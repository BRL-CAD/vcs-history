head	11.191;
access;
symbols
	ansi-20040405-merged:11.183.2.3
	postmerge-20040405-ansi:11.189
	premerge-20040404-ansi:11.188
	postmerge-autoconf:11.188
	autoconf-freeze:11.187.4.2
	premerge-autoconf:11.188
	postmerge-20040315-windows:11.188
	premerge-20040315-windows:11.188
	windows-20040315-freeze:11.183.4.1
	autoconf-20031203:11.187
	autoconf-20031202:11.187
	autoconf-branch:11.187.0.4
	phong-branch:11.187.0.2
	photonmap-branch:11.186.0.2
	rel-6-1-DP:11.184
	windows-branch:11.183.0.4
	rel-6-0-2:11.180
	ansi-branch:11.183.0.2
	rel-6-0-1-branch:11.180.0.2
	hartley-6-0-post:11.182
	hartley-6-0-pre:11.181
	rel-6-0-1:11.180
	rel-6-0:11.179
	rel-5-4:11.144.2.2
	offsite-5-3-pre:11.160
	rel-5-3:11.144.2.2
	rel-5-2:11.144
	rel-5-1-branch:11.144.0.2
	rel-5-1:11.144
	rel-5-0:11.106
	rel-5-0-beta:11.100
	rel-4-5:11.85
	ctj-4-5-post:11.72
	ctj-4-5-pre:11.72
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.5
	rel-1-10:4.1
	rt-2:2.11;
locks; strict;
comment	@ * @;


11.191
date	2004.05.21.17.47.42;	author morrison;	state dead;
branches;
next	11.190;

11.190
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.189;

11.189
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.188;

11.188
date	2004.02.02.17.39.32;	author morrison;	state Exp;
branches;
next	11.187;

11.187
date	2003.08.06.12.26.21;	author jra;	state Exp;
branches
	11.187.4.1;
next	11.186;

11.186
date	2003.04.02.15.23.54;	author jra;	state Exp;
branches
	11.186.2.1;
next	11.185;

11.185
date	2002.11.04.19.25.45;	author jra;	state Exp;
branches;
next	11.184;

11.184
date	2002.09.26.19.50.23;	author jra;	state Exp;
branches;
next	11.183;

11.183
date	2002.08.20.17.08.23;	author jra;	state Exp;
branches
	11.183.2.1
	11.183.4.1;
next	11.182;

11.182
date	2002.08.15.20.55.34;	author hartley;	state Exp;
branches;
next	11.181;

11.181
date	2002.08.11.02.06.55;	author morrison;	state Exp;
branches;
next	11.180;

11.180
date	2002.06.03.19.13.45;	author jra;	state Exp;
branches;
next	11.179;

11.179
date	2001.11.15.22.55.54;	author bparker;	state Exp;
branches;
next	11.178;

11.178
date	2001.11.05.21.20.06;	author morrison;	state Exp;
branches;
next	11.177;

11.177
date	2001.11.01.22.01.23;	author bparker;	state Exp;
branches;
next	11.176;

11.176
date	2001.10.30.02.16.18;	author jra;	state Exp;
branches;
next	11.175;

11.175
date	2001.10.02.19.24.32;	author jra;	state Exp;
branches;
next	11.174;

11.174
date	2001.09.06.16.24.03;	author bparker;	state Exp;
branches;
next	11.173;

11.173
date	2001.09.06.15.57.34;	author bparker;	state Exp;
branches;
next	11.172;

11.172
date	2001.08.14.18.32.57;	author bparker;	state Exp;
branches;
next	11.171;

11.171
date	2001.08.02.13.21.32;	author bparker;	state Exp;
branches;
next	11.170;

11.170
date	2001.06.26.20.55.03;	author bparker;	state Exp;
branches;
next	11.169;

11.169
date	2001.06.05.15.51.41;	author bparker;	state Exp;
branches;
next	11.168;

11.168
date	2001.06.01.19.23.24;	author bparker;	state Exp;
branches;
next	11.167;

11.167
date	2001.05.16.21.38.08;	author morrison;	state Exp;
branches;
next	11.166;

11.166
date	2001.05.02.19.35.38;	author jra;	state Exp;
branches;
next	11.165;

11.165
date	2001.04.25.12.44.46;	author jra;	state Exp;
branches;
next	11.164;

11.164
date	2001.04.05.19.35.44;	author morrison;	state Exp;
branches;
next	11.163;

11.163
date	2001.04.02.21.38.19;	author morrison;	state Exp;
branches;
next	11.162;

11.162
date	2001.03.31.01.57.22;	author morrison;	state Exp;
branches;
next	11.161;

11.161
date	2001.03.23.22.35.55;	author butler;	state Exp;
branches;
next	11.160;

11.160
date	2001.02.23.21.44.27;	author bparker;	state Exp;
branches;
next	11.159;

11.159
date	2000.11.09.15.39.17;	author jra;	state Exp;
branches;
next	11.158;

11.158
date	2000.10.24.19.56.43;	author mike;	state Exp;
branches;
next	11.157;

11.157
date	2000.10.24.19.05.06;	author mike;	state Exp;
branches;
next	11.156;

11.156
date	2000.10.24.15.01.55;	author mike;	state Exp;
branches;
next	11.155;

11.155
date	2000.10.20.05.04.38;	author mike;	state Exp;
branches;
next	11.154;

11.154
date	2000.10.18.14.23.46;	author bparker;	state Exp;
branches;
next	11.153;

11.153
date	2000.09.09.05.02.54;	author mike;	state Exp;
branches;
next	11.152;

11.152
date	2000.09.09.04.30.55;	author mike;	state Exp;
branches;
next	11.151;

11.151
date	2000.09.08.05.55.48;	author mike;	state Exp;
branches;
next	11.150;

11.150
date	2000.08.25.01.36.38;	author mike;	state Exp;
branches;
next	11.149;

11.149
date	2000.08.19.03.10.45;	author mike;	state Exp;
branches;
next	11.148;

11.148
date	2000.08.11.02.41.34;	author mike;	state Exp;
branches;
next	11.147;

11.147
date	2000.06.29.14.55.38;	author butler;	state Exp;
branches;
next	11.146;

11.146
date	2000.06.28.17.40.22;	author mike;	state Exp;
branches;
next	11.145;

11.145
date	2000.06.28.17.11.24;	author mike;	state Exp;
branches;
next	11.144;

11.144
date	2000.06.20.19.16.54;	author jra;	state Exp;
branches
	11.144.2.1;
next	11.143;

11.143
date	2000.06.20.18.29.01;	author jra;	state Exp;
branches;
next	11.142;

11.142
date	2000.06.08.21.28.03;	author bparker;	state Exp;
branches;
next	11.141;

11.141
date	2000.06.07.20.41.29;	author bparker;	state Exp;
branches;
next	11.140;

11.140
date	2000.06.06.19.42.14;	author bparker;	state Exp;
branches;
next	11.139;

11.139
date	2000.06.05.21.51.18;	author bparker;	state Exp;
branches;
next	11.138;

11.138
date	2000.06.05.20.43.43;	author mike;	state Exp;
branches;
next	11.137;

11.137
date	2000.06.02.20.22.16;	author bparker;	state Exp;
branches;
next	11.136;

11.136
date	2000.03.31.02.57.05;	author mike;	state Exp;
branches;
next	11.135;

11.135
date	2000.03.29.22.24.30;	author bparker;	state Exp;
branches;
next	11.134;

11.134
date	2000.03.17.15.14.16;	author jra;	state Exp;
branches;
next	11.133;

11.133
date	2000.03.16.13.39.28;	author jra;	state Exp;
branches;
next	11.132;

11.132
date	2000.03.02.14.48.28;	author jra;	state Exp;
branches;
next	11.131;

11.131
date	2000.02.14.21.49.08;	author bparker;	state Exp;
branches;
next	11.130;

11.130
date	2000.01.31.13.43.27;	author jra;	state Exp;
branches;
next	11.129;

11.129
date	2000.01.14.15.55.23;	author bparker;	state Exp;
branches;
next	11.128;

11.128
date	2000.01.07.21.46.32;	author bparker;	state Exp;
branches;
next	11.127;

11.127
date	2000.01.06.04.37.00;	author mike;	state Exp;
branches;
next	11.126;

11.126
date	99.12.30.19.44.12;	author jra;	state Exp;
branches;
next	11.125;

11.125
date	99.12.20.20.18.40;	author jra;	state Exp;
branches;
next	11.124;

11.124
date	99.12.20.19.59.13;	author jra;	state Exp;
branches;
next	11.123;

11.123
date	99.12.17.16.24.27;	author bparker;	state Exp;
branches;
next	11.122;

11.122
date	99.12.15.15.29.36;	author jra;	state Exp;
branches;
next	11.121;

11.121
date	99.12.10.21.02.54;	author jra;	state Exp;
branches;
next	11.120;

11.120
date	99.12.09.20.31.06;	author jra;	state Exp;
branches;
next	11.119;

11.119
date	99.12.09.19.20.59;	author jra;	state Exp;
branches;
next	11.118;

11.118
date	99.12.06.20.21.44;	author jra;	state Exp;
branches;
next	11.117;

11.117
date	99.12.02.14.18.55;	author jra;	state Exp;
branches;
next	11.116;

11.116
date	99.12.01.21.29.57;	author jra;	state Exp;
branches;
next	11.115;

11.115
date	99.12.01.19.05.28;	author jra;	state Exp;
branches;
next	11.114;

11.114
date	99.11.26.19.44.06;	author jra;	state Exp;
branches;
next	11.113;

11.113
date	99.11.19.02.34.39;	author mike;	state Exp;
branches;
next	11.112;

11.112
date	99.11.18.03.52.15;	author mike;	state Exp;
branches;
next	11.111;

11.111
date	99.11.15.17.15.07;	author jra;	state Exp;
branches;
next	11.110;

11.110
date	99.11.08.15.14.40;	author jra;	state Exp;
branches;
next	11.109;

11.109
date	99.10.19.20.34.35;	author jra;	state Exp;
branches;
next	11.108;

11.108
date	99.10.14.16.18.32;	author bparker;	state Exp;
branches;
next	11.107;

11.107
date	99.10.08.21.44.26;	author bparker;	state Exp;
branches;
next	11.106;

11.106
date	99.09.09.20.35.53;	author bparker;	state Exp;
branches;
next	11.105;

11.105
date	99.09.01.18.55.10;	author bparker;	state Exp;
branches;
next	11.104;

11.104
date	99.08.20.21.03.51;	author bparker;	state Exp;
branches;
next	11.103;

11.103
date	99.07.08.17.41.18;	author bparker;	state Exp;
branches;
next	11.102;

11.102
date	99.06.25.20.30.44;	author bparker;	state Exp;
branches;
next	11.101;

11.101
date	99.06.14.22.18.42;	author bparker;	state Exp;
branches;
next	11.100;

11.100
date	99.05.06.17.55.21;	author bparker;	state Exp;
branches;
next	11.99;

11.99
date	99.05.03.16.47.11;	author bparker;	state Exp;
branches;
next	11.98;

11.98
date	99.03.09.21.38.56;	author bparker;	state Exp;
branches;
next	11.97;

11.97
date	99.02.08.16.32.58;	author bparker;	state Exp;
branches;
next	11.96;

11.96
date	99.01.21.18.31.21;	author bparker;	state Exp;
branches;
next	11.95;

11.95
date	99.01.12.18.16.41;	author bparker;	state Exp;
branches;
next	11.94;

11.94
date	98.12.09.22.35.32;	author bparker;	state Exp;
branches;
next	11.93;

11.93
date	98.11.06.22.32.40;	author bparker;	state Exp;
branches;
next	11.92;

11.92
date	98.08.13.12.24.46;	author bparker;	state Exp;
branches;
next	11.91;

11.91
date	98.07.15.16.37.00;	author bparker;	state Exp;
branches;
next	11.90;

11.90
date	98.06.11.19.41.43;	author bparker;	state Exp;
branches;
next	11.89;

11.89
date	98.04.07.14.08.35;	author jra;	state Exp;
branches;
next	11.88;

11.88
date	98.03.19.15.55.50;	author jra;	state Exp;
branches;
next	11.87;

11.87
date	98.03.19.15.05.04;	author jra;	state Exp;
branches;
next	11.86;

11.86
date	98.02.26.16.12.03;	author bparker;	state Exp;
branches;
next	11.85;

11.85
date	98.01.28.16.15.25;	author bparker;	state Exp;
branches;
next	11.84;

11.84
date	98.01.21.16.27.53;	author jra;	state Exp;
branches;
next	11.83;

11.83
date	97.12.23.14.24.27;	author bparker;	state Exp;
branches;
next	11.82;

11.82
date	97.11.26.21.32.48;	author bparker;	state Exp;
branches;
next	11.81;

11.81
date	97.11.06.20.00.03;	author bparker;	state Exp;
branches;
next	11.80;

11.80
date	97.09.08.18.51.07;	author bparker;	state Exp;
branches;
next	11.79;

11.79
date	97.09.03.14.18.48;	author bparker;	state Exp;
branches;
next	11.78;

11.78
date	97.07.30.19.55.49;	author bparker;	state Exp;
branches;
next	11.77;

11.77
date	97.07.28.20.10.14;	author bparker;	state Exp;
branches;
next	11.76;

11.76
date	97.07.25.20.49.26;	author bparker;	state Exp;
branches;
next	11.75;

11.75
date	97.07.17.20.54.17;	author bparker;	state Exp;
branches;
next	11.74;

11.74
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.73;

11.73
date	97.06.25.13.41.47;	author bparker;	state Exp;
branches;
next	11.72;

11.72
date	97.05.27.22.00.10;	author butler;	state Exp;
branches;
next	11.71;

11.71
date	97.05.23.00.59.44;	author butler;	state Exp;
branches;
next	11.70;

11.70
date	97.05.22.09.29.07;	author butler;	state Exp;
branches;
next	11.69;

11.69
date	97.05.13.12.50.33;	author jra;	state Exp;
branches;
next	11.68;

11.68
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.67;

11.67
date	97.04.23.18.30.43;	author bparker;	state Exp;
branches;
next	11.66;

11.66
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.65;

11.65
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.64;

11.64
date	97.03.12.20.45.46;	author jra;	state Exp;
branches;
next	11.63;

11.63
date	97.03.06.21.42.59;	author bparker;	state Exp;
branches;
next	11.62;

11.62
date	97.02.28.21.36.17;	author bparker;	state Exp;
branches;
next	11.61;

11.61
date	97.02.14.22.09.01;	author bparker;	state Exp;
branches;
next	11.60;

11.60
date	97.01.29.23.15.45;	author bparker;	state Exp;
branches;
next	11.59;

11.59
date	97.01.24.21.02.48;	author bparker;	state Exp;
branches;
next	11.58;

11.58
date	97.01.08.21.16.05;	author jra;	state Exp;
branches;
next	11.57;

11.57
date	97.01.07.22.38.18;	author bparker;	state Exp;
branches;
next	11.56;

11.56
date	97.01.03.21.45.25;	author bparker;	state Exp;
branches;
next	11.55;

11.55
date	97.01.02.21.55.37;	author bparker;	state Exp;
branches;
next	11.54;

11.54
date	97.01.02.19.36.55;	author bparker;	state Exp;
branches;
next	11.53;

11.53
date	96.12.30.22.33.40;	author bparker;	state Exp;
branches;
next	11.52;

11.52
date	96.12.23.19.59.00;	author jra;	state Exp;
branches;
next	11.51;

11.51
date	96.12.20.22.52.00;	author bparker;	state Exp;
branches;
next	11.50;

11.50
date	96.12.19.22.08.35;	author bparker;	state Exp;
branches;
next	11.49;

11.49
date	96.12.19.16.35.02;	author jra;	state Exp;
branches;
next	11.48;

11.48
date	96.12.18.22.21.44;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	96.12.18.17.13.40;	author jra;	state Exp;
branches;
next	11.46;

11.46
date	96.12.17.21.28.16;	author bparker;	state Exp;
branches;
next	11.45;

11.45
date	96.12.13.23.10.54;	author bparker;	state Exp;
branches;
next	11.44;

11.44
date	96.12.12.22.10.09;	author bparker;	state Exp;
branches;
next	11.43;

11.43
date	96.12.11.22.40.57;	author bparker;	state Exp;
branches;
next	11.42;

11.42
date	96.12.10.21.45.18;	author bparker;	state Exp;
branches;
next	11.41;

11.41
date	96.12.09.23.01.26;	author bparker;	state Exp;
branches;
next	11.40;

11.40
date	96.11.19.20.31.16;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	96.11.19.19.09.10;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	96.11.01.22.17.37;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	96.10.09.16.59.31;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	96.10.04.15.03.03;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	96.09.25.20.16.42;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	96.09.23.18.28.35;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	96.09.17.21.18.06;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	96.08.21.19.42.46;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	96.08.21.19.33.41;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	96.08.21.14.18.29;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	96.07.30.21.32.37;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	96.07.09.21.37.03;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	96.07.03.13.57.30;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	96.05.24.18.34.21;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	96.03.22.18.31.14;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	96.03.01.19.19.31;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	96.02.09.22.15.02;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	96.01.05.22.08.48;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	95.12.01.02.51.31;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	95.11.27.15.47.37;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	95.11.07.22.56.43;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	95.08.03.14.42.29;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	95.07.28.20.31.52;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	95.07.20.22.38.10;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	95.07.18.22.53.50;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	95.07.17.20.18.03;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	95.07.14.19.10.11;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	95.03.08.16.38.55;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.02.20.16.55.15;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.02.18.03.08.51;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.01.19.16.20.42;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.01.17.13.04.39;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.01.06.09.29.14;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.06;	author mike;	state Rel4_4;
branches;
next	10.73;

10.73
date	95.01.03.14.31.09;	author gdurf;	state Exp;
branches;
next	10.72;

10.72
date	94.12.23.16.17.28;	author gdurf;	state Exp;
branches;
next	10.71;

10.71
date	94.12.23.14.30.56;	author gdurf;	state Exp;
branches;
next	10.70;

10.70
date	94.12.23.14.29.10;	author gdurf;	state Exp;
branches;
next	10.69;

10.69
date	94.12.20.16.36.23;	author jra;	state Exp;
branches;
next	10.68;

10.68
date	94.12.16.19.36.43;	author gdurf;	state Exp;
branches;
next	10.67;

10.67
date	94.11.28.13.29.52;	author jra;	state Exp;
branches;
next	10.66;

10.66
date	94.11.22.17.09.07;	author jra;	state Exp;
branches;
next	10.65;

10.65
date	94.11.21.16.32.39;	author jra;	state Exp;
branches;
next	10.64;

10.64
date	94.11.18.16.25.25;	author jra;	state Exp;
branches;
next	10.63;

10.63
date	94.11.17.17.07.23;	author jra;	state Exp;
branches;
next	10.62;

10.62
date	94.11.16.16.59.00;	author jra;	state Exp;
branches;
next	10.61;

10.61
date	94.11.15.14.58.18;	author jra;	state Exp;
branches;
next	10.60;

10.60
date	94.11.10.12.06.08;	author jra;	state Exp;
branches;
next	10.59;

10.59
date	94.10.11.09.31.03;	author jra;	state Exp;
branches;
next	10.58;

10.58
date	94.10.05.16.40.32;	author jra;	state Exp;
branches;
next	10.57;

10.57
date	94.10.05.16.23.48;	author jra;	state Exp;
branches;
next	10.56;

10.56
date	94.09.26.10.21.59;	author jra;	state Exp;
branches;
next	10.55;

10.55
date	94.09.23.16.38.24;	author jra;	state Exp;
branches;
next	10.54;

10.54
date	94.09.02.15.56.10;	author jra;	state Exp;
branches;
next	10.53;

10.53
date	94.09.01.16.36.13;	author jra;	state Exp;
branches;
next	10.52;

10.52
date	94.08.31.17.07.51;	author jra;	state Exp;
branches;
next	10.51;

10.51
date	94.08.30.16.47.06;	author jra;	state Exp;
branches;
next	10.50;

10.50
date	94.08.27.03.02.03;	author mike;	state Exp;
branches;
next	10.49;

10.49
date	94.08.09.15.06.31;	author gdurf;	state Exp;
branches;
next	10.48;

10.48
date	94.06.22.18.24.35;	author gdurf;	state Exp;
branches;
next	10.47;

10.47
date	94.06.03.16.44.53;	author gdurf;	state Exp;
branches;
next	10.46;

10.46
date	94.06.01.17.10.50;	author gdurf;	state Exp;
branches;
next	10.45;

10.45
date	94.06.01.16.54.01;	author gdurf;	state Exp;
branches;
next	10.44;

10.44
date	94.06.01.16.30.11;	author gdurf;	state Exp;
branches;
next	10.43;

10.43
date	94.03.16.19.53.59;	author cjohnson;	state Exp;
branches;
next	10.42;

10.42
date	94.03.09.22.31.00;	author mike;	state Exp;
branches;
next	10.41;

10.41
date	94.02.23.03.22.39;	author mike;	state Exp;
branches;
next	10.40;

10.40
date	94.02.23.02.48.12;	author pjt;	state Exp;
branches;
next	10.39;

10.39
date	94.01.24.16.16.46;	author pjt;	state Exp;
branches;
next	10.38;

10.38
date	94.01.13.19.02.30;	author mike;	state Exp;
branches;
next	10.37;

10.37
date	94.01.12.17.27.49;	author mike;	state Exp;
branches;
next	10.36;

10.36
date	94.01.12.02.46.34;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	94.01.11.19.08.44;	author mike;	state Exp;
branches;
next	10.34;

10.34
date	94.01.10.16.09.01;	author mike;	state Exp;
branches;
next	10.33;

10.33
date	93.11.10.04.08.40;	author cjohnson;	state Exp;
branches;
next	10.32;

10.32
date	92.06.19.00.40.53;	author mike;	state Exp;
branches;
next	10.31;

10.31
date	92.06.12.23.53.42;	author mike;	state Exp;
branches;
next	10.30;

10.30
date	92.05.22.17.33.16;	author butler;	state Exp;
branches;
next	10.29;

10.29
date	92.04.23.10.53.14;	author mmark;	state Exp;
branches;
next	10.28;

10.28
date	92.04.18.10.56.13;	author mmark;	state Exp;
branches;
next	10.27;

10.27
date	92.03.24.14.23.22;	author mmark;	state Exp;
branches;
next	10.26;

10.26
date	92.03.23.22.23.47;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	92.03.20.19.16.19;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	92.03.20.15.41.32;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	92.03.17.20.53.53;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	92.02.14.16.28.26;	author mmark;	state Exp;
branches;
next	10.21;

10.21
date	92.02.14.14.58.51;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	92.02.05.23.12.52;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	92.02.05.19.37.00;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	92.02.05.17.27.03;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	92.02.05.15.41.24;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	92.02.05.15.19.30;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	92.02.05.13.41.08;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	92.02.05.13.29.47;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	92.02.05.13.09.49;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	92.02.04.02.07.14;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	92.02.03.22.09.07;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	91.12.20.02.28.13;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	91.12.20.01.09.44;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	91.12.19.03.22.55;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	91.12.19.03.16.38;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	91.12.19.03.12.27;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	91.12.18.08.10.06;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	91.12.18.07.56.14;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	91.12.18.04.28.28;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.12.02.16.57.39;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.40;	author mike;	state Rel4_0;
branches;
next	9.8;

9.8
date	91.07.17.23.30.25;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.01.26.03.23.04;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.12.15.04.18.49;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.08.05.54.45;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.04.21.06.05.58;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.10.27.21.26.59;	author phil;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.24.34;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.03.04;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.04.06.20.39.57;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.03.06.17.40.57;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.16.22.56.06;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.19.48;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.36.46;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.09.20.01.33.08;	author reschly;	state Exp;
branches;
next	7.4;

7.4
date	88.05.15.23.05.06;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	87.11.14.05.02.42;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.05.46;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.00.40;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.09.26.01.02.11;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.08.03.53;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.20.33;	author mike;	state Rel;
branches;
next	4.5;

4.5
date	87.02.13.00.07.31;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.02.11.05.34.33;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.11.05.31.44;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.11.04.59.32;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.21.30;	author mike;	state Rel1;
branches;
next	2.23;

2.23
date	86.12.28.23.02.33;	author mike;	state Exp;
branches;
next	2.22;

2.22
date	86.10.12.03.24.06;	author mike;	state Exp;
branches;
next	2.21;

2.21
date	86.10.06.22.45.18;	author mike;	state Exp;
branches;
next	2.20;

2.20
date	86.10.06.22.02.57;	author mike;	state Exp;
branches;
next	2.19;

2.19
date	86.09.10.01.39.05;	author mike;	state Exp;
branches;
next	2.18;

2.18
date	86.08.12.06.49.29;	author mike;	state Exp;
branches;
next	2.17;

2.17
date	86.07.18.02.41.44;	author mike;	state Exp;
branches;
next	2.16;

2.16
date	86.07.17.17.37.54;	author mike;	state Exp;
branches;
next	2.15;

2.15
date	86.03.14.20.42.02;	author mike;	state Exp;
branches;
next	2.14;

2.14
date	86.03.10.21.38.16;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	85.09.27.19.11.55;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	85.09.14.05.36.26;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	85.08.26.17.16.04;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	85.08.07.05.18.54;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	85.07.30.01.17.41;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	85.06.06.22.33.19;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.05.29.23.17.14;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.05.29.15.25.11;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.05.10.00.54.22;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.05.03.01.25.34;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.03.15.05.05.11;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.12.04.06.54;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.56.00;	author mike;	state Prod;
branches;
next	1.7;

1.7
date	85.03.08.20.53.48;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	85.02.01.00.50.28;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	85.01.16.03.15.11;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.01.16.01.57.55;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.11.22.06.56.43;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.20.04.24.17;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.50.33;	author mike;	state Exp;
branches;
next	;

11.144.2.1
date	2000.11.09.14.38.54;	author jra;	state Exp;
branches;
next	11.144.2.2;

11.144.2.2
date	2001.02.23.21.43.23;	author bparker;	state Exp;
branches;
next	;

11.183.2.1
date	2002.09.19.18.02.01;	author morrison;	state Exp;
branches;
next	11.183.2.2;

11.183.2.2
date	2003.01.31.00.11.54;	author morrison;	state Exp;
branches;
next	11.183.2.3;

11.183.2.3
date	2004.03.17.21.21.57;	author morrison;	state Exp;
branches;
next	;

11.183.4.1
date	2004.03.11.23.46.34;	author morrison;	state Exp;
branches;
next	;

11.186.2.1
date	2003.08.26.14.03.43;	author justin;	state Exp;
branches;
next	;

11.187.4.1
date	2004.02.12.18.34.14;	author erikg;	state Exp;
branches;
next	11.187.4.2;

11.187.4.2
date	2004.03.15.14.07.37;	author erikg;	state Exp;
branches;
next	;


desc
@Edit a Solid
@


11.191
log
@moved to src/mged/
@
text
@/*
 *			E D S O L . C
 *
 * Functions -
 *	init_sedit	set up for a Solid Edit
 *	sedit		Apply Solid Edit transformation(s)
 *	pscale		Partial scaling of a solid
 *	init_oedit	set up for object edit?
 *	f_dextrude()	extrude a drawing (nmg wire loop) to create a solid
 *	f_eqn		change face of GENARB8 to new equation
 *
 *  Authors -
 *	Keith A. Applin
 *	Bob Suckling
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/edsol.c,v 11.190 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "nurb.h"
#include "wdb.h"

#include "./ged.h"
#include "./mged_solid.h"
#include "./sedit.h"
#include "./mged_dm.h"

#if 1
#define TRY_EDIT_NEW_WAY
#endif

extern struct bn_tol		mged_tol;	/* from ged.c */

extern short earb4[5][18];
extern short earb5[9][18];
extern short earb6[10][18];
extern short earb7[12][18];
extern short earb8[12][18];

static void	arb8_edge(int arg), ars_ed(int arg), ell_ed(int arg), tgc_ed(int arg), tor_ed(int arg), spline_ed(int arg);
static void	nmg_ed(int arg), pipe_ed(int arg), vol_ed(int arg), ebm_ed(int arg), dsp_ed(int arg), cline_ed(int arg), bot_ed(int arg), extr_ed(int arg);
static void	rpc_ed(int arg), rhc_ed(int arg), part_ed(int arg), epa_ed(int arg), ehy_ed(int arg), eto_ed(int arg);
static void	superell_ed(int arg);

static void	arb7_edge(int arg), arb6_edge(int arg), arb5_edge(int arg), arb4_point(int arg);
static void	arb8_mv_face(int arg), arb7_mv_face(int arg), arb6_mv_face(int arg);
static void	arb5_mv_face(int arg), arb4_mv_face(int arg), arb8_rot_face(int arg), arb7_rot_face(int arg);
static void 	arb6_rot_face(int arg), arb5_rot_face(int arg), arb4_rot_face(int arg), arb_control(int arg);
static void	init_sedit_vars(void), init_oedit_vars(void), init_oedit_guts(void);

void pscale(void);
void update_edit_absolute_tran(fastf_t *view_pos);
void set_e_axes_pos(int both);
point_t e_axes_pos;
point_t curr_e_axes_pos;
short int fixv;		/* used in ECMD_ARB_ROTATE_FACE,f_eqn(): fixed vertex */

MGED_EXTERN( struct wdb_pipept *find_pipept_nearest_pt, (const struct bu_list *pipe_hd, const point_t pt ) );
MGED_EXTERN( void split_pipept, (struct bu_list *pipe_hd, struct wdb_pipept *ps, point_t pt ) );
MGED_EXTERN( struct wdb_pipept *del_pipept, (struct wdb_pipept *ps ) );
MGED_EXTERN( struct wdb_pipept *add_pipept, (struct rt_pipe_internal *pipe, struct wdb_pipept *pp, const point_t new_pt ) );

/* data for solid editing */
int			sedraw;	/* apply solid editing changes */

struct rt_db_internal	es_int;
struct rt_db_internal	es_int_orig;

int	es_type;		/* COMGEOM solid type */
int     es_edflag;		/* type of editing for this solid */
int     es_edclass;		/* type of editing class for this solid */
fastf_t	es_scale;		/* scale factor */
fastf_t	es_peqn[7][4];		/* ARBs defining plane equations */
fastf_t	es_m[3];		/* edge(line) slope */
mat_t	es_mat;			/* accumulated matrix of path */ 
mat_t 	es_invmat;		/* inverse of es_mat   KAA */

int bot_verts[3];		/* vertices for the BOT solid */

point_t	es_keypoint;		/* center of editing xforms */
char	*es_keytag;		/* string identifying the keypoint */
int	es_keyfixed;		/* keypoint specified by user? */

vect_t		es_para;	/* keyboard input param. Only when inpara set.  */
int		inpara;		/* es_para valid.  es_mvalid must = 0 */
static vect_t	es_mparam;	/* mouse input param.  Only when es_mvalid set */
static int	es_mvalid;	/* es_mparam valid.  inpara must = 0 */

static int	spl_surfno;	/* What surf & ctl pt to edit on spline */
static int	spl_ui;
static int	spl_vi;

static int	es_ars_crv;	/* curve and column identifying selected ARS point */
static int	es_ars_col;
static point_t	es_pt;		/* coordinates of selected ARS point */

static struct edgeuse	*es_eu=(struct edgeuse *)NULL;	/* Currently selected NMG edgeuse */
static struct loopuse	*lu_copy=(struct loopuse*)NULL;	/* copy of loop to be extruded */
static plane_t		lu_pl;	/* plane equation for loop to be extruded */
static struct shell	*es_s=(struct shell *)NULL;	/* Shell where extrusion is to end up */
static point_t		lu_keypoint;	/* keypoint of lu_copy for extrusion */

static struct wdb_pipept *es_pipept=(struct wdb_pipept *)NULL; /* Currently selected PIPE segment */

/*  These values end up in es_menu, as do ARB vertex numbers */
int	es_menu;		/* item selected from menu */
#define MENU_TOR_R1		21
#define MENU_TOR_R2		22
#define MENU_TGC_ROT_H		23
#define MENU_TGC_ROT_AB 	24
#define	MENU_TGC_MV_H		25
#define MENU_TGC_MV_HH		26
#define MENU_TGC_SCALE_H	27
#define	MENU_TGC_SCALE_H_V	28
#define MENU_TGC_SCALE_A	29
#define MENU_TGC_SCALE_B	30
#define MENU_TGC_SCALE_C	31
#define MENU_TGC_SCALE_D	32
#define MENU_TGC_SCALE_AB	33
#define MENU_TGC_SCALE_CD	34
#define MENU_TGC_SCALE_ABCD	35
#define MENU_ARB_MV_EDGE	36
#define MENU_ARB_MV_FACE	37
#define MENU_ARB_ROT_FACE	38
#define MENU_ELL_SCALE_A	39
#define MENU_ELL_SCALE_B	40
#define MENU_ELL_SCALE_C	41
#define MENU_ELL_SCALE_ABC	42
#define MENU_RPC_B		43
#define MENU_RPC_H		44
#define MENU_RPC_R		45
#define MENU_RHC_B		46
#define MENU_RHC_H		47
#define MENU_RHC_R		48
#define MENU_RHC_C		49
#define MENU_EPA_H		50
#define MENU_EPA_R1		51
#define MENU_EPA_R2		52
#define MENU_EHY_H		53
#define MENU_EHY_R1		54
#define MENU_EHY_R2		55
#define MENU_EHY_C		56
#define MENU_ETO_R		57
#define MENU_ETO_RD		58
#define MENU_ETO_SCALE_C	59
#define MENU_ETO_ROT_C		60
#define	MENU_PIPE_SELECT	61
#define	MENU_PIPE_NEXT_PT	62
#define MENU_PIPE_PREV_PT	63
#define MENU_PIPE_SPLIT		64
#define MENU_PIPE_PT_OD		65
#define MENU_PIPE_PT_ID		66
#define	MENU_PIPE_SCALE_OD	67
#define	MENU_PIPE_SCALE_ID	68
#define	MENU_PIPE_ADD_PT	69
#define MENU_PIPE_INS_PT	70
#define MENU_PIPE_DEL_PT	71
#define	MENU_PIPE_MOV_PT	72
#define	MENU_PIPE_PT_RADIUS	73
#define	MENU_PIPE_SCALE_RADIUS	74
#define	MENU_VOL_FNAME		75
#define	MENU_VOL_FSIZE		76
#define	MENU_VOL_CSIZE		77
#define	MENU_VOL_THRESH_LO	78
#define	MENU_VOL_THRESH_HI	79
#define	MENU_EBM_FNAME		80
#define	MENU_EBM_FSIZE		81
#define	MENU_EBM_HEIGHT		82
#define	MENU_DSP_FNAME		83
#define	MENU_DSP_FSIZE		84	/* Not implemented yet */
#define	MENU_DSP_SCALE_X	85
#define	MENU_DSP_SCALE_Y	86
#define	MENU_DSP_SCALE_ALT	87
#define MENU_PART_H		88
#define MENU_PART_v		89
#define MENU_PART_h		90
#define MENU_BOT_PICKV		91
#define	MENU_BOT_PICKE		92
#define	MENU_BOT_PICKT		93
#define	MENU_BOT_MOVEV		94
#define	MENU_BOT_MOVEE		95
#define	MENU_BOT_MOVET		96
#define	MENU_BOT_MODE		97
#define	MENU_BOT_ORIENT		98
#define	MENU_BOT_THICK		99
#define	MENU_BOT_FMODE		100
#define MENU_BOT_DELETE_TRI	101
#define MENU_BOT_FLAGS		102
#define MENU_EXTR_SCALE_H	103
#define MENU_EXTR_MOV_H		104
#define MENU_EXTR_ROT_H		105
#define MENU_EXTR_SKT_NAME	106
#define	MENU_CLINE_SCALE_H	107
#define	MENU_CLINE_MOVE_H	108
#define MENU_CLINE_SCALE_R	109
#define	MENU_CLINE_SCALE_T	110
#define MENU_TGC_SCALE_H_CD	111
#define	MENU_TGC_SCALE_H_V_AB	112
#define MENU_SUPERELL_SCALE_A	113
#define MENU_SUPERELL_SCALE_B	114
#define MENU_SUPERELL_SCALE_C	115
#define MENU_SUPERELL_SCALE_ABC	116

extern int arb_faces[5][24];	/* from edarb.c */

struct menu_item cline_menu[] = {
	{ "CLINE MENU",		(void (*)())NULL, 0 },
	{ "Set H",		cline_ed, ECMD_CLINE_SCALE_H },
	{ "Move End H",		cline_ed, ECMD_CLINE_MOVE_H },
	{ "Set R",		cline_ed, ECMD_CLINE_SCALE_R },
	{ "Set plate thickness", cline_ed, ECMD_CLINE_SCALE_T },
	{ "", (void (*)())NULL, 0 }
};

struct  menu_item extr_menu[] = {
	{ "EXTRUSION MENU",	(void (*)())NULL, 0 },
	{ "Set H",		extr_ed, ECMD_EXTR_SCALE_H },
	{ "Move End H",		extr_ed, ECMD_EXTR_MOV_H },
	{ "Rotate H",		extr_ed, ECMD_EXTR_ROT_H },
	{ "Referenced Sketch",	extr_ed, ECMD_EXTR_SKT_NAME },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item ars_pick_menu[] = {
	{ "ARS PICK MENU", (void (*)())NULL, 0 },
	{ "Pick Vertex", ars_ed, ECMD_ARS_PICK },
	{ "Next Vertex", ars_ed, ECMD_ARS_NEXT_PT },
	{ "Prev Vertex", ars_ed, ECMD_ARS_PREV_PT },
	{ "Next Curve", ars_ed, ECMD_ARS_NEXT_CRV },
	{ "Prev Curve", ars_ed, ECMD_ARS_PREV_CRV },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item ars_menu[] = {
	{ "ARS MENU", (void (*)())NULL, 0 },
	{ "Pick Vertex", ars_ed, ECMD_ARS_PICK_MENU },
	{ "Move Point", ars_ed, ECMD_ARS_MOVE_PT },
	{ "Delete Curve", ars_ed, ECMD_ARS_DEL_CRV },
	{ "Delete Column", ars_ed, ECMD_ARS_DEL_COL },
	{ "Dup Curve", ars_ed, ECMD_ARS_DUP_CRV },
	{ "Dup Column", ars_ed, ECMD_ARS_DUP_COL },
	{ "Move Curve", ars_ed, ECMD_ARS_MOVE_CRV },
	{ "Move Column", ars_ed, ECMD_ARS_MOVE_COL },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  edge8_menu[] = {
	{ "ARB8 EDGES", (void (*)())NULL, 0 },
	{ "Move Edge 12", arb8_edge, 0 },
	{ "Move Edge 23", arb8_edge, 1 },
	{ "Move Edge 34", arb8_edge, 2 },
	{ "Move Edge 14", arb8_edge, 3 },
	{ "Move Edge 15", arb8_edge, 4 },
	{ "Move Edge 26", arb8_edge, 5 },
	{ "Move Edge 56", arb8_edge, 6 },
	{ "Move Edge 67", arb8_edge, 7 },
	{ "Move Edge 78", arb8_edge, 8 },
	{ "Move Edge 58", arb8_edge, 9 },
	{ "Move Edge 37", arb8_edge, 10 },
	{ "Move Edge 48", arb8_edge, 11 },
	{ "RETURN",       arb8_edge, 12 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  edge7_menu[] = {
	{ "ARB7 EDGES", (void (*)())NULL, 0 },
	{ "Move Edge 12", arb7_edge, 0 },
	{ "Move Edge 23", arb7_edge, 1 },
	{ "Move Edge 34", arb7_edge, 2 },
	{ "Move Edge 14", arb7_edge, 3 },
	{ "Move Edge 15", arb7_edge, 4 },
	{ "Move Edge 26", arb7_edge, 5 },
	{ "Move Edge 56", arb7_edge, 6 },
	{ "Move Edge 67", arb7_edge, 7 },
	{ "Move Edge 37", arb7_edge, 8 },
	{ "Move Edge 57", arb7_edge, 9 },
	{ "Move Edge 45", arb7_edge, 10 },
	{ "Move Point 5", arb7_edge, 11 },
	{ "RETURN",       arb7_edge, 12 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  edge6_menu[] = {
	{ "ARB6 EDGES", (void (*)())NULL, 0 },
	{ "Move Edge 12", arb6_edge, 0 },
	{ "Move Edge 23", arb6_edge, 1 },
	{ "Move Edge 34", arb6_edge, 2 },
	{ "Move Edge 14", arb6_edge, 3 },
	{ "Move Edge 15", arb6_edge, 4 },
	{ "Move Edge 25", arb6_edge, 5 },
	{ "Move Edge 36", arb6_edge, 6 },
	{ "Move Edge 46", arb6_edge, 7 },
	{ "Move Point 5", arb6_edge, 8 },
	{ "Move Point 6", arb6_edge, 9 },
	{ "RETURN",       arb6_edge, 10 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  edge5_menu[] = {
	{ "ARB5 EDGES", (void (*)())NULL, 0 },
	{ "Move Edge 12", arb5_edge, 0 },
	{ "Move Edge 23", arb5_edge, 1 },
	{ "Move Edge 34", arb5_edge, 2 },
	{ "Move Edge 14", arb5_edge, 3 },
	{ "Move Edge 15", arb5_edge, 4 },
	{ "Move Edge 25", arb5_edge, 5 },
	{ "Move Edge 35", arb5_edge, 6 },
	{ "Move Edge 45", arb5_edge, 7 },
	{ "Move Point 5", arb5_edge, 8 },
	{ "RETURN",       arb5_edge, 9 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  point4_menu[] = {
	{ "ARB4 POINTS", (void (*)())NULL, 0 },
	{ "Move Point 1", arb4_point, 0 },
	{ "Move Point 2", arb4_point, 1 },
	{ "Move Point 3", arb4_point, 2 },
	{ "Move Point 4", arb4_point, 4 },
	{ "RETURN",       arb4_point, 5 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  tgc_menu[] = {
	{ "TGC MENU", (void (*)())NULL, 0 },
	{ "Set H",	tgc_ed, MENU_TGC_SCALE_H },
	{ "Set H (move V)", tgc_ed, MENU_TGC_SCALE_H_V },
	{ "Set H (adj C,D)",	tgc_ed, MENU_TGC_SCALE_H_CD },
	{ "Set H (move V, adj A,B)", tgc_ed, MENU_TGC_SCALE_H_V_AB },
	{ "Set A",	tgc_ed, MENU_TGC_SCALE_A },
	{ "Set B",	tgc_ed, MENU_TGC_SCALE_B },
	{ "Set C",	tgc_ed, MENU_TGC_SCALE_C },
	{ "Set D",	tgc_ed, MENU_TGC_SCALE_D },
	{ "Set A,B",	tgc_ed, MENU_TGC_SCALE_AB },
	{ "Set C,D",	tgc_ed, MENU_TGC_SCALE_CD },
	{ "Set A,B,C,D", tgc_ed, MENU_TGC_SCALE_ABCD },
	{ "Rotate H",	tgc_ed, MENU_TGC_ROT_H },
	{ "Rotate AxB",	tgc_ed, MENU_TGC_ROT_AB },
	{ "Move End H(rt)", tgc_ed, MENU_TGC_MV_H },
	{ "Move End H", tgc_ed, MENU_TGC_MV_HH },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  tor_menu[] = {
	{ "TORUS MENU", (void (*)())NULL, 0 },
	{ "Set Radius 1", tor_ed, MENU_TOR_R1 },
	{ "Set Radius 2", tor_ed, MENU_TOR_R2 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  eto_menu[] = {
	{ "ELL-TORUS MENU", (void (*)())NULL, 0 },
	{ "Set r", eto_ed, MENU_ETO_R },
	{ "Set D", eto_ed, MENU_ETO_RD },
	{ "Set C", eto_ed, MENU_ETO_SCALE_C },
	{ "Rotate C", eto_ed, MENU_ETO_ROT_C },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  ell_menu[] = {
	{ "ELLIPSOID MENU", (void (*)())NULL, 0 },
	{ "Set A", ell_ed, MENU_ELL_SCALE_A },
	{ "Set B", ell_ed, MENU_ELL_SCALE_B },
	{ "Set C", ell_ed, MENU_ELL_SCALE_C },
	{ "Set A,B,C", ell_ed, MENU_ELL_SCALE_ABC },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  spline_menu[] = {
	{ "SPLINE MENU", (void (*)())NULL, 0 },
	{ "Pick Vertex", spline_ed, -1 },
	{ "Move Vertex", spline_ed, ECMD_VTRANS },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  nmg_menu[] = {
	{ "NMG MENU", (void (*)())NULL, 0 },
	{ "Pick Edge", nmg_ed, ECMD_NMG_EPICK },
	{ "Move Edge", nmg_ed, ECMD_NMG_EMOVE },
	{ "Split Edge", nmg_ed, ECMD_NMG_ESPLIT },
	{ "Delete Edge", nmg_ed, ECMD_NMG_EKILL },
	{ "Next EU", nmg_ed, ECMD_NMG_FORW },
	{ "Prev EU", nmg_ed, ECMD_NMG_BACK },
	{ "Radial EU", nmg_ed, ECMD_NMG_RADIAL },
	{ "Extrude Loop", nmg_ed , ECMD_NMG_LEXTRU },
	{ "Eebug Edge", nmg_ed, ECMD_NMG_EDEBUG },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item mv8_menu[] = {
	{ "ARB8 FACES", (void (*)())NULL, 0 },
	{ "Move Face 1234", arb8_mv_face, 1 },
	{ "Move Face 5678", arb8_mv_face, 2 },
	{ "Move Face 1584", arb8_mv_face, 3 },
	{ "Move Face 2376", arb8_mv_face, 4 },
	{ "Move Face 1265", arb8_mv_face, 5 },
	{ "Move Face 4378", arb8_mv_face, 6 },
	{ "RETURN",         arb8_mv_face, 7 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item mv7_menu[] = {
	{ "ARB7 FACES", (void (*)())NULL, 0 },
	{ "Move Face 1234", arb7_mv_face, 1 },
	{ "Move Face 2376", arb7_mv_face, 4 },
	{ "RETURN",         arb7_mv_face, 7 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item mv6_menu[] = {
	{ "ARB6 FACES", (void (*)())NULL, 0 },
	{ "Move Face 1234", arb6_mv_face, 1 },
	{ "Move Face 2365", arb6_mv_face, 2 },
	{ "Move Face 1564", arb6_mv_face, 3 },
	{ "Move Face 125" , arb6_mv_face, 4 },
	{ "Move Face 346" , arb6_mv_face, 5 },
	{ "RETURN",         arb6_mv_face, 6 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item mv5_menu[] = {
	{ "ARB5 FACES", (void (*)())NULL, 0 },
	{ "Move Face 1234", arb5_mv_face, 1 },
	{ "Move Face 125" , arb5_mv_face, 2 },
	{ "Move Face 235" , arb5_mv_face, 3 },
	{ "Move Face 345" , arb5_mv_face, 4 },
	{ "Move Face 145" , arb5_mv_face, 5 },
	{ "RETURN",         arb5_mv_face, 6 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item mv4_menu[] = {
	{ "ARB4 FACES", (void (*)())NULL, 0 },
	{ "Move Face 123" , arb4_mv_face, 1 },
	{ "Move Face 124" , arb4_mv_face, 2 },
	{ "Move Face 234" , arb4_mv_face, 3 },
	{ "Move Face 134" , arb4_mv_face, 4 },
	{ "RETURN",         arb4_mv_face, 5 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item rot8_menu[] = {
	{ "ARB8 FACES", (void (*)())NULL, 0 },
	{ "Rotate Face 1234", arb8_rot_face, 1 },
	{ "Rotate Face 5678", arb8_rot_face, 2 },
	{ "Rotate Face 1584", arb8_rot_face, 3 },
	{ "Rotate Face 2376", arb8_rot_face, 4 },
	{ "Rotate Face 1265", arb8_rot_face, 5 },
	{ "Rotate Face 4378", arb8_rot_face, 6 },
	{ "RETURN",         arb8_rot_face, 7 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item rot7_menu[] = {
	{ "ARB7 FACES", (void (*)())NULL, 0 },
	{ "Rotate Face 1234", arb7_rot_face, 1 },
	{ "Rotate Face 567" , arb7_rot_face, 2 },
	{ "Rotate Face 145" , arb7_rot_face, 3 },
	{ "Rotate Face 2376", arb7_rot_face, 4 },
	{ "Rotate Face 1265", arb7_rot_face, 5 },
	{ "Rotate Face 4375", arb7_rot_face, 6 },
	{ "RETURN",         arb7_rot_face, 7 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item rot6_menu[] = {
	{ "ARB6 FACES", (void (*)())NULL, 0 },
	{ "Rotate Face 1234", arb6_rot_face, 1 },
	{ "Rotate Face 2365", arb6_rot_face, 2 },
	{ "Rotate Face 1564", arb6_rot_face, 3 },
	{ "Rotate Face 125" , arb6_rot_face, 4 },
	{ "Rotate Face 346" , arb6_rot_face, 5 },
	{ "RETURN",         arb6_rot_face, 6 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item rot5_menu[] = {
	{ "ARB5 FACES", (void (*)())NULL, 0 },
	{ "Rotate Face 1234", arb5_rot_face, 1 },
	{ "Rotate Face 125" , arb5_rot_face, 2 },
	{ "Rotate Face 235" , arb5_rot_face, 3 },
	{ "Rotate Face 345" , arb5_rot_face, 4 },
	{ "Rotate Face 145" , arb5_rot_face, 5 },
	{ "RETURN",         arb5_rot_face, 6 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item rot4_menu[] = {
	{ "ARB4 FACES", (void (*)())NULL, 0 },
	{ "Rotate Face 123" , arb4_rot_face, 1 },
	{ "Rotate Face 124" , arb4_rot_face, 2 },
	{ "Rotate Face 234" , arb4_rot_face, 3 },
	{ "Rotate Face 134" , arb4_rot_face, 4 },
	{ "RETURN",         arb4_rot_face, 5 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item cntrl_menu[] = {
	{ "ARB MENU", (void (*)())NULL, 0 },
	{ "Move Edges", arb_control, MENU_ARB_MV_EDGE },
	{ "Move Faces", arb_control, MENU_ARB_MV_FACE },
	{ "Rotate Faces", arb_control, MENU_ARB_ROT_FACE },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item part_menu[] = {
	{ "Particle MENU", (void (*)())NULL, 0 },
	{ "Set H", part_ed, MENU_PART_H },
	{ "Set v", part_ed, MENU_PART_v },
	{ "Set h", part_ed, MENU_PART_h },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  rpc_menu[] = {
	{ "RPC MENU", (void (*)())NULL, 0 },
	{ "Set B", rpc_ed, MENU_RPC_B },
	{ "Set H", rpc_ed, MENU_RPC_H },
	{ "Set r", rpc_ed, MENU_RPC_R },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  rhc_menu[] = {
	{ "RHC MENU", (void (*)())NULL, 0 },
	{ "Set B", rhc_ed, MENU_RHC_B },
	{ "Set H", rhc_ed, MENU_RHC_H },
	{ "Set r", rhc_ed, MENU_RHC_R },
	{ "Set c", rhc_ed, MENU_RHC_C },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  epa_menu[] = {
	{ "EPA MENU", (void (*)())NULL, 0 },
	{ "Set H", epa_ed, MENU_EPA_H },
	{ "Set A", epa_ed, MENU_EPA_R1 },
	{ "Set B", epa_ed, MENU_EPA_R2 },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  ehy_menu[] = {
	{ "EHY MENU", (void (*)())NULL, 0 },
	{ "Set H", ehy_ed, MENU_EHY_H },
	{ "Set A", ehy_ed, MENU_EHY_R1 },
	{ "Set B", ehy_ed, MENU_EHY_R2 },
	{ "Set c", ehy_ed, MENU_EHY_C },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item pipe_menu[] = {
	{ "PIPE MENU", (void (*)())NULL, 0 },
	{ "Select Point", pipe_ed, MENU_PIPE_SELECT },
	{ "Next Point", pipe_ed, MENU_PIPE_NEXT_PT },
	{ "Previous Point", pipe_ed, MENU_PIPE_PREV_PT },
	{ "Move Point", pipe_ed, MENU_PIPE_MOV_PT },
	{ "Delete Point", pipe_ed, MENU_PIPE_DEL_PT },
	{ "Append Point", pipe_ed, MENU_PIPE_ADD_PT },
	{ "Prepend Point", pipe_ed, MENU_PIPE_INS_PT },
	{ "Set Point OD", pipe_ed, MENU_PIPE_PT_OD },
	{ "Set Point ID", pipe_ed, MENU_PIPE_PT_ID },
	{ "Set Point Bend", pipe_ed, MENU_PIPE_PT_RADIUS },
	{ "Set Pipe OD", pipe_ed, MENU_PIPE_SCALE_OD },
	{ "Set Pipe ID", pipe_ed, MENU_PIPE_SCALE_ID },
	{ "Set Pipe Bend", pipe_ed, MENU_PIPE_SCALE_RADIUS },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item vol_menu[] = {
	{"VOL MENU", (void (*)())NULL, 0 },
	{"File Name", vol_ed, MENU_VOL_FNAME },
	{"File Size (X Y Z)", vol_ed, MENU_VOL_FSIZE },
	{"Voxel Size (X Y Z)", vol_ed, MENU_VOL_CSIZE },
	{"Threshold (low)", vol_ed, MENU_VOL_THRESH_LO },
	{"Threshold (hi)", vol_ed, MENU_VOL_THRESH_HI },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item ebm_menu[] = {
	{"EBM MENU", (void (*)())NULL, 0 },
	{"File Name", ebm_ed, MENU_EBM_FNAME },
	{"File Size (W N)", ebm_ed, MENU_EBM_FSIZE },
	{"Extrude Depth", ebm_ed, MENU_EBM_HEIGHT },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item dsp_menu[] = {
	{"DSP MENU", (void (*)())NULL, 0 },
	{"Name", dsp_ed, MENU_DSP_FNAME },
	{"Set X", dsp_ed, MENU_DSP_SCALE_X },
	{"Set Y", dsp_ed, MENU_DSP_SCALE_Y },
	{"Set ALT", dsp_ed, MENU_DSP_SCALE_ALT },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item bot_menu[] = {
	{ "BOT MENU", (void (*)())NULL, 0 },
	{ "Pick Vertex", bot_ed, ECMD_BOT_PICKV },
	{ "Pick Edge", bot_ed, ECMD_BOT_PICKE },
	{ "Pick Triangle", bot_ed, ECMD_BOT_PICKT },
	{ "Move Vertex", bot_ed, ECMD_BOT_MOVEV },
	{ "Move Edge", bot_ed, ECMD_BOT_MOVEE },
	{ "Move Triangle", bot_ed, ECMD_BOT_MOVET },
	{ "Delete Triangle", bot_ed, ECMD_BOT_FDEL },
	{ "Select Mode", bot_ed, ECMD_BOT_MODE },
	{ "Select Orientation", bot_ed, ECMD_BOT_ORIENT },
	{ "Set flags", bot_ed, ECMD_BOT_FLAGS },
	{ "Set Face Thickness", bot_ed, ECMD_BOT_THICK },
	{ "Set Face Mode", bot_ed, ECMD_BOT_FMODE },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item  superell_menu[] = {
	{ "SUPERELLIPSOID MENU", (void (*)())NULL, 0 },
	{ "Set A", superell_ed, MENU_SUPERELL_SCALE_A },
	{ "Set B", superell_ed, MENU_SUPERELL_SCALE_B },
	{ "Set C", superell_ed, MENU_SUPERELL_SCALE_C },
	{ "Set A,B,C", superell_ed, MENU_SUPERELL_SCALE_ABC },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item *which_menu[] = {
	point4_menu,
	edge5_menu,
	edge6_menu,
	edge7_menu,
	edge8_menu,
	mv4_menu,
	mv5_menu,
	mv6_menu,
	mv7_menu,
	mv8_menu,
	rot4_menu,
	rot5_menu,
	rot6_menu,
	rot7_menu,
	rot8_menu
};

short int arb_vertices[5][24] = {
	{ 1,2,3,0, 1,2,4,0, 2,3,4,0, 1,3,4,0, 0,0,0,0, 0,0,0,0 },	/* arb4 */
	{ 1,2,3,4, 1,2,5,0, 2,3,5,0, 3,4,5,0, 1,4,5,0, 0,0,0,0 },	/* arb5 */
	{ 1,2,3,4, 2,3,6,5, 1,5,6,4, 1,2,5,0, 3,4,6,0, 0,0,0,0 },	/* arb6 */
	{ 1,2,3,4, 5,6,7,0, 1,4,5,0, 2,3,7,6, 1,2,6,5, 4,3,7,5 },	/* arb7 */
	{ 1,2,3,4, 5,6,7,8, 1,5,8,4, 2,3,7,6, 1,2,6,5, 4,3,7,8 }	/* arb8 */
};

static void
arb8_edge(int arg)
{
  es_menu = arg;
  es_edflag = EARB;
  if(arg == 12)  {
    es_edflag = ECMD_ARB_MAIN_MENU;
    sedit();
  }

  set_e_axes_pos(1);
}

static void
arb7_edge(int arg)
{
  es_menu = arg;
  es_edflag = EARB;
  if(arg == 11) {
    /* move point 5 */
    es_edflag = PTARB;
    es_menu = 4;	/* location of point */
  }
  if(arg == 12)  {
    es_edflag = ECMD_ARB_MAIN_MENU;
    sedit();
  }

  set_e_axes_pos(1);
}

static void
arb6_edge(int arg)
{
  es_menu = arg;
  es_edflag = EARB;
  if(arg == 8) {
    /* move point 5   location = 4 */
    es_edflag = PTARB;
    es_menu = 4;
  }
  if(arg == 9) {
    /* move point 6   location = 6 */
    es_edflag = PTARB;
    es_menu = 6;
  }
  if(arg == 10)  {
    es_edflag = ECMD_ARB_MAIN_MENU;
    sedit();
  }

  set_e_axes_pos(1);
}

static void
arb5_edge(int arg)
{
  es_menu = arg;
  es_edflag = EARB;
  if(arg == 8) {
    /* move point 5 at loaction 4 */
    es_edflag = PTARB;
    es_menu = 4;
  }
  if(arg == 9)  {
    es_edflag = ECMD_ARB_MAIN_MENU;
    sedit();
  }

  set_e_axes_pos(1);
}

static void
arb4_point(int arg)
{
  es_menu = arg;
  es_edflag = PTARB;
  if(arg == 5)  {
    es_edflag = ECMD_ARB_MAIN_MENU;
    sedit();
  }

  set_e_axes_pos(1);
}

static void
bot_ed(int arg)
{
	es_menu = arg;
	es_edflag = arg;

	sedit();
	set_e_axes_pos(1);
}

static void
ebm_ed(int arg)
{
  es_menu = arg;

  switch( arg ){
  case MENU_EBM_FNAME:
    es_edflag = ECMD_EBM_FNAME;
    break;
  case MENU_EBM_FSIZE:
    es_edflag = ECMD_EBM_FSIZE;
    break;
  case MENU_EBM_HEIGHT:
    es_edflag = ECMD_EBM_HEIGHT;
    break;
  }

  sedit();
  set_e_axes_pos(1);
}

static void
dsp_ed(int arg)
{
	es_menu = arg;
	
	switch( arg ) {
	case MENU_DSP_FNAME:
		es_edflag = ECMD_DSP_FNAME;
		break;
	case MENU_DSP_FSIZE:
		es_edflag = ECMD_DSP_FSIZE;
		break;
	case MENU_DSP_SCALE_X:
		es_edflag = ECMD_DSP_SCALE_X;
		break;
	case MENU_DSP_SCALE_Y:
		es_edflag = ECMD_DSP_SCALE_Y;
		break;
	case MENU_DSP_SCALE_ALT:
		es_edflag = ECMD_DSP_SCALE_ALT;
		break;
	}
	sedit();
	set_e_axes_pos(1);
}

static void
cline_ed(int arg)
{
	es_edflag = arg;
	sedit();
}

static void
vol_ed(int arg)
{
  es_menu = arg;

  switch( arg ){
  case MENU_VOL_FNAME:
    es_edflag = ECMD_VOL_FNAME;
    break;
  case MENU_VOL_FSIZE:
    es_edflag = ECMD_VOL_FSIZE;
    break;
  case MENU_VOL_CSIZE:
    es_edflag = ECMD_VOL_CSIZE;
    break;
  case MENU_VOL_THRESH_LO:
    es_edflag = ECMD_VOL_THRESH_LO;
    break;
  case MENU_VOL_THRESH_HI:
    es_edflag = ECMD_VOL_THRESH_HI;
    break;
  }

  sedit();
  set_e_axes_pos(1);
}

static void
pipe_ed(int arg)
{
	struct wdb_pipept *next;
	struct wdb_pipept *prev;

	if(dbip == DBI_NULL)
	  return;

	switch( arg )
	{
		case MENU_PIPE_SELECT:
			es_menu = arg;
			es_edflag = ECMD_PIPE_PICK;
		break;
		case MENU_PIPE_NEXT_PT:
			if( !es_pipept )
			{
			  Tcl_AppendResult(interp, "No Pipe Segment selected\n", (char *)NULL);
			  return;
			}
			next = BU_LIST_NEXT( wdb_pipept, &es_pipept->l );
			if( next->l.magic == BU_LIST_HEAD_MAGIC )
			{
			  Tcl_AppendResult(interp, "Current segment is the last\n", (char *)NULL);
			  return;
			}
			es_pipept = next;
			rt_pipept_print( es_pipept, base2local );
			es_menu = arg;
			es_edflag = IDLE;
			sedit();
		break;
		case MENU_PIPE_PREV_PT:
			if( !es_pipept )
			{
			  Tcl_AppendResult(interp, "No Pipe Segment selected\n", (char *)NULL);
			  return;
			}
			prev = BU_LIST_PREV( wdb_pipept, &es_pipept->l );
			if( prev->l.magic == BU_LIST_HEAD_MAGIC )
			{
			  Tcl_AppendResult(interp, "Current segment is the first\n", (char *)NULL);
			  return;
			}
			es_pipept = prev;
			rt_pipept_print( es_pipept, base2local );
			es_menu = arg;
			es_edflag = IDLE;
			sedit();
		break;
		case MENU_PIPE_SPLIT:
			/* not used */
		break;
		case MENU_PIPE_MOV_PT:
			if( !es_pipept )
			{
			  Tcl_AppendResult(interp, "No Pipe Segment selected\n", (char *)NULL);
			  es_edflag = IDLE;
			  return;
			}
			es_menu = arg;
			es_edflag = ECMD_PIPE_PT_MOVE;
		break;
		case MENU_PIPE_PT_OD:
		case MENU_PIPE_PT_ID:
		case MENU_PIPE_PT_RADIUS:
			if( !es_pipept )
			{
			  Tcl_AppendResult(interp, "No Pipe Segment selected\n", (char *)NULL);
			  es_edflag = IDLE;
			  return;
			}
			es_menu = arg;
			es_edflag = PSCALE;
		break;
		case MENU_PIPE_SCALE_OD:
		case MENU_PIPE_SCALE_ID:
		case MENU_PIPE_SCALE_RADIUS:
			es_menu = arg;
			es_edflag = PSCALE;
		break;
		case MENU_PIPE_ADD_PT:
			es_menu = arg;
			es_edflag = ECMD_PIPE_PT_ADD;
		break;
		case MENU_PIPE_INS_PT:
			es_menu = arg;
			es_edflag = ECMD_PIPE_PT_INS;
		break;
		case MENU_PIPE_DEL_PT:
			es_menu = arg;
			es_edflag = ECMD_PIPE_PT_DEL;
			sedit();
		break;
	}
	set_e_axes_pos(1);
}

static void
tgc_ed(int arg)
{
	es_menu = arg;
	es_edflag = PSCALE;
	if(arg == MENU_TGC_ROT_H )
		es_edflag = ECMD_TGC_ROT_H;
	if(arg == MENU_TGC_ROT_AB)
		es_edflag = ECMD_TGC_ROT_AB;
	if(arg == MENU_TGC_MV_H)
		es_edflag = ECMD_TGC_MV_H;
	if(arg == MENU_TGC_MV_HH)
		es_edflag = ECMD_TGC_MV_HH;

	set_e_axes_pos(1);
}


static void
tor_ed(int arg)
{
	es_menu = arg;
	es_edflag = PSCALE;

	set_e_axes_pos(1);
}

static void
eto_ed(int arg)
{
	es_menu = arg;
	if(arg == MENU_ETO_ROT_C )
		es_edflag = ECMD_ETO_ROT_C;
	else
		es_edflag = PSCALE;

	set_e_axes_pos(1);
}

static void
rpc_ed(int arg)
{
	es_menu = arg;
	es_edflag = PSCALE;

	set_e_axes_pos(1);
}

static void
part_ed(int arg)
{
	es_menu = arg;
	es_edflag = PSCALE;

	set_e_axes_pos(1);
}

static void
rhc_ed(int arg)
{
	es_menu = arg;
	es_edflag = PSCALE;

	set_e_axes_pos(1);
}

static void
epa_ed(int arg)
{
	es_menu = arg;
	es_edflag = PSCALE;

	set_e_axes_pos(1);
}

static void
ehy_ed(int arg)
{
	es_menu = arg;
	es_edflag = PSCALE;

	set_e_axes_pos(1);
}

static void
ell_ed(int arg)
{
	es_menu = arg;
	es_edflag = PSCALE;

	set_e_axes_pos(1);
}

static void
arb8_mv_face(int arg)
{
	es_menu = arg - 1;
	es_edflag = ECMD_ARB_MOVE_FACE;
	if(arg == 7)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedit();
	}

	set_e_axes_pos(1);
}

static void
arb7_mv_face(int arg)
{
	es_menu = arg - 1;
	es_edflag = ECMD_ARB_MOVE_FACE;
	if(arg == 7)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedit();
	}

	set_e_axes_pos(1);
}		

static void
arb6_mv_face(int arg)
{
	es_menu = arg - 1;
	es_edflag = ECMD_ARB_MOVE_FACE;
	if(arg == 6)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedit();
	}

	set_e_axes_pos(1);
}

static void
arb5_mv_face(int arg)
{
  es_menu = arg - 1;
  es_edflag = ECMD_ARB_MOVE_FACE;
  if(arg == 6)  {
    es_edflag = ECMD_ARB_MAIN_MENU;
    sedit();
  }

  set_e_axes_pos(1);
}

static void
arb4_mv_face(int arg)
{
  es_menu = arg - 1;
  es_edflag = ECMD_ARB_MOVE_FACE;
  if(arg == 5)  {
    es_edflag = ECMD_ARB_MAIN_MENU;
    sedit();
  }

  set_e_axes_pos(1);
}

static void
arb8_rot_face(int arg)
{
  es_menu = arg - 1;
  es_edflag = ECMD_ARB_SETUP_ROTFACE;
  if(arg == 7)
    es_edflag = ECMD_ARB_MAIN_MENU;

  sedit();
}

static void
arb7_rot_face(int arg)
{
  es_menu = arg - 1;
  es_edflag = ECMD_ARB_SETUP_ROTFACE;
  if(arg == 7)
    es_edflag = ECMD_ARB_MAIN_MENU;

  sedit();
}		

static void
arb6_rot_face(int arg)
{
  es_menu = arg - 1;
  es_edflag = ECMD_ARB_SETUP_ROTFACE;
  if(arg == 6)
    es_edflag = ECMD_ARB_MAIN_MENU;

  sedit();
}

static void
arb5_rot_face(int arg)
{
  es_menu = arg - 1;
  es_edflag = ECMD_ARB_SETUP_ROTFACE;
  if(arg == 6)
    es_edflag = ECMD_ARB_MAIN_MENU;

  sedit();
}

static void
arb4_rot_face(int arg)
{
  es_menu = arg - 1;
  es_edflag = ECMD_ARB_SETUP_ROTFACE;
  if(arg == 5)
    es_edflag = ECMD_ARB_MAIN_MENU;

  sedit();
}

static void
arb_control(int arg)
{
  es_menu = arg;
  es_edflag = ECMD_ARB_SPECIFIC_MENU;
  sedit();
}

/*ARGSUSED*/
static void
ars_ed(int arg)
{
  es_edflag = arg;
  sedit();
}

/*ARGSUSED*/
static void
extr_ed(int arg)
{
  es_edflag = arg;
  sedit();
}

static void superell_ed(int arg) {
  es_menu = arg;
  es_edflag = PSCALE;
  set_e_axes_pos(1);
  return;
}

/*ARGSUSED*/
static void
spline_ed(int arg)
{
  /* XXX Why wasn't this done by setting es_edflag = ECMD_SPLINE_VPICK? */
  if( arg < 0 )  {
    /* Enter picking state */
    chg_state( ST_S_EDIT, ST_S_VPICK, "Vertex Pick" );
    return;
  }
  /* For example, this will set es_edflag = ECMD_VTRANS */
  es_edflag = arg;
  sedit();

	set_e_axes_pos(1);
}
/*
 *			N M G _ E D
 *
 *  Handler for events in the NMG menu.
 *  Mostly just set appropriate state flags to prepare us for user's
 *  next event.
 */
/*ARGSUSED*/
static void
nmg_ed(int arg)
{
	switch(arg)  {
	default:
	  Tcl_AppendResult(interp, "nmg_ed: undefined menu event?\n", (char *)NULL);
	  return;
	case ECMD_NMG_EPICK:
	case ECMD_NMG_EMOVE:
	case ECMD_NMG_ESPLIT:
	case ECMD_NMG_EKILL:
		break;
	case ECMD_NMG_EDEBUG:
		if( !es_eu )  {
		  Tcl_AppendResult(interp, "nmg_ed: no edge selected yet\n", (char *)NULL);
		  return;
		}

		nmg_pr_fu_around_eu( es_eu, &mged_tol );
		{
			struct model		*m;
			struct rt_vlblock	*vbp;
			long			*tab;

			m = nmg_find_model( &es_eu->l.magic );
			NMG_CK_MODEL(m);

			if( *es_eu->g.magic_p == NMG_EDGE_G_LSEG_MAGIC )
			{
				/* get space for list of items processed */
				tab = (long *)bu_calloc( m->maxindex+1, sizeof(long),
					"nmg_ed tab[]");
				vbp = rt_vlblock_init();

				nmg_vlblock_around_eu(vbp, es_eu, tab, 1, &mged_tol);
				cvt_vlblock_to_solids( vbp, "_EU_", 0 );	/* swipe vlist */

				rt_vlblock_free(vbp);
				bu_free( (genptr_t)tab, "nmg_ed tab[]" );
			}
			view_state->vs_flag = 1;
		}
		if( *es_eu->up.magic_p == NMG_LOOPUSE_MAGIC )  {
			nmg_veu( &es_eu->up.lu_p->down_hd, es_eu->up.magic_p );
		}
		/* no change of state or es_edflag */
		return;
	case ECMD_NMG_FORW:
		if( !es_eu )  {
		  Tcl_AppendResult(interp, "nmg_ed: no edge selected yet\n", (char *)NULL);
		  return;
		}
		NMG_CK_EDGEUSE(es_eu);
		es_eu = BU_LIST_PNEXT_CIRC(edgeuse, es_eu);

		{
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "edgeuse selected=x%x (%g %g %g) <-> (%g %g %g)\n",
				es_eu, V3ARGS( es_eu->vu_p->v_p->vg_p->coord ),
				V3ARGS( es_eu->eumate_p->vu_p->v_p->vg_p->coord ) );
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}

		sedit();
		return;
	case ECMD_NMG_BACK:
		if( !es_eu )  {
			bu_log("nmg_ed: no edge selected yet\n");
			return;
		}
		NMG_CK_EDGEUSE(es_eu);
		es_eu = BU_LIST_PPREV_CIRC(edgeuse, es_eu);

		{
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "edgeuse selected=x%x (%g %g %g) <-> (%g %g %g)\n",
				es_eu, V3ARGS( es_eu->vu_p->v_p->vg_p->coord ),
				V3ARGS( es_eu->eumate_p->vu_p->v_p->vg_p->coord ) );
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}

		sedit();
		return;
	case ECMD_NMG_RADIAL:
		if( !es_eu )  {
			bu_log("nmg_ed: no edge selected yet\n");
			return;
		}
		NMG_CK_EDGEUSE(es_eu);
		es_eu = es_eu->eumate_p->radial_p;

		{
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "edgeuse selected=x%x (%g %g %g) <-> (%g %g %g)\n",
				es_eu, V3ARGS( es_eu->vu_p->v_p->vg_p->coord ),
				V3ARGS( es_eu->eumate_p->vu_p->v_p->vg_p->coord ) );
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}

		sedit();
		return;
	case ECMD_NMG_LEXTRU:
		{
			struct model *m,*m_tmp;
			struct nmgregion *r,*r_tmp;
			struct shell *s,*s_tmp;
			struct loopuse *lu=(struct loopuse *)NULL;
			struct loopuse *lu_tmp;
			struct edgeuse *eu;
			fastf_t area;
			int wire_loop_count=0;

			m = (struct model *)es_int.idb_ptr;
			NMG_CK_MODEL( m );

			/* look for wire loops */
			for( BU_LIST_FOR( r , nmgregion , &m->r_hd ) )
			{
				NMG_CK_REGION( r );
				for( BU_LIST_FOR( s , shell , &r->s_hd ) )
				{
					if( BU_LIST_IS_EMPTY( &s->lu_hd ) )
						continue;

					for( BU_LIST_FOR( lu_tmp , loopuse , &s->lu_hd ) )
					{
						if( !lu )
							lu = lu_tmp;
						else if( lu_tmp == lu->lumate_p )
							continue;

						wire_loop_count++;
					}
				}
			}

			if( !wire_loop_count )
			{
			  Tcl_AppendResult(interp, "No sketch (wire loop) to extrude\n",
					   (char *)NULL);
			  return;
			}

			if( wire_loop_count > 1 )
			{
			  Tcl_AppendResult(interp, "Too many wire loops!!! Don't know which to extrude!!\n", (char *)NULL);
				return;
			}

			if( !lu || *lu->up.magic_p != NMG_SHELL_MAGIC )
			{
				/* This should never happen */
				bu_bomb( "Cannot find wire loop!!\n" );
			}

			/* Make sure loop is not a crack */
			area = nmg_loop_plane_area( lu , lu_pl );

			if( area < 0.0 )
			{
			  Tcl_AppendResult(interp, "Cannot extrude loop with no area\n",
					   (char *)NULL);
			  return;
			}

			/* Check if loop crosses itself */
			for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				struct edgeuse *eu2;
				struct vertex *v1;
				vect_t edge1;

				NMG_CK_EDGEUSE( eu );

				v1 = eu->vu_p->v_p;
				NMG_CK_VERTEX( v1 );
				VSUB2( edge1, eu->eumate_p->vu_p->v_p->vg_p->coord, v1->vg_p->coord );

				for( eu2 = BU_LIST_PNEXT( edgeuse , &eu->l ) ; BU_LIST_NOT_HEAD( eu2 , &lu->down_hd ) ; eu2=BU_LIST_PNEXT( edgeuse, &eu2->l) )
				{
					struct vertex *v2;
					vect_t edge2;
					fastf_t dist[2];
					int ret_val;

					NMG_CK_EDGEUSE( eu2 );

					if( eu2 == eu )
						continue;
					if( eu2 == BU_LIST_PNEXT_CIRC( edgeuse,  &eu->l ) )
						continue;
					if( eu2 == BU_LIST_PPREV_CIRC( edgeuse, &eu->l ) )
						continue;

					v2 = eu2->vu_p->v_p;
					NMG_CK_VERTEX( v2 );
					VSUB2( edge2, eu2->eumate_p->vu_p->v_p->vg_p->coord, v2->vg_p->coord );

					if( (ret_val=bn_isect_lseg3_lseg3( dist, v1->vg_p->coord, edge1,
						v2->vg_p->coord, edge2, &mged_tol )) > (-1) )
					{
					  struct bu_vls tmp_vls;

					  bu_vls_init(&tmp_vls);
					  bu_vls_printf(&tmp_vls,
							"Loop crosses itself, cannot extrude\n" );
					  bu_vls_printf(&tmp_vls,
							"edge1: pt=( %g %g %g ), dir=( %g %g %g)\n",
						  V3ARGS( v1->vg_p->coord ), V3ARGS( edge1 ) );
					  bu_vls_printf(&tmp_vls,
							"edge2: pt=( %g %g %g ), dir=( %g %g %g)\n",
						  V3ARGS( v2->vg_p->coord ), V3ARGS( edge2 ) );
					  if( ret_val == 0 )
					    bu_vls_printf(&tmp_vls,
							  "edges are collinear and overlap\n" );
					  else
					    {
					      point_t isect_pt;
					      
					      VJOIN1( isect_pt, v1->vg_p->coord, dist[0], edge1 );
					      bu_vls_printf(&tmp_vls,
							    "edges intersect at ( %g %g %g )\n",
						      V3ARGS( isect_pt ) );
					    }

					  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls),
							   (char *)NULL);
					  bu_vls_free(&tmp_vls);
					  return;
					}
				}
			}

			/* Create a temporary model to store the basis loop */
			m_tmp = nmg_mm();
			r_tmp = nmg_mrsv( m_tmp );
			s_tmp = BU_LIST_FIRST( shell , &r_tmp->s_hd );
			lu_copy = nmg_dup_loop( lu , &s_tmp->l.magic , (long **)0 );
			if( !lu_copy )
			{
			  Tcl_AppendResult(interp, "Failed to make copy of loop\n", (char *)NULL);
			  nmg_km( m_tmp );
			  return;
			}

			/* Get the first vertex in the loop as the basis for extrusion */
			eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
			VMOVE( lu_keypoint , eu->vu_p->v_p->vg_p->coord );

			s = lu->up.s_p;
			
			if( BU_LIST_NON_EMPTY( &s->fu_hd ) )
			{
				/* make a new shell to hold the extruded solid */

				r = BU_LIST_FIRST( nmgregion , &m->r_hd );
				NMG_CK_REGION( r );
				es_s = nmg_msv( r );
			}
			else
				es_s = s;

		}
		break;
	}
	/* For example, this will set es_edflag = ECMD_NMG_EPICK */
	es_edflag = arg;
	sedit();
}

/*
 *  Keypoint in model space is established in "pt".
 *  If "str" is set, then that point is used, else default
 *  for this solid is selected and set.
 *  "str" may be a constant string, in either upper or lower case,
 *  or it may be something complex like "(3,4)" for an ARS or spline
 *  to select a particular vertex or control point.
 *
 *  XXX Perhaps this should be done via solid-specific parse tables,
 *  so that solids could be pretty-printed & structprint/structparse
 *  processed as well?
 */
void
get_solid_keypoint(fastf_t *pt, char **strp, struct rt_db_internal *ip, fastf_t *mat)
{
	char	*cp = *strp;
	point_t	mpt;
	static char		buf[128];

	RT_CK_DB_INTERNAL( ip );

	switch( ip->idb_type )  {
	case ID_CLINE:
		{
			struct rt_cline_internal *cli = 
				(struct rt_cline_internal *)ip->idb_ptr;

			RT_CLINE_CK_MAGIC( cli );

			if( !strcmp( cp, "V" ) )
			{
				VMOVE( mpt, cli->v );
				*strp = "V";
			}
			else if( !strcmp( cp, "H" ) )
			{
				VADD2( mpt, cli->v, cli->h );
				*strp = "H";
			}
			else
			{
				VMOVE( mpt, cli->v );
				*strp = "V";
			}
			break;
		}
	case ID_PARTICLE:
		{
			struct rt_part_internal *part =
				(struct rt_part_internal *)ip->idb_ptr;

			RT_PART_CK_MAGIC( part );

			if( !strcmp( cp , "V" ) )
			{
				VMOVE( mpt , part->part_V );
				*strp = "V";
			}
			else if( !strcmp( cp , "H" ) )
			{
				VADD2( mpt , part->part_V , part->part_H );
				*strp = "H";	
			}
			else	/* default */
			{
				VMOVE( mpt , part->part_V );
				*strp = "V";
			}
			break;
		}
	case ID_PIPE:
		{
			struct rt_pipe_internal *pipe =
				(struct rt_pipe_internal *)ip->idb_ptr;
			struct wdb_pipept *pipe_seg;

			RT_PIPE_CK_MAGIC( pipe );

			if (es_pipept == (struct wdb_pipept *)NULL) {
			  pipe_seg = BU_LIST_FIRST( wdb_pipept , &pipe->pipe_segs_head );
			  VMOVE( mpt , pipe_seg->pp_coord );
			} else {
			  VMOVE( mpt , es_pipept->pp_coord );
			}
			*strp = "V";
			break;
		}
	case ID_ARBN:
		{
			struct rt_arbn_internal *arbn =
				(struct rt_arbn_internal *)ip->idb_ptr;
			int i,j,k;
			int good_vert=0;

			RT_ARBN_CK_MAGIC( arbn );
			for( i=0 ; i<arbn->neqn ; i++ )
			{
				for( j=i+1 ; j<arbn->neqn ; j++ )
				{
					for( k=j+1 ; k<arbn->neqn ; k++ )
					{
						if( !bn_mkpoint_3planes( mpt , arbn->eqn[i] , arbn->eqn[j] , arbn->eqn[k] ) )
						{
							int l;

							good_vert = 1;
							for( l=0 ; l<arbn->neqn ; l++ )
							{
								if( l == i || l == j || l == k )
									continue;

								if( DIST_PT_PLANE( mpt , arbn->eqn[l] ) > mged_tol.dist )
								{
									good_vert = 0;
									break;
								}
							}

							if( good_vert )
								break;
						}
						if( good_vert )
							break;
					}
					if( good_vert )
						break;
				}
				if( good_vert )
					break;
			}

			*strp = "V";
			break;
		}
	case ID_EBM:
		{
			struct rt_ebm_internal *ebm =
				(struct rt_ebm_internal *)ip->idb_ptr;
			point_t pt;

			RT_EBM_CK_MAGIC( ebm );

			VSETALL( pt , 0.0 );
			MAT4X3PNT( mpt , ebm->mat , pt );
			*strp = "V";
			break;
		}
	case ID_BOT:
		{
			struct rt_bot_internal *bot =
				(struct rt_bot_internal *)ip->idb_ptr;

			if( bot_verts[0] > -1 )
				VMOVE( mpt, &bot->vertices[bot_verts[0]*3] )
			else
				VMOVE( mpt, bot->vertices )

			break;
		}
	case ID_DSP:
		{
			struct rt_dsp_internal *dsp =
				(struct rt_dsp_internal *)ip->idb_ptr;
			point_t pt;
			
			RT_DSP_CK_MAGIC( dsp );
			
			VSETALL( pt , 0.0 );
			MAT4X3PNT( mpt , dsp->dsp_stom , pt );
			*strp = "V";
			break;
		}
	case ID_HF:
		{
			struct rt_hf_internal *hf =
				(struct rt_hf_internal *)ip->idb_ptr;

			RT_HF_CK_MAGIC( hf );

			VMOVE( mpt, hf->v );
			*strp = "V";
			break;
		}
	case ID_VOL:
		{
			struct rt_vol_internal *vol =
				(struct rt_vol_internal *)ip->idb_ptr;
			point_t pt;

			RT_VOL_CK_MAGIC( vol );

			VSETALL( pt , 0.0 );
			MAT4X3PNT( mpt , vol->mat , pt );
			*strp = "V";
			break;
		}
	case ID_HALF:
		{
			struct rt_half_internal *haf =
				(struct rt_half_internal *)ip->idb_ptr;
			RT_HALF_CK_MAGIC( haf );

			VSCALE( mpt , haf->eqn , haf->eqn[H] );
			*strp = "V";
			break;
		}
	case ID_ARB8:
		{
			struct rt_arb_internal *arb =
				(struct rt_arb_internal *)ip->idb_ptr;
			RT_ARB_CK_MAGIC( arb );

			if( *cp == 'V' ) {
				int vertex_number;
				char *ptr;

				ptr = cp + 1;
				vertex_number = (*ptr) - '0';
				if( vertex_number < 1 || vertex_number > 8 )
					vertex_number = 1;
				VMOVE( mpt , arb->pt[vertex_number-1] );
				sprintf( buf, "V%d", vertex_number );
				*strp = buf;
				break;
			}

			/* Default */
			VMOVE( mpt , arb->pt[0] );
			*strp = "V1";

			break;
		}
	case ID_ELL:
	case ID_SPH:
		{
			struct rt_ell_internal	*ell = 
				(struct rt_ell_internal *)ip->idb_ptr;
			RT_ELL_CK_MAGIC(ell);

			if( strcmp( cp, "V" ) == 0 )  {
				VMOVE( mpt, ell->v );
				*strp = "V";
				break;
			}
			if( strcmp( cp, "A" ) == 0 )  {
				VADD2( mpt , ell->v , ell->a );
				*strp = "A";
				break;
			}
			if( strcmp( cp, "B" ) == 0 )  {
				VADD2( mpt , ell->v , ell->b );
				*strp = "B";
				break;
			}
			if( strcmp( cp, "C" ) == 0 )  {
				VADD2( mpt , ell->v , ell->c );
				*strp = "C";
				break;
			}
			/* Default */
			VMOVE( mpt, ell->v );
			*strp = "V";
			break;
		}
	case ID_SUPERELL:
		{
			struct rt_superell_internal	*superell = 
				(struct rt_superell_internal *)ip->idb_ptr;
			RT_SUPERELL_CK_MAGIC(superell);

			if( strcmp( cp, "V" ) == 0 )  {
				VMOVE( mpt, superell->v );
				*strp = "V";
				break;
			}
			if( strcmp( cp, "A" ) == 0 )  {
				VADD2( mpt , superell->v , superell->a );
				*strp = "A";
				break;
			}
			if( strcmp( cp, "B" ) == 0 )  {
				VADD2( mpt , superell->v , superell->b );
				*strp = "B";
				break;
			}
			if( strcmp( cp, "C" ) == 0 )  {
				VADD2( mpt , superell->v , superell->c );
				*strp = "C";
				break;
			}
			/* Default */
			VMOVE( mpt, superell->v );
			*strp = "V";
			break;
		}
	case ID_TOR:
		{
			struct rt_tor_internal	*tor = 
				(struct rt_tor_internal *)ip->idb_ptr;
			RT_TOR_CK_MAGIC(tor);

			if( strcmp( cp, "V" ) == 0 )  {
				VMOVE( mpt, tor->v );
				*strp = "V";
				break;
			}
			/* Default */
			VMOVE( mpt, tor->v );
			*strp = "V";
			break;
		}
	case ID_TGC:
	case ID_REC:
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)ip->idb_ptr;
			RT_TGC_CK_MAGIC(tgc);

			if( strcmp( cp, "V" ) == 0 )  {
				VMOVE( mpt, tgc->v );
				*strp = "V";
				break;
			}
			if( strcmp( cp, "H" ) == 0 )  {
				VMOVE( mpt, tgc->h );
				*strp = "H";
				break;
			}
			if( strcmp( cp, "A" ) == 0 )  {
				VMOVE( mpt, tgc->a );
				*strp = "A";
				break;
			}
			if( strcmp( cp, "B" ) == 0 )  {
				VMOVE( mpt, tgc->b );
				*strp = "B";
				break;
			}
			if( strcmp( cp, "C" ) == 0 )  {
				VMOVE( mpt, tgc->c );
				*strp = "C";
				break;
			}
			if( strcmp( cp, "D" ) == 0 )  {
				VMOVE( mpt, tgc->d );
				*strp = "D";
				break;
			}
			/* Default */
			VMOVE( mpt, tgc->v );
			*strp = "V";
			break;
		}
	case ID_BSPLINE:
		{
			register struct rt_nurb_internal *sip =
				(struct rt_nurb_internal *) es_int.idb_ptr;
			register struct face_g_snurb	*surf;
			register fastf_t		*fp;

			RT_NURB_CK_MAGIC(sip);
			surf = sip->srfs[spl_surfno];
			NMG_CK_SNURB(surf);
			fp = &RT_NURB_GET_CONTROL_POINT( surf, spl_ui, spl_vi );
			VMOVE( mpt, fp );
			sprintf(buf, "Surf %d, index %d,%d",
				spl_surfno, spl_ui, spl_vi );
			*strp = buf;
			break;
		}
	case ID_GRIP:
		{
			struct rt_grip_internal *gip =
				(struct rt_grip_internal *)ip->idb_ptr;
			RT_GRIP_CK_MAGIC(gip);
			VMOVE( mpt, gip->center);
			*strp = "C";
			break;
		}
	case ID_ARS:
		{
			register struct rt_ars_internal *ars =
				(struct rt_ars_internal *)es_int.idb_ptr;
			RT_ARS_CK_MAGIC( ars );

			if (es_ars_crv < 0 || es_ars_col < 0) {
			  VMOVE( mpt, es_pt );
			} else {
			  VMOVE( mpt, &ars->curves[es_ars_crv][es_ars_col*3] );
			}

			*strp = "V";
			break;
		}
	case ID_RPC:
		{
			struct rt_rpc_internal *rpc =
				(struct rt_rpc_internal *)ip->idb_ptr;
			RT_RPC_CK_MAGIC( rpc );

			VMOVE( mpt , rpc->rpc_V );
			*strp = "V";
			break;
		}
	case ID_RHC:
		{
			struct rt_rhc_internal *rhc =
				(struct rt_rhc_internal *)ip->idb_ptr;
			RT_RHC_CK_MAGIC( rhc );

			VMOVE( mpt , rhc->rhc_V );
			*strp = "V";
			break;
		}
	case ID_EPA:
		{
			struct rt_epa_internal *epa =
				(struct rt_epa_internal *)ip->idb_ptr;
			RT_EPA_CK_MAGIC( epa );

			VMOVE( mpt , epa->epa_V );
			*strp = "V";
			break;
		}
	case ID_EHY:
		{
			struct rt_ehy_internal *ehy =
				(struct rt_ehy_internal *)ip->idb_ptr;
			RT_EHY_CK_MAGIC( ehy );

			VMOVE( mpt , ehy->ehy_V );
			*strp = "V";
			break;
		}
	case ID_ETO:
		{
			struct rt_eto_internal *eto =
				(struct rt_eto_internal *)ip->idb_ptr;
			RT_ETO_CK_MAGIC( eto );

			VMOVE( mpt , eto->eto_V );
			*strp = "V";
			break;
		}
	case ID_POLY:
		{
			struct rt_pg_face_internal *_poly;
			struct rt_pg_internal *pg = 
				(struct rt_pg_internal *)ip->idb_ptr;
			RT_PG_CK_MAGIC( pg );

			_poly = pg->poly;
			VMOVE( mpt , _poly->verts );
			*strp = "V";
			break;
		}
	case ID_SKETCH:
		{
			struct rt_sketch_internal *skt = 
				(struct rt_sketch_internal *)ip->idb_ptr;
			RT_SKETCH_CK_MAGIC( skt );

			VMOVE( mpt, skt->V );
			*strp = "V";
			break;
		}
	case ID_EXTRUDE:
		{
			struct rt_extrude_internal *extr = 
				(struct rt_extrude_internal *)ip->idb_ptr;
			RT_EXTRUDE_CK_MAGIC( extr );

			if( extr->skt )
			{
				VJOIN2( mpt, extr->V, extr->skt->verts[0][0], extr->u_vec, extr->skt->verts[0][2], extr->v_vec );
				*strp = "V1";
			}
			else
			{
				VMOVE( mpt, extr->V );
				*strp = "V";
			}
			break;
		}
	case ID_NMG:
		{
			struct vertex *v;
			struct vertexuse *vu;
			struct edgeuse *eu;
			struct loopuse *lu;
			struct faceuse *fu;
			struct shell *s;
			struct nmgregion *r;
			register struct model *m =
				(struct model *) es_int.idb_ptr;
			NMG_CK_MODEL(m);
			/* XXX Fall through, for now (How about first vertex?? - JRA) */

			/* set default first */
			VSETALL( mpt, 0.0 );
			*strp = "(origin)";

#if 1
			/* XXX Try to use the first point of the selected edge */
			if (es_eu != (struct edgeuse *)NULL &&
			    es_eu->vu_p != (struct vertexuse *)NULL &&
			    es_eu->vu_p->v_p != (struct vertex *)NULL &&
			    es_eu->vu_p->v_p->vg_p != (struct vertex_g *)NULL) {
			  VMOVE(mpt, es_eu->vu_p->v_p->vg_p->coord);
			  break;
			}
#endif

			if( BU_LIST_IS_EMPTY( &m->r_hd ) )
				break;

			r = BU_LIST_FIRST( nmgregion , &m->r_hd );
			if( !r )
				break;
			NMG_CK_REGION( r );

			if( BU_LIST_IS_EMPTY( &r->s_hd ) )
				break;

			s = BU_LIST_FIRST( shell , &r->s_hd );
			if( !s )
				break;
			NMG_CK_SHELL( s );

			if( BU_LIST_IS_EMPTY( &s->fu_hd ) )
				fu = (struct faceuse *)NULL;
			else
				fu = BU_LIST_FIRST( faceuse , &s->fu_hd );
			if( fu )
			{
				NMG_CK_FACEUSE( fu );
				lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
				NMG_CK_LOOPUSE( lu );
				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC )
				{
					eu = BU_LIST_FIRST( edgeuse , &lu->down_hd );
					NMG_CK_EDGEUSE( eu );
					NMG_CK_VERTEXUSE( eu->vu_p );
					v = eu->vu_p->v_p;
				}
				else
				{
					vu = BU_LIST_FIRST( vertexuse , &lu->down_hd );
					NMG_CK_VERTEXUSE( vu );
					v = vu->v_p;
				}
				NMG_CK_VERTEX( v );
				if( !v->vg_p )
					break;
				VMOVE( mpt , v->vg_p->coord );
				*strp = "V";
				break;
			}
			if( BU_LIST_IS_EMPTY( &s->lu_hd ) )
				lu = (struct loopuse *)NULL;
			else
				lu = BU_LIST_FIRST( loopuse , &s->lu_hd );
			if( lu )
			{
				NMG_CK_LOOPUSE( lu );
				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC )
				{
					eu = BU_LIST_FIRST( edgeuse , &lu->down_hd );
					NMG_CK_EDGEUSE( eu );
					NMG_CK_VERTEXUSE( eu->vu_p );
					v = eu->vu_p->v_p;
				}
				else
				{
					vu = BU_LIST_FIRST( vertexuse , &lu->down_hd );
					NMG_CK_VERTEXUSE( vu );
					v = vu->v_p;
				}
				NMG_CK_VERTEX( v );
				if( !v->vg_p )
					break;
				VMOVE( mpt , v->vg_p->coord );
				*strp = "V";
				break;
			}
			if( BU_LIST_IS_EMPTY( &s->eu_hd ) )
				eu = (struct edgeuse *)NULL;
			else
				eu = BU_LIST_FIRST( edgeuse , &s->eu_hd );
			if( eu )
			{
				NMG_CK_EDGEUSE( eu );
				NMG_CK_VERTEXUSE( eu->vu_p );
				v = eu->vu_p->v_p;
				NMG_CK_VERTEX( v );
				if( !v->vg_p )
					break;
				VMOVE( mpt , v->vg_p->coord );
				*strp = "V";
				break;
			}
			vu = s->vu_p;
			if( vu )
			{
				NMG_CK_VERTEXUSE( vu );
				v = vu->v_p;
				NMG_CK_VERTEX( v );
				if( !v->vg_p )
					break;
				VMOVE( mpt , v->vg_p->coord );
				*strp = "V";
				break;
			}
		}
	default:
	  Tcl_AppendResult(interp, "get_solid_keypoint: unrecognized solid type (setting keypoint to origin)\n", (char *)NULL);
	  VSETALL( mpt, 0.0 );
	  *strp = "(origin)";
	  break;
	}
	MAT4X3PNT( pt, mat, mpt );
}

int
f_get_solid_keypoint(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	if( state == ST_VIEW || state == ST_S_PICK || state == ST_O_PICK )
		return TCL_OK;

	get_solid_keypoint( es_keypoint, &es_keytag, &es_int, es_mat );
	return TCL_OK;
}

void
set_e_axes_pos(int both)
             /* if(!both) then set only curr_e_axes_pos, otherwise
	      set e_axes_pos and curr_e_axes_pos */
{
	int	i;
	register struct dm_list *dmlp;

	update_views = 1;
#if 0
	VMOVE(curr_e_axes_pos, es_keypoint);
#else
	switch (es_int.idb_type) {
	case	ID_ARB8:
		if (state == ST_O_EDIT)
			i = 0;
		else
			switch (es_edflag) {
			case STRANS:
				i = 0;
				break;
			case EARB:
				switch (es_type) {
				case ARB5:
					i = earb5[es_menu][0];
					break;
				case ARB6:
					i = earb6[es_menu][0];
					break;
				case ARB7:
					i = earb7[es_menu][0];
					break;
				case ARB8:
					i = earb8[es_menu][0];
					break;
				default:
					i = 0;
					break;
				}
				break;
			case PTARB:
				switch (es_type) {
				case ARB4:
					i = es_menu;	/* index for point 1,2,3 or 4 */
					break;
				case ARB5:
				case ARB7:
					i = 4;	/* index for point 5 */
					break;
				case ARB6:
					i = es_menu;	/* index for point 5 or 6 */
					break;
				default:
					i = 0;
					break;
				}
				break;
			case ECMD_ARB_MOVE_FACE:
				switch (es_type) {
				case ARB4:
					i = arb_faces[0][es_menu * 4];
					break;
				case ARB5:
					i = arb_faces[1][es_menu * 4];  		
					break;
				case ARB6:
					i = arb_faces[2][es_menu * 4];  		
					break;
				case ARB7:
					i = arb_faces[3][es_menu * 4];  		
					break;
				case ARB8:
					i = arb_faces[4][es_menu * 4];  		
					break;
				default:
					i = 0;
					break;
				}
				break;
			case ECMD_ARB_ROTATE_FACE:
				i = fixv;
				break;
			default:
				i = 0;
				break;
			}

		MAT4X3PNT(curr_e_axes_pos, es_mat,
			  ((struct rt_arb_internal *)es_int.idb_ptr)->pt[i]);
		break;
	case ID_TGC:
	case ID_REC:
		if (es_edflag == ECMD_TGC_MV_H ||
		    es_edflag == ECMD_TGC_MV_HH) {
			struct rt_tgc_internal  *tgc = (struct rt_tgc_internal *)es_int.idb_ptr;
			point_t tgc_v;
			vect_t tgc_h;

			MAT4X3PNT(tgc_v, es_mat, tgc->v);
			MAT4X3VEC(tgc_h, es_mat, tgc->h);
			VADD2(curr_e_axes_pos, tgc_h, tgc_v);
		} else
			VMOVE(curr_e_axes_pos, es_keypoint)

				break;
	case ID_EXTRUDE:
		if (es_edflag == ECMD_EXTR_MOV_H) {
			struct rt_extrude_internal *extr = (struct rt_extrude_internal *)es_int.idb_ptr;
			point_t extr_v;
			vect_t extr_h;

			RT_EXTRUDE_CK_MAGIC(extr);

			MAT4X3PNT(extr_v, es_mat, extr->V);
			MAT4X3VEC(extr_h, es_mat, extr->h);
			VADD2(curr_e_axes_pos, extr_h, extr_v);
		} else
			VMOVE(curr_e_axes_pos, es_keypoint)

				break;
	case ID_CLINE:
		if (es_edflag == ECMD_CLINE_MOVE_H) {
			struct rt_cline_internal *cli = 
				(struct rt_cline_internal *)es_int.idb_ptr;
			point_t cli_v;
			vect_t cli_h;

			RT_CLINE_CK_MAGIC(cli);

			MAT4X3PNT(cli_v, es_mat, cli->v);
			MAT4X3VEC(cli_h, es_mat, cli->h);
			VADD2(curr_e_axes_pos, cli_h, cli_v);
		} else
			VMOVE(curr_e_axes_pos, es_keypoint)
				break;
	default:
		VMOVE(curr_e_axes_pos, es_keypoint);
		break;
	}
#endif

	if (both) {
		VMOVE(e_axes_pos, curr_e_axes_pos);

		if (EDIT_ROTATE) {
			es_edclass = EDIT_CLASS_ROTATE;
			VSETALL( edit_absolute_model_rotate, 0.0 );
			VSETALL( edit_absolute_object_rotate, 0.0 );
			VSETALL( edit_absolute_view_rotate, 0.0 );
			VSETALL( last_edit_absolute_model_rotate, 0.0 );
			VSETALL( last_edit_absolute_object_rotate, 0.0 );
			VSETALL( last_edit_absolute_view_rotate, 0.0 );
		} else if (EDIT_TRAN) {
			es_edclass = EDIT_CLASS_TRAN;
			VSETALL( edit_absolute_model_tran, 0.0 );
			VSETALL( edit_absolute_view_tran, 0.0 );
			VSETALL( last_edit_absolute_model_tran, 0.0 );
			VSETALL( last_edit_absolute_view_tran, 0.0 );
		} else if (EDIT_SCALE) {
			es_edclass = EDIT_CLASS_SCALE;

			if (SEDIT_SCALE) {
				edit_absolute_scale = 0.0;
				acc_sc_sol = 1.0;
			}
		} else
			es_edclass = EDIT_CLASS_NULL;

#if 1
		MAT_IDN(acc_rot_sol);
#endif

		FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l)
			dmlp->dml_mged_variables->mv_transform = 'e';
	}
}

/*
 *			I N I T _ S E D I T
 *
 *  First time in for this solid, set things up.
 *  If all goes well, change state to ST_S_EDIT.
 *  Solid editing is completed only via sedit_accept() / sedit_reject().
 */
void
init_sedit(void)
{
	register int		type;
	int			id;

	if(dbip == DBI_NULL)
	  return;

	/*
	 * Check for a processed region or other illegal solid.
	 */
	if( illump->s_Eflag )  {
	  Tcl_AppendResult(interp,
"Unable to Solid_Edit a processed region;  select a primitive instead\n", (char *)NULL);
	  return;
	}

	/* Read solid description into es_int */
	if( rt_db_get_internal( &es_int, LAST_SOLID(illump),
	  dbip, NULL, &rt_uniresource ) < 0 )  {
	  Tcl_AppendResult(interp, "init_sedit(",
	  		LAST_SOLID(illump)->d_namep,
			   "):  solid import failure\n", (char *)NULL);
	  rt_db_free_internal( &es_int, &rt_uniresource );
	  return;				/* FAIL */
	}
	RT_CK_DB_INTERNAL( &es_int );
	id = es_int.idb_type;

	es_menu = 0;
	if( id == ID_ARB8 )
	{
		struct rt_arb_internal *arb;

		arb = (struct rt_arb_internal *)es_int.idb_ptr;
		RT_ARB_CK_MAGIC( arb );

		type = rt_arb_std_type( &es_int , &mged_tol );
		es_type = type;

		if( rt_arb_calc_planes( es_peqn , arb , es_type , &mged_tol ) )
		{
		  Tcl_AppendResult(interp,"Cannot calculate plane equations for ARB8\n",
				   (char *)NULL);
		  rt_db_free_internal( &es_int, &rt_uniresource );
		  return;
		}
	}
	else if( id == ID_BSPLINE )
	{
		register struct rt_nurb_internal *sip =
			(struct rt_nurb_internal *) es_int.idb_ptr;
		register struct face_g_snurb	*surf;
		RT_NURB_CK_MAGIC(sip);
		spl_surfno = sip->nsrf/2;
		surf = sip->srfs[spl_surfno];
		NMG_CK_SNURB(surf);
		spl_ui = surf->s_size[1]/2;
		spl_vi = surf->s_size[0]/2;
	}

	/* Save aggregate path matrix */
	pathHmat( illump, es_mat, illump->s_fullpath.fp_len-2 );

	/* get the inverse matrix */
	bn_mat_inv( es_invmat, es_mat );

	/* Establish initial keypoint */
	es_keytag = "";
	get_solid_keypoint( es_keypoint, &es_keytag, &es_int, es_mat );

	es_eu = (struct edgeuse *)NULL;	/* Reset es_eu */
	es_pipept = (struct wdb_pipept *)NULL; /* Reset es_pipept */
	lu_copy = (struct loopuse *)NULL;
	es_ars_crv = (-1);
	es_ars_col = (-1);

	bot_verts[0] = -1;
	bot_verts[1] = -1;
	bot_verts[2] = -1;

	/* Finally, enter solid edit state */
	(void)chg_state( ST_S_PICK, ST_S_EDIT, "Keyboard illuminate");
	chg_l2menu(ST_S_EDIT);
	es_edflag = IDLE;

	button( BE_S_EDIT );	/* Drop into edit menu right away */
	init_sedit_vars();

	{
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_strcpy(&vls, "begin_edit_callback ");
		db_path_to_vls(&vls, &illump->s_fullpath);
		(void)Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
	}
}

static void
init_sedit_vars(void)
{
	MAT_IDN(acc_rot_sol);
	MAT_IDN(incr_change);

	VSETALL(edit_absolute_model_rotate, 0.0);
	VSETALL(edit_absolute_object_rotate, 0.0);
	VSETALL(edit_absolute_view_rotate, 0.0);
	VSETALL(last_edit_absolute_model_rotate, 0.0);
	VSETALL(last_edit_absolute_object_rotate, 0.0);
	VSETALL(last_edit_absolute_view_rotate, 0.0);
	VSETALL(edit_absolute_model_tran, 0.0);
	VSETALL(edit_absolute_view_tran, 0.0);
	VSETALL(last_edit_absolute_model_tran, 0.0);
	VSETALL(last_edit_absolute_view_tran, 0.0);
	edit_absolute_scale = 0.0;
	acc_sc_sol = 1.0;

	VSETALL(edit_rate_model_rotate, 0.0);
	VSETALL(edit_rate_object_rotate, 0.0);
	VSETALL(edit_rate_view_rotate, 0.0);
	VSETALL(edit_rate_model_tran, 0.0);
	VSETALL(edit_rate_view_tran, 0.0);

	set_e_axes_pos(1);
}

/*
 *			R E P L O T _ E D I T I N G _ S O L I D
 *
 *  All solid edit routines call this subroutine after
 *  making a change to es_int or es_mat.
 */
void
replot_editing_solid(void)
{
  mat_t mat;
  register struct solid *sp;
  struct directory *illdp = LAST_SOLID(illump);

  FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
    if(LAST_SOLID(sp) == illdp )  {
      pathHmat( sp, mat, sp->s_fullpath.fp_len-2 );
      (void)replot_modified_solid( sp, &es_int, mat );
    }
  }
}

/*
 *			T R A N S F O R M _ E D I T I N G _ S O L I D
 *
 */
void
transform_editing_solid(
	struct rt_db_internal	*os,		/* output solid */
	const mat_t		mat,
	struct rt_db_internal	*is,		/* input solid */
	int			free)
{
	RT_CK_DB_INTERNAL( is );
	if( rt_functab[is->idb_type].ft_xform( os, mat, is, free, dbip, &rt_uniresource ) < 0 )
		bu_bomb("transform_editing_solid");
}

/*
 *			S E D I T _ M E N U
 *
 *
 *  Put up menu header
 */
void
sedit_menu(void) {

	menu_state->ms_flag = 0;		/* No menu item selected yet */

	mmenu_set_all( MENU_L1, MENU_NULL );
	chg_l2menu(ST_S_EDIT);
                                                                      
	switch( es_int.idb_type ) {

	case ID_ARB8:
		mmenu_set_all( MENU_L1, cntrl_menu );
		break;
	case ID_TGC:
		mmenu_set_all( MENU_L1, tgc_menu );
		break;
	case ID_TOR:
		mmenu_set_all( MENU_L1, tor_menu );
		break;
	case ID_ELL:
		mmenu_set_all( MENU_L1, ell_menu );
		break;
	case ID_SUPERELL:
		mmenu_set_all( MENU_L1, superell_menu );
		break;
	case ID_ARS:
		mmenu_set_all( MENU_L1, ars_menu );
		break;
	case ID_BSPLINE:
		mmenu_set_all( MENU_L1, spline_menu );
		break;
	case ID_RPC:
		mmenu_set_all( MENU_L1, rpc_menu );
		break;
	case ID_RHC:
		mmenu_set_all( MENU_L1, rhc_menu );
		break;
	case ID_EPA:
		mmenu_set_all( MENU_L1, epa_menu );
		break;
	case ID_EHY:
		mmenu_set_all( MENU_L1, ehy_menu );
		break;
	case ID_ETO:
		mmenu_set_all( MENU_L1, eto_menu );
		break;
	case ID_NMG:
		mmenu_set_all( MENU_L1, nmg_menu );
		break;
	case ID_PIPE:
		mmenu_set_all( MENU_L1, pipe_menu );
		break;
	case ID_VOL:
		mmenu_set_all( MENU_L1, vol_menu );
		break;
	case ID_EBM:
		mmenu_set_all( MENU_L1, ebm_menu );
		break;
	case ID_DSP:
		mmenu_set_all( MENU_L1, dsp_menu );
		break;
	case ID_PARTICLE:
		mmenu_set_all( MENU_L1, part_menu );
		break;
	case ID_BOT:
		mmenu_set_all( MENU_L1, bot_menu );
		break;
	case ID_EXTRUDE:
		mmenu_set_all( MENU_L1, extr_menu );
		break;
	case ID_CLINE:
		mmenu_set_all( MENU_L1, cline_menu );
		break;
	}
	es_edflag = IDLE;	/* Drop out of previous edit mode */
	es_menu = 0;
}

int
get_rotation_vertex(void)
{
  int i, j;
  int type, loc, valid;
  int fixv = -1;
  struct bu_vls str;
  struct bu_vls cmd;

  type = es_type - 4;

  loc = es_menu*4;
  valid = 0;
  bu_vls_init(&str);
  bu_vls_init(&cmd);

  bu_vls_printf(&str, "Enter fixed vertex number( ");
  for(i=0; i<4; i++){
    if( arb_vertices[type][loc+i] )
      bu_vls_printf(&str, "%d ", arb_vertices[type][loc+i]);
  }
  bu_vls_printf(&str, ") [%d]: ",arb_vertices[type][loc]);

  bu_vls_printf(&cmd, "cad_input_dialog .get_vertex %S {Need vertex for solid rotate}\
 {%s} vertex_num %d 0 {{ summary \"Enter a vertex number to rotate about.\"}} OK",
		&dName, bu_vls_addr(&str), arb_vertices[type][loc]);

  while(!valid){
    if(Tcl_Eval(interp, bu_vls_addr(&cmd)) != TCL_OK){
      Tcl_AppendResult(interp, "get_rotation_vertex: Error reading vertex\n", (char *)NULL);
      /* Using default */
      return arb_vertices[type][loc];
    }

    fixv = atoi(Tcl_GetVar(interp, "vertex_num", TCL_GLOBAL_ONLY));
    for(j=0; j<4; j++)  {
      if( fixv==arb_vertices[type][loc+j] )
	valid=1;
    }
  }

  bu_vls_free(&str);
  return fixv;
}

char *
get_file_name(char *str)
{
	struct bu_vls cmd;
	struct bu_vls varname_vls;
	char *dir;
	char *fptr;
	char *ptr1;
	char *ptr2;

	bu_vls_init( &cmd );
	bu_vls_init( &varname_vls );
	bu_vls_strcpy( &varname_vls, "mged_gui(getFileDir)" );

	if( (fptr=strrchr( str, '/')))
	{
		dir = (char *)bu_malloc( (strlen(str)+1)*sizeof( char ), "get_file_name: dir" );
		ptr1 = str;
		ptr2 = dir;
		while( ptr1 != fptr )
			*ptr2++ = *ptr1++;
		*ptr2 = '\0';
		Tcl_SetVar(interp, bu_vls_addr(&varname_vls), dir, TCL_GLOBAL_ONLY);
		bu_free((genptr_t)dir, "get_file_name: directory string");
	}

	bu_vls_printf(&cmd,
		      "getFile %s %s {{{All Files} {*}}} {Get File}",
		      bu_vls_addr(&pathName),
		      bu_vls_addr(&varname_vls));
	bu_vls_free(&varname_vls);

	if( Tcl_Eval( interp, bu_vls_addr( &cmd ) ) )
	{
		bu_vls_free( &cmd );
		return( (char *)NULL );
	}
	else if( interp->result[0] != '\0' )
	{
		bu_vls_free( &cmd );
		return( interp->result );
	}
	else
	{
		bu_vls_free( &cmd );
		return( (char *)NULL );
	}
}

static void 
dsp_scale(struct rt_dsp_internal *dsp, int idx)
{
	mat_t m, scalemat;

	RT_DSP_CK_MAGIC(dsp);

	MAT_IDN(m);

	if (es_mvalid) {
		bu_log("es_mvalid %g %g %g\n", V3ARGS(es_mparam));
	}

	if (inpara > 0) {
		m[idx] = es_para[0];
		bu_log("Keyboard %g\n", es_para[0]);
	} else if (es_scale != 0.0) {
		m[idx] *= es_scale;
		bu_log("es_scale %g\n", es_scale);
		es_scale = 0.0;
	}

	bn_mat_xform_about_pt(scalemat, m, es_keypoint);

	bn_mat_mul(m, dsp->dsp_stom, scalemat);
	MAT_COPY(dsp->dsp_stom, m);

	bn_mat_mul(m, scalemat, dsp->dsp_mtos);
	MAT_COPY(dsp->dsp_mtos, m);

}
/*
 * 			S E D I T
 * 
 * A great deal of magic takes place here, to accomplish solid editing.
 *
 *  Called from mged main loop after any event handlers:
 *		if( sedraw > 0 )  sedit();
 *  to process any residual events that the event handlers were too
 *  lazy to handle themselves.
 *
 *  A lot of processing is deferred to here, so that the "p" command
 *  can operate on an equal footing to mouse events.
 */
void
sedit(void)
{
	struct rt_arb_internal *arb;
	fastf_t	*eqp;
	static vect_t work;
	register int i;
	static int pnt5;		/* ECMD_ARB_SETUP_ROTFACE, special arb7 case */
	static float la, lb, lc, ld;	/* TGC: length of vectors */
	mat_t	mat;
	mat_t	mat1;
	mat_t	edit;
	point_t rot_point;

	if(dbip == DBI_NULL)
	  return;

	sedraw = 0;
	++update_views;

	switch( es_edflag ) {

	case IDLE:
	  /* do nothing more */
	  --update_views;
	  break;

	case ECMD_DSP_SCALE_X:
		dsp_scale( (struct rt_dsp_internal *)es_int.idb_ptr, MSX);
		break;
	case ECMD_DSP_SCALE_Y:
		dsp_scale( (struct rt_dsp_internal *)es_int.idb_ptr, MSY);
		break;
	case ECMD_DSP_SCALE_ALT:
		dsp_scale( (struct rt_dsp_internal *)es_int.idb_ptr, MSZ);
		break;
	case ECMD_DSP_FNAME:
		{
			struct rt_dsp_internal *dsp =
				(struct rt_dsp_internal *)es_int.idb_ptr;
			char *fname;
			struct stat stat_buf;
			off_t need_size;
			struct bu_vls message;

			RT_DSP_CK_MAGIC( dsp );

			/* Pop-up the Tk file browser */
			fname = get_file_name( bu_vls_addr(&dsp->dsp_name) );
			if ( ! fname) break;

			if( stat( fname, &stat_buf ) ) {
				bu_vls_init( &message );
				bu_vls_printf( &message, "Cannot get status of file %s\n", fname );
				Tcl_SetResult(interp, bu_vls_addr( &message ), TCL_VOLATILE );
				bu_vls_free( &message );
				mged_print_result( TCL_ERROR );
				return;
			}

			need_size = dsp->dsp_xcnt * dsp->dsp_ycnt * 2;
			if (stat_buf.st_size < need_size) {
				bu_vls_init( &message );
				bu_vls_printf( &message, "File (%s) is too small, adjust the file size parameters first", fname);
				Tcl_SetResult(interp, bu_vls_addr( &message ), TCL_VOLATILE);
				bu_vls_free( &message );
				mged_print_result( TCL_ERROR );
				return;
			}
			bu_vls_strcpy( &dsp->dsp_name, fname );

			break;
		}

	case ECMD_EBM_FSIZE:	/* set file size */
		{
			struct rt_ebm_internal *ebm =
				(struct rt_ebm_internal *)es_int.idb_ptr;
			struct stat stat_buf;
			off_t need_size;

			RT_EBM_CK_MAGIC( ebm );

			if( inpara == 2 )
			{
				if( stat( ebm->file, &stat_buf ) )
				{
					Tcl_AppendResult(interp, "Cannot get status of file ", ebm->file, (char *)NULL );
					mged_print_result( TCL_ERROR );
					return;
				}
				need_size = es_para[0] * es_para[1] * sizeof( unsigned char );
				if( stat_buf.st_size < need_size )
				{
					Tcl_AppendResult(interp, "File (", ebm->file,
						") is too small, set file name first", (char *)NULL );
					mged_print_result( TCL_ERROR );
					return;
				}
				ebm->xdim = es_para[0];
				ebm->ydim = es_para[1];
			}
			else if( inpara > 0 )
			{
				Tcl_AppendResult(interp, "width and length of file are required\n", (char *)NULL );
				mged_print_result( TCL_ERROR );
				return;
			}
		}
		break;

	case ECMD_EBM_FNAME:
		{
			struct rt_ebm_internal *ebm =
				(struct rt_ebm_internal *)es_int.idb_ptr;
			char *fname;
			struct stat stat_buf;
			off_t need_size;

			RT_EBM_CK_MAGIC( ebm );

			fname = get_file_name( ebm->file );
			if( fname )
			{
				struct bu_vls message;

				if( stat( fname, &stat_buf ) )
				{
					bu_vls_init( &message );
					bu_vls_printf( &message, "Cannot get status of file %s\n", fname );
					Tcl_SetResult(interp, bu_vls_addr( &message ), TCL_VOLATILE );
					bu_vls_free( &message );
					mged_print_result( TCL_ERROR );
					return;
				}
				need_size = ebm->xdim * ebm->ydim * sizeof( unsigned char );
				if( stat_buf.st_size < need_size )
				{
					bu_vls_init( &message );
					bu_vls_printf( &message, "File (%s) is too small, adjust the file size parameters first", fname);
					Tcl_SetResult(interp, bu_vls_addr( &message ), TCL_VOLATILE);
					bu_vls_free( &message );
					mged_print_result( TCL_ERROR );
					return;
				}
				strcpy( ebm->file, fname );
			}

			break;
		}

	case ECMD_EBM_HEIGHT:	/* set extrusion depth */
		{
			struct rt_ebm_internal *ebm =
				(struct rt_ebm_internal *)es_int.idb_ptr;

			RT_EBM_CK_MAGIC( ebm );

			if( inpara == 1 )
				ebm->tallness = es_para[0];
			else if( inpara > 0 )
			{
				Tcl_AppendResult(interp,
					"extrusion depth required\n",
					(char *)NULL );
				mged_print_result( TCL_ERROR );
				return;
			}
			else if( es_scale > 0.0 )
			{	
				ebm->tallness *= es_scale;
				es_scale = 0.0;
			}
		}
		break;

	case ECMD_VOL_CSIZE:	/* set voxel size */
		{
			struct rt_vol_internal *vol =
				(struct rt_vol_internal *)es_int.idb_ptr;

			RT_VOL_CK_MAGIC( vol );

			if( inpara == 3 )
				VMOVE( vol->cellsize, es_para )
			else if( inpara > 0 && inpara != 3 )
			{
				Tcl_AppendResult(interp, "x, y, and z cell sizes are required\n", (char *)NULL );
				mged_print_result( TCL_ERROR );
				return;
			}
			else if( es_scale > 0.0 )
			{	
				VSCALE( vol->cellsize, vol->cellsize, es_scale )
				es_scale = 0.0;
			}
		}
		break;

	case ECMD_VOL_FSIZE:	/* set file size */
		{
			struct rt_vol_internal *vol =
				(struct rt_vol_internal *)es_int.idb_ptr;
			struct stat stat_buf;
			off_t need_size;

			RT_VOL_CK_MAGIC( vol );

			if( inpara == 3 )
			{
				if( stat( vol->file, &stat_buf ) )
				{
					Tcl_AppendResult(interp, "Cannot get status of file ", vol->file, (char *)NULL );
					mged_print_result( TCL_ERROR );
					return;
				}
				need_size = es_para[0] * es_para[1] * es_para[2] * sizeof( unsigned char );
				if( stat_buf.st_size < need_size )
				{
					Tcl_AppendResult(interp, "File (", vol->file,
						") is too small, set file name first", (char *)NULL );
					mged_print_result( TCL_ERROR );
					return;
				}
				vol->xdim = es_para[0];
				vol->ydim = es_para[1];
				vol->zdim = es_para[2];
			}
			else if( inpara > 0 )
			{
				Tcl_AppendResult(interp, "x, y, and z file sizes are required\n", (char *)NULL );
				mged_print_result( TCL_ERROR );
				return;
			}
		}
		break;

	case ECMD_VOL_THRESH_LO:
		{
			struct rt_vol_internal *vol =
				(struct rt_vol_internal *)es_int.idb_ptr;

			RT_VOL_CK_MAGIC( vol );

			i = vol->lo;
			if( inpara )
				i = es_para[0];
			else if( es_scale > 0.0 )
			{
				i = vol->lo * es_scale;
				if( i == vol->lo && es_scale > 1.0 )
					i++;
				else if( i == vol->lo && es_scale < 1.0 )
					i--;
			}

			if( i < 0 )
				i = 0;

			if( i > 255 )
				i = 255;

			vol->lo = i;
			break;
		}

	case ECMD_VOL_THRESH_HI:
		{
			struct rt_vol_internal *vol =
				(struct rt_vol_internal *)es_int.idb_ptr;

			RT_VOL_CK_MAGIC( vol );

			i = vol->hi;
			if( inpara )
				i = es_para[0];
			else if( es_scale > 0.0 )
			{
				i = vol->hi * es_scale;
				if( i == vol->hi && es_scale > 1.0 )
					i++;
				else if( i == vol->hi && es_scale < 1.0 )
					i--;
			}

			if( i < 0 )
				i = 0;

			if( i > 255 )
				i = 255;

			vol->hi = i;
			break;
		}

	case ECMD_VOL_FNAME:
		{
			struct rt_vol_internal *vol =
				(struct rt_vol_internal *)es_int.idb_ptr;
			char *fname;
			struct stat stat_buf;
			off_t need_size;

			RT_VOL_CK_MAGIC( vol );

			fname = get_file_name( vol->file );
			if( fname )
			{
				struct bu_vls message;

				if( stat( fname, &stat_buf ) )
				{
					bu_vls_init( &message );
					bu_vls_printf( &message, "Cannot get status of file %s\n", fname );
					Tcl_SetResult(interp, bu_vls_addr( &message ), TCL_VOLATILE );
					bu_vls_free( &message );
					mged_print_result( TCL_ERROR );
					return;
				}
				need_size = vol->xdim * vol->ydim * vol->zdim * sizeof( unsigned char );
				if( stat_buf.st_size < need_size )
				{
					bu_vls_init( &message );
					bu_vls_printf( &message, "File (%s) is too small, adjust the file size parameters first", fname);
					Tcl_SetResult(interp, bu_vls_addr( &message ), TCL_VOLATILE);
					bu_vls_free( &message );
					mged_print_result( TCL_ERROR );
					return;
				}
				strcpy( vol->file, fname );
			}

			break;
		}

	case ECMD_BOT_MODE:
		{
			struct rt_bot_internal *bot =
				(struct rt_bot_internal *)es_int.idb_ptr;
			const char *radio_result;
			char mode[10];
			int ret_tcl;
			int old_mode;

			RT_BOT_CK_MAGIC( bot );
			old_mode = bot->mode;
			sprintf( mode, " %d", old_mode - 1);
			ret_tcl = Tcl_VarEval( interp, "cad_radio", " .bot_mode_radio ",
				   bu_vls_addr( &pathName ), " _bot_mode_result",
				   " \"BOT Mode\"", "  \"Select the desired mode\"", mode,
				   " { surface volume plate plate/nocosine }",
				   " { \"In surface mode, each triangle represents part of a zero thickness surface and no volume is enclosed\" \"In volume mode, the triangles are expected to enclose a volume and that volume becomes the solid\" \"In plate mode, each triangle represents a plate with a specified thickness\" \"In plate/nocosine mode, each triangle represents a plate with a specified thickness, but the LOS thickness reported by the raytracer is independent of obliquity angle\" } ", (char *)NULL );
			if( ret_tcl != TCL_OK )
			{
				Tcl_AppendResult(interp, "Mode selection failed!!!\n", (char *)NULL );
				break;
			}
			radio_result = Tcl_GetVar( interp, "_bot_mode_result", TCL_GLOBAL_ONLY );
			bot->mode = atoi( radio_result ) + 1;
			if( bot->mode == RT_BOT_PLATE || bot->mode == RT_BOT_PLATE_NOCOS )
			{
				if( old_mode != RT_BOT_PLATE && old_mode != RT_BOT_PLATE_NOCOS )
				{
					/* need to create some thicknesses */
					bot->thickness = (fastf_t *)bu_calloc( bot->num_faces, sizeof( fastf_t ), "BOT thickness" );
					bot->face_mode = bu_bitv_new( bot->num_faces );
					bu_bitv_clear( bot->face_mode );
				}
			}
			else
			{
				if( old_mode == RT_BOT_PLATE || old_mode == RT_BOT_PLATE_NOCOS )
				{
					/* free the per face memory */
					bu_free( (char *)bot->thickness, "BOT thickness" );
					bot->thickness = (fastf_t *)NULL;
					bu_free( (char *)bot->face_mode, "BOT face_mode" );
					bot->face_mode = (struct bu_bitv *)NULL;
				}
			}
		}
		break;
	case ECMD_BOT_ORIENT:
		{
			struct rt_bot_internal *bot =
				(struct rt_bot_internal *)es_int.idb_ptr;
			const char *radio_result;
			char orient[10];
			int ret_tcl;

			RT_BOT_CK_MAGIC( bot );
			sprintf( orient, " %d", bot->orientation - 1);
			ret_tcl = Tcl_VarEval( interp, "cad_radio", " .bot_orient_radio ",
				   bu_vls_addr( &pathName ), " _bot_orient_result",
				   " \"BOT Face Orientation\"", "  \"Select the desired orientation\"", orient,
				   " { none right-hand-rule left-hand-rule }",
				   " { \"No orientation means that there is no particular order for the vertices of the triangles\" \"right-hand-rule means that the vertices of each triangle are ordered such that the right-hand-rule produces an outward pointing normal\"  \"left-hand-rule means that the vertices of each triangle are ordered such that the left-hand-rule produces an outward pointing normal\" } ", (char *)NULL );
			if( ret_tcl != TCL_OK )
			{
				Tcl_AppendResult(interp, "Face orientation selection failed!!!\n", (char *)NULL );
				break;
			}
			radio_result = Tcl_GetVar( interp, "_bot_orient_result", TCL_GLOBAL_ONLY );
			bot->orientation = atoi( radio_result ) + 1;
		}
		break;
	case ECMD_BOT_THICK:
		{
			struct rt_bot_internal *bot =
				(struct rt_bot_internal *)es_int.idb_ptr;
			int i, face_no;

			RT_BOT_CK_MAGIC( bot );

			if( bot->mode != RT_BOT_PLATE && bot->mode != RT_BOT_PLATE_NOCOS )
			{
				if( Tcl_VarEval( interp, "cad_dialog ", ".bot_err ", "$mged_gui(mged,screen) ", "{Not Plate Mode} ",
					"{Cannot edit face thickness in a non-plate BOT} ", "\"\" ", "0 ", "OK ",
					(char *)NULL ) != TCL_OK )
				{
					bu_log( "cad_dialog failed!!!!: %s\n", interp->result );
				}
				break;
			}

			if( bot_verts[0] < 0 || bot_verts[1] < 0 || bot_verts[2] < 0 )
			{
				/* setting thickness for all faces */
				if( !inpara )
					break;

				(void)Tcl_VarEval( interp, "cad_dialog ", ".bot_err ",
					"$mged_gui(mged,screen) ", "{Setting Thickness for All Faces} ",
					"{No face is selected, so this operation will modify all the faces in this BOT} ",
					"\"\" ", "0 ", "OK ", "CANCEL ", (char *)NULL );
				if( atoi( interp->result) )
					break;

				for( i=0 ; i<bot->num_faces ; i++ )
					bot->thickness[i] = es_para[0];
			}
			else
			{
				/* setting thickness for just one face */
				if( !inpara )
					break;

				face_no = -1;
				for( i=0 ; i < bot->num_faces ; i++ )
				{
					if( bot_verts[0] == bot->faces[i*3] &&
					    bot_verts[1] == bot->faces[i*3+1] &&
					    bot_verts[2] == bot->faces[i*3+2] )
					{
						face_no = i;
						break;
					}
				}
				if( face_no < 0 )
				{
					bu_log( "Cannot find face with vertices %d %d %d!!\n",
						V3ARGS( bot_verts ) );
					break;
				}

				bot->thickness[face_no] = es_para[0];
			}
		}
		break;
	case ECMD_BOT_FLAGS:
		{
			int ret_tcl;
			const char *dialog_result;
			char cur_settings[11];
			struct rt_bot_internal *bot =
				(struct rt_bot_internal *)es_int.idb_ptr;

			RT_BOT_CK_MAGIC( bot );

			strcpy( cur_settings, " { 0 0 }" );

			if( bot->bot_flags & RT_BOT_USE_NORMALS ) {
				cur_settings[3] = '1';
			}
			if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
				cur_settings[5] = '1';
			}

			ret_tcl = Tcl_VarEval( interp,
					       "cad_list_buts",
					       " .bot_list_flags ",
					       bu_vls_addr( &pathName ),
					       " _bot_flags_result ",
					       cur_settings,
					       " \"BOT Flags\"",
					       " \"Select the desired flags\"",
					       " { {Use vertex normals} {Use single precision ray-tracing} }",
					       " { {This selection indicates that surface normals at hit points should be interpolated from vertex normals} {This selection indicates that the prepped form of the BOT triangles should use sigle precision to save memory} } ",
					       (char *)NULL );
			if( ret_tcl != TCL_OK )
			{
				bu_log( "ERROR: cad_list_buts: %s\n", interp->result );
				break;
			}
			dialog_result = Tcl_GetVar( interp, "_bot_flags_result", TCL_GLOBAL_ONLY );

			if( dialog_result[0] == '1' ) {
				bot->bot_flags |= RT_BOT_USE_NORMALS;
			} else {
				bot->bot_flags &= ~RT_BOT_USE_NORMALS;
			}
			if( dialog_result[2] == '1' ) {
				bot->bot_flags |= RT_BOT_USE_FLOATS;
			} else {
				bot->bot_flags &= ~RT_BOT_USE_FLOATS;
			}
		}
		break;
	case ECMD_BOT_FMODE:
		{
			struct rt_bot_internal *bot =
				(struct rt_bot_internal *)es_int.idb_ptr;
			char fmode[10];
			const char *radio_result;
			int face_no;
			int ret_tcl;

			RT_BOT_CK_MAGIC( bot );

			if( bot->mode != RT_BOT_PLATE && bot->mode != RT_BOT_PLATE_NOCOS )
			{
				(void)Tcl_VarEval( interp, "cad_dialog ", ".bot_err ", "$mged_gui(mged,screen) ", "{Not Plate Mode} ",
					"{Cannot edit face mode in a non-plate BOT} ", "\"\" ", "0 ", "OK ",
					(char *)NULL );
				break;
			}

			if( bot_verts[0] < 0 || bot_verts[1] < 0 || bot_verts[2] < 0 )
			{
				/* setting mode for all faces */
				(void)Tcl_VarEval( interp, "cad_dialog ", ".bot_err ",
					"$mged_gui(mged,screen) ", "{Setting Mode for All Faces} ",
					"{No face is selected, so this operation will modify all the faces in this BOT} ",
					"\"\" ", "0 ", "OK ", "CANCEL ", (char *)NULL );
				if( atoi( interp->result) )
					break;

				face_no = -2;
			}
			else
			{
				/* setting thickness for just one face */
				face_no = -1;
				for( i=0 ; i < bot->num_faces ; i++ )
				{
					if( bot_verts[0] == bot->faces[i*3] &&
					    bot_verts[1] == bot->faces[i*3+1] &&
					    bot_verts[2] == bot->faces[i*3+2] )
					{
						face_no = i;
						break;
					}
				}
				if( face_no < 0 )
				{
					bu_log( "Cannot find face with vertices %d %d %d!!\n",
						V3ARGS( bot_verts ) );
					break;
				}
			}

			if( face_no > -1 )
				sprintf( fmode, " %d", BU_BITTEST( bot->face_mode, face_no )?1:0 );
			else
				sprintf( fmode, " %d", BU_BITTEST( bot->face_mode, 0 )?1:0 );

			ret_tcl = Tcl_VarEval( interp, "cad_radio", " .bot_fmode_radio ", bu_vls_addr( &pathName ),
					       " _bot_fmode_result ", "\"BOT Face Mode\"",
					       " \"Select the desired face mode\"", fmode,
					       " { {Thickness centered about hit point} {Thickness appended to hit point} }",
					       " { {This selection will place the plate thickness centered about the hit point} {This selection will place the plate thickness rayward of the hit point} } ",
					       (char *)NULL );
			if( ret_tcl != TCL_OK )
			{
				bu_log( "ERROR: cad_radio: %s\n", interp->result );
				break;
			}
			radio_result = Tcl_GetVar( interp, "_bot_fmode_result", TCL_GLOBAL_ONLY );

			if( face_no > -1 )
			{
				if( atoi( radio_result ) )
					BU_BITSET( bot->face_mode, face_no );
				else
					BU_BITCLR( bot->face_mode, face_no );
			}
			else
			{
				if( atoi( radio_result ) )
				{
					for( i=0 ; i<bot->num_faces ; i++ )
						BU_BITSET( bot->face_mode, i );
				}
				else
					bu_bitv_clear( bot->face_mode );
			}
		}
		break;
	case ECMD_BOT_FDEL:
		{
			struct rt_bot_internal *bot =
				(struct rt_bot_internal *)es_int.idb_ptr;

			int i, j, face_no;

			RT_BOT_CK_MAGIC( bot );

			if( bot_verts[0] < 0 || bot_verts[1] < 0 || bot_verts[2] < 0 )
			{
				bu_log( "No Face selected!!!\n" );
				return;
			}

			face_no = -1;
			for( i=0 ; i < bot->num_faces ; i++ )
			{
				if( bot_verts[0] == bot->faces[i*3] &&
				    bot_verts[1] == bot->faces[i*3+1] &&
				    bot_verts[2] == bot->faces[i*3+2] )
				{
					face_no = i;
					break;
				}
			}
			if( face_no < 0 )
			{
				bu_log( "Cannot find selected face!!!\n");
				return;
			}
			bot->num_faces--;
			for( i=face_no ; i<bot->num_faces ; i++ )
			{
				j = i + 1;
				bot->faces[3*i] = bot->faces[3*j];
				bot->faces[3*i + 1] = bot->faces[3*j + 1];
				bot->faces[3*i + 2] = bot->faces[3*j + 2];
				if( bot->thickness )
					bot->thickness[i] = bot->thickness[j];
			}

			if( bot->face_mode )
			{
				struct bu_bitv *new_bitv;

				new_bitv = bu_bitv_new( bot->num_faces );
				BU_BITV_ZEROALL( new_bitv )
				for( i=0 ; i<face_no ; i++ )
				{
					if( BU_BITTEST( bot->face_mode, i ) )
						BU_BITSET( new_bitv, i );
				}
				for( i=face_no ; i<bot->num_faces ; i++ )
				{
					j = i+1;
					if( BU_BITTEST( bot->face_mode, j ) )
						BU_BITSET( new_bitv, i );
				}
				bu_bitv_free( bot->face_mode );
				bot->face_mode = new_bitv;
			}
			bot_verts[0] = -1;
			bot_verts[1] = -1;
			bot_verts[2] = -1;
		}
		break;
	case ECMD_EXTR_SKT_NAME:
		{
			struct rt_extrude_internal *extr =
				(struct rt_extrude_internal *)es_int.idb_ptr;
			const char *sketch_name;
			int ret_tcl;
			struct directory *dp;
			struct rt_db_internal tmp_ip;
			struct bu_vls tcl_cmd;

			RT_EXTRUDE_CK_MAGIC( extr );

			bu_vls_init( &tcl_cmd );
			bu_vls_printf( &tcl_cmd, "cad_input_dialog .get_sketch_name $mged_gui(mged,screen) {Select Sketch} {Enter the name of the sketch to be extruded} final_sketch_name %s 0 {{summary \"Enter sketch name\"}} APPLY DISMISS",
				extr->sketch_name );
			ret_tcl = Tcl_Eval( interp, bu_vls_addr( &tcl_cmd ) );
			if( ret_tcl != TCL_OK )
			{
				bu_log( "ERROR: %s\n", Tcl_GetStringResult( interp ) );
				bu_vls_free( &tcl_cmd );
				break;
			}

			if( atoi( Tcl_GetStringResult( interp ) ) == 1 )
				break;
			
			bu_vls_free( &tcl_cmd );

			sketch_name = Tcl_GetVar( interp, "final_sketch_name", TCL_GLOBAL_ONLY );
			if( extr->sketch_name )
				bu_free( (char *)extr->sketch_name, "extr->sketch_name" );
			extr->sketch_name = bu_strdup( sketch_name );

			if( extr->skt )
			{
				/* free the old sketch */
				RT_INIT_DB_INTERNAL( &tmp_ip );
				tmp_ip.idb_major_type = DB5_MAJORTYPE_BRLCAD;
				tmp_ip.idb_type = ID_SKETCH;
				tmp_ip.idb_ptr = (genptr_t)extr->skt;
				tmp_ip.idb_meth = &rt_functab[ID_SKETCH];
				rt_db_free_internal( &tmp_ip, &rt_uniresource );
			}

			if( (dp=db_lookup( dbip, sketch_name, 0 )) == DIR_NULL )
			{
				bu_log( "Warning: %s does not exist!!!\n",
					sketch_name );
				extr->skt = (struct rt_sketch_internal *)NULL;
			}
			else
			{
				/* import the new sketch */

			        if( rt_db_get_internal( &tmp_ip, dp, dbip, bn_mat_identity, &rt_uniresource ) != ID_SKETCH )
			        {
			                bu_log( "rt_extrude_import: ERROR: Cannot import sketch (%.16s) for extrusion\n",
			                        sketch_name );
			        	extr->skt = (struct rt_sketch_internal *)NULL;
			        }
				else
					extr->skt = (struct rt_sketch_internal *)tmp_ip.idb_ptr;
			}
		}
		break;
	case ECMD_EXTR_MOV_H:
		{
			struct rt_extrude_internal *extr =
				(struct rt_extrude_internal *)es_int.idb_ptr;

			RT_EXTRUDE_CK_MAGIC( extr );
			if( inpara ) {
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model coordinates */
			    MAT4X3PNT( work, es_invmat, es_para );
			    VSUB2(extr->h, work, extr->V);
			  }else{
			    VSUB2(extr->h, es_para, extr->V);
			  }
#else
				/* apply es_invmat to convert to real model coordinates */
				MAT4X3PNT( work, es_invmat, es_para );
				VSUB2(extr->h, work, extr->V);
#endif
			}

			/* check for zero H vector */
			if( MAGNITUDE( extr->h ) <= SQRT_SMALL_FASTF ) {
			  Tcl_AppendResult(interp, "Zero H vector not allowed, resetting to +Z\n",
					   (char *)NULL);
				mged_print_result( TCL_ERROR );
			  VSET(extr->h, 0.0, 0.0, 1.0);
			  break;
			}
		}
		break;
	case ECMD_EXTR_SCALE_H:
		{
			struct rt_extrude_internal *extr =
				(struct rt_extrude_internal *)es_int.idb_ptr;

			RT_EXTRUDE_CK_MAGIC( extr );

			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(extr->h);
				VSCALE(extr->h, extr->h, es_scale);
			}
			else if( es_scale > 0.0 )
			{
				VSCALE(extr->h, extr->h, es_scale);
				es_scale = 0.0;
			}
		}
		break;
	case ECMD_ARB_MAIN_MENU:
		/* put up control (main) menu for GENARB8s */
		menu_state->ms_flag = 0;
		es_edflag = IDLE;
		mmenu_set( MENU_L1, cntrl_menu );
		break;

	case ECMD_ARB_SPECIFIC_MENU:
		/* put up specific arb edit menus */
		menu_state->ms_flag = 0;
		es_edflag = IDLE;
		switch( es_menu ){
			case MENU_ARB_MV_EDGE:  
				mmenu_set( MENU_L1, which_menu[es_type-4] );
				break;
			case MENU_ARB_MV_FACE:
				mmenu_set( MENU_L1, which_menu[es_type+1] );
				break;
			case MENU_ARB_ROT_FACE:
				mmenu_set( MENU_L1, which_menu[es_type+6] );
				break;
			default:
			  Tcl_AppendResult(interp, "Bad menu item.\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  return;
		}
		break;

	case ECMD_ARB_MOVE_FACE:
		/* move face through definite point */
		if(inpara) {
			arb = (struct rt_arb_internal *)es_int.idb_ptr;
			RT_ARB_CK_MAGIC( arb );

#ifdef TRY_EDIT_NEW_WAY
			if(mged_variables->mv_context){
			  /* apply es_invmat to convert to real model space */
			  MAT4X3PNT(work,es_invmat,es_para);
			}else{
			  VMOVE(work, es_para);
			}
#else
			/* apply es_invmat to convert to real model space */
			MAT4X3PNT(work,es_invmat,es_para);
#endif
			/* change D of planar equation */
			es_peqn[es_menu][3]=VDOT(&es_peqn[es_menu][0], work);
			/* find new vertices, put in record in vector notation */
			(void)rt_arb_calc_points( arb , es_type , es_peqn , &mged_tol );
		}
		break;

	case ECMD_ARB_SETUP_ROTFACE:
		arb = (struct rt_arb_internal *)es_int.idb_ptr;
		RT_ARB_CK_MAGIC( arb );

		/* check if point 5 is in the face */
		pnt5 = 0;
		for(i=0; i<4; i++)  {
			if( arb_vertices[es_type-4][es_menu*4+i]==5 )
				pnt5=1;
		}
		
		/* special case for arb7 */
		if( es_type == ARB7  && pnt5 ){
		  Tcl_AppendResult(interp, "\nFixed vertex is point 5.\n", (char *)NULL);
		  fixv = 5;
		}
		else{
#if 1
		  fixv = get_rotation_vertex();
#else
			/* find fixed vertex for ECMD_ARB_ROTATE_FACE */
			fixv=0;
			do  {
				int	type,loc,valid;
				char	line[128];
				
				type = es_type - 4;
				bu_log("\nEnter fixed vertex number( ");
				loc = es_menu*4;
				for(i=0; i<4; i++){
					if( arb_vertices[type][loc+i] )
						bu_log("%d ",
						    arb_vertices[type][loc+i]);
				}
				bu_log(") [%d]: ",arb_vertices[type][loc]);

				(void)fgets( line, sizeof(line), stdin );
				line[strlen(line)-1] = '\0';		/* remove newline */

				if( feof(stdin) )  quit();
				if( line[0] == '\0' )
					fixv = arb_vertices[type][loc]; 	/* default */
				else
					fixv = atoi( line );
				
				/* check whether nimble fingers entered valid vertex */
				valid = 0;
				for(j=0; j<4; j++)  {
					if( fixv==arb_vertices[type][loc+j] )
						valid=1;
				}
				if( !valid )
					fixv=0;
			} while( fixv <= 0 || fixv > es_type );
#endif
		}
		
		pr_prompt();
		fixv--;
		es_edflag = ECMD_ARB_ROTATE_FACE;
		view_state->vs_flag = 1;	/* draw arrow, etc */
		set_e_axes_pos(1);
		break;

	case ECMD_ARB_ROTATE_FACE:
		/* rotate a GENARB8 defining plane through a fixed vertex */

		arb = (struct rt_arb_internal *)es_int.idb_ptr;
		RT_ARB_CK_MAGIC( arb );

		if(inpara) {
			static mat_t invsolr;
			static vect_t tempvec;
			static float rota, fb;

			/*
			 * Keyboard parameters in degrees.
			 * First, cancel any existing rotations,
			 * then perform new rotation
			 */
			bn_mat_inv( invsolr, acc_rot_sol );
			eqp = &es_peqn[es_menu][0];	/* es_menu==plane of interest */
			VMOVE( work, eqp );
			MAT4X3VEC( eqp, invsolr, work );

			if( inpara == 3 ){
				/* 3 params:  absolute X,Y,Z rotations */
				/* Build completely new rotation change */
				MAT_IDN( modelchanges );
				bn_mat_angles(modelchanges,
					      es_para[0],
					      es_para[1],
					      es_para[2]);
				MAT_COPY(acc_rot_sol, modelchanges);

#ifdef TRY_EDIT_NEW_WAY
				/* Borrow incr_change matrix here */
				bn_mat_mul( incr_change, modelchanges, invsolr );
				if(mged_variables->mv_context){
				  /* calculate rotations about keypoint */
				  bn_mat_xform_about_pt( edit, incr_change, es_keypoint );

				  /* We want our final matrix (mat) to xform the original solid
				   * to the position of this instance of the solid, perform the
				   * current edit operations, then xform back.
				   *	mat = es_invmat * edit * es_mat
				   */
				  bn_mat_mul( mat1, edit, es_mat );
				  bn_mat_mul( mat, es_invmat, mat1 );
				  MAT_IDN( incr_change );
				  /* work contains original es_peqn[es_menu][0] */
				  MAT4X3VEC( eqp, mat, work );
				}else{
				  VMOVE( work, eqp );
				  MAT4X3VEC( eqp, modelchanges, work );
				}
#else
				/* Apply new rotation to face */
				eqp = &es_peqn[es_menu][0];

				VMOVE( work, eqp );
				MAT4X3VEC( eqp, modelchanges, work );
#endif
			}
			else if( inpara == 2 ){
				/* 2 parameters:  rot,fb were given */
				rota= es_para[0] * degtorad;
				fb  = es_para[1] * degtorad;
	
				/* calculate normal vector (length=1) from rot,fb */
				es_peqn[es_menu][0] = cos(fb) * cos(rota);
				es_peqn[es_menu][1] = cos(fb) * sin(rota);
				es_peqn[es_menu][2] = sin(fb);
			}
			else{
			  Tcl_AppendResult(interp, "Must be < rot fb | xdeg ydeg zdeg >\n",
					   (char *)NULL);
				mged_print_result( TCL_ERROR );
			  return;
			}

			/* point notation of fixed vertex */
			VMOVE( tempvec, arb->pt[fixv] );

			/* set D of planar equation to anchor at fixed vertex */
			/* es_menu == plane of interest */
			es_peqn[es_menu][3]=VDOT(eqp,tempvec);	

			/*  Clear out solid rotation */
			MAT_IDN( modelchanges );

		}  else  {
			/* Apply incremental changes */
			static vect_t tempvec;

			eqp = &es_peqn[es_menu][0];
			VMOVE( work, eqp );
			MAT4X3VEC( eqp, incr_change, work );

			/* point notation of fixed vertex */
			VMOVE( tempvec, arb->pt[fixv] );

			/* set D of planar equation to anchor at fixed vertex */
			/* es_menu == plane of interest */
			es_peqn[es_menu][3]=VDOT(eqp,tempvec);	
		}

		(void)rt_arb_calc_points( arb , es_type , es_peqn , &mged_tol );
		MAT_IDN( incr_change );

		/* no need to calc_planes again */
		replot_editing_solid();

		inpara = 0;
		return;

	case SSCALE:
		/* scale the solid uniformly about it's vertex point */
		{
			mat_t	scalemat;
			mat_t   mat, mat2;

			es_eu = (struct edgeuse *)NULL;	/* Reset es_eu */
			es_pipept = (struct wdb_pipept *)NULL; /* Reset es_pipept */
			bot_verts[0] = -1;
			bot_verts[1] = -1;
			bot_verts[2] = -1;
			if(inpara) {
				/* accumulate the scale factor */
				es_scale = es_para[0] / acc_sc_sol;
				acc_sc_sol = es_para[0];
			}

			bn_mat_scale_about_pt( scalemat, es_keypoint, es_scale );
			bn_mat_mul(mat2, scalemat, es_mat);
			bn_mat_mul(mat, es_invmat, mat2);
			transform_editing_solid(&es_int, mat, &es_int, 1);

			/* reset solid scale factor */
			es_scale = 1.0;
		}
		break;

	case STRANS:
		/* translate solid  */
		{
			vect_t	delta;
			mat_t	xlatemat;

			es_eu = (struct edgeuse *)NULL;	/* Reset es_eu */
			es_pipept = (struct wdb_pipept *)NULL; /* Reset es_pipept */
			bot_verts[0] = -1;
			bot_verts[1] = -1;
			bot_verts[2] = -1;
			if(inpara) {
				/* Need vector from current vertex/keypoint
				 * to desired new location.
				 */
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){ /* move solid so that es_keypoint is at position es_para */
			    vect_t raw_para;

			    MAT4X3PNT(raw_para, es_invmat, es_para);
			    MAT4X3PNT(work, es_invmat, es_keypoint);
			    VSUB2( delta, work, raw_para );
			    MAT_IDN( xlatemat );
			    MAT_DELTAS_VEC_NEG( xlatemat, delta );
			  }else{ /* move solid to position es_para */
			    /* move solid to position es_para */
			    MAT4X3PNT(work, es_invmat, es_keypoint);
			    VSUB2( delta, work, es_para );
			    MAT_IDN( xlatemat );
			    MAT_DELTAS_VEC_NEG( xlatemat, delta );
			  }
#else
				VSUB2( delta, es_para, es_keypoint );
				MAT_IDN( xlatemat );
				MAT_DELTAS_VEC( xlatemat, delta );
#endif
				transform_editing_solid(&es_int, xlatemat, &es_int, 1);
			}
		}
		break;
	case ECMD_VTRANS:
		/* translate a vertex */
		es_eu = (struct edgeuse *)NULL;	/* Reset es_eu */
		es_pipept = (struct wdb_pipept *)NULL; /* Reset es_pipept */
		bot_verts[0] = -1;
		bot_verts[1] = -1;
		bot_verts[2] = -1;
		if( es_mvalid )  {
			/* Mouse parameter:  new position in model space */
			VMOVE( es_para, es_mparam );
			inpara = 1;
		}
		if(inpara) {


			/* Keyboard parameter:  new position in model space.
			 * XXX for now, splines only here */
			register struct rt_nurb_internal *sip =
				(struct rt_nurb_internal *) es_int.idb_ptr;
			register struct face_g_snurb	*surf;
			register fastf_t	*fp;

			RT_NURB_CK_MAGIC(sip);
			surf = sip->srfs[spl_surfno];
			NMG_CK_SNURB(surf);
			fp = &RT_NURB_GET_CONTROL_POINT( surf, spl_ui, spl_vi );
#ifdef TRY_EDIT_NEW_WAY
			if(mged_variables->mv_context){
			  /* apply es_invmat to convert to real model space */
			  MAT4X3PNT( fp, es_invmat, es_para );
			}else{
			  VMOVE( fp, es_para );
			}
#else
			VMOVE( fp, es_para );
#endif
		}
		break;

	case ECMD_CLINE_SCALE_H:
		/*
		 * Scale height vector
		 */
		{
			struct rt_cline_internal *cli = 
				(struct rt_cline_internal *)es_int.idb_ptr;

			RT_CLINE_CK_MAGIC( cli );

			if( inpara )
			{
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(cli->h);
				VSCALE(cli->h, cli->h, es_scale);
			}
			else if( es_scale > 0.0 )
			{
				VSCALE(cli->h, cli->h, es_scale);
				es_scale = 0.0;
			}
		}
		break;

	case ECMD_CLINE_SCALE_R:
		/*
		 * Scale radius
		 */
		{
			struct rt_cline_internal *cli = 
				(struct rt_cline_internal *)es_int.idb_ptr;

			RT_CLINE_CK_MAGIC( cli );

			if( inpara )
				cli->radius = es_para[0];
			else if( es_scale > 0.0 )
			{
				cli->radius *= es_scale;
				es_scale = 0.0;
			}
		}
		break;

	case ECMD_CLINE_SCALE_T:
		/*
		 * Scale plate thickness
		 */
		{
			struct rt_cline_internal *cli = 
				(struct rt_cline_internal *)es_int.idb_ptr;

			RT_CLINE_CK_MAGIC( cli );

			if( inpara )
				cli->thickness = es_para[0];
			else if( es_scale > 0.0 )
			{
				cli->thickness *= es_scale;
				es_scale = 0.0;
			}
		}
		break;

	case ECMD_CLINE_MOVE_H:
		/*
		 * Move end of height vector
		 */
		{
			struct rt_cline_internal *cli = 
				(struct rt_cline_internal *)es_int.idb_ptr;

			RT_CLINE_CK_MAGIC( cli );

			if( inpara )
			{
#ifdef TRY_EDIT_NEW_WAY
				if( mged_variables->mv_context )
				{
					MAT4X3PNT( work, es_invmat, es_para );
					VSUB2( cli->h, work, cli->v );
				}
				else
					VSUB2( cli->h, es_para, cli->v )
#else
				MAT4X3PNT( work, es_invmat, es_para );
				VSUB2( cli->h, work, cli->v );
#endif
			}
			/* check for zero H vector */
			if( MAGNITUDE( cli->h ) <= SQRT_SMALL_FASTF ) {
			  Tcl_AppendResult(interp, "Zero H vector not allowed, resetting to +Z\n",
					   (char *)NULL);
				mged_print_result( TCL_ERROR );
			  VSET(cli->h, 0.0, 0.0, 1.0 );
			  break;
			}
		}
		break;

	case ECMD_TGC_MV_H:
		/*
		 * Move end of H of tgc, keeping plates perpendicular
		 * to H vector.
		 */
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;

			RT_TGC_CK_MAGIC(tgc);
			if( inpara ) {
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model coordinates */
			    MAT4X3PNT( work, es_invmat, es_para );
			    VSUB2(tgc->h, work, tgc->v);
			  }else{
			    VSUB2(tgc->h, es_para, tgc->v);
			  }
#else
				/* apply es_invmat to convert to real model coordinates */
				MAT4X3PNT( work, es_invmat, es_para );
				VSUB2(tgc->h, work, tgc->v);
#endif
			}

			/* check for zero H vector */
			if( MAGNITUDE( tgc->h ) <= SQRT_SMALL_FASTF ) {
			  Tcl_AppendResult(interp, "Zero H vector not allowed, resetting to +Z\n",
					   (char *)NULL);
				mged_print_result( TCL_ERROR );
			  VSET(tgc->h, 0.0, 0.0, 1.0 );
			  break;
			}

			/* have new height vector --  redefine rest of tgc */
			la = MAGNITUDE( tgc->a );
			lb = MAGNITUDE( tgc->b );
			lc = MAGNITUDE( tgc->c );
			ld = MAGNITUDE( tgc->d );

			/* find 2 perpendicular vectors normal to H for new A,B */
			bn_vec_perp( tgc->b, tgc->h );
			VCROSS(tgc->a, tgc->b, tgc->h);
			VUNITIZE(tgc->a);
			VUNITIZE(tgc->b);

			/* Create new C,D from unit length A,B, with previous len */
			VSCALE(tgc->c, tgc->a, lc);
			VSCALE(tgc->d, tgc->b, ld);

			/* Restore original vector lengths to A,B */
			VSCALE(tgc->a, tgc->a, la);
			VSCALE(tgc->b, tgc->b, lb);
		}
		break;

	case ECMD_TGC_MV_HH:
		/* Move end of H of tgc - leave ends alone */
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;

			RT_TGC_CK_MAGIC(tgc);
			if( inpara ) {
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model coordinates */
			    MAT4X3PNT( work, es_invmat, es_para );
			    VSUB2(tgc->h, work, tgc->v);
			  }else{
			    VSUB2(tgc->h, es_para, tgc->v);
			  }
#else
				/* apply es_invmat to convert to real model coordinates */
				MAT4X3PNT( work, es_invmat, es_para );
				VSUB2(tgc->h, work, tgc->v);
#endif
			}

			/* check for zero H vector */
			if( MAGNITUDE( tgc->h ) <= SQRT_SMALL_FASTF ) {
			  Tcl_AppendResult(interp, "Zero H vector not allowed, resetting to +Z\n",
					   (char *)NULL);
				mged_print_result( TCL_ERROR );
			  VSET(tgc->h, 0.0, 0.0, 1.0);
			  break;
			}
		}
		break;

	case PSCALE:
		es_eu = (struct edgeuse *)NULL;	/* Reset es_eu */
		bot_verts[0] = -1;
		bot_verts[1] = -1;
		bot_verts[2] = -1;
		pscale();
		break;

	case PTARB:	/* move an ARB point */
	case EARB:   /* edit an ARB edge */
		if( inpara ) { 
#ifdef TRY_EDIT_NEW_WAY
		  if(mged_variables->mv_context){
		    /* apply es_invmat to convert to real model space */
		    MAT4X3PNT( work, es_invmat, es_para );
		  }else{
		    VMOVE( work, es_para );
		  }
#else
			/* apply es_invmat to convert to real model space */
			MAT4X3PNT( work, es_invmat, es_para );
#endif
			editarb( work );
		}
		break;

	case SROT:
		/* rot solid about vertex */
		{
			es_eu = (struct edgeuse *)NULL;	/* Reset es_eu */
			es_pipept = (struct wdb_pipept *)NULL; /* Reset es_pipept */
			bot_verts[0] = -1;
			bot_verts[1] = -1;
			bot_verts[2] = -1;
			if(inpara) {
				static mat_t invsolr;
				/*
				 * Keyboard parameters:  absolute x,y,z rotations,
				 * in degrees.  First, cancel any existing rotations,
				 * then perform new rotation
				 */
				bn_mat_inv( invsolr, acc_rot_sol );

				/* Build completely new rotation change */
				MAT_IDN( modelchanges );
				bn_mat_angles(modelchanges,
					      es_para[0],
					      es_para[1],
					      es_para[2]);
				/* Borrow incr_change matrix here */
				bn_mat_mul( incr_change, modelchanges, invsolr );
				MAT_COPY(acc_rot_sol, modelchanges);

				/* Apply new rotation to solid */
				/*  Clear out solid rotation */
				MAT_IDN( modelchanges );
			}  else  {
				/* Apply incremental changes already in incr_change */
			}
			/* Apply changes to solid */
			/* xlate keypoint to origin, rotate, then put back. */
#ifdef TRY_EDIT_NEW_WAY
			switch(mged_variables->mv_rotate_about){
			case 'v':       /* View Center */
			  VSET(work, 0.0, 0.0, 0.0);
			  MAT4X3PNT(rot_point, view_state->vs_vop->vo_view2model, work);
			  break;
			case 'e':       /* Eye */
			  VSET(work, 0.0, 0.0, 1.0);
			  MAT4X3PNT(rot_point, view_state->vs_vop->vo_view2model, work);
			  break;
			case 'm':       /* Model Center */
			  VSETALL(rot_point, 0.0);
			  break;
			case 'k':       /* Key Point */
			default:
			  VMOVE(rot_point, es_keypoint);
			  break;
			}

			if(mged_variables->mv_context){
			  /* calculate rotations about keypoint */
			  bn_mat_xform_about_pt( edit, incr_change, rot_point );

			  /* We want our final matrix (mat) to xform the original solid
			   * to the position of this instance of the solid, perform the
			   * current edit operations, then xform back.
			   *	mat = es_invmat * edit * es_mat
			   */
			  bn_mat_mul( mat1, edit, es_mat );
			  bn_mat_mul( mat, es_invmat, mat1 );
			}else{
			  MAT4X3PNT(work, es_invmat, rot_point);
			  bn_mat_xform_about_pt( mat, incr_change, work );
			}
#else
			bn_mat_xform_about_pt( mat, incr_change, es_keypoint);
#endif
			transform_editing_solid(&es_int, mat, &es_int, 1);

			MAT_IDN( incr_change );
		}
		break;

	case ECMD_EXTR_ROT_H:
		/* rotate height vector */
		{
			struct rt_extrude_internal	*extr = 
				(struct rt_extrude_internal *)es_int.idb_ptr;

			RT_EXTRUDE_CK_MAGIC(extr);
#ifdef TRY_EDIT_NEW_WAY
			if(inpara) {
				static mat_t invsolr;
				/*
				 * Keyboard parameters:  absolute x,y,z rotations,
				 * in degrees.  First, cancel any existing rotations,
				 * then perform new rotation
				 */
				bn_mat_inv( invsolr, acc_rot_sol );

				/* Build completely new rotation change */
				MAT_IDN( modelchanges );
				bn_mat_angles(modelchanges,
					      es_para[0],
					      es_para[1],
					      es_para[2]);
				/* Borrow incr_change matrix here */
				bn_mat_mul( incr_change, modelchanges, invsolr );
				MAT_COPY(acc_rot_sol, modelchanges);

				/* Apply new rotation to solid */
				/*  Clear out solid rotation */
				MAT_IDN( modelchanges );
			}  else  {
				/* Apply incremental changes already in incr_change */
			}

			if(mged_variables->mv_context){
			  /* calculate rotations about keypoint */
			  bn_mat_xform_about_pt( edit, incr_change, es_keypoint );

			  /* We want our final matrix (mat) to xform the original solid
			   * to the position of this instance of the solid, perform the
			   * current edit operations, then xform back.
			   *	mat = es_invmat * edit * es_mat
			   */
			  bn_mat_mul( mat1, edit, es_mat );
			  bn_mat_mul( mat, es_invmat, mat1 );
			  MAT4X3VEC(extr->h, mat, extr->h);
			}else{
			  MAT4X3VEC(extr->h, incr_change, extr->h);
			}
#else
			MAT4X3VEC(extr->h, incr_change, extr->h);
#endif

			MAT_IDN( incr_change );
		}
		break;

	case ECMD_TGC_ROT_H:
		/* rotate height vector */
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;

			RT_TGC_CK_MAGIC(tgc);
#ifdef TRY_EDIT_NEW_WAY
			if(inpara) {
				static mat_t invsolr;
				/*
				 * Keyboard parameters:  absolute x,y,z rotations,
				 * in degrees.  First, cancel any existing rotations,
				 * then perform new rotation
				 */
				bn_mat_inv( invsolr, acc_rot_sol );

				/* Build completely new rotation change */
				MAT_IDN( modelchanges );
				bn_mat_angles(modelchanges,
					      es_para[0],
					      es_para[1],
					      es_para[2]);
				/* Borrow incr_change matrix here */
				bn_mat_mul( incr_change, modelchanges, invsolr );
				MAT_COPY(acc_rot_sol, modelchanges);

				/* Apply new rotation to solid */
				/*  Clear out solid rotation */
				MAT_IDN( modelchanges );
			}  else  {
				/* Apply incremental changes already in incr_change */
			}

			if(mged_variables->mv_context){
			  /* calculate rotations about keypoint */
			  bn_mat_xform_about_pt( edit, incr_change, es_keypoint );

			  /* We want our final matrix (mat) to xform the original solid
			   * to the position of this instance of the solid, perform the
			   * current edit operations, then xform back.
			   *	mat = es_invmat * edit * es_mat
			   */
			  bn_mat_mul( mat1, edit, es_mat );
			  bn_mat_mul( mat, es_invmat, mat1 );
			  MAT4X3VEC(tgc->h, mat, tgc->h);
			}else{
			  MAT4X3VEC(tgc->h, incr_change, tgc->h);
			}
#else
			MAT4X3VEC(tgc->h, incr_change, tgc->h);
#endif

			MAT_IDN( incr_change );
		}
		break;

	case ECMD_TGC_ROT_AB:
		/* rotate surfaces AxB and CxD (tgc) */
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;

			RT_TGC_CK_MAGIC(tgc);
#ifdef TRY_EDIT_NEW_WAY
			if(inpara) {
				static mat_t invsolr;
				/*
				 * Keyboard parameters:  absolute x,y,z rotations,
				 * in degrees.  First, cancel any existing rotations,
				 * then perform new rotation
				 */
				bn_mat_inv( invsolr, acc_rot_sol );

				/* Build completely new rotation change */
				MAT_IDN( modelchanges );
				bn_mat_angles(modelchanges,
					      es_para[0],
					      es_para[1],
					      es_para[2]);
				/* Borrow incr_change matrix here */
				bn_mat_mul( incr_change, modelchanges, invsolr );
				MAT_COPY(acc_rot_sol, modelchanges);

				/* Apply new rotation to solid */
				/*  Clear out solid rotation */
				MAT_IDN( modelchanges );
			}  else  {
				/* Apply incremental changes already in incr_change */
			}

			if(mged_variables->mv_context){
			  /* calculate rotations about keypoint */
			  bn_mat_xform_about_pt( edit, incr_change, es_keypoint );

			  /* We want our final matrix (mat) to xform the original solid
			   * to the position of this instance of the solid, perform the
			   * current edit operations, then xform back.
			   *	mat = es_invmat * edit * es_mat
			   */
			  bn_mat_mul( mat1, edit, es_mat );
			  bn_mat_mul( mat, es_invmat, mat1 );
			  MAT4X3VEC(tgc->a, mat, tgc->a);
			  MAT4X3VEC(tgc->b, mat, tgc->b);
			  MAT4X3VEC(tgc->c, mat, tgc->c);
			  MAT4X3VEC(tgc->d, mat, tgc->d);
			}else{
			  MAT4X3VEC(tgc->a, incr_change, tgc->a);
			  MAT4X3VEC(tgc->b, incr_change, tgc->b);
			  MAT4X3VEC(tgc->c, incr_change, tgc->c);
			  MAT4X3VEC(tgc->d, incr_change, tgc->d);
			}
#else
			MAT4X3VEC(work, incr_change, tgc->a);
			VMOVE(tgc->a, work);
			MAT4X3VEC(work, incr_change, tgc->b);
			VMOVE(tgc->b, work);
			MAT4X3VEC(work, incr_change, tgc->c);
			VMOVE(tgc->c, work);
			MAT4X3VEC(work, incr_change, tgc->d);
			VMOVE(tgc->d, work);
#endif
			MAT_IDN( incr_change );
		}
		break;

	case ECMD_ETO_ROT_C:
		/* rotate ellipse semi-major axis vector */
		{
			struct rt_eto_internal	*eto = 
				(struct rt_eto_internal *)es_int.idb_ptr;

			RT_ETO_CK_MAGIC(eto);
#ifdef TRY_EDIT_NEW_WAY
			if(inpara) {
				static mat_t invsolr;
				/*
				 * Keyboard parameters:  absolute x,y,z rotations,
				 * in degrees.  First, cancel any existing rotations,
				 * then perform new rotation
				 */
				bn_mat_inv( invsolr, acc_rot_sol );

				/* Build completely new rotation change */
				MAT_IDN( modelchanges );
				bn_mat_angles(modelchanges,
					      es_para[0],
					      es_para[1],
					      es_para[2]);
				/* Borrow incr_change matrix here */
				bn_mat_mul( incr_change, modelchanges, invsolr );
				MAT_COPY(acc_rot_sol, modelchanges);

				/* Apply new rotation to solid */
				/*  Clear out solid rotation */
				MAT_IDN( modelchanges );
			}  else  {
				/* Apply incremental changes already in incr_change */
			}

			if(mged_variables->mv_context){
			  /* calculate rotations about keypoint */
			  bn_mat_xform_about_pt( edit, incr_change, es_keypoint );

			  /* We want our final matrix (mat) to xform the original solid
			   * to the position of this instance of the solid, perform the
			   * current edit operations, then xform back.
			   *	mat = es_invmat * edit * es_mat
			   */
			  bn_mat_mul( mat1, edit, es_mat );
			  bn_mat_mul( mat, es_invmat, mat1 );
			  
			  MAT4X3VEC(eto->eto_C, mat, eto->eto_C);
			}else{
			  MAT4X3VEC(eto->eto_C, incr_change, eto->eto_C);
			}
#else
			MAT4X3VEC(work, incr_change, eto->eto_C);
			VMOVE(eto->eto_C, work);
#endif
		}
		MAT_IDN( incr_change );
		break;

	case ECMD_NMG_EPICK:
		/* XXX Nothing to do here (yet), all done in mouse routine. */
		break;
	case ECMD_NMG_EMOVE:
		{
			point_t new_pt;

			if( !es_eu )
			{
			  Tcl_AppendResult(interp, "No edge selected!\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			NMG_CK_EDGEUSE( es_eu );

			if( es_mvalid )
				VMOVE( new_pt , es_mparam )
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( new_pt, es_invmat, es_para);
			  }else{
			    VMOVE( new_pt, es_para );
			  }
#else
				VMOVE( new_pt , es_para );
#endif
			}else if( inpara && inpara != 3 )
			{
			  Tcl_AppendResult(interp, "x y z coordinates required for edge move\n",
					   (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			else if( !es_mvalid && !inpara )
				break;

			if( !nmg_find_fu_of_eu( es_eu ) && *es_eu->up.magic_p == NMG_LOOPUSE_MAGIC )
			{
				struct loopuse *lu;
				fastf_t area;
				plane_t pl;

				/* this edge is in a wire loop
				 * keep the loop planar
				 */
				lu = es_eu->up.lu_p;
				NMG_CK_LOOPUSE( lu );
				
				/* get plane equation for loop */
				area = nmg_loop_plane_area( lu , pl );
				if( area > 0.0 )
				{
					vect_t view_z_dir;
					vect_t view_dir;
					fastf_t dist;

					/* Get view direction vector */
					VSET( view_z_dir, 0.0, 0.0, 1.0 );
					MAT4X3VEC(view_dir , view_state->vs_vop->vo_view2model , view_z_dir);

					/* intersect line through new_pt with plane of loop */
					if( bn_isect_line3_plane( &dist , new_pt , view_dir , pl , &mged_tol ) < 1)
					{
					  /* line does not intersect plane, don't do an esplit */
					  Tcl_AppendResult(interp, "Edge Move: Cannot place new point in plane of loop\n", (char *)NULL);
					  mged_print_result( TCL_ERROR );
						break;
					}
					VJOIN1( new_pt , new_pt , dist , view_dir );
				}
			}

			if( nmg_move_edge_thru_pt( es_eu, new_pt, &mged_tol ) < 0 ) {
				VPRINT("Unable to hit", new_pt);
			}
		}
		break;

	case ECMD_NMG_EKILL:
		{
			struct model *m;
			struct edge_g_lseg *eg;

			if( !es_eu )
			{
			  Tcl_AppendResult(interp, "No edge selected!\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			NMG_CK_EDGEUSE( es_eu );

			m = nmg_find_model( &es_eu->l.magic );

			if( *es_eu->up.magic_p == NMG_LOOPUSE_MAGIC )
			{
				struct loopuse *lu;
				struct edgeuse *prev_eu,*next_eu;

				lu = es_eu->up.lu_p;
				NMG_CK_LOOPUSE( lu );

				if( *lu->up.magic_p != NMG_SHELL_MAGIC )
				{
				  /* Currently can only kill wire edges or edges in wire loops */
				  Tcl_AppendResult(interp, "Currently, we can only kill wire edges or edges in wire loops\n", (char *)NULL);
				  mged_print_result( TCL_ERROR );
				  es_edflag = IDLE;
				  break;
				}

				prev_eu = BU_LIST_PPREV_CIRC( edgeuse , &es_eu->l );
				NMG_CK_EDGEUSE( prev_eu );

				if( prev_eu == es_eu )
				{
					/* only one edge left in the loop
					 * make it an edge to/from same vertex
					 */
					if( es_eu->vu_p->v_p == es_eu->eumate_p->vu_p->v_p )
					{
					  /* refuse to delete last edge that runs
					   * to/from same vertex
					   */
					  Tcl_AppendResult(interp, "Cannot delete last edge running to/from same vertex\n", (char *)NULL);
						mged_print_result( TCL_ERROR );
						break;
					}
					NMG_CK_EDGEUSE( es_eu->eumate_p );
					nmg_movevu( es_eu->eumate_p->vu_p , es_eu->vu_p->v_p );
					break;
				}

				next_eu = BU_LIST_PNEXT_CIRC( edgeuse , &es_eu->l );
				NMG_CK_EDGEUSE( next_eu );

				nmg_movevu( next_eu->vu_p , es_eu->vu_p->v_p );
				if( nmg_keu( es_eu ) )
				{
					/* Should never happen!!! */
					bu_bomb( "sedit(): killed edge and emptied loop!!\n" );
				}
				es_eu = prev_eu;
				nmg_rebound( m , &mged_tol );

				/* fix edge geometry for modified edge (next_eu ) */
				eg = next_eu->g.lseg_p;
				NMG_CK_EDGE_G_LSEG( eg );
				VMOVE( eg->e_pt , next_eu->vu_p->v_p->vg_p->coord );
				VSUB2( eg->e_dir, next_eu->eumate_p->vu_p->v_p->vg_p->coord, next_eu->vu_p->v_p->vg_p->coord );

				break;
			}
			else if( *es_eu->up.magic_p == NMG_SHELL_MAGIC )
			{
				/* wire edge, just kill it */
				(void)nmg_keu( es_eu );
				es_eu = (struct edgeuse *)NULL;
				nmg_rebound( m , &mged_tol );
			}
		}

	case ECMD_NMG_ESPLIT:
		{
			struct vertex *v=(struct vertex *)NULL;
			struct edge_g_lseg *eg;
			struct model *m;
			point_t new_pt;
			fastf_t area;
			plane_t pl;

			if( !es_eu )
			{
			  Tcl_AppendResult(interp, "No edge selected!\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			NMG_CK_EDGEUSE( es_eu );
			m = nmg_find_model( &es_eu->l.magic );
			NMG_CK_MODEL( m );
			if( es_mvalid )
				VMOVE( new_pt , es_mparam )
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( new_pt, es_invmat, es_para);
			  }else{
			    VMOVE( new_pt , es_para );
			  }
#else
			  VMOVE( new_pt , es_para );
#endif
			}else if( inpara && inpara != 3 )
			{
			  Tcl_AppendResult(interp, "x y z coordinates required for edge split\n",
					   (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			else if( !es_mvalid && !inpara )
				break;

			if( *es_eu->up.magic_p == NMG_LOOPUSE_MAGIC )
			{
				struct loopuse *lu;

				lu = es_eu->up.lu_p;
				NMG_CK_LOOPUSE( lu );

				/* Currently, can only split wire edges or edges in wire loops */
				if( *lu->up.magic_p != NMG_SHELL_MAGIC )
				{
				  Tcl_AppendResult(interp, "Currently, we can only split wire edges or edges in wire loops\n", (char *)NULL);
					es_edflag = IDLE;
					mged_print_result( TCL_ERROR );
					break;
				}

				/* get plane equation for loop */
				area = nmg_loop_plane_area( lu , pl );
				if( area > 0.0 )
				{
					vect_t view_z_dir;
					vect_t view_dir;
					fastf_t dist;

					/* Get view direction vector */
					VSET( view_z_dir, 0.0, 0.0, 1.0 );
					MAT4X3VEC(view_dir, view_state->vs_vop->vo_view2model, view_z_dir);

					/* intersect line through new_pt with plane of loop */
					if( bn_isect_line3_plane( &dist , new_pt , view_dir , pl , &mged_tol ) < 1)
					{
					  /* line does not intersect plane, don't do an esplit */
					  Tcl_AppendResult(interp, "Edge Split: Cannot place new point in plane of loop\n", (char *)NULL);
						mged_print_result( TCL_ERROR );
						break;
					}
					VJOIN1( new_pt , new_pt , dist , view_dir );
				}
			}
			es_eu = nmg_esplit( v , es_eu , 0 );
			nmg_vertex_gv( es_eu->vu_p->v_p , new_pt );
			nmg_rebound( m , &mged_tol );
			eg = es_eu->g.lseg_p;
			NMG_CK_EDGE_G_LSEG( eg );
			VMOVE( eg->e_pt , new_pt );
			VSUB2( eg->e_dir , es_eu->eumate_p->vu_p->v_p->vg_p->coord , new_pt );
		}
		break;
	case ECMD_NMG_LEXTRU:
		{
			fastf_t dist;
			point_t to_pt;
			vect_t extrude_vec;
			struct loopuse *new_lu;
			struct faceuse *fu;
			struct model *m;
			plane_t new_lu_pl;
			fastf_t area;

			if( es_mvalid )
				VMOVE( to_pt , es_mparam )
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( to_pt, es_invmat, es_para);
			  }else{
			    VMOVE( to_pt , es_para );
			  }
#else
				VMOVE( to_pt , es_para )
#endif
			}
			else if( inpara == 1 )
				VJOIN1( to_pt, lu_keypoint, es_para[0], lu_pl )
			else if( inpara && inpara != 3 )
			{
			  Tcl_AppendResult(interp, "x y z coordinates required for loop extrusion\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			else if( !es_mvalid && !inpara )
				break;

			VSUB2( extrude_vec , to_pt , lu_keypoint );

			if( bn_isect_line3_plane( &dist , to_pt , extrude_vec , lu_pl , &mged_tol ) < 1 )
			{
			  Tcl_AppendResult(interp, "Cannot extrude parallel to plane of loop\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  return;
			}

			if( BU_LIST_NON_EMPTY( &es_s->fu_hd ) )
			{
				struct nmgregion *r;

				r = es_s->r_p;
				(void) nmg_ks( es_s );
				es_s = nmg_msv( r );
			}

			new_lu = nmg_dup_loop( lu_copy , &es_s->l.magic , (long **)0 );
			area = nmg_loop_plane_area( new_lu , new_lu_pl );
			if( area < 0.0 )
			{
			  Tcl_AppendResult(interp, "loop to be extruded as no area!!!\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  return;
			}

			if( VDOT( extrude_vec , new_lu_pl ) > 0.0 )
			{
				plane_t tmp_pl;

				fu = nmg_mf( new_lu->lumate_p );
				NMG_CK_FACEUSE( fu );
				HREVERSE( tmp_pl , new_lu_pl );
				nmg_face_g( fu , tmp_pl );
			}
			else
			{
				fu = nmg_mf( new_lu );
				NMG_CK_FACEUSE( fu );
				nmg_face_g( fu , new_lu_pl );
			}

			(void)nmg_extrude_face( fu , extrude_vec , &mged_tol );

			nmg_fix_normals( fu->s_p , &mged_tol );

			m = nmg_find_model( &fu->l.magic );
			nmg_rebound( m , &mged_tol );
			(void)nmg_ck_geometry( m , &mged_tol );

			es_eu = (struct edgeuse *)NULL;

			replot_editing_solid();
			view_state->vs_flag = 1;
		}
		break;
	case ECMD_PIPE_PICK:
		{
			struct rt_pipe_internal *pipe=
				(struct rt_pipe_internal *)es_int.idb_ptr;
			point_t new_pt;

			RT_PIPE_CK_MAGIC( pipe );

			if( es_mvalid )
			  VMOVE( new_pt , es_mparam )
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( new_pt, es_invmat, es_para);
			  }else{
			    VMOVE( new_pt , es_para );
			  }
#else
			  VMOVE( new_pt , es_para )
#endif
			}
			else if( inpara && inpara != 3 )
			{
			  Tcl_AppendResult(interp, "x y z coordinates required for segment selection\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			else if( !es_mvalid && !inpara )
				break;

			es_pipept = find_pipept_nearest_pt( &pipe->pipe_segs_head, new_pt );
			if( !es_pipept )
			{
			  Tcl_AppendResult(interp, "No PIPE segment selected\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			}
			else
				rt_pipept_print( es_pipept, base2local );
		}
		break;
	case ECMD_PIPE_SPLIT:
		{
			struct rt_pipe_internal *pipe=
				(struct rt_pipe_internal *)es_int.idb_ptr;
			point_t new_pt;

			RT_PIPE_CK_MAGIC( pipe );

			if( es_mvalid )
			  VMOVE( new_pt , es_mparam )
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( new_pt, es_invmat, es_para);
			  }else{
			    VMOVE( new_pt , es_para );
			  }
#else
				VMOVE( new_pt , es_para )
#endif
			}
			else if( inpara && inpara != 3 )
			{
			  Tcl_AppendResult(interp, "x y z coordinates required for segment split\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			else if( !es_mvalid && !inpara )
				break;

			if( !es_pipept )
			{
			  Tcl_AppendResult(interp, "No pipe segment selected\n", (char *)NULL);
				mged_print_result( TCL_ERROR );
				break;
			}

			split_pipept( &pipe->pipe_segs_head, es_pipept, new_pt );
		}
		break;
	case ECMD_PIPE_PT_MOVE:
		{
			struct rt_pipe_internal *pipe=
				(struct rt_pipe_internal *)es_int.idb_ptr;
			point_t new_pt;

			RT_PIPE_CK_MAGIC( pipe );

			if( es_mvalid )
				VMOVE( new_pt , es_mparam )
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( new_pt, es_invmat, es_para);
			  }else{
			    VMOVE( new_pt , es_para );
			  }
#else
				VMOVE( new_pt , es_para )
#endif
			}
			else if( inpara && inpara != 3 )
			{
			  Tcl_AppendResult(interp, "x y z coordinates required for segment movement\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			else if( !es_mvalid && !inpara )
				break;

			if( !es_pipept )
			{
			  Tcl_AppendResult(interp, "No pipe segment selected\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}

			move_pipept( pipe, es_pipept, new_pt );
		}
		break;
	case ECMD_PIPE_PT_ADD:
		{
			struct rt_pipe_internal *pipe=
				(struct rt_pipe_internal *)es_int.idb_ptr;
			point_t new_pt;

			RT_PIPE_CK_MAGIC( pipe );

			if( es_mvalid )
				VMOVE( new_pt , es_mparam )
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( new_pt, es_invmat, es_para);
			  }else{
			    VMOVE( new_pt , es_para );
			  }
#else
				VMOVE( new_pt , es_para )
#endif
			}
			else if( inpara && inpara != 3 )
			{
			  Tcl_AppendResult(interp, "x y z coordinates required for 'append segment'\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			else if( !es_mvalid && !inpara )
				break;

			es_pipept = add_pipept( pipe, es_pipept, new_pt );
		}
		break;
	case ECMD_PIPE_PT_INS:
		{
			struct rt_pipe_internal *pipe=
				(struct rt_pipe_internal *)es_int.idb_ptr;
			point_t new_pt;

			RT_PIPE_CK_MAGIC( pipe );

			if( es_mvalid )
				VMOVE( new_pt , es_mparam )
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( new_pt, es_invmat, es_para);
			  }else{
			    VMOVE( new_pt , es_para );
			  }
#else
				VMOVE( new_pt , es_para )
#endif
			}
			else if( inpara && inpara != 3 )
			{
			  Tcl_AppendResult(interp, "x y z coordinates required for 'prepend segment'\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			else if( !es_mvalid && !inpara )
				break;

			ins_pipept( pipe, es_pipept, new_pt );
		}
		break;
	case ECMD_PIPE_PT_DEL:
		{
			if( !es_pipept )
			{
			  Tcl_AppendResult(interp, "No pipe segment selected\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			es_pipept = del_pipept( es_pipept );
		}
		break;
	case ECMD_ARS_PICK_MENU:
		/* put up point pick menu for ARS solid */
		menu_state->ms_flag = 0;
		es_edflag = ECMD_ARS_PICK;
		mmenu_set( MENU_L1, ars_pick_menu );
		break;
	case ECMD_ARS_EDIT_MENU:
		/* put up main ARS edit menu */
		menu_state->ms_flag = 0;
		es_edflag = IDLE;
		mmenu_set( MENU_L1, ars_menu );
		break;
	case ECMD_ARS_PICK:
		{
			struct rt_ars_internal *ars=
				(struct rt_ars_internal *)es_int.idb_ptr;
			point_t pick_pt;
			vect_t view_dir;
			vect_t z_dir;
			struct bu_vls tmp_vls;
			point_t selected_pt;

			RT_ARS_CK_MAGIC( ars );

			if( es_mvalid )
				VMOVE( pick_pt, es_mparam )
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( pick_pt, es_invmat, es_para);
			  }else{
			    VMOVE( pick_pt, es_para );
			  }
#else
				VMOVE( pick_pt, es_para )
#endif
			}
			else if( inpara && inpara != 3 )
			{
				Tcl_AppendResult(interp, "x y z coordinates required for 'pick point'\n", (char *)NULL);
				mged_print_result( TCL_ERROR );
				break;
			}
			else if( !es_mvalid && !inpara )
				break;

			/* Get view direction vector */
			VSET( z_dir, 0.0, 0.0, 1.0 );
			MAT4X3VEC(view_dir , view_state->vs_vop->vo_view2model , z_dir);
			find_nearest_ars_pt( &es_ars_crv, &es_ars_col, ars, pick_pt, view_dir );
			VMOVE( es_pt, &ars->curves[es_ars_crv][es_ars_col*3] );
			VSCALE( selected_pt, es_pt, base2local );
			bu_log( "Selected point #%d from curve #%d (%f %f %f)\n",
				 es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
			bu_vls_init( &tmp_vls );
			bu_vls_printf( &tmp_vls, "Selected point #%d from curve #%d ( %f %f %f )\n", es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
			Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL );
			mged_print_result( TCL_ERROR );
			bu_vls_free( &tmp_vls );
		}
		break;
	case ECMD_ARS_NEXT_PT:
		{
			struct rt_ars_internal *ars=
				(struct rt_ars_internal *)es_int.idb_ptr;
			struct bu_vls tmp_vls;
			point_t selected_pt;

			RT_ARS_CK_MAGIC( ars );

			if( es_ars_crv >= 0 && es_ars_col >= 0 )
			{
				es_ars_col++;
				if( es_ars_col >= ars->pts_per_curve )
					es_ars_col = 0;
				VMOVE( es_pt, &ars->curves[es_ars_crv][es_ars_col*3] );
				VSCALE( selected_pt, es_pt, base2local );
				bu_log( "Selected point #%d from curve #%d (%f %f %f)\n",
					 es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
				bu_vls_init( &tmp_vls );
				bu_vls_printf( &tmp_vls, "Selected point #%d from curve #%d ( %f %f %f )\n", es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
				Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL );
				mged_print_result( TCL_ERROR );
				bu_vls_free( &tmp_vls );
			}
		}
		break;
	case ECMD_ARS_PREV_PT:
		{
			struct rt_ars_internal *ars=
				(struct rt_ars_internal *)es_int.idb_ptr;
			struct bu_vls tmp_vls;
			point_t selected_pt;

			RT_ARS_CK_MAGIC( ars );

			if( es_ars_crv >= 0 && es_ars_col >= 0 )
			{
				es_ars_col--;
				if( es_ars_col < 0 )
					es_ars_col = ars->pts_per_curve - 1;
				VMOVE( es_pt, &ars->curves[es_ars_crv][es_ars_col*3] );
				VSCALE( selected_pt, es_pt, base2local );
				bu_log( "Selected point #%d from curve #%d (%f %f %f)\n",
					 es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
				bu_vls_init( &tmp_vls );
				bu_vls_printf( &tmp_vls, "Selected point #%d from curve #%d ( %f %f %f )\n", es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
				Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL );
				mged_print_result( TCL_ERROR );
				bu_vls_free( &tmp_vls );
			}
		}
		break;
	case ECMD_ARS_NEXT_CRV:
		{
			struct rt_ars_internal *ars=
				(struct rt_ars_internal *)es_int.idb_ptr;
			struct bu_vls tmp_vls;
			point_t selected_pt;

			RT_ARS_CK_MAGIC( ars );

			if( es_ars_crv >= 0 && es_ars_col >= 0 )
			{
				es_ars_crv++;
				if(es_ars_crv >= ars->ncurves )
					es_ars_crv = 0;
				VMOVE( es_pt, &ars->curves[es_ars_crv][es_ars_col*3] );
				VSCALE( selected_pt, es_pt, base2local );
				bu_log( "Selected point #%d from curve #%d (%f %f %f)\n",
					 es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
				bu_vls_init( &tmp_vls );
				bu_vls_printf( &tmp_vls, "Selected point #%d from curve #%d ( %f %f %f )\n", es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
				Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL );
				mged_print_result( TCL_ERROR );
				bu_vls_free( &tmp_vls );
			}
		}
		break;
	case ECMD_ARS_PREV_CRV:
		{
			struct rt_ars_internal *ars=
				(struct rt_ars_internal *)es_int.idb_ptr;
			struct bu_vls tmp_vls;
			point_t selected_pt;

			RT_ARS_CK_MAGIC( ars );

			if( es_ars_crv >= 0 && es_ars_col >= 0 )
			{
				es_ars_crv--;
				if( es_ars_crv < 0 )
					es_ars_crv = ars->ncurves - 1;
				VMOVE( es_pt, &ars->curves[es_ars_crv][es_ars_col*3] );
				VSCALE( selected_pt, es_pt, base2local );
				bu_log( "Selected point #%d from curve #%d (%f %f %f)\n",
					 es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
				bu_vls_init( &tmp_vls );
				bu_vls_printf( &tmp_vls, "Selected point #%d from curve #%d ( %f %f %f )\n", es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
				Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL );
				mged_print_result( TCL_ERROR );
				bu_vls_free( &tmp_vls );
			}
		}
		break;
	case ECMD_ARS_DUP_CRV:
		{
			struct rt_ars_internal *ars=
				(struct rt_ars_internal *)es_int.idb_ptr;
			fastf_t **curves;

			RT_ARS_CK_MAGIC( ars );

			if( es_ars_crv < 0 || es_ars_col < 0 )
			{
				bu_log( "No ARS point selected\n" );
				break;
			}

			curves = (fastf_t **)bu_malloc( (ars->ncurves+1) * sizeof( fastf_t * ),
					"new curves" );

			for( i=0 ; i<ars->ncurves+1 ; i++ )
			{
				int j,k;

				curves[i] = (fastf_t *)bu_malloc( ars->pts_per_curve * 3 * sizeof( fastf_t ),
						"new curves[i]" );

				if( i <= es_ars_crv )
					k = i;
				else
					k = i - 1;

				for( j=0 ; j<ars->pts_per_curve*3 ; j++ )
					curves[i][j] = ars->curves[k][j];
			}

			for( i=0 ; i<ars->ncurves ; i++ )
				bu_free( (genptr_t)ars->curves[i], "ars->curves[i]" );
			bu_free( (genptr_t)ars->curves, "ars->curves" );

			ars->curves = curves;
			ars->ncurves++;
		}
		break;
	case ECMD_ARS_DUP_COL:
		{
			struct rt_ars_internal *ars=
				(struct rt_ars_internal *)es_int.idb_ptr;
			fastf_t **curves;

			RT_ARS_CK_MAGIC( ars );

			if( es_ars_crv < 0 || es_ars_col < 0 )
			{
				bu_log( "No ARS point selected\n" );
				break;
			}

			curves = (fastf_t **)bu_malloc( ars->ncurves * sizeof( fastf_t * ),
					"new curves" );

			for( i=0 ; i<ars->ncurves ; i++ )
			{
				int j,k;

				curves[i] = (fastf_t *)bu_malloc( (ars->pts_per_curve + 1) * 3 * sizeof( fastf_t ),
						"new curves[i]" );

				for( j=0 ; j<ars->pts_per_curve+1 ; j++ )
				{
					if( j <= es_ars_col )
						k = j;
					else
						k = j - 1;

					curves[i][j*3] = ars->curves[i][k*3];
					curves[i][j*3+1] = ars->curves[i][k*3+1];
					curves[i][j*3+2] = ars->curves[i][k*3+2];
				}
			}

			for( i=0 ; i<ars->ncurves ; i++ )
				bu_free( (genptr_t)ars->curves[i], "ars->curves[i]" );
			bu_free( (genptr_t)ars->curves, "ars->curves" );

			ars->curves = curves;
			ars->pts_per_curve++;
		}
		break;
	case ECMD_ARS_DEL_CRV:
		{
			struct rt_ars_internal *ars=
				(struct rt_ars_internal *)es_int.idb_ptr;
			fastf_t **curves;
			int k;

			RT_ARS_CK_MAGIC( ars );

			if( es_ars_crv < 0 || es_ars_col < 0 )
			{
				bu_log( "No ARS point selected\n" );
				break;
			}

			if( es_ars_crv == 0 || es_ars_crv == ars->ncurves-1 )
			{
				bu_log( "Cannot delete first or last curve\n" );
				break;
			}

			curves = (fastf_t **)bu_malloc( (ars->ncurves - 1) * sizeof( fastf_t * ),
					"new curves" );

			k = 0;
			for( i=0 ; i<ars->ncurves ; i++ )
			{
				int j;

				if( i == es_ars_crv )
					continue;

				curves[k] = (fastf_t *)bu_malloc( ars->pts_per_curve * 3 * sizeof( fastf_t ),
						"new curves[k]" );

				for( j=0 ; j<ars->pts_per_curve*3 ; j++ )
					curves[k][j] = ars->curves[i][j];

				k++;
			}

			for( i=0 ; i<ars->ncurves ; i++ )
				bu_free( (genptr_t)ars->curves[i], "ars->curves[i]" );
			bu_free( (genptr_t)ars->curves, "ars->curves" );

			ars->curves = curves;
			ars->ncurves--;

			if( es_ars_crv >= ars->ncurves )
				es_ars_crv = ars->ncurves - 1;
		}
		break;
	case ECMD_ARS_DEL_COL:
		{
			struct rt_ars_internal *ars=
				(struct rt_ars_internal *)es_int.idb_ptr;
			fastf_t **curves;

			RT_ARS_CK_MAGIC( ars );

			if( es_ars_crv < 0 || es_ars_col < 0 )
			{
				bu_log( "No ARS point selected\n" );
				break;
			}

			if( es_ars_col == 0 || es_ars_col == ars->ncurves - 1 )
			{
				bu_log( "Cannot delete first or last column\n" );
				break;
			}

			if( ars->pts_per_curve < 3 )
			{
				bu_log( "Cannot create an ARS with less than two points per curve\n" );
				break;
			}

			curves = (fastf_t **)bu_malloc( ars->ncurves * sizeof( fastf_t * ),
					"new curves" );

			for( i=0 ; i<ars->ncurves ; i++ )
			{
				int j,k;


				curves[i] = (fastf_t *)bu_malloc( (ars->pts_per_curve - 1) * 3 * sizeof( fastf_t ),
						"new curves[i]" );

				k = 0;
				for( j=0 ; j<ars->pts_per_curve ; j++ )
				{
					if( j == es_ars_col )
						continue;

					curves[i][k*3] = ars->curves[i][j*3];
					curves[i][k*3+1] = ars->curves[i][j*3+1];
					curves[i][k*3+2] = ars->curves[i][j*3+2];
					k++;
				}
			}

			for( i=0 ; i<ars->ncurves ; i++ )
				bu_free( (genptr_t)ars->curves[i], "ars->curves[i]" );
			bu_free( (genptr_t)ars->curves, "ars->curves" );

			ars->curves = curves;
			ars->pts_per_curve--;

			if( es_ars_col >= ars->pts_per_curve )
				es_ars_col = ars->pts_per_curve - 1;
		}
		break;
	case ECMD_ARS_MOVE_COL:
		{
			struct rt_ars_internal *ars=
				(struct rt_ars_internal *)es_int.idb_ptr;
			point_t new_pt;
			vect_t diff;

			RT_ARS_CK_MAGIC( ars );

			if( es_ars_crv < 0 || es_ars_col < 0 )
			{
				bu_log( "No ARS point selected\n" );
				break;
			}

			if( es_mvalid )
			{
				vect_t view_dir;
				plane_t view_pl;
				fastf_t dist;

				/* construct a plane perpendiculr to view direction
				 * that passes through ARS point being moved
				 */
				VSET( view_dir, 0.0, 0.0, 1.0 );
				MAT4X3VEC(view_pl, view_state->vs_vop->vo_view2model, view_dir);
				VUNITIZE( view_pl );
				view_pl[3] = VDOT( view_pl, &ars->curves[es_ars_crv][es_ars_col*3] );

				/* project es_mparam onto the plane */
				dist = DIST_PT_PLANE( es_mparam, view_pl );
				VJOIN1( new_pt, es_mparam, -dist, view_pl );
			}
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( new_pt, es_invmat, es_para);
			  }else{
			    VMOVE( new_pt , es_para );
			  }
#else
				VMOVE( new_pt , es_para )
#endif
			}
			else if( inpara && inpara != 3 )
			{
			  Tcl_AppendResult(interp, "x y z coordinates required for point movement\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			else if( !es_mvalid && !inpara )
				break;

			VSUB2( diff, new_pt, &ars->curves[es_ars_crv][es_ars_col*3] );

			for( i=0 ; i<ars->ncurves ; i++ )
				VADD2( &ars->curves[i][es_ars_col*3],
					&ars->curves[i][es_ars_col*3], diff );

		}
		break;
	case ECMD_ARS_MOVE_CRV:
		{
			struct rt_ars_internal *ars=
				(struct rt_ars_internal *)es_int.idb_ptr;
			point_t new_pt;
			vect_t diff;

			RT_ARS_CK_MAGIC( ars );

			if( es_ars_crv < 0 || es_ars_col < 0 )
			{
				bu_log( "No ARS point selected\n" );
				break;
			}

			if( es_mvalid )
			{
				vect_t view_dir;
				plane_t view_pl;
				fastf_t dist;

				/* construct a plane perpendiculr to view direction
				 * that passes through ARS point being moved
				 */
				VSET( view_dir, 0.0, 0.0, 1.0 );
				MAT4X3VEC(view_pl, view_state->vs_vop->vo_view2model, view_dir);
				VUNITIZE( view_pl );
				view_pl[3] = VDOT( view_pl, &ars->curves[es_ars_crv][es_ars_col*3] );

				/* project es_mparam onto the plane */
				dist = DIST_PT_PLANE( es_mparam, view_pl );
				VJOIN1( new_pt, es_mparam, -dist, view_pl );
			}
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( new_pt, es_invmat, es_para);
			  }else{
			    VMOVE( new_pt , es_para );
			  }
#else
				VMOVE( new_pt , es_para )
#endif
			}
			else if( inpara && inpara != 3 )
			{
			  Tcl_AppendResult(interp, "x y z coordinates required for point movement\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			else if( !es_mvalid && !inpara )
				break;

			VSUB2( diff, new_pt, &ars->curves[es_ars_crv][es_ars_col*3] );

			for( i=0 ; i<ars->pts_per_curve ; i++ )
				VADD2( &ars->curves[es_ars_crv][i*3],
					&ars->curves[es_ars_crv][i*3], diff );

		}
		break;
	case ECMD_ARS_MOVE_PT:
		{
			struct rt_ars_internal *ars=
				(struct rt_ars_internal *)es_int.idb_ptr;
			point_t new_pt;

			RT_ARS_CK_MAGIC( ars );

			if( es_ars_crv < 0 || es_ars_col < 0 )
			{
				bu_log( "No ARS point selected\n" );
				break;
			}

			if( es_mvalid )
			{
				vect_t view_dir;
				plane_t view_pl;
				fastf_t dist;

				/* construct a plane perpendiculr to view direction
				 * that passes through ARS point being moved
				 */
				VSET( view_dir, 0.0, 0.0, 1.0 );
				MAT4X3VEC(view_pl, view_state->vs_vop->vo_view2model, view_dir);
				VUNITIZE( view_pl );
				view_pl[3] = VDOT( view_pl, &ars->curves[es_ars_crv][es_ars_col*3] );

				/* project es_mparam onto the plane */
				dist = DIST_PT_PLANE( es_mparam, view_pl );
				VJOIN1( new_pt, es_mparam, -dist, view_pl );
			}
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( new_pt, es_invmat, es_para);
			  }else{
			    VMOVE( new_pt , es_para );
			  }
#else
				VMOVE( new_pt , es_para )
#endif
			}
			else if( inpara && inpara != 3 )
			{
			  Tcl_AppendResult(interp, "x y z coordinates required for point movement\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			else if( !es_mvalid && !inpara )
				break;

			VMOVE( &ars->curves[es_ars_crv][es_ars_col*3] , new_pt );
		}
		break;
	case ECMD_BOT_MOVEV:
		{
			struct rt_bot_internal *bot = (struct rt_bot_internal *)es_int.idb_ptr;
			int vert;
			point_t new_pt;

			RT_BOT_CK_MAGIC( bot );

			if( bot_verts[0] < 0 )
			{
				bu_log( "No BOT point selected\n" );
				break;
			}

			if( bot_verts[1] >= 0 && bot_verts[2] >= 0 )
			{
				bu_log( "A triangle is selected, not a BOT point!!!\n" );
				break;
			}

			if( bot_verts[1] >= 0 )
			{
				bu_log( "An edge is selected, not a BOT point!!!\n" );
				break;
			}

			vert = bot_verts[0];
			if( es_mvalid )
				VMOVE( new_pt , es_mparam )
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( new_pt, es_invmat, es_para);
			  }else{
			    VMOVE( new_pt , es_para );
			  }
#else
				VMOVE( new_pt , es_para )
#endif
			}
			else if( inpara && inpara != 3 )
			{
			  Tcl_AppendResult(interp, "x y z coordinates required for point movement\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			else if( !es_mvalid && !inpara )
				break;

			VMOVE( &bot->vertices[vert*3] , new_pt );
		}
		break;
	case ECMD_BOT_MOVEE:
		{
			struct rt_bot_internal *bot = (struct rt_bot_internal *)es_int.idb_ptr;
			int v1, v2;
			vect_t diff;
			point_t new_pt;

			RT_BOT_CK_MAGIC( bot );

			if( bot_verts[0] < 0 || bot_verts[1] < 0 )
			{
				Tcl_AppendResult( interp, "No BOT edge selected\n", (char *)NULL );
				mged_print_result( TCL_ERROR );
				break;
			}

			if( bot_verts[2] >= 0 )
			{
				bu_log( "A triangle is selected, not a BOT edge!!!\n" );
				break;
			}
			v1 = bot_verts[0];
			v2 = bot_verts[1];
			if( es_mvalid )
				VMOVE( new_pt , es_mparam )
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( new_pt, es_invmat, es_para);
			  }else{
			    VMOVE( new_pt , es_para );
			  }
#else
				VMOVE( new_pt , es_para )
#endif
			}
			else if( inpara && inpara != 3 )
			{
			  Tcl_AppendResult(interp, "x y z coordinates required for point movement\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			else if( !es_mvalid && !inpara )
				break;

			

			VSUB2( diff, new_pt, &bot->vertices[v1*3] );
			VMOVE( &bot->vertices[v1*3] , new_pt );
			VADD2( &bot->vertices[v2*3], &bot->vertices[v2*3], diff );
		}
		break;
	case ECMD_BOT_MOVET:
		{
			struct rt_bot_internal *bot = (struct rt_bot_internal *)es_int.idb_ptr;
			int v1, v2, v3;
			point_t new_pt;
			vect_t diff;

			RT_BOT_CK_MAGIC( bot );

			if( bot_verts[0] < 0 ||
				bot_verts[1] < 0 ||
				bot_verts[2] < 0 )
			{
				Tcl_AppendResult( interp, "No BOT triangle selected\n", (char *)NULL );
				mged_print_result( TCL_ERROR );
				break;
			}
			v1 = bot_verts[0];
			v2 = bot_verts[1];
			v3 = bot_verts[2];

			if( es_mvalid )
				VMOVE( new_pt , es_mparam )
			else if( inpara == 3 ){
#ifdef TRY_EDIT_NEW_WAY
			  if(mged_variables->mv_context){
			    /* apply es_invmat to convert to real model space */
			    MAT4X3PNT( new_pt, es_invmat, es_para);
			  }else{
			    VMOVE( new_pt , es_para );
			  }
#else
				VMOVE( new_pt , es_para )
#endif
			}
			else if( inpara && inpara != 3 )
			{
			  Tcl_AppendResult(interp, "x y z coordinates required for point movement\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  break;
			}
			else if( !es_mvalid && !inpara )
				break;

			VSUB2( diff, new_pt, &bot->vertices[v1*3] );
			VMOVE( &bot->vertices[v1*3] , new_pt );
			VADD2( &bot->vertices[v2*3], &bot->vertices[v2*3], diff );
			VADD2( &bot->vertices[v3*3], &bot->vertices[v3*3], diff );
		}
		break;
	case ECMD_BOT_PICKV:
	case ECMD_BOT_PICKE:
	case ECMD_BOT_PICKT:
		break;
	default:
	  {
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "sedit():  unknown edflag = %d.\n", es_edflag );
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    mged_print_result( TCL_ERROR );
	    bu_vls_free(&tmp_vls);
	  }
	}

	/* must re-calculate the face plane equations for arbs */
	if( es_int.idb_type == ID_ARB8 )
	{
		arb = (struct rt_arb_internal *)es_int.idb_ptr;
		RT_ARB_CK_MAGIC( arb );

		(void)rt_arb_calc_planes( es_peqn , arb , es_type , &mged_tol );
	}

	/* If the keypoint changed location, find about it here */
	if (!es_keyfixed)
		get_solid_keypoint( es_keypoint, &es_keytag, &es_int, es_mat );

	set_e_axes_pos(0);
	replot_editing_solid();

	if(update_views){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "active_edit_callback");
	  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	}

	inpara = 0;
	es_mvalid = 0;
}

/*
 *			S E D I T _ M O U S E
 *
 *  Mouse (pen) press in graphics area while doing Solid Edit.
 *  mousevec [X] and [Y] are in the range -1.0...+1.0, corresponding
 *  to viewspace.
 *
 *  In order to allow the "p" command to do the same things that
 *  a mouse event can, the preferred strategy is to store the value
 *  corresponding to what the "p" command would give in es_mparam,
 *  set es_mvalid=1, set sedraw=1, and return, allowing sedit()
 *  to actually do the work.
 */
void
sedit_mouse( const vect_t mousevec )
{
  vect_t pos_view;	 	/* Unrotated view space pos */
  vect_t pos_model;		/* Rotated screen space pos */
  vect_t tr_temp;		/* temp translation vector */
  vect_t temp;
  vect_t raw_kp;                /* es_keypoint with es_invmat applied */
  vect_t raw_mp;                /* raw model position */


  if( es_edflag <= 0 )
    return;

  switch( es_edflag )  {
  case SSCALE:
  case PSCALE:
  case ECMD_DSP_SCALE_X:
  case ECMD_DSP_SCALE_Y:
  case ECMD_DSP_SCALE_ALT:
  case ECMD_VOL_CSIZE:
  case ECMD_VOL_THRESH_LO:
  case ECMD_VOL_THRESH_HI:
  case ECMD_EBM_HEIGHT:
  case ECMD_EXTR_SCALE_H:
  case ECMD_CLINE_SCALE_H:
  case ECMD_CLINE_SCALE_T:
  case ECMD_CLINE_SCALE_R:
    /* use mouse to get a scale factor */
    es_scale = 1.0 + 0.25 * ((fastf_t)
			     (mousevec[Y] > 0 ? mousevec[Y] : -mousevec[Y]));
    if ( mousevec[Y] <= 0 )
      es_scale = 1.0 / es_scale;

    /* accumulate scale factor */
    acc_sc_sol *= es_scale;

    edit_absolute_scale = acc_sc_sol - 1.0;
    if(edit_absolute_scale > 0)
      edit_absolute_scale /= 3.0;

    sedit();

    return;
  case STRANS:
    /* 
     * Use mouse to change solid's location.
     * Project solid's keypoint into view space,
     * replace X,Y (but NOT Z) components, and
     * project result back to model space.
     * Then move keypoint there.
     */
    {
      point_t	pt;
      vect_t	delta;
      mat_t	xlatemat;

      MAT4X3PNT(pos_view, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
      pos_view[X] = mousevec[X];
      pos_view[Y] = mousevec[Y];
      MAT4X3PNT(pt, view_state->vs_vop->vo_view2model, pos_view);

      /* Need vector from current vertex/keypoint
       * to desired new location.
       */
      MAT4X3PNT( raw_mp, es_invmat, pt );
      MAT4X3PNT( raw_kp, es_invmat, curr_e_axes_pos );
      VSUB2( delta, raw_kp, raw_mp );
      MAT_IDN( xlatemat );
      MAT_DELTAS_VEC_NEG( xlatemat, delta );
      transform_editing_solid(&es_int, xlatemat, &es_int, 1);
    }

    break;
  case ECMD_VTRANS:
    /* 
     * Use mouse to change a vertex location.
     * Project vertex (in solid keypoint) into view space,
     * replace X,Y (but NOT Z) components, and
     * project result back to model space.
     * Leave desired location in es_mparam.
     */

    MAT4X3PNT(pos_view, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
    pos_view[X] = mousevec[X];
    pos_view[Y] = mousevec[Y];
    MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, pos_view);
    MAT4X3PNT( es_mparam, es_invmat, temp );
    es_mvalid = 1;	/* es_mparam is valid */
    /* Leave the rest to code in sedit() */

    break;
  case ECMD_TGC_MV_H:
  case ECMD_TGC_MV_HH:
    /* Use mouse to change location of point V+H */
    {
      struct rt_tgc_internal	*tgc = 
	(struct rt_tgc_internal *)es_int.idb_ptr;
      RT_TGC_CK_MAGIC(tgc);

      MAT4X3PNT(pos_view, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
      pos_view[X] = mousevec[X];
      pos_view[Y] = mousevec[Y];
      /* Do NOT change pos_view[Z] ! */
      MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, pos_view);
      MAT4X3PNT( tr_temp, es_invmat, temp );
      VSUB2( tgc->h, tr_temp, tgc->v );
    }

    break;
  case ECMD_EXTR_MOV_H:
    /* Use mouse to change location of point V+H */
    {
      struct rt_extrude_internal	*extr = 
	(struct rt_extrude_internal *)es_int.idb_ptr;
      RT_EXTRUDE_CK_MAGIC(extr);

      MAT4X3PNT(pos_view, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
      pos_view[X] = mousevec[X];
      pos_view[Y] = mousevec[Y];
      /* Do NOT change pos_view[Z] ! */
      MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, pos_view);
      MAT4X3PNT( tr_temp, es_invmat, temp );
      VSUB2( extr->h, tr_temp, extr->V );
    }

    break;
  case ECMD_CLINE_MOVE_H:
    {
    	struct rt_cline_internal *cli =
    		(struct rt_cline_internal *)es_int.idb_ptr;

    	RT_CLINE_CK_MAGIC( cli );

      MAT4X3PNT(pos_view, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
      pos_view[X] = mousevec[X];
      pos_view[Y] = mousevec[Y];
      /* Do NOT change pos_view[Z] ! */
      MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, pos_view);
      MAT4X3PNT( tr_temp, es_invmat, temp );
      VSUB2( cli->h, tr_temp, cli->v );
    }

    break;
  case PTARB:
    /* move an arb point to indicated point */
    /* point is located at es_values[es_menu*3] */
    MAT4X3PNT(pos_view, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
    pos_view[X] = mousevec[X];
    pos_view[Y] = mousevec[Y];
    MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, pos_view);
    MAT4X3PNT(pos_model, es_invmat, temp);
    editarb( pos_model );

    break;
  case EARB:
    MAT4X3PNT(pos_view, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
    pos_view[X] = mousevec[X];
    pos_view[Y] = mousevec[Y];
    MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, pos_view);
    MAT4X3PNT(pos_model, es_invmat, temp);
    editarb( pos_model );

    break;
  case ECMD_ARB_MOVE_FACE:
    MAT4X3PNT(pos_view, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
    pos_view[X] = mousevec[X];
    pos_view[Y] = mousevec[Y];
    MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, pos_view);
    MAT4X3PNT(pos_model, es_invmat, temp);
    /* change D of planar equation */
    es_peqn[es_menu][3]=VDOT(&es_peqn[es_menu][0], pos_model);
    /* calculate new vertices, put in record as vectors */
    {
      struct rt_arb_internal *arb=
	(struct rt_arb_internal *)es_int.idb_ptr;

      RT_ARB_CK_MAGIC( arb );
      (void)rt_arb_calc_points( arb , es_type , es_peqn , &mged_tol );
    }

    break;
  case ECMD_BOT_PICKV:
    {
  	struct rt_bot_internal *bot = (struct rt_bot_internal *)es_int.idb_ptr;
  	int tmp_vert;
    	char tmp_msg[256];

  	RT_BOT_CK_MAGIC( bot );

	MAT4X3PNT(pos_view, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
	pos_view[X] = mousevec[X];
	pos_view[Y] = mousevec[Y];

  	tmp_vert = rt_bot_find_v_nearest_pt2(bot, pos_view, view_state->vs_vop->vo_model2view);
  	if( tmp_vert < 0 )
  	{
  		Tcl_AppendResult(interp, "ECMD_BOT_PICKV: unable to find a vertex!!!\n", (char *)NULL );
  		mged_print_result( TCL_ERROR );
  		return;
  	}

  	bot_verts[0] = tmp_vert;
  	bot_verts[1] = -1;
  	bot_verts[2] = -1;
	sprintf( tmp_msg, "picked point at (%g %g %g), vertex #%d\n", V3ARGS( &bot->vertices[tmp_vert*3] ), tmp_vert );
    	Tcl_AppendResult(interp, tmp_msg, (char *)NULL );
	mged_print_result( TCL_OK );
    }
    break;
  case ECMD_BOT_PICKE:
    {
  	struct rt_bot_internal *bot = (struct rt_bot_internal *)es_int.idb_ptr;
    	int vert1, vert2;
    	char tmp_msg[256];

    	RT_BOT_CK_MAGIC( bot );

	MAT4X3PNT(pos_view, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
	pos_view[X] = mousevec[X];
	pos_view[Y] = mousevec[Y];

    	if (rt_bot_find_e_nearest_pt2(&vert1, &vert2, bot, pos_view, view_state->vs_vop->vo_model2view))
  	{
  		Tcl_AppendResult(interp, "ECMD_BOT_PICKE: unable to find an edge!!!\n", (char *)NULL );
  		mged_print_result( TCL_ERROR );
  		return;
  	}

  	bot_verts[0] = vert1;
  	bot_verts[1] = vert2;
  	bot_verts[2] = -1;
	sprintf( tmp_msg, "picked edge from (%g %g %g) to (%g %g %g)\n", V3ARGS( &bot->vertices[vert1*3] ), V3ARGS( &bot->vertices[vert2*3] ) );
    	Tcl_AppendResult(interp, tmp_msg, (char *)NULL );
	mged_print_result( TCL_OK );
    }
    break;
  case ECMD_BOT_PICKT:
  	{
		struct rt_bot_internal *bot = (struct rt_bot_internal *)es_int.idb_ptr;
  		point_t start_pt, tmp;
  		vect_t dir;
  		int i, hits, ret_tcl;
  		int v1, v2, v3;
  		point_t pt1, pt2, pt3;
		struct bu_vls vls;

  		RT_BOT_CK_MAGIC( bot );

		bu_vls_init( &vls );

  		VSET( tmp, mousevec[X], mousevec[Y], 0.0 );
  		MAT4X3PNT(start_pt, view_state->vs_vop->vo_view2model, tmp);
  		VSET(tmp, 0, 0, 1 );
  		MAT4X3VEC(dir, view_state->vs_vop->vo_view2model, tmp);

		bu_vls_strcat( &vls, " {" );
		hits = 0;
  		for( i=0 ; i<bot->num_faces ; i++ )
  		{
  			v1 = bot->faces[i*3];
  			v2 = bot->faces[i*3+1];
  			v3 = bot->faces[i*3+2];
  			VMOVE( pt1, &bot->vertices[v1*3] );
  			VMOVE( pt2, &bot->vertices[v2*3] );
  			VMOVE( pt3, &bot->vertices[v3*3] );

  			if( bn_does_ray_isect_tri(start_pt, dir, pt1, pt2, pt3, tmp ) )
			  {
			    hits++;
			    bu_vls_printf( &vls, " { %d %d %d }", v1, v2, v3 );
			  }
  		}
		bu_vls_strcat( &vls, " } " );

		if( hits == 0 )
  		{
	  		bot_verts[0] = -1;
	  		bot_verts[1] = -1;
	  		bot_verts[2] = -1;
			bu_vls_free( &vls );
  		}
  		if( hits == 1 )
  		{
  			(void)sscanf( bu_vls_addr( &vls ), " { { %d %d %d", &bot_verts[0], &bot_verts[1], &bot_verts[2] );
			bu_vls_free( &vls );
  		}
		else
		{
			Tcl_LinkVar( interp, "bot_v1", (char *)&bot_verts[0], TCL_LINK_INT );
			Tcl_LinkVar( interp, "bot_v2", (char *)&bot_verts[1], TCL_LINK_INT );
			Tcl_LinkVar( interp, "bot_v3", (char *)&bot_verts[2], TCL_LINK_INT );

			ret_tcl = Tcl_VarEval( interp, "bot_face_select ", bu_vls_addr( &vls ), (char *)NULL );
			bu_vls_free( &vls );
			if( ret_tcl != TCL_OK )
			{
			  bu_log( "bot_face_select failed: %s\n", interp->result );
			  bot_verts[0] = -1;
			  bot_verts[1] = -1;
			  bot_verts[2] = -1;
			  break;
			}
		}
  	}
  	break;
  case ECMD_NMG_EPICK:
    /* XXX Should just leave desired location in es_mparam for sedit() */
    {
      struct model	*m = 
	(struct model *)es_int.idb_ptr;
      struct edge	*e;
      struct bn_tol	tmp_tol;
      NMG_CK_MODEL(m);

      /* Picking an edge should not depend on tolerances! */
      tmp_tol.magic = BN_TOL_MAGIC;
      tmp_tol.dist = 0.0;
      tmp_tol.dist_sq = tmp_tol.dist * tmp_tol.dist;
      tmp_tol.perp = 0.0;
      tmp_tol.para = 1 - tmp_tol.perp;

      MAT4X3PNT(pos_view, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
      pos_view[X] = mousevec[X];
      pos_view[Y] = mousevec[Y];
      if ((e = nmg_find_e_nearest_pt2(&m->magic, pos_view,
				      view_state->vs_vop->vo_model2view, &tmp_tol)) == (struct edge *)NULL) {
	Tcl_AppendResult(interp, "ECMD_NMG_EPICK: unable to find an edge\n",
			 (char *)NULL);
	mged_print_result( TCL_ERROR );
	return;
      }
      es_eu = e->eu_p;
      NMG_CK_EDGEUSE(es_eu);

      {
	struct bu_vls tmp_vls;

	bu_vls_init(&tmp_vls);
	bu_vls_printf(&tmp_vls,
		      "edgeuse selected=x%x (%g %g %g) <-> (%g %g %g)\n",
		      es_eu, V3ARGS( es_eu->vu_p->v_p->vg_p->coord ),
		      V3ARGS( es_eu->eumate_p->vu_p->v_p->vg_p->coord ) );
	Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	mged_print_result( TCL_ERROR );
	bu_vls_free(&tmp_vls);
      }
  }

    break;
  case ECMD_NMG_LEXTRU:
  case ECMD_NMG_EMOVE:
  case ECMD_NMG_ESPLIT:
  case ECMD_PIPE_PICK:
  case ECMD_PIPE_SPLIT:
  case ECMD_PIPE_PT_MOVE:
  case ECMD_PIPE_PT_ADD:
  case ECMD_PIPE_PT_INS:
  case ECMD_ARS_PICK:
  case ECMD_ARS_MOVE_PT:
  case ECMD_ARS_MOVE_CRV:
  case ECMD_ARS_MOVE_COL:
  case ECMD_BOT_MOVEV:
  case ECMD_BOT_MOVEE:
  case ECMD_BOT_MOVET:

    MAT4X3PNT(pos_view, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
    pos_view[X] = mousevec[X];
    pos_view[Y] = mousevec[Y];
    MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, pos_view);
    MAT4X3PNT(es_mparam, es_invmat, temp);
    es_mvalid = 1;

    break;
  default:
    Tcl_AppendResult(interp, "mouse press undefined in this solid edit mode\n", (char *)NULL);
    mged_print_result( TCL_ERROR );
    return;
    }

  update_edit_absolute_tran(pos_view);
  sedit();
}

void
update_edit_absolute_tran(vect_t view_pos)
{
	vect_t model_pos;
	vect_t ea_view_pos;
	vect_t diff;
	fastf_t inv_Viewscale = 1/view_state->vs_vop->vo_scale;

	MAT4X3PNT(model_pos, view_state->vs_vop->vo_view2model, view_pos);
	VSUB2(diff, model_pos, e_axes_pos);
	VSCALE(edit_absolute_model_tran, diff, inv_Viewscale);
	VMOVE(last_edit_absolute_model_tran, edit_absolute_model_tran);

	MAT4X3PNT(ea_view_pos, view_state->vs_vop->vo_model2view, e_axes_pos);
	VSUB2(edit_absolute_view_tran, view_pos, ea_view_pos);
	VMOVE(last_edit_absolute_view_tran, edit_absolute_view_tran);
}

void
sedit_trans(fastf_t *tvec)
{
  vect_t temp;
  vect_t raw_kp;
  vect_t pos_model;

  if( es_edflag <= 0 )
    return;

  switch( es_edflag ) {
  case STRANS:
    /* 
     * Use mouse to change solid's location.
     * Project solid's keypoint into view space,
     * replace X,Y and Z components, and
     * project result back to model space.
     * Then move keypoint there.
     */
    {
      point_t	pt;
      vect_t	delta;
      mat_t	xlatemat;

      MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, tvec);
      MAT4X3PNT( pt, es_invmat, temp );
      MAT4X3PNT( raw_kp, es_invmat, es_keypoint );

      /* Need vector from current vertex/keypoint
       * to desired new location.
       */
      VSUB2( delta, raw_kp, pt );
      MAT_IDN( xlatemat );
      MAT_DELTAS_VEC_NEG( xlatemat, delta );
      transform_editing_solid(&es_int, xlatemat, &es_int, 1);
    }

    break;
  case ECMD_VTRANS:
    /* 
     * Use mouse to change a vertex location.
     * Project vertex (in solid keypoint) into view space,
     * replace X,Y and Z components, and
     * project result back to model space.
     * Leave desired location in es_mparam.
     */
    MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, tvec);
    MAT4X3PNT( es_mparam, es_invmat, temp );
    es_mvalid = 1;	/* es_mparam is valid */
    /* Leave the rest to code in sedit() */

    break;
  case ECMD_TGC_MV_H:
  case ECMD_TGC_MV_HH:
    /* Use mouse to change location of point V+H */
    {
      vect_t tr_temp;
      struct rt_tgc_internal	*tgc = 
	(struct rt_tgc_internal *)es_int.idb_ptr;
      RT_TGC_CK_MAGIC(tgc);

      MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, tvec);
      MAT4X3PNT( tr_temp, es_invmat, temp );
      VSUB2( tgc->h, tr_temp, tgc->v );
    }

    break;
  case ECMD_EXTR_MOV_H:
    /* Use mouse to change location of point V+H */
    {
      vect_t tr_temp;
      struct rt_extrude_internal	*extr = 
	(struct rt_extrude_internal *)es_int.idb_ptr;
      RT_EXTRUDE_CK_MAGIC(extr);

      MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, tvec);
      MAT4X3PNT( tr_temp, es_invmat, temp );
      VSUB2( extr->h, tr_temp, extr->V );
    }

    break;
  case ECMD_CLINE_MOVE_H:
    /* Use mouse to change location of point V+H */
    {
      vect_t tr_temp;
      struct rt_cline_internal	*cli = 
	(struct rt_cline_internal *)es_int.idb_ptr;
      RT_CLINE_CK_MAGIC(cli);

      MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, tvec);
      MAT4X3PNT( tr_temp, es_invmat, temp );
      VSUB2( cli->h, tr_temp, cli->v );
    }

    break;
  case PTARB:
    /* move an arb point to indicated point */
    /* point is located at es_values[es_menu*3] */
    {
      struct rt_arb_internal *arb=
	(struct rt_arb_internal *)es_int.idb_ptr;
      RT_ARB_CK_MAGIC( arb );

      VMOVE( temp , arb->pt[es_menu] );
    }

    MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, tvec);
    MAT4X3PNT(pos_model, es_invmat, temp);
    editarb( pos_model );

    break;
  case EARB:
    /* move arb edge, through indicated point */
    MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, tvec);
    /* apply inverse of es_mat */
    MAT4X3PNT( pos_model, es_invmat, temp );
    editarb( pos_model );

    break;
  case ECMD_ARB_MOVE_FACE:
    /* move arb face, through  indicated  point */
    MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, tvec);

    /* apply inverse of es_mat */
    MAT4X3PNT( pos_model, es_invmat, temp );

    /* change D of planar equation */
    es_peqn[es_menu][3]=VDOT(&es_peqn[es_menu][0], pos_model);

    /* calculate new vertices, put in record as vectors */
    {
      struct rt_arb_internal *arb=
	(struct rt_arb_internal *)es_int.idb_ptr;
      
      RT_ARB_CK_MAGIC( arb );
      (void)rt_arb_calc_points( arb , es_type , es_peqn , &mged_tol );
    }

    break;
  case ECMD_NMG_EPICK:
    /* XXX Should just leave desired location in es_mparam for sedit() */
    {
      struct model	*m = 
	(struct model *)es_int.idb_ptr;
      struct edge	*e;
      struct bn_tol	tmp_tol;
      NMG_CK_MODEL(m);

      /* Picking an edge should not depend on tolerances! */
      tmp_tol.magic = BN_TOL_MAGIC;
      tmp_tol.dist = 0.0;
      tmp_tol.dist_sq = tmp_tol.dist * tmp_tol.dist;
      tmp_tol.perp = 0.0;
      tmp_tol.para = 1 - tmp_tol.perp;

      if ((e = nmg_find_e_nearest_pt2(&m->magic,
				      tvec,
				      view_state->vs_vop->vo_model2view,
				      &tmp_tol)) == (struct edge *)NULL) {
	Tcl_AppendResult(interp,
			 "ECMD_NMG_EPICK: unable to find an edge\n",
			 (char *)NULL);
	sedraw = 0;
	return;
      }
      es_eu = e->eu_p;
      NMG_CK_EDGEUSE(es_eu);

      {
	struct bu_vls tmp_vls;

	bu_vls_init(&tmp_vls);
	bu_vls_printf(&tmp_vls,
		      "edgeuse selected=x%x (%g %g %g) <-> (%g %g %g)\n",
		      es_eu, V3ARGS( es_eu->vu_p->v_p->vg_p->coord ),
		      V3ARGS( es_eu->eumate_p->vu_p->v_p->vg_p->coord ) );
	Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	bu_vls_free(&tmp_vls);
      }
    }

    break;
  case ECMD_NMG_LEXTRU:
  case ECMD_NMG_EMOVE:
  case ECMD_NMG_ESPLIT:
  case ECMD_PIPE_PICK:
  case ECMD_PIPE_SPLIT:
  case ECMD_PIPE_PT_MOVE:
  case ECMD_PIPE_PT_ADD:
  case ECMD_PIPE_PT_INS:
  case ECMD_ARS_PICK:
  case ECMD_ARS_MOVE_PT:
  case ECMD_ARS_MOVE_CRV:
  case ECMD_ARS_MOVE_COL:
    MAT4X3PNT(temp, view_state->vs_vop->vo_view2model, tvec);
    /* apply inverse of es_mat */
    MAT4X3PNT( es_mparam, es_invmat, temp );
    es_mvalid = 1;

    break;
  default:
    Tcl_AppendResult(interp,
		     "mouse press undefined in this solid edit mode\n",
		     (char *)NULL);
    sedraw = 0;
    return;
  }

  sedit();
}

void
sedit_abs_scale(void)
{
  fastf_t old_acc_sc_sol;

  if( es_edflag != SSCALE && es_edflag != PSCALE )
    return;

  old_acc_sc_sol = acc_sc_sol;

  if(-SMALL_FASTF < edit_absolute_scale && edit_absolute_scale < SMALL_FASTF)
    acc_sc_sol = 1.0;
  else if(edit_absolute_scale > 0.0)
    acc_sc_sol = 1.0 + edit_absolute_scale * 3.0;
  else{
    if((edit_absolute_scale - MGED_SMALL_SCALE) < -1.0)
      edit_absolute_scale = -1.0 + MGED_SMALL_SCALE;
    
    acc_sc_sol = 1.0 + edit_absolute_scale;
  }

  es_scale = acc_sc_sol / old_acc_sc_sol;
  sedit();
}


/*
 *  Object Edit
 */
void
objedit_mouse( const vect_t mousevec )
{
  fastf_t			scale;
  vect_t	pos_view;	 	/* Unrotated view space pos */
  vect_t	pos_model;	/* Rotated screen space pos */
  vect_t	tr_temp;		/* temp translation vector */
  vect_t	temp;

  MAT_IDN( incr_change );
  scale = 1;
  if( movedir & SARROW )  {
    /* scaling option is in effect */
    scale = 1.0 + (fastf_t)(mousevec[Y]>0 ?
			    mousevec[Y] : -mousevec[Y]);
    if ( mousevec[Y] <= 0 )
      scale = 1.0 / scale;

    /* switch depending on scaling option selected */
    switch( edobj ) {

    case BE_O_SCALE:
      /* global scaling */
      incr_change[15] = 1.0 / scale;
      
      acc_sc_obj /= incr_change[15];
      edit_absolute_scale = acc_sc_obj - 1.0;
      if(edit_absolute_scale > 0.0)
	edit_absolute_scale /= 3.0;
      break;

    case BE_O_XSCALE:
      /* local scaling ... X-axis */
      incr_change[0] = scale;
      /* accumulate the scale factor */
      acc_sc[0] *= scale;
      edit_absolute_scale = acc_sc[0] - 1.0;
      if(edit_absolute_scale > 0.0)
	edit_absolute_scale /= 3.0;
      break;

    case BE_O_YSCALE:
      /* local scaling ... Y-axis */
      incr_change[5] = scale;
      /* accumulate the scale factor */
      acc_sc[1] *= scale;
      edit_absolute_scale = acc_sc[1] - 1.0;
      if(edit_absolute_scale > 0.0)
	edit_absolute_scale /= 3.0;
      break;
      
    case BE_O_ZSCALE:
      /* local scaling ... Z-axis */
      incr_change[10] = scale;
      /* accumulate the scale factor */
      acc_sc[2] *= scale;
      edit_absolute_scale = acc_sc[2] - 1.0;
      if(edit_absolute_scale > 0.0)
	edit_absolute_scale /= 3.0;
      break;
    }

    /* Have scaling take place with respect to keypoint,
     * NOT the view center.
     */
#if 0
    MAT4X3PNT(temp, es_mat, es_keypoint);
#else
    VMOVE(temp, es_keypoint);
#endif
    MAT4X3PNT(pos_model, modelchanges, temp);
    wrt_point(modelchanges, incr_change, modelchanges, pos_model);

    MAT_IDN( incr_change );
    new_edit_mats();
  }  else if( movedir & (RARROW|UARROW) )  {
    mat_t oldchanges;	/* temporary matrix */

    /* Vector from object keypoint to cursor */
#if 0
    MAT4X3PNT( temp, es_mat, es_keypoint );
#else
    VMOVE(temp, es_keypoint);
#endif
    MAT4X3PNT( pos_view, view_state->vs_model2objview, temp );

    if( movedir & RARROW )
      pos_view[X] = mousevec[X];
    if( movedir & UARROW )
      pos_view[Y] = mousevec[Y];

    MAT4X3PNT(pos_model, view_state->vs_vop->vo_view2model, pos_view);/* NOT objview */
    MAT4X3PNT( tr_temp, modelchanges, temp );
    VSUB2( tr_temp, pos_model, tr_temp );
    MAT_DELTAS(incr_change,
	       tr_temp[X], tr_temp[Y], tr_temp[Z]);
    MAT_COPY( oldchanges, modelchanges );
    bn_mat_mul( modelchanges, incr_change, oldchanges );

    MAT_IDN( incr_change );
    new_edit_mats();

    update_edit_absolute_tran(pos_view);
  }  else  {
    Tcl_AppendResult(interp, "No object edit mode selected;  mouse press ignored\n", (char *)NULL);
    return;
  }
}


void
oedit_trans(fastf_t *tvec)
{
  point_t  pos_model;
  point_t  tr_temp;
  point_t  temp;
  mat_t incr_mat;
  mat_t oldchanges;	/* temporary matrix */

  MAT_IDN( incr_mat );
#if 0
  MAT4X3PNT( temp, es_mat, es_keypoint );
#else
  VMOVE(temp, es_keypoint);
#endif
  MAT4X3PNT( pos_model, view_state->vs_vop->vo_view2model, tvec );/* NOT objview */
  MAT4X3PNT( tr_temp, modelchanges, temp );
  VSUB2( tr_temp, pos_model, tr_temp );
  MAT_DELTAS(incr_mat,
	     tr_temp[X], tr_temp[Y], tr_temp[Z]);
  MAT_COPY( oldchanges, modelchanges );
  bn_mat_mul( modelchanges, incr_mat, oldchanges );

  new_edit_mats();
}


void
oedit_abs_scale(void)
{
  fastf_t scale;
  vect_t temp;
  vect_t pos_model;
  mat_t incr_mat;

  MAT_IDN( incr_mat );

  if(-SMALL_FASTF < edit_absolute_scale && edit_absolute_scale < SMALL_FASTF)
    scale = 1;
  else if(edit_absolute_scale > 0.0)
    scale = 1.0 + edit_absolute_scale * 3.0;
  else{
    if((edit_absolute_scale - MGED_SMALL_SCALE) < -1.0)
      edit_absolute_scale = -1.0 + MGED_SMALL_SCALE;

    scale = 1.0 + edit_absolute_scale;
  }

  /* switch depending on scaling option selected */
  switch( edobj ) {

  case BE_O_SCALE:
    /* global scaling */
    incr_mat[15] = acc_sc_obj / scale;
    acc_sc_obj = scale;
    break;

  case BE_O_XSCALE:
    /* local scaling ... X-axis */
    incr_mat[0] = scale / acc_sc[0];
    /* accumulate the scale factor */
    acc_sc[0] = scale;
    break;

  case BE_O_YSCALE:
    /* local scaling ... Y-axis */
    incr_mat[5] = scale / acc_sc[1];
    /* accumulate the scale factor */
    acc_sc[1] = scale;
    break;

  case BE_O_ZSCALE:
    /* local scaling ... Z-axis */
    incr_mat[10] = scale / acc_sc[2];
    /* accumulate the scale factor */
    acc_sc[2] = scale;
    break;
  }

  /* Have scaling take place with respect to keypoint,
   * NOT the view center.
   */
#if 0
  MAT4X3PNT(temp, es_mat, es_keypoint);
#else
  VMOVE(temp, es_keypoint);
#endif
  MAT4X3PNT(pos_model, modelchanges, temp);
  wrt_point(modelchanges, incr_mat, modelchanges, pos_model);

  new_edit_mats();
}


/*
 *			V L S _ S O L I D
 */
void
vls_solid( struct bu_vls *vp, const struct rt_db_internal *ip, const mat_t mat )
{
	struct rt_db_internal	intern;
	int			id;

	if(dbip == DBI_NULL)
	  return;

	BU_CK_VLS(vp);
	RT_CK_DB_INTERNAL(ip);

	id = ip->idb_type;
	transform_editing_solid( &intern, mat, (struct rt_db_internal *)ip, 0 );

	if( id != ID_ARS && id != ID_POLY && id != ID_BOT )
	{
		if( rt_functab[id].ft_describe( vp, &intern, 1 /*verbose*/,
		    base2local, &rt_uniresource, dbip ) < 0 )
		  Tcl_AppendResult(interp, "vls_solid: describe error\n", (char *)NULL);
	}
	else
	{
		if( rt_functab[id].ft_describe( vp, &intern, 0 /* not verbose */,
		    base2local, &rt_uniresource, dbip ) < 0 )
		  Tcl_AppendResult(interp, "vls_solid: describe error\n", (char *)NULL);
	}

	if( id == ID_PIPE && es_pipept )
	{
		struct rt_pipe_internal *pipe;
		struct wdb_pipept *ps=(struct wdb_pipept *)NULL;
		int seg_no=0;

		pipe = (struct rt_pipe_internal *)ip->idb_ptr;
		RT_PIPE_CK_MAGIC( pipe );

		for( BU_LIST_FOR( ps, wdb_pipept, &pipe->pipe_segs_head ) )
		{
			seg_no++;
			if( ps == es_pipept )
				break;
		}

		if( ps == es_pipept )
			rt_vls_pipept( vp, seg_no, &intern, base2local );
	}

	rt_db_free_internal( &intern, &rt_uniresource );
}

/*
 *  			P S C A L E
 *  
 *  Partial scaling of a solid.
 */
void
pscale(void)
{
	static fastf_t ma,mb;

	switch( es_menu ) {

	case MENU_VOL_CSIZE:	/* scale voxel size */
		{
			bu_log( "es_scale = %g\n", es_scale );
		}
		break;

	case MENU_TGC_SCALE_H:	/* scale height vector */
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;
			RT_TGC_CK_MAGIC(tgc);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(tgc->h);
			}
			VSCALE(tgc->h, tgc->h, es_scale);
		}
		break;

	case MENU_TGC_SCALE_H_V:	/* scale height vector (but move V) */
		{
			point_t old_top;

			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;
			RT_TGC_CK_MAGIC(tgc);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(tgc->h);
			}
			VADD2( old_top, tgc->v, tgc->h );
			VSCALE(tgc->h, tgc->h, es_scale);
			VSUB2( tgc->v, old_top, tgc->h );
		}
		break;

	case MENU_TGC_SCALE_H_CD:
		{
			vect_t vec1, vec2;
			vect_t c, d;
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;

			RT_TGC_CK_MAGIC(tgc);

			if (inpara) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(tgc->h);
			}

			/* calculate new c */
			VSUB2(vec1, tgc->a, tgc->c);
			VSCALE(vec2, vec1, 1-es_scale);
			VADD2(c, tgc->c, vec2);

			/* calculate new d */
			VSUB2(vec1, tgc->b, tgc->d);
			VSCALE(vec2, vec1, 1-es_scale);
			VADD2(d, tgc->d, vec2);

			if (0 <= VDOT(tgc->c, c) &&
			    0 <= VDOT(tgc->d, d) &&
			    !NEAR_ZERO(MAGNITUDE(c), SMALL_FASTF) &&
			    !NEAR_ZERO(MAGNITUDE(d), SMALL_FASTF)) {
				/* adjust c, d and h */
				VMOVE(tgc->c, c);
				VMOVE(tgc->d, d);
				VSCALE(tgc->h, tgc->h, es_scale);
			}
		}
		break;

	case MENU_TGC_SCALE_H_V_AB:
		{
			vect_t vec1, vec2;
			vect_t a, b;
			point_t old_top;
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;

			RT_TGC_CK_MAGIC(tgc);

			if (inpara) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(tgc->h);
			}

			/* calculate new a */
			VSUB2(vec1, tgc->c, tgc->a);
			VSCALE(vec2, vec1, 1-es_scale);
			VADD2(a, tgc->a, vec2);

			/* calculate new b */
			VSUB2(vec1, tgc->d, tgc->b);
			VSCALE(vec2, vec1, 1-es_scale);
			VADD2(b, tgc->b, vec2);

			if (0 <= VDOT(tgc->a, a) &&
			    0 <= VDOT(tgc->b, b) &&
			    !NEAR_ZERO(MAGNITUDE(a), SMALL_FASTF) &&
			    !NEAR_ZERO(MAGNITUDE(b), SMALL_FASTF)) {
				/* adjust a, b, v and h */
				VMOVE(tgc->a, a);
				VMOVE(tgc->b, b);
				VADD2( old_top, tgc->v, tgc->h );
				VSCALE(tgc->h, tgc->h, es_scale);
				VSUB2( tgc->v, old_top, tgc->h );
			}
		}
		break;

	case MENU_TOR_R1:
		/* scale radius 1 of TOR */
		{
			struct rt_tor_internal	*tor = 
				(struct rt_tor_internal *)es_int.idb_ptr;
			fastf_t	newrad;
			RT_TOR_CK_MAGIC(tor);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				newrad = es_para[0];
			} else {
				newrad = tor->r_a * es_scale;
			}
			if( newrad < SMALL )  newrad = 4*SMALL;
			if( tor->r_h <= newrad )
				tor->r_a = newrad;
		}
		break;

	case MENU_TOR_R2:
		/* scale radius 2 of TOR */
		{
			struct rt_tor_internal	*tor = 
				(struct rt_tor_internal *)es_int.idb_ptr;
			fastf_t	newrad;
			RT_TOR_CK_MAGIC(tor);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				newrad = es_para[0];
			} else {
				newrad = tor->r_h * es_scale;
			}
			if( newrad < SMALL )  newrad = 4*SMALL;
			if( newrad <= tor->r_a )
				tor->r_h = newrad;
		}
		break;

	case MENU_ETO_R:
		/* scale radius 1 (r) of ETO */
		{
			struct rt_eto_internal	*eto = 
				(struct rt_eto_internal *)es_int.idb_ptr;
			fastf_t	ch, cv, dh, newrad;
			vect_t	Nu;

			RT_ETO_CK_MAGIC(eto);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				newrad = es_para[0];
			} else {
				newrad = eto->eto_r * es_scale;
			}
			if( newrad < SMALL )  newrad = 4*SMALL;
			VMOVE(Nu, eto->eto_N);
			VUNITIZE(Nu);
			/* get horiz and vert components of C and Rd */
			cv = VDOT( eto->eto_C, Nu );
			ch = sqrt( VDOT( eto->eto_C, eto->eto_C ) - cv * cv );
			/* angle between C and Nu */
			dh = eto->eto_rd * cv / MAGNITUDE(eto->eto_C);
			/* make sure revolved ellipse doesn't overlap itself */
			if (ch <= newrad && dh <= newrad)
				eto->eto_r = newrad;
		}
		break;

	case MENU_ETO_RD:
		/* scale Rd, ellipse semi-minor axis length, of ETO */
		{
			struct rt_eto_internal	*eto = 
				(struct rt_eto_internal *)es_int.idb_ptr;
			fastf_t	dh, newrad, work;
			vect_t	Nu;

			RT_ETO_CK_MAGIC(eto);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				newrad = es_para[0];
			} else {
				newrad = eto->eto_rd * es_scale;
			}
			if( newrad < SMALL )  newrad = 4*SMALL;
			work = MAGNITUDE(eto->eto_C);
				if (newrad <= work) {
				VMOVE(Nu, eto->eto_N);
				VUNITIZE(Nu);
				dh = newrad * VDOT( eto->eto_C, Nu ) / work;
				/* make sure revolved ellipse doesn't overlap itself */
				if (dh <= eto->eto_r)
					eto->eto_rd = newrad;
			}
		}
		break;

	case MENU_ETO_SCALE_C:
		/* scale vector C */
		{
			struct rt_eto_internal	*eto = 
				(struct rt_eto_internal *)es_int.idb_ptr;
			fastf_t	ch, cv;
			vect_t	Nu, Work;

			RT_ETO_CK_MAGIC(eto);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(eto->eto_C);
			}
			if (es_scale * MAGNITUDE(eto->eto_C) >= eto->eto_rd) {
				VMOVE(Nu, eto->eto_N);
				VUNITIZE(Nu);
				VSCALE(Work, eto->eto_C, es_scale);
				/* get horiz and vert comps of C and Rd */
				cv = VDOT( Work, Nu );
				ch = sqrt( VDOT( Work, Work ) - cv * cv );
				if (ch <= eto->eto_r)
					VMOVE(eto->eto_C, Work);
			}
		}
		break;

	case MENU_RPC_B:
		/* scale vector B */
		{
			struct rt_rpc_internal	*rpc = 
				(struct rt_rpc_internal *)es_int.idb_ptr;
			RT_RPC_CK_MAGIC(rpc);

			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(rpc->rpc_B);
			}
			VSCALE(rpc->rpc_B, rpc->rpc_B, es_scale);
		}
		break;

	case MENU_RPC_H:
		/* scale vector H */
		{
			struct rt_rpc_internal	*rpc = 
				(struct rt_rpc_internal *)es_int.idb_ptr;

			RT_RPC_CK_MAGIC(rpc);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(rpc->rpc_H);
			}
			VSCALE(rpc->rpc_H, rpc->rpc_H, es_scale);
		}
		break;

	case MENU_RPC_R:
		/* scale rectangular half-width of RPC */
		{
			struct rt_rpc_internal	*rpc = 
				(struct rt_rpc_internal *)es_int.idb_ptr;

			RT_RPC_CK_MAGIC(rpc);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / rpc->rpc_r;
			}
			rpc->rpc_r *= es_scale;
		}
		break;

	case MENU_RHC_B:
		/* scale vector B */
		{
			struct rt_rhc_internal	*rhc = 
				(struct rt_rhc_internal *)es_int.idb_ptr;
			RT_RHC_CK_MAGIC(rhc);

			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(rhc->rhc_B);
			}
			VSCALE(rhc->rhc_B, rhc->rhc_B, es_scale);
		}
		break;

	case MENU_RHC_H:
		/* scale vector H */
		{
			struct rt_rhc_internal	*rhc = 
				(struct rt_rhc_internal *)es_int.idb_ptr;
			RT_RHC_CK_MAGIC(rhc);

			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(rhc->rhc_H);
			}
			VSCALE(rhc->rhc_H, rhc->rhc_H, es_scale);
		}
		break;

	case MENU_RHC_R:
		/* scale rectangular half-width of RHC */
		{
			struct rt_rhc_internal	*rhc = 
				(struct rt_rhc_internal *)es_int.idb_ptr;

			RT_RHC_CK_MAGIC(rhc);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / rhc->rhc_r;
			}
			rhc->rhc_r *= es_scale;
		}
		break;

	case MENU_RHC_C:
		/* scale rectangular half-width of RHC */
		{
			struct rt_rhc_internal	*rhc = 
				(struct rt_rhc_internal *)es_int.idb_ptr;

			RT_RHC_CK_MAGIC(rhc);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / rhc->rhc_c;
			}
			rhc->rhc_c *= es_scale;
		}
		break;

	case MENU_EPA_H:
		/* scale height vector H */
		{
			struct rt_epa_internal	*epa = 
				(struct rt_epa_internal *)es_int.idb_ptr;

			RT_EPA_CK_MAGIC(epa);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(epa->epa_H);
			}
			VSCALE(epa->epa_H, epa->epa_H, es_scale);
		}
		break;

	case MENU_EPA_R1:
		/* scale semimajor axis of EPA */
		{
			struct rt_epa_internal	*epa = 
				(struct rt_epa_internal *)es_int.idb_ptr;

			RT_EPA_CK_MAGIC(epa);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / epa->epa_r1;
			}
			if (epa->epa_r1 * es_scale >= epa->epa_r2)
				epa->epa_r1 *= es_scale;
			else
				bu_log("pscale:  semi-minor axis cannot be longer than semi-major axis!");
		}
		break;

	case MENU_EPA_R2:
		/* scale semiminor axis of EPA */
		{
			struct rt_epa_internal	*epa = 
				(struct rt_epa_internal *)es_int.idb_ptr;

			RT_EPA_CK_MAGIC(epa);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / epa->epa_r2;
			}
			if (epa->epa_r2 * es_scale <= epa->epa_r1)
				epa->epa_r2 *= es_scale;
			else
				bu_log("pscale:  semi-minor axis cannot be longer than semi-major axis!");
		}
		break;

	case MENU_EHY_H:
		/* scale height vector H */
		{
			struct rt_ehy_internal	*ehy = 
				(struct rt_ehy_internal *)es_int.idb_ptr;

			RT_EHY_CK_MAGIC(ehy);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(ehy->ehy_H);
			}
			VSCALE(ehy->ehy_H, ehy->ehy_H, es_scale);
		}
		break;

	case MENU_EHY_R1:
		/* scale semimajor axis of EHY */
		{
			struct rt_ehy_internal	*ehy = 
				(struct rt_ehy_internal *)es_int.idb_ptr;

			RT_EHY_CK_MAGIC(ehy);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / ehy->ehy_r1;
			}
			if (ehy->ehy_r1 * es_scale >= ehy->ehy_r2)
				ehy->ehy_r1 *= es_scale;
			else
				bu_log("pscale:  semi-minor axis cannot be longer than semi-major axis!");
		}
		break;

	case MENU_EHY_R2:
		/* scale semiminor axis of EHY */
		{
			struct rt_ehy_internal	*ehy = 
				(struct rt_ehy_internal *)es_int.idb_ptr;

			RT_EHY_CK_MAGIC(ehy);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / ehy->ehy_r2;
			}
			if (ehy->ehy_r2 * es_scale <= ehy->ehy_r1)
				ehy->ehy_r2 *= es_scale;
			else
				bu_log("pscale:  semi-minor axis cannot be longer than semi-major axis!");
		}
		break;

	case MENU_EHY_C:
		/* scale distance between apex of EHY & asymptotic cone */
		{
			struct rt_ehy_internal	*ehy = 
				(struct rt_ehy_internal *)es_int.idb_ptr;

			RT_EHY_CK_MAGIC(ehy);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / ehy->ehy_c;
			}
			ehy->ehy_c *= es_scale;
		}
		break;

	case MENU_TGC_SCALE_A:
		/* scale vector A */
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;
			RT_TGC_CK_MAGIC(tgc);

			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(tgc->a);
			}
			VSCALE(tgc->a, tgc->a, es_scale);
		}
		break;

	case MENU_TGC_SCALE_B:
		/* scale vector B */
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;
			RT_TGC_CK_MAGIC(tgc);

			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(tgc->b);
			}
			VSCALE(tgc->b, tgc->b, es_scale);
		}
		break;

	case MENU_ELL_SCALE_A:
		/* scale vector A */
		{
			struct rt_ell_internal	*ell = 
				(struct rt_ell_internal *)es_int.idb_ptr;
			RT_ELL_CK_MAGIC(ell);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_scale = es_para[0] * es_mat[15] /
					MAGNITUDE(ell->a);
			}
			VSCALE( ell->a, ell->a, es_scale );
		}
		break;

	case MENU_ELL_SCALE_B:
		/* scale vector B */
		{
			struct rt_ell_internal	*ell = 
				(struct rt_ell_internal *)es_int.idb_ptr;
			RT_ELL_CK_MAGIC(ell);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_scale = es_para[0] * es_mat[15] /
					MAGNITUDE(ell->b);
			}
			VSCALE( ell->b, ell->b, es_scale );
		}
		break;

	case MENU_ELL_SCALE_C:
		/* scale vector C */
		{
			struct rt_ell_internal	*ell = 
				(struct rt_ell_internal *)es_int.idb_ptr;
			RT_ELL_CK_MAGIC(ell);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_scale = es_para[0] * es_mat[15] /
					MAGNITUDE(ell->c);
			}
			VSCALE( ell->c, ell->c, es_scale );
		}
		break;

	case MENU_TGC_SCALE_C:
		/* TGC: scale ratio "c" */
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;
			RT_TGC_CK_MAGIC(tgc);

			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(tgc->c);
			}
			VSCALE(tgc->c, tgc->c, es_scale);
		}
		break;

	case MENU_TGC_SCALE_D:   /* scale  d for tgc */
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;
			RT_TGC_CK_MAGIC(tgc);

			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(tgc->d);
			}
			VSCALE(tgc->d, tgc->d, es_scale);
		}
		break;

	case MENU_TGC_SCALE_AB:
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;
			RT_TGC_CK_MAGIC(tgc);

			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(tgc->a);
			}
			VSCALE(tgc->a, tgc->a, es_scale);
			ma = MAGNITUDE( tgc->a );
			mb = MAGNITUDE( tgc->b );
			VSCALE(tgc->b, tgc->b, ma/mb);
		}
		break;

	case MENU_TGC_SCALE_CD:	/* scale C and D of tgc */
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;
			RT_TGC_CK_MAGIC(tgc);

			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(tgc->c);
			}
			VSCALE(tgc->c, tgc->c, es_scale);
			ma = MAGNITUDE( tgc->c );
			mb = MAGNITUDE( tgc->d );
			VSCALE(tgc->d, tgc->d, ma/mb);
		}
		break;

	case MENU_TGC_SCALE_ABCD: 		/* scale A,B,C, and D of tgc */
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;
			RT_TGC_CK_MAGIC(tgc);

			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(tgc->a);
			}
			VSCALE(tgc->a, tgc->a, es_scale);
			ma = MAGNITUDE( tgc->a );
			mb = MAGNITUDE( tgc->b );
			VSCALE(tgc->b, tgc->b, ma/mb);
			mb = MAGNITUDE( tgc->c );
			VSCALE(tgc->c, tgc->c, ma/mb);
			mb = MAGNITUDE( tgc->d );
			VSCALE(tgc->d, tgc->d, ma/mb);
		}
		break;

	case MENU_ELL_SCALE_ABC:	/* set A,B, and C length the same */
		{
			struct rt_ell_internal	*ell = 
				(struct rt_ell_internal *)es_int.idb_ptr;
			RT_ELL_CK_MAGIC(ell);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_scale = es_para[0] * es_mat[15] /
					MAGNITUDE(ell->a);
			}
			VSCALE( ell->a, ell->a, es_scale );
			ma = MAGNITUDE( ell->a );
			mb = MAGNITUDE( ell->b );
			VSCALE(ell->b, ell->b, ma/mb);
			mb = MAGNITUDE( ell->c );
			VSCALE(ell->c, ell->c, ma/mb);
		}
		break;

		/* begin super ellipse menu options */
	case MENU_SUPERELL_SCALE_A:
		/* scale vector A */
		{
			struct rt_superell_internal	*superell = 
				(struct rt_superell_internal *)es_int.idb_ptr;
			RT_SUPERELL_CK_MAGIC(superell);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_scale = es_para[0] * es_mat[15] /
					MAGNITUDE(superell->a);
			}
			VSCALE( superell->a, superell->a, es_scale );
		}
		break;

	case MENU_SUPERELL_SCALE_B:
		/* scale vector B */
		{
			struct rt_superell_internal	*superell = 
				(struct rt_superell_internal *)es_int.idb_ptr;
			RT_SUPERELL_CK_MAGIC(superell);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_scale = es_para[0] * es_mat[15] /
					MAGNITUDE(superell->b);
			}
			VSCALE( superell->b, superell->b, es_scale );
		}
		break;

	case MENU_SUPERELL_SCALE_C:
		/* scale vector C */
		{
			struct rt_superell_internal	*superell = 
				(struct rt_superell_internal *)es_int.idb_ptr;
			RT_SUPERELL_CK_MAGIC(superell);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_scale = es_para[0] * es_mat[15] /
					MAGNITUDE(superell->c);
			}
			VSCALE( superell->c, superell->c, es_scale );
		}
		break;

	case MENU_SUPERELL_SCALE_ABC:	/* set A,B, and C length the same */
		{
			struct rt_superell_internal	*superell = 
				(struct rt_superell_internal *)es_int.idb_ptr;
			RT_SUPERELL_CK_MAGIC(superell);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_scale = es_para[0] * es_mat[15] /
					MAGNITUDE(superell->a);
			}
			VSCALE( superell->a, superell->a, es_scale );
			ma = MAGNITUDE( superell->a );
			mb = MAGNITUDE( superell->b );
			VSCALE(superell->b, superell->b, ma/mb);
			mb = MAGNITUDE( superell->c );
			VSCALE(superell->c, superell->c, ma/mb);
		}
		break;


	case MENU_PIPE_PT_OD:	/* scale OD of one pipe segment */
	  {
	    if( !es_pipept )
	      {
		Tcl_AppendResult(interp, "pscale: no pipe segment selected for scaling\n", (char *)NULL);
		return;
	      }
			
	    if( inpara ) {
	      /* take es_mat[15] (path scaling) into account */
	      if( es_pipept->pp_od > 0.0 )
		es_scale = es_para[0] * es_mat[15]/es_pipept->pp_od;
	      else
		es_scale = (-es_para[0] * es_mat[15]);
	    }
	    pipe_seg_scale_od( es_pipept, es_scale );
	  }
	  break;
	case MENU_PIPE_PT_ID:	/* scale ID of one pipe segment */
		{
			if( !es_pipept )
			{
			  Tcl_AppendResult(interp, "pscale: no pipe segment selected for scaling\n", (char *)NULL);
			  return;
			}
			
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				if( es_pipept->pp_id > 0.0 )
					es_scale = es_para[0] * es_mat[15]/es_pipept->pp_id;
				else
					es_scale = (-es_para[0] * es_mat[15]);
			}
			pipe_seg_scale_id( es_pipept, es_scale );
		}
		break;
	case MENU_PIPE_PT_RADIUS:	/* scale bend radius at selected point */
		{
			if( !es_pipept )
			{
			  Tcl_AppendResult(interp, "pscale: no pipe segment selected for scaling\n", (char *)NULL);
			  return;
			}
			
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				if( es_pipept->pp_id > 0.0 )
					es_scale = es_para[0] * es_mat[15]/es_pipept->pp_bendradius;
				else
					es_scale = (-es_para[0] * es_mat[15]);
			}
			pipe_seg_scale_radius( es_pipept, es_scale );
		}
		break;
	case MENU_PIPE_SCALE_OD:	/* scale entire pipe OD */
		if( inpara )
		{
			struct rt_pipe_internal *pipe =
				(struct rt_pipe_internal *)es_int.idb_ptr;
			struct wdb_pipept *ps;

			RT_PIPE_CK_MAGIC( pipe );

			ps = BU_LIST_FIRST( wdb_pipept, &pipe->pipe_segs_head );
			BU_CKMAG( ps, WDB_PIPESEG_MAGIC, "wdb_pipept" );

			if( ps->pp_od > 0.0 )
				es_scale = es_para[0] * es_mat[15]/ps->pp_od;
			else
			{
				while( ps->l.magic != BU_LIST_HEAD_MAGIC && ps->pp_od <= 0.0 )
					ps = BU_LIST_NEXT( wdb_pipept, &ps->l );

				if( ps->l.magic == BU_LIST_HEAD_MAGIC )
				{
				  Tcl_AppendResult(interp, "Entire pipe solid has zero OD!!!!\n", (char *)NULL);
				  return;
				}

				es_scale = es_para[0] * es_mat[15]/ps->pp_od;
			}
		}
		pipe_scale_od( &es_int, es_scale );
		break;
	case MENU_PIPE_SCALE_ID:	/* scale entire pipe ID */
		if( inpara )
		{
			struct rt_pipe_internal *pipe =
				(struct rt_pipe_internal *)es_int.idb_ptr;
			struct wdb_pipept *ps;

			RT_PIPE_CK_MAGIC( pipe );

			ps = BU_LIST_FIRST( wdb_pipept, &pipe->pipe_segs_head );
			BU_CKMAG( ps, WDB_PIPESEG_MAGIC, "wdb_pipept" );

			if( ps->pp_id > 0.0 )
				es_scale = es_para[0] * es_mat[15]/ps->pp_id;
			else
			{
				while( ps->l.magic != BU_LIST_HEAD_MAGIC && ps->pp_id <= 0.0 )
					ps = BU_LIST_NEXT( wdb_pipept, &ps->l );

				/* Check if entire pipe has zero ID */
				if( ps->l.magic == BU_LIST_HEAD_MAGIC )
					es_scale = (-es_para[0] * es_mat[15]);
				else
					es_scale = es_para[0] * es_mat[15]/ps->pp_id;
			}
		}
		pipe_scale_id( &es_int, es_scale );
		break;
	case MENU_PIPE_SCALE_RADIUS:	/* scale entire pipr bend radius */
		if( inpara )
		{
			struct rt_pipe_internal *pipe =
				(struct rt_pipe_internal *)es_int.idb_ptr;
			struct wdb_pipept *ps;

			RT_PIPE_CK_MAGIC( pipe );

			ps = BU_LIST_FIRST( wdb_pipept, &pipe->pipe_segs_head );
			BU_CKMAG( ps, WDB_PIPESEG_MAGIC, "wdb_pipept" );

			if( ps->pp_bendradius > 0.0 )
				es_scale = es_para[0] * es_mat[15]/ps->pp_bendradius;
			else
			{
				while( ps->l.magic != BU_LIST_HEAD_MAGIC && ps->pp_bendradius <= 0.0 )
					ps = BU_LIST_NEXT( wdb_pipept, &ps->l );

				/* Check if entire pipe has zero ID */
				if( ps->l.magic == BU_LIST_HEAD_MAGIC )
					es_scale = (-es_para[0] * es_mat[15]);
				else
					es_scale = es_para[0] * es_mat[15]/ps->pp_bendradius;
			}
		}
		pipe_scale_radius( &es_int, es_scale );
		break;
	case MENU_PART_H:
		/* scale vector H */
		{
			struct rt_part_internal	*part = 
				(struct rt_part_internal *)es_int.idb_ptr;

			RT_PART_CK_MAGIC(part);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(part->part_H);
			}
			VSCALE(part->part_H, part->part_H, es_scale);
		}
		break;

	case MENU_PART_v:
		/* scale v end radius */
		{
			struct rt_part_internal	*part = 
				(struct rt_part_internal *)es_int.idb_ptr;

			RT_PART_CK_MAGIC(part);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / part->part_vrad;
			}
			part->part_vrad *= es_scale;
		}
		break;

	case MENU_PART_h:
		/* scale h end radius */
		{
			struct rt_part_internal	*part = 
				(struct rt_part_internal *)es_int.idb_ptr;

			RT_PART_CK_MAGIC(part);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / part->part_hrad;
			}
			part->part_hrad *= es_scale;
		}
		break;

	}
}

/*
 *			I N I T _ O B J E D I T _ G U T S
 *
 */
static void
init_oedit_guts(void)
{
	int			id;
	char			*strp="";

	/* for safety sake */
	es_menu = 0;
	es_edflag = -1;
	MAT_IDN(es_mat);

	if (dbip == DBI_NULL)
		return;

	/*
	 * Check for a processed region 
	 */
	if (illump->s_Eflag) {
		/* Have a processed (E'd) region - NO key solid.
		 * 	Use the 'center' as the key
		 */
		VMOVE(es_keypoint, illump->s_center);

		/* The s_center takes the es_mat into account already */
	}

	/* Not an evaluated region - just a regular path ending in a solid */
	if( rt_db_get_internal( &es_int, LAST_SOLID(illump),
	    dbip, NULL, &rt_uniresource ) < 0 )  {
		Tcl_AppendResult(interp, "init_oedit(",
	    			LAST_SOLID(illump)->d_namep,
				 "):  solid import failure\n", (char *)NULL);
		rt_db_free_internal( &es_int, &rt_uniresource );
		button(BE_REJECT);
		return;				/* FAIL */
	}
	RT_CK_DB_INTERNAL(&es_int);
	id = es_int.idb_type;

	if (id == ID_ARB8) {
		struct rt_arb_internal *arb;

		arb = (struct rt_arb_internal *)es_int.idb_ptr;
		RT_ARB_CK_MAGIC(arb);

		es_type = rt_arb_std_type(&es_int , &mged_tol);
	}

	/* Save aggregate path matrix */
	pathHmat(illump, es_mat, illump->s_fullpath.fp_len-2);

	/* get the inverse matrix */
	bn_mat_inv(es_invmat, es_mat);

	get_solid_keypoint(es_keypoint, &strp, &es_int, es_mat);
	init_oedit_vars();
}

static void
init_oedit_vars(void)
{
	set_e_axes_pos(1);

	VSETALL(edit_absolute_model_rotate, 0.0);
	VSETALL(edit_absolute_object_rotate, 0.0);
	VSETALL(edit_absolute_view_rotate, 0.0);
	VSETALL(last_edit_absolute_model_rotate, 0.0);
	VSETALL(last_edit_absolute_object_rotate, 0.0);
	VSETALL(last_edit_absolute_view_rotate, 0.0);
	VSETALL(edit_absolute_model_tran, 0.0);
	VSETALL(edit_absolute_view_tran, 0.0);
	VSETALL(last_edit_absolute_model_tran, 0.0);
	VSETALL(last_edit_absolute_view_tran, 0.0);
	edit_absolute_scale = 0.0;
	acc_sc_sol = 1.0;
	acc_sc_obj = 1.0;
	VSETALL(acc_sc, 1.0);

	VSETALL(edit_rate_model_rotate, 0.0);
	VSETALL(edit_rate_object_rotate, 0.0);
	VSETALL(edit_rate_view_rotate, 0.0);
	VSETALL(edit_rate_model_tran, 0.0);
	VSETALL(edit_rate_view_tran, 0.0);

	MAT_IDN(modelchanges);
	MAT_IDN(acc_rot_sol);
}

/*
 *			I N I T _ O B J E D I T
 *
 */
void
init_oedit(void)
{
	struct bu_vls		vls;

	/* do real initialization work */
	init_oedit_guts();

	es_edclass = EDIT_CLASS_NULL;

	/* begin edit callback */
	bu_vls_init(&vls);
	bu_vls_strcpy(&vls, "begin_edit_callback {}");
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
}

void oedit_reject(void);

static void
oedit_apply( int continue_editing )
{
	register struct solid *sp;
	/* matrices used to accept editing done from a depth
	 *	>= 2 from the top of the illuminated path
	 */
	mat_t topm;	/* accum matrix from pathpos 0 to i-2 */
	mat_t inv_topm;	/* inverse */
	mat_t deltam;	/* final "changes":  deltam = (inv_topm)(modelchanges)(topm) */
	mat_t tempm;

	switch (ipathpos) {
	case 0:
		moveHobj(DB_FULL_PATH_GET(&illump->s_fullpath,ipathpos),
			modelchanges);
		break;
	case 1:
		moveHinstance(DB_FULL_PATH_GET(&illump->s_fullpath,ipathpos-1),
			      DB_FULL_PATH_GET(&illump->s_fullpath,ipathpos),
			      modelchanges);
		break;
	default:
		MAT_IDN(topm);
		MAT_IDN(inv_topm);
		MAT_IDN(deltam);
		MAT_IDN(tempm);

		pathHmat(illump, topm, ipathpos-2);

		bn_mat_inv(inv_topm, topm);

		bn_mat_mul(tempm, modelchanges, topm);
		bn_mat_mul(deltam, inv_topm, tempm);

		moveHinstance(DB_FULL_PATH_GET(&illump->s_fullpath,ipathpos-1),
			      DB_FULL_PATH_GET(&illump->s_fullpath,ipathpos),
			      deltam);
		break;
	}

	/*
	 *  Redraw all solids affected by this edit.
	 *  Regenerate a new control list which does not
	 *  include the solids about to be replaced,
	 *  so we can safely fiddle the displaylist.
	 */
	modelchanges[15] = 1000000000;	/* => small ratio */

	/* Now, recompute new chunks of displaylist */
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		if (sp->s_iflag == DOWN)
			continue;
		(void)replot_original_solid(sp);

		if( continue_editing == DOWN ) {
			sp->s_iflag = DOWN;
		}
	}
}

void
oedit_accept(void)
{
	register struct solid *sp;

	if (dbip == DBI_NULL)
		return;

	if (dbip->dbi_read_only) {
		oedit_reject();
		FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
			if (sp->s_iflag == DOWN)
				continue;
			(void)replot_original_solid(sp);
			sp->s_iflag = DOWN;
		}
		bu_log("Sorry, this database is READ-ONLY\n");
		pr_prompt();

		return;
	}

	oedit_apply( DOWN ); /* finished editing */
	oedit_reject();
}

void
oedit_reject(void)
{
	rt_db_free_internal(&es_int, &rt_uniresource);
}

/* 			F _ E Q N ( )
 * Gets the A,B,C of a  planar equation from the command line and puts the
 * result into the array es_peqn[] at the position pointed to by the variable
 * 'es_menu' which is the plane being redefined. This function is only callable
 * when in solid edit and rotating the face of a GENARB8.
 */
int
f_eqn(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	short int i;
	vect_t tempvec;
	struct rt_arb_internal *arb;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 4 || 4 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help eqn");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( state != ST_S_EDIT ){
	  Tcl_AppendResult(interp, "Eqn: must be in solid edit\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( es_int.idb_type != ID_ARB8 )
	{
	  Tcl_AppendResult(interp, "Eqn: type must be GENARB8\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( es_edflag != ECMD_ARB_ROTATE_FACE ){
	  Tcl_AppendResult(interp, "Eqn: must be rotating a face\n", (char *)NULL);
	  return TCL_ERROR;
	}

	arb = (struct rt_arb_internal *)es_int.idb_ptr;
	RT_ARB_CK_MAGIC( arb );

	/* get the A,B,C from the command line */
	for(i=0; i<3; i++)
		es_peqn[es_menu][i]= atof(argv[i+1]);
	VUNITIZE( &es_peqn[es_menu][0] );

	VMOVE( tempvec , arb->pt[fixv] );
	es_peqn[es_menu][3]=VDOT( es_peqn[es_menu], tempvec );
	if( rt_arb_calc_points( arb , es_type , es_peqn , &mged_tol ) )
		return CMD_BAD;

	/* draw the new version of the solid */
	replot_editing_solid();

	/* update display information */
	view_state->vs_flag = 1;

	return TCL_OK;
}

/* Hooks from buttons.c */

/*
 * Copied from sedit_accept - modified to optionally leave
 *                            solid edit state.
 */
static int
sedit_apply(int accept_flag)
{
	struct directory	*dp;

	es_eu = (struct edgeuse *)NULL;	/* Reset es_eu */
	es_pipept = (struct wdb_pipept *)NULL; /* Reset es_pipept */
	bot_verts[0] = -1;
	bot_verts[1] = -1;
	bot_verts[2] = -1;
	
	if (lu_copy) {
		struct model *m;

		m = nmg_find_model(&lu_copy->l.magic);
		nmg_km(m);
		lu_copy = (struct loopuse *)NULL;
	}

	/* write editing changes out to disc */
	dp = LAST_SOLID(illump);

	/* make sure that any BOT solid is minimally legal */
	if (es_int.idb_type == ID_BOT) {
		struct rt_bot_internal *bot = (struct rt_bot_internal *)es_int.idb_ptr;

		RT_BOT_CK_MAGIC(bot);
		if (bot->mode == RT_BOT_SURFACE || bot->mode == RT_BOT_SOLID) {
			/* make sure facemodes and thicknesses have been freed */
			if (bot->thickness) {
				bu_free( (char *)bot->thickness, "BOT thickness" );
				bot->thickness = NULL;
			}
			if (bot->face_mode) {
				bu_free( (char *)bot->face_mode, "BOT face_mode" );
				bot->face_mode = NULL;
			}
		} else {
			/* make sure face_modes and thicknesses exist */
			if (!bot->thickness)
				bot->thickness = (fastf_t *)bu_calloc( bot->num_faces, sizeof( fastf_t ), "BOT thickness" );
			if (!bot->face_mode) {
				bot->face_mode = bu_bitv_new( bot->num_faces );
				bu_bitv_clear( bot->face_mode );
			}
		}
	}

	/* Scale change on export is 1.0 -- no change */
	if( rt_db_put_internal( dp, dbip, &es_int, &rt_uniresource ) < 0 )  {
		Tcl_AppendResult(interp, "sedit_apply(", dp->d_namep,
				 "):  solid export failure\n", (char *)NULL);
		if (accept_flag) {
			rt_db_free_internal(&es_int, &rt_uniresource);
		}
		return TCL_ERROR;				/* FAIL */
	}

	if (accept_flag) {
		menu_state->ms_flag = 0;
		movedir = 0;
		es_edflag = -1;
		es_edclass = EDIT_CLASS_NULL;

		rt_db_free_internal(&es_int, &rt_uniresource);
	} else {
		/* XXX hack to restore es_int after rt_db_put_internal blows it away */
		/* Read solid description into es_int again!!! Gaak! */
		if (rt_db_get_internal(&es_int, LAST_SOLID(illump),
				       dbip, NULL, &rt_uniresource) < 0) {
			Tcl_AppendResult(interp, "sedit_apply(",
					 LAST_SOLID(illump)->d_namep,
					 "):  solid reimport failure\n", (char *)NULL);
			rt_db_free_internal(&es_int, &rt_uniresource);
			return TCL_ERROR;
		}
	}


	return TCL_OK;
}

void
sedit_accept(void)
{
	if (dbip == DBI_NULL)
		return;

	if (not_state(ST_S_EDIT, "Primitive edit accept"))
		return;

	if (dbip->dbi_read_only) {
		sedit_reject();
		bu_log( "Sorry, this database is READ-ONLY\n" );
		pr_prompt();
		return;
	}

	if (sedraw > 0)
		sedit();

	(void)sedit_apply(1);
}

void
sedit_reject(void)
{
	if( not_state( ST_S_EDIT, "Solid edit reject" ) )  return;

	if( sedraw > 0)
	  sedit();

	es_eu = (struct edgeuse *)NULL;	/* Reset es_eu */
	es_pipept = (struct wdb_pipept *)NULL; /* Reset es_pipept */
	bot_verts[0] = -1;
	bot_verts[1] = -1;
	bot_verts[2] = -1;
	es_ars_crv = (-1);
	es_ars_col = (-1);

	if( lu_copy )
	{
		struct model *m;

		m = nmg_find_model( &lu_copy->l.magic );
		nmg_km( m );
		lu_copy = (struct loopuse *)NULL;
	}

	/* Restore the original solid everywhere */
	{
	  register struct solid *sp;

	  FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
	    if(LAST_SOLID(sp) == LAST_SOLID(illump))
	      (void)replot_original_solid( sp );
	  }
	}

	menu_state->ms_flag = 0;
	movedir = 0;
	es_edflag = -1;
	es_edclass = EDIT_CLASS_NULL;

	rt_db_free_internal( &es_int, &rt_uniresource );
}

int
mged_param(Tcl_Interp *interp, int argc, fastf_t *argvect)
{
  register int i;

  CHECK_DBI_NULL;

  if( es_edflag <= 0 )  {
    Tcl_AppendResult(interp,
		     "A solid editor option not selected\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

#if 0
  if( es_edflag == ECMD_TGC_ROT_H
      || es_edflag == ECMD_TGC_ROT_AB
      || es_edflag == ECMD_ETO_ROT_C ) {
    Tcl_AppendResult(interp,
		     "\"p\" command not defined for this option\n",
		     (char *)NULL);
    return TCL_ERROR;
  }
#endif

  inpara = 0;
  for( i = 0; i < argc; i++ )  {
    es_para[ inpara++ ] = argvect[i];
  }

  if( es_edflag == PSCALE || es_edflag == SSCALE || es_edflag == ECMD_BOT_THICK )  {
    if (inpara != 1) {
	    Tcl_AppendResult(interp, "ERROR: only one argument needed\n", (char *)NULL);
	    inpara = 0;
	    return TCL_ERROR;
    }

    if( es_menu == MENU_PIPE_PT_OD || es_menu == MENU_PIPE_PT_ID || es_menu == MENU_PIPE_SCALE_ID )
      {
	if( es_para[0] < 0.0 )
	  {
	    Tcl_AppendResult(interp, "ERROR: SCALE FACTOR < 0\n", (char *)NULL);
	    inpara = 0;
	    return TCL_ERROR;
	  }
      }
    else
      {
	if(es_para[0] <= 0.0) {
	  Tcl_AppendResult(interp, "ERROR: SCALE FACTOR <= 0\n", (char *)NULL);
	  inpara = 0;
	  return TCL_ERROR;
	}
      }
  } else {
    if (inpara != 3) {
	    Tcl_AppendResult(interp, "ERROR: three arguments needed\n", (char *)NULL);
	    inpara = 0;
	    return TCL_ERROR;
    }
  }

  /* check if need to convert input values to the base unit */
  switch( es_edflag ) {

  case STRANS:
  case ECMD_VTRANS:
  case PSCALE:
  case EARB:
  case ECMD_ARB_MOVE_FACE:
  case ECMD_TGC_MV_H:
  case ECMD_TGC_MV_HH:
  case PTARB:
  case ECMD_NMG_ESPLIT:
  case ECMD_NMG_EMOVE:
  case ECMD_NMG_LEXTRU:
  case ECMD_PIPE_PICK:
  case ECMD_PIPE_SPLIT:
  case ECMD_PIPE_PT_MOVE:
  case ECMD_PIPE_PT_ADD:
  case ECMD_PIPE_PT_INS:
  case ECMD_ARS_PICK:
  case ECMD_ARS_MOVE_PT:
  case ECMD_ARS_MOVE_CRV:
  case ECMD_ARS_MOVE_COL:
  case ECMD_VOL_CSIZE:
  case ECMD_DSP_SCALE_X:
  case ECMD_DSP_SCALE_Y:
  case ECMD_DSP_SCALE_ALT:
  case ECMD_EBM_HEIGHT:
  case ECMD_EXTR_SCALE_H:
  case ECMD_CLINE_SCALE_H:
  case ECMD_CLINE_SCALE_T:
  case ECMD_CLINE_SCALE_R:
  case ECMD_CLINE_MOVE_H:
  case ECMD_EXTR_MOV_H:
  case ECMD_BOT_THICK:
  case ECMD_BOT_MOVET:
  case ECMD_BOT_MOVEE:
  case ECMD_BOT_MOVEV:
    /* must convert to base units */
    es_para[0] *= local2base;
    es_para[1] *= local2base;
    es_para[2] *= local2base;
    /* fall through */
  default:
    break;
  }

#if 1
  sedit();

  if(SEDIT_TRAN){
    vect_t diff;
    fastf_t inv_Viewscale = 1/view_state->vs_vop->vo_scale;
		    
    VSUB2(diff, es_para, e_axes_pos);
    VSCALE(edit_absolute_model_tran, diff, inv_Viewscale);
    VMOVE(last_edit_absolute_model_tran, edit_absolute_model_tran);
  }else if(SEDIT_ROTATE){
    VMOVE(edit_absolute_model_rotate, es_para);
  }else if(SEDIT_SCALE){
    edit_absolute_scale = acc_sc_sol - 1.0;
    if(edit_absolute_scale > 0)
      edit_absolute_scale /= 3.0;
  }
#endif
  return TCL_OK;
}

/* Input parameter editing changes from keyboard */
/* Format: p dx [dy dz]		*/
int
f_param(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  register int i;
  vect_t argvect;

  CHECK_DBI_NULL;
  CHECK_READ_ONLY;

  if(argc < 2 || 4 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help p");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  for( i = 1; i < argc && i <= 3 ; i++ ){
    argvect[i-1] = atof( argv[i] );
  }

  return mged_param(interp, argc-1, argvect);
}

#if 0
/*
 *  Returns -
 *	1	solid edit claimes the rotate event
 *	0	rotate event can be used some other way.
 */
int
sedit_rotate( xangle, yangle, zangle )
double	xangle, yangle, zangle;
{
	mat_t	tempp;

	if(!SEDIT_ROTATE)
	  return 0;

	MAT_IDN( incr_change );
	bn_mat_angles_rad(incr_change, xangle, yangle, zangle);

	/* accumulate the translations */
	bn_mat_mul(tempp, incr_change, acc_rot_sol);
	MAT_COPY(acc_rot_sol, tempp);

	/* sedit() will use incr_change or acc_rot_sol ?? */
	sedit();	/* change es_int only, NOW */

	return 1;
}

/*
 *  Returns -
 *	1	object edit claimes the rotate event
 *	0	rotate event can be used some other way.
 */
int
objedit_rotate( xangle, yangle, zangle )
double	xangle, yangle, zangle;
{
	mat_t	tempp;
	vect_t	point;

	if( movedir != ROTARROW )  return 0;

	MAT_IDN( incr_change );
	bn_mat_angles_rad(incr_change, xangle, yangle, zangle);

	/* accumulate change matrix - do it wrt a point NOT view center */
#if 0
	MAT4X3PNT(point, modelchanges, es_keypoint);
#else
	bn_mat_mul(tempp, modelchanges, es_mat);
	MAT4X3PNT(point, tempp, es_keypoint);
#endif
	wrt_point(modelchanges, incr_change, modelchanges, point);

	new_edit_mats();

	return 1;
}
#endif

/*
 *			L A B E L _ E D I T E D _ S O L I D
 *
 *  Put labels on the vertices of the currently edited solid.
 *  XXX This really should use import/export interface!!!  Or be part of it.
 */
void
label_edited_solid(
	int *num_lines,
	point_t *lines,
	struct rt_point_labels	pl[],
	int			max_pl,
	const mat_t		xform,
	struct rt_db_internal	*ip)
{
	register int	i;
	point_t		work;
	point_t		pos_view;
	int		npl = 0;

	RT_CK_DB_INTERNAL( ip );

	switch( ip->idb_type )  {

#define	POINT_LABEL( _pt, _char )	{ \
	VMOVE( pl[npl].pt, _pt ); \
	pl[npl].str[0] = _char; \
	pl[npl++].str[1] = '\0'; }

#define	POINT_LABEL_STR( _pt, _str )	{ \
	VMOVE( pl[npl].pt, _pt ); \
	strncpy( pl[npl++].str, _str, sizeof(pl[0].str)-1 ); }

	case ID_ARB8:
		{
			struct rt_arb_internal *arb=
				(struct rt_arb_internal *)es_int.idb_ptr;
			RT_ARB_CK_MAGIC( arb );
			switch( es_type )
			{
				case ARB8:
					for( i=0 ; i<8 ; i++ )
					{
						MAT4X3PNT( pos_view, xform, arb->pt[i] );
						POINT_LABEL( pos_view, i+'1' );
					}
					break;
				case ARB7:
					for( i=0 ; i<7 ; i++ )
					{
						MAT4X3PNT( pos_view, xform, arb->pt[i] );
						POINT_LABEL( pos_view, i+'1' );
					}
					break;
				case ARB6:
					for( i=0 ; i<5 ; i++ )
					{
						MAT4X3PNT( pos_view, xform, arb->pt[i] );
						POINT_LABEL( pos_view, i+'1' );
					}
					MAT4X3PNT( pos_view, xform, arb->pt[6] );
					POINT_LABEL( pos_view, '6' );
					break;
				case ARB5:
					for( i=0 ; i<5 ; i++ )
					{
						MAT4X3PNT( pos_view, xform, arb->pt[i] );
						POINT_LABEL( pos_view, i+'1' );
					}
					break;
				case ARB4:
					for( i=0 ; i<3 ; i++ )
					{
						MAT4X3PNT( pos_view, xform, arb->pt[i] );
						POINT_LABEL( pos_view, i+'1' );
					}
					MAT4X3PNT( pos_view, xform, arb->pt[4] );
					POINT_LABEL( pos_view, '4' );
					break;
			}
		}
		break;
	case ID_TGC:
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;
			RT_TGC_CK_MAGIC(tgc);
			MAT4X3PNT( pos_view, xform, tgc->v );
			POINT_LABEL( pos_view, 'V' );

			VADD2( work, tgc->v, tgc->a );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'A' );

			VADD2( work, tgc->v, tgc->b );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'B' );

			VADD3( work, tgc->v, tgc->h, tgc->c );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'C' );

			VADD3( work, tgc->v, tgc->h, tgc->d );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'D' );
		}
		break;

	case ID_ELL:
		{
			point_t	work;
			point_t	pos_view;
			struct rt_ell_internal	*ell = 
				(struct rt_ell_internal *)es_int.idb_ptr;
			RT_ELL_CK_MAGIC(ell);

			MAT4X3PNT( pos_view, xform, ell->v );
			POINT_LABEL( pos_view, 'V' );

			VADD2( work, ell->v, ell->a );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'A' );

			VADD2( work, ell->v, ell->b );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'B' );

			VADD2( work, ell->v, ell->c );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'C' );
		}
		break;

	case ID_SUPERELL:
		{
			point_t	work;
			point_t	pos_view;
			struct rt_superell_internal	*superell = 
				(struct rt_superell_internal *)es_int.idb_ptr;
			RT_SUPERELL_CK_MAGIC(superell);

			MAT4X3PNT( pos_view, xform, superell->v );
			POINT_LABEL( pos_view, 'V' );

			VADD2( work, superell->v, superell->a );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'A' );

			VADD2( work, superell->v, superell->b );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'B' );

			VADD2( work, superell->v, superell->c );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'C' );
		}
		break;

	case ID_TOR:
		{
			struct rt_tor_internal	*tor = 
				(struct rt_tor_internal *)es_int.idb_ptr;
			fastf_t	r3, r4;
			vect_t	adir;
			RT_TOR_CK_MAGIC(tor);

			bn_vec_ortho( adir, tor->h );

			MAT4X3PNT( pos_view, xform, tor->v );
			POINT_LABEL( pos_view, 'V' );

			r3 = tor->r_a - tor->r_h;
			VJOIN1( work, tor->v, r3, adir );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'I' );

			r4 = tor->r_a + tor->r_h;
			VJOIN1( work, tor->v, r4, adir );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'O' );

			VJOIN1( work, tor->v, tor->r_a, adir );
			VADD2( work, work, tor->h );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'H' );
		}
		break;

	case ID_RPC:
		{
			struct rt_rpc_internal	*rpc = 
				(struct rt_rpc_internal *)es_int.idb_ptr;
			vect_t	Ru;

			RT_RPC_CK_MAGIC(rpc);
			MAT4X3PNT( pos_view, xform, rpc->rpc_V );
			POINT_LABEL( pos_view, 'V' );

			VADD2( work, rpc->rpc_V, rpc->rpc_B );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'B' );

			VADD2( work, rpc->rpc_V, rpc->rpc_H );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'H' );

			VCROSS( Ru, rpc->rpc_B, rpc->rpc_H );
			VUNITIZE( Ru );
			VSCALE( Ru, Ru, rpc->rpc_r );
			VADD2( work, rpc->rpc_V, Ru );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'r' );
		}
		break;

	case ID_PARTICLE:
		{
			struct rt_part_internal	*part =
				(struct rt_part_internal *)es_int.idb_ptr;
			vect_t	Ru, ortho;

			RT_PART_CK_MAGIC(part);
			MAT4X3PNT( pos_view, xform, part->part_V );
			POINT_LABEL( pos_view, 'V' );

			VADD2( work, part->part_V, part->part_H );
                        MAT4X3PNT(pos_view, xform, work);
                        POINT_LABEL( pos_view, 'H' );

			VMOVE( Ru, part->part_H );
			VUNITIZE( Ru );
			bn_vec_ortho( ortho, Ru );
			VSCALE( work, ortho, part->part_vrad );
			VADD2( work, part->part_V, work );
                        MAT4X3PNT( pos_view, xform, work );
                        POINT_LABEL( pos_view, 'v' );

			VSCALE( work, ortho, part->part_hrad );
			VADD3( work, part->part_V, part->part_H, work );
                        MAT4X3PNT( pos_view, xform, work );
                        POINT_LABEL( pos_view, 'h' );
		}
		break;

	case ID_RHC:
		{
			struct rt_rhc_internal	*rhc = 
				(struct rt_rhc_internal *)es_int.idb_ptr;
			vect_t	Ru;

			RT_RHC_CK_MAGIC(rhc);
			MAT4X3PNT( pos_view, xform, rhc->rhc_V );
			POINT_LABEL( pos_view, 'V' );

			VADD2( work, rhc->rhc_V, rhc->rhc_B );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'B' );

			VADD2( work, rhc->rhc_V, rhc->rhc_H );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'H' );

			VCROSS( Ru, rhc->rhc_B, rhc->rhc_H );
			VUNITIZE( Ru );
			VSCALE( Ru, Ru, rhc->rhc_r );
			VADD2( work, rhc->rhc_V, Ru );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'r' );

			VMOVE( work, rhc->rhc_B );
			VUNITIZE( work );
			VSCALE( work, work,
				MAGNITUDE(rhc->rhc_B) + rhc->rhc_c );
			VADD2( work, work, rhc->rhc_V );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'c' );
		}
		break;

	case ID_EPA:
		{
			struct rt_epa_internal	*epa = 
				(struct rt_epa_internal *)es_int.idb_ptr;
			vect_t	A, B;

			RT_EPA_CK_MAGIC(epa);
			MAT4X3PNT( pos_view, xform, epa->epa_V );
			POINT_LABEL( pos_view, 'V' );

			VADD2( work, epa->epa_V, epa->epa_H );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'H' );

			VSCALE( A, epa->epa_Au, epa->epa_r1 );
			VADD2( work, epa->epa_V, A );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'A' );

			VCROSS( B, epa->epa_Au, epa->epa_H );
			VUNITIZE( B );
			VSCALE( B, B, epa->epa_r2 );
			VADD2( work, epa->epa_V, B );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'B' );
		}
		break;

	case ID_EHY:
		{
			struct rt_ehy_internal	*ehy = 
				(struct rt_ehy_internal *)es_int.idb_ptr;
			vect_t	A, B;

			RT_EHY_CK_MAGIC(ehy);
			MAT4X3PNT( pos_view, xform, ehy->ehy_V );
			POINT_LABEL( pos_view, 'V' );

			VADD2( work, ehy->ehy_V, ehy->ehy_H );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'H' );

			VSCALE( A, ehy->ehy_Au, ehy->ehy_r1 );
			VADD2( work, ehy->ehy_V, A );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'A' );

			VCROSS( B, ehy->ehy_Au, ehy->ehy_H );
			VUNITIZE( B );
			VSCALE( B, B, ehy->ehy_r2 );
			VADD2( work, ehy->ehy_V, B );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'B' );

			VMOVE( work, ehy->ehy_H );
			VUNITIZE( work );
			VSCALE( work, work,
				MAGNITUDE(ehy->ehy_H) + ehy->ehy_c );
			VADD2( work, ehy->ehy_V, work );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'c' );
		}
		break;

	case ID_ETO:
		{
			struct rt_eto_internal	*eto = 
				(struct rt_eto_internal *)es_int.idb_ptr;
			fastf_t	ch, cv, dh, dv, cmag, phi;
			vect_t	Au, Nu;

			RT_ETO_CK_MAGIC(eto);

			MAT4X3PNT( pos_view, xform, eto->eto_V );
			POINT_LABEL( pos_view, 'V' );

			VMOVE(Nu, eto->eto_N);
			VUNITIZE(Nu);
			bn_vec_ortho( Au, Nu );
			VUNITIZE(Au);

			cmag = MAGNITUDE(eto->eto_C);
			/* get horizontal and vertical components of C and Rd */
			cv = VDOT( eto->eto_C, Nu );
			ch = sqrt( cmag*cmag - cv*cv );
			/* angle between C and Nu */
			phi = acos( cv / cmag );
			dv = -eto->eto_rd * sin(phi);
			dh = eto->eto_rd * cos(phi);

			VJOIN2(work, eto->eto_V, eto->eto_r+ch, Au, cv, Nu);
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'C' );

			VJOIN2(work, eto->eto_V, eto->eto_r+dh, Au, dv, Nu);
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'D' );

			VJOIN1(work, eto->eto_V, eto->eto_r, Au);
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'r' );
		}
		break;

	case ID_ARS:
		{
			register struct rt_ars_internal *ars=
				(struct rt_ars_internal *)es_int.idb_ptr;

			RT_ARS_CK_MAGIC( ars );

			MAT4X3PNT(pos_view, xform, ars->curves[0] )

			if( es_ars_crv >= 0 && es_ars_col >= 0 )
			{
				point_t work;
				point_t ars_pt;

				VMOVE( work, &ars->curves[es_ars_crv][es_ars_col*3] );
				MAT4X3PNT(ars_pt, xform, work);
				POINT_LABEL_STR( ars_pt, "pt" );
			}
		}
		POINT_LABEL( pos_view, 'V' );
		break;

	case ID_BSPLINE:
		{
			register struct rt_nurb_internal *sip =
				(struct rt_nurb_internal *) es_int.idb_ptr;
			register struct face_g_snurb	*surf;
			register fastf_t	*fp;

			RT_NURB_CK_MAGIC(sip);
			surf = sip->srfs[spl_surfno];
			NMG_CK_SNURB(surf);
			fp = &RT_NURB_GET_CONTROL_POINT( surf, spl_ui, spl_vi );
			MAT4X3PNT(pos_view, xform, fp);
			POINT_LABEL( pos_view, 'V' );

			fp = &RT_NURB_GET_CONTROL_POINT( surf, 0, 0 );
			MAT4X3PNT(pos_view, xform, fp);
			POINT_LABEL_STR( pos_view, " 0,0" );
			fp = &RT_NURB_GET_CONTROL_POINT( surf, 0, surf->s_size[1]-1 );
			MAT4X3PNT(pos_view, xform, fp);
			POINT_LABEL_STR( pos_view, " 0,u" );
			fp = &RT_NURB_GET_CONTROL_POINT( surf, surf->s_size[0]-1, 0 );
			MAT4X3PNT(pos_view, xform, fp);
			POINT_LABEL_STR( pos_view, " v,0" );
			fp = &RT_NURB_GET_CONTROL_POINT( surf, surf->s_size[0]-1, surf->s_size[1]-1 );
			MAT4X3PNT(pos_view, xform, fp);
			POINT_LABEL_STR( pos_view, " u,v" );
		}
		break;
	case ID_NMG:
		/* New way only */
		{
#ifndef NO_MAGIC_CHECKING
			register struct model *m =
				(struct model *) es_int.idb_ptr;
			NMG_CK_MODEL(m);
#endif

			if( es_eu )  {
				point_t	cent;
				NMG_CK_EDGEUSE(es_eu);
				VADD2SCALE( cent,
					es_eu->vu_p->v_p->vg_p->coord,
					es_eu->eumate_p->vu_p->v_p->vg_p->coord,
					0.5 );
				MAT4X3PNT(pos_view, xform, cent);
				POINT_LABEL_STR( pos_view, " eu" );
			}
		}
		break;
	case ID_PIPE:
		{
#ifndef NO_MAGIC_CHECKING
			register struct rt_pipe_internal *pipe =
				(struct rt_pipe_internal *)es_int.idb_ptr;

			RT_PIPE_CK_MAGIC( pipe );
#endif

			if( es_pipept ) {
				BU_CKMAG( es_pipept, WDB_PIPESEG_MAGIC, "wdb_pipept" );

				MAT4X3PNT(pos_view, xform, es_pipept->pp_coord);
				POINT_LABEL_STR( pos_view, "pt" );
			}
		}
		break;
	case ID_CLINE:
		{
			register struct rt_cline_internal *cli = 
				(struct rt_cline_internal *)es_int.idb_ptr;
			point_t work1;

			RT_CLINE_CK_MAGIC( cli );

			MAT4X3PNT( pos_view, xform, cli->v );
			POINT_LABEL( pos_view, 'V' );

			VADD2( work1, cli->v, cli->h );
			MAT4X3PNT( pos_view, xform, work1 );
			POINT_LABEL( pos_view, 'H' );
		}
		break;
	case ID_BOT:
		{
			register struct rt_bot_internal *bot =
				(struct rt_bot_internal *)es_int.idb_ptr;

			RT_BOT_CK_MAGIC( bot );

			if( bot_verts[2] > -1 &&
				bot_verts[1] > -1 &&
				bot_verts[0] > -1 )
			{
				/* editing a face */
				point_t mid_pt;
				point_t p1, p2, p3;
				fastf_t one_third=1.0/3.0;

				MAT4X3PNT( p1, xform, &bot->vertices[bot_verts[0]*3] );
				MAT4X3PNT( p2, xform, &bot->vertices[bot_verts[1]*3] );
				MAT4X3PNT( p3, xform, &bot->vertices[bot_verts[2]*3] );
				VADD3( mid_pt, p1, p2, p3 );

				VSCALE( mid_pt, mid_pt, one_third );
				
				*num_lines = 3;
				VMOVE( lines[0], mid_pt );
				VMOVE( lines[1], p1 );
				VMOVE( lines[2], mid_pt );
				VMOVE( lines[3], p2 );
				VMOVE( lines[4], mid_pt );
				VMOVE( lines[5], p3 );
			}
			else if( bot_verts[1] > -1 && bot_verts[0] > -1 )
			{
				/* editing an edge */
				point_t mid_pt;

				VBLEND2( mid_pt, 0.5, &bot->vertices[bot_verts[0]*3],
						 0.5, &bot->vertices[bot_verts[1]*3] );

				MAT4X3PNT( pos_view, xform, mid_pt );
				POINT_LABEL_STR( pos_view, "edge" );
			}
			if( bot_verts[0] > -1 )
			{
				/* editing something, always label the vertex (this is the keypoint) */
				MAT4X3PNT( pos_view, xform, &bot->vertices[bot_verts[0]*3] );
				POINT_LABEL_STR( pos_view, "pt" );
			}
		}
		break;
	}

	pl[npl].str[0] = '\0';	/* Mark ending */
}

/* -------------------------------- */
/*
 *			R T _ A R B _ C A L C _ P L A N E S
 *
 *	Calculate the plane (face) equations for an arb
 *	output previously went to es_peqn[i].
 *
 *  Returns -
 *	-1	Failure
 *	 0	OK
 */
int
rt_arb_calc_planes(
	plane_t			planes[6],
	struct rt_arb_internal	*arb,
	int			type,
	const struct bn_tol	*tol)
{
	register int i, p1, p2, p3;

	RT_ARB_CK_MAGIC( arb);
	BN_CK_TOL( tol );

	type -= 4;	/* ARB4 at location 0, ARB5 at 1, etc */

	for(i=0; i<6; i++) {
		if(arb_faces[type][i*4] == -1)
			break;	/* faces are done */
		p1 = arb_faces[type][i*4];
		p2 = arb_faces[type][i*4+1];
		p3 = arb_faces[type][i*4+2];

		if( bn_mk_plane_3pts( planes[i],
		    arb->pt[p1], arb->pt[p2], arb->pt[p3], tol ) < 0 )  {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "rt_arb_calc_planes: No eqn for face %d%d%d%d\n",
				p1+1, p2+1, p3+1, arb_faces[type][i*4+3]+1);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			bu_vls_free(&tmp_vls);
		  return -1;
		}
	}
	return 0;
}

/* -------------------------------- */
void
sedit_vpick( point_t v_pos )
{
	point_t	m_pos;
	int	surfno, u, v;

	MAT4X3PNT( m_pos, view_state->vs_objview2model, v_pos );

	if( nurb_closest2d( &surfno, &u, &v,
	    (struct rt_nurb_internal *)es_int.idb_ptr,
	    m_pos, view_state->vs_model2objview ) >= 0 )  {
		spl_surfno = surfno;
		spl_ui = u;
		spl_vi = v;
		get_solid_keypoint( es_keypoint, &es_keytag, &es_int, es_mat );
	}
	chg_state( ST_S_VPICK, ST_S_EDIT, "Vertex Pick Complete");
	view_state->vs_flag = 1;
}

#define DIST2D(P0, P1)	sqrt(	((P1)[X] - (P0)[X])*((P1)[X] - (P0)[X]) + \
				((P1)[Y] - (P0)[Y])*((P1)[Y] - (P0)[Y]) )

#define DIST3D(P0, P1)	sqrt(	((P1)[X] - (P0)[X])*((P1)[X] - (P0)[X]) + \
				((P1)[Y] - (P0)[Y])*((P1)[Y] - (P0)[Y]) + \
				((P1)[Z] - (P0)[Z])*((P1)[Z] - (P0)[Z]) )

/*
 *	C L O S E S T 3 D
 *
 *	Given a vlist pointer (vhead) to point coordinates and a reference
 *	point (ref_pt), pass back in "closest_pt" the coordinates of the
 *	point nearest the reference point in 3 space.
 *
 */
int
rt_vl_closest3d(struct bu_list *vhead, fastf_t *ref_pt, fastf_t *closest_pt)
{
	fastf_t		dist, cur_dist;
	pointp_t	c_pt;
	struct rt_vlist	*cur_vp;
	
	if (vhead == BU_LIST_NULL || BU_LIST_IS_EMPTY(vhead))
		return(1);	/* fail */

	/* initialize smallest distance using 1st point in list */
	cur_vp = BU_LIST_FIRST(rt_vlist, vhead);
	dist = DIST3D(ref_pt, cur_vp->pt[0]);
	c_pt = cur_vp->pt[0];

	for (BU_LIST_FOR(cur_vp, rt_vlist, vhead)) {
		register int	i;
		register int	nused = cur_vp->nused;
		register point_t *cur_pt = cur_vp->pt;
		
		for (i = 0; i < nused; i++) {
			cur_dist = DIST3D(ref_pt, cur_pt[i]);
			if (cur_dist < dist) {
				dist = cur_dist;
				c_pt = cur_pt[i];
			}
		}
	}
	VMOVE(closest_pt, c_pt);
	return(0);	/* success */
}

/*
 *	C L O S E S T 2 D
 *
 *	Given a pointer (vhead) to vlist point coordinates, a reference
 *	point (ref_pt), and a transformation matrix (mat), pass back in
 *	"closest_pt" the original, untransformed 3 space coordinates of
 *	the point nearest the reference point after all points have been
 *	transformed into 2 space projection plane coordinates.
 */
int
rt_vl_closest2d(struct bu_list *vhead, fastf_t *ref_pt, fastf_t *mat, fastf_t *closest_pt)
{
	fastf_t		dist, cur_dist;
	point_t		cur_pt2d, ref_pt2d;
	pointp_t	c_pt;
	struct rt_vlist	*cur_vp;
	
	if (vhead == BU_LIST_NULL || BU_LIST_IS_EMPTY(vhead))
		return(1);	/* fail */

	/* transform reference point to 2d */
	MAT4X3PNT(ref_pt2d, mat, ref_pt);

	/* initialize smallest distance using 1st point in list */
	cur_vp = BU_LIST_FIRST(rt_vlist, vhead);
	MAT4X3PNT(cur_pt2d, mat, cur_vp->pt[0]);
	dist = DIST2D(ref_pt2d, cur_pt2d);
	c_pt = cur_vp->pt[0];

	for (BU_LIST_FOR(cur_vp, rt_vlist, vhead)) {
		register int	i;
		register int	nused = cur_vp->nused;
		register point_t *cur_pt = cur_vp->pt;
		
		for (i = 0; i < nused; i++) {
			MAT4X3PNT(cur_pt2d, mat, cur_pt[i]);
			cur_dist = DIST2D(ref_pt2d, cur_pt2d);
			if (cur_dist < dist) {
				dist = cur_dist;
				c_pt = cur_pt[i];
			}
		}
	}
	VMOVE(closest_pt, c_pt);
	return(0);	/* success */
}

/*
 *				N U R B _ C L O S E S T 3 D
 *
 *	Given a vlist pointer (vhead) to point coordinates and a reference
 *	point (ref_pt), pass back in "closest_pt" the coordinates of the
 *	point nearest the reference point in 3 space.
 *
 */
int
nurb_closest3d(int *surface, int *uval, int *vval, const struct rt_nurb_internal *spl, const fastf_t *ref_pt)
{
	struct face_g_snurb	*srf;
	fastf_t		*mesh;
	fastf_t		d;
	fastf_t		c_dist;		/* closest dist so far */
	int		c_surfno;
	int		c_u, c_v;
	int		u, v;
	int		i;

	RT_NURB_CK_MAGIC(spl);

	c_dist = INFINITY;
	c_surfno = c_u = c_v = -1;

	for( i = 0; i < spl->nsrf; i++ )  {
		int	advance;

		srf = spl->srfs[i];
		NMG_CK_SNURB(srf);
		mesh = srf->ctl_points;
		advance = RT_NURB_EXTRACT_COORDS(srf->pt_type);

		for( v = 0; v < srf->s_size[0]; v++ )  {
			for( u = 0; u < srf->s_size[1]; u++ )  {
				/* XXX 4-tuples? */
				d = DIST3D(ref_pt, mesh);
				if (d < c_dist)  {
					c_dist = d;
					c_surfno = i;
					c_u = u;
					c_v = v;
				}
				mesh += advance;
			}
		}
	}
	if( c_surfno < 0 )  return  -1;		/* FAIL */
	*surface = c_surfno;
	*uval = c_u;
	*vval = c_v;

	return(0);				/* success */
}

/*
 *				N U R B _ C L O S E S T 2 D
 *
 *	Given a pointer (vhead) to vlist point coordinates, a reference
 *	point (ref_pt), and a transformation matrix (mat), pass back in
 *	"closest_pt" the original, untransformed 3 space coordinates of
 *	the point nearest the reference point after all points have been
 *	transformed into 2 space projection plane coordinates.
 */
int
nurb_closest2d(
	int				*surface,
	int				*uval,
	int				*vval,
	const struct rt_nurb_internal	*spl,
	const point_t			ref_pt,
	const mat_t			mat)
{
	struct face_g_snurb	*srf;
	point_t		ref_2d;
	fastf_t		*mesh;
	fastf_t		d;
	fastf_t		c_dist;		/* closest dist so far */
	int		c_surfno;
	int		c_u, c_v;
	int		u, v;
	int		i;

	RT_NURB_CK_MAGIC(spl);

	c_dist = INFINITY;
	c_surfno = c_u = c_v = -1;

	/* transform reference point to 2d */
	MAT4X3PNT(ref_2d, mat, ref_pt);

	for( i = 0; i < spl->nsrf; i++ )  {
		int	advance;

		srf = spl->srfs[i];
		NMG_CK_SNURB(srf);
		mesh = srf->ctl_points;
		advance = RT_NURB_EXTRACT_COORDS(srf->pt_type);

		for( v = 0; v < srf->s_size[0]; v++ )  {
			for( u = 0; u < srf->s_size[1]; u++ )  {
				point_t	cur;
				/* XXX 4-tuples? */
				MAT4X3PNT( cur, mat, mesh );
				d = DIST2D(ref_2d, cur);
				if (d < c_dist)  {
					c_dist = d;
					c_surfno = i;
					c_u = u;
					c_v = v;
				}
				mesh += advance;
			}
		}
	}
	if( c_surfno < 0 )  return  -1;		/* FAIL */
	*surface = c_surfno;
	*uval = c_u;
	*vval = c_v;

	return(0);				/* success */
}


int
f_keypoint(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  CHECK_DBI_NULL;

  if(argc < 1 || 4 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help keypoint");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
  
  if ((state != ST_S_EDIT) && (state != ST_O_EDIT)) {
    state_err("keypoint assignment");
    return TCL_ERROR;
  }

  switch (--argc) {
  case 0:
    {
      struct bu_vls tmp_vls;
      point_t key;


      VSCALE( key, es_keypoint, base2local );
      bu_vls_init(&tmp_vls);
      bu_vls_printf(&tmp_vls, "%s (%g, %g, %g)\n", es_keytag, V3ARGS(key));
      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
      bu_vls_free(&tmp_vls);
    }

    break;
  case 3:
    VSET(es_keypoint,
	 atof( argv[1] ) * local2base,
	 atof( argv[2] ) * local2base,
	 atof( argv[3] ) * local2base);
    es_keytag = "user-specified";
    es_keyfixed = 1;
    break;
  case 1:
    if (strcmp(argv[1], "reset") == 0) {
      es_keytag = "";
      es_keyfixed = 0;
      get_solid_keypoint(es_keypoint, &es_keytag,
			 &es_int, es_mat);
      break;
    }
  default:
    Tcl_AppendResult(interp, "Usage: 'keypoint [<x y z> | reset]'\n", (char *)NULL);
    return TCL_ERROR;
  }

  view_state->vs_flag = 1;
  return TCL_OK;
}

int
f_get_sedit_menus(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  struct menu_item *mip = (struct menu_item *)NULL;
  struct bu_vls vls;

  if(state != ST_S_EDIT)
    return TCL_ERROR;

  bu_vls_init(&vls);

  switch( es_int.idb_type ) {
  case ID_ARB8:
    {
      struct bu_vls vls2;

      bu_vls_init(&vls2);

      /* title */
      bu_vls_printf(&vls, "{{ARB MENU} {}}");

      /* build "move edge" menu */
      mip = which_menu[es_type-4];
      /* submenu title */
      bu_vls_printf(&vls2, "{{%s} {}}", mip->menu_string);
      for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
	bu_vls_printf(&vls2, " {{%s} {}}", mip->menu_string);

      bu_vls_printf(&vls, " {{%s} {%s}}", cntrl_menu[1].menu_string, bu_vls_addr(&vls2));
      bu_vls_trunc(&vls2, 0);

      /* build "move face" menu */
      mip = which_menu[es_type+1];
      /* submenu title */
      bu_vls_printf(&vls2, "{{%s} {}}", mip->menu_string);
      for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
	bu_vls_printf(&vls2, " {{%s} {}}", mip->menu_string);

      bu_vls_printf(&vls, " {{%s} {%s}}", cntrl_menu[2].menu_string, bu_vls_addr(&vls2));
      bu_vls_trunc(&vls2, 0);

      /* build "rotate face" menu */
      mip = which_menu[es_type+6];
      /* submenu title */
      bu_vls_printf(&vls2, "{{%s} {}}", mip->menu_string);
      for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
	bu_vls_printf(&vls2, " {{%s} {}}", mip->menu_string);

      bu_vls_printf(&vls, " {{%s} {%s}}", cntrl_menu[3].menu_string, bu_vls_addr(&vls2));
      bu_vls_free(&vls2);
    }

    break;
  case ID_ARS:
    {
      struct bu_vls vls2;

      /* build ARS PICK MENU Tcl list */
      bu_vls_init(&vls2);

      mip = ars_pick_menu;
      /* title */
      bu_vls_printf(&vls2, " {{%s} {}}", mip->menu_string);
      for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
	bu_vls_printf(&vls2, " {{%s} {}}", mip->menu_string);

      mip = ars_menu;
      /* title */
      bu_vls_printf(&vls, " {{%s} {}}", mip->menu_string);

      /* pick vertex menu */
      bu_vls_printf(&vls, " {{%s} {%s}}", (++mip)->menu_string,
		    bu_vls_addr(&vls2));

      for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
	bu_vls_printf(&vls, " {{%s} {}}", mip->menu_string);

      bu_vls_free(&vls2);
    }

    break;
  default:
    switch( es_int.idb_type ) {
    case ID_TGC:
      mip = tgc_menu;
      break;
    case ID_TOR:
      mip = tor_menu;
      break;
    case ID_ELL:
      mip = ell_menu;
      break;
    case ID_SUPERELL:
      mip = superell_menu;
      break;
    case ID_BSPLINE:
      mip = spline_menu;
      break;
    case ID_RPC:
      mip = rpc_menu;
      break;
    case ID_RHC:
      mip = rhc_menu;
      break;
    case ID_EPA:
      mip = epa_menu;
      break;
    case ID_EHY:
      mip = ehy_menu;
      break;
    case ID_ETO:
      mip = eto_menu;
      break;
    case ID_NMG:
      mip = nmg_menu;
      break;
    case ID_PIPE:
      mip = pipe_menu;
      break;
    case ID_VOL:
      mip = vol_menu;
      break;
    case ID_EBM:
      mip = ebm_menu;
      break;
    case ID_DSP:
      mip = dsp_menu;
      break;
    case ID_PARTICLE:
      mip = part_menu;
      break;
   case ID_BOT:
      mip = bot_menu;
      break;
   case ID_EXTRUDE:
      mip = extr_menu;
      break;
   case ID_CLINE:
      mip = cline_menu;
      break;
    }

    if(mip == (struct menu_item *)NULL)
      break;

    /* title */
    bu_vls_printf(&vls, " {{%s} {}}", mip->menu_string);

    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {{%s} {}}", mip->menu_string);

    break;
  }

  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)0);
  bu_vls_free(&vls);

  return TCL_OK;
}

int
f_get_sedit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  int status;
  struct rt_db_internal ces_int;
  Tcl_Obj *pto;
  Tcl_Obj *pnto;

  if(argc < 1 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helpdevel get_sed");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(state != ST_S_EDIT){
    Tcl_AppendResult(interp, "get_sed: must be in solid edit state", (char *)0);
    return TCL_ERROR;
  }

  if(argc == 1){
    /* get solid type and parameters */
    RT_CK_DB_INTERNAL(&es_int);
    RT_CK_FUNCTAB(es_int.idb_meth);
    status = es_int.idb_meth->ft_tclget(interp, &es_int, (char *)0);
    pto = Tcl_GetObjResult(interp);

    pnto = Tcl_NewObj();
    /* insert solid name, type and parameters */
    Tcl_AppendStringsToObj(pnto, LAST_SOLID(illump)->d_namep, " ",
			   Tcl_GetStringFromObj(pto, (int *)0), (char *)0);

    Tcl_SetObjResult(interp, pnto);
    return status;
  }

  if(argv[1][0] != '-' || argv[1][1] != 'c'){
    Tcl_AppendResult(interp, "Usage: get_sed [-c]", (char *)0);
    return TCL_ERROR;
  }

  RT_INIT_DB_INTERNAL(&ces_int);
  /* apply matrices along the path */
  transform_editing_solid(&ces_int, es_mat, &es_int, 0);

  /* get solid type and parameters */
  RT_CK_DB_INTERNAL(&ces_int);
  RT_CK_FUNCTAB(ces_int.idb_meth);
  status = ces_int.idb_meth->ft_tclget(interp, &ces_int, (char *)0);
  pto = Tcl_GetObjResult(interp);

  pnto = Tcl_NewObj();
  /* insert full pathname */
  {
  	struct bu_vls str;
  	bu_vls_init(&str);
  	db_path_to_vls(&str, &illump->s_fullpath);
        Tcl_AppendStringsToObj(pnto, bu_vls_addr(&str), NULL );
  	bu_vls_free(&str);
  }

  /* insert solid type and parameters */
  Tcl_AppendStringsToObj(pnto, " ", Tcl_GetStringFromObj(pto, (int *)0), (char *)0);

  Tcl_SetObjResult(interp, pnto);

  rt_db_free_internal( &ces_int, &rt_uniresource );

  return status;
}

int
f_put_sedit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  register const struct rt_functab *ftp;
  long save_magic;
  int context;

  /*XXX needs better argument checking */
  if(argc < 6){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helpdevel put_sed");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(state != ST_S_EDIT){
    Tcl_AppendResult(interp, "put_sed: must be in solid edit state", (char *)0);
    return TCL_ERROR;
  }

  /* look for -c */
  if(argv[1][0] == '-' && argv[1][1] == 'c'){
    context = 1;
    --argc;
    ++argv;
  } else
    context = 0;

  ftp = rt_get_functab_by_label( argv[1] );
  if( ftp == NULL ||
      ftp->ft_parsetab == (struct bu_structparse *)NULL) {
    Tcl_AppendResult( interp, "put_sed: ", argv[1],
		      " object type is not supported for db get",
		      (char *)0 );
    return TCL_ERROR;
  }

  RT_CK_FUNCTAB(es_int.idb_meth);
  if( es_int.idb_meth != ftp ) {
    Tcl_AppendResult( interp,
		      "put_sed: idb_meth type mismatch",
		      (char *)0 );
  }

  save_magic = *((long *)es_int.idb_ptr);
  *((long *)es_int.idb_ptr) = ftp->ft_internal_magic;
  if( bu_structparse_argv(interp, argc-2, argv+2, ftp->ft_parsetab,
			  (char *)es_int.idb_ptr )==TCL_ERROR ) {
    return TCL_ERROR;
  }
  *((long *)es_int.idb_ptr) = save_magic;

  if(context)
    transform_editing_solid(&es_int, es_invmat, &es_int, 1);

  /* must re-calculate the face plane equations for arbs */
  if( es_int.idb_type == ID_ARB8 ){
    struct rt_arb_internal *arb;

    arb = (struct rt_arb_internal *)es_int.idb_ptr;
    RT_ARB_CK_MAGIC( arb );

    (void)rt_arb_calc_planes( es_peqn , arb , es_type , &mged_tol );
  }

  if(!es_keyfixed)
    get_solid_keypoint(es_keypoint, &es_keytag, &es_int, es_mat);

  set_e_axes_pos(0);
  replot_editing_solid();

  return TCL_OK;
}

/*
 *			F _ S E D I T _ R E S E T
 */
int
f_sedit_reset(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  struct bu_vls vls;

  if(state != ST_S_EDIT)
    return TCL_ERROR;

  if(argc != 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helpdevel sed_reset");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* free old copy */
  rt_db_free_internal( &es_int, &rt_uniresource );

  /* reset */
  es_pipept = (struct wdb_pipept *)NULL;
  es_s = (struct shell *)NULL;
  es_eu = (struct edgeuse *)NULL;

  /* read in a fresh copy */
  if( rt_db_get_internal( &es_int, LAST_SOLID(illump),
   dbip, NULL, &rt_uniresource ) < 0 )  {
    Tcl_AppendResult(interp, "sedit_reset(",
   			LAST_SOLID(illump)->d_namep,
		     "):  solid import failure\n", (char *)NULL);
    return TCL_ERROR;				/* FAIL */
  }
  RT_CK_DB_INTERNAL( &es_int );
  replot_editing_solid();

  /* Establish initial keypoint */
  es_keytag = "";
  get_solid_keypoint( es_keypoint, &es_keytag, &es_int, es_mat );

  /* Reset relevant variables */
  MAT_IDN(acc_rot_sol);
  VSETALL( edit_absolute_model_rotate, 0.0 );
  VSETALL( edit_absolute_object_rotate, 0.0 );
  VSETALL( edit_absolute_view_rotate, 0.0 );
  VSETALL( last_edit_absolute_model_rotate, 0.0 );
  VSETALL( last_edit_absolute_object_rotate, 0.0 );
  VSETALL( last_edit_absolute_view_rotate, 0.0 );
  VSETALL( edit_absolute_model_tran, 0.0 );
  VSETALL( edit_absolute_view_tran, 0.0 );
  VSETALL( last_edit_absolute_model_tran, 0.0 );
  VSETALL( last_edit_absolute_view_tran, 0.0 );
  edit_absolute_scale = 0.0;
  acc_sc_sol = 1.0;
  VSETALL( edit_rate_model_rotate, 0.0 );
  VSETALL( edit_rate_object_rotate, 0.0 );
  VSETALL( edit_rate_view_rotate, 0.0 );
  VSETALL( edit_rate_model_tran, 0.0 );
  VSETALL( edit_rate_view_tran, 0.0 );

  set_e_axes_pos(1);
  update_views = 1;

  /* active edit callback */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "active_edit_callback");
  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);

  return TCL_OK;
}

int
f_sedit_apply(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls vls;

	CHECK_DBI_NULL;

	if (not_state(ST_S_EDIT, "Primitive edit accept")) {
		Tcl_AppendResult(interp, "Must be in solid edit state!\n");
		return TCL_ERROR;
	}

	if (sedraw > 0)
		sedit();

	init_sedit_vars();
	(void)sedit_apply(0);

	/* active edit callback */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "active_edit_callback");
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_OK;
}

int
f_oedit_reset(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls vls;

	if (state != ST_O_EDIT)
		return TCL_ERROR;

	if (argc != 1) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel oed_reset");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	oedit_reject();
	init_oedit_guts();

	new_edit_mats();
	update_views = 1;

	/* active edit callback */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "active_edit_callback");
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_OK;
}

int
f_oedit_apply(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls	vls;
	char		*strp="";

	CHECK_DBI_NULL;
	oedit_apply( UP ); /* apply changes, but continue editing */

	/* Save aggregate path matrix */
	MAT_IDN(es_mat);
	pathHmat(illump, es_mat, illump->s_fullpath.fp_len-2);

	/* get the inverse matrix */
	bn_mat_inv(es_invmat, es_mat);

	get_solid_keypoint(es_keypoint, &strp, &es_int, es_mat);
	init_oedit_vars();
	new_edit_mats();
	update_views = 1;

	/* active edit callback */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "active_edit_callback");
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_OK;
}
@


11.190
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/edsol.c,v 11.189 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.189
log
@merge of ansi-6-0-branch into HEAD
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d30 5
a34 1
#include "conf.h"
@


11.188
log
@update copyright to include span through 2003
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.187 2003/08/06 12:26:21 jra Exp $ (BRL)";
d71 14
a84 12
static void	arb8_edge(), ars_ed(), ell_ed(), tgc_ed(), tor_ed(), spline_ed();
static void	nmg_ed(), pipe_ed(), vol_ed(), ebm_ed(), dsp_ed(), cline_ed(), bot_ed(), extr_ed();
static void	rpc_ed(), rhc_ed(), part_ed(), epa_ed(), ehy_ed(), eto_ed();
static void	arb7_edge(), arb6_edge(), arb5_edge(), arb4_point();
static void	arb8_mv_face(), arb7_mv_face(), arb6_mv_face();
static void	arb5_mv_face(), arb4_mv_face(), arb8_rot_face(), arb7_rot_face();
static void 	arb6_rot_face(), arb5_rot_face(), arb4_rot_face(), arb_control();
static void	init_sedit_vars(), init_oedit_vars(), init_oedit_guts();

void pscale();
void update_edit_absolute_tran();
void set_e_axes_pos();
a227 1

d230 4
d641 9
d677 1
a677 2
arb8_edge( arg )
int arg;
d690 1
a690 2
arb7_edge( arg )
int arg;
d708 1
a708 2
arb6_edge( arg )
int arg;
d731 1
a731 2
arb5_edge( arg )
int arg;
d749 1
a749 2
arb4_point( arg )
int arg;
d762 1
a762 1
bot_ed( arg )
d772 1
a772 2
ebm_ed( arg )
int arg;
d793 1
a793 2
dsp_ed( arg )
int arg;
d819 1
a819 2
cline_ed( arg )
int arg;
d826 1
a826 2
vol_ed( arg )
int arg;
d853 1
a853 2
pipe_ed( arg )
int arg;
d952 1
a952 2
tgc_ed( arg )
int arg;
d970 1
a970 2
tor_ed( arg )
int arg;
d979 1
a979 2
eto_ed( arg )
int arg;
d991 1
a991 2
rpc_ed( arg )
int arg;
d1000 1
a1000 2
part_ed( arg )
int arg;
d1009 1
a1009 2
rhc_ed( arg )
int arg;
d1018 1
a1018 2
epa_ed( arg )
int arg;
d1027 1
a1027 2
ehy_ed( arg )
int arg;
d1036 1
a1036 2
ell_ed( arg )
int arg;
d1045 1
a1045 2
arb8_mv_face( arg )
int arg;
d1058 1
a1058 2
arb7_mv_face( arg )
int arg;
d1071 1
a1071 2
arb6_mv_face( arg )
int arg;
d1084 1
a1084 2
arb5_mv_face( arg )
int arg;
d1097 1
a1097 2
arb4_mv_face( arg )
int arg;
d1110 1
a1110 2
arb8_rot_face( arg )
int arg;
d1121 1
a1121 2
arb7_rot_face( arg )
int arg;
d1132 1
a1132 2
arb6_rot_face( arg )
int arg;
d1143 1
a1143 2
arb5_rot_face( arg )
int arg;
d1154 1
a1154 2
arb4_rot_face( arg )
int arg;
d1165 1
a1165 2
arb_control( arg )
int arg;
d1174 1
a1174 2
ars_ed( arg )
int arg;
d1182 1
a1182 2
extr_ed( arg )
int arg;
d1188 6
d1197 1
a1197 2
spline_ed( arg )
int arg;
d1220 1
a1220 2
nmg_ed( arg )
int arg;
d1511 1
a1511 5
get_solid_keypoint( pt, strp, ip, mat )
point_t		pt;
char		**strp;
struct rt_db_internal	*ip;
mat_t		mat;
d1762 31
d2122 1
a2122 5
f_get_solid_keypoint(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d2132 2
a2133 2
set_e_axes_pos(both)
int both;    /* if(!both) then set only curr_e_axes_pos, otherwise
d2417 1
a2417 1
init_sedit_vars()
d2488 1
a2488 1
sedit_menu()  {
d2509 3
d2566 1
a2566 1
get_rotation_vertex()
d2611 1
a2611 2
get_file_name( str )
char *str;
d2660 1
a2660 3
dsp_scale(dsp, idx)
struct rt_dsp_internal *dsp;
int idx;
d2704 1
a2704 1
sedit()
d6074 1
a6074 2
sedit_trans(tvec)
vect_t tvec;
d6424 1
a6424 2
oedit_trans(tvec)
point_t tvec;
d6577 1
a6577 1
pscale()
d7244 67
d7507 1
a7507 1
init_oedit_guts()
d7565 1
a7565 1
init_oedit_vars()
d7615 1
a7615 1
void oedit_reject();
d7717 1
a7717 5
f_eqn(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d7781 1
a7781 2
sedit_apply(accept_flag)
     int	accept_flag;
d7928 1
a7928 4
mged_param(interp, argc, argvect)
Tcl_Interp *interp;
int argc;
vect_t argvect;
d8060 1
a8060 5
f_param(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d8278 25
d8771 1
a8771 3
rt_vl_closest3d(vhead, ref_pt, closest_pt)
struct bu_list	*vhead;
point_t		ref_pt, closest_pt;
d8812 1
a8812 4
rt_vl_closest2d(vhead, ref_pt, mat, closest_pt)
struct bu_list	*vhead;
point_t		ref_pt, closest_pt;
mat_t		mat;
d8858 1
a8858 6
nurb_closest3d(surface, uval, vval, spl, ref_pt )
int				*surface;
int				*uval;
int				*vval;
const struct rt_nurb_internal	*spl;
const point_t			ref_pt;
d8974 1
a8974 5
f_keypoint(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d9034 1
a9034 5
f_get_sedit_menus(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d9125 3
d9194 1
a9194 5
f_get_sedit(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d9268 1
a9268 5
f_put_sedit(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d9348 1
a9348 5
f_sedit_reset(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d9419 1
a9419 5
f_sedit_apply(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d9446 1
a9446 5
f_oedit_reset(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d9477 1
a9477 5
f_oedit_apply(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
@


11.187
log
@Mods to allow editing of BOT flags
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.186 2003/04/02 15:23:54 jra Exp $ (BRL)";
@


11.187.4.1
log
@merge from HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.188 2004/02/02 17:39:32 morrison Exp $ (BRL)";
@


11.187.4.2
log
@merge from head
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.187.4.1 2004/02/12 18:34:14 erikg Exp $ (BRL)";
@


11.186
log
@Added some const's to quiet the compiler
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.185 2002/11/04 19:25:45 jra Exp $ (BRL)";
d217 9
a225 8
#define MENU_EXTR_SCALE_H	102
#define MENU_EXTR_MOV_H		103
#define MENU_EXTR_ROT_H		104
#define MENU_EXTR_SKT_NAME	105
#define	MENU_CLINE_SCALE_H	106
#define	MENU_CLINE_MOVE_H	107
#define MENU_CLINE_SCALE_R	108
#define	MENU_CLINE_SCALE_T	109
d227 2
a228 2
#define MENU_TGC_SCALE_H_CD	110
#define	MENU_TGC_SCALE_H_V_AB	111
d630 1
d3160 49
@


11.186.2.1
log
@updated for merging
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.187 2003/08/06 12:26:21 jra Exp $ (BRL)";
d217 8
a224 9
#define MENU_BOT_FLAGS		102
#define MENU_EXTR_SCALE_H	103
#define MENU_EXTR_MOV_H		104
#define MENU_EXTR_ROT_H		105
#define MENU_EXTR_SKT_NAME	106
#define	MENU_CLINE_SCALE_H	107
#define	MENU_CLINE_MOVE_H	108
#define MENU_CLINE_SCALE_R	109
#define	MENU_CLINE_SCALE_T	110
d226 2
a227 2
#define MENU_TGC_SCALE_H_CD	111
#define	MENU_TGC_SCALE_H_V_AB	112
a628 1
	{ "Set flags", bot_ed, ECMD_BOT_FLAGS },
a3157 49
			}
		}
		break;
	case ECMD_BOT_FLAGS:
		{
			int ret_tcl;
			const char *dialog_result;
			char cur_settings[11];
			struct rt_bot_internal *bot =
				(struct rt_bot_internal *)es_int.idb_ptr;

			RT_BOT_CK_MAGIC( bot );

			strcpy( cur_settings, " { 0 0 }" );

			if( bot->bot_flags & RT_BOT_USE_NORMALS ) {
				cur_settings[3] = '1';
			}
			if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
				cur_settings[5] = '1';
			}

			ret_tcl = Tcl_VarEval( interp,
					       "cad_list_buts",
					       " .bot_list_flags ",
					       bu_vls_addr( &pathName ),
					       " _bot_flags_result ",
					       cur_settings,
					       " \"BOT Flags\"",
					       " \"Select the desired flags\"",
					       " { {Use vertex normals} {Use single precision ray-tracing} }",
					       " { {This selection indicates that surface normals at hit points should be interpolated from vertex normals} {This selection indicates that the prepped form of the BOT triangles should use sigle precision to save memory} } ",
					       (char *)NULL );
			if( ret_tcl != TCL_OK )
			{
				bu_log( "ERROR: cad_list_buts: %s\n", interp->result );
				break;
			}
			dialog_result = Tcl_GetVar( interp, "_bot_flags_result", TCL_GLOBAL_ONLY );

			if( dialog_result[0] == '1' ) {
				bot->bot_flags |= RT_BOT_USE_NORMALS;
			} else {
				bot->bot_flags &= ~RT_BOT_USE_NORMALS;
			}
			if( dialog_result[2] == '1' ) {
				bot->bot_flags |= RT_BOT_USE_FLOATS;
			} else {
				bot->bot_flags &= ~RT_BOT_USE_FLOATS;
@


11.185
log
@Two bugs fixed:
	BOT face thickness edit was scaling es_para (already scaled elsewhere)
	BOT face thickness edit was requiring three parameters to "p" command (only really needs one)
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.184 2002/09/26 19:50:23 jra Exp $ (BRL)";
d3031 1
a3031 1
			char *radio_result;
d3078 1
a3078 1
			char *radio_result;
d3166 1
a3166 1
			char *radio_result;
d3322 1
a3322 1
			char *sketch_name;
@


11.184
log
@Vertex picking for a BOT now reports vertex number picked
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.183 2002/08/20 17:08:23 jra Exp $ (BRL)";
d3131 1
a3131 1
					bot->thickness[i] = es_para[0] * local2base;
d3157 1
a3157 1
				bot->thickness[face_no] = es_para[0] * local2base;
d7840 1
a7840 1
  if( es_edflag == PSCALE || es_edflag == SSCALE )  {
@


11.183
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.181 2002/08/11 02:06:55 morrison Exp $ (BRL)";
d5816 1
a5816 1
	sprintf( tmp_msg, "picked point at (%g %g %g)\n", V3ARGS( &bot->vertices[tmp_vert*3] ) );
@


11.183.4.1
log
@sync to HEAD...
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/edsol.c,v 11.188 2004/02/02 17:39:32 morrison Exp $ (BRL)";
d217 8
a224 9
#define MENU_BOT_FLAGS		102
#define MENU_EXTR_SCALE_H	103
#define MENU_EXTR_MOV_H		104
#define MENU_EXTR_ROT_H		105
#define MENU_EXTR_SKT_NAME	106
#define	MENU_CLINE_SCALE_H	107
#define	MENU_CLINE_MOVE_H	108
#define MENU_CLINE_SCALE_R	109
#define	MENU_CLINE_SCALE_T	110
d226 2
a227 2
#define MENU_TGC_SCALE_H_CD	111
#define	MENU_TGC_SCALE_H_V_AB	112
a628 1
	{ "Set flags", bot_ed, ECMD_BOT_FLAGS },
d3031 1
a3031 1
			const char *radio_result;
d3078 1
a3078 1
			const char *radio_result;
d3131 1
a3131 1
					bot->thickness[i] = es_para[0];
d3157 1
a3157 50
				bot->thickness[face_no] = es_para[0];
			}
		}
		break;
	case ECMD_BOT_FLAGS:
		{
			int ret_tcl;
			const char *dialog_result;
			char cur_settings[11];
			struct rt_bot_internal *bot =
				(struct rt_bot_internal *)es_int.idb_ptr;

			RT_BOT_CK_MAGIC( bot );

			strcpy( cur_settings, " { 0 0 }" );

			if( bot->bot_flags & RT_BOT_USE_NORMALS ) {
				cur_settings[3] = '1';
			}
			if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
				cur_settings[5] = '1';
			}

			ret_tcl = Tcl_VarEval( interp,
					       "cad_list_buts",
					       " .bot_list_flags ",
					       bu_vls_addr( &pathName ),
					       " _bot_flags_result ",
					       cur_settings,
					       " \"BOT Flags\"",
					       " \"Select the desired flags\"",
					       " { {Use vertex normals} {Use single precision ray-tracing} }",
					       " { {This selection indicates that surface normals at hit points should be interpolated from vertex normals} {This selection indicates that the prepped form of the BOT triangles should use sigle precision to save memory} } ",
					       (char *)NULL );
			if( ret_tcl != TCL_OK )
			{
				bu_log( "ERROR: cad_list_buts: %s\n", interp->result );
				break;
			}
			dialog_result = Tcl_GetVar( interp, "_bot_flags_result", TCL_GLOBAL_ONLY );

			if( dialog_result[0] == '1' ) {
				bot->bot_flags |= RT_BOT_USE_NORMALS;
			} else {
				bot->bot_flags &= ~RT_BOT_USE_NORMALS;
			}
			if( dialog_result[2] == '1' ) {
				bot->bot_flags |= RT_BOT_USE_FLOATS;
			} else {
				bot->bot_flags &= ~RT_BOT_USE_FLOATS;
d3166 1
a3166 1
			const char *radio_result;
d3322 1
a3322 1
			const char *sketch_name;
d5816 1
a5816 1
	sprintf( tmp_msg, "picked point at (%g %g %g), vertex #%d\n", V3ARGS( &bot->vertices[tmp_vert*3] ), tmp_vert );
d7840 1
a7840 1
  if( es_edflag == PSCALE || es_edflag == SSCALE || es_edflag == ECMD_BOT_THICK )  {
@


11.183.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.183 2002/08/20 17:08:23 jra Exp $ (BRL)";
d71 12
a82 12
static void	arb8_edge(int arg), ars_ed(int arg), ell_ed(int arg), tgc_ed(int arg), tor_ed(int arg), spline_ed(int arg);
static void	nmg_ed(int arg), pipe_ed(int arg), vol_ed(int arg), ebm_ed(int arg), dsp_ed(int arg), cline_ed(int arg), bot_ed(int arg), extr_ed(int arg);
static void	rpc_ed(int arg), rhc_ed(int arg), part_ed(int arg), epa_ed(int arg), ehy_ed(int arg), eto_ed(int arg);
static void	arb7_edge(int arg), arb6_edge(int arg), arb5_edge(int arg), arb4_point(int arg);
static void	arb8_mv_face(int arg), arb7_mv_face(int arg), arb6_mv_face(int arg);
static void	arb5_mv_face(int arg), arb4_mv_face(int arg), arb8_rot_face(int arg), arb7_rot_face(int arg);
static void 	arb6_rot_face(int arg), arb5_rot_face(int arg), arb4_rot_face(int arg), arb_control(int arg);
static void	init_sedit_vars(void), init_oedit_vars(void), init_oedit_guts(void);

void pscale(void);
void update_edit_absolute_tran(fastf_t *view_pos);
void set_e_axes_pos(int both);
d661 2
a662 1
arb8_edge(int arg)
d675 2
a676 1
arb7_edge(int arg)
d694 2
a695 1
arb6_edge(int arg)
d718 2
a719 1
arb5_edge(int arg)
d737 2
a738 1
arb4_point(int arg)
d751 1
a751 1
bot_ed(int arg)
d761 2
a762 1
ebm_ed(int arg)
d783 2
a784 1
dsp_ed(int arg)
d810 2
a811 1
cline_ed(int arg)
d818 2
a819 1
vol_ed(int arg)
d846 2
a847 1
pipe_ed(int arg)
d946 2
a947 1
tgc_ed(int arg)
d965 2
a966 1
tor_ed(int arg)
d975 2
a976 1
eto_ed(int arg)
d988 2
a989 1
rpc_ed(int arg)
d998 2
a999 1
part_ed(int arg)
d1008 2
a1009 1
rhc_ed(int arg)
d1018 2
a1019 1
epa_ed(int arg)
d1028 2
a1029 1
ehy_ed(int arg)
d1038 2
a1039 1
ell_ed(int arg)
d1048 2
a1049 1
arb8_mv_face(int arg)
d1062 2
a1063 1
arb7_mv_face(int arg)
d1076 2
a1077 1
arb6_mv_face(int arg)
d1090 2
a1091 1
arb5_mv_face(int arg)
d1104 2
a1105 1
arb4_mv_face(int arg)
d1118 2
a1119 1
arb8_rot_face(int arg)
d1130 2
a1131 1
arb7_rot_face(int arg)
d1142 2
a1143 1
arb6_rot_face(int arg)
d1154 2
a1155 1
arb5_rot_face(int arg)
d1166 2
a1167 1
arb4_rot_face(int arg)
d1178 2
a1179 1
arb_control(int arg)
d1188 2
a1189 1
ars_ed(int arg)
d1197 2
a1198 1
extr_ed(int arg)
d1207 2
a1208 1
spline_ed(int arg)
d1231 2
a1232 1
nmg_ed(int arg)
d1523 5
a1527 1
get_solid_keypoint(fastf_t *pt, char **strp, struct rt_db_internal *ip, fastf_t *mat)
d2107 5
a2111 1
f_get_solid_keypoint(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2121 2
a2122 2
set_e_axes_pos(int both)
             /* if(!both) then set only curr_e_axes_pos, otherwise
d2406 1
a2406 1
init_sedit_vars(void)
d2477 1
a2477 1
sedit_menu(void) {
d2552 1
a2552 1
get_rotation_vertex(void)
d2597 2
a2598 1
get_file_name(char *str)
d2647 3
a2649 1
dsp_scale(struct rt_dsp_internal *dsp, int idx)
d2693 1
a2693 1
sedit(void)
d6014 2
a6015 1
sedit_trans(fastf_t *tvec)
d6365 2
a6366 1
oedit_trans(fastf_t *tvec)
d6519 1
a6519 1
pscale(void)
d7382 1
a7382 1
init_oedit_guts(void)
d7440 1
a7440 1
init_oedit_vars(void)
d7490 1
a7490 1
void oedit_reject(void);
d7592 5
a7596 1
f_eqn(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d7660 2
a7661 1
sedit_apply(int accept_flag)
d7808 4
a7811 1
mged_param(Tcl_Interp *interp, int argc, fastf_t *argvect)
d7943 5
a7947 1
f_param(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d8633 3
a8635 1
rt_vl_closest3d(struct bu_list *vhead, fastf_t *ref_pt, fastf_t *closest_pt)
d8676 4
a8679 1
rt_vl_closest2d(struct bu_list *vhead, fastf_t *ref_pt, fastf_t *mat, fastf_t *closest_pt)
d8725 6
a8730 1
nurb_closest3d(int *surface, int *uval, int *vval, const struct rt_nurb_internal *spl, const fastf_t *ref_pt)
d8846 5
a8850 1
f_keypoint(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d8910 5
a8914 1
f_get_sedit_menus(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d9071 5
a9075 1
f_get_sedit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d9149 5
a9153 1
f_put_sedit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d9233 5
a9237 1
f_sedit_reset(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d9308 5
a9312 1
f_sedit_apply(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d9339 5
a9343 1
f_oedit_reset(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d9374 5
a9378 1
f_oedit_apply(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.183.2.2
log
@Added initial stubbed support for a new primitive -- a superquadric ellipsoid.  The primitive may be created in mged, but it has the same guts as the ellipsoid
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.183.2.1 2002/09/19 18:02:01 morrison Exp $ (BRL)";
a73 2
static void	superell_ed(int arg);

a228 5
#define MENU_SUPERELL_SCALE_A	112
#define MENU_SUPERELL_SCALE_B	113
#define MENU_SUPERELL_SCALE_C	114
#define MENU_SUPERELL_SCALE_ABC	115

a633 9
struct menu_item  superell_menu[] = {
	{ "SUPERELLIPSOID MENU", (void (*)())NULL, 0 },
	{ "Set A", superell_ed, MENU_SUPERELL_SCALE_A },
	{ "Set B", superell_ed, MENU_SUPERELL_SCALE_B },
	{ "Set C", superell_ed, MENU_SUPERELL_SCALE_C },
	{ "Set A,B,C", superell_ed, MENU_SUPERELL_SCALE_ABC },
	{ "", (void (*)())NULL, 0 }
};

a1171 6
static void superell_ed(int arg) {
  es_menu = arg;
  es_edflag = PSCALE;
  set_e_axes_pos(1);
  return;
}
a1739 31
	case ID_SUPERELL:
		{
			struct rt_superell_internal	*superell = 
				(struct rt_superell_internal *)ip->idb_ptr;
			RT_SUPERELL_CK_MAGIC(superell);

			if( strcmp( cp, "V" ) == 0 )  {
				VMOVE( mpt, superell->v );
				*strp = "V";
				break;
			}
			if( strcmp( cp, "A" ) == 0 )  {
				VADD2( mpt , superell->v , superell->a );
				*strp = "A";
				break;
			}
			if( strcmp( cp, "B" ) == 0 )  {
				VADD2( mpt , superell->v , superell->b );
				*strp = "B";
				break;
			}
			if( strcmp( cp, "C" ) == 0 )  {
				VADD2( mpt , superell->v , superell->c );
				*strp = "C";
				break;
			}
			/* Default */
			VMOVE( mpt, superell->v );
			*strp = "V";
			break;
		}
a2455 3
	case ID_SUPERELL:
		mmenu_set_all( MENU_L1, superell_menu );
		break;
a7138 67

		/* begin super ellipse menu options */
	case MENU_SUPERELL_SCALE_A:
		/* scale vector A */
		{
			struct rt_superell_internal	*superell = 
				(struct rt_superell_internal *)es_int.idb_ptr;
			RT_SUPERELL_CK_MAGIC(superell);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_scale = es_para[0] * es_mat[15] /
					MAGNITUDE(superell->a);
			}
			VSCALE( superell->a, superell->a, es_scale );
		}
		break;

	case MENU_SUPERELL_SCALE_B:
		/* scale vector B */
		{
			struct rt_superell_internal	*superell = 
				(struct rt_superell_internal *)es_int.idb_ptr;
			RT_SUPERELL_CK_MAGIC(superell);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_scale = es_para[0] * es_mat[15] /
					MAGNITUDE(superell->b);
			}
			VSCALE( superell->b, superell->b, es_scale );
		}
		break;

	case MENU_SUPERELL_SCALE_C:
		/* scale vector C */
		{
			struct rt_superell_internal	*superell = 
				(struct rt_superell_internal *)es_int.idb_ptr;
			RT_SUPERELL_CK_MAGIC(superell);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_scale = es_para[0] * es_mat[15] /
					MAGNITUDE(superell->c);
			}
			VSCALE( superell->c, superell->c, es_scale );
		}
		break;

	case MENU_SUPERELL_SCALE_ABC:	/* set A,B, and C length the same */
		{
			struct rt_superell_internal	*superell = 
				(struct rt_superell_internal *)es_int.idb_ptr;
			RT_SUPERELL_CK_MAGIC(superell);
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_scale = es_para[0] * es_mat[15] /
					MAGNITUDE(superell->a);
			}
			VSCALE( superell->a, superell->a, es_scale );
			ma = MAGNITUDE( superell->a );
			mb = MAGNITUDE( superell->b );
			VSCALE(superell->b, superell->b, ma/mb);
			mb = MAGNITUDE( superell->c );
			VSCALE(superell->c, superell->c, ma/mb);
		}
		break;


a8105 25
	case ID_SUPERELL:
		{
			point_t	work;
			point_t	pos_view;
			struct rt_superell_internal	*superell = 
				(struct rt_superell_internal *)es_int.idb_ptr;
			RT_SUPERELL_CK_MAGIC(superell);

			MAT4X3PNT( pos_view, xform, superell->v );
			POINT_LABEL( pos_view, 'V' );

			VADD2( work, superell->v, superell->a );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'A' );

			VADD2( work, superell->v, superell->b );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'B' );

			VADD2( work, superell->v, superell->c );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, 'C' );
		}
		break;

a8926 3
      break;
    case ID_SUPERELL:
      mip = superell_menu;
@


11.183.2.3
log
@sync branch with HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d219 16
a234 16
#define MENU_BOT_FLAGS		102
#define MENU_EXTR_SCALE_H	103
#define MENU_EXTR_MOV_H		104
#define MENU_EXTR_ROT_H		105
#define MENU_EXTR_SKT_NAME	106
#define	MENU_CLINE_SCALE_H	107
#define	MENU_CLINE_MOVE_H	108
#define MENU_CLINE_SCALE_R	109
#define	MENU_CLINE_SCALE_T	110
#define MENU_TGC_SCALE_H_CD	111
#define	MENU_TGC_SCALE_H_V_AB	112
#define MENU_SUPERELL_SCALE_A	113
#define MENU_SUPERELL_SCALE_B	114
#define MENU_SUPERELL_SCALE_C	115
#define MENU_SUPERELL_SCALE_ABC	116

a635 1
	{ "Set flags", bot_ed, ECMD_BOT_FLAGS },
d3042 1
a3042 1
			const char *radio_result;
d3089 1
a3089 1
			const char *radio_result;
d3142 1
a3142 1
					bot->thickness[i] = es_para[0];
d3168 1
a3168 50
				bot->thickness[face_no] = es_para[0];
			}
		}
		break;
	case ECMD_BOT_FLAGS:
		{
			int ret_tcl;
			const char *dialog_result;
			char cur_settings[11];
			struct rt_bot_internal *bot =
				(struct rt_bot_internal *)es_int.idb_ptr;

			RT_BOT_CK_MAGIC( bot );

			strcpy( cur_settings, " { 0 0 }" );

			if( bot->bot_flags & RT_BOT_USE_NORMALS ) {
				cur_settings[3] = '1';
			}
			if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
				cur_settings[5] = '1';
			}

			ret_tcl = Tcl_VarEval( interp,
					       "cad_list_buts",
					       " .bot_list_flags ",
					       bu_vls_addr( &pathName ),
					       " _bot_flags_result ",
					       cur_settings,
					       " \"BOT Flags\"",
					       " \"Select the desired flags\"",
					       " { {Use vertex normals} {Use single precision ray-tracing} }",
					       " { {This selection indicates that surface normals at hit points should be interpolated from vertex normals} {This selection indicates that the prepped form of the BOT triangles should use sigle precision to save memory} } ",
					       (char *)NULL );
			if( ret_tcl != TCL_OK )
			{
				bu_log( "ERROR: cad_list_buts: %s\n", interp->result );
				break;
			}
			dialog_result = Tcl_GetVar( interp, "_bot_flags_result", TCL_GLOBAL_ONLY );

			if( dialog_result[0] == '1' ) {
				bot->bot_flags |= RT_BOT_USE_NORMALS;
			} else {
				bot->bot_flags &= ~RT_BOT_USE_NORMALS;
			}
			if( dialog_result[2] == '1' ) {
				bot->bot_flags |= RT_BOT_USE_FLOATS;
			} else {
				bot->bot_flags &= ~RT_BOT_USE_FLOATS;
d3177 1
a3177 1
			const char *radio_result;
d3333 1
a3333 1
			const char *sketch_name;
d5827 1
a5827 1
	sprintf( tmp_msg, "picked point at (%g %g %g), vertex #%d\n", V3ARGS( &bot->vertices[tmp_vert*3] ), tmp_vert );
d7908 1
a7908 1
  if( es_edflag == PSCALE || es_edflag == SSCALE || es_edflag == ECMD_BOT_THICK )  {
@


11.182
log
@Converted from K&R to ANSI C - RFH
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.180 2002/06/03 19:13:45 jra Exp $ (BRL)";
d71 12
a82 12
static void	arb8_edge(int arg), ars_ed(int arg), ell_ed(int arg), tgc_ed(int arg), tor_ed(int arg), spline_ed(int arg);
static void	nmg_ed(int arg), pipe_ed(int arg), vol_ed(int arg), ebm_ed(int arg), dsp_ed(int arg), cline_ed(int arg), bot_ed(int arg), extr_ed(int arg);
static void	rpc_ed(int arg), rhc_ed(int arg), part_ed(int arg), epa_ed(int arg), ehy_ed(int arg), eto_ed(int arg);
static void	arb7_edge(int arg), arb6_edge(int arg), arb5_edge(int arg), arb4_point(int arg);
static void	arb8_mv_face(int arg), arb7_mv_face(int arg), arb6_mv_face(int arg);
static void	arb5_mv_face(int arg), arb4_mv_face(int arg), arb8_rot_face(int arg), arb7_rot_face(int arg);
static void 	arb6_rot_face(int arg), arb5_rot_face(int arg), arb4_rot_face(int arg), arb_control(int arg);
static void	init_sedit_vars(void), init_oedit_vars(void), init_oedit_guts(void);

void pscale(void);
void update_edit_absolute_tran(fastf_t *view_pos);
void set_e_axes_pos(int both);
d661 2
a662 1
arb8_edge(int arg)
d675 2
a676 1
arb7_edge(int arg)
d694 2
a695 1
arb6_edge(int arg)
d718 2
a719 1
arb5_edge(int arg)
d737 2
a738 1
arb4_point(int arg)
d751 1
a751 1
bot_ed(int arg)
d761 2
a762 1
ebm_ed(int arg)
d783 2
a784 1
dsp_ed(int arg)
d810 2
a811 1
cline_ed(int arg)
d818 2
a819 1
vol_ed(int arg)
d846 2
a847 1
pipe_ed(int arg)
d946 2
a947 1
tgc_ed(int arg)
d965 2
a966 1
tor_ed(int arg)
d975 2
a976 1
eto_ed(int arg)
d988 2
a989 1
rpc_ed(int arg)
d998 2
a999 1
part_ed(int arg)
d1008 2
a1009 1
rhc_ed(int arg)
d1018 2
a1019 1
epa_ed(int arg)
d1028 2
a1029 1
ehy_ed(int arg)
d1038 2
a1039 1
ell_ed(int arg)
d1048 2
a1049 1
arb8_mv_face(int arg)
d1062 2
a1063 1
arb7_mv_face(int arg)
d1076 2
a1077 1
arb6_mv_face(int arg)
d1090 2
a1091 1
arb5_mv_face(int arg)
d1104 2
a1105 1
arb4_mv_face(int arg)
d1118 2
a1119 1
arb8_rot_face(int arg)
d1130 2
a1131 1
arb7_rot_face(int arg)
d1142 2
a1143 1
arb6_rot_face(int arg)
d1154 2
a1155 1
arb5_rot_face(int arg)
d1166 2
a1167 1
arb4_rot_face(int arg)
d1178 2
a1179 1
arb_control(int arg)
d1188 2
a1189 1
ars_ed(int arg)
d1197 2
a1198 1
extr_ed(int arg)
d1207 2
a1208 1
spline_ed(int arg)
d1231 2
a1232 1
nmg_ed(int arg)
d1523 5
a1527 1
get_solid_keypoint(fastf_t *pt, char **strp, struct rt_db_internal *ip, fastf_t *mat)
d2107 5
a2111 1
f_get_solid_keypoint(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2121 2
a2122 2
set_e_axes_pos(int both)
             /* if(!both) then set only curr_e_axes_pos, otherwise
d2406 1
a2406 1
init_sedit_vars(void)
d2477 1
a2477 1
sedit_menu(void) {
d2552 1
a2552 1
get_rotation_vertex(void)
d2597 2
a2598 1
get_file_name(char *str)
d2647 3
a2649 1
dsp_scale(struct rt_dsp_internal *dsp, int idx)
d2693 1
a2693 1
sedit(void)
d6014 2
a6015 1
sedit_trans(fastf_t *tvec)
d6365 2
a6366 1
oedit_trans(fastf_t *tvec)
d6519 1
a6519 1
pscale(void)
d7382 1
a7382 1
init_oedit_guts(void)
d7440 1
a7440 1
init_oedit_vars(void)
d7490 1
a7490 1
void oedit_reject(void);
d7592 5
a7596 1
f_eqn(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d7660 2
a7661 1
sedit_apply(int accept_flag)
d7808 4
a7811 1
mged_param(Tcl_Interp *interp, int argc, fastf_t *argvect)
d7943 5
a7947 1
f_param(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d8589 1
d8633 3
a8635 1
rt_vl_closest3d(struct bu_list *vhead, fastf_t *ref_pt, fastf_t *closest_pt)
d8676 4
a8679 1
rt_vl_closest2d(struct bu_list *vhead, fastf_t *ref_pt, fastf_t *mat, fastf_t *closest_pt)
d8725 6
a8730 1
nurb_closest3d(int *surface, int *uval, int *vval, const struct rt_nurb_internal *spl, const fastf_t *ref_pt)
d8846 5
a8850 1
f_keypoint(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d8910 5
a8914 1
f_get_sedit_menus(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d9071 5
a9075 1
f_get_sedit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d9149 5
a9153 1
f_put_sedit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d9233 5
a9237 1
f_sedit_reset(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d9308 5
a9312 1
f_sedit_apply(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d9339 5
a9343 1
f_oedit_reset(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d9374 5
a9378 1
f_oedit_apply(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.181
log
@freed a statically allocated vls string that was previously not freed..(memory leak)
@
text
@d71 12
a82 12
static void	arb8_edge(), ars_ed(), ell_ed(), tgc_ed(), tor_ed(), spline_ed();
static void	nmg_ed(), pipe_ed(), vol_ed(), ebm_ed(), dsp_ed(), cline_ed(), bot_ed(), extr_ed();
static void	rpc_ed(), rhc_ed(), part_ed(), epa_ed(), ehy_ed(), eto_ed();
static void	arb7_edge(), arb6_edge(), arb5_edge(), arb4_point();
static void	arb8_mv_face(), arb7_mv_face(), arb6_mv_face();
static void	arb5_mv_face(), arb4_mv_face(), arb8_rot_face(), arb7_rot_face();
static void 	arb6_rot_face(), arb5_rot_face(), arb4_rot_face(), arb_control();
static void	init_sedit_vars(), init_oedit_vars(), init_oedit_guts();

void pscale();
void update_edit_absolute_tran();
void set_e_axes_pos();
d661 1
a661 2
arb8_edge( arg )
int arg;
d674 1
a674 2
arb7_edge( arg )
int arg;
d692 1
a692 2
arb6_edge( arg )
int arg;
d715 1
a715 2
arb5_edge( arg )
int arg;
d733 1
a733 2
arb4_point( arg )
int arg;
d746 1
a746 1
bot_ed( arg )
d756 1
a756 2
ebm_ed( arg )
int arg;
d777 1
a777 2
dsp_ed( arg )
int arg;
d803 1
a803 2
cline_ed( arg )
int arg;
d810 1
a810 2
vol_ed( arg )
int arg;
d837 1
a837 2
pipe_ed( arg )
int arg;
d936 1
a936 2
tgc_ed( arg )
int arg;
d954 1
a954 2
tor_ed( arg )
int arg;
d963 1
a963 2
eto_ed( arg )
int arg;
d975 1
a975 2
rpc_ed( arg )
int arg;
d984 1
a984 2
part_ed( arg )
int arg;
d993 1
a993 2
rhc_ed( arg )
int arg;
d1002 1
a1002 2
epa_ed( arg )
int arg;
d1011 1
a1011 2
ehy_ed( arg )
int arg;
d1020 1
a1020 2
ell_ed( arg )
int arg;
d1029 1
a1029 2
arb8_mv_face( arg )
int arg;
d1042 1
a1042 2
arb7_mv_face( arg )
int arg;
d1055 1
a1055 2
arb6_mv_face( arg )
int arg;
d1068 1
a1068 2
arb5_mv_face( arg )
int arg;
d1081 1
a1081 2
arb4_mv_face( arg )
int arg;
d1094 1
a1094 2
arb8_rot_face( arg )
int arg;
d1105 1
a1105 2
arb7_rot_face( arg )
int arg;
d1116 1
a1116 2
arb6_rot_face( arg )
int arg;
d1127 1
a1127 2
arb5_rot_face( arg )
int arg;
d1138 1
a1138 2
arb4_rot_face( arg )
int arg;
d1149 1
a1149 2
arb_control( arg )
int arg;
d1158 1
a1158 2
ars_ed( arg )
int arg;
d1166 1
a1166 2
extr_ed( arg )
int arg;
d1175 1
a1175 2
spline_ed( arg )
int arg;
d1198 1
a1198 2
nmg_ed( arg )
int arg;
d1489 1
a1489 5
get_solid_keypoint( pt, strp, ip, mat )
point_t		pt;
char		**strp;
struct rt_db_internal	*ip;
mat_t		mat;
d2069 1
a2069 5
f_get_solid_keypoint(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d2079 2
a2080 2
set_e_axes_pos(both)
int both;    /* if(!both) then set only curr_e_axes_pos, otherwise
d2364 1
a2364 1
init_sedit_vars()
d2435 1
a2435 1
sedit_menu()  {
d2510 1
a2510 1
get_rotation_vertex()
d2555 1
a2555 2
get_file_name( str )
char *str;
d2604 1
a2604 3
dsp_scale(dsp, idx)
struct rt_dsp_internal *dsp;
int idx;
d2648 1
a2648 1
sedit()
d5969 1
a5969 2
sedit_trans(tvec)
vect_t tvec;
d6319 1
a6319 2
oedit_trans(tvec)
point_t tvec;
d6472 1
a6472 1
pscale()
d7335 1
a7335 1
init_oedit_guts()
d7393 1
a7393 1
init_oedit_vars()
d7443 1
a7443 1
void oedit_reject();
d7545 1
a7545 5
f_eqn(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d7609 1
a7609 2
sedit_apply(accept_flag)
     int	accept_flag;
d7756 1
a7756 4
mged_param(interp, argc, argvect)
Tcl_Interp *interp;
int argc;
vect_t argvect;
d7888 1
a7888 5
f_param(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
a8529 1
			bu_vls_free(&tmp_vls);
d8573 1
a8573 3
rt_vl_closest3d(vhead, ref_pt, closest_pt)
struct bu_list	*vhead;
point_t		ref_pt, closest_pt;
d8614 1
a8614 4
rt_vl_closest2d(vhead, ref_pt, mat, closest_pt)
struct bu_list	*vhead;
point_t		ref_pt, closest_pt;
mat_t		mat;
d8660 1
a8660 6
nurb_closest3d(surface, uval, vval, spl, ref_pt )
int				*surface;
int				*uval;
int				*vval;
const struct rt_nurb_internal	*spl;
const point_t			ref_pt;
d8776 1
a8776 5
f_keypoint(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d8836 1
a8836 5
f_get_sedit_menus(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d8993 1
a8993 5
f_get_sedit(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d9067 1
a9067 5
f_put_sedit(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d9147 1
a9147 5
f_sedit_reset(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d9218 1
a9218 5
f_sedit_apply(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d9245 1
a9245 5
f_oedit_reset(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d9276 1
a9276 5
f_oedit_apply(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
@


11.180
log
@f_oedit_apply() and oedit_apply() were not correctly handling the case were the
user applies the current edit, but wants to continue editing.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.179 2001/11/15 22:55:54 bparker Exp $ (BRL)";
d8589 1
@


11.179
log
@*- mods to pscale() to warn the user about trying to set
   the semi-major axis to something smaller than the
   semi-minor axis
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.178 2001/11/05 21:20:06 morrison Exp $ (BRL)";
d7493 1
a7493 1
oedit_apply()
d7546 4
a7549 1
		sp->s_iflag = DOWN;
d7575 1
a7575 1
	oedit_apply();
d9383 1
a9383 3
	oedit_apply();

	replot_original_solid(illump);
@


11.178
log
@Solid to Primitive naming convention conversions
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.177 2001/11/01 22:01:23 bparker Exp $ (BRL)";
d6908 2
d6927 2
d6962 2
d6981 2
@


11.177
log
@*- add "struct db_i *" parameter to ft_describe function calls
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.176 2001/10/30 02:16:18 jra Exp $ (BRL)";
d7737 1
a7737 1
	if (not_state(ST_S_EDIT, "Solid edit accept"))
d9306 1
a9306 1
	if (not_state(ST_S_EDIT, "Solid edit accept")) {
@


11.176
log
@reset now works correctly for the pipe solid
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.175 2001/10/02 19:24:32 jra Exp $ (BRL)";
d6480 1
a6480 1
		    base2local, &rt_uniresource ) < 0 )
d6486 1
a6486 1
		    base2local, &rt_uniresource ) < 0 )
@


11.175
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.174 2001/09/06 16:24:03 bparker Exp $ (BRL)";
d9242 5
@


11.174
log
@*- change a few menu item names
   in the TGC edit menu
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.173 2001/09/06 15:57:34 bparker Exp $ (BRL)";
d3355 1
@


11.173
log
@*- add two new TGC edit modes
	Set H,C,D - primarily sets H, then adjusts
		C and D so that the angles between
		the ends and the sides of the TGC
		are constant.
	Set H,A,B (move V) - same as above except moves V
		and adjusts A and B.
*- change the following items in the TGC edit menu:
	"Set c" ---> "Set C"
	"Set d" ---> "Set D"
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.172 2001/08/14 18:32:57 bparker Exp $ (BRL)";
d353 2
a354 2
	{ "Set H,C,D",	tgc_ed, MENU_TGC_SCALE_H_CD },
	{ "Set H,A,B (move V)", tgc_ed, MENU_TGC_SCALE_H_V_AB },
@


11.172
log
@*- mods to sedit_apply to restore es_int after
   rt_db_put_internal blows it away
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.171 2001/08/02 13:21:32 bparker Exp $ (BRL)";
d226 3
d353 2
d357 2
a358 2
	{ "Set c",	tgc_ed, MENU_TGC_SCALE_C },
	{ "Set d",	tgc_ed, MENU_TGC_SCALE_D },
d6559 77
@


11.171
log
@*- calling begin_edit_callback with full path of solid.
   This is for the Sketch_editor.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.170 2001/06/26 20:55:03 bparker Exp $ (BRL)";
d7631 11
d7643 1
@


11.170
log
@*- first format set_e_axes_pos so
   it's readable
*- apply mods to set_e_axes_pos that
   fixes editing an arbn.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.169 2001/06/05 15:51:41 bparker Exp $ (BRL)";
d2393 2
a2394 1
		bu_vls_printf(&vls, "begin_edit_callback");
d7394 1
a7394 1
	bu_vls_strcpy(&vls, "begin_edit_callback");
@


11.169
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.168 2001/06/01 19:23:24 bparker Exp $ (BRL)";
d2120 2
a2121 2
  int	i;
  register struct dm_list *dmlp;
d2123 1
a2123 1
  update_views = 1;
d2125 1
a2125 1
  VMOVE(curr_e_axes_pos, es_keypoint);
d2127 74
a2200 75
  switch(es_int.idb_type){
  case	ID_ARB8:
  case	ID_ARBN:
    if(state == ST_O_EDIT)
      i = 0;
    else
      switch(es_edflag){
      case	STRANS:
	i = 0;
	break;
      case	EARB:
	switch(es_type){
	case	ARB5:
	  i = earb5[es_menu][0];
	  break;
	case	ARB6:
	  i = earb6[es_menu][0];
	  break;
	case	ARB7:
	  i = earb7[es_menu][0];
	  break;
	case	ARB8:
	  i = earb8[es_menu][0];
	  break;
	default:
	  i = 0;
	  break;
	}
	break;
      case	PTARB:
	switch(es_type){
	case    ARB4:
	  i = es_menu;	/* index for point 1,2,3 or 4 */
	  break;
	case    ARB5:
	case	ARB7:
	  i = 4;	/* index for point 5 */
	  break;
	case    ARB6:
	  i = es_menu;	/* index for point 5 or 6 */
	  break;
	default:
	  i = 0;
	  break;
	}
	break;
      case ECMD_ARB_MOVE_FACE:
	switch(es_type){
	case	ARB4:
	  i = arb_faces[0][es_menu * 4];
	  break;
	case	ARB5:
	  i = arb_faces[1][es_menu * 4];  		
	  break;
	case	ARB6:
	  i = arb_faces[2][es_menu * 4];  		
	  break;
	case	ARB7:
	  i = arb_faces[3][es_menu * 4];  		
	  break;
	case	ARB8:
	  i = arb_faces[4][es_menu * 4];  		
	  break;
	default:
	  i = 0;
	  break;
	}
	break;
      case ECMD_ARB_ROTATE_FACE:
	i = fixv;
	break;
      default:
	i = 0;
	break;
      }
d2202 16
a2217 16
    MAT4X3PNT(curr_e_axes_pos, es_mat,
	      ((struct rt_arb_internal *)es_int.idb_ptr)->pt[i]);
    break;
  case ID_TGC:
  case ID_REC:
    if(es_edflag == ECMD_TGC_MV_H ||
       es_edflag == ECMD_TGC_MV_HH){
      struct rt_tgc_internal  *tgc = (struct rt_tgc_internal *)es_int.idb_ptr;
      point_t tgc_v;
      vect_t tgc_h;

      MAT4X3PNT(tgc_v, es_mat, tgc->v);
      MAT4X3VEC(tgc_h, es_mat, tgc->h);
      VADD2(curr_e_axes_pos, tgc_h, tgc_v);
    }else
      VMOVE(curr_e_axes_pos, es_keypoint)
d2219 14
a2232 16
    break;
  case ID_EXTRUDE:
  	if( es_edflag == ECMD_EXTR_MOV_H )
  	{
  		struct rt_extrude_internal *extr = (struct rt_extrude_internal *)es_int.idb_ptr;
  		point_t extr_v;
  		vect_t extr_h;

  		RT_EXTRUDE_CK_MAGIC( extr );

  		MAT4X3PNT(extr_v, es_mat, extr->V);
  		MAT4X3VEC(extr_h, es_mat, extr->h);
  		VADD2(curr_e_axes_pos, extr_h, extr_v);
  	}
  	else
  		VMOVE(curr_e_axes_pos, es_keypoint)
d2234 20
a2253 22
    break;
  case ID_CLINE:
  	if( es_edflag == ECMD_CLINE_MOVE_H )
  	{
  		struct rt_cline_internal *cli = 
  			(struct rt_cline_internal *)es_int.idb_ptr;
  		point_t cli_v;
  		vect_t cli_h;

  		RT_CLINE_CK_MAGIC( cli );

  		MAT4X3PNT(cli_v, es_mat, cli->v);
  		MAT4X3VEC(cli_h, es_mat, cli->h);
  		VADD2(curr_e_axes_pos, cli_h, cli_v);
  	}
  	else
  		VMOVE(curr_e_axes_pos, es_keypoint)
    break;
  default:
    VMOVE(curr_e_axes_pos, es_keypoint);
    break;
  }
d2256 2
a2257 2
  if(both){
    VMOVE(e_axes_pos, curr_e_axes_pos);
d2259 23
a2281 23
    if(EDIT_ROTATE){
      es_edclass = EDIT_CLASS_ROTATE;
      VSETALL( edit_absolute_model_rotate, 0.0 );
      VSETALL( edit_absolute_object_rotate, 0.0 );
      VSETALL( edit_absolute_view_rotate, 0.0 );
      VSETALL( last_edit_absolute_model_rotate, 0.0 );
      VSETALL( last_edit_absolute_object_rotate, 0.0 );
      VSETALL( last_edit_absolute_view_rotate, 0.0 );
    }else if(EDIT_TRAN){
      es_edclass = EDIT_CLASS_TRAN;
      VSETALL( edit_absolute_model_tran, 0.0 );
      VSETALL( edit_absolute_view_tran, 0.0 );
      VSETALL( last_edit_absolute_model_tran, 0.0 );
      VSETALL( last_edit_absolute_view_tran, 0.0 );
    }else if(EDIT_SCALE){
      es_edclass = EDIT_CLASS_SCALE;

      if(SEDIT_SCALE){
	edit_absolute_scale = 0.0;
	acc_sc_sol = 1.0;
      }
    }else
      es_edclass = EDIT_CLASS_NULL;
d2284 1
a2284 1
    MAT_IDN(acc_rot_sol);
d2287 3
a2289 3
    FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l)
      dmlp->dml_mged_variables->mv_transform = 'e';
  }
@


11.168
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.167 2001/05/16 21:38:08 morrison Exp $ (BRL)";
a4022 1
#ifdef MGED_USE_VIEW_OBJ
a4023 3
#else
			  MAT4X3PNT(rot_point, view_state->vs_view2model, work);
#endif
a4026 1
#ifdef MGED_USE_VIEW_OBJ
a4027 3
#else
			  MAT4X3PNT(rot_point, view_state->vs_view2model, work);
#endif
a4362 1
#ifdef MGED_USE_VIEW_OBJ
a4363 3
#else
					MAT4X3VEC( view_dir , view_state->vs_view2model , view_z_dir );
#endif
a4532 1
#ifdef MGED_USE_VIEW_OBJ
a4533 3
#else
					MAT4X3VEC( view_dir , view_state->vs_view2model , view_z_dir );
#endif
a4898 1
#ifdef MGED_USE_VIEW_OBJ
a4899 3
#else
			MAT4X3VEC( view_dir , view_state->vs_view2model , z_dir );
#endif
a5239 1
#ifdef MGED_USE_VIEW_OBJ
a5240 3
#else
				MAT4X3VEC( view_pl, view_state->vs_view2model, view_dir );
#endif
a5301 1
#ifdef MGED_USE_VIEW_OBJ
a5302 3
#else
				MAT4X3VEC( view_pl, view_state->vs_view2model, view_dir );
#endif
a5362 1
#ifdef MGED_USE_VIEW_OBJ
a5363 3
#else
				MAT4X3VEC( view_pl, view_state->vs_view2model, view_dir );
#endif
a5665 1
#ifdef MGED_USE_VIEW_OBJ
a5669 6
#else
      MAT4X3PNT( pos_view, view_state->vs_model2view, curr_e_axes_pos );
      pos_view[X] = mousevec[X];
      pos_view[Y] = mousevec[Y];
      MAT4X3PNT( pt, view_state->vs_view2model, pos_view );
#endif
a5691 1
#ifdef MGED_USE_VIEW_OBJ
a5695 6
#else
    MAT4X3PNT( pos_view, view_state->vs_model2view, curr_e_axes_pos );
    pos_view[X] = mousevec[X];
    pos_view[Y] = mousevec[Y];
    MAT4X3PNT( temp, view_state->vs_view2model, pos_view );
#endif
a5708 1
#ifdef MGED_USE_VIEW_OBJ
a5713 7
#else
      MAT4X3PNT(pos_view, view_state->vs_model2view, curr_e_axes_pos);
      pos_view[X] = mousevec[X];
      pos_view[Y] = mousevec[Y];
      /* Do NOT change pos_view[Z] ! */
      MAT4X3PNT( temp, view_state->vs_view2model, pos_view );
#endif
a5725 1
#ifdef MGED_USE_VIEW_OBJ
a5730 7
#else
      MAT4X3PNT(pos_view, view_state->vs_model2view, curr_e_axes_pos);
      pos_view[X] = mousevec[X];
      pos_view[Y] = mousevec[Y];
      /* Do NOT change pos_view[Z] ! */
      MAT4X3PNT( temp, view_state->vs_view2model, pos_view );
#endif
a5742 1
#ifdef MGED_USE_VIEW_OBJ
a5747 7
#else
      MAT4X3PNT(pos_view, view_state->vs_model2view, curr_e_axes_pos);
      pos_view[X] = mousevec[X];
      pos_view[Y] = mousevec[Y];
      /* Do NOT change pos_view[Z] ! */
      MAT4X3PNT( temp, view_state->vs_view2model, pos_view );
#endif
a5755 1
#ifdef MGED_USE_VIEW_OBJ
a5759 6
#else
    MAT4X3PNT(pos_view, view_state->vs_model2view, curr_e_axes_pos);
    pos_view[X] = mousevec[X];
    pos_view[Y] = mousevec[Y];
    MAT4X3PNT(temp, view_state->vs_view2model, pos_view);
#endif
a5764 1
#ifdef MGED_USE_VIEW_OBJ
a5768 6
#else
    MAT4X3PNT(pos_view, view_state->vs_model2view, curr_e_axes_pos);
    pos_view[X] = mousevec[X];
    pos_view[Y] = mousevec[Y];
    MAT4X3PNT(temp, view_state->vs_view2model, pos_view);
#endif
a5773 1
#ifdef MGED_USE_VIEW_OBJ
a5777 6
#else
    MAT4X3PNT(pos_view, view_state->vs_model2view, curr_e_axes_pos);
    pos_view[X] = mousevec[X];
    pos_view[Y] = mousevec[Y];
    MAT4X3PNT(temp, view_state->vs_view2model, pos_view);
#endif
a5798 1
#ifdef MGED_USE_VIEW_OBJ
a5803 7
#else
	MAT4X3PNT( pos_view, view_state->vs_model2view, curr_e_axes_pos );
	pos_view[X] = mousevec[X];
	pos_view[Y] = mousevec[Y];

  	tmp_vert = rt_bot_find_v_nearest_pt2( bot, pos_view, view_state->vs_model2view );
#endif
a5826 1
#ifdef MGED_USE_VIEW_OBJ
a5831 7
#else
	MAT4X3PNT( pos_view, view_state->vs_model2view, curr_e_axes_pos );
	pos_view[X] = mousevec[X];
	pos_view[Y] = mousevec[Y];

    	if( rt_bot_find_e_nearest_pt2( &vert1, &vert2, bot, pos_view, view_state->vs_model2view ) )
#endif
a5860 1
#ifdef MGED_USE_VIEW_OBJ
a5863 5
#else
  		MAT4X3PNT( start_pt, view_state->vs_view2model, tmp );
  		VSET( tmp, 0, 0, 1 );
  		MAT4X3VEC( dir, view_state->vs_view2model, tmp );
#endif
a5930 1
#ifdef MGED_USE_VIEW_OBJ
a5935 8
#else
      MAT4X3PNT( pos_view, view_state->vs_model2view, curr_e_axes_pos );
      pos_view[X] = mousevec[X];
      pos_view[Y] = mousevec[Y];
      if( (e = nmg_find_e_nearest_pt2( &m->magic, pos_view,
				       view_state->vs_model2view, &tmp_tol )) ==
	  (struct edge *)NULL )  {
#endif
a5974 1
#ifdef MGED_USE_VIEW_OBJ
a5978 6
#else
    MAT4X3PNT(pos_view, view_state->vs_model2view, curr_e_axes_pos);
    pos_view[X] = mousevec[X];
    pos_view[Y] = mousevec[Y];
    MAT4X3PNT(temp, view_state->vs_view2model, pos_view);
#endif
a5995 1
#ifdef MGED_USE_VIEW_OBJ
a6008 15
#else
  vect_t model_pos;
  vect_t ea_view_pos;
  vect_t diff;
  fastf_t inv_Viewscale = 1/view_state->vs_Viewscale;

  MAT4X3PNT(model_pos, view_state->vs_view2model, view_pos);
  VSUB2(diff, model_pos, e_axes_pos);
  VSCALE(edit_absolute_model_tran, diff, inv_Viewscale);
  VMOVE(last_edit_absolute_model_tran, edit_absolute_model_tran);

  MAT4X3PNT(ea_view_pos, view_state->vs_model2view, e_axes_pos);
  VSUB2(edit_absolute_view_tran, view_pos, ea_view_pos);
  VMOVE(last_edit_absolute_view_tran, edit_absolute_view_tran);
#endif
a6035 1
#ifdef MGED_USE_VIEW_OBJ
a6036 3
#else
      MAT4X3PNT(temp, view_state->vs_view2model, tvec);
#endif
a6057 1
#ifdef MGED_USE_VIEW_OBJ
a6058 3
#else
    MAT4X3PNT( temp, view_state->vs_view2model, tvec );
#endif
a6072 1
#ifdef MGED_USE_VIEW_OBJ
a6073 3
#else
      MAT4X3PNT( temp, view_state->vs_view2model, tvec );
#endif
a6086 1
#ifdef MGED_USE_VIEW_OBJ
a6087 3
#else
      MAT4X3PNT( temp, view_state->vs_view2model, tvec );
#endif
a6100 1
#ifdef MGED_USE_VIEW_OBJ
a6101 3
#else
      MAT4X3PNT( temp, view_state->vs_view2model, tvec );
#endif
a6117 1
#ifdef MGED_USE_VIEW_OBJ
a6118 3
#else
    MAT4X3PNT( temp, view_state->vs_view2model, tvec );
#endif
a6124 1
#ifdef MGED_USE_VIEW_OBJ
a6125 3
#else
    MAT4X3PNT( temp, view_state->vs_view2model, tvec );
#endif
a6132 1
#ifdef MGED_USE_VIEW_OBJ
a6133 3
#else
    MAT4X3PNT( temp, view_state->vs_view2model, tvec );
#endif
a6166 1
#ifdef MGED_USE_VIEW_OBJ
a6170 6
#else
      if( (e = nmg_find_e_nearest_pt2( &m->magic,
				       tvec,
				       view_state->vs_model2view,
				       &tmp_tol )) == (struct edge *)NULL )  {
#endif
a6205 1
#ifdef MGED_USE_VIEW_OBJ
a6206 3
#else
    MAT4X3PNT( temp, view_state->vs_view2model, tvec );
#endif
a6342 1
#ifdef MGED_USE_VIEW_OBJ
a6343 3
#else
    MAT4X3PNT( pos_model, view_state->vs_view2model, pos_view );/* NOT objview */
#endif
a6377 1
#ifdef MGED_USE_VIEW_OBJ
a6378 3
#else
  MAT4X3PNT( pos_model, view_state->vs_view2model, tvec );/* NOT objview */
#endif
a7821 1
#ifdef MGED_USE_VIEW_OBJ
a7822 3
#else
    fastf_t inv_Viewscale = 1/view_state->vs_Viewscale;
#endif
@


11.167
log
@PRODUCTION optimizations
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.166 2001/05/02 19:35:38 jra Exp $ (BRL)";
d2445 1
a2445 1
  FOR_ALL_SOLIDS(sp, &HeadSolid.l) {
d3574 4
a3577 4
				buildHrot( modelchanges,
					es_para[0] * degtorad,
					es_para[1] * degtorad,
					es_para[2] * degtorad );
d4003 4
a4006 4
				buildHrot( modelchanges,
					es_para[0] * degtorad,
					es_para[1] * degtorad,
					es_para[2] * degtorad );
d4023 3
d4027 1
d4031 3
d4035 1
d4089 4
a4092 4
				buildHrot( modelchanges,
					es_para[0] * degtorad,
					es_para[1] * degtorad,
					es_para[2] * degtorad );
d4146 4
a4149 4
				buildHrot( modelchanges,
					es_para[0] * degtorad,
					es_para[1] * degtorad,
					es_para[2] * degtorad );
d4203 4
a4206 4
				buildHrot( modelchanges,
					es_para[0] * degtorad,
					es_para[1] * degtorad,
					es_para[2] * degtorad );
d4272 4
a4275 4
				buildHrot( modelchanges,
					es_para[0] * degtorad,
					es_para[1] * degtorad,
					es_para[2] * degtorad );
d4371 3
d4375 1
d4545 3
d4549 1
d4915 3
d4919 1
d5260 3
d5264 1
d5326 3
d5330 1
d5391 3
d5395 1
d5698 6
d5708 1
d5731 6
d5741 1
d5755 7
d5767 1
d5780 7
d5792 1
d5805 7
d5817 1
d5826 6
d5836 1
d5842 6
d5852 1
d5858 6
d5868 1
d5890 7
d5902 1
d5926 7
d5938 1
d5968 5
d5976 1
d6044 7
d6057 1
d6096 7
d6107 1
d6123 1
a6123 2
update_edit_absolute_tran(view_pos)
vect_t view_pos;
d6125 15
d6153 1
d6181 5
a6185 1
      MAT4X3PNT( temp, view_state->vs_view2model, tvec );
d6207 3
d6211 1
d6226 3
d6230 1
d6244 3
d6248 1
d6262 3
d6266 1
d6283 3
d6287 1
d6294 3
d6298 1
d6306 3
d6310 1
d6344 6
d6354 1
d6390 3
d6394 1
d6531 3
d6535 1
d6570 3
d6574 1
d7651 1
a7651 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l) {
d7669 1
a7669 1
		FOR_ALL_SOLIDS(sp, &HeadSolid.l) {
d7887 1
a7887 1
	  FOR_ALL_SOLIDS(sp, &HeadSolid.l) {
d8018 3
d8022 1
d8086 1
a8086 1
	buildHrot( incr_change, xangle, yangle, zangle );
d8113 1
a8113 1
	buildHrot( incr_change, xangle, yangle, zangle );
@


11.166
log
@Made code not dependent on BU_BITTEST returning a 0 or 1
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.165 2001/04/25 12:44:46 jra Exp $ (BRL)";
d8342 1
d8346 1
d8362 1
d8367 1
@


11.165
log
@The "sketch_name" field of the internal form of the extrusion is now a malloced string
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.164 2001/04/05 19:35:44 morrison Exp $ (BRL)";
d3214 1
a3214 1
				sprintf( fmode, " %d", BU_BITTEST( bot->face_mode, face_no ) );
d3216 1
a3216 1
				sprintf( fmode, " %d", BU_BITTEST( bot->face_mode, 0 ) );
@


11.164
log
@updated SIGNED to signed
updated CONST to const
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.163 2001/04/02 21:38:19 morrison Exp $ (BRL)";
d3346 3
a3348 1
			NAMEMOVE( sketch_name, extr->sketch_name );
@


11.163
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.162 2001/03/31 01:57:22 morrison Exp $ (BRL)";
d87 1
a87 1
MGED_EXTERN( struct wdb_pipept *find_pipept_nearest_pt, (CONST struct bu_list *pipe_hd, CONST point_t pt ) );
d90 1
a90 1
MGED_EXTERN( struct wdb_pipept *add_pipept, (struct rt_pipe_internal *pipe, struct wdb_pipept *pp, CONST point_t new_pt ) );
d8621 2
a8622 2
CONST struct rt_nurb_internal	*spl;
CONST point_t			ref_pt;
d9047 1
a9047 1
  register CONST struct rt_functab *ftp;
@


11.162
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.161 2001/03/23 22:35:55 butler Exp $ (BRL)";
d2654 1
a2654 1
	mat_idn(m);
d2672 1
a2672 1
	bn_mat_copy(dsp->dsp_stom, m);
d2675 1
a2675 1
	bn_mat_copy(dsp->dsp_mtos, m);
d3576 1
a3576 1
				bn_mat_copy(acc_rot_sol, modelchanges);
d4007 1
a4007 1
				bn_mat_copy(acc_rot_sol, modelchanges);
d4085 1
a4085 1
				bn_mat_copy(acc_rot_sol, modelchanges);
d4142 1
a4142 1
				bn_mat_copy(acc_rot_sol, modelchanges);
d4199 1
a4199 1
				bn_mat_copy(acc_rot_sol, modelchanges);
d4268 1
a4268 1
				bn_mat_copy(acc_rot_sol, modelchanges);
d6347 1
a6347 1
    bn_mat_copy( oldchanges, modelchanges );
d6382 1
a6382 1
  bn_mat_copy( oldchanges, modelchanges );
d7889 1
a7889 1
	bn_mat_copy(acc_rot_sol, tempp);
@


11.161
log
@Changes to support new DSP primitive representation
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /n/tgm/d/CVS/brlcad/mged/edsol.c,v 11.160 2001/02/23 21:44:27 bparker Exp $ (BRL)";
d2289 1
a2289 1
    bn_mat_idn(acc_rot_sol);
d2407 2
a2408 2
	bn_mat_idn(acc_rot_sol);
	bn_mat_idn(incr_change);
d3571 1
a3571 1
				bn_mat_idn( modelchanges );
d3592 1
a3592 1
				  bn_mat_idn( incr_change );
d3632 1
a3632 1
			bn_mat_idn( modelchanges );
d3651 1
a3651 1
		bn_mat_idn( incr_change );
d3708 1
a3708 1
			    bn_mat_idn( xlatemat );
d3714 1
a3714 1
			    bn_mat_idn( xlatemat );
d3719 1
a3719 1
				bn_mat_idn( xlatemat );
d4000 1
a4000 1
				bn_mat_idn( modelchanges );
d4011 1
a4011 1
				bn_mat_idn( modelchanges );
d4056 1
a4056 1
			bn_mat_idn( incr_change );
d4078 1
a4078 1
				bn_mat_idn( modelchanges );
d4089 1
a4089 1
				bn_mat_idn( modelchanges );
d4113 1
a4113 1
			bn_mat_idn( incr_change );
d4135 1
a4135 1
				bn_mat_idn( modelchanges );
d4146 1
a4146 1
				bn_mat_idn( modelchanges );
d4170 1
a4170 1
			bn_mat_idn( incr_change );
d4192 1
a4192 1
				bn_mat_idn( modelchanges );
d4203 1
a4203 1
				bn_mat_idn( modelchanges );
d4239 1
a4239 1
			bn_mat_idn( incr_change );
d4261 1
a4261 1
				bn_mat_idn( modelchanges );
d4272 1
a4272 1
				bn_mat_idn( modelchanges );
d4298 1
a4298 1
		bn_mat_idn( incr_change );
d5675 1
a5675 1
      bn_mat_idn( xlatemat );
d6043 1
a6043 1
      bn_mat_idn( xlatemat );
d6260 1
a6260 1
  bn_mat_idn( incr_change );
d6324 1
a6324 1
    bn_mat_idn( incr_change );
d6350 1
a6350 1
    bn_mat_idn( incr_change );
d6371 1
a6371 1
  bn_mat_idn( incr_mat );
d6397 1
a6397 1
  bn_mat_idn( incr_mat );
d7302 1
a7302 1
	bn_mat_idn(es_mat);
d7377 2
a7378 2
	bn_mat_idn(modelchanges);
	bn_mat_idn(acc_rot_sol);
d7427 4
a7430 4
		bn_mat_idn(topm);
		bn_mat_idn(inv_topm);
		bn_mat_idn(deltam);
		bn_mat_idn(tempm);
d7884 1
a7884 1
	bn_mat_idn( incr_change );
d7911 1
a7911 1
	bn_mat_idn( incr_change );
d9163 1
a9163 1
  bn_mat_idn(acc_rot_sol);
d9276 1
a9276 1
	bn_mat_idn(es_mat);
@


11.160
log
@*- mods to mged_param()
   - fixed typo in "if" statement that always caused the corresponding
     code segment to be executed
   - check to see that scale operations only get one argument, while
     all other operations get three
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.159 2000/11/09 15:39:17 jra Exp $ (BRL)";
d606 1
a606 1
	{"File Name", dsp_ed, MENU_DSP_FNAME },
d2739 1
a2739 1
			fname = get_file_name( bu_vls_addr(&dsp->dsp_file) );
d2760 1
a2760 1
			bu_vls_strcpy( &dsp->dsp_file, fname );
@


11.159
log
@Correct labels for BOT face mode selection box
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.158 2000/10/24 19:56:43 mike Exp $ (BRL)";
d7738 7
a7744 1
    if( es_menu == MENU_PIPE_PT_OD || es_menu == MENU_PIPE_PT_ID || MENU_PIPE_SCALE_ID )
d7761 6
@


11.158
log
@
possible uninit
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.157 2000/10/24 19:05:06 mike Exp $ (BRL)";
d3221 2
a3222 2
					       " { {Thickness appended to hit point} {Thickness centered about hit point} }",
					       " { {This selection will place the plate thickness rayward of the hit point} {This selection will place the plate thickness centered about the hit point} } ",
@


11.157
log
@
Fixed compiler lint, function declarations.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.156 2000/10/24 15:01:55 mike Exp $ (BRL)";
d2555 1
a2555 1
  int fixv;
@


11.156
log
@
BoT support routines now have rt_bot prefix
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.155 2000/10/20 05:04:38 mike Exp $ (BRL)";
d49 1
a51 1
#include "rtgeom.h"
d2305 1
a2305 1
init_sedit()
d2439 1
a2439 1
replot_editing_solid()
d2458 5
a2462 5
transform_editing_solid(os, mat, is, free)
struct rt_db_internal	*os;		/* output solid */
CONST mat_t		mat;
struct rt_db_internal	*is;		/* input solid */
int			free;
d3355 1
a3355 1
				rt_sketch_ifree( &tmp_ip );
d5608 1
a5608 2
sedit_mouse( mousevec )
CONST vect_t	mousevec;
d6223 1
a6223 1
sedit_abs_scale()
d6252 1
a6252 2
objedit_mouse( mousevec )
CONST vect_t	mousevec;
d6390 1
a6390 1
oedit_abs_scale()
d6460 1
a6460 4
vls_solid( vp, ip, mat )
register struct bu_vls		*vp;
CONST struct rt_db_internal	*ip;
CONST mat_t			mat;
d6504 1
a6504 1
			vls_pipept( vp, seg_no, &intern, base2local );
d7386 1
a7386 1
init_oedit()
d7463 1
a7463 1
oedit_accept()
d7489 1
a7489 1
oedit_reject()
a7562 1
void sedit_reject();
d7640 1
a7640 1
sedit_accept()
d7662 1
a7662 1
sedit_reject()
d7924 7
a7930 7
label_edited_solid( num_lines, lines, pl, max_pl, xform, ip )
int *num_lines;
point_t *lines;
struct rt_point_labels	pl[];
int			max_pl;
CONST mat_t		xform;
struct rt_db_internal	*ip;
d8442 5
a8446 5
rt_arb_calc_planes( planes, arb, type, tol )
plane_t			planes[6];
struct rt_arb_internal	*arb;
int			type;
CONST struct bn_tol	*tol;
d8478 1
a8478 2
sedit_vpick( v_pos )
point_t	v_pos;
d8666 7
a8672 7
nurb_closest2d(surface, uval, vval, spl, ref_pt, mat )
int				*surface;
int				*uval;
int				*vval;
CONST struct rt_nurb_internal	*spl;
CONST point_t			ref_pt;
CONST mat_t			mat;
@


11.155
log
@
s_path array has been replaced by a s_fullpath "struct db_full_path".
This has eliminated the MAX_PATH restriction in MGED.
member s_last is gone too.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.154 2000/10/18 14:23:46 bparker Exp $ (BRL)";
d5802 1
a5802 1
  	tmp_vert = bot_find_v_nearest_pt2( bot, pos_view, view_state->vs_model2view );
d5830 1
a5830 1
    	if( bot_find_e_nearest_pt2( &vert1, &vert2, bot, pos_view, view_state->vs_model2view ) )
@


11.154
log
@*** empty log message ***
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.153 2000/09/09 05:02:54 mike Exp $ (BRL)";
d2323 4
a2326 2
	if( rt_db_get_internal( &es_int, illump->s_path[(int)(illump->s_last)], dbip, NULL, &rt_uniresource ) < 0 )  {
	  Tcl_AppendResult(interp, "init_sedit(", illump->s_path[(int)(illump->s_last)]->d_namep,
d2367 1
a2367 1
	pathHmat( illump, es_mat, illump->s_last-1 );
d2443 1
d2446 2
a2447 2
    if(sp->s_path[(int)(sp->s_last)]->d_addr == illump->s_path[(int)(illump->s_last)]->d_addr){
      pathHmat( sp, mat, sp->s_last-1 );
d7325 4
a7328 2
	if( rt_db_get_internal( &es_int, illump->s_path[(int)(illump->s_last)], dbip, NULL, &rt_uniresource ) < 0 )  {
		Tcl_AppendResult(interp, "init_oedit(", illump->s_path[(int)(illump->s_last)]->d_namep,
d7347 1
a7347 1
	pathHmat(illump, es_mat, illump->s_last-1);
d7423 2
a7424 1
		moveHobj(illump->s_path[ipathpos], modelchanges);
d7427 2
a7428 2
		moveHinstance(illump->s_path[ipathpos-1],
			      illump->s_path[ipathpos],
d7444 2
a7445 2
		moveHinstance(illump->s_path[ipathpos-1],
			      illump->s_path[ipathpos],
d7595 1
a7595 1
	dp = illump->s_path[(int)(illump->s_last)];
d7697 1
a7697 1
	    if(sp->s_path[(int)(sp->s_last)]->d_addr == illump->s_path[(int)(illump->s_last)]->d_addr)
a8963 1
  int i;
d8993 1
a8993 1
    Tcl_AppendStringsToObj(pnto, illump->s_path[(int)(illump->s_last)]->d_namep, " ",
d9017 6
a9022 2
  for(i=0; i <= illump->s_last; i++){
    Tcl_AppendStringsToObj(pnto, "/", illump->s_path[i]->d_namep, (char *)0);
d9143 4
a9146 2
  if( rt_db_get_internal( &es_int, illump->s_path[(int)(illump->s_last)], dbip, NULL, &rt_uniresource ) < 0 )  {
    Tcl_AppendResult(interp, "sedit_reset(", illump->s_path[(int)(illump->s_last)]->d_namep,
d9272 1
a9272 1
	pathHmat(illump, es_mat, illump->s_last-1);
@


11.153
log
@
Lint
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.152 2000/09/09 04:30:55 mike Exp $ (BRL)";
d83 2
a84 2
vect_t e_axes_pos;
vect_t curr_e_axes_pos;
@


11.152
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.151 2000/09/08 05:55:48 mike Exp $ (BRL)";
d1384 1
a1384 1
			if( !lu | *lu->up.magic_p != NMG_SHELL_MAGIC )
d2323 2
a2324 2
	if( rt_db_get_internal( &es_int, illump->s_path[illump->s_last], dbip, NULL, &rt_uniresource ) < 0 )  {
	  Tcl_AppendResult(interp, "init_sedit(", illump->s_path[illump->s_last]->d_namep,
d2443 1
a2443 1
    if(sp->s_path[sp->s_last]->d_addr == illump->s_path[illump->s_last]->d_addr){
d3318 1
a3318 1
			char *sketch_name, *curve_name;
d7322 2
a7323 2
	if( rt_db_get_internal( &es_int, illump->s_path[illump->s_last], dbip, NULL, &rt_uniresource ) < 0 )  {
		Tcl_AppendResult(interp, "init_oedit(", illump->s_path[illump->s_last]->d_namep,
d7589 1
a7589 1
	dp = illump->s_path[illump->s_last];
a7641 2
	struct directory	*dp;

d7691 1
a7691 1
	    if(sp->s_path[sp->s_last]->d_addr == illump->s_path[illump->s_last]->d_addr)
@


11.151
log
@
Tree routines now need resource structure.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.150 2000/08/25 01:36:38 mike Exp $ (BRL)";
d6479 1
a6479 1
		    base2local ) < 0 )
d6485 1
a6485 1
		    base2local ) < 0 )
@


11.150
log
@
lint
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.149 2000/08/19 03:10:45 mike Exp $ (BRL)";
d2323 1
a2323 1
	if( rt_db_get_internal( &es_int, illump->s_path[illump->s_last], dbip, NULL ) < 0 )  {
d2326 1
a2326 1
	  rt_db_free_internal( &es_int );
d2347 1
a2347 1
		  rt_db_free_internal( &es_int );
d2462 1
a2462 1
	if( rt_functab[is->idb_type].ft_xform( os, mat, is, free, dbip ) < 0 )
d3365 1
a3365 1
			        if( rt_db_get_internal( &tmp_ip, dp, dbip, bn_mat_identity ) != ID_SKETCH )
d6509 1
a6509 1
	rt_db_free_internal( &intern );
d7322 1
a7322 1
	if( rt_db_get_internal( &es_int, illump->s_path[illump->s_last], dbip, NULL ) < 0 )  {
d7325 1
a7325 1
		rt_db_free_internal( &es_int );
d7490 1
a7490 1
	rt_db_free_internal(&es_int);
d7618 1
a7618 1
	if( rt_db_put_internal( dp, dbip, &es_int ) < 0 )  {
d7622 1
a7622 1
			rt_db_free_internal(&es_int);
d7633 1
a7633 1
		rt_db_free_internal(&es_int);
d7703 1
a7703 1
	rt_db_free_internal( &es_int );
d9023 1
a9023 1
  rt_db_free_internal( &ces_int );
d9133 1
a9133 1
  rt_db_free_internal( &es_int );
d9136 1
a9136 1
  if( rt_db_get_internal( &es_int, illump->s_path[(int)(illump->s_last)], dbip, NULL ) < 0 )  {
@


11.149
log
@
const RCSid
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.148 2000/08/11 02:41:34 mike Exp $ (BRL)";
d8990 1
a8990 1
    Tcl_AppendStringsToObj(pnto, illump->s_path[illump->s_last]->d_namep, " ",
d9136 2
a9137 2
  if( rt_db_get_internal( &es_int, illump->s_path[illump->s_last], dbip, NULL ) < 0 )  {
    Tcl_AppendResult(interp, "sedit_reset(", illump->s_path[illump->s_last]->d_namep,
@


11.148
log
@
Added comment.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.147 2000/06/29 14:55:38 butler Exp $ (BRL)";
@


11.147
log
@Updates to DSP code
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.146 2000/06/28 17:40:22 mike Exp $ (BRL)";
d2735 1
@


11.146
log
@
Eliminated es_ext
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.145 2000/06/28 17:11:24 mike Exp $ (BRL)";
d2735 1
a2735 1
			fname = get_file_name( dsp->dsp_file );
d2756 1
a2756 1
			strcpy( dsp->dsp_file, fname );
@


11.145
log
@
Made proper use of rt_db_free_internal()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.144 2000/06/20 19:16:54 jra Exp $ (BRL)";
a94 1
struct bu_external	es_ext;
d2322 2
a2323 10
	/* Read solid description.  Save copy of original data */
	BU_INIT_EXTERNAL(&es_ext);
	if( db_get_external( &es_ext, illump->s_path[illump->s_last], dbip ) < 0 ){
	  TCL_READ_ERR;
	  return;
	}

	RT_INIT_DB_INTERNAL(&es_int);
	id = rt_id_solid( &es_ext );
	if( rt_functab[id].ft_import( &es_int, &es_ext, bn_mat_identity, dbip ) < 0 )  {
a2326 1
	  db_free_external( &es_ext );
d2330 1
a2346 1
		  db_free_external( &es_ext );
d7321 1
a7321 9
	if (db_get_external(&es_ext, illump->s_path[illump->s_last], dbip) < 0) {
		Tcl_AppendResult(interp, "init_oedit(", illump->s_path[illump->s_last]->d_namep,
				 "): db_get_external failure\n", (char *)NULL);
		button(BE_REJECT);
		return;
	}

	id = rt_id_solid(&es_ext);
	if (rt_functab[id].ft_import(&es_int, &es_ext, bn_mat_identity, dbip) < 0) {
d7325 1
a7325 1
		db_free_external(&es_ext);
d7329 1
a7489 1
	db_free_external(&es_ext);
d7617 1
a7617 1
	if (rt_functab[es_int.idb_type].ft_export( &es_ext, &es_int, 1.0, dbip) < 0)  {
a7621 1
			db_free_external(&es_ext);
a7625 9
    	if (accept_flag)
		rt_db_free_internal(&es_int);

	if (db_put_external(&es_ext, dp, dbip) < 0) {
		if (accept_flag)
			db_free_external(&es_ext);
		TCL_WRITE_ERR_return;
	}

a7632 1
		db_free_external(&es_ext);
a7702 1
	db_free_external( &es_ext );
d9108 3
a9117 1
  int id;
d9135 2
a9136 4
  RT_INIT_DB_INTERNAL(&es_int);
  id = rt_id_solid( &es_ext );
  if( rt_functab[id].ft_import( &es_int, &es_ext, bn_mat_identity, dbip ) < 0 )  {
    Tcl_AppendResult(interp, "init_sedit(", illump->s_path[illump->s_last]->d_namep,
a9137 2
    rt_db_free_internal( &es_int );
    db_free_external( &es_ext );
@


11.144
log
@Corrected bug in BOT triangle selection
Made bit vector handling for BOT triangle deletion safer
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.143 2000/06/20 18:29:01 jra Exp $ (BRL)";
d2335 1
a2335 1
	  if( es_int.idb_ptr )  rt_functab[id].ft_ifree( &es_int );
d2357 1
a2357 1
		  rt_functab[id].ft_ifree( &es_int );
d6518 1
a6518 1
	rt_functab[id].ft_ifree( &intern );
d7342 1
a7342 2
		if (es_int.idb_ptr)
			rt_functab[id].ft_ifree( &es_int );
d7506 1
a7506 3
	if (es_int.idb_ptr)
		rt_functab[es_int.idb_type].ft_ifree(&es_int);
	es_int.idb_ptr = (genptr_t)NULL;
d7639 1
a7639 2
			if (es_int.idb_ptr)
				rt_functab[es_int.idb_type].ft_ifree(&es_int);
d7645 2
a7646 2
    	if (es_int.idb_ptr && accept_flag)
		rt_functab[es_int.idb_type].ft_ifree(&es_int);
d7660 1
a7660 3
		if (es_int.idb_ptr)
			rt_functab[es_int.idb_type].ft_ifree(&es_int);
		es_int.idb_ptr = (genptr_t)NULL;
d7731 1
a7731 2
    	if( es_int.idb_ptr )  rt_functab[es_int.idb_type].ft_ifree( &es_int );
	es_int.idb_ptr = (genptr_t)NULL;
d9052 1
a9052 2
  if( ces_int.idb_ptr )
    rt_functab[ces_int.idb_type].ft_ifree( &ces_int );
d9160 1
a9160 2
  if(es_int.idb_ptr)
    rt_functab[es_int.idb_type].ft_ifree(&es_int);
d9168 1
a9168 1
    if( es_int.idb_ptr )  rt_functab[id].ft_ifree( &es_int );
@


11.144.2.1
log
@Corrected labels for BOT face mode editing pop-up
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.144 2000/06/20 19:16:54 jra Exp $ (BRL)";
d3227 2
a3228 2
					       " { {Thickness centered about hit point} {Thickness appended to hit point} }",
					       " { {This selection will place the plate thickness centered about the hit point} {This selection will place the plate thickness rayward of the hit point} } ",
@


11.144.2.2
log
@*- mods to mged_param()
   - fixed typo in "if" statement that always caused the corresponding
     code segment to be executed
   - check to see that scale operations only get one argument, while
     all other operations get three
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.144.2.1 2000/11/09 14:38:54 jra Exp $ (BRL)";
d7776 1
a7776 7
    if (inpara != 1) {
	    Tcl_AppendResult(interp, "ERROR: only one argument needed\n", (char *)NULL);
	    inpara = 0;
	    return TCL_ERROR;
    }

    if( es_menu == MENU_PIPE_PT_OD || es_menu == MENU_PIPE_PT_ID || es_menu == MENU_PIPE_SCALE_ID )
a7792 6
  } else {
    if (inpara != 3) {
	    Tcl_AppendResult(interp, "ERROR: three arguments needed\n", (char *)NULL);
	    inpara = 0;
	    return TCL_ERROR;
    }
@


11.143
log
@Added triangle removal to BOT editing
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.142 2000/06/08 21:28:03 bparker Exp $ (BRL)";
d622 1
a626 1
	{ "Delete Face", bot_ed, ECMD_BOT_FDEL },
d3300 9
d3313 1
a3313 3
						BU_BITSET( bot->face_mode, i );
					else
						BU_BITCLR( bot->face_mode, i );
d3315 2
d5894 1
d5898 2
a5899 3
	  		bot_verts[0] = v1;
	  		bot_verts[1] = v2;
	  		bot_verts[2] = v3;
@


11.142
log
@Comment out sedit_rotate and objedit_rotate
since they're not being used.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.141 2000/06/07 20:41:29 bparker Exp $ (BRL)";
d217 9
a225 8
#define MENU_EXTR_SCALE_H	101
#define MENU_EXTR_MOV_H		102
#define MENU_EXTR_ROT_H		103
#define MENU_EXTR_SKT_NAME	104
#define	MENU_CLINE_SCALE_H	105
#define	MENU_CLINE_MOVE_H	106
#define MENU_CLINE_SCALE_R	107
#define	MENU_CLINE_SCALE_T	108
d626 1
d3254 58
@


11.141
log
@Changing a few forgotten helpdevel commands
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.140 2000/06/06 19:42:14 bparker Exp $ (BRL)";
d7826 1
d7884 1
@


11.140
log
@*- changed Scale to Set in the
   solid specific menus
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.139 2000/06/05 21:51:18 bparker Exp $ (BRL)";
d9010 1
a9010 1
    bu_vls_printf(&vls, "helpdevel put_sedit");
d9090 1
a9090 1
    bu_vls_printf(&vls, "helpdevel reset_edit_solid");
d9194 1
a9194 1
		bu_vls_printf(&vls, "helpdevel reset_edit_matrix");
@


11.139
log
@*- add f_oedit_apply
*- mods to f_sedit_apply
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.137 2000/06/02 20:22:16 bparker Exp $ (BRL)";
d230 1
a230 1
	{ "Scale H",		cline_ed, ECMD_CLINE_SCALE_H },
d232 2
a233 2
	{ "Scale R",		cline_ed, ECMD_CLINE_SCALE_R },
	{ "Scale plate thickness", cline_ed, ECMD_CLINE_SCALE_T },
d239 1
a239 1
	{ "Scale H",		extr_ed, ECMD_EXTR_SCALE_H },
d348 9
a356 9
	{ "Scale H",	tgc_ed, MENU_TGC_SCALE_H },
	{ "Scale H (move V)", tgc_ed, MENU_TGC_SCALE_H_V },
	{ "Scale A",	tgc_ed, MENU_TGC_SCALE_A },
	{ "Scale B",	tgc_ed, MENU_TGC_SCALE_B },
	{ "Scale c",	tgc_ed, MENU_TGC_SCALE_C },
	{ "Scale d",	tgc_ed, MENU_TGC_SCALE_D },
	{ "Scale A,B",	tgc_ed, MENU_TGC_SCALE_AB },
	{ "Scale C,D",	tgc_ed, MENU_TGC_SCALE_CD },
	{ "Scale A,B,C,D", tgc_ed, MENU_TGC_SCALE_ABCD },
d366 2
a367 2
	{ "Scale Radius 1", tor_ed, MENU_TOR_R1 },
	{ "Scale Radius 2", tor_ed, MENU_TOR_R2 },
d373 3
a375 3
	{ "Scale r", eto_ed, MENU_ETO_R },
	{ "Scale D", eto_ed, MENU_ETO_RD },
	{ "Scale C", eto_ed, MENU_ETO_SCALE_C },
d382 4
a385 4
	{ "Scale A", ell_ed, MENU_ELL_SCALE_A },
	{ "Scale B", ell_ed, MENU_ELL_SCALE_B },
	{ "Scale C", ell_ed, MENU_ELL_SCALE_C },
	{ "Scale A,B,C", ell_ed, MENU_ELL_SCALE_ABC },
d528 3
a530 3
	{ "Scale H", part_ed, MENU_PART_H },
	{ "Scale v", part_ed, MENU_PART_v },
	{ "Scale h", part_ed, MENU_PART_h },
d536 3
a538 3
	{ "Scale B", rpc_ed, MENU_RPC_B },
	{ "Scale H", rpc_ed, MENU_RPC_H },
	{ "Scale r", rpc_ed, MENU_RPC_R },
d544 4
a547 4
	{ "Scale B", rhc_ed, MENU_RHC_B },
	{ "Scale H", rhc_ed, MENU_RHC_H },
	{ "Scale r", rhc_ed, MENU_RHC_R },
	{ "Scale c", rhc_ed, MENU_RHC_C },
d553 3
a555 3
	{ "Scale H", epa_ed, MENU_EPA_H },
	{ "Scale A", epa_ed, MENU_EPA_R1 },
	{ "Scale B", epa_ed, MENU_EPA_R2 },
d561 4
a564 4
	{ "Scale H", ehy_ed, MENU_EHY_H },
	{ "Scale A", ehy_ed, MENU_EHY_R1 },
	{ "Scale B", ehy_ed, MENU_EHY_R2 },
	{ "Scale c", ehy_ed, MENU_EHY_C },
d577 6
a582 6
	{ "Scale Point OD", pipe_ed, MENU_PIPE_PT_OD },
	{ "Scale Point ID", pipe_ed, MENU_PIPE_PT_ID },
	{ "Scale Point Bend", pipe_ed, MENU_PIPE_PT_RADIUS },
	{ "Scale Pipe OD", pipe_ed, MENU_PIPE_SCALE_OD },
	{ "Scale Pipe ID", pipe_ed, MENU_PIPE_SCALE_ID },
	{ "Scale Pipe Bend", pipe_ed, MENU_PIPE_SCALE_RADIUS },
d607 3
a609 3
	{"Scale X", dsp_ed, MENU_DSP_SCALE_X },
	{"Scale Y", dsp_ed, MENU_DSP_SCALE_Y },
	{"Scale ALT", dsp_ed, MENU_DSP_SCALE_ALT },
@


11.138
log
@
Added return code to silence lint.
@
text
@d8 1
a8 1
 *	init_objedit	set up for object edit?
d78 1
a79 2
static int sedit_apply();
int get_edit_solid_menus();
d2101 1
a2101 1
get_solid_keypoint_tcl(clientData, interp, argc, argv)
d2398 1
d2400 13
a2412 1
#if 1
d2414 1
a2414 1
	bn_mat_idn( incr_change );
d2416 10
a2425 10
	VSETALL( edit_absolute_model_rotate, 0.0 );
	VSETALL( edit_absolute_object_rotate, 0.0 );
	VSETALL( edit_absolute_view_rotate, 0.0 );
	VSETALL( last_edit_absolute_model_rotate, 0.0 );
	VSETALL( last_edit_absolute_object_rotate, 0.0 );
	VSETALL( last_edit_absolute_view_rotate, 0.0 );
	VSETALL( edit_absolute_model_tran, 0.0 );
	VSETALL( edit_absolute_view_tran, 0.0 );
	VSETALL( last_edit_absolute_model_tran, 0.0 );
	VSETALL( last_edit_absolute_view_tran, 0.0 );
d2429 5
a2433 5
	VSETALL( edit_rate_model_rotate, 0.0 );
	VSETALL( edit_rate_object_rotate, 0.0 );
	VSETALL( edit_rate_view_rotate, 0.0 );
	VSETALL( edit_rate_model_tran, 0.0 );
	VSETALL( edit_rate_view_tran, 0.0 );
a2435 10

	{
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "begin_edit_callback");
	  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	}
#endif
d6255 1
d6257 3
d6269 1
d6271 3
d6311 1
d6313 3
d6383 1
d6385 3
d7235 2
a7236 2
void
init_objedit_guts()
d7246 2
a7247 2
	if(dbip == DBI_NULL)
	  return;
d7252 1
a7252 2
	if( illump->s_Eflag )  {

d7262 5
a7266 5
	if( db_get_external( &es_ext, illump->s_path[illump->s_last], dbip ) < 0 )  {
	  Tcl_AppendResult(interp, "init_objedit(", illump->s_path[illump->s_last]->d_namep,
			   "): db_get_external failure\n", (char *)NULL);
	  button(BE_REJECT);
	  return;
d7269 8
a7276 7
	id = rt_id_solid( &es_ext );
	if( rt_functab[id].ft_import( &es_int, &es_ext, bn_mat_identity, dbip ) < 0 )  {
	  Tcl_AppendResult(interp, "init_objedit(", illump->s_path[illump->s_last]->d_namep,
			   "):  solid import failure\n", (char *)NULL);
	  if( es_int.idb_ptr )  rt_functab[id].ft_ifree( &es_int );
	  db_free_external( &es_ext );
	  return;				/* FAIL */
d7278 1
a7278 1
	RT_CK_DB_INTERNAL( &es_int );
d7280 1
a7280 2
	if( id == ID_ARB8 )
	{
d7284 1
a7284 1
		RT_ARB_CK_MAGIC( arb );
d7286 1
a7286 1
		es_type = rt_arb_std_type( &es_int , &mged_tol );
d7290 1
a7290 1
	pathHmat( illump, es_mat, illump->s_last-1 );
d7293 5
a7297 1
	bn_mat_inv( es_invmat, es_mat );
d7299 3
a7301 1
	get_solid_keypoint( es_keypoint , &strp , &es_int , es_mat );
d7304 10
a7313 10
	VSETALL( edit_absolute_model_rotate, 0.0 );
	VSETALL( edit_absolute_object_rotate, 0.0 );
	VSETALL( edit_absolute_view_rotate, 0.0 );
	VSETALL( last_edit_absolute_model_rotate, 0.0 );
	VSETALL( last_edit_absolute_object_rotate, 0.0 );
	VSETALL( last_edit_absolute_view_rotate, 0.0 );
	VSETALL( edit_absolute_model_tran, 0.0 );
	VSETALL( edit_absolute_view_tran, 0.0 );
	VSETALL( last_edit_absolute_model_tran, 0.0 );
	VSETALL( last_edit_absolute_view_tran, 0.0 );
d7317 7
a7323 1
	VSETALL( acc_sc, 1.0 );
d7325 2
a7326 5
	VSETALL( edit_rate_model_rotate, 0.0 );
	VSETALL( edit_rate_object_rotate, 0.0 );
	VSETALL( edit_rate_view_rotate, 0.0 );
	VSETALL( edit_rate_model_tran, 0.0 );
	VSETALL( edit_rate_view_tran, 0.0 );
d7334 1
a7334 1
init_objedit()
d7336 4
a7339 1
  struct bu_vls		vls;
d7341 1
a7341 2
  /* do real initialization work */
  init_objedit_guts();
d7343 5
a7347 5
  /* begin edit callback */
  bu_vls_init(&vls);
  bu_vls_strcpy(&vls, "begin_edit_callback");
  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d7352 2
a7353 2
void
oedit_accept()
d7364 1
a7364 19
	if(dbip == DBI_NULL)
	  return;

	if( dbip->dbi_read_only )
	{
		oedit_reject();
		FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
			if( sp->s_iflag == DOWN )
				continue;
			(void)replot_original_solid( sp );
			sp->s_iflag = DOWN;
		}
		bu_log( "Sorry, this database is READ-ONLY\n" );
		pr_prompt();

		return;
	}

	switch( ipathpos )  {
d7366 1
a7366 1
		moveHobj( illump->s_path[ipathpos], modelchanges );
d7369 3
a7371 5
		moveHinstance(
			illump->s_path[ipathpos-1],
			illump->s_path[ipathpos],
			modelchanges
		);
d7374 15
a7388 17
		bn_mat_idn( topm );
		bn_mat_idn( inv_topm );
		bn_mat_idn( deltam );
		bn_mat_idn( tempm );

		pathHmat( illump, topm, ipathpos-2 );

		bn_mat_inv( inv_topm, topm );

		bn_mat_mul( tempm, modelchanges, topm );
		bn_mat_mul( deltam, inv_topm, tempm );

		moveHinstance(
			illump->s_path[ipathpos-1],
			illump->s_path[ipathpos],
			deltam
		);
a7399 5
#if 0
	view_state->vs_flag=1;
	refresh();
#endif

d7401 2
a7402 2
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
		if( sp->s_iflag == DOWN )
d7404 1
a7404 1
		(void)replot_original_solid( sp );
d7407 23
d7431 1
d7438 4
a7441 7
  bn_mat_idn( modelchanges );
  bn_mat_idn( acc_rot_sol );
  es_edclass = EDIT_CLASS_NULL;

  if( es_int.idb_ptr )  rt_functab[es_int.idb_type].ft_ifree( &es_int );
  es_int.idb_ptr = (genptr_t)NULL;
  db_free_external( &es_ext );
d7515 89
d7609 2
a7610 2
	if(dbip == DBI_NULL)
	  return;
d7612 2
a7613 1
	if( not_state( ST_S_EDIT, "Solid edit accept" ) )  return;
d7615 1
a7615 2
	if( dbip->dbi_read_only )
	{
d7622 2
a7623 2
	if( sedraw > 0)
	  sedit();
d8694 1
a8694 1
f_keypoint (clientData, interp, argc, argv)
d8757 2
a8758 1
get_edit_solid_menus(clientData, interp, argc, argv)
d8919 1
a8919 1
f_get_edit_solid(clientData, interp, argc, argv)
d8935 1
a8935 1
    bu_vls_printf(&vls, "helpdevel get_edit_solid");
d8942 1
a8942 1
    Tcl_AppendResult(interp, "get_edit_solid: must be in solid edit state", (char *)0);
d8963 1
a8963 1
    Tcl_AppendResult(interp, "Usage: get_edit_solid [-c]", (char *)0);
d8995 1
a8995 1
f_put_edit_solid(clientData, interp, argc, argv)
d9010 1
a9010 1
    bu_vls_printf(&vls, "helpdevel put_edit_solid");
d9017 1
a9017 1
    Tcl_AppendResult(interp, "put_edit_solid: must be in solid edit state", (char *)0);
d9032 1
a9032 1
    Tcl_AppendResult( interp, "put_edit_solid: ", argv[1],
d9041 1
a9041 1
		      "put_edit_solid: idb_meth type mismatch",
d9076 1
a9076 1
f_reset_edit_solid(clientData, interp, argc, argv)
d9149 6
a9154 7
/*
 * Copied from sedit_accept - modified to optionally leave
 *                            solid edit state.
 */
static int
sedit_apply(accept_flag)
     int	accept_flag;
d9156 1
a9156 1
	struct directory	*dp;
d9158 1
a9158 8
	es_eu = (struct edgeuse *)NULL;	/* Reset es_eu */
	es_pipept = (struct wdb_pipept *)NULL; /* Reset es_pipept */
	bot_verts[0] = -1;
	bot_verts[1] = -1;
	bot_verts[2] = -1;
	
	if (lu_copy) {
		struct model *m;
d9160 3
a9162 3
		m = nmg_find_model(&lu_copy->l.magic);
		nmg_km(m);
		lu_copy = (struct loopuse *)NULL;
d9165 5
a9169 2
	/* write editing changes out to disc */
	dp = illump->s_path[illump->s_last];
d9171 5
a9175 3
	/* make sure that any BOT solid is minimally legal */
	if (es_int.idb_type == ID_BOT) {
		struct rt_bot_internal *bot = (struct rt_bot_internal *)es_int.idb_ptr;
d9177 2
a9178 21
		RT_BOT_CK_MAGIC(bot);
		if (bot->mode == RT_BOT_SURFACE || bot->mode == RT_BOT_SOLID) {
			/* make sure facemodes and thicknesses have been freed */
			if (bot->thickness) {
				bu_free( (char *)bot->thickness, "BOT thickness" );
				bot->thickness = NULL;
			}
			if (bot->face_mode) {
				bu_free( (char *)bot->face_mode, "BOT face_mode" );
				bot->face_mode = NULL;
			}
		} else {
			/* make sure face_modes and thicknesses exist */
			if (!bot->thickness)
				bot->thickness = (fastf_t *)bu_calloc( bot->num_faces, sizeof( fastf_t ), "BOT thickness" );
			if (!bot->face_mode) {
				bot->face_mode = bu_bitv_new( bot->num_faces );
				bu_bitv_clear( bot->face_mode );
			}
		}
	}
d9180 8
a9187 11
	/* Scale change on export is 1.0 -- no change */
	if (rt_functab[es_int.idb_type].ft_export( &es_ext, &es_int, 1.0, dbip) < 0)  {
		Tcl_AppendResult(interp, "sedit_apply(", dp->d_namep,
				 "):  solid export failure\n", (char *)NULL);
		if (accept_flag) {
			if (es_int.idb_ptr)
				rt_functab[es_int.idb_type].ft_ifree(&es_int);
			db_free_external(&es_ext);
		}
		return TCL_ERROR;				/* FAIL */
	}
d9189 2
a9190 2
    	if (es_int.idb_ptr && accept_flag)
		rt_functab[es_int.idb_type].ft_ifree(&es_int);
d9192 6
a9197 4
	if (db_put_external(&es_ext, dp, dbip) < 0) {
		if (accept_flag)
			db_free_external(&es_ext);
		TCL_WRITE_ERR_return;
d9200 5
a9204 5
	if (accept_flag) {
		menu_state->ms_flag = 0;
		movedir = 0;
		es_edflag = -1;
		es_edclass = EDIT_CLASS_NULL;
d9206 5
a9210 5
		if (es_int.idb_ptr)
			rt_functab[es_int.idb_type].ft_ifree(&es_int);
		es_int.idb_ptr = (genptr_t)NULL;
		db_free_external(&es_ext);
	}
d9216 1
a9216 1
f_sedit_apply(clientData, interp, argc, argv)
d9222 2
a9223 1
	RT_CK_DBI_TCL(interp, dbip);
d9225 2
a9226 2
	if (not_state(ST_S_EDIT, "Solid edit accept"))
		return TCL_ERROR;
d9228 1
a9228 2
	if (sedraw > 0)
		sedit();
d9230 3
a9232 2
	return sedit_apply(0);
}
d9234 2
a9235 8
int
f_reset_edit_matrix(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  struct bu_vls vls;
d9237 4
a9240 2
  if(state != ST_O_EDIT)
    return TCL_ERROR;
d9242 5
a9246 7
  if(argc != 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helpdevel reset_edit_matrix");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d9248 1
a9248 13
  oedit_reject();
  init_objedit_guts();

  new_mats();
  update_views = 1;

  /* active edit callback */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "active_edit_callback");
  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);

  return TCL_OK;
@


11.137
log
@New command (f_sedit_apply) to push solid edits to
  the database while remaining in solid edit state.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.136 2000/03/31 02:57:05 mike Exp $ (BRL)";
d9133 1
a9133 2
	if (dbip == DBI_NULL)
		return;
d9136 1
a9136 1
		return;
@


11.136
log
@
Fixed typo
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.135 2000/03/29 22:24:30 bparker Exp $ (BRL)";
d79 1
d7514 1
a7514 74
	es_eu = (struct edgeuse *)NULL;	/* Reset es_eu */
	es_pipept = (struct wdb_pipept *)NULL; /* Reset es_pipept */
	bot_verts[0] = -1;
	bot_verts[1] = -1;
	bot_verts[2] = -1;
	if( lu_copy )
	{
		struct model *m;

		m = nmg_find_model( &lu_copy->l.magic );
		nmg_km( m );
		lu_copy = (struct loopuse *)NULL;
	}

	/* write editing changes out to disc */
	dp = illump->s_path[illump->s_last];

	/* make sure that any BOT solid is minimally legal */
	if( es_int.idb_type == ID_BOT )
	  {
	    struct rt_bot_internal *bot = (struct rt_bot_internal *)es_int.idb_ptr;

	    RT_BOT_CK_MAGIC( bot );
	    if( bot->mode == RT_BOT_SURFACE || bot->mode == RT_BOT_SOLID )
	      {
		/* make sure facemodes and thicknesses have been freed */
		if( bot->thickness )
		  {
		    bu_free( (char *)bot->thickness, "BOT thickness" );
		    bot->thickness = NULL;
		  }
		if( bot->face_mode )
		  {
		    bu_free( (char *)bot->face_mode, "BOT face_mode" );
		    bot->face_mode = NULL;
		  }
	      }
	    else
	      {
		/* make sure face_modes and thicknesses exist */
		if( !bot->thickness )
		  bot->thickness = (fastf_t *)bu_calloc( bot->num_faces, sizeof( fastf_t ), "BOT thickness" );
		if( !bot->face_mode )
		  {
		    bot->face_mode = bu_bitv_new( bot->num_faces );
		    bu_bitv_clear( bot->face_mode );
		  }
	      }
	  }

	/* Scale change on export is 1.0 -- no change */
	if( rt_functab[es_int.idb_type].ft_export( &es_ext, &es_int, 1.0, dbip ) < 0 )  {
	  Tcl_AppendResult(interp, "sedit_accept(", dp->d_namep,
			   "):  solid export failure\n", (char *)NULL);
	  if( es_int.idb_ptr )  rt_functab[es_int.idb_type].ft_ifree( &es_int );
	  db_free_external( &es_ext );
	  return;				/* FAIL */
	}
    	if( es_int.idb_ptr )  rt_functab[es_int.idb_type].ft_ifree( &es_int );

	if( db_put_external( &es_ext, dp, dbip ) < 0 )  {
		db_free_external( &es_ext );
		TCL_WRITE_ERR;
		return;
	}

	menu_state->ms_flag = 0;
	movedir = 0;
	es_edflag = -1;
	es_edclass = EDIT_CLASS_NULL;

    	if( es_int.idb_ptr )  rt_functab[es_int.idb_type].ft_ifree( &es_int );
	es_int.idb_ptr = (genptr_t)NULL;
	db_free_external( &es_ext );
d9035 108
@


11.135
log
@*- remove a few extern statements that now live in raytrace.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.134 2000/03/17 15:14:16 jra Exp $ (BRL)";
d8291 1
a8291 1
			point_t work, work1;
d8295 1
a8295 1
			MAT4X3PNT( work, xform, cli->v );
d8299 1
a8299 1
			MAT4X3PNT( work, xform, work1 );
@


11.134
log
@Modified extrusion editing to account for changing sketch to contain only one curve
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.133 2000/03/16 13:39:28 jra Exp $ (BRL)";
a86 1
MGED_EXTERN( fastf_t nmg_loop_plane_area , ( struct loopuse *lu , plane_t pl ) );
@


11.133
log
@Sketch solid can only have one curve now
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.132 2000/03/02 14:48:28 jra Exp $ (BRL)";
d3260 1
d3264 4
a3267 2
			ret_tcl = Tcl_VarEval( interp, "get_sketch", " $mged_gui(mged,screen) ",
				extr->sketch_name, " ", (char *)NULL );
d3269 7
d3277 2
d3295 2
a3296 2
				Tcl_AppendResult(interp, "Warning: ", sketch_name, " does not exist!!!\n",
					(char *)NULL );
@


11.132
log
@Eliminated FGP solid and added CLINE solid
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.131 2000/02/14 21:49:08 bparker Exp $ (BRL)";
d3263 2
a3264 2
			ret_tcl = Tcl_VarEval( interp, "get_sketch_and_curve", " $mged_gui(mged,screen) ",
				extr->sketch_name, " ", extr->curve_name, (char *)NULL );
a3269 2
			curve_name = Tcl_GetVar( interp, "final_curve_name", TCL_GLOBAL_ONLY );
			NAMEMOVE( curve_name, extr->curve_name );
@


11.131
log
@*- mods to call cad_input_dialog
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.130 2000/01/31 13:43:27 jra Exp $ (BRL)";
d72 1
a72 1
static void	nmg_ed(), pipe_ed(), vol_ed(), ebm_ed(), dsp_ed(), fgp_ed(), bot_ed(), extr_ed();
d208 18
a225 17
#define MENU_FGP_SOLID		91
#define MENU_FGP_THICK		92
#define MENU_FGP_MODE		93
#define MENU_BOT_PICKV		94
#define	MENU_BOT_PICKE		95
#define	MENU_BOT_PICKT		96
#define	MENU_BOT_MOVEV		97
#define	MENU_BOT_MOVEE		98
#define	MENU_BOT_MOVET		99
#define	MENU_BOT_MODE		100
#define	MENU_BOT_ORIENT		101
#define	MENU_BOT_THICK		102
#define	MENU_BOT_FMODE		103
#define MENU_EXTR_SCALE_H	104
#define MENU_EXTR_MOV_H		105
#define MENU_EXTR_ROT_H		106
#define MENU_EXTR_SKT_NAME	107
d229 9
a613 8
struct menu_item fgp_menu[] = {
	{ "FGP MENU", (void (*)())NULL, 0 },
	{ "Referenced Solid", fgp_ed, MENU_FGP_SOLID },
	{ "Scale Thickness", fgp_ed, MENU_FGP_THICK },
	{ "Mode", fgp_ed, MENU_FGP_MODE },
	{ "", (void (*)())NULL, 0 }
};

a745 22
fgp_ed( arg )
{
	es_menu = arg;

	switch( arg )
	{
		case MENU_FGP_SOLID:
			es_edflag = ECMD_FGP_SOLID;
			break;
		case MENU_FGP_THICK:
			es_edflag = ECMD_FGP_THICK;
			break;
		case MENU_FGP_MODE:
			es_edflag = ECMD_FGP_MODE;
			break;
	}

	sedit();
	set_e_axes_pos(1);
}

static void
d804 7
d1531 24
a1655 19
	case ID_FGP:
		{
			struct rt_fgp_internal *plt =
				(struct rt_fgp_internal *)ip->idb_ptr;
			struct rt_db_internal in;

			RT_FGP_CK_MAGIC( plt );

			VSETALL( mpt, 0.0 )

			if( rt_db_get_internal( &in, plt->ref_dp, plt->dbip, plt->xform )  < 0 )
			{
				Tcl_AppendResult(interp, "get_solid_keypoint() Failed for FGP solid referencing ", plt->ref_dp->d_namep, "\n", (char *)NULL );
				break;
			}
			get_solid_keypoint( mpt, strp, &in, mat );
			rt_db_free_internal( &in );
			break;
		}
d2238 17
d2395 1
a2395 4
	if( id == ID_FGP )
		chg_l2menu(ST_S_NO_EDIT );
	else
		chg_l2menu(ST_S_EDIT);
d2484 1
a2484 4
	if( es_int.idb_type == ID_FGP )
		chg_l2menu(ST_S_NO_EDIT);
	else
		chg_l2menu(ST_S_EDIT);
a2538 3
	case ID_FGP:
		mmenu_set_all( MENU_L1, fgp_menu );
		break;
d2545 3
a3027 81
	case ECMD_FGP_THICK:
		{
			struct rt_fgp_internal *fgp =
				(struct rt_fgp_internal *)es_int.idb_ptr;

			RT_FGP_CK_MAGIC( fgp );

			if( inpara == 1 )
				fgp->thickness = es_para[0];
			else if( inpara > 0 )
			{
				Tcl_AppendResult(interp,
					"plate thickness required\n",
					(char *)NULL );
				mged_print_result( TCL_ERROR );
				return;
			}
			else if( es_scale > 0.0 )
			{
				fgp->thickness *= es_scale;
				es_scale = 0.0;
			}
		}
		break;

	case ECMD_FGP_SOLID:
		{
			struct rt_fgp_internal *fgp =
				(struct rt_fgp_internal *)es_int.idb_ptr;
			char *sol_name;
			int ret_tcl;

			RT_FGP_CK_MAGIC( fgp );

			ret_tcl = Tcl_VarEval( interp, "cad_input_dialog", " .fgp_solid", " $mged_gui(mged,screen)",
				" {FGP solid reference}", " {Enter the name of the solid to be referenced by this FGP}",
				" FGP_Ref_Solid ", fgp->ref_dp->d_namep ," 0 ",
				"{{ summary \"The solid you name here will be used by the FGP solid to define its extent\" }}",
				" OK", " CANCEL", (char *)NULL );
			if( ret_tcl != TCL_OK )
			{
				bu_log( "cad_input_dialog failed: %s\n", interp->result );
				break;
			}
			sol_name = Tcl_GetVar( interp, "FGP_Ref_Solid", TCL_GLOBAL_ONLY );
			NAMEMOVE( sol_name, fgp->referenced_solid );
			if( (fgp->ref_dp = db_lookup( dbip, sol_name, 0 ) ) == DIR_NULL )
			{
				Tcl_AppendResult(interp, "Warning: ", sol_name, " does not exist!!!\n",
					(char *)NULL );
			}
			fgp->dbip = dbip;
		}
		break;

	case ECMD_FGP_MODE:
		{
			struct rt_fgp_internal *fgp =
				(struct rt_fgp_internal *)es_int.idb_ptr;
			char *radio_result;
			char mode[10];
			int ret_tcl;

			RT_FGP_CK_MAGIC( fgp );
			sprintf( mode, " %d", fgp->mode-1 );
			ret_tcl = Tcl_VarEval( interp, "cad_radio", " .fgp_radio ", bu_vls_addr( &pathName ), " _fgp_mode_result",
				" \"Plate Mode\"", " \"Select the desired mode\"", mode,
				" { centered front }",
				" { \"Selecting the centered mode means the thickness of the plate\nwill be centered about the hit points on the underlying solid\" \"Selecting the front mode means that the thickness of the plate\nwill be extended along the ray starting at the hit points on the underlying solid\" } ",
				 (char *)NULL );

			if( ret_tcl != TCL_OK )
			{
				Tcl_AppendResult(interp, "Mode selection failed!!!\n", (char *)NULL );
				break;
			}
			radio_result = Tcl_GetVar( interp, "_fgp_mode_result", TCL_GLOBAL_ONLY );

			fgp->mode = atoi( radio_result ) + 1;
		}
		break;
d3690 100
d5558 3
d5660 17
d6018 14
d7707 4
a7715 1
  case ECMD_FGP_THICK:
d8278 16
a8839 3
    case ID_FGP:
      mip = fgp_menu;
      break;
d8845 3
@


11.130
log
@Extrusion editing
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.129 2000/01/14 15:55:23 bparker Exp $ (BRL)";
d2573 3
a2575 2
  bu_vls_printf(&cmd, "mged_input_dialog .get_vertex %S {Need vertex for solid rotate}\
 {%s} vertex_num %d 0 OK", &dName, bu_vls_addr(&str), arb_vertices[type][loc]);
@


11.129
log
@*- capitalize menu items
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.128 2000/01/07 21:46:32 bparker Exp $ (BRL)";
d72 1
a72 1
static void	nmg_ed(), pipe_ed(), vol_ed(), ebm_ed(), dsp_ed(), fgp_ed(), bot_ed();
d221 4
d228 9
d1203 9
d1958 10
a1967 2
			VMOVE( mpt, extr->V );
			*strp = "V";
d2229 17
d2396 1
d2542 3
d3329 104
d3962 57
d5534 1
d5617 17
d5961 14
d7649 7
d8769 3
@


11.128
log
@*- mods to edit menus (i.e. capitalized first letter of each word)
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.127 2000/01/06 04:37:00 mike Exp $ (BRL)";
d8413 1
a8413 1
      bu_vls_printf(&vls, " {{move edges} {%s}}", bu_vls_addr(&vls2));
d8423 1
a8423 1
      bu_vls_printf(&vls, " {{move faces} {%s}}", bu_vls_addr(&vls2));
d8433 1
a8433 1
      bu_vls_printf(&vls, " {{rotate faces} {%s}}", bu_vls_addr(&vls2));
@


11.127
log
@
ft_xform really needed a dbip parameter so it could pass it along to
ft_export and ft_import
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.126 1999/12/30 19:44:12 jra Exp $ (BRL)";
d226 5
a230 5
	{ "pick vertex", ars_ed, ECMD_ARS_PICK },
	{ "next vertex", ars_ed, ECMD_ARS_NEXT_PT },
	{ "prev vertex", ars_ed, ECMD_ARS_PREV_PT },
	{ "next curve", ars_ed, ECMD_ARS_NEXT_CRV },
	{ "prev curve", ars_ed, ECMD_ARS_PREV_CRV },
d236 8
a243 8
	{ "pick vertex", ars_ed, ECMD_ARS_PICK_MENU },
	{ "move point", ars_ed, ECMD_ARS_MOVE_PT },
	{ "delete curve", ars_ed, ECMD_ARS_DEL_CRV },
	{ "delete column", ars_ed, ECMD_ARS_DEL_COL },
	{ "dup curve", ars_ed, ECMD_ARS_DUP_CRV },
	{ "dup column", ars_ed, ECMD_ARS_DUP_COL },
	{ "move curve", ars_ed, ECMD_ARS_MOVE_CRV },
	{ "move column", ars_ed, ECMD_ARS_MOVE_COL },
d249 12
a260 12
	{ "move edge 12", arb8_edge, 0 },
	{ "move edge 23", arb8_edge, 1 },
	{ "move edge 34", arb8_edge, 2 },
	{ "move edge 14", arb8_edge, 3 },
	{ "move edge 15", arb8_edge, 4 },
	{ "move edge 26", arb8_edge, 5 },
	{ "move edge 56", arb8_edge, 6 },
	{ "move edge 67", arb8_edge, 7 },
	{ "move edge 78", arb8_edge, 8 },
	{ "move edge 58", arb8_edge, 9 },
	{ "move edge 37", arb8_edge, 10 },
	{ "move edge 48", arb8_edge, 11 },
d267 12
a278 12
	{ "move edge 12", arb7_edge, 0 },
	{ "move edge 23", arb7_edge, 1 },
	{ "move edge 34", arb7_edge, 2 },
	{ "move edge 14", arb7_edge, 3 },
	{ "move edge 15", arb7_edge, 4 },
	{ "move edge 26", arb7_edge, 5 },
	{ "move edge 56", arb7_edge, 6 },
	{ "move edge 67", arb7_edge, 7 },
	{ "move edge 37", arb7_edge, 8 },
	{ "move edge 57", arb7_edge, 9 },
	{ "move edge 45", arb7_edge, 10 },
	{ "move point 5", arb7_edge, 11 },
d285 10
a294 10
	{ "move edge 12", arb6_edge, 0 },
	{ "move edge 23", arb6_edge, 1 },
	{ "move edge 34", arb6_edge, 2 },
	{ "move edge 14", arb6_edge, 3 },
	{ "move edge 15", arb6_edge, 4 },
	{ "move edge 25", arb6_edge, 5 },
	{ "move edge 36", arb6_edge, 6 },
	{ "move edge 46", arb6_edge, 7 },
	{ "move point 5", arb6_edge, 8 },
	{ "move point 6", arb6_edge, 9 },
d301 9
a309 9
	{ "move edge 12", arb5_edge, 0 },
	{ "move edge 23", arb5_edge, 1 },
	{ "move edge 34", arb5_edge, 2 },
	{ "move edge 14", arb5_edge, 3 },
	{ "move edge 15", arb5_edge, 4 },
	{ "move edge 25", arb5_edge, 5 },
	{ "move edge 35", arb5_edge, 6 },
	{ "move edge 45", arb5_edge, 7 },
	{ "move point 5", arb5_edge, 8 },
d316 4
a319 4
	{ "move point 1", arb4_point, 0 },
	{ "move point 2", arb4_point, 1 },
	{ "move point 3", arb4_point, 2 },
	{ "move point 4", arb4_point, 4 },
d326 13
a338 13
	{ "scale H",	tgc_ed, MENU_TGC_SCALE_H },
	{ "scale H (move V)", tgc_ed, MENU_TGC_SCALE_H_V },
	{ "scale A",	tgc_ed, MENU_TGC_SCALE_A },
	{ "scale B",	tgc_ed, MENU_TGC_SCALE_B },
	{ "scale c",	tgc_ed, MENU_TGC_SCALE_C },
	{ "scale d",	tgc_ed, MENU_TGC_SCALE_D },
	{ "scale A,B",	tgc_ed, MENU_TGC_SCALE_AB },
	{ "scale C,D",	tgc_ed, MENU_TGC_SCALE_CD },
	{ "scale A,B,C,D", tgc_ed, MENU_TGC_SCALE_ABCD },
	{ "rotate H",	tgc_ed, MENU_TGC_ROT_H },
	{ "rotate AxB",	tgc_ed, MENU_TGC_ROT_AB },
	{ "move end H(rt)", tgc_ed, MENU_TGC_MV_H },
	{ "move end H", tgc_ed, MENU_TGC_MV_HH },
d344 2
a345 2
	{ "scale radius 1", tor_ed, MENU_TOR_R1 },
	{ "scale radius 2", tor_ed, MENU_TOR_R2 },
d351 4
a354 4
	{ "scale r", eto_ed, MENU_ETO_R },
	{ "scale D", eto_ed, MENU_ETO_RD },
	{ "scale C", eto_ed, MENU_ETO_SCALE_C },
	{ "rotate C", eto_ed, MENU_ETO_ROT_C },
d360 4
a363 4
	{ "scale A", ell_ed, MENU_ELL_SCALE_A },
	{ "scale B", ell_ed, MENU_ELL_SCALE_B },
	{ "scale C", ell_ed, MENU_ELL_SCALE_C },
	{ "scale A,B,C", ell_ed, MENU_ELL_SCALE_ABC },
d369 2
a370 2
	{ "pick vertex", spline_ed, -1 },
	{ "move vertex", spline_ed, ECMD_VTRANS },
d376 9
a384 9
	{ "pick edge", nmg_ed, ECMD_NMG_EPICK },
	{ "move edge", nmg_ed, ECMD_NMG_EMOVE },
	{ "split edge", nmg_ed, ECMD_NMG_ESPLIT },
	{ "delete edge", nmg_ed, ECMD_NMG_EKILL },
	{ "next eu", nmg_ed, ECMD_NMG_FORW },
	{ "prev eu", nmg_ed, ECMD_NMG_BACK },
	{ "radial eu", nmg_ed, ECMD_NMG_RADIAL },
	{ "extrude loop", nmg_ed , ECMD_NMG_LEXTRU },
	{ "debug edge", nmg_ed, ECMD_NMG_EDEBUG },
d390 6
a395 6
	{ "move face 1234", arb8_mv_face, 1 },
	{ "move face 5678", arb8_mv_face, 2 },
	{ "move face 1584", arb8_mv_face, 3 },
	{ "move face 2376", arb8_mv_face, 4 },
	{ "move face 1265", arb8_mv_face, 5 },
	{ "move face 4378", arb8_mv_face, 6 },
d402 2
a403 2
	{ "move face 1234", arb7_mv_face, 1 },
	{ "move face 2376", arb7_mv_face, 4 },
d410 5
a414 5
	{ "move face 1234", arb6_mv_face, 1 },
	{ "move face 2365", arb6_mv_face, 2 },
	{ "move face 1564", arb6_mv_face, 3 },
	{ "move face 125" , arb6_mv_face, 4 },
	{ "move face 346" , arb6_mv_face, 5 },
d421 5
a425 5
	{ "move face 1234", arb5_mv_face, 1 },
	{ "move face 125" , arb5_mv_face, 2 },
	{ "move face 235" , arb5_mv_face, 3 },
	{ "move face 345" , arb5_mv_face, 4 },
	{ "move face 145" , arb5_mv_face, 5 },
d432 4
a435 4
	{ "move face 123" , arb4_mv_face, 1 },
	{ "move face 124" , arb4_mv_face, 2 },
	{ "move face 234" , arb4_mv_face, 3 },
	{ "move face 134" , arb4_mv_face, 4 },
d442 6
a447 6
	{ "rotate face 1234", arb8_rot_face, 1 },
	{ "rotate face 5678", arb8_rot_face, 2 },
	{ "rotate face 1584", arb8_rot_face, 3 },
	{ "rotate face 2376", arb8_rot_face, 4 },
	{ "rotate face 1265", arb8_rot_face, 5 },
	{ "rotate face 4378", arb8_rot_face, 6 },
d454 6
a459 6
	{ "rotate face 1234", arb7_rot_face, 1 },
	{ "rotate face 567" , arb7_rot_face, 2 },
	{ "rotate face 145" , arb7_rot_face, 3 },
	{ "rotate face 2376", arb7_rot_face, 4 },
	{ "rotate face 1265", arb7_rot_face, 5 },
	{ "rotate face 4375", arb7_rot_face, 6 },
a463 2


d466 5
a470 5
	{ "rotate face 1234", arb6_rot_face, 1 },
	{ "rotate face 2365", arb6_rot_face, 2 },
	{ "rotate face 1564", arb6_rot_face, 3 },
	{ "rotate face 125" , arb6_rot_face, 4 },
	{ "rotate face 346" , arb6_rot_face, 5 },
d477 5
a481 5
	{ "rotate face 1234", arb5_rot_face, 1 },
	{ "rotate face 125" , arb5_rot_face, 2 },
	{ "rotate face 235" , arb5_rot_face, 3 },
	{ "rotate face 345" , arb5_rot_face, 4 },
	{ "rotate face 145" , arb5_rot_face, 5 },
d488 4
a491 4
	{ "rotate face 123" , arb4_rot_face, 1 },
	{ "rotate face 124" , arb4_rot_face, 2 },
	{ "rotate face 234" , arb4_rot_face, 3 },
	{ "rotate face 134" , arb4_rot_face, 4 },
d498 3
a500 3
	{ "move edges", arb_control, MENU_ARB_MV_EDGE },
	{ "move faces", arb_control, MENU_ARB_MV_FACE },
	{ "rotate faces", arb_control, MENU_ARB_ROT_FACE },
d506 3
a508 3
	{ "scale H", part_ed, MENU_PART_H },
	{ "scale v", part_ed, MENU_PART_v },
	{ "scale h", part_ed, MENU_PART_h },
d514 3
a516 3
	{ "scale B", rpc_ed, MENU_RPC_B },
	{ "scale H", rpc_ed, MENU_RPC_H },
	{ "scale r", rpc_ed, MENU_RPC_R },
d522 4
a525 4
	{ "scale B", rhc_ed, MENU_RHC_B },
	{ "scale H", rhc_ed, MENU_RHC_H },
	{ "scale r", rhc_ed, MENU_RHC_R },
	{ "scale c", rhc_ed, MENU_RHC_C },
d531 3
a533 3
	{ "scale H", epa_ed, MENU_EPA_H },
	{ "scale A", epa_ed, MENU_EPA_R1 },
	{ "scale B", epa_ed, MENU_EPA_R2 },
d539 4
a542 4
	{ "scale H", ehy_ed, MENU_EHY_H },
	{ "scale A", ehy_ed, MENU_EHY_R1 },
	{ "scale B", ehy_ed, MENU_EHY_R2 },
	{ "scale c", ehy_ed, MENU_EHY_C },
d548 13
a560 13
	{ "select point", pipe_ed, MENU_PIPE_SELECT },
	{ "next point", pipe_ed, MENU_PIPE_NEXT_PT },
	{ "previous point", pipe_ed, MENU_PIPE_PREV_PT },
	{ "move point", pipe_ed, MENU_PIPE_MOV_PT },
	{ "delete point", pipe_ed, MENU_PIPE_DEL_PT },
	{ "append point", pipe_ed, MENU_PIPE_ADD_PT },
	{ "prepend point", pipe_ed, MENU_PIPE_INS_PT },
	{ "scale point OD", pipe_ed, MENU_PIPE_PT_OD },
	{ "scale point ID", pipe_ed, MENU_PIPE_PT_ID },
	{ "scale point bend", pipe_ed, MENU_PIPE_PT_RADIUS },
	{ "scale pipe OD", pipe_ed, MENU_PIPE_SCALE_OD },
	{ "scale pipe ID", pipe_ed, MENU_PIPE_SCALE_ID },
	{ "scale pipe bend", pipe_ed, MENU_PIPE_SCALE_RADIUS },
d566 5
a570 5
	{"file name", vol_ed, MENU_VOL_FNAME },
	{"file size (X Y Z)", vol_ed, MENU_VOL_FSIZE },
	{"voxel size (X Y Z)", vol_ed, MENU_VOL_CSIZE },
	{"threshold (low)", vol_ed, MENU_VOL_THRESH_LO },
	{"threshold (hi)", vol_ed, MENU_VOL_THRESH_HI },
d576 3
a578 3
	{"file name", ebm_ed, MENU_EBM_FNAME },
	{"file size (W N)", ebm_ed, MENU_EBM_FSIZE },
	{"extrude depth", ebm_ed, MENU_EBM_HEIGHT },
d584 1
a584 1
	{"file name", dsp_ed, MENU_DSP_FNAME },
d593 3
a595 3
	{ "referenced solid", fgp_ed, MENU_FGP_SOLID },
	{ "Scale thickness", fgp_ed, MENU_FGP_THICK },
	{ "mode", fgp_ed, MENU_FGP_MODE },
d601 10
a610 10
	{ "pick vertex", bot_ed, ECMD_BOT_PICKV },
	{ "pick edge", bot_ed, ECMD_BOT_PICKE },
	{ "pick triangle", bot_ed, ECMD_BOT_PICKT },
	{ "move vertex", bot_ed, ECMD_BOT_MOVEV },
	{ "move edge", bot_ed, ECMD_BOT_MOVEE },
	{ "move triangle", bot_ed, ECMD_BOT_MOVET },
	{ "select mode", bot_ed, ECMD_BOT_MODE },
	{ "select orientation", bot_ed, ECMD_BOT_ORIENT },
	{ "set face thickness", bot_ed, ECMD_BOT_THICK },
	{ "set face mode", bot_ed, ECMD_BOT_FMODE },
@


11.126
log
@Eliminated some unused variables
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.125 1999/12/20 20:18:40 jra Exp $ (BRL)";
d2416 1
a2416 1
	if( rt_functab[is->idb_type].ft_xform( os, mat, is, free ) < 0 )
@


11.125
log
@get_solid_keypoint_tcl needed some checking of state
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.124 1999/12/20 19:59:13 jra Exp $ (BRL)";
d2600 1
a2600 1
	mat_t m, mat, mat2, scalemat;
a2648 1
	static int j;
a3147 2
				int ret_tcl;

a3210 2
				int ret_tcl;

a4341 1
			struct wdb_pipept *next;
a5506 1
  		fastf_t dist;
a6912 1
	struct menu_item        *mip;
a7018 2
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
a7187 2
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
a7283 3
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;

a7957 1
			struct wdb_pipept *next;
@


11.124
log
@Added commands bot_vertex_fuse, bot_face_fuse, and bot_condense
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.123 1999/12/17 16:24:27 bparker Exp $ (BRL)";
d2088 3
@


11.123
log
@*- modified f_keypoint's return value
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.122 1999/12/15 15:29:36 jra Exp $ (BRL)";
d1653 1
d2081 10
d3061 1
d3064 2
a3065 1
			sprintf( mode, " %d", bot->mode - 1);
d3078 21
d3135 1
a3135 1
				(void)Tcl_VarEval( interp, "cad_dialog ", ".bot_err ", "$mged_gui(mged,screen) ", "{Not Plate Mode} ",
d3137 4
a3140 1
					(char *)NULL );
a5540 4
		Tcl_LinkVar( interp, "bot_v1", (char *)&bot_verts[0], TCL_LINK_INT );
		Tcl_LinkVar( interp, "bot_v2", (char *)&bot_verts[1], TCL_LINK_INT );
		Tcl_LinkVar( interp, "bot_v3", (char *)&bot_verts[2], TCL_LINK_INT );

d5554 8
a5561 4
		  {
		    ret_tcl = Tcl_VarEval( interp, "bot_face_select ", bu_vls_addr( &vls ), (char *)NULL );
		    bu_vls_free( &vls );
		      if( ret_tcl != TCL_OK )
d5569 1
a5569 1
		  }
d8024 1
a8024 1
			else if( bot_verts[0] > -1 )
d8026 1
a8026 1
				/* editing a vertex */
@


11.122
log
@Eliminated an unused variable
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.121 1999/12/10 21:02:54 jra Exp $ (BRL)";
d8357 1
a8357 1
  return TCL_ERROR;
@


11.121
log
@Face mode and Face thickness editing for BOT solids.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.120 1999/12/09 20:31:06 jra Exp $ (BRL)";
a1628 1
			int id;
d1635 1
a1635 1
			if( (id=rt_db_get_internal( &in, plt->ref_dp, plt->dbip, plt->xform ))  < 0 )
@


11.120
log
@Eliminated a commented out line from label_edited_solid()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.119 1999/12/09 19:20:59 jra Exp $ (BRL)";
d219 2
d611 2
d3045 10
a3054 10
	  {
	    struct rt_bot_internal *bot =
	      (struct rt_bot_internal *)es_int.idb_ptr;
	    char *radio_result;
	    char mode[10];
	    int ret_tcl;

	    RT_BOT_CK_MAGIC( bot );
	    sprintf( mode, " %d", bot->mode - 1);
	    ret_tcl = Tcl_VarEval( interp, "cad_radio", " .bot_mode_radio ",
d3059 9
a3067 9
	    if( ret_tcl != TCL_OK )
	      {
		Tcl_AppendResult(interp, "Mode selection failed!!!\n", (char *)NULL );
		break;
	      }
	    radio_result = Tcl_GetVar( interp, "_bot_mode_result", TCL_GLOBAL_ONLY );
	    bot->mode = atoi( radio_result ) + 1;
	  }
	  break;
d3069 10
a3078 10
	  {
	    struct rt_bot_internal *bot =
	      (struct rt_bot_internal *)es_int.idb_ptr;
	    char *radio_result;
	    char orient[10];
	    int ret_tcl;

	    RT_BOT_CK_MAGIC( bot );
	    sprintf( orient, " %d", bot->orientation - 1);
	    ret_tcl = Tcl_VarEval( interp, "cad_radio", " .bot_orient_radio ",
d3083 163
a3245 9
	    if( ret_tcl != TCL_OK )
	      {
		Tcl_AppendResult(interp, "Face orientation selection failed!!!\n", (char *)NULL );
		break;
	      }
	    radio_result = Tcl_GetVar( interp, "_bot_orient_result", TCL_GLOBAL_ONLY );
	    bot->orientation = atoi( radio_result ) + 1;
	  }
	  break;
@


11.119
log
@More BOT editing
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.118 1999/12/06 20:21:44 jra Exp $ (BRL)";
a7810 1
/*				POINT_LABEL_STR( mid_pt, "face" ); */
@


11.118
log
@
More stuff for BOT editing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.117 1999/12/02 14:18:55 jra Exp $ (BRL)";
d217 2
d607 2
d3040 48
a3087 1

d4907 13
d4962 6
d5313 1
a5313 1
  		int i;
d5317 1
d5321 2
d5328 2
d5339 5
a5343 3
  			if( bn_isect_ray_tri( &dist, NULL, NULL, NULL, start_pt, dir,
  				pt1, pt2, pt3 ) )
  					break;
d5345 5
d5351 7
a5357 1
  		if( i < bot->num_faces )
d5363 13
a5375 6
  		else
  		{
	  		bot_verts[0] = -1;
	  		bot_verts[1] = -1;
	  		bot_verts[2] = -1;
  		}
d7036 33
@


11.117
log
@
The beginnings of BOT editing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.116 1999/12/01 21:29:57 jra Exp $ (BRL)";
d4894 2
a4895 1
				bu_log( "No BOT edge selected\n" );
d4930 50
d5238 45
d7224 3
a7226 1
label_edited_solid( pl, max_pl, xform, ip )
d7672 19
d8209 3
@


11.116
log
@
Mod to init_sedit() to initialize list of BOT vertices.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.115 1999/12/01 19:05:28 jra Exp $ (BRL)";
d3273 3
d3300 3
d3336 3
d3464 3
d3493 3
d6831 3
d6885 3
d7561 33
@


11.115
log
@
Fixed a bug in get_solid_keypoint for the BOT
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.114 1999/11/26 19:44:06 jra Exp $ (BRL)";
d2313 4
@


11.114
log
@Added the start of editing of the BOT solid
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.113 1999/11/19 02:34:39 mike Exp $ (BRL)";
d1642 4
a1645 1
			VMOVE( mpt, bot->vertices );
@


11.113
log
@
Fully committed to ft_tclget() et.al.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.112 1999/11/18 03:52:15 mike Exp $ (BRL)";
d72 1
a72 1
static void	nmg_ed(), pipe_ed(), vol_ed(), ebm_ed(), dsp_ed(), fgp_ed();
d109 2
d211 6
d597 11
d747 10
d2465 3
d4821 90
d5110 55
d5222 3
@


11.112
log
@
Changed to use rt_get_functab_by_label().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.111 1999/11/15 17:15:07 jra Exp $ (BRL)";
a7871 2
extern int rt_db_report();		/* XXX internal to librt/tcl.c */

d7902 3
a7904 1
    status = rt_db_report(interp, &es_int, (char *)0);
d7926 3
a7928 1
  status = rt_db_report(interp, &ces_int, (char *)0);
@


11.111
log
@Added BOT solid to get_solid_keypoint()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.110 1999/11/08 15:14:40 jra Exp $ (BRL)";
d7872 1
a7872 10
struct rt_solid_type_lookup {
  char			id;
  size_t		db_internal_size;
  long			magic;
  char			*label;
  struct bu_structparse	*parsetab;
};

extern int rt_db_report();
extern struct rt_solid_type_lookup *rt_get_parsetab_by_name();
d7953 1
a7953 1
  register struct rt_solid_type_lookup *stlp;
d7981 5
a7985 5
  stlp = rt_get_parsetab_by_name( argv[1] );
  if( stlp == NULL ||
      stlp->parsetab == (struct bu_structparse *)NULL) {
    Tcl_AppendResult( interp, "put_edit_solid: ", stlp->label,
		      "object type is not supported",
d7990 2
a7991 1
  if( es_int.idb_type != stlp->id ) {
d7993 1
a7993 1
		      "put_edit_solid: type mismatch",
d7998 2
a7999 2
  *((long *)es_int.idb_ptr) = stlp->magic;
  if( bu_structparse_argv(interp, argc-2, argv+2, stlp->parsetab,
@


11.110
log
@
minor change to class BOT the same as polysolids and ARS slids.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.109 1999/10/19 20:34:35 jra Exp $ (BRL)";
d1606 8
@


11.109
log
@Added editing for the FGP solid
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.108 1999/10/14 16:18:32 bparker Exp $ (BRL)";
d5498 1
a5498 1
	if( id != ID_ARS && id != ID_POLY )
@


11.108
log
@*- modified params sent to getFile
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.107 1999/10/08 21:44:26 bparker Exp $ (BRL)";
d72 1
a72 1
static void	nmg_ed(), pipe_ed(), vol_ed(), ebm_ed(), dsp_ed();
d206 3
d581 8
d706 22
d1588 20
d2276 4
a2279 1
	chg_l2menu(ST_S_EDIT);
d2367 4
a2370 1
	chg_l2menu(ST_S_EDIT);
d2425 3
d2908 82
d7840 3
@


11.107
log
@*- mods to get_file_name()
	- free memory pointed to by dir
	- call getFile() instead of fs_dialog
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.106 1999/09/09 20:35:53 bparker Exp $ (BRL)";
d2442 3
a2444 1
	bu_vls_printf(&cmd, "getFile mged . %s {{{All Files} {*}}} {Get File}",
@


11.106
log
@*- mods to get_solid_keypoint(); for NMG's, attempt to use
   the first vertex of the current edge as the keypoint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.105 1999/09/01 18:55:10 bparker Exp $ (BRL)";
d2420 1
d2427 2
d2438 3
a2440 1
		strcat( dir, "/*" );
d2442 3
a2444 4
		bu_vls_printf( &cmd, "fs_dialog .w . %s", dir );
	}
	else
		bu_vls_printf( &cmd, "fs_dialog .w . *" );
@


11.105
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.104 1999/08/20 21:03:51 bparker Exp $ (BRL)";
d1858 11
@


11.104
log
@*- mods to get_solid_keypoint to properly set the
   keypoint for an ars
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.103 1999/07/08 17:41:18 bparker Exp $ (BRL)";
d6381 1
a6381 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d6551 1
a6551 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d6666 1
a6666 3
  if(dbip == DBI_NULL)
    return TCL_OK;

d7492 1
a7492 2
  if(dbip == DBI_NULL)
    return TCL_OK;
@


11.103
log
@*- mod to init_objedit_guts(),
   call get_solid_keypoint() after calculating es_mat
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.102 1999/06/25 20:30:44 bparker Exp $ (BRL)";
d1750 6
a1755 1
			VMOVE( mpt , ars->curves[0] );
@


11.102
log
@*- mods to get_solid_keypoint() for pipe solid
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.101 1999/06/14 22:18:42 bparker Exp $ (BRL)";
a6206 2
	get_solid_keypoint( es_keypoint , &strp , &es_int , es_mat );

d6213 1
@


11.101
log
@*- mods to init_objedit_guts()
	- initialize acc_sc_obj
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.100 1999/05/06 17:55:21 bparker Exp $ (BRL)";
d1486 6
a1491 2
			pipe_seg = BU_LIST_FIRST( wdb_pipept , &pipe->pipe_segs_head );
			VMOVE( mpt , pipe_seg->pp_coord );
@


11.100
log
@*- mods to get_edit_solid_menus()
   It now returns a edit menu of the following form:

	{{title} {}}
	{{label_1} {submenu_1}}
	{{label_2} {submenu_1}}

		...

	{{label_n} {submenu_n}}

   The submenus may be empty, otherwise they have the same form
   as a menu. Note - the first item in a menu or submenu is
   always a menu title, which of course has an empty submenu.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.99 1999/05/03 16:47:11 bparker Exp $ (BRL)";
d6225 1
@


11.99
log
@*- mods to support f_reset_edit_matrix
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.98 1999/03/09 21:38:56 bparker Exp $ (BRL)";
a7558 1
  bu_vls_printf(&vls, "{");
d7562 52
a7613 4
    /* build "move edge" menu */
    mip = which_menu[es_type-4];
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7615 3
a7617 2
    /* end "move edge" menu and start "move face" menu */
    bu_vls_printf(&vls, " } {");
d7619 3
a7621 4
    /* build "move face" menu */
    mip = which_menu[es_type+1];
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7623 2
a7624 2
    /* end "move face" menu and start "rotate face" menu */
    bu_vls_printf(&vls, " } {");
d7626 2
a7627 4
    /* build "rotate face" menu */
    mip = which_menu[es_type+6];
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
a7640 3
    case ID_ARS:
      mip = ars_menu;
      break;
d7682 3
d7686 1
a7686 1
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
a7690 1
  bu_vls_printf(&vls, " }");
d7816 4
a7819 3
  if( stlp == NULL ) {
    Tcl_AppendResult( interp,
		      "put_edit_solid: unknown object type",
@


11.98
log
@*- fixed bug found by jra that caused improper translations
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.97 1999/02/08 16:32:58 bparker Exp $ (BRL)";
d6144 1
a6144 1
 *			I N I T _ O B J E D I T
d6148 1
a6148 1
init_objedit()
d6232 10
d6243 2
a6244 2
	{
	  struct bu_vls		vls;
d6246 5
a6250 5
	  bu_vls_init(&vls);
	  bu_vls_strcpy(&vls, "begin_edit_callback");
	  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	}
d6340 1
a6340 7
	bn_mat_idn( modelchanges );
	bn_mat_idn( acc_rot_sol );
	es_edclass = EDIT_CLASS_NULL;

    	if( es_int.idb_ptr )  rt_functab[es_int.idb_type].ft_ifree( &es_int );
	es_int.idb_ptr = (genptr_t)NULL;
	db_free_external( &es_ext );
d6346 2
a6352 2

  bn_mat_idn( acc_rot_sol );
d7823 1
a7828 2
    struct bu_vls vls;

d7878 33
d7912 1
d7914 6
@


11.97
log
@add support for particle solid
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.96 1999/01/21 18:31:21 bparker Exp $ (BRL)";
d4719 1
a4719 1
      MAT4X3PNT( pos_view, view_state->vs_model2view, e_axes_pos );
d4745 1
a4745 1
    MAT4X3PNT( pos_view, view_state->vs_model2view, e_axes_pos );
d4762 1
a4762 1
      MAT4X3PNT(pos_view, view_state->vs_model2view, e_axes_pos);
d4775 1
a4775 1
    MAT4X3PNT(pos_view, view_state->vs_model2view, e_axes_pos);
d4784 1
a4784 1
    MAT4X3PNT(pos_view, view_state->vs_model2view, e_axes_pos);
d4793 1
a4793 1
    MAT4X3PNT(pos_view, view_state->vs_model2view, e_axes_pos);
d4826 1
a4826 1
      MAT4X3PNT( pos_view, view_state->vs_model2view, e_axes_pos );
d4867 1
a4867 1
    MAT4X3PNT(pos_view, view_state->vs_model2view, e_axes_pos);
@


11.96
log
@*- use helpdevel for help on developer commands
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.95 1999/01/12 18:16:41 bparker Exp $ (BRL)";
d73 1
a73 1
static void	rpc_ed(), rhc_ed(), epa_ed(), ehy_ed(), eto_ed();
d203 3
a206 1

d491 8
d925 10
d2343 3
d6092 48
d6924 29
d7627 3
@


11.95
log
@*- some cleanup
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.94 1998/12/09 22:35:32 bparker Exp $ (BRL)";
d7571 6
a7576 1
    Tcl_AppendResult(interp, "Usage: get_edit_solid [-c]", (char *)0);
d7642 6
d7719 10
@


11.94
log
@*- initialize variable in get_edit_solid_menus()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.93 1998/11/06 22:32:40 bparker Exp $ (BRL)";
a6202 10
#ifdef DO_SINGLE_DISPLAY_LIST
		save_dmlp = curr_dm_list;
		FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
		  if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables->mv_dlist){
		    curr_dm_list = dmlp;
		    createDList(&HeadSolid);
		  }
		}
		curr_dm_list = save_dmlp;
#endif
a6258 11
#ifdef DO_SINGLE_DISPLAY_LIST
	save_dmlp = curr_dm_list;
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
	  if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables->mv_dlist){
	    curr_dm_list = dmlp;
	    createDList(&HeadSolid);
	  }
	}
	curr_dm_list = save_dmlp;
#endif

a6375 11
#ifdef DO_SINGLE_DISPLAY_LIST
	save_dmlp = curr_dm_list;
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
	  if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables->mv_dlist){
	    curr_dm_list = dmlp;
	    createDList(&HeadSolid);
	  }
	}
	curr_dm_list = save_dmlp;
#endif

a6449 11

#ifdef DO_SINGLE_DISPLAY_LIST
	save_dmlp = curr_dm_list;
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
	  if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables->mv_dlist){
	    curr_dm_list = dmlp;
	    createDList(&HeadSolid);
	  }
	}
	curr_dm_list = save_dmlp;
#endif
@


11.93
log
@*- use new structures
*- cleanup
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.92 1998/08/13 12:24:46 bparker Exp $ (BRL)";
d7491 1
a7491 1
  struct menu_item *mip;
@


11.92
log
@*- added the following functions:
	begin_edit_callback()
	get_edit_solid_menus()
	f_get_edit_solid()
	f_put_edit_solid()
	f_reset_edit_solid()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.91 1998/07/15 16:37:00 bparker Exp $ (BRL)";
a62 1
extern void set_scroll();   /* defined in set.c */
a69 3
#if 0
extern int      savedit;
#endif
a80 3
#if 0
void	calc_planes();
#endif
a84 1
#if 1
a85 3
#else
static short int fixv;		/* used in ECMD_ARB_ROTATE_FACE,f_eqn(): fixed vertex */
#endif
d1169 1
a1169 1
			dmaflag = 1;
d2085 1
a2085 5
      dmlp->_mged_variables->transform = 'e';

#ifdef DO_SCROLL_UPDATES
    set_scroll();
#endif
d2268 1
a2268 1
	menuflag = 0;		/* No menu item selected yet */
d2799 1
a2799 1
		menuflag = 0;
d2806 1
a2806 1
		menuflag = 0;
d2832 1
a2832 1
			if(mged_variables->context){
d2909 1
a2909 1
		dmaflag = 1;	/* draw arrow, etc */
d2947 1
a2947 1
				if(mged_variables->context){
d3062 1
a3062 1
			  if(mged_variables->context){ /* move solid so that es_keypoint is at position es_para */
d3110 1
a3110 1
			if(mged_variables->context){
d3134 1
a3134 1
			  if(mged_variables->context){
d3188 1
a3188 1
			  if(mged_variables->context){
d3222 1
a3222 1
		  if(mged_variables->context){
d3269 1
a3269 1
			switch(mged_variables->rotate_about){
d3272 1
a3272 1
			  MAT4X3PNT(rot_point, view2model, work);
d3276 1
a3276 1
			  MAT4X3PNT(rot_point, view2model, work);
d3287 1
a3287 1
			if(mged_variables->context){
d3345 1
a3345 1
			if(mged_variables->context){
d3402 1
a3402 1
			if(mged_variables->context){
d3471 1
a3471 1
			if(mged_variables->context){
d3514 1
a3514 1
			  if(mged_variables->context){
d3555 1
a3555 1
					MAT4X3VEC( view_dir , view2model , view_z_dir );
d3680 1
a3680 1
			  if(mged_variables->context){
d3725 1
a3725 1
					MAT4X3VEC( view_dir , view2model , view_z_dir );
d3762 1
a3762 1
			  if(mged_variables->context){
d3837 1
a3837 1
			dmaflag = 1;
d3853 1
a3853 1
			  if(mged_variables->context){
d3894 1
a3894 1
			  if(mged_variables->context){
d3935 1
a3935 1
			  if(mged_variables->context){
d3976 1
a3976 1
			  if(mged_variables->context){
d4010 1
a4010 1
			  if(mged_variables->context){
d4045 1
a4045 1
		menuflag = 0;
d4051 1
a4051 1
		menuflag = 0;
d4071 1
a4071 1
			  if(mged_variables->context){
d4092 1
a4092 1
			MAT4X3VEC( view_dir , view2model , z_dir );
d4433 1
a4433 1
				MAT4X3VEC( view_pl, view2model, view_dir );
d4443 1
a4443 1
			  if(mged_variables->context){
d4495 1
a4495 1
				MAT4X3VEC( view_pl, view2model, view_dir );
d4505 1
a4505 1
			  if(mged_variables->context){
d4556 1
a4556 1
				MAT4X3VEC( view_pl, view2model, view_dir );
d4566 1
a4566 1
			  if(mged_variables->context){
a4679 3
#ifdef UPDATE_TCL_SLIDERS
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_scale_vls));
#endif
d4696 1
a4696 1
      MAT4X3PNT( pos_view, model2view, e_axes_pos );
d4699 1
a4699 1
      MAT4X3PNT( pt, view2model, pos_view );
d4722 1
a4722 1
    MAT4X3PNT( pos_view, model2view, e_axes_pos );
d4725 1
a4725 1
    MAT4X3PNT( temp, view2model, pos_view );
d4739 1
a4739 1
      MAT4X3PNT(pos_view, model2view, e_axes_pos);
d4743 1
a4743 1
      MAT4X3PNT( temp, view2model, pos_view );
d4752 1
a4752 1
    MAT4X3PNT(pos_view, model2view, e_axes_pos);
d4755 1
a4755 1
    MAT4X3PNT(temp, view2model, pos_view);
d4761 1
a4761 1
    MAT4X3PNT(pos_view, model2view, e_axes_pos);
d4764 1
a4764 1
    MAT4X3PNT(temp, view2model, pos_view);
d4770 1
a4770 1
    MAT4X3PNT(pos_view, model2view, e_axes_pos);
d4773 1
a4773 1
    MAT4X3PNT(temp, view2model, pos_view);
d4803 1
a4803 1
      MAT4X3PNT( pos_view, model2view, e_axes_pos );
d4807 1
a4807 1
				       model2view, &tmp_tol )) ==
d4844 1
a4844 1
    MAT4X3PNT(pos_view, model2view, e_axes_pos);
d4847 1
a4847 1
    MAT4X3PNT(temp, view2model, pos_view);
d4869 1
a4869 1
  fastf_t inv_Viewscale = 1/Viewscale;
d4871 1
a4871 1
  MAT4X3PNT(model_pos, view2model, view_pos);
d4876 1
a4876 1
  MAT4X3PNT(ea_view_pos, model2view, e_axes_pos);
a4878 9

#ifdef UPDATE_TCL_SLIDERS
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_model_tran_vls[X]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_model_tran_vls[Y]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_model_tran_vls[Z]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_view_tran_vls[X]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_view_tran_vls[Y]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_view_tran_vls[Z]));
#endif
d4906 1
a4906 1
      MAT4X3PNT( temp, view2model, tvec );
d4928 1
a4928 1
    MAT4X3PNT( temp, view2model, tvec );
d4943 1
a4943 1
      MAT4X3PNT( temp, view2model, tvec );
d4960 1
a4960 1
    MAT4X3PNT( temp, view2model, tvec );
d4967 1
a4967 1
    MAT4X3PNT( temp, view2model, tvec );
d4975 1
a4975 1
    MAT4X3PNT( temp, view2model, tvec );
d5011 1
a5011 1
				       model2view,
d5048 1
a5048 1
    MAT4X3PNT( temp, view2model, tvec );
a5062 6

#ifdef UPDATE_TCL_SLIDERS
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[X]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[Y]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[Z]));
#endif
a5087 4

#ifdef UPDATE_TCL_SLIDERS
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_scale_vls));
#endif
a5165 3
#ifdef UPDATE_TCL_SLIDERS
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_scale_vls));
#endif
d5171 1
a5171 1
    MAT4X3PNT( pos_view, model2objview, temp );
d5178 1
a5178 1
    MAT4X3PNT( pos_model, view2model, pos_view );/* NOT objview */
d5209 1
a5209 1
  MAT4X3PNT( pos_model, view2model, tvec );/* NOT objview */
a5217 6

#ifdef UPDATE_TCL_SLIDERS
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[X]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[Y]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[Z]));
#endif
a5280 4

#ifdef UPDATE_TCL_SLIDERS
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_scale_vls));
#endif
d6206 1
a6206 1
		  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables->dlist){
d6257 1
a6257 1
	dmaflag=1;
d6272 1
a6272 1
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables->dlist){
a6283 4
#ifdef DO_SCROLL_UPDATES
	set_scroll();
#endif

a6293 4
#ifdef DO_SCROLL_UPDATES
  set_scroll();
#endif

d6366 1
a6366 1
	dmaflag = 1;
d6400 1
a6400 1
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables->dlist){
d6438 1
a6438 1
	menuflag = 0;
a6442 4
#ifdef DO_SCROLL_UPDATES
	set_scroll();
#endif

d6486 1
a6486 1
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables->dlist){
d6494 1
a6494 1
	menuflag = 0;
a6498 4
#ifdef DO_SCROLL_UPDATES
	set_scroll();
#endif

d6600 1
a6600 1
    fastf_t inv_Viewscale = 1/Viewscale;
d7178 1
a7178 1
	MAT4X3PNT( m_pos, objview2model, v_pos );
d7182 1
a7182 1
	    m_pos, model2objview ) >= 0 )  {
d7189 1
a7189 1
	dmaflag = 1;
d7481 1
a7481 1
  dmaflag = 1;
@


11.91
log
@*- call do_edit_menu and do_arb_edit_menu with solid type
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edsol.c,v 11.90 1998/06/11 19:41:43 bparker Exp $ (BRL)";
d83 1
a83 1
void build_tcl_edit_menu();
a2130 1
	RT_INIT_DB_INTERNAL(&es_int);
d2136 1
a2199 1
	sedit();
a2203 2
	build_tcl_edit_menu();

d2226 9
d2247 2
a2248 2
#if 0
	struct rt_db_internal	*ip;
d2250 6
a2255 19
	(void)illump->s_path[illump->s_last];

	ip = &es_int;
	RT_CK_DB_INTERNAL( ip );

	(void)replot_modified_solid( illump, ip, es_mat );
#else
	{
	  mat_t mat;
	  register struct solid *sp;

	  FOR_ALL_SOLIDS(sp, &HeadSolid.l) {
	    if(sp->s_path[sp->s_last]->d_addr == illump->s_path[illump->s_last]->d_addr){
	      pathHmat( sp, mat, sp->s_last-1 );
	      (void)replot_modified_solid( sp, &es_int, mat );
	    }
	  }
	}
#endif
d4631 9
a4641 1
	return;
a6130 1
	struct bu_vls		vls;
d6212 8
a6219 4
	bu_vls_init(&vls);
	bu_vls_strcpy(&vls, "do_edit_menu {} {}");
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d7551 5
a7555 3

void
build_tcl_edit_menu()
d7560 3
d7564 1
a7567 2
    bu_vls_printf(&vls, "do_arb_edit_menu arb8 {");

a7588 2
    /* end "rotate face" menu */
    bu_vls_printf(&vls, " }\n");
d7590 52
a7641 3
  case ID_TGC:
    bu_vls_printf(&vls, "do_edit_menu tgc {");
    mip = tgc_menu;
a7644 1
    bu_vls_printf(&vls, " }\n");
d7646 102
a7747 5
  case ID_TOR:
    bu_vls_printf(&vls, "do_edit_menu tor {");
    mip = tor_menu;
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7749 4
a7752 7
    bu_vls_printf(&vls, " }\n");
    break;
  case ID_ELL:
    bu_vls_printf(&vls, "do_edit_menu ell {");
    mip = ell_menu;
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7754 15
a7768 7
    bu_vls_printf(&vls, " }\n");
    break;
  case ID_ARS:
    bu_vls_printf(&vls, "do_edit_menu ars {");
    mip = ars_menu;
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7770 5
a7774 7
    bu_vls_printf(&vls, " }\n");
    break;
  case ID_BSPLINE:
    bu_vls_printf(&vls, "do_edit_menu spline {");
    mip = spline_menu;
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7776 7
a7782 7
    bu_vls_printf(&vls, " }\n");
    break;
  case ID_RPC:
    bu_vls_printf(&vls, "do_edit_menu rpc {");
    mip = rpc_menu;
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7784 2
a7785 7
    bu_vls_printf(&vls, " }\n");
    break;
  case ID_RHC:
    bu_vls_printf(&vls, "do_edit_menu rhc {");
    mip = rhc_menu;
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7787 3
a7789 7
    bu_vls_printf(&vls, " }\n");
    break;
  case ID_EPA:
    bu_vls_printf(&vls, "do_edit_menu epa {");
    mip = epa_menu;
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7791 2
a7792 7
    bu_vls_printf(&vls, " }\n");
    break;
  case ID_EHY:
    bu_vls_printf(&vls, "do_edit_menu ehy {");
    mip = ehy_menu;
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7794 2
a7795 7
    bu_vls_printf(&vls, " }\n");
    break;
  case ID_ETO:
    bu_vls_printf(&vls, "do_edit_menu eto {");
    mip = eto_menu;
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7797 2
a7798 7
    bu_vls_printf(&vls, " }\n");
    break;
  case ID_NMG:
    bu_vls_printf(&vls, "do_edit_menu nmg {");
    mip = nmg_menu;
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7800 2
a7801 7
    bu_vls_printf(&vls, " }\n");
    break;
  case ID_PIPE:
    bu_vls_printf(&vls, "do_edit_menu pipe {");
    mip = pipe_menu;
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7803 2
a7804 7
    bu_vls_printf(&vls, " }\n");
    break;
  case ID_VOL:
    bu_vls_printf(&vls, "do_edit_menu vol {");
    mip = vol_menu;
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7806 8
a7813 7
    bu_vls_printf(&vls, " }\n");
    break;
  case ID_EBM:
    bu_vls_printf(&vls, "do_edit_menu ebm {");
    mip = ebm_menu;
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7815 2
a7816 7
    bu_vls_printf(&vls, " }\n");
    break;
  case ID_DSP:
    bu_vls_printf(&vls, "do_edit_menu dsp {");
    mip = dsp_menu;
    for(++mip; mip->menu_func != (void (*)())NULL; ++mip)
      bu_vls_printf(&vls, " {%s}", mip->menu_string);
d7818 13
a7830 2
    bu_vls_printf(&vls, " }\n");
    break;
d7832 26
d7859 3
d7863 1
a7863 2
  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
@


11.90
log
@*- using floating point literals to initialize floats
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/edsol.c,v 11.89 1998/04/07 14:08:35 jra Exp $ (BRL)";
d6213 1
a6213 1
	bu_vls_strcpy(&vls, "do_edit_menu {}");
d7558 1
a7558 1
    bu_vls_printf(&vls, "do_arb_edit_menu {");
d7585 1
a7585 1
    bu_vls_printf(&vls, "do_edit_menu {");
d7593 1
a7593 1
    bu_vls_printf(&vls, "do_edit_menu {");
d7601 1
a7601 1
    bu_vls_printf(&vls, "do_edit_menu {");
d7609 1
a7609 1
    bu_vls_printf(&vls, "do_edit_menu {");
d7617 1
a7617 1
    bu_vls_printf(&vls, "do_edit_menu {");
d7625 1
a7625 1
    bu_vls_printf(&vls, "do_edit_menu {");
d7633 1
a7633 1
    bu_vls_printf(&vls, "do_edit_menu {");
d7641 1
a7641 1
    bu_vls_printf(&vls, "do_edit_menu {");
d7649 1
a7649 1
    bu_vls_printf(&vls, "do_edit_menu {");
d7657 1
a7657 1
    bu_vls_printf(&vls, "do_edit_menu {");
d7665 1
a7665 1
    bu_vls_printf(&vls, "do_edit_menu {");
d7673 1
a7673 1
    bu_vls_printf(&vls, "do_edit_menu {");
d7681 1
a7681 1
    bu_vls_printf(&vls, "do_edit_menu {");
d7689 1
a7689 1
    bu_vls_printf(&vls, "do_edit_menu {");
d7697 1
a7697 1
    bu_vls_printf(&vls, "do_edit_menu {");
@


11.89
log
@Added ID_EXTRUDE to get_keypoint().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.88 1998/03/19 15:55:50 jra Exp jra $ (BRL)";
d1838 1
a1838 1
			VSETALL( mpt, 0 );
d1944 1
a1944 1
	  VSETALL( mpt, 0 );
d2085 2
a2086 2
	edit_absolute_scale = 0;
	acc_sc_sol = 1;
d2219 2
a2220 2
	edit_absolute_scale = 0;
	acc_sc_sol = 1;
d2222 5
a2226 5
	VSETALL( edit_rate_model_rotate, 0 );
	VSETALL( edit_rate_object_rotate, 0 );
	VSETALL( edit_rate_view_rotate, 0 );
	VSETALL( edit_rate_model_tran, 0 );
	VSETALL( edit_rate_view_tran, 0 );
d3175 1
a3175 1
			  VSET(tgc->h, 0, 0, 1 );
d3229 1
a3229 1
			  VSET(tgc->h, 0, 0, 1 );
d3576 1
a3576 1
					VSET( view_z_dir , 0 , 0 , 1 );
d3746 1
a3746 1
					VSET( view_z_dir , 0 , 0 , 1 );
d4113 1
a4113 1
			VSET( z_dir , 0 , 0 , 1 );
d6202 1
a6202 1
	edit_absolute_scale = 0;
d6206 5
a6210 5
	VSETALL( edit_rate_model_rotate, 0 );
	VSETALL( edit_rate_object_rotate, 0 );
	VSETALL( edit_rate_view_rotate, 0 );
	VSETALL( edit_rate_model_tran, 0 );
	VSETALL( edit_rate_view_tran, 0 );
@


11.88
log
@Changed rt_import and ft_export calls to new calling sequence.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.87 1998/03/19 15:05:04 jra Exp jra $ (BRL)";
d1810 10
@


11.87
log
@Added "sketch" tp get_keypoint()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.86 1998/02/26 16:12:03 bparker Exp jra $ (BRL)";
d2128 1
a2128 1
	if( rt_functab[id].ft_import( &es_int, &es_ext, bn_mat_identity ) < 0 )  {
d6153 1
a6153 1
	if( rt_functab[id].ft_import( &es_int, &es_ext, bn_mat_identity ) < 0 )  {
d6467 1
a6467 1
	if( rt_functab[es_int.idb_type].ft_export( &es_ext, &es_int, 1.0 ) < 0 )  {
@


11.86
log
@*- use e_axes_pos instead of curr_e_axes_pos to eliminate creeping
	when editing with the mouse.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.85 1998/01/28 16:15:25 bparker Exp bparker $ (BRL)";
d1800 10
@


11.85
log
@using rotate_about instead of erotate_about
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.84 1998/01/21 16:27:53 jra Exp bparker $ (BRL)";
d4693 1
a4693 1
      MAT4X3PNT( pos_view, model2view, es_keypoint );
d4702 1
a4702 1
      MAT4X3PNT( raw_kp, es_invmat, es_keypoint );
d4719 1
a4719 1
    MAT4X3PNT( pos_view, model2view, curr_e_axes_pos );
d4736 1
a4736 1
      MAT4X3PNT(pos_view, model2view, curr_e_axes_pos);
d4749 1
a4749 1
    MAT4X3PNT(pos_view, model2view, curr_e_axes_pos);
d4758 1
a4758 1
    MAT4X3PNT(pos_view, model2view, curr_e_axes_pos);
d4767 1
a4767 1
    MAT4X3PNT(pos_view, model2view, curr_e_axes_pos);
d4800 1
a4800 1
      MAT4X3PNT( pos_view, model2view, curr_e_axes_pos );
d4841 1
a4841 1
    MAT4X3PNT(pos_view, model2view, curr_e_axes_pos);
@


11.84
log
@Added capability to scale height vector (but move V) to TGC editing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.83 1997/12/23 14:24:27 bparker Exp jra $ (BRL)";
d3271 1
a3271 1
			switch(mged_variables->erotate_about){
@


11.83
log
@*** empty log message ***
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.82 1997/11/26 21:32:48 bparker Exp bparker $ (BRL)";
d154 60
a213 59
#define MENU_TGC_SCALE_A	28
#define MENU_TGC_SCALE_B	29
#define MENU_TGC_SCALE_C	30
#define MENU_TGC_SCALE_D	31
#define MENU_TGC_SCALE_AB	32
#define MENU_TGC_SCALE_CD	33
#define MENU_TGC_SCALE_ABCD	34
#define MENU_ARB_MV_EDGE	35
#define MENU_ARB_MV_FACE	36
#define MENU_ARB_ROT_FACE	37
#define MENU_ELL_SCALE_A	38
#define MENU_ELL_SCALE_B	39
#define MENU_ELL_SCALE_C	40
#define MENU_ELL_SCALE_ABC	41
#define MENU_RPC_B		42
#define MENU_RPC_H		43
#define MENU_RPC_R		44
#define MENU_RHC_B		45
#define MENU_RHC_H		46
#define MENU_RHC_R		47
#define MENU_RHC_C		48
#define MENU_EPA_H		49
#define MENU_EPA_R1		50
#define MENU_EPA_R2		51
#define MENU_EHY_H		52
#define MENU_EHY_R1		53
#define MENU_EHY_R2		54
#define MENU_EHY_C		55
#define MENU_ETO_R		56
#define MENU_ETO_RD		57
#define MENU_ETO_SCALE_C	58
#define MENU_ETO_ROT_C		59
#define	MENU_PIPE_SELECT	60
#define	MENU_PIPE_NEXT_PT	61
#define MENU_PIPE_PREV_PT	62
#define MENU_PIPE_SPLIT		63
#define MENU_PIPE_PT_OD		64
#define MENU_PIPE_PT_ID		65
#define	MENU_PIPE_SCALE_OD	66
#define	MENU_PIPE_SCALE_ID	67
#define	MENU_PIPE_ADD_PT	68
#define MENU_PIPE_INS_PT	69
#define MENU_PIPE_DEL_PT	70
#define	MENU_PIPE_MOV_PT	71
#define	MENU_PIPE_PT_RADIUS	72
#define	MENU_PIPE_SCALE_RADIUS	73
#define	MENU_VOL_FNAME		74
#define	MENU_VOL_FSIZE		75
#define	MENU_VOL_CSIZE		76
#define	MENU_VOL_THRESH_LO	77
#define	MENU_VOL_THRESH_HI	78
#define	MENU_EBM_FNAME		79
#define	MENU_EBM_FSIZE		80
#define	MENU_EBM_HEIGHT		81
#define	MENU_DSP_FNAME		82
#define	MENU_DSP_FSIZE		83	/* Not implemented yet */
#define	MENU_DSP_SCALE_X	84
#define	MENU_DSP_SCALE_Y	85
#define	MENU_DSP_SCALE_ALT	86
d321 1
d5399 18
@


11.82
log
@ifdef code that uses Tcl_UpdateLinkedVar
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.81 1997/11/06 20:00:03 bparker Exp bparker $ (BRL)";
d2076 1
d2078 1
d6289 2
a6290 1
	scroll_edit = EDIT_CLASS_NULL;
d6292 1
d6303 2
a6304 1
  scroll_edit = EDIT_CLASS_NULL;
d6306 1
d6456 2
a6457 1
	scroll_edit = EDIT_CLASS_NULL;
d6459 1
d6516 2
a6517 1
	scroll_edit = EDIT_CLASS_NULL;
d6519 1
@


11.81
log
@*- mods to update mged_variables->transform
*- use new mged variable: erotate_about
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.80 1997/09/08 18:51:07 bparker Exp bparker $ (BRL)";
d5178 1
d5180 1
@


11.80
log
@*- new macro FOR_ALL_DISPLAYS
*- mged_variables is now a pointer
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.79 1997/09/03 14:18:48 bparker Exp bparker $ (BRL)";
d1936 1
d2073 3
a2075 1
    mged_variables->transform = 'e';
d3267 1
a3267 1
			switch(mged_variables->rotate_about){
@


11.79
log
@mods to implement new display lists
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.78 1997/07/30 19:55:49 bparker Exp bparker $ (BRL)";
d2072 1
a2072 1
    mged_variables.transform = 'e';
d2827 1
a2827 1
			if(mged_variables.context){
d2942 1
a2942 1
				if(mged_variables.context){
d3057 1
a3057 1
			  if(mged_variables.context){ /* move solid so that es_keypoint is at position es_para */
d3105 1
a3105 1
			if(mged_variables.context){
d3129 1
a3129 1
			  if(mged_variables.context){
d3183 1
a3183 1
			  if(mged_variables.context){
d3217 1
a3217 1
		  if(mged_variables.context){
d3264 1
a3264 1
			switch(mged_variables.rotate_about){
d3282 1
a3282 1
			if(mged_variables.context){
d3340 1
a3340 1
			if(mged_variables.context){
d3397 1
a3397 1
			if(mged_variables.context){
d3466 1
a3466 1
			if(mged_variables.context){
d3509 1
a3509 1
			  if(mged_variables.context){
d3675 1
a3675 1
			  if(mged_variables.context){
d3757 1
a3757 1
			  if(mged_variables.context){
d3848 1
a3848 1
			  if(mged_variables.context){
d3889 1
a3889 1
			  if(mged_variables.context){
d3930 1
a3930 1
			  if(mged_variables.context){
d3971 1
a3971 1
			  if(mged_variables.context){
d4005 1
a4005 1
			  if(mged_variables.context){
d4066 1
a4066 1
			  if(mged_variables.context){
d4438 1
a4438 1
			  if(mged_variables.context){
d4500 1
a4500 1
			  if(mged_variables.context){
d4561 1
a4561 1
			  if(mged_variables.context){
d6204 2
a6205 2
		for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
		  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist){
d6270 2
a6271 2
	for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist){
d6402 2
a6403 2
	for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist){
d6490 2
a6491 2
	for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist){
@


11.78
log
@mods to build_tcl_edit_menu()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.77 1997/07/28 20:10:14 bparker Exp bparker $ (BRL)";
d6177 2
d6201 11
d6267 12
d6381 2
d6400 11
d6456 3
d6487 11
@


11.77
log
@mods to init_objedit()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.76 1997/07/25 20:49:26 bparker Exp bparker $ (BRL)";
d4667 1
d4669 4
a4672 1
    goto end;
a4711 1
#ifdef TRY_EDIT_NEW_WAY
a4717 9
#else
    MAT4X3PNT( temp, es_mat, es_keypoint );
    MAT4X3PNT( pos_view, model2view, temp );
    pos_view[X] = mousevec[X];
    pos_view[Y] = mousevec[Y];
    MAT4X3PNT( temp, view2model, pos_view );
    MAT4X3PNT( es_mparam, es_invmat, temp );
    es_mvalid = 1;	/* es_mparam is valid */
#endif
a4728 1
#ifdef TRY_EDIT_NEW_WAY
a4735 11
#else
      VADD2( temp, tgc->v, tgc->h );
      MAT4X3PNT(pos_model, es_mat, temp);
      MAT4X3PNT( pos_view, model2view, pos_model );
      pos_view[X] = mousevec[X];
      pos_view[Y] = mousevec[Y];
      /* Do NOT change pos_view[Z] ! */
      MAT4X3PNT( temp, view2model, pos_view );
      MAT4X3PNT( tr_temp, es_invmat, temp );
      VSUB2( tgc->h, tr_temp, tgc->v );
#endif
a4741 1
#ifdef TRY_EDIT_NEW_WAY
a4746 16
#else
    {
      struct rt_arb_internal *arb=
	(struct rt_arb_internal *)es_int.idb_ptr;
      RT_ARB_CK_MAGIC( arb );
      
      VMOVE( temp , arb->pt[es_menu] );
    }

    MAT4X3PNT(pos_model, es_mat, temp);
    MAT4X3PNT(pos_view, model2view, pos_model);
    pos_view[X] = mousevec[X];
    pos_view[Y] = mousevec[Y];
    MAT4X3PNT(temp, view2model, pos_view);
    MAT4X3PNT(pos_model, es_invmat, temp);
#endif
a4750 1
#ifdef TRY_EDIT_NEW_WAY
a4755 6
#else
    /* move arb edge, through indicated point */
    MAT4X3PNT( temp, view2model, mousevec );
    /* apply inverse of es_mat */
    MAT4X3PNT( pos_model, es_invmat, temp );
#endif
a4759 1
#ifdef TRY_EDIT_NEW_WAY
a4764 6
#else
    /* move arb face, through  indicated  point */
    MAT4X3PNT( temp, view2model, mousevec );
    /* apply inverse of es_mat */
    MAT4X3PNT( pos_model, es_invmat, temp );
#endif
a4792 1
#ifdef TRY_EDIT_NEW_WAY
a4797 4
#else
      if( (e = nmg_find_e_nearest_pt2( &m->magic, mousevec,
				       model2view, &tmp_tol )) ==
#endif
a4833 1
#ifdef TRY_EDIT_NEW_WAY
a4838 5
#else
    MAT4X3PNT( temp, view2model, mousevec );
    /* apply inverse of es_mat */
    MAT4X3PNT( es_mparam, es_invmat, temp );
#endif
a4848 1
end:
d4853 2
a4854 2
update_edit_absolute_tran(pos_view)
vect_t pos_view;
d4857 1
d4861 1
a4861 1
  MAT4X3PNT(model_pos, view2model, pos_view);
d4866 5
d4874 4
d6084 1
d7486 1
d7494 1
d7502 1
d7510 1
d7518 1
d7526 1
d7534 1
d7542 1
d7550 1
d7558 1
d7566 1
d7574 1
d7582 1
d7590 1
@


11.76
log
@mods to use new edit variables
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.75 1997/07/17 20:54:17 bparker Exp bparker $ (BRL)";
d5113 2
a5114 1
#if 0
a5120 2
#define MGED_SMALL_SCALE 1.0e-10

d5144 2
d5147 1
d5280 1
a5280 1
#if 0
a5342 3
#if 0
  MAT4X3PNT(pos_model, modelchanges, es_keypoint);
#else
a5344 1
#endif
d5349 1
d5351 1
d6198 3
d6203 2
d6206 2
@


11.75
log
@*- support for new interface edit menus
*- mods to sedit() ---> SROT
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.74 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
d2046 6
a2051 1
      VSETALL( edit_absolute_rotate, 0.0 );
d2054 4
a2057 1
      VSETALL( edit_absolute_tran, 0.0 );
d2181 11
a2191 2
	VSETALL( edit_absolute_rotate, 0.0 );
	VSETALL( edit_absolute_tran, 0.0 );
d2195 6
d4681 2
a4682 2
#ifdef TRY_EDIT_NEW_WAY
      MAT4X3PNT( pos_view, model2view, e_axes_pos );
a4694 16
#else
	MAT4X3PNT( temp, es_mat, es_keypoint );
	MAT4X3PNT( pos_view, model2view, temp );
	pos_view[X] = mousevec[X];
	pos_view[Y] = mousevec[Y];
	MAT4X3PNT( temp, view2model, pos_view );
	MAT4X3PNT( pt, es_invmat, temp );

	/* Need vector from current vertex/keypoint
	 * to desired new location.
	 */

	VSUB2( delta, es_keypoint, pt );
	bn_mat_idn( xlatemat );
	MAT_DELTAS_VEC_NEG( xlatemat, delta );
#endif
d4709 1
a4709 1
    MAT4X3PNT( pos_view, model2view, e_axes_pos );
d4736 1
a4736 1
      MAT4X3PNT(pos_view, model2view, e_axes_pos);
d4761 1
a4761 1
    MAT4X3PNT(pos_view, model2view, e_axes_pos);
d4787 1
a4787 1
    MAT4X3PNT(pos_view, model2view, e_axes_pos);
d4803 1
a4803 1
    MAT4X3PNT(pos_view, model2view, e_axes_pos);
d4843 1
a4843 1
      MAT4X3PNT( pos_view, model2view, e_axes_pos );
d4889 1
a4889 1
    MAT4X3PNT(pos_view, model2view, e_axes_pos);
d4923 2
a4924 1
  VSCALE(edit_absolute_tran, diff, inv_Viewscale);
d4926 3
a4928 3
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[X]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[Y]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[Z]));
d5113 1
d5117 1
a5217 3
#if 0
    MAT4X3PNT(pos_model, modelchanges, es_keypoint);
#else
a5219 1
#endif
a5222 1
#ifdef DO_NEW_EDIT_MATS
a5223 3
#else
    new_mats();
#endif
a5228 4
#if 0
    VMOVE( temp, es_keypoint );
    MAT4X3PNT( pos_view, model2objview, es_keypoint );
#else
d5231 1
a5231 1
#endif
a5245 1
#ifdef DO_NEW_EDIT_MATS
a5246 3
#else
    new_mats();
#endif
a5266 3
#if 0
  VMOVE(temp, es_keypoint);
#else
a5267 1
#endif
a5275 1
#ifdef DO_NEW_EDIT_MATS
a5276 3
#else
  new_mats();
#endif
d5278 1
d5282 1
a5348 1
#ifdef DO_NEW_EDIT_MATS
a5349 3
#else
  new_mats();
#endif
d6195 5
a6199 2
	VSETALL( edit_absolute_rotate, 0.0 );
	VSETALL( edit_absolute_tran, 0.0 );
d6202 6
d6601 2
a6602 1
    VSCALE(edit_absolute_tran, diff, inv_Viewscale);
d6604 1
a6604 1
    VMOVE(edit_absolute_rotate, es_para);
a6700 1
#ifdef DO_NEW_EDIT_MATS
a6701 3
#else
	new_mats();
#endif
@


11.74
log
@mods to run without a database
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.73 1997/06/25 13:41:47 bparker Exp bparker $ (BRL)";
a2049 3
#if 0
    }else if(SEDIT_SCALE){
#else
a2050 1
#endif
d2060 2
a2061 5
#if 0
    if(mged_variables.transform == 'e')
      scroll_edit = es_edclass;
    else
      scroll_edit = EDIT_CLASS_NULL;
a2063 2
    bn_mat_idn(acc_rot_sol);

a2160 3
	sedit_menu();		/* put up menu header */
	build_tcl_edit_menu();

d2168 12
d2447 1
d2453 1
a2453 1
	update_views = 1;
d2458 2
a2459 2
	  /* do nothing */
	  update_views = 0;
d3241 18
d3261 1
a3261 1
			  bn_mat_xform_about_pt( edit, incr_change, es_keypoint );
d3271 1
a3271 1
			  MAT4X3PNT(work, es_invmat, es_keypoint);
d5208 3
d5213 1
d5227 4
d5233 1
d5264 1
a5264 1
vect_t tvec;
d5266 3
a5268 3
  vect_t  pos_model;
  vect_t  tr_temp;
  vect_t  temp;
d5273 3
d5277 2
a5278 1
  MAT4X3PNT( pos_model, view2model, tvec);/* NOT objview */
d5353 3
d5358 1
d6211 4
d6699 3
d6704 1
d7457 1
a7457 1
    	point_t key;
d7460 1
a7460 1
    	VSCALE( key, es_keypoint, base2local );
@


11.73
log
@*** empty log message ***
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.72 1997/05/27 22:00:10 butler Exp bparker $ (BRL)";
d83 1
d778 3
d2091 3
d2171 1
a2173 6
#if 0
	dmp->dm_light( dmp, LIGHT_ON, BE_ACCEPT );
	dmp->dm_light( dmp, LIGHT_ON, BE_REJECT );
	dmp->dm_light( dmp, LIGHT_OFF, BE_S_ILLUMINATE );
#endif

d2448 2
d5347 3
d6114 1
d6121 3
d6174 5
d6195 3
d6306 3
d6367 3
d6477 3
d6592 3
d7391 3
d7447 150
@


11.72
log
@Fixed dsp editing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.71 1997/05/23 00:59:44 butler Exp butler $ (BRL)";
d2061 1
a2061 1
    if(mged_variables.edit)
d2069 1
a2069 1
    mged_variables.edit = 1;
@


11.71
log
@misc dsp foolishness
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.70 1997/05/22 09:29:07 butler Exp butler $ (BRL)";
d208 1
a208 1
#define	MENU_DSP_FSIZE		83
a569 1
	{"file size (W N)", dsp_ed, MENU_DSP_FSIZE },
d2411 7
a2417 3
	bn_mat_mul(mat2, scalemat, es_mat);
	bn_mat_mul(mat, es_invmat, mat2);
	transform_editing_solid(&es_int, mat, &es_int, 1);
a2465 42
	case ECMD_DSP_FSIZE:	/* set file size */
		{
			struct rt_dsp_internal *dsp =
				(struct rt_dsp_internal *)es_int.idb_ptr;
			struct stat stat_buf;
			off_t need_size;

			RT_DSP_CK_MAGIC( dsp );

			if( inpara == 2 )
			{
				if( stat( dsp->dsp_file, &stat_buf ) )
				{
					Tcl_AppendResult(interp, "Cannot get status of file ", dsp->dsp_file, (char *)NULL );
					mged_print_result( TCL_ERROR );
					return;
				}
				need_size = dsp->dsp_xcnt * dsp->dsp_ycnt * 2;
				
				if( stat_buf.st_size < need_size )
				{
					Tcl_AppendResult(interp,
						"File (", dsp->dsp_file,
						") is too small, set file name first",
						(char *)NULL );
					mged_print_result( TCL_ERROR );
					return;
				}
				dsp->dsp_xcnt = es_para[0];
				dsp->dsp_ycnt = es_para[1];
			}
			else if( inpara > 0 )
			{
				Tcl_AppendResult(interp,
					"width and length of file are required\n",
					(char *)NULL );
				mged_print_result( TCL_ERROR );
				return;
			}
		}
		break;

@


11.70
log
@added support for dsp solid
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.69 1997/05/13 12:50:33 jra Exp butler $ (BRL)";
d742 1
d2387 29
d2455 2
a2456 3
		{
			break;
		}
d2458 2
a2459 3
		{
			break;
		}
d2461 2
a2462 20
		{
			struct rt_dsp_internal *dsp =
				(struct rt_dsp_internal *)es_int.idb_ptr;
			mat_t m, mat1, mat2;
			mat_t scalemat;

			RT_DSP_CK_MAGIC(dsp);
			
			if ( inpara == 1) {
				mat_idn(m);
				m[MSZ] = es_para[0];
			}
			bn_mat_xform_about_pt(scalemat, m, es_keypoint);
			bn_mat_mul(mat2, scalemat, es_mat);
			bn_mat_mul(mat1, es_invmat, mat2);
			transform_editing_solid(&es_int, mat, &es_int, 1);
			

			break;
		}
d3102 2
d4640 3
d6558 3
@


11.69
log
@"keypoint" command now displays the keypoint in model units.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.68 1997/04/24 18:03:58 bparker Exp jra $ (BRL)";
d76 1
a76 1
static void	nmg_ed(), pipe_ed(), vol_ed(), ebm_ed();
d207 5
d213 1
d567 10
d716 27
d1536 13
d2290 3
d2424 108
d2620 3
a2622 1
				Tcl_AppendResult(interp, "extrusion depth required\n", (char *)NULL );
@


11.68
log
@modify calls to Tcl_Eval
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.67 1997/04/23 18:30:43 bparker Exp bparker $ (BRL)";
d7231 1
d7233 2
d7236 1
a7236 1
      bu_vls_printf(&tmp_vls, "%s (%g, %g, %g)\n", es_keytag, V3ARGS(es_keypoint));
@


11.67
log
@*** empty log message ***
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.66 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d6145 6
a6150 1
	  Tcl_Eval(interp, "help eqn");
d6419 6
a6424 1
    Tcl_Eval(interp, "help p");
d7213 6
a7218 1
    Tcl_Eval(interp, "help keypoint");
@


11.66
log
@mods so that commands check args internally
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.65 1997/03/25 14:43:44 jra Exp bparker $ (BRL)";
a57 1
#include "./menu.h"
d1878 3
d1979 1
@


11.65
log
@Mods to support MGED's read-only mode.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.64 1997/03/12 20:45:46 jra Exp jra $ (BRL)";
d6141 2
a6142 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d6144 1
d6408 1
a6408 1
	CHECK_READ_ONLY;
d6410 2
a6411 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d6413 1
d7199 2
a7200 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d7202 1
@


11.64
log
@removed dependencies on db.h.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.63 1997/03/06 21:42:59 bparker Exp jra $ (BRL)";
d6017 2
d6031 14
d6139 2
d6183 1
d6192 8
d6405 2
@


11.63
log
@call new_edit_mats instead of new_mats
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.62 1997/02/28 21:36:17 bparker Exp bparker $ (BRL)";
a47 1
#include "db.h"
d85 1
d87 1
a2014 40

/* 	CALC_PLANES()
 *		calculate the plane (face) equations for an arb
 *		in solidrec pointed at by sp
 * XXX replaced by rt_arb_calc_planes()
 */
void
calc_planes( sp, type )
struct solidrec *sp;
int type;
{
	struct solidrec temprec;
	register int i, p1, p2, p3;

	/* find the plane equations */
	/* point notation - use temprec record */
	VMOVE( &temprec.s_values[0], &sp->s_values[0] );
	for(i=3; i<=21; i+=3) {
		VADD2( &temprec.s_values[i], &sp->s_values[i], &sp->s_values[0] );
	}
	type -= 4;	/* ARB4 at location 0, ARB5 at 1, etc */
	for(i=0; i<6; i++) {
		if(arb_faces[type][i*4] == -1)
			break;	/* faces are done */
		p1 = arb_faces[type][i*4];
		p2 = arb_faces[type][i*4+1];
		p3 = arb_faces[type][i*4+2];
		if(planeqn(i, p1, p2, p3, &temprec)) {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "No eqn for face %d%d%d%d\n",
				p1+1,p2+1,p3+1,arb_faces[type][i*4+3]+1);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		  return;
		}
	}
}

a2233 39
}

/* 			C A L C _ P N T S (  )
 * XXX replaced by rt_arb_calc_points() in facedef.c
 *
 * Takes the array es_peqn[] and intersects the planes to find the vertices
 * of a GENARB8.  The vertices are stored in the solid record 'old_srec' which
 * is of type 'type'.  If intersect fails, the points (in vector notation) of
 * 'old_srec' are used to clean up the array es_peqn[] for anyone else. The
 * vertices are put in 'old_srec' in vector notation.  This is an analog to
 * calc_planes().
 */
void
calc_pnts( old_srec, type )
struct solidrec *old_srec;
int type;
{
	struct solidrec temp_srec;
	short int i;

	/* find new points for entire solid */
	for(i=0; i<8; i++){
	  /* use temp_srec until we know intersect doesn't fail */
	  if( intersect(type,i*3,i,&temp_srec) ){
	    Tcl_AppendResult(interp, "Intersection of planes fails\n", (char *)NULL);
	    /* clean up array es_peqn for anyone else */
	    calc_planes( old_srec, type );
	    return;				/* failure */
	  }
	}

	/* back to vector notation */
	VMOVE( &old_srec->s_values[0], &temp_srec.s_values[0] );
	for(i=3; i<=21; i+=3){
		VSUB2(	&old_srec->s_values[i],
			&temp_srec.s_values[i],
			&temp_srec.s_values[0]  );
	}
	return;						/* success */
@


11.62
log
@call mmenu_set_all instead of mmenu_set
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.61 1997/02/14 22:09:01 bparker Exp bparker $ (BRL)";
d5120 3
d5124 1
d5146 3
d5150 1
d5180 3
d5184 1
d5251 3
d5255 2
d6516 3
d6520 1
@


11.61
log
@*** empty log message ***
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.60 1997/01/29 23:15:45 bparker Exp bparker $ (BRL)";
d2220 1
a2220 1
	mmenu_set( MENU_L1, MENU_NULL );
d2226 1
a2226 1
		mmenu_set( MENU_L1, cntrl_menu );
d2229 1
a2229 1
		mmenu_set( MENU_L1, tgc_menu );
d2232 1
a2232 1
		mmenu_set( MENU_L1, tor_menu );
d2235 1
a2235 1
		mmenu_set( MENU_L1, ell_menu );
d2238 1
a2238 1
		mmenu_set( MENU_L1, ars_menu );
d2241 1
a2241 1
		mmenu_set( MENU_L1, spline_menu );
d2244 1
a2244 1
		mmenu_set( MENU_L1, rpc_menu );
d2247 1
a2247 1
		mmenu_set( MENU_L1, rhc_menu );
d2250 1
a2250 1
		mmenu_set( MENU_L1, epa_menu );
d2253 1
a2253 1
		mmenu_set( MENU_L1, ehy_menu );
d2256 1
a2256 1
		mmenu_set( MENU_L1, eto_menu );
d2259 1
a2259 1
		mmenu_set( MENU_L1, nmg_menu );
d2262 1
a2262 1
		mmenu_set( MENU_L1, pipe_menu );
d2265 1
a2265 1
		mmenu_set( MENU_L1, vol_menu );
d2268 1
a2268 1
		mmenu_set( MENU_L1, ebm_menu );
d2338 1
a2338 1
 {%s} vertex_num %d 0 OK", dName, bu_vls_addr(&str), arb_vertices[type][loc]);
@


11.60
log
@mods to update scrollbars
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.59 1997/01/24 21:02:48 bparker Exp bparker $ (BRL)";
d2338 1
a2338 1
 {%s} vertex_num %d 0 OK", dname, bu_vls_addr(&str), arb_vertices[type][loc]);
@


11.59
log
@mods to update sliders
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.58 1997/01/08 21:16:05 jra Exp bparker $ (BRL)";
a65 1
extern void bv_edit_toggle();
d2000 1
d2005 1
d2009 2
a2010 2
    mged_variables.edit = 0;
    bv_edit_toggle();
d2337 1
a2337 1
  bu_vls_printf(&cmd, "mged_input_dialog .get_vertex %s {Need vertex for solid rotate}\
a2355 9
  
#if 0
  /* check whether nimble fingers entered valid vertex */
  valid = 0;
  for(j=0; j<4; j++)  {
    if( fixv==arb_vertices[type][loc+j] )
      valid=1;
  }
#endif
d6145 2
d6157 2
d6267 2
d6271 2
a6272 2
	menuflag = 0;
	movedir = 0;
a6302 1
	  mat_t mat;
d6315 2
@


11.58
log
@Typo in vls_solid().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.57 1997/01/07 22:38:18 bparker Exp jra $ (BRL)";
d65 1
d113 1
d1981 24
a2004 8
    if(EDIT_ROTATE)
      VSETALL( edit_absolute_rotate, 0.0 )
    else if(EDIT_TRAN)
      VSETALL( edit_absolute_tran, 0.0 )
    else if(SEDIT_SCALE){
      edit_absolute_scale = 0;
      acc_sc_sol = 1;
    }
d4559 2
a4560 1
    break;
a4605 1
    update_edit_absolute_tran(pos_view);
a4633 1
    update_edit_absolute_tran(pos_view);
a4663 1
    update_edit_absolute_tran(pos_view);
a4691 1
    update_edit_absolute_tran(pos_view);
a4707 1
    update_edit_absolute_tran(pos_view);
a4732 1
    update_edit_absolute_tran(pos_view);
d4781 1
a4781 4
#ifdef TRY_EDIT_NEW_WAY
      update_edit_absolute_tran(pos_view);
#endif
    }
a4808 1
    update_edit_absolute_tran(pos_view);
d4814 1
a4814 1
  }
d4816 2
d4832 4
a4835 3
  
  if(BU_LIST_NON_EMPTY(&head_cmd_list.l))
    (void)Tcl_Eval(interp, "set_sliders");
d5020 3
d5050 1
d5129 1
d5181 4
d5248 1
d6152 1
d6162 5
a6166 3
    	if( es_int.idb_ptr )  rt_functab[es_int.idb_type].ft_ifree( &es_int );
	es_int.idb_ptr = (genptr_t)NULL;
	db_free_external( &es_ext );
d6168 1
a6168 1
	bn_mat_idn( acc_rot_sol );
d6272 1
d6317 1
@


11.57
log
@more mods to sedit()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.56 1997/01/03 21:45:25 bparker Exp bparker $ (BRL)";
d5248 1
a5248 1
	if( id != ID_ARS || id != ID_POLY )
@


11.56
log
@mods to sedit()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.55 1997/01/02 21:55:37 bparker Exp bparker $ (BRL)";
d3632 9
a3640 1
			else if( inpara == 3 )
d3642 2
d3722 13
a3734 3
				VMOVE( new_pt , es_mparam )
			else if( inpara == 3 )
				VMOVE( new_pt , es_para )
d3763 10
a3772 2
				VMOVE( new_pt , es_mparam )
			else if( inpara == 3 )
d3774 2
d3805 9
a3813 1
			else if( inpara == 3 )
d3815 2
d3846 9
a3854 1
			else if( inpara == 3 )
d3856 2
d3880 9
a3888 1
			else if( inpara == 3 )
d3890 2
d3941 9
a3949 1
			else if( inpara == 3 )
d3951 2
d4313 9
a4321 1
			else if( inpara == 3 )
d4323 2
d4375 9
a4383 1
			else if( inpara == 3 )
d4385 2
d4436 9
a4444 1
			else if( inpara == 3 )
d4446 2
@


11.55
log
@*- mods so that mousevec ( a CONST) is not changed
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.54 1997/01/02 19:36:55 bparker Exp bparker $ (BRL)";
d1961 2
d1964 7
a1970 4
      VADD2(curr_e_axes_pos, tgc->h, tgc->v);
      MAT4X3PNT(curr_e_axes_pos, es_mat, curr_e_axes_pos);
      break;
    }
d2415 4
d2723 8
d2733 1
d2836 22
d2860 1
d2863 1
d2999 8
d3008 1
d3023 9
d3035 1
d3077 9
d3089 1
d3111 8
d3121 1
a3128 4
			mat_t	mat;
			mat_t	mat1;
			mat_t	edit;

d3190 45
a3234 2
			MAT4X3VEC(work, incr_change, tgc->h);
			VMOVE(tgc->h, work);
d3247 30
d3278 18
d3304 1
a3304 1

d3316 44
d3362 1
d3384 12
a3395 3
			else if( inpara == 3 )
				VMOVE( new_pt , es_para )
			else if( inpara && inpara != 3 )
d3550 12
a3561 3
			else if( inpara == 3 )
				VMOVE( new_pt , es_para )
			else if( inpara && inpara != 3 )
d4593 1
a4593 1
    update_edit_absolute_tran(mousevec);
d4619 1
a4619 1
    update_edit_absolute_tran(mousevec);
d4637 7
d4646 1
d4668 3
a4670 2

      update_edit_absolute_tran(mousevec);
d4699 1
a4699 1
    update_edit_absolute_tran(mousevec);
d6212 1
d6221 1
@


11.54
log
@mods to use libbn and libbu
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.53 1996/12/30 22:33:40 bparker Exp bparker $ (BRL)";
d4226 3
a4228 2
      mousevec[Z] = pos_view[Z];
      MAT4X3PNT( pt, view2model, mousevec );
d4270 3
a4272 2
    mousevec[Z] = pos_view[Z];
    MAT4X3PNT( temp, view2model, mousevec );
d4298 4
a4301 2
      mousevec[Z] = pos_view[Z];
      MAT4X3PNT(temp, view2model, mousevec);
d4324 3
a4326 2
    mousevec[Z] = pos_view[Z];
    MAT4X3PNT(temp, view2model, mousevec);
d4351 3
a4353 2
    mousevec[Z] = pos_view[Z];
    MAT4X3PNT(temp, view2model, mousevec);
d4368 3
a4370 2
    mousevec[Z] = pos_view[Z];
    MAT4X3PNT(temp, view2model, mousevec);
d4449 3
a4451 2
    mousevec[Z] = pos_view[Z];
    MAT4X3PNT(temp, view2model, mousevec);
@


11.53
log
@*- call sedit() directly
*- replot edited solid when multiply referenced
*- mods to sedit_mouse
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.52 1996/12/23 19:59:00 jra Exp bparker $ (BRL)";
d47 1
d66 1
a66 1
extern struct rt_tol		mged_tol;	/* from ged.c */
d106 1
a106 1
struct rt_external	es_ext;
d1297 1
a1297 1
					if( (ret_val=rt_isect_lseg3_lseg3( dist, v1->vg_p->coord, edge1,
d1446 1
a1446 1
						if( !rt_mkpoint_3planes( mpt , arbn->eqn[i] , arbn->eqn[j] , arbn->eqn[k] ) )
d1983 1
a1983 1
    mat_idn(acc_rot_sol);
d2053 1
a2053 1
	RT_INIT_EXTERNAL(&es_ext);
d2061 1
a2061 1
	if( rt_functab[id].ft_import( &es_int, &es_ext, rt_identity ) < 0 )  {
d2107 1
a2107 1
	mat_inv( es_invmat, es_mat );
d2357 1
a2357 1
		dir = (char *)rt_malloc( (strlen(str)+1)*sizeof( char ), "get_file_name: dir" );
d2803 1
a2803 1
			mat_inv( invsolr, acc_rot_sol );
d2811 1
a2811 1
				mat_idn( modelchanges );
d2816 1
a2816 1
				mat_copy(acc_rot_sol, modelchanges);
d2848 1
a2848 1
			mat_idn( modelchanges );
d2867 1
a2867 1
		mat_idn( incr_change );
d2889 3
a2891 3
			mat_scale_about_pt( scalemat, es_keypoint, es_scale );
			mat_mul(mat2, scalemat, es_mat);
			mat_mul(mat, es_invmat, mat2);
d2918 1
a2918 1
			    mat_idn( xlatemat );
d2924 1
a2924 1
			    mat_idn( xlatemat );
d2929 1
a2929 1
				mat_idn( xlatemat );
d2993 1
a2993 1
			mat_vec_perp( tgc->b, tgc->h );
d3062 1
a3062 1
				mat_inv( invsolr, acc_rot_sol );
d3065 1
a3065 1
				mat_idn( modelchanges );
d3071 2
a3072 2
				mat_mul( incr_change, modelchanges, invsolr );
				mat_copy(acc_rot_sol, modelchanges);
d3076 1
a3076 1
				mat_idn( modelchanges );
d3085 1
a3085 1
			  mat_xform_about_pt( edit, incr_change, es_keypoint );
d3092 2
a3093 2
			  mat_mul( mat1, edit, es_mat );
			  mat_mul( mat, es_invmat, mat1 );
d3096 1
a3096 1
			  mat_xform_about_pt( mat, incr_change, work );
d3099 1
a3099 1
			mat_xform_about_pt( mat, incr_change, es_keypoint);
d3103 1
a3103 1
			mat_idn( incr_change );
d3117 1
a3117 1
			mat_idn( incr_change );
d3138 1
a3138 1
			mat_idn( incr_change );
d3152 1
a3152 1
		mat_idn( incr_change );
d3209 1
a3209 1
					if( rt_isect_line3_plane( &dist , new_pt , view_dir , pl , &mged_tol ) < 1)
d3370 1
a3370 1
					if( rt_isect_line3_plane( &dist , new_pt , view_dir , pl , &mged_tol ) < 1)
d3417 1
a3417 1
			if( rt_isect_line3_plane( &dist , to_pt , extrude_vec , lu_pl , &mged_tol ) < 1 )
d4235 1
a4235 1
      mat_idn( xlatemat );
d4250 1
a4250 1
	mat_idn( xlatemat );
d4390 1
a4390 1
      struct rt_tol	tmp_tol;
d4394 1
a4394 1
      tmp_tol.magic = RT_TOL_MAGIC;
d4512 1
a4512 1
      mat_idn( xlatemat );
d4597 1
a4597 1
      struct rt_tol	tmp_tol;
d4601 1
a4601 1
      tmp_tol.magic = RT_TOL_MAGIC;
d4704 1
a4704 1
  mat_idn( incr_change );
d4764 1
a4764 1
    mat_idn( incr_change );
d4782 2
a4783 2
    mat_copy( oldchanges, modelchanges );
    mat_mul( modelchanges, incr_change, oldchanges );
d4785 1
a4785 1
    mat_idn( incr_change );
d4806 1
a4806 1
  mat_idn( incr_mat );
d4813 2
a4814 2
  mat_copy( oldchanges, modelchanges );
  mat_mul( modelchanges, incr_mat, oldchanges );
d4828 1
a4828 1
  mat_idn( incr_mat );
d4951 1
a4951 1
			rt_log( "es_scale = %g\n", es_scale );
d5663 1
a5663 1
	mat_idn(es_mat);
d5687 1
a5687 1
	if( rt_functab[id].ft_import( &es_int, &es_ext, rt_identity ) < 0 )  {
d5712 1
a5712 1
	mat_inv( es_invmat, es_mat );
d5741 4
a5744 4
		mat_idn( topm );
		mat_idn( inv_topm );
		mat_idn( deltam );
		mat_idn( tempm );
d5748 1
a5748 1
		mat_inv( inv_topm, topm );
d5750 2
a5751 2
		mat_mul( tempm, modelchanges, topm );
		mat_mul( deltam, inv_topm, tempm );
d5781 2
a5782 2
	mat_idn( modelchanges );
	mat_idn( acc_rot_sol );
d5796 1
a5796 1
	mat_idn( acc_rot_sol );
d6089 1
a6089 1
	mat_idn( incr_change );
d6093 2
a6094 2
	mat_mul(tempp, incr_change, acc_rot_sol);
	mat_copy(acc_rot_sol, tempp);
d6116 1
a6116 1
	mat_idn( incr_change );
d6120 1
a6120 1
	mat_mul(tempp, modelchanges, es_mat);
d6268 1
a6268 1
			mat_vec_ortho( adir, tor->h );
d6430 1
a6430 1
			vec_ortho( Au, Nu );
d6561 1
a6561 1
CONST struct rt_tol	*tol;
d6566 1
a6566 1
	RT_CK_TOL( tol );
d6577 1
a6577 1
		if( rt_mk_plane_3pts( planes[i],
@


11.52
log
@Mod to SROT editing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.51 1996/12/20 22:52:00 bparker Exp jra $ (BRL)";
d589 6
a594 6
	es_menu = arg;
	es_edflag = EARB;
	if(arg == 12)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedraw = 1;
	}
d596 1
a596 1
	set_e_axes_pos(1);
d603 11
a613 11
	es_menu = arg;
	es_edflag = EARB;
	if(arg == 11) {
		/* move point 5 */
		es_edflag = PTARB;
		es_menu = 4;	/* location of point */
	}
	if(arg == 12)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedraw = 1;
	}
d615 1
a615 1
	set_e_axes_pos(1);
d622 16
a637 16
	es_menu = arg;
	es_edflag = EARB;
	if(arg == 8) {
		/* move point 5   location = 4 */
		es_edflag = PTARB;
		es_menu = 4;
	}
	if(arg == 9) {
		/* move point 6   location = 6 */
		es_edflag = PTARB;
		es_menu = 6;
	}
	if(arg == 10)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedraw = 1;
	}
d639 1
a639 1
	set_e_axes_pos(1);
d646 11
a656 11
	es_menu = arg;
	es_edflag = EARB;
	if(arg == 8) {
		/* move point 5 at loaction 4 */
		es_edflag = PTARB;
		es_menu = 4;
	}
	if(arg == 9)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedraw = 1;
	}
d658 1
a658 1
	set_e_axes_pos(1);
d665 6
a670 6
	es_menu = arg;
	es_edflag = PTARB;
	if(arg == 5)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedraw = 1;
	}
d672 1
a672 1
	set_e_axes_pos(1);
d679 13
a691 2
	es_menu = arg;
	sedraw = 1;
d693 2
a694 13
	switch( arg )
	{
		case MENU_EBM_FNAME:
			es_edflag = ECMD_EBM_FNAME;
			break;
		case MENU_EBM_FSIZE:
			es_edflag = ECMD_EBM_FSIZE;
			break;
		case MENU_EBM_HEIGHT:
			es_edflag = ECMD_EBM_HEIGHT;
			break;
	}
	set_e_axes_pos(1);
d701 19
a719 2
	es_menu = arg;
	sedraw = 1;
d721 2
a722 19
	switch( arg )
	{
		case MENU_VOL_FNAME:
			es_edflag = ECMD_VOL_FNAME;
			break;
		case MENU_VOL_FSIZE:
			es_edflag = ECMD_VOL_FSIZE;
			break;
		case MENU_VOL_CSIZE:
			es_edflag = ECMD_VOL_CSIZE;
			break;
		case MENU_VOL_THRESH_LO:
			es_edflag = ECMD_VOL_THRESH_LO;
			break;
		case MENU_VOL_THRESH_HI:
			es_edflag = ECMD_VOL_THRESH_HI;
			break;
	}
	set_e_axes_pos(1);
a750 1
			sedraw = 1;
d754 1
a768 1
			sedraw = 1;
d772 1
a813 1
			sedraw = 1;
d816 1
d922 1
a922 1
		sedraw = 1;
d936 1
a936 1
		sedraw = 1;
d950 1
a950 1
		sedraw = 1;
d960 6
a965 6
	es_menu = arg - 1;
	es_edflag = ECMD_ARB_MOVE_FACE;
	if(arg == 6)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedraw = 1;
	}
d967 1
a967 1
	set_e_axes_pos(1);
d974 6
a979 6
	es_menu = arg - 1;
	es_edflag = ECMD_ARB_MOVE_FACE;
	if(arg == 5)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedraw = 1;
	}
d981 1
a981 1
	set_e_axes_pos(1);
d988 6
a993 7
	es_menu = arg - 1;
	es_edflag = ECMD_ARB_SETUP_ROTFACE;
	sedraw = 1;
	if(arg == 7)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedraw = 1;
	}
d1000 6
a1005 7
	es_menu = arg - 1;
	es_edflag = ECMD_ARB_SETUP_ROTFACE;
	sedraw = 1;
	if(arg == 7)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedraw = 1;
	}
d1012 6
a1017 7
	es_menu = arg - 1;
	es_edflag = ECMD_ARB_SETUP_ROTFACE;
	sedraw = 1;
	if(arg == 6)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedraw = 1;
	}
d1024 6
a1029 7
	es_menu = arg - 1;
	es_edflag = ECMD_ARB_SETUP_ROTFACE;
	sedraw = 1;
	if(arg == 6)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedraw = 1;
	}
d1036 6
a1041 7
	es_menu = arg - 1;
	es_edflag = ECMD_ARB_SETUP_ROTFACE;
	sedraw = 1;
	if(arg == 5)  {
		es_edflag = ECMD_ARB_MAIN_MENU;
		sedraw = 1;
	}
d1048 3
a1050 3
	es_menu = arg;
	es_edflag = ECMD_ARB_SPECIFIC_MENU;
	sedraw = 1;
d1058 2
a1059 2
	es_edflag = arg;
	sedraw = 1;
d1068 9
a1076 9
	/* XXX Why wasn't this done by setting es_edflag = ECMD_SPLINE_VPICK? */
	if( arg < 0 )  {
		/* Enter picking state */
		chg_state( ST_S_EDIT, ST_S_VPICK, "Vertex Pick" );
		return;
	}
	/* For example, this will set es_edflag = ECMD_VTRANS */
	es_edflag = arg;
	sedraw = 1;
d1155 1
a1155 1
		sedraw = 1;
d1176 1
a1176 1
		sedraw = 1;
d1197 1
a1197 1
		sedraw = 1;
d1365 1
a1365 1
	sedraw = 1;
d1977 1
a1977 1
    else if(SEDIT_SCALE)
d1979 2
d2130 1
a2130 1
	sedraw = 1;
d2154 11
a2164 1
	(void)replot_modified_solid( illump, &es_int, es_mat );
d2878 1
d2889 3
a2891 1
			transform_editing_solid(&es_int, scalemat, &es_int, 1);
d2911 1
a2911 3
#if 1
			  /* move solid so that es_keypoint is at position es_para */
			  {
d2919 6
a2926 7
			  /* move solid to position es_para */
			  MAT4X3PNT(work, es_invmat, es_keypoint);
			  VSUB2( delta, work, es_para );
			  mat_idn( xlatemat );
			  MAT_DELTAS_VEC_NEG( xlatemat, delta );
#endif
#else
d3081 16
a3096 3
#if 0
			MAT4X3PNT(work, es_invmat, es_keypoint);
			mat_xform_about_pt( mat, incr_change, work );
d3098 1
a3098 10
			/* calculate rotations about keypoint */
			mat_xform_about_pt( edit, incr_change, es_keypoint );

			/* We want our final matrix (mat) to xform the original solid
			 * to the position of this instance of the solid, perform the
			 * current edit operations, then xform back.
			 *	mat = es_invmat * edit * es_mat
			 */
			mat_mul( mat1, edit, es_mat );
			mat_mul( mat, es_invmat, mat1 );
d4151 1
a4151 1
	if (! es_keyfixed)
a4222 1

d4224 3
a4226 4
      MAT4X3PNT( pos_view, model2view, es_keypoint );
      pos_view[X] = mousevec[X];
      pos_view[Y] = mousevec[Y];
      MAT4X3PNT( pt, view2model, pos_view );
d4237 6
a4242 6
      MAT4X3PNT( temp, es_mat, es_keypoint );
      MAT4X3PNT( pos_view, model2view, temp );
      pos_view[X] = mousevec[X];
      pos_view[Y] = mousevec[Y];
      MAT4X3PNT( temp, view2model, pos_view );
      MAT4X3PNT( pt, es_invmat, temp );
d4244 3
a4246 3
      /* Need vector from current vertex/keypoint
       * to desired new location.
       */
d4248 3
a4250 3
      VSUB2( delta, es_keypoint, pt );
      mat_idn( xlatemat );
      MAT_DELTAS_VEC_NEG( xlatemat, delta );
d4267 3
a4269 4
    MAT4X3PNT( pos_view, model2view, es_keypoint );
    pos_view[X] = mousevec[X];
    pos_view[Y] = mousevec[Y];
    MAT4X3PNT( temp, view2model, pos_view );
d4293 7
d4309 1
d4317 6
d4337 1
d4343 6
d4353 1
d4359 6
d4369 1
d4439 6
d4448 1
d4662 2
d4678 4
a4681 1
  else
d4683 1
a4685 1

d4833 4
a4836 1
  else
d4838 1
d5929 10
a5938 2
	/* Restore the original solid */
	replot_original_solid( illump );
a5973 1
  sedraw++;
a5984 1
	    sedraw = 0;
a5992 1
	  sedraw = 0;
@


11.51
log
@mods to set_e_axes_pos
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.50 1996/12/19 22:08:35 bparker Exp bparker $ (BRL)";
d3042 2
d3074 1
a3074 1
#ifdef TRY_EDIT_NEW_WAY
d3078 10
a3087 1
			mat_xform_about_pt( mat, incr_change, es_keypoint );
@


11.50
log
@mods to sedit
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.49 1996/12/19 16:35:02 jra Exp bparker $ (BRL)";
d596 1
a596 1
	set_e_axes_pos();
d615 1
a615 1
	set_e_axes_pos();
d639 1
a639 1
	set_e_axes_pos();
d658 1
a658 1
	set_e_axes_pos();
d672 1
a672 1
	set_e_axes_pos();
d694 1
a694 1
	set_e_axes_pos();
d722 1
a722 1
	set_e_axes_pos();
d819 1
a819 1
	set_e_axes_pos();
d837 1
a837 1
	set_e_axes_pos();
d848 1
a848 1
	set_e_axes_pos();
d861 1
a861 1
	set_e_axes_pos();
d871 1
a871 1
	set_e_axes_pos();
d881 1
a881 1
	set_e_axes_pos();
d891 1
a891 1
	set_e_axes_pos();
d901 1
a901 1
	set_e_axes_pos();
d911 1
a911 1
	set_e_axes_pos();
d925 1
a925 1
	set_e_axes_pos();
d939 1
a939 1
	set_e_axes_pos();
d953 1
a953 1
	set_e_axes_pos();
d967 1
a967 1
	set_e_axes_pos();
d981 1
a981 1
	set_e_axes_pos();
d1083 1
a1083 1
	set_e_axes_pos();
d1874 3
a1876 1
set_e_axes_pos()
d1957 1
a1957 2
#if 1
    MAT4X3PNT(e_axes_pos, es_mat,
a1958 4
    VMOVE(curr_e_axes_pos, e_axes_pos);
#else
    VMOVE(e_axes_pos, ((struct rt_arb_internal *)es_int.idb_ptr)->pt[i]);
#endif
d1966 2
a1967 1
      VADD2(e_axes_pos, tgc->h, tgc->v);
d1971 1
a1971 1
    VMOVE(e_axes_pos, es_keypoint);
d1975 9
a1983 6
  if(EDIT_ROTATE)
    VSETALL( edit_absolute_rotate, 0.0 )
  else if(EDIT_TRAN)
    VSETALL( edit_absolute_tran, 0.0 )
  else if(SEDIT_SCALE)
    edit_absolute_scale = 0;
d1985 1
a1985 1
  mat_idn(acc_rot_sol);
d1987 3
a1989 2
  mged_variables.edit = 0;
  bv_edit_toggle();
d2776 1
a2776 1
		set_e_axes_pos();
d4006 1
d4058 1
d4132 1
d5649 1
a5649 1
	set_e_axes_pos();
@


11.49
log
@Added editing for EBM solid
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.48 1996/12/18 22:21:44 bparker Exp jra $ (BRL)";
d89 1
d1958 1
d2898 20
d2921 1
d3070 2
a3071 2
#if 0
			MAT4X3VEC(work, es_invmat, es_keypoint);
d4831 1
a4831 1
	if( id != ID_ARS )
@


11.48
log
@*- mods to sedit_mouse, sedit_trans, f_param
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.47 1996/12/18 17:13:40 jra Exp bparker $ (BRL)";
d77 1
a77 1
static void	nmg_ed(), pipe_ed(), vol_ed();
d201 3
d550 8
d675 22
d2231 3
d2332 2
a2333 1
get_file_name()
d2336 4
d2343 15
a2357 1
	bu_vls_printf( &cmd, "fs_dialog .w . * new_file" );
d2363 5
d2371 1
a2371 4
		if( interp->result[0] == '1' )
			return( Tcl_GetVar( interp, "new_file", TCL_GLOBAL_ONLY));
		else
			return( (char *)NULL );
d2409 100
d2518 1
a2518 1
			else if( inpara > 0 && inpara < 3 )
d2561 1
a2561 1
			else if( inpara > 0 && inpara < 3 )
d2638 1
a2638 1
			fname = get_file_name();
d4146 1
d5925 1
@


11.47
log
@Added editing for VOL solid.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.46 1996/12/17 21:28:16 bparker Exp jra $ (BRL)";
d60 4
a2735 8
				/* Keyboard parameter.
				 * Apply inverse of es_mat to these
				 * model coordinates first, because sedit_mouse()
				 * has already applied es_mat to them.
				 * XXX this does not make sense.
				 */
				MAT4X3PNT( work, es_invmat, es_para );

d2890 4
d2895 1
d3972 25
a3996 4
	vect_t	pos_view;	 	/* Unrotated view space pos */
	vect_t	pos_model;		/* Rotated screen space pos */
	vect_t	tr_temp;		/* temp translation vector */
	vect_t	temp;
d3998 3
d4002 13
a4014 2
	if( es_edflag <= 0 )  return;
	switch( es_edflag )  {
d4016 5
a4020 17
	case SSCALE:
	case PSCALE:
	case ECMD_VOL_CSIZE:
	case ECMD_VOL_THRESH_LO:
	case ECMD_VOL_THRESH_HI:
		/* use mouse to get a scale factor */
		es_scale = 1.0 + 0.25 * ((fastf_t)
			(mousevec[Y] > 0 ? mousevec[Y] : -mousevec[Y]));
		if ( mousevec[Y] <= 0 )
			es_scale = 1.0 / es_scale;

		/* accumulate scale factor */
		acc_sc_sol *= es_scale;

		edit_absolute_scale = acc_sc_sol - 1.0;
		if(edit_absolute_scale > 0)
		  edit_absolute_scale /= 3.0;
d4022 15
a4036 14
		sedraw = 1;
		return;
	case STRANS:
		/* 
		 * Use mouse to change solid's location.
		 * Project solid's keypoint into view space,
		 * replace X,Y (but NOT Z) components, and
		 * project result back to model space.
		 * Then move keypoint there.
		 */
		{
			point_t	pt;
			vect_t	delta;
			mat_t	xlatemat;
d4038 3
a4040 6
			MAT4X3PNT( temp, es_mat, es_keypoint );
			MAT4X3PNT( pos_view, model2view, temp );
			pos_view[X] = mousevec[X];
			pos_view[Y] = mousevec[Y];
			MAT4X3PNT( temp, view2model, pos_view );
			MAT4X3PNT( pt, es_invmat, temp );
d4042 6
a4047 8
			/* Need vector from current vertex/keypoint
			 * to desired new location.
			 */
			VSUB2( delta, es_keypoint, pt );
			mat_idn( xlatemat );
			MAT_DELTAS_VEC_NEG( xlatemat, delta );
			transform_editing_solid(&es_int, xlatemat, &es_int, 1);
		}
d4049 10
a4058 11
	        update_edit_absolute_tran(pos_view);
		sedraw = 1;
		return;
	case ECMD_VTRANS:
		/* 
		 * Use mouse to change a vertex location.
		 * Project vertex (in solid keypoint) into view space,
		 * replace X,Y (but NOT Z) components, and
		 * project result back to model space.
		 * Leave desired location in es_mparam.
		 */
d4060 17
a4076 8
		MAT4X3PNT( temp, es_mat, es_keypoint );
		MAT4X3PNT( pos_view, model2view, temp );
		pos_view[X] = mousevec[X];
		pos_view[Y] = mousevec[Y];
		MAT4X3PNT( temp, view2model, pos_view );
		MAT4X3PNT( es_mparam, es_invmat, temp );
		es_mvalid = 1;	/* es_mparam is valid */
		/* Leave the rest to code in sedit() */
d4078 9
a4086 10
		update_edit_absolute_tran(pos_view);
		sedraw = 1;
		return;
	case ECMD_TGC_MV_H:
	case ECMD_TGC_MV_HH:
		/* Use mouse to change location of point V+H */
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)es_int.idb_ptr;
			RT_TGC_CK_MAGIC(tgc);
d4088 10
a4097 10
			VADD2( temp, tgc->v, tgc->h );
			MAT4X3PNT(pos_model, es_mat, temp);
			MAT4X3PNT( pos_view, model2view, pos_model );
			pos_view[X] = mousevec[X];
			pos_view[Y] = mousevec[Y];
			/* Do NOT change pos_view[Z] ! */
			MAT4X3PNT( temp, view2model, pos_view );
			MAT4X3PNT( tr_temp, es_invmat, temp );
			VSUB2( tgc->h, tr_temp, tgc->v );
		}
d4099 12
a4110 10
	        update_edit_absolute_tran(pos_view);
		sedraw = 1;
		return;
	case PTARB:
		/* move an arb point to indicated point */
		/* point is located at es_values[es_menu*3] */
		{
			struct rt_arb_internal *arb=
				(struct rt_arb_internal *)es_int.idb_ptr;
			RT_ARB_CK_MAGIC( arb );
d4112 7
a4118 2
			VMOVE( temp , arb->pt[es_menu] );
		}
d4120 8
a4127 7
		MAT4X3PNT(pos_model, es_mat, temp);
		MAT4X3PNT(pos_view, model2view, pos_model);
		pos_view[X] = mousevec[X];
		pos_view[Y] = mousevec[Y];
		MAT4X3PNT(temp, view2model, pos_view);
		MAT4X3PNT(pos_model, es_invmat, temp);
		editarb( pos_model );
d4129 13
a4141 13
		update_edit_absolute_tran(pos_view);
		sedraw = 1;
		return;
	case EARB:
#if 0
	  
#else
		/* move arb edge, through indicated point */
		MAT4X3PNT( temp, view2model, mousevec );
		/* apply inverse of es_mat */
		MAT4X3PNT( pos_model, es_invmat, temp );
#endif
		editarb( pos_model );
d4143 3
a4145 14
		update_edit_absolute_tran(mousevec);
		sedraw = 1;
		return;
	case ECMD_ARB_MOVE_FACE:
		/* move arb face, through  indicated  point */
		MAT4X3PNT( temp, view2model, mousevec );
		/* apply inverse of es_mat */
		MAT4X3PNT( pos_model, es_invmat, temp );
		/* change D of planar equation */
		es_peqn[es_menu][3]=VDOT(&es_peqn[es_menu][0], pos_model);
		/* calculate new vertices, put in record as vectors */
		{
			struct rt_arb_internal *arb=
				(struct rt_arb_internal *)es_int.idb_ptr;
d4147 10
a4156 3
			RT_ARB_CK_MAGIC( arb );
			(void)rt_arb_calc_points( arb , es_type , es_peqn , &mged_tol );
		}
d4158 6
a4163 11
		update_edit_absolute_tran(mousevec);
		sedraw = 1;
		return;
	case ECMD_NMG_EPICK:
		/* XXX Should just leave desired location in es_mparam for sedit() */
		{
			struct model	*m = 
				(struct model *)es_int.idb_ptr;
			struct edge	*e;
			struct rt_tol	tmp_tol;
			NMG_CK_MODEL(m);
d4165 10
a4174 15
			/* Picking an edge should not depend on tolerances! */
			tmp_tol.magic = RT_TOL_MAGIC;
			tmp_tol.dist = 0.0;
			tmp_tol.dist_sq = tmp_tol.dist * tmp_tol.dist;
			tmp_tol.perp = 0.0;
			tmp_tol.para = 1 - tmp_tol.perp;

			if( (e = nmg_find_e_nearest_pt2( &m->magic, mousevec,
			    model2view, &tmp_tol )) == (struct edge *)NULL )  {
			  Tcl_AppendResult(interp, "ECMD_NMG_EPICK: unable to find an edge\n", (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  return;
			}
			es_eu = e->eu_p;
			NMG_CK_EDGEUSE(es_eu);
d4176 2
a4177 2
			{
			  struct bu_vls tmp_vls;
d4179 9
a4187 9
			  bu_vls_init(&tmp_vls);
			  bu_vls_printf(&tmp_vls,
					"edgeuse selected=x%x (%g %g %g) <-> (%g %g %g)\n",
					es_eu, V3ARGS( es_eu->vu_p->v_p->vg_p->coord ),
					V3ARGS( es_eu->eumate_p->vu_p->v_p->vg_p->coord ) );
			  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			  mged_print_result( TCL_ERROR );
			  bu_vls_free(&tmp_vls);
			}
d4189 2
a4190 4
			update_edit_absolute_tran(mousevec);
			sedraw = 1;
		}
	        break;
d4192 17
a4208 16
	case ECMD_NMG_LEXTRU:
	case ECMD_NMG_EMOVE:
	case ECMD_NMG_ESPLIT:
	case ECMD_PIPE_PICK:
	case ECMD_PIPE_SPLIT:
	case ECMD_PIPE_PT_MOVE:
	case ECMD_PIPE_PT_ADD:
	case ECMD_PIPE_PT_INS:
	case ECMD_ARS_PICK:
	case ECMD_ARS_MOVE_PT:
	case ECMD_ARS_MOVE_CRV:
	case ECMD_ARS_MOVE_COL:
		MAT4X3PNT( temp, view2model, mousevec );
		/* apply inverse of es_mat */
		MAT4X3PNT( es_mparam, es_invmat, temp );
		es_mvalid = 1;
d4210 7
a4216 8
		update_edit_absolute_tran(mousevec);
		sedraw = 1;
		return;
	default:
	  Tcl_AppendResult(interp, "mouse press undefined in this solid edit mode\n", (char *)NULL);
	  mged_print_result( TCL_ERROR );
	  break;
	}
d4218 1
a4218 4
	/* XXX I would prefer to see an explicit call to the guts of sedit()
	 * XXX here, rather than littering the place with global variables
	 * XXX for later interpretation.
	 */
d4242 1
d4264 1
d4269 1
a4269 1
      VSUB2( delta, es_keypoint, pt );
a4389 1
  break;
d4391 1
a5766 7
#if 0
    if(SEDIT_TRAN){
      vect_t temp;
		    
      MAT4X3PNT( edit_absolute_tran, model2view, es_para );
    }
#endif
d5776 17
a5793 5

  /* XXX I would prefer to see an explicit call to the guts of sedit()
   * XXX here, rather than littering the place with global variables
   * XXX for later interpretation.
   */
@


11.46
log
@*- added code to keep sliders in sync when using mouse
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.45 1996/12/13 23:10:54 bparker Exp bparker $ (BRL)";
d40 3
d73 1
a73 1
static void	nmg_ed(), pipe_ed();
d192 5
d533 10
d660 28
d2191 3
d2291 23
d2348 159
d2530 1
d2663 1
d2795 1
d2839 1
d2959 1
d2972 1
d3007 1
d3028 1
d3047 1
d3066 1
d3115 1
d3129 1
d3147 1
d3168 1
d3203 1
d3214 1
d3232 1
d3282 1
d3290 1
d3292 2
d3313 1
d3322 1
d3344 1
d3353 1
d3375 1
d3399 1
d3413 1
d3450 1
d3467 1
d3492 1
d3518 1
d3544 1
d3570 1
d3812 1
d3863 1
d3913 1
d3929 1
d3982 3
d4149 1
d4164 1
d4195 1
d4680 6
d5748 1
@


11.45
log
@weekend checkin
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.44 1996/12/12 22:10:09 bparker Exp bparker $ (BRL)";
d79 1
a79 1
void sedit_absolute_tran_update();
a1793 16
#if 0
  update_views = 1;

  if(EDIT_TRAN) {
    VMOVE(e_axes_pos, es_keypoint);
    MAT4X3PNT( absolute_slew, model2view, es_keypoint );
  }else{
    point_t new_pos;

    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, new_pos);

    if(EDIT_ROTATE)
      VSETALL( absolute_rotate, 0.0 );
  }
#else
d1871 4
d1876 1
a1890 1
#endif
d3757 1
a3757 1
	        sedit_absolute_tran_update(mousevec);
d3778 1
a3778 1
		sedit_absolute_tran_update(mousevec);
d3800 1
a3800 1
	        sedit_absolute_tran_update(mousevec);
d3822 1
a3822 1
		sedit_absolute_tran_update(mousevec);
d3826 3
d3833 1
d3836 1
a3836 1
		sedit_absolute_tran_update(mousevec);
d3855 1
a3855 1
		sedit_absolute_tran_update(mousevec);
d3894 1
a3894 1
			sedit_absolute_tran_update(mousevec);
d3916 1
a3916 1
		sedit_absolute_tran_update(mousevec);
d3931 2
a3932 2
sedit_absolute_tran_update(mousevec)
vect_t mousevec;
a3933 1
  vect_t pos_view;
d3938 1
a3938 3
  MAT4X3PNT( pos_view, model2view, es_keypoint);
  mousevec[Z] = pos_view[Z];
  MAT4X3PNT(model_pos, view2model, mousevec);
d4158 27
a4184 5
	fastf_t			scale;
	vect_t	pos_view;	 	/* Unrotated view space pos */
	vect_t	pos_model;	/* Rotated screen space pos */
	vect_t	tr_temp;		/* temp translation vector */
	vect_t	temp;
d4186 9
a4194 8
	mat_idn( incr_change );
	scale = 1;
	if( movedir & SARROW )  {
		/* scaling option is in effect */
		scale = 1.0 + (fastf_t)(mousevec[Y]>0 ?
			mousevec[Y] : -mousevec[Y]);
		if ( mousevec[Y] <= 0 )
			scale = 1.0 / scale;
d4196 20
a4215 2
		/* switch depending on scaling option selected */
		switch( edobj ) {
d4217 36
a4252 57
			case BE_O_SCALE:
				/* global scaling */
				incr_change[15] = 1.0 / scale;
			break;

			case BE_O_XSCALE:
				/* local scaling ... X-axis */
				incr_change[0] = scale;
				/* accumulate the scale factor */
				acc_sc[0] *= scale;
			break;

			case BE_O_YSCALE:
				/* local scaling ... Y-axis */
				incr_change[5] = scale;
				/* accumulate the scale factor */
				acc_sc[1] *= scale;
			break;

			case BE_O_ZSCALE:
				/* local scaling ... Z-axis */
				incr_change[10] = scale;
				/* accumulate the scale factor */
				acc_sc[2] *= scale;
			break;
		}

		/* Have scaling take place with respect to keypoint,
		 * NOT the view center.
		 */
		MAT4X3PNT(temp, es_mat, es_keypoint);
		MAT4X3PNT(pos_model, modelchanges, temp);
		wrt_point(modelchanges, incr_change, modelchanges, pos_model);
	}  else if( movedir & (RARROW|UARROW) )  {
		mat_t oldchanges;	/* temporary matrix */

		/* Vector from object keypoint to cursor */
		MAT4X3PNT( temp, es_mat, es_keypoint );
		MAT4X3PNT( pos_view, model2objview, temp );
		if( movedir & RARROW )
			pos_view[X] = mousevec[X];
		if( movedir & UARROW )
			pos_view[Y] = mousevec[Y];

		MAT4X3PNT( pos_model, view2model, pos_view );/* NOT objview */
		MAT4X3PNT( tr_temp, modelchanges, temp );
		VSUB2( tr_temp, pos_model, tr_temp );
		MAT_DELTAS(incr_change,
			tr_temp[X], tr_temp[Y], tr_temp[Z]);
		mat_copy( oldchanges, modelchanges );
		mat_mul( modelchanges, incr_change, oldchanges );
	}  else  {
	  Tcl_AppendResult(interp, "No object edit mode selected;  mouse press ignored\n", (char *)NULL);
	  return;
	}
	mat_idn( incr_change );
	new_mats();
a4259 1
  vect_t  pos_view;
d4302 1
a4302 1
    incr_mat[15] = scale / acc_sc_obj;
@


11.44
log
@start of cleanup
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.43 1996/12/11 22:40:57 bparker Exp bparker $ (BRL)";
d57 1
d60 5
a64 2
extern void set_e_axes_pos();

d79 3
a81 1

d114 1
a114 1
extern int	inpara;		/* es_para valid.  es_mvalid must = 0 */
d1788 130
d3767 1
d3769 1
a3769 17
			{
/*XXXXX  More experimentation */
			  extern point_t e_axes_pos;
			  vect_t model_pos;
			  vect_t diff;
			  fastf_t inv_Viewscale = 1/Viewscale;

			  MAT4X3PNT( pos_view, model2view, es_keypoint);
			  mousevec[Z] = pos_view[Z];
			  MAT4X3PNT(model_pos, view2model, mousevec);
			  VSUB2(diff, model_pos, e_axes_pos);
			  VSCALE(edit_absolute_tran, diff, inv_Viewscale);

			  if(BU_LIST_NON_EMPTY(&head_cmd_list.l))
			    (void)Tcl_Eval(interp, "set_sliders");
			}
		}
d3789 2
d3811 2
d3833 2
d3843 2
d3862 2
d3902 1
d3923 2
a3937 3
/*
 *  Object Edit
 */
d3939 2
a3940 2
objedit_mouse( mousevec )
CONST vect_t	mousevec;
d3942 13
a3954 75
	fastf_t			scale;
	vect_t	pos_view;	 	/* Unrotated view space pos */
	vect_t	pos_model;	/* Rotated screen space pos */
	vect_t	tr_temp;		/* temp translation vector */
	vect_t	temp;

	mat_idn( incr_change );
	scale = 1;
	if( movedir & SARROW )  {
		/* scaling option is in effect */
		scale = 1.0 + (fastf_t)(mousevec[Y]>0 ?
			mousevec[Y] : -mousevec[Y]);
		if ( mousevec[Y] <= 0 )
			scale = 1.0 / scale;

		/* switch depending on scaling option selected */
		switch( edobj ) {

			case BE_O_SCALE:
				/* global scaling */
				incr_change[15] = 1.0 / scale;
			break;

			case BE_O_XSCALE:
				/* local scaling ... X-axis */
				incr_change[0] = scale;
				/* accumulate the scale factor */
				acc_sc[0] *= scale;
			break;

			case BE_O_YSCALE:
				/* local scaling ... Y-axis */
				incr_change[5] = scale;
				/* accumulate the scale factor */
				acc_sc[1] *= scale;
			break;

			case BE_O_ZSCALE:
				/* local scaling ... Z-axis */
				incr_change[10] = scale;
				/* accumulate the scale factor */
				acc_sc[2] *= scale;
			break;
		}

		/* Have scaling take place with respect to keypoint,
		 * NOT the view center.
		 */
		MAT4X3PNT(temp, es_mat, es_keypoint);
		MAT4X3PNT(pos_model, modelchanges, temp);
		wrt_point(modelchanges, incr_change, modelchanges, pos_model);
	}  else if( movedir & (RARROW|UARROW) )  {
		mat_t oldchanges;	/* temporary matrix */

		/* Vector from object keypoint to cursor */
		MAT4X3PNT( temp, es_mat, es_keypoint );
		MAT4X3PNT( pos_view, model2objview, temp );
		if( movedir & RARROW )
			pos_view[X] = mousevec[X];
		if( movedir & UARROW )
			pos_view[Y] = mousevec[Y];

		MAT4X3PNT( pos_model, view2model, pos_view );/* NOT objview */
		MAT4X3PNT( tr_temp, modelchanges, temp );
		VSUB2( tr_temp, pos_model, tr_temp );
		MAT_DELTAS(incr_change,
			tr_temp[X], tr_temp[Y], tr_temp[Z]);
		mat_copy( oldchanges, modelchanges );
		mat_mul( modelchanges, incr_change, oldchanges );
	}  else  {
	  Tcl_AppendResult(interp, "No object edit mode selected;  mouse press ignored\n", (char *)NULL);
	  return;
	}
	mat_idn( incr_change );
	new_mats();
a3956 1

d4140 1
a4140 1
sedit_scale()
d4163 169
a5383 2
/* Input parameter editing changes from keyboard */
/* Format: p dx [dy dz]		*/
d5385 1
a5385 2
f_param(clientData, interp, argc, argv)
ClientData clientData;
d5387 2
a5388 2
int	argc;
char	**argv;
d5390 1
a5390 1
	register int i;
d5392 6
a5397 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d5399 8
a5406 10
	if( es_edflag <= 0 )  {
	  Tcl_AppendResult(interp, "A solid editor option not selected\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( es_edflag == ECMD_TGC_ROT_H
		|| es_edflag == ECMD_TGC_ROT_AB
		|| es_edflag == ECMD_ETO_ROT_C ) {
	  Tcl_AppendResult(interp, "\"p\" command not defined for this option\n", (char *)NULL);
	  return TCL_ERROR;
	}
d5408 5
a5412 5
	inpara = 0;
	sedraw++;
	for( i = 1; i < argc && i <= 3 ; i++ )  {
		es_para[ inpara++ ] = atof( argv[i] );
	}
d5414 18
a5431 20
	if( es_edflag == PSCALE || es_edflag == SSCALE )  {
		if( es_menu == MENU_PIPE_PT_OD || es_menu == MENU_PIPE_PT_ID || MENU_PIPE_SCALE_ID )
		{
			if( es_para[0] < 0.0 )
			{
			   Tcl_AppendResult(interp, "ERROR: SCALE FACTOR < 0\n", (char *)NULL);
			   inpara = 0;
			   sedraw = 0;
			   return TCL_ERROR;
			}
		}
		else
		{
			if(es_para[0] <= 0.0) {
			  Tcl_AppendResult(interp, "ERROR: SCALE FACTOR <= 0\n", (char *)NULL);
			  inpara = 0;
			  sedraw = 0;
			  return TCL_ERROR;
			}
		}
d5433 2
d5436 2
a5437 2
	/* check if need to convert input values to the base unit */
	switch( es_edflag ) {
d5439 20
a5458 20
		case STRANS:
		case ECMD_VTRANS:
		case PSCALE:
		case EARB:
		case ECMD_ARB_MOVE_FACE:
		case ECMD_TGC_MV_H:
		case ECMD_TGC_MV_HH:
		case PTARB:
		case ECMD_NMG_ESPLIT:
		case ECMD_NMG_EMOVE:
		case ECMD_NMG_LEXTRU:
		case ECMD_PIPE_PICK:
		case ECMD_PIPE_SPLIT:
		case ECMD_PIPE_PT_MOVE:
		case ECMD_PIPE_PT_ADD:
		case ECMD_PIPE_PT_INS:
		case ECMD_ARS_PICK:
		case ECMD_ARS_MOVE_PT:
		case ECMD_ARS_MOVE_CRV:
		case ECMD_ARS_MOVE_COL:
d5460 2
a5461 2
		  if(SEDIT_TRAN){
		    vect_t temp;
d5463 2
a5464 2
		    MAT4X3PNT( edit_absolute_tran, model2view, es_para );
		  }
d5466 31
a5496 8
			/* must convert to base units */
			es_para[0] *= local2base;
			es_para[1] *= local2base;
			es_para[2] *= local2base;
			/* fall through */
		default:
			break;
	}
d5498 3
a5500 1
	return TCL_OK;
d5502 1
a5502 4
	/* XXX I would prefer to see an explicit call to the guts of sedit()
	 * XXX here, rather than littering the place with global variables
	 * XXX for later interpretation.
	 */
@


11.43
log
@experimenting
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.42 1996/12/10 21:45:18 bparker Exp bparker $ (BRL)";
d3598 4
d4074 13
a4086 8
#if 0
	case SSCALE:
	case PSCALE:
		/* use mouse to get a scale factor */
		es_scale = 1.0 + 0.25 * ((fastf_t)
			(mousevec[Y] > 0 ? mousevec[Y] : -mousevec[Y]));
		if ( mousevec[Y] <= 0 )
			es_scale = 1.0 / es_scale;
d4088 1
a4088 2
		/* accumulate scale factor */
		acc_sc_sol *= es_scale;
d4090 1
a4090 3
		sedraw = 1;
		return;
#endif
@


11.42
log
@experimentation
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.41 1996/12/09 23:01:26 bparker Exp bparker $ (BRL)";
a2253 1
		mat_idn( acc_rot_sol );
d3612 1
a3612 1
#if 0
a3617 4
#else
			/* Experimental */
			MAT4X3PNT( temp, view2model, mousevec );
#endif
d3627 17
d3655 1
a3655 1
#if 0
a3660 4
#else
		/* Experimental */
		MAT4X3PNT( temp, view2model, mousevec );
#endif
a3673 1
#if 0
a3680 4
#else
			/* Experimental */
			MAT4X3PNT( temp, view2model, mousevec );
#endif
d3696 1
a3696 1
#if 0
a3701 4
#else
		/* Experimental */
		MAT4X3PNT( temp, view2model, mousevec );
#endif
d3883 204
@


11.41
log
@mods to allow any kind of view manipulation at any time --- not quite done yet
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.40 1996/11/19 20:31:16 jra Exp bparker $ (BRL)";
d3613 1
a3613 1

d3619 4
d3643 1
d3649 4
d3666 1
d3674 4
d3693 1
d3699 4
d5014 1
a5014 1
#if 1
@


11.40
log
@Mod to make adding a pipe segment advance es_pipet to new point.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.39 1996/11/19 19:09:10 bparker Exp jra $ (BRL)";
a60 2
void set_tran();

d4999 1
a4999 1
		    MAT4X3PNT( absolute_slew, model2view, es_para );
a5010 10
#if 0
	if(es_edflag >= SROT && es_edflag <= ECMD_ETO_ROT_C){
	  VMOVE(absolute_rotate, es_para);
	}else

	if(es_edflag >= STRANS && es_edflag <= PTARB){
	  if(!tran_set)
	    set_tran(es_para[0], es_para[1], es_para[2]);
	}
#endif
@


11.39
log
@reinitialize acc_rot_sol
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.38 1996/11/01 22:17:37 bparker Exp bparker $ (BRL)";
d88 1
d3003 1
a3003 1
			add_pipept( pipe, es_pipept, new_pt );
@


11.38
log
@call sedit within sedit_accept and
sedit_reject to update things in case these guys
are called within a Tcl script.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.37 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
d1937 1
d1946 3
a1948 1

a1964 12
#if 0
/*
 * this is the old way.  rt_db_xform_internal was transfered and
 * modified into rt_generic_xform() in librt/table.c
 * rt_generic_xform is normally called via rt_functab[id].ft_xform()
 */
	struct directory	*dp;

	dp = illump->s_path[illump->s_last];
	if( rt_db_xform_internal( os, mat, is, free, dp->d_namep ) < 0 )
		bu_bomb("transform_editing_solid");		/* FAIL */
#endif
d4760 1
d4773 2
@


11.37
log
@hacks to use latest libdm
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.36 1996/10/09 16:59:31 bparker Exp bparker $ (BRL)";
d4850 3
d4896 3
@


11.36
log
@changed variable name "poly" to "_poly"
--- conflicts with macro named poly in compat4.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.35 1996/10/04 15:03:03 bparker Exp bparker $ (BRL)";
d1914 5
a1918 3
	dmp->dmr_light( dmp, LIGHT_ON, BE_ACCEPT );
	dmp->dmr_light( dmp, LIGHT_ON, BE_REJECT );
	dmp->dmr_light( dmp, LIGHT_OFF, BE_S_ILLUMINATE );
@


11.35
log
@cast bu_free's 1st argument to genptr_t
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.34 1996/09/25 20:16:42 bparker Exp bparker $ (BRL)";
d1645 1
a1645 1
			struct rt_pg_face_internal *poly;
d1650 2
a1651 2
			poly = pg->poly;
			VMOVE( mpt , poly->verts );
@


11.34
log
@now using more generalized solid macros
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.33 1996/09/23 18:28:35 bparker Exp bparker $ (BRL)";
d1043 1
a1043 1
				bu_free( (char *)tab, "nmg_ed tab[]" );
d3229 2
a3230 2
				bu_free( (char *)ars->curves[i], "ars->curves[i]" );
			bu_free( (char *)ars->curves, "ars->curves" );
d3274 2
a3275 2
				bu_free( (char *)ars->curves[i], "ars->curves[i]" );
			bu_free( (char *)ars->curves, "ars->curves" );
d3323 2
a3324 2
				bu_free( (char *)ars->curves[i], "ars->curves[i]" );
			bu_free( (char *)ars->curves, "ars->curves" );
d3384 2
a3385 2
				bu_free( (char *)ars->curves[i], "ars->curves[i]" );
			bu_free( (char *)ars->curves, "ars->curves" );
@


11.33
log
@ use LIBDM permanently
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.32 1996/09/17 21:18:06 bparker Exp bparker $ (BRL)";
d52 1
a52 1
#include "./solid.h"
d4760 1
a4760 1
	FOR_ALL_SOLIDS( sp )  {
@


11.32
log
@prepare to use libdm
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.31 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d54 1
a54 1
#include "./dm.h"
a1913 1
#ifdef USE_LIBDM
a1916 5
#else
	dmp->dmr_light( LIGHT_ON, BE_ACCEPT );
	dmp->dmr_light( LIGHT_ON, BE_REJECT );
	dmp->dmr_light( LIGHT_OFF, BE_S_ILLUMINATE );
#endif
@


11.31
log
@rt_list ---> bu_list
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.30 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d1914 5
d1922 1
@


11.30
log
@now using libbu
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.29 1996/08/21 19:42:46 jra Exp bparker $ (BRL)";
d42 1
d85 2
a86 2
MGED_EXTERN( struct wdb_pipept *find_pipept_nearest_pt, (CONST struct rt_list *pipe_hd, CONST point_t pt ) );
MGED_EXTERN( void split_pipept, (struct rt_list *pipe_hd, struct wdb_pipept *ps, point_t pt ) );
d655 2
a656 2
			next = RT_LIST_NEXT( wdb_pipept, &es_pipept->l );
			if( next->l.magic == RT_LIST_HEAD_MAGIC )
d673 2
a674 2
			prev = RT_LIST_PREV( wdb_pipept, &es_pipept->l );
			if( prev->l.magic == RT_LIST_HEAD_MAGIC )
d1058 1
a1058 1
		es_eu = RT_LIST_PNEXT_CIRC(edgeuse, es_eu);
d1079 1
a1079 1
		es_eu = RT_LIST_PPREV_CIRC(edgeuse, es_eu);
d1130 1
a1130 1
			for( RT_LIST_FOR( r , nmgregion , &m->r_hd ) )
d1133 1
a1133 1
				for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d1135 1
a1135 1
					if( RT_LIST_IS_EMPTY( &s->lu_hd ) )
d1138 1
a1138 1
					for( RT_LIST_FOR( lu_tmp , loopuse , &s->lu_hd ) )
d1180 1
a1180 1
			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d1192 1
a1192 1
				for( eu2 = RT_LIST_PNEXT( edgeuse , &eu->l ) ; RT_LIST_NOT_HEAD( eu2 , &lu->down_hd ) ; eu2=RT_LIST_PNEXT( edgeuse, &eu2->l) )
d1203 1
a1203 1
					if( eu2 == RT_LIST_PNEXT_CIRC( edgeuse,  &eu->l ) )
d1205 1
a1205 1
					if( eu2 == RT_LIST_PPREV_CIRC( edgeuse, &eu->l ) )
d1250 1
a1250 1
			s_tmp = RT_LIST_FIRST( shell , &r_tmp->s_hd );
d1260 1
a1260 1
			eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
d1265 1
a1265 1
			if( RT_LIST_NON_EMPTY( &s->fu_hd ) )
d1269 1
a1269 1
				r = RT_LIST_FIRST( nmgregion , &m->r_hd );
d1342 1
a1342 1
			pipe_seg = RT_LIST_FIRST( wdb_pipept , &pipe->pipe_segs_head );
d1673 1
a1673 1
			if( RT_LIST_IS_EMPTY( &m->r_hd ) )
d1676 1
a1676 1
			r = RT_LIST_FIRST( nmgregion , &m->r_hd );
d1681 1
a1681 1
			if( RT_LIST_IS_EMPTY( &r->s_hd ) )
d1684 1
a1684 1
			s = RT_LIST_FIRST( shell , &r->s_hd );
d1689 1
a1689 1
			if( RT_LIST_IS_EMPTY( &s->fu_hd ) )
d1692 1
a1692 1
				fu = RT_LIST_FIRST( faceuse , &s->fu_hd );
d1696 1
a1696 1
				lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
d1698 1
a1698 1
				if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC )
d1700 1
a1700 1
					eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
d1707 1
a1707 1
					vu = RT_LIST_FIRST( vertexuse , &lu->down_hd );
d1718 1
a1718 1
			if( RT_LIST_IS_EMPTY( &s->lu_hd ) )
d1721 1
a1721 1
				lu = RT_LIST_FIRST( loopuse , &s->lu_hd );
d1725 1
a1725 1
				if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC )
d1727 1
a1727 1
					eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
d1734 1
a1734 1
					vu = RT_LIST_FIRST( vertexuse , &lu->down_hd );
d1745 1
a1745 1
			if( RT_LIST_IS_EMPTY( &s->eu_hd ) )
d1748 1
a1748 1
				eu = RT_LIST_FIRST( edgeuse , &s->eu_hd );
d2697 1
a2697 1
				prev_eu = RT_LIST_PPREV_CIRC( edgeuse , &es_eu->l );
d2718 1
a2718 1
				next_eu = RT_LIST_PNEXT_CIRC( edgeuse , &es_eu->l );
d2856 1
a2856 1
			if( RT_LIST_NON_EMPTY( &es_s->fu_hd ) )
d3914 1
a3914 1
		for( RT_LIST_FOR( ps, wdb_pipept, &pipe->pipe_segs_head ) )
d4555 1
a4555 1
			ps = RT_LIST_FIRST( wdb_pipept, &pipe->pipe_segs_head );
d4562 2
a4563 2
				while( ps->l.magic != RT_LIST_HEAD_MAGIC && ps->pp_od <= 0.0 )
					ps = RT_LIST_NEXT( wdb_pipept, &ps->l );
d4565 1
a4565 1
				if( ps->l.magic == RT_LIST_HEAD_MAGIC )
d4585 1
a4585 1
			ps = RT_LIST_FIRST( wdb_pipept, &pipe->pipe_segs_head );
d4592 2
a4593 2
				while( ps->l.magic != RT_LIST_HEAD_MAGIC && ps->pp_id <= 0.0 )
					ps = RT_LIST_NEXT( wdb_pipept, &ps->l );
d4596 1
a4596 1
				if( ps->l.magic == RT_LIST_HEAD_MAGIC )
d4613 1
a4613 1
			ps = RT_LIST_FIRST( wdb_pipept, &pipe->pipe_segs_head );
d4620 2
a4621 2
				while( ps->l.magic != RT_LIST_HEAD_MAGIC && ps->pp_bendradius <= 0.0 )
					ps = RT_LIST_NEXT( wdb_pipept, &ps->l );
d4624 1
a4624 1
				if( ps->l.magic == RT_LIST_HEAD_MAGIC )
d5583 1
a5583 1
struct rt_list	*vhead;
d5590 1
a5590 1
	if (vhead == RT_LIST_NULL || RT_LIST_IS_EMPTY(vhead))
d5594 1
a5594 1
	cur_vp = RT_LIST_FIRST(rt_vlist, vhead);
d5598 1
a5598 1
	for (RT_LIST_FOR(cur_vp, rt_vlist, vhead)) {
d5626 1
a5626 1
struct rt_list	*vhead;
d5635 1
a5635 1
	if (vhead == RT_LIST_NULL || RT_LIST_IS_EMPTY(vhead))
d5642 1
a5642 1
	cur_vp = RT_LIST_FIRST(rt_vlist, vhead);
d5647 1
a5647 1
	for (RT_LIST_FOR(cur_vp, rt_vlist, vhead)) {
@


11.29
log
@Added capability to extrude NMG loop through a simple distance.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.28 1996/08/21 19:33:41 bparker Exp jra $ (BRL)";
d1034 1
a1034 1
				tab = (long *)rt_calloc( m->maxindex+1, sizeof(long),
d1042 1
a1042 1
				rt_free( (char *)tab, "nmg_ed tab[]" );
d1060 1
a1060 1
		  struct rt_vls tmp_vls;
d1062 2
a1063 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "edgeuse selected=x%x (%g %g %g) <-> (%g %g %g)\n",
d1066 2
a1067 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d1074 1
a1074 1
			rt_log("nmg_ed: no edge selected yet\n");
d1081 1
a1081 1
		  struct rt_vls tmp_vls;
d1083 2
a1084 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "edgeuse selected=x%x (%g %g %g) <-> (%g %g %g)\n",
d1087 2
a1088 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d1095 1
a1095 1
			rt_log("nmg_ed: no edge selected yet\n");
d1102 1
a1102 1
		  struct rt_vls tmp_vls;
d1104 2
a1105 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "edgeuse selected=x%x (%g %g %g) <-> (%g %g %g)\n",
d1108 2
a1109 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d1165 1
a1165 1
				rt_bomb( "Cannot find wire loop!!\n" );
d1214 1
a1214 1
					  struct rt_vls tmp_vls;
d1216 2
a1217 2
					  rt_vls_init(&tmp_vls);
					  rt_vls_printf(&tmp_vls,
d1219 1
a1219 1
					  rt_vls_printf(&tmp_vls,
d1222 1
a1222 1
					  rt_vls_printf(&tmp_vls,
d1226 1
a1226 1
					    rt_vls_printf(&tmp_vls,
d1233 1
a1233 1
					      rt_vls_printf(&tmp_vls,
d1238 1
a1238 1
					  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls),
d1240 1
a1240 1
					  rt_vls_free(&tmp_vls);
d1809 1
a1809 1
		  struct rt_vls tmp_vls;
d1811 2
a1812 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "No eqn for face %d%d%d%d\n",
d1814 2
a1815 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d1958 1
a1958 1
		rt_bomb("transform_editing_solid");
d1969 1
a1969 1
		rt_bomb("transform_editing_solid");		/* FAIL */
d2078 2
a2079 2
  struct rt_vls str;
  struct rt_vls cmd;
d2085 2
a2086 2
  rt_vls_init(&str);
  rt_vls_init(&cmd);
d2088 1
a2088 1
  rt_vls_printf(&str, "Enter fixed vertex number( ");
d2091 1
a2091 1
      rt_vls_printf(&str, "%d ", arb_vertices[type][loc+i]);
d2093 1
a2093 1
  rt_vls_printf(&str, ") [%d]: ",arb_vertices[type][loc]);
d2095 2
a2096 2
  rt_vls_printf(&cmd, "mged_input_dialog .get_vertex %s {Need vertex for solid rotate}\
 {%s} vertex_num %d 0 OK", dname, rt_vls_addr(&str), arb_vertices[type][loc]);
d2099 1
a2099 1
    if(Tcl_Eval(interp, rt_vls_addr(&cmd)) != TCL_OK){
d2112 1
a2112 1
  rt_vls_free(&str);
d2228 1
a2228 1
				rt_log("\nEnter fixed vertex number( ");
d2232 1
a2232 1
						rt_log("%d ",
d2235 1
a2235 1
				rt_log(") [%d]: ",arb_vertices[type][loc]);
d2724 1
a2724 1
					rt_bomb( "sedit(): killed edge and emptied loop!!\n" );
d3063 1
a3063 1
			struct rt_vls tmp_vls;
d3086 1
a3086 1
			rt_log( "Selected point #%d from curve #%d (%f %f %f)\n",
d3088 4
a3091 4
			rt_vls_init( &tmp_vls );
			rt_vls_printf( &tmp_vls, "Selected point #%d from curve #%d ( %f %f %f )\n", es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
			Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL );
			rt_vls_free( &tmp_vls );
d3098 1
a3098 1
			struct rt_vls tmp_vls;
d3110 1
a3110 1
				rt_log( "Selected point #%d from curve #%d (%f %f %f)\n",
d3112 4
a3115 4
				rt_vls_init( &tmp_vls );
				rt_vls_printf( &tmp_vls, "Selected point #%d from curve #%d ( %f %f %f )\n", es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
				Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL );
				rt_vls_free( &tmp_vls );
d3123 1
a3123 1
			struct rt_vls tmp_vls;
d3135 1
a3135 1
				rt_log( "Selected point #%d from curve #%d (%f %f %f)\n",
d3137 4
a3140 4
				rt_vls_init( &tmp_vls );
				rt_vls_printf( &tmp_vls, "Selected point #%d from curve #%d ( %f %f %f )\n", es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
				Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL );
				rt_vls_free( &tmp_vls );
d3148 1
a3148 1
			struct rt_vls tmp_vls;
d3160 1
a3160 1
				rt_log( "Selected point #%d from curve #%d (%f %f %f)\n",
d3162 4
a3165 4
				rt_vls_init( &tmp_vls );
				rt_vls_printf( &tmp_vls, "Selected point #%d from curve #%d ( %f %f %f )\n", es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
				Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL );
				rt_vls_free( &tmp_vls );
d3173 1
a3173 1
			struct rt_vls tmp_vls;
d3185 1
a3185 1
				rt_log( "Selected point #%d from curve #%d (%f %f %f)\n",
d3187 4
a3190 4
				rt_vls_init( &tmp_vls );
				rt_vls_printf( &tmp_vls, "Selected point #%d from curve #%d ( %f %f %f )\n", es_ars_col, es_ars_crv, V3ARGS( selected_pt ) );
				Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL );
				rt_vls_free( &tmp_vls );
d3204 1
a3204 1
				rt_log( "No ARS point selected\n" );
d3208 1
a3208 1
			curves = (fastf_t **)rt_malloc( (ars->ncurves+1) * sizeof( fastf_t * ),
d3215 1
a3215 1
				curves[i] = (fastf_t *)rt_malloc( ars->pts_per_curve * 3 * sizeof( fastf_t ),
d3228 2
a3229 2
				rt_free( (char *)ars->curves[i], "ars->curves[i]" );
			rt_free( (char *)ars->curves, "ars->curves" );
d3245 1
a3245 1
				rt_log( "No ARS point selected\n" );
d3249 1
a3249 1
			curves = (fastf_t **)rt_malloc( ars->ncurves * sizeof( fastf_t * ),
d3256 1
a3256 1
				curves[i] = (fastf_t *)rt_malloc( (ars->pts_per_curve + 1) * 3 * sizeof( fastf_t ),
d3273 2
a3274 2
				rt_free( (char *)ars->curves[i], "ars->curves[i]" );
			rt_free( (char *)ars->curves, "ars->curves" );
d3291 1
a3291 1
				rt_log( "No ARS point selected\n" );
d3297 1
a3297 1
				rt_log( "Cannot delete first or last curve\n" );
d3301 1
a3301 1
			curves = (fastf_t **)rt_malloc( (ars->ncurves - 1) * sizeof( fastf_t * ),
d3312 1
a3312 1
				curves[k] = (fastf_t *)rt_malloc( ars->pts_per_curve * 3 * sizeof( fastf_t ),
d3322 2
a3323 2
				rt_free( (char *)ars->curves[i], "ars->curves[i]" );
			rt_free( (char *)ars->curves, "ars->curves" );
d3342 1
a3342 1
				rt_log( "No ARS point selected\n" );
d3348 1
a3348 1
				rt_log( "Cannot delete first or last column\n" );
d3354 1
a3354 1
				rt_log( "Cannot create an ARS with less than two points per curve\n" );
d3358 1
a3358 1
			curves = (fastf_t **)rt_malloc( ars->ncurves * sizeof( fastf_t * ),
d3366 1
a3366 1
				curves[i] = (fastf_t *)rt_malloc( (ars->pts_per_curve - 1) * 3 * sizeof( fastf_t ),
d3383 2
a3384 2
				rt_free( (char *)ars->curves[i], "ars->curves[i]" );
			rt_free( (char *)ars->curves, "ars->curves" );
d3404 1
a3404 1
				rt_log( "No ARS point selected\n" );
d3454 1
a3454 1
				rt_log( "No ARS point selected\n" );
d3503 1
a3503 1
				rt_log( "No ARS point selected\n" );
d3540 1
a3540 1
	    struct rt_vls tmp_vls;
d3542 4
a3545 4
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "sedit():  unknown edflag = %d.\n", es_edflag );
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d3745 1
a3745 1
			  struct rt_vls tmp_vls;
d3747 2
a3748 2
			  rt_vls_init(&tmp_vls);
			  rt_vls_printf(&tmp_vls,
d3752 2
a3753 2
			  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
			  rt_vls_free(&tmp_vls);
d3878 1
a3878 1
register struct rt_vls		*vp;
d3885 1
a3885 1
	RT_VLS_CHECK(vp);
d4555 1
a4555 1
			RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "wdb_pipept" );
d4585 1
a4585 1
			RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "wdb_pipept" );
d4613 1
a4613 1
			RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "wdb_pipept" );
d5486 1
a5486 1
				RT_CKMAG( es_pipept, WDB_PIPESEG_MAGIC, "wdb_pipept" );
d5531 1
a5531 1
		  struct rt_vls tmp_vls;
d5533 2
a5534 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "rt_arb_calc_planes: No eqn for face %d%d%d%d\n",
d5536 1
a5536 1
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
d5811 1
a5811 1
      struct rt_vls tmp_vls;
d5813 4
a5816 4
      rt_vls_init(&tmp_vls);
      rt_vls_printf(&tmp_vls, "%s (%g, %g, %g)\n", es_keytag, V3ARGS(es_keypoint));
      Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
      rt_vls_free(&tmp_vls);
@


11.28
log
@removed backslashes.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.27 1996/08/21 14:18:29 jra Exp bparker $ (BRL)";
d2837 2
@


11.27
log
@Minor mods for IRIX 6.2.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.26 1996/07/30 21:32:37 bparker Exp jra $ (BRL)";
d2095 2
a2096 2
  rt_vls_printf(&cmd, "mged_input_dialog .get_vertex %s \{Need vertex for solid rotate\}\
 \{%s\} vertex_num %d 0 OK", dname, rt_vls_addr(&str), arb_vertices[type][loc]);
@


11.26
log
@*** empty log message ***
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.25 1996/07/09 21:37:03 jra Exp bparker $ (BRL)";
d5085 1
@


11.25
log
@Added ARS editing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.24 1996/07/03 13:57:30 jra Exp jra $ (BRL)";
d58 1
a58 1
extern void set_e_axis_pos();
d556 1
a556 1
	set_e_axis_pos();
d575 1
a575 1
	set_e_axis_pos();
d599 1
a599 1
	set_e_axis_pos();
d618 1
a618 1
	set_e_axis_pos();
d632 1
a632 1
	set_e_axis_pos();
d729 1
a729 1
	set_e_axis_pos();
d747 1
a747 1
	set_e_axis_pos();
d758 1
a758 1
	set_e_axis_pos();
d771 1
a771 1
	set_e_axis_pos();
d781 1
a781 1
	set_e_axis_pos();
d791 1
a791 1
	set_e_axis_pos();
d801 1
a801 1
	set_e_axis_pos();
d811 1
a811 1
	set_e_axis_pos();
d821 1
a821 1
	set_e_axis_pos();
d835 1
a835 1
	set_e_axis_pos();
d849 1
a849 1
	set_e_axis_pos();
d863 1
a863 1
	set_e_axis_pos();
d877 1
a877 1
	set_e_axis_pos();
d891 1
a891 1
	set_e_axis_pos();
d993 1
a993 1
	set_e_axis_pos();
d2263 1
a2263 1
		set_e_axis_pos();
d4696 1
a4696 1
	set_e_axis_pos();
@


11.24
log
@Changed made by Bparker.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.23 1996/05/24 18:34:21 bparker Exp bparker $ (BRL)";
d116 4
d186 23
a327 6
struct menu_item  ars_menu[] = {
	{ "ARS MENU", (void (*)())NULL, 0 },
	{ "not implemented", ars_ed, 1 },
	{ "", (void (*)())NULL, 0 }
};

d973 2
a974 1
  Tcl_AppendResult(interp,"NOT IMPLEMENTED YET\n", (char *)NULL);
d1907 2
d3042 494
d3766 4
d3889 12
a3900 3
	if( rt_functab[id].ft_describe( vp, &intern, 1 /*verbose*/,
	    base2local ) < 0 )
	  Tcl_AppendResult(interp, "vls_solid: describe error\n", (char *)NULL);
d3921 1
d4891 3
d4987 4
d5413 10
@


11.23
log
@*** empty log message ***
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.22 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d108 1
a108 1
extern int	inpara;		/* es_para valid.  es_mvalid mus = 0 */
a3199 1

d3238 1
a3238 1
		break;
a3253 1

d4452 7
d4468 6
a4473 1
        if(es_edflag >= STRANS && es_edflag <= PTARB){
d4477 1
a4477 1

d4497 2
a4498 6
	if( es_edflag != ECMD_TGC_ROT_H &&
	    es_edflag != ECMD_TGC_ROT_AB &&
	    es_edflag != SROT &&
	    es_edflag != ECMD_ETO_ROT_C &&
	    es_edflag != ECMD_ARB_ROTATE_FACE)
		return 0;
@


11.22
log
@still tcl-converting
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.21 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d4463 1
a4463 7
	if(es_edflag >= SROT && es_edflag <= ECMD_ETO_ROT_C){
	  if(!rot_set){
	    rot_x = es_para[0];
	    rot_y = es_para[1];
	    rot_z = es_para[2];
	  }
	}else if(es_edflag >= STRANS && es_edflag <= PTARB){
@


11.21
log
@convert commands to Tcl
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.20 1996/03/22 18:31:14 bparker Exp bparker $ (BRL)";
d2048 53
d2131 3
a2133 2
		/* do nothing */
		break;
d2194 3
d2231 1
@


11.20
log
@cleanup
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.19 1996/03/01 19:19:31 bparker Exp bparker $ (BRL)";
d630 2
a631 2
				rt_log( "No Pipe Segment selected\n" );
				return;
d636 2
a637 2
				rt_log( "Current segment is the last\n" );
				return;
d648 2
a649 2
				rt_log( "No Pipe Segment selected\n" );
				return;
d654 2
a655 2
				rt_log( "Current segment is the first\n" );
				return;
d669 3
a671 3
				rt_log( "No Pipe Segment selected\n" );
				es_edflag = IDLE;
				return;
d681 3
a683 3
				rt_log( "No Pipe Segment selected\n" );
				es_edflag = IDLE;
				return;
d952 1
a952 1
	rt_log("NOT IMPLEMENTED YET\n");
d987 2
a988 2
		rt_log("nmg_ed: undefined menu event?\n");
		return;
d996 2
a997 2
			rt_log("nmg_ed: no edge selected yet\n");
			return;
d1031 2
a1032 2
			rt_log("nmg_ed: no edge selected yet\n");
			return;
d1036 12
a1047 3
		rt_log("edgeuse selected=x%x (%g %g %g) <-> (%g %g %g)\n", es_eu,
			V3ARGS( es_eu->vu_p->v_p->vg_p->coord ),
			V3ARGS( es_eu->eumate_p->vu_p->v_p->vg_p->coord ) );
d1057 12
a1068 3
		rt_log("edgeuse selected=x%x (%g %g %g) <-> (%g %g %g)\n", es_eu,
			V3ARGS( es_eu->vu_p->v_p->vg_p->coord ),
			V3ARGS( es_eu->eumate_p->vu_p->v_p->vg_p->coord ) );
d1078 12
a1089 3
		rt_log("edgeuse selected=x%x (%g %g %g) <-> (%g %g %g)\n", es_eu,
			V3ARGS( es_eu->vu_p->v_p->vg_p->coord ),
			V3ARGS( es_eu->eumate_p->vu_p->v_p->vg_p->coord ) );
d1129 3
a1131 2
				rt_log( "No sketch (wire loop) to extrude\n" );
				return;
d1136 1
a1136 1
				rt_log( "Too many wire loops!!! Don't know which to extrude!!\n" );
d1151 3
a1153 2
				rt_log( "Cannot extrude loop with no area\n" );
				return;
d1192 1
a1192 10
						rt_log( "Loop crosses itself, cannot extrude\n" );
						rt_log( "edge1: pt=( %g %g %g ), dir=( %g %g %g)\n",
							V3ARGS( v1->vg_p->coord ), V3ARGS( edge1 ) );
						rt_log( "edge2: pt=( %g %g %g ), dir=( %g %g %g)\n",
							V3ARGS( v2->vg_p->coord ), V3ARGS( edge2 ) );
						if( ret_val == 0 )
							rt_log( "edges are collinear and overlap\n" );
						else
						{
							point_t isect_pt;
d1194 26
a1219 5
							VJOIN1( isect_pt, v1->vg_p->coord, dist[0], edge1 );
							rt_log( "edges intersect at ( %g %g %g )\n",
								V3ARGS( isect_pt ) );
						}
						return;
d1231 3
a1233 3
				rt_log( "Failed to make copy of loop\n" );
				nmg_km( m_tmp );
				return;
d1752 4
a1755 4
		rt_log( "get_solid_keypoint: unrecognized solid type (setting keypoint to origin)\n" );
		VSETALL( mpt, 0 );
		*strp = "(origin)";
		break;
d1787 4
a1790 1
			rt_log("No eqn for face %d%d%d%d\n",
d1792 3
a1794 1
			return;
d1816 3
a1818 3
		rt_log(
"Unable to Solid_Edit a processed region;  select a primitive instead\n");
		return;
d1824 4
a1827 2
	if( db_get_external( &es_ext, illump->s_path[illump->s_last], dbip ) < 0 )
		READ_ERR_return;
d1831 5
a1835 5
		rt_log("init_sedit(%s):  solid import failure\n",
			illump->s_path[illump->s_last]->d_namep );
	    	if( es_int.idb_ptr )  rt_functab[id].ft_ifree( &es_int );
		db_free_external( &es_ext );
		return;				/* FAIL */
d1852 5
a1856 4
			rt_log( "Cannot calculate plane equations for ARB8\n" );
			db_free_external( &es_ext );
			rt_functab[id].ft_ifree( &es_int );
			return;
d2029 7
a2035 7
		/* use temp_srec until we know intersect doesn't fail */
		if( intersect(type,i*3,i,&temp_srec) ){
			rt_log("Intersection of planes fails\n");
			/* clean up array es_peqn for anyone else */
			calc_planes( old_srec, type );
			return;				/* failure */
		}
d2103 2
a2104 2
				rt_log("Bad menu item.\n");
				return;
d2136 2
a2137 2
				rt_log("\nFixed vertex is point 5.\n");
				fixv = 5;
d2231 3
a2233 2
				rt_log("Must be < rot fb | xdeg ydeg zdeg >\n");
				return;
d2362 4
a2365 3
				rt_log("Zero H vector not allowed, resetting to +Z\n");
				VSET(tgc->h, 0, 0, 1 );
				break;
d2405 4
a2408 3
				rt_log("Zero H vector not allowed, resetting to +Z\n");
				VSET(tgc->h, 0, 0, 1 );
				break;
d2525 2
a2526 2
				rt_log( "No edge selected!\n" );
				break;
d2536 3
a2538 2
				rt_log( "x y z coordinates required for edge move\n" );
				break;
d2570 2
a2571 2
						/* line does not intersect plane, don't do an esplit */
						rt_log( "Edge Move: Cannot place new point in plane of loop\n" );
d2591 2
a2592 2
				rt_log( "No edge selected!\n" );
				break;
d2608 4
a2611 4
					/* Currently can only kill wire edges or edges in wire loops */
					rt_log( "Currently, we can only kill wire edges or edges in wire loops\n" );
					es_edflag = IDLE;
					break;
d2624 4
a2627 4
						/* refuse to delete last edge that runs
						 * to/from same vertex
						 */
						rt_log( "Cannot delete last edge running to/from same vertex\n" );
d2675 2
a2676 2
				rt_log( "No edge selected!\n" );
				break;
d2687 3
a2689 2
				rt_log( "x y z coordinates required for edge split\n" );
				break;
d2704 1
a2704 1
					rt_log( "Currently, we can only split wire edges or edges in wire loops\n" );
d2724 2
a2725 2
						/* line does not intersect plane, don't do an esplit */
						rt_log( "Edge Split: Cannot place new point in plane of loop\n" );
d2757 2
a2758 2
				rt_log( "x y z coordinates required for loop extrusion\n" );
				break;
d2767 2
a2768 2
				rt_log( "Cannot extrude parallel to plane of loop\n" );
				return;
d2784 2
a2785 2
				rt_log( "loop to be extruded as no area!!!\n" );
				return;
d2833 2
a2834 2
				rt_log( "x y z coordinates required for segment selection\n" );
				break;
d2841 1
a2841 1
				rt_log( "No PIPE segment selected\n" );
d2860 2
a2861 2
				rt_log( "x y z coordinates required for segment split\n" );
				break;
d2868 1
a2868 1
				rt_log( "No pipe segment selected\n" );
d2889 2
a2890 2
				rt_log( "x y z coordinates required for segment movement\n" );
				break;
d2897 2
a2898 2
				rt_log( "No pipe segment selected\n" );
				break;
d2918 2
a2919 2
				rt_log( "x y z coordinates required for 'append segment'\n" );
				break;
d2941 2
a2942 2
				rt_log( "x y z coordinates required for 'prepend segment'\n" );
				break;
d2954 2
a2955 2
				rt_log( "No pipe segment selected\n" );
				break;
d2961 8
a2968 1
		rt_log("sedit():  unknown edflag = %d.\n", es_edflag );
d3161 2
a3162 2
				rt_log("ECMD_NMG_EPICK: unable to find an edge\n");
				return;
d3166 13
a3178 3
				rt_log("edgeuse selected=x%x (%g %g %g) <-> (%g %g %g)\n", es_eu,
				V3ARGS( es_eu->vu_p->v_p->vg_p->coord ),
				V3ARGS( es_eu->eumate_p->vu_p->v_p->vg_p->coord ) );
d3199 2
a3200 2
		rt_log("mouse press undefined in this solid edit mode\n");
		break;
d3286 2
a3287 2
		rt_log("No object edit mode selected;  mouse press ignored\n");
		return;
d3313 1
a3313 1
		rt_log("vls_solid: describe error\n");
d3902 6
a3907 6
		{
			if( !es_pipept )
			{
				rt_log( "pscale: no pipe segment selected for scaling\n" );
				return;
			}
d3909 10
a3918 10
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				if( es_pipept->pp_od > 0.0 )
					es_scale = es_para[0] * es_mat[15]/es_pipept->pp_od;
				else
					es_scale = (-es_para[0] * es_mat[15]);
			}
			pipe_seg_scale_od( es_pipept, es_scale );
		}
		break;
d3923 2
a3924 2
				rt_log( "pscale: no pipe segment selected for scaling\n" );
				return;
d3941 2
a3942 2
				rt_log( "pscale: no pipe segment selected for scaling\n" );
				return;
d3976 2
a3977 2
					rt_log( "Entire pipe solid has zero OD!!!!\n" );
					return;
d4074 4
a4077 4
		rt_log("init_objedit(%s): db_get_external failure\n",
			illump->s_path[illump->s_last]->d_namep );
		button(BE_REJECT);
		return;
d4082 5
a4086 5
		rt_log("init_objedit(%s):  solid import failure\n",
			illump->s_path[illump->s_last]->d_namep );
	    	if( es_int.idb_ptr )  rt_functab[id].ft_ifree( &es_int );
		db_free_external( &es_ext );
		return;				/* FAIL */
d4197 3
a4199 1
f_eqn(argc, argv)
d4207 3
d4211 2
a4212 2
		rt_log("Eqn: must be in solid edit\n");
		return CMD_BAD;
d4217 2
a4218 2
		rt_log("Eqn: type must be GENARB8\n");
		return CMD_BAD;
d4222 2
a4223 2
		rt_log("Eqn: must be rotating a face\n");
		return CMD_BAD;
d4245 1
a4245 1
	return CMD_OK;
d4273 5
a4277 4
		rt_log("sedit_accept(%s):  solid export failure\n", dp->d_namep);
	    	if( es_int.idb_ptr )  rt_functab[es_int.idb_type].ft_ifree( &es_int );
		db_free_external( &es_ext );
		return;				/* FAIL */
d4283 2
a4284 2
		ERROR_RECOVERY_SUGGESTION;
		WRITE_ERR_return;
d4327 3
a4329 1
f_param( argc, argv )
d4335 3
d4339 2
a4340 2
		rt_log("A solid editor option not selected\n");
		return CMD_BAD;
d4345 2
a4346 2
		rt_log("\"p\" command not defined for this option\n");
		return CMD_BAD;
d4360 4
a4363 4
				rt_log("ERROR: SCALE FACTOR < 0\n");
				inpara = 0;
				sedraw = 0;
				return CMD_BAD;
d4369 4
a4372 4
				rt_log("ERROR: SCALE FACTOR <= 0\n");
				inpara = 0;
				sedraw = 0;
				return CMD_BAD;
d4416 1
a4416 1
	return CMD_OK;
d4921 7
a4927 4
			rt_log("rt_arb_calc_planes: No eqn for face %d%d%d%d\n",
				p1+1, p2+1, p3+1,
				arb_faces[type][i*4+3]+1);
			return -1;
d5184 3
a5186 1
f_keypoint (argc, argv)
d5190 40
a5229 5
	if ((state != ST_S_EDIT) && (state != ST_O_EDIT))
	{
	    state_err("keypoint assignment");
	    return CMD_BAD;
	}
d5231 2
a5232 29
	switch (--argc)
	{
	    case 0:
		rt_log("%s (%g, %g, %g)\n", es_keytag, V3ARGS(es_keypoint));
		break;
	    case 3:
		VSET(es_keypoint,
		    atof( argv[1] ) * local2base,
		    atof( argv[2] ) * local2base,
		    atof( argv[3] ) * local2base);
		es_keytag = "user-specified";
		es_keyfixed = 1;
		break;
	    case 1:
		if (strcmp(argv[1], "reset") == 0)
		{
		    es_keytag = "";
		    es_keyfixed = 0;
		    get_solid_keypoint(es_keypoint, &es_keytag,
					&es_int, es_mat);
		    break;
		}
	    default:
		rt_log("Usage: 'keypoint [<x y z> | reset]'\n");
		return CMD_BAD;
	}

	dmaflag = 1;
	return CMD_OK;
@


11.19
log
@remove unused XMGED stuff
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.18 1996/02/09 22:15:02 bparker Exp bparker $ (BRL)";
a59 1
#ifdef VIRTUAL_TRACKBALL
a60 1
#endif
a2023 1
#ifdef MULTI_ATTACH
a2024 1
#endif
a3150 3
#ifdef MULTI_ATTACH
	update_views = 1;
#endif
d4091 2
d4095 1
a4319 1
#ifdef VIRTUAL_TRACKBALL
a4334 4
#else
			return CMD_OK;
	}
#endif
@


11.18
log
@adding virtual trackball stuff
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.17 1996/01/05 22:08:48 bparker Exp bparker $ (BRL)";
a60 2
extern void (*tran_hook)();
extern void (*rot_hook)();
a61 2
extern int rot_set;
extern int tran_set;
d64 1
a64 1
#ifdef XMGED
d2110 1
a2110 3
#ifdef XMGED
				(void)mged_gets( line ); /* Null terminated */
#else
d2113 1
a2113 1
#endif
a4333 3

	  if(rot_hook)
	    (*rot_hook)();
a4336 3

	  if(tran_hook)
	    (*tran_hook)();
@


11.17
log
@Just playing it safe
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.16 1995/12/01 02:51:31 mike Exp bparker $ (BRL)";
d59 2
a60 1
#ifdef XMGED
d63 2
a64 4
extern int irot_set;
extern double irot_x;
extern double irot_y;
extern double irot_z;
d66 3
a68 3
extern double tran_x;
extern double tran_y;
extern double tran_z;
a69 2

void set_tran();
d4330 1
a4330 1
#ifdef XMGED
d4335 4
a4338 4
	  if(!irot_set){
	    irot_x = es_para[0];
	    irot_y = es_para[1];
	    irot_z = es_para[2];
@


11.16
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.15 1995/11/27 15:47:37 jra Exp $ (BRL)";
a69 1
extern int      update_views;
d2033 1
a2033 1
#ifdef XMGED
d3164 1
a3164 1
#ifdef XMGED
@


11.15
log
@Mod to nmg_ed(), will now skip call to nmg_vlblock_around_eu() for CNURB edges.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.14 1995/11/07 22:56:43 bparker Exp jra $ (BRL)";
d1507 2
a1508 2
			register struct snurb	*surf;
			register fastf_t	*fp;
d1824 1
a1824 1
		register struct snurb	*surf;
d2297 1
a2297 1
			register struct snurb	*surf;
d4767 1
a4767 1
			register struct snurb	*surf;
d5010 1
a5010 1
	struct snurb	*srf;
d5072 1
a5072 1
	struct snurb	*srf;
@


11.14
log
@unleashed a few xmged commands
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.13 1995/08/03 14:42:29 jra Exp bparker $ (BRL)";
d1019 1
a1019 1
			if( es_eu->g.magic_p )
@


11.13
log
@Added bend radius scaling for pipe solid.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.12 1995/07/28 20:31:52 jra Exp jra $ (BRL)";
d58 1
a59 1
extern void set_e_axis_pos();
d87 1
a87 1
#ifdef XMGED
a544 1
#ifdef XMGED
a545 1
#endif
a563 1
#ifdef XMGED
a564 1
#endif
a587 1
#ifdef XMGED
a588 1
#endif
a606 1
#ifdef XMGED
a607 1
#endif
a620 1
#ifdef XMGED
a621 1
#endif
a717 1
#ifdef XMGED
a718 1
#endif
a735 1
#ifdef XMGED
a736 1
#endif
a746 1
#ifdef XMGED
a747 1
#endif
a759 1
#ifdef XMGED
a760 1
#endif
a769 1
#ifdef XMGED
a770 1
#endif
a779 1
#ifdef XMGED
a780 1
#endif
a789 1
#ifdef XMGED
a790 1
#endif
a799 1
#ifdef XMGED
a800 1
#endif
a809 1
#ifdef XMGED
a810 1
#endif
a823 1
#ifdef XMGED
a824 1
#endif
a837 1
#ifdef XMGED
a838 1
#endif
a851 1
#ifdef XMGED
a852 1
#endif
a865 1
#ifdef XMGED
a866 1
#endif
a879 1
#ifdef XMGED
a880 1
#endif
a980 1
#ifdef XMGED
a981 1
#endif
a2145 1
#ifdef XMGED
a2146 1
#endif
a4053 1
#ifdef XMGED
a4054 1
#endif
@


11.12
log
@Added editing for new style pipe solid.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.11 1995/07/20 22:38:10 jra Exp $ (BRL)";
d187 2
d501 1
d504 1
d698 1
d710 1
d3925 18
d4000 28
@


11.11
log
@Added move segment for pipe editing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.10 1995/07/18 22:53:50 jra Exp jra $ (BRL)";
d94 3
a96 3
MGED_EXTERN( struct wdb_pipeseg *find_pipeseg_nearest_pt, (CONST struct rt_list *pipe_hd, CONST point_t pt ) );
MGED_EXTERN( void split_pipeseg, (struct rt_list *pipe_hd, struct wdb_pipeseg *ps, point_t pt ) );
MGED_EXTERN( struct wdb_pipeseg *del_pipeseg, (struct wdb_pipeseg *ps ) );
d132 1
a132 1
static struct wdb_pipeseg *es_pipeseg=(struct wdb_pipeseg *)NULL; /* Currently selected PIPE segment */
d176 2
a177 2
#define	MENU_PIPE_NEXT_SEG	61
#define MENU_PIPE_PREV_SEG	62
d179 2
a180 2
#define MENU_PSEG_OD		64
#define MENU_PSEG_ID		65
d183 4
a186 4
#define	MENU_PIPE_ADD_SEG	68
#define MENU_PIPE_INS_SEG	69
#define MENU_PIPE_DEL_SEG	70
#define	MENU_PIPE_MOV_SEG	71
d490 9
a498 10
	{ "select segment", pipe_ed, MENU_PIPE_SELECT },
	{ "next segment", pipe_ed, MENU_PIPE_NEXT_SEG },
	{ "previous segment", pipe_ed, MENU_PIPE_PREV_SEG },
	{ "split segment", pipe_ed, MENU_PIPE_SPLIT },
	{ "move segment", pipe_ed, MENU_PIPE_MOV_SEG },
	{ "delete segment", pipe_ed, MENU_PIPE_DEL_SEG },
	{ "append segmemt", pipe_ed, MENU_PIPE_ADD_SEG },
	{ "prepend segment", pipe_ed, MENU_PIPE_INS_SEG },
	{ "scale segment OD", pipe_ed, MENU_PSEG_OD },
	{ "scale segment ID", pipe_ed, MENU_PSEG_ID },
d634 2
a635 2
	struct wdb_pipeseg *next;
	struct wdb_pipeseg *prev;
d643 2
a644 2
		case MENU_PIPE_NEXT_SEG:
			if( !es_pipeseg )
d649 2
a650 1
			if( es_pipeseg->ps_type == WDB_PIPESEG_TYPE_END )
d655 1
a655 2
			next = RT_LIST_NEXT( wdb_pipeseg, &es_pipeseg->l );
			es_pipeseg = next;
d657 1
a657 1
			rt_pipeseg_print( es_pipeseg, base2local );
d661 2
a662 2
		case MENU_PIPE_PREV_SEG:
			if( !es_pipeseg )
d667 1
a667 1
			prev = RT_LIST_PREV( wdb_pipeseg, &es_pipeseg->l );
d673 1
a673 1
			es_pipeseg = prev;
d675 1
a675 1
			rt_pipeseg_print( es_pipeseg, base2local );
d680 1
a680 14
			if( !es_pipeseg )
			{
				rt_log( "No Pipe Segment selected\n" );
				es_edflag = IDLE;
				return;
			}
			if( es_pipeseg->ps_type != WDB_PIPESEG_TYPE_LINEAR )
			{
				rt_log( "Can only split linear segements\n" );
				es_edflag = IDLE;
				return;
			}
			es_menu = arg;
			es_edflag = ECMD_PIPE_SPLIT;
d682 2
a683 2
		case MENU_PIPE_MOV_SEG:
			if( !es_pipeseg )
d690 1
a690 1
			es_edflag = ECMD_PIPE_SEG_MOVE;
d692 3
a694 3
		case MENU_PSEG_OD:
		case MENU_PSEG_ID:
			if( !es_pipeseg )
d708 1
a708 1
		case MENU_PIPE_ADD_SEG:
d710 1
a710 1
			es_edflag = ECMD_PIPE_SEG_ADD;
d712 1
a712 1
		case MENU_PIPE_INS_SEG:
d714 1
a714 1
			es_edflag = ECMD_PIPE_SEG_INS;
d716 1
a716 1
		case MENU_PIPE_DEL_SEG:
d719 1
a719 1
			es_edflag = ECMD_PIPE_SEG_DEL;
d1318 1
a1318 1
			struct wdb_pipeseg *pipe_seg;
d1322 2
a1323 2
			pipe_seg = RT_LIST_FIRST( wdb_pipeseg , &pipe->pipe_segs_head );
			VMOVE( mpt , pipe_seg->ps_start );
d1878 1
a1878 1
	es_pipeseg = (struct wdb_pipeseg *)NULL; /* Reset es_pipeseg */
d2277 1
a2277 1
			es_pipeseg = (struct wdb_pipeseg *)NULL; /* Reset es_pipeseg */
d2299 1
a2299 1
			es_pipeseg = (struct wdb_pipeseg *)NULL; /* Reset es_pipeseg */
d2322 1
a2322 1
		es_pipeseg = (struct wdb_pipeseg *)NULL; /* Reset es_pipeseg */
d2431 1
a2431 1
			es_pipeseg = (struct wdb_pipeseg *)NULL; /* Reset es_pipeseg */
d2818 1
a2818 1
			struct wdb_pipeseg *next;
d2835 2
a2836 2
			es_pipeseg = find_pipeseg_nearest_pt( &pipe->pipe_segs_head, new_pt );
			if( !es_pipeseg )
d2839 1
a2839 1
				rt_pipeseg_print( es_pipeseg, base2local );
d2862 1
a2862 1
			if( !es_pipeseg )
a2866 5
			if( es_pipeseg->ps_type != WDB_PIPESEG_TYPE_LINEAR )
			{
				rt_log( "Can only split linear pipe segments\n" );
				break;
			}
d2868 1
a2868 1
			split_pipeseg( &pipe->pipe_segs_head, es_pipeseg, new_pt );
d2871 1
a2871 1
	case ECMD_PIPE_SEG_MOVE:
d2891 1
a2891 1
			if( !es_pipeseg )
d2897 1
a2897 1
			move_pipeseg( pipe, es_pipeseg, new_pt );
d2900 1
a2900 1
	case ECMD_PIPE_SEG_ADD:
d2920 1
a2920 1
			add_pipeseg( pipe, new_pt );
d2923 1
a2923 1
	case ECMD_PIPE_SEG_INS:
d2943 1
a2943 1
			ins_pipeseg( pipe, new_pt );
d2946 1
a2946 1
	case ECMD_PIPE_SEG_DEL:
d2948 1
a2948 1
			if( !es_pipeseg )
d2953 1
a2953 1
			es_pipeseg = del_pipeseg( es_pipeseg );
d3167 3
a3169 3
	case ECMD_PIPE_SEG_MOVE:
	case ECMD_PIPE_SEG_ADD:
	case ECMD_PIPE_SEG_INS:
d3297 1
a3297 1
	if( id == ID_PIPE && es_pipeseg )
d3300 1
a3300 1
		struct wdb_pipeseg *ps=(struct wdb_pipeseg *)NULL;
d3306 1
a3306 1
		for( RT_LIST_FOR( ps, wdb_pipeseg, &pipe->pipe_segs_head ) )
d3309 1
a3309 1
			if( ps == es_pipeseg )
d3313 2
a3314 2
		if( ps == es_pipeseg )
			vls_pipeseg( vp, seg_no, &intern, base2local );
d3883 1
a3883 1
	case MENU_PSEG_OD:	/* scale OD of one pipe segment */
d3885 1
a3885 1
			if( !es_pipeseg )
d3893 2
a3894 2
				if( es_pipeseg->ps_od > 0.0 )
					es_scale = es_para[0] * es_mat[15]/es_pipeseg->ps_od;
d3898 1
a3898 1
			pipe_seg_scale_od( es_pipeseg, es_scale );
d3901 1
a3901 1
	case MENU_PSEG_ID:	/* scale ID of one pipe segment */
d3903 1
a3903 1
			if( !es_pipeseg )
d3911 2
a3912 2
				if( es_pipeseg->ps_id > 0.0 )
					es_scale = es_para[0] * es_mat[15]/es_pipeseg->ps_id;
d3916 1
a3916 1
			pipe_seg_scale_id( es_pipeseg, es_scale );
d3924 1
a3924 1
			struct wdb_pipeseg *ps;
d3928 2
a3929 2
			ps = RT_LIST_FIRST( wdb_pipeseg, &pipe->pipe_segs_head );
			RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "wdb_pipeseg" );
d3931 2
a3932 2
			if( ps->ps_od > 0.0 )
				es_scale = es_para[0] * es_mat[15]/ps->ps_od;
d3935 2
a3936 2
				while( ps->l.magic != RT_LIST_HEAD_MAGIC && ps->ps_od <= 0.0 )
					ps = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
d3944 1
a3944 1
				es_scale = es_para[0] * es_mat[15]/ps->ps_od;
d3954 1
a3954 1
			struct wdb_pipeseg *ps;
d3958 2
a3959 2
			ps = RT_LIST_FIRST( wdb_pipeseg, &pipe->pipe_segs_head );
			RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "wdb_pipeseg" );
d3961 2
a3962 2
			if( ps->ps_id > 0.0 )
				es_scale = es_para[0] * es_mat[15]/ps->ps_id;
d3965 2
a3966 2
				while( ps->l.magic != RT_LIST_HEAD_MAGIC && ps->ps_id <= 0.0 )
					ps = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
d3972 1
a3972 1
					es_scale = es_para[0] * es_mat[15]/ps->ps_id;
d4188 1
a4188 1
	es_pipeseg = (struct wdb_pipeseg *)NULL; /* Reset es_pipeseg */
d4231 1
a4231 1
	es_pipeseg = (struct wdb_pipeseg *)NULL; /* Reset es_pipeseg */
d4280 1
a4280 1
		if( es_menu == MENU_PSEG_OD || es_menu == MENU_PSEG_ID || MENU_PIPE_SCALE_ID )
d4317 3
a4319 3
		case ECMD_PIPE_SEG_MOVE:
		case ECMD_PIPE_SEG_ADD:
		case ECMD_PIPE_SEG_INS:
d4806 1
a4806 1
			struct wdb_pipeseg *next;
d4810 2
a4811 3
			if( es_pipeseg ) {
				point_t cent;
				RT_CKMAG( es_pipeseg, WDB_PIPESEG_MAGIC, "wdb_pipeseg" );
d4813 2
a4814 41
				switch( es_pipeseg->ps_type )
				{
					case WDB_PIPESEG_TYPE_END:
						VMOVE( cent, es_pipeseg->ps_start );
						break;
					case WDB_PIPESEG_TYPE_LINEAR:
						next = RT_LIST_NEXT( wdb_pipeseg, &es_pipeseg->l );
						VADD2SCALE( cent, es_pipeseg->ps_start,
							next->ps_start, 0.5 );
						break;
					case WDB_PIPESEG_TYPE_BEND:
						{
							vect_t v1, v2;
							vect_t to_start,to_end;
							vect_t normal;
							fastf_t bend_radius;
							fastf_t angle;
							fastf_t v1_coeff, v2_coeff;

							next = RT_LIST_NEXT( wdb_pipeseg, &es_pipeseg->l );
							VSUB2( to_start, es_pipeseg->ps_start,
								es_pipeseg->ps_bendcenter );
							VSUB2( to_end, next->ps_start,
								es_pipeseg->ps_bendcenter );
							VCROSS( normal, to_start, to_end );
							VCROSS( v2, normal, to_start );
							VUNITIZE( v2 );
							bend_radius = MAGNITUDE( to_start );
							VSCALE( v1, to_start, 1.0/bend_radius );
							angle = atan2( VDOT( to_end, v2 ), VDOT( to_end, v1 ) );
							angle = angle/2.0;
							v1_coeff = bend_radius*cos(angle);
							v2_coeff = bend_radius*sin(angle);
							VJOIN2( cent, es_pipeseg->ps_bendcenter,
								v1_coeff, v1, v2_coeff, v2 );
							
						}
						break;
				}
				MAT4X3PNT(pos_view, xform, cent);
				POINT_LABEL_STR( pos_view, "seg" );
@


11.10
log
@Added delete segment capabilities to pipe editing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.9 1995/07/17 20:18:03 jra Exp jra $ (BRL)";
d186 1
d494 1
d696 10
d2870 1
a2870 1
				rt_log( "x y z coordinates required for segment selection\n" );
d2890 29
d3186 1
d4336 1
@


11.9
log
@Added more pipe editing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.8 1995/07/14 19:10:11 jra Exp jra $ (BRL)";
d96 1
d185 1
d493 1
d717 6
d2922 10
@


11.8
log
@Added some pipe solid editing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.7 1995/03/08 16:38:55 jra Exp jra $ (BRL)";
d179 5
d491 2
d494 3
d690 1
d692 1
d702 12
d2869 46
d3126 2
d3851 4
a3854 1
				es_scale = es_para[0] * es_mat[15]/es_pipeseg->ps_od;
d3859 76
d4238 18
a4255 5
		if(es_para[0] <= 0.0) {
			rt_log("ERROR: SCALE FACTOR <= 0\n");
			inpara = 0;
			sedraw = 0;
			return CMD_BAD;
d4275 2
@


11.7
log
@Added vertex coordinate output on edgeuse selection.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.6 95/02/20 16:55:15 jra Exp Locker: jra $ (BRL)";
d77 1
a77 1
static void	nmg_ed();
d94 2
d131 2
d174 5
d480 10
d617 80
d1847 1
d1965 3
d2246 1
d2268 1
d2291 1
d2400 1
d2783 47
d2831 14
d3054 2
d3182 20
d3769 15
a3783 1

d3995 1
d4038 1
d4109 2
d4593 55
@


11.6
log
@Mod to sedit_mouse() to make picking an NMG edge independent of current tolerances.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.5 95/02/18 03:08:51 mike Exp Locker: jra $ (BRL)";
d950 3
a952 1
		rt_log("edgeuse selected=x%x\n", es_eu);
d962 3
a964 1
		rt_log("edgeuse selected=x%x\n", es_eu);
d974 3
a976 1
		rt_log("edgeuse selected=x%x\n", es_eu);
d2876 3
a2878 1
			rt_log("edgeuse selected=x%x\n", es_eu);
@


11.5
log
@Eliminated local setting of "rt_tol" structures.
Everything now uses the global mged_tol.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.4 95/01/19 16:20:42 bparker Exp $ (BRL)";
d2853 1
d2855 8
d2864 1
a2864 1
			    model2view, &mged_tol )) == (struct edge *)NULL )  {
@


11.4
log
@merging xmged sources
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.3 95/01/17 13:04:39 bparker Exp $ (BRL)";
d4389 1
a4389 1
struct rt_tol		*tol;
@


11.3
log
@merging xmged sources
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/edsol.c,v 11.2 95/01/17 11:42:56 bparker Exp $ (BRL)";
d1928 3
@


11.2
log
@Added code to set es_type in init_objedit whenever key solid is an ARB8.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.1 95/01/04 10:03:06 mike Rel4_4 Locker: jra $ (BRL)";
d58 18
d86 4
d91 1
d507 4
d528 4
d554 4
d575 4
d591 4
d611 4
d624 4
d639 4
d651 4
d663 4
d675 4
d687 4
d699 4
d715 4
d731 4
d747 4
d763 4
d779 4
d882 4
a886 1

d2009 3
a2011 1

d2014 1
d2037 3
d2897 3
d3626 4
d3889 23
d3914 1
@


11.1
log
@Release_4.4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.73 95/01/03 14:31:09 gdurf Exp $ (BRL)";
d3501 10
@


10.73
log
@Removed wrong sprintf (it was sprintfing on a string constant)
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.72 94/12/23 16:17:28 gdurf Exp Locker: gdurf $ (BRL)";
@


10.72
log
@Fixed typos
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.71 94/12/23 14:30:56 gdurf Exp Locker: gdurf $ (BRL)";
d1051 1
d1202 2
a1203 1
				sprintf( *strp , "V%d" , vertex_number );
d1206 1
d1210 1
a1308 1
			static char		buf[128];
d1611 1
d2609 1
@


10.71
log
@Converted menu_array[]= to menu_set()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.70 94/12/23 14:29:10 gdurf Exp Locker: gdurf $ (BRL)";
d1716 1
a1716 1
	menu_set( MENU_L1, MENU_NULL );
d1722 1
a1722 1
		menu_set( MENU_L1, cntrl_menu );
d1725 1
a1725 1
		menu_set( MENU_L1, tgc_menu );
d1728 1
a1728 1
		menu_set( MENU_L1, tor_menu );
d1731 1
a1731 1
		menu_set( MENU_L1, ell_menu );
d1734 1
a1734 1
		menu_set( MENU_L1, ars_menu );
d1737 1
a1737 1
		menu_set( MENU_L1, spline_menu );
d1740 1
a1740 1
		menu_set( MENU_L1, rpc_menu );
d1743 1
a1743 1
		menu_set( MENU_L1, rhc_menu );
d1746 1
a1746 1
		menu_set( MENU_L1, epa_menu );
d1749 1
a1749 1
		menu_set( MENU_L1, ehy_menu );
d1752 1
a1752 1
		menu_set( MENU_L1, eto_menu );
d1755 1
a1755 1
		menu_set( MENU_L1, nmg_menu );
d1837 1
a1837 1
		menu_set( MENU_L1, cntrl_menu );
d1846 1
a1846 1
				menu_set( MENU_L1, which_menu[es_type-4] );
d1849 1
a1849 1
				menu_set( MENU_L1, which_menu[es_type+1] );
d1852 1
a1852 1
				menu_set( MENU_L1, which_menu[es_type+6] );
@


10.70
log
@Converted menu_array[]= to menu_set()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.69 94/12/20 16:36:23 jra Exp Locker: gdurf $ (BRL)";
d1837 1
a1837 1
		menu_array[MENU_L1] = cntrl_menu;
d1846 1
a1846 1
				menu_array[MENU_L1] = which_menu[es_type-4];
d1849 1
a1849 1
				menu_array[MENU_L1] = which_menu[es_type+1];
d1852 1
a1852 1
				menu_array[MENU_L1] = which_menu[es_type+6];
@


10.69
log
@A few gdurf changes and MODS for CRAY.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.68 94/12/16 19:36:43 gdurf Exp Locker: jra $ (BRL)";
d1716 1
a1716 1
	menu_array[MENU_L1] = MENU_NULL;
d1722 1
a1722 1
		menu_array[MENU_L1] = cntrl_menu;
d1725 1
a1725 1
		menu_array[MENU_L1] = tgc_menu;
d1728 1
a1728 1
		menu_array[MENU_L1] = tor_menu;
d1731 1
a1731 1
		menu_array[MENU_L1] = ell_menu;
d1734 1
a1734 1
		menu_array[MENU_L1] = ars_menu;
d1737 1
a1737 1
		menu_array[MENU_L1] = spline_menu;
d1740 1
a1740 1
		menu_array[MENU_L1] = rpc_menu;
d1743 1
a1743 1
		menu_array[MENU_L1] = rhc_menu;
d1746 1
a1746 1
		menu_array[MENU_L1] = epa_menu;
d1749 1
a1749 1
		menu_array[MENU_L1] = ehy_menu;
d1752 1
a1752 1
		menu_array[MENU_L1] = eto_menu;
d1755 1
a1755 1
		menu_array[MENU_L1] = nmg_menu;
@


10.68
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.67 1994/11/28 13:29:52 jra Exp gdurf $ (BRL)";
a884 1
			long *trans_tbl;
a1012 3
				long *trans_tbl;
				struct loopuse *new_lu;

d1684 1
a1684 1
mat_t			mat;
d2875 1
a2875 1
	transform_editing_solid( &intern, mat, ip, 0 );
@


10.67
log
@Added code to modify edge geometry in sedit when NMG edges are split or deleted.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/edsol.c,v 10.66 94/11/22 17:09:07 jra Exp Locker: jra $ (BRL)";
d769 1
a769 1
	(void)printf("NOT IMPLEMENTED YET\n");
d803 1
a803 1
		(void)printf("nmg_ed: undefined menu event?\n");
d812 1
a812 1
			(void)printf("nmg_ed: no edge selected yet\n");
d847 1
a847 1
			(void)printf("nmg_ed: no edge selected yet\n");
d852 1
a852 1
		(void)printf("edgeuse selected=x%x\n", es_eu);
d857 1
a857 1
			(void)printf("nmg_ed: no edge selected yet\n");
d862 1
a862 1
		(void)printf("edgeuse selected=x%x\n", es_eu);
d867 1
a867 1
			(void)printf("nmg_ed: no edge selected yet\n");
d872 1
a872 1
		(void)printf("edgeuse selected=x%x\n", es_eu);
d913 1
a913 1
				(void)printf( "No sketch (wire loop) to extrude\n" );
d919 1
a919 1
				(void)printf( "Too many wire loops!!! Don't know which to extrude!!\n" );
d934 1
a934 1
				(void)printf( "Cannot extrude loop with no area\n" );
d974 2
a975 2
						(void)printf( "Loop crosses itself, cannot extrude\n" );
						(void)printf( "edge1: pt=( %g %g %g ), dir=( %g %g %g)\n",
d977 1
a977 1
						(void)printf( "edge2: pt=( %g %g %g ), dir=( %g %g %g)\n",
d980 1
a980 1
							(void)printf( "edges are collinear and overlap\n" );
d986 1
a986 1
							(void)printf( "edges intersect at ( %g %g %g )\n",
d1001 1
a1001 1
				(void)printf( "Failed to make copy of loop\n" );
d1557 1
a1557 1
			(void)printf("No eqn for face %d%d%d%d\n",
d1581 1
a1581 1
		(void)printf(
d1614 1
a1614 1
			(void) printf( "Cannot calculate plane equations for ARB8\n" );
d1788 1
a1788 1
			(void)printf("Intersection of planes fails\n");
d1859 1
a1859 1
				(void)printf("Bad menu item.\n");
d1892 1
a1892 1
				(void)printf("\nFixed vertex is point 5.\n");
d1903 1
a1903 1
				(void)printf("\nEnter fixed vertex number( ");
d1907 1
a1907 1
						printf("%d ",
d1910 1
a1910 1
				printf(") [%d]: ",arb_vertices[type][loc]);
d1985 1
a1985 1
				(void)printf("Must be < rot fb | xdeg ydeg zdeg >\n");
d2112 1
a2112 1
				(void)printf("Zero H vector not allowed, resetting to +Z\n");
d2154 1
a2154 1
				(void)printf("Zero H vector not allowed, resetting to +Z\n");
d2272 1
a2272 1
				printf( "No edge selected!\n" );
d2283 1
a2283 1
				(void)printf( "x y z coordinates required for edge move\n" );
d2317 1
a2317 1
						(void)printf( "Edge Move: Cannot place new point in plane of loop\n" );
d2337 1
a2337 1
				printf( "No edge selected!\n" );
d2355 1
a2355 1
					(void)printf( "Currently, we can only kill wire edges or edges in wire loops\n" );
d2373 1
a2373 1
						(void)printf( "Cannot delete last edge running to/from same vertex\n" );
d2421 1
a2421 1
				printf( "No edge selected!\n" );
d2433 1
a2433 1
				(void)printf( "x y z coordinates required for edge split\n" );
d2449 1
a2449 1
					(void)printf( "Currently, we can only split wire edges or edges in wire loops\n" );
d2470 1
a2470 1
						(void)printf( "Edge Split: Cannot place new point in plane of loop\n" );
d2502 1
a2502 1
				(void)printf( "x y z coordinates required for loop extrusion\n" );
d2512 1
a2512 1
				(void)printf( "Cannot extrude parallel to plane of loop\n" );
d2529 1
a2529 1
				(void)printf( "loop to be extruded as no area!!!\n" );
d2565 1
a2565 1
		(void)printf("sedit():  unknown edflag = %d.\n", es_edflag );
d2748 1
a2748 1
				(void)printf("ECMD_NMG_EPICK: unable to find an edge\n");
d2753 1
a2753 1
			(void)printf("edgeuse selected=x%x\n", es_eu);
d2769 1
a2769 1
		(void)printf("mouse press undefined in this solid edit mode\n");
d2856 1
a2856 1
		(void)printf("No object edit mode selected;  mouse press ignored\n");
d2883 1
a2883 1
		printf("vls_solid: describe error\n");
d3485 1
a3485 1
		(void)printf("init_objedit(%s): db_get_external failure\n",
d3602 1
a3602 1
		(void)printf("Eqn: must be in solid edit\n");
d3608 1
a3608 1
		(void)printf("Eqn: type must be GENARB8\n");
d3613 1
a3613 1
		(void)printf("Eqn: must be rotating a face\n");
d3722 1
a3722 1
		(void)printf("A solid editor option not selected\n");
d3728 1
a3728 1
		(void)printf("\"p\" command not defined for this option\n");
d3740 1
a3740 1
			(void)printf("ERROR: SCALE FACTOR <= 0\n");
d4531 1
a4531 1
		printf("%s (%g, %g, %g)\n", es_keytag, V3ARGS(es_keypoint));
d4551 1
a4551 1
		(void) printf("Usage: 'keypoint [<x y z> | reset]'\n");
@


10.66
log
@Added check in nmg_ed to avoid extruding a loop that crosses itself.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/edsol.c,v 10.65 94/11/21 16:32:39 jra Exp Locker: jra $ (BRL)";
d956 1
d971 2
a972 2
					if( rt_isect_lseg3_lseg3( dist, v1->vg_p->coord, edge1,
						v2->vg_p->coord, edge2, &mged_tol ) > (-1) )
d975 14
d2333 1
d2392 7
d2413 1
d2479 4
d2555 1
@


10.65
log
@removed f_dextrude and made "extrude loop" NMG menu entry.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.64 94/11/18 16:25:25 jra Exp Locker: jra $ (BRL)";
d936 41
@


10.64
log
@Added NMG edge split and delete and f_dextrude().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.63 94/11/17 17:07:23 jra Exp Locker: jra $ (BRL)";
d100 5
a104 1
static struct edgeuse	*es_eu;	/* Currently selected NMG edgeuse */
a285 1
	{ "debug edge", nmg_ed, ECMD_NMG_EDEBUG },
d291 2
d875 97
d1588 1
d2299 1
d2385 1
d2416 10
d2427 67
d2688 1
d3579 3
d3583 5
d3621 3
d3625 5
d3690 1
a4485 153
	return CMD_OK;
}

int
f_dextrude( argc, argv )
int argc;
char **argv;
{
	struct model *m;
	struct nmgregion *r;
	struct shell *s;
	struct faceuse *fu;
	struct loopuse *lu=(struct loopuse *)NULL;
	struct loopuse *lu_tmp;
	int wire_loop_count=0;
	int shell_has_faces=0;
	point_t to_pt;
	fastf_t extrude_dist;
	vect_t extrude_dir;
	vect_t extrude_vec;
	char *new_solid_name=(char *)NULL;
	fastf_t area;
	fastf_t dist;
	plane_t pl;

	if( not_state( ST_S_EDIT, "Dextrude" ) )
		return CMD_BAD;

	if( es_int.idb_type != ID_NMG )
	{
		(void)printf( "Dextrude: can only be applied to an NMG solid\n" );
		return CMD_BAD;
	}

	if( argc == 4 )
	{
		VSET( to_pt , atof( argv[1] ) , atof( argv[2] ) , atof( argv[3] ) )
		VSCALE( to_pt , to_pt , local2base );
	}
	else if( argc == 5 )
	{
		extrude_dist = atof( argv[1] ) * local2base;
		VSET( extrude_dir , atof( argv[2] ) , atof( argv[3] ) , atof( argv[4] ) )
		VUNITIZE( extrude_dir );
	}

	m = (struct model *)es_int.idb_ptr;
	NMG_CK_MODEL( m );

	/* look for wire loops */
	for( RT_LIST_FOR( r , nmgregion , &m->r_hd ) )
	{
		NMG_CK_REGION( r );
		for( RT_LIST_FOR( s , shell , &r->s_hd ) )
		{
			if( RT_LIST_IS_EMPTY( &s->lu_hd ) )
				continue;

			for( RT_LIST_FOR( lu_tmp , loopuse , &s->lu_hd ) )
			{
				if( !lu )
					lu = lu_tmp;
				else if( lu_tmp == lu->lumate_p )
					continue;

				wire_loop_count++;
			}
		}
	}

	if( !wire_loop_count )
	{
		(void)printf( "No sketch (wire loop) to extrude\n" );
		return CMD_BAD;
	}

	if( wire_loop_count > 1 )
	{
		(void)printf( "Too many wire loops!!! Don't know which to extrude!!\n" );
		return CMD_BAD;
	}

	if( !lu | *lu->up.magic_p != NMG_SHELL_MAGIC )
	{
		/* This should never happen */
		rt_bomb( "Cannot find wire loop!!\n" );
	}

	/* Make sure loop is not a crack */
	area = nmg_loop_plane_area( lu , pl );

	if( area < 0.0 )
	{
		(void)printf( "Cannot extrude loop with no area\n" );
		return CMD_BAD;
	}

	if( argc == 4 )
	{
		extrude_dist = DIST_PT_PLANE( to_pt , pl );
		VMOVE( extrude_dir , pl );
	}

	if( rt_isect_line3_plane( &dist , to_pt , extrude_dir , pl , &mged_tol ) < 1 )
	{
		(void)printf( "Cannot extrude parallel to plane of loop\n" );
		return CMD_BAD;
	}

	s = lu->up.s_p;
	
	if( RT_LIST_NON_EMPTY( &s->fu_hd ) )
	{
		long *trans_tbl;
		struct loopuse *new_lu;

		/* make a new shell to hold the extruded solid */

		r = RT_LIST_FIRST( nmgregion , &m->r_hd );
		NMG_CK_REGION( r );
		s = nmg_msv( r );

		/* copy the loop to the new shell */
		trans_tbl = (long *)rt_calloc( 2*m->maxindex , sizeof( long ) , "Dextrude: trans_tbl" );
		new_lu = nmg_dup_loop( lu , &s->l.magic , &trans_tbl );
		rt_free( (char *)trans_tbl , "Dextrude: trans_tbl" );
		if( nmg_klu( lu ) )
		{
			/* this should never happen */
			rt_bomb( "Killed wire loop emptied shell with faces!!!!\n" );
		}

		lu = new_lu;
		nmg_loop_g( lu->l_p , &mged_tol );
	}

	fu = nmg_mf( lu );
	NMG_CK_FACEUSE( fu );
	nmg_face_g( fu , pl );

	VSCALE( extrude_vec , extrude_dir , extrude_dist )

	(void)nmg_extrude_face( fu , extrude_vec , &mged_tol );
	nmg_fix_normals( fu->s_p , &mged_tol );
	nmg_rebound( m , &mged_tol );

	es_eu = (struct edgeuse *)NULL;

	replot_editing_solid();
	dmaflag = 1;

	

@


10.63
log
@Added NMG split edge capability.
@
text
@d9 1
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.62 94/11/16 16:59:00 jra Exp Locker: jra $ (BRL)";
d70 2
d284 1
d803 1
d810 1
a2104 1
	case ECMD_NMG_EMOVE:
d2107 3
d2111 131
d2247 2
d2265 1
a2265 1
				return;
d2268 1
a2268 1
				return;
d2270 36
a2505 1
	/* XXX Should just leave desired location in es_mparam for sedit() */
d2507 1
a2507 1
		/* move edge, through indicated point */
d2510 1
a2510 9
		MAT4X3PNT( pos_model, es_invmat, temp );
		if( nmg_move_edge_thru_pt( es_eu, pos_model, &mged_tol ) < 0 ) {
			VPRINT("Unable to hit", pos_model);
		}
		sedraw = 1;
		return;

	case ECMD_NMG_ESPLIT:
		MAT4X3PNT( es_mparam , view2model, mousevec );
d3490 1
d4286 153
@


10.62
log
@Fixed get_solid_keypoint to handle NMG's with no faces.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.61 94/11/15 14:58:18 jra Exp Locker: jra $ (BRL)";
a98 9
/* XXX This belongs in sedit.h */
#define ECMD_VTRANS		17	/* vertex translate */
#define ECMD_NMG_EPICK		19	/* edge pick */
#define ECMD_NMG_EMOVE		20	/* edge move */
#define ECMD_NMG_EDEBUG		21	/* edge debug */
#define ECMD_NMG_FORW		22	/* next eu */
#define ECMD_NMG_BACK		23	/* prev eu */
#define ECMD_NMG_RADIAL		24	/* radial+mate eu */

d280 1
d798 1
d814 6
a819 4
			/* get space for list of items processed */
			tab = (long *)rt_calloc( m->maxindex+1, sizeof(long),
				"nmg_ed tab[]");
			vbp = rt_vlblock_init();
d821 2
a822 2
			nmg_vlblock_around_eu(vbp, es_eu, tab, 1, &mged_tol);
			cvt_vlblock_to_solids( vbp, "_EU_", 0 );	/* swipe vlist */
d824 3
a826 2
			rt_vlblock_free(vbp);
			rt_free( (char *)tab, "nmg_ed tab[]" );
a863 1

d2103 32
d2341 6
d3321 1
@


10.61
log
@Added statements to reset es_eu to NULL.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.60 94/11/10 12:06:08 jra Exp Locker: jra $ (BRL)";
d1261 3
d1269 3
d1277 4
a1280 1
			fu = RT_LIST_FIRST( faceuse , &s->fu_hd );
d1306 4
a1309 1
			lu = RT_LIST_FIRST( loopuse , &s->lu_hd );
d1333 4
a1336 1
			eu = RT_LIST_FIRST( edgeuse , &s->eu_hd );
@


10.60
log
@Irix 6.0.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.59 94/10/11 09:31:03 jra Exp Locker: mike $ (BRL)";
d1469 1
a1469 1
	es_eu = (struct edgeuse *)NULL;
d1854 1
d1875 1
d1897 1
d1987 1
d2005 1
d3179 2
d3212 2
@


10.59
log
@Added a missing break and fixed an error in use of strcmp.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.58 94/10/05 16:40:32 jra Exp Locker: jra $ (BRL)";
d997 11
d1400 1
a1400 1
	register int i, type, p1, p2, p3;
a1494 3
	int			id;
	struct rt_external	ext;
	struct rt_db_internal	intern;
a1495 1
	struct directory	*dp;
d1497 1
a1497 1
	dp = illump->s_path[illump->s_last];
a1516 2
	struct directory	*dp;

d1526 2
a1645 1
	register dbfloat_t *op;
d1902 1
a1902 1
			/* XXX for now, splines only here */
a2397 1
	struct rt_external	ext;
a2398 2
	struct solidrec		sol;
	mat_t			ident;
a2420 1
	register dbfloat_t *op;
a2421 1
	static fastf_t mr1,mr2;
a2601 1
			fastf_t	newrad;
a2649 1
			fastf_t	newrad;
a2665 1
			fastf_t	newrad;
a2697 1
			fastf_t	newrad;
a2714 1
			fastf_t	newrad;
a2747 1
			fastf_t	newrad;
a2764 1
			fastf_t	newrad;
a2781 1
			fastf_t	newrad;
a2987 2
	register int		i;
	register int		type;
a3170 1
	int	id;
@


10.58
log
@Added input checking to rt_arb_calc_planes.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/edsol.c,v 10.57 94/10/05 16:23:48 jra Exp Locker: jra $ (BRL)";
d907 1
a907 1
			if( strcmp( cp , "V" ) )
d912 1
a912 1
			else if( strcmp( cp , "H" ) )
d922 1
@


10.57
log
@Recalculation at end of sedit was assuming rt_arb_internal *arb was set,
it wasn't always, so I added code to set it.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.56 94/09/26 10:21:59 jra Exp Locker: jra $ (BRL)";
d3755 3
@


10.56
log
@Added ID_PART, ID_PIPE, and ID_ARBN to get_solid_keypoint, added complaint to default case.
Changed check in sedit from GENARB8 to ID_ARB8 for recalculation of plane eqns.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.55 94/09/23 16:38:24 jra Exp Locker: jra $ (BRL)";
d2087 4
d2092 1
@


10.55
log
@Added ARB8, VOL, EBM, and HALF to get_solid_keypoint.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.54 94/09/02 15:56:10 jra Exp Locker: jra $ (BRL)";
d47 1
d900 83
d1336 1
d2086 1
a2086 1
	if( es_int.idb_type == GENARB8 )
@


10.54
log
@Removed all blocks of code that didn't use the "new way".
Added more solid cases to get_solid_keypoint.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.53 94/09/01 16:36:13 jra Exp Locker: jra $ (BRL)";
d899 59
d959 1
a969 6

/* XXXX Does this really make sense???  A, B, and C are vectors, not points.
 * Would someone really want to rotate this solid about a point
 * that happens to have the same coordinates as one of these
 * vectors??	-JRA
 */
d971 1
a971 1
				VMOVE( mpt, ell->a );
d976 1
a976 1
				VMOVE( mpt, ell->b );
d981 1
a981 1
				VMOVE( mpt, ell->c );
d1007 1
@


10.53
log
@Checkpoint in conversion to import/export use.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.52 94/08/31 17:07:51 jra Exp Locker: jra $ (BRL)";
a55 2
static int	new_way = 1;	/* Set 1 for import/export handling */

d75 1
a75 1
union record es_rec;		/* current solid record */
d910 6
d1030 62
d1094 7
d1104 91
a1194 1
			/* XXX Fall through, for now */
d1277 1
a1277 1
	if( new_way )
d1279 1
a1279 3
		if( id == ID_ARB8 )
		{
			struct rt_arb_internal *arb;
d1281 2
a1282 2
			arb = (struct rt_arb_internal *)es_int.idb_ptr;
			RT_ARB_CK_MAGIC( arb );
d1284 8
a1291 9
			type = rt_arb_std_type( &es_int , &mged_tol );
			es_type = type;
			if( rt_arb_calc_planes( es_peqn , arb , es_type , &mged_tol ) )
			{
				(void) printf( "Cannot calculate plane equations for ARB8\n" );
				db_free_external( &es_ext );
				rt_functab[id].ft_ifree( &es_int );
				return;
			}
d1294 1
a1294 1
	else
d1296 9
a1304 45
		bcopy( (char *)es_ext.ext_buf, (char *)&es_rec, sizeof(es_rec) );

		if( es_rec.u_id == ID_SOLID )  {
			struct solidrec temprec;	/* copy of solid to determine type */

			temprec = es_rec.s;		/* struct copy */
			VMOVE( es_keypoint, es_rec.s.s_values );
			es_keyfixed = 0;

			if( (type = es_rec.s.s_cgtype) < 0 )
				type *= -1;
			if(type == BOX || type == RPP)
				type = ARB8;
			if(type == RAW) {
				/* rearrange vectors to correspond to the
				 *  	"standard" ARB6
				 */
				register struct solidrec *trp = &temprec;
				VMOVE(&trp->s_values[3], &es_rec.s.s_values[9]);
				VMOVE(&trp->s_values[6], &es_rec.s.s_values[21]);
				VMOVE(&trp->s_values[9], &es_rec.s.s_values[12]);
				VMOVE(&trp->s_values[12], &es_rec.s.s_values[3]);
				VMOVE(&trp->s_values[15], &es_rec.s.s_values[6]);
				VMOVE(&trp->s_values[18], &es_rec.s.s_values[18]);
				VMOVE(&trp->s_values[21], &es_rec.s.s_values[15]);
				es_rec.s = *trp;	/* struct copy */
				type = ARB6;
			}
			es_rec.s.s_cgtype = type;

			if( es_rec.s.s_type == GENARB8 ) {
				/* find the comgeom arb type */
				if( (type = type_arb( &es_rec )) == 0 ) {
					(void)printf("%s: BAD ARB\n",es_rec.s.s_name);
					return;
				}

				temprec = es_rec.s;
				es_rec.s.s_cgtype = type;
				es_type = type;	/* !!! Needed for facedef.c */

				/* find the plane equations */
				calc_planes( &es_rec.s, type );
			}
		}
a1305 18
#if 1
	/* Experimental, but working. */
	switch( id )  {
	case ID_ARB8:
	case ID_ELL:
	case ID_EHY:
	case ID_EPA:
	case ID_RPC:
	case ID_RHC:
	case ID_TGC:
	case ID_TOR:
	case ID_ETO:
	case ID_BSPLINE:
	case ID_NMG:
	case ID_GRIP:
	case ID_ARS:
		rt_log("Experimental:  new_way=1\n");
		new_way = 1;
a1306 18
	}
	switch( id )  {
	case ID_BSPLINE:
		{
			register struct rt_nurb_internal *sip =
				(struct rt_nurb_internal *) es_int.idb_ptr;
			register struct snurb	*surf;
			RT_NURB_CK_MAGIC(sip);
			spl_surfno = sip->nsrf/2;
			surf = sip->srfs[spl_surfno];
			NMG_CK_SNURB(surf);
			spl_ui = surf->s_size[1]/2;
			spl_vi = surf->s_size[0]/2;
		}
		break;
	}
#endif

d1338 1
a1338 1
 *  making a change to es_rec or es_mat.
d1351 1
a1351 23
	if( new_way )  {
		ip = &es_int;
	} else {
		/* Fake up an external representation */
		RT_INIT_EXTERNAL( &ext );
		ext.ext_buf = (genptr_t)&es_rec;
		ext.ext_nbytes = sizeof(union record);

		if( (id = rt_id_solid( &ext )) == ID_NULL )  {
			(void)printf("replot_editing_solid() unable to identify type of solid %s\n",
				dp->d_namep );
			return;
		}

	    	RT_INIT_DB_INTERNAL(&intern);
		if( rt_functab[id].ft_import( &intern, &ext, rt_identity ) < 0 )  {
			rt_log("%s:  solid import failure\n",
				dp->d_namep );
		    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
		    	return;			/* ERROR */
		}
		ip = &intern;
	}
a1355 3
	if( !new_way )  {
	    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
	}
d1704 2
a1705 4
		if(inpara) {
			/* accumulate the scale factor */
			es_scale = es_para[0] / acc_sc_sol;
			acc_sc_sol = es_para[0];
d1707 6
a1712 3
		}
		if( new_way )  {
			mat_t	scalemat;
d1715 3
a1717 5
		} else {
			for(i=3; i<=21; i+=3) { 
				op = &es_rec.s.s_values[i];
				VSCALE(op,op,es_scale);
			}
a1718 2
		/* reset solid scale factor */
		es_scale = 1.0;
d1723 3
a1725 11
		if(inpara) {
			/* Keyboard parameter.
			 * Apply inverse of es_mat to these
			 * model coordinates first, because sedit_mouse()
			 * has already applied es_mat to them.
			 * XXX this does not make sense.
			 */
			MAT4X3PNT( work, es_invmat, es_para );
			if( new_way )  {
				vect_t	delta;
				mat_t	xlatemat;
d1727 9
a1742 2
			} else {
				VMOVE(es_rec.s.s_values, work);
d1774 1
a1774 1
		if( new_way )  {
d1777 1
a1810 5
		} else {
		if( inpara ) {
			/* apply es_invmat to convert to real model coordinates */
			MAT4X3PNT( work, es_invmat, es_para );
			VSUB2(&es_rec.s.s_tgc_H, work, &es_rec.s.s_tgc_V);
a1811 36

		/* check for zero H vector */
		if( MAGNITUDE( &es_rec.s.s_tgc_H ) == 0.0 ) {
			(void)printf("Zero H vector not allowed, resetting to +Z\n");
			VSET( &es_rec.s.s_tgc_H, 0, 0, 1 );
			break;
		}

		/* have new height vector --  redefine rest of tgc */
		la = MAGNITUDE( &es_rec.s.s_tgc_A );
		lb = MAGNITUDE( &es_rec.s.s_tgc_B );
		lc = MAGNITUDE( &es_rec.s.s_tgc_C );
		ld = MAGNITUDE( &es_rec.s.s_tgc_D );

		/* find 2 perpendicular vectors normal to H for new A,B */
		j=0;
		for(i=0; i<3; i++) {
			work[i] = 0.0;
			if( fabs(es_rec.s.s_values[i+3]) < 
			    fabs(es_rec.s.s_values[j+3]) )
				j = i;
		}
		work[j] = 1.0;
		VCROSS(&es_rec.s.s_tgc_B, work, &es_rec.s.s_tgc_H);
		VCROSS(&es_rec.s.s_tgc_A, &es_rec.s.s_tgc_B, &es_rec.s.s_tgc_H);
		VUNITIZE(&es_rec.s.s_tgc_A);
		VUNITIZE(&es_rec.s.s_tgc_B);

		/* Create new C,D from unit length A,B, with previous len */
		VSCALE(&es_rec.s.s_tgc_C, &es_rec.s.s_tgc_A, lc);
		VSCALE(&es_rec.s.s_tgc_D, &es_rec.s.s_tgc_B, ld);

		/* Restore original vector lengths to A,B */
		VSCALE(&es_rec.s.s_tgc_A, &es_rec.s.s_tgc_A, la);
		VSCALE(&es_rec.s.s_tgc_B, &es_rec.s.s_tgc_B, lb);
		}
d1816 1
a1816 1
		if( new_way )  {
d1819 1
a1832 5
		} else {
		if( inpara ) {
			/* apply es_invmat to convert to real model coordinates */
			MAT4X3PNT( work, es_invmat, es_para );
			VSUB2(&es_rec.s.s_tgc_H, work, &es_rec.s.s_tgc_V);
a1833 8

		/* check for zero H vector */
		if( MAGNITUDE( &es_rec.s.s_tgc_H ) == 0.0 ) {
			(void)printf("Zero H vector not allowed, resetting to +Z\n");
			VSET( &es_rec.s.s_tgc_H, 0, 0, 1 );
			break;
		}
		}
d1851 2
a1852 8
		if(inpara) {
			static mat_t invsolr;
			/*
			 * Keyboard parameters:  absolute x,y,z rotations,
			 * in degrees.  First, cancel any existing rotations,
			 * then perform new rotation
			 */
			mat_inv( invsolr, acc_rot_sol );
d1854 8
a1861 9
			/* Build completely new rotation change */
			mat_idn( modelchanges );
			buildHrot( modelchanges,
				es_para[0] * degtorad,
				es_para[1] * degtorad,
				es_para[2] * degtorad );
			/* Borrow incr_change matrix here */
			mat_mul( incr_change, modelchanges, invsolr );
			mat_copy(acc_rot_sol, modelchanges);
d1863 17
a1879 9
			/* Apply new rotation to solid */
			/*  Clear out solid rotation */
			mat_idn( modelchanges );
		}  else  {
			/* Apply incremental changes already in incr_change */
		}
		/* Apply changes to solid */
		if( new_way )  {
			mat_t	mat;
d1883 2
a1884 6
		} else {
			for(i=1; i<8; i++) {
				op = &es_rec.s.s_values[i*3];
				VMOVE( work, op );
				MAT4X3VEC( op, incr_change, work );
			}
a1885 1
		mat_idn( incr_change );
d1890 1
a1890 1
		if( new_way )  {
d1893 1
d1897 2
a1898 3
		} else {
			MAT4X3VEC(work, incr_change, &es_rec.s.s_tgc_H);
			VMOVE(&es_rec.s.s_tgc_H, work);
a1899 1
		mat_idn( incr_change );
d1904 1
a1904 1
		if( new_way )  {
d1907 1
d1918 2
a1919 6
		} else {
			for(i=2; i<6; i++) {
				op = &es_rec.s.s_values[i*3];
				MAT4X3VEC( work, incr_change, op );
				VMOVE( op, work );
			}
a1920 1
		mat_idn( incr_change );
d1950 2
a1951 5
	if( new_way )  {
		if (! es_keyfixed) {
			get_solid_keypoint( es_keypoint, &es_keytag, &es_int, es_mat );
		}
	}
d2006 1
a2006 1
		if( new_way )  {
a2024 8
		} else {
			/* XXX this makes bad assumptions about format of es_rec !! */
			MAT4X3PNT( temp, es_mat, es_rec.s.s_values );
			MAT4X3PNT( pos_view, model2view, temp );
			pos_view[X] = mousevec[X];
			pos_view[Y] = mousevec[Y];
			MAT4X3PNT( temp, view2model, pos_view );
			MAT4X3PNT( es_rec.s.s_values, es_invmat, temp );
d2049 1
a2049 1
		if( new_way )  {
a2062 10
		} else {
			VADD2( temp, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_H );
			MAT4X3PNT(pos_model, es_mat, temp);
			MAT4X3PNT( pos_view, model2view, pos_model );
			pos_view[X] = mousevec[X];
			pos_view[Y] = mousevec[Y];
			/* Do NOT change pos_view[Z] ! */
			MAT4X3PNT( temp, view2model, pos_view );
			MAT4X3PNT( tr_temp, es_invmat, temp );
			VSUB2( &es_rec.s.s_tgc_H, tr_temp, &es_rec.s.s_tgc_V );
a2068 1
		if( new_way )
a2075 2
		else
			VADD2(temp, es_rec.s.s_values, &es_rec.s.s_values[es_menu*3]);
a2100 1
		if( new_way )
a2107 2
		else
			calc_pnts( &es_rec.s, es_rec.s.s_cgtype );
d2279 1
a2279 1
		if( new_way )  {
a2288 8
		} else {
			op = &es_rec.s.s_tgc_H;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
d2294 1
a2294 1
		if( new_way )  {
a2308 37
		} else {
			mr2 = MAGNITUDE(&es_rec.s.s_tor_H);
			op = &es_rec.s.s_tor_B;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);

			op = &es_rec.s.s_tor_A;
			VSCALE(op, op, es_scale);
			mr1 = MAGNITUDE(op);
			if( mr1 < mr2 ) {
				VSCALE(op, op, (mr2+0.01)/mr1);
				op = &es_rec.s.s_tor_B;
				VSCALE(op, op, (mr2+0.01)/mr1);
				mr1 = MAGNITUDE(op);
			}
torcom:
			ma = mr1 - mr2;
			op = &es_rec.s.s_tor_C;
			mb = MAGNITUDE(op);
			VSCALE(op, op, ma/mb);

			op = &es_rec.s.s_tor_D;
			mb = MAGNITUDE(op);
			VSCALE(op, op, ma/mb);

			ma = mr1 + mr2;
			op = &es_rec.s.s_tor_E;
			mb = MAGNITUDE(op);
			VSCALE(op, op, ma/mb);

			op = &es_rec.s.s_tor_F;
			mb = MAGNITUDE(op);
			VSCALE(op, op, ma/mb);
d2314 1
a2314 1
		if( new_way )  {
a2328 15
		} else {
			op = &es_rec.s.s_values[3];
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
			mr2 = MAGNITUDE(op);
			mr1 = MAGNITUDE(&es_rec.s.s_values[6]);
			if(mr1 < mr2) {
				VSCALE(op, op, (mr1-0.01)/mr2);
				mr2 = MAGNITUDE(op);
			}
			goto torcom;
a2333 1
		/* new_way only */
a2363 1
		/* new_way only */
d2656 1
a2656 1
		if( new_way )  {
a2666 8
		} else {
			op = &es_rec.s.s_tgc_A;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
d2672 1
a2672 1
		if( new_way )  {
a2682 8
		} else {
			op = &es_rec.s.s_tgc_B;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
d2688 1
a2688 1
		if( new_way )  {
a2697 8
		} else {
			op = &es_rec.s.s_ell_A;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
d2703 1
a2703 1
		if( new_way )  {
a2712 8
		} else {
			op = &es_rec.s.s_ell_B;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
d2718 1
a2718 1
		if( new_way )  {
a2727 8
		} else {
			op = &es_rec.s.s_ell_C;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
d2733 1
a2733 1
		if( new_way )  {
a2743 8
		} else {
			op = &es_rec.s.s_tgc_C;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
d2748 1
a2748 1
		if( new_way )  {
a2758 8
		} else {
			op = &es_rec.s.s_tgc_D;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
d2763 1
a2763 1
		if( new_way )  {
a2776 12
		} else {
			op = &es_rec.s.s_tgc_A;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
			ma = MAGNITUDE( op );
			op = &es_rec.s.s_tgc_B;
			mb = MAGNITUDE( op );
			VSCALE(op, op, ma/mb);
d2781 1
a2781 1
		if( new_way )  {
a2794 12
		} else {
			op = &es_rec.s.s_tgc_C;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
			ma = MAGNITUDE( op );
			op = &es_rec.s.s_tgc_D;
			mb = MAGNITUDE( op );
			VSCALE(op, op, ma/mb);
d2799 1
a2799 1
		if( new_way )  {
a2816 18
		} else {
			op = &es_rec.s.s_tgc_A;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
			ma = MAGNITUDE( op );
			op = &es_rec.s.s_tgc_B;
			mb = MAGNITUDE( op );
			VSCALE(op, op, ma/mb);
			op = &es_rec.s.s_tgc_C;
			mb = MAGNITUDE( op );
			VSCALE(op, op, ma/mb);
			op = &es_rec.s.s_tgc_D;
			mb = MAGNITUDE( op );
			VSCALE(op, op, ma/mb);
d2821 1
a2821 1
		if( new_way )  {
a2835 15
		} else {
			op = &es_rec.s.s_ell_A;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
			ma = MAGNITUDE( op );
			op = &es_rec.s.s_ell_B;
			mb = MAGNITUDE( op );
			VSCALE(op, op, ma/mb);
			op = &es_rec.s.s_ell_C;
			mb = MAGNITUDE( op );
			VSCALE(op, op, ma/mb);
d2852 1
d2890 1
a2890 7
	if( new_way )
	{
		char *strp="";
		get_solid_keypoint( es_keypoint , &strp , &es_int , es_mat );
	}
	else
	{
a2891 63
	/* XXX hack:  get first granule into es_rec (ugh) */
	bcopy( (char *)es_ext.ext_buf, (char *)&es_rec, sizeof(es_rec) );

	/* Find the keypoint for editing */
	id = rt_id_solid( &es_ext );
	switch( id )  {
	case ID_NULL:
		(void)printf("init_objedit(%s): bad database record\n",
			illump->s_path[illump->s_last]->d_namep );
		button(BE_REJECT);
		db_free_external( &es_ext );
		return;

	case ID_ARS_A:
		{
			register union record *rec =
				(union record *)es_ext.ext_buf;

			/* XXX should import the ARS! */

			/* only interested in vertex */
			VMOVE(es_keypoint, rec[1].b.b_values);
			es_rec.s.s_type = ARS;		/* XXX wrong */
			es_rec.s.s_cgtype = ARS;
		}
		break;

	case ID_TOR:
	case ID_TGC:
	case ID_ELL:
	case ID_ARB8:
	case ID_HALF:
	case ID_RPC:
	case ID_RHC:
	case ID_EHY:
	case ID_EPA:
	case ID_ETO:
		/* All folks with u_id == (DB_)ID_SOLID */
		if( es_rec.s.s_cgtype < 0 )
			es_rec.s.s_cgtype *= -1;

		if( es_rec.s.s_type == GENARB8 ) {
			/* find the comgeom arb type */
			if( (type = type_arb( &es_rec )) == 0 ) {
				(void)printf("%s: BAD ARB\n",es_rec.s.s_name);
				return;
			}
			es_rec.s.s_cgtype = type;
		}
		VMOVE( es_keypoint, es_rec.s.s_values );
		break;

	case ID_EBM:
		/* Use model origin as key point */
		VSETALL(es_keypoint, 0 );
		break;

	default:
		VMOVE(es_keypoint, illump->s_center);
		printf("init_objedit() using %g,%g,%g as keypoint\n",
			V3ARGS(es_keypoint) );
	}
	}
a2896 4

	/* XXX Zap out es_rec, nobody should look there any further */
	if( !new_way )
		bzero( (char *)&es_rec, sizeof(es_rec) );
d2994 2
a2995 1
	if( new_way )
a2996 9
		if( es_int.idb_type != ID_ARB8 )
		{
			(void)printf("Eqn: type must be GENARB8\n");
			return CMD_BAD;
		}
	}
	else
	{
	if( es_rec.s.s_type != GENARB8 ){
d3000 1
a3000 1
	}
d3014 4
a3017 20
	if( new_way )
	{
		VMOVE( tempvec , arb->pt[fixv] );
		es_peqn[es_menu][3]=VDOT( es_peqn[es_menu], tempvec );
		if( rt_arb_calc_points( arb , es_type , es_peqn , &mged_tol ) )
			return CMD_BAD;
	}
	else
	{
	/* set D of planar equation to anchor at fixed vertex */
	if( fixv ){				/* not the solid vertex */
		VADD2( tempvec, &es_rec.s.s_values[fixv*3], &es_rec.s.s_values[0] );
	}
	else{
		VMOVE( tempvec, &es_rec.s.s_values[0] );
	}
	es_peqn[es_menu][3]=VDOT( &es_peqn[es_menu][0], tempvec );
	
	calc_pnts( &es_rec.s, es_rec.s.s_cgtype );
	}
d3040 4
a3043 10
	if( !new_way )  {
		db_put( dbip, dp, &es_rec, 0, 1 );
	} else {
		/* Scale change on export is 1.0 -- no change */
		if( rt_functab[es_int.idb_type].ft_export( &es_ext, &es_int, 1.0 ) < 0 )  {
			rt_log("sedit_accept(%s):  solid export failure\n", dp->d_namep);
		    	if( es_int.idb_ptr )  rt_functab[es_int.idb_type].ft_ifree( &es_int );
			db_free_external( &es_ext );
			return;				/* FAIL */
		}
d3045 4
d3050 4
a3053 5
		if( db_put_external( &es_ext, dp, dbip ) < 0 )  {
			db_free_external( &es_ext );
			ERROR_RECOVERY_SUGGESTION;
			WRITE_ERR_return;
		}
a3058 1
/*	new_way = 0;	*/
a3075 1
/*	new_way = 0;	*/
d3169 1
a3169 1
	sedit();	/* change es_rec only, NOW */
a3213 1
	union record	temp_rec;	/* copy of es_rec record */
a3231 1
		if( new_way )
a3278 17
		else
		{
		MAT4X3PNT( pos_view, xform, es_rec.s.s_values );
		POINT_LABEL( pos_view, '1' );
		temp_rec.s = es_rec.s;
		if(es_type == ARB4) {
			VMOVE(&temp_rec.s.s_values[9], &temp_rec.s.s_values[12]);
		}
		if(es_type == ARB6) {
			VMOVE(&temp_rec.s.s_values[15], &temp_rec.s.s_values[18]);
		}
		for(i=1; i<es_type; i++) {
			VADD2( work, es_rec.s.s_values, &temp_rec.s.s_values[i*3] );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, i + '1' );
		}
		}
d3281 1
a3281 1
		if( new_way )  {
a3302 19
		} else {
		MAT4X3PNT( pos_view, xform, &es_rec.s.s_tgc_V );
		POINT_LABEL( pos_view, 'V' );

		VADD2( work, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_A );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'A' );

		VADD2( work, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_B );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'B' );

		VADD3( work, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_H, &es_rec.s.s_tgc_C );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'C' );

		VADD3( work, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_H, &es_rec.s.s_tgc_D );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'D' );
d3307 1
a3307 1
		if( new_way )  {
a3327 15
		} else {
		MAT4X3PNT( pos_view, xform, &es_rec.s.s_ell_V );
		POINT_LABEL( pos_view, 'V' );

		VADD2( work, &es_rec.s.s_ell_V, &es_rec.s.s_ell_A );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'A' );

		VADD2( work, &es_rec.s.s_ell_V, &es_rec.s.s_ell_B );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'B' );

		VADD2( work, &es_rec.s.s_ell_V, &es_rec.s.s_ell_C );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'C' );
d3332 1
a3332 1
		if( new_way )  {
a3357 15
		} else {
		MAT4X3PNT( pos_view, xform, &es_rec.s.s_tor_V );
		POINT_LABEL( pos_view, 'V' );

		VADD2( work, &es_rec.s.s_tor_V, &es_rec.s.s_tor_C );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'I' );

		VADD2( work, &es_rec.s.s_tor_V, &es_rec.s.s_tor_E );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'O' );

		VADD3( work, &es_rec.s.s_tor_V, &es_rec.s.s_tor_A, &es_rec.s.s_tor_H);
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'H' );
a3487 1
		/* new_way only */
a3527 1
		if( new_way )
a3535 4
		else
		{
			MAT4X3PNT(pos_view, xform, es_rec.s.s_values)
		}
a3539 1
		/* New way only */
@


10.52
log
@Checkpoint (conversion to using import/export).
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.51 94/08/30 16:47:06 jra Exp Locker: jra $ (BRL)";
d1016 10
d1197 1
d1483 2
d1496 1
d1557 1
d2096 1
d2127 10
a2136 1
		calc_pnts( &es_rec.s, es_rec.s.s_cgtype );
d3093 8
d3163 1
a3163 1

d3171 2
a3172 1
	bzero( (char *)&es_rec, sizeof(es_rec) );
d3264 1
d3270 11
a3280 1
	else if( es_rec.s.s_type != GENARB8 ){
d3284 2
a3285 1
	else if( es_edflag != ECMD_ARB_ROTATE_FACE ){
d3290 3
d3298 9
d3317 1
d3902 13
a3914 1
		MAT4X3PNT(pos_view, xform, es_rec.s.s_values);
@


10.51
log
@Checkpoint (converting to using es_int rather than es_rec).
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.50 94/08/27 03:02:03 mike Exp Locker: jra $ (BRL)";
d56 1
a56 1
static int	new_way = 0;	/* Set 1 for import/export handling */
d1104 5
a1108 2
	new_way = 0;
	bcopy( (char *)es_ext.ext_buf, (char *)&es_rec, sizeof(es_rec) );
d1110 2
a1111 2
	if( es_rec.u_id == ID_SOLID )  {
		struct solidrec temprec;	/* copy of solid to determine type */
d1113 9
a1121 22
		temprec = es_rec.s;		/* struct copy */
		VMOVE( es_keypoint, es_rec.s.s_values );
		es_keyfixed = 0;

		if( (type = es_rec.s.s_cgtype) < 0 )
			type *= -1;
		if(type == BOX || type == RPP)
			type = ARB8;
		if(type == RAW) {
			/* rearrange vectors to correspond to the
			 *  	"standard" ARB6
			 */
			register struct solidrec *trp = &temprec;
			VMOVE(&trp->s_values[3], &es_rec.s.s_values[9]);
			VMOVE(&trp->s_values[6], &es_rec.s.s_values[21]);
			VMOVE(&trp->s_values[9], &es_rec.s.s_values[12]);
			VMOVE(&trp->s_values[12], &es_rec.s.s_values[3]);
			VMOVE(&trp->s_values[15], &es_rec.s.s_values[6]);
			VMOVE(&trp->s_values[18], &es_rec.s.s_values[18]);
			VMOVE(&trp->s_values[21], &es_rec.s.s_values[15]);
			es_rec.s = *trp;	/* struct copy */
			type = ARB6;
d1123 4
a1126 1
		es_rec.s.s_cgtype = type;
d1128 25
a1152 5
		if( es_rec.s.s_type == GENARB8 ) {
			/* find the comgeom arb type */
			if( (type = type_arb( &es_rec )) == 0 ) {
				(void)printf("%s: BAD ARB\n",es_rec.s.s_name);
				return;
a1153 2

			temprec = es_rec.s;
a1154 1
			es_type = type;	/* !!! Needed for facedef.c */
d1156 14
a1169 2
			/* find the plane equations */
			calc_planes( &es_rec.s, type );
d1175 1
a1477 1
			new_way = 1;
a1481 1
		new_way = 1;
a1542 1
		new_way = 1;
a1970 1
	struct rt_arb_internal *arb;
d2077 9
a2085 1
		VADD2(temp, es_rec.s.s_values, &es_rec.s.s_values[es_menu*3]);
d3303 1
a3303 1
	new_way = 0;
d3321 1
a3321 1
	new_way = 0;
@


10.50
log
@Now compiles with new NURB header.

@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.49 94/08/09 15:06:31 gdurf Exp Locker: mike $ (BRL)";
d1402 1
d1448 1
d1454 2
a1455 1
			calc_pnts( &es_rec.s, es_rec.s.s_cgtype );
d1460 3
d1466 1
a1466 1
			if( arb_vertices[es_rec.s.s_cgtype-4][es_menu*4+i]==5 )
d1471 1
a1471 1
		if( es_rec.s.s_cgtype == ARB7  && pnt5 ){
d1482 1
a1482 1
				type = es_rec.s.s_cgtype - 4;
d1508 1
a1508 1
			} while( fixv <= 0 || fixv > es_rec.s.s_cgtype );
d1520 4
d1570 1
a1570 6
			if( fixv ){		/* special case for solid vertex */
				VADD2(tempvec, &es_rec.s.s_values[fixv*3], &es_rec.s.s_values[0] );
			}
			else{
				VMOVE( tempvec, &es_rec.s.s_values[fixv] );
			}
d1588 1
a1588 6
			if( fixv ){		/* special case for solid vertex */
				VADD2(tempvec, &es_rec.s.s_values[fixv*3], &es_rec.s.s_values[0] );
			}
			else{
				VMOVE( tempvec, &es_rec.s.s_values[fixv] );
			}
d1595 1
a1595 1
		calc_pnts( &es_rec.s, es_rec.s.s_cgtype );
d1913 2
a1914 2
	if( es_rec.s.s_type == GENARB8 )
		calc_planes( &es_rec.s, es_rec.s.s_cgtype );
d1951 1
d3452 50
d3515 1
@


10.49
log
@Factored ifdefs
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.48 1994/06/22 18:24:35 gdurf Exp gdurf $ (BRL)";
d40 1
a46 1
#include "externs.h"
a52 9

/* From librt/nmg_info.c */
RT_EXTERN( struct edge *nmg_find_e_nearest_pt2, (long *magic_p,
			CONST point_t pt2, CONST mat_t mat,
			CONST struct rt_tol *tol) );

/* XXX Move to rtgeom.h? */
#define RT_NURB_GET_CONTROL_POINT(_s,_u,_v)	((_s)->ctl_points[ \
	((_v)*(_s)->s_size[1]+(_u))*RT_NURB_EXTRACT_COORDS((_s)->pt_type)])
@


10.48
log
@Removed superfluous return statement
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.47 1994/06/03 16:44:53 gdurf Exp gdurf $ (BRL)";
d29 2
d33 3
a35 1
#ifdef BSD
a36 2
#else
#include <string.h>
@


10.47
log
@replaced gets with fgets
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.46 1994/06/01 17:10:50 gdurf Exp gdurf $ (BRL)";
d3357 1
a3357 1

a3365 2

	return CMD_OK;
@


10.46
log
@Converted f_param to use new command return codes.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.45 1994/06/01 16:54:01 gdurf Exp gdurf $ (BRL)";
d1493 2
a1494 1
				(void)gets( line );		/* Null terminated */
@


10.45
log
@Converted f_keypoint to use new command return codes.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.44 1994/06/01 16:30:11 gdurf Exp gdurf $ (BRL)";
d3308 1
a3308 1
void
d3317 1
a3317 1
		return;
d3323 1
a3323 1
		return;
d3337 1
a3337 1
			return;
d3358 1
a3358 1
			return;
d3365 2
@


10.44
log
@Converted f_eqn to use new command return codes.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.43 94/03/16 19:53:59 cjohnson Exp Locker: mike $ (BRL)";
d4115 4
a4118 1
void f_keypoint (argc, argv)
d4125 1
a4125 1
	    return;
d4152 1
a4152 1
		break;
d4156 1
@


10.43
log
@Add grip editing.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.34 1994/03/14 20:29:35 cjohnson Exp $ (BRL)";
d834 1
a834 1
			nmg_vlblock_around_eu(vbp, es_eu, tab);
d3201 1
a3201 1
void
d3211 1
a3211 1
		return;
d3215 1
a3215 1
		return;
d3219 1
a3219 1
		return;
d3243 2
@


10.42
log
@Added "next", "prev", and "radial" items to NMG edgeuse debugging.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.41 94/02/23 03:22:39 mike Exp Locker: mike $ (BRL)";
d1014 9
d1170 1
a1200 1
printf("es_keypoint (%s) (%g, %g, %g)\n", es_keytag, V3ARGS(es_keypoint) );
a1619 1
		printf("%d: %s (%g, %g, %g)\n", __LINE__, es_keytag, V3ARGS(es_keypoint));
d1649 1
a1649 1
				VSUB2( delta, work, es_keypoint );
d1651 1
a1651 1
				MAT_DELTAS_VEC_NEG( xlatemat, delta );
d1924 2
a1925 5
		if (! es_keyfixed)
		{
		printf("%d %s (%g, %g, %g)\n", __LINE__, es_keytag, V3ARGS(es_keypoint));
		get_solid_keypoint( es_keypoint, &es_keytag, &es_int, es_mat );
		printf("%d %s (%g, %g, %g)\n", __LINE__, es_keytag, V3ARGS(es_keypoint));
@


10.41
log
@Added visualization of debugged edgeuses.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.40 94/02/23 02:48:12 pjt Exp Locker: mike $ (BRL)";
d112 3
d297 3
d846 31
@


10.40
log
@Added f_keypoint() routine
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.39 94/01/24 16:16:46 pjt Exp Locker: pjt $ (BRL)";
d815 23
@


10.39
log
@Corrected a call to rt_log() by init_object()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.38 94/01/13 19:02:30 mike Exp Locker: pjt $ (BRL)";
d94 1
d1050 1
d1551 1
d1856 3
d1860 2
d4047 39
@


10.38
log
@Improved commenting.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.37 94/01/12 17:27:49 mike Exp Locker: mike $ (BRL)";
d2965 1
a2965 1
		rt_log("init_sedit(%s):  solid import failure\n",
@


10.37
log
@NMG edge moving works!
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.36 94/01/12 02:46:34 mike Exp Locker: mike $ (BRL)";
d1867 2
d2027 2
a2028 1
			if( (e = nmg_find_e_nearest_pt2( &m->magic, mousevec, model2view, &mged_tol )) == (struct edge *)NULL )  {
a2038 1
#if 1
a2039 1
	/* JRA -- look here! */
a2049 1
#endif
@


10.36
log
@Added initial NMG "solid edit" capability.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.35 94/01/11 19:08:44 mike Exp Locker: mike $ (BRL)";
d1839 2
d2036 1
a2036 1
#if 0
d2044 1
a2044 1
		if( nmg_move_edge_thru_pt( es_eu, pos_model, mged_tol ) < 0 ) {
@


10.35
log
@Moved mat_scale_about_pt(), and mat_xform_about_pt() to librt/mat.c
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.34 94/01/10 16:09:01 mike Exp Locker: mike $ (BRL)";
a36 4
#define RT_NURB_GET_CONTROL_POINT(_s,_u,_v)	((_s)->ctl_points[ \
	((_v)*(_s)->s_size[1]+(_u))*RT_NURB_EXTRACT_COORDS((_s)->pt_type)])


d52 11
d66 1
d103 3
d107 4
a110 1
#define ECMD_VTRANS		17
d288 8
d778 1
d790 33
d953 7
d1131 2
d1274 3
d1330 3
d1838 3
d1865 6
d2015 34
a2048 1
		
d2053 5
d3253 8
a3260 7
		if( es_edflag == PSCALE || es_edflag == SSCALE )  {
			if(es_para[0] <= 0.0) {
				(void)printf("ERROR: SCALE FACTOR <= 0\n");
				inpara = 0;
				sedraw = 0;
				return;
			}
d3263 2
a3264 1
	/* check if need to convert to the base unit */
d3283 5
d3724 19
@


10.34
log
@Started support for solid edit of NMGs.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.33 93/11/10 04:08:40 cjohnson Exp Locker: mike $ (BRL)";
a139 59
/*
 *			M A T _ S C A L E _ A B O U T _ P T
 *
 *  Build a matrix to scale uniformly around a given point.
 *
 *  Returns -
 *	-1	if scale is too small.
 *	 0	if OK.
 */
int
mat_scale_about_pt( mat, pt, scale )
mat_t		mat;
CONST point_t	pt;
CONST double	scale;
{
	mat_t	xlate;
	mat_t	s;
	mat_t	tmp;

	mat_idn( xlate );
	MAT_DELTAS_VEC_NEG( xlate, pt );

	mat_idn( s );
	if( NEAR_ZERO( scale, SMALL ) )  {
		mat_zero( mat );
		return -1;			/* ERROR */
	}
	s[15] = 1/scale;

	mat_mul( tmp, s, xlate );

	MAT_DELTAS_VEC( xlate, pt );
	mat_mul( mat, xlate, tmp );
	return 0;				/* OK */
}

/*
 *			M A T _ X F O R M _ A B O U T _ P T
 *
 *  Build a matrix to apply arbitary 4x4 transformation around a given point.
 */
void
mat_xform_about_pt( mat, xform, pt )
mat_t		mat;
CONST mat_t	xform;
CONST point_t	pt;
{
	mat_t	xlate;
	mat_t	tmp;

	mat_idn( xlate );
	MAT_DELTAS_VEC_NEG( xlate, pt );

	mat_mul( tmp, xform, xlate );

	MAT_DELTAS_VEC( xlate, pt );
	mat_mul( mat, xlate, tmp );
}

a2024 2

#define EPSILON 1.0e-7
@


10.33
log
@Change to rt_functab[].ft_xform for new_way=1 transformations.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.32 1992/06/19 00:40:53 mike Exp cjohnson $ (BRL)";
d1094 1
d1159 1
a1159 1
		if( new_way )  {
d1197 1
a1197 1
struct rt_db_internal	*os;
d1199 1
a1199 1
struct rt_db_internal	*is;
d1203 2
a1204 1
	dp = illump->s_path[illump->s_last];
d1213 1
@


10.32
log
@Rudimentary spline editing now works, including interactive ctl point
picking.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.31 92/06/12 23:53:42 mike Exp Locker: mike $ (BRL)";
d1203 8
d1213 1
a3702 51

/*
 *			R T _ D B _ X F O R M _ I N T E R N A L
 *
 *  Apply a 4x4 transformation matrix to the internal form of a solid.
 *
 *  If "free" flag is non-zero, storage for the original solid is released.
 *  If "os" is same as "is", storage for the original solid is
 *  overwritten with the new, transformed solid.
 *
 * XXX This should be part of the import/export interface.
 * XXX Each solid should know how to transform it's internal representation.
 *
 *  Returns -
 *	-1	FAIL
 *	 0	OK
 */
int
rt_db_xform_internal(os, mat, is, free, name)
struct rt_db_internal	*os;
mat_t			mat;
struct rt_db_internal	*is;
int			free;
char			*name;
{
	struct rt_external	ext;
	int			id;

	RT_CK_DB_INTERNAL( is );
	id = is->idb_type;
	RT_INIT_EXTERNAL(&ext);
	/* Scale change on export is 1.0 -- no change */
	if( rt_functab[id].ft_export( &ext, is, 1.0 ) < 0 )  {
		rt_log("rt_db_xform_internal(%s):  %s export failure\n",
			name, rt_functab[id].ft_name);
		return -1;			/* FAIL */
	}
	if( (free || os == is) && is->idb_ptr )  {
		rt_functab[id].ft_ifree( is );
    		is->idb_ptr = (genptr_t)0;
    	}

	if( rt_functab[id].ft_import( os, &ext, mat ) < 0 )  {
		rt_log("rt_db_xform_internal(%s):  solid import failure\n",
			name);
		return -1;			/* FAIL */
	}
	RT_CK_DB_INTERNAL( os );
	return 0;				/* OK */
}

@


10.31
log
@Initial b-spline editing stuff.  Still experimental.
@
text
@d14 1
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.30 92/05/22 17:33:16 butler Exp Locker: mike $ (BRL)";
d37 4
d328 1
d815 5
d949 1
a949 1
			fp = &surf->ctl_points[(spl_vi*surf->s_size[1]+spl_ui)*RT_NURB_EXTRACT_COORDS(surf->pt_type)];
d1108 2
a1109 5
			spl_ui = surf->s_size[0]/2;
			spl_vi = surf->s_size[1]/2;
rt_log("Spline edit.  Surface %d, ctl point %d,%d out of %d,%d\n",
			spl_surfno, spl_ui, spl_vi,
			surf->s_size[0], surf->s_size[1] );
d1581 1
a1581 2
			fp = &surf->ctl_points[spl_vi*surf->s_size[1]+spl_ui];
			VPRINT("old ctl point value", fp);
a1582 1
			VPRINT("new ctl point value", fp);
a1911 2
VPRINT("keypoint_view", pos_view);
VPRINT("mousevec", mousevec);
a1913 1
VPRINT("'3d' mouse position", pos_view);
a1914 1
VPRINT("model mouse pos", temp);
d3299 4
a3629 1
			spl_surfno = sip->nsrf/2;
d3632 1
a3632 1
			fp = &surf->ctl_points[spl_vi*surf->s_size[1]+spl_ui];
d3635 13
d3748 2
a3749 2
sedit_vpick( pos )
point_t	pos;
d3751 242
@


10.30
log
@Re-ordered occurrence of subroutines so that functions are defined before
being used the first time.  Removes compiler warnings.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.29 92/04/23 10:53:14 mmark Exp Locker: butler $ (BRL)";
d39 1
d41 1
a73 1
fastf_t	es_para[3];		/* keyboard input parameter changes */
d82 11
d323 1
a323 1
	{ "not implemented", spline_ed, 1 },
d803 1
d809 3
a811 1
	(void)printf("NOT IMPLEMENTED YET\n");
d927 18
d1082 1
d1087 18
d1150 1
a1150 1
	if( new_way )  {
d1199 6
a1204 1
/* put up menu header */
d1535 2
a1536 1
			 * as already applied es_mat to them.
d1555 14
d1570 10
d1824 1
d1896 22
d3195 1
d3614 18
d3709 2
a3710 2
		rt_log("rt_db_xform_internal(%s):  solid export failure\n",
			name);
d3727 7
@


10.29
log
@fixed code for ETO "rotate C"
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.28 92/04/18 10:56:13 mmark Exp Locker: mmark $ (BRL)";
d800 155
d1196 39
a3512 155
/*
 *  Keypoint in model space is established in "pt".
 *  If "str" is set, then that point is used, else default
 *  for this solid is selected and set.
 *  "str" may be a constant string, in either upper or lower case,
 *  or it may be something complex like "(3,4)" for an ARS or spline
 *  to select a particular vertex or control point.
 *
 *  XXX Perhaps this should be done via solid-specific parse tables,
 *  so that solids could be pretty-printed & structprint/structparse
 *  processed as well?
 */
void
get_solid_keypoint( pt, strp, ip, mat )
point_t		pt;
char		**strp;
struct rt_db_internal	*ip;
mat_t		mat;
{
	char	*cp = *strp;
	point_t	mpt;

	RT_CK_DB_INTERNAL( ip );

	switch( ip->idb_type )  {
	case ID_ELL:
		{
			struct rt_ell_internal	*ell = 
				(struct rt_ell_internal *)ip->idb_ptr;
			RT_ELL_CK_MAGIC(ell);

			if( strcmp( cp, "V" ) == 0 )  {
				VMOVE( mpt, ell->v );
				*strp = "V";
				break;
			}
			if( strcmp( cp, "A" ) == 0 )  {
				VMOVE( mpt, ell->a );
				*strp = "A";
				break;
			}
			if( strcmp( cp, "B" ) == 0 )  {
				VMOVE( mpt, ell->b );
				*strp = "B";
				break;
			}
			if( strcmp( cp, "C" ) == 0 )  {
				VMOVE( mpt, ell->c );
				*strp = "C";
				break;
			}
			/* Default */
			VMOVE( mpt, ell->v );
			*strp = "V";
			break;
		}
	case ID_TOR:
		{
			struct rt_tor_internal	*tor = 
				(struct rt_tor_internal *)ip->idb_ptr;
			RT_TOR_CK_MAGIC(tor);

			if( strcmp( cp, "V" ) == 0 )  {
				VMOVE( mpt, tor->v );
				*strp = "V";
				break;
			}
			/* Default */
			VMOVE( mpt, tor->v );
			*strp = "V";
			break;
		}
	case ID_TGC:
		{
			struct rt_tgc_internal	*tgc = 
				(struct rt_tgc_internal *)ip->idb_ptr;
			RT_TGC_CK_MAGIC(tgc);

			if( strcmp( cp, "V" ) == 0 )  {
				VMOVE( mpt, tgc->v );
				*strp = "V";
				break;
			}
			if( strcmp( cp, "H" ) == 0 )  {
				VMOVE( mpt, tgc->h );
				*strp = "H";
				break;
			}
			if( strcmp( cp, "A" ) == 0 )  {
				VMOVE( mpt, tgc->a );
				*strp = "A";
				break;
			}
			if( strcmp( cp, "B" ) == 0 )  {
				VMOVE( mpt, tgc->b );
				*strp = "B";
				break;
			}
			if( strcmp( cp, "C" ) == 0 )  {
				VMOVE( mpt, tgc->c );
				*strp = "C";
				break;
			}
			if( strcmp( cp, "D" ) == 0 )  {
				VMOVE( mpt, tgc->d );
				*strp = "D";
				break;
			}
			/* Default */
			VMOVE( mpt, tgc->v );
			*strp = "V";
			break;
		}
	default:
		VSETALL( mpt, 0 );
		*strp = "(origin)";
		break;
	}
	MAT4X3PNT( pt, mat, mpt );
}

/* 	CALC_PLANES()
 *		calculate the plane (face) equations for an arb
 *		in solidrec pointed at by sp
 * XXX replaced by rt_arb_calc_planes()
 */
void
calc_planes( sp, type )
struct solidrec *sp;
int type;
{
	struct solidrec temprec;
	register int i, p1, p2, p3;

	/* find the plane equations */
	/* point notation - use temprec record */
	VMOVE( &temprec.s_values[0], &sp->s_values[0] );
	for(i=3; i<=21; i+=3) {
		VADD2( &temprec.s_values[i], &sp->s_values[i], &sp->s_values[0] );
	}
	type -= 4;	/* ARB4 at location 0, ARB5 at 1, etc */
	for(i=0; i<6; i++) {
		if(arb_faces[type][i*4] == -1)
			break;	/* faces are done */
		p1 = arb_faces[type][i*4];
		p2 = arb_faces[type][i*4+1];
		p3 = arb_faces[type][i*4+2];
		if(planeqn(i, p1, p2, p3, &temprec)) {
			(void)printf("No eqn for face %d%d%d%d\n",
				p1+1,p2+1,p3+1,arb_faces[type][i*4+3]+1);
			return;
		}
	}
}

a3602 38
/* 			C A L C _ P N T S (  )
 * XXX replaced by rt_arb_calc_points() in facedef.c
 *
 * Takes the array es_peqn[] and intersects the planes to find the vertices
 * of a GENARB8.  The vertices are stored in the solid record 'old_srec' which
 * is of type 'type'.  If intersect fails, the points (in vector notation) of
 * 'old_srec' are used to clean up the array es_peqn[] for anyone else. The
 * vertices are put in 'old_srec' in vector notation.  This is an analog to
 * calc_planes().
 */
void
calc_pnts( old_srec, type )
struct solidrec *old_srec;
int type;
{
	struct solidrec temp_srec;
	short int i;

	/* find new points for entire solid */
	for(i=0; i<8; i++){
		/* use temp_srec until we know intersect doesn't fail */
		if( intersect(type,i*3,i,&temp_srec) ){
			(void)printf("Intersection of planes fails\n");
			/* clean up array es_peqn for anyone else */
			calc_planes( old_srec, type );
			return;				/* failure */
		}
	}

	/* back to vector notation */
	VMOVE( &old_srec->s_values[0], &temp_srec.s_values[0] );
	for(i=3; i<=21; i+=3){
		VSUB2(	&old_srec->s_values[i],
			&temp_srec.s_values[i],
			&temp_srec.s_values[0]  );
	}
	return;						/* success */
}
@


10.28
log
@added error checking for erim solids
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.27 92/03/24 14:23:22 mmark Exp Locker: mmark $ (BRL)";
a602 1
	es_edflag = PSCALE;
d605 2
d1524 1
d2872 3
a2874 1
	if( es_edflag == ECMD_TGC_ROT_H || es_edflag == ECMD_TGC_ROT_AB ) {
d2926 1
@


10.27
log
@editing support for erim primitives
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.26 92/03/23 22:23:47 mike Exp Locker: mmark $ (BRL)";
d3194 1
a3254 1
VPRINT("H", ehy->ehy_H);
a3255 1
VPRINT("Hu", work);
a3257 1
VPRINT("c", work);
@


10.26
log
@Converted facedef.c to "new way".
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.25 92/03/20 19:16:19 mike Exp Locker: mike $ (BRL)";
d52 1
a52 1
static void	eto_ed();
d104 18
a121 2
#define MENU_ETO_R1		42
#define MENU_ETO_R2		43
d287 4
a290 2
	{ "scale r1 (r)", eto_ed, MENU_ETO_R1 },
	{ "scale r2 (rd)", eto_ed, MENU_ETO_R2 },
d433 34
d604 2
d609 32
d886 4
d1020 12
d1518 12
d1927 1
a1927 1
	case MENU_ETO_R1:
d1933 3
a1935 1
			fastf_t	newrad;
d1945 9
a1953 1
			if( eto->eto_rd <= newrad )
d1958 2
a1959 2
	case MENU_ETO_R2:
		/* scale radius 2 (rd) of ETO */
d1964 3
a1966 1
			fastf_t	newrad;
d1976 9
a1984 2
			if( newrad <= eto->eto_r )
				eto->eto_rd = newrad;
d1988 263
d2631 4
d3138 128
d3271 3
a3273 2
			fastf_t	r3, r4;
			vect_t	adir;
a3275 2
			mat_vec_ortho( adir, eto->eto_N );

d3279 15
a3293 3
#if 0
			r3 = eto->r_a - eto->r_h;
			VJOIN1( work, eto->v, r3, adir );
d3295 1
a3295 1
			POINT_LABEL( pos_view, 'I' );
d3297 1
a3297 2
			r4 = eto->r_a + eto->r_h;
			VJOIN1( work, eto->v, r4, adir );
d3299 1
a3299 1
			POINT_LABEL( pos_view, 'O' );
d3301 1
a3301 2
			VJOIN1( work, eto->v, eto->r_a, adir );
			VADD2( work, work, eto->h );
d3303 1
a3303 2
			POINT_LABEL( pos_view, 'H' );
#endif
@


10.25
log
@Created rt_db_xform_internal()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.24 92/03/20 15:41:32 mike Exp Locker: mike $ (BRL)";
d790 1
d3023 39
@


10.24
log
@Eliminated cmd_args[].
Broke out rt_arb_calc_planes
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.23 92/03/17 20:53:53 mike Exp Locker: mike $ (BRL)";
a885 2
 * XXX This should be part of the import/export interface.
 * XXX Each solid should know how to transform it's internal representation.
a893 1
	struct rt_external	ext;
a894 3
	int			id;

	RT_CK_DB_INTERNAL( is );
d896 1
a896 5
	id = is->idb_type;
	RT_INIT_EXTERNAL(&ext);
	/* Scale change on export is 1.0 -- no change */
	if( rt_functab[id].ft_export( &ext, is, 1.0 ) < 0 )  {
		rt_log("transform_editing_solid(%s):  solid export failure\n", dp->d_namep);
a897 13
	}
	if( (free || os == is) && is->idb_ptr )  {
		rt_functab[id].ft_ifree( is );
    		is->idb_ptr = (genptr_t)0;
    	}

	if( rt_functab[id].ft_import( os, &ext, mat ) < 0 )  {
		rt_log("transform_editing_solid(%s):  solid import failure\n",
			illump->s_path[illump->s_last]->d_namep );
		rt_bomb("transform_editing_solid");		/* FAIL */
	}
	RT_CK_DB_INTERNAL( os );

d2972 50
@


10.23
log
@Moved findang() from edsol.c to anal.c
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.22 92/02/14 16:28:26 mmark Exp Locker: mike $ (BRL)";
a48 3
extern char    *cmd_args[];
extern int 	numargs;

a166 1
extern int arb_planes[5][24];	/* from edarb.c */
d1100 2
a1101 1
			if( numargs == (1+3) ){		/* absolute X,Y,Z rotations */
d1115 4
a1118 3
			else if( numargs== (1+2) ){	/* rot,fb given */
				rota= atof(cmd_args[1]) * degtorad;
				fb  = atof(cmd_args[2]) * degtorad;
a2369 34

/* 	CALC_PLANES()
 *		calculate the plane (face) equations for an arb
 *		in solidrec pointed at by sp
 */
void
calc_planes( sp, type )
struct solidrec *sp;
int type;
{
	struct solidrec temprec;
	register int i, p1, p2, p3;

	/* find the plane equations */
	/* point notation - use temprec record */
	VMOVE( &temprec.s_values[0], &sp->s_values[0] );
	for(i=3; i<=21; i+=3) {
		VADD2( &temprec.s_values[i], &sp->s_values[i], &sp->s_values[0] );
	}
	type -= 4;	/* ARB4 at location 0, ARB5 at 1, etc */
	for(i=0; i<6; i++) {
		if(arb_faces[type][i*4] == -1)
			break;	/* faces are done */
		p1 = arb_faces[type][i*4];
		p2 = arb_faces[type][i*4+1];
		p3 = arb_faces[type][i*4+2];
		if(planeqn(i, p1, p2, p3, &temprec)) {
			(void)printf("No eqn for face %d%d%d%d\n",
				p1+1,p2+1,p3+1,arb_faces[type][i*4+3]+1);
			return;
		}
	}
}

d2377 3
a2379 1
f_eqn()
d2399 1
a2399 1
		es_peqn[es_menu][i]= atof(cmd_args[i+1]);
d2497 1
a2497 1
	inpara = 1;
d2499 2
a2500 2
	for( i = 1; i < argc; i++ )  {
		es_para[ i - 1 ] = atof( argv[i] );
d2921 74
@


10.22
log
@Initial ETO editing
@
text
@a6 1
 *	findang		Given a normal vector, find rotation & fallback angles
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.21 92/02/14 14:58:51 mike Exp Locker: mmark $ (BRL)";
a1677 53
}

/*
 *			F I N D A N G
 *
 * finds direction cosines and rotation, fallback angles of a unit vector
 * angles = pointer to 5 fastf_t's to store angles
 * unitv = pointer to the unit vector (previously computed)
 */
void
findang( angles, unitv )
register fastf_t	*angles;
register vect_t		unitv;
{
	FAST fastf_t f;

	/* convert direction cosines into axis angles */
	if( unitv[X] <= -1.0 )  angles[X] = -90.0;
	else if( unitv[X] >= 1.0 )  angles[X] = 90.0;
	else angles[X] = acos( unitv[X] ) * radtodeg;

	if( unitv[Y] <= -1.0 )  angles[Y] = -90.0;
	else if( unitv[Y] >= 1.0 )  angles[Y] = 90.0;
	else angles[Y] = acos( unitv[Y] ) * radtodeg;

	if( unitv[Z] <= -1.0 )  angles[Z] = -90.0;
	else if( unitv[Z] >= 1.0 )  angles[Z] = 90.0;
	else angles[Z] = acos( unitv[Z] ) * radtodeg;

	/* fallback angle */
	if( unitv[Z] <= -1.0 )  unitv[Z] = -1.0;
	else if( unitv[Z] >= 1.0 )  unitv[Z] = 1.0;
	angles[4] = asin(unitv[Z]);

	/* rotation angle */
	/* For the tolerance below, on an SGI 4D/70, cos(asin(1.0)) != 0.0
	 * with an epsilon of +/- 1.0e-17, so the tolerance below was
	 * substituted for the original +/- 1.0e-20.
	 */
	if((f = cos(angles[4])) > 1.0e-16 || f < -1.0e-16 )  {
		f = unitv[X]/f;
		if( f <= -1.0 )
			angles[3] = 180;
		else if( f >= 1.0 )
			angles[3] = 0;
		else
			angles[3] = radtodeg * acos( f );
	}  else
		angles[3] = 0.0;
	if( unitv[Y] < 0 )
		angles[3] = 360.0 - angles[3];

	angles[4] *= radtodeg;
@


10.21
log
@Converted TORUS to new editing scheme.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.20 92/02/05 23:12:52 mike Exp Locker: mike $ (BRL)";
d56 1
d108 2
d274 7
d552 8
d806 1
d957 3
d1891 42
d2313 1
d2845 33
@


10.20
log
@Calling sequence to vls_solid() changed.
More es_keypoint stuff.
Moved oedit_accept() and oedit_reject() from buttons.c to edsol.c
for better coupling to the editing support
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.19 92/02/05 19:37:00 mike Exp Locker: mike $ (BRL)";
d787 1
d1779 24
a1802 8
		mr2 = MAGNITUDE(&es_rec.s.s_tor_H);
		op = &es_rec.s.s_tor_B;
		if( inpara ) {
			/* take es_mat[15] (path scaling) into account */
			es_para[0] *= es_mat[15];
			es_scale = es_para[0] / MAGNITUDE(op);
		}
		VSCALE(op, op, es_scale);
d1804 2
a1805 7
		op = &es_rec.s.s_tor_A;
		VSCALE(op, op, es_scale);
		mr1 = MAGNITUDE(op);
		if( mr1 < mr2 ) {
			VSCALE(op, op, (mr2+0.01)/mr1);
			op = &es_rec.s.s_tor_B;
			VSCALE(op, op, (mr2+0.01)/mr1);
d1807 6
a1812 1
		}
d1814 4
a1817 4
		ma = mr1 - mr2;
		op = &es_rec.s.s_tor_C;
		mb = MAGNITUDE(op);
		VSCALE(op, op, ma/mb);
d1819 3
a1821 3
		op = &es_rec.s.s_tor_D;
		mb = MAGNITUDE(op);
		VSCALE(op, op, ma/mb);
d1823 4
a1826 4
		ma = mr1 + mr2;
		op = &es_rec.s.s_tor_E;
		mb = MAGNITUDE(op);
		VSCALE(op, op, ma/mb);
d1828 4
a1831 3
		op = &es_rec.s.s_tor_F;
		mb = MAGNITUDE(op);
		VSCALE(op, op, ma/mb);
d1836 23
a1858 11
		op = &es_rec.s.s_values[3];
		if( inpara ) {
			/* take es_mat[15] (path scaling) into account */
			es_para[0] *= es_mat[15];
			es_scale = es_para[0] / MAGNITUDE(op);
		}
		VSCALE(op, op, es_scale);
		mr2 = MAGNITUDE(op);
		mr1 = MAGNITUDE(&es_rec.s.s_values[6]);
		if(mr1 < mr2) {
			VSCALE(op, op, (mr1-0.01)/mr2);
d1860 6
d1867 1
a1867 1
		goto torcom;
a2196 1
		return;
d2739 27
d2780 1
d2845 16
@


10.19
log
@Eliminated es_orig
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.18 92/02/05 17:27:03 mike Exp Locker: mike $ (BRL)";
a79 2
static point_t	es_keypoint;	/* center of editing xforms */
static char	*es_keytag;	/* string identifying the keypoint */
d81 3
a789 4
		es_keytag = "";
		get_solid_keypoint( es_keypoint, &es_keytag, &es_int );
		printf("es_keypoint (%s) (%g, %g, %g)\n", es_keytag,
			V3ARGS(es_keypoint) );
d799 5
d1428 1
a1428 1
		get_solid_keypoint( es_keypoint, &es_keytag, &es_int );
d1714 1
a1714 1
 *  The only "solidrec" argument ever used is &es_res.s
d1717 4
a1720 4
vls_solid( vp, sp, mat )
register struct rt_vls	*vp;
register struct solidrec *sp;
CONST mat_t		mat;
d1729 1
d1731 2
a1732 9
	if( new_way )  {
		id = es_int.idb_type;
		transform_editing_solid( &intern, mat, &es_int, 0 );
	} else {
		/* Fake up an external record.  Does not need to be freed */
		sol = *sp;		/* struct copy */
		RT_INIT_EXTERNAL(&ext);
		ext.ext_nbytes = sizeof(sol);
		ext.ext_buf = (genptr_t)&sol;
a1733 7
		id = rt_id_solid( &ext );
		if( rt_functab[id].ft_import( &intern, &ext, mat ) < 0 )  {
			printf("vls_solid: database import error\n");
			return;
		}
	}

d2248 1
d2250 63
a2312 1
	/* XXX These should move to oedit_accept() and oedit_reject() ! */
d2314 1
d2318 7
d2326 1
d2445 1
d2463 1
d2742 1
a2742 1
get_solid_keypoint( pt, strp, ip )
d2746 1
d2749 1
d2761 1
a2761 1
				VMOVE( pt, ell->v );
d2763 1
a2763 1
				return;
d2766 1
a2766 1
				VMOVE( pt, ell->a );
d2768 1
a2768 1
				return;
d2771 1
a2771 1
				VMOVE( pt, ell->b );
d2773 1
a2773 1
				return;
d2776 1
a2776 1
				VMOVE( pt, ell->c );
d2778 1
a2778 1
				return;
d2781 1
a2781 1
			VMOVE( pt, ell->v );
d2783 1
a2783 1
			return;
d2792 1
a2792 1
				VMOVE( pt, tgc->v );
d2794 1
a2794 1
				return;
d2797 1
a2797 1
				VMOVE( pt, tgc->h );
d2799 1
a2799 1
				return;
d2802 1
a2802 1
				VMOVE( pt, tgc->a );
d2804 1
a2804 1
				return;
d2807 1
a2807 1
				VMOVE( pt, tgc->b );
d2809 1
a2809 1
				return;
d2812 1
a2812 1
				VMOVE( pt, tgc->c );
d2814 1
a2814 1
				return;
d2817 1
a2817 1
				VMOVE( pt, tgc->d );
d2819 1
a2819 1
				return;
d2822 1
a2822 1
			VMOVE( pt, tgc->v );
d2824 1
a2824 1
			return;
d2827 1
a2827 1
		VSETALL( pt, 0 );
d2831 1
@


10.18
log
@Added new_way support to TGC.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.17 92/02/05 15:41:24 mike Exp Locker: mike $ (BRL)";
a72 1
union record es_orig;		/* original solid record */
d738 1
d740 1
a740 2
	bcopy( (char *)es_ext.ext_buf, (char *)&es_orig, sizeof(es_orig) );
	if( es_orig.u_id == ID_SOLID )  {
a742 1
		es_rec = es_orig;		/* struct copy */
d1251 2
a1252 3
			(void)printf("Zero H vector not allowed\n");
			/* Replace with original H */
			VMOVE(&es_rec.s.s_tgc_H, &es_orig.s.s_tgc_H);
d1313 2
a1314 3
			(void)printf("Zero H vector not allowed\n");
			/* Replace with original H */
			VMOVE(&es_rec.s.s_tgc_H, &es_orig.s.s_tgc_H);
@


10.17
log
@db_put_external() adds name now.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.16 92/02/05 15:19:30 mike Exp Locker: mike $ (BRL)";
d82 1
d782 1
d784 6
a789 3
		/* XXX strictly experimental! */
		if( es_rec.s.s_type == GENELL )  {
			char	*str = "V";
d791 5
a795 9
			rt_log("Experimental:  new_way=1\n");
			new_way = 1;
			rt_log("es_int.idb_magic=x%x\n", es_int.idb_magic);
			rt_log("es_int.idb_type=%d.\n", es_int.idb_type);
			rt_log("es_int.idb_ptr=x%x\n", es_int.idb_ptr);

			get_solid_keypoint( es_keypoint, &str, &es_int );
			VPRINT("es_keypoint", es_keypoint);
		}
a797 2
	}

d1208 37
d1286 1
d1291 17
d1321 1
a1321 1

d1382 10
a1391 2
		MAT4X3VEC(work, incr_change, &es_rec.s.s_tgc_H);
		VMOVE(&es_rec.s.s_tgc_H, work);
d1397 19
a1415 4
		for(i=2; i<6; i++) {
			op = &es_rec.s.s_values[i*3];
			MAT4X3VEC( work, incr_change, op );
			VMOVE( op, work );
d1430 1
a1430 2
		char	*str = "V";
		get_solid_keypoint( es_keypoint, &str, &es_int );
d1510 25
a1534 9
		VADD2( temp, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_H );
		MAT4X3PNT(pos_model, es_mat, temp);
		MAT4X3PNT( pos_view, model2view, pos_model );
		pos_view[X] = mousevec[X];
		pos_view[Y] = mousevec[Y];
		/* Do NOT change pos_view[Z] ! */
		MAT4X3PNT( temp, view2model, pos_view );
		MAT4X3PNT( tr_temp, es_invmat, temp );
		VSUB2( &es_rec.s.s_tgc_H, tr_temp, &es_rec.s.s_tgc_V );
d1770 18
a1787 5
		op = &es_rec.s.s_tgc_H;
		if( inpara ) {
			/* take es_mat[15] (path scaling) into account */
			es_para[0] *= es_mat[15];
			es_scale = es_para[0] / MAGNITUDE(op);
a1788 2

		VSCALE(op, op, es_scale);
d1850 19
a1868 5
		op = &es_rec.s.s_tgc_A;
		if( inpara ) {
			/* take es_mat[15] (path scaling) into account */
			es_para[0] *= es_mat[15];
			es_scale = es_para[0] / MAGNITUDE(op);
a1869 1
		VSCALE(op, op, es_scale);
d1874 19
a1892 5
		op = &es_rec.s.s_tgc_B;
		if( inpara ) {
			/* take es_mat[15] (path scaling) into account */
			es_para[0] *= es_mat[15];
			es_scale = es_para[0] / MAGNITUDE(op);
a1893 1
		VSCALE(op, op, es_scale);
d1967 19
a1985 5
		op = &es_rec.s.s_tgc_C;
		if( inpara ) {
			/* take es_mat[15] (path scaling) into account */
			es_para[0] *= es_mat[15];
			es_scale = es_para[0] / MAGNITUDE(op);
a1986 1
		VSCALE(op, op, es_scale);
d1990 19
a2008 5
		op = &es_rec.s.s_tgc_D;
		if( inpara ) {
			/* take es_mat[15] (path scaling) into account */
			es_para[0] *= es_mat[15];
			es_scale = es_para[0] / MAGNITUDE(op);
a2009 1
		VSCALE(op, op, es_scale);
d2013 26
a2038 5
		op = &es_rec.s.s_tgc_A;
		if( inpara ) {
			/* take es_mat[15] (path scaling) into account */
			es_para[0] *= es_mat[15];
			es_scale = es_para[0] / MAGNITUDE(op);
a2039 5
		VSCALE(op, op, es_scale);
		ma = MAGNITUDE( op );
		op = &es_rec.s.s_tgc_B;
		mb = MAGNITUDE( op );
		VSCALE(op, op, ma/mb);
d2043 26
a2068 5
		op = &es_rec.s.s_tgc_C;
		if( inpara ) {
			/* take es_mat[15] (path scaling) into account */
			es_para[0] *= es_mat[15];
			es_scale = es_para[0] / MAGNITUDE(op);
a2069 5
		VSCALE(op, op, es_scale);
		ma = MAGNITUDE( op );
		op = &es_rec.s.s_tgc_D;
		mb = MAGNITUDE( op );
		VSCALE(op, op, ma/mb);
d2073 36
a2108 5
		op = &es_rec.s.s_tgc_A;
		if( inpara ) {
			/* take es_mat[15] (path scaling) into account */
			es_para[0] *= es_mat[15];
			es_scale = es_para[0] / MAGNITUDE(op);
a2109 11
		VSCALE(op, op, es_scale);
		ma = MAGNITUDE( op );
		op = &es_rec.s.s_tgc_B;
		mb = MAGNITUDE( op );
		VSCALE(op, op, ma/mb);
		op = &es_rec.s.s_tgc_C;
		mb = MAGNITUDE( op );
		VSCALE(op, op, ma/mb);
		op = &es_rec.s.s_tgc_D;
		mb = MAGNITUDE( op );
		VSCALE(op, op, ma/mb);
d2560 23
d2601 1
d2721 41
@


10.16
log
@New editing is starting to work
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.15 92/02/05 13:41:08 mike Exp Locker: mike $ (BRL)";
a861 4
/* XXX This routine isn't taking into account the tree path,
 * XXX nor the provided es_mat argument!
 * XXX It's in dodraw.c -- fix it!
 */
d870 4
a873 1
 * Works the new_way only.
a2148 1
	union record		*rec;
a2166 4

		/* Depends on solid names always being in the same place */
		rec = (union record *)es_ext.ext_buf;
		NAMEMOVE( dp->d_namep, rec->s.s_name );
@


10.15
log
@Modified ell for new way.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.14 92/02/05 13:29:47 mike Exp Locker: mike $ (BRL)";
d81 1
d107 59
d745 1
d784 2
d791 3
d1167 1
a1167 2
			mat_idn(scalemat);
			scalemat[15] = 1/es_scale;
d1187 1
d1189 1
d1191 1
d1193 1
a1193 1
				 * to new location.  Then apply matrix.
d1195 3
a1197 1
				rt_bomb("new_way");
a1199 1
				MAT4X3PNT( work, es_invmat, es_para );
d1313 4
a1316 3
			/* XXX Need to xlate keypoint to origin, then rotate, then put back. */
			rt_bomb("new_way");
			transform_editing_solid(&es_int, incr_change, &es_int, 1);
d1352 6
d1397 1
a1397 1
		 * Project solid's V point into view space,
d1400 1
d1402 28
a1429 8
		/* XXX this makes bad assumptions about format of es_rec !! */
		/* XXX new_way */
		MAT4X3PNT( temp, es_mat, es_rec.s.s_values );
		MAT4X3PNT( pos_view, model2view, temp );
		pos_view[X] = mousevec[X];
		pos_view[Y] = mousevec[Y];
		MAT4X3PNT( temp, view2model, pos_view );
		MAT4X3PNT( es_rec.s.s_values, es_invmat, temp );
d1537 1
a1537 1
		/* Have scaling take place with respect to a point,
d1540 1
a1540 2
		/* XXX should have an es_keypoint for this */
		MAT4X3PNT(temp, es_mat, es_rec.s.s_values);
d1546 2
a1547 3
		/* Vector from object center to cursor */
		/* XXX should have an es_keypoint for this */
		MAT4X3PNT( temp, es_mat, es_rec.s.s_values );
d1906 1
a1906 1
	case MENU_ELL_SCALE_ABC:	/* scale A,B, and C of ellg */
d1967 1
a1967 2
		/* XXX should have an es_keypoint for this */
		VMOVE(es_rec.s.s_values, illump->s_center);
a1968 4
		/* Zero the other values */
		for(i=3; i<24; i++)
			es_rec.s.s_values[i] = 0.0;

d1994 1
a1994 2
	/* XXX should have an es_keypoint here;
	 * instead, be certain that es_rec.s.s_values[0] has key point! */
d2012 1
a2012 1
			VMOVE(es_rec.s.s_values, rec[1].b.b_values);
d2035 1
d2040 1
a2040 1
		VSETALL(es_rec.s.s_values, 0 );
d2044 1
a2044 1
		/* XXX Need SOMETHING in s_values, s/b es_keypoint */
d2046 1
a2046 2
			V3ARGS(illump->s_center) );
		VMOVE(es_rec.s.s_values, illump->s_center);
d2055 3
d2307 1
a2307 2
	/* XXX should have an es_keypoint for this */
	MAT4X3PNT(point, tempp, es_rec.s.s_values);
d2443 61
@


10.14
log
@Took on solid vertex labeling from titles.c
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.13 92/02/05 13:09:49 mike Exp Locker: mike $ (BRL)";
d2289 22
d2325 1
@


10.13
log
@transform_editing_solid() got new arg:  free source copy.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.12 92/02/04 02:07:14 mike Exp Locker: mike $ (BRL)";
d2222 107
@


10.12
log
@Further along.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.11 92/02/03 22:09:07 mike Exp Locker: mike $ (BRL)";
d720 1
a720 1
#if 0
d811 1
a811 1
transform_editing_solid(os, mat, is)
d815 1
d830 1
a830 1
    	if( os == is && is->idb_ptr )  {
d1103 1
a1103 1
			transform_editing_solid(&es_int, scalemat, &es_int);
d1128 1
a1128 1
				transform_editing_solid(&es_int, xlatemat, &es_int);
d1246 1
a1246 1
			transform_editing_solid(&es_int, incr_change, &es_int);
d1548 1
a1548 1
		transform_editing_solid( &intern, mat, &es_int );
@


10.11
log
@Moved size change handling into db_ext_put().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.10 91/12/20 02:28:13 mike Exp Locker: mike $ (BRL)";
a39 1
#include "./sedit.h"
d41 3
a44 1
#include "externs.h"
d46 1
d53 2
d677 1
d720 11
d766 1
d771 7
a777 4
	/* Fake up an external representation */
	RT_INIT_EXTERNAL( &ext );
	ext.ext_buf = (genptr_t)&es_rec;
	ext.ext_nbytes = sizeof(union record);
d779 14
a792 4
	if( (id = rt_id_solid( &ext )) == ID_NULL )  {
		(void)printf("replot_editing_solid() unable to identify type of solid %s\n",
			dp->d_namep );
		return;
d794 1
d796 7
a802 4
    	RT_INIT_DB_INTERNAL(&intern);
	if( rt_functab[id].ft_import( &intern, &ext, rt_identity ) < 0 )  {
		rt_log("%s:  solid import failure\n",
			dp->d_namep );
a803 1
	    	return;			/* ERROR */
d805 1
a805 1
	RT_CK_DB_INTERNAL( &intern );
d807 12
a818 1
	(void)replot_modified_solid( illump, &intern, es_mat );
d820 21
a840 1
    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
d1098 10
a1107 3
		for(i=3; i<=21; i+=3) { 
			op = &es_rec.s.s_values[i];
			VSCALE(op,op,es_scale);
d1118 2
a1119 1
			 * model coordinates first.
d1121 11
a1131 2
			MAT4X3PNT( work, es_invmat, es_para );
			VMOVE(es_rec.s.s_values, work);
a1223 5
			for(i=1; i<8; i++) {
				op = &es_rec.s.s_values[i*3];
				VMOVE( work, op );
				MAT4X3VEC( op, invsolr, work );
			}
d1231 2
a1235 5
			for(i=1; i<8; i++) {
				op = &es_rec.s.s_values[i*3];
				VMOVE( work, op );
				MAT4X3VEC( op, modelchanges, work );
			}
a1237 1

d1239 8
a1246 1
			/* Apply incremental changes */
d1325 1
d1528 3
d1545 9
a1553 5
	/* Fake up an external record.  Does not need to be freed */
	sol = *sp;		/* struct copy */
	RT_INIT_EXTERNAL(&ext);
	ext.ext_nbytes = sizeof(sol);
	ext.ext_buf = (genptr_t)&sol;
d1555 5
a1559 4
	id = rt_id_solid( &ext );
	if( rt_functab[id].ft_import( &intern, &ext, mat ) < 0 )  {
		printf("vls_solid: database import error\n");
		return;
d1674 18
a1691 5
		op = &es_rec.s.s_ell_A;
		if( inpara ) {
			/* take es_mat[15] (path scaling) into account */
			es_para[0] *= es_mat[15];
			es_scale = es_para[0] / MAGNITUDE(op);
a1692 1
		VSCALE(op, op, es_scale);
d1697 18
a1714 5
		op = &es_rec.s.s_ell_B;
		if( inpara ) {
			/* take es_mat[15] (path scaling) into account */
			es_para[0] *= es_mat[15];
			es_scale = es_para[0] / MAGNITUDE(op);
a1715 1
		VSCALE(op, op, es_scale);
d1720 18
a1737 5
		op = &es_rec.s.s_ell_C;
		if( inpara ) {
			/* take es_mat[15] (path scaling) into account */
			es_para[0] *= es_mat[15];
			es_scale = es_para[0] / MAGNITUDE(op);
a1738 2

		VSCALE(op, op, es_scale);
d1811 30
a1840 5
		op = &es_rec.s.s_ell_A;
		if( inpara ) {
			/* take es_mat[15] (path scaling) into account */
			es_para[0] *= es_mat[15];
			es_scale = es_para[0] / MAGNITUDE(op);
a1841 8
		VSCALE(op, op, es_scale);
		ma = MAGNITUDE( op );
		op = &es_rec.s.s_ell_B;
		mb = MAGNITUDE( op );
		VSCALE(op, op, ma/mb);
		op = &es_rec.s.s_ell_C;
		mb = MAGNITUDE( op );
		VSCALE(op, op, ma/mb);
d2065 10
a2074 6
#if 1
	db_put( dbip, dp, &es_rec, 0, 1 );
#else
	/* Scale change on export is 1.0 -- no change */
	if( rt_functab[es_int.idb_type].ft_export( &es_ext, &es_int, 1.0 ) < 0 )  {
		rt_log("sedit_accept(%s):  solid export failure\n", dp->d_namep);
a2075 4
		db_free_external( &es_ext );
		return;				/* FAIL */
	}
    	if( es_int.idb_ptr )  rt_functab[es_int.idb_type].ft_ifree( &es_int );
d2077 3
a2079 3
	/* Depends on solid names always being in the same place */
	rec = (union record *)es_ext.ext_buf;
	NAMEMOVE( dp->d_namep, rec->s.s_name );
d2081 5
a2085 4
	if( db_put_external( &es_ext, dp, dbip ) < 0 )  {
		db_free_external( &es_ext );
		ERROR_RECOVERY_SUGGESTION;
		WRITE_ERR_return;
d2087 1
a2087 1
#endif
d2091 1
d2108 1
@


10.10
log
@Many defines for es_edflag values have been given better names.
sedit_rotate() and objedit_rotate() event handlers split off
from usejoy() in ged.c
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.9 91/12/20 01:09:44 mike Exp Locker: mike $ (BRL)";
a643 1
	struct solidrec temprec;	/* copy of solid to determine type */
d672 1
d675 2
a676 1
	es_rec = es_orig;		/* struct copy */
d678 2
a679 5
	if( es_orig.u_id != ID_SOLID )  {
		(void)printf(
"Unable to Solid_Edit %c record;  select a primitive instead\n");
		return;
	}
d681 20
a700 1
	es_menu = 0;
d702 6
a707 1
	temprec = es_rec.s;		/* struct copy */
d709 2
a710 20
	if( (type = es_rec.s.s_cgtype) < 0 )
		type *= -1;
	if(type == BOX || type == RPP)
		type = ARB8;
	if(type == RAW) {
		/* rearrange vectors to correspond to the
		 *  	"standard" ARB6
		 */
		register struct solidrec *trp = &temprec;
		VMOVE(&trp->s_values[3], &es_rec.s.s_values[9]);
		VMOVE(&trp->s_values[6], &es_rec.s.s_values[21]);
		VMOVE(&trp->s_values[9], &es_rec.s.s_values[12]);
		VMOVE(&trp->s_values[12], &es_rec.s.s_values[3]);
		VMOVE(&trp->s_values[15], &es_rec.s.s_values[6]);
		VMOVE(&trp->s_values[18], &es_rec.s.s_values[18]);
		VMOVE(&trp->s_values[21], &es_rec.s.s_values[15]);
		es_rec.s = *trp;	/* struct copy */
		type = ARB6;
	}
	es_rec.s.s_cgtype = type;
d712 2
a713 5
	if( es_rec.s.s_type == GENARB8 ) {
		/* find the comgeom arb type */
		if( (type = type_arb( &es_rec )) == 0 ) {
			(void)printf("%s: BAD ARB\n",es_rec.s.s_name);
			return;
a714 6

		temprec = es_rec.s;
		es_rec.s.s_cgtype = type;

		/* find the plane equations */
		calc_planes( &es_rec.s, type );
a716 1

a1282 3
		mousevec[X] = mousevec[X];
		mousevec[Y] = mousevec[Y];
		mousevec[Z] = 0;
a1290 3
		mousevec[X] = mousevec[X];
		mousevec[Y] = mousevec[Y];
		mousevec[Z] = 0;
a1917 1
	int			ngran;
a1939 13

	ngran = (es_ext.ext_nbytes + sizeof(union record)-1)/sizeof(union record);
	if( ngran != dp->d_len )  {
		if( ngran < dp->d_len )  {
			if( db_trunc( dbip, dp, dp->d_len - ngran ) < 0 )
			    	ALLOC_ERR_return;
		} else if( ngran > dp->d_len )  {
			if( db_delete( dbip, dp ) < 0 || 
			    db_alloc( dbip, dp, ngran ) < 0 )  {
			    	ALLOC_ERR_return;
			}
		}
	}
@


10.9
log
@Changed calling sequence to replot_modified_solid() to use
an rt_db_internal structure, rather than a pointer to union record.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.8 91/12/19 03:22:55 mike Exp Locker: mike $ (BRL)";
d59 1
a59 1
static short int fixv;		/* used in ROTFACE,f_eqn(): fixed vertex */
d378 1
a378 1
		es_edflag = CONTROL;
d395 1
a395 1
		es_edflag = CONTROL;
d417 1
a417 1
		es_edflag = CONTROL;
d434 1
a434 1
		es_edflag = CONTROL;
d446 1
a446 1
		es_edflag = CONTROL;
d457 4
a460 2
	if(arg == MENU_TGC_ROT_H || arg == MENU_TGC_ROT_AB)
		es_edflag = PROT;
d462 1
a462 1
		es_edflag = MOVEH;
d464 1
a464 1
		es_edflag = MOVEHH;
d489 1
a489 1
	es_edflag = MVFACE;
d491 1
a491 1
		es_edflag = CONTROL;
d501 1
a501 1
	es_edflag = MVFACE;
d503 1
a503 1
		es_edflag = CONTROL;
d513 1
a513 1
	es_edflag = MVFACE;
d515 1
a515 1
		es_edflag = CONTROL;
d525 1
a525 1
	es_edflag = MVFACE;
d527 1
a527 1
		es_edflag = CONTROL;
d537 1
a537 1
	es_edflag = MVFACE;
d539 1
a539 1
		es_edflag = CONTROL;
d549 1
a549 1
	es_edflag = SETUP_ROTFACE;
d552 1
a552 1
		es_edflag = CONTROL;
d562 1
a562 1
	es_edflag = SETUP_ROTFACE;
d565 1
a565 1
		es_edflag = CONTROL;
d575 1
a575 1
	es_edflag = SETUP_ROTFACE;
d578 1
a578 1
		es_edflag = CONTROL;
d588 1
a588 1
	es_edflag = SETUP_ROTFACE;
d591 1
a591 1
		es_edflag = CONTROL;
d601 1
a601 1
	es_edflag = SETUP_ROTFACE;
d604 1
a604 1
		es_edflag = CONTROL;
d614 1
a614 1
	es_edflag = CHGMENU;
d815 2
d836 1
a836 1
	static int pnt5;		/* SETUP_ROTFACE, special arb7 case */
d848 2
a849 2
	case CONTROL:
		/* put up control menu for GENARB8s */
d855 1
a855 1
	case CHGMENU:
d875 1
a875 1
	case MVFACE:
d887 1
a887 1
	case SETUP_ROTFACE:
d901 1
a901 1
			/* find fixed vertex for ROTFACE */
d937 1
a937 1
		es_edflag = ROTFACE;
d942 1
a942 1
	case ROTFACE:
d1033 1
a1033 1
		/* scale the solid */
d1060 1
a1060 5
	case MENU:
		/* do nothing */
		break;

	case MOVEH:
d1108 1
a1108 1
	case MOVEHH:
d1183 6
a1188 2
	case PROT:   /* partial rotation of a solid */
		switch( es_menu ) {
d1190 6
a1195 12
		case MENU_TGC_ROT_H:  /* rotate height vector */
			MAT4X3VEC(work, incr_change, &es_rec.s.s_tgc_H);
			VMOVE(&es_rec.s.s_tgc_H, work);
			break;

		case MENU_TGC_ROT_AB:  /* rotate surfaces AxB and CxD (tgc) */
			for(i=2; i<6; i++) {
				op = &es_rec.s.s_values[i*3];
				MAT4X3VEC( work, incr_change, op );
				VMOVE( op, work );
			}
			break;
d1260 2
a1261 2
	case MOVEH:
	case MOVEHH:
d1298 1
a1298 1
	case MVFACE:
d1896 1
a1896 1
	else if( es_edflag != ROTFACE ){
d2010 1
a2010 1
	if( es_edflag == PROT ) {
d2019 1
a2019 2
		if( es_edflag == PSCALE ||
					es_edflag == SSCALE )  {
d2034 3
a2036 3
		case MVFACE:
		case MOVEH:
		case MOVEHH:
d2046 58
@


10.8
log
@Moved f_param ("p") command from cmd.c to edsol.c
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.7 91/12/19 03:16:38 mike Exp Locker: mike $ (BRL)";
d751 30
a780 1
	replot_modified_solid( illump, &es_rec, es_mat );
@


10.7
log
@CHGMENU and SETUP_ROTFACE also resulted in sedraw=1
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.6 91/12/19 03:12:27 mike Exp Locker: mike $ (BRL)";
d1968 52
@


10.6
log
@Incorporated MENU defines locally, gave them better names.
Moved mouse event handling routines here (from usepen.c)
for solid edit and object edit events.
Made setting of sedraw=1 explicit in menu handlers.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.5 91/12/18 08:10:06 mike Exp Locker: mike $ (BRL)";
d548 1
d561 1
d574 1
d587 1
d600 1
d613 1
@


10.5
log
@Eliminated unused variables es_nlines es_display
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.4 91/12/18 07:56:14 mike Exp Locker: mike $ (BRL)";
d62 2
a74 1
int	es_menu;		/* item selected from menu */
d78 24
d184 12
a195 12
	{ "scale H",	tgc_ed, MENUH },
	{ "scale A",	tgc_ed, MENUA },
	{ "scale B",	tgc_ed, MENUB },
	{ "scale c",	tgc_ed, MENUP1 },
	{ "scale d",	tgc_ed, MENUP2 },
	{ "scale A,B",	tgc_ed, MENUAB },
	{ "scale C,D",	tgc_ed, MENUCD },
	{ "scale A,B,C,D", tgc_ed, MENUABCD },
	{ "rotate H",	tgc_ed, MENURH },
	{ "rotate AxB",	tgc_ed, MENURAB },
	{ "move end H(rt)", tgc_ed, MENUMH },
	{ "move end H", tgc_ed, MENUMHH },
d201 2
a202 2
	{ "scale radius 1", tor_ed, MENUR1 },
	{ "scale radius 2", tor_ed, MENUR2 },
d208 4
a211 4
	{ "scale A", ell_ed, MENUA },
	{ "scale B", ell_ed, MENUB },
	{ "scale C", ell_ed, MENUC },
	{ "scale A,B,C", ell_ed, MENUABC },
d339 3
a341 3
	{ "move edges", arb_control, EDGEMENU },
	{ "move faces", arb_control, MOVEMENU },
	{ "rotate faces", arb_control, ROTMENU },
d377 1
a377 1
	if(arg == 12)
d379 2
d394 1
a394 1
	if(arg == 12)
d396 2
d416 1
a416 1
	if(arg == 10)
d418 2
d433 1
a433 1
	if(arg == 9)
d435 2
d445 1
a445 1
	if(arg == 5)
d447 2
d457 1
a457 1
	if(arg == MENURH || arg == MENURAB)
d459 1
a459 1
	if(arg == MENUMH)
d461 1
a461 1
	if(arg == MENUMHH)
d488 1
a488 1
	if( arg == 7 )
d490 2
d500 1
a500 1
	if( arg == 7 )
d502 2
d512 1
a512 1
	if( arg == 6 )
d514 2
d524 1
a524 1
	if( arg == 6 )
d526 2
d536 1
a536 1
	if( arg == 5 )
d538 2
d548 1
a548 1
	if( arg == 7 )
d550 2
d560 1
a560 1
	if( arg == 7 )
d562 2
d572 1
a572 1
	if( arg == 6 )
d574 2
d584 1
a584 1
	if( arg == 6 )
d586 2
d596 1
a596 1
	if( arg == 5 )
d598 2
d784 5
d821 1
a821 1
			case EDGEMENU:  
d824 1
a824 1
			case MOVEMENU:
d827 1
a827 1
			case ROTMENU:
d1151 1
a1151 1
		case MENURH:  /* rotate height vector */
d1156 1
a1156 1
		case MENURAB:  /* rotate surfaces AxB and CxD (tgc) */
d1181 13
d1195 91
d1287 86
d1473 1
a1473 1
	case MENUH:	/* scale height vector */
d1484 1
a1484 1
	case MENUR1:
d1524 1
a1524 1
	case MENUR2:
d1541 1
a1541 1
	case MENUA:
d1543 8
a1550 1
		switch( es_int.idb_type ) {
d1552 10
a1561 9
		case ID_ELL:
			op = &es_rec.s.s_ell_A;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
			break;
d1563 7
a1569 10
		case ID_TGC:
			op = &es_rec.s.s_tgc_A;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
			break;

d1571 1
d1574 1
a1574 1
	case MENUB:
d1576 5
a1580 21
		switch( es_int.idb_type ) {

		case ID_ELL:
			op = &es_rec.s.s_ell_B;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
			break;

		case ID_TGC:
			op = &es_rec.s.s_tgc_B;
			if( inpara ) {
				/* take es_mat[15] (path scaling) into account */
				es_para[0] *= es_mat[15];
				es_scale = es_para[0] / MAGNITUDE(op);
			}
			VSCALE(op, op, es_scale);
			break;
d1582 1
d1585 2
a1586 2
	case MENUC:
		/* scale vector C (ELL only) */
d1597 1
a1597 1
	case MENUP1:
d1608 1
a1608 1
	case MENUP2:   /* scale  d for tgc */
d1618 1
a1618 1
	case MENUAB:
d1632 1
a1632 1
	case MENUCD:	/* scale C and D of tgc */
d1646 1
a1646 1
	case MENUABCD: 		/* scale A,B,C, and D of tgc */
d1666 1
a1666 1
	case MENUABC:	/* scale A,B, and C of ellg */
@


10.4
log
@Eliminated pr_solid() in favor of newer code, using import/export
interface and vls routines.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.3 91/12/18 04:28:28 mike Exp Locker: mike $ (BRL)";
a75 2
int	es_nlines;		/* # lines in printed display */
char	es_display[ES_LINELEN*10];/* buffer for lines of display */
a1175 15

#define PR_STR(ln,str)	(void)strcpy(&es_display[ln*ES_LINELEN], str);

#define PR_PT(ln,title,base)	(void)sprintf( &es_display[ln*ES_LINELEN],\
		"\t%c (%.4f, %.4f, %.4f)%c", \
		title, (base)[X], (base)[Y], (base)[Z], '\0' )

#define PR_VECM(ln,title,base,mag)	(void)sprintf( &es_display[ln*ES_LINELEN],\
		"\t%c (%.4f, %.4f, %.4f) Mag=%f%c", \
		title, (base)[X], (base)[Y], (base)[Z], mag, '\0' )

#define PR_ANG(ln,str,base)	(void)sprintf( &es_display[ln*ES_LINELEN],\
		"\t%s dir cos=(%.1f, %.1f, %.1f), rot=%.1f, fb=%.1f%c", \
		str, (base)[0], (base)[1], (base)[2], \
		(base)[3], (base)[4], '\0' )
@


10.3
log
@Bare beginnings of conversion to es_int stuff
@
text
@a7 1
 *	pr_solid	Print a description of a solid
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.2 91/12/02 16:57:39 mike Exp Locker: mike $ (BRL)";
d704 1
a704 1
	switch( es_gentype ) {
d706 1
a706 1
	case GENARB8:
d709 1
a709 1
	case GENTGC:
d712 1
a712 1
	case TOR:
d715 1
a715 1
	case GENELL:
d718 1
a718 3

	/* These two sections are wrong!!  Not solid records at all! */
	case ARS:
d721 1
a721 1
	case SPLINE:
a932 1
		pr_solid( &es_rec.s );
a1119 1
	pr_solid( &es_rec.s );
a1193 6
/*
 *			P R _ S O L I D
 *
 * Generate neatly formatted representation of the solid,
 * for display purposes.
 */
d1195 2
a1196 1
pr_solid( sp )
d1198 1
d1200 5
a1204 9
	static vect_t work;
	register int i;
	static fastf_t ma;
	static fastf_t r1, r2;
	static vect_t unitv;
	static fastf_t ang[5];
	static struct solidrec local;
	register int length;
	int cgtype;
d1206 1
a1206 7
	/* make a private copy in local units */
	for(i=0; i<24; i+=3) {
		VSCALE(work, &sp->s_values[i], base2local);
		VMOVE(&local.s_values[i], work);
	}
	if( (cgtype = sp->s_cgtype) < 0 )
		cgtype *= -1;
d1208 5
a1212 1
	switch( sp->s_type ) {
d1214 5
a1218 6
	case HALFSPACE:
		PR_PT( 0, 'N', &sp->s_values[0]);
		(void)sprintf( &es_display[1*ES_LINELEN],
			"\td=%f", local.s_values[3]);
		es_nlines = 2;
		break;
d1220 4
a1223 141
	case ARS:
	case ARSCONT:
		PR_PT( 0, 'V', &local.s_values[0]);
		es_nlines = 1;
		break;

	case TOR:
		r1 = MAGNITUDE(&local.s_tor_A);
		r2 = MAGNITUDE(&local.s_tor_H);
		PR_PT( 0, 'V', &local.s_tor_V );

		(void)sprintf( &es_display[1*ES_LINELEN],
			"\tr1=%f, r2=%f%c", r1, r2, '\0' );

		if( r2 < EPSILON )  {
			PR_STR( 2, "N too small");
		} else {
			VSCALE( unitv, &local.s_tor_H, 1.0/r2 );/* N == H^ */
			PR_PT( 2, 'N', unitv );
		}

		findang( ang, unitv );
		PR_ANG( 3, "N", ang );

		PR_PT( 4, 'I', &local.s_tor_C );
		PR_PT( 5, 'O', &local.s_tor_E );
		PR_PT( 6, 'H', &local.s_tor_H );
		es_nlines = 7;
		break;

	case GENARB8:
		PR_PT( 0, '1', &local.s_values[0] );
		switch( cgtype ) {
			case ARB8:
				es_nlines = length = 8;
/* common area for arbs */
arbcommon:
				for(i=3; i<3*length; i+=3) {
					VADD2( work, &local.s_values[i], &local.s_values[0] );
					PR_PT( i/3, '1'+(i/3), work );
				}
				break;

			case ARB7:
				es_nlines = length = 7;
				goto arbcommon;

			case ARB6:
				es_nlines = length = 6;
				VMOVE(&local.s_values[15], &local.s_values[18]);
				goto arbcommon;

			case ARB5:
				es_nlines = length = 5;
				goto arbcommon;

			case ARB4:
				es_nlines = length = 4;
				VMOVE(&local.s_values[9], &local.s_values[12]);
				goto arbcommon;

			default:
				/* use ARB8 */
				es_nlines = length = 8;
				goto arbcommon;
		}
		break;

	case GENELL:
		PR_PT( 0, 'V', &local.s_ell_V );

		ma = MAGNITUDE( &local.s_ell_A );
		PR_VECM( 1, 'A', &local.s_ell_A, ma );

		if( ma < EPSILON )  {
			PR_STR( 2, "A too small");
		} else {
			VSCALE( unitv, &local.s_ell_A, 1.0/ma );
			findang( ang, unitv );
			PR_ANG( 2, "A", ang );
		}

		ma = MAGNITUDE( &local.s_ell_B );
		PR_VECM( 3, 'B', &local.s_ell_B, ma );

		if( ma < EPSILON )  {
			PR_STR( 4, "B too small");
		} else {
			VSCALE( unitv, &local.s_ell_B, 1.0/ma );
			findang( ang, unitv );
			PR_ANG( 4, "B", ang );
		}

		ma = MAGNITUDE( &local.s_ell_C );
		PR_VECM( 5, 'C', &local.s_ell_C, ma );

		if( ma < EPSILON )  {
			PR_STR( 6, "C too small");
		} else {
			VSCALE( unitv, &local.s_ell_C, 1.0/ma );
			findang( ang, unitv );
			PR_ANG( 6, "C", ang );
		}

		es_nlines = 7;
		break;

	case GENTGC:
		PR_PT( 0, 'V', &local.s_tgc_V );

		ma = MAGNITUDE( &local.s_tgc_H );
		PR_VECM( 1, 'H', &local.s_tgc_H, ma );

		if( ma < EPSILON )  {
			PR_STR( 2, "H magnitude too small");
		} else {
			VSCALE( unitv, &local.s_tgc_H, 1.0/ma );
			findang( ang, unitv );
			PR_ANG( 2, "H", ang );
		}

		ma = MAGNITUDE( &local.s_tgc_A );
		PR_VECM( 3, 'A', &local.s_tgc_A, ma );

		ma = MAGNITUDE( &local.s_tgc_B );
		PR_VECM( 4, 'B', &local.s_tgc_B, ma );

		(void)sprintf( &es_display[5*ES_LINELEN],
			"\tc = %f, d = %f%c",
			MAGNITUDE( &local.s_tgc_C ),
			MAGNITUDE( &local.s_tgc_D ), '\0' );

		/* AxB */
		VCROSS( unitv, &local.s_tgc_C, &local.s_tgc_D );
		VUNITIZE( unitv );
		findang( ang, unitv );
		PR_ANG( 6, "AxB", ang );

		es_nlines = 7;
		break;
	}
d1310 1
a1310 1
		switch( es_gentype ) {
d1312 1
a1312 1
		case GENELL:
d1322 1
a1322 1
		case GENTGC:
d1337 1
a1337 1
		switch(es_gentype) {
d1339 1
a1339 1
		case GENELL:
d1349 1
a1349 1
		case GENTGC:
a1468 1
	struct rt_external	es_ext;	/* This should be external */
a1497 1
	/* XXX should be db_getmrec() */
d1504 11
d1580 2
a1581 3
	/* fill the display array */
	pr_solid( &es_rec.s );

a1663 1
	pr_solid( &es_rec.s );
@


10.2
log
@Created sedit_accept() and sedit_reject(), in edsol.c
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 10.1 91/10/12 06:43:40 mike Rel4_0 Locker: mike $ (BRL)";
d63 4
d579 1
d586 1
d598 17
a614 1
	db_get( dbip,  illump->s_path[illump->s_last], &es_orig, 0 , 1);
d617 1
a617 1
	if( es_rec.u_id != ID_SOLID )  {
d1818 5
d1826 36
a1861 1
	db_put( dbip, illump->s_path[illump->s_last], &es_rec, 0, 1 );
d1865 3
d1881 3
@


10.1
log
@Release_4.0
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 9.8 91/07/17 23:30:25 mike Exp $ (BRL)";
d1789 27
@


9.8
log
@Fixed bug reported by Sue Coates.
ARS and HALF did not have on-screen display in user units.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 9.7 91/01/26 03:23:04 mike Exp $ (BRL)";
@


9.7
log
@Changed calling sequences for ft_plot, rt_id_solid, etc.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 9.6 90/12/15 04:18:49 mike Exp $ (BRL)";
d1210 1
a1210 1
			"\td=%f", sp->s_values[3]);
d1216 1
a1216 1
		PR_PT( 0, 'V', &sp->s_values[0]);
@


9.6
log
@Fixed bug in ARB8 object editing introduced by revision 9.2
Some serious housekeeping is still in order here!
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/edsol.c,v 9.5 90/12/08 05:54:45 mike Exp $ (BRL)";
d1600 4
a1603 3
	register int i, type;
	union record trec;
	int	id;
d1631 8
a1638 1
	db_get( dbip,  illump->s_path[illump->s_last], &es_rec, 0 , 1);
d1642 2
a1643 1
	switch( id = rt_id_solid( &es_rec ) )  {
d1648 1
d1652 11
a1662 6
		/* read the first B-record into trec */
		db_get( dbip,  illump->s_path[illump->s_last], &trec, 1 , 1);
		/* only interested in vertex */
		VMOVE(es_rec.s.s_values, trec.b.b_values);
		es_rec.s.s_type = ARS;		/* XXX wrong */
		es_rec.s.s_cgtype = ARS;
d1705 1
@


9.5
log
@Minor optimization.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 9.4 90/04/21 06:05:58 mike Exp $ (BRL)";
d1650 6
a1655 1
	case ID_SOLID:
d1676 2
@


9.4
log
@redraw() and drawtree() replaced.
More emphasis on argv/argc use in command functions.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 9.3 89/10/27 21:26:59 mike Locked $ (BRL)";
d773 2
a774 1
		for(i=pnt5=0; i<4; i++)
d777 1
d787 3
a789 3
			while( !( fixv > 0   &&   fixv <= es_rec.s.s_cgtype ) ){
				static short int type,loc,valid;
				char line[20];
d793 1
a794 1
					loc = es_menu*4;
d796 2
a797 1
						printf("%d ",arb_vertices[type][loc+i]);
d809 2
a810 1
				for(j=valid=0; j<4; j++)
d813 1
d816 1
a816 1
			}
@


9.3
log
@Tolerence too tight for at least the SGI 4D/70.  Fix to a 90 degree
rotation imposed on boundary values.  Both from Dan Dender.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 9.2 89/10/10 16:24:34 phil Locked $ (BRL)";
a51 2
extern struct solid	*redraw();

d662 12
d906 1
a906 1
		illump = redraw( illump, &es_rec, es_mat );
d1094 1
a1094 1
	illump = redraw( illump, &es_rec, es_mat );
d1755 2
a1756 2
	/* draw the new solid */
	illump = redraw( illump, &es_rec, es_mat );
a1760 1
	return;	
@


9.2
log
@Started adding support for all the many solid types, in object editing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 9.1 89/05/19 06:03:04 mike Rel3_5 $ (BRL)";
d1125 5
a1129 1
	if((f = cos(angles[4])) > 1.0e-20 || f < -1.0e-20 )  {
d1132 1
a1132 1
			angles[3] = -90;
d1134 1
a1134 1
			angles[3] = 90;
d1139 1
a1139 1
	if( unitv[1] < 0 )
@


9.1
log
@Release_3.5
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 8.5 89/04/06 20:39:57 mike Exp $ (BRL)";
d1583 1
d1585 5
d1598 1
a1605 6
		mat_idn(es_mat);

		/* for safety sake */
		es_menu = 0;
		es_edflag = -1;

d1610 1
d1613 7
a1619 5
	if( es_rec.u_id == ID_BSOLID ) {
		(void)printf("SPLINE may not work well\n");
		mat_idn(es_mat);
		es_menu = 0;
		es_edflag = -1;
a1620 1
	}
d1622 1
a1622 1
	if( es_rec.u_id == ID_ARS_A ) { 
d1627 3
a1629 2
		es_rec.s.s_type = es_rec.s.s_cgtype = ARS;
	}
d1631 3
a1633 5
	if( es_rec.u_id != ID_SOLID && es_rec.u_id != ID_ARS_A ) {
		(void)printf(
"ERROR - Should have a SOLID at bottom of path\n");
		return;
	}
d1635 9
a1643 2
	es_menu = 0;
	es_edflag = -1;
d1645 4
a1648 2
	if( es_rec.s.s_cgtype < 0 )
		es_rec.s.s_cgtype *= -1;
d1650 3
a1652 8
	if( es_rec.s.s_type == GENARB8 ) {
		/* find the comgeom arb type */
		if( (type = type_arb( &es_rec )) == 0 ) {
			(void)printf("%s: BAD ARB\n",es_rec.s.s_name);
			return;
		}

		es_rec.s.s_cgtype = type;
a1653 1

@


8.5
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 8.4 89/03/06 17:40:57 mike Locked $ (BRL)";
@


8.4
log
@ansii
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 8.3 89/01/16 22:56:06 mike Locked $ (BRL)";
d44 1
@


8.3
log
@Moved redraw() into dodraw.c
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 8.2 88/12/06 01:19:48 mike Locked $ (BRL)";
a47 1
extern int	printf();
@


8.2
log
@Converted to new db_*() routines.
@
text
@a4 1
 *	redraw		redraw a single solid, given matrix and record.
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/edsol.c,v 1.2 88/10/23 13:56:28 mike Exp $ (BRL)";
d52 2
a570 41

/*
 *  			R E D R A W
 *  
 *  Probably misnamed.
 */
struct solid *
redraw( sp, recp, mat )
struct solid *sp;
union record *recp;
mat_t	mat;
{
	int addr, bytes;

	if( sp == SOLID_NULL )
		return( sp );

	/* Remember displaylist location of previous solid */
	addr = sp->s_addr;
	bytes = sp->s_bytes;

	if( drawHsolid(
		sp,
		sp->s_soldash,
		sp->s_last,
		mat,
		recp,
		sp->s_regionid
	) != 1 )  {
		(void)printf("redraw():  error in drawHsolid()\n");
		return(sp);
	}

	/* Release previous chunk of displaylist, and rewrite control list */
	memfree( &(dmp->dmr_map), (unsigned)bytes, (unsigned long)addr );
	dmaflag = 1;
	return( sp );
}



@


8.1
log
@Release_3.0
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 7.5 88/09/20 01:33:08 reschly Exp $ (BRL)";
d43 1
a45 1
#include "./objdir.h"
d634 1
a634 1
	db_getrec( illump->s_path[illump->s_last], &es_orig, 0 );
d1649 1
a1649 1
	db_getrec( illump->s_path[illump->s_last], &es_rec, 0 );
d1661 1
a1661 1
		db_getrec( illump->s_path[illump->s_last], &trec, 1 );
@


7.5
log
@shortened ARB CONTROL MENU to ARB MENU to give it a better chance of fitting..
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 7.4 88/05/15 23:05:06 reschly Locked $ (BRL)";
@


7.4
log
@lint fixes
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 7.3 87/11/14 05:02:42 mike Locked $ (BRL)";
d313 1
a313 1
	{ "ARB CONTROL MENU", (void (*)())NULL, 0 },
@


7.3
log
@Added dir_getmrec() to get all records for an item,
using malloc.
Added total path matrix as explicit arg to redraw().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 7.2 87/11/05 05:05:46 mike Locked $ (BRL)";
d60 1
d1706 1
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 7.1 87/11/03 00:00:40 mike Rel $ (BRL)";
d576 1
a576 1
redraw( sp, recp )
d579 1
a592 1

d594 1
a594 1
		es_mat,
d935 1
a935 1
		illump = redraw( illump, &es_rec );
d1123 1
a1123 1
	illump = redraw( illump, &es_rec );
d1775 1
a1775 1
	illump = redraw( illump, &es_rec );
@


7.1
log
@Release 2.3
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 6.2 87/09/26 01:02:11 mike Exp $ (BRL)";
d39 1
a39 1
#include "./machine.h"	/* special copy */
d66 4
a69 4
float	es_scale;		/* scale factor */
float 	es_para[3];		/* keyboard input parameter changes */
float	es_peqn[7][4];		/* ARBs defining plane equations */
float	es_m[3];		/* edge(line) slope */
a621 1
	float *op;
d745 2
a746 1
	register float *op;
d863 3
a865 3
			op = &es_peqn[es_menu][0];	/* es_menu==plane of interest */
			VMOVE( work, op );
			MAT4X3VEC( op, invsolr, work );
d877 3
a879 3
				op = &es_peqn[es_menu][0];
				VMOVE( work, op );
				MAT4X3VEC( op, modelchanges, work );
d905 1
a905 1
			es_peqn[es_menu][3]=VDOT(op,tempvec);	
d914 3
a916 3
			op = &es_peqn[es_menu][0];
			VMOVE( work, op );
			MAT4X3VEC( op, incr_change, work );
d928 1
a928 1
			es_peqn[es_menu][3]=VDOT(op,tempvec);	
d1135 1
a1135 1
 * angles = pointer to 5 floats to store angles
d1140 2
a1141 1
register float *angles, *unitv;
d1209 2
a1210 2
	static float ma;
	static float r1, r2;
d1212 1
a1212 1
	static float ang[5];
d1385 3
a1387 3
	register float *op;
	static float ma,mb;
	static float mr1,mr2;
@


6.2
log
@Added protection to acos() calls.  On the Cray XMP, acos()
aborts the program if it gets an out-of-range argument.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 6.1 87/07/11 08:03:53 mike Locked $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 5.1 87/06/24 22:20:33 mike Rel $ (BRL)";
d1144 4
a1147 4
	/* direction cos */
	angles[X] = acos( unitv[X] ) * radtodeg;
	angles[Y] = acos( unitv[Y] ) * radtodeg;
	angles[Z] = acos( unitv[Z] ) * radtodeg;
d1149 8
d1158 2
@


5.1
log
@Release 1.24
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 4.5 87/02/13 00:07:31 mike Exp $ (BRL)";
@


4.5
log
@Release 1.20 -- First Formal Release
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 4.4 87/02/11 05:34:33 mike Exp $ (BRL)";
@


4.4
log
@Cray fixups
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 4.3 87/02/11 05:31:44 mike Locked $ (BRL)";
@


4.3
log
@Latest fixes from Keith
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 4.1 86/12/29 03:21:30 mike Rel1 $ (BRL)";
d75 3
a77 2
int arb_faces[5][24];	/* from edarb.c */
int arb_planes[5][24];	/* from edarb.c */
@


4.2
log
@Made sedit.h all externs, with storage defined in edsol.c
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 4.1 86/12/29 03:21:30 mike Locked $ (BRL)";
d223 1
a223 1
	{ "move face 236" , arb6_mv_face, 2 },
d281 1
a281 1
	{ "rotate face 236" , arb6_rot_face, 2 },
d339 1
a339 1
	{ 1,2,3,4, 2,3,6,0, 1,5,6,4, 1,2,5,0, 3,4,6,0, 0,0,0,0 },	/* arb6 */
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.23 86/12/28 23:02:33 mike Exp $ (BRL)";
d61 16
@


2.23
log
@Fix for Alliant C compiler bug
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.22 86/10/12 03:24:06 mike Exp $ (BRL)";
@


2.22
log
@strings.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.21 86/10/06 22:45:18 mike Locked $ (BRL)";
d638 9
a646 8
		VMOVE(&temprec.s_values[3], &es_rec.s.s_values[9]);
		VMOVE(&temprec.s_values[6], &es_rec.s.s_values[21]);
		VMOVE(&temprec.s_values[9], &es_rec.s.s_values[12]);
		VMOVE(&temprec.s_values[12], &es_rec.s.s_values[3]);
		VMOVE(&temprec.s_values[15], &es_rec.s.s_values[6]);
		VMOVE(&temprec.s_values[18], &es_rec.s.s_values[18]);
		VMOVE(&temprec.s_values[21], &es_rec.s.s_values[15]);
		es_rec.s = temprec;	/* struct copy */
@


2.21
log
@More acos() cleanup
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.20 86/10/06 22:02:57 mike Locked $ (BRL)";
d31 8
a38 3
#include	<stdio.h>
#include	<math.h>
#include	<string.h>
@


2.20
log
@Cleaned up some ugliness with using acos().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.19 86/09/10 01:39:05 mike Locked $ (BRL)";
d1130 9
a1138 3
	if((f = cos(angles[4])) > 1.0e-20 || f < -1.0e-20 )
		angles[3] = radtodeg * acos( unitv[X]/f );
	else
@


2.19
log
@Dender:  lots of additions for ARB face editing.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.18 86/08/12 06:49:29 mike Exp $ (BRL)";
d1119 1
a1119 1
	register int i;
d1122 3
a1124 2
	for( i=0; i<3; i++ ) 
		angles[i] = acos( unitv[i] ) * radtodeg;
d1130 2
a1131 2
	if(cos(angles[4]) != 0.0)
		angles[3] = radtodeg * acos( unitv[X]/cos(angles[4]) );
@


2.18
log
@Changed #includes for CC -I../h
@
text
@d12 1
d28 1
a28 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.17 86/07/18 02:41:44 mike Exp $ (BRL)";
d31 1
d45 2
d48 5
a52 2
static void	arb8_ed(), ars_ed(), ell_ed(), tgc_ed(), tor_ed(), spline_ed();
static void	arb7_ed(), arb6_ed(), arb5_ed(), arb4_ed();
d55 1
d57 15
a71 14
struct menu_item  arb8_menu[] = {
	{ "ARB8 MENU", (void (*)())NULL, 0 },
	{ "move edge 12", arb8_ed, 0 },
	{ "move edge 23", arb8_ed, 1 },
	{ "move edge 34", arb8_ed, 2 },
	{ "move edge 14", arb8_ed, 3 },
	{ "move edge 15", arb8_ed, 4 },
	{ "move edge 26", arb8_ed, 5 },
	{ "move edge 56", arb8_ed, 6 },
	{ "move edge 67", arb8_ed, 7 },
	{ "move edge 78", arb8_ed, 8 },
	{ "move edge 58", arb8_ed, 9 },
	{ "move edge 37", arb8_ed, 10 },
	{ "move edge 48", arb8_ed, 11 },
d75 15
a89 14
struct menu_item  arb7_menu[] = {
	{ "ARB7 MENU", (void (*)())NULL, 0 },
	{ "move edge 12", arb7_ed, 0 },
	{ "move edge 23", arb7_ed, 1 },
	{ "move edge 34", arb7_ed, 2 },
	{ "move edge 14", arb7_ed, 3 },
	{ "move edge 15", arb7_ed, 4 },
	{ "move edge 26", arb7_ed, 5 },
	{ "move edge 56", arb7_ed, 6 },
	{ "move edge 67", arb7_ed, 7 },
	{ "move edge 37", arb7_ed, 8 },
	{ "move edge 57", arb7_ed, 9 },
	{ "move edge 45", arb7_ed, 10 },
	{ "move point 5", arb7_ed, 11 },
d93 13
a105 12
struct menu_item  arb6_menu[] = {
	{ "ARB6 MENU", (void (*)())NULL, 0 },
	{ "move edge 12", arb6_ed, 0 },
	{ "move edge 23", arb6_ed, 1 },
	{ "move edge 34", arb6_ed, 2 },
	{ "move edge 14", arb6_ed, 3 },
	{ "move edge 15", arb6_ed, 4 },
	{ "move edge 25", arb6_ed, 5 },
	{ "move edge 36", arb6_ed, 6 },
	{ "move edge 46", arb6_ed, 7 },
	{ "move point 5", arb6_ed, 8 },
	{ "move point 6", arb6_ed, 9 },
d109 12
a120 11
struct menu_item  arb5_menu[] = {
	{ "ARB5 MENU", (void (*)())NULL, 0 },
	{ "move edge 12", arb5_ed, 0 },
	{ "move edge 23", arb5_ed, 1 },
	{ "move edge 34", arb5_ed, 2 },
	{ "move edge 14", arb5_ed, 3 },
	{ "move edge 15", arb5_ed, 4 },
	{ "move edge 25", arb5_ed, 5 },
	{ "move edge 35", arb5_ed, 6 },
	{ "move edge 45", arb5_ed, 7 },
	{ "move point 5", arb5_ed, 8 },
d124 7
a130 6
struct menu_item  arb4_menu[] = {
	{ "ARB4 MENU", (void (*)())NULL, 0 },
	{ "move point 1", arb4_ed, 0 },
	{ "move point 2", arb4_ed, 1 },
	{ "move point 3", arb4_ed, 2 },
	{ "move point 4", arb4_ed, 4 },
d179 11
d191 132
d324 1
a324 1
arb8_ed( arg )
d329 2
a332 1

d334 1
a334 1
arb7_ed( arg )
d344 2
d349 1
a349 1
arb6_ed( arg )
d364 2
d369 1
a369 1
arb5_ed( arg )
d379 2
d384 1
a384 1
arb4_ed( arg )
d389 2
d424 9
d434 98
d570 1
d586 3
d689 1
a689 1

d693 1
a693 19
		switch( es_type ) {

			case ARB8:
				menu_array[MENU_L1] = arb8_menu;
			break;

		 	case ARB7:
				menu_array[MENU_L1] = arb7_menu;
			break;
		 	case ARB6:
				menu_array[MENU_L1] = arb6_menu;
			break;
		 	case ARB5:
				menu_array[MENU_L1] = arb5_menu;
			break;
		 	case ARB4:
				menu_array[MENU_L1] = arb4_menu;
			break;
		}
d726 1
d738 180
d1692 49
@


2.17
log
@Modified to include halfspace.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.16 86/07/17 17:37:54 mike Exp $ (BRL)";
d33 8
a40 8
#include "../h/vmath.h"
#include "../h/db.h"
#include "sedit.h"
#include "ged.h"
#include "solid.h"
#include "objdir.h"
#include "dm.h"
#include "menu.h"
@


2.16
log
@Improved version of fixes from Davisson and Applin
Additional argument added to pathHmat().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.15 86/03/14 20:42:02 mike Exp $ (BRL)";
d446 2
d746 7
@


2.15
log
@Added support for the new spline format.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.14 86/03/10 21:38:16 mike Exp $ (BRL)";
d385 1
a385 1
	pathHmat( illump, es_mat );
d1201 1
a1201 1
	pathHmat( illump, es_mat );
@


2.14
log
@Latest revisions from Keith, including lots of new commands
and one-axis scaling.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.13 85/09/27 19:11:55 mike Exp $ (BRL)";
d1161 1
a1161 1
	if( es_rec.u_id == ID_B_SPL_HEAD ) {
@


2.13
log
@KAA code reorganization.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.12 85/09/14 05:36:26 mike Exp $ (BRL)";
d692 3
d703 1
a703 1
		" %c (%.4f, %.4f, %.4f)%c", \
d707 1
a707 1
		" %c (%.4f, %.4f, %.4f) Mag=%f%c", \
d711 1
a711 1
		" %s dir cos=(%.1f, %.1f, %.1f), rot=%.1f, fb=%.1f%c", \
d757 1
a757 1
			" r1=%f, r2=%f%c", r1, r2, '\0' );
d782 1
a782 1
				for(i=3; i<=3*length; i+=3) {
d873 1
a873 1
			" c = %f, d = %f%c",
@


2.12
log
@Lint-inspired cleanup.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.11 85/08/26 17:16:04 mike Exp $ (BRL)";
d380 1
a380 21
		/* point notation - use temprec record */
		for(i=3; i<=21; i+=3) {
			op = &temprec.s_values[i];
			VADD2(op, op, &es_rec.s.s_values[0]);
		}
		type -= 4;	/* ARB4 at location 0, ARB5 at 1, etc */
		for(i=0; i<6; i++) {
			if(arb_faces[type][i*4] == -1)
				break;	/* faces are done */
			p1 = arb_faces[type][i*4];
			p2 = arb_faces[type][i*4+1];
			p3 = arb_faces[type][i*4+2];
			if(planeqn(i, p1, p2, p3, &temprec)) {
				(void)printf("No eqn for face %d%d%d%d\n",
					p1+1,p2+1,p3+1,arb_faces[type][i*4+3]+1);
				return;
			}
/*
printf("peqn[%d][]: %.4f %.4f %.4f %.4f\n",i,es_peqn[i][0],es_peqn[i][1],es_peqn[i][2],es_peqn[i][3]);
*/
		}
d657 1
a657 1
		redo_planes();
d1209 3
a1211 2
/* 	REDO_PLANES()
 *		redo the plane (face) equations for an arb
d1213 3
a1215 1
redo_planes( )
d1218 1
a1218 2
	register float *op;
	register int i, type, p1, p2, p3;
a1219 3
	type = es_rec.s.s_cgtype;
	temprec = es_rec.s;		/* struct copy */

d1222 1
d1224 1
a1224 2
		op = &temprec.s_values[i];
		VADD2(op, op, &es_rec.s.s_values[0]);
@


2.11
log
@Latest solid editing improvements from KAA.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.9 85/07/30 01:17:41 mike Exp $ (BRL)";
d322 1
a322 1
	union record temprec;	/* copy of solid record to determine type */
d347 1
a347 1
	temprec = es_rec;
d357 8
a364 8
		VMOVE(&temprec.s.s_values[3], &es_rec.s.s_values[9]);
		VMOVE(&temprec.s.s_values[6], &es_rec.s.s_values[21]);
		VMOVE(&temprec.s.s_values[9], &es_rec.s.s_values[12]);
		VMOVE(&temprec.s.s_values[12], &es_rec.s.s_values[3]);
		VMOVE(&temprec.s.s_values[15], &es_rec.s.s_values[6]);
		VMOVE(&temprec.s.s_values[18], &es_rec.s.s_values[18]);
		VMOVE(&temprec.s.s_values[21], &es_rec.s.s_values[15]);
		es_rec = temprec;
d376 1
a376 1
		temprec = es_rec;
d382 1
a382 1
			op = &temprec.s.s_values[i];
d387 1
a387 1
			if(faces[type][i*4] == -1)
d389 4
a392 4
			p1 = faces[type][i*4];
			p2 = faces[type][i*4+1];
			p3 = faces[type][i*4+2];
			if(planeqn(i, p1, p2, p3, &temprec.s)) {
d394 1
a394 1
					p1+1,p2+1,p3+1,faces[type][i*4+3]+1);
d803 1
a803 1
			break;
a807 1
			break;
a812 1
			break;
a816 1
			break;
a821 1
			break;
a826 2
			break;

d1234 2
a1235 1
	union record temprec;
a1236 1
	float *op;
d1239 1
a1239 1
	temprec = es_rec;
d1244 1
a1244 1
		op = &temprec.s.s_values[i];
d1249 1
a1249 1
		if(faces[type][i*4] == -1)
d1251 4
a1254 4
		p1 = faces[type][i*4];
		p2 = faces[type][i*4+1];
		p3 = faces[type][i*4+2];
		if(planeqn(i, p1, p2, p3, &temprec.s)) {
d1256 1
a1256 1
				p1+1,p2+1,p3+1,faces[type][i*4+3]+1);
@


2.10
log
@Changed to use common ../h/vmath.h
@
text
@d128 3
d150 1
d675 4
d762 6
d1078 66
d1154 2
a1155 1
	register int i;
d1184 2
a1185 2
	if( es_rec.u_id == ID_ARS_A || es_rec.u_id == ID_B_SPL_HEAD )  {
		(void)printf("ARS or SPLINE may not work well\n");
d1192 9
a1200 1
	if( es_rec.u_id != ID_SOLID )  {
d1209 14
d1233 35
@


2.9
log
@Change to support new ARB editing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.8 85/06/06 22:33:19 mike Exp $ (BRL)";
d32 2
a33 1
#include "ged_types.h"
a35 1
#include "../h/vmath.h"
@


2.8
log
@KAA, added f_edgedir() support
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.7 85/05/29 23:17:14 mike Exp $ (BRL)";
d44 2
a45 1
static void	arb_ed(), ars_ed(), ell_ed(), tgc_ed(), tor_ed(), spline_ed();
d49 14
a62 14
struct menu_item  arb_menu[] = {
	{ "ARB MENU", (void (*)())NULL, 0 },
	{ "move edge 12", arb_ed, 12 },
	{ "move edge 23", arb_ed, 23 },
	{ "move edge 34", arb_ed, 43 },
	{ "move edge 14", arb_ed, 14 },
	{ "move edge 15", arb_ed, 15 },
	{ "move edge 26", arb_ed, 26 },
	{ "move edge 56", arb_ed, 56 },
	{ "move edge 67", arb_ed, 67 },
	{ "move edge 78", arb_ed, 87 },
	{ "move edge 58", arb_ed, 58 },
	{ "move edge 37", arb_ed, 37 },
	{ "move edge 48", arb_ed, 48 },
d66 55
d130 1
a130 1
	{ "move end H (rt)", tgc_ed, MENUMH },
d164 1
a164 1
arb_ed( arg )
a168 1
	newedge = 1;
d173 52
a246 1

d318 4
a341 2
	if(es_rec.s.s_cgtype < 0)
		es_rec.s.s_cgtype *= -1;
d343 57
d433 19
a451 1
		menu_array[MENU_L1] = arb_menu;
d595 1
d741 2
d749 2
d780 39
a818 3
		for(i=3; i<=21; i+=3) {
			VADD2( work, &local.s_values[i], &local.s_values[0] );
			PR_PT( i/3, '1'+(i/3), work );
a819 1
		es_nlines = 8;
@


2.7
log
@Added MENU_L2 menu for solid/object edit buttons,
moved menus to left side of screen.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.6 85/05/29 15:25:11 mike Exp $ (BRL)";
d74 2
a75 1
	{ "move end of H", tgc_ed, MENUMH },
d127 2
d388 18
@


2.6
log
@Added extra checking for bad divisions to pr_solid().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.5 85/05/10 00:54:22 mike Exp $ (BRL)";
d49 1
a49 1
	{ "GENERAL ARB MENU", (void (*)())NULL, 0 },
d86 1
a86 1
	{ "GENERAL ELLIPSOID MENU", (void (*)())NULL, 0 },
d246 1
d260 1
a260 1
	menu_array[MENU_L2] = MENU_NULL;
@


2.5
log
@Added multi-menu capability, added dmr_window and dmr_debug,
deleted dmr_restart.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.4 85/05/03 01:25:34 mike Exp $ (BRL)";
d501 4
d534 1
d536 1
a536 1
	/* convert to local units */
d539 1
a539 1
		VMOVE(&sp->s_values[i], work);
d545 3
a547 3
		r1 = MAGNITUDE(&sp->s_tor_A);
		r2 = MAGNITUDE(&sp->s_tor_H);
		PR_PT( 0, 'V', &sp->s_tor_V );
d552 6
a557 2
		VSCALE( unitv, &sp->s_tor_H, 1.0/r2 );	/* N == H^ */
		PR_PT( 2, 'N', unitv );
d562 3
a564 3
		PR_PT( 4, 'I', &sp->s_tor_C );
		PR_PT( 5, 'O', &sp->s_tor_E );
		PR_PT( 6, 'H', &sp->s_tor_H );
d569 1
a569 1
		PR_PT( 0, '1', &sp->s_values[0] );
d571 1
a571 1
			VADD2( work, &sp->s_values[i], &sp->s_values[0] );
d578 1
a578 1
		PR_PT( 0, 'V', &sp->s_ell_V );
d580 2
a581 2
		ma = MAGNITUDE( &sp->s_ell_A );
		PR_VECM( 1, 'A', &sp->s_ell_A, ma );
d583 7
a589 3
		VSCALE( unitv, &sp->s_ell_A, 1.0/ma );
		findang( ang, unitv );
		PR_ANG( 2, "A", ang );
d591 2
a592 2
		ma = MAGNITUDE( &sp->s_ell_B );
		PR_VECM( 3, 'B', &sp->s_ell_B, ma );
d594 7
a600 3
		VSCALE( unitv, &sp->s_ell_B, 1.0/ma );
		findang( ang, unitv );
		PR_ANG( 4, "B", ang );
d602 2
a603 2
		ma = MAGNITUDE( &sp->s_ell_C );
		PR_VECM( 5, 'C', &sp->s_ell_C, ma );
d605 7
a611 3
		VSCALE( unitv, &sp->s_ell_C, 1.0/ma );
		findang( ang, unitv );
		PR_ANG( 6, "C", ang );
d617 1
a617 1
		PR_PT( 0, 'V', &sp->s_tgc_V );
d619 2
a620 2
		ma = MAGNITUDE( &sp->s_tgc_H );
		PR_VECM( 1, 'H', &sp->s_tgc_H, ma );
d622 7
a628 3
		VSCALE( unitv, &sp->s_tgc_H, 1.0/ma );
		findang( ang, unitv );
		PR_ANG( 2, "H", ang );
d630 2
a631 2
		ma = MAGNITUDE( &sp->s_tgc_A );
		PR_VECM( 3, 'A', &sp->s_tgc_A, ma );
d633 2
a634 2
		ma = MAGNITUDE( &sp->s_tgc_B );
		PR_VECM( 4, 'B', &sp->s_tgc_B, ma );
d638 2
a639 2
			MAGNITUDE( &sp->s_tgc_C ),
			MAGNITUDE( &sp->s_tgc_D ), '\0' );
d642 1
a642 1
		VCROSS( unitv, &sp->s_tgc_C, &sp->s_tgc_D );
a648 6
	}

	/* convert back to base units */
	for(i=0; i<24; i+=3) {
		VSCALE(work, &sp->s_values[i], local2base);
		VMOVE(&sp->s_values[i], work);
@


2.4
log
@Fixed redraw() to preserve region ID.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.3 85/03/15 05:05:11 mike Exp $ (BRL)";
d238 23
a260 2
	/* put up menu header */
	MENU_ON( FALSE );
d264 1
a264 1
		MENU_INSTALL( arb_menu );
d267 1
a267 1
		MENU_INSTALL( tgc_menu );
d270 1
a270 1
		MENU_INSTALL( tor_menu );
d273 1
a273 1
		MENU_INSTALL( ell_menu );
d276 1
a276 1
		MENU_INSTALL( ars_menu );
d279 1
a279 1
		MENU_INSTALL( spline_menu );
a281 11

	/* Finally, enter solid edit state */
	dmp->dmr_light( LIGHT_ON, BE_ACCEPT );
	dmp->dmr_light( LIGHT_ON, BE_REJECT );
	dmp->dmr_light( LIGHT_OFF, BE_S_ILLUMINATE );

	(void)chg_state( ST_S_PICK, ST_S_EDIT, "Keyboard illuminate");
	es_edflag = IDLE;
	sedraw = 1;

	button( BE_S_EDIT );	/* Drop into edit menu right away */
@


2.3
log
@Added mapping between region ID and color + database handle.
Reorganized to support regular expressions on the command line.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.2 85/03/12 04:06:54 mike Exp $ (BRL)";
d184 2
a185 2
		illump->s_soldash,
		illump->s_last,
d188 1
a188 1
		0
@


2.2
log
@Paul Stay's Spline code
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: edsol.c,v 2.1 85/03/11 23:56:00 mike Prod $ (BRL)";
d187 3
a189 2
		recp ) != 1
	)  {
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d44 1
a44 1
static void	arb_ed(), ars_ed(), ell_ed(), tgc_ed(), tor_ed();
d99 5
d105 1
d155 8
d256 3
d799 1
a799 1
	int i;
d805 1
d827 8
@


1.7
log
@USNA changes which formalize state changes.
@
text
@d10 2
a11 1
 *	plane
d13 12
d26 3
d33 1
a33 1
#include "db.h"
d35 1
a35 1
#include "vmath.h"
d38 1
a38 1
#include "dir.h"
d46 2
d180 1
a180 1
	memfree( &(dmp->dmr_map), bytes, addr );
d191 1
d434 1
a434 1
		printf("sedit():  unknown edflag = %d.\n", es_edflag );
d473 1
a473 1
#define PR_PT(ln,title,base)	sprintf( &es_display[ln*ES_LINELEN],\
d477 1
a477 1
#define PR_VECM(ln,title,base,mag)	sprintf( &es_display[ln*ES_LINELEN],\
d481 1
a481 1
#define PR_ANG(ln,str,base)	sprintf( &es_display[ln*ES_LINELEN],\
d516 1
a516 1
		sprintf( &es_display[1*ES_LINELEN],
d610 1
d779 1
d826 1
a826 1
	pr_solid( &es_rec );
a828 1

@


1.6
log
@Keith's global/local units additions
@
text
@d230 1
a230 1
	state = ST_S_EDIT;
@


1.5
log
@path scaling fixes from Keith
@
text
@a27 2
static void	findang();

d433 1
a433 1
static void
d484 6
d578 6
d754 55
@


1.4
log
@pre-Keith version
@
text
@d203 3
d264 4
a267 1
			es_scale = es_para[0];
d280 6
a285 2
			/* Keyboard parameter */
			VMOVE(es_rec.s.s_values, es_para);
d299 3
a301 1
			VSUB2(&es_rec.s.s_tgc_H, es_para, &es_rec.s.s_tgc_V);
d346 5
a350 2
		if( inpara )
			editarb( es_para );
d362 1
a362 1
			mat_inv( invsolr, modelchanges );
d375 1
d383 3
d461 1
a461 1
		" %c (%.4f, %.4f, %.4f) mag=%f%c", \
d591 3
a593 1
		if( inpara )
d595 2
d604 3
a606 1
		if(inpara)
d608 1
d643 5
a647 3
		if(inpara)
			es_scale = es_para[0] /
					MAGNITUDE(op);
d663 3
a665 1
			if(inpara)
d667 1
d673 3
a675 1
			if(inpara)
d677 1
d690 3
a692 1
			if(inpara)
d694 1
d700 3
a702 1
			if(inpara)
d704 1
d713 3
a715 1
		if(inpara)
d717 2
d725 3
a727 1
		if(inpara)
d729 1
d735 3
a737 1
		if(inpara)
d739 1
@


1.3
log
@Multiple simultaneous display manager support
@
text
@d17 1
a17 1
#include "3d.h"
d164 1
a164 1
	memfree( &(dmp->dmr_map), addr, bytes );
@


1.2
log
@Vector lists saved, multiple display managers supported.
@
text
@d164 1
a164 1
	freevgcore( addr, bytes );
@


1.1
log
@Initial revision
@
text
@d225 3
a227 3
	dm_light( LIGHT_ON, BE_ACCEPT );
	dm_light( LIGHT_ON, BE_REJECT );
	dm_light( LIGHT_OFF, BE_S_ILLUMINATE );
@
