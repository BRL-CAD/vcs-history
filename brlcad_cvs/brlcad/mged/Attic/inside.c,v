head	11.50;
access;
symbols
	ansi-20040405-merged:11.46.2.2
	postmerge-20040405-ansi:11.48
	premerge-20040404-ansi:11.47
	postmerge-autoconf:11.47
	autoconf-freeze:11.46.10.2
	premerge-autoconf:11.47
	postmerge-20040315-windows:11.47
	premerge-20040315-windows:11.47
	windows-20040315-freeze:11.46.4.1
	autoconf-20031203:11.46
	autoconf-20031202:11.46
	autoconf-branch:11.46.0.10
	phong-branch:11.46.0.8
	photonmap-branch:11.46.0.6
	rel-6-1-DP:11.46
	windows-branch:11.46.0.4
	rel-6-0-2:11.43
	ansi-branch:11.46.0.2
	rel-6-0-1-branch:11.43.0.2
	hartley-6-0-post:11.45
	hartley-6-0-pre:11.43
	rel-6-0-1:11.43
	rel-6-0:11.41
	rel-5-4:11.27.2.1
	offsite-5-3-pre:11.37
	rel-5-3:11.27.2.1
	rel-5-2:11.27
	rel-5-1-branch:11.27.0.2
	rel-5-1:11.27
	rel-5-0:11.22
	rel-5-0-beta:11.21
	rel-4-5:11.20
	ctj-4-5-post:11.19
	ctj-4-5-pre:11.19
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.50
date	2004.05.21.17.47.44;	author morrison;	state dead;
branches;
next	11.49;

11.49
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.48;

11.48
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.47;

11.47
date	2004.02.02.17.39.33;	author morrison;	state Exp;
branches;
next	11.46;

11.46
date	2002.08.20.17.08.23;	author jra;	state Exp;
branches
	11.46.2.1
	11.46.4.1
	11.46.10.1;
next	11.45;

11.45
date	2002.08.17.10.37.03;	author morrison;	state Exp;
branches;
next	11.44;

11.44
date	2002.08.15.20.55.35;	author hartley;	state Exp;
branches;
next	11.43;

11.43
date	2002.08.09.13.16.45;	author jra;	state Exp;
branches;
next	11.42;

11.42
date	2002.05.31.20.29.19;	author jra;	state Exp;
branches;
next	11.41;

11.41
date	2001.10.02.19.24.32;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	2001.06.01.19.23.24;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	2001.04.05.19.35.45;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2001.03.23.22.05.35;	author jra;	state Exp;
branches;
next	11.37;

11.37
date	2001.02.01.21.39.32;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	2001.01.17.21.33.45;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	2000.10.24.19.59.23;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	2000.10.24.19.05.07;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	2000.10.20.05.04.39;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	2000.09.08.14.26.18;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	2000.09.08.05.55.49;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	2000.08.19.03.10.15;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.08.01.13.12.01;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	2000.06.30.19.58.09;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.06.09.12.51.45;	author jra;	state Exp;
branches
	11.27.2.1;
next	11.26;

11.26
date	99.12.30.20.00.13;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	99.12.29.23.23.23;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	99.11.24.14.26.42;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	99.11.03.21.29.22;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	99.09.01.18.55.10;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	99.02.08.16.32.58;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	97.04.08.13.20.27;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	97.02.28.21.38.11;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	96.11.15.16.27.56;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	96.10.01.17.26.29;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.09.25.20.10.14;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.09.23.18.25.15;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.08.28.15.07.03;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.03.01.19.31.04;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.02.18.03.09.02;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.49;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.14;	author mike;	state Rel4_4;
branches;
next	10.15;

10.15
date	94.12.16.19.36.54;	author gdurf;	state Exp;
branches;
next	10.14;

10.14
date	94.11.16.16.57.52;	author jra;	state Exp;
branches;
next	10.13;

10.13
date	94.09.02.00.29.59;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.08.09.15.10.51;	author gdurf;	state Exp;
branches;
next	10.11;

10.11
date	94.06.23.17.49.41;	author jra;	state Exp;
branches;
next	10.10;

10.10
date	94.06.13.19.07.45;	author gdurf;	state Exp;
branches;
next	10.9;

10.9
date	94.05.11.15.22.50;	author jra;	state Exp;
branches;
next	10.8;

10.8
date	94.05.06.15.47.35;	author jra;	state Exp;
branches;
next	10.7;

10.7
date	94.04.09.19.48.14;	author jra;	state Exp;
branches;
next	10.6;

10.6
date	93.09.29.16.14.20;	author jra;	state Exp;
branches;
next	10.5;

10.5
date	93.08.25.08.14.18;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	92.03.25.15.53.24;	author mmark;	state Exp;
branches;
next	10.3;

10.3
date	92.03.21.05.31.54;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.03.20.15.26.00;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.47;	author mike;	state Rel4_0;
branches;
next	9.5;

9.5
date	91.08.30.17.17.02;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.08.00.31.20;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.04.21.06.06.10;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.27.22.48.42;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.03.20;	author mike;	state Rel3_5;
branches;
next	8.8;

8.8
date	89.05.18.00.00.35;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.05.17.23.34.36;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.05.11.21.42.21;	author phil;	state Exp;
branches;
next	8.5;

8.5
date	89.04.07.02.31.41;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.06.20.40.06;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.16.22.51.46;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.26.02;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.36.58;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.09.19.22.48.39;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.05.15.23.05.12;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.06.16;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.01.07;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.04.22;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.21.10;	author mike;	state Rel;
branches;
next	4.3;

4.3
date	87.02.13.00.07.57;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.11.05.38.41;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.22.01;	author mike;	state Rel1;
branches;
next	2.2;

2.2
date	86.09.23.17.41.34;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	86.09.09.22.06.26;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.08.12.06.49.52;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.03.10.21.38.37;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.09.27.19.12.24;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	85.09.14.05.36.50;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.09.12.00.25.55;	author mike;	state Exp;
branches;
next	;

11.27.2.1
date	2001.02.01.21.31.54;	author bparker;	state Exp;
branches;
next	;

11.46.2.1
date	2002.09.19.18.02.03;	author morrison;	state Exp;
branches;
next	11.46.2.2;

11.46.2.2
date	2004.03.17.21.22.00;	author morrison;	state Exp;
branches;
next	;

11.46.4.1
date	2004.03.11.23.46.35;	author morrison;	state Exp;
branches;
next	;

11.46.10.1
date	2004.02.12.18.34.14;	author erikg;	state Exp;
branches;
next	11.46.10.2;

11.46.10.2
date	2004.03.15.14.07.38;	author erikg;	state Exp;
branches;
next	;


desc
@Routine to make a solid inside another solid
@


11.50
log
@moved to src/mged/
@
text
@/*
 *			I N S I D E 
 *
 *	Given an outside solid and desired thicknesses, finds
 *	an inside solid to produce those thicknesses.
 *
 * Functions -
 *	f_inside	reads all the input required
 *	arbin		finds inside of arbs
 *	tgcin		finds inside of tgcs
 *	ellgin		finds inside of ellgs
 *	torin		finds inside of tors
 *
 *  Authors -
 *	Keith A Applin
 *	Michael Markowski
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/inside.c,v 11.49 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <signal.h>
#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "./ged.h"
#include "./sedit.h"
#include "externs.h"
#include "./mged_solid.h"
#include "./mged_dm.h"
#include "./cmd.h"

BU_EXTERN( void nmg_invert_shell , ( struct shell *s , const struct bn_tol *tol ) );

extern struct rt_db_internal	es_int;	/* from edsol.c */
extern struct bn_tol		mged_tol;	/* from ged.c */

extern char	**promp;	/* pointer to a pointer to a char */

static char *p_arb4[] = {
	"Enter thickness for face 123: ",
	"Enter thickness for face 124: ",
	"Enter thickness for face 234: ",
	"Enter thickness for face 134: ",
};

static char *p_arb5[] = {
	"Enter thickness for face 1234: ",
	"Enter thickness for face 125: ",
	"Enter thickness for face 235: ",
	"Enter thickness for face 345: ",
	"Enter thickness for face 145: ",
};

static char *p_arb6[] = {
	"Enter thickness for face 1234: ",
	"Enter thickness for face 2356: ",
	"Enter thickness for face 1564: ",
	"Enter thickness for face 125: ",
	"Enter thickness for face 346: ",
};

static char *p_arb7[] = {
	"Enter thickness for face 1234: ",
	"Enter thickness for face 567: ",
	"Enter thickness for face 145: ",
	"Enter thickness for face 2376: ",
	"Enter thickness for face 1265: ",
	"Enter thickness for face 3475: ",
};

static char *p_arb8[] = {
	"Enter thickness for face 1234: ",
	"Enter thickness for face 5678: ",
	"Enter thickness for face 1485: ",
	"Enter thickness for face 2376: ",
	"Enter thickness for face 1265: ",
	"Enter thickness for face 3478: ",
};

static char *p_tgcin[] = {
	"Enter thickness for base (AxB): ",
	"Enter thickness for top (CxD): ",
	"Enter thickness for side: ",
};

static char *p_partin[] = {
	"Enter thickness for body: ",
};

static char *p_rpcin[] = {
	"Enter thickness for front plate (contains V): ",
	"Enter thickness for back plate: ",
	"Enter thickness for top plate: ",
	"Enter thickness for body: ",
};

static char *p_rhcin[] = {
	"Enter thickness for front plate (contains V): ",
	"Enter thickness for back plate: ",
	"Enter thickness for top plate: ",
	"Enter thickness for body: ",
};

static char *p_epain[] = {
	"Enter thickness for top plate: ",
	"Enter thickness for body: ",
};

static char *p_ehyin[] = {
	"Enter thickness for top plate: ",
	"Enter thickness for body: ",
};

static char *p_etoin[] = {
	"Enter thickness for body: ",
};

static char *p_nmgin[] = {
	"Enter thickness for shell: ",
};

/*	F _ I N S I D E ( ) :	control routine...reads all data
 */
int
f_inside(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int i;
	struct directory	*dp;
	struct directory	*outdp;
	mat_t newmat;
	int	cgtype;		/* cgtype ARB 4..8 */
	int	nface;
	fastf_t	thick[6];
	plane_t	planes[6];
	struct rt_db_internal	intern;
	char	*newname;
	int arg = 1;
	int status = TCL_OK;

	CHECK_DBI_NULL;

	if(argc < 1){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help inside");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else
	  return TCL_OK;

	/* SCHEME:
	 *	if in solid edit, use "edited" solid
	 *	if in object edit, use "key" solid
	 *	else get solid name to use
	 */

	if( state == ST_S_EDIT ) {
	  /* solid edit mode */
	  /* apply es_mat editing to parameters */
	  transform_editing_solid( &intern, es_mat, &es_int, 0 );
	  outdp = LAST_SOLID(illump);

	  if( argc < arg+1 ) {
		  Tcl_AppendResult(interp, "You are in Prim Edit mode, using edited primitive as outside primitive: ", (char *)NULL);
		  add_solid_path_to_result( interp, illump );
		  Tcl_AppendResult(interp, "\n", (char *)NULL);
	  }
	}  else if( state == ST_O_EDIT ) {
	  /* object edit mode */
	  if( illump->s_Eflag ) {
	     Tcl_AppendResult(interp, "Cannot find inside of a processed (E'd) region\n",
			      (char *)NULL);
	     status = TCL_ERROR;
	     goto end;
	  }
	  /* use the solid at bottom of path (key solid) */
	  /* apply es_mat and modelchanges editing to parameters */
	  bn_mat_mul(newmat, modelchanges, es_mat);
	  transform_editing_solid( &intern, newmat, &es_int, 0 );
	  outdp = LAST_SOLID(illump);
	  if( argc < arg+1 ) {
		  Tcl_AppendResult(interp, "You are in Object Edit mode, using key solid as outside solid: ", (char *)NULL);
		  add_solid_path_to_result( interp, illump );
		  Tcl_AppendResult(interp, "\n", (char *)NULL);
	  }
	} else {
	  /* Not doing any editing....ask for outside solid */
	  if( argc < arg+1 ) {
	    Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter name of outside solid: ",
			     (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	  if( (outdp = db_lookup( dbip,  argv[arg], LOOKUP_NOISY )) == DIR_NULL ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  ++arg;

	  if( rt_db_get_internal( &intern, outdp, dbip, bn_mat_identity, &rt_uniresource ) < 0 ) {
	    (void)signal( SIGINT, SIG_IGN );
	    TCL_READ_ERR_return;
	  }
	}

	if( intern.idb_type == ID_ARB8 )  {
	  /* find the comgeom arb type, & reorganize */
	  int uvec[8],svec[11];

	  if( rt_arb_get_cgtype( &cgtype , intern.idb_ptr, &mged_tol , uvec , svec ) == 0 ) {
	    Tcl_AppendResult(interp, outdp->d_namep, ": BAD ARB\n", (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }

	  /* must find new plane equations to account for
	   * any editing in the es_mat matrix or path to this solid.
	   */
	  if( rt_arb_calc_planes( planes, intern.idb_ptr, cgtype, &mged_tol ) < 0 )  {
	    Tcl_AppendResult(interp, "rt_arb_calc_planes(", outdp->d_namep,
			     "): failed\n", (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	}
	/* "intern" is now loaded with the outside solid data */

	/* get the inside solid name */
	if( argc < arg+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter name of the inside solid: ",
			   (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}
	if( db_lookup( dbip, argv[arg], LOOKUP_QUIET ) != DIR_NULL ) {
	  Tcl_AppendResult(interp, "you are attempting to use ", argv[arg],
		" as the inside solid.\n", "(Note that if you are in an edit mode",
		" the outside solid will be the solid you are editing)\n", (char *)NULL );
	  status = TCL_ERROR;
	  goto end;
	}
	if( dbip->dbi_version < 5 && (int)strlen(argv[arg]) >= NAMESIZE )  {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "Database version 4 names are limited to %d characters\n", NAMESIZE-1);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	  status = TCL_ERROR;
	  goto end;
	}
	newname = argv[arg];
	++arg;

	/* get thicknesses and calculate parameters for newrec */
	switch( intern.idb_type )  {

	case ID_ARB8:
	    {
	    	struct rt_arb_internal *arb =
			(struct rt_arb_internal *)intern.idb_ptr;

		nface = 6;

		switch( cgtype ) {
		case 8:
			promp = p_arb8;
			break;

		case 7:
			promp = p_arb7;
			break;

		case 6:
			promp = p_arb6;
			nface = 5;
			VMOVE( arb->pt[5], arb->pt[6] );
			break;

		case 5:
			promp = p_arb5;
			nface = 5;
			break;

		case 4:
			promp = p_arb4;
			nface = 4;
			VMOVE( arb->pt[3], arb->pt[4] );
			break;
		}

		for(i=0; i<nface; i++) {
		  if( argc < arg+1 ) {
		    Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
		    status = TCL_ERROR;
		    goto end;
		  }
		  thick[i] = atof(argv[arg]) * local2base;
		  ++arg;
		}

		if( arbin(&intern, thick, nface, cgtype, planes) ){
		  status = TCL_ERROR;
		  goto end;
		}
		break;
	    }

	case ID_TGC:
	  promp = p_tgcin;
	  for(i=0; i<3; i++) {
	    if( argc < arg+1 ) {
	      Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	    thick[i] = atof( argv[arg] ) * local2base;
	    ++arg;
	  }

	  if( tgcin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_ELL:
	  if( argc < arg+1 ) {
	    Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter desired thickness: ", (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	  thick[0] = atof( argv[arg] ) * local2base;
	  ++arg;

	  if( ellgin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_TOR:
	  if( argc < arg+1 ) {
	    Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter desired thickness: ", (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	  thick[0] = atof( argv[arg] ) * local2base;
	  ++arg;

	  if( torin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_PARTICLE:
	  promp = p_partin;
	  for (i = 0; i < 1; i++) {
	    if( argc < arg+1 ) {
	      Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	    thick[i] = atof( argv[arg] ) * local2base;
	    ++arg;
	  }

	  if( partin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;
	  
	case ID_RPC:
	  promp = p_rpcin;
	  for (i = 0; i < 4; i++) {
	    if( argc < arg+1 ) {
	      Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	    thick[i] = atof( argv[arg] ) * local2base;
	    ++arg;
	  }

	  if( rpcin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_RHC:
	  promp = p_rhcin;
	  for (i = 0; i < 4; i++) {
	    if( argc < arg+1 ) {
	      Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	    thick[i] = atof( argv[arg] ) * local2base;
	    ++arg;
	  }

	  if( rhcin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_EPA:
	  promp = p_epain;
	  for (i = 0; i < 2; i++) {
	    if( argc < arg+1 ) {
	      Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	    thick[i] = atof( argv[arg] ) * local2base;
	    ++arg;
	  }

	  if( epain(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_EHY:
	  promp = p_ehyin;
	  for (i = 0; i < 2; i++) {
	    if( argc < arg+1 ) {
	      Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	    thick[i] = atof( argv[arg] ) * local2base;
	    ++arg;
	  }
	  
	  if( ehyin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_ETO:
	  promp = p_etoin;
	  for (i = 0; i < 1; i++) {
	    if( argc < arg+1 ) {
	      Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	    thick[i] = atof( argv[arg] ) * local2base;
	    ++arg;
	  }

	  if( etoin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_NMG:
	  promp = p_nmgin;
	  if( argc < arg+1 ) {
	    Tcl_AppendResult(interp, MORE_ARGS_STR, promp[0], (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	  thick[0] = atof( argv[arg] ) * local2base;
	  ++arg;
	  if( nmgin( &intern , thick[0] ) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	default:
	  Tcl_AppendResult(interp, "Cannot find inside for '",
			   rt_functab[intern.idb_type].ft_name, "' solid\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	/* don't allow interrupts while we update the database! */
	(void)signal( SIGINT, SIG_IGN);
 
	/* Add to in-core directory */
	if( (dp = db_diradd( dbip,  newname, -1, 0, DIR_SOLID, (genptr_t)&intern.idb_type )) == DIR_NULL )  {
	  (void)signal( SIGINT, SIG_IGN );
	  TCL_ALLOC_ERR_return;
	}
	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 ) {
	  (void)signal( SIGINT, SIG_IGN );
	  TCL_WRITE_ERR_return;
	}

	/* Draw the new solid */
	{
		char	*arglist[3];
		arglist[0] = "e";
		arglist[1] = newname;
		arglist[2] = NULL;
		return cmd_draw(clientData, interp, 2, arglist );
	}
end:
	(void)signal( SIGINT, SIG_IGN );
	return status;
}



/* finds inside arbs */
int
arbin(
	struct rt_db_internal	*ip,
	fastf_t	thick[6],
	int	nface,
	int	cgtype,		/* # of points, 4..8 */
	plane_t	planes[6])
{
	struct rt_arb_internal	*arb = (struct rt_arb_internal *)ip->idb_ptr;
	point_t		center_pt;
	int		num_pts=8;	/* number of points to solve using rt_arb_3face_intersect */
	int		i;

	RT_ARB_CK_MAGIC(arb);

	/* find reference point (center_pt[3]) to find direction of normals */
	rt_arb_centroid( center_pt, arb, cgtype );

	/* move new face planes for the desired thicknesses
	 * don't do this yet for an arb7 */
	if( cgtype != 7 )
	{
		for(i=0; i<nface; i++) {
			if( (planes[i][3] - VDOT(center_pt, &planes[i][0])) > 0.0 )
				thick[i] *= -1.0;
			planes[i][3] += thick[i];
		}
	}

	if( cgtype == 5 ) 
		num_pts = 4;	/* use rt_arb_3face_intersect for first 4 points */
	else if( cgtype == 7 )
		num_pts = 0;	/* don't use rt_arb_3face_intersect for any points */

	/* find the new vertices by intersecting the new face planes */
	for(i=0; i<num_pts; i++) {
	  if( rt_arb_3face_intersect( arb->pt[i], (const plane_t *)planes, cgtype, i*3 ) < 0 )  {
	    Tcl_AppendResult(interp, "cannot find inside arb\n", (char *)NULL);
	    return(1);
	  }
	}

	/* The following is code for the special cases of arb5 and arb7
	 * These arbs have a vertex that is the intersection of four planes, and
	 * the inside solid may have a single vertex or an edge replacing this vertex
	 */
	if( cgtype == 5 )
	{
	  /* Here we are only concerned with the one vertex where 4 planes intersect
	   * in the original solid
	   */
	  point_t pt[4];
	  fastf_t dist0,dist1;
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  
	  /* calculate the four possible intersect points */
	  if( bn_mkpoint_3planes( pt[0] , planes[1] , planes[2] , planes[3] ) )
	    {
	      bu_vls_printf(&tmp_vls, "Cannot find inside arb5\n" );
	      bu_vls_printf(&tmp_vls, "Cannot find intersection of three planes for point 0:\n" );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
	      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	      bu_vls_free(&tmp_vls);
	      return( 1 );
	    }
	  if( bn_mkpoint_3planes( pt[1] , planes[2] , planes[3] , planes[4] ) )
	    {
	      bu_vls_printf(&tmp_vls, "Cannot find inside arb5\n" );
	      bu_vls_printf(&tmp_vls, "Cannot find intersection of three planes for point 1:\n" );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
	      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	      bu_vls_free(&tmp_vls);
	      return( 1 );
	    }
	  if( bn_mkpoint_3planes( pt[2] , planes[3] , planes[4] , planes[1] ) )
	    {
	      bu_vls_printf(&tmp_vls, "Cannot find inside arb5\n" );
	      bu_vls_printf(&tmp_vls, "Cannot find intersection of three planes for point 2:\n" );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
	      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	      bu_vls_free(&tmp_vls);
	      return( 1 );
	    }
	  if( bn_mkpoint_3planes( pt[3] , planes[4] , planes[1] , planes[2] ) )
	    {
	      bu_vls_printf(&tmp_vls, "Cannot find inside arb5\n" );
	      bu_vls_printf(&tmp_vls, "Cannot find intersection of three planes for point 3:\n" );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
	      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	      bu_vls_free(&tmp_vls);
	      return( 1 );
	    }
			
		if( bn_pt3_pt3_equal( pt[0] , pt[1] , &mged_tol ) )
		{
			/* if any two of the calculates intersection points are equal,
			 * then all four must be equal
			 */
			for( i=4 ; i<8 ; i++ )
				VMOVE( arb->pt[i] , pt[0] );

			return( 0 );
		}

		/* There will be an edge where the four planes come together
		 * Two edges of intersection have been calculated
		 *     pt[0]<->pt[2]
		 *     pt[1]<->pt[3]
		 * the one closest to the non-invloved plane (planes[0]) is the
		 * one we want
		 */

		dist0 = DIST_PT_PLANE( pt[0] , planes[0] );
		if( dist0 < 0.0 )
			dist0 = (-dist0);

		dist1 = DIST_PT_PLANE( pt[1] , planes[0] );
		if( dist1 < 0.0 )
			dist1 = (-dist1);

		if( dist0 < dist1 )
		{
			VMOVE( arb->pt[5] , pt[0] );
			VMOVE( arb->pt[6] , pt[0] );
			VMOVE( arb->pt[4] , pt[2] );
			VMOVE( arb->pt[7] , pt[2] );
		}
		else
		{
			VMOVE( arb->pt[4] , pt[3] );
			VMOVE( arb->pt[5] , pt[3] );
			VMOVE( arb->pt[6] , pt[1] );
			VMOVE( arb->pt[7] , pt[1] );
		}
	}
	else if( cgtype == 7 )
	{
		struct model *m;
		struct nmgregion *r;
		struct shell *s = NULL;
		struct faceuse *fu;
		struct rt_tess_tol ttol;
		struct bu_ptbl vert_tab;
		struct rt_bot_internal  *bot;

		ttol.magic = RT_TESS_TOL_MAGIC;
		ttol.abs = mged_abs_tol;
		ttol.rel = mged_rel_tol;
		ttol.norm = mged_nrm_tol;

		/* Make a model to hold the inside solid */
		m = nmg_mm();

		/* get an NMG version of this arb7 */
		if( rt_functab[ip->idb_type].ft_tessellate( &r , m , ip , &ttol , &mged_tol ) )
		{
		  Tcl_AppendResult(interp, "Cannot tessellate arb7\n", (char *)NULL);
		  rt_db_free_internal( ip, &rt_uniresource );
		  return( 1 );
		}

		/* move face planes */
		for( i=0 ; i<nface ; i++ )
		{
			int found=0;

			/* look for the face plane with the same geometry as the arb7 planes */
			s = BU_LIST_FIRST( shell , &r->s_hd );
			for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
			{
				struct face_g_plane *fg;
				plane_t pl;

				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					continue;

				NMG_GET_FU_PLANE( pl , fu );
				if( bn_coplanar( planes[i] , pl , &mged_tol ) > 0 )
				{
					/* found the NMG face geometry that matches arb face i */
					found = 1;
					fg = fu->f_p->g.plane_p;
					NMG_CK_FACE_G_PLANE( fg );

					/* move the face by distance "thick[i]" */
					if( fu->f_p->flip )
						fg->N[3] += thick[i];
					else
						fg->N[3] -= thick[i];

					break;
				}
			}
			if( !found )
			{
			  struct bu_vls tmp_vls;

			  bu_vls_init(&tmp_vls);
			  bu_vls_printf(&tmp_vls,"Could not move face plane for arb7, face #%d\n",
					i );
			  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			  bu_vls_free(&tmp_vls);
			  nmg_km( m );
			  return( 1 );
			}
		}

		/* solve for new vertex geometry
		 * This does all the vertices
		 */
		bu_ptbl( &vert_tab , BU_PTBL_INIT , (long *)NULL );
		nmg_vertex_tabulate( &vert_tab , &m->magic );
		for( i=0 ; i<BU_PTBL_END( &vert_tab ) ; i++ )
		{
			struct vertex *v;

			v = (struct vertex *)BU_PTBL_GET( &vert_tab , i );
			NMG_CK_VERTEX( v );

			if( nmg_in_vert( v , 0 , &mged_tol ) )
			{
			  Tcl_AppendResult(interp, "Could not find coordinates for inside arb7\n",
					   (char *)NULL);
			  nmg_km( m );
			  bu_ptbl( &vert_tab , BU_PTBL_FREE , (long *)NULL );
			  return( 1 );
			}
		}
		bu_ptbl( &vert_tab , BU_PTBL_FREE , (long *)NULL );

		/* rebound model */
		nmg_rebound( m , &mged_tol );

		nmg_extrude_cleanup( s , 0 , &mged_tol );

		/* free old ip pointer */
		rt_db_free_internal( ip, &rt_uniresource );

		/* convert the NMG to a BOT */
		bot = (struct rt_bot_internal *)nmg_bot( s, &mged_tol );
		nmg_km( m );

		/* put new solid in "ip" */
		ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
		ip->idb_type = ID_BOT;
		ip->idb_meth = &rt_functab[ID_BOT];
		ip->idb_ptr = (genptr_t)bot;
	}

	return(0);
}

/*	Calculates inside TGC
 *
 * thick[0] is thickness for base (AxB)
 * thick[1] is thickness for top (CxD)
 * thick[2] is thickness for side
 */
int
tgcin(struct rt_db_internal *ip, fastf_t thick[6])
{
	struct rt_tgc_internal	*tgc = (struct rt_tgc_internal *)ip->idb_ptr;
	vect_t norm;		/* unit vector normal to base */
	fastf_t normal_height;	/* height in direction normal to base */
	vect_t v,h;		/* parameters for inside TGC */
	point_t top;		/* vertex at top of inside TGC */
	fastf_t mag_a,mag_b,mag_c,mag_d; /* lengths of original semi-radii */
	fastf_t new_mag_a,new_mag_b,new_mag_c,new_mag_d; /* new lengths */
	vect_t unit_a,unit_b,unit_c,unit_d; /* unit vectors along semi radii */
	fastf_t ratio;

	RT_TGC_CK_MAGIC(tgc);

	VCROSS( norm, tgc->a, tgc->b )
	VUNITIZE( norm )

	normal_height = VDOT( norm, tgc->h );
	if( normal_height < 0.0 )
	{
		normal_height = (-normal_height);
		VREVERSE( norm, norm )
	}

	if( (thick[0] + thick[1]) >= normal_height )
	{
		Tcl_AppendResult(interp, "TGC shorter than base and top thicknesses\n", (char *)NULL);
		return( 1 );
	}

	mag_a = MAGNITUDE( tgc->a );
	mag_b = MAGNITUDE( tgc->b );
	mag_c = MAGNITUDE( tgc->c );
	mag_d = MAGNITUDE( tgc->d );

	if(( mag_a < VDIVIDE_TOL && mag_c < VDIVIDE_TOL ) ||
	   ( mag_b < VDIVIDE_TOL && mag_d < VDIVIDE_TOL ) )
	{
		Tcl_AppendResult(interp, "TGC is too small too create inside solid", (char *)NULL );
		return( 1 );
	}

	if( mag_a >= VDIVIDE_TOL )
		VSCALE( unit_a, tgc->a, 1.0/mag_a )
	else if( mag_c >= VDIVIDE_TOL )
		VSCALE( unit_a, tgc->c, 1.0/mag_c )

	if( mag_c >= VDIVIDE_TOL )
		VSCALE( unit_c, tgc->c, 1.0/mag_c )
	else if( mag_a >= VDIVIDE_TOL )
		VSCALE( unit_c, tgc->a, 1.0/mag_a )

	if( mag_b >= VDIVIDE_TOL )
		VSCALE( unit_b, tgc->b, 1.0/mag_b )
	else if( mag_d >= VDIVIDE_TOL )
		VSCALE( unit_b, tgc->d, 1.0/mag_d )

	if( mag_d >= VDIVIDE_TOL )
		VSCALE( unit_d, tgc->d, 1.0/mag_d )
	else if( mag_c >= VDIVIDE_TOL )
		VSCALE( unit_d, tgc->b, 1.0/mag_b )

	/* Calculate new vertex from base thickness */
	if( thick[0] != 0.0 )
	{
		/* calculate new vertex using similar triangles */
		ratio = thick[0]/normal_height;
		VJOIN1( v, tgc->v, ratio, tgc->h )

		/* adjust lengths of a and c to account for new vertex position */
		new_mag_a = mag_a + (mag_c - mag_a)*ratio;
		new_mag_b = mag_b + (mag_d - mag_b)*ratio;
	}
	else /* just copy the existing values */
	{
		VMOVE( v, tgc->v )
		new_mag_a = mag_a;
		new_mag_b = mag_b;
	}

	/* calculate new height vector */
	if( thick[1] != 0.0 )
	{
		/* calculate new height vector using simialr triangles */
		ratio = thick[1]/normal_height;
		VJOIN1( top, tgc->v, 1.0 - ratio, tgc->h )

		/* adjust lengths of c and d */
		new_mag_c = mag_c + (mag_a - mag_c)*ratio;
		new_mag_d = mag_d + (mag_b - mag_d)*ratio;
	}
	else /* just copy existing values */
	{
		VADD2( top, tgc->v, tgc->h )
		new_mag_c = mag_c;
		new_mag_d = mag_d;
	}

	/* calculate new height vector based on new vertex and top */
	VSUB2( h, top, v )

	if( thick[2] != 0.0 )	/* ther is a side thickness */
	{
		vect_t ctoa;	/* unit vector from tip of C to tip of A */
		vect_t dtob;	/* unit vector from tip of D to tip of B */
		point_t pt_a, pt_b, pt_c, pt_d;	/* points at tips of semi radii */
		fastf_t delta_ac, delta_bd;	/* radius change for thickness */
		fastf_t dot;	/* dot product */
		fastf_t ratio1,ratio2;

		if( (thick[2] >= new_mag_a || thick[2] >= new_mag_b) &&
		    (thick[2] >= new_mag_c || thick[2] >= new_mag_d) )
		{
			/* can't make a small enough TGC */
			Tcl_AppendResult(interp, "Side thickness too large\n", (char *)NULL );
			return( 1 );
		}

		/* approach this as two 2D problems. One is in the plane containing
		 * the a, h, and c vectors. The other is in the plane containing
		 * the b, h, and d vectors.
		 * In the ahc plane:
		 * Calculate the amount that both a and c must be changed to produce
		 * a normal thickness of thick[2]. Use the vector from tip of c to tip
		 * of a and the unit_a vector to get sine of angle that the normal
		 * side thickness makes with vector a (and so also with vector c).
		 * The amount vectors a and c must change is thick[2]/(cosine of that angle).
		 * Similar for the bhd plane.
		 */

		/* Calculate unit vectors from tips of c/d to tips of a/b */
		VJOIN1( pt_a, v, new_mag_a, unit_a )
		VJOIN1( pt_b, v, new_mag_b, unit_b )
		VJOIN2( pt_c, v, 1.0, h, new_mag_c, unit_c )
		VJOIN2( pt_d, v, 1.0, h, new_mag_d, unit_d )
		VSUB2( ctoa, pt_a, pt_c )
		VSUB2( dtob, pt_b, pt_d )
		VUNITIZE( ctoa )
		VUNITIZE( dtob )

		/* Calculate amount vectors a and c must change */
		dot = VDOT( ctoa, unit_a );
		delta_ac = thick[2]/sqrt( 1.0 - dot*dot );

		/* Calculate amount vectors d and d must change */
		dot = VDOT( dtob, unit_b );
		delta_bd = thick[2]/sqrt( 1.0 - dot*dot );

		if( (delta_ac > new_mag_a || delta_bd > new_mag_b) &&
		    (delta_ac > new_mag_c || delta_bd > new_mag_d) )
		{
			/* Can't make TGC small enough */
			Tcl_AppendResult(interp, "Side thickness too large\n", (char *)NULL );
			return( 1 );
		}

		/* Check if changes will make vectors a or d lengths negative */
		if( delta_ac >= new_mag_c || delta_bd >= new_mag_d )
		{
			/* top vertex (height) must move. Calculate similar triangle ratios */
			if( delta_ac >= new_mag_c )
				ratio1 = (new_mag_a - delta_ac)/(new_mag_a - new_mag_c);
			else
				ratio1 = 1.0;

			if( delta_bd >= new_mag_d )
				ratio2 = (new_mag_b - delta_bd)/(new_mag_b - new_mag_d);
			else
				ratio2 = 1.0;

			/* choose the smallest similar triangle for setting new top vertex */
			if( ratio1 < ratio2 )
				ratio = ratio1;
			else
				ratio = ratio2;

			if( ratio1 == ratio && ratio1 < 1.0 ) /* c vector must go to zero */
				new_mag_c = SQRT_SMALL_FASTF;
			else if( ratio1 > ratio && ratio < 1.0 )
			{
				/* vector d will go to zero, but vector c will not */

				/* calculate original length of vector c at new top vertex */
				new_mag_c = new_mag_c + (new_mag_a - new_mag_c)*( 1.0 - ratio);

				/* now just subtract delta */
				new_mag_c -= delta_ac;
			}
			else /* just change c vector length by delta */
				new_mag_c -= delta_ac;

			if( ratio2 == ratio && ratio2 < 1.0 ) /* vector d must go to zero */
				new_mag_d = SQRT_SMALL_FASTF;
			else if( ratio2 > ratio && ratio < 1.0 )
			{
				/* calculate vector length at new top vertex */
				new_mag_d = new_mag_d + (new_mag_b - new_mag_d)*(1.0 - ratio);

				/* now just subtract delta */
				new_mag_d -= delta_bd;
			}
			else /* just adjust length */
				new_mag_d -= delta_bd;

			VSCALE( h, h, ratio )
			new_mag_a -= delta_ac;
			new_mag_b -= delta_bd;
		}
		else if( delta_ac >= new_mag_a || delta_bd >= new_mag_b)
		{
			/* base vertex (v) must move */

			/* Calculate similar triangle ratios */
			if( delta_ac >= new_mag_a )
				ratio1 = (new_mag_c - delta_ac)/(new_mag_c - new_mag_a);
			else
				ratio1 = 1.0;

			if( delta_bd >= new_mag_b )
				ratio2 = (new_mag_d - delta_bd)/(new_mag_d - new_mag_b);
			else
				ratio2 = 1.0;

			/* select smallest triangle to set new base vertex */
			if( ratio1 < ratio2 )
				ratio = ratio1;
			else
				ratio = ratio2;

			if( ratio1 == ratio && ratio1 < 1.0 ) /* vector a must go to zero */
				new_mag_a = SQRT_SMALL_FASTF;
			else if( ratio1 > ratio && ratio < 1.0 )
			{
				/* calculate length of vector a if it were at new base location */
				new_mag_a = new_mag_c + (new_mag_a - new_mag_c)*ratio;

				/* now just subtract delta */
				new_mag_a -= delta_ac;
			}
			else /* just subtract delta */
				new_mag_a -= delta_ac;

			if( ratio2 == ratio && ratio2 < 1.0 ) /* vector b must go to zero */
				new_mag_b = SQRT_SMALL_FASTF;
			else if( ratio2 > ratio && ratio < 1.0 )
			{
				/* Calculate length of b if it were at new base vector */
				new_mag_b = new_mag_d + (new_mag_b - new_mag_d)*ratio;

				/* now just subtract delta */
				new_mag_b -= delta_bd;
			}
			else /* just subtract delta */
				new_mag_b -= delta_bd;

			/* adjust height vector using smallest similar triangle ratio */
			VJOIN1( v, v, 1.0-ratio, h )
			VSUB2( h, top, v )
			new_mag_c -= delta_ac;
			new_mag_d -= delta_bd;
		}
		else /* just change the vector lengths */
		{
			new_mag_a -= delta_ac;
			new_mag_b -= delta_bd;
			new_mag_c -= delta_ac;
			new_mag_d -= delta_bd;
		}
	}

	/* copy new values into the TGC */
	VMOVE( tgc->v, v )
	VMOVE( tgc->h, h)
	VSCALE( tgc->a, unit_a, new_mag_a )
	VSCALE( tgc->b, unit_b, new_mag_b )
	VSCALE( tgc->c, unit_c, new_mag_c )
	VSCALE( tgc->d, unit_d, new_mag_d )

	return( 0 );
}

/* finds inside of torus */
int
torin(struct rt_db_internal *ip, fastf_t thick[6] )
{
	struct rt_tor_internal	*tor = (struct rt_tor_internal *)ip->idb_ptr;

	RT_TOR_CK_MAGIC(tor);
	if( thick[0] == 0.0 )
		return(0);

	if( thick[0] < 0 ) {
	  if( (tor->r_h - thick[0]) > (tor->r_a + .01) ) {
	    Tcl_AppendResult(interp, "cannot do: r2 > r1\n", (char *)NULL);
	    return(1);
	  }
	}
	if( thick[0] >= tor->r_h ) {
	  Tcl_AppendResult(interp, "cannot do: r2 <= 0\n", (char *)NULL);
	  return(1);
	}

	tor->r_h = tor->r_h - thick[0];
	return(0);
}


/* finds inside ellg */
int
ellgin(struct rt_db_internal *ip, fastf_t thick[6])
{
	struct rt_ell_internal	*ell = (struct rt_ell_internal *)ip->idb_ptr;
	int i, j, k, order[3];
	fastf_t mag[3], nmag[3];
	fastf_t ratio;

	if( thick[0] <= 0.0 ) 
		return(0);
	thick[2] = thick[1] = thick[0];	/* uniform thickness */

	RT_ELL_CK_MAGIC(ell);
	mag[0] = MAGNITUDE(ell->a);
	mag[1] = MAGNITUDE(ell->b);
	mag[2] = MAGNITUDE(ell->c);

	for(i=0; i<3; i++) {
		order[i] = i;
	}

	for(i=0; i<2; i++) {
		k = i + 1;
		for(j=k; j<3; j++) {
			if(mag[i] < mag[j])
				order[i] = j;
		}
	}

	if( (ratio = mag[order[1]] / mag[order[0]]) < .8 )
		thick[order[1]] = thick[order[1]]/(1.016447*pow(ratio,.071834));
	if( (ratio = mag[order[2]] / mag[order[1]]) < .8 )
		thick[order[2]] = thick[order[2]]/(1.016447*pow(ratio,.071834));

	for(i=0; i<3; i++) {
	  if( (nmag[i] = mag[i] - thick[i]) <= 0.0 ){
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "Warning: new vector [%d] length <= 0 \n", i);
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
	  }
	}
	VSCALE(ell->a, ell->a, nmag[0]/mag[0]);
	VSCALE(ell->b, ell->b, nmag[1]/mag[1]);
	VSCALE(ell->c, ell->c, nmag[2]/mag[2]);
	return(0);
}

/* find inside of particle solid */
int
partin(struct rt_db_internal *ip, fastf_t *thick )
{
	struct rt_part_internal	*part = (struct rt_part_internal *)ip->idb_ptr;

	RT_PART_CK_MAGIC( part );

	if(*thick >= part->part_vrad || *thick >= part->part_hrad)
	  return(1);    /* BAD */

	part->part_vrad -= *thick;
	part->part_hrad -= *thick;

	return(0);
}

/* finds inside of rpc, not quite right - r needs to be smaller */
int
rpcin(struct rt_db_internal *ip, fastf_t thick[4])
{
	struct rt_rpc_internal	*rpc = (struct rt_rpc_internal *)ip->idb_ptr;
	fastf_t			b;
	vect_t			Bu, Hu, Ru;

	RT_RPC_CK_MAGIC(rpc);

	/* get unit coordinate axes */
	VMOVE( Bu, rpc->rpc_B );
	VMOVE( Hu, rpc->rpc_H );
	VCROSS( Ru, Hu, Bu );
	VUNITIZE( Bu );
	VUNITIZE( Hu );
	VUNITIZE( Ru );

	b = MAGNITUDE(rpc->rpc_B);
	VJOIN2( rpc->rpc_V, rpc->rpc_V, thick[0], Hu, thick[2], Bu );
	VSCALE( rpc->rpc_H, Hu, MAGNITUDE(rpc->rpc_H) - thick[0] - thick[1] );
	VSCALE( rpc->rpc_B, Bu, b - thick[2] - thick[3] );
#if 0
	bp = b - thick[2] - thick[3];
	rp = rpc->rpc_r - thick[3];	/* !!! ESTIMATE !!! */
	yp = rp * sqrt( (bp - thick[2])/bp );
	VSET( Norm,
		0.,
		2 * bp * yp/(rp * rp),
		-1.);
	VUNITIZE(Norm)
	th = thick[3] / Norm[Y];
	rpc->rpc_r -= th;
#endif
	rpc->rpc_r -= thick[3];

	return(0);
}

/* XXX finds inside of rhc, not quite right */
int
rhcin(struct rt_db_internal *ip, fastf_t thick[4])
{
	struct rt_rhc_internal	*rhc = (struct rt_rhc_internal *)ip->idb_ptr;
	vect_t			Bn, Hn, Bu, Hu, Ru;

	RT_RHC_CK_MAGIC(rhc);
	
	VMOVE( Bn, rhc->rhc_B );
	VMOVE( Hn, rhc->rhc_H );
	
	/* get unit coordinate axes */
	VMOVE( Bu, Bn );
	VMOVE( Hu, Hn );
	VCROSS( Ru, Hu, Bu );
	VUNITIZE( Bu );
	VUNITIZE( Hu );
	VUNITIZE( Ru );

	VJOIN2( rhc->rhc_V, rhc->rhc_V, thick[0], Hu, thick[2], Bu );
	VSCALE( rhc->rhc_H, Hu, MAGNITUDE(rhc->rhc_H) - thick[0] - thick[1] );
	VSCALE( rhc->rhc_B, Bu, MAGNITUDE(rhc->rhc_B) - thick[2] - thick[3] );
	rhc->rhc_r -= thick[3];

	return(0);
}

/* finds inside of epa, not quite right */
int
epain(struct rt_db_internal *ip, fastf_t thick[2])
{
	struct rt_epa_internal	*epa = (struct rt_epa_internal *)ip->idb_ptr;
	vect_t			Hu;

	RT_EPA_CK_MAGIC(epa);
	
	VMOVE( Hu, epa->epa_H );
	VUNITIZE( Hu );

	VJOIN1( epa->epa_V, epa->epa_V, thick[0], Hu );
	VSCALE( epa->epa_H, Hu, MAGNITUDE(epa->epa_H) - thick[0] - thick[1] );
	epa->epa_r1 -= thick[1];
	epa->epa_r2 -= thick[1];

	return(0);
}

/* finds inside of ehy, not quite right, */
int
ehyin(struct rt_db_internal *ip, fastf_t thick[2])
{
	struct rt_ehy_internal	*ehy = (struct rt_ehy_internal *)ip->idb_ptr;
	vect_t			Hu;

	RT_EHY_CK_MAGIC(ehy);
	
	VMOVE( Hu, ehy->ehy_H );
	VUNITIZE( Hu );
	
	VJOIN1( ehy->ehy_V, ehy->ehy_V, thick[0], Hu );
	VSCALE( ehy->ehy_H, Hu, MAGNITUDE(ehy->ehy_H) - thick[0] - thick[1] );
	ehy->ehy_r1 -= thick[1];
	ehy->ehy_r2 -= thick[1];

	return(0);
}

/* finds inside of eto */
int
etoin(struct rt_db_internal *ip, fastf_t thick[1])
{
	fastf_t			c;
	struct rt_eto_internal	*eto = (struct rt_eto_internal *)ip->idb_ptr;

	RT_ETO_CK_MAGIC(eto);

	c = 1. - thick[0]/MAGNITUDE(eto->eto_C);
	VSCALE( eto->eto_C, eto->eto_C, c );
	eto->eto_rd -= thick[0];

	return(0);
}

/* find inside for NMG */
int
nmgin( struct rt_db_internal *ip, fastf_t thick )
{
	struct model *m;
	struct nmgregion *r;

	if( ip->idb_type != ID_NMG )
		return( 1 );

	m = (struct model *)ip->idb_ptr;
	NMG_CK_MODEL( m );

	r = BU_LIST_FIRST( nmgregion ,  &m->r_hd );
	while( BU_LIST_NOT_HEAD( r , &m->r_hd ) )
	{
		struct nmgregion *next_r;
		struct shell *s;

		NMG_CK_REGION( r );

		next_r = BU_LIST_PNEXT( nmgregion , &r->l );

		s = BU_LIST_FIRST( shell , &r->s_hd );
		while( BU_LIST_NOT_HEAD( s , &r->s_hd ) )
		{
			struct shell *next_s;

			next_s = BU_LIST_PNEXT( shell , &s->l );

			nmg_shell_coplanar_face_merge( s, &mged_tol, 1 );
			if( !nmg_kill_cracks( s ) )
				(void)nmg_extrude_shell( s , thick , 0 , 0 , &mged_tol );

			s = next_s;
		}

		if( BU_LIST_IS_EMPTY( &r->s_hd ) )
			nmg_kr( r );

		r = next_r;
	}

	if( BU_LIST_IS_EMPTY( &m->r_hd ) )
	{
	  Tcl_AppendResult(interp, "No inside created\n", (char *)NULL);
	  nmg_km( m );
	  return( 1 );
	}
	else
	  return( 0 );
}
@


11.49
log
@change conf.h to a wrapped config.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/inside.c,v 11.48 2004/04/05 09:09:12 morrison Exp $ (BRL)";
@


11.48
log
@merge of ansi-6-0-branch into HEAD
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d31 5
a35 1
#include "conf.h"
@


11.47
log
@update copyright to include span through 2003
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.46 2002/08/20 17:08:23 jra Exp $ (BRL)";
d149 1
a149 5
f_inside(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
@


11.46
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1985 by the United States Army.
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.43 2002/08/09 13:16:45 jra Exp $ (BRL)";
@


11.46.4.1
log
@sync to HEAD...
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/inside.c,v 11.47 2004/02/02 17:39:33 morrison Exp $ (BRL)";
@


11.46.10.1
log
@merge from HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.47 2004/02/02 17:39:33 morrison Exp $ (BRL)";
@


11.46.10.2
log
@merge from head
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.46.10.1 2004/02/12 18:34:14 erikg Exp $ (BRL)";
@


11.46.2.1
log
@Initial ANSIfication
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.46 2002/08/20 17:08:23 jra Exp $ (BRL)";
d149 5
a153 1
f_inside(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.46.2.2
log
@sync branch with HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.45
log
@REFIXED the inside on arb8 bug that appears to have gotten replaced.  The bug is an array that is supposed to be size 11, but is set at 8..
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.44 2002/08/15 20:55:35 hartley Exp $ (BRL)";
d149 5
a153 1
f_inside(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.44
log
@Converted from K&R to ANSI C - RFH
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.42 2002/05/31 20:29:19 jra Exp $ (BRL)";
d238 1
a238 1
	  int uvec[8],svec[8];
@


11.43
log
@Applied fix found by Sean where rt_arb_get_cgtype() was being called with svec array too small
@
text
@d149 1
a149 5
f_inside(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d238 1
a238 1
	  int uvec[8],svec[11];
@


11.42
log
@f_inside() now only tells you that you are in edit mode once
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.41 2001/10/02 19:24:32 jra Exp $ (BRL)";
d242 1
a242 1
	  int uvec[8],svec[8];
@


11.41
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.40 2001/06/01 19:23:24 bparker Exp $ (BRL)";
d197 5
a201 3
	  Tcl_AppendResult(interp, "You are in Prim Edit mode, using edited primitive as outside primitive: ", (char *)NULL);
	  add_solid_path_to_result( interp, illump );
	  Tcl_AppendResult(interp, "\n", (char *)NULL);
d215 5
a219 4

	  Tcl_AppendResult(interp, "You are in Object Edit mode, using key solid as outside solid: ", (char *)NULL);
	  add_solid_path_to_result( interp, illump );
	  Tcl_AppendResult(interp, "\n", (char *)NULL);
@


11.40
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.39 2001/04/05 19:35:45 morrison Exp $ (BRL)";
d801 1
@


11.39
log
@updated SIGNED to signed
updated CONST to const
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.38 2001/03/23 22:05:35 jra Exp $ (BRL)";
d54 1
d537 1
a537 1
		return f_edit(clientData, interp, 2, arglist );
@


11.38
log
@Support for major and minor types in directory structure
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/inside.c,v 11.37 2001/02/01 21:39:32 bparker Exp $ (BRL)";
d55 1
a55 1
BU_EXTERN( void nmg_invert_shell , ( struct shell *s , CONST struct bn_tol *tol ) );
@


11.37
log
@*- change "Solid" to "Prim"
*- change "Object" to "Matrix"
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.36 2001/01/17 21:33:45 jra Exp $ (BRL)";
d521 1
a521 1
	if( (dp = db_diradd( dbip,  newname, -1, 0, DIR_SOLID, NULL )) == DIR_NULL )  {
@


11.36
log
@Mods for unlimited length names
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.35 2000/10/24 19:59:23 mike Exp $ (BRL)";
d196 1
a196 1
	  Tcl_AppendResult(interp, "You are in Solid Edit mode, using edited solid as outside solid: ", (char *)NULL);
@


11.35
log
@
possible uninit
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.34 2000/10/24 19:05:07 mike Exp $ (BRL)";
d272 1
a272 1
	if( (int)strlen(argv[arg]) >= NAMESIZE )  {
d276 1
a276 1
	  bu_vls_printf(&tmp_vls, "Names are limited to %d characters\n", NAMESIZE-1);
@


11.34
log
@
Fixed compiler lint, function declarations.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.33 2000/10/20 05:04:39 mike Exp $ (BRL)";
d695 1
a695 1
		struct shell *s;
@


11.33
log
@
s_path array has been replaced by a s_fullpath "struct db_full_path".
This has eliminated the MAX_PATH restriction in MGED.
member s_last is gone too.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.32 2000/09/08 14:26:18 bparker Exp $ (BRL)";
d547 6
a552 6
arbin(ip, thick, nface, cgtype, planes)
struct rt_db_internal	*ip;
fastf_t	thick[6];
int	nface;
int	cgtype;		/* # of points, 4..8 */
plane_t	planes[6];
d815 1
a815 3
tgcin(ip, thick)
struct rt_db_internal	*ip;
fastf_t	thick[6];
d1098 1
a1098 3
torin(ip, thick)
struct rt_db_internal	*ip;
fastf_t			thick[6];
d1124 1
a1124 3
ellgin(ip, thick)
struct rt_db_internal	*ip;
fastf_t	thick[6];
d1175 1
a1175 3
partin(ip, thick)
struct rt_db_internal	*ip;
fastf_t	*thick;
d1192 1
a1192 3
rpcin(ip, thick)
struct rt_db_internal	*ip;
fastf_t	thick[4];
d1231 1
a1231 3
rhcin(ip, thick)
struct rt_db_internal	*ip;
fastf_t	thick[4];
d1259 1
a1259 3
epain(ip, thick)
struct rt_db_internal	*ip;
fastf_t	thick[2];
d1279 1
a1279 3
ehyin(ip, thick)
struct rt_db_internal	*ip;
fastf_t	thick[2];
d1299 1
a1299 3
etoin(ip, thick)
struct rt_db_internal	*ip;
fastf_t	thick[1];
d1315 1
a1315 3
nmgin( ip , thick )
struct rt_db_internal	*ip;
fastf_t thick;
@


11.32
log
@Cast planes parameter to (const plane_t *)
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.31 2000/09/08 05:55:49 mike Exp $ (BRL)";
d194 1
a194 1
	  outdp = illump->s_path[illump->s_last];
d197 1
a197 3
	  for(i=0; i <= illump->s_last; i++) {
	    Tcl_AppendResult(interp, "/", illump->s_path[i]->d_namep, (char *)NULL);
	  }
d211 1
a211 1
	  outdp = illump->s_path[illump->s_last];
d214 1
a214 3
	  for(i=0; i <= illump->s_last; i++) {
	    Tcl_AppendResult(interp, "/", illump->s_path[i]->d_namep, (char *)NULL);
	  }
@


11.31
log
@
Tree routines now need resource structure.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.30 2000/08/19 03:10:15 mike Exp $ (BRL)";
d586 1
a586 1
	  if( rt_arb_3face_intersect( arb->pt[i], planes, cgtype, i*3 ) < 0 )  {
@


11.30
log
@
Reduced use of MAXARGS
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.29 2000/08/01 13:12:01 jra Exp $ (BRL)";
d234 1
a234 1
	  if( rt_db_get_internal( &intern, outdp, dbip, bn_mat_identity ) < 0 ) {
d529 1
a529 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 ) {
d717 1
a717 1
		  rt_db_free_internal( ip );
d797 1
a797 1
		rt_db_free_internal( ip );
@


11.29
log
@The inside of an arb7 is now a BOT
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.28 2000/06/30 19:58:09 mike Exp $ (BRL)";
d169 1
a169 1
	if(argc < 1 || MAXARGS < argc){
@


11.28
log
@
ft_ifree calls replaced properly
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.27 2000/06/09 12:51:45 jra Exp $ (BRL)";
d703 1
d799 4
d804 3
a806 3
		ip->idb_type = ID_NMG;
		ip->idb_meth = &rt_functab[ID_NMG];
		ip->idb_ptr = (genptr_t)m;
@


11.27
log
@Removed redeclaration of nmg_extrude_shell()
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.26 1999/12/30 20:00:13 jra Exp $ (BRL)";
d716 1
a716 1
		  rt_functab[ip->idb_type].ft_ifree( ip );
@


11.27.2.1
log
@*- changed "Solid" to "Prim"
*- changed "Object" to "Matrix"
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.27 2000/06/09 12:51:45 jra Exp $ (BRL)";
d196 1
a196 1
	  Tcl_AppendResult(interp, "You are in Prim Edit mode, using edited primitive as outside primitive: ", (char *)NULL);
@


11.26
log
@Eliminated some unused variables
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.25 1999/12/29 23:23:23 mike Exp $ (BRL)";
a55 1
BU_EXTERN( struct shell *nmg_extrude_shell , ( struct shell *s, fastf_t thick , int normal_ward , int approximate , CONST struct bn_tol *tol ) );
@


11.25
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.24 1999/11/24 14:26:42 jra Exp $ (BRL)";
d822 1
a822 1
	vect_t v,h,a,b,c,d;	/* parameters for inside TGC */
@


11.24
log
@All solid/combination creation  routines needed values assigned to idb_meth
in the rt_db_internal struct
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.23 1999/11/03 21:29:22 jra Exp $ (BRL)";
d526 1
a526 1
	if( (dp = db_diradd( dbip,  newname, -1, 0, DIR_SOLID )) == DIR_NULL )  {
@


11.23
log
@Added a more decriptive error message to the inside command
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.22 1999/09/01 18:55:10 bparker Exp $ (BRL)";
d801 1
@


11.22
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.21 1999/02/08 16:32:58 bparker Exp $ (BRL)";
d197 1
a197 1
	  Tcl_AppendResult(interp, "Outside solid: ", (char *)NULL);
d216 1
a216 1
	  Tcl_AppendResult(interp, "Outside solid: ", (char *)NULL);
d271 3
a273 1
	  aexists( argv[arg] );
@


11.21
log
@add support for particle solid
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/inside.c,v 11.20 1997/07/01 22:09:08 bparker Exp $ (BRL)";
d168 1
a168 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
@


11.20
log
@mods to run without a database
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.19 1997/04/24 18:03:58 bparker Exp bparker $ (BRL)";
d110 4
d391 18
d1174 19
@


11.19
log
@modify calls to Tcl_Eval
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.18 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d163 3
@


11.18
log
@mods so that commands check args internally
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.17 1997/04/08 13:20:27 jra Exp bparker $ (BRL)";
d165 6
a170 1
	  Tcl_Eval(interp, "help inside");
@


11.17
log
@fixed bug in nmgin().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.16 1997/02/28 21:38:11 jra Exp jra $ (BRL)";
d164 2
a165 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d167 1
@


11.16
log
@removed include of db.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.15 1997/01/02 19:35:05 bparker Exp jra $ (BRL)";
d1310 3
a1312 1
			(void)nmg_extrude_shell( s , thick , 0 , 0 , &mged_tol );
@


11.15
log
@mods to use libbn and libbu
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.14 1996/11/15 16:27:56 jra Exp bparker $ (BRL)";
a45 1
#include "db.h"			/* XXX needed for NAMESIZE */
@


11.14
log
@Rewrote tgcin() to correctly handle TGC's with a side thickness greater than the radius
at one end of the TGC.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.13 1996/10/01 17:26:29 bparker Exp jra $ (BRL)";
d45 1
d56 2
a57 2
BU_EXTERN( void nmg_invert_shell , ( struct shell *s , CONST struct rt_tol *tol ) );
BU_EXTERN( struct shell *nmg_extrude_shell , ( struct shell *s, fastf_t thick , int normal_ward , int approximate , CONST struct rt_tol *tol ) );
d60 1
a60 1
extern struct rt_tol		mged_tol;	/* from ged.c */
d200 1
a200 1
	  mat_mul(newmat, modelchanges, es_mat);
d223 1
a223 1
	  if( rt_db_get_internal( &intern, outdp, dbip, rt_identity ) < 0 ) {
d577 1
a577 1
	  if( rt_mkpoint_3planes( pt[0] , planes[1] , planes[2] , planes[3] ) )
d588 1
a588 1
	  if( rt_mkpoint_3planes( pt[1] , planes[2] , planes[3] , planes[4] ) )
d599 1
a599 1
	  if( rt_mkpoint_3planes( pt[2] , planes[3] , planes[4] , planes[1] ) )
d610 1
a610 1
	  if( rt_mkpoint_3planes( pt[3] , planes[4] , planes[1] , planes[2] ) )
d622 1
a622 1
		if( rt_pt3_pt3_equal( pt[0] , pt[1] , &mged_tol ) )
d706 1
a706 1
				if( rt_coplanar( planes[i] , pl , &mged_tol ) > 0 )
@


11.13
log
@ignore SIGINT
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.12 1996/09/25 20:10:14 bparker Exp bparker $ (BRL)";
d774 6
a779 1
/* finds inside of tgc */
d786 8
a793 9
	fastf_t	mag[5], nmag[5];
	vect_t	unitH, unitA, unitB;
	vect_t	unitC, unitD;
	vect_t	hwork;
	fastf_t	aa[2], ab[2], ba[2], bb[2];
	fastf_t	dt, h1, h2, ht, dtha, dthb;
	fastf_t	s, d4, d5, ctan, t3;
	register int i, k;
	double ratio;
a794 1
	thick[3] = thick[2];
d797 254
a1050 61
	mag[0] = MAGNITUDE( tgc->h );
	mag[1] = MAGNITUDE( tgc->a );
	mag[2] = MAGNITUDE( tgc->b );
	mag[3] = MAGNITUDE( tgc->c );
	mag[4] = MAGNITUDE( tgc->d );

	if( (ratio = (mag[2] / mag[1])) < .8 )
		thick[3] = thick[3] / (1.016447 * pow(ratio, .071834));
	VSCALE(unitH, tgc->h, 1.0/mag[0]);
	VSCALE(unitA, tgc->a, 1.0/mag[1]);
	VSCALE(unitB, tgc->b, 1.0/mag[2]);
	VSCALE(unitC, tgc->c, 1.0/mag[3]);
	VSCALE(unitD, tgc->d, 1.0/mag[4]);

	VCROSS(hwork, unitA, unitB);
	if( (dt = VDOT(hwork, unitH)) == 0.0 ) {
	  Tcl_AppendResult(interp, "BAD cylinder\n", (char *)NULL);
	  return(1);
	}
	else if( dt < 0.0 )
		dt = (-dt);

	h1 = thick[0] / dt;
	h2 = thick[1] / dt;
	if( (ht = dt * mag[0]) == 0.0 ) {
	  Tcl_AppendResult(interp, "Cannot find the inside cylinder\n", (char *)NULL);
	  return(1);
	}
	dtha = VDOT(unitA, tgc->h);
	dthb = VDOT(unitB, tgc->h);
	s = 1.0;
	for(k=0; k<2; k++) {
		if( k )
			s = -1.0;
		d4 = s * dtha + mag[3];
		d5 = s * dthb + mag[4];
		ctan = (mag[1] - d4) / ht;
		t3 = thick[2] * sqrt( (mag[1] - d4)*(mag[1] - d4) + ht*ht ) / ht;
		aa[k] = mag[1] - t3 - (thick[0]*ctan);
		ab[k] = d4 - t3 + (thick[1]*ctan);

		ctan = (mag[2] - d5) / ht;
		t3 = thick[3] * sqrt( (mag[2]-d5)*(mag[2]-d5) + ht*ht ) / ht;
		ba[k] = mag[2] - t3 - (thick[0]*ctan);
		bb[k] = d5 - t3 + (thick[1]*ctan);
	}

	nmag[0] = mag[0] - (h1+h2);
	nmag[1] = ( aa[0] + aa[1] ) * .5;
	nmag[2] = ( ba[0] + ba[1] ) * .5;
	nmag[3] = (ab[0] + ab[1]) * .5;
	nmag[4] = (bb[0] + bb[1]) * .5;
	VSCALE(tgc->h, unitH, nmag[0] );
	VSCALE(tgc->a, unitA, nmag[1] );
	VSCALE(tgc->b, unitB, nmag[2] );
	VSCALE(tgc->c, unitC, nmag[3] );
	VSCALE(tgc->d, unitD, nmag[4] );

	for( i=0; i<3; i++ )  {
		tgc->v[i] += unitH[i]*h1 + .5 *
		    ( (aa[0] - aa[1])*unitA[i] + (ba[0] - ba[1])*unitB[i] );
d1052 10
a1061 1
	return(0);
a1062 1

@


11.12
log
@include mged_solid.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.11 1996/09/23 18:25:15 bparker Exp bparker $ (BRL)";
d162 1
d194 2
a195 1
	     return TCL_ERROR;
d213 2
a214 1
	    return TCL_ERROR;
d216 4
a219 2
	  if( (outdp = db_lookup( dbip,  argv[arg], LOOKUP_NOISY )) == DIR_NULL )  
	    return TCL_ERROR;
d223 1
d234 2
a235 1
	    return TCL_ERROR;
d244 2
a245 1
	    return TCL_ERROR;
d254 2
a255 1
	  return TCL_ERROR;
d259 2
a260 1
	  return TCL_ERROR;
d269 2
a270 1
	  return TCL_ERROR;
d315 2
a316 1
		    return TCL_ERROR;
d322 4
a325 2
		if( arbin(&intern, thick, nface, cgtype, planes) )
		  return TCL_ERROR;
d334 2
a335 1
	      return TCL_ERROR;
d341 4
a344 2
	  if( tgcin(&intern, thick) )
	    return TCL_ERROR;
d350 2
a351 1
	    return TCL_ERROR;
d356 4
a359 2
	  if( ellgin(&intern, thick) )
	    return TCL_ERROR;
d365 2
a366 1
	    return TCL_ERROR;
d371 4
a374 2
	  if( torin(&intern, thick) )
	    return TCL_ERROR;
d382 2
a383 1
	      return TCL_ERROR;
d389 4
a392 2
	  if( rpcin(&intern, thick) )
	    return TCL_ERROR;
d400 2
a401 1
	      return TCL_ERROR;
d407 4
a410 2
	  if( rhcin(&intern, thick) )
	    return TCL_ERROR;
d418 2
a419 1
	      return TCL_ERROR;
d425 4
a428 2
	  if( epain(&intern, thick) )
	    return TCL_ERROR;
d436 2
a437 1
	      return TCL_ERROR;
d443 4
a446 2
	  if( ehyin(&intern, thick) )
	    return TCL_ERROR;
d454 2
a455 1
	      return TCL_ERROR;
d461 4
a464 2
	  if( etoin(&intern, thick) )
	    return TCL_ERROR;
d471 2
a472 1
	    return TCL_ERROR;
d476 4
a479 2
	  if( nmgin( &intern , thick[0] ) )
	    return TCL_ERROR;
d485 2
a486 1
	  return TCL_ERROR;
d494 1
d498 1
d510 3
@


11.11
log
@changed dm.h to mged_dm.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.10 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d52 1
a52 1
#include "./solid.h"
@


11.10
log
@rt_list ---> bu_list
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.9 1996/08/28 15:07:03 bparker Exp bparker $ (BRL)";
d53 1
a53 1
#include "./dm.h"
@


11.9
log
@more conversions to libbu
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.8 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d43 1
a45 1
#include "rtlist.h"
d647 2
a648 2
			s = RT_LIST_FIRST( shell , &r->s_hd );
			for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d1042 2
a1043 2
	r = RT_LIST_FIRST( nmgregion ,  &m->r_hd );
	while( RT_LIST_NOT_HEAD( r , &m->r_hd ) )
d1050 1
a1050 1
		next_r = RT_LIST_PNEXT( nmgregion , &r->l );
d1052 2
a1053 2
		s = RT_LIST_FIRST( shell , &r->s_hd );
		while( RT_LIST_NOT_HEAD( s , &r->s_hd ) )
d1057 1
a1057 1
			next_s = RT_LIST_PNEXT( shell , &s->l );
d1064 1
a1064 1
		if( RT_LIST_IS_EMPTY( &r->s_hd ) )
d1070 1
a1070 1
	if( RT_LIST_IS_EMPTY( &m->r_hd ) )
@


11.8
log
@now using libbu
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.7 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d623 1
a623 1
		struct nmg_ptbl vert_tab;
d691 1
a691 1
		nmg_tbl( &vert_tab , TBL_INIT , (long *)NULL );
d693 1
a693 1
		for( i=0 ; i<NMG_TBL_END( &vert_tab ) ; i++ )
d697 1
a697 1
			v = (struct vertex *)NMG_TBL_GET( &vert_tab , i );
d705 1
a705 1
			  nmg_tbl( &vert_tab , TBL_FREE , (long *)NULL );
d709 1
a709 1
		nmg_tbl( &vert_tab , TBL_FREE , (long *)NULL );
@


11.7
log
@Still Tcl'ing the code
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.6 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d55 2
a56 2
RT_EXTERN( void nmg_invert_shell , ( struct shell *s , CONST struct rt_tol *tol ) );
RT_EXTERN( struct shell *nmg_extrude_shell , ( struct shell *s, fastf_t thick , int normal_ward , int approximate , CONST struct rt_tol *tol ) );
d253 1
a253 1
	  struct rt_vls tmp_vls;
d255 4
a258 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "Names are limited to %d characters\n", NAMESIZE-1);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d524 1
a524 1
	  struct rt_vls tmp_vls;
d526 1
a526 1
	  rt_vls_init(&tmp_vls);
d531 7
a537 7
	      rt_vls_printf(&tmp_vls, "Cannot find inside arb5\n" );
	      rt_vls_printf(&tmp_vls, "Cannot find intersection of three planes for point 0:\n" );
	      rt_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
	      rt_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
	      rt_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
	      Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	      rt_vls_free(&tmp_vls);
d542 7
a548 7
	      rt_vls_printf(&tmp_vls, "Cannot find inside arb5\n" );
	      rt_vls_printf(&tmp_vls, "Cannot find intersection of three planes for point 1:\n" );
	      rt_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
	      rt_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
	      rt_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
	      Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	      rt_vls_free(&tmp_vls);
d553 7
a559 7
	      rt_vls_printf(&tmp_vls, "Cannot find inside arb5\n" );
	      rt_vls_printf(&tmp_vls, "Cannot find intersection of three planes for point 2:\n" );
	      rt_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
	      rt_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
	      rt_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
	      Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	      rt_vls_free(&tmp_vls);
d564 7
a570 7
	      rt_vls_printf(&tmp_vls, "Cannot find inside arb5\n" );
	      rt_vls_printf(&tmp_vls, "Cannot find intersection of three planes for point 3:\n" );
	      rt_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
	      rt_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
	      rt_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
	      Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	      rt_vls_free(&tmp_vls);
d676 1
a676 1
			  struct rt_vls tmp_vls;
d678 2
a679 2
			  rt_vls_init(&tmp_vls);
			  rt_vls_printf(&tmp_vls,"Could not move face plane for arb7, face #%d\n",
d681 2
a682 2
			  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
			  rt_vls_free(&tmp_vls);
d880 1
a880 1
	    struct rt_vls tmp_vls;
d882 4
a885 4
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "Warning: new vector [%d] length <= 0 \n", i);
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
@


11.6
log
@still tcl-converting
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.5 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d166 4
a169 1
	(void)signal( SIGINT, sig2);    /* allow interupts */
@


11.5
log
@convert commands to Tcl
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.4 1996/03/01 19:31:04 bparker Exp bparker $ (BRL)";
d460 1
@


11.4
log
@remove unused XMGED stuff
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.3 1995/02/18 03:09:02 mike Exp bparker $ (BRL)";
d145 3
a147 1
f_inside(argc, argv)
d161 1
d163 2
a164 1
	int arg = 1;
d175 10
a184 10
		/* solid edit mode */
		/* apply es_mat editing to parameters */
		transform_editing_solid( &intern, es_mat, &es_int, 0 );
		outdp = illump->s_path[illump->s_last];

		rt_log("Outside solid: ");
		for(i=0; i <= illump->s_last; i++) {
			rt_log("/%s",illump->s_path[i]->d_namep);
		}
		rt_log("\n");
d186 17
a202 16
		/* object edit mode */
		if( illump->s_Eflag ) {
			rt_log("Cannot find inside of a processed (E'd) region\n");
			return CMD_BAD;
		}
		/* use the solid at bottom of path (key solid) */
		/* apply es_mat and modelchanges editing to parameters */
		mat_mul(newmat, modelchanges, es_mat);
		transform_editing_solid( &intern, newmat, &es_int, 0 );
		outdp = illump->s_path[illump->s_last];

		rt_log("Outside solid: ");
		for(i=0; i <= illump->s_last; i++) {
			rt_log("/%s",illump->s_path[i]->d_namep);
		}
		rt_log("\n");
d204 13
a216 13
		/* Not doing any editing....ask for outside solid */
		if( argc < arg+1 ) {
			rt_log("Enter name of outside solid: ");
			return CMD_MORE;
		}
		if( (outdp = db_lookup( dbip,  argv[arg], LOOKUP_NOISY )) == DIR_NULL )  
			return CMD_BAD;
		++arg;

		if( rt_db_get_internal( &intern, outdp, dbip, rt_identity ) < 0 ) {
			READ_ERR;
			return CMD_BAD;
		}
d220 2
a221 7
		/* find the comgeom arb type, & reorganize */
		int uvec[8],svec[8];

		if( rt_arb_get_cgtype( &cgtype , intern.idb_ptr, &mged_tol , uvec , svec ) == 0 ) {
			rt_log("%s: BAD ARB\n",outdp->d_namep);
			return CMD_BAD;
		}
d223 13
a235 7
		/* must find new plane equations to account for
		 * any editing in the es_mat matrix or path to this solid.
		 */
		if( rt_arb_calc_planes( planes, intern.idb_ptr, cgtype, &mged_tol ) < 0 )  {
			rt_log("rt_arb_calc_planes(%s): failed\n", outdp->d_namep);
			return CMD_BAD;
		}
d241 3
a243 2
		rt_log("Enter name of the inside solid: ");
		return CMD_MORE;
d246 2
a247 2
		aexists( argv[arg] );
		return CMD_BAD;
d250 7
a256 2
		rt_log("Names are limited to %d characters\n", NAMESIZE-1);
		return CMD_BAD;
d299 6
a304 6
			if( argc < arg+1 ) {
				rt_log("%s",promp[i]);
				return CMD_MORE;
			}
			thick[i] = atof(argv[arg]) * local2base;
			++arg;
d308 1
a308 1
			return CMD_BAD;
d313 13
a325 13
		promp = p_tgcin;
		for(i=0; i<3; i++) {
			if( argc < arg+1 ) {
				rt_log("%s",promp[i]);
				return CMD_MORE;
			}
			thick[i] = atof( argv[arg] ) * local2base;
			++arg;
		}

		if( tgcin(&intern, thick) )
			return CMD_BAD;
		break;
d328 10
a337 6
		if( argc < arg+1 ) {
			rt_log("Enter desired thickness: ");
			return CMD_MORE;
		}
		thick[0] = atof( argv[arg] ) * local2base;
		++arg;
a338 4
		if( ellgin(&intern, thick) )
			return CMD_BAD;
		break;

d340 10
a349 10
		if( argc < arg+1 ) {
			rt_log("Enter desired thickness: ");
			return CMD_MORE;
		}
		thick[0] = atof( argv[arg] ) * local2base;
		++arg;

		if( torin(&intern, thick) )
			return CMD_BAD;
		break;
d352 13
a364 13
		promp = p_rpcin;
		for (i = 0; i < 4; i++) {
			if( argc < arg+1 ) {
				rt_log("%s",promp[i]);
				return CMD_MORE;
			}
			thick[i] = atof( argv[arg] ) * local2base;
			++arg;
		}

		if( rpcin(&intern, thick) )
			return CMD_BAD;
		break;
d367 13
a379 13
		promp = p_rhcin;
		for (i = 0; i < 4; i++) {
			if( argc < arg+1 ) {
				rt_log("%s",promp[i]);
				return CMD_MORE;
			}
			thick[i] = atof( argv[arg] ) * local2base;
			++arg;
		}

		if( rhcin(&intern, thick) )
			return CMD_BAD;
		break;
d382 13
a394 9
		promp = p_epain;
		for (i = 0; i < 2; i++) {
			if( argc < arg+1 ) {
				rt_log("%s",promp[i]);
				return CMD_MORE;
			}
			thick[i] = atof( argv[arg] ) * local2base;
			++arg;
		}
a395 4
		if( epain(&intern, thick) )
			return CMD_BAD;
		break;

d397 13
a409 9
		promp = p_ehyin;
		for (i = 0; i < 2; i++) {
			if( argc < arg+1 ) {
				rt_log("%s",promp[i]);
				return CMD_MORE;
			}
			thick[i] = atof( argv[arg] ) * local2base;
			++arg;
		}
a410 4
		if( ehyin(&intern, thick) )
			return CMD_BAD;
		break;

d412 13
a424 9
		promp = p_etoin;
		for (i = 0; i < 1; i++) {
			if( argc < arg+1 ) {
				rt_log("%s",promp[i]);
				return CMD_MORE;
			}
			thick[i] = atof( argv[arg] ) * local2base;
			++arg;
		}
a425 4
		if( etoin(&intern, thick) )
			return CMD_BAD;
		break;

d427 10
a436 10
		promp = p_nmgin;
		if( argc < arg+1 ) {
			rt_log( "%s" , promp[0] );
			return CMD_MORE;
		}
		thick[0] = atof( argv[arg] ) * local2base;
		++arg;
		if( nmgin( &intern , thick[0] ) )
			return CMD_BAD;
		break;
d439 3
a441 3
		rt_log("Cannot find inside for '%s' solid\n",
			rt_functab[intern.idb_type].ft_name );
		return CMD_BAD;
d449 1
a449 2
	    	ALLOC_ERR;
		return CMD_BAD;
d452 1
a452 2
		WRITE_ERR;
		return CMD_BAD;
d460 1
a460 1
		return f_edit( 2, arglist );
d503 4
a506 4
		if( rt_arb_3face_intersect( arb->pt[i], planes, cgtype, i*3 ) < 0 )  {
			rt_log("cannot find inside arb\n");
			return(1);
		}
d515 54
a568 43
		/* Here we are only concerned with the one vertex where 4 planes intersect
		 * in the original solid
		 */
		point_t pt[4];
		fastf_t dist0,dist1;

		/* calculate the four possible intersect points */
		if( rt_mkpoint_3planes( pt[0] , planes[1] , planes[2] , planes[3] ) )
		{
			rt_log( "Cannot find inside arb5\n" );
			rt_log( "Cannot find intersection of three planes for point 0:\n" );
			rt_log( "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
			rt_log( "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
			rt_log( "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
			return( 1 );
		}
		if( rt_mkpoint_3planes( pt[1] , planes[2] , planes[3] , planes[4] ) )
		{
			rt_log( "Cannot find inside arb5\n" );
			rt_log( "Cannot find intersection of three planes for point 1:\n" );
			rt_log( "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
			rt_log( "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
			rt_log( "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
			return( 1 );
		}
		if( rt_mkpoint_3planes( pt[2] , planes[3] , planes[4] , planes[1] ) )
		{
			rt_log( "Cannot find inside arb5\n" );
			rt_log( "Cannot find intersection of three planes for point 2:\n" );
			rt_log( "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
			rt_log( "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
			rt_log( "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
			return( 1 );
		}
		if( rt_mkpoint_3planes( pt[3] , planes[4] , planes[1] , planes[2] ) )
		{
			rt_log( "Cannot find inside arb5\n" );
			rt_log( "Cannot find intersection of three planes for point 3:\n" );
			rt_log( "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
			rt_log( "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
			rt_log( "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
			return( 1 );
		}
d632 3
a634 3
			rt_log( "Cannot tessellate arb7\n" );
			rt_functab[ip->idb_type].ft_ifree( ip );
			return( 1 );
d672 9
a680 3
				rt_log( "Could not move face plane for arb7, face #%d\n" , i );
				nmg_km( m );
				return( 1 );
d698 5
a702 4
				rt_log( "Could not find coordinates for inside arb7\n" );
				nmg_km( m );
				nmg_tbl( &vert_tab , TBL_FREE , (long *)NULL );
				return( 1 );
d759 2
a760 2
		rt_log("BAD cylinder\n");
		return(1);
d768 2
a769 2
		rt_log("Cannot find the inside cylinder\n");
		return(1);
d822 4
a825 4
		if( (tor->r_h - thick[0]) > (tor->r_a + .01) ) {
			rt_log("cannot do: r2 > r1\n");
			return(1);
		}
d828 2
a829 2
		rt_log("cannot do: r2 <= 0\n");
		return(1);
d875 8
a882 2
		if( (nmag[i] = mag[i] - thick[i]) <= 0.0 )
			rt_log("Warning: new vector [%d] length <= 0 \n", i);
d1068 3
a1070 3
		rt_log( "No inside created\n" );
		nmg_km( m );
		return( 1 );
d1073 1
a1073 1
		return( 0 );
@


11.3
log
@Eliminated local setting of "rt_tol" structures.
Everything now uses the global mged_tol.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 11.2 95/01/17 13:04:49 bparker Exp Locker: mike $ (BRL)";
a161 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint);	/* allow interrupts */
#else
a162 1
#endif
@


11.2
log
@merging xmged sources
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/inside.c,v 11.2 95/01/17 11:43:18 bparker Exp $ (BRL)";
d55 2
a56 2
RT_EXTERN( void nmg_invert_shell , ( struct shell *s , struct rt_tol *tol ) );
RT_EXTERN( struct shell *nmg_extrude_shell , ( struct shell *s, fastf_t thick , int normal_ward , int approximate , struct rt_tol *tol ) );
a158 1
	struct rt_tol	tol;
a161 7
	/* XXX These need to be improved */
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

d222 1
a222 1
		if( rt_arb_get_cgtype( &cgtype , intern.idb_ptr, &tol , uvec , svec ) == 0 ) {
d230 1
a230 1
		if( rt_arb_calc_planes( planes, intern.idb_ptr, cgtype, &tol ) < 0 )  {
@


11.1
log
@Release_4.4
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 10.15 94/12/16 19:36:54 gdurf Exp $ (BRL)";
d170 5
a174 1
	(void)signal( SIGINT, sig2);	/* allow interrupts */
@


10.15
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 10.14 1994/11/16 16:57:52 jra Exp gdurf $ (BRL)";
@


10.14
log
@Irix 6.0.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/inside.c,v 10.13 1994/09/02 00:29:59 mike Exp jra $ (BRL)";
d184 1
a184 1
		(void)printf("Outside solid: ");
d186 1
a186 1
			(void)printf("/%s",illump->s_path[i]->d_namep);
d188 1
a188 1
		(void)printf("\n");
d192 1
a192 1
			(void)printf("Cannot find inside of a processed (E'd) region\n");
d201 1
a201 1
		(void)printf("Outside solid: ");
d203 1
a203 1
			(void)printf("/%s",illump->s_path[i]->d_namep);
d205 1
a205 1
		(void)printf("\n");
d209 1
a209 1
			(void)printf("Enter name of outside solid: ");
d243 1
a243 1
		(void)printf("Enter name of the inside solid: ");
d251 1
a251 1
		(void)printf("Names are limited to %d characters\n", NAMESIZE-1);
d296 1
a296 1
				(void)printf("%s",promp[i]);
d312 1
a312 1
				(void)printf("%s",promp[i]);
d325 1
a325 1
			(void)printf("Enter desired thickness: ");
d337 1
a337 1
			(void)printf("Enter desired thickness: ");
d351 1
a351 1
				(void)printf("%s",promp[i]);
d366 1
a366 1
				(void)printf("%s",promp[i]);
d381 1
a381 1
				(void)printf("%s",promp[i]);
d396 1
a396 1
				(void)printf("%s",promp[i]);
d411 1
a411 1
				(void)printf("%s",promp[i]);
d425 1
a425 1
			(void)printf( "%s" , promp[0] );
d435 1
a435 1
		(void)printf("Cannot find inside for '%s' solid\n",
d502 1
a502 1
			(void)printf("cannot find inside arb\n");
d522 5
a526 5
			(void)printf( "Cannot find inside arb5\n" );
			(void)printf( "Cannot find intersection of three planes for point 0:\n" );
			(void)printf( "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
			(void)printf( "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
			(void)printf( "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
d531 5
a535 5
			(void)printf( "Cannot find inside arb5\n" );
			(void)printf( "Cannot find intersection of three planes for point 1:\n" );
			(void)printf( "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
			(void)printf( "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
			(void)printf( "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
d540 5
a544 5
			(void)printf( "Cannot find inside arb5\n" );
			(void)printf( "Cannot find intersection of three planes for point 2:\n" );
			(void)printf( "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
			(void)printf( "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
			(void)printf( "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
d549 5
a553 5
			(void)printf( "Cannot find inside arb5\n" );
			(void)printf( "Cannot find intersection of three planes for point 3:\n" );
			(void)printf( "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
			(void)printf( "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
			(void)printf( "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
d619 1
a619 1
			(void)printf( "Cannot tessellate arb7\n" );
d659 1
a659 1
				(void)printf( "Could not move face plane for arb7, face #%d\n" , i );
d679 1
a679 1
				(void)printf( "Could not find coordinates for inside arb7\n" );
d739 1
a739 1
		(void)printf("BAD cylinder\n");
d748 1
a748 1
		(void)printf("Cannot find the inside cylinder\n");
d803 1
a803 1
			(void)printf("cannot do: r2 > r1\n");
d808 1
a808 1
		(void)printf("cannot do: r2 <= 0\n");
d856 1
a856 1
			(void)printf("Warning: new vector [%d] length <= 0 \n", i);
d1042 1
a1042 1
		(void)printf( "No inside created\n" );
@


10.13
log
@Changed to new face geometry pointers
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 10.12 94/08/09 15:10:51 gdurf Exp Locker: mike $ (BRL)";
a153 1
	int	p1, p2, p3;
d717 1
a717 1
	register int i, j, k;
d871 2
a872 2
	fastf_t			b, bp, th, rp, yp;
	vect_t			Bu, Hu, Norm, Ru;
d905 1
a905 1
/* finds inside of rhc, not quite right */
a911 2
	fastf_t			rn;
	point_t			Vn;
a915 1
	VMOVE( Vn, rhc->rhc_V );
a917 1
	rn = rhc->rhc_r;
@


10.12
log
@Factored ifdefs
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 10.11 1994/06/23 17:49:41 jra Exp gdurf $ (BRL)";
d634 1
a634 1
				struct face_g *fg;
d646 2
a647 2
					fg = fu->f_p->fg_p;
					NMG_CK_FACE_G( fg );
@


10.11
log
@Added call to nmg_extrude_cleanup after building inside nmg for an arb7
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 10.10 94/06/13 19:07:45 gdurf Exp Locker: jra $ (BRL)";
d31 2
d36 3
a38 1
#ifdef BSD
a39 2
#else
#include <string.h>
@


10.10
log
@Expunged cmd_args[], numargs, and getcmd()
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 10.9 1994/05/11 15:22:50 jra Exp gdurf $ (BRL)";
d54 1
a54 1
RT_EXTERN( struct shell *nmg_extrude_shell , ( struct shell *s, fastf_t thick , int normal_ward , struct rt_tol *tol ) );
d676 1
a676 1
			if( nmg_in_vert( v , &mged_tol ) )
d686 5
d1032 1
a1032 1
			(void)nmg_extrude_shell( s , thick , 0 , &mged_tol );
@


10.9
log
@Modified arbin to create NMG's for insides of arb7's
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 10.8 94/05/06 15:47:35 jra Exp Locker: jra $ (BRL)";
a58 5
extern int	args;		/* total number of args available */
extern int	argcnt;		/* holder for number of args added later */
extern int	newargs;	/* number of args from getcmd() */
extern int	numargs;	/* number of args */
extern char	*cmd_args[];	/* array of pointers to args */
d142 4
a145 2
void
f_inside()
d160 2
a170 6
	/* don't use any arguments entered initially 
	 * will explicitly ask for data as needed
	 */
	args = numargs;
	argcnt = 0;

d192 1
a192 1
			return;
d207 12
a218 7
		(void)printf("Enter name of outside solid: ");
		argcnt = getcmd(args);
		if( (outdp = db_lookup( dbip,  cmd_args[args], LOOKUP_NOISY )) == DIR_NULL )  
			return;
		args += argcnt;
		if( rt_db_get_internal( &intern, outdp, dbip, rt_identity ) < 0 )
			READ_ERR_return;
d220 1
d227 1
a227 1
			return;
d234 2
a235 2
			rt_log("rt_arb_calc_planes(%s): failued\n", outdp->d_namep);
			return;
d241 1
a241 2
	argcnt=0;
	while( !argcnt ){		/* no command yet */
d243 1
a243 1
		argcnt = getcmd(args);
d245 3
a247 3
	if( db_lookup( dbip,  cmd_args[args], LOOKUP_QUIET ) != DIR_NULL ) {
		aexists( cmd_args[args] );
		return;
d249 1
a249 1
	if( (int)strlen(cmd_args[args]) >= NAMESIZE )  {
d251 1
a251 1
		return;
d253 2
a254 1
	newname = cmd_args[args];
a255 2
	args += argcnt;

d294 6
a299 5
			(void)printf("%s",promp[i]);
			if( (argcnt = getcmd( args )) < 0 )
				return;
			thick[i] = atof(cmd_args[args]) * local2base;
			args += argcnt;
d303 1
a303 1
			return;
d310 6
a315 5
			(void)printf("%s",promp[i]);
			if( (argcnt = getcmd(args)) < 0 )
				return;
			thick[i] = atof( cmd_args[args] ) * local2base;
			args += argcnt;
d319 1
a319 1
			return;
d323 6
a328 4
		(void)printf("Enter desired thickness: ");
		if( (argcnt = getcmd(args)) < 0 )
			return;
		thick[0] = atof( cmd_args[args] ) * local2base;
d331 1
a331 1
			return;
d335 6
a340 4
		(void)printf("Enter desired thickness: ");
		if( (argcnt = getcmd(args)) < 0 )
			return;
		thick[0] = atof( cmd_args[args] ) * local2base;
d343 1
a343 1
			return;
d349 6
a354 5
			(void)printf("%s",promp[i]);
			if( (argcnt = getcmd(args)) < 0 )
				return;
			thick[i] = atof( cmd_args[args] ) * local2base;
			args += argcnt;
d358 1
a358 1
			return;
d364 6
a369 5
			(void)printf("%s",promp[i]);
			if( (argcnt = getcmd(args)) < 0 )
				return;
			thick[i] = atof( cmd_args[args] ) * local2base;
			args += argcnt;
d373 1
a373 1
			return;
d379 6
a384 5
			(void)printf("%s",promp[i]);
			if( (argcnt = getcmd(args)) < 0 )
				return;
			thick[i] = atof( cmd_args[args] ) * local2base;
			args += argcnt;
d388 1
a388 1
			return;
d394 6
a399 5
			(void)printf("%s",promp[i]);
			if( (argcnt = getcmd(args)) < 0 )
				return;
			thick[i] = atof( cmd_args[args] ) * local2base;
			args += argcnt;
d403 1
a403 1
			return;
d409 6
a414 5
			(void)printf("%s",promp[i]);
			if( (argcnt = getcmd(args)) < 0 )
				return;
			thick[i] = atof( cmd_args[args] ) * local2base;
			args += argcnt;
d418 1
a418 1
			return;
d423 6
a428 4
		(void)printf( "%s" , promp[0] );
		if( (argcnt = getcmd(args)) < 0 )
			return;
		thick[0] = atof( cmd_args[args] ) * local2base;
d430 1
a430 1
			return;
d436 1
a436 1
		return;
d444 6
a449 1
	    	ALLOC_ERR_return;
a450 2
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )
		WRITE_ERR_return;
d457 1
a457 1
		f_edit( 2, arglist );
@


10.8
log
@Modified arbin to handle arb5's correctly.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 10.7 94/04/09 19:48:14 jra Exp Locker: jra $ (BRL)";
d461 1
a461 1
	int		num_pts=8;
d469 9
a477 5
	/* move new face planes for the desired thicknesses */
	for(i=0; i<nface; i++) {
		if( (planes[i][3] - VDOT(center_pt, &planes[i][0])) > 0.0 )
			thick[i] *= -1.0;
		planes[i][3] += thick[i];
d480 4
a483 2
	if( cgtype == 5 )
		num_pts = 4;
d493 4
d499 3
d503 1
a503 2
		fastf_t min_dist=MAX_FASTF;
		int min_pt;
d505 2
a506 1
		for( i=0 ; i<4 ; i++ )
d508 34
a541 17
			int j,k,l;

			j = i+1;
			if( j > 4 )
				j -= 4;
			k = i+2;
			if( k > 4 )
				k -= 4;
			l = i+3;
			if( l > 4 )
				l -= 4;

			if( rt_mkpoint_3planes( pt[i] , planes[j] , planes[k] , planes[l] ) )
			{
				(void)printf( "Cannot find inside arb5\n" );
				return( 1 );
			}
a542 1
		}
d545 3
d554 7
a560 3
		for( i=0 ; i<4 ; i++ )
		{
			fastf_t dist;
d562 3
a564 3
			dist = DIST_PT_PLANE( pt[i] , planes[0] );
			if( dist < 0.0 )
				dist = (-dist);
d566 3
a568 6
			if( dist < min_dist )
			{
				min_dist = dist;
				min_pt = i;
			}
		}
d570 1
a570 1
		if( min_pt == 0 || min_pt == 2 )
d585 8
d594 87
d1027 1
a1027 1
		rt_log( "No inside created\n" );
@


10.7
log
@Added NMG capability
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 10.6 93/09/29 16:14:20 jra Exp Locker: jra $ (BRL)";
d461 1
d476 3
d480 1
a480 1
	for(i=0; i<8; i++) {
d486 67
@


10.6
log
@Fixed inside command for arbs
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 10.5 93/08/25 08:14:18 jra Exp Locker: jra $ (BRL)";
d44 1
d53 3
d57 1
d141 3
d413 10
d781 53
@


10.5
log
@fixed error in "tgcin" (was computing an outer TGC in some cases).
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 10.4 92/03/25 15:53:24 mmark Exp Locker: jra $ (BRL)";
d216 3
a218 1
		if( (cgtype = rt_arb_get_cgtype( &intern, &tol )) <= 0 ) {
d459 1
a459 1
		if( rt_arb_3face_intersect( arb->pt[i], planes, cgtype, i ) < 0 )  {
@


10.4
log
@added erim solids
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 10.3 92/03/21 05:31:54 mike Exp $ (BRL)";
d504 3
@


10.3
log
@Converted over to "new way".
@
text
@d16 1
d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 10.2 92/03/20 15:26:00 mike Exp Locker: mike $ (BRL)";
d108 6
d115 22
d333 70
d620 137
@


10.2
log
@Code cleanup
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 10.1 91/10/12 06:43:47 mike Rel4_0 Locker: mike $ (BRL)";
d41 3
a43 1
#include "db.h"
d51 2
a59 4
void		arb_center();

static union record newrec;		/* new record to find inside solid */

d114 2
a115 1
	register struct directory *dp;
d117 2
a118 1
	int type, p1, p2, p3;
a119 1
	int	np;		/* number of points */
d121 4
d126 7
d142 3
a144 3
	 *	if in solid edit, use "edited" solid as newrec
	 *	if in object edit, use "key" solid as newrec
	 *	else get solid name to use as newrec
d148 1
a148 2
		/* solid edit mode, use edited solid for newrec */
		newrec = es_rec;
d150 2
a151 6
		MAT4X3PNT( &newrec.s.s_values[0], es_mat, &es_rec.s.s_values[0]);
		for(i=1; i<8; i++) {
			MAT4X3VEC(	&newrec.s.s_values[i*3],
					es_mat,
					&es_rec.s.s_values[i*3] );
		}
d164 1
a164 2
		/* use the solid at bottom of path (key solid) for newrec */
		newrec = es_rec;
d167 2
a168 6
		MAT4X3PNT( &newrec.s.s_values[0], newmat, &es_rec.s.s_values[0]);
		for(i=1; i<8; i++) {
			MAT4X3VEC(	&newrec.s.s_values[i*3],
					newmat,
					&es_rec.s.s_values[i*3] );
		}
d179 1
a179 1
		if( (dp = db_lookup( dbip,  cmd_args[args], LOOKUP_NOISY )) == DIR_NULL )  
d182 9
a190 1
		if( db_get( dbip,  dp, &newrec, 0 , 1) < 0 )  READ_ERR_return;
a191 10
		if( newrec.s.s_type == GENARB8 ) {
			/* find the comgeom arb type, & reorganize */
			if( (type = type_arb( &newrec )) == 0 ) {
				(void)printf("%s: BAD ARB\n",newrec.s.s_name);
				return;
			}
			newrec.s.s_cgtype = type;
		}
	}
	if(newrec.s.s_type == GENARB8) {
d195 4
a198 1
		calc_planes( &newrec.s, newrec.s.s_cgtype );
d200 1
a201 3
	/* newrec is now loaded with the outside solid data */


d216 1
a216 1
	NAMEMOVE( cmd_args[args], newrec.s.s_name );
d221 1
a221 1
	switch( newrec.s.s_type ) {
d223 5
a227 1
	case GENARB8:
a228 1
		np = newrec.s.s_cgtype;
d230 2
a231 9
		/* point notation */
		for(i=3; i<=21; i+=3) {
			VADD2(	&newrec.s.s_values[i],
				&newrec.s.s_values[i],
				&newrec.s.s_values[0] );
		}

		switch( newrec.s.s_cgtype ) {
		case ARB8:
d235 1
a235 1
		case ARB7:
d239 1
a239 1
		case ARB6:
d242 1
a242 2
			VMOVE( &newrec.s.s_values[15],
				&newrec.s.s_values[18] );
d245 1
a245 1
		case ARB5:
d250 1
a250 1
		case ARB4:
d253 1
a253 2
			VMOVE( &newrec.s.s_values[9],
				&newrec.s.s_values[12] );
d265 1
a265 1
		if( arbin(thick, nface, np) )
a266 7

		/* back to vector notation */
		for(i=3; i<=21; i+=3) {
			VSUB2(	&newrec.s.s_values[i],
				&newrec.s.s_values[i],
				&newrec.s.s_values[0] );
		}
d268 1
d270 1
a270 1
	case GENTGC:
d280 1
a280 1
		if( tgcin(thick) )
d284 1
a284 1
	case GENELL:
d290 1
a290 1
		if( ellgin(thick) )
d294 1
a294 1
	case TOR:
d300 1
a300 1
		if( torin(thick) )
d305 2
a306 1
		(void)printf("Cannot find inside for this record (%c) type\n",newrec.s.s_type);
d314 1
a314 2
	if( (dp = db_diradd( dbip,  newrec.s.s_name, -1, 0, DIR_SOLID )) == DIR_NULL ||
	    db_alloc( dbip, dp, 1 ) < 0 )  {
d317 2
a318 1
	if( db_put( dbip, dp, &newrec, 0, 1 ) < 0 )  WRITE_ERR_return;
d324 1
a324 1
		arglist[1] = newrec.s.s_name;
d333 2
a334 1
arbin(thick, nface, np)
d337 2
a338 1
int	np;
d340 3
a342 2
	vect_t	pc;
	int i;
d344 1
a344 2
	/* find reference point (pc[3]) to find direction of normals */
	arb_center(pc, newrec.s.s_values, np);
d346 4
a349 1
	/* new face planes for the desired thicknesses */
d351 1
a351 1
		if( (es_peqn[i][3] - VDOT(pc, &es_peqn[i][0])) > 0.0 )
d353 1
a353 1
		es_peqn[i][3] += thick[i];
d358 1
a358 1
		if( intersect(np, i*3, i, &newrec.s) ) {
a359 3
			/* restore es_peqn for anyone else */
			for(i=0; i<nface; i++)
				es_peqn[i][3] -= thick[i];
a362 4

	/* restore es_peqn for anyone else */
	for(i=0; i<nface; i++)
		es_peqn[i][3] -= thick[i];
a365 28
/* 
 *	A R B _ C E N T E R
 *
 * Find the center point for the arb whose values are in the s array,
 * with the given number of verticies.  Return the point in cpt.
 * WARNING: The s array is dbfloat_t's not fastf_t's.
 */
void
arb_center( cpt, s, npoints )
vect_t cpt;
dbfloat_t s[];
int npoints;
{
	int i,j,k;
	fastf_t temp;

	for(i=0; i<3; i++) {
		temp = 0.0;
		for(j=0; j<npoints; j++) {
			k = j * 3 + i;
			temp += s[k];
		}
		cpt[i] = temp / (fastf_t)npoints;
	}
}



d368 2
a369 1
tgcin(thick)
d372 1
d375 1
d384 1
d386 6
a391 4
	for(i=0; i<5; i++) {
		j = (i+1) * 3;
		mag[i] = MAGNITUDE( &newrec.s.s_values[j] );
	}
d394 5
a398 3
	VSCALE(unitH, &newrec.s.s_values[3], 1.0/mag[0]);
	VSCALE(unitA, &newrec.s.s_values[6], 1.0/mag[1]);
	VSCALE(unitB, &newrec.s.s_values[9], 1.0/mag[2]);
d411 2
a412 2
	dtha = VDOT(unitA, &newrec.s.s_values[3]);
	dthb = VDOT(unitB, &newrec.s.s_values[3]);
d435 5
a439 5
	VSCALE(&newrec.s.s_values[3], &newrec.s.s_values[3], nmag[0]/mag[0]);
	VSCALE(&newrec.s.s_values[6], &newrec.s.s_values[6], nmag[1]/mag[1]);
	VSCALE(&newrec.s.s_values[9], &newrec.s.s_values[9], nmag[2]/mag[2]);
	VSCALE(&newrec.s.s_values[12], &newrec.s.s_values[12], nmag[3]/mag[3]);
	VSCALE(&newrec.s.s_values[15], &newrec.s.s_values[15], nmag[4]/mag[4]);
d441 4
a444 4
	for( i=0; i<3; i++ ) 
		newrec.s.s_values[i] = newrec.s.s_values[i]
					 + unitH[i]*h1
		 + .5 * ( (aa[0] - aa[1])*unitA[i] + (ba[0] - ba[1])*unitB[i] );
d451 3
a453 2
torin(thick)
fastf_t	thick[6];
d455 1
a455 1
	fastf_t	mr1, mr2, mnewr2, msum, mdif, nmsum, nmdif;
d457 1
a457 1

a460 2
	mr1 = MAGNITUDE( &newrec.s.s_values[6] );
	mr2 = MAGNITUDE( &newrec.s.s_values[3] );
d462 1
a462 1
		if( (mr2 - thick[0]) > (mr1 + .01) ) {
d467 1
a467 1
	if( thick[0] >= mr2 ) {
d472 1
a472 10
	mnewr2 = mr2 - thick[0];
	VSCALE(&newrec.s.s_values[3],&newrec.s.s_values[3],mnewr2/mr2);
	msum = MAGNITUDE( &newrec.s.s_values[18] );
	mdif = MAGNITUDE( &newrec.s.s_values[12] );
	nmsum = mr1 + mnewr2;
	nmdif = mr1 - mnewr2;
	VSCALE(&newrec.s.s_values[12],&newrec.s.s_values[12],nmdif/mdif);
	VSCALE(&newrec.s.s_values[15],&newrec.s.s_values[15],nmdif/mdif);
	VSCALE(&newrec.s.s_values[18],&newrec.s.s_values[18],nmsum/msum);
	VSCALE(&newrec.s.s_values[21],&newrec.s.s_values[21],nmsum/msum);
d479 2
a480 1
ellgin(thick)
d483 1
d490 1
d492 5
a497 2
		j = (i + 1) * 3;
		mag[i] = MAGNITUDE( &newrec.s.s_values[j] );
a498 1
		thick[i] = thick[0];
d516 1
a516 4
			(void)printf("Warning: new vector length <= 0 \n");
		j = (i+1) * 3;
		VSCALE(&newrec.s.s_values[j], &newrec.s.s_values[j],
			nmag[i]/mag[i]);
d518 3
@


10.1
log
@Release_4.0
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 9.5 91/08/30 17:17:02 mike Exp $ (BRL)";
a57 3
static int	nface, np, nm, mp;
static fastf_t	thick[6];
static vect_t	pc;
d117 3
a145 7
		if(newrec.s.s_type == GENARB8) {
			/* must find new plane equations to account for
			 *	any editing in the es_mat matrix
			 */
			calc_planes( &newrec.s, newrec.s.s_cgtype );
		}

d151 1
a151 4
	}

	else
	if( state == ST_O_EDIT ) {
a167 7
		if(newrec.s.s_type == GENARB8) {
			/* must find new plane equations to account for
			 *	any editing done in the path to this solid
			 */
			calc_planes( &newrec.s, newrec.s.s_cgtype );
		}

d173 1
a173 3
	}

	else {
a181 20
		if(newrec.u_id != ID_SOLID) {
			(void)printf("%s: NOT a solid\n",dp->d_namep);
			return;
		}

		if( (type = newrec.s.s_cgtype) < 0 )
			type *= -1;
		if( type == BOX || type == RPP )
			type = ARB8;
		if( type == RAW ) {
			VMOVE(&newrec.s.s_values[3], &newrec.s.s_values[9]);
			VMOVE(&newrec.s.s_values[6], &newrec.s.s_values[21]);
			VMOVE(&newrec.s.s_values[9], &newrec.s.s_values[12]);
			VMOVE(&newrec.s.s_values[12], &newrec.s.s_values[3]);
			VMOVE(&newrec.s.s_values[15], &newrec.s.s_values[6]);
			VMOVE(&newrec.s.s_values[18], &newrec.s.s_values[18]);
			VMOVE(&newrec.s.s_values[21], &newrec.s.s_values[15]);
		}
		newrec.s.s_cgtype = type;

d183 1
a183 1
			/* find the comgeom arb type */
a188 3

			/* find the plane equations */
			calc_planes( &newrec.s, type );
d191 6
d222 3
a224 5
		case GENARB8:
			nface = 6;
			np = newrec.s.s_cgtype;
			nm = np - 4;
			mp = 8;
d226 6
a231 6
			/* point notation */
			for(i=3; i<=21; i+=3) {
				VADD2(	&newrec.s.s_values[i],
					&newrec.s.s_values[i],
					&newrec.s.s_values[0] );
			}
d233 4
a236 1
			switch( newrec.s.s_cgtype ) {
d238 3
a240 3
				case ARB8:
					promp = p_arb8;
				break;
d242 6
a247 3
				case ARB7:
					promp = p_arb7;
				break;
d249 4
a252 7
				case ARB6:
					promp = p_arb6;
					nface = 5;
					mp = 6;
					VMOVE( &newrec.s.s_values[15],
						&newrec.s.s_values[18] );
				break;
d254 7
a260 5
				case ARB5:
					promp = p_arb5;
					nface = 5;
					mp = 6;
				break;
d262 3
a264 17
				case ARB4:
					promp = p_arb4;
					nface = mp = 4;
					VMOVE( &newrec.s.s_values[9],
						&newrec.s.s_values[12] );
				break;
			}

			for(i=0; i<nface; i++) {
				(void)printf("%s",promp[i]);
				if( (argcnt = getcmd( args )) < 0 )
					return;
				thick[i] = atof(cmd_args[args]) * local2base;
				args += argcnt;
			}

			if( arbin() )
d266 3
d270 2
a271 7
			/* back to vector notation */
			for(i=3; i<=21; i+=3) {
				VSUB2(	&newrec.s.s_values[i],
					&newrec.s.s_values[i],
					&newrec.s.s_values[0] );
			}
		break;
d273 6
a278 12
		case GENTGC:
			promp = p_tgcin;
			for(i=0; i<3; i++) {
				(void)printf("%s",promp[i]);
				if( (argcnt = getcmd(args)) < 0 )
					return;
				thick[i] = atof( cmd_args[args] ) * local2base;
				args += argcnt;
			}

			if( tgcin() )
				return;
d281 4
a284 2
		case GENELL:
			(void)printf("Enter desired thickness: ");
d287 3
a289 1
			thick[0] = atof( cmd_args[args] ) * local2base;
d291 2
a292 2
			if( ellgin() )
				return;
d295 5
a299 5
		case TOR:
			(void)printf("Enter desired thickness: ");
			if( (argcnt = getcmd(args)) < 0 )
				return;
			thick[0] = atof( cmd_args[args] ) * local2base;
d301 2
a302 2
			if( torin() )
				return;
d305 3
a307 2
		default:
			(void)printf("Cannot find inside for this record (%c) type\n",newrec.s.s_type);
d309 9
d343 4
a346 1
arbin()
d348 1
d408 2
a409 1
tgcin()
d483 2
a484 1
torin()
d521 2
a522 1
ellgin()
d528 1
a528 1
	if( thick[0] == 0.0 ) 
@


9.5
log
@strlen returns unsigned, ANSI comparison with int requires cast.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 9.4 90/12/08 00:31:20 mike Exp $ (BRL)";
@


9.4
log
@Added error checking around calls to db_*() routines
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/inside.c,v 9.3 90/04/21 06:06:10 mike Exp $ (BRL)";
d247 1
a247 1
	if( strlen(cmd_args[args]) >= NAMESIZE )  {
@


9.3
log
@redraw() and drawtree() replaced.
More emphasis on argv/argc use in command functions.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 9.2 89/10/27 22:48:42 mike Locked $ (BRL)";
d199 1
a199 1
		db_get( dbip,  dp, &newrec, 0 , 1);
d365 5
a369 4
	if( (dp = db_diradd( dbip,  newrec.s.s_name, -1, 0, DIR_SOLID )) == DIR_NULL )
		return;
	db_alloc( dbip, dp, 1 );
	db_put( dbip, dp, &newrec, 0, 1 );
@


9.2
log
@generalized center(), now arb_center() so that it could also
be used by anal.c.  Note there is yet another version in proc_reg.c
but it uses fastf's, which this one uses dbfloat's (sigh).
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 9.1 89/05/19 06:03:20 phil Locked $ (BRL)";
d368 1
d370 7
a376 5
	db_put( dbip, dp, &newrec, 0, 1 );
	/* draw the "inside" solid */
	drawtree( dp );
	dmp->dmr_colorchange();
	dmaflag = 1;
@


9.1
log
@Release_3.5
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 8.8 89/05/18 00:00:35 mike Exp $ (BRL)";
d56 1
a56 1
void		center();
d385 1
a385 1
	center();
d411 7
a417 2

/* finds reference center point (pc[3]) for the arb */
d419 4
a422 1
center()
d424 2
a425 2
	register int i, j, k;
	register fastf_t ppc;
d428 2
a429 2
		ppc = 0.0;
		for(j=0; j<np; j++) {
d431 1
a431 1
			ppc += newrec.s.s_values[k];
d433 1
a433 1
		pc[i] = ppc / (fastf_t)np;
a435 1

@


8.8
log
@Missing include file
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 8.7 89/05/17 23:34:36 mike Locked $ (BRL)";
@


8.7
log
@Added colorchange() call.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 8.6 89/05/11 21:42:21 mike Locked $ (BRL)";
d47 1
@


8.6
log
@db_diradd had the length and flags parameters backward
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 8.5 89/04/07 02:31:41 phil Locked $ (BRL)";
d371 1
@


8.5
log
@MAXLINE moved into ged.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 8.4 89/04/06 20:40:06 mike Locked $ (BRL)";
d364 1
a364 1
	if( (dp = db_diradd( dbip,  newrec.s.s_name, -1, DIR_SOLID, 0 )) == DIR_NULL )
@


8.4
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 8.3 89/01/16 22:51:46 mike Locked $ (BRL)";
a60 2

#define MAXLINE		512	/* Maximum number of chars per line */
@


8.3
log
@drawHobj() --> drawtree()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 8.2 88/12/06 01:26:02 mike Locked $ (BRL)";
d45 1
@


8.2
log
@Converted to new db_*() routines.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/inside.c,v 1.2 88/10/23 13:56:36 mike Exp $ (BRL)";
d371 1
a371 1
	drawHobj(dp, ROOT, 0, identity);
@


8.1
log
@Release_3.0
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 7.4 88/09/19 22:48:39 mike Exp $ (BRL)";
d42 1
a43 1
#include "./objdir.h"
d196 1
a196 1
		if( (dp = lookup( cmd_args[args], LOOKUP_NOISY )) == DIR_NULL )  
d199 1
a199 1
		db_getrec( dp, &newrec, 0 );
d243 1
a243 1
	if( lookup( cmd_args[args], LOOKUP_QUIET ) != DIR_NULL ) {
d365 1
a365 1
	if( (dp = dir_add( newrec.s.s_name, -1, DIR_SOLID, 0 )) == DIR_NULL )
d367 1
a367 1
	db_alloc( dp, 1 );
d369 1
a369 1
	db_putrec( dp, &newrec, 0 );
@


7.4
log
@atof() is better defined by <math.h>
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 7.3 88/05/15 23:05:12 mike Locked $ (BRL)";
@


7.3
log
@lint fixes
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 7.2 87/11/05 05:06:16 mike Locked $ (BRL)";
a45 2

extern double atof();
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 7.1 87/11/03 00:01:07 mike Rel $ (BRL)";
a46 1
extern void aexists();
a47 1
extern void f_quit();
d56 2
d246 1
a246 1
		(void)aexists( cmd_args[args] );
d414 2
a415 1
center( )
d417 2
a419 3
	int i, j, k;
	fastf_t ppc;

a427 3

	return;

@


7.1
log
@Release 2.3
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 6.1 87/07/11 08:04:22 mike Rel $ (BRL)";
d39 1
a39 1
#include "./machine.h"	/* special copy */
d59 2
a60 1
static float	thick[6], pc[3];
d418 1
a418 1
	float ppc;
d426 1
a426 1
		pc[i] = ppc / (float)np;
d440 7
a446 4
	float mag[5], nmag[5], unitH[3], unitA[3], unitB[3];
	float hwork[3], aa[2], ab[2], ba[2], bb[2];
	float dt, h1, h2, ht, dtha, dthb, s, d4, d5, ctan, t3;
	int i, j, k;
d514 1
a514 1
	float mr1, mr2, mnewr2, msum, mdif, nmsum, nmdif;
d552 2
a553 2
	float mag[3], nmag[3];
	double ratio;
d582 2
a583 1
		VSCALE(&newrec.s.s_values[j],&newrec.s.s_values[j],nmag[i]/mag[i]);
@


6.1
log
@Release 2.0
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 5.1 87/06/24 22:21:10 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 4.3 87/02/13 00:07:57 mike Exp $ (BRL)";
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 4.2 87/02/11 05:38:41 mike Exp $ (BRL)";
@


4.2
log
@Minor cleanups inspired by the Cray
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 4.1 86/12/29 03:22:01 mike Locked $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 2.2 86/09/23 17:41:34 mike Exp $ (BRL)";
d51 3
a53 3
int		args;		/* total number of args available */
int		argcnt;		/* holder for number of args added later */
int		newargs;	/* number of args from getcmd() */
d56 1
a56 1
char		**promp;	/* pointer to a pointer to a char */
@


2.2
log
@Minor cleanup for cray
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 2.1 86/09/09 22:06:26 mike Exp $ (BRL)";
@


2.1
log
@Loop for inside name, resotre es_peqn.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 1.5 86/08/12 06:49:52 mike Exp $ (BRL)";
d32 2
d35 4
a38 1
#include <math.h>
@


1.5
log
@Changed #includes for CC -I../h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 1.4 86/03/10 21:38:37 mike Exp $ (BRL)";
d232 1
d234 5
a238 2
	(void)printf("Enter name of the inside solid: ");
	argcnt = getcmd(args);
d393 3
d400 3
@


1.4
log
@Latest revisions from Keith, including lots of new commands
and one-axis scaling.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 1.3 85/09/27 19:12:24 mike Exp $ (BRL)";
d33 1
d35 6
a40 7
#include "../h/vmath.h"
#include "../h/db.h"
#include "ged.h"
#include "objdir.h"
#include "sedit.h"
#include <math.h>
#include "solid.h"
@


1.3
log
@KAA code reorganization.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 1.2 85/09/14 05:36:50 mike Exp $ (BRL)";
d235 2
a236 2
	if( lookup( cmd_args[2], LOOKUP_QUIET ) != DIR_NULL ) {
		(void)aexists( cmd_args[2] );
d239 1
a239 1
	if( strlen(cmd_args[2]) >= NAMESIZE )  {
@


1.2
log
@Lint-inspired cleanup.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: inside.c,v 1.1 85/09/12 00:25:55 mike Exp $ (BRL)";
d141 8
d173 8
d226 1
a226 24
			for(i=3; i<=21; i+=3) {
				VADD2(	&newrec.s.s_values[i],
					&newrec.s.s_values[i],
					&newrec.s.s_values[0] );
			}
			type -= 4;
			for(i=0; i<6; i++) {
				if(arb_faces[type][i*4] == -1)
					break;
				p1 = arb_faces[type][i*4+0];
				p2 = arb_faces[type][i*4+1];
				p3 = arb_faces[type][i*4+2];
				if(planeqn(i, p1, p2, p3, &newrec.s)) {
					(void)printf("No eqn for face %d%d%d%d\n",
						p1+1,p2+1,p3+1,arb_faces[type][i*4+3]+1);
					return;
				}
			}
			/* back to vector notation */
			for(i=3; i<=21; i+=3) {
				VSUB2(	&newrec.s.s_values[i],
					&newrec.s.s_values[i],
					&newrec.s.s_values[0] );
			}
d429 2
@


1.1
log
@Initial revision
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.13 85/08/29 14:55:21 mike Exp $ (BRL)";
d217 1
a217 1
				if(faces[type][i*4] == -1)
d219 3
a221 3
				p1 = faces[type][i*4+0];
				p2 = faces[type][i*4+1];
				p3 = faces[type][i*4+2];
d224 1
a224 1
						p1+1,p2+1,p3+1,faces[type][i*4+3]+1);
@
