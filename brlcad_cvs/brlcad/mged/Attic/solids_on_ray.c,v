head	1.38;
access;
symbols
	ansi-20040405-merged:1.34.2.2
	postmerge-20040405-ansi:1.36
	premerge-20040404-ansi:1.35
	postmerge-autoconf:1.35
	autoconf-freeze:1.34.10.2
	premerge-autoconf:1.35
	postmerge-20040315-windows:1.35
	premerge-20040315-windows:1.35
	windows-20040315-freeze:1.34.4.1
	autoconf-20031203:1.34
	autoconf-20031202:1.34
	autoconf-branch:1.34.0.10
	phong-branch:1.34.0.8
	photonmap-branch:1.34.0.6
	rel-6-1-DP:1.34
	windows-branch:1.34.0.4
	rel-6-0-2:1.32
	ansi-branch:1.34.0.2
	rel-6-0-1-branch:1.32.0.2
	hartley-6-0-post:1.33
	hartley-6-0-pre:1.32
	rel-6-0-1:1.32
	rel-6-0:1.32
	rel-5-4:1.24
	offsite-5-3-pre:1.28
	rel-5-3:1.24
	rel-5-2:1.24
	rel-5-1-branch:1.24.0.2
	rel-5-1:1.24
	rel-5-0:1.22
	rel-5-0-beta:1.22
	rel-4-5:1.19
	ctj-4-5-post:1.18
	ctj-4-5-pre:1.18;
locks; strict;
comment	@ * @;


1.38
date	2004.05.21.17.47.50;	author morrison;	state dead;
branches;
next	1.37;

1.37
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	1.35;

1.35
date	2004.02.02.17.39.35;	author morrison;	state Exp;
branches;
next	1.34;

1.34
date	2002.08.20.17.08.25;	author jra;	state Exp;
branches
	1.34.2.1
	1.34.4.1
	1.34.10.1;
next	1.33;

1.33
date	2002.08.15.20.55.38;	author hartley;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.05.21.20.07;	author morrison;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.18.19.22.06;	author bparker;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.05.19.35.45;	author morrison;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.02.21.20.40;	author bparker;	state Exp;
branches;
next	1.28;

1.28
date	2000.10.24.19.05.09;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.24.15.14.13;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.20.05.04.39;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.19.03.10.49;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	99.12.30.20.13.34;	author jra;	state Exp;
branches;
next	1.23;

1.23
date	99.11.12.21.16.28;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	98.12.30.04.36.45;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	98.09.14.15.59.20;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	98.03.24.09.45.20;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	97.06.13.22.20.31;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	97.02.28.21.44.01;	author jra;	state Exp;
branches;
next	1.17;

1.17
date	97.01.09.01.26.35;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	96.10.04.15.06.34;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	96.09.25.20.16.42;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	96.09.23.18.15.59;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	96.09.23.15.01.22;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	96.09.03.15.58.52;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	96.04.18.20.25.25;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	95.08.10.21.11.19;	author gdurf;	state Exp;
branches;
next	1.7;

1.7
date	95.08.08.20.28.25;	author gdurf;	state Exp;
branches;
next	1.6;

1.6
date	95.07.25.17.54.21;	author gdurf;	state Exp;
branches;
next	1.5;

1.5
date	95.07.20.17.09.05;	author pjt;	state Exp;
branches;
next	1.4;

1.4
date	95.07.12.16.53.34;	author pjt;	state Exp;
branches;
next	1.3;

1.3
date	95.07.11.19.20.01;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	95.07.10.20.10.51;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	95.07.10.14.52.17;	author pjt;	state Exp;
branches;
next	;

1.34.2.1
date	2002.09.19.18.02.04;	author morrison;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2004.03.17.21.22.04;	author morrison;	state Exp;
branches;
next	;

1.34.4.1
date	2004.03.11.23.46.36;	author morrison;	state Exp;
branches;
next	;

1.34.10.1
date	2004.02.12.18.34.16;	author erikg;	state Exp;
branches;
next	1.34.10.2;

1.34.10.2
date	2004.03.15.14.07.41;	author erikg;	state Exp;
branches;
next	;


desc
@     Routines to implement the click-to-pick-an-edit-solid
     facility.
@


1.38
log
@moved to src/mged/
@
text
@/*
 *		S O L I D S _ O N _ R A Y . C
 *
 *	Routines to implement the click-to-pick-an-edit-solid feature.
 *
 *  Functions -
 *	skewer_solids		fire a ray and list the solids hit
 *
 *  Author -
 *	Paul Tanenbaum
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/solids_on_ray.c,v 1.37 2004/05/10 15:30:48 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <signal.h>

#include "tcl.h"
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "redblack.h"
#include "raytrace.h"
#include "externs.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./mged_dm.h"

#define	ORDER_BY_NAME		 0
#define	ORDER_BY_DISTANCE	 1

#define	made_it()		printf("Made it to %s%d\n", \
					__FILE__, __LINE__); \
				fflush(stdout)

/*
 *		S O L _ N A M E _ D I S T
 *
 *	Little pair for storing the name and distance of a solid
 */
struct sol_name_dist
{
    long	magic;
    char	*name;
    fastf_t	dist;
};
#define	SOL_NAME_DIST_MAGIC	0x736c6e64

#if OLD_RPT
/*
 *		S O L _  C O M P _ N A M E
 *
 *	The function to order solids alphabetically by name
 */
static int
sol_comp_name(v1, v2)
void *v1, *v2;    
{
    struct sol_name_dist	*s1 = v1;
    struct sol_name_dist	*s2 = v2;

    BU_CKMAG(s1, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");
    BU_CKMAG(s2, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");

    return(strcmp(s1 -> name, s2 -> name));
}

/*
 *		S O L _  C O M P _ D I S T
 *
 *	The function to order solids by distance along the ray
 */
static int
sol_comp_dist(v1, v2)
void *v1, *v2;    
{
    struct sol_name_dist	*s1 = v1;
    struct sol_name_dist	*s2 = v2;

    BU_CKMAG(s1, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");
    BU_CKMAG(s2, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");

    if (s1 -> dist > s2 -> dist)
	return (1);
    else if (s1 -> dist == s2 -> dist)
	return (0);
    else /* (s1 -> dist < s2 -> dist) */
	return (-1);
}

/*
 *			M K _ S O L I D
 */
static struct sol_name_dist *
mk_solid(name, dist)
char	*name;
fastf_t	dist;
{
    struct sol_name_dist	*sp;

    sp = (struct sol_name_dist *)
	    bu_malloc(sizeof(struct sol_name_dist), "solid");
    sp -> magic = SOL_NAME_DIST_MAGIC;
    sp -> name = (char *)
	    bu_malloc(strlen(name) + 1, "solid name");
    (void) strcpy(sp -> name, name);
    sp -> dist = dist;
    return (sp);
}

/*
 *			F R E E _ S O L I D
 *
 *	This function has two parameters: the solid to free and
 *	an indication whether the name member of the solid should
 *	also be freed.
 */
static void
free_solid(sol, free_name)
struct sol_name_dist	*sol;
int			free_name;

{
    BU_CKMAG(sol, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");

    if (free_name)
	bu_free((genptr_t) sol -> name, "solid name");
    bu_free((genptr_t) sol, "solid");
}

/*
 *			P R I N T _ S O L I D
 */
static void
print_solid(vp, depth)
void	*vp;
int	depth;
{
    struct sol_name_dist	*sol = vp;
    struct bu_vls tmp_vls;

    BU_CKMAG(sol, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");

    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "solid %s at distance %g along ray\n",
		  sol -> name, sol -> dist);
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
}
#endif /* OLD_RPT */


/*
 *			    N O _ O P
 *
 *	    Null event handler for use by rt_shootray().
 *
 *	Does nothing.  Returns 1.
 */
static int
no_op(struct application *ap, struct partition *ph)
{
    return (1);
}

/*
 *	    B U I L D _ P A T H _ N A M E _ O F _ S O L I D ( )
 *
 *	Builds the slash-separated path name for a struct solid.
 */
void
build_path_name_of_solid(struct bu_vls *vp, struct solid *sp)
{
    bu_vls_trunc(vp, 0);
    db_path_to_vls(vp, &sp->s_fullpath);
}

#if OLD_RPT
/*
 *			R P T _ S O L I D S
 *
 *		Hit handler for use by rt_shootray().
 *
 *	Grabs the first partition it sees, extracting thence
 *	the segment list.  Rpt_solids() sorts the solids along
 *	the ray by first encounter.  As a side-effect, rpt_solids()
 *	stores in ap->a_uptr the address of a null-terminated array
 *	of the sorted solid names.  If ap->a_user is nonzero,
 *	rpt_solids() stashes the complete path name for each solid,
 *	otherwise, just its basename.  It returns 1.
 */
/* If this is defined inside the body of rpt_solids(), it causes
 * the IRIX 6 compilers to segmentation fault in WHIRL file phase. Ugh. */
static int			(*rpt_solids_orders[])() =
				{
				    sol_comp_name,
				    sol_comp_dist
				};

static int
rpt_solids(ap, ph, finished_segs)
struct application	*ap;
struct partition	*ph;
struct seg		*finished_segs;
{
    char			**result;
    struct db_full_path		*fp;
    int				i;
    struct partition		*pp;
    bu_rb_tree			*solids;
    struct seg			*segp;
    struct sol_name_dist	*old_sol;
    struct sol_name_dist	*sol;
    struct soltab		*stp;
    struct bu_vls		sol_path_name;
    int				index;

    /*
     *	Initialize the solid list
     */
    if ((solids = bu_rb_create("Primitive list", 2, rpt_solids_orders)) == BU_RB_TREE_NULL)
    {
	bu_log("%s: %d: bu_rb_create() bombed\n", __FILE__, __LINE__);
	exit (1);
    }
    solids -> rbt_print = print_solid;
    bu_rb_uniq_on(solids, ORDER_BY_NAME);

    bu_vls_init(&sol_path_name);

    /*
     *	Get the list of segments along this ray
     *	and seek to its head
     */
    BU_CKMAG(ph, PT_HD_MAGIC, "partition head");
    pp = ph -> pt_forw;
    BU_CKMAG(pp, PT_MAGIC, "partition structure");
    if (BU_LIST_MAGIC_WRONG((struct bu_list *) finished_segs,
			    RT_SEG_MAGIC))
	BU_CKMAG(finished_segs, BU_LIST_HEAD_MAGIC, "list head");

    /*
     *	New stuff
     */

    RT_CK_LIST_HEAD(&finished_segs->l);

    for (RT_LIST_FOR(pp, partition, (struct bu_list *) &ph -> pt_magic))
    {
	BU_CKMAG(pp, PT_MAGIC, "partition");
	BU_CKMAG(pp -> pt_regionp, RT_REGION_MAGIC, "region");
	printf("    Partition <x%lx> is '%s' ",
	    (long)pp, pp -> pt_regionp -> reg_name);
	
	printf("\n--- Primitives hit on this partition ---\n");
	for (i = 0; i < (pp -> pt_seglist).end; ++i)
	{
	    stp = ((struct seg *)BU_PTBL_GET(&pp->pt_seglist, i))->seg_stp;
	    RT_CK_SOLTAB(stp);
	    bu_vls_trunc(&sol_path_name, 0);
	    fp = &(stp -> st_path);
	    if (fp -> magic != 0)
	    {
		printf(" full path... ");fflush(stdout);
		RT_CK_FULL_PATH(fp);
		bu_vls_strcpy(&sol_path_name, db_path_to_string(fp));
	    }
	    else
	    {
		printf(" dir-entry name... ");fflush(stdout);
		BU_CKMAG(stp -> st_dp, RT_DIR_MAGIC,
		    "directory");
		bu_vls_strcpy(&sol_path_name, stp -> st_name);
	    }
	    printf("'%s'\n", bu_vls_addr(&sol_path_name));fflush(stdout);
	}
	printf("------------------------------------\n");

    /*
     *	Look at each segment that participated in this ray partition.
     */
    for( index = 0; index < BU_PTBL_END(&pp->pt_seglist); index++ )  {
        segp = (struct seg *)BU_PTBL_GET(&pp->pt_seglist, index);
	RT_CK_SEG(segp);
	RT_CK_SOLTAB(segp -> seg_stp);

	printf("Primitive #%d in this partition is ", index);fflush(stdout);
	bu_vls_trunc(&sol_path_name, 0);
	fp = &(segp -> seg_stp -> st_path);
	if (fp -> magic != 0)
	{
		printf(" full path... ");fflush(stdout);
		RT_CK_FULL_PATH(fp);
		bu_vls_strcpy(&sol_path_name, db_path_to_string(fp));
	}
	else
	{
		printf(" dir-entry name... ");fflush(stdout);
		BU_CKMAG(segp -> seg_stp -> st_dp, RT_DIR_MAGIC,
		    "directory");
		bu_vls_strcpy(&sol_path_name, segp -> seg_stp -> st_name);
	}
	printf("'%s'\n", bu_vls_addr(&sol_path_name));

	/*
	 *	Attempt to record the new solid.
	 *	If it shares its name with a previously recorded solid,
	 *	then retain the one that appears earlier on the ray.
	 */
	sol = mk_solid(bu_vls_addr(&sol_path_name),
		    segp -> seg_in.hit_dist);
	if (bu_rb_insert(solids, (void *) sol) < 0)
	{
	    old_sol = (struct sol_name_dist *)
			bu_rb_curr(solids, ORDER_BY_NAME);
	    BU_CKMAG(old_sol, SOL_NAME_DIST_MAGIC,
		"sol_name_dist structure");
	    if (sol -> dist >= old_sol -> dist)
		free_solid(sol, 1);
	    else
	    {
		bu_rb_delete(solids, ORDER_BY_NAME);
		bu_rb_insert(solids, sol);
		free_solid(old_sol, 1);
	    }
	}
    }
    }

    /*
     *	Record the resulting list of solid names
     *	for use by the calling function
     */
    result = (char **)
		bu_malloc((solids -> rbt_nm_nodes + 1) * sizeof(char *),
			  "names of solids on ray");
    for (sol = (struct sol_name_dist *) bu_rb_min(solids, ORDER_BY_DISTANCE),
		i=0;
	 sol != NULL;
	 sol = (struct sol_name_dist *) bu_rb_succ(solids, ORDER_BY_DISTANCE),
		++i)
    {
	result[i] = sol -> name;
	free_solid(sol, 0);
    }
    result[i] = 0;
    ap -> a_uptr = (char *) result;

    bu_rb_free(solids, BU_RB_RETAIN_DATA);

    return 1;
    /*
     *	End new stuff
     */
#if 0

    for (segh = pp -> pt_inseg;
	    *((long *) segh) != BU_LIST_HEAD_MAGIC;
	    segh = (struct seg *) (segh -> l.forw))
	BU_CKMAG(segh, RT_SEG_MAGIC, "segment structure");

    /*
     *	Let's see what final_segs contains...
     */
    RT_CHECK_SEG(final_segs -> seg_stp);
    bu_vls_trunc(&sol_path_name, 0);
    fp = &(final_segs -> seg_stp -> st_path);
    bu_vls_strcpy(&sol_path_name, db_path_to_string(fp));
    printf("At line %d, sol_path_name contains '%s'\n",
	    __LINE__, bu_vls_addr(&sol_path_name));

    /*
     *	March down the segment list
     */
    for (segp = (struct seg *) (segh -> l.forw);
	    segp != segh;
	    segp = (struct seg *) segp -> l.forw)
    {
	BU_CKMAG(segp, RT_SEG_MAGIC, "seg structure");
	
	bu_vls_trunc(&sol_path_name, 0);
	fp = &(segp -> seg_stp -> st_path);
	printf("At line %d, sol_path_name contains '%s'\n",
		__LINE__, bu_vls_addr(&sol_path_name));
	if (fp -> magic)
	    bu_vls_strcpy(&sol_path_name, db_path_to_string(fp));
	printf("At line %d, sol_path_name contains '%s'\n",
		__LINE__, bu_vls_addr(&sol_path_name));
	bu_vls_strcat(&sol_path_name, segp -> seg_stp -> st_name);
	printf("At line %d, sol_path_name contains '%s'\n",
		__LINE__, bu_vls_addr(&sol_path_name));
	sol = mk_solid(bu_vls_addr(&sol_path_name),
		    segp -> seg_in.hit_dist);
	printf("and segp -> seg_stp = %x\n", segp -> seg_stp);
	/*
	 *	Attempt to record the new solid.
	 *	If it shares its name with a previously recorded solid,
	 *	then retain the one that appears earlier on the ray.
	 */
	if (bu_rb_insert(solids, (void *) sol) < 0)
	{
	    old_sol = (struct sol_name_dist *)
			bu_rb_curr(solids, ORDER_BY_NAME);
	    BU_CKMAG(old_sol, SOL_NAME_DIST_MAGIC,
		"sol_name_dist structure");
	    if (sol -> dist >= old_sol -> dist)
		free_solid(sol, 1);
	    else
	    {
		bu_rb_delete(solids, ORDER_BY_NAME);
		bu_rb_insert(solids, sol);
		free_solid(old_sol, 1);
	    }
	}
    }
    printf("HELLO %s:%d\n", __FILE__, __LINE__);

    result = (char **)
		bu_malloc((solids -> rbt_nm_nodes + 1) * sizeof(char *),
			  "names of solids on ray");
    for (sol = (struct sol_name_dist *) bu_rb_min(solids, ORDER_BY_DISTANCE),
		i=0;
	 sol != NULL;
	 sol = (struct sol_name_dist *) bu_rb_succ(solids, ORDER_BY_DISTANCE),
		++i)
    {
	result[i] = sol -> name;
	free_solid(sol, 0);
    }
    result[i] = 0;
    ap -> a_uptr = (char *) result;

    bu_rb_free(solids, RB_RETAIN_DATA);
    return (1);
#endif
}
#endif

/*
 *			R P T _ H I T S _ M I K E
 *
 *  Each partition represents a segment, i.e. a single solid.
 *  Boolean operations have not been performed.
 *  The partition list is sorted by ascending inhit distance.
 *  This code does not attempt to eliminate duplicate segs,
 *  e.g. from piercing the torus twice.
 */
static int
rpt_hits_mike(struct application *ap, struct partition *PartHeadp, struct seg *segp)
{
	register struct partition	*pp;
	int		len;
	char		**list;
	int		i;

	len = rt_partition_len(PartHeadp) + 2;
	list = (char **)bu_calloc( len, sizeof(char *), "hit list[]");

	i = 0;
	for( pp = PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {
		RT_CK_PT(pp);
		list[i++] = db_path_to_string( &(pp->pt_inseg->seg_stp->st_path) );
	}
	list[i++] = NULL;
	if( i > len )  bu_bomb("rpt_hits_mike: array overflow\n");

	ap->a_uptr = (genptr_t)list;
	return len;
}

/*
 *			R P T _ M I S S
 *
 *		Miss handler for use by rt_shootray().
 *
 *	Stuffs the address of a null string in ap->a_uptr and returns 0.
 */

static int
rpt_miss(struct application *ap)
{
	ap->a_uptr = NULL;

    return (0);
}

/*
 *		    S K E W E R _ S O L I D S
 *
 *	Fire a ray at some geometry and obtain a list of
 *	the solids encountered, sorted by first intersection.
 *
 *	The function has five parameters: the model and objects at which
 *	to fire (in an argc/argv pair) the origination point and direction
 *	for the ray, and a result-format specifier.  So long as it could
 *	find the objects in the model, skewer_solids() returns a null-
 *	terminated array of solid names.  Otherwise, it returns 0.  If
 *	full_path is nonzero, then the entire path for each solid is
 *	recorded.  Otherwise, only the basename is recorded.
 *
 *	N.B. - It is the caller's responsibility to free the array
 *	of solid names.
 */
char **skewer_solids (int argc, const char **argv, fastf_t *ray_orig, fastf_t *ray_dir, int full_path)
{
    struct application	ap;
    struct rt_i		*rtip;
    struct bu_list	sol_list;

	if (argc <= 0) {
		Tcl_AppendResult( interp, "skewer_solids argc<=0\n", (char *)NULL );
		return ((char **) 0);
	}

	/* .inmem rt_gettrees .rt -i -u [who] */
	rtip = rt_new_rti( dbip );
	rtip->useair = 1;
	rtip->rti_dont_instance = 1;	/* full paths to solids, too. */
	if (rt_gettrees(rtip, argc, argv, 1) == -1) {
		Tcl_AppendResult( interp, "rt_gettrees() failed\n", (char *)NULL );
		rt_clean(rtip);
		bu_free((genptr_t)rtip, "struct rt_i");
		return ((char **) 0);
	}

	/* .rt prep 1 */
	rtip->rti_hasty_prep = 1;
	rt_prep(rtip);

    BU_LIST_INIT(&sol_list);

    /*
     *	Initialize the application
     */
    ap.a_magic = RT_AP_MAGIC;
    ap.a_ray.magic = RT_RAY_MAGIC;
    ap.a_hit = rpt_hits_mike;
    ap.a_miss = rpt_miss;
    ap.a_resource = RESOURCE_NULL;
    ap.a_overlap = no_op;
    ap.a_onehit = 0;
    ap.a_user = 1;	/* Requests full paths to solids, not just basenames */
    ap.a_rt_i = rtip;
    ap.a_zero1 = ap.a_zero2 = 0;
    ap.a_purpose = "skewer_solids()";
    ap.a_no_booleans = 1;		/* full paths, no booleans */
    VMOVE(ap.a_ray.r_pt, ray_orig);
    VMOVE(ap.a_ray.r_dir, ray_dir);

    (void) rt_shootray(&ap);

	rt_clean(rtip);
	bu_free((genptr_t)rtip, "struct rt_i");

    return ((char **) ap.a_uptr);
}
@


1.37
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/solids_on_ray.c,v 1.36 2004/04/05 09:09:12 morrison Exp $ (ARL)";
@


1.36
log
@merge of ansi-6-0-branch into HEAD
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d29 5
a33 1
#include "conf.h"
@


1.35
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.34 2002/08/20 17:08:25 jra Exp $ (ARL)";
d178 1
a178 3
no_op(ap, ph)
struct application	*ap;
struct partition	*ph;
d189 1
a189 3
build_path_name_of_solid(vp, sp)
struct bu_vls	*vp;
struct solid	*sp;
d466 1
a466 4
rpt_hits_mike(ap, PartHeadp, segp)
struct application	*ap;
struct partition	*PartHeadp;
struct seg		*segp;
d497 1
a497 2
rpt_miss(ap)
struct application	*ap;
d521 1
a521 8
char **skewer_solids (argc, argv, ray_orig, ray_dir, full_path)

int		argc;
const char	**argv;
point_t		ray_orig;
vect_t		ray_dir;
int		full_path;

@


1.34
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1995 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.32 2001/11/05 21:20:07 morrison Exp $ (ARL)";
@


1.34.4.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/solids_on_ray.c,v 1.35 2004/02/02 17:39:35 morrison Exp $ (ARL)";
@


1.34.10.1
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.35 2004/02/02 17:39:35 morrison Exp $ (ARL)";
@


1.34.10.2
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.34.10.1 2004/02/12 18:34:16 erikg Exp $ (ARL)";
@


1.34.2.1
log
@Initial ANSIfication
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.34 2002/08/20 17:08:25 jra Exp $ (ARL)";
d178 3
a180 1
no_op(struct application *ap, struct partition *ph)
d191 3
a193 1
build_path_name_of_solid(struct bu_vls *vp, struct solid *sp)
d470 4
a473 1
rpt_hits_mike(struct application *ap, struct partition *PartHeadp, struct seg *segp)
d504 2
a505 1
rpt_miss(struct application *ap)
d529 8
a536 1
char **skewer_solids (int argc, const char **argv, fastf_t *ray_orig, fastf_t *ray_dir, int full_path)
@


1.34.2.2
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


1.33
log
@Converted from K&R to ANSI C - RFH
@
text
@d178 3
a180 1
no_op(struct application *ap, struct partition *ph)
d191 3
a193 1
build_path_name_of_solid(struct bu_vls *vp, struct solid *sp)
d470 4
a473 1
rpt_hits_mike(struct application *ap, struct partition *PartHeadp, struct seg *segp)
d504 2
a505 1
rpt_miss(struct application *ap)
d529 8
a536 1
char **skewer_solids (int argc, const char **argv, fastf_t *ray_orig, fastf_t *ray_dir, int full_path)
@


1.32
log
@Solid to Primitive naming convention conversions
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.31 2001/06/18 19:22:06 bparker Exp $ (ARL)";
d178 1
a178 3
no_op(ap, ph)
struct application	*ap;
struct partition	*ph;
d189 1
a189 3
build_path_name_of_solid(vp, sp)
struct bu_vls	*vp;
struct solid	*sp;
d466 1
a466 4
rpt_hits_mike(ap, PartHeadp, segp)
struct application	*ap;
struct partition	*PartHeadp;
struct seg		*segp;
d497 1
a497 2
rpt_miss(ap)
struct application	*ap;
d521 1
a521 8
char **skewer_solids (argc, argv, ray_orig, ray_dir, full_path)

int		argc;
const char	**argv;
point_t		ray_orig;
vect_t		ray_dir;
int		full_path;

@


1.31
log
@*- initialize magic (a_magic and a_ray.magic)
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.30 2001/04/05 19:35:45 morrison Exp $ (ARL)";
d242 1
a242 1
    if ((solids = bu_rb_create("Solid list", 2, rpt_solids_orders)) == BU_RB_TREE_NULL)
d276 1
a276 1
	printf("\n--- Solids hit on this partition ---\n");
d308 1
a308 1
	printf("Solid #%d in this partition is ", index);fflush(stdout);
@


1.30
log
@updated SIGNED to signed
updated CONST to const
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.29 2001/04/02 21:20:40 bparker Exp $ (ARL)";
d567 2
@


1.29
log
@*- remove Tk dependencies
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.28 2000/10/24 19:05:09 mike Exp $ (ARL)";
d532 1
a532 1
CONST char	**argv;
@


1.28
log
@
Fixed compiler lint, function declarations.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.27 2000/10/24 15:14:13 mike Exp $ (ARL)";
a35 1
#include "tk.h"
@


1.27
log
@
compiler lint
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.26 2000/10/20 05:04:39 mike Exp $ (ARL)";
d67 1
d168 2
d200 1
a200 1
#if 0
@


1.26
log
@
s_path array has been replaced by a s_fullpath "struct db_full_path".
This has eliminated the MAX_PATH restriction in MGED.
member s_last is gone too.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.25 2000/08/19 03:10:49 mike Exp $ (ARL)";
d197 1
d271 2
a272 2
	printf("    Partition <%lx> is '%s' ",
	    pp, pp -> pt_regionp -> reg_name);
d456 1
@


1.25
log
@
const RCSid
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.24 1999/12/30 20:13:34 jra Exp $ (ARL)";
a192 2
    int		i;

d194 1
a194 6
    for (i = 0; i < sp -> s_last; ++i)
    {
	bu_vls_strcat(vp, sp -> s_path[i] -> d_namep);
	bu_vls_strcat(vp, "/");
    }
    bu_vls_strcat(vp, sp -> s_path[sp -> s_last] -> d_namep);
@


1.24
log
@Eliminated some unused variables
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.23 1999/11/12 21:16:28 mike Exp $ (ARL)";
@


1.23
log
@
Changed from pt_solids_hit to pt_seglist; more general.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.22 1998/12/30 04:36:45 mike Exp $ (ARL)";
a233 1
    int				full_path; /* Get full path, not base? */
a234 1
    struct reg_db_internals	*dbintp;
a235 1
    struct seg			*segh;
a236 1
    struct solid		*sp;
a242 2
    full_path = ap -> a_user;

a543 1
    struct sol_name_dist	*sol;
@


1.22
log
@LibRedBlack is now part of LIBBU
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.21 1998/09/14 15:59:20 bparker Exp $ (ARL)";
d245 1
d287 1
a287 1
	for (i = 0; i < (pp -> pt_solids_hit).end; ++i)
d289 2
a290 2
	    stp = (struct soltab *) ((pp -> pt_solids_hit).buffer[i]);
	    BU_CKMAG(stp, RT_SOLTAB_MAGIC, "soltab");
d311 1
a311 1
     *	Look at each segment that participated in the ray partition(s)
d313 2
a314 4
    for (RT_LIST_FOR(segp, seg, &finished_segs->l))
    {
	int	index;

d318 4
a321 5
	/*
	 *	Check to see if the seg/solid is in this partition
	 */
	if ((index = bu_ptbl_locate(&pp -> pt_solids_hit,
			    (long *) segp -> seg_stp)) != -1)
a322 6
	    printf("Solid #%d in this partition is ", index);fflush(stdout);
	    BU_CKMAG(segp -> seg_stp, RT_SOLTAB_MAGIC, "soltab");
	    bu_vls_trunc(&sol_path_name, 0);
	    fp = &(segp -> seg_stp -> st_path);
	    if (fp -> magic != 0)
	    {
d326 3
a328 3
	    }
	    else
	    {
a332 2
	    }
	    printf("'%s'\n", bu_vls_addr(&sol_path_name));
d334 1
a334 2
	else
	    printf("No, this seg isn't in this partition\n");
@


1.21
log
@*- fix typos
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/solids_on_ray.c,v 1.20 1998/03/24 09:45:20 mike Exp $ (ARL)";
d237 1
a237 1
    rb_tree			*solids;
d251 1
a251 1
    if ((solids = rb_create("Solid list", 2, rpt_solids_orders)) == RB_TREE_NULL)
d253 1
a253 1
	bu_log("%s: %d: rb_create() bombed\n", __FILE__, __LINE__);
d257 1
a257 1
    rb_uniq_on(solids, ORDER_BY_NAME);
d354 1
a354 1
	if (rb_insert(solids, (void *) sol) < 0)
d357 1
a357 1
			rb_curr(solids, ORDER_BY_NAME);
d364 2
a365 2
		rb_delete(solids, ORDER_BY_NAME);
		rb_insert(solids, sol);
d379 1
a379 1
    for (sol = (struct sol_name_dist *) rb_min(solids, ORDER_BY_DISTANCE),
d382 1
a382 1
	 sol = (struct sol_name_dist *) rb_succ(solids, ORDER_BY_DISTANCE),
d391 1
a391 1
    rb_free(solids, RB_RETAIN_DATA);
d442 1
a442 1
	if (rb_insert(solids, (void *) sol) < 0)
d445 1
a445 1
			rb_curr(solids, ORDER_BY_NAME);
d452 2
a453 2
		rb_delete(solids, ORDER_BY_NAME);
		rb_insert(solids, sol);
d463 1
a463 1
    for (sol = (struct sol_name_dist *) rb_min(solids, ORDER_BY_DISTANCE),
d466 1
a466 1
	 sol = (struct sol_name_dist *) rb_succ(solids, ORDER_BY_DISTANCE),
d475 1
a475 1
    rb_free(solids, RB_RETAIN_DATA);
@


1.20
log
@Using a few new LIBRT flags, this version works.
No eliminating duplicates, though, such as 2 segs through a torus.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.19 1997/06/13 22:20:31 mike Exp mike $ (ARL)";
d282 1
a282 1
	printf("    Partition <%x> is '%s' ",
@


1.19
log
@Worked around IRIX 6 compiler bug.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.18 1997/02/28 21:44:01 jra Exp mike $ (ARL)";
d481 35
d524 1
a524 1
rpt_miss(ap, ph)
a525 1
struct partition	*ph;
d527 1
a527 2
    ap -> a_uptr = bu_malloc(sizeof(char *), "names of solids on ray");
    *((char **) (ap -> a_uptr)) = 0;
d563 4
a566 6
    if (argc <= 0) {
	char **ptr;
	ptr = (char **)bu_malloc(sizeof(char *), "empty solid list");
	*ptr = 0;
	return ptr;
    }
d568 10
a577 6
    {
	char			**result;
	register struct solid	*sp;
	struct bu_vls		vls;
	register int		nm_solids;
	register int		i;
d579 3
a581 44
	/*
	 *	Count the solids presently in view
	 */
	nm_solids = 0;
	FOR_ALL_SOLIDS (sp, &HeadSolid.l)
	    if (sp -> s_flag == UP)
		++nm_solids;

	/*
	 *	Now go back and record all their names
	 */
	result = (char **) bu_malloc((nm_solids + 1) * sizeof(char *),
			  "names of solids in view");
	bu_vls_init(&vls);
	i = 0;
	FOR_ALL_SOLIDS (sp, &HeadSolid.l)
	    if (sp -> s_flag == UP)
	    {
		build_path_name_of_solid(&vls, sp);
		result[i++] = bu_vls_strdup(&vls);
	    }
	result[i] = 0;
	/*
	 *	XXX	The calling routine is responsible to free
	 *		the result!
	 */
	return (result);
    }
#if 0
    if ((rtip = rt_dirbuild(dbip -> dbi_filename, (char *) 0, 0)) == RTI_NULL)
    {
      Tcl_AppendResult(interp, "Cannot build directory for file '",
		       dbip -> dbi_filename, "'\n", (char *)NULL);
      return ((char **) 0);
    }
    rtip -> useair = 1;
    /*
     *	XXX	I've hardwired in here to use a single CPU.
     *		Should that be bu_avail_cpus()?
     */
    if (rt_gettrees(rtip, argc, argv, 1) == -1) {
	return ((char **) 0);
    }
    rt_prep(rtip);
d588 1
a588 1
    ap.a_hit = rpt_solids;
d597 1
d603 3
a606 1
#endif
@


1.18
log
@removed include of db.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.17 1997/01/09 01:26:35 mike Exp jra $ (ARL)";
d217 7
a244 5
    static int			(*orders[])() =
				{
				    sol_comp_name,
				    sol_comp_dist
				};
d251 1
a251 1
    if ((solids = rb_create("Solid list", 2, orders)) == RB_TREE_NULL)
@


1.17
log
@PJT's October 10th version.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.16 1996/10/04 15:06:34 bparker Exp pjt $ (ARL)";
a39 1
#include "db.h"
@


1.16
log
@cast bu_free's 1st argument to genptr_t
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.15 1996/09/25 20:16:42 bparker Exp bparker $ (ARL)";
d51 4
d220 1
a220 1
rpt_solids(ap, ph, final_segs)
d223 1
a223 1
struct seg		*final_segs;
d230 1
d237 1
d257 19
a275 1
    printf("HELLO %s:%d\n", __FILE__, __LINE__);
d277 1
a277 1
    if (1)
d279 28
a306 2
	printf("HELLO %s:%d\n", __FILE__, __LINE__);
	bu_vls_init(&sol_path_name);
d308 6
a313 12
	/*
	 *	Get the list of segments along this ray
	 *	and seek to its head
	 */
	BU_CKMAG(ph, PT_HD_MAGIC, "partition head");
	pp = ph -> pt_forw;
	BU_CKMAG(pp, PT_MAGIC, "partition structure");
	BU_CKMAG(final_segs, RT_SEG_MAGIC, "segment structure");
	for (segh = pp -> pt_inseg;
		*((long *) segh) != BU_LIST_HEAD_MAGIC;
		segh = (struct seg *) (segh -> l.forw))
	    BU_CKMAG(segh, RT_SEG_MAGIC, "segment structure");
d315 2
a316 9
	/*
	 *	Let's see what final_segs contains...
	 */
	RT_CHECK_SEG(final_segs -> seg_stp);
	bu_vls_trunc(&sol_path_name, 0);
	fp = &(final_segs -> seg_stp -> st_path);
	bu_vls_strcpy(&sol_path_name, db_path_to_string(fp));
	printf("At line %d, sol_path_name contains '%s'\n",
		__LINE__, bu_vls_addr(&sol_path_name));
d319 1
a319 1
	 *	March down the segment list
d321 2
a322 3
	for (segp = (struct seg *) (segh -> l.forw);
		segp != segh;
		segp = (struct seg *) segp -> l.forw)
d324 2
a325 2
	    BU_CKMAG(segp, RT_SEG_MAGIC, "seg structure");
	    
d328 4
a331 3
	    printf("At line %d, sol_path_name contains '%s'\n",
		    __LINE__, bu_vls_addr(&sol_path_name));
	    if (fp -> magic)
d333 29
a361 14
	    printf("At line %d, sol_path_name contains '%s'\n",
		    __LINE__, bu_vls_addr(&sol_path_name));
	    bu_vls_strcat(&sol_path_name, segp -> seg_stp -> st_name);
	    printf("At line %d, sol_path_name contains '%s'\n",
		    __LINE__, bu_vls_addr(&sol_path_name));
	    sol = mk_solid(bu_vls_addr(&sol_path_name),
			segp -> seg_in.hit_dist);
	    printf("and segp -> seg_stp = %x\n", segp -> seg_stp);
	    /*
	     *	Attempt to record the new solid.
	     *	If it shares its name with a previously recorded solid,
	     *	then retain the one that appears earlier on the ray.
	     */
	    if (rb_insert(solids, (void *) sol) < 0)
d363 3
a365 12
		old_sol = (struct sol_name_dist *)
			    rb_curr(solids, ORDER_BY_NAME);
		BU_CKMAG(old_sol, SOL_NAME_DIST_MAGIC,
		    "sol_name_dist structure");
		if (sol -> dist >= old_sol -> dist)
		    free_solid(sol, 1);
		else
		{
		    rb_delete(solids, ORDER_BY_NAME);
		    rb_insert(solids, sol);
		    free_solid(old_sol, 1);
		}
d369 14
a382 1
    else
d384 18
a401 9
	printf("HELLO %s:%d\n", __FILE__, __LINE__);
	bu_vls_init(&sol_path_name);
	bu_log("Path names for all solids...\n");
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)
	{
	    build_path_name_of_solid (&sol_path_name, sp);
	    printf("%s\n", bu_vls_addr(&sol_path_name));
	}
	bu_log("...the end\n");
d403 9
a411 11
	/*
	 *	Get the list of segments along this ray
	 *	and seek to its head
	 */
	BU_CKMAG(ph, PT_HD_MAGIC, "partition head");
	pp = ph -> pt_forw;
	BU_CKMAG(pp, PT_MAGIC, "partition structure");
	for (segh = pp -> pt_inseg;
		*((long *) segh) != BU_LIST_HEAD_MAGIC;
		segh = (struct seg *) (segh -> l.forw))
	    BU_CKMAG(segh, RT_SEG_MAGIC, "segment structure");
d413 23
d437 3
a439 1
	 *	March down the segment list
d441 1
a441 3
	for (segp = (struct seg *) (segh -> l.forw);
		segp != segh;
		segp = (struct seg *) segp -> l.forw)
d443 7
a449 4
	    BU_CKMAG(segp, RT_SEG_MAGIC, "seg structure");
	    
	    sol = mk_solid(segp -> seg_stp -> st_name, segp -> seg_in.hit_dist);
	    if (rb_insert(solids, (void *) sol) < 0)
d451 3
a453 12
		old_sol = (struct sol_name_dist *)
			    rb_curr(solids, ORDER_BY_NAME);
		BU_CKMAG(old_sol, SOL_NAME_DIST_MAGIC,
		    "sol_name_dist structure");
		if (sol -> dist >= old_sol -> dist)
		    free_solid(sol, 1);
		else
		{
		    rb_delete(solids, ORDER_BY_NAME);
		    rb_insert(solids, sol);
		    free_solid(old_sol, 1);
		}
d476 1
d535 37
a571 1
	
d608 1
@


1.15
log
@now using more generalized solid macros
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.14 1996/09/23 18:15:59 bparker Exp bparker $ (ARL)";
d141 2
a142 2
	bu_free((char *) sol -> name, "solid name");
    bu_free((char *) sol, "solid");
@


1.14
log
@changed dm.h to mged_dm.h
.,
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.13 1996/09/23 15:01:22 bparker Exp bparker $ (ARL)";
d45 1
a45 1
#include "./solid.h"
d331 1
a331 1
	FOR_ALL_SOLIDS(sp)
@


1.13
log
@check in pjt's modifications
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.12 1996/09/03 20:02:37 bparker Exp pjt $ (ARL)";
d46 1
a46 1
#include "./dm.h"
@


1.12
log
@rt_list ---> bu_list
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.11 1996/09/03 15:58:52 bparker Exp bparker $ (ARL)";
d216 1
a216 1
rpt_solids(ap, ph)
d219 1
d265 1
d270 10
@


1.11
log
@check in Lee's changes
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.10 1996/08/27 20:30:05 bparker Exp butler $ (ARL)";
d31 1
a33 1
#include <stdio.h>
d38 1
a39 1
#include "bu.h"
a40 2
#include "rtstring.h"
#include "rtlist.h"
d265 1
a265 1
		*((long *) segh) != RT_LIST_HEAD_MAGIC;
d334 1
a334 1
		*((long *) segh) != RT_LIST_HEAD_MAGIC;
d433 1
a433 1
    struct rt_list	sol_list;
d459 1
a459 1
    RT_LIST_INIT(&sol_list);
@


1.10
log
@now using libbu
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.9 1996/04/18 20:25:25 bparker Exp bparker $ (ARL)";
d39 1
@


1.9
log
@convert commands to Tcl
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.8 1995/08/10 21:11:19 gdurf Exp bparker $ (ARL)";
d77 2
a78 2
    RT_CKMAG(s1, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");
    RT_CKMAG(s2, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");
d95 2
a96 2
    RT_CKMAG(s1, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");
    RT_CKMAG(s2, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");
d117 1
a117 1
	    rt_malloc(sizeof(struct sol_name_dist), "solid");
d120 1
a120 1
	    rt_malloc(strlen(name) + 1, "solid name");
d139 1
a139 1
    RT_CKMAG(sol, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");
d142 2
a143 2
	rt_free((char *) sol -> name, "solid name");
    rt_free((char *) sol, "solid");
d155 1
a155 1
    struct rt_vls tmp_vls;
d157 1
a157 1
    RT_CKMAG(sol, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");
d159 2
a160 2
    rt_vls_init(&tmp_vls);
    rt_vls_printf(&tmp_vls, "solid %s at distance %g along ray\n",
d162 2
a163 2
    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
    rt_vls_free(&tmp_vls);
d188 1
a188 1
struct rt_vls	*vp;
d193 1
a193 1
    rt_vls_trunc(vp, 0);
d196 2
a197 2
	rt_vls_strcat(vp, sp -> s_path[i] -> d_namep);
	rt_vls_strcat(vp, "/");
d199 1
a199 1
    rt_vls_strcat(vp, sp -> s_path[sp -> s_last] -> d_namep);
d232 1
a232 1
    struct rt_vls		sol_path_name;
d246 1
a246 1
	rt_log("%s: %d: rb_create() bombed\n", __FILE__, __LINE__);
d256 1
a256 1
	rt_vls_init(&sol_path_name);
d262 1
a262 1
	RT_CKMAG(ph, PT_HD_MAGIC, "partition head");
d264 1
a264 1
	RT_CKMAG(pp, PT_MAGIC, "partition structure");
d268 1
a268 1
	    RT_CKMAG(segh, RT_SEG_MAGIC, "segment structure");
d277 1
a277 1
	    RT_CKMAG(segp, RT_SEG_MAGIC, "seg structure");
d279 1
a279 1
	    rt_vls_trunc(&sol_path_name, 0);
d282 1
a282 1
		    __LINE__, rt_vls_addr(&sol_path_name));
d284 1
a284 1
		rt_vls_strcpy(&sol_path_name, db_path_to_string(fp));
d286 2
a287 2
		    __LINE__, rt_vls_addr(&sol_path_name));
	    rt_vls_strcat(&sol_path_name, segp -> seg_stp -> st_name);
d289 2
a290 2
		    __LINE__, rt_vls_addr(&sol_path_name));
	    sol = mk_solid(rt_vls_addr(&sol_path_name),
d302 1
a302 1
		RT_CKMAG(old_sol, SOL_NAME_DIST_MAGIC,
d318 2
a319 2
	rt_vls_init(&sol_path_name);
	rt_log("Path names for all solids...\n");
d323 1
a323 1
	    printf("%s\n", rt_vls_addr(&sol_path_name));
d325 1
a325 1
	rt_log("...the end\n");
d331 1
a331 1
	RT_CKMAG(ph, PT_HD_MAGIC, "partition head");
d333 1
a333 1
	RT_CKMAG(pp, PT_MAGIC, "partition structure");
d337 1
a337 1
	    RT_CKMAG(segh, RT_SEG_MAGIC, "segment structure");
d346 1
a346 1
	    RT_CKMAG(segp, RT_SEG_MAGIC, "seg structure");
d353 1
a353 1
		RT_CKMAG(old_sol, SOL_NAME_DIST_MAGIC,
d369 1
a369 1
		rt_malloc((solids -> rbt_nm_nodes + 1) * sizeof(char *),
d400 1
a400 1
    ap -> a_uptr = rt_malloc(sizeof(char *), "names of solids on ray");
d439 1
a439 1
	ptr = (char **)rt_malloc(sizeof(char *), "empty solid list");
d453 1
a453 1
     *		Should that be rt_avail_cpus()?
@


1.8
log
@Prototypes
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.7 1995/08/08 20:28:25 gdurf Exp gdurf $ (ARL)";
a152 1

d155 1
d158 6
a163 2
    rt_log("solid %s at distance %g along ray\n",
	sol -> name, sol -> dist);
d446 3
a448 3
	rt_log("Cannot build directory for file '%s'\n",
	    dbip -> dbi_filename);
	return ((char **) 0);
@


1.7
log
@Changes by PJT
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.6 1995/07/25 17:54:21 gdurf Exp $ (ARL)";
d70 3
a72 1
static int sol_comp_name (void *v1, void *v2)
d88 3
a90 1
static int sol_comp_dist (void *v1, void *v2)
d109 2
a110 2
static struct sol_name_dist *mk_solid (name, dist)

a112 1

d133 2
a134 2
static void free_solid (sol, free_name)

d149 2
a150 2
static void print_solid (vp, depth)

d169 2
a170 2
static int no_op (ap, ph)

a172 1

d182 2
a183 2
void build_path_name_of_solid (vp, sp)

a185 1

d212 2
a213 2
static int rpt_solids (ap, ph)

a215 1

d391 2
a392 2
static int rpt_miss (ap, ph)

a394 1

@


1.6
log
@allowed empty argument list
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.5 1995/07/20 17:09:05 pjt Exp gdurf $ (ARL)";
d116 3
a118 1
    sp -> name = name;
d125 4
d130 1
a130 1
static void free_solid (sol)
d133 1
d138 2
d155 2
a156 1
    rt_log("solid %s at distance %g along ray\n", sol -> name, sol -> dist);
d218 1
d220 1
a220 1
    int				full_path; /* Get full path, not just base? */
d228 1
a228 1
    struct rt_vls		v;
d252 14
d267 1
a267 1
	 *	March down the partition list
d269 3
a271 1
	for (pp = ph -> pt_forw; pp != ph; pp = pp -> pt_forw)
d273 21
a293 1
	    sol = mk_solid(pp -> pt_regionp -> reg_name, (fastf_t) 3.0);
d301 1
a301 1
		    free_solid(sol);
d306 1
a306 1
		    free_solid(old_sol);
d314 1
a314 1
	rt_vls_init(&v);
d318 2
a319 2
	    build_path_name_of_solid (&v, sp);
	    printf("%s\n", rt_vls_addr(&v));
d352 1
a352 1
		    free_solid(sol);
d357 1
a357 1
		    free_solid(old_sol);
d367 2
a368 1
    for (sol = (struct sol_name_dist *) rb_min(solids, ORDER_BY_DISTANCE), i=0;
d370 2
a371 1
	 sol = (struct sol_name_dist *) rb_succ(solids, ORDER_BY_DISTANCE), ++i)
d374 1
a374 1
	free_solid(sol);
@


1.5
log
@exploratory efforts aimed at handling
multiply referenced solids
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.4 1995/07/12 16:53:34 pjt Exp pjt $ (ARL)";
d384 7
d403 1
a403 1
    if (rt_gettrees(rtip, argc, argv, 1) == -1)
d405 1
@


1.4
log
@First version of cmd_solids_on_ray now works...
Yet to handle multiply referenced solids, though
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.3 1995/07/11 19:20:01 pjt Exp pjt $ (ARL)";
d166 22
d196 3
a198 1
 *	of the sorted solid names.  It returns 1.
d209 1
d212 3
a214 2
    struct seg			*sh;
    struct seg			*sp;
d217 1
d224 2
d236 1
d238 37
a274 11
    /*
     *	Get the list of segments along this ray
     *	and seek to its head
     */
    RT_CKMAG(ph, PT_HD_MAGIC, "partition head");
    pp = ph -> pt_forw;
    RT_CKMAG(pp, PT_MAGIC, "partition structure");
    for (sh = pp -> pt_inseg;
	    *((long *) sh) != RT_LIST_HEAD_MAGIC;
	    sh = (struct seg *) (sh -> l.forw))
	RT_CKMAG(sh, RT_SEG_MAGIC, "segment structure");
d276 18
a293 11
    /*
     *	March down the list of segments
     */
    for (sp = (struct seg *) (sh -> l.forw);
	    sp != sh;
	    sp = (struct seg *) sp -> l.forw)
    {
	RT_CKMAG(sp, RT_SEG_MAGIC, "seg structure");
	
	sol = mk_solid(sp -> seg_stp -> st_name, sp -> seg_in.hit_dist);
	if (rb_insert(solids, (void *) sol) < 0)
d295 4
a298 5
	    old_sol = (struct sol_name_dist *) rb_curr(solids, ORDER_BY_NAME);
	    RT_CKMAG(old_sol, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");
	    if (sol -> dist >= old_sol -> dist)
		free_solid(sol);
	    else
d300 12
a311 3
		rb_delete(solids, ORDER_BY_NAME);
		rb_insert(solids, sol);
		free_solid(old_sol);
d315 1
d355 1
a355 1
 *		S K E W E R _ S O L I D S
d360 7
a366 5
 *	The function has four parameters: the model and objects
 *	at which to fire (in an argc/argv pair) and the origination
 *	point and direction for the ray.  So long as it could find
 *	the objects in the model, skewer_solids() returns a
 *	null-terminated array of solid names.  Otherwise, it returns 0.
d371 1
a371 1
char **skewer_solids (argc, argv, ray_orig, ray_dir)
d377 1
d410 1
a410 1
    ap.a_uptr = (genptr_t) &sol_list;
@


1.3
log
@ 1. Implemented librt(3) miss handler, rpt_miss().
 2. Before it returns, rpt_solids() now frees (rb_tree *solids).
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.2 1995/07/10 20:10:51 pjt Exp pjt $ (ARL)";
a117 1
    rt_log("Created solid (%s, %g)\n", sp -> name, sp -> dist);
a130 1
    rt_log("freeing solid (%s, %g)...\n", sol -> name, sol -> dist);
a196 1
    rt_log("I hit it!\n");
a227 3
	rt_log("I saw solid %s at distance %g\n",
	    sp -> seg_stp -> st_name,
	    sp -> seg_in.hit_dist);
a243 2
    rt_log("\n- - - Solids along the ray - - -\n");
    rb_walk(solids, ORDER_BY_DISTANCE, print_solid, INORDER);
a252 1
	rt_log("before free_solid(%x)... '%s'\n", sol, result[i]);
a253 1
	rt_log("after free_solid(%x)... '%s'\n", sol, result[i]);
a275 1
    rt_log("I missed!\n");
@


1.2
log
@COB 10 July
@
text
@d7 1
a7 1
 *	cmd_solids_on_ray	trace a single ray from current view
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/solids_on_ray.c,v 1.1 1995/07/10 14:52:17 pjt Exp pjt $ (ARL)";
a150 1

d175 2
a176 2
 *	fills the rt_list structure pointed to by ap->a_uptr with
 *	the names of the solids.  It returns 1.
d254 1
a254 1
		rt_malloc(solids -> rbt_nm_nodes * sizeof(char *),
d261 1
d263 1
d265 4
a268 1
    ap -> a_uptr = result;
d273 21
d296 1
a296 1
 *	Fire a ray at some geometry and return a list of
d299 8
a306 1
 *	N.B. - It is the caller's responsibility to free the list.
d342 1
a342 1
    ap.a_miss = no_op;
@


1.1
log
@Initial revision
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d41 1
d176 1
a176 1
 *	fills the rt_list structure pointed to by ap.a_uptr with
d186 2
d189 1
a191 1
    rb_tree			*solids;
d253 12
d276 1
a276 1
struct rt_list *skewer_solids (argc, argv, ray_orig, ray_dir)
d286 2
a287 1
    struct rt_list	*sol_list;
d293 1
a293 1
	return ((struct rt_list *) 0);
d301 1
a301 1
	return ((struct rt_list *) 0);
d304 1
a304 6
    /*
     *	Allocate and initialize the solid list
     */
    sol_list = (struct rt_list *)
		    rt_malloc(sizeof(struct rt_list), "solid list");
    RT_LIST_INIT(sol_list);
d314 1
a314 1
    ap.a_uptr = (genptr_t) sol_list;
d322 2
a323 1
    return (sol_list);
@
