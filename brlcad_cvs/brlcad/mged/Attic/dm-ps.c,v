head	11.31;
access;
symbols
	ansi-20040405-merged:11.27.2.2
	postmerge-20040405-ansi:11.29
	premerge-20040404-ansi:11.28
	postmerge-autoconf:11.28
	autoconf-freeze:11.27.10.1
	premerge-autoconf:11.28
	postmerge-20040315-windows:11.28
	premerge-20040315-windows:11.27
	windows-20040315-freeze:11.27.4.1
	autoconf-20031203:11.27
	autoconf-20031202:11.27
	autoconf-branch:11.27.0.10
	phong-branch:11.27.0.8
	photonmap-branch:11.27.0.6
	rel-6-1-DP:11.27
	windows-branch:11.27.0.4
	rel-6-0-2:11.25
	ansi-branch:11.27.0.2
	rel-6-0-1-branch:11.25.0.2
	hartley-6-0-post:11.26
	hartley-6-0-pre:11.25
	rel-6-0-1:11.25
	rel-6-0:11.25
	rel-5-4:11.23.2.1
	offsite-5-3-pre:11.25
	rel-5-3:11.23.2.1
	rel-5-2:11.23.2.1
	rel-5-1-branch:11.23.0.2
	rel-5-1:11.23
	rel-5-0:11.22
	rel-5-0-beta:11.22
	rel-4-5:11.20
	ctj-4-5-post:11.17
	ctj-4-5-pre:11.17
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.31
date	2004.05.21.17.47.40;	author morrison;	state dead;
branches;
next	11.30;

11.30
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.29;

11.29
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2004.03.16.21.15.11;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2002.08.20.17.08.22;	author jra;	state Exp;
branches
	11.27.2.1
	11.27.4.1
	11.27.10.1;
next	11.26;

11.26
date	2002.08.15.20.55.33;	author hartley;	state Exp;
branches;
next	11.25;

11.25
date	2000.08.31.18.13.02;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	2000.08.19.03.10.44;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	99.12.01.14.06.35;	author bparker;	state Exp;
branches
	11.23.2.1;
next	11.22;

11.22
date	98.11.06.22.32.39;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	98.02.26.15.56.35;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	98.01.16.22.08.18;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	97.12.23.14.26.50;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	97.10.10.17.01.50;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	97.05.21.12.47.01;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	97.05.08.14.33.16;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	97.04.23.18.31.27;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	97.02.24.22.05.25;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	97.01.29.23.13.32;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.12.04.21.15.47;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.09.25.20.05.53;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.09.23.18.41.43;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.09.17.21.21.19;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	96.03.01.19.31.51;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.32;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.56;	author mike;	state Rel4_4;
branches;
next	10.9;

10.9
date	94.12.24.01.05.21;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.12.23.22.55.12;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.12.16.19.36.10;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.10.14.17.07.00;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.10.14.16.06.29;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.10.21.42.52;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.09.15.14.34;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.06.01.11.58.57;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.26;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.07.19.01.16.51;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	91.02.02.00.00.58;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	91.01.12.08.25.33;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.02.29;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.04.06.20.39.24;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.06.46;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.36.22;	author mike;	state Rel3_0;
branches;
next	1.4;

1.4
date	88.09.17.08.28.27;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	88.09.15.21.03.22;	author phil;	state Exp;
branches;
next	1.2;

1.2
date	88.09.06.05.21.28;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.09.02.15.23.52;	author mike;	state Exp;
branches;
next	;

11.23.2.1
date	2000.09.01.17.31.46;	author bparker;	state Exp;
branches;
next	;

11.27.2.1
date	2002.09.19.18.02.01;	author morrison;	state Exp;
branches;
next	11.27.2.2;

11.27.2.2
date	2004.03.17.21.21.57;	author morrison;	state Exp;
branches;
next	;

11.27.4.1
date	2002.09.26.23.04.10;	author morrison;	state Exp;
branches;
next	;

11.27.10.1
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@Display Manager to output PostScript
@


11.31
log
@moved to src/mged/
@
text
@/*
 *			D M - P S . C
 *
 *  Routines specific to MGED's use of LIBDM's Postscript display manager.
 *
 *  Author -
 *	Robert G. Parker
 *  
 *  Source -
 *	SLAD CAD Team
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/dm-ps.c,v 11.30 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifndef WIN32
#include <sys/time.h>		/* for struct timeval */
#endif
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "./ged.h"
#include "./mged_dm.h"
#include "dm-ps.h"

extern void dm_var_init(struct dm_list *initial_dm_list);

int
PS_dm_init(struct dm_list *o_dm_list, int argc, char **argv)
{
  dm_var_init(o_dm_list);

  if ((dmp = dm_open(interp, DM_TYPE_PS, argc, argv)) == DM_NULL)
    return TCL_ERROR;

  return TCL_OK;
}
@


11.30
log
@change conf.h to a wrapped config.h
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/dm-ps.c,v 11.29 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.29
log
@merge of ansi-6-0-branch into HEAD
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d19 5
a23 1
#include "conf.h"
@


11.28
log
@merge of windows-6-0-branch into head
@
text
@d35 1
a35 1
extern void dm_var_init();
d38 1
a38 4
PS_dm_init(o_dm_list, argc, argv)
struct dm_list *o_dm_list;
int argc;
char *argv[];
@


11.27
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-ps.c,v 11.25 2000/08/31 18:13:02 bparker Exp $ (BRL)";
d22 1
d24 1
@


11.27.10.1
log
@merge from head
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a21 1
#ifndef WIN32
a22 1
#endif
@


11.27.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-ps.c,v 11.27 2002/08/20 17:08:22 jra Exp $ (BRL)";
a21 1
#ifndef WIN32
a22 1
#endif
@


11.27.2.1
log
@Initial ANSIfication
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-ps.c,v 11.27 2002/08/20 17:08:22 jra Exp $ (BRL)";
d33 1
a33 1
extern void dm_var_init(struct dm_list *initial_dm_list);
d36 4
a39 1
PS_dm_init(struct dm_list *o_dm_list, int argc, char **argv)
@


11.27.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a21 1
#ifndef WIN32
a22 1
#endif
@


11.26
log
@Converted from K&R to ANSI C - RFH
@
text
@d33 1
a33 1
extern void dm_var_init(struct dm_list *initial_dm_list);
d36 4
a39 1
PS_dm_init(struct dm_list *o_dm_list, int argc, char **argv)
@


11.25
log
@signature for dm_open() changed to include interp
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-ps.c,v 11.24 2000/08/19 03:10:44 mike Exp $ (BRL)";
d33 1
a33 1
extern void dm_var_init();
d36 1
a36 4
PS_dm_init(o_dm_list, argc, argv)
struct dm_list *o_dm_list;
int argc;
char *argv[];
@


11.24
log
@
const RCSid
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-ps.c,v 11.23 1999/12/01 14:06:35 bparker Exp $ (BRL)";
d43 1
a43 1
  if((dmp = dm_open(DM_TYPE_PS, argc, argv)) == DM_NULL)
@


11.23
log
@*- mods to reflect changes in struct dm
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-ps.c,v 11.22 1998/11/06 22:32:39 bparker Exp $ (BRL)";
@


11.23.2.1
log
@dm_open has new signature (i.e. interp)
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-ps.c,v 11.25 2000/08/31 18:13:02 bparker Exp $ (BRL)";
d43 1
a43 1
  if ((dmp = dm_open(interp, DM_TYPE_PS, argc, argv)) == DM_NULL)
@


11.22
log
@*- use new structures
*- cleanup
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-ps.c,v 11.21 1998/02/26 15:56:35 bparker Exp $ (BRL)";
a45 1
  zclip_ptr = &((struct ps_vars *)dmp->dm_vars.priv_vars)->zclip;
@


11.21
log
@*- using new dm_vars structure
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.20 1998/01/16 22:08:18 bparker Exp bparker $ (BRL)";
a46 1
  curr_dm_list->s_info->opp = &pathName;
@


11.20
log
@*** empty log message ***
@
text
@d4 1
a4 5
 * A useful hack to allow GED to generate
 * PostScript files that not only contain the drawn objects, but
 * also contain the faceplate display as well.
 * Mostly, used for making viewgraphs and photographs
 * of an editing session.
d7 1
a7 1
 *	Michael John Muuss
d10 2
a11 2
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
a12 4
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
d14 1
d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.19 1997/12/23 14:26:50 bparker Exp bparker $ (BRL)";
d46 1
a46 1
  zclip_ptr = &((struct ps_vars *)dmp->dm_vars)->zclip;
@


11.19
log
@*** empty log message ***
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.18 1997/10/10 17:01:50 bparker Exp bparker $ (BRL)";
a37 1
#include "./mged_solid.h"
@


11.18
log
@call dm_open without eventHandler
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.17 1997/05/21 12:47:01 bparker Exp bparker $ (BRL)";
d54 1
@


11.17
log
@mods to PS_dm_init
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.16 1997/05/08 14:33:16 bparker Exp bparker $ (BRL)";
d51 1
a51 1
  if((dmp = dm_open(DM_TYPE_PS, DM_EVENT_HANDLER_NULL, argc, argv)) == DM_NULL)
@


11.16
log
@call generic dm_open
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.15 1997/04/23 18:31:27 bparker Exp bparker $ (BRL)";
d54 1
a54 1
  curr_dm_list->s_info->opp = &tkName;
@


11.15
log
@*** empty log message ***
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.14 1997/02/24 22:05:25 bparker Exp bparker $ (BRL)";
d51 1
a51 1
  if((dmp = PS_open(DM_EVENT_HANDLER_NULL, argc - 1, argv + 1)) == DM_NULL)
@


11.14
log
@*** empty log message ***
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.13 1997/01/29 23:13:32 bparker Exp bparker $ (BRL)";
a48 1
#if DO_NEW_LIBDM_OPEN
a55 3
#else
  return PS_open((int (*)())NULL, argc, argv);
#endif
@


11.13
log
@experiment with libdm
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.12 1996/12/04 21:15:47 bparker Exp bparker $ (BRL)";
d41 1
a41 1
struct dm *PS_dm_init();
d43 3
a45 2
struct dm *
PS_dm_init(argc, argv)
d49 9
d59 1
@


11.12
log
@no longer using dm_init
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.11 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
a35 1
#include "dm-ps.h"
d39 1
d41 1
a41 1
int PS_dm_init();
d43 4
a46 2
int
PS_dm_init()
d48 1
a48 1
  return TCL_OK;
@


11.11
log
@hacks to use latest libdm
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.10 1996/09/25 20:05:53 bparker Exp $ (BRL)";
d44 1
a44 3
PS_dm_init(argc, argv)
int argc;
char *argv[];
d46 1
a46 4
  if(dmp->dm_init(dmp, argc, argv) == TCL_ERROR)
    return TCL_ERROR;

  return dmp->dm_open(dmp);
@


11.10
log
@include mged_solid.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.9 1996/09/23 18:41:43 bparker Exp bparker $ (BRL)";
d48 1
a48 1
  if(dmp->dmr_init(dmp, argc, argv) == TCL_ERROR)
d51 1
a51 1
  return dmp->dmr_open(dmp);
@


11.9
log
@use LIBDM permanently
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.8 1996/09/17 21:21:19 bparker Exp bparker $ (BRL)";
d39 1
a39 1
#include "./solid.h"
a40 1
extern color_soltab();
d48 1
a48 1
  if(dmp->dmr_init(dmp, color_soltab, argc, argv) == TCL_ERROR)
@


11.8
log
@prepare to use libdm
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.7 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d36 1
d38 1
a38 1
#include "./dm.h"
a40 3
#ifdef USE_LIBDM
#include "dm-ps.h"

d45 3
a47 1
PS_dm_init()
d49 1
a49 1
  if(dmp->dmr_init(dmp, color_soltab) == TCL_ERROR)
a53 465
#else
/* Display Manager package interface */

#define PLOTBOUND	1000.0	/* Max magnification in Rot matrix */
int	PS_init();
int	PS_open();
void	PS_close();
MGED_EXTERN(void	PS_input, (fd_set *input, int noblock) );
void	PS_prolog(), PS_epilog();
void	PS_normal(), PS_newrot();
void	PS_update();
void	PS_puts(), PS_2d_line(), PS_light();
int	PS_object();
unsigned PS_cvtvecs(), PS_load();
void	PS_statechange(), PS_viewchange(), PS_colorchange();
void	PS_window(), PS_debug();
int     PS_dm();

struct dm dm_PS = {
  PS_init,
  PS_open, PS_close,
  PS_input,
  PS_prolog, PS_epilog,
  PS_normal, PS_newrot,
  PS_update,
  PS_puts, PS_2d_line,
  PS_light,
  PS_object,
  PS_cvtvecs, PS_load,
  PS_statechange,
  PS_viewchange,
  PS_colorchange,
  PS_window, PS_debug, PS_dm, 0,
  0,				/* no displaylist */
  0,				/* no display to release! */
  PLOTBOUND,
  "ps", "Screen to PostScript",
  0,
  0,
  0,
  0
};

extern struct device_values dm_values;	/* values read from devices */

static vect_t	clipmin, clipmax;	/* for vector clipping */
FILE	*ps_fp;			/* PostScript file pointer */
static char	ttybuf[BUFSIZ];
#if 0
static int	in_middle;		/* !0 when in middle of image */
#endif

/*
 * Display coordinate conversion:
 *  GED is using -2048..+2047,
 *  and we define the PLOT file to use 0..4095
 */
#define	GED_TO_PS(x)	((int)((x)+2048))

PS_init()
{
  return TCL_OK;
}

/*
 *			P S _ O P E N
 *
 * Open the output file, and output the PostScript prolog.
 *
 */
PS_open()
{
	char line[64];

	if( (ps_fp = fopen( dname, "w" )) == NULL ){
	  Tcl_AppendResult(interp, "f_ps: Error opening file - ", dname,
			   "\n", (char *)NULL);
	  return TCL_ERROR;
	}

	setbuf( ps_fp, ttybuf );
	fputs( "%!PS-Adobe-1.0\n\
%begin(plot)\n\
%%DocumentFonts:  Courier\n", ps_fp );
	fprintf(ps_fp, "%%%%Title: %s\n", line );
	fputs( "\
%%Creator: MGED dm-ps.c\n\
%%BoundingBox: 0 0 324 324	% 4.5in square, for TeX\n\
%%EndComments\n\
\n", ps_fp );

	fputs( "\
4 setlinewidth\n\
\n\
% Sizes, made functions to avoid scaling if not needed\n\
/FntH /Courier findfont 80 scalefont def\n\
/DFntL { /FntL /Courier findfont 73.4 scalefont def } def\n\
/DFntM { /FntM /Courier findfont 50.2 scalefont def } def\n\
/DFntS { /FntS /Courier findfont 44 scalefont def } def\n\
\n\
% line styles\n\
/NV { [] 0 setdash } def	% normal vectors\n\
/DV { [8] 0 setdash } def	% dotted vectors\n\
/DDV { [8 8 32 8] 0 setdash } def	% dot-dash vectors\n\
/SDV { [32 8] 0 setdash } def	% short-dash vectors\n\
/LDV { [64 8] 0 setdash } def	% long-dash vectors\n\
\n\
/NEWPG {\n\
	.0791 .0791 scale	% 0-4096 to 324 units (4.5 inches)\n\
} def\n\
\n\
FntH  setfont\n\
NEWPG\n\
", ps_fp);

#if 0
	in_middle = 0;
#endif

	return(0);			/* OK */
}

/*
 *  			P S _ C L O S E
 *  
 *  Gracefully release the display.
 */
void
PS_close()
{
  if( !ps_fp )  return;

  fputs("%end(plot)\n", ps_fp);
  (void)fclose(ps_fp);
  ps_fp = (FILE *)NULL;
}

/*
 *			P S _ P R O L O G
 *
 * There are global variables which are parameters to this routine.
 */
void
PS_prolog()
{
#if 0
  /* We expect the screen to be blank so far */
  if( in_middle )  {
    /*
     *  Force the release of this Display Manager
     *  This assures only one frame goes into the file.
     */

    release(NULL);
    return;
  }

  in_middle = 1;
#endif

  /* Put the center point up */
  PS_2d_line( 0, 0, 1, 1, 0 );
}

/*
 *			P S _ E P I L O G
 */
void
PS_epilog()
{
  if( !ps_fp )  return;

  fputs("% showpage	% uncomment to use raw file\n", ps_fp);
  (void)fflush( ps_fp );
  return;
}

/*
 *  			P S _ N E W R O T
 *  Stub.
 */
/* ARGSUSED */
void
PS_newrot(mat)
mat_t mat;
{
	return;
}

/*
 *  			P S _ O B J E C T
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.
 *
 *  Returns 0 if object could be drawn, !0 if object was omitted.
 */
/* ARGSUSED */
int
PS_object( sp, mat, ratio, white )
register struct solid *sp;
mat_t mat;
double ratio;
int white;
{
	static vect_t			last;
	register struct rt_vlist	*vp;
	int useful = 0;

	if( !ps_fp )  return(0);

	if( sp->s_soldash )
		fprintf(ps_fp, "DDV ");		/* Dot-dashed vectors */
	else
		fprintf(ps_fp, "NV ");		/* Normal vectors */

	for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			static vect_t	start, fin;
			switch( *cmd )  {
			case RT_VLIST_POLY_START:
			case RT_VLIST_POLY_VERTNORM:
				continue;
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_LINE_MOVE:
				/* Move, not draw */
				MAT4X3PNT( last, model2view, *pt );
				continue;
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
			case RT_VLIST_LINE_DRAW:
				/* draw */
				MAT4X3PNT( fin, model2view, *pt );
				VMOVE( start, last );
				VMOVE( last, fin );
				break;
			}

			if(
				vclip( start, fin, clipmin, clipmax ) == 0
			)  continue;

			fprintf(ps_fp,"newpath %d %d moveto %d %d lineto stroke\n",
				GED_TO_PS( start[0] * 2047 ),
				GED_TO_PS( start[1] * 2047 ),
				GED_TO_PS( fin[0] * 2047 ),
				GED_TO_PS( fin[1] * 2047 ) );
			useful = 1;
		}
	}
	return(useful);
}

/*
 *			P S _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
void
PS_normal()
{
	return;
}

/*
 *			P S _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 */
void
PS_update()
{
	if( !ps_fp )  return;

	(void)fflush(ps_fp);
}

/*
 *			P S _ P U T S
 *
 * Output a string into the displaylist.
 * The starting position of the beam is as specified.
 */
/* ARGSUSED */
void
PS_puts( str, x, y, size, color )
register char *str;
{
	if( !ps_fp )  return;

	switch( size )  {
	default:
		/* Smallest */
		fprintf(ps_fp,"DFntS ");
		break;
	case 1:
		fprintf(ps_fp,"DFntM ");
		break;
	case 2:
		fprintf(ps_fp,"DFntL ");
		break;
	case 3:
		/* Largest */
		fprintf(ps_fp,"FntH ");
		break;
	}

	fprintf(ps_fp, "(%s) %d %d moveto show\n",
		str, GED_TO_PS(x), GED_TO_PS(y) );
}

/*
 *			P S _ 2 D _ G O T O
 *
 */
void
PS_2d_line( x1, y1, x2, y2, dashed )
int x1, y1;
int x2, y2;
int dashed;
{

	if( !ps_fp )  return;

	if( dashed )
		fprintf(ps_fp, "DDV ");	/* Dot-dashed vectors */
	else
		fprintf(ps_fp, "NV ");		/* Normal vectors */
	fprintf(ps_fp,"newpath %d %d moveto %d %d lineto stroke\n",
		GED_TO_PS(x1), GED_TO_PS(y1),
		GED_TO_PS(x2), GED_TO_PS(y2) );
}

/*
 *			P S _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream,
 * unless "noblock" is set.
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 */
void
PS_input( input, noblock )
fd_set		*input;
int		noblock;
{
	struct timeval	tv;
	int		width;
	int		cnt;

#if defined(_SC_OPEN_MAX)
	if( (width = sysconf(_SC_OPEN_MAX)) <= 0 )
#endif
		width = 32;

	/*
	 * Check for input on the keyboard only.
	 *
	 * Suspend execution until either
	 *  1)  User types a full line
	 *  2)  The timelimit on SELECT has expired
	 *
	 * If a RATE operation is in progress (zoom, rotate, slew)
	 * in which we still have to update the display,
	 * do not suspend execution.
	 */
	tv.tv_sec = 0;
	if( noblock )  {
		tv.tv_usec = 0;
	}  else  {
		/* 1/20th second */
		tv.tv_usec = 50000;
	}
	cnt = select( width, input, (fd_set *)0,  (fd_set *)0, &tv );
	if( cnt < 0 )  {
		perror("dm/select");
	}
}

/* 
 *			P S _ L I G H T
 */
/* ARGSUSED */
void
PS_light( cmd, func )
int cmd;
int func;			/* BE_ or BV_ function */
{
	return;
}

/* ARGSUSED */
unsigned
PS_cvtvecs( sp )
struct solid *sp;
{
	return( 0 );
}

/*
 * Loads displaylist
 */
unsigned
PS_load( addr, count )
unsigned addr, count;
{
#if 0
	bu_log("PS_load(x%x, %d.)\n", addr, count );
#endif
	return( 0 );
}

void
PS_statechange()
{
}

void
PS_viewchange()
{
}

void
PS_colorchange()
{
	color_soltab();		/* apply colors to the solid table */
}

/* ARGSUSED */
void
PS_debug(lvl)
{
}

void
PS_window(w)
register int w[];
{
	/* Compute the clipping bounds */
	clipmin[0] = w[1] / 2048.;
	clipmin[1] = w[3] / 2048.;
	clipmin[2] = w[5] / 2048.;
	clipmax[0] = w[0] / 2047.;
	clipmax[1] = w[2] / 2047.;
	clipmax[2] = w[4] / 2047.;
}

int
PS_dm(argc, argv)
int argc;
char *argv[];
{
  return TCL_OK;
}
#endif
@


11.7
log
@rt_list ---> bu_list
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.6 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d40 15
d58 1
d70 1
d73 22
a94 17
	PS_open, PS_close,
	PS_input,
	PS_prolog, PS_epilog,
	PS_normal, PS_newrot,
	PS_update,
	PS_puts, PS_2d_line,
	PS_light,
	PS_object,
	PS_cvtvecs, PS_load,
	PS_statechange,
	PS_viewchange,
	PS_colorchange,
	PS_window, PS_debug,
	0,				/* no displaylist */
	0,				/* no display to release! */
	PLOTBOUND,
	"ps", "Screen to PostScript"
d113 5
d510 9
@


11.6
log
@now using libbu
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.5 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d32 1
d244 1
a244 1
	for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
@


11.5
log
@Still Tcl'ing the code
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.4 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d443 1
a443 1
	rt_log("PS_load(x%x, %d.)\n", addr, count );
@


11.4
log
@still tcl-converting
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.3 1996/03/01 19:31:51 bparker Exp bparker $ (BRL)";
d79 1
d81 1
d99 1
a99 14
#if 0
	rt_log("PostScript file? ");
	(void)fgets( line, sizeof(line), stdin ); /* \n, null terminated */
	line[strlen(line)-1] = '\0';		/* remove newline */
	if( feof(stdin) )  quit();
	if( line[0] != '\0' )  {
		if( (ps_fp = fopen( line, "w" )) == NULL )  {
			perror(line);
			return(1);		/* BAD */
		}
	} else {
		return(1);		/* BAD */
	}
#else
a104 1
#endif
d141 1
d143 1
d156 1
a156 2

	if( !ps_fp )  return;
d158 3
a160 6
	fputs("%end(plot)\n", ps_fp);
	(void)fclose(ps_fp);
	ps_fp = (FILE *)NULL;
#if 0
	rt_log("PS_close()\n");
#endif
d172 10
a181 3
	if( !dmaflag )
		return;
#endif
d183 1
a183 10
	/* We expect the screen to be blank so far */
	if( in_middle )  {
		/*
		 *  Force the release of this Display Manager
		 *  This assures only one frame goes into the file.
		 */
#ifdef MULTI_ATTACH
	  release(NULL);
#else
		release();
a184 3
		return;
	}
	in_middle = 1;
d186 2
a187 2
	/* Put the center point up */
	PS_2d_line( 0, 0, 1, 1, 0 );
d196 1
a196 1
	if( !ps_fp )  return;
d198 3
a200 3
	fputs("% showpage	% uncomment to use raw file\n", ps_fp);
	(void)fflush( ps_fp );
	return;
@


11.3
log
@remove unused XMGED stuff
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 11.2 1995/01/17 13:04:32 bparker Exp bparker $ (BRL)";
a76 1
#if 0
a77 4
char	ps_ttybuf[BUFSIZ];
int	in_middle;		/* !0 when in middle of image */
#else
static FILE	*ps_fp;			/* PostScript file pointer */
a79 1
#endif
d97 1
a97 1

a109 3

#if 0
	setbuf( ps_fp, ps_ttybuf );
d111 5
a115 1
	setbuf( ps_fp, ttybuf );
d118 1
d171 2
a172 1
	ps_fp = (FILE *)0;
d174 1
d185 1
d188 1
d196 3
d200 1
d249 1
d287 1
d461 1
d463 1
@


11.2
log
@merging xmged sources
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/dm-ps.c,v 11.2 95/01/17 11:42:39 bparker Exp $ (BRL)";
d77 1
a77 1
#ifdef XMGED
d117 1
a117 1
#ifdef XMGED
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 10.9 94/12/24 01:05:21 mike Exp $ (BRL)";
d77 5
a83 1

d85 1
d117 3
d121 1
@


10.9
log
@Eliminated old dm_values.dv_* style "polled" device interface.
Everything is done by string commands now.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 10.8 94/12/23 22:55:12 mike Exp Locker: mike $ (BRL)";
@


10.8
log
@Added vert norm
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 10.7 94/12/16 19:36:10 gdurf Exp Locker: mike $ (BRL)";
a416 2

	dm_values.dv_penpress = 0;
@


10.7
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 10.6 1994/10/14 17:07:00 mike Exp gdurf $ (BRL)";
d257 1
@


10.6
log
@#if defined(_SC_OPEN_MAX)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 10.5 94/10/14 16:06:29 mike Exp Locker: mike $ (BRL)";
d99 1
a99 1
	(void)printf("PostScript file? ");
d167 1
a167 1
	printf("PS_close()\n");
d447 1
a447 1
	(void)printf("PS_load(x%x, %d.)\n", addr, count );
@


10.5
log
@Changed from getdtablesize() to sysconf(_SC_OPEN_MAX)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 10.4 94/08/10 21:42:52 mike Exp Locker: mike $ (BRL)";
d389 1
d391 1
@


10.4
log
@Changed calling sequence to dmr_input(), to pass an fd_set rather
than a single file descriptor.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 10.3 94/08/09 15:14:34 gdurf Exp Locker: mike $ (BRL)";
d389 1
a389 1
	if( (width = getdtablesize()) <= 0 )
@


10.3
log
@Added include of conf.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 10.2 1994/06/01 11:58:57 gdurf Exp gdurf $ (BRL)";
d29 1
d31 1
a36 1
#include "externs.h"
d44 1
a44 1
int	PS_input();
d376 3
a378 3
 * Returns:
 *	0 if no command waiting to be read,
 *	1 if command is waiting to be read.
d380 4
a383 1
PS_input( cmd_fd, noblock )
d385 3
a387 1
	register long readfds;
d389 3
d403 11
a413 5
	readfds = (1<<cmd_fd);
	if( noblock )
		readfds = bsdselect( readfds, 0, 0 );
	else
		readfds = bsdselect( readfds, 30*60, 0 );	/* 30 mins */
a415 5

	if( readfds & (1<<cmd_fd) )
		return(1);		/* command awaits */
	else
		return(0);		/* just peripheral stuff */
@


10.2
log
@Replaced gets() with fgets()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 10.1 1991/10/12 06:43:26 mike Rel4_0 gdurf $ (BRL)";
d25 2
@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 9.4 91/07/19 01:16:51 mike Exp $ (BRL)";
d97 2
a98 1
	(void)gets( line );		/* Null terminated */
@


9.4
log
@Don't use u_char on IBM.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 9.3 91/02/02 00:00:58 mike Exp $ (BRL)";
@


9.3
log
@Modified for new rt_vlist structures
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 9.2 91/01/12 08:25:33 mike Exp $ (BRL)";
a35 2
typedef unsigned char u_char;

d318 1
a318 1
register u_char *str;
@


9.2
log
@externs.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ps.c,v 9.1 89/05/19 06:02:29 mike Rel3_5 $ (BRL)";
d235 2
a236 2
	static vect_t last;
	register struct vlist *vp;
d246 24
a269 12
	for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
		/* Viewing region is from -1.0 to +1.0 */
		if( vp->vl_draw == 0 )  {
			/* Move, not draw */
			MAT4X3PNT( last, mat, vp->vl_pnt );
		}  else  {
			static vect_t fin;
			static vect_t start;
			/* draw */
			MAT4X3PNT( fin, mat, vp->vl_pnt );
			VMOVE( start, last );
			VMOVE( last, fin );
@


9.1
log
@Release_3.5
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-ps.c,v 8.3 89/04/06 20:39:24 mike Exp $ (BRL)";
a35 2
extern void	perror();

a73 1
extern FILE	*popen();		/* stdio pipe open routine */
@


8.3
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-ps.c,v 8.2 88/12/06 01:06:46 mike Locked $ (BRL)";
@


8.2
log
@Added #include <raytrace.h> for vector list stuff
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/dm-ps.c,v 1.2 88/10/23 13:56:07 mike Exp $ (BRL)";
d33 1
@


8.1
log
@Release_3.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-ps.c,v 1.4 88/09/17 08:28:27 mike Exp $ (BRL)";
d30 1
@


1.4
log
@Changed to return(0)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-ps.c,v 1.3 88/09/15 21:03:22 mike Locked $ (BRL)";
@


1.3
log
@added release display flag
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-ps.c,v 1.2 88/09/06 05:21:28 phil Locked $ (BRL)";
d240 1
a240 1
	if( !ps_fp )  return;
@


1.2
log
@This version includes it's own PostScript startoff,
and has been successfully used with TeX.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-ps.c,v 1.1 88/09/02 15:23:52 mike Locked $ (BRL)";
d68 1
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-plot.c,v 7.3 88/02/25 06:06:12 mike Exp $ (BRL)";
d79 2
a110 1
	/** Copy the prolog out **/
d112 36
a147 2
	fprintf(ps_fp, "%f %f scale\n", 1.0, 1.0);
/*	pl_space( ps_fp, -2048, -2048, 2048, 2048 );*/
d159 4
d165 1
d179 10
a188 1
	/* We expect the screen to be blank so far, from last frame flush */
d191 1
a191 3
	fprintf(ps_fp,"%d %d moveto %d %d 1 0 360 arc\n",
		GED_TO_PS(0), GED_TO_PS(0),
		GED_TO_PS(0), GED_TO_PS(0) );
d200 3
a202 1
	fprintf(ps_fp, "showpage\n");
d239 2
d242 1
a242 1
		fprintf(ps_fp, "DDV\n");	/* Dot-dashed vectors */
d244 1
a244 1
		fprintf(ps_fp, "NV\n");		/* Normal vectors */
d294 2
d310 2
d329 2
a330 1
	fprintf(ps_fp, "(%s) %d %d PR\n", str, GED_TO_PS(x), GED_TO_PS(y) );
d343 3
d347 1
a347 1
		fprintf(ps_fp, "DDV\n");	/* Dot-dashed vectors */
d349 1
a349 1
		fprintf(ps_fp, "NV\n");		/* Normal vectors */
a445 2
	(void)fflush(ps_fp);
	printf("flushed\n");
@
