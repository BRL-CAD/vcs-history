head	1.23;
access;
symbols
	ansi-20040405-merged:1.18.2.2
	postmerge-20040405-ansi:1.21
	premerge-20040404-ansi:1.20
	postmerge-autoconf:1.20
	autoconf-freeze:1.18.10.3
	premerge-autoconf:1.20
	postmerge-20040315-windows:1.20
	premerge-20040315-windows:1.19
	windows-20040315-freeze:1.18.4.2
	autoconf-20031203:1.18
	autoconf-20031202:1.18
	autoconf-branch:1.18.0.10
	phong-branch:1.18.0.8
	photonmap-branch:1.18.0.6
	rel-6-1-DP:1.18
	windows-branch:1.18.0.4
	rel-6-0-2:1.16
	ansi-branch:1.18.0.2
	rel-6-0-1-branch:1.16.0.2
	hartley-6-0-post:1.17
	hartley-6-0-pre:1.16
	rel-6-0-1:1.16
	rel-6-0:1.16
	offsite-5-3-pre:1.6;
locks; strict;
comment	@ * @;


1.23
date	2004.05.21.17.47.35;	author morrison;	state dead;
branches;
next	1.22;

1.22
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.16.21.15.10;	author morrison;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.02.17.39.31;	author morrison;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.20.17.08.21;	author jra;	state Exp;
branches
	1.18.2.1
	1.18.4.1
	1.18.10.1;
next	1.17;

1.17
date	2002.08.15.20.55.31;	author hartley;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.02.19.24.32;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.17.20.05.34;	author morrison;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.16.21.38.08;	author morrison;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.20.21.34.39;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.03.19.02.23;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.23.22.35.55;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.21.21.48.14;	author pjt;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.21.16.11.44;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.21.15.30.21;	author pjt;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.20.21.49.57;	author pjt;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.24.15.35.22;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.08.05.55.47;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.29.22.44.11;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.19.03.10.41;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.30.20.11.38;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.30.15.12.15;	author pjt;	state Exp;
branches;
next	;

1.18.2.1
date	2002.09.19.18.01.59;	author morrison;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2004.03.17.21.21.54;	author morrison;	state Exp;
branches;
next	;

1.18.4.1
date	2002.09.26.23.04.08;	author morrison;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2004.03.11.23.46.32;	author morrison;	state Exp;
branches;
next	;

1.18.10.1
date	2004.02.12.18.34.12;	author erikg;	state Exp;
branches;
next	1.18.10.2;

1.18.10.2
date	2004.03.15.14.07.35;	author erikg;	state Exp;
branches;
next	1.18.10.3;

1.18.10.3
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.23
log
@moved to src/mged/
@
text
@/*
 *			B O D Y I O . C
 *
 * Functions -
 *	cmd_import_body - read an object's body from a file
 *	cmd_export_body - write an object's body to a file
 *
 *  Author -
 *	Paul J. Tanenbaum
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 2000-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.

 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/bodyio.c,v 1.22 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifndef WIN32
#include <pwd.h>
#endif
#include <signal.h>
#include <math.h>
#include <time.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <errno.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "db5.h"
#include "bn.h"
#include "nmg.h"
#include "raytrace.h"
#include "externs.h"
#include "./ged.h"
#include "./sedit.h"

/* defined in librt/db5_bin.c */
extern void rt_binunif_dump();

/*
 *		C M D _ I M P O R T _ B O D Y ( )
 *
 *	Read an object's body from disk file
 *
 */
int
cmd_import_body(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    register struct directory	*dp;
    struct stat			stat_buf;
    int				major_code, minor_code;
    int				majc, minc;
    char			*descrip;
    struct bu_vls		vls;
    struct rt_db_internal	intern;
    struct rt_binunif_internal	*bip;
    int				fd;
    int				gotten;

    CHECK_DBI_NULL;

    if(argc != 4){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help %s", argv[0]);
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    switch (sscanf(argv[3], "%d %d", &major_code, &minor_code)) {
	case 1:
	    /* XXX is it safe to have no minor code? */
	    minor_code = 0;
	case 2:
	    break;
	case 0:
	    if ( db5_type_codes_from_descrip(&majc, &minc,
						argv[3])
	     && db5_type_codes_from_tag(&majc, &minc,
						argv[3])) {
		bu_vls_init( &vls );
		bu_vls_printf( &vls,
				"Invalid data type: '%s'\n", argv[3] );
		Tcl_SetResult(interp, bu_vls_addr( &vls ), TCL_VOLATILE );
		bu_vls_free( &vls );
		mged_print_result( TCL_ERROR );
		return TCL_ERROR;
	    }
    	    major_code = majc;
    	    minor_code = minc;
	    break;
    }
    bu_vls_init( &vls );
    if (db5_type_descrip_from_codes( &descrip, major_code, minor_code )) {
	bu_vls_printf( &vls,
			"Invalid maj/min: %d %d\n",
			major_code, minor_code);
	Tcl_SetResult(interp, bu_vls_addr( &vls ), TCL_VOLATILE );
	bu_vls_free( &vls );
	mged_print_result( TCL_ERROR );
	return TCL_ERROR;
    }
    if (RT_G_DEBUG & DEBUG_VOL)
        bu_log( "Type is %d %d '%s'\n", major_code, minor_code, descrip);

    /*
     *	Check to see if we need to create a new object
     */
    if ((dp = db_lookup( dbip, argv[1], LOOKUP_QUIET)) == DIR_NULL) {
	bu_vls_init( &vls );
	bu_vls_printf( &vls, "object \"%s\" does not exist.\n", argv[1] );
	Tcl_SetResult(interp, bu_vls_addr( &vls ), TCL_VOLATILE );
	bu_vls_free( &vls );
	mged_print_result( TCL_ERROR );
	return TCL_ERROR;

#if 0
	/* Update the in-core directory */
	if( (dp = db_diradd( dbip, argv[1], -1, 0, 0, NULL ))
		== DIR_NULL ) {
	  Tcl_AppendResult(interp, "An error has occured while adding '",
			   argv[1], "' to the database.\n", (char *)NULL);
	  TCL_ERROR_RECOVERY_SUGGESTION;
	  return TCL_ERROR;
	}

	BU_GETSTRUCT( comb, rt_comb_internal );
	comb->magic = RT_COMB_MAGIC;
	bu_vls_init( &comb->shader );
	bu_vls_init( &comb->material );
	comb->region_id = -1;
	comb->tree = TREE_NULL;
#endif

    } else {
	RT_INIT_DB_INTERNAL( &intern );
    }

    /*
     *	How much data do we have to suck in?
     */
    if( stat( argv[2], &stat_buf ) ) {
	bu_vls_init( &vls );
	bu_vls_printf( &vls, "Cannot get status of file %s\n", argv[2] );
	Tcl_SetResult(interp, bu_vls_addr( &vls ), TCL_VOLATILE );
	bu_vls_free( &vls );
	mged_print_result( TCL_ERROR );
	return TCL_ERROR;
    }
    if (RT_G_DEBUG & DEBUG_VOL)
	    bu_log ("File '%s' is %d bytes long\n", argv[2], stat_buf.st_size);
    if( (fd = open( argv[2], O_RDONLY  )) == -1 ) {
	bu_vls_init( &vls );
	bu_vls_printf( &vls,
	    "Cannot open file %s for reading\n", argv[2] );
	Tcl_SetResult(interp, bu_vls_addr( &vls ), TCL_VOLATILE );
	bu_vls_free( &vls );
	mged_print_result( TCL_ERROR );
	return TCL_ERROR;
    }

    if (db5_type_descrip_from_codes( &descrip, major_code, minor_code )) {
	bu_vls_printf( &vls,
	    "Invalid major_code/minor_code: %d\n", major_code);
	Tcl_SetResult(interp, bu_vls_addr( &vls ), TCL_VOLATILE );
	bu_vls_free( &vls );
	mged_print_result( TCL_ERROR );
	return TCL_ERROR;
    }
    switch (major_code) {
	case DB5_MAJORTYPE_BINARY_UNIF:
	    bip = bu_malloc(sizeof(struct rt_binunif_internal),
		    "rt_binunif_internal");
	    bip->magic = RT_BINUNIF_INTERNAL_MAGIC;
	    bip->type = minor_code;
	    bip->u.uint8 = (unsigned char *) bu_malloc(stat_buf.st_size, "binunif");
    if (RT_G_DEBUG & DEBUG_VOL)
	    bu_log("Created an rt_binunif_internal for type '%s' (minor=%d)\n", descrip, minor_code);

	    gotten = read( fd, (void *) (bip->u.uint8), stat_buf.st_size);
	    if (gotten == -1) {
		perror( "import_body" );
		return TCL_ERROR;
	    } else if (gotten < stat_buf.st_size) {
		bu_vls_init( &vls );
		bu_vls_printf( &vls,
		    "Incomplete read of object %s from file %s, got %d bytes\n",
		    argv[1], argv[2], gotten );
		Tcl_SetResult(interp, bu_vls_addr( &vls ), TCL_VOLATILE );
		bu_vls_free( &vls );
		mged_print_result( TCL_ERROR );
		return TCL_ERROR;
	    }
	    if (RT_G_DEBUG & DEBUG_VOL)
		    bu_log("gotten=%d,  minor_code is %d\n",
			   gotten, minor_code);
	    bip->count = gotten / db5_type_sizeof_n_binu( minor_code );
	    if (RT_G_DEBUG & DEBUG_VOL) {
		    bu_log("Got 'em!\nThink I own %d of 'em\n", bip->count);
		    fflush(stderr);
	    }
	    intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
	    intern.idb_type = minor_code;
	    intern.idb_meth = &rt_functab[ID_BINUNIF];
	    intern.idb_ptr = (genptr_t)bip;
	    rt_binunif_dump(bip);
	    rt_db_put_internal5( dp, dbip, &intern, &rt_uniresource, DB5_MAJORTYPE_BINARY_UNIF );
	    rt_db_free_internal( &intern, &rt_uniresource );
	    break;
	default:
	    bu_vls_printf( &vls,
		"Haven't gotten around to supporting type: %s\n",
		descrip);
	    Tcl_SetResult(interp, bu_vls_addr( &vls ), TCL_VOLATILE );
	    bu_vls_free( &vls );
	    mged_print_result( TCL_ERROR );
	    return TCL_ERROR;
    }

    return TCL_OK;
}

/*
 *		C M D _ E X P O R T _ B O D Y ( )
 *
 *	Write an object's body to disk file
 *
 */
int
cmd_export_body(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    register struct directory	*dp;
    int				fd;
    void			*bufp;
    size_t			nbytes = 0;
    int				written;
    struct bu_external		ext;
    struct db5_raw_internal	raw;
    struct rt_db_internal	intern;
    struct rt_binunif_internal	*bip;
    struct bu_vls		vls;
#if 0
    int				status;
#endif
    char			*tmp;

    CHECK_DBI_NULL;

    if(argc != 3){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help %s", argv[0]);
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    /*
     *	Find the guy we're told to write
     */
    if( (dp = db_lookup( dbip, argv[2], LOOKUP_NOISY)) == DIR_NULL ){
	bu_vls_init( &vls );
	bu_vls_printf( &vls,
	    "Cannot find object %s for writing\n", argv[2] );
	Tcl_SetResult(interp, bu_vls_addr( &vls ), TCL_VOLATILE );
	bu_vls_free( &vls );
	mged_print_result( TCL_ERROR );
	return TCL_ERROR;
    }
    RT_INIT_DB_INTERNAL(&intern);
    if ( rt_db_get_internal5( &intern, dp, dbip, NULL, &rt_uniresource) 
	!= ID_BINUNIF
     || db_get_external( &ext, dp, dbip ) < 0 ) {
	(void)signal( SIGINT, SIG_IGN );
	TCL_READ_ERR_return;
    }
    if (db5_get_raw_internal_ptr(&raw, ext.ext_buf) == NULL)
    {
	bu_free_external( &ext );
	(void)signal( SIGINT, SIG_IGN );
	TCL_READ_ERR_return;
    }

    /*
     *	Do the writing
     */
#ifndef WIN32
    if( (fd = creat( argv[1], S_IRWXU | S_IRGRP | S_IROTH  )) == -1 ) {
#else
		if( (fd = creat( argv[1], _S_IREAD | _S_IWRITE  )) == -1 ) { 
#endif
	bu_free_external( &ext );
	bu_vls_init( &vls );
	bu_vls_printf( &vls,
	    "Cannot open file %s for writing\n", argv[1] );
	Tcl_SetResult(interp, bu_vls_addr( &vls ), TCL_VOLATILE );
	bu_vls_free( &vls );
	mged_print_result( TCL_ERROR );
	return TCL_ERROR;
    }
    if (db5_type_descrip_from_codes(&tmp, raw.major_type, raw.minor_type))
	tmp = 0;

    if (RT_G_DEBUG & DEBUG_VOL)
	    bu_log("cmd_export_body() sees type (%d, %d)='%s'\n",
		   raw.major_type, raw.minor_type, tmp);
    switch (raw.major_type) {
	case DB5_MAJORTYPE_BINARY_UNIF:
#if 0
	    if ( rt_binunif_import5( &intern, &ext, 0, dbip,
		    &rt_uniresource, raw.minor_type  ) ) {
		(void)signal( SIGINT, SIG_IGN );
		TCL_READ_ERR_return;
	    }
#endif
	    bip = (struct rt_binunif_internal *) intern.idb_ptr;
	    RT_CK_BINUNIF(bip);
	    rt_binunif_dump(bip);
	    bufp = (void *) bip->u.uint8;
	    bu_log("cmd_export_body() thinks bip->count=%d\n", bip->count);
	    switch (bip -> type) {
		case DB5_MINORTYPE_BINU_FLOAT:
			if (RT_G_DEBUG & DEBUG_VOL)
				bu_log("bip->type switch... float");
		    nbytes = (size_t) (bip->count * sizeof(float));
		    break;
		case DB5_MINORTYPE_BINU_DOUBLE:
			if (RT_G_DEBUG & DEBUG_VOL)
				bu_log("bip->type switch... double");
		    nbytes = (size_t) (bip->count * sizeof(double));
		    break;
		case DB5_MINORTYPE_BINU_8BITINT:
		case DB5_MINORTYPE_BINU_8BITINT_U:
			if (RT_G_DEBUG & DEBUG_VOL)
				bu_log("bip->type switch... 8bitint");
		    nbytes = (size_t) (bip->count);
		    break;
		case DB5_MINORTYPE_BINU_16BITINT:
			if (RT_G_DEBUG & DEBUG_VOL)
				bu_log("bip->type switch... 16bitint");
		    nbytes = (size_t) (bip->count * 2);
		    bu_log("data[0] = %u\n", bip->u.uint16[0]);
		    break;
		case DB5_MINORTYPE_BINU_16BITINT_U:
			if (RT_G_DEBUG & DEBUG_VOL)
				bu_log("bip->type switch... 16bituint");
		    nbytes = (size_t) (bip->count * 2);
		    bu_log("data[0] = %u\n", bip->u.uint16[0]);
		    break;
		case DB5_MINORTYPE_BINU_32BITINT:
		case DB5_MINORTYPE_BINU_32BITINT_U:
			if (RT_G_DEBUG & DEBUG_VOL)
				bu_log("bip->type switch... 32bitint");
		    nbytes = (size_t) (bip->count * 4);
		    break;
		case DB5_MINORTYPE_BINU_64BITINT:
		case DB5_MINORTYPE_BINU_64BITINT_U:
			if (RT_G_DEBUG & DEBUG_VOL)
				bu_log("bip->type switch... 64bitint");
		    nbytes = (size_t) (bip->count * 8);
		    break;
		default:
		    /* XXX	This shouln't happen!!    */
		    bu_log("bip->type switch... default");
		    break;
	    }
	    break;
	default:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("I'm in the default\n");
		bufp = (void *) ext.ext_buf;
		nbytes = (size_t) ext.ext_nbytes;
		break;
    }
    if (RT_G_DEBUG & DEBUG_VOL)
	    bu_log("going to write %ld bytes\n", nbytes);

    if ( (written = write(fd, bufp, nbytes) ) != nbytes ) {
    	perror(argv[1]);
	    bu_log("%s:%d\n", __FILE__, __LINE__);
	bu_free_external( &ext );
	bu_vls_init( &vls );
	bu_vls_printf( &vls,
	    "Incomplete write of object %s to file %s, got %ld, s/b=%ld\n",
	    argv[2], argv[1], written, nbytes );
	Tcl_SetResult(interp, bu_vls_addr( &vls ), TCL_VOLATILE );
	bu_vls_free( &vls );
	mged_print_result( TCL_ERROR );
	return TCL_ERROR;
    }

    bu_free_external( &ext );
    return TCL_OK;
}
@


1.22
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/bodyio.c,v 1.21 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


1.21
log
@merge of ansi-6-0-branch into HEAD
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d29 5
a33 1
#include "conf.h"
@


1.20
log
@merge of windows-6-0-branch into head
@
text
@d72 1
a72 5
cmd_import_body(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d257 1
a257 5
cmd_export_body(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
@


1.19
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.18 2002/08/20 17:08:21 jra Exp $ (BRL)";
d32 1
d34 1
d46 1
d48 1
d321 1
d323 3
@


1.18
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 2000 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.16 2001/10/02 19:24:32 jra Exp $ (BRL)";
@


1.18.10.1
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.19 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


1.18.10.2
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.18.10.1 2004/02/12 18:34:12 erikg Exp $ (BRL)";
@


1.18.10.3
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a31 1
#ifndef WIN32
a32 1
#endif
a43 1
#ifndef WIN32
a44 1
#endif
a316 1
#ifndef WIN32
a317 3
#else
		if( (fd = creat( argv[1], _S_IREAD | _S_IWRITE  )) == -1 ) { 
#endif
@


1.18.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.18 2002/08/20 17:08:21 jra Exp $ (BRL)";
a31 1
#ifndef WIN32
a32 1
#endif
a43 1
#ifndef WIN32
a44 1
#endif
a316 1
#ifndef WIN32
a317 3
#else
		if( (fd = creat( argv[1], _S_IREAD | _S_IWRITE  )) == -1 ) { 
#endif
@


1.18.4.2
log
@sync to HEAD...
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/bodyio.c,v 1.18.4.1 2002/09/26 23:04:08 morrison Exp $ (BRL)";
@


1.18.2.1
log
@Initial ANSIfication
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.18 2002/08/20 17:08:21 jra Exp $ (BRL)";
d68 5
a72 1
cmd_import_body(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d257 5
a261 1
cmd_export_body(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


1.18.2.2
log
@sync branch with HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a31 1
#ifndef WIN32
a32 1
#endif
a43 1
#ifndef WIN32
a44 1
#endif
a308 1
#ifndef WIN32
a309 3
#else
		if( (fd = creat( argv[1], _S_IREAD | _S_IWRITE  )) == -1 ) { 
#endif
@


1.17
log
@Converted from K&R to ANSI C - RFH
@
text
@d68 5
a72 1
cmd_import_body(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d257 5
a261 1
cmd_export_body(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


1.16
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.15 2001/05/17 20:05:34 morrison Exp $ (BRL)";
d68 1
a68 5
cmd_import_body(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d253 1
a253 5
cmd_export_body(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
@


1.15
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.14 2001/05/16 21:38:08 morrison Exp $ (BRL)";
d229 1
@


1.14
log
@PRODUCTION optimizations
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.13 2001/04/20 21:34:39 bparker Exp $ (BRL)";
d130 1
a130 1
    if (rt_g.debug & DEBUG_VOL)
d177 1
a177 1
    if (rt_g.debug & DEBUG_VOL)
d204 1
a204 1
    if (rt_g.debug & DEBUG_VOL)
d221 1
a221 1
	    if (rt_g.debug & DEBUG_VOL)
d225 1
a225 1
	    if (rt_g.debug & DEBUG_VOL) {
d329 1
a329 1
    if (rt_g.debug & DEBUG_VOL)
d348 1
a348 1
			if (rt_g.debug & DEBUG_VOL)
d353 1
a353 1
			if (rt_g.debug & DEBUG_VOL)
d359 1
a359 1
			if (rt_g.debug & DEBUG_VOL)
d364 1
a364 1
			if (rt_g.debug & DEBUG_VOL)
d370 1
a370 1
			if (rt_g.debug & DEBUG_VOL)
d377 1
a377 1
			if (rt_g.debug & DEBUG_VOL)
d383 1
a383 1
			if (rt_g.debug & DEBUG_VOL)
d394 1
a394 1
		if (rt_g.debug & DEBUG_VOL)
d400 1
a400 1
    if (rt_g.debug & DEBUG_VOL)
@


1.13
log
@*- mods for handling return value of db5_get_raw_internal_ptr()
   differently. Previous code tested for <0 to indicate
   a failed attempt. However, this routine never returns
   values less than 0. It returns NULL (0) for failure and >0
   for success.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.12 2001/04/03 19:02:23 bparker Exp $ (BRL)";
d265 1
a265 1
    size_t			nbytes;
@


1.12
log
@*- get rid of warnings
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.11 2001/03/23 22:35:55 butler Exp $ (BRL)";
d306 1
a306 1
    if ( db5_get_raw_internal_ptr( &raw, ext.ext_buf ) < 0 )
@


1.11
log
@Changes to support new DSP primitive representation
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /n/tgm/d/CVS/brlcad/mged/bodyio.c,v 1.10 2001/03/21 21:48:14 pjt Exp $ (BRL)";
d57 3
@


1.10
log
@tweaks
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/bodyio.c,v 1.9 2001/03/21 16:11:44 butler Exp $ (BRL)";
d127 2
a128 1
    bu_log( "Type is %d %d '%s'\n", major_code, minor_code, descrip);
d133 1
a133 1
    if(( dp = db_lookup( dbip, argv[1], LOOKUP_NOISY)) == DIR_NULL ) {
d135 1
a135 1
	bu_vls_printf( &vls, "I don't feel like creating object %s\n", argv[1] );
d174 2
a175 1
    bu_log ("File '%s' is %d bytes long\n", argv[2], stat_buf.st_size);
d201 1
d218 3
a220 1
	    bu_log("gotten=%d,  minor_code is %d\n", gotten, minor_code);
d222 4
a225 3
	    bu_log("Got 'em!\nThink I own %d of 'em\n", bip->count);
	    fflush(stderr);

d325 4
a328 2
    bu_log("cmd_export_body() sees type (%d, %d)='%s'\n",
	raw.major_type, raw.minor_type, tmp);
d345 2
a346 1
		    bu_log("bip->type switch... float");
d350 2
a351 1
		    bu_log("bip->type switch... double");
d356 2
a357 1
		    bu_log("bip->type switch... 8bitint");
d361 5
d367 2
a368 1
		    bu_log("bip->type switch... 16bitint");
d370 1
d374 2
a375 1
		    bu_log("bip->type switch... 32bitint");
d380 2
a381 1
		    bu_log("bip->type switch... 64bitint");
d391 5
a395 4
	    bu_log("I'm in the default\n");
	    bufp = (void *) ext.ext_buf;
	    nbytes = (size_t) ext.ext_nbytes;
	    break;
d397 3
a399 1
    bu_log("going to write %ld bytes\n", nbytes);
d402 1
@


1.9
log
@Fixes for binary objects
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /n/tgm/d/CVS/brlcad/mged/bodyio.c,v 1.8 2001/03/21 15:30:21 pjt Exp $ (BRL)";
d266 1
a266 1
    char			tmp[1028];
d317 2
a318 2
    if (db5_type_descrip_from_codes(tmp, raw.major_type, raw.minor_type))
	tmp[0] = '\0';
@


1.8
log
@uncommented an rt_get_external()
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/bodyio.c,v 1.7 2001/03/20 21:49:57 pjt Exp $ (BRL)";
d220 1
a220 1
	    intern.idb_type = ID_BINUNIF;
@


1.7
log
@COB 20 Mar 2001
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/bodyio.c,v 1.6 2000/10/24 15:35:22 mike Exp $ (BRL)";
d292 2
a293 4
	!= ID_BINUNIF ) {
#if 0
    if ( db_get_external( &ext, dp, dbip ) < 0 )
#endif
@


1.6
log
@
lint
@
text
@d5 2
a6 2
 *	cmd_bodyread - read an object's body from a file
 *	cmd_bodywrite - write an object's body to a file
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.5 2000/09/08 05:55:47 mike Exp $ (BRL)";
d59 1
a59 1
 *		C M D _ B O D Y R E A D ( )
d65 1
a65 1
cmd_bodyread(clientData, interp, argc, argv )
a71 4
#if 0
    struct bu_external		ext;
    struct db5_raw_internal	raw;
#endif
d74 1
a74 1
    unsigned char		majc, minc;
d132 1
a132 1
    if( (dp = db_lookup( dbip, argv[1], LOOKUP_NOISY)) == DIR_NULL ) {
d203 1
a203 1
		perror( "bodyread" );
d215 1
d218 1
d223 2
a224 1
	    rt_db_put_internal5( dp, dbip, &intern, &rt_uniresource );
d241 1
a241 1
 *		C M D _ B O D Y W R I T E ( )
d247 1
a247 1
cmd_bodywrite(clientData, interp, argc, argv )
a260 3
#if 0
    struct stat			stat_buf;
#endif
d266 1
d290 4
d295 1
a295 1
    {
d319 4
d325 3
a327 2
	    if ( rt_binunif_import5( &intern,
			raw.minor_type, &ext, dbip ) ) {
a329 1
		
d331 1
d333 2
d336 1
d339 1
d343 1
d348 1
d353 1
d358 1
d363 1
d366 4
d373 1
d378 1
d384 1
a384 1
	    "Incomplete write of object %s to file %s, got %d, s/b=%d\n",
@


1.5
log
@
Tree routines now need resource structure.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.4 2000/08/29 22:44:11 mike Exp $ (BRL)";
d72 1
d75 1
d262 1
d264 1
d267 1
d269 1
@


1.4
log
@
Fixed lint
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.3 2000/08/19 03:10:41 mike Exp $ (BRL)";
d223 2
a224 2
	    rt_db_put_internal5( dp, dbip, &intern );
	    rt_db_free_internal( &intern );
@


1.3
log
@
const RCSid
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.2 2000/06/30 20:11:38 pjt Exp $ (BRL)";
d75 2
a76 1
    unsigned char		major_code, minor_code;
d103 1
a103 1
	    if ( db5_type_codes_from_descrip(&major_code, &minor_code,
d105 1
a105 1
	     && db5_type_codes_from_tag(&major_code, &minor_code,
d113 1
a113 1
		return;
d115 2
d127 1
a127 1
	return;
d140 1
a140 1
	return;
d149 1
a149 1
	  return DIR_NULL;
d173 1
a173 1
	return;
d183 1
a183 1
	return;
d192 1
a192 1
	return;
d215 1
a215 1
		return;
d233 1
a233 1
	    return;
d285 1
a285 1
	return;
d310 1
a310 1
	return;
d353 1
d357 2
a358 2
	    "Incomplete write of object %s to file %s\n",
	    argv[2], argv[1] );
d362 1
a362 1
	return;
@


1.2
log
@I'm sorta kinda reading in something successfully
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bodyio.c,v 1.1 2000/06/30 15:12:15 pjt Exp $ (BRL)";
@


1.1
log
@Read/Write an object's body from/to a disk file
@
text
@d5 2
a6 2
 *	bodyread - read an object's body from a file
 *	bodywrite - write an object's body to a file
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.48 2000/03/31 18:14:18 bparker Exp $ (BRL)";
d45 1
d76 1
a76 1
    char			*foo;
d78 4
d108 1
a108 2
				"Invalid data type: 'tomato'\n" );
				/*"Invalid data type: '%s'\n", argv[3] );*/
d117 1
a117 1
    if (db5_type_descrip_from_codes( &foo, major_code, minor_code )) {
d126 1
a126 5
    bu_vls_printf( &vls, "Type is %d %d '%s'\n", major_code, minor_code, foo);
    Tcl_SetResult(interp, bu_vls_addr( &vls ), TCL_VOLATILE );
    bu_vls_free( &vls );
    mged_print_result( TCL_OK );
    return;
a127 1
#if 0
d132 8
d142 1
a142 2
		== DIR_NULL
	 || db_put ( dbip, dp, XXX, 0, 1) < 0 )  {
d155 1
d157 1
a158 4
	intern.idb_type = ID_COMBINATION;
	intern.idb_meth = &rt_functab[ID_COMBINATION];
	intern.idb_ptr = (genptr_t)comb;

d172 60
a231 3
    /* stat_buf.st_size */
    (void)signal( SIGINT, SIG_IGN );
#endif
d264 1
a264 1
    if(argc != 4){
d275 1
a275 1
    if( (dp = db_lookup( dbip, argv[2], LOOKUP_NOISY)) != DIR_NULL ){
d278 1
a278 1
	    "Cannot find object %s for writing\n", argv[1] );
@

