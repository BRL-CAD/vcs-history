head	1.24;
access;
symbols
	ansi-20040405-merged:1.21.4.1
	postmerge-20040405-ansi:1.22
	premerge-20040404-ansi:1.22
	postmerge-autoconf:1.22
	autoconf-freeze:1.21.12.1
	premerge-autoconf:1.22
	postmerge-20040315-windows:1.22
	premerge-20040315-windows:1.21
	windows-20040315-freeze:1.21.6.1
	autoconf-20031203:1.21
	autoconf-20031202:1.21
	autoconf-branch:1.21.0.12
	phong-branch:1.21.0.10
	photonmap-branch:1.21.0.8
	rel-6-1-DP:1.21
	windows-branch:1.21.0.6
	rel-6-0-2:1.21
	ansi-branch:1.21.0.4
	rel-6-0-1-branch:1.21.0.2
	hartley-6-0-post:1.21
	hartley-6-0-pre:1.21
	rel-6-0-1:1.21
	rel-6-0:1.21
	rel-5-4:1.13.2.3
	offsite-5-3-pre:1.17
	rel-5-3:1.13.2.3
	rel-5-2:1.13
	rel-5-1-branch:1.13.0.2
	rel-5-1:1.13
	rel-5-0:1.12
	rel-5-0-beta:1.10
	rel-4-5:1.1;
locks; strict;
comment	@ * @;


1.24
date	2004.05.21.17.47.40;	author morrison;	state dead;
branches;
next	1.23;

1.23
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.16.21.15.11;	author morrison;	state Exp;
branches;
next	1.21;

1.21
date	2001.10.17.07.40.05;	author morrison;	state Exp;
branches
	1.21.4.1
	1.21.6.1
	1.21.12.1;
next	1.20;

1.20
date	2001.06.18.14.23.55;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.05.15.51.41;	author bparker;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.01.19.23.24;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.16.22.43.43;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.17.16.32.59;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.24.15.14.13;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.18.14.23.14;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	99.12.27.18.52.09;	author bparker;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	99.07.09.13.49.29;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	99.07.08.20.25.30;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	98.11.06.22.31.40;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	98.10.21.17.06.34;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	98.06.29.19.15.22;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	98.06.11.14.28.11;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	98.05.07.15.40.48;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	98.03.19.20.55.26;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	98.03.19.18.02.52;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	98.03.06.22.32.14;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	98.02.26.15.57.49;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	97.10.10.17.17.39;	author bparker;	state Exp;
branches;
next	;

1.13.2.1
date	2000.10.18.14.03.07;	author bparker;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2000.11.17.16.31.28;	author bparker;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2001.02.09.15.26.31;	author bparker;	state Exp;
branches;
next	;

1.21.4.1
date	2004.03.17.21.21.57;	author morrison;	state Exp;
branches;
next	;

1.21.6.1
date	2002.09.26.23.04.10;	author morrison;	state Exp;
branches;
next	;

1.21.12.1
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@MGED's only registered event handler.
@


1.24
log
@moved to src/mged/
@
text
@/*
 *                        D O E V E N T . C
 *
 * X event handling routines for MGED.
 *
 * Author -
 *     Robert G. Parker
 *
 * Source -
 *	SLAD CAD Team
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>

#ifdef DM_X
#  include "tk.h"
#  include <X11/Xutil.h>
#ifndef WIN32
#  include <X11/extensions/XI.h>
#  include <X11/extensions/XInput.h>
#endif
#  include <X11/keysym.h>
#else
#  include "tcl.h"
#endif


#if IR_KNOBS
#include <gl/device.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "dm_xvars.h"
#include "./ged.h"
#include "./mged_dm.h"
#include "./sedit.h"

extern int doMotion;			/* defined in dm-generic.c */
extern void rect_view2image();		/* defined in rect.c */
extern void rect_image2view();
extern void rb_set_dirty_flag();

static void motion_event_handler();
#if IR_KNOBS
static void dials_event_handler();
#endif

#if IR_BUTTONS
static void buttons_event_handler();
/*
 * Map SGI Button numbers to MGED button functions.
 * The layout of this table is suggestive of the actual button box layout.
 */
#define SW_HELP_KEY	SW0
#define SW_ZERO_KEY	SW3
#define HELP_KEY	0
#define ZERO_KNOBS	0
static unsigned char bmap[IR_BUTTONS] = {
	HELP_KEY,    BV_ADCURSOR, BV_RESET,    ZERO_KNOBS,
	BE_O_SCALE,  BE_O_XSCALE, BE_O_YSCALE, BE_O_ZSCALE, 0,           BV_VSAVE,
	BE_O_X,      BE_O_Y,      BE_O_XY,     BE_O_ROTATE, 0,           BV_VRESTORE,
	BE_S_TRANS,  BE_S_ROTATE, BE_S_SCALE,  BE_MENU,     BE_O_ILLUMINATE, BE_S_ILLUMINATE,
	BE_REJECT,   BV_BOTTOM,   BV_TOP,      BV_REAR,     BV_45_45,    BE_ACCEPT,
	BV_RIGHT,    BV_FRONT,    BV_LEFT,     BV_35_25
};
#endif

#ifdef IR_KNOBS
/*
 *  Labels for knobs in help mode.
 */
static char	*kn1_knobs[] = {
	/* 0 */ "adc <1",	/* 1 */ "zoom", 
	/* 2 */ "adc <2",	/* 3 */ "adc dist",
	/* 4 */ "adc y",	/* 5 */ "y slew",
	/* 6 */ "adc x",	/* 7 */	"x slew"
};
static char	*kn2_knobs[] = {
	/* 0 */ "unused",	/* 1 */	"zoom",
	/* 2 */ "z rot",	/* 3 */ "z slew",
	/* 4 */ "y rot",	/* 5 */ "y slew",
	/* 6 */ "x rot",	/* 7 */	"x slew"
};
#endif

#if IR_BUTTONS || IR_KNOBS
static int button0 = 0;
#endif

int
doEvent(clientData, eventPtr)
ClientData clientData;
XEvent *eventPtr;
{
  register struct dm_list *save_dm_list;
  int status;

  if(eventPtr->type == DestroyNotify || (unsigned long)eventPtr->xany.window == 0)
    return TCL_OK;

  save_dm_list = curr_dm_list;
  GET_DM_LIST(curr_dm_list, (unsigned long)eventPtr->xany.window);

  /* it's an event for a window that I'm not handling */
  if(curr_dm_list == DM_LIST_NULL){
    curr_dm_list = save_dm_list;
    return TCL_OK;
  }

    /* windows fix - for now */
#ifdef WIN32
  if(eventHandler == NULL)
	  return TCL_CONTINUE;
#endif

  /* calling the display manager specific event handler */
  status = eventHandler(clientData, eventPtr);

  /* no further processing of this event */
  if(status != TCL_OK){
    curr_dm_list = save_dm_list;
    return status;
  }

  /* Continuing to process the event */

  if(eventPtr->type == ConfigureNotify){
    XConfigureEvent *conf = (XConfigureEvent *)eventPtr;

    DM_CONFIGURE_WIN(dmp);
    rect_image2view();
    dirty = 1;

    if(fbp)
      fb_configureWindow(fbp, conf->width, conf->height);

    /* no further processing of this event */
    status = TCL_RETURN;
  }else if(eventPtr->type == MapNotify){
    mapped = 1;

    /* no further processing of this event */
    status = TCL_RETURN;
  }else if(eventPtr->type == UnmapNotify){
    mapped = 0;

    /* no further processing of this event */
    status = TCL_RETURN;
  }else if(eventPtr->type == MotionNotify){
    motion_event_handler((XMotionEvent *)eventPtr);

    /* no further processing of this event */
    status = TCL_RETURN;
  }
#if IR_KNOBS
  else if(eventPtr->type == ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devmotionnotify){
    dials_event_handler((XDeviceMotionEvent *)eventPtr);

    /* no further processing of this event */
    status = TCL_RETURN;
  }
#endif
#if IR_BUTTONS
  else if(eventPtr->type == ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonpress){
    buttons_event_handler((XDeviceButtonEvent *)eventPtr, 1);

    /* no further processing of this event */
    status = TCL_RETURN;
  }else if(eventPtr->type == ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonrelease){
    buttons_event_handler((XDeviceButtonEvent *)eventPtr, 0);

    /* no further processing of this event */
    status = TCL_RETURN;
  }
#endif

  curr_dm_list = save_dm_list;
  return status;
}

#if IR_BUTTONS || IR_KNOBS
static void
set_knob_offset()
{
  int i;

  for(i = 0; i < 8; ++i)
    dml_knobs[i] = 0;
}
#endif

#if IR_BUTTONS || IR_KNOBS
static void
common_dbtext(str)
char *str;
{
  bu_log("common_dbtext: You pressed Help key and '%s'\n", str);
}
#endif

static void
motion_event_handler(xmotion)
XMotionEvent *xmotion;
{
  struct bu_vls cmd;
  int save_edflag = -1;
  int mx, my;
  int dx, dy;
  fastf_t f;
  fastf_t fx, fy;
  fastf_t td;

  if (dbip == DBI_NULL)
	  return;

  bu_vls_init(&cmd);

  mx = xmotion->x;
  my = xmotion->y;
  dx = mx - dml_omx;
  dy = my - dml_omy;

  switch(am_mode){
  case AMM_IDLE:
    if(scroll_active)
      bu_vls_printf( &cmd, "M 1 %d %d\n",
		     (int)(dm_Xx2Normal(dmp, mx) * GED_MAX),
		     (int)(dm_Xy2Normal(dmp, my, 0) * GED_MAX) );
    else if(rubber_band->rb_active){
      fastf_t x = dm_Xx2Normal(dmp, mx);
      fastf_t y = dm_Xy2Normal(dmp, my, 1);

      if(grid_state->gr_snap)
	snap_to_grid(&x, &y);

      rubber_band->rb_width = x - rubber_band->rb_x;
      rubber_band->rb_height = y - rubber_band->rb_y;

      rect_view2image();
      /*
       * Now go back the other way to reconcile
       * differences caused by floating point fuzz.
       */
      rect_image2view();
      rb_set_dirty_flag();

      goto handled;
    }else if(doMotion)
      /* do the regular thing */
      /* Constant tracking (e.g. illuminate mode) bound to M mouse */
      bu_vls_printf( &cmd, "M 0 %d %d\n",
		     (int)(dm_Xx2Normal(dmp, mx) * GED_MAX),
		     (int)(dm_Xy2Normal(dmp, my, 1) * GED_MAX) );
    else /* not doing motion */
      goto handled;

    break;
  case AMM_ROT:
    {
      char save_coords;

      save_coords = mged_variables->mv_coords;
      mged_variables->mv_coords = 'v';

      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->mv_transform == 'e'){

	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_ROTATE)
	    es_edflag = SROT;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_ROTATE;
	}

	if(mged_variables->mv_rateknobs)
	  bu_vls_printf(&cmd, "knob -i x %lf y %lf\n",
			dy / (fastf_t)dmp->dm_height * RATE_ROT_FACTOR * 2.0,
			dx / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0);
	else
	  bu_vls_printf(&cmd, "knob -i ax %lf ay %lf\n",
			dy * 0.25, dx * 0.25);
      } else {
	if(mged_variables->mv_rateknobs)
	  bu_vls_printf(&cmd, "knob -i -v x %lf y %lf\n",
			dy / (fastf_t)dmp->dm_height * RATE_ROT_FACTOR * 2.0,
			dx / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0);
	else
	  bu_vls_printf(&cmd, "knob -i -v ax %lf ay %lf\n",
			dy * 0.25, dx * 0.25);
      }

      (void)Tcl_Eval(interp, bu_vls_addr(&cmd));
      mged_variables->mv_coords = save_coords;

      goto reset_edflag;
    }
  case AMM_TRAN:
    {
      char save_coords;

      save_coords = mged_variables->mv_coords;
      mged_variables->mv_coords = 'v';

      fx = dx / (fastf_t)dmp->dm_width * 2.0;
      fy = -dy / (fastf_t)dmp->dm_height / dmp->dm_aspect * 2.0;

      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->mv_transform == 'e'){

	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_TRAN)
	    es_edflag = STRANS;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_XY;
	}

	if(mged_variables->mv_rateknobs)
	  bu_vls_printf(&cmd, "knob -i X %lf Y %lf\n", fx, fy);
	else if(grid_state->gr_snap){
	  point_t view_pt;
	  point_t model_pt;
	  point_t vcenter, diff;

	  /* accumulate distance mouse moved since starting to translate */
	  dml_mouse_dx += dx;
	  dml_mouse_dy += dy;

	  view_pt[X] = dml_mouse_dx / (fastf_t)dmp->dm_width * 2.0;
	  view_pt[Y] = -dml_mouse_dy / (fastf_t)dmp->dm_height / dmp->dm_aspect * 2.0;
	  view_pt[Z] = 0.0;
	  round_to_grid(&view_pt[X], &view_pt[Y]);

	  MAT4X3PNT(model_pt, view_state->vs_vop->vo_view2model, view_pt);
	  MAT_DELTAS_GET_NEG(vcenter, view_state->vs_vop->vo_center);
	  VSUB2(diff, model_pt, vcenter);
	  VSCALE(diff, diff, base2local);
	  VADD2(model_pt, dml_work_pt, diff);
	  if (state == ST_S_EDIT)
		  bu_vls_printf(&cmd, "p %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
	  else
		  bu_vls_printf(&cmd, "translate %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
	}else
	  bu_vls_printf(&cmd, "knob -i aX %lf aY %lf\n",
			fx*view_state->vs_vop->vo_scale*base2local, fy*view_state->vs_vop->vo_scale*base2local);
      }else{
	if(mged_variables->mv_rateknobs)      /* otherwise, drag to translate the view */
	  bu_vls_printf( &cmd, "knob -i -v X %lf Y %lf\n", fx, fy );
	else{
	  if(grid_state->gr_snap){
	    /* accumulate distance mouse moved since starting to translate */
	    dml_mouse_dx += dx;
	    dml_mouse_dy += dy;

	    snap_view_to_grid(dml_mouse_dx / (fastf_t)dmp->dm_width * 2.0,
			      -dml_mouse_dy / (fastf_t)dmp->dm_height / dmp->dm_aspect * 2.0);

	    mged_variables->mv_coords = save_coords;
	    goto handled;
	  }else
	    bu_vls_printf( &cmd, "knob -i -v aX %lf aY %lf\n",
			   fx*view_state->vs_vop->vo_scale*base2local, fy*view_state->vs_vop->vo_scale*base2local );
	}
      }

      (void)Tcl_Eval(interp, bu_vls_addr(&cmd));
      mged_variables->mv_coords = save_coords;

      goto reset_edflag;
    }
  case AMM_SCALE:
    if((state == ST_S_EDIT || state == ST_O_EDIT) &&
       mged_variables->mv_transform == 'e'){
      if(state == ST_S_EDIT && !SEDIT_SCALE){
	save_edflag = es_edflag;
	es_edflag = SSCALE;
      }else if(state == ST_O_EDIT && !OEDIT_SCALE){
	save_edflag = edobj;
	edobj = BE_O_SCALE;
      }
    }

    if(abs(dx) >= abs(dy))
      f = dx;
    else
      f = -dy;

    if(mged_variables->mv_rateknobs)
      bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
    else
      bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

    break;
  case AMM_ADC_ANG1:
    fx = dm_Xx2Normal(dmp, mx) * GED_MAX - adc_state->adc_dv_x;
    fy = dm_Xy2Normal(dmp, my, 1) * GED_MAX - adc_state->adc_dv_y;
    bu_vls_printf(&cmd, "adc a1 %lf\n", RAD2DEG*atan2(fy, fx));

    break;
  case AMM_ADC_ANG2:
    fx = dm_Xx2Normal(dmp, mx) * GED_MAX - adc_state->adc_dv_x;
    fy = dm_Xy2Normal(dmp, my, 1) * GED_MAX - adc_state->adc_dv_y;
    bu_vls_printf(&cmd, "adc a2 %lf\n", RAD2DEG*atan2(fy, fx));

    break;
  case AMM_ADC_TRAN:
    {
      point_t model_pt;
      point_t view_pt;

      VSET(view_pt, dm_Xx2Normal(dmp, mx), dm_Xy2Normal(dmp, my, 1), 0.0);

      if(grid_state->gr_snap)
	snap_to_grid(&view_pt[X], &view_pt[Y]);

      MAT4X3PNT(model_pt, view_state->vs_vop->vo_view2model, view_pt);
      VSCALE(model_pt, model_pt, base2local);
      bu_vls_printf(&cmd, "adc xyz %lf %lf %lf\n", model_pt[X], model_pt[Y], model_pt[Z]);
    }

    break;
  case AMM_ADC_DIST:
    fx = (dm_Xx2Normal(dmp, mx) * GED_MAX - adc_state->adc_dv_x) * view_state->vs_vop->vo_scale * base2local * INV_GED;
    fy = (dm_Xy2Normal(dmp, my, 1) * GED_MAX - adc_state->adc_dv_y) * view_state->vs_vop->vo_scale * base2local * INV_GED;
    td = sqrt(fx * fx + fy * fy);
    bu_vls_printf(&cmd, "adc dst %lf\n", td);

    break;
  case AMM_CON_ROT_X:
    if((state == ST_S_EDIT || state == ST_O_EDIT) &&
       mged_variables->mv_transform == 'e'){
      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_ROTATE)
	  es_edflag = SROT;
      }else{
	save_edflag = edobj;
	edobj = BE_O_ROTATE;
      }
    }

    if(abs(dx) >= abs(dy))
      f = dx;
    else
      f = -dy;

    if(mged_variables->mv_rateknobs)
      bu_vls_printf( &cmd, "knob -i x %f\n",
		     f / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0 );
    else
      bu_vls_printf( &cmd, "knob -i ax %f\n", f * 0.25 );

    break;
  case AMM_CON_ROT_Y:
    if((state == ST_S_EDIT || state == ST_O_EDIT) &&
       mged_variables->mv_transform == 'e'){
      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_ROTATE)
	  es_edflag = SROT;
      }else{
	save_edflag = edobj;
	edobj = BE_O_ROTATE;
      }
    }

    if(abs(dx) >= abs(dy))
      f = dx;
    else
      f = -dy;

    if(mged_variables->mv_rateknobs)
      bu_vls_printf( &cmd, "knob -i y %f\n",
		     f / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0 );
    else
      bu_vls_printf( &cmd, "knob -i ay %f\n", f * 0.25 );

    break;
  case AMM_CON_ROT_Z:
    if((state == ST_S_EDIT || state == ST_O_EDIT) &&
       mged_variables->mv_transform == 'e'){
      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_ROTATE)
	  es_edflag = SROT;
      }else{
	save_edflag = edobj;
	edobj = BE_O_ROTATE;
      }
    }

    if(abs(dx) >= abs(dy))
      f = dx;
    else
      f = -dy;

    if(mged_variables->mv_rateknobs)
      bu_vls_printf( &cmd, "knob -i z %f\n",
		     f / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0 );
    else
      bu_vls_printf( &cmd, "knob -i az %f\n", f * 0.25 );

    break;
  case AMM_CON_TRAN_X:
    if((state == ST_S_EDIT || state == ST_O_EDIT) &&
       mged_variables->mv_transform == 'e'){
      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_TRAN)
	  es_edflag = STRANS;
      }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	save_edflag = edobj;
	edobj = BE_O_X;
      }
    }

    if(abs(dx) >= abs(dy))
      f = dx / (fastf_t)dmp->dm_width * 2.0;
    else
      f = -dy / (fastf_t)dmp->dm_height / dmp->dm_aspect * 2.0;

    if(mged_variables->mv_rateknobs)
      bu_vls_printf( &cmd, "knob -i X %f\n", f);
    else
      bu_vls_printf( &cmd, "knob -i aX %f\n", f*view_state->vs_vop->vo_scale*base2local);

    break;
  case AMM_CON_TRAN_Y:
    if((state == ST_S_EDIT || state == ST_O_EDIT) &&
       mged_variables->mv_transform == 'e'){
      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_TRAN)
	  es_edflag = STRANS;
      }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	save_edflag = edobj;
	edobj = BE_O_Y;
      }
    }

    if(abs(dx) >= abs(dy))
      f = dx / (fastf_t)dmp->dm_width * 2.0;
    else
      f = -dy / (fastf_t)dmp->dm_height / dmp->dm_aspect * 2.0;

    if(mged_variables->mv_rateknobs)
      bu_vls_printf( &cmd, "knob -i Y %f\n", f);
    else
      bu_vls_printf( &cmd, "knob -i aY %f\n", f*view_state->vs_vop->vo_scale*base2local);

    break;
  case AMM_CON_TRAN_Z:
    if((state == ST_S_EDIT || state == ST_O_EDIT) &&
       mged_variables->mv_transform == 'e'){
      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_TRAN)
	  es_edflag = STRANS;
      }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	save_edflag = edobj;
	edobj = BE_O_XY;
      }
    }

    if(abs(dx) >= abs(dy))
      f = dx / (fastf_t)dmp->dm_width * 2.0;
    else
      f = -dy / (fastf_t)dmp->dm_height / dmp->dm_aspect * 2.0;

    if(mged_variables->mv_rateknobs)
      bu_vls_printf( &cmd, "knob -i Z %f\n", f);
    else
      bu_vls_printf( &cmd, "knob -i aZ %f\n", f*view_state->vs_vop->vo_scale*base2local);

    break;
  case AMM_CON_SCALE_X:
    if((state == ST_S_EDIT || state == ST_O_EDIT) &&
       mged_variables->mv_transform == 'e'){
      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_SCALE)
	  es_edflag = SSCALE;
      }else if(state == ST_O_EDIT && !OEDIT_SCALE){
	save_edflag = edobj;
	edobj = BE_O_XSCALE;
      }
    }

    if(abs(dx) >= abs(dy))
      f = dx;
    else
      f = -dy;

    if(mged_variables->mv_rateknobs)
      bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
    else
      bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

    break;
  case AMM_CON_SCALE_Y:
    if((state == ST_S_EDIT || state == ST_O_EDIT) &&
       mged_variables->mv_transform == 'e'){
      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_SCALE)
	  es_edflag = SSCALE;
      }else if(state == ST_O_EDIT && !OEDIT_SCALE){
	save_edflag = edobj;
	edobj = BE_O_YSCALE;
      }
    }

    if(abs(dx) >= abs(dy))
      f = dx;
    else
      f = -dy;

    if(mged_variables->mv_rateknobs)
      bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
    else
      bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

    break;
  case AMM_CON_SCALE_Z:
    if((state == ST_S_EDIT || state == ST_O_EDIT) &&
       mged_variables->mv_transform == 'e'){
      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_SCALE)
	  es_edflag = SSCALE;
      }else if(state == ST_O_EDIT && !OEDIT_SCALE){
	save_edflag = edobj;
	edobj = BE_O_ZSCALE;
      }
    }

    if(abs(dx) >= abs(dy))
      f = dx;
    else
      f = -dy;

    if(mged_variables->mv_rateknobs)
      bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
    else
      bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

    break;
  case AMM_CON_XADC:
    if(abs(dx) >= abs(dy))
      f = dx;
    else
      f = -dy;

    bu_vls_printf( &cmd, "knob -i xadc %f\n",
		   f / (fastf_t)dmp->dm_width * GED_RANGE );
    break;
  case AMM_CON_YADC:
    if(abs(dx) >= abs(dy))
      f = dx;
    else
      f = -dy;

    bu_vls_printf( &cmd, "knob -i yadc %f\n",
		   f / (fastf_t)dmp->dm_height * GED_RANGE );
    break;
  case AMM_CON_ANG1:
    if(abs(dx) >= abs(dy))
      f = dx;
    else
      f = -dy;

    bu_vls_printf( &cmd, "knob -i ang1 %f\n",
		   f / (fastf_t)dmp->dm_width * 90.0 );
    break;
  case AMM_CON_ANG2:
    if(abs(dx) >= abs(dy))
      f = dx;
    else
      f = -dy;

    bu_vls_printf( &cmd, "knob -i ang2 %f\n",
		     f / (fastf_t)dmp->dm_width * 90.0 );
    break;
  case AMM_CON_DIST:
    if(abs(dx) >= abs(dy))
      f = dx;
    else
      f = -dy;

    bu_vls_printf( &cmd, "knob -i distadc %f\n",
		   f / (fastf_t)dmp->dm_width * GED_RANGE );
    break;
  }

  (void)Tcl_Eval(interp, bu_vls_addr(&cmd));

reset_edflag:
  if(save_edflag != -1){
    if(state == ST_S_EDIT)
      es_edflag = save_edflag;
    else if(state == ST_O_EDIT)
      edobj = save_edflag;
  }

handled:
  bu_vls_free(&cmd);
  dml_omx = mx;
  dml_omy = my;
}

#if IR_KNOBS
static void
dials_event_handler(dmep)
XDeviceMotionEvent *dmep;
{
  static int knob_values[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  struct bu_vls cmd;
  int save_edflag = -1;
  int setting;
  fastf_t f;

  if (dbip == DBI_NULL)
	  return;

  if(button0){
    common_dbtext((adc_state->adc_draw ? kn1_knobs:kn2_knobs)[dmep->first_axis]);
    return;
  }

  bu_vls_init(&cmd);

  switch(DIAL0 + dmep->first_axis){
  case DIAL0:
    if(adc_state->adc_draw){
      if(-NOISE <= dml_knobs[dmep->first_axis] &&
	 dml_knobs[dmep->first_axis] <= NOISE &&
	 !adc_state->adc_dv_a1 )
	dml_knobs[dmep->first_axis] +=
	  dmep->axis_data[0] - knob_values[dmep->first_axis];
      else
	dml_knobs[dmep->first_axis] =
	  dm_unlimit(adc_state->adc_dv_a1) + dmep->axis_data[0] - knob_values[dmep->first_axis];

      setting = dm_limit(dml_knobs[dmep->first_axis]);
      bu_vls_printf( &cmd, "knob ang1 %f\n",
		     45.0 - 45.0*((double)setting) * INV_GED);
    }else{
      if(mged_variables->mv_rateknobs){
	f = view_state->vs_rate_model_rotate[Z];

	if(-NOISE <= dml_knobs[dmep->first_axis] &&
	   dml_knobs[dmep->first_axis] <= NOISE && !f)
	  dml_knobs[dmep->first_axis] +=
	    dmep->axis_data[0] - knob_values[dmep->first_axis];
	else
	  dml_knobs[dmep->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    dmep->axis_data[0] - knob_values[dmep->first_axis];

	setting = dm_limit(dml_knobs[dmep->first_axis]);
	bu_vls_printf( &cmd, "knob -m z %f\n", setting / 512.0 );
      }else{
	f = view_state->vs_absolute_model_rotate[Z];

	if(-NOISE <= dml_knobs[dmep->first_axis] &&
	   dml_knobs[dmep->first_axis] <= NOISE && !f)
	  dml_knobs[dmep->first_axis] +=
	    dmep->axis_data[0] - knob_values[dmep->first_axis];
	else
	  dml_knobs[dmep->first_axis] =
	    dm_unlimit((int)(2.847 * f)) +
	    dmep->axis_data[0] - knob_values[dmep->first_axis];

	f = dm_limit(dml_knobs[dmep->first_axis]) / 512.0;
	bu_vls_printf( &cmd, "knob -m az %f\n", dm_wrap(f) * 180.0);
      }
    }
    break;
  case DIAL1:
    if(mged_variables->mv_rateknobs){
      if(EDIT_SCALE && mged_variables->mv_transform == 'e')
	f = edit_rate_scale;
      else
	f = view_state->vs_rate_scale;

      if(-NOISE <= dml_knobs[dmep->first_axis] &&
	 dml_knobs[dmep->first_axis] <= NOISE && !f)
	  dml_knobs[dmep->first_axis] +=
	    dmep->axis_data[0] - knob_values[dmep->first_axis];
      else
	dml_knobs[dmep->first_axis] = dm_unlimit((int)(512.5 * f)) +
	  dmep->axis_data[0] - knob_values[dmep->first_axis];

      setting = dm_limit(dml_knobs[dmep->first_axis]);
      bu_vls_printf( &cmd, "knob S %f\n", setting / 512.0 );
    }else{
      if(EDIT_SCALE && mged_variables->mv_transform == 'e')
	f = edit_absolute_scale;
      else
	f = view_state->vs_absolute_scale;

      if(-NOISE <= dml_knobs[dmep->first_axis] &&
	 dml_knobs[dmep->first_axis] <= NOISE && !f)
	dml_knobs[dmep->first_axis] +=
	  dmep->axis_data[0] - knob_values[dmep->first_axis];
      else
	dml_knobs[dmep->first_axis] =
	  dm_unlimit((int)(512.5 * f)) +
	  dmep->axis_data[0] - knob_values[dmep->first_axis];

      setting = dm_limit(dml_knobs[dmep->first_axis]);
      bu_vls_printf( &cmd, "knob aS %f\n", setting / 512.0 );
    }
    break;
  case DIAL2:
    if(adc_state->adc_draw){
      if(-NOISE <= dml_knobs[dmep->first_axis] &&
	 dml_knobs[dmep->first_axis] <= NOISE &&
	 !adc_state->adc_dv_a2 )
	dml_knobs[dmep->first_axis] +=
	  dmep->axis_data[0] - knob_values[dmep->first_axis];
      else
	dml_knobs[dmep->first_axis] =
	  dm_unlimit(adc_state->adc_dv_a2) + dmep->axis_data[0] - knob_values[dmep->first_axis];

      setting = dm_limit(dml_knobs[dmep->first_axis]);
      bu_vls_printf( &cmd, "knob ang2 %f\n",
		     45.0 - 45.0*((double)setting) * INV_GED);
    }else {
      if(mged_variables->mv_rateknobs){
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->mv_transform == 'e'){
	  switch(mged_variables->mv_coords){
	  case 'm':
	    f = edit_rate_model_rotate[Z];
	    break;
	  case 'o':
	    f = edit_rate_object_rotate[Z];
	    break;
	  case 'v':
	  default:
	    f = edit_rate_view_rotate[Z];
	    break;
	  }

	  if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_ROTATE)
	      es_edflag = SROT;
	  }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	    save_edflag = edobj;
	    edobj = BE_O_ROTATE;
	  }
	}else if(mged_variables->mv_coords == 'm')
	  f = view_state->vs_rate_model_rotate[Z];
	else
	  f = view_state->vs_rate_rotate[Z];

	if(-NOISE <= dml_knobs[dmep->first_axis] &&
	   dml_knobs[dmep->first_axis] <= NOISE && !f)
	  dml_knobs[dmep->first_axis] +=
	    dmep->axis_data[0] - knob_values[dmep->first_axis];
	else
	  dml_knobs[dmep->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    dmep->axis_data[0] - knob_values[dmep->first_axis];

	setting = dm_limit(dml_knobs[dmep->first_axis]);
	bu_vls_printf( &cmd, "knob z %f\n", setting / 512.0 );
      }else{
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->mv_transform == 'e'){
	  switch(mged_variables->mv_coords){
	  case 'm':
	    f = edit_absolute_model_rotate[Z];
	    break;
	  case 'o':
	    f = edit_absolute_object_rotate[Z];
	    break;
	  case 'v':
	  default:
	    f = edit_absolute_view_rotate[Z];
	    break;
	  }

	  if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_ROTATE)
	      es_edflag = SROT;
	  }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	    save_edflag = edobj;
	    edobj = BE_O_ROTATE;
	  }
	}else if(mged_variables->mv_coords == 'm')
	  f = view_state->vs_absolute_model_rotate[Z];
	else
	  f = view_state->vs_absolute_rotate[Z];

	if(-NOISE <= dml_knobs[dmep->first_axis] &&
	   dml_knobs[dmep->first_axis] <= NOISE && !f)
	  dml_knobs[dmep->first_axis] +=
	    dmep->axis_data[0] - knob_values[dmep->first_axis];
	else
	  dml_knobs[dmep->first_axis] =
	    dm_unlimit((int)(2.847 * f)) +
	    dmep->axis_data[0] - knob_values[dmep->first_axis];

	f = dm_limit(dml_knobs[dmep->first_axis]) / 512.0;
	bu_vls_printf( &cmd, "knob az %f\n", dm_wrap(f) * 180.0);
      }
    }
    break;
  case DIAL3:
    if(adc_state->adc_draw){
      if(-NOISE <= dml_knobs[dmep->first_axis] &&
	 dml_knobs[dmep->first_axis] <= NOISE &&
	 !adc_state->adc_dv_dist)
	dml_knobs[dmep->first_axis] +=
	  dmep->axis_data[0] - knob_values[dmep->first_axis];
      else
	dml_knobs[dmep->first_axis] =
	  dm_unlimit(adc_state->adc_dv_dist) + dmep->axis_data[0] - knob_values[dmep->first_axis];

      setting = dm_limit(dml_knobs[dmep->first_axis]);
      bu_vls_printf( &cmd, "knob distadc %d\n", setting );
    }else {
      if(mged_variables->mv_rateknobs){
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->mv_transform == 'e'){
	  switch(mged_variables->mv_coords){
	  case 'm':
	  case 'o':
	    f = edit_rate_model_tran[Z];
	    break;
	  case 'v':
	  default:
	    f = edit_rate_view_tran[Z];
	    break;
	  }

	  if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_TRAN)
	      es_edflag = STRANS;
	  }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }
	}else if(mged_variables->mv_coords == 'm')
	  f = view_state->vs_rate_model_tran[Z];
	else
	  f = view_state->vs_rate_tran[Z];

	if(-NOISE <= dml_knobs[dmep->first_axis] &&
	   dml_knobs[dmep->first_axis] <= NOISE && !f)
	  dml_knobs[dmep->first_axis] +=
	    dmep->axis_data[0] - knob_values[dmep->first_axis];
	else
	  dml_knobs[dmep->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    dmep->axis_data[0] - knob_values[dmep->first_axis];

	setting = dm_limit(dml_knobs[dmep->first_axis]);
	bu_vls_printf( &cmd, "knob Z %f\n", setting / 512.0 );
      }else{
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->mv_transform == 'e'){
	  switch(mged_variables->mv_coords){
	  case 'm':
	  case 'o':
	    f = edit_absolute_model_tran[Z];
	    break;
	  case 'v':
	  default:
	    f = edit_absolute_view_tran[Z];
	    break;
	  }

	  if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_TRAN)
	      es_edflag = STRANS;
	  }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }
	}else if(mged_variables->mv_coords == 'm')
	  f = view_state->vs_absolute_model_tran[Z];
	else
	  f = view_state->vs_absolute_tran[Z];

	if(-NOISE <= dml_knobs[dmep->first_axis] &&
	   dml_knobs[dmep->first_axis] <= NOISE &&
	   !f )
	  dml_knobs[dmep->first_axis] +=
	    dmep->axis_data[0] - knob_values[dmep->first_axis];
	else
	  dml_knobs[dmep->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    dmep->axis_data[0] - knob_values[dmep->first_axis];

	setting = dm_limit(dml_knobs[dmep->first_axis]);
	bu_vls_printf(&cmd, "knob aZ %f\n", setting / 512.0 * view_state->vs_vop->vo_scale * base2local);
      }
    }
    break;
  case DIAL4:
    if(adc_state->adc_draw){
      if(-NOISE <= dml_knobs[dmep->first_axis] &&
	 dml_knobs[dmep->first_axis] <= NOISE &&
	 !adc_state->adc_dv_y)
	dml_knobs[dmep->first_axis] +=
	  dmep->axis_data[0] - knob_values[dmep->first_axis];
      else
	dml_knobs[dmep->first_axis] =
	  dm_unlimit(adc_state->adc_dv_y) + dmep->axis_data[0] - knob_values[dmep->first_axis];

      setting = dm_limit(dml_knobs[dmep->first_axis]);
      bu_vls_printf( &cmd, "knob yadc %d\n", setting );
    }else{
      if(mged_variables->mv_rateknobs){
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->mv_transform == 'e'){
	  switch(mged_variables->mv_coords){
	  case 'm':
	    f = edit_rate_model_rotate[Y];
	    break;
	  case 'o':
	    f = edit_rate_object_rotate[Y];
	    break;
	  case 'v':
	  default:
	    f = edit_rate_view_rotate[Y];
	    break;
	  }

	  if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_ROTATE)
	      es_edflag = SROT;
	  }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	    save_edflag = edobj;
	    edobj = BE_O_ROTATE;
	  }
	}else if(mged_variables->mv_coords == 'm')
	  f = view_state->vs_rate_model_rotate[Y];
	else
	  f = view_state->vs_rate_rotate[Y];

	if(-NOISE <= dml_knobs[dmep->first_axis] &&
	   dml_knobs[dmep->first_axis] <= NOISE && !f)
	  dml_knobs[dmep->first_axis] +=
	    dmep->axis_data[0] - knob_values[dmep->first_axis];
	else
	  dml_knobs[dmep->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    dmep->axis_data[0] - knob_values[dmep->first_axis];

	setting = dm_limit(dml_knobs[dmep->first_axis]);
	bu_vls_printf( &cmd, "knob y %f\n", setting / 512.0 );
      }else{
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->mv_transform == 'e'){
	  switch(mged_variables->mv_coords){
	  case 'm':
	    f = edit_absolute_model_rotate[Y];
	    break;
	  case 'o':
	    f = edit_absolute_object_rotate[Y];
	    break;
	  case 'v':
	  default:
	    f = edit_absolute_view_rotate[Y];
	    break;
	  }

	  if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_ROTATE)
	      es_edflag = SROT;
	  }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	    save_edflag = edobj;
	    edobj = BE_O_ROTATE;
	  }
	}else if(mged_variables->mv_coords == 'm')
	  f = view_state->vs_absolute_model_rotate[Y];
	else
	  f = view_state->vs_absolute_rotate[Y];

	if(-NOISE <= dml_knobs[dmep->first_axis] &&
	   dml_knobs[dmep->first_axis] <= NOISE &&
	   !f )
	  dml_knobs[dmep->first_axis] +=
	    dmep->axis_data[0] - knob_values[dmep->first_axis];
	else
	  dml_knobs[dmep->first_axis] =
	    dm_unlimit((int)(2.847 * f)) +
	    dmep->axis_data[0] - knob_values[dmep->first_axis];

	f = dm_limit(dml_knobs[dmep->first_axis]) / 512.0;
	bu_vls_printf( &cmd, "knob ay %f\n", dm_wrap(f) * 180.0);
      }
    }
    break;
  case DIAL5:
    if(mged_variables->mv_rateknobs){
      if((state == ST_S_EDIT || state == ST_O_EDIT)
	 && mged_variables->mv_transform == 'e'){
	switch(mged_variables->mv_coords){
	case 'm':
	case 'o':
	  f = edit_rate_model_tran[Y];
	  break;
	case 'v':
	default:
	  f = edit_rate_view_tran[Y];
	  break;
	}

	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_TRAN)
	    es_edflag = STRANS;
	}else if(state == ST_O_EDIT && !OEDIT_TRAN){
	  save_edflag = edobj;
	  edobj = BE_O_XY;
	}
      }else if(mged_variables->mv_coords == 'm')
	f = view_state->vs_rate_model_tran[Y];
      else
	f = view_state->vs_rate_tran[Y];

      if(-NOISE <= dml_knobs[dmep->first_axis] &&
	 dml_knobs[dmep->first_axis] <= NOISE && !f)
	dml_knobs[dmep->first_axis] +=
	  dmep->axis_data[0] - knob_values[dmep->first_axis];
      else
	dml_knobs[dmep->first_axis] =
	  dm_unlimit((int)(512.5 * f)) +
	  dmep->axis_data[0] - knob_values[dmep->first_axis];

      setting = dm_limit(dml_knobs[dmep->first_axis]);
      bu_vls_printf( &cmd, "knob Y %f\n", setting / 512.0 );
    }else{
      if((state == ST_S_EDIT || state == ST_O_EDIT)
	 && mged_variables->mv_transform == 'e'){
	switch(mged_variables->mv_coords){
	case 'm':
	case 'o':
	  f = edit_absolute_model_tran[Y];
	  break;
	case 'v':
	default:
	  f = edit_absolute_view_tran[Y];
	  break;
	}

	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_TRAN)
	    es_edflag = STRANS;
	}else if(state == ST_O_EDIT && !OEDIT_TRAN){
	  save_edflag = edobj;
	  edobj = BE_O_XY;
	}
      }else if(mged_variables->mv_coords == 'm')
	f = view_state->vs_absolute_model_tran[Y];
      else
	f = view_state->vs_absolute_tran[Y];

      if(-NOISE <= dml_knobs[dmep->first_axis] &&
	 dml_knobs[dmep->first_axis] <= NOISE && !f)
	dml_knobs[dmep->first_axis] +=
	  dmep->axis_data[0] -
	  knob_values[dmep->first_axis];
      else
	dml_knobs[dmep->first_axis] =
	  dm_unlimit((int)(512.5 * f)) +
	  dmep->axis_data[0] - knob_values[dmep->first_axis];

      setting = dm_limit(dml_knobs[dmep->first_axis]);
      bu_vls_printf(&cmd, "knob aY %f\n", setting / 512.0 * view_state->vs_vop->vo_scale * base2local);
    }
    break;
  case DIAL6:
    if(adc_state->adc_draw){
      if(-NOISE <= dml_knobs[dmep->first_axis] &&
	 dml_knobs[dmep->first_axis] <= NOISE &&
	 !adc_state->adc_dv_x)
	dml_knobs[dmep->first_axis] +=
	  dmep->axis_data[0] - knob_values[dmep->first_axis];
      else
	dml_knobs[dmep->first_axis] =
	  dm_unlimit(adc_state->adc_dv_x) + dmep->axis_data[0] - knob_values[dmep->first_axis];

      setting = dm_limit(dml_knobs[dmep->first_axis]);
      bu_vls_printf( &cmd, "knob xadc %d\n", setting );
    }else{
      if(mged_variables->mv_rateknobs){
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->mv_transform == 'e'){
	  switch(mged_variables->mv_coords){
	  case 'm':
	    f = edit_rate_model_rotate[X];
	    break;
	  case 'o':
	    f = edit_rate_object_rotate[X];
	    break;
	  case 'v':
	  default:
	    f = edit_rate_view_rotate[X];
	    break;
	  }

	  if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_ROTATE)
	      es_edflag = SROT;
	  }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	    save_edflag = edobj;
	    edobj = BE_O_ROTATE;
	  }
	}else if(mged_variables->mv_coords == 'm')
	  f = view_state->vs_rate_model_rotate[X];
	else
	  f = view_state->vs_rate_rotate[X];

	if(-NOISE <= dml_knobs[dmep->first_axis] &&
	   dml_knobs[dmep->first_axis] <= NOISE && !f)
	  dml_knobs[dmep->first_axis] +=
	    dmep->axis_data[0] - knob_values[dmep->first_axis];
	else
	  dml_knobs[dmep->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    dmep->axis_data[0] - knob_values[dmep->first_axis];

	setting = dm_limit(dml_knobs[dmep->first_axis]);
	bu_vls_printf( &cmd, "knob x %f\n", setting / 512.0);
      }else{
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->mv_transform == 'e'){
	  switch(mged_variables->mv_coords){
	  case 'm':
	    f = edit_absolute_model_rotate[X];
	    break;
	  case 'o':
	    f = edit_absolute_object_rotate[X];
	    break;
	  case 'v':
	  default:
	    f = edit_absolute_view_rotate[X];
	    break;
	  }

	  if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_ROTATE)
	      es_edflag = SROT;
	  }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	    save_edflag = edobj;
	    edobj = BE_O_ROTATE;
	  }
	}else if(mged_variables->mv_coords == 'm')
	  f = view_state->vs_absolute_model_rotate[X];
	else
	  f = view_state->vs_absolute_rotate[X];

	if(-NOISE <= dml_knobs[dmep->first_axis] &&
	   dml_knobs[dmep->first_axis] <= NOISE && !f)
	  dml_knobs[dmep->first_axis] +=
	    dmep->axis_data[0] - knob_values[dmep->first_axis];
	else
	  dml_knobs[dmep->first_axis] =
	    dm_unlimit((int)(2.847 * f)) +
	    dmep->axis_data[0] - knob_values[dmep->first_axis];

	f = dm_limit(dml_knobs[dmep->first_axis]) / 512.0;
	bu_vls_printf( &cmd, "knob ax %f\n", dm_wrap(f) * 180.0);
      }
    }
    break;
  case DIAL7:
    if(mged_variables->mv_rateknobs){
      if((state == ST_S_EDIT || state == ST_O_EDIT)
	 && mged_variables->mv_transform == 'e'){
	switch(mged_variables->mv_coords){
	case 'm':
	case 'o':
	  f = edit_rate_model_tran[X];
	  break;
	case 'v':
	default:
	  f = edit_rate_view_tran[X];
	  break;
	}

	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_TRAN)
	    es_edflag = STRANS;
	}else if(state == ST_O_EDIT && !OEDIT_TRAN){
	  save_edflag = edobj;
	  edobj = BE_O_XY;
	}
      }else if(mged_variables->mv_coords == 'm')
	f = view_state->vs_rate_model_tran[X];
      else
	f = view_state->vs_rate_tran[X];

      if(-NOISE <= dml_knobs[dmep->first_axis] &&
	 dml_knobs[dmep->first_axis] <= NOISE && !f)
	dml_knobs[dmep->first_axis] +=
	  dmep->axis_data[0] - knob_values[dmep->first_axis];
      else
	dml_knobs[dmep->first_axis] =
	  dm_unlimit((int)(512.5 * f)) +
	  dmep->axis_data[0] - knob_values[dmep->first_axis];

      setting = dm_limit(dml_knobs[dmep->first_axis]);
      bu_vls_printf( &cmd, "knob X %f\n", setting / 512.0 );
    }else{
      if((state == ST_S_EDIT || state == ST_O_EDIT)
	 && mged_variables->mv_transform == 'e'){
	switch(mged_variables->mv_coords){
	case 'm':
	case 'o':
	  f = edit_absolute_model_tran[X];
	  break;
	case 'v':
	default:
	  f = edit_absolute_view_tran[X];
	  break;
	}

	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_TRAN)
	    es_edflag = STRANS;
	}else if(state == ST_O_EDIT && !OEDIT_TRAN){
	  save_edflag = edobj;
	  edobj = BE_O_XY;
	}
      }else if(mged_variables->mv_coords == 'm')
	f = view_state->vs_absolute_model_tran[X];
      else
	f = view_state->vs_absolute_tran[X];

      if(-NOISE <= dml_knobs[dmep->first_axis] &&
	 dml_knobs[dmep->first_axis] <= NOISE && !f)
	dml_knobs[dmep->first_axis] +=
	  dmep->axis_data[0] - knob_values[dmep->first_axis];
      else
	dml_knobs[dmep->first_axis] =
	  dm_unlimit((int)(512.5 * f)) +
	  dmep->axis_data[0] - knob_values[dmep->first_axis];

      setting = dm_limit(dml_knobs[dmep->first_axis]);
      bu_vls_printf(&cmd, "knob aX %f\n", setting / 512.0 * view_state->vs_vop->vo_scale * base2local);
    }
    break;
  default:
    break;
  }

  /* Keep track of the knob values */
  knob_values[dmep->first_axis] = dmep->axis_data[0];

  Tcl_Eval(interp, bu_vls_addr(&cmd));

  if(save_edflag != -1){
    if(state == ST_S_EDIT)
      es_edflag = save_edflag;
    else if(state == ST_O_EDIT)
      edobj = save_edflag;
  }

  bu_vls_free(&cmd);
}
#endif

#if IR_BUTTONS
static void
buttons_event_handler(dbep, press)
XDeviceButtonEvent *dbep;
int press;
{
  if(press){
    struct bu_vls cmd;

    if(dbep->button == 1){
      button0 = 1;
      return;
    }

    if(button0){
      common_dbtext(label_button(bmap[dbep->button - 1]));
      return;
    }else if(dbep->button == 4){
      set_knob_offset();

      bu_vls_init(&cmd);
      bu_vls_strcat(&cmd, "knob zero\n");
    }else{
      bu_vls_init(&cmd);
      bu_vls_printf(&cmd, "press %s\n",
		    label_button(bmap[dbep->button - 1]));
    }

    (void)Tcl_Eval(interp, bu_vls_addr(&cmd));
    bu_vls_free(&cmd);
  }else{
    if(dbep->button == 1)
      button0 = 0;
  }
}
#endif
@


1.23
log
@change conf.h to a wrapped config.h
@
text
@@


1.22
log
@merge of windows-6-0-branch into head
@
text
@d16 5
a20 1
#include "conf.h"
@


1.21
log
@Mac OS X warning and error fixes for non-production build
@
text
@d24 1
d27 1
d33 1
d120 6
@


1.21.12.1
log
@merge from head
@
text
@a23 1
#ifndef WIN32
a25 1
#endif
a30 1

a116 6

    /* windows fix - for now */
#ifdef WIN32
  if(eventHandler == NULL)
	  return TCL_CONTINUE;
#endif
@


1.21.4.1
log
@sync branch with HEAD
@
text
@a23 1
#ifndef WIN32
a25 1
#endif
a30 1

a116 6

    /* windows fix - for now */
#ifdef WIN32
  if(eventHandler == NULL)
	  return TCL_CONTINUE;
#endif
@


1.21.6.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@a23 1
#ifndef WIN32
a25 1
#endif
a30 1

a116 6

    /* windows fix - for now */
#ifdef WIN32
  if(eventHandler == NULL)
	  return TCL_CONTINUE;
#endif
@


1.20
log
@*- mods to handle the case where Xwindows hands
   the application an event where the window id is 0.
@
text
@d21 10
a30 5
#include "tk.h"
#include <X11/Xutil.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XInput.h>
#include <X11/keysym.h>
@


1.19
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d101 1
a101 1
  if(eventPtr->type == DestroyNotify)
@


1.18
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@a333 1
#ifdef MGED_USE_VIEW_OBJ
a335 4
#else
	  MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
	  MAT_DELTAS_GET_NEG(vcenter, view_state->vs_toViewcenter);
#endif
a343 1
#ifdef MGED_USE_VIEW_OBJ
a345 4
#else
	  bu_vls_printf(&cmd, "knob -i aX %lf aY %lf\n",
			fx*view_state->vs_Viewscale*base2local, fy*view_state->vs_Viewscale*base2local);
#endif
a360 1
#ifdef MGED_USE_VIEW_OBJ
a362 4
#else
	    bu_vls_printf( &cmd, "knob -i -v aX %lf aY %lf\n",
			   fx*view_state->vs_Viewscale*base2local, fy*view_state->vs_Viewscale*base2local );
#endif
a415 1
#ifdef MGED_USE_VIEW_OBJ
a416 3
#else
      MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
#endif
a422 1
#ifdef MGED_USE_VIEW_OBJ
a424 4
#else
    fx = (dm_Xx2Normal(dmp, mx) * GED_MAX - adc_state->adc_dv_x) * view_state->vs_Viewscale * base2local * INV_GED;
    fy = (dm_Xy2Normal(dmp, my, 1) * GED_MAX - adc_state->adc_dv_y) * view_state->vs_Viewscale * base2local * INV_GED;
#endif
a524 1
#ifdef MGED_USE_VIEW_OBJ
a525 3
#else
      bu_vls_printf( &cmd, "knob -i aX %f\n", f*view_state->vs_Viewscale*base2local);
#endif
a548 1
#ifdef MGED_USE_VIEW_OBJ
a549 3
#else
      bu_vls_printf( &cmd, "knob -i aY %f\n", f*view_state->vs_Viewscale*base2local);
#endif
a572 1
#ifdef MGED_USE_VIEW_OBJ
a573 3
#else
      bu_vls_printf( &cmd, "knob -i aZ %f\n", f*view_state->vs_Viewscale*base2local);
#endif
a1002 1
#ifdef MGED_USE_VIEW_OBJ
a1003 3
#else
	bu_vls_printf(&cmd, "knob aZ %f\n", setting / 512.0 * view_state->vs_Viewscale * base2local);
#endif
a1181 1
#ifdef MGED_USE_VIEW_OBJ
a1182 3
#else
      bu_vls_printf(&cmd, "knob aY %f\n", setting / 512.0 * view_state->vs_Viewscale * base2local);
#endif
a1357 1
#ifdef MGED_USE_VIEW_OBJ
a1358 3
#else
      bu_vls_printf(&cmd, "knob aX %f\n", setting / 512.0 * view_state->vs_Viewscale * base2local);
#endif
@


1.17
log
@*- check if (dbip == DBI_NULL) before doing anything
@
text
@d334 4
d340 1
d349 4
d355 1
d371 4
d377 1
d431 3
d435 1
d442 4
d448 1
d549 3
d553 1
d577 3
d581 1
d605 3
d609 1
d1039 3
d1043 1
d1222 3
d1226 1
d1402 3
d1406 1
@


1.16
log
@Mods to account for floating point fuzz
when drawing the rubberband
@
text
@d210 3
d721 3
@


1.15
log
@
compiler lint
@
text
@d234 5
@


1.14
log
@Mods to make snap-to-grid work while in Object Edit.
@
text
@d47 1
d49 3
a52 2

#ifdef IR_BUTTONS
d89 1
d91 1
d178 1
d187 1
d189 1
d196 1
@


1.13
log
@*- use DM_CONFIGURE_WIN
@
text
@d323 4
a326 1
	  bu_vls_printf(&cmd, "p %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
@


1.13.2.1
log
@Mods to make snap-to-grid work in Object Edit
@
text
@d323 1
a323 4
	  if (state == ST_S_EDIT)
		  bu_vls_printf(&cmd, "p %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
	  else
		  bu_vls_printf(&cmd, "translate %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
@


1.13.2.2
log
@Mods to account for floating point fuzz
when drawing the rubberband
@
text
@a225 5
      /*
       * Now go back the other way to reconcile
       * differences caused by floating point fuzz.
       */
      rect_image2view();
@


1.13.2.3
log
@Mods that check if dbip==DBI_NULL
@
text
@a201 3
  if (dbip == DBI_NULL)
	  return;

a709 3

  if (dbip == DBI_NULL)
	  return;
@


1.12
log
@*- simplify
@
text
@d123 1
a123 1
    dm_configureWindowShape(dmp);
@


1.11
log
@*- mods to motion_event_handler to accomodate
   earlier changes in chgview.c
@
text
@d304 4
a307 5
	else{
	  if(grid_state->gr_snap){
	    point_t view_pt;
	    point_t model_pt;
	    point_t vcenter, diff;
d309 3
a311 3
	    /* accumulate distance mouse moved since starting to translate */
	    dml_mouse_dx += dx;
	    dml_mouse_dy += dy;
d313 4
a316 4
	    view_pt[X] = dml_mouse_dx / (fastf_t)dmp->dm_width * 2.0;
	    view_pt[Y] = -dml_mouse_dy / (fastf_t)dmp->dm_height / dmp->dm_aspect * 2.0;
	    view_pt[Z] = 0.0;
	    round_to_grid(&view_pt[X], &view_pt[Y]);
d318 9
a326 10
	    MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
	    MAT_DELTAS_GET_NEG(vcenter, view_state->vs_toViewcenter);
	    VSUB2(diff, model_pt, vcenter);
	    VSCALE(diff, diff, base2local);
	    VADD2(model_pt, dml_work_pt, diff);
	    bu_vls_printf(&cmd, "p %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
	  }else
	    bu_vls_printf(&cmd, "knob -i aX %lf aY %lf\n",
			  fx*view_state->vs_Viewscale*base2local, fy*view_state->vs_Viewscale*base2local);
	}
@


1.10
log
@*- use new structures
*- cleanup
@
text
@d240 1
a240 2
    if((state == ST_S_EDIT || state == ST_O_EDIT) &&
       mged_variables->mv_transform == 'e'){
d246 27
a272 7
      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_ROTATE)
	  es_edflag = SROT;
      }else{
	save_edflag = edobj;
	edobj = BE_O_ROTATE;
a274 7
      if(mged_variables->mv_rateknobs)
	bu_vls_printf(&cmd, "knob -i x %lf y %lf\n",
		      dy / (fastf_t)dmp->dm_height * RATE_ROT_FACTOR * 2.0,
		      dx / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0);
      else
	bu_vls_printf(&cmd, "knob -i ax %lf ay %lf\n",
		      dy * 0.25, dx * 0.25);
a279 10

    if(mged_variables->mv_rateknobs)
      bu_vls_printf(&cmd, "knob -i -v x %lf y %lf\n",
		    dy / (fastf_t)dmp->dm_height * RATE_ROT_FACTOR * 2.0,
		    dx / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0);
    else
      bu_vls_printf(&cmd, "knob -i -v ax %lf ay %lf\n",
		    dy * 0.25, dx * 0.25);

    break;
d281 1
a281 5
    fx = dx / (fastf_t)dmp->dm_width * 2.0;
    fy = -dy / (fastf_t)dmp->dm_height / dmp->dm_aspect * 2.0;
      
    if((state == ST_S_EDIT || state == ST_O_EDIT) &&
       mged_variables->mv_transform == 'e'){
d287 42
a328 4
      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_TRAN)
	  es_edflag = STRANS;
d330 17
a346 30
	save_edflag = edobj;
	edobj = BE_O_XY;
      }

      if(mged_variables->mv_rateknobs)
	bu_vls_printf(&cmd, "knob -i X %lf Y %lf\n", fx, fy);
      else{
	if(grid_state->gr_snap){
	  point_t view_pt;
	  point_t model_pt;
	  point_t vcenter, diff;

	  /* accumulate distance mouse moved since starting to translate */
	  dml_mouse_dx += dx;
	  dml_mouse_dy += dy;

	  view_pt[X] = dml_mouse_dx / (fastf_t)dmp->dm_width * 2.0;
	  view_pt[Y] = -dml_mouse_dy / (fastf_t)dmp->dm_height / dmp->dm_aspect * 2.0;
	  view_pt[Z] = 0.0;
	  round_to_grid(&view_pt[X], &view_pt[Y]);

	  MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
	  MAT_DELTAS_GET_NEG(vcenter, view_state->vs_toViewcenter);
	  VSUB2(diff, model_pt, vcenter);
	  VSCALE(diff, diff, base2local);
	  VADD2(model_pt, dml_work_pt, diff);
	  bu_vls_printf(&cmd, "p %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
	}else
	  bu_vls_printf(&cmd, "knob -i aX %lf aY %lf\n",
			fx*view_state->vs_Viewscale*base2local, fy*view_state->vs_Viewscale*base2local);
a353 20

    /* otherwise, drag to translate the view */
    if(mged_variables->mv_rateknobs)
      bu_vls_printf( &cmd, "knob -i -v X %lf Y %lf\n", fx, fy );
    else{
      if(grid_state->gr_snap){
	/* accumulate distance mouse moved since starting to translate */
	dml_mouse_dx += dx;
	dml_mouse_dy += dy;

	snap_view_to_grid(dml_mouse_dx / (fastf_t)dmp->dm_width * 2.0,
			  -dml_mouse_dy / (fastf_t)dmp->dm_height / dmp->dm_aspect * 2.0);

	goto handled;
      }else
	bu_vls_printf( &cmd, "knob -i -v aX %lf aY %lf\n",
		       fx*view_state->vs_Viewscale*base2local, fy*view_state->vs_Viewscale*base2local );
    }

    break;
@


1.9
log
@*- replace some literals with macros
@
text
@d41 4
a44 1
extern int doMotion;	/* defined in dm-generic.c */
d124 1
d215 1
a215 1
    else if(rubber_band_active){
d219 1
a219 1
      if(mged_variables->grid_snap)
d222 2
a223 2
      rect_width = x - rect_x;
      rect_height = y - rect_y;
d225 3
a227 1
      dirty = 1;
d241 1
a241 1
       mged_variables->transform == 'e'){
d244 2
a245 2
      save_coords = mged_variables->coords;
      mged_variables->coords = 'v';
d256 1
a256 1
      if(mged_variables->rateknobs)
d264 1
a264 1
      mged_variables->coords = save_coords;
d269 1
a269 1
    if(mged_variables->rateknobs)
d283 1
a283 1
       mged_variables->transform == 'e'){
d286 2
a287 2
      save_coords = mged_variables->coords;
      mged_variables->coords = 'v';
d298 1
a298 1
      if(mged_variables->rateknobs)
d301 1
a301 1
	if(mged_variables->grid_snap){
d315 2
a316 2
	  MAT4X3PNT(model_pt, view2model, view_pt);
	  MAT_DELTAS_GET_NEG(vcenter, toViewcenter);
d323 1
a323 1
			fx*Viewscale*base2local, fy*Viewscale*base2local);
d327 1
a327 1
      mged_variables->coords = save_coords;
d333 1
a333 1
    if(mged_variables->rateknobs)
d336 1
a336 1
      if(mged_variables->grid_snap){
d347 1
a347 1
		       fx*Viewscale*base2local, fy*Viewscale*base2local );
d353 1
a353 1
       mged_variables->transform == 'e'){
d368 1
a368 1
    if(mged_variables->rateknobs)
d375 2
a376 2
    fx = dm_Xx2Normal(dmp, mx) * GED_MAX - dv_xadc;
    fy = dm_Xy2Normal(dmp, my, 1) * GED_MAX - dv_yadc;
d381 2
a382 2
    fx = dm_Xx2Normal(dmp, mx) * GED_MAX - dv_xadc;
    fy = dm_Xy2Normal(dmp, my, 1) * GED_MAX - dv_yadc;
d393 1
a393 1
      if(mged_variables->grid_snap)
d396 1
a396 1
      MAT4X3PNT(model_pt, view2model, view_pt);
d403 2
a404 2
    fx = (dm_Xx2Normal(dmp, mx) * GED_MAX - dv_xadc) * Viewscale * base2local * INV_GED;
    fy = (dm_Xy2Normal(dmp, my, 1) * GED_MAX - dv_yadc) * Viewscale * base2local * INV_GED;
d411 1
a411 1
       mged_variables->transform == 'e'){
d427 1
a427 1
    if(mged_variables->rateknobs)
d436 1
a436 1
       mged_variables->transform == 'e'){
d452 1
a452 1
    if(mged_variables->rateknobs)
d461 1
a461 1
       mged_variables->transform == 'e'){
d477 1
a477 1
    if(mged_variables->rateknobs)
d486 1
a486 1
       mged_variables->transform == 'e'){
d502 1
a502 1
    if(mged_variables->rateknobs)
d505 1
a505 1
      bu_vls_printf( &cmd, "knob -i aX %f\n", f*Viewscale*base2local);
d510 1
a510 1
       mged_variables->transform == 'e'){
d526 1
a526 1
    if(mged_variables->rateknobs)
d529 1
a529 1
      bu_vls_printf( &cmd, "knob -i aY %f\n", f*Viewscale*base2local);
d534 1
a534 1
       mged_variables->transform == 'e'){
d550 1
a550 1
    if(mged_variables->rateknobs)
d553 1
a553 1
      bu_vls_printf( &cmd, "knob -i aZ %f\n", f*Viewscale*base2local);
d558 1
a558 1
       mged_variables->transform == 'e'){
d574 1
a574 1
    if(mged_variables->rateknobs)
d582 1
a582 1
       mged_variables->transform == 'e'){
d598 1
a598 1
    if(mged_variables->rateknobs)
d606 1
a606 1
       mged_variables->transform == 'e'){
d622 1
a622 1
    if(mged_variables->rateknobs)
d635 1
a635 1
		   f / (fastf_t)dmp->dm_width * 4095.0 );
d644 1
a644 1
		   f / (fastf_t)dmp->dm_height * 4095.0 );
d671 1
a671 1
		   f / (fastf_t)dmp->dm_width * 4095.0 );
d703 1
a703 1
    common_dbtext((adc_draw ? kn1_knobs:kn2_knobs)[dmep->first_axis]);
d711 1
a711 1
    if(adc_draw){
d714 1
a714 1
	 !dv_1adc )
d719 1
a719 1
	  dm_unlimit(dv_1adc) + dmep->axis_data[0] - knob_values[dmep->first_axis];
d725 2
a726 2
      if(mged_variables->rateknobs){
	f = rate_model_rotate[Z];
d740 1
a740 1
	f = absolute_model_rotate[Z];
d757 2
a758 2
    if(mged_variables->rateknobs){
      if(EDIT_SCALE && mged_variables->transform == 'e')
d761 1
a761 1
	f = rate_scale;
d774 1
a774 1
      if(EDIT_SCALE && mged_variables->transform == 'e')
d777 1
a777 1
	f = absolute_scale;
d793 1
a793 1
    if(adc_draw){
d796 1
a796 1
	 !dv_2adc )
d801 1
a801 1
	  dm_unlimit(dv_2adc) + dmep->axis_data[0] - knob_values[dmep->first_axis];
d807 1
a807 1
      if(mged_variables->rateknobs){
d809 2
a810 2
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->coords){
d831 2
a832 2
	}else if(mged_variables->coords == 'm')
	  f = rate_model_rotate[Z];
d834 1
a834 1
	  f = rate_rotate[Z];
d849 2
a850 2
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->coords){
d871 2
a872 2
	}else if(mged_variables->coords == 'm')
	  f = absolute_model_rotate[Z];
d874 1
a874 1
	  f = absolute_rotate[Z];
d891 1
a891 1
    if(adc_draw){
d894 1
a894 1
	 !dv_distadc)
d899 1
a899 1
	  dm_unlimit(dv_distadc) + dmep->axis_data[0] - knob_values[dmep->first_axis];
d904 1
a904 1
      if(mged_variables->rateknobs){
d906 2
a907 2
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->coords){
d926 2
a927 2
	}else if(mged_variables->coords == 'm')
	  f = rate_model_tran[Z];
d929 1
a929 1
	  f = rate_tran[Z];
d944 2
a945 2
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->coords){
d964 2
a965 2
	}else if(mged_variables->coords == 'm')
	  f = absolute_model_tran[Z];
d967 1
a967 1
	  f = absolute_tran[Z];
d980 1
a980 1
	bu_vls_printf(&cmd, "knob aZ %f\n", setting / 512.0 * Viewscale * base2local);
d985 1
a985 1
    if(adc_draw){
d988 1
a988 1
	 !dv_yadc)
d993 1
a993 1
	  dm_unlimit(dv_yadc) + dmep->axis_data[0] - knob_values[dmep->first_axis];
d998 1
a998 1
      if(mged_variables->rateknobs){
d1000 2
a1001 2
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->coords){
d1022 2
a1023 2
	}else if(mged_variables->coords == 'm')
	  f = rate_model_rotate[Y];
d1025 1
a1025 1
	  f = rate_rotate[Y];
d1040 2
a1041 2
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->coords){
d1062 2
a1063 2
	}else if(mged_variables->coords == 'm')
	  f = absolute_model_rotate[Y];
d1065 1
a1065 1
	  f = absolute_rotate[Y];
d1083 1
a1083 1
    if(mged_variables->rateknobs){
d1085 2
a1086 2
	 && mged_variables->transform == 'e'){
	switch(mged_variables->coords){
d1105 2
a1106 2
      }else if(mged_variables->coords == 'm')
	f = rate_model_tran[Y];
d1108 1
a1108 1
	f = rate_tran[Y];
d1123 2
a1124 2
	 && mged_variables->transform == 'e'){
	switch(mged_variables->coords){
d1143 2
a1144 2
      }else if(mged_variables->coords == 'm')
	f = absolute_model_tran[Y];
d1146 1
a1146 1
	f = absolute_tran[Y];
d1159 1
a1159 1
      bu_vls_printf(&cmd, "knob aY %f\n", setting / 512.0 * Viewscale * base2local);
d1163 1
a1163 1
    if(adc_draw){
d1166 1
a1166 1
	 !dv_xadc)
d1171 1
a1171 1
	  dm_unlimit(dv_xadc) + dmep->axis_data[0] - knob_values[dmep->first_axis];
d1176 1
a1176 1
      if(mged_variables->rateknobs){
d1178 2
a1179 2
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->coords){
d1200 2
a1201 2
	}else if(mged_variables->coords == 'm')
	  f = rate_model_rotate[X];
d1203 1
a1203 1
	  f = rate_rotate[X];
d1218 2
a1219 2
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->coords){
d1240 2
a1241 2
	}else if(mged_variables->coords == 'm')
	  f = absolute_model_rotate[X];
d1243 1
a1243 1
	  f = absolute_rotate[X];
d1260 1
a1260 1
    if(mged_variables->rateknobs){
d1262 2
a1263 2
	 && mged_variables->transform == 'e'){
	switch(mged_variables->coords){
d1282 2
a1283 2
      }else if(mged_variables->coords == 'm')
	f = rate_model_tran[X];
d1285 1
a1285 1
	f = rate_tran[X];
d1300 2
a1301 2
	 && mged_variables->transform == 'e'){
	switch(mged_variables->coords){
d1320 2
a1321 2
      }else if(mged_variables->coords == 'm')
	f = absolute_model_tran[X];
d1323 1
a1323 1
	f = absolute_tran[X];
d1335 1
a1335 1
      bu_vls_printf(&cmd, "knob aX %f\n", setting / 512.0 * Viewscale * base2local);
@


1.8
log
@*- mods to motion_event_handler() to use snap_to_grid() as
	appropriate for drawing the rectangle and for ADC translation.
@
text
@d209 2
a210 2
		     (int)(dm_Xx2Normal(dmp, mx) * 2047.0),
		     (int)(dm_Xy2Normal(dmp, my, 0) * 2047.0) );
d227 2
a228 2
		     (int)(dm_Xx2Normal(dmp, mx) * 2047.0),
		     (int)(dm_Xy2Normal(dmp, my, 1) * 2047.0) );
d369 2
a370 2
    fx = dm_Xx2Normal(dmp, mx) * 2047.0 - dv_xadc;
    fy = dm_Xy2Normal(dmp, my, 1) * 2047.0 - dv_yadc;
d375 2
a376 2
    fx = dm_Xx2Normal(dmp, mx) * 2047.0 - dv_xadc;
    fy = dm_Xy2Normal(dmp, my, 1) * 2047.0 - dv_yadc;
d397 2
a398 2
    fx = (dm_Xx2Normal(dmp, mx) * 2047.0 - dv_xadc) * Viewscale * base2local / 2047.0;
    fy = (dm_Xy2Normal(dmp, my, 1) * 2047.0 - dv_yadc) * Viewscale * base2local / 2047.0;
d717 1
a717 1
		     45.0 - 45.0*((double)setting)/2047.0);
d799 1
a799 1
		     45.0 - 45.0*((double)setting)/2047.0);
@


1.7
log
@*- remove the following ifdefs:
	USE_FRAMEBUFFER, DO_SNAP_TO_GRID, DO_RUBBER_BAND, USE_RT_ASPECT
@
text
@d215 3
d386 4
@


1.6
log
@*- remove forward_key(), no longer a need
@
text
@a122 1
#ifdef USE_FRAMEBUFFER
a124 1
#endif
a207 1
#ifdef USE_RT_ASPECT
a210 5
#else
      bu_vls_printf( &cmd, "M 1 %d %d\n",
		     (int)(dm_Xx2Normal(dmp, mx, 0) * 2047.0),
		     (int)(dm_Xy2Normal(dmp, my) * 2047.0) );
#endif
a211 1
#ifdef USE_RT_ASPECT
a213 4
#else
      fastf_t x = dm_Xx2Normal(dmp, mx, 1);
      fastf_t y = dm_Xy2Normal(dmp, my);
#endif
a222 1
#ifdef USE_RT_ASPECT
a225 5
#else
      bu_vls_printf( &cmd, "M 0 %d %d\n",
		     (int)(dm_Xx2Normal(dmp, mx, 1) * 2047.0),
		     (int)(dm_Xy2Normal(dmp, my) * 2047.0) );
#endif
a269 1
#ifdef USE_RT_ASPECT
a271 4
#else
    fx = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
    fy = -dy / (fastf_t)dmp->dm_height * 2.0;
#endif
a300 1
#ifdef USE_RT_ASPECT
a302 4
#else
	  view_pt[X] = dml_mouse_dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
	  view_pt[Y] = -dml_mouse_dy / (fastf_t)dmp->dm_height * 2.0;
#endif
a331 1
#ifdef USE_RT_ASPECT
a333 4
#else
	snap_view_to_grid(dml_mouse_dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0,
			  -dml_mouse_dy / (fastf_t)dmp->dm_height * 2.0);
#endif
a365 1
#ifdef USE_RT_ASPECT
a367 4
#else
    fx = dm_Xx2Normal(dmp, mx, 1) * 2047.0 - dv_xadc;
    fy = dm_Xy2Normal(dmp, my) * 2047.0 - dv_yadc;
#endif
a371 1
#ifdef USE_RT_ASPECT
a373 4
#else
    fx = dm_Xx2Normal(dmp, mx, 1) * 2047.0 - dv_xadc;
    fy = dm_Xy2Normal(dmp, my) * 2047.0 - dv_yadc;
#endif
a389 1
#ifdef USE_RT_ASPECT
a391 4
#else
    fx = (dm_Xx2Normal(dmp, mx, 1) * 2047.0 - dv_xadc) * Viewscale * base2local / 2047.0;
    fy = (dm_Xy2Normal(dmp, my) * 2047.0 - dv_yadc) * Viewscale * base2local / 2047.0;
#endif
a483 1
#ifdef USE_RT_ASPECT
a487 6
#else
    if(abs(dx) >= abs(dy))
      f = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
    else
      f = -dy / (fastf_t)dmp->dm_height * 2.0;
#endif
a507 1
#ifdef USE_RT_ASPECT
a511 6
#else
    if(abs(dx) >= abs(dy))
      f = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
    else
      f = -dy / (fastf_t)dmp->dm_height * 2.0;
#endif
a531 1
#ifdef USE_RT_ASPECT
a535 6
#else
    if(abs(dx) >= abs(dy))
      f = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
    else
      f = -dy / (fastf_t)dmp->dm_height * 2.0;
#endif
a620 1
#ifdef USE_RT_ASPECT
a622 4
#else
    bu_vls_printf( &cmd, "knob -i xadc %f\n",
		   f / (fastf_t)dmp->dm_width / dmp->dm_aspect * 4095.0 );
#endif
a656 1
#ifdef USE_RT_ASPECT
a658 4
#else
    bu_vls_printf( &cmd, "knob -i distadc %f\n",
		   f / (fastf_t)dmp->dm_width / dmp->dm_aspect * 4095.0 );
#endif
@


1.5
log
@mods to doEvent()
@
text
@a45 1
static int forward_key();
d117 1
a117 4
  /* Forward key events to a command window */
  if(mged_variables->send_key && eventPtr->type == KeyPress)
    status = forward_key((XKeyEvent *)eventPtr);
  else if(eventPtr->type == ConfigureNotify){
a1460 23

/* Forward key events to a command window */
static int
forward_key(xkey)
XKeyEvent *xkey;
{
  char buffer[2];
  KeySym keysym;
  struct dm_char_queue *dcqp;

  XLookupString(xkey, buffer, 1, &keysym, (XComposeStatus *)NULL);

  if(keysym == mged_variables->hot_key)
    return TCL_OK;

  BU_GETSTRUCT(dcqp, dm_char_queue);
  dcqp->dlp = curr_dm_list;
  BU_LIST_INSERT(&head_dm_char_queue.l, &dcqp->l);
  write(dm_pipe[1], buffer, 1);

  /* Use this so that these events won't propagate */
  return TCL_RETURN;
}
@


1.4
log
@adc variables are no longer mged_variables
@
text
@d149 1
a149 1
  }else
d151 1
a151 1
  if(eventPtr->type == ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devmotionnotify){
d156 1
a156 1
  }else
d159 1
a159 1
  if(eventPtr->type == ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonpress){
d169 1
a169 1
  }else
a170 18
  if(eventPtr->type == KeyPress){
    /*XXX Hack to prevent Tk from choking on certain control sequences */
    if(eventPtr->xkey.state & ControlMask){
      char buffer[1];
      KeySym keysym;

      XLookupString(&(eventPtr->xkey), buffer, 1,
		    &keysym, (XComposeStatus *)NULL);

      if(keysym == XK_c || keysym == XK_t || keysym == XK_v ||
	 keysym == XK_w || keysym == XK_x || keysym == XK_y)
	/* no further processing of this event */
	status = TCL_RETURN;
    }

    /* allow further processing of this event */
    status = TCL_OK;
  }
@


1.3
log
@*- mods to use rt's notion of aspect ratio (i.e. width/height)
@
text
@d792 1
a792 1
    common_dbtext((mged_variables->adcflag ? kn1_knobs:kn2_knobs)[dmep->first_axis]);
d800 1
a800 1
    if(mged_variables->adcflag){
d882 1
a882 1
    if(mged_variables->adcflag){
d980 1
a980 1
    if(mged_variables->adcflag){
d1074 1
a1074 1
    if(mged_variables->adcflag){
d1252 1
a1252 1
    if(mged_variables->adcflag){
@


1.2
log
@*- mods to doEvent()
*- added set_knob_offset(), common_dbtext(), motion_event_handler(),
	dials_event_handler(), buttons_event_handler() and forward_key()
@
text
@d232 1
d234 4
d240 1
d242 4
d248 1
d258 5
d266 1
d311 4
d317 1
d347 4
d353 1
d383 4
d389 1
d422 4
d428 2
a429 1
    bu_vls_printf(&cmd, "adc a1 %lf\n", DEGRAD*atan2(fy, fx));
d433 4
d439 2
a440 1
    bu_vls_printf(&cmd, "adc a2 %lf\n", DEGRAD*atan2(fy, fx));
d444 9
a452 3
    bu_vls_printf(&cmd, "adc hv %lf %lf\n",
		  dm_Xx2Normal(dmp, mx, 1) * Viewscale * base2local,
		  dm_Xy2Normal(dmp, my) * Viewscale * base2local);
d456 4
d462 1
d555 1
d557 5
d565 1
d586 6
d596 1
d617 6
d627 1
d713 1
d715 3
d719 1
d754 4
d760 1
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * An event handler for MGED.
d9 5
a13 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1988 by the United States Army.
 *	All rights reserved.
d17 4
d22 8
d34 4
d39 8
d48 39
d109 81
d191 411
d603 818
a1420 1
  return status;
@
