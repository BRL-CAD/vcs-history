head	1.33;
access;
symbols
	ansi-20040405-merged:1.29.2.2
	postmerge-20040405-ansi:1.31
	premerge-20040404-ansi:1.30
	postmerge-autoconf:1.30
	autoconf-freeze:1.29.10.2
	premerge-autoconf:1.30
	postmerge-20040315-windows:1.30
	premerge-20040315-windows:1.30
	windows-20040315-freeze:1.29.4.1
	autoconf-20031203:1.29
	autoconf-20031202:1.29
	autoconf-branch:1.29.0.10
	phong-branch:1.29.0.8
	photonmap-branch:1.29.0.6
	rel-6-1-DP:1.29
	windows-branch:1.29.0.4
	rel-6-0-2:1.27
	ansi-branch:1.29.0.2
	rel-6-0-1-branch:1.27.0.2
	hartley-6-0-post:1.28
	hartley-6-0-pre:1.27
	rel-6-0-1:1.27
	rel-6-0:1.27
	rel-5-4:1.22
	offsite-5-3-pre:1.24
	rel-5-3:1.22
	rel-5-2:1.22
	rel-5-1-branch:1.22.0.2
	rel-5-1:1.22
	rel-5-0:1.22
	rel-5-0-beta:1.22
	rel-4-5:1.20
	ctj-4-5-post:1.20
	ctj-4-5-pre:1.20;
locks; strict;
comment	@ * @;


1.33
date	2004.05.21.17.47.41;	author morrison;	state dead;
branches;
next	1.32;

1.32
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.02.17.39.32;	author morrison;	state Exp;
branches;
next	1.29;

1.29
date	2002.08.20.17.08.23;	author jra;	state Exp;
branches
	1.29.2.1
	1.29.4.1
	1.29.10.1;
next	1.28;

1.28
date	2002.08.15.20.55.34;	author hartley;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.05.15.51.41;	author bparker;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.01.19.23.24;	author bparker;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.16.21.38.08;	author morrison;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.24.19.05.06;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.25.18.40.25;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	98.11.06.22.32.40;	author bparker;	state Exp;
branches;
next	1.21;

1.21
date	98.06.11.19.41.42;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	97.04.23.18.30.43;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	97.02.28.21.31.37;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	96.11.19.20.31.16;	author jra;	state Exp;
branches;
next	1.16;

1.16
date	96.10.04.15.02.44;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	96.09.25.20.10.14;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	96.09.23.18.29.33;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	96.04.18.20.26.00;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	95.08.29.13.03.40;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	95.08.03.14.42.29;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	95.07.28.20.31.52;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	95.07.21.20.37.25;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	95.07.20.22.37.29;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	95.07.18.22.53.50;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	95.07.17.20.17.49;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	95.07.14.19.08.08;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	95.07.14.14.54.31;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	95.07.12.12.52.59;	author jra;	state Exp;
branches;
next	;

1.29.2.1
date	2002.09.19.18.02.01;	author morrison;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2004.03.17.21.21.57;	author morrison;	state Exp;
branches;
next	;

1.29.4.1
date	2004.03.11.23.46.34;	author morrison;	state Exp;
branches;
next	;

1.29.10.1
date	2004.02.12.18.34.14;	author erikg;	state Exp;
branches;
next	1.29.10.2;

1.29.10.2
date	2004.03.15.14.07.37;	author erikg;	state Exp;
branches;
next	;


desc
@Pipe editing routines.
@


1.33
log
@moved to src/mged/
@
text
@/*
 *			E D P I P E . C
 *
 * Functions -
 *	split_pipept - split a pipe segment at a given point
 *	find_pipept_nearest_pt - find which segment of a pipe is nearest
 *			the ray from "pt" in the viewing direction (for segment selection in MGED)
 *
 *  Author -
 *	John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/edpipe.c,v 1.32 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
	
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "rtgeom.h"
#include "wdb.h"

#include "./ged.h"
#include "./mged_solid.h"
#include "./sedit.h"
#include "./mged_dm.h"

extern struct bn_tol		mged_tol;	/* from ged.c */

void
split_pipept(struct bu_list *pipe_hd, struct wdb_pipept *ps, fastf_t *new_pt)
{
}

void
pipe_scale_od( struct rt_db_internal *db_int, fastf_t scale)
{
	struct wdb_pipept *ps;
	struct rt_pipe_internal *pipe=(struct rt_pipe_internal *)db_int->idb_ptr;

	RT_PIPE_CK_MAGIC( pipe );

	/* check that this can be done */
	for( BU_LIST_FOR( ps, wdb_pipept, &pipe->pipe_segs_head ) )
	{
		fastf_t tmp_od;

		if( scale < 0.0 )
			tmp_od = (-scale );
		else
			tmp_od = ps->pp_od*scale;
		if( ps->pp_id > tmp_od )
		{
		  Tcl_AppendResult(interp, "Cannot make OD less than ID\n", (char *)NULL);
		  return;
		}
		if( tmp_od > 2.0*ps->pp_bendradius )
		{
		  Tcl_AppendResult(interp, "Cannot make outer radius greater than bend radius\n", (char *)NULL);
		  return;
		}
	}

	for( BU_LIST_FOR( ps, wdb_pipept, &pipe->pipe_segs_head ) )
		ps->pp_od *= scale;
}

void
pipe_scale_id( struct rt_db_internal *db_int, fastf_t scale )
{
	struct wdb_pipept *ps;
	struct rt_pipe_internal *pipe=(struct rt_pipe_internal *)db_int->idb_ptr;
	fastf_t tmp_id;

	RT_PIPE_CK_MAGIC( pipe );

	/* check that this can be done */
	for( BU_LIST_FOR( ps, wdb_pipept, &pipe->pipe_segs_head ) )
	{
		if( scale > 0.0 )
			tmp_id = ps->pp_id*scale;
		else
			tmp_id = (-scale);
		if( ps->pp_od < tmp_id )
		{
		  Tcl_AppendResult(interp, "Cannot make ID greater than OD\n", (char *)NULL);
		  return;
		}
		if( tmp_id > 2.0*ps->pp_bendradius )
		{
		  Tcl_AppendResult(interp, "Cannot make inner radius greater than bend radius\n", (char *)NULL);
		  return;
		}
	}

	for( BU_LIST_FOR( ps, wdb_pipept, &pipe->pipe_segs_head ) )
	{
		if( scale > 0.0 )
			ps->pp_id *= scale;
		else
			ps->pp_id = (-scale);
	}
}

void
pipe_seg_scale_od( struct wdb_pipept *ps, fastf_t scale )
{
	fastf_t tmp_od;

	BU_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );

	/* need to check that the new OD is not less than ID
	 * of any affected segment.
	 */
	if( scale < 0.0 )
		tmp_od = (-scale);
	else
		tmp_od = scale*ps->pp_od;
	if( ps->pp_id > tmp_od )
	{
	  Tcl_AppendResult(interp, "Cannot make OD smaller than ID\n", (char *)NULL);
	  return;
	}
	if( tmp_od > 2.0*ps->pp_bendradius )
	{
	  Tcl_AppendResult(interp, "Cannot make outer radius greater than bend radius\n", (char *)NULL);
	  return;
	}

	if( scale > 0.0 )
		ps->pp_od *= scale;
	else
		ps->pp_od = (-scale);
}

void
pipe_seg_scale_id( struct wdb_pipept *ps, fastf_t scale )
{
	fastf_t tmp_id;

	BU_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );

	/* need to check that the new ID is not greater than OD */
	if( scale > 0.0 )
		tmp_id = scale*ps->pp_id;
	else
		tmp_id = (-scale);
	if( ps->pp_od < tmp_id )
	{
	  Tcl_AppendResult(interp, "Cannot make ID greater than OD\n", (char *)NULL);
	  return;
	}
	if( tmp_id > 2.0*ps->pp_bendradius )
	{
	  Tcl_AppendResult(interp, "Cannot make inner radius greater than bend radius\n", (char *)NULL);
	  return;
	}

	if( scale > 0.0 )
		ps->pp_id *= scale;
	else
		ps->pp_id = (-scale);
}

void
pipe_seg_scale_radius( struct wdb_pipept *ps, fastf_t scale )
{
	fastf_t old_radius;
	struct wdb_pipept *head;

	BU_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe point" );

	head = ps;
	while( head->l.magic != BU_LIST_HEAD_MAGIC )
		head = BU_LIST_NEXT( wdb_pipept, &head->l );

	/* make sure we can make this change */
	old_radius = ps->pp_bendradius;
	if( scale > 0.0 )
		ps->pp_bendradius *= scale;
	else
		ps->pp_bendradius = (-scale);

	if( ps->pp_bendradius < ps->pp_od * 0.5 )
	{
	  Tcl_AppendResult(interp, "Cannot make bend radius less than pipe outer radius\n", (char *)NULL);
	  ps->pp_bendradius = old_radius;
	  return;
	}

	if( rt_pipe_ck( &head->l ) )
	{
		/* won't work, go back to original radius */
		ps->pp_bendradius = old_radius;
		return;
	}

}

void
pipe_scale_radius( struct rt_db_internal *db_int, fastf_t scale )
{
	struct bu_list head;
	struct wdb_pipept *old_ps,*new_ps;
	struct rt_pipe_internal *pipe=(struct rt_pipe_internal *)db_int->idb_ptr;

	RT_CK_DB_INTERNAL( db_int );
	RT_PIPE_CK_MAGIC( pipe );

	/* make a quick check for minimum bend radius */
	for( BU_LIST_FOR( old_ps, wdb_pipept, &pipe->pipe_segs_head ) )
	{
		if( scale < 0.0 )
		{
			if( (-scale) < old_ps->pp_od * 0.5 )
			{
			  Tcl_AppendResult(interp, "Cannot make bend radius less than pipe outer radius\n", (char *)NULL);
			  return;
			}
		}
		else
		{
			if( old_ps->pp_bendradius * scale < old_ps->pp_od * 0.5 )
			{
			  Tcl_AppendResult(interp, "Cannot make bend radius less than pipe outer radius\n", (char *)NULL);
			  return;
			}
		}
	}

	/* make temporary copy of this pipe solid */
	BU_LIST_INIT( &head );
	for( BU_LIST_FOR( old_ps, wdb_pipept, &pipe->pipe_segs_head ) )
	{
		BU_GETSTRUCT( new_ps, wdb_pipept );
		*new_ps = (*old_ps);
		BU_LIST_APPEND( &head, &new_ps->l );
	}

	/* make the desired editing changes to the copy */
	for( BU_LIST_FOR( new_ps, wdb_pipept, &head ) )
	{
		if( scale < 0.0 )
			new_ps->pp_bendradius = (-scale);
		else
			new_ps->pp_bendradius *= scale;
	}

	/* check if the copy is O.K. */
	if( rt_pipe_ck( &head ) )
	{
		/* won't work, go back to original */
		while( BU_LIST_NON_EMPTY( &head ) )
		{
			new_ps = BU_LIST_FIRST( wdb_pipept, &head );
			BU_LIST_DEQUEUE( &new_ps->l );
			bu_free( (genptr_t)new_ps, "pipe_scale_radius: new_ps" );
		}
		return;
	}

	/* free temporary pipe solid */
	while( BU_LIST_NON_EMPTY( &head ) )
	{
		new_ps = BU_LIST_FIRST( wdb_pipept, &head );
		BU_LIST_DEQUEUE( &new_ps->l );
		bu_free( (genptr_t)new_ps, "pipe_scale_radius: new_ps" );
	}

	/* make changes to the original */
	for( BU_LIST_FOR( old_ps, wdb_pipept, &pipe->pipe_segs_head ) )
	{
		if( scale < 0.0 )
			old_ps->pp_bendradius = (-scale);
		else
			old_ps->pp_bendradius *= scale;
	}

}


struct wdb_pipept *
find_pipept_nearest_pt( const struct bu_list *pipe_hd, const point_t pt )
{
	struct wdb_pipept *ps;
	struct wdb_pipept *nearest=(struct wdb_pipept *)NULL;
	struct bn_tol tmp_tol;
	fastf_t min_dist = MAX_FASTF;
	vect_t dir,work;

	tmp_tol.magic = BN_TOL_MAGIC;
	tmp_tol.dist = 0.0;
	tmp_tol.dist_sq = tmp_tol.dist * tmp_tol.dist;
	tmp_tol.perp = 0.0;
	tmp_tol.para = 1.0 - tmp_tol.perp;

	/* get a direction vector in model space corresponding to z-direction in view */
	VSET( work, 0.0, 0.0, 1.0 )
	MAT4X3VEC(dir, view_state->vs_vop->vo_view2model, work)

	for( BU_LIST_FOR( ps, wdb_pipept, pipe_hd ) )
	{
		fastf_t dist;

		dist = bn_dist_line3_pt3( pt, dir, ps->pp_coord );
		if( dist < min_dist )
		{
			min_dist = dist;
			nearest = ps;
		}
	}
	return( nearest );
}

struct wdb_pipept *
add_pipept( struct rt_pipe_internal *pipe, struct wdb_pipept *pp, const point_t new_pt )
{
	struct wdb_pipept *last;
	struct wdb_pipept *new;

	RT_PIPE_CK_MAGIC( pipe );
	if( pp )
		BU_CKMAG( pp, WDB_PIPESEG_MAGIC, "pipe point" );

	if( pp )
		last = pp;
	else
	{
		/* add new point to end of pipe solid */
		last = BU_LIST_LAST( wdb_pipept, &pipe->pipe_segs_head );
		if( last->l.magic == BU_LIST_HEAD_MAGIC )
		{
			BU_GETSTRUCT( new, wdb_pipept );
			new->l.magic = WDB_PIPESEG_MAGIC;
			new->pp_od = 30.0;
			new->pp_id = 0.0;
			new->pp_bendradius = 40.0;
			VMOVE( new->pp_coord, new_pt );
			BU_LIST_INSERT( &pipe->pipe_segs_head, &new->l );
			return( new );
		}
	}

	/* build new point */
	BU_GETSTRUCT( new, wdb_pipept );
	new->l.magic = WDB_PIPESEG_MAGIC;
	new->pp_od = last->pp_od;
	new->pp_id = last->pp_id;
	new->pp_bendradius = last->pp_bendradius;
	VMOVE( new->pp_coord, new_pt );

	if( !pp )	/* add to end of pipe solid */
		BU_LIST_INSERT( &pipe->pipe_segs_head, &new->l )
	else		/* append after current point */
		BU_LIST_APPEND( &pp->l, &new->l )

	if( rt_pipe_ck( &pipe->pipe_segs_head ) )
	{
		/* won't work here, so refuse to do it */
		BU_LIST_DEQUEUE( &new->l );
		bu_free( (genptr_t)new, "add_pipept: new " );
		return( pp );
	}
	else
		return( new );
}


void
ins_pipept( struct rt_pipe_internal *pipe, struct wdb_pipept *pp, const point_t new_pt )
{
	struct wdb_pipept *first;
	struct wdb_pipept *new;

	RT_PIPE_CK_MAGIC( pipe );
	if( pp )
		BU_CKMAG( pp, WDB_PIPESEG_MAGIC, "pipe point" );

	if( pp )
		first = pp;
	else
	{
		/* insert new point at start of pipe solid */
		first = BU_LIST_FIRST( wdb_pipept, &pipe->pipe_segs_head );
		if( first->l.magic == BU_LIST_HEAD_MAGIC )
		{
			BU_GETSTRUCT( new, wdb_pipept );
			new->l.magic = WDB_PIPESEG_MAGIC;
			new->pp_od = 30.0;
			new->pp_id = 0.0;
			new->pp_bendradius = 40.0;
			VMOVE( new->pp_coord, new_pt );
			BU_LIST_APPEND( &pipe->pipe_segs_head, &new->l );
			return;
		}
	}

	/* build new point */
	BU_GETSTRUCT( new, wdb_pipept );
	new->l.magic = WDB_PIPESEG_MAGIC;
	new->pp_od = first->pp_od;
	new->pp_id = first->pp_id;
	new->pp_bendradius = first->pp_bendradius;
	VMOVE( new->pp_coord, new_pt );

	if( !pp )	/* add to start of pipe */
		BU_LIST_APPEND( &pipe->pipe_segs_head, &new->l )
	else		/* insert before current point */
		BU_LIST_INSERT( &pp->l, &new->l )

	if( rt_pipe_ck( &pipe->pipe_segs_head ) )
	{
		/* won't work here, so refuse to do it */
		BU_LIST_DEQUEUE( &new->l );
		bu_free( (genptr_t)new, "ins_pipept: new " );
	}
}

struct wdb_pipept *
del_pipept( struct wdb_pipept *ps )
{
	struct wdb_pipept *next;
	struct wdb_pipept *prev;
	struct wdb_pipept *head;

	BU_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );

	head = ps;
	while( head->l.magic != BU_LIST_HEAD_MAGIC )
		head = BU_LIST_NEXT( wdb_pipept, &head->l );

	next = BU_LIST_NEXT( wdb_pipept, &ps->l );
	if( next->l.magic == BU_LIST_HEAD_MAGIC )
		next = (struct wdb_pipept *)NULL;

	prev = BU_LIST_PREV( wdb_pipept, &ps->l );
	if( prev->l.magic == BU_LIST_HEAD_MAGIC )
		prev = (struct wdb_pipept *)NULL;

	if( !prev && !next )
	{
	  Tcl_AppendResult(interp, "Cannot delete last point in pipe\n", (char *)NULL);
	  return( ps );
	}

	BU_LIST_DEQUEUE( &ps->l );

	if( rt_pipe_ck( &head->l ) )
	{
	  Tcl_AppendResult(interp, "Cannot delete this point, it will result in an illegal pipe\n", (char *)NULL);
		if( next )
			BU_LIST_INSERT( &next->l, &ps->l )
		else if( prev )
			BU_LIST_APPEND( &prev->l, &ps->l )
		else
			BU_LIST_INSERT( &head->l, &ps->l )

		return( ps );
	}
	else
		bu_free( (genptr_t)ps, "del_pipept: ps" );

	if( prev )
		return( prev );
	else
		return( next );

}

void
move_pipept( struct rt_pipe_internal *pipe, struct wdb_pipept *ps, const point_t new_pt )
{
	point_t old_pt;

	RT_PIPE_CK_MAGIC( pipe );
	BU_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );

	VMOVE( old_pt, ps->pp_coord );

	VMOVE( ps->pp_coord, new_pt );
	if( rt_pipe_ck( &pipe->pipe_segs_head ) )
	{
	  Tcl_AppendResult(interp, "Cannot move point there\n", (char *)NULL);
	  VMOVE( ps->pp_coord, old_pt );
	}
}
@


1.32
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/edpipe.c,v 1.31 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


1.31
log
@merge of ansi-6-0-branch into HEAD
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d30 5
a34 1
#include "conf.h"
@


1.30
log
@update copyright to include span through 2003
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edpipe.c,v 1.29 2002/08/20 17:08:23 jra Exp $ (BRL)";
d57 1
a57 4
split_pipept( pipe_hd, ps, new_pt )
struct bu_list *pipe_hd;
struct wdb_pipept *ps;
point_t new_pt;
@


1.29
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1995 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edpipe.c,v 1.27 2001/06/05 15:51:41 bparker Exp $ (BRL)";
@


1.29.4.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/edpipe.c,v 1.30 2004/02/02 17:39:32 morrison Exp $ (BRL)";
@


1.29.10.1
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edpipe.c,v 1.30 2004/02/02 17:39:32 morrison Exp $ (BRL)";
@


1.29.10.2
log
@merge from head
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edpipe.c,v 1.29.10.1 2004/02/12 18:34:14 erikg Exp $ (BRL)";
@


1.29.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edpipe.c,v 1.29 2002/08/20 17:08:23 jra Exp $ (BRL)";
d57 4
a60 1
split_pipept(struct bu_list *pipe_hd, struct wdb_pipept *ps, fastf_t *new_pt)
@


1.29.2.2
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


1.28
log
@Converted from K&R to ANSI C - RFH
@
text
@d57 4
a60 1
split_pipept(struct bu_list *pipe_hd, struct wdb_pipept *ps, fastf_t *new_pt)
@


1.27
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edpipe.c,v 1.26 2001/06/01 19:23:24 bparker Exp $ (BRL)";
d57 1
a57 4
split_pipept( pipe_hd, ps, new_pt )
struct bu_list *pipe_hd;
struct wdb_pipept *ps;
point_t new_pt;
@


1.26
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edpipe.c,v 1.25 2001/05/16 21:38:08 morrison Exp $ (BRL)";
a327 1
#ifdef MGED_USE_VIEW_OBJ
a328 3
#else
	MAT4X3VEC( dir, view_state->vs_view2model, work )
#endif
@


1.25
log
@PRODUCTION optimizations
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edpipe.c,v 1.24 2000/10/24 19:05:06 mike Exp $ (BRL)";
d328 3
d332 1
@


1.24
log
@
Fixed compiler lint, function declarations.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edpipe.c,v 1.23 2000/07/25 18:40:25 mike Exp $ (BRL)";
d352 1
a352 1
		BU_CKMAG( pp, WDB_PIPESEG_MAGIC, "pipe point" )
d406 1
a406 1
		BU_CKMAG( pp, WDB_PIPESEG_MAGIC, "pipe point" )
@


1.23
log
@
libwdb & lint
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edpipe.c,v 1.22 1998/11/06 22:32:40 bparker Exp $ (BRL)";
d55 1
d65 1
a65 3
pipe_scale_od( db_int, scale )
struct rt_db_internal *db_int;
fastf_t scale;
d96 1
d98 1
a98 3
pipe_scale_id( db_int, scale )
struct rt_db_internal *db_int;
fastf_t scale;
d135 1
a135 3
pipe_seg_scale_od( ps, scale )
struct wdb_pipept *ps;
fastf_t scale;
d164 1
d166 1
a166 3
pipe_seg_scale_id( ps, scale )
struct wdb_pipept *ps;
fastf_t scale;
d195 1
a195 3
pipe_seg_scale_radius( ps, scale )
struct wdb_pipept *ps;
fastf_t scale;
d230 1
a230 3
pipe_scale_radius( db_int, scale )
struct rt_db_internal *db_int;
fastf_t scale;
d312 1
a312 3
find_pipept_nearest_pt( pipe_hd, pt )
CONST struct bu_list *pipe_hd;
CONST point_t pt;
d345 1
a345 4
add_pipept( pipe, pp, new_pt )
struct rt_pipe_internal *pipe;
struct wdb_pipept *pp;
CONST point_t new_pt;
d399 1
a399 4
ins_pipept( pipe, pp, new_pt )
struct rt_pipe_internal *pipe;
struct wdb_pipept *pp;
CONST point_t new_pt;
d449 1
a449 2
del_pipept( ps )
struct wdb_pipept *ps;
d500 1
a500 4
move_pipept( pipe, ps, new_pt )
struct rt_pipe_internal *pipe;
struct wdb_pipept *ps;
point_t new_pt;
@


1.22
log
@*- use new structures
*- cleanup
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edpipe.c,v 1.21 1998/06/11 19:41:42 bparker Exp $ (BRL)";
d227 1
a227 1
	if( rt_pipe_ck( head ) )
d495 1
a495 1
	if( rt_pipe_ck( head ) )
@


1.21
log
@*- using floating point literals to initialize floats
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/edpipe.c,v 1.20 1997/04/23 18:30:43 bparker Exp $ (BRL)";
d339 1
a339 1
	MAT4X3VEC( dir, view2model, work )
@


1.20
log
@*** empty log message ***
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.19 1997/02/28 21:31:37 jra Exp bparker $ (BRL)";
d335 1
a335 1
	tmp_tol.para = 1 - tmp_tol.perp;
d338 1
a338 1
	VSET( work, 0, 0, 1 )
@


1.19
log
@removed include of db.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.18 1997/01/02 19:35:05 bparker Exp jra $ (BRL)";
a52 1
#include "./menu.h"
@


1.18
log
@mods to use libbn and libbu
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.17 1996/11/19 20:31:16 jra Exp bparker $ (BRL)";
a42 1
#include "db.h"
@


1.17
log
@Mod to make adding a pipe segment advance es_pipet to new point.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.16 1996/10/04 15:02:44 bparker Exp jra $ (BRL)";
d56 1
a56 1
extern struct rt_tol		mged_tol;	/* from ged.c */
d329 1
a329 1
	struct rt_tol tmp_tol;
d333 1
a333 1
	tmp_tol.magic = RT_TOL_MAGIC;
d347 1
a347 1
		dist = rt_dist_line3_pt3( pt, dir, ps->pp_coord );
@


1.16
log
@cast bu_free's 1st argument to genptr_t
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.15 1996/09/25 20:10:14 bparker Exp bparker $ (BRL)";
d357 1
a357 1
void
d385 1
a385 1
			return;
d407 1
d409 2
@


1.15
log
@include mged_solid.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.14 1996/09/23 18:29:33 bparker Exp bparker $ (BRL)";
d297 1
a297 1
			bu_free( (char *)new_ps, "pipe_scale_radius: new_ps" );
d307 1
a307 1
		bu_free( (char *)new_ps, "pipe_scale_radius: new_ps" );
d406 1
a406 1
		bu_free( (char *)new, "add_pipept: new " );
d460 1
a460 1
		bu_free( (char *)new, "ins_pipept: new " );
d507 1
a507 1
		bu_free( (char *)ps, "del_pipept: ps" );
@


1.14
log
@changed dm.h to mged_dm.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.13 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d51 1
a51 1
#include "./solid.h"
@


1.13
log
@rt_list ---> bu_list
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.12 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d53 1
a53 1
#include "./dm.h"
@


1.12
log
@now using libbu
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.11 1996/04/18 20:26:00 bparker Exp bparker $ (BRL)";
d59 1
a59 1
struct rt_list *pipe_hd;
d76 1
a76 1
	for( RT_LIST_FOR( ps, wdb_pipept, &pipe->pipe_segs_head ) )
d96 1
a96 1
	for( RT_LIST_FOR( ps, wdb_pipept, &pipe->pipe_segs_head ) )
d111 1
a111 1
	for( RT_LIST_FOR( ps, wdb_pipept, &pipe->pipe_segs_head ) )
d129 1
a129 1
	for( RT_LIST_FOR( ps, wdb_pipept, &pipe->pipe_segs_head ) )
d212 2
a213 2
	while( head->l.magic != RT_LIST_HEAD_MAGIC )
		head = RT_LIST_NEXT( wdb_pipept, &head->l );
d243 1
a243 1
	struct rt_list head;
d251 1
a251 1
	for( RT_LIST_FOR( old_ps, wdb_pipept, &pipe->pipe_segs_head ) )
d272 2
a273 2
	RT_LIST_INIT( &head );
	for( RT_LIST_FOR( old_ps, wdb_pipept, &pipe->pipe_segs_head ) )
d277 1
a277 1
		RT_LIST_APPEND( &head, &new_ps->l );
d281 1
a281 1
	for( RT_LIST_FOR( new_ps, wdb_pipept, &head ) )
d293 1
a293 1
		while( RT_LIST_NON_EMPTY( &head ) )
d295 2
a296 2
			new_ps = RT_LIST_FIRST( wdb_pipept, &head );
			RT_LIST_DEQUEUE( &new_ps->l );
d303 1
a303 1
	while( RT_LIST_NON_EMPTY( &head ) )
d305 2
a306 2
		new_ps = RT_LIST_FIRST( wdb_pipept, &head );
		RT_LIST_DEQUEUE( &new_ps->l );
d311 1
a311 1
	for( RT_LIST_FOR( old_ps, wdb_pipept, &pipe->pipe_segs_head ) )
d324 1
a324 1
CONST struct rt_list *pipe_hd;
d343 1
a343 1
	for( RT_LIST_FOR( ps, wdb_pipept, pipe_hd ) )
d375 2
a376 2
		last = RT_LIST_LAST( wdb_pipept, &pipe->pipe_segs_head );
		if( last->l.magic == RT_LIST_HEAD_MAGIC )
d384 1
a384 1
			RT_LIST_INSERT( &pipe->pipe_segs_head, &new->l );
d398 1
a398 1
		RT_LIST_INSERT( &pipe->pipe_segs_head, &new->l )
d400 1
a400 1
		RT_LIST_APPEND( &pp->l, &new->l )
d405 1
a405 1
		RT_LIST_DEQUEUE( &new->l );
d429 2
a430 2
		first = RT_LIST_FIRST( wdb_pipept, &pipe->pipe_segs_head );
		if( first->l.magic == RT_LIST_HEAD_MAGIC )
d438 1
a438 1
			RT_LIST_APPEND( &pipe->pipe_segs_head, &new->l );
d452 1
a452 1
		RT_LIST_APPEND( &pipe->pipe_segs_head, &new->l )
d454 1
a454 1
		RT_LIST_INSERT( &pp->l, &new->l )
d459 1
a459 1
		RT_LIST_DEQUEUE( &new->l );
d475 2
a476 2
	while( head->l.magic != RT_LIST_HEAD_MAGIC )
		head = RT_LIST_NEXT( wdb_pipept, &head->l );
d478 2
a479 2
	next = RT_LIST_NEXT( wdb_pipept, &ps->l );
	if( next->l.magic == RT_LIST_HEAD_MAGIC )
d482 2
a483 2
	prev = RT_LIST_PREV( wdb_pipept, &ps->l );
	if( prev->l.magic == RT_LIST_HEAD_MAGIC )
d492 1
a492 1
	RT_LIST_DEQUEUE( &ps->l );
d498 1
a498 1
			RT_LIST_INSERT( &next->l, &ps->l )
d500 1
a500 1
			RT_LIST_APPEND( &prev->l, &ps->l )
d502 1
a502 1
			RT_LIST_INSERT( &head->l, &ps->l )
@


1.11
log
@convert commands to Tcl
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.10 1995/08/29 13:03:40 jra Exp bparker $ (BRL)";
d145 1
a145 1
	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );
d177 1
a177 1
	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );
d209 1
a209 1
	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe point" );
d275 1
a275 1
		GETSTRUCT( new_ps, wdb_pipept );
d297 1
a297 1
			rt_free( (char *)new_ps, "pipe_scale_radius: new_ps" );
d307 1
a307 1
		rt_free( (char *)new_ps, "pipe_scale_radius: new_ps" );
d368 1
a368 1
		RT_CKMAG( pp, WDB_PIPESEG_MAGIC, "pipe point" )
d378 1
a378 1
			GETSTRUCT( new, wdb_pipept );
d390 1
a390 1
	GETSTRUCT( new, wdb_pipept );
d406 1
a406 1
		rt_free( (char *)new, "add_pipept: new " );
d422 1
a422 1
		RT_CKMAG( pp, WDB_PIPESEG_MAGIC, "pipe point" )
d432 1
a432 1
			GETSTRUCT( new, wdb_pipept );
d444 1
a444 1
	GETSTRUCT( new, wdb_pipept );
d460 1
a460 1
		rt_free( (char *)new, "ins_pipept: new " );
d472 1
a472 1
	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );
d507 1
a507 1
		rt_free( (char *)ps, "del_pipept: ps" );
d525 1
a525 1
	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );
@


1.10
log
@Mods for new pipe solid format.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.9 1995/08/03 14:42:29 jra Exp jra $ (BRL)";
d86 2
a87 2
			rt_log( "Cannot make OD less than ID\n" );
			return;
d91 2
a92 2
			rt_log( "Cannot make outer radius greater than bend radius\n" );
			return;
d119 2
a120 2
			rt_log( "Cannot make ID greater than OD\n" );
			return;
d124 2
a125 2
			rt_log( "Cannot make inner radius greater than bend radius\n" );
			return;
d156 2
a157 2
		rt_log( "Cannot make OD smaller than ID\n" );
		return;
d161 2
a162 2
		rt_log( "Cannot make outer radius greater than bend radius\n" );
		return;
d186 2
a187 2
		rt_log( "Cannot make ID greater than OD\n" );
		return;
d191 2
a192 2
		rt_log( "Cannot make inner radius greater than bend radius\n" );
		return;
d224 3
a226 3
		rt_log( "Cannot make bend radius less than pipe outer radius\n" );
		ps->pp_bendradius = old_radius;
		return;
d257 2
a258 2
				rt_log( "Cannot make bend radius less than pipe outer radius\n" );
				return;
d265 2
a266 2
				rt_log( "Cannot make bend radius less than pipe outer radius\n" );
				return;
d488 2
a489 2
		rt_log( "Cannot delete last point in pipe\n" );
		return( ps );
d496 1
a496 1
		rt_log( "Cannot delete this point, it will result in an illegal pipe\n" );
d532 2
a533 2
		rt_log( "Cannot move point there\n" );
		VMOVE( ps->pp_coord, old_pt );
@


1.9
log
@Added bend radius scaling for pipe solid.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.8 1995/07/28 20:31:52 jra Exp jra $ (BRL)";
d75 2
a76 1
	if( scale < 1.0 )
d78 1
a78 4
		/* check that this can be done */
		for( RT_LIST_FOR( ps, wdb_pipept, &pipe->pipe_segs_head ) )
		{
			fastf_t tmp_od;
d80 3
d84 4
a87 10
			if( ps->pp_id > tmp_od )
			{
				rt_log( "Cannot make OD less than ID\n" );
				return;
			}
			if( tmp_od > 2.0*ps->pp_bendradius )
			{
				rt_log( "Cannot make outer radius greater than bend radius\n" );
				return;
			}
d89 5
d110 2
a111 1
	if( scale > 1.0 || scale < 0.0 )
d113 10
a122 2
		/* check that this can be done */
		for( RT_LIST_FOR( ps, wdb_pipept, &pipe->pipe_segs_head ) )
d124 2
a125 14
			if( scale > 0.0 )
				tmp_id = ps->pp_id*scale;
			else
				tmp_id = (-scale);
			if( ps->pp_od < tmp_id )
			{
				rt_log( "Cannot make ID greater than OD\n" );
				return;
			}
			if( tmp_id > 2.0*ps->pp_bendradius )
			{
				rt_log( "Cannot make inner radius greater than bend radius\n" );
				return;
			}
d147 8
a154 2
	/* make sure we can make this change */
	if( scale < 1.0 )
d156 7
a162 17
		/* need to check that the new OD is not less than ID
		 * of any affected segment.
		 */
		if( scale < 0.0 )
			tmp_od = (-scale);
		else
			tmp_od = scale*ps->pp_od;
		if( ps->pp_id > tmp_od )
		{
			rt_log( "Cannot make OD smaller than ID\n" );
			return;
		}
		if( tmp_od > 2.0*ps->pp_bendradius )
		{
			rt_log( "Cannot make outer radius greater than bend radius\n" );
			return;
		}
d179 11
a189 2
	/* make sure we can make this change */
	if( scale > 1.0 || scale < 0.0 )
d191 2
a192 15
		/* need to check that the new ID is not greater than OD */
		if( scale > 0.0 )
			tmp_id = scale*ps->pp_id;
		else
			tmp_id = (-scale);
		if( ps->pp_od < tmp_id )
		{
			rt_log( "Cannot make ID greater than OD\n" );
			return;
		}
		if( tmp_id > 2.0*ps->pp_bendradius )
		{
			rt_log( "Cannot make inner radius greater than bend radius\n" );
			return;
		}
@


1.8
log
@Added editing for new style pipe solid.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.7 1995/07/21 20:37:25 jra Exp jra $ (BRL)";
d211 121
@


1.7
log
@Checkpoint.
@
text
@d5 2
a6 2
 *	split_pipeseg - split a pipe segment at a given point
 *	find_pipeseg_nearest_pt - find which segment of a pipe is nearest
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.6 1995/07/20 22:37:29 jra Exp jra $ (BRL)";
a56 1

d58 4
a61 142
solve_pipe_to_bend( start_pt, start_dir, bend_at_start, radius_at_start, end_bend_center, end_dir,
	radius_at_end, start_bend_center, line_start_pt, line_end_pt, norm_at_end )
point_t start_pt;
vect_t start_dir;
int bend_at_start;
fastf_t radius_at_start;
point_t end_bend_center;
vect_t end_dir;
fastf_t radius_at_end;
point_t start_bend_center;
point_t line_start_pt;
point_t line_end_pt;
vect_t norm_at_end;
{
	vect_t pt_to_pt;
	vect_t norm_at_start;
	vect_t to_bcenter;
	vect_t to_tang_start;
	vect_t to_tang_end;
	vect_t cent_to_cent;
	vect_t start1;
	vect_t end1;
	fastf_t dist_ctc;
	fastf_t angle;
	mat_t mat;

rt_log( "In solve_pipe_to_bend:\n" );
rt_log( "\tstart_pt=( %g %g %g ), start_dir=( %g %g %g ), bend_at_start=%d\n", V3ARGS( start_pt ), V3ARGS( start_dir ), bend_at_start );
rt_log( "\tend_bend_center=( %g %g %g ), end_dir=( %g %g %g )\n", V3ARGS( end_bend_center ), V3ARGS( end_dir ) );

	VSUB2( pt_to_pt, end_bend_center, start_pt );

	VCROSS( norm_at_end, pt_to_pt, end_dir );
	VUNITIZE( norm_at_end );
rt_log( "\t\tpt_to_pt=( %g %g %g ), norm_at_end=( %g %g %g )\n" , V3ARGS( pt_to_pt ), V3ARGS( norm_at_end ) );

	if( bend_at_start )
	{
		vect_t pt_to_pt_dir;
		vect_t to_line_end;
		fastf_t mag_pt_to_pt;
		fastf_t sin_angle;
		fastf_t one_over_sin;
		fastf_t angle2;
#if 0
		VMOVE( pt_to_pt_dir, pt_to_pt );
		mag_pt_to_pt = MAGNITUDE( pt_to_pt );
		VSCALE( pt_to_pt_dir, pt_to_pt_dir, (1.0/mag_pt_to_pt) );
		VCROSS( norm_at_start, start_dir, pt_to_pt_dir );
rt_log( "norm_at_start=( %g %g %g )\n" , V3ARGS( norm_at_start ) );
		sin_angle = MAGNITUDE( norm_at_start );
		one_over_sin = 1.0/sin_angle;
		VSCALE( norm_at_start, norm_at_start, one_over_sin );
		angle2 = asin( radius_at_end/mag_pt_to_pt );
rt_log( "angle2 = %g, angle1 = %g\n" , angle2, asin( sin_angle ) );
		if( asin( radius_at_end/mag_pt_to_pt ) > asin( sin_angle ) )
		{
			vect_t tmp_norm;

			/* normal calculation may be reversed */
rt_log( " normal calculation may be reversed \n" );
			VCROSS( to_line_end, pt_to_pt_dir, norm_at_end );
			VJOIN1( to_line_end, pt_to_pt, radius_at_end, to_line_end );
			VCROSS( tmp_norm, start_dir, to_line_end );
rt_log( "\t\t\ttmp_norm = ( %g %g %g ), to_end_line=( %g %g %g )\n", V3ARGS( tmp_norm ), V3ARGS( to_line_end ) );
			if( VDOT( tmp_norm, norm_at_start ) < 0.0 )
			{
rt_log( "\t\t\treversing normal\n" );
				VREVERSE( norm_at_start, norm_at_start );
			}
		}
#endif
		VCROSS( to_line_end, pt_to_pt, norm_at_end );
		VUNITIZE( to_line_end );
		VJOIN1( to_line_end, pt_to_pt, radius_at_end, to_line_end );
		VCROSS( norm_at_start, start_dir, to_line_end );
		VUNITIZE( norm_at_start );

rt_log( "\t\tnorm_at_start=( %g %g %g )\n" , V3ARGS( norm_at_start ) );
		VCROSS( to_bcenter, norm_at_start, start_dir );
rt_log( "\t\tto bend center at start = ( %g %g %g )\n", V3ARGS( to_bcenter ) );
		VJOIN1( start_bend_center, start_pt, radius_at_start, to_bcenter );
rt_log( "\t\tstart bend center = ( %g %g %g )\n" , V3ARGS( start_bend_center ) );
	}

	if( bend_at_start )
		VSUB2( cent_to_cent, end_bend_center, start_bend_center )
	else
		VMOVE( cent_to_cent, pt_to_pt )

	dist_ctc = MAGNITUDE( cent_to_cent );
rt_log( "\t\tcent_to_cent = ( %g %g %g ), length=%g\n" , V3ARGS( cent_to_cent ), dist_ctc );

	if( bend_at_start )
	{
		VCROSS( start1, cent_to_cent, norm_at_start );
		VUNITIZE( start1 );
	}
	else
		VSETALL( start1, 0.0 )

	VCROSS( end1, cent_to_cent, norm_at_end );
	VUNITIZE( end1 );

rt_log( "\t\tstart1=( %g %g %g ), end1=( %g %g %g )\n", V3ARGS( start1 ), V3ARGS( end1 ) );

	if( bend_at_start )
	{
		angle = asin( (radius_at_start - VDOT( end1, start1 )*radius_at_end)/dist_ctc );
		mat_arb_rot( mat, start_bend_center, norm_at_start, angle );
		MAT4X3VEC( to_tang_start, mat, start1 );
		VUNITIZE( to_tang_start );
rt_log( "angel at start = %g, to_start_tang=( %g %g %g )\n", angle, V3ARGS( to_tang_start ) );
		VJOIN1( line_start_pt, start_bend_center, radius_at_start, to_tang_start );
	}
	else
		VMOVE( line_start_pt, start_pt )
rt_log( "\t\tline_start_pt=( %g %g %g )\n", V3ARGS( line_start_pt ) );

	angle = asin( (radius_at_end - VDOT( end1, start1 )*radius_at_start)/dist_ctc );
	mat_arb_rot( mat, end_bend_center, norm_at_end, -angle );
	MAT4X3VEC( to_tang_end, mat, end1 );
	VUNITIZE( to_tang_end );
rt_log( "angel at end = %g, to_end_tang=( %g %g %g )\n", angle, V3ARGS( to_tang_end ) );
	VJOIN1( line_end_pt, end_bend_center, radius_at_end, to_tang_end );
rt_log( "\t\tline_end_pt=( %g %g %g )\n", V3ARGS( line_end_pt ) );
}

void
solve_pipe_from_bend( norm_at_start, start_bend_center, start_dir, radius_at_start, end_pt, end_dir, bend_at_end,
	radius_at_end, end_bend_center, line_start_pt, line_end_pt )
vect_t norm_at_start;
point_t start_bend_center;
vect_t start_dir;
fastf_t radius_at_start;
point_t end_pt;
vect_t end_dir;
int bend_at_end;
fastf_t radius_at_end;
point_t end_bend_center;
point_t line_start_pt;
point_t line_end_pt;
a62 80
	vect_t pt_to_pt;
	vect_t norm_at_end;
	vect_t to_bcenter;
	vect_t to_tang_start;
	vect_t to_tang_end;
	vect_t cent_to_cent;
	vect_t start1;
	vect_t end1;
	fastf_t dist_ctc;
	fastf_t angle;
	mat_t mat;

rt_log( "In solve_pipe_from_bend:\n" );
rt_log( "\tstart_bend_center=( %g %g %g ), start_dir=( %g %g %g ), bend_at_end=%d\n", V3ARGS( start_bend_center ), V3ARGS( start_dir ), bend_at_end );
rt_log( "\tend_bend_center=( %g %g %g )\n", V3ARGS( end_bend_center ) );

	VSUB2( pt_to_pt, end_pt, start_bend_center );

	if( norm_at_start[0] == 0.0 && norm_at_start[1] == 0.0 && norm_at_start[2] == 0.0 )
	{
		VCROSS( norm_at_start, start_dir, pt_to_pt );
		VUNITIZE( norm_at_start );
	}

rt_log( "\t\tpt_to_pt=( %g %g %g ), norm_at_start=( %g %g %g )\n" , V3ARGS( pt_to_pt ), V3ARGS( norm_at_start ) );

	if( bend_at_end )
	{
		vect_t to_line_start;

		VCROSS( to_line_start, norm_at_start, pt_to_pt );
		VUNITIZE( to_line_start );
		VJOIN1( to_line_start, pt_to_pt, radius_at_start, to_line_start );
		VCROSS( norm_at_end, to_line_start, end_dir );
		VUNITIZE( norm_at_end );
		VCROSS( to_bcenter, norm_at_end, end_dir );
		VJOIN1( end_bend_center, end_pt, radius_at_end, to_bcenter );
	}

	if( bend_at_end )
		VSUB2( cent_to_cent, end_bend_center, start_bend_center )
	else
		VMOVE( cent_to_cent, pt_to_pt )

	dist_ctc = MAGNITUDE( cent_to_cent );
rt_log( "\t\tcent_to_cent = ( %g %g %g ), length=%g\n" , V3ARGS( cent_to_cent ), dist_ctc );

	VCROSS( start1, cent_to_cent, norm_at_start );
	VUNITIZE( start1 );

	if( bend_at_end )
	{
		VCROSS( end1, cent_to_cent, norm_at_end );
		VUNITIZE( end1 );
	}
	else
		VSETALL( end1, 0.0 )

rt_log( "\t\tstart1=( %g %g %g ), end1=( %g %g %g )\n", V3ARGS( start1 ), V3ARGS( end1 ) );

	angle = asin( (radius_at_start - VDOT( end1, start1 )*radius_at_end)/dist_ctc );
	mat_arb_rot( mat, start_bend_center, norm_at_start, angle );
	MAT4X3VEC( to_tang_start, mat, start1 );
	VUNITIZE( to_tang_start );
rt_log( "angel at start = %g, to_start_tang=( %g %g %g )\n", angle, V3ARGS( to_tang_start ) );
	VJOIN1( line_start_pt, start_bend_center, radius_at_start, to_tang_start );
rt_log( "\t\tline_start_pt=( %g %g %g )\n", V3ARGS( line_start_pt ) );

	if( bend_at_end )
	{
		angle = asin( (radius_at_end - VDOT( end1, start1 )*radius_at_start)/dist_ctc );
		mat_arb_rot( mat, end_bend_center, norm_at_end, -angle );
		MAT4X3VEC( to_tang_end, mat, end1 );
		VUNITIZE( to_tang_end );
	rt_log( "angel at end = %g, to_end_tang=( %g %g %g )\n", angle, V3ARGS( to_tang_end ) );
		VJOIN1( line_end_pt, end_bend_center, radius_at_end, to_tang_end );
	}
	else
		VMOVE( line_end_pt, end_pt );
	rt_log( "\t\tline_end_pt=( %g %g %g )\n", V3ARGS( line_end_pt ) );
d70 1
a70 1
	struct wdb_pipeseg *ps;
d78 1
a78 1
		for( RT_LIST_FOR( ps, wdb_pipeseg, &pipe->pipe_segs_head ) )
d80 4
a83 1
			if( ps->ps_id > ps->ps_od*scale )
d88 5
d96 2
a97 2
	for( RT_LIST_FOR( ps, wdb_pipeseg, &pipe->pipe_segs_head ) )
		ps->ps_od *= scale;
d104 1
a104 1
	struct wdb_pipeseg *ps;
d113 1
a113 1
		for( RT_LIST_FOR( ps, wdb_pipeseg, &pipe->pipe_segs_head ) )
d116 1
a116 1
				tmp_id = ps->ps_id*scale;
d119 1
a119 1
			if( ps->ps_od < tmp_id )
d124 5
d132 1
a132 1
	for( RT_LIST_FOR( ps, wdb_pipeseg, &pipe->pipe_segs_head ) )
d135 1
a135 1
			ps->ps_id *= scale;
d137 1
a137 1
			ps->ps_id = (-scale);
d143 1
a143 1
struct wdb_pipeseg *ps;
a145 4
	struct wdb_pipeseg *prev;
	struct wdb_pipeseg *next;
	int seg_count=0;
	int id_eq_od=0;
d159 2
a160 2
			tmp_od = scale*ps->ps_od;
		if( ps->ps_id > tmp_od )
d165 1
a165 51
		prev = RT_LIST_PREV( wdb_pipeseg, &ps->l );
		while( prev->l.magic != RT_LIST_HEAD_MAGIC &&
			 prev->ps_type == WDB_PIPESEG_TYPE_BEND )
		{
			if( scale < 0.0 )
				tmp_od = (-scale);
			else
				tmp_od = scale*prev->ps_od;
			if( prev->ps_id > tmp_od )
			{
				rt_log( "Cannot make OD smaller than ID\n" );
				return;
			}
			seg_count++;
			if( prev->ps_id == tmp_od )
				id_eq_od++;
			prev = RT_LIST_PREV( wdb_pipeseg, &prev->l );
		}
		if( ps->ps_type == WDB_PIPESEG_TYPE_BEND )
		{
			next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
			while( next->ps_type == WDB_PIPESEG_TYPE_BEND )
			{
				if( scale < 0.0 )
					tmp_od = (-scale);
				else
					tmp_od = scale*next->ps_od;
				if( next->ps_id > tmp_od )
				{
					rt_log( "Cannot make OD smaller than ID\n" );
					return;
				}
				seg_count++;
				if( next->ps_id == tmp_od )
					id_eq_od++;
				next = RT_LIST_NEXT( wdb_pipeseg, &next->l );
			}
			if( scale < 0.0 )
				tmp_od = (-scale);
			else
				tmp_od = scale*next->ps_od;
			if( next->ps_id > tmp_od )
			{
				rt_log( "Cannot make OD smaller than ID\n" );
				return;
			}
			seg_count++;
			if( next->ps_id == tmp_od )
				id_eq_od++;
		}
		if( seg_count && id_eq_od == seg_count )
d167 1
a167 1
			rt_log( "Cannot make zero wall thickness pipe\n" );
d173 1
a173 1
		ps->ps_od *= scale;
d175 1
a175 28
		ps->ps_od = (-scale);
	prev = RT_LIST_PREV( wdb_pipeseg, &ps->l );
	while( prev->l.magic != RT_LIST_HEAD_MAGIC &&
		 prev->ps_type == WDB_PIPESEG_TYPE_BEND )
	{
		if( scale > 0.0 )
			prev->ps_od *= scale;
		else
			prev->ps_od = (-scale);
		prev = RT_LIST_PREV( wdb_pipeseg, &prev->l );
	}

	if( ps->ps_type == WDB_PIPESEG_TYPE_BEND )
	{
		next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
		while( next->ps_type == WDB_PIPESEG_TYPE_BEND )
		{
			if( scale > 0.0 )
				next->ps_od *= scale;
			else
				next->ps_od = (-scale);
			next = RT_LIST_PNEXT_CIRC( wdb_pipeseg, &next->l );
		}
		if( scale > 0.0 )
			next->ps_od *= scale;
		else
			next->ps_od = (-scale);
	}
d179 1
a179 1
struct wdb_pipeseg *ps;
a181 4
	struct wdb_pipeseg *prev;
	struct wdb_pipeseg *next;
	int seg_count=0;
	int id_eq_od=0;
d189 1
a189 3
		/* need to check that the new ID is not greater than OD
		 * of any affected segment.
		 */
d191 1
a191 1
			tmp_id = scale*ps->ps_id;
d194 1
a194 1
		if( ps->ps_od < tmp_id )
d199 1
a199 51
		prev = RT_LIST_PREV( wdb_pipeseg, &ps->l );
		while( prev->l.magic != RT_LIST_HEAD_MAGIC &&
			 prev->ps_type == WDB_PIPESEG_TYPE_BEND )
		{
			if( scale > 0.0 )
				tmp_id = scale*prev->ps_id;
			else
				tmp_id = (-scale);
			if( prev->ps_od < tmp_id )
			{
				rt_log( "Cannot make ID greater than OD\n" );
				return;
			}
			seg_count++;
			if( prev->ps_od == tmp_id )
				id_eq_od++;
			prev = RT_LIST_PREV( wdb_pipeseg, &prev->l );
		}
		if( ps->ps_type == WDB_PIPESEG_TYPE_BEND )
		{
			next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
			while( next->ps_type == WDB_PIPESEG_TYPE_BEND )
			{
				if( scale > 0.0 )
					tmp_id = scale*next->ps_id;
				else
					tmp_id = (-scale);
				if( next->ps_od < tmp_id )
				{
					rt_log( "Cannot make ID greater than OD\n" );
					return;
				}
				seg_count++;
				if( next->ps_od == tmp_id )
					id_eq_od++;
				next = RT_LIST_NEXT( wdb_pipeseg, &next->l );
			}
			if( scale > 0.0 )
				tmp_id = scale*next->ps_id;
			else
				tmp_id = (-scale);
			if( next->ps_od < tmp_id )
			{
				rt_log( "Cannot make ID greater than OD\n" );
				return;
			}
			seg_count++;
			if( next->ps_od == tmp_id )
				id_eq_od++;
		}
		if( seg_count && id_eq_od == seg_count )
d201 1
a201 1
			rt_log( "Cannot make zero wall thickness pipe\n" );
d207 1
a207 188
		ps->ps_id *= scale;
	else
		ps->ps_id = (-scale);
	prev = RT_LIST_PREV( wdb_pipeseg, &ps->l );
	while( prev->l.magic != RT_LIST_HEAD_MAGIC &&
		 prev->ps_type == WDB_PIPESEG_TYPE_BEND )
	{
		if( scale > 0.0 )
			prev->ps_id *= scale;
		else
			prev->ps_od = (-scale);
		prev = RT_LIST_PREV( wdb_pipeseg, &prev->l );
	}

	if( ps->ps_type == WDB_PIPESEG_TYPE_BEND )
	{
		next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
		while( next->ps_type == WDB_PIPESEG_TYPE_BEND )
		{
			if( scale > 0.0 )
				next->ps_id *= scale;
			else
				next->ps_id = (-scale);
			next = RT_LIST_PNEXT_CIRC( wdb_pipeseg, &next->l );
		}
		if( scale > 0.0 )
			next->ps_id *= scale;
		else
			next->ps_id = (-scale);
	}
}

static void
break_bend( ps, n1, n2, angle )
struct wdb_pipeseg *ps;
vect_t n1,n2;
fastf_t angle;
{
	struct wdb_pipeseg *next;
	struct wdb_pipeseg *new_bend;
	vect_t to_end;
	point_t new_pt;
	fastf_t n1_coeff,n2_coeff;
	fastf_t bend_radius;

	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );

	if( ps->ps_type != WDB_PIPESEG_TYPE_BEND )
		rt_bomb( "break_bend: Called with a non-bend pipe segment\n" );

	next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
	VSUB2( to_end, next->ps_start, ps->ps_bendcenter );
	bend_radius = MAGNITUDE( to_end );

	n1_coeff = bend_radius*cos( angle );
	n2_coeff = bend_radius*sin( angle );
	VJOIN2( new_pt, ps->ps_bendcenter, n1_coeff, n1, n2_coeff, n2 );

	GETSTRUCT( new_bend, wdb_pipeseg );
	new_bend->ps_type = WDB_PIPESEG_TYPE_BEND;
	new_bend->l.magic = WDB_PIPESEG_MAGIC;
	new_bend->ps_od = ps->ps_od;
	new_bend->ps_id = ps->ps_id;

	VMOVE( new_bend->ps_bendcenter, ps->ps_bendcenter );
	VMOVE( new_bend->ps_start, new_pt );

	RT_LIST_APPEND( &ps->l, &new_bend->l );
}

static void
make_bend_lt_180( ps, normal )
struct wdb_pipeseg *ps;
vect_t normal;	/* unit normal */
{
	struct wdb_pipeseg *next;
	vect_t to_start;
	vect_t to_end;
	vect_t v2;
	fastf_t angle;

	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );

	if( ps->ps_type != WDB_PIPESEG_TYPE_BEND )
		rt_bomb( "make_bend_lt_180 called with non-bend pipe segment\n" );

	next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );

	VSUB2( to_start, ps->ps_start, ps->ps_bendcenter );
	VSUB2( to_end, next->ps_start, ps->ps_bendcenter );
	VCROSS( v2, normal, to_start );

	angle = atan2( VDOT( to_end, v2 ), VDOT( to_end, to_start ) );
	if( angle < 0.0 )
		angle += 2.0*rt_pi;

	if( angle > rt_pi-RT_DOT_TOL )
	{
		VUNITIZE( to_start );
		VUNITIZE( v2 );
		break_bend( ps, to_start, v2, angle/2.0 );
	}
}

static void
get_bend_start_line( ps, pt, dir )
CONST struct wdb_pipeseg *ps;
point_t pt;
vect_t dir;
{
	struct wdb_pipeseg *next;
	struct wdb_pipeseg *prev;
	vect_t to_start;
	vect_t to_end;
	vect_t normal;

	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );

	if( ps->ps_type != WDB_PIPESEG_TYPE_BEND )
		rt_bomb( "get_bend_start_line called woth non-bend pipe segment\n" );

	VMOVE( pt, ps->ps_start );

	prev = RT_LIST_PREV( wdb_pipeseg, &ps->l );
	if( prev->l.magic != RT_LIST_HEAD_MAGIC && prev->ps_type == WDB_PIPESEG_TYPE_LINEAR )
	{
		struct wdb_pipeseg *pprev;

		pprev = RT_LIST_PREV( wdb_pipeseg, &prev->l );
		while( pprev->l.magic != RT_LIST_HEAD_MAGIC && pprev->ps_type == WDB_PIPESEG_TYPE_LINEAR )
		{
			prev = pprev;
			pprev = RT_LIST_PREV( wdb_pipeseg, &pprev->l );
		}
		VSUB2( dir, pt, prev->ps_start )
	}
	else
	{
		next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );

		VSUB2( to_start, ps->ps_start, ps->ps_bendcenter );
		VSUB2( to_end, next->ps_start, ps->ps_bendcenter );
		VCROSS( normal, to_start, to_end );
		VCROSS( dir, normal, to_start );
	}

	if( VNEAR_ZERO( dir, SQRT_SMALL_FASTF ) )
		VSETALL( dir, 0.0 )
	else
		VUNITIZE( dir )
}

static void
get_bend_end_line( ps, pt, dir )
CONST struct wdb_pipeseg *ps;
point_t pt;
vect_t dir;
{
	struct wdb_pipeseg *next;
	vect_t to_start;
	vect_t to_end;
	vect_t normal;

	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );

	if( ps->ps_type != WDB_PIPESEG_TYPE_BEND )
		rt_bomb( "get_bend_end_line called woth non-bend pipe segment\n" );

	next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
	VMOVE( pt, next->ps_start );

	if( next->ps_type == WDB_PIPESEG_TYPE_LINEAR )
	{
		while( next->ps_type == WDB_PIPESEG_TYPE_LINEAR )
			next = RT_LIST_NEXT( wdb_pipeseg, &next->l );

		VSUB2( dir, pt, next->ps_start );
	}
	else
	{
		VSUB2( to_start, ps->ps_start, ps->ps_bendcenter );
		VSUB2( to_end, next->ps_start, ps->ps_bendcenter );
		VCROSS( normal, to_start, to_end );
		VCROSS( dir, to_end, normal );
	}

	if( VNEAR_ZERO( dir, SQRT_SMALL_FASTF ) )
		VSETALL( dir, 0.0 )
d209 1
a209 332
		VUNITIZE( dir )
}

static fastf_t
get_bend_radius( ps )
CONST struct wdb_pipeseg *ps;
{
	struct wdb_pipeseg *next;
	struct wdb_pipeseg *prev;
	fastf_t bend_radius=(-1.0);
	vect_t to_start;

	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );

	if( ps->ps_type == WDB_PIPESEG_TYPE_BEND )
	{
		VSUB2( to_start, ps->ps_start, ps->ps_bendcenter );
		bend_radius = MAGNITUDE( to_start );
		return( bend_radius );
	}

	next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
	prev = RT_LIST_PREV( wdb_pipeseg, &ps->l );

	while( next->ps_type != WDB_PIPESEG_TYPE_END || prev->l.magic != RT_LIST_HEAD_MAGIC )
	{
		if( next->ps_type != WDB_PIPESEG_TYPE_END )
		{
			if( next->ps_type == WDB_PIPESEG_TYPE_BEND )
			{
				VSUB2( to_start, next->ps_start, next->ps_bendcenter );
				bend_radius = MAGNITUDE( to_start );
				return( bend_radius );
			}
			next = RT_LIST_NEXT( wdb_pipeseg, &next->l );
		}
		if( prev->l.magic != RT_LIST_HEAD_MAGIC )
		{
			if( prev->ps_type == WDB_PIPESEG_TYPE_BEND )
			{
				VSUB2( to_start, prev->ps_start, prev->ps_bendcenter );
				bend_radius = MAGNITUDE( to_start );
				return( bend_radius );
			}
			prev = RT_LIST_PREV( wdb_pipeseg, &prev->l );
		}
	}

	if( bend_radius < 0.0 )
		bend_radius = ps->ps_od;

	return( bend_radius );
}

void
split_pipeseg( pipe_hd, ps, pt )
struct rt_list *pipe_hd;
struct wdb_pipeseg *ps;
point_t pt;
{
	struct wdb_pipeseg *new_linear;
	struct wdb_pipeseg *new_bend;
	struct wdb_pipeseg *start_bend=(struct wdb_pipeseg *)NULL;
	struct wdb_pipeseg *end_bend=(struct wdb_pipeseg *)NULL;
	struct wdb_pipeseg *next;
	struct wdb_pipeseg *prev;
	vect_t new_dir1,new_dir2;
	vect_t v1,v2;
	vect_t n1,n2;
	vect_t normal;
	fastf_t bend_radius;
	fastf_t alpha;

	RT_CK_LIST_HEAD( pipe_hd );
	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );

	if( ps->ps_type != WDB_PIPESEG_TYPE_LINEAR )
	{
		rt_log( "Can only split linear pipe segments\n" );
		return;
	}

	bend_radius = get_bend_radius( ps );

	GETSTRUCT( new_linear, wdb_pipeseg );
	new_linear->ps_type = WDB_PIPESEG_TYPE_LINEAR;
	new_linear->l.magic = WDB_PIPESEG_MAGIC;
	new_linear->ps_od = ps->ps_od;
	new_linear->ps_id = ps->ps_id;

	GETSTRUCT( new_bend, wdb_pipeseg );
	new_bend->ps_type = WDB_PIPESEG_TYPE_BEND;
	new_bend->l.magic = WDB_PIPESEG_MAGIC;
	new_bend->ps_od = ps->ps_od;
	new_bend->ps_id = ps->ps_id;

	VSUB2( new_dir1, ps->ps_start, pt );
	VUNITIZE( new_dir1 );

	next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
	VSUB2( new_dir2, next->ps_start, pt );
	VUNITIZE( new_dir2 );

	prev = RT_LIST_PREV( wdb_pipeseg, &ps->l );
	if( RT_LIST_IS_HEAD( &prev->l, pipe_hd ) && next->ps_type == WDB_PIPESEG_TYPE_END )
	{
		/* this is the only segment in the current pipe */
		VCROSS( normal, new_dir1, new_dir2 );

		VCROSS( n1, normal, new_dir1 );
		VUNITIZE( n1 );

		VCROSS( n2, new_dir2, normal );
		VUNITIZE( n2 );

		alpha = bend_radius*(VDOT( n2, new_dir1 ) + VDOT( n1, new_dir2 ) )/
			(2.0 * (1.0 - VDOT( new_dir1, new_dir2 ) ) );
		VJOIN2( new_bend->ps_bendcenter, pt, alpha, new_dir1, bend_radius, n1 );
		VJOIN1( new_bend->ps_start, pt, alpha, new_dir1 );

		VJOIN1( new_linear->ps_start, pt, alpha, new_dir2 );

		RT_LIST_APPEND( &ps->l, &new_bend->l );
		RT_LIST_APPEND( &new_bend->l, &new_linear->l );

		return;
	}

	/* process starting end of "ps" */
	if( RT_LIST_NOT_HEAD( &prev->l, pipe_hd ) )
	{
		if( prev->ps_type == WDB_PIPESEG_TYPE_LINEAR )
		{
			vect_t dir;

			/* two consecutive linear sections, probably needs a bend inserted */
			VSUB2( dir, prev->ps_start, ps->ps_start );
			VUNITIZE( dir );

			if( !NEAR_ZERO( VDOT( dir, new_dir1 ) - 1.0, RT_DOT_TOL ) )
			{
				struct wdb_pipeseg *start_bend;
				point_t pt1;
				vect_t d1,d2;

				/* does need a bend */
				GETSTRUCT( start_bend, wdb_pipeseg );
				start_bend->ps_type = WDB_PIPESEG_TYPE_BEND;
				start_bend->l.magic = WDB_PIPESEG_MAGIC;
				start_bend->ps_od = ps->ps_od;
				start_bend->ps_id = ps->ps_id;

				VMOVE( pt1, ps->ps_start );
				VMOVE( d1, dir );
				VREVERSE( d2, new_dir1 );
				VCROSS( normal, d1, d2 );

				VCROSS( n1, normal, d1 );
				VUNITIZE( n1 );

				VCROSS( n2, d2, normal );
				VUNITIZE( n2 );

				alpha = bend_radius*(VDOT( n2, d1 ) + VDOT( n1, d2 ) )/
					(2.0 * (1.0 - VDOT( d1, d2 ) ) );

				VJOIN2( start_bend->ps_bendcenter, ps->ps_start, alpha, d1, bend_radius, n1 );
				VJOIN1( start_bend->ps_start, ps->ps_start, alpha, d1 );
				VJOIN1( ps->ps_start, ps->ps_start, alpha, d2 );

				RT_LIST_INSERT( &ps->l, &start_bend->l );
			}
		}
		else if( prev->ps_type == WDB_PIPESEG_TYPE_BEND )
		{
			point_t pt1;
			point_t pt2;
			vect_t d1;
			vect_t d2;
			vect_t d3;
			fastf_t local_bend_radius;
			fastf_t dist_to_center;
			fastf_t angle;
			mat_t mat;

			/* get bend radius for this bend */
			VSUB2( d1, prev->ps_bendcenter, prev->ps_start );
			local_bend_radius = MAGNITUDE( d1 );

			/* calculate new bend center */
			get_bend_start_line( prev, pt1, n2 );
			VSUB2( d2, pt, pt1 );
			VCROSS( normal, n2, d2 );
			VUNITIZE( normal );
			VCROSS( n1, normal, n2 );
			VUNITIZE( n1 );
			VJOIN1( prev->ps_bendcenter, prev->ps_start, local_bend_radius, n1 );

			/* calculate new start point for "ps" */
			VSUB2( d1, pt, prev->ps_bendcenter );
			angle = asin( local_bend_radius/MAGNITUDE( d1 ) );
			mat_arb_rot( mat, prev->ps_bendcenter, normal, angle );
			VCROSS( d2, d1, normal )
			MAT4X3VEC( d3, mat, d2 );
			VUNITIZE( d3 );
			VJOIN1( ps->ps_start, prev->ps_bendcenter, local_bend_radius, d3 );

			/* Make sure resulting bend is less than 180 degrees */
			angle = atan2( VDOT( d3, n2 ),	VDOT( d3, n1 ) );
			if( angle < 0.0 )
				angle += 2.0 * rt_pi;

			if( angle > rt_pi - RT_DOT_TOL )
				break_bend( prev, n1, n2, angle/2 );
		}
	}

	/* process end point of "ps" */
	if( next->ps_type != WDB_PIPESEG_TYPE_END )
	{
		if( next->ps_type == WDB_PIPESEG_TYPE_LINEAR )
		{
			vect_t dir;
			struct wdb_pipeseg *nnext;

			/* two consecutive linear sections, probably needs a bend inserted */
			nnext = RT_LIST_NEXT( wdb_pipeseg, &next->l );
			VSUB2( dir, nnext->ps_start, next->ps_start );
			VUNITIZE( dir );

			if( !NEAR_ZERO( VDOT( dir, new_dir2 ) - 1.0, RT_DOT_TOL ) )
			{
				point_t pt1;
				vect_t d1,d2;

				/* does need a bend */
				GETSTRUCT( end_bend, wdb_pipeseg );
				end_bend->ps_type = WDB_PIPESEG_TYPE_BEND;
				end_bend->l.magic = WDB_PIPESEG_MAGIC;
				end_bend->ps_od = ps->ps_od;
				end_bend->ps_id = ps->ps_id;

				VMOVE( pt1, nnext->ps_start );
				VMOVE( d1, dir );
				VREVERSE( d2, new_dir2 );
				VCROSS( normal, d1, d2 );

				VCROSS( n1, normal, d1 );
				VUNITIZE( n1 );

				VCROSS( n2, d2, normal );
				VUNITIZE( n2 );

				alpha = bend_radius*(VDOT( n2, d1 ) + VDOT( n1, d2 ) )/
					(2.0 * (1.0 - VDOT( d1, d2 ) ) );

				VJOIN2( end_bend->ps_bendcenter, next->ps_start, alpha, d1, bend_radius, n1 );
				VJOIN1( end_bend->ps_start, next->ps_start, alpha, d1 );
				VJOIN1( next->ps_start, next->ps_start, alpha, d2 );

				RT_LIST_APPEND( &ps->l, &end_bend->l );
			}
		}
		else if( next->ps_type == WDB_PIPESEG_TYPE_BEND )
		{
			struct wdb_pipeseg *nnext;
			mat_t mat;
			point_t pt1,pt2;
			vect_t d1,d2,d3;
			fastf_t local_bend_radius;
			fastf_t dist_to_center;
			fastf_t angle;

			/* get bend radius for this bend */
			VSUB2( d1, next->ps_bendcenter, next->ps_start );
			local_bend_radius = MAGNITUDE( d1 );

			/* calculate new bend center */
			get_bend_end_line( next, pt1, n2 );
			VSUB2( d2, pt, pt1 );
			VCROSS( normal, n2, d2 );
			VUNITIZE( normal );
			VCROSS( n1, normal, n2 );
			VUNITIZE( n1 );
			nnext = RT_LIST_NEXT( wdb_pipeseg, &next->l );
			VJOIN1( next->ps_bendcenter, nnext->ps_start, local_bend_radius, n1 );

			/* calculate new end point for "ps" (next->ps_start) */
			VSUB2( d1, pt, next->ps_bendcenter );
			VCROSS( d2, d1, normal );
			angle = asin( local_bend_radius/MAGNITUDE( d1 ) );
			mat_arb_rot( mat, next->ps_bendcenter, normal, angle );
			MAT4X3VEC( d3, mat, d2 );
			VUNITIZE( d3 );
			VJOIN1( next->ps_start, next->ps_bendcenter, local_bend_radius, d3 );

			/* Make sure resulting bend is less than 180 degrees */
			angle = atan2( VDOT( d3, n2 ), -VDOT( d3, n1 ) );
			if( angle < 0.0 )
				angle += 2.0 * rt_pi;

			if( angle > rt_pi - RT_DOT_TOL )
				break_bend( next, n1, n2, angle/2 );
		}
	}

	VSUB2( new_dir1, ps->ps_start, pt );
	VUNITIZE( new_dir1 );

	next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
	VSUB2( new_dir2, next->ps_start, pt );
	VUNITIZE( new_dir2 );

	VCROSS( normal, new_dir1, new_dir2 );

	VCROSS( n1, normal, new_dir1 );
	VUNITIZE( n1 );

	VCROSS( n2, new_dir2, normal );
	VUNITIZE( n2 );

	alpha = bend_radius*(VDOT( n2, new_dir1 ) + VDOT( n1, new_dir2 ) )/
		(2.0 * (1.0 - VDOT( new_dir1, new_dir2 ) ) );
	VJOIN2( new_bend->ps_bendcenter, pt, alpha, new_dir1, bend_radius, n1 );
	VJOIN1( new_bend->ps_start, pt, alpha, new_dir1 );

	VJOIN1( new_linear->ps_start, pt, alpha, new_dir2 );

	RT_LIST_APPEND( &ps->l, &new_bend->l );
	RT_LIST_APPEND( &new_bend->l, &new_linear->l );

	return;
d212 2
a213 2
struct wdb_pipeseg *
find_pipeseg_nearest_pt( pipe_hd, pt )
d217 2
a218 2
	struct wdb_pipeseg *ps;
	struct wdb_pipeseg *nearest=(struct wdb_pipeseg *)NULL;
a231 1
	VUNITIZE( dir );
d233 1
a233 1
	for( RT_LIST_FOR( ps, wdb_pipeseg, pipe_hd ) )
d235 1
a235 36
		struct wdb_pipeseg *next;
		point_t pca;
		fastf_t dist[2];
		fastf_t dist_sq;
		int code;

		if( ps->ps_type == WDB_PIPESEG_TYPE_END )
			break;

		next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );

		if( ps->ps_type == WDB_PIPESEG_TYPE_LINEAR )
		{
			code = rt_dist_line3_lseg3( dist, pt, dir, ps->ps_start, next->ps_start, &tmp_tol );

			if( code == 0 )
				dist_sq = 0.0;
			else
			{
				point_t p1,p2;
				vect_t seg_vec;
				vect_t diff;

				VJOIN1( p1, pt, dist[0], dir )
				if( dist[1] < 0.0 )
					VMOVE( p2, ps->ps_start )
				else if( dist[1] > 1.0 )
					VMOVE( p2, next->ps_start )
				else
				{
					VSUB2( seg_vec, next->ps_start, ps->ps_start )
					VJOIN1( p2, ps->ps_start, dist[1], seg_vec )
				}
				VSUB2( diff, p1, p2 )
				dist_sq = MAGSQ( diff );
			}
d237 2
a238 7
			if( dist_sq < min_dist )
			{
				min_dist = dist_sq;
				nearest = ps;
			}
		}
		else if( ps->ps_type == WDB_PIPESEG_TYPE_BEND )
d240 2
a241 66
			vect_t to_start;
			vect_t to_end;
			vect_t norm;
			vect_t v1,v2;
			fastf_t delta_angle;
			fastf_t cos_del,sin_del;
			fastf_t x,y,x_new,y_new;
			fastf_t radius;
			point_t pt1,pt2;
			int i;

			VSUB2( to_start, ps->ps_start, ps->ps_bendcenter );
			VSUB2( to_end, next->ps_start, ps->ps_bendcenter );
			VCROSS( norm, to_start, to_end );
			VMOVE( v1, to_start );
			VUNITIZE( v1 );
			VCROSS( v2, norm, v1 );
			VUNITIZE( v2 );
			delta_angle = atan2( VDOT( to_end, v2 ), VDOT( to_end, v1 ) )/5.0;
			cos_del = cos( delta_angle );
			sin_del = sin( delta_angle );
			radius = MAGNITUDE( to_start );

			x = radius;
			y = 0.0;
			VJOIN2( pt1, ps->ps_bendcenter, x, v1, y, v2 );
			for( i=0 ; i<5 ; i++ )
			{
				x_new = x*cos_del - y*sin_del;
				y_new = x*sin_del + y*cos_del;
				VJOIN2( pt2, ps->ps_bendcenter, x_new, v1, y_new, v2 );
				x = x_new;
				y = y_new;

				code = rt_dist_line3_lseg3( dist, pt, dir, pt1, pt2, &tmp_tol );

				if( code == 0 )
					dist_sq = 0.0;
				else
				{
					point_t p1,p2;
					vect_t seg_vec;
					vect_t diff;

					VJOIN1( p1, pt, dist[0], dir )
					if( dist[1] < 0.0 )
						VMOVE( p2, pt1 )
					else if( dist[1] > 1.0 )
						VMOVE( p2, pt2 )
					else
					{
						VSUB2( seg_vec, pt2, pt1 )
						VJOIN1( p2, pt1, dist[1], seg_vec )
					}
					VSUB2( diff, p1, p2 )
					dist_sq = MAGSQ( diff );
				}

				if( dist_sq < min_dist )
				{
					min_dist = dist_sq;
					nearest = ps;
				}

				VMOVE( pt1, pt2 );
			}
d248 1
a248 1
add_pipeseg( pipe, new_pt )
d250 1
d253 2
a254 15
	struct wdb_pipeseg *end_ps;
	struct wdb_pipeseg *last_ps;
	struct wdb_pipeseg *new_linear;
	struct wdb_pipeseg *new_bend;
	point_t old_end;
	fastf_t bend_radius;
	vect_t end_dir;
	vect_t tmp_dir;
	vect_t normal;
	vect_t to_start;
	vect_t to_end;
	vect_t d1,d2;
	fastf_t angle;
	fastf_t dist_to_center;
	mat_t mat;
d257 2
d260 3
a262 33
	end_ps = RT_LIST_LAST( wdb_pipeseg, &pipe->pipe_segs_head );
	RT_CKMAG( end_ps, WDB_PIPESEG_MAGIC, "pipe segment" );
	
	if( end_ps->ps_type != WDB_PIPESEG_TYPE_END )
	{
		rt_log( "This pipe doesn't have and 'END' segment!!!\n" );
		return;
	}
	VMOVE( old_end, end_ps->ps_start );
	last_ps = RT_LIST_PREV( wdb_pipeseg, &end_ps->l );
	RT_CKMAG( last_ps, WDB_PIPESEG_MAGIC, "pipe segment" );
	if( last_ps->l.magic == RT_LIST_HEAD_MAGIC )
	{
		/* This pipe is just an END segment */
		GETSTRUCT( new_linear, wdb_pipeseg );
		new_linear->ps_type = WDB_PIPESEG_TYPE_LINEAR;
		new_linear->l.magic = WDB_PIPESEG_MAGIC;
		new_linear->ps_od = end_ps->ps_od;
		new_linear->ps_id = end_ps->ps_id;
		VMOVE( new_linear->ps_start, old_end );
		VMOVE( end_ps->ps_start, new_pt );
		RT_LIST_INSERT( &end_ps->l, &new_linear->l );
	}

	VSUB2( tmp_dir, new_pt, old_end );
	dist_to_center = MAGNITUDE( tmp_dir );
	if( dist_to_center < RT_LEN_TOL )	/* nothing new needed */
		return;
	VUNITIZE( tmp_dir );

	bend_radius = get_bend_radius( last_ps );

	if( last_ps->ps_type == WDB_PIPESEG_TYPE_LINEAR )
d264 11
a274 5
		VSUB2( end_dir, last_ps->ps_start, old_end );
		VUNITIZE( end_dir );
		if( NEAR_ZERO( VDOT( end_dir, tmp_dir ) + 1.0, RT_DOT_TOL ) )
		{
			/* new point is in same direction as last segment, so just strech it */
a277 7
	else
	{
		get_bend_start_line( last_ps, old_end, end_dir );
		VREVERSE( end_dir, end_dir );
		VSUB2( tmp_dir, new_pt, old_end );
		VUNITIZE( tmp_dir );
	}
d279 7
a285 1
	VMOVE( end_ps->ps_start, new_pt );
d287 4
a290 5
	GETSTRUCT( new_linear, wdb_pipeseg );
	new_linear->ps_type = WDB_PIPESEG_TYPE_LINEAR;
	new_linear->l.magic = WDB_PIPESEG_MAGIC;
	new_linear->ps_od = last_ps->ps_od;
	new_linear->ps_id = last_ps->ps_id;
d292 1
a292 1
	if( last_ps->ps_type != WDB_PIPESEG_TYPE_BEND )
d294 3
a296 6
		GETSTRUCT( new_bend, wdb_pipeseg );
		new_bend->ps_type = WDB_PIPESEG_TYPE_BEND;
		new_bend->l.magic = WDB_PIPESEG_MAGIC;
		new_bend->ps_od = last_ps->ps_od;
		new_bend->ps_id = last_ps->ps_id;
		VMOVE( new_bend->ps_start, old_end );
a297 31
	else
		new_bend = last_ps;

	/* get bend center for new bend */
	VCROSS( normal, end_dir, tmp_dir );
	VUNITIZE( normal );
	VCROSS( to_start, normal, end_dir );
	VUNITIZE( to_start );
	VJOIN1( new_bend->ps_bendcenter, old_end, bend_radius, to_start );

	/* calculate start point for new linear segment */
	VSUB2( tmp_dir, new_bend->ps_bendcenter, new_pt );
	angle = asin( bend_radius/MAGNITUDE( tmp_dir ) );
	mat_arb_rot( mat, new_bend->ps_bendcenter, normal, -angle );
	VCROSS( d1, tmp_dir, normal );
	MAT4X3VEC( to_end, mat, d1 );
	VUNITIZE( to_end );
	VJOIN1( new_linear->ps_start, new_bend->ps_bendcenter, bend_radius, to_end );

	if( new_bend != last_ps )
		RT_LIST_APPEND( &last_ps->l, &new_bend->l );
	RT_LIST_APPEND( &new_bend->l, &new_linear->l );

	/* make sure new bend is less than 180 degrees */
	VREVERSE( to_start, to_start );
	VCROSS( d2, to_start, normal );
	angle = atan2( VDOT( to_end, d2 ), VDOT( to_end, to_start) );
	if( angle < 0.0 )
		angle += 2.0*rt_pi;
	if( angle > rt_pi - RT_DOT_TOL )
		break_bend( new_bend, to_start, d2, angle/2.0 );
d302 1
a302 1
ins_pipeseg( pipe, new_pt )
d304 1
d307 2
a308 15
	struct wdb_pipeseg *start_ps;
	struct wdb_pipeseg *next_ps;
	struct wdb_pipeseg *new_linear;
	struct wdb_pipeseg *new_bend;
	fastf_t dist_to_start;
	vect_t tmp_dir;
	vect_t start_dir;
	vect_t normal;
	vect_t to_start;
	vect_t to_end;
	vect_t d1,d2;
	point_t old_start;
	fastf_t bend_radius;
	fastf_t angle;
	mat_t mat;
d311 2
d314 3
a316 23
	start_ps = RT_LIST_FIRST( wdb_pipeseg, &pipe->pipe_segs_head );
	RT_CKMAG( start_ps, WDB_PIPESEG_MAGIC, "pipe segment" );

	if( start_ps->ps_type == WDB_PIPESEG_TYPE_END )
	{
		/* This pipe is just an END segment */
		GETSTRUCT( new_linear, wdb_pipeseg );
		new_linear->ps_type = WDB_PIPESEG_TYPE_LINEAR;
		new_linear->l.magic = WDB_PIPESEG_MAGIC;
		new_linear->ps_od = start_ps->ps_od;
		new_linear->ps_id = start_ps->ps_id;
		VMOVE( new_linear->ps_start, new_pt );
		RT_LIST_INSERT( &start_ps->l, &new_linear->l );
	}

	VSUB2( tmp_dir, new_pt, start_ps->ps_start );
	dist_to_start = MAGNITUDE( tmp_dir );
	if( dist_to_start < RT_LEN_TOL )	/* nothing new needed */
		return;

	bend_radius = get_bend_radius( start_ps );

	if( start_ps->ps_type == WDB_PIPESEG_TYPE_LINEAR )
d318 11
a328 8
		VMOVE( old_start, start_ps->ps_start );
		next_ps = RT_LIST_NEXT( wdb_pipeseg, &start_ps->l );
		RT_CKMAG( next_ps, WDB_PIPESEG_MAGIC, "pipe segment" );
		VSUB2( start_dir, next_ps->ps_start, old_start );
		if( NEAR_ZERO( VDOT( start_dir, tmp_dir ) + 1.0, RT_DOT_TOL ) )
		{
			/* new point is in same direction as first segment, so just strech it */
			VMOVE( start_ps->ps_start, new_pt );
d332 8
a339 7
	else
	{
		get_bend_end_line( start_ps, old_start, start_dir );
		VREVERSE( start_dir, start_dir );
		VSUB2( tmp_dir, new_pt, old_start );
		VUNITIZE( tmp_dir );
	}
d341 4
a344 6
	GETSTRUCT( new_linear, wdb_pipeseg );
	new_linear->ps_type = WDB_PIPESEG_TYPE_LINEAR;
	new_linear->l.magic = WDB_PIPESEG_MAGIC;
	new_linear->ps_od = start_ps->ps_od;
	new_linear->ps_id = start_ps->ps_id;
	VMOVE( new_linear->ps_start, new_pt );
d346 1
a346 1
	if( start_ps->ps_type != WDB_PIPESEG_TYPE_BEND )
d348 3
a350 5
		GETSTRUCT( new_bend, wdb_pipeseg );
		new_bend->ps_type = WDB_PIPESEG_TYPE_BEND;
		new_bend->l.magic = WDB_PIPESEG_MAGIC;
		new_bend->ps_od = start_ps->ps_od;
		new_bend->ps_id = start_ps->ps_id;
a351 31
	else
		new_bend = start_ps;

	/* get bend center for new bend */
	VCROSS( normal, start_dir, tmp_dir );
	VUNITIZE( normal );
	VCROSS( to_start, normal, start_dir );
	VUNITIZE( to_start );
	VJOIN1( new_bend->ps_bendcenter, old_start, bend_radius, to_start );

	/* calculate end point for new linear segment */
	VSUB2( tmp_dir, new_bend->ps_bendcenter, new_pt );
	angle = asin( bend_radius/MAGNITUDE( tmp_dir ) );
	mat_arb_rot( mat, new_bend->ps_bendcenter, normal, -angle );
	VCROSS( d1, tmp_dir, normal );
	MAT4X3VEC( to_end, mat, d1 );
	VUNITIZE( to_end );
	VJOIN1( new_bend->ps_start, new_bend->ps_bendcenter, bend_radius, to_end );

	if( new_bend != start_ps )
		RT_LIST_INSERT( &start_ps->l, &new_bend->l );
	RT_LIST_INSERT( &new_bend->l, &new_linear->l );

	/* make sure new bend is less than 180 degrees */
	VREVERSE( to_start, to_start );
	VCROSS( d2, to_start, normal );
	angle = atan2( VDOT( to_end, d2 ), VDOT( to_end, to_start) );
	if( angle < 0.0 )
		angle += 2.0*rt_pi;
	if( angle > rt_pi - RT_DOT_TOL )
		break_bend( new_bend, to_start, d2, angle/2.0 );
d354 3
a356 3
struct wdb_pipeseg *
del_pipeseg( ps )
struct wdb_pipeseg *ps;
d358 3
a360 18
	struct wdb_pipeseg *next;
	struct wdb_pipeseg *prev;
	struct wdb_pipeseg *pprev;
	struct wdb_pipeseg *bend1;
	struct wdb_pipeseg *bend2;
	struct wdb_pipeseg *linear;
	vect_t trans;
	point_t start,end;
	vect_t dir1,dir2,dir3,dir4;
	vect_t normal1,normal2;
	vect_t to_center;
	vect_t to_start,to_end,v2;
	vect_t cent_to_cent;
	vect_t d2,d2_rot;
	vect_t d1,d1_rot;
	fastf_t bend_radius1,bend_radius2;
	fastf_t angle;
	mat_t mat;
d364 7
a370 5
	if( ps->ps_type == WDB_PIPESEG_TYPE_END )
	{
		rt_log( "Cannot delete END segment\n" );
		return( ps );
	}
d372 1
a372 1
	prev = RT_LIST_PREV( wdb_pipeseg, &ps->l );
d374 1
a374 4
		prev = (struct wdb_pipeseg *)NULL;

	next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
	RT_CKMAG( next, WDB_PIPESEG_MAGIC, "pipe segment" );
d376 1
a376 2
	/* Check if this is the only segment */
	if( next->ps_type == WDB_PIPESEG_TYPE_END && !prev )
d378 1
a378 1
		rt_log( "Cannot delete only segment in pipe\n" );
d382 3
a384 2
	/* Check if this is the last segment */
	if( next->ps_type == WDB_PIPESEG_TYPE_END )
d386 5
a390 8
		/* just delete the last segment */
		VMOVE( next->ps_start, ps->ps_start );
		next->ps_od = ps->ps_od;
		next->ps_id = ps->ps_id;
		RT_LIST_DEQUEUE( &ps->l );
		rt_free( (char *)ps, "del_pipeseg: ps" );
		if( prev )
			return( prev );
d392 1
a392 11
			return( next );
	}

	/* Check if this is the first segment */
	if( !prev )
	{
		/* just delete the first segment */
		RT_LIST_DEQUEUE( &ps->l );
		rt_free( (char *)ps, "del_pipeseg: ps" );
		return( next );
	}
a393 4
	/* selected segment has segments before and after it */
	if( ps->ps_type == WDB_PIPESEG_TYPE_BEND )
	{
		rt_log( "Cannot delete BEND segments in the middle of a pipe\n" );
d396 2
a397 17

	/* if selected segment is one of two consecutive linear segments,
	 * just remove one and stretch the remaining one
	 */
	if( next->ps_type == WDB_PIPESEG_TYPE_LINEAR )
	{
		if( prev->ps_type == WDB_PIPESEG_TYPE_BEND )
		{
			next->ps_od = prev->ps_od;
			next->ps_id = prev->ps_id;
			VMOVE( next->ps_start, ps->ps_start );
		}

		RT_LIST_DEQUEUE( &ps->l );
		rt_free( (char *)ps, "del_pipeseg: ps" );
		return( next );
	}
d399 1
a399 4
	if( prev->ps_type == WDB_PIPESEG_TYPE_LINEAR )
	{
		RT_LIST_DEQUEUE( &ps->l );
		rt_free( (char *)ps, "del_pipeseg: ps" );
d401 1
a401 25
	}

	/* If we reach here, selected segment is linear with bends at both ends */

	if( next->ps_type != WDB_PIPESEG_TYPE_BEND || prev->ps_type != WDB_PIPESEG_TYPE_BEND )
	{
		rt_log( "Error in del_pipeseg, linear segment not surrounded by bends!!!\n" );
		return( ps );
	}

	/* Get translation vector for moving bend segments */
	VSUB2( trans, next->ps_start, ps->ps_start );
	RT_LIST_DEQUEUE( &ps->l );
	rt_free( (char *)ps, "del_pipeseg: ps" );

	/* move all bend segments prior to "ps" by translation vector */
	while( prev->l.magic != RT_LIST_HEAD_MAGIC && prev->ps_type == WDB_PIPESEG_TYPE_BEND )
	{
		VADD2( prev->ps_start, prev->ps_start, trans );
		VADD2( prev->ps_bendcenter, prev->ps_bendcenter, trans );
		prev = RT_LIST_PREV( wdb_pipeseg, &prev->l );
	}

	/* if no linear segments, we are done */
	if( prev->l.magic == RT_LIST_HEAD_MAGIC )
a403 608
	if( prev->ps_type != WDB_PIPESEG_TYPE_LINEAR )
		rt_bomb( "del_pipeseg: Expecting a linear segment, didn't find one!!!\n" );

	linear = prev;
	bend2 = RT_LIST_NEXT( wdb_pipeseg, &linear->l );
	bend1 = RT_LIST_PREV( wdb_pipeseg, &linear->l );
	if( bend1->l.magic == RT_LIST_HEAD_MAGIC )
		bend1 = (struct wdb_pipeseg *)NULL;
	next = RT_LIST_NEXT( wdb_pipeseg, &bend2->l );

	/* bend1, linear, and bend2 must be adjusted to mate correctly */

	if( bend1 )
	{
		/* calculate new bend center for bend1 */
		get_bend_start_line( bend1, start, dir1 );
		bend_radius1 = get_bend_radius( bend1 );

		/* get line direction away from bend */
		VREVERSE( dir1, dir1 );

		VSUB2( dir2, next->ps_start, start );
		VCROSS( normal1, dir1, dir2 );

		VCROSS( to_center, normal1, dir1 );
		VUNITIZE( to_center );
		VJOIN1( bend1->ps_bendcenter, start, bend_radius1, to_center );
	}
	else
		VSUB2( dir2, next->ps_start, linear->ps_start )

	/* calculate new bend center for bend2 */
	get_bend_end_line( bend2, end, dir3 );
	bend_radius2 = get_bend_radius( bend2 );

	VREVERSE( dir3, dir3 );
	VREVERSE( dir4, dir2 );
	VCROSS( normal2, dir4, dir3 );
	VCROSS( to_center, dir3, normal2 );
	VUNITIZE( to_center );
	VJOIN1( bend2->ps_bendcenter, next->ps_start, bend_radius2, to_center );

	/* calculate angle off normal of center-to-center line for bend/linear junction */
	if( bend1 )
	{
		VSUB2( cent_to_cent, bend2->ps_bendcenter, bend1->ps_bendcenter );
		VCROSS( d1, normal1, cent_to_cent );
	}
	else
		VSUB2( cent_to_cent, bend2->ps_bendcenter, linear->ps_start )

	VCROSS( d2, normal2, cent_to_cent );

	if( bend1 )
	{
		if( VDOT( d1, d2 ) > 0.0 )
			angle = asin( (bend_radius1 - bend_radius2)/MAGNITUDE( cent_to_cent ) );
		else
			angle = asin( (bend_radius1 + bend_radius2)/MAGNITUDE( cent_to_cent ) );
	}
	else
		angle = asin( bend_radius2/MAGNITUDE( cent_to_cent ) );

	/* calulate new end points for linear segment */
	if( NEAR_ZERO( angle, RT_DOT_TOL ) )
	{
		if( bend1 )
		{
			VUNITIZE( d1 );
			VJOIN1( linear->ps_start, bend1->ps_bendcenter, bend_radius1, d1 );
		}
		VUNITIZE( d2 );
		VJOIN1( bend2->ps_start, bend2->ps_bendcenter, bend_radius2, d2 );
		return( linear );
	}

	if( bend1 )
	{
		VUNITIZE( normal1 );
		mat_arb_rot( mat, bend1->ps_bendcenter, normal1, angle );
		MAT4X3VEC( d1_rot, mat, d1 );
		VUNITIZE( d1_rot );
		VJOIN1( linear->ps_start, bend1->ps_bendcenter, bend_radius1, d1_rot );
	}

	VUNITIZE( normal2 );
	mat_arb_rot( mat, bend2->ps_bendcenter, normal2, angle );
	MAT4X3VEC( d2_rot, mat, d2 );
	VUNITIZE( d2_rot );
	VJOIN1( bend2->ps_start, bend2->ps_bendcenter, bend_radius2, d2_rot );

	/* insure that bends are less than 180 degrees */
	if( bend1 )
	{
		VSUB2( to_start, bend1->ps_start, bend1->ps_bendcenter );
		VUNITIZE( to_start );
		VSUB2( to_end, linear->ps_start, bend1->ps_bendcenter );
		VCROSS( v2, to_start, normal1 );
		angle = atan2( VDOT( to_end, v2 ), VDOT( to_end, to_start ) );
		if( angle < 0.0 )
			angle += 2.0*rt_pi;
		if( angle > rt_pi - RT_DOT_TOL )
			break_bend( bend1, to_start, v2, angle/2.0 );
	}

	VSUB2( to_start, bend2->ps_start, bend2->ps_bendcenter );
	VUNITIZE( to_start );
	next = RT_LIST_NEXT( wdb_pipeseg, &bend2->l );
	VSUB2( to_end, next->ps_start, bend2->ps_bendcenter );
	VCROSS( v2, to_start, normal2 );
	angle = atan2( VDOT( to_end, v2 ), VDOT( to_end, to_start ) );
	if( angle < 0.0 )
		angle += 2.0*rt_pi;
	if( angle > rt_pi - RT_DOT_TOL )
		break_bend( bend2, to_start, v2, angle/2.0 );

	return( linear );
}

#if 1
void
move_bend( pipe, ps, new_pt )
struct rt_pipe_internal *pipe;
struct wdb_pipeseg *ps;
point_t new_pt;
{
	struct wdb_pipeseg *bend1;
	struct wdb_pipeseg *linear;
	struct wdb_pipeseg *bend2;
	struct wdb_pipeseg *prev;
	struct wdb_pipeseg *next;
	struct wdb_pipeseg *first_bend2;
	point_t start_pt;
	vect_t start_dir;
	point_t end_pt;
	vect_t end_dir;
	point_t tmp_pt;
	vect_t ps_dir;
	fastf_t radius1;
	fastf_t radius2;
	fastf_t radius_ps;
	vect_t translat;
	vect_t norm_at_bend;

	RT_PIPE_CK_MAGIC( pipe );
	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );

	if( ps->ps_type != WDB_PIPESEG_TYPE_BEND )
	{
		rt_log( "move_bend called with non-bend pipe segment\n" );
		return;
	}

	VSUB2( translat, new_pt, ps->ps_bendcenter );

	VMOVE( ps->ps_bendcenter, new_pt );
	VADD2( ps->ps_start, ps->ps_start, translat );

	next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
	while( next->ps_type == WDB_PIPESEG_TYPE_BEND )
	{
		VADD2( next->ps_bendcenter, next->ps_bendcenter, translat );
		VADD2( next->ps_start, next->ps_start, translat );
		next = RT_LIST_NEXT( wdb_pipeseg, &next->l );
	}
	VADD2( next->ps_start, next->ps_start, translat );

	prev = RT_LIST_PREV( wdb_pipeseg, &ps->l );
	while( prev->l.magic != RT_LIST_HEAD_MAGIC && prev->ps_type == WDB_PIPESEG_TYPE_BEND )
	{
		VADD2( prev->ps_bendcenter, prev->ps_bendcenter, translat );
		VADD2( prev->ps_start, prev->ps_start, translat );
		prev = RT_LIST_PREV( wdb_pipeseg, &prev->l );
	}

	/* get bend radius */
	radius_ps = get_bend_radius( ps );

	/* solve section before bend first */
	bend2 = ps;
	prev = RT_LIST_PREV( wdb_pipeseg, &bend2->l );
	while( prev->l.magic != RT_LIST_HEAD_MAGIC && prev->ps_type == WDB_PIPESEG_TYPE_BEND )
	{
		bend2 = prev;
		prev = RT_LIST_PREV( wdb_pipeseg, &prev->l );
	}
	first_bend2 = bend2;

	linear = (struct wdb_pipeseg *)NULL;
	prev = RT_LIST_PREV( wdb_pipeseg, &bend2->l );
	while( prev->l.magic != RT_LIST_HEAD_MAGIC && prev->ps_type == WDB_PIPESEG_TYPE_LINEAR )
	{
		linear = prev;
		prev = RT_LIST_PREV( wdb_pipeseg, &prev->l );
	}

	if( linear )
	{
		bend1 = RT_LIST_PREV( wdb_pipeseg, &linear->l );
		if( bend1->l.magic == RT_LIST_HEAD_MAGIC )
			bend1 = (struct wdb_pipeseg *)NULL;
		get_bend_end_line( bend2, tmp_pt, end_dir );
		VREVERSE( end_dir, end_dir );

		if( bend1 )
		{
			radius1 = get_bend_radius( bend1 );
			get_bend_start_line( bend1, start_pt, start_dir );
			solve_pipe_to_bend( start_pt, start_dir, 1, radius1, new_pt, end_dir, radius_ps,
				bend1->ps_bendcenter, linear->ps_start, bend2->ps_start, norm_at_bend );
		}
		else
		{
			solve_pipe_to_bend( linear->ps_start, start_dir, 0, 0.0, new_pt, end_dir, radius_ps,
				tmp_pt, tmp_pt, bend2->ps_start, norm_at_bend );
		}
	}

	/* now solve section after bend */
	bend1 = ps;
	next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
	while( next->ps_type == WDB_PIPESEG_TYPE_BEND )
	{
		bend1 = next;
		next = RT_LIST_NEXT( wdb_pipeseg, &next->l );
	}

	linear = (struct wdb_pipeseg *)NULL;
	while( next->ps_type == WDB_PIPESEG_TYPE_LINEAR )
	{
		linear = next;
		next = RT_LIST_NEXT( wdb_pipeseg, &next->l );
	}

	bend2 = next;
	if( bend2->ps_type != WDB_PIPESEG_TYPE_BEND )
		bend2 = (struct wdb_pipeseg *)NULL;

	if( linear )
	{
		if( first_bend2 != bend1 )
			VSETALL( norm_at_bend, 0.0 )

		get_bend_start_line( bend1, tmp_pt, start_dir );
		if( bend2 )
		{
			radius2 = get_bend_radius( bend2 );
			get_bend_end_line( bend2, end_pt, end_dir );
			VREVERSE( end_dir, end_dir );
			solve_pipe_from_bend( norm_at_bend, new_pt, start_dir, radius_ps, end_pt, end_dir, 1, radius2,
				bend2->ps_bendcenter, linear->ps_start, bend2->ps_start );
		}
		else
		{
			struct wdb_pipeseg *next;

			next = RT_LIST_NEXT( wdb_pipeseg, &bend1->l );
			while( next->ps_type == WDB_PIPESEG_TYPE_LINEAR )
				next = RT_LIST_NEXT( wdb_pipeseg, &next->l );

			solve_pipe_from_bend( norm_at_bend, new_pt, start_dir, radius_ps, next->ps_start, end_dir, 0, 0.0,
				tmp_pt, linear->ps_start, tmp_pt );
		}
	}
}
#else
void
move_bend( pipe, ps, new_pt )
struct rt_pipe_internal *pipe;
struct wdb_pipeseg *ps;
point_t new_pt;
{
	struct wdb_pipeseg *next_bend;
	vect_t next_norm;
	struct wdb_pipeseg *prev_bend;
	vect_t prev_norm;
	struct wdb_pipeseg *bend1;
	struct wdb_pipeseg *bend2;
	struct wdb_pipeseg *linear;
	struct wdb_pipeseg *pprev;
	struct wdb_pipeseg *nnext;
	point_t tmp_pt;
	vect_t cent_to_cent;
	vect_t start1,end1,normal1;
	vect_t start2,end2,normal2;
	vect_t d1,d1_rot;
	vect_t d2,d2_rot;
	vect_t linear_dir;
	mat_t mat1_plus,mat1_minus;
	mat_t mat2_plus,mat2_minus;
	fastf_t bend_radius1,bend_radius2;
	fastf_t angle;
	vect_t trans;

	RT_PIPE_CK_MAGIC( pipe );
	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );

	if( ps->ps_type != WDB_PIPESEG_TYPE_BEND )
	{
		rt_log( "move_bend called with non-bend pipe segment\n" );
		return;
	}

	next_bend = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
	while( next_bend->ps_type == WDB_PIPESEG_TYPE_BEND )
		next_bend = RT_LIST_NEXT( wdb_pipeseg, &next_bend->l );
	while( next_bend->ps_type == WDB_PIPESEG_TYPE_LINEAR )
		next_bend = RT_LIST_NEXT( wdb_pipeseg, &next_bend->l );
	if( next_bend->ps_type != WDB_PIPESEG_TYPE_END )
	{
		get_bend_end_line( next_bend, tmp_pt, end1 );
		get_bend_start_line( next_bend, tmp_pt, start1 );
		VCROSS( next_norm, end1, start1 );
	}

	prev_bend = RT_LIST_PREV( wdb_pipeseg, &ps->l );
	while( prev_bend->l.magic != RT_LIST_HEAD_MAGIC && prev_bend->ps_type == WDB_PIPESEG_TYPE_BEND )
		prev_bend = RT_LIST_PREV( wdb_pipeseg, &prev_bend->l );
	while( prev_bend->l.magic != RT_LIST_HEAD_MAGIC && prev_bend->ps_type == WDB_PIPESEG_TYPE_LINEAR )
		prev_bend = RT_LIST_PREV( wdb_pipeseg, &prev_bend->l );
	if( prev_bend->l.magic != RT_LIST_HEAD_MAGIC )
	{
		get_bend_end_line( prev_bend, tmp_pt, end1 );
		get_bend_start_line( prev_bend, tmp_pt, start1 );
		VCROSS( prev_norm, end1, start1 );
	}

	/* get translation vector for move */
	VSUB2( trans, new_pt, ps->ps_bendcenter );

	/* move this bend */
	VMOVE( ps->ps_bendcenter, new_pt );
	VADD2( ps->ps_start, ps->ps_start, trans );

	/* move all adjacent bends also */
	bend1 = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
	while( bend1->ps_type == WDB_PIPESEG_TYPE_BEND )
	{
		VADD2( bend1->ps_bendcenter, bend1->ps_bendcenter, trans );
		VADD2( bend1->ps_start, bend1->ps_start, trans );
		bend1 = RT_LIST_NEXT( wdb_pipeseg, &bend1->l );
	}
	bend1 = RT_LIST_PREV( wdb_pipeseg, &ps->l );
	while( bend1->l.magic != RT_LIST_HEAD_MAGIC && bend1->ps_type == WDB_PIPESEG_TYPE_BEND )
	{
		VADD2( bend1->ps_bendcenter, bend1->ps_bendcenter, trans );
		VADD2( bend1->ps_start, bend1->ps_start, trans );
		bend1 = RT_LIST_PREV( wdb_pipeseg, &bend1->l );
	}

	/* find next section consisting of possibly a bend, linear section and another bend */
	linear = ps;
	while( linear->ps_type != WDB_PIPESEG_TYPE_LINEAR && linear->ps_type != WDB_PIPESEG_TYPE_END )
		linear = RT_LIST_NEXT( wdb_pipeseg, &linear->l );

	/* if a linear segment is found, an adjustment is necessary */
	if( linear->ps_type == WDB_PIPESEG_TYPE_LINEAR )
	{
		/* found a linear section that must be adjusted */

		/* move the start point of the linear section to get good
		 * end line for bend1 and a good start line for bend2
		 */
		VADD2( linear->ps_start, linear->ps_start, trans );
		bend1 = RT_LIST_PREV( wdb_pipeseg, &linear->l );

		/* look for a bend that follows the linear section */
		bend2 = linear;
		while( bend2->ps_type != WDB_PIPESEG_TYPE_BEND && bend2->ps_type != WDB_PIPESEG_TYPE_END )
			bend2 = RT_LIST_NEXT( wdb_pipeseg, &bend2->l );
		if( bend2->ps_type != WDB_PIPESEG_TYPE_BEND )
			bend2 = (struct wdb_pipeseg *)NULL;

		/* Get center to center lines between bends */
		if( bend2 )
			VSUB2( cent_to_cent, bend2->ps_bendcenter, bend1->ps_bendcenter )
		else
		{
			nnext = RT_LIST_NEXT( wdb_pipeseg, &linear->l );
			while( nnext->ps_type == WDB_PIPESEG_TYPE_LINEAR )
				nnext = RT_LIST_NEXT( wdb_pipeseg, &nnext->l );
			VSUB2( cent_to_cent, nnext->ps_start, bend1->ps_bendcenter )
		}

		/* get normal and vector normal to center-to-center line for bend1 */
		bend_radius1 = get_bend_radius( bend1 );
		get_bend_start_line( bend1, tmp_pt, start1 );
		get_bend_end_line( bend1, tmp_pt, end1 );
		VCROSS( normal1, end1, start1 );
		VUNITIZE( normal1 );
		VCROSS( d1, cent_to_cent, normal1 );

		if( bend2 )
		{
			/* get normal and vector normal to center-to-center line for bend2 */
			bend_radius2 = get_bend_radius( bend2 );
			get_bend_start_line( bend2, tmp_pt, start2 );
			get_bend_end_line( bend2, tmp_pt, end2 );
			VCROSS( normal2, end2, start2 );
			VUNITIZE( normal2 );
			VCROSS( d2, cent_to_cent, normal2 );

			if( VDOT( normal2, next_norm ) < 0.0 )
			{
				struct wdb_pipeseg *next;
				vect_t to_center;

				/* bendcenter needs to be switched */
				next = RT_LIST_NEXT( wdb_pipeseg, &bend2->l );
				VSUB2( to_center, bend2->ps_bendcenter, next->ps_start );
				VSUB2( bend2->ps_bendcenter, next->ps_start, to_center );
			}
		}

		/* calculate angle that d1 and d2 must rotate about bend centers */
		if( bend2 )
		{
			if( VDOT( d1, d2 ) < 0.0 )
				angle = asin( (bend_radius1+bend_radius2)/MAGNITUDE( cent_to_cent ) );
			else
				angle = asin( (bend_radius1-bend_radius2)/MAGNITUDE( cent_to_cent ) );
		}
		else
			angle = asin( bend_radius1/MAGNITUDE( cent_to_cent ) );

		/* rotate d1 */
		mat_arb_rot( mat1_plus, bend1->ps_bendcenter, normal1, angle );
		mat_arb_rot( mat1_minus, bend1->ps_bendcenter, normal1, -angle );
		if( bend2 )
		{
			mat_arb_rot( mat2_plus, bend2->ps_bendcenter, normal2, angle );
			mat_arb_rot( mat2_minus, bend2->ps_bendcenter, normal2, -angle );
		}
		MAT4X3VEC( d1_rot, mat1_plus, d1 );
		VUNITIZE( d1_rot );
		/* calculate new start point for linear segment */
		VJOIN1( linear->ps_start, bend1->ps_bendcenter, bend_radius1, d1_rot );

		if( bend2 )
		{
			/* rotate d2 */
			if( VDOT( d1, d2 ) < 0.0 )
				MAT4X3VEC( d2_rot, mat2_minus, d2 )
			else
				MAT4X3VEC( d2_rot, mat2_plus, d2 )
			VUNITIZE( d2_rot );
			/* calculate new start point for bend2 */
			VJOIN1( bend2->ps_start, bend2->ps_bendcenter, bend_radius2, d2_rot );
		}

		/* adjust any linear segments between "linear" and bend2 */
		if( bend2 )
			VSUB2( linear_dir, bend2->ps_start, linear->ps_start )
		else
		{
			nnext = RT_LIST_NEXT( wdb_pipeseg, &linear->l );
			while( nnext->ps_type == WDB_PIPESEG_TYPE_LINEAR )
				nnext = RT_LIST_NEXT( wdb_pipeseg, &nnext->l );
			VSUB2( linear_dir, nnext->ps_start, linear->ps_start );
		}
		VUNITIZE( linear_dir );
		nnext = RT_LIST_NEXT( wdb_pipeseg, &linear->l );
		while( nnext->ps_type == WDB_PIPESEG_TYPE_LINEAR )
		{
			vect_t old_vec;

			VSUB2( old_vec, nnext->ps_start, linear->ps_start );
			VJOIN1( nnext->ps_start, linear->ps_start, VDOT( linear_dir, old_vec ), linear_dir );
			nnext = RT_LIST_NEXT( wdb_pipeseg, &nnext->l );
		}

		/* make sure bend2 is less than 180 degrees */
		if( bend2 )
			make_bend_lt_180( bend2, normal2 );
	}

	/* search the previous sections (prior to "ps") for a bend, linear, bend arrangement */
	linear = ps;
	while( linear->l.magic != RT_LIST_HEAD_MAGIC && linear->ps_type != WDB_PIPESEG_TYPE_LINEAR )
		linear = RT_LIST_PREV( wdb_pipeseg, &linear->l );

	/* if a linear segment is found, an adjustment is necessary */
	if( linear->ps_type == WDB_PIPESEG_TYPE_LINEAR )
	{
		/* found a linear section that must be adjusted */
		bend2 = RT_LIST_NEXT( wdb_pipeseg, &linear->l );

		/* look for a bend that precedes the linear section */
		bend1 = linear;
		while( bend1->l.magic != RT_LIST_HEAD_MAGIC && bend1->ps_type != WDB_PIPESEG_TYPE_BEND )
			bend1 = RT_LIST_PREV( wdb_pipeseg, &bend1->l );
		if( bend1->l.magic == RT_LIST_HEAD_MAGIC )
			bend1 = (struct wdb_pipeseg *)NULL;

		/* Get center to center lines between bends */
		if( bend1 )
			VSUB2( cent_to_cent, bend2->ps_bendcenter, bend1->ps_bendcenter )
		else
		{
			struct wdb_pipeseg *prev=(struct wdb_pipeseg *)NULL;

			pprev = RT_LIST_PREV( wdb_pipeseg, &linear->l );
			while( pprev->ps_type == WDB_PIPESEG_TYPE_LINEAR )
			{
				prev = pprev;
				pprev = RT_LIST_PREV( wdb_pipeseg, &pprev->l );
			}
			if( prev )
				VSUB2( cent_to_cent, bend2->ps_bendcenter, prev->ps_start )
			else
				VSUB2( cent_to_cent, bend2->ps_bendcenter, linear->ps_start )
		}

		if( bend1 )
		{
			/* get normal and vector normal to center to center line for bend1 */
			bend_radius1 = get_bend_radius( bend1 );
			get_bend_start_line( bend1, tmp_pt, start1 );
			get_bend_end_line( bend1, tmp_pt, end1 );
			VCROSS( normal1, end1, start1 );
			VUNITIZE( normal1 );
			VCROSS( d1, cent_to_cent, normal1 );
		}

		/* get normal and vector normal to center to center line for bend2 */
		bend_radius2 = get_bend_radius( bend2 );
		get_bend_start_line( bend2, tmp_pt, start2 );
		get_bend_end_line( bend2, tmp_pt, end2 );
		VCROSS( normal2, end2, start2 );
		VUNITIZE( normal2 );
		VCROSS( d2, cent_to_cent, normal2 );

		/* calculate angle that d1 and d2 must rotate about bend centers */
		if( bend1 )
		{
			if( VDOT( d1, d2 ) < 0.0 )
				angle = asin( (bend_radius1+bend_radius2)/MAGNITUDE( cent_to_cent ) );
			else
				angle = asin( (bend_radius1-bend_radius2)/MAGNITUDE( cent_to_cent ) );
		}
		else
			angle = asin( bend_radius2/MAGNITUDE( cent_to_cent ) );

		mat_arb_rot( mat2_plus, bend2->ps_bendcenter, normal2, angle );
		mat_arb_rot( mat2_minus, bend2->ps_bendcenter, normal2, -angle );
		if( bend1 )
		{
			mat_arb_rot( mat1_plus, bend1->ps_bendcenter, normal1, angle );
			mat_arb_rot( mat1_minus, bend1->ps_bendcenter, normal1, -angle );
		}
		if( bend1 )
		{
			/* rotate d1 */
			MAT4X3VEC( d1_rot, mat1_plus, d1 );
			VUNITIZE( d1_rot );
			/* calculate new start point for linear segment */
			VJOIN1( linear->ps_start, bend1->ps_bendcenter, bend_radius1, d1_rot );
		}

		/* rotate d2 */
		if( bend1 )
		{
			if( VDOT( d1, d2 ) < 0.0 )
				MAT4X3VEC( d2_rot, mat2_minus, d2 )
			else
				MAT4X3VEC( d2_rot, mat2_plus, d2 )
		}
		else
			MAT4X3VEC( d2_rot, mat2_minus, d2 )

		VUNITIZE( d2_rot );
		/* calculate new start point for bend2 */
		VJOIN1( bend2->ps_start, bend2->ps_bendcenter, bend_radius2, d2_rot );

		/* adjust any linear segments between "linear" and bend2 */
		VSUB2( linear_dir, bend2->ps_start, linear->ps_start )
		VUNITIZE( linear_dir );
		nnext = RT_LIST_NEXT( wdb_pipeseg, &linear->l );
		while( nnext->ps_type == WDB_PIPESEG_TYPE_LINEAR )
		{
			vect_t old_vec;

			VSUB2( old_vec, nnext->ps_start, linear->ps_start );
			VJOIN1( nnext->ps_start, linear->ps_start, VDOT( linear_dir, old_vec ), linear_dir );
			nnext = RT_LIST_NEXT( wdb_pipeseg, &nnext->l );
		}
		/* make sure bend1 is less than 180 degrees */
		if( bend1 )
			make_bend_lt_180( bend1, normal1 );
	}

	/* make sure ps is less than 180 degrees */
	get_bend_start_line( ps, tmp_pt, start2 );
	get_bend_end_line( ps, tmp_pt, end2 );
	VCROSS( normal2, end2, start2 );
	VUNITIZE( normal2 );
	make_bend_lt_180( ps, normal2 );
}
#endif
void
move_linear( pipe, ps, new_pt )
struct rt_pipe_internal *pipe;
struct wdb_pipeseg *ps;
point_t new_pt;
{

	RT_PIPE_CK_MAGIC( pipe );
	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );
d407 1
a407 1
move_end( pipe, ps, new_pt )
d409 1
a409 1
struct wdb_pipeseg *ps;
d412 1
a415 8
}

void
move_pipeseg( pipe, ps, new_pt )
struct rt_pipe_internal *pipe;
struct wdb_pipeseg *ps;
point_t new_pt;
{
d417 1
a417 2
	RT_PIPE_CK_MAGIC( pipe );
	RT_CKMAG( ps, WDB_PIPESEG_MAGIC, "pipe segment" );
d419 2
a420 1
	switch( ps->ps_type )
d422 2
a423 12
		case WDB_PIPESEG_TYPE_BEND:
			move_bend( pipe, ps, new_pt );
			break;
		case WDB_PIPESEG_TYPE_LINEAR:
			move_linear( pipe, ps, new_pt );
			break;
		case WDB_PIPESEG_TYPE_END:
			move_end( pipe, ps, new_pt );
			break;
		default:
			rt_log( "move_pipeseg: Unrecognized PIPE segment type (%d)\n", ps->ps_type );
			break;
@


1.6
log
@Checkpoint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.5 1995/07/18 22:53:50 jra Exp jra $ (BRL)";
d59 226
d1695 147
d2174 1
a2174 1

@


1.5
log
@Added delete segment capabilities to pipe editing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.4 1995/07/17 20:17:49 jra Exp jra $ (BRL)";
d395 34
d434 1
d436 3
a438 1
	struct wdb_pipeseg *next;
d448 1
a448 1
	if( prev->l.magic != RT_LIST_HEAD_MAGIC )
d450 4
a453 1
		if( prev->ps_type == WDB_PIPESEG_TYPE_LINEAR )
d455 2
a456 3
			VSUB2( dir, pt, prev->ps_start );
			VUNITIZE( dir );
			return;
d458 1
d460 1
a460 2

	next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
d462 1
a462 3
		vect_t to_start;
		vect_t to_end;
		vect_t normal;
a467 2
		VUNITIZE( dir );
		return;
d470 4
a473 1
	rt_bomb( "get_bend_start_line: Cannot get a start line for pipe bend segment\n" );
d483 3
d494 1
d497 2
a498 1
		struct wdb_pipeseg *nnext;
d500 1
a500 4
		nnext = RT_LIST_NEXT( wdb_pipeseg, &next->l );
		VSUB2( dir, pt, nnext->ps_start );
		VUNITIZE( dir );
		return;
d502 1
a502 1
	if( next->ps_type == WDB_PIPESEG_TYPE_BEND || next->ps_type == WDB_PIPESEG_TYPE_END )
a503 4
		vect_t to_start;
		vect_t to_end;
		vect_t normal;

a507 2
		VUNITIZE( dir );
		return;
d510 4
a513 1
	rt_bomb( "get_bend_end_line: Cannot get a end line for pipe bend segment\n" );
d1467 382
@


1.4
log
@Added more pipe editing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.3 1995/07/14 19:08:08 jra Exp jra $ (BRL)";
d471 1
a471 1
		VCROSS( dir, normal, to_end );
d1188 243
@


1.3
log
@Added OD scaling.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.2 1995/07/14 14:54:31 jra Exp jra $ (BRL)";
d59 63
d130 1
d140 9
d153 5
a157 1
			if( prev->ps_id > scale*prev->ps_od )
d163 1
a163 1
			if( prev->ps_id == scale*prev->ps_od )
d172 5
a176 1
				if( next->ps_id > scale*prev->ps_od )
d182 1
a182 1
				if( next->ps_id == scale*next->ps_od )
d186 5
a190 1
			if( next->ps_id > scale*prev->ps_od )
d196 1
a196 1
			if( next->ps_id == scale*next->ps_od )
d206 4
a209 1
	ps->ps_od *= scale;
d214 4
a217 1
		prev->ps_od *= scale;
d226 7
d234 113
d349 4
a352 1
		next->ps_od *= scale;
d462 1
a462 1
	if( next->ps_type == WDB_PIPESEG_TYPE_BEND )
d510 1
d520 1
d948 238
@


1.2
log
@First working version.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edpipe.c,v 1.1 1995/07/12 12:52:59 jra Exp jra $ (BRL)";
d57 84
@


1.1
log
@Initial revision
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edsol.c,v 11.7 1995/03/08 16:38:55 jra Exp jra $ (BRL)";
d39 1
a39 1

d58 172
d238 2
d242 1
a245 1
	vect_t new_dir1,new_dir2;
d247 1
d258 2
d267 1
a267 1
	new_bend->ps_type = WDB_PIPESEG_TYPE_BEND ;
a271 1
	next = RT_LIST_NEXT( wdb_pipeseg, &ps->l );
d274 2
a277 1
	VCROSS( normal, new_dir1, new_dir2 );
a281 2
		fastf_t alpha;

d283 1
a284 1
		bend_radius = ps->ps_od;
d301 139
d441 35
a475 1
			struct wdb_pipeseg *tmp;
d477 2
a478 2
			for( RT_LIST_FOR( tmp, wdb_pipeseg, pipe_hd ) )
				rt_pipeseg_print( tmp, (double)1.0 );
d481 27
a507 2
	else
		rt_log( "Not implimented yet\n" );
@
