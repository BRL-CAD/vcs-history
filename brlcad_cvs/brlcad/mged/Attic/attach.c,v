head	11.125;
access;
symbols
	ansi-20040405-merged:11.120.2.2
	postmerge-20040405-ansi:11.123
	premerge-20040404-ansi:11.122
	postmerge-autoconf:11.122
	autoconf-freeze:11.120.10.3
	premerge-autoconf:11.122
	postmerge-20040315-windows:11.122
	premerge-20040315-windows:11.121
	windows-20040315-freeze:11.120.4.2
	autoconf-20031203:11.120
	autoconf-20031202:11.120
	autoconf-branch:11.120.0.10
	phong-branch:11.120.0.8
	photonmap-branch:11.120.0.6
	rel-6-1-DP:11.120
	windows-branch:11.120.0.4
	rel-6-0-2:11.118
	ansi-branch:11.120.0.2
	rel-6-0-1-branch:11.118.0.2
	hartley-6-0-post:11.119
	hartley-6-0-pre:11.118
	rel-6-0-1:11.118
	rel-6-0:11.118
	rel-5-4:11.107.2.1
	offsite-5-3-pre:11.112
	rel-5-3:11.107.2.1
	rel-5-2:11.107
	rel-5-1-branch:11.107.0.2
	rel-5-1:11.107
	rel-5-0:11.101
	rel-5-0-beta:11.99
	rel-4-5:11.83
	ctj-4-5-post:11.65
	ctj-4-5-pre:11.65
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1
	rt-2:2.10;
locks; strict;
comment	@ * @;


11.125
date	2004.05.21.17.47.35;	author morrison;	state dead;
branches;
next	11.124;

11.124
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.123;

11.123
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.122;

11.122
date	2004.03.16.21.15.10;	author morrison;	state Exp;
branches;
next	11.121;

11.121
date	2004.02.02.17.39.31;	author morrison;	state Exp;
branches;
next	11.120;

11.120
date	2002.08.20.17.08.21;	author jra;	state Exp;
branches
	11.120.2.1
	11.120.4.1
	11.120.10.1;
next	11.119;

11.119
date	2002.08.15.20.55.31;	author hartley;	state Exp;
branches;
next	11.118;

11.118
date	2001.10.17.07.40.04;	author morrison;	state Exp;
branches;
next	11.117;

11.117
date	2001.08.11.13.16.11;	author butler;	state Exp;
branches;
next	11.116;

11.116
date	2001.08.02.17.36.52;	author jra;	state Exp;
branches;
next	11.115;

11.115
date	2001.07.28.04.56.15;	author jra;	state Exp;
branches;
next	11.114;

11.114
date	2001.06.01.19.23.22;	author bparker;	state Exp;
branches;
next	11.113;

11.113
date	2001.04.02.21.20.40;	author bparker;	state Exp;
branches;
next	11.112;

11.112
date	2000.11.14.20.42.16;	author bparker;	state Exp;
branches;
next	11.111;

11.111
date	2000.10.24.15.15.56;	author mike;	state Exp;
branches;
next	11.110;

11.110
date	2000.09.07.02.23.41;	author mike;	state Exp;
branches;
next	11.109;

11.109
date	2000.08.19.03.10.40;	author mike;	state Exp;
branches;
next	11.108;

11.108
date	2000.08.19.03.10.10;	author mike;	state Exp;
branches;
next	11.107;

11.107
date	2000.01.21.15.24.53;	author bparker;	state Exp;
branches
	11.107.2.1;
next	11.106;

11.106
date	99.12.30.20.18.32;	author jra;	state Exp;
branches;
next	11.105;

11.105
date	99.10.28.14.22.11;	author bparker;	state Exp;
branches;
next	11.104;

11.104
date	99.10.27.17.40.17;	author bparker;	state Exp;
branches;
next	11.103;

11.103
date	99.10.26.17.33.01;	author bparker;	state Exp;
branches;
next	11.102;

11.102
date	99.10.22.21.38.51;	author bparker;	state Exp;
branches;
next	11.101;

11.101
date	99.09.10.23.10.23;	author bparker;	state Exp;
branches;
next	11.100;

11.100
date	99.07.23.20.23.46;	author bparker;	state Exp;
branches;
next	11.99;

11.99
date	99.05.14.22.19.43;	author bparker;	state Exp;
branches;
next	11.98;

11.98
date	99.03.18.18.00.42;	author bparker;	state Exp;
branches;
next	11.97;

11.97
date	99.01.27.14.40.35;	author bparker;	state Exp;
branches;
next	11.96;

11.96
date	99.01.21.18.32.36;	author bparker;	state Exp;
branches;
next	11.95;

11.95
date	99.01.12.17.56.33;	author bparker;	state Exp;
branches;
next	11.94;

11.94
date	98.12.29.20.46.24;	author bparker;	state Exp;
branches;
next	11.93;

11.93
date	98.12.15.15.56.01;	author bparker;	state Exp;
branches;
next	11.92;

11.92
date	98.11.06.21.56.59;	author bparker;	state Exp;
branches;
next	11.91;

11.91
date	98.10.21.17.29.16;	author bparker;	state Exp;
branches;
next	11.90;

11.90
date	98.08.13.11.58.40;	author bparker;	state Exp;
branches;
next	11.89;

11.89
date	98.06.25.07.37.24;	author mike;	state Exp;
branches;
next	11.88;

11.88
date	98.06.24.18.21.53;	author bparker;	state Exp;
branches;
next	11.87;

11.87
date	98.06.11.14.28.08;	author bparker;	state Exp;
branches;
next	11.86;

11.86
date	98.03.19.18.00.08;	author bparker;	state Exp;
branches;
next	11.85;

11.85
date	98.03.06.22.32.57;	author bparker;	state Exp;
branches;
next	11.84;

11.84
date	98.02.20.23.12.39;	author bparker;	state Exp;
branches;
next	11.83;

11.83
date	98.02.06.21.58.47;	author bparker;	state Exp;
branches;
next	11.82;

11.82
date	98.01.28.16.01.12;	author bparker;	state Exp;
branches;
next	11.81;

11.81
date	97.12.23.14.25.19;	author bparker;	state Exp;
branches;
next	11.80;

11.80
date	97.11.26.21.33.44;	author bparker;	state Exp;
branches;
next	11.79;

11.79
date	97.11.19.21.47.22;	author bparker;	state Exp;
branches;
next	11.78;

11.78
date	97.11.14.15.12.52;	author bparker;	state Exp;
branches;
next	11.77;

11.77
date	97.11.03.15.16.43;	author bparker;	state Exp;
branches;
next	11.76;

11.76
date	97.10.10.21.05.00;	author bparker;	state Exp;
branches;
next	11.75;

11.75
date	97.10.10.16.55.40;	author bparker;	state Exp;
branches;
next	11.74;

11.74
date	97.10.08.13.47.36;	author bparker;	state Exp;
branches;
next	11.73;

11.73
date	97.09.11.13.30.43;	author bparker;	state Exp;
branches;
next	11.72;

11.72
date	97.09.08.19.46.37;	author bparker;	state Exp;
branches;
next	11.71;

11.71
date	97.09.08.18.22.01;	author bparker;	state Exp;
branches;
next	11.70;

11.70
date	97.09.03.14.08.11;	author bparker;	state Exp;
branches;
next	11.69;

11.69
date	97.07.25.20.53.36;	author bparker;	state Exp;
branches;
next	11.68;

11.68
date	97.07.17.20.50.42;	author bparker;	state Exp;
branches;
next	11.67;

11.67
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.66;

11.66
date	97.06.25.13.32.44;	author bparker;	state Exp;
branches;
next	11.65;

11.65
date	97.05.29.14.06.46;	author bparker;	state Exp;
branches;
next	11.64;

11.64
date	97.05.22.03.42.13;	author mike;	state Exp;
branches;
next	11.63;

11.63
date	97.05.22.03.35.31;	author mike;	state Exp;
branches;
next	11.62;

11.62
date	97.05.21.12.43.42;	author bparker;	state Exp;
branches;
next	11.61;

11.61
date	97.05.08.14.31.27;	author bparker;	state Exp;
branches;
next	11.60;

11.60
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.59;

11.59
date	97.04.23.18.26.17;	author bparker;	state Exp;
branches;
next	11.58;

11.58
date	97.04.18.12.28.53;	author bparker;	state Exp;
branches;
next	11.57;

11.57
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.56;

11.56
date	97.04.04.19.54.00;	author bparker;	state Exp;
branches;
next	11.55;

11.55
date	97.03.20.23.01.19;	author bparker;	state Exp;
branches;
next	11.54;

11.54
date	97.03.20.14.45.52;	author bparker;	state Exp;
branches;
next	11.53;

11.53
date	97.03.07.02.51.55;	author mike;	state Exp;
branches;
next	11.52;

11.52
date	97.03.06.21.37.56;	author bparker;	state Exp;
branches;
next	11.51;

11.51
date	97.03.06.14.08.17;	author bparker;	state Exp;
branches;
next	11.50;

11.50
date	97.02.28.21.26.37;	author bparker;	state Exp;
branches;
next	11.49;

11.49
date	97.02.14.22.18.26;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	97.02.06.22.08.56;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	97.01.29.23.13.32;	author bparker;	state Exp;
branches;
next	11.46;

11.46
date	97.01.24.20.55.30;	author bparker;	state Exp;
branches;
next	11.45;

11.45
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	11.44;

11.44
date	97.01.10.21.58.32;	author bparker;	state Exp;
branches;
next	11.43;

11.43
date	97.01.02.22.12.41;	author bparker;	state Exp;
branches;
next	11.42;

11.42
date	97.01.02.19.38.47;	author bparker;	state Exp;
branches;
next	11.41;

11.41
date	96.12.04.21.19.21;	author bparker;	state Exp;
branches;
next	11.40;

11.40
date	96.11.19.21.04.59;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	96.10.18.13.53.51;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	96.10.09.16.55.11;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	96.10.03.20.22.09;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	96.09.30.19.43.18;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	96.09.26.20.39.30;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	96.09.25.19.56.53;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	96.09.23.18.38.45;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	96.09.17.21.22.01;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	96.08.28.19.42.55;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	96.08.22.20.52.01;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	96.07.30.21.31.40;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	96.07.25.18.42.12;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	96.03.27.22.00.44;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	96.03.25.21.58.04;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	96.03.22.22.57.01;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	96.03.22.18.34.30;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	96.03.11.21.47.21;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	96.03.08.18.32.04;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	96.02.28.21.37.11;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	96.02.12.21.46.28;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.01.25.22.26.39;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.01.22.22.51.03;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.01.17.22.05.07;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.01.05.22.08.48;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	95.12.27.22.35.54;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	95.11.09.22.22.05;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	95.09.01.15.13.42;	author cnuzman;	state Exp;
branches;
next	11.6;

11.6
date	95.08.24.17.28.46;	author cnuzman;	state Exp;
branches;
next	11.5;

11.5
date	95.08.17.19.59.14;	author cnuzman;	state Exp;
branches;
next	11.4;

11.4
date	95.07.25.21.58.09;	author cnuzman;	state Exp;
branches;
next	11.3;

11.3
date	95.06.16.17.50.53;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.03.46;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.38;	author mike;	state Rel4_4;
branches;
next	10.11;

10.11
date	94.12.27.16.58.23;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.12.16.19.35.26;	author gdurf;	state Exp;
branches;
next	10.9;

10.9
date	94.10.14.17.07.38;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.08.10.21.43.02;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.08.09.14.56.16;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.06.01.16.02.06;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.06.01.11.51.03;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	93.11.05.12.22.39;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.07.13.21.01.06;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.08.24.19.51.27;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.05;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	91.10.10.00.46.52;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.01.47;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.04.06.20.38.45;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.02.14.22.23.32;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.55.18;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.35.26;	author mike;	state Rel3_0;
branches;
next	7.8;

7.8
date	88.09.16.02.45.12;	author reschly;	state Exp;
branches;
next	7.7;

7.7
date	88.09.10.06.30.41;	author stay;	state Exp;
branches;
next	7.6;

7.6
date	88.09.10.06.24.27;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.05.15.23.04.42;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.03.02.23.22.59;	author phil;	state Exp;
branches;
next	7.3;

7.3
date	88.01.13.12.29.14;	author stay;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.03.27;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.58.31;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.10.28.21.07.45;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.08.01.44;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.17.46;	author mike;	state Rel;
branches;
next	4.4;

4.4
date	87.05.28.22.46.07;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.13.00.05.24;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.03.01.25.33;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.19.05;	author mike;	state Rel1;
branches;
next	2.18;

2.18
date	86.11.13.14.03.56;	author mike;	state Exp;
branches;
next	2.17;

2.17
date	86.10.29.00.22.00;	author mike;	state Exp;
branches;
next	2.16;

2.16
date	86.09.23.17.39.52;	author mike;	state Exp;
branches;
next	2.15;

2.15
date	86.08.14.22.20.25;	author mike;	state Exp;
branches;
next	2.14;

2.14
date	86.08.13.00.05.42;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	86.08.12.06.46.39;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	86.06.12.00.36.06;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	86.04.09.01.10.17;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	85.08.07.05.16.36;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	85.06.07.01.11.00;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	85.06.03.17.42.02;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.06.03.16.48.08;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.05.29.23.15.54;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.03.28.22.24.31;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.03.22.10.50.58;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.03.15.05.02.44;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.14.15.57.00;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.53.38;	author mike;	state Prod;
branches;
next	1.9;

1.9
date	85.03.08.20.52.13;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	85.02.14.00.27.10;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	85.02.02.01.38.37;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	85.01.19.04.07.09;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	85.01.19.02.28.24;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.01.17.07.27.41;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.01.16.01.56.12;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.22.06.55.36;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.20.04.21.58;	author mike;	state Exp;
branches;
next	;

11.107.2.1
date	2000.11.14.20.38.09;	author bparker;	state Exp;
branches;
next	;

11.120.2.1
date	2002.09.19.18.01.59;	author morrison;	state Exp;
branches;
next	11.120.2.2;

11.120.2.2
date	2004.03.17.21.21.54;	author morrison;	state Exp;
branches;
next	;

11.120.4.1
date	2002.09.26.23.04.08;	author morrison;	state Exp;
branches;
next	11.120.4.2;

11.120.4.2
date	2004.03.11.23.46.32;	author morrison;	state Exp;
branches;
next	;

11.120.10.1
date	2004.02.12.18.34.12;	author erikg;	state Exp;
branches;
next	11.120.10.2;

11.120.10.2
date	2004.03.15.14.07.35;	author erikg;	state Exp;
branches;
next	11.120.10.3;

11.120.10.3
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@
Attach to & detach from display manager.
@


11.125
log
@moved to src/mged/
@
text
@/*
 *			A T T A C H . C
 *
 * Functions -
 *	f_refresh	request display refresh
 *	f_attach	attach display device
 *	attach		attach to a given display processor
 *	f_release	release display device
 *	release		guts for f_release
 *  
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/attach.c,v 11.124 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#ifdef USE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
#include <stdio.h>
#ifndef WIN32
#include <sys/time.h>		/* for struct timeval */
#endif
#include "machine.h"
#include "externs.h"
#include "bu.h"
#ifdef DM_X
#  include "tk.h"
#  include "itk.h"
#else
#  include "tcl.h"
#endif
#include "vmath.h"
#include "raytrace.h"
#include "dm-Null.h"
#include "./ged.h"
#include "./titles.h"
#include "./sedit.h"
#include "./mged_solid.h"
#include "./mged_dm.h"

#define NEED_GUI(_type) ( \
	IS_DM_TYPE_OGL(_type) || \
	IS_DM_TYPE_GLX(_type) || \
	IS_DM_TYPE_PEX(_type) || \
	IS_DM_TYPE_X(_type) )

/* All systems can compile these! */
extern int Plot_dm_init(struct dm_list *o_dm_list, int argc, char **argv);
extern int PS_dm_init(struct dm_list *o_dm_list, int argc, char **argv);

#ifdef DM_X
#ifndef WIN32
extern int X_dm_init();
extern void X_fb_open();
#endif

#ifdef DM_OGL
extern int Ogl_dm_init();
extern void Ogl_fb_open();
#endif
#endif /* DM_X */

#ifdef DM_GLX
extern int Glx_dm_init();
#endif
#ifdef DM_PEX
extern int Pex_dm_init();
#endif

extern void share_dlist(struct dm_list *dlp2);	/* defined in share.c */
extern void set_port(void);		/* defined in fbserv.c */
extern void predictor_init(void);	/* defined in predictor.c */
extern void view_ring_init(struct _view_state *vsp1, struct _view_state *vsp2); /* defined in chgview.c */

#ifndef WIN32
extern void Tk_CreateCanvasBezierType();
#endif

#ifdef DM_X
extern Tk_Window tkwin;
#endif
extern struct _color_scheme default_color_scheme;

int gui_setup(char *dstr);
int mged_attach(struct w_dm *wp, int argc, char **argv);
void get_attached(void);
void print_valid_dm(void);
void dm_var_init(struct dm_list *initial_dm_list);
void mged_slider_init_vls(struct dm_list *p);
void mged_slider_free_vls(struct dm_list *p);
void mged_link_vars(struct dm_list *p);

#if 0
static int do_2nd_attach_prompt();
#endif
void mged_fb_open(void);
void mged_fb_close(void);

int mged_default_dlist = 0;   /* This variable is available via Tcl for controlling use of display lists */
struct dm_list head_dm_list;  /* list of active display managers */
struct dm_list *curr_dm_list;
char tmp_str[1024];
static int windowbounds[6] = { XMIN, XMAX, YMIN, YMAX, (int)GED_MIN, (int)GED_MAX };

struct w_dm which_dm[] = {
  { DM_TYPE_PLOT, "plot", Plot_dm_init },  /* DM_PLOT_INDEX defined in mged_dm.h */
  { DM_TYPE_PS, "ps", PS_dm_init },      /* DM_PS_INDEX defined in mged_dm.h */
#ifdef DM_X
#ifndef WIN32
  { DM_TYPE_X, "X", X_dm_init },
#endif
#ifdef DM_OGL
  { DM_TYPE_OGL, "ogl", Ogl_dm_init },
#endif
#endif
#ifdef DM_GLX
  { DM_TYPE_GLX, "glx", Glx_dm_init },
#endif
#ifdef DM_PEX
  { DM_TYPE_PEX, "pex", Pex_dm_init },
#endif
  { -1, (char *)NULL, (int (*)())NULL}
};


int
release(char *name, int need_close)
{
  struct dm_list *save_dm_list = DM_LIST_NULL;

  if(name != NULL){
    struct dm_list *p;

    if(!strcmp("nu", name))
      return TCL_OK;  /* Ignore */

    FOR_ALL_DISPLAYS(p, &head_dm_list.l){
      if(strcmp(name, bu_vls_addr(&p->dml_dmp->dm_pathName)))
	continue;

      /* found it */
      if(p != curr_dm_list){
	save_dm_list = curr_dm_list;
	curr_dm_list = p;
      }
      break;
    }

    if(p == &head_dm_list){
      Tcl_AppendResult(interp, "release: ", name,
		       " not found\n", (char *)NULL);
      return TCL_ERROR;
    }
  }else if(dmp && !strcmp("nu", bu_vls_addr(&pathName)))
      return TCL_OK;  /* Ignore */

  if(fbp){
    if(mged_variables->mv_listen){
      /* drop all clients */
      mged_variables->mv_listen = 0;
      set_port();
    }

    /* release framebuffer resources */
    mged_fb_close();
  }

  /*
   *  This saves the state of the resoures to the "nu" display manager, which
   *  is beneficial only if closing the last display manager. So when
   *  another display manager is opened, it looks like the last one
   *  the user had open. This depends on "nu" always being last in the list.
   */
  usurp_all_resources(BU_LIST_LAST(dm_list, &head_dm_list.l), curr_dm_list);

  /* If this display is being referenced by a command window,
     then remove the reference  */
  if(curr_dm_list->dml_tie != NULL)
    curr_dm_list->dml_tie->cl_tie = (struct dm_list *)NULL;

  if(need_close)
    DM_CLOSE(dmp);

  RT_FREE_VLIST(&curr_dm_list->dml_p_vlist);
  BU_LIST_DEQUEUE( &curr_dm_list->l );
  mged_slider_free_vls(curr_dm_list);
  bu_free( (genptr_t)curr_dm_list, "release: curr_dm_list" );

  if(save_dm_list != DM_LIST_NULL)
    curr_dm_list = save_dm_list;
  else
    curr_dm_list = (struct dm_list *)head_dm_list.l.forw;

  return TCL_OK;
}

int
f_release(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  if(argc < 1 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help release");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(argc == 2){
    int status;
    struct bu_vls vls1;

    bu_vls_init(&vls1);

    if(*argv[1] != '.')
      bu_vls_printf(&vls1, ".%s", argv[1]);
    else
      bu_vls_strcpy(&vls1, argv[1]);

    status = release(bu_vls_addr(&vls1), 1);

    bu_vls_free(&vls1);
    return status;
  }else
    return release((char *)NULL, 1);
}

#if 0
static int
do_2nd_attach_prompt()
{
  char *dm_default;
  char  hostname[80];
  char  display[82];
  struct bu_vls prompt;


  bu_vls_init(&prompt);

  /* get or create the default display */
  if( (dm_default = getenv("DISPLAY")) == NULL ) {
    /* Env not set, use local host */
    gethostname( hostname, 80 );
    hostname[79] = '\0';
    (void)sprintf( display, "%s:0", hostname );
    dm_default = display;
  }

  bu_vls_printf(&prompt, "Display [%s]? ", dm_default);

  Tcl_AppendResult(interp, MORE_ARGS_STR, bu_vls_addr(&prompt), (char *)NULL);
  bu_vls_printf(&curr_cmd_list->cl_more_default, "%s", dm_default);

  return TCL_ERROR;
}
#endif

int
f_attach(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  register struct w_dm *wp;

  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help attach");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    print_valid_dm();
    return TCL_ERROR;
  }

  /* Look at last argument, skipping over any options which preceed it */
  for( wp = &which_dm[2]; wp->type != -1; wp++ )
    if( strcmp(argv[argc - 1], wp->name ) == 0 )
      break;

  if(wp->type == -1){
    Tcl_AppendResult(interp, "attach(", argv[argc - 1], "): BAD\n", (char *)NULL);
    print_valid_dm();
    return TCL_ERROR;
  }

  return mged_attach(wp, argc, argv);
}

void
print_valid_dm(void)
{
    Tcl_AppendResult(interp, "\tThe following display manager types are valid: ", (char *)NULL);
#ifdef DM_X
#ifndef WIN32
    Tcl_AppendResult(interp, "X  ", (char *)NULL);
#endif
#ifdef DM_OGL
    Tcl_AppendResult(interp, "ogl  ", (char *)NULL);
#endif
#endif
#ifdef DM_GLX
    Tcl_AppendResult(interp, "glx", (char *)NULL);
#endif
    Tcl_AppendResult(interp, "\n", (char *)NULL);
}

int
mged_attach(
	struct w_dm *wp,
	int argc,
	char *argv[])
{
  register struct dm_list *o_dm_list;

  o_dm_list = curr_dm_list;
  BU_GETSTRUCT(curr_dm_list, dm_list);

  /* initialize predictor stuff */
  BU_LIST_INIT(&curr_dm_list->dml_p_vlist);
  predictor_init();

  /* Only need to do this once */
#ifdef DM_X
  if(tkwin == NULL && NEED_GUI(wp->type)){
    struct dm *tmp_dmp;
    struct bu_vls tmp_vls;

    /* look for "-d display_string" and use it if provided */
    BU_GETSTRUCT(tmp_dmp, dm);
    bu_vls_init(&tmp_dmp->dm_pathName);
    bu_vls_init(&tmp_dmp->dm_dName);
    bu_vls_init(&tmp_vls);
    dm_processOptions(tmp_dmp, &tmp_vls, argc - 1, argv + 1);
    if(strlen(bu_vls_addr(&tmp_dmp->dm_dName))){
      if(gui_setup(bu_vls_addr(&tmp_dmp->dm_dName)) == TCL_ERROR){
	bu_free( (genptr_t)curr_dm_list, "f_attach: dm_list" );
	curr_dm_list = o_dm_list;
	bu_vls_free(&tmp_dmp->dm_pathName);
	bu_vls_free(&tmp_dmp->dm_dName);
	bu_vls_free(&tmp_vls);
	bu_free((genptr_t)tmp_dmp, "mged_attach: tmp_dmp");
	return TCL_ERROR;
      }
    } else if(gui_setup((char *)NULL) == TCL_ERROR){
      bu_free( (genptr_t)curr_dm_list, "f_attach: dm_list" );
      curr_dm_list = o_dm_list;
      bu_vls_free(&tmp_dmp->dm_pathName);
      bu_vls_free(&tmp_dmp->dm_dName);
      bu_vls_free(&tmp_vls);
      bu_free((genptr_t)tmp_dmp, "mged_attach: tmp_dmp");
      return TCL_ERROR;
    }

    bu_vls_free(&tmp_dmp->dm_pathName);
    bu_vls_free(&tmp_dmp->dm_dName);
    bu_vls_free(&tmp_vls);
    bu_free((genptr_t)tmp_dmp, "mged_attach: tmp_dmp");
  }
#endif

  BU_LIST_APPEND(&head_dm_list.l, &curr_dm_list->l);

  if(wp->init(o_dm_list, argc, argv) == TCL_ERROR)
    goto Bad;

  /* initialize the background color */
  cs_set_bg();

  mged_link_vars(curr_dm_list);

  Tcl_ResetResult(interp);
  Tcl_AppendResult(interp, "ATTACHING ", dmp->dm_name, " (", dmp->dm_lname,
		   ")\n", (char *)NULL);

#ifdef DO_DISPLAY_LISTS
  share_dlist(curr_dm_list);

  if(displaylist && mged_variables->mv_dlist && !dlist_state->dl_active){
    createDLists(&dgop->dgo_headSolid); 
    dlist_state->dl_active = 1;
  }
#endif

  DM_SET_WIN_BOUNDS(dmp, windowbounds);
  mged_fb_open();

  return TCL_OK;

Bad:
  Tcl_AppendResult(interp, "attach(", argv[argc - 1], "): BAD\n", (char *)NULL);

  if(dmp != (struct dm *)0)
    release((char *)NULL, 1);  /* release() will call dm_close */
  else
    release((char *)NULL, 0);  /* release() will not call dm_close */

  return TCL_ERROR;
}

void
get_attached(void)
{
  int argc;
  char *argv[3];
  char line[80];
  register struct w_dm *wp;

  while(1){
    bu_log("attach (nu");
    /* skip plot and ps */
    wp = &which_dm[2];
    for( ; wp->type != -1; wp++ )
      bu_log("|%s", wp->name);
    bu_log(")[nu]? ");
    (void)fgets(line, sizeof(line), stdin); /* \n, Null terminated */

    if(line[0] == '\n' || strncmp(line, "nu", 2) == 0)
      return;  /* Nothing more to do. */

    line[strlen(line)-1] = '\0';        /* remove newline */

    for( wp = &which_dm[2]; wp->type != -1; wp++ )
      if( strcmp( line, wp->name ) == 0 )
	break;

    if( wp->type != -1 )
      break;

    /* Not a valid choice, loop. */
  }

  argc = 2;
  argv[0] = "";
  argv[1] = "";
  argv[2] = (char *)NULL;
  (void)mged_attach(wp, argc, argv);
}


int
gui_setup(char *dstr)
{
#ifdef DM_X
  struct bu_vls vls;

  /* initialize only once */
  if(tkwin != NULL)
    return TCL_OK;

  bu_vls_init(&vls);

  if(dstr != (char *)NULL){
    bu_vls_strcpy(&vls, "env(DISPLAY)");
    Tcl_SetVar(interp, bu_vls_addr(&vls), dstr, TCL_GLOBAL_ONLY);
  }

  /* This runs the tk.tcl script */
  if(Tk_Init(interp) == TCL_ERROR){
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* Add Bezier Curves to the canvas widget */
#ifndef WIN32
  Tk_CreateCanvasBezierType();
#endif

  /* Initialize [incr Tk] */
  if (Itk_Init(interp) == TCL_ERROR) {
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* Import [incr Tk] commands into the global namespace */
  if (Tcl_Import(interp, Tcl_GetGlobalNamespace(interp),
		 "::itk::*", /* allowOverwrite */ 1) != TCL_OK) {
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* Initialize the Iwidgets package */
  if (Tcl_Eval(interp, "package require Iwidgets") != TCL_OK) {
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* Import iwidgets into the global namespace */
  if (Tcl_Import(interp, Tcl_GetGlobalNamespace(interp),
		 "::iwidgets::*", /* allowOverwrite */ 1) != TCL_OK) {
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* Add Bezier Curves to the canvas widget */
#ifndef WIN32
  Tk_CreateCanvasBezierType();
#endif


  /* Initialize libdm */
  (void)Dm_Init(interp);

  /* Initialize libfb */
  (void)Fb_Init(interp);

  if((tkwin = Tk_MainWindow(interp)) == NULL){
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* create the event handler */
  Tk_CreateGenericHandler(doEvent, (ClientData)NULL);

  bu_vls_strcpy(&vls, "wm withdraw . ; tk appname mged");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
#endif /* DM_X */

  return TCL_OK;
}


/*
 *			F _ D M
 *
 *  Run a display manager specific command(s).
 */
int
f_dm(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  if( !cmd_hook ){
    Tcl_AppendResult(interp, "The '", dmp->dm_name,
		     "' display manager does not support local commands.\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help dm");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  return cmd_hook( argc-1, argv+1 );
}

/*
 *			 I S _ D M _ N U L L
 *
 *  Returns -
 *	 0	If the display manager goes to a real screen.
 *	!0	If the null display manager is attached.
 */
int
is_dm_null(void)
{
  return(curr_dm_list == &head_dm_list);
}

void
dm_var_init(struct dm_list *initial_dm_list)
{
  BU_GETSTRUCT(adc_state, _adc_state);
  *adc_state = *initial_dm_list->dml_adc_state;			/* struct copy */
  adc_state->adc_rc = 1;
#if 0
  adc_state->adc_a1 = adc_state->adc_a2 = 45.0;
#endif

  BU_GETSTRUCT(menu_state, _menu_state);
  *menu_state = *initial_dm_list->dml_menu_state;		/* struct copy */
  menu_state->ms_rc = 1;

  BU_GETSTRUCT(rubber_band, _rubber_band);
  *rubber_band = *initial_dm_list->dml_rubber_band;		/* struct copy */
  rubber_band->rb_rc = 1;

  BU_GETSTRUCT(mged_variables, _mged_variables);
  *mged_variables = *initial_dm_list->dml_mged_variables;	/* struct copy */
  mged_variables->mv_rc = 1;
  mged_variables->mv_dlist = mged_default_dlist;
  mged_variables->mv_listen = 0;
  mged_variables->mv_port = 0;
  mged_variables->mv_fb = 0;

  BU_GETSTRUCT(color_scheme, _color_scheme);
#if 0
  /* initialize using the last curr_dm_list */
  *color_scheme = *initial_dm_list->dml_color_scheme;		/* struct copy */
#else
  /* initialize using the nu display manager */
  *color_scheme = *BU_LIST_LAST(dm_list, &head_dm_list.l)->dml_color_scheme;
#endif
  color_scheme->cs_rc = 1;

  BU_GETSTRUCT(grid_state, _grid_state);
  *grid_state = *initial_dm_list->dml_grid_state;		/* struct copy */
  grid_state->gr_rc = 1;

  BU_GETSTRUCT(axes_state, _axes_state);
  *axes_state = *initial_dm_list->dml_axes_state;		/* struct copy */
  axes_state->ax_rc = 1;

  BU_GETSTRUCT(dlist_state, _dlist_state);
  dlist_state->dl_rc = 1;

  BU_GETSTRUCT(view_state, _view_state);
  *view_state = *initial_dm_list->dml_view_state;			/* struct copy */
  view_state->vs_vop = vo_open_cmd("");
  *view_state->vs_vop = *initial_dm_list->dml_view_state->vs_vop;	/* struct copy */
  view_state->vs_vop->vo_clientData = view_state;
  view_state->vs_rc = 1;
  view_ring_init(curr_dm_list->dml_view_state, (struct _view_state *)NULL);

  dirty = 1;
  mapped = 1;
  netfd = -1;
  owner = 1;
  am_mode = AMM_IDLE;
  adc_auto = 1;
  grid_auto_size = 1;
}

void
mged_slider_init_vls(struct dm_list *p)
{
  bu_vls_init(&p->dml_fps_name);
  bu_vls_init(&p->dml_aet_name);
  bu_vls_init(&p->dml_ang_name);
  bu_vls_init(&p->dml_center_name);
  bu_vls_init(&p->dml_size_name);
  bu_vls_init(&p->dml_adc_name);
}

void
mged_slider_free_vls(struct dm_list *p)
{
  if (BU_VLS_IS_INITIALIZED(&p->dml_fps_name)) {
    bu_vls_free(&p->dml_fps_name);
    bu_vls_free(&p->dml_aet_name);
    bu_vls_free(&p->dml_ang_name);
    bu_vls_free(&p->dml_center_name);
    bu_vls_free(&p->dml_size_name);
    bu_vls_free(&p->dml_adc_name);
  }
}

void
mged_link_vars(struct dm_list *p)
{
  mged_slider_init_vls(p);

  bu_vls_printf(&p->dml_fps_name, "%s(%S,fps)", MGED_DISPLAY_VAR,
		&p->dml_dmp->dm_pathName);
  bu_vls_printf(&p->dml_aet_name, "%s(%S,aet)", MGED_DISPLAY_VAR,
		&p->dml_dmp->dm_pathName);
  bu_vls_printf(&p->dml_ang_name, "%s(%S,ang)", MGED_DISPLAY_VAR,
		&p->dml_dmp->dm_pathName);
  bu_vls_printf(&p->dml_center_name, "%s(%S,center)", MGED_DISPLAY_VAR,
		&p->dml_dmp->dm_pathName);
  bu_vls_printf(&p->dml_size_name, "%s(%S,size)", MGED_DISPLAY_VAR,
		&p->dml_dmp->dm_pathName);
  bu_vls_printf(&p->dml_adc_name, "%s(%S,adc)", MGED_DISPLAY_VAR,
		&p->dml_dmp->dm_pathName);
}

int
f_get_dm_list(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  struct dm_list *dlp;

  if(argc != 1){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helpdevel get_dm_list");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
    Tcl_AppendElement(interp, bu_vls_addr(&dlp->dml_dmp->dm_pathName));

  return TCL_OK;
}

void
mged_fb_open(void)
{
#ifdef DM_X
#ifndef WIN32
  if(dmp->dm_type == DM_TYPE_X)
    X_fb_open();
#endif
#ifdef DM_OGL
#ifndef WIN32
  else 
#endif
if(dmp->dm_type == DM_TYPE_OGL)
    Ogl_fb_open();
#endif
#endif
}

void
mged_fb_close(void)
{
#ifdef DM_X
  struct bu_vls vls;

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "fb_close_existing %lu", fbp);
  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);

  fbp = (FBIO *)0;
#endif
}
@


11.124
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/attach.c,v 11.123 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.123
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d27 5
a31 1
#include "conf.h"
@


11.122
log
@merge of windows-6-0-branch into head
@
text
@d62 2
a63 2
extern int Plot_dm_init();
extern int PS_dm_init();
d84 4
a87 4
extern void share_dlist();	/* defined in share.c */
extern void set_port();		/* defined in fbserv.c */
extern void predictor_init();	/* defined in predictor.c */
extern void view_ring_init(); /* defined in chgview.c */
d98 8
a105 8
int gui_setup();
int mged_attach();
void get_attached();
void print_valid_dm();
void dm_var_init();
void mged_slider_init_vls();
void mged_slider_free_vls();
void mged_link_vars();
d110 2
a111 2
void mged_fb_open();
void mged_fb_close();
d141 1
a141 3
release(name, need_close)
char *name;
int need_close;
d212 1
a212 5
f_release(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d274 1
a274 5
f_attach(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d304 1
a304 1
print_valid_dm()
d415 1
a415 1
get_attached()
d455 1
a455 2
gui_setup(dstr)
char *dstr;
d543 1
a543 5
f_dm(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d573 1
a573 1
is_dm_null()
d579 1
a579 2
dm_var_init(initial_dm_list)
struct dm_list *initial_dm_list;
d643 1
a643 2
mged_slider_init_vls(p)
struct dm_list *p;
d654 1
a654 2
mged_slider_free_vls(p)
struct dm_list *p;
d667 1
a667 2
mged_link_vars(p)
struct dm_list *p;
d686 1
a686 5
f_get_dm_list(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d707 1
a707 1
mged_fb_open()
d725 1
a725 1
mged_fb_close()
@


11.121
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.120 2002/08/20 17:08:21 jra Exp $ (BRL)";
d34 1
d36 1
d66 1
d69 1
d89 1
d91 1
d123 1
d125 1
d318 1
d320 1
d489 1
d491 1
d520 1
d522 1
d733 1
d736 1
d738 4
a741 1
  else if(dmp->dm_type == DM_TYPE_OGL)
@


11.120
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.118 2001/10/17 07:40:04 morrison Exp $ (BRL)";
@


11.120.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.121 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


11.120.10.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.120.10.1 2004/02/12 18:34:12 erikg Exp $ (BRL)";
@


11.120.10.3
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a33 1
#ifndef WIN32
a34 1
#endif
a63 1
#ifndef WIN32
a65 1
#endif
a84 1
#ifndef WIN32
a85 1
#endif
a116 1
#ifndef WIN32
a117 1
#endif
a309 1
#ifndef WIN32
a310 1
#endif
a478 1
#ifndef WIN32
a479 1
#endif
a507 1
#ifndef WIN32
a508 1
#endif
a718 1
#ifndef WIN32
a720 1
#endif
d722 1
a722 4
#ifndef WIN32
  else 
#endif
if(dmp->dm_type == DM_TYPE_OGL)
@


11.120.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.120 2002/08/20 17:08:21 jra Exp $ (BRL)";
a33 1
#ifndef WIN32
a34 1
#endif
a63 1
#ifndef WIN32
a65 1
#endif
a84 1
#ifndef WIN32
a85 1
#endif
a116 1
#ifndef WIN32
a117 1
#endif
a309 1
#ifndef WIN32
a310 1
#endif
a478 1
#ifndef WIN32
a479 1
#endif
a507 1
#ifndef WIN32
a508 1
#endif
a718 1
#ifndef WIN32
a720 1
#endif
d722 1
a722 4
#ifndef WIN32
  else 
#endif
if(dmp->dm_type == DM_TYPE_OGL)
@


11.120.4.2
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/attach.c,v 11.120.4.1 2002/09/26 23:04:08 morrison Exp $ (BRL)";
@


11.120.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.120 2002/08/20 17:08:21 jra Exp $ (BRL)";
d60 2
a61 2
extern int Plot_dm_init(struct dm_list *o_dm_list, int argc, char **argv);
extern int PS_dm_init(struct dm_list *o_dm_list, int argc, char **argv);
d80 4
a83 4
extern void share_dlist(struct dm_list *dlp2);	/* defined in share.c */
extern void set_port(void);		/* defined in fbserv.c */
extern void predictor_init(void);	/* defined in predictor.c */
extern void view_ring_init(struct _view_state *vsp1, struct _view_state *vsp2); /* defined in chgview.c */
d92 8
a99 8
int gui_setup(char *dstr);
int mged_attach(struct w_dm *wp, int argc, char **argv);
void get_attached(void);
void print_valid_dm(void);
void dm_var_init(struct dm_list *initial_dm_list);
void mged_slider_init_vls(struct dm_list *p);
void mged_slider_free_vls(struct dm_list *p);
void mged_link_vars(struct dm_list *p);
d104 2
a105 2
void mged_fb_open(void);
void mged_fb_close(void);
d133 3
a135 1
release(char *name, int need_close)
d206 5
a210 1
f_release(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d272 5
a276 1
f_attach(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d306 1
a306 1
print_valid_dm(void)
d415 1
a415 1
get_attached(void)
d455 2
a456 1
gui_setup(char *dstr)
d540 5
a544 1
f_dm(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d574 1
a574 1
is_dm_null(void)
d580 2
a581 1
dm_var_init(struct dm_list *initial_dm_list)
d645 2
a646 1
mged_slider_init_vls(struct dm_list *p)
d657 2
a658 1
mged_slider_free_vls(struct dm_list *p)
d671 2
a672 1
mged_link_vars(struct dm_list *p)
d691 5
a695 1
f_get_dm_list(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d716 1
a716 1
mged_fb_open(void)
d729 1
a729 1
mged_fb_close(void)
@


11.120.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a33 1
#ifndef WIN32
a34 1
#endif
a63 1
#ifndef WIN32
a65 1
#endif
a84 1
#ifndef WIN32
a85 1
#endif
a116 1
#ifndef WIN32
a117 1
#endif
a299 1
#ifndef WIN32
a300 1
#endif
a467 1
#ifndef WIN32
a468 1
#endif
a496 1
#ifndef WIN32
a497 1
#endif
a695 1
#ifndef WIN32
a697 1
#endif
d699 1
a699 4
#ifndef WIN32
  else 
#endif
if(dmp->dm_type == DM_TYPE_OGL)
@


11.119
log
@Converted from K&R to ANSI C - RFH
@
text
@d60 2
a61 2
extern int Plot_dm_init(struct dm_list *o_dm_list, int argc, char **argv);
extern int PS_dm_init(struct dm_list *o_dm_list, int argc, char **argv);
d80 4
a83 4
extern void share_dlist(struct dm_list *dlp2);	/* defined in share.c */
extern void set_port(void);		/* defined in fbserv.c */
extern void predictor_init(void);	/* defined in predictor.c */
extern void view_ring_init(struct _view_state *vsp1, struct _view_state *vsp2); /* defined in chgview.c */
d92 8
a99 8
int gui_setup(char *dstr);
int mged_attach(struct w_dm *wp, int argc, char **argv);
void get_attached(void);
void print_valid_dm(void);
void dm_var_init(struct dm_list *initial_dm_list);
void mged_slider_init_vls(struct dm_list *p);
void mged_slider_free_vls(struct dm_list *p);
void mged_link_vars(struct dm_list *p);
d104 2
a105 2
void mged_fb_open(void);
void mged_fb_close(void);
d133 3
a135 1
release(char *name, int need_close)
d206 5
a210 1
f_release(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d272 5
a276 1
f_attach(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d306 1
a306 1
print_valid_dm(void)
d415 1
a415 1
get_attached(void)
d455 2
a456 1
gui_setup(char *dstr)
d540 5
a544 1
f_dm(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d574 1
a574 1
is_dm_null(void)
d580 2
a581 1
dm_var_init(struct dm_list *initial_dm_list)
d645 2
a646 1
mged_slider_init_vls(struct dm_list *p)
d657 2
a658 1
mged_slider_free_vls(struct dm_list *p)
d671 2
a672 1
mged_link_vars(struct dm_list *p)
d691 5
a695 1
f_get_dm_list(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d716 1
a716 1
mged_fb_open(void)
d729 1
a729 1
mged_fb_close(void)
@


11.118
log
@Mac OS X warning and error fixes for non-production build
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.117 2001/08/11 13:16:11 butler Exp $ (BRL)";
d60 2
a61 2
extern int Plot_dm_init();
extern int PS_dm_init();
d80 4
a83 4
extern void share_dlist();	/* defined in share.c */
extern void set_port();		/* defined in fbserv.c */
extern void predictor_init();	/* defined in predictor.c */
extern void view_ring_init(); /* defined in chgview.c */
d92 8
a99 8
int gui_setup();
int mged_attach();
void get_attached();
void print_valid_dm();
void dm_var_init();
void mged_slider_init_vls();
void mged_slider_free_vls();
void mged_link_vars();
d104 2
a105 2
void mged_fb_open();
void mged_fb_close();
d133 1
a133 3
release(name, need_close)
char *name;
int need_close;
d204 1
a204 5
f_release(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d266 1
a266 5
f_attach(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d296 1
a296 1
print_valid_dm()
d405 1
a405 1
get_attached()
d445 1
a445 2
gui_setup(dstr)
char *dstr;
d529 1
a529 5
f_dm(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d559 1
a559 1
is_dm_null()
d565 1
a565 2
dm_var_init(initial_dm_list)
struct dm_list *initial_dm_list;
d629 1
a629 2
mged_slider_init_vls(p)
struct dm_list *p;
d640 1
a640 2
mged_slider_free_vls(p)
struct dm_list *p;
d653 1
a653 2
mged_link_vars(p)
struct dm_list *p;
d672 1
a672 5
f_get_dm_list(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d693 1
a693 1
mged_fb_open()
d706 1
a706 1
mged_fb_close()
@


11.117
log
@misc compiler warning changes
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.116 2001/08/02 17:36:52 jra Exp $ (BRL)";
d39 2
a40 2
#include "tk.h"
#include "itk.h"
d42 1
a42 1
#include "tcl.h"
@


11.116
log
@Added Bezier curve to canvas widget
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.115 2001/07/28 04:56:15 jra Exp $ (BRL)";
d84 2
@


11.115
log
@Added support for Bezier curves in the Tk canvas (required a call here)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.114 2001/06/01 19:23:22 bparker Exp $ (BRL)";
d475 3
@


11.114
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.113 2001/04/02 21:20:40 bparker Exp $ (BRL)";
d501 4
@


11.113
log
@*- remove Tk dependencies
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.112 2000/11/14 20:42:16 bparker Exp $ (BRL)";
d391 1
a391 1
    createDLists(&HeadSolid); 
d619 4
a622 1
  *view_state = *initial_dm_list->dml_view_state;		/* struct copy */
@


11.112
log
@set mged_default_dlist = 0
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.111 2000/10/24 15:15:56 mike Exp $ (BRL)";
d38 1
d40 4
d66 1
a66 1
#endif
d71 2
d85 1
d87 1
a115 1
#endif
d119 1
a308 1
#endif
d312 1
d335 1
d371 1
d456 1
d519 1
d706 1
d713 1
d719 1
d728 1
@


11.111
log
@
lint
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.110 2000/09/07 02:23:41 mike Exp $ (BRL)";
d96 1
a96 1
int mged_default_dlist = 1;   /* This variable is available via Tcl for controlling use of display lists */
@


11.110
log
@
Added externs to ged.h to fix lint
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.109 2000/08/19 03:10:40 mike Exp $ (BRL)";
d28 5
a32 1

d90 1
d92 1
d230 1
d258 1
@


11.109
log
@
const RCSid
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.108 2000/08/19 03:10:10 mike Exp $ (BRL)";
d303 4
a306 4
mged_attach(wp, argc, argv)
register struct w_dm *wp;
int argc;
char *argv[];
@


11.108
log
@
Reduced use of MAXARGS
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.107 2000/01/21 15:24:53 bparker Exp $ (BRL)";
@


11.107
log
@*- mods to always have a framebuffer
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.106 1999/12/30 20:18:32 jra Exp $ (BRL)";
d261 1
a261 1
  if(argc < 2 || MAXARGS < argc){
d272 1
d523 1
a523 1
  if(argc < 2 || MAXARGS < argc){
@


11.107.2.1
log
@set mged_default_dlist = 0
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.107 2000/01/21 15:24:53 bparker Exp $ (BRL)";
d90 1
a90 1
int mged_default_dlist = 0;   /* This variable is available via Tcl for controlling use of display lists */
@


11.106
log
@Eliminated some unused variables
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.105 1999/10/28 14:22:11 bparker Exp $ (BRL)";
d377 1
@


11.105
log
@*- fixed a bug in release() where a resource was being
   accessed after being released.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.104 1999/10/27 17:40:17 bparker Exp $ (BRL)";
a95 8
static char *default_view_strings[] = {
  "top",
  "right",
  "front",
  "45,45",
  "35,25"
};

a119 1
  register struct solid *sp;
a306 1
  register struct solid *sp;
a307 1
  struct dm_list *dlp;
a397 1
  struct bu_vls vls;
a434 2
  char *filename;
  int status;
a693 1
  int status;
@


11.104
log
@*- cleanup
*- initialize the Iwidgets package and import
   them into the global namespace
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.103 1999/10/26 17:33:01 bparker Exp $ (BRL)";
a156 8
  /*
   *  This saves the state of the resoures to the "nu" display manager, which
   *  is beneficial only if closing the last display manager. So when
   *  another display manager is opened, it looks like the last one
   *  the user had open. This depends on "nu" always being last in the list.
   */
  usurp_all_resources(BU_LIST_LAST(dm_list, &head_dm_list.l), curr_dm_list);

d167 8
@


11.103
log
@*- turn on Itcl
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.102 1999/10/22 21:38:51 bparker Exp $ (BRL)";
d468 1
a468 6
#if 0
  Tcl_StaticPackage(interp, "Tk", Tk_Init, Tk_SafeInit);
#endif

#if 1
  /* XXX Initialize [incr Tk] */
d474 1
a474 5
#if 0
  Tcl_StaticPackage(interp, "Itk", Itk_Init, (Tcl_PackageInitProc *) NULL);
#endif

  /* Import [incr Tcl] commands into the global namespace */
d481 9
a489 1
  if (Tcl_Eval(interp, "auto_mkindex_parser::slavehook { _%@@namespace import -force ::itk::* }") != TCL_OK) {
a492 1
#endif
@


11.102
log
@*- initialize libdm and libfb
*- add code initialize [incr Tcl]; for now leave turned off
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.101 1999/09/10 23:10:23 bparker Exp $ (BRL)";
d472 1
a472 1
#if 0
@


11.101
log
@*- mods to initialize color_scheme with the nu display manager's
   settings
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.100 1999/07/23 20:23:46 bparker Exp $ (BRL)";
a463 1
    Tcl_AppendResult(interp, "\ngui_setup: Couldn't initialize Tk\n", (char *)NULL);
d468 34
a502 1
    Tcl_AppendResult(interp, "gui_setup: Failed to get main window.\n", (char *)NULL);
@


11.100
log
@*- check validity of the vls before freeing.
   I think this fixes a bug reported earlier.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.99 1999/05/14 22:19:43 bparker Exp $ (BRL)";
d559 2
d562 4
a566 3
#if 0
  color_scheme->cs_mode = default_color_scheme.cs_mode;
#endif
@


11.99
log
@*- move BU_LIST_APPEND(&head_dm_list.l, &curr_dm_list->l);
	before call to get display manager
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.98 1999/03/18 18:00:42 bparker Exp $ (BRL)";
d606 8
a613 6
  bu_vls_free(&p->dml_fps_name);
  bu_vls_free(&p->dml_aet_name);
  bu_vls_free(&p->dml_ang_name);
  bu_vls_free(&p->dml_center_name);
  bu_vls_free(&p->dml_size_name);
  bu_vls_free(&p->dml_adc_name);
@


11.98
log
@*- mods to dm_var_init
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.97 1999/01/27 14:40:35 bparker Exp $ (BRL)";
d364 2
a367 2

  BU_LIST_APPEND(&head_dm_list.l, &curr_dm_list->l);
@


11.97
log
@*- change mged_slider_link_vars to mged_link_vars
*- properly set dl_active
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.96 1999/01/21 18:32:36 bparker Exp $ (BRL)";
d554 3
d583 1
@


11.96
log
@*- call helpdevel for help on get_dm_list
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.95 1999/01/12 17:56:33 bparker Exp $ (BRL)";
d84 1
a84 1
void mged_slider_link_vars();
d372 1
a372 1
  mged_slider_link_vars(curr_dm_list);
d381 1
a381 1
  if(displaylist && mged_variables->mv_dlist && !dlist_state->dl_active)
d383 2
a571 1
  dlist_state->dl_active = mged_variables->mv_dlist;
d611 1
a611 1
mged_slider_link_vars(p)
@


11.95
log
@*- code to support sharing display lists
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.94 1998/12/29 20:46:24 bparker Exp $ (BRL)";
d498 1
a498 1
		     "' display manager does not support any local commands.\n",
d637 10
@


11.94
log
@*- mods to release()
*- mods to dm_var_init()
*- mods to mged_slider_link_vars()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.93 1998/12/15 15:56:01 bparker Exp $ (BRL)";
d69 1
d90 1
d181 1
a181 13
  if(need_close){
#ifdef DO_DISPLAY_LISTS
    if(displaylist &&
       mged_variables->mv_dlist &&
       BU_LIST_NON_EMPTY(&HeadSolid.l))
#ifdef DO_SINGLE_DISPLAY_LIST
    DM_FREEDLISTS(dmp, 1, 1);
#else
    DM_FREEDLISTS(dmp, BU_LIST_FIRST(solid, &HeadSolid.l)->s_dlist,
		       BU_LIST_LAST(solid, &HeadSolid.l)->s_dlist -
		       BU_LIST_FIRST(solid, &HeadSolid.l)->s_dlist + 1);
#endif
#endif
a182 1
  }
d318 1
a326 1
  BU_LIST_APPEND(&head_dm_list.l, &curr_dm_list->l);
a339 1
	BU_LIST_DEQUEUE( &curr_dm_list->l );
a348 1
      BU_LIST_DEQUEUE( &curr_dm_list->l );
d367 5
d379 3
a381 4
  if(displaylist && mged_variables->mv_dlist)
#ifdef DO_SINGLE_DISPLAY_LIST
    createDList(&HeadSolid);
#else
a383 1
#endif
d551 1
d567 4
@


11.93
log
@*- no longer using display manager owned frametime
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.92 1998/11/06 21:56:59 bparker Exp $ (BRL)";
d44 5
a48 19
int gui_setup();
int mged_attach();
void get_attached();
void print_valid_dm();
void dm_var_init();

void mged_slider_init_vls();
void mged_slider_free_vls();
void mged_slider_link_vars();
void mged_slider_unlink_vars();

static int do_2nd_attach_prompt();
void mged_fb_open();
void mged_fb_close();

extern struct _color_scheme default_color_scheme;
extern void set_port();		/* defined in fbserv.c */
extern void predictor_init();	/* defined in predictor.c */
extern void view_ring_init(); /* defined in chgview.c */
d69 3
a71 5
#define NEED_GUI(_type) ( \
	IS_DM_TYPE_OGL(_type) || \
	IS_DM_TYPE_GLX(_type) || \
	IS_DM_TYPE_PEX(_type) || \
	IS_DM_TYPE_X(_type) )
d74 15
d155 7
a161 17
  {
    struct dm_list *sdm;

    sdm = curr_dm_list;

    /*
     *  This saves the state of the resoures to the "nu" display manager, which
     *  is beneficial only if closing the last display manager. So when
     *  another display manager is opened, it looks like the last one
     *  the user had open.
     *
     *  Note: "nu" cannot be released.
     */
    curr_dm_list = BU_LIST_LAST(dm_list, &head_dm_list.l);
    dm_var_init(sdm);
    curr_dm_list = sdm;
  }
d197 1
a197 34

  if(!--view_state->vs_rc){
    view_ring_destroy(curr_dm_list);

    bu_vls_free(&view_state->vs_aet_name);
    bu_vls_free(&view_state->vs_ang_name);
    bu_vls_free(&view_state->vs_center_name);
    bu_vls_free(&view_state->vs_size_name);
    bu_vls_free(&view_state->vs_adc_name);

    bu_free((genptr_t)view_state, "release: view_state");
  }

  if (!--adc_state->adc_rc)
    bu_free((genptr_t)adc_state, "release: adc_state");

  if (!--menu_state->ms_rc)
    bu_free((genptr_t)menu_state, "release: menu_state");

  if (!--rubber_band->rb_rc)
    bu_free((genptr_t)rubber_band, "release: rubber_band");

  if (!--mged_variables->mv_rc)
    bu_free((genptr_t)mged_variables, "release: mged_variables");

  if (!--color_scheme->cs_rc)
    bu_free((genptr_t)color_scheme, "release: color_scheme");

  if (!--grid_state->gr_rc)
    bu_free((genptr_t)grid_state, "release: grid_state");

  if (!--axes_state->ax_rc)
    bu_free((genptr_t)axes_state, "release: axes_state");

a207 1

a379 8
  bu_vls_init(&fps_name);
  bu_vls_printf(&fps_name, "%s(%S,fps)", MGED_DISPLAY_VAR,
		&curr_dm_list->dml_dmp->dm_pathName);

#if TRY_NEW_MGED_VARS
  mged_variable_setup(curr_dm_list);
#endif

d403 1
a403 1
    release((char *)NULL, 1);  /* relesae() will call dm_close */
d580 1
a580 18
#if 0
  view_state->vs_flag = 1;
#endif
  view_ring_init(curr_dm_list);

#if 0
#if 1
  bn_mat_copy(view_state->vs_Viewrot, initial_dm_list->dml_view_state->vs_Viewrot);
  bn_mat_copy(view_state->vs_toViewcenter, initial_dm_list->dml_view_state->vs_toViewcenter);
  bn_mat_copy(view_state->vs_ModelDelta, bn_mat_identity);
  view_state->vs_Viewscale = initial_dm_list->dml_view_state->vs_Viewscale;
#else
  bn_mat_copy(view_state->vs_Viewrot, bn_mat_identity);
  size_reset();
#endif
  MAT_DELTAS_GET_NEG(view_state->vs_orig_pos, view_state->vs_toViewcenter);
  new_mats();
#endif
d594 6
a599 5
  bu_vls_init(&p->dml_view_state->vs_aet_name);
  bu_vls_init(&p->dml_view_state->vs_ang_name);
  bu_vls_init(&p->dml_view_state->vs_center_name);
  bu_vls_init(&p->dml_view_state->vs_size_name);
  bu_vls_init(&p->dml_view_state->vs_adc_name);
d606 6
a611 5
  bu_vls_free(&p->dml_view_state->vs_aet_name);
  bu_vls_free(&p->dml_view_state->vs_ang_name);
  bu_vls_free(&p->dml_view_state->vs_center_name);
  bu_vls_free(&p->dml_view_state->vs_size_name);
  bu_vls_free(&p->dml_view_state->vs_adc_name);
d620 1
a620 1
  bu_vls_printf(&p->dml_view_state->vs_aet_name, "%s(%S,aet)", MGED_DISPLAY_VAR,
d622 1
a622 1
  bu_vls_printf(&p->dml_view_state->vs_ang_name, "%s(%S,ang)", MGED_DISPLAY_VAR,
d624 1
a624 1
  bu_vls_printf(&p->dml_view_state->vs_center_name, "%s(%S,center)", MGED_DISPLAY_VAR,
d626 1
a626 1
  bu_vls_printf(&p->dml_view_state->vs_size_name, "%s(%S,size)", MGED_DISPLAY_VAR,
d628 1
a628 1
  bu_vls_printf(&p->dml_view_state->vs_adc_name, "%s(%S,adc)", MGED_DISPLAY_VAR,
d630 2
a631 6
}

void
mged_slider_unlink_vars(p)
struct dm_list *p;
{
@


11.92
log
@*- use new structures
*- remove share_vars, unshare_vars
*- remove share_view, unshare_view
*- cleanup
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.91 1998/10/21 17:29:16 bparker Exp $ (BRL)";
a655 1
  frametime = 1;
@


11.91
log
@*- use macros in place of common literals
*- use color scheme variables
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.90 1998/08/13 11:58:40 bparker Exp $ (BRL)";
a55 1
static void find_new_owner();
a59 1
extern void cs_set_bg();	/* defined in color_scheme.c */
d62 1
a62 1
extern void set_scroll();	/* defined in set.c */
a63 2
extern int mged_view_init(); /* defined in chgview.c */

a127 2
  struct dm_list *p;
  struct cmd_list *p_cmd;
d131 2
d137 1
a137 1
      if(strcmp(name, bu_vls_addr(&p->_dmp->dm_pathName)))
d153 1
a153 2
  }else{
    if(dmp && !strcmp("nu", bu_vls_addr(&pathName)))
a154 3
    else
      p = curr_dm_list;
  }
a155 1
#if 1
d161 8
d170 1
a170 5
    bn_mat_copy(Viewrot, p->s_info->_Viewrot);
    bn_mat_copy(toViewcenter, p->s_info->_toViewcenter);
    Viewscale = p->s_info->_Viewscale;
    new_mats();

a172 1
#endif
d175 1
a175 1
    if(mged_variables->listen){
d177 1
a177 1
      mged_variables->listen = 0;
a184 24
  if(!--p->s_info->_rc){
    if(center_name.vls_magic == BU_VLS_MAGIC){
      mged_slider_unlink_vars(p);
      mged_slider_free_vls(p);
    }

    /* free view ring */
    if(p->s_info->_headView.l.magic == BU_LIST_HEAD_MAGIC){
      struct view_list *vlp;
      struct view_list *nvlp;

      for(vlp = BU_LIST_FIRST(view_list, &p->s_info->_headView.l);
	  BU_LIST_NOT_HEAD(vlp, &p->s_info->_headView.l);){
	nvlp = BU_LIST_PNEXT(view_list, vlp);
	BU_LIST_DEQUEUE(&vlp->l);
	bu_free((genptr_t)vlp, "release: vlp");
	vlp = nvlp;
      }
    }

    bu_free( (genptr_t)p->s_info, "release: s_info" );
  }else if(p->_owner)
    find_new_owner(p);

d187 2
a188 2
  if(p->aim != NULL)
    p->aim->aim = (struct dm_list *)NULL;
d193 1
a193 1
       mged_variables->dlist &&
d206 2
a207 2
  RT_FREE_VLIST(&p->p_vlist);
  BU_LIST_DEQUEUE( &p->l );
d209 2
a210 1
  bu_free( (genptr_t)p, "release: curr_dm_list" );
d212 32
d312 1
a312 1
  bu_vls_printf(&curr_cmd_list->more_default, "%s", dm_default);
d379 1
a379 1
  BU_LIST_INIT(&curr_dm_list->p_vlist);
d425 4
a432 3
  bu_vls_init(&fps_name);
  bu_vls_printf(&fps_name, "%s(%S,fps)", MGED_DISPLAY_VAR,
		&curr_dm_list->_dmp->dm_pathName);
a433 2
  mmenu_init();
  btn_head_menu(0,0,0);
a434 5
  if(state == ST_S_EDIT)
    sedit_menu();
  else if(state == ST_O_EDIT)
    chg_l2menu(ST_O_EDIT);

d440 1
a440 1
  if(displaylist && mged_variables->dlist)
a447 3
  ++dirty;
  adc_auto = 1;
  grid_auto_size = 1;
d592 3
a594 7

int
f_unshare_view(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d596 5
a600 69
  struct dm_list *p;
  struct shared_info *sip;
  struct dm_list *save_cdlp;
  struct cmd_list *save_cclp;
  struct bu_vls vls1;

  if(argc < 2 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help unshare_view");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  bu_vls_init(&vls1);

  if(*argv[1] != '.')
    bu_vls_printf(&vls1, ".%s", argv[1]);
  else
    bu_vls_strcpy(&vls1, argv[1]);

  FOR_ALL_DISPLAYS(p, &head_dm_list.l)
    if(!strcmp(bu_vls_addr(&vls1), bu_vls_addr(&p->_dmp->dm_pathName)))
      break;

  if(p == &head_dm_list){
    Tcl_AppendResult(interp, "unshare_view: bad pathname - %s\n",
		     bu_vls_addr(&vls1), (char *)NULL);
    bu_vls_free(&vls1);
    return TCL_ERROR;
  }

  bu_vls_free(&vls1);

  if(p->_owner){
    if(p->s_info->_rc > 1){  /* sharing s_info with another display manager */
      struct dm_list *nop;

      --p->s_info->_rc;
      sip = p->s_info;
      find_new_owner(p);
    }else
      return TCL_OK;  /* Nothing to do */
  }else{
    --p->s_info->_rc;
    sip = p->s_info;
  }

  BU_GETSTRUCT(p->s_info, shared_info);
  bcopy((void *)sip, (void *)p->s_info, sizeof(struct shared_info));
  p->s_info->_rc = 1;
  p->_owner = 1;
  p->_dmp->dm_vp = &p->s_info->_Viewscale;
  p->s_info->opp = &p->_dmp->dm_pathName;
  mged_slider_link_vars(p);
  mged_view_init(p);

  save_cdlp = curr_dm_list;
  curr_dm_list = p;
  if(p->aim){
    save_cclp = curr_cmd_list;
    curr_cmd_list = p->aim;
  }

#ifdef DO_SCROLL_UPDATES
  set_scroll();
d603 7
a609 6
  curr_dm_list = save_cdlp;
  if(p->aim)
    curr_cmd_list = save_cclp;
  
  return TCL_OK;
}
d611 3
a613 12
int
f_share_view(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_list *p;
  struct dm_list *p1 = (struct dm_list *)NULL;
  struct dm_list *p2 = (struct dm_list *)NULL;
  struct cmd_list *save_cclp;  /* save current cmd_list pointer */
  struct bu_vls vls1, vls2;
d615 5
a619 85
  if(argc < 3 || 3 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help share_view");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  bu_vls_init(&vls1);
  bu_vls_init(&vls2);

  if(*argv[1] != '.')
    bu_vls_printf(&vls1, ".%s", argv[1]);
  else
    bu_vls_strcpy(&vls1, argv[1]);

  if(*argv[2] != '.')
    bu_vls_printf(&vls2, ".%s", argv[2]);
  else
    bu_vls_strcpy(&vls2, argv[2]);

  FOR_ALL_DISPLAYS(p, &head_dm_list.l){
    if(p1 == (struct dm_list *)NULL && !strcmp(bu_vls_addr(&vls1),
					       bu_vls_addr(&p->_dmp->dm_pathName)))
      p1 = p;
    else if(p2 == (struct dm_list *)NULL && !strcmp(bu_vls_addr(&vls2),
						    bu_vls_addr(&p->_dmp->dm_pathName)))
      p2 = p;
    else if(p1 != (struct dm_list *)NULL && p2 != (struct dm_list *)NULL)
      break;
  }

  if(p1 == (struct dm_list *)NULL || p2 == (struct dm_list *)NULL){
    Tcl_AppendResult(interp, "f_share_view: bad pathname(s)\n\tpathName1 - ",
		     bu_vls_addr(&vls1), "\t\tpathName2 - ",
		     bu_vls_addr(&vls2), "\n", (char *)NULL);
    bu_vls_free(&vls1);
    bu_vls_free(&vls2);
    return TCL_ERROR;
  }

  bu_vls_free(&vls1);
  bu_vls_free(&vls2);

  /* free p2's s_info struct if not being used */
  if(!--p2->s_info->_rc){
    mged_slider_unlink_vars(p2);
    mged_slider_free_vls(p2);

    /* free view ring */
    if(p2->s_info->_headView.l.magic == BU_LIST_HEAD_MAGIC){
      struct view_list *vlp;
      struct view_list *nvlp;

      for(vlp = BU_LIST_FIRST(view_list, &p2->s_info->_headView.l);
	  BU_LIST_NOT_HEAD(vlp, &p2->s_info->_headView.l);){
	nvlp = BU_LIST_PNEXT(view_list, vlp);
	BU_LIST_DEQUEUE(&vlp->l);
	bu_free((genptr_t)vlp, "release: vlp");
	vlp = nvlp;
      }
    }

    bu_free( (genptr_t)p2->s_info, "share_view: s_info" );
  /* otherwise if p2's s_info struct is being used and p2 is the owner */
  }else if(p2->_owner)
    find_new_owner(p2);

  p2->_owner = 0;

  /* p2 now shares p1's s_info */
  p2->s_info = p1->s_info;

  /* reuse p to save curr_dm_list */
  p = curr_dm_list;
  curr_dm_list = p2;
  if(p2->aim){
    save_cclp = curr_cmd_list;
    curr_cmd_list = p1->aim;
  }

#ifdef DO_SCROLL_UPDATES
  set_scroll();
d622 3
a624 12
  curr_dm_list = p;
  if(p2->aim)
    curr_cmd_list = save_cclp;

  p2->_dmp->dm_vp = &p2->s_info->_Viewscale;

  /* increment the reference count */
  ++p1->s_info->_rc;

  dmaflag = 1;
  return TCL_OK;
}
d626 3
a628 23
static void
find_new_owner( op )
struct dm_list *op;
{
  struct dm_list *p;
  struct dm_list *save_cdlp;
  struct cmd_list *save_cclp;

  FOR_ALL_DISPLAYS(p, &head_dm_list.l){
    /* first one found is the new owner */
    if(op != p && p->s_info == op->s_info){
      p->_owner = 1;
      p->s_info->opp = &p->_dmp->dm_pathName;
      mged_slider_unlink_vars(p);
      mged_slider_free_vls(p);
      mged_slider_link_vars(p);

      save_cdlp = curr_dm_list;
      curr_dm_list = p;
      if(p->aim){
	save_cclp = curr_cmd_list;
	curr_cmd_list = p->aim;
      }
d630 5
a634 2
#ifdef DO_SCROLL_UPDATES
      set_scroll();
d636 1
a636 71

      curr_dm_list = save_cdlp;
      if(p->aim)
	curr_cmd_list = save_cclp;

      return;
    }
  }

  Tcl_AppendResult(interp, "find_new_owner: Failed to find a new owner\n", (char *)NULL);
}

int
f_share_vars(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_list *dlp1, *dlp2, *dlp3;
  struct _mged_variables *save_mvp;

  if(argc != 3){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help share_vars");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  FOR_ALL_DISPLAYS(dlp1, &head_dm_list.l)
    if(!strcmp(argv[1], bu_vls_addr(&dlp1->_dmp->dm_pathName)))
      break;

  if(dlp1 == &head_dm_list){
     Tcl_AppendResult(interp, "f_share_vars: unrecognized pathName - ",
		      argv[1], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  FOR_ALL_DISPLAYS(dlp2, &head_dm_list.l)
    if(!strcmp(argv[2], bu_vls_addr(&dlp2->_dmp->dm_pathName)))
      break;

  if(dlp2 == &head_dm_list){
     Tcl_AppendResult(interp, "f_share_vars: unrecognized pathName - ",
		      argv[1], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(dlp1 == dlp2)
    return TCL_OK;

  /* already sharing mged variables */
  if(dlp1->_mged_variables == dlp2->_mged_variables)
    return TCL_OK;


  save_mvp = dlp2->_mged_variables;
  dlp2->_mged_variables = dlp1->_mged_variables;

  /* check if save_mvp is being used elsewhere */
  FOR_ALL_DISPLAYS(dlp3, &head_dm_list.l)
    if(save_mvp == dlp3->_mged_variables)
      break;

  /* save_mvp is not being used */
  if(dlp3 == &head_dm_list)
    bu_free((genptr_t)save_mvp, "f_share_menu: save_mvp");
d638 1
a638 58
  /* need to redraw this guy */
  dlp2->_dirty = 1;

  return TCL_OK;
}

int
f_unshare_vars(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct dm_list *dlp1, *dlp2;

  if(argc != 2){
    return TCL_ERROR;
  }

  FOR_ALL_DISPLAYS(dlp1, &head_dm_list.l)
    if(!strcmp(argv[1], bu_vls_addr(&dlp1->_dmp->dm_pathName)))
      break;

  if(dlp1 == &head_dm_list){
     Tcl_AppendResult(interp, "f_unshare_menu: unrecognized pathName - ",
		      argv[1], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  FOR_ALL_DISPLAYS(dlp2, &head_dm_list.l)
    if(dlp1 != dlp2 && dlp1->_mged_variables == dlp2->_mged_variables)
      break;

  /* not sharing mged_variables ---- nothing to do */
  if(dlp2 == &head_dm_list)
    return TCL_OK;

  BU_GETSTRUCT(dlp1->_mged_variables, _mged_variables);
  *dlp1->_mged_variables = *dlp2->_mged_variables;  /* struct copy */

  return TCL_OK;
}

void
dm_var_init(initial_dm_list)
struct dm_list *initial_dm_list;
{
  int i;

  BU_GETSTRUCT(curr_dm_list->s_info, shared_info);

  BU_GETSTRUCT(mged_variables, _mged_variables);
  *mged_variables = *initial_dm_list->_mged_variables; /* struct copy */

  BU_GETSTRUCT(color_scheme, _color_scheme);
  *color_scheme = *initial_dm_list->_color_scheme;	/* struct copy */
  color_scheme->active = default_color_scheme.active;

d640 4
a643 4
  bn_mat_copy(Viewrot, initial_dm_list->s_info->_Viewrot);
  bn_mat_copy(toViewcenter, initial_dm_list->s_info->_toViewcenter);
  bn_mat_copy(ModelDelta, bn_mat_identity);
  Viewscale = initial_dm_list->s_info->_Viewscale;
d645 1
a645 1
  bn_mat_copy(Viewrot, bn_mat_identity);
d648 1
a648 1
  MAT_DELTAS_GET_NEG(orig_pos, toViewcenter);
d650 1
d652 3
a655 3
  rc = 1;
  dmaflag = 1;
  owner = 1;
d657 2
a658 5
  mapped = 1;
  adc_a1 = adc_a2 = 45.0;
  mged_view_init(curr_dm_list);

  BU_GETSTRUCT(curr_dm_list->menu_vars, menu_vars);
d665 5
a669 40
  bu_vls_init(&p->s_info->_aet_name);
  bu_vls_init(&p->s_info->_ang_name);
  bu_vls_init(&p->s_info->_center_name);
  bu_vls_init(&p->s_info->_size_name);
  bu_vls_init(&p->s_info->_adc_name);

#ifdef UPDATE_TCL_SLIDERS
  bu_vls_init(&p->s_info->_rate_tran_vls[X]);
  bu_vls_init(&p->s_info->_rate_tran_vls[Y]);
  bu_vls_init(&p->s_info->_rate_tran_vls[Z]);
  bu_vls_init(&p->s_info->_rate_model_tran_vls[X]);
  bu_vls_init(&p->s_info->_rate_model_tran_vls[Y]);
  bu_vls_init(&p->s_info->_rate_model_tran_vls[Z]);
  bu_vls_init(&p->s_info->_rate_rotate_vls[X]);
  bu_vls_init(&p->s_info->_rate_rotate_vls[Y]);
  bu_vls_init(&p->s_info->_rate_rotate_vls[Z]);
  bu_vls_init(&p->s_info->_rate_model_rotate_vls[X]);
  bu_vls_init(&p->s_info->_rate_model_rotate_vls[Y]);
  bu_vls_init(&p->s_info->_rate_model_rotate_vls[Z]);
  bu_vls_init(&p->s_info->_rate_scale_vls);
  bu_vls_init(&p->s_info->_absolute_tran_vls[X]);
  bu_vls_init(&p->s_info->_absolute_tran_vls[Y]);
  bu_vls_init(&p->s_info->_absolute_tran_vls[Z]);
  bu_vls_init(&p->s_info->_absolute_model_tran_vls[X]);
  bu_vls_init(&p->s_info->_absolute_model_tran_vls[Y]);
  bu_vls_init(&p->s_info->_absolute_model_tran_vls[Z]);
  bu_vls_init(&p->s_info->_absolute_rotate_vls[X]);
  bu_vls_init(&p->s_info->_absolute_rotate_vls[Y]);
  bu_vls_init(&p->s_info->_absolute_rotate_vls[Z]);
  bu_vls_init(&p->s_info->_absolute_model_rotate_vls[X]);
  bu_vls_init(&p->s_info->_absolute_model_rotate_vls[Y]);
  bu_vls_init(&p->s_info->_absolute_model_rotate_vls[Z]);
  bu_vls_init(&p->s_info->_absolute_scale_vls);
  bu_vls_init(&p->s_info->_xadc_vls);
  bu_vls_init(&p->s_info->_yadc_vls);
  bu_vls_init(&p->s_info->_ang1_vls);
  bu_vls_init(&p->s_info->_ang2_vls);
  bu_vls_init(&p->s_info->_distadc_vls);
  bu_vls_init(&p->s_info->_Viewscale_vls);
#endif
d676 5
a680 40
  bu_vls_free(&p->s_info->_aet_name);
  bu_vls_free(&p->s_info->_ang_name);
  bu_vls_free(&p->s_info->_center_name);
  bu_vls_free(&p->s_info->_size_name);
  bu_vls_free(&p->s_info->_adc_name);

#ifdef UPDATE_TCL_SLIDERS
  bu_vls_free(&p->s_info->_rate_tran_vls[X]);
  bu_vls_free(&p->s_info->_rate_tran_vls[Y]);
  bu_vls_free(&p->s_info->_rate_tran_vls[Z]);
  bu_vls_free(&p->s_info->_rate_model_tran_vls[X]);
  bu_vls_free(&p->s_info->_rate_model_tran_vls[Y]);
  bu_vls_free(&p->s_info->_rate_model_tran_vls[Z]);
  bu_vls_free(&p->s_info->_rate_rotate_vls[X]);
  bu_vls_free(&p->s_info->_rate_rotate_vls[Y]);
  bu_vls_free(&p->s_info->_rate_rotate_vls[Z]);
  bu_vls_free(&p->s_info->_rate_model_rotate_vls[X]);
  bu_vls_free(&p->s_info->_rate_model_rotate_vls[Y]);
  bu_vls_free(&p->s_info->_rate_model_rotate_vls[Z]);
  bu_vls_free(&p->s_info->_rate_scale_vls);
  bu_vls_free(&p->s_info->_absolute_tran_vls[X]);
  bu_vls_free(&p->s_info->_absolute_tran_vls[Y]);
  bu_vls_free(&p->s_info->_absolute_tran_vls[Z]);
  bu_vls_free(&p->s_info->_absolute_model_tran_vls[X]);
  bu_vls_free(&p->s_info->_absolute_model_tran_vls[Y]);
  bu_vls_free(&p->s_info->_absolute_model_tran_vls[Z]);
  bu_vls_free(&p->s_info->_absolute_rotate_vls[X]);
  bu_vls_free(&p->s_info->_absolute_rotate_vls[Y]);
  bu_vls_free(&p->s_info->_absolute_rotate_vls[Z]);
  bu_vls_free(&p->s_info->_absolute_model_rotate_vls[X]);
  bu_vls_free(&p->s_info->_absolute_model_rotate_vls[Y]);
  bu_vls_free(&p->s_info->_absolute_model_rotate_vls[Z]);
  bu_vls_free(&p->s_info->_absolute_scale_vls);
  bu_vls_free(&p->s_info->_xadc_vls);
  bu_vls_free(&p->s_info->_yadc_vls);
  bu_vls_free(&p->s_info->_ang1_vls);
  bu_vls_free(&p->s_info->_ang2_vls);
  bu_vls_free(&p->s_info->_distadc_vls);
  bu_vls_free(&p->s_info->_Viewscale_vls);
#endif
d689 10
a698 139
  bu_vls_printf(&p->s_info->_aet_name, "%s(%S,aet)", MGED_DISPLAY_VAR,
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_ang_name, "%s(%S,ang)", MGED_DISPLAY_VAR,
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_center_name, "%s(%S,center)", MGED_DISPLAY_VAR,
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_size_name, "%s(%S,size)", MGED_DISPLAY_VAR,
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_adc_name, "%s(%S,adc)", MGED_DISPLAY_VAR,
		&p->_dmp->dm_pathName);

#ifdef UPDATE_TCL_SLIDERS
  bu_vls_printf(&p->s_info->_rate_tran_vls[X], "rate_tran(%S,X)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_rate_tran_vls[Y], "rate_tran(%S,Y)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_rate_tran_vls[Z], "rate_tran(%S,Z)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_rate_model_tran_vls[X], "rate_model_tran(%S,X)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_rate_model_tran_vls[Y], "rate_model_tran(%S,Y)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_rate_model_tran_vls[Z], "rate_model_tran(%S,Z)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_rate_rotate_vls[X], "rate_rotate(%S,X)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_rate_rotate_vls[Y], "rate_rotate(%S,Y)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_rate_rotate_vls[Z], "rate_rotate(%S,Z)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_rate_model_rotate_vls[X], "rate_model_rotate(%S,X)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_rate_model_rotate_vls[Y], "rate_model_rotate(%S,Y)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_rate_model_rotate_vls[Z], "rate_model_rotate(%S,Z)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_rate_scale_vls, "rate_scale(%S)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_absolute_tran_vls[X], "abs_tran(%S,X)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_absolute_tran_vls[Y], "abs_tran(%S,Y)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_absolute_tran_vls[Z], "abs_tran(%S,Z)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_absolute_model_tran_vls[X], "abs_model_tran(%S,X)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_absolute_model_tran_vls[Y], "abs_model_tran(%S,Y)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_absolute_model_tran_vls[Z], "abs_model_tran(%S,Z)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_absolute_rotate_vls[X], "abs_rotate(%S,X)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_absolute_rotate_vls[Y], "abs_rotate(%S,Y)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_absolute_rotate_vls[Z], "abs_rotate(%S,Z)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_absolute_model_rotate_vls[X], "abs_model_rotate(%S,X)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_absolute_model_rotate_vls[Y], "abs_model_rotate(%S,Y)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_absolute_model_rotate_vls[Z], "abs_model_rotate(%S,Z)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_absolute_scale_vls, "abs_scale(%S)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_xadc_vls, "xadc(%S)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_yadc_vls, "yadc(%S)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_ang1_vls, "ang1(%S)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_ang2_vls, "ang2(%S)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_distadc_vls, "distadc(%S)",
		&p->_dmp->dm_pathName);
  bu_vls_printf(&p->s_info->_Viewscale_vls, "Viewscale(%S)",
		&p->_dmp->dm_pathName);

  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_rate_tran_vls[X]),
	      (char *)&p->s_info->_rate_tran[X], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_rate_tran_vls[Y]),
	      (char *)&p->s_info->_rate_tran[Y], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_rate_tran_vls[Z]),
	      (char *)&p->s_info->_rate_tran[Z], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_rate_model_tran_vls[X]),
	      (char *)&p->s_info->_rate_model_tran[X], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_rate_model_tran_vls[Y]),
	      (char *)&p->s_info->_rate_model_tran[Y], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_rate_model_tran_vls[Z]),
	      (char *)&p->s_info->_rate_model_tran[Z], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_rate_rotate_vls[X]),
	      (char *)&p->s_info->_rate_rotate[X], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_rate_rotate_vls[Y]),
	      (char *)&p->s_info->_rate_rotate[Y], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_rate_rotate_vls[Z]),
	      (char *)&p->s_info->_rate_rotate[Z], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_rate_model_rotate_vls[X]),
	      (char *)&p->s_info->_rate_model_rotate[X], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_rate_model_rotate_vls[Y]),
	      (char *)&p->s_info->_rate_model_rotate[Y], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_rate_model_rotate_vls[Z]),
	      (char *)&p->s_info->_rate_model_rotate[Z], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_rate_scale_vls),
	      (char *)&p->s_info->_rate_scale, TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_absolute_tran_vls[X]),
	      (char *)&p->s_info->_absolute_tran[X], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_absolute_tran_vls[Y]),
	      (char *)&p->s_info->_absolute_tran[Y], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_absolute_tran_vls[Z]),
	      (char *)&p->s_info->_absolute_tran[Z], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_absolute_model_tran_vls[X]),
	      (char *)&p->s_info->_absolute_model_tran[X], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_absolute_model_tran_vls[Y]),
	      (char *)&p->s_info->_absolute_model_tran[Y], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_absolute_model_tran_vls[Z]),
	      (char *)&p->s_info->_absolute_model_tran[Z], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_absolute_rotate_vls[X]),
	      (char *)&p->s_info->_absolute_rotate[X], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_absolute_rotate_vls[Y]),
	      (char *)&p->s_info->_absolute_rotate[Y], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_absolute_rotate_vls[Z]),
	      (char *)&p->s_info->_absolute_rotate[Z], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_absolute_model_rotate_vls[X]),
	      (char *)&p->s_info->_absolute_model_rotate[X], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_absolute_model_rotate_vls[Y]),
	      (char *)&p->s_info->_absolute_model_rotate[Y], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_absolute_model_rotate_vls[Z]),
	      (char *)&p->s_info->_absolute_model_rotate[Z], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_absolute_scale_vls),
	      (char *)&p->s_info->_absolute_scale, TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_xadc_vls),
	      (char *)&p->s_info->_dv_xadc, TCL_LINK_INT);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_yadc_vls),
	      (char *)&p->s_info->_dv_yadc, TCL_LINK_INT);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_distadc_vls),
	      (char *)&p->s_info->_dv_distadc, TCL_LINK_INT);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_Viewscale_vls),
	      (char *)&p->s_info->_Viewscale,
	      TCL_LINK_DOUBLE|TCL_LINK_READ_ONLY);
#endif
a704 34
#ifdef UPDATE_TCL_SLIDERS
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_rate_tran_vls[X]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_rate_tran_vls[Y]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_rate_tran_vls[Z]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_rate_model_tran_vls[X]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_rate_model_tran_vls[Y]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_rate_model_tran_vls[Z]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_rate_rotate_vls[X]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_rate_rotate_vls[Y]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_rate_rotate_vls[Z]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_rate_model_rotate_vls[X]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_rate_model_rotate_vls[Y]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_rate_model_rotate_vls[Z]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_rate_scale_vls));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_absolute_tran_vls[X]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_absolute_tran_vls[Y]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_absolute_tran_vls[Z]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_absolute_model_tran_vls[X]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_absolute_model_tran_vls[Y]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_absolute_model_tran_vls[Z]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_absolute_rotate_vls[X]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_absolute_rotate_vls[Y]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_absolute_rotate_vls[Z]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_absolute_model_rotate_vls[X]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_absolute_model_rotate_vls[Y]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_absolute_model_rotate_vls[Z]));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_absolute_scale_vls));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_xadc_vls));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_yadc_vls));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_ang1_vls));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_ang2_vls));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_distadc_vls));
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_Viewscale_vls));
#endif
d717 1
a717 1
    Tcl_AppendElement(interp, bu_vls_addr(&dlp->_dmp->dm_pathName));
@


11.90
log
@*- now using MGED_DISPLAY_VAR
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.89 1998/06/25 07:37:24 mike Exp $ (BRL)";
d60 5
a64 3
extern void set_port(); /* defined in fbserv.c */
extern void predictor_init(); /* defined in predictor.c */
extern void set_scroll();  /* defined in set.c */
d71 1
a93 1
extern struct _mged_variables default_mged_variables;
d97 1
a97 1
static int windowbounds[6] = { XMIN, XMAX, YMIN, YMAX, -2048, 2047 };
d946 1
d949 4
@


11.89
log
@Port to sun4.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.88 1998/06/24 18:21:53 bparker Exp $ (BRL)";
d425 1
a425 1
  bu_vls_printf(&fps_name, "mged_display(%S,fps)",
d1069 1
a1069 1
  bu_vls_printf(&p->s_info->_aet_name, "mged_display(%S,aet)",
d1071 1
a1071 1
  bu_vls_printf(&p->s_info->_ang_name, "mged_display(%S,ang)",
d1073 1
a1073 1
  bu_vls_printf(&p->s_info->_center_name, "mged_display(%S,center)",
d1075 1
a1075 1
  bu_vls_printf(&p->s_info->_size_name, "mged_display(%S,size)",
d1077 1
a1077 1
  bu_vls_printf(&p->s_info->_adc_name, "mged_display(%S,adc)",
@


11.88
log
@*- ifdef Tcl slider variable names
*- remove call to color_soltab()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/attach.c,v 11.87 1998/06/11 14:28:08 bparker Exp $ (BRL)";
d1270 1
d1273 1
@


11.87
log
@*- remove the following ifdefs:
	USE_FRAMEBUFFER, DO_SNAP_TO_GRID, DO_RUBBER_BAND, USE_RT_ASPECT
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/attach.c,v 11.86 1998/03/19 18:00:08 bparker Exp $ (BRL)";
d49 1
d54 1
d63 1
a63 1
extern void color_soltab();
d190 1
a190 1
    if(rate_tran_vls[X].vls_magic == BU_VLS_MAGIC){
a448 1
  color_soltab();
d980 2
d1014 1
d1026 2
d1060 1
d1079 2
d1207 1
d1214 1
d1247 1
@


11.86
log
@adc variables are no longer mged_variables
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.85 1998/03/06 22:32:57 bparker Exp bparker $ (BRL)";
a68 1
#ifdef USE_FRAMEBUFFER
a70 1
#endif
a72 1
#ifdef USE_FRAMEBUFFER
a74 1
#endif
a175 1
#ifdef USE_FRAMEBUFFER
a185 1
#endif
a1252 1
#ifdef USE_FRAMEBUFFER
a1274 1
#endif
@


11.85
log
@*- clean up some old ADC related code
*- initialize adc_auto
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.84 1998/02/20 23:12:39 bparker Exp bparker $ (BRL)";
d970 1
a970 1
  mged_variables->adc_a1 = mged_variables->adc_a2 = 45.0;
@


11.84
log
@initial grid_auto_size
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.83 1998/02/06 21:58:47 bparker Exp bparker $ (BRL)";
d455 1
d970 1
a970 1
  adc_a1_deg = adc_a2_deg = 45.0;
a1198 4
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_ang1_vls),
	      (char *)&p->s_info->_adc_a1_deg, TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_ang2_vls),
	      (char *)&p->s_info->_adc_a2_deg, TCL_LINK_DOUBLE);
@


11.83
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.82 1998/01/28 16:01:12 bparker Exp bparker $ (BRL)";
d455 1
@


11.82
log
@*- added f_get_dm_list(), mged_fb_open() and mged_fb_close()
*- modified release() to release framebuffer resources if necessary
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.81 1997/12/23 14:25:19 bparker Exp bparker $ (BRL)";
a968 1
  mged_variables->v_axes_pos = initial_dm_list->_mged_variables->v_axes_pos;
@


11.81
log
@remove scroll_edit
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.80 1997/11/26 21:33:44 bparker Exp bparker $ (BRL)";
d55 2
d58 1
d69 2
d72 1
d75 3
d180 13
d1246 40
@


11.80
log
@add new Tcl variable links to MGED variables
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.79 1997/11/19 21:47:22 bparker Exp bparker $ (BRL)";
a217 4
  if(p->_scroll_edit_vls.vls_magic == BU_VLS_MAGIC){
    Tcl_UnlinkVar(interp, bu_vls_addr(&p->_scroll_edit_vls));
    bu_vls_free(&p->_scroll_edit_vls);
  }
a408 5
  bu_vls_init(&curr_dm_list->_scroll_edit_vls);
  bu_vls_printf(&curr_dm_list->_scroll_edit_vls, "scroll_edit(%S)",
		&curr_dm_list->_dmp->dm_pathName);
  Tcl_LinkVar(interp, bu_vls_addr(&curr_dm_list->_scroll_edit_vls),
	      (char *)&curr_dm_list->_scroll_edit, TCL_LINK_INT);
d651 2
d654 2
d758 2
d761 2
d799 2
d802 2
@


11.79
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.78 1997/11/14 15:12:52 bparker Exp bparker $ (BRL)";
d962 3
d968 3
d975 3
d981 3
d1005 3
d1011 3
d1018 3
d1024 3
d1058 6
d1070 6
d1084 6
d1096 6
d1123 6
d1135 6
d1149 6
d1161 6
d1191 3
d1197 3
d1204 3
d1210 3
@


11.78
log
@mods to reflect name changes in LIBDM
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.77 1997/11/03 15:16:43 bparker Exp bparker $ (BRL)";
a489 6
#if 0
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "openw -s -gt %s\n", line);
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
#else
a494 1
#endif
@


11.77
log
@use LIBDM macros
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.76 1997/10/10 21:05:00 bparker Exp bparker $ (BRL)";
d374 1
a374 1
    dm_process_options(tmp_dmp, &tmp_vls, argc - 1, argv + 1);
@


11.76
log
@mods to set window bounds once at display manager creation
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.75 1997/10/10 16:55:40 bparker Exp bparker $ (BRL)";
d88 1
a88 1
static int windowbounds[6] = { XMAX, XMIN, YMAX, YMIN, 2047, -2048 };
d206 1
a206 1
    dmp->dm_freeDLists(dmp, dmp->dm_displaylist + 1, 1);
d208 1
a208 2
    dmp->dm_freeDLists(dmp, BU_LIST_FIRST(solid, &HeadSolid.l)->s_dlist +
		       dmp->dm_displaylist,
d213 1
a213 1
    dmp->dm_close(dmp);
d442 1
a442 1
  dmp->dm_setWinBounds(dmp, windowbounds);
@


11.75
log
@register MGED's only registered event handler
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.74 1997/10/08 13:47:36 bparker Exp bparker $ (BRL)";
d39 1
d88 1
d442 3
a444 1
  ++dmaflag;
@


11.74
log
@mods to use Tcl_SetVar with vls strings
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.73 1997/09/11 13:30:43 bparker Exp bparker $ (BRL)";
d533 3
@


11.73
log
@*- mods to release() to properly free "new" display lists
*- mods to f_share_view() to reverse its behavior
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.72 1997/09/08 19:46:37 bparker Exp bparker $ (BRL)";
d514 6
a519 2
  if(dstr != (char *)NULL)
    Tcl_SetVar2(interp, "env", "DISPLAY", dstr, TCL_GLOBAL_ONLY);
d524 1
d530 1
d534 1
a534 2
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "wm withdraw . ; tk appname mged");
a536 10

#if 0
  /* Check to see if user specified MGED_GUIRC */
  if((filename = getenv("MGED_GUIRC")) != (char *)NULL )  {
	if( Tcl_EvalFile( interp, filename ) != TCL_OK )  {
		bu_log("Error reading %s:\n%s\n", filename,
			Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
	}
  }
#endif
@


11.72
log
@remove reattach()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.71 1997/09/08 18:22:01 bparker Exp bparker $ (BRL)";
d200 3
a202 1
    if(displaylist && mged_variables->dlist)
d204 1
a204 1
    dmp->dm_freeDLists(dmp, HeadSolid.s_dlist + dmp->dm_displaylist, 1);
d206 2
a207 1
    dmp->dm_freeDLists(dmp, HeadSolid.s_dlist + dmp->dm_displaylist,
d209 1
a209 1
		       HeadSolid.s_dlist + 1);
d733 4
a736 4
  /* free p1's s_info struct if not being used */
  if(!--p1->s_info->_rc){
    mged_slider_unlink_vars(p1);
    mged_slider_free_vls(p1);
d739 1
a739 1
    if(p->s_info->_headView.l.magic == BU_LIST_HEAD_MAGIC){
d743 2
a744 2
      for(vlp = BU_LIST_FIRST(view_list, &p->s_info->_headView.l);
	  BU_LIST_NOT_HEAD(vlp, &p->s_info->_headView.l);){
d752 4
a755 4
    bu_free( (genptr_t)p1->s_info, "share_view: s_info" );
  /* otherwise if p1's s_info struct is being used and p1 is the owner */
  }else if(p1->_owner)
    find_new_owner(p1);
d757 1
a757 1
  p1->_owner = 0;
d759 2
a760 2
  /* p1 now shares p2's s_info */
  p1->s_info = p2->s_info;
d764 2
a765 2
  curr_dm_list = p1;
  if(p1->aim){
d771 1
a771 1
  if(p1->aim)
d774 1
a774 1
  p1->_dmp->dm_vp = &p1->s_info->_Viewscale;
d777 1
a777 1
  ++p2->s_info->_rc;
d829 6
@


11.71
log
@*- new commands: f_share_vars() and f_unshare_vars() to share or stop
	sharing mged_variables
*- use new macro FOR_ALL_DISPLAYS
*- mged_variables is now a pointer
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.70 1997/09/03 14:08:11 bparker Exp bparker $ (BRL)";
a264 17


int
reattach()
{
  char *av[6];

  av[0] = "attach";
  av[1] = "-d";
  av[2] = bu_vls_addr(&dName);
  av[3] = "-n";
  av[4] = dmp->dm_name;
  av[5] = NULL;

  return f_attach((ClientData)NULL, interp, 5, av);
}

@


11.70
log
@mods to implement new display lists
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.69 1997/07/25 20:53:36 bparker Exp bparker $ (BRL)";
d55 1
d129 1
a129 1
    for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d200 1
a200 1
    if(displaylist && mged_variables.dlist)
d211 2
a212 1
	
d371 5
d445 1
a445 1
  if(displaylist && mged_variables.dlist)
d608 1
a608 1
f_untie(clientData, interp, argc, argv )
d624 1
a624 1
    bu_vls_printf(&vls, "help untie");
d638 1
a638 1
  for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) )
d643 1
a643 1
    Tcl_AppendResult(interp, "untie: bad pathname - %s\n",
d689 1
a689 1
f_tie(clientData, interp, argc, argv )
d705 1
a705 1
    bu_vls_printf(&vls, "help tie");
d724 1
a724 1
  for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d736 1
a736 1
    Tcl_AppendResult(interp, "f_tie: bad pathname(s)\n\tpathName1 - ",
d766 1
a766 1
    bu_free( (genptr_t)p1->s_info, "tie: s_info" );
d805 1
a805 1
  for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d832 96
d936 2
a937 5
#if 0
  mged_variables = default_mged_variables; /* struct copy */
#else
  mged_variables = initial_dm_list->_mged_variables; /* struct copy */
#endif
d942 1
d958 1
a958 1
  last_v_axes = initial_dm_list->_last_v_axes;
a960 1
#if 1
a961 1
#endif
@


11.69
log
@add new Tcl variable ---> Viewscale
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.68 1997/07/17 20:50:42 bparker Exp bparker $ (BRL)";
d39 1
a40 1
#include "./sedit.h"
d152 16
d198 10
a207 8
    /* Delete all references to display processor memory */
    FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
      rt_memfree( &(dmp->dm_map), sp->s_bytes, (unsigned long)sp->s_addr );
      sp->s_bytes = 0;
      sp->s_addr = 0;
    }
    rt_mempurge( &(dmp->dm_map) );
    
a410 1
  no_memory = 0;
d437 8
a444 11
  FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
    /* Write vector subs into new display processor */
    if( (sp->s_bytes = dmp->dm_cvtvecs( dmp, sp )) != 0 )  {
      sp->s_addr = rt_memalloc( &(dmp->dm_map), sp->s_bytes );
      if( sp->s_addr == 0 )  break;
      sp->s_bytes = dmp->dm_load(dmp, sp->s_addr, sp->s_bytes);
    } else {
      sp->s_addr = 0;
      sp->s_bytes = 0;
    }
  }
d839 5
d846 1
@


11.68
log
@*- remove azimuth tcl variable support
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.67 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
d873 1
d904 1
d961 2
d1002 3
d1030 1
@


11.67
log
@mods to run without a database
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.66 1997/06/25 13:32:44 bparker Exp bparker $ (BRL)";
d837 1
a837 1
  last_v_axes = 2; /* center location */
a860 1
  bu_vls_init(&p->s_info->_rate_azimuth_vls);
a867 1
  bu_vls_init(&p->s_info->_absolute_azimuth_vls);
a890 1
  bu_vls_free(&p->s_info->_rate_azimuth_vls);
a897 1
  bu_vls_free(&p->s_info->_absolute_azimuth_vls);
a934 2
  bu_vls_printf(&p->s_info->_rate_azimuth_vls, "rate_rotate(%S,azim)",
		&p->_dmp->dm_pathName);
a948 2
  bu_vls_printf(&p->s_info->_absolute_azimuth_vls, "abs_rotate(%S,azim)",
		&p->_dmp->dm_pathName);
a973 2
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_rate_azimuth_vls),
	      (char *)&p->s_info->_rate_azimuth, TCL_LINK_DOUBLE);
a987 2
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_absolute_azimuth_vls),
	      (char *)&p->s_info->azimuth, TCL_LINK_DOUBLE);
a1010 1
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_rate_azimuth_vls));
a1017 1
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_absolute_azimuth_vls));
@


11.66
log
@mods to support view ring
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.65 1997/05/29 14:06:46 bparker Exp bparker $ (BRL)";
d454 1
d480 6
d491 1
d819 1
d821 3
d830 1
a830 1
  am_mode = ALT_IDLE;
@


11.65
log
@mods for handling azimuth related Tcl variables
.,
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.64 1997/05/22 03:42:13 mike Exp bparker $ (BRL)";
a53 1
int mged_load_dv();
d57 1
a153 3
#if TRY_NEW_MGED_VARS
      mged_variable_free_vls(p);
#endif
d157 15
d178 2
a179 3
  for( BU_LIST_FOR(p_cmd, cmd_list, &head_cmd_list.l) )
    if(p_cmd->aim == p)
      break;
a180 3
  if(p_cmd->aim == p)
    p_cmd->aim = (struct dm_list *)NULL;

d198 1
a433 1
  (void)mged_load_dv();
a641 3
#if TRY_NEW_MGED_VARS
  mged_variable_setup(p);
#endif
d643 1
a719 3
#if TRY_NEW_MGED_VARS
    mged_variable_free_vls(p1);
#endif
d722 15
a780 4
#if TRY_NEW_MGED_VARS
      mged_variable_free_vls(p);
      mged_variable_setup(p);
#endif
d815 1
a815 1
  MAT_DELTAS_GET(orig_pos, toViewcenter);
d818 1
a818 1
  am_mode = ALT_MOUSE_MODE_IDLE;
d826 5
a1024 42
}


int
mged_load_dv()
{
  int i;

  for(i = 0; i < VIEW_TABLE_SIZE; ++i){
    press(default_view_strings[i]);
    bn_mat_copy(viewrot_table[i], Viewrot);
    viewscale_table[i] = Viewscale;
  }

  current_view = 0;
  bn_mat_copy(Viewrot, viewrot_table[current_view]);
  Viewscale = viewscale_table[current_view];
  new_mats();

  return TCL_OK;
}


/* Load default views */
int
f_load_dv(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  if(argc < 1 || 1 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help load_dv");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  return mged_load_dv();
@


11.64
log
@Added tk appname of "mged", for use with "send" command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.63 1997/05/22 03:35:31 mike Exp mike $ (BRL)";
d54 1
d425 1
a425 1
  (void)f_load_dv((ClientData)NULL, interp, 1, NULL);
d830 1
d838 1
d862 1
d870 1
d908 2
d924 2
d951 2
d967 2
d992 1
d1000 1
d1009 20
a1036 2
  int i;

d1047 1
a1047 12
  for(i = 0; i < VIEW_TABLE_SIZE; ++i){
    press(default_view_strings[i]);
    bn_mat_copy(viewrot_table[i], Viewrot);
    viewscale_table[i] = Viewscale;
  }

  current_view = 0;
  bn_mat_copy(Viewrot, viewrot_table[current_view]);
  Viewscale = viewscale_table[current_view];
  new_mats();

  return TCL_OK;
@


11.63
log
@BParker change, set mapped=1
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.62 1997/05/21 12:43:42 bparker Exp bparker $ (BRL)";
d505 1
a505 1
  bu_vls_printf(&vls, "wm withdraw .");
@


11.62
log
@*- mods to mged_attach
*- mods to mged_slider_link_vars
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.61 1997/05/08 14:31:27 bparker Exp bparker $ (BRL)";
d808 1
@


11.61
log
@mods to reflect changes to "struct w_dm"
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.60 1997/04/24 18:03:58 bparker Exp bparker $ (BRL)";
d344 21
a364 1
    if(gui_setup() == TCL_ERROR){
d368 4
d374 5
d391 1
a391 1
		&curr_dm_list->_dmp->dm_tkName);
d394 1
a394 1
		&curr_dm_list->_dmp->dm_tkName);
d479 2
a480 1
gui_setup()
d490 3
d495 1
a495 2
    Tcl_AppendResult(interp, "\ngui_setup: Try setting the TK_LIBRARY environment variable\n",
		               "           to the path where tk.tcl lives.\n\n", (char *)NULL);
d632 1
a632 1
  p->s_info->opp = &p->_dmp->dm_tkName;
d761 1
a761 1
      p->s_info->opp = &p->_dmp->dm_tkName;
d879 1
a879 1
		&p->_dmp->dm_tkName);
d881 1
a881 1
		&p->_dmp->dm_tkName);
d883 1
a883 1
		&p->_dmp->dm_tkName);
d885 1
a885 1
		&p->_dmp->dm_tkName);
d887 1
a887 1
		&p->_dmp->dm_tkName);
d889 1
a889 1
		&p->_dmp->dm_tkName);
d891 1
a891 1
		&p->_dmp->dm_tkName);
d893 1
a893 1
		&p->_dmp->dm_tkName);
d895 1
a895 1
		&p->_dmp->dm_tkName);
d897 1
a897 1
		&p->_dmp->dm_tkName);
d899 1
a899 1
		&p->_dmp->dm_tkName);
d901 1
a901 1
		&p->_dmp->dm_tkName);
d903 1
a903 1
		&p->_dmp->dm_tkName);
d905 1
a905 1
		&p->_dmp->dm_tkName);
d907 1
a907 1
		&p->_dmp->dm_tkName);
d909 1
a909 1
		&p->_dmp->dm_tkName);
d911 1
a911 1
		&p->_dmp->dm_tkName);
d913 1
a913 1
		&p->_dmp->dm_tkName);
d915 1
a915 1
		&p->_dmp->dm_tkName);
d917 1
a917 1
		&p->_dmp->dm_tkName);
d919 1
a919 1
		&p->_dmp->dm_tkName);
d921 1
a921 1
		&p->_dmp->dm_tkName);
d923 1
a923 1
		&p->_dmp->dm_tkName);
d925 1
a925 1
		&p->_dmp->dm_tkName);
@


11.60
log
@modify calls to Tcl_Eval
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.59 1997/04/23 18:26:17 bparker Exp bparker $ (BRL)";
a58 2
extern struct dm dm_Null;

a59 3
extern struct dm dm_Plot;	/* Unix Plot */
#define IS_DM_PLOT(dp) ((dp) == &dm_Plot)

a60 3
extern struct dm dm_PS;		/* PostScript */
#define IS_DM_PS(dp) ((dp) == &dm_PS)

a62 4
extern struct dm dm_X;
#define IS_DM_X(dp) ((dp) == &dm_X)
#else
#define IS_DM_X(dp) (0)
a63 1

a65 4
extern struct dm dm_ogl;
#define IS_DM_OGL(dp) ((dp) == &dm_ogl)
#else
#define IS_DM_OGL(dp) (0)
a66 1

a68 4
extern struct dm dm_glx;
#define IS_DM_GLX(dp) ((dp) == &dm_glx)
#else
#define IS_DM_GLX(dp) (0)
a69 1

a71 4
extern struct dm dm_pex;
#define IS_DM_PEX(dp) ((dp) == &dm_pex)
#else
#define IS_DM_PEX(dp) (0)
d74 5
a78 5
#define NEED_GUI(dp) ( \
	IS_DM_OGL(dp) || \
	IS_DM_GLX(dp) || \
	IS_DM_PEX(dp) || \
	IS_DM_X(dp) )
d95 2
a96 2
  { &dm_Plot, Plot_dm_init },  /* DM_PLOT_INDEX defined in mged_dm.h */
  { &dm_PS, PS_dm_init },      /* DM_PS_INDEX defined in mged_dm.h */
d98 1
a98 1
  { &dm_X, X_dm_init },
a99 3
#ifdef DM_PEX
  { &dm_pex, Pex_dm_init },
#endif
d101 1
a101 1
  { &dm_ogl, Ogl_dm_init },
d104 4
a107 1
  { &dm_glx, Glx_dm_init },
d109 1
a109 1
  { (struct dm *)0, (int (*)())0}
d301 2
a302 2
  for( wp = &which_dm[0]; wp->dp != (struct dm *)0; wp++ )
    if( strcmp(argv[argc - 1], wp->dp->dm_name ) == 0 )
d305 1
a305 1
  if(wp->dp == (struct dm *)0){
d343 1
a343 1
  if(tkwin == NULL && NEED_GUI(wp->dp)){
d421 2
a422 2
    for( ; wp->dp != (struct dm *)0; wp++ )
      bu_log("|%s", wp->dp->dm_name);
d431 2
a432 2
    for( wp = &which_dm[0]; wp->dp != (struct dm *)0; wp++ )
      if( strcmp( line, wp->dp->dm_name ) == 0 )
d435 1
a435 1
    if( wp->dp != (struct dm *)0 )
d477 1
d485 1
@


11.59
log
@added a few comments and moved 'struct w_dm' to mged_dm.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.58 1997/04/18 12:28:53 bparker Exp bparker $ (BRL)";
d235 6
a240 1
    Tcl_Eval(interp, "help release");
d318 6
a323 1
    Tcl_Eval(interp, "help attach");
d481 1
d499 4
a502 1
  (void)Tcl_Eval( interp, "wm withdraw .");
d536 6
a541 1
    Tcl_Eval(interp, "help dm");
d576 7
a582 1
    Tcl_Eval(interp, "help untie");
d659 6
a664 1
    Tcl_Eval(interp, "help tie");
d997 6
a1002 1
    Tcl_Eval(interp, "help load_dv");
@


11.58
log
@mods to argc parameter when calling f_load_dv
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.57 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d121 3
a123 8
struct w_dm {
  struct dm *dp;
  int (*init)();
};

static struct w_dm which_dm[] = {
  { &dm_Plot, Plot_dm_init },
  { &dm_PS, PS_dm_init },
d759 1
a759 1
  mged_variables = default_mged_variables;
@


11.57
log
@mods so that commands check args internally
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.56 1997/04/04 19:54:00 bparker Exp bparker $ (BRL)";
a390 1
  (void)f_load_dv((ClientData)NULL, interp, 0, NULL);
d417 1
@


11.56
log
@mods to prompt for a display manager
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.55 1997/03/20 23:01:19 bparker Exp bparker $ (BRL)";
d239 2
a240 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d242 1
d317 2
a318 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL)){
d526 2
a527 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d529 1
d561 4
a564 2
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
        return TCL_ERROR;
d638 2
a639 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d641 1
d971 2
a972 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d974 1
@


11.55
log
@mods to f_attach
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.54 1997/03/20 14:45:52 bparker Exp bparker $ (BRL)";
d44 3
a313 2
  register struct solid *sp;
  register struct dm_list *o_dm_list;
d315 2
a316 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d318 1
d326 11
a336 1
    Tcl_AppendResult(interp, "\tPlease attach to one of the following display manager types: ", (char *)NULL);
d347 10
a356 2
    return TCL_ERROR;
  }
d426 39
@


11.54
log
@mods to f_attach
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.53 1997/03/07 02:51:55 mike Exp bparker $ (BRL)";
d323 11
a333 1
    Tcl_AppendResult(interp, "\tPlease attach to either X, ogl, or glx.\n", (char *)NULL);
d399 1
a399 1
  if(dmp != (genptr_t)0)
@


11.53
log
@If there is an error in a Tcl .mgedrc file, provide full error trace.
Debugging is hard enough even with the trace.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.52 1997/03/06 21:37:56 bparker Exp mike $ (BRL)";
d45 4
d255 1
a255 1
    return release(NULL, 1);
d332 6
a337 2
    if(gui_setup() == TCL_ERROR)
      goto Bad;
d701 1
d731 1
d761 1
d856 1
a856 1

@


11.52
log
@added variable fps_name
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.51 1997/03/06 14:08:17 bparker Exp bparker $ (BRL)";
d415 6
a420 4
  if((filename = getenv("MGED_GUIRC")) == (char *)NULL )
    return TCL_OK;

  (void)Tcl_EvalFile( interp, filename );
@


11.51
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.50 1997/02/28 21:26:37 bparker Exp bparker $ (BRL)";
d340 3
d694 5
a698 4
  bu_vls_init(&p->s_info->aet_name);
  bu_vls_init(&p->s_info->ang_name);
  bu_vls_init(&p->s_info->center_name);
  bu_vls_init(&p->s_info->size_name);
d723 5
a727 4
  bu_vls_free(&p->s_info->aet_name);
  bu_vls_free(&p->s_info->ang_name);
  bu_vls_free(&p->s_info->center_name);
  bu_vls_free(&p->s_info->size_name);
d754 3
a756 1
  bu_vls_printf(&p->s_info->aet_name, "mged_display(%S,aet)",
d758 1
a758 1
  bu_vls_printf(&p->s_info->ang_name, "mged_display(%S,ang)",
d760 1
a760 1
  bu_vls_printf(&p->s_info->center_name, "mged_display(%S,center)",
d762 1
a762 1
  bu_vls_printf(&p->s_info->size_name, "mged_display(%S,size)",
@


11.50
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.49 1997/02/14 22:18:26 bparker Exp bparker $ (BRL)";
a325 1
#if 1
a331 1
#if DO_NEW_LIBDM_OPEN
a334 30
#else
  BU_GETSTRUCT(dmp, dm);
  *dmp = *wp->dp;
  dm_var_init(o_dm_list);
  no_memory = 0;
  if(wp->init(argc, argv) == DM_NULL)
    goto Bad;
#endif

#else
  BU_GETSTRUCT(dmp, dm);
  *dmp = *wp->dp;
  curr_dm_list->dm_init = wp->init;
  dm_var_init(o_dm_list);

  no_memory = 0;

  curr_dm_list->dm_init();
  bu_vls_init(&dmp->dm_initWinProc);
  bu_vls_strcpy(&dmp->dm_initWinProc, "mged_bind_dm");

  /* Only need to do this once */
  if(tkwin == NULL && NEED_GUI(wp->dp)){
    if(gui_setup() == TCL_ERROR)
      goto Bad;
  }

  if(dmp->dm_open(dmp, argc - 1, argv + 1))
    goto Bad;
#endif
d685 1
@


11.49
log
@*- mods to support mged_display tcl variables
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.48 1997/02/06 22:08:56 bparker Exp bparker $ (BRL)";
d182 1
a182 1
      mged_slider_free_vls(p->s_info);
d210 4
a213 6
#if 0
  bu_vls_free(&pathName);
  bu_vls_free(&dName);
  bu_vls_free(&dmp->dm_initWinProc);
  bu_free( (genptr_t)p->_dmp, "release: curr_dm_list->_dmp" );
#endif
d371 6
d379 2
d382 5
d547 1
a547 1
  p->s_info->opp = &p->_dmp->dm_pathName;
d625 1
a625 1
    mged_slider_free_vls(p1->s_info);
d669 1
a669 1
      p->s_info->opp = &p->_dmp->dm_pathName;
d675 1
a675 1
      mged_slider_free_vls(p->s_info);
d719 30
a748 2
mged_slider_init_vls(sip)
struct shared_info *sip;
d750 23
a772 53
  bu_vls_init(&sip->aet_name);
  bu_vls_init(&sip->ang_name);
  bu_vls_init(&sip->center_name);
  bu_vls_init(&sip->size_name);
  bu_vls_init(&sip->_scroll_edit_vls);
  bu_vls_init(&sip->_rate_tran_vls[X]);
  bu_vls_init(&sip->_rate_tran_vls[Y]);
  bu_vls_init(&sip->_rate_tran_vls[Z]);
  bu_vls_init(&sip->_rate_rotate_vls[X]);
  bu_vls_init(&sip->_rate_rotate_vls[Y]);
  bu_vls_init(&sip->_rate_rotate_vls[Z]);
  bu_vls_init(&sip->_rate_scale_vls);
  bu_vls_init(&sip->_absolute_tran_vls[X]);
  bu_vls_init(&sip->_absolute_tran_vls[Y]);
  bu_vls_init(&sip->_absolute_tran_vls[Z]);
  bu_vls_init(&sip->_absolute_rotate_vls[X]);
  bu_vls_init(&sip->_absolute_rotate_vls[Y]);
  bu_vls_init(&sip->_absolute_rotate_vls[Z]);
  bu_vls_init(&sip->_absolute_scale_vls);
  bu_vls_init(&sip->_xadc_vls);
  bu_vls_init(&sip->_yadc_vls);
  bu_vls_init(&sip->_ang1_vls);
  bu_vls_init(&sip->_ang2_vls);
  bu_vls_init(&sip->_distadc_vls);
}

mged_slider_free_vls(sip)
struct shared_info *sip;
{
  bu_vls_free(&sip->aet_name);
  bu_vls_free(&sip->ang_name);
  bu_vls_free(&sip->center_name);
  bu_vls_free(&sip->size_name);
  bu_vls_free(&sip->_scroll_edit_vls);
  bu_vls_free(&sip->_rate_tran_vls[X]);
  bu_vls_free(&sip->_rate_tran_vls[Y]);
  bu_vls_free(&sip->_rate_tran_vls[Z]);
  bu_vls_free(&sip->_rate_rotate_vls[X]);
  bu_vls_free(&sip->_rate_rotate_vls[Y]);
  bu_vls_free(&sip->_rate_rotate_vls[Z]);
  bu_vls_free(&sip->_rate_scale_vls);
  bu_vls_free(&sip->_absolute_tran_vls[X]);
  bu_vls_free(&sip->_absolute_tran_vls[Y]);
  bu_vls_free(&sip->_absolute_tran_vls[Z]);
  bu_vls_free(&sip->_absolute_rotate_vls[X]);
  bu_vls_free(&sip->_absolute_rotate_vls[Y]);
  bu_vls_free(&sip->_absolute_rotate_vls[Z]);
  bu_vls_free(&sip->_absolute_scale_vls);
  bu_vls_free(&sip->_xadc_vls);
  bu_vls_free(&sip->_yadc_vls);
  bu_vls_free(&sip->_ang1_vls);
  bu_vls_free(&sip->_ang2_vls);
  bu_vls_free(&sip->_distadc_vls);
d778 1
a778 1
  mged_slider_init_vls(p->s_info);
a787 2
  bu_vls_printf(&p->s_info->_scroll_edit_vls, "scroll_edit(%S)",
		&p->_dmp->dm_tkName);
a826 2
  Tcl_LinkVar(interp, bu_vls_addr(&p->s_info->_scroll_edit_vls),
	      (char *)&p->s_info->_scroll_edit, TCL_LINK_INT);
a870 1
  Tcl_UnlinkVar(interp, bu_vls_addr(&p->s_info->_scroll_edit_vls));
@


11.48
log
@mods to use latest libdm
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.47 1997/01/29 23:13:32 bparker Exp bparker $ (BRL)";
d178 3
d212 1
a212 1
  bu_vls_free(&dname);
d264 1
a264 1
  av[2] = bu_vls_addr(&dname);
d370 3
d537 3
d610 3
d659 4
d711 4
d740 4
d771 8
d780 1
a780 1
		&p->_dmp->dm_pathName);
d782 1
a782 1
		&p->_dmp->dm_pathName);
d784 1
a784 1
		&p->_dmp->dm_pathName);
d786 1
a786 1
		&p->_dmp->dm_pathName);
d788 1
a788 1
		&p->_dmp->dm_pathName);
d790 1
a790 1
		&p->_dmp->dm_pathName);
d792 1
a792 1
		&p->_dmp->dm_pathName);
d794 1
a794 1
		&p->_dmp->dm_pathName);
d796 1
a796 1
		&p->_dmp->dm_pathName);
d798 1
a798 1
		&p->_dmp->dm_pathName);
d800 1
a800 1
		&p->_dmp->dm_pathName);
d802 1
a802 1
		&p->_dmp->dm_pathName);
d804 1
a804 1
		&p->_dmp->dm_pathName);
d806 1
a806 1
		&p->_dmp->dm_pathName);
d808 1
a808 1
		&p->_dmp->dm_pathName);
d810 1
a810 1
		&p->_dmp->dm_pathName);
d812 1
a812 1
		&p->_dmp->dm_pathName);
d814 1
a814 1
		&p->_dmp->dm_pathName);
d816 1
a816 1
		&p->_dmp->dm_pathName);
d818 1
a818 1
		&p->_dmp->dm_pathName);
@


11.47
log
@experiment with libdm
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.46 1997/01/24 20:55:30 bparker Exp bparker $ (BRL)";
d44 1
a46 1
static void dm_var_init();
d54 1
a54 1
extern struct dm *Plot_dm_init();
d58 1
a58 1
extern struct dm *PS_dm_init();
d63 1
a63 1
extern struct dm *X_dm_init();
d71 1
a71 1
extern struct dm *Ogl_dm_init();
d79 1
a79 1
extern struct dm *Glx_dm_init();
d87 1
a87 1
extern struct dm *Pex_dm_init();
d116 1
a116 1
  struct dm *(*init)();
d134 1
a134 1
  { (struct dm *)0, (struct dm *(*)())0}
d332 2
a333 2
#if 0
  if((dmp = wp->init(argc, argv)) == DM_NULL)
d335 1
d670 1
a670 6
static void
#if 0
dm_var_init(initial_dm_list, name)
struct dm_list *initial_dm_list;
char *name;
#else
a672 1
#endif
a678 4
#if 0
  if(name)
    bu_vls_strcpy(&dname, name);
#endif
a689 2
  dmp->dm_vp = &Viewscale;
  curr_dm_list->s_info->opp = &pathName;
@


11.46
log
@mods to f_tie, f_untie, release and attach
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.45 1997/01/17 22:56:57 bparker Exp bparker $ (BRL)";
d54 1
a54 1
extern int Plot_dm_init();
d58 1
a58 1
extern int PS_dm_init();
d63 1
a63 1
extern int X_dm_init();
d71 1
a71 1
extern int Ogl_dm_init();
d79 1
a79 1
extern int Glx_dm_init();
d87 1
a87 1
extern int Pex_dm_init();
d116 1
a116 1
  int (*init)();
d134 1
a134 1
  { (struct dm *)0, (int (*)())0}
d151 1
d170 1
a170 1
    if(!strcmp("nu", bu_vls_addr(&pathName)))
a175 12
  if(need_close){
    /* Delete all references to display processor memory */
    FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
      rt_memfree( &(dmp->dm_map), sp->s_bytes, (unsigned long)sp->s_addr );
      sp->s_bytes = 0;
      sp->s_addr = 0;
    }
    rt_mempurge( &(dmp->dm_map) );
    
    dmp->dm_close(dmp);
  }
	
d194 14
d209 1
a210 1
  BU_LIST_DEQUEUE( &p->l );
d212 1
d234 5
a238 2
  if(argc == 2)
    return release(argv[1], 1);
d240 11
a250 1
  return release(NULL, 1);
d257 1
a257 1
  char *av[4];
d260 5
a264 3
  av[1] = dmp->dm_name;
  av[2] = dname;
  av[3] = NULL;
d266 1
a266 1
  return f_attach((ClientData)NULL, interp, 3, av);
a306 1
  register struct dm_list *dmlp;
a311 11
  if(argc == 1){
    wp = &which_dm[2];  /* not advertising dm_Plot or dm_PS */
    Tcl_AppendResult(interp, MORE_ARGS_STR,
		     "attach (", (wp++)->dp->dm_name, (char *)NULL);
    for( ; wp->dp != (struct dm *)0; wp++ )
      Tcl_AppendResult(interp, "|", wp->dp->dm_name, (char *)NULL);
    Tcl_AppendResult(interp, ")? ",  (char *)NULL);
    
    return TCL_ERROR;
  }

d313 1
a313 1
    if( strcmp(argv[1], wp->dp->dm_name ) == 0 )
d317 2
a318 1
    Tcl_AppendResult(interp, "attach(", argv[1], "): BAD\n", (char *)NULL);
d321 9
a329 13
  
  if(argc == 2 && NEED_GUI(wp->dp)){
    return do_2nd_attach_prompt();
  }else{
    BU_GETSTRUCT(dmlp, dm_list);
    BU_LIST_APPEND(&head_dm_list.l, &dmlp->l);
    o_dm_list = curr_dm_list;
    curr_dm_list = dmlp;
    BU_GETSTRUCT(dmp, dm);
    *dmp = *wp->dp;
    bu_vls_init(&pathName);
    curr_dm_list->dm_init = wp->init;
    dm_var_init(o_dm_list, argv[2]);
d332 18
d354 1
a354 1
  bu_vls_strcpy(&dmp->dm_initWinProc, "mged_bind_dm_win");
d358 1
a358 1
    if(gui_setup(argv[2]) == TCL_ERROR)
d362 1
a362 1
  if(dmp->dm_open(dmp, argc - 2, argv + 2))
d364 1
d369 1
d390 1
a390 1
  Tcl_AppendResult(interp, "attach(", argv[1], "): BAD\n", (char *)NULL);
d392 1
a392 1
  if(dmp->dm_vars != (genptr_t)0)
d402 1
a402 2
gui_setup(screen)
char *screen;
d485 1
d490 7
d498 1
a498 1
    if(!strcmp(argv[1], bu_vls_addr(&p->_dmp->dm_pathName)))
d502 3
a504 1
    Tcl_AppendResult(interp, "untie: bad pathname - %s\n", argv[1], (char *)NULL);
d508 2
d557 1
d562 13
d576 2
a577 1
    if(p1 == (struct dm_list *)NULL && !strcmp(argv[1], bu_vls_addr(&p->_dmp->dm_pathName)))
d579 2
a580 1
    else if(p2 == (struct dm_list *)NULL && !strcmp(argv[2], bu_vls_addr(&p->_dmp->dm_pathName)))
d587 5
a591 2
    Tcl_AppendResult(interp, "f_tie: bad pathname(s)\n\tpathName1 - ", argv[1],
		     "\t\tpathName2 - ", argv[2], "\n", (char *)NULL);
d595 3
d670 1
d674 4
d684 1
d686 2
a687 1
    strcpy(dname, name);
@


11.45
log
@checkin for weekend
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.44 1997/01/10 21:58:32 bparker Exp bparker $ (BRL)";
d48 1
d143 31
a173 40
	register struct solid *sp;
	struct dm_list *p;
	struct cmd_list *p_cmd;
	struct dm_list *save_dm_list = DM_LIST_NULL;

	if(name != NULL){
	  if(!strcmp("nu", name))
	    return TCL_OK;  /* Ignore */
	  for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
	    if(strcmp(name, bu_vls_addr(&p->_dmp->dm_pathName)))
	      continue;

	    /* found it */
	    if(p != curr_dm_list){
	      save_dm_list = curr_dm_list;
	      curr_dm_list = p;
	    }
	    break;
	  }

	  if(p == &head_dm_list){
	    Tcl_AppendResult(interp, "release: ", name,
			     " not found\n", (char *)NULL);
	    return TCL_ERROR;
	  }
	}else{
	  if(!strcmp("nu", bu_vls_addr(&pathName)))
	    return TCL_OK;  /* Ignore */
	  else
	    p = curr_dm_list;
	}

	if(need_close){
	  /* Delete all references to display processor memory */
	  FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
	    rt_memfree( &(dmp->dm_map), sp->s_bytes, (unsigned long)sp->s_addr );
	    sp->s_bytes = 0;
	    sp->s_addr = 0;
	  }
	  rt_mempurge( &(dmp->dm_map) );
d175 11
a185 2
	  dmp->dm_close(dmp);
	}
d187 17
a203 25
	if(!--p->s_info->_rc){
	  mged_slider_unlink_vars(p);
	  mged_slider_free_vls(p->s_info);
	  bu_free( (genptr_t)p->s_info, "release: s_info" );
	}else if(p->_owner)
	  find_new_owner(p);

	/* If this display is being referenced by a command window,
	   then remove the reference  */
	for( BU_LIST_FOR(p_cmd, cmd_list, &head_cmd_list.l) )
	  if(p_cmd->aim == p)
	    break;

	if(p_cmd->aim == p)
	  p_cmd->aim = (struct dm_list *)NULL;

	bu_vls_free(&pathName);
	BU_LIST_DEQUEUE( &p->l );
	bu_free( (genptr_t)p->_dmp, "release: curr_dm_list->_dmp" );
	bu_free( (genptr_t)p, "release: curr_dm_list" );

	if(save_dm_list != DM_LIST_NULL)
	  curr_dm_list = save_dm_list;
	else
	  curr_dm_list = (struct dm_list *)head_dm_list.l.forw;
d205 12
a216 1
	return TCL_OK;
d330 4
a339 3
  curr_dm_list->dm_init();
  bu_vls_init(&dmp->dm_initWinProc);
  bu_vls_strcpy(&dmp->dm_initWinProc, "mged_bind_dm_win");
d344 1
d460 2
d471 1
a471 1
    Tcl_AppendResult(interp, "f_untie: bad pathname - %s\n", argv[1], (char *)NULL);
d477 2
a481 8
      BU_GETSTRUCT(p->s_info, shared_info);
      bcopy((void *)sip, (void *)p->s_info, sizeof(struct shared_info));
      p->s_info->_rc = 1;
      p->_owner = 1;
      p->_dmp->dm_vp = &p->s_info->_Viewscale;
      p->s_info->opp = &p->_dmp->dm_pathName;
      mged_slider_link_vars(p);
      return TCL_OK;
a486 8
    BU_GETSTRUCT(p->s_info, shared_info);
    bcopy((void *)sip, (void *)p->s_info, sizeof(struct shared_info));
    p->s_info->_rc = 1;
    p->_owner = 1;
    p->_dmp->dm_vp = &p->s_info->_Viewscale;
    p->s_info->opp = &p->_dmp->dm_pathName;
    mged_slider_link_vars(p);
    return TCL_OK;
d488 21
d521 1
d528 1
a528 1
	p1 = p;
d555 12
d581 2
d590 1
d592 12
d626 1
a627 3
  (void)f_load_dv((ClientData)NULL, interp, 0, NULL);

  MAT_DELTAS_GET(orig_pos, toViewcenter);
d642 1
d667 1
d694 2
d735 2
d766 1
a766 1
	      (char *)&p->s_info->_dv_xadc, TCL_LINK_DOUBLE);
d768 1
a768 1
	      (char *)&p->s_info->_dv_yadc, TCL_LINK_DOUBLE);
d774 1
a774 1
	      (char *)&p->s_info->_dv_distadc, TCL_LINK_DOUBLE);
d781 1
@


11.44
log
@*- move f_release here from chgview.c
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.43 1997/01/02 22:12:41 bparker Exp bparker $ (BRL)";
d40 1
d103 1
d148 2
d168 1
a168 1
	  if( curr_dm_list == &head_dm_list )
d186 3
a188 1
	if(!--p->s_info->_rc)
d190 1
a190 1
	else if(p->_owner)
d319 1
a321 1
    dmp->dm_vp = &Viewscale;
d338 2
a355 4
#if 0
  dmp->dm_colorchange(dmp);
  dmp->dm_viewchange( dmp, DM_CHGV_REDO, SOLID_NULL );
#endif
a381 22
#if 0
  if((tkwin = Tk_CreateMainWindow(interp, screen, "MGED", "MGED")) == NULL){
    bu_log("gui_setup: Failed to create main window.\n");
    return TCL_ERROR;
  }

  /* This runs the tk.tcl script */
  if (Tk_Init(interp) == TCL_ERROR){
    bu_log("Tk_Init error %s\n", interp->result);
    return TCL_ERROR;
  }
#else

#if 0
  {
    Display *tkdpy;

    tkdpy = XOpenDisplay(":0.0");
    printf("stop\n");
  }
#endif

d383 3
a385 2
  if (Tk_Init(interp) == TCL_ERROR){
    bu_log("Tk_Init error %s\n", interp->result);
d390 1
a390 1
    bu_log("gui_setup: Failed to get main window.\n");
a392 1
#endif
d394 1
a394 1
  Tcl_Eval( interp, "wm withdraw .");
d400 1
a400 2
  if(Tcl_EvalFile( interp, filename ) == TCL_ERROR)
    bu_log("gui_setup: %s\n", interp->result);
d477 2
a478 1
      
d481 1
a481 1
      return TCL_OK; /* Nothing to do */
d490 2
a491 1

d526 3
a528 1
  if(!--p1->s_info->_rc)
d531 1
a531 1
  else if(p1->_owner)
d558 3
d577 1
a577 2
  bcopy((void *)&default_mged_variables, (void *)&mged_variables,
	sizeof(struct _mged_variables));
d592 161
d754 1
@


11.43
log
@.
@
text
@d5 2
d8 2
a9 1
 *	release		detach from current display processor
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.42 1997/01/02 19:38:47 bparker Exp bparker $ (BRL)";
d134 1
d208 18
@


11.42
log
@mods to use libbn and libbu
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.41 1996/12/04 21:19:21 bparker Exp bparker $ (BRL)";
d570 3
a572 2
  strcpy(dname, name);
  bn_mat_copy(Viewrot, identity);
@


11.41
log
@*** empty log message ***
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.40 1996/11/19 21:04:59 bparker Exp bparker $ (BRL)";
d571 1
a571 1
  mat_copy(Viewrot, identity);
d599 1
a599 1
    mat_copy(viewrot_table[i], Viewrot);
d604 1
a604 1
  mat_copy(Viewrot, viewrot_table[current_view]);
@


11.40
log
@Modification to work with TK version 4.2 and Tcl version 7.6
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.39 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
d187 4
a190 1
	    p_cmd->aim = (struct dm_list *)NULL;
d304 4
a307 1
  if( curr_dm_list->dm_init(argc - 1, argv + 1) )
a569 1
  bu_vls_init(&pathName);
@


11.39
log
@hacks to use latest libdm
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.38 1996/10/18 13:53:51 bparker Exp bparker $ (BRL)";
d350 1
d361 22
@


11.38
log
@call color_soltab before calling dmr_colorchange
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.37 1996/10/09 16:55:11 bparker Exp bparker $ (BRL)";
d143 1
a143 1
	    if(strcmp(name, bu_vls_addr(&p->_dmp->dmr_pathName)))
d169 1
a169 1
	    rt_memfree( &(dmp->dmr_map), sp->s_bytes, (unsigned long)sp->s_addr );
d173 1
a173 1
	  rt_mempurge( &(dmp->dmr_map) );
d175 1
a175 1
	  dmp->dmr_close(dmp);
d208 1
a208 1
  av[1] = dmp->dmr_name;
d262 1
a262 1
		     "attach (", (wp++)->dp->dmr_name, (char *)NULL);
d264 1
a264 1
      Tcl_AppendResult(interp, "|", wp->dp->dmr_name, (char *)NULL);
d271 1
a271 1
    if( strcmp(argv[1], wp->dp->dmr_name ) == 0 )
d288 1
a288 1
    dm_init = wp->init;
d290 1
a290 1
    dmp->dmr_vp = &Viewscale;
d301 1
a301 1
  if( dm_init(argc - 1, argv + 1) )
d304 1
a304 1
  Tcl_AppendResult(interp, "ATTACHING ", dmp->dmr_name, " (", dmp->dmr_lname,
d309 2
a310 2
    if( (sp->s_bytes = dmp->dmr_cvtvecs( dmp, sp )) != 0 )  {
      sp->s_addr = rt_memalloc( &(dmp->dmr_map), sp->s_bytes );
d312 1
a312 1
      sp->s_bytes = dmp->dmr_load(dmp, sp->s_addr, sp->s_bytes);
d320 4
a323 2
  dmp->dmr_colorchange(dmp);
  dmp->dmr_viewchange( dmp, DM_CHGV_REDO, SOLID_NULL );
d330 2
a331 2
  if(dmp->dmr_vars != (genptr_t)0)
    release((char *)NULL, 1);  /* relesae() will call dmr_close */
d333 1
a333 1
    release((char *)NULL, 0);  /* release() will not call dmr_close */
d386 4
a389 3
  if( !dmp->dmr_cmd )  {
    Tcl_AppendResult(interp, "The '", dmp->dmr_name,
		     "' display manager does not support any local commands.\n", (char *)NULL);
d396 1
a396 1
  return dmp->dmr_cmd( argc-1, argv+1 );
d427 1
a427 1
    if(!strcmp(argv[1], bu_vls_addr(&p->_dmp->dmr_pathName)))
d444 1
a444 1
      p->_dmp->dmr_vp = &p->s_info->_Viewscale;
d456 1
a456 1
    p->_dmp->dmr_vp = &p->s_info->_Viewscale;
d477 1
a477 1
    if(p1 == (struct dm_list *)NULL && !strcmp(argv[1], bu_vls_addr(&p->_dmp->dmr_pathName)))
d479 1
a479 1
    else if(p2 == (struct dm_list *)NULL && !strcmp(argv[2], bu_vls_addr(&p->_dmp->dmr_pathName)))
d503 1
a503 1
  p1->_dmp->dmr_vp = &p1->s_info->_Viewscale;
@


11.37
log
@fixed bug that improperly handled bad arguments to attach
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.36 1996/10/03 20:22:09 bparker Exp bparker $ (BRL)";
d319 1
@


11.36
log
@get rid of extra cmdline() uses
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.35 1996/09/30 19:43:18 bparker Exp bparker $ (BRL)";
d132 1
a132 1
release(name)
d134 1
d166 10
a175 5
	/* Delete all references to display processor memory */
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
		rt_memfree( &(dmp->dmr_map), sp->s_bytes, (unsigned long)sp->s_addr );
		sp->s_bytes = 0;
		sp->s_addr = 0;
d177 1
a177 4
	rt_mempurge( &(dmp->dmr_map) );

	dmp->dmr_close(dmp);

d274 5
a278 3
  if(wp == (struct w_dm *)0)
    goto Bad;

d327 4
a330 2
  if(wp != (struct w_dm *)0)
    release((char *)NULL);
@


11.35
log
@remove dmr_hp and dmr_cfunc
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.34 1996/09/26 20:39:30 bparker Exp bparker $ (BRL)";
d100 6
a105 6
static char *view_cmd_str[] = {
  "press top",
  "press right",
  "press front",
  "press 45,45",
  "press 35,25"
d202 6
a207 2
  struct bu_vls cmd;
  int status;
d209 1
a209 6
  bu_vls_init(&cmd);
  bu_vls_printf(&cmd, "attach %s %s\n", dmp->dmr_name, dname);
  release((char *)NULL);
  status = cmdline(&cmd, FALSE);
  bu_vls_free(&cmd);
  return status;
a553 1
  struct bu_vls vls;
a557 1
  bu_vls_init(&vls);
d559 1
a559 2
    bu_vls_strcpy(&vls, view_cmd_str[i]);
    (void)cmdline(&vls, False);
a562 1
  bu_vls_free(&vls);
@


11.34
log
@call gui_setup with display string
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.33 1996/09/25 19:56:53 bparker Exp bparker $ (BRL)";
a283 2
    dmp->dmr_hp = &HeadSolid;  /*XXX Temporary */
    dmp->dmr_cfunc = color_soltab;
a315 3
#if 0  /* dmr_colorchange already does this */
  color_soltab();
#endif
@


11.33
log
@now using more generalized solid macros
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.32 1996/09/23 18:38:45 bparker Exp bparker $ (BRL)";
d39 1
d176 1
a176 1
	  bu_free( (char *)p->s_info, "release: s_info" );
d188 2
a189 1
	bu_free( (char *)p, "release: curr_dm_list" );
d294 4
a297 2
  if(tkwin == NULL && NEED_GUI(wp->dp))
    gui_setup();
d332 35
@


11.32
log
@ use LIBDM permanently
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.31 1996/09/17 21:22:01 bparker Exp bparker $ (BRL)";
d36 1
a36 1
#include "./solid.h"
d165 1
a165 1
	FOR_ALL_SOLIDS( sp )  {
d276 1
a276 2
    dmlp = (struct dm_list *)bu_malloc(sizeof(struct dm_list), "struct dm_list");
    bzero((void *)dmlp, sizeof(struct dm_list));
d280 1
a280 1
    dmp = (struct dm *)bu_malloc(sizeof(struct dm), "struct dm");
d282 2
d286 1
d301 1
a301 1
  FOR_ALL_SOLIDS( sp )  {
d314 1
d316 1
d396 1
a396 2
      p->s_info = (struct shared_info *)bu_malloc(sizeof(struct shared_info),
						  "shared_info");
d399 2
d408 1
a408 2
    p->s_info = (struct shared_info *)bu_malloc(sizeof(struct shared_info),
						"shared_info");
d412 1
a446 1
  /*XXX this screws things up for dm-ogl's viewscale pointer --- needs fixing */
d459 2
d493 1
a493 3
  curr_dm_list->s_info = (struct shared_info *)bu_malloc(sizeof(struct shared_info),
							 "shared_info");
  bzero((void *)curr_dm_list->s_info, sizeof(struct shared_info));
@


11.31
log
@prepare to use libdm
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.30 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d34 1
d37 1
a37 1
#include "./dm.h"
a38 4
MGED_EXTERN(void	Nu_input, (fd_set *input, int noblock) );
static void	Nu_void();
static int	Nu_int0();
static unsigned Nu_unsign();
d43 1
a43 24
struct dm dm_Null = {
  Nu_int0,
  Nu_int0, Nu_void,
  Nu_input,
  Nu_void, Nu_void,
  Nu_void, Nu_void,
  Nu_void,
  Nu_void, Nu_void,
  Nu_void,
  Nu_int0,
  Nu_unsign, Nu_unsign,
  Nu_void,
  Nu_void,
  Nu_void,
  Nu_void, Nu_void, Nu_int0, Nu_int0,
  0,			/* no displaylist */
  0,			/* no display to release */
  0.0,
  "nu", "Null Display",
  0,
  0,
  0,
  0
};
d46 3
a48 2
extern struct dm dm_Tek;	/* Tek 4014 */
extern struct dm dm_T49;	/* Tek 4109 */
d50 3
a55 38
#ifdef DM_MG
/* We only supply a kernel driver for Berkeley VAX systems for the MG */
extern struct dm dm_Mg;
#endif

#ifdef DM_VG
/* We only supply a kernel driver for Berkeley VAX systems for the VG */
extern struct dm dm_Vg;
#endif

#ifdef DM_RAT
extern struct dm dm_Rat;
#endif

#ifdef DM_RAT80
extern struct dm dm_Rat80;
#endif

#ifdef DM_MER
extern struct dm dm_Mer;
#endif

#ifdef DM_PS
extern struct dm dm_Ps;
#endif

#ifdef DM_IR
extern struct dm dm_Ir;
#endif

#ifdef DM_4D
extern struct dm dm_4d;
#endif

#ifdef DM_SUNPW
extern struct dm dm_SunPw;
#endif

d57 1
a63 4
#ifdef DM_XGL
extern struct dm dm_XGL;
#endif

d65 1
d73 1
d81 1
a87 8
#ifdef USE_LIBDM
extern int Ogl_dm_init();
extern int X_dm_init();
extern int Glx_dm_init();
extern int Pex_dm_init();
extern int PS_dm_init();
extern void color_soltab();

d92 1
a92 3
	IS_DM_X(dp) || \
	0)
#endif
d107 10
a116 7
static struct dm *which_dm[] = {
	&dm_PS,  /* We won't be advertising this guy --- access is now through the ps command */
	&dm_Tek,
	&dm_T49,
	&dm_Plot,
#ifdef DM_IR
	&dm_Ir,
d118 2
a119 2
#ifdef DM_4D
	&dm_4d,
d121 2
a122 8
#ifdef DM_XGL
	&dm_XGL,
#endif
#ifdef DM_GT
	&dm_gt,
#endif
#ifdef DM_SUNPW
	&dm_SunPw,
d125 1
a125 4
	&dm_glx,
#endif
#ifdef DM_PEX
	&dm_pex,
d127 1
a127 22
#ifdef DM_X
	&dm_X,
#endif
#ifdef DM_MG
	&dm_Mg,
#endif
#ifdef DM_VG
	&dm_Vg,
#endif
#ifdef DM_RAT
	&dm_Rat,
#endif
#ifdef DM_MER
	&dm_Mer,
#endif
#ifdef DM_PS
	&dm_Ps,
#endif
#ifdef DM_OGL
	&dm_ogl,
#endif
	0
a171 1
#ifdef USE_LIBDM
a172 3
#else
	dmp->dmr_close();
#endif
d179 2
a180 1
	/* If this display is being referenced by a command window, remove it */
a196 41
static int Nu_int0() { return(0); }
static void Nu_void() { ; }
static unsigned Nu_unsign() { return(0); }

/*
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 */
void
Nu_input( input, noblock )
fd_set		*input;
int		noblock;
{
	struct timeval	tv;
	int		width;
	int		cnt;

	if( !isatty(fileno(stdin)) )  return;	/* input awaits! */

#if defined(_SC_OPEN_MAX)
	if( (width = sysconf(_SC_OPEN_MAX)) <= 0 || width > 32)
#endif
		width = 32;

	if( noblock )  {
		/* 1/20th second */
		tv.tv_sec = 0;
		tv.tv_usec = 50000;
	} else {
		/* Wait a VERY long time for user to type something */
		tv.tv_sec = 9999999;
		tv.tv_usec = 0;
	}
	cnt = select( width, input, (fd_set *)0,  (fd_set *)0, &tv );
	if( cnt < 0 )  {
		perror("Nu_input/select()");
	}
}

d213 1
a213 2
do_2nd_attach_prompt(name)
char *name;
a214 5
  static char plot_default[] = "pl-fb";
  static char tek_default[] = "/dev/tty";
#if 0
  static char ps_default[] = "mged.ps";
#endif
d216 2
d220 1
d223 8
a230 23
  if(!strcmp(name, "plot")){
    dm_default = plot_default;
    bu_vls_printf(&prompt, "UNIX-Plot filter [pl-fb]? ");
  }else if(!strcmp(name, "tek")){
    dm_default = tek_default;
    bu_vls_printf(&prompt, "Output tty [stdout]? ");
#if 0
  }else if(!strcmp(name, "ps")){
    dm_default = ps_default;
    bu_vls_printf(&prompt, "PostScript file [mged.ps]? ");
#endif
  }else{
    char  hostname[80];
    char  display[82];

    /* get or create the default display */
    if( (dm_default = getenv("DISPLAY")) == NULL ) {
      /* Env not set, use local host */
      gethostname( hostname, 80 );
      hostname[79] = '\0';
      (void)sprintf( display, "%s:0", hostname );
      dm_default = display;
    }
d232 1
a232 2
    bu_vls_printf(&prompt, "Display [%s]? ", dm_default);
  }
a239 1

d247 1
a247 1
  register struct dm **dp;
d256 5
a260 4
    dp = &which_dm[1];  /* not advertising dm_PS */
    Tcl_AppendResult(interp, MORE_ARGS_STR, "attach (", (*dp++)->dmr_name, (char *)NULL);
    for( ; *dp != (struct dm *)0; dp++ )
      Tcl_AppendResult(interp, "|", (*dp)->dmr_name, (char *)NULL);
d266 2
a267 2
  for( dp = &which_dm[0]; *dp != (struct dm *)0; dp++ )
    if( strcmp(argv[1], (*dp)->dmr_name ) == 0 )
d270 1
a270 1
  if(*dp == (struct dm *)0)
d273 2
a274 2
  if(argc == 2){
    return do_2nd_attach_prompt((*dp)->dmr_name);
d282 3
a284 2
    *dmp = **dp;
    dm_var_init(o_dm_list, argv[2], *dp);
d290 1
a290 1
  if(tkwin == NULL && NEED_GUI(*dp))
d293 1
a293 5
#ifdef USE_LIBDM
  if( dm_init() )
    goto Bad;
#else
  if( dmp->dmr_open() )
a294 1
#endif
a300 1
#ifdef USE_LIBDM
a301 3
#else
    if( (sp->s_bytes = dmp->dmr_cvtvecs( sp )) != 0 )  {
#endif
a303 1
#ifdef USE_LIBDM
a304 3
#else
      sp->s_bytes = dmp->dmr_load(sp->s_addr, sp->s_bytes);
#endif
a310 1
#ifdef USE_LIBDM
a311 3
#else
  dmp->dmr_colorchange();
#endif
a312 1
#ifdef USE_LIBDM
a313 3
#else
  dmp->dmr_viewchange( DM_CHGV_REDO, SOLID_NULL );
#endif
d320 1
a320 1
  if(*dp != (struct dm *)0)
d481 1
a481 1
dm_var_init(initial_dm_list, name, dp)
a483 1
struct dm *dp;
a501 14
#ifdef USE_LIBDM
  if(IS_DM_X(dp))
    dm_init = X_dm_init;
  else if(IS_DM_OGL(dp))
    dm_init = Ogl_dm_init;
  else if(IS_DM_GLX(dp))
    dm_init = Glx_dm_init;
  else if(IS_DM_PEX(dp))
    dm_init = Pex_dm_init;
  else if(IS_DM_PS(dp))
    dm_init = PS_dm_init;
  else
    dm_init = dmp->dmr_open;
#endif
@


11.30
log
@rt_list ---> bu_list
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.29 1996/08/28 19:42:55 bparker Exp bparker $ (BRL)";
d31 1
d47 22
a68 17
	Nu_int0, Nu_void,
	Nu_input,
	Nu_void, Nu_void,
	Nu_void, Nu_void,
	Nu_void,
	Nu_void, Nu_void,
	Nu_void,
	Nu_int0,
	Nu_unsign, Nu_unsign,
	Nu_void,
	Nu_void,
	Nu_void,
	Nu_void, Nu_void,
	0,			/* no displaylist */
	0,			/* no display to release */
	0.0,
	"nu", "Null Display"
d76 1
d118 3
d129 3
d136 3
d143 19
d164 1
d238 1
a238 1
	    if(strcmp(name, bu_vls_addr(&p->_pathName)))
d269 3
d273 1
a433 1
#if 1
a434 18
#else
    char  *envp;
    char  hostname[80];
    char  display[82];

    /* get or create the default display */
    if( (envp = getenv("DISPLAY")) == NULL ) {
      /* Env not set, use local host */
      gethostname( hostname, 80 );
      hostname[79] = '\0';
      (void)sprintf( display, "%s:0", hostname );
      envp = display;
    }

    Tcl_AppendResult(interp, MORE_ARGS_STR, "Display [", envp, "]? ", (char *)NULL);
    bu_vls_printf(&curr_cmd_list->more_default, "%s", envp);
    return TCL_ERROR;
#endif
d436 1
a436 1
    dmlp = (struct dm_list *)bu_malloc(sizeof(struct dm_list), "dm_list");
d441 3
a443 2
    dmp = *dp;
    dm_var_init(o_dm_list, argv[2]);
d447 9
d458 1
d465 3
d469 1
d472 3
d476 1
d482 4
d487 1
d489 3
d493 1
d559 1
a559 1
    if(!strcmp(argv[1], bu_vls_addr(&p->_pathName)))
d608 1
a608 1
    if(p1 == (struct dm_list *)NULL && !strcmp(argv[1], bu_vls_addr(&p->_pathName)))
d610 1
a610 1
    else if(p2 == (struct dm_list *)NULL && !strcmp(argv[2], bu_vls_addr(&p->_pathName)))
d622 1
d625 1
a625 1
    bu_free( (char *)p1->s_info, "tie: s_info" );
d661 1
a661 1
dm_var_init(initial_dm_list, name)
d664 1
d666 1
a666 8
  if(dmp == &dm_PS){
    curr_dm_list->s_info = initial_dm_list->s_info;
    owner = 0;
    ++initial_dm_list->s_info->_rc;
    bu_vls_init(&pathName);
    strcpy(dname, name);
  }else{
    int i;
d668 33
a700 20
    curr_dm_list->s_info = (struct shared_info *)bu_malloc(sizeof(struct shared_info),
							    "shared_info");
    bzero((void *)curr_dm_list->s_info, sizeof(struct shared_info));
    bcopy((void *)&default_mged_variables, (void *)&mged_variables,
	  sizeof(struct _mged_variables));

    bu_vls_init(&pathName);
    strcpy(dname, name);
    mat_copy(Viewrot, identity);
    size_reset();
    new_mats();
    (void)f_load_dv((ClientData)NULL, interp, 0, NULL);

    MAT_DELTAS_GET(orig_pos, toViewcenter);

    am_mode = ALT_MOUSE_MODE_IDLE;
    rc = 1;
    dmaflag = 1;
    owner = 1;
  }
@


11.29
log
@initialize am_mode
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.28 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d30 1
d201 1
a201 1
	  for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d241 1
a241 1
	for( RT_LIST_FOR(p_cmd, cmd_list, &head_cmd_list.l) )
d246 1
a246 1
	RT_LIST_DEQUEUE( &p->l );
d417 1
a417 1
    RT_LIST_APPEND(&head_dm_list.l, &dmlp->l);
d509 1
a509 1
  for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) )
d558 1
a558 1
  for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d598 1
a598 1
  for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
@


11.28
log
@now using libbu
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.27 1996/08/22 20:52:01 bparker Exp bparker $ (BRL)";
d638 1
@


11.27
log
@cast NULL to (char *) in calls to release()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.26 1996/07/30 21:31:40 bparker Exp bparker $ (BRL)";
d201 1
a201 1
	    if(strcmp(name, rt_vls_addr(&p->_pathName)))
d235 1
a235 1
	  rt_free( (char *)p->s_info, "release: s_info" );
d244 1
a244 1
	rt_vls_free(&pathName);
d246 1
a246 1
	rt_free( (char *)p, "release: curr_dm_list" );
d300 1
a300 1
  struct rt_vls cmd;
d303 2
a304 2
  rt_vls_init(&cmd);
  rt_vls_printf(&cmd, "attach %s %s\n", dmp->dmr_name, dname);
d307 1
a307 1
  rt_vls_free(&cmd);
d322 1
a322 1
  struct rt_vls prompt;
d324 1
a324 1
  rt_vls_init(&prompt);
d328 1
a328 1
    rt_vls_printf(&prompt, "UNIX-Plot filter [pl-fb]? ");
d331 1
a331 1
    rt_vls_printf(&prompt, "Output tty [stdout]? ");
d335 1
a335 1
    rt_vls_printf(&prompt, "PostScript file [mged.ps]? ");
d350 1
a350 1
    rt_vls_printf(&prompt, "Display [%s]? ", dm_default);
d353 2
a354 2
  Tcl_AppendResult(interp, MORE_ARGS_STR, rt_vls_addr(&prompt), (char *)NULL);
  rt_vls_printf(&curr_cmd_list->more_default, "%s", dm_default);
d410 1
a410 1
    rt_vls_printf(&curr_cmd_list->more_default, "%s", envp);
d414 1
a414 1
    dmlp = (struct dm_list *)rt_malloc(sizeof(struct dm_list), "dm_list");
d509 1
a509 1
    if(!strcmp(argv[1], rt_vls_addr(&p->_pathName)))
d522 1
a522 1
      p->s_info = (struct shared_info *)rt_malloc(sizeof(struct shared_info),
d533 1
a533 1
    p->s_info = (struct shared_info *)rt_malloc(sizeof(struct shared_info),
d558 1
a558 1
    if(p1 == (struct dm_list *)NULL && !strcmp(argv[1], rt_vls_addr(&p->_pathName)))
d560 1
a560 1
    else if(p2 == (struct dm_list *)NULL && !strcmp(argv[2], rt_vls_addr(&p->_pathName)))
d574 1
a574 1
    rt_free( (char *)p1->s_info, "tie: s_info" );
d618 1
a618 1
    rt_vls_init(&pathName);
d623 1
a623 1
    curr_dm_list->s_info = (struct shared_info *)rt_malloc(sizeof(struct shared_info),
d629 1
a629 1
    rt_vls_init(&pathName);
d653 1
a653 1
  struct rt_vls vls;
d658 1
a658 1
  rt_vls_init(&vls);
d660 1
a660 1
    rt_vls_strcpy(&vls, view_cmd_str[i]);
d665 1
a665 1
  rt_vls_free(&vls);
@


11.26
log
@*** empty log message ***
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.25 1996/07/25 18:42:12 bparker Exp bparker $ (BRL)";
d305 1
a305 1
  release(NULL);
d451 1
a451 1
    release(NULL);
@


11.25
log
@define f_load_dv() -- this loads default views into the viewrot_table
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.24 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d136 2
a137 1
  "press 45,45"
@


11.24
log
@Still Tcl'ing the code
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.23 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
a39 1
void find_new_owner();
d41 2
a130 1
void dm_var_init();
d132 7
d590 1
a590 1
void
d608 1
a608 1
void
d620 2
d630 1
a630 1
    mat_copy( Viewrot, initial_dm_list->s_info->_Viewrot );
d633 1
d641 31
@


11.23
log
@still tcl-converting
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.22 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d41 1
a118 4
#ifdef DM_OGL2
extern struct dm dm_ogl2;
#endif

a131 1
/* The [0] entry will be the startup default */
d133 1
a135 1
	&dm_PS,
a178 3
#ifdef DM_OGL2
	&dm_ogl2,
#endif
d188 1
d231 5
d303 49
d368 1
a368 1
    dp = &which_dm[0];
d385 3
d404 1
d505 1
a505 1
    Tcl_AppendResult(interp, "f_untie: bad pathname - %s\n", argv[1]);
@


11.22
log
@convert commands to Tcl
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.21 1996/03/27 22:00:44 bparker Exp bparker $ (BRL)";
a136 3
#if 0
	&dm_Null,		/* This should go first */
#endif
d189 1
a189 1
void
d213 1
a213 1
	    return;
d217 1
a217 1
	    return;
a244 55
}

void
attach(name)
char *name;
{
  register struct dm **dp;
  register struct solid *sp;

  register struct dm_list *dmlp;
  register struct dm_list *o_dm_list;

  /* The Null display manager is already attached */
  if(!strcmp(name, which_dm[0]->dmr_name))
    return;

  for( dp=which_dm; *dp != (struct dm *)0; dp++ )  {
    if( strcmp( (*dp)->dmr_name, name ) != 0 )
      continue;

    dmlp = (struct dm_list *)rt_malloc(sizeof(struct dm_list),
				       "dm_list");
    bzero((void *)dmlp, sizeof(struct dm_list));

    RT_LIST_APPEND(&head_dm_list.l, &dmlp->l);
    o_dm_list = curr_dm_list;
    curr_dm_list = dmlp;
    dmp = *dp;
    dm_var_init(o_dm_list);

    no_memory = 0;
    if( dmp->dmr_open() )
      break;

    rt_log("ATTACHING %s (%s)\n",
	   dmp->dmr_name, dmp->dmr_lname);

    FOR_ALL_SOLIDS( sp )  {
      /* Write vector subs into new display processor */
      if( (sp->s_bytes = dmp->dmr_cvtvecs( sp )) != 0 )  {
	sp->s_addr = rt_memalloc( &(dmp->dmr_map), sp->s_bytes );
	if( sp->s_addr == 0 )  break;
	sp->s_bytes = dmp->dmr_load(sp->s_addr, sp->s_bytes);
      } else {
	sp->s_addr = 0;
	sp->s_bytes = 0;
      }
    }
    dmp->dmr_colorchange();
    color_soltab();
    dmp->dmr_viewchange( DM_CHGV_REDO, SOLID_NULL );
    dmaflag++;
    return;
  }
  rt_log("attach(%s): BAD\n", name);
d246 1
a246 2
  if(*dp != (struct dm *)0)
    release(NULL);
a289 44
/*
 *  			G E T _ A T T A C H E D
 *
 *  Prompt the user with his options, and loop until a valid choice is made.
 */
void
get_attached()
{
	char line[80];
	register struct dm **dp;

	/* If non-interactive, don't attach a device and don't ask */
	if( !isatty(0) )  {
		attach( "nu" );
		return;
	}

	while(1)  {
		rt_log("attach (");
		dp = &which_dm[0];
		rt_log("%s", (*dp++)->dmr_name);
		for( ; *dp != (struct dm *)0; dp++ )
			rt_log("|%s", (*dp)->dmr_name);
		rt_log(")[%s]? ", which_dm[0]->dmr_name);

		(void)fgets(line, sizeof(line), stdin);	/* \n, Null terminated */
		line[strlen(line)-1] = '\0';		/* remove newline */

		if( feof(stdin) )  quit();
		if( line[0] == '\0' )  {
			dp = &which_dm[0];	/* default */
			break;
		}
		for( dp = &which_dm[0]; *dp != (struct dm *)0; dp++ )
			if( strcmp( line, (*dp)->dmr_name ) == 0 )
				break;
		if( *dp != (struct dm *)0 )
			break;
		/* Not a valid choice, loop. */
	}
	/* Valid choice made, attach to it */
	attach( (*dp)->dmr_name );
}

a335 4
  /* The Null display manager is already attached */
  if(dp == &which_dm[0])
    return TCL_OK;

d436 48
d507 2
a508 2
    Tcl_AppendResult(interp, "Bad pathname(s)\n\tpathName1: ", argv[1],
		     "\t\tpathName2: ", argv[2], "\n", (char *)NULL);
d554 8
a561 1
  curr_dm_list->s_info = (struct shared_info *)rt_malloc(sizeof(struct shared_info),
d563 16
a578 18
  bzero((void *)curr_dm_list->s_info, sizeof(struct shared_info));
#if 1
  bcopy((void *)&default_mged_variables, (void *)&mged_variables, sizeof(struct _mged_variables));
#else
  mged_variables = default_mged_variables;
#endif

  rt_vls_init(&pathName);
  strcpy(dname, name);
  mat_copy( Viewrot, initial_dm_list->s_info->_Viewrot );
  size_reset();
  new_mats();

  MAT_DELTAS_GET(orig_pos, toViewcenter);

  rc = 1;
  dmaflag = 1;
  owner = 1;
@


11.21
log
@*** empty log message ***
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.20 1996/03/25 21:58:04 bparker Exp bparker $ (BRL)";
d198 1
a198 1
	struct dm_list *save_dm_list = (struct dm_list *)NULL;
d214 2
a215 1
	    rt_log("release: %s not found\n", name);
a234 5
	if(save_dm_list == (struct dm_list *)NULL)
	  curr_dm_list = (struct dm_list *)curr_dm_list->l.forw;
	else
	  curr_dm_list = save_dm_list;  /* put it back the way it was */

d240 1
d244 3
a246 6
	/* 
	 * If there are any more active displays other than that which is
         * found in head_dm_list, then assign that as the current dm_list.
	 */
	if( curr_dm_list == &head_dm_list &&
	    (struct dm_list *)head_dm_list.l.forw != &head_dm_list)
d393 1
a393 1
void
a395 13
  char *name;

#if 0
  if(curr_dm_list == &head_dm_list)
    return;

  name = strdup(dmp->dmr_name);
  release(NULL);
  attach(name);
  free((void *)name);

  dmaflag = 1;
#else
d397 1
d402 1
a402 1
  cmdline(&cmd, FALSE);
d404 1
a404 1
#endif
d408 3
a410 1
f_attach( argc, argv )
d419 3
a422 1
    rt_log("attach (");
d424 1
a424 1
    rt_log("%s", (*dp++)->dmr_name);
d426 2
a427 2
      rt_log("|%s", (*dp)->dmr_name);
    rt_log(")[%s]? ", which_dm[0]->dmr_name);
d429 1
a429 1
    return CMD_MORE;
d441 1
a441 8
    return CMD_OK;

#if 0
  if(argc == 2){
    rt_log("X Display: ? ");
    return CMD_MORE;
  }
#endif
a442 7
  dmlp = (struct dm_list *)rt_malloc(sizeof(struct dm_list), "dm_list");
  bzero((void *)dmlp, sizeof(struct dm_list));
  RT_LIST_APPEND(&head_dm_list.l, &dmlp->l);
  o_dm_list = curr_dm_list;
  curr_dm_list = dmlp;
  dmp = *dp;

d457 10
a466 2
    dm_var_init(o_dm_list, envp);
  }else
d468 1
d474 2
a475 2
  rt_log("ATTACHING %s (%s)\n",
	 dmp->dmr_name, dmp->dmr_lname);
d492 1
a492 1
  return CMD_OK;
d495 1
a495 1
  rt_log("attach(%s): BAD\n", argv[1]);
d500 1
a500 1
  return CMD_BAD;
d510 3
a512 1
f_dm(argc, argv)
d516 8
a523 4
	if( !dmp->dmr_cmd )  {
		rt_log("The '%s' display manager does not support any local commands.\n", dmp->dmr_name);
		return CMD_BAD;
	}
d525 1
a525 8
#if 0
/* mged_cmd already checks for this */
	if( argc-1 < 1 )  {
		rt_log("'dm' command requires an argument.\n");
		return CMD_BAD;
	}
#endif
	return dmp->dmr_cmd( argc-1, argv+1 );
d543 3
a545 1
f_tie( argc, argv )
d553 3
d566 3
a568 2
    rt_log("Bad pathname(s)\n\tpathName1: %s\t\tpathName2: %s\n", argv[1], argv[2]);
    return CMD_BAD;
d587 1
a587 1
  return CMD_OK;
d604 1
a604 1
    rt_log("find_new_owner: Failed to find a new owner\n");
d616 7
a623 1
  mged_variables = default_mged_variables;
@


11.20
log
@modify attach to silently use :0 for display if none
is provided.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.19 1996/03/22 22:57:01 bparker Exp bparker $ (BRL)";
d471 16
a486 4
  if(argc == 2)
    /* Use local display */
    dm_var_init(o_dm_list, ":0");
  else
@


11.19
log
@changed attach to use CMD_MORE
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.18 1996/03/22 18:34:30 bparker Exp bparker $ (BRL)";
d404 1
d414 9
d457 1
d462 1
a469 1
  dm_var_init(o_dm_list);
d471 6
d478 1
a478 1
  if( dmp->dmr_open(argv[2]) )
d611 1
a611 1
dm_var_init(initial_dm_list)
d613 1
d618 1
@


11.18
log
@cleanup
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.17 1996/03/11 21:47:21 bparker Exp bparker $ (BRL)";
d137 1
d139 1
d414 79
@


11.17
log
@added the tie command
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.16 1996/03/08 18:32:04 bparker Exp bparker $ (BRL)";
d40 1
a129 1
#ifdef MULTI_ATTACH
a133 3
#else
struct dm *dmp = &dm_Null;	/* Ptr to current Display Manager package */
#endif
a189 1
#ifdef MULTI_ATTACH
a193 5
#else
void
release()
{
#endif
a194 1
#ifdef MULTI_ATTACH
d204 4
a207 2
	    save_dm_list = curr_dm_list;
	    curr_dm_list = p;
d218 2
a220 1
#endif
a231 4
#ifdef MULTI_ATTACH
	p = curr_dm_list;

	/* name was not supplied so use next one */
d237 5
a242 2
	if(!--rc)
	  rt_free( (char *)p->s_info, "release: s_info" );
a251 4
	  
#else
	dmp = &dm_Null;
#endif
a260 1
#ifdef MULTI_ATTACH
d307 1
a307 8
#if 0
  dmlp = (struct dm_list *)rt_malloc(sizeof(struct dm_list),
				     "dm_list");
  RT_LIST_APPEND(&head_dm_list.l, &dmlp->l);
  curr_dm_list = dmlp;
  curr_dm_list->_dmp = &dm_Null;
  dm_var_init(o_dm_list);
#else
a309 37
#endif
#else
	if( dmp != &dm_Null )
		release();

	for( dp=which_dm; *dp != (struct dm *)0; dp++ )  {
		if( strcmp( (*dp)->dmr_name, name ) != 0 )
			continue;
		dmp = *dp;

		no_memory = 0;
		if( dmp->dmr_open() )
			break;

		rt_log("ATTACHING %s (%s)\n",
			dmp->dmr_name, dmp->dmr_lname);

		FOR_ALL_SOLIDS( sp )  {
			/* Write vector subs into new display processor */
			if( (sp->s_bytes = dmp->dmr_cvtvecs( sp )) != 0 )  {
				sp->s_addr = rt_memalloc( &(dmp->dmr_map), sp->s_bytes );
				if( sp->s_addr == 0 )  break;
				sp->s_bytes = dmp->dmr_load(sp->s_addr, sp->s_bytes);
			} else {
				sp->s_addr = 0;
				sp->s_bytes = 0;
			}
		}
		dmp->dmr_colorchange();
		color_soltab();
		dmp->dmr_viewchange( DM_CHGV_REDO, SOLID_NULL );
		dmaflag++;
		return;
	}
	rt_log("attach(%s): BAD\n", name);
	dmp = &dm_Null;
#endif
a399 1
#ifdef MULTI_ATTACH
d409 2
a410 4
#else
	attach( dmp->dmr_name );		/* reattach */
#endif
	dmaflag = 1;
a447 1
#ifdef MULTI_ATTACH
a448 3
#else
	return dmp == &dm_Null;
#endif
a451 1
#ifdef MULTI_ATTACH
d475 1
d477 4
a480 1
    rt_free( (char *)p, "tie: s_info" );
d482 2
d490 1
d495 18
a523 1
#ifdef VIRTUAL_TRACKBALL
a524 1
#endif
d526 1
a526 1
  ++rc;
d528 1
a529 1
#endif
@


11.16
log
@added an optional parameter to the release command
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.15 1996/02/28 21:37:11 bparker Exp bparker $ (BRL)";
d213 1
d249 2
d288 1
d517 35
d556 3
a558 1

d560 1
a560 1
  mat_copy( Viewrot, initial_dm_list->_Viewrot );
d568 1
@


11.15
log
@added dm_ogl2 and other multi-attach stuff
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.14 1996/02/12 21:46:28 bparker Exp bparker $ (BRL)";
d193 6
d202 1
d206 1
d208 18
a225 2
	if( curr_dm_list == &head_dm_list )
	  return;
d240 6
a245 1
	curr_dm_list = (struct dm_list *)curr_dm_list->l.forw;
d325 1
a325 1
    release();
d460 1
a460 1
  release();
@


11.14
log
@added dm_pex
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.13 1996/01/25 22:26:39 bparker Exp bparker $ (BRL)";
d117 4
d187 3
d245 4
d295 2
a296 1
  release();
d401 1
a401 3
#ifdef XMGED
		(void)mged_gets( line );                /* Null terminated */
#else
d404 1
a404 1
#endif
d424 11
d436 1
d476 1
a476 1
  return curr_dm_list == &head_dm_list;
a487 5
#if 0
  /* init rotation matrix */
  Viewscale = 500;		/* => viewsize of 1000mm (1m) */
  mat_idn( Viewrot );
  mat_idn( toViewcenter );
d489 3
a492 12
  setview( 0.0, 0.0, 0.0 );
#else
  Viewscale = initial_dm_list->_Viewscale;
  mat_copy( Viewrot, initial_dm_list->_Viewrot );
  mat_copy( toViewcenter, initial_dm_list->_toViewcenter);
  mat_copy( model2view, initial_dm_list->_model2view );
  mat_copy( view2model, view2model);

  if( state != ST_VIEW ) {
    mat_mul( model2objview, model2view, modelchanges );
    mat_inv( objview2model, model2objview );
  }
d494 2
a495 1
  dmaflag = 1;
d498 1
a498 1
  mged_variables = default_mged_variables;
@


11.13
log
@*** empty log message ***
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.12 1996/01/22 22:51:03 bparker Exp bparker $ (BRL)";
d121 4
a149 3
#ifdef DM_GLX
	&dm_glx,
#endif
d155 6
@


11.12
log
@*** empty log message ***
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.11 1996/01/17 22:05:07 bparker Exp bparker $ (BRL)";
d185 3
a200 3
	if( curr_dm_list == &head_dm_list )
	  return;

d203 1
d206 9
@


11.11
log
@modified release() when MULTI_ATTACH is defined
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.10 1996/01/05 22:08:48 bparker Exp bparker $ (BRL)";
d266 2
@


11.10
log
@Just playing it safe
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.9 1995/12/27 22:35:54 bparker Exp bparker $ (BRL)";
d183 3
d196 10
d207 1
a265 2
#else
  curr_dm_list = &head_dm_list;
@


11.9
log
@Experimenting with attaching more
than one display manager
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.8 1995/11/09 22:22:05 bparker Exp bparker $ (BRL)";
d122 4
a125 3
struct rt_list dm_list_head;  /* list of active display managers */
struct dm_list *dm_list_curr;
void initialize_dm();
d205 1
d213 6
a218 4
    RT_LIST_APPEND(&dm_list_head, &dmlp->l);
    dm_list_curr = dmlp;
    dm_list_curr->_dmp = *dp;
    initialize_dm();
d245 1
d248 7
a254 4
  RT_LIST_APPEND(&dm_list_head, &dmlp->l);
  dm_list_curr = dmlp;
  dm_list_curr->_dmp = &dm_Null;
  initialize_dm();
d423 1
a423 1
  return dm_list_curr == NULL;
d432 2
a433 1
initialize_dm()
d435 1
d443 16
@


11.8
log
@remove unnecessary check in f_dm
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.7 1995/09/01 15:13:42 cnuzman Exp bparker $ (BRL)";
d117 9
d127 1
d145 3
d199 5
a203 2
	register struct dm **dp;
	register struct solid *sp;
d205 43
d250 1
a255 35
#ifdef XMGED
		FOR_ALL_SOLIDS( sp )  {
			/* Write vector subs into new display processor */
			if( (sp->s_bytes = dmp->dmr_cvtvecs( sp )) != 0 )  {
				sp->s_addr = rt_memalloc( &(dmp->dmr_map), sp->s_bytes );
				if( sp->s_addr == 0 )  break;
				sp->s_bytes = dmp->dmr_load(sp->s_addr, sp->s_bytes);
			} else {
				sp->s_addr = 0;
				sp->s_bytes = 0;
			}
		}

		no_memory = 0;
		switch( dmp->dmr_open() ){
		case -1:
			goto not_okay;
		case 0:
			break;
		case 1:
			goto okay;	/* just released the X display */
		}

		(void)rt_log( "ATTACHING %s (%s)\n",
			     dmp->dmr_name, dmp->dmr_lname);

		dmp->dmr_colorchange();
		color_soltab();
		dmp->dmr_viewchange( DM_CHGV_REDO, SOLID_NULL );
		dmaflag++;
		return;
	}
not_okay:	(void)rt_log( "attach(%s): BAD\n", name);
okay:		dmp = &dm_Null;
#else
d414 3
d418 15
d434 1
@


11.7
log
@not much
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.6 1995/08/24 17:28:46 cnuzman Exp cnuzman $ (BRL)";
d368 3
d375 1
@


11.6
log
@changed dm-ogl to dm-gl
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.5 1995/08/17 19:59:14 cnuzman Exp cnuzman $ (BRL)";
d113 2
a114 2
#ifdef DM_GL
extern struct dm dm_gl;
d159 2
a160 2
#ifdef DM_GL
	&dm_gl,
@


11.5
log
@changed display manager name from Xogl to ogl
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.4 1995/07/25 21:58:09 cnuzman Exp cnuzman $ (BRL)";
d113 2
a114 2
#ifdef DM_OGL
extern struct dm dm_ogl;
d159 2
a160 2
#ifdef DM_OGL
	&dm_ogl,
@


11.4
log
@begin work on OpenGL display manager
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.3 1995/06/16 17:50:53 gdurf Exp cnuzman $ (BRL)";
d113 2
a114 2
#ifdef DM_XOGL
extern struct dm dm_Xogl;
d159 2
a160 2
#ifdef DM_XOGL
	&dm_Xogl,
@


11.3
log
@Added correct return to f_dm()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 11.2 1995/01/17 13:03:46 bparker Exp gdurf $ (BRL)";
d113 4
d158 3
@


11.2
log
@merging xmged sources
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/attach.c,v 11.2 95/01/17 11:41:53 bparker Exp $ (BRL)";
d365 1
a365 2
	(void)dmp->dmr_cmd( argc-1, argv+1 );
	return CMD_OK;
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 10.11 94/12/27 16:58:23 mike Exp $ (BRL)";
d189 13
d203 22
d250 1
d318 3
d323 1
@


10.11
log
@Fixed bug #247, added rt_ prefix to memalloc(), etc.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 10.10 94/12/16 19:35:26 gdurf Exp Locker: mike $ (BRL)";
@


10.10
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 10.9 1994/10/14 17:07:38 mike Exp gdurf $ (BRL)";
d165 1
a165 1
		memfree( &(dmp->dmr_map), sp->s_bytes, (unsigned long)sp->s_addr );
d169 1
a169 1
	mempurge( &(dmp->dmr_map) );
d199 1
a199 1
				sp->s_addr = memalloc( &(dmp->dmr_map), sp->s_bytes );
@


10.9
log
@Replaced Berkeley getdtablesize()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 10.8 94/08/10 21:43:02 mike Exp Locker: mike $ (BRL)";
d193 1
a193 1
		(void)printf("ATTACHING %s (%s)\n",
d213 1
a213 1
	(void)printf("attach(%s): BAD\n", name);
d276 1
a276 1
		(void)printf("attach (");
d278 1
a278 1
		(void)printf("%s", (*dp++)->dmr_name);
d280 2
a281 2
			(void)printf("|%s", (*dp)->dmr_name);
		(void)printf(")[%s]? ", which_dm[0]->dmr_name);
d318 1
a318 1
		printf("The '%s' display manager does not support any local commands.\n", dmp->dmr_name);
d322 1
a322 1
		printf("'dm' command requires an argument.\n");
@


10.8
log
@Changed calling sequence to dmr_input(), to pass an fd_set rather
than a single file descriptor.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 10.7 94/08/09 14:56:16 gdurf Exp Locker: mike $ (BRL)";
d238 3
a240 1
	if( (width = getdtablesize()) <= 0 )
@


10.7
log
@#include "conf.h"
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 10.6 1994/06/01 16:02:06 gdurf Exp gdurf $ (BRL)";
d27 1
d29 1
a30 1
#include "db.h"
a32 1
#include "externs.h"
d36 1
a36 1
static int	Nu_input();	/* Quite necessary */
d221 10
a230 3
/* ARGSUSED */
static int
Nu_input( fd, noblock )
d232 22
a253 3
	if( isatty(fd) )
		(void)bsdselect( 1<<fd, 9999999, 0 );
	return(1);
@


10.6
log
@Converted f_dm to use new command return codes.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 10.5 1994/06/01 11:51:03 gdurf Exp gdurf $ (BRL)";
d23 2
@


10.5
log
@Replaced gets() with fgets()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 10.4 1993/11/05 12:22:39 mike Exp gdurf $ (BRL)";
d282 1
a282 1
void
d289 1
a289 1
		return;
d293 1
a293 1
		return;
d296 1
@


10.4
log
@Added is_dm_null()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 10.3 93/07/13 21:01:06 mike Exp Locker: mike $ (BRL)";
d252 2
a253 1
		(void)gets( line );		/* Null terminated */
@


10.3
log
@Added f_dm command
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 10.2 92/08/24 19:51:27 mike Exp Locker: mike $ (BRL)";
d295 13
@


10.2
log
@Added new variable "eye_sep_dist" to support Stereo viewing.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 10.1 91/10/12 06:43:05 mike Rel4_0 Locker: mike $ (BRL)";
d274 21
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 9.2 91/10/10 00:46:52 mike Exp $ (BRL)";
d267 7
@


9.2
log
@Added Sun XGL dm
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/attach.c,v 9.1 89/05/19 06:01:47 mike Rel3_5 Locker: mike $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 8.4 89/04/06 20:38:45 mike Exp $ (BRL)";
d107 4
d125 3
@


8.4
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 8.3 89/02/14 22:23:32 mike Locked $ (BRL)";
@


8.3
log
@Removed obsolete DM_GT entry
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 8.2 88/12/06 00:55:18 mike Locked $ (BRL)";
d30 1
@


8.2
log
@Included raytrace.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/attach.c,v 1.2 88/10/23 13:55:34 mike Exp $ (BRL)";
a95 4
#endif

#ifdef DM_GT
extern struct dm dm_gt;
@


8.1
log
@Release_3.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 7.8 88/09/16 02:45:12 reschly Exp $ (BRL)";
d28 1
@


7.8
log
@enhanced the null display manager to not release it's display.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 7.7 88/09/10 06:30:41 reschly Locked $ (BRL)";
@


7.7
log
@ADded SGI GT support...
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 7.6 88/09/10 06:24:27 stay Locked $ (BRL)";
d51 2
a52 1
	0,
@


7.6
log
@Added PostScript
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 7.5 88/05/15 23:04:42 mike Locked $ (BRL)";
d96 4
d122 3
@


7.5
log
@lint fixes
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 7.4 88/03/02 23:22:59 mike Locked $ (BRL)";
d57 1
a57 1
extern struct dm dm_Tek;
d59 2
a60 1
extern struct dm dm_Plot;
d111 1
@


7.4
log
@added DM_X hooks
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 7.3 88/01/13 12:29:14 stay Exp $ (BRL)";
d141 1
d158 1
d205 1
a205 1
static
d218 1
@


7.3
log
@Added display manager for SGI 4d
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 7.2 87/11/05 05:03:27 stay Locked $ (BRL)";
d99 4
d119 3
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 7.1 87/11/02 23:58:31 mike Rel $ (BRL)";
d91 4
d109 3
@


7.1
log
@Release 2.3
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 6.2 87/10/28 21:07:45 mike Exp $ (BRL)";
d25 1
a25 1
#include "./machine.h"	/* special copy */
@


6.2
log
@Added dm_rat80 support
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 6.1 87/07/11 08:01:44 mike Locked $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 5.1 87/06/24 22:17:46 mike Rel $ (BRL)";
d73 4
@


5.1
log
@Release 1.24
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 4.4 87/05/28 22:46:07 mike Exp $ (BRL)";
@


4.4
log
@Made Megatek and VG optional displays
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 4.3 87/02/13 00:05:24 mike Locked $ (BRL)";
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 4.2 87/02/03 01:25:33 mike Exp $ (BRL)";
d61 3
a63 3
#ifdef BSD
/* We only supply kernel drivers for Berkeley systems for these */
extern struct dm dm_Mg, dm_Vg;
d66 5
d105 1
a105 1
#ifdef BSD
d107 2
@


4.2
log
@Changed to only call bsdselect() from Nu_input when
input is a tty.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 4.1 86/12/29 03:19:05 mike Locked $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.18 86/11/13 14:03:56 mike Exp $ (BRL)";
d181 2
a182 1
	(void)bsdselect( 1<<fd, 9999999, 0 );
@


2.18
log
@Added DM_SUNPW
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.17 86/10/29 00:22:00 mike Locked $ (BRL)";
@


2.17
log
@Eliminated trailing "|" for Ron.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.16 86/09/23 17:39:52 mike Locked $ (BRL)";
d82 4
d96 3
@


2.16
log
@Minor cleanup for cray
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.15 86/08/14 22:20:25 mike Exp $ (BRL)";
d196 4
a199 2
		for( dp = &which_dm[0]; *dp != (struct dm *)0; dp++ )
			(void)printf("%s|", (*dp)->dmr_name);
@


2.15
log
@Changed attach() to bsdattach() to provide better insulation.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.14 86/08/13 00:05:42 mike Exp $ (BRL)";
d58 1
a58 1
extern struct dm dm_Tek4109;
d62 1
a62 1
/* Only Berkeley systems have kernel drivers for these */
d88 1
a88 1
	&dm_Tek4109,
@


2.14
log
@Converted from BSD42 to BSD and SYSV defines to select UNIX type.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.13 86/08/12 06:46:39 mike Exp $ (BRL)";
d174 1
a174 2
	long readfds = (1<<fd);
	(void)select( 32, &readfds, 0L, 0L, (char *)0 );
@


2.13
log
@Changed #includes for CC -I../h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.12 86/06/12 00:36:06 mike Exp $ (BRL)";
d61 3
a63 3
/* Only some systems can do these */
#ifdef BSD42
extern struct dm dm_Mg, dm_Vg, dm_Rat;
d65 5
d73 1
d77 1
d93 1
a93 1
#ifdef BSD42
d96 2
@


2.12
log
@Added new standard device, tek4109.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.11 86/04/09 01:10:17 mike Exp $ (BRL)";
d26 5
a30 5
#include "../h/vmath.h"
#include "../h/db.h"
#include "ged.h"
#include "solid.h"
#include "dm.h"
@


2.11
log
@Added hooks for dm-plot.c
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.10 85/08/07 05:16:36 mike Exp $ (BRL)";
d58 1
d81 1
@


2.10
log
@Changed to use common ../h/vmath.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.9 85/06/07 01:11:00 mike Exp $ (BRL)";
d55 6
a60 1
extern struct dm dm_Tek;	/* All systems can compile this one! */
d80 1
@


2.9
log
@Made Merlin device conditional on cc -DDM_MER being present.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.8 85/06/03 17:42:02 mike Exp $ (BRL)";
d25 2
a26 1
#include "ged_types.h"
@


2.8
log
@Makefile controlled defines.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.7 85/06/03 16:48:08 mike Exp $ (BRL)";
d54 1
a54 1
extern struct dm dm_Tek, dm_Ir;
d56 1
a56 1
extern struct dm dm_Mg, dm_Vg, dm_Tek, dm_Rat, dm_Mer;
d58 3
d62 1
a62 1
extern struct dm_Ps;
d65 1
a65 1
extern struct dm_Ir;
d81 2
@


2.7
log
@Fixes to allow compilation on System V on the IRIS.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.5 85/03/28 22:24:31 mike Exp $ (BRL)";
d58 1
a58 1
#ifdef PS300
d61 3
d71 1
d73 1
d80 1
a80 1
#ifdef PS300
d82 1
a82 1
#endif PS300
@


2.6
log
@added stubs to Null display manager
@
text
@d54 2
d57 1
d67 3
a71 1
	&dm_Tek,
d74 1
@


2.5
log
@Made NULL device the default.
Changed get_attached to simply attach to NULL device if not on a tty.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.4 85/03/22 10:50:58 mike Exp $ (BRL)";
d37 1
a37 1
	Nu_int0, Nu_void, Nu_void,
d49 1
@


2.4
log
@Symbolic viewchange
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.3 85/03/15 05:02:44 mike Exp $ (BRL)";
d62 1
a70 1
	&dm_Null,
d122 1
d153 6
@


2.3
log
@Added mapping between region ID and color + database handle.
Reorganized to support regular expressions on the command line.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.2 85/03/14 15:57:00 mike Exp $ (BRL)";
d53 1
a53 1
extern struct dm dm_Mg, dm_Vg, dm_Tek, dm_Rat;
d66 1
d122 1
a122 1
		dmp->dmr_viewchange( 0, SOLID_NULL );	/* complete change */
@


2.2
log
@reset no_memory flag when attaching new display.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 2.1 85/03/11 23:53:38 mike Prod $ (BRL)";
d48 1
d120 1
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 1.9 85/03/08 20:52:13 mike Exp $ (BRL)";
d101 1
@


1.9
log
@Informs display manager of view change.
@
text
@d8 4
a11 1
 * Source -
d15 4
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: attach.c,v 1.8 85/02/14 00:27:10 mike Exp $ (BRL)";
d26 1
a26 1
#include "db.h"
d33 1
a33 1
static int	Nu_int0(), Nu_int1();
d47 1
d52 4
a55 1
extern struct dm dm_Mg, dm_Vg, dm_Tek, dm_Rat, dm_Ps;
a60 1
	&dm_Ps,
d65 3
d78 1
a78 1
		memfree( &(dmp->dmr_map), sp->s_bytes, sp->s_addr );
d104 1
a104 1
		printf("ATTACHING %s (%s)\n",
d109 1
a109 1
			if( (sp->s_bytes = dmp->dmr_cvtvecs( sp )) > 0 )  {
d118 1
a118 1
		dmp->dmr_viewchange();
d122 1
a122 1
	printf("attach(%s): BAD\n", name);
a126 1
static int Nu_int1() { return(1); }
d130 1
d135 1
a135 1
	(void)_select( 32, &readfds, 0L, 0L, (char *)0 );
d150 1
a150 1
		printf("attach (");
d152 2
a153 2
			printf("%s|", (*dp)->dmr_name);
		printf(")[%s]? ", which_dm[0]->dmr_name);
@


1.8
log
@Status return added.
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: attach.c,v 1.7 85/02/02 01:38:37 mike Exp $ (BRL)";
d39 2
d44 1
a44 1
extern struct dm dm_Mg, dm_Vg, dm_Tek, dm_Rat;
d50 1
d105 1
@


1.7
log
@dmr_open routines now return success/fail indication
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: attach.c,v 1.6 85/01/19 04:07:09 mike Exp $ (BRL)";
d119 1
@


1.6
log
@Fixed problem with dmr_cvtvecs() returning 0,
for devices without displaylist.
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: attach.c,v 1.5 85/01/19 02:28:24 mike Exp $ (BRL)";
d26 1
a26 1
static int	Nu_int();
d30 1
a30 1
	Nu_void, Nu_void, Nu_void,
d37 1
a37 1
	Nu_int,
d84 4
a90 2
		dmp->dmr_open();

d109 2
a110 1
static int Nu_int() { return(0); }
@


1.5
log
@Added support for Raster Tech (RAT)
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: attach.c,v 1.4 85/01/17 07:27:41 mike Exp $ (BRL)";
d91 8
a98 4
			sp->s_bytes = dmp->dmr_cvtvecs( sp );
			sp->s_addr = memalloc( &(dmp->dmr_map), sp->s_bytes );
			if( sp->s_addr == 0 )  break;
			sp->s_bytes = dmp->dmr_load(sp->s_addr, sp->s_bytes);
@


1.4
log
@
Latest stuff
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: attach.c,v 1.3 85/01/16 01:56:12 mike Exp $ (BRL)";
d42 1
a42 1
extern struct dm dm_Mg, dm_Vg, dm_Tek;
d51 1
@


1.3
log
@pre-Keith version
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: attach.c,v 1.2 84/11/22 06:55:36 mike Exp $ (BRL)";
d42 1
a42 1
extern struct dm dm_Mg, dm_Vg;
d50 1
d90 1
a90 4
			sp->s_bytes = dmp->dmr_cvtvecs( sp->s_vlist,
				sp->s_center, sp->s_size,
				sp->s_soldash, sp->s_vlen );

@


1.2
log
@Multiple simultaneous display manager support
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: attach.c,v 1.1 84/11/20 04:21:58 mike Exp $ (BRL)";
d17 1
d19 1
a19 1
#include "3d.h"
a42 1
extern struct dm *dmp;		/* Ptr to current Display Manager package */
d44 3
a47 1
	&dm_Null,
d50 1
a57 2
	printf("releasing %s\n", dmp->dmr_name);

d62 1
d82 1
a82 1
		printf("attach(%s) %s\n",
d113 32
@


1.1
log
@Initial revision
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d59 1
a59 1
		freevgcore( sp->s_addr, sp->s_bytes );
d62 1
a63 2
	/* NEED TO CHANGE DISPLAY PROCESSOR MEMORY MAPS! */

d82 1
a82 1
		/* NEED TO CHANGE MEMORY MAPS HERE */
d88 2
a89 1
				sp->s_center, sp->s_size, sp->s_soldash );
d91 1
a91 1
			sp->s_addr = memalloc( sp->s_bytes );
@
