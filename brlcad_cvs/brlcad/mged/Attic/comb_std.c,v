head	1.31;
access;
symbols
	rel-5-4:1.23
	offsite-5-3-pre:1.28
	rel-5-3:1.23
	rel-5-2:1.23
	rel-5-1-branch:1.23.0.2
	rel-5-1:1.23
	rel-5-0:1.18
	rel-5-0-beta:1.17
	rel-4-5:1.17
	ctj-4-5-post:1.15
	ctj-4-5-pre:1.15;
locks; strict;
comment	@ * @;


1.31
date	2001.05.04.14.23.42;	author bparker;	state dead;
branches;
next	1.30;

1.30
date	2001.04.03.18.17.07;	author jra;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.23.22.05.34;	author jra;	state Exp;
branches;
next	1.28;

1.28
date	2000.10.24.20.01.44;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.24.15.14.13;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.08.05.55.48;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.19.03.10.43;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	2000.08.19.03.10.13;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.04.05.15.41;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	99.12.30.20.11.50;	author jra;	state Exp;
branches;
next	1.21;

1.21
date	99.12.29.23.23.20;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	99.11.26.23.03.31;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	99.11.24.14.26.41;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	99.09.01.18.55.09;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	97.08.22.22.38.22;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	97.05.02.14.21.18;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	97.03.25.13.27.08;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	97.02.25.19.03.14;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	97.02.25.13.57.02;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	97.02.21.13.41.54;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	97.01.02.22.12.41;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	97.01.02.19.33.14;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	96.08.22.20.53.11;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	95.08.10.21.09.33;	author gdurf;	state Exp;
branches;
next	1.1;

1.1
date	95.06.23.19.54.36;	author pjt;	state Exp;
branches;
next	;


desc
@     Code to implement the 'c' command
@


1.31
log
@*- the routines in this file have moved
   to librt
@
text
@/*			C O M B _ S T D . C
 *
 *	Code to impliement the "c" command
 *
 *  Author -
 *      John R. Anderson
 *
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 *  Distribution Notice -
 *      Re-distribution of this software is restricted, as described in
 *      your "Statement of Terms and Conditions for the Release of
 *      The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *      This software is Copyright (C) 1997 by the United States Army
 *      in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/comb_std.c,v 1.30 2001/04/03 18:17:07 jra Exp $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./ged.h"

#define	PRINT_USAGE Tcl_AppendResult(interp, "c: usage 'c [-gr] comb_name [bool_expr]'\n",\
				     (char *)NULL)

struct tokens
{
	struct bu_list		l;
	short			type;
	union tree		*tp;
};

/* token types */
#define	TOK_NULL	0
#define	TOK_LPAREN	1
#define	TOK_RPAREN	2
#define	TOK_UNION	3
#define	TOK_INTER	4
#define	TOK_SUBTR	5
#define	TOK_TREE	6

HIDDEN void
Free_tokens( hp )
struct bu_list *hp;
{
	struct tokens *tok;

	BU_CK_LIST_HEAD( hp );

	while( BU_LIST_WHILE( tok, tokens, hp ) )
	{
		BU_LIST_DEQUEUE( &tok->l );
		if( tok->type == TOK_TREE )
		{
			if( tok->tp )
				db_free_tree( tok->tp, &rt_uniresource );
		}
	}
}

HIDDEN void
Append_union( hp )
struct bu_list *hp;
{
	struct tokens *tok;

	BU_CK_LIST_HEAD( hp );

	tok = (struct tokens *)bu_malloc( sizeof( struct tokens ), "tok" );
	tok->type = TOK_UNION;
	tok->tp = (union tree *)NULL;
	BU_LIST_INSERT( hp, &tok->l );
}

HIDDEN void
Append_inter( hp )
struct bu_list *hp;
{
	struct tokens *tok;

	BU_CK_LIST_HEAD( hp );

	tok = (struct tokens *)bu_malloc( sizeof( struct tokens ), "tok" );
	tok->type = TOK_INTER;
	tok->tp = (union tree *)NULL;
	BU_LIST_INSERT( hp, &tok->l );
}

HIDDEN void
Append_subtr( hp )
struct bu_list *hp;
{
	struct tokens *tok;

	BU_CK_LIST_HEAD( hp );

	tok = (struct tokens *)bu_malloc( sizeof( struct tokens ), "tok" );
	tok->type = TOK_SUBTR;
	tok->tp = (union tree *)NULL;
	BU_LIST_INSERT( hp, &tok->l );
}

HIDDEN void
Append_lparen( hp )
struct bu_list *hp;
{
	struct tokens *tok;

	BU_CK_LIST_HEAD( hp );

	tok = (struct tokens *)bu_malloc( sizeof( struct tokens ), "tok" );
	tok->type = TOK_LPAREN;
	tok->tp = (union tree *)NULL;
	BU_LIST_INSERT( hp, &tok->l );
}

HIDDEN void
Append_rparen( hp )
struct bu_list *hp;
{
	struct tokens *tok;

	BU_CK_LIST_HEAD( hp );

	tok = (struct tokens *)bu_malloc( sizeof( struct tokens ), "tok" );
	tok->type = TOK_RPAREN;
	tok->tp = (union tree *)NULL;
	BU_LIST_INSERT( hp, &tok->l );
}

HIDDEN int
Add_operator( hp, ch, last_tok )
struct bu_list *hp;
char ch;
short *last_tok;
{
	char illegal[2];

	BU_CK_LIST_HEAD( hp );

	switch( ch )
	{
		case 'u':
			Append_union( hp );
			*last_tok = TOK_UNION;
			break;
		case '+':
			Append_inter( hp );
			*last_tok = TOK_INTER;
			break;
		case '-':
			Append_subtr( hp );
			*last_tok = TOK_SUBTR;
			break;
		default:
			illegal[0] = ch;
			illegal[1] = '\0';
			Tcl_AppendResult(interp, "Illegal operator: ", illegal,
				", aborting\n", (char *)NULL );
			Free_tokens( hp );
			return TCL_ERROR;
	}
	return TCL_OK;
}

HIDDEN int
Add_operand( hp, name )
struct bu_list *hp;
char *name;
{
	char *ptr_lparen;
	char *ptr_rparen;
	int name_len;
	union tree *node;
	struct tokens *tok;

	BU_CK_LIST_HEAD( hp );

	ptr_lparen = strchr( name, '(' );
	ptr_rparen = strchr( name, ')' );

	BU_GETUNION( node, tree );
	node->magic = RT_TREE_MAGIC;
	node->tr_op = OP_DB_LEAF;
	node->tr_l.tl_mat = (matp_t)NULL;
	if( ptr_lparen || ptr_rparen )
	{
		int tmp1,tmp2;

		if( ptr_rparen )
			tmp1 = ptr_rparen - name;
		else
			tmp1 = (-1);
		if( ptr_lparen )
			tmp2 = ptr_lparen - name;
		else
			tmp2 = (-1);

		if( tmp2 == (-1) && tmp1 > 0 )
			name_len = tmp1;
		else if( tmp1 == (-1) && tmp2 > 0 )
			name_len = tmp2;
		else if( tmp1 > 0 && tmp2 > 0 )
		{
			if( tmp1 < tmp2 )
				name_len = tmp1;
			else
				name_len = tmp2;
		}
		else
		{
			Tcl_AppendResult(interp, "Cannot determine length of operand name: ",
				name, ", aborting\n", (char *)NULL );
			return( 0 );
		}
	}
	else
		name_len = strlen( name );

	node->tr_l.tl_name = (char *)bu_malloc( name_len + 1, "node name" );
	strncpy( node->tr_l.tl_name, name, name_len );
	node->tr_l.tl_name[name_len] = '\0';
	tok = (struct tokens *)bu_malloc( sizeof( struct tokens ), "tok" );
	tok->type = TOK_TREE;
	tok->tp = node;
	BU_LIST_INSERT( hp, &tok->l );
	return( name_len );
}

HIDDEN void
Do_inter( hp )
struct bu_list *hp;
{
	struct tokens *tok;

	for( BU_LIST_FOR( tok, tokens, hp ) )
	{
		struct tokens *prev, *next;
		union tree *tp;

		if( tok->type != TOK_INTER )
			continue;

		prev = BU_LIST_PREV( tokens, &tok->l );
		next = BU_LIST_NEXT( tokens, &tok->l );

		if( prev->type !=TOK_TREE || next->type != TOK_TREE )
			continue;

		/* this is an eligible intersection operation */
		tp = (union tree *)bu_malloc( sizeof( union tree ), "tp" );
		tp->magic = RT_TREE_MAGIC;
		tp->tr_b.tb_op = OP_INTERSECT;
		tp->tr_b.tb_regionp = (struct region *)NULL;
		tp->tr_b.tb_left = prev->tp;
		tp->tr_b.tb_right = next->tp;
		BU_LIST_DEQUEUE( &tok->l );
		bu_free( (char *)tok, "tok" );
		BU_LIST_DEQUEUE( &prev->l );
		bu_free( (char *)prev, "prev" );
		next->tp = tp;
		tok = next;
	}
}

HIDDEN void
Do_union_subtr( hp )
struct bu_list *hp;
{
	struct tokens *tok;

	for( BU_LIST_FOR( tok, tokens, hp ) )
	{
		struct tokens *prev, *next;
		union tree *tp;

		if( tok->type != TOK_UNION && tok->type != TOK_SUBTR )
			continue;

		prev = BU_LIST_PREV( tokens, &tok->l );
		next = BU_LIST_NEXT( tokens, &tok->l );

		if( prev->type !=TOK_TREE || next->type != TOK_TREE )
			continue;

		/* this is an eligible operation */
		tp = (union tree *)bu_malloc( sizeof( union tree ), "tp" );
		tp->magic = RT_TREE_MAGIC;
		if( tok->type == TOK_UNION )
			tp->tr_b.tb_op = OP_UNION;
		else
			tp->tr_b.tb_op = OP_SUBTRACT;
		tp->tr_b.tb_regionp = (struct region *)NULL;
		tp->tr_b.tb_left = prev->tp;
		tp->tr_b.tb_right = next->tp;
		BU_LIST_DEQUEUE( &tok->l );
		bu_free( (char *)tok, "tok" );
		BU_LIST_DEQUEUE( &prev->l );
		bu_free( (char *)prev, "prev" );
		next->tp = tp;
		tok = next;
	}
}

HIDDEN int
Do_paren( hp )
struct bu_list *hp;
{
	struct tokens *tok;

	for( BU_LIST_FOR( tok, tokens, hp ) )
	{
		struct tokens *prev, *next;

		if( tok->type != TOK_TREE )
			continue;

		prev = BU_LIST_PREV( tokens, &tok->l );
		next = BU_LIST_NEXT( tokens, &tok->l );

		if( prev->type !=TOK_LPAREN || next->type != TOK_RPAREN )
			continue;

		/* this is an eligible operand surrounded by parens */
		BU_LIST_DEQUEUE( &next->l );
		bu_free( (char *)next, "next" );
		BU_LIST_DEQUEUE( &prev->l );
		bu_free( (char *)prev, "prev" );
	}

	if( hp->forw == hp->back && hp->forw != hp )
		return( 1 );	/* done */
	else if( BU_LIST_IS_EMPTY( hp ) )
		return( -1 );	/* empty tree!!!! */
	else
		return( 0 );	/* more to do */
		
}

HIDDEN union tree *
Eval_bool( hp )
struct bu_list *hp;
{
	int done=0;
	union tree *final_tree;
	struct tokens *tok;

	while( done != 1 )
	{
		Do_inter( hp );
		Do_union_subtr( hp );
		done = Do_paren( hp );
	}

	if( done == 1 )
	{
		tok = BU_LIST_NEXT( tokens, hp );
		final_tree = tok->tp;
		BU_LIST_DEQUEUE( &tok->l );
		bu_free( (char *)tok, "tok" );
		return( final_tree );
	}
#if 0
	if( done == (-1) )
#endif
        return( (union tree *)NULL );
}

HIDDEN int
Check_syntax( hp, comb_name, dp )
struct bu_list *hp;
char *comb_name;
struct directory *dp;
{
	struct tokens *tok;
	int paren_count=0;
	int paren_error=0;
	int missing_exp=0;
	int missing_op=0;
	int op_count=0;
	int arg_count=0;
	int circular_ref=0;
	int errors=0;
	short last_tok=TOK_NULL;

	if(dbip == DBI_NULL)
	  return 0;

	for( BU_LIST_FOR( tok, tokens, hp ) )
	{
		switch( tok->type )
		{
			case TOK_LPAREN:
				paren_count++;
				if( last_tok == TOK_RPAREN )
					missing_op++;
				break;
			case TOK_RPAREN:
				paren_count--;
				if( last_tok == TOK_LPAREN )
					missing_exp++;
				break;
			case TOK_UNION:
			case TOK_SUBTR:
			case TOK_INTER:
				op_count++;
				break;
			case TOK_TREE:
				arg_count++;
				if( !dp && !strcmp( comb_name, tok->tp->tr_l.tl_name ) )
					circular_ref++;
				else if( db_lookup( dbip, tok->tp->tr_l.tl_name, LOOKUP_QUIET ) == DIR_NULL )
					Tcl_AppendResult(interp, "WARNING: '",
						tok->tp->tr_l.tl_name,
						"' does not actually exist\n", (char *)NULL );
				break;
		}
		if( paren_count < 0 )
			paren_error++;
		last_tok = tok->type;
	}

	if( paren_count || paren_error )
	{
		Tcl_AppendResult(interp, "ERROR: unbalanced parenthesis\n", (char *)NULL );
		errors++;
	}

	if( missing_exp )
	{
		Tcl_AppendResult(interp, "ERROR: empty parenthesis (missing expression)\n", (char *)NULL );
		errors++;
	}

	if( missing_op )
	{
		Tcl_AppendResult(interp, "ERROR: must have operator between ')('\n", (char *)NULL );
		errors++;
	}

	if( op_count != arg_count-1 )
	{
		Tcl_AppendResult(interp, "ERROR: mismatch of operators and operands\n", (char *)NULL );
		errors++;
	}

	if( circular_ref )
	{
		Tcl_AppendResult(interp, "ERROR: combination cannot reference itself during initial creation\n", (char *)NULL );
		errors++;
	}

	if( errors )
	{
		Tcl_AppendResult(interp, "\t---------aborting!\n", (char *)NULL );
		return( 1 );
	}

	return( 0 );
}

/*
 *		    F _ C O M B _ S T D ( )
 *
 *	Input a combination in standard set-theoetic notation
 *
 *	Syntax: c [-gr] comb_name [boolean_expr]
 */
int
f_comb_std(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	char				*comb_name;
	int				ch;
	int				region_flag = -1;
	register struct directory	*dp;
    	struct rt_db_internal		intern;
	struct rt_comb_internal		*comb = NULL;
	struct tokens			tok_hd;
	struct tokens			*tok;
	short				last_tok;
	int				i;
	union tree			*final_tree;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 3){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help c");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* Parse options */
	bu_optind = 1;	/* re-init bu_getopt() */
	while ((ch = bu_getopt(argc, argv, "gr?")) != EOF)
	{
		switch (ch)
		{
		  case 'g':
			region_flag = 0;
			break;
		  case 'r':
			region_flag = 1;
			break;
		  /* XXX How about -p and -v for FASTGEN? */
		  case '?':
			  default:
			PRINT_USAGE;
			return TCL_OK;
		}
	}
	argc -= (bu_optind + 1);
	argv += bu_optind;

	comb_name = *argv++;
	if (argc == -1)
	{
		PRINT_USAGE;
		return TCL_OK;
	}

	if ((region_flag != -1) && (argc == 0))
	{
		/*
		 *	Set/Reset the REGION flag of an existing combination
		 */
		if ((dp = db_lookup(dbip, comb_name, LOOKUP_NOISY)) == DIR_NULL)
			return TCL_ERROR;

		if( !(dp->d_flags & DIR_COMB) )
		{
			Tcl_AppendResult(interp, comb_name, " is not a combination\n", (char *)0 );
			return TCL_ERROR;
		}

		if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
			TCL_READ_ERR_return;
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		RT_CK_COMB( comb );

		if( region_flag )
			comb->region_flag = 1;
		else
			comb->region_flag = 0;

		if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
		{
			rt_comb_ifree( &intern, &rt_uniresource );
			TCL_WRITE_ERR_return;
		}

		return TCL_OK;
	}
	/*
	 *	At this point, we know we have a Boolean expression.
	 *	If the combination already existed and region_flag is -1,
	 *	then leave its region_flag alone.
	 *	If the combination didn't exist yet,
	 *	then pretend region_flag was 0.
	 *	Otherwise, make sure to set its c_flags according to region_flag.
	 */

	dp = db_lookup( dbip, comb_name, LOOKUP_QUIET );
	if( dp != DIR_NULL )
	{
		Tcl_AppendResult(interp, "ERROR: ", comb_name, " already exists\n", (char *)0 );
		return TCL_ERROR;
	}

	/* parse Boolean expression */
	BU_LIST_INIT( &tok_hd.l );
	tok_hd.type = TOK_NULL;

	last_tok = TOK_LPAREN;
	for( i=0 ; i<argc ; i++ )
	{
		char *ptr;

		ptr = argv[i];
		while( *ptr )
		{
			while( *ptr == '(' || *ptr == ')' )
			{
				switch( *ptr )
				{
					case '(':
						Append_lparen( &tok_hd.l );
						last_tok = TOK_LPAREN;
						break;
					case ')':
						Append_rparen( &tok_hd.l );
						last_tok = TOK_RPAREN;
						break;
				}
				ptr++;
			}

			if( *ptr == '\0' )
				continue;

			if( last_tok == TOK_RPAREN )
			{
				/* next token MUST be an operator */
				if( Add_operator( &tok_hd.l, *ptr, &last_tok ) == TCL_ERROR )
				{
					Free_tokens( &tok_hd.l );
					if( dp != DIR_NULL )
						rt_comb_ifree( &intern, &rt_uniresource );
					return TCL_ERROR;
				}
				ptr++;
			}
			else if( last_tok == TOK_LPAREN )
			{
				/* next token MUST be an operand */
				int name_len;

				name_len = Add_operand( &tok_hd.l, ptr );
				if( name_len < 1 )
				{
					Free_tokens( &tok_hd.l );
					if( dp != DIR_NULL )
						rt_comb_ifree( &intern, &rt_uniresource );
					return TCL_ERROR;
				}
				last_tok = TOK_TREE;
				ptr += name_len;
			}
			else if( last_tok == TOK_TREE )
			{
				/* must be an operator */
				if( Add_operator( &tok_hd.l, *ptr, &last_tok ) == TCL_ERROR )
				{
					Free_tokens( &tok_hd.l );
					if( dp != DIR_NULL )
						rt_comb_ifree( &intern, &rt_uniresource );
					return TCL_ERROR;
				}
				ptr++;
			}
			else if( last_tok == TOK_UNION ||
				 last_tok == TOK_INTER ||
				 last_tok == TOK_SUBTR )
			{
				/* must be an operand */
				int name_len;

				name_len = Add_operand( &tok_hd.l, ptr );
				if( name_len < 1 )
				{
					Free_tokens( &tok_hd.l );
					if( dp != DIR_NULL )
						rt_comb_ifree( &intern, &rt_uniresource );
					return TCL_ERROR;
				}
				last_tok = TOK_TREE;
				ptr += name_len;
			}
		}
	}

#if 0
	Tcl_AppendResult(interp, "parsed tree:\n", (char *)NULL );
	for( BU_LIST_FOR( tok, tokens, &tok_hd.l ) )
	{
		switch( tok->type )
		{
			case TOK_LPAREN:
				Tcl_AppendResult(interp, " ( ", (char *)NULL );
				break;
			case TOK_RPAREN:
				Tcl_AppendResult(interp, " ) ", (char *)NULL );
				break;
			case TOK_UNION:
				Tcl_AppendResult(interp, " u ", (char *)NULL );
				break;
			case TOK_INTER:
				Tcl_AppendResult(interp, " + ", (char *)NULL );
				break;
			case TOK_SUBTR:
				Tcl_AppendResult(interp, " - ", (char *)NULL );
				break;
			case TOK_TREE:
				Tcl_AppendResult(interp, tok->tp->tr_l.tl_name, (char *)NULL );
				break;
			default:
				Tcl_AppendResult(interp, "\nUnrecognized token type\n", (char *)NULL );
				break;
		}
	}
	Tcl_AppendResult(interp, "\n", (char *)NULL );
#endif

	if( Check_syntax( &tok_hd.l, comb_name, dp ) )
	{
		Free_tokens( &tok_hd.l );
		return TCL_ERROR;
#if 0
		if( dp != DIR_NULL )
			rt_comb_ifree( &intern, &rt_uniresource );
#endif
	}

	/* replace any occurences of comb_name with existing tree */
	if( dp != DIR_NULL )
	{
		for( BU_LIST_FOR( tok, tokens, &tok_hd.l ) )
		{
			struct rt_db_internal intern1;
			struct rt_comb_internal *comb1;

			switch( tok->type )
			{
				case TOK_LPAREN:
				case TOK_RPAREN:
				case TOK_UNION:
				case TOK_INTER:
				case TOK_SUBTR:
					break;
				case TOK_TREE:
					if( !strcmp( tok->tp->tr_l.tl_name, comb_name ) )
					{
						db_free_tree( tok->tp, &rt_uniresource );
						if( rt_db_get_internal( &intern1, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
						{
							Tcl_AppendResult(interp, "Cannot get records for ", comb_name, "\n" );
							TCL_READ_ERR_return;
						}
						comb1 = (struct rt_comb_internal *)intern1.idb_ptr;
						RT_CK_COMB( comb1 );

						tok->tp = comb1->tree;
						comb1->tree = (union tree *)NULL;
						rt_comb_ifree( &intern1, &rt_uniresource );
					}
				break;
				default:
					Tcl_AppendResult(interp, "ERROR: Unrecognized token type\n", (char *)NULL );
					Free_tokens( &tok_hd.l );
					return TCL_ERROR;
			}
		}
	}

	final_tree = Eval_bool( &tok_hd.l );

#if 0
	{
		char *str;

		Tcl_AppendResult(interp, "evaluated tree:\n", (char *)NULL );
		str = rt_pr_tree_str( final_tree );
		Tcl_AppendResult(interp, str, (char *)NULL );
		bu_free( str, "str" );
	}
#endif
	if( dp == DIR_NULL )
	{
		BU_GETSTRUCT( comb, rt_comb_internal );
		comb->magic = RT_COMB_MAGIC;
		comb->tree = final_tree;
		bu_vls_init( &comb->shader );
		bu_vls_init( &comb->material );
		comb->region_id = -1;
		if( region_flag == (-1) )
			comb->region_flag = 0;
		else
			comb->region_flag = region_flag;

		if( comb->region_flag )
		{
			struct bu_vls tmp_vls;

			comb->region_flag = 1;
			comb->region_id = item_default++;;
			comb->aircode = air_default;
			comb->los = los_default;
			comb->GIFTmater = mat_default;
			bu_vls_init(&tmp_vls);
			bu_vls_printf(&tmp_vls,
				"Creating region id=%d, air=%d, los=%d, GIFTmaterial=%d\n",
				comb->region_id, comb->aircode, comb->los, comb->GIFTmater );
			Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			bu_vls_free(&tmp_vls);
		}

		RT_INIT_DB_INTERNAL( &intern );
		intern.idb_type = ID_COMBINATION;
		intern.idb_meth = &rt_functab[ID_COMBINATION];
		intern.idb_ptr = (genptr_t)comb;

		if( (dp=db_diradd( dbip, comb_name, -1L, 0, DIR_COMB, (genptr_t)&intern.idb_type )) == DIR_NULL )
		{
			Tcl_AppendResult(interp, "Failed to add ", comb_name,
				" to directory, aborting\n" , (char *)NULL );
			TCL_ERROR_RECOVERY_SUGGESTION;
			return TCL_ERROR;
		}

		if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
		{
			Tcl_AppendResult(interp, "Failed to write ", dp->d_namep, (char *)NULL );
			return TCL_ERROR;
		}
	}
	else
	{
		db_delete( dbip, dp );

		dp->d_len = 0;
		dp->d_un.file_offset = -1;
		db_free_tree( comb->tree, &rt_uniresource );
		comb->tree = final_tree;

		if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
		{
			Tcl_AppendResult(interp, "Failed to write ", dp->d_namep, (char *)NULL );
			return TCL_ERROR;
		}
	}

	return TCL_OK;
}
@


1.30
log
@Minor adjustment in f_comb_std() debug messages
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/comb_std.c,v 1.29 2001/03/23 22:05:34 jra Exp $ (BRL)";
@


1.29
log
@Support for major and minor types in directory structure
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/comb_std.c,v 1.28 2000/10/24 20:01:44 mike Exp $ (BRL)";
d776 1
a776 1
		struct bu_vls vls;
d779 3
a781 4
		bu_vls_init( &vls );
		db_tree_describe( &vls, final_tree, 0, 0, 1,0 );
		Tcl_AppendResult(interp, bu_vls_addr( &vls ), (char *)NULL );
		bu_vls_free( &vls );
@


1.28
log
@
possible uninit
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/comb_std.c,v 1.27 2000/10/24 15:14:13 mike Exp $ (BRL)";
d820 1
a820 1
		if( (dp=db_diradd( dbip, comb_name, -1L, 0, DIR_COMB, NULL )) == DIR_NULL )
@


1.27
log
@
compiler lint
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/comb_std.c,v 1.26 2000/09/08 05:55:48 mike Exp $ (BRL)";
d500 1
a500 1
	struct rt_comb_internal		*comb;
@


1.26
log
@
Tree routines now need resource structure.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/comb_std.c,v 1.25 2000/08/19 03:10:43 mike Exp $ (BRL)";
d36 1
a500 2
	extern int			bu_optind;
	extern char			*bu_optarg;
@


1.25
log
@
const RCSid
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/comb_std.c,v 1.24 2000/08/19 03:10:13 mike Exp $ (BRL)";
d74 1
a74 1
				db_free_tree( tok->tp );
d564 1
a564 1
		if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d574 1
a574 1
		if( rt_db_put_internal( dp, dbip, &intern ) < 0 )
d576 1
a576 1
			rt_comb_ifree( &intern );
d636 1
a636 1
						rt_comb_ifree( &intern );
d651 1
a651 1
						rt_comb_ifree( &intern );
d664 1
a664 1
						rt_comb_ifree( &intern );
d681 1
a681 1
						rt_comb_ifree( &intern );
d728 1
a728 1
			rt_comb_ifree( &intern );
d751 2
a752 2
						db_free_tree( tok->tp );
						if( rt_db_get_internal( &intern1, dp, dbip, (fastf_t *)NULL ) < 0 )
d762 1
a762 1
						rt_comb_ifree( &intern1 );
d829 1
a829 1
		if( rt_db_put_internal( dp, dbip, &intern ) < 0 )
d841 1
a841 1
		db_free_tree( comb->tree );
d844 1
a844 1
		if( rt_db_put_internal( dp, dbip, &intern ) < 0 )
@


1.24
log
@
Reduced use of MAXARGS
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/comb_std.c,v 1.23 2000/03/04 05:15:41 mike Exp $ (BRL)";
@


1.23
log
@
Modified to note FASTGEN plate/volume mode as possible future extension.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/comb_std.c,v 1.22 1999/12/30 20:11:50 jra Exp $ (BRL)";
d511 1
a511 1
	if(argc < 3 || MAXARGS < argc){
@


1.22
log
@Eliminated some unused variables
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/comb_std.c,v 1.21 1999/12/29 23:23:20 mike Exp $ (BRL)";
d533 1
d585 1
a585 1
	 *	then leave its c_flags alone.
@


1.21
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/comb_std.c,v 1.20 1999/11/26 23:03:31 mike Exp $ (BRL)";
a331 1
		union tree *tp;
a604 2
		char *ptr_next;
		union tree *node;
@


1.20
log
@
Lint
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/comb_std.c,v 1.19 1999/11/24 14:26:41 jra Exp $ (BRL)";
d823 1
a823 1
		if( (dp=db_diradd( dbip, comb_name, -1L, 0, DIR_COMB )) == DIR_NULL )
@


1.19
log
@All solid/combination creation  routines needed values assigned to idb_meth
in the rt_db_internal struct
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/comb_std.c,v 1.18 1999/09/01 18:55:09 bparker Exp $ (BRL)";
d564 1
a564 1
		if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d754 1
a754 1
						if( rt_db_get_internal( &intern1, dp, dbip, (mat_t *)NULL ) < 0 )
@


1.18
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/comb_std.c,v 1.17 1997/08/22 22:38:22 mike Exp $ (BRL)";
d820 1
@


1.17
log
@Made use of bu_getopt() explicit, rather than depending on
#define in bu.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.16 1997/07/01 22:09:08 bparker Exp mike $ (BRL)";
d509 1
a509 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

@


1.16
log
@mods to run without a database
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.15 1997/05/02 14:21:18 jra Exp bparker $ (BRL)";
d501 2
a502 2
	extern int			optind;
	extern char			*optarg;
d525 2
a526 2
	optind = 1;	/* re-init getopt() */
	while ((ch = getopt(argc, argv, "gr?")) != EOF)
d542 2
a543 2
	argc -= (optind + 1);
	argv += optind;
@


1.15
log
@Mod to keep "c" command from overwriting existing combinations.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.14 1997/04/24 18:03:58 bparker Exp jra $ (BRL)";
d405 3
d508 3
@


1.14
log
@modify calls to Tcl_Eval
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.13 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d554 6
d590 2
a591 17
		if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
		{
			Tcl_AppendResult(interp, "Cannot get records for ", comb_name, "\n" );
			TCL_READ_ERR_return;
		}
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		RT_CK_COMB( comb );

		if( region_flag != (-1) )
		{
			if( region_flag )
				comb->region_flag = 1;
			else
				comb->region_flag = 0;
		}
		Tcl_AppendResult(interp, "WARNING: existing combination '", comb_name,
			"' will be overwritten\n", (char *)NULL );
@


1.13
log
@mods so that commands check args internally
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.12 1997/03/25 13:27:08 jra Exp bparker $ (BRL)";
d509 6
a514 1
	  Tcl_Eval(interp, "help c");
@


1.12
log
@Rewrite of "c" command.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.11 1997/02/25 19:03:14 jra Exp $ (BRL)";
d508 4
a511 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
		return TCL_ERROR;
@


1.11
log
@Fixed a minor bug (but it still doesn't work).
@
text
@d1 1
a1 2
/*
 *			C O M B _ S T D . C
d3 1
a3 8
 * Functions -
 *	bt_create_leaf		Create a leaf node for a Boolean tree
 *	bt_create_internal	Create an internal node for a Boolean tree
 *	f_comb_std		Create or extend a combination from
 *				a Boolean expression in unrestricted
 *				(standard) form
 *	bool_input_from_vls	input function for lex(1) scanner
 *	bool_unput_from_vls	output function for lex(1) scanner
d6 1
a6 1
 *	Paul Tanenbaum
d9 2
a10 2
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
d13 3
a15 3
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
d18 2
a19 2
 *	This software is Copyright (C) 1995 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d21 1
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.10 1997/02/25 13:57:02 jra Exp jra $ (BRL)";
d29 5
a39 1
#include "./comb_bool.h"
d44 278
a321 3
static struct bu_vls	vp;			/* The Boolean expression */
char			*bool_bufp = 0;
struct bool_tree_node	*comb_bool_tree;
d323 3
a325 9
/*
 *		    B T _ C R E A T E _ L E A F ( )
 *
 *		Create a leaf node for a Boolean tree
 *
 */
struct bool_tree_node *
bt_create_leaf(object_name)
char *object_name;
d327 1
a327 2
    struct bool_tree_node	*b;
    char			*sp;
d329 4
a332 2
    b = (struct bool_tree_node *)
	    bu_malloc(sizeof(struct bool_tree_node), "Bool-tree leaf");
d334 2
a335 3
    b -> btn_magic = BOOL_TREE_NODE_MAGIC;
    bt_opn(b) = OPN_NULL;
    sp = bu_malloc(strlen(object_name) + 1, "Bool-tree leaf name");
d337 2
a338 3
    bu_semaphore_acquire( (unsigned int)(&rt_g.res_syscall - &rt_g.res_syscall) );		/* lock */
    sprintf(sp, "%s", object_name);
    bu_semaphore_release( (unsigned int)(&rt_g.res_syscall - &rt_g.res_syscall) );		/* unlock */
d340 9
a348 1
    bt_leaf_name(b) = sp;
d350 7
a356 1
    return(b);
d359 14
a372 34
/*
 *		B T _ C R E A T E _ I N T E R N A L ( )
 *
 *		Create a leaf node for a Boolean tree
 *
 */
struct bool_tree_node *
bt_create_internal(opn, opd1, opd2)
int opn;
struct bool_tree_node *opd1, *opd2;
{
    struct bool_tree_node	*b;

    BU_CKMAG(opd1, BOOL_TREE_NODE_MAGIC, "Boolean tree node");
    BU_CKMAG(opd2, BOOL_TREE_NODE_MAGIC, "Boolean tree node");

    b = (struct bool_tree_node *)
	    bu_malloc(sizeof(struct bool_tree_node), "Bool-tree leaf");

    b -> btn_magic = BOOL_TREE_NODE_MAGIC;
    switch (opn)
    {
	case OPN_UNION:
	case OPN_DIFFERENCE:
	case OPN_INTERSECTION:
	    bt_opn(b) = opn;
	    break;
	default:
	    bu_log("%s:%d:bt_create_internal: Illegal operation '%d'\n",
		__FILE__, __LINE__, opn);
	    exit (1);
    }
    bt_opd(b, BT_LEFT) = opd1;
    bt_opd(b, BT_RIGHT) = opd2;
d374 12
a385 1
    return (b);
d388 89
d492 43
a534 25
    char			*comb_name;
    int				ch;
    int				region_flag = -1;
    register struct directory	*dp;

    extern int			optind;
    extern char			*optarg;

    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
      return TCL_ERROR;

    /* Parse options */
    optind = 1;	/* re-init getopt() */
    while ((ch = getopt(argc, argv, "gr?")) != EOF)
    {
	switch (ch)
	{
	    case 'g':
		region_flag = 0;
		break;
	    case 'r':
		region_flag = 1;
		break;
	    case '?':
	    default:
a537 10
    }
    argc -= (optind + 1);
    argv += optind;

    comb_name = *argv++;
    if (argc == -1)
    {
	PRINT_USAGE;
	return TCL_OK;
    }
d539 23
a561 4
    if ((region_flag != -1) && (argc == 0))
    {
    	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
d563 2
d566 6
a571 1
	 *	Set/Reset the REGION flag of an existing combination
d573 158
a730 2
	if ((dp = db_lookup(dbip, comb_name, LOOKUP_NOISY)) == DIR_NULL)
	  return TCL_ERROR;
d732 40
a771 9
    	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
    		TCL_READ_ERR_return;
    	comb = (struct rt_comb_internal *)intern.idb_ptr;
    	RT_CK_COMB( comb );

    	if( region_flag )
    		comb->region_flag = 1;
    	else
    		comb->region_flag = 0;
d773 1
a773 2
    	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )
    		TCL_WRITE_ERR_return;
d775 3
a777 26
	return TCL_OK;
    }
    /*
     *	At this point, we know we have a Boolean expression.
     *	If the combination already existed and region_flag is -1,
     *	then leave its c_flags alone.
     *	If the combination didn't exist yet,
     *	then pretend region_flag was 0.
     *	Otherwise, make sure to set its c_flags according to region_flag.
     */

    if (bool_bufp == 0)
	bu_vls_init(&vp);
    else
	bu_vls_trunc(&vp, 0);

    bu_vls_from_argv(&vp, argc, argv);
    bool_bufp = bu_vls_addr(&vp);
    Tcl_AppendResult(interp, "Will define ", ((region_flag == 1) ? "region" : "group"),
		     " '", comb_name, "' as '", bool_bufp, "'\n", (char *)NULL);
    if (yyparse() != 0)
    {
      Tcl_AppendResult(interp, "Invalid Boolean expression\n");
      return TCL_ERROR;
    }
    show_gift_bool(comb_bool_tree, 1);
d779 58
a836 2
    return TCL_OK;
}
d838 11
a848 14
/*
 *		B O O L _ I N P U T _ F R O M _ V L S ( )
 *
 *	Input function for LEX(1) scanner to read Boolean expressions
 *	from a variable-length string.
 */
int
bool_input_from_vls()
{
    if (*bool_bufp == '\0')
	return (0);
    else
	return (*bool_bufp++);
}
d850 1
a850 11
/*
 *		B O O L _ U N P U T _ F R O M _ V L S ( )
 *
 *	Unput function for LEX(1) scanner to read Boolean expressions
 *	from a variable-length string.
 */
void
bool_unput_from_vls(ch)
int ch;
{
    *--bool_bufp = ch;
@


1.10
log
@Completed conversion to combination import/export.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.9 1997/02/21 13:41:54 jra Exp jra $ (BRL)";
a207 1
    {
a208 2
	bool_bufp = bu_vls_addr(&vp);
    }
d213 2
a214 1
    Tcl_AppendResult(interp, "Will define ", (region_flag ? "region" : "group"),
@


1.9
log
@Converted to use combination import/export.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.8 1997/01/02 22:12:41 bparker Exp jra $ (BRL)";
a38 1
#include "db.h"
a136 1
    union record		record;
@


1.8
log
@.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.7 1997/01/02 19:33:14 bparker Exp bparker $ (BRL)";
d176 3
d184 14
a197 14
	if (db_get(dbip, dp, &record, 0, 1) < 0)
	{
	  TCL_READ_ERR_return;
	}
	if (record.u_id != ID_COMB )
	{
	  Tcl_AppendResult(interp, comb_name, ":  not a combination\n", (char *)NULL);
	  return TCL_OK;
	}
	record.c.c_flags = region_flag ? 'R' : ' ';
	if (db_put(dbip, dp, &record, 0, 1) < 0)
	{
	    TCL_WRITE_ERR_return;
	}
@


1.7
log
@mods to use libbn and libbu
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.6 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d72 1
a72 1
    bu_semaphore_acquire( &rt_g.res_syscall );		/* lock */
d74 1
a74 1
    bu_semaphore_release( &rt_g.res_syscall );		/* unlock */
@


1.6
log
@rt_list ---> bu_list
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.5 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d72 1
a72 1
    RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d74 1
a74 1
    RES_RELEASE( &rt_g.res_syscall );		/* unlock */
@


1.5
log
@now using libbu
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.4 1996/08/22 20:53:11 bparker Exp bparker $ (BRL)";
a42 1
#include "rtstring.h"
@


1.4
log
@removed unreachable statement.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.3 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d49 1
a49 1
static struct rt_vls	vp;			/* The Boolean expression */
d67 1
a67 1
	    rt_malloc(sizeof(struct bool_tree_node), "Bool-tree leaf");
d71 1
a71 1
    sp = rt_malloc(strlen(object_name) + 1, "Bool-tree leaf name");
d95 2
a96 2
    RT_CKMAG(opd1, BOOL_TREE_NODE_MAGIC, "Boolean tree node");
    RT_CKMAG(opd2, BOOL_TREE_NODE_MAGIC, "Boolean tree node");
d99 1
a99 1
	    rt_malloc(sizeof(struct bool_tree_node), "Bool-tree leaf");
d110 1
a110 1
	    rt_log("%s:%d:bt_create_internal: Illegal operation '%d'\n",
d209 2
a210 2
	rt_vls_init(&vp);
	bool_bufp = rt_vls_addr(&vp);
d213 1
a213 1
	rt_vls_trunc(&vp, 0);
d215 1
a215 1
    rt_vls_from_argv(&vp, argc, argv);
@


1.3
log
@convert commands to Tcl
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.2 1995/08/10 21:09:33 gdurf Exp bparker $ (BRL)";
a194 1
	    return TCL_ERROR;
@


1.2
log
@ANSI prototypes!
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/comb_std.c,v 1.1 1995/06/23 19:54:36 pjt Exp gdurf $ (BRL)";
d46 2
a47 1
#define	PRINT_USAGE	rt_log("c: usage 'c [-gr] comb_name [bool_expr]'\n")
d129 3
a131 1
f_comb_std (argc, argv)
a133 1

d144 3
d162 1
a162 1
		return (CMD_OK);
d172 1
a172 1
	return (CMD_OK);
d181 1
a181 1
	    return (CMD_BAD);
d184 1
a184 2
	    READ_ERR;
	    return (CMD_BAD);
d188 2
a189 2
	    rt_log("%s:  not a combination\n", comb_name );
	    return (CMD_OK);
d194 2
a195 2
	    WRITE_ERR;
	    return (CMD_BAD);
d197 1
a197 1
	return (CMD_OK);
d215 1
d217 2
a218 2
    rt_log("Will define %s '%s' as '%s'\n",
	(region_flag ? "region" : "group"), comb_name, bool_bufp);
d221 2
a222 2
	rt_log("Invalid Boolean expression\n");
	return (CMD_BAD);
d226 1
a226 1
    return (CMD_OK);
@


1.1
log
@Initial revision
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 11.1 95/01/04 10:03:23 mike Rel4_4 $ (BRL)";
d58 3
a60 1
struct bool_tree_node *bt_create_leaf (char *object_name)
d87 4
a90 3
struct bool_tree_node *bt_create_internal (int opn,
		    struct bool_tree_node *opd1,
		    struct bool_tree_node *opd2)
d127 2
a128 2
int f_comb_std (argc, argv)

d230 2
a231 1
int bool_input_from_vls ()
d245 3
a247 4
void bool_unput_from_vls (ch)

int	ch;

@
