head	11.111;
access;
symbols
	ansi-20040405-merged:11.108.2.1
	postmerge-20040405-ansi:11.109
	premerge-20040404-ansi:11.108
	postmerge-autoconf:11.108
	autoconf-freeze:11.108
	premerge-autoconf:11.108
	postmerge-20040315-windows:11.108
	premerge-20040315-windows:11.108
	windows-20040315-freeze:11.108
	autoconf-20031203:11.108
	autoconf-20031202:11.108
	autoconf-branch:11.108.0.10
	phong-branch:11.108.0.8
	photonmap-branch:11.108.0.6
	rel-6-1-DP:11.108
	windows-branch:11.108.0.4
	rel-6-0-2:11.106
	ansi-branch:11.108.0.2
	rel-6-0-1-branch:11.106.0.2
	hartley-6-0-post:11.107
	hartley-6-0-pre:11.106
	rel-6-0-1:11.106
	rel-6-0:11.106
	rel-5-4:11.72.2.2
	offsite-5-3-pre:11.88
	rel-5-3:11.72.2.2
	rel-5-2:11.72
	rel-5-1-branch:11.72.0.2
	rel-5-1:11.72
	rel-5-0:11.63
	rel-5-0-beta:11.61
	rel-4-5:11.55
	ctj-4-5-post:11.46
	ctj-4-5-pre:11.46
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.4
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.111
date	2004.05.21.17.47.51;	author morrison;	state dead;
branches;
next	11.110;

11.110
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.109;

11.109
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.108;

11.108
date	2002.08.20.17.08.26;	author jra;	state Exp;
branches
	11.108.2.1;
next	11.107;

11.107
date	2002.08.15.20.55.39;	author hartley;	state Exp;
branches;
next	11.106;

11.106
date	2001.06.01.19.23.25;	author bparker;	state Exp;
branches;
next	11.105;

11.105
date	2001.05.04.14.20.46;	author bparker;	state Exp;
branches;
next	11.104;

11.104
date	2001.05.03.17.01.47;	author bparker;	state Exp;
branches;
next	11.103;

11.103
date	2001.05.02.17.12.37;	author bparker;	state Exp;
branches;
next	11.102;

11.102
date	2001.04.20.20.01.49;	author bparker;	state Exp;
branches;
next	11.101;

11.101
date	2001.04.05.19.35.46;	author morrison;	state Exp;
branches;
next	11.100;

11.100
date	2001.04.04.12.54.55;	author jra;	state Exp;
branches;
next	11.99;

11.99
date	2001.04.02.21.38.21;	author morrison;	state Exp;
branches;
next	11.98;

11.98
date	2001.04.02.20.07.16;	author jra;	state Exp;
branches;
next	11.97;

11.97
date	2001.04.02.18.10.11;	author jra;	state Exp;
branches;
next	11.96;

11.96
date	2001.03.31.01.57.24;	author morrison;	state Exp;
branches;
next	11.95;

11.95
date	2001.03.27.23.09.34;	author bparker;	state Exp;
branches;
next	11.94;

11.94
date	2001.03.26.19.15.55;	author bparker;	state Exp;
branches;
next	11.93;

11.93
date	2001.03.23.22.05.36;	author jra;	state Exp;
branches;
next	11.92;

11.92
date	2001.03.22.22.00.39;	author bparker;	state Exp;
branches;
next	11.91;

11.91
date	2001.03.22.18.14.42;	author bparker;	state Exp;
branches;
next	11.90;

11.90
date	2001.03.21.22.15.58;	author bparker;	state Exp;
branches;
next	11.89;

11.89
date	2001.03.21.20.12.39;	author bparker;	state Exp;
branches;
next	11.88;

11.88
date	2001.02.16.22.40.58;	author bparker;	state Exp;
branches;
next	11.87;

11.87
date	2001.01.17.21.01.13;	author jra;	state Exp;
branches;
next	11.86;

11.86
date	2000.10.24.20.00.52;	author mike;	state Exp;
branches;
next	11.85;

11.85
date	2000.10.24.19.05.10;	author mike;	state Exp;
branches;
next	11.84;

11.84
date	2000.10.24.15.02.43;	author mike;	state Exp;
branches;
next	11.83;

11.83
date	2000.10.23.14.28.52;	author jra;	state Exp;
branches;
next	11.82;

11.82
date	2000.10.20.20.35.59;	author jra;	state Exp;
branches;
next	11.81;

11.81
date	2000.09.09.04.30.56;	author mike;	state Exp;
branches;
next	11.80;

11.80
date	2000.09.08.05.55.49;	author mike;	state Exp;
branches;
next	11.79;

11.79
date	2000.08.19.03.46.00;	author mike;	state Exp;
branches;
next	11.78;

11.78
date	2000.08.19.03.10.18;	author mike;	state Exp;
branches;
next	11.77;

11.77
date	2000.08.18.20.14.43;	author mike;	state Exp;
branches;
next	11.76;

11.76
date	2000.07.23.23.42.22;	author mike;	state Exp;
branches;
next	11.75;

11.75
date	2000.06.30.19.58.09;	author mike;	state Exp;
branches;
next	11.74;

11.74
date	2000.06.28.16.58.42;	author mike;	state Exp;
branches;
next	11.73;

11.73
date	2000.06.28.16.11.06;	author mike;	state Exp;
branches;
next	11.72;

11.72
date	2000.03.29.22.24.30;	author bparker;	state Exp;
branches
	11.72.2.1;
next	11.71;

11.71
date	2000.01.13.20.15.17;	author jra;	state Exp;
branches;
next	11.70;

11.70
date	2000.01.04.17.58.21;	author bparker;	state Exp;
branches;
next	11.69;

11.69
date	99.12.30.20.09.20;	author jra;	state Exp;
branches;
next	11.68;

11.68
date	99.12.29.23.23.27;	author mike;	state Exp;
branches;
next	11.67;

11.67
date	99.12.29.21.09.46;	author mike;	state Exp;
branches;
next	11.66;

11.66
date	99.12.23.06.10.52;	author mike;	state Exp;
branches;
next	11.65;

11.65
date	99.11.26.23.03.33;	author mike;	state Exp;
branches;
next	11.64;

11.64
date	99.11.24.14.26.42;	author jra;	state Exp;
branches;
next	11.63;

11.63
date	99.09.01.18.55.12;	author bparker;	state Exp;
branches;
next	11.62;

11.62
date	99.08.27.20.13.53;	author pjt;	state Exp;
branches;
next	11.61;

11.61
date	99.03.01.15.53.05;	author pjt;	state Exp;
branches;
next	11.60;

11.60
date	99.01.21.18.31.19;	author bparker;	state Exp;
branches;
next	11.59;

11.59
date	98.12.17.04.19.11;	author mike;	state Exp;
branches;
next	11.58;

11.58
date	98.09.14.15.59.20;	author bparker;	state Exp;
branches;
next	11.57;

11.57
date	98.03.19.15.55.50;	author jra;	state Exp;
branches;
next	11.56;

11.56
date	98.02.22.23.31.35;	author jra;	state Exp;
branches;
next	11.55;

11.55
date	97.12.18.06.49.07;	author mike;	state Exp;
branches;
next	11.54;

11.54
date	97.12.16.14.34.41;	author pjt;	state Exp;
branches;
next	11.53;

11.53
date	97.12.08.21.17.08;	author pjt;	state Exp;
branches;
next	11.52;

11.52
date	97.09.22.02.03.08;	author butler;	state Exp;
branches;
next	11.51;

11.51
date	97.09.10.17.34.40;	author bparker;	state Exp;
branches;
next	11.50;

11.50
date	97.08.26.14.17.47;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	97.08.22.22.38.22;	author mike;	state Exp;
branches;
next	11.48;

11.48
date	97.08.15.19.21.42;	author jra;	state Exp;
branches;
next	11.47;

11.47
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.46;

11.46
date	97.05.27.12.05.29;	author jra;	state Exp;
branches;
next	11.45;

11.45
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.44;

11.44
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.43;

11.43
date	97.04.08.14.03.54;	author jra;	state Exp;
branches;
next	11.42;

11.42
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.41;

11.41
date	97.03.12.20.45.46;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	97.02.25.13.53.26;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	97.02.14.13.14.30;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	97.02.13.18.03.39;	author jra;	state Exp;
branches;
next	11.37;

11.37
date	97.02.13.17.59.52;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	97.02.13.17.18.13;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	97.02.13.14.16.25;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	97.02.12.16.04.36;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	97.01.02.22.12.41;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	97.01.02.19.31.06;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	96.12.04.03.39.35;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	96.10.25.16.51.53;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	96.10.18.15.42.31;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	96.10.04.15.07.15;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	96.10.03.20.31.11;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	96.10.01.17.26.29;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	96.09.03.13.07.52;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	96.08.28.15.07.47;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	96.08.20.20.59.47;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	96.08.20.20.38.32;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	96.08.16.14.05.32;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	96.07.25.18.59.31;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	96.07.15.20.33.56;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	96.06.06.21.41.46;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	96.06.03.12.47.19;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.03.01.19.25.10;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.02.22.16.27.07;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	96.02.20.17.01.00;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	96.01.17.19.01.09;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	95.12.07.18.06.26;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.04.20.20.16.55;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.03.10.19.18.20;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.02.17.21.33.32;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.02.13.15.46.00;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.05.28;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.48;	author mike;	state Rel4_4;
branches;
next	10.13;

10.13
date	94.12.23.23.48.34;	author gdurf;	state Exp;
branches;
next	10.12;

10.12
date	94.12.16.20.56.06;	author gdurf;	state Exp;
branches;
next	10.11;

10.11
date	94.12.16.20.39.13;	author gdurf;	state Exp;
branches;
next	10.10;

10.10
date	94.12.16.19.37.37;	author gdurf;	state Exp;
branches;
next	10.9;

10.9
date	94.11.10.12.06.18;	author jra;	state Exp;
branches;
next	10.8;

10.8
date	94.11.07.16.13.59;	author jra;	state Exp;
branches;
next	10.7;

10.7
date	94.08.09.19.03.08;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.06.13.19.03.37;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.06.01.15.48.40;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.05.11.15.23.56;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	94.03.11.06.28.52;	author cjohnson;	state Exp;
branches;
next	10.2;

10.2
date	91.12.18.06.48.01;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.27;	author mike;	state Rel4_0;
branches;
next	9.6;

9.6
date	91.07.09.02.08.59;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.08.06.00.18;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.08.00.31.30;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.07.03.17.18;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.12.07.01.12.02;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.04.16;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.05.11.21.42.52;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.04.06.19.28.17;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	88.12.06.02.36.19;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.10.06.05.11.40;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.37.40;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.08.12.20.26.32;	author phil;	state Exp;
branches;
next	7.4;

7.4
date	88.05.15.23.05.33;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	87.11.05.07.09.28;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.07.35;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.02.27;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.06.00;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.22.56;	author mike;	state Rel;
branches;
next	4.4;

4.4
date	87.02.13.00.13.36;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.11.05.38.28;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.11.05.08.01;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.23.42;	author mike;	state Rel1;
branches;
next	1.6;

1.6
date	86.10.12.03.08.43;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.09.23.19.52.42;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.09.23.17.42.36;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.08.12.06.51.38;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.03.14.20.42.41;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.03.10.21.44.09;	author mike;	state Exp;
branches;
next	;

11.72.2.1
date	2000.10.25.19.05.24;	author jra;	state Exp;
branches;
next	11.72.2.2;

11.72.2.2
date	2001.02.06.19.16.27;	author bparker;	state Exp;
branches;
next	;

11.108.2.1
date	2002.09.19.18.02.07;	author morrison;	state Exp;
branches;
next	;


desc
@Copy and print utilities.
@


11.111
log
@moved to src/mged/
@
text
@/*
 *			U T I L I T Y 2 . C
 *
 *
 *	f_pathsum()	gives various path summaries
 *	f_copyeval()	copy an evaluated solid
 *	f_push()	control routine to push transformations to bottom of paths
 *	f_showmats()	shows matrices along a path
 *
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <signal.h>
#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "rtgeom.h"
#include "nmg.h"
#include "raytrace.h"
#include "wdb.h"
#include "./ged.h"
#include "./sedit.h"
#include "./cmd.h"
#include "../librt/debug.h"	/* XXX */

int
f_eac(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int i,j;
	int item;
	struct directory *dp;
	struct bu_vls v;
	int new_argc;
	int lim;

	CHECK_DBI_NULL;

	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help eac");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	bu_vls_init( &v );

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else{
	  bu_vls_free( &v );
	  return TCL_OK;
	}

	bu_vls_strcat( &v, "e" );
	lim = 1;

	for( j=1; j<argc; j++)
	{
		item = atoi( argv[j] );
		if( item < 1 )
			continue;

		for( i = 0; i < RT_DBNHASH; i++ )
		{
			for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )
			{
				struct rt_db_internal intern;
				struct rt_comb_internal *comb;

				if( !(dp->d_flags & DIR_REGION) )
					continue;

				if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
					TCL_READ_ERR_return;
				comb = (struct rt_comb_internal *)intern.idb_ptr;
				if( comb->region_id != 0 ||
					comb->aircode != item )
				{
					rt_comb_ifree( &intern, &rt_uniresource );
					continue;
				}
				rt_comb_ifree( &intern, &rt_uniresource );

				bu_vls_strcat( &v, " " );
				bu_vls_strcat( &v, dp->d_namep );
				lim++;
			}
		}
	}

	if( lim > 1 )
	{
		int retval;
		char **new_argv;

		new_argv = (char **)bu_calloc( lim+1, sizeof( char *), "f_eac: new_argv" );
		new_argc = rt_split_cmd( new_argv, lim+1, bu_vls_addr( &v ) );
		retval = cmd_draw( clientData, interp, new_argc, new_argv );
		bu_free( (genptr_t)new_argv, "f_eac: new_argv" );
		bu_vls_free( &v );
		(void)signal( SIGINT, SIG_IGN );
		return retval;
	}
	else
	{
		bu_vls_free( &v );
		(void)signal( SIGINT, SIG_IGN );
		return TCL_OK;
	}
}
@


11.110
log
@change conf.h to a wrapped config.h
@
text
@@


11.109
log
@merge of ansi-6-0-branch into HEAD
@
text
@d12 5
a16 1
#include "conf.h"
@


11.108
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d37 1
a37 5
f_eac(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
@


11.108.2.1
log
@Initial ANSIfication
@
text
@d37 5
a41 1
f_eac(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.107
log
@Converted from K&R to ANSI C - RFH
@
text
@d37 5
a41 1
f_eac(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.106
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d37 1
a37 5
f_eac(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
@


11.105
log
@*- export more commands out of mged and into librt
*- modify mged to use the librt routines
@
text
@d33 1
d115 1
a115 1
		retval = f_edit( clientData, interp, new_argc, new_argv );
@


11.104
log
@*- add the following commands to MGED:
     adjust, attr, dbip, dump, form, get, match, put
@
text
@a34 198
extern struct bn_tol	mged_tol;	/* from ged.c */

int
f_shells(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	CHECK_DBI_NULL;

	return wdb_shells_cmd(wdbp, interp, argc, argv);
}

/*  	F _ P A T H S U M :   does the following
 *		1.  produces path for purposes of matching
 *      	2.  gives all paths matching the input path OR
 *		3.  gives a summary of all paths matching the input path
 *		    including the final parameters of the solids at the bottom
 *		    of the matching paths
 */
int
f_pathsum(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	int	ret;

	CHECK_DBI_NULL;

	if (argc < 2) {
		/* get the path */
		Tcl_AppendResult(interp, MORE_ARGS_STR,
				 "Enter the path: ", (char *)NULL);
		return TCL_ERROR;
	}

	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
        else
		return TCL_OK;

	ret = wdb_pathsum_cmd(wdbp, interp, argc, argv);

	(void)signal( SIGINT, SIG_IGN );
	return ret;
}

/*   	F _ C O P Y E V A L : copys an evaluated solid
 */

int
f_copyeval(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	int ret;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if (argc < 3) {
		Tcl_AppendResult(interp, MORE_ARGS_STR,
				 "Enter new_solid_name and full path to old_solid\n",
				 (char *)NULL);
		return TCL_ERROR;
	}

	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
        else
		return TCL_OK;

	ret = wdb_copyeval_cmd(wdbp, interp, argc, argv);

	(void)signal( SIGINT, SIG_IGN );
	return ret;
}


/*			F _ P U S H
 *
 * The push command is used to move matrices from combinations 
 * down to the solids. At some point, it is worth while thinking
 * about adding a limit to have the push go only N levels down.
 *
 * the -d flag turns on the treewalker debugging output.
 * the -P flag allows for multi-processor tree walking (not useful)
 * the -l flag is there to select levels even if it does not currently work.
 */
int
f_push(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	return wdb_push_cmd(wdbp, interp, argc, argv);
}

int
f_hide(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	return wdb_hide_cmd(wdbp, interp, argc, argv);
}

int
f_unhide(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	return wdb_unhide_cmd(wdbp, interp, argc, argv);
}

int
f_xpush(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_xpush_cmd(wdbp, interp, argc, argv);
}

int
f_showmats(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	CHECK_DBI_NULL;

	return wdb_showmats_cmd(wdbp, interp, argc, argv);
}

int
f_nmg_simplify(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char *argv[];
{
	CHECK_DBI_NULL;

	return wdb_nmg_simplify_cmd(wdbp, interp, argc, argv);
}

/*			F _ M A K E _ B B
 *
 *	Build an RPP bounding box for the list of objects and/or paths passed to this routine
 */

int
f_make_bb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	return wdb_make_bb_cmd(wdbp, interp, argc, argv);
}

int
f_whatid(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	CHECK_DBI_NULL;

	return wdb_whatid_cmd(wdbp, interp, argc, argv);
}

a125 38
}


int
f_edge_collapse( clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	char *av[3];

	CHECK_DBI_NULL;

	if (wdb_nmg_collapse_cmd(wdbp, interp, argc, argv) == TCL_ERROR)
		return TCL_ERROR;

	av[0] = "e";
	av[1] = argv[2];
	av[2] = NULL;

	return f_edit(clientData, interp, 2, av);
}

/*			F _ M A K E _ N A M E
 *
 * Generate an identifier that is guaranteed not to be the name
 * of any object currently in the database.
 *
 */
int
f_make_name(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	CHECK_DBI_NULL;
	return wdb_make_name_cmd(wdbp, interp, argc, argv);
@


11.103
log
@*- modified database commands to use new librt routines
@
text
@d338 1
a338 1
	if (wdb_edge_collapse_cmd(wdbp, interp, argc, argv) == TCL_ERROR)
@


11.102
log
@*- replace invoke_db_wrapper with calls
   to the new C API's for wdb_obj.
@
text
@a6 1
 *	trace()		traces hierarchy of objects
a7 2
 *	push()		pushes all transformations to solids at bottom of paths
 *	identitize()	makes all transformation matrices == identity for an object
a34 5
void		identitize();
void		trace();
void		matrix_print();
void		push();

a36 2
BU_EXTERN( struct rt_i *rt_new_rti, (struct db_i *dbip) );

a43 579
	struct directory *old_dp,*new_dp;
	struct rt_db_internal old_intern,new_intern;
	struct model *m_tmp,*m;
	struct nmgregion *r_tmp,*r;
	struct shell *s_tmp,*s;
	int shell_count=0;
	struct bu_vls shell_name;
	long **trans_tbl;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 2 || 2 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help shells");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( (old_dp = db_lookup( dbip,  argv[1], LOOKUP_NOISY )) == DIR_NULL )
	  return TCL_ERROR;

	if( rt_db_get_internal( &old_intern, old_dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )
	{
	  Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( old_intern.idb_type != ID_NMG )
	{
	  Tcl_AppendResult(interp, "Object is not an NMG!!!\n", (char *)NULL);
	  return TCL_ERROR;
	}

	m = (struct model *)old_intern.idb_ptr;
	NMG_CK_MODEL(m);

	bu_vls_init( &shell_name );
	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
	{
		for( BU_LIST_FOR( s, shell, &r->s_hd ) )
		{
			s_tmp = nmg_dup_shell( s, &trans_tbl, &mged_tol );
			bu_free( (genptr_t)trans_tbl, "trans_tbl" );

			m_tmp = nmg_mmr();
			r_tmp = BU_LIST_FIRST( nmgregion, &m_tmp->r_hd );

			BU_LIST_DEQUEUE( &s_tmp->l );
			BU_LIST_APPEND( &r_tmp->s_hd, &s_tmp->l );
			s_tmp->r_p = r_tmp;
			nmg_m_reindex( m_tmp, 0 );
			nmg_m_reindex( m, 0 );

			bu_vls_printf( &shell_name, "shell.%d", shell_count );
			while( db_lookup( dbip, bu_vls_addr( &shell_name ), 0 ) != DIR_NULL )
			{
				bu_vls_trunc( &shell_name, 0 );
				shell_count++;
				bu_vls_printf( &shell_name, "shell.%d", shell_count );
			}

			/* Export NMG as a new solid */
			RT_INIT_DB_INTERNAL(&new_intern);
			new_intern.idb_type = ID_NMG;
			new_intern.idb_meth = &rt_functab[ID_NMG];
			new_intern.idb_ptr = (genptr_t)m_tmp;

			if( (new_dp=db_diradd( dbip, bu_vls_addr( &shell_name ), -1, 0, DIR_SOLID, (genptr_t)&new_intern.idb_type)) == DIR_NULL )  {
			  TCL_ALLOC_ERR_return;
			}

			/* make sure the geometry/bounding boxes are up to date */
			nmg_rebound(m_tmp, &mged_tol);


			if( rt_db_put_internal( new_dp, dbip, &new_intern, &rt_uniresource ) < 0 )  {
				/* Free memory */
				nmg_km(m_tmp);
				Tcl_AppendResult(interp, "rt_db_put_internal() failure\n", (char *)NULL);
				return TCL_ERROR;
			}
			/* Internal representation has been freed by rt_db_put_internal */
			new_intern.idb_ptr = (genptr_t)NULL;

		}
	}
	bu_vls_free( &shell_name );
	return TCL_OK;
}

#define MAX_LEVELS 12
#define CPEVAL		0
#define LISTPATH	1
#define LISTEVAL	2

/* input path */
struct directory *obj[MAX_LEVELS];
int objpos;

/* print flag */
int prflag;

/* path transformation matrix ... calculated in trace() */
mat_t xform;

/*  	F _ P A T H S U M :   does the following
 *		1.  produces path for purposes of matching
 *      	2.  gives all paths matching the input path OR
 *		3.  gives a summary of all paths matching the input path
 *		    including the final parameters of the solids at the bottom
 *		    of the matching paths
 */
int
f_pathsum(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	int	ret;

	CHECK_DBI_NULL;

	if (argc < 2) {
		/* get the path */
		Tcl_AppendResult(interp, MORE_ARGS_STR,
				 "Enter the path: ", (char *)NULL);
		return TCL_ERROR;
	}

	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
        else
		return TCL_OK;

	ret = wdb_pathsum_cmd(wdbp, interp, argc, argv);

	(void)signal( SIGINT, SIG_IGN );
	return ret;
}

/*   	F _ C O P Y E V A L : copys an evaluated solid
 */

int
f_copyeval(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{

	struct directory *dp;
	struct rt_db_internal internal,new_int;
	mat_t	start_mat;
	int	id;
	int	i;
	int	endpos;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 1 || 27 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help copyeval");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( argc < 3 )
	{
	  Tcl_AppendResult(interp, MORE_ARGS_STR,
			   "Enter new_solid_name and full path to old_solid\n",
			   (char *)NULL);
	  return TCL_ERROR;
	}

	/* check if new solid name already exists in description */
	if( db_lookup( dbip, argv[1], LOOKUP_QUIET) != DIR_NULL )
	{
	  Tcl_AppendResult(interp, argv[1], ": already exists\n", (char *)NULL);
	  return TCL_ERROR;
	}

	MAT_IDN( start_mat );

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else
	  return TCL_OK;

	/* build directory pointer array for desired path */
	if( argc == 3 && strchr( argv[2], '/' ) )
	{
		char *tok;

		endpos = 0;

		tok = strtok( argv[2], "/" );
		while( tok )
		{
			if( (obj[endpos++] = db_lookup( dbip, tok, LOOKUP_NOISY )) == DIR_NULL)
			{
				(void)signal( SIGINT, SIG_IGN );
				return TCL_ERROR;
			}
			tok = strtok( (char *)NULL, "/" );
		}
	}
	else
	{
		for(i=2; i<argc; i++)
		{
		  if( (obj[i-2] = db_lookup( dbip, argv[i], LOOKUP_NOISY)) == DIR_NULL){
		    (void)signal( SIGINT, SIG_IGN );
		    return TCL_ERROR;
		  }
		}
		endpos = argc - 2;
	}

	objpos = endpos - 1;

	/* Make sure that final component in path is a solid */
	if( (id = rt_db_get_internal( &internal, obj[endpos - 1], dbip, identity, &rt_uniresource )) < 0 )
	{
	  Tcl_AppendResult(interp, "import failure on ",
			   argv[argc-1], "\n", (char *)NULL);
	  (void)signal( SIGINT, SIG_IGN );
	  return TCL_ERROR;
	}

	if( id >= ID_COMBINATION ) {
		rt_db_free_internal( &internal, &rt_uniresource );
		Tcl_AppendResult(interp, "final component on path must be a solid!!!\n", (char *)NULL );
		(void)signal( SIGINT, SIG_IGN );
		return TCL_ERROR;
	}

	trace(obj[0], 0, start_mat, CPEVAL);

	if(prflag == 0) {
	  Tcl_AppendResult(interp, "PATH:  ", (char *)NULL);

	  for(i=0; i<objpos; i++)
	    Tcl_AppendResult(interp, "/", obj[i]->d_namep, (char *)NULL);

	  Tcl_AppendResult(interp, "  NOT FOUND\n", (char *)NULL);
	  rt_db_free_internal( &internal, &rt_uniresource );
	  (void)signal( SIGINT, SIG_IGN );
	  return TCL_ERROR;
	}

	/* Have found the desired path - xform is the transformation matrix */
	/* xform matrix calculated in trace() */

	/* create the new solid */
	RT_INIT_DB_INTERNAL( &new_int );
	if( rt_generic_xform( &new_int, xform , &internal , 0, dbip, &rt_uniresource ) )
	{
	  rt_db_free_internal( &internal, &rt_uniresource );
	  Tcl_AppendResult(interp, "f_copyeval: rt_generic_xform failed\n", (char *)NULL);
	  (void)signal( SIGINT, SIG_IGN );
	  return TCL_ERROR;
	}

	if( (dp=db_diradd( dbip, argv[1], -1L, 0, obj[endpos-1]->d_flags, (genptr_t)&new_int.idb_type)) == DIR_NULL )  {
	  rt_db_free_internal( &internal, &rt_uniresource );
	  rt_db_free_internal( &new_int, &rt_uniresource );
	  (void)signal( SIGINT, SIG_IGN );
	  TCL_ALLOC_ERR_return;
	}

	if (rt_db_put_internal( dp, dbip, &new_int, &rt_uniresource ) < 0 )
	{
	  rt_db_free_internal( &internal, &rt_uniresource );
	  rt_db_free_internal( &new_int, &rt_uniresource );
	  (void)signal( SIGINT, SIG_IGN );
	  TCL_WRITE_ERR_return;
	}
	rt_db_free_internal( &internal, &rt_uniresource );
	rt_db_free_internal( &new_int, &rt_uniresource );

	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
}



/*	trace()		traces heirarchy of paths
 */

/* current path being traced */
extern struct directory *path[MAX_LEVELS];

HIDDEN void
Do_trace( dbip, comb, comb_leaf, user_ptr1, user_ptr2, user_ptr3 )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		user_ptr1, user_ptr2, user_ptr3;
{
	int			*pathpos;
	int			*flag;
	matp_t			old_xlate;
	mat_t			new_xlate;
	struct directory	*nextdp;

	RT_CK_DBI( dbip );
	RT_CK_TREE( comb_leaf );

	pathpos = (int *)user_ptr1;
	old_xlate = (matp_t)user_ptr2;
	flag = (int *)user_ptr3;

	if( comb_leaf->tr_l.tl_mat )  {
		bn_mat_mul( new_xlate, old_xlate, comb_leaf->tr_l.tl_mat );
	} else {
		MAT_COPY( new_xlate, old_xlate );
	}
	if( (nextdp = db_lookup( dbip, comb_leaf->tr_l.tl_name, LOOKUP_NOISY )) == DIR_NULL )
		return;

	trace( nextdp, (*pathpos)+1, new_xlate, *flag );
}

void
trace( dp, pathpos, old_xlate, flag)
register struct directory *dp;
int pathpos;
mat_t old_xlate;
int flag;
{
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	int i, k;
	int id;
	struct bu_vls str;

	if(dbip == DBI_NULL)
	  return;

	bu_vls_init( &str );

	if( pathpos >= MAX_LEVELS ) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "nesting exceeds %d levels\n",MAX_LEVELS);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);

	  for(i=0; i<MAX_LEVELS; i++)
	    Tcl_AppendResult(interp, "/", path[i]->d_namep, (char *)NULL);

	  Tcl_AppendResult(interp, "\n", (char *)NULL);
	  return;
	}

	if( dp->d_flags & DIR_COMB )
	{
		if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
			READ_ERR_return;

		path[pathpos] = dp;
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		if( comb->tree )
			db_tree_funcleaf( dbip, comb, comb->tree, Do_trace,
				(genptr_t)&pathpos, (genptr_t)old_xlate, (genptr_t)&flag );
		rt_comb_ifree( &intern, &rt_uniresource );
		return;
	}

	/* not a combination  -  should have a solid */

	/* last (bottom) position */
	path[pathpos] = dp;

	/* check for desired path */
	for(k=0; k<objpos; k++) {
		if(path[k]->d_addr != obj[k]->d_addr) {
			/* not the desired path */
			return;
		}
	}

	/* have the desired path up to objpos */
	MAT_COPY(xform, old_xlate);
	prflag = 1;

	if(flag == CPEVAL)
		return;

	/* print the path */
	for(k=0; k<pathpos; k++)
	  Tcl_AppendResult(interp, "/", path[k]->d_namep, (char *)NULL);

	if(flag == LISTPATH) {
	  bu_vls_printf( &str, "/%16s:\n", dp->d_namep );
	  Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
	  bu_vls_free(&str);
	  return;
	}

	/* NOTE - only reach here if flag == LISTEVAL */
	Tcl_AppendResult(interp, "/", (char *)NULL);
	if( (id=rt_db_get_internal( &intern, dp, dbip, xform, &rt_uniresource )) < 0 )
	{
		Tcl_AppendResult(interp, "rt_db_get_internal(", dp->d_namep,
                        ") failure", (char *)NULL );
		return;
	}
	bu_vls_printf( &str, "%16s:\n", dp->d_namep );
	if( rt_functab[id].ft_describe( &str, &intern, 1, base2local, &rt_uniresource ) < 0 )
		Tcl_AppendResult(interp, dp->d_namep, ": describe error\n", (char *)NULL);
	rt_db_free_internal( &intern, &rt_uniresource );
	Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
	bu_vls_free(&str);
}

/*
 *			M A T R I X _ P R I N T
 *
 * Print out the 4x4 matrix addressed by "m".
 */
void
matrix_print( m )
register matp_t m;
{
  register int i;
  struct bu_vls tmp_vls;

  bu_vls_init(&tmp_vls);

  for(i=0; i<16; i++) {
    if( (i+1)%4 )
      bu_vls_printf(&tmp_vls, "%f\t",m[i]);
    else if(i == 15)
      bu_vls_printf(&tmp_vls, "%f\n",m[i]);
    else
      bu_vls_printf(&tmp_vls, "%f\n",m[i]*base2local);
  }

  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
  bu_vls_free(&tmp_vls);
}


/* structure to hold all solids that have been pushed. */
struct push_id {
	long	magic;
	struct push_id *forw, *back;
	struct directory *pi_dir;
	mat_t	pi_mat;
};
#define MAGIC_PUSH_ID	0x50495323
struct push_id	pi_head;
#define FOR_ALL_PUSH_SOLIDS(p) \
	for( p=pi_head.forw; p!=&pi_head; p=p->forw)

static int push_error;

/*
 *		P U S H _ L E A F
 *
 * This routine must be prepared to run in parallel.
 *
 * This routine is called once for eas leaf (solid) that is to
 * be pushed.  All it does is build at push_id linked list.  The 
 * linked list could be handled by bu_list macros but it is simple
 * enough to do hear with out them.
 */
HIDDEN union tree *push_leaf( tsp, pathp, ip, client_data)
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
{
	union tree	*curtree;
	struct directory *dp;
	register struct push_id *pip;

	RT_CK_TESS_TOL(tsp->ts_ttol);
	BN_CK_TOL(tsp->ts_tol);
	RT_CK_DB_INTERNAL(ip);

	dp = pathp->fp_names[pathp->fp_len-1];

	if (rt_g.debug&DEBUG_TREEWALK) {
	  char *sofar = db_path_to_string(pathp);

	  Tcl_AppendResult(interp, "push_leaf(", ip->idb_meth->ft_name,
			   ") path='", sofar, "'\n", (char *)NULL);
	  bu_free((genptr_t)sofar, "path string");
	}
/*
 * XXX - This will work but is not the best method.  dp->d_uses tells us
 * if this solid (leaf) has been seen before.  If it hasn't just add
 * it to the list.  If it has, search the list to see if the matricies
 * match and do the "right" thing.
 *
 * (There is a question as to whether dp->d_uses is reset to zero
 *  for each tree walk.  If it is not, then d_uses is NOT a safe
 *  way to check and this method will always work.)
 */
	bu_semaphore_acquire((unsigned int)(RT_SEM_WORKER - BU_SEM_SYSCALL));
	FOR_ALL_PUSH_SOLIDS(pip) {
	  if (pip->pi_dir == dp ) {
	    if (!bn_mat_is_equal(pip->pi_mat,
				 tsp->ts_mat, tsp->ts_tol)) {
	      char *sofar = db_path_to_string(pathp);

	      Tcl_AppendResult(interp, "push_leaf: matrix mismatch between '", sofar,
			       "' and prior reference.\n", (char *)NULL);
	      bu_free((genptr_t)sofar, "path string");
	      push_error = 1;
	    }

	    bu_semaphore_release((unsigned int)(RT_SEM_WORKER - BU_SEM_SYSCALL));
	    BU_GETUNION(curtree, tree);
	    curtree->magic = RT_TREE_MAGIC;
	    curtree->tr_op = OP_NOP;
	    return curtree;
	  }
	}
/*
 * This is the first time we have seen this solid.
 */
	pip = (struct push_id *) bu_malloc(sizeof(struct push_id),
	    "Push ident");
	pip->magic = MAGIC_PUSH_ID;
	pip->pi_dir = dp;
	MAT_COPY(pip->pi_mat, tsp->ts_mat);
	pip->back = pi_head.back;
	pi_head.back = pip;
	pip->forw = &pi_head;
	pip->back->forw = pip;
	bu_semaphore_release((unsigned int)(RT_SEM_WORKER - BU_SEM_SYSCALL));
	BU_GETUNION(curtree, tree);
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;
	return curtree;
}
/*
 * A null routine that does nothing.
 */
HIDDEN union tree *push_region_end( tsp, pathp, curtree, client_data)
register struct db_tree_state *tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
{
	return curtree;
}

/*			F _ P U S H
 *
 * The push command is used to move matrices from combinations 
 * down to the solids. At some point, it is worth while thinking
 * about adding a limit to have the push go only N levels down.
 *
 * the -d flag turns on the treewalker debugging output.
 * the -P flag allows for multi-processor tree walking (not useful)
 * the -l flag is there to select levels even if it does not currently work.
 */
int
f_push(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
a44 941
	CHECK_READ_ONLY;

	return invoke_db_wrapper(interp, argc, argv);
}

int
f_hide(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	return invoke_db_wrapper(interp, argc, argv);
}

int
f_unhide(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	return invoke_db_wrapper(interp, argc, argv);
}

HIDDEN void
Do_identitize( dbip, comb, comb_leaf, user_ptr1, user_ptr2, user_ptr3 )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		user_ptr1, user_ptr2, user_ptr3;
{
	struct directory *dp;

	RT_CK_DBI( dbip );
	RT_CK_TREE( comb_leaf );

	/* NULL pointer signifies an identity matrix */
	if( comb_leaf->tr_l.tl_mat )  {
		bu_free( comb_leaf->tr_l.tl_mat, "tl_mat" );
		comb_leaf->tr_l.tl_mat = NULL;
	}
	if( (dp = db_lookup( dbip, comb_leaf->tr_l.tl_name, LOOKUP_NOISY )) == DIR_NULL )
		return;

	identitize( dp );
}

/*
 *			I D E N T I T I Z E ( ) 
 *
 *	Traverses an objects paths, setting all member matrices == identity
 *
 */
void
identitize( dp )
struct directory *dp;
{

	struct rt_db_internal intern;
	struct rt_comb_internal *comb;

	if(dbip == DBI_NULL)
	  return;

	if( dp->d_flags & DIR_SOLID )
		return;
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
		READ_ERR_return;
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	if( comb->tree )
	{
		db_tree_funcleaf( dbip, comb, comb->tree, Do_identitize,
			(genptr_t)NULL, (genptr_t)NULL, (genptr_t)NULL );
		if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
		{
			Tcl_AppendResult(interp, "Cannot write modified combination (", dp->d_namep,
				") to database\n", (char *)NULL );
			return;
		}
	}
	rt_db_free_internal( &intern, &rt_uniresource );
}

static void
increment_uses( db_ip, dp, ptr )
struct db_i *db_ip;
struct directory *dp;
genptr_t	ptr;
{
	RT_CK_DIR( dp );

	dp->d_uses++;
}

static void
increment_nrefs( db_ip, dp, ptr )
struct db_i *db_ip;
struct directory *dp;
genptr_t	ptr;
{
	RT_CK_DIR( dp );

	dp->d_nref++;
}

struct object_use
{
	struct bu_list	l;
	struct directory *dp;
	mat_t xform;
	int used;
};

static void
Free_uses( db_ip, dp, ptr )
struct db_i *db_ip;
struct directory *dp;
genptr_t	ptr;
{
	struct object_use *use;

	if(dbip == DBI_NULL)
	  return;

	RT_CK_DIR( dp );

	while( BU_LIST_NON_EMPTY( &dp->d_use_hd ) )
	{
		use = BU_LIST_FIRST( object_use, &dp->d_use_hd );
		if( !use->used )
		{
			/* never used, so delete directory entry.
			 * This could actually delete the original, buts that's O.K.
			 */
			db_dirdelete( dbip, use->dp );
		}

		BU_LIST_DEQUEUE( &use->l );
		bu_free( (genptr_t)use, "Free_uses: use" );
	}
}

static void
Make_new_name( db_ip, dp, ptr )
struct db_i *db_ip;
struct directory *dp;
genptr_t	ptr;
{
	struct object_use *use;
	int use_no;
	int digits;
	int suffix_start;
	int name_length;
	int j;
	char format_v4[25], format_v5[25];
	struct bu_vls name_v5;
	char name_v4[NAMESIZE];
	char *name;

	if(dbip == DBI_NULL)
	  return;

	/* only one use and not referenced elsewhere, nothing to do */
	if( dp->d_uses < 2 && dp->d_uses == dp->d_nref )
		return;

	/* check if already done */
	if( BU_LIST_NON_EMPTY( &dp->d_use_hd ) )
		return;

	digits = log10( (double)dp->d_uses ) + 2.0;
	sprintf( format_v5, "%%s_%%0%dd", digits );
	sprintf( format_v4, "_%%0%dd", digits );

	name_length = strlen( dp->d_namep );
	if( name_length + digits + 1 > NAMESIZE - 1 )
		suffix_start = NAMESIZE - digits - 2;
	else
		suffix_start = name_length;

	if( dbip->dbi_version >= 5 )
		bu_vls_init( &name_v5 );
	j = 0;
	for( use_no=0 ; use_no<dp->d_uses ; use_no++ )
	{
		j++;
		use = (struct object_use *)bu_malloc( sizeof( struct object_use ), "Make_new_name: use" );

		/* set xform for this object_use to all zeros */
		MAT_ZERO( use->xform );
		use->used = 0;
		if( dbip->dbi_version < 5 ) {
			NAMEMOVE( dp->d_namep, name_v4 );
			name_v4[NAMESIZE-1] = '\0';                /* ensure null termination */
		}

		/* Add an entry for the original at the end of the list
		 * This insures that the original will be last to be modified
		 * If original were modified earlier, copies would be screwed-up
		 */
		if( use_no == dp->d_uses-1 && dp->d_uses == dp->d_nref )
			use->dp = dp;
		else
		{
			if( dbip->dbi_version < 5 )
			{
				sprintf( &name_v4[suffix_start], format_v4, j );
				name = name_v4;
			}
			else
			{
				bu_vls_trunc( &name_v5, 0 );
				bu_vls_printf( &name_v5, format_v5, dp->d_namep, j );
				name = bu_vls_addr( &name_v5 );
			}

			/* Insure that new name is unique */
			while( db_lookup( dbip, name, 0 ) != DIR_NULL )
			{
				j++;
				if( dbip->dbi_version < 5 )
				{
					sprintf( &name_v4[suffix_start], format_v4, j );
					name = name_v4;
				}
				else
				{
					bu_vls_trunc( &name_v5, 0 );
					bu_vls_printf( &name_v5, format_v5, dp->d_namep, j );
					name = bu_vls_addr( &name_v5 );
				}
			}

			/* Add new name to directory */
			if( (use->dp = db_diradd( dbip, name, -1, 0, dp->d_flags, (genptr_t)&dp->d_minor_type )) == DIR_NULL )
			{
				ALLOC_ERR;
				return;
			}
		}

		/* Add new directory pointer to use list for this object */
		BU_LIST_INSERT( &dp->d_use_hd, &use->l );
	}
	if( dbip->dbi_version >= 5 )
		bu_vls_free( &name_v5 );
}

static struct directory *
Copy_solid( dp, xform )
struct directory *dp;
mat_t xform;
{
	struct directory *found;
	struct rt_db_internal sol_int;
	struct object_use *use;

	if(dbip == DBI_NULL)
	  return DIR_NULL;

	RT_CK_DIR( dp );

	if( !(dp->d_flags & DIR_SOLID) )
	{
	  Tcl_AppendResult(interp, "Copy_solid: ", dp->d_namep,
			   " is not a solid!!!!\n", (char *)NULL);
	  return( DIR_NULL );
	}

	/* If no transformation is to be applied, just use the original */
	if( bn_mat_is_identity( xform ) )
	{
		/* find original in the list */
		for( BU_LIST_FOR( use, object_use, &dp->d_use_hd ) )
		{
			if( use->dp == dp && use->used == 0 )
			{
				use->used = 1;
				return( dp );
			}
		}
	}

	/* Look for a copy that already has this transform matrix */
	for( BU_LIST_FOR( use, object_use, &dp->d_use_hd ) )
	{
		if( bn_mat_is_equal( xform, use->xform, &mged_tol ) )
		{
			/* found a match, no need to make another copy */
			use->used = 1;
			return( use->dp );
		}
	}

	/* get a fresh use */
	found = DIR_NULL;
	for( BU_LIST_FOR( use, object_use, &dp->d_use_hd ) )
	{
		if( use->used )
			continue;

		found = use->dp;
		use->used = 1;
		MAT_COPY( use->xform, xform );
		break;
	}

	if( found == DIR_NULL && dp->d_nref == 1 && dp->d_uses == 1 )
	{
		/* only one use, take it */
		found = dp;
	}

	if( found == DIR_NULL )
	{
	  Tcl_AppendResult(interp, "Ran out of uses for solid ",
			   dp->d_namep, "\n", (char *)NULL);
	  return( DIR_NULL );
	}

	if( rt_db_get_internal( &sol_int, dp, dbip, xform, &rt_uniresource ) < 0 )
	{
	  Tcl_AppendResult(interp, "Cannot import solid ",
			   dp->d_namep, "\n", (char *)NULL);
	  return( DIR_NULL );
	}

	RT_CK_DB_INTERNAL( &sol_int );
	if( rt_db_put_internal( found, dbip, &sol_int, &rt_uniresource ) < 0 )
	{
	  Tcl_AppendResult(interp, "Cannot write copy solid (", found->d_namep,
			   ") to database\n", (char *)NULL);
	  return( DIR_NULL );
	}

	return( found );
}

static struct directory *Copy_object();

HIDDEN void
Do_copy_membs( dbip, comb, comb_leaf, user_ptr1, user_ptr2, user_ptr3 )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		user_ptr1, user_ptr2, user_ptr3;
{
	struct directory	*dp;
	struct directory	*dp_new;
	mat_t			new_xform;
	matp_t			xform;

	RT_CK_DBI( dbip );
	RT_CK_TREE( comb_leaf );

	if( (dp=db_lookup( dbip, comb_leaf->tr_l.tl_name, LOOKUP_QUIET)) == DIR_NULL )
		return;

	xform = (matp_t)user_ptr1;

	/* apply transform matrix for this arc */
	if( comb_leaf->tr_l.tl_mat )  {
		bn_mat_mul( new_xform, xform, comb_leaf->tr_l.tl_mat );
	} else {
		MAT_COPY( new_xform, xform );
	}

	/* Copy member with current tranform matrix */
	if( (dp_new=Copy_object( dp, new_xform )) == DIR_NULL )
	{
	  Tcl_AppendResult(interp, "Failed to copy object ",
			   dp->d_namep, "\n", (char *)NULL);
	  return;
	}

	/* replace member name with new copy */
	bu_free( comb_leaf->tr_l.tl_name, "comb_leaf->tr_l.tl_name" );
	comb_leaf->tr_l.tl_name = bu_strdup( dp_new->d_namep );

	/* make transform for this arc the identity matrix */
	if( !comb_leaf->tr_l.tl_mat )  {
		comb_leaf->tr_l.tl_mat = (matp_t)bu_malloc( sizeof(mat_t), "tl_mat" );
	}
	MAT_IDN( comb_leaf->tr_l.tl_mat );
}

static struct directory *
Copy_comb( dp, xform )
struct directory *dp;
mat_t xform;
{
	struct object_use *use;
	struct directory *found;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;

	if(dbip == DBI_NULL)
	  return DIR_NULL;

	RT_CK_DIR( dp );

	/* Look for a copy that already has this transform matrix */
	for( BU_LIST_FOR( use, object_use, &dp->d_use_hd ) )
	{
		if( bn_mat_is_equal( xform, use->xform, &mged_tol ) )
		{
			/* found a match, no need to make another copy */
			use->used = 1;
			return( use->dp );
		}
	}

	/* if we can't get records for this combination, just leave it alone */
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
		return( dp );
	comb = (struct rt_comb_internal *)intern.idb_ptr;

	/* copy members */
	if( comb->tree )
		db_tree_funcleaf( dbip, comb, comb->tree, Do_copy_membs,
			(genptr_t)xform, (genptr_t)NULL, (genptr_t)NULL );

	/* Get a use of this object */
	found = DIR_NULL;
	for( BU_LIST_FOR( use, object_use, &dp->d_use_hd ) )
	{
		/* Get a fresh use of this object */
		if( use->used )
			continue;	/* already used */
		found = use->dp;
		use->used = 1;
		MAT_COPY( use->xform, xform );
		break;
	}

	if( found == DIR_NULL && dp->d_nref == 1 && dp->d_uses == 1 )
	{
		/* only one use, so take original */
		found = dp;
	}

	if( found == DIR_NULL )
	{
	  Tcl_AppendResult(interp, "Ran out of uses for combination ",
			   dp->d_namep, "\n", (char *)NULL);
	  return( DIR_NULL );
	}

	if( rt_db_put_internal( found, dbip, &intern, &rt_uniresource ) < 0 )
	{
		Tcl_AppendResult(interp, "rt_db_put_internal failed for ", dp->d_namep,
			"\n", (char *)NULL );
		rt_comb_ifree( &intern, &rt_uniresource );
		return( DIR_NULL );
	}

	return( found );
}

static struct directory *
Copy_object( dp, xform )
struct directory *dp;
mat_t xform;
{
	RT_CK_DIR( dp );

	if( dp->d_flags & DIR_SOLID )
		return( Copy_solid( dp, xform ) );
	else
		return( Copy_comb( dp, xform ) );
}

HIDDEN void
Do_ref_incr( dbip, comb, comb_leaf, user_ptr1, user_ptr2, user_ptr3 )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		user_ptr1, user_ptr2, user_ptr3;
{
	struct directory *dp;

	RT_CK_DBI( dbip );
	RT_CK_TREE( comb_leaf );

	if( (dp = db_lookup( dbip, comb_leaf->tr_l.tl_name, LOOKUP_QUIET)) == DIR_NULL )
		return;

	dp->d_nref++;
}

int
f_xpush(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	struct directory *old_dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	struct bu_ptbl tops;
	mat_t xform;
	int i;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 2 || 2 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help xpush");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* get directory pointer for arg */
	if( (old_dp = db_lookup( dbip,  argv[1], LOOKUP_NOISY )) == DIR_NULL )
	  return TCL_ERROR;

	/* Initialize use and reference counts of all directory entries */
	for( i=0 ; i<RT_DBNHASH ; i++ )
	{
		struct directory *dp;

		for( dp=dbip->dbi_Head[i] ; dp!=DIR_NULL ; dp=dp->d_forw )
		{
			if( !(dp->d_flags & ( DIR_SOLID | DIR_COMB ) ) )
				continue;

			dp->d_uses = 0;
			dp->d_nref = 0;
		}
	}

	/* Count uses in the tree being pushed (updates dp->d_uses) */
	db_functree( dbip, old_dp, increment_uses, increment_uses, &rt_uniresource, NULL );

	/* Do a simple reference count to find top level objects */
	for( i=0 ; i<RT_DBNHASH ; i++ )
	{
		struct directory *dp;

		for( dp=dbip->dbi_Head[i] ; dp!=DIR_NULL ; dp=dp->d_forw )
		{
			struct rt_db_internal intern;
			struct rt_comb_internal *comb;

			if( dp->d_flags & DIR_SOLID )
				continue;

			if( !(dp->d_flags & ( DIR_SOLID | DIR_COMB ) ) )
				continue;

			if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
				TCL_READ_ERR_return;
			comb = (struct rt_comb_internal *)intern.idb_ptr;
			if( comb->tree )
				db_tree_funcleaf( dbip, comb, comb->tree, Do_ref_incr, (genptr_t )NULL, (genptr_t )NULL, (genptr_t )NULL );
			rt_comb_ifree( &intern, &rt_uniresource );
		}
	}

	/* anything with zero references is a tree top */
	bu_ptbl_init( &tops, 0, "tops for xpush" );
	for( i=0 ; i<RT_DBNHASH ; i++ )
	{
		struct directory *dp;

		for( dp=dbip->dbi_Head[i] ; dp!=DIR_NULL ; dp=dp->d_forw )
		{
			if( dp->d_flags & DIR_SOLID )
				continue;

			if( !(dp->d_flags & ( DIR_SOLID | DIR_COMB ) ) )
				continue;

			if( dp->d_nref == 0 )
				bu_ptbl( &tops, BU_PTBL_INS, (long *)dp );
		}
	}

	/* now re-zero the reference counts */
	for( i=0 ; i<RT_DBNHASH ; i++ )
	{
		struct directory *dp;

		for( dp=dbip->dbi_Head[i] ; dp!=DIR_NULL ; dp=dp->d_forw )
		{
			if( !(dp->d_flags & ( DIR_SOLID | DIR_COMB ) ) )
				continue;

			dp->d_nref = 0;
		}
	}

	/* accurately count references in entire model */
	for( i=0 ; i<BU_PTBL_END( &tops ) ; i++ )
	{
		struct directory *dp;

		dp = (struct directory *)BU_PTBL_GET( &tops, i );
		db_functree( dbip, dp, increment_nrefs, increment_nrefs, &rt_uniresource, NULL );
	}

	/* Free list of tree-tops */
	bu_ptbl( &tops, BU_PTBL_FREE, (long *)NULL );

	/* Make new names */
	db_functree( dbip, old_dp, Make_new_name, Make_new_name, &rt_uniresource, NULL );

	MAT_IDN( xform );

	/* Make new objects */
	if( rt_db_get_internal( &intern, old_dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
	{
		bu_log( "ERROR: cannot load %s feom the database!!!\n", old_dp->d_namep );
		bu_log( "\tNothing has been changed!!\n" );
		db_functree( dbip, old_dp, Free_uses, Free_uses, &rt_uniresource, NULL );
		return TCL_ERROR;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	if( !comb->tree )
	{
		db_functree( dbip, old_dp, Free_uses, Free_uses, &rt_uniresource, NULL );
		return TCL_OK;
	}

	db_tree_funcleaf( dbip, comb, comb->tree, Do_copy_membs,
		(genptr_t)xform, (genptr_t)NULL, (genptr_t)NULL );

	if( rt_db_put_internal( old_dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		Tcl_AppendResult(interp, "rt_db_put_internal failed for ", old_dp->d_namep,
			"\n", (char *)NULL );
		rt_comb_ifree( &intern, &rt_uniresource );
		db_functree( dbip, old_dp, Free_uses, Free_uses, &rt_uniresource, NULL );
		return TCL_ERROR;
	}

	/* Free use lists and delete unused directory entries */
	db_functree( dbip, old_dp, Free_uses, Free_uses, &rt_uniresource, NULL );

	return TCL_OK;
}

HIDDEN void
Do_showmats( dbip, comb, comb_leaf, user_ptr1, user_ptr2, user_ptr3 )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		user_ptr1, user_ptr2, user_ptr3;
{
	matp_t	acc_matrix;
	int	*count;
	char	*child;

	RT_CK_DBI( dbip );
	RT_CK_TREE( comb_leaf );

	acc_matrix = (matp_t)user_ptr1;
	count = (int *)user_ptr2;
	child = (char *)user_ptr3;

	if( strcmp( comb_leaf->tr_l.tl_name, child ) )
		return;

	(*count)++;
	if( *count > 1 )
		bu_log( "\n\tOccurrence #%d:\n", *count );

	bn_mat_print( "", comb_leaf->tr_l.tl_mat );
	if( *count == 1 )
	{
		mat_t tmp_mat;
		if( comb_leaf->tr_l.tl_mat )  {
			bn_mat_mul( tmp_mat, acc_matrix, comb_leaf->tr_l.tl_mat );
			MAT_COPY( acc_matrix, tmp_mat );
		}
	}

}

int
f_showmats(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	char *parent;
	char *child;
	struct directory *dp;
	int max_count=1;
	mat_t acc_matrix;
	struct bu_vls tmp_vls;

	CHECK_DBI_NULL;

	if(argc < 2 || 2 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help showmats");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	bu_vls_init(&tmp_vls);
	MAT_IDN( acc_matrix );

	parent = strtok( argv[1], "/" );
	while( (child = strtok( (char *)NULL, "/" )) != NULL )
	{
		int count;
		struct rt_db_internal	intern;
		struct rt_comb_internal *comb;

		if( (dp = db_lookup( dbip, parent, LOOKUP_NOISY )) == DIR_NULL)
		  return TCL_ERROR;

		Tcl_AppendResult(interp, parent, "\n", (char *)NULL);

		if( !(dp->d_flags & DIR_COMB) )
		{
			Tcl_AppendResult( interp, "\tThis is not a combination\n", (char *)NULL );
			break;
		}

		if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
			TCL_READ_ERR_return;
		comb = (struct rt_comb_internal *)intern.idb_ptr;

		count = 0;

		start_catching_output(&tmp_vls);
		if( comb->tree )
			db_tree_funcleaf( dbip, comb, comb->tree, Do_showmats,
				(genptr_t)acc_matrix, (genptr_t)&count, (genptr_t)child );
		rt_comb_ifree( &intern, &rt_uniresource );
		stop_catching_output(&tmp_vls);
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);

		if( !count )
		{
		  Tcl_AppendResult(interp, child, " is not a member of ",
				   parent, "\n", (char *)NULL);
		  return TCL_ERROR;
		}
		if( count > max_count )
			max_count = count;

		parent = child;
	}
	Tcl_AppendResult(interp, parent, "\n", (char *)NULL);

	if( max_count > 1 )
	  Tcl_AppendResult(interp, "\nAccumulated matrix (using first occurrence of each object):\n", (char *)NULL);
	else
	  Tcl_AppendResult(interp, "\nAccumulated matrix:\n", (char *)NULL);

	start_catching_output(&tmp_vls);
	bn_mat_print( "", acc_matrix );
	stop_catching_output(&tmp_vls);
	Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	bu_vls_free(&tmp_vls);

	return TCL_OK;
}

int
f_nmg_simplify(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char *argv[];
{
	struct directory *dp;
	struct rt_db_internal nmg_intern;
	struct rt_db_internal new_intern;
	struct model *m;
	struct nmgregion *r;
	struct shell *s;
	int do_all=1;
	int do_arb=0;
	int do_tgc=0;
	int do_poly=0;
	char *new_name;
	char *nmg_name;
	int success = 0;
	int shell_count=0;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 3 || 4 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help nmg_simplify");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	RT_INIT_DB_INTERNAL( &new_intern );

	if( argc == 4 )
	{
		do_all = 0;
		if( !strncmp( argv[1], "arb", 3 ) )
			do_arb = 1;
		else if( !strncmp( argv[1], "tgc", 3 ) )
			do_tgc = 1;
		else if( !strncmp( argv[1], "poly", 4 ) )
			do_poly = 1;
		else
		{
		  Tcl_AppendResult(interp, "Usage: nmg_simplify [arb|ell|tgc|poly] new_solid_name nmg_solid\n", (char *)NULL);
		  return TCL_ERROR;
		}

		new_name = argv[2];
		nmg_name = argv[3];
	}
	else
	{
		new_name = argv[1];
		nmg_name = argv[2];
	}

	if( db_lookup( dbip, new_name, LOOKUP_QUIET) != DIR_NULL )
	{
	  Tcl_AppendResult(interp, new_name, " already exists\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( (dp=db_lookup( dbip, nmg_name, LOOKUP_QUIET)) == DIR_NULL )
	{
	  Tcl_AppendResult(interp, nmg_name, " does not exist\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( rt_db_get_internal( &nmg_intern, dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )
	{
	  Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( nmg_intern.idb_type != ID_NMG )
	{
	  Tcl_AppendResult(interp, nmg_name, " is not an NMG solid\n", (char *)NULL);
	  rt_db_free_internal( &nmg_intern, &rt_uniresource );
	  return TCL_ERROR;
	}

	m = (struct model *)nmg_intern.idb_ptr;
	NMG_CK_MODEL( m );

	/* count shells */
	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
	{
		for( BU_LIST_FOR( s, shell, &r->s_hd ) )
			shell_count++;
	}

	if( (do_arb || do_all) && shell_count == 1 )
	{
		struct rt_arb_internal arb_int;

		if( nmg_to_arb( m, &arb_int ) )
		{
			new_intern.idb_ptr = (genptr_t)(&arb_int);
			new_intern.idb_type = ID_ARB8;
			new_intern.idb_meth = &rt_functab[ID_ARB8];
			success = 1;
		}
		else if( do_arb )
		{
			/* see if we can get an arb by simplifying the NMG */

			r = BU_LIST_FIRST( nmgregion, &m->r_hd );
			s = BU_LIST_FIRST( shell, &r->s_hd );
			nmg_shell_coplanar_face_merge( s, &mged_tol, 1 );
			if( !nmg_kill_cracks( s ) )
			{
				(void) nmg_model_edge_fuse( m, &mged_tol );
				(void) nmg_model_edge_g_fuse( m, &mged_tol );
				(void) nmg_unbreak_region_edges( &r->l.magic );
				if( nmg_to_arb( m, &arb_int ) )
				{
					new_intern.idb_ptr = (genptr_t)(&arb_int);
					new_intern.idb_type = ID_ARB8;
					new_intern.idb_meth = &rt_functab[ID_ARB8];
					success = 1;
				}
			}
			if( !success )
			{
				rt_db_free_internal( &nmg_intern, &rt_uniresource );
				Tcl_AppendResult(interp, "Failed to construct an ARB equivalent to ",
						 nmg_name, "\n", (char *)NULL);
				return TCL_OK;
			}
		}
	}

	if( (do_tgc || do_all) && !success && shell_count == 1 )
	{
		struct rt_tgc_internal tgc_int;

		if( nmg_to_tgc( m, &tgc_int, &mged_tol ) )
		{
			new_intern.idb_ptr = (genptr_t)(&tgc_int);
			new_intern.idb_type = ID_TGC;
			new_intern.idb_meth = &rt_functab[ID_TGC];
			success = 1;
		}
		else if( do_tgc )
		{
		  rt_db_free_internal( &nmg_intern, &rt_uniresource );
		  Tcl_AppendResult(interp, "Failed to construct a TGC equivalent to ",
				   nmg_name, "\n", (char *)NULL);
		  return TCL_OK;
		}
	}

	/* see if we can get an arb by simplifying the NMG */
	if( (do_arb || do_all) && !success && shell_count == 1 )
	{
		struct rt_arb_internal arb_int;
d46 2
a47 24
		r = BU_LIST_FIRST( nmgregion, &m->r_hd );
		s = BU_LIST_FIRST( shell, &r->s_hd );
		nmg_shell_coplanar_face_merge( s, &mged_tol, 1 );
		if( !nmg_kill_cracks( s ) )
		{
			(void) nmg_model_edge_fuse( m, &mged_tol );
			(void) nmg_model_edge_g_fuse( m, &mged_tol );
			(void) nmg_unbreak_region_edges( &r->l.magic );
			if( nmg_to_arb( m, &arb_int ) )
			{
				new_intern.idb_ptr = (genptr_t)(&arb_int);
				new_intern.idb_type = ID_ARB8;
				new_intern.idb_meth = &rt_functab[ID_ARB8];
				success = 1;
			}
			else if( do_arb )
			{
			  rt_db_free_internal( &nmg_intern, &rt_uniresource );
			  Tcl_AppendResult(interp, "Failed to construct an ARB equivalent to ",
					   nmg_name, "\n", (char *)NULL);
			  return TCL_OK;
			}
		}
	}
d49 15
a63 3
	if( (do_poly || do_all) && !success )
	{
		struct rt_pg_internal *poly_int;
d65 1
a65 1
		poly_int = (struct rt_pg_internal *)bu_malloc( sizeof( struct rt_pg_internal ), "f_nmg_simplify: poly_int" );
d67 5
a71 13
		if( nmg_to_poly( m, poly_int, &mged_tol ) )
		{
			new_intern.idb_ptr = (genptr_t)(poly_int);
			new_intern.idb_type = ID_POLY;
			new_intern.idb_meth = &rt_functab[ID_POLY];
			success = 1;
		}
		else if( do_poly )
		{
		  rt_db_free_internal( &nmg_intern, &rt_uniresource );
		  Tcl_AppendResult(interp, nmg_name, " is not a closed surface, cannot make a polysolid\n", (char *)NULL);
		  return TCL_OK;
		}
d74 4
a77 4
	if( success )
	{
		r = BU_LIST_FIRST( nmgregion, &m->r_hd );
		s = BU_LIST_FIRST( shell, &r->s_hd );
d79 1
a79 3
		if( BU_LIST_NON_EMPTY( &s->lu_hd ) )
		  Tcl_AppendResult(interp, "wire loops in ", nmg_name,
				   " have been ignored in conversion\n", (char *)NULL);
d81 2
a82 27
		if( BU_LIST_NON_EMPTY( &s->eu_hd ) )
		  Tcl_AppendResult(interp, "wire edges in ", nmg_name,
				   " have been ignored in conversion\n", (char *)NULL);

		if( s->vu_p )
		  Tcl_AppendResult(interp, "Single vertexuse in shell of ", nmg_name,
				   " has been ignored in conversion\n", (char *)NULL);

		rt_db_free_internal( &nmg_intern, &rt_uniresource );

		if( (dp=db_diradd( dbip, new_name, -1L, 0, DIR_SOLID, (genptr_t)&new_intern.idb_type)) == DIR_NULL )
		{
			Tcl_AppendResult(interp, "Cannot add ", new_name, " to directory\n", (char *)NULL );
			return TCL_ERROR;
		}

		if( rt_db_put_internal( dp, dbip, &new_intern, &rt_uniresource ) < 0 )
		{
			rt_db_free_internal( &new_intern, &rt_uniresource );
			TCL_WRITE_ERR_return;
		}
		return TCL_OK;
	}

	Tcl_AppendResult(interp, "simplification to ", argv[1],
			 " is not yet supported\n", (char *)NULL);
	return TCL_ERROR;
d85 1
a85 3
/*			F _ M A K E _ B B
 *
 *	Build an RPP bounding box for the list of objects and/or paths passed to this routine
d89 1
a89 1
f_make_bb(clientData, interp, argc, argv)
d95 1
a95 6
	struct rt_i		*rtip;
	int			i;
	point_t			rpp_min,rpp_max;
	struct db_full_path	path;
	struct region		*regp;
	char			*new_name;
d100 5
a104 8
	if(argc < 3){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help make_bb");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
d107 4
a110 6
	/* Since arguments may be paths, make sure first argument isn't */
	if( strchr( argv[1], '/' ) )
	{
	  Tcl_AppendResult(interp, "Do not use '/' in solid names: ", argv[1], "\n", (char *)NULL);
	  return TCL_ERROR;
	}
d112 1
a112 6
	new_name = argv[1];
	if( db_lookup( dbip, new_name, LOOKUP_QUIET ) != DIR_NULL )
	{
	  Tcl_AppendResult(interp, new_name, " already exists\n", (char *)NULL);
	  return TCL_ERROR;
	}
d114 3
a116 7
	/* Make a new rt_i instance from the exusting db_i sructure */
	if( (rtip=rt_new_rti( dbip ) ) == RTI_NULL )
	{
	  Tcl_AppendResult(interp, "rt_new_rti failure for ", dbip->dbi_filename,
			   "\n", (char *)NULL);
	  return TCL_ERROR;
	}
a117 4
	/* Get trees for list of objects/paths */
	for( i=2 ; i<argc ; i++  )
	{
		int gottree;
d119 19
a137 10
		/* Get full_path structure for argument */
		db_full_path_init( &path );
		if( db_string_to_path( &path,  rtip->rti_dbip, argv[i] ) )
		{
			Tcl_AppendResult(interp, "db_string_to_path failed for ",
				argv[i], "\n", (char *)NULL );
			rt_clean( rtip );
			bu_free( (genptr_t)rtip, "f_make_bb: rtip" );
			return TCL_ERROR;
		}
d139 2
a140 4
		/* check if we alerady got this tree */
		gottree = 0;
		for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
			struct db_full_path tmp_path;
d142 9
a150 15
			db_full_path_init( &tmp_path );
			if( db_string_to_path( &tmp_path, rtip->rti_dbip, regp->reg_name ) )
			{
				Tcl_AppendResult(interp, "db_string_to_path failed for ",
					regp->reg_name, "\n", (char *)NULL );
				rt_clean( rtip );
				bu_free( (genptr_t)rtip, "f_make_bb: rtip" );
				return TCL_ERROR;
			}
			if( path.fp_names[0] == tmp_path.fp_names[0] )
				gottree = 1;
			db_free_full_path( &tmp_path );
			if( gottree )
				break;
		}
d152 2
a153 11
		/* if we don't already have it, get it */
		if( !gottree && rt_gettree( rtip, path.fp_names[0]->d_namep ) )
		{
			Tcl_AppendResult(interp, "rt_gettree failed for ",
				argv[i], "\n", (char *)NULL );
			rt_clean( rtip );
			bu_free( (genptr_t)rtip, "f_make_bb: rtip" );
			return TCL_ERROR;
		}
		db_free_full_path( &path );
	}
d155 9
a163 2
	/* prep calculates bounding boxes of solids */
	rt_prep( rtip );
d165 2
a166 32
	/* initialize RPP bounds */
	VSETALL( rpp_min, MAX_FASTF );
	VREVERSE( rpp_max, rpp_min );
	for( i=2 ; i<argc ; i++ )
	{
		vect_t reg_min, reg_max;
		struct region *regp;
		const char *reg_name;

		/* check if input name is a region */
		for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
			reg_name = regp->reg_name;
			if( *argv[i] != '/' && *reg_name == '/' )
				reg_name++;

			if( strcmp( reg_name, argv[i] ) )
				continue;

			/* Found match */
			/* input name was a region  */
			if( rt_bound_tree( regp->reg_treetop, reg_min, reg_max ) )
			{
				Tcl_AppendResult(interp, "rt_bound_tree failed for ",
					regp->reg_name, "\n", (char *)NULL );
				rt_clean( rtip );
				bu_free( (genptr_t)rtip, "f_make_bb: rtip" );
				return TCL_ERROR;
			}
			VMINMAX( rpp_min, rpp_max, reg_min );
			VMINMAX( rpp_min, rpp_max, reg_max );
			goto found;
		}
d168 7
a174 3
		/* Not found */
		{
			int name_len;
d176 2
a177 8
			/* input name may be a group, need to check all regions under
			 * that group
			 */
			name_len = strlen( argv[i] );
			for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
				reg_name = regp->reg_name;
				if( *argv[i] != '/' && *reg_name == '/' )
					reg_name++;
d179 8
a186 2
				if( strncmp( argv[i], reg_name, name_len ) )
					continue;
d188 2
a189 15
				/* This is part of the group */
				if( rt_bound_tree( regp->reg_treetop, reg_min, reg_max ) )
				{
					Tcl_AppendResult(interp, "rt_bound_tree failed for ",
						regp->reg_name, "\n", (char *)NULL );
					rt_clean( rtip );
					bu_free( (genptr_t)rtip, "f_make_bb: rtip" );
					return TCL_ERROR;
				}
				VMINMAX( rpp_min, rpp_max, reg_min );
				VMINMAX( rpp_min, rpp_max, reg_max );
			}
		}
found:	;
	}
d191 8
a198 1
	rt_free_rti( rtip );
d200 2
a201 5
	/* build bounding RPP solid */
	if( mk_rpp( wdbp, new_name, rpp_min, rpp_max ) < 0 )  {
		Tcl_AppendResult(interp, "Cannot add ", new_name, " to database\n", (char *)NULL );
		return TCL_ERROR;
	}
d203 4
a206 3
	/* use "e" command to get new solid displayed */
	{
	  char *av[3];
d208 9
a216 3
	  av[0] = "e";
	  av[1] = new_name;
	  av[2] = NULL;
d218 1
a218 2
	  return f_edit( clientData, interp, 2, av );
	}
d230 1
a230 1
	return invoke_db_wrapper(interp, argc, argv);
d334 1
a334 8
	char *new_name;
	struct model *m;
	struct rt_db_internal intern;
	struct directory *dp;
	long count;
	char count_str[32];
	fastf_t tol_coll;
	fastf_t min_angle;
a336 74
	CHECK_READ_ONLY;

	if(argc < 5){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help nmg_collapse");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( strchr( argv[2], '/' ) )
	{
	  Tcl_AppendResult(interp, "Do not use '/' in solid names: ", argv[2], "\n", (char *)NULL);
	  return TCL_ERROR;
	}

	new_name = argv[2];
	
	if( db_lookup( dbip, new_name, LOOKUP_QUIET ) != DIR_NULL )
	{
	  Tcl_AppendResult(interp, new_name, " already exists\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( (dp=db_lookup( dbip, argv[1], LOOKUP_NOISY )) == DIR_NULL )
		return TCL_ERROR;

	if( dp->d_flags & DIR_COMB )
	{
		Tcl_AppendResult(interp, argv[1], " is a combination, only NMG solids are allowed here\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL, &rt_uniresource ) < 0 )
	{
		Tcl_AppendResult(interp, "Failed to get internal form of ", argv[1], "!!!!\n", (char *)NULL);
		return TCL_ERROR;
	}

	if( intern.idb_type != ID_NMG )
	{
		Tcl_AppendResult(interp, argv[1], " is not an NMG solid!!!!\n", (char *)NULL );
		rt_db_free_internal( &intern, &rt_uniresource );
		return TCL_ERROR;
	}

	tol_coll = atof( argv[3] ) * local2base;
	if( tol_coll <= 0.0 )
	{
		Tcl_AppendResult(interp, "tolerance distance too small\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( argc == 5 )
	{
		min_angle = atof( argv[4] );
		if( min_angle < 0.0 )
		{
			Tcl_AppendResult(interp, "Minimum angle cannot be less than zero\n", (char *)NULL );
			return TCL_ERROR;
		}
	}
	else
		min_angle = 0.0;

	m = (struct model *)intern.idb_ptr;
	NMG_CK_MODEL( m );

	/* triangulate model */
	nmg_triangulate_model( m, &mged_tol );

	count = nmg_edge_collapse( m, &mged_tol, tol_coll, min_angle );
d338 1
a338 4
	if( (dp=db_diradd( dbip, new_name, -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", new_name, " to directory\n", (char *)NULL );
		rt_db_free_internal( &intern, &rt_uniresource );
a339 20
	}

	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		rt_db_free_internal( &intern, &rt_uniresource );
		TCL_WRITE_ERR_return;
	}

	rt_db_free_internal( &intern, &rt_uniresource );

	sprintf( count_str, "%ld", count );
	Tcl_AppendResult(interp, count_str, " edges collapsed\n", (char *)NULL );

	/* use "e" command to get new solid displayed */
	{
	  char *av[3];

	  av[0] = "e";
	  av[1] = new_name;
	  av[2] = NULL;
d341 3
a343 2
	  return f_edit( clientData, interp, 2, av );
	}
d345 1
d355 4
a358 7
f_make_name(clientData, interp, argc, argv)

ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;

d360 2
a361 66
    struct bu_vls	obj_name;
    char		*cp, *tp;
    static int		i = 0;
    int			len;

    CHECK_DBI_NULL;

    switch (argc)
    {
	case 2:
	    if (strcmp(argv[1], "-s") != 0)
		break;
	    else
	    {
		i = 0;
		return TCL_OK;
	    }
	case 3:
	{
	    int		new_i;

	    if ((strcmp(argv[1], "-s") == 0)
	     && (sscanf(argv[2], "%d", &new_i) == 1))
	    {
		i = new_i;
		return TCL_OK;
	    }
	}
	default:
	{
	    struct bu_vls	vls;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "helpdevel make_name");
	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	    return TCL_ERROR;
	}
    }

    bu_vls_init(&obj_name);
    for (cp = argv[1], len = 0; (*cp != '\0'); ++cp, ++len)
    {
	if (*cp == '@@')  {
	    if (*(cp + 1) == '@@')  {
		++cp;
	    } else {
		break;
	    }
	}
	bu_vls_putc(&obj_name, *cp);
    }
    bu_vls_putc(&obj_name, '\0');
    tp = (*cp == '\0') ? ""
		       : cp + 1;

    do
    {
	bu_vls_trunc(&obj_name, len);
	bu_vls_printf(&obj_name, "%d", i++);
	bu_vls_strcat(&obj_name, tp);
    }
    while (db_lookup(dbip, bu_vls_addr(&obj_name), LOOKUP_QUIET) != DIR_NULL);
    Tcl_AppendResult(interp, bu_vls_addr(&obj_name), (char *) NULL);
    bu_vls_free(&obj_name);
    return TCL_OK;
@


11.101
log
@updated SIGNED to signed
updated CONST to const
@
text
@d193 1
a193 1
	ret = invoke_db_wrapper(interp, argc, argv);
@


11.100
log
@"copyeval" now works with database v5
@
text
@d1773 1
a1773 1
		CONST char *reg_name;
@


11.99
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@a210 1
	struct bu_external external,new_ext;
d282 2
d285 1
a285 2
	BU_INIT_EXTERNAL( &external );
	if( db_get_external( &external , obj[endpos-1] , dbip ) )
d287 2
a288 11
	  db_free_external( &external );
	  (void)signal( SIGINT, SIG_IGN );
	  TCL_READ_ERR_return;
	}
	BU_CK_EXTERNAL( &external );

	if( (id=rt_id_solid( &external )) == ID_NULL )
	{
	  Tcl_AppendResult(interp, "Final name in full path must be a solid, ",
			   argv[argc-1], " is not a solid\n", (char *)NULL);
	  db_free_external( &external );
d293 5
a297 8
	RT_INIT_DB_INTERNAL( &internal );
	if( rt_functab[id].ft_import( &internal, &external, identity, dbip, &rt_uniresource ) < 0 )
	{
	  Tcl_AppendResult(interp, "solid import failure on ",
			   argv[argc-1], "\n", (char *)NULL);
	  db_free_external( &external );
	  (void)signal( SIGINT, SIG_IGN );
	  return TCL_ERROR;
d309 1
a309 1
	  db_free_external( &external );
d321 1
a321 1
	  db_free_external( &external );
a326 10
	if( rt_functab[id].ft_export( &new_ext , &new_int , 1.0, dbip, &rt_uniresource ) )
	{
	  db_free_external( &new_ext );
	  db_free_external( &external );
	  Tcl_AppendResult(interp, "f_copyeval: export failure for new solid\n",
			   (char *)NULL);
	  (void)signal( SIGINT, SIG_IGN );
	  return TCL_ERROR;
	}

d328 2
a329 2
	  db_free_external( &new_ext );
	  db_free_external( &external );
d334 1
a334 1
	if (db_put_external( &new_ext, dp, dbip ) < 0 )
d336 2
a337 2
	  db_free_external( &new_ext );
	  db_free_external( &external );
d341 2
a342 2
	db_free_external( &external );
	db_free_external( &new_ext );
@


11.98
log
@Added "hide" and "unhide" comands
@
text
@d401 1
a401 1
		bn_mat_copy( new_xlate, old_xlate );
d470 1
a470 1
	bn_mat_copy(xform, old_xlate);
d615 1
a615 1
	bn_mat_copy(pip->pi_mat, tsp->ts_mat);
d966 1
a966 1
		bn_mat_copy( use->xform, xform );
d1027 1
a1027 1
		bn_mat_copy( new_xform, xform );
d1094 1
a1094 1
		bn_mat_copy( use->xform, xform );
d1341 1
a1341 1
			bn_mat_copy( acc_matrix, tmp_mat );
@


11.97
log
@Lint
@
text
@a198 2


d650 26
@


11.96
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@a638 44
/*
 * The tree walker neds to have an initial state.  We could
 * steal it from doview.c but there is no real reason.
 */

static struct db_tree_state push_initial_tree_state = {
	RT_DBTS_MAGIC,		/* magic */
	0,			/* ts_dbip */
	0,			/* ts_sofar */
	0,0,0,			/* region, air, gmater */
	100,			/* GIFT los */
#if __STDC__
	{
#endif
		/* struct mater_info ts_mater */
		{1.0, 0.0, 0.0},	/* color, RGB */
		-1.0,		/* Temperature */
		0,		/* override */
		0,		/* color inherit */
		0,		/* mater inherit */
#if 0
		""		/* shader */
#else
		NULL		/* shader */
#endif
#if __STDC__
	}
#endif
	,
	{1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0},
	REGION_NON_FASTGEN,		/* ts_is_fastgen */
	0,				/* ts_stop_at_regions */
	NULL,				/* ts_region_start_func */
	NULL,				/* ts_region_end_func */
	NULL,				/* ts_leaf_func */
	NULL,				/* ts_ttol */
	NULL,				/* ts_tol */
	NULL,				/* ts_m */
	NULL,				/* ts_rtip */
	NULL				/* ts_resp */
};
@


11.95
log
@*- modify f_pathsum to use the one in LIBRT
@
text
@d248 1
a248 1
	bn_mat_idn( start_mat );
d872 1
a872 1
		bn_mat_zero( use->xform );
d1066 1
a1066 1
	bn_mat_idn( comb_leaf->tr_l.tl_mat );
d1295 1
a1295 1
	bn_mat_idn( xform );
@


11.94
log
@*- check-in #if'd out unfinished work from tgm/offsite
@
text
@a176 1
#if 0
a196 96
#else
	int i, flag, pos_in;

	CHECK_DBI_NULL;

	if(argc < 1){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help %s", argv[0]);
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* pos_in = first member of path entered
	 *
	 *	paths are matched up to last input member
	 *      ANY path the same up to this point is considered as matching
	 */
	prflag = 0;

	/* find out which command was entered */
	if( strcmp( argv[0], "paths" ) == 0 ) {
		/* want to list all matching paths */
		flag = LISTPATH;
	} else if( strcmp( argv[0], "listeval" ) == 0 ) {
		/* want to list evaluated solid[s] */
		flag = LISTEVAL;
	} else {
		bu_log("f_pathsum() name=%s?\n", argv[0]);
		flag = 0;
	}

	if( argc < 2 )  {
		/* get the path */
	  Tcl_AppendResult(interp, MORE_ARGS_STR,
			   "Enter the path: ", (char *)NULL);
	  return TCL_ERROR;
	}

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else
	  return TCL_OK;

	pos_in = 1;

	if( argc == 2 && strchr( argv[1], '/' ) )
	{
		char *tok;
		objpos = 0;

		tok = strtok( argv[1], "/" );
		while( tok )
		{
			if( (obj[objpos++] = db_lookup( dbip, tok, LOOKUP_NOISY )) == DIR_NULL)
			{
				(void)signal( SIGINT, SIG_IGN );
				return TCL_ERROR;
			}
			tok = strtok( (char *)NULL, "/" );
		}
	}
	else
	{
		objpos = argc-1;

		/* build directory pointer array for desired path */
		for(i=0; i<objpos; i++) {
		  if( (obj[i] = db_lookup( dbip, argv[pos_in+i], LOOKUP_NOISY )) == DIR_NULL){
		    (void)signal( SIGINT, SIG_IGN );
		    return TCL_ERROR;
		  }
		}
	}

#if 0
	bn_mat_idn(identity);
#endif
	bn_mat_idn( xform );

	trace(obj[0], 0, identity, flag);

	if(prflag == 0) {
	  /* path not found */
	  Tcl_AppendResult(interp, "PATH:  ", (char *)NULL);
	  for(i=0; i<objpos; i++)
	    Tcl_AppendResult(interp, "/", obj[i]->d_namep, (char *)NULL);

	  Tcl_AppendResult(interp, "  NOT FOUND\n", (char *)NULL);
	}

	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
#endif
@


11.93
log
@Support for major and minor types in directory structure
@
text
@d177 22
d293 1
@


11.92
log
@*- convert f_push to use LIBRT's wdb_push_tcl via
   invoke_db_wrapper
@
text
@d119 7
a125 1
			if( (new_dp=db_diradd( dbip, bu_vls_addr( &shell_name ), -1, 0, DIR_SOLID, NULL)) == DIR_NULL )  {
a132 6
			/* Export NMG as a new solid */
			RT_INIT_DB_INTERNAL(&new_intern);
			new_intern.idb_type = ID_NMG;
			new_intern.idb_meth = &rt_functab[ID_NMG];
			new_intern.idb_ptr = (genptr_t)m_tmp;

d425 1
a425 1
	if( (dp=db_diradd( dbip, argv[1], -1L, 0, obj[endpos-1]->d_flags, NULL)) == DIR_NULL )  {
d991 1
a991 1
			if( (use->dp = db_diradd( dbip, name, -1, 0, dp->d_flags, NULL )) == DIR_NULL )
d1757 1
a1757 1
		if( (dp=db_diradd( dbip, new_name, -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )
d2165 1
a2165 1
	if( (dp=db_diradd( dbip, new_name, -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )
@


11.91
log
@*- remove old code from f_whatid
@
text
@a774 14
	int	ncpu;
	int	c;
	int	old_debug;
#if 0
	int	levels;	/* XXX levels option on push command not yet implemented */
#endif
	extern 	int bu_optind;
	extern	char *bu_optarg;
	extern	struct bn_tol	mged_tol;	/* from ged.c */
	extern	struct rt_tess_tol mged_ttol;
	int	i;
	struct push_id *pip;
	struct rt_db_internal	intern;

d778 1
a778 132
	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help push");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	RT_CHECK_DBI(dbip);

	old_debug = rt_g.debug;
	pi_head.magic = MAGIC_PUSH_ID;
	pi_head.forw = pi_head.back = &pi_head;
	pi_head.pi_dir = (struct directory *) 0;

	/* Initial values for options, must be reset each time */
	ncpu = 1;

	/* Parse options */
	bu_optind = 1;	/* re-init bu_getopt() */
	while ( (c=bu_getopt(argc, argv, "l:P:d")) != EOF) {
		switch(c) {
		case 'l':
#if 0
			levels=atoi(bu_optarg);
#endif
			break;
		case 'P':
			ncpu = atoi(bu_optarg);
			if (ncpu<1) ncpu = 1;
			break;
		case 'd':
			rt_g.debug |= DEBUG_TREEWALK;
			break;
		case '?':
		default:
		  Tcl_AppendResult(interp, "push: usage push [-l levels] [-P processors] [-d] root [root2 ...]\n", (char *)NULL);
			break;
		}
	}

	argc -= bu_optind;
	argv += bu_optind;

	push_error = 0;

	push_initial_tree_state.ts_ttol = &mged_ttol;
	push_initial_tree_state.ts_tol  = &mged_tol;
	mged_ttol.magic = RT_TESS_TOL_MAGIC;
	mged_ttol.abs = mged_abs_tol;
	mged_ttol.rel = mged_rel_tol;
	mged_ttol.norm = mged_nrm_tol;

	/*
	 * build a linked list of solids with the correct
	 * matrix to apply to each solid.  This will also
	 * check to make sure that a solid is not pushed in two
	 * different directions at the same time.
	 */
	i = db_walk_tree( dbip, argc, (CONST char **)argv,
	    ncpu,
	    &push_initial_tree_state,
	    0,				/* take all regions */
	    push_region_end,
	    push_leaf, (genptr_t)NULL );

	/*
	 * If there was any error, then just free up the solid
	 * list we just built.
	 */
	if ( i < 0 || push_error ) {
		while (pi_head.forw != &pi_head) {
			pip = pi_head.forw;
			pip->forw->back = pip->back;
			pip->back->forw = pip->forw;
			bu_free((genptr_t)pip, "Push ident");
		}
		rt_g.debug = old_debug;
		Tcl_AppendResult(interp, "push:\tdb_walk_tree failed or there was a solid moving\n\tin two or more directions\n", (char *)NULL);
		return TCL_ERROR;
	}
	/*
	 * We've built the push solid list, now all we need to do is apply
	 * the matrix we've stored for each solid.
	 */
	FOR_ALL_PUSH_SOLIDS(pip) {
		if (rt_db_get_internal( &intern, pip->pi_dir, dbip, pip->pi_mat, &rt_uniresource ) < 0 )  {
		  Tcl_AppendResult(interp, "f_push: Read error fetching '",
				   pip->pi_dir->d_namep, "'\n", (char *)NULL);
		  push_error = -1;
		  continue;
		}
		RT_CK_DB_INTERNAL( &intern );

		if (rt_db_put_internal( pip->pi_dir, dbip, &intern, &rt_uniresource ) < 0)  {
		  Tcl_AppendResult(interp, "push(", pip->pi_dir->d_namep,
				   "): solid export failure\n", (char *)NULL);
		}
		rt_db_free_internal( &intern, &rt_uniresource );
	}

	/*
	 * Now use the identitize() tree walker to turn all the
	 * matricies in a combination to the identity matrix.
	 * It would be nice to use db_tree_walker() but the tree
	 * walker does not give us all combinations, just regions.
	 * This would work if we just processed all matricies backwards
	 * from the leaf (solid) towards the root, but all in all it
	 * seems that this is a better method.
	 */

	while (argc > 0) {
		struct directory *db;
		db = db_lookup(dbip, *argv++, 0);
		if (db) identitize(db);
		--argc;
	}

	/*
	 * Free up the solid table we built.
	 */
	while (pi_head.forw != &pi_head) {
		pip = pi_head.forw;
		pip->forw->back = pip->back;
		pip->back->forw = pip->forw;
		bu_free((genptr_t)pip, "Push ident");
	}

	rt_g.debug = old_debug;
	return push_error ? TCL_ERROR : TCL_OK;
@


11.90
log
@*- mods to use invoke_db_wrapper
@
text
@a2120 1
#if 1
a2121 8
#else
	bu_vls_init(&vls);
	bu_build_cmd_vls(&vls, MGED_DB_NAME, argc, argv);
	ret = Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return ret;
#endif
@


11.89
log
@*- modifiy f_whatid to use LIBRT's wdb_whatid_tcl method
@
text
@a2118 3
	int		ret;
	struct bu_vls	vls;

d2121 3
d2130 1
@


11.88
log
@*- free vls in f_make_name
@
text
@d2119 2
a2120 4
	struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	char id[10];
d2124 4
a2127 2
	if(argc < 2){
	  struct bu_vls vls;
d2129 1
a2129 24
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help whatid");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( (dp=db_lookup( dbip, argv[1], LOOKUP_NOISY )) == DIR_NULL )
		return TCL_ERROR;

	if( !( dp->d_flags & DIR_REGION ) )
	{
		Tcl_AppendResult(interp, argv[1], " is not a region\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
		return TCL_ERROR;
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	sprintf( id, "%d\n", comb->region_id );
	rt_comb_ifree( &intern, &rt_uniresource );
	Tcl_AppendResult(interp, id, (char *)NULL );

	return TCL_OK;
@


11.87
log
@Mods to handle unlimited name lengths
@
text
@d2451 1
@


11.86
log
@
Possible uninit
@
text
@d60 1
a60 1
	char shell_name[NAMESIZE];
d94 1
d111 2
a112 2
			sprintf( shell_name, "shell.%d", shell_count );
			while( db_lookup( dbip, shell_name, 0 ) != DIR_NULL )
d114 1
d116 1
a116 1
				sprintf( shell_name, "shell.%d", shell_count );
d119 1
a119 1
			if( (new_dp=db_diradd( dbip, shell_name, -1, 0, DIR_SOLID, NULL)) == DIR_NULL )  {
d144 1
a144 1

d1056 4
a1059 2
	char format[25];
	char name[NAMESIZE];
d1073 2
a1074 1
	sprintf( format, "_%%0%dd", digits );
d1082 2
d1093 4
a1096 2
		NAMEMOVE( dp->d_namep, name );
		name[NAMESIZE-1] = '\0';                /* ensure null termination */
d1106 11
a1116 1
			sprintf( &name[suffix_start], format, j );
d1122 11
a1132 1
				sprintf( &name[suffix_start], format, j );
d1146 2
d1173 11
a1183 1
		return( dp );
d1196 1
a1197 1
	/* get a fresh use */
d1567 1
a1567 1
	if( strncmp( comb_leaf->tr_l.tl_name, child, NAMESIZE ) )
@


11.85
log
@
Fixed compiler lint, function declarations.
@
text
@d200 1
a200 2
	}
	if( strcmp( argv[0], "listeval" ) == 0 ) {
d203 3
@


11.84
log
@
lint
@
text
@d30 1
a32 1
#include "rtgeom.h"
d403 1
a403 1
	if( rt_generic_xform( &new_int, xform , &internal , 0 ) )
@


11.83
log
@Modified xpush to be better aware of entire model (also, it now ignores all non-geometry objects)
@
text
@a1124 1
	int id;
d1179 1
a1179 1
	if( (id=rt_db_get_internal( &sol_int, dp, dbip, xform, &rt_uniresource )) < 0 )
@


11.82
log
@Added needed resource pointers to db_functree calls
@
text
@a981 27
zero_dp_counts( db_ip, dp, ptr )
struct db_i *db_ip;
struct directory *dp;
genptr_t	ptr;
{
  Tcl_Interp	*interp = (Tcl_Interp *)ptr;
  RT_CK_DIR( dp );

  dp->d_nref = 0;
  dp->d_uses = 0;

  if( BU_LIST_NON_EMPTY( &dp->d_use_hd ) )
    Tcl_AppendResult(interp, "List for ", dp->d_namep, " is not empty\n", (char *)NULL);
}

static void
zero_nrefs( db_ip, dp, ptr )
struct db_i *db_ip;
struct directory *dp;
genptr_t	ptr;
{
	RT_CK_DIR( dp );

	dp->d_nref = 0;
}

static void
d1091 1
a1091 1
		if( use_no == dp->d_uses-1 )
d1139 4
a1187 1

d1358 2
d1381 14
a1394 2
	/* initialize use and reference counts */
	db_functree( dbip, old_dp, zero_dp_counts, zero_dp_counts, &rt_uniresource, (genptr_t)interp );
d1396 1
a1396 1
	/* Count uses */
d1399 1
a1399 2
	/* Get list of tree tops in this model */
	bu_ptbl( &tops, BU_PTBL_INIT, (long *)NULL );
d1424 2
d1443 2
a1444 2
	/* zero nrefs in entire model */
	for( i=0 ; i<BU_PTBL_END( &tops ) ; i++ )
d1448 7
a1454 2
		dp = (struct directory *)BU_PTBL_GET( &tops, i );
		db_functree( dbip, dp, zero_nrefs, zero_nrefs, &rt_uniresource, NULL );
d1457 1
a1457 1
	/* count references in entire model */
d1475 25
a1499 1
	(void) Copy_object( old_dp, xform );
@


11.81
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@a1149 1
	struct bu_external sol_ext;
d1203 1
a1203 13
	BU_INIT_EXTERNAL( &sol_ext );

	if( db_get_external( &sol_ext, dp, dbip ) < 0 )
	{
	  Tcl_AppendResult(interp, "Cannot get external form of ",
			   dp->d_namep, "\n", (char *)NULL);
	  return( DIR_NULL );
	}

	RT_INIT_DB_INTERNAL( &sol_int );

	id = rt_id_solid( &sol_ext );
	if( rt_functab[id].ft_import( &sol_int, &sol_ext, xform, dbip, &rt_uniresource ) < 0 )
d1404 1
a1404 1
	db_functree( dbip, old_dp, zero_dp_counts, zero_dp_counts, (genptr_t)interp );
d1407 1
a1407 1
	db_functree( dbip, old_dp, increment_uses, increment_uses, NULL );
d1423 3
d1444 3
d1458 1
a1458 1
		db_functree( dbip, dp, zero_nrefs, zero_nrefs, NULL );
d1467 1
a1467 1
		db_functree( dbip, dp, increment_nrefs, increment_nrefs, NULL );
d1474 1
a1474 1
	db_functree( dbip, old_dp, Make_new_name, Make_new_name, NULL );
d1482 1
a1482 1
	db_functree( dbip, old_dp, Free_uses, Free_uses, NULL );
@


11.80
log
@
Tree routines now need resource structure.
@
text
@d568 1
a568 1
	if( rt_functab[id].ft_describe( &str, &intern, 1, base2local ) < 0 )
d715 1
d742 10
@


11.79
log
@
lint
@
text
@d79 1
a79 1
	if( rt_db_get_internal( &old_intern, old_dp, dbip, bn_mat_identity ) < 0 )
d131 1
a131 1
			if( rt_db_put_internal( new_dp, dbip, &new_intern ) < 0 )  {
d375 1
a375 1
	if( rt_functab[id].ft_import( &internal, &external, identity, dbip ) < 0 )
d411 1
a411 1
	if( rt_functab[id].ft_export( &new_ext , &new_int , 1.0, dbip ) )
d516 1
a516 1
		if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d524 1
a524 1
		rt_comb_ifree( &intern );
d561 1
a561 1
	if( (id=rt_db_get_internal( &intern, dp, dbip, xform )) < 0 )
d570 1
a570 1
	rt_db_free_internal( &intern );
d865 1
a865 1
		if (rt_db_get_internal( &intern, pip->pi_dir, dbip, pip->pi_mat ) < 0 )  {
d873 1
a873 1
		if (rt_db_put_internal( pip->pi_dir, dbip, &intern ) < 0)  {
d877 1
a877 1
		rt_db_free_internal( &intern );
d953 1
a953 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d960 1
a960 1
		if( rt_db_put_internal( dp, dbip, &intern ) < 0 )
d967 1
a967 1
	rt_db_free_internal( &intern );
d1205 1
a1205 1
	if( rt_functab[id].ft_import( &sol_int, &sol_ext, xform, dbip ) < 0 )
d1214 1
a1214 1
	if( rt_db_put_internal( found, dbip, &sol_int ) < 0 )
d1299 1
a1299 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d1334 1
a1334 1
	if( rt_db_put_internal( found, dbip, &intern ) < 0 )
d1338 1
a1338 1
		rt_comb_ifree( &intern );
d1425 1
a1425 1
			if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d1430 1
a1430 1
			rt_comb_ifree( &intern );
d1567 1
a1567 1
		if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d1577 1
a1577 1
		rt_comb_ifree( &intern );
d1682 1
a1682 1
	if( rt_db_get_internal( &nmg_intern, dp, dbip, bn_mat_identity ) < 0 )
d1691 1
a1691 1
	  rt_db_free_internal( &nmg_intern );
d1738 1
a1738 1
				rt_db_free_internal( &nmg_intern );
d1759 1
a1759 1
		  rt_db_free_internal( &nmg_intern );
d1788 1
a1788 1
			  rt_db_free_internal( &nmg_intern );
d1811 1
a1811 1
		  rt_db_free_internal( &nmg_intern );
d1834 1
a1834 1
		rt_db_free_internal( &nmg_intern );
d1842 1
a1842 1
		if( rt_db_put_internal( dp, dbip, &new_intern ) < 0 )
d1844 1
a1844 1
			rt_db_free_internal( &new_intern );
d2079 1
a2079 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d2083 1
a2083 1
	rt_comb_ifree( &intern );
d2143 1
a2143 1
				if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d2149 1
a2149 1
					rt_comb_ifree( &intern );
d2152 1
a2152 1
				rt_comb_ifree( &intern );
d2235 1
a2235 1
	if( rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL ) < 0 )
d2244 1
a2244 1
		rt_db_free_internal( &intern );
d2278 1
a2278 1
		rt_db_free_internal( &intern );
d2282 1
a2282 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )
d2284 1
a2284 1
		rt_db_free_internal( &intern );
d2288 1
a2288 1
	rt_db_free_internal( &intern );
@


11.78
log
@
Reduced use of MAXARGS
@
text
@d2023 1
a2023 1
found:
@


11.77
log
@
Modified to eliminate
"../mged/utility2.c", line 1998: warning(1110): statement is unreachable
Changed to use libwdb to make the RPP, rather constructing it the hard way.
Fixed various lint
@
text
@d179 1
a179 1
	if(argc < 1 || MAXARGS < argc){
d777 1
a777 1
	if(argc < 2 || MAXARGS < argc){
d1877 1
a1877 1
	if(argc < 3 || MAXARGS < argc){
d2060 1
a2060 1
	if(argc < 2 || MAXARGS < argc){
d2105 1
a2105 1
	if(argc < 2 || MAXARGS < argc){
d2202 1
a2202 1
	if(argc < 5 || MAXARGS < argc){
@


11.76
log
@
Removed calls to db_alloc(), which are no longer necessary
with either v4 or v5 database interfaces
@
text
@d33 1
d723 1
a723 1
		1.0, 0.0, 0.0,	/* color, RGB */
d737 1
a737 1
	1.0, 0.0, 0.0, 0.0,
d740 1
a740 1
	0.0, 0.0, 0.0, 1.0,
a770 1
	int	id;
d1550 1
a1550 1
	while( child = strtok( (char *)NULL, "/" ) )
a1870 3
	struct directory	*dp;
	struct rt_arb_internal	*arb;
	struct rt_db_internal	new_intern;
d1976 2
a1977 5
			if( !strcmp( reg_name, argv[i] ) )
				goto found;
				
		}
		goto not_found;
d1979 1
a1979 3
		if( regp != REGION_NULL )
		{
found:
d1991 1
d1993 2
a1994 1
		else
a1996 1
not_found:
d2023 1
d2026 1
a2026 17
	/* build bounding RPP */
	arb = (struct rt_arb_internal *)bu_malloc( sizeof( struct rt_arb_internal ), "arb" );
	VMOVE( arb->pt[0], rpp_min );
	VSET( arb->pt[1], rpp_min[X], rpp_min[Y], rpp_max[Z] );
	VSET( arb->pt[2], rpp_min[X], rpp_max[Y], rpp_max[Z] );
	VSET( arb->pt[3], rpp_min[X], rpp_max[Y], rpp_min[Z] );
	VSET( arb->pt[4], rpp_max[X], rpp_min[Y], rpp_min[Z] );
	VSET( arb->pt[5], rpp_max[X], rpp_min[Y], rpp_max[Z] );
	VMOVE( arb->pt[6], rpp_max );
	VSET( arb->pt[7], rpp_max[X], rpp_max[Y], rpp_min[Z] );
	arb->magic = RT_ARB_INTERNAL_MAGIC;

	/* set up internal structure */
	RT_INIT_DB_INTERNAL( &new_intern );
	new_intern.idb_type = ID_ARB8;
	new_intern.idb_meth = &rt_functab[ID_ARB8];
	new_intern.idb_ptr = (genptr_t)arb;
d2028 3
a2030 3
	if( (dp=db_diradd( dbip, new_name, -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", new_name, " to directory\n", (char *)NULL );
a2033 9
	if( rt_db_put_internal( dp, dbip, &new_intern ) < 0 )
	{
		rt_db_free_internal( &new_intern );
		TCL_WRITE_ERR_return;
	}

	rt_clean( rtip );
	bu_free( (genptr_t)rtip, "f_make_bb: rtip" );

d2364 2
a2365 2
	if (*cp == '@@')
	    if (*(cp + 1) == '@@')
d2367 1
a2367 1
	    else
d2369 2
@


11.75
log
@
ft_ifree calls replaced properly
@
text
@d420 1
a420 3
	if( (dp=db_diradd( dbip, argv[1], -1, obj[endpos-1]->d_len, obj[endpos-1]->d_flags, NULL)) == DIR_NULL ||
	    db_alloc( dbip, dp, obj[endpos-1]->d_len ) < 0 )
	{
@


11.74
log
@
Modified not to use v4 import/export routines directly, but to
use the higher level routines.
Also modified to use tl_mat == NULL as signal for identity matrix,
rather than filling in an identity.
@
text
@d571 1
a571 1
	rt_functab[id].ft_ifree( &intern );
@


11.73
log
@
db_walk_tree() leaf method calling sequence changed.
@
text
@d774 1
a774 2
	struct bu_external	es_ext;
	struct rt_db_internal	es_int;
d862 4
a865 4
/*
 * We've built the push solid list, now all we need to do is apply
 * the matrix we've stored for each solid.
 */
d867 1
a867 3
		BU_INIT_EXTERNAL(&es_ext);
		RT_INIT_DB_INTERNAL(&es_int);
		if (db_get_external( &es_ext, pip->pi_dir, dbip) < 0) {
d873 3
a875 10
		id = rt_id_solid( &es_ext);
		if (rt_functab[id].ft_import(&es_int, &es_ext, pip->pi_mat, dbip) < 0 ) {
		  Tcl_AppendResult(interp, "push(", pip->pi_dir->d_namep,
				   "): solid import failure\n", (char *)NULL);
		  if (es_int.idb_ptr) rt_functab[id].ft_ifree( &es_int);
		  db_free_external( &es_ext);
		  continue;
		}
		RT_CK_DB_INTERNAL( &es_int);
		if ( rt_functab[id].ft_export( &es_ext, &es_int, 1.0, dbip) < 0 ) {
a877 2
		} else {
			db_put_external(&es_ext, pip->pi_dir, dbip);
d879 1
a879 2
		if (es_int.idb_ptr) rt_functab[id].ft_ifree(&es_int);
		db_free_external(&es_ext);
d925 4
a928 2
	if( !comb_leaf->tr_l.tl_mat )  {
		comb_leaf->tr_l.tl_mat = (matp_t)bu_malloc( sizeof(mat_t), "tl_mat" );
a929 1
	bn_mat_idn( comb_leaf->tr_l.tl_mat );
d969 1
@


11.72
log
@*- remove a few extern statements that now live in raytrace.h
@
text
@d628 1
a628 1
HIDDEN union tree *push_leaf( tsp, pathp, ep, id, client_data)
d631 1
a631 2
struct bu_external	*ep;
int			id;
d640 1
d647 1
a647 1
	  Tcl_AppendResult(interp, "push_leaf(", rt_functab[id].ft_name,
@


11.72.2.1
log
@Improved "xpush" to be aware of object uses outside the tree being pushed
and to use the original solid when no transformation is being applied.
@
text
@d984 27
d1120 1
a1120 1
		if( use_no == dp->d_uses-1 && dp->d_uses == dp->d_nref )
a1168 4
	/* If no transformation is to be applied, just use the original */
	if( bn_mat_is_identity( xform ) )
		return( dp );

a1396 2
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
d1418 2
a1419 14
	/* Initialize use and reference counts of all directory entries */
	for( i=0 ; i<RT_DBNHASH ; i++ )
	{
		struct directory *dp;

		for( dp=dbip->dbi_Head[i] ; dp!=DIR_NULL ; dp=dp->d_forw )
		{
			if( !(dp->d_flags & ( DIR_SOLID | DIR_COMB ) ) )
				continue;

			dp->d_uses = 0;
			dp->d_nref = 0;
		}
	}
d1421 1
a1421 1
	/* Count uses in the tree being pushed (updates dp->d_uses) */
a1437 3
			if( !(dp->d_flags & ( DIR_SOLID | DIR_COMB ) ) )
				continue;

d1462 1
a1462 1
	for( i=0 ; i<RT_DBNHASH ; i++ )
d1466 2
a1467 7
		for( dp=dbip->dbi_Head[i] ; dp!=DIR_NULL ; dp=dp->d_forw )
		{
			if( !(dp->d_flags & ( DIR_SOLID | DIR_COMB ) ) )
				continue;

			dp->d_nref = 0;
		}
a1469 1

d1488 1
a1488 25
	if( rt_db_get_internal( &intern, old_dp, dbip, (fastf_t *)NULL ) < 0 )
	{
		bu_log( "ERROR: cannot load %s feom the database!!!\n", old_dp->d_namep );
		bu_log( "\tNothing has been changed!!\n" );
		db_functree( dbip, old_dp, Free_uses, Free_uses, NULL );
		return TCL_ERROR;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	if( !comb->tree )
	{
		db_functree( dbip, old_dp, Free_uses, Free_uses, NULL );
		return TCL_OK;
	}

	db_tree_funcleaf( dbip, comb, comb->tree, Do_copy_membs,
		(genptr_t)xform, (genptr_t)NULL, (genptr_t)NULL );

	if( rt_db_put_internal( old_dp, dbip, &intern ) < 0 )
	{
		Tcl_AppendResult(interp, "rt_db_put_internal failed for ", old_dp->d_namep,
			"\n", (char *)NULL );
		rt_comb_ifree( &intern );
		db_functree( dbip, old_dp, Free_uses, Free_uses, NULL );
		return TCL_ERROR;
	}
@


11.72.2.2
log
@*- free vls in f_make_name()
@
text
@a2450 1
    bu_vls_free(&obj_name);
@


11.71
log
@f_make_bb() now mallocs an rt_arb_internal struct (instead of using a automatic) so that
rt_db_put_internal() has something to free
@
text
@a43 1
BU_EXTERN( struct shell *nmg_dup_shell, ( struct shell *s, long ***trans_tbl, struct bn_tol *tol ) );
@


11.70
log
@*- add client_data to db_walk_tree
@
text
@d1886 1
a1886 1
	struct rt_arb_internal	arb;
d2047 10
a2056 9
	VMOVE( arb.pt[0], rpp_min );
	VSET( arb.pt[1], rpp_min[X], rpp_min[Y], rpp_max[Z] );
	VSET( arb.pt[2], rpp_min[X], rpp_max[Y], rpp_max[Z] );
	VSET( arb.pt[3], rpp_min[X], rpp_max[Y], rpp_min[Z] );
	VSET( arb.pt[4], rpp_max[X], rpp_min[Y], rpp_min[Z] );
	VSET( arb.pt[5], rpp_max[X], rpp_min[Y], rpp_max[Z] );
	VMOVE( arb.pt[6], rpp_max );
	VSET( arb.pt[7], rpp_max[X], rpp_max[Y], rpp_min[Z] );
	arb.magic = RT_ARB_INTERNAL_MAGIC;
d2062 1
a2062 1
	new_intern.idb_ptr = (genptr_t)(&arb);
@


11.69
log
@Eliminated some unused variables
@
text
@d629 1
a629 1
HIDDEN union tree *push_leaf( tsp, pathp, ep, id)
d634 1
d703 1
a703 1
HIDDEN union tree *push_region_end( tsp, pathp, curtree)
d707 1
d847 1
a847 1
	    push_leaf);
@


11.68
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@a288 1
	int status = TCL_OK;
a489 2

	struct directory *nextdp;
d492 1
a492 2
	mat_t new_xlate;
	int nparts, i, k;
a957 1
	struct directory *nextdp;
a1045 3
	struct bu_external sol_ext;
	struct rt_db_internal sol_int;
	int id;
a1292 2
	mat_t new_xform;
	int i;
d1398 1
a1398 1
	int i,j;
a1504 1
	mat_t	matrix;
a1563 2
		int j;
		int found;
a1630 1
	struct bu_external new_extern;
a1635 1
	int do_ell=0;
a1662 2
		else if( !strncmp( argv[1], "ell", 3 ) )
			do_ell = 1;
d1880 1
a1880 1
	int			i,j;
@


11.67
log
@Added client_data pointer to db_functree() to eliminate use of
global variables.
@
text
@d117 1
a117 1
			if( (new_dp=db_diradd( dbip, shell_name, -1, 0, DIR_SOLID)) == DIR_NULL )  {
d422 1
a422 1
	if( (dp=db_diradd( dbip, argv[1], -1, obj[endpos-1]->d_len, obj[endpos-1]->d_flags)) == DIR_NULL ||
d1141 1
a1141 1
			if( (use->dp = db_diradd( dbip, name, -1, 0, dp->d_flags )) == DIR_NULL )
d1865 1
a1865 1
		if( (dp=db_diradd( dbip, new_name, -1L, 0, DIR_SOLID)) == DIR_NULL )
d2078 1
a2078 1
	if( (dp=db_diradd( dbip, new_name, -1L, 0, DIR_SOLID)) == DIR_NULL )
d2334 1
a2334 1
	if( (dp=db_diradd( dbip, new_name, -1L, 0, DIR_SOLID)) == DIR_NULL )
@


11.66
log
@
struct region is a bu_list now
@
text
@d988 1
a988 1
zero_dp_counts( db_ip, dp )
d991 1
d993 1
d1004 1
a1004 1
zero_nrefs( db_ip, dp )
d1007 1
d1015 1
a1015 1
increment_uses( db_ip, dp )
d1018 1
d1026 1
a1026 1
increment_nrefs( db_ip, dp )
d1029 1
d1045 1
a1045 1
Free_uses( db_ip, dp )
d1048 1
d1077 1
a1077 1
Make_new_name( db_ip, dp )
d1080 1
d1428 1
a1428 1
	db_functree( dbip, old_dp, zero_dp_counts, zero_dp_counts );
d1431 1
a1431 1
	db_functree( dbip, old_dp, increment_uses, increment_uses );
d1476 1
a1476 1
		db_functree( dbip, dp, zero_nrefs, zero_nrefs );
d1485 1
a1485 1
		db_functree( dbip, dp, increment_nrefs, increment_nrefs );
d1492 1
a1492 1
	db_functree( dbip, old_dp, Make_new_name, Make_new_name );
d1500 1
a1500 1
	db_functree( dbip, old_dp, Free_uses, Free_uses );
@


11.65
log
@
Lint
@
text
@d1952 1
a1952 2
		for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )
		{
d1996 1
a1996 2
		for( regp = rtip->HeadRegion; regp != REGION_NULL; regp = regp->reg_forw )
		{
d2002 1
a2002 1
				break;
d2005 1
d2009 1
d2025 1
d2031 1
a2031 2
			for( regp = rtip->HeadRegion; regp != REGION_NULL; regp = regp->reg_forw )
			{
@


11.64
log
@All solid/combination creation  routines needed values assigned to idb_meth
in the rt_db_internal struct
@
text
@d522 1
a522 1
		if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d971 1
a971 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d1314 1
a1314 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d1440 1
a1440 1
			if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d1585 1
a1585 1
		if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d2131 1
a2131 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d2195 1
a2195 1
				if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
@


11.63
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d128 1
d1735 1
d1754 1
d1776 1
d1805 1
d1828 1
d2068 1
@


11.62
log
@Added -s option to make_name
@
text
@d63 1
a63 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d176 1
a176 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d290 1
a290 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d779 1
a779 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d1402 1
a1402 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d1549 1
a1549 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1650 1
a1650 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d1893 1
a1893 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d2103 1
a2103 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d2148 1
a2148 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d2244 1
a2244 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d2371 1
a2371 2
    if (dbip == DBI_NULL)
	return TCL_OK;
@


11.61
log
@Deleted some diagnostics from code for make_name
@
text
@d2392 1
a2392 1
    if ((argc < 2) || (2 < argc))
d2394 11
a2404 1
	struct bu_vls vls;
d2406 17
a2422 5
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel make_name");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
@


11.60
log
@*- use helpdevel for help on developer commands
@
text
@a2388 1
    bu_log("make_name %s\n", argv[1]);
a2421 1
	bu_log("OK, object_name is '%s'\n", bu_vls_addr(&obj_name));
a2423 1
    bu_log("%s\n", bu_vls_addr(&obj_name));
@


11.59
log
@Regions now have an associated temperature
@
text
@d2398 1
a2398 1
	bu_vls_printf(&vls, "help make_name");
@


11.58
log
@*- fix typos
@
text
@d732 1
@


11.57
log
@Changed rt_import and ft_export calls to new calling sequence.
@
text
@d2352 1
a2352 1
	sprintf( count_str, "%d", count );
@


11.56
log
@Added minimum resulting angle parameter to nmg_edge_collapse().
@
text
@d380 1
a380 1
	if( rt_functab[id].ft_import( &internal, &external, identity ) < 0 )
d416 1
a416 1
	if( rt_functab[id].ft_export( &new_ext , &new_int , 1.0 ) )
d885 1
a885 1
		if (rt_functab[id].ft_import(&es_int, &es_ext, pip->pi_mat) < 0 ) {
d893 1
a893 1
		if ( rt_functab[id].ft_export( &es_ext, &es_int, 1.0) < 0 ) {
d1223 1
a1223 1
	if( rt_functab[id].ft_import( &sol_int, &sol_ext, xform ) < 0 )
@


11.55
log
@tl_mat == NULL indicates identity matrix.
@
text
@d2242 1
d2257 1
d2264 1
a2264 1
	if(argc < 4 || MAXARGS < argc){
a2273 7
	tol_coll = atof( argv[1] ) * local2base;
	if( tol_coll <= 0.0 )
	{
		Tcl_AppendResult(interp, "tolerance distance too small\n", (char *)NULL );
		return TCL_ERROR;
	}

d2288 1
a2288 1
	if( (dp=db_lookup( dbip, argv[3], LOOKUP_NOISY )) == DIR_NULL )
d2293 1
a2293 1
		Tcl_AppendResult(interp, argv[3], " is a combination, only NMG solids are allowed here\n", (char *)NULL );
d2299 1
a2299 1
		Tcl_AppendResult(interp, "Failed to get internal form of ", argv[3], "!!!!\n", (char *)NULL);
d2305 1
a2305 1
		Tcl_AppendResult(interp, argv[3], " is not an NMG solid!!!!\n", (char *)NULL );
d2310 19
d2335 1
a2335 1
	count = nmg_edge_collapse( m, &mged_tol, tol_coll );
@


11.54
log
@Reran ed script ../h/sed4 to adjust for Mike's changes
@
text
@d477 5
a481 1
	bn_mat_mul( new_xlate, old_xlate, comb_leaf->tr_l.tl_mat );
d946 3
d1265 5
a1269 1
	bn_mat_mul( new_xform, xform, comb_leaf->tr_l.tl_mat );
d1284 3
d1535 4
a1538 2
		bn_mat_mul( tmp_mat, acc_matrix, comb_leaf->tr_l.tl_mat );
		MAT_COPY( acc_matrix, tmp_mat );
@


11.53
log
@Implemented the make_name command
@
text
@d665 1
a665 1
	bu_semaphore_acquire((unsigned int)(&rt_g.res_worker - &rt_g.res_syscall));
d678 1
a678 1
	    bu_semaphore_release((unsigned int)(&rt_g.res_worker - &rt_g.res_syscall));
d697 1
a697 1
	bu_semaphore_release((unsigned int)(&rt_g.res_worker - &rt_g.res_syscall));
@


11.52
log
@fixed subscript out of range
@
text
@d748 1
a748 1
 * The push command is used to move matricies from combinations 
d2336 62
@


11.51
log
@*** empty log message ***
@
text
@d1112 1
a1112 1
		name[NAMESIZE] = '\0';                /* ensure null termination */
@


11.50
log
@Added tolerance argument to nmg_collapse command.
@
text
@d1112 1
@


11.49
log
@Made use of bu_getopt() explicit, rather than depending on
#define in bu.h
@
text
@d2238 1
d2245 1
a2245 1
	if(argc < 3 || MAXARGS < argc){
d2255 2
a2256 1
	if( strchr( argv[1], '/' ) )
d2258 7
a2264 1
	  Tcl_AppendResult(interp, "Do not use '/' in solid names: ", argv[1], "\n", (char *)NULL);
d2268 1
a2268 1
	new_name = argv[1];
d2276 1
a2276 1
	if( (dp=db_lookup( dbip, argv[2], LOOKUP_NOISY )) == DIR_NULL )
d2281 1
a2281 1
		Tcl_AppendResult(interp, argv[2], " is a combination, only NMG solids are allowed here\n", (char *)NULL );
d2287 1
a2287 1
		Tcl_AppendResult(interp, "Failed to get internal form of ", argv[2], "!!!!\n", (char *)NULL);
d2293 1
a2293 1
		Tcl_AppendResult(interp, argv[2], " is not an NMG solid!!!!\n", (char *)NULL );
d2304 1
a2304 1
	count = nmg_edge_collapse( m, &mged_tol );
@


11.48
log
@Added nmg_collapse command.
@
text
@d769 2
a770 2
	extern 	int optind;
	extern	char *optarg;
d805 2
a806 2
	optind = 1;	/* re-init getopt() */
	while ( (c=getopt(argc, argv, "l:P:d")) != EOF) {
d810 1
a810 1
			levels=atoi(optarg);
d814 1
a814 1
			ncpu = atoi(optarg);
d827 2
a828 2
	argc -= optind;
	argv += optind;
@


11.47
log
@mods to run without a database
@
text
@d2224 104
@


11.46
log
@fixed bug in f_eac().
@
text
@d63 3
d178 3
d293 3
d500 3
d779 3
d964 3
d1047 3
d1082 3
d1154 3
d1287 3
d1393 3
d1540 3
d1642 3
d1887 3
d2099 3
d2144 3
@


11.45
log
@modify calls to Tcl_Eval
@
text
@d2135 1
a2135 2
				if( (dp->d_flags & DIR_COMB|DIR_REGION) !=
				    (DIR_COMB|DIR_REGION) )
@


11.44
log
@mods so that commands check args internally
@
text
@d66 7
a72 2
	      Tcl_Eval(interp, "help shells");
	          return TCL_ERROR;
d290 6
a295 1
	  Tcl_Eval(interp, "help copyeval");
d770 6
a775 1
	  Tcl_Eval(interp, "help push");
d1366 6
a1371 1
	  Tcl_Eval(interp, "help xpush");
d1508 6
a1513 1
	  Tcl_Eval(interp, "help showmats");
d1609 6
a1614 1
	  Tcl_Eval(interp, "help nmg_simplify");
d1851 6
a1856 1
	  Tcl_Eval(interp, "help make_bb");
d2058 6
a2063 1
	  Tcl_Eval(interp, "help whatid");
d2101 6
a2106 1
	  Tcl_Eval(interp, "help eac");
@


11.43
log
@Improved f_nmg_simplify().
@
text
@d65 4
a68 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d170 7
a176 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d178 1
d284 2
a285 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d287 1
d759 2
a760 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d762 1
d1350 2
a1351 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1353 1
d1487 2
a1488 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1490 1
d1583 2
a1584 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1586 1
d1820 2
a1821 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1823 1
d2022 4
a2025 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
		return TCL_ERROR;
d2060 4
a2063 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
		return TCL_ERROR;
@


11.42
log
@Mods to support MGED's read-only mode.
@
text
@d1562 1
d1625 2
a1626 1
	if( do_arb || do_all )
d1628 6
d1644 24
a1667 4
		  rt_db_free_internal( &nmg_intern );
		  Tcl_AppendResult(interp, "Failed to construct an ARB equivalent to ",
				   nmg_name, "\n", (char *)NULL);
		  return TCL_OK;
d1671 1
a1671 1
	if( (do_tgc || do_all) && !success )
d1689 30
@


11.41
log
@removed dependencies on db.h.
@
text
@d63 2
d273 2
d746 2
d1335 2
d1563 2
d1740 2
@


11.40
log
@Completed conversion to combination import/export.
@
text
@a30 1
#include "db.h"
d692 2
a693 2
		DB_INH_LOWER,	/* color inherit */
		DB_INH_LOWER,	/* mater inherit */
@


11.39
log
@Use bu_strdup() to assign values to tr_l.tl_nam.
@
text
@a4 1
 *	f_tabobj()	tabs objects as they are stored in data file
a37 2
static union record record;

a135 114
/*  	F _ T A B O B J :   tabs objects as they appear in data file
 */
int
f_tabobj(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	register struct directory *dp;
	int ngran, nmemb;
	int i, j, k, kk;
	struct bu_vls tmp_vls;

	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;

	bu_vls_init(&tmp_vls);
	start_catching_output(&tmp_vls);

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	else{
	  bu_vls_free(&tmp_vls);
	  return TCL_OK;
	}

	for(i=1; i<argc; i++) {
		if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY)) == DIR_NULL )
			continue;
		if( db_get( dbip, dp, &record, 0, 1) < 0 ) {
		  stop_catching_output(&tmp_vls);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		  (void)signal( SIGINT, SIG_IGN );
		  TCL_READ_ERR_return;
		}
		if(record.u_id == ID_ARS_A) {
			bu_log("%c %d %s ",record.a.a_id,record.a.a_type,record.a.a_name);
			bu_log("%d %d %d %d\n",record.a.a_m,record.a.a_n,
				record.a.a_curlen,record.a.a_totlen);
			/* the b-records */
			ngran = record.a.a_totlen;
			for(j=1; j<=ngran; j++) {
				if( db_get( dbip, dp, &record, j, 1) < 0 ) {
				  stop_catching_output(&tmp_vls);
				  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
				  bu_vls_free(&tmp_vls);
				  (void)signal( SIGINT, SIG_IGN );
				  TCL_READ_ERR_return;
				}
				bu_log("%c %d %d %d\n",record.b.b_id,record.b.b_type,record.b.b_n,record.b.b_ngranule);
				for(k=0; k<24; k+=6) {
					for(kk=k; kk<k+6; kk++)
						bu_log("%10.4f ",record.b.b_values[kk]*base2local);
					bu_log("\n");
				}
			}
		}

		if(record.u_id == ID_SOLID) {
			bu_log("%c %d %s %d\n", record.s.s_id,
				record.s.s_type,record.s.s_name,
				record.s.s_cgtype);
			for(kk=0;kk<24;kk+=6){
				for(j=kk;j<kk+6;j++)
					bu_log("%10.4f ",record.s.s_values[j]*base2local);
				bu_log("\n");
			}
		}
		if(record.u_id == ID_COMB) {
			bu_log("%c '%c' %s %d %d %d %d %d \n",
			record.c.c_id,record.c.c_flags,
			record.c.c_name,record.c.c_regionid,
			record.c.c_aircode, dp->d_len-1,
			record.c.c_material,record.c.c_los);
			nmemb = dp->d_len-1;
			for(j=1; j<=nmemb; j++) {
				mat_t	xmat;

				if( db_get( dbip, dp, &record, j, 1) < 0 ) {
				  stop_catching_output(&tmp_vls);
				  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
				  bu_vls_free(&tmp_vls);
				  (void)signal( SIGINT, SIG_IGN );
				  TCL_READ_ERR_return;
				}
				bu_log("%c %c %s\n",
					record.M.m_id,
					record.M.m_relation,
					record.M.m_instname);
				rt_mat_dbmat( xmat, record.M.m_mat );
				matrix_print( xmat );
				bu_log("\n");
			}
		}
		if(record.u_id == ID_P_HEAD) {
			bu_log("POLYGON: not implemented yet\n");
		}

		if(record.u_id == ID_BSOLID) {
			bu_log("SPLINE: not implemented yet\n");
		}
	}

	stop_catching_output(&tmp_vls);
	Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	bu_vls_free(&tmp_vls);

	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
}


a1460 1
	union record *rp;
a1673 2
		int ngran;

d1691 1
a1691 1
		if( rt_functab[new_intern.idb_type].ft_export( &new_extern, &new_intern, 1.0 ) < 0 )
d1693 2
a1694 3
		  Tcl_AppendResult(interp, "f_nmg_simplify: export failure\n", (char *)NULL);
		  rt_functab[new_intern.idb_type].ft_ifree( &new_intern );
		  return TCL_ERROR;
d1697 1
a1697 13
		/* only the polysolid mallocs anything */
		if( new_intern.idb_type == ID_POLY )
			rt_functab[new_intern.idb_type].ft_ifree( &new_intern );

		ngran = (new_extern.ext_nbytes+sizeof(union record)-1) / sizeof(union record);
		if( (dp = db_diradd( dbip, new_name, -1L, ngran, DIR_SOLID)) == DIR_NULL ||
		    db_alloc( dbip, dp, 1 ) < 0 )
		    {
		      db_free_external( &new_extern );
		      TCL_ALLOC_ERR_return;
		    }

		if (db_put_external( &new_extern, dp, dbip ) < 0 )
d1699 2
a1700 2
		  db_free_external( &new_extern );
		  TCL_WRITE_ERR_return;
a1701 1
		db_free_external( &new_extern );
a1728 1
	struct bu_external	new_extern;
a1729 1
	int			ngran;
a1891 1
	BU_INIT_EXTERNAL( &new_extern );
d1893 1
a1893 2
	/* export it */
	if( rt_functab[new_intern.idb_type].ft_export( &new_extern, &new_intern, 1.0 ) < 0 )
d1895 2
a1896 12
	  Tcl_AppendResult(interp, "f_make_bb: export failure\n", (char *)NULL);
	  rt_functab[new_intern.idb_type].ft_ifree( &new_intern );
	  return TCL_ERROR;
	}

	/* Add this new solid to the directory */
	ngran = (new_extern.ext_nbytes+sizeof(union record)-1) / sizeof(union record);
	if( (dp = db_diradd( dbip, new_name, -1L, ngran, DIR_SOLID)) == DIR_NULL ||
		db_alloc( dbip, dp, 1 ) < 0 )
	{
	  db_free_external( &new_extern );
	  TCL_ALLOC_ERR_return;
d1899 1
a1899 2
	/* and finally, write it to disk */
	if (db_put_external( &new_extern, dp, dbip ) < 0 )
d1901 2
a1902 2
	  db_free_external( &new_extern );
	  TCL_WRITE_ERR_return;
a1904 3
	/* clean up */
	db_free_external( &new_extern );

a1929 1
	union record rec;
@


11.38
log
@Added a couple checks for existence of comb->tree.
@
text
@d1325 2
a1326 1
	NAMEMOVE( dp_new->d_namep, comb_leaf->tr_l.tl_name );
@


11.37
log
@Converted more code to using combination import/export.
"tab" command still reads records from database.
@
text
@d608 3
a610 2
		db_tree_funcleaf( dbip, comb, comb->tree, Do_trace,
			(genptr_t)&pathpos, (genptr_t)old_xlate, (genptr_t)&flag );
d1615 3
a1617 1
		db_tree_funcleaf( dbip, comb, comb->tree, Do_showmats, (genptr_t)acc_matrix, (genptr_t)&count, (genptr_t)child );
@


11.36
log
@Modified identitize(), "listeval", "copyeval", "paths" to use combination import/export.
Also modified "listeval", "copyeval", and "paths" to accept '/' delimited paths.
@
text
@d2076 2
d2093 1
a2093 4
	if( db_get( dbip, dp, &rec, 0, 1 ) )
	{
		Tcl_AppendResult(interp, "Cannot get database record for ",
			argv[1], "\n", (char *)NULL );
d2095 3
a2097 3
	}

	sprintf( id, "%d\n", rec.c.c_regionid );
a2112 1
	union record rec;
d2135 2
d2142 3
d2148 9
a2156 4
				if( db_get( dbip, dp, &rec, 0, 1 ) < 0 ) {
				  bu_vls_free( &v );
				  (void)signal( SIGINT, SIG_IGN );
				  TCL_READ_ERR_return;
d2158 1
a2158 3
				if( rec.c.c_regionid != 0 ||
					rec.c.c_aircode != item )
						continue;
a2174 1
		bu_vls_free( &v );
@


11.35
log
@Mod "xpush" to use combination import/export, and fixed "listeval" (wasn't doing the 'eval' part).
@
text
@d307 1
a307 1
			   "Enter the path (space is delimiter): ", (char *)NULL);
a316 1
	objpos = argc-1;
d318 27
a344 6
	/* build directory pointer array for desired path */
	for(i=0; i<objpos; i++) {
	  if( (obj[i] = db_lookup( dbip, argv[pos_in+i], LOOKUP_NOISY )) == DIR_NULL){
	    (void)signal( SIGINT, SIG_IGN );
	    return TCL_ERROR;
	  }
a371 2
static union record saverec;

d386 1
d395 2
a396 2
			   "Enter new_solid_name and full path to old_solid ",
			   "(seperate path components with spaces not /)\n", (char *)NULL);
d415 18
a432 1
	for(i=2; i<argc; i++)
d434 8
a441 4
	  if( (obj[i-2] = db_lookup( dbip, argv[i], LOOKUP_NOISY)) == DIR_NULL){
	    (void)signal( SIGINT, SIG_IGN );
	    return TCL_ERROR;
	  }
d446 1
a446 1
	if( db_get_external( &external , obj[argc-3] , dbip ) )
d510 2
a511 2
	if( (dp=db_diradd( dbip, argv[1], -1, obj[argc-3]->d_len, obj[argc-3]->d_flags)) == DIR_NULL ||
	    db_alloc( dbip, dp, obj[argc-3]->d_len ) < 0 )
d541 27
d578 1
d601 4
a604 11
	if( db_get( dbip, dp, &record, 0, 1) < 0 )  READ_ERR_return;

	if( record.u_id == ID_COMB ) {
		nparts = dp->d_len-1;
		for(i=1; i<=nparts; i++) {
			mat_t	xmat;

			if( db_get( dbip, dp, &record, i, 1) < 0 )  READ_ERR_return;
			path[pathpos] = dp;
			if( (nextdp = db_lookup( dbip, record.M.m_instname, LOOKUP_NOISY)) == DIR_NULL )
				continue;
d606 5
a610 7
			rt_mat_dbmat( xmat, record.M.m_mat );
			bn_mat_mul(new_xlate, old_xlate, xmat);

			/* Recursive call */
			trace(nextdp, pathpos+1, new_xlate, flag);

		}
d631 1
a631 3
	if(flag == CPEVAL) { 
		/* save this record */
		if( db_get( dbip, dp, &saverec, 0, 1) < 0 )  READ_ERR_return;
a632 1
	}
d639 3
a641 1
	  Tcl_AppendResult(interp, "/", record.s.s_name, "\n", (char *)NULL);
d658 1
d998 19
d1029 2
a1030 3
	int nparts, i;
#if 0
	mat_t	identity;
d1032 14
a1045 15
	bn_mat_idn( identity );
#endif
	if( db_get( dbip, dp, &record, 0, 1) < 0 )  READ_ERR_return;
	if( record.u_id == ID_COMB ) {
		nparts = dp->d_len-1;
		for(i=1; i<=nparts; i++) {
			if( db_get( dbip, dp, &record, i, 1) < 0 )  READ_ERR_return;

			rt_dbmat_mat( record.M.m_mat, identity );
			if( db_put( dbip, dp, &record, i, 1 ) < 0 )  WRITE_ERR_return;

			if( (nextdp = db_lookup( dbip, record.M.m_instname, LOOKUP_NOISY)) == DIR_NULL )
				continue;
			/* Recursive call */
			identitize( nextdp );
a1046 1
		return;
a1047 2
	/* bottom position */
	return;
@


11.34
log
@Changed showmats command to use combination import/export.
@
text
@d510 1
d513 1
a587 1
	/* do_list will print actual solid name */
d589 10
a598 1
	do_list( &str, dp, 1 );
d1219 38
d1264 2
a1265 1
	union record *rp;
d1283 1
a1283 1
	if( (rp=db_getmrec( dbip , dp )) == (union record *)0 )
d1285 1
d1288 3
a1290 28
	for( i=1 ; i<dp->d_len ; i++ )
	{
		mat_t arc_mat;
		struct directory *dp2;
		struct directory *dp_new;

		/* ignore members that don't exist */
		if( (dp2=db_lookup( dbip, rp[i].M.m_instname, 0 )) == DIR_NULL )
			continue;

		/* apply transform matrix for this arc */
		rt_mat_dbmat( arc_mat, rp[i].M.m_mat );
		bn_mat_mul( new_xform, xform, arc_mat );

		/* Copy member with current tranform matrix */
		if( (dp_new=Copy_object( dp2, new_xform )) == DIR_NULL )
		{
		  Tcl_AppendResult(interp, "Failed to copy object ",
				   dp2->d_namep, "\n", (char *)NULL);
		  return( DIR_NULL );
		}

		/* replace member name with new copy */
		NAMEMOVE( dp_new->d_namep, rp[i].M.m_instname );

		/* make transform for this arc the identity matrix */
		rt_dbmat_mat( rp[i].M.m_mat, bn_mat_identity );
	}
d1318 1
a1318 12
	if( found != dp )
	{
	  if( db_alloc( dbip, found, dp->d_len ) < 0 )
	    {
	      Tcl_AppendResult(interp, "Cannot allocate space for combination ",
			       found->d_namep, "\n", (char *)NULL);
	      return( DIR_NULL );
	    }
	  NAMEMOVE( found->d_namep, rp[0].c.c_name );
	}

	if( db_put( dbip, found, rp, 0, found->d_len ) < 0 )
d1320 4
a1323 3
	  Tcl_AppendResult(interp,  "Failed to write combination ",
			   found->d_namep, " to database\n", (char *)NULL);
	  return( DIR_NULL );
d1342 18
d1393 2
a1394 1
			union record *rp;
d1399 6
a1404 18
			if( (rp=db_getmrec( dbip , dp )) == (union record *)0 )
			{
			  Tcl_AppendResult(interp, "Cannot get records for ", dp->d_namep,
					   "\n", (char *)NULL);
			  return TCL_ERROR;
			}

			for( j=1 ; j<dp->d_len ; j++ )
			{
				struct directory *dp2;

				dp2 = db_lookup( dbip, rp[j].M.m_instname, 0 );
				if( dp2 == DIR_NULL )
					continue;

				dp2->d_nref++;
			}
			bu_free( (genptr_t)rp, "rp[]" );
@


11.33
log
@.
@
text
@d1435 36
d1498 2
d1506 1
a1506 1
		if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
d1508 2
a1509 1
		  TCL_READ_ERR_return;
d1512 4
a1515 1
		found = 0;
d1517 1
d1519 2
a1520 21
		for( j=1 ; j<dp->d_len ; j++ )
		{
			if( !strncmp( rp[j].M.m_instname, child, NAMESIZE ) )
			{
				mat_t matrix;

				count++;
				if( count > 1 )
				  bu_log( "\n\tOccurrence #%d:\n", count );

				rt_mat_dbmat( matrix, rp[j].M.m_mat );
				bn_mat_print( "", matrix );
				if( count == 1 )
				{
					mat_t tmp_mat;
					bn_mat_mul( tmp_mat, acc_matrix, matrix );
					MAT_COPY( acc_matrix, tmp_mat );
				}
				found = 1;
			}
		}
d1525 1
a1525 1
		if( !found )
a1533 1
		bu_free( (genptr_t)rp, "f_showmats: rp" );
@


11.32
log
@mods to use libbn and libbu
@
text
@d676 1
a676 1
	bu_semaphore_acquire(&rt_g.res_worker);
d689 1
a689 1
	    bu_semaphore_release(&rt_g.res_worker);
d708 1
a708 1
	bu_semaphore_release(&rt_g.res_worker);
@


11.31
log
@Changed ma_matparm stuff to ma_shader
@
text
@d30 1
d46 1
a46 1
extern struct rt_tol	mged_tol;	/* from ged.c */
d73 1
a73 1
	if( rt_db_get_internal( &old_intern, old_dp, dbip, rt_identity ) < 0 )
d328 1
a328 1
	mat_idn(identity);
d330 1
a330 1
	mat_idn( xform );
d363 1
a363 1
	struct rt_external external,new_ext;
d388 1
a388 1
	mat_idn( start_mat );
d405 1
a405 1
	RT_INIT_EXTERNAL( &external );
d412 1
a412 1
	RT_CK_EXTERNAL( &external );
d544 1
a544 1
			mat_mul(new_xlate, old_xlate, xmat);
d567 1
a567 1
	mat_copy(xform, old_xlate);
d647 1
a647 1
struct rt_external	*ep;
d655 1
a655 1
	RT_CK_TOL(tsp->ts_tol);
d676 1
a676 1
	RES_ACQUIRE(&rt_g.res_worker);
d679 1
a679 1
	    if (!rt_mat_is_equal(pip->pi_mat,
d689 1
a689 1
	    RES_RELEASE(&rt_g.res_worker);
d703 1
a703 1
	mat_copy(pip->pi_mat, tsp->ts_mat);
d708 1
a708 1
	RES_RELEASE(&rt_g.res_worker);
d742 1
d744 3
d782 1
a782 1
	extern	struct rt_tol	mged_tol;	/* from ged.c */
d787 1
a787 1
	struct rt_external	es_ext;
d871 1
a871 1
		RT_INIT_EXTERNAL(&es_ext);
d945 1
a945 1
	mat_idn( identity );
d1025 1
a1025 1
	struct rt_external sol_ext;
d1085 1
a1085 1
		mat_zero( use->xform );
d1125 1
a1125 1
	struct rt_external sol_ext;
d1142 1
a1142 1
		if( rt_mat_is_equal( xform, use->xform, &mged_tol ) )
d1159 1
a1159 1
		mat_copy( use->xform, xform );
d1176 1
a1176 1
	RT_INIT_EXTERNAL( &sol_ext );
d1225 1
a1225 1
		if( rt_mat_is_equal( xform, use->xform, &mged_tol ) )
d1250 1
a1250 1
		mat_mul( new_xform, xform, arc_mat );
d1264 1
a1264 1
		rt_dbmat_mat( rp[i].M.m_mat, rt_identity );
d1276 1
a1276 1
		mat_copy( use->xform, xform );
d1424 1
a1424 1
	mat_idn( xform );
d1487 1
a1487 1
				mat_print( "", matrix );
d1491 1
a1491 1
					mat_mul( tmp_mat, acc_matrix, matrix );
d1521 1
a1521 1
	mat_print( "", acc_matrix );
d1539 1
a1539 1
	struct rt_external new_extern;
d1595 1
a1595 1
	if( rt_db_get_internal( &nmg_intern, dp, dbip, rt_identity ) < 0 )
d1741 1
a1741 1
	struct rt_external	new_extern;
d1906 1
a1906 1
	RT_INIT_EXTERNAL( &new_extern );
@


11.30
log
@Minor mods to account for changes in nmg_dup_shell().
@
text
@d741 1
a741 2
		"",		/* material name */
		""		/* material params */
@


11.29
log
@removed an unneccessary nmg_fuse().
@
text
@d47 1
a47 1
BU_EXTERN( struct shell *nmg_dup_shell, ( struct shell *s, long ***trans_tbl ) );
d91 1
a91 1
			s_tmp = nmg_dup_shell( s, &trans_tbl );
@


11.28
log
@cast bu_free's 1st argument to genptr_t
@
text
@a102 2
			(void)nmg_model_fuse( m_tmp, &mged_tol );

@


11.27
log
@more ignore SIGINT
@
text
@d92 1
a92 1
			bu_free( (char *)trans_tbl, "trans_tbl" );
d665 1
a665 1
	  bu_free(sofar, "path string");
d686 1
a686 1
	      bu_free(sofar, "path string");
d858 1
a858 1
			bu_free((char *)pip, "Push ident");
d920 1
a920 1
		bu_free((char *)pip, "Push ident");
d1041 1
a1041 1
		bu_free( (char *)use, "Free_uses: use" );
d1380 1
a1380 1
			bu_free( (char *)rp, "rp[]" );
d1508 1
a1508 1
		bu_free( (char *)rp, "f_showmats: rp" );
d1781 1
a1781 1
			bu_free( (char *)rtip, "f_make_bb: rtip" );
d1797 1
a1797 1
				bu_free( (char *)rtip, "f_make_bb: rtip" );
d1813 1
a1813 1
			bu_free( (char *)rtip, "f_make_bb: rtip" );
d1851 1
a1851 1
				bu_free( (char *)rtip, "f_make_bb: rtip" );
d1880 1
a1880 1
					bu_free( (char *)rtip, "f_make_bb: rtip" );
d1934 1
a1934 1
	bu_free( (char *)rtip, "f_make_bb: rtip" );
d2050 1
a2050 1
		bu_free( (char *)new_argv, "f_eac: new_argv" );
@


11.26
log
@ignore SIGINT
@
text
@d162 2
a163 1
	else
d165 1
a294 5
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else
	  return TCL_OK;

d312 5
d322 2
a323 1
	  if( (obj[i] = db_lookup( dbip, argv[pos_in+i], LOOKUP_NOISY )) == DIR_NULL)
d325 1
d344 1
d369 1
d399 2
a400 1
	  if( (obj[i-2] = db_lookup( dbip, argv[i], LOOKUP_NOISY)) == DIR_NULL)
d402 1
d410 1
d420 1
d430 1
d444 1
a447 5
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else
	  return TCL_OK;

d457 1
d465 3
a467 1
	  Tcl_AppendResult(interp, "f_copyeval: export failure for new solid\n", (char *)NULL);
d476 1
d484 1
d490 1
d2002 2
d2006 2
a2007 1
        else
d2009 1
a2009 2

	bu_vls_init( &v );
d2026 2
d2051 2
d2058 1
@


11.25
log
@rt_list ---> bu_list
@
text
@d172 1
d186 1
d222 1
d246 2
@


11.24
log
@removed redundant "eid" command.
@
text
@d28 1
d87 1
a87 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d89 1
a89 1
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d95 1
a95 1
			r_tmp = RT_LIST_FIRST( nmgregion, &m_tmp->r_hd );
d97 2
a98 2
			RT_LIST_DEQUEUE( &s_tmp->l );
			RT_LIST_APPEND( &r_tmp->s_hd, &s_tmp->l );
d624 1
a624 1
 * linked list could be handled by rt_list macros but it is simple
d957 1
a957 1
  if( RT_LIST_NON_EMPTY( &dp->d_use_hd ) )
d993 1
a993 1
	struct rt_list	l;
d1011 1
a1011 1
	while( RT_LIST_NON_EMPTY( &dp->d_use_hd ) )
d1013 1
a1013 1
		use = RT_LIST_FIRST( object_use, &dp->d_use_hd );
d1022 1
a1022 1
		RT_LIST_DEQUEUE( &use->l );
d1046 1
a1046 1
	if( RT_LIST_NON_EMPTY( &dp->d_use_hd ) )
d1095 1
a1095 1
		RT_LIST_INSERT( &dp->d_use_hd, &use->l );
d1120 1
a1120 1
	for( RT_LIST_FOR( use, object_use, &dp->d_use_hd ) )
d1132 1
a1132 1
	for( RT_LIST_FOR( use, object_use, &dp->d_use_hd ) )
d1203 1
a1203 1
	for( RT_LIST_FOR( use, object_use, &dp->d_use_hd ) )
d1249 1
a1249 1
	for( RT_LIST_FOR( use, object_use, &dp->d_use_hd ) )
d1652 2
a1653 2
		r = RT_LIST_FIRST( nmgregion, &m->r_hd );
		s = RT_LIST_FIRST( shell, &r->s_hd );
d1655 1
a1655 1
		if( RT_LIST_NON_EMPTY( &s->lu_hd ) )
d1659 1
a1659 1
		if( RT_LIST_NON_EMPTY( &s->eu_hd ) )
@


11.23
log
@more conversions to libbu
@
text
@a1965 70
f_eid(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	int i,j;
	int item;
	struct directory *dp;
	union record rec;
	struct bu_vls v;
	int new_argc;
	int lim;

	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
		return TCL_ERROR;

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else
	  return TCL_OK;

	bu_vls_init( &v );

	bu_vls_strcat( &v, "e" );
	lim = 1;

	for( j=1; j<argc; j++)
	{
		item = atoi( argv[j] );

		for( i = 0; i < RT_DBNHASH; i++ )
		{
			for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )
			{
				if( (dp->d_flags & DIR_COMB|DIR_REGION) !=
				    (DIR_COMB|DIR_REGION) )
					continue;
				if( db_get( dbip, dp, &rec, 0, 1 ) < 0 ) {
				  TCL_READ_ERR_return;
				}
				if( rec.c.c_regionid != item )
					continue;

				bu_vls_strcat( &v, " " );
				bu_vls_strcat( &v, dp->d_namep );
				lim++;
			}
		}
	}
	if( lim > 1 )
	{
		int retval;
		char **new_argv;

		new_argv = (char **)bu_calloc( lim+1, sizeof( char *), "f_eac: new_argv" );
		new_argc = rt_split_cmd( new_argv, lim+1, bu_vls_addr( &v ) );
		retval = f_edit( clientData, interp, new_argc, new_argv );
		bu_vls_free( &v );
		bu_free( (char *)new_argv, "f_eac: new_argv" );
		return retval;
	}
	else
	{
		bu_vls_free( &v );
		return TCL_OK;
	}
}

int
@


11.22
log
@now using libbu
@
text
@d1314 1
a1314 1
	struct nmg_ptbl tops;
d1332 1
a1332 1
	nmg_tbl( &tops, TBL_INIT, (long *)NULL );
d1375 1
a1375 1
				nmg_tbl( &tops, TBL_INS, (long *)dp );
d1380 1
a1380 1
	for( i=0 ; i<NMG_TBL_END( &tops ) ; i++ )
d1384 1
a1384 1
		dp = (struct directory *)NMG_TBL_GET( &tops, i );
d1389 1
a1389 1
	for( i=0 ; i<NMG_TBL_END( &tops ) ; i++ )
d1393 1
a1393 1
		dp = (struct directory *)NMG_TBL_GET( &tops, i );
d1398 1
a1398 1
	nmg_tbl( &tops, TBL_FREE, (long *)NULL );
@


11.21
log
@Minor mod to the "eid" command.
@
text
@d46 2
a47 2
RT_EXTERN( struct shell *nmg_dup_shell, ( struct shell *s, long ***trans_tbl ) );
RT_EXTERN( struct rt_i *rt_new_rti, (struct db_i *dbip) );
d91 1
a91 1
			rt_free( (char *)trans_tbl, "trans_tbl" );
d151 1
a151 1
	struct rt_vls tmp_vls;
d156 1
a156 1
	rt_vls_init(&tmp_vls);
d169 2
a170 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d174 2
a175 2
			rt_log("%c %d %s ",record.a.a_id,record.a.a_type,record.a.a_name);
			rt_log("%d %d %d %d\n",record.a.a_m,record.a.a_n,
d182 2
a183 2
				  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
				  rt_vls_free(&tmp_vls);
d186 1
a186 1
				rt_log("%c %d %d %d\n",record.b.b_id,record.b.b_type,record.b.b_n,record.b.b_ngranule);
d189 2
a190 2
						rt_log("%10.4f ",record.b.b_values[kk]*base2local);
					rt_log("\n");
d196 1
a196 1
			rt_log("%c %d %s %d\n", record.s.s_id,
d201 2
a202 2
					rt_log("%10.4f ",record.s.s_values[j]*base2local);
				rt_log("\n");
d206 1
a206 1
			rt_log("%c '%c' %s %d %d %d %d %d \n",
d217 2
a218 2
				  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
				  rt_vls_free(&tmp_vls);
d221 1
a221 1
				rt_log("%c %c %s\n",
d227 1
a227 1
				rt_log("\n");
d231 1
a231 1
			rt_log("POLYGON: not implemented yet\n");
d235 1
a235 1
			rt_log("SPLINE: not implemented yet\n");
d240 2
a241 2
	Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	rt_vls_free(&tmp_vls);
d494 1
a494 1
	struct rt_vls str;
d496 1
a496 1
	rt_vls_init( &str );
d499 1
a499 1
	  struct rt_vls tmp_vls;
d501 4
a504 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "nesting exceeds %d levels\n",MAX_LEVELS);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d571 1
a571 1
	Tcl_AppendResult(interp, rt_vls_addr(&str), (char *)NULL);
d584 1
a584 1
  struct rt_vls tmp_vls;
d586 1
a586 1
  rt_vls_init(&tmp_vls);
d590 1
a590 1
      rt_vls_printf(&tmp_vls, "%f\t",m[i]);
d592 1
a592 1
      rt_vls_printf(&tmp_vls, "%f\n",m[i]);
d594 1
a594 1
      rt_vls_printf(&tmp_vls, "%f\n",m[i]*base2local);
d597 2
a598 2
  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
  rt_vls_free(&tmp_vls);
d646 1
a646 1
	  rt_free(sofar, "path string");
d667 1
a667 1
	      rt_free(sofar, "path string");
d672 1
a672 1
	    GETUNION(curtree, tree);
d681 1
a681 1
	pip = (struct push_id *) rt_malloc(sizeof(struct push_id),
d691 1
a691 1
	GETUNION(curtree, tree);
d839 1
a839 1
			rt_free((char *)pip, "Push ident");
d901 1
a901 1
		rt_free((char *)pip, "Push ident");
d1022 1
a1022 1
		rt_free( (char *)use, "Free_uses: use" );
d1061 1
a1061 1
		use = (struct object_use *)rt_malloc( sizeof( struct object_use ), "Make_new_name: use" );
d1361 1
a1361 1
			rt_free( (char *)rp, "rp[]" );
d1427 1
a1427 1
	struct rt_vls tmp_vls;
d1432 1
a1432 1
	rt_vls_init(&tmp_vls);
d1463 1
a1463 1
				  rt_log( "\n\tOccurrence #%d:\n", count );
d1477 2
a1478 2
		Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		rt_vls_free(&tmp_vls);
d1489 1
a1489 1
		rt_free( (char *)rp, "f_showmats: rp" );
d1502 2
a1503 2
	Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	rt_vls_free(&tmp_vls);
d1631 1
a1631 1
		poly_int = (struct rt_pg_internal *)rt_malloc( sizeof( struct rt_pg_internal ), "f_nmg_simplify: poly_int" );
d1762 1
a1762 1
			rt_free( (char *)rtip, "f_make_bb: rtip" );
d1778 1
a1778 1
				rt_free( (char *)rtip, "f_make_bb: rtip" );
d1794 1
a1794 1
			rt_free( (char *)rtip, "f_make_bb: rtip" );
d1832 1
a1832 1
				rt_free( (char *)rtip, "f_make_bb: rtip" );
d1861 1
a1861 1
					rt_free( (char *)rtip, "f_make_bb: rtip" );
d1915 1
a1915 1
	rt_free( (char *)rtip, "f_make_bb: rtip" );
d1976 1
a1976 1
	struct rt_vls v;
d1988 1
a1988 1
	rt_vls_init( &v );
d1990 1
a1990 1
	rt_vls_strcat( &v, "e" );
d2010 2
a2011 2
				rt_vls_strcat( &v, " " );
				rt_vls_strcat( &v, dp->d_namep );
d2021 2
a2022 2
		new_argv = (char **)rt_calloc( lim+1, sizeof( char *), "f_eac: new_argv" );
		new_argc = rt_split_cmd( new_argv, lim+1, rt_vls_addr( &v ) );
d2024 2
a2025 2
		rt_vls_free( &v );
		rt_free( (char *)new_argv, "f_eac: new_argv" );
d2030 1
a2030 1
		rt_vls_free( &v );
d2046 1
a2046 1
	struct rt_vls v;
d2058 1
a2058 1
	rt_vls_init( &v );
d2060 1
a2060 1
	rt_vls_strcat( &v, "e" );
d2081 2
a2082 2
				rt_vls_strcat( &v, " " );
				rt_vls_strcat( &v, dp->d_namep );
d2093 2
a2094 2
		new_argv = (char **)rt_calloc( lim+1, sizeof( char *), "f_eac: new_argv" );
		new_argc = rt_split_cmd( new_argv, lim+1, rt_vls_addr( &v ) );
d2096 2
a2097 2
		rt_vls_free( &v );
		rt_free( (char *)new_argv, "f_eac: new_argv" );
d2102 1
a2102 1
		rt_vls_free( &v );
@


11.20
log
@Added "eac", "eid", and "whatid" commands.
@
text
@d1976 3
d1988 5
a2000 2
				char *av[3];

d2010 3
a2012 5
				av[0] = "e";
				av[1] = dp->d_namep;
				av[2] = (char *)NULL;

				(void) f_edit( clientData, interp, 2, av );
d2016 17
a2032 1
	return TCL_OK;
@


11.19
log
@Minor mod to xpush command.
@
text
@d1928 158
@


11.18
log
@no need to keep initializing identity
@
text
@d1004 3
d1015 3
a1017 1
			/* never used, so delete directory entry */
d1068 5
a1072 1
		if( use_no == 0 ) /* Add an entry for the original at the end of the list */
@


11.17
log
@hack to appease sun4's complaining about aggregate initialization
@
text
@d318 1
d320 1
d921 1
d925 1
@


11.16
log
@Minor fix for f_xpush.
@
text
@d1906 1
a1906 1
	  char *av[] = {"e", NULL, NULL};
d1908 1
d1910 1
@


11.15
log
@Re-wrote f_make_bb().
@
text
@d1081 1
a1081 1
		RT_LIST_APPEND( &dp->d_use_hd, &use->l );
d1125 1
d1242 1
@


11.14
log
@Still Tcl'ing the code
@
text
@d1686 4
a1689 128
static void
Get_region_rpp( rtip,  pathp, reg_min, reg_max )
struct rt_i	*rtip;
struct db_full_path *pathp;
point_t reg_min;
point_t reg_max;
{
	struct region *regp;
	char *path;

	VSETALL( reg_min, MAX_FASTF );
	VREVERSE( reg_max, reg_min );

	path = db_path_to_string( pathp );
	for( regp = rtip->HeadRegion ; regp != REGION_NULL; regp = regp->reg_forw )
	{
		if( !strcmp( path, regp->reg_name ) )
			break;
	}

	if( !regp )
	{
	  Tcl_AppendResult(interp, "Could not find region ", path, "\n", (char *)NULL);
	  return;
	}

	if( rt_bound_tree( regp->reg_treetop, reg_min, reg_max ) )
	{
	  Tcl_AppendResult(interp, "rt_bound_tree failed for ", path, "\n", (char *)NULL);
	  return;
	}
	rt_free( path, "Get_region_rpp: path" );
}

static void
Get_comb_rpp( rtip, dp, pathp, comb_min, comb_max )
struct rt_i		*rtip;
struct directory	*dp;
struct db_full_path	*pathp;
vect_t			comb_min;
vect_t			comb_max;
{
	union record *rec;
	int i;
	vect_t tmp_min, tmp_max;

	if( (dp->d_flags & DIR_SOLID) || (dp->d_flags & DIR_REGION ) )
	{
	  Tcl_AppendResult(interp, "Get_comb_rpp called for region or solid (",
			   dp->d_namep, ")\n", (char *)NULL);
	  rt_bomb(  "Get_comb_rpp called for region or solid" );
	}

	VSETALL( comb_min, MAX_FASTF );
	VREVERSE( comb_max, comb_min );
	VSETALL( tmp_min, MAX_FASTF );
	VREVERSE( tmp_max, tmp_min );

	rec = db_getmrec( dbip, dp );
	for( i=1 ; i<dp->d_len ; i++ )
	{
		struct directory *dp2;
		struct db_full_path tmp_pathp;
		vect_t sub_min, sub_max;

		if( rec[i].u_id != ID_MEMB )
		{
		  Tcl_AppendResult(interp, "didn't get member records for ",
				   dp->d_namep, "\n", (char *)NULL);
		  continue;
		}

		dp2 = db_lookup( dbip, rec[i].M.m_instname, LOOKUP_NOISY );
		if( dp2 == DIR_NULL )
			rt_bomb( "db_lookup failed" );

		db_full_path_init( &tmp_pathp );
		db_dup_full_path( &tmp_pathp, pathp );
		db_add_node_to_full_path( &tmp_pathp, dp2 );

		if( rec[i].M.m_relation != '-' )
		{
			if( (dp2->d_flags & DIR_SOLID) || (dp2->d_flags & DIR_REGION) )
				Get_region_rpp( rtip, &tmp_pathp, sub_min, sub_max );
			else
				Get_comb_rpp( rtip, dp2, &tmp_pathp, sub_min, sub_max );

		}
		db_free_full_path( &tmp_pathp );

		switch( rec[i].M.m_relation )
		{
			case 'u':
				VMIN( tmp_min, sub_min );
				VMAX( tmp_max, sub_max );
				VMIN( comb_min, tmp_min );
				VMAX( comb_max, tmp_max );
				VSETALL( tmp_min, MAX_FASTF );
				VREVERSE( tmp_max, tmp_min );
				break;
			case '-':
				break;
			case '+':
				VMAX( tmp_min, sub_min );
				VMIN( tmp_max, sub_max );
				break;
			default:
			  {
			    struct rt_vls tmp_vls;

			    rt_vls_init(&tmp_vls);
			    rt_vls_printf(&tmp_vls, "Illegal operation (%c) in combination (%s) for member (%s)\n", rec[i].M.m_relation, dp->d_namep, rec[i].M.m_instname );
			    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
			    rt_vls_free(&tmp_vls);
			  }

			  break;
		}
		if( sub_min[X] < MAX_FASTF )
		{
			VMIN( tmp_min, sub_min );
			VMAX( tmp_max, sub_max );
			VMIN( comb_min, tmp_min );
			VMAX( comb_max, tmp_max );
		}
	}
	rt_free( (char *)rec, "Get_comb_rpp: rec" );
}
d1699 1
a1699 1
	int			i;
d1706 1
d1713 7
d1727 1
d1730 1
a1730 1
	  Tcl_AppendResult(interp, "rt_dirbuild failure for ", dbip->dbi_filename,
d1735 2
a1736 1
	if( rt_gettrees( rtip, argc-2, (CONST char **)&argv[2], 1 ) )
d1738 45
a1782 4
	  Tcl_AppendResult(interp, "rt_gettrees failed\n", (char *)NULL);
	  rt_clean( rtip );
	  rt_free( (char *)rtip, "f_make_bb: rtip" );
	  return TCL_ERROR;
d1785 4
d1793 10
a1802 1
		union tree *final_tree;
d1804 4
a1807 2
		if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY ) ) == DIR_NULL )
			exit( 1 );
d1809 1
a1809 1
		if( (dp->d_flags & DIR_REGION) || (dp->d_flags & DIR_SOLID) )
d1811 9
a1819 6
			vect_t reg_min, reg_max;

			db_full_path_init( &path );
			db_add_node_to_full_path( &path, dp );
			Get_region_rpp( rtip, &path, reg_min, reg_max );
			db_free_full_path( &path );
d1825 1
a1825 1
			vect_t comb_min,comb_max;
d1827 25
a1851 6
			db_full_path_init( &path );
			db_add_node_to_full_path( &path, dp );
			Get_comb_rpp( rtip, dp, &path, comb_min, comb_max );
			VMINMAX( rpp_min, rpp_max, comb_min );
			VMINMAX( rpp_min, rpp_max, comb_max );
			db_free_full_path( &path );
d1855 1
d1866 1
d1872 1
d1880 1
d1889 1
d1895 2
d1902 1
@


11.13
log
@still tcl-converting
@
text
@d159 4
a162 2
	/* interupts */
	(void)signal( SIGINT, sig2);    /* allow interupts */
d287 4
a290 2
	/* interupts */
	(void)signal( SIGINT, sig2);    /* allow interupts */
d377 4
a380 2
	/* interupts */
	(void)signal( SIGINT, sig2);    /* allow interupts */
d428 4
a431 2
	/* No interupts */
	(void)signal( SIGINT, SIG_IGN );
@


11.12
log
@convert commands to Tcl
@
text
@d1923 7
a1929 1
	return f_edit( clientData, interp, 2, argv );
@


11.11
log
@remove unused XMGED stuff
@
text
@d50 3
a52 1
f_shells( argc, argv )
d65 3
d69 1
a69 1
		return CMD_BAD;
d73 2
a74 2
		rt_log("rt_db_get_internal() error\n");
		return CMD_BAD;
d79 2
a80 2
		rt_log( "Object is not an NMG!!!\n" );
		return( CMD_BAD );
d112 1
a112 2
			    	ALLOC_ERR;
				return CMD_BAD;
d127 2
a128 2
				rt_log("rt_db_put_internal() failure\n");
				return( CMD_BAD );
d136 1
a136 1
	return( CMD_OK );
d142 3
a144 1
f_tabobj(argc, argv)
d151 4
d156 3
d166 4
a169 2
			READ_ERR;
			return CMD_BAD;
d179 4
a182 2
					READ_ERR;
					return CMD_BAD;
d214 4
a217 2
					READ_ERR;
					return CMD_BAD;
d236 5
a240 1
	return CMD_OK;
d267 3
a269 1
f_pathsum(argc, argv)
d275 3
d300 3
a302 2
		rt_log("Enter the path (space is delimiter): ");
		return CMD_MORE;
d310 2
a311 2
		if( (obj[i] = db_lookup( dbip, argv[pos_in+i], LOOKUP_NOISY )) == DIR_NULL)
			return CMD_BAD;
d320 6
a325 5
		/* path not found */
		rt_log("PATH:  ");
		for(i=0; i<objpos; i++)
			rt_log("/%s",obj[i]->d_namep);
		rt_log("  NOT FOUND\n");
d328 1
a328 1
	return CMD_OK;
d339 3
a341 1
f_copyeval(argc, argv)
d353 3
d358 4
a361 2
		rt_log( "Enter new_solid_name and full path to old_solid (seperate path components with spaces not /)\n" );
		return CMD_MORE;
d367 2
a368 2
		rt_log("%s: already exists\n",argv[1]);
		return CMD_BAD;
d379 2
a380 2
		if( (obj[i-2] = db_lookup( dbip, argv[i], LOOKUP_NOISY)) == DIR_NULL)
			return CMD_BAD;
d387 2
a388 3
		db_free_external( &external );
		READ_ERR;
		return CMD_BAD;
d394 4
a397 4
		rt_log( "Final name in full path must be a solid, %s is not a solid\n",
			argv[argc-1] );
		db_free_external( &external );
		return CMD_BAD;
d403 4
a406 3
		rt_log( "solid import failure on %s\n" , argv[argc-1] );
		db_free_external( &external );
		return CMD_BAD;
d412 8
a419 6
		rt_log("PATH:  ");
		for(i=0; i<objpos; i++)
			rt_log("/%s",obj[i]->d_namep);
		rt_log("  NOT FOUND\n");
		db_free_external( &external );
		return CMD_BAD;
d432 3
a434 3
		db_free_external( &external );
		rt_log( "f_copyeval: rt_generic_xform failed\n" );
		return CMD_BAD;
d439 4
a442 4
		db_free_external( &new_ext );
		db_free_external( &external );
		rt_log( "f_copyeval: export failure for new solid\n" );
		return CMD_BAD;
d448 3
a450 4
		db_free_external( &new_ext );
		db_free_external( &external );
	    	ALLOC_ERR;
		return CMD_BAD;
d455 3
a457 4
		db_free_external( &new_ext );
		db_free_external( &external );
		WRITE_ERR;
		return CMD_BAD;
d462 1
a462 1
	return CMD_OK;
d489 12
a500 5
		rt_log("nesting exceeds %d levels\n",MAX_LEVELS);
		for(i=0; i<MAX_LEVELS; i++)
			rt_log("/%s", path[i]->d_namep);
		rt_log("\n");
		return;
d550 2
a551 1
		rt_log("/%s",path[k]->d_namep);
d553 2
a554 2
		rt_log("/%s\n",record.s.s_name);
		return;
d559 1
a559 1
	rt_log("/");
d561 1
a561 1
	rt_log( "%s", rt_vls_addr(&str) );
d573 13
a585 1
	register int i;
d587 2
a588 8
	for(i=0; i<16; i++) {
		if( (i+1)%4 )
			rt_log("%f\t",m[i]);
		else if(i == 15)
			rt_log("%f\n",m[i]);
		else
			rt_log("%f\n",m[i]*base2local);
	}
d632 5
a636 4
		char *sofar = db_path_to_string(pathp);
		rt_log("push_leaf(%s) path='%s'\n",
		    rt_functab[id].ft_name, sofar);
		rt_free(sofar, "path string");
d650 17
a666 15
		if (pip->pi_dir == dp ) {
			if (!rt_mat_is_equal(pip->pi_mat,
			    tsp->ts_mat, tsp->ts_tol)) {
			    	char *sofar = db_path_to_string(pathp);
				rt_log("push_leaf: matrix mismatch between '%s' and prior reference.\n",
				    sofar, dp->d_namep);
				rt_free(sofar, "path string");
				push_error = 1;
			}
			RES_RELEASE(&rt_g.res_worker);
			GETUNION(curtree, tree);
			curtree->magic = RT_TREE_MAGIC;
			curtree->tr_op = OP_NOP;
			return curtree;
		}
d737 3
a739 1
f_push(argc, argv)
d759 3
d790 1
a790 1
			rt_log("push: usage push [-l levels] [-P processors] [-d] root [root2 ...]\n");
d832 2
a833 2
		rt_log("push:\tdb_walk_tree failed or there was a solid moving\n\tin two or more directions\n");
		return CMD_BAD;
d843 4
a846 4
			rt_log("f_push: Read error fetching '%s'\n",
			    pip->pi_dir->d_namep);
			push_error = -1;
			continue;
d850 5
a854 5
			rt_log("push(%s): solid import failure\n",
			    pip->pi_dir->d_namep);
			if (es_int.idb_ptr) rt_functab[id].ft_ifree( &es_int);
			db_free_external( &es_ext);
			continue;
d858 2
a859 1
			rt_log("push(%s): solid export failure\n", pip->pi_dir->d_namep);
d895 1
a895 1
	return push_error ? CMD_BAD : CMD_OK;
d939 1
a939 1
	RT_CK_DIR( dp );
d941 2
a942 2
	dp->d_nref = 0;
	dp->d_uses = 0;
d944 2
a945 2
	if( RT_LIST_NON_EMPTY( &dp->d_use_hd ) )
		rt_log( "List for %s is not empty\n" , dp->d_namep );
d1092 3
a1094 2
		rt_log( "Copy_solid: %s is not a solid!!!!\n", dp->d_namep );
		return( DIR_NULL );
d1128 3
a1130 2
		rt_log( "Ran out of uses for solid %s\n" , dp->d_namep );
		return( DIR_NULL );
d1137 3
a1139 2
		rt_log( "Cannot get external form of %s\n" , dp->d_namep );
		return( DIR_NULL );
d1147 3
a1149 2
		rt_log( "Cannot import solid %s\n" , dp->d_namep );
		return( DIR_NULL );
d1156 3
a1158 2
		rt_log( "Cannot write copy solid (%s) to database\n" , found->d_namep );
		return( DIR_NULL );
d1212 3
a1214 2
			rt_log( "Failed to copy object %s\n" , dp2->d_namep );
			return( DIR_NULL );
d1244 3
a1246 2
		rt_log( "Ran out of uses for combination %s\n" , dp->d_namep );
		return( DIR_NULL );
d1251 7
a1257 6
		if( db_alloc( dbip, found, dp->d_len ) < 0 )
		{
			rt_log( "Cannot allocate space for combination %s\n" , found->d_namep );
			return( DIR_NULL );
		}
		NAMEMOVE( found->d_namep, rp[0].c.c_name );
d1262 3
a1264 2
		rt_log( "Failed to write combination %s to database\n" , found->d_namep );
		return( DIR_NULL );
d1284 3
a1286 1
f_xpush( argc, argv )
d1295 3
d1300 1
a1300 1
		return CMD_BAD;
d1323 3
a1325 2
				rt_log( "Cannot get records for %s\n" , dp->d_namep );
				return CMD_BAD;
d1388 1
a1388 1
	return CMD_OK;
d1392 3
a1394 1
f_showmats( argc, argv )
d1404 4
d1409 1
d1420 1
a1420 1
			return CMD_BAD;
d1422 1
a1422 1
		rt_log( "%s\n", parent );
d1426 1
a1426 2
			READ_ERR;
			return CMD_BAD;
d1431 1
d1440 2
a1441 1
					rt_log( "\n\tOccurrence #%d:\n", count );
d1453 4
d1459 3
a1461 2
			rt_log( "%s is not a member of %s\n", child, parent );
			return CMD_BAD;
d1469 1
a1469 1
	rt_log( "%s\n", parent );
d1472 1
a1472 1
		rt_log( "\nAccumulated matrix (using first occurrence of each object):\n" );
d1474 3
a1476 1
		rt_log( "\nAccumulated matrix:\n");
d1478 3
d1482 1
a1482 1
	return CMD_OK;
d1486 3
a1488 1
f_nmg_simplify( argc, argv )
d1508 2
a1509 5
	if( argc < 3 || argc > 4 )
	{
		rt_log( "Usage: nmg_simplify [arb|ell|tgc|poly] new_solid_name nmg_solid\n" );
		return CMD_BAD;
	}
d1526 2
a1527 2
			rt_log( "Usage: nmg_simplify [arb|ell|tgc|poly] new_solid_name nmg_solid\n" );
			return CMD_BAD;
d1541 2
a1542 2
		rt_log( "%s already exists\n", new_name );
		return CMD_BAD;
d1547 2
a1548 2
		rt_log( "%s does not exist\n", nmg_name );
		return CMD_BAD;
d1553 2
a1554 2
		rt_log("rt_db_get_internal() error\n");
		return CMD_BAD;
d1559 3
a1561 3
		rt_log( "%s is not an NMG solid\n", nmg_name );
		rt_db_free_internal( &nmg_intern );
		return CMD_BAD;
d1579 4
a1582 3
			rt_db_free_internal( &nmg_intern );
			rt_log( "Failed to construct an ARB equivalent to %s\n", nmg_name );
			return CMD_OK;
d1598 4
a1601 3
			rt_db_free_internal( &nmg_intern );
			rt_log( "Failed to construct a TGC equivalent to %s\n", nmg_name );
			return CMD_OK;
d1618 3
a1620 3
			rt_db_free_internal( &nmg_intern );
			rt_log( "%s is not a closed surface, cannot make a polysolid\n", nmg_name );
			return CMD_OK;
d1632 2
a1633 1
			rt_log( "wire loops in %s have been ignored in conversion\n", nmg_name );
d1636 2
a1637 1
			rt_log( "wire edges in %s have been ignored in conversion\n", nmg_name );
d1640 2
a1641 1
			rt_log( "Single vertexuse in shell of %s has been ignored in conversion\n", nmg_name );
d1647 3
a1649 3
			rt_log( "f_nmg_simplify: export failure\n" );
			rt_functab[new_intern.idb_type].ft_ifree( &new_intern );
			return CMD_BAD;
d1660 2
a1661 3
			db_free_external( &new_extern );
		    	ALLOC_ERR;
			return CMD_BAD;
d1666 2
a1667 3
			db_free_external( &new_extern );
			WRITE_ERR;
			return CMD_BAD;
d1670 1
a1670 1
		return CMD_OK;
d1672 4
a1675 2
	rt_log( "simplification to %s is not yet supported\n", argv[1] );
	return CMD_BAD;
d1700 2
a1701 2
		rt_log( "Could not find region %s\n", path );
		return;
d1706 2
a1707 2
		rt_log( "rt_bound_tree failed for %s\n",path );
		return;
d1726 3
a1728 2
		rt_log( "Get_comb_rpp called for region or solid (%s)\n", dp->d_namep );
		rt_bomb(  "Get_comb_rpp called for region or solid" );
d1745 3
a1747 2
			rt_log( "didn't get member records for %s\n", dp->d_namep );
			continue;
d1785 10
a1794 3
				rt_log( "Illegal operation (%c) in combination (%s) for member (%s)\n",
					rec[i].M.m_relation, dp->d_namep, rec[i].M.m_instname );
				break;
d1808 3
a1810 1
f_make_bb( argc, argv )
d1825 2
a1826 5
	if( argc < 3 )
	{
		rt_log( "Usage: make_bb new_solid_name object1 [object2 object3 ...]\n" );
		return CMD_BAD;
	}
d1831 2
a1832 2
		rt_log( "%s already exists\n", new_name );
		return CMD_BAD;
d1837 3
a1839 2
		rt_log( "rt_dirbuild failure for %s\n", dbip->dbi_filename );
		return CMD_BAD;
d1844 4
a1847 4
		rt_log( "rt_gettrees failed\n" );
		rt_clean( rtip );
		rt_free( (char *)rtip, "f_make_bb: rtip" );
		return CMD_BAD;
d1900 3
a1902 3
		rt_log( "f_make_bb: export failure\n" );
		rt_functab[new_intern.idb_type].ft_ifree( &new_intern );
		return CMD_BAD;
d1909 2
a1910 3
		db_free_external( &new_extern );
	    	ALLOC_ERR;
		return CMD_BAD;
d1915 2
a1916 3
		db_free_external( &new_extern );
		WRITE_ERR;
		return CMD_BAD;
d1923 1
a1923 1
	return f_edit( 2, argv );
@


11.10
log
@Added support for make_bb command.
@
text
@a146 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );
#else
a147 1
#endif
a257 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );
#else
a258 1
#endif
a336 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );
#else
a337 1
#endif
@


11.9
log
@Added "nmg_simplify" command.
@
text
@d47 1
d1591 241
@


11.8
log
@Fixed bug in f_showmats().
@
text
@d1402 189
@


11.7
log
@Added f_showmats().
@
text
@d1375 1
a1375 1
					mat_mul( tmp_mat, matrix, acc_matrix );
@


11.6
log
@Added xpush command.
@
text
@d12 1
d1323 76
@


11.5
log
@Can't do rt_log( rt_vls_addr( &str ) ), need to use "%s" format.
Otherwise, can over-run format string in printf.
@
text
@d19 1
d544 1
a544 1
			rt_log("%f\t",m[i]);
d882 442
@


11.4
log
@Fixed missing return value.

@
text
@d525 1
a525 1
	rt_log( rt_vls_addr(&str) );
@


11.3
log
@Added "shells" command.
@
text
@d104 2
a105 1
			    	ALLOC_ERR_return;
@


11.2
log
@merging xmged sources
@
text
@d27 1
d30 1
d41 89
@


11.1
log
@Release_4.4
@
text
@d52 5
a56 1
	(void)signal( SIGINT, sig2 );
d167 5
a171 1
	(void)signal( SIGINT, sig2 );
d250 5
a254 1
	(void)signal( SIGINT, sig2 );
@


10.13
log
@Converted to new do_list
@
text
@@


10.12
log
@Temporary hack to get rt_log and do_list on the same stream
@
text
@d352 1
d354 2
d420 2
a421 1
	do_list( stderr, dp, 1 );
@


10.11
log
@Converted putchar to rt_log
@
text
@d417 1
a417 1
	do_list( stdout, dp, 1 );
@


10.10
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d111 1
a111 1
				(void)putchar('\n');
@


10.9
log
@Irix 6.0.
@
text
@d62 2
a63 2
			(void)printf("%c %d %s ",record.a.a_id,record.a.a_type,record.a.a_name);
			(void)printf("%d %d %d %d\n",record.a.a_m,record.a.a_n,
d72 1
a72 1
				(void)printf("%c %d %d %d\n",record.b.b_id,record.b.b_type,record.b.b_n,record.b.b_ngranule);
d75 2
a76 2
						(void)printf("%10.4f ",record.b.b_values[kk]*base2local);
					(void)printf("\n");
d82 1
a82 1
			(void)printf("%c %d %s %d\n", record.s.s_id,
d87 2
a88 2
					(void)printf("%10.4f ",record.s.s_values[j]*base2local);
				(void)printf("\n");
d92 1
a92 1
			(void)printf("%c '%c' %s %d %d %d %d %d \n",
d105 1
a105 1
				(void)printf("%c %c %s\n",
d115 1
a115 1
			(void)printf("POLYGON: not implemented yet\n");
d119 1
a119 1
			(void)printf("SPLINE: not implemented yet\n");
d177 1
a177 1
		(void)printf("Enter the path (space is delimiter): ");
d197 1
a197 1
		(void)printf("PATH:  ");
d199 2
a200 2
			(void)printf("/%s",obj[i]->d_namep);
		(void)printf("  NOT FOUND\n");
d228 1
a228 1
		printf( "Enter new_solid_name and full path to old_solid (seperate path components with spaces not /)\n" );
d235 1
a235 1
		(void)printf("%s: already exists\n",argv[1]);
d280 1
a280 1
		(void)printf("PATH:  ");
d282 2
a283 2
			(void)printf("/%s",obj[i]->d_namep);
		(void)printf("  NOT FOUND\n");
d354 1
a354 1
		(void)printf("nesting exceeds %d levels\n",MAX_LEVELS);
d356 2
a357 2
			(void)printf("/%s", path[i]->d_namep);
		(void)printf("\n");
d408 1
a408 1
		(void)printf("/%s",path[k]->d_namep);
d410 1
a410 1
		(void)printf("/%s\n",record.s.s_name);
d416 1
a416 1
	(void)printf("/");
d433 1
a433 1
			(void)printf("%f\t",m[i]);
d435 1
a435 1
			(void)printf("%f\t",m[i]);
d437 1
a437 1
			(void)printf("%f\n",m[i]*base2local);
d632 1
a632 1
			printf("push: usage push [-l levels] [-P processors] [-d] root [root2 ...]\n");
@


10.8
log
@finished construction of copyeval command.
@
text
@d351 1
a351 5
	int nparts, i, k, j;
	int arslen, npt, n;
	int	kk = 0;
	vect_t	vertex;
	vect_t	vec;
a471 1
	struct rt_db_internal intern;
d591 3
a593 1
	int	levels;
d619 1
d621 1
@


10.7
log
@Factored ifdefs
@
text
@d219 5
a223 1
	register struct directory *dp;
a224 6
	int	j;
	int	k;
	int	kk = 1;
	int	ngran;
	int	pos_in;
	vect_t	vec;
d226 5
a230 2
	prflag = 0;
	pos_in = argc;
d232 6
a237 2
	printf("The copyeval command is currently being reconstructed.\n\
Sorry for the inconvenience.\n");
d239 1
a239 2
#if 0
	argcnt = 0;
a243 6
	/* get the path - ignore any input so far */
	(void)printf("Enter the complete path: ");
	argcnt = getcmd(args);
	args += argcnt;
	objpos = argcnt;

d245 3
a247 2
	for(i=0; i<objpos; i++) {
		if( (obj[i] = db_lookup( dbip, cmd_args[pos_in+i], LOOKUP_NOISY)) == DIR_NULL)
d251 5
a255 2
	/* check if last path member is a solid */
	if( db_get( dbip,  obj[objpos-1], &record, 0, 1) < 0 ) {
d257 1
a257 1
		return;
d259 7
a265 3
	if(record.u_id != ID_SOLID && record.u_id != ID_ARS_A &&
		record.u_id != ID_BSOLID && record.u_id != ID_P_HEAD) {
		(void)printf("Bottom of path is not a solid\n");
d269 5
a273 7
	/* get the new solid name */
	(void)printf("Enter the new solid name: ");
	argcnt = getcmd(args);

	/* check if new solid name already exists in description */
	if( db_lookup( dbip, cmd_args[args], LOOKUP_QUIET) != DIR_NULL ) {
		(void)printf("%s: already exists\n",cmd_args[args]);
d277 1
a277 2
	mat_idn( identity );
	mat_idn( xform );
a278 2
	trace(obj[0], 0, identity, CPEVAL);

d284 1
d295 6
a300 43
	if(saverec.u_id == ID_ARS_A) {
		NAMEMOVE(cmd_args[args], saverec.a.a_name);
		ngran = saverec.a.a_totlen;
		if( (dp = db_diradd( dbip, saverec.a.a_name, -1, ngran+1, DIR_SOLID)) == DIR_NULL ||
		    db_alloc( dbip, dp, ngran+1 ) < 0 )  {
		    	ALLOC_ERR;
			return CMD_BAD;
		}
		if( db_put( dbip, dp, &saverec, 0, 1 ) < 0 ) {
			WRITE_ERR;
			return CMD_BAD;
		}

		/* apply transformation to the b-records */
		for(i=1; i<=ngran; i++) {
			if( db_get( dbip, obj[objpos-1], &record, i , 1) < 0 ) {
				READ_ERR;
				return CMD_BAD;
			}
			if(i == 1) {
				/* vertex */
				MAT4X3PNT( vec, xform,
						&record.b.b_values[0] );
				VMOVE(&record.b.b_values[0], vec);
				kk = 1;
			}


			/* rest of the vectors */
			for(k=kk; k<8; k++) {
				MAT4X3VEC( vec, xform,
						&record.b.b_values[k*3] );
				VMOVE(&record.b.b_values[k*3], vec);
			}
			kk = 0;

			/* write this b-record */
			if( db_put( dbip, dp, &record, i, 1) < 0 ) {
				WRITE_ERR;
				return CMD_BAD;
			}
		}
		return CMD_OK;
d303 5
a307 2
	if(saverec.u_id == ID_BSOLID) {
		(void)printf("B-SPLINEs not implemented\n");
d311 6
a316 2
	if(saverec.u_id == ID_P_HEAD) {
		(void)printf("POLYGONs not implemented\n");
d320 6
a325 18
	if(saverec.u_id == ID_SOLID) {
		NAMEMOVE(cmd_args[args], saverec.s.s_name);
		if( (dp = db_diradd( dbip, saverec.s.s_name, -1, 1, DIR_SOLID)) == DIR_NULL ||
		    db_alloc( dbip, dp, 1 ) < 0 )  {
			ALLOC_ERR;
			return CMD_BAD;
		}
		MAT4X3PNT( vec, xform, &saverec.s.s_values[0] );
		VMOVE(&saverec.s.s_values[0], vec);
		for(i=3; i<=21; i+=3) {
			MAT4X3VEC( vec, xform, &saverec.s.s_values[i] );
			VMOVE(&saverec.s.s_values[i], vec);
		}
		if( db_put( dbip, dp, &saverec, 0, 1 ) < 0 ){
			WRITE_ERR;
			return CMD_BAD;
		}
		return CMD_OK;
d327 2
a328 1
#endif
d330 1
a330 1
	return CMD_BAD;
@


10.6
log
@Expunged cmd_args[], numargs, and getcmd().
@
text
@d15 2
d19 3
a21 1
#ifdef BSD
a22 2
#else
#include <string.h>
@


10.5
log
@CoConverted f_ functions to use new command return codes.
@
text
@a30 6
extern int	args;		/* total number of args available */
extern int	argcnt;		/* holder for number of args added later */
extern int	newargs;	/* number of args from getcmd() */
extern int	numargs;	/* number of args */
extern char	*cmd_args[];	/* array of pointers to args */

d41 3
a43 1
f_tabobj( )
d52 2
a53 2
	for(i=1; i<numargs; i++) {
		if( (dp = db_lookup( dbip, cmd_args[i], LOOKUP_NOISY)) == DIR_NULL )
d164 1
a164 1
	if( strcmp( cmd_args[0], "paths" ) == 0 ) {
d168 1
a168 1
	if( strcmp( cmd_args[0], "listeval" ) == 0 ) {
a173 1
		pos_in = args = argc;
d176 1
a176 7
		argcnt = getcmd(args);
		args += argcnt;
		objpos = argcnt;
	} else {
		pos_in = args = 1;
		argcnt = argc-1;
		objpos = argc-1;
d179 3
d184 1
a184 1
		if( (obj[i] = db_lookup( dbip, cmd_args[pos_in+i], LOOKUP_NOISY)) == DIR_NULL)
d212 3
a214 1
f_copyeval( )
d227 6
a232 1
	pos_in = args = numargs;
d251 4
a254 1
	if( db_get( dbip,  obj[objpos-1], &record, 0, 1) < 0 )  READ_ERR_return;
d365 1
a644 2

	if ( argc <= 0) return -1;	/* FAIL */
@


10.4
log
@Union tree magic numbers
@
text
@d46 1
a46 1
void
d59 4
a62 1
		if( db_get( dbip, dp, &record, 0, 1) < 0 )  READ_ERR_return;
d70 4
a73 1
				if( db_get( dbip, dp, &record, j, 1) < 0 )  READ_ERR_return;
d103 4
a106 1
				if( db_get( dbip, dp, &record, j, 1) < 0 )  READ_ERR_return;
d124 1
a124 1
	return;
d150 1
a150 1
void
d193 1
a193 1
			return;
d208 2
d219 1
a219 1
void
d248 1
a248 1
			return;
d256 1
a256 1
		return;
d266 1
a266 1
		return;
d279 1
a279 1
		return;
d294 2
a295 1
		    	ALLOC_ERR_return;
d297 4
a300 2
		if( db_put( dbip, dp, &saverec, 0, 1 ) < 0 )
			WRITE_ERR_return;
d304 4
a307 2
			if( db_get( dbip, obj[objpos-1], &record, i , 1) < 0 )
				READ_ERR_return;
d326 4
a329 1
			if( db_put( dbip, dp, &record, i, 1) < 0 )  WRITE_ERR_return;
d331 1
a331 1
		return;
d336 1
a336 1
		return;
d341 1
a341 1
		return;
d348 2
a349 1
			ALLOC_ERR_return;
d357 5
a361 2
		if( db_put( dbip, dp, &saverec, 0, 1 ) < 0 )  WRITE_ERR_return;
		return;
d364 1
d712 1
a712 1
		return -1;
d773 1
a773 1
	return push_error;
@


10.3
log
@Upgrade the push function to handle all reasonable solids using
the import/export with matrix ability.  Also upgrade the tests
for solids going in to or more directions at the same time.
@
text
@d525 1
d544 1
@


10.2
log
@Changed "listeval" command to use do_list() routine for pretty printing.
@
text
@d29 1
d456 6
a461 6


/* structure to distinguish "pushed" solids */
struct idpush {
	char	i_name[NAMESIZE];
	mat_t	i_mat;
d463 4
a466 1
static struct idpush idpush, idbuf;
d468 1
a468 4
#define MAXSOL 2000
extern int discr[], idfd, rd_idfd;	/* from utility1 */
static int push_count;		/* count of solids to be pushed */
static int abort_flag;
d471 1
a471 1
 *		F _ P U S H ( )
d473 1
a473 1
 *	control routine for "pushing" transformations to bottom of paths
d475 4
d480 5
a484 2
void
f_push( )
d486 15
a500 12

	struct directory *dp, *tdp;
	int i, j, k, ii, ngran;
	int	kk = 0;
	vect_t	vec;

	(void)signal( SIGINT, sig2 );		/* interupts */

	/* open temp file */
	if( (idfd = creat("/tmp/mged_push", 0666)) < 0 ) {
		perror( "/tmp/mged_push" );
		return;
d502 20
a521 27
	rd_idfd = open( "/tmp/mged_push", 2 );

	for(i=1; i<numargs; i++) {
		if( (dp = db_lookup( dbip, cmd_args[i], LOOKUP_NOISY)) == DIR_NULL ) {
			(void)printf("Skip this object\n");
			continue;
		}
		push_count = 0;		/* NO solids yet */
		abort_flag = 0;
		mat_idn( identity );
		push(dp, 0, identity);
		if( abort_flag ) {
			/* Cannot push transformations for this object */
			(void)printf("%s: push failed\n",cmd_args[i]);
			continue;
		}
		/* It's okay to "push" this object */
		(void)signal( SIGINT, SIG_IGN );	/* no interupts */
		(void)lseek(rd_idfd, 0L, 0);
		for(j=0; j<push_count; j++) {
			(void)read(rd_idfd, &idpush, sizeof idpush);

			/* apply transformation to this solid */
			if( (tdp = db_lookup( dbip, idpush.i_name, LOOKUP_QUIET)) == DIR_NULL ) {
				(void)printf("push: cannot find solid (%s)\n",
						idpush.i_name);
				continue;
d523 4
a526 68
			if( db_get( dbip, tdp, &record, 0, 1) < 0 )  READ_ERR_return;
			switch( record.u_id ) {

			case ID_SOLID:
				MAT4X3PNT(	vec,
						idpush.i_mat,
						&record.s.s_values[0]	);
				VMOVE( &record.s.s_values[0], vec );
				for(k=3; k<=21; k+=3) {
					MAT4X3VEC(	vec,
							idpush.i_mat,
							&record.s.s_values[k]	);
					VMOVE( &record.s.s_values[k], vec );
				}
				if( db_put( dbip, tdp, &record, 0, 1 ) < 0 )
					WRITE_ERR_return;
			break;

			case ID_ARS_A:
				/* apply transformation to the b-records */
				ngran = record.a.a_totlen;
				for(ii=1; ii<=ngran; ii++) {
					if( db_get( dbip, tdp, &record, ii, 1) < 0 )
						READ_ERR_return;
					if(ii == 1) {
						/* vertex */
						MAT4X3PNT(	vec,
								idpush.i_mat,
								&record.b.b_values[0] );
						VMOVE( &record.b.b_values[0], vec );
						kk = 1;
					}

					/* rest of the vectors */
					for(k=kk; k<8; k++) {
						MAT4X3VEC(	vec,
								idpush.i_mat,
								&record.b.b_values[k*3] );
						VMOVE( &record.b.b_values[k*3], vec );
					}
					kk = 0;

					/* write this b-record */
					if( db_put( dbip, tdp, &record, ii, 1 ) < 0 )
						WRITE_ERR_return;
				}
			break;

			/*
			 * NOTE:  these cases are checked in "push" so won't reach here.
			 *	When splines and polygons are implemented, must update
			 *	this section.
			 */
			case ID_BSOLID:
				(void)printf("WARNING: (%s) SPLINE not pushed with other elements\n",
						record.B.B_name);
			break;

			case ID_P_HEAD:
				(void)printf("WARNING: (%s) POLYGON not pushed with other elements\n",
						record.p.p_name);
			break;

			default:
				(void)printf("push: unknown solid type (%c) \n",
						record.u_id);
			}	/* end of switch */

d528 27
a554 14

		/*
		 *	Finished all the paths for this object
		 *
		 *	Identitize all member matrices for this object
		 */
		identitize( dp );
		(void)printf("%s: transformations pushed\n",cmd_args[i]);
		(void)signal( SIGINT, sig2 );		/* interupts */
	}

	(void)close( idfd );
	(void)close( rd_idfd );
	(void)unlink( "/tmp/mged_push\0" );
d556 4
d561 24
d586 1
a586 3

/*
 *				P U S H ( )
d588 3
a590 4
 *	Given an object, traverses each path to bottom solid.
 *	This solid is checked against previous solids.
 * 	If this name appeared previously, then the matrices are checked.
 *	If matrices are different, then will not be able to "push" this object.
d592 3
d596 4
a599 5
void
push( dp, pathpos, old_xlate )
struct directory *dp;
int pathpos;
mat_t	old_xlate;
d601 44
a644 33
	struct directory *nextdp;
	mat_t new_xlate;
	int nparts, i, k, j;
	int dchar = 0;

	if( abort_flag == 99 )	/* go no further */
		return;

	if( pathpos >= MAX_LEVELS ) {
		(void)printf("nesting exceeds %d levels\n",MAX_LEVELS);
		for(i=0; i<MAX_LEVELS; i++)
			(void)printf("/%s", path[i]->d_namep);
		(void)printf("\n");
		abort_flag = 1;
		return;
	}

	if( db_get( dbip, dp, &record, 0, 1) < 0 )  READ_ERR_return;
	if( record.u_id == ID_COMB ) {
		nparts = dp->d_len-1;
		for(i=1; i<=nparts; i++) {
			mat_t	xmat;

			if( db_get( dbip, dp, &record, i, 1) < 0 )  READ_ERR_return;
			path[pathpos] = dp;
			if( (nextdp = db_lookup( dbip, record.M.m_instname, LOOKUP_NOISY)) == DIR_NULL )
				continue;

			rt_mat_dbmat( xmat, record.M.m_mat );
			mat_mul(new_xlate, old_xlate, xmat);

			/* Recursive call */
			push(nextdp, pathpos+1, new_xlate);
a645 1
		return;
d648 2
a649 18
	/* not a combination  -  should have a solid */
	if(record.u_id == ID_BSOLID) {
		(void)printf("push: (%s) SPLINE not implemented yet - abort\n",
				record.B.B_name);
		abort_flag = 1;
		return;
	}
	if(record.u_id == ID_P_HEAD) {
		(void)printf("push: (%s) POLYGON not implemented yet - abort\n",
				record.p.p_name);
		abort_flag = 1;
		return;
	}
	if(record.u_id != ID_SOLID && record.u_id != ID_ARS_A) {
		(void)printf("bad record type '%c' should be 'S' or 'A'\n",record.u_id);
		abort_flag = 1;
		return;
	}
d651 1
a651 2
	/* last (bottom) position */
	path[pathpos] = dp;
d653 34
a686 14
	/* check if this is a new or old solid */
	if(record.u_id == ID_SOLID) {
		(void)strncpy(idpush.i_name, record.s.s_name, NAMESIZE);
	}
	else {
		(void)strncpy(idpush.i_name, record.a.a_name, NAMESIZE);
	}
	mat_copy(idpush.i_mat, old_xlate);

	dchar = 0;
	for(i=0; i<NAMESIZE; i++) {
		if(idpush.i_name[i] == 0) 
			break;
		dchar += (idpush.i_name[i] << (i&7));
d688 40
d729 5
a733 18
	for(i=0; i<push_count; i++) {
		if(dchar == discr[i]) {
			/* possible match --- check closer */
			(void)lseek(rd_idfd, i*(long)sizeof idpush, 0);
			(void)read(rd_idfd, &idbuf, sizeof idpush);
			if( strcmp( idpush.i_name, idbuf.i_name ) == 0 ) {
				/* names are the same ... check matrices */
				if( check_mat(idpush.i_mat, idbuf.i_mat) == 1 ) {
					/* matrices are also equal---same solid */
					return;
				}
				/* BAD ... matrices are diff but names the same */
				(void)printf("Cannot push: solid (%s) has conflicts\n",
						idpush.i_name);
				abort_flag = 1;
				return;
			}
		}
d736 8
a743 6
	/* Have a NEW solid */
	discr[push_count++] = dchar;
	if(push_count > MAXSOL) {
		(void)printf("push: number of solids > max (%d)\n",MAXSOL);
		abort_flag = 99;
		return;
a744 4
	(void)lseek(idfd, 0L, 2);
	(void)write(idfd, &idpush, sizeof idpush);

	return;
d746 2
a749 3



a783 22
}





/*	C H E C K _ M A T ( )	 -  compares 4x4 matrices
 *		returns 1 if same.....0 otherwise
 */

check_mat( mat1, mat2 )
mat_t mat1, mat2;
{
	register int i;

	for(i=0; i<16; i++) {
		if( mat1[i] != mat2[i] )
			return( 0 );	/* different */
	}

	return( 1 );	/* same */

@


10.1
log
@Release_4.0
@
text
@a396 7
	/*
	 *	TO DO ..... include SPLINES and POLYGONS 
 	 */
	if(record.u_id != ID_SOLID && record.u_id != ID_ARS_A) {
		(void)printf("bad record type '%c' should be 'S' or 'A'\n",record.u_id);
		return;
	}
d428 3
a430 69
	if(record.u_id == ID_SOLID) {
		(void)printf("/%s:\n",record.s.s_name);
		MAT4X3PNT(vec, xform, &record.s.s_values[0]);
		VMOVE(&record.s.s_values[0], vec);
		for(i=3; i<=21; i+=3) {
			MAT4X3VEC(	vec, xform,
					&record.s.s_values[i] );
			VMOVE(&record.s.s_values[i], vec);
		}
		/* put parameters in "nice" format and print */
		pr_solid( &record.s );
		for( i=0; i < es_nlines; i++ )
			(void)printf("%s\n",&es_display[ES_LINELEN*i]);

		/* If in solid edit, re-compute solid params */
		if(state == ST_S_EDIT)
			pr_solid(&es_rec.s);

		return;
	}

	if(record.u_id == ID_ARS_A) {
		(void)printf("/%s:\n",record.a.a_name);
		n = record.a.a_n;
		(void)printf("%d curves  %d points per curve\n",record.a.a_m,n);
		arslen = record.a.a_totlen;
		for(i=1; i<=arslen; i++) {
			if( db_get( dbip, dp, &record, i, 1) < 0 )  READ_ERR_return;
			if( (npt = (n - ((record.b.b_ngranule-1)*8))) > 8 )
				npt = 8;
			if(i == 1) {
				/* vertex */
				MAT4X3PNT(	vertex,
						xform,
						&record.b.b_values[0] );
				VMOVE( &record.b.b_values[0], vertex );
				kk = 1;
			}
			/* rest of vectors */
			for(k=kk; k<npt; k++) {
				MAT4X3VEC(	vec,
						xform,
						&record.b.b_values[k*3] );
				VADD2(	&record.b.b_values[k*3],
					vertex,
					vec	);
			}
			kk = 0;
			/* print this granule */
			for(k=0; k<npt; k+=2) {
				for(j=k*3; (j<(k+2)*3 && j<npt*3); j++) 
					(void)printf("%10.4f ",record.b.b_values[j]);
				(void)printf("\n");
			}

		}
		return;
	}
	if(record.u_id == ID_P_HEAD) {
		(void)printf("/%s:\n",record.p.p_name);
		(void)printf("POLYGON data print not implemented\n");
		return;
	}
	if(record.u_id == ID_BSOLID) {
		(void)printf("/%s:\n",record.B.B_name);
		(void)printf("B-SPLINE data print not implemented\n");
		return;
	}

a431 5





@


9.6
log
@Fixed "paths" command to not prompt when command line args are given.
@
text
@@


9.5
log
@lint
@
text
@d141 3
a143 1
f_pathsum( )
a153 3
	pos_in = args = numargs;
	argcnt = 0;

d167 12
a178 5
	/* get the path - ignore any input so far */
	(void)printf("Enter the path (space is delimiter): ");
	argcnt = getcmd(args);
	args += argcnt;
	objpos = argcnt;
a197 1

@


9.4
log
@Added error checking around calls to db_*() routines
@
text
@d356 2
a357 1
	int arslen, kk, npt, n;
d553 2
a554 1
	int i, j, k, kk, ii, ngran;
@


9.3
log
@Eliminated use of rec.c.c_length, using instead dp->d_len-1
@
text
@d58 1
a58 1
		db_get( dbip, dp, &record, 0, 1);
d66 1
a66 1
				db_get( dbip, dp, &record, j, 1);
d96 1
a96 1
				db_get( dbip, dp, &record, j, 1);
d235 1
a235 1
	db_get( dbip,  obj[objpos-1], &record, 0, 1);
d275 6
a280 4
		if( (dp = db_diradd( dbip, saverec.a.a_name, -1, ngran+1, DIR_SOLID)) == DIR_NULL )
			return;
		db_alloc( dbip, dp, ngran+1 );
		db_put( dbip, dp, &saverec, 0, 1 );
d284 2
a285 1
			db_get( dbip, obj[objpos-1], &record, i , 1);
d304 1
a304 1
			db_put( dbip, dp, &record, i, 1);
d321 4
a324 2
		if( (dp = db_diradd( dbip, saverec.s.s_name, -1, 1, DIR_SOLID)) == DIR_NULL )
			return;
d331 1
a331 2
		db_alloc( dbip, dp, 1 );
		db_put( dbip, dp, &saverec, 0, 1 );
d368 1
a368 1
	db_get( dbip, dp, &record, 0, 1);
d375 1
a375 1
			db_get( dbip, dp, &record, i, 1);
d416 1
a416 1
		db_get( dbip, dp, &saverec, 0, 1);
d456 1
a456 1
			db_get( dbip, dp, &record, i, 1);
d590 1
a590 1
			db_get( dbip, tdp, &record, 0, 1);
d604 2
a605 1
				db_put( dbip, tdp, &record, 0, 1 );
d612 2
a613 1
					db_get( dbip, tdp, &record, ii, 1);
d633 2
a634 1
					db_put( dbip, tdp, &record, ii, 1 );
d709 1
a709 1
	db_get( dbip, dp, &record, 0, 1);
d715 1
a715 1
			db_get( dbip, dp, &record, i, 1);
d820 1
a820 1
	db_get( dbip, dp, &record, 0, 1);
d824 1
a824 1
			db_get( dbip, dp, &record, i, 1);
d827 1
a827 1
			db_put( dbip, dp, &record, i, 1 );
a860 5





@


9.2
log
@lint
@
text
@d90 1
a90 1
			record.c.c_aircode,record.c.c_length,
d92 1
a92 1
			nmemb = record.c.c_length;
d367 1
a367 1
		nparts = record.c.c_length;
d704 1
a704 1
		nparts = record.c.c_length;
d815 1
a815 1
		nparts = record.c.c_length;
@


9.1
log
@Release_3.5
@
text
@d207 6
a212 2
	int i, j, k, kk, ngran;
	int pos_in;
@


8.5
log
@db_diradd had the length and flags parameters backward
@
text
@@


8.4
log
@removed MAXLINE (unused)
@
text
@d271 1
a271 1
		if( (dp = db_diradd( dbip, saverec.a.a_name, -1, DIR_SOLID, ngran+1)) == DIR_NULL )
d314 1
a314 1
		if( (dp = db_diradd( dbip, saverec.s.s_name, -1, DIR_SOLID, 1)) == DIR_NULL )
@


8.3
log
@Converted to new db_*() routines.
@
text
@a37 2
#define MAXLINE		512	/* Maximum number of chars per line */

@


8.2
log
@over zealous error message (it didn't have what it wanted to print)
@
text
@d26 1
a28 1
#include "./objdir.h"
d58 1
a58 1
		if( (dp = lookup(cmd_args[i], LOOKUP_NOISY)) == DIR_NULL )
d60 1
a60 1
		db_getrec(dp, (char *)&record, 0);
d68 1
a68 1
				db_getrec(dp, (char *)&record, j);
d98 1
a98 1
				db_getrec(dp, (char *)&record, j);
d178 1
a178 1
		if( (obj[i] = lookup(cmd_args[pos_in+i], LOOKUP_NOISY)) == DIR_NULL)
d228 1
a228 1
		if( (obj[i] = lookup(cmd_args[pos_in+i], LOOKUP_NOISY)) == DIR_NULL)
d233 1
a233 1
	db_getrec( obj[objpos-1], (char *)&record, 0);
d245 1
a245 1
	if( lookup(cmd_args[args], LOOKUP_QUIET) != DIR_NULL ) {
d273 1
a273 1
		if( (dp = dir_add(saverec.a.a_name, -1, DIR_SOLID, ngran+1)) == DIR_NULL )
d275 2
a276 2
		db_alloc( dp, ngran+1 );
		db_putrec(dp, &saverec, 0);
d280 1
a280 1
			db_getrec( obj[objpos-1], (char *)&record, i );
d299 1
a299 1
			db_putrec(dp, &record, i);
d316 1
a316 1
		if( (dp = dir_add(saverec.s.s_name, -1, DIR_SOLID, 1)) == DIR_NULL )
d324 2
a325 2
		db_alloc( dp, 1 );
		db_putrec( dp, &saverec, 0 );
d362 1
a362 1
	db_getrec(dp, (char *)&record, 0);
d369 1
a369 1
			db_getrec(dp, (char *)&record, i);
d371 1
a371 1
			if( (nextdp = lookup(record.M.m_instname, LOOKUP_NOISY)) == DIR_NULL )
d410 1
a410 1
		db_getrec(dp, (char *)&saverec, 0);
d450 1
a450 1
			db_getrec(dp, (char *)&record, i);
d559 1
a559 1
		if( (dp = lookup(cmd_args[i], LOOKUP_NOISY)) == DIR_NULL ) {
d579 1
a579 1
			if( (tdp = lookup(idpush.i_name, LOOKUP_QUIET)) == DIR_NULL ) {
d584 1
a584 1
			db_getrec(tdp, (char *)&record, 0);
d598 1
a598 1
				db_putrec(tdp, (char *)&record, 0);
d605 1
a605 1
					db_getrec( tdp, (char *)&record, ii );
d625 1
a625 1
					db_putrec(tdp, &record, ii);
d700 1
a700 1
	db_getrec(dp, (char *)&record, 0);
d706 1
a706 1
			db_getrec(dp, (char *)&record, i);
d708 1
a708 1
			if( (nextdp = lookup(record.M.m_instname, LOOKUP_NOISY)) == DIR_NULL )
d811 1
a811 1
	db_getrec(dp, (char *)&record, 0);
d815 1
a815 1
			db_getrec(dp, (char *)&record, i);
d818 1
a818 1
			db_putrec(dp, (char *)&record, i);
d820 1
a820 1
			if( (nextdp = lookup(record.M.m_instname, LOOKUP_NOISY)) == DIR_NULL )
@


8.1
log
@Release_3.0
@
text
@d236 1
a236 1
		(void)printf("Bottom of path %s is not a solid\n",dp->d_namep);
@


7.5
log
@closed some leftover file descriptors
@
text
@@


7.4
log
@lint fixes
@
text
@d661 2
@


7.3
log
@Changed to use rt_mat_dbmat and rt_dbmat_mat
to convert between database and internal formats.
@
text
@d40 4
a44 3



d47 1
a47 1

d142 1
a142 2


d204 1
d339 1
d504 1
d541 1
d675 1
a675 2


d799 1
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d95 2
d102 2
a103 1
				matrix_print( record.M.m_mat );
d365 2
d371 4
a375 2
			mat_mul(new_xlate, old_xlate, record.M.m_mat);

d699 2
d705 4
a709 1
			mat_mul(new_xlate, old_xlate, record.M.m_mat);
d802 1
d804 1
d811 1
a811 2
			/* set member matrix to identity */
			mat_idn( record.M.m_mat );
@


7.1
log
@Release 2.3
@
text
@d23 1
a23 1
#include "./machine.h"	/* special copy */
d207 1
a207 1
	float vec[3];
d346 2
a347 2
	float vertex[3];
	float vec[3];
d536 1
a536 1
	float vec[3];
@


6.1
log
@Release 2.0
@
text
@@


5.1
log
@Release 1.24
@
text
@@


4.4
log
@Release 1.20 -- First Formal Release
@
text
@@


4.3
log
@Minor cleanups inspired by the Cray
@
text
@@


4.2
log
@Cray cleanups
@
text
@d333 1
a333 1
struct directory *path[MAX_LEVELS];
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d30 3
a32 3
int		args;		/* total number of args available */
int		argcnt;		/* holder for number of args added later */
int		newargs;	/* number of args from getcmd() */
d518 1
a518 1
struct idpush idpush, idbuf;
d521 3
a523 3
int discr[MAXSOL], idfd, rd_idfd;
int push_count;		/* count of solids to be pushed */
int abort;
d553 1
a553 1
		abort = 0;
d556 1
a556 1
		if( abort ) {
d676 1
a676 1
	if( abort == 99 )	/* go no further */
d684 1
a684 1
		abort = 1;
d707 1
a707 1
		abort = 1;
d713 1
a713 1
		abort = 1;
d718 1
a718 1
		abort = 1;
d755 1
a755 1
				abort = 1;
d765 1
a765 1
		abort = 99;
@


1.6
log
@strings.h
@
text
@@


1.5
log
@typo
@
text
@d18 2
a20 2
#else
#include <strings.h>
@


1.4
log
@Minor cleanup for cray
@
text
@d21 1
@


1.3
log
@Changed #includes for CC -I../h
@
text
@d17 3
d21 1
a663 1
struct directory *path[MAX_LEVELS];
@


1.2
log
@Added support for the new spline format.
@
text
@d19 5
a23 5
#include "../h/vmath.h"
#include "../h/db.h"
#include "ged.h"
#include "sedit.h"
#include "objdir.h"
@


1.1
log
@Initial revision
@
text
@d103 1
a103 1
		if(record.u_id == ID_B_SPL_HEAD) {
d226 1
a226 1
		record.u_id != ID_B_SPL_HEAD && record.u_id != ID_P_HEAD) {
d295 1
a295 1
	if(saverec.u_id == ID_B_SPL_HEAD) {
d472 2
a473 2
	if(record.u_id == ID_B_SPL_HEAD) {
		(void)printf("/%s:\n",record.d.d_name);
d618 1
a618 1
			case ID_B_SPL_HEAD:
d620 1
a620 1
						record.d.d_name);
d700 1
a700 1
	if(record.u_id == ID_B_SPL_HEAD) {
d702 1
a702 1
				record.d.d_name);
@
