head	11.35;
access;
symbols
	rel-4-5:11.34
	ctj-4-5-post:11.33
	ctj-4-5-pre:11.33
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.35
date	98.10.23.15.12.06;	author bparker;	state dead;
branches;
next	11.34;

11.34
date	97.09.23.21.04.13;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	96.09.03.16.31.38;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	96.08.29.23.37.36;	author butler;	state Exp;
branches;
next	11.30;

11.30
date	96.08.29.23.08.21;	author butler;	state Exp;
branches;
next	11.29;

11.29
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	96.07.30.21.29.43;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	96.07.10.20.26.12;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	96.06.21.16.07.33;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	96.05.24.18.42.47;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.01.26.15.52.43;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	96.01.23.16.24.05;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	95.12.20.19.27.51;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	95.12.11.22.46.59;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	95.12.04.22.03.13;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	95.12.02.00.22.42;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	95.11.30.23.12.51;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	95.11.29.21.58.00;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	95.11.28.21.26.47;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	95.11.27.21.57.22;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	95.11.22.17.57.49;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	95.11.22.17.17.09;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	95.11.20.21.33.26;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	95.11.02.18.30.38;	author cjohnson;	state Exp;
branches;
next	11.8;

11.8
date	95.08.24.06.24.34;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.08.23.23.05.02;	author cnuzman;	state Exp;
branches;
next	11.6;

11.6
date	95.07.20.13.37.47;	author gdurf;	state Exp;
branches;
next	11.5;

11.5
date	95.07.06.13.31.45;	author gdurf;	state Exp;
branches;
next	11.4;

11.4
date	95.07.05.21.22.32;	author gdurf;	state Exp;
branches;
next	11.3;

11.3
date	95.06.16.19.47.36;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.06.15.20.35.56;	author gdurf;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.51;	author mike;	state Rel4_4;
branches;
next	10.53;

10.53
date	94.12.27.23.08.10;	author mike;	state Exp;
branches;
next	10.52;

10.52
date	94.12.27.17.41.35;	author mike;	state Exp;
branches;
next	10.51;

10.51
date	94.12.24.01.05.13;	author mike;	state Exp;
branches;
next	10.50;

10.50
date	94.12.23.23.14.34;	author mike;	state Exp;
branches;
next	10.49;

10.49
date	94.12.23.19.35.06;	author mike;	state Exp;
branches;
next	10.48;

10.48
date	94.12.23.17.17.35;	author gdurf;	state Exp;
branches;
next	10.47;

10.47
date	94.12.16.17.55.46;	author gdurf;	state Exp;
branches;
next	10.46;

10.46
date	94.12.12.22.58.49;	author mike;	state Exp;
branches;
next	10.45;

10.45
date	94.10.14.16.06.09;	author mike;	state Exp;
branches;
next	10.44;

10.44
date	94.09.21.21.46.53;	author mike;	state Exp;
branches;
next	10.43;

10.43
date	94.09.06.14.21.21;	author jra;	state Exp;
branches;
next	10.42;

10.42
date	94.08.31.20.24.34;	author stay;	state Exp;
branches;
next	10.41;

10.41
date	94.08.10.21.42.13;	author mike;	state Exp;
branches;
next	10.40;

10.40
date	94.08.09.15.12.09;	author gdurf;	state Exp;
branches;
next	10.39;

10.39
date	94.08.03.21.17.22;	author mike;	state Exp;
branches;
next	10.38;

10.38
date	94.08.02.18.07.58;	author mike;	state Exp;
branches;
next	10.37;

10.37
date	94.08.02.18.02.36;	author mike;	state Exp;
branches;
next	10.36;

10.36
date	94.03.09.00.18.28;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	94.02.16.18.20.32;	author cjohnson;	state Exp;
branches;
next	10.34;

10.34
date	94.02.16.17.40.38;	author cjohnson;	state Exp;
branches;
next	10.33;

10.33
date	93.11.05.09.46.33;	author stay;	state Exp;
branches;
next	10.32;

10.32
date	93.10.29.02.23.13;	author stay;	state Exp;
branches;
next	10.31;

10.31
date	93.10.26.01.47.57;	author mike;	state Exp;
branches;
next	10.30;

10.30
date	93.07.14.19.27.36;	author mike;	state Exp;
branches;
next	10.29;

10.29
date	93.07.13.21.01.47;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	93.07.01.03.15.14;	author mike;	state Exp;
branches;
next	10.27;

10.27
date	93.07.01.01.39.42;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	93.04.07.23.37.51;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	93.04.07.03.06.23;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	93.02.02.11.56.28;	author stay;	state Exp;
branches;
next	10.23;

10.23
date	92.10.20.18.16.55;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	92.10.20.14.34.51;	author stay;	state Exp;
branches;
next	10.21;

10.21
date	92.08.24.19.51.29;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	92.08.21.22.46.16;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	92.08.21.20.22.33;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	92.08.21.19.33.44;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	92.07.23.05.12.09;	author butler;	state Exp;
branches;
next	10.16;

10.16
date	92.07.09.19.55.57;	author butler;	state Exp;
branches;
next	10.15;

10.15
date	92.07.07.10.54.15;	author stay;	state Exp;
branches;
next	10.14;

10.14
date	92.06.19.00.47.56;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	92.06.16.12.43.05;	author stay;	state Exp;
branches;
next	10.12;

10.12
date	92.06.16.12.34.26;	author stay;	state Exp;
branches;
next	10.11;

10.11
date	92.05.23.16.09.47;	author butler;	state Exp;
branches;
next	10.10;

10.10
date	92.04.18.02.46.39;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	92.04.18.01.47.25;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.04.18.01.02.56;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.04.16.04.08.10;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.04.16.03.04.27;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.04.03.19.49.54;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.04.03.02.11.55;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.03.28.05.33.37;	author stay;	state Exp;
branches;
next	10.2;

10.2
date	91.11.05.00.02.47;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.17;	author mike;	state Rel4_0;
branches;
next	9.32;

9.32
date	91.09.21.03.06.47;	author butler;	state Exp;
branches;
next	9.31;

9.31
date	91.08.31.07.34.19;	author butler;	state Exp;
branches;
next	9.30;

9.30
date	91.07.18.00.26.47;	author butler;	state Exp;
branches;
next	9.29;

9.29
date	91.07.10.00.32.37;	author butler;	state Exp;
branches;
next	9.28;

9.28
date	91.07.09.02.28.10;	author mike;	state Exp;
branches;
next	9.27;

9.27
date	91.06.18.06.55.18;	author stay;	state Exp;
branches;
next	9.26;

9.26
date	91.04.12.14.41.23;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	91.03.05.01.19.21;	author butler;	state Exp;
branches;
next	9.24;

9.24
date	91.03.01.19.28.33;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	91.03.01.19.09.06;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.03.01.19.07.21;	author butler;	state Exp;
branches;
next	9.21;

9.21
date	91.02.20.00.17.02;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.02.19.23.08.53;	author butler;	state Exp;
branches;
next	9.19;

9.19
date	91.02.02.00.00.51;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.01.26.04.53.12;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.01.25.20.20.06;	author cjohnson;	state Exp;
branches;
next	9.16;

9.16
date	90.10.31.21.41.32;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	90.07.17.12.22.53;	author stay;	state Exp;
branches;
next	9.14;

9.14
date	90.06.26.05.56.27;	author stay;	state Exp;
branches;
next	9.13;

9.13
date	90.06.04.23.35.27;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.06.04.22.41.36;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.05.31.22.25.13;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.05.22.21.22.34;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.05.22.21.20.36;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.03.15.01.59.10;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.03.12.21.41.57;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.03.03.04.18.24;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.02.27.23.34.59;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	89.11.01.14.33.53;	author stay;	state Exp;
branches;
next	9.3;

9.3
date	89.10.31.14.28.39;	author stay;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.21.15;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.02.10;	author mike;	state Rel3_5;
branches;
next	8.9;

8.9
date	89.04.21.17.26.09;	author mike;	state Exp;
branches;
next	8.8;

8.8
date	89.04.06.20.39.05;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.03.04.02.14.49;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.01.19.22.18.30;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.01.18.01.55.50;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	88.12.06.01.02.30;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	88.10.06.05.39.36;	author mike;	state Rel3_0;
branches;
next	8.2;

8.2
date	88.10.06.04.30.45;	author mike;	state Rel3_0;
branches;
next	8.1;

8.1
date	88.10.05.00.35.49;	author mike;	state Rel3_0;
branches;
next	1.8;

1.8
date	88.09.21.06.20.02;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	88.09.17.02.24.06;	author reschly;	state Exp;
branches;
next	1.6;

1.6
date	88.09.07.11.14.07;	author stay;	state Exp;
branches;
next	1.5;

1.5
date	88.07.21.05.25.10;	author phil;	state Exp;
branches;
next	1.4;

1.4
date	88.06.27.10.57.04;	author stay;	state Exp;
branches;
next	1.3;

1.3
date	88.02.25.06.04.59;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.01.20.15.11.43;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	88.01.13.12.24.25;	author stay;	state Exp;
branches;
next	;


desc
@Silicon Graphics Clover 4D/60T display manager
@


11.35
log
@*- moved old display managers to dm_old
@
text
@/*
 *			D M - 4 D . C
 *
 *  This version for the SGI 4-D Iris, both regular and GT versions.
 *  
 *
 *  Uses library -lgl
 *
 *  Authors -
 *	Paul R. Stay
 *	Michael John Muuss
 *	Robert J. Reschly
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-4d.c,v 11.34 1997/09/23 21:04:13 jra Exp bparker $ (BRL)";
#endif

#include "conf.h"

/* Forwards compat with IRIX 5.0.1 */
#define class	inv_class	/* Map Irix 4 name into Irix 5 name */
#define type	inv_type	/* Map Irix 4 name into Irix 5 name */
#define state	inv_state	/* Map Irix 4 name into Irix 5 name */

#include <stdio.h>
#include <math.h>
#include <termio.h>
#undef VMIN		/* is used in vmath.h, too */
#include <ctype.h>
#include <X11/X.h>
#include <gl/gl.h>		/* SGI IRIS library */
#include <gl/device.h>		/* SGI IRIS library */
#include <gl/get.h>		/* SGI IRIS library */
#include <gl/cg2vme.h>		/* SGI IRIS, for DE_R1 defn on IRIX 3 */
#include <gl/addrs.h>		/* SGI IRIS, for DER1_STEREO defn on IRIX 3 */
#include <sys/types.h>
#include <sys/time.h>
#include <sys/invent.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "./mged_dm.h"
#include "dm.h"
#include "externs.h"
#include "solid.h"
#include "tcl.h"

#define YSTEREO		491	/* subfield height, in scanlines */
#define YOFFSET_LEFT	532	/* YSTEREO + YBLANK ? */

extern inventory_t	*getinvent();

/* Display Manager package interface */

#define IRBOUND	4095.9	/* Max magnification in Rot matrix */

int	Ir_open();
void	Ir_close();
MGED_EXTERN(void	Ir_input, (fd_set *input, int noblock) );
void	Ir_prolog(), Ir_epilog();
void	Ir_normal(), Ir_newrot();
void	Ir_update();
void	Ir_puts(), Ir_2d_line(), Ir_light();
int	Ir_object();
unsigned Ir_cvtvecs(), Ir_load();
void	Ir_statechange(), Ir_viewchange(), Ir_colorchange();
void	Ir_window(), Ir_debug();
int	Ir_dm();
static void    Ircheckevents();
static void    ir_var_init();

#define ir_fd (((struct ir_vars *)dm_vars)->_ir_fd)
#define gr_id (((struct ir_vars *)dm_vars)->_gr_id)
#define win (((struct ir_vars *)dm_vars)->_win)
#define win_l (((struct ir_vars *)dm_vars)->_win_l)
#define win_b (((struct ir_vars *)dm_vars)->_win_b)
#define win_r (((struct ir_vars *)dm_vars)->_win_r)
#define win_t (((struct ir_vars *)dm_vars)->_win_t)
#define winx_size (((struct ir_vars *)dm_vars)->_winx_size)
#define winy_size (((struct ir_vars *)dm_vars)->_winy_size)
#define perspective_mode (((struct ir_vars *)dm_vars)->_perspective_mode)
#define perspective_angle (((struct ir_vars *)dm_vars)->_perspective_angle)
#define knobs (((struct ir_vars *)dm_vars)->_knobs)
#define stereo_is_on (((struct ir_vars *)dm_vars)->_stereo_is_on)
#define ir_is_gt (((struct ir_vars *)dm_vars)->_ir_is_gt)
#define aspect_corr (((struct ir_vars *)dm_vars)->_aspect_corr)
#define ir_oldmonitor (((struct ir_vars *)dm_vars)->_ir_oldmonitor)
#define mvars (((struct ir_vars *)dm_vars)->_mvars)

struct modifiable_ir_vars {
  int cueing_on;
  int zclipping_on;
  int zbuffer_on;
  int lighting_on;
  int zbuf;
  int rgb;
  int doublebuffer;
  int min_scr_z;       /* based on getgdesc(GD_ZMIN) */
  int max_scr_z;       /* based on getgdesc(GD_ZMAX) */
  int debug;
  int linewidth;
};

struct ir_vars {
  int _ir_fd;
  long _gr_id;
  Window _win;
  long _win_l, _win_b, _win_r, _win_t;
  long _winx_size, _winy_size;
  int _perspective_mode;
  int _perspective_angle;
  int _knobs[8];
  int _stereo_is_on;
  int _ir_is_gt;
  mat_t _aspect_corr;
  int _ir_oldmonitor;
  struct modifiable_ir_vars _mvars;
};

static int ir_count = 0;
static int perspective_table[] = { 
	30, 45, 60, 90 };
static int ovec = -1;		/* Old color map entry number */
static int kblights();
static double	xlim_view = 1.0;	/* args for ortho() */
static double	ylim_view = 1.0;
static CONST char ir_title[] = "BRL MGED";


void		ir_colorit();

#ifdef IR_BUTTONS
/*
 * Map SGI Button numbers to MGED button functions.
 * The layout of this table is suggestive of the actual button box layout.
 */
#define SW_HELP_KEY	SW0
#define SW_ZERO_KEY	SW3
#define HELP_KEY	0
#define ZERO_KNOBS	0
static unsigned char bmap[IR_BUTTONS] = {
	HELP_KEY,    BV_ADCURSOR, BV_RESET,    ZERO_KNOBS,
	BE_O_SCALE,  BE_O_XSCALE, BE_O_YSCALE, BE_O_ZSCALE, 0,           BV_VSAVE,
	BE_O_X,      BE_O_Y,      BE_O_XY,     BE_O_ROTATE, 0,           BV_VRESTORE,
	BE_S_TRANS,  BE_S_ROTATE, BE_S_SCALE,  BE_MENU,     BE_O_ILLUMINATE, BE_S_ILLUMINATE,
	BE_REJECT,   BV_BOTTOM,   BV_TOP,      BV_REAR,     BV_45_45,    BE_ACCEPT,
	BV_RIGHT,    BV_FRONT,    BV_LEFT,     BV_35_25
};
/* Inverse map for mapping MGED button functions to SGI button numbers */
static unsigned char invbmap[BV_MAXFUNC+1];

/* bit 0 == switchlight 0 */
static unsigned long lights;
#endif

#ifdef IR_KNOBS
static int irlimit();			/* provides knob dead spot */
#define NOISE 32		/* Size of dead spot on knob */
/*
 *  Labels for knobs in help mode.
 */
char	*kn1_knobs[] = {
	/* 0 */ "adc <1",	/* 1 */ "zoom", 
	/* 2 */ "adc <2",	/* 3 */ "adc dist",
	/* 4 */ "adc y",	/* 5 */ "y slew",
	/* 6 */ "adc x",	/* 7 */	"x slew"
};
char	*kn2_knobs[] = {
	/* 0 */ "unused",	/* 1 */	"zoom",
	/* 2 */ "z rot",	/* 3 */ "z slew",
	/* 4 */ "y rot",	/* 5 */ "y slew",
	/* 6 */ "x rot",	/* 7 */	"x slew"
};
#endif

/*
 * SGI Color Map table
 */
#define NSLOTS		4080	/* The mostest possible - may be fewer */
static int ir_nslots=0;		/* how many we have, <= NSLOTS */
static int slotsused;		/* how many actually used */
static struct rgbtab {
	unsigned char	r;
	unsigned char	g;
	unsigned char	b;
} ir_rgbtab[NSLOTS];

struct dm dm_4d = {
	Ir_open, Ir_close,
	Ir_input,
	Ir_prolog, Ir_epilog,
	Ir_normal, Ir_newrot,
	Ir_update,
	Ir_puts, Ir_2d_line,
	Ir_light,
	Ir_object,
	Ir_cvtvecs, Ir_load,
	Ir_statechange,
	Ir_viewchange,
	Ir_colorchange,
	Ir_window, Ir_debug,
	0,			/* no "displaylist", per. se. */
	0,			/* multi-window */
	IRBOUND,
	"sgi", "SGI 4d",
	0,			/* mem map */
	Ir_dm
};

extern struct device_values dm_values;	/* values read from devices */

static void	establish_lighting();
static void	establish_zbuffer();


static void
refresh_hook()
{
	dmaflag = 1;
}

#define IR_MV_O(_m) offsetof(struct modifiable_ir_vars, _m)
struct bu_structparse Ir_vparse[] = {
	{"%d",  1, "depthcue",		IR_MV_O(cueing_on),	Ir_colorchange },
	{"%d",  1, "zclip",		IR_MV_O(zclipping_on),	refresh_hook },
	{"%d",  1, "zbuffer",		IR_MV_O(zbuffer_on),	establish_zbuffer },
	{"%d",  1, "lighting",		IR_MV_O(lighting_on),	establish_lighting },
	{"%d",  1, "has_zbuf",		IR_MV_O(zbuf),	refresh_hook },
	{"%d",  1, "has_rgb",		IR_MV_O(rgb),	Ir_colorchange },
	{"%d",  1, "has_doublebuffer",	IR_MV_O(doublebuffer), refresh_hook },
	{"%d",  1, "min_scr_z",		IR_MV_O(min_scr_z),	refresh_hook },
	{"%d",  1, "max_scr_z",		IR_MV_O(max_scr_z),	refresh_hook },
	{"%d",  1, "debug",		IR_MV_O(debug),		FUNC_NULL },
	{"%d",  1, "linewidth",		IR_MV_O(linewidth),	refresh_hook },
	{"",	0,  (char *)0,		0,			FUNC_NULL }
};

/* Map +/-2048 GED space into -1.0..+1.0 :: x/2048*/
#define GED2IRIS(x)	(((float)(x))*0.00048828125)

/*
 *  Mouse coordinates are in absolute screen space, not relative to
 *  the window they came from.  Convert to window-relative,
 *  then to MGED-style +/-2048 range.
 */
static int
irisX2ged(x)
register int x;
{
	if( x <= win_l )  return(-2048);
	if( x >= win_r )  return(2047);
	x -= win_l;
	x = ( x / (double)winx_size)*4096.0;
	x -= 2048;
	return(x);
}

static int
irisY2ged(y)
register int y;
{
	if( y <= win_b )  return(-2048);
	if( y >= win_t )  return(2047);
	y -= win_b;
	if( stereo_is_on )  y = (y%512)<<1;
	y = ( y / (double)winy_size)*4096.0;
	y -= 2048;
	return(y);
}

/* 
 *			I R _ C O N F I G U R E _ W I N D O W _ S H A P E
 *
 *  Either initially, or on resize/reshape of the window,
 *  sense the actual size of the window, and perform any
 *  other initializations of the window configuration.
 */
static void
Ir_configure_window_shape()
{
	int		npix;
	int		monitor;

	xlim_view = 1.0;
	ylim_view = 1.0;
	mat_idn(aspect_corr);

	getsize( &winx_size, &winy_size);
	getorigin( &win_l, & win_b );
	win_r = win_l + winx_size;
	win_t = win_b + winy_size;

	/* Write enable all the bloody bits after resize! */
	viewport(0, winx_size, 0, winy_size);

	if( mvars.zbuf ) establish_zbuffer();
	establish_lighting();
	
	if( mvars.doublebuffer)
	{
		/* Clear out image from windows underneath */
		frontbuffer(1);
		ir_clear_to_black();
		frontbuffer(0);
		ir_clear_to_black();
	} else
		ir_clear_to_black();

	monitor = getmonitor();
	{
		extern Tcl_Interp *interp;	/* cmd.c */
		char	*val;

		val = Tcl_GetVar2(interp, "sgi_ntsc", NULL, TCL_GLOBAL_ONLY);
		if( val && atoi(val) != 0 )  {
		  Tcl_AppendResult(interp, "dm-4d: setting NTSC size window\n", (char *)NULL);
		  monitor = NTSC;
		}
	}
	switch( monitor )  {
	default:
		break;
	case NTSC:
		/* Only use the central square part, due to overscan */
		npix = YMAX170-30;
		winx_size = npix * 4 / 3;	/* NTSC aspect ratio */
		winy_size = npix;
		win_l = (XMAX170 - winx_size)/2;
		win_r = win_l + winx_size;
		win_b = (YMAX170-winy_size)/2;
		win_t = win_b + winy_size;

		if( !mged_variables.faceplate )  {
			/* Use the whole screen, for VR & visualization */
			viewport( 0, XMAX170, 0, YMAX170 );
		} else {
			/* Only use the central (square) faceplate area */
			/*
			 * XXX Does this viewport() call do anything?  (Write enable pixels maybe?)
			 * XXX (1) the first frame (only) is shrunken oddly in X, and
			 * XXX (2) the drawing overflows the boundaries.
			 * XXX Perhaps XY clipping could be used?
			 * At least the aspect ratio is right!
			 */
			/* XXXXX See page 8-9 in the manual.
			 * XXX The best way to do the masking in NTSC mode is to
			 * XXX just set a Z-buffer write mask of 0 on the parts we don't
			 * XXX want to have written.
			 */
			viewport( (XMAX170 - npix)/2, npix + (XMAX170 - npix)/2,
			    (YMAX170-npix)/2, npix + (YMAX170-npix)/2 );
		}
		/* Aspect ratio correction is needed either way */
		xlim_view = XMAX170 / (double)YMAX170;
		ylim_view = 1;	/* YMAX170 / YMAX170 */

		mvars.linewidth = 3;
		blanktime(0);	/* don't screensave while recording video! */
		break;
	case PAL:
		/* Only use the central square part */
		npix = YMAXPAL-30;
		winx_size = npix;	/* What is PAL aspect ratio? */
		winy_size = npix;
		win_l = (XMAXPAL - winx_size)/2;
		win_r = win_l + winx_size;
		;
		win_b = (YMAXPAL-winy_size)/2;
		win_t = win_b + winy_size;
		viewport( (XMAXPAL - npix)/2, npix + (XMAXPAL - npix)/2,
		    (YMAXPAL-npix)/2, npix + (YMAXPAL-npix)/2 );
		mvars.linewidth = 3;
		blanktime(0);	/* don't screensave while recording video! */
		break;
	}

	ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );
	/* The ortho() call really just makes this matrix: */
	aspect_corr[0] = 1/xlim_view;
	aspect_corr[5] = 1/ylim_view;
}

#define CMAP_BASE	32
#define CMAP_RAMP_WIDTH	16
#define MAP_ENTRY(x)	((mvars.cueing_on) ? \
			((x) * CMAP_RAMP_WIDTH + CMAP_BASE) : \
			((x) + CMAP_BASE) )


/*
 *			I R _ O P E N
 *
 *  Fire up the display manager, and the display processor. Note that
 *  this brain-damaged version of the MEX display manager gets terribly
 *  confused if you try to close your last window.  Tough. We go ahead
 *  and close the window.  Ignore the "ERR_CLOSEDLASTWINDOW" error
 *  message. It doesn't hurt anything.  Silly MEX.
 */
int
Ir_open()
{
	register int	i;
	Matrix		m;
	inventory_t	*inv;
	int		win_size=1000;
	int		win_o_x=272;
	int		win_o_y=12;

	if(ir_count){
	  ++ir_count;
	  Tcl_AppendResult(interp, "Ir_open: sgi is already open\n", (char *)NULL);
	  return TCL_ERROR;
	}

#ifdef DM_OGL
	/* This is a hack to handle the fact that the sgi attach crashes
	 * if a direct OpenGL context has been previously opened in the 
	 * current mged session. This stops the attach before it crashes.
	 */
	if (ogl_ogl_used){
	  Tcl_AppendResult(interp, "Can't attach sgi, because a direct OpenGL context has\n",
			   "previously been opened in this session. To use sgi,\n",
			   "quit this session and reopen it.\n", (char *)NULL);
	  return TCL_ERROR;
	}
	ogl_sgi_used = 1;
#endif /* DM_OGL */

	ir_var_init();
	bu_vls_printf(&pathName, ".dm_4d");

#if 1
	{
	  static char dm_4d_dstr[80];

	  sprintf(dm_4d_dstr, "DISPLAY=%s", dname);
	  putenv(dm_4d_dstr);
	}

	if(getgdesc(GD_BITS_NORM_DBL_RED) > 0){
	  mvars.rgb = 1;
	  mvars.doublebuffer = 1;
	  ir_is_gt = 1;
	}

	if(getgdesc(GD_BITS_NORM_ZBUFFER) > 0)
	  mvars.zbuf = 1;
#else
	/*
	 *  Take inventory of the hardware.
	 *  See "types for class graphics" in /usr/include/sys/invent.h
	 */
	while( (inv = getinvent()) != (inventory_t *)0 )  {
		if( inv->class != INV_GRAPHICS )  continue;
		switch( inv->type )  {
		default:
#if 0
			bu_log("mged/dm-4d.c: getinvent() INV_GRAPHICS type=%d not recognized, you need to modify the source code\n",
			    inv->type);
#endif
			/* Since we recognize all the old devices, be
			 * optimistic and assume that new devices are plush.
			 * Or at least that GL can simulate everything adequately.
			 */
			ir_is_gt = 1;
			mvars.zbuf = 1;
			mvars.rgb = 1;
			mvars.doublebuffer = 1;
			break;
		case INV_GRODEV:			 /* 4D/60 machines */
			mvars.doublebuffer = 1;
			if( inv->state & INV_GR1ZBUF24 )
				mvars.zbuf = 1;
			break;
		case INV_VGX:
		case INV_VGXT:			/* VGX Turbo and SkyWriter */
		case INV_GMDEV:			/* GT graphics */
		case INV_CG2:
			ir_is_gt = 1;
			mvars.zbuf = 1;
			mvars.rgb = 1;
			mvars.doublebuffer = 1;
			break;
		case INV_GR1BP:
			mvars.rgb = 1;
			break;
		case INV_GR1ZBUFFER:
			mvars.zbuf = 1;
			break;
		case INV_GR1BOARD:	/* Personal Iris */
			if ( inv->state & INV_GR1RE2 )
				ir_is_gt = 1;
			if(inv->state & INV_GR1ZBUF24 )
				mvars.zbuf = 1;
			if(inv->state & INV_GR1BIT24 )
				mvars.rgb = 1;
			mvars.doublebuffer = 1;
			break;
#if defined(INV_LIGHT)
		case INV_LIGHT:		/* Entry Level Indigo */
			ir_is_gt = 0;
			mvars.zbuf = 1;
			mvars.doublebuffer = 0;
			mvars.rgb = 1;
			break;
#endif

#if defined(INV_GR2)
		case INV_GR2:		/* Elan EXPRESS Graphics */
			/* if(inv->state & INV_GR2_ELAN) */
			/* Just let GL simulate it */
			mvars.rgb = 1;
			mvars.doublebuffer = 1;
			mvars.zbuf = 1;
			ir_is_gt = 1;
			/* if(inv->state & INV_GR2_EXTREME) */
			break;
#endif
#if defined(INV_NEWPORT)
		case INV_NEWPORT:
			/* if(inv->state & INV_NEWPORT_XL) */
			/* Just let GL simulate it */
			mvars.rgb = 1;
			mvars.doublebuffer = 1;
			mvars.zbuf = 1;
			ir_is_gt = 1;
#			if 0
				if(inv->state & INV_NEWPORT_24)
					mvars.rgb = 1;
#			endif
			break;
#endif
		}
	}
	endinvent();		/* frees internal inventory memory */
#endif

#if 0
	bu_log("4D: gt=%d, zbuf=%d, rgb=%d\n", ir_is_gt, mvars.zbuf, mvars.rgb);
#endif

	/* Start out with the usual window */
	foreground();
#if 1
	if (mged_variables.sgi_win_size > 0)
		win_size = mged_variables.sgi_win_size;

	if (mged_variables.sgi_win_origin[0] != 0)
		win_o_x = mged_variables.sgi_win_origin[0];

	if (mged_variables.sgi_win_origin[1] != 0)
		win_o_y = mged_variables.sgi_win_origin[1];

	prefposition( win_o_x, win_o_x+win_size, win_o_y, win_o_y+win_size);
#else
	prefposition( 376, 1276, 12, 912 );		/* Old, larger size */
	prefposition( 376, 376+900, 112, 112+900 );	/* new, smaller size */
#endif
	if( (gr_id = winopen( "BRL MGED" )) == -1 )  {
	  Tcl_AppendResult(interp, "No more graphics ports available.\n", (char *)NULL);
	  return TCL_ERROR;
	}
	keepaspect(1,1);	/* enforce 1:1 aspect ratio */
	winconstraints();	/* remove constraints on the window size */

	ir_oldmonitor = getmonitor();
	if( mged_variables.eye_sep_dist )  {
		if( sgi_has_stereo() )  {
			setmonitor(STR_RECT);
			stereo_is_on = 1;
		} else {
		  Tcl_AppendResult(interp, "NOTICE: This SGI does not have stereo display capability\n", (char *)NULL);
		  stereo_is_on = 0;
		}
	}

	/*
	 *  If monitor is in special mode, close window and re-open.
	 *  winconstraints() does not work, and getmonitor() can't
	 *  be called before a window is open.
	 */
	switch( getmonitor() )  {
	case HZ30:
	case HZ30_SG:
		/* Dunn camera, etc. */
		/* Use already established prefposition */
		break;
	case STR_RECT:
		/* Hi-res monitor in stereo mode, take over whole screen */
		winclose(gr_id);
		noborder();
		foreground();
#if defined(__sgi) && defined(__mips)
		/* Deal with Irix 4.0 bug:  (+2,+0) offset due to border */
		prefposition( 0-2, XMAXSCREEN-2, 0, YMAXSCREEN );
#else
		prefposition( 0, XMAXSCREEN, 0, YMAXSCREEN );
#endif
		if( (gr_id = winopen( "BRL MGED" )) == -1 )  {
		  Tcl_AppendResult(interp, "No more graphics ports available.\n", (char *)NULL);
		  return TCL_ERROR;
		}
		break;
	default:
	case HZ60:
		/* Regular hi-res monitor */
		/* Use already established prefposition */
		break;
	case NTSC:
		/* Television */
		winclose(gr_id);
		prefposition( 0, XMAX170, 0, YMAX170 );
		foreground();
		if( (gr_id = winopen( "BRL MGED" )) == -1 )  {
		  Tcl_AppendResult(interp, "No more graphics ports available.\n", (char *)NULL);
		  return TCL_ERROR;
		}
		break;
	case PAL:
		/* Television */
		winclose(gr_id);
		prefposition( 0, XMAXPAL, 0, YMAXPAL );
		foreground();
		if( (gr_id = winopen( "BRL MGED" )) == -1 )  {
		  Tcl_AppendResult(interp, "No more graphics ports available.\n", (char *)NULL);
		  return TCL_ERROR;
		}
		break;
	}

	/*
	 *  Configure the operating mode of the pixels in this window.
	 *  Do not output graphics, clear screen, etc, until *after*
	 *  the call to gconfig().
	 */
	if( mvars.rgb )  {
		RGBmode();
	} else {
		/* one indexed color map of 4096 entries */
		onemap();
	}
	if ( mvars.doublebuffer)
		doublebuffer();

	gconfig();

	/*
	 * Establish GL library operating modes
	 */
	/* Don't draw polygon edges */
	glcompat( GLC_OLDPOLYGON, 0 );

	/* Z-range mapping */
	/* Z range from getgdesc(GD_ZMIN)
	 * to getgdesc(GD_ZMAX).
	 * Hardware specific.
	 */
	glcompat( GLC_ZRANGEMAP, 0 );
	/* Take off a smidgeon for wraparound, as suggested by SGI manual */
	mvars.min_scr_z = getgdesc(GD_ZMIN)+15;
	mvars.max_scr_z = getgdesc(GD_ZMAX)-15;

	Ir_configure_window_shape();

	/* Enable qdev() input from various devices */
	qdevice(LEFTMOUSE);
	qdevice(MIDDLEMOUSE);
	qdevice(RIGHTMOUSE);
	tie(LEFTMOUSE, MOUSEX, MOUSEY);
	tie(MIDDLEMOUSE, MOUSEX, MOUSEY);
	tie(RIGHTMOUSE, MOUSEX, MOUSEY);

#if IR_KNOBS
	/*
	 *  Turn on the dials and initialize them for -2048 to 2047
	 *  range with a dead spot at zero (Iris knobs are 1024 units
	 *  per rotation).
	 */
	for(i = DIAL0; i < DIAL8; i++)
		setvaluator(i, 0, -2048-NOISE, 2047+NOISE);
	for(i = DIAL0; i < DIAL8; i++)
		qdevice(i);
#endif
#if IR_BUTTONS
	/*
	 *  Enable all the buttons in the button table.
	 */
	for(i = 0; i < IR_BUTTONS; i++)
		qdevice(i+SWBASE);
	/*
	 *  For all possible button presses, build a table
	 *  of MGED function to SGI button/light mappings.
	 */
	for( i=0; i < IR_BUTTONS; i++ )  {
		register int j;
		if( (j = bmap[i]) != 0 )
			invbmap[j] = i;
	}
# if 0
	ir_dbtext(ir_title);
# else
	dbtext("");
# endif
#endif
        qdevice(THREEKEY); /* press 35,25 */
        qdevice(FOURKEY); /* press 45,45 */
	qdevice(AKEY); /* adc */
        qdevice(BKEY); /* press bottom */
        qdevice(EKEY); /* set e_axes ! */
        qdevice(FKEY); /* press front */
        qdevice(IKEY); /* aip f */
        qdevice(LKEY); /* press left */
        qdevice(OKEY); /* press oill */
	qdevice(PKEY); /* M 1 0 0 */
        qdevice(QKEY); /* press reject */
        qdevice(RKEY); /* press right */
        qdevice(SKEY); /* press sill */
        qdevice(TKEY); /* press top */
        qdevice(UKEY); /* aip b */
        qdevice(VKEY); /* set v_axes ! */
        qdevice(WKEY); /* set w_axes ! */

	qdevice(F1KEY);	/* pf1 key for depthcue switching */
	qdevice(F2KEY);	/* pf2 for Z clipping */
	qdevice(F3KEY);	/* pf3 for perspective */
	qdevice(F4KEY);	/* pf4 for Z buffering */
	qdevice(F5KEY);	/* pf5 for lighting */
	qdevice(F6KEY);	/* pf6 for changing perspective */
	qdevice(F7KEY);	/* pf7 toggles faceplate */
	qdevice(F8KEY);	/* pf8 toggles menu */
	qdevice(F12KEY);/* pf12 toggles focus */
	while( getbutton(LEFTMOUSE)||getbutton(MIDDLEMOUSE)||getbutton(RIGHTMOUSE) )  {
	  Tcl_AppendResult(interp, "IRIS_open:  mouse button stuck\n", (char *)NULL);
	  sleep(1);
	}

	/* Line style 0 is solid.  Program line style 1 as dot-dashed */
	deflinestyle( 1, 0xCF33 );
	setlinestyle( 0 );

	ir_fd = qgetfd();

	Tk_CreateFileHandler(ir_fd, 1, Ircheckevents, (ClientData)curr_dm_list);
	ir_count = 1;
	return(0);
}

/*
 *  			I R _ C L O S E
 *  
 *  Gracefully release the display.  Well, mostly gracefully -- see
 *  the comments in the open routine.
 */
void
Ir_close()
{
#ifdef DM_OGL
  if (ogl_ogl_used)
    return;
#endif

  if(ir_count > 1){
    --ir_count;
    return;
  }

  if(mvars.cueing_on) depthcue(0);

  lampoff( 0xf );

  /* avoids error messages when reattaching */
  mmode(MVIEWING);	
  lmbind(LIGHT2,0);
  lmbind(LIGHT3,0);
  lmbind(LIGHT4,0);
  lmbind(LIGHT5,0);

  frontbuffer(1);
  ir_clear_to_black();
  frontbuffer(0);

  if( getmonitor() != ir_oldmonitor )
    setmonitor(ir_oldmonitor);

  winclose(gr_id);

  if(ir_fd)
    Tk_DeleteFileHandler(ir_fd);

  if(dm_vars)
    bu_free(dm_vars, "Ir_close: dm_vars");

  ir_count = 0;
  return;
}

/*
 *			I R _ P R O L O G
 *
 * Define the world, and include in it instances of all the
 * important things.  Most important of all is the object "faceplate",
 * which is built between dmr_normal() and dmr_epilog()
 * by dmr_puts and dmr_2d_line calls from adcursor() and dotitles().
 */
void
Ir_prolog()
{
	if (mvars.debug)
	  Tcl_AppendResult(interp, "Ir_prolog\n", (char *)NULL);
#if 0
	ortho2( -1.0,1.0, -1.0,1.0);	/* L R Bot Top */
#else
	ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );
#endif

	if( !mvars.doublebuffer )
	{
		ir_clear_to_black();
		return;
	}
	linewidth(mvars.linewidth);
}

/*
 *			I R _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
void
Ir_normal()
{
	if (mvars.debug)
	  Tcl_AppendResult(interp, "Ir_normal\n", (char *)NULL);

	if( mvars.rgb )  {
		RGBcolor( (short)0, (short)0, (short)0 );
	} else {
		color(BLACK);
	}

#if 0
	ortho2( -1.0,1.0, -1.0,1.0);	/* L R Bot Top */
#else
	ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );
#endif
}

/*
 *			I R _ E P I L O G
 */
void
Ir_epilog()
{
	if (mvars.debug)
	  Tcl_AppendResult(interp, "Ir_epilog\n", (char *)NULL);

	/*
	 * A Point, in the Center of the Screen.
	 * This is drawn last, to always come out on top.
	 */
	Ir_2d_line( 0, 0, 0, 0, 0 );
	/* End of faceplate */

	if(mvars.doublebuffer )
	{
		swapbuffers();
		/* give Graphics pipe time to work */
		ir_clear_to_black();
	}
}

/*
 *  			I R _ N E W R O T
 *
 *  Load a new rotation matrix.  This will be followed by
 *  many calls to Ir_object().
 *
 *  IMPORTANT COORDINATE SYSTEM NOTE:
 *
 *  MGED uses a right handed coordinate system where +Z points OUT of
 *  the screen.  The Silicon Graphics uses a left handed coordinate
 *  system where +Z points INTO the screen.
 *  This difference in convention is handled here.
 *  The conversion is accomplished by concatenating a matrix multiply
 *  by
 *            (  1    0    0   0  )
 *            (  0    1    0   0  )
 *            (  0    0   -1   0  )
 *            (  0    0    0   1  )
 *
 *  However, this is actually implemented by straight-line code which
 *  flips the sign on the entire third row.
 *
 *  Note that through BRL-CAD Release 3.7 this was handled by flipping
 *  the direction of the shade ramps.  Now, with the Z-buffer being used,
 *  the correct solution is important.
 */
void
Ir_newrot(mat, which_eye)
mat_t	mat;
{
	register fastf_t *mptr;
	Matrix	gtmat;
	mat_t	newm;
	int	i;

	if (mvars.debug)
	  Tcl_AppendResult(interp, "Ir_newrot()\n", (char *)NULL);

	switch(which_eye)  {
	case 0:
		/* Non-stereo */
		break;
	case 1:
		/* R eye */
		viewport(0, XMAXSCREEN, 0, YSTEREO);
		Ir_puts( "R", 2020, 0, 0, DM_RED );
		break;
	case 2:
		/* L eye */
		viewport(0, XMAXSCREEN, 0+YOFFSET_LEFT, YSTEREO+YOFFSET_LEFT);
		break;
	}

	if( ! mvars.zclipping_on ) {
		mat_t	nozclip;

		mat_idn( nozclip );
		nozclip[10] = 1.0e-20;
		mat_mul( newm, nozclip, mat );
		mptr = newm;
	} else {
		mptr = mat;
	}
#if 0
	for(i= 0; i < 4; i++) {
		gtmat[0][i] = *(mptr++);
		gtmat[1][i] = *(mptr++);
		gtmat[2][i] = *(mptr++);
		gtmat[3][i] = *(mptr++);
	}
#else
	gtmat[0][0] = *(mptr++) * aspect_corr[0];
	gtmat[1][0] = *(mptr++) * aspect_corr[0];
	gtmat[2][0] = *(mptr++) * aspect_corr[0];
	gtmat[3][0] = *(mptr++) * aspect_corr[0];

	gtmat[0][1] = *(mptr++) * aspect_corr[5];
	gtmat[1][1] = *(mptr++) * aspect_corr[5];
	gtmat[2][1] = *(mptr++) * aspect_corr[5];
	gtmat[3][1] = *(mptr++) * aspect_corr[5];

	gtmat[0][2] = *(mptr++);
	gtmat[1][2] = *(mptr++);
	gtmat[2][2] = *(mptr++);
	gtmat[3][2] = *(mptr++);

	gtmat[0][3] = *(mptr++);
	gtmat[1][3] = *(mptr++);
	gtmat[2][3] = *(mptr++);
	gtmat[3][3] = *(mptr++);
#endif

	/*
	 *  Convert between MGED's right handed coordinate system
	 *  where +Z comes out of the screen to the Silicon Graphics's
	 *  left handed coordinate system, where +Z goes INTO the screen.
	 */
	gtmat[0][2] = -gtmat[0][2];
	gtmat[1][2] = -gtmat[1][2];
	gtmat[2][2] = -gtmat[2][2];
	gtmat[3][2] = -gtmat[3][2];

	loadmatrix( gtmat );
}

static float material_objdef[] = {
	ALPHA,		1.0,	
	AMBIENT,	0.2, 0.2, 0.2,	/* 0.4 in rt */
	DIFFUSE,	0.6, 0.6, 0.6,
	SPECULAR,	0.2, 0.2, 0.2,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	10.0,
	LMNULL   };

/*
 *  			I R _ O B J E C T
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.  Mat is model2view.
 *
 *  Returns -
 *	 0 if object could be drawn
 *	!0 if object was omitted.
 */
int
Ir_object( sp, m, ratio, white )
register struct solid *sp;
fastf_t		*m;
double		ratio;
int		white;
{
	register struct rt_vlist	*vp;
	register int nvec;
	register float	*gtvec;
	char	gtbuf[16+3*sizeof(double)];
	int first;
	int i,j;

	if (mvars.debug)
	  Tcl_AppendResult(interp, "Ir_Object()\n", (char *)NULL);

	/*
	 *  It is claimed that the "dancing vector disease" of the
	 *  4D GT processors is due to the array being passed to v3f()
	 *  not being quad-word aligned (16-byte boundary).
	 *  This hack ensures that the buffer has this alignment.
	 *  Note that this requires gtbuf to be 16 bytes longer than needed.
	 */
	gtvec = (float *)((((int)gtbuf)+15) & (~0xF));

	/*
	 * IMPORTANT DEPTHCUEING NOTE
	 *
	 * Also note that the depthcueing shaderange() routine wanders
	 * outside it's allotted range due to roundoff errors.  A buffer
	 * entry is kept on each end of the shading curves, and the
	 * highlight mode uses the *next* to the brightest entry --
	 * otherwise it can (and does) fall off the shading ramp.
	 */
	if (sp->s_soldash)
		setlinestyle( 1 );		/* set dot-dash */

	if( mvars.rgb )  {
		register short	r, g, b;
		if( white )  {
			r = g = b = 230;
		} else {
			r = (short)sp->s_color[0];
			g = (short)sp->s_color[1];
			b = (short)sp->s_color[2];
		}
		if(mvars.cueing_on)  {
			lRGBrange(
			    r/10, g/10, b/10,
			    r, g, b,
			    mvars.min_scr_z, mvars.max_scr_z );
		} else
		if(mvars.lighting_on && ir_is_gt)
		{
			/* Ambient = .2, Diffuse = .6, Specular = .2 */

			/* Ambient */
			material_objdef[3] = 	.2 * ( r / 255.0);
			material_objdef[4] = 	.2 * ( g / 255.0);
			material_objdef[5] = 	.2 * ( b / 255.0);

			/* diffuse */
			material_objdef[7] = 	.6 * ( r / 255.0);
			material_objdef[8] = 	.6 * ( g / 255.0);
			material_objdef[9] = 	.6 * ( b / 255.0);

			/* Specular */
			material_objdef[11] = 	.2 * ( r / 255.0);
			material_objdef[12] = 	.2 * ( g / 255.0);
			material_objdef[13] = 	.2 * ( b / 255.0);

			lmdef(DEFMATERIAL, 21, 0, material_objdef);
			lmbind(MATERIAL, 21);

		} else

			RGBcolor( r, g, b );
	} else {
		if( white ) {
			ovec = nvec = MAP_ENTRY(DM_WHITE);
			/* Use the *next* to the brightest white entry */
			if(mvars.cueing_on)  {
				lshaderange(nvec+1, nvec+1,
				    mvars.min_scr_z, mvars.max_scr_z );
			}
			color( nvec );
		} else {
			if( (nvec = MAP_ENTRY( sp->s_dmindex )) != ovec) {
				/* Use only the middle 14 to allow for roundoff...
				 * Pity the poor fool who has defined a black object.
				 * The code will use the "reserved" color map entries
				 * to display it when in depthcued mode.
				 */
				if(mvars.cueing_on)  {
					lshaderange(nvec+1, nvec+14,
					    mvars.min_scr_z, mvars.max_scr_z );
				}
				color( nvec );
				ovec = nvec;
			}
		}
	}

	/* Viewing region is from -1.0 to +1.0 */
	first = 1;
	for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			switch( *cmd )  {
			case RT_VLIST_LINE_MOVE:
				/* Move, start line */
				if( first == 0 )
					endline();
				first = 0;
				bgnline();
				v3d( *pt );
				break;
			case RT_VLIST_LINE_DRAW:
				/* Draw line */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_START:
				/* Start poly marker & normal */
				if( first == 0 )
					endline();
				/* concave(TRUE); */
				bgnpolygon();
				/* Set surface normal (vl_pnt points outward) */
				VMOVE( gtvec, *pt );
				n3f(gtvec);
				break;
			case RT_VLIST_POLY_MOVE:
				/* Polygon Move */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_DRAW:
				/* Polygon Draw */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_END:
				/* Draw, End Polygon */
				v3d( *pt );
				endpolygon();
				first = 1;
				break;
			case RT_VLIST_POLY_VERTNORM:
				/* Set per-vertex normal.  Given before vert. */
				VMOVE( gtvec, *pt );
				n3f(gtvec);
				break;
			}
		}
	}
	if( first == 0 ) endline();

	if (sp->s_soldash)
		setlinestyle(0);		/* restore solid lines */

	return(1);	/* OK */
}

/*
 *			I R _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 * Last routine called in refresh cycle.
 */
void
Ir_update()
{
	if (mvars.debug)
	  Tcl_AppendResult(interp, "Ir_update()\n", (char *)NULL);

	return;
}

/*
 *			I R _ P U T S
 *
 * Output a string.
 * The starting position of the beam is as specified.
 */
void
Ir_puts( str, x, y, size, colour )
register char *str;
int x,y,size, colour;
{
	if (mvars.debug)
	  Tcl_AppendResult(interp, "Ir_puts()\n", (char *)NULL);

	cmov2( GED2IRIS(x), GED2IRIS(y));
	if( mvars.rgb )  {
		RGBcolor( (short)ir_rgbtab[colour].r,
		    (short)ir_rgbtab[colour].g,
		    (short)ir_rgbtab[colour].b );
	} else {
		color( MAP_ENTRY(colour) );
	}
	charstr( str );
}

/*
 *			I R _ 2 D _ L I N E
 *
 */
void
Ir_2d_line( x1, y1, x2, y2, dashed )
int x1, y1;
int x2, y2;
int dashed;
{
	register int nvec;

	if (mvars.debug)
	  Tcl_AppendResult(interp, "Ir_2d_line()\n", (char *)NULL);

	if( mvars.rgb )  {
		/* Yellow */
		if(mvars.cueing_on)  {
			lRGBrange(
			    255, 255, 0,
			    255, 255, 0,
			    mvars.min_scr_z, mvars.max_scr_z );
		}
		RGBcolor( (short)255, (short)255, (short) 0 );
	} else {
		if((nvec = MAP_ENTRY(DM_YELLOW)) != ovec) {
			if(mvars.cueing_on) lshaderange(nvec, nvec,
			    mvars.min_scr_z, mvars.max_scr_z );
			color( nvec );
			ovec = nvec;
		}
	}

	if( dashed )
		setlinestyle(1);	/* into dot-dash */

	move2( GED2IRIS(x1), GED2IRIS(y1));
	draw2( GED2IRIS(x2), GED2IRIS(y2));

	if( dashed )
		setlinestyle(0);	/* restore to solid */
}

/*
 *			I R _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream, or a device event has
 * occured, unless "noblock" is set.
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 */
void
Ir_input( input, noblock )
fd_set		*input;
int		noblock;
{
	static int cnt;
	register int i;
	struct timeval	tv;
	fd_set		files;
	int		width;

	if (mvars.debug)
	  Tcl_AppendResult(interp, "Ir_input()\n", (char *)NULL);

	if( (width = sysconf(_SC_OPEN_MAX)) <= 0 )
		width = 32;
	files = *input;		/* save, for restore on each loop */
	FD_SET( ir_fd, &files );

	/*
	 * Check for input on the keyboard or on the polled registers.
	 *
	 * Suspend execution until either
	 *  1)  User types a full line
	 *  2)  A change in peripheral status occurs
	 *  3)  The timelimit on SELECT has expired
	 *
	 * If a RATE operation is in progress (zoom, rotate, slew)
	 * in which the peripherals (rate setting) may not be changed,
	 * but we still have to update the display,
	 * do not suspend execution.
	 */
	do  {
		cnt = 0;
		i = qtest();
		if( i != 0 )  {
			FD_ZERO( input );
			FD_SET( ir_fd, input );
			break;		/* There is device input */
		}
		*input = files;

		tv.tv_sec = 0;
		if( noblock )  {
			tv.tv_usec = 0;
		}  else {
			/* 1/20th second */
			tv.tv_usec = 50000;
		}
		cnt = select( width, input, (fd_set *)0,  (fd_set *)0, &tv );
		if( cnt < 0 )  {
			perror("dm-4d.c/select");
			break;
		}
		if( noblock )  break;
		for( i=0; i<width; i++ )  {
			if( FD_ISSET(i, input) )  goto input_waiting;
		}
	} while( noblock == 0 );

input_waiting:
	/*
	 * Set device interface structure for GED to "rest" state.
	 * First, process any messages that came in.
	 */

	if( FD_ISSET( ir_fd, input ) )
		Ircheckevents();

	return;
}
/*
 *  C H E C K E V E N T S
 *
 *  Look at events to check for button, dial, and mouse movement.
 */
static void
Ircheckevents(clientData, mask)
ClientData clientData;
int mask;
{
#define NVAL 48
  short values[NVAL];
  register short *valp;
  register int ret;
  register int n;
  static	button0  = 0;	/*  State of button 0 */
  static char	pending_button = 'M';
  static int	pending_val = 0;
  static	pending_x = 0;
  static	pending_y = 0;
  register struct dm_list *save_dm_list;
  struct bu_vls cmd;

/*
  if (qtest() == 0)
  return;
*/

  bu_vls_init(&cmd);

  save_dm_list = curr_dm_list;
  curr_dm_list = (struct dm_list *)clientData;

  n = blkqread( values, NVAL );	/* n is # of shorts returned */
  if( mvars.debug ){
    struct bu_vls tmp_vls;

    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "blkqread gave %d\n", n);
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
  }
  for( valp = values; n > 0; n -= 2, valp += 2 )  {

    ret = *valp;
    if( mvars.debug ){
      struct bu_vls tmp_vls;

      bu_vls_init(&tmp_vls);
      bu_vls_printf(&tmp_vls, "qread ret=%d, val=%d\n", ret, valp[1]);
      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
      bu_vls_free(&tmp_vls);
    }
#if IR_BUTTONS
    if((ret >= SWBASE && ret < SWBASE+IR_BUTTONS)
       || (ret >= F1KEY && ret <= F12KEY)
       ) {
      register int	i;

      /*
       *  Switch 0 is help key.
       *  Holding down key 0 and pushing another
       *  button or turning the knob will display
       *  what it is in the button box display.
       */
			if(ret == SW_HELP_KEY)  {
				button0 = valp[1];
#if IR_KNOBS
				/*
				 *  Save and restore dial settings
				 *  so that when the user twists them
				 *  while holding down button 0 he
				 *  really isn't changing them.
				 */
				for(i = 0; i < 8; i++)
					if(button0)
						knobs[i] =
						    getvaluator(DIAL0+i);
					else setvaluator(DIAL0+i,knobs[i],
					    -2048-NOISE, 2047+NOISE);
#endif
				if(button0)
					ir_dbtext("Help Key");
# if 0
else
	ir_dbtext(ir_title);
# endif
continue;

			}

#if IR_KNOBS
			/*
			 *  If button 1 is pressed, reset run away knobs.
			 */
			if(ret == SW_ZERO_KEY || ret == F12KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					ir_dbtext("ZeroKnob");
					continue;
				}
#if IR_KNOBS
				/* zap the knobs */
				for(i = 0; i < 8; i++)  {
					setvaluator(DIAL0+i, 0,
					    -2048-NOISE, 2047+NOISE);
					knobs[i] = 0;
				}
#endif
				bu_vls_printf(&cmd,
				    "knob zero\n");
				continue;
			}
#endif
			/*
			 *  If PFkey 1 is pressed, toggle depthcueing.
			 */
			if(ret == F1KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					ir_dbtext("Depthcue");
					continue;
				}
				/* toggle depthcueing and remake colormap */
				bu_vls_printf(&cmd,
				    "dm set depthcue !\n");
				continue;
			} else if(ret == F2KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					ir_dbtext("Z clip");
					continue;
				}
				/* toggle zclipping */
				bu_vls_printf(&cmd,
				    "dm set zclip !\n");
				continue;
			} else if(ret == F3KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					ir_dbtext("Perspect");
					continue;
				}
				perspective_mode = 1-perspective_mode;
				bu_vls_printf( &cmd,
				    "set perspective %d\n",
				    perspective_mode ?
				    perspective_table[perspective_angle] :
				    -1 );
				dmaflag = 1;
				continue;
			} else if(ret == F4KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					ir_dbtext("Zbuffing");
					continue;
				}
				/* toggle zbuffer status */
				bu_vls_printf(&cmd,
				    "dm set zbuffer !\n");
				continue;
			} else if(ret == F5KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					ir_dbtext("Lighting");
					continue;
				}
				/* toggle status */
				bu_vls_printf(&cmd,
				    "dm set lighting !\n");
				continue;
			} else if (ret == F6KEY) {
				if (!valp[1]) continue; /* Ignore release */
				/* Help mode */
				if (button0) {
					ir_dbtext("P-Angle");
					continue;
				}
				/* toggle perspective matrix */
				if (--perspective_angle < 0) perspective_angle = 3;
				if(perspective_mode) bu_vls_printf( &cmd,
				    "set perspective %d\n",
				    perspective_table[perspective_angle] );
				dmaflag = 1;
				continue;
			} else if (ret == F7KEY) {
				if (!valp[1]) continue; /* Ignore release */
				/* Help mode */
				if (button0) {
					ir_dbtext("NoFace");
					continue;
				}
				/* Toggle faceplate on/off */
#if 0
				no_faceplate = !no_faceplate;

				bu_vls_strcat( &cmd,
				    no_faceplate ?
				    "set faceplate 0\n" :
				    "set faceplate 1\n" );
#else
				bu_vls_strcat( &cmd,
					       "set faceplate !\n" );
#endif
				Ir_configure_window_shape();
				dmaflag = 1;
				continue;
			} else if (ret == F8KEY) {
				if (!valp[1]) continue; /* Ignore release */
				/* Help mode */
				if (button0) {
					ir_dbtext("NoMenu");
					continue;
				}

				bu_vls_strcat( &cmd,
					       "set show_menu !\n" );

				Ir_configure_window_shape();
				dmaflag = 1;
				continue;
			}
			/*
			 * If button being depressed (as opposed to
			 * being released) either display the cute
			 * message or process the button depending
			 * on whether button0 is also being held down.
			 */
			i = bmap[ret - SWBASE];



			if(!valp[1]) continue;
			if(button0) {
				ir_dbtext(label_button(i));
			} else {
				/* An actual button press */
#				if 0
				/* old way -- an illegal upcall */
				button(i);
#				else
				/* better way -- queue a string command */
				bu_vls_strcat( &cmd,
				    "press " );
				bu_vls_strcat( &cmd,
				    label_button(i) );
				bu_vls_strcat( &cmd,
				    "\n" );
#				endif
			}
			continue;
    }
#endif
    if( ret >= BUT0 && ret <= MAXKBDBUT ) {
      if( !valp[1] )
	continue; /* Ignore release */

      switch( ret ) {
      case THREEKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("press 35,25");
	  break;
	}

	bu_vls_strcat(&cmd, "press 35,25\n");
	break;
      case FOURKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("press 45,45");
	  break;
	}

	bu_vls_strcat(&cmd, "press 45,45\n");
	break;
      case AKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("adc");
	  break;
	}

	bu_vls_strcat(&cmd, "adc\n");
	break;
      case BKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("press bottom");
	  break;
	}

	bu_vls_strcat(&cmd, "press bottom\n");
	break;
      case EKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("set e_axes !");
	  break;
	}

	bu_vls_strcat(&cmd, "set e_axes !\n");
	break;
      case FKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("press front");
	  break;
	}

	bu_vls_strcat(&cmd, "press front\n");
	break;
      case IKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("aip f");
	  break;
	}

	bu_vls_strcat(&cmd, "aip f\n");
	break;
      case LKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("press left");
	  break;
	}

	bu_vls_strcat(&cmd, "press left\n");
	break;
      case OKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("press oill");
	  break;
	}

	bu_vls_strcat(&cmd, "press oill\n");
	break;
      case PKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("M 1 0 0");
	  break;
	}

	bu_vls_strcat(&cmd, "M 1 0 0\n");
	break;
      case QKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("press reject");
	  break;
	}

	bu_vls_strcat(&cmd, "press reject\n");
	break;
      case RKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("press right");
	  break;
	}

	bu_vls_strcat(&cmd, "press right\n");
	break;
      case SKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("press sill");
	  break;
	}

	bu_vls_strcat(&cmd, "press sill\n");
	break;
      case TKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("press top");
	  break;
	}

	bu_vls_strcat(&cmd, "press top\n");
	break;
      case UKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("aip b");
	  break;
	}

	bu_vls_strcat(&cmd, "aip b\n");
	break;
      case VKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("set v_axes !");
	  break;
	}

	bu_vls_strcat(&cmd, "set v_axes !\n");
	break;
      case WKEY:
	/*  Help mode */
	if(button0)  {
	  ir_dbtext("set w_axes");
	  break;
	}

	bu_vls_strcat(&cmd, "set w_axes !\n");
	break;
      default:
	break;
      }

      continue;
    }
#if IR_KNOBS
		/*  KNOBS, uh...er...DIALS  */
		/*	6	7
		 *	4	5
		 *	2	3
		 *	0	1
		 */
		if(ret >= DIAL0 && ret <= DIAL8)  {
			int	setting;
			/*  Help MODE */
			if(button0)  {
				ir_dbtext(
				    (mged_variables.adcflag ? kn1_knobs:kn2_knobs)[ret-DIAL0]);
				continue;
			}
			/* Make a dead zone around 0 */
			setting = irlimit(valp[1]);
			switch(ret)  {
			case DIAL0:
				if(mged_variables.adcflag) {
					bu_vls_printf( &cmd, "knob ang1 %d\n",
							setting );
				}
				break;
			case DIAL1:
				bu_vls_printf( &cmd , "knob S %f\n",
							setting/2048.0 );
				break;
			case DIAL2:
				if(mged_variables.adcflag)
					bu_vls_printf( &cmd , "knob ang2 %d\n",
							setting );
				else {
				  if(mged_variables.rateknobs)
				    bu_vls_printf( &cmd , "knob z %f\n",
						   setting/2048.0 );
				  else
				    bu_vls_printf( &cmd , "knob az %f\n",
						   setting/512.0 );
				}
				break;
			case DIAL3:
				if(mged_variables.adcflag)
					bu_vls_printf( &cmd , "knob distadc %d\n",
							setting );
				else {
				  if(mged_variables.rateknobs)
				    bu_vls_printf( &cmd , "knob Z %f\n",
						   setting/2048.0 );
				  else
				    bu_vls_printf( &cmd , "knob aZ %f\n",
						   setting/512.0 );
				}
				break;
			case DIAL4:
				if(mged_variables.adcflag)
					bu_vls_printf( &cmd , "knob yadc %d\n",
							setting );
				else {
				  if(mged_variables.rateknobs)
				    bu_vls_printf( &cmd , "knob y %f\n",
						   setting/2048.0 );
				  else
				    bu_vls_printf( &cmd , "knob ay %f\n",
						   setting/512.0 );
				}
				break;
			case DIAL5:
			        if(mged_variables.rateknobs)
				  bu_vls_printf( &cmd , "knob Y %f\n",
						 setting/2048.0 );
				else
				  bu_vls_printf( &cmd , "knob aY %f\n",
						 setting/512.0 );
				break;
			case DIAL6:
				if(mged_variables.adcflag)
					bu_vls_printf( &cmd , "knob xadc %d\n",
							setting );
				else {
				  if(mged_variables.rateknobs)
				    bu_vls_printf( &cmd , "knob x %f\n",
						   setting/2048.0 );
				  else
				    bu_vls_printf( &cmd , "knob ax %f\n",
						   setting/512.0 );
				}
				break;
			case DIAL7:
			        if(mged_variables.rateknobs)
				  bu_vls_printf( &cmd , "knob X %f\n",
						 setting/2048.0 );
				else
				  bu_vls_printf( &cmd , "knob aX %f\n",
						 setting/512.0 );
				break;
			}
			continue;
		}
#endif
		switch( ret )  {
		case LEFTMOUSE:
			pending_button = 'L';
			pending_val = (int)valp[1] ? 1 : 0;
			break;
		case RIGHTMOUSE:
			pending_button = 'R';
			pending_val = (int)valp[1] ? 1 : 0;
			break;
		case MIDDLEMOUSE:
			/* Will be followed by MOUSEX and MOUSEY hits */
			pending_button = 'M';
			pending_val = (int)valp[1] ? 1 : 0;
			/* Don't signal DV_PICK until MOUSEY event */
			break;
		case MOUSEX:
			pending_x = irisX2ged( (int)valp[1] );
			if(mvars.debug>1)printf("mousex %d\n", pending_x);
			break;
		case MOUSEY:
			pending_y = irisY2ged( (int)valp[1] );
			if(mvars.debug>1)printf("mousey %d\n", pending_y);
			/*
			 *  Thanks to the tie() call, when a MIDDLEMOUSE
			 *  event is signalled, it will be (eventually)
			 *  followed by a MOUSEX and MOUSEY event.
			 *  The MOUSEY event may not be in the same
			 *  blkqread() buffer, owing to time delays in
			 *  the outputting of the tie()'ed events.
			 *  So, don't report the mouse event on MIDDLEMOUSE;
			 *  instead, the flag pending_val flag is set,
			 *  and the mouse event is signaled here, which
			 *  may need multiple trips through this subroutine.
			 *
			 *  MOUSEY may be queued all by itself to support
			 *  illuminate mode;  in those cases, pending_val
			 *  will be zero already, and we just parrot the last
			 *  X value.
			 */
			bu_vls_printf( &cmd, "%c %d %d %d\n",
			    pending_button,
			    pending_val,
			    pending_x, pending_y);
			pending_button = 'M';
			pending_val = 0;
			break;
		case REDRAW:
			/* Window may have moved */
			Ir_configure_window_shape();
			dmaflag = 1;
			if( mvars.doublebuffer) /* to fix back buffer */
				refresh();
			dmaflag = 1;
			break;
		case INPUTCHANGE:
			/* Means we got or lost the keyboard.  Ignore */
			break;
		case WMREPLY:
			/* This guy speaks, but has nothing to say */
			break;
		case 0:
			/* These show up as a consequence of using qgetfd().  Most regrettable.  Ignore. */
			break;
		default:
		  {
		    struct bu_vls tmp_vls;

		    bu_vls_init(&tmp_vls);
		    bu_vls_printf(&tmp_vls, "IRIS device %d gave %d?\n", ret, valp[1]);
		    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		    bu_vls_free(&tmp_vls);
		  }
		  break;
		}
  }

  scroll_active = 0;
  (void)cmdline(&cmd, FALSE);
  bu_vls_free(&cmd);
  curr_dm_list = save_dm_list;
}

/* 
 *			I R _ L I G H T
 *
 * This function must keep both the light hardware, and the software
 * copy of the lights up to date.  Note that requests for light changes
 * may not actually cause the lights to be changed, depending on
 * whether the buttons are being used for "view" or "edit" functions
 * (although this is not done in the present code).
 */
void
Ir_light( cmd, func )
int cmd;
int func;			/* BE_ or BV_ function */
{
	register unsigned short bit;
#ifdef IR_BUTTONS
	/* Check for BE_ function not assigned to a button */
	if( (bit = invbmap[func]) == 0 && cmd != LIGHT_RESET )
		return;
	switch( cmd )  {
	case LIGHT_RESET:
		lights = 0;
		break;
	case LIGHT_ON:
		lights |= 1<<bit;
		break;
	case LIGHT_OFF:
		lights &= ~(1<<bit);
		break;
	}

	/* Update the lights box. */
#if !defined(__sgi)	/* This bombs, on early Irix 4.0 releases */
	setdblights( lights );
#endif
#endif
}

/*
 *			I R _ C V T V E C S
 *
 */
unsigned
Ir_cvtvecs( sp )
register struct solid *sp;
{
	return( 0 );	/* No "displaylist" consumed */
}

/*
 * Loads displaylist from storage[]
 */
unsigned
Ir_load( addr, count )
unsigned addr, count;
{
	return( 0 );		/* FLAG:  error */
}

void
Ir_statechange( a, b )
{
	if( mvars.debug ){
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "statechange %d %d\n", a, b );
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
	/*
	 *  Based upon new state, possibly do extra stuff,
	 *  including enabling continuous tablet tracking,
	 *  object highlighting
	 */
	switch( b )  {
	case ST_VIEW:
		unqdevice( MOUSEY );	/* constant tracking OFF */
		/* This should not affect the tie()'d MOUSEY events */
		break;

	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
		/*  Have all changes of MOUSEY generate an event */
		qdevice( MOUSEY );	/* constant tracking ON */
		break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	case ST_S_VPICK:
		unqdevice( MOUSEY );	/* constant tracking OFF */
		break;
	default:
	  {
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "Ir_statechange: unknown state %s\n", state_str[b]);
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
	  }
	  break;
	}
	Ir_viewchange( DM_CHGV_REDO, SOLID_NULL );
}

void
Ir_viewchange( cmd, sp )
register int cmd;
register struct solid *sp;
{
	if( mvars.debug ){
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "viewchange( %d, x%x )\n", cmd, sp );
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
	switch( cmd )  {
	case DM_CHGV_ADD:
		break;
	case DM_CHGV_REDO:
		break;
	case DM_CHGV_DEL:
		break;
	case DM_CHGV_REPL:
		return;
	case DM_CHGV_ILLUM:
		break;
	}
}

void
Ir_debug(lvl)
{
	mvars.debug = lvl;
}

void
Ir_window(w)
int w[];
{
}


/*
 *  			I R _ C O L O R C H A N G E
 *  
 *  Go through the solid table, and allocate color map slots.
 *	8 bit system gives 4 or 8,
 *	24 bit system gives 12 or 24.
 */
void
Ir_colorchange()
{
	register int i;
	register int nramp;

	if( mvars.debug )
	  Tcl_AppendResult(interp, "colorchange\n", (char *)NULL);

	/* Program the builtin colors */
	ir_rgbtab[0].r=0; 
	ir_rgbtab[0].g=0; 
	ir_rgbtab[0].b=0;/* Black */
	ir_rgbtab[1].r=255; 
	ir_rgbtab[1].g=0; 
	ir_rgbtab[1].b=0;/* Red */
	ir_rgbtab[2].r=0; 
	ir_rgbtab[2].g=0; 
	ir_rgbtab[2].b=255;/* Blue */
	ir_rgbtab[3].r=255; 
	ir_rgbtab[3].g=255;
	ir_rgbtab[3].b=0;/*Yellow */
	ir_rgbtab[4].r = ir_rgbtab[4].g = ir_rgbtab[4].b = 255; /* White */
	slotsused = 5;

	if( mvars.rgb )  {
		if(mvars.cueing_on) {
			depthcue(1);
		} else {
			depthcue(0);
		}

		RGBcolor( (short)255, (short)255, (short)255 );

		/* apply region-id based colors to the solid table */
		color_soltab();

		return;
	}

	ir_nslots = getplanes();
	if(mvars.cueing_on && (ir_nslots < 7)) {
	  Tcl_AppendResult(interp, "Too few bitplanes: depthcueing disabled\n");
	  mvars.cueing_on = 0;
	}
	ir_nslots = 1<<ir_nslots;
	if( ir_nslots > NSLOTS )  ir_nslots = NSLOTS;
	if(mvars.cueing_on) {
		/* peel off reserved ones */
		ir_nslots = (ir_nslots - CMAP_BASE) / CMAP_RAMP_WIDTH;
		depthcue(1);
	} else {
		ir_nslots -= CMAP_BASE;	/* peel off the reserved entries */
		depthcue(0);
	}

	ovec = -1;	/* Invalidate the old colormap entry */

	/* apply region-id based colors to the solid table */
	color_soltab();

	/* Map the colors in the solid table to colormap indices */
	ir_colorit();

	for( i=0; i < slotsused; i++ )  {
		gen_color( i, ir_rgbtab[i].r, ir_rgbtab[i].g, ir_rgbtab[i].b);
	}

	color(WHITE);	/* undefinied after gconfig() */
}

void
ir_colorit()
{
	register struct solid	*sp;
	register struct rgbtab *rgb;
	register int i;
	register int r,g,b;

	if( mvars.rgb )  return;

	FOR_ALL_SOLIDS (sp, &HeadSolid.l) {
		r = sp->s_color[0];
		g = sp->s_color[1];
		b = sp->s_color[2];
		if( (r == 255 && g == 255 && b == 255) ||
		    (r == 0 && g == 0 && b == 0) )  {
			sp->s_dmindex = DM_WHITE;
			continue;
		}

		/* First, see if this matches an existing color map entry */
		rgb = ir_rgbtab;
		for( i = 0; i < slotsused; i++, rgb++ )  {
			if( rgb->r == r && rgb->g == g && rgb->b == b )  {
				sp->s_dmindex = i;
				goto next;
			}
		}

		/* If slots left, create a new color map entry, first-come basis */
		if( slotsused < ir_nslots )  {
			rgb = &ir_rgbtab[i=(slotsused++)];
			rgb->r = r;
			rgb->g = g;
			rgb->b = b;
			sp->s_dmindex = i;
			continue;
		}
		sp->s_dmindex = DM_YELLOW;	/* Default color */
next:		
		;
	}
}

/*
 *  I R _ D B T E X T
 *
 *  Used to call dbtext to print cute messages on the button box,
 *  if you have one.  Has to shift everythign to upper case
 *  since the box goes off the deep end with lower case.
 *
 *  Because not all SGI button boxes have text displays,
 *  this now needs to go to stdout in order to be useful.
 */

ir_dbtext(str)
register char *str;
{
#if IR_BUTTONS
	register i;
	char	buf[9];
	register char *cp;

# if 0
	for(i = 0, cp = buf; i < 8 && *str; i++, cp++, str++)
		*cp = islower(*str) ?  toupper(*str) : *str;
	*cp = 0;
	dbtext(buf);
# else
	Tcl_AppendResult(interp, "dm-4d: You pressed Help key and '", str,
			 "'\n", (char *)NULL);
# endif
#else
	return;
#endif
}

#if IR_KNOBS
/*
 *			I R L I M I T
 *
 * Because the dials are so sensitive, setting them exactly to
 * zero is very difficult.  This function can be used to extend the
 * location of "zero" into "the dead zone".
 */
static 
int irlimit(i)
int i;
{
	if( i > NOISE )
		return( i-NOISE );
	if( i < -NOISE )
		return( i+NOISE );
	return(0);
}
#endif

/*			G E N _ C O L O R
 *
 *	maps a given color into the appropriate colormap entry
 *	for both depthcued and non-depthcued mode.  In depthcued mode,
 *	gen_color also generates the colormap ramps.  Note that in depthcued
 *	mode, DM_BLACK uses map entry 0, and does not generate a ramp for it.
 *	Non depthcued mode skips the first CMAP_BASE colormap entries.
 *
 *	This routine is not called at all if ir_has_rgb is set.
 */
gen_color(c)
int c;
{
	if(mvars.cueing_on) {

		/*  Not much sense in making a ramp for DM_BLACK.  Besides
		 *  which, doing so, would overwrite the bottom color
		 *  map entries, which is a no-no.
		 */
		if( c != DM_BLACK) {
			register int i;
			fastf_t r_inc, g_inc, b_inc;
			fastf_t red, green, blue;

			r_inc = ir_rgbtab[c].r/16;
			g_inc = ir_rgbtab[c].g/16;
			b_inc = ir_rgbtab[c].b/16;

			red = ir_rgbtab[c].r;
			green = ir_rgbtab[c].g;
			blue = ir_rgbtab[c].b;

			for(i = 15; i >= 0;
			    i--, red -= r_inc, green -= g_inc, blue -= b_inc)
				mapcolor( MAP_ENTRY(c) + i,
				    (short)red,
				    (short)green,
				    (short)blue );
		}
	} else {
		mapcolor(c+CMAP_BASE,
		    ir_rgbtab[c].r, ir_rgbtab[c].g, ir_rgbtab[c].b);
	}
}

#ifdef never
/*
 *  Update the PF key lights.
 */
static int
kblights()
{
	char	lights;

	lights = (mvars.cueing_on)
	    | (mvars.zclipping_on << 1)
	    | (perspective_mode << 2)
	    | (mvars.zbuffer_on << 3);

	lampon(lights);
	lampoff(lights^0xf);
}
#endif

static void
establish_zbuffer()
{
	if( mvars.zbuf == 0 )  {
	  Tcl_AppendResult(interp, "dm-4d: This machine has no Zbuffer to enable\n", (char *)NULL);
		mvars.zbuffer_on = 0;
	}
	zbuffer( mvars.zbuffer_on );
	if( mvars.zbuffer_on)  {
		/* Set screen coords of near and far clipping planes */
		lsetdepth(mvars.min_scr_z, mvars.max_scr_z);
	}
	dmaflag = 1;
}

ir_clear_to_black()
{
	/* Re-enable the full viewport */
	viewport(0, winx_size, 0, winy_size);

	if( mvars.zbuffer_on )  {
		zfunction( ZF_LEQUAL );
		if( mvars.rgb )  {
			czclear( 0x000000, mvars.max_scr_z );
		} else {
			czclear( BLACK, mvars.max_scr_z );
		}
	} else {
		if( mvars.rgb )  {
			RGBcolor( (short)0, (short)0, (short)0 );
		} else {
			color(BLACK);
		}
		clear();
	}
}

#if 0
/* Handy fakeouts when we don't want to link with -lmpc */
usinit()	{ 
	bu_log("usinit\n"); 
}
usnewlock()	{ 
	bu_log("usnewlock\n"); 
}
taskcreate()	{ 
	bu_log("taskcreate\n"); 
}
#endif

/*
 *  The structparse will change the value of the variable.
 *  Just implement it, here.
 */
static void
establish_lighting()
{
	if( !mvars.lighting_on )  {
		/* Turn it off */
		mmode(MVIEWING);
		lmbind(MATERIAL,0);
		lmbind(LMODEL,0);
		mmode(MSINGLE);
	} else {
		/* Turn it on */
		if( mvars.cueing_on )  {
			/* Has to be off for lighting */
			mvars.cueing_on = 0;
			Ir_colorchange();
		}

		mmode(MVIEWING);


		make_materials();	/* Define material properties */

		lmbind(LMODEL, 2);	/* infinite */
		lmbind(LIGHT2,2);
		lmbind(LIGHT3,3);
		lmbind(LIGHT4,4);
		lmbind(LIGHT5,5);

		/* RGB color commands & lighting */
		lmcolor( LMC_COLOR );

		mmode(MSINGLE);
	}
	dmaflag = 1;
}

/*
 *  Some initial lighting model stuff
 *  Really, MGED needs to derrive it's lighting from the database,
 *  but for now, this hack will suffice.
 *
 *  For materials, the definitions are:
 *	ALPHA		opacity.  1.0=opaque
 *	AMBIENT		ambient reflectance of the material  0..1
 *	DIFFUSE		diffuse reflectance of the material  0..1
 *	SPECULAR	specular reflectance of the material  0..1
 *	EMISSION	emission color ???
 *	SHININESS	specular scattering exponent, integer 0..128
 */
static float material_default[] = {
	ALPHA,		1.0,
	AMBIENT,	0.2, 0.2, 0.2,
	DIFFUSE,	0.8, 0.8, 0.8,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	0.0,
	SPECULAR,	0.0, 0.0, 0.0,
	LMNULL   };

/* Something like the RT default phong material */
static float material_rtdefault[] = {
	ALPHA,		1.0,	
	AMBIENT,	0.2, 0.2, 0.2,	/* 0.4 in rt */
	DIFFUSE,	0.6, 0.6, 0.6,
	SPECULAR,	0.2, 0.2, 0.2,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	10.0,
	LMNULL   };

/* This was the "default" material in the demo */
static float material_xdefault[] = {
	AMBIENT, 0.35, 0.25,  0.1,
	DIFFUSE, 0.1, 0.5, 0.1,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 5.0,
	LMNULL   };

static float mat_brass[] = {
	AMBIENT, 0.35, 0.25,  0.1,
	DIFFUSE, 0.65, 0.5, 0.35,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 5.0,
	LMNULL   };

static float mat_shinybrass[] = {
	AMBIENT, 0.25, 0.15, 0.0,
	DIFFUSE, 0.65, 0.5, 0.35,
	SPECULAR, 0.9, 0.6, 0.0,
	SHININESS, 10.0,
	LMNULL   };

static float mat_pewter[] = {
	AMBIENT, 0.0, 0.0,  0.0,
	DIFFUSE, 0.6, 0.55 , 0.65,
	SPECULAR, 0.9, 0.9, 0.95,
	SHININESS, 10.0,
	LMNULL   };

static float mat_silver[] = {
	AMBIENT, 0.4, 0.4,  0.4,
	DIFFUSE, 0.3, 0.3, 0.3,
	SPECULAR, 0.9, 0.9, 0.95,
	SHININESS, 30.0,
	LMNULL   };

static float mat_gold[] = {
	AMBIENT, 0.4, 0.2, 0.0,
	DIFFUSE, 0.9, 0.5, 0.0,
	SPECULAR, 0.7, 0.7, 0.0,
	SHININESS, 10.0,
	LMNULL   };

static float mat_shinygold[] = {
	AMBIENT, 0.4, 0.2,  0.0,
	DIFFUSE, 0.9, 0.5, 0.0,
	SPECULAR, 0.9, 0.9, 0.0,
	SHININESS, 20.0,
	LMNULL   };

static float mat_plaster[] = {
	AMBIENT, 0.2, 0.2,  0.2,
	DIFFUSE, 0.95, 0.95, 0.95,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 1.0,
	LMNULL   };

static float mat_redplastic[] = {
	AMBIENT, 0.3, 0.1, 0.1,
	DIFFUSE, 0.5, 0.1, 0.1,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_greenplastic[] = {
	AMBIENT, 0.1, 0.3, 0.1,
	DIFFUSE, 0.1, 0.5, 0.1,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_blueplastic[] = {
	AMBIENT, 0.1, 0.1, 0.3,
	DIFFUSE, 0.1, 0.1, 0.5,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_greenflat[] = {
	EMISSION,   0.0, 0.4, 0.0,
	AMBIENT,    0.0, 0.0, 0.0,
	DIFFUSE,    0.0, 0.0, 0.0,
	SPECULAR,   0.0, 0.6, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_greenshiny[]= {
	EMISSION, 0.0, 0.4, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.25, 0.9, 0.25,
	SHININESS, 10.0,
	LMNULL
};

static float mat_blueflat[] = {
	EMISSION, 0.0, 0.0, 0.4,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.0, 0.5, 0.5,
	SPECULAR,  0.0, 0.0, 0.9,
	SHININESS, 10.0,
	LMNULL
};

static float mat_blueshiny[] = {
	EMISSION, 0.0, 0.0, 0.6,
	AMBIENT,  0.1, 0.25, 0.5,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_redflat[] = {
	EMISSION, 0.60, 0.0, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 1.0,
	LMNULL
};

static float mat_redshiny[] = {
	EMISSION, 0.60, 0.0, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_beigeshiny[] = {
	EMISSION, 0.5, 0.5, 0.6,
	AMBIENT,  0.35, 0.35, 0.0,
	DIFFUSE,  0.5, 0.5, 0.0,
	SPECULAR,  0.5, 0.5, 0.0,
	SHININESS, 10.0,
	LMNULL
};

/*
 *  Meanings of the parameters:
 *	AMBIENT		ambient light associated with this source ???, 0..1
 *	LCOLOR		light color, 0..1
 *	POSITION	position of light.  w=0 for infinite lights
 */
static float default_light[] = {
	AMBIENT,	0.0, 0.0, 0.0, 
	LCOLOR,		1.0, 1.0, 1.0, 
	POSITION,	0.0, 0.0, 1.0, 0.0,
	LMNULL};


#if 1
# if 0
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 100.0, -200.0, 100.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.6, 0.1, 0.1, 
	POSITION, -100.0, -30.0, 100.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.3, 0.1, 
	POSITION, 100.0, -20.0, 20.0, 0.0, 
	LMNULL};


static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.3, 
	POSITION, 0.0, 100.0, -100.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 1.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};
# else
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 100.0, 200.0, 100.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.6, 0.1, 0.1, 
	POSITION, 100.0, 30.0, 100.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.3, 0.1, 
	POSITION, -100.0, 20.0, 20.0, 0.0, 
	LMNULL};


static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.3, 
	POSITION, 0.0, -100.0, -100.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 1.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};
# endif

#else
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 10.0, 50.0, 50.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.5, 0.1, 0.1, 
	POSITION, -100.0, 0.0, 0.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.5, 0.1, 
	POSITION, 100.0, 50.0, 0.0, 0.0, 
	LMNULL};

static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.5, 
	POSITION, 0.0, -50.0, 0.0, 0.0, 
	LMNULL};

static float orange_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,	0.35, 0.175, 0.0, 
	POSITION, -50.0, 50.0, 10.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};


#endif




/*
 *  Lighting model parameters
 *	AMBIENT		amount of ambient light present in the scene, 0..1
 *	ATTENUATION	fixed and variable attenuation factor, 0..1
 *	LOCALVIEWER	1=eye at (0,0,0), 0=eye at (0,0,+inf)
 */
static float	default_lmodel[] = {
	AMBIENT,	0.2,  0.2,  0.2,
	ATTENUATION,	1.0, 0.0, 
	LOCALVIEWER,	0.0, 
	LMNULL};

static float infinite[] = {
	AMBIENT, 0.3,  0.3, 0.3, 
	LOCALVIEWER, 0.0, 
	LMNULL};

static float local[] = {
	AMBIENT, 0.3,  0.3, 0.3, 
	LOCALVIEWER, 1.0, 
	ATTENUATION, 1.0, 0.0, 
	LMNULL};


make_materials()
{
	/* define material properties */
	lmdef (DEFMATERIAL, 1, 0, material_default);

	lmdef (DEFMATERIAL, 2, 0, mat_brass);
	lmdef (DEFMATERIAL, 3, 0, mat_shinybrass);
	lmdef (DEFMATERIAL, 4, 0, mat_pewter);
	lmdef (DEFMATERIAL, 5, 0, mat_silver);
	lmdef (DEFMATERIAL, 6, 0, mat_gold);
	lmdef (DEFMATERIAL, 7, 0, mat_shinygold);
	lmdef (DEFMATERIAL, 8, 0, mat_plaster);
	lmdef (DEFMATERIAL, 9, 0, mat_redplastic);
	lmdef (DEFMATERIAL, 10, 0, mat_greenplastic);
	lmdef (DEFMATERIAL, 11, 0, mat_blueplastic);

	lmdef (DEFMATERIAL, 12, 0, mat_greenflat);
	lmdef (DEFMATERIAL, 13, 0, mat_greenshiny);

	lmdef (DEFMATERIAL, 14, 0, mat_blueflat);
	lmdef (DEFMATERIAL, 15, 0, mat_blueshiny);

	lmdef (DEFMATERIAL, 16, 0, mat_redflat);
	lmdef (DEFMATERIAL, 17, 0, mat_redshiny);

	lmdef (DEFMATERIAL, 18, 0, mat_beigeshiny);

	lmdef( DEFMATERIAL, 19, 0, material_xdefault );
	lmdef( DEFMATERIAL, 20, 0, material_rtdefault );

	/*    lmdef (DEFLIGHT, 1, 0, default_light); */
	lmdef (DEFLIGHT, 4, 0, green_inf_light);
	lmdef (DEFLIGHT, 2, 0, white_inf_light);
	lmdef (DEFLIGHT, 3, 0, red_inf_light);
	lmdef (DEFLIGHT, 4, 0, green_inf_light);
	lmdef (DEFLIGHT, 5, 0, blue_inf_light);
	/*    lmdef (DEFLIGHT, 6, 0, orange_inf_light); */
	lmdef (DEFLIGHT, 7, 0, white_local_light);

	lmdef (DEFLMODEL, 1, 0, default_lmodel);
	lmdef (DEFLMODEL, 2, 0, infinite);
	lmdef (DEFLMODEL, 3, 0, local);


}

/*
 *  Check to see if setmonitor(STR_RECT) will work.
 *  Returns -
 *	> 0	If stereo is available
 *	0	If not
 */
int
sgi_has_stereo()
{
#if !defined(__sgi) && !defined(__mips)
	/* IRIX 3 systems, test to see if DER1_STEREO bit is
	 * read/write (no hardware underneath), or
	 * read only (hardware underneath, which can't be read back.
	 */
	int	rw_orig, rw1, rw2;

	rw_orig = getvideo(DE_R1);
	rw1 = rw_orig ^ DER1_STEREO;	/* Toggle the bit */
	setvideo(DE_R1, rw1);
	rw2 = getvideo(DE_R1);
	if( rw1 != rw2 )  {
		setvideo(DE_R1, rw_orig);/* Restore original state */
		return 1;		/* Has stereo */
	}
	rw1 = rw1 ^ DER1_STEREO;	/* Toggle the bit, again */
	setvideo(DE_R1, rw1);
	rw2 = getvideo(DE_R1);
	if( rw1 != rw2 )  {
		setvideo(DE_R1, rw_orig);/* Restore original state */
		return 1;		/* Has stereo */
	}
	setvideo(DE_R1, rw_orig);	/* Restore original state */
	return 0;			/* Does not have stereo */
#else
	/* IRIX 4 systems */
	return getgdesc(GD_STEREO);
#endif
}

/*
 *			I R _ D M
 * 
 *  Implement display-manager specific commands, from MGED "dm" command.
 */
int
Ir_dm(argc, argv)
int	argc;
char	**argv;
{
	struct bu_vls	vls;
	struct bu_vls tmp_vls;

	if( argc < 1 )  return -1;

	/* For now, only "set" command is implemented */
	if( strcmp( argv[0], "set" ) != 0 )  {
	  Tcl_AppendResult(interp, "dm: command is not 'set'\n", (char *)NULL);
	  return TCL_ERROR;
	}

	bu_vls_init(&vls);
	bu_vls_init(&tmp_vls);
	start_catching_output(&tmp_vls);

	if( argc < 2 )  {
		/* Bare set command, print out current settings */
	  bu_struct_print( "dm_4d internal variables", Ir_vparse, (char *)&mvars );
		bu_log("%s", bu_vls_addr(&vls) );
	} else if( argc == 2 ) {
	  bu_vls_struct_item_named( &vls, Ir_vparse, argv[1], (char *)&mvars, ',');
		bu_log( "%s\n", bu_vls_addr(&vls) );
  	} else {
	        bu_vls_printf( &vls, "%s=\"", argv[1] );
	        bu_vls_from_argv( &vls, argc-2, argv+2 );
		bu_vls_putc( &vls, '\"' );
		bu_struct_parse( &vls, Ir_vparse, (char *)&mvars );
	}

	bu_vls_free(&vls);

	stop_catching_output(&tmp_vls);
	Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	bu_vls_free(&tmp_vls);
	return TCL_OK;
}

static void
ir_var_init()
{
  dm_vars = (char *)bu_malloc(sizeof(struct ir_vars), "ir_var_init: ir_vars");
  bzero((void *)dm_vars, sizeof(struct ir_vars));
  mvars.cueing_on = 1;
  mvars.zclipping_on = 1;
  mvars.zbuffer_on = 1;
  mvars.linewidth = 1;
  win = -1;
}
@


11.34
log
@FOR_ALL_SOLIDS macro needed another arg
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.33 1996/09/03 20:02:37 bparker Exp jra $ (BRL)";
@


11.33
log
@rt_list ---> bu_list
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.32 1996/09/03 16:31:38 bparker Exp bparker $ (BRL)";
d54 2
a55 1
#include "./dm.h"
d57 1
a57 1
#include "./solid.h"
d2180 1
a2180 1
	FOR_ALL_SOLIDS( sp )  {
@


11.32
log
@check in Lee's changes
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.31 1996/08/29 23:37:36 butler Exp butler $ (BRL)";
d50 1
a51 1
#include "bu.h"
d1116 1
a1116 1
	for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
@


11.31
log
@structparse moved to libbu
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.30 1996/08/29 23:08:21 butler Exp butler $ (BRL)";
d2853 1
a2853 1
	  bu_structprint( "dm_4d internal variables", Ir_vparse, (char *)&mvars );
d2856 1
a2856 1
	  bu_vls_name_print( &vls, Ir_vparse, argv[1], (char *)&mvars );
d2862 1
a2862 1
		bu_structparse( &vls, Ir_vparse, (char *)&mvars );
@


11.30
log
@structparse moved to libbu
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.29 1996/08/27 20:30:05 bparker Exp butler $ (BRL)";
d2853 1
a2853 1
	  rt_structprint( "dm_4d internal variables", Ir_vparse, (char *)&mvars );
d2856 1
a2856 1
	  rt_vls_name_print( &vls, Ir_vparse, argv[1], (char *)&mvars );
@


11.29
log
@now using libbu
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.28 1996/07/30 21:29:43 bparker Exp bparker $ (BRL)";
d51 1
d234 1
a234 1
struct structparse Ir_vparse[] = {
d2862 1
a2862 1
		rt_structparse( &vls, Ir_vparse, (char *)&mvars );
@


11.28
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.27 1996/07/10 20:26:12 bparker Exp bparker $ (BRL)";
d440 1
a440 1
	rt_vls_printf(&pathName, ".dm_4d");
d468 1
a468 1
			rt_log("mged/dm-4d.c: getinvent() INV_GRAPHICS type=%d not recognized, you need to modify the source code\n",
d549 1
a549 1
	rt_log("4D: gt=%d, zbuf=%d, rgb=%d\n", ir_is_gt, mvars.zbuf, mvars.rgb);
d801 1
a801 1
    rt_free(dm_vars, "Ir_close: dm_vars");
d1360 1
a1360 1
  struct rt_vls cmd;
d1367 1
a1367 1
  rt_vls_init(&cmd);
d1374 1
a1374 1
    struct rt_vls tmp_vls;
d1376 4
a1379 4
    rt_vls_init(&tmp_vls);
    rt_vls_printf(&tmp_vls, "blkqread gave %d\n", n);
    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
    rt_vls_free(&tmp_vls);
d1385 1
a1385 1
      struct rt_vls tmp_vls;
d1387 4
a1390 4
      rt_vls_init(&tmp_vls);
      rt_vls_printf(&tmp_vls, "qread ret=%d, val=%d\n", ret, valp[1]);
      Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
      rt_vls_free(&tmp_vls);
d1449 1
a1449 1
				rt_vls_printf(&cmd,
d1465 1
a1465 1
				rt_vls_printf(&cmd,
d1476 1
a1476 1
				rt_vls_printf(&cmd,
d1487 1
a1487 1
				rt_vls_printf( &cmd,
d1502 1
a1502 1
				rt_vls_printf(&cmd,
d1513 1
a1513 1
				rt_vls_printf(&cmd,
d1525 1
a1525 1
				if(perspective_mode) rt_vls_printf( &cmd,
d1541 1
a1541 1
				rt_vls_strcat( &cmd,
d1546 1
a1546 1
				rt_vls_strcat( &cmd,
d1560 1
a1560 1
				rt_vls_strcat( &cmd,
d1587 1
a1587 1
				rt_vls_strcat( &cmd,
d1589 1
a1589 1
				rt_vls_strcat( &cmd,
d1591 1
a1591 1
				rt_vls_strcat( &cmd,
d1610 1
a1610 1
	rt_vls_strcat(&cmd, "press 35,25\n");
d1619 1
a1619 1
	rt_vls_strcat(&cmd, "press 45,45\n");
d1628 1
a1628 1
	rt_vls_strcat(&cmd, "adc\n");
d1637 1
a1637 1
	rt_vls_strcat(&cmd, "press bottom\n");
d1646 1
a1646 1
	rt_vls_strcat(&cmd, "set e_axes !\n");
d1655 1
a1655 1
	rt_vls_strcat(&cmd, "press front\n");
d1664 1
a1664 1
	rt_vls_strcat(&cmd, "aip f\n");
d1673 1
a1673 1
	rt_vls_strcat(&cmd, "press left\n");
d1682 1
a1682 1
	rt_vls_strcat(&cmd, "press oill\n");
d1691 1
a1691 1
	rt_vls_strcat(&cmd, "M 1 0 0\n");
d1700 1
a1700 1
	rt_vls_strcat(&cmd, "press reject\n");
d1709 1
a1709 1
	rt_vls_strcat(&cmd, "press right\n");
d1718 1
a1718 1
	rt_vls_strcat(&cmd, "press sill\n");
d1727 1
a1727 1
	rt_vls_strcat(&cmd, "press top\n");
d1736 1
a1736 1
	rt_vls_strcat(&cmd, "aip b\n");
d1745 1
a1745 1
	rt_vls_strcat(&cmd, "set v_axes !\n");
d1754 1
a1754 1
	rt_vls_strcat(&cmd, "set w_axes !\n");
d1782 1
a1782 1
					rt_vls_printf( &cmd, "knob ang1 %d\n",
d1787 1
a1787 1
				rt_vls_printf( &cmd , "knob S %f\n",
d1792 1
a1792 1
					rt_vls_printf( &cmd , "knob ang2 %d\n",
d1796 1
a1796 1
				    rt_vls_printf( &cmd , "knob z %f\n",
d1799 1
a1799 1
				    rt_vls_printf( &cmd , "knob az %f\n",
d1805 1
a1805 1
					rt_vls_printf( &cmd , "knob distadc %d\n",
d1809 1
a1809 1
				    rt_vls_printf( &cmd , "knob Z %f\n",
d1812 1
a1812 1
				    rt_vls_printf( &cmd , "knob aZ %f\n",
d1818 1
a1818 1
					rt_vls_printf( &cmd , "knob yadc %d\n",
d1822 1
a1822 1
				    rt_vls_printf( &cmd , "knob y %f\n",
d1825 1
a1825 1
				    rt_vls_printf( &cmd , "knob ay %f\n",
d1831 1
a1831 1
				  rt_vls_printf( &cmd , "knob Y %f\n",
d1834 1
a1834 1
				  rt_vls_printf( &cmd , "knob aY %f\n",
d1839 1
a1839 1
					rt_vls_printf( &cmd , "knob xadc %d\n",
d1843 1
a1843 1
				    rt_vls_printf( &cmd , "knob x %f\n",
d1846 1
a1846 1
				    rt_vls_printf( &cmd , "knob ax %f\n",
d1852 1
a1852 1
				  rt_vls_printf( &cmd , "knob X %f\n",
d1855 1
a1855 1
				  rt_vls_printf( &cmd , "knob aX %f\n",
d1901 1
a1901 1
			rt_vls_printf( &cmd, "%c %d %d %d\n",
d1927 1
a1927 1
		    struct rt_vls tmp_vls;
d1929 4
a1932 4
		    rt_vls_init(&tmp_vls);
		    rt_vls_printf(&tmp_vls, "IRIS device %d gave %d?\n", ret, valp[1]);
		    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		    rt_vls_free(&tmp_vls);
d1940 1
a1940 1
  rt_vls_free(&cmd);
d2007 1
a2007 1
	  struct rt_vls tmp_vls;
d2009 4
a2012 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "statechange %d %d\n", a, b );
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d2038 1
a2038 1
	    struct rt_vls tmp_vls;
d2040 4
a2043 4
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "Ir_statechange: unknown state %s\n", state_str[b]);
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d2056 1
a2056 1
	  struct rt_vls tmp_vls;
d2058 4
a2061 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "viewchange( %d, x%x )\n", cmd, sp );
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d2369 1
a2369 1
	rt_log("usinit\n"); 
d2372 1
a2372 1
	rt_log("usnewlock\n"); 
d2375 1
a2375 1
	rt_log("taskcreate\n"); 
d2835 2
a2836 2
	struct rt_vls	vls;
	struct rt_vls tmp_vls;
d2846 2
a2847 2
	rt_vls_init(&vls);
	rt_vls_init(&tmp_vls);
d2853 1
a2853 1
		rt_log("%s", rt_vls_addr(&vls) );
d2856 1
a2856 1
		rt_log( "%s\n", rt_vls_addr(&vls) );
d2858 3
a2860 3
	        rt_vls_printf( &vls, "%s=\"", argv[1] );
	        rt_vls_from_argv( &vls, argc-2, argv+2 );
		rt_vls_putc( &vls, '\"' );
d2864 1
a2864 1
	rt_vls_free(&vls);
d2867 2
a2868 2
	Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	rt_vls_free(&tmp_vls);
d2875 1
a2875 1
  dm_vars = (char *)rt_malloc(sizeof(struct ir_vars), "ir_var_init: ir_vars");
@


11.27
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.26 1996/06/21 16:07:33 bparker Exp bparker $ (BRL)";
d719 1
a719 1
        qdevice(EKEY); /* set e_axis ! */
d730 2
a731 2
        qdevice(VKEY); /* set v_axis ! */
        qdevice(WKEY); /* set w_axis ! */
d1642 1
a1642 1
	  ir_dbtext("set e_axis !");
d1646 1
a1646 1
	rt_vls_strcat(&cmd, "set e_axis !\n");
d1741 1
a1741 1
	  ir_dbtext("set v_axis !");
d1745 1
a1745 1
	rt_vls_strcat(&cmd, "set v_axis !\n");
d1750 1
a1750 1
	  ir_dbtext("set w_axis");
d1754 1
a1754 1
	rt_vls_strcat(&cmd, "set w_axis !\n");
@


11.26
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.25 1996/05/24 18:42:47 bparker Exp bparker $ (BRL)";
d767 1
d770 1
@


11.25
log
@added support for absolute rotate etc. via the knobs
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.24 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d1772 1
a1772 1
				    (adcflag ? kn1_knobs:kn2_knobs)[ret-DIAL0]);
d1779 1
a1779 1
				if(adcflag) {
d1789 1
a1789 1
				if(adcflag)
d1802 1
a1802 1
				if(adcflag)
d1815 1
a1815 1
				if(adcflag)
d1836 1
a1836 1
				if(adcflag)
@


11.24
log
@Still Tcl'ing the code
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.23 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d442 17
d546 2
d1792 8
a1799 3
				else
					rt_vls_printf( &cmd , "knob z %f\n",
							setting/2048.0 );
d1805 8
a1812 3
				else
					rt_vls_printf( &cmd , "knob Z %f\n",
							setting/2048.0 );
d1818 8
a1825 3
				else
					rt_vls_printf( &cmd , "knob y %f\n",
							setting/2048.0 );
d1828 6
a1833 2
				rt_vls_printf( &cmd , "knob Y %f\n",
							setting/2048.0 );
d1839 8
a1846 3
				else
					rt_vls_printf( &cmd , "knob x %f\n",
							setting/2048.0 );
d1849 6
a1854 2
				rt_vls_printf( &cmd , "knob X %f\n",
							setting/2048.0 );
d1936 1
@


11.23
log
@still tcl-converting
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.22 1996/01/26 15:52:43 bparker Exp bparker $ (BRL)";
d326 2
a327 2
			rt_log("dm-4d: setting NTSC size window\n");
			monitor = NTSC;
a429 1
	ogl_sgi_used = 1;
d436 1
d483 1
a483 1
		case INV_GR1BOARD:	/* Persoanl Iris */
d748 3
d776 2
a777 2
  Tk_DeleteFileHandler(ir_fd);
  rt_free(dm_vars, "Ir_close: dm_vars");
d779 3
d805 1
a805 1
	if( dmaflag && !mvars.doublebuffer )
d1165 1
a1165 2
	if( !dmaflag )
		return;
d1347 1
d1352 8
a1359 2
  if( mvars.debug )
    rt_log("blkqread gave %d\n", n);
d1363 8
a1370 2
    if( mvars.debug )
      rt_log("qread ret=%d, val=%d\n", ret, valp[1]);
d1877 9
a1885 2
			rt_log("IRIS device %d gave %d?\n", ret, valp[1]);
			break;
d1956 8
a1963 1
	if( mvars.debug ) rt_log("statechange %d %d\n", a, b );
d1987 9
a1995 2
		rt_log("Ir_statechange: unknown state %s\n", state_str[b]);
		break;
d2005 8
a2012 1
	if( mvars.debug ) rt_log("viewchange( %d, x%x )\n", cmd, sp );
d2053 2
a2054 1
	if( mvars.debug )  rt_log("colorchange\n");
d2089 2
a2090 2
		rt_log("Too few bitplanes: depthcueing disabled\n");
		mvars.cueing_on = 0;
d2187 2
a2188 1
	rt_log("dm-4d: You pressed Help key and '%s'\n", str);
d2283 1
a2283 1
		rt_log("dm-4d: This machine has no Zbuffer to enable\n");
d2786 1
d2792 2
a2793 2
		rt_log("dm: command is not 'set'\n");
		return CMD_BAD;
d2797 3
d2813 1
d2815 5
a2819 1
	return CMD_OK;
@


11.22
log
@*** empty log message ***
@
text
@a0 1
#ifdef MULTI_ATTACH
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.21 1996/01/23 16:24:05 bparker Exp bparker $ (BRL)";
d130 1
a417 1
	static int      count = 0;
d419 6
d432 4
a435 4
		rt_log("Can't attach sgi, because a direct OpenGL context has\n");
		rt_log("previously been opened in this session. To use sgi,\n");
		rt_log("quit this session and reopen it.\n");
		return(-1);
d440 1
a440 2
	rt_vls_init(&pathName);
	rt_vls_printf(&pathName, ".dm_4d%d", count++);
d551 2
a552 2
		rt_log( "No more graphics ports available.\n" );
		return	-1;
d563 2
a564 2
			rt_log("NOTICE: This SGI does not have stereo display capability\n");
			stereo_is_on = 0;
d591 2
a592 2
			rt_log( "No more graphics ports available.\n" );
			return	-1;
d606 2
a607 2
			rt_log( "No more graphics ports available.\n" );
			return	-1;
d616 2
a617 2
			rt_log( "No more graphics ports available.\n" );
			return	-1;
d724 2
a725 2
		rt_log("IRIS_open:  mouse button stuck\n");
		sleep(1);
d735 1
d748 4
a751 1
	if(mvars.cueing_on) depthcue(0);
d753 1
a753 1
	lampoff( 0xf );
d755 1
a755 6
	/* avoids error messages when reattaching */
	mmode(MVIEWING);	
	lmbind(LIGHT2,0);
	lmbind(LIGHT3,0);
	lmbind(LIGHT4,0);
	lmbind(LIGHT5,0);
d757 6
d764 3
a766 3
	frontbuffer(1);
	ir_clear_to_black();
	frontbuffer(0);
d768 2
a769 2
	if( getmonitor() != ir_oldmonitor )
		setmonitor(ir_oldmonitor);
d771 1
a771 1
	winclose(gr_id);
d773 2
a774 3
	Tk_DeleteFileHandler(ir_fd);
	rt_free(dm_vars, "Ir_close: dm_vars");
	rt_vls_free(&pathName);
d776 2
a777 1
	return;
d792 1
a792 1
		rt_log( "Ir_prolog\n");
d818 1
a818 1
		rt_log( "Ir_normal\n");
d840 2
a841 1
		rt_log( "Ir_epilog\n");
d893 1
a893 1
		rt_log( "Ir_newrot()\n");
d997 1
a997 1
		rt_log( "Ir_Object()\n");
d1157 2
a1158 1
		rt_log( "Ir_update()\n");
d1175 2
a1176 1
		rt_log( "Ir_puts()\n");
d1201 2
a1202 1
		rt_log( "Ir_2d_line()\n");
d1254 2
a1255 1
		rt_log( "Ir_input()\n");
a2775 2509
#else
/*
 *			D M - 4 D . C
 *
 *  This version for the SGI 4-D Iris, both regular and GT versions.
 *
 *  Uses library -lgl
 *
 *  Authors -
 *	Paul R. Stay
 *	Michael John Muuss
 *	Robert J. Reschly
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.21 1996/01/23 16:24:05 bparker Exp bparker $ (BRL)";
#endif

#include "conf.h"

/* Forwards compat with IRIX 5.0.1 */
#define class	inv_class	/* Map Irix 4 name into Irix 5 name */
#define type	inv_type	/* Map Irix 4 name into Irix 5 name */
#define state	inv_state	/* Map Irix 4 name into Irix 5 name */

#include <stdio.h>
#include <math.h>
#include <termio.h>
#undef VMIN		/* is used in vmath.h, too */
#include <ctype.h>

#include <gl/gl.h>		/* SGI IRIS library */
#include <gl/device.h>		/* SGI IRIS library */
#include <gl/get.h>		/* SGI IRIS library */
#include <gl/cg2vme.h>		/* SGI IRIS, for DE_R1 defn on IRIX 3 */
#include <gl/addrs.h>		/* SGI IRIS, for DER1_STEREO defn on IRIX 3 */
#include <sys/types.h>
#include <sys/time.h>
#include <sys/invent.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "./dm.h"
#include "externs.h"
#include "./solid.h"
#include "tcl.h"

#define YSTEREO		491	/* subfield height, in scanlines */
#define YOFFSET_LEFT	532	/* YSTEREO + YBLANK ? */

extern inventory_t	*getinvent();

/* Display Manager package interface */

#define IRBOUND	4095.9	/* Max magnification in Rot matrix */

int	Ir_open();
void	Ir_close();
MGED_EXTERN(void	Ir_input, (fd_set *input, int noblock) );
void	Ir_prolog(), Ir_epilog();
void	Ir_normal(), Ir_newrot();
void	Ir_update();
void	Ir_puts(), Ir_2d_line(), Ir_light();
int	Ir_object();
unsigned Ir_cvtvecs(), Ir_load();
void	Ir_statechange(), Ir_viewchange(), Ir_colorchange();
void	Ir_window(), Ir_debug();
int	Ir_dm();
void    Ircheckevents();

/*
 * These variables are visible and modifiable via a "dm set" command.
 */
static int	cueing_on = 1;		/* Depth cueing flag - for colormap work */
static int	zclipping_on = 1;	/* Z Clipping flag */
static int	zbuffer_on = 1;		/* Hardware Z buffer is on */
static int	lighting_on = 0;	/* Lighting model on */
static int	ir_debug;		/* 2 for basic, 3 for full */
static int	no_faceplate = 0;	/* Don't draw faceplate */
static int	ir_linewidth = 1;	/* Line drawing width */
/*
 * These are derived from the hardware inventory -- user can change them,
 * but the results may not be pleasing.  Mostly, this allows them to be seen.
 */
static int	ir_is_gt;		/* 0 for non-GT machines */
static int	ir_has_zbuf;		/* 0 if no Z buffer */
static int	ir_has_rgb;		/* 0 if mapped mode must be used */
static int	ir_has_doublebuffer;	/* 0 if singlebuffer mode must be used */
static int	min_scr_z;		/* based on getgdesc(GD_ZMIN) */
static int	max_scr_z;		/* based on getgdesc(GD_ZMAX) */
/* End modifiable variables */

static int	ir_fd;			/* GL file descriptor to select() on */
static int perspective_mode = 0;	/* Perspective flag */
static int perspective_angle =3;	/* Angle of perspective */

static mat_t	aspect_corr;
static int	stereo_is_on = 0;

static int perspective_table[] = { 
	30, 45, 60, 90 };
static int ovec = -1;		/* Old color map entry number */
static int kblights();
static double	xlim_view = 1.0;	/* args for ortho() */
static double	ylim_view = 1.0;
static CONST char ir_title[] = "BRL MGED";


void		ir_colorit();

#ifdef IR_BUTTONS
/*
 * Map SGI Button numbers to MGED button functions.
 * The layout of this table is suggestive of the actual button box layout.
 */
#define SW_HELP_KEY	SW0
#define SW_ZERO_KEY	SW3
#define HELP_KEY	0
#define ZERO_KNOBS	0
static unsigned char bmap[IR_BUTTONS] = {
	HELP_KEY,    BV_ADCURSOR, BV_RESET,    ZERO_KNOBS,
	BE_O_SCALE,  BE_O_XSCALE, BE_O_YSCALE, BE_O_ZSCALE, 0,           BV_VSAVE,
	BE_O_X,      BE_O_Y,      BE_O_XY,     BE_O_ROTATE, 0,           BV_VRESTORE,
	BE_S_TRANS,  BE_S_ROTATE, BE_S_SCALE,  BE_MENU,     BE_O_ILLUMINATE, BE_S_ILLUMINATE,
	BE_REJECT,   BV_BOTTOM,   BV_TOP,      BV_REAR,     BV_45_45,    BE_ACCEPT,
	BV_RIGHT,    BV_FRONT,    BV_LEFT,     BV_35_25
};
/* Inverse map for mapping MGED button functions to SGI button numbers */
static unsigned char invbmap[BV_MAXFUNC+1];

/* bit 0 == switchlight 0 */
static unsigned long lights;
#endif

#ifdef IR_KNOBS
static int irlimit();			/* provides knob dead spot */
#define NOISE 32		/* Size of dead spot on knob */
/*
 *  Labels for knobs in help mode.
 */
char	*kn1_knobs[] = {
	/* 0 */ "adc <1",	/* 1 */ "zoom", 
	/* 2 */ "adc <2",	/* 3 */ "adc dist",
	/* 4 */ "adc y",	/* 5 */ "y slew",
	/* 6 */ "adc x",	/* 7 */	"x slew"
};
char	*kn2_knobs[] = {
	/* 0 */ "unused",	/* 1 */	"zoom",
	/* 2 */ "z rot",	/* 3 */ "z slew",
	/* 4 */ "y rot",	/* 5 */ "y slew",
	/* 6 */ "x rot",	/* 7 */	"x slew"
};
#endif

/*
 * SGI Color Map table
 */
#define NSLOTS		4080	/* The mostest possible - may be fewer */
static int ir_nslots=0;		/* how many we have, <= NSLOTS */
static int slotsused;		/* how many actually used */
static struct rgbtab {
	unsigned char	r;
	unsigned char	g;
	unsigned char	b;
} ir_rgbtab[NSLOTS];

struct dm dm_4d = {
	Ir_open, Ir_close,
	Ir_input,
	Ir_prolog, Ir_epilog,
	Ir_normal, Ir_newrot,
	Ir_update,
	Ir_puts, Ir_2d_line,
	Ir_light,
	Ir_object,
	Ir_cvtvecs, Ir_load,
	Ir_statechange,
	Ir_viewchange,
	Ir_colorchange,
	Ir_window, Ir_debug,
	0,			/* no "displaylist", per. se. */
	0,			/* multi-window */
	IRBOUND,
	"sgi", "SGI 4d",
	0,			/* mem map */
	Ir_dm
};

extern struct device_values dm_values;	/* values read from devices */

static void	establish_lighting();
static void	establish_zbuffer();


static void
refresh_hook()
{
	dmaflag = 1;
}

struct structparse Ir_vparse[] = {
	{"%d",  1, "depthcue",		(int)&cueing_on,	Ir_colorchange },
	{"%d",  1, "zclip",		(int)&zclipping_on,	refresh_hook },
	{"%d",  1, "zbuffer",		(int)&zbuffer_on,	establish_zbuffer },
	{"%d",  1, "lighting",		(int)&lighting_on,	establish_lighting },
	{"%d",  1, "no_faceplate",	(int)&no_faceplate,	refresh_hook },
	{"%d",  1, "has_zbuf",		(int)&ir_has_zbuf,	refresh_hook },
	{"%d",  1, "has_rgb",		(int)&ir_has_rgb,	Ir_colorchange },
	{"%d",  1, "has_doublebuffer",	(int)&ir_has_doublebuffer, refresh_hook },
	{"%d",  1, "min_scr_z",		(int)&min_scr_z,	refresh_hook },
	{"%d",  1, "max_scr_z",		(int)&max_scr_z,	refresh_hook },
	{"%d",  1, "debug",		(int)&ir_debug,		FUNC_NULL },
	{"%d",  1, "linewidth",		(int)&ir_linewidth,	refresh_hook },
	{"",	0,  (char *)0,		0,			FUNC_NULL }
};

static int	ir_oldmonitor;		/* Old monitor type */
long gr_id;
long win_l, win_b, win_r, win_t;
long winx_size, winy_size;

/* Map +/-2048 GED space into -1.0..+1.0 :: x/2048*/
#define GED2IRIS(x)	(((float)(x))*0.00048828125)

/*
 *  Mouse coordinates are in absolute screen space, not relative to
 *  the window they came from.  Convert to window-relative,
 *  then to MGED-style +/-2048 range.
 */
static int
irisX2ged(x)
register int x;
{
	if( x <= win_l )  return(-2048);
	if( x >= win_r )  return(2047);
	x -= win_l;
	x = ( x / (double)winx_size)*4096.0;
	x -= 2048;
	return(x);
}

static int
irisY2ged(y)
register int y;
{
	if( y <= win_b )  return(-2048);
	if( y >= win_t )  return(2047);
	y -= win_b;
	if( stereo_is_on )  y = (y%512)<<1;
	y = ( y / (double)winy_size)*4096.0;
	y -= 2048;
	return(y);
}

/* 
 *			I R _ C O N F I G U R E _ W I N D O W _ S H A P E
 *
 *  Either initially, or on resize/reshape of the window,
 *  sense the actual size of the window, and perform any
 *  other initializations of the window configuration.
 */
static void
Ir_configure_window_shape()
{
	int		npix;
	int		monitor;

	xlim_view = 1.0;
	ylim_view = 1.0;
	mat_idn(aspect_corr);

	getsize( &winx_size, &winy_size);
	getorigin( &win_l, & win_b );
	win_r = win_l + winx_size;
	win_t = win_b + winy_size;

	/* Write enable all the bloody bits after resize! */
	viewport(0, winx_size, 0, winy_size);

	if( ir_has_zbuf ) establish_zbuffer();
	establish_lighting();
	
	if( ir_has_doublebuffer)
	{
		/* Clear out image from windows underneath */
		frontbuffer(1);
		ir_clear_to_black();
		frontbuffer(0);
		ir_clear_to_black();
	} else
		ir_clear_to_black();

	monitor = getmonitor();
	{
		extern Tcl_Interp *interp;	/* cmd.c */
		char	*val;

		val = Tcl_GetVar2(interp, "sgi_ntsc", NULL, TCL_GLOBAL_ONLY);
		if( val && atoi(val) != 0 )  {
			rt_log("dm-4d: setting NTSC size window\n");
			monitor = NTSC;
		}
	}
	switch( monitor )  {
	default:
		break;
	case NTSC:
		/* Only use the central square part, due to overscan */
		npix = YMAX170-30;
		winx_size = npix * 4 / 3;	/* NTSC aspect ratio */
		winy_size = npix;
		win_l = (XMAX170 - winx_size)/2;
		win_r = win_l + winx_size;
		win_b = (YMAX170-winy_size)/2;
		win_t = win_b + winy_size;

		if( no_faceplate )  {
			/* Use the whole screen, for VR & visualization */
			viewport( 0, XMAX170, 0, YMAX170 );
		} else {
			/* Only use the central (square) faceplate area */
			/*
			 * XXX Does this viewport() call do anything?  (Write enable pixels maybe?)
			 * XXX (1) the first frame (only) is shrunken oddly in X, and
			 * XXX (2) the drawing overflows the boundaries.
			 * XXX Perhaps XY clipping could be used?
			 * At least the aspect ratio is right!
			 */
			/* XXXXX See page 8-9 in the manual.
			 * XXX The best way to do the masking in NTSC mode is to
			 * XXX just set a Z-buffer write mask of 0 on the parts we don't
			 * XXX want to have written.
			 */
			viewport( (XMAX170 - npix)/2, npix + (XMAX170 - npix)/2,
			    (YMAX170-npix)/2, npix + (YMAX170-npix)/2 );
		}
		/* Aspect ratio correction is needed either way */
		xlim_view = XMAX170 / (double)YMAX170;
		ylim_view = 1;	/* YMAX170 / YMAX170 */

		ir_linewidth = 3;
		blanktime(0);	/* don't screensave while recording video! */
		break;
	case PAL:
		/* Only use the central square part */
		npix = YMAXPAL-30;
		winx_size = npix;	/* What is PAL aspect ratio? */
		winy_size = npix;
		win_l = (XMAXPAL - winx_size)/2;
		win_r = win_l + winx_size;
		;
		win_b = (YMAXPAL-winy_size)/2;
		win_t = win_b + winy_size;
		viewport( (XMAXPAL - npix)/2, npix + (XMAXPAL - npix)/2,
		    (YMAXPAL-npix)/2, npix + (YMAXPAL-npix)/2 );
		ir_linewidth = 3;
		blanktime(0);	/* don't screensave while recording video! */
		break;
	}

	ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );
	/* The ortho() call really just makes this matrix: */
	aspect_corr[0] = 1/xlim_view;
	aspect_corr[5] = 1/ylim_view;
}

#define CMAP_BASE	32
#define CMAP_RAMP_WIDTH	16
#define MAP_ENTRY(x)	((cueing_on) ? \
			((x) * CMAP_RAMP_WIDTH + CMAP_BASE) : \
			((x) + CMAP_BASE) )


/*
 *			I R _ O P E N
 *
 *  Fire up the display manager, and the display processor. Note that
 *  this brain-damaged version of the MEX display manager gets terribly
 *  confused if you try to close your last window.  Tough. We go ahead
 *  and close the window.  Ignore the "ERR_CLOSEDLASTWINDOW" error
 *  message. It doesn't hurt anything.  Silly MEX.
 */

int
Ir_open()
{
	register int	i;
	Matrix		m;
	inventory_t	*inv;
	int		win_size=1000;
	int		win_o_x=272;
	int		win_o_y=12;

#ifdef DM_OGL
	/* This is a hack to handle the fact that the sgi attach crashes
	 * if a direct OpenGL context has been previously opened in the 
	 * current mged session. This stops the attach before it crashes.
	 */
	ogl_sgi_used = 1;
	if (ogl_ogl_used){
		rt_log("Can't attach sgi, because a direct OpenGL context has\n");
		rt_log("previously been opened in this session. To use sgi,\n");
		rt_log("quit this session and reopen it.\n");
		return(-1);
	}
#endif /* DM_OGL */

	/*
	 *  Take inventory of the hardware.
	 *  See "types for class graphics" in /usr/include/sys/invent.h
	 */
	while( (inv = getinvent()) != (inventory_t *)0 )  {
		if( inv->class != INV_GRAPHICS )  continue;
		switch( inv->type )  {
		default:
#if 0
			rt_log("mged/dm-4d.c: getinvent() INV_GRAPHICS type=%d not recognized, you need to modify the source code\n",
			    inv->type);
#endif
			/* Since we recognize all the old devices, be
			 * optimistic and assume that new devices are plush.
			 * Or at least that GL can simulate everything adequately.
			 */
			ir_is_gt = 1;
			ir_has_zbuf = 1;
			ir_has_rgb = 1;
			ir_has_doublebuffer = 1;
			break;
		case INV_GRODEV:			 /* 4D/60 machines */
			ir_has_doublebuffer = 1;
			if( inv->state & INV_GR1ZBUF24 )
				ir_has_zbuf = 1;
			break;
		case INV_VGX:
		case INV_VGXT:			/* VGX Turbo and SkyWriter */
		case INV_GMDEV:			/* GT graphics */
		case INV_CG2:
			ir_is_gt = 1;
			ir_has_zbuf = 1;
			ir_has_rgb = 1;
			ir_has_doublebuffer = 1;
			break;
		case INV_GR1BP:
			ir_has_rgb = 1;
			break;
		case INV_GR1ZBUFFER:
			ir_has_zbuf = 1;
			break;
		case INV_GR1BOARD:	/* Persoanl Iris */
			if ( inv->state & INV_GR1RE2 )
				ir_is_gt = 1;
			if(inv->state & INV_GR1ZBUF24 )
				ir_has_zbuf = 1;
			if(inv->state & INV_GR1BIT24 )
				ir_has_rgb = 1;
			ir_has_doublebuffer = 1;
			break;
#if defined(INV_LIGHT)
		case INV_LIGHT:		/* Entry Level Indigo */
			ir_is_gt = 0;
			ir_has_zbuf = 1;
			ir_has_doublebuffer = 0;
			ir_has_rgb = 1;
			break;
#endif

#if defined(INV_GR2)
		case INV_GR2:		/* Elan EXPRESS Graphics */
			/* if(inv->state & INV_GR2_ELAN) */
			/* Just let GL simulate it */
			ir_has_rgb = 1;
			ir_has_doublebuffer = 1;
			ir_has_zbuf = 1;
			ir_is_gt = 1;
			/* if(inv->state & INV_GR2_EXTREME) */
			break;
#endif
#if defined(INV_NEWPORT)
		case INV_NEWPORT:
			/* if(inv->state & INV_NEWPORT_XL) */
			/* Just let GL simulate it */
			ir_has_rgb = 1;
			ir_has_doublebuffer = 1;
			ir_has_zbuf = 1;
			ir_is_gt = 1;
#			if 0
				if(inv->state & INV_NEWPORT_24)
					ir_has_rgb = 1;
#			endif
			break;
#endif
		}
	}
	endinvent();		/* frees internal inventory memory */
#if 0
	rt_log("4D: gt=%d, zbuf=%d, rgb=%d\n", ir_is_gt, ir_has_zbuf, ir_has_rgb);
#endif

	/* Start out with the usual window */
	foreground();
#if 1
	if (mged_variables.sgi_win_size > 0)
		win_size = mged_variables.sgi_win_size;

	if (mged_variables.sgi_win_origin[0] != 0)
		win_o_x = mged_variables.sgi_win_origin[0];

	if (mged_variables.sgi_win_origin[1] != 0)
		win_o_y = mged_variables.sgi_win_origin[1];

	prefposition( win_o_x, win_o_x+win_size, win_o_y, win_o_y+win_size);
#else
	prefposition( 376, 1276, 12, 912 );		/* Old, larger size */
	prefposition( 376, 376+900, 112, 112+900 );	/* new, smaller size */
#endif
	if( (gr_id = winopen( "BRL MGED" )) == -1 )  {
		rt_log( "No more graphics ports available.\n" );
		return	-1;
	}
	keepaspect(1,1);	/* enforce 1:1 aspect ratio */
	winconstraints();	/* remove constraints on the window size */

	ir_oldmonitor = getmonitor();
	if( mged_variables.eye_sep_dist )  {
		if( sgi_has_stereo() )  {
			setmonitor(STR_RECT);
			stereo_is_on = 1;
		} else {
			rt_log("NOTICE: This SGI does not have stereo display capability\n");
			stereo_is_on = 0;
		}
	}

	/*
	 *  If monitor is in special mode, close window and re-open.
	 *  winconstraints() does not work, and getmonitor() can't
	 *  be called before a window is open.
	 */
	switch( getmonitor() )  {
	case HZ30:
	case HZ30_SG:
		/* Dunn camera, etc. */
		/* Use already established prefposition */
		break;
	case STR_RECT:
		/* Hi-res monitor in stereo mode, take over whole screen */
		winclose(gr_id);
		noborder();
		foreground();
#if defined(__sgi) && defined(__mips)
		/* Deal with Irix 4.0 bug:  (+2,+0) offset due to border */
		prefposition( 0-2, XMAXSCREEN-2, 0, YMAXSCREEN );
#else
		prefposition( 0, XMAXSCREEN, 0, YMAXSCREEN );
#endif
		if( (gr_id = winopen( "BRL MGED" )) == -1 )  {
			rt_log( "No more graphics ports available.\n" );
			return	-1;
		}
		break;
	default:
	case HZ60:
		/* Regular hi-res monitor */
		/* Use already established prefposition */
		break;
	case NTSC:
		/* Television */
		winclose(gr_id);
		prefposition( 0, XMAX170, 0, YMAX170 );
		foreground();
		if( (gr_id = winopen( "BRL MGED" )) == -1 )  {
			rt_log( "No more graphics ports available.\n" );
			return	-1;
		}
		break;
	case PAL:
		/* Television */
		winclose(gr_id);
		prefposition( 0, XMAXPAL, 0, YMAXPAL );
		foreground();
		if( (gr_id = winopen( "BRL MGED" )) == -1 )  {
			rt_log( "No more graphics ports available.\n" );
			return	-1;
		}
		break;
	}

	/*
	 *  Configure the operating mode of the pixels in this window.
	 *  Do not output graphics, clear screen, etc, until *after*
	 *  the call to gconfig().
	 */
	if( ir_has_rgb )  {
		RGBmode();
	} else {
		/* one indexed color map of 4096 entries */
		onemap();
	}
	if ( ir_has_doublebuffer)
		doublebuffer();

	gconfig();

	/*
	 * Establish GL library operating modes
	 */
	/* Don't draw polygon edges */
	glcompat( GLC_OLDPOLYGON, 0 );

	/* Z-range mapping */
	/* Z range from getgdesc(GD_ZMIN)
	 * to getgdesc(GD_ZMAX).
	 * Hardware specific.
	 */
	glcompat( GLC_ZRANGEMAP, 0 );
	/* Take off a smidgeon for wraparound, as suggested by SGI manual */
	min_scr_z = getgdesc(GD_ZMIN)+15;
	max_scr_z = getgdesc(GD_ZMAX)-15;

	Ir_configure_window_shape();

	/* Enable qdev() input from various devices */
	qdevice(LEFTMOUSE);
	qdevice(MIDDLEMOUSE);
	qdevice(RIGHTMOUSE);
	tie(LEFTMOUSE, MOUSEX, MOUSEY);
	tie(MIDDLEMOUSE, MOUSEX, MOUSEY);
	tie(RIGHTMOUSE, MOUSEX, MOUSEY);

#if IR_KNOBS
	/*
	 *  Turn on the dials and initialize them for -2048 to 2047
	 *  range with a dead spot at zero (Iris knobs are 1024 units
	 *  per rotation).
	 */
	for(i = DIAL0; i < DIAL8; i++)
		setvaluator(i, 0, -2048-NOISE, 2047+NOISE);
	for(i = DIAL0; i < DIAL8; i++)
		qdevice(i);
#endif
#if IR_BUTTONS
	/*
	 *  Enable all the buttons in the button table.
	 */
	for(i = 0; i < IR_BUTTONS; i++)
		qdevice(i+SWBASE);
	/*
	 *  For all possible button presses, build a table
	 *  of MGED function to SGI button/light mappings.
	 */
	for( i=0; i < IR_BUTTONS; i++ )  {
		register int j;
		if( (j = bmap[i]) != 0 )
			invbmap[j] = i;
	}
# if 0
	ir_dbtext(ir_title);
# else
	dbtext("");
# endif
#endif

	qdevice(F1KEY);	/* pf1 key for depthcue switching */
	qdevice(F2KEY);	/* pf2 for Z clipping */
	qdevice(F3KEY);	/* pf3 for perspective */
	qdevice(F4KEY);	/* pf4 for Z buffering */
	qdevice(F5KEY);	/* pf5 for lighting */
	qdevice(F6KEY);	/* pf6 for changing perspective */
	qdevice(F7KEY);	/* pf7 for no faceplate */
	qdevice(F12KEY);/* pf12 to zero knobs */
	while( getbutton(LEFTMOUSE)||getbutton(MIDDLEMOUSE)||getbutton(RIGHTMOUSE) )  {
		rt_log("IRIS_open:  mouse button stuck\n");
		sleep(1);
	}

	/* Line style 0 is solid.  Program line style 1 as dot-dashed */
	deflinestyle( 1, 0xCF33 );
	setlinestyle( 0 );

	ir_fd = qgetfd();

	Tk_CreateFileHandler(ir_fd, 1, Ircheckevents, (void *)NULL);
	return(0);
}

/*
 *  			I R _ C L O S E
 *  
 *  Gracefully release the display.  Well, mostly gracefully -- see
 *  the comments in the open routine.
 */
void
Ir_close()
{
	if(cueing_on) depthcue(0);

	lampoff( 0xf );

	/* avoids error messages when reattaching */
	mmode(MVIEWING);	
	lmbind(LIGHT2,0);
	lmbind(LIGHT3,0);
	lmbind(LIGHT4,0);
	lmbind(LIGHT5,0);


	frontbuffer(1);
	ir_clear_to_black();
	frontbuffer(0);

	if( getmonitor() != ir_oldmonitor )
		setmonitor(ir_oldmonitor);

	winclose(gr_id);

	return;
}

/*
 *			I R _ P R O L O G
 *
 * Define the world, and include in it instances of all the
 * important things.  Most important of all is the object "faceplate",
 * which is built between dmr_normal() and dmr_epilog()
 * by dmr_puts and dmr_2d_line calls from adcursor() and dotitles().
 */
void
Ir_prolog()
{
	if (ir_debug)
		rt_log( "Ir_prolog\n");
#if 0
	ortho2( -1.0,1.0, -1.0,1.0);	/* L R Bot Top */
#else
	ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );
#endif

	if( dmaflag && !ir_has_doublebuffer )
	{
		ir_clear_to_black();
		return;
	}
	linewidth(ir_linewidth);
}

/*
 *			I R _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
void
Ir_normal()
{
	if (ir_debug)
		rt_log( "Ir_normal\n");

	if( ir_has_rgb )  {
		RGBcolor( (short)0, (short)0, (short)0 );
	} else {
		color(BLACK);
	}

#if 0
	ortho2( -1.0,1.0, -1.0,1.0);	/* L R Bot Top */
#else
	ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );
#endif
}

/*
 *			I R _ E P I L O G
 */
void
Ir_epilog()
{
	if (ir_debug)
		rt_log( "Ir_epilog\n");
	/*
	 * A Point, in the Center of the Screen.
	 * This is drawn last, to always come out on top.
	 */
	Ir_2d_line( 0, 0, 0, 0, 0 );
	/* End of faceplate */

	if(ir_has_doublebuffer )
	{
		swapbuffers();
		/* give Graphics pipe time to work */
		ir_clear_to_black();
	}
}

/*
 *  			I R _ N E W R O T
 *
 *  Load a new rotation matrix.  This will be followed by
 *  many calls to Ir_object().
 *
 *  IMPORTANT COORDINATE SYSTEM NOTE:
 *
 *  MGED uses a right handed coordinate system where +Z points OUT of
 *  the screen.  The Silicon Graphics uses a left handed coordinate
 *  system where +Z points INTO the screen.
 *  This difference in convention is handled here.
 *  The conversion is accomplished by concatenating a matrix multiply
 *  by
 *            (  1    0    0   0  )
 *            (  0    1    0   0  )
 *            (  0    0   -1   0  )
 *            (  0    0    0   1  )
 *
 *  However, this is actually implemented by straight-line code which
 *  flips the sign on the entire third row.
 *
 *  Note that through BRL-CAD Release 3.7 this was handled by flipping
 *  the direction of the shade ramps.  Now, with the Z-buffer being used,
 *  the correct solution is important.
 */
void
Ir_newrot(mat, which_eye)
mat_t	mat;
{
	register fastf_t *mptr;
	Matrix	gtmat;
	mat_t	newm;
	int	i;

	if (ir_debug)
		rt_log( "Ir_newrot()\n");

	switch(which_eye)  {
	case 0:
		/* Non-stereo */
		break;
	case 1:
		/* R eye */
		viewport(0, XMAXSCREEN, 0, YSTEREO);
		Ir_puts( "R", 2020, 0, 0, DM_RED );
		break;
	case 2:
		/* L eye */
		viewport(0, XMAXSCREEN, 0+YOFFSET_LEFT, YSTEREO+YOFFSET_LEFT);
		break;
	}

	if( ! zclipping_on ) {
		mat_t	nozclip;

		mat_idn( nozclip );
		nozclip[10] = 1.0e-20;
		mat_mul( newm, nozclip, mat );
		mptr = newm;
	} else {
		mptr = mat;
	}
#if 0
	for(i= 0; i < 4; i++) {
		gtmat[0][i] = *(mptr++);
		gtmat[1][i] = *(mptr++);
		gtmat[2][i] = *(mptr++);
		gtmat[3][i] = *(mptr++);
	}
#else
	gtmat[0][0] = *(mptr++) * aspect_corr[0];
	gtmat[1][0] = *(mptr++) * aspect_corr[0];
	gtmat[2][0] = *(mptr++) * aspect_corr[0];
	gtmat[3][0] = *(mptr++) * aspect_corr[0];

	gtmat[0][1] = *(mptr++) * aspect_corr[5];
	gtmat[1][1] = *(mptr++) * aspect_corr[5];
	gtmat[2][1] = *(mptr++) * aspect_corr[5];
	gtmat[3][1] = *(mptr++) * aspect_corr[5];

	gtmat[0][2] = *(mptr++);
	gtmat[1][2] = *(mptr++);
	gtmat[2][2] = *(mptr++);
	gtmat[3][2] = *(mptr++);

	gtmat[0][3] = *(mptr++);
	gtmat[1][3] = *(mptr++);
	gtmat[2][3] = *(mptr++);
	gtmat[3][3] = *(mptr++);
#endif

	/*
	 *  Convert between MGED's right handed coordinate system
	 *  where +Z comes out of the screen to the Silicon Graphics's
	 *  left handed coordinate system, where +Z goes INTO the screen.
	 */
	gtmat[0][2] = -gtmat[0][2];
	gtmat[1][2] = -gtmat[1][2];
	gtmat[2][2] = -gtmat[2][2];
	gtmat[3][2] = -gtmat[3][2];

	loadmatrix( gtmat );
}

static float material_objdef[] = {
	ALPHA,		1.0,	
	AMBIENT,	0.2, 0.2, 0.2,	/* 0.4 in rt */
	DIFFUSE,	0.6, 0.6, 0.6,
	SPECULAR,	0.2, 0.2, 0.2,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	10.0,
	LMNULL   };

/*
 *  			I R _ O B J E C T
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.  Mat is model2view.
 *
 *  Returns -
 *	 0 if object could be drawn
 *	!0 if object was omitted.
 */
int
Ir_object( sp, m, ratio, white )
register struct solid *sp;
fastf_t		*m;
double		ratio;
int		white;
{
	register struct rt_vlist	*vp;
	register int nvec;
	register float	*gtvec;
	char	gtbuf[16+3*sizeof(double)];
	int first;
	int i,j;

	if (ir_debug)
		rt_log( "Ir_Object()\n");

	/*
	 *  It is claimed that the "dancing vector disease" of the
	 *  4D GT processors is due to the array being passed to v3f()
	 *  not being quad-word aligned (16-byte boundary).
	 *  This hack ensures that the buffer has this alignment.
	 *  Note that this requires gtbuf to be 16 bytes longer than needed.
	 */
	gtvec = (float *)((((int)gtbuf)+15) & (~0xF));

	/*
	 * IMPORTANT DEPTHCUEING NOTE
	 *
	 * Also note that the depthcueing shaderange() routine wanders
	 * outside it's allotted range due to roundoff errors.  A buffer
	 * entry is kept on each end of the shading curves, and the
	 * highlight mode uses the *next* to the brightest entry --
	 * otherwise it can (and does) fall off the shading ramp.
	 */
	if (sp->s_soldash)
		setlinestyle( 1 );		/* set dot-dash */

	if( ir_has_rgb )  {
		register short	r, g, b;
		if( white )  {
			r = g = b = 230;
		} else {
			r = (short)sp->s_color[0];
			g = (short)sp->s_color[1];
			b = (short)sp->s_color[2];
		}
		if(cueing_on)  {
			lRGBrange(
			    r/10, g/10, b/10,
			    r, g, b,
			    min_scr_z, max_scr_z );
		} else
		if(lighting_on && ir_is_gt)
		{
			/* Ambient = .2, Diffuse = .6, Specular = .2 */

			/* Ambient */
			material_objdef[3] = 	.2 * ( r / 255.0);
			material_objdef[4] = 	.2 * ( g / 255.0);
			material_objdef[5] = 	.2 * ( b / 255.0);

			/* diffuse */
			material_objdef[7] = 	.6 * ( r / 255.0);
			material_objdef[8] = 	.6 * ( g / 255.0);
			material_objdef[9] = 	.6 * ( b / 255.0);

			/* Specular */
			material_objdef[11] = 	.2 * ( r / 255.0);
			material_objdef[12] = 	.2 * ( g / 255.0);
			material_objdef[13] = 	.2 * ( b / 255.0);

			lmdef(DEFMATERIAL, 21, 0, material_objdef);
			lmbind(MATERIAL, 21);

		} else

			RGBcolor( r, g, b );
	} else {
		if( white ) {
			ovec = nvec = MAP_ENTRY(DM_WHITE);
			/* Use the *next* to the brightest white entry */
			if(cueing_on)  {
				lshaderange(nvec+1, nvec+1,
				    min_scr_z, max_scr_z );
			}
			color( nvec );
		} else {
			if( (nvec = MAP_ENTRY( sp->s_dmindex )) != ovec) {
				/* Use only the middle 14 to allow for roundoff...
				 * Pity the poor fool who has defined a black object.
				 * The code will use the "reserved" color map entries
				 * to display it when in depthcued mode.
				 */
				if(cueing_on)  {
					lshaderange(nvec+1, nvec+14,
					    min_scr_z, max_scr_z );
				}
				color( nvec );
				ovec = nvec;
			}
		}
	}

	/* Viewing region is from -1.0 to +1.0 */
	first = 1;
	for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			switch( *cmd )  {
			case RT_VLIST_LINE_MOVE:
				/* Move, start line */
				if( first == 0 )
					endline();
				first = 0;
				bgnline();
				v3d( *pt );
				break;
			case RT_VLIST_LINE_DRAW:
				/* Draw line */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_START:
				/* Start poly marker & normal */
				if( first == 0 )
					endline();
				/* concave(TRUE); */
				bgnpolygon();
				/* Set surface normal (vl_pnt points outward) */
				VMOVE( gtvec, *pt );
				n3f(gtvec);
				break;
			case RT_VLIST_POLY_MOVE:
				/* Polygon Move */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_DRAW:
				/* Polygon Draw */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_END:
				/* Draw, End Polygon */
				v3d( *pt );
				endpolygon();
				first = 1;
				break;
			case RT_VLIST_POLY_VERTNORM:
				/* Set per-vertex normal.  Given before vert. */
				VMOVE( gtvec, *pt );
				n3f(gtvec);
				break;
			}
		}
	}
	if( first == 0 ) endline();

	if (sp->s_soldash)
		setlinestyle(0);		/* restore solid lines */

	return(1);	/* OK */
}

/*
 *			I R _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 * Last routine called in refresh cycle.
 */
void
Ir_update()
{
	if (ir_debug)
		rt_log( "Ir_update()\n");
	if( !dmaflag )
		return;
}

/*
 *			I R _ P U T S
 *
 * Output a string.
 * The starting position of the beam is as specified.
 */
void
Ir_puts( str, x, y, size, colour )
register char *str;
int x,y,size, colour;
{
	if (ir_debug)
		rt_log( "Ir_puts()\n");
	cmov2( GED2IRIS(x), GED2IRIS(y));
	if( ir_has_rgb )  {
		RGBcolor( (short)ir_rgbtab[colour].r,
		    (short)ir_rgbtab[colour].g,
		    (short)ir_rgbtab[colour].b );
	} else {
		color( MAP_ENTRY(colour) );
	}
	charstr( str );
}

/*
 *			I R _ 2 D _ L I N E
 *
 */
void
Ir_2d_line( x1, y1, x2, y2, dashed )
int x1, y1;
int x2, y2;
int dashed;
{
	register int nvec;

	if (ir_debug)
		rt_log( "Ir_2d_line()\n");
	if( ir_has_rgb )  {
		/* Yellow */
		if(cueing_on)  {
			lRGBrange(
			    255, 255, 0,
			    255, 255, 0,
			    min_scr_z, max_scr_z );
		}
		RGBcolor( (short)255, (short)255, (short) 0 );
	} else {
		if((nvec = MAP_ENTRY(DM_YELLOW)) != ovec) {
			if(cueing_on) lshaderange(nvec, nvec,
			    min_scr_z, max_scr_z );
			color( nvec );
			ovec = nvec;
		}
	}

	if( dashed )
		setlinestyle(1);	/* into dot-dash */

	move2( GED2IRIS(x1), GED2IRIS(y1));
	draw2( GED2IRIS(x2), GED2IRIS(y2));

	if( dashed )
		setlinestyle(0);	/* restore to solid */
}

/*
 *			I R _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream, or a device event has
 * occured, unless "noblock" is set.
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 */
void
Ir_input( input, noblock )
fd_set		*input;
int		noblock;
{
	static int cnt;
	register int i;
	struct timeval	tv;
	fd_set		files;
	int		width;

	if (ir_debug)
		rt_log( "Ir_input()\n");
	if( (width = sysconf(_SC_OPEN_MAX)) <= 0 )
		width = 32;
	files = *input;		/* save, for restore on each loop */
	FD_SET( ir_fd, &files );

	/*
	 * Check for input on the keyboard or on the polled registers.
	 *
	 * Suspend execution until either
	 *  1)  User types a full line
	 *  2)  A change in peripheral status occurs
	 *  3)  The timelimit on SELECT has expired
	 *
	 * If a RATE operation is in progress (zoom, rotate, slew)
	 * in which the peripherals (rate setting) may not be changed,
	 * but we still have to update the display,
	 * do not suspend execution.
	 */
	do  {
		cnt = 0;
		i = qtest();
		if( i != 0 )  {
			FD_ZERO( input );
			FD_SET( ir_fd, input );
			break;		/* There is device input */
		}
		*input = files;

		tv.tv_sec = 0;
		if( noblock )  {
			tv.tv_usec = 0;
		}  else {
			/* 1/20th second */
			tv.tv_usec = 50000;
		}
		cnt = select( width, input, (fd_set *)0,  (fd_set *)0, &tv );
		if( cnt < 0 )  {
			perror("dm-4d.c/select");
			break;
		}
		if( noblock )  break;
		for( i=0; i<width; i++ )  {
			if( FD_ISSET(i, input) )  goto input_waiting;
		}
	} while( noblock == 0 );

input_waiting:
	/*
	 * Set device interface structure for GED to "rest" state.
	 * First, process any messages that came in.
	 */

	if( FD_ISSET( ir_fd, input ) )
		Ircheckevents();

	return;
}
/*
 *  C H E C K E V E N T S
 *
 *  Look at events to check for button, dial, and mouse movement.
 */
void
Ircheckevents()  {
#define NVAL 48
	short values[NVAL];
	register short *valp;
	register int ret;
	register int n;
	static	knobs[8];	/*  Save values of dials  */
	static	button0  = 0;	/*  State of button 0 */
	static char	pending_button = 'M';
	static int	pending_val = 0;
	static	pending_x = 0;
	static	pending_y = 0;

	/*
	if (qtest() == 0)
	    return;
 */
	n = blkqread( values, NVAL );	/* n is # of shorts returned */
	if( ir_debug ) rt_log("blkqread gave %d\n", n);
	for( valp = values; n > 0; n -= 2, valp += 2 )  {

		ret = *valp;
		if( ir_debug ) rt_log("qread ret=%d, val=%d\n", ret, valp[1]);
#if IR_BUTTONS
		if((ret >= SWBASE && ret < SWBASE+IR_BUTTONS)
		    || (ret >= F1KEY && ret <= F12KEY)
		    ) {
			register int	i;

			/*
			 *  Switch 0 is help key.
			 *  Holding down key 0 and pushing another
			 *  button or turning the knob will display
			 *  what it is in the button box displya.
			 */
			if(ret == SW_HELP_KEY)  {
				button0 = valp[1];
#if IR_KNOBS
				/*
				 *  Save and restore dial settings
				 *  so that when the user twists them
				 *  while holding down button 0 he
				 *  really isn't changing them.
				 */
				for(i = 0; i < 8; i++)
					if(button0)
						knobs[i] =
						    getvaluator(DIAL0+i);
					else setvaluator(DIAL0+i,knobs[i],
					    -2048-NOISE, 2047+NOISE);
#endif
				if(button0)
					ir_dbtext("Help Key");
# if 0
else
	ir_dbtext(ir_title);
# endif
continue;

			}

#if IR_KNOBS
			/*
			 *  If button 1 is pressed, reset run away knobs.
			 */
			if(ret == SW_ZERO_KEY || ret == F12KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					ir_dbtext("ZeroKnob");
					continue;
				}
#if IR_KNOBS
				/* zap the knobs */
				for(i = 0; i < 8; i++)  {
					setvaluator(DIAL0+i, 0,
					    -2048-NOISE, 2047+NOISE);
					knobs[i] = 0;
				}
#endif
				rt_vls_printf(&dm_values.dv_string,
				    "knob zero\n");
				continue;
			}
#endif
			/*
			 *  If PFkey 1 is pressed, toggle depthcueing.
			 */
			if(ret == F1KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					ir_dbtext("Depthcue");
					continue;
				}
				/* toggle depthcueing and remake colormap */
				rt_vls_printf(&dm_values.dv_string,
				    "dm set depthcue !\n");
				continue;
			} else if(ret == F2KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					ir_dbtext("Z clip");
					continue;
				}
				/* toggle zclipping */
				rt_vls_printf(&dm_values.dv_string,
				    "dm set zclip !\n");
				continue;
			} else if(ret == F3KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					ir_dbtext("Perspect");
					continue;
				}
				perspective_mode = 1-perspective_mode;
				rt_vls_printf( &dm_values.dv_string,
				    "set perspective %d\n",
				    perspective_mode ?
				    perspective_table[perspective_angle] :
				    -1 );
				dmaflag = 1;
				continue;
			} else if(ret == F4KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					ir_dbtext("Zbuffing");
					continue;
				}
				/* toggle zbuffer status */
				rt_vls_printf(&dm_values.dv_string,
				    "dm set zbuffer !\n");
				continue;
			} else if(ret == F5KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					ir_dbtext("Lighting");
					continue;
				}
				/* toggle status */
				rt_vls_printf(&dm_values.dv_string,
				    "dm set lighting !\n");
				continue;
			} else if (ret == F6KEY) {
				if (!valp[1]) continue; /* Ignore release */
				/* Help mode */
				if (button0) {
					ir_dbtext("P-Angle");
					continue;
				}
				/* toggle perspective matrix */
				if (--perspective_angle < 0) perspective_angle = 3;
				if(perspective_mode) rt_vls_printf( &dm_values.dv_string,
				    "set perspective %d\n",
				    perspective_table[perspective_angle] );
				dmaflag = 1;
				continue;
			} else if (ret == F7KEY) {
				if (!valp[1]) continue; /* Ignore release */
				/* Help mode */
				if (button0) {
					ir_dbtext("NoFace");
					continue;
				}
				/* Toggle faceplate on/off */
				no_faceplate = !no_faceplate;
				rt_vls_strcat( &dm_values.dv_string,
				    no_faceplate ?
				    "set faceplate 0\n" :
				    "set faceplate 1\n" );
				Ir_configure_window_shape();
				dmaflag = 1;
				continue;
			}
			/*
			 * If button being depressed (as opposed to
			 * being released) either display the cute
			 * message or process the button depending
			 * on whether button0 is also being held down.
			 */
			i = bmap[ret - SWBASE];



			if(!valp[1]) continue;
			if(button0) {
				ir_dbtext(label_button(i));
			} else {
				/* An actual button press */
#				if 0
				/* old way -- an illegal upcall */
				button(i);
#				else
				/* better way -- queue a string command */
				rt_vls_strcat( &dm_values.dv_string,
				    "press " );
				rt_vls_strcat( &dm_values.dv_string,
				    label_button(i) );
				rt_vls_strcat( &dm_values.dv_string,
				    "\n" );
#				endif
			}
			continue;
		}
#endif
#if IR_KNOBS
		/*  KNOBS, uh...er...DIALS  */
		/*	6	7
		 *	4	5
		 *	2	3
		 *	0	1
		 */
		if(ret >= DIAL0 && ret <= DIAL8)  {
			int	setting;
			/*  Help MODE */
			if(button0)  {
				ir_dbtext(
				    (adcflag ? kn1_knobs:kn2_knobs)[ret-DIAL0]);
				continue;
			}
			/* Make a dead zone around 0 */
			setting = irlimit(valp[1]);
			switch(ret)  {
			case DIAL0:
				if(adcflag) {
					rt_vls_printf( &dm_values.dv_string, "knob ang1 %d\n",
							setting );
				}
				break;
			case DIAL1:
				rt_vls_printf( &dm_values.dv_string , "knob S %f\n",
							setting/2048.0 );
				break;
			case DIAL2:
				if(adcflag)
					rt_vls_printf( &dm_values.dv_string , "knob ang2 %d\n",
							setting );
				else
					rt_vls_printf( &dm_values.dv_string , "knob z %f\n",
							setting/2048.0 );
				break;
			case DIAL3:
				if(adcflag)
					rt_vls_printf( &dm_values.dv_string , "knob distadc %d\n",
							setting );
				else
					rt_vls_printf( &dm_values.dv_string , "knob Z %f\n",
							setting/2048.0 );
				break;
			case DIAL4:
				if(adcflag)
					rt_vls_printf( &dm_values.dv_string , "knob yadc %d\n",
							setting );
				else
					rt_vls_printf( &dm_values.dv_string , "knob y %f\n",
							setting/2048.0 );
				break;
			case DIAL5:
				rt_vls_printf( &dm_values.dv_string , "knob Y %f\n",
							setting/2048.0 );
				break;
			case DIAL6:
				if(adcflag)
					rt_vls_printf( &dm_values.dv_string , "knob xadc %d\n",
							setting );
				else
					rt_vls_printf( &dm_values.dv_string , "knob x %f\n",
							setting/2048.0 );
				break;
			case DIAL7:
				rt_vls_printf( &dm_values.dv_string , "knob X %f\n",
							setting/2048.0 );
				break;
			}
			continue;
		}
#endif
		switch( ret )  {
		case LEFTMOUSE:
			pending_button = 'L';
			pending_val = (int)valp[1] ? 1 : 0;
			break;
		case RIGHTMOUSE:
			pending_button = 'R';
			pending_val = (int)valp[1] ? 1 : 0;
			break;
		case MIDDLEMOUSE:
			/* Will be followed by MOUSEX and MOUSEY hits */
			pending_button = 'M';
			pending_val = (int)valp[1] ? 1 : 0;
			/* Don't signal DV_PICK until MOUSEY event */
			break;
		case MOUSEX:
			pending_x = irisX2ged( (int)valp[1] );
			if(ir_debug>1)printf("mousex %d\n", pending_x);
			break;
		case MOUSEY:
			pending_y = irisY2ged( (int)valp[1] );
			if(ir_debug>1)printf("mousey %d\n", pending_y);
			/*
			 *  Thanks to the tie() call, when a MIDDLEMOUSE
			 *  event is signalled, it will be (eventually)
			 *  followed by a MOUSEX and MOUSEY event.
			 *  The MOUSEY event may not be in the same
			 *  blkqread() buffer, owing to time delays in
			 *  the outputting of the tie()'ed events.
			 *  So, don't report the mouse event on MIDDLEMOUSE;
			 *  instead, the flag pending_val flag is set,
			 *  and the mouse event is signaled here, which
			 *  may need multiple trips through this subroutine.
			 *
			 *  MOUSEY may be queued all by itself to support
			 *  illuminate mode;  in those cases, pending_val
			 *  will be zero already, and we just parrot the last
			 *  X value.
			 */
			rt_vls_printf( &dm_values.dv_string, "%c %d %d %d\n",
			    pending_button,
			    pending_val,
			    pending_x, pending_y);
			pending_button = 'M';
			pending_val = 0;
			break;
		case REDRAW:
			/* Window may have moved */
			Ir_configure_window_shape();
			dmaflag = 1;
			if( ir_has_doublebuffer) /* to fix back buffer */
				refresh();
			dmaflag = 1;
			break;
		case INPUTCHANGE:
			/* Means we got or lost the keyboard.  Ignore */
			break;
		case WMREPLY:
			/* This guy speaks, but has nothing to say */
			break;
		case 0:
			/* These show up as a consequence of using qgetfd().  Most regrettable.  Ignore. */
			break;
		default:
			rt_log("IRIS device %d gave %d?\n", ret, valp[1]);
			break;
		}
	}
}

/* 
 *			I R _ L I G H T
 *
 * This function must keep both the light hardware, and the software
 * copy of the lights up to date.  Note that requests for light changes
 * may not actually cause the lights to be changed, depending on
 * whether the buttons are being used for "view" or "edit" functions
 * (although this is not done in the present code).
 */
void
Ir_light( cmd, func )
int cmd;
int func;			/* BE_ or BV_ function */
{
	register unsigned short bit;
#ifdef IR_BUTTONS
	/* Check for BE_ function not assigned to a button */
	if( (bit = invbmap[func]) == 0 && cmd != LIGHT_RESET )
		return;
	switch( cmd )  {
	case LIGHT_RESET:
		lights = 0;
		break;
	case LIGHT_ON:
		lights |= 1<<bit;
		break;
	case LIGHT_OFF:
		lights &= ~(1<<bit);
		break;
	}

	/* Update the lights box. */
#if !defined(__sgi)	/* This bombs, on early Irix 4.0 releases */
	setdblights( lights );
#endif
#endif
}

/*
 *			I R _ C V T V E C S
 *
 */
unsigned
Ir_cvtvecs( sp )
register struct solid *sp;
{
	return( 0 );	/* No "displaylist" consumed */
}

/*
 * Loads displaylist from storage[]
 */
unsigned
Ir_load( addr, count )
unsigned addr, count;
{
	return( 0 );		/* FLAG:  error */
}

void
Ir_statechange( a, b )
{
	if( ir_debug ) rt_log("statechange %d %d\n", a, b );
	/*
	 *  Based upon new state, possibly do extra stuff,
	 *  including enabling continuous tablet tracking,
	 *  object highlighting
	 */
	switch( b )  {
	case ST_VIEW:
		unqdevice( MOUSEY );	/* constant tracking OFF */
		/* This should not affect the tie()'d MOUSEY events */
		break;

	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
		/*  Have all changes of MOUSEY generate an event */
		qdevice( MOUSEY );	/* constant tracking ON */
		break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	case ST_S_VPICK:
		unqdevice( MOUSEY );	/* constant tracking OFF */
		break;
	default:
		rt_log("Ir_statechange: unknown state %s\n", state_str[b]);
		break;
	}
	Ir_viewchange( DM_CHGV_REDO, SOLID_NULL );
}

void
Ir_viewchange( cmd, sp )
register int cmd;
register struct solid *sp;
{
	if( ir_debug ) rt_log("viewchange( %d, x%x )\n", cmd, sp );
	switch( cmd )  {
	case DM_CHGV_ADD:
		break;
	case DM_CHGV_REDO:
		break;
	case DM_CHGV_DEL:
		break;
	case DM_CHGV_REPL:
		return;
	case DM_CHGV_ILLUM:
		break;
	}
}

void
Ir_debug(lvl)
{
	ir_debug = lvl;
}

void
Ir_window(w)
int w[];
{
}


/*
 *  			I R _ C O L O R C H A N G E
 *  
 *  Go through the solid table, and allocate color map slots.
 *	8 bit system gives 4 or 8,
 *	24 bit system gives 12 or 24.
 */
void
Ir_colorchange()
{
	register int i;
	register int nramp;

	if( ir_debug )  rt_log("colorchange\n");

	/* Program the builtin colors */
	ir_rgbtab[0].r=0; 
	ir_rgbtab[0].g=0; 
	ir_rgbtab[0].b=0;/* Black */
	ir_rgbtab[1].r=255; 
	ir_rgbtab[1].g=0; 
	ir_rgbtab[1].b=0;/* Red */
	ir_rgbtab[2].r=0; 
	ir_rgbtab[2].g=0; 
	ir_rgbtab[2].b=255;/* Blue */
	ir_rgbtab[3].r=255; 
	ir_rgbtab[3].g=255;
	ir_rgbtab[3].b=0;/*Yellow */
	ir_rgbtab[4].r = ir_rgbtab[4].g = ir_rgbtab[4].b = 255; /* White */
	slotsused = 5;

	if( ir_has_rgb )  {
		if(cueing_on) {
			depthcue(1);
		} else {
			depthcue(0);
		}

		RGBcolor( (short)255, (short)255, (short)255 );

		/* apply region-id based colors to the solid table */
		color_soltab();

		return;
	}

	ir_nslots = getplanes();
	if(cueing_on && (ir_nslots < 7)) {
		rt_log("Too few bitplanes: depthcueing disabled\n");
		cueing_on = 0;
	}
	ir_nslots = 1<<ir_nslots;
	if( ir_nslots > NSLOTS )  ir_nslots = NSLOTS;
	if(cueing_on) {
		/* peel off reserved ones */
		ir_nslots = (ir_nslots - CMAP_BASE) / CMAP_RAMP_WIDTH;
		depthcue(1);
	} else {
		ir_nslots -= CMAP_BASE;	/* peel off the reserved entries */
		depthcue(0);
	}

	ovec = -1;	/* Invalidate the old colormap entry */

	/* apply region-id based colors to the solid table */
	color_soltab();

	/* Map the colors in the solid table to colormap indices */
	ir_colorit();

	for( i=0; i < slotsused; i++ )  {
		gen_color( i, ir_rgbtab[i].r, ir_rgbtab[i].g, ir_rgbtab[i].b);
	}

	color(WHITE);	/* undefinied after gconfig() */
}

void
ir_colorit()
{
	register struct solid	*sp;
	register struct rgbtab *rgb;
	register int i;
	register int r,g,b;

	if( ir_has_rgb )  return;

	FOR_ALL_SOLIDS( sp )  {
		r = sp->s_color[0];
		g = sp->s_color[1];
		b = sp->s_color[2];
		if( (r == 255 && g == 255 && b == 255) ||
		    (r == 0 && g == 0 && b == 0) )  {
			sp->s_dmindex = DM_WHITE;
			continue;
		}

		/* First, see if this matches an existing color map entry */
		rgb = ir_rgbtab;
		for( i = 0; i < slotsused; i++, rgb++ )  {
			if( rgb->r == r && rgb->g == g && rgb->b == b )  {
				sp->s_dmindex = i;
				goto next;
			}
		}

		/* If slots left, create a new color map entry, first-come basis */
		if( slotsused < ir_nslots )  {
			rgb = &ir_rgbtab[i=(slotsused++)];
			rgb->r = r;
			rgb->g = g;
			rgb->b = b;
			sp->s_dmindex = i;
			continue;
		}
		sp->s_dmindex = DM_YELLOW;	/* Default color */
next:		
		;
	}
}

/*
 *  I R _ D B T E X T
 *
 *  Used to call dbtext to print cute messages on the button box,
 *  if you have one.  Has to shift everythign to upper case
 *  since the box goes off the deep end with lower case.
 *
 *  Because not all SGI button boxes have text displays,
 *  this now needs to go to stdout in order to be useful.
 */

ir_dbtext(str)
register char *str;
{
#if IR_BUTTONS
	register i;
	char	buf[9];
	register char *cp;

# if 0
	for(i = 0, cp = buf; i < 8 && *str; i++, cp++, str++)
		*cp = islower(*str) ?  toupper(*str) : *str;
	*cp = 0;
	dbtext(buf);
# else
	rt_log("dm-4d: You pressed Help key and '%s'\n", str);
# endif
#else
	return;
#endif
}

#if IR_KNOBS
/*
 *			I R L I M I T
 *
 * Because the dials are so sensitive, setting them exactly to
 * zero is very difficult.  This function can be used to extend the
 * location of "zero" into "the dead zone".
 */
static 
int irlimit(i)
int i;
{
	if( i > NOISE )
		return( i-NOISE );
	if( i < -NOISE )
		return( i+NOISE );
	return(0);
}
#endif

/*			G E N _ C O L O R
 *
 *	maps a given color into the appropriate colormap entry
 *	for both depthcued and non-depthcued mode.  In depthcued mode,
 *	gen_color also generates the colormap ramps.  Note that in depthcued
 *	mode, DM_BLACK uses map entry 0, and does not generate a ramp for it.
 *	Non depthcued mode skips the first CMAP_BASE colormap entries.
 *
 *	This routine is not called at all if ir_has_rgb is set.
 */
gen_color(c)
int c;
{
	if(cueing_on) {

		/*  Not much sense in making a ramp for DM_BLACK.  Besides
		 *  which, doing so, would overwrite the bottom color
		 *  map entries, which is a no-no.
		 */
		if( c != DM_BLACK) {
			register int i;
			fastf_t r_inc, g_inc, b_inc;
			fastf_t red, green, blue;

			r_inc = ir_rgbtab[c].r/16;
			g_inc = ir_rgbtab[c].g/16;
			b_inc = ir_rgbtab[c].b/16;

			red = ir_rgbtab[c].r;
			green = ir_rgbtab[c].g;
			blue = ir_rgbtab[c].b;

			for(i = 15; i >= 0;
			    i--, red -= r_inc, green -= g_inc, blue -= b_inc)
				mapcolor( MAP_ENTRY(c) + i,
				    (short)red,
				    (short)green,
				    (short)blue );
		}
	} else {
		mapcolor(c+CMAP_BASE,
		    ir_rgbtab[c].r, ir_rgbtab[c].g, ir_rgbtab[c].b);
	}
}

#ifdef never
/*
 *  Update the PF key lights.
 */
static int
kblights()
{
	char	lights;

	lights = (cueing_on)
	    | (zclipping_on << 1)
	    | (perspective_mode << 2)
	    | (zbuffer_on << 3);

	lampon(lights);
	lampoff(lights^0xf);
}
#endif

static void
establish_zbuffer()
{
	if( ir_has_zbuf == 0 )  {
		rt_log("dm-4d: This machine has no Zbuffer to enable\n");
		zbuffer_on = 0;
	}
	zbuffer( zbuffer_on );
	if( zbuffer_on)  {
		/* Set screen coords of near and far clipping planes */
		lsetdepth(min_scr_z, max_scr_z);
	}
	dmaflag = 1;
}

ir_clear_to_black()
{
	/* Re-enable the full viewport */
	viewport(0, winx_size, 0, winy_size);

	if( zbuffer_on )  {
		zfunction( ZF_LEQUAL );
		if( ir_has_rgb )  {
			czclear( 0x000000, max_scr_z );
		} else {
			czclear( BLACK, max_scr_z );
		}
	} else {
		if( ir_has_rgb )  {
			RGBcolor( (short)0, (short)0, (short)0 );
		} else {
			color(BLACK);
		}
		clear();
	}
}

#if 0
/* Handy fakeouts when we don't want to link with -lmpc */
usinit()	{ 
	rt_log("usinit\n"); 
}
usnewlock()	{ 
	rt_log("usnewlock\n"); 
}
taskcreate()	{ 
	rt_log("taskcreate\n"); 
}
#endif

/*
 *  The structparse will change the value of the variable.
 *  Just implement it, here.
 */
static void
establish_lighting()
{
	if( !lighting_on )  {
		/* Turn it off */
		mmode(MVIEWING);
		lmbind(MATERIAL,0);
		lmbind(LMODEL,0);
		mmode(MSINGLE);
	} else {
		/* Turn it on */
		if( cueing_on )  {
			/* Has to be off for lighting */
			cueing_on = 0;
			Ir_colorchange();
		}

		mmode(MVIEWING);


		make_materials();	/* Define material properties */

		lmbind(LMODEL, 2);	/* infinite */
		lmbind(LIGHT2,2);
		lmbind(LIGHT3,3);
		lmbind(LIGHT4,4);
		lmbind(LIGHT5,5);

		/* RGB color commands & lighting */
		lmcolor( LMC_COLOR );

		mmode(MSINGLE);
	}
	dmaflag = 1;
}

/*
 *  Some initial lighting model stuff
 *  Really, MGED needs to derrive it's lighting from the database,
 *  but for now, this hack will suffice.
 *
 *  For materials, the definitions are:
 *	ALPHA		opacity.  1.0=opaque
 *	AMBIENT		ambient reflectance of the material  0..1
 *	DIFFUSE		diffuse reflectance of the material  0..1
 *	SPECULAR	specular reflectance of the material  0..1
 *	EMISSION	emission color ???
 *	SHININESS	specular scattering exponent, integer 0..128
 */
static float material_default[] = {
	ALPHA,		1.0,
	AMBIENT,	0.2, 0.2, 0.2,
	DIFFUSE,	0.8, 0.8, 0.8,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	0.0,
	SPECULAR,	0.0, 0.0, 0.0,
	LMNULL   };

/* Something like the RT default phong material */
static float material_rtdefault[] = {
	ALPHA,		1.0,	
	AMBIENT,	0.2, 0.2, 0.2,	/* 0.4 in rt */
	DIFFUSE,	0.6, 0.6, 0.6,
	SPECULAR,	0.2, 0.2, 0.2,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	10.0,
	LMNULL   };

/* This was the "default" material in the demo */
static float material_xdefault[] = {
	AMBIENT, 0.35, 0.25,  0.1,
	DIFFUSE, 0.1, 0.5, 0.1,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 5.0,
	LMNULL   };

static float mat_brass[] = {
	AMBIENT, 0.35, 0.25,  0.1,
	DIFFUSE, 0.65, 0.5, 0.35,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 5.0,
	LMNULL   };

static float mat_shinybrass[] = {
	AMBIENT, 0.25, 0.15, 0.0,
	DIFFUSE, 0.65, 0.5, 0.35,
	SPECULAR, 0.9, 0.6, 0.0,
	SHININESS, 10.0,
	LMNULL   };

static float mat_pewter[] = {
	AMBIENT, 0.0, 0.0,  0.0,
	DIFFUSE, 0.6, 0.55 , 0.65,
	SPECULAR, 0.9, 0.9, 0.95,
	SHININESS, 10.0,
	LMNULL   };

static float mat_silver[] = {
	AMBIENT, 0.4, 0.4,  0.4,
	DIFFUSE, 0.3, 0.3, 0.3,
	SPECULAR, 0.9, 0.9, 0.95,
	SHININESS, 30.0,
	LMNULL   };

static float mat_gold[] = {
	AMBIENT, 0.4, 0.2, 0.0,
	DIFFUSE, 0.9, 0.5, 0.0,
	SPECULAR, 0.7, 0.7, 0.0,
	SHININESS, 10.0,
	LMNULL   };

static float mat_shinygold[] = {
	AMBIENT, 0.4, 0.2,  0.0,
	DIFFUSE, 0.9, 0.5, 0.0,
	SPECULAR, 0.9, 0.9, 0.0,
	SHININESS, 20.0,
	LMNULL   };

static float mat_plaster[] = {
	AMBIENT, 0.2, 0.2,  0.2,
	DIFFUSE, 0.95, 0.95, 0.95,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 1.0,
	LMNULL   };

static float mat_redplastic[] = {
	AMBIENT, 0.3, 0.1, 0.1,
	DIFFUSE, 0.5, 0.1, 0.1,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_greenplastic[] = {
	AMBIENT, 0.1, 0.3, 0.1,
	DIFFUSE, 0.1, 0.5, 0.1,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_blueplastic[] = {
	AMBIENT, 0.1, 0.1, 0.3,
	DIFFUSE, 0.1, 0.1, 0.5,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_greenflat[] = {
	EMISSION,   0.0, 0.4, 0.0,
	AMBIENT,    0.0, 0.0, 0.0,
	DIFFUSE,    0.0, 0.0, 0.0,
	SPECULAR,   0.0, 0.6, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_greenshiny[]= {
	EMISSION, 0.0, 0.4, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.25, 0.9, 0.25,
	SHININESS, 10.0,
	LMNULL
};

static float mat_blueflat[] = {
	EMISSION, 0.0, 0.0, 0.4,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.0, 0.5, 0.5,
	SPECULAR,  0.0, 0.0, 0.9,
	SHININESS, 10.0,
	LMNULL
};

static float mat_blueshiny[] = {
	EMISSION, 0.0, 0.0, 0.6,
	AMBIENT,  0.1, 0.25, 0.5,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_redflat[] = {
	EMISSION, 0.60, 0.0, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 1.0,
	LMNULL
};

static float mat_redshiny[] = {
	EMISSION, 0.60, 0.0, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_beigeshiny[] = {
	EMISSION, 0.5, 0.5, 0.6,
	AMBIENT,  0.35, 0.35, 0.0,
	DIFFUSE,  0.5, 0.5, 0.0,
	SPECULAR,  0.5, 0.5, 0.0,
	SHININESS, 10.0,
	LMNULL
};

/*
 *  Meanings of the parameters:
 *	AMBIENT		ambient light associated with this source ???, 0..1
 *	LCOLOR		light color, 0..1
 *	POSITION	position of light.  w=0 for infinite lights
 */
static float default_light[] = {
	AMBIENT,	0.0, 0.0, 0.0, 
	LCOLOR,		1.0, 1.0, 1.0, 
	POSITION,	0.0, 0.0, 1.0, 0.0,
	LMNULL};


#if 1
# if 0
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 100.0, -200.0, 100.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.6, 0.1, 0.1, 
	POSITION, -100.0, -30.0, 100.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.3, 0.1, 
	POSITION, 100.0, -20.0, 20.0, 0.0, 
	LMNULL};


static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.3, 
	POSITION, 0.0, 100.0, -100.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 1.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};
# else
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 100.0, 200.0, 100.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.6, 0.1, 0.1, 
	POSITION, 100.0, 30.0, 100.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.3, 0.1, 
	POSITION, -100.0, 20.0, 20.0, 0.0, 
	LMNULL};


static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.3, 
	POSITION, 0.0, -100.0, -100.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 1.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};
# endif

#else
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 10.0, 50.0, 50.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.5, 0.1, 0.1, 
	POSITION, -100.0, 0.0, 0.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.5, 0.1, 
	POSITION, 100.0, 50.0, 0.0, 0.0, 
	LMNULL};

static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.5, 
	POSITION, 0.0, -50.0, 0.0, 0.0, 
	LMNULL};

static float orange_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,	0.35, 0.175, 0.0, 
	POSITION, -50.0, 50.0, 10.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};


#endif




/*
 *  Lighting model parameters
 *	AMBIENT		amount of ambient light present in the scene, 0..1
 *	ATTENUATION	fixed and variable attenuation factor, 0..1
 *	LOCALVIEWER	1=eye at (0,0,0), 0=eye at (0,0,+inf)
 */
static float	default_lmodel[] = {
	AMBIENT,	0.2,  0.2,  0.2,
	ATTENUATION,	1.0, 0.0, 
	LOCALVIEWER,	0.0, 
	LMNULL};

static float infinite[] = {
	AMBIENT, 0.3,  0.3, 0.3, 
	LOCALVIEWER, 0.0, 
	LMNULL};

static float local[] = {
	AMBIENT, 0.3,  0.3, 0.3, 
	LOCALVIEWER, 1.0, 
	ATTENUATION, 1.0, 0.0, 
	LMNULL};


make_materials()
{
	/* define material properties */
	lmdef (DEFMATERIAL, 1, 0, material_default);

	lmdef (DEFMATERIAL, 2, 0, mat_brass);
	lmdef (DEFMATERIAL, 3, 0, mat_shinybrass);
	lmdef (DEFMATERIAL, 4, 0, mat_pewter);
	lmdef (DEFMATERIAL, 5, 0, mat_silver);
	lmdef (DEFMATERIAL, 6, 0, mat_gold);
	lmdef (DEFMATERIAL, 7, 0, mat_shinygold);
	lmdef (DEFMATERIAL, 8, 0, mat_plaster);
	lmdef (DEFMATERIAL, 9, 0, mat_redplastic);
	lmdef (DEFMATERIAL, 10, 0, mat_greenplastic);
	lmdef (DEFMATERIAL, 11, 0, mat_blueplastic);

	lmdef (DEFMATERIAL, 12, 0, mat_greenflat);
	lmdef (DEFMATERIAL, 13, 0, mat_greenshiny);

	lmdef (DEFMATERIAL, 14, 0, mat_blueflat);
	lmdef (DEFMATERIAL, 15, 0, mat_blueshiny);

	lmdef (DEFMATERIAL, 16, 0, mat_redflat);
	lmdef (DEFMATERIAL, 17, 0, mat_redshiny);

	lmdef (DEFMATERIAL, 18, 0, mat_beigeshiny);

	lmdef( DEFMATERIAL, 19, 0, material_xdefault );
	lmdef( DEFMATERIAL, 20, 0, material_rtdefault );

	/*    lmdef (DEFLIGHT, 1, 0, default_light); */
	lmdef (DEFLIGHT, 4, 0, green_inf_light);
	lmdef (DEFLIGHT, 2, 0, white_inf_light);
	lmdef (DEFLIGHT, 3, 0, red_inf_light);
	lmdef (DEFLIGHT, 4, 0, green_inf_light);
	lmdef (DEFLIGHT, 5, 0, blue_inf_light);
	/*    lmdef (DEFLIGHT, 6, 0, orange_inf_light); */
	lmdef (DEFLIGHT, 7, 0, white_local_light);

	lmdef (DEFLMODEL, 1, 0, default_lmodel);
	lmdef (DEFLMODEL, 2, 0, infinite);
	lmdef (DEFLMODEL, 3, 0, local);


}

/*
 *  Check to see if setmonitor(STR_RECT) will work.
 *  Returns -
 *	> 0	If stereo is available
 *	0	If not
 */
int
sgi_has_stereo()
{
#if !defined(__sgi) && !defined(__mips)
	/* IRIX 3 systems, test to see if DER1_STEREO bit is
	 * read/write (no hardware underneath), or
	 * read only (hardware underneath, which can't be read back.
	 */
	int	rw_orig, rw1, rw2;

	rw_orig = getvideo(DE_R1);
	rw1 = rw_orig ^ DER1_STEREO;	/* Toggle the bit */
	setvideo(DE_R1, rw1);
	rw2 = getvideo(DE_R1);
	if( rw1 != rw2 )  {
		setvideo(DE_R1, rw_orig);/* Restore original state */
		return 1;		/* Has stereo */
	}
	rw1 = rw1 ^ DER1_STEREO;	/* Toggle the bit, again */
	setvideo(DE_R1, rw1);
	rw2 = getvideo(DE_R1);
	if( rw1 != rw2 )  {
		setvideo(DE_R1, rw_orig);/* Restore original state */
		return 1;		/* Has stereo */
	}
	setvideo(DE_R1, rw_orig);	/* Restore original state */
	return 0;			/* Does not have stereo */
#else
	/* IRIX 4 systems */
	return getgdesc(GD_STEREO);
#endif
}

/*
 *			I R _ D M
 * 
 *  Implement display-manager specific commands, from MGED "dm" command.
 */
int
Ir_dm(argc, argv)
int	argc;
char	**argv;
{
	struct rt_vls	vls;

	if( argc < 1 )  return -1;

	/* For now, only "set" command is implemented */
	if( strcmp( argv[0], "set" ) != 0 )  {
		rt_log("dm: command is not 'set'\n");
		return CMD_BAD;
	}

	rt_vls_init(&vls);
	if( argc < 2 )  {
		/* Bare set command, print out current settings */
		rt_structprint("dm_4d internal variables", Ir_vparse, (char *)0 );
		rt_log("%s", rt_vls_addr(&vls) );
	} else if( argc == 2 ) {
	        rt_vls_name_print( &vls, Ir_vparse, argv[1], (char *)0 );
		rt_log( "%s\n", rt_vls_addr(&vls) );
  	} else {
	        rt_vls_printf( &vls, "%s=\"", argv[1] );
	        rt_vls_from_argv( &vls, argc-2, argv+2 );
		rt_vls_putc( &vls, '\"' );
		rt_structparse( &vls, Ir_vparse, (char *)0 );
	}
	rt_vls_free(&vls);
	return CMD_OK;
}
#endif
@


11.21
log
@check this in for Mike
@
text
@d1 1
d6 2761
d2785 1
a2785 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.20 1995/12/20 19:27:51 bparker Exp mike $ (BRL)";
a2864 1
static CONST char ir_title[] = "BRL MGED";
d2867 4
d2877 2
a2878 2
static mat_t	aspect_corr;
static int	stereo_is_on = 0;
d2971 1
a2987 1

d3178 1
d3486 1
d4030 1
a4031 1
	static	knobs[8];	/*  Save values of dials  */
d5270 1
a5270 2


@


11.20
log
@back to version 11.9
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.9 1995/11/02 18:30:38 cjohnson Exp $ (BRL)";
d55 1
d272 1
d299 12
a310 1
	switch( getmonitor() )  {
@


11.19
log
@using create_glx proc to create the glxwidget.
also now prompting for the DISPLAY environment variable.
now using an environment variable when looking for the starup file.
@
text
@a1 23
   Just a note:

   DM-4D.C currently uses the commands below. These particular commands
   should not be used in mixed mode programming.

   qdevice
   blkqread
   qtest
   getbutton
   getvaluator
   setvaluator
   unqdevice
   mapcolor
   gconfig
   doublebuffer
   RGBmode
   winopen
   foreground
   noborder
   keepaspect
   prefposition
*/
/*
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.18 1995/12/04 22:03:13 bparker Exp bparker $ (BRL)";
a25 4
/* Experimental */
#define MIXED_MODE 1
#define TRY_PIPES 1

a38 18
#if MIXED_MODE
#include <X11/X.h>
#include <gl/glws.h>
#include "tk.h"
#include <X11/extensions/XI.h>
#include <X11/extensions/XInput.h>
#include <X11/Xutil.h>
#include "tkGLX.h"
extern Tcl_Interp *interp;
extern Tk_Window tkwin;
static Tk_Window xtkwin;
static Display  *dpy;
static Window   win;
static int devmotionnotify = LASTEvent;
static int devbuttonpress = LASTEvent;
static int devbuttonrelease = LASTEvent;
#endif

a58 3
#if TRY_PIPES
extern int ged_pipe[];
#endif
a76 8
#if MIXED_MODE
int   Ir_loadGLX();
#ifdef USE_PROTOTYPES
Tk_GenericProc Ircheckevents;
#else
int Ircheckevents();
#endif
#else
a77 1
#endif
a88 5
#if 0
static int      focus = 0;              /* send key events to the command window */
#endif
static int      dummy_perspective = 1;
static int      perspective_mode = 0;	/* Perspective flag */
a100 10
#if MIXED_MODE
static int irsetup();
GLXconfig glxConfig [] = {
  { GLX_NORMAL, GLX_DOUBLE, TRUE },
  { GLX_NORMAL, GLX_RGB, TRUE },
  { GLX_NORMAL, GLX_ZSIZE, GLX_NOCONFIG },
  { 0, 0, 0 }
};
#endif

d103 1
a195 2
static void     establish_perspective();
static void     set_perspective();
a209 2
	{"%d",  1, "perspective",       (int)&perspective_mode, establish_perspective },
	{"%d",  1, "set_perspective",(int)&dummy_perspective,  set_perspective },
a221 1
static char ref[] = "mged";
a238 3
#if MIXED_MODE
	x = (x/(double)winx_size - 0.5) * 4095;
#else
a240 1

a243 2
#endif

a250 3
#if MIXED_MODE
	y = (0.5 - y/(double)winy_size) * 4095;
#else
a252 1

a256 2
#endif

a270 3
#if MIXED_MODE
	XWindowAttributes xwa;
#endif
a275 5
#if MIXED_MODE
	XGetWindowAttributes( dpy, win, &xwa );
	winx_size = xwa.width;
	winy_size = xwa.height;
#else
a277 1

d280 1
a280 1
#endif
a296 2
#if MIXED_MODE
#else
a352 1
#endif
a376 330
#if MIXED_MODE
Ir_open()
{
        char	line[82];
        char	hostname[80];
	char	display[82];
	char	*envp;

	/* get or create the default display */
	if( (envp = getenv("DISPLAY")) == NULL ) {
		/* Env not set, use local host */
		gethostname( hostname, 80 );
		hostname[79] = '\0';
		(void)sprintf( display, "%s:0", hostname );
		envp = display;
	}

	rt_log("X Display [%s]? ", envp );
	(void)fgets( line, sizeof(line), stdin );
	line[strlen(line)-1] = '\0';		/* remove newline */
	if( feof(stdin) )  quit();
	if( line[0] != '\0' ) {
		if( irsetup(line) ) {
			return(1);		/* BAD */
		}
	} else {
		if( irsetup(envp) ) {
			return(1);	/* BAD */
		}
	}

	/* Ignore the old scrollbars and menus */
	ignore_scroll_and_menu = 1;

	return(0);			/* OK */
}

static int
irsetup( name )
char *name;
{
	register int	i;
	Matrix		m;
	inventory_t	*inv;
	int		win_size=1000;
	int		win_o_x=272;
	int		win_o_y=12;
	struct rt_vls str;
	int j, k;
	int ndevices;
	int nclass = 0;
	XDeviceInfoPtr olist, list;
	XDevice *dev;
	XEventClass e_class[15];
	XInputClassInfo *cip;
	XAnyClassPtr any;

	rt_vls_init(&str);
	rt_vls_printf(&str, "loadtk %s\n", name);
	if(cmdline(&str, FALSE) == CMD_BAD){
	  rt_vls_free(&str);
	  return -1;
	}
	
	(void)TkGLX_Init(interp, tkwin);

	/* Invoke script to create button and key bindings */
	if( Ir_loadGLX() )
	  return -1;

	dpy = Tk_Display(tkwin);
	winx_size = DisplayWidth(dpy, Tk_ScreenNumber(tkwin)) - 20;
	winy_size = DisplayHeight(dpy, Tk_ScreenNumber(tkwin)) - 20;
	if(winx_size > winy_size)
	  winx_size = winy_size;
	else
	  winy_size = winx_size;

	rt_vls_strcpy(&str, "create_glx ");
	rt_vls_printf(&str, ".%s %s %d %d true true\n", ref, ref,
		      winx_size, winy_size);
	rt_vls_printf(&str, "pack .%s -expand 1 -fill both\n", ref);
	if(cmdline(&str, FALSE) == CMD_BAD){
	  rt_vls_free(&str);
	  return -1;
	}

	rt_vls_free(&str);

	if(TkGLXwin_RefExists(ref)){
	  xtkwin = TkGLXwin_RefGetTkwin(ref);
	  if(xtkwin == NULL)
	    return -1;
	}else{
	  rt_log("Ir_open: ref - %s doesn't exist!!!\n", ref);
	  return -1;
	}

	/* Do this now to force a GLXlink */
	Tk_MapWindow(xtkwin);

	Tk_MakeWindowExist(xtkwin);
	win = Tk_WindowId(xtkwin);

	ir_is_gt = 1;

	{
	  GLXconfig *glx_config, *p;

	  glx_config = TkGLXwin_RefGetConfig(ref);
	
	  for(p = glx_config; p->buffer; ++p){
	    switch(p->buffer){
	    case GLX_NORMAL:
	      switch(p->mode){
	      case GLX_ZSIZE:
		if(p->arg)
		  ir_has_zbuf = 1;
		else
		  ir_has_zbuf = 0;

		break;
	      case GLX_RGB:
		if(p->arg)
		  ir_has_rgb = 1;
		else
		  ir_has_rgb = 0;

		break;
	      case GLX_DOUBLE:
		if(p->arg)
		  ir_has_doublebuffer = 1;
		else
		  ir_has_doublebuffer = 0;

		break;
	      case GLX_STEREOBUF:
		stereo_is_on = 1;

		break;
	      case GLX_BUFSIZE:
	      case GLX_STENSIZE:
	      case GLX_ACSIZE:
	      case GLX_VISUAL:
	      case GLX_COLORMAP:
	      case GLX_WINDOW:
	      case GLX_MSSAMPLE:
	      case GLX_MSZSIZE:
	      case GLX_MSSSIZE:
	      case GLX_RGBSIZE:
	      default:
		break;
	      }
	    case GLX_OVERLAY:
	    case GLX_POPUP:
	    case GLX_UNDERLAY:
	    default:
	      break;
	    }
	  }

	  free((void *)glx_config);
	}

#if 0
	/* Start out with the usual window */
/*XXX Not supposed to be using this guy in mixed mode. */
	foreground();
#endif
	
	if (mged_variables.sgi_win_size > 0)
		win_size = mged_variables.sgi_win_size;

	if (mged_variables.sgi_win_origin[0] != 0)
		win_o_x = mged_variables.sgi_win_origin[0];

	if (mged_variables.sgi_win_origin[1] != 0)
		win_o_y = mged_variables.sgi_win_origin[1];
#if 0
	prefposition( win_o_x, win_o_x+win_size, win_o_y, win_o_y+win_size);
#else
#endif
#if 0
	keepaspect(1,1);	/* enforce 1:1 aspect ratio */
#endif
	winconstraints();	/* remove constraints on the window size */

	/*
	 * Establish GL library operating modes
	 */
	/* Don't draw polygon edges */
	glcompat( GLC_OLDPOLYGON, 0 );

	/* Z-range mapping */
	/* Z range from getgdesc(GD_ZMIN)
	 * to getgdesc(GD_ZMAX).
	 * Hardware specific.
	 */
	glcompat( GLC_ZRANGEMAP, 0 );
	/* Take off a smidgeon for wraparound, as suggested by SGI manual */
#if 1
	min_scr_z = getgdesc(GD_ZMIN)+15;
	max_scr_z = getgdesc(GD_ZMAX)-15;
#else
	min_scr_z = 0;
	max_scr_z = 0;
#endif

	Ir_configure_window_shape();

	/* Line style 0 is solid.  Program line style 1 as dot-dashed */
	deflinestyle( 1, 0xCF33 );
	setlinestyle( 0 );

/* Take a look at the available input devices */
	olist = list = (XDeviceInfoPtr) XListInputDevices (dpy, &ndevices);

	/* IRIX 4.0.5 bug workaround */
	if( list == (XDeviceInfoPtr)NULL ||
	   list == (XDeviceInfoPtr)1 )  goto Done;

	for(j = 0; j < ndevices; ++j, list++){
	  if(list->use == IsXExtensionDevice){
	    if(!strcmp(list->name, "dial+buttons")){
	      if((dev = XOpenDevice(dpy, list->id)) == (XDevice *)NULL){
		rt_log("Ir_open: Couldn't open the dials+buttons\n");
		goto Done;
	      }

	      for(cip = dev->classes, k = 0; k < dev->num_classes;
		  ++k, ++cip){
		switch(cip->input_class){
		case ButtonClass:
		  DeviceButtonPress(dev, devbuttonpress, e_class[nclass]);
		  ++nclass;
		  DeviceButtonRelease(dev, devbuttonrelease, e_class[nclass]);
		  ++nclass;
		  break;
		case ValuatorClass:
		  DeviceMotionNotify(dev, devmotionnotify, e_class[nclass]);
		  ++nclass;
		  break;
		default:
		  break;
		}
	      }

	      XSelectExtensionEvent(dpy, win, e_class, nclass);
	      goto Done;
	    }
	  }
	}
Done:
	XFreeDeviceList(olist);
	Tk_CreateGenericHandler(Ircheckevents, (ClientData)NULL);
	XSelectInput(dpy, win, ExposureMask|ButtonPressMask|
		     KeyPressMask|StructureNotifyMask);

	return(0);
}

/*XXX Just experimenting */
int
Ir_loadGLX()
{
  FILE    *fp;
  struct rt_vls str;
  char *path;
  int     found;
  int bogus;

#define DM_IR_ENVRC "MGED_DM_IR_RCFILE"
#define DM_IR_RCFILE "glxinit2.tk"

  found = 0;
  rt_vls_init( &str );

  if((path = getenv(DM_IR_ENVRC)) != (char *)NULL ){
    if ((fp = fopen(path, "r")) != NULL ) {
      rt_vls_strcpy( &str, path );
      found = 1;
    }
  }

  if(!found){
    if( (path = getenv("HOME")) != (char *)NULL )  {
      rt_vls_strcpy( &str, path );
      rt_vls_strcat( &str, "/" );
      rt_vls_strcat( &str, DM_IR_RCFILE );

      if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )
	found = 1;
    }
  }

  if( !found ) {
    if( (fp = fopen( DM_IR_RCFILE, "r" )) != NULL )  {
      rt_vls_strcpy( &str, DM_IR_RCFILE );
      found = 1;
    }
  }

/*XXX Temporary, so things will work without knowledge of the new environment
      variables */
  if( !found ) {
    rt_vls_strcpy( &str, "/m/cad/mged/");
    rt_vls_strcat( &str, DM_IR_RCFILE);

    if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )
      found = 1;
  }

  if(!found){
    rt_vls_free(&str);
    return -1;
  }

  fclose( fp );

  if (Tcl_EvalFile( interp, rt_vls_addr(&str) ) == TCL_ERROR) {
    rt_log("Error reading %s: %s\n", DM_IR_RCFILE, interp->result);
    rt_vls_free(&str);
    return -1;
  }

  rt_vls_free(&str);
  return 0;
}

#else
a676 1
#endif
a702 3
#if MIXED_MODE
	Tk_DestroyWindow(xtkwin);
#else
d707 1
a707 4
#endif

	/* Stop ignoring the old scrollbars and menus */
	ignore_scroll_and_menu = 0;
a1178 3
#if MIXED_MODE
/* Don't need to do this because Ir_input never gets called anyway */
#else
d1235 1
a1235 1
#endif
a1237 195

#if MIXED_MODE
/*
   This routine does not get key events. The key events are
   being processed via the TCL/TK bind command. Eventually, I'd also
   like to do the dials+buttons that way. That would leave this
   routine to handle only events like Expose and ConfigureNotify.
*/
int
Ircheckevents(clientData, eventPtr)
ClientData clientData;
XEvent *eventPtr;
{
  XEvent event;
  static int button0  = 0;   /*  State of button 0 */
  static int knobs[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  static int knobs_offset[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  static int knobs_during_help[8] = {0, 0, 0, 0, 0, 0, 0, 0};

/*XXX still drawing too much!!!
i.e. drawing 2 or more times when resizing the window to a larger size.
once for the Configure and once for the expose. This is especially
annoying when running remotely. */

  if (eventPtr->xany.window != win)
    return TCL_OK;

#if 0
if(eventPtr->type == Expose)
  rt_log("Ircheckevents:%d\t%d\tevent type - %d\tcount - %d\n",
	 win, eventPtr->xany.window, eventPtr->type, eventPtr->xexpose.count);
else if( eventPtr->type == ConfigureNotify )
  rt_log("Ircheckevents:%d\t%d\tevent type - %d\n",
	 win, eventPtr->xany.window, eventPtr->type, eventPtr->xexpose.count);
#endif

#if TRY_PIPES
  if(mged_variables.focus && eventPtr->type == KeyPress){
    char buffer[1];

    XLookupString(&(eventPtr->xkey), buffer, 1,
		  (KeySym *)NULL, (XComposeStatus *)NULL);

    write(ged_pipe[1], buffer, 1);
    return TCL_RETURN;
  }
#endif


  /* Now getting X events */
  if(eventPtr->type == Expose && eventPtr->xexpose.count == 0){
    /* Window may have moved */
    Ir_configure_window_shape();

    dmaflag = 1;
    if( ir_has_doublebuffer) /* to fix back buffer */
      refresh();
    dmaflag = 1;
  }else if( eventPtr->type == ConfigureNotify ){
      /* Window may have moved */
      Ir_configure_window_shape();

      if (eventPtr->xany.window != win)
	return TCL_OK;

      dmaflag = 1;
      if( ir_has_doublebuffer) /* to fix back buffer */
	refresh();
      dmaflag = 1;
  }else if( eventPtr->type == MotionNotify ) {
    int x, y;

    x = (eventPtr->xmotion.x/(double)winx_size - 0.5) * 4095;
    y = (0.5 - eventPtr->xmotion.y/(double)winy_size) * 4095;
    /* Constant tracking (e.g. illuminate mode) bound to M mouse */
    rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n", x, y );
  }else if( eventPtr->type == devmotionnotify ){
    XDeviceMotionEvent *M;
    int setting;

    M = (XDeviceMotionEvent * ) eventPtr;

    if(button0){
      knobs_during_help[M->first_axis] = M->axis_data[0];
      ir_dbtext(
		(adcflag ? kn1_knobs:kn2_knobs)[M->first_axis]);
      return TCL_OK;
    }else{
      knobs[M->first_axis] = M->axis_data[0];
      setting = irlimit(knobs[M->first_axis] - knobs_offset[M->first_axis]);
    }

    switch(DIAL0 + M->first_axis){
    case DIAL0:
      if(adcflag) {
	rt_vls_printf( &dm_values.dv_string, "knob ang1 %d\n",
		      setting );
      }
      break;
    case DIAL1:
      rt_vls_printf( &dm_values.dv_string , "knob S %f\n",
		    setting / 2048.0 );
      break;
    case DIAL2:
      if(adcflag)
	rt_vls_printf( &dm_values.dv_string , "knob ang2 %d\n",
		      setting );
      else
	rt_vls_printf( &dm_values.dv_string , "knob z %f\n",
		      setting / 2048.0 );
      break;
    case DIAL3:
      if(adcflag)
	rt_vls_printf( &dm_values.dv_string , "knob distadc %d\n",
		      setting );
      else
	rt_vls_printf( &dm_values.dv_string , "knob Z %f\n",
		      setting / 2048.0 );
      break;
    case DIAL4:
      if(adcflag)
	rt_vls_printf( &dm_values.dv_string , "knob yadc %d\n",
		      setting );
      else
	rt_vls_printf( &dm_values.dv_string , "knob y %f\n",
		      setting / 2048.0 );
      break;
    case DIAL5:
      rt_vls_printf( &dm_values.dv_string , "knob Y %f\n",
		    setting / 2048.0 );
      break;
    case DIAL6:
      if(adcflag)
	rt_vls_printf( &dm_values.dv_string , "knob xadc %d\n",
		      setting );
      else
	rt_vls_printf( &dm_values.dv_string , "knob x %f\n",
		      setting / 2048.0 );
      break;
    case DIAL7:
      rt_vls_printf( &dm_values.dv_string , "knob X %f\n",
		    setting / 2048.0 );
      break;
    default:
      break;
    }

  }else if( eventPtr->type == devbuttonpress ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1){
      button0 = 1;
      return TCL_OK;
    }

    if(button0){
      ir_dbtext(label_button(bmap[B->button - 1]));
    }else if(B->button == 4){
      int i;

      rt_vls_strcat(&dm_values.dv_string, "knob zero\n");
      for(i = 0; i < 8; ++i){
#if 0 /* Not surprising that this really doesn't work. */
	/* Not supposed to use this in mixed mode; trying it anyway:-). */
	setvaluator(DIAL0+i, 0, -2048-NOISE, 2047+NOISE);

	knobs[i] = 0;
#else
	knobs_offset[i] = knobs[i];
#endif
      }
    }else
      rt_vls_printf(&dm_values.dv_string, "press %s\n",
		    label_button(bmap[B->button - 1]));
  }else if( eventPtr->type == devbuttonrelease ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1){
      int i;

      button0 = 0;

      /* update the offset */
      for(i = 0; i < 8; ++i)
	knobs_offset[i] += knobs_during_help[i] - knobs[i];
    }
  }

  return TCL_OK;
}
#else
a1593 1
#endif
a1662 21
#if MIXED_MODE
 	switch( b )  {
	case ST_VIEW:
	  /* constant tracking OFF */
	  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|
		       KeyPressMask|StructureNotifyMask);
	  break;
	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
	  /* constant tracking ON */
	  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|
		       KeyPressMask|StructureNotifyMask|PointerMotionMask);
	  break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	  /* constant tracking OFF */
	  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|
		       KeyPressMask|StructureNotifyMask);
	  break;
#else
a1679 1
#endif
a1683 1

a1905 2
#if MIXED_MODE
#else
a1935 1
#endif
a1957 39
establish_perspective()
{
  rt_vls_printf( &dm_values.dv_string,
		"set perspective %d\n",
		perspective_mode ?
		perspective_table[perspective_angle] :
		-1 );
  dmaflag = 1;
}

/*
   This routine will toggle the perspective_angle if the
   dummy_perspective value is 0 or less. Otherwise, the
   perspective_angle is set to the value of (dummy_perspective - 1).
*/
static void
set_perspective()
{
  /* set perspective matrix */
  if(dummy_perspective > 0)
    perspective_angle = dummy_perspective <= 4 ? dummy_perspective - 1: 3;
  else if (--perspective_angle < 0) /* toggle perspective matrix */
    perspective_angle = 3;

  if(perspective_mode)
    rt_vls_printf( &dm_values.dv_string,
		  "set perspective %d\n",
		  perspective_table[perspective_angle] );

  /*
     Just in case the "!" is used with the set command. This
     allows us to toggle through more than two values.
   */
  dummy_perspective = 1;

  dmaflag = 1;
}

static void
a2464 1
#if 0
d2489 1
a2489 38
#else
	if( !strcmp( argv[0], "set" )){
	  rt_vls_init(&vls);
	  if( argc < 2 )  {
	    /* Bare set command, print out current settings */
	    rt_structprint("dm_4d internal variables", Ir_vparse, (char *)0 );
	    rt_log("%s", rt_vls_addr(&vls) );
	  } else if( argc == 2 ) {
	    rt_vls_name_print( &vls, Ir_vparse, argv[1], (char *)0 );
	    rt_log( "%s\n", rt_vls_addr(&vls) );
	  } else {
	    rt_vls_printf( &vls, "%s=\"", argv[1] );
	    rt_vls_from_argv( &vls, argc-2, argv+2 );
	    rt_vls_putc( &vls, '\"' );
	    rt_structparse( &vls, Ir_vparse, (char *)0 );
	  }
	  rt_vls_free(&vls);
	  return CMD_OK;
	}

	if( !strcmp( argv[0], "mouse" )){
	  int up;
	  int xpos;
	  int ypos;

	  if( argc < 4){
	    rt_log("dm: need more parameters\n");
	    rt_log("mouse 1|0 xpos ypos\n");
	    return CMD_BAD;
	  }

	  up = atoi(argv[1]);
	  xpos = atoi(argv[2]);
	  ypos = atoi(argv[3]);
	  rt_vls_printf(&dm_values.dv_string, "M %d %d %d\n",
			up, irisX2ged(xpos), irisY2ged(ypos));
	  return CMD_OK;
	}
a2490 2
	rt_log("dm: bad command - %s\n", argv[0]);
	return CMD_BAD;
a2491 2
#endif
}
@


11.18
log
@using ignore_scroll_and_menu to ignore the old scrollbars and menus.
now using mged_variables.focus instead of a local variable
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.17 1995/12/02 00:22:42 bparker Exp bparker $ (BRL)";
d126 1
a126 1
void   Ir_loadGLX();
d163 10
d297 1
a297 1
static char ref[] = "mged_glx";
a477 1
int
d480 38
d535 29
a563 2
	rt_vls_strcpy(&str, "loadtk\n");
	(void)cmdline(&str, FALSE);
a564 2
	
	TkGLX_Init(interp, tkwin);
d566 8
a573 2
	/* Invoke script to create a mixed-mode X window */
	Ir_loadGLX();
a577 1
	dpy = Tk_Display(xtkwin);
a580 1
#if 0
d582 1
a582 4
	ir_has_zbuf = 1;
	ir_has_rgb = 1;
	ir_has_doublebuffer = 1;
#else
a627 5
#if 0
		/* What else do we have? */
		rt_log("Ir_open: GLX_NORMAL\tmode - %d\targ - %d\n",
		       p->mode, p->arg);
#endif
a633 5
#if 0
	      /* What else do we have? */
	      rt_log("Ir_open: buffer - %d\tmode - %d\targ - %d\n",
		     p->buffer, p->mode, p->arg);
#endif
a639 1
#endif
d735 1
a735 4
	/* Ignore the old scrollbars and menus */
	ignore_scroll_and_menu = 1;

	return (0);
d739 1
a739 1
void
d742 50
a791 3
  if(Tcl_EvalFile(interp, "/m/cad/mged/glxinit.tk") == TCL_ERROR){
    rt_log("Ir_open: %s\n", interp->result);
    mged_finish(1);
d794 6
a799 5
  if(TkGLXwin_RefExists(ref))
    xtkwin = TkGLXwin_RefGetTkwin(ref);
  else{
    rt_log("Ir_open: ref - %s doesn't exist!!!\n", ref);
    mged_finish(1);
d801 3
@


11.17
log
@*** empty log message ***
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.16 1995/11/30 23:12:51 bparker Exp bparker $ (BRL)";
d146 1
d148 1
a274 1
	{"%d",  1, "focus",             (int)&focus,            FUNC_NULL },
d287 1
a476 1
	char ref[] = "mged_glx";
a496 7
	if(TkGLXwin_RefExists(ref))
	  xtkwin = TkGLXwin_RefGetTkwin(ref);
	else{
	  rt_log("Ir_open: ref - %s doesn't exist!!!\n", ref);
	  mged_finish(1);
	}

d673 3
d687 7
d1032 3
a1034 1
	return;
d1605 1
a1605 1
  if(focus && eventPtr->type == KeyPress){
@


11.16
log
@*** empty log message ***
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.15 1995/11/29 21:58:00 bparker Exp bparker $ (BRL)";
d256 1
a256 1
static void     next_perspective();
d272 1
a272 1
	{"%d",  1, "next_perspective",(int)&dummy_perspective,  next_perspective },
d2520 1
a2520 1
next_perspective()
d2533 4
a2536 1
  /* just in case the "!" is used with the set command */
d3095 1
a3095 1
	if( !strcmp( argv[0], "mouse")){
@


11.15
log
@Just cleaning up some of my mess.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.14 1995/11/28 21:26:47 bparker Exp bparker $ (BRL)";
d79 3
a81 3
static int devmotionnotify;
static int devbuttonpress;
static int devbuttonrelease;
d510 1
d515 65
d581 5
d587 1
d589 1
d621 1
a621 1
#if 0
d631 4
a674 5
#if 0
	Tk_CreateEventHandler(xtkwin, ExposureMask|PointerMotionMask|
			      StructureNotifyMask,
			      (void (*)())Ircheckevents, (ClientData)NULL);
#else
d676 2
a677 1
#endif
a678 4
	/* Line style 0 is solid.  Program line style 1 as dot-dashed */
	deflinestyle( 1, 0xCF33 );
	setlinestyle( 0 );

a1585 1
#if 1
a1587 1
#endif
d1597 4
a1600 3
if(focus && eventPtr->type == KeyPress){
  char buffer[1];
  int status;
d1602 2
a1603 2
  XLookupString(&(eventPtr->xkey), buffer, 1,
		(KeySym *)NULL, (XComposeStatus *)NULL);
d1605 3
a1607 2
#if TRY_PIPES
  write(ged_pipe[1], buffer, 1);
a1609 3
  return TCL_ERROR;
}

d2184 19
d2221 1
d2226 1
a2226 1
#endif
@


11.14
log
@added focus to the dm set command
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.13 1995/11/27 21:57:22 bparker Exp bparker $ (BRL)";
d51 1
a100 1
#define TRY_PIPES 1
a474 292

#if 0
#ifdef DM_OGL
	/* This is a hack to handle the fact that the sgi attach crashes
	 * if a direct OpenGL context has been previously opened in the 
	 * current mged session. This stops the attach before it crashes.
	 */
	ogl_sgi_used = 1;
	if (ogl_ogl_used){
		rt_log("Can't attach sgi, because a direct OpenGL context has\n");
		rt_log("previously been opened in this session. To use sgi,\n");
		rt_log("quit this session and reopen it.\n");
		return(-1);
	}
#endif /* DM_OGL */
	/*
	 *  Take inventory of the hardware.
	 *  See "types for class graphics" in /usr/include/sys/invent.h
	 */
	while( (inv = getinvent()) != (inventory_t *)0 )  {
		if( inv->class != INV_GRAPHICS )  continue;
		switch( inv->type )  {
		default:
#if 0
			rt_log("mged/dm-4d.c: getinvent() INV_GRAPHICS type=%d not recognized, you need to modify the source code\n",
			    inv->type);
#endif
			/* Since we recognize all the old devices, be
			 * optimistic and assume that new devices are plush.
			 * Or at least that GL can simulate everything adequately.
			 */
			ir_is_gt = 1;
			ir_has_zbuf = 1;
			ir_has_rgb = 1;
			ir_has_doublebuffer = 1;
			break;
		case INV_GRODEV:			 /* 4D/60 machines */
			ir_has_doublebuffer = 1;
			if( inv->state & INV_GR1ZBUF24 )
				ir_has_zbuf = 1;
			break;
		case INV_VGX:
		case INV_VGXT:			/* VGX Turbo and SkyWriter */
		case INV_GMDEV:			/* GT graphics */
		case INV_CG2:
			ir_is_gt = 1;
			ir_has_zbuf = 1;
			ir_has_rgb = 1;
			ir_has_doublebuffer = 1;
			break;
		case INV_GR1BP:
			ir_has_rgb = 1;
			break;
		case INV_GR1ZBUFFER:
			ir_has_zbuf = 1;
			break;
		case INV_GR1BOARD:	/* Persoanl Iris */
			if ( inv->state & INV_GR1RE2 )
				ir_is_gt = 1;
			if(inv->state & INV_GR1ZBUF24 )
				ir_has_zbuf = 1;
			if(inv->state & INV_GR1BIT24 )
				ir_has_rgb = 1;
			ir_has_doublebuffer = 1;
			break;
#if defined(INV_LIGHT)
		case INV_LIGHT:		/* Entry Level Indigo */
			ir_is_gt = 0;
			ir_has_zbuf = 1;
			ir_has_doublebuffer = 0;
			ir_has_rgb = 1;
			break;
#endif

#if defined(INV_GR2)
		case INV_GR2:		/* Elan EXPRESS Graphics */
			/* if(inv->state & INV_GR2_ELAN) */
			/* Just let GL simulate it */
			ir_has_rgb = 1;
			ir_has_doublebuffer = 1;
			ir_has_zbuf = 1;
			ir_is_gt = 1;
			/* if(inv->state & INV_GR2_EXTREME) */
			break;
#endif
#if defined(INV_NEWPORT)
		case INV_NEWPORT:
			/* if(inv->state & INV_NEWPORT_XL) */
			/* Just let GL simulate it */
			ir_has_rgb = 1;
			ir_has_doublebuffer = 1;
			ir_has_zbuf = 1;
			ir_is_gt = 1;
#			if 0
				if(inv->state & INV_NEWPORT_24)
					ir_has_rgb = 1;
#			endif
			break;
#endif
		}
	}
	endinvent();		/* frees internal inventory memory */
#if 0
	rt_log("4D: gt=%d, zbuf=%d, rgb=%d\n", ir_is_gt, ir_has_zbuf, ir_has_rgb);
#endif

	/* Start out with the usual window */
	foreground();
#if 1
	if (mged_variables.sgi_win_size > 0)
		win_size = mged_variables.sgi_win_size;

	if (mged_variables.sgi_win_origin[0] != 0)
		win_o_x = mged_variables.sgi_win_origin[0];

	if (mged_variables.sgi_win_origin[1] != 0)
		win_o_y = mged_variables.sgi_win_origin[1];

	prefposition( win_o_x, win_o_x+win_size, win_o_y, win_o_y+win_size);
#else
	prefposition( 376, 1276, 12, 912 );		/* Old, larger size */
	prefposition( 376, 376+900, 112, 112+900 );	/* new, smaller size */
#endif
	if( (gr_id = winopen( "BRL MGED" )) == -1 )  {
		rt_log( "No more graphics ports available.\n" );
		return	-1;
	}
	keepaspect(1,1);	/* enforce 1:1 aspect ratio */
	winconstraints();	/* remove constraints on the window size */

	ir_oldmonitor = getmonitor();
	if( mged_variables.eye_sep_dist )  {
		if( sgi_has_stereo() )  {
			setmonitor(STR_RECT);
			stereo_is_on = 1;
		} else {
			rt_log("NOTICE: This SGI does not have stereo display capability\n");
			stereo_is_on = 0;
		}
	}

	/*
	 *  If monitor is in special mode, close window and re-open.
	 *  winconstraints() does not work, and getmonitor() can't
	 *  be called before a window is open.
	 */
	switch( getmonitor() )  {
	case HZ30:
	case HZ30_SG:
		/* Dunn camera, etc. */
		/* Use already established prefposition */
		break;
	case STR_RECT:
		/* Hi-res monitor in stereo mode, take over whole screen */
		winclose(gr_id);
		noborder();
		foreground();
#if defined(__sgi) && defined(__mips)
		/* Deal with Irix 4.0 bug:  (+2,+0) offset due to border */
		prefposition( 0-2, XMAXSCREEN-2, 0, YMAXSCREEN );
#else
		prefposition( 0, XMAXSCREEN, 0, YMAXSCREEN );
#endif
		if( (gr_id = winopen( "BRL MGED" )) == -1 )  {
			rt_log( "No more graphics ports available.\n" );
			return	-1;
		}
		break;
	default:
	case HZ60:
		/* Regular hi-res monitor */
		/* Use already established prefposition */
		break;
	case NTSC:
		/* Television */
		winclose(gr_id);
		prefposition( 0, XMAX170, 0, YMAX170 );
		foreground();
		if( (gr_id = winopen( "BRL MGED" )) == -1 )  {
			rt_log( "No more graphics ports available.\n" );
			return	-1;
		}
		break;
	case PAL:
		/* Television */
		winclose(gr_id);
		prefposition( 0, XMAXPAL, 0, YMAXPAL );
		foreground();
		if( (gr_id = winopen( "BRL MGED" )) == -1 )  {
			rt_log( "No more graphics ports available.\n" );
			return	-1;
		}
		break;
	}

	/*
	 *  Configure the operating mode of the pixels in this window.
	 *  Do not output graphics, clear screen, etc, until *after*
	 *  the call to gconfig().
	 */
	if( ir_has_rgb )  {
		RGBmode();
	} else {
		/* one indexed color map of 4096 entries */
		onemap();
	}
	if ( ir_has_doublebuffer)
		doublebuffer();

	gconfig();

	/*
	 * Establish GL library operating modes
	 */
	/* Don't draw polygon edges */
	glcompat( GLC_OLDPOLYGON, 0 );

	/* Z-range mapping */
	/* Z range from getgdesc(GD_ZMIN)
	 * to getgdesc(GD_ZMAX).
	 * Hardware specific.
	 */
	glcompat( GLC_ZRANGEMAP, 0 );
	/* Take off a smidgeon for wraparound, as suggested by SGI manual */
	min_scr_z = getgdesc(GD_ZMIN)+15;
	max_scr_z = getgdesc(GD_ZMAX)-15;

	Ir_configure_window_shape();

	/* Enable qdev() input from various devices */
	qdevice(LEFTMOUSE);
	qdevice(MIDDLEMOUSE);
	qdevice(RIGHTMOUSE);
	tie(LEFTMOUSE, MOUSEX, MOUSEY);
	tie(MIDDLEMOUSE, MOUSEX, MOUSEY);
	tie(RIGHTMOUSE, MOUSEX, MOUSEY);

#if IR_KNOBS
	/*
	 *  Turn on the dials and initialize them for -2048 to 2047
	 *  range with a dead spot at zero (Iris knobs are 1024 units
	 *  per rotation).
	 */
	for(i = DIAL0; i < DIAL8; i++)
		setvaluator(i, 0, -2048-NOISE, 2047+NOISE);
	for(i = DIAL0; i < DIAL8; i++)
		qdevice(i);
#endif
#if IR_BUTTONS
	/*
	 *  Enable all the buttons in the button table.
	 */
	for(i = 0; i < IR_BUTTONS; i++)
		qdevice(i+SWBASE);
	/*
	 *  For all possible button presses, build a table
	 *  of MGED function to SGI button/light mappings.
	 */
	for( i=0; i < IR_BUTTONS; i++ )  {
		register int j;
		if( (j = bmap[i]) != 0 )
			invbmap[j] = i;
	}
# if 0
	ir_dbtext(ir_title);
# else
	dbtext("");
# endif
#endif

	qdevice(F1KEY);	/* pf1 key for depthcue switching */
	qdevice(F2KEY);	/* pf2 for Z clipping */
	qdevice(F3KEY);	/* pf3 for perspective */
	qdevice(F4KEY);	/* pf4 for Z buffering */
	qdevice(F5KEY);	/* pf5 for lighting */
	qdevice(F6KEY);	/* pf6 for changing perspective */
	qdevice(F7KEY);	/* pf7 for no faceplate */
	qdevice(F12KEY);/* pf12 to zero knobs */
	while( getbutton(LEFTMOUSE)||getbutton(MIDDLEMOUSE)||getbutton(RIGHTMOUSE) )  {
		rt_log("IRIS_open:  mouse button stuck\n");
		sleep(1);
	}

	/* Line style 0 is solid.  Program line style 1 as dot-dashed */
	deflinestyle( 1, 0xCF33 );
	setlinestyle( 0 );

	ir_fd = qgetfd();

	Tk_CreateFileHandler(ir_fd, 1, Ircheckevents, (void *)NULL);
	return(0);
#else
a610 1
#endif
d951 3
a956 3
#if MIXED_MODE
	Tk_DestroyWindow(xtkwin);
#else
@


11.13
log
@added perspective and next_perspective to the dm command.
fixed the "knob zero" button.
added the help for the dials+buttons.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.12 1995/11/22 17:57:49 bparker Exp bparker $ (BRL)";
d82 1
d100 1
d104 3
a125 1
int    Ircheckevents();
d127 5
d146 3
a162 2
static int dummy_perspective = 1;
static int perspective_mode = 0;	/* Perspective flag */
d273 1
d1817 1
a1817 1
  rt_log("%d\t%d\tevent type - %d\tcount - %d\n",
d1820 1
a1820 1
  rt_log("%d\t%d\tevent type - %d\n",
d1823 13
a3322 2


@


11.12
log
@no longer using getsize and getorigin in Ir_configure_window_shape
when MIXED_MODE. Using XGetWindowAttributes instead.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.11 1995/11/22 17:17:09 bparker Exp bparker $ (BRL)";
d49 1
d80 1
d151 1
d245 2
d261 2
d860 2
d1777 6
d1789 4
a1836 3
    if (eventPtr->xany.window != win)
      return TCL_OK;

d1845 6
a1850 1
    if (eventPtr->xany.window != win)
d1852 4
a1855 3

    M = (XDeviceMotionEvent * ) eventPtr;
    setting = irlimit(M->axis_data[0]);
d1866 1
a1866 1
		    setting/2048.0 );
d1874 1
a1874 1
		      setting/2048.0 );
d1882 1
a1882 1
		      setting/2048.0 );
d1890 1
a1890 1
		      setting/2048.0 );
d1894 1
a1894 1
		    setting/2048.0 );
d1902 1
a1902 1
		      setting/2048.0 );
d1906 1
a1906 1
		    setting/2048.0 );
d1915 4
a1918 1
    if (eventPtr->xany.window != win)
d1920 23
d1946 4
a1949 7
/* Temporary */
    if(B->button == 4)
          rt_vls_strcat(&dm_values.dv_string, "knob zero\n");
    else
      rt_vls_printf(&dm_values.dv_string, "press %s\n",
		 label_button(bmap[B->button - 1]));
  }
d1951 4
a1954 10
#if 0
/*XXX hack */
  while( XPending( dpy ) > 0){
    XNextEvent( dpy, &event );
    if( event.type == devmotionnotify)
      rt_log("Ircheckevents: got a devmotionnotify event\n");
    else if( event.type == devbuttonpress)
      rt_log("Ircheckevents: got a devbuttonpress event\n");
    else
      rt_log("Ircheckevents: got an event of type %d\n", event.type);
a1955 1
#endif
d2685 36
@


11.11
log
@added support for dials+buttons when compiled in MIXED_MODE
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.10 1995/11/20 21:33:26 bparker Exp bparker $ (BRL)";
d329 3
d337 5
d347 1
a347 1

d1776 3
a1778 2
i.e. drawing atleast 2 times when resizing the window to a larger size.
once for the Configure and once for the expose */
@


11.10
log
@Experiment is partially done. The idea is to add
the use of the glx widget. Since we're now getting
X events we have to make special requests in order to
get the dials and buttons. Thats next.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.9 1995/11/02 18:30:38 cjohnson Exp bparker $ (BRL)";
d77 3
a79 1
#else
a81 1
#endif
a741 1
	int count;
d743 8
d756 1
a756 1

d769 3
a772 2
	Tk_MapWindow(xtkwin);
#if 0
d774 2
a775 2
#endif
	
d824 39
d866 3
d882 1
a882 1
  if(Tcl_EvalFile(interp, "../mged/glxinit.tk") == TCL_ERROR){
d1765 21
d1787 1
a1787 2
  if((eventPtr->type == Expose && eventPtr->xexpose.count == 0) ||
      eventPtr->type == ConfigureNotify){
d1790 1
d1793 1
a1793 1
       refresh();
d1795 11
d1809 3
d1816 79
d1896 13
@


11.9
log
@Make open GL code conditional on DM_OGL #define
@
text
@d2 23
d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.8 1995/08/24 06:24:34 mike Exp cjohnson $ (BRL)";
d49 2
d64 14
d80 1
d117 4
d122 1
d284 3
d289 1
d293 2
d302 3
d307 1
d312 2
d335 1
d355 2
d413 1
d438 400
d1138 1
d1168 3
d1172 1
d1645 3
d1704 3
d1708 25
a1732 1
	return;
d1734 1
d2091 1
d2161 2
d2184 1
d2407 2
d2439 1
d2969 1
d2994 43
@


11.8
log
@Allow fully flexible bindings for left and right mouse clicks.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.7 1995/08/23 23:05:02 cnuzman Exp mike $ (BRL)";
d387 1
d399 1
@


11.7
log
@hacked around bug which causes mged to crash when sgi and ogl are used
in the same session
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.6 1995/07/20 13:37:47 gdurf Exp cnuzman $ (BRL)";
d616 1
d618 1
d1250 2
a1251 1
	static	pending_middleval = 0;
d1525 2
a1526 2
			if( valp[1] )
				rt_vls_strcat( &dm_values.dv_string, "zoom 0.5\n");
d1529 2
a1530 2
			if( valp[1] )
				rt_vls_strcat( &dm_values.dv_string, "zoom 2\n");
d1533 3
a1535 2
			/* Will also get MOUSEX and MOUSEY hits */
			pending_middleval = (int)valp[1] ? 1 : 0;
d1553 1
a1553 1
			 *  instead, the flag pending_middleval flag is set,
d1558 1
a1558 1
			 *  illuminate mode;  in those cases, pending_middleval
d1562 3
a1564 2
			rt_vls_printf( &dm_values.dv_string, "M %d %d %d\n",
			    pending_middleval,
d1566 2
a1567 1
			pending_middleval = 0;
@


11.6
log
@Removed extra qtest
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.5 1995/07/06 13:31:45 gdurf Exp gdurf $ (BRL)";
d285 2
a286 1

d387 11
d686 8
@


11.5
log
@Fixed set commands
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.4 1995/07/05 21:22:32 gdurf Exp gdurf $ (BRL)";
d1232 1
d1235 1
a1235 1

@


11.4
log
@Tk changes
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.3 1995/06/16 19:47:36 gdurf Exp gdurf $ (BRL)";
d1315 1
a1315 1
				    "dm set depthcue=!\n");
d1326 1
a1326 1
				    "dm set zclip=!\n");
d1352 1
a1352 1
				    "dm set zbuffer=!\n");
d1363 1
a1363 1
				    "dm set lighting=!\n");
@


11.3
log
@Changed set command to match new style
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.2 1995/06/15 20:35:56 gdurf Exp gdurf $ (BRL)";
d77 1
d658 1
d1210 1
a1210 1
		checkevents();
d1219 2
a1220 1
checkevents()  {
d1231 3
@


11.2
log
@Changed set command
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.1 1995/01/04 10:02:51 mike Rel4_4 gdurf $ (BRL)";
d1384 2
a1385 2
				    "set faceplate=0\n" :
				    "set faceplate=1\n" );
d2435 1
a2435 1
		return -1;
d2443 7
a2449 2
	} else {
		rt_vls_from_argv( &vls, argc-1, argv+1 );
d2453 1
a2453 1
	return 0;
d2455 2
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.53 94/12/27 23:08:10 mike Exp $ (BRL)";
d1331 1
a1331 1
				    "set perspective=%d\n",
d1369 1
a1369 1
				    "set perspective=%d\n",
@


10.53
log
@Device "0" events are now showing up, since adding the qgetfd() call.
Just ignore them.
Most regrettable.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.52 94/12/27 17:41:35 mike Exp Locker: mike $ (BRL)";
@


10.52
log
@GL *does* have a file descriptor we can select() on!
qgetfd().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.52 94/12/27 17:38:17 mike Exp $ (BRL)";
d1549 3
@


10.51
log
@Eliminated old dm_values.dv_* style "polled" device interface.
Everything is done by string commands now.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.50 94/12/23 23:14:34 mike Exp Locker: mike $ (BRL)";
d100 2
a101 2

static char ir_title[] = "BRL MGED";
d655 2
d1158 1
a1158 1
	/* FD_SET( gl_fd, &files ); */
d1178 1
d1207 1
a1207 1
	if( i != 0 )
@


10.50
log
@Added F12 as rotation zap key.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.49 94/12/23 19:35:06 mike Exp Locker: mike $ (BRL)";
a1202 3
	dm_values.dv_buttonpress = 0;
	dm_values.dv_flagadc = 0;
	dm_values.dv_penpress = 0;
@


10.49
log
@Added per-vertex normal support, for "ev -v".
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.48 94/12/23 17:17:35 gdurf Exp Locker: mike $ (BRL)";
d645 1
d1237 1
a1237 3
		    || ret == F1KEY || ret == F2KEY || ret == F3KEY
		    || ret == F4KEY || ret == F5KEY || ret == F6KEY
		    || ret == F7KEY
d1277 1
a1277 1
			if(ret == SW_ZERO_KEY)  {
d1292 2
@


10.48
log
@Removed superfluous fflush
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.47 94/12/16 17:55:46 gdurf Exp Locker: gdurf $ (BRL)";
d1030 5
@


10.47
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.46 1994/12/12 22:58:49 mike Exp gdurf $ (BRL)";
a2433 1
		fflush(stdout);
@


10.46
log
@Fixed the NEWPORT support.
Changed to assume that all recent versions of GL can emulate
everything we need.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.45 94/10/14 16:06:09 mike Exp Locker: mike $ (BRL)";
d394 1
a394 1
			printf("mged/dm-4d.c: getinvent() INV_GRAPHICS type=%d not recognized, you need to modify the source code\n",
d473 1
a473 1
	printf("4D: gt=%d, zbuf=%d, rgb=%d\n", ir_is_gt, ir_has_zbuf, ir_has_rgb);
d494 1
a494 1
		printf( "No more graphics ports available.\n" );
d506 1
a506 1
			printf("NOTICE: This SGI does not have stereo display capability\n");
d534 1
a534 1
			printf( "No more graphics ports available.\n" );
d549 1
a549 1
			printf( "No more graphics ports available.\n" );
d559 1
a559 1
			printf( "No more graphics ports available.\n" );
d646 1
a646 1
		printf("IRIS_open:  mouse button stuck\n");
d693 1
a693 1
		fprintf(stderr, "Ir_prolog\n");
d719 1
a719 1
		fprintf(stderr, "Ir_normal\n");
d741 1
a741 1
		fprintf(stderr, "Ir_epilog\n");
d793 1
a793 1
		fprintf(stderr, "Ir_newrot()\n");
d897 1
a897 1
		fprintf(stderr, "Ir_Object()\n");
d1052 1
a1052 1
		fprintf(stderr, "Ir_update()\n");
d1069 1
a1069 1
		fprintf(stderr, "Ir_puts()\n");
d1094 1
a1094 1
		fprintf(stderr, "Ir_2d_line()\n");
d1146 1
a1146 1
		fprintf(stderr, "Ir_input()\n");
d1224 1
a1224 1
	if( ir_debug ) printf("blkqread gave %d\n", n);
d1228 1
a1228 1
		if( ir_debug ) printf("qread ret=%d, val=%d\n", ret, valp[1]);
d1545 1
a1545 1
			printf("IRIS device %d gave %d?\n", ret, valp[1]);
d1613 1
a1613 1
	if( ir_debug ) printf("statechange %d %d\n", a, b );
d1637 1
a1637 1
		(void)printf("Ir_statechange: unknown state %s\n", state_str[b]);
d1648 1
a1648 1
	if( ir_debug ) printf("viewchange( %d, x%x )\n", cmd, sp );
d1689 1
a1689 1
	if( ir_debug )  printf("colorchange\n");
d1724 1
a1724 1
		printf("Too few bitplanes: depthcueing disabled\n");
d1822 1
a1822 1
	printf("dm-4d: You pressed Help key and '%s'\n", str);
d1917 1
a1917 1
		printf("dm-4d: This machine has no Zbuffer to enable\n");
d1953 1
a1953 1
	printf("usinit\n"); 
d1956 1
a1956 1
	printf("usnewlock\n"); 
d1959 1
a1959 1
	printf("taskcreate\n"); 
d2425 1
a2425 1
		printf("dm: command is not 'set'\n");
d2433 1
a2433 1
		printf("%s", rt_vls_addr(&vls) );
@


10.45
log
@Changed from getdtablesize() to sysconf(_SC_OPEN_MAX)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.44 94/09/21 21:46:53 mike Exp Locker: mike $ (BRL)";
d386 2
a387 1
	 *  Take inventory of the hardware
d393 1
d396 1
d399 1
d445 8
a452 8
		case INV_GR2:		/* Elan Graphics */
			if(inv->state & INV_GR2_ELAN)
			{
				ir_has_rgb = 1;
				ir_has_doublebuffer = 1;
				ir_has_zbuf = 1;
				ir_is_gt = 1;
			}
d455 4
a458 5
		}
#if defined(NEWPORT)
	case NEWPORT:		/* Elan Graphics */
		if(inv->state & INV_NEWPORT)
		{
d463 6
a469 2
		break;
#endif
@


10.44
log
@Removed duplicate #define, now found in h/conf.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.43 94/09/06 14:21:21 jra Exp Locker: mike $ (BRL)";
d1140 1
a1140 1
	if( (width = getdtablesize()) <= 0 )
@


10.43
log
@Finished conversion to use rt_vls_printf( &dm_values.dv_string rather than setting values.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.42 94/08/31 20:24:34 stay Exp Locker: jra $ (BRL)";
a33 1
#define _BSD_TYPES		/* Needed for IRIX 5.0.1 */
@


10.42
log
@cleaned up the code to get rid of some
extra (or lacking) tabs (I ran it through cb)
and fixed the lighting model and added color for
the objects using the lighting model
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.41 94/08/10 21:42:13 mike Exp $ (BRL)";
d1429 2
a1430 2
					dm_values.dv_1adc = setting;
					dm_values.dv_flagadc =1;
d1434 2
a1435 1
				dm_values.dv_zoom = setting / 2048.0;
d1438 6
a1443 6
				if(adcflag) {
					dm_values.dv_2adc = setting;
					dm_values.dv_flagadc =1;
				} else {
					dm_values.dv_zjoy = setting/2048.0;
				}
d1446 6
a1451 5
				if(adcflag) {
					dm_values.dv_distadc = setting;
					dm_values.dv_flagadc =1;
				}
				else dm_values.dv_zslew = setting/2048.0;
d1454 6
a1459 6
				if(adcflag) {
					dm_values.dv_yadc = setting;
					dm_values.dv_flagadc =1;
				} else {
					dm_values.dv_yjoy = setting/2048.0;
				}
d1462 2
a1463 1
				dm_values.dv_yslew = setting/2048.0;
d1466 6
a1471 6
				if(adcflag) {
					dm_values.dv_xadc = setting;
					dm_values.dv_flagadc =1;
				} else {
					dm_values.dv_xjoy = setting/2048.0;
				}
d1474 2
a1475 1
				dm_values.dv_xslew = setting/2048.0;
@


10.41
log
@Changed calling sequence to dmr_input(), to pass an fd_set rather
than a single file descriptor.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.40 1994/08/09 15:12:09 gdurf Exp $ (BRL)";
d105 2
a106 1
static int perspective_table[] = { 30, 45, 60, 90 };
d126 6
a131 6
             HELP_KEY,    BV_ADCURSOR, BV_RESET,    ZERO_KNOBS,
BE_O_SCALE,  BE_O_XSCALE, BE_O_YSCALE, BE_O_ZSCALE, 0,           BV_VSAVE,
BE_O_X,      BE_O_Y,      BE_O_XY,     BE_O_ROTATE, 0,           BV_VRESTORE,
BE_S_TRANS,  BE_S_ROTATE, BE_S_SCALE,  BE_MENU,     BE_O_ILLUMINATE, BE_S_ILLUMINATE,
BE_REJECT,   BV_BOTTOM,   BV_TOP,      BV_REAR,     BV_45_45,    BE_ACCEPT,
             BV_RIGHT,    BV_FRONT,    BV_LEFT,     BV_35_25
d221 1
d295 1
a295 1
	
d314 12
a325 12
/*
 * XXX Does this viewport() call do anything?  (Write enable pixels maybe?)
 * XXX (1) the first frame (only) is shrunken oddly in X, and
 * XXX (2) the drawing overflows the boundaries.
 * XXX Perhaps XY clipping could be used?
 * At least the aspect ratio is right!
 */
/* XXXXX See page 8-9 in the manual.
 * XXX The best way to do the masking in NTSC mode is to
 * XXX just set a Z-buffer write mask of 0 on the parts we don't
 * XXX want to have written.
 */
d327 1
a327 1
				(YMAX170-npix)/2, npix + (YMAX170-npix)/2 );
d342 2
a343 1
		win_r = win_l + winx_size;;
d347 1
a347 1
			(YMAXPAL-npix)/2, npix + (YMAXPAL-npix)/2 );
d393 2
a394 1
			printf("mged/dm-4d.c: getinvent() INV_GRAPHICS type=%d not recognized, you need to modify the source code\n",inv->type);
d442 9
a450 9
                case INV_GR2:		/* Elan Graphics */
                        if(inv->state & INV_GR2_ELAN)
                        {
                                ir_has_rgb = 1;
                                ir_has_doublebuffer = 1;
                                ir_has_zbuf = 1;
                                ir_is_gt = 1;
                        }
                        break;
d454 9
a462 9
                case NEWPORT:		/* Elan Graphics */
                        if(inv->state & INV_NEWPORT)
                        {
                                ir_has_rgb = 1;
                                ir_has_doublebuffer = 1;
                                ir_has_zbuf = 1;
                                ir_is_gt = 1;
                        }
                        break;
d477 1
a477 1
	    	win_o_x = mged_variables.sgi_win_origin[0];
d480 1
a480 1
	    	win_o_y = mged_variables.sgi_win_origin[1];
d856 9
d888 1
a888 1
	int i,j;	
a891 10
	/* It seems that this needs to be done before the loadmatrix() */
	if( ir_is_gt && lighting_on )  {
		/* Separate projection matrix from
		 * modeling and viewing xforms.
		 */
		mmode(MVIEWING);
		/* Select the material */
		lmbind(MATERIAL, 20);
		Ir_newrot(m);
	}
d925 29
a953 5
				r/10, g/10, b/10,
				r, g, b,
				min_scr_z, max_scr_z );
		}
		RGBcolor( r, g, b );
d960 1
a960 1
					min_scr_z, max_scr_z );
d970 1
a970 1
			  	if(cueing_on)  {
d972 2
a973 2
			  			min_scr_z, max_scr_z );
			  	}
d975 2
a976 2
			  	ovec = nvec;
			  }
a1028 4
	if( lighting_on )  {
		/* Return to no-lighting mode */
		mmode(MSINGLE);
	}
d1067 2
a1068 2
			(short)ir_rgbtab[colour].g,
			(short)ir_rgbtab[colour].b );
d1093 3
a1095 3
				255, 255, 0,
				255, 255, 0,
				min_scr_z, max_scr_z );
d1100 2
a1101 2
		  	if(cueing_on) lshaderange(nvec, nvec,
				min_scr_z, max_scr_z );
d1103 1
a1103 1
		  	ovec = nvec;
d1171 1
a1171 1
		}  else  {
d1225 4
a1228 4
		  || ret == F1KEY || ret == F2KEY || ret == F3KEY
		  || ret == F4KEY || ret == F5KEY || ret == F6KEY
		  || ret == F7KEY
		) {
d1248 2
a1249 2
						 knobs[i] =
						   getvaluator(DIAL0+i);
d1251 1
a1251 1
						-2048-NOISE, 2047+NOISE);
d1256 2
a1257 2
				else
					ir_dbtext(ir_title);
d1259 2
a1260 2
				continue;
				
d1278 1
a1278 1
					  -2048-NOISE, 2047+NOISE);
d1297 1
a1297 1
					"dm set depthcue=!\n");
d1308 1
a1308 1
					"dm set zclip=!\n");
d1319 4
a1322 4
					"set perspective=%d\n",
					perspective_mode ?
						perspective_table[perspective_angle] :
						-1 );
d1334 1
a1334 1
					"dm set zbuffer=!\n");
d1345 1
a1345 1
					"dm set lighting=!\n");
d1357 2
a1358 2
					"set perspective=%d\n",
					perspective_table[perspective_angle] );
d1371 3
a1373 3
					no_faceplate ?
					"set faceplate=0\n" :
					"set faceplate=1\n" );
d1390 1
a1390 1
				 ir_dbtext(label_button(i));
d1394 2
a1395 2
					/* old way -- an illegal upcall */
					button(i);
d1397 7
a1403 7
					/* better way -- queue a string command */
					rt_vls_strcat( &dm_values.dv_string,
						"press " );
					rt_vls_strcat( &dm_values.dv_string,
						label_button(i) );
					rt_vls_strcat( &dm_values.dv_string,
						"\n" );
d1417 1
a1417 1
			int	setting;	
d1421 1
a1421 1
		(adcflag ? kn1_knobs:kn2_knobs)[ret-DIAL0]);
d1516 2
a1517 2
				pending_middleval,
				pending_x, pending_y);
d1525 1
a1525 1
				refresh();		
d1614 1
a1614 1
		
d1682 12
a1693 4
	ir_rgbtab[0].r=0; ir_rgbtab[0].g=0; ir_rgbtab[0].b=0;/* Black */
	ir_rgbtab[1].r=255; ir_rgbtab[1].g=0; ir_rgbtab[1].b=0;/* Red */
	ir_rgbtab[2].r=0; ir_rgbtab[2].g=0; ir_rgbtab[2].b=255;/* Blue */
	ir_rgbtab[3].r=255; ir_rgbtab[3].g=255;ir_rgbtab[3].b=0;/*Yellow */
d1759 1
a1759 1
		    	sp->s_dmindex = DM_WHITE;
d1782 2
a1783 1
next:		;
d1797 1
a1797 1
 
d1799 1
a1799 1
	register char *str;
d1802 1
a1802 1
  	register i;
d1829 1
a1829 1
	int i;
d1853 1
a1853 1
		
d1872 1
a1872 1
			  i--, red -= r_inc, green -= g_inc, blue -= b_inc)
d1874 3
a1876 3
					(short)red,
					(short)green,
					(short)blue );
d1880 1
a1880 1
			ir_rgbtab[c].r, ir_rgbtab[c].g, ir_rgbtab[c].b);
d1894 3
a1896 3
		| (zclipping_on << 1)
		| (perspective_mode << 2)
		| (zbuffer_on << 3);
d1942 9
a1950 3
usinit()	{ printf("usinit\n"); }
usnewlock()	{ printf("usnewlock\n"); }
taskcreate()	{ printf("taskcreate\n"); }
d1973 8
a1980 5
			mmode(MVIEWING);
		/* Define material properties */
		make_materials();
			lmbind(LMODEL, 2);	/* infinite */
			lmbind(LIGHT2,2);
d1986 1
a1986 12
#if 1
		/* Good for debugging */
		/* Material color does not apply,
		 * when lighting is on */
		lmcolor( LMC_COLOR );	/* default */
#else
		/* Good for looking.
		 * RGBcolor() values go to emissions
		 * durring lighting calculations.
		 */
		lmcolor( LMC_EMISSION );
#endif
d2007 7
a2013 7
			ALPHA,		1.0,
			AMBIENT,	0.2, 0.2, 0.2,
			DIFFUSE,	0.8, 0.8, 0.8,
			EMISSION,	0.0, 0.0, 0.0,
			SHININESS,	0.0,
			SPECULAR,	0.0, 0.0, 0.0,
			LMNULL   };
d2017 7
a2023 7
			ALPHA,		1.0,	
			AMBIENT,	0.2, 0.2, 0.2,	/* 0.4 in rt */
			DIFFUSE,	0.6, 0.6, 0.6,
			SPECULAR,	0.2, 0.2, 0.2,
			EMISSION,	0.0, 0.0, 0.0,
			SHININESS,	10.0,
			LMNULL   };
d2026 76
a2101 65
static float material_xdefault[] = {AMBIENT, 0.35, 0.25,  0.1,
			DIFFUSE, 0.1, 0.5, 0.1,
			SPECULAR, 0.0, 0.0, 0.0,
			SHININESS, 5.0,
			LMNULL   };

static float mat_brass[] = {AMBIENT, 0.35, 0.25,  0.1,
			DIFFUSE, 0.65, 0.5, 0.35,
			SPECULAR, 0.0, 0.0, 0.0,
			SHININESS, 5.0,
			LMNULL   };

static float mat_shinybrass[] = {AMBIENT, 0.25, 0.15, 0.0,
			DIFFUSE, 0.65, 0.5, 0.35,
			SPECULAR, 0.9, 0.6, 0.0,
			SHININESS, 10.0,
			LMNULL   };

static float mat_pewter[] = {AMBIENT, 0.0, 0.0,  0.0,
			DIFFUSE, 0.6, 0.55 , 0.65,
			SPECULAR, 0.9, 0.9, 0.95,
			SHININESS, 10.0,
			LMNULL   };

static float mat_silver[] = {AMBIENT, 0.4, 0.4,  0.4,
			DIFFUSE, 0.3, 0.3, 0.3,
			SPECULAR, 0.9, 0.9, 0.95,
			SHININESS, 30.0,
			LMNULL   };

static float mat_gold[] = {AMBIENT, 0.4, 0.2, 0.0,
			DIFFUSE, 0.9, 0.5, 0.0,
			SPECULAR, 0.7, 0.7, 0.0,
			SHININESS, 10.0,
			LMNULL   };

static float mat_shinygold[] = {AMBIENT, 0.4, 0.2,  0.0,
			DIFFUSE, 0.9, 0.5, 0.0,
			SPECULAR, 0.9, 0.9, 0.0,
			SHININESS, 20.0,
			LMNULL   };

static float mat_plaster[] = {AMBIENT, 0.2, 0.2,  0.2,
			DIFFUSE, 0.95, 0.95, 0.95,
			SPECULAR, 0.0, 0.0, 0.0,
			SHININESS, 1.0,
			LMNULL   };

static float mat_redplastic[] = {AMBIENT, 0.3, 0.1, 0.1,
			DIFFUSE, 0.5, 0.1, 0.1,
			SPECULAR, 0.45, 0.45, 0.45,
			SHININESS, 30.0,
			LMNULL   };

static float mat_greenplastic[] = {AMBIENT, 0.1, 0.3, 0.1,
			DIFFUSE, 0.1, 0.5, 0.1,
			SPECULAR, 0.45, 0.45, 0.45,
			SHININESS, 30.0,
			LMNULL   };

static float mat_blueplastic[] = {AMBIENT, 0.1, 0.1, 0.3,
			DIFFUSE, 0.1, 0.1, 0.5,
			SPECULAR, 0.45, 0.45, 0.45,
			SHININESS, 30.0,
			LMNULL   };
d2104 7
a2110 7
			EMISSION,   0.0, 0.4, 0.0,
			AMBIENT,    0.0, 0.0, 0.0,
			DIFFUSE,    0.0, 0.0, 0.0,
			SPECULAR,   0.0, 0.6, 0.0,
			SHININESS, 10.0,
			LMNULL
			};
d2113 7
a2119 7
			EMISSION, 0.0, 0.4, 0.0,
			AMBIENT,  0.1, 0.25, 0.1,
			DIFFUSE,  0.5, 0.5, 0.5,
			SPECULAR,  0.25, 0.9, 0.25,
			SHININESS, 10.0,
			LMNULL
			};
d2122 7
a2128 7
		       EMISSION, 0.0, 0.0, 0.4,
		       AMBIENT,  0.1, 0.25, 0.1,
		       DIFFUSE,  0.0, 0.5, 0.5,
		       SPECULAR,  0.0, 0.0, 0.9,
		       SHININESS, 10.0,
		       LMNULL
		       };
d2131 7
a2137 7
			EMISSION, 0.0, 0.0, 0.6,
			AMBIENT,  0.1, 0.25, 0.5,
			DIFFUSE,  0.5, 0.5, 0.5,
			SPECULAR,  0.5, 0.0, 0.0,
			SHININESS, 10.0,
			LMNULL
			};
d2140 7
a2146 7
			EMISSION, 0.60, 0.0, 0.0,
			AMBIENT,  0.1, 0.25, 0.1,
			DIFFUSE,  0.5, 0.5, 0.5,
			SPECULAR,  0.5, 0.0, 0.0,
			SHININESS, 1.0,
			LMNULL
			};
d2149 7
a2155 7
			EMISSION, 0.60, 0.0, 0.0,
			AMBIENT,  0.1, 0.25, 0.1,
			DIFFUSE,  0.5, 0.5, 0.5,
			SPECULAR,  0.5, 0.0, 0.0,
			SHININESS, 10.0,
			LMNULL
			};
d2158 7
a2164 7
			EMISSION, 0.5, 0.5, 0.6,
			AMBIENT,  0.35, 0.35, 0.0,
			DIFFUSE,  0.5, 0.5, 0.0,
			SPECULAR,  0.5, 0.5, 0.0,
			SHININESS, 10.0,
			LMNULL
			};
d2173 5
a2177 5
			AMBIENT,	0.0, 0.0, 0.0, 
			LCOLOR,		1.0, 1.0, 1.0, 
			POSITION,	0.0, 0.0, 1.0, 0.0,
			LMNULL};
		    
d2181 31
a2211 26
static float white_inf_light[] = {AMBIENT, 0.0, 0.0, 0.0, 
			   LCOLOR,   0.70, 0.70, 0.70, 
			   POSITION, 100.0, -200.0, 100.0, 0.0, 
			   LMNULL};


static float red_inf_light[] = {AMBIENT, 0.0, 0.0, 0.0, 
			   LCOLOR,   0.6, 0.1, 0.1, 
			   POSITION, -100.0, -30.0, 100.0, 0.0, 
			   LMNULL};

static float green_inf_light[] = {AMBIENT, 0.0, 0.0, 0.0, 
			   LCOLOR,   0.1, 0.3, 0.1, 
			   POSITION, 100.0, -20.0, 20.0, 0.0, 
			   LMNULL};


static float blue_inf_light[] = {AMBIENT, 0.0, 0.0, 0.0, 
			   LCOLOR,   0.1, 0.1, 0.3, 
			   POSITION, 0.0, 100.0, -100.0, 0.0, 
			   LMNULL};

static float white_local_light[] = {AMBIENT, 0.0, 1.0, 0.0, 
			     LCOLOR,   0.75, 0.75, 0.75, 
			     POSITION, 0.0, 10.0, 10.0, 5.0, 
			     LMNULL};
d2213 31
a2243 26
static float white_inf_light[] = {AMBIENT, 0.0, 0.0, 0.0, 
			   LCOLOR,   0.70, 0.70, 0.70, 
			   POSITION, 100.0, 200.0, 100.0, 0.0, 
			   LMNULL};


static float red_inf_light[] = {AMBIENT, 0.0, 0.0, 0.0, 
			   LCOLOR,   0.6, 0.1, 0.1, 
			   POSITION, 100.0, 30.0, 100.0, 0.0, 
			   LMNULL};

static float green_inf_light[] = {AMBIENT, 0.0, 0.0, 0.0, 
			   LCOLOR,   0.1, 0.3, 0.1, 
			   POSITION, -100.0, 20.0, 20.0, 0.0, 
			   LMNULL};


static float blue_inf_light[] = {AMBIENT, 0.0, 0.0, 0.0, 
			   LCOLOR,   0.1, 0.1, 0.3, 
			   POSITION, 0.0, -100.0, -100.0, 0.0, 
			   LMNULL};

static float white_local_light[] = {AMBIENT, 0.0, 1.0, 0.0, 
			     LCOLOR,   0.75, 0.75, 0.75, 
			     POSITION, 0.0, 10.0, 10.0, 5.0, 
			     LMNULL};
d2247 37
a2283 31
static float white_inf_light[] = {AMBIENT, 0.0, 0.0, 0.0, 
			   LCOLOR,   0.70, 0.70, 0.70, 
			   POSITION, 10.0, 50.0, 50.0, 0.0, 
			   LMNULL};


static float red_inf_light[] = {AMBIENT, 0.0, 0.0, 0.0, 
			   LCOLOR,   0.5, 0.1, 0.1, 
			   POSITION, -100.0, 0.0, 0.0, 0.0, 
			   LMNULL};

static float green_inf_light[] = {AMBIENT, 0.0, 0.0, 0.0, 
			   LCOLOR,   0.1, 0.5, 0.1, 
			   POSITION, 100.0, 50.0, 0.0, 0.0, 
			   LMNULL};

static float blue_inf_light[] = {AMBIENT, 0.0, 0.0, 0.0, 
			   LCOLOR,   0.1, 0.1, 0.5, 
			   POSITION, 0.0, -50.0, 0.0, 0.0, 
			   LMNULL};

static float orange_inf_light[] = {AMBIENT, 0.0, 0.0, 0.0, 
			    LCOLOR,	0.35, 0.175, 0.0, 
			    POSITION, -50.0, 50.0, 10.0, 0.0, 
			    LMNULL};

static float white_local_light[] = {AMBIENT, 0.0, 0.0, 0.0, 
			     LCOLOR,   0.75, 0.75, 0.75, 
			     POSITION, 0.0, 10.0, 10.0, 5.0, 
			     LMNULL};
			   
d2297 15
a2311 13
			AMBIENT,	0.2,  0.2,  0.2,
			ATTENUATION,	1.0, 0.0, 
			LOCALVIEWER,	0.0, 
			LMNULL};

static float infinite[] = {AMBIENT, 0.3,  0.3, 0.3, 
	            LOCALVIEWER, 0.0, 
	            LMNULL};

static float local[] = {AMBIENT, 0.3,  0.3, 0.3, 
	         LOCALVIEWER, 1.0, 
	         ATTENUATION, 1.0, 0.0, 
	         LMNULL};
d2316 2
a2317 2
    /* define material properties */
    lmdef (DEFMATERIAL, 1, 0, material_default);
d2319 13
a2331 13
    lmdef (DEFMATERIAL, 2, 0, mat_brass);
    lmdef (DEFMATERIAL, 3, 0, mat_shinybrass);
    lmdef (DEFMATERIAL, 4, 0, mat_pewter);
    lmdef (DEFMATERIAL, 5, 0, mat_silver);
    lmdef (DEFMATERIAL, 6, 0, mat_gold);
    lmdef (DEFMATERIAL, 7, 0, mat_shinygold);
    lmdef (DEFMATERIAL, 8, 0, mat_plaster);
    lmdef (DEFMATERIAL, 9, 0, mat_redplastic);
    lmdef (DEFMATERIAL, 10, 0, mat_greenplastic);
    lmdef (DEFMATERIAL, 11, 0, mat_blueplastic);

    lmdef (DEFMATERIAL, 12, 0, mat_greenflat);
    lmdef (DEFMATERIAL, 13, 0, mat_greenshiny);
d2333 2
a2334 2
    lmdef (DEFMATERIAL, 14, 0, mat_blueflat);
    lmdef (DEFMATERIAL, 15, 0, mat_blueshiny);
d2336 2
a2337 2
    lmdef (DEFMATERIAL, 16, 0, mat_redflat);
    lmdef (DEFMATERIAL, 17, 0, mat_redshiny);
d2339 1
a2339 1
    lmdef (DEFMATERIAL, 18, 0, mat_beigeshiny);
d2344 12
a2355 12
/*    lmdef (DEFLIGHT, 1, 0, default_light); */
    lmdef (DEFLIGHT, 4, 0, green_inf_light);
    lmdef (DEFLIGHT, 2, 0, white_inf_light);
    lmdef (DEFLIGHT, 3, 0, red_inf_light);
    lmdef (DEFLIGHT, 4, 0, green_inf_light);
    lmdef (DEFLIGHT, 5, 0, blue_inf_light);
/*    lmdef (DEFLIGHT, 6, 0, orange_inf_light); */
    lmdef (DEFLIGHT, 7, 0, white_local_light);

    lmdef (DEFLMODEL, 1, 0, default_lmodel);
    lmdef (DEFLMODEL, 2, 0, infinite);
    lmdef (DEFLMODEL, 3, 0, local);
@


10.40
log
@Added include "conf.h"
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.39 1994/08/03 21:17:22 mike Exp gdurf $ (BRL)";
d68 1
a68 1
int	Ir_input();
d1101 3
a1103 5
 * The GED "generic input" structure is filled in.
 *
 * Returns:
 *	0 if no command waiting to be read,
 *	1 if command is waiting to be read.
d1105 4
a1108 1
Ir_input( cmd_fd, rateflg )
a1114 2
/*XXX*/	extern void		(*extrapoll_hook)();	/* ged.c */
/*XXX*/	extern int		extrapoll_fd;
d1120 2
d1139 2
a1140 1
		if( i != 0 )
d1142 3
a1144 3
		FD_ZERO( &files );
		FD_SET( cmd_fd, &files );
/*XXX*/		if(extrapoll_fd) FD_SET( extrapoll_fd, &files );
d1146 1
a1146 2

		if( rateflg )  {
d1152 1
a1152 1
		cnt = select( width, &files, (fd_set *)0,  (fd_set *)0, &tv );
d1157 5
a1161 9
/*XXX*/		if(extrapoll_fd&&FD_ISSET(extrapoll_fd,&files)&&extrapoll_hook)  {
/*XXX*/			(*extrapoll_hook)();
/*XXX*/			cnt = FD_ISSET(cmd_fd, &files);
/*XXX*/			break;
/*XXX*/		}
		cnt = FD_ISSET(cmd_fd, &files);
		if( cnt != 0 )
			break;		/* There is keyboard input */
	} while( rateflg == 0 );
d1163 1
d1175 1
a1175 4
	if( cnt > 0 )
		return(1);		/* command awaits */
	else
		return(0);		/* just peripheral stuff */
@


10.39
log
@Allow negative window offsets.
Especially necessary with SGI Galileo board.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.38 94/08/02 18:07:58 mike Exp Locker: mike $ (BRL)";
d26 2
a39 8
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "./dm.h"
#include "externs.h"
#include "./solid.h"

d48 8
@


10.38
log
@Added support for some more SGI types.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.37 94/08/02 18:02:36 mike Exp Locker: mike $ (BRL)";
d470 1
a470 1
	if (mged_variables.sgi_win_origin[0] > 0)
d473 1
a473 1
	if (mged_variables.sgi_win_origin[1] > 0)
@


10.37
log
@Added settable linewidth.
Use 7 on Galileo board.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.36 94/03/09 00:18:28 mike Exp Locker: mike $ (BRL)";
d402 1
d405 1
@


10.36
log
@Added mouse debugging.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.35 94/02/16 18:20:32 cjohnson Exp Locker: mike $ (BRL)";
d86 1
d214 1
d329 1
a329 1
		linewidth(3);
d343 1
a343 1
		linewidth(3);
d691 1
@


10.35
log
@Add support (resupport?) for the old PI20s that return GR1BP as graphics
type rather than using the state variable in GR1BOARD.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.34 1994/02/16 17:40:38 cjohnson Exp $ (BRL)";
d1468 1
d1472 1
@


10.34
log
@Add the variable that is suppose to be printed to a printf line.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.33 1993/11/05 09:46:33 stay Exp cjohnson $ (BRL)";
d406 6
@


10.33
log
@added fixes for the newport section to not bomb out if compiled in a Irix 4.0
systems
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.32 1993/10/29 02:23:13 stay Exp stay $ (BRL)";
d386 1
a386 1
			printf("mged/dm-4d.c: getinvent() INV_GRAPHICS type=%d not recognized, you need to modify the source code\n");
@


10.32
log
@added case for newport graphics (INDY)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dm-4d.c,v 10.31 1993/10/26 01:47:57 mike Exp stay $ (BRL)";
a426 1
		case INV_NEWPORT:	/* INDY */
d437 11
@


10.31
log
@IRIX 5.0.1
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dm-4d.c,v 10.30 1993/07/14 19:27:36 mike Exp mike $ (BRL)";
d427 1
@


10.30
log
@Modified to get and use min_scr_z and max_scr_z.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.29 93/07/13 21:01:47 mike Exp Locker: mike $ (BRL)";
d26 5
d32 1
d110 2
d1691 1
a1691 1
int
@


10.29
log
@Added support for "dm set" command.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.28 93/07/01 03:15:14 mike Exp Locker: mike $ (BRL)";
d88 2
d202 2
d307 5
d545 1
a546 4
#if 0
	/* Optional:  Z from 0 to 0x007fffff */
	glcompat( GLC_ZRANGEMAP, 1 );
#else
d549 1
a549 1
	 * Hardware specific.  This is the default mode.
d552 3
a554 1
#endif
a888 1
			/* RGBrange marked obsolete, use lRGBrange! */
d892 1
a892 2
				0, 0x007fffff );
			/* XXX should investigate lRGBrange, lshaderange, lsetdepth */
d899 4
a902 2
			if(cueing_on) lshaderange(nvec+1, nvec+1, 0, 0x007fffff);

d911 4
a914 1
			  	if(cueing_on) lshaderange(nvec+1, nvec+14, 0, 0x007fffff);
d1040 1
a1040 1
				0, 0x007fffff );
d1045 2
a1046 1
		  	if(cueing_on) lshaderange(nvec, nvec, 0, 0x007fffff);
a1847 1
		continue;
d1850 4
a1853 1
	if( zbuffer_on) lsetdepth(0, 0x007fffff);
d1865 1
a1865 1
			czclear( 0, 0x7fffff );
d1867 1
a1867 1
			czclear( BLACK, 0x7fffff );
@


10.28
log
@NTSC aspect correction is now right (again, sigh).
Two problems:
(1) the first frame (only) is shrunken oddly in X.
(2) the drawing overflows the boundaries in NTSC mode (faceplate=1)
Something for later.  But at least the aspect ratio is right!
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.27 93/07/01 01:39:42 mike Exp Locker: mike $ (BRL)";
d69 1
d71 18
d90 1
a91 3
static int cueing_on = 1;	/* Depth cueing flag - for colormap work */
static int zclipping_on = 1;	/* Z Clipping flag */
static int zbuffer_on = 1;	/* Hardware Z buffer is on */
a94 2
static int lighting_on = 0;	/* Lighting model on */
static int no_faceplate = 0;	/* Don't draw faceplate */
d175 3
a177 1
	"sgi", "SGI 4d"
d182 22
a203 5
static int	ir_debug;		/* 2 for basic, 3 for full */
static int	ir_is_gt;		/* 0 for non-GT machines */
static int	ir_has_zbuf;		/* 0 if no Z buffer */
static int	ir_has_rgb;		/* 0 if mapped mode must be used */
static int	ir_has_doublebuffer;	/* 0 if singlebuffer mode must be used */
d266 1
a266 5
	if( ir_has_zbuf && zbuffer_on ) 
	{
		zbuffer(1);
		lsetdepth(0, 0x07fffff );
	}
d1234 2
a1235 2
				cueing_on = cueing_on ? 0 : 1;
				Ir_colorchange();
d1245 2
a1246 2
				zclipping_on = zclipping_on ? 0 : 1;
				dmaflag = 1;
a1269 4
				if( ir_has_zbuf == 0 )  {
					printf("dm-4d: This machine has no Zbuffer to enable\n");
					continue;
				}
d1271 2
a1272 4
				zbuffer_on = zbuffer_on ? 0 : 1;
				zbuffer( zbuffer_on );
				if( zbuffer_on) lsetdepth(0, 0x007fffff);
				dmaflag = 1;
d1282 2
a1283 44
				if( lighting_on )  {
					/* Turn it off */
					mmode(MVIEWING);
					lmbind(MATERIAL,0);
					lmbind(LMODEL,0);
					lighting_on = 0;
					mmode(MSINGLE);
				} else {
					/* Turn it on */
					if( cueing_on )  {
						/* Has to be off for lighting */
						cueing_on = 0;
						Ir_colorchange();
					}

					mmode(MVIEWING);
					/* Define material properties */
					make_materials();

					lmbind(LMODEL, 2);	/* infinite */

					lmbind(LIGHT2,2);
					lmbind(LIGHT3,3);
					lmbind(LIGHT4,4);
					lmbind(LIGHT5,5);

					/* RGB color commands & lighting */
#if 1
					/* Good for debugging */
					/* Material color does not apply,
					 * when lighting is on */
					lmcolor( LMC_COLOR );	/* default */
#else
					/* Good for looking.
					 * RGBcolor() values go to emissions
					 * durring lighting calculations.
					 */
					lmcolor( LMC_EMISSION );
#endif

					mmode(MSINGLE);
					lighting_on = 1;
				}
				dmaflag = 1;
d1830 13
d1873 48
d2295 34
@


10.27
log
@Don't bother setting blanktime(), that's the user's business.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.26 93/04/07 23:37:51 mike Exp Locker: mike $ (BRL)";
d252 1
a252 1
		/* Only use the central square part */
d263 1
a263 2
			xlim_view = XMAX170 / (double)npix / (4 / 3);;
			ylim_view = YMAX170 / (double)npix;
d266 7
a274 2
			xlim_view = 1;
			ylim_view = 1;
d276 3
@


10.26
log
@Added support for SkyWriter.  Thanks to
Michael N. LeVine  Naval Air Weapons Station, China Lake, Ca 93555, USA
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.25 93/04/07 03:06:23 mike Exp Locker: mike $ (BRL)";
a249 11
		if( !ir_is_gt )  {
			/*
			 *  Set an 8 minute screensaver blanking, which will light up
			 *  the screen again if it was dark, and will protect it otherwise.
			 *  4D/60 has a hardware botch limiting the time to 2**15 frames.
			 */
			blanktime( (long) 32767L );
		} else {
			/* Set blanktime to 30 minutes (at 67 Hz) */
			blanktime( 30 * 60 * 67 );
		}
@


10.25
log
@Added more graceful handling of new SGI devices that arn't recognized.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.24 93/02/02 11:56:28 stay Exp Locker: mike $ (BRL)";
d357 2
a358 1
		case INV_GMDEV:
@


10.24
log
@*** empty log message ***
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dm-4d.c,v 10.23 92/10/20 18:16:55 mike Exp Locker: stay $ (BRL)";
d342 10
@


10.23
log
@On GT machines, use 30 minute blanktime, rather than 8.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.22 92/10/20 14:34:51 stay Exp Locker: mike $ (BRL)";
@


10.22
log
@added a case for the old 4d/60 graphics boards
Still seems to be a problem with color maps
but I belive it is related to X on these
older boards. If gets fixed when the cursor get
inside the mged window.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dm-4d.c,v 10.21 92/08/24 19:51:29 mike Exp Locker: stay $ (BRL)";
d250 11
a260 6
		/*
		 *  Set an 8 minute screensaver blanking, which will light up
		 *  the screen again if it was dark, and will protect it otherwise.
		 *  4D/60 has a hardware botch limiting the time to 2**15 frames.
		 */
		blanktime( (long) 32767L );
@


10.21
log
@Added new variable "eye_sep_dist" to support Stereo viewing.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.20 92/08/21 22:46:16 mike Exp Locker: mike $ (BRL)";
d337 5
@


10.20
log
@Initial prototype support for stereo viewer
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.19 92/08/21 20:22:33 mike Exp Locker: mike $ (BRL)";
d404 8
a411 5
#if 0
	/* XXX also need to test some flag variable */
	if( sgi_has_stereo() )  {
		setmonitor(STR_RECT);
		stereo_is_on = 1;
a412 1
#endif
d578 2
a579 1
	setmonitor(ir_oldmonitor);
@


10.19
log
@Updated so that it will still compile on IRIX 3 systems.
Added sgi_has_stereo() check routine.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.18 92/08/21 19:33:44 mike Exp Locker: mike $ (BRL)";
d49 3
d85 1
d170 1
a198 1
	
d202 1
d403 9
d423 16
d576 2
d684 1
a684 1
Ir_newrot(mat)
d694 16
d1830 3
@


10.18
log
@In NTSC mode, when faceplate is turned off, use full screen for geometry.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.17 92/07/23 05:12:09 butler Exp Locker: mike $ (BRL)";
d43 2
d347 1
d354 1
d356 1
d366 1
a366 1

d2142 39
@


10.17
log
@trying to get lighting model to work right.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.16 92/07/09 19:55:57 butler Exp Locker: butler $ (BRL)";
d77 3
d213 4
d259 13
a271 2
		viewport( (XMAX170 - npix)/2, npix + (XMAX170 - npix)/2,
			(YMAX170-npix)/2, npix + (YMAX170-npix)/2 );
d278 1
a278 1
		winx_size = npix;
d290 5
d558 1
d560 3
d590 1
d592 3
d667 1
d674 5
d680 16
d1257 1
@


10.16
log
@altered pattern of lights when displaying polygons.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.15 92/07/07 10:54:15 stay Exp Locker: butler $ (BRL)";
d1923 1
d1950 5
a1954 1
			   
d1956 23
d2069 1
a2069 1
    lmdef (DEFLIGHT, 1, 0, default_light);
@


10.15
log
@added some mmode commands to get rid of the LMBIND error
message when viewing in polygon mode. It turns out that 
you can only call lmbind when in MVIEWING mode. So I added
the appropriate calls.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dm-4d.c,v 10.14 92/06/19 00:47:56 mike Exp Locker: stay $ (BRL)";
d1921 2
d1925 1
a1925 1
			   POSITION, 10.0, 50.0, 50.0, 0.0, 
d1928 1
d1930 2
a1931 2
			   LCOLOR,   0.5, 0.1, 0.1, 
			   POSITION, -100.0, 50.0, 0.0, 0.0, 
d1934 6
d1941 2
a1942 2
			   LCOLOR,   0.1, 0.1, 0.5, 
			   POSITION, 0.0, 50.0, 0.0, 0.0, 
d1945 18
d1968 5
d1983 6
d2042 1
d2047 1
a2047 1
    lmdef (DEFLIGHT, 6, 0, orange_inf_light);
@


10.14
log
@Added ST_S_VPICK to statechange support
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.13 92/06/16 12:43:05 stay Exp Locker: mike $ (BRL)";
d1134 1
a1134 1
					mmode(MSINGLE);
d1138 1
d1147 1
d1172 1
@


10.13
log
@Added support for the 4D/RPG elan Graphics 
which is the entry level system (read indigo) with
the Elan Graphics (24 bit Z-buffer 24 Bit Color)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.12 92/06/16 12:34:26 stay Exp Locker: stay $ (BRL)";
d1447 1
@


10.12
log
@Lee debugging
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dm-4d.c,v 10.11 92/05/23 16:09:47 butler Exp Locker: butler $ (BRL)";
d328 11
@


10.11
log
@Removed IR_WIDGETS code used for forms_library experiment.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.10 92/04/18 02:46:39 mike Exp Locker: butler $ (BRL)";
d522 2
a523 1

d543 3
d561 2
d613 2
d670 2
d812 2
d829 2
d854 2
d906 2
@


10.10
log
@Moved perspective handling into dozoom.c
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.9 92/04/18 01:47:25 mike Exp $ (BRL)";
a164 77
#if IR_WIDGETS
# include "forms.h"
# include "./mged_widgets.h"

static int win_focus = 0;

void button_call(obj, val)
OBJECT *obj;
long val;
{	
	short ev[4];


	ev[0] = (short)val;
	ev[1] = get_button(obj);
/*	(void)fprintf(stdout, "button %d\n", ev[1]); */
	ev[2] = getvaluator(MOUSEX);
	ev[3] = getvaluator(MOUSEY);

	lbr_qenter(ev);
}

void toggle_call(obj, val)
OBJECT *obj;
long val;
{
	short ev[4];

	ev[0] = (short)val;
	ev[1] = 1;
	ev[2] = getvaluator(MOUSEX);
	ev[3] = getvaluator(MOUSEY);

	lbr_qenter(ev);
	ev[1] = 0;
	lbr_qenter(ev);
}

void dial_call(obj, dial_dev)
OBJECT *obj;
long dial_dev;
{
	float	dial_val, min, max;
	short	valuator;

	dial_val = get_dial_value(obj);
	get_dial_bounds(obj, &min, &max);
	valuator = getvaluator(dial_dev);

	/* setvaluator will cause an event to be queued if the device
	 * has been queued.  Thus there is no reason for us to queue
	 * a "fake" dial event, setvaluator will do it for us ;-).
	 */
	setvaluator((short)dial_dev, (short)dial_val,
		(short)min, (short)max);
}

void help_call(obj, val)
OBJECT *obj;
long val;
{
	short ev[4];

	ev[0] = val;
	ev[1] = get_button(obj);
	ev[2] = getvaluator(MOUSEX);
	ev[3] = getvaluator(MOUSEY);

	(void)fprintf(stdout, "help button %d\n", ev[1]);
	
	lbr_qenter(ev);
}


#endif


a296 3
#if IR_WIDGETS
	int		use_widgets=0;
#endif
a373 3
#if IR_WIDGETS
		use_widgets = 1;
#endif
a432 6
#if IR_WIDGETS

	fl_usrqdevice(LEFTMOUSE);
	fl_usrqdevice(MIDDLEMOUSE);
	fl_usrqdevice(RIGHTMOUSE);
#else
d437 2
a438 2
#endif
#if IR_KNOBS || IR_WIDGETS
a446 3
# if IR_WIDGETS
		fl_usrqdevice(i);
# else
a447 2
# endif

d449 1
a449 1
#if IR_BUTTONS || IR_WIDGETS
a453 3
#if IR_WIDGETS
		fl_usrqdevice(i+SWBASE);
#else
a454 1
#endif
a470 9
#if IR_WIDGETS
	fl_usrqdevice(F1KEY);	/* pf1 key for depthcue switching */
	fl_usrqdevice(F2KEY);	/* pf2 for Z clipping */
	fl_usrqdevice(F3KEY);	/* pf3 for perspective */
	fl_usrqdevice(F4KEY);	/* pf4 for Z buffering */
	fl_usrqdevice(F5KEY);	/* pf5 for lighting */
	fl_usrqdevice(F6KEY);	/* pf6 for changing perspective */
	fl_usrqdevice(F7KEY);	/* pf7 for no faceplate */
#else
a477 1
#endif
a486 9
#if IR_WIDGETS
	if (use_widgets) {
		create_the_forms();

		show_forms(Button_Box, PLACE_SIZE, TRUE, "Soft Buttons");
		show_forms(Dials, PLACE_SIZE, TRUE, "Soft Dials");
	}
#endif

a506 4
#if IR_WIDGETS
	hide_form(Button_Box);
	hide_form(Dials);
#endif
a969 7
#if IR_WIDGETS
	n = fl_usrblkqread( values, NVAL );/* n is # of shorts returned */
	if( ir_debug ) printf("fl_usrblkqread gave %d\n", n);
	for (valp = values ; n > 0  ; n -= 4, valp += 4 ) {
		ret = *valp;

#else
d976 1
a976 2
#endif
#if IR_BUTTONS || IR_WIDGETS
d1016 1
a1016 1
#if IR_KNOBS || IR_WIDGETS
a1026 3
#if IR_WIDGETS
				/* zero the widget knobs */
#endif
a1273 40
#if IR_WIDGETS
		switch( ret ) {
		case LEFTMOUSE:
			if (win_focus && valp[1] &&
			    dm_values.dv_penpress != DV_PICK )
				dm_values.dv_penpress = DV_OUTZOOM;
			break;
		case MIDDLEMOUSE:
			if (win_focus) {
				dm_values.dv_xpen = irisX2ged( (int)valp[2] );
				dm_values.dv_ypen = irisY2ged( (int)valp[3] );
				dm_values.dv_penpress = DV_PICK;
			}
			break;
		case RIGHTMOUSE:
			if( win_focus && valp[1] && 
			    dm_values.dv_penpress != DV_PICK )
				dm_values.dv_penpress = DV_INZOOM;
			break;
		case REDRAW:
			/* Window may have moved */
			Ir_configure_window_shape();
			dmaflag = 1;
			if( ir_has_doublebuffer) /* to fix back buffer */
				refresh();		
			dmaflag = 1;
			break;
		case INPUTCHANGE:
			/* Means we got or lost the input focus. */
			win_focus = (valp[1] == gr_id);
			break;
		case WMREPLY:
			/* This guy speaks, but has nothing to say */
			break;
		default:
			printf("IRIS device %d gave %d?\n", ret, valp[1]);
			break;
		}

#else
a1332 1
#endif
a1405 3
#if IR_WIDGETS
		fl_usrunqdevice( MOUSEY );	/* constant tracking OFF */
#else
a1406 1
#endif
a1413 3
#if IR_WIDGETS
		fl_usrqdevice( MOUSEY );	/* constant tracking ON */
#else
a1414 1
#endif
a1417 3
#if IR_WIDGETS
		fl_usrunqdevice( MOUSEY );	/* constant tracking OFF */
#else
a1418 1
#endif
@


10.9
log
@Modified make a dm_newrot() call twice, once before normal solids,
and a second time before edited solids.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.8 92/04/18 01:02:56 mike Exp Locker: mike $ (BRL)";
a75 2
static mat_t perspect_mat;
static mat_t nozclip_mat;
a76 1
static int persp_mat();
a594 5
	/* Compute some viewing matricies */
	mat_idn( nozclip_mat );
	nozclip_mat[10] = 1.0e-20;
	persp_mat( perspect_mat, 90.0, 1.0, 0.01, 1.0e10, 1.0 );

d726 1
a726 1
	int	i,j;	
d728 2
a729 9
	/* It seems that this needs to be done before the loadmatrix() */
	if( ir_is_gt && lighting_on )  {
		/* Separate projection matrix from
		 * modeling and viewing xforms.
		 */
		mmode(MVIEWING);
		/* Select the material */
		lmbind(MATERIAL, 20);
	}
d731 3
a733 6
	/* This section has the potential of being speed up since a new
	 * matrix is loaded for each object. Even though its the same
	 * matrix.
	 */
	if( perspective_mode ) {
		mat_mul( newm, perspect_mat, mat );
a734 3
	} else if( ! zclipping_on ) {
		mat_mul( newm, nozclip_mat, mat );
		mptr = newm;
d739 4
a742 2
		for(j= 0; j < 4; j++)
			gtmat[j][i] = *(mptr++);
d772 3
a774 3
register fastf_t *m;
double ratio;
int white;
d791 1
a1285 18
				switch (perspective_angle) {
				case 3:
					persp_mat( perspect_mat, 90.0,
					    1.0, 0.01, 1.0e10, 1.0 );
					break;
				case 2:
					persp_mat( perspect_mat, 60.0,
					    1.0, 0.01, 1.0e10, 1.0 );
					break;
				case 1:
					persp_mat( perspect_mat, 45.0,
					    1.0, 0.01, 1.0e10, 1.0 );
					break;
				case 0:
					persp_mat( perspect_mat, 30.0,
					    1.0, 0.01, 1.0e10, 1.0 );
					break;
				}
a1871 25
/*
 *  Compute a perspective matrix.
 *  Reference: SGI Graphics Reference Appendix C
 */
static int
persp_mat( m, fovy, aspect, near, far, backoff )
mat_t	m;
fastf_t	fovy, aspect, near, far, backoff;
{
	mat_t	m2, tran;

	fovy *= 3.1415926535/180.0;

	mat_idn( m2 );
	m2[5] = cos(fovy/2.0) / sin(fovy/2.0);
	m2[0] = m2[5]/aspect;
	m2[10] = -(far+near) / (far-near);	/* negate Z! */
	m2[11] = -2*far*near / (far-near);
	m2[14] = -1;
	m2[15] = 0;

	mat_idn( tran );
	tran[11] = -backoff;
	mat_mul( m, m2, tran );
}
@


10.8
log
@Now notifies MGED of perspective changes.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.7 92/04/16 04:08:10 mike Exp Locker: mike $ (BRL)";
a702 14
 *  Stub.
 */
void
Ir_newrot(mat)
mat_t mat;
{
}

/*
 *  			I R _ O B J E C T
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.  Mat is model2view.
d704 2
a705 3
 *  Returns -
 *	 0 if object could be drawn
 *	!0 if object was omitted.
d727 3
a729 6
int
Ir_object( sp, m, ratio, white )
register struct solid *sp;
register fastf_t *m;
double ratio;
int white;
a730 4
	register struct rt_vlist	*vp;
	register int nvec;
	register float	*gtvec;
	char	gtbuf[16+3*sizeof(double)];
d732 3
a734 4
	Matrix gtmat;
	int first;
	int i,j;	
	mat_t	mtmp, newm;
a745 10

	/*
	 *  It is claimed that the "dancing vector disease" of the
	 *  4D GT processors is due to the array being passed to v3f()
	 *  not being quad-word aligned (16-byte boundary).
	 *  This hack ensures that the buffer has this alignment.
	 *  Note that this requires gtbuf to be 16 bytes longer than needed.
	 */
	gtvec = (float *)((((int)gtbuf)+15) & (~0xF));

d751 2
a752 2
		mat_mul( newm, perspect_mat, m );
		m = newm;
d754 4
a757 2
		mat_mul( newm, nozclip_mat, m );
		m = newm;
d759 4
a763 5
	mptr = m;
	for(i= 0; i < 4; i++)
	for(j= 0; j < 4; j++)
		gtmat[j][i] = *(mptr++);

d775 1
d777 43
@


10.7
log
@Contains ultra hacks for VR testing
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.6 92/04/16 03:04:27 mike Exp Locker: mike $ (BRL)";
d72 1
d1209 5
d1310 3
@


10.6
log
@Modified to use select() directly now, rather than bsdselect().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.5 92/04/03 19:49:54 mike Exp Locker: mike $ (BRL)";
d1013 2
d1039 1
d1053 5
@


10.5
log
@Implemented set faceplate=0 support, per idea from Lee.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.4 92/04/03 02:11:55 mike Exp Locker: mike $ (BRL)";
d44 1
d1010 3
d1014 3
a1029 5
	/* System V on IRIS defines select() for graphics library.
	 * Also note that we need to frequently check qtest() for devices.
	 * Under MEX, need to swap buffers, for -other- programs to get
	 * a chance.
	 */
d1034 5
a1038 7
			break;
#ifdef NONBLOCK
		clearerr( stdin );
		cnt = 1;
		(void)ioctl( cmd_fd, FIONBIO, &cnt );
		cnt = 1;
#else
d1040 1
a1040 1
			cnt = bsdselect( (long)(1<<cmd_fd), 0, 0 );
d1043 1
a1043 1
			cnt = bsdselect( (long)(1<<cmd_fd), 0, 50000 );
d1045 6
a1050 1
#endif
d1052 1
a1052 8
			break;
		/* If Rate operation, return immed., else wait. */
		/* For MEX in double buffered mode, we really ought to
		 * do a swapbuffers() here, but that means arranging to
		 * have something sensible in the back buffer already,
		 * and at the moment, it's black.  We could leave it stale,
		 * but that would be just as bad.  For now, punt.
		 */
@


10.4
log
@Fixed problem with loosing events in illuminate mode.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.3 92/03/28 05:33:37 stay Exp Locker: mike $ (BRL)";
a941 2
	if( no_faceplate )  return;

a964 2
	if( no_faceplate )  return;

d1309 4
@


10.3
log
@added supoort for the Iris indigo entry level workstation.
Currently it only supports single buffer mode since the double buffer
scheme only uses 1 bit red, 2 bits green, 1 bit blue, The INV_LIGHT
name changes in release 4.0.3 with the introduction of the ELAN graphics,
but I will have to work on that later(when I have a ELAN system on hand)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dm-4d.c,v 10.2 91/11/05 00:02:47 mike Exp Locker: stay $ (BRL)";
a1089 1
	static	pending_middlemouse = 0;	/* state variable */
a1465 1
			pending_middlemouse = 1;
d1481 3
a1483 3
			 *  So, don't signal DV_PICK on MIDDLEMOUSE;
			 *  instead, set the flag, and patiently wait until
			 *  the subsequent MOUSEY event has arrived, which
d1485 5
d1491 4
a1494 8
			if( pending_middlemouse )  {
				char	input_line[64];
				sprintf(input_line, "M %d %d %d\n",
					pending_middleval,
					pending_x, pending_y);
				rt_vls_strcat( &dm_values.dv_string, input_line);
				pending_middlemouse = 0;
			}
@


10.2
log
@Modified for beginnings of new display manager interface.
Added zoom and "M" (mouse) command.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 10.1 91/10/12 06:43:17 mike Rel4_0 Locker: mike $ (BRL)";
d161 1
a161 1

d302 9
a310 5
	/* Clear out image from windows underneath */
	frontbuffer(1);
	ir_clear_to_black();
	frontbuffer(0);
	ir_clear_to_black();
d392 1
d401 1
d403 6
d492 3
a494 1
	doublebuffer();
d652 3
a654 1
	if( !dmaflag )
d656 1
d691 6
a696 4
	swapbuffers();

	/* give Graphics pipe time to work */
	ir_clear_to_black();
d745 1
d1439 2
a1440 1
			refresh();		/* to fix back buffer */
d1501 2
a1502 1
			refresh();		/* to fix back buffer */
@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.32 91/09/21 03:06:47 butler Exp $ (BRL)";
d1071 3
d1437 2
a1438 2
			if( valp[1] && dm_values.dv_penpress != DV_PICK )
				dm_values.dv_penpress = DV_OUTZOOM;
d1440 4
d1446 3
a1448 4
			if( valp[1] ) {
				pending_middlemouse = 1;
				/* Don't signal DV_PICK until MOUSEY event */
			}
a1449 4
		case RIGHTMOUSE:
			if( valp[1] && dm_values.dv_penpress != DV_PICK )
				dm_values.dv_penpress = DV_INZOOM;
			break;
d1451 1
a1451 1
			dm_values.dv_xpen = irisX2ged( (int)valp[1] );
d1454 1
a1454 1
			dm_values.dv_ypen = irisY2ged( (int)valp[1] );
d1468 5
a1472 1
				dm_values.dv_penpress = DV_PICK;
@


9.32
log
@allowed user to set width/height of window independently
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.31 91/08/31 07:34:19 butler Exp $ (BRL)";
@


9.31
log
@added support for user defined preferences for window position/size
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.30 91/07/18 00:26:47 butler Exp $ (BRL)";
d410 1
a410 2
	if (mged_variables.sgi_win_origin[0] > 0 ||
	    mged_variables.sgi_win_origin[0] > 0) {
d412 2
a414 1
	}
@


9.30
log
@put in dbtext("") to send null string to button box.  Needed to reset
diald when button box has been powered off.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.29 91/07/10 00:32:37 butler Exp $ (BRL)";
d374 4
d407 10
a416 1
	prefposition( 272, 1272, 12, 1012 );		/* Larger still */
@


9.29
log
@fixed bug where button box buttons would perform functions while help key
was depressed.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.28 91/07/09 02:28:10 mike Exp $ (BRL)";
d538 2
@


9.28
log
@Made mged window even larger.
Removed setdblights() on Irix 4.0 (Cypress) because it causes
core dumps.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.29 91/07/09 02:23:06 mike Exp $ (BRL)";
d1286 6
a1291 3
			if(valp[1])  {
				if(button0 && valp[1])
					 ir_dbtext(label_button(i));
@


9.27
log
@deleted kblights from the display manager, they are no longer supported
in the gl, and slow down any processing. Hopefully we can have a btte 
interface later on with the gui...

@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.26 91/04/12 14:41:23 mike Exp $ (BRL)";
d402 6
a407 1
	prefposition( 376, 376+900, 112, 112+900 );
d1505 1
d1507 1
@


9.26
log
@Minor nits
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.25 91/03/05 01:19:21 butler Exp $ (BRL)";
a638 6
#ifdef never
	/* Doing this here affects the redraw speed, due to the
	 * slow serial line running out to the keyboard!
	 */
	kblights();
#endif
a1143 1
				kblights();
a1154 1
				kblights();
a1164 1
				kblights();
a1181 1
				kblights();
a1271 1
				kblights();
d1811 1
d1828 1
a1828 1

@


9.25
log
@added code to widget routine dial_call
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.24 91/03/01 19:28:33 mike Exp $ (BRL)";
d396 3
a831 1
			float	norm[3];
d852 2
a853 2
				VMOVE( norm, *pt );
				n3f(norm);
@


9.24
log
@Defined F7 key to be "no faceplate" toggle.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.23 91/03/01 19:09:06 mike Exp $ (BRL)";
d181 1
a181 1
	(void)fprintf(stdout, "button %d\n", ev[1]);
d204 1
a204 1
void dial_call(obj, val)
d206 1
a206 1
long val;
d208 2
d211 10
d483 1
@


9.23
log
@Oops, the American NTSC aspect ratio is 4:3.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.22 91/03/01 19:07:21 butler Exp $ (BRL)";
d72 1
d527 1
d535 1
d893 2
d917 3
d1061 1
a1225 1
				kblights();
d1255 11
@


9.22
log
@window focus changing
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.21 91/02/20 00:17:02 mike Exp $ (BRL)";
d307 1
a307 1
		winx_size = npix * 5 / 4;	/* NTSC aspect ratio */
@


9.21
log
@Can now move and resize MGED window.
Now account for 5:4 aspect in NTSC mode, so that circles are round.
Clear full viewport in NTSC mode, to clean out other windows
stuff that may have popped up in the interim (like libfb).
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.20 91/02/19 23:08:53 butler Exp $ (BRL)";
d169 2
d493 1
d1037 1
a1037 1
	if( ir_debug ) printf("blkqread gave %d\n", n);
d1049 1
a1049 1
#if IR_BUTTONS
d1087 2
a1088 1
#if IR_KNOBS
d1099 4
d1109 1
d1350 1
a1350 1
			if (winget() == gr_id && valp[1] &&
d1355 1
a1355 1
			if (winget() == gr_id) {
d1362 1
a1362 1
			if( winget() == gr_id() &&valp[1] &&
d1374 2
a1375 1
			/* Means we got or lost the keyboard.  Ignore */
@


9.20
log
@Perspective mode toggle on F3, step through viewing angles on F6
ifdefs toward a GUI button box
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.18 91/01/26 04:53:12 mike Exp $ (BRL)";
a65 1
static int big_txt = 0;		/* Text window size flag - hack for Ir_puts */
a156 1
static int	ir_buffer;
d230 6
d261 72
a355 2
	int		npix;
	int		monitor;
d389 2
d397 1
a397 2
	monitor = getmonitor();
	switch( monitor )  {
a432 6
	/* Sense the actual size of the window */
	getsize( &winx_size, &winy_size);
	getorigin( &win_l, & win_b );
	win_r = win_l + winx_size;
	win_t = win_b + winy_size;

d464 1
a464 5
	if( ir_has_zbuf && zbuffer_on ) 
	{
		zbuffer(1);
		lsetdepth(0, 0x07fffff );
	}
a465 47
	/* Clear out image from windows underneath */
	frontbuffer(1);
	ir_clear_to_black();
	frontbuffer(0);
	
	ir_buffer = 0;

	/* Set special television-specific behaviors */
	switch( monitor )  {
	default:
		/*
		 *  Set an 8 minute screensaver blanking, which will light up
		 *  the screen again if it was dark, and will protect it otherwise.
		 *  4D/60 has a hardware botch limiting the time to 2**15 frames.
		 */
		blanktime( (long) 32767L );
		break;
	case NTSC:
		/* Only use the central square part */
		npix = YMAX170-30;
		winx_size = npix;
		winy_size = npix;
		win_l = (XMAX170 - winx_size)/2;
		win_r = win_l + winx_size;
		win_b = (YMAX170-winy_size)/2;
		win_t = win_b + winy_size;
		viewport( (XMAX170 - npix)/2, npix + (XMAX170 - npix)/2,
			(YMAX170-npix)/2, npix + (YMAX170-npix)/2 );
		linewidth(3);
		blanktime(0);	/* don't screensave while recording video! */
		break;
	case PAL:
		/* Only use the central square part */
		npix = YMAXPAL-30;
		winx_size = npix;
		winy_size = npix;
		win_l = (XMAXPAL - winx_size)/2;
		win_r = win_l + winx_size;;
		win_b = (YMAXPAL-winy_size)/2;
		win_t = win_b + winy_size;
		viewport( (XMAXPAL - npix)/2, npix + (XMAXPAL - npix)/2,
			(YMAXPAL-npix)/2, npix + (YMAXPAL-npix)/2 );
		linewidth(3);
		blanktime(0);	/* don't screensave while recording video! */
		break;
	}

a639 2
	ir_buffer = (ir_buffer==0)?1:0;

d1358 2
a1359 1
			/* Window may have moved? */
d1415 2
a1416 1
			/* Window may have moved? */
@


9.19
log
@Modified for new rt_vlist structures
@
text
@d71 1
d167 63
d282 3
a284 1

d332 3
d449 5
d458 2
a459 2

#if IR_KNOBS
d468 3
d472 1
d474 1
a474 1
#if IR_BUTTONS
d479 3
d483 1
a483 1

d498 8
d511 2
a512 1
	
d525 1
a525 1
/*	persp_mat( perspect_mat, 90.0, 1.0, 0.01, 1.0e10, 1.0 ); */
d527 9
d556 4
a1000 1

d1016 7
d1025 1
a1026 1
	for( valp = values; n > 0; n -= 2, valp += 2 )  {
d1029 1
a1029 1

d1033 1
a1033 1
		  || ret == F4KEY || ret == F5KEY
d1122 1
a1122 22
				/* toggle perspective viewing */
				if (--perspective_mode < 0) perspective_mode = 4;
				switch (perspective_mode) {
				case 4:
					persp_mat( perspect_mat, 90.0,
					    1.0, 0.01, 1.0e10, 1.0 );
					break;
				case 3:
					persp_mat( perspect_mat, 60.0,
					    1.0, 0.01, 1.0e10, 1.0 );
					break;
				case 2:
					persp_mat( perspect_mat, 45.0,
					    1.0, 0.01, 1.0e10, 1.0 );
					break;
				case 1:
					persp_mat( perspect_mat, 30.0,
					    1.0, 0.01, 1.0e10, 1.0 );
					break;
				case 0:
					break;
				}
d1195 30
d1322 37
d1413 1
d1485 3
d1489 1
d1497 3
d1501 1
d1505 3
d1509 1
d1770 1
a1770 1
		| ((perspective_mode ? 1 : 0) << 2)
@


9.18
log
@Changed from using an "illegal" upcall to button(i)
to queueing a command string instead.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.17 91/01/25 20:20:06 cjohnson Exp $ (BRL)";
d572 1
a572 1
	register struct vlist *vp;
d685 45
a729 41
	for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
		float	norm[3];
		switch( vp->vl_draw )  {
		case VL_CMD_LINE_MOVE:
			/* Move, start line */
			if( first == 0 )
				endline();
			first = 0;
			bgnline();
			v3d( vp->vl_pnt );
			break;
		case VL_CMD_LINE_DRAW:
			/* Draw line */
			v3d( vp->vl_pnt );
			break;
		case VL_CMD_POLY_START:
			/* Start poly marker & normal */
			if( first == 0 )
				endline();
			/* concave(TRUE); */
			bgnpolygon();
			/* Set surface normal (vl_pnt points outward) */
			norm[X] = vp->vl_pnt[X];
			norm[Y] = vp->vl_pnt[Y];
			norm[Z] = vp->vl_pnt[Z];
			n3f(norm);
			break;
		case VL_CMD_POLY_MOVE:
			/* Polygon Move */
			v3d( vp->vl_pnt );
			break;
		case VL_CMD_POLY_DRAW:
			/* Polygon Draw */
			v3d( vp->vl_pnt );
			break;
		case VL_CMD_POLY_END:
			/* Draw, End Polygon */
			v3d( vp->vl_pnt );
			endpolygon();
			first = 1;
			break;
@


9.17
log
@Change perspective key to toggle through 90,60,45,30 and orthaginal.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.16 90/10/31 21:41:32 mike Exp $ (BRL)";
d1111 1
a1111 1
			if(valp[1])
d1114 15
a1128 2
			else
				button(i);
@


9.16
log
@Fixed pen presses in NTSC mode
Reorganized so that rear buffer is cleared AFTER gconfig() is called.
It had no effect before, and left turds in the back buffer.
Only a problem in NTSC mode.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.15 90/07/17 12:22:53 stay Exp $ (BRL)";
d70 1
a70 1
static int perspective_on = 0;	/* Perspective flag */
d435 1
a435 1
	persp_mat( perspect_mat, 90.0, 1.0, 0.01, 1.0e10, 1.0 );
d606 1
a606 1
	if( perspective_on ) {
d1010 21
a1030 1
				perspective_on = perspective_on ? 0 : 1;
d1585 1
a1585 1
		| (perspective_on << 2)
@


9.15
log
@Added the appropriate calls to mged for the personal iris and
the 4D 240Gt machines to work with depthcueing.  The problem was we
were using some of the old routines such as RGBrange instead of the
newer and supported routes such as lRGBrange, lshaderange.. etc.
I tried it on both a personal iris and a 240GTX machine
-Paul
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.14 90/06/26 05:56:27 stay Exp $ (BRL)";
d217 1
d255 2
a256 1
	switch( getmonitor() )  {
a275 6
		ir_clear_to_black();
		/* Only use the central square part */
		npix = YMAX170-30;
		viewport( (XMAX170 - npix)/2, npix + (XMAX170 - npix)/2,
			(YMAX170-npix)/2, npix + (YMAX170-npix)/2 );
		linewidth(3);
a285 6
		ir_clear_to_black();
		/* Only use the central square part */
		npix = YMAXPAL-30;
		viewport( (XMAXPAL - npix)/2, npix + (XMAXPAL - npix)/2,
			(YMAXPAL-npix)/2, npix + (YMAXPAL-npix)/2 );
		linewidth(2);
d295 5
d306 1
a306 1
	doublebuffer();			/* half of whatever we have */
d339 41
a435 6
	/*
	 *  Set an 8 minute screensaver blanking, which will light up
	 *  the screen again if it was dark, and will protect it otherwise.
	 *  The 4D has a hardware botch limiting the time to 2**15 frames.
	 */
	blanktime( (long) 32767L );
@


9.14
log
@*** empty log message ***
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dm-4d.c,v 9.13 90/06/04 23:35:27 mike Exp $ (BRL)";
d334 1
a334 1
		lsetdepth(0, 768 );
d625 1
a625 1
			RGBrange(
d628 1
a628 1
				0, 768 );
d636 1
a636 1
			if(cueing_on) shaderange(nvec+1, nvec+1, 0, 768);
d646 1
a646 1
			  	if(cueing_on) shaderange(nvec+1, nvec+14, 0, 768);
d759 1
a759 1
			RGBrange(
d762 1
a762 1
				0, 768 );
d767 1
a767 1
		  	if(cueing_on) shaderange(nvec, nvec, 0, 768);
d998 1
a998 1
				if( zbuffer_on) lsetdepth(0, 768);
@


9.13
log
@Restored squareness of smaller image
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.12 90/06/04 22:41:36 mike Exp $ (BRL)";
@


9.12
log
@Modified to leave bottom 50 pixels of screen free, for typing
long lines of text into.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.11 90/05/31 22:25:13 mike Exp $ (BRL)";
d243 1
a243 1
	prefposition( 376, 1276, 50+12, 1012 );
@


9.11
log
@Automaticly detect when in NTSC mode
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.10 90/05/22 21:22:34 mike Exp $ (BRL)";
d243 1
a243 1
	prefposition( 376, 1276, 12, 912 );
@


9.10
log
@Eliminated old "non-GT" way of drawing lines.
"new" way should work on everything.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.9 90/05/22 21:20:36 mike Exp $ (BRL)";
d32 1
a32 1
#include "../h/machine.h"	/* special copy */
d42 1
d213 2
a214 2
	register int i;
	Matrix	m;
d216 1
d241 1
d243 1
a243 1
	prefposition( 276, 1276, 12, 1012 );
d249 51
a299 1
	/* setupt the global variables for the window. */
a301 1

a313 2
	winattach( );

d1176 1
@


9.9
log
@Modified to use VL_CMD_* definitions for vlist ops
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 9.8 90/03/15 01:59:10 mike Exp $ (BRL)";
d604 42
a645 45
	if( ir_is_gt )  {

		first = 1;
		for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
			float	norm[3];
			switch( vp->vl_draw )  {
			case VL_CMD_LINE_MOVE:
				/* Move, start line */
				if( first == 0 )
					endline();
				first = 0;
				bgnline();
				v3d( vp->vl_pnt );
				break;
			case VL_CMD_LINE_DRAW:
				/* Draw line */
				v3d( vp->vl_pnt );
				break;
			case VL_CMD_POLY_START:
				/* Start poly marker & normal */
				if( first == 0 )
					endline();
				/* concave(TRUE); */
				bgnpolygon();
				/* Set surface normal (vl_pnt points outward) */
				norm[X] = vp->vl_pnt[X];
				norm[Y] = vp->vl_pnt[Y];
				norm[Z] = vp->vl_pnt[Z];
				n3f(norm);
				break;
			case VL_CMD_POLY_MOVE:
				/* Polygon Move */
				v3d( vp->vl_pnt );
				break;
			case VL_CMD_POLY_DRAW:
				/* Polygon Draw */
				v3d( vp->vl_pnt );
				break;
			case VL_CMD_POLY_END:
				/* Draw, End Polygon */
				v3d( vp->vl_pnt );
				endpolygon();
				first = 1;
				break;
			}
d647 5
a651 15
		if( first == 0 ) endline();

		if( lighting_on )  {
			/* Return to no-lighting mode */
			mmode(MSINGLE);
		}
	} else {
		/* Non-GT system */
		for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
			/* Viewing region is from -1.0 to +1.0 */
			if( vp->vl_draw == 0 )
				move( vp->vl_pnt[X], vp->vl_pnt[Y], vp->vl_pnt[Z] );
			else
				draw( vp->vl_pnt[X], vp->vl_pnt[Y], vp->vl_pnt[Z] );
		}
@


9.8
log
@Established the abilty to switch between polygons and vectors
in a single vlist chain.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 9.7 90/03/12 21:41:57 mike Locked $ (BRL)";
d610 1
a610 1
			case 0:
d618 1
a618 1
			case 1:
d622 1
a622 1
			case 2:
d634 1
a634 1
			case 3:
d638 1
a638 1
			case 4:
d642 1
a642 1
			case 5:
@


9.7
log
@Unraveled a few more GL secrets.
Used glcompat() to turn off (re)-drawing the outline of polygons.
[Thanks Phil!]
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 9.6 90/03/03 04:18:24 mike Locked $ (BRL)";
d264 17
d606 10
a615 45
		if( sp->s_vlist != VL_NULL && sp->s_vlist->vl_draw == 2 )  {
			/* Draw as polygons, with header markers */
			first = 1;
			for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
				float	norm[3];
				switch( vp->vl_draw )  {
				case 2:
					/* Start poly marker & normal */
					if( first )
						first = 0;
					else
						endpolygon();
					/* concave(TRUE); */
					bgnpolygon();
					/* Set surface normal (vl_pnt points outward) */
					norm[X] = vp->vl_pnt[X];
					norm[Y] = vp->vl_pnt[Y];
					norm[Z] = vp->vl_pnt[Z];
					n3f(norm);
					break;
				case 0:
					/* Move, not draw */
					first = 0;
					v3d( vp->vl_pnt );
					break;
				case 1:
					/* Draw */
					first = 0;
					v3d( vp->vl_pnt );
					break;
				}
			}
			if( !first ) endpolygon();
		} else {
			/* Draw with vectors */
			first = 1;
			for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
				if( vp->vl_draw == 0 )  {
					/* Move, not draw */
					if ( first )
						first = 0;
					else
						endline();
					bgnline();
				}
d617 31
a648 1
			if( !first )  endline();
d650 1
a651 1

a986 17
					/*
					 * Establish GL library operating modes
					 */
					/* Don't draw polygon edges */
					glcompat( GLC_OLDPOLYGON, 0 );
					/* Z-range mapping */
#if 0
					/* Optional:  Z from 0 to 0x007fffff */
					glcompat( GLC_ZRANGEMAP, 1 );
#else
					/* Z range from getgdesc(GD_ZMIN)
					 * to getgdesc(GD_ZMAX).
					 * Hardware specific.
					 */
					glcompat( GLC_ZRANGEMAP, 0 );	/* default */
#endif

d998 1
a998 1
#if 0
@


9.6
log
@Added very preliminary support for SGI lighting models.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 9.5 90/02/27 23:34:59 mike Locked $ (BRL)";
d550 1
a550 1
			r = g = b = 250;
d557 1
d562 1
d974 19
d1001 14
@


9.5
log
@Call n3f() to send surface normal for a polygon.
Because not all SGI button boxes have text displays any more (sigh),
print the help messages on stdout.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/spark/m/cad/mged/RCS/dm-4d.c,v 9.4 89/11/01 14:33:53 stay Exp $ (BRL)";
d70 1
d318 1
d485 11
d586 1
d599 1
a599 1
					concave(TRUE);
d636 6
d643 1
d839 1
a839 1
		  || ret == F4KEY
d951 35
d1525 271
@


9.4
log
@Fixed depthcueing for gt machines. Zbuffer needed an initial
value for the depth range, for it to work right.

@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 9.3 89/10/31 14:28:39 stay Locked $ (BRL)";
d308 1
d310 1
d577 1
d580 1
a580 1
					/* Normal, perhaps? */
d587 5
d846 1
d849 1
d1307 1
a1307 1
 *  Call dbtext to print cute messages on the button box,
d1310 3
d1323 1
d1328 3
@


9.3
log
@Added better discrimination for Personal Iris
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 9.2 89/10/10 16:21:15 mike Locked $ (BRL)";
d263 5
a267 1
	if( ir_has_zbuf && zbuffer_on )  zbuffer(1);
d916 1
@


9.2
log
@Added PRELIMINARY polygon rendering support.
Enabled Z buffering when hardware supports it.
Fixed coordinate system:  SGI is left handed, MGED is right handed.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 9.1 89/05/19 06:02:10 mike Rel3_5 $ (BRL)";
d225 8
@


9.1
log
@Release_3.5
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 8.9 89/04/21 17:26:09 mike Exp $ (BRL)";
d27 1
a33 1
#include "mater.h"
d68 1
d120 12
d157 2
d223 2
d244 6
a249 1
	onemap();			/* one color map */
d255 3
a257 1
	color(BLACK);
d259 1
a259 1
	clear();
d299 1
a299 2
	/* Enable the pf1 key for depthcue switching */
	qdevice(F1KEY);
d302 1
d341 1
a341 2
	color(BLACK);
	clear();
d343 1
d376 6
a381 1
	color(BLACK);
d409 1
a409 2
	color(BLACK);
	clear();
d429 23
a451 1
 *  Returns 0 if object could be drawn, !0 if object was omitted.
d462 1
a462 1
	char	gtbuf[16+3*sizeof(float)];
a481 1

d495 10
d509 2
a510 5
	 * IMPORTANT DEPTHCUEING NOTE:  The IRIS screen +Z points in
	 * (i.e. increasing Z is further away).  In order to reconcile
	 * this with mged (which expects +Z to point out), the color
	 * ramps will be flipped to compensate.  This seemed to be the
	 * lessor of the evils at the time.
d520 21
a540 4
	if( white ) {
		ovec = nvec = MAP_ENTRY(DM_WHITE);
		/* Use the *next* to the brightest white entry */
		if(cueing_on) shaderange(nvec+1, nvec+1, 0, 768);
a541 9
		color( nvec );
	} else {
		if( (nvec = MAP_ENTRY( sp->s_dmindex )) != ovec) {
			/* Use only the middle 14 to allow for roundoff...
			 * Pity the poor fool who has defined a black object.
			 * The code will use the "reserved" color map entries
			 * to display it when in depthcued mode.
			 */
		  	if(cueing_on) shaderange(nvec+1, nvec+14, 0, 768);
d543 12
a554 2
		  	ovec = nvec;
		  }
d557 1
d559 16
a574 6
		first = 1;
		for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
			/* Viewing region is from -1.0 to +1.0 */
			if( vp->vl_draw == 0 )  {
				/* Move, not draw */
				if ( first )
d576 8
a583 3
				else
					endline();
				bgnline();
d585 16
a600 5
			mptr = &(vp->vl_pnt[0]);
			gtvec[0] = *mptr;
			gtvec[1] = *(mptr+1);
			gtvec[2] = *(mptr+2); 
			v3f( gtvec ); 
a601 1
		endline();
d643 7
a649 1
	color( MAP_ENTRY(colour) );
d664 15
a678 4
	if((nvec = MAP_ENTRY(DM_YELLOW)) != ovec) {
	  	if(cueing_on) shaderange(nvec, nvec, 0, 768);
		color( nvec );
	  	ovec = nvec;
d797 3
a799 1
		  || ret == F1KEY || ret == F2KEY || ret == F3KEY ) {
d890 17
a1169 12
 * Color Map table
 */
#define NSLOTS		4080	/* The mostest possible - may be fewer */
static int ir_nslots=0;		/* how many we have, <= NSLOTS */
static int slotsused;		/* how many actually used */
static struct rgbtab {
	unsigned char	r;
	unsigned char	g;
	unsigned char	b;
} ir_rgbtab[NSLOTS];

/*
d1172 1
a1172 1
 *  Go through the mater table, and allocate color map slots.
a1178 1
	register struct mater *mp;
d1182 25
a1222 1
	if( ir_debug )  printf("colorchange\n");
a1223 6
	/* Program the builtin colors */
	ir_rgbtab[0].r=0; ir_rgbtab[0].g=0; ir_rgbtab[0].b=0;/* Black */
	ir_rgbtab[1].r=255; ir_rgbtab[1].g=0; ir_rgbtab[1].b=0;/* Red */
	ir_rgbtab[2].r=0; ir_rgbtab[2].g=0; ir_rgbtab[2].b=255;/* Blue */
	ir_rgbtab[3].r=255; ir_rgbtab[3].g=255;ir_rgbtab[3].b=0;/*Yellow */
	ir_rgbtab[4].r = ir_rgbtab[4].g = ir_rgbtab[4].b = 255; /* White */
a1224 2
	slotsused = 5;

a1234 2
	/* Re-send the tree, with the new colors attached */
	Ir_viewchange( DM_CHGV_REDO, SOLID_NULL );
d1246 2
d1327 2
a1328 1
 *	maps the mater color entries into the appropriate colormap entry
d1333 2
a1334 1
 * 	Note that the colormap ramps are generated from bright to dim.
d1343 1
a1343 1
		 *  map entries, which is a no, no.
d1354 6
a1359 4
			for(i = 0, red = ir_rgbtab[c].r,
			  green = ir_rgbtab[c].g, blue = ir_rgbtab[c].b;
			  i < 16;
			  i++, red -= r_inc, green -= g_inc, blue -= b_inc)
d1381 2
a1382 1
		| (perspective_on << 2);
a1391 1
#include <math.h>
d1412 19
@


8.9
log
@SGI claims the 4D GTX machines need quad-word (16 byte)
alignment for the v3f() argument, so this hack provides that.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 8.8 89/04/06 20:39:05 mike Locked $ (BRL)";
@


8.8
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 8.7 89/03/04 02:14:49 mike Locked $ (BRL)";
d411 2
a412 1
	register float gtvec[3];
d418 9
@


8.7
log
@Used SGI "inventory" function to determine if this machine is
a GT or not.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 8.6 89/01/19 22:18:30 mike Locked $ (BRL)";
d37 1
@


8.6
log
@Switched from leaving 16 to 32 color map slots unused,
to reflect additional 4Sight needs in Release 3.1
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/spark/m/cad/mged/RCS/dm-4d.c,v 8.5 89/01/18 01:55:50 mike Exp $ (BRL)";
d41 2
d44 2
d142 1
d197 1
d199 13
d457 2
d467 1
d472 24
a495 10
	color( nvec );

#ifdef SGI4D_GT
	first = 1;
	for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
		/* Viewing region is from -1.0 to +1.0 */
		if( vp->vl_draw == 0 )  {
			/* Move, not draw */
			if ( first )
				first = 0;
d497 1
a497 2
				endline();
			bgnline();
a498 5
		mptr = &(vp->vl_pnt[0]);
		gtvec[0] = *mptr;
		gtvec[1] = *(mptr+1);
		gtvec[2] = *(mptr+2); 
		v3f( gtvec ); 
a499 10
	endline();
#else
	for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
		/* Viewing region is from -1.0 to +1.0 */
		if( vp->vl_draw == 0 )
			move( vp->vl_pnt[X], vp->vl_pnt[Y], vp->vl_pnt[Z] );
		else
			draw( vp->vl_pnt[X], vp->vl_pnt[Y], vp->vl_pnt[Z] );
	}
#endif
d549 1
a551 2
	
	color( nvec );
@


8.5
log
@Includes changes in how MGED colors the various solids.
Externally, the color selection now matches that used by RT.
Internally, this was accomplished by adding 3 more fields
to the solid table (s_basecolor[], s_color[], s_dmindex),
and eliminating the mt_dm_int value from the region-id-based
material table.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 8.4 88/12/06 01:02:30 mike Locked $ (BRL)";
d170 5
a174 1
#define map_entry(x)	((cueing_on) ? ((x) * 16) : ((x) + 16))
d435 1
a435 1
		ovec = nvec = map_entry(DM_WHITE);
d439 1
a439 1
		if( (nvec = map_entry( sp->s_dmindex )) != ovec) {
d512 1
a512 1
	color( map_entry(colour) );
d527 1
a527 1
	if((nvec = map_entry(DM_YELLOW)) != ovec) {
d1035 1
d1037 2
a1038 1
		ir_nslots = ir_nslots / 16 - 1;	/* peel off reserved ones */
d1041 1
a1041 1
		ir_nslots -= 16;	/* peel off the reserved entries */
a1043 1
	if( ir_nslots > NSLOTS )  ir_nslots = NSLOTS;
d1162 2
a1163 2
 *	Non depthcued mode skips the first 16 colormap entries.  Also note
 * 	that the colormap ramps are generated from bright to dim.
d1171 1
a1171 1
		 *  which, doing so, would overwrite the bottom 16 color
d1187 4
a1190 2
				mapcolor(c * 16 + i, (short)red, (short)green,
				  (short)blue);
d1193 2
a1194 1
		mapcolor(c+16, ir_rgbtab[c].r, ir_rgbtab[c].g, ir_rgbtab[c].b);
@


8.4
log
@Fixed problem with initializing dials,
changed to using raytrace.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/dm-4d.c,v 1.3 88/10/30 00:48:24 mike Exp $ (BRL)";
d430 1
a430 1
	if( white || sp->s_materp == (char *)0 ) {
d435 1
a435 3
		if((nvec =
		  map_entry(((struct mater *)sp->s_materp)->mt_dm_int))
		  != ovec) {
a1049 2
	for( mp = MaterHead; mp != MATER_NULL; mp = mp->mt_forw )
		ir_colorit( mp );
d1051 2
a1052 1
	color_soltab();		/* apply colors to the solid table */
d1054 3
d1067 1
a1067 2
ir_colorit( mp )
struct mater *mp;
d1069 1
d1074 9
a1082 8
	r = mp->mt_r;
	g = mp->mt_g;
	b = mp->mt_b;
	if( (r == 255 && g == 255 && b == 255) ||
	    (r == 0 && g == 0 && b == 0) )  {
		mp->mt_dm_int = DM_WHITE;
		return;
	}
d1084 7
a1090 6
	/* First, see if this matches an existing color map entry */
	rgb = ir_rgbtab;
	for( i = 0; i < slotsused; i++, rgb++ )  {
		if( rgb->r == r && rgb->g == g && rgb->b == b )  {
			 mp->mt_dm_int = i;
			 return;
a1091 1
	}
d1093 11
a1103 8
	/* If slots left, create a new color map entry, first-come basis */
	if( slotsused < ir_nslots )  {
		rgb = &ir_rgbtab[i=(slotsused++)];
		rgb->r = r;
		rgb->g = g;
		rgb->b = b;
		mp->mt_dm_int = i;
		return;
a1104 1
	mp->mt_dm_int = DM_YELLOW;	/* Default color */
@


8.3
log
@Added blanktime() call to light up screen when MGED starts.
really really Release 3.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 8.3 88/10/06 05:16:21 mike Rel3_0 $ (BRL)";
d34 1
d227 3
a229 1
	for(i = DIAL0; i <= DIAL8; i++) {
a230 2
		setvaluator(i, 0, -2048-NOISE, 2047+NOISE);
	}
@


8.2
log
@Fixed problem with unreliable middle mouse events on a 4D/GT.
Added "pending_middlemouse" state flag to cope with new time
delays from 4Sight in handling of tie()'ed events.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 8.1 88/10/05 00:35:49 mike Locked $ (BRL)";
d268 6
@


8.1
log
@Release_3.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 1.8 88/09/21 06:20:02 mike Exp $ (BRL)";
d630 1
d824 2
a825 1
				dm_values.dv_penpress = DV_PICK;
d837 16
d941 1
d947 1
d1223 2
a1224 2
#ifndef SGI4D_Rel2
/* Fakeouts so that we don't have to link with -lmpc */
@


1.8
log
@This version supports both the GT and the regular 4D.
Note that as of this writing, there remains a "middle mouse"
event eating problem (or buffer switching problem), still to be resolved.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 1.7 88/09/17 02:24:06 mike Locked $ (BRL)";
@


1.7
log
@reworked open and close operations. tidied up knobs and buttons a bit.
@
text
@d2 1
a2 1
 *			D M - I R I S . C
d4 1
a4 1
 *  Uses library -lgl2
d6 1
a6 1
 *  NON-displaylist version.
a7 12
 *  MGED display manager for the IRIS.
 *  Based on dm-mer.c
 *
 *  Display structure -
 *	ROOT LIST = { wrld }
 *	wrld = { face, Mvie, Medi }
 *	face = { faceplate stuff, 2d lines and text }
 *	Mvie = { model2view matrix, view }
 *	view = { (all non-edit solids) }
 *	Medi = { model2objview matrix, edit }
 *	edit = { (all edit solids) }
 *
d9 1
d11 1
a11 1
 *	Paul R. Stay
d19 1
a19 1
 *	This software is Copyright (C) 1985 by the United States Army.
a20 2
 *
 *  Now with BUTTONS and KNOBS! - Ron Natalie, BRL,  3 Oct, 1986
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 1.6 88/09/07 11:14:07 reschly Locked $ (BRL)";
a39 1
#include <gl/immed.h>
a57 4
#define	IR_BUTTONS	32
#define	IR_KNOBS	8


d323 4
d328 1
a343 1
	gflush();
a360 2
	im_setup;
	
a378 1
	im_setup;
d380 5
d400 4
a403 4
	im_dirty_matrixstack;
	GEWAIT;
	
	im_outshort(GEloadmm);
d405 1
a405 19
	im_outfloat( *m++);
	im_outfloat( *m++);
	im_outfloat( *m++);
	im_outfloat( *m++);
	GEWAIT;
	im_outfloat( *m++);
	im_outfloat( *m++);
	im_outfloat( *m++);
	im_outfloat( *m++);
	GEWAIT;
	im_outfloat( *m++);
	im_outfloat( *m++);
	im_outfloat( *m++);
	im_outfloat( *m++);
	GEWAIT;
	im_outfloat( *m++);
	im_outfloat( *m++);
	im_outfloat( *m++);
	im_last_outfloat( *m++);
d407 1
a419 2
	

d421 1
a421 5
	{
		GEWAIT;
		im_passcmd(2, FBClinestyle);
		im_last_outshort( 0xCF33 );
	}
d441 1
a441 1
	im_color( nvec );
d443 2
d449 5
a453 4
			im_outshort( GEmove | GEPA_3F );
		}  else  {
			/* draw */
			im_outshort( GEdraw | GEPA_3F );
d455 5
a459 2
		im_out3F( vp->vl_pnt[X], vp->vl_pnt[Y], vp->vl_pnt[Z] );

d461 10
a471 2
	GEWAIT;

d473 1
a473 5
	{
		GEWAIT;
		im_passcmd(2, FBClinestyle);
		im_last_outshort( 0xFFFF );
	}
a486 1
	gflush();		/* Flush any pending output */
d500 1
d502 3
a504 13
	im_setup;

	/*
	 * HACK ALERT!  The following is a quick first attempt at turning
	 * off all text except vertices in the small graphics window.
	 */
	if( (big_txt == 0) || ((strlen(str) == 1) && (colour == DM_WHITE))) {
		im_cmov2( GED2IRIS(x), GED2IRIS(y));

		im_color( map_entry(colour) );

		charstr( str );
	}
a516 1
	im_setup;
d523 1
a523 1
	im_color( nvec );
d525 2
a526 7
	if( dashed )  {
		GEWAIT;
		im_passcmd(2, FBClinestyle);
		im_last_outshort( 0xFFFF );
	}
	im_move2( GED2IRIS(x1), GED2IRIS(y1));
	im_draw2( GED2IRIS(x2), GED2IRIS(y2));
d528 5
a532 5
	if( dashed )  {
		GEWAIT;
		im_passcmd(2, FBClinestyle);
		im_last_outshort( 0xFFFF );
	}
a1167 1
#ifdef never
a1173 1
#endif
d1202 7
@


1.6
log
@Fixed solid dash problem
@
text
@d36 1
a36 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 1.5 88/07/21 05:25:10 stay Locked $ (BRL)";
d146 1
d193 5
a197 2
 * Fire up the display manager, and the display processor.
 *
d199 1
a206 2
	prefposition( 0, 10, 0, 10);
	winopen("dummy");
a232 2
/* 	swapinterval( 5 );*/

d238 11
a249 1
	ir_dbtext("dm_ir");
d265 2
a271 13
#endif
#if IR_KNOBS
	/*
	 *  Turn on the dials and initialize them for -2048 to 2047
	 *  range with a dead spot at zero (Iris knobs are 1024 units
	 *  per rotation).
	 */
	for(i = DIAL0; i <= DIAL8; i++) {
		qdevice(i);
		setvaluator(i, 0, -2048-NOISE, 2047+NOISE);
	}
	ir_dbtext(ir_title);
#endif
d293 2
a294 1
 *  Gracefully release the display.
d303 1
d306 2
a307 4
	frontbuffer(1);
	clear();

	greset();
@


1.5
log
@fixed help key label
@
text
@d36 1
a36 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 1.4 88/06/27 10:57:04 phil Locked $ (BRL)";
a449 3
	GEWAIT;
	im_passcmd(2, FBClinestyle);
	im_last_outshort( 0xFFFF );
d451 7
d493 6
a498 2
	im_passcmd(2, FBClinestyle);
	im_last_outshort( 0xFFFF );
@


1.4
log
@Take out turing on the PF lights as it slows it down
We can now also take out swapinterval.
@
text
@d36 1
a36 1
static char RCSid[] = "@@(#)$Header: /n/m/cad/mged/RCS/dm-4d.c,v 1.3 88/02/25 06:04:59 mike Exp $ (BRL)";
d118 2
a119 2
	/* 0 */ "adc <2",	/* 1 */ "zoom", 
	/* 2 */ "adc <1",	/* 3 */ "adc dist",
@


1.3
log
@Modified for new vector lists
@
text
@d36 1
a36 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 1.2 88/01/20 15:11:43 mike Locked $ (BRL)";
d230 1
a230 1
	swapinterval( 5 );
d1201 1
d1208 1
@


1.2
log
@fixed machine.h entry....
@
text
@d36 1
a36 1
static char RCSid[] = "@@(#)$Header: dm-4d.c,v 1.1 88/01/13 12:24:25 stay Locked $ (BRL)";
d394 1
a394 1
	register struct veclist *vp;
d474 1
a474 2
	nvec = sp->s_vlen;
	for( vp = sp->s_vlist; nvec-- > 0; vp++ )  {
d476 1
a476 1
		if( vp->vl_pen == PEN_UP )  {
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
static char RCSid[] = "@@(#)$Header: dm-ir.c,v 7.1 87/11/02 23:59:16 mike Rel $ (BRL)";
d44 1
a44 1
#include "./machine.h"	/* special copy */
@
