head	11.10;
access;
symbols
	ansi-20040405-merged:11.7.2.1
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.7
	premerge-autoconf:11.7
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.7
	autoconf-20031203:11.7
	autoconf-20031202:11.7
	autoconf-branch:11.7.0.10
	phong-branch:11.7.0.8
	photonmap-branch:11.7.0.6
	rel-6-1-DP:11.7
	windows-branch:11.7.0.4
	rel-6-0-2:11.5
	ansi-branch:11.7.0.2
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.6
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.3
	offsite-5-3-pre:11.5
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.3
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.10
date	2004.05.21.17.47.36;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2002.08.20.17.08.21;	author jra;	state Exp;
branches
	11.7.2.1;
next	11.6;

11.6
date	2002.08.15.20.55.32;	author hartley;	state Exp;
branches;
next	11.5;

11.5
date	2000.08.24.22.11.30;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.08.19.03.10.41;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.08.25.14.51.05;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	97.08.22.22.38.22;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.40;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.12.16.20.38.59;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.12.16.19.35.31;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.11.05.03.58.34;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.23.18.42.30;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.08.23.18.29.50;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.08.23.16.56.36;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.09.14.50.37;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.07;	author mike;	state Rel4_0;
branches;
next	1.1;

1.1
date	91.09.20.15.43.40;	author mike;	state Exp;
branches;
next	;

11.7.2.1
date	2002.09.19.18.01.59;	author morrison;	state Exp;
branches;
next	;


desc
@Compute bounding polygon
@


11.10
log
@moved to src/mged/
@
text
@/*
 *			C A D _ B O U N D P . C
 *
 *	cad_boundp -- bounding polygon of two-dimensional view
 *
 *  Author -
 *	D A Gwyn
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 *
 * NOTES FOR MAINTAINER:
 *
 *	This program is somewhat slow when operating on large input
 *	sets.  The following ideas should improve the speed, possibly
 *	at the expense of maximum data set size:
 *
 *	(1)  Merge the Chop() and Build() phases.  Since Chop() examines
 *	segment endpoints anyway, it is in a good position to build the
 *	linked lists used by Search().
 *
 *	(2)  Sort the input endpoints into a double tree on X and Y.
 *	This should cut Chop() from order N ^ 2 to N * log( N ).
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/cad_boundp.c,v 11.9 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <math.h>
#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#ifdef HAVE_STDARG_H
#include	<stdarg.h>
#else
#include	<varargs.h>
#endif

#include "machine.h"
#include "bu.h"
#include "externs.h"

#include "./vld_std.h"

typedef struct
	{
	/* The following are float instead of double, to save space: */
	float		x;		/* X coordinate */
	float		y;		/* Y coordinate */
}	coords; 		/* view-coordinates of point */

typedef struct segment
{
	struct segment	*links; 	/* segment list thread */
	coords		sxy;		/* (X,Y) coordinates of start */
	coords		exy;		/* (X,Y) coordinates of end */
}	segment;		/* entry in list of segments */

struct queue;				/* (to clear from name space) */

typedef struct point
{
	struct point	*linkp; 	/* point list thread */
	struct queue	*firstq;	/* NULL once output */
	coords		xy;		/* (X,Y) coordinates of point */
}	point;			/* entry in list of points */

typedef struct queue
{
	struct queue	*nextq; 	/* endpoint list thread */
	point		*endpoint;	/* -> endpt of ray from point */
}	queue;			/* entry in list of endpoints */

#ifdef HAVE_STDARG_H
static bool	Mess(char *fmt, ...);
#else
static bool	Mess();
#endif
static bool	Build(void), Chop(void), EndPoint(register coords *p, register segment *segp), GetArgs(int argc, char **argv), Input(register segment *inp),
Near(register coords *ap, register coords *bp), Search(void), Split(coords *p, register segment *oldp, register segment *listh), Usage(void);
static coords	*Intersect(register segment *a, register segment *b);
static point	*LookUp(register coords *coop), *NewPoint(register coords *coop), *PutList(register coords *coop);
static pointer	Alloc(unsigned int size);
static queue	*Enqueue(register point *addp, register point *startp);
static void	Output(register coords *coop), Toss(register pointer ptr);

static bool	initial = true; 	/* false after first Output */
static bool	vflag = false;		/* set if "-v" option found */
static double	tolerance = 0.0;	/* point matching slop */
static double	tolsq = 0.0;		/* `tolerance' ^ 2 */
static point	*headp = NULL;		/* head of list of points */
static segment	seghead = { 
	&seghead };	/* segment list head */


static bool
Usage(void) 				/* print usage message */
{
	return
	    Mess( "usage: cad_boundp[ -i input][ -o output][ -t tolerance][ -v]" );
}


int
main(int argc, char **argv)			/* "cad_boundp" entry point */
   	     			/* argument count */
    	        		/* argument strings */
{
	if ( !GetArgs( argc, argv ) )	/* process command arguments */
		return 1;

	if ( !Chop() )			/* input; chop into segments */
		return 2;

	if ( !Build() ) 		/* build linked lists */
		return 3;

	if ( !Search() )		/* output bounding polygon */
		return 4;

	return 0;			/* success! */
}


static bool
GetArgs(int argc, char **argv)			/* process command arguments */
   		     		/* argument count */
    		        	/* argument strings */
{
	static bool	iflag = false;	/* set if "-i" option found */
	static bool	oflag = false;	/* set if "-o" option found */
	static bool	tflag = false;	/* set if "-t" option found */
	int		c;		/* option letter */

#ifdef	DEBUG
	(void)Mess( "\n\t\tGetArgs\n" );
#endif
	while ( (c = bu_getopt( argc, argv, "i:o:t:v" )) != EOF )
		switch ( c )
		{
		case 'i':
			if ( iflag )
				return
				    Mess( "too many -i options" );
			iflag = true;

			if ( strcmp( bu_optarg, "-" ) != 0
			    && freopen( bu_optarg, "r", stdin ) == NULL
			    )
				return
				    Mess( "can't open \"%s\"", bu_optarg );
			break;

		case 'o':
			if ( oflag )
				return
				    Mess( "too many -o options" );
			oflag = true;

			if ( strcmp( bu_optarg, "-" ) != 0
			    && freopen( bu_optarg, "w", stdout ) == NULL
			    )
				return
				    Mess( "can't create \"%s\"", bu_optarg );
			break;

		case 't':
			if ( tflag )
				return
				    Mess( "too many -t options" );
			tflag = true;

			if ( sscanf( bu_optarg, "%le", &tolerance ) != 1 )
				return
				    Mess( "bad tolerance: %s", bu_optarg );
			tolsq = tolerance * tolerance;
			break;

		case 'v':
			vflag = true;
			break;

		case '?':
			return Usage(); /* print usage message */
		}

	return true;
}


/*
	The following phase is required to chop up line segments that
	intersect; this guarantees that all polygon vertices will be
	found at segment endpoints.  Unfortunately, this is an N^2
	process.  It is also hard to do right; thus the elaborateness.
*/

static bool
Chop(void)					/* chop vectors into segments */
{
	segment *inp;			/* -> input whole segment */

#ifdef	DEBUG
	(void)Mess( "\n\t\tChop\n" );
#endif
	/* Although we try to Alloc() when no input remains, it is more
	   efficient than repeatedly copying the input into *inp.     */
	while ( (inp = (segment *)Alloc( (unsigned)sizeof(segment) )) != NULL
	    && Input( inp )
	    ) {
		register segment	*segp;	/* segment list entry */
		segment 		piecehead;
		/* list of inp pieces */
		register segment	*pp;	/* -> pieces of `inp' */

		/* Reverse the segment if necessary to get endpoints
		   in left-to-right order; speeds up range check. */

		if ( inp->sxy.x > inp->exy.x )
		{
			coords	temp;		/* store for swapping */

#ifdef	DEBUG
			(void)Mess( "endpoints swapped" );
#endif
			temp = inp->sxy;
			inp->sxy = inp->exy;
			inp->exy = temp;
		}

		/* Split input and segment list entries into pieces. */

		inp->links = &piecehead;
		piecehead.links = inp;	/* initially, one piece */

		/* Note:  Although the split-off pieces of `segp' are
		   linked in front of `segp', that's okay since they
		   cannot intersect `inp' again!		      */
		for ( segp = seghead.links; segp != &seghead;
		    segp = segp->links
		    )
			/* Similarly, once a piece of `inp' intersects
			   `segp', we can stop looking at the pieces. */
			for ( pp = piecehead.links; pp != &piecehead;
			    pp = pp->links
			    )	{
				register coords *i;	/* intersectn */

				/* Be careful; `i' -> static storage
				   internal to Intersect().	      */
				i = Intersect( pp, segp );
				if ( i != NULL )
				{
					if ( ( !EndPoint( i, pp  )
					    && !Split( i, pp, &piecehead ) )
					    || ( !EndPoint( i, segp )
					    && !Split( i, segp, &seghead ) )
					    )	/* out of memory */
						return false;

					break;	/* next `segp' */
				}
			}
#ifdef	DEBUG
		(void)Mess( "new input pieces:" );
		for ( pp = piecehead.links; pp != &piecehead;
		    pp = pp->links
		    )
			(void)Mess( "\t(%g,%g)->(%g,%g)",
			    (double)pp->sxy.x,
			    (double)pp->sxy.y,
			    (double)pp->exy.x,
			    (double)pp->exy.y
			    );
		(void)Mess( "other segments:" );
		for ( segp = seghead.links; segp != &seghead;
		    segp = segp->links
		    )
			(void)Mess( "\t(%g,%g)->(%g,%g)",
			    (double)segp->sxy.x,
			    (double)segp->sxy.y,
			    (double)segp->exy.x,
			    (double)segp->exy.y
			    );
#endif

		/* Put input segment pieces into segment list. */

		/* Note:  It is better to scan the pieces to find the
		   tail link than to waste storage on double links. */
		for ( pp = piecehead.links; pp->links != &piecehead;
		    pp = pp->links
		    )
			;
		pp->links = seghead.links;	/* last-piece link */
		seghead.links = piecehead.links;	/* add pieces */
	}
	Toss( (pointer)inp );		/* unused segment at EOF */

	return inp != NULL;
}


static bool
Split(coords *p, register segment *oldp, register segment *listh) 		/* split segment in two */
      			   	/* -> break point */
                	      	/* -> segment to be split */
                	        /* -> list to attach tail to */
{
	register segment	*newp;	/* -> new list entry */

#ifdef	DEBUG
	(void)Mess( "split (%g,%g)->(%g,%g) at (%g,%g)",
	    (double)oldp->sxy.x, (double)oldp->sxy.y,
	    (double)oldp->exy.x, (double)oldp->exy.y,
	    (double)p->x, (double)p->y
	    );
#endif
	if ( (newp = (segment *)Alloc( (unsigned)sizeof(segment) )) == NULL )
		return false;		/* out of heap space */
	newp->links = listh->links;
	newp->sxy = *p;
	newp->exy = oldp->exy;
	oldp->exy = *p; 		/* old entry, new endpoint */
	listh->links = newp;		/* attach to list head */

	return true;
}


static bool
Build(void) 				/* build linked lists */
{
	register segment	*listp; /* -> segment list entry */
	segment 		*deadp; /* -> list entry to be freed */

#ifdef	DEBUG
	(void)Mess( "\n\t\tBuild\n" );
#endif
	/* When we are finished, `seghead' will become invalid. */
	for ( listp = seghead.links; listp != &seghead;
	    deadp = listp, listp = listp->links, Toss( (pointer)deadp )
	    )	{
		register point	*startp, *endp; /* -> segment endpts */

		if ( (startp = PutList( &listp->sxy )) == NULL
		    || (endp   = PutList( &listp->exy )) == NULL
		    || Enqueue( startp, endp ) == NULL
		    || Enqueue( endp, startp ) == NULL
		    )
			return false;	/* out of heap space */
	}

	return	true;
}


static bool
Search(void)				/* output bounding polygon */
{
	double		from;		/* backward edge direction */
	register point	*currentp;	/* -> current (start) point */
	point		*previousp;	/* -> previous vertex point */

#ifdef	DEBUG
	(void)Mess( "\n\t\tSearch\n" );
#endif
	if ( headp == NULL )
		return true;		/* trivial case */

	/* Locate the lowest point; this is the first polygon vertex. */
	{
		float		miny;		/* smallest Y coordinate */
		register point	*listp; 	/* -> next point in list */

		currentp = listp = headp;
		miny = currentp->xy.y;
		while ( (listp = listp->linkp) != NULL )
			if ( listp->xy.y < miny )
			{
				miny = listp->xy.y;
				currentp = listp;
			}
	}
	previousp = NULL;		/* differs from currentp! */
	from = 270.0;

	/* Output point and look for next CCW point on periphery. */

	for ( ; ; )
	{
		coords		first;	/* first output if -v */
		double		mindir; /* smallest from->to angle */
		register point	*nextp = (point *)NULL; /* -> next perimeter point */
		queue		*endq;	/* -> endpoint queue entry */

#ifdef	DEBUG
		(void)Mess( "from %g", from );
#endif
		endq = currentp->firstq;
		if ( endq == NULL )
		{
			if ( vflag && !initial )
				Output( &first );	/* closure */

			return true;	/* been here before => done */
		}

		Output( &currentp->xy );	/* found vertex */
		if ( vflag && initial )
		{
			initial = false;
			first = currentp->xy;	/* save for closure */
		}

		/* Find the rightmost forward edge endpoint. */

		mindir = 362.0;
		do	{
			double		to;	/* forward edge dir */
			double		diff;	/* angle from->to */
			register point	*endp;	/* -> endpoint */

			endp = endq->endpoint;
			if ( endp == previousp	/* don't double back! */
			|| endp == currentp	/* don't stay here! */
			)
				continue;

			/* Note: it would be possible to save some calls
			   to atan2 by being clever about quadrants.  */
			if ( endp->xy.y == currentp->xy.y
			    && endp->xy.x == currentp->xy.x
			    )
				to = 0.0;	/* not supposed to happen */
			else
				to = atan2( (double)
				    (endp->xy.y - currentp->xy.y),
				    (double)
				    (endp->xy.x - currentp->xy.x)
				    ) * DEGRAD;
#ifdef	DEBUG
			(void)Mess( "to %g", to );
#endif
			diff = to - from;
			/* Note: Exact 360 (0) case is not supposed to
			   happen, but this algorithm copes with it.  */
			while ( diff <= 0.0 )
				diff += 360.0;

			if ( diff < mindir )
			{
#ifdef	DEBUG
				(void)Mess( "new min %g", diff );
#endif
				mindir = diff;
				nextp = endp;
			}
		} while ( (endq = endq->nextq) != NULL );

		if ( mindir > 361.0 )
			return Mess( "degenerate input" );

		currentp->firstq = NULL;	/* "visited" */
		previousp = currentp;
		currentp = nextp;

		from += mindir + 180.0; /* reverse of saved "to" */
		/* The following is needed only to improve accuracy: */
		while ( from > 360.0 )
			from -= 360.0;	/* reduce to range [0,360) */
	}
}


static point *
PutList(register coords *coop) 			/* return -> point in list */
                      		/* -> coordinates */
{
	register point	*p;		/* -> list entry */

	p = LookUp( coop );		/* may already be there */
	if ( p == NULL )		/* not yet in list */
	{			/* start new point group */
#ifdef	DEBUG
		(void)Mess( "new point group (%g,%g)",
		    (double)coop->x, (double)coop->y
		    );
#endif
		p = NewPoint( coop );
#if 0
			if ( p == NULL )
			return NULL;	/* out of heap space */
#endif
	}

	return p;			/* -> point list entry */
}


static point *
LookUp(register coords *coop)				/* find point group in list */
                      		/* -> coordinates */
{
	register point	*p;		/* -> list members */

	for ( p = headp; p != NULL; p = p->linkp )
		if ( Near( coop, &p->xy ) )
		{
#ifdef	DEBUG
			(void)Mess( "found (%g,%g) in list",
			    (double)coop->x, (double)coop->y
			    );
#endif
			return p;	/* found a match */
		}

	return NULL;			/* not yet in list */
}


static point *
NewPoint(register coords *coop)			/* add point to list */
                      		/* -> coordinates */
{
	register point	*newp;		/* newly allocated point */

	newp = (point *)Alloc( (unsigned)sizeof(point) );
	if ( newp == NULL )
		return NULL;

#ifdef	DEBUG
	(void)Mess( "add point (%g,%g)",
	    (double)coop->x, (double)coop->y
	    );
#endif
	newp->linkp = headp;
	newp->firstq = NULL;		/* empty endpoint queue */
	newp->xy = *coop;		/* coordinates */
	return headp = newp;
}


static queue *
Enqueue(register point *addp, register point *startp) 		/* add to endpoint queue */
              	      		/* -> point being queued */
              	        	/* -> point owning queue */
{
	register queue	*newq;		/* new queue element */

	newq = (queue *)Alloc( (unsigned)sizeof(queue) );
	if ( newq == NULL )
		return NULL;

#ifdef	DEBUG
	(void)Mess( "enqueue (%g,%g) on (%g,%g)",
	    (double)addp->xy.x, (double)addp->xy.y,
	    (double)startp->xy.x, (double)startp->xy.y
	    );
#endif
	newq->nextq = startp->firstq;
	newq->endpoint = addp;
	return startp->firstq = newq;
}


static coords *
Intersect(register segment *a, register segment *b)			/* determine intersection */
                	        /* segments being tested */
{
	double			det;	/* determinant, 0 if parallel */
	double			xaeas, xbebs, yaeas, ybebs;
	/* coordinate differences */

	/* First perform range check, to eliminate most cases.	Note
	   that segments point left-to-right even after splitting. */

	if ( a->sxy.x > 		/* a left */
	b->exy.x + tolerance	/* b right */
	|| a->exy.x < 		/* a right */
	b->sxy.x - tolerance	/* b left */
	|| Min( a->sxy.y, a->exy.y ) >		/* a bottom */
	Max( b->sxy.y, b->exy.y ) + tolerance	/* b top */
	|| Max( a->sxy.y, a->exy.y ) <		/* a top */
	Min( b->sxy.y, b->exy.y ) - tolerance	/* b bottom */
	)	{
#ifdef	DEBUG
		(void)Mess( "ranges don't intersect" );
#endif
		return NULL;		/* can't intersect */
	}

	/* Passed quick check, now comes the hard part. */

	xaeas = (double)a->exy.x - (double)a->sxy.x;
	xbebs = (double)b->exy.x - (double)b->sxy.x;
	yaeas = (double)a->exy.y - (double)a->sxy.y;
	ybebs = (double)b->exy.y - (double)b->sxy.y;

	det = xbebs * yaeas - xaeas * ybebs;

	{
		double	norm;			/* norm of coefficient matrix */
		double	t;			/* test value for norm */

		norm = 0.0;
		if ( (t = Abs( xaeas )) > norm )
			norm = t;
		if ( (t = Abs( xbebs )) > norm )
			norm = t;
		if ( (t = Abs( yaeas )) > norm )
			norm = t;
		if ( (t = Abs( ybebs )) > norm )
			norm = t;

#define EPSILON 1.0e-06 		/* relative `det' size thresh */
		if ( Abs( det ) <= EPSILON * norm * norm )
		{
#ifdef	DEBUG
			(void)Mess( "parallel: det=%g, norm=%g", det, norm );
#endif
			return NULL;		/* parallels don't intersect */
		}
#undef	EPSILON
	}
	{
		/* `p' must be static; Intersect returns a pointer to it! */
		static coords	p;		/* point of intersection */
		double		lambda, mu;	/* segment parameters */
		double		onemmu; 	/* 1.0 - mu, for efficiency */
		double		xbsas, ybsas;	/* more coord differences */

		xbsas = (double)b->sxy.x - (double)a->sxy.x;
		ybsas = (double)b->sxy.y - (double)a->sxy.y;

		mu = (xbebs * ybsas - xbsas * ybebs) / det;
		onemmu = 1.0 - mu;
		p.x = onemmu * a->sxy.x + mu * a->exy.x;
		p.y = onemmu * a->sxy.y + mu * a->exy.y;
		if ( (onemmu < 0.0 || mu < 0.0) && !EndPoint( &p, a ) )
		{
#ifdef	DEBUG
			(void)Mess( "intersect off (%g,%g)->(%g,%g): mu=%g",
			    (double)a->sxy.x, (double)a->sxy.y,
			    (double)a->exy.x, (double)a->exy.y,
			    mu
			    );
#endif
			return NULL;		/* not in segment *a */
		}

		lambda = (xaeas * ybsas - xbsas * yaeas) / det;
		if ( (lambda > 1.0 || lambda < 0.0) && !EndPoint( &p, b ) )
		{
#ifdef	DEBUG
			(void)Mess( "intersect off (%g,%g)->(%g,%g): lambda=%g",
			    (double)b->sxy.x, (double)b->sxy.y,
			    (double)b->exy.x, (double)b->exy.y,
			    lambda
			    );
#endif
			return NULL;		/* not in segment *b */
		}

#ifdef	DEBUG
		(void)Mess( "intersection is (%g,%g): mu=%g lambda=%g",
		    (double)p.x, (double)p.y, mu, lambda
		    );
#endif
		return &p;
	}
}


static bool
EndPoint(register coords *p, register segment *segp)			/* check for segment endpoint */
                	   	/* -> point being tested */
                	      	/* -> segment */
{
#ifdef	DEBUG
	if ( Near( p, &segp->sxy ) || Near( p, &segp->exy ) )
		(void)Mess( "(%g,%g) is endpt of (%g,%g)->(%g,%g)",
		    (double)p->x, (double)p->y,
		    (double)segp->sxy.x, (double)segp->sxy.y,
		    (double)segp->exy.x, (double)segp->exy.y
		    );
#endif
	return Near( p, &segp->sxy ) || Near( p, &segp->exy );
}


static bool
Near(register coords *ap, register coords *bp)				/* check if within tolerance */
                         	/* -> points being checked */
{
	double		xsq, ysq;	/* dist between coords ^ 2 */

	/* Originally this was an abs value test; this is neater. */

	xsq = ap->x - bp->x;
	xsq *= xsq;
	ysq = ap->y - bp->y;
	ysq *= ysq;

#ifdef	DEBUG
	if ( xsq + ysq <= tolsq )
		(void)Mess( "(%g,%g) is near (%g,%g)",
		    (double)ap->x, (double)ap->y,
		    (double)bp->x, (double)bp->y
		    );
#endif
	return xsq + ysq <= tolsq;
}


static pointer
Alloc(unsigned int size)				/* allocate storage from heap */
        		     	/* # bytes required */
{
	register pointer	ptr;	/* -> allocated storage */

	if ( (ptr = malloc( size * sizeof(char) )) == NULL )
		(void)Mess( "out of memory" );

	return ptr;			/* (may be NULL) */
}


static void
Toss(register pointer ptr)				/* return storage to heap */
                	    	/* -> allocated storage */
{
	if ( ptr != NULL )
		free( ptr );
}


/*VARARGS*/
static bool
#ifdef HAVE_STDARG_H
Mess( char *fmt, ... )			/* print error message */
#else
Mess( va_alist )			/* print error message */
va_dcl					/* format, optional arguments */
#endif
{
	va_list		ap;		/* for accessing arguments */
#ifndef HAVE_STDARG_H
	register char	*fmt;		/* format */

	va_start( ap );
	fmt = va_arg( ap, char * );
#else
	va_start( ap, fmt );
#endif
	(void)fflush( stdout );
	(void)fputs( "cad_boundp: ", stderr );
#ifdef HAVE_VPRINTF
	(void)vprintf( fmt, ap );
#else
	(void) _doprnt( fmt, ap, stderr );
#endif
	(void)fputc( '\n', stderr );

	va_end( ap );

	return false;
}


static bool
Input(register segment *inp)				/* input stroke record */
                	     	/* -> input segment */
{
	char			inbuf[82];	/* record buffer */

	while ( fgets( inbuf, (int)sizeof inbuf, stdin ) != NULL )
	{			/* scan input record */
		register int	cvt;	/* # fields converted */

#ifdef	DEBUG
		(void)Mess( "input: %s", inbuf );
#endif
		cvt = sscanf( inbuf, " %e %e %e %e",
		    &inp->sxy.x, &inp->sxy.y,
		    &inp->exy.x, &inp->exy.y
		    );

		if ( cvt == 0 )
			continue;	/* skip color, comment, etc. */

		if ( cvt == 4 )
			return true;	/* successfully converted */

		(void)Mess( "bad input: %s", inbuf );
		exit( 5 );		/* return false insufficient */
	}

	return false;			/* EOF */
}


static void
Output(register coords *coop)				/* dump polygon vertex coords */
                      		/* -> coords to be output */
{
	static coords	last;		/* previous *coop */

	if ( vflag )
	{
		if ( !initial )
			printf( "%g %g %g %g\n",
			    (double)last.x, (double)last.y,
			    (double)coop->x, (double)coop->y
			    );

		last = *coop;		/* save for next start point */
	}
	else
		printf( "%g %g\n",
		    (double)coop->x, (double)coop->y
		    );
#ifdef	DEBUG
	(void)Mess( "output: %g %g",
	    (double)coop->x, (double)coop->y
	    );
#endif
}
@


11.9
log
@change conf.h to a wrapped config.h
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/cad_boundp.c,v 11.8 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.8
log
@merge of ansi-6-0-branch into HEAD
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d34 5
a38 1
#include "conf.h"
@


11.7
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cad_boundp.c,v 11.5 2000/08/24 22:11:30 mike Exp $ (BRL)";
d89 7
a95 7
static bool	Build(), Chop(), EndPoint(), GetArgs(), Input(),
Near(), Search(), Split(), Usage();
static coords	*Intersect();
static point	*LookUp(), *NewPoint(), *PutList();
static pointer	Alloc();
static queue	*Enqueue();
static void	Output(), Toss();
d107 1
a107 1
Usage() 				/* print usage message */
d115 3
a117 3
main( argc, argv )			/* "cad_boundp" entry point */
int	argc;			/* argument count */
char	*argv[];		/* argument strings */
d136 3
a138 3
GetArgs( argc, argv )			/* process command arguments */
int		argc;		/* argument count */
char		*argv[];	/* argument strings */
d209 1
a209 1
Chop()					/* chop vectors into segments */
d315 4
a318 4
Split( p, oldp, listh ) 		/* split segment in two */
coords			*p;	/* -> break point */
register segment	*oldp;	/* -> segment to be split */
register segment	*listh; /* -> list to attach tail to */
d342 1
a342 1
Build() 				/* build linked lists */
d369 1
a369 1
Search()				/* output bounding polygon */
d487 2
a488 2
PutList( coop ) 			/* return -> point in list */
register coords *coop;		/* -> coordinates */
d512 2
a513 2
LookUp( coop )				/* find point group in list */
register coords *coop;		/* -> coordinates */
d533 2
a534 2
NewPoint( coop )			/* add point to list */
register coords *coop;		/* -> coordinates */
d555 3
a557 3
Enqueue( addp, startp ) 		/* add to endpoint queue */
register point	*addp;		/* -> point being queued */
register point	*startp;	/* -> point owning queue */
d578 2
a579 2
Intersect( a, b )			/* determine intersection */
register segment	*a, *b; /* segments being tested */
d686 3
a688 3
EndPoint( p, segp )			/* check for segment endpoint */
register coords 	*p;	/* -> point being tested */
register segment	*segp;	/* -> segment */
d703 2
a704 2
Near( ap, bp )				/* check if within tolerance */
register coords *ap, *bp;	/* -> points being checked */
d727 2
a728 2
Alloc( size )				/* allocate storage from heap */
unsigned		size;	/* # bytes required */
d740 2
a741 2
Toss( ptr )				/* return storage to heap */
register pointer	ptr;	/* -> allocated storage */
d782 2
a783 2
Input( inp )				/* input stroke record */
register segment	*inp;	/* -> input segment */
d814 2
a815 2
Output( coop )				/* dump polygon vertex coords */
register coords *coop;		/* -> coords to be output */
@


11.7.2.1
log
@Initial ANSIfication
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cad_boundp.c,v 11.7 2002/08/20 17:08:21 jra Exp $ (BRL)";
d89 7
a95 7
static bool	Build(void), Chop(void), EndPoint(register coords *p, register segment *segp), GetArgs(int argc, char **argv), Input(register segment *inp),
Near(register coords *ap, register coords *bp), Search(void), Split(coords *p, register segment *oldp, register segment *listh), Usage(void);
static coords	*Intersect(register segment *a, register segment *b);
static point	*LookUp(register coords *coop), *NewPoint(register coords *coop), *PutList(register coords *coop);
static pointer	Alloc(unsigned int size);
static queue	*Enqueue(register point *addp, register point *startp);
static void	Output(register coords *coop), Toss(register pointer ptr);
d107 1
a107 1
Usage(void) 				/* print usage message */
d115 3
a117 3
main(int argc, char **argv)			/* "cad_boundp" entry point */
   	     			/* argument count */
    	        		/* argument strings */
d136 3
a138 3
GetArgs(int argc, char **argv)			/* process command arguments */
   		     		/* argument count */
    		        	/* argument strings */
d209 1
a209 1
Chop(void)					/* chop vectors into segments */
d315 4
a318 4
Split(coords *p, register segment *oldp, register segment *listh) 		/* split segment in two */
      			   	/* -> break point */
                	      	/* -> segment to be split */
                	        /* -> list to attach tail to */
d342 1
a342 1
Build(void) 				/* build linked lists */
d369 1
a369 1
Search(void)				/* output bounding polygon */
d487 2
a488 2
PutList(register coords *coop) 			/* return -> point in list */
                      		/* -> coordinates */
d512 2
a513 2
LookUp(register coords *coop)				/* find point group in list */
                      		/* -> coordinates */
d533 2
a534 2
NewPoint(register coords *coop)			/* add point to list */
                      		/* -> coordinates */
d555 3
a557 3
Enqueue(register point *addp, register point *startp) 		/* add to endpoint queue */
              	      		/* -> point being queued */
              	        	/* -> point owning queue */
d578 2
a579 2
Intersect(register segment *a, register segment *b)			/* determine intersection */
                	        /* segments being tested */
d686 3
a688 3
EndPoint(register coords *p, register segment *segp)			/* check for segment endpoint */
                	   	/* -> point being tested */
                	      	/* -> segment */
d703 2
a704 2
Near(register coords *ap, register coords *bp)				/* check if within tolerance */
                         	/* -> points being checked */
d727 2
a728 2
Alloc(unsigned int size)				/* allocate storage from heap */
        		     	/* # bytes required */
d740 2
a741 2
Toss(register pointer ptr)				/* return storage to heap */
                	    	/* -> allocated storage */
d782 2
a783 2
Input(register segment *inp)				/* input stroke record */
                	     	/* -> input segment */
d814 2
a815 2
Output(register coords *coop)				/* dump polygon vertex coords */
                      		/* -> coords to be output */
@


11.6
log
@Converted from K&R to ANSI C - RFH
@
text
@d89 7
a95 7
static bool	Build(void), Chop(void), EndPoint(register coords *p, register segment *segp), GetArgs(int argc, char **argv), Input(register segment *inp),
Near(register coords *ap, register coords *bp), Search(void), Split(coords *p, register segment *oldp, register segment *listh), Usage(void);
static coords	*Intersect(register segment *a, register segment *b);
static point	*LookUp(register coords *coop), *NewPoint(register coords *coop), *PutList(register coords *coop);
static pointer	Alloc(unsigned int size);
static queue	*Enqueue(register point *addp, register point *startp);
static void	Output(register coords *coop), Toss(register pointer ptr);
d107 1
a107 1
Usage(void) 				/* print usage message */
d115 3
a117 3
main(int argc, char **argv)			/* "cad_boundp" entry point */
   	     			/* argument count */
    	        		/* argument strings */
d136 3
a138 3
GetArgs(int argc, char **argv)			/* process command arguments */
   		     		/* argument count */
    		        	/* argument strings */
d209 1
a209 1
Chop(void)					/* chop vectors into segments */
d315 4
a318 4
Split(coords *p, register segment *oldp, register segment *listh) 		/* split segment in two */
      			   	/* -> break point */
                	      	/* -> segment to be split */
                	        /* -> list to attach tail to */
d342 1
a342 1
Build(void) 				/* build linked lists */
d369 1
a369 1
Search(void)				/* output bounding polygon */
d487 2
a488 2
PutList(register coords *coop) 			/* return -> point in list */
                      		/* -> coordinates */
d512 2
a513 2
LookUp(register coords *coop)				/* find point group in list */
                      		/* -> coordinates */
d533 2
a534 2
NewPoint(register coords *coop)			/* add point to list */
                      		/* -> coordinates */
d555 3
a557 3
Enqueue(register point *addp, register point *startp) 		/* add to endpoint queue */
              	      		/* -> point being queued */
              	        	/* -> point owning queue */
d578 2
a579 2
Intersect(register segment *a, register segment *b)			/* determine intersection */
                	        /* segments being tested */
d686 3
a688 3
EndPoint(register coords *p, register segment *segp)			/* check for segment endpoint */
                	   	/* -> point being tested */
                	      	/* -> segment */
d703 2
a704 2
Near(register coords *ap, register coords *bp)				/* check if within tolerance */
                         	/* -> points being checked */
d727 2
a728 2
Alloc(unsigned int size)				/* allocate storage from heap */
        		     	/* # bytes required */
d740 2
a741 2
Toss(register pointer ptr)				/* return storage to heap */
                	    	/* -> allocated storage */
d782 2
a783 2
Input(register segment *inp)				/* input stroke record */
                	     	/* -> input segment */
d814 2
a815 2
Output(register coords *coop)				/* dump polygon vertex coords */
                      		/* -> coords to be output */
@


11.5
log
@
Lint
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cad_boundp.c,v 11.4 2000/08/19 03:10:41 mike Exp $ (BRL)";
d89 7
a95 7
static bool	Build(), Chop(), EndPoint(), GetArgs(), Input(),
Near(), Search(), Split(), Usage();
static coords	*Intersect();
static point	*LookUp(), *NewPoint(), *PutList();
static pointer	Alloc();
static queue	*Enqueue();
static void	Output(), Toss();
d107 1
a107 1
Usage() 				/* print usage message */
d115 3
a117 3
main( argc, argv )			/* "cad_boundp" entry point */
int	argc;			/* argument count */
char	*argv[];		/* argument strings */
d136 3
a138 3
GetArgs( argc, argv )			/* process command arguments */
int		argc;		/* argument count */
char		*argv[];	/* argument strings */
d209 1
a209 1
Chop()					/* chop vectors into segments */
d315 4
a318 4
Split( p, oldp, listh ) 		/* split segment in two */
coords			*p;	/* -> break point */
register segment	*oldp;	/* -> segment to be split */
register segment	*listh; /* -> list to attach tail to */
d342 1
a342 1
Build() 				/* build linked lists */
d369 1
a369 1
Search()				/* output bounding polygon */
d487 2
a488 2
PutList( coop ) 			/* return -> point in list */
register coords *coop;		/* -> coordinates */
d512 2
a513 2
LookUp( coop )				/* find point group in list */
register coords *coop;		/* -> coordinates */
d533 2
a534 2
NewPoint( coop )			/* add point to list */
register coords *coop;		/* -> coordinates */
d555 3
a557 3
Enqueue( addp, startp ) 		/* add to endpoint queue */
register point	*addp;		/* -> point being queued */
register point	*startp;	/* -> point owning queue */
d578 2
a579 2
Intersect( a, b )			/* determine intersection */
register segment	*a, *b; /* segments being tested */
d686 3
a688 3
EndPoint( p, segp )			/* check for segment endpoint */
register coords 	*p;	/* -> point being tested */
register segment	*segp;	/* -> segment */
d703 2
a704 2
Near( ap, bp )				/* check if within tolerance */
register coords *ap, *bp;	/* -> points being checked */
d727 2
a728 2
Alloc( size )				/* allocate storage from heap */
unsigned		size;	/* # bytes required */
d740 2
a741 2
Toss( ptr )				/* return storage to heap */
register pointer	ptr;	/* -> allocated storage */
d782 2
a783 2
Input( inp )				/* input stroke record */
register segment	*inp;	/* -> input segment */
d814 2
a815 2
Output( coop )				/* dump polygon vertex coords */
register coords *coop;		/* -> coords to be output */
@


11.4
log
@
const RCSid
@
text
@d31 1
a31 2
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cad_boundp.c,v 11.3 1997/08/25 14:51:05 jra Exp $ (BRL)";
static char	sccsid[] = "@@(#)cad_boundp.c	1.13";
d114 1
d264 4
a267 4
					if ( !EndPoint( i, pp  )
					    && !Split( i, pp, &piecehead )
					    || !EndPoint( i, segp )
					    && !Split( i, segp, &seghead )
@


11.3
log
@Needed libbu for cad_parea and cad_boundp.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cad_boundp.c,v 11.2 1997/08/22 22:38:22 mike Exp jra $ (BRL)";
@


11.2
log
@Made use of bu_getopt() explicit, rather than depending on
#define in bu.h
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cad_boundp.c,v 11.1 1995/01/04 10:02:40 mike Rel4_4 mike $ (BRL)";
d51 1
@


11.1
log
@Release_4.4
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cad_boundp.c,v 10.8 94/12/16 20:38:59 gdurf Exp $ (BRL)";
d147 1
a147 1
	while ( (c = getopt( argc, argv, "i:o:t:v" )) != EOF )
d156 2
a157 2
			if ( strcmp( optarg, "-" ) != 0
			    && freopen( optarg, "r", stdin ) == NULL
d160 1
a160 1
				    Mess( "can't open \"%s\"", optarg );
d169 2
a170 2
			if ( strcmp( optarg, "-" ) != 0
			    && freopen( optarg, "w", stdout ) == NULL
d173 1
a173 1
				    Mess( "can't create \"%s\"", optarg );
d182 1
a182 1
			if ( sscanf( optarg, "%le", &tolerance ) != 1 )
d184 1
a184 1
				    Mess( "bad tolerance: %s", optarg );
@


10.8
log
@Fixed rt_log messup
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cad_boundp.c,v 10.7 1994/12/16 19:35:31 gdurf Exp gdurf $ (BRL)";
@


10.7
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cad_boundp.c,v 10.6 1994/11/05 03:58:34 mike Exp gdurf $ (BRL)";
d768 1
a768 1
	(void)vrt_log( fmt, ap );
d821 1
a821 1
			rt_log( "%g %g %g %g\n",
d829 1
a829 1
		rt_log( "%g %g\n",
@


10.6
log
@Irix 6
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cad_boundp.c,v 10.5 94/08/23 18:42:30 gdurf Exp Locker: mike $ (BRL)";
d768 1
a768 1
	(void)vfprintf( stderr, fmt, ap );
d821 1
a821 1
			(void)printf( "%g %g %g %g\n",
d829 1
a829 1
		(void)printf( "%g %g\n",
@


10.5
log
@Cleaned up includes
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cad_boundp.c,v 10.4 1994/08/23 18:29:50 gdurf Exp gdurf $ (BRL)";
d500 4
a503 2
		/*		if ( p == NULL )
/*			return NULL;	/* out of heap space */
@


10.4
log
@Removed losing situation
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cad_boundp.c,v 10.3 1994/08/23 16:56:36 gdurf Exp gdurf $ (BRL)";
d39 1
d41 3
a43 3

#include	"./vld_std.h"

d52 2
@


10.3
log
@Removed #error directive
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cad_boundp.c,v 10.2 1994/08/09 14:50:37 gdurf Exp $ (BRL)";
d45 1
a45 1
#elif HAVE_VARARGS_H
a46 2
#else
#include "Need to have stdarg.h or varargs.h."
@


10.2
log
@Factored ifdefs
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cad_boundp.c,v 10.1 1991/10/12 06:43:07 mike Rel4_0 gdurf $ (BRL)";
d48 1
a48 1
#error "Need to have stdarg.h or varargs.h."
@


10.1
log
@Release_4.0
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cad_boundp.c,v 1.1 91/09/20 15:43:40 mike Exp $ (BRL)";
d35 1
a35 3
#include	<math.h>
#include	<stdio.h>
#include	<string.h>
d37 4
d43 1
a43 1
#if STD_C
d45 2
d48 1
a48 1
#include	<varargs.h>
d51 2
a52 5
extern void	exit(), free();
extern pointer	malloc();
extern int	getopt();

extern char	*optarg;
d83 1
a83 1
#if STD_C
d746 1
a746 1
#if STD_C
d754 1
a754 1
#if !STD_C
d764 3
a766 1
#if defined(BSD)
a767 2
#else
	(void)vfprintf( stderr, fmt, ap );
@


1.1
log
@Initial revision
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@
