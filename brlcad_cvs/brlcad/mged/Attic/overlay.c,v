head	11.28;
access;
symbols
	ansi-20040405-merged:11.24.2.2
	postmerge-20040405-ansi:11.26
	premerge-20040404-ansi:11.25
	postmerge-autoconf:11.25
	autoconf-freeze:11.24.10.2
	premerge-autoconf:11.25
	postmerge-20040315-windows:11.25
	premerge-20040315-windows:11.25
	windows-20040315-freeze:11.24.4.1
	autoconf-20031203:11.24
	autoconf-20031202:11.24
	autoconf-branch:11.24.0.10
	phong-branch:11.24.0.8
	photonmap-branch:11.24.0.6
	rel-6-1-DP:11.24
	windows-branch:11.24.0.4
	rel-6-0-2:11.22
	ansi-branch:11.24.0.2
	rel-6-0-1-branch:11.22.0.2
	hartley-6-0-post:11.23
	hartley-6-0-pre:11.22
	rel-6-0-1:11.22
	rel-6-0:11.22
	rel-5-4:11.14
	offsite-5-3-pre:11.17
	rel-5-3:11.14
	rel-5-2:11.14
	rel-5-1-branch:11.14.0.2
	rel-5-1:11.14
	rel-5-0:11.12
	rel-5-0-beta:11.11
	rel-4-5:11.10
	ctj-4-5-post:11.9
	ctj-4-5-pre:11.9
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.28
date	2004.05.21.17.47.47;	author morrison;	state dead;
branches;
next	11.27;

11.27
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.26;

11.26
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2004.02.02.17.39.34;	author morrison;	state Exp;
branches;
next	11.24;

11.24
date	2002.08.20.17.08.24;	author jra;	state Exp;
branches
	11.24.2.1
	11.24.4.1
	11.24.10.1;
next	11.23;

11.23
date	2002.08.15.20.55.36;	author hartley;	state Exp;
branches;
next	11.22;

11.22
date	2001.09.19.22.19.53;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	2001.06.13.21.05.20;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	2001.06.05.15.51.42;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	2001.06.01.19.23.25;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	2001.03.31.01.57.23;	author morrison;	state Exp;
branches;
next	11.17;

11.17
date	2000.10.20.05.04.39;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.09.07.02.58.52;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.08.19.03.10.15;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.01.14.22.58.11;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	99.10.29.17.25.47;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	99.09.01.18.55.11;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	98.11.06.22.32.42;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	97.03.20.14.47.07;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	97.01.29.05.25.05;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.09.25.20.16.42;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	96.09.23.18.22.47;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.23;	author mike;	state Rel4_4;
branches;
next	10.10;

10.10
date	94.12.27.15.17.22;	author jra;	state Exp;
branches;
next	10.9;

10.9
date	94.08.09.18.16.31;	author gdurf;	state Exp;
branches;
next	10.8;

10.8
date	94.06.01.16.56.26;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.03.18.01.25.45;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.03.18.01.17.44;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.03.18.01.11.18;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.06.06.01.07.40;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.06.05.22.30.30;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.06.05.14.45.32;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.11;	author mike;	state Rel4_0;
branches;
next	9.10;

9.10
date	91.09.21.03.11.33;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.08.28.04.20.28;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.02.02.00.01.38;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.05.24.03.05.11;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.05.24.00.19.27;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.05.22.16.03.37;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.05.22.14.52.10;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.05.22.14.16.37;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.05.22.13.06.57;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.03.35;	author mike;	state Rel3_5;
branches;
next	8.6;

8.6
date	89.05.17.23.34.51;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.05.11.21.42.31;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.04.06.20.40.14;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.18.01.53.22;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.40.09;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.37.11;	author mike;	state Rel3_0;
branches;
next	1.3;

1.3
date	88.09.15.21.10.30;	author phil;	state Exp;
branches;
next	1.2;

1.2
date	88.05.15.23.05.16;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.02.26.22.41.24;	author mike;	state Exp;
branches;
next	;

11.24.2.1
date	2002.09.19.18.02.03;	author morrison;	state Exp;
branches;
next	11.24.2.2;

11.24.2.2
date	2004.03.17.21.22.01;	author morrison;	state Exp;
branches;
next	;

11.24.4.1
date	2004.03.11.23.46.36;	author morrison;	state Exp;
branches;
next	;

11.24.10.1
date	2004.02.12.18.34.15;	author erikg;	state Exp;
branches;
next	11.24.10.2;

11.24.10.2
date	2004.03.15.14.07.39;	author erikg;	state Exp;
branches;
next	;


desc
@Code to read UNIX-Plot files into vector lists, and
to take vector lists and convert them into Phatom solids.
Used for adding overlays to models, like overlap plots.
@


11.28
log
@moved to src/mged/
@
text
@/*
 *			O V E R L A Y . C
 *
 * Functions -
 *	f_overlay		Read a UNIX-Plot file as an overlay
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/overlay.c,v 11.27 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <math.h>
#include <signal.h>
#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "mater.h"

#include "raytrace.h"
#include "./ged.h"
#include "externs.h"
#include "./sedit.h"
#include "./mged_solid.h"
#include "./mged_dm.h"

/* Usage:  overlay file.plot [name] */
int
cmd_overlay(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	int		ret;
	struct bu_vls	char_size;
	int		ac;
	char		*av[5];

	CHECK_DBI_NULL;

	ac = argc + 1;
	bu_vls_init(&char_size);
	bu_vls_printf(&char_size, "%lf", view_state->vs_vop->vo_scale * 0.01);
	av[0] = argv[0];		/* command name */
	av[1] = argv[1];		/* plotfile name */
	av[2] = bu_vls_addr(&char_size);
	if (argc == 3) {
		av[3] = argv[2];	/* name */
		av[4] = (char *)0;
	} else
		av[3] = (char *)0;

	if ((ret = dgo_overlay_cmd(dgop, interp, ac, av)) == TCL_OK)
		update_views = 1;

	bu_vls_free(&char_size);
	return ret;
}

/* Usage:  labelvert solid(s) */
int
f_labelvert(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int	i;
	struct rt_vlblock	*vbp;
	struct directory	*dp;
	mat_t			mat;
	fastf_t			scale;

	CHECK_DBI_NULL;

	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help labelvert");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	vbp = rt_vlblock_init();
	MAT_IDN(mat);
	bn_mat_inv(mat, view_state->vs_vop->vo_rotation);
	scale = view_state->vs_vop->vo_size / 100;		/* divide by # chars/screen */

	for( i=1; i<argc; i++ )  {
		struct solid	*s;
		if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY )) == DIR_NULL )
			continue;
		/* Find uses of this solid in the solid table */
		FOR_ALL_SOLIDS(s, &dgop->dgo_headSolid)  {
			if( db_full_path_search( &s->s_fullpath, dp ) )  {
				rt_label_vlist_verts( vbp, &s->s_vlist, mat, scale, base2local );
			}
		}
	}

	cvt_vlblock_to_solids( vbp, "_LABELVERT_", 0 );

	rt_vlblock_free(vbp);
	update_views = 1;
	return TCL_OK;
}
@


11.27
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/overlay.c,v 11.26 2004/04/05 09:09:12 morrison Exp $ (BRL)";
@


11.26
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.25
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.24 2002/08/20 17:08:24 jra Exp $ (BRL)";
d74 1
a74 5
f_labelvert(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.24
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1988 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.22 2001/09/19 22:19:53 bparker Exp $ (BRL)";
@


11.24.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/overlay.c,v 11.25 2004/02/02 17:39:34 morrison Exp $ (BRL)";
@


11.24.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.25 2004/02/02 17:39:34 morrison Exp $ (BRL)";
@


11.24.10.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.24.10.1 2004/02/12 18:34:15 erikg Exp $ (BRL)";
@


11.24.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.24 2002/08/20 17:08:24 jra Exp $ (BRL)";
d74 5
a78 1
f_labelvert(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.24.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.23
log
@Converted from K&R to ANSI C - RFH
@
text
@d74 5
a78 1
f_labelvert(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.22
log
@*- add CHECK_DBI_NULL to cmd_overlay
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.21 2001/06/13 21:05:20 bparker Exp $ (BRL)";
d74 1
a74 5
f_labelvert(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.21
log
@*- fill in missing character size
*- remove if'ed out code
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.20 2001/06/05 15:51:42 bparker Exp $ (BRL)";
d50 2
@


11.20
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.19 2001/06/01 19:23:25 bparker Exp $ (BRL)";
a45 1
#if 1
d47 15
d63 1
a63 1
	if ((ret = dgo_overlay_cmd(dgop, interp, argc, argv)) == TCL_OK)
d66 1
a67 40
#else
	char		*name;
	FILE		*fp;
	int		ret;
	struct bn_vlblock	*vbp;

	if(argc < 2 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help overlay");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( argc == 2 )
		name = "_PLOT_OVERLAY_";
	else
		name = argv[2];

	if( (fp = fopen(argv[1], "r")) == NULL )  {
		perror(argv[1]);
		return TCL_ERROR;
	}

	vbp = rt_vlblock_init();
	ret = rt_uplot_to_vlist(vbp, fp, view_state->vs_vop->vo_scale * 0.01);
	fclose(fp);
	if( ret < 0 )  {
		rt_vlblock_free(vbp);
		return TCL_ERROR;
	}

	cvt_vlblock_to_solids( vbp, name, 0 );

	rt_vlblock_free(vbp);
	update_views = 1;
	return TCL_OK;
#endif
@


11.19
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.18 2001/03/31 01:57:23 morrison Exp $ (BRL)";
a79 1
#ifdef MGED_USE_VIEW_OBJ
a80 3
#else
	ret = rt_uplot_to_vlist( vbp, fp, view_state->vs_Viewscale * 0.01 );
#endif
a122 1
#ifdef MGED_USE_VIEW_OBJ
a124 4
#else
	bn_mat_inv( mat, view_state->vs_Viewrot );
	scale = VIEWSIZE / 100;		/* divide by # chars/screen */
#endif
@


11.18
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.17 2000/10/20 05:04:39 mike Exp $ (BRL)";
d41 4
a44 5
f_overlay(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
d46 8
d80 3
d84 1
d96 1
d127 4
d133 1
d140 1
a140 1
		FOR_ALL_SOLIDS(s, &HeadSolid.l)  {
@


11.17
log
@
s_path array has been replaced by a s_fullpath "struct db_full_path".
This has eliminated the MAX_PATH restriction in MGED.
member s_last is gone too.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.16 2000/09/07 02:58:52 mike Exp $ (BRL)";
d114 1
a114 1
	bn_mat_idn(mat);
@


11.16
log
@
Added externs to ged.h to quiet down lint
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.15 2000/08/19 03:10:15 mike Exp $ (BRL)";
d124 2
a125 6
			int	j;
			for( j = s->s_last; j >= 0; j-- )  {
				if( s->s_path[j] == dp )  {
					rt_label_vlist_verts( vbp, &s->s_vlist, mat, scale, base2local );
					break;
				}
@


11.15
log
@
Reduced use of MAXARGS
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.14 2000/01/14 22:58:11 bparker Exp $ (BRL)";
d41 5
a45 5
f_overlay(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.14
log
@*- use struct bn_vlblock
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.13 1999/10/29 17:25:47 bparker Exp $ (BRL)";
d103 1
a103 1
	if(argc < 2 || MAXARGS < argc){
@


11.13
log
@*- mods to f_overlay and f_labelvert
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.12 1999/09/01 18:55:11 bparker Exp $ (BRL)";
d50 1
a50 1
	struct rt_vlblock	*vbp;
@


11.12
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.11 1998/11/06 22:32:42 bparker Exp $ (BRL)";
d83 1
a83 1
	view_state->vs_flag = 1;
d137 1
a137 1
	view_state->vs_flag = 1;
@


11.11
log
@*- use new structures
*- cleanup
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/overlay.c,v 11.10 1997/07/01 22:09:08 bparker Exp $ (BRL)";
d101 1
a101 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
@


11.10
log
@mods to run without a database
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 11.9 1997/04/24 18:03:58 bparker Exp bparker $ (BRL)";
d73 1
a73 1
	ret = rt_uplot_to_vlist( vbp, fp, Viewscale * 0.01 );
d83 1
a83 1
	dmaflag = 1;
d116 1
a116 1
	bn_mat_inv( mat, Viewrot );
d138 1
a138 1
	dmaflag = 1;
@


11.9
log
@modify calls to Tcl_Eval
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 11.8 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d100 3
@


11.8
log
@mods so that commands check args internally
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 11.7 1997/03/20 14:47:07 bparker Exp bparker $ (BRL)";
d53 6
a58 1
	  Tcl_Eval(interp, "help overlay");
d102 6
a107 1
	  Tcl_Eval(interp, "help labelvert");
@


11.7
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 11.6 1997/01/29 05:25:05 mike Exp bparker $ (BRL)";
d52 2
a53 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d55 1
d96 2
a97 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d99 1
@


11.6
log
@Don't need db.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 11.5 1997/01/02 19:35:05 bparker Exp mike $ (BRL)";
a31 1
#include "./sedit.h"
d35 1
@


11.5
log
@mods to use libbn and libbu
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 11.4 1996/09/25 20:16:42 bparker Exp bparker $ (BRL)";
a29 1
#include "db.h"
@


11.4
log
@now using more generalized solid macros
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 11.3 1996/09/23 18:22:47 bparker Exp bparker $ (BRL)";
d99 2
a100 2
	mat_idn(mat);
	mat_inv( mat, Viewrot );
@


11.3
log
@changed dm.h to mged_dm.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 11.2 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d37 1
a37 1
#include "./solid.h"
d108 1
a108 1
		FOR_ALL_SOLIDS(s)  {
@


11.2
log
@convert commands to Tcl
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 11.1 1995/01/04 10:03:23 mike Rel4_4 bparker $ (BRL)";
d38 1
a38 1
#include "./dm.h"
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 10.10 94/12/27 15:17:22 jra Exp $ (BRL)";
d42 3
a44 1
f_overlay( argc, argv )
d53 4
a56 1
	if( argc <= 2 )
d63 1
a63 1
		return CMD_BAD;
d71 1
a71 1
		return CMD_BAD;
d78 1
a78 1
	return CMD_OK;
d83 3
a85 1
f_labelvert( argc, argv )
d95 3
d123 1
a123 1
	return CMD_OK;
@


10.10
log
@Modified f_labelvert to call rt_label_vlist_verts with "base2local" arg.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 10.9 94/08/09 18:16:31 gdurf Exp Locker: jra $ (BRL)";
@


10.9
log
@Added include of conf.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 10.8 1994/06/01 16:56:26 gdurf Exp gdurf $ (BRL)";
d102 1
a102 1
					rt_label_vlist_verts( vbp, &s->s_vlist, mat, scale );
@


10.8
log
@Converted f_labelvert and f_overlay to use new command return codes.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 10.7 1994/03/18 01:25:45 mike Exp gdurf $ (BRL)";
d22 2
@


10.7
log
@Added extra arg on rt_uplot_to_vlist
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 10.6 94/03/18 01:17:44 mike Exp Locker: mike $ (BRL)";
d39 1
a39 1
void
d56 1
a56 1
		return;
d64 1
a64 1
		return;
d71 1
d75 1
a75 1
void
d111 1
@


10.6
log
@Moved all common routines off to librt/vlist.c
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 10.5 94/03/18 01:11:18 mike Exp Locker: mike $ (BRL)";
d60 1
a60 1
	ret = rt_uplot_to_vlist( vbp, fp );
@


10.5
log
@Changed over to using 3symbol routine from librt/font.c
@
text
@a5 2
 *	uplot_vlist		Read UNIX-Plot, create list of vectors
 *	getshort		Read VAX-order 16-bit number
d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 10.4 92/06/06 01:07:40 mike Exp Locker: mike $ (BRL)";
a37 76
#define	TBAD	0	/* no such command */
#define TNONE	1	/* no arguments */
#define TSHORT	2	/* Vax 16-bit short */
#define	TIEEE	3	/* IEEE 64-bit floating */
#define	TCHAR	4	/* unsigned chars */
#define	TSTRING	5	/* linefeed terminated string */

struct uplot {
	int	targ;	/* type of args */
	int	narg;	/* number or args */
	char	*desc;	/* description */
};
struct uplot uplot_error = { 0, 0, 0 };
struct uplot uplot_letters[] = {
/*A*/	{ 0, 0, 0 },
/*B*/	{ 0, 0, 0 },
/*C*/	{ TCHAR, 3, "color" },
/*D*/	{ 0, 0, 0 },
/*E*/	{ 0, 0, 0 },
/*F*/	{ TNONE, 0, "flush" },
/*G*/	{ 0, 0, 0 },
/*H*/	{ 0, 0, 0 },
/*I*/	{ 0, 0, 0 },
/*J*/	{ 0, 0, 0 },
/*K*/	{ 0, 0, 0 },
/*L*/	{ TSHORT, 6, "3line" },
/*M*/	{ TSHORT, 3, "3move" },
/*N*/	{ TSHORT, 3, "3cont" },
/*O*/	{ TIEEE, 3, "d_3move" },
/*P*/	{ TSHORT, 3, "3point" },
/*Q*/	{ TIEEE, 3, "d_3cont" },
/*R*/	{ 0, 0, 0 },
/*S*/	{ TSHORT, 6, "3space" },
/*T*/	{ 0, 0, 0 },
/*U*/	{ 0, 0, 0 },
/*V*/	{ TIEEE, 6, "d_3line" },
/*W*/	{ TIEEE, 6, "d_3space" },
/*X*/	{ TIEEE, 3, "d_3point" },
/*Y*/	{ 0, 0, 0 },
/*Z*/	{ 0, 0, 0 },
/*[*/	{ 0, 0, 0 },
/*\*/	{ 0, 0, 0 },
/*]*/	{ 0, 0, 0 },
/*^*/	{ 0, 0, 0 },
/*_*/	{ 0, 0, 0 },
/*`*/	{ 0, 0, 0 },
/*a*/	{ TSHORT, 6, "arc" },
/*b*/	{ 0, 0, 0 },
/*c*/	{ TSHORT, 3, "circle" },
/*d*/	{ 0, 0, 0 },
/*e*/	{ TNONE, 0, "erase" },
/*f*/	{ TSTRING, 1, "linmod" },
/*g*/	{ 0, 0, 0 },
/*h*/	{ 0, 0, 0 },
/*i*/	{ TIEEE, 3, "d_circle" },
/*j*/	{ 0, 0, 0 },
/*k*/	{ 0, 0, 0 },
/*l*/	{ TSHORT, 4, "line" },
/*m*/	{ TSHORT, 2, "move" },
/*n*/	{ TSHORT, 2, "cont" },
/*o*/	{ TIEEE, 2, "d_move" },
/*p*/	{ TSHORT, 2, "point" },
/*q*/	{ TIEEE, 2, "d_cont" },
/*r*/	{ TIEEE, 6, "d_arc" },
/*s*/	{ TSHORT, 4, "space" },
/*t*/	{ TSTRING, 1, "label" },
/*u*/	{ 0, 0, 0 },
/*v*/	{ TIEEE, 4, "d_line" },
/*w*/	{ TIEEE, 4, "d_space" },
/*x*/	{ TIEEE, 2, "d_point" },
/*y*/	{ 0, 0, 0 },
/*z*/	{ 0, 0, 0 }
};

static int	getshort();

d60 1
a60 1
	ret = uplot_vlist( vbp, fp );
a72 27
void
label_vlist_verts( vbp, src, mat, sz )
struct rt_vlblock	*vbp;
struct rt_list		*src;
mat_t			mat;
double			sz;
{
	struct rt_vlist	*vp;
	struct rt_list	*vhead;
	char		label[256];
	fastf_t		scale;

	vhead = rt_vlblock_find( vbp, 255, 255, 255 );	/* white */

	for( RT_LIST_FOR( vp, rt_vlist, src ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			sprintf( label, " %g, %g, %g",
				V3ARGS(*pt) );
			rt_vlist_3string( vhead, label, pt, mat, sz );
		}
	}
}

d99 1
a99 1
					label_vlist_verts( vbp, &s->s_vlist, mat, scale );
a109 166
}

/*
 *			U P L O T _ V L I S T
 *
 *  Read a BRL-style 3-D UNIX-plot file into a vector list.
 *  For now, discard color information, only extract vectors.
 *  This might be more naturally located in mged/plot.c
 */
int
uplot_vlist( vbp, fp )
struct rt_vlblock	*vbp;
register FILE		*fp;
{
	register struct rt_list	*vhead;
	register int	c;
	mat_t	mat;
	struct	uplot *up;
	char	carg[256];
	fastf_t	arg[6];
	char	inbuf[8];
	vect_t	a,b;
	point_t	last_pos;
	int	cc;
	int	i;
	int	j;

	vhead = rt_vlblock_find( vbp, 0xFF, 0xFF, 0x00 );	/* Yellow */

	while( (c = getc(fp)) != EOF ) {
		/* look it up */
		if( c < 'A' || c > 'z' ) {
			up = &uplot_error;
		} else {
			up = &uplot_letters[ c - 'A' ];
		}

		if( up->targ == TBAD ) {
			fprintf( stderr, "Bad command '%c' (0x%02x)\n", c, c );
			return(-1);
		}

		if( up->narg > 0 )  {
			for( i = 0; i < up->narg; i++ ) {
			switch( up->targ ){
				case TSHORT:
					arg[i] = getshort(fp);
					break;
				case TIEEE:
					fread( inbuf, 8, 1, fp );
					ntohd( &arg[i], inbuf, 1 );
					break;
				case TSTRING:
					j = 0;
					while( (cc = getc(fp)) != '\n'
					    && cc != EOF )
						carg[j++] = cc;
					carg[j] = '\0';
					break;
				case TCHAR:
					carg[i] = getc(fp);
					arg[i] = 0;
					break;
				case TNONE:
				default:
					arg[i] = 0;	/* ? */
					break;
				}
			}
		}

		switch( c ) {
		case 's':
		case 'w':
		case 'S':
		case 'W':
			/* Space commands, do nothing. */
			break;
		case 'm':
		case 'o':
			/* 2-D move */
			arg[Z] = 0;
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_MOVE );
			break;
		case 'M':
		case 'O':
			/* 3-D move */
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_MOVE );
			break;
		case 'n':
		case 'q':
			/* 2-D draw */
			arg[Z] = 0;
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_DRAW );
			break;
		case 'N':
		case 'Q':
			/* 3-D draw */
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_DRAW );
			break;
		case 'l':
		case 'v':
			/* 2-D line */
			VSET( a, arg[0], arg[1], 0.0 );
			VSET( b, arg[2], arg[3], 0.0 );
			RT_ADD_VLIST( vhead, a, RT_VLIST_LINE_MOVE );
			RT_ADD_VLIST( vhead, b, RT_VLIST_LINE_DRAW );
			break;
		case 'L':
		case 'V':
			/* 3-D line */
			VSET( a, arg[0], arg[1], arg[2] );
			VSET( b, arg[3], arg[4], arg[5] );
			RT_ADD_VLIST( vhead, a, RT_VLIST_LINE_MOVE );
			RT_ADD_VLIST( vhead, b, RT_VLIST_LINE_DRAW );
			break;
		case 'p':
		case 'x':
			/* 2-D point */
			arg[Z] = 0;
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_MOVE );
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_DRAW );
			break;
		case 'P':
		case 'X':
			/* 3-D point */
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_MOVE );
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_DRAW );
			break;
		case 'C':
			/* Color */
			vhead = rt_vlblock_find( vbp,
				carg[0], carg[1], carg[2] );
			break;
		case 't':
			/* Text string */
			mat_idn(mat);
			if( RT_LIST_NON_EMPTY( vhead ) )  {
				struct rt_vlist *vlp;
				/* Use coordinates of last op */
				vlp = RT_LIST_LAST( rt_vlist, vhead );
				VMOVE( last_pos, vlp->pt[vlp->nused-1] );
			} else {
				VSETALL( last_pos, 0 );
			}
			rt_vlist_3string( vhead, carg, last_pos, mat, Viewscale * 0.01 );
			break;
		}
	}
	return(0);
}

static int
getshort(fp)
FILE	*fp;
{
	register long	v, w;

	v = getc(fp);
	v |= (getc(fp)<<8);	/* order is important! */

	/* worry about sign extension - sigh */
	if( v <= 0x7FFF )  return(v);
	w = -1;
	w &= ~0x7FFF;
	return( w | v );
@


10.4
log
@Now checks full path for match, rather than just leaf, in labelvert cmd.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 10.3 92/06/05 22:30:30 mike Exp Locker: mike $ (BRL)";
a39 39
/*
 *  Character stroke table, taken from libtig/symbol.c
 *
 *	Terminal Independant Graphics Display Package
 *		Mike Muuss  July 31, 1978
 *
 *	This routine is used to plot a string of ASCII symbols
 *  on the plot being generated, using a built-in set of fonts
 *  drawn as vector lists.
 * 
 *	Internally, the basic font resides in a 10x10 unit square.
 *  Externally, each character can be thought to occupy one square
 *  plotting unit;  the 'scale'
 *  parameter allows this to be changed as desired, although scale
 *  factors less than 10.0 are unlikely to be legible.
 *
 */

/*
 *	Motion encoding macros
 *
 * All characters reference absolute points within a 10 x 10 square
 */
#define	brt(x,y)	(11*x+y)
#define drk(x,y)	-(11*x+y)
#define	LAST		-128		/* 0200 Marks end of stroke list */
#define	NEGY		-127		/* 0201 Denotes negative y stroke */
#define bneg(x,y)	NEGY, brt(x,y)
#define dneg(x,y)	NEGY, drk(x,y)

#if defined(CRAY1) || defined(CRAY2) || defined(mips)
#define TINY	int
#else
#define TINY	char		/* must be signed */
#endif

static TINY	*tp_cindex[256];	/* index to stroke tokens */
extern TINY	tp_ctable[];	/* table of strokes */

a114 1
extern void	vlist_3symbol();
d173 1
a173 1
			vlist_3symbol( vhead, label, pt, mat, sz );
d360 1
a360 1
			vlist_3symbol( vhead, carg, last_pos, mat, Viewscale * 0.01 );
a381 1090

/*
 *  Once-only setup routine
 */
static void
tp_setup()
{
	register TINY	*p;	/* pointer to stroke table */
	register int i;

	p = tp_ctable;		/* pointer to stroke list */

	/* Store start addrs of each stroke list */
	for( i=040-5; i<128; i++)  {
		tp_cindex[i+128] = tp_cindex[i] = p;
		while( (*p++) != LAST );
	}
	for( i=6; i<040; i++ )  {
		tp_cindex[i+128] = tp_cindex[i] = tp_cindex['?'];
	}
	for( i=1; i<6; i++ )  {
		tp_cindex[i+128] = tp_cindex[i] = tp_cindex[040-1+i];
	}
}

/*
 *			V L I S T _ 3 S Y M B O L
 *
 *  'scale' is the width, in mm, of one character.
 */
void
vlist_3symbol( vhead, string, origin, rot, scale )
register struct rt_list	*vhead;
char	*string;		/* string of chars to be plotted */
point_t	origin;			/* lower left corner of 1st char */
mat_t	rot;			/* Transform matrix (WARNING: may xlate) */
double	scale;			/* scale factor to change 1x1 char sz */
{
	register unsigned char *cp;
	double	offset;			/* offset of char from given x,y */
	int	ysign;			/* sign of y motion, either +1 or -1 */
	vect_t	temp;
	vect_t	loc;
	mat_t	xlate_to_origin;
	mat_t	mtemp;
	mat_t	mat;

	if( string == NULL || *string == '\0' )
		return;			/* done before begun! */

	/*
	 *  The point "origin" will be the center of the axis rotation.
	 *  The text is located in a local coordinate system with the
	 *  lower left corner of the first character at (0,0,0), with
	 *  the text proceeding onward towards +X.
	 *  We need to rotate the text around it's local (0,0,0),
	 *  and then translate to the user's designated "origin".
	 *  If the user provided translation or
	 *  scaling in his matrix, it will *also* be applied.
	 */
	mat_idn( xlate_to_origin );
	MAT_DELTAS( xlate_to_origin,	origin[X], origin[Y], origin[Z] );
	mat_mul( mat, xlate_to_origin, rot );

	/* Check to see if initialization is needed */
	if( tp_cindex[040] == 0 )  tp_setup();

	/* Draw each character in the input string */
	offset = 0;
	for( cp = (unsigned char *)string ; *cp; cp++, offset += scale )  {
		register TINY	*p;	/* pointer to stroke table */
		register int	stroke;

		VSET( temp, offset, 0, 0 );
		MAT4X3PNT( loc, mat, temp );
		RT_ADD_VLIST( vhead, loc, RT_VLIST_LINE_MOVE );		/* move */

		for( p = tp_cindex[*cp]; (stroke= *p) != LAST; p++ )  {
			int	draw;

			if( stroke==NEGY )  {
				ysign = (-1);
				stroke = *++p;
			} else
				ysign = 1;

			/* Detect & process pen control */
			if( stroke < 0 )  {
				stroke = -stroke;
				draw = 0;
			} else
				draw = 1;

			/* stroke co-ordinates in string coord system */
			VSET( temp, (stroke/11) * 0.1 * scale + offset,
				   (ysign * (stroke%11)) * 0.1 * scale, 0 );
			MAT4X3PNT( loc, mat, temp );
			if( draw )  {
				RT_ADD_VLIST( vhead, loc, RT_VLIST_LINE_DRAW );
			} else {
				RT_ADD_VLIST( vhead, loc, RT_VLIST_LINE_MOVE );
			}
		}
	}
}


/*	tables for markers	*/

TINY	tp_ctable[] = {

/*	+	*/
	drk(0, 5),
	brt(8, 5),
	drk(4, 8),
	brt(4, 2),
	LAST,

/*	x	*/
	drk(0, 2),
	brt(8, 8),
	drk(0, 8),
	brt(8, 2),
	LAST,

/*	triangle	*/
	drk(0, 2),
	brt(4, 8),
	brt(8, 2),
	brt(0, 2),
	LAST,

/*	square	*/
	drk(0, 2),
	brt(0, 8),
	brt(8, 8),
	brt(8, 2),
	brt(0, 2),
	LAST,

/*	hourglass	*/
	drk(0, 2),
	brt(8, 8),
	brt(0, 8),
	brt(8, 2),
	brt(0, 2),
	LAST,

/*	table for ascii 040, ' '	*/
	LAST,

/*	table for !	*/
	drk(3, 0),
	brt(5, 2),
	brt(5, 0),
	brt(3, 2),
	brt(3, 0),
	drk(4, 4),
	brt(3, 10),
	brt(5, 10),
	brt(4, 4),
	brt(4, 10),
	LAST,

/*	table for "	*/
	drk(1, 10),
	brt(3, 10),
	brt(2, 7),
	brt(1, 10 ),
	drk(5, 10),
	brt(7, 10),
	brt(6, 7),
	brt(5, 10),
	LAST,

/*	table for #	*/
	drk(1, 0),
	brt(3, 9),
	drk(6, 9),
	brt(4, 0),
	drk(6, 3),
	brt(0, 3),
	drk(1, 6),
	brt(7, 6),
	LAST,

/*	table for $	*/
	drk(1, 2),
	brt(1, 1),
	brt(7, 1),
	brt(7, 5),
	brt(1, 5),
	brt(1, 9),
	brt(7, 9),
	brt(7, 8),
	drk(4, 10),
	brt(4, 0),
	LAST,

/*	table for %	*/
	drk(3, 10),
	brt(3, 7),
	brt(0, 7),
	brt(0, 10),
	brt(8, 10),
	brt(0, 0),
	drk(8, 0),
	brt(5, 0),
	brt(5, 3),
	brt(8, 3),
	brt(8, 0),
	LAST,

/*	table for &	*/
	drk(7, 3),
	brt(4, 0),
	brt(1, 0),
	brt(0, 3),
	brt(5, 8),
	brt(4, 10),
	brt(3, 10),
	brt(1, 8),
	brt(8, 0),
	LAST,

/*	table for '	*/
	drk(4, 6),
	brt(5, 10),
	brt(6, 10),
	brt(4, 6),
	LAST,

/*	table for (	*/
	drk(5, 0 ),
	brt(3, 1 ),
	brt(2, 4 ),
	brt(2, 6 ),
	brt(3, 9 ),
	brt(5, 10 ),
	LAST,

/*	table for )	*/
	drk(3, 0 ),
	brt(5, 1 ),
	brt(6, 4 ),
	brt(6, 6 ),
	brt(5, 9 ),
	brt(3, 10 ),
	LAST,

/*	table for *	*/
	drk(4, 2 ),
	brt(4, 8 ),
	drk(6, 7 ),
	brt(2, 3 ),
	drk(6, 3 ),
	brt(2, 7 ),
	drk(1, 5 ),
	brt(7, 5 ),
	LAST,

/*	table for +	*/
	drk(1, 5 ),
	brt(7, 5 ),
	drk(4, 8 ),
	brt(4, 2 ),
	LAST,

/*	table for, 	*/
	drk(5, 0 ),
	brt(3, 2 ),
	brt(3, 0 ),
	brt(5, 2 ),
	brt(5, 0 ),
	bneg(2, 2 ),
	brt(4, 0 ),
	LAST,

/*	table for -	*/
	drk(1, 5 ),
	brt(7, 5 ),
	LAST,

/*	table for .	*/
	drk(5, 0 ),
	brt(3, 2 ),
	brt(3, 0 ),
	brt(5, 2 ),
	brt(5, 0 ),
	LAST,

/*	table for /	*/
	brt(8, 10 ),
	LAST,

/*	table for 0	*/
	drk(8, 10),
	brt(0, 0),
	brt(0, 10),
	brt(8, 10),
	brt(8, 0),
	brt(0, 0),
	LAST,

/*	table for 1	*/
	drk(4, 0 ),
	brt(4, 10 ),
	brt(2, 8 ),
	LAST,

/*	table for 2	*/
	drk(0, 6 ),
	brt(0, 8 ),
	brt(3, 10 ),
	brt(5, 10 ),
	brt(8, 8 ),
	brt(8, 7 ),
	brt(0, 2 ),
	brt(0, 0 ),
	brt(8, 0 ),
	LAST,

/*	table for 3	*/
	drk(0, 10 ),
	brt(8, 10 ),
	brt(8, 5 ),
	brt(0, 5 ),
	brt(8, 5 ),
	brt(8, 0 ),
	brt(0, 0 ),
	LAST,

/*	table for 4	*/
	drk(0, 10 ),
	brt(0, 5 ),
	brt(8, 5 ),
	drk(8, 10 ),
	brt(8, 0 ),
	LAST,

/*	table for 5	*/
	drk(8, 10 ),
	brt(0, 10 ),
	brt(0, 5 ),
	brt(8, 5 ),
	brt(8, 0 ),
	brt(0, 0 ),
	LAST,

/*	table for 6	*/
	drk(0, 10 ),
	brt(0, 0 ),
	brt(8, 0 ),
	brt(8, 5 ),
	brt(0, 5 ),
	LAST,

/*	table for 7	*/
	drk(0, 10 ),
	brt(8, 10 ),
	brt(6, 0 ),
	LAST,

/*	table for 8	*/
	drk(0, 5 ),
	brt(0, 0 ),
	brt(8, 0 ),
	brt(8, 5 ),
	brt(0, 5 ),
	brt(0, 10 ),
	brt(8, 10 ),
	brt(8, 5 ),
	LAST,

/*	table for 9	*/
	drk(8, 5 ),
	brt(0, 5 ),
	brt(0, 10 ),
	brt(8, 10 ),
	brt(8, 0 ),
	LAST,

/*	table for :	*/
	drk(5, 6 ),
	brt(3, 8 ),
	brt(3, 6 ),
	brt(5, 8 ),
	brt(5, 6 ),
	drk(5, 0 ),
	brt(3, 2 ),
	brt(3, 0 ),
	brt(5, 2 ),
	brt(5, 0 ),
	LAST,

/*	table for ;	*/
	drk(5, 6 ),
	brt(3, 8 ),
	brt(3, 6 ),
	brt(5, 8 ),
	brt(5, 6 ),
	drk(5, 0 ),
	brt(3, 2 ),
	brt(3, 0 ),
	brt(5, 2 ),
	brt(5, 0 ),
	bneg(2, 2 ),
	brt(4, 0 ),
	LAST,

/*	table for <	*/
	drk(8, 8 ),
	brt(0, 5 ),
	brt(8, 2 ),
	LAST,

/*	table for =	*/
	drk(0, 7 ),
	brt(8, 7 ),
	drk(0, 3 ),
	brt(8, 3 ),
	LAST,

/*	table for >	*/
	drk(0, 8 ),
	brt(8, 5 ),
	brt(0, 2 ),
	LAST,

/*	table for ?	*/
	drk(3, 0 ),
	brt(5, 2 ),
	brt(5, 0 ),
	brt(3, 2 ),
	brt(3, 0 ),
	drk(1, 7 ),
	brt(1, 9 ),
	brt(3, 10 ),
	brt(5, 10 ),
	brt(7, 9 ),
	brt(7, 7 ),
	brt(4, 5 ),
	brt(4, 3 ),
	LAST,

/*	table for @@	*/
	drk(0, 8 ),
	brt(2, 10 ),
	brt(6, 10 ),
	brt(8, 8 ),
	brt(8, 2 ),
	brt(6, 0 ),
	brt(2, 0 ),
	brt(1, 1 ),
	brt(1, 4 ),
	brt(2, 5 ),
	brt(4, 5 ),
	brt(5, 4 ),
	brt(5, 0 ),
	LAST,

/*	table for A	*/
	brt(0, 8 ),
	brt(2, 10 ),
	brt(6, 10 ),
	brt(8, 8 ),
	brt(8, 0 ),
	drk(0, 5 ),
	brt(8, 5 ),
	LAST,

/*	table for B	*/
	brt(0, 10 ),
	brt(5, 10 ),
	brt(8, 9 ),
	brt(8, 6 ),
	brt(5, 5 ),
	brt(0, 5 ),
	brt(5, 5 ),
	brt(8, 4 ),
	brt(8, 1 ),
	brt(5, 0 ),
	brt(0, 0 ),
	LAST,

/*	table for C	*/
	drk(8, 2 ),
	brt(6, 0 ),
	brt(2, 0 ),
	brt(0, 2 ),
	brt(0, 8 ),
	brt(2, 10 ),
	brt(6, 10 ),
	brt(8, 8 ),
	LAST,

/*	table for D	*/
	brt(0, 10 ),
	brt(5, 10 ),
	brt(8, 8 ),
	brt(8, 2 ),
	brt(5, 0 ),
	brt(0, 0 ),
	LAST,

/*	table for E	*/
	drk(8, 0 ),
	brt(0, 0 ),
	brt(0, 10 ),
	brt(8, 10 ),
	drk(0, 5 ),
	brt(5, 5 ),
	LAST,

/*	table for F	*/
	brt(0, 10 ),
	brt(8, 10 ),
	drk(0, 5 ),
	brt(5, 5 ),
	LAST,

/*	table for G	*/
	drk(5, 5 ),
	brt(8, 5 ),
	brt(8, 2 ),
	brt(6, 0 ),
	brt(2, 0 ),
	brt(0, 2 ),
	brt(0, 8 ),
	brt(2, 10 ),
	brt(6, 10 ),
	brt(8, 8 ),
	LAST,

/*	table for H	*/
	brt(0, 10 ),
	drk(8, 10 ),
	brt(8, 0 ),
	drk(0, 6 ),
	brt(8, 6 ),
	LAST,

/*	table for I	*/
	drk(4, 0 ),
	brt(6, 0 ),
	drk(5, 0 ),
	brt(5, 10 ),
	brt(4, 10 ),
	brt(6, 10 ),
	LAST,

/*	table for J	*/
	drk(0, 2 ),
	brt(2, 0 ),
	brt(5, 0 ),
	brt(7, 2 ),
	brt(7, 10 ),
	brt(6, 10 ),
	brt(8, 10 ),
	LAST,

/*	table for K	*/
	brt(0, 10 ),
	drk(0, 5 ),
	brt(8, 10 ),
	drk(3, 7 ),
	brt(8, 0 ),
	LAST,

/*	table for L	*/
	drk(8, 0 ),
	brt(0, 0 ),
	brt(0, 10 ),
	LAST,

/*	table for M	*/
	brt(0, 10 ),
	brt(4, 5 ),
	brt(8, 10 ),
	brt(8, 10 ),
	brt(8, 0 ),
	LAST,

/*	table for N	*/
	brt(0, 10 ),
	brt(8, 0 ),
	brt(8, 10 ),
	LAST,

/*	table for O	*/
	drk(0, 2 ),
	brt(0, 8 ),
	brt(2, 10 ),
	brt(6, 10 ),
	brt(8, 8 ),
	brt(8, 2 ),
	brt(6, 0 ),
	brt(2, 0 ),
	brt(0, 2 ),
	LAST,

/*	table for P	*/
	brt(0, 10 ),
	brt(6, 10 ),
	brt(8, 9 ),
	brt(8, 6 ),
	brt(6, 5 ),
	brt(0, 5 ),
	LAST,

/*	table for Q	*/
	drk(0, 2 ),
	brt(0, 8 ),
	brt(2, 10 ),
	brt(6, 10 ),
	brt(8, 8 ),
	brt(8, 2 ),
	brt(6, 0 ),
	brt(2, 0 ),
	brt(0, 2 ),
	drk(5, 3 ),
	brt(8, 0 ),
	LAST,

/*	table for R	*/
	brt(0, 10 ),
	brt(6, 10 ),
	brt(8, 8 ),
	brt(8, 6 ),
	brt(6, 5 ),
	brt(0, 5 ),
	drk(5, 5 ),
	brt(8, 0 ),
	LAST,

/*	table for S	*/
	drk(0, 1 ),
	brt(1, 0 ),
	brt(6, 0 ),
	brt(8, 2 ),
	brt(8, 4 ),
	brt(6, 6 ),
	brt(2, 6 ),
	brt(0, 7 ),
	brt(0, 9 ),
	brt(1, 10 ),
	brt(7, 10 ),
	brt(8, 9 ),
	LAST,

/*	table for T	*/
	drk(4, 0 ),
	brt(4, 10 ),
	drk(0, 10 ),
	brt(8, 10 ),
	LAST,

/*	table for U	*/
	drk(0, 10 ),
	brt(0, 2 ),
	brt(2, 0 ),
	brt(6, 0 ),
	brt(8, 2 ),
	brt(8, 10 ),
	LAST,

/*	table for V	*/
	drk(0, 10 ),
	brt(4, 0 ),
	brt(8, 10 ),
	LAST,

/*	table for W	*/
	drk(0, 10 ),
	brt(1, 0 ),
	brt(4, 4 ),
	brt(7, 0 ),
	brt(8, 10 ),
	LAST,

/*	table for X	*/
	brt(8, 10 ),
	drk(0, 10 ),
	brt(8, 0 ),
	LAST,

/*	table for Y	*/
	drk(0, 10 ),
	brt(4, 4 ),
	brt(8, 10 ),
	drk(4, 4 ),
	brt(4, 0 ),
	LAST,

/*	table for Z	*/
	drk(0, 10 ),
	brt(8, 10 ),
	brt(0, 0 ),
	brt(8, 0 ),
	LAST,

/*	table for [	*/
	drk(6, 0 ),
	brt(4, 0 ),
	brt(4, 10 ),
	brt(6, 10 ),
	LAST,

/*	table for \	*/
	drk(0, 10 ),
	brt(8, 0 ),
	LAST,

/*	table for ]	*/
	drk(2, 0 ),
	brt(4, 0 ),
	brt(4, 10 ),
	brt(2, 10 ),
	LAST,

/*	table for ^	*/
	drk(4, 0 ),
	brt(4, 10 ),
	drk(2, 8 ),
	brt(4, 10 ),
	brt(6, 8 ),
	LAST,

/*	table for _	*/
	dneg(0, 1),
	bneg(11, 1),
	LAST,

/*	table for ascii 96: accent	*/
	drk(3, 10),
	brt(5, 6),
	brt(4, 10),
	brt(3, 10),
	LAST,

/*	table for a	*/
	drk(0, 5),
	brt(1, 6),
	brt(6, 6),
	brt(7, 5),
	brt(7, 1),
	brt(8, 0),
	drk(7, 1),
	brt(6, 0),
	brt(1, 0),
	brt(0, 1),
	brt(0, 2),
	brt(1, 3),
	brt(6, 3),
	brt(7, 2),
	LAST,

/*	table for b	*/
	brt(0, 10),
	drk(8, 3),
	brt(7, 5),
	brt(4, 6),
	brt(1, 5),
	brt(0, 3),
	brt(1, 1),
	brt(4, 0),
	brt(7, 1),
	brt(8, 3),
	LAST,

/*	table for c	*/
	drk(8, 5),
	brt(7, 6),
	brt(2, 6),
	brt(0, 4),
	brt(0, 4),
	brt(0, 2),
	brt(2, 0),
	brt(7, 0),
	brt(8, 1),
	LAST,

/*	table for d	*/
	drk(8, 0),
	brt(8, 10),
	drk(8, 3),
	brt(7, 5),
	brt(4, 6),
	brt(1, 5),
	brt(0, 3),
	brt(1, 1),
	brt(4, 0),
	brt(7, 1),
	brt(8, 3),
	LAST,

/*	table for e	*/
	drk(0, 4),
	brt(1, 3),
	brt(7, 3),
	brt(8, 4),
	brt(8, 5),
	brt(7, 6),
	brt(1, 6),
	brt(0, 5),
	brt(0, 1),
	brt(1, 0),
	brt(7, 0),
	brt(8, 1),
	LAST,

/*	table for f	*/
	drk(2, 0),
	brt(2, 9),
	brt(3, 10),
	brt(5, 10),
	brt(6, 9),
	drk(1, 5),
	brt(4, 5),
	LAST,

/*	table for g	*/
	drk(8, 6),
	drk(8, 3),
	brt(7, 5),
	brt(4, 6),
	brt(1, 5),
	brt(0, 3),
	brt(1, 1),
	brt(4, 0),
	brt(7, 1),
	brt(8, 3),
	bneg(8, 2),
	bneg(7, 3),
	bneg(1, 3),
	bneg(0, 2),
	LAST,

/*	table for h	*/
	brt(0, 10),
	drk(0, 4),
	brt(2, 6),
	brt(6, 6),
	brt(8, 4),
	brt(8, 0),
	LAST,

/*	table for i	*/
	drk(4, 0),
	brt(4, 6),
	brt(3, 6),
	drk(4, 9),
	brt(4, 8),
	drk(3, 0),
	brt(5, 0),
	LAST,

/*	table for j	*/
	drk(5, 6),
	brt(6, 6),
	bneg(6, 2),
	bneg(5, 3),
	bneg(3, 3),
	bneg(2, 2),
	LAST,

/*	table for k	*/
	brt(2, 0),
	brt(2, 10),
	brt(0, 10),
	drk(2, 4),
	brt(4, 4),
	brt(8, 6),
	drk(4, 4),
	brt(8, 0),
	LAST,

/*	table for l	*/
	drk(3, 10),
	brt(4, 10),
	brt(4, 2),
	brt(5, 0),
	LAST,

/*	table for m	*/
	brt(0, 6),
	drk(0, 5),
	brt(1, 6),
	brt(3, 6),
	brt(4, 5),
	brt(4, 0),
	drk(4, 5),
	brt(5, 6),
	brt(7, 6),
	brt(8, 5),
	brt(8, 0),
	LAST,

/*	table for n	*/
	brt(0, 6),
	drk(0, 4),
	brt(2, 6),
	brt(6, 6),
	brt(8, 4),
	brt(8, 0),
	LAST,

/*	table for o	*/
	drk(8, 3),
	brt(7, 5),
	brt(4, 6),
	brt(1, 5),
	brt(0, 3),
	brt(1, 1),
	brt(4, 0),
	brt(7, 1),
	brt(8, 3),
	LAST,

/*	table for p	*/
	drk(0, 6),
	bneg(0, 3),
	drk(8, 3),
	brt(7, 5),
	brt(4, 6),
	brt(1, 5),
	brt(0, 3),
	brt(1, 1),
	brt(4, 0),
	brt(7, 1),
	brt(8, 3),
	LAST,

/*	table for q	*/
	drk(8, 6),
	drk(8, 3),
	brt(7, 5),
	brt(4, 6),
	brt(1, 5),
	brt(0, 3),
	brt(1, 1),
	brt(4, 0),
	brt(7, 1),
	brt(8, 3),
	bneg(8, 3),
	bneg(9, 3),
	LAST,

/*	table for r	*/
	brt(1, 0),
	brt(1, 6),
	brt(0, 6),
	drk(1, 4),
	brt(3, 6),
	brt(6, 6),
	brt(8, 4),
	LAST,

/*	table for s	*/
	drk(0, 1),
	brt(1, 0),
	brt(7, 0),
	brt(8, 1),
	brt(7, 2),
	brt(1, 4),
	brt(0, 5),
	brt(1, 6),
	brt(7, 6),
	brt(8, 5),
	LAST,

/*	table for t	*/
	drk(7, 1),
	brt(6, 0),
	brt(4, 0),
	brt(3, 1),
	brt(3, 10),
	brt(2, 10),
	drk(1, 5),
	brt(5, 5),
	LAST,

/*	table for u	*/
	drk(0, 6),
	brt(1, 6),
	brt(1, 1),
	brt(2, 0),
	brt(6, 0),
	brt(7, 1),
	brt(7, 6),
	drk(7, 1),
	brt(8, 0),
	LAST,

/*	table for v	*/
	drk(0, 6),
	brt(4, 0),
	brt(8, 6),
	LAST,

/*	table for w	*/
	drk(0, 6),
	brt(0, 5),
	brt(2, 0),
	brt(4, 5),
	brt(6, 0),
	brt(8, 5),
	brt(8, 6),
	LAST,

/*	table for x	*/
	brt(8, 6),
	drk(0, 6),
	brt(8, 0),
	LAST,

/*	table for y	*/
	drk(0, 6),
	brt(0, 1),
	brt(1, 0),
	brt(7, 0),
	brt(8, 1),
	drk(8, 6),
	bneg(8, 2),
	bneg(7, 3),
	bneg(1, 3),
	bneg(0, 2),
	LAST,

/*	table for z	*/
	drk(0, 6),
	brt(8, 6),
	brt(0, 0),
	brt(8, 0),
	LAST,

/*	table for ascii 123, left brace	*/
	drk(6, 10),
	brt(5, 10),
	brt(4, 9),
	brt(4, 6),
	brt(3, 5),
	brt(4, 4),
	brt(4, 1),
	brt(5, 0),
	brt(6, 0),
	LAST,

/*	table for ascii 124, vertical bar	*/
	drk(4, 4),
	brt(4, 0),
	brt(5, 0),
	brt(5, 4),
	brt(4, 4),
	drk(4, 6),
	brt(4, 10),
	brt(5, 10),
	brt(5, 6),
	brt(4, 6),
	LAST,

/*	table for ascii 125, right brace	*/
	drk(2, 0),
	brt(3, 0),
	brt(4, 1),
	brt(4, 4),
	brt(5, 5),
	brt(4, 6),
	brt(4, 9),
	brt(3, 10),
	brt(2, 10),
	LAST,

/*	table for ascii 126, tilde	*/
	drk(0, 5),
	brt(1, 6),
	brt(3, 6),
	brt(5, 4),
	brt(7, 4),
	brt(8, 5),
	LAST,

/*	table for ascii 127, rubout	*/
	drk(0, 2),
	brt(0, 8),
	brt(8, 8),
	brt(8, 2),
	brt(0, 2),
	LAST
};
@


10.3
log
@Fixed bug in vlist_3symbol relating to 0xFF masking (removed).
Added f_labelvert() routine, to label vertices of the vlist of a solid(s).
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 10.2 92/06/05 14:45:32 mike Exp Locker: mike $ (BRL)";
d241 7
a247 2
			if( s->s_path[s->s_last] != dp )  continue;
			label_vlist_verts( vbp, &s->s_vlist, mat, scale );
@


10.2
log
@Moved comment.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 10.1 91/10/12 06:44:11 mike Rel4_0 Locker: mike $ (BRL)";
d185 1
a185 1
	cvt_vlblock_to_solids( vbp, name );
d191 61
d494 1
a494 1
		for( p = tp_cindex[*cp]; ((stroke= *p)&0xFF) != LAST; p++ )  {
d497 1
a497 1
			if( (stroke&0xFF)==NEGY )  {
@


10.1
log
@Release_4.0
@
text
@a5 1
 *	invent_solid		Turn list of vectors into phony solid
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 9.10 91/09/21 03:11:33 mike Exp $ (BRL)";
@


9.10
log
@TINY is signed, don't need 0377 mask.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 9.9 91/08/28 04:20:28 mike Exp $ (BRL)";
@


9.9
log
@Stardent inspired fix -- unsigned char was improperly initialized.
matches change in libplot3/symbol.c
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 9.8 91/02/02 00:01:38 mike Exp $ (BRL)";
d372 1
a372 1
		while( (*p++ & 0377) != LAST );
@


9.8
log
@Converted to new rt_vlist structure
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 9.7 90/05/24 03:05:11 mike Exp $ (BRL)";
d66 2
a67 2
#define	LAST		0200		/* Marks end of stroke list */
#define	NEGY		0201		/* Denotes negative y stroke */
@


9.7
log
@Moved generic vlblock stuff into librt.
Moved invent_solid & friends into dodraw.c
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 9.6 90/05/24 00:19:27 mike Exp $ (BRL)";
a164 1
	struct vlhead	vhead;
d166 1
a166 1
	struct vlblock	*vbp;
d201 1
a201 1
struct vlblock	*vbp;
d204 1
a204 1
	register struct vlhead	*vhead;
d217 1
a217 1
	vhead = &vbp->cvp[0].head;	/* Yellow */
d272 1
a272 1
			ADD_VL( vhead, arg, 0 );
d277 1
a277 1
			ADD_VL( vhead, arg, 0 );
d283 1
a283 1
			ADD_VL( vhead, arg, 1 );
d288 1
a288 1
			ADD_VL( vhead, arg, 1 );
d295 2
a296 2
			ADD_VL( vhead, a, 0 );
			ADD_VL( vhead, b, 1 );
d303 2
a304 2
			ADD_VL( vhead, a, 0 );
			ADD_VL( vhead, b, 1 );
d310 2
a311 2
			ADD_VL( vhead, arg, 0 );
			ADD_VL( vhead, arg, 1 );
d316 2
a317 2
			ADD_VL( vhead, arg, 0 );
			ADD_VL( vhead, arg, 1 );
d327 5
a331 2
			if( vhead->vh_first != VL_NULL )  {
				VMOVE( last_pos, vhead->vh_last->vl_pnt );
d389 1
a389 1
register struct vlhead	*vhead;
d432 1
a432 1
		ADD_VL( vhead, loc, 0 );		/* move */
d455 1
a455 1
				ADD_VL( vhead, loc, 1 );
d457 1
a457 1
				ADD_VL( vhead, loc, 0 );
@


9.6
log
@Somewhat modularized.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 9.5 90/05/22 16:03:37 mike Exp $ (BRL)";
a156 78
struct color_vlist_head {
	int			count;
	struct color_vlist	*cvp;
};

struct color_vlist {
	long			rgb;
	struct vlhead		head;
};

struct color_vlist_head *
color_vlist_init()
{
	struct color_vlist_head *cvh;
	int	i;

	GETSTRUCT( cvh, color_vlist_head );
	cvh->count = 32;
	cvh->cvp = (struct color_vlist *)rt_malloc(
		cvh->count * sizeof(struct color_vlist),
		"color_vlist[]");

	for( i=0; i < cvh->count; i++ )  {
		cvh->cvp[i].rgb = 0;	/* black, unused */
		cvh->cvp[i].head.vh_first = VL_NULL;
		cvh->cvp[i].head.vh_last = VL_NULL;
	}
	cvh->cvp[0].rgb = 0xFFFF00L;	/* Yellow, default */
	cvh->cvp[1].rgb = 0xFFFFFFL;	/* White */

	return(cvh);
}

void
color_vlist_free(cvh)
struct color_vlist_head *cvh;
{
	int	i;

	for( i=0; i < cvh->count; i++ )  {
		/* Release any remaining vlist storage */
		if( cvh->cvp[i].rgb == 0 )  continue;
		if( cvh->cvp[i].head.vh_first == VL_NULL) continue;
		FREE_VL( cvh->cvp[i].head.vh_first );
	}

	rt_free( (char *)(cvh->cvp), "color_vlist[]" );
	rt_free( (char *)cvh, "color_vlist_head" );
}

struct vlhead *
color_vlist_find( cvh, r, g, b )
struct color_vlist_head *cvh;
{
	long	new;
	int	n;

	new = ((r&0xFF)<<16)|((g&0xFF)<<8)|(b&0xFF);

	/* Map black plots into default color (yellow) */
	if( new == 0 ) return( &cvh->cvp[0].head );

	for( n=0; n < cvh->count; n++ )  {
		if( cvh->cvp[n].rgb == 0 )  {
			/* Allocate empty slot */
			cvh->cvp[n].rgb = new;
			return( &cvh->cvp[n].head );
		}
		if( cvh->cvp[n].rgb == new )
			return( &cvh->cvp[n].head );
	}
	/*  RGB does not match any existing entry, and table is full.
	 *  Eventually, enlarge table.
	 *  For now, just default to yellow.
	 */
	return( &cvh->cvp[0].head );
}

d167 1
a167 1
	struct color_vlist_head	*cvh;
d179 2
a180 2
	cvh = color_vlist_init();
	ret = uplot_vlist( cvh, fp );
d183 1
a183 1
		color_vlist_free(cvh);
d187 1
a187 1
	cvt_vlist_to_solids( cvh, name );
d189 1
a189 1
	color_vlist_free(cvh);
a192 27
cvt_vlist_to_solids( cvh, name )
struct color_vlist_head	*cvh;
char		*name;
{
	int		i;
	char		shortname[32];
	char		namebuf[64];
	char		cmd_buf[64];

	strncpy( shortname, name, 16-6 );
	shortname[16-6] = '\0';
	/* Remove any residue colors from a previous overlay w/same name */
	sprintf( cmd_buf, "kill %s*\n", shortname );
	cmdline(cmd_buf);

	for( i=0; i < cvh->count; i++ )  {
		if( i== 0 )  {
			invent_solid( name, &cvh->cvp[0] );
			continue;
		}
		if( cvh->cvp[i].rgb == 0 )  continue;
		sprintf( namebuf, "%s%x",
			shortname, cvh->cvp[i].rgb );
		invent_solid( namebuf, &cvh->cvp[i] );
	}
}

a193 93
 *			I N V E N T _ S O L I D
 *
 *  Invent a solid by adding a fake entry in the database table,
 *  adding an entry to the solid table, and populating it with
 *  the given vector list.
 *
 *  This parallels much of the code in dodraw.c
 */
int
invent_solid( name, cvl )
char	*name;
struct color_vlist	*cvl;
{
	register struct directory *dp;
	register struct solid *sp;
	register struct vlist *vp;
	struct vlhead	*vhead;
	vect_t		max, min;

	vhead = &cvl->head;

#define PHONY_ADDR	(-1L)
	if( (dp = db_lookup( dbip,  name, LOOKUP_QUIET )) != DIR_NULL )  {
		if( dp->d_addr != PHONY_ADDR )  {
			printf("invent_solid(%s) would clobber existing database entry, ignored\n");
			return(-1);
		}
		/* Name exists from some other overlay,
		 * zap any associated solids
		 */
		eraseobj(dp);
	} else {
		/* Need to enter phony name in directory structure */
		dp = db_diradd( dbip,  name, PHONY_ADDR, 0, DIR_SOLID );
	}

	/* Obtain a fresh solid structure, and fill it in */
	GET_SOLID(sp);

	VSETALL( max, -INFINITY );
	VSETALL( min,  INFINITY );
	sp->s_vlist = vhead->vh_first;
	vhead->vh_first = vhead->vh_last = VL_NULL;
	sp->s_vlen = 0;
	for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
		/* XXX need to look at types here */
		VMINMAX( min, max, vp->vl_pnt );
		sp->s_vlen++;
	}
	VSET( sp->s_center,
		(max[X] + min[X])*0.5,
		(max[Y] + min[Y])*0.5,
		(max[Z] + min[Z])*0.5 );

	sp->s_size = max[X] - min[X];
	MAX( sp->s_size, max[Y] - min[Y] );
	MAX( sp->s_size, max[Z] - min[Z] );

	/* set path information -- this is a top level node */
	sp->s_last = 0;
	sp->s_path[0] = dp;

	sp->s_iflag = DOWN;
	sp->s_soldash = 0;
	sp->s_Eflag = 1;		/* Can't be solid edited! */
	sp->s_color[0] = sp->s_basecolor[0] = (cvl->rgb>>16) & 0xFF;
	sp->s_color[1] = sp->s_basecolor[1] = (cvl->rgb>> 8) & 0xFF;
	sp->s_color[2] = sp->s_basecolor[2] = (cvl->rgb    ) & 0xFF;
	sp->s_regionid = 0;
	sp->s_addr = 0;
	sp->s_bytes = 0;

	/* Cvt to displaylist, determine displaylist memory requirement. */
	if( !no_memory && (sp->s_bytes = dmp->dmr_cvtvecs( sp )) != 0 )  {
		/* Allocate displaylist storage for object */
		sp->s_addr = memalloc( &(dmp->dmr_map), sp->s_bytes );
		if( sp->s_addr == 0 )  {
			no_memory = 1;
			(void)printf("invent_solid: out of Displaylist\n");
			sp->s_bytes = 0;	/* not drawn */
		} else {
			sp->s_bytes = dmp->dmr_load(sp->s_addr, sp->s_bytes );
		}
	}

	/* Solid successfully drawn, add to linked list of solid structs */
	APPEND_SOLID( sp, HeadSolid.s_back );
	dmp->dmr_viewchange( DM_CHGV_ADD, sp );
	dmp->dmr_colorchange();
	return(0);		/* OK */
}

/*
d201 2
a202 2
uplot_vlist( cvh, fp )
struct color_vlist_head	*cvh;
d218 1
a218 1
	vhead = &cvh->cvp[0].head;	/* Yellow */
d322 1
a322 1
			vhead = color_vlist_find( cvh,
@


9.5
log
@Modified to remove residue overlays w/same name.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 9.4 90/05/22 14:52:10 mike Exp $ (BRL)";
a40 4
extern void	perror();
extern int	atoi(), execl(), fork(), nice(), wait();
extern long	time();

d157 5
d163 2
a164 2
	long		rgb;
	struct vlhead	head;
d167 68
d245 1
a245 5
	int		i;
	struct color_vlist	color_vlist[32];
	char		shortname[32];
	char		namebuf[64];
	char		cmd_buf[64];
d257 6
a262 4
	for( i=0; i<32; i++ )  {
		color_vlist[i].rgb = 0;		/* black, unused */
		color_vlist[i].head.vh_first =
			color_vlist[i].head.vh_last = VL_NULL;
a263 3
	ret = uplot_vlist( color_vlist, 32, fp );
	fclose(fp);
	if( ret < 0 )  return;
d265 15
d286 1
a286 1
	for( i=0; i<32; i++ )  {
d288 1
a288 1
			invent_solid( name, &color_vlist[0] );
d291 1
a291 1
		if( color_vlist[i].rgb == 0 )  continue;
d293 2
a294 2
			shortname, color_vlist[i].rgb );
		invent_solid( namebuf, &color_vlist[i] );
a295 2

	dmaflag++;
d341 1
d343 2
a344 1
	for( vp = vhead->vh_first; vp != VL_NULL; vp = vp->vl_forw )  {
d399 2
a400 3
uplot_vlist( cvl, ncvl, fp )
struct color_vlist	*cvl;
int			ncvl;
d416 1
a416 2
	cvl[0].rgb = 0xFFFF00L;		/* Yellow */
	vhead = &cvl[0].head;
d520 2
a521 15
			{
				long	new;
				int	n;
				new = ((carg[0]&0xFF)<<16)|((carg[1]&0xFF)<<8)|(carg[2]&0xFF);
				for( n=0; n<ncvl; n++ )  {
					if( cvl[n].rgb == 0 )  {
						cvl[n].rgb = new;
						goto match;
					}
					if( cvl[n].rgb == new )  goto match;
				}
				n = 0;	/* not found, table full => yellow */
match:
				vhead = &cvl[n].head;
			}
@


9.4
log
@Added ability to process color-change directives found in the plot file.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 9.3 90/05/22 14:16:37 mike Exp $ (BRL)";
d180 1
d201 6
d212 1
a212 2
		strncpy( shortname, name, 16-6 );
		shortname[16-6] = '\0';
@


9.3
log
@Added stroke table for vector fonts.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 9.2 90/05/22 13:06:57 mike Exp $ (BRL)";
d161 5
d172 2
a173 2
	char	*name;
	FILE	*fp;
d175 5
a179 1
	int	ret;
d191 6
a196 2
	vhead.vh_first = vhead.vh_last = VL_NULL;
	ret = uplot_vlist( &vhead, fp );
d200 11
a210 1
	invent_solid( name, &vhead );
d225 1
a225 1
invent_solid( name, vhead )
d227 1
a227 1
struct vlhead	*vhead;
d232 1
d235 2
d278 4
a281 4
	sp->s_Eflag = 0;		/* This is a solid */
	sp->s_color[0] = sp->s_basecolor[0] = 255;
	sp->s_color[1] = sp->s_basecolor[1] = 255;
	sp->s_color[2] = sp->s_basecolor[2] = 0;
d314 3
a316 2
uplot_vlist( vhead, fp )
register struct vlhead	*vhead;
d319 1
d332 3
d437 15
@


9.2
log
@Changed to argv/argc
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/overlay.c,v 9.1 89/05/19 06:03:35 mike Rel3_5 $ (BRL)";
d45 39
d159 1
d293 1
d295 1
d299 1
d302 1
d319 23
a341 21
				switch( up->targ ){
					case TSHORT:
						arg[i] = getshort(fp);
						break;
					case TIEEE:
						fread( inbuf, 8, 1, fp );
						ntohd( &arg[i], inbuf, 1 );
						break;
					case TSTRING:
						while( (cc = getc(fp)) != '\n'
							&& cc != EOF )
								;
						break;
					case TCHAR:
						(void) getc(fp);
						arg[i] = 0;
						break;
					case TNONE:
					default:
						arg[i] = 0;	/* ? */
						break;
d404 13
d437 1090
@


9.1
log
@Release_3.5
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: overlay.c,v 8.6 89/05/17 23:34:51 mike Exp $ (BRL)";
a44 3
extern int	numargs;	/* number of args */
extern char	*cmd_args[];	/* array of pointers to args */

d123 3
a125 1
f_overlay()
d132 1
a132 1
	if( numargs <= 2 )
d135 1
a135 1
		name = cmd_args[2];
d137 2
a138 2
	if( (fp = fopen(cmd_args[1], "r")) == NULL )  {
		perror(cmd_args[1]);
@


8.6
log
@Added colorchange() call.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: overlay.c,v 8.5 89/05/11 21:42:31 mike Locked $ (BRL)";
@


8.5
log
@db_diradd had the length and flags parameters backward
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: overlay.c,v 8.4 89/04/06 20:40:14 phil Locked $ (BRL)";
d237 1
@


8.4
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: overlay.c,v 8.3 89/01/18 01:53:22 mike Locked $ (BRL)";
d184 1
a184 1
		dp = db_diradd( dbip,  name, PHONY_ADDR, DIR_SOLID, 0 );
@


8.3
log
@Includes changes in how MGED colors the various solids.
Externally, the color selection now matches that used by RT.
Internally, this was accomplished by adding 3 more fields
to the solid table (s_basecolor[], s_color[], s_dmindex),
and eliminating the mt_dm_int value from the region-id-based
material table.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: overlay.c,v 8.2 88/12/06 01:40:09 mike Locked $ (BRL)";
d37 1
@


8.2
log
@Converted to new db_*() routines.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/overlay.c,v 1.3 88/10/29 22:55:39 mike Exp $ (BRL)";
a46 7
static struct mater overlay_mater = {
	0, 32767,
	DM_YELLOW,
	255, 255, 0,
	MATER_NO_ADDR, 0
};

d213 3
a215 1
	sp->s_materp = (char *)&overlay_mater;
@


8.1
log
@Release_3.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: overlay.c,v 1.3 88/09/15 21:10:30 phil Exp $ (BRL)";
d35 1
a36 1
#include "./objdir.h"
d179 1
a179 1
	if( (dp = lookup( name, LOOKUP_QUIET )) != DIR_NULL )  {
d190 1
a190 1
		dp = dir_add( name, PHONY_ADDR, DIR_SOLID, 0 );
a195 1
#define INFINITY	1.0e20
d238 1
a238 7
	/* Solid is successfully drawn.  Compute maximum. */
	/* This should be done with an RPP instead! XXX */
	MAX( maxview, sp->s_center[X] + sp->s_size );
	MAX( maxview, sp->s_center[Y] + sp->s_size );
	MAX( maxview, sp->s_center[Z] + sp->s_size );

	/* Add to linked list of solid structs */
@


1.3
log
@bug in number of args for "arc" UnixPlot command
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: overlay.c,v 1.2 88/05/15 23:05:16 mike Exp $ (BRL)";
@


1.2
log
@lint fixes
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: overlay.c,v 1.1 88/02/26 22:41:24 mike Locked $ (BRL)";
d100 1
a100 1
/*a*/	{ TSHORT, 3, "arc" },
d117 1
a117 1
/*r*/	{ TIEEE, 3, "d_arc" },
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 7.6 88/02/25 06:04:45 mike Exp $ (BRL)";
d168 1
d248 1
@
