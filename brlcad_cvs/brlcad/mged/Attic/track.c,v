head	11.33;
access;
symbols
	ansi-20040405-merged:11.29.2.2
	postmerge-20040405-ansi:11.31
	premerge-20040404-ansi:11.30
	postmerge-autoconf:11.30
	autoconf-freeze:11.29.10.2
	premerge-autoconf:11.30
	postmerge-20040315-windows:11.30
	premerge-20040315-windows:11.30
	windows-20040315-freeze:11.29.4.1
	autoconf-20031203:11.29
	autoconf-20031202:11.29
	autoconf-branch:11.29.0.10
	phong-branch:11.29.0.8
	photonmap-branch:11.29.0.6
	rel-6-1-DP:11.29
	windows-branch:11.29.0.4
	rel-6-0-2:11.27
	ansi-branch:11.29.0.2
	rel-6-0-1-branch:11.27.0.2
	hartley-6-0-post:11.28
	hartley-6-0-pre:11.27
	rel-6-0-1:11.27
	rel-6-0:11.26
	rel-5-4:11.18
	offsite-5-3-pre:11.23
	rel-5-3:11.18
	rel-5-2:11.18
	rel-5-1-branch:11.18.0.2
	rel-5-1:11.18
	rel-5-0:11.16
	rel-5-0-beta:11.15
	rel-4-5:11.15
	ctj-4-5-post:11.14
	ctj-4-5-pre:11.14
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.33
date	2004.05.21.17.47.50;	author morrison;	state dead;
branches;
next	11.32;

11.32
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.31;

11.31
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2004.02.02.17.39.35;	author morrison;	state Exp;
branches;
next	11.29;

11.29
date	2002.08.20.17.08.26;	author jra;	state Exp;
branches
	11.29.2.1
	11.29.4.1
	11.29.10.1;
next	11.28;

11.28
date	2002.08.15.20.55.39;	author hartley;	state Exp;
branches;
next	11.27;

11.27
date	2002.05.17.12.55.27;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2001.10.02.19.24.32;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	2001.06.01.19.23.25;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	2001.03.23.22.05.35;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	2000.10.24.19.05.09;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.10.19.21.25.01;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.09.08.05.55.49;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.08.24.02.54.14;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.08.19.03.10.50;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	99.12.29.23.23.26;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	99.11.24.14.26.42;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	99.09.01.18.55.11;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	97.03.03.16.19.50;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	96.10.03.20.40.46;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.10.01.17.26.29;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.09.23.18.16.31;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	96.03.01.19.24.48;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.05.12;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.42;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.12.27.18.15.44;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.12.16.19.37.27;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.11.28.14.43.32;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	94.08.23.18.28.59;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.06.03.17.37.12;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.06.01.14.56.06;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.23;	author mike;	state Rel4_0;
branches;
next	9.5;

9.5
date	91.01.12.08.25.38;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.08.00.31.26;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.07.03.17.17;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.04.21.06.06.20;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.04.05;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.05.11.21.42.35;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.04.06.19.21.13;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	89.01.16.22.51.48;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.02.34.09;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.37.30;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.09.21.02.34.14;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.05.15.23.05.22;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.07.05;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.02.07;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.05.35;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.22.27;	author mike;	state Rel;
branches;
next	4.3;

4.3
date	87.02.13.00.13.16;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.11.05.38.34;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.23.19;	author mike;	state Rel1;
branches;
next	1.5;

1.5
date	86.10.06.22.03.34;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.09.23.17.42.00;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.08.12.06.51.03;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.05.28.01.43.19;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.03.10.21.45.33;	author mike;	state Exp;
branches;
next	;

11.29.2.1
date	2002.09.19.18.02.06;	author morrison;	state Exp;
branches;
next	11.29.2.2;

11.29.2.2
date	2004.03.17.21.22.05;	author morrison;	state Exp;
branches;
next	;

11.29.4.1
date	2004.03.11.23.46.37;	author morrison;	state Exp;
branches;
next	;

11.29.10.1
date	2004.02.12.18.34.16;	author erikg;	state Exp;
branches;
next	11.29.10.2;

11.29.10.2
date	2004.03.15.14.07.41;	author erikg;	state Exp;
branches;
next	;


desc
@Builds a track, given wheel positions
@


11.33
log
@moved to src/mged/
@
text
@
/*
 *			T R A C K . C
 *
 *	f_amtrack():	Adds "tracks" to the data file given the required info
 *
 *  Author -
 *	Keith A. Applin
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/track.c,v 11.32 2004/05/10 15:30:48 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <signal.h>
#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "wdb.h"
#include "./ged.h"
#include "./mged_dm.h"
#include "./cmd.h"

extern void aexists(char *name);

static int	Trackpos = 0;
static fastf_t	plano[4], plant[4];

static struct track_solid
{
	int s_type;
	char s_name[NAMESIZE];
	fastf_t s_values[24];
} sol;

void		crname(char *name, int pos), slope(fastf_t *wh1, fastf_t *wh2, fastf_t *t), crdummy(fastf_t *w, fastf_t *t, int flag), trcurve(fastf_t *wh, fastf_t *t);
void		bottom(fastf_t *vec1, fastf_t *vec2, fastf_t *t), top(fastf_t *vec1, fastf_t *vec2, fastf_t *t), crregion(char *region, char *op, int *members, int number, char *solidname), itoa(int n, char *s, int w);

/*
 *
 *	F _ A M T R A C K ( ) :	adds track given "wheel" info
 *
 */
int
f_amtrack(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{

	fastf_t fw[3], lw[3], iw[3], dw[3], tr[3];
	char solname[12], regname[12], grpname[9], oper[3];
	int i, j, memb[4];
	char temp[4];
	vect_t	temp1, temp2;
	int item, mat, los;
	int arg;
	int edit_result;
	struct bu_list head;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	BU_LIST_INIT(&head);

	if(argc < 1 || 27 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help track");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* interupts */
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	else
	  return TCL_OK;

	oper[0] = oper[2] = WMOP_INTERSECT;
	oper[1] = WMOP_SUBTRACT;

	arg = 1;

	/* get the roadwheel info */
	if ( argc < arg+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter X of the FIRST roadwheel: ",
			   (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	fw[0] = atof( argv[arg] ) * local2base;
	++arg;

	if( argc < arg+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter X of the LAST roadwheel: ",
			   (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	lw[0] = atof( argv[arg] ) * local2base;
	++arg;

	if( fw[0] <= lw[0] ) {
	  Tcl_AppendResult(interp, "First wheel after last wheel - STOP\n", (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}

	if( argc < arg+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter Z of the roadwheels: ",
			   (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	fw[1] = lw[1] = atof( argv[arg] ) * local2base;
	++arg;

	if( argc < arg+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter radius of the roadwheels: ",
			   (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	fw[2] = lw[2] = atof( argv[arg] ) * local2base;
	++arg;
	if( fw[2] <= 0 ) {
	  Tcl_AppendResult(interp, "Radius <= 0 - STOP\n", (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}

	if ( argc < arg+1 ) {
	  /* get the drive wheel info */
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter X of the drive (REAR) wheel: ",
			   (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	dw[0] = atof( argv[arg] ) * local2base;
	++arg;
	if( dw[0] >= lw[0] ) {
	  Tcl_AppendResult(interp, "DRIVE wheel not in the rear - STOP \n", (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}

	if( argc < arg+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter Z of the drive (REAR) wheel: ",
			   (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	dw[1] = atof( argv[arg] ) * local2base;
	++arg;

	if( argc < arg+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter radius of the drive (REAR) wheel: ",
			   (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	dw[2] = atof( argv[arg] ) * local2base;
	++arg;
	if( dw[2] <= 0 ) {
	  Tcl_AppendResult(interp, "Radius <= 0 - STOP\n", (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	
	/* get the idler wheel info */
	if( argc < arg+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter X of the idler (FRONT) wheel: ",
			   (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	iw[0] = atof( argv[arg] ) * local2base;
	++arg;
	if( iw[0] <= fw[0] ) {
	  Tcl_AppendResult(interp, "IDLER wheel not in the front - STOP \n", (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}

	if( argc < arg+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter Z of the idler (FRONT) wheel: ",
			   (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	iw[1] = atof( argv[arg] ) * local2base;
	++arg;

	if( argc < arg+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter radius of the idler (FRONT) wheel: ",
			   (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	iw[2] = atof( argv[arg] ) * local2base;
	++arg;
	if( iw[2] <= 0 ) {
	  Tcl_AppendResult(interp, "Radius <= 0 - STOP\n", (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}

	/* get track info */
	if( argc < arg+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter Y-MIN of the track: ",
			   (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	tr[2] = tr[0] = atof( argv[arg] ) * local2base;
	++arg;

	if( argc < arg+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter Y-MAX of the track: ",
			   (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	tr[1] = atof( argv[arg] ) * local2base;
	++arg;
	if( tr[0] == tr[1] ) {
	  Tcl_AppendResult(interp, "MIN == MAX ... STOP\n", (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	if( tr[0] > tr[1] ) {
	  Tcl_AppendResult(interp, "MIN > MAX .... will switch\n", (char *)NULL);
	  tr[1] = tr[0];
	  tr[0] = tr[2];
	}

	if( argc < arg+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter track thickness: ",
			   (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}
	tr[2] = atof( argv[arg] ) * local2base;
	++arg;
	if( tr[2] <= 0 ) {
	  Tcl_AppendResult(interp, "Track thickness <= 0 - STOP\n", (char *)NULL);
	  edit_result = TCL_ERROR;
	  goto end;
	}

	solname[0] = regname[0] = grpname[0] = 't';
	solname[1] = regname[1] = grpname[1] = 'r';
	solname[2] = regname[2] = grpname[2] = 'a';
	solname[3] = regname[3] = grpname[3] = 'c';
	solname[4] = regname[4] = grpname[4] = 'k';
	solname[5] = regname[5] = '.';
	solname[6] = 's';
	regname[6] = 'r';
	solname[7] = regname[7] = '.';
	grpname[5] = solname[8] = regname[8] = '\0';
	grpname[8] = solname[11] = regname[11] = '\0';
/*
	bu_log("\nX of first road wheel  %10.4f\n",fw[0]);
	bu_log("X of last road wheel   %10.4f\n",lw[0]);
	bu_log("Z of road wheels       %10.4f\n",fw[1]);
	bu_log("radius of road wheels  %10.4f\n",fw[2]);
	bu_log("\nX of drive wheel       %10.4f\n",dw[0]);
	bu_log("Z of drive wheel       %10.4f\n",dw[1]);
	bu_log("radius of drive wheel  %10.4f\n",dw[2]);
	bu_log("\nX of idler wheel       %10.4f\n",iw[0]);
	bu_log("Z of idler wheel       %10.4f\n",iw[1]);
	bu_log("radius of idler wheel  %10.4f\n",iw[2]);
	bu_log("\nY MIN of track         %10.4f\n",tr[0]);
	bu_log("Y MAX of track         %10.4f\n",tr[1]);
	bu_log("thickness of track     %10.4f\n",tr[2]);
*/

/* Check for names to use:
 *	1.  start with track.s.1->10 and track.r.1->10
 *	2.  if bad, increment count by 10 and try again
 */

tryagain:	/* sent here to try next set of names */

	for(i=0; i<11; i++) {
		crname(solname, i);
		crname(regname, i);
		if(	(db_lookup( dbip, solname, LOOKUP_QUIET) != DIR_NULL)	||
			(db_lookup( dbip, regname, LOOKUP_QUIET) != DIR_NULL)	) {
			/* name already exists */
			solname[8] = regname[8] = '\0';
			if( (Trackpos += 10) > 500 ) {
			  Tcl_AppendResult(interp, "Track: naming error -- STOP\n",
					   (char *)NULL);
			  edit_result = TCL_ERROR;
			  goto end;
			}
			goto tryagain;
		}
		solname[8] = regname[8] = '\0';
	}

	/* no interupts */
	(void)signal( SIGINT, SIG_IGN );

	/* find the front track slope to the idler */
	for(i=0; i<24; i++)
		sol.s_values[i] = 0.0;

	slope(fw, iw, tr);
	VMOVE(temp2, &sol.s_values[0]);
	crname(solname, 1);
	(void)strcpy(sol.s_name, solname);
	sol.s_type = ID_ARB8;
	if( wrobj(solname, DIR_SOLID) ) 
	  return TCL_ERROR;

	solname[8] = '\0';

	/* find track around idler */
	for(i=0; i<24; i++)
		sol.s_values[i] = 0.0;
	sol.s_type = ID_TGC;
	trcurve(iw, tr);
	crname(solname, 2);
	(void)strcpy(sol.s_name, solname);
	if( wrobj( solname , DIR_SOLID ) )
	  return TCL_ERROR;
	solname[8] = '\0';
	/* idler dummy rcc */
	sol.s_values[6] = iw[2];
	sol.s_values[11] = iw[2];
	VMOVE(&sol.s_values[12], &sol.s_values[6]);
	VMOVE(&sol.s_values[15], &sol.s_values[9]);
	crname(solname, 3);
	(void)strcpy(sol.s_name, solname);
	if( wrobj( solname , DIR_SOLID ) )
		return TCL_ERROR;
	solname[8] = '\0';

	/* find idler track dummy arb8 */
	for(i=0; i<24; i++)
		sol.s_values[i] = 0.0;
	crname(solname, 4);
	(void)strcpy(sol.s_name, solname);
	sol.s_type = ID_ARB8;
	crdummy(iw, tr, 1);
	if( wrobj(solname,DIR_SOLID) )
	  return TCL_ERROR;
	solname[8] = '\0';

	/* track slope to drive */
	for(i=0; i<24; i++)
		sol.s_values[i] = 0.0;
	slope(lw, dw, tr);
	VMOVE(temp1, &sol.s_values[0]);
	crname(solname, 5);
	(void)strcpy(sol.s_name, solname);
	if(wrobj(solname,DIR_SOLID))
		return TCL_ERROR;
	solname[8] = '\0';

	/* track around drive */
	for(i=0; i<24; i++)
		sol.s_values[i] = 0.0;
	sol.s_type = ID_TGC;
	trcurve(dw, tr);
	crname(solname, 6);
	(void)strcpy(sol.s_name, solname);
	if( wrobj(solname,DIR_SOLID) )
		return TCL_ERROR;
	solname[8] = '\0';

	/* drive dummy rcc */
	sol.s_values[6] = dw[2];
	sol.s_values[11] = dw[2];
	VMOVE(&sol.s_values[12], &sol.s_values[6]);
	VMOVE(&sol.s_values[15], &sol.s_values[9]);
	crname(solname, 7);
	(void)strcpy(sol.s_name, solname);
	if( wrobj(solname,DIR_SOLID) )
		return TCL_ERROR;
	solname[8] = '\0';

	/* drive dummy arb8 */
	for(i=0; i<24; i++)
		sol.s_name[i] = 0.0;
	crname(solname, 8);
	(void)strcpy(sol.s_name, solname);
	sol.s_type = ID_ARB8;
	crdummy(dw, tr, 2);
	if( wrobj(solname,DIR_SOLID) )
		return TCL_ERROR;
	solname[8] = '\0';
	
	/* track bottom */
	temp1[1] = temp2[1] = tr[0];
	bottom(temp1, temp2, tr);
	crname(solname, 9);
	(void)strcpy(sol.s_name, solname);
	if( wrobj(solname,DIR_SOLID) )
		return TCL_ERROR;
	solname[8] = '\0';

	/* track top */
	temp1[0] = dw[0];
	temp1[1] = temp2[1] = tr[0];
	temp1[2] = dw[1] + dw[2];
	temp2[0] = iw[0];
	temp2[2] = iw[1] + iw[2];
	top(temp1, temp2, tr);
	crname(solname, 10);
	(void)strcpy(sol.s_name, solname);
	if( wrobj(solname,DIR_SOLID) )
		return TCL_ERROR;
	solname[8] = '\0';

	/* add the regions */
	item = item_default;
	mat = mat_default;
	los = los_default;
	item_default = 500;
	mat_default = 1;
	los_default = 50;
	/* region 1 */
	memb[0] = 1;
	memb[1] = 4;
	crname(regname, 1);
	crregion(regname, oper, memb, 2, solname);
	solname[8] = regname[8] = '\0';

	/* region 2 */
	crname(regname, 2);
	memb[0] = 2;
	memb[1] = 3;
	memb[2] = 4;
	crregion(regname, oper, memb, 3, solname);
	solname[8] = regname[8] = '\0';

	/* region 5 */
	crname(regname, 5);
	memb[0] = 5;
	memb[1] = 8;
	crregion(regname, oper, memb, 2, solname);
	solname[8] = regname[8] = '\0';

	/* region 6 */
	crname(regname, 6);
	memb[0] = 6;
	memb[1] = 7;
	memb[2] = 8;
	crregion(regname, oper, memb, 3, solname);
	solname[8] = regname[8] = '\0';

	/* region 9 */
	crname(regname, 9);
	memb[0] = 9;
	memb[1] = 1;
	memb[2] = 5;
	oper[2] = WMOP_SUBTRACT;
	crregion(regname, oper, memb, 3, solname);
	solname[8] = regname[8] = '\0';

	/* region 10 */
	crname(regname, 10);
	memb[0] = 10;
	memb[1] = 4;
	memb[2] = 8;
	crregion(regname, oper, memb, 3, solname);
	solname[8] = regname[8] = '\0';

	/* group all the track regions */
	j = 1;
	if( (i = Trackpos / 10 + 1) > 9 )
		j = 2;
	itoa(i, temp, j);
	(void)strcat(grpname, temp);
	grpname[8] = '\0';
	for(i=1; i<11; i++) {
		if( i == 3 || i ==4 || i == 7 || i == 8 )
			continue;
		regname[8] = '\0';
		crname(regname, i);
		if( db_lookup( dbip, regname, LOOKUP_QUIET) == DIR_NULL ) {
		  Tcl_AppendResult(interp, "group: ", grpname, " will skip member: ",
				   regname, "\n", (char *)NULL);
		  continue;
		}
		mk_addmember( regname, &head, NULL, WMOP_UNION );
	}

	/* Add them all at once */
	if( mk_comb( wdbp, grpname, &head,
	    0, NULL, NULL, NULL,
	    0, 0, 0, 0,
	    0, 1, 1 ) < 0 )
	{
		Tcl_AppendResult(interp,
			"An error has occured while adding '",
			grpname, "' to the database.\n", (char *)NULL);
	}

	/* draw this track */
	Tcl_AppendResult(interp, "The track regions are in group ", grpname,
			 "\n", (char *)NULL);
	{
		char	*arglist[3];
		arglist[0] = "e";
		arglist[1] = grpname;
		arglist[2] = NULL;
		edit_result = cmd_draw( clientData, interp, 2, arglist );
	}

	Trackpos += 10;
	item_default = item;
	mat_default = mat;
	los_default = los;
	grpname[5] = solname[8] = regname[8] = '\0';

	return edit_result;
end:
	(void)signal( SIGINT, SIG_IGN );
	return edit_result;
}

void
crname(char *name, int pos)
{
	int i, j;
	char temp[4];

	j=1;
	if( (i = Trackpos + pos) > 9 )
		j = 2;
	if( i > 99 )
		j = 3;
	itoa(i, temp, j);
	(void)strcat(name,temp);
	return;
}

int
wrobj( char name[], int flags )
{
	struct directory *tdp;
	struct rt_db_internal intern;
	int i;

	if(dbip == DBI_NULL)
	  return 0;

	if( db_lookup( dbip, name, LOOKUP_QUIET) != DIR_NULL ) {
	  Tcl_AppendResult(interp, "track naming error: ", name,
			   " already exists\n", (char *)NULL);
	  return(-1);
	}

	if( flags != DIR_SOLID )
	{
		Tcl_AppendResult(interp, "wrobj can only write solids, aborting\n" );
		return( -1 );
	}

	RT_INIT_DB_INTERNAL( &intern );
	switch( sol.s_type )
	{
		case ID_ARB8:
			{
				struct rt_arb_internal *arb;

				BU_GETSTRUCT( arb, rt_arb_internal );

				arb->magic = RT_ARB_INTERNAL_MAGIC;

				VMOVE( arb->pt[0], &sol.s_values[0] );
				for( i=1 ; i<8 ; i++ )
					VADD2( arb->pt[i], &sol.s_values[i*3], arb->pt[0] )

				intern.idb_ptr = (genptr_t)arb;
				intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
				intern.idb_type = ID_ARB8;
				intern.idb_meth = &rt_functab[ID_ARB8];
			}
			break;
		case ID_TGC:
			{
				struct rt_tgc_internal *tgc;

				BU_GETSTRUCT( tgc, rt_tgc_internal );

				tgc->magic = RT_TGC_INTERNAL_MAGIC;

				VMOVE( tgc->v, &sol.s_values[0] );
				VMOVE( tgc->h, &sol.s_values[3] );
				VMOVE( tgc->a, &sol.s_values[6] );
				VMOVE( tgc->b, &sol.s_values[9] );
				VMOVE( tgc->c, &sol.s_values[12] );
				VMOVE( tgc->d, &sol.s_values[15] );

				intern.idb_ptr = (genptr_t)tgc;
				intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
				intern.idb_type = ID_TGC;
				intern.idb_meth = &rt_functab[ID_TGC];
			}
			break;
		default:
			Tcl_AppendResult(interp, "Unrecognized solid type in 'wrobj', aborting\n", (char *)NULL );
			return( -1 );
	}

	if( (tdp = db_diradd( dbip, name, -1L, 0, flags, (genptr_t)&intern.idb_type)) == DIR_NULL )
	{
		rt_db_free_internal( &intern, &rt_uniresource );
		Tcl_AppendResult(interp, "Cannot add '", name, "' to directory, aborting\n", (char *)NULL );
		return( -1 );
	}

	if( rt_db_put_internal( tdp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		rt_db_free_internal( &intern, &rt_uniresource );
		Tcl_AppendResult(interp, "wrobj(", name, "):  write error\n", (char *)NULL);
		TCL_ERROR_RECOVERY_SUGGESTION;
		return( -1 );
	}
	return(0);
}

void
tancir(register fastf_t *cir1, register fastf_t *cir2)
{
	static fastf_t mag;
	vect_t	work;
	FAST fastf_t f;
	static fastf_t	temp, tempp, ang, angc;

	work[0] = cir2[0] - cir1[0];
	work[2] = cir2[1] - cir1[1];
	work[1] = 0.0;
	mag = MAGNITUDE( work );
	if( mag > 1.0e-20 || mag < -1.0e-20 )  {
		f = 1.0/mag;
	}  else {
	  Tcl_AppendResult(interp, "tancir():  0-length vector!\n", (char *)NULL);
	  return;
	}
	VSCALE(work, work, f);
	temp = acos( work[0] );
	if( work[2] < 0.0 )
		temp = 6.28318512717958646 - temp;
	tempp = acos( (cir1[2] - cir2[2]) * f );
	ang = temp + tempp;
	angc = temp - tempp;
	if( (cir1[1] + cir1[2] * sin(ang)) >
	    (cir1[1] + cir1[2] * sin(angc)) )
		ang = angc;
	plano[0] = cir1[0] + cir1[2] * cos(ang);
	plano[1] = cir1[1] + cir1[2] * sin(ang);
	plant[0] = cir2[0] + cir2[2] * cos(ang);
	plant[1] = cir2[1] + cir2[2] * sin(ang);

	return;
}

void
slope(fastf_t *wh1, fastf_t *wh2, fastf_t *t)
{
	int i, j, switchs;
	fastf_t	temp;
	fastf_t	mag;
	fastf_t	z, r, b;
	vect_t	del, work;

	switchs = 0;
	if( wh1[2] < wh2[2] ) {
		switchs++;
		for(i=0; i<3; i++) {
			temp = wh1[i];
			wh1[i] = wh2[i];
			wh2[i] = temp;
		}
	}
	tancir(wh1, wh2);
	if( switchs ) {
		for(i=0; i<3; i++) {
			temp = wh1[i];
			wh1[i] = wh2[i];
			wh2[i] = temp;
		}
	}
	if(plano[1] <= plant[1]) {
		for(i=0; i<2; i++) {
			temp = plano[i];
			plano[i] = plant[i];
			plant[i] = temp;
		}
	}
	del[1] = 0.0;
	del[0] = plano[0] - plant[0];
	del[2] = plano[1] - plant[1];
	mag = MAGNITUDE( del );
	work[0] = -1.0 * t[2] * del[2] / mag;
	if( del[0] < 0.0 )
		work[0] *= -1.0;
	work[1] = 0.0;
	work[2] = t[2] * fabs(del[0]) / mag;
	b = (plano[1] - work[2]) - (del[2]/del[0]*(plano[0] - work[0]));
	z = wh1[1];
	r = wh1[2];
	if( wh1[1] >= wh2[1] ) {
		z = wh2[1];
		r = wh2[2];
	}
	sol.s_values[2] = z - r - t[2];
	sol.s_values[1] = t[0];
	sol.s_values[0] = (sol.s_values[2] - b) / (del[2] / del[0]);
	sol.s_values[3] = plano[0] + (del[0]/mag) - work[0] - sol.s_values[0];
	sol.s_values[4] = 0.0;
	sol.s_values[5] = plano[1] + (del[2]/mag) - work[2] - sol.s_values[2];
	VADD2(&sol.s_values[6], &sol.s_values[3], work);
	VMOVE(&sol.s_values[9], work);
	work[0] = work[2] = 0.0;
	work[1] = t[1] - t[0];
	VMOVE(&sol.s_values[12], work);
	for(i=3; i<=9; i+=3) {
		j = i + 12;
		VADD2(&sol.s_values[j], &sol.s_values[i], work);
	}

	return;
}

void
crdummy(fastf_t *w, fastf_t *t, int flag)
{
	fastf_t	temp;
	vect_t	vec;
	int i, j;

	vec[1] = 0.0;
	if(plano[1] <= plant[1]) {
		for(i=0; i<2; i++) {
			temp = plano[i];
			plano[i] = plant[i];
			plant[i] = temp;
		}
	}

	vec[0] = w[2] + t[2] + 1.0;
	vec[2] = ( (plano[1] - w[1]) * vec[0] ) / (plano[0] - w[0]);
	if( flag > 1 )
		vec[0] *= -1.0;
	if(vec[2] >= 0.0)
		vec[2] *= -1.0;
	sol.s_values[0] = w[0];
	sol.s_values[1] = t[0] -1.0;
	sol.s_values[2] = w[1];
	VMOVE(&sol.s_values[3] , vec);
	vec[2] = w[2] + t[2] + 1.0;
	VMOVE(&sol.s_values[6], vec);
	vec[0] = 0.0;
	VMOVE(&sol.s_values[9], vec);
	vec[2] = 0.0;
	vec[1] = t[1] - t[0] + 2.0;
	VMOVE(&sol.s_values[12], vec);
	for(i=3; i<=9; i+=3) {
		j = i + 12;
		VADD2(&sol.s_values[j], &sol.s_values[i], vec);
	}

	return;

}

void
trcurve(fastf_t *wh, fastf_t *t)
{
	sol.s_values[0] = wh[0];
	sol.s_values[1] = t[0];
	sol.s_values[2] = wh[1];
	sol.s_values[4] = t[1] - t[0];
	sol.s_values[6] = wh[2] + t[2];
	sol.s_values[11] = wh[2] + t[2];
	VMOVE(&sol.s_values[12], &sol.s_values[6]);
	VMOVE(&sol.s_values[15], &sol.s_values[9]);
}

void
bottom(fastf_t *vec1, fastf_t *vec2, fastf_t *t)
{
	vect_t	tvec;
	int i, j;

	VMOVE(&sol.s_values[0], vec1);
	tvec[0] = vec2[0] - vec1[0];
	tvec[1] = tvec[2] = 0.0;
	VMOVE(&sol.s_values[3], tvec);
	tvec[0] = tvec[1] = 0.0;
	tvec[2] = t[2];
	VADD2(&sol.s_values[6], &sol.s_values[3], tvec);
	VMOVE(&sol.s_values[9], tvec);
	tvec[0] = tvec[2] = 0.0;
	tvec[1] = t[1] - t[0];
	VMOVE(&sol.s_values[12], tvec);

	for(i=3; i<=9; i+=3) {
		j = i + 12;
		VADD2(&sol.s_values[j], &sol.s_values[i], tvec);
	}
}

void
top(fastf_t *vec1, fastf_t *vec2, fastf_t *t)
{
	fastf_t	tooch, mag;
	vect_t	del, tvec;
	int i, j;

	tooch = t[2] * .25;
	del[0] = vec2[0] - vec1[0];
	del[1] = 0.0;
	del[2] = vec2[2] - vec1[2];
	mag = MAGNITUDE( del );
	VSCALE(tvec, del, tooch/mag);
	VSUB2(&sol.s_values[0], vec1, tvec);
	VADD2(del, del, tvec);
	VADD2(&sol.s_values[3], del, tvec);
	tvec[0] = tvec[2] = 0.0;
	tvec[1] = t[1] - t[0];
	VCROSS(del, tvec, &sol.s_values[3]);
	mag = MAGNITUDE( del );
	if(del[2] < 0)
		mag *= -1.0;
	VSCALE(&sol.s_values[9], del, t[2]/mag);
	VADD2(&sol.s_values[6], &sol.s_values[3], &sol.s_values[9]);
	VMOVE(&sol.s_values[12], tvec);

	for(i=3; i<=9; i+=3) {
		j = i + 12;
		VADD2(&sol.s_values[j], &sol.s_values[i], tvec);
	}
}

void
crregion(char *region, char *op, int *members, int number, char *solidname)
{
  int i;
  struct bu_list head;

  if(dbip == DBI_NULL)
    return;

  BU_LIST_INIT(&head);

  for(i=0; i<number; i++) {
    solidname[8] = '\0';
    crname(solidname, members[i]);
    if( db_lookup( dbip, solidname, LOOKUP_QUIET) == DIR_NULL ) {
      Tcl_AppendResult(interp, "region: ", region, " will skip member: ",
		       solidname, "\n", (char *)NULL);
      continue;
    }
    mk_addmember( solidname, &head, NULL, op[i] );
  }
  (void)mk_comb( wdbp, region, &head,
	    1, NULL, NULL, NULL,
	    500+Trackpos+i, 0, mat_default, los_default,
	    0, 1, 1 );
}




/*	==== I T O A ( )
 *	convert integer to ascii  wd format
 */
void
itoa(int n, char *s, int w)
{
	int	 c, i, j, sign;

	if( (sign = n) < 0 )	n = -n;
	i = 0;
	do	s[i++] = n % 10 + '0';	while( (n /= 10) > 0 );
	if( sign < 0 )	s[i++] = '-';

	/* blank fill array
	 */
	for( j = i; j < w; j++ )	s[j] = ' ';
	if( i > w )
	  Tcl_AppendResult(interp, "itoa: field length too small\n", (char *)NULL);
	s[w] = '\0';
	/* reverse the array
	 */
	for( i = 0, j = w - 1; i < j; i++, j-- ) {
		c    = s[i];
		s[i] = s[j];
		s[j] =    c;
	}
}

@


11.32
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/track.c,v 11.31 2004/04/05 09:09:12 morrison Exp $ (ARL)";
@


11.31
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d27 5
a31 1
#include "conf.h"
@


11.30
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.29 2002/08/20 17:08:26 jra Exp $ (ARL)";
d48 1
a48 1
extern void aexists();
d60 2
a61 2
void		crname(), slope(), crdummy(), trcurve();
void		bottom(), top(), crregion(), itoa();
d69 1
a69 5
f_amtrack(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d551 1
a551 3
crname(name, pos)
char name[];
int pos;
d653 1
a653 2
tancir( cir1, cir2 )
register fastf_t cir1[], cir2[];
d689 1
a689 2
slope( wh1, wh2 , t )
fastf_t wh1[], wh2[], t[];
d757 1
a757 3
crdummy( w, t, flag )
fastf_t	w[3], t[3];
int	flag;
d799 1
a799 2
trcurve( wh, t )
fastf_t wh[], t[];
d812 1
a812 3
bottom( vec1, vec2, t )
vect_t	vec1, vec2;
fastf_t	t[];
d836 1
a836 3
top( vec1, vec2, t )
vect_t	vec1, vec2;
fastf_t	t[];
d868 1
a868 3
crregion( region, op, members, number, solidname )
char region[], op[], solidname[];
int members[], number;
d901 1
a901 3
itoa( n, s, w )
char	 s[];
int   n,    w;
@


11.29
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1994 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.27 2002/05/17 12:55:27 morrison Exp $ (ARL)";
@


11.29.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/track.c,v 11.30 2004/02/02 17:39:35 morrison Exp $ (ARL)";
@


11.29.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.30 2004/02/02 17:39:35 morrison Exp $ (ARL)";
@


11.29.10.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.29.10.1 2004/02/12 18:34:16 erikg Exp $ (ARL)";
@


11.29.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.29 2002/08/20 17:08:26 jra Exp $ (ARL)";
d48 1
a48 1
extern void aexists(char *name);
d60 2
a61 2
void		crname(char *name, int pos), slope(fastf_t *wh1, fastf_t *wh2, fastf_t *t), crdummy(fastf_t *w, fastf_t *t, int flag), trcurve(fastf_t *wh, fastf_t *t);
void		bottom(fastf_t *vec1, fastf_t *vec2, fastf_t *t), top(fastf_t *vec1, fastf_t *vec2, fastf_t *t), crregion(char *region, char *op, int *members, int number, char *solidname), itoa(int n, char *s, int w);
d69 5
a73 1
f_amtrack(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d555 3
a557 1
crname(char *name, int pos)
d659 2
a660 1
tancir(register fastf_t *cir1, register fastf_t *cir2)
d696 2
a697 1
slope(fastf_t *wh1, fastf_t *wh2, fastf_t *t)
d765 3
a767 1
crdummy(fastf_t *w, fastf_t *t, int flag)
d809 2
a810 1
trcurve(fastf_t *wh, fastf_t *t)
d823 3
a825 1
bottom(fastf_t *vec1, fastf_t *vec2, fastf_t *t)
d849 3
a851 1
top(fastf_t *vec1, fastf_t *vec2, fastf_t *t)
d883 3
a885 1
crregion(char *region, char *op, int *members, int number, char *solidname)
d918 3
a920 1
itoa(int n, char *s, int w)
@


11.29.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.28
log
@Converted from K&R to ANSI C - RFH
@
text
@d48 1
a48 1
extern void aexists(char *name);
d60 2
a61 2
void		crname(char *name, int pos), slope(fastf_t *wh1, fastf_t *wh2, fastf_t *t), crdummy(fastf_t *w, fastf_t *t, int flag), trcurve(fastf_t *wh, fastf_t *t);
void		bottom(fastf_t *vec1, fastf_t *vec2, fastf_t *t), top(fastf_t *vec1, fastf_t *vec2, fastf_t *t), crregion(char *region, char *op, int *members, int number, char *solidname), itoa(int n, char *s, int w);
d69 5
a73 1
f_amtrack(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d555 3
a557 1
crname(char *name, int pos)
d659 2
a660 1
tancir(register fastf_t *cir1, register fastf_t *cir2)
d696 2
a697 1
slope(fastf_t *wh1, fastf_t *wh2, fastf_t *t)
d765 3
a767 1
crdummy(fastf_t *w, fastf_t *t, int flag)
d809 2
a810 1
trcurve(fastf_t *wh, fastf_t *t)
d823 3
a825 1
bottom(fastf_t *vec1, fastf_t *vec2, fastf_t *t)
d849 3
a851 1
top(fastf_t *vec1, fastf_t *vec2, fastf_t *t)
d883 3
a885 1
crregion(char *region, char *op, int *members, int number, char *solidname)
d918 3
a920 1
itoa(int n, char *s, int w)
@


11.27
log
@added matrix parameter to mk_addmember()
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.26 2001/10/02 19:24:32 jra Exp $ (ARL)";
d48 1
a48 1
extern void aexists();
d60 2
a61 2
void		crname(), slope(), crdummy(), trcurve();
void		bottom(), top(), crregion(), itoa();
d69 1
a69 5
f_amtrack(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d551 1
a551 3
crname(name, pos)
char name[];
int pos;
d653 1
a653 2
tancir( cir1, cir2 )
register fastf_t cir1[], cir2[];
d689 1
a689 2
slope( wh1, wh2 , t )
fastf_t wh1[], wh2[], t[];
d757 1
a757 3
crdummy( w, t, flag )
fastf_t	w[3], t[3];
int	flag;
d799 1
a799 2
trcurve( wh, t )
fastf_t wh[], t[];
d812 1
a812 3
bottom( vec1, vec2, t )
vect_t	vec1, vec2;
fastf_t	t[];
d836 1
a836 3
top( vec1, vec2, t )
vect_t	vec1, vec2;
fastf_t	t[];
d868 1
a868 3
crregion( region, op, members, number, solidname )
char region[], op[], solidname[];
int members[], number;
d901 1
a901 3
itoa( n, s, w )
char	 s[];
int   n,    w;
@


11.26
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.25 2001/06/01 19:23:25 bparker Exp $ (ARL)";
d517 1
a517 1
		mk_addmember( regname, &head, WMOP_UNION );
d903 1
a903 1
    mk_addmember( solidname, &head, op[i] );
@


11.25
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.24 2001/03/23 22:05:35 jra Exp $ (ARL)";
d610 1
d631 1
@


11.24
log
@Support for major and minor types in directory structure
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/track.c,v 11.23 2000/10/24 19:05:09 mike Exp $ (ARL)";
d46 1
d539 1
a539 1
		edit_result = f_edit( clientData, interp, 2, arglist );
@


11.23
log
@
Fixed compiler lint, function declarations.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.22 2000/10/19 21:25:01 mike Exp $ (ARL)";
d638 1
a638 1
	if( (tdp = db_diradd( dbip, name, -1L, 0, flags, NULL)) == DIR_NULL )
@


11.22
log
@
lint
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.21 2000/09/08 05:55:49 mike Exp $ (ARL)";
d572 1
a572 3
wrobj( name, flags )
char name[];
int flags;
@


11.21
log
@
Tree routines now need resource structure.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.20 2000/08/24 02:54:14 mike Exp $ (ARL)";
d571 1
a571 1

@


11.20
log
@
Changed from combadd() to mk_comb().
Main benefit is not taking a trip to the database as we add each member
to the combination.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.19 2000/08/19 03:10:50 mike Exp $ (ARL)";
d642 1
a642 1
		rt_db_free_internal( &intern );
d647 1
a647 1
	if( rt_db_put_internal( tdp, dbip, &intern ) < 0 )
d649 1
a649 1
		rt_db_free_internal( &intern );
@


11.19
log
@
const RCSid
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.18 1999/12/29 23:23:26 mike Exp $ (ARL)";
a74 1
	register struct directory *dp;
d83 1
d88 2
d511 1
a511 1
		if( (dp = db_lookup( dbip, regname, LOOKUP_QUIET)) == DIR_NULL ) {
d516 12
a527 1
		(void)combadd(dp, grpname, 0, WMOP_UNION, 0, 0);
a885 1
  struct directory *dp;
d887 1
d892 2
d897 1
a897 1
    if( (dp = db_lookup( dbip, solidname, LOOKUP_QUIET)) == DIR_NULL ) {
d902 1
a902 1
    (void)combadd(dp, region, 1, op[i], 500+Trackpos+i, 0);
d904 4
@


11.18
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.17 1999/11/24 14:26:42 jra Exp $ (ARL)";
@


11.17
log
@All solid/combination creation  routines needed values assigned to idb_meth
in the rt_db_internal struct
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.16 1999/09/01 18:55:11 bparker Exp $ (ARL)";
d627 1
a627 1
	if( (tdp = db_diradd( dbip, name, -1L, 0, flags)) == DIR_NULL )
@


11.16
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/track.c,v 11.15 1997/07/01 22:09:08 bparker Exp $ (ARL)";
d599 1
d619 1
@


11.15
log
@mods to run without a database
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/track.c,v 11.14 1997/04/24 18:03:58 bparker Exp bparker $ (ARL)";
d85 1
a85 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

@


11.14
log
@modify calls to Tcl_Eval
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/track.c,v 11.13 1997/04/16 20:23:49 bparker Exp bparker $ (ARL)";
d85 3
d569 3
d875 3
@


11.13
log
@mods so that commands check args internally
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/track.c,v 11.12 1997/03/25 14:43:44 jra Exp bparker $ (ARL)";
d88 6
a93 1
	  Tcl_Eval(interp, "help track");
@


11.12
log
@Mods to support MGED's read-only mode.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/track.c,v 11.11 1997/03/03 16:19:50 jra Exp jra $ (ARL)";
d87 2
a88 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d90 1
@


11.11
log
@Converted to use combination import/export
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/track.c,v 11.10 1996/10/03 20:40:46 bparker Exp jra $ (ARL)";
d84 2
@


11.10
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/track.c,v 11.9 1996/10/01 17:26:29 bparker Exp bparker $ (ARL)";
a40 1
#include "db.h"
d42 2
d52 6
a57 1
static union record record;
d94 2
a95 2
	oper[0] = oper[2] = INTERSECT;
	oper[1] = SUBTRACT;
a320 2
	record.s.s_id = ID_SOLID;

d323 1
a323 1
		record.s.s_values[i] = 0.0;
d326 1
a326 1
	VMOVE(temp2, &record.s.s_values[0]);
d328 2
a329 3
	(void)strcpy(record.s.s_name, solname);
	record.s.s_type = GENARB8;
	record.s.s_cgtype = BOX;		/* BOX */
d337 2
a338 3
		record.s.s_values[i] = 0.0;
	record.s.s_type = GENTGC;
	record.s.s_cgtype = RCC;
d341 1
a341 1
	(void)strcpy(record.s.s_name, solname);
d346 4
a349 4
	record.s.s_values[6] = iw[2];
	record.s.s_values[11] = iw[2];
	VMOVE(&record.s.s_values[12], &record.s.s_values[6]);
	VMOVE(&record.s.s_values[15], &record.s.s_values[9]);
d351 1
a351 1
	(void)strcpy(record.s.s_name, solname);
d358 1
a358 1
		record.s.s_values[i] = 0.0;
d360 2
a361 3
	(void)strcpy(record.s.s_name, solname);
	record.s.s_type = GENARB8;
	record.s.s_cgtype = ARB8;		/* arb8 */
d369 1
a369 1
		record.s.s_values[i] = 0.0;
d371 1
a371 1
	VMOVE(temp1, &record.s.s_values[0]);
d373 1
a373 2
	(void)strcpy(record.s.s_name, solname);
	record.s.s_cgtype = BOX;		/* box */
d380 2
a381 3
		record.s.s_values[i] = 0.0;
	record.s.s_type = GENTGC;
	record.s.s_cgtype = RCC;
d384 1
a384 1
	(void)strcpy(record.s.s_name, solname);
d390 4
a393 4
	record.s.s_values[6] = dw[2];
	record.s.s_values[11] = dw[2];
	VMOVE(&record.s.s_values[12], &record.s.s_values[6]);
	VMOVE(&record.s.s_values[15], &record.s.s_values[9]);
d395 1
a395 1
	(void)strcpy(record.s.s_name, solname);
d402 1
a402 1
		record.s.s_name[i] = 0.0;
d404 2
a405 3
	(void)strcpy(record.s.s_name, solname);
	record.s.s_type = GENARB8;
	record.s.s_cgtype = ARB8;		/* arb8 */
a411 1
	record.s.s_cgtype = ARB8;		/* arb8 */
d415 1
a415 1
	(void)strcpy(record.s.s_name, solname);
d428 1
a428 1
	(void)strcpy(record.s.s_name, solname);
a433 23
	bzero( (char *)&record , sizeof( union record ) );
	record.c.c_id = ID_COMB;
	record.c.c_flags = 'R';
	record.c.c_aircode = 0;
	record.c.c_regionid = 111;
	record.c.c_material = 0;
	record.c.c_los = 0;

	/* regions 3, 4, 7, 8 - dummy regions */
	for(i=3; i<5; i++) {
		regname[8] = '\0';
		crname(regname, i);
		(void)strcpy(record.c.c_name, regname);
		if( wrobj(regname,DIR_REGION|DIR_COMB) )
			return TCL_ERROR;
		regname[8] = '\0';
		crname(regname, i+4);
		(void)strcpy(record.c.c_name, regname);
		if( wrobj(regname,DIR_REGION|DIR_COMB) )
			return TCL_ERROR;
	}
	regname[8] = '\0';

d475 1
a475 1
	oper[2] = SUBTRACT;
d495 2
d504 1
a504 1
		(void)combadd(dp, grpname, 0, UNION, 0, 0);
d554 2
d558 1
a558 1
	  Tcl_AppendResult(interp, "amtrack naming error: ", name,
d562 63
a624 6
	if( (tdp = db_diradd( dbip, name, -1, 1, flags)) == DIR_NULL ||
	    db_alloc( dbip, tdp, 1) < 0 ||
	    db_put( dbip, tdp, &record, 0, 1 ) < 0 )  {
	  Tcl_AppendResult(interp, "wrobj(", name, "):  write error\n", (char *)NULL);
	  TCL_ERROR_RECOVERY_SUGGESTION;
	  return( -1 );
d716 8
a723 8
	record.s.s_values[2] = z - r - t[2];
	record.s.s_values[1] = t[0];
	record.s.s_values[0] = (record.s.s_values[2] - b) / (del[2] / del[0]);
	record.s.s_values[3] = plano[0] + (del[0]/mag) - work[0] - record.s.s_values[0];
	record.s.s_values[4] = 0.0;
	record.s.s_values[5] = plano[1] + (del[2]/mag) - work[2] - record.s.s_values[2];
	VADD2(&record.s.s_values[6], &record.s.s_values[3], work);
	VMOVE(&record.s.s_values[9], work);
d726 1
a726 1
	VMOVE(&record.s.s_values[12], work);
d729 1
a729 1
		VADD2(&record.s.s_values[j], &record.s.s_values[i], work);
d759 4
a762 4
	record.s.s_values[0] = w[0];
	record.s.s_values[1] = t[0] -1.0;
	record.s.s_values[2] = w[1];
	VMOVE(&record.s.s_values[3] , vec);
d764 1
a764 1
	VMOVE(&record.s.s_values[6], vec);
d766 1
a766 1
	VMOVE(&record.s.s_values[9], vec);
d769 1
a769 1
	VMOVE(&record.s.s_values[12], vec);
d772 1
a772 1
		VADD2(&record.s.s_values[j], &record.s.s_values[i], vec);
d783 8
a790 8
	record.s.s_values[0] = wh[0];
	record.s.s_values[1] = t[0];
	record.s.s_values[2] = wh[1];
	record.s.s_values[4] = t[1] - t[0];
	record.s.s_values[6] = wh[2] + t[2];
	record.s.s_values[11] = wh[2] + t[2];
	VMOVE(&record.s.s_values[12], &record.s.s_values[6]);
	VMOVE(&record.s.s_values[15], &record.s.s_values[9]);
d801 1
a801 1
	VMOVE(&record.s.s_values[0], vec1);
d804 1
a804 1
	VMOVE(&record.s.s_values[3], tvec);
d807 2
a808 2
	VADD2(&record.s.s_values[6], &record.s.s_values[3], tvec);
	VMOVE(&record.s.s_values[9], tvec);
d811 1
a811 1
	VMOVE(&record.s.s_values[12], tvec);
d815 1
a815 1
		VADD2(&record.s.s_values[j], &record.s.s_values[i], tvec);
d834 1
a834 1
	VSUB2(&record.s.s_values[0], vec1, tvec);
d836 1
a836 1
	VADD2(&record.s.s_values[3], del, tvec);
d839 1
a839 1
	VCROSS(del, tvec, &record.s.s_values[3]);
d843 3
a845 3
	VSCALE(&record.s.s_values[9], del, t[2]/mag);
	VADD2(&record.s.s_values[6], &record.s.s_values[3], &record.s.s_values[9]);
	VMOVE(&record.s.s_values[12], tvec);
d849 1
a849 1
		VADD2(&record.s.s_values[j], &record.s.s_values[i], tvec);
@


11.9
log
@ignore SIGINT
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/track.c,v 11.8 1996/09/23 18:16:31 bparker Exp bparker $ (ARL)";
d304 2
a305 1
			  return TCL_ERROR;
@


11.8
log
@changed dm.h to mged_dm.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/track.c,v 11.7 1996/08/27 20:30:05 bparker Exp bparker $ (ARL)";
d97 2
a98 1
	  return TCL_ERROR;
d106 2
a107 1
	  return TCL_ERROR;
d114 2
a115 1
	  return TCL_ERROR;
d121 2
a122 1
	  return TCL_ERROR;
d130 2
a131 1
	  return TCL_ERROR;
d137 2
a138 1
	  return TCL_ERROR;
d145 2
a146 1
	  return TCL_ERROR;
d152 2
a153 1
	  return TCL_ERROR;
d159 2
a160 1
	  return TCL_ERROR;
d168 2
a169 1
	  return TCL_ERROR;
d175 2
a176 1
	  return TCL_ERROR;
d183 2
a184 1
	  return TCL_ERROR;
d190 2
a191 1
	  return TCL_ERROR;
d197 2
a198 1
	  return TCL_ERROR;
d206 2
a207 1
	  return TCL_ERROR;
d213 2
a214 1
	  return TCL_ERROR;
d221 2
a222 1
	  return TCL_ERROR;
d230 2
a231 1
	  return TCL_ERROR;
d237 2
a238 1
	  return TCL_ERROR;
d249 2
a250 1
	  return TCL_ERROR;
d256 2
a257 1
	  return TCL_ERROR;
d547 3
@


11.7
log
@now using libbu
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/track.c,v 11.6 1996/05/02 21:33:02 bparker Exp bparker $ (ARL)";
d44 1
a44 1
#include "./dm.h"
@


11.6
log
@Still Tcl'ing the code
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/track.c,v 11.5 1996/04/24 16:20:56 bparker Exp bparker $ (ARL)";
d251 13
a263 13
	rt_log("\nX of first road wheel  %10.4f\n",fw[0]);
	rt_log("X of last road wheel   %10.4f\n",lw[0]);
	rt_log("Z of road wheels       %10.4f\n",fw[1]);
	rt_log("radius of road wheels  %10.4f\n",fw[2]);
	rt_log("\nX of drive wheel       %10.4f\n",dw[0]);
	rt_log("Z of drive wheel       %10.4f\n",dw[1]);
	rt_log("radius of drive wheel  %10.4f\n",dw[2]);
	rt_log("\nX of idler wheel       %10.4f\n",iw[0]);
	rt_log("Z of idler wheel       %10.4f\n",iw[1]);
	rt_log("radius of idler wheel  %10.4f\n",iw[2]);
	rt_log("\nY MIN of track         %10.4f\n",tr[0]);
	rt_log("Y MAX of track         %10.4f\n",tr[1]);
	rt_log("thickness of track     %10.4f\n",tr[2]);
@


11.5
log
@still tcl-converting
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/track.c,v 11.4 1996/04/18 20:28:43 bparker Exp bparker $ (ARL)";
d83 4
a86 1
	(void)signal( SIGINT, sig2);    /* allow interupts */
@


11.4
log
@convert commands to Tcl
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/track.c,v 11.3 1996/03/01 19:24:48 bparker Exp bparker $ (ARL)";
d513 1
@


11.3
log
@remove unused XMGED stuff
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/track.c,v 11.2 1995/01/17 13:05:12 bparker Exp bparker $ (ARL)";
d62 3
a64 1
f_amtrack( argc, argv  )
d79 3
d92 3
a94 2
		rt_log("Enter X of the FIRST roadwheel: ");
		return CMD_MORE;
d100 3
a102 2
		rt_log("Enter X of the LAST roadwheel: ");
		return CMD_MORE;
d108 2
a109 2
		rt_log("First wheel after last wheel - STOP\n");
		return CMD_BAD;
d113 3
a115 2
		rt_log("Enter Z of the roadwheels: ");
		return CMD_MORE;
d121 3
a123 2
		rt_log("Enter radius of the roadwheels: ");
		return CMD_MORE;
d128 2
a129 2
		rt_log("Radius <= 0 - STOP\n");
		return CMD_BAD;
d133 4
a136 3
		/* get the drive wheel info */
		rt_log("Enter X of the drive (REAR) wheel: ");
		return CMD_MORE;
d141 2
a142 2
		rt_log("DRIVE wheel not in the rear - STOP \n");
		return CMD_BAD;
d146 3
a148 2
		rt_log("Enter Z of the drive (REAR) wheel: ");
		return CMD_MORE;
d154 3
a156 2
		rt_log("Enter radius of the drive (REAR) wheel: ");
		return CMD_MORE;
d161 2
a162 2
		rt_log("Radius <= 0 - STOP\n");
		return CMD_BAD;
d167 3
a169 2
		rt_log("Enter X of the idler (FRONT) wheel: ");
		return CMD_MORE;
d174 2
a175 2
		rt_log("IDLER wheel not in the front - STOP \n");
		return CMD_BAD;
d179 3
a181 2
		rt_log("Enter Z of the idler (FRONT) wheel: ");
		return CMD_MORE;
d187 3
a189 2
		rt_log("Enter radius of the idler (FRONT) wheel: ");
		return CMD_MORE;
d194 2
a195 2
		rt_log("Radius <= 0 - STOP\n");
		return CMD_BAD;
d200 3
a202 2
		rt_log("Enter Y-MIN of the track: ");
		return CMD_MORE;
d208 3
a210 2
		rt_log("Enter Y-MAX of the track: ");
		return CMD_MORE;
d215 2
a216 2
		rt_log("MIN == MAX ... STOP\n");
		return CMD_BAD;
d219 3
a221 3
		rt_log("MIN > MAX .... will switch\n");
		tr[1] = tr[0];
		tr[0] = tr[2];
d225 3
a227 2
		rt_log("Enter track thickness: ");
		return CMD_MORE;
d232 2
a233 2
		rt_log("Track thickness <= 0 - STOP\n");
		return CMD_BAD;
d278 3
a280 2
				rt_log("Track: naming error -- STOP\n");
				return CMD_BAD;
d303 1
a303 1
		return CMD_BAD;
d316 1
a316 1
		return CMD_BAD;
d326 1
a326 1
		return CMD_BAD;
d338 1
a338 1
		return CMD_BAD;
d350 1
a350 1
		return CMD_BAD;
d362 1
a362 1
		return CMD_BAD;
d373 1
a373 1
		return CMD_BAD;
d385 1
a385 1
		return CMD_BAD;
d395 1
a395 1
		return CMD_BAD;
d408 1
a408 1
		return CMD_BAD;
d426 1
a426 1
			return CMD_BAD;
d431 1
a431 1
			return CMD_BAD;
d499 3
a501 2
			rt_log("group: %s will skip member: %s\n",grpname,regname);
			continue;
d507 2
a508 1
	rt_log("The track regions are in group %s\n",grpname);
d513 1
a513 1
		edit_result = f_edit( 2, arglist );
d551 3
a553 2
		rt_log("amtrack naming error: %s already exists\n",name);
		return(-1);
d558 3
a560 3
	    	rt_log("wrobj(%s):  write error\n", name);
	    	ERROR_RECOVERY_SUGGESTION;
		return( -1 );
d581 2
a582 2
		rt_log("tancir():  0-length vector!\n");
		return;
d794 2
a795 2
	struct directory *dp;
	int i;
d797 10
a806 9
	for(i=0; i<number; i++) {
		solidname[8] = '\0';
		crname(solidname, members[i]);
		if( (dp = db_lookup( dbip, solidname, LOOKUP_QUIET)) == DIR_NULL ) {
			rt_log("region: %s will skip member: %s\n",region,solidname);
			continue;
		}
		(void)combadd(dp, region, 1, op[i], 500+Trackpos+i, 0);
	}
d830 2
a831 1
	if( i > w )	rt_log( "itoa: field length too small\n" );
@


11.2
log
@merging xmged sources
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/track.c,v 11.2 95/01/17 11:44:36 bparker Exp $ (ARL)";
a77 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );
#else
a78 1
#endif
@


11.1
log
@Release_4.4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/track.c,v 10.7 94/12/27 18:15:44 mike Exp $ (ARL)";
d78 5
a82 1
	(void)signal( SIGINT, sig2 );
@


10.7
log
@Added RCSid
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
@


10.6
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d7 15
d23 3
@


10.5
log
@modified to cirrectly create dummy regions.
@
text
@d69 1
a69 1
		(void)printf("Enter X of the FIRST roadwheel: ");
d76 1
a76 1
		(void)printf("Enter X of the LAST roadwheel: ");
d83 1
a83 1
		(void)printf("First wheel after last wheel - STOP\n");
d88 1
a88 1
		(void)printf("Enter Z of the roadwheels: ");
d95 1
a95 1
		(void)printf("Enter radius of the roadwheels: ");
d101 1
a101 1
		(void)printf("Radius <= 0 - STOP\n");
d107 1
a107 1
		(void)printf("Enter X of the drive (REAR) wheel: ");
d113 1
a113 1
		(void)printf("DRIVE wheel not in the rear - STOP \n");
d118 1
a118 1
		(void)printf("Enter Z of the drive (REAR) wheel: ");
d125 1
a125 1
		(void)printf("Enter radius of the drive (REAR) wheel: ");
d131 1
a131 1
		(void)printf("Radius <= 0 - STOP\n");
d137 1
a137 1
		(void)printf("Enter X of the idler (FRONT) wheel: ");
d143 1
a143 1
		(void)printf("IDLER wheel not in the front - STOP \n");
d148 1
a148 1
		(void)printf("Enter Z of the idler (FRONT) wheel: ");
d155 1
a155 1
		(void)printf("Enter radius of the idler (FRONT) wheel: ");
d161 1
a161 1
		(void)printf("Radius <= 0 - STOP\n");
d167 1
a167 1
		(void)printf("Enter Y-MIN of the track: ");
d174 1
a174 1
		(void)printf("Enter Y-MAX of the track: ");
d180 1
a180 1
		(void)printf("MIN == MAX ... STOP\n");
d184 1
a184 1
		(void)printf("MIN > MAX .... will switch\n");
d190 1
a190 1
		(void)printf("Enter track thickness: ");
d196 1
a196 1
		(void)printf("Track thickness <= 0 - STOP\n");
d212 13
a224 13
	(void)printf("\nX of first road wheel  %10.4f\n",fw[0]);
	(void)printf("X of last road wheel   %10.4f\n",lw[0]);
	(void)printf("Z of road wheels       %10.4f\n",fw[1]);
	(void)printf("radius of road wheels  %10.4f\n",fw[2]);
	(void)printf("\nX of drive wheel       %10.4f\n",dw[0]);
	(void)printf("Z of drive wheel       %10.4f\n",dw[1]);
	(void)printf("radius of drive wheel  %10.4f\n",dw[2]);
	(void)printf("\nX of idler wheel       %10.4f\n",iw[0]);
	(void)printf("Z of idler wheel       %10.4f\n",iw[1]);
	(void)printf("radius of idler wheel  %10.4f\n",iw[2]);
	(void)printf("\nY MIN of track         %10.4f\n",tr[0]);
	(void)printf("Y MAX of track         %10.4f\n",tr[1]);
	(void)printf("thickness of track     %10.4f\n",tr[2]);
d242 1
a242 1
				(void)printf("Track: naming error -- STOP\n");
d462 1
a462 1
			(void)printf("group: %s will skip member: %s\n",grpname,regname);
d469 1
a469 1
	(void)printf("The track regions are in group %s\n",grpname);
d512 1
a512 1
		(void)printf("amtrack naming error: %s already exists\n",name);
d518 1
a518 1
	    	(void)printf("wrobj(%s):  write error\n", name);
d541 1
a541 1
		fprintf(stderr,"tancir():  0-length vector!\n");
d761 1
a761 1
			(void)printf("region: %s will skip member: %s\n",region,solidname);
d789 1
a789 1
	if( i > w )	(void)printf( "itoa: field length too small\n" );
@


10.4
log
@Factored ifdefs
@
text
@d265 1
a265 1
	if( wrobj(solname) ) 
d278 1
a278 1
	if( wrobj( solname ) )
d288 1
a288 1
	if( wrobj( solname ) )
d300 1
a300 1
	if( wrobj(solname) )
d312 1
a312 1
	if(wrobj(solname))
d324 1
a324 1
	if( wrobj(solname) )
d335 1
a335 1
	if( wrobj(solname) )
d347 1
a347 1
	if( wrobj(solname) )
d357 1
a357 1
	if( wrobj(solname) )
d370 1
a370 1
	if( wrobj(solname) )
d375 1
d388 1
a388 1
		if( wrobj(regname) )
d393 1
a393 1
		if( wrobj(regname) )
d505 1
a505 2

wrobj( name )
d507 1
d515 1
a515 1
	if( (tdp = db_diradd( dbip, name, -1, 1, DIR_SOLID)) == DIR_NULL ||
@


10.3
log
@Modified routines requiring input to use CMD_MORE
@
text
@d9 2
d14 3
a16 1
#ifdef BSD
a17 2
#else
#include <string.h>
d21 1
@


10.2
log
@Converted f_amtrack to use new command return codes.
@
text
@a26 6
extern int 	numargs;
extern char	*cmd_args[];
extern int	newargs;
extern int	args;
extern int	argcnt;

d53 2
d62 1
a62 2
	args = numargs;
	argcnt = 0;
d65 14
a78 8
	(void)printf("Enter X of the FIRST roadwheel: ");
	argcnt = getcmd(args);
	fw[0] = atof( cmd_args[args] ) * local2base;
	args += argcnt;
	(void)printf("Enter X of the LAST roadwheel: ");
	argcnt = getcmd(args);
	lw[0] = atof( cmd_args[args] ) * local2base;
	args += argcnt;
d83 14
a96 7
	(void)printf("Enter Z of the roadwheels: ");
	argcnt = getcmd(args);
	fw[1] = lw[1] = atof( cmd_args[args] ) * local2base;
	args += argcnt;
	(void)printf("Enter radius of the roadwheels: ");
	argcnt = getcmd(args);
	fw[2] = lw[2] = atof( cmd_args[args] ) * local2base;
a100 1
	args += argcnt;
d102 7
a108 4
	/* get the drive wheel info */
	(void)printf("Enter X of the drive (REAR) wheel: ");
	argcnt = getcmd(args);
	dw[0] = atof( cmd_args[args] ) * local2base;
d113 14
a126 8
	args += argcnt;
	(void)printf("Enter Z of the drive (REAR) wheel: ");
	argcnt = getcmd(args);
	dw[1] = atof( cmd_args[args] ) * local2base;
	args += argcnt;
	(void)printf("Enter radius of the drive (REAR) wheel: ");
	argcnt = getcmd(args);
	dw[2] = atof( cmd_args[args] ) * local2base;
d131 1
a131 2
	args += argcnt;

d133 6
a138 4
	(void)printf("Enter X of the idler (FRONT) wheel: ");
	argcnt = getcmd(args);
	iw[0] = atof( cmd_args[args] ) * local2base;
	args += argcnt;
d143 14
a156 7
	(void)printf("Enter Z of the idler (FRONT) wheel: ");
	argcnt = getcmd(args);
	iw[1] = atof( cmd_args[args] ) * local2base;
	args += argcnt;
	(void)printf("Enter radius of the idler (FRONT) wheel: ");
	argcnt = getcmd(args);
	iw[2] = atof( cmd_args[args] ) * local2base;
a160 1
	args += argcnt;
d163 13
a175 7
	(void)printf("Enter Y-MIN of the track: ");
	argcnt = getcmd(args);
	tr[2] = tr[0] = atof( cmd_args[args] ) * local2base;
	args += argcnt;
	(void)printf("Enter Y-MAX of the track: ");
	argcnt = getcmd(args);
	tr[1] = atof( cmd_args[args] ) * local2base;
d185 7
a191 4
	args += argcnt;
	(void)printf("Enter track thickness: ");
	argcnt = getcmd(args);
	tr[2] = atof( cmd_args[args] ) * local2base;
d470 1
a470 1
		f_edit( 2, arglist );
d479 1
a479 1
	return CMD_OK;
@


10.1
log
@Release_4.0
@
text
@d46 4
a49 2
void
f_amtrack(  )
d80 1
a80 1
		return;
d91 1
a91 1
		return;
d101 1
a101 1
		return;
d113 1
a113 1
		return;
d124 1
a124 1
		return;
d135 1
a135 1
		return;
d149 1
a149 1
		return;
d162 1
a162 1
		return;
d208 1
a208 1
				return;
d231 1
a231 1
		return;
d244 1
a244 1
		return;
d254 1
a254 1
		return;
d266 1
a266 1
		return;
d278 1
a278 1
		return;
d290 1
a290 1
		return;
d301 1
a301 1
		return;
d313 1
a313 1
		return;
d323 1
a323 1
		return;
d336 1
a336 1
		return;
d353 1
a353 1
			return;
d358 1
a358 1
			return;
d446 2
@


9.5
log
@externs.h
@
text
@@


9.4
log
@Added error checking around calls to db_*() routines
@
text
@a25 2
extern int atoi();
extern char *strcat(), *strcpy();
@


9.3
log
@Eliminated use of rec.c.c_length, using instead dp->d_len-1
@
text
@d477 5
a481 1
	if( (tdp = db_diradd( dbip, name, -1, 1, DIR_SOLID)) == DIR_NULL )
d483 1
a483 2
	db_alloc( dbip, tdp, 1);
	db_put( dbip, tdp, &record, 0, 1 );
@


9.2
log
@redraw() and drawtree() replaced.
More emphasis on argv/argc use in command functions.
@
text
@d342 1
a342 1
	record.c.c_aircode = record.c.c_length = 0;
@


9.1
log
@Release_3.5
@
text
@d432 1
d434 6
a440 6
	/* draw this track */
	dp = db_lookup( dbip, grpname, LOOKUP_QUIET);
	drawtree( dp );
	dmp->dmr_colorchange();
	dmaflag = 1;

a445 2

	return;
@


8.5
log
@db_diradd had the length and flags parameters backward
@
text
@@


8.4
log
@removed MAXLINE (unused)
@
text
@d478 1
a478 1
	if( (tdp = db_diradd( dbip, name, -1, DIR_SOLID, 1)) == DIR_NULL )
@


8.3
log
@drawHobj() --> drawtree()
@
text
@a42 2
#define MAXLINE	512

@


8.2
log
@Converted to new db_*() routines.
@
text
@d438 1
a438 1
	drawHobj( dp, ROOT, 0, identity, 0 );
@


8.1
log
@Release_3.0
@
text
@d21 1
a22 1
#include "./objdir.h"
d204 2
a205 2
		if(	(lookup(solname, LOOKUP_QUIET) != DIR_NULL)	||
			(lookup(regname, LOOKUP_QUIET) != DIR_NULL)	) {
d427 1
a427 1
		if( (dp=lookup(regname, LOOKUP_QUIET)) == DIR_NULL ) {
d437 1
a437 1
	dp = lookup(grpname, LOOKUP_QUIET);
d476 1
a476 1
	if( lookup(name, LOOKUP_QUIET) != DIR_NULL ) {
d480 1
a480 1
	if( (tdp = dir_add(name, -1, DIR_SOLID, 1)) == DIR_NULL )
d482 2
a483 2
	db_alloc(tdp, 1);
	db_putrec(tdp, &record, 0);
d722 1
a722 1
		if( (dp = lookup(solidname, LOOKUP_QUIET)) == DIR_NULL ) {
@


7.4
log
@get atof() extern from math.h
@
text
@@


7.3
log
@lint fixes
@
text
@a25 1
extern double atof();
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@a29 2
double fabs();

d41 3
d51 1
a51 1

d452 1
a452 1

d488 1
a488 1

d525 1
a525 3



d594 1
a594 2


d638 1
a638 2


a649 1
	return;
d652 1
a652 1

a675 2

	return;
d678 1
a678 1

a709 2

	return;
d712 1
a712 1

a728 2

	return;
d737 1
@


7.1
log
@Release 2.3
@
text
@d18 1
a18 1
#include "./machine.h"
d39 1
a39 1
static float	plano[4], plant[4];
d55 1
a55 1
	float fw[3], lw[3], iw[3], dw[3], tr[3];
d59 1
a59 1
	float temp1[3], temp2[3];
d489 1
a489 1
register float cir1[], cir2[];
d491 2
a492 1
	static fastf_t work[3], mag;
d494 1
a494 1
	static double temp, tempp, ang, angc;
d528 1
a528 1
float wh1[], wh2[], t[];
d531 4
a534 1
	float temp, del[3], mag, work[3], z, r, b;
d598 2
a599 2
float w[3], t[3];
int flag;
d601 2
a602 1
	float temp, vec[3];
d643 1
a643 1
float wh[], t[];
d658 2
a659 1
float vec1[], vec2[], t[];
d661 1
a661 1
	float tvec[3];
d686 2
a687 1
float vec1[], vec2[], t[];
d689 2
a690 1
	float tooch, del[3], tvec[3], mag;
@


6.1
log
@Release 2.0
@
text
@@


5.1
log
@Release 1.24
@
text
@@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@@


4.2
log
@Minor cleanups inspired by the Cray
@
text
@@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d34 6
a39 5
int		newargs;
int		args;
int		argcnt;
int		Trackpos = 0;
float		plano[4], plant[4];
@


1.5
log
@Cleaned up some ugliness with using acos().
@
text
@@


1.4
log
@Minor cleanup for cray
@
text
@d488 1
a488 1
float cir1[], cir2[];
d490 3
a492 2
	float work[3], mag;
	double temp, p, tempp, ang, angc;
a493 1
	p = 3.14159265;
d498 7
a504 1
	VSCALE(work, work, 1.0/mag);
d507 2
a508 2
		temp = p + p - temp;
	tempp = acos( (cir1[2] - cir2[2]) / mag );
@


1.3
log
@Changed #includes for CC -I../h
@
text
@d11 2
d14 4
a17 1
#include <math.h>
@


1.2
log
@New checks and features from Keith
@
text
@d12 1
d14 5
a18 6
#include "../h/vmath.h"
#include "../h/db.h"
#include "ged.h"
#include "objdir.h"
#include <math.h>
#include "dm.h"
@


1.1
log
@Initial revision
@
text
@d50 1
a50 1
	char solname[12], regname[12], grpname[7], oper[3];
d170 2
a171 1
	solname[8] = regname[8] = '\0';
d188 4
d193 18
a219 2
	tryagain:	/* sent here if naming error to try again */

d226 2
a227 6
	if( wrobj(solname) ) {
		/* name already exists, try next set */
		if( (Trackpos += 10) > 990 ) {
			(void)printf(" I QUIT!!! \n");
			return;
		}
a228 5
		(void)printf("will try next set\n");
		solname[8] = '\0';
		goto tryagain;
	}

d417 1
@
