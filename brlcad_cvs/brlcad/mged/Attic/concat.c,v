head	11.39;
access;
symbols
	ansi-20040405-merged:11.35.4.1
	postmerge-20040405-ansi:11.37
	premerge-20040404-ansi:11.37
	postmerge-autoconf:11.37
	autoconf-freeze:11.35.12.3
	premerge-autoconf:11.37
	postmerge-20040315-windows:11.37
	premerge-20040315-windows:11.36
	windows-20040315-freeze:11.35.6.2
	autoconf-20031203:11.35
	autoconf-20031202:11.35
	autoconf-branch:11.35.0.12
	phong-branch:11.35.0.10
	photonmap-branch:11.35.0.8
	rel-6-1-DP:11.35
	windows-branch:11.35.0.6
	rel-6-0-2:11.35
	ansi-branch:11.35.0.4
	rel-6-0-1-branch:11.35.0.2
	hartley-6-0-post:11.35
	hartley-6-0-pre:11.35
	rel-6-0-1:11.35
	rel-6-0:11.35
	rel-5-4:11.24.2.1
	offsite-5-3-pre:11.30
	rel-5-3:11.24.2.1
	rel-5-2:11.24
	rel-5-1-branch:11.24.0.2
	rel-5-1:11.24
	rel-5-0:11.21
	rel-5-0-beta:11.20
	rel-4-5:11.20
	ctj-4-5-post:11.16
	ctj-4-5-pre:11.16
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.39
date	2004.05.21.17.47.39;	author morrison;	state dead;
branches;
next	11.38;

11.38
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.37;

11.37
date	2004.03.16.21.15.10;	author morrison;	state Exp;
branches;
next	11.36;

11.36
date	2004.02.02.17.39.32;	author morrison;	state Exp;
branches;
next	11.35;

11.35
date	2001.05.04.14.20.46;	author bparker;	state Exp;
branches
	11.35.4.1
	11.35.6.1
	11.35.12.1;
next	11.34;

11.34
date	2001.05.02.17.14.00;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	2001.03.23.22.01.37;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	2001.03.23.19.44.12;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	2001.03.21.22.15.21;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	2000.11.02.03.13.34;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.11.02.02.55.37;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.10.17.21.30.57;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.09.08.05.55.48;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.08.19.03.10.43;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.07.23.23.42.21;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	99.12.30.20.01.36;	author jra;	state Exp;
branches
	11.24.2.1;
next	11.23;

11.23
date	99.12.29.23.23.20;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	99.11.26.23.03.31;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	99.09.01.18.55.09;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	97.11.05.17.53.30;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	97.09.10.17.30.10;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	97.07.31.14.27.47;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	97.03.28.21.38.15;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	97.02.28.21.09.02;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	97.02.25.14.21.40;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	97.02.14.13.12.01;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	96.10.04.14.59.42;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.10.03.20.42.28;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.10.01.17.26.29;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	96.03.01.19.32.29;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.29;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.49;	author mike;	state Rel4_4;
branches;
next	10.11;

10.11
date	94.12.16.19.35.51;	author gdurf;	state Exp;
branches;
next	10.10;

10.10
date	94.11.10.12.06.05;	author jra;	state Exp;
branches;
next	10.9;

10.9
date	94.10.21.19.34.23;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.09.28.15.43.27;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.09.28.02.57.27;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.08.09.15.04.15;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.08.09.14.53.23;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.06.13.19.06.12;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	92.02.11.08.14.14;	author butler;	state Exp;
branches;
next	10.2;

10.2
date	92.02.05.13.34.57;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.15;	author mike;	state Rel4_0;
branches;
next	1.6;

1.6
date	91.07.18.00.33.51;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	90.12.07.06.08.51;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	90.12.07.06.05.58;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	90.12.07.05.41.35;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.12.07.04.16.08;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.12.07.03.30.54;	author mike;	state Exp;
branches;
next	;

11.24.2.1
date	2000.11.02.13.36.21;	author jra;	state Exp;
branches;
next	;

11.35.4.1
date	2004.03.17.21.21.56;	author morrison;	state Exp;
branches;
next	;

11.35.6.1
date	2002.09.26.23.04.09;	author morrison;	state Exp;
branches;
next	11.35.6.2;

11.35.6.2
date	2004.03.11.23.46.34;	author morrison;	state Exp;
branches;
next	;

11.35.12.1
date	2004.02.12.18.34.13;	author erikg;	state Exp;
branches;
next	11.35.12.2;

11.35.12.2
date	2004.03.15.14.07.36;	author erikg;	state Exp;
branches;
next	11.35.12.3;

11.35.12.3
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@MGED commands for managing the merging of two databases
@


11.39
log
@moved to src/mged/
@
text
@/*
 *			C O N C A T . C
 *
 *  Functions -
 *	f_dup()		checks for dup names before cat'ing of two files
 *	f_concat()	routine to cat another GED file onto end of current file
 *
 *  Authors -
 *	Michael John Muuss
 *	Keith A. Applin
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSconcat[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/concat.c,v 11.38 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifndef WIN32
#include <pwd.h>
#endif
#include <signal.h>
#include <math.h>
#include <time.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "externs.h"
#include "./ged.h"
#include "./sedit.h"

char	new_name[NAMESIZE];
char	prestr[NAMESIZE];
int	ncharadd;

@


11.38
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /cvs/brlcad/mged/concat.c,v 11.37 2004/03/16 21:15:10 morrison Exp $ (BRL)";
@


11.37
log
@merge of windows-6-0-branch into head
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header$ (BRL)";
d25 5
a29 1
#include "conf.h"
@


11.36
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.35 2001/05/04 14:20:46 bparker Exp $ (BRL)";
d28 1
d30 1
@


11.35
log
@*- export more commands out of mged and into librt
*- modify mged to use the librt routines
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1990 by the United States Army.
d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.34 2001/05/02 17:14:00 bparker Exp $ (BRL)";
@


11.35.4.1
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header$ (BRL)";
a27 1
#ifndef WIN32
a28 1
#endif
@


11.35.12.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.36 2004/02/02 17:39:32 morrison Exp $ (BRL)";
@


11.35.12.2
log
@merge from head
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.35.12.1 2004/02/12 18:34:13 erikg Exp $ (BRL)";
@


11.35.12.3
log
@merge from head
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header$ (BRL)";
a27 1
#ifndef WIN32
a28 1
#endif
@


11.35.6.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.35 2001/05/04 14:20:46 bparker Exp $ (BRL)";
a27 1
#ifndef WIN32
a28 1
#endif
@


11.35.6.2
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/concat.c,v 11.35.6.1 2002/09/26 23:04:09 morrison Exp $ (BRL)";
@


11.34
log
@*- modified commands to use new librt routines
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.33 2001/03/23 22:01:37 bparker Exp $ (BRL)";
a48 65
/*
 *
 *			F _ D U P ( )
 *
 *  Check for duplicate names in preparation for cat'ing of files
 *
 *  Usage:  dup file.g [prefix]
 *  becomes: db dup file.g [prefix]
 */
int
f_dup(clientData, interp, argc, argv )
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
{
	CHECK_DBI_NULL;

	return wdb_dup_cmd(wdbp, interp, argc, argv);
}

/*
 *			F _ C O N C A T
 *
 *  Concatenate another GED file into the current file.
 *  Interrupts are not permitted during this function.
 *
 *  Usage:  dbconcat file.g [prefix]
 *  becomes: db concat file.g prefix
 *
 *  NOTE:  If a prefix is not given on the command line,
 *  then the users insist that they be prompted for the prefix,
 *  to prevent inadvertently sucking in a non-prefixed file.
 *  Slash ("/") specifies no prefix.
 */
int
f_concat(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
{
	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	/* get any prefix */
	if (argc < 2) {
		Tcl_AppendResult(interp, MORE_ARGS_STR,
				 "concat: Enter database: ",
				 (char *)NULL);
		return TCL_ERROR;
	}

	if (argc < 3) {
		Tcl_AppendResult(interp, MORE_ARGS_STR,
				 "concat: Enter prefix string or / for no prefix: ",
				 (char *)NULL);
		return TCL_ERROR;
	}

	/* replace dbconcat with concat */
	argv[0] = "concat";

	return wdb_concat_cmd(wdbp, interp, argc, argv);
}
@


11.33
log
@*- modify prompting for f_concat
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /d/CVS/brlcad/mged/concat.c,v 11.32 2001/03/23 19:44:12 bparker Exp $ (BRL)";
a48 2
int invoke_db_wrapper(Tcl_Interp *interp, int argc, char **argv);

d67 1
a67 31
	return invoke_db_wrapper(interp, argc, argv);
}

/*
 *			I N V O K E _ D B _ W R A P P E R
 *
 *  This is generally useful for all MGED commands
 *  that have been subsumed by "db" object methods.
 */
int
invoke_db_wrapper(Tcl_Interp	*interp,
		  int		argc,
		  char		**argv)
{
	register int	i;
	struct bu_vls	vls;
	int		ret;

	bu_vls_init(&vls);

	bu_vls_strcpy(&vls, MGED_DB_NAME);
	for (i = 0; i < argc; ++i)
		bu_vls_printf(&vls, " %s", argv[i]);

	if (bu_debug)
		bu_log("%s\n", bu_vls_addr(&vls));

	ret = Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return ret;
d112 1
a112 1
	return invoke_db_wrapper(interp, argc, argv);
@


11.32
log
@*- change dbconcat to concat before
   invoking invoke_db_wrapper
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /d/CVS/brlcad/mged/concat.c,v 11.31 2001/03/21 22:15:21 bparker Exp $ (BRL)";
d127 7
@


11.31
log
@*- mods to invoke_db_wrapper
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /d/CVS/brlcad/mged/concat.c,v 11.30 2000/11/02 03:13:34 mike Exp $ (BRL)";
d133 3
@


11.30
log
@
Invoke "db dup" in place of the (nasty) built-in code.
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.29 2000/11/02 02:55:37 mike Exp $ (BRL)";
d49 1
a49 1
int invoke_db_wrapper( ClientData clientData, Tcl_Interp *interp, int argc, char **argv, const char *cmd );
d62 4
a65 4
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d67 1
a67 6
  struct bu_vls vls;

  CHECK_DBI_NULL;

  if(argc < 2 || 3 < argc){
    struct bu_vls vls;
d69 1
a69 8
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help dup");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  return invoke_db_wrapper( clientData, interp, argc, argv, "dup" );
d79 3
a81 1
invoke_db_wrapper( ClientData clientData, Tcl_Interp *interp, int argc, char **argv, const char *cmd )
d83 5
a87 2
	struct bu_vls	str;
	int	ret;
d89 3
a91 1
	bu_vls_init(&str);
d93 5
a97 3
	bu_vls_printf( &str, "db %s ", cmd );
	bu_vls_from_argv( &str, argc-1, argv+1 );
	if(bu_debug) bu_log("%s\n", bu_vls_addr(&str) );
a98 2
	ret = Tcl_Eval( interp, bu_vls_addr(&str) );
	bu_vls_free( &str );
d118 4
a121 4
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
a125 10
	if(argc < 2 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help dbconcat");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

d127 5
a131 5
	if( argc < 3 )  {
	  Tcl_AppendResult(interp, MORE_ARGS_STR,
			   "concat: Enter prefix string or / for no prefix: ",
			   (char *)NULL);
	  return TCL_ERROR;
d134 1
a134 1
	return invoke_db_wrapper( clientData, interp, argc, argv, "concat" );
@


11.29
log
@
After calling db_scan(), be sure to release the on-disk free map,
to prevent rt_memfree(addr=x10e,size=1)  ERROR type=010 messages.
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.28 2000/10/17 21:30:57 mike Exp $ (BRL)";
a44 3
int			num_dups;
struct directory	**dup_dirp;

d49 1
a49 39
/*
 *			M G E D _ D I R _ C H E C K
 *
 * Check a name against the global directory.
 */
int
mged_dir_check( input_dbip, name, laddr, len, flags, ptr )
register struct db_i	*input_dbip;
register CONST char	*name;
long			laddr;
int			len;
int			flags;
genptr_t		ptr;
{
	struct directory	*dupdp;
	char			local[NAMESIZE+2];

	if(dbip == DBI_NULL)
	  return 0;

	if( input_dbip->dbi_magic != DBI_MAGIC )  bu_bomb("mged_dir_check:  bad dbip\n");

	/* Add the prefix, if any */
	if( ncharadd > 0 )  {
		(void)strncpy( local, prestr, ncharadd );
		(void)strncpy( local+ncharadd, name, NAMESIZE-ncharadd );
	} else {
		(void)strncpy( local, name, NAMESIZE );
	}
	local[NAMESIZE] = '\0';
		
	/* Look up this new name in the existing (main) database */
	if( (dupdp = db_lookup( dbip, local, LOOKUP_QUIET )) != DIR_NULL )  {
		/* Duplicate found, add it to the list */
		num_dups++;
		*dup_dirp++ = dupdp;
	}
	return 0;
}
d58 1
a66 3
  struct db_i		*newdbp = DBI_NULL;
  struct directory	**dirp0 = (struct directory **)NULL;
  int status = TCL_OK;
d81 1
a81 99
  bu_vls_init(&vls);
  if( setjmp( jmp_env ) == 0 )
    (void)signal( SIGINT, sig3);	/* allow interupts */
  else{
    bu_vls_free(&vls);

    if(dirp0)
      bu_free( (genptr_t)dirp0, "dir_getspace array" );

    if(newdbp && newdbp->dbi_magic == DBI_MAGIC)
      db_close( newdbp );

    return TCL_OK;
  }

  /* get any prefix */
  if( argc < 3 ) {
    prestr[0] = '\0';
  } else {
    (void)strcpy(prestr, argv[2]);
  }
  num_dups = 0;
  if( (ncharadd = strlen( prestr )) > 12 )  {
    ncharadd = 12;
    prestr[12] = '\0';
  }

  /* open the input file */
  if( (newdbp = db_open( argv[1], "r" )) == DBI_NULL )  {
    perror( argv[1] );
    Tcl_AppendResult(interp, "dup: Can't open ", argv[1], "\n", (char *)NULL);
    status = TCL_ERROR;
    goto end;
  }

  Tcl_AppendResult(interp, "\n*** Comparing ", dbip->dbi_filename,
		   "  with ", argv[1], " for duplicate names\n", (char *)NULL);
  if( ncharadd ) {
    Tcl_AppendResult(interp, "  For comparison, all names in ",
		     argv[1], " were prefixed with:  ", prestr, "\n", (char *)NULL);
  }

  /* Get array to hold names of duplicates */
  if( (dup_dirp = dir_getspace(0)) == (struct directory **) 0) {
    Tcl_AppendResult(interp, "f_dup: unable to get memory\n", (char *)NULL);
    status = TCL_ERROR;
    db_close( newdbp );
    goto end;
  }
  dirp0 = dup_dirp;

  /* Scan new database for overlaps */
  if( db_scan( newdbp, mged_dir_check, 0, NULL ) < 0 )  {
    Tcl_AppendResult(interp, "dup: db_scan failure\n", (char *)NULL);
    status = TCL_ERROR;
    bu_free( (genptr_t)dirp0, "dir_getspace array" );
    db_close( newdbp );
    goto end;
  }
  rt_mempurge( &(newdbp->dbi_freep) );	/* didn't really build a directory */

  vls_col_pr4v(&vls, dirp0, (int)(dup_dirp - dirp0));
  bu_vls_printf(&vls, "\n -----  %d duplicate names found  -----\n",num_dups);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_free( (genptr_t)dirp0, "dir_getspace array" );
  db_close( newdbp );

end:
  (void)signal( SIGINT, SIG_IGN );
  bu_vls_free(&vls);
  return status;
}

HIDDEN void
Do_update( dbip, comb, comb_leaf, user_ptr1, user_ptr2, user_ptr3 )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		user_ptr1, user_ptr2, user_ptr3;
{
	char	mref[NAMESIZE+2];
	char	*prestr;
	int	*ncharadd;

	if(dbip == DBI_NULL)
	  return;

	RT_CK_DBI( dbip );
	RT_CK_TREE( comb_leaf );

	ncharadd = (int *)user_ptr1;
	prestr = (char *)user_ptr2;

	(void)strncpy( mref, prestr, *ncharadd );
	(void)strncpy( mref+(*ncharadd),
		comb_leaf->tr_l.tl_name,
		NAMESIZE-(*ncharadd) );
	bu_free( comb_leaf->tr_l.tl_name, "comb_leaf->tr_l.tl_name" );
	comb_leaf->tr_l.tl_name = bu_strdup( mref );
a84 112
 *			M G E D _ D I R _ A D D
 *
 *  Add a solid or conbination from an auxillary database
 *  into the primary database.
 */
int
mged_dir_add( input_dbip, name, laddr, len, flags, ptr )
register struct db_i	*input_dbip;
register CONST char	*name;
long			laddr;
int			len;
int			flags;
genptr_t		ptr;
{
	register struct directory *input_dp;
	register struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	char			local[NAMESIZE+2+2];

	CHECK_DBI_NULL;

	if( input_dbip->dbi_magic != DBI_MAGIC )  bu_bomb("mged_dir_add:  bad dbip\n");

	/* Add the prefix, if any */
	if( ncharadd > 0 )  {
		(void)strncpy( local, prestr, ncharadd );
		(void)strncpy( local+ncharadd, name, NAMESIZE-ncharadd );
	} else {
		(void)strncpy( local, name, NAMESIZE );
	}
	local[NAMESIZE] = '\0';
		
	/* Look up this new name in the existing (main) database */
	if( (dp = db_lookup( dbip, local, LOOKUP_QUIET )) != DIR_NULL )  {
		register int	c;
		char		loc2[NAMESIZE+2+2];

		/* This object already exists under the (prefixed) name */
		/* Protect the database against duplicate names! */
		/* Change object names, but NOT any references made by combinations. */
		(void)strncpy( loc2, local, NAMESIZE );
		/* Shift name right two characters, and further prefix */
		strncpy( local+2, loc2, NAMESIZE-2 );
		local[1] = '_';			/* distinctive separater */
		local[NAMESIZE] = '\0';	/* ensure null termination */

		for( c = 'A'; c <= 'Z'; c++ )  {
			local[0] = c;
			if( (dp = db_lookup( dbip, local, LOOKUP_QUIET )) == DIR_NULL )
				break;
		}
		if( c > 'Z' )  {
			bu_log("mged_dir_add: Duplicate of name '%s', ignored\n",
				local );
			return 0;
		}
		bu_log("mged_dir_add: Duplicate of '%s' given new name '%s'\nYou should have used the 'dup' command to detect this,\nand then specified a prefix for the 'concat' command.\n",
			loc2, local );
	}

	/* First, register this object in input database */
	if( (input_dp = db_diradd( input_dbip, name, laddr, len, flags, ptr)) == DIR_NULL )
		return(-1);

	/* Then, register a new object in the main database */
	if( (dp = db_diradd( dbip, local, -1L, 0, flags, ptr)) == DIR_NULL )
		return(-1);

	if( rt_db_get_internal( &intern, input_dp, input_dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
	{
		READ_ERR;
		if( db_delete( dbip, dp ) < 0 ||
		    db_dirdelete( dbip, dp ) < 0 )  {
		    	DELETE_ERR(local);
		}
	    	/* Abort processing on first error */
		return -1;
	}

	/* The name is set, update any references */
	if( flags & DIR_SOLID )
	{
		bu_log("adding solid '%s'\n", local );
		if ((ncharadd + strlen(name)) > (unsigned)NAMESIZE)
			bu_log("WARNING: solid name \"%s%s\" truncated to \"%s\"\n",
				prestr,name, local);
	}
	else
	{
		bu_log("adding  comb '%s'\n", local );

		/* Update all the member records */
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		if( ncharadd && comb->tree )
		{
			db_tree_funcleaf( dbip, comb, comb->tree, Do_update,
				(genptr_t)&ncharadd, (genptr_t)prestr, (genptr_t)NULL );
		}
	}

	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		bu_log( "Failed writing %s to database\n", dp->d_namep );
		return( -1 );
	}

	return 0;
}


/*
d100 1
d114 1
d119 1
@


11.28
log
@
Changed "dbconcat" command to invoke "concat" method on "db" object.
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.27 2000/09/08 05:55:48 mike Exp $ (BRL)";
d183 1
@


11.27
log
@
Tree routines now need resource structure.
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.26 2000/08/19 03:10:43 mike Exp $ (BRL)";
d337 22
d364 1
a364 1
 *  Usage:  dup file.g [prefix]
a376 3
	struct db_i		*newdbp;
	int bad = 0;

d398 1
a398 33
	if( strcmp( argv[2], "/" ) == 0 )  {
		/* No prefix desired */
		(void)strcpy(prestr, "\0");
	} else {
		(void)strcpy(prestr, argv[2]);
	}

	if( (ncharadd = strlen( prestr )) > 12 )  {
		ncharadd = 12;
		prestr[12] = '\0';
	}

	/* open the input file */
	if( (newdbp = db_open( argv[1], "r" )) == DBI_NULL )  {
		perror( argv[1] );
		Tcl_AppendResult(interp, "concat: Can't open ",
				 argv[1], "\n", (char *)NULL);
		return TCL_ERROR;
	}

	/* Scan new database, adding everything encountered. */
	if( db_scan( newdbp, mged_dir_add, 1, NULL ) < 0 )  {
	  Tcl_AppendResult(interp, "concat: db_scan failure\n", (char *)NULL);
	  bad = 1;	
	  /* Fall through, to close off database */
	}

	/* Free all the directory entries, and close the input database */
	db_close( newdbp );

	sync();		/* just in case... */

	return bad ? TCL_ERROR : TCL_OK;
@


11.26
log
@
const RCSid
@
text
@d22 1
a22 1
static const char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.25 2000/07/23 23:42:21 mike Exp $ (BRL)";
d294 1
a294 1
	if( rt_db_get_internal( &intern, input_dp, input_dbip, (fastf_t *)NULL ) < 0 )
d305 1
a305 1
	/* Update the name, and any references */
a311 3

		bu_free((genptr_t)dp->d_namep, "mged_dir_add: dp->d_namep");
		dp->d_namep = bu_strdup(local);
a315 2
		bu_free((genptr_t)dp->d_namep, "mged_dir_add: dp->d_namep");
		dp->d_namep = bu_strdup(local);
d326 1
a326 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )
@


11.25
log
@
Removed calls to db_alloc(), which are no longer necessary
with either v4 or v5 database interfaces
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.24 1999/12/30 20:01:36 jra Exp $ (BRL)";
@


11.24
log
@Eliminated some unused variables
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.23 1999/12/29 23:23:20 mike Exp $ (BRL)";
d291 1
a291 3
	if( (dp = db_diradd( dbip, local, -1L, len, flags, ptr)) == DIR_NULL )
		return(-1);
	if( db_alloc( dbip, dp, len ) < 0 )
@


11.24.2.1
log
@After calling db_scan(), be sure to release the on-disk free map,
to prevent rt_memfree(addr=x10e,size=1)  ERROR type=010 messages.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.24 1999/12/30 20:01:36 jra Exp $ (BRL)";
a182 1
  rt_mempurge( &(newdbp->dbi_freep) );  /* didn't really build a directory */
@


11.23
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.22 1999/11/26 23:03:31 mike Exp $ (BRL)";
a319 3
		register int i;
		char	mref[NAMESIZE+2];

@


11.22
log
@
Lint
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.21 1999/09/01 18:55:09 bparker Exp $ (BRL)";
d58 1
a58 1
mged_dir_check( input_dbip, name, laddr, len, flags )
d60 1
a60 1
register char		*name;
d64 1
d176 1
a176 1
  if( db_scan( newdbp, mged_dir_check, 0 ) < 0 )  {
d231 1
a231 1
mged_dir_add( input_dbip, name, laddr, len, flags )
d233 1
a233 1
register char		*name;
d237 1
d287 1
a287 1
	if( (input_dp = db_diradd( input_dbip, name, laddr, len, flags)) == DIR_NULL )
d291 1
a291 1
	if( (dp = db_diradd( dbip, local, -1L, len, flags)) == DIR_NULL )
d410 1
a410 1
	if( db_scan( newdbp, mged_dir_add, 1 ) < 0 )  {
@


11.21
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /c/CVS/brlcad/mged/concat.c,v 11.20 1997/11/05 17:53:30 jra Exp $ (BRL)";
d294 1
a294 1
	if( rt_db_get_internal( &intern, input_dp, input_dbip, (mat_t *)NULL ) < 0 )
@


11.20
log
@Made Do_update() agree with f_concat() on new names.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.19 1997/09/10 17:30:10 bparker Exp jra $ (BRL)";
d111 1
a111 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d243 1
a243 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d366 1
a366 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

@


11.19
log
@mged_dir_add() was wrongly making an assumption
about the size of dp->d_namep
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.18 1997/07/31 14:27:47 bparker Exp bparker $ (BRL)";
d219 1
a219 1
		NAMESIZE-1-(*ncharadd) );
@


11.18
log
@fixed typo
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.17 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
d315 2
a316 1
		NAMEMOVE( local, dp->d_namep );
d324 2
a325 1
		NAMEMOVE( local, dp->d_namep );
@


11.17
log
@mods to run without a database
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.16 1997/04/24 18:03:58 bparker Exp bparker $ (BRL)";
d163 1
a163 1
		     argv[1], " prefixed with:  ", prestr, "\n", (char *)NULL);
@


11.16
log
@modify calls to Tcl_Eval
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.15 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d68 3
d111 3
d207 3
d244 3
d365 3
@


11.15
log
@mods so that commands check args internally
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.14 1997/03/28 21:38:15 jra Exp bparker $ (BRL)";
d109 6
a114 1
    Tcl_Eval(interp, "help dup");
d357 6
a362 1
	  Tcl_Eval(interp, "help dbconcat");
@


11.14
log
@Fixed it to handle NAMESIZE length names instead of NAMESIZE-1.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.13 1997/03/25 14:43:44 jra Exp jra $ (BRL)";
d108 2
a109 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d111 1
d351 2
a352 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d354 1
@


11.13
log
@Mods to support MGED's read-only mode.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.12 1997/02/28 21:09:02 jra Exp jra $ (BRL)";
d233 1
a233 1
		(void)strncpy( local+ncharadd, name, NAMESIZE-1-ncharadd );
d237 1
a237 1
	local[NAMESIZE-1] = '\0';
d251 1
a251 1
		local[NAMESIZE-1] = '\0';	/* ensure null termination */
d292 1
a292 1
		if ((ncharadd + strlen(name)) >= (unsigned)NAMESIZE)
@


11.12
log
@removed db.h include.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.11 1997/02/25 14:21:40 jra Exp jra $ (BRL)";
d346 2
@


11.11
log
@Completeed conversion to combination import/export.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.10 1997/02/14 13:12:01 jra Exp jra $ (BRL)";
a39 1
#include "db.h"
@


11.10
log
@Converted to using combination import/export.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.9 1996/10/04 14:59:42 bparker Exp jra $ (BRL)";
a226 1
	union record		*rec;
@


11.9
log
@-call vls_col_pr4v() instead of col_pr4v.
-cast bu_free's 1st argument to genptr_t.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.8 1996/10/03 20:42:28 bparker Exp bparker $ (BRL)";
d184 24
d225 2
d279 2
a280 2
	/* Read in all the records for this object */
	if( (rec = db_getmrec( input_dbip, input_dp )) == (union record *)0 )  {
d291 2
a292 1
	if( flags & DIR_SOLID )  {
d298 4
a301 3
		/* Depends on all kinds of solids having name in same place */
		NAMEMOVE( local, rec->s.s_name );
	} else {
d306 1
a306 1
		NAMEMOVE( local, rec->c.c_name );
d309 5
a313 8
		for( i=1; i < dp->d_len; i++ )  {
			if( ncharadd ) {
				(void)strncpy( mref, prestr, ncharadd );
				(void)strncpy( mref+ncharadd,
					rec[i].M.m_instname,
					NAMESIZE-1-ncharadd );
				NAMEMOVE( mref, rec[i].M.m_instname );
			}
d317 5
a321 3
	/* Write the new record into the main database */
	if( db_put( dbip, dp, rec, 0, len ) < 0 )
		return(-1);
a322 1
	bu_free( (genptr_t)rec, "db_getmrec rec" );
@


11.8
log
@free allocated memory after interrupt
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.7 1996/10/01 17:26:29 bparker Exp bparker $ (BRL)";
d107 1
a107 1
  struct bu_vls tmp_vls;
d112 1
a112 2
  bu_vls_init(&tmp_vls);

d116 1
a116 1
    bu_vls_free(&tmp_vls);
d172 3
a174 3
  col_pr4v( dirp0, (int)(dup_dirp - dirp0));
  bu_vls_printf(&tmp_vls, "\n -----  %d duplicate names found  -----\n",num_dups);
  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
a178 1
  bu_vls_free(&tmp_vls);
d180 1
d296 1
a296 1
	bu_free( (char *)rec, "db_getmrec rec" );
@


11.7
log
@ignore SIGINT
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.6 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d104 74
a177 65
	struct db_i		*newdbp;
	struct directory	**dirp0;
	int status = TCL_OK;

	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);	/* allow interupts */
	else
	  return TCL_OK;

	/* get any prefix */
	if( argc < 3 ) {
		prestr[0] = '\0';
	} else {
		(void)strcpy(prestr, argv[2]);
	}
	num_dups = 0;
	if( (ncharadd = strlen( prestr )) > 12 )  {
		ncharadd = 12;
		prestr[12] = '\0';
	}

	/* open the input file */
	if( (newdbp = db_open( argv[1], "r" )) == DBI_NULL )  {
	  perror( argv[1] );
	  Tcl_AppendResult(interp, "dup: Can't open ", argv[1], "\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	Tcl_AppendResult(interp, "\n*** Comparing ", dbip->dbi_filename,
			 "  with ", argv[1], " for duplicate names\n", (char *)NULL);
	if( ncharadd ) {
	  Tcl_AppendResult(interp, "  For comparison, all names in ",
			   argv[1], " prefixed with:  ", prestr, "\n", (char *)NULL);
	}

	/* Get array to hold names of duplicates */
	if( (dup_dirp = dir_getspace(0)) == (struct directory **) 0) {
	  Tcl_AppendResult(interp, "f_dup: unable to get memory\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}
	dirp0 = dup_dirp;

	/* Scan new database for overlaps */
	if( db_scan( newdbp, mged_dir_check, 0 ) < 0 )  {
	  Tcl_AppendResult(interp, "dup: db_scan failure\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	col_pr4v( dirp0, (int)(dup_dirp - dirp0));
	bu_free( (char *)dirp0, "dir_getspace array" );
	
	{
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "\n -----  %d duplicate names found  -----\n",num_dups);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
a178 1
	db_close( newdbp );
d180 3
a182 2
	(void)signal( SIGINT, SIG_IGN );
	return status;
@


11.6
log
@now using libbu
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.5 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d106 1
d132 2
a133 1
	  return TCL_ERROR;
d146 2
a147 1
	  return TCL_ERROR;
d154 2
a155 1
	  return TCL_ERROR;
d171 3
a173 2

	return TCL_OK;
@


11.5
log
@Still Tcl'ing the code
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.4 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d69 1
a69 1
	if( input_dbip->dbi_magic != DBI_MAGIC )  rt_bomb("mged_dir_check:  bad dbip\n");
d155 1
a155 1
	rt_free( (char *)dirp0, "dir_getspace array" );
d158 1
a158 1
	  struct rt_vls tmp_vls;
d160 4
a163 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "\n -----  %d duplicate names found  -----\n",num_dups);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d191 1
a191 1
	if( input_dbip->dbi_magic != DBI_MAGIC )  rt_bomb("mged_dir_add:  bad dbip\n");
d222 1
a222 1
			rt_log("mged_dir_add: Duplicate of name '%s', ignored\n",
d226 1
a226 1
		rt_log("mged_dir_add: Duplicate of '%s' given new name '%s'\nYou should have used the 'dup' command to detect this,\nand then specified a prefix for the 'concat' command.\n",
d253 1
a253 1
		rt_log("adding solid '%s'\n", local );
d255 1
a255 1
			rt_log("WARNING: solid name \"%s%s\" truncated to \"%s\"\n",
d264 1
a264 1
		rt_log("adding  comb '%s'\n", local );
d283 1
a283 1
	rt_free( (char *)rec, "db_getmrec rec" );
@


11.4
log
@convert commands to Tcl
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.3 1996/03/01 19:32:29 bparker Exp bparker $ (BRL)";
d110 4
a113 1
	(void)signal( SIGINT, sig2 );           /* allow interrupts */
@


11.3
log
@remove unused XMGED stuff
./
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 11.2 1995/01/17 13:04:29 bparker Exp bparker $ (BRL)";
d98 3
a100 1
f_dup( argc, argv )
d107 3
d126 3
a128 3
		perror( argv[1] );
		(void)rt_log( "dup: Can't open %s\n", argv[1]);
		return CMD_BAD;
d131 2
a132 2
	rt_log("\n*** Comparing %s with %s for duplicate names\n",
		dbip->dbi_filename,argv[1]);
d134 2
a135 2
		rt_log("  For comparison, all names in %s prefixed with:  %s\n",
				argv[1],prestr);
d140 2
a141 2
		rt_log( "f_dup: unable to get memory\n");
		return CMD_BAD;
d147 2
a148 2
		(void)rt_log( "dup: db_scan failure\n");
		return CMD_BAD;
d153 9
a161 1
	rt_log("\n -----  %d duplicate names found  -----\n",num_dups);
d165 1
a165 1
	return CMD_OK;
d298 3
a300 1
f_concat( argc, argv )
d307 3
d312 4
a315 3
		(void)rt_log(
			"concat: Enter prefix string or / for no prefix: ");
		return CMD_MORE;
d333 3
a335 2
		(void)rt_log( "concat: Can't open %s\n", argv[1]);
		return CMD_BAD;
d340 3
a342 3
		(void)rt_log( "concat: db_scan failure\n");
		bad = 1;	
		/* Fall through, to close off database */
d350 1
a350 1
	return bad ? CMD_BAD : CMD_OK;
@


11.2
log
@merging xmged sources
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/xmged/RCS/concat.c,v 11.2 95/01/17 11:42:10 bparker Exp $ (BRL)";
a104 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );		/* allow interrupts */
#else
a105 1
#endif
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 10.11 94/12/16 19:35:51 gdurf Exp $ (BRL)";
d105 5
a109 1
	(void)signal( SIGINT, sig2 );		/* allow interrupts */
@


10.11
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 10.10 1994/11/10 12:06:05 jra Exp gdurf $ (BRL)";
@


10.10
log
@Irix 6.0.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/concat.c,v 10.9 1994/10/21 19:34:23 mike Exp jra $ (BRL)";
d122 1
a122 1
		(void)fprintf(stderr, "dup: Can't open %s\n", argv[1]);
d126 1
a126 1
	(void)printf("\n*** Comparing %s with %s for duplicate names\n",
d129 1
a129 1
		(void)printf("  For comparison, all names in %s prefixed with:  %s\n",
d135 1
a135 1
		(void) printf( "f_dup: unable to get memory\n");
d142 1
a142 1
		(void)fprintf(stderr, "dup: db_scan failure\n");
d148 1
a148 1
	(void)printf("\n -----  %d duplicate names found  -----\n",num_dups);
d237 1
a237 1
		printf("adding solid '%s'\n", local );
d239 1
a239 1
			printf("WARNING: solid name \"%s%s\" truncated to \"%s\"\n",
d248 1
a248 1
		printf("adding  comb '%s'\n", local );
d294 1
a294 1
		(void)fprintf(stderr,
d314 1
a314 1
		(void)fprintf(stderr, "concat: Can't open %s\n", argv[1]);
d320 1
a320 1
		(void)fprintf(stderr, "concat: db_scan failure\n");
@


10.9
log
@strlen() is unsigned now.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 10.8 94/09/28 15:43:27 mike Exp Locker: mike $ (BRL)";
a65 2
	register struct directory **headp;
	register struct directory *dp;
@


10.8
log
@Clarified error message.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 10.7 94/09/28 02:57:27 mike Exp Locker: mike $ (BRL)";
d240 1
a240 1
		if ((ncharadd + strlen(name)) >= NAMESIZE)
@


10.7
log
@(1) ALWAYS require a prefix string to be given.  '/' means no prefix.
(2) If concat file is the database file, prevent db_getmrec() failures
from creating damaged database records and causing core dumps.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 10.6 94/08/09 15:04:15 gdurf Exp Locker: mike $ (BRL)";
d194 2
d212 1
a212 1
		rt_log("mged_dir_add: Duplicate of '%s' given new name '%s'\n",
@


10.6
log
@Added include
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 10.5 1994/08/09 14:53:23 gdurf Exp gdurf $ (BRL)";
d215 1
a215 1
	if( (input_dp = db_diradd( input_dbip, local, laddr, len, flags)) == DIR_NULL )
d225 9
a233 2
	if( (rec = db_getmrec( input_dbip, input_dp )) == (union record *)0 )
		return(-1);
d267 1
d293 8
a300 1
	if( argc < 3 )
d302 1
a302 1
	else
d304 1
@


10.5
log
@Factored ifdefs
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 10.4 1994/06/13 19:06:12 gdurf Exp gdurf $ (BRL)";
d24 2
@


10.4
log
@Expunged cmd_args[] and numargs.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 10.3 1992/02/11 08:14:14 butler Exp gdurf $ (BRL)";
d30 3
a32 1
#ifdef BSD
a33 2
#else
#include <string.h>
@


10.3
log
@introduced code to warn user of solid-name truncation.  Made name truncation
consistent between solid name and name-of-solid-in-combination.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 10.2 92/02/05 13:34:57 mike Exp Locker: butler $ (BRL)";
a43 4
extern int	args;		/* total number of args available */
extern int	argcnt;		/* holder for number of args added later */
extern char	*cmd_args[];	/* array of pointers to args */

d97 1
a97 1
void
d123 1
a123 1
		return;
d136 1
a136 1
		return;
d143 1
a143 1
		return;
d151 2
d274 1
a274 1
void
d280 1
a280 4

	/* save number of args entered initially */
	args = argc;
	argcnt = 0;
d283 4
a286 10
	if( argc < 3 ) {
		(void)printf("Enter prefix string or CR: ");
		argcnt = getcmd(args);
		/* add any new args entered */
		args += argcnt;
		/* no prefix is acceptable */
		if(args == 2)
			cmd_args[2][0] = '\0';
	}
	(void)strcpy(prestr, cmd_args[2]);
d294 4
a297 4
	if( (newdbp = db_open( cmd_args[1], "r" )) == DBI_NULL )  {
		perror( cmd_args[1] );
		(void)fprintf(stderr, "concat: Can't open %s\n", cmd_args[1]);
		return;
d303 1
d311 2
@


10.2
log
@stdio.h must come before pwd.h
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 10.1 91/10/12 06:43:15 mike Rel4_0 Locker: mike $ (BRL)";
d182 1
a182 1
		(void)strncpy( local+ncharadd, name, NAMESIZE-ncharadd );
d186 1
a186 1
	local[NAMESIZE] = '\0';
d198 1
a198 1
		local[NAMESIZE] = '\0';		/* ensure null termination */
d231 4
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 1.6 91/07/18 00:33:51 mike Exp $ (BRL)";
d25 1
a27 1
#include <stdio.h>
@


1.6
log
@ *  NOTE:  If a prefix is not given on the command line,
 *  then the users insist that they be prompted for the prefix,
 *  to prevent inadvertently sucking in a non-prefixed file.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 1.5 90/12/07 06:08:51 mike Exp $ (BRL)";
@


1.5
log
@Eliminated references to cmd_args
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 1.4 90/12/07 06:05:58 mike Exp $ (BRL)";
d44 4
d267 4
d279 4
d285 7
a291 3
		prestr[0] = '\0';
	} else {
		(void)strcpy(prestr, argv[2]);
d293 2
d301 3
a303 3
	if( (newdbp = db_open( argv[1], "r" )) == DBI_NULL )  {
		perror( argv[1] );
		(void)fprintf(stderr, "concat: Can't open %s\n", argv[1]);
d310 1
a310 1
		return;
@


1.4
log
@Concat function now working well.
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 1.3 90/12/07 05:41:35 mike Exp $ (BRL)";
a42 4

extern int	args;		/* total number of args available */
extern int	argcnt;		/* holder for number of args added later */
extern char	*cmd_args[];	/* array of pointers to args */
@


1.3
log
@Converted to using db_scan for concat operation
@
text
@d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 1.2 90/12/07 04:16:08 mike Exp $ (BRL)";
d175 1
a175 1
	char			local[NAMESIZE+2];
d191 1
d194 1
d196 2
a197 2
		strncpy( local+2, name, NAMESIZE-2 );
		local[1] = '@@';			/* distinctive separater */
d211 1
a211 1
			name, local );
d237 1
a237 1
		printf("adding comb '%s'\n", local );
@


1.2
log
@This version has a working "dup" command.
@
text
@d9 1
d22 1
a22 1
static char RCSconcat[] = "@@(#)$Header: /m/cad/mged/RCS/concat.c,v 1.1 90/12/07 03:30:54 mike Exp $ (BRL)";
a47 2
void		prename();

d52 1
a52 1
char	prestr[15];
a54 16
/*    P R E N A M E ( ): 	actually adds prefix to a name
 *				new_name[] = prestr[] + old_name[]
 */
void
prename( old_name )
char old_name[NAMESIZE];
{

	(void)strcpy(new_name, prestr);
	(void)strncat(new_name, old_name, NAMESIZE-1-ncharadd);
	if( ncharadd + strlen( old_name ) > NAMESIZE-1 ) {
		(void)printf("name truncated : %s + %s = %s\n",
			prestr,old_name,new_name);
	}
}

d56 1
a56 1
 *			M G E D _ D I R A D D
d58 1
a58 1
 * Add an entry to the directory
d61 2
a62 2
mged_diradd( loc_dbip, name, laddr, len, flags )
register struct db_i	*loc_dbip;
d73 1
a73 1
	if( loc_dbip->dbi_magic != DBI_MAGIC )  rt_bomb("mged_diradd:  bad dbip\n");
d85 1
a85 1
	if( (dupdp = db_lookup( dbip, name, 0 )) != DIR_NULL )  {
d123 1
a123 1
	/* open the target file */
d144 2
a145 2
	/* Scan new directory for overlaps */
	if( db_scan( newdbp, mged_diradd ) < 0 )  {
a157 1

d159 1
d161 2
a162 3
 *		F _ C O N C A T
 *
 *	concatenates another GED file onto end of current file
d164 7
a170 4
void
f_concat( argc, argv )
int	argc;
char	**argv;
d172 1
a172 3
	union record	record;
	FILE *catfp;
	int nskipped, i, length;
d174 2
d177 1
a177 1
	(void)signal( SIGINT, sig2 );		/* interrupts */
d179 6
a184 10
	/* save number of args entered initially */
	args = argc;
	argcnt = 0;

	/* get target file name */
	while( args < 2 ) {
		(void)printf("Enter the target file name: ");
		argcnt = getcmd(args);
		/* add any new args entered */
		args += argcnt;
d186 5
d192 5
a196 5
	/* open the target file */
	if( (catfp=fopen(cmd_args[1], "r")) == NULL ) {
		(void)fprintf(stderr,"Can't open %s\n",cmd_args[1]);
		return;
	}
d198 12
a209 9
	/* get any prefix */
	if( args < 3 ) {
		(void)printf("Enter prefix string or CR: ");
		argcnt = getcmd(args);
		/* add any new args entered */
		args += argcnt;
		/* no prefix is acceptable */
		if(args == 2)
			cmd_args[2][0] = '\0';
d212 3
a214 3
	ncharadd = nskipped = 0;
	(void)strcpy(prestr, cmd_args[2]);
	ncharadd = strlen( prestr );
d216 5
a220 7
	fread( (char *)&record, sizeof record, 1, catfp );
	if(record.u_id != ID_IDENT) {
		(void)printf("%s: Not a correct GED data base - STOP\n",
				cmd_args[1]);
		(void)fclose( catfp );
		return;
	}
d222 3
a224 1
	(void)signal( SIGINT, SIG_IGN );		/* NO interrupts */
d226 8
a233 1
	while( fread( (char *)&record, sizeof record, 1, catfp ) == 1 && ! feof(catfp) ) {
d235 2
a236 1
		switch( record.u_id ) {
d238 11
a248 6
			case ID_IDENT:
			case ID_FREE:
			case ID_ARS_B:
			case ID_MEMB:
			case ID_P_DATA:
				break;
d250 3
a252 3
			case ID_MATERIAL:
				rt_color_addrec( &record, -1 );
				break;
d254 2
a255 21
			case ID_SOLID:
				if(record.s.s_name[0] == 0)
					break;
				if( ncharadd ) {
					prename(record.s.s_name);
					NAMEMOVE(new_name, record.s.s_name);
				}
				if( db_lookup( dbip, record.s.s_name, LOOKUP_QUIET) != DIR_NULL ) {
					nskipped++;
					(void)printf("SOLID (%s) already exists in %s....will skip\n",
						record.s.s_name, dbip->dbi_filename);
					break;
				}
				/* add to the directory */
printf("adding solid \"%s\"\n", record.s.s_name);
				if( (dp = db_diradd( dbip, record.s.s_name, -1, 1, DIR_SOLID)) == DIR_NULL )
					return;
				/* add the record to the data base file */
				db_alloc( dbip, dp, 1 );
				db_put( dbip, dp, &record, 0, 1 );
				break;
a256 24
			case ID_ARS_A:
				if( ncharadd ) {
					prename(record.a.a_name);
					NAMEMOVE(new_name, record.a.a_name);
				}
				if( db_lookup( dbip, record.a.a_name, LOOKUP_QUIET) != DIR_NULL ) {
					nskipped++;
					(void)printf("ARS (%s) already exists in %s....will skip\n",
							record.a.a_name, dbip->dbi_filename);
					break;
				}
				/* add to the directory */
				length = record.a.a_totlen;
				if( (dp = db_diradd( dbip, record.a.a_name, -1, length+1, DIR_SOLID)) == DIR_NULL )
					return;
				/* add the record to the data base file */
				db_alloc( dbip, dp, length+1 );
				db_put( dbip, dp, &record, 0, 1 );
				/* get the b_records */
				for(i=1; i<=length; i++) {
					(void)fread( (char *)&record, sizeof record, 1, catfp );
					db_put( dbip, dp, &record, i, 1 );
				}
				break;
d258 14
a271 42
			case ID_COMB:
				if( ncharadd ) {
					prename(record.c.c_name);
					NAMEMOVE(new_name, record.c.c_name);
				}
				if( db_lookup( dbip, record.c.c_name, LOOKUP_QUIET) != DIR_NULL ) {
					nskipped++;
					(void)printf("COMB (%s) already exists in %s....will skip\n",
							record.c.c_name, dbip->dbi_filename);
					break;
				}
				/* add to the directory */
#if 0
				length = record.c.c_length;
#else
	/* XXXXX XXXXX XXXXX */
				length = 0;
#endif
printf("adding comb \"%s\"\n", record.c.c_name);
				if( (dp = db_diradd( dbip,  record.c.c_name, -1,
						length+1,
						record.c.c_flags == 'R' ?
						DIR_COMB|DIR_REGION : DIR_COMB
						) ) == DIR_NULL )
					return;
				/* add the record to the data base file */
				db_alloc( dbip, dp, length+1 );
				db_put( dbip, dp, &record, 0, 1 );
				/* get the member records */
				for(i=1; i<=length; i++) {
					(void)fread( (char *)&record, sizeof record, 1, catfp );
					if( record.M.m_brname[0] && ncharadd ) {
						prename(record.M.m_brname);
						NAMEMOVE(new_name, record.M.m_brname);
					}
					if( record.M.m_instname[0] && ncharadd ) {
						prename(record.M.m_instname);
						NAMEMOVE(new_name, record.M.m_instname);
					}
					db_put( dbip, dp, &record, i, 1 );
				}
				break;
d273 10
a282 14
			case ID_BSOLID:
				if( ncharadd ) {
					prename(record.B.B_name);
					NAMEMOVE(new_name, record.B.B_name);
				}
				if( db_lookup( dbip, record.B.B_name, LOOKUP_QUIET) != DIR_NULL ) {
					nskipped++;
					(void)printf("SPLINE (%s) already exists in %s....will skip\n",
							record.B.B_name, dbip->dbi_filename);
					break;
				}
	printf("SPLINE not implemented yet, aborting!\n");
				/* Need to miss the knots and mesh */
				return;
d284 6
a289 15
			case ID_P_HEAD:
				if(record.p.p_name[0] == 0)
					break;
				if( ncharadd ) {
					prename(record.p.p_name);
					NAMEMOVE(new_name, record.p.p_name);
				}
				if( db_lookup( dbip, record.p.p_name, LOOKUP_QUIET) != DIR_NULL ) {
					nskipped++;
					(void)printf("POLYGON (%s) already exists in %s....will skip\n",
							record.p.p_name, dbip->dbi_filename);
					break;
				}
printf("POLYGONS not implemented yet.....SKIP %s\n",record.p.p_name);
				break;
d291 5
a295 4
			default:
				(void)printf("BAD record type (%c) in %s\n",
						record.u_id,cmd_args[1]);
				break;
d297 2
a298 1
		}
d300 1
a300 1
	}
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSconcat[] = "@@(#)$Header$ (BRL)";
d49 3
d73 1
d75 37
d116 1
a116 1
 *
d123 2
a124 6
	union record	record;
	register FILE *dupfp;
	register int i;
	int ndup;
	register struct directory *tmpdp;
	struct directory **dirp, **dirp0;
d128 5
a132 10
	/* save number of args entered initially */
	args = argc;
	argcnt = 0;

	/* get target file name */
	while( args < 2 ) {
		(void)printf("Enter the target file name: ");
		argcnt = getcmd(args);
		/* add any new args entered */
		args += argcnt;
d134 5
d141 3
a143 2
	if( (dupfp=fopen(cmd_args[1], "r")) == NULL ) {
		(void)fprintf(stderr,"Can't open %s\n",cmd_args[1]);
a146 24
	/* get any prefix */
	if( args < 3 ) {
		(void)printf("Enter prefix string or CR: ");
		argcnt = getcmd(args);
		/* add any new args entered */
		args += argcnt;
		/* no prefix is acceptable */
		if(args == 2)
			cmd_args[2][0] = '\0';
	}

	ndup = 0;
	ncharadd = 0;
	(void)strcpy(prestr, cmd_args[2]);
	ncharadd = strlen( prestr );

	fread( (char *)&record, sizeof record, 1, dupfp );
	if(record.u_id != ID_IDENT) {
		(void)printf("%s: Not a correct GED data base - STOP\n",
				cmd_args[1]);
		(void)fclose( dupfp );
		return;
	}

d148 1
a148 1
		dbip->dbi_filename,cmd_args[1]);
d151 1
a151 1
				cmd_args[1],prestr);
d154 2
a155 1
	if( (dirp = dir_getspace(0)) == (struct directory **) 0) {
d159 1
a159 1
	dirp0 = dirp;
d161 5
a165 2
	while( fread( (char *)&record, sizeof record, 1, dupfp ) == 1 && ! feof(dupfp) ) {
		tmpdp = DIR_NULL;
d167 3
a169 1
		switch( record.u_id ) {
d171 1
a171 90
			case ID_IDENT:
			case ID_FREE:
			case ID_ARS_B:
			case ID_MEMB:
			case ID_P_DATA:
			case ID_MATERIAL:
				break;

			case ID_SOLID:
				if(record.s.s_name[0] == 0)
					break;
				if( ncharadd ) {
					prename(record.s.s_name);
					tmpdp = db_lookup( dbip, new_name, LOOKUP_QUIET);
				}
				else
					tmpdp = db_lookup( dbip, record.s.s_name, LOOKUP_QUIET);
				break;

			case ID_ARS_A:
				if(record.a.a_name[0] == 0) 
					break;
				if( ncharadd ) {
					prename(record.a.a_name);
					tmpdp = db_lookup( dbip, new_name, LOOKUP_QUIET);
				}
				else
					tmpdp = db_lookup( dbip, record.a.a_name, LOOKUP_QUIET);
				break;

			case ID_COMB:
				if(record.c.c_name[0] == 0)
					break;
				if( ncharadd ) {
					prename(record.c.c_name);
					tmpdp = db_lookup( dbip, new_name, LOOKUP_QUIET);
				}
				else
					tmpdp = db_lookup( dbip, record.c.c_name, LOOKUP_QUIET);
				break;

			case ID_BSOLID:
				if(record.B.B_name[0] == 0)
					break;
				if( ncharadd ) {
					prename(record.B.B_name);
					tmpdp = db_lookup( dbip, new_name, LOOKUP_QUIET);
				}
				else
					tmpdp = db_lookup( dbip, record.B.B_name, LOOKUP_QUIET);
				break;

			case ID_BSURF:
				/* Need to skip over knots & mesh which follows! */
				(void)fseek( dupfp,
					(record.d.d_nknots+record.d.d_nctls) *
						(long)(sizeof(record)),
					1 );
				continue;

			case ID_P_HEAD:
				if(record.p.p_name[0] == 0)
					break;
				if( ncharadd ) {
					prename(record.p.p_name);
					tmpdp = db_lookup( dbip, new_name, LOOKUP_QUIET);
				}
				else
					tmpdp = db_lookup( dbip, record.p.p_name, LOOKUP_QUIET);
				break;

			default:
				(void)printf("Unknown record type (%c) in %s\n",
						record.u_id,cmd_args[1]);
				break;

		}

		if(tmpdp != DIR_NULL) {
			/* have a duplicate name */
			ndup++;
			*dirp++ = tmpdp;
			tmpdp = DIR_NULL;
		}
	}
	col_pr4v( dirp0, (int)(dirp - dirp0));
	free( dirp0);
	(void)printf("\n -----  %d duplicate names found  -----\n",ndup);
	(void)fclose( dupfp );
	return;
d311 1
d313 4
@
