head	11.56;
access;
symbols
	ansi-20040405-merged:11.52.4.1
	postmerge-20040405-ansi:11.53
	premerge-20040404-ansi:11.53
	postmerge-autoconf:11.53
	autoconf-freeze:11.52.12.2
	premerge-autoconf:11.53
	postmerge-20040315-windows:11.53
	premerge-20040315-windows:11.53
	windows-20040315-freeze:11.52.6.1
	autoconf-20031203:11.52
	autoconf-20031202:11.52
	autoconf-branch:11.52.0.12
	phong-branch:11.52.0.10
	photonmap-branch:11.52.0.8
	rel-6-1-DP:11.52
	windows-branch:11.52.0.6
	rel-6-0-2:11.52
	ansi-branch:11.52.0.4
	rel-6-0-1-branch:11.52.0.2
	hartley-6-0-post:11.52
	hartley-6-0-pre:11.52
	rel-6-0-1:11.52
	rel-6-0:11.52
	rel-5-4:11.45.2.1
	offsite-5-3-pre:11.49
	rel-5-3:11.45.2.1
	rel-5-2:11.45
	rel-5-1-branch:11.45.0.2
	rel-5-1:11.45
	rel-5-0:11.41
	rel-5-0-beta:11.41
	rel-4-5:11.35
	ctj-4-5-post:11.27
	ctj-4-5-pre:11.27
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.11;
locks; strict;
comment	@ * @;


11.56
date	2004.05.21.17.47.50;	author morrison;	state dead;
branches;
next	11.55;

11.55
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.54;

11.54
date	2004.05.10.15.25.28;	author morrison;	state Exp;
branches;
next	11.53;

11.53
date	2004.02.02.17.39.35;	author morrison;	state Exp;
branches;
next	11.52;

11.52
date	2002.01.10.14.06.35;	author jra;	state Exp;
branches
	11.52.4.1
	11.52.6.1
	11.52.12.1;
next	11.51;

11.51
date	2001.06.05.15.51.42;	author bparker;	state Exp;
branches;
next	11.50;

11.50
date	2001.06.01.19.23.25;	author bparker;	state Exp;
branches;
next	11.49;

11.49
date	2001.02.01.21.29.28;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	2000.10.20.05.04.40;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	2000.09.07.02.58.52;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	2000.08.19.03.10.49;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	2000.01.06.22.06.55;	author mike;	state Exp;
branches
	11.45.2.1;
next	11.44;

11.44
date	99.12.30.19.16.46;	author jra;	state Exp;
branches;
next	11.43;

11.43
date	99.12.09.21.18.17;	author jra;	state Exp;
branches;
next	11.42;

11.42
date	99.12.06.20.21.44;	author jra;	state Exp;
branches;
next	11.41;

11.41
date	98.12.29.20.25.36;	author bparker;	state Exp;
branches;
next	11.40;

11.40
date	98.11.06.22.32.43;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	98.10.21.16.58.10;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	98.06.12.19.46.23;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	98.03.19.18.14.18;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	98.03.06.22.35.41;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	98.02.06.22.08.13;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	97.11.03.15.22.04;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	97.10.08.13.46.38;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	97.09.08.18.49.51;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	97.07.31.14.47.06;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	97.07.25.20.51.42;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	97.06.25.13.45.21;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	97.05.29.14.11.12;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	97.04.09.20.34.04;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	97.04.04.19.55.26;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	97.03.06.21.39.01;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	97.02.28.21.28.12;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	97.01.30.22.14.19;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	97.01.29.23.14.40;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	97.01.29.02.52.22;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	96.11.01.22.20.13;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	96.09.25.20.10.14;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	96.09.23.18.13.58;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.09.17.21.16.26;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.06.21.16.07.54;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.03.01.19.27.11;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.02.28.21.35.02;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.01.17.22.07.40;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	95.12.04.22.07.45;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	95.12.02.00.19.07;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	95.12.01.23.03.40;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.08.03.21.49.25;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.05.09;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.39;	author mike;	state Rel4_4;
branches;
next	10.20;

10.20
date	95.01.03.14.32.29;	author gdurf;	state Exp;
branches;
next	10.19;

10.19
date	94.12.27.18.06.24;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	94.11.05.03.47.40;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	94.10.18.14.04.23;	author jra;	state Exp;
branches;
next	10.16;

10.16
date	94.10.18.11.23.24;	author jra;	state Exp;
branches;
next	10.15;

10.15
date	94.10.18.08.39.57;	author jra;	state Exp;
branches;
next	10.14;

10.14
date	94.10.12.13.19.20;	author jra;	state Exp;
branches;
next	10.13;

10.13
date	94.10.11.12.33.44;	author jra;	state Exp;
branches;
next	10.12;

10.12
date	94.09.01.14.43.42;	author jra;	state Exp;
branches;
next	10.11;

10.11
date	94.08.09.18.43.42;	author gdurf;	state Exp;
branches;
next	10.10;

10.10
date	92.06.09.14.23.15;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	92.04.03.05.04.05;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.02.14.16.28.56;	author mmark;	state Exp;
branches;
next	10.7;

10.7
date	92.02.14.15.04.34;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.02.05.23.12.51;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.02.05.13.29.10;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.02.05.13.25.05;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	91.12.18.07.55.39;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.12.18.04.12.20;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.21;	author mike;	state Rel4_0;
branches;
next	9.10;

9.10
date	91.09.20.19.35.29;	author butler;	state Exp;
branches;
next	9.9;

9.9
date	91.08.30.18.33.39;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.08.30.18.31.12;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.08.30.18.23.34;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.06.30.21.16.31;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.06.30.19.51.30;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.06.27.16.31.43;	author pjt;	state Exp;
branches;
next	9.3;

9.3
date	91.06.25.16.10.24;	author pjt;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.28.07;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.04.00;	author mike;	state Rel3_5;
branches;
next	8.6;

8.6
date	89.04.22.05.44.53;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.04.21.04.57.03;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.14.05.08.52;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.04.06.20.40.21;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.02.33.28;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.37.26;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.09.07.11.09.07;	author stay;	state Exp;
branches;
next	7.4;

7.4
date	88.09.06.17.20.15;	author reschly;	state Exp;
branches;
next	7.3;

7.3
date	88.07.22.01.58.26;	author phil;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.06.59;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.02.00;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.05.26;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.22.19;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.13.10;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.23.11;	author mike;	state Rel1;
branches;
next	2.13;

2.13
date	86.08.12.06.50.54;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	85.09.27.19.12.46;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	85.08.28.21.41.56;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	85.08.26.17.16.23;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	85.08.07.05.19.54;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	85.07.30.01.18.14;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.05.29.23.17.34;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.05.10.00.54.58;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.05.08.00.24.50;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.05.03.02.00.20;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.05.02.22.12.31;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.15.05.06.31;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.58.01;	author mike;	state Prod;
branches;
next	1.8;

1.8
date	85.02.02.01.40.53;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	85.02.01.04.06.27;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	85.02.01.00.51.21;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	85.01.19.02.30.54;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.01.16.03.29.25;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.01.16.01.58.51;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.20.04.25.43;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.53.15;	author mike;	state Exp;
branches;
next	;

11.45.2.1
date	2001.02.01.21.28.41;	author bparker;	state Exp;
branches;
next	;

11.52.4.1
date	2004.03.17.21.22.05;	author morrison;	state Exp;
branches;
next	;

11.52.6.1
date	2004.03.11.23.46.37;	author morrison;	state Exp;
branches;
next	;

11.52.12.1
date	2004.02.12.18.34.16;	author erikg;	state Exp;
branches;
next	11.52.12.2;

11.52.12.2
date	2004.03.15.14.07.41;	author erikg;	state Exp;
branches;
next	;


desc
@Draw the "faceplate" on the display screen
@


11.56
log
@moved to src/mged/
@
text
@/*
 *			T I T L E S . C
 *
 * Functions -
 *	dotitles	Output GED "faceplate" & titles.
 *
 *  Author -
 *	Michael John Muuss
 *	Kieth A. Applin
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/titles.c,v 11.55 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#define USE_OLD_MENUS 0

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "externs.h"
#include "./ged.h"
#include "./titles.h"
#include "./mged_solid.h"
#include "./sedit.h"
#include "./mgedtcl.h"
#include "./mged_dm.h"

int	state;
char	*state_str[] = {
	"-ZOT-",
	"VIEWING",
	"SOL PICK",
	"SOL EDIT",
	"OBJ PICK",
	"OBJ PATH",
	"OBJ EDIT",
	"VERTPICK",
	"UNKNOWN",
};

extern mat_t perspective_mat;  /* defined in dozoom.c */
extern struct rt_db_internal	es_int;

/*
 *			C R E A T E _ T E X T _ O V E R L A Y
 *
 *  Prepare the numerical display of the currently edited solid/object.
 */
void
create_text_overlay( struct bu_vls *vp )
{
	struct directory	*dp;
	struct bu_vls vls;

	BU_CK_VLS(vp);
	bu_vls_init(&vls);

	/*
	 * Set up for character output.  For the best generality, we
	 * don't assume that the display can process a CRLF sequence,
	 * so each line is written with a separate call to DM_DRAW_STRING_2D().
	 */

	/* print solid info at top of screen */
	if( es_edflag >= 0 ) {
		dp = LAST_SOLID(illump);

		bu_vls_strcat( vp, "** SOLID -- " );
		bu_vls_strcat( vp, dp->d_namep );
		bu_vls_strcat( vp, ": ");

		vls_solid( vp, &es_int, bn_mat_identity );

		if(illump->s_fullpath.fp_len > 1) {
			bu_vls_strcat( vp, "\n** PATH --  ");
			db_path_to_vls( vp, &illump->s_fullpath );
			bu_vls_strcat( vp, ": " );

			/* print the evaluated (path) solid parameters */
			vls_solid( vp, &es_int, es_mat );
		}
	}

	/* display path info for object editing also */
	if( state == ST_O_EDIT ) {
		bu_vls_strcat( vp, "** PATH --  ");
		db_path_to_vls( vp, &illump->s_fullpath );
		bu_vls_strcat( vp, ": " );

		/* print the evaluated (path) solid parameters */
		if( illump->s_Eflag == 0 ) {
			mat_t	new_mat;
			/* NOT an evaluated region */
			/* object edit option selected */
			bn_mat_mul(new_mat, modelchanges, es_mat);

			vls_solid( vp, &es_int, new_mat );
		}
	}

	{
	  register char *start;
	  register char *p;
	  register int imax = 0;
	  register int i = 0;
	  register int j;
	  struct bu_vls vls;

	  start = bu_vls_addr( vp );
	  /*
	   * Some display managers don't handle TABs properly, so
	   * we replace any TABs with spaces. Also, look for the
	   * maximum line length.
	   */
	  for(p = start; *p != '\0'; ++p){
	    if(*p == '\t')
	      *p = ' ';
	    else if(*p == '\n'){
	      if(i > imax)
		imax = i;
	      i = 0;
	    }else
	      ++i;
	  }

	  if(i > imax)
	    imax = i;

	  /* Prep string for use with Tcl/Tk */
	  ++imax;
	  i = 0;
	  bu_vls_init(&vls);
	  for(p = start; *p != '\0'; ++p){
	    if(*p == '\n'){
	      for(j = 0; j < imax - i; ++j)
		bu_vls_putc(&vls, ' ');

	      bu_vls_putc(&vls, *p);
	      i = 0;
	    }else{
	      bu_vls_putc(&vls, *p);
	      ++i;
	    }
	  }

	  Tcl_SetVar(interp, bu_vls_addr(&edit_info_vls),
		     bu_vls_addr(&vls), TCL_GLOBAL_ONLY);
	  bu_vls_free(&vls);
	}
}

/*
 *			S C R E E N _ V L S
 *
 *  Output a vls string to the display manager,
 *  as a text overlay on the graphics area (ugh).
 *
 * Set up for character output.  For the best generality, we
 * don't assume that the display can process a CRLF sequence,
 * so each line is written with a separate call to DM_DRAW_STRING_2D().
 */
void
screen_vls(
	int	xbase,
	int	ybase,
	struct bu_vls	*vp)
{
  register char	*start;
  register char	*end;
  register int	y;

  BU_CK_VLS( vp );
  y = ybase;

  DM_SET_FGCOLOR(dmp,
		 color_scheme->cs_edit_info[0],
		 color_scheme->cs_edit_info[1],
		 color_scheme->cs_edit_info[2], 1, 1.0);

  start = bu_vls_addr( vp );
  while( *start != '\0' )  {
    if( (end = strchr( start, '\n' )) == NULL )  return;

    *end = '\0';

    DM_DRAW_STRING_2D(dmp, start,
		      GED2PM1(xbase), GED2PM1(y), 0, 0);
    start = end+1;
    y += TEXT0_DY;
  }
}

/*
 *			D O T I T L E S
 *
 * Produce titles, etc, on the screen.
 * NOTE that this routine depends on being called AFTER dozoom();
 */
void
dotitles(struct bu_vls *overlay_vls)
{
	register int    i;
	register int    x, y;			/* for menu computations */
	static vect_t   temp;
	register int    yloc, xloc;
	int		scroll_ybot;
	struct bu_vls   vls;
	typedef char    c_buf[80];
	auto c_buf      cent_x, cent_y, cent_z, size, ang_x, ang_y, ang_z;
	int             ss_line_not_drawn=1; /* true if the second status line has not been drawn */
	fastf_t		tmp_val;

	if(dbip == DBI_NULL)
	  return;

	bu_vls_init(&vls);
	
	/* Set the Tcl variables to the appropriate values. */

	if (illump != SOLID_NULL) {
	  struct bu_vls path_lhs, path_rhs;

	  bu_vls_init(&path_lhs);
	  bu_vls_init(&path_rhs);
	  for (i = 0; i < ipathpos; i++)
	    bu_vls_printf(&path_lhs, "/%s", DB_FULL_PATH_GET(&illump->s_fullpath,i)->d_namep);
	  for (; i < illump->s_fullpath.fp_len; i++)
	    bu_vls_printf(&path_rhs, "/%s", DB_FULL_PATH_GET(&illump->s_fullpath,i)->d_namep);

	  bu_vls_printf(&vls, "%s(path_lhs)", MGED_DISPLAY_VAR);
	  Tcl_SetVar(interp, bu_vls_addr(&vls), bu_vls_addr(&path_lhs), TCL_GLOBAL_ONLY);
	  bu_vls_trunc(&vls, 0);
	  bu_vls_printf(&vls, "%s(path_rhs)", MGED_DISPLAY_VAR);
	  Tcl_SetVar(interp, bu_vls_addr(&vls), bu_vls_addr(&path_rhs), TCL_GLOBAL_ONLY);
	  bu_vls_free(&path_rhs);
	  bu_vls_free(&path_lhs);
	} else {
	  bu_vls_printf(&vls, "%s(path_lhs)", MGED_DISPLAY_VAR);
	  Tcl_SetVar(interp, bu_vls_addr(&vls), "", TCL_GLOBAL_ONLY);
	  bu_vls_trunc(&vls, 0);
	  bu_vls_printf(&vls, "%s(path_rhs)", MGED_DISPLAY_VAR);
	  Tcl_SetVar(interp, bu_vls_addr(&vls), "", TCL_GLOBAL_ONLY);
	}

	/* take some care here to avoid buffer overrun */
	tmp_val = -view_state->vs_vop->vo_center[MDX]*base2local;
	if( fabs( tmp_val ) < 10e70 ) {
		sprintf(cent_x, "%.3f", tmp_val);
	} else {
		sprintf(cent_x, "%.3g", tmp_val);
	}
	tmp_val = -view_state->vs_vop->vo_center[MDY]*base2local;
	if( fabs( tmp_val ) < 10e70 ) {
		sprintf(cent_y, "%.3f", tmp_val);
	} else {
		sprintf(cent_y, "%.3g", tmp_val);
	}
	tmp_val = -view_state->vs_vop->vo_center[MDZ]*base2local;
	if( fabs( tmp_val ) < 10e70 ) {
		sprintf(cent_z, "%.3f", tmp_val);
	} else {
		sprintf(cent_z, "%.3g", tmp_val);
	}
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "cent=(%s %s %s)", cent_x, cent_y, cent_z);
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_center_name),
		   bu_vls_addr(&vls), TCL_GLOBAL_ONLY);

	tmp_val = view_state->vs_vop->vo_size*base2local;
	if( fabs( tmp_val ) < 10e70 ) {
		sprintf(size, "sz=%.3f", tmp_val);
	} else {
		sprintf(size, "sz=%.3g", tmp_val);
	}
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_size_name),
		    size, TCL_GLOBAL_ONLY);

	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "%s(units)", MGED_DISPLAY_VAR);
	Tcl_SetVar(interp, bu_vls_addr(&vls),
		   (char *)bu_units_string(dbip->dbi_local2base), TCL_GLOBAL_ONLY);

	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "az=%3.2f  el=%3.2f  tw=%3.2f", V3ARGS(view_state->vs_vop->vo_aet));
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_aet_name),
		   bu_vls_addr(&vls), TCL_GLOBAL_ONLY);

	sprintf(ang_x, "%.2f", view_state->vs_rate_rotate[X]);
	sprintf(ang_y, "%.2f", view_state->vs_rate_rotate[Y]);
	sprintf(ang_z, "%.2f", view_state->vs_rate_rotate[Z]);

	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "ang=(%s %s %s)", ang_x, ang_y, ang_z);
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_ang_name),
		   bu_vls_addr(&vls), TCL_GLOBAL_ONLY);

	DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, 0);

	/* Label the vertices of the edited solid */
	if(es_edflag >= 0 || (state == ST_O_EDIT && illump->s_Eflag == 0))  {
		mat_t			xform;
		struct rt_point_labels	pl[8+1];
		point_t lines[2*4];	/* up to 4 lines to draw */
		int num_lines=0;

		if( view_state->vs_vop->vo_perspective <= 0)
		  bn_mat_mul( xform, view_state->vs_model2objview, es_mat );
		else{
		  mat_t tmat;

		  bn_mat_mul( tmat, view_state->vs_model2objview, es_mat );
		  bn_mat_mul( xform, perspective_mat, tmat );
		}

		label_edited_solid( &num_lines, lines,  pl, 8+1, xform, &es_int );

		DM_SET_FGCOLOR(dmp,
			       color_scheme->cs_geo_label[0],
			       color_scheme->cs_geo_label[1],
			       color_scheme->cs_geo_label[2], 1, 1.0);
		for( i=0 ; i<num_lines ; i++ )
			DM_DRAW_LINE_2D( dmp,
			   GED2PM1(((int)(lines[i*2][X]*GED_MAX))),
			   GED2PM1(((int)(lines[i*2][Y]*GED_MAX)) * dmp->dm_aspect),
			   GED2PM1(((int)(lines[i*2+1][X]*GED_MAX))),
			   GED2PM1(((int)(lines[i*2+1][Y]*GED_MAX)) * dmp->dm_aspect) );
		for( i=0; i<8+1; i++ )  {
			if( pl[i].str[0] == '\0' )  break;
			DM_DRAW_STRING_2D( dmp, pl[i].str,
					   GED2PM1(((int)(pl[i].pt[X]*GED_MAX))+15),
					   GED2PM1(((int)(pl[i].pt[Y]*GED_MAX))+15), 0, 1 );
		}
	}

if(mged_variables->mv_faceplate){
	/* Line across the bottom, above two bottom status lines */
	DM_SET_FGCOLOR(dmp,
		       color_scheme->cs_other_line[0],
		       color_scheme->cs_other_line[1],
		       color_scheme->cs_other_line[2], 1, 1.0);
	DM_DRAW_LINE_2D( dmp,
			 GED2PM1(XMIN), GED2PM1(TITLE_YBASE-TEXT1_DY),
			 GED2PM1(XMAX), GED2PM1(TITLE_YBASE-TEXT1_DY) );

	if(mged_variables->mv_orig_gui){
	  /* Enclose window in decorative box.  Mostly for alignment. */
	  DM_DRAW_LINE_2D( dmp,
			   GED2PM1(XMIN), GED2PM1(YMIN),
			   GED2PM1(XMAX), GED2PM1(YMIN) );
	  DM_DRAW_LINE_2D( dmp,
			   GED2PM1(XMAX), GED2PM1(YMIN),
			   GED2PM1(XMAX), GED2PM1(YMAX) );
	  DM_DRAW_LINE_2D( dmp,
			   GED2PM1(XMAX), GED2PM1(YMAX),
			   GED2PM1(XMIN), GED2PM1(YMAX) );
	  DM_DRAW_LINE_2D( dmp,
			   GED2PM1(XMIN), GED2PM1(YMAX),
			   GED2PM1(XMIN), GED2PM1(YMIN) );

	  /* Display scroll bars */
	  scroll_ybot = scroll_display( SCROLLY ); 
	  y = MENUY;
	  x = MENUX;

	  /* Display state and local unit in upper left corner, boxed */
	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_state_text1[0],
			 color_scheme->cs_state_text1[1],
			 color_scheme->cs_state_text1[2], 1, 1.0);
	  DM_DRAW_STRING_2D(dmp, state_str[state],
			    GED2PM1(MENUX), GED2PM1(MENUY - MENU_DY), 1, 0 );
	}else{
	  scroll_ybot = SCROLLY;
	  x = XMIN + 20;
	  y = YMAX+TEXT0_DY;
	}

	/*
	 * Print information about object illuminated
	 */
	if( illump != SOLID_NULL &&
	    (state==ST_O_PATH || state==ST_O_PICK || state==ST_S_PICK) )  {
	  for( i=0; i < illump->s_fullpath.fp_len; i++ )  {
	    if( i == ipathpos  &&  state == ST_O_PATH )  {
	      DM_SET_FGCOLOR(dmp,
			     color_scheme->cs_state_text1[0],
			     color_scheme->cs_state_text1[1],
			     color_scheme->cs_state_text1[2], 1, 1.0);
	      DM_DRAW_STRING_2D( dmp, "[MATRIX]",
				 GED2PM1(x), GED2PM1(y), 0, 0 );
	      y += MENU_DY;
	    }
	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_state_text2[0],
			   color_scheme->cs_state_text2[1],
			   color_scheme->cs_state_text2[2], 1, 1.0);
	    DM_DRAW_STRING_2D( dmp,
			DB_FULL_PATH_GET(&illump->s_fullpath,i)->d_namep,
			GED2PM1(x), GED2PM1(y), 0, 0 );
	    y += MENU_DY;
	  }
	}

	if(mged_variables->mv_orig_gui){
	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_other_line[0],
			 color_scheme->cs_other_line[1],
			 color_scheme->cs_other_line[2], 1, 1.0);
	  DM_DRAW_LINE_2D(dmp,
			  GED2PM1(MENUXLIM), GED2PM1(y),
			  GED2PM1(MENUXLIM), GED2PM1(YMAX));	/* vert. */
	  /*
	   * The top of the menu (if any) begins at the Y value specified.
	   */
	  mmenu_display( y );

	  /* print parameter locations on screen */
	  if( state == ST_O_EDIT && illump->s_Eflag ) {
		/* region is a processed region */
		MAT4X3PNT(temp, view_state->vs_model2objview, es_keypoint);
		xloc = (int)(temp[X]*GED_MAX);
		yloc = (int)(temp[Y]*GED_MAX);
		DM_SET_FGCOLOR(dmp,
			       color_scheme->cs_edit_info[0],
			       color_scheme->cs_edit_info[1],
			       color_scheme->cs_edit_info[2], 1, 1.0);
		DM_DRAW_LINE_2D(dmp,
				GED2PM1(xloc-TEXT0_DY), GED2PM1(yloc+TEXT0_DY),
				GED2PM1(xloc+TEXT0_DY), GED2PM1(yloc-TEXT0_DY));
		DM_DRAW_LINE_2D(dmp,
				GED2PM1(xloc-TEXT0_DY), GED2PM1(yloc-TEXT0_DY),
				GED2PM1(xloc+TEXT0_DY), GED2PM1(yloc+TEXT0_DY));
		DM_DRAW_LINE_2D(dmp,
				GED2PM1(xloc+TEXT0_DY), GED2PM1(yloc+TEXT0_DY),
				GED2PM1(xloc-TEXT0_DY), GED2PM1(yloc+TEXT0_DY));
		DM_DRAW_LINE_2D(dmp,
				GED2PM1(xloc+TEXT0_DY), GED2PM1(yloc-TEXT0_DY),
				GED2PM1(xloc-TEXT0_DY), GED2PM1(yloc-TEXT0_DY));
		DM_DRAW_LINE_2D(dmp,
				GED2PM1(xloc+TEXT0_DY), GED2PM1(yloc+TEXT0_DY),
				GED2PM1(xloc+TEXT0_DY), GED2PM1(yloc-TEXT0_DY));
		DM_DRAW_LINE_2D(dmp,
				GED2PM1(xloc-TEXT0_DY), GED2PM1(yloc+TEXT0_DY),
				GED2PM1(xloc-TEXT0_DY), GED2PM1(yloc-TEXT0_DY));
	      }
	}

	/*
	 * Prepare the numerical display of the currently edited solid/object.
	 */
	/*	create_text_overlay( &vls ); */
	if(mged_variables->mv_orig_gui){
	  screen_vls( SOLID_XBASE, scroll_ybot+TEXT0_DY, overlay_vls );
	}else{
	  screen_vls( x, y, overlay_vls );
	}

	/*
	 * General status information on first status line
	 */
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls,
		      " cent=(%s, %s, %s), %s %s, ", cent_x, cent_y, cent_z,
		      size, bu_units_string(dbip->dbi_local2base));
	bu_vls_printf(&vls, "az=%3.2f el=%3.2f tw=%3.2f ang=(%s, %s, %s)", V3ARGS(view_state->vs_vop->vo_aet),
		      ang_x, ang_y, ang_z);
	DM_SET_FGCOLOR(dmp,
		       color_scheme->cs_status_text1[0],
		       color_scheme->cs_status_text1[1],
		       color_scheme->cs_status_text1[2], 1, 1.0);
	DM_DRAW_STRING_2D( dmp, bu_vls_addr(&vls),
			   GED2PM1(TITLE_XBASE), GED2PM1(TITLE_YBASE), 1, 0 );
} /* if faceplate !0 */

	/*
	 * Second status line
	 */

	/* Priorities for what to display:
	 *	1.  adc info
	 *	2.  keypoint
	 *	3.  illuminated path
	 *
	 * This way the adc info will be displayed during editing
	 */

	if( adc_state->adc_draw ) {
	  fastf_t f;

	  f = view_state->vs_vop->vo_scale * base2local;
	  /* Angle/Distance cursor */
	  bu_vls_trunc(&vls, 0);
	  bu_vls_printf( &vls,
			 " curs:  a1=%.1f,  a2=%.1f,  dst=%.3f,  cent=(%.3f, %.3f),  delta=(%.3f, %.3f)",
			 adc_state->adc_a1, adc_state->adc_a2,
			 adc_state->adc_dst * f,
			 adc_state->adc_pos_grid[X] * f, adc_state->adc_pos_grid[Y] * f,
			 adc_state->adc_pos_view[X] * f, adc_state->adc_pos_view[Y] * f);
		if(mged_variables->mv_faceplate){
		  DM_SET_FGCOLOR(dmp,
				 color_scheme->cs_status_text2[0],
				 color_scheme->cs_status_text2[1],
				 color_scheme->cs_status_text2[2], 1, 1.0);
		  DM_DRAW_STRING_2D( dmp, bu_vls_addr(&vls),
				     GED2PM1(TITLE_XBASE), GED2PM1(TITLE_YBASE + TEXT1_DY), 1, 0 );
		}
		Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_adc_name),
			    bu_vls_addr(&vls), TCL_GLOBAL_ONLY);
		ss_line_not_drawn = 0;
	}else{
	  Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_adc_name), "", TCL_GLOBAL_ONLY);
	}

	if( state == ST_S_EDIT || state == ST_O_EDIT )  {
	  struct bu_vls kp_vls;

	  bu_vls_init(&kp_vls);
	  bu_vls_printf( &kp_vls,
			 " Keypoint: %s %s: (%g, %g, %g)",
			 rt_functab[es_int.idb_type].ft_name+3,	/* Skip ID_ */
			 es_keytag,
			 es_keypoint[X] * base2local,
			 es_keypoint[Y] * base2local,
			 es_keypoint[Z] * base2local);
	  if(mged_variables->mv_faceplate && ss_line_not_drawn){
	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_status_text2[0],
			   color_scheme->cs_status_text2[1],
			   color_scheme->cs_status_text2[2], 1, 1.0);
	    DM_DRAW_STRING_2D( dmp, bu_vls_addr(&kp_vls),
			       GED2PM1(TITLE_XBASE), GED2PM1(TITLE_YBASE + TEXT1_DY), 1, 0 );
	    ss_line_not_drawn = 0;
	  }

	  bu_vls_trunc(&vls, 0);
	  bu_vls_printf(&vls, "%s(keypoint)", MGED_DISPLAY_VAR);
	  Tcl_SetVar(interp, bu_vls_addr(&vls), bu_vls_addr(&kp_vls), TCL_GLOBAL_ONLY);

	  bu_vls_free(&kp_vls);
	}else{
	  bu_vls_trunc(&vls, 0);
	  bu_vls_printf(&vls, "%s(keypoint)", MGED_DISPLAY_VAR);
	  Tcl_SetVar(interp, bu_vls_addr(&vls), "", TCL_GLOBAL_ONLY);
	}

	if( illump != SOLID_NULL )  {
	  if(mged_variables->mv_faceplate && ss_line_not_drawn){
	    bu_vls_trunc(&vls, 0);

	    /* Illuminated path */
	    bu_vls_strcat(&vls, " Path: ");
	    for( i=0; i < illump->s_fullpath.fp_len; i++ )  {
	      if( i == ipathpos  &&
		  (state == ST_O_PATH || state == ST_O_EDIT) )
		bu_vls_strcat( &vls, "/__MATRIX__" );
	      bu_vls_printf(&vls, "/%s",
	    		DB_FULL_PATH_GET(&illump->s_fullpath,i)->d_namep );
	    }
	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_status_text2[0],
			   color_scheme->cs_status_text2[1],
			   color_scheme->cs_status_text2[2], 1, 1.0);
	    DM_DRAW_STRING_2D( dmp, bu_vls_addr(&vls),
			       GED2PM1(TITLE_XBASE), GED2PM1(TITLE_YBASE + TEXT1_DY), 1, 0 );

	    ss_line_not_drawn = 0;
	  }
	}

	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "%.2f fps", 1/frametime );
	if(mged_variables->mv_faceplate && ss_line_not_drawn){
	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_status_text2[0],
			 color_scheme->cs_status_text2[1],
			 color_scheme->cs_status_text2[2], 1, 1.0);
	  DM_DRAW_STRING_2D( dmp, bu_vls_addr(&vls),
			     GED2PM1(TITLE_XBASE), GED2PM1(TITLE_YBASE + TEXT1_DY), 1, 0 );
	}
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_fps_name),
		    bu_vls_addr(&vls), TCL_GLOBAL_ONLY);

	bu_vls_free(&vls);
}
@


11.55
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/titles.c,v 11.54 2004/05/10 15:25:28 morrison Exp $ (BRL)";
@


11.54
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.53 2004/02/02 17:39:35 morrison Exp $ (BRL)";
d26 5
a30 1
#include "conf.h"
@


11.53
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.52 2002/01/10 14:06:35 jra Exp $ (BRL)";
d199 1
a199 1
		 color_scheme->cs_edit_info[2], 1);
d341 1
a341 1
			       color_scheme->cs_geo_label[2], 1);
d361 1
a361 1
		       color_scheme->cs_other_line[2], 1);
d390 1
a390 1
			 color_scheme->cs_state_text1[2], 1);
d409 1
a409 1
			     color_scheme->cs_state_text1[2], 1);
d417 1
a417 1
			   color_scheme->cs_state_text2[2], 1);
d429 1
a429 1
			 color_scheme->cs_other_line[2], 1);
d447 1
a447 1
			       color_scheme->cs_edit_info[2], 1);
d491 1
a491 1
		       color_scheme->cs_status_text1[2], 1);
d524 1
a524 1
				 color_scheme->cs_status_text2[2], 1);
d550 1
a550 1
			   color_scheme->cs_status_text2[2], 1);
d583 1
a583 1
			   color_scheme->cs_status_text2[2], 1);
d597 1
a597 1
			 color_scheme->cs_status_text2[2], 1);
@


11.52
log
@Minor mods to avoid buffer overrun when viewing cube is large
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1985 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.51 2001/06/05 15:51:42 bparker Exp $ (BRL)";
@


11.52.4.1
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.52.6.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/titles.c,v 11.53 2004/02/02 17:39:35 morrison Exp $ (BRL)";
@


11.52.12.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.53 2004/02/02 17:39:35 morrison Exp $ (BRL)";
@


11.52.12.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.52.12.1 2004/02/12 18:34:16 erikg Exp $ (BRL)";
@


11.51
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.50 2001/06/01 19:23:25 bparker Exp $ (BRL)";
d232 1
d266 19
a284 3
	sprintf(cent_x, "%.3f", -view_state->vs_vop->vo_center[MDX]*base2local);
	sprintf(cent_y, "%.3f", -view_state->vs_vop->vo_center[MDY]*base2local);
	sprintf(cent_z, "%.3f", -view_state->vs_vop->vo_center[MDZ]*base2local);
d290 6
a295 1
	sprintf(size, "sz=%.3f", view_state->vs_vop->vo_size*base2local);
@


11.50
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.49 2001/02/01 21:29:28 bparker Exp $ (BRL)";
a264 1
#ifdef MGED_USE_VIEW_OBJ
a283 24
#else
	sprintf(cent_x, "%.3f", -view_state->vs_toViewcenter[MDX]*base2local);
	sprintf(cent_y, "%.3f", -view_state->vs_toViewcenter[MDY]*base2local);
	sprintf(cent_z, "%.3f", -view_state->vs_toViewcenter[MDZ]*base2local);
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "cent=(%s %s %s)", cent_x, cent_y, cent_z);
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_center_name),
		   bu_vls_addr(&vls), TCL_GLOBAL_ONLY);

	sprintf(size, "sz=%.3f", VIEWSIZE*base2local);
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_size_name),
		    size, TCL_GLOBAL_ONLY);

	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "%s(units)", MGED_DISPLAY_VAR);
	Tcl_SetVar(interp, bu_vls_addr(&vls),
		   (char *)bu_units_string(dbip->dbi_local2base), TCL_GLOBAL_ONLY);

	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "az=%3.2f  el=%3.2f  tw=%3.2f",
		      view_state->vs_azimuth,
		      view_state->vs_elevation,
		      view_state->vs_twist);
#endif
d305 1
a305 1
		if( mged_variables->mv_perspective <= 0)
a463 1
#ifdef MGED_USE_VIEW_OBJ
a465 8
#else
	bu_vls_printf(&vls,
		       "az=%3.2f el=%3.2f tw=%3.2f ang=(%s, %s, %s)",
		      view_state->vs_azimuth,
		      view_state->vs_elevation,
		      view_state->vs_twist,
		      ang_x, ang_y, ang_z);
#endif
a488 1
#ifdef MGED_USE_VIEW_OBJ
a489 3
#else
	  f = view_state->vs_Viewscale * base2local;
#endif
@


11.49
log
@*- apply aspect ratio to y component of lines
   returned from label_edited_solid. This fixes
   a bug that shows up while editing bots in a
   non-square window.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.48 2000/10/20 05:04:40 mike Exp $ (BRL)";
d265 21
d308 1
d489 4
d499 1
d523 3
d527 1
@


11.48
log
@
s_path array has been replaced by a s_fullpath "struct db_full_path".
This has eliminated the MAX_PATH restriction in MGED.
member s_last is gone too.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.47 2000/09/07 02:58:52 mike Exp $ (BRL)";
d326 1
a326 1
			   GED2PM1(((int)(lines[i*2][Y]*GED_MAX))),
d328 1
a328 1
			   GED2PM1(((int)(lines[i*2+1][Y]*GED_MAX))) );
@


11.47
log
@
Added externs to ged.h to quiet down lint
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.46 2000/08/19 03:10:49 mike Exp $ (BRL)";
a73 1
	register int	i;
d87 1
a87 1
		dp = illump->s_path[illump->s_last];
d95 1
a95 1
		if(illump->s_last) {
d97 1
a97 4
			for(i=0; i <= illump->s_last; i++) {
				bu_vls_strcat( vp, "/" );
				bu_vls_strcat( vp, illump->s_path[i]->d_namep);
			}
d108 1
a108 4
		for(i=0; i <= illump->s_last; i++) {
			bu_vls_strcat( vp, "/" );
			bu_vls_strcat( vp, illump->s_path[i]->d_namep);
		}
d246 3
a248 3
	    bu_vls_printf(&path_lhs, "/%s", illump->s_path[i]->d_namep);
	  for (; i <= illump->s_last; i++)
	    bu_vls_printf(&path_rhs, "/%s", illump->s_path[i]->d_namep);
d385 1
a385 1
	  for( i=0; i <= illump->s_last; i++ )  {
d399 3
a401 2
	    DM_DRAW_STRING_2D( dmp, illump->s_path[i]->d_namep,
			       GED2PM1(x), GED2PM1(y), 0, 0 );
d558 1
a558 1
	    for( i=0; i <= illump->s_last; i++ )  {
d562 2
a563 1
	      bu_vls_printf(&vls, "/%s", illump->s_path[i]->d_namep);
@


11.46
log
@
const RCSid
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.45 2000/01/06 22:06:55 mike Exp $ (BRL)";
d71 1
a71 2
create_text_overlay( vp )
register struct bu_vls	*vp;
d191 4
a194 4
screen_vls( xbase, ybase, vp )
int	xbase;
int	ybase;
register struct bu_vls	*vp;
d228 1
a228 2
dotitles(overlay_vls)
struct bu_vls *overlay_vls;
@


11.45
log
@
Changed uses of rt_units_* routines to bu_units_*
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.44 1999/12/30 19:16:46 jra Exp $ (BRL)";
@


11.45.2.1
log
@*- apply aspect ratio to y component of lines
   returned from label_edited_solid. This fixes
   a bug that shows up while editing bots in a
   non-square window.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.45 2000/01/06 22:06:55 mike Exp $ (BRL)";
d335 1
a335 1
			   GED2PM1(((int)(lines[i*2][Y]*GED_MAX)) * dmp->dm_aspect),
d337 1
a337 1
			   GED2PM1(((int)(lines[i*2+1][Y]*GED_MAX)) * dmp->dm_aspect) );
@


11.44
log
@Eliminated some unused variables
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.43 1999/12/09 21:18:17 jra Exp $ (BRL)";
d289 1
a289 1
		   (char *)rt_units_string(dbip->dbi_local2base), TCL_GLOBAL_ONLY);
d474 1
a474 1
		      size, rt_units_string(dbip->dbi_local2base));
@


11.43
log
@Fixed drawing of lines for BOT in dotitles()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.42 1999/12/06 20:21:44 jra Exp $ (BRL)";
d234 1
a234 2
	static vect_t   work, work1;		/* work vector */
	static vect_t   temp, temp1;
a235 1
	auto fastf_t	az, el, tw;
@


11.42
log
@
More stuff for BOT editing.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.41 1998/12/29 20:25:36 bparker Exp $ (BRL)";
d336 4
a339 4
			   GED2PM1(((int)(lines[i*2][X]*GED_MAX))+15),
			   GED2PM1(((int)(lines[i*2][Y]*GED_MAX))+15),
			   GED2PM1(((int)(lines[i*2+1][X]*GED_MAX))+15),
			   GED2PM1(((int)(lines[i*2+1][Y]*GED_MAX))+15) );
@


11.41
log
@*- variable name changes
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.40 1998/11/06 22:32:43 bparker Exp $ (BRL)";
d316 2
d328 1
a328 1
		label_edited_solid( pl, 8+1, xform, &es_int );
d334 6
@


11.40
log
@*- use new structures
*- cleanup
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.39 1998/10/21 16:58:10 bparker Exp $ (BRL)";
d281 1
a281 1
	Tcl_SetVar(interp, bu_vls_addr(&view_state->vs_center_name),
d285 1
a285 1
	Tcl_SetVar(interp, bu_vls_addr(&view_state->vs_size_name),
d298 1
a298 1
	Tcl_SetVar(interp, bu_vls_addr(&view_state->vs_aet_name),
d307 1
a307 1
	Tcl_SetVar(interp, bu_vls_addr(&view_state->vs_ang_name),
d515 1
a515 1
		Tcl_SetVar(interp, bu_vls_addr(&view_state->vs_adc_name),
d519 1
a519 1
	  Tcl_SetVar(interp, bu_vls_addr(&view_state->vs_adc_name), "", TCL_GLOBAL_ONLY);
d587 1
a587 1
	Tcl_SetVar(interp, bu_vls_addr(&fps_name),
@


11.39
log
@*- use new color scheme variables
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/titles.c,v 11.38 1998/06/12 19:46:23 bparker Exp $ (BRL)";
d205 3
a207 3
		 color_scheme->fp_edit_info[0],
		 color_scheme->fp_edit_info[1],
		 color_scheme->fp_edit_info[2], 1);
d276 3
a278 3
	sprintf(cent_x, "%.3f", -toViewcenter[MDX]*base2local);
	sprintf(cent_y, "%.3f", -toViewcenter[MDY]*base2local);
	sprintf(cent_z, "%.3f", -toViewcenter[MDZ]*base2local);
d281 1
a281 1
	Tcl_SetVar(interp, bu_vls_addr(&center_name),
d285 1
a285 1
	Tcl_SetVar(interp, bu_vls_addr(&size_name),
d295 4
a298 4
		      curr_dm_list->s_info->azimuth,
		      curr_dm_list->s_info->elevation,
		      curr_dm_list->s_info->twist);
	Tcl_SetVar(interp, bu_vls_addr(&aet_name),
d301 3
a303 3
	sprintf(ang_x, "%.2f", rate_rotate[X]);
	sprintf(ang_y, "%.2f", rate_rotate[Y]);
	sprintf(ang_z, "%.2f", rate_rotate[Z]);
d307 1
a307 1
	Tcl_SetVar(interp, bu_vls_addr(&ang_name),
d310 1
a310 1
	DM_SET_LINE_ATTR(dmp, mged_variables->linewidth, 0);
d317 2
a318 2
		if( mged_variables->perspective <= 0)
		  bn_mat_mul( xform, model2objview, es_mat );
d322 1
a322 1
		  bn_mat_mul( tmat, model2objview, es_mat );
d329 3
a331 3
			       color_scheme->geo_label[0],
			       color_scheme->geo_label[1],
			       color_scheme->geo_label[2], 1);
d335 2
a336 2
					   GED2PM1(((int)(pl[i].pt[X]*2048))+15),
					   GED2PM1(((int)(pl[i].pt[Y]*2048))+15), 0, 1 );
d340 1
a340 1
if(mged_variables->faceplate){
d343 3
a345 3
		       color_scheme->fp_other_line[0],
		       color_scheme->fp_other_line[1],
		       color_scheme->fp_other_line[2], 1);
d350 1
a350 1
	if(mged_variables->orig_gui){
d372 3
a374 3
			 color_scheme->fp_state_text1[0],
			 color_scheme->fp_state_text1[1],
			 color_scheme->fp_state_text1[2], 1);
d391 3
a393 3
			     color_scheme->fp_state_text1[0],
			     color_scheme->fp_state_text1[1],
			     color_scheme->fp_state_text1[2], 1);
d399 3
a401 3
			   color_scheme->fp_state_text2[0],
			   color_scheme->fp_state_text2[1],
			   color_scheme->fp_state_text2[2], 1);
d408 1
a408 1
	if(mged_variables->orig_gui){
d410 3
a412 3
			 color_scheme->fp_other_line[0],
			 color_scheme->fp_other_line[1],
			 color_scheme->fp_other_line[2], 1);
d424 3
a426 3
		MAT4X3PNT(temp, model2objview, es_keypoint);
		xloc = (int)(temp[X]*2048);
		yloc = (int)(temp[Y]*2048);
d428 3
a430 3
			       color_scheme->fp_edit_info[0],
			       color_scheme->fp_edit_info[1],
			       color_scheme->fp_edit_info[2], 1);
d456 1
a456 1
	if(mged_variables->orig_gui){
d471 3
a473 3
		      curr_dm_list->s_info->azimuth,
		      curr_dm_list->s_info->elevation,
		      curr_dm_list->s_info->twist,
d476 3
a478 3
		       color_scheme->fp_status_text1[0],
		       color_scheme->fp_status_text1[1],
		       color_scheme->fp_status_text1[2], 1);
d495 1
a495 1
	if( adc_draw ) {
d498 1
a498 1
	  f = Viewscale * base2local;
d503 5
a507 5
			 adc_a1, adc_a2,
			 adc_dst * f,
			 adc_pos_grid[X] * f, adc_pos_grid[Y] * f,
			 adc_pos_view[X] * f, adc_pos_view[Y] * f);
		if(mged_variables->faceplate){
d509 3
a511 3
				 color_scheme->fp_status_text2[0],
				 color_scheme->fp_status_text2[1],
				 color_scheme->fp_status_text2[2], 1);
d515 1
a515 1
		Tcl_SetVar(interp, bu_vls_addr(&adc_name),
d519 1
a519 1
	  Tcl_SetVar(interp, bu_vls_addr(&adc_name), "", TCL_GLOBAL_ONLY);
d533 1
a533 1
	  if(mged_variables->faceplate && ss_line_not_drawn){
d535 3
a537 3
			   color_scheme->fp_status_text2[0],
			   color_scheme->fp_status_text2[1],
			   color_scheme->fp_status_text2[2], 1);
d555 1
a555 1
	  if(mged_variables->faceplate && ss_line_not_drawn){
d567 3
a569 3
			   color_scheme->fp_status_text2[0],
			   color_scheme->fp_status_text2[1],
			   color_scheme->fp_status_text2[2], 1);
d579 1
a579 1
	if(mged_variables->faceplate && ss_line_not_drawn){
d581 3
a583 3
			 color_scheme->fp_status_text2[0],
			 color_scheme->fp_status_text2[1],
			 color_scheme->fp_status_text2[2], 1);
@


11.38
log
@*- change DM_SET_COLOR to DM_SET_FGCOLOR
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/titles.c,v 11.37 1998/03/19 18:14:18 bparker Exp $ (BRL)";
d204 5
d214 1
a214 11
#if 0
    {
      register char *p;

      /* Some display managers don't handle TABs properly, so
	 we replace any TABs with spaces. */
      for(p = start; *p != '\0'; ++p)
	if(*p == '\t')
	  *p = ' ';
    }
#endif
d328 4
a331 1
		DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d342 4
a345 1
	DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d370 5
a374 6
	  /* Display state and local unit in upper right corner, boxed */
#define YPOS	(MENUY - MENU_DY - 75 )
	  DM_DRAW_LINE_2D(dmp,
			  GED2PM1(MENUXLIM), GED2PM1(YPOS),
			  GED2PM1(MENUXLIM), GED2PM1(YMAX));	/* vert. */
	  DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
a376 1
#undef YPOS
d390 4
a393 1
	      DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d398 4
a401 1
	    DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d409 7
d427 4
a430 1
		DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d463 1
a463 1
	 * General status information on the next to last line
d475 4
a478 1
	DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d508 4
a511 1
		  DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d534 4
a537 1
	    DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d566 4
a569 1
	    DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d580 4
a583 1
	  DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
@


11.37
log
@ADC variables are no longer mged_variables
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.36 1998/03/06 22:35:41 bparker Exp bparker $ (BRL)";
d333 1
a333 1
		DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d344 1
a344 1
	DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d374 1
a374 1
	  DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d391 1
a391 1
	      DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d396 1
a396 1
	    DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d415 1
a415 1
		DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d460 1
a460 1
	DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d490 1
a490 1
		  DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d513 1
a513 1
	    DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d542 1
a542 1
	    DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d553 1
a553 1
	  DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
@


11.36
log
@clean up some old ADC related code
*- use new ADC mged_variables
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.35 1998/02/06 22:08:13 bparker Exp bparker $ (BRL)";
d477 12
a488 21
	if( mged_variables->adcflag ) {
		/* Angle/Distance cursor */
		point_t	pt1, pt2, pt3;
		point_t	center_model;

		VSET(pt1, 
		    (dv_xadc / 2047.0) *Viewscale,
		    (dv_yadc / 2047.0) *Viewscale, 0.0);
		VSET(center_model, 
		    -toViewcenter[MDX], -toViewcenter[MDY],
		    -toViewcenter[MDZ]);
		MAT4X3VEC(pt2, Viewrot, center_model);
		VADD2(pt3, pt1, pt2);
		bu_vls_trunc(&vls, 0);
		bu_vls_printf( &vls,
" curs:  a1=%.1f,  a2=%.1f,  dst=%.3f,  cent=(%.3f, %.3f),  delta=(%.3f, %.3f)",
			mged_variables->adc_a1, mged_variables->adc_a2,
			mged_variables->adc_dst,
			pt3[X]*base2local, pt3[Y]*base2local,
			(dv_xadc / 2047.0) *Viewscale*base2local,
			(dv_yadc / 2047.0) *Viewscale*base2local );
@


11.35
log
@DM_DRAW_STRING_2D and DM_DRAW_STRING_2D now expect x,y values in the range +-1
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.34 1997/11/03 15:22:04 bparker Exp bparker $ (BRL)";
d483 2
a484 2
		    (curs_x / 2047.0) *Viewscale,
		    (curs_y / 2047.0) *Viewscale, 0.0);
d493 2
a494 2
			angle1 * radtodeg, angle2 * radtodeg,
			(c_tdist / 2047.0) *Viewscale*base2local,
d496 2
a497 2
			(curs_x / 2047.0) *Viewscale*base2local,
			(curs_y / 2047.0) *Viewscale*base2local );
@


11.34
log
@use LIBDM macros
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.33 1997/10/08 13:46:38 bparker Exp bparker $ (BRL)";
d220 2
a221 1
    DM_DRAW_STRING_2D(dmp, start, xbase, y, 0, 0);
d337 2
a338 2
				((int)(pl[i].pt[X]*2048))+15,
				((int)(pl[i].pt[Y]*2048))+15, 0, 1 );
d345 3
a347 2
	DM_DRAW_LINE_2D( dmp, XMIN, TITLE_YBASE-TEXT1_DY, XMAX,
			      TITLE_YBASE-TEXT1_DY );
d351 12
a362 4
	  DM_DRAW_LINE_2D( dmp, XMIN, YMIN, XMAX, YMIN );
	  DM_DRAW_LINE_2D( dmp, XMAX, YMIN, XMAX, YMAX );
	  DM_DRAW_LINE_2D( dmp, XMAX, YMAX, XMIN, YMAX );
	  DM_DRAW_LINE_2D( dmp, XMIN, YMAX, XMIN, YMIN );
d371 3
a373 1
	  DM_DRAW_LINE_2D(dmp, MENUXLIM, YPOS, MENUXLIM, YMAX);	/* vert. */
d375 2
a376 1
	  DM_DRAW_STRING_2D(dmp, state_str[state], MENUX, MENUY - MENU_DY, 1, 0 );
d392 2
a393 1
	      DM_DRAW_STRING_2D( dmp, "[MATRIX]", x, y, 0, 0 );
d397 2
a398 1
	    DM_DRAW_STRING_2D( dmp, illump->s_path[i]->d_namep, x, y, 0, 0 );
d416 18
a433 12
		DM_DRAW_LINE_2D(dmp, xloc-TEXT0_DY, yloc+TEXT0_DY, xloc+TEXT0_DY,
				 yloc-TEXT0_DY);
		DM_DRAW_LINE_2D(dmp, xloc-TEXT0_DY, yloc-TEXT0_DY, xloc+TEXT0_DY,
				 yloc+TEXT0_DY);
		DM_DRAW_LINE_2D(dmp, xloc+TEXT0_DY, yloc+TEXT0_DY, xloc-TEXT0_DY,
				 yloc+TEXT0_DY);
		DM_DRAW_LINE_2D(dmp, xloc+TEXT0_DY, yloc-TEXT0_DY, xloc-TEXT0_DY,
				 yloc-TEXT0_DY);
		DM_DRAW_LINE_2D(dmp, xloc+TEXT0_DY, yloc+TEXT0_DY, xloc+TEXT0_DY,
				 yloc-TEXT0_DY);
		DM_DRAW_LINE_2D(dmp, xloc-TEXT0_DY, yloc+TEXT0_DY, xloc-TEXT0_DY,
				 yloc-TEXT0_DY);
d461 2
a462 1
	DM_DRAW_STRING_2D( dmp, bu_vls_addr(&vls), TITLE_XBASE, TITLE_YBASE, 1, 0 );
d500 2
a501 2
		  DM_DRAW_STRING_2D( dmp, bu_vls_addr(&vls), TITLE_XBASE,
					TITLE_YBASE + TEXT1_DY, 1, 0 );
d523 2
a524 2
	    DM_DRAW_STRING_2D( dmp, bu_vls_addr(&kp_vls), TITLE_XBASE,
				  TITLE_YBASE + TEXT1_DY, 1, 0 );
d552 2
a553 2
	    DM_DRAW_STRING_2D( dmp, bu_vls_addr(&vls), TITLE_XBASE,
				  TITLE_YBASE + TEXT1_DY, 1, 0 );
d563 2
a564 2
	  DM_DRAW_STRING_2D( dmp, bu_vls_addr(&vls), TITLE_XBASE,
				TITLE_YBASE + TEXT1_DY, 1, 0 );
@


11.33
log
@mods to use Tcl_SetVar with vls strings
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.32 1997/09/08 18:49:51 bparker Exp bparker $ (BRL)";
d84 1
a84 1
	 * so each line is written with a separate call to dmp->dm_drawString2D().
d189 1
a189 1
 * so each line is written with a separate call to dmp->dm_drawString2D().
d220 1
a220 1
    dmp->dm_drawString2D( dmp, start, xbase, y, 0, 0 );
d314 1
a314 1
	dmp->dm_setLineAttr(dmp, mged_variables->linewidth, 0);
d332 1
a332 1
		dmp->dm_setColor(dmp, DM_YELLOW, 1);
d335 1
a335 1
			dmp->dm_drawString2D( dmp, pl[i].str,
d343 2
a344 2
	dmp->dm_setColor(dmp, DM_YELLOW, 1);
	dmp->dm_drawLine2D( dmp, XMIN, TITLE_YBASE-TEXT1_DY, XMAX,
d349 4
a352 4
	  dmp->dm_drawLine2D( dmp, XMIN, YMIN, XMAX, YMIN );
	  dmp->dm_drawLine2D( dmp, XMAX, YMIN, XMAX, YMAX );
	  dmp->dm_drawLine2D( dmp, XMAX, YMAX, XMIN, YMAX );
	  dmp->dm_drawLine2D( dmp, XMIN, YMAX, XMIN, YMIN );
d361 3
a363 3
	  dmp->dm_drawLine2D(dmp, MENUXLIM, YPOS, MENUXLIM, YMAX);	/* vert. */
	  dmp->dm_setColor(dmp, DM_WHITE, 1);
	  dmp->dm_drawString2D(dmp, state_str[state], MENUX, MENUY - MENU_DY, 1, 0 );
d378 2
a379 2
	      dmp->dm_setColor(dmp, DM_WHITE, 1);
	      dmp->dm_drawString2D( dmp, "[MATRIX]", x, y, 0, 0 );
d382 2
a383 2
	    dmp->dm_setColor(dmp, DM_YELLOW, 1);
	    dmp->dm_drawString2D( dmp, illump->s_path[i]->d_namep, x, y, 0, 0 );
d400 2
a401 2
		dmp->dm_setColor(dmp, DM_YELLOW, 1);
		dmp->dm_drawLine2D(dmp, xloc-TEXT0_DY, yloc+TEXT0_DY, xloc+TEXT0_DY,
d403 1
a403 1
		dmp->dm_drawLine2D(dmp, xloc-TEXT0_DY, yloc-TEXT0_DY, xloc+TEXT0_DY,
d405 1
a405 1
		dmp->dm_drawLine2D(dmp, xloc+TEXT0_DY, yloc+TEXT0_DY, xloc-TEXT0_DY,
d407 1
a407 1
		dmp->dm_drawLine2D(dmp, xloc+TEXT0_DY, yloc-TEXT0_DY, xloc-TEXT0_DY,
d409 1
a409 1
		dmp->dm_drawLine2D(dmp, xloc+TEXT0_DY, yloc+TEXT0_DY, xloc+TEXT0_DY,
d411 1
a411 1
		dmp->dm_drawLine2D(dmp, xloc-TEXT0_DY, yloc+TEXT0_DY, xloc-TEXT0_DY,
d439 2
a440 2
	dmp->dm_setColor(dmp, DM_WHITE, 1);
	dmp->dm_drawString2D( dmp, bu_vls_addr(&vls), TITLE_XBASE, TITLE_YBASE, 1, 0 );
d477 2
a478 2
		  dmp->dm_setColor(dmp, DM_YELLOW, 1);
		  dmp->dm_drawString2D( dmp, bu_vls_addr(&vls), TITLE_XBASE,
d500 2
a501 2
	    dmp->dm_setColor(dmp, DM_YELLOW, 1);
	    dmp->dm_drawString2D( dmp, bu_vls_addr(&kp_vls), TITLE_XBASE,
d529 2
a530 2
	    dmp->dm_setColor(dmp, DM_YELLOW, 1);
	    dmp->dm_drawString2D( dmp, bu_vls_addr(&vls), TITLE_XBASE,
d540 2
a541 2
	  dmp->dm_setColor(dmp, DM_YELLOW, 1);
	  dmp->dm_drawString2D( dmp, bu_vls_addr(&vls), TITLE_XBASE,
@


11.32
log
@mged_variables is now a pointer
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.31 1997/07/31 14:47:06 bparker Exp bparker $ (BRL)";
d256 1
a256 1
	    struct bu_vls path_lhs, path_rhs;
d258 14
a271 12
	    bu_vls_init(&path_lhs);
	    bu_vls_init(&path_rhs);
	    for (i = 0; i < ipathpos; i++)
		bu_vls_printf(&path_lhs, "/%s", illump->s_path[i]->d_namep);
	    for (; i <= illump->s_last; i++)
		bu_vls_printf(&path_rhs, "/%s", illump->s_path[i]->d_namep);
	    Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "path_lhs",
			bu_vls_addr(&path_lhs), TCL_GLOBAL_ONLY);
	    Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "path_rhs",
			bu_vls_addr(&path_rhs), TCL_GLOBAL_ONLY);
	    bu_vls_free(&path_rhs);
	    bu_vls_free(&path_lhs);
d273 5
a277 4
	    Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "path_lhs", "",
			TCL_GLOBAL_ONLY);
	    Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "path_rhs", "",
			TCL_GLOBAL_ONLY);
d283 1
a286 1
	bu_vls_trunc(&vls, 0);
d291 1
d293 3
d297 1
a297 4
	Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "units",
		    (char *)rt_units_string(dbip->dbi_local2base),
		    TCL_GLOBAL_ONLY);

a303 1
	bu_vls_trunc(&vls, 0);
d309 1
a312 7
	bu_vls_trunc(&vls, 0);

#if 0
	Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "adc", "", TCL_GLOBAL_ONLY);
	Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "keypoint", "", TCL_GLOBAL_ONLY);
	Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "fps", "", TCL_GLOBAL_ONLY);
#endif
a313 1
#if 1
a314 3
#else
	dmp->dm_setLineAttr(dmp, 1, 0); /* linewidth - 1, not dashed */
#endif
d429 1
a440 1
	bu_vls_trunc(&vls, 0);
d468 1
a483 1
		bu_vls_trunc(&vls, 0);
d489 22
a510 16
	        bu_vls_printf( &vls,
			" Keypoint: %s %s: (%g, %g, %g)",
			rt_functab[es_int.idb_type].ft_name+3,	/* Skip ID_ */
			es_keytag,
			es_keypoint[X] * base2local,
			es_keypoint[Y] * base2local,
			es_keypoint[Z] * base2local);
		if(mged_variables->faceplate && ss_line_not_drawn){
		  dmp->dm_setColor(dmp, DM_YELLOW, 1);
		  dmp->dm_drawString2D( dmp, bu_vls_addr(&vls), TITLE_XBASE,
					TITLE_YBASE + TEXT1_DY, 1, 0 );
		  ss_line_not_drawn = 0;
		}
		Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "keypoint",
			    bu_vls_addr(&vls), TCL_GLOBAL_ONLY);
		bu_vls_trunc(&vls, 0);
d512 3
a514 1
	  Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "keypoint", "", TCL_GLOBAL_ONLY);
d518 17
a534 15
		if(mged_variables->faceplate && ss_line_not_drawn){
		  /* Illuminated path */
		  bu_vls_strcat(&vls, " Path: ");
		  for( i=0; i <= illump->s_last; i++ )  {
		    if( i == ipathpos  &&
			(state == ST_O_PATH || state == ST_O_EDIT) )
		      bu_vls_strcat( &vls, "/__MATRIX__" );
		    bu_vls_printf(&vls, "/%s", illump->s_path[i]->d_namep);
		  }
		  dmp->dm_setColor(dmp, DM_YELLOW, 1);
		  dmp->dm_drawString2D( dmp, bu_vls_addr(&vls), TITLE_XBASE,
					TITLE_YBASE + TEXT1_DY, 1, 0 );
		  bu_vls_trunc(&vls, 0);
		  ss_line_not_drawn = 0;
		}
d537 1
@


11.31
log
@now setting mged_display(state) in chg_state()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.30 1997/07/25 20:51:42 bparker Exp bparker $ (BRL)";
d318 1
a318 1
	dmp->dm_setLineAttr(dmp, mged_variables.linewidth, 0);
d328 1
a328 1
		if( mged_variables.perspective <= 0)
d348 1
a348 1
if(mged_variables.faceplate){
d354 1
a354 1
	if(mged_variables.orig_gui){
d395 1
a395 1
	if(mged_variables.orig_gui){
d427 1
a427 1
	if(mged_variables.orig_gui){
d462 1
a462 1
	if( mged_variables.adcflag ) {
d482 1
a482 1
		if(mged_variables.faceplate){
d503 1
a503 1
		if(mged_variables.faceplate && ss_line_not_drawn){
d517 1
a517 1
		if(mged_variables.faceplate && ss_line_not_drawn){
d535 1
a535 1
	if(mged_variables.faceplate && ss_line_not_drawn){
@


11.30
log
@mods to use user specified linewidth
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.29 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
a254 2
	Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "state", state_str[state],
		    TCL_GLOBAL_ONLY);
@


11.29
log
@mods to run without a database
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.28 1997/06/25 13:45:21 bparker Exp bparker $ (BRL)";
d319 3
d323 1
@


11.28
log
@*** empty log message ***
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.27 1997/05/29 14:11:12 bparker Exp bparker $ (BRL)";
d247 3
@


11.27
log
@mods to Tcl label variables
,
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.26 1997/04/09 20:34:04 bparker Exp bparker $ (BRL)";
d349 1
a349 1
	if(mged_variables.show_menu){
d390 1
a390 1
	if(mged_variables.show_menu){
d422 1
a422 1
	if(mged_variables.show_menu){
d432 1
a432 1
		      " cent=(%s, %s, %s), sz=%s %s, ", cent_x, cent_y, cent_z,
@


11.26
log
@apply perspective mat to vertex labels
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.25 1997/04/04 19:55:26 bparker Exp bparker $ (BRL)";
d279 1
a279 1
	bu_vls_printf(&vls, "%s %s %s", cent_x, cent_y, cent_z);
d284 1
a284 1
	sprintf(size, "%.3f", VIEWSIZE*base2local);
d293 1
a293 1
	bu_vls_printf(&vls, "Azim: %3.2f  Elev: %3.2f  Twist: %3.2f",
d305 1
a305 1
	bu_vls_printf(&vls, "ang(%s %s %s)", ang_x, ang_y, ang_z);
@


11.25
log
@set ss_line_not_drawn to 0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.24 1997/03/06 21:39:01 bparker Exp bparker $ (BRL)";
d62 1
a64 1

d323 8
a330 1
		bn_mat_mul( xform, model2objview, es_mat );
@


11.24
log
@mods to dotitles
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.23 1997/02/28 21:28:12 bparker Exp bparker $ (BRL)";
d518 1
@


11.23
log
@add support for a few more Tcl variables
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.22 1997/01/30 22:14:19 bparker Exp bparker $ (BRL)";
d246 1
d280 1
a280 1
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->s_info->center_name),
d285 1
a285 1
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->s_info->size_name),
d297 1
a297 1
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->s_info->aet_name),
d306 1
a306 1
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->s_info->ang_name),
d310 1
d314 1
d436 2
a448 1
} /* if faceplate !0 */
d470 6
a475 4
		dmp->dm_setColor(dmp, DM_YELLOW, 1);
		dmp->dm_drawString2D( dmp, bu_vls_addr(&vls), TITLE_XBASE,
			      TITLE_YBASE + TEXT1_DY, 1, 0 );
		Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "adc",
d477 7
a483 1
	} else if( state == ST_S_EDIT || state == ST_O_EDIT )  {
d491 6
a496 3
		dmp->dm_setColor(dmp, DM_YELLOW, 1);
		dmp->dm_drawString2D( dmp, bu_vls_addr(&vls), TITLE_XBASE,
			       TITLE_YBASE + TEXT1_DY, 1, 0 );
d499 19
a517 8
	} else if( illump != SOLID_NULL )  {
		/* Illuminated path */
	        bu_vls_strcat(&vls, " Path: ");
		for( i=0; i <= illump->s_last; i++ )  {
			if( i == ipathpos  &&
			    (state == ST_O_PATH || state == ST_O_EDIT) )
				bu_vls_strcat( &vls, "/__MATRIX__" );
			bu_vls_printf(&vls, "/%s", illump->s_path[i]->d_namep);
d519 7
a525 10
		dmp->dm_setColor(dmp, DM_YELLOW, 1);
		dmp->dm_drawString2D( dmp, bu_vls_addr(&vls), TITLE_XBASE,
			       TITLE_YBASE + TEXT1_DY, 1, 0 );
	} else {
		bu_vls_printf(&vls, "%.2f fps", 1/frametime );
		dmp->dm_setColor(dmp, DM_YELLOW, 1);
		dmp->dm_drawString2D( dmp, bu_vls_addr(&vls), TITLE_XBASE,
			       TITLE_YBASE + TEXT1_DY, 1, 0 );
		Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "fps",
			    bu_vls_addr(&vls), TCL_GLOBAL_ONLY);
d527 2
@


11.22
log
@mods due to changes in dm_drawString2D ---- for use with non-square windows
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.21 1997/01/29 23:14:40 bparker Exp bparker $ (BRL)";
d76 1
d79 1
d129 50
d197 10
a206 21
	register char	*start;
	register char	*end;
	register int	y;

	BU_CK_VLS( vp );
	y = ybase;

	start = bu_vls_addr( vp );
	while( *start != '\0' )  {
		if( (end = strchr( start, '\n' )) == NULL )  return;

		*end = '\0';
#if 1
		{
		  register char *p;

		  /* Some display managers don't handle TABs properly, so
		     we replace any TABs with spaces. */
		  for(p = start; *p != '\0'; ++p)
		    if(*p == '\t')
		      *p = ' ';
d208 11
a218 1
		}
d220 4
a223 4
		dmp->dm_drawString2D( dmp, start, xbase, y, 0, 0 );
		start = end+1;
		y += TEXT0_DY;
	}
d233 2
a234 1
dotitles()
d245 1
a245 2
	auto c_buf      cent_x, cent_y, cent_z, size, azimuth, elevation,
	                twist, ang_x, ang_y, ang_z;
a277 1

d279 2
a280 2
	Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "center", bu_vls_addr(&vls),
		    TCL_GLOBAL_ONLY);
d284 2
a285 1
	Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "size", size, TCL_GLOBAL_ONLY);
d292 7
a298 25
#if 1
	sprintf(azimuth,   "%3.2f", curr_dm_list->s_info->azimuth);
	sprintf(elevation, "%2.2f", curr_dm_list->s_info->elevation);
	sprintf(twist,     "%3.2f", curr_dm_list->s_info->twist);
#else
	/* Find current azimuth, elevation, and twist angles */
	VSET( work , 0 , 0 , 1 );	/* view z-direction */
	MAT4X3VEC( temp , view2model , work );
	VSET( work1 , 1 , 0 , 0 );	/* view x-direction */
	MAT4X3VEC( temp1 , view2model , work1 );

	/* calculate angles using accuracy of 0.005, since display
	 * shows 2 digits right of decimal point */
	bn_aet_vec( &az , &el , &tw , temp , temp1 , (fastf_t)0.005 );

	sprintf(azimuth,   "%3.2f", az);
	sprintf(elevation, "%2.2f", el);
	sprintf(twist,     "%3.2f", tw);
#endif
	
	Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "azimuth", azimuth,
		    TCL_GLOBAL_ONLY);
	Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "elevation", elevation,
		    TCL_GLOBAL_ONLY);
	Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "twist", twist, TCL_GLOBAL_ONLY);
d304 3
a306 3
	bu_vls_printf(&vls, "%s %s %s", ang_x, ang_y, ang_z);
	Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "ang", bu_vls_addr(&vls),
		    TCL_GLOBAL_ONLY);
a323 3
#if 0
		dmp->dm_setColor(dmp, DM_WHITE, 1);
#else
a324 1
#endif
d411 1
a411 2
	create_text_overlay( &vls );

d413 1
a413 1
	  screen_vls( SOLID_XBASE, scroll_ybot+TEXT0_DY, &vls );
d415 1
a415 1
	  screen_vls( x, y, &vls );
a423 1

d425 5
a429 2
		       "az=%s el=%s tw=%s ang=(%s, %s, %s)",
		      azimuth, elevation, twist, ang_x, ang_y, ang_z);
@


11.21
log
@mods to dotitles()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.20 1997/01/29 02:52:22 mike Exp bparker $ (BRL)";
d169 1
a169 1
		dmp->dm_drawString2D( dmp, start, xbase, y, 0, DM_YELLOW );
d300 1
a300 1
				((int)(pl[i].pt[Y]*2048))+15, 0 );
d326 1
a326 1
	  dmp->dm_drawString2D(dmp, state_str[state], MENUX, MENUY - MENU_DY, 1 );
d342 1
a342 1
	      dmp->dm_drawString2D( dmp, "[MATRIX]", x, y, 0 );
d346 1
a346 1
	    dmp->dm_drawString2D( dmp, illump->s_path[i]->d_namep, x, y, 0 );
d401 1
a401 1
	dmp->dm_drawString2D( dmp, bu_vls_addr(&vls), TITLE_XBASE, TITLE_YBASE, 1 );
d438 1
a438 1
			      TITLE_YBASE + TEXT1_DY, 1 );
d451 1
a451 1
			       TITLE_YBASE + TEXT1_DY, 1 );
d465 1
a465 1
			       TITLE_YBASE + TEXT1_DY, 1 );
d470 1
a470 1
			       TITLE_YBASE + TEXT1_DY, 1 );
@


11.20
log
@No longer need db.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.19 1997/01/17 22:56:57 bparker Exp $ (BRL)";
d182 1
a182 2
dotitles(call_dm)
int call_dm;
a279 7
#if 1
	if (!call_dm) {
	    bu_vls_free(&vls);
	    return;
	}
#endif

d304 1
a304 7
#if 0
	if (!call_dm) {
	    bu_vls_free(&vls);
	    return;
	}
#endif

d414 1
@


11.19
log
@checkin for weekend
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.18 1997/01/02 19:35:05 bparker Exp bparker $ (BRL)";
a39 1
#include "db.h"
@


11.18
log
@mods to use libbn and libbu
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.17 1996/11/01 22:20:13 bparker Exp bparker $ (BRL)";
a62 1
extern double			frametime;	/* from ged.c */
@


11.17
log
@use azimuth, elevation, and twist values from s_info structure
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.16 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
a35 2
#include "tcl.h"

d39 1
d95 1
a95 1
		vls_solid( vp, &es_int, rt_identity );
d124 1
a124 1
			mat_mul(new_mat, modelchanges, es_mat);
d257 1
a257 1
	mat_aet_vec( &az , &el , &tw , temp , temp1 , (fastf_t)0.005 );
d297 1
a297 1
		mat_mul( xform, model2objview, es_mat );
@


11.16
log
@hacks to use latest libdm
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.15 1996/09/25 20:10:14 bparker Exp bparker $ (BRL)";
d245 5
d263 1
d302 1
d304 3
@


11.15
log
@include mged_solid.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.14 1996/09/23 18:13:58 bparker Exp bparker $ (BRL)";
d85 1
a85 1
	 * so each line is written with a separate call to dmp->dmr_puts().
d140 1
a140 1
 * so each line is written with a separate call to dmp->dmr_puts().
d172 1
a172 1
		dmp->dmr_puts( dmp, start, xbase, y, 0, DM_YELLOW );
d278 9
d296 1
d299 1
a299 1
			dmp->dmr_puts( dmp, pl[i].str,
d301 1
a301 2
				((int)(pl[i].pt[Y]*2048))+15,
				0, DM_WHITE );
d305 1
d310 1
d313 3
a315 2
	dmp->dmr_2d_line( dmp, XMIN, TITLE_YBASE-TEXT1_DY, XMAX,
			  TITLE_YBASE-TEXT1_DY, 0 );
d319 4
a322 4
	  dmp->dmr_2d_line( dmp, XMIN, YMIN, XMAX, YMIN, 0 );
	  dmp->dmr_2d_line( dmp, XMAX, YMIN, XMAX, YMAX, 0 );
	  dmp->dmr_2d_line( dmp, XMAX, YMAX, XMIN, YMAX, 0 );
	  dmp->dmr_2d_line( dmp, XMIN, YMAX, XMIN, YMIN, 0 );
d331 3
a333 2
	  dmp->dmr_puts(dmp, state_str[state], MENUX, MENUY - MENU_DY, 1, DM_WHITE );
	  dmp->dmr_2d_line(dmp, MENUXLIM, YPOS, MENUXLIM, YMAX, 0);	/* vert. */
d346 10
a355 10
		for( i=0; i <= illump->s_last; i++ )  {
			if( i == ipathpos  &&  state == ST_O_PATH )  {
				dmp->dmr_puts( dmp, "[MATRIX]", x, y, 0,
					       DM_WHITE );
				y += MENU_DY;
			}
			dmp->dmr_puts( dmp, illump->s_path[i]->d_namep, x, y, 0,
				       DM_YELLOW );
			y += MENU_DY;
		}
d370 13
a382 12
		dmp->dmr_2d_line(dmp, xloc-TEXT0_DY, yloc+TEXT0_DY, xloc+TEXT0_DY,
				 yloc-TEXT0_DY, 0);
		dmp->dmr_2d_line(dmp, xloc-TEXT0_DY, yloc-TEXT0_DY, xloc+TEXT0_DY,
				 yloc+TEXT0_DY, 0);
		dmp->dmr_2d_line(dmp, xloc+TEXT0_DY, yloc+TEXT0_DY, xloc-TEXT0_DY,
				 yloc+TEXT0_DY, 0);
		dmp->dmr_2d_line(dmp, xloc+TEXT0_DY, yloc-TEXT0_DY, xloc-TEXT0_DY,
				 yloc-TEXT0_DY, 0);
		dmp->dmr_2d_line(dmp, xloc+TEXT0_DY, yloc+TEXT0_DY, xloc+TEXT0_DY,
				 yloc-TEXT0_DY, 0);
		dmp->dmr_2d_line(dmp, xloc-TEXT0_DY, yloc+TEXT0_DY, xloc-TEXT0_DY,
				 yloc-TEXT0_DY, 0);
d407 2
a408 2
	dmp->dmr_puts( dmp, bu_vls_addr(&vls), TITLE_XBASE, TITLE_YBASE, 1,
		       DM_WHITE );
d442 3
a444 2
		dmp->dmr_puts( dmp, bu_vls_addr(&vls), TITLE_XBASE,
			      TITLE_YBASE + TEXT1_DY, 1, DM_YELLOW );
d455 3
a457 2
		dmp->dmr_puts( dmp, bu_vls_addr(&vls), TITLE_XBASE,
			       TITLE_YBASE + TEXT1_DY, 1, DM_YELLOW );
d469 3
a471 2
		dmp->dmr_puts( dmp, bu_vls_addr(&vls), TITLE_XBASE,
			       TITLE_YBASE + TEXT1_DY, 1, DM_YELLOW );
d474 3
a476 2
		dmp->dmr_puts( dmp, bu_vls_addr(&vls), TITLE_XBASE,
			       TITLE_YBASE + TEXT1_DY, 1, DM_YELLOW );
@


11.14
log
@use LIBDM permanently
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.13 1996/09/17 21:16:26 bparker Exp bparker $ (BRL)";
d46 1
a46 1
#include "./solid.h"
@


11.13
log
@prepare to use libdm
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.12 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d49 1
a49 1
#include "./dm.h"
a171 1
#ifdef USE_LIBDM
a172 3
#else
		dmp->dmr_puts( start, xbase, y, 0, DM_YELLOW );
#endif
a288 1
#ifdef USE_LIBDM
a289 3
#else
			dmp->dmr_puts( pl[i].str,
#endif
a301 1
#ifdef USE_LIBDM
a303 4
#else
	dmp->dmr_2d_line( XMIN, TITLE_YBASE-TEXT1_DY, XMAX,
			  TITLE_YBASE-TEXT1_DY, 0 );
#endif
a306 1
#ifdef USE_LIBDM
a310 6
#else
	  dmp->dmr_2d_line( XMIN, YMIN, XMAX, YMIN, 0 );
	  dmp->dmr_2d_line( XMAX, YMIN, XMAX, YMAX, 0 );
	  dmp->dmr_2d_line( XMAX, YMAX, XMIN, YMAX, 0 );
	  dmp->dmr_2d_line( XMIN, YMAX, XMIN, YMIN, 0 );
#endif
a318 1
#ifdef USE_LIBDM
a320 4
#else
	  dmp->dmr_puts(state_str[state], MENUX, MENUY - MENU_DY, 1, DM_WHITE );
	  dmp->dmr_2d_line(MENUXLIM, YPOS, MENUXLIM, YMAX, 0);	/* vert. */
#endif
a334 1
#ifdef USE_LIBDM
a336 4
#else
				dmp->dmr_puts( "[MATRIX]", x, y, 0,
					       DM_WHITE );
#endif
a338 1
#ifdef USE_LIBDM
a340 4
#else
			dmp->dmr_puts( illump->s_path[i]->d_namep, x, y, 0,
				       DM_YELLOW );
#endif
a356 1
#ifdef USE_LIBDM
a368 14
#else
		dmp->dmr_2d_line(xloc-TEXT0_DY, yloc+TEXT0_DY, xloc+TEXT0_DY,
				 yloc-TEXT0_DY, 0);
		dmp->dmr_2d_line(xloc-TEXT0_DY, yloc-TEXT0_DY, xloc+TEXT0_DY,
				 yloc+TEXT0_DY, 0);
		dmp->dmr_2d_line(xloc+TEXT0_DY, yloc+TEXT0_DY, xloc-TEXT0_DY,
				 yloc+TEXT0_DY, 0);
		dmp->dmr_2d_line(xloc+TEXT0_DY, yloc-TEXT0_DY, xloc-TEXT0_DY,
				 yloc-TEXT0_DY, 0);
		dmp->dmr_2d_line(xloc+TEXT0_DY, yloc+TEXT0_DY, xloc+TEXT0_DY,
				 yloc-TEXT0_DY, 0);
		dmp->dmr_2d_line(xloc-TEXT0_DY, yloc+TEXT0_DY, xloc-TEXT0_DY,
				 yloc-TEXT0_DY, 0);
#endif
a392 1
#ifdef USE_LIBDM
a394 4
#else
	dmp->dmr_puts( bu_vls_addr(&vls), TITLE_XBASE, TITLE_YBASE, 1,
		       DM_WHITE );
#endif
a427 1
#ifdef USE_LIBDM
a429 4
#else
		dmp->dmr_puts( bu_vls_addr(&vls), TITLE_XBASE,
			      TITLE_YBASE + TEXT1_DY, 1, DM_YELLOW );
#endif
a439 1
#ifdef USE_LIBDM
a441 4
#else
		dmp->dmr_puts( bu_vls_addr(&vls), TITLE_XBASE,
			       TITLE_YBASE + TEXT1_DY, 1, DM_YELLOW );
#endif
a452 1
#ifdef USE_LIBDM
a454 4
#else
		dmp->dmr_puts( bu_vls_addr(&vls), TITLE_XBASE,
			       TITLE_YBASE + TEXT1_DY, 1, DM_YELLOW );
#endif
a456 1
#ifdef USE_LIBDM
a458 4
#else
		dmp->dmr_puts( bu_vls_addr(&vls), TITLE_XBASE,
			       TITLE_YBASE + TEXT1_DY, 1, DM_YELLOW );
#endif
@


11.12
log
@rt_list ---> bu_list
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.11 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d172 3
d176 1
d293 3
d297 1
d310 4
d316 1
d320 6
d330 1
d338 5
a342 1

a343 1
#define YPOS	(MENUY - MENU_DY - 75 )
d345 1
d360 4
d366 1
d369 4
d375 1
d392 14
d418 1
d443 4
d449 1
d483 4
d489 1
d500 4
d506 1
d518 4
d524 1
d527 4
d533 1
@


11.11
log
@now using libbu
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.10 1996/06/21 16:07:54 bparker Exp bparker $ (BRL)";
d39 1
@


11.10
log
@*** empty log message ***
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.9 1996/03/01 19:27:11 bparker Exp bparker $ (BRL)";
d74 1
a74 1
register struct rt_vls	*vp;
d79 1
a79 1
	RT_VLS_CHECK(vp);
d91 3
a93 3
		rt_vls_strcat( vp, "** SOLID -- " );
		rt_vls_strcat( vp, dp->d_namep );
		rt_vls_strcat( vp, ": ");
d98 1
a98 1
			rt_vls_strcat( vp, "\n** PATH --  ");
d100 2
a101 2
				rt_vls_strcat( vp, "/" );
				rt_vls_strcat( vp, illump->s_path[i]->d_namep);
d103 1
a103 1
			rt_vls_strcat( vp, ": " );
d112 1
a112 1
		rt_vls_strcat( vp, "** PATH --  ");
d114 2
a115 2
			rt_vls_strcat( vp, "/" );
			rt_vls_strcat( vp, illump->s_path[i]->d_namep);
d117 1
a117 1
		rt_vls_strcat( vp, ": " );
d145 1
a145 1
register struct rt_vls	*vp;
d151 1
a151 1
	RT_VLS_CHECK( vp );
d154 1
a154 1
	start = rt_vls_addr( vp );
d194 1
a194 1
	struct rt_vls   vls;
d199 1
a199 1
	rt_vls_init(&vls);
d206 1
a206 1
	    struct rt_vls path_lhs, path_rhs;
d208 2
a209 2
	    rt_vls_init(&path_lhs);
	    rt_vls_init(&path_rhs);
d211 1
a211 1
		rt_vls_printf(&path_lhs, "/%s", illump->s_path[i]->d_namep);
d213 1
a213 1
		rt_vls_printf(&path_rhs, "/%s", illump->s_path[i]->d_namep);
d215 1
a215 1
			rt_vls_addr(&path_lhs), TCL_GLOBAL_ONLY);
d217 3
a219 3
			rt_vls_addr(&path_rhs), TCL_GLOBAL_ONLY);
	    rt_vls_free(&path_rhs);
	    rt_vls_free(&path_lhs);
d231 2
a232 2
	rt_vls_printf(&vls, "%s %s %s", cent_x, cent_y, cent_z);
	Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "center", rt_vls_addr(&vls),
d234 1
a234 1
	rt_vls_trunc(&vls, 0);
d238 1
a238 1
	rt_vls_trunc(&vls, 0);
d268 2
a269 2
	rt_vls_printf(&vls, "%s %s %s", ang_x, ang_y, ang_z);
	Tcl_SetVar2(interp, MGED_DISPLAY_VAR, "ang", rt_vls_addr(&vls),
d271 1
a271 1
	rt_vls_trunc(&vls, 0);
d296 1
a296 1
	    rt_vls_free(&vls);
d386 1
a386 1
	rt_vls_printf(&vls,
d390 1
a390 1
	rt_vls_printf(&vls,
d393 1
a393 1
	dmp->dmr_puts( rt_vls_addr(&vls), TITLE_XBASE, TITLE_YBASE, 1,
d395 1
a395 1
	rt_vls_trunc(&vls, 0);
d421 1
a421 1
		rt_vls_printf( &vls,
d428 1
a428 1
		dmp->dmr_puts( rt_vls_addr(&vls), TITLE_XBASE,
d431 1
a431 1
			    rt_vls_addr(&vls), TCL_GLOBAL_ONLY);
d433 1
a433 1
	        rt_vls_printf( &vls,
d440 1
a440 1
		dmp->dmr_puts( rt_vls_addr(&vls), TITLE_XBASE,
d443 1
a443 1
			    rt_vls_addr(&vls), TCL_GLOBAL_ONLY);
d446 1
a446 1
	        rt_vls_strcat(&vls, " Path: ");
d450 2
a451 2
				rt_vls_strcat( &vls, "/__MATRIX__" );
			rt_vls_printf(&vls, "/%s", illump->s_path[i]->d_namep);
d453 1
a453 1
		dmp->dmr_puts( rt_vls_addr(&vls), TITLE_XBASE,
d456 2
a457 2
		rt_vls_printf(&vls, "%.2f fps", 1/frametime );
		dmp->dmr_puts( rt_vls_addr(&vls), TITLE_XBASE,
d460 1
a460 1
			    rt_vls_addr(&vls), TCL_GLOBAL_ONLY);
d463 1
a463 1
	rt_vls_free(&vls);
@


11.9
log
@remove unused XMGED stuff
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.8 1996/02/28 21:35:02 bparker Exp bparker $ (BRL)";
d408 1
a408 1
	if( adcflag ) {
@


11.8
log
@remove tabs in screen_vls
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.7 1996/01/17 22:07:40 bparker Exp bparker $ (BRL)";
a61 4

#ifdef XMGED
void    (*dotitles_hook)();
#endif
@


11.7
log
@now using mged_variable.show_menu instead of
ignore_scroll_and_menu
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.6 1995/12/04 22:07:45 bparker Exp bparker $ (BRL)";
d163 12
@


11.6
log
@Using ignore_scroll_and_menu to ignore the old menus and
scrollbars depending on the preference of the display
manager.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.5 1995/12/02 00:19:07 bparker Exp bparker $ (BRL)";
a49 3
/* Used to ignore the old scrollbars and menus */
int ignore_scroll_and_menu = 0;

d296 1
a296 1
	if(!ignore_scroll_and_menu){
d337 1
a337 1
	if(!ignore_scroll_and_menu){
d369 1
a369 1
	if(!ignore_scroll_and_menu){
@


11.5
log
@shut off old menus and shift other info at top over.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.4 1995/12/01 23:03:40 bparker Exp bparker $ (BRL)";
d50 3
a294 15
#if USE_OLD_MENUS	
#ifdef XMGED
	if(dotitles_hook){
	    (*dotitles_hook)();
	    rt_vls_free(&vls);
	    return;
	}
#endif
	/* Enclose window in decorative box.  Mostly for alignment. */
	dmp->dmr_2d_line( XMIN, YMIN, XMAX, YMIN, 0 );
	dmp->dmr_2d_line( XMAX, YMIN, XMAX, YMAX, 0 );
	dmp->dmr_2d_line( XMAX, YMAX, XMIN, YMAX, 0 );
	dmp->dmr_2d_line( XMIN, YMAX, XMIN, YMIN, 0 );
#endif

d299 11
a309 5
#if USE_OLD_MENUS
	/* Display scroll bars */
	scroll_ybot = scroll_display( SCROLLY ); 
	y = MENUY;
	x = MENUX;
d311 1
a311 1
	/* Display state and local unit in upper right corner, boxed */
d313 1
a313 1
	dmp->dmr_puts(state_str[state], MENUX, MENUY - MENU_DY, 1, DM_WHITE );
d315 1
a315 1
	dmp->dmr_2d_line(MENUXLIM, YPOS, MENUXLIM, YMAX, 0);	/* vert. */
d317 5
a321 5
#else
	scroll_ybot = SCROLLY;
	x = XMIN + 20;
	y = YMAX+TEXT0_DY;
#endif
d340 5
a344 5
#if USE_OLD_MENUS
	/*
	 * The top of the menu (if any) begins at the Y value specified.
	 */
	mmenu_display( y );
d346 2
a347 2
	/* print parameter locations on screen */
	if( state == ST_O_EDIT && illump->s_Eflag ) {
d364 1
a365 1
#endif
d372 5
a376 5
#if USE_OLD_MENUS
	screen_vls( SOLID_XBASE, scroll_ybot+TEXT0_DY, &vls );
#else
	screen_vls( x, y, &vls );
#endif
@


11.4
log
@changed dotitles so that it will label the vertices while in
solid edit whether the faceplate is on or not
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.3 1995/08/03 21:49:25 gdurf Exp bparker $ (BRL)";
d24 2
d180 1
a180 1
	register int    y;			/* for menu computations */
d291 2
a292 1
	
d305 1
d311 1
d315 1
d323 5
d336 1
a336 1
				dmp->dmr_puts( "[MATRIX]", MENUX, y, 0,
d340 1
a340 1
			dmp->dmr_puts( illump->s_path[i]->d_namep, MENUX, y, 0,
d346 1
d371 1
d377 2
d380 3
@


11.3
log
@dotitles() now sets Tcl variables for each label
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 11.2 1995/01/17 13:05:09 bparker Exp gdurf $ (BRL)";
d267 18
a357 18
	}

	/* Label the vertices of the edited solid */
	if(es_edflag >= 0 || (state == ST_O_EDIT && illump->s_Eflag == 0))  {
		mat_t			xform;
		struct rt_point_labels	pl[8+1];

		mat_mul( xform, model2objview, es_mat );

		label_edited_solid( pl, 8+1, xform, &es_int );

		for( i=0; i<8+1; i++ )  {
			if( pl[i].str[0] == '\0' )  break;
			dmp->dmr_puts( pl[i].str,
				((int)(pl[i].pt[X]*2048))+15,
				((int)(pl[i].pt[Y]*2048))+15,
				0, DM_WHITE );
		}
@


11.2
log
@merging xmged sources
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/titles.c,v 11.2 95/01/17 11:44:31 bparker Exp $ (BRL)";
d33 3
d45 1
d174 2
a175 1
dotitles()
d177 6
a182 9
	register int i;
	register char	*cp;		/* char pointer - for sprintf() */
	register int y;			/* for menu computations */
	static vect_t work,work1;		/* work vector */
	static vect_t temp,temp1;
	register int yloc, xloc;
	auto fastf_t	az, el, twist;
	auto char linebuf[512];
	struct rt_vls	vls;
d184 59
d244 28
d274 3
a276 3
	  (*dotitles_hook)();

	  return;
a278 3

	RT_VLS_INIT( &vls );

d286 2
a287 1
	dmp->dmr_2d_line( XMIN, TITLE_YBASE-TEXT1_DY, XMAX, TITLE_YBASE-TEXT1_DY, 0 );
d294 1
d307 2
a308 1
				dmp->dmr_puts( "[MATRIX]", MENUX, y, 0, DM_WHITE );
d311 2
a312 1
			dmp->dmr_puts( illump->s_path[i]->d_namep, MENUX, y, 0, DM_YELLOW );
d328 12
a339 6
		dmp->dmr_2d_line(xloc-TEXT0_DY, yloc+TEXT0_DY, xloc+TEXT0_DY, yloc-TEXT0_DY, 0);
		dmp->dmr_2d_line(xloc-TEXT0_DY, yloc-TEXT0_DY, xloc+TEXT0_DY, yloc+TEXT0_DY, 0);
		dmp->dmr_2d_line(xloc+TEXT0_DY, yloc+TEXT0_DY, xloc-TEXT0_DY, yloc+TEXT0_DY, 0);
		dmp->dmr_2d_line(xloc+TEXT0_DY, yloc-TEXT0_DY, xloc-TEXT0_DY, yloc-TEXT0_DY, 0);
		dmp->dmr_2d_line(xloc+TEXT0_DY, yloc+TEXT0_DY, xloc+TEXT0_DY, yloc-TEXT0_DY, 0);
		dmp->dmr_2d_line(xloc-TEXT0_DY, yloc+TEXT0_DY, xloc-TEXT0_DY, yloc-TEXT0_DY, 0);
a364 1
	rt_vls_free( &vls );
d369 10
a378 29
	(void)sprintf( &linebuf[0],
		" cent=(%.3f, %.3f, %.3f), sz=%.3f %s, ",
		-toViewcenter[MDX]*base2local,
		-toViewcenter[MDY]*base2local,
		-toViewcenter[MDZ]*base2local,
		VIEWSIZE*base2local,
		rt_units_string(dbip->dbi_local2base) );

	cp = &linebuf[0];
#define FINDNULL(p)	while(*p++); p--;	/* leaves p at NULL */
	FINDNULL(cp);

	/* Find current azimuth, elevation, and twist angles */
	VSET( work , 0 , 0 , 1 );	/* view z-direction */
	MAT4X3VEC( temp , view2model , work );
	VSET( work1 , 1 , 0 , 0 );	/* view x-direction */
	MAT4X3VEC( temp1 , view2model , work1 );

	/* calculate angles using accuracy of 0.005, since display
	 * shows 2 digits right of decimal point */
	mat_aet_vec( &az , &el , &twist , temp , temp1 , (fastf_t)0.005 );

	(void)sprintf( cp, "az=%3.2f el=%2.2f tw=%3.2f ang=(%.2f, %.2f, %.2f)",
		az, el, twist,
		rate_rotate[X],
		rate_rotate[Y],
		rate_rotate[Z] );
	dmp->dmr_puts( &linebuf[0], TITLE_XBASE, TITLE_YBASE, 1, DM_WHITE );

d404 1
a404 1
		(void)sprintf( &linebuf[0],
d411 4
a414 1
		dmp->dmr_puts( &linebuf[0], TITLE_XBASE, TITLE_YBASE + TEXT1_DY, 1, DM_YELLOW );
d416 2
a417 2
		(void)sprintf( &linebuf[0],
			" Keypoint: %s %s: (%g, %g, %g)\n",
d423 4
a426 1
		dmp->dmr_puts( &linebuf[0], TITLE_XBASE, TITLE_YBASE + TEXT1_DY, 1, DM_YELLOW );
d429 1
a429 1
		(void)sprintf( linebuf, " Path: ");
d433 2
a434 4
				(void)strcat( &linebuf[0], "/__MATRIX__" );
			cp = &linebuf[0];
			FINDNULL(cp);
			(void)sprintf(cp, "/%s", illump->s_path[i]->d_namep );
d436 2
a437 1
		dmp->dmr_puts( &linebuf[0], TITLE_XBASE, TITLE_YBASE + TEXT1_DY, 1, DM_YELLOW );
d439 5
a443 2
		(void)sprintf( linebuf, "%.2f fps", 1/frametime );
		dmp->dmr_puts( &linebuf[0], TITLE_XBASE, TITLE_YBASE + TEXT1_DY, 1, DM_YELLOW );
d445 2
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.20 95/01/03 14:32:29 gdurf Exp $ (BRL)";
d57 4
d182 8
@


10.20
log
@*** empty log message ***
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.19 94/12/27 18:06:24 mike Exp Locker: gdurf $ (BRL)";
@


10.19
log
@Eliminated use of dv_xjoy
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.18 94/11/05 03:47:40 mike Exp Locker: mike $ (BRL)";
@


10.18
log
@Irix 6
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.17 94/10/18 14:04:23 jra Exp Locker: mike $ (BRL)";
d286 3
a288 3
		dm_values.dv_xjoy * 6,
		dm_values.dv_yjoy * 6,
		dm_values.dv_zjoy * 6 );
@


10.17
log
@Changed "twist" to "tw" on display line.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.16 94/10/18 11:23:24 jra Exp Locker: jra $ (BRL)";
a69 1
	auto char linebuf[512];
a172 1
	mat_t new_mat,temp_mat1,temp_mat2;
a173 1
	register float y_val;
@


10.16
log
@Added accuracy argument to mat_aet_vec.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.15 94/10/18 08:39:57 jra Exp $ (BRL)";
d287 1
a287 1
	(void)sprintf( cp, "az=%3.2f el=%2.2f twist=%3.2f ang=(%.2f, %.2f, %.2f)",
@


10.15
log
@Modified dotitiles to display azimuth, elevation, and twist.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.14 94/10/12 13:19:20 jra Exp Locker: jra $ (BRL)";
d282 4
a285 1
	mat_aet_vec( &az , &el , &twist , temp , temp1 );
@


10.14
log
@Improved the dotitles routine further to produce a better az,el.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.13 94/10/11 12:33:44 jra Exp Locker: jra $ (BRL)";
d172 2
a173 2
	static vect_t work;		/* work vector */
	static vect_t temp;
d177 1
a177 1
	auto fastf_t	az, el;
d277 6
a282 1
	/* Find current azimuth and elevation angles */
d284 2
a285 29
	/* Get elevation angle first directly from Viewrot */
	el = mat_atan2( -Viewrot[6] , Viewrot[10] ) * radtodeg;

	/* create a matrix to reverse the elevation angle */
	mat_idn( temp_mat1 );
	buildHrot( temp_mat1 , -el , 0.0 , 0.0 );

	/* apply this matrix to Viewrot to get a matrix that contains
	 * just the azimuth rotation
	 */
	mat_mul( temp_mat2 , temp_mat1 , Viewrot );

	/* get the azimuth rotation from the final matrix
	 * and adjust for the fact that 0,0 (az,el) is different from
	 * an identity Viewrot.
	 */
	az = (-90.0) - mat_atan2( temp_mat2[4] , temp_mat2[5] ) * radtodeg;
	if( az < (-180.0) )
		az += 360.0;
	else if( az > 180.0 )
		az -= 360.0;
	el += 90.0;
	if( el < (-180.0) )
		el += 360.0;
	else if( el > 180 )
		el -= 360.0;

	(void)sprintf( cp, "az=%3.2f el=%2.2f ang=(%.2f, %.2f, %.2f)",
		az, el,
@


10.13
log
@Modified dotitles to calculate azimuth for elevations of +/- 90.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.12 94/09/01 14:43:42 jra Exp $ (BRL)";
d174 1
a174 1
	mat_t new_mat;
d276 29
a304 21
	/* az/el 0,0 is when screen +Z is model +X */
	VSET( work, 0, 0, 1 );
	MAT3X3VEC( temp, view2model, work );
	if( NEAR_ZERO( VDOT( work , temp ) - 1.0 , SQRT_SMALL_FASTF ) )
	{
		/* elevation is 90, find azimuth */
		VSET( work , 1 , 0 , 0 );
		MAT3X3VEC( temp , view2model , work );
		el = 90;
		az = mat_atan2( -temp[X] , temp[Y] ) * radtodeg;
	}
	else if( NEAR_ZERO( VDOT( work , temp ) + 1.0 , SQRT_SMALL_FASTF ) )
	{
		/* elevation is -90, find azimuth */
		VSET( work , 1 , 0 , 0 );
		MAT3X3VEC( temp , view2model , work );
		el = (-90);
		az = mat_atan2( -temp[X] , temp[Y] ) * radtodeg;
	}
	else
		ae_vec( &az, &el, temp );
@


10.12
log
@Keypoint output in local units.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.11 94/08/09 18:43:42 gdurf Exp Locker: jra $ (BRL)";
d279 19
a297 1
	ae_vec( &az, &el, temp );
@


10.11
log
@Factored ifdefs
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.10 1992/06/09 14:23:15 mike Exp gdurf $ (BRL)";
d325 3
a327 1
			V3ARGS(es_keypoint) );
@


10.10
log
@Added ST_S_VPICK
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.9 92/04/03 05:04:05 mike Exp Locker: mike $ (BRL)";
d24 2
d28 3
a30 1
#ifdef BSD
a31 2
#else
#include <string.h>
@


10.9
log
@Added frames/sec display
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.8 92/02/14 16:28:56 mmark Exp Locker: mike $ (BRL)";
d51 1
@


10.8
log
@Fixed bug with text y offset
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.7 92/02/14 15:04:34 mike Exp Locker: mmark $ (BRL)";
d54 1
d335 3
@


10.7
log
@Scroll bars move solid edit text down.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.6 92/02/05 23:12:51 mike Exp Locker: mike $ (BRL)";
d255 1
a255 1
	screen_vls( SOLID_XBASE, SOLID_YBASE+scroll_ybot, &vls );
@


10.6
log
@Calling sequence to vls_solid() changed.
More es_keypoint stuff.
Moved oedit_accept() and oedit_reject() from buttons.c to edsol.c
for better coupling to the editing support
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.5 92/02/05 13:29:10 mike Exp Locker: mike $ (BRL)";
d176 1
d190 1
a190 1
	y = scroll_display( SCROLLY ); 
d255 1
a255 1
	screen_vls( SOLID_XBASE, SOLID_YBASE, &vls );
@


10.5
log
@Moved labeling to edsol.c
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.4 92/02/05 13:25:05 mike Exp Locker: mike $ (BRL)";
d67 1
d80 2
d83 1
a83 1
		rt_vls_strcat( vp, es_name );
d86 1
a86 1
		vls_solid( vp, &es_rec.s, rt_identity );
d97 1
a97 1
			vls_solid( vp, &es_rec.s, es_mat );
d111 1
a111 1
		if( state == ST_O_EDIT && illump->s_Eflag == 0 ) {
d117 1
a117 1
			vls_solid( vp, &es_rec.s, new_mat );
a118 12

		if( state == ST_O_EDIT && illump->s_Eflag ) {
			point_t	work;
			/* region has been evaluated */
			/* XXX should have an es_keypoint for this */
			MAT4X3PNT(work, modelchanges, es_rec.s.s_values);
			(void)sprintf( &linebuf[0],
				"CENTER : %.4f %.4f %.4f\n",
				work[0]*base2local, work[1]*base2local, work[2]*base2local );
			rt_vls_strcat( vp, &linebuf[0] );
		}

d221 1
a221 2
		/* XXX should have an es_keypoint for this ??? */
		MAT4X3PNT(temp, model2objview, es_rec.s.s_values);
d288 2
a289 2
	 *	2.  illuminated path
	 *	3.  title
d315 8
a322 2
	}
	else if( illump != SOLID_NULL )  {
@


10.4
log
@moved rt_point_labels definition into raytrace.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.3 91/12/18 07:55:39 mike Exp Locker: mike $ (BRL)";
a338 107
}

/*
 *			L A B E L _ E D I T E D _ S O L I D
 *
 *  Put labels on the vertices of the currently edited solid.
 *  XXX This really should use import/export interface!!!  Or be part of it.
 */
label_edited_solid( pl, max_pl, xform, ip )
struct rt_point_labels	pl[];
int			max_pl;
CONST mat_t		xform;
struct rt_db_internal	*ip;
{
	register int	i;
	union record	temp_rec;	/* copy of es_rec record */
	point_t		work;
	point_t		pos_view;
	int		npl = 0;

	RT_CK_DB_INTERNAL( ip );

	switch( ip->idb_type )  {

#define	POINT_LABEL( _pt, _char )	{ \
	VMOVE( pl[npl].pt, _pt ); \
	pl[npl].str[0] = _char; \
	pl[npl++].str[1] = '\0'; }

	case ID_ARB8:
		MAT4X3PNT( pos_view, xform, es_rec.s.s_values );
		POINT_LABEL( pos_view, '1' );
		temp_rec.s = es_rec.s;
		if(es_type == ARB4) {
			VMOVE(&temp_rec.s.s_values[9], &temp_rec.s.s_values[12]);
		}
		if(es_type == ARB6) {
			VMOVE(&temp_rec.s.s_values[15], &temp_rec.s.s_values[18]);
		}
		for(i=1; i<es_type; i++) {
			VADD2( work, es_rec.s.s_values, &temp_rec.s.s_values[i*3] );
			MAT4X3PNT(pos_view, xform, work);
			POINT_LABEL( pos_view, i + '1' );
		}
		break;
	case ID_TGC:
		MAT4X3PNT( pos_view, xform, &es_rec.s.s_tgc_V );
		POINT_LABEL( pos_view, 'V' );

		VADD2( work, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_A );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'A' );

		VADD2( work, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_B );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'B' );

		VADD3( work, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_H, &es_rec.s.s_tgc_C );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'C' );

		VADD3( work, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_H, &es_rec.s.s_tgc_D );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'D' );
		break;

	case ID_ELL:
		MAT4X3PNT( pos_view, xform, &es_rec.s.s_ell_V );
		POINT_LABEL( pos_view, 'V' );

		VADD2( work, &es_rec.s.s_ell_V, &es_rec.s.s_ell_A );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'A' );

		VADD2( work, &es_rec.s.s_ell_V, &es_rec.s.s_ell_B );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'B' );

		VADD2( work, &es_rec.s.s_ell_V, &es_rec.s.s_ell_C );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'C' );
		break;

	case ID_TOR:
		MAT4X3PNT( pos_view, xform, &es_rec.s.s_tor_V );
		POINT_LABEL( pos_view, 'V' );

		VADD2( work, &es_rec.s.s_tor_V, &es_rec.s.s_tor_C );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'I' );

		VADD2( work, &es_rec.s.s_tor_V, &es_rec.s.s_tor_E );
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'O' );

		VADD3( work, &es_rec.s.s_tor_V, &es_rec.s.s_tor_A, &es_rec.s.s_tor_H);
		MAT4X3PNT(pos_view, xform, work);
		POINT_LABEL( pos_view, 'H' );
		break;

	case ID_ARS:
		MAT4X3PNT(pos_view, xform, es_rec.s.s_values);
		POINT_LABEL( pos_view, 'V' );
		break;
	}

	pl[npl].str[0] = '\0';	/* Mark ending */
@


10.3
log
@Eliminated pr_solid() in favor of newer interface.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.2 91/12/18 04:12:20 mike Exp Locker: mike $ (BRL)";
a55 4
struct point_labels {
	char	str[8];
	point_t	pt;
};
d245 1
a245 1
		struct point_labels	pl[8+1];
d348 1
a348 1
struct point_labels	pl[];
@


10.2
log
@Modified towards using import/export interface for labeling solids.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 10.1 91/10/12 06:44:21 mike Rel4_0 Locker: mike $ (BRL)";
d26 5
d62 108
a182 1
	union record temp_rec;		/* copy of es_rec record */
d188 1
d190 2
d265 1
a265 3
	 * Set up for character output.  For the best generality, we
	 * don't assume that the display can process a CRLF sequence,
	 * so each line is written with a separate call to dmp->dmr_puts().
d267 3
a270 122
#define FINDNULL(p)	while(*p++); p--;	/* leaves p at NULL */
	/* print solid info at top of screen */
	if( es_edflag >= 0 ) {
		(void)sprintf(&linebuf[0], "** SOLID -- %s:", es_name);
		dmp->dmr_puts(	&linebuf[0],
				SOLID_XBASE,
				SOLID_YBASE,
				1,
				DM_YELLOW);
		for( i=0; i<es_nlines; i++ )  {
			dmp->dmr_puts( &es_display[i*ES_LINELEN],
				SOLID_XBASE,
				SOLID_YBASE+TEXT1_DY+(TEXT0_DY*i),
				0,
				DM_YELLOW );
		}

		if(illump->s_last) {
			(void)sprintf(&linebuf[0], "** PATH --  ");
			for(i=0; i <= illump->s_last; i++) {
				cp = &linebuf[0];
				FINDNULL( cp );
				(void)sprintf(cp,"/%s",illump->s_path[i]->d_namep);
			}
			cp = &linebuf[0];
			FINDNULL( cp );
			(void)sprintf(cp,":");
			
			/* This breaks on the 4D compilers if done
			 * as part of the procedure call 
			 * also if its a int so   (sigh....)
			 */
			y_val = (float) ((es_nlines + 2) *(TEXT0_DY))
	                               + SOLID_YBASE + TEXT1_DY;

			dmp->dmr_puts(	&linebuf[0],
					SOLID_XBASE,
					y_val,
					1,
					DM_RED);
			/* print the evaluated (path) solid parameters */
			temp_rec.s = es_rec.s;		/* struct copy */
			MAT4X3PNT( &temp_rec.s.s_values[0], es_mat,
					&es_rec.s.s_values[0] );
			for(i=1; i<8; i++) {
				MAT4X3VEC( &temp_rec.s.s_values[i*3], es_mat,
						&es_rec.s.s_values[i*3] );
			}

			y_val = (float) SOLID_YBASE+(2*TEXT1_DY)+(TEXT0_DY*(es_nlines+2));
			pr_solid( &temp_rec.s );

			for(i=0; i<es_nlines; i++) {
				yloc = (int) y_val + (TEXT0_DY*i);
				dmp->dmr_puts(	&es_display[i*ES_LINELEN],
						SOLID_XBASE,
						yloc,
						0,
						DM_RED );
			}
			pr_solid( &es_rec.s );

		}
	}

	/* display path info for object editing also */
	if( state == ST_O_EDIT ) {
		(void)sprintf(&linebuf[0], "** PATH --  ");
		for(i=0; i <= illump->s_last; i++) {
			cp = &linebuf[0];
			FINDNULL( cp );
			(void)sprintf(cp,"/%s",illump->s_path[i]->d_namep);
		}
		cp = &linebuf[0];
		FINDNULL( cp );
		(void)sprintf(cp,":");

		dmp->dmr_puts(	&linebuf[0],
				SOLID_XBASE,
				SOLID_YBASE,
				1,
				DM_RED);

		/* print the evaluated (path) solid parameters */
		if( state == ST_O_EDIT && illump->s_Eflag == 0 ) {
			/* NOT an evaluated region */
			/* object edit option selected */
			temp_rec.s = es_rec.s;		/* struct copy */
			mat_mul(new_mat, modelchanges, es_mat);
			MAT4X3PNT( temp_rec.s.s_values, new_mat, es_rec.s.s_values );
			for(i=1; i<8; i++) {
				MAT4X3VEC( &temp_rec.s.s_values[i*3], new_mat, &es_rec.s.s_values[i*3] );
			}

			pr_solid( &temp_rec.s );

			for(i=0; i<es_nlines; i++) {
				dmp->dmr_puts(	&es_display[i*ES_LINELEN],
						SOLID_XBASE,
						SOLID_YBASE+TEXT1_DY+(TEXT0_DY*i),
						0,
						DM_RED );
			}
			pr_solid( &es_rec.s );
		}

		if( state == ST_O_EDIT && illump->s_Eflag ) {
			/* region has been evaluated */
			/* XXX should have an es_keypoint for this */
			MAT4X3PNT(work, modelchanges, es_rec.s.s_values);
			(void)sprintf( &linebuf[0],
					"CENTER : %.4f %.4f %.4f",
					work[0]*base2local, work[1]*base2local, work[2]*base2local );
			dmp->dmr_puts( &linebuf[0],
					SOLID_XBASE,
					SOLID_YBASE+TEXT1_DY+TEXT0_DY,
					1,
					DM_RED );
		}

	}

d283 1
d349 1
a349 1
 *  XXX This really should use import/export interface!!!
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 9.10 91/09/20 19:35:29 butler Exp $ (BRL)";
d49 7
d132 3
a134 2
	if(es_edflag >= 0 || (state == ST_O_EDIT && illump->s_Eflag == 0))
		label_edited_solid();
d136 13
d356 5
a360 1
label_edited_solid()
a364 1
	point_t		temp;
d366 1
a366 2
	mat_t		xform;		/* model2objview * es_mat */
	char		kvt[4];		/* Used to change chars to strings */
d368 1
a368 1
	mat_mul( xform, model2objview, es_mat );
d370 1
a370 1
	switch( es_gentype )  {
d372 6
a377 1
	case GENARB8:
d379 1
a379 1
		dmp->dmr_puts( "1", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d390 1
a390 3
			kvt[0] = i + '1';
			kvt[1] = '\0';
			dmp->dmr_puts( kvt, ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d393 4
a396 1
	case GENTGC:
d399 1
a399 1
		dmp->dmr_puts( "A", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d403 1
a403 1
		dmp->dmr_puts( "B", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d407 1
a407 1
		dmp->dmr_puts( "C", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d411 1
a411 1
		dmp->dmr_puts( "D", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d414 4
a417 1
	case GENELL:
d420 1
a420 1
		dmp->dmr_puts( "A", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d424 1
a424 1
		dmp->dmr_puts( "B", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d428 1
a428 1
		dmp->dmr_puts( "C", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d431 4
a434 1
	case TOR:
d437 1
a437 1
		dmp->dmr_puts( "I", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d441 1
a441 1
		dmp->dmr_puts( "O", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d445 1
a445 1
		dmp->dmr_puts( "H", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d448 1
a448 2
	case ARS:
	case ARSCONT:
d450 1
a450 1
		dmp->dmr_puts( "V", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d453 2
@


9.10
log
@The "cent=" readout for the adc was previously changed from a screen
RELATIVE to a model ABSOLUTE coordinate system.  Users complained.  The
RELATIVE coordinate of the adc is now reported as a "delta=" field.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 9.9 91/08/30 18:33:39 mike Exp $ (BRL)";
@


9.9
log
@This minor mod fixes bypasses the Stardent compiler bug which reports
line 416: internal compiler error:  Unknown ND2 found in loop
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 9.8 91/08/30 18:31:12 mike Exp $ (BRL)";
d306 1
a306 1
" curs:  a1=%.1f,  a2=%.1f,  dst=%.3f,  cent=(%.3f, %.3f)",
d309 3
a311 1
			pt3[X]*base2local, pt3[Y]*base2local);
@


9.8
log
@Serious optimization
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 9.7 91/08/30 18:23:34 mike Exp $ (BRL)";
d341 1
a357 1
			static char kvt[4] = "X\0";/* Cvts chars to strings */
d361 1
@


9.7
log
@Split vertex labling out into a separate function
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 9.6 91/06/30 21:16:31 mike Exp $ (BRL)";
d331 1
d336 1
a336 1
	union record	temp_rec;		/* copy of es_rec record */
d340 1
d342 2
d347 1
a347 2
		MAT4X3PNT( work, es_mat, es_rec.s.s_values );
		MAT4X3PNT( pos_view, model2objview, work );
d359 1
a359 2
			MAT4X3PNT(temp, es_mat, work);
			MAT4X3PNT( pos_view, model2objview, temp );
d366 1
a366 2
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
d370 1
a370 2
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
d373 2
a374 4
		VADD2( temp, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_H );
		VADD2( work, temp, &es_rec.s.s_tgc_C );
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
d377 2
a378 4
		VADD2( temp, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_H );
		VADD2( work, temp, &es_rec.s.s_tgc_D );
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
d384 1
a384 2
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
d386 1
d388 1
a388 2
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
d390 1
d392 1
a392 2
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
d395 1
d398 1
a398 2
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
d400 1
d402 1
a402 2
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
d404 1
d406 1
a406 2
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
d409 1
d412 1
a412 2
		MAT4X3PNT(temp, es_mat, es_rec.s.s_values);
		MAT4X3PNT( pos_view, model2objview, temp );
@


9.6
log
@Replaced local_unit[] with call to rt_units_string()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/titles.c,v 9.4 91/06/27 16:31:43 pjt Exp $ (BRL)";
a62 1
	static vect_t pos_view;		/* view position */
d124 3
a126 1
	if(es_edflag >= 0 || (state == ST_O_EDIT && illump->s_Eflag == 0))  switch( es_gentype )  {
a127 80
	case GENARB8:
		MAT4X3PNT( work, es_mat, es_rec.s.s_values );
		MAT4X3PNT( pos_view, model2objview, work );
		dmp->dmr_puts( "1", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
		temp_rec.s = es_rec.s;
		if(es_type == ARB4) {
			VMOVE(&temp_rec.s.s_values[9], &temp_rec.s.s_values[12]);
		}
		if(es_type == ARB6) {
			VMOVE(&temp_rec.s.s_values[15], &temp_rec.s.s_values[18]);
		}
		for(i=1; i<es_type; i++) {
			static char kvt[4] = "X\0";/* Cvts chars to strings */
			VADD2( work, es_rec.s.s_values, &temp_rec.s.s_values[i*3] );
			MAT4X3PNT(temp, es_mat, work);
			MAT4X3PNT( pos_view, model2objview, temp );
			kvt[0] = i + '1';
			dmp->dmr_puts( kvt, ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
		}
		break;
	case GENTGC:
		VADD2( work, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_A );
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
		dmp->dmr_puts( "A", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );

		VADD2( work, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_B );
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
		dmp->dmr_puts( "B", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );

		VADD2( temp, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_H );
		VADD2( work, temp, &es_rec.s.s_tgc_C );
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
		dmp->dmr_puts( "C", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );

		VADD2( temp, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_H );
		VADD2( work, temp, &es_rec.s.s_tgc_D );
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
		dmp->dmr_puts( "D", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
		break;

	case GENELL:
		VADD2( work, &es_rec.s.s_ell_V, &es_rec.s.s_ell_A );
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
		dmp->dmr_puts( "A", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
		VADD2( work, &es_rec.s.s_ell_V, &es_rec.s.s_ell_B );
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
		dmp->dmr_puts( "B", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
		VADD2( work, &es_rec.s.s_ell_V, &es_rec.s.s_ell_C );
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
		dmp->dmr_puts( "C", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
		break;
	case TOR:
		VADD2( work, &es_rec.s.s_tor_V, &es_rec.s.s_tor_C );
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
		dmp->dmr_puts( "I", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
		VADD2( work, &es_rec.s.s_tor_V, &es_rec.s.s_tor_E );
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
		dmp->dmr_puts( "O", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
		VADD3( work, &es_rec.s.s_tor_V, &es_rec.s.s_tor_A, &es_rec.s.s_tor_H);
		MAT4X3PNT(temp, es_mat, work);
		MAT4X3PNT( pos_view, model2objview, temp );
		dmp->dmr_puts( "H", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
		break;
	case ARS:
	case ARSCONT:
		MAT4X3PNT(temp, es_mat, es_rec.s.s_values);
		MAT4X3PNT( pos_view, model2objview, temp );
		dmp->dmr_puts( "V", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
		break;
	}

d324 96
@


9.5
log
@Per suggestion from Harry Reed the younger,
eliminated the database title from the faceplate.
This results in a small performance improvement
which improves interactivity.
@
text
@a48 11
char	*local_unit[] = {
	"NONE",
	"MILLIMETERS",
	"CENTIMETERS",
	"METERS",
	"INCHES",
	"FEET",
	"UNKNOWN",
};


d344 1
a344 1
		local_unit[localunit] );
@


9.4
log
@Fixed reporting of ADC cent. coordinates?
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 9.2 89/10/10 16:28:07 mike Exp $ (BRL)";
a412 4
		dmp->dmr_puts( &linebuf[0], TITLE_XBASE, TITLE_YBASE + TEXT1_DY, 1, DM_YELLOW );
	} else {
		/* Title of model */
		(void)sprintf(&linebuf[0], " %s", cur_title);
@


9.3
log
@Changed formats for az and el to display hundredths of degree,
and changed cent for ADC to display GIFT h and v coordinates
@
text
@d388 2
a389 2
		    (curs_x / 2047.0) *Viewscale*base2local,
		    (curs_y / 2047.0) *Viewscale*base2local, 0.0);
d399 1
a399 1
			pt3[X], pt3[Y]);
@


9.2
log
@Added notes about where es_keypoint is needed
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 9.1 89/05/19 06:04:00 mike Rel3_5 $ (BRL)";
d363 1
a363 1
	(void)sprintf( cp, "az=%3.0f el=%2.0f ang=(%.2f, %.2f, %.2f)",
d384 11
d399 1
a399 2
			(curs_x / 2047.0) *Viewscale*base2local,
			(curs_y / 2047.0) *Viewscale*base2local );
@


9.1
log
@Release_3.5
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 8.6 89/04/22 05:44:53 mike Exp $ (BRL)";
d124 1
d332 1
@


8.6
log
@Simplified scroll-bars Y layout slightly,
to prevent wrap-around on Megatek.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 8.5 89/04/21 04:57:03 mike Locked $ (BRL)";
@


8.5
log
@Interface hooks for supporting scroll bars (aka sliders).
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 8.4 89/04/14 05:08:52 mike Locked $ (BRL)";
d91 4
a103 2
	y = MENUY;

a118 1
	scroll_display( SCROLLY ); 
@


8.4
log
@Added current azimuth/elevation to mode line.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 8.3 89/04/06 20:40:21 mike Locked $ (BRL)";
d30 1
d32 1
a32 1
#include "externs.h"
d94 1
a94 2
	dmp->dmr_2d_line(MENUXLIM, YPOS, XMIN, YPOS, 0); /* side-side */
	dmp->dmr_2d_line(MENUXLIM, YPOS, MENUXLIM, YMAX, 0);
d117 1
@


8.3
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 8.2 88/12/06 02:33:28 mike Locked $ (BRL)";
d78 1
d355 6
a360 1
	(void)sprintf( cp, "ang=(%.2f, %.2f, %.2f)",
@


8.2
log
@objdir.h --> raytrace.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/titles.c,v 1.2 88/10/23 13:56:56 mike Exp $ (BRL)";
d31 1
@


8.1
log
@Release_3.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 7.5 88/09/07 11:09:07 stay Exp $ (BRL)";
d29 1
a31 1
#include "./objdir.h"
@


7.5
log
@A procedure call witha lot of calculations in it broke the
SGI 4D compiler (2.0 and 3.0) had to take it out and compute
it separate. It also seems that it needed a float to do it
right. SIGH........
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 7.4 88/09/06 17:20:15 stay Locked $ (BRL)";
@


7.4
log
@added stdio include
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 7.3 88/07/22 01:58:26 reschly Locked $ (BRL)";
d76 1
d246 7
d256 1
a256 1
					SOLID_YBASE+TEXT1_DY+(TEXT0_DY*(es_nlines+2)),
d268 1
a268 1
			yloc = SOLID_YBASE+(2*TEXT1_DY)+(TEXT0_DY*(es_nlines+2));
d272 1
d275 1
a275 1
						yloc+(TEXT0_DY*i),
@


7.3
log
@menu -> mmenu
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 7.2 87/11/05 05:06:59 phil Locked $ (BRL)";
d24 1
a33 2

extern int	printf(), sprintf();
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 7.1 87/11/03 00:02:00 mike Rel $ (BRL)";
d115 1
a115 1
	menu_display( y );
@


7.1
log
@Release 2.3
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 6.1 87/07/11 08:05:26 mike Rel $ (BRL)";
d25 1
a25 1
#include "./machine.h"	/* special copy */
@


6.1
log
@Release 2.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 5.1 87/06/24 22:22:19 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 4.2 87/02/13 00:13:10 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 4.1 86/12/29 03:23:11 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 2.13 86/08/12 06:50:54 mike Exp $ (BRL)";
@


2.13
log
@Changed #includes for CC -I../h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 2.12 85/09/27 19:12:46 mike Exp $ (BRL)";
@


2.12
log
@KAA prioritize bottom line of screen.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 2.11 85/08/28 21:41:56 mike Exp $ (BRL)";
d24 1
d26 7
a32 8
#include "../h/vmath.h"
#include "ged.h"
#include "solid.h"
#include "objdir.h"
#include "../h/db.h"
#include "sedit.h"
#include <math.h>
#include "dm.h"
@


2.11
log
@Changed division by viewfactor to multiplication by viewscale.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 2.10 85/08/26 17:16:23 mike Exp $ (BRL)";
d354 20
a373 1
	if( illump != SOLID_NULL )  {
a383 9
		dmp->dmr_puts( &linebuf[0], TITLE_XBASE, TITLE_YBASE + TEXT1_DY, 1, DM_YELLOW );
	} else if (adcflag)  {
		/* Angle/Distance cursor */
		(void)sprintf( &linebuf[0],
" curs:  a1=%.1f,  a2=%.1f,  dst=%.3f,  cent=(%.3f, %.3f)",
			angle1 * radtodeg, angle2 * radtodeg,
			(c_tdist / 2047.0) *Viewscale*base2local,
			(curs_x / 2047.0) *Viewscale*base2local,
			(curs_y / 2047.0) *Viewscale*base2local );
@


2.10
log
@Latest solid editing improvements from KAA.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 2.8 85/07/30 01:18:14 mike Exp $ (BRL)";
d371 3
a373 3
			(c_tdist / 2047.0) / VIEWFACTOR*base2local,
			(curs_x / 2047.0) / VIEWFACTOR*base2local,
			(curs_y / 2047.0) / VIEWFACTOR*base2local );
@


2.9
log
@Changed to use common ../h/vmath.h
@
text
@d205 6
@


2.8
log
@Change to support new ARB editing.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 2.7 85/05/29 23:17:34 mike Exp $ (BRL)";
d24 2
a25 1
#include "ged_types.h"
a32 1
#include "../h/vmath.h"
@


2.7
log
@Added MENU_L2 menu for solid/object edit buttons,
moved menus to left side of screen.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 2.6 85/05/10 00:54:58 mike Exp $ (BRL)";
d137 8
a144 1
		for(i=1; i<8; i++) {
d146 1
a146 1
			VADD2( work, es_rec.s.s_values, &es_rec.s.s_values[i*3] );
@


2.6
log
@Added multi-menu capability, added dmr_window and dmr_debug,
deleted dmr_restart.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 2.5 85/05/08 00:24:50 mike Exp $ (BRL)";
d80 4
a83 4
	dmp->dmr_2d_line( -2048, -2048,  2047, -2048, 0 );
	dmp->dmr_2d_line(  2047, -2048,  2047,  2047, 0 );
	dmp->dmr_2d_line(  2047,  2047, -2048,  2047, 0 );
	dmp->dmr_2d_line( -2048,  2047, -2048, -2048, 0 );
d86 1
a86 1
	dmp->dmr_2d_line( -2047, TITLE_YBASE-TEXT1_DY, 2047, TITLE_YBASE-TEXT1_DY, 0 );
a89 1
	dmp->dmr_puts( local_unit[localunit], MENUX, MENUY - (2*MENU_DY), 1, DM_YELLOW);
d91 2
a92 2
	dmp->dmr_2d_line(XLIM, YPOS, 2047, YPOS, 0);
	dmp->dmr_2d_line(XLIM, YPOS, XLIM, 2047, 0);
a94 7
#ifndef never
	/* QUESTIONABLE use of machine */
	/* print region default code numbers */
	(void)sprintf( &linebuf[0], " Next Region:   item=%d  air=%d  mat=%d  los=%d",
			item_default,air_default,mat_default,los_default);
	dmp->dmr_puts(&linebuf[0], TITLE_XBASE, TITLE_YBASE - 3*TEXT1_DY/2, 1, DM_YELLOW);
#endif
d211 1
a211 1
				TITLE_XBASE+15,
d217 1
a217 1
				TITLE_XBASE,
d235 1
a235 1
					TITLE_XBASE+15,
d253 1
a253 1
						TITLE_XBASE,
d276 1
a276 1
				TITLE_XBASE+15,
d296 1
a296 1
						TITLE_XBASE,
d311 1
a311 1
					TITLE_XBASE+15,
d323 1
a323 1
		" cent=(%.3f, %.3f, %.3f), sz=%.3f, ",
d327 2
a328 1
		VIEWSIZE*base2local );
@


2.5
log
@KAA print default region ids.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 2.4 85/05/03 02:00:20 mike Exp $ (BRL)";
d96 1
a96 1
#ifdef never
@


2.4
log
@Moved some functionality into menu.c;
no longer display path information in menu area once
in an edit state.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 2.3 85/05/02 22:12:31 mike Exp $ (BRL)";
d96 7
@


2.3
log
@Better indication of location of Ojbect edit matrix,
slight format improvements.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 2.2 85/03/15 05:06:31 mike Exp $ (BRL)";
a95 5
	/* Menu area border */
	if( illump != SOLID_NULL )  {
		dmp->dmr_2d_line(  XLIM,  2047,  XLIM,  TITLE_YBASE-TEXT1_DY, 0 );
	}

d101 2
a102 1
	if( illump != SOLID_NULL )  {
d104 1
a104 2
			if( i == ipathpos  &&
			    (state == ST_O_PATH || state == ST_O_EDIT) )  {
a112 7
	/* put horiz lines to seperate path info and menu */
	if( state == ST_S_EDIT ) {
		/* solid edit */
		dmp->dmr_2d_line(XLIM, y-MENU_DY/2, 2047, y-MENU_DY/2, 0);
		dmp->dmr_2d_line(XLIM, y-MENU_DY/2+10, 2047, y-MENU_DY/2+10, 0);
	}

d114 1
a114 3
	 * The "y" value is passed so that the menu can be presented
	 * even when in illuminate path mode.
	 * This is probably unlikely, but is there if needed.
a198 7
	}

	/* prefix item selected with "==>" to let user know it is selected */
	if( es_edflag >= 0 && menuflag ) {
		dmp->dmr_puts("==>", MENUX-114, menuyy, 0, DM_WHITE);
		dmp->dmr_puts("==>", MENUX-114, menuyy, 0, DM_WHITE);
		dmp->dmr_puts("==>", MENUX-114, menuyy, 0, DM_WHITE);
@


2.2
log
@Added mapping between region ID and color + database handle.
Reorganized to support regular expressions on the command line.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 2.1 85/03/11 23:58:01 mike Prod $ (BRL)";
d84 13
a99 1
	dmp->dmr_2d_line( -2047, TITLE_YBASE-TEXT1_DY, 2047, TITLE_YBASE-TEXT1_DY, 0 );
a100 9
	/* Display current state in upper right corner */
	dmp->dmr_puts( state_str[state], MENUX, MENUY - MENU_DY, 1, DM_YELLOW );

	/* Display current local unit in effect */
	dmp->dmr_puts( local_unit[localunit], MENUX, MENUY - (2*MENU_DY), 1, DM_BLUE);
	dmp->dmr_2d_line(XLIM, 1825, 2047, 1825, 0);
	dmp->dmr_2d_line(XLIM, 1815, 2047, 1815, 0);
	dmp->dmr_2d_line(XLIM, 1815, XLIM, 2047, 0);

d108 5
a113 4
			if( state == ST_O_PATH && i == ipathpos )  {
				dmp->dmr_puts( illump->s_path[i]->d_namep, MENUX, y, 0, DM_WHITE );
				dmp->dmr_puts( illump->s_path[i]->d_namep, MENUX, y, 0, DM_WHITE );
			}
d138 2
a139 2
		dmp->dmr_2d_line(xloc-TEXT0_DY, yloc+TEXT0_DY, xloc+TEXT0_DY, yloc-TEXT0_DY);
		dmp->dmr_2d_line(xloc-TEXT0_DY, yloc-TEXT0_DY, xloc+TEXT0_DY, yloc+TEXT0_DY);
d217 3
a219 3
			dmp->dmr_puts("==>", MENUX-114, menuyy, 0, DM_WHITE);
			dmp->dmr_puts("==>", MENUX-114, menuyy, 0, DM_WHITE);
			dmp->dmr_puts("==>", MENUX-114, menuyy, 0, DM_WHITE);
d360 1
a360 1
	 * Angle/Distance cursor below status line.
d362 14
a375 1
	if (adcflag)  {
d377 6
a382 7
" curs:  ang1=%.1f,  ang2=%.1f,  dist=%.3f,  cent=(%.3f, %.3f)",
				angle1 * radtodeg, angle2 * radtodeg,
				(c_tdist / 2047.0) / VIEWFACTOR*base2local,
				(curs_x / 2047.0) / VIEWFACTOR*base2local,
				(curs_y / 2047.0) / VIEWFACTOR*base2local
			     );
		dmp->dmr_puts( &linebuf[0], TITLE_XBASE, TITLE_YBASE + TEXT1_DY, 1, DM_BLUE );
d384 1
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 1.8 85/02/02 01:40:53 mike Exp $ (BRL)";
d93 1
a93 1
	dmp->dmr_puts( local_unit[localunit], MENUX, MENUY - (2*MENU_DY), 1, DM_CYAN);
d326 1
a326 1
					"CENTER  : %.4f %.4f %.4f",
d366 1
a366 1
		dmp->dmr_puts( &linebuf[0], TITLE_XBASE, TITLE_YBASE + TEXT1_DY, 1, DM_CYAN );
@


1.8
log
@Shortened titles.
@
text
@d7 5
a11 1
 * Source -
d15 4
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: titles.c,v 1.7 85/02/01 04:06:27 mike Exp $ (BRL)";
d27 2
a28 2
#include "dir.h"
#include "db.h"
d32 1
a32 1
#include "vmath.h"
d258 1
a258 1
			temp_rec = es_rec;
d303 1
a303 1
			temp_rec = es_rec;
@


1.7
log
@Decreased screen clutter
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: titles.c,v 1.6 85/02/01 00:51:21 mike Exp $ (BRL)";
d333 1
a333 1
		" view:  cent=(%.3f, %.3f, %.3f), sz=%.3f, ",
d352 1
a352 1
" cursor:  angle1=%.1f,  angle2=%.1f,  dist=%.3f,  cent=(%.3f, %.3f)",
@


1.6
log
@Keith's global/local units additions
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d333 1
a333 1
		" view:  cent=(%.3f, %.3f, %.3f), size=%.3f, ",
d341 1
a341 1
	(void)sprintf( cp, "angles=(%.2f, %.2f, %.2f)",
d359 3
a361 9
	}
	else {
		/* display title and units */
		(void)sprintf(&linebuf[0], " Title = %s",cur_title);
		cp = &linebuf[0];
		FINDNULL( cp );
		(void)sprintf(cp, "   UNITS = %s",local_unit[localunit]);
		linebuf[80] = '\0';
		dmp->dmr_puts( &linebuf[0], TITLE_XBASE, TITLE_YBASE + TEXT1_DY, 1, DM_BLUE );
@


1.5
log
@Made state titles shorter, used larger letters.
@
text
@d6 5
d12 4
d31 1
a31 1
	"VIEW",
d40 11
d67 2
a68 1
	register int yloc;
a77 1
		dmp->dmr_2d_line( -2047, TITLE_YBASE-TEXT1_DY, XLIM, TITLE_YBASE-TEXT1_DY, 0 );
d79 1
d82 1
a82 1
	dmp->dmr_puts( state_str[state], MENUX, MENUY - MENU_DY, 2, DM_YELLOW );
d84 6
d105 8
d121 12
a132 1
	if(es_edflag >= 0)  switch( es_gentype )  {
d134 2
d232 1
d273 56
d330 1
a330 1
	 * General status information on the last line
d333 5
a337 2
		"\r view:  cent=(%.3f, %.3f, %.3f), size=%.3f, ",
		-toViewcenter[MDX], -toViewcenter[MDY], -toViewcenter[MDZ], VIEWSIZE );
d348 1
a348 1
	 * Angle/Distance cursor above status line.
d352 1
a352 1
"\r cursor:  angle1=%.1f,  angle2=%.1f,  dist=%.3f,  cent=(%.3f, %.3f)",
d354 3
a356 3
				(c_tdist / 2047.0) / VIEWFACTOR,
				(curs_x / 2047.0) / VIEWFACTOR,
				(curs_y / 2047.0) / VIEWFACTOR
d358 10
a367 1
		dmp->dmr_puts( &linebuf[0], TITLE_XBASE, TITLE_YBASE - TEXT1_DY, 1, DM_CYAN );
@


1.4
log
@Various solid edit cleanups, plus additional screen information.
@
text
@d23 5
a27 5
	"SOLID PICK",
	"SOLID EDIT",
	"OBJECT PICK",
	"OBJECT PATH",
	"OBJECT EDIT",
d61 1
a61 1
	dmp->dmr_puts( state_str[state], MENUX, MENUY - MENU_DY, 1, DM_YELLOW );
@


1.3
log
@pre-Keith version
@
text
@d46 2
d70 1
a70 1
			dmp->dmr_puts( illump->s_path[i]->d_namep, MENUX, y, DM_YELLOW );
d89 2
a90 1
		MAT4X3PNT( pos_view, model2objview, es_rec.s.s_values );
d95 2
a96 1
			MAT4X3PNT( pos_view, model2objview, work );
d103 2
a104 1
		MAT4X3PNT( pos_view, model2objview, work );
d108 2
a109 1
		MAT4X3PNT( pos_view, model2objview, work );
d114 2
a115 1
		MAT4X3PNT( pos_view, model2objview, work );
d120 2
a121 1
		MAT4X3PNT( pos_view, model2objview, work );
d127 2
a128 1
		MAT4X3PNT( pos_view, model2objview, work );
d131 2
a132 1
		MAT4X3PNT( pos_view, model2objview, work );
d135 2
a136 1
		MAT4X3PNT( pos_view, model2objview, work );
d141 2
a142 1
		MAT4X3PNT( pos_view, model2objview, work );
d145 2
a146 1
		MAT4X3PNT( pos_view, model2objview, work );
d149 2
a150 1
		MAT4X3PNT( pos_view, model2objview, work );
d168 1
d171 6
d180 2
a181 1
				SOLID_YBASE+(TEXT0_DY*i),
d184 38
a231 1
#define FINDNULL(p)	while(*p++); p--;	/* leaves p at NULL */
@


1.2
log
@Vector lists saved, multiple display managers supported.
@
text
@d11 1
a11 1
#include "3d.h"
@


1.1
log
@Initial revision
@
text
@a18 2
extern struct device_values dm_values;	/* Values from devs, from dm-XX.c */

d49 4
a52 4
	dm_2d_line( -2048, -2048,  2047, -2048, 0 );
	dm_2d_line(  2047, -2048,  2047,  2047, 0 );
	dm_2d_line(  2047,  2047, -2048,  2047, 0 );
	dm_2d_line( -2048,  2047, -2048, -2048, 0 );
d54 2
a55 2
		dm_2d_line(  XLIM,  2047,  XLIM,  TITLE_YBASE-TEXT1_DY, 0 );
		dm_2d_line( -2047, TITLE_YBASE-TEXT1_DY, XLIM, TITLE_YBASE-TEXT1_DY, 0 );
d59 1
a59 1
	dm_puts( state_str[state], MENUX, MENUY - MENU_DY, 1, DM_YELLOW );
d68 1
a68 1
			dm_puts( illump->s_path[i]->d_namep, MENUX, y, DM_YELLOW );
d70 2
a71 2
				dm_puts( illump->s_path[i]->d_namep, MENUX, y, 0, DM_WHITE );
				dm_puts( illump->s_path[i]->d_namep, MENUX, y, 0, DM_WHITE );
d88 1
a88 1
		dm_puts( "1", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d94 1
a94 1
			dm_puts( kvt, ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d100 1
a100 1
		dm_puts( "A", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d104 1
a104 1
		dm_puts( "B", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d109 1
a109 1
		dm_puts( "C", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d114 1
a114 1
		dm_puts( "D", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d120 1
a120 1
		dm_puts( "A", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d123 1
a123 1
		dm_puts( "B", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d126 1
a126 1
		dm_puts( "C", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d131 1
a131 1
		dm_puts( "I", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d134 1
a134 1
		dm_puts( "O", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d137 1
a137 1
		dm_puts( "H", ((int)(pos_view[X]*2048))+15, ((int)(pos_view[Y]*2048))+15, 0, DM_WHITE );
d143 3
a145 3
			dm_puts("==>", MENUX-114, menuyy, 0, DM_WHITE);
			dm_puts("==>", MENUX-114, menuyy, 0, DM_WHITE);
			dm_puts("==>", MENUX-114, menuyy, 0, DM_WHITE);
d151 1
a151 1
	 * so each line is written with a separate call to dm_puts().
d157 1
a157 1
			dm_puts( &es_display[i*ES_LINELEN],
d178 1
a178 1
	dm_puts( &linebuf[0], TITLE_XBASE, TITLE_YBASE, 1, DM_WHITE );
d191 1
a191 1
		dm_puts( &linebuf[0], TITLE_XBASE, TITLE_YBASE - TEXT1_DY, 1, DM_CYAN );
@
