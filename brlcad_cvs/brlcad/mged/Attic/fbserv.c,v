head	1.17;
access;
symbols
	ansi-20040405-merged:1.13.2.2
	postmerge-20040405-ansi:1.15
	premerge-20040404-ansi:1.14
	postmerge-autoconf:1.14
	autoconf-freeze:1.13.10.2
	premerge-autoconf:1.14
	postmerge-20040315-windows:1.14
	premerge-20040315-windows:1.14
	windows-20040315-freeze:1.13.4.1
	autoconf-20031203:1.13
	autoconf-20031202:1.13
	autoconf-branch:1.13.0.10
	phong-branch:1.13.0.8
	photonmap-branch:1.13.0.6
	rel-6-1-DP:1.13
	windows-branch:1.13.0.4
	rel-6-0-2:1.11
	ansi-branch:1.13.0.2
	rel-6-0-1-branch:1.11.0.2
	hartley-6-0-post:1.12
	hartley-6-0-pre:1.11
	rel-6-0-1:1.11
	rel-6-0:1.11
	rel-5-4:1.9
	offsite-5-3-pre:1.11
	rel-5-3:1.9
	rel-5-2:1.9
	rel-5-1-branch:1.9.0.2
	rel-5-1:1.9
	rel-5-0:1.8
	rel-5-0-beta:1.8
	rel-4-5:1.2;
locks; strict;
comment	@ * @;


1.17
date	2004.05.21.17.47.42;	author morrison;	state dead;
branches;
next	1.16;

1.16
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.02.17.39.32;	author morrison;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.20.17.08.23;	author jra;	state Exp;
branches
	1.13.2.1
	1.13.4.1
	1.13.10.1;
next	1.12;

1.12
date	2002.08.15.20.55.34;	author hartley;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.01.21.16.10;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.19.03.10.45;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.07.21.44.54;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	99.03.18.18.03.18;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	98.11.06.22.32.40;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	98.06.27.04.29.19;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	98.06.11.14.28.11;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	98.02.26.16.25.01;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	98.02.20.23.16.11;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	98.01.28.16.03.05;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.21.55.23;	author bparker;	state Exp;
branches;
next	;

1.13.2.1
date	2002.09.19.18.02.02;	author morrison;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2004.03.17.21.21.59;	author morrison;	state Exp;
branches;
next	;

1.13.4.1
date	2004.03.11.23.46.35;	author morrison;	state Exp;
branches;
next	;

1.13.10.1
date	2004.02.12.18.34.14;	author erikg;	state Exp;
branches;
next	1.13.10.2;

1.13.10.2
date	2004.03.15.14.07.38;	author erikg;	state Exp;
branches;
next	;


desc
@MGED's fbserv code
@


1.17
log
@moved to src/mged/
@
text
@/*
 *			F B S E R V . C
 *
 *  This code was developed by modifying the stand-alone version of fbserv to work
 *  within MGED.
 *
 *  Author -
 *	Robert Parker
 *
 *  Authors of the stand-alone fbserv -
 *	Phillip Dykstra
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/fbserv.c,v 1.16 2004/05/10 15:30:48 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>

#include <sys/socket.h>
#include <netinet/in.h>		/* For htonl(), etc */

#include "tcl.h"
#include "machine.h"
#include "externs.h"		/* For malloc, getopt */
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "./mged_dm.h"
#include "../libfb/pkgtypes.h"
#include "./fbserv.h"

#define NET_LONG_LEN	4	/* # bytes to network long */

void set_port(void);

#ifdef LOCAL_STATIC
#undef LOCAL_STATIC
#endif
#define LOCAL_STATIC static

LOCAL_STATIC void new_client(struct pkg_conn *pcp);
LOCAL_STATIC void drop_client(int sub);
LOCAL_STATIC void new_client_handler(ClientData clientData, int mask);
LOCAL_STATIC void existing_client_handler(ClientData clientData, int mask);
LOCAL_STATIC void comm_error(char *str);
LOCAL_STATIC void setup_socket(int fd);


/*
 *			N E W _ C L I E N T
 */
LOCAL_STATIC void
new_client(struct pkg_conn *pcp)
{
  register int	i;

  if( pcp == PKC_ERROR )
    return;

  for(i = MAX_CLIENTS-1; i >= 0; i--){
    if(clients[i].c_fd != 0)
      continue;

    /* Found an available slot */
    clients[i].c_pkg = pcp;
    clients[i].c_fd = pcp->pkc_fd;
    setup_socket(pcp->pkc_fd);

    Tcl_CreateFileHandler(clients[i].c_fd, TCL_READABLE,
			  existing_client_handler, (ClientData)clients[i].c_fd);

    return;
  }

  bu_log("new_client: too many clients\n");
  pkg_close(pcp);
}

/*
 *			D R O P _ C L I E N T
 */
LOCAL_STATIC void
drop_client(int sub)
{
  if(clients[sub].c_pkg != PKC_NULL)  {
    pkg_close(clients[sub].c_pkg);
    clients[sub].c_pkg = PKC_NULL;
  }

  if(clients[sub].c_fd != 0)  {
    Tcl_DeleteFileHandler(clients[sub].c_fd);
    close(clients[sub].c_fd);
    clients[sub].c_fd = 0;
  }
}

/*
 *			S E T _ P O R T
 */
void
set_port(void)
{
  register int i;
  int save_port;
  char portname[32];

  /* Check to see if previously active --- if so then deactivate */
  if(netfd >= 0){
    /* first drop all clients */
    for(i = 0; i < MAX_CLIENTS; ++i)
      drop_client(i);

    Tcl_DeleteFileHandler(netfd);
    close(netfd);
    netfd = -1;
  }

  if(!mged_variables->mv_listen)
    return;

  if(!mged_variables->mv_fb){
    mged_variables->mv_listen = 0;
    return;
  }

#if 1
#define MAX_PORT_TRIES 100

  save_port = mged_variables->mv_port;
  if(mged_variables->mv_port < 0)
    mged_variables->mv_port = 0;

  /* Try a reasonable number of times to hang a listen */
  for(i = 0; i < MAX_PORT_TRIES; ++i){
    if(mged_variables->mv_port < 1024)
      sprintf(portname,"%d", mged_variables->mv_port + 5559);
    else
      sprintf(portname,"%d", mged_variables->mv_port);

    /*
     * Hang an unending listen for PKG connections
     */
    if( (netfd = pkg_permserver(portname, 0, 0, comm_error)) < 0 )
      ++mged_variables->mv_port;
    else
      break;
  }
#else
  if(mged_variables->mv_port < 0){
    mged_variables->mv_listen = 0;
    bu_log("set_port: invalid port number - %d\n", mged_variables->mv_port);
    return;
  }

  if(mged_variables->mv_port < 1024)
     sprintf(portname,"%d", mged_variables->mv_port + 5559);
  else
    sprintf(portname,"%d", mged_variables->mv_port);

  /*
   * Hang an unending listen for PKG connections
   */
  if( (netfd = pkg_permserver(portname, 0, 0, comm_error)) < 0 ){
    bu_log("set_port: failed to hang a listen on port %d\n", mged_variables->mv_port);
    mged_variables->mv_listen = 0;

    return;
  }
#endif

  if(netfd < 0){
    mged_variables->mv_port = save_port;
    mged_variables->mv_listen = 0;
    bu_log("set_port: failed to hang a listen on ports %d - %d\n",
	   mged_variables->mv_port, mged_variables->mv_port + MAX_PORT_TRIES - 1);
  }else
    Tcl_CreateFileHandler(netfd, TCL_READABLE,
			  new_client_handler, (ClientData)netfd);
}

/*
 * Accept any new client connections.
 */
LOCAL_STATIC void
new_client_handler(ClientData clientData, int mask)
{
  int fd = (int)((long)clientData & 0xFFFF);	/* fd's will be small */
  struct dm_list *dlp;
  struct dm_list *scdlp;  /* save current dm_list pointer */

  FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
    if(fd == dlp->dml_netfd)
      goto found;

  return;

found:
  /* save */
  scdlp = curr_dm_list;

  curr_dm_list = dlp;
  new_client(pkg_getclient(fd, pkg_switch, comm_error, 0));

  /* restore */
  curr_dm_list = scdlp;
}

/*
 * Process arrivals from existing clients.
 */
LOCAL_STATIC void
existing_client_handler(ClientData clientData, int mask)
{
  register int i;
  int fd = (int)((long)clientData & 0xFFFF);	/* fd's will be small */
  int npp;			/* number of processed packages */
  struct dm_list *dlp;
  struct dm_list *scdlp;  /* save current dm_list pointer */

  FOR_ALL_DISPLAYS(dlp, &head_dm_list.l){
    for(i = MAX_CLIENTS-1; i >= 0; i--)
      if(fd == dlp->dml_clients[i].c_fd)
	goto found;
  }

  return;

found:
  /* save */
  scdlp = curr_dm_list;

  curr_dm_list = dlp;
  for(i = MAX_CLIENTS-1; i >= 0; i--){
    if(clients[i].c_fd == 0)
      continue;

    if((npp = pkg_process(clients[i].c_pkg)) < 0)
      bu_log("pkg_process error encountered (1)\n");

    if(npp > 0)
      dirty = 1;

    if(clients[i].c_fd != fd)
      continue;

    if(pkg_suckin(clients[i].c_pkg) <= 0){
      /* Probably EOF */
      drop_client(i);

      continue;
    }

    if((npp = pkg_process(clients[i].c_pkg)) < 0)
      bu_log("pkg_process error encountered (2)\n");

    if(npp > 0)
      dirty = 1;
  }

  /* restore */
  curr_dm_list = scdlp;
}

LOCAL_STATIC void
setup_socket(int fd)
{
  int on = 1;

#if defined(SO_KEEPALIVE)
  if(setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char *)&on, sizeof(on)) < 0){
    bu_log("setsockopt (SO_KEEPALIVE): %m\n");
  }
#endif
#if defined(SO_RCVBUF)
  /* try to set our buffers up larger */
  {
    int	m = -1, n = -1;
    int	val;
    int	size;

    for(size = 256; size > 16; size /= 2){
      val = size * 1024;
      m = setsockopt(fd, SOL_SOCKET, SO_RCVBUF,
		      (char *)&val, sizeof(val));
      val = size * 1024;
      n = setsockopt(fd, SOL_SOCKET, SO_SNDBUF,
		      (char *)&val, sizeof(val));
      if(m >= 0 && n >= 0)  break;
    }

    if(m < 0 || n < 0)
      bu_log("setup_socket: setsockopt() SO_RCVBUF/SO_SNDBUF failed: %m\n");
  }
#endif
}

/*
 *			C O M M _ E R R O R
 *
 *  Communication error.  An error occured on the PKG link.
 */
LOCAL_STATIC void
comm_error(char *str)
{
  bu_log(str);
}

/*
 * This is where we go for message types we don't understand.
 */
void
pkgfoo(struct pkg_conn *pcp, char *buf)
{
  bu_log("fbserv: unable to handle message type %d\n", pcp->pkc_type);
  (void)free(buf);
}

/******** Here's where the hooks lead *********/

void
rfbopen(struct pkg_conn *pcp, char *buf)
{
  char	rbuf[5*NET_LONG_LEN+1];
  int	want;

  /* Don't really open a new framebuffer --- use existing one */
  (void)pkg_plong(&rbuf[0*NET_LONG_LEN], 0);	/* ret */
  (void)pkg_plong(&rbuf[1*NET_LONG_LEN], fbp->if_max_width);
  (void)pkg_plong(&rbuf[2*NET_LONG_LEN], fbp->if_max_height);
  (void)pkg_plong(&rbuf[3*NET_LONG_LEN], fbp->if_width);
  (void)pkg_plong(&rbuf[4*NET_LONG_LEN], fbp->if_height);

  want = 5*NET_LONG_LEN;
  if( pkg_send( MSG_RETURN, rbuf, want, pcp ) != want )
    comm_error("pkg_send fb_open reply\n");

  if(buf)
    (void)free(buf);
}

void
rfbclose(struct pkg_conn *pcp, char *buf)
{
  char	rbuf[NET_LONG_LEN+1];
	
  /*
   * We are playing FB server so we don't really close the
   * frame buffer.  We should flush output however.
   */
  (void)fb_flush(fbp);
  (void)pkg_plong(&rbuf[0], 0);		/* return success */

  /* Don't check for errors, SGI linger mode or other events
   * may have already closed down all the file descriptors.
   * If communication has broken, other end will know we are gone.
   */
  (void)pkg_send(MSG_RETURN, rbuf, NET_LONG_LEN, pcp);

  if(buf)
    (void)free(buf);
}

void
rfbfree(struct pkg_conn *pcp, char *buf)
{
  char	rbuf[NET_LONG_LEN+1];
	
  /* Don't really free framebuffer */
  if(pkg_send(MSG_RETURN, rbuf, NET_LONG_LEN, pcp) != NET_LONG_LEN)
    comm_error("pkg_send fb_free reply\n");

  if(buf)
    (void)free(buf);
}

void
rfbclear(struct pkg_conn *pcp, char *buf)
{
  RGBpixel bg;
  char	rbuf[NET_LONG_LEN+1];

  bg[RED] = buf[0];
  bg[GRN] = buf[1];
  bg[BLU] = buf[2];

  (void)pkg_plong(rbuf, fb_clear(fbp, bg));
  pkg_send(MSG_RETURN, rbuf, NET_LONG_LEN, pcp);

  if(buf)
    (void)free(buf);
}

void
rfbread(struct pkg_conn *pcp, char *buf)
{
	int	x, y, num;
	int	ret;
	static unsigned char	*scanbuf = NULL;
	static int	buflen = 0;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	num = pkg_glong( &buf[2*NET_LONG_LEN] );

	if( num*sizeof(RGBpixel) > buflen ) {
		if( scanbuf != NULL )
			free( (char *)scanbuf );
		buflen = num*sizeof(RGBpixel);
		if( buflen < 1024*sizeof(RGBpixel) )
			buflen = 1024*sizeof(RGBpixel);
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
			fb_log("fb_read: malloc failed!");
			if( buf ) (void)free(buf);
			buflen = 0;
			return;
		}
	}

	ret = fb_read( fbp, x, y, scanbuf, num );
	if( ret < 0 )  ret = 0;		/* map error indications */
	/* sending a 0-length package indicates error */
	pkg_send( MSG_RETURN, scanbuf, ret*sizeof(RGBpixel), pcp );
	if( buf ) (void)free(buf);
}

void
rfbwrite(struct pkg_conn *pcp, char *buf)
{
	int	x, y, num;
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	type;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	num = pkg_glong( &buf[2*NET_LONG_LEN] );
	type = pcp->pkc_type;
	ret = fb_write( fbp, x, y, (unsigned char *)&buf[3*NET_LONG_LEN], num );

	if( type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

/*
 *			R F B R E A D R E C T
 */
void
rfbreadrect(struct pkg_conn *pcp, char *buf)
{
	int	xmin, ymin;
	int	width, height;
	int	num;
	int	ret;
	static unsigned char	*scanbuf = NULL;
	static int	buflen = 0;

	xmin = pkg_glong( &buf[0*NET_LONG_LEN] );
	ymin = pkg_glong( &buf[1*NET_LONG_LEN] );
	width = pkg_glong( &buf[2*NET_LONG_LEN] );
	height = pkg_glong( &buf[3*NET_LONG_LEN] );
	num = width * height;

	if( num*sizeof(RGBpixel) > buflen ) {
		if( scanbuf != NULL )
			free( (char *)scanbuf );
		buflen = num*sizeof(RGBpixel);
		if( buflen < 1024*sizeof(RGBpixel) )
			buflen = 1024*sizeof(RGBpixel);
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
			fb_log("fb_read: malloc failed!");
			if( buf ) (void)free(buf);
			buflen = 0;
			return;
		}
	}

	ret = fb_readrect( fbp, xmin, ymin, width, height, scanbuf );
	if( ret < 0 )  ret = 0;		/* map error indications */
	/* sending a 0-length package indicates error */
	pkg_send( MSG_RETURN, scanbuf, ret*sizeof(RGBpixel), pcp );
	if( buf ) (void)free(buf);
}

/*
 *			R F B W R I T E R E C T
 */
void
rfbwriterect(struct pkg_conn *pcp, char *buf)
{
	int	x, y;
	int	width, height;
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	type;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	width = pkg_glong( &buf[2*NET_LONG_LEN] );
	height = pkg_glong( &buf[3*NET_LONG_LEN] );

	type = pcp->pkc_type;
	ret = fb_writerect( fbp, x, y, width, height,
		(unsigned char *)&buf[4*NET_LONG_LEN] );

	if( type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

/*
 *			R F B B W R E A D R E C T
 */
void
rfbbwreadrect(struct pkg_conn *pcp, char *buf)
{
	int	xmin, ymin;
	int	width, height;
	int	num;
	int	ret;
	static unsigned char	*scanbuf = NULL;
	static int	buflen = 0;

	xmin = pkg_glong( &buf[0*NET_LONG_LEN] );
	ymin = pkg_glong( &buf[1*NET_LONG_LEN] );
	width = pkg_glong( &buf[2*NET_LONG_LEN] );
	height = pkg_glong( &buf[3*NET_LONG_LEN] );
	num = width * height;

	if( num > buflen ) {
		if( scanbuf != NULL )
			free( (char *)scanbuf );
		buflen = num;
		if( buflen < 1024 )
			buflen = 1024;
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
			fb_log("rfbbwreadrect: malloc failed!");
			if( buf ) (void)free(buf);
			buflen = 0;
			return;
		}
	}

	ret = fb_bwreadrect( fbp, xmin, ymin, width, height, scanbuf );
	if( ret < 0 )  ret = 0;		/* map error indications */
	/* sending a 0-length package indicates error */
	pkg_send( MSG_RETURN, scanbuf, ret, pcp );
	if( buf ) (void)free(buf);
}

/*
 *			R F B B W W R I T E R E C T
 */
void
rfbbwwriterect(struct pkg_conn *pcp, char *buf)
{
	int	x, y;
	int	width, height;
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	type;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	width = pkg_glong( &buf[2*NET_LONG_LEN] );
	height = pkg_glong( &buf[3*NET_LONG_LEN] );

	type = pcp->pkc_type;
	ret = fb_writerect( fbp, x, y, width, height,
		(unsigned char *)&buf[4*NET_LONG_LEN] );

	if( type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

void
rfbcursor(struct pkg_conn *pcp, char *buf)
{
	int	mode, x, y;
	char	rbuf[NET_LONG_LEN+1];

	mode = pkg_glong( &buf[0*NET_LONG_LEN] );
	x = pkg_glong( &buf[1*NET_LONG_LEN] );
	y = pkg_glong( &buf[2*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_cursor( fbp, mode, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbgetcursor(struct pkg_conn *pcp, char *buf)
{
	int	ret;
	int	mode, x, y;
	char	rbuf[4*NET_LONG_LEN+1];

	ret = fb_getcursor( fbp, &mode, &x, &y );
	(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
	(void)pkg_plong( &rbuf[1*NET_LONG_LEN], mode );
	(void)pkg_plong( &rbuf[2*NET_LONG_LEN], x );
	(void)pkg_plong( &rbuf[3*NET_LONG_LEN], y );
	pkg_send( MSG_RETURN, rbuf, 4*NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbsetcursor(struct pkg_conn *pcp, char *buf)
{
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	xbits, ybits;
	int	xorig, yorig;

	xbits = pkg_glong( &buf[0*NET_LONG_LEN] );
	ybits = pkg_glong( &buf[1*NET_LONG_LEN] );
	xorig = pkg_glong( &buf[2*NET_LONG_LEN] );
	yorig = pkg_glong( &buf[3*NET_LONG_LEN] );

	ret = fb_setcursor( fbp, (unsigned char *)&buf[4*NET_LONG_LEN],
		xbits, ybits, xorig, yorig );

	if( pcp->pkc_type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

/*OLD*/
void
rfbscursor(struct pkg_conn *pcp, char *buf)
{
	int	mode, x, y;
	char	rbuf[NET_LONG_LEN+1];

	mode = pkg_glong( &buf[0*NET_LONG_LEN] );
	x = pkg_glong( &buf[1*NET_LONG_LEN] );
	y = pkg_glong( &buf[2*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_scursor( fbp, mode, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/*OLD*/
void
rfbwindow(struct pkg_conn *pcp, char *buf)
{
	int	x, y;
	char	rbuf[NET_LONG_LEN+1];

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_window( fbp, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/*OLD*/
void
rfbzoom(struct pkg_conn *pcp, char *buf)
{
	int	x, y;
	char	rbuf[NET_LONG_LEN+1];

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_zoom( fbp, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbview(struct pkg_conn *pcp, char *buf)
{
	int	ret;
	int	xcenter, ycenter, xzoom, yzoom;
	char	rbuf[NET_LONG_LEN+1];

	xcenter = pkg_glong( &buf[0*NET_LONG_LEN] );
	ycenter = pkg_glong( &buf[1*NET_LONG_LEN] );
	xzoom = pkg_glong( &buf[2*NET_LONG_LEN] );
	yzoom = pkg_glong( &buf[3*NET_LONG_LEN] );

	ret = fb_view( fbp, xcenter, ycenter, xzoom, yzoom );
	(void)pkg_plong( &rbuf[0], ret );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbgetview(struct pkg_conn *pcp, char *buf)
{
	int	ret;
	int	xcenter, ycenter, xzoom, yzoom;
	char	rbuf[5*NET_LONG_LEN+1];

	ret = fb_getview( fbp, &xcenter, &ycenter, &xzoom, &yzoom );
	(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
	(void)pkg_plong( &rbuf[1*NET_LONG_LEN], xcenter );
	(void)pkg_plong( &rbuf[2*NET_LONG_LEN], ycenter );
	(void)pkg_plong( &rbuf[3*NET_LONG_LEN], xzoom );
	(void)pkg_plong( &rbuf[4*NET_LONG_LEN], yzoom );
	pkg_send( MSG_RETURN, rbuf, 5*NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbrmap(struct pkg_conn *pcp, char *buf)
{
	register int	i;
	char	rbuf[NET_LONG_LEN+1];
	ColorMap map;
	unsigned char	cm[256*2*3];

	(void)pkg_plong( &rbuf[0*NET_LONG_LEN], fb_rmap( fbp, &map ) );
	for( i = 0; i < 256; i++ ) {
		(void)pkg_pshort( cm+2*(0+i), map.cm_red[i] );
		(void)pkg_pshort( cm+2*(256+i), map.cm_green[i] );
		(void)pkg_pshort( cm+2*(512+i), map.cm_blue[i] );
	}
	pkg_send( MSG_DATA, cm, sizeof(cm), pcp );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/*
 *			R F B W M A P
 *
 *  Accept a color map sent by the client, and write it to the framebuffer.
 *  Network format is to send each entry as a network (IBM) order 2-byte
 *  short, 256 red shorts, followed by 256 green and 256 blue, for a total
 *  of 3*256*2 bytes.
 */
void
rfbwmap(struct pkg_conn *pcp, char *buf)
{
	int	i;
	char	rbuf[NET_LONG_LEN+1];
	long	ret;
	ColorMap map;

	if( pcp->pkc_len == 0 )
		ret = fb_wmap( fbp, COLORMAP_NULL );
	else {
		for( i = 0; i < 256; i++ ) {
			map.cm_red[i] = pkg_gshort( buf+2*(0+i) );
			map.cm_green[i] = pkg_gshort( buf+2*(256+i) );
			map.cm_blue[i] = pkg_gshort( buf+2*(512+i) );
		}
		ret = fb_wmap( fbp, &map );
	}
	(void)pkg_plong( &rbuf[0], ret );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbflush(struct pkg_conn *pcp, char *buf)
{
	int	ret;
	char	rbuf[NET_LONG_LEN+1];

	ret = fb_flush( fbp );

	if( pcp->pkc_type < MSG_NORETURN ) {
		(void)pkg_plong( rbuf, ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

void
rfbpoll(struct pkg_conn *pcp, char *buf)
{
	(void)fb_poll( fbp );
	if( buf ) (void)free(buf);
}

/*
 *  At one time at least we couldn't send a zero length PKG
 *  message back and forth, so we receive a dummy long here.
 */
void
rfbhelp(struct pkg_conn *pcp, char *buf)
{
	long	ret;
	char	rbuf[NET_LONG_LEN+1];

	(void)pkg_glong( &buf[0*NET_LONG_LEN] );

	ret = fb_help(fbp);
	(void)pkg_plong( &rbuf[0], ret );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}
@


1.16
log
@change conf.h to a wrapped config.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/fbserv.c,v 1.15 2004/04/05 09:09:11 morrison Exp $ (ARL)";
@


1.15
log
@merge of ansi-6-0-branch into HEAD
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d31 5
a35 1
#include "conf.h"
@


1.14
log
@update copyright to include span through 2003
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/fbserv.c,v 1.13 2002/08/20 17:08:23 jra Exp $ (ARL)";
d52 1
a52 1
void set_port();
d59 6
a64 6
LOCAL_STATIC void new_client();
LOCAL_STATIC void drop_client();
LOCAL_STATIC void new_client_handler();
LOCAL_STATIC void existing_client_handler();
LOCAL_STATIC void comm_error();
LOCAL_STATIC void setup_socket();
d71 1
a71 2
new_client(pcp)
struct pkg_conn	*pcp;
d101 1
a101 2
drop_client(sub)
int sub;
d119 1
a119 1
set_port()
d203 1
a203 3
new_client_handler(clientData, mask)
ClientData clientData;
int mask;
d230 1
a230 3
existing_client_handler(clientData, mask)
ClientData clientData;
int mask;
d283 1
a283 2
setup_socket(fd)
int	fd;
d321 1
a321 2
comm_error(str)
char *str;
d330 1
a330 3
pkgfoo(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d339 1
a339 3
rfbopen(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d360 1
a360 3
rfbclose(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d382 1
a382 3
rfbfree(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d395 1
a395 3
rfbclear(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d412 1
a412 3
rfbread(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d445 1
a445 3
rfbwrite(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d469 1
a469 3
rfbreadrect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d509 1
a509 3
rfbwriterect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d537 1
a537 3
rfbbwreadrect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d577 1
a577 3
rfbbwwriterect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d602 1
a602 3
rfbcursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d617 1
a617 3
rfbgetcursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d633 1
a633 3
rfbsetcursor(pcp, buf)
struct pkg_conn *pcp;
char		*buf;
d657 1
a657 3
rfbscursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d673 1
a673 3
rfbwindow(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d688 1
a688 3
rfbzoom(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d702 1
a702 3
rfbview(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d720 1
a720 3
rfbgetview(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d737 1
a737 3
rfbrmap(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d742 1
a742 1
	char	cm[256*2*3];
d764 1
a764 3
rfbwmap(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d787 1
a787 3
rfbflush(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d802 1
a802 3
rfbpoll(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d813 1
a813 3
rfbhelp(pcp, buf)
struct pkg_conn *pcp;
char *buf;
@


1.13
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1995 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/fbserv.c,v 1.11 2000/11/01 21:16:10 mike Exp $ (ARL)";
@


1.13.4.1
log
@sync to HEAD...
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/fbserv.c,v 1.14 2004/02/02 17:39:32 morrison Exp $ (ARL)";
@


1.13.10.1
log
@merge from HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/fbserv.c,v 1.14 2004/02/02 17:39:32 morrison Exp $ (ARL)";
@


1.13.10.2
log
@merge from head
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/fbserv.c,v 1.13.10.1 2004/02/12 18:34:14 erikg Exp $ (ARL)";
@


1.13.2.1
log
@Initial ANSIfication
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/fbserv.c,v 1.13 2002/08/20 17:08:23 jra Exp $ (ARL)";
d52 1
a52 1
void set_port(void);
d59 6
a64 6
LOCAL_STATIC void new_client(struct pkg_conn *pcp);
LOCAL_STATIC void drop_client(int sub);
LOCAL_STATIC void new_client_handler(ClientData clientData, int mask);
LOCAL_STATIC void existing_client_handler(ClientData clientData, int mask);
LOCAL_STATIC void comm_error(char *str);
LOCAL_STATIC void setup_socket(int fd);
d71 2
a72 1
new_client(struct pkg_conn *pcp)
d102 2
a103 1
drop_client(int sub)
d121 1
a121 1
set_port(void)
d205 3
a207 1
new_client_handler(ClientData clientData, int mask)
d234 3
a236 1
existing_client_handler(ClientData clientData, int mask)
d289 2
a290 1
setup_socket(int fd)
d328 2
a329 1
comm_error(char *str)
d338 3
a340 1
pkgfoo(struct pkg_conn *pcp, char *buf)
d349 3
a351 1
rfbopen(struct pkg_conn *pcp, char *buf)
d372 3
a374 1
rfbclose(struct pkg_conn *pcp, char *buf)
d396 3
a398 1
rfbfree(struct pkg_conn *pcp, char *buf)
d411 3
a413 1
rfbclear(struct pkg_conn *pcp, char *buf)
d430 3
a432 1
rfbread(struct pkg_conn *pcp, char *buf)
d465 3
a467 1
rfbwrite(struct pkg_conn *pcp, char *buf)
d491 3
a493 1
rfbreadrect(struct pkg_conn *pcp, char *buf)
d533 3
a535 1
rfbwriterect(struct pkg_conn *pcp, char *buf)
d563 3
a565 1
rfbbwreadrect(struct pkg_conn *pcp, char *buf)
d605 3
a607 1
rfbbwwriterect(struct pkg_conn *pcp, char *buf)
d632 3
a634 1
rfbcursor(struct pkg_conn *pcp, char *buf)
d649 3
a651 1
rfbgetcursor(struct pkg_conn *pcp, char *buf)
d667 3
a669 1
rfbsetcursor(struct pkg_conn *pcp, char *buf)
d693 3
a695 1
rfbscursor(struct pkg_conn *pcp, char *buf)
d711 3
a713 1
rfbwindow(struct pkg_conn *pcp, char *buf)
d728 3
a730 1
rfbzoom(struct pkg_conn *pcp, char *buf)
d744 3
a746 1
rfbview(struct pkg_conn *pcp, char *buf)
d764 3
a766 1
rfbgetview(struct pkg_conn *pcp, char *buf)
d783 3
a785 1
rfbrmap(struct pkg_conn *pcp, char *buf)
d790 1
a790 1
	unsigned char	cm[256*2*3];
d812 3
a814 1
rfbwmap(struct pkg_conn *pcp, char *buf)
d837 3
a839 1
rfbflush(struct pkg_conn *pcp, char *buf)
d854 3
a856 1
rfbpoll(struct pkg_conn *pcp, char *buf)
d867 3
a869 1
rfbhelp(struct pkg_conn *pcp, char *buf)
@


1.13.2.2
log
@sync branch with HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


1.12
log
@Converted from K&R to ANSI C - RFH
@
text
@d52 1
a52 1
void set_port(void);
d59 6
a64 6
LOCAL_STATIC void new_client(struct pkg_conn *pcp);
LOCAL_STATIC void drop_client(int sub);
LOCAL_STATIC void new_client_handler(ClientData clientData, int mask);
LOCAL_STATIC void existing_client_handler(ClientData clientData, int mask);
LOCAL_STATIC void comm_error(char *str);
LOCAL_STATIC void setup_socket(int fd);
d71 2
a72 1
new_client(struct pkg_conn *pcp)
d102 2
a103 1
drop_client(int sub)
d121 1
a121 1
set_port(void)
d205 3
a207 1
new_client_handler(ClientData clientData, int mask)
d234 3
a236 1
existing_client_handler(ClientData clientData, int mask)
d289 2
a290 1
setup_socket(int fd)
d328 2
a329 1
comm_error(char *str)
d338 3
a340 1
pkgfoo(struct pkg_conn *pcp, char *buf)
d349 3
a351 1
rfbopen(struct pkg_conn *pcp, char *buf)
d372 3
a374 1
rfbclose(struct pkg_conn *pcp, char *buf)
d396 3
a398 1
rfbfree(struct pkg_conn *pcp, char *buf)
d411 3
a413 1
rfbclear(struct pkg_conn *pcp, char *buf)
d430 3
a432 1
rfbread(struct pkg_conn *pcp, char *buf)
d465 3
a467 1
rfbwrite(struct pkg_conn *pcp, char *buf)
d491 3
a493 1
rfbreadrect(struct pkg_conn *pcp, char *buf)
d533 3
a535 1
rfbwriterect(struct pkg_conn *pcp, char *buf)
d563 3
a565 1
rfbbwreadrect(struct pkg_conn *pcp, char *buf)
d605 3
a607 1
rfbbwwriterect(struct pkg_conn *pcp, char *buf)
d632 3
a634 1
rfbcursor(struct pkg_conn *pcp, char *buf)
d649 3
a651 1
rfbgetcursor(struct pkg_conn *pcp, char *buf)
d667 3
a669 1
rfbsetcursor(struct pkg_conn *pcp, char *buf)
d693 3
a695 1
rfbscursor(struct pkg_conn *pcp, char *buf)
d711 3
a713 1
rfbwindow(struct pkg_conn *pcp, char *buf)
d728 3
a730 1
rfbzoom(struct pkg_conn *pcp, char *buf)
d744 3
a746 1
rfbview(struct pkg_conn *pcp, char *buf)
d764 3
a766 1
rfbgetview(struct pkg_conn *pcp, char *buf)
d783 3
a785 1
rfbrmap(struct pkg_conn *pcp, char *buf)
d790 1
a790 1
	unsigned char	cm[256*2*3];
d812 3
a814 1
rfbwmap(struct pkg_conn *pcp, char *buf)
d837 3
a839 1
rfbflush(struct pkg_conn *pcp, char *buf)
d854 3
a856 1
rfbpoll(struct pkg_conn *pcp, char *buf)
d867 3
a869 1
rfbhelp(struct pkg_conn *pcp, char *buf)
@


1.11
log
@
lint
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/fbserv.c,v 1.10 2000/08/19 03:10:45 mike Exp $ (ARL)";
d52 1
a52 1
void set_port();
d59 6
a64 6
LOCAL_STATIC void new_client();
LOCAL_STATIC void drop_client();
LOCAL_STATIC void new_client_handler();
LOCAL_STATIC void existing_client_handler();
LOCAL_STATIC void comm_error();
LOCAL_STATIC void setup_socket();
d71 1
a71 2
new_client(pcp)
struct pkg_conn	*pcp;
d101 1
a101 2
drop_client(sub)
int sub;
d119 1
a119 1
set_port()
d203 1
a203 3
new_client_handler(clientData, mask)
ClientData clientData;
int mask;
d230 1
a230 3
existing_client_handler(clientData, mask)
ClientData clientData;
int mask;
d283 1
a283 2
setup_socket(fd)
int	fd;
d321 1
a321 2
comm_error(str)
char *str;
d330 1
a330 3
pkgfoo(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d339 1
a339 3
rfbopen(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d360 1
a360 3
rfbclose(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d382 1
a382 3
rfbfree(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d395 1
a395 3
rfbclear(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d412 1
a412 3
rfbread(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d445 1
a445 3
rfbwrite(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d469 1
a469 3
rfbreadrect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d509 1
a509 3
rfbwriterect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d537 1
a537 3
rfbbwreadrect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d577 1
a577 3
rfbbwwriterect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d602 1
a602 3
rfbcursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d617 1
a617 3
rfbgetcursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d633 1
a633 3
rfbsetcursor(pcp, buf)
struct pkg_conn *pcp;
char		*buf;
d657 1
a657 3
rfbscursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d673 1
a673 3
rfbwindow(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d688 1
a688 3
rfbzoom(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d702 1
a702 3
rfbview(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d720 1
a720 3
rfbgetview(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d737 1
a737 3
rfbrmap(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d742 1
a742 1
	char	cm[256*2*3];
d764 1
a764 3
rfbwmap(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d787 1
a787 3
rfbflush(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d802 1
a802 3
rfbpoll(pcp, buf)
struct pkg_conn *pcp;
char *buf;
d813 1
a813 3
rfbhelp(pcp, buf)
struct pkg_conn *pcp;
char *buf;
@


1.10
log
@
const RCSid
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/fbserv.c,v 1.9 2000/02/07 21:44:54 mike Exp $ (ARL)";
d296 1
a296 1
    bu_log("setsockopt (SO_KEEPALIVE): %m");
d302 1
a302 1
    int	m, n;
d317 1
a317 1
      bu_log("setup_socket: setsockopt()");
@


1.9
log
@
Fix compiler warnings.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/fbserv.c,v 1.8 1999/03/18 18:03:18 bparker Exp $ (ARL)";
@


1.8
log
@*- initialize netfd to -1
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/fbserv.c,v 1.7 1998/11/06 22:32:40 bparker Exp $ (ARL)";
d209 1
a209 1
  int fd = (int)clientData;
d239 1
a239 1
  int fd = (int)clientData;
@


1.7
log
@*- use new structures
*- cleanup
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/fbserv.c,v 1.6 1998/06/27 04:29:19 mike Exp $ (ARL)";
d54 12
a65 6
static void new_client();
static void drop_client();
static void new_client_handler();
static void existing_client_handler();
static void comm_error();
static void setup_socket();
d70 1
a70 1
static void
d101 1
a101 1
static void
d128 1
a128 1
  if(netfd > 0){
d135 1
a135 1
    netfd = 0;
d204 1
a204 1
static void
d233 1
a233 1
static void
d288 1
a288 1
static void
d327 1
a327 1
static void
@


1.6
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/fbserv.c,v 1.5 1998/06/11 14:28:11 bparker Exp $ (ARL)";
d74 1
a74 1
    if(clients[i].fd != 0)
d78 2
a79 2
    clients[i].pkg = pcp;
    clients[i].fd = pcp->pkc_fd;
d82 2
a83 2
    Tcl_CreateFileHandler(clients[i].fd, TCL_READABLE,
			  existing_client_handler, (ClientData)clients[i].fd);
d99 3
a101 3
  if(clients[sub].pkg != PKC_NULL)  {
    pkg_close(clients[sub].pkg);
    clients[sub].pkg = PKC_NULL;
d104 4
a107 4
  if(clients[sub].fd != 0)  {
    Tcl_DeleteFileHandler(clients[sub].fd);
    close(clients[sub].fd);
    clients[sub].fd = 0;
d132 1
a132 1
  if(!mged_variables->listen)
d135 2
a136 2
  if(!mged_variables->fb){
    mged_variables->listen = 0;
d143 3
a145 3
  save_port = mged_variables->port;
  if(mged_variables->port < 0)
    mged_variables->port = 0;
d149 2
a150 2
    if(mged_variables->port < 1024)
      sprintf(portname,"%d", mged_variables->port + 5559);
d152 1
a152 1
      sprintf(portname,"%d", mged_variables->port);
d158 1
a158 1
      ++mged_variables->port;
d163 3
a165 3
  if(mged_variables->port < 0){
    mged_variables->listen = 0;
    bu_log("set_port: invalid port number - %d\n", mged_variables->port);
d169 2
a170 2
  if(mged_variables->port < 1024)
     sprintf(portname,"%d", mged_variables->port + 5559);
d172 1
a172 1
    sprintf(portname,"%d", mged_variables->port);
d178 2
a179 2
    bu_log("set_port: failed to hang a listen on port %d\n", mged_variables->port);
    mged_variables->listen = 0;
d186 2
a187 2
    mged_variables->port = save_port;
    mged_variables->listen = 0;
d189 1
a189 1
	   mged_variables->port, mged_variables->port + MAX_PORT_TRIES - 1);
d208 1
a208 1
    if(fd == dlp->_netfd)
d240 1
a240 1
      if(fd == dlp->_clients[i].fd)
d252 1
a252 1
    if(clients[i].fd == 0)
d255 1
a255 1
    if((npp = pkg_process(clients[i].pkg)) < 0)
d261 1
a261 1
    if(clients[i].fd != fd)
d264 1
a264 1
    if(pkg_suckin(clients[i].pkg) <= 0){
d271 1
a271 1
    if((npp = pkg_process(clients[i].pkg)) < 0)
@


1.5
log
@*- remove the following ifdefs:
	USE_FRAMEBUFFER, DO_SNAP_TO_GRID, DO_RUBBER_BAND, USE_RT_ASPECT
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/fbserv.c,v 1.4 1998/02/26 16:25:01 bparker Exp $ (ARL)";
d528 72
@


1.4
log
@*- mods necessary to move to Tcl 8.0
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/fbserv.c,v 1.3 1998/02/20 23:16:11 bparker Exp bparker $ (ARL)";
a30 1
#ifdef USE_FRAMEBUFFER
a802 1
#endif
@


1.3
log
@*- code to find a port number
*- stop using fb_busy_flag
*- cause redraw only after receiving more data
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/fbserv.c,v 1.2 1998/01/28 16:03:05 bparker Exp bparker $ (ARL)";
d83 2
a84 3
    Tcl_CreateFileHandler(Tcl_GetFile((ClientData)clients[i].fd, TCL_UNIX_FD),
			  TCL_READABLE, existing_client_handler,
			  (ClientData)clients[i].fd);
d106 1
a106 2
    Tcl_DeleteFileHandler(Tcl_GetFile((ClientData)clients[sub].fd, TCL_UNIX_FD));
    Tcl_FreeFile(Tcl_GetFile((ClientData)clients[sub].fd, TCL_UNIX_FD));
d128 1
a128 2
    Tcl_DeleteFileHandler(Tcl_GetFile((ClientData)netfd, TCL_UNIX_FD));
    Tcl_FreeFile(Tcl_GetFile((ClientData)netfd, TCL_UNIX_FD));
d192 2
a193 2
    Tcl_CreateFileHandler(Tcl_GetFile((ClientData)netfd, TCL_UNIX_FD),
			  TCL_READABLE, new_client_handler, (ClientData)netfd);
@


1.2
log
@*- mods to set_port()
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/fbserv.c,v 1.1 1998/01/16 21:55:23 bparker Exp bparker $ (ARL)";
d45 1
a45 1

a61 2
int fb_busy_flag = 0;

d121 1
d144 23
d187 1
d189 8
a196 2
  Tcl_CreateFileHandler(Tcl_GetFile((ClientData)netfd, TCL_UNIX_FD),
			TCL_READABLE, new_client_handler, (ClientData)netfd);
a225 2

  ++fb_busy_flag;
d238 1
d259 1
a259 1
    if(pkg_process(clients[i].pkg) < 0){
d261 3
a263 1
    }
a270 1
      --fb_busy_flag;
d275 1
a275 1
    if(pkg_process(clients[i].pkg) < 0){
d277 3
a279 1
    }
@


1.1
log
@Initial revision
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbserv/RCS/fbserv.c,v 11.7 1997/09/23 21:38:47 bparker Exp $ (ARL)";
d139 5
@
