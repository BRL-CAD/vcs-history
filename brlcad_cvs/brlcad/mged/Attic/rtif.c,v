head	11.109;
access;
symbols
	ansi-20040405-merged:11.101.2.3
	postmerge-20040405-ansi:11.107
	premerge-20040404-ansi:11.106
	postmerge-autoconf:11.106
	autoconf-freeze:11.103.6.4
	premerge-autoconf:11.106
	postmerge-20040315-windows:11.106
	premerge-20040315-windows:11.105
	windows-20040315-freeze:11.101.4.4
	autoconf-20031203:11.103.6.1
	autoconf-20031202:11.103
	autoconf-branch:11.103.0.6
	phong-branch:11.103.0.4
	photonmap-branch:11.103.0.2
	rel-6-1-DP:11.101
	windows-branch:11.101.0.4
	rel-6-0-2:11.98
	ansi-branch:11.101.0.2
	rel-6-0-1-branch:11.98.0.2
	hartley-6-0-post:11.100
	hartley-6-0-pre:11.99
	rel-6-0-1:11.98
	rel-6-0:11.98
	rel-5-4:11.80.2.4
	offsite-5-3-pre:11.90
	rel-5-3:11.80.2.4
	rel-5-2:11.80
	rel-5-1-branch:11.80.0.2
	rel-5-1:11.80
	rel-5-0:11.72
	rel-5-0-beta:11.65
	rel-4-5:11.52
	ctj-4-5-post:11.42
	ctj-4-5-pre:11.42
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.109
date	2004.05.21.17.47.49;	author morrison;	state dead;
branches;
next	11.108;

11.108
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.107;

11.107
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.106;

11.106
date	2004.03.16.21.15.12;	author morrison;	state Exp;
branches;
next	11.105;

11.105
date	2004.02.02.17.39.35;	author morrison;	state Exp;
branches;
next	11.104;

11.104
date	2003.12.01.16.19.55;	author morrison;	state Exp;
branches;
next	11.103;

11.103
date	2003.04.11.04.43.08;	author morrison;	state Exp;
branches
	11.103.6.1;
next	11.102;

11.102
date	2003.04.10.20.32.49;	author morrison;	state Exp;
branches;
next	11.101;

11.101
date	2002.08.20.17.08.25;	author jra;	state Exp;
branches
	11.101.2.1
	11.101.4.1;
next	11.100;

11.100
date	2002.08.15.20.55.37;	author hartley;	state Exp;
branches;
next	11.99;

11.99
date	2002.08.11.02.10.44;	author morrison;	state Exp;
branches;
next	11.98;

11.98
date	2001.11.14.18.49.26;	author bparker;	state Exp;
branches;
next	11.97;

11.97
date	2001.06.05.15.51.42;	author bparker;	state Exp;
branches;
next	11.96;

11.96
date	2001.06.01.19.23.25;	author bparker;	state Exp;
branches;
next	11.95;

11.95
date	2001.05.02.17.14.01;	author bparker;	state Exp;
branches;
next	11.94;

11.94
date	2001.04.02.21.38.20;	author morrison;	state Exp;
branches;
next	11.93;

11.93
date	2001.03.31.01.57.23;	author morrison;	state Exp;
branches;
next	11.92;

11.92
date	2001.03.26.19.15.55;	author bparker;	state Exp;
branches;
next	11.91;

11.91
date	2001.03.19.22.20.02;	author butler;	state Exp;
branches;
next	11.90;

11.90
date	2001.01.23.14.30.59;	author jra;	state Exp;
branches;
next	11.89;

11.89
date	2001.01.05.15.54.45;	author bparker;	state Exp;
branches;
next	11.88;

11.88
date	2000.11.16.21.20.29;	author bparker;	state Exp;
branches;
next	11.87;

11.87
date	2000.10.26.19.05.52;	author bparker;	state Exp;
branches;
next	11.86;

11.86
date	2000.10.24.19.05.08;	author mike;	state Exp;
branches;
next	11.85;

11.85
date	2000.10.20.05.08.34;	author mike;	state Exp;
branches;
next	11.84;

11.84
date	2000.10.20.05.04.39;	author mike;	state Exp;
branches;
next	11.83;

11.83
date	2000.09.06.21.14.50;	author mike;	state Exp;
branches;
next	11.82;

11.82
date	2000.08.19.03.10.17;	author mike;	state Exp;
branches;
next	11.81;

11.81
date	2000.08.16.21.46.19;	author mike;	state Exp;
branches;
next	11.80;

11.80
date	2000.06.13.16.24.54;	author bparker;	state Exp;
branches
	11.80.2.1;
next	11.79;

11.79
date	2000.02.17.16.34.03;	author mike;	state Exp;
branches;
next	11.78;

11.78
date	2000.02.01.20.20.07;	author mike;	state Exp;
branches;
next	11.77;

11.77
date	2000.01.21.21.52.45;	author butler;	state Exp;
branches;
next	11.76;

11.76
date	99.12.30.19.34.15;	author jra;	state Exp;
branches;
next	11.75;

11.75
date	99.12.27.18.51.26;	author bparker;	state Exp;
branches;
next	11.74;

11.74
date	99.12.01.14.06.35;	author bparker;	state Exp;
branches;
next	11.73;

11.73
date	99.10.29.17.26.30;	author bparker;	state Exp;
branches;
next	11.72;

11.72
date	99.09.13.14.22.09;	author bparker;	state Exp;
branches;
next	11.71;

11.71
date	99.09.09.19.42.57;	author bparker;	state Exp;
branches;
next	11.70;

11.70
date	99.09.08.21.04.26;	author bparker;	state Exp;
branches;
next	11.69;

11.69
date	99.09.01.18.55.11;	author bparker;	state Exp;
branches;
next	11.68;

11.68
date	99.08.16.14.42.59;	author bparker;	state Exp;
branches;
next	11.67;

11.67
date	99.07.02.22.18.38;	author mike;	state Exp;
branches;
next	11.66;

11.66
date	99.06.11.20.16.55;	author bparker;	state Exp;
branches;
next	11.65;

11.65
date	99.04.02.14.56.19;	author pjt;	state Exp;
branches;
next	11.64;

11.64
date	99.03.29.19.48.27;	author bparker;	state Exp;
branches;
next	11.63;

11.63
date	99.03.18.17.59.43;	author bparker;	state Exp;
branches;
next	11.62;

11.62
date	99.01.27.19.17.51;	author bparker;	state Exp;
branches;
next	11.61;

11.61
date	99.01.21.18.31.20;	author bparker;	state Exp;
branches;
next	11.60;

11.60
date	98.11.06.22.32.42;	author bparker;	state Exp;
branches;
next	11.59;

11.59
date	98.10.21.16.29.34;	author bparker;	state Exp;
branches;
next	11.58;

11.58
date	98.06.11.19.41.48;	author bparker;	state Exp;
branches;
next	11.57;

11.57
date	98.03.19.17.54.31;	author bparker;	state Exp;
branches;
next	11.56;

11.56
date	98.03.06.22.36.45;	author bparker;	state Exp;
branches;
next	11.55;

11.55
date	98.03.03.19.13.31;	author bparker;	state Exp;
branches;
next	11.54;

11.54
date	98.02.26.16.25.28;	author bparker;	state Exp;
branches;
next	11.53;

11.53
date	98.02.20.23.18.33;	author bparker;	state Exp;
branches;
next	11.52;

11.52
date	98.02.06.22.04.57;	author bparker;	state Exp;
branches;
next	11.51;

11.51
date	98.01.28.16.17.49;	author bparker;	state Exp;
branches;
next	11.50;

11.50
date	98.01.16.21.59.10;	author bparker;	state Exp;
branches;
next	11.49;

11.49
date	97.12.23.14.20.08;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	97.12.17.23.38.56;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	97.12.17.23.37.28;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	97.12.04.14.50.06;	author bparker;	state Exp;
branches;
next	11.45;

11.45
date	97.09.08.18.36.46;	author bparker;	state Exp;
branches;
next	11.44;

11.44
date	97.08.22.22.38.22;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.42;

11.42
date	97.05.22.19.49.38;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.40;

11.40
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	97.02.14.08.52.06;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	97.02.06.22.04.41;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	97.01.29.03.41.35;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	97.01.10.17.19.11;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	97.01.02.19.33.14;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	96.10.04.15.06.23;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	96.10.03.20.41.05;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	96.10.01.17.26.29;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	96.09.30.19.49.28;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	96.09.25.20.16.42;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	96.09.23.18.21.14;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	96.08.28.22.24.53;	author cnuzman;	state Exp;
branches;
next	11.26;

11.26
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	96.08.21.14.14.43;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	96.07.31.00.19.20;	author cnuzman;	state Exp;
branches;
next	11.23;

11.23
date	96.07.15.20.36.08;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.06.21.16.08.21;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	96.06.06.13.59.02;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	96.03.22.18.33.05;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	96.03.08.18.32.51;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	96.03.01.19.28.39;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	95.12.27.22.31.29;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	95.08.02.21.33.54;	author gdurf;	state Exp;
branches;
next	11.12;

11.12
date	95.07.25.17.53.49;	author gdurf;	state Exp;
branches;
next	11.11;

11.11
date	95.07.20.14.14.48;	author pjt;	state Exp;
branches;
next	11.10;

11.10
date	95.07.20.14.04.40;	author gdurf;	state Exp;
branches;
next	11.9;

11.9
date	95.07.12.16.53.34;	author pjt;	state Exp;
branches;
next	11.8;

11.8
date	95.07.11.19.14.14;	author pjt;	state Exp;
branches;
next	11.7;

11.7
date	95.07.10.20.09.55;	author pjt;	state Exp;
branches;
next	11.6;

11.6
date	95.07.07.20.17.47;	author pjt;	state Exp;
branches;
next	11.5;

11.5
date	95.06.13.16.15.49;	author pjt;	state Exp;
branches;
next	11.4;

11.4
date	95.03.10.20.47.06;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.01.17.13.05.01;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.01.09.16.51.31;	author gdurf;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.31;	author mike;	state Rel4_4;
branches;
next	10.30;

10.30
date	94.12.23.23.02.09;	author gdurf;	state Exp;
branches;
next	10.29;

10.29
date	94.12.23.23.01.31;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	94.12.16.20.33.48;	author gdurf;	state Exp;
branches;
next	10.27;

10.27
date	94.12.16.19.37.17;	author gdurf;	state Exp;
branches;
next	10.26;

10.26
date	94.11.05.03.52.12;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	94.10.18.00.10.56;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	94.08.25.17.53.04;	author gdurf;	state Exp;
branches;
next	10.23;

10.23
date	94.08.24.19.09.25;	author gdurf;	state Exp;
branches;
next	10.22;

10.22
date	94.08.24.18.41.26;	author gdurf;	state Exp;
branches;
next	10.21;

10.21
date	94.08.24.18.38.46;	author gdurf;	state Exp;
branches;
next	10.20;

10.20
date	94.08.02.18.08.34;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	94.08.02.14.31.30;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	94.06.03.17.33.14;	author gdurf;	state Exp;
branches;
next	10.17;

10.17
date	94.06.01.17.07.45;	author gdurf;	state Exp;
branches;
next	10.16;

10.16
date	94.04.06.00.09.40;	author cjohnson;	state Exp;
branches;
next	10.15;

10.15
date	94.04.05.19.10.05;	author cjohnson;	state Exp;
branches;
next	10.14;

10.14
date	94.03.30.19.35.47;	author cjohnson;	state Exp;
branches;
next	10.13;

10.13
date	94.03.18.01.36.12;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	93.09.25.11.57.52;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	93.03.24.05.29.27;	author phil;	state Exp;
branches;
next	10.10;

10.10
date	93.03.24.04.04.43;	author phil;	state Exp;
branches;
next	10.9;

10.9
date	92.11.23.20.53.56;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.11.23.19.37.37;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.11.23.18.53.43;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.11.23.18.14.45;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.09.03.19.54.21;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.09.03.19.19.06;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.06.05.21.12.09;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.04.18.01.04.01;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.15;	author mike;	state Rel4_0;
branches;
next	9.11;

9.11
date	91.07.02.08.38.35;	author pjt;	state Exp;
branches;
next	9.10;

9.10
date	91.06.25.16.05.11;	author pjt;	state Exp;
branches;
next	9.9;

9.9
date	91.03.01.16.14.31;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.02.02.00.01.52;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.12.07.01.01.16;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.11.11.04.51.32;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.11.04.06.35.50;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.05.24.04.17.43;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.12.29.12.44.32;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.12.28.15.40.12;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.03.43;	author mike;	state Rel3_5;
branches;
next	8.7;

8.7
date	89.04.06.20.18.17;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.02.11.04.03.04;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.01.09.05.10.22;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	88.12.28.22.03.56;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	88.12.06.02.48.07;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.02.31.54;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.37.18;	author mike;	state Rel3_0;
branches;
next	1.4;

1.4
date	88.09.17.02.33.12;	author reschly;	state Exp;
branches;
next	1.3;

1.3
date	88.05.15.23.05.18;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.02.27.01.21.36;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.02.26.22.57.35;	author mike;	state Exp;
branches;
next	;

11.80.2.1
date	2000.10.26.19.06.45;	author bparker;	state Exp;
branches;
next	11.80.2.2;

11.80.2.2
date	2000.11.15.21.31.19;	author bparker;	state Exp;
branches;
next	11.80.2.3;

11.80.2.3
date	2001.01.05.15.12.32;	author jra;	state Exp;
branches;
next	11.80.2.4;

11.80.2.4
date	2001.01.05.15.53.52;	author bparker;	state Exp;
branches;
next	;

11.101.2.1
date	2002.09.19.18.02.04;	author morrison;	state Exp;
branches;
next	11.101.2.2;

11.101.2.2
date	2004.03.17.21.22.04;	author morrison;	state Exp;
branches;
next	11.101.2.3;

11.101.2.3
date	2004.04.02.16.11.41;	author morrison;	state Exp;
branches;
next	;

11.101.4.1
date	2002.09.26.23.04.13;	author morrison;	state Exp;
branches;
next	11.101.4.2;

11.101.4.2
date	2004.03.11.23.46.36;	author morrison;	state Exp;
branches;
next	11.101.4.3;

11.101.4.3
date	2004.03.12.10.01.19;	author morrison;	state Exp;
branches;
next	11.101.4.4;

11.101.4.4
date	2004.03.12.17.37.44;	author morrison;	state Exp;
branches;
next	;

11.103.6.1
date	2003.12.03.17.56.00;	author erikg;	state Exp;
branches;
next	11.103.6.2;

11.103.6.2
date	2004.02.12.18.34.15;	author erikg;	state Exp;
branches;
next	11.103.6.3;

11.103.6.3
date	2004.03.15.14.07.39;	author erikg;	state Exp;
branches;
next	11.103.6.4;

11.103.6.4
date	2004.03.18.18.10.31;	author erikg;	state Exp;
branches;
next	;


desc
@RT interfaces for the MGED program
@


11.109
log
@moved to src/mged/
@
text
@/*
 *			R T I F . C
 *
 *  Routines to interface to RT, and RT-style command files
 *
 * Functions -
 *	f_rt		ray-trace
 *	f_rrt		ray-trace using any program
 *	f_rtcheck	ray-trace to check for overlaps
 *	f_saveview	save the current view parameters
 *	f_loadview	load view parameters from a saveview file
 *	f_rmats		load views from a file
 *	f_savekey	save keyframe in file
 *	f_nirt          trace a single ray from current view
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/rtif.c,v 11.108 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#include <signal.h>
#ifndef WIN32
#  include <sys/time.h>		/* For struct timeval */
#endif
#include <sys/stat.h>		/* for chmod() */

#include "tcl.h"

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "externs.h"
#include "mater.h"
#include "./sedit.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./mged_dm.h"
#include "./mgedtcl.h"
#include "./qray.h"
#include "./cmd.h"

#ifdef WIN32
#  include <fcntl.h>
#endif

extern int mged_svbase(void);
extern void set_perspective(); /* from set.c */

#ifdef WIN32
#  include <fcntl.h>
#endif

/* from ged.c -- used to open databases quietly */
extern int interactive;

static void setup_rt(register char **vp, int printcmd);

static int tree_walk_needed;
struct run_rt head_run_rt;

struct rtcheck {
#ifdef WIN32
	HANDLE			fd;
	HANDLE			hProcess;
	DWORD			pid;
#  ifdef TCL_OK
	Tcl_Channel		chan;
#  else
	genptr_t chan;
#  endif
#else
       int			fd;    
       int			pid;
#endif
	   FILE			*fp;
       struct bn_vlblock	*vbp;
       struct bu_list		*vhead;
       double			csize;  
};
//Tcl_Channel chan;
#ifdef TCL_OK
	Tcl_Channel chan1;
#else
	genptr_t chan1;
#endif

static vect_t	rtif_eye_model;
static mat_t	rtif_viewrot;
static struct bn_vlblock	*rtif_vbp;
static FILE	*rtif_fp;
static double	rtif_delay;
static struct _mged_variables    rtif_saved_state;       /* saved state variables */
static int	rtif_mode;
static int	rtif_desiredframe;
static int	rtif_finalframe;
static int	rtif_currentframe;

extern int	cm_start();
extern int	cm_vsize();
extern int	cm_eyept();
extern int	cm_lookat_pt();
extern int	cm_vrot();
extern int	cm_end();
extern int	cm_multiview();
extern int	cm_anim();
extern int	cm_tree();
extern int	cm_clean();
extern int	cm_set();
extern int	cm_ae();
extern int	cm_orientation();
extern int	cm_null();

/* here we define a minimal table of commands that are supported by the
 * loadview command.  unsupported commands are those that have no bearing on
 * view restoration. 
 */
struct command_tab view_cmdtab[] = {
	{"viewsize", "size in mm", "set view size",
		cm_vsize,	2, 2},
	{"eye_pt", "xyz of eye", "set eye point",
		cm_eyept,	4, 4},
	{"lookat_pt", "x y z [yflip]", "set eye look direction, in X-Y plane",
		cm_lookat_pt,	4, 5},
	{"viewrot", "4x4 matrix", "set view direction from matrix",
		cm_vrot,	17,17},
	{"orientation", "quaturnion", "set view direction from quaturnion",
		cm_orientation,	5, 5},
	{"set", 	"", "show or set parameters",
		cm_set,		1, 999},

	/* begin unsupported commands (for view loading) */

	{"start", "frame number", "start a new frame",
		cm_null,	2, 2},
	{"clean", "", "clean articulation from previous frame",
		cm_null,	1, 1},
	{"end", 	"", "end of frame setup, begin raytrace",
		cm_null,		1, 1},

	/* not output, by default in saveview */

	{"multiview", "", "produce stock set of views",
		cm_null,	1, 1},
	{"anim", 	"path type args", "specify articulation animation",
		cm_null,	4, 999},
	{"tree", 	"treetop(s)", "specify alternate list of tree tops",
		cm_null,	1, 999},
	{"ae", "azim elev", "specify view as azim and elev, in degrees",
		cm_null,		3, 3},
	{"opt", "-flags", "set flags, like on command line",
		cm_null,		2, 999},

	/* this is a quick hack used for quietly parsing the EOF delimiter in the
	 * script files. 
	 */
	{"EOF", "", "End of file delimiter",
		cm_null,		1, 1},

	/* XXX support for the ae command is not included, though it probably should */
	{(char *)0, (char *)0, (char *)0,
	        0,		0, 0	/* END */}
};


/*
 *			P R _ W A I T _ S T A T U S
 *
 *  Interpret the status return of a wait() system call,
 *  for the edification of the watching luser.
 *  Warning:  This may be somewhat system specific, most especially
 *  on non-UNIX machines.
 */
void
pr_wait_status(int status)
{
  int	sig = status & 0x7f;
  int	core = status & 0x80;
  int	ret = status >> 8;
  struct bu_vls tmp_vls;

  if( status == 0 )  {
    Tcl_AppendResult(interp, "Normal exit\n", (char *)NULL);
    return;
  }

  bu_vls_init(&tmp_vls);
  bu_vls_printf(&tmp_vls, "Abnormal exit x%x", status);

  if( core )
    bu_vls_printf(&tmp_vls, ", core dumped");

  if( sig )
    bu_vls_printf(&tmp_vls, ", terminating signal = %d", sig );
  else
    bu_vls_printf(&tmp_vls, ", return (exit) code = %d", ret );

  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), "\n", (char *)NULL);
  bu_vls_free(&tmp_vls);
}

/*
 *  			R T _ O L D W R I T E
 *  
 *  Write out the information that RT's -M option needs to show current view.
 *  Note that the model-space location of the eye is a parameter,
 *  as it can be computed in different ways.
 *  The is the OLD format, needed only when sending to RT on a pipe,
 *  due to some oddball hackery in RT to determine old -vs- new format.
 */
HIDDEN void
rt_oldwrite(FILE *fp, fastf_t *eye_model)
{
	register int i;

	(void)fprintf(fp, "%.9e\n", view_state->vs_vop->vo_size);
	(void)fprintf(fp, "%.9e %.9e %.9e\n",
		eye_model[X], eye_model[Y], eye_model[Z] );
	for( i=0; i < 16; i++ )  {
		(void)fprintf(fp, "%.9e ", view_state->vs_vop->vo_rotation[i]);
		if( (i%4) == 3 )
			(void)fprintf(fp, "\n");
	}
	(void)fprintf(fp, "\n");
}

/*
 *  			R T _ W R I T E
 *  
 *  Write out the information that RT's -M option needs to show current view.
 *  Note that the model-space location of the eye is a parameter,
 *  as it can be computed in different ways.
 */
HIDDEN void
rt_write(FILE *fp, fastf_t *eye_model)
{
	register int	i;
	quat_t		quat;
	register struct solid *sp;

	(void)fprintf(fp, "viewsize %.15e;\n", view_state->vs_vop->vo_size);
	quat_mat2quat(quat, view_state->vs_vop->vo_rotation);
	(void)fprintf(fp, "orientation %.15e %.15e %.15e %.15e;\n", V4ARGS(quat));
	(void)fprintf(fp, "eye_pt %.15e %.15e %.15e;\n",
		eye_model[X], eye_model[Y], eye_model[Z] );

	(void)fprintf(fp, "start 0; clean;\n");
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		for (i=0;i<sp->s_fullpath.fp_len;i++) {
			DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_flags &= ~DIR_USED;
		}
	}
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		for (i=0; i<sp->s_fullpath.fp_len; i++ ) {
			struct directory *dp;
			dp = DB_FULL_PATH_GET(&sp->s_fullpath,i);
			if (!(dp->d_flags & DIR_USED)) {
				register struct animate *anp;
				for (anp = dp->d_animate; anp;
				    anp=anp->an_forw) {
					db_write_anim(fp, anp);
				}
				dp->d_flags |= DIR_USED;
			}
		}
	}

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		for (i=0;i<sp->s_fullpath.fp_len;i++) {
			DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_flags &= ~DIR_USED;
		}
	}
#undef DIR_USED
	(void)fprintf(fp, "end;\n");
}

/*
 *  			R T _ R E A D
 *  
 *  Read in one view in the old RT format.
 */
HIDDEN int
rt_read(FILE *fp, fastf_t *scale, fastf_t *eye, fastf_t *mat)
{
	register int i;
	double d;

	if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
	*scale = d*0.5;
	if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
	eye[X] = d;
	if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
	eye[Y] = d;
	if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
	eye[Z] = d;
	for( i=0; i < 16; i++ )  {
		if( fscanf( fp, "%lf", &d ) != 1 )
			return(-1);
		mat[i] = d;
	}
	return(0);
}

/*			B U I L D _ T O P S
 *
 *  Build a command line vector of the tops of all objects in view.
 */
int
build_tops(char **start, char **end)
{
	register char **vp = start;
	register struct solid *sp;

	/*
	 * Find all unique top-level entries.
	 *  Mark ones already done with s_wflag == UP
	 */
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
		register struct solid *forw;
		struct directory *dp = FIRST_SOLID(sp);

		if( sp->s_wflag == UP )
			continue;
		if( dp->d_addr == RT_DIR_PHONY_ADDR )
			continue;	/* Ignore overlays, predictor, etc */
		if( vp < end )
			*vp++ = dp->d_namep;
		else  {
		  Tcl_AppendResult(interp, "mged: ran out of comand vector space at ",
				   dp->d_namep, "\n", (char *)NULL);
		  break;
		}
		sp->s_wflag = UP;
		for(BU_LIST_PFOR(forw, sp, solid, &dgop->dgo_headSolid)){
			if( FIRST_SOLID(forw) == dp )
				forw->s_wflag = UP;
		}
	}
	*vp = (char *) 0;
	return vp-start;
}
/*
 *			S E T U P _ R T
 *
 *  Set up command line for one of the RT family of programs,
 *  with all objects in view enumerated.
 */
static char	*rt_cmd_vec[MAXARGS];
static int	rt_cmd_vec_len;
static char	rt_cmd_storage[MAXARGS*9];

static void
setup_rt(register char **vp, int printcmd)
{
  rt_cmd_vec_len = vp - rt_cmd_vec;
  rt_cmd_vec_len += build_tops(vp, &rt_cmd_vec[MAXARGS]);

  if(printcmd){
    /* Print out the command we are about to run */
    vp = &rt_cmd_vec[0];
    while( *vp )
      Tcl_AppendResult(interp, *vp++, " ", (char *)NULL);

    Tcl_AppendResult(interp, "\n", (char *)NULL);
  }
}

int
cmd_rtabort(ClientData clientData,
	     Tcl_Interp *interp,
	     int argc,
	     char **argv)
{
	return dgo_rtabort_cmd(dgop, interp, argc, argv);
}

#ifndef WIN32
static void
rt_output_handler(ClientData clientData, int mask)
{
	struct run_rt *run_rtp = (struct run_rt *)clientData;
	int count;
	char line[RT_MAXLINE+1];

	/* Get data from rt */
	if ((count = read((int)run_rtp->fd, line, RT_MAXLINE)) == 0) {
		int retcode;
		int rpid;
		int aborted;

		Tcl_DeleteFileHandler(run_rtp->fd);
		close(run_rtp->fd);

		/* wait for the forked process */
		while ((rpid = wait(&retcode)) != run_rtp->pid && rpid != -1)
			pr_wait_status(retcode);

		aborted = run_rtp->aborted;

		/* free run_rtp */
 		BU_LIST_DEQUEUE(&run_rtp->l);
		bu_free((genptr_t)run_rtp, "rt_output_handler: run_rtp");

		if (aborted)
			bu_log("Raytrace aborted.\n");
		else
			bu_log("Raytrace complete.\n");
		return;
	}

	line[count] = '\0';

	/*XXX For now just blather to stderr */
	bu_log("%s", line);
}
#else
void
rt_output_handler(ClientData clientData, int mask)
{
	struct run_rt *run_rtp = (struct run_rt *)clientData;
	int count;
#if 0
	char line[RT_MAXLINE+1];

	/* Get data from rt */
	if ((!ReadFile(run_rtp->fd, line, RT_MAXLINE,&count,0))) {
#else
	char line[5120+1];
	

	/* Get data from rt */
	if ((!ReadFile(run_rtp->fd, line, 5120,&count,0))) {
#endif
		int aborted;

		Tcl_DeleteChannelHandler(run_rtp->chan,rt_output_handler,(ClientData)run_rtp);
		CloseHandle(run_rtp->fd);

		/* wait for the forked process */

		WaitForSingleObject( run_rtp->hProcess, INFINITE );
		
		if(GetLastError() == ERROR_PROCESS_ABORTED)
		{
			run_rtp->aborted = 1; 
		}

		aborted = run_rtp->aborted;

		/* free run_rtp */
 		BU_LIST_DEQUEUE(&run_rtp->l);
		bu_free((genptr_t)run_rtp, "rt_output_handler: run_rtp");

		if (aborted)
			bu_log("Raytrace aborted.\n");
		else
			bu_log("Raytrace complete.\n");
		return;
	}

	line[count] = '\0';

	/*XXX For now just blather to stderr */
	bu_log("%s", line);
}
#endif

static void
rt_set_eye_model(fastf_t *eye_model)
{
  if(dmp->dm_zclip || mged_variables->mv_perspective_mode){
    vect_t temp;

    VSET( temp, 0.0, 0.0, 1.0 );
    MAT4X3PNT(eye_model, view_state->vs_vop->vo_view2model, temp);
  }else{ /* not doing zclipping, so back out of geometry */
    register struct solid *sp;
    register int i;
    double  t;
    double  t_in;
    vect_t  direction;
    vect_t  extremum[2];
    vect_t  minus, plus;    /* vers of this solid's bounding box */

    VSET(eye_model, -view_state->vs_vop->vo_center[MDX],
	 -view_state->vs_vop->vo_center[MDY], -view_state->vs_vop->vo_center[MDZ]);

    for (i = 0; i < 3; ++i){
      extremum[0][i] = INFINITY;
      extremum[1][i] = -INFINITY;
    }
    FOR_ALL_SOLIDS (sp, &dgop->dgo_headSolid){
      minus[X] = sp->s_center[X] - sp->s_size;
      minus[Y] = sp->s_center[Y] - sp->s_size;
      minus[Z] = sp->s_center[Z] - sp->s_size;
      VMIN( extremum[0], minus );
      plus[X] = sp->s_center[X] + sp->s_size;
      plus[Y] = sp->s_center[Y] + sp->s_size;
      plus[Z] = sp->s_center[Z] + sp->s_size;
      VMAX( extremum[1], plus );
    }
    VMOVEN(direction, view_state->vs_vop->vo_rotation + 8, 3);
    VSCALE(direction, direction, -1.0);
    for(i = 0; i < 3; ++i)
      if (NEAR_ZERO(direction[i], 1e-10))
	direction[i] = 0.0;
    if ((eye_model[X] >= extremum[0][X]) &&
	(eye_model[X] <= extremum[1][X]) &&
	(eye_model[Y] >= extremum[0][Y]) &&
	(eye_model[Y] <= extremum[1][Y]) &&
	(eye_model[Z] >= extremum[0][Z]) &&
	(eye_model[Z] <= extremum[1][Z])){
      t_in = -INFINITY;
      for(i = 0; i < 6; ++i){
	if (direction[i%3] == 0)
	  continue;
	t = (extremum[i/3][i%3] - eye_model[i%3]) /
	  direction[i%3];
	if ((t < 0) && (t > t_in))
	  t_in = t;
      }
      VJOIN1(eye_model, eye_model, t_in, direction);
    }
  }
}

#ifndef WIN32
/*
 *			R U N _ R T
 */
int
run_rt(void)
{
	register struct solid *sp;
	register int i;
	FILE *fp_in;
	int pipe_in[2];
	int pipe_err[2];
	vect_t eye_model;
	int		pid; 	 
	struct run_rt	*run_rtp;

	(void)pipe( pipe_in );
	(void)pipe( pipe_err );
	(void)signal( SIGINT, SIG_IGN );
	if ((pid = fork()) == 0) {
	  /* make this a process group leader */
	  setpgid(0, 0);

	  /* Redirect stdin and stderr */
	  (void)close(0);
	  (void)dup( pipe_in[0] );
	  (void)close(2);
	  (void)dup ( pipe_err[1] );

	  /* close pipes */
	  (void)close(pipe_in[0]);
	  (void)close(pipe_in[1]);
	  (void)close(pipe_err[0]);
	  (void)close(pipe_err[1]);

	  for( i=3; i < 20; i++ )
	    (void)close(i);

	  (void)signal( SIGINT, SIG_DFL );
	  (void)execvp( rt_cmd_vec[0], rt_cmd_vec );
	  perror( rt_cmd_vec[0] );
	  exit(16);
	}

	/* As parent, send view information down pipe */
	(void)close( pipe_in[0] );
	fp_in = fdopen( pipe_in[1], "w" );

	(void)close( pipe_err[1] );

	rt_set_eye_model(eye_model);
	rt_write(fp_in, eye_model);
	(void)fclose( fp_in );

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;

	BU_GETSTRUCT(run_rtp, run_rt);
	BU_LIST_APPEND(&head_run_rt.l, &run_rtp->l);
	run_rtp->fd = pipe_err[0];
	run_rtp->pid = pid;

	Tcl_CreateFileHandler(run_rtp->fd, TCL_READABLE,
			      rt_output_handler, (ClientData)run_rtp);

	return 0;
}
#else
run_rt()
{
	register struct solid *sp;
	register int i;
	FILE *fp_in;
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	vect_t eye_model;
	struct run_rt	*run_rtp;

   STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   SECURITY_ATTRIBUTES sa          = {0};
   char line[2048];
   char name[256];

    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_err[1];
   si.hStdError   = pipe_err[1];


   sprintf(line,"%s ",rt_cmd_vec[0]);
   for(i=1;i<rt_cmd_vec_len;i++) {
	   sprintf(name,"%s ",rt_cmd_vec[i]);
	   strcat(line,name); }
	   

   if(CreateProcess( NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStderr);
}


	/* As parent, send view information down pipe */
	CloseHandle(pipe_in[0]);
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	CloseHandle(pipe_err[1]);


	rt_set_eye_model(eye_model);
	rt_write(fp_in, eye_model);
	(void)fclose( fp_in );

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;

	BU_GETSTRUCT(run_rtp, run_rt);
	BU_LIST_APPEND(&head_run_rt.l, &run_rtp->l);
	run_rtp->fd = pipe_errDup;
	run_rtp->hProcess = pi.hProcess;
	run_rtp->pid = pi.dwProcessId;
	run_rtp->aborted=0;

	run_rtp->chan = Tcl_MakeFileChannel(run_rtp->fd,TCL_READABLE);
	Tcl_CreateChannelHandler(run_rtp->chan,TCL_READABLE,
			      rt_output_handler, (ClientData)run_rtp);

	return 0;
}
#endif

/*
 *			F _ R T
 */
int
cmd_rt(ClientData	clientData,
       Tcl_Interp	*interp,
       int		argc,
       char		**argv)
{
	CHECK_DBI_NULL;

	/* skip past _mged_ */
	if (argv[0][0] == '_' && argv[0][1] == 'm' &&
	    strncmp(argv[0], "_mged_", 6) == 0)
		argv[0] += 6;

	return dgo_rt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
}

/*
 *			F _ R R T
 *
 *  Invoke any program with the current view & stuff, just like
 *  an "rt" command (above).
 *  Typically used to invoke a remote RT (hence the name).
 */
int
f_rrt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register char **vp;
	register int i;

	CHECK_DBI_NULL;

	if(argc < 2 || MAXARGS < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help rrt");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( not_state( ST_VIEW, "Ray-trace of current view" ) )
	  return TCL_ERROR;

	vp = &rt_cmd_vec[0];
	for( i=1; i < argc; i++ )
		*vp++ = argv[i];
	*vp++ = dbip->dbi_filename;

	setup_rt( vp, 1 );
	(void)run_rt();

	return TCL_OK;
}

#if 0
static void
rtcheck_vector_handler(clientData, mask)
ClientData clientData;
int mask;
{
  int value;
  struct solid *sp;
  struct rtcheck *rtcp = (struct rtcheck *)clientData;

  /* Get vector output from rtcheck */
  if ((value = getc(rtcp->fp)) == EOF) {
    int retcode;
    int rpid;

    Tcl_DeleteFileHandler(rtcp->fd);
    fclose(rtcp->fp);

    FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
      sp->s_wflag = DOWN;

    /* Add overlay */
    cvt_vlblock_to_solids( rtcp->vbp, "OVERLAPS", 0 );
    rt_vlblock_free(rtcp->vbp);

    /* wait for the forked process */
    while ((rpid = wait(&retcode)) != rtcp->pid && rpid != -1)
      pr_wait_status(retcode);

    /* free rtcp */
    bu_free((genptr_t)rtcp, "rtcheck_vector_handler: rtcp");

    update_views = 1;
    return;
  }

  (void)rt_process_uplot_value( &rtcp->vhead,
				rtcp->vbp,
				rtcp->fp,
				value,
				rtcp->csize );
}

static void
rtcheck_output_handler(clientData, mask)
ClientData clientData;
int mask;
{
  int count;
  char line[RT_MAXLINE];
  int fd = (int)((long)clientData & 0xFFFF);	/* fd's will be small */

  /* Get textual output from rtcheck */
#if 0
  if((count = read((int)fd, line, RT_MAXLINE)) == 0){
#else
  if((count = read((int)fd, line, 5120)) == 0){
#endif
    Tcl_DeleteFileHandler(fd);
    close(fd);

    return;
  }

  line[count] = '\0';
  bu_log("%s", line);
}
#endif

int
cmd_rtcheck(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	CHECK_DBI_NULL;

	return dgo_rtcheck_cmd(dgop, view_state->vs_vop, interp, argc, argv);
}


/*
 *			B A S E N A M E
 *  
 *  Return basename of path, removing leading slashes and trailing suffix.
 */
HIDDEN char *
basename(register char *p1, register char *suff)
{
	register char *p2, *p3;
	static char buf[128];

	p2 = p1;
	while (*p1) {
		if (*p1++ == '/')
			p2 = p1;
	}
	for(p3=suff; *p3; p3++) 
		;
	while(p1>p2 && p3>suff)
		if(*--p3 != *--p1)
			return(p2);
	strncpy( buf, p2, p1-p2 );
	return(buf);
}

/*
 *			F _ S A V E V I E W
 *
 *  Create a shell script to ray-trace this view.
 *  Any arguments to this command are passed as arguments to RT
 *  in the generated shell script
 */
int
f_saveview(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register struct solid *sp;
	register int i;
	register FILE *fp;
	char *base;

	CHECK_DBI_NULL;

	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help saveview");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( (fp = fopen( argv[1], "a")) == NULL )  {
	  perror(argv[1]);
	  return TCL_ERROR;
	}

	base = basename( argv[1], ".sh" );
	(void)chmod( argv[1], 0755 );	/* executable */
	/* Do not specify -v option to rt; batch jobs must print everything. -Mike */
	(void)fprintf(fp, "#!/bin/sh\nrt -M ");
	if( view_state->vs_vop->vo_perspective > 0 )
		(void)fprintf(fp, "-p%g ", view_state->vs_vop->vo_perspective);
	for( i=2; i < argc; i++ )
		(void)fprintf(fp,"%s ", argv[i]);
	(void)fprintf(fp,"\\\n -o %s.pix\\\n $*\\\n", base);
	(void)fprintf(fp," %s\\\n ", dbip->dbi_filename);

	/* Find all unique top-level entries.
	 *  Mark ones already done with s_wflag == UP
	 */
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
		register struct solid *forw;	/* XXX */
		struct directory *dp = FIRST_SOLID(sp);

		if( sp->s_wflag == UP )
			continue;
		if (dp->d_addr == RT_DIR_PHONY_ADDR) continue;
		(void)fprintf(fp, "'%s' ", dp->d_namep);
		sp->s_wflag = UP;
		for(BU_LIST_PFOR(forw, sp, solid, &dgop->dgo_headSolid)){
			if( FIRST_SOLID(forw) == dp )
				forw->s_wflag = UP;
		}
	}
	(void)fprintf(fp,"\\\n 2>> %s.log\\\n", base);
	(void)fprintf(fp," <<EOF\n");

	{
	  vect_t eye_model;

	  rt_set_eye_model(eye_model);
	  rt_write(fp, eye_model);
	}

	(void)fprintf(fp,"\nEOF\n");
	(void)fclose( fp );
	
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;

	return TCL_OK;
}


/*
 *			F _ L O A D V I E W
 *
 *  Load a ray-trace view shell script.  If a database is not open, the 
 *  database listed in the script will attempted to be opened.  If a 
 *  database is open, it must match (inode) the one in the saveview
 *  raytrace script for it to get used.
 *
 *  The actual raytrace functionality is ignored in scripts -- only the view
 *  is intended to be restored, if possible.
 */
int
f_loadview(ClientData clientData, Tcl_Interp *interp, int argc, char *argv[])
{
	register FILE *fp;
	char buffer[512];

	/* data pulled from script file */
	int perspective=-1;
	char dbName[512];
	char objects[1024];
	char *editArgv[3];

	/* save previous interactive state */
	int prevInteractive = interactive;
	int prevPerspective =  mged_variables->mv_perspective;

	/* inodes used for database comparisons */
	struct stat dbInode;
	struct stat scriptInode;

#if 0
	/* for view orientation */
	vect_t xlate;
	mat_t new_cent;
	
	double viewsize;
	double orientation[4]={0.0, 0.0, 0.0, 0.0};
	vect_t eye_pt={0.0, 0.0, 0.0};
#endif

	/* We do not need to check *here* if a database is open, since we will be
	 * loading one anyways.  we manually check when/if we find the database name.
	 */
	/*	CHECK_DBI_NULL; */

	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help loadview");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* open the file for reading */
	if ( (fp = fopen( argv[1], "r" )) == NULL ) {
		perror(argv[1]);
		return TCL_ERROR;
	}

	/* turn perspective mode off, by default.  A "-p" option in the
	 * view script will turn it back on.
	 */
	mged_variables->mv_perspective=-1;
	set_perspective();

	/* iterate over the contents of the raytrace script */
	while (!feof(fp)) {
		memset(buffer, 0, 512);
		fscanf(fp, "%s", buffer);

		if (strncmp(buffer, "-p", 2)==0) {
		  /* we found perspective */

		  buffer[0]=' ';
		  buffer[1]=' ';
		  sscanf(buffer, "%d", &perspective);
		  /*      bu_log("perspective=%d\n", perspective);*/
		  mged_variables->mv_perspective=perspective;
		  /* !!! this does not update the menu variable.. */	
		  set_perspective(); 

		} else if (strncmp(buffer, "$*", 2)==0) {
		  /* the next read is the file name, the objects come
		   * after that 
		   */

		  memset(dbName, 0, 1024);
		  fscanf(fp, "%s", dbName);
		  /* if the last character is a line termination, 
		   * remove it (it should always be unless the user
		   * modifies the file)
		   */
		  if ( *(dbName + strlen(dbName) - 1)=='\\' ) {
		    memset(dbName+strlen(dbName)-1, 0, 1);
		  }
		  /*      bu_log("dbName=%s\n", dbName); */
		  
		  /* if no database is open, we attempt to open the
		   * database listed in the script.  if a database is
		   * open, we compare the open database's inode number
		   * with the inode of the database listed in the script.
		   * If they match, we may proceed. otherwise we need
		   * to abort since the wrong database would be open.
		   */
		  if ( dbip == DBI_NULL ) {
		    /* load the database */

		    /* XXX could use better path handling instead of
		     * assuming rooted or . */
		    
		    /* turn off interactive mode so the f_opendb() call
		     * doesn't blather or attempt to create a new database
		     */
		    interactive=0;
		    editArgv[0]="";
		    editArgv[1]=dbName;
		    editArgv[2]=(char *)NULL;
		    if (f_opendb( (ClientData)NULL, interp, 2, editArgv ) == TCL_ERROR) {
		      Tcl_AppendResult(interp, "Unable to load database: ", dbName, "\n", (char *)NULL);
		      
		      /* restore state before leaving */
		      mged_variables->mv_perspective=prevPerspective;
		      set_perspective();

		      return TCL_ERROR;
		    } else {
		      Tcl_AppendResult(interp, "Loading database: ", dbName, "\n", (char *)NULL);
		    }
		    interactive=prevInteractive;
		    
		  } else {
		    /* compare inode numbers */
		    
		    stat(dbip->dbi_filename, &dbInode);
		    stat(dbName, &scriptInode);
		    
		    /* stop here if they are not the same file, otherwise,
		     * we may proceed as expected, and load the objects.
		     */
		    if (dbInode.st_ino != scriptInode.st_ino) {
		      Tcl_AppendResult(interp, "View script references a different database\nCannot load the view without closing the current database\n(i.e. run \"opendb ", dbName, "\")\n", (char *)NULL);
		      
		      /* restore state before leaving */
		      mged_variables->mv_perspective=prevPerspective;
		      set_perspective();
		      
		      return TCL_ERROR;
		    }
		    
		  }
		  /* end check for loaded database */
		  
		  /* get rid of anything that may be displayed, since we
		   * will load objects that are listed in the script next.
		   */
		  (void)cmd_zap( (ClientData)NULL, interp, 1, NULL );

		  /* now get the objects listed */
		  fscanf(fp, "%s", objects);
		  /*		  bu_log("OBJECTS=%s\n", objects);*/
		  while ((!feof(fp)) && (strncmp(objects, "\\", 1)!=0)) {

		    /* clean off the single quotes... */
		    if (strncmp(objects, "'", 1)==0) {
		      objects[0]=' ';
		      memset(objects+strlen(objects)-1, ' ', 1);
		      sscanf(objects, "%s", objects);
		    }

		    editArgv[0] = "e";
		    editArgv[1] = objects;
		    editArgv[2] = (char *)NULL;
		    if (edit_com( 2, editArgv, 1, 1 ) != 0) {
		      Tcl_AppendResult(interp, "Unable to load object: ", objects, "\n", (char *)NULL);
		    }
		    
		    /* bu_log("objects=%s\n", objects);*/
		    fscanf(fp, "%s", objects);
		  }

		  /* end iteration over reading in listed objects */
		} else if (strncmp(buffer, "<<EOF", 5)==0) {
		  char *cmdBuffer = NULL;
		  /* we are almost done .. read in the view commands */
			
		  while ( (cmdBuffer = rt_read_cmd( fp )) != NULL ) {
		    /* even unsupported commands should return successfully as
		     * they should be calling cm_null()
		     */
		    if ( rt_do_cmd( (struct rt_i *)0, cmdBuffer, view_cmdtab ) < 0 ) { 
		      Tcl_AppendResult(interp, "command failed: ", cmdBuffer, "\n", (char *)NULL);
		    }
		    bu_free( (genptr_t)cmdBuffer, "loadview cmdBuffer" );
		  }
		  /* end iteration over rt commands */

		}
		/* end check for non-view values (dbname, etc) */

	}
	/* end iteration over file until eof */
	fclose(fp);

	/* now we have to finish the eye point calculations that usually get
	 * postponed until the end command runs.  Since we are at the "end"
	 * of a commands section, we may finish the computations.
	 */
	/* First step:  put eye at view center (view 0,0,0) */
	MAT_COPY(view_state->vs_vop->vo_rotation, rtif_viewrot);
	MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, rtif_eye_model);
	new_mats(); /* actually updates display here (maybe?) */
	
	/* XXX not sure why the correction factor is needed, but it works -- csm */
	/*  Second step:  put eye at view 0,0,1.
	 *  For eye to be at 0,0,1, the old 0,0,-1 needs to become 0,0,0.
	VSET(xlate, 0.0, 0.0, -1.0);
	MAT4X3PNT(new_cent, view_state->vs_vop->vo_view2model, xlate);
	MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, new_cent);
	new_mats();
	 */

	/* update the view next time through the event loop */
	update_views = 1;

	return TCL_OK;
}


/*
 *			F _ R M A T S
 *
 * Load view matrixes from a file.  rmats filename [mode]
 *
 * Modes:
 *	-1	put eye in viewcenter (default)
 *	0	put eye in viewcenter, don't rotate.
 *	1	leave view alone, animate solid named "EYE"
 */
int
f_rmats(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register FILE *fp;
	register struct directory *dp;
	register struct solid *sp;
	vect_t	eye_model;
	vect_t	xlate;
	vect_t	sav_center;
	vect_t	sav_start;
	int	mode;
	fastf_t	scale;
	mat_t	rot;
	register struct bn_vlist *vp;

	CHECK_DBI_NULL;

	if(argc < 2 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help rmats");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( not_state( ST_VIEW, "animate from matrix file") )
	  return TCL_ERROR;

	if( (fp = fopen(argv[1], "r")) == NULL )  {
	  perror(argv[1]);
	  return TCL_ERROR;
	}

	sp = SOLID_NULL;

	mode = -1;
	if( argc > 2 )
		mode = atoi(argv[2]);
	switch(mode)  {
	case 1:
		if( (dp = db_lookup(dbip, "EYE", LOOKUP_NOISY)) == DIR_NULL )  {
			mode = -1;
			break;
		}
		FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
			if( LAST_SOLID(sp) != dp )  continue;
			if( BU_LIST_IS_EMPTY( &(sp->s_vlist) ) )  continue;
			vp = BU_LIST_LAST( bn_vlist, &(sp->s_vlist) );
			VMOVE( sav_start, vp->pt[vp->nused-1] );
			VMOVE( sav_center, sp->s_center );
			Tcl_AppendResult(interp, "animating EYE solid\n", (char *)NULL);
			goto work;
		}
		/* Fall through */
	default:
	case -1:
	  mode = -1;
	  Tcl_AppendResult(interp, "default mode:  eyepoint at (0,0,1) viewspace\n", (char *)NULL);
	  break;
	case 0:
	  Tcl_AppendResult(interp, "rotation supressed, center is eyepoint\n", (char *)NULL);
	  break;
	}
work:
#if 0
	/* If user hits ^C, this will stop, but will leave hanging filedes */
	(void)signal(SIGINT, cur_sigint);
#else
        if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else
	  return TCL_OK;
#endif
	while( !feof( fp ) &&
	    rt_read( fp, &scale, eye_model, rot ) >= 0 )  {
	    	switch(mode)  {
	    	case -1:
	    		/* First step:  put eye in center */
		       	view_state->vs_vop->vo_scale = scale;
		       	MAT_COPY(view_state->vs_vop->vo_rotation, rot);
			MAT_DELTAS(view_state->vs_vop->vo_center,
				-eye_model[X],
				-eye_model[Y],
				-eye_model[Z] );
	    		new_mats();
	    		/* Second step:  put eye in front */
	    		VSET(xlate, 0.0, 0.0, -1.0);	/* correction factor */
	    		MAT4X3PNT(eye_model, view_state->vs_vop->vo_view2model, xlate);
			MAT_DELTAS(view_state->vs_vop->vo_center,
				-eye_model[X],
				-eye_model[Y],
				-eye_model[Z] );
	    		new_mats();
	    		break;
	    	case 0:
		       	view_state->vs_vop->vo_scale = scale;
			MAT_IDN(view_state->vs_vop->vo_rotation);	/* top view */
			MAT_DELTAS( view_state->vs_vop->vo_center,
				-eye_model[X],
				-eye_model[Y],
				-eye_model[Z] );
			new_mats();
	    		break;
	    	case 1:
	    		/* Adjust center for displaylist devices */
	    		VMOVE( sp->s_center, eye_model );

	    		/* Adjust vector list for non-dl devices */
	    		if( BU_LIST_IS_EMPTY( &(sp->s_vlist) ) )  break;
			vp = BU_LIST_LAST( bn_vlist, &(sp->s_vlist) );
	    		VSUB2( xlate, eye_model, vp->pt[vp->nused-1] );
			for( BU_LIST_FOR( vp, bn_vlist, &(sp->s_vlist) ) )  {
				register int	i;
				register int	nused = vp->nused;
				register int	*cmd = vp->cmd;
				register point_t *pt = vp->pt;
				for( i = 0; i < nused; i++,cmd++,pt++ )  {
					switch( *cmd )  {
					case BN_VLIST_POLY_START:
					case BN_VLIST_POLY_VERTNORM:
						break;
					case BN_VLIST_LINE_MOVE:
					case BN_VLIST_LINE_DRAW:
					case BN_VLIST_POLY_MOVE:
					case BN_VLIST_POLY_DRAW:
					case BN_VLIST_POLY_END:
						VADD2( *pt, *pt, xlate );
						break;
					}
				}
			}
	    		break;
	    	}
		view_state->vs_flag = 1;
		refresh();	/* Draw new display */
	}
	if( mode == 1 )  {
    		VMOVE( sp->s_center, sav_center );
		if( BU_LIST_NON_EMPTY( &(sp->s_vlist) ) )  {
			vp = BU_LIST_LAST( bn_vlist, &(sp->s_vlist) );
	    		VSUB2( xlate, sav_start, vp->pt[vp->nused-1] );
			for( BU_LIST_FOR( vp, bn_vlist, &(sp->s_vlist) ) )  {
				register int	i;
				register int	nused = vp->nused;
				register int	*cmd = vp->cmd;
				register point_t *pt = vp->pt;
				for( i = 0; i < nused; i++,cmd++,pt++ )  {
					switch( *cmd )  {
					case BN_VLIST_POLY_START:
					case BN_VLIST_POLY_VERTNORM:
						break;
					case BN_VLIST_LINE_MOVE:
					case BN_VLIST_LINE_DRAW:
					case BN_VLIST_POLY_MOVE:
					case BN_VLIST_POLY_DRAW:
					case BN_VLIST_POLY_END:
						VADD2( *pt, *pt, xlate );
						break;
					}
				}
			}
		}
	}

	fclose(fp);
	(void)mged_svbase();

	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
}

/* Save a keyframe to a file */
int
f_savekey(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register FILE *fp;
	fastf_t	time;
	vect_t	eye_model;
	vect_t temp;

	if(argc < 2 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help savekey");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( (fp = fopen( argv[1], "a")) == NULL )  {
	  perror(argv[1]);
	  return TCL_ERROR;
	}
	if( argc > 2 ) {
	  time = atof( argv[2] );
	  (void)fprintf(fp,"%f\n", time);
	}
	/*
	 *  Eye is in conventional place.
	 */
	VSET( temp, 0.0, 0.0, 1.0 );
	MAT4X3PNT(eye_model, view_state->vs_vop->vo_view2model, temp);
	rt_oldwrite(fp, eye_model);
	(void)fclose( fp );

	return TCL_OK;
}

extern int	cm_start(int argc, char **argv);
extern int	cm_vsize(int argc, char **argv);
extern int	cm_eyept(int argc, char **argv);
extern int	cm_lookat_pt(int argc, char **argv);
extern int	cm_vrot(int argc, char **argv);
extern int	cm_end(int argc, char **argv);
extern int	cm_multiview(int argc, char **argv);
extern int	cm_anim(int argc, char **argv);
extern int	cm_tree(int argc, char **argv);
extern int	cm_clean(int argc, char **argv);
extern int	cm_set(int argc, char **argv);
extern int	cm_orientation(int argc, char **argv);

/* table of commands supported by the preview command
 */
static struct command_tab cmdtab[] = {
	{"start", "frame number", "start a new frame",
		cm_start,	2, 2},
	{"viewsize", "size in mm", "set view size",
		cm_vsize,	2, 2},
	{"eye_pt", "xyz of eye", "set eye point",
		cm_eyept,	4, 4},
	{"lookat_pt", "x y z [yflip]", "set eye look direction, in X-Y plane",
		cm_lookat_pt,	4, 5},
	{"orientation", "quaturnion", "set view direction from quaturnion",
		cm_orientation,	5, 5},
	{"viewrot", "4x4 matrix", "set view direction from matrix",
		cm_vrot,	17,17},
	{"end", 	"", "end of frame setup, begin raytrace",
		cm_end,		1, 1},
	{"multiview", "", "produce stock set of views",
		cm_multiview,	1, 1},
	{"anim", 	"path type args", "specify articulation animation",
		cm_anim,	4, 999},
	{"tree", 	"treetop(s)", "specify alternate list of tree tops",
		cm_tree,	1, 999},
	{"clean", "", "clean articulation from previous frame",
		cm_clean,	1, 1},
	{"set", 	"", "show or set parameters",
		cm_set,		1, 999},
	{"ae", "azim elev", "specify view as azim and elev, in degrees",
		cm_null,		3, 3},
	{"opt", "-flags", "set flags, like on command line",
		cm_null,		2, 999},
	{(char *)0, (char *)0, (char *)0,
		0,		0, 0}	/* END */
};


/*
 *			R T I F _ S I G I N T
 *
 *  Called on SIGINT from within preview.
 *  Close things down and abort.
 *
 *  WARNING:  If the ^C happened when bu_free() had already done a bu_semaphore_acquire,
 *  then any further calls to bu_free() will hang.
 *  It isn't clear how to handle this.
 */
static void
rtif_sigint(int num)
{
	if(dbip == DBI_NULL)
	  return;

	write( 2, "rtif_sigint\n", 12);

	/* Restore state variables */
	*mged_variables = rtif_saved_state;	/* struct copy */

	if(rtif_vbp)  {
		rt_vlblock_free(rtif_vbp);
		rtif_vbp = (struct bn_vlblock *)NULL;
	}
	db_free_anim(dbip);	/* Forget any anim commands */
	sig3(num);			/* Call main SIGINT handler */
	/* NOTREACHED */
}


/*
 *			F _ P R E V I E W
 *
 *  Preview a new style RT animation scrtip.
 *  Note that the RT command parser code is used, rather than the
 *  MGED command parser, because of the differences in format.
 *  The RT parser expects command handlers of the form "cm_xxx()",
 *  and all communications are done via global variables.
 *
 *  For the moment, the only preview mode is the normal one,
 *  moving the eyepoint as directed.
 *  However, as a bonus, the eye path is left behind as a vector plot.
 */
int
f_preview(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	char	*cmd;
	int	c;
	vect_t	temp;

	CHECK_DBI_NULL;

	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help preview");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( not_state( ST_VIEW, "animate viewpoint from new RT file") )
	  return TCL_ERROR;

	/* Save any state variables we plan on changing */
	rtif_saved_state = *mged_variables;	/* struct copy */
	mged_variables->mv_autosize = 0;

	rtif_delay = 0;			/* Full speed, by default */
	rtif_mode = 1;			/* wireframe drawing */
	rtif_desiredframe = 0;
	rtif_finalframe = 0;

	/* Parse options */
	bu_optind = 1;			/* re-init bu_getopt() */
	while( (c=bu_getopt(argc,argv,"d:vD:K:")) != EOF )  {
		switch(c)  {
		case 'd':
			rtif_delay = atof(bu_optarg);
			break;
		case 'D':
			rtif_desiredframe = atof(bu_optarg);
			break;
		case 'K':
			rtif_finalframe = atof(bu_optarg);
			break;
		case 'v':
			rtif_mode = 3;	/* Like "ev" */
			break;
		default:
		  {
		    struct bu_vls tmp_vls;

		    bu_vls_init(&tmp_vls);
		    bu_vls_printf(&tmp_vls, "option '%c' unknown\n", c);
		    bu_vls_printf(&tmp_vls, "        -d#     inter-frame delay\n");
		    bu_vls_printf(&tmp_vls, "        -v      polygon rendering (visual)\n");
		    bu_vls_printf(&tmp_vls, "        -D#     desired starting frame\n");
		    bu_vls_printf(&tmp_vls, "        -K#     final frame\n");
		    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		    bu_vls_free(&tmp_vls);
		  }

		  break;
		}
	}
	argc -= bu_optind-1;
	argv += bu_optind-1;

	/* If file is still open from last cmd getting SIGINT, close it */
	if(rtif_fp)  fclose(rtif_fp);
	if( (rtif_fp = fopen(argv[1], "r")) == NULL )  {
	  perror(argv[1]);
	  return TCL_ERROR;
	}

	/* Build list of top-level objects in view, in rt_cmd_vec[] */
	rt_cmd_vec[0] = "tree";
	setup_rt( &rt_cmd_vec[1], 1 );

	rtif_vbp = rt_vlblock_init();

	Tcl_AppendResult(interp, "eyepoint at (0,0,1) viewspace\n", (char *)NULL);

	/*
	 *  Initialize the view to the current one in MGED
	 *  in case a view specification is never given.
	 */
	MAT_COPY(rtif_viewrot, view_state->vs_vop->vo_rotation);
	VSET(temp, 0.0, 0.0, 1.0);
	MAT4X3PNT(rtif_eye_model, view_state->vs_vop->vo_view2model, temp);

	if( setjmp( jmp_env ) == 0 )
	  /* If user hits ^C, preview will stop, and clean up */
	  (void)signal(SIGINT, rtif_sigint);
	else
	  return TCL_OK;

	while( ( cmd = rt_read_cmd( rtif_fp )) != NULL )  {
		/* Hack to prevent running framedone scripts prematurely */
		if( cmd[0] == '!' )  {
			if( rtif_currentframe < rtif_desiredframe ||
			    (rtif_finalframe && rtif_currentframe > rtif_finalframe) )  {
				bu_free( (genptr_t)cmd, "preview ! cmd" );
			    	continue;
			}
		}
		if( rt_do_cmd( (struct rt_i *)0, cmd, cmdtab ) < 0 )
		   Tcl_AppendResult(interp, "command failed: ", cmd,
				    "\n", (char *)NULL);
		bu_free( (genptr_t)cmd, "preview cmd" );
	}
	fclose(rtif_fp);
	rtif_fp = NULL;

	cvt_vlblock_to_solids( rtif_vbp, "EYE_PATH", 0 );
	if(rtif_vbp)  {
		rt_vlblock_free(rtif_vbp);
		rtif_vbp = (struct bn_vlblock *)NULL;
	}
	db_free_anim(dbip);	/* Forget any anim commands */

	/* Restore state variables */
	*mged_variables = rtif_saved_state;	/* struct copy */

	(void)mged_svbase();

	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
}

/*
 *			F _ N I R T
 *
 *  Invoke nirt with the current view & stuff
 */
int
f_nirt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register char **vp;
	FILE *fp_in;
	FILE *fp_out, *fp_err;
	int pid;
	int rpid;
	int retcode;
#ifndef WIN32
	int pipe_in[2];
	int pipe_out[2];
	int pipe_err[2];
#else
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_out[2],hSaveStdout,pipe_outDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	STARTUPINFO si = {0};
	PROCESS_INFORMATION pi = {0};
	SECURITY_ATTRIBUTES sa          = {0};
	char name[1024];
	char line1[2048];
#endif
	int use_input_orig = 0;
	vect_t	center_model;
	vect_t dir;
	vect_t cml;
	register int i;
	register struct solid *sp;
	char line[MAXLINE];
	char *val;
	struct bu_vls vls;
	struct bu_vls o_vls;
	struct bu_vls p_vls;
	struct bu_vls t_vls;
	struct bn_vlblock *vbp;
	struct qray_dataList *ndlp;
	struct qray_dataList HeadQRayData;

	CHECK_DBI_NULL;

	if(argc < 1 || MAXARGS < argc){
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help %s", argv[0]);
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);

	  return TCL_ERROR;
	}

	vp = &rt_cmd_vec[0];
	*vp++ = "nirt";

	/* swipe x, y, z off the end if present */
	if(argc > 3){
	  if(sscanf(argv[argc-3], "%lf", &center_model[X]) == 1 &&
	     sscanf(argv[argc-2], "%lf", &center_model[Y]) == 1 &&
	     sscanf(argv[argc-1], "%lf", &center_model[Z]) == 1){
	    use_input_orig = 1;
	    argc -= 3;
	    VSCALE(center_model, center_model, local2base);
	  }else if(adc_state->adc_draw)
	    *vp++ = "-b";
	}else if(adc_state->adc_draw)
	  *vp++ = "-b";

	if(mged_variables->mv_use_air){
	  *vp++ = "-u";
	  *vp++ = "1";
	}

	/* Calculate point from which to fire ray */
	if(!use_input_orig && adc_state->adc_draw){
	  vect_t  view_ray_orig;

	  VSET(view_ray_orig, (fastf_t)adc_state->adc_dv_x, (fastf_t)adc_state->adc_dv_y, GED_MAX);
	  VSCALE(view_ray_orig, view_ray_orig, INV_GED);
	  MAT4X3PNT(center_model, view_state->vs_vop->vo_view2model, view_ray_orig);
	}else if(!use_input_orig){
	  VSET(center_model, -view_state->vs_vop->vo_center[MDX],
	       -view_state->vs_vop->vo_center[MDY], -view_state->vs_vop->vo_center[MDZ]);
	}

	if( mged_variables->mv_perspective_mode )
	{
		point_t pt, eye;

		/* get eye point */
		VSET(pt, 0.0, 0.0, 1.0);
		MAT4X3PNT(eye, view_state->vs_vop->vo_view2model, pt);
		VSCALE(eye, eye, base2local);

		/* point passed in is actually the aim point */
		VSCALE(cml, center_model, base2local);
		VSUB2(dir, cml, eye);
		VUNITIZE(dir);

		/* copy eye point to cml (cml is used for the "xyz" command to nirt */
		VMOVE(cml, eye);
	} else {
		VSCALE(cml, center_model, base2local);
		VMOVEN(dir, view_state->vs_vop->vo_rotation + 8, 3);
		VSCALE(dir, dir, -1.0);
	}

	bu_vls_init(&p_vls);
	bu_vls_printf(&p_vls, "xyz %lf %lf %lf;",
		cml[X], cml[Y], cml[Z]);
	bu_vls_printf(&p_vls, "dir %lf %lf %lf; s",
		dir[X], dir[Y], dir[Z]);

	i = 0;
	if(QRAY_GRAPHICS){

	  *vp++ = "-e";
	  *vp++ = QRAY_FORMAT_NULL;

	  /* first ray  ---- returns partitions */
	  *vp++ = "-e";
	  *vp++ = QRAY_FORMAT_P;

	  /* ray start, direction, and 's' command */
	  *vp++ = "-e";
	  *vp++ = bu_vls_addr(&p_vls);

	  /* second ray  ---- returns overlaps */
	  *vp++ = "-e";
	  *vp++ = QRAY_FORMAT_O;

	  /* ray start, direction, and 's' command */
	  *vp++ = "-e";
	  *vp++ = bu_vls_addr(&p_vls);

	  if(QRAY_TEXT){
	    char *cp;
	    int count = 0;

	    bu_vls_init(&o_vls);

	    /* get 'r' format now; prepend its' format string with a newline */
	    val = bu_vls_addr(&qray_fmts[0].fmt);

	    /* find first '"' */
	    while(*val != '"' && *val != '\0')
	      ++val;

	    if(*val == '\0')
	      goto done;
	    else
	      ++val;	    /* skip first '"' */

	    /* find last '"' */
	    cp = (char *)strrchr(val, '"');

	    if(cp != (char *)NULL) /* found it */
	      count = cp - val;

done:
#ifndef WIN32
	    if(*val == '\0')
	      bu_vls_printf(&o_vls, " fmt r \"\\n\" ");
	    else{
	      bu_vls_printf(&o_vls, " fmt r \"\\n%*s\" ", count, val);
#else
	      if(*val == '\0')
		bu_vls_printf(&o_vls, " fmt r \\\"\\\\n\\\" ");
	      else	{
		bu_vls_printf(&o_vls, " fmt r \\\"\\\\n%*s\\\" ", count, val);
#endif
	      if(count)
		val += count + 1;
	      bu_vls_printf(&o_vls, "%s", val);
	    }

	    i = 1;

	    *vp++ = "-e";
	    *vp++ = bu_vls_addr(&o_vls);
	  }
	}

	if(QRAY_TEXT){

	  bu_vls_init(&t_vls);

	  /* load vp with formats for printing */
	  for(; qray_fmts[i].type != (char)NULL; ++i)
	    bu_vls_printf(&t_vls, "fmt %c %s; ",
			  qray_fmts[i].type,
			  bu_vls_addr(&qray_fmts[i].fmt));

	  *vp++ = "-e";
	  *vp++ = bu_vls_addr(&t_vls);

	  /* nirt does not like the trailing ';' */
	  bu_vls_trunc(&t_vls, -2);
	}

	/* include nirt script string */
	if (bu_vls_strlen(&qray_script)) {
	  *vp++ = "-e";
	  *vp++ = bu_vls_addr(&qray_script);
	}

        *vp++ = "-e";
        *vp++ = bu_vls_addr(&p_vls);

	for( i=1; i < argc; i++ )
		*vp++ = argv[i];
	*vp++ = dbip->dbi_filename;

	setup_rt( vp, qray_cmd_echo );

	if(use_input_orig){
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "\nFiring from (%lf, %lf, %lf)...\n",
			center_model[X], center_model[Y], center_model[Z]);
	  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	  bu_vls_free(&vls);
	}else if(adc_state->adc_draw)
	  Tcl_AppendResult(interp, "\nFiring through angle/distance cursor...\n",
			   (char *)NULL);
	else
	  Tcl_AppendResult(interp, "\nFiring from view center...\n", (char *)NULL);

#ifndef WIN32
	(void)pipe( pipe_in );
	(void)pipe( pipe_out );
	(void)pipe( pipe_err );
	(void)signal( SIGINT, SIG_IGN );
	if ( ( pid = fork()) == 0 )  {
 	        /* Redirect stdin, stdout, stderr */
		(void)close(0);
		(void)dup( pipe_in[0] );
		(void)close(1);
		(void)dup( pipe_out[1] );
		(void)close(2);
		(void)dup ( pipe_err[1] );

		/* close pipes */
		(void)close(pipe_in[0]);
		(void)close(pipe_in[1]);
		(void)close(pipe_out[0]);
		(void)close(pipe_out[1]);
		(void)close(pipe_err[0]);
		(void)close(pipe_err[1]);
		for( i=3; i < 20; i++ )
			(void)close(i);
		(void)signal( SIGINT, SIG_DFL );
		(void)execvp( rt_cmd_vec[0], rt_cmd_vec );
		perror( rt_cmd_vec[0] );
		exit(16);
	}

	/* use fp_in to feed view info to nirt */
	(void)close( pipe_in[0] );
	fp_in = fdopen( pipe_in[1], "w" );

	/* use fp_out to read back the result */
	(void)close( pipe_out[1] );
	fp_out = fdopen( pipe_out[0], "r" );

	/* use fp_err to read any error messages */
	(void)close( pipe_err[1] );
	fp_err = fdopen( pipe_err[0], "r" );

	/* send quit command to nirt */
	fwrite( "q\n", 1, 2, fp_in );
	(void)fclose( fp_in );
#else
	sa.nLength = sizeof(sa);
	sa.bInheritHandle = TRUE;
	sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_out[0], &pipe_out[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_OUTPUT_HANDLE, pipe_out[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
	DuplicateHandle( GetCurrentProcess(), pipe_out[0],
        GetCurrentProcess(),  &pipe_outDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_out[0] );

	// Save the handle to the current STDERR.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDERR.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDERR.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
	DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
			GetCurrentProcess(), &pipe_inDup, 
			0, FALSE,                  // not inherited       
			DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


	si.cb = sizeof(STARTUPINFO);
	si.lpReserved = NULL;
	si.lpReserved2 = NULL;
	si.cbReserved2 = 0;
	si.lpDesktop = NULL;
	si.dwFlags = 0;
	si.dwFlags = STARTF_USESTDHANDLES;
	si.hStdInput   = pipe_in[0];
	si.hStdOutput  = pipe_out[1];
	si.hStdError   = pipe_err[1];


	sprintf(line1,"%s ",rt_cmd_vec[0]);
	for(i=1;i<rt_cmd_vec_len;i++) {
	  sprintf(name,"%s ",rt_cmd_vec[i]);
	  strcat(line1,name); 
	  if(strstr(name,"-e") != NULL) {
	    i++;
	    sprintf(name,"\"%s\" ",rt_cmd_vec[i]);
	    strcat(line1,name);} 
	}

	if(CreateProcess( NULL, line1, NULL, NULL,TRUE, DETACHED_PROCESS, NULL, NULL, &si, &pi )) {
	  SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	  SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout);
	  SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);
	}
 
	/* use fp_in to feed view info to nirt */
	CloseHandle( pipe_in[0] );
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	//fp_in = fdopen( pipe_in[1], "w" );

	/* use fp_out to read back the result */
	CloseHandle( pipe_out[1] );
	//fp_out = fdopen( pipe_out[0], "r" );
	fp_out = _fdopen( _open_osfhandle((HFILE)pipe_outDup,_O_TEXT), "r" );

	/* use fp_err to read any error messages */
	CloseHandle(pipe_err[1]);
	//fp_err = fdopen( pipe_err[0], "r" );
	fp_err = _fdopen( _open_osfhandle((HFILE)pipe_errDup,_O_TEXT), "r" );

	/* send quit command to nirt */
	fwrite( "q\n", 1, 2, fp_in );
	(void)fclose( fp_in );
#endif

	bu_vls_free(&p_vls);   /* use to form "partition" part of nirt command above */
	if(QRAY_GRAPHICS){

	  if(QRAY_TEXT)
	    bu_vls_free(&o_vls); /* used to form "overlap" part of nirt command above */

	  BU_LIST_INIT(&HeadQRayData.l);

	  /* handle partitions */
	  while(fgets(line, MAXLINE, fp_out) != (char *)NULL){
	    if(line[0] == '\n'){
	      Tcl_AppendResult(interp, line+1, (char *)NULL);
	      break;
	    }

	    BU_GETSTRUCT(ndlp, qray_dataList);
	    BU_LIST_APPEND(HeadQRayData.l.back, &ndlp->l);

	    if(sscanf(line, "%le %le %le %le",
		      &ndlp->x_in, &ndlp->y_in, &ndlp->z_in, &ndlp->los) != 4)
	      break;
	  }

	  vbp = rt_vlblock_init();
	  qray_data_to_vlist(vbp, &HeadQRayData, dir, 0);
	  bu_list_free(&HeadQRayData.l);
	  cvt_vlblock_to_solids(vbp, bu_vls_addr(&qray_basename), 0);
	  rt_vlblock_free(vbp);

	  /* handle overlaps */
	  while(fgets(line, MAXLINE, fp_out) != (char *)NULL){
	    if(line[0] == '\n'){
	      Tcl_AppendResult(interp, line+1, (char *)NULL);
	      break;
	    }

	    BU_GETSTRUCT(ndlp, qray_dataList);
	    BU_LIST_APPEND(HeadQRayData.l.back, &ndlp->l);

	    if(sscanf(line, "%le %le %le %le",
		      &ndlp->x_in, &ndlp->y_in, &ndlp->z_in, &ndlp->los) != 4)
	      break;
	  }
	  vbp = rt_vlblock_init();
	  qray_data_to_vlist(vbp, &HeadQRayData, dir, 1);
	  bu_list_free(&HeadQRayData.l);
	  cvt_vlblock_to_solids(vbp, bu_vls_addr(&qray_basename), 0);
	  rt_vlblock_free(vbp);

	  update_views = 1;
	}

	if(QRAY_TEXT){
	  bu_vls_free(&t_vls);

	  while(fgets(line, MAXLINE, fp_out) != (char *)NULL)
	    Tcl_AppendResult(interp, line, (char *)NULL);
	}

	(void)fclose(fp_out);

	while(fgets(line, MAXLINE, fp_err) != (char *)NULL)
	  Tcl_AppendResult(interp, line, (char *)NULL);
	(void)fclose(fp_err);

#ifndef WIN32

	/* Wait for program to finish */
	while ((rpid = wait(&retcode)) != pid && rpid != -1)
		;	/* NULL */

	if( retcode != 0 )
		pr_wait_status( retcode );
#else
	/* Wait for program to finish */
	WaitForSingleObject( pi.hProcess, INFINITE );

#endif

#if 0
	(void)signal(SIGINT, cur_sigint);
#endif

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;

	return TCL_OK;
}

int
f_vnirt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  register int i;
  int status;
  fastf_t sf = 1.0 * INV_GED;
  vect_t view_ray_orig;
  vect_t center_model;
  struct bu_vls vls;
  struct bu_vls x_vls;
  struct bu_vls y_vls;
  struct bu_vls z_vls;
  char **av;

  CHECK_DBI_NULL;

  if(argc < 3){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  /*
   * The last two arguments are expected to be x,y in view coordinates.
   * It is also assumed that view z will be the front of the viewing cube.
   * These coordinates are converted to x,y,z in model coordinates and then
   * converted to local units before being handed to nirt. All other
   * arguments are passed straight through to nirt.
   */
  if(sscanf(argv[argc-2], "%lf", &view_ray_orig[X]) != 1 ||
     sscanf(argv[argc-1], "%lf", &view_ray_orig[Y]) != 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }
  view_ray_orig[Z] = GED_MAX;
  argc -= 2;

  av = (char **)bu_malloc(sizeof(char *) * (argc + 4), "f_vnirt: av");

  /* Calculate point from which to fire ray */
  VSCALE(view_ray_orig, view_ray_orig, sf);
  MAT4X3PNT(center_model, view_state->vs_vop->vo_view2model, view_ray_orig);
  VSCALE(center_model, center_model, base2local);

  bu_vls_init(&x_vls);
  bu_vls_init(&y_vls);
  bu_vls_init(&z_vls);
  bu_vls_printf(&x_vls, "%lf", center_model[X]);
  bu_vls_printf(&y_vls, "%lf", center_model[Y]);
  bu_vls_printf(&z_vls, "%lf", center_model[Z]);

  /* pass remaining arguments to nirt */
  av[0] = "nirt";
  for(i = 1; i < argc; ++i)
    av[i] = argv[i];

  /* pass modified coordinates to nirt */
  av[i++] = bu_vls_addr(&x_vls);
  av[i++] = bu_vls_addr(&y_vls);
  av[i++] = bu_vls_addr(&z_vls);
  av[i] = (char *)NULL;

  status = f_nirt(clientData, interp, argc + 3, av);

  bu_vls_free(&x_vls);
  bu_vls_free(&y_vls);
  bu_vls_free(&z_vls);
  bu_free((genptr_t)av, "f_vnirt: av");

  return status;
}

int
cm_start(int argc, char **argv)
{
	if( argc < 2 )
		return(-1);
	rtif_currentframe = atoi(argv[1]);
	tree_walk_needed = 0;
	return(0);
}

int
cm_vsize(int argc, char **argv)
{
	if( argc < 2 )
		return(-1);
	/* for some reason, scale is supposed to be half of size... */
	view_state->vs_vop->vo_size = atof(argv[1]);
	view_state->vs_vop->vo_scale = view_state->vs_vop->vo_size * 0.5;
	view_state->vs_vop->vo_invSize = 1.0 / view_state->vs_vop->vo_size;
	return(0);
}

int
cm_eyept(int argc, char **argv)
{
	if( argc < 4 )
		return(-1);
	rtif_eye_model[X] = atof(argv[1]);
	rtif_eye_model[Y] = atof(argv[2]);
	rtif_eye_model[Z] = atof(argv[3]);
	/* Processing is deferred until cm_end() */
	return(0);
}

int
cm_lookat_pt(int argc, char **argv)
{
	point_t	pt;
	vect_t	dir;

	if( argc < 4 )
		return(-1);
	pt[X] = atof(argv[1]);
	pt[Y] = atof(argv[2]);
	pt[Z] = atof(argv[3]);

	VSUB2( dir, pt, rtif_eye_model );
	VUNITIZE( dir );

#if 1
	/*
	   At the moment bn_mat_lookat will return NAN's if the direction vector
	   is aligned with the Z axis. The following is a temporary workaround.
	 */
	{
	  vect_t neg_Z_axis;

	  VSET(neg_Z_axis, 0.0, 0.0, -1.0);
	  bn_mat_fromto( rtif_viewrot, dir, neg_Z_axis);
	}
#else
	bn_mat_lookat( rtif_viewrot, dir, yflip );
#endif

	/*  Final processing is deferred until cm_end(), but eye_pt
	 *  must have been specified before here (for now)
	 */
	return(0);
}

int
cm_vrot(int argc, char **argv)
{
	register int	i;

	if( argc < 17 )
		return(-1);
	for( i=0; i<16; i++ )
		rtif_viewrot[i] = atof(argv[i+1]);
	/* Processing is deferred until cm_end() */
	return(0);
}

int
cm_orientation(int argc, char **argv)
{
	register int	i;
	quat_t		quat;

	for( i=0; i<4; i++ )
		quat[i] = atof( argv[i+1] );
	quat_quat2mat( rtif_viewrot, quat );
	return(0);
}

/*
 *			C M _ E N D
 */
int
cm_end(int argc, char **argv)
{
	vect_t	xlate;
	vect_t	new_cent;
	vect_t	xv, yv;			/* view x, y */
	vect_t	xm, ym;			/* model x, y */
	struct bu_list		*vhead = &rtif_vbp->head[0];

	/* Only display the frames the user is interested in */
	if( rtif_currentframe < rtif_desiredframe )  return 0;
	if( rtif_finalframe && rtif_currentframe > rtif_finalframe )  return 0;

	/* Record eye path as a polyline.  Move, then draws */
	if( BU_LIST_IS_EMPTY( vhead ) )  {
		RT_ADD_VLIST( vhead, rtif_eye_model, BN_VLIST_LINE_MOVE );
	} else {
		RT_ADD_VLIST( vhead, rtif_eye_model, BN_VLIST_LINE_DRAW );
	}

	/* First step:  put eye at view center (view 0,0,0) */
	MAT_COPY(view_state->vs_vop->vo_rotation, rtif_viewrot);
	MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, rtif_eye_model);
	new_mats();

	/*
	 * Compute camera orientation notch to right (+X) and up (+Y)
	 * Done here, with eye in center of view.
	 */
	VSET(xv, 0.05, 0.0, 0.0);
	VSET(yv, 0.0, 0.05, 0.0);
	MAT4X3PNT(xm, view_state->vs_vop->vo_view2model, xv);
	MAT4X3PNT(ym, view_state->vs_vop->vo_view2model, yv);
	RT_ADD_VLIST(vhead, xm, BN_VLIST_LINE_DRAW);
	RT_ADD_VLIST(vhead, rtif_eye_model, BN_VLIST_LINE_MOVE);
	RT_ADD_VLIST(vhead, ym, BN_VLIST_LINE_DRAW);
	RT_ADD_VLIST(vhead, rtif_eye_model, BN_VLIST_LINE_MOVE);

	/*  Second step:  put eye at view 0,0,1.
	 *  For eye to be at 0,0,1, the old 0,0,-1 needs to become 0,0,0.
	 */
	VSET(xlate, 0.0, 0.0, -1.0);	/* correction factor */
	MAT4X3PNT(new_cent, view_state->vs_vop->vo_view2model, xlate);
	MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, new_cent);
	new_mats();

	/* If new treewalk is needed, get new objects into view. */
	if( tree_walk_needed )  {
	  char *av[2];

	  av[0] = "Z";
	  av[1] = NULL;

	  (void)cmd_zap( (ClientData)NULL, interp, 1, av );
	  edit_com( rt_cmd_vec_len, rt_cmd_vec, rtif_mode, 0 );
	}

	view_state->vs_flag = 1;
	refresh();	/* Draw new display */
	view_state->vs_flag = 1;
	if( rtif_delay > 0 )  {
		struct timeval tv;
		fd_set readfds;
	
		FD_ZERO(&readfds);
		FD_SET(fileno(stdin), &readfds);
		tv.tv_sec = (long)rtif_delay;
		tv.tv_usec = (long)((rtif_delay - tv.tv_sec) * 1000000);
		select( fileno(stdin)+1, &readfds, (fd_set *)0, (fd_set *)0, &tv );
	}
	return(0);
}

int
cm_multiview(int argc, char **argv)
{
	return(-1);
}

/*
 *			C M _ A N I M
 *
 *  Parse any "anim" commands, and lodge their info in the directory structs.
 */
int
cm_anim(int argc, char **argv)
{

  if(dbip == DBI_NULL)
    return 0;

  if( db_parse_anim( dbip, argc, (const char **)argv ) < 0 )  {
    Tcl_AppendResult(interp, "cm_anim:  ", argv[1], " ", argv[2], " failed\n", (char *)NULL);
    return(-1);		/* BAD */
  }

  tree_walk_needed = 1;

  return(0);
}

/*
 *			C M _ T R E E
 *
 *  Replace list of top-level objects in rt_cmd_vec[].
 */
int
cm_tree(int argc, char **argv)
{
	register int	i = 1;
	char *cp = rt_cmd_storage;

	for( i = 1;  i < argc && i < MAXARGS; i++ )  {
		strcpy(cp, argv[i]);
		rt_cmd_vec[i] = cp;
		cp += strlen(cp) + 1;
	}
	rt_cmd_vec[i] = (char *)0;
	rt_cmd_vec_len = i;

	tree_walk_needed = 1;

	return(0);
}

/*
 *			C M _ C L E A N
 *
 *  Clear current view.
 */
int
cm_clean(int argc, char **argv)
{
	if(dbip == DBI_NULL)
	  return 0;

	/*f_zap( (ClientData)NULL, interp, 0, (char **)0 );*/

	/* Free animation structures */
	db_free_anim(dbip);

	tree_walk_needed = 1;
	return 0;
}

int
cm_set(int argc, char **argv)
{
	return(-1);
}

extern char **skewer_solids (int argc, const char **argv, fastf_t *ray_orig, fastf_t *ray_dir, int full_path);

int
cmd_solids_on_ray (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    char			**snames;
    int				h = 0;
    int				v = 0;
    int				i;		/* Dummy loop index */
    register struct solid	*sp;
    double			t;
    double			t_in;
    struct bu_vls		vls;
    point_t			ray_orig;
    vect_t			ray_dir;
    point_t			extremum[2];
    point_t			minus, plus;	/* vrts of solid's bnding bx */
    vect_t			unit_H, unit_V;

    if(argc < 1 || 3 < argc){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "helpdevel solids_on_ray");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    if ((argc != 1) && (argc != 3))
    {
	Tcl_AppendResult(interp, "Usage: 'solids_on_ray [h v]'", (char *)NULL);
	return (TCL_ERROR);
    }
    if ((argc == 3) &&
        ((Tcl_GetInt(interp, argv[1], &h) != TCL_OK)
      || (Tcl_GetInt(interp, argv[2], &v) != TCL_OK)))
    {
	Tcl_AppendResult(interp, "\nUsage: 'solids_on_ray h v'", NULL);
	return (TCL_ERROR);
    }

    if (((int)GED_MIN > h)  || (h > (int)GED_MAX) || ((int)GED_MIN > v)  || (v > (int)GED_MAX))
    {
	Tcl_AppendResult(interp, "Screen coordinates out of range\n",
	    "Must be between +/-2048", NULL);
	return (TCL_ERROR);
    }

    VSET(ray_orig, -view_state->vs_vop->vo_center[MDX],
	-view_state->vs_vop->vo_center[MDY], -view_state->vs_vop->vo_center[MDZ]);
    /*
     * Compute bounding box of all objects displayed.
     * Borrowed from size_reset() in chgview.c
     */
    for (i = 0; i < 3; ++i)
    {
	extremum[0][i] = INFINITY;
	extremum[1][i] = -INFINITY;
    }
    FOR_ALL_SOLIDS (sp, &dgop->dgo_headSolid)
    {
	    minus[X] = sp->s_center[X] - sp->s_size;
	    minus[Y] = sp->s_center[Y] - sp->s_size;
	    minus[Z] = sp->s_center[Z] - sp->s_size;
	    VMIN( extremum[0], minus );
	    plus[X] = sp->s_center[X] + sp->s_size;
	    plus[Y] = sp->s_center[Y] + sp->s_size;
	    plus[Z] = sp->s_center[Z] + sp->s_size;
	    VMAX( extremum[1], plus );
    }
    VMOVEN(ray_dir, view_state->vs_vop->vo_rotation + 8, 3);
    VSCALE(ray_dir, ray_dir, -1.0);
    for (i = 0; i < 3; ++i)
	if (NEAR_ZERO(ray_dir[i], 1e-10))
	    ray_dir[i] = 0.0;
    if ((ray_orig[X] >= extremum[0][X]) &&
	(ray_orig[X] <= extremum[1][X]) &&
	(ray_orig[Y] >= extremum[0][Y]) &&
	(ray_orig[Y] <= extremum[1][Y]) &&
	(ray_orig[Z] >= extremum[0][Z]) &&
	(ray_orig[Z] <= extremum[1][Z]))
    {
	t_in = -INFINITY;
	for (i = 0; i < 6; ++i)
	{
	    if (ray_dir[i%3] == 0)
		continue;
	    t = (extremum[i/3][i%3] - ray_orig[i%3]) /
		    ray_dir[i%3];
	    if ((t < 0) && (t > t_in))
		t_in = t;
	}
	VJOIN1(ray_orig, ray_orig, t_in, ray_dir);
    }

    VMOVEN(unit_H, view_state->vs_vop->vo_model2view, 3);
    VMOVEN(unit_V, view_state->vs_vop->vo_model2view + 4, 3);
    VJOIN1(ray_orig, ray_orig, h * view_state->vs_vop->vo_scale * INV_GED, unit_H);
    VJOIN1(ray_orig, ray_orig, v * view_state->vs_vop->vo_scale * INV_GED, unit_V);

    /*
     *	Build a list of all the top-level objects currently displayed
     */
    rt_cmd_vec_len = build_tops(&rt_cmd_vec[0], &rt_cmd_vec[MAXARGS]);
    
    bu_vls_init(&vls);
    start_catching_output(&vls);
    snames = skewer_solids(rt_cmd_vec_len, (const char **)rt_cmd_vec, ray_orig, ray_dir, 1);
    stop_catching_output(&vls);

    if (snames == 0)
    {
	Tcl_AppendResult(interp, "Error executing skewer_solids: ", (char *)NULL);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
	return (TCL_ERROR);
    }

    bu_vls_free(&vls);

    for (i = 0; snames[i] != 0; ++i)
	Tcl_AppendElement(interp, snames[i]);
    
    bu_free((genptr_t) snames, "solid names");

    return TCL_OK;
}


/*
 * List the objects currently being drawn.
 */
int 
cmd_who (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return dgo_who_cmd(dgop, interp, argc, argv);
}

/* any commands that are not supported or implemented may call this null
 * routine to avoid rt_do_cmd() "command not found" error reporting
 */
int
cm_null(argc, argv)
char	**argv;
int	argc;
{
  return(0);
}
@


11.108
log
@change conf.h to a wrapped config.h
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/rtif.c,v 11.107 2004/04/05 09:09:12 morrison Exp $ (BRL)";
@


11.107
log
@merge of ansi-6-0-branch into HEAD
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d32 5
a36 1
#include "conf.h"
@


11.106
log
@merge of windows-6-0-branch into head
@
text
@d67 1
a67 1
extern int mged_svbase();
d69 5
d77 2
a78 1
static void setup_rt();
a79 1

d195 1
a195 2
pr_wait_status( status )
int	status;
d232 1
a232 3
rt_oldwrite(fp, eye_model)
FILE *fp;
vect_t eye_model;
d255 1
a255 3
rt_write(fp, eye_model)
FILE *fp;
vect_t eye_model;
d303 1
a303 5
rt_read(fp, scale, eye, mat)
FILE	*fp;
fastf_t	*scale;
vect_t	eye;
mat_t	mat;
d375 1
a375 3
setup_rt( vp, printcmd )
register char	**vp;
int printcmd;
d491 1
a491 2
rt_set_eye_model(eye_model)
vect_t eye_model;
d554 1
a554 1
run_rt()
d765 1
a765 5
f_rrt(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d883 1
a883 2
basename( p1, suff )
register char *p1, *suff;
d910 1
a910 5
f_saveview(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char **argv;
d1226 1
a1226 5
f_rmats(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1400 1
a1400 5
f_savekey(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1436 13
a1494 1
#ifndef WIN32
d1496 1
a1496 5
rtif_sigint( num )
int	num;
#else
static void rtif_sigint(int	num)
#endif
d1530 1
a1530 5
f_preview(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1664 1
a1664 5
f_nirt(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1934 2
a1935 2
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;
d1947 1
a1947 1
    DuplicateHandle( GetCurrentProcess(), pipe_out[0],
d1963 1
a1963 1
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
d1986 3
a1988 3
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
d1992 27
a2018 37
   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_out[1];
   si.hStdError   = pipe_err[1];


   sprintf(line1,"%s ",rt_cmd_vec[0]);
   for(i=1;i<rt_cmd_vec_len;i++) {
	   sprintf(name,"%s ",rt_cmd_vec[i]);
	   strcat(line1,name); 
	   if(strstr(name,"-e") != NULL) {
		   i++;
		   sprintf(name,"\"%s\" ",rt_cmd_vec[i]);
			strcat(line1,name);} 
   }

   if(CreateProcess( NULL,
                     line1,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout);
	SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);
}
d2130 1
a2130 5
f_vnirt(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d2209 1
a2209 3
cm_start(argc, argv)
char	**argv;
int	argc;
d2219 1
a2219 3
cm_vsize(argc, argv)
char	**argv;
int	argc;
d2231 1
a2231 3
cm_eyept(argc, argv)
char	**argv;
int	argc;
d2243 1
a2243 3
cm_lookat_pt(argc, argv)
int	argc;
char	**argv;
d2279 1
a2279 3
cm_vrot(argc, argv)
char	**argv;
int	argc;
d2292 1
a2292 3
cm_orientation( argc, argv )
int	argc;
char	**argv;
d2307 1
a2307 3
cm_end(argc, argv)
char	**argv;
int	argc;
d2380 1
a2380 3
cm_multiview(argc, argv)
char	**argv;
int	argc;
d2391 1
a2391 3
cm_anim(argc, argv)
int	argc;
char	**argv;
d2413 1
a2413 3
cm_tree(argc, argv)
char	**argv;
int	argc;
d2437 1
a2437 3
cm_clean(argc, argv)
char	**argv;
int	argc;
d2452 1
a2452 3
cm_set(argc, argv)
char	**argv;
int	argc;
d2457 1
a2457 1
extern char **skewer_solids ();
d2460 1
a2460 5
cmd_solids_on_ray (clientData, interp, argc, argv)
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char		**argv;
d2565 1
a2565 1
    snames = skewer_solids(rt_cmd_vec_len, rt_cmd_vec, ray_orig, ray_dir, 1);
d2591 1
a2591 5
cmd_who (clientData, interp, argc, argv)
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char 		**argv;
@


11.105
log
@update copyright to include span through 2003
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.104 2003/12/01 16:19:55 morrison Exp $ (BRL)";
d42 3
a44 1
#include <sys/time.h>		/* For struct timeval */
d63 4
d78 11
a88 2
       int			fd;
       FILE			*fp;
d90 2
d96 6
d405 1
a405 1
#if 1
a410 1
#if 0
a414 6
#else
	char line[5120+1];

	/* Get data from rt */
	if ((count = read((int)run_rtp->fd, line, 5120)) == 0) {
#endif
d444 50
d556 1
a556 1
#if 1
d623 120
d1506 1
d1510 3
d1527 1
a1527 1
	sig3();			/* Call main SIGINT handler */
d1693 2
a1694 1
	int pid, rpid;
d1696 1
d1700 10
d1845 1
d1850 6
d1912 1
a1912 1

d1956 117
d2139 2
d2147 5
@


11.104
log
@spacing after the arg output
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1988 by the United States Army.
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.103 2003/04/11 04:43:08 morrison Exp $ (BRL)";
@


11.103
log
@fixed bug in restoration of viewsize during mged loadview command -- scale has to be half of size and size needs to be set; also fixed segment violation
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.102 2003/04/10 20:32:49 morrison Exp $ (BRL)";
d769 1
a769 1
		(void)fprintf(fp, "-p%g", view_state->vs_vop->vo_perspective);
@


11.103.6.1
log
@updates from HEAD
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.104 2003/12/01 16:19:55 morrison Exp $ (BRL)";
d769 1
a769 1
		(void)fprintf(fp, "-p%g ", view_state->vs_vop->vo_perspective);
@


11.103.6.2
log
@merge from HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.105 2004/02/02 17:39:35 morrison Exp $ (BRL)";
@


11.103.6.3
log
@merge from head
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.103.6.2 2004/02/12 18:34:15 erikg Exp $ (BRL)";
@


11.103.6.4
log
@merge from head
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d42 1
a42 3
#ifndef WIN32
#  include <sys/time.h>		/* For struct timeval */
#endif
a60 4
#ifdef WIN32
#  include <fcntl.h>
#endif

d72 2
a73 11
#ifdef WIN32
	HANDLE			fd;
	HANDLE			hProcess;
	DWORD			pid;
#  ifdef TCL_OK
	Tcl_Channel		chan;
#  else
	genptr_t chan;
#  endif
#else
       int			fd;    
a74 2
#endif
	   FILE			*fp;
a78 6
//Tcl_Channel chan;
#ifdef TCL_OK
	Tcl_Channel chan1;
#else
	genptr_t chan1;
#endif
d382 1
a382 1
#ifndef WIN32
d388 1
d393 6
a427 50
#else
void
rt_output_handler(ClientData clientData, int mask)
{
	struct run_rt *run_rtp = (struct run_rt *)clientData;
	int count;
#if 0
	char line[RT_MAXLINE+1];

	/* Get data from rt */
	if ((!ReadFile(run_rtp->fd, line, RT_MAXLINE,&count,0))) {
#else
	char line[5120+1];
	

	/* Get data from rt */
	if ((!ReadFile(run_rtp->fd, line, 5120,&count,0))) {
#endif
		int aborted;

		Tcl_DeleteChannelHandler(run_rtp->chan,rt_output_handler,(ClientData)run_rtp);
		CloseHandle(run_rtp->fd);

		/* wait for the forked process */

		WaitForSingleObject( run_rtp->hProcess, INFINITE );
		
		if(GetLastError() == ERROR_PROCESS_ABORTED)
		{
			run_rtp->aborted = 1; 
		}

		aborted = run_rtp->aborted;

		/* free run_rtp */
 		BU_LIST_DEQUEUE(&run_rtp->l);
		bu_free((genptr_t)run_rtp, "rt_output_handler: run_rtp");

		if (aborted)
			bu_log("Raytrace aborted.\n");
		else
			bu_log("Raytrace complete.\n");
		return;
	}

	line[count] = '\0';

	/*XXX For now just blather to stderr */
	bu_log("%s", line);
}
d490 1
a490 1
#ifndef WIN32
a556 120
#else
run_rt()
{
	register struct solid *sp;
	register int i;
	FILE *fp_in;
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	vect_t eye_model;
	struct run_rt	*run_rtp;

   STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   SECURITY_ATTRIBUTES sa          = {0};
   char line[2048];
   char name[256];

    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_err[1];
   si.hStdError   = pipe_err[1];


   sprintf(line,"%s ",rt_cmd_vec[0]);
   for(i=1;i<rt_cmd_vec_len;i++) {
	   sprintf(name,"%s ",rt_cmd_vec[i]);
	   strcat(line,name); }
	   

   if(CreateProcess( NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStderr);
}


	/* As parent, send view information down pipe */
	CloseHandle(pipe_in[0]);
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	CloseHandle(pipe_err[1]);


	rt_set_eye_model(eye_model);
	rt_write(fp_in, eye_model);
	(void)fclose( fp_in );

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;

	BU_GETSTRUCT(run_rtp, run_rt);
	BU_LIST_APPEND(&head_run_rt.l, &run_rtp->l);
	run_rtp->fd = pipe_errDup;
	run_rtp->hProcess = pi.hProcess;
	run_rtp->pid = pi.dwProcessId;
	run_rtp->aborted=0;

	run_rtp->chan = Tcl_MakeFileChannel(run_rtp->fd,TCL_READABLE);
	Tcl_CreateChannelHandler(run_rtp->chan,TCL_READABLE,
			      rt_output_handler, (ClientData)run_rtp);

	return 0;
}
a1319 1
#ifndef WIN32
a1322 3
#else
static void rtif_sigint(int	num)
#endif
d1337 1
a1337 1
	sig3(num);			/* Call main SIGINT handler */
d1503 1
a1503 2
	int pid;
	int rpid;
a1504 1
#ifndef WIN32
a1507 10
#else
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_out[2],hSaveStdout,pipe_outDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	STARTUPINFO si = {0};
	PROCESS_INFORMATION pi = {0};
	SECURITY_ATTRIBUTES sa          = {0};
	char name[1024];
	char line1[2048];
#endif
a1642 1
#ifndef WIN32
a1646 6
#else
	      if(*val == '\0')
		bu_vls_printf(&o_vls, " fmt r \\\"\\\\n\\\" ");
	      else	{
		bu_vls_printf(&o_vls, " fmt r \\\"\\\\n%*s\\\" ", count, val);
#endif
d1703 1
a1703 1
#ifndef WIN32
a1746 117
#else
	sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_out[0], &pipe_out[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_OUTPUT_HANDLE, pipe_out[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_out[0],
        GetCurrentProcess(),  &pipe_outDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_out[0] );

	// Save the handle to the current STDERR.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDERR.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDERR.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_out[1];
   si.hStdError   = pipe_err[1];


   sprintf(line1,"%s ",rt_cmd_vec[0]);
   for(i=1;i<rt_cmd_vec_len;i++) {
	   sprintf(name,"%s ",rt_cmd_vec[i]);
	   strcat(line1,name); 
	   if(strstr(name,"-e") != NULL) {
		   i++;
		   sprintf(name,"\"%s\" ",rt_cmd_vec[i]);
			strcat(line1,name);} 
   }

   if(CreateProcess( NULL,
                     line1,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout);
	SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);
}
 
	/* use fp_in to feed view info to nirt */
	CloseHandle( pipe_in[0] );
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	//fp_in = fdopen( pipe_in[1], "w" );

	/* use fp_out to read back the result */
	CloseHandle( pipe_out[1] );
	//fp_out = fdopen( pipe_out[0], "r" );
	fp_out = _fdopen( _open_osfhandle((HFILE)pipe_outDup,_O_TEXT), "r" );

	/* use fp_err to read any error messages */
	CloseHandle(pipe_err[1]);
	//fp_err = fdopen( pipe_err[0], "r" );
	fp_err = _fdopen( _open_osfhandle((HFILE)pipe_errDup,_O_TEXT), "r" );

	/* send quit command to nirt */
	fwrite( "q\n", 1, 2, fp_in );
	(void)fclose( fp_in );
#endif
a1812 2
#ifndef WIN32

a1818 5
#else
	/* Wait for program to finish */
	WaitForSingleObject( pi.hProcess, INFINITE );

#endif
@


11.102
log
@adjusted whitespacing
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.101 2002/08/20 17:08:25 jra Exp $ (BRL)";
d835 1
a835 1
	char *editArgv[2];
d845 1
a849 2

#if 0
d976 1
a976 1
		  /*			bu_log("objects=%s\n", objects);*/
d993 1
a994 1
		    /*				bu_log("objects=%s\n", objects);*/
d996 1
d1932 4
a1935 1
	view_state->vs_vop->vo_scale = atof(argv[1])*0.5;
d2343 1
a2343 1
	return(0);
@


11.101
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.99 2002/08/11 02:10:44 morrison Exp $ (BRL)";
d85 1
a85 1
static struct _mged_variables    rtif_saved_state;       /* saved state variable\s */
d832 1
a832 1
  int perspective=-1;
d877 2
a878 2
	/* turn perspective mode off, by default.  A "-p" option in the view script
	 * will turn it back on.
d884 1
a884 1
  while (!feof(fp)) {
d888 2
a889 2
    if (strncmp(buffer, "-p", 2)==0) {
      /* we found perspective */
d891 110
a1000 103
      buffer[0]=' ';
      buffer[1]=' ';
      sscanf(buffer, "%d", &perspective);
			/*      bu_log("perspective=%d\n", perspective);*/
			mged_variables->mv_perspective=perspective;
			set_perspective(); /* !!! this does not update the menu variable.. */

    } else if (strncmp(buffer, "$*", 2)==0) {
      /* the next read is the file name, the objects come after that */

      memset(dbName, 0, 1024);
      fscanf(fp, "%s", dbName);
      /* if the last character is a line termination, remove it
       * (it should always be unless the user modifies the file)
       */
      if ( *(dbName + strlen(dbName) - 1)=='\\' ) {
        memset(dbName+strlen(dbName)-1, 0, 1);
      }
			/*      bu_log("dbName=%s\n", dbName); */

			/* if no database is open, we attempt to open the database listed in the
			 * script.  if a database is open, we compare the open database's inode
			 * number with the inode of the database listed in the script.  If they
			 * match, we may proceed. otherwise we need to abort since the wrong
			 * database would be open.
			 */
			if ( dbip == DBI_NULL ) {
				/* load the database */

				/* XXX could use better path handling instead of assuming rooted or . */

				/* turn off interactive mode so the f_opendb() call doesn't blather or
				 * attempt to create a new database
				 */
				interactive=0;
				editArgv[0]="";
				editArgv[1]=dbName;
				editArgv[2]=(char *)NULL;
				if (f_opendb( (ClientData)NULL, interp, 2, editArgv ) == TCL_ERROR) {
					Tcl_AppendResult(interp, "Unable to load database: ", dbName, "\n", (char *)NULL);

					/* restore state before leaving */
					mged_variables->mv_perspective=prevPerspective;
					set_perspective();

					return TCL_ERROR;
				} else {
					Tcl_AppendResult(interp, "Loading database: ", dbName, "\n", (char *)NULL);
				}
				interactive=prevInteractive;

			} else {
				/* compare inode numbers */

				stat(dbip->dbi_filename, &dbInode);
				stat(dbName, &scriptInode);

				/* stop here if they are not the same file, otherwise, we may proceed
				 * as expected, and load the objects.
				 */
				if (dbInode.st_ino != scriptInode.st_ino) {
					Tcl_AppendResult(interp, "View script references a different database\nCannot load the view without closing the current database\n(i.e. run \"opendb ", dbName, "\")\n", (char *)NULL);

					/* restore state before leaving */
					mged_variables->mv_perspective=prevPerspective;
					set_perspective();

					return TCL_ERROR;
				}
					
			}
			/* end check for loaded database */

			/* get rid of anything that may be displayed, since we will load objects
			 * that are listed in the script next.
			 */
			(void)cmd_zap( (ClientData)NULL, interp, 1, NULL );

      /* now get the objects listed */
      fscanf(fp, "%s", objects);
			/*			bu_log("objects=%s\n", objects);*/
      while ((!feof(fp)) && (strncmp(objects, "\\", 1)!=0)) {

				/* clean off the single quotes... */
				if (strncmp(objects, "'", 1)==0) {
					objects[0]=' ';
					memset(objects+strlen(objects)-1, ' ', 1);
					sscanf(objects, "%s", objects);
				}

				editArgv[0] = "e";
				editArgv[1] = objects;
				editArgv[2] = (char *)NULL;
				if (edit_com( 2, editArgv, 1, 1 ) != 0) {
					Tcl_AppendResult(interp, "Unable to load object: ", objects, "\n", (char *)NULL);
				}

				fscanf(fp, "%s", objects);
				/*				bu_log("objects=%s\n", objects);*/
      }			/* end iteration over reading in listed objects */
    } else if (strncmp(buffer, "<<EOF", 5)==0) {
			char *cmdBuffer = NULL;
      /* we are almost done .. read in the view commands */
d1002 10
a1011 10
			while ( (cmdBuffer = rt_read_cmd( fp )) != NULL ) {
				/* even unsupported commands should return successfully as they should
				 * be calling cm_null()
				 */
				if ( rt_do_cmd( (struct rt_i *)0, cmdBuffer, view_cmdtab ) < 0 ) { 
					Tcl_AppendResult(interp, "command failed: ", cmdBuffer, "\n", (char *)NULL);
				}
				bu_free( (genptr_t)cmdBuffer, "loadview cmdBuffer" );
			}
			/* end iteration over rt commands */
d1013 1
a1013 1
    }
d1016 1
a1016 1
  }
d1032 1
a1032 2
	 */
	VSET(xlate, 0.0, 0.0, -1.0);	/* correction factor */
d1036 1
@


11.101.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.101 2002/08/20 17:08:25 jra Exp $ (BRL)";
a41 1
#ifndef WIN32
a42 1
#endif
a60 4
#ifdef WIN32
#include <fcntl.h>
#endif

d72 2
a73 11
#ifdef WIN32
	HANDLE			fd;
	HANDLE			hProcess;
	DWORD			pid;
#ifdef TCL_OK
	Tcl_Channel		chan;
#else
	genptr_t chan;
#endif
#else
       int			fd;    
a74 2
#endif
	   FILE			*fp;
a78 6
//Tcl_Channel chan;
#ifdef TCL_OK
	Tcl_Channel chan1;
#else
	genptr_t chan1;
#endif
d382 1
a382 1
#ifndef WIN32
a427 50
#else
void
rt_output_handler(ClientData clientData, int mask)
{
	struct run_rt *run_rtp = (struct run_rt *)clientData;
	int count;
#if 0
	char line[RT_MAXLINE+1];

	/* Get data from rt */
	if ((!ReadFile(run_rtp->fd, line, RT_MAXLINE,&count,0))) {
#else
	char line[5120+1];
	

	/* Get data from rt */
	if ((!ReadFile(run_rtp->fd, line, 5120,&count,0))) {
#endif
		int aborted;

		Tcl_DeleteChannelHandler(run_rtp->chan,rt_output_handler,(ClientData)run_rtp);
		CloseHandle(run_rtp->fd);

		/* wait for the forked process */

		WaitForSingleObject( run_rtp->hProcess, INFINITE );
		
		if(GetLastError() == ERROR_PROCESS_ABORTED)
		{
			run_rtp->aborted = 1; 
		}

		aborted = run_rtp->aborted;

		/* free run_rtp */
 		BU_LIST_DEQUEUE(&run_rtp->l);
		bu_free((genptr_t)run_rtp, "rt_output_handler: run_rtp");

		if (aborted)
			bu_log("Raytrace aborted.\n");
		else
			bu_log("Raytrace complete.\n");
		return;
	}

	line[count] = '\0';

	/*XXX For now just blather to stderr */
	bu_log("%s", line);
}
d490 1
a490 1
#ifndef WIN32
a556 120
#else
run_rt()
{
	register struct solid *sp;
	register int i;
	FILE *fp_in;
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	vect_t eye_model;
	struct run_rt	*run_rtp;

   STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   SECURITY_ATTRIBUTES sa          = {0};
   char line[2048];
   char name[256];

    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_err[1];
   si.hStdError   = pipe_err[1];


   sprintf(line,"%s ",rt_cmd_vec[0]);
   for(i=1;i<rt_cmd_vec_len;i++) {
	   sprintf(name,"%s ",rt_cmd_vec[i]);
	   strcat(line,name); }
	   

   if(CreateProcess( NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStderr);
}


	/* As parent, send view information down pipe */
	CloseHandle(pipe_in[0]);
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	CloseHandle(pipe_err[1]);


	rt_set_eye_model(eye_model);
	rt_write(fp_in, eye_model);
	(void)fclose( fp_in );

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;

	BU_GETSTRUCT(run_rtp, run_rt);
	BU_LIST_APPEND(&head_run_rt.l, &run_rtp->l);
	run_rtp->fd = pipe_errDup;
	run_rtp->hProcess = pi.hProcess;
	run_rtp->pid = pi.dwProcessId;
	run_rtp->aborted=0;

	run_rtp->chan = Tcl_MakeFileChannel(run_rtp->fd,TCL_READABLE);
	Tcl_CreateChannelHandler(run_rtp->chan,TCL_READABLE,
			      rt_output_handler, (ClientData)run_rtp);

	return 0;
}
a1312 1
#ifndef WIN32
a1315 3
#else
static void rtif_sigint(int	num)
#endif
d1330 1
a1330 1
	sig3(num);			/* Call main SIGINT handler */
d1496 2
a1497 1
#ifndef WIN32
a1500 10
#else
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_out[2],hSaveStdout,pipe_outDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   SECURITY_ATTRIBUTES sa          = {0};
   char name[1024];
   char line1[2048];
#endif
a1635 1
#ifndef WIN32
a1639 6
#else
		if(*val == '\0')
	      bu_vls_printf(&o_vls, " fmt r \\\"\\\\n\\\" ");
	    else{
	      bu_vls_printf(&o_vls, " fmt r \\\"\\\\n%*s\\\" ", count, val);
#endif
d1696 1
a1696 1
#ifndef WIN32
a1739 117
#else
	sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_out[0], &pipe_out[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_OUTPUT_HANDLE, pipe_out[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_out[0],
        GetCurrentProcess(),  &pipe_outDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_out[0] );

	// Save the handle to the current STDERR.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDERR.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDERR.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_out[1];
   si.hStdError   = pipe_err[1];


   sprintf(line1,"%s ",rt_cmd_vec[0]);
   for(i=1;i<rt_cmd_vec_len;i++) {
	   sprintf(name,"%s ",rt_cmd_vec[i]);
	   strcat(line1,name); 
	   if(strstr(name,"-e") != NULL) {
		   i++;
		   sprintf(name,"\"%s\" ",rt_cmd_vec[i]);
			strcat(line1,name);} 
   }

   if(CreateProcess( NULL,
                     line1,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout);
	SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);
}
 
	/* use fp_in to feed view info to nirt */
	CloseHandle( pipe_in[0] );
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	//fp_in = fdopen( pipe_in[1], "w" );

	/* use fp_out to read back the result */
	CloseHandle( pipe_out[1] );
	//fp_out = fdopen( pipe_out[0], "r" );
	fp_out = _fdopen( _open_osfhandle((HFILE)pipe_outDup,_O_TEXT), "r" );

	/* use fp_err to read any error messages */
	CloseHandle(pipe_err[1]);
	//fp_err = fdopen( pipe_err[0], "r" );
	fp_err = _fdopen( _open_osfhandle((HFILE)pipe_errDup,_O_TEXT), "r" );

	/* send quit command to nirt */
	fwrite( "q\n", 1, 2, fp_in );
	(void)fclose( fp_in );
#endif
a1805 2
#ifndef WIN32

a1811 5
#else
	/* Wait for program to finish */
	WaitForSingleObject( pi.hProcess, INFINITE );

#endif
@


11.101.4.2
log
@sync to HEAD...
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/rtif.c,v 11.101.4.1 2002/09/26 23:04:13 morrison Exp $ (BRL)";
d108 1
a108 1
static struct _mged_variables    rtif_saved_state;       /* saved state variables */
d962 1
a962 1
		(void)fprintf(fp, "-p%g ", view_state->vs_vop->vo_perspective);
d1025 1
a1025 1
	int perspective=-1;
d1028 1
a1028 1
	char *editArgv[3];
d1070 2
a1071 2
	/* turn perspective mode off, by default.  A "-p" option in the
	 * view script will turn it back on.
d1077 1
a1077 1
	while (!feof(fp)) {
d1081 2
a1082 2
		if (strncmp(buffer, "-p", 2)==0) {
		  /* we found perspective */
d1084 96
a1179 106
		  buffer[0]=' ';
		  buffer[1]=' ';
		  sscanf(buffer, "%d", &perspective);
		  /*      bu_log("perspective=%d\n", perspective);*/
		  mged_variables->mv_perspective=perspective;
		  /* !!! this does not update the menu variable.. */	
		  set_perspective(); 

		} else if (strncmp(buffer, "$*", 2)==0) {
		  /* the next read is the file name, the objects come
		   * after that 
		   */

		  memset(dbName, 0, 1024);
		  fscanf(fp, "%s", dbName);
		  /* if the last character is a line termination, 
		   * remove it (it should always be unless the user
		   * modifies the file)
		   */
		  if ( *(dbName + strlen(dbName) - 1)=='\\' ) {
		    memset(dbName+strlen(dbName)-1, 0, 1);
		  }
		  /*      bu_log("dbName=%s\n", dbName); */
		  
		  /* if no database is open, we attempt to open the
		   * database listed in the script.  if a database is
		   * open, we compare the open database's inode number
		   * with the inode of the database listed in the script.
		   * If they match, we may proceed. otherwise we need
		   * to abort since the wrong database would be open.
		   */
		  if ( dbip == DBI_NULL ) {
		    /* load the database */

		    /* XXX could use better path handling instead of
		     * assuming rooted or . */
		    
		    /* turn off interactive mode so the f_opendb() call
		     * doesn't blather or attempt to create a new database
		     */
		    interactive=0;
		    editArgv[0]="";
		    editArgv[1]=dbName;
		    editArgv[2]=(char *)NULL;
		    if (f_opendb( (ClientData)NULL, interp, 2, editArgv ) == TCL_ERROR) {
		      Tcl_AppendResult(interp, "Unable to load database: ", dbName, "\n", (char *)NULL);
		      
		      /* restore state before leaving */
		      mged_variables->mv_perspective=prevPerspective;
		      set_perspective();

		      return TCL_ERROR;
		    } else {
		      Tcl_AppendResult(interp, "Loading database: ", dbName, "\n", (char *)NULL);
		    }
		    interactive=prevInteractive;
		    
		  } else {
		    /* compare inode numbers */
		    
		    stat(dbip->dbi_filename, &dbInode);
		    stat(dbName, &scriptInode);
		    
		    /* stop here if they are not the same file, otherwise,
		     * we may proceed as expected, and load the objects.
		     */
		    if (dbInode.st_ino != scriptInode.st_ino) {
		      Tcl_AppendResult(interp, "View script references a different database\nCannot load the view without closing the current database\n(i.e. run \"opendb ", dbName, "\")\n", (char *)NULL);
		      
		      /* restore state before leaving */
		      mged_variables->mv_perspective=prevPerspective;
		      set_perspective();
		      
		      return TCL_ERROR;
		    }
		    
		  }
		  /* end check for loaded database */
		  
		  /* get rid of anything that may be displayed, since we
		   * will load objects that are listed in the script next.
		   */
		  (void)cmd_zap( (ClientData)NULL, interp, 1, NULL );

		  /* now get the objects listed */
		  fscanf(fp, "%s", objects);
		  /*		  bu_log("OBJECTS=%s\n", objects);*/
		  while ((!feof(fp)) && (strncmp(objects, "\\", 1)!=0)) {

		    /* clean off the single quotes... */
		    if (strncmp(objects, "'", 1)==0) {
		      objects[0]=' ';
		      memset(objects+strlen(objects)-1, ' ', 1);
		      sscanf(objects, "%s", objects);
		    }

		    editArgv[0] = "e";
		    editArgv[1] = objects;
		    editArgv[2] = (char *)NULL;
		    if (edit_com( 2, editArgv, 1, 1 ) != 0) {
		      Tcl_AppendResult(interp, "Unable to load object: ", objects, "\n", (char *)NULL);
		    }
		    
		    /* bu_log("objects=%s\n", objects);*/
		    fscanf(fp, "%s", objects);
		  }
d1181 6
a1186 4
		  /* end iteration over reading in listed objects */
		} else if (strncmp(buffer, "<<EOF", 5)==0) {
		  char *cmdBuffer = NULL;
		  /* we are almost done .. read in the view commands */
d1188 10
a1197 10
		  while ( (cmdBuffer = rt_read_cmd( fp )) != NULL ) {
		    /* even unsupported commands should return successfully as
		     * they should be calling cm_null()
		     */
		    if ( rt_do_cmd( (struct rt_i *)0, cmdBuffer, view_cmdtab ) < 0 ) { 
		      Tcl_AppendResult(interp, "command failed: ", cmdBuffer, "\n", (char *)NULL);
		    }
		    bu_free( (genptr_t)cmdBuffer, "loadview cmdBuffer" );
		  }
		  /* end iteration over rt commands */
d1199 1
a1199 1
		}
d1202 1
a1202 1
	}
d1218 2
a1219 1
	VSET(xlate, 0.0, 0.0, -1.0);
a1222 1
	 */
d2262 1
a2262 4
	/* for some reason, scale is supposed to be half of size... */
	view_state->vs_vop->vo_size = atof(argv[1]);
	view_state->vs_vop->vo_scale = view_state->vs_vop->vo_size * 0.5;
	view_state->vs_vop->vo_invSize = 1.0 / view_state->vs_vop->vo_size;
d2670 1
a2670 1
  return(0);
@


11.101.4.3
log
@merge from HEAD
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a1037 1
#if 0
d1042 2
@


11.101.4.4
log
@ws and missing variables after merge
@
text
@d43 1
a43 1
#  include <sys/time.h>		/* For struct timeval */
d64 1
a64 1
#  include <fcntl.h>
d82 1
a82 1
#  ifdef TCL_OK
d84 1
a84 1
#  else
d86 1
a86 1
#  endif
d411 1
d416 6
a1699 3
	int pid;
	int rpid;
	int retcode;
d1709 4
a1712 4
	PROCESS_INFORMATION pi = {0};
	SECURITY_ATTRIBUTES sa          = {0};
	char name[1024];
	char line1[2048];
d1855 4
a1858 4
	      if(*val == '\0')
		bu_vls_printf(&o_vls, " fmt r \\\"\\\\n\\\" ");
	      else	{
		bu_vls_printf(&o_vls, " fmt r \\\"\\\\n%*s\\\" ", count, val);
@


11.101.2.1
log
@Initial ANSIfication
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.101 2002/08/20 17:08:25 jra Exp $ (BRL)";
d61 1
a61 1
extern int mged_svbase(void);
a62 1

d66 2
a67 1
static void setup_rt(register char **vp, int printcmd);
a68 1
static int tree_walk_needed;
d167 2
a168 1
pr_wait_status(int status)
d205 3
a207 1
rt_oldwrite(FILE *fp, fastf_t *eye_model)
d230 3
a232 1
rt_write(FILE *fp, fastf_t *eye_model)
d280 5
a284 1
rt_read(FILE *fp, fastf_t *scale, fastf_t *eye, fastf_t *mat)
d356 3
a358 1
setup_rt(register char **vp, int printcmd)
d431 2
a432 1
rt_set_eye_model(fastf_t *eye_model)
d495 1
a495 1
run_rt(void)
d586 5
a590 1
f_rrt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d708 2
a709 1
basename(register char *p1, register char *suff)
d736 5
a740 1
f_saveview(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1049 5
a1053 1
f_rmats(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1227 5
a1231 1
f_savekey(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
a1266 13
extern int	cm_start(int argc, char **argv);
extern int	cm_vsize(int argc, char **argv);
extern int	cm_eyept(int argc, char **argv);
extern int	cm_lookat_pt(int argc, char **argv);
extern int	cm_vrot(int argc, char **argv);
extern int	cm_end(int argc, char **argv);
extern int	cm_multiview(int argc, char **argv);
extern int	cm_anim(int argc, char **argv);
extern int	cm_tree(int argc, char **argv);
extern int	cm_clean(int argc, char **argv);
extern int	cm_set(int argc, char **argv);
extern int	cm_orientation(int argc, char **argv);

d1314 2
a1315 1
rtif_sigint(int num)
d1349 5
a1353 1
f_preview(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1487 5
a1491 1
f_nirt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1824 5
a1828 1
f_vnirt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1907 3
a1909 1
cm_start(int argc, char **argv)
d1919 3
a1921 1
cm_vsize(int argc, char **argv)
d1930 3
a1932 1
cm_eyept(int argc, char **argv)
d1944 3
a1946 1
cm_lookat_pt(int argc, char **argv)
d1982 3
a1984 1
cm_vrot(int argc, char **argv)
d1997 3
a1999 1
cm_orientation(int argc, char **argv)
d2014 3
a2016 1
cm_end(int argc, char **argv)
d2089 3
a2091 1
cm_multiview(int argc, char **argv)
d2102 3
a2104 1
cm_anim(int argc, char **argv)
d2126 3
a2128 1
cm_tree(int argc, char **argv)
d2152 3
a2154 1
cm_clean(int argc, char **argv)
d2169 3
a2171 1
cm_set(int argc, char **argv)
d2176 1
a2176 1
extern char **skewer_solids (int argc, const char **argv, fastf_t *ray_orig, fastf_t *ray_dir, int full_path);
d2179 5
a2183 1
cmd_solids_on_ray (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2314 5
a2318 1
cmd_who (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.101.2.2
log
@sync branch with HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d42 1
a42 3
#ifndef WIN32
#  include <sys/time.h>		/* For struct timeval */
#endif
a60 1

a63 4
#ifdef WIN32
#  include <fcntl.h>
#endif

d73 2
a74 11
#ifdef WIN32
	HANDLE			fd;
	HANDLE			hProcess;
	DWORD			pid;
#  ifdef TCL_OK
	Tcl_Channel		chan;
#  else
	genptr_t chan;
#  endif
#else
       int			fd;    
a75 2
#endif
	   FILE			*fp;
a79 6
//Tcl_Channel chan;
#ifdef TCL_OK
	Tcl_Channel chan1;
#else
	genptr_t chan1;
#endif
d86 1
a86 1
static struct _mged_variables    rtif_saved_state;       /* saved state variables */
d372 1
a372 1
#ifndef WIN32
d378 1
d383 6
a417 50
#else
void
rt_output_handler(ClientData clientData, int mask)
{
	struct run_rt *run_rtp = (struct run_rt *)clientData;
	int count;
#if 0
	char line[RT_MAXLINE+1];

	/* Get data from rt */
	if ((!ReadFile(run_rtp->fd, line, RT_MAXLINE,&count,0))) {
#else
	char line[5120+1];
	

	/* Get data from rt */
	if ((!ReadFile(run_rtp->fd, line, 5120,&count,0))) {
#endif
		int aborted;

		Tcl_DeleteChannelHandler(run_rtp->chan,rt_output_handler,(ClientData)run_rtp);
		CloseHandle(run_rtp->fd);

		/* wait for the forked process */

		WaitForSingleObject( run_rtp->hProcess, INFINITE );
		
		if(GetLastError() == ERROR_PROCESS_ABORTED)
		{
			run_rtp->aborted = 1; 
		}

		aborted = run_rtp->aborted;

		/* free run_rtp */
 		BU_LIST_DEQUEUE(&run_rtp->l);
		bu_free((genptr_t)run_rtp, "rt_output_handler: run_rtp");

		if (aborted)
			bu_log("Raytrace aborted.\n");
		else
			bu_log("Raytrace complete.\n");
		return;
	}

	line[count] = '\0';

	/*XXX For now just blather to stderr */
	bu_log("%s", line);
}
d479 1
a479 1
#ifndef WIN32
a545 120
#else
run_rt()
{
	register struct solid *sp;
	register int i;
	FILE *fp_in;
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	vect_t eye_model;
	struct run_rt	*run_rtp;

   STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   SECURITY_ATTRIBUTES sa          = {0};
   char line[2048];
   char name[256];

    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_err[1];
   si.hStdError   = pipe_err[1];


   sprintf(line,"%s ",rt_cmd_vec[0]);
   for(i=1;i<rt_cmd_vec_len;i++) {
	   sprintf(name,"%s ",rt_cmd_vec[i]);
	   strcat(line,name); }
	   

   if(CreateProcess( NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStderr);
}


	/* As parent, send view information down pipe */
	CloseHandle(pipe_in[0]);
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	CloseHandle(pipe_err[1]);


	rt_set_eye_model(eye_model);
	rt_write(fp_in, eye_model);
	(void)fclose( fp_in );

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;

	BU_GETSTRUCT(run_rtp, run_rt);
	BU_LIST_APPEND(&head_run_rt.l, &run_rtp->l);
	run_rtp->fd = pipe_errDup;
	run_rtp->hProcess = pi.hProcess;
	run_rtp->pid = pi.dwProcessId;
	run_rtp->aborted=0;

	run_rtp->chan = Tcl_MakeFileChannel(run_rtp->fd,TCL_READABLE);
	Tcl_CreateChannelHandler(run_rtp->chan,TCL_READABLE,
			      rt_output_handler, (ClientData)run_rtp);

	return 0;
}
d749 1
a749 1
		(void)fprintf(fp, "-p%g ", view_state->vs_vop->vo_perspective);
d812 1
a812 1
	int perspective=-1;
d815 1
a815 1
	char *editArgv[3];
a824 1
#if 0
d829 2
d857 2
a858 2
	/* turn perspective mode off, by default.  A "-p" option in the
	 * view script will turn it back on.
d864 1
a864 1
	while (!feof(fp)) {
d868 65
a932 2
		if (strncmp(buffer, "-p", 2)==0) {
		  /* we found perspective */
d934 33
a966 106
		  buffer[0]=' ';
		  buffer[1]=' ';
		  sscanf(buffer, "%d", &perspective);
		  /*      bu_log("perspective=%d\n", perspective);*/
		  mged_variables->mv_perspective=perspective;
		  /* !!! this does not update the menu variable.. */	
		  set_perspective(); 

		} else if (strncmp(buffer, "$*", 2)==0) {
		  /* the next read is the file name, the objects come
		   * after that 
		   */

		  memset(dbName, 0, 1024);
		  fscanf(fp, "%s", dbName);
		  /* if the last character is a line termination, 
		   * remove it (it should always be unless the user
		   * modifies the file)
		   */
		  if ( *(dbName + strlen(dbName) - 1)=='\\' ) {
		    memset(dbName+strlen(dbName)-1, 0, 1);
		  }
		  /*      bu_log("dbName=%s\n", dbName); */
		  
		  /* if no database is open, we attempt to open the
		   * database listed in the script.  if a database is
		   * open, we compare the open database's inode number
		   * with the inode of the database listed in the script.
		   * If they match, we may proceed. otherwise we need
		   * to abort since the wrong database would be open.
		   */
		  if ( dbip == DBI_NULL ) {
		    /* load the database */

		    /* XXX could use better path handling instead of
		     * assuming rooted or . */
		    
		    /* turn off interactive mode so the f_opendb() call
		     * doesn't blather or attempt to create a new database
		     */
		    interactive=0;
		    editArgv[0]="";
		    editArgv[1]=dbName;
		    editArgv[2]=(char *)NULL;
		    if (f_opendb( (ClientData)NULL, interp, 2, editArgv ) == TCL_ERROR) {
		      Tcl_AppendResult(interp, "Unable to load database: ", dbName, "\n", (char *)NULL);
		      
		      /* restore state before leaving */
		      mged_variables->mv_perspective=prevPerspective;
		      set_perspective();

		      return TCL_ERROR;
		    } else {
		      Tcl_AppendResult(interp, "Loading database: ", dbName, "\n", (char *)NULL);
		    }
		    interactive=prevInteractive;
		    
		  } else {
		    /* compare inode numbers */
		    
		    stat(dbip->dbi_filename, &dbInode);
		    stat(dbName, &scriptInode);
		    
		    /* stop here if they are not the same file, otherwise,
		     * we may proceed as expected, and load the objects.
		     */
		    if (dbInode.st_ino != scriptInode.st_ino) {
		      Tcl_AppendResult(interp, "View script references a different database\nCannot load the view without closing the current database\n(i.e. run \"opendb ", dbName, "\")\n", (char *)NULL);
		      
		      /* restore state before leaving */
		      mged_variables->mv_perspective=prevPerspective;
		      set_perspective();
		      
		      return TCL_ERROR;
		    }
		    
		  }
		  /* end check for loaded database */
		  
		  /* get rid of anything that may be displayed, since we
		   * will load objects that are listed in the script next.
		   */
		  (void)cmd_zap( (ClientData)NULL, interp, 1, NULL );

		  /* now get the objects listed */
		  fscanf(fp, "%s", objects);
		  /*		  bu_log("OBJECTS=%s\n", objects);*/
		  while ((!feof(fp)) && (strncmp(objects, "\\", 1)!=0)) {

		    /* clean off the single quotes... */
		    if (strncmp(objects, "'", 1)==0) {
		      objects[0]=' ';
		      memset(objects+strlen(objects)-1, ' ', 1);
		      sscanf(objects, "%s", objects);
		    }

		    editArgv[0] = "e";
		    editArgv[1] = objects;
		    editArgv[2] = (char *)NULL;
		    if (edit_com( 2, editArgv, 1, 1 ) != 0) {
		      Tcl_AppendResult(interp, "Unable to load object: ", objects, "\n", (char *)NULL);
		    }
		    
		    /* bu_log("objects=%s\n", objects);*/
		    fscanf(fp, "%s", objects);
		  }
d968 6
a973 4
		  /* end iteration over reading in listed objects */
		} else if (strncmp(buffer, "<<EOF", 5)==0) {
		  char *cmdBuffer = NULL;
		  /* we are almost done .. read in the view commands */
d975 10
a984 10
		  while ( (cmdBuffer = rt_read_cmd( fp )) != NULL ) {
		    /* even unsupported commands should return successfully as
		     * they should be calling cm_null()
		     */
		    if ( rt_do_cmd( (struct rt_i *)0, cmdBuffer, view_cmdtab ) < 0 ) { 
		      Tcl_AppendResult(interp, "command failed: ", cmdBuffer, "\n", (char *)NULL);
		    }
		    bu_free( (genptr_t)cmdBuffer, "loadview cmdBuffer" );
		  }
		  /* end iteration over rt commands */
d986 1
a986 1
		}
d989 1
a989 1
	}
d1005 2
a1006 1
	VSET(xlate, 0.0, 0.0, -1.0);
a1009 1
	 */
d1314 1
a1314 1
	sig3(num);			/* Call main SIGINT handler */
d1472 1
a1472 2
	int pid;
	int rpid;
a1473 1
#ifndef WIN32
a1476 10
#else
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_out[2],hSaveStdout,pipe_outDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	STARTUPINFO si = {0};
	PROCESS_INFORMATION pi = {0};
	SECURITY_ATTRIBUTES sa          = {0};
	char name[1024];
	char line1[2048];
#endif
a1611 1
#ifndef WIN32
a1615 6
#else
	      if(*val == '\0')
		bu_vls_printf(&o_vls, " fmt r \\\"\\\\n\\\" ");
	      else	{
		bu_vls_printf(&o_vls, " fmt r \\\"\\\\n%*s\\\" ", count, val);
#endif
a1672 1
#ifndef WIN32
a1715 107
#else
	sa.nLength = sizeof(sa);
	sa.bInheritHandle = TRUE;
	sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_out[0], &pipe_out[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_OUTPUT_HANDLE, pipe_out[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
	DuplicateHandle( GetCurrentProcess(), pipe_out[0],
        GetCurrentProcess(),  &pipe_outDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_out[0] );

	// Save the handle to the current STDERR.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDERR.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDERR.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
	DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
			GetCurrentProcess(), &pipe_inDup, 
			0, FALSE,                  // not inherited       
			DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


	si.cb = sizeof(STARTUPINFO);
	si.lpReserved = NULL;
	si.lpReserved2 = NULL;
	si.cbReserved2 = 0;
	si.lpDesktop = NULL;
	si.dwFlags = 0;
	si.dwFlags = STARTF_USESTDHANDLES;
	si.hStdInput   = pipe_in[0];
	si.hStdOutput  = pipe_out[1];
	si.hStdError   = pipe_err[1];


	sprintf(line1,"%s ",rt_cmd_vec[0]);
	for(i=1;i<rt_cmd_vec_len;i++) {
	  sprintf(name,"%s ",rt_cmd_vec[i]);
	  strcat(line1,name); 
	  if(strstr(name,"-e") != NULL) {
	    i++;
	    sprintf(name,"\"%s\" ",rt_cmd_vec[i]);
	    strcat(line1,name);} 
	}

	if(CreateProcess( NULL, line1, NULL, NULL,TRUE, DETACHED_PROCESS, NULL, NULL, &si, &pi )) {
	  SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	  SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout);
	  SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);
	}
 
	/* use fp_in to feed view info to nirt */
	CloseHandle( pipe_in[0] );
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	//fp_in = fdopen( pipe_in[1], "w" );

	/* use fp_out to read back the result */
	CloseHandle( pipe_out[1] );
	//fp_out = fdopen( pipe_out[0], "r" );
	fp_out = _fdopen( _open_osfhandle((HFILE)pipe_outDup,_O_TEXT), "r" );

	/* use fp_err to read any error messages */
	CloseHandle(pipe_err[1]);
	//fp_err = fdopen( pipe_err[0], "r" );
	fp_err = _fdopen( _open_osfhandle((HFILE)pipe_errDup,_O_TEXT), "r" );

	/* send quit command to nirt */
	fwrite( "q\n", 1, 2, fp_in );
	(void)fclose( fp_in );
#endif
a1781 2
#ifndef WIN32

a1787 5
#else
	/* Wait for program to finish */
	WaitForSingleObject( pi.hProcess, INFINITE );

#endif
d1893 1
a1893 4
	/* for some reason, scale is supposed to be half of size... */
	view_state->vs_vop->vo_size = atof(argv[1]);
	view_state->vs_vop->vo_scale = view_state->vs_vop->vo_size * 0.5;
	view_state->vs_vop->vo_invSize = 1.0 / view_state->vs_vop->vo_size;
d2273 1
a2273 1
  return(0);
@


11.101.2.3
log
@quell warning
@
text
@d2563 1
a2563 1
    snames = skewer_solids(rt_cmd_vec_len, (const char **)rt_cmd_vec, ray_orig, ray_dir, 1);
@


11.100
log
@Converted from K&R to ANSI C - RFH
@
text
@d11 1
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.98 2001/11/14 18:49:26 bparker Exp $ (BRL)";
d61 4
a64 2
extern int mged_svbase(void);
static void setup_rt(register char **vp, int printcmd);
d66 1
d80 78
d167 2
a168 1
pr_wait_status(int status)
d205 3
a207 1
rt_oldwrite(FILE *fp, fastf_t *eye_model)
d230 3
a232 1
rt_write(FILE *fp, fastf_t *eye_model)
d280 5
a284 1
rt_read(FILE *fp, fastf_t *scale, fastf_t *eye, fastf_t *mat)
d356 3
a358 1
setup_rt(register char **vp, int printcmd)
d431 2
a432 1
rt_set_eye_model(fastf_t *eye_model)
d495 1
a495 1
run_rt(void)
d586 5
a590 1
f_rrt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d707 3
a709 2
static char *
basename(register char *p1, register char *suff)
d736 5
a740 1
f_saveview(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d813 225
d1049 5
a1053 1
f_rmats(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1057 1
a1057 1
	register struct solid *sp = SOLID_NULL;
d1086 3
d1227 5
a1231 1
f_savekey(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1267 2
a1268 13
extern int	cm_start(int argc, char **argv);
extern int	cm_vsize(int argc, char **argv);
extern int	cm_eyept(int argc, char **argv);
extern int	cm_lookat_pt(int argc, char **argv);
extern int	cm_vrot(int argc, char **argv);
extern int	cm_end(int argc, char **argv);
extern int	cm_multiview(int argc, char **argv);
extern int	cm_anim(int argc, char **argv);
extern int	cm_tree(int argc, char **argv);
extern int	cm_clean(int argc, char **argv);
extern int	cm_set(int argc, char **argv);
extern int	cm_orientation(int argc, char **argv);

d1294 4
a1301 23
/*
 *			F _ P R E V I E W
 *
 *  Preview a new style RT animation scrtip.
 *  Note that the RT command parser code is used, rather than the
 *  MGED command parser, because of the differences in format.
 *  The RT parser expects command handlers of the form "cm_xxx()",
 *  and all communications are done via global variables.
 *
 *  For the moment, the only preview mode is the normal one,
 *  moving the eyepoint as directed.
 *  However, as a bonus, the eye path is left behind as a vector plot.
 */
static vect_t	rtif_eye_model;
static mat_t	rtif_viewrot;
static struct bn_vlblock	*rtif_vbp;
static FILE	*rtif_fp;
static double	rtif_delay;
static struct _mged_variables    rtif_saved_state;       /* saved state variable\s */
static int	rtif_mode;
static int	rtif_desiredframe;
static int	rtif_finalframe;
static int	rtif_currentframe;
d1314 2
a1315 1
rtif_sigint(int num)
d1334 1
d1337 10
d1349 5
a1353 1
f_preview(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1487 5
a1491 1
f_nirt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1824 5
a1828 1
f_vnirt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1907 3
a1909 1
cm_start(int argc, char **argv)
d1919 3
a1921 1
cm_vsize(int argc, char **argv)
d1930 3
a1932 1
cm_eyept(int argc, char **argv)
d1944 3
a1946 1
cm_lookat_pt(int argc, char **argv)
d1982 3
a1984 1
cm_vrot(int argc, char **argv)
d1997 3
a1999 1
cm_orientation(int argc, char **argv)
d2014 3
a2016 1
cm_end(int argc, char **argv)
d2036 1
a2036 1
       	MAT_COPY(view_state->vs_vop->vo_rotation, rtif_viewrot);
d2089 3
a2091 1
cm_multiview(int argc, char **argv)
d2102 3
a2104 1
cm_anim(int argc, char **argv)
d2126 3
a2128 1
cm_tree(int argc, char **argv)
d2152 3
a2154 1
cm_clean(int argc, char **argv)
d2169 3
a2171 1
cm_set(int argc, char **argv)
d2176 1
a2176 1
extern char **skewer_solids (int argc, const char **argv, fastf_t *ray_orig, fastf_t *ray_dir, int full_path);
d2179 5
a2183 1
cmd_solids_on_ray (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2314 5
a2318 1
cmd_who (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2323 11
@


11.99
log
@Added loadview command.  loadview command is converse of the saveview command.  it reads raytrace script files, handles a proper subset of the possible commands (those related to the view only), and restores the stored view
@
text
@a10 1
 *	f_loadview	load view parameters from a saveview file
d60 2
a61 4
extern int mged_svbase();
extern void set_perspective(); /* from set.c */
/* from ged.c -- used to open databases quietly */
extern int interactive;
a62 1
static void setup_rt();
a75 78
static vect_t	rtif_eye_model;
static mat_t	rtif_viewrot;
static struct bn_vlblock	*rtif_vbp;
static FILE	*rtif_fp;
static double	rtif_delay;
static struct _mged_variables    rtif_saved_state;       /* saved state variable\s */
static int	rtif_mode;
static int	rtif_desiredframe;
static int	rtif_finalframe;
static int	rtif_currentframe;

extern int	cm_start();
extern int	cm_vsize();
extern int	cm_eyept();
extern int	cm_lookat_pt();
extern int	cm_vrot();
extern int	cm_end();
extern int	cm_multiview();
extern int	cm_anim();
extern int	cm_tree();
extern int	cm_clean();
extern int	cm_set();
extern int	cm_ae();
extern int	cm_orientation();
extern int	cm_null();

/* here we define a minimal table of commands that are supported by the
 * loadview command.  unsupported commands are those that have no bearing on
 * view restoration. 
 */
struct command_tab view_cmdtab[] = {
	{"viewsize", "size in mm", "set view size",
		cm_vsize,	2, 2},
	{"eye_pt", "xyz of eye", "set eye point",
		cm_eyept,	4, 4},
	{"lookat_pt", "x y z [yflip]", "set eye look direction, in X-Y plane",
		cm_lookat_pt,	4, 5},
	{"viewrot", "4x4 matrix", "set view direction from matrix",
		cm_vrot,	17,17},
	{"orientation", "quaturnion", "set view direction from quaturnion",
		cm_orientation,	5, 5},
	{"set", 	"", "show or set parameters",
		cm_set,		1, 999},

	/* begin unsupported commands (for view loading) */

	{"start", "frame number", "start a new frame",
		cm_null,	2, 2},
	{"clean", "", "clean articulation from previous frame",
		cm_null,	1, 1},
	{"end", 	"", "end of frame setup, begin raytrace",
		cm_null,		1, 1},

	/* not output, by default in saveview */

	{"multiview", "", "produce stock set of views",
		cm_null,	1, 1},
	{"anim", 	"path type args", "specify articulation animation",
		cm_null,	4, 999},
	{"tree", 	"treetop(s)", "specify alternate list of tree tops",
		cm_null,	1, 999},
	{"ae", "azim elev", "specify view as azim and elev, in degrees",
		cm_null,		3, 3},
	{"opt", "-flags", "set flags, like on command line",
		cm_null,		2, 999},

	/* this is a quick hack used for quietly parsing the EOF delimiter in the
	 * script files. 
	 */
	{"EOF", "", "End of file delimiter",
		cm_null,		1, 1},

	/* XXX support for the ae command is not included, though it probably should */
	{(char *)0, (char *)0, (char *)0,
	        0,		0, 0	/* END */}
};


d85 1
a85 2
pr_wait_status( status )
int	status;
d122 1
a122 3
rt_oldwrite(fp, eye_model)
FILE *fp;
vect_t eye_model;
d145 1
a145 3
rt_write(fp, eye_model)
FILE *fp;
vect_t eye_model;
d193 1
a193 5
rt_read(fp, scale, eye, mat)
FILE	*fp;
fastf_t	*scale;
vect_t	eye;
mat_t	mat;
d265 1
a265 3
setup_rt( vp, printcmd )
register char	**vp;
int printcmd;
d338 1
a338 2
rt_set_eye_model(eye_model)
vect_t eye_model;
d401 1
a401 1
run_rt()
d492 1
a492 5
f_rrt(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d609 2
a610 3
HIDDEN char *
basename( p1, suff )
register char *p1, *suff;
d637 1
a637 5
f_saveview(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char **argv;
a709 225

/*
 *			F _ L O A D V I E W
 *
 *  Load a ray-trace view shell script.  If a database is not open, the 
 *  database listed in the script will attempted to be opened.  If a 
 *  database is open, it must match (inode) the one in the saveview
 *  raytrace script for it to get used.
 *
 *  The actual raytrace functionality is ignored in scripts -- only the view
 *  is intended to be restored, if possible.
 */
int
f_loadview(ClientData clientData, Tcl_Interp *interp, int argc, char *argv[])
{
	register FILE *fp;
	char buffer[512];

	/* data pulled from script file */
  int perspective=-1;
	char dbName[512];
	char objects[1024];
	char *editArgv[2];

	/* save previous interactive state */
	int prevInteractive = interactive;
	int prevPerspective =  mged_variables->mv_perspective;

	/* inodes used for database comparisons */
	struct stat dbInode;
	struct stat scriptInode;

	/* for view orientation */
	vect_t xlate;
	mat_t new_cent;
	

#if 0
	double viewsize;
	double orientation[4]={0.0, 0.0, 0.0, 0.0};
	vect_t eye_pt={0.0, 0.0, 0.0};
#endif

	/* We do not need to check *here* if a database is open, since we will be
	 * loading one anyways.  we manually check when/if we find the database name.
	 */
	/*	CHECK_DBI_NULL; */

	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help loadview");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* open the file for reading */
	if ( (fp = fopen( argv[1], "r" )) == NULL ) {
		perror(argv[1]);
		return TCL_ERROR;
	}

	/* turn perspective mode off, by default.  A "-p" option in the view script
	 * will turn it back on.
	 */
	mged_variables->mv_perspective=-1;
	set_perspective();

	/* iterate over the contents of the raytrace script */
  while (!feof(fp)) {
		memset(buffer, 0, 512);
		fscanf(fp, "%s", buffer);

    if (strncmp(buffer, "-p", 2)==0) {
      /* we found perspective */

      buffer[0]=' ';
      buffer[1]=' ';
      sscanf(buffer, "%d", &perspective);
			/*      bu_log("perspective=%d\n", perspective);*/
			mged_variables->mv_perspective=perspective;
			set_perspective(); /* !!! this does not update the menu variable.. */

    } else if (strncmp(buffer, "$*", 2)==0) {
      /* the next read is the file name, the objects come after that */

      memset(dbName, 0, 1024);
      fscanf(fp, "%s", dbName);
      /* if the last character is a line termination, remove it
       * (it should always be unless the user modifies the file)
       */
      if ( *(dbName + strlen(dbName) - 1)=='\\' ) {
        memset(dbName+strlen(dbName)-1, 0, 1);
      }
			/*      bu_log("dbName=%s\n", dbName); */

			/* if no database is open, we attempt to open the database listed in the
			 * script.  if a database is open, we compare the open database's inode
			 * number with the inode of the database listed in the script.  If they
			 * match, we may proceed. otherwise we need to abort since the wrong
			 * database would be open.
			 */
			if ( dbip == DBI_NULL ) {
				/* load the database */

				/* XXX could use better path handling instead of assuming rooted or . */

				/* turn off interactive mode so the f_opendb() call doesn't blather or
				 * attempt to create a new database
				 */
				interactive=0;
				editArgv[0]="";
				editArgv[1]=dbName;
				editArgv[2]=(char *)NULL;
				if (f_opendb( (ClientData)NULL, interp, 2, editArgv ) == TCL_ERROR) {
					Tcl_AppendResult(interp, "Unable to load database: ", dbName, "\n", (char *)NULL);

					/* restore state before leaving */
					mged_variables->mv_perspective=prevPerspective;
					set_perspective();

					return TCL_ERROR;
				} else {
					Tcl_AppendResult(interp, "Loading database: ", dbName, "\n", (char *)NULL);
				}
				interactive=prevInteractive;

			} else {
				/* compare inode numbers */

				stat(dbip->dbi_filename, &dbInode);
				stat(dbName, &scriptInode);

				/* stop here if they are not the same file, otherwise, we may proceed
				 * as expected, and load the objects.
				 */
				if (dbInode.st_ino != scriptInode.st_ino) {
					Tcl_AppendResult(interp, "View script references a different database\nCannot load the view without closing the current database\n(i.e. run \"opendb ", dbName, "\")\n", (char *)NULL);

					/* restore state before leaving */
					mged_variables->mv_perspective=prevPerspective;
					set_perspective();

					return TCL_ERROR;
				}
					
			}
			/* end check for loaded database */

			/* get rid of anything that may be displayed, since we will load objects
			 * that are listed in the script next.
			 */
			(void)cmd_zap( (ClientData)NULL, interp, 1, NULL );

      /* now get the objects listed */
      fscanf(fp, "%s", objects);
			/*			bu_log("objects=%s\n", objects);*/
      while ((!feof(fp)) && (strncmp(objects, "\\", 1)!=0)) {

				/* clean off the single quotes... */
				if (strncmp(objects, "'", 1)==0) {
					objects[0]=' ';
					memset(objects+strlen(objects)-1, ' ', 1);
					sscanf(objects, "%s", objects);
				}

				editArgv[0] = "e";
				editArgv[1] = objects;
				editArgv[2] = (char *)NULL;
				if (edit_com( 2, editArgv, 1, 1 ) != 0) {
					Tcl_AppendResult(interp, "Unable to load object: ", objects, "\n", (char *)NULL);
				}

				fscanf(fp, "%s", objects);
				/*				bu_log("objects=%s\n", objects);*/
      }			/* end iteration over reading in listed objects */
    } else if (strncmp(buffer, "<<EOF", 5)==0) {
			char *cmdBuffer = NULL;
      /* we are almost done .. read in the view commands */
			
			while ( (cmdBuffer = rt_read_cmd( fp )) != NULL ) {
				/* even unsupported commands should return successfully as they should
				 * be calling cm_null()
				 */
				if ( rt_do_cmd( (struct rt_i *)0, cmdBuffer, view_cmdtab ) < 0 ) { 
					Tcl_AppendResult(interp, "command failed: ", cmdBuffer, "\n", (char *)NULL);
				}
				bu_free( (genptr_t)cmdBuffer, "loadview cmdBuffer" );
			}
			/* end iteration over rt commands */

    }
		/* end check for non-view values (dbname, etc) */

  }
	/* end iteration over file until eof */
	fclose(fp);

	/* now we have to finish the eye point calculations that usually get
	 * postponed until the end command runs.  Since we are at the "end"
	 * of a commands section, we may finish the computations.
	 */
	/* First step:  put eye at view center (view 0,0,0) */
	MAT_COPY(view_state->vs_vop->vo_rotation, rtif_viewrot);
	MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, rtif_eye_model);
	new_mats(); /* actually updates display here (maybe?) */
	
	/* XXX not sure why the correction factor is needed, but it works -- csm */
	/*  Second step:  put eye at view 0,0,1.
	 *  For eye to be at 0,0,1, the old 0,0,-1 needs to become 0,0,0.
	 */
	VSET(xlate, 0.0, 0.0, -1.0);	/* correction factor */
	MAT4X3PNT(new_cent, view_state->vs_vop->vo_view2model, xlate);
	MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, new_cent);
	new_mats();

	/* update the view next time through the event loop */
	update_views = 1;

	return TCL_OK;
}


d721 1
a721 5
f_rmats(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d725 1
a725 1
	register struct solid *sp;
a753 3

	sp = SOLID_NULL;

d892 1
a892 5
f_savekey(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d928 13
a940 2
/* table of commands supported by the preview command
 */
a965 4
	{"ae", "azim elev", "specify view as azim and elev, in degrees",
		cm_null,		3, 3},
	{"opt", "-flags", "set flags, like on command line",
		cm_null,		2, 999},
d970 23
d1005 1
a1005 2
rtif_sigint( num )
int	num;
a1023 1

a1025 10
 *
 *  Preview a new style RT animation scrtip.
 *  Note that the RT command parser code is used, rather than the
 *  MGED command parser, because of the differences in format.
 *  The RT parser expects command handlers of the form "cm_xxx()",
 *  and all communications are done via global variables.
 *
 *  For the moment, the only preview mode is the normal one,
 *  moving the eyepoint as directed.
 *  However, as a bonus, the eye path is left behind as a vector plot.
d1028 1
a1028 5
f_preview(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1162 1
a1162 5
f_nirt(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1495 1
a1495 5
f_vnirt(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d1574 1
a1574 3
cm_start(argc, argv)
char	**argv;
int	argc;
d1584 1
a1584 3
cm_vsize(argc, argv)
char	**argv;
int	argc;
d1593 1
a1593 3
cm_eyept(argc, argv)
char	**argv;
int	argc;
d1605 1
a1605 3
cm_lookat_pt(argc, argv)
int	argc;
char	**argv;
d1641 1
a1641 3
cm_vrot(argc, argv)
char	**argv;
int	argc;
d1654 1
a1654 3
cm_orientation( argc, argv )
int	argc;
char	**argv;
d1669 1
a1669 3
cm_end(argc, argv)
char	**argv;
int	argc;
d1689 1
a1689 1
	MAT_COPY(view_state->vs_vop->vo_rotation, rtif_viewrot);
d1742 1
a1742 3
cm_multiview(argc, argv)
char	**argv;
int	argc;
d1753 1
a1753 3
cm_anim(argc, argv)
int	argc;
char	**argv;
d1775 1
a1775 3
cm_tree(argc, argv)
char	**argv;
int	argc;
d1799 1
a1799 3
cm_clean(argc, argv)
char	**argv;
int	argc;
d1814 1
a1814 3
cm_set(argc, argv)
char	**argv;
int	argc;
d1819 1
a1819 1
extern char **skewer_solids ();
d1822 1
a1822 5
cmd_solids_on_ray (clientData, interp, argc, argv)
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char		**argv;
d1953 1
a1953 5
cmd_who (clientData, interp, argc, argv)
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char 		**argv;
a1957 11
}

/* any commands that are not supported or implemented may call this null
 * routine to avoid rt_do_cmd() "command not found" error reporting
 */
int
cm_null(argc, argv)
char	**argv;
int	argc;
{
	return(0);
@


11.98
log
@*- removed if'ed out code
@
text
@d11 1
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.97 2001/06/05 15:51:42 bparker Exp $ (BRL)";
d62 4
a66 1

d80 78
d707 1
a707 1
static char *
d740 1
a740 1
char	**argv;
d813 225
d1057 1
a1057 1
	register struct solid *sp = SOLID_NULL;
d1086 3
d1267 2
a1268 13
extern int	cm_start();
extern int	cm_vsize();
extern int	cm_eyept();
extern int	cm_lookat_pt();
extern int	cm_vrot();
extern int	cm_end();
extern int	cm_multiview();
extern int	cm_anim();
extern int	cm_tree();
extern int	cm_clean();
extern int	cm_set();
extern int	cm_orientation();

d1294 4
a1301 23
/*
 *			F _ P R E V I E W
 *
 *  Preview a new style RT animation scrtip.
 *  Note that the RT command parser code is used, rather than the
 *  MGED command parser, because of the differences in format.
 *  The RT parser expects command handlers of the form "cm_xxx()",
 *  and all communications are done via global variables.
 *
 *  For the moment, the only preview mode is the normal one,
 *  moving the eyepoint as directed.
 *  However, as a bonus, the eye path is left behind as a vector plot.
 */
static vect_t	rtif_eye_model;
static mat_t	rtif_viewrot;
static struct bn_vlblock	*rtif_vbp;
static FILE	*rtif_fp;
static double	rtif_delay;
static struct _mged_variables    rtif_saved_state;       /* saved state variable\s */
static int	rtif_mode;
static int	rtif_desiredframe;
static int	rtif_finalframe;
static int	rtif_currentframe;
d1334 1
d1337 10
d2036 1
a2036 1
       	MAT_COPY(view_state->vs_vop->vo_rotation, rtif_viewrot);
d2323 11
@


11.97
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.96 2001/06/01 19:23:25 bparker Exp $ (BRL)";
a2028 1
#if 1
a2031 65
#else
	register struct solid *sp;
	int skip_real, skip_phony;

	if(argc < 1 || 2 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help who");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	skip_real = 0;
	skip_phony = 1;
	if (argc > 1) {
		switch (argv[1][0]) {
		case 'b':
			skip_real = 0;
			skip_phony = 0;
			break;
		case 'p':
			skip_real = 1;
			skip_phony = 0;
			break;
		case 'r':
			skip_real = 0;
			skip_phony = 1;
			break;
		default:
			Tcl_AppendResult(interp,"who: argument not understood\n", (char *)NULL);
			return TCL_ERROR;
		}
	}
		

	/* Find all unique top-level entries.
	 *  Mark ones already done with s_wflag == UP
	 */
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
	  sp->s_wflag = DOWN;
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
	  register struct solid *forw;	/* XXX */
	  struct directory *dp = FIRST_SOLID(sp);

	  if( sp->s_wflag == UP )
	    continue;
	  if (dp->d_addr == RT_DIR_PHONY_ADDR){
	    if (skip_phony) continue;
	  } else {
	    if (skip_real) continue;
	  }
	  Tcl_AppendResult(interp, dp->d_namep, " ", (char *)NULL);
	  sp->s_wflag = UP;
	  FOR_REST_OF_SOLIDS(forw, sp, &dgop->dgo_headSolid){
	    if( FIRST_SOLID(forw) == dp )
	      forw->s_wflag = UP;
	  }
	}
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;

	return TCL_OK;
#endif
@


11.96
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.95 2001/05/02 17:14:01 bparker Exp $ (BRL)";
a128 1
#ifdef MGED_USE_VIEW_OBJ
a129 3
#else
	(void)fprintf(fp, "%.9e\n", VIEWSIZE );
#endif
a132 1
#ifdef MGED_USE_VIEW_OBJ
a133 3
#else
		(void)fprintf( fp, "%.9e ", view_state->vs_Viewrot[i] );
#endif
a155 1
#ifdef MGED_USE_VIEW_OBJ
a156 9
#if 0
	(void)fprintf(fp, "viewrot ");
	for (i=0; i < 16; i++) {
		(void)fprintf(fp, "%.15e ", view_state->vs_vop->vo_rotation[i]);
		if ((i%4) == 3)
			(void)fprintf(fp, "\n");
	}
	(void)fprintf(fp, ";\n");
#else
a158 17
#endif
#else
	(void)fprintf(fp, "viewsize %.15e;\n", VIEWSIZE );
#if 0
	(void)fprintf(fp, "viewrot ");
	for( i=0; i < 16; i++ )  {
		(void)fprintf( fp, "%.15e ", view_state->vs_Viewrot[i] );
		if( (i%4) == 3 )
			(void)fprintf(fp, "\n");
	}
	(void)fprintf(fp, ";\n");
#else
	quat_mat2quat( quat, view_state->vs_Viewrot );
	(void)fprintf(fp, "orientation %.15e %.15e %.15e %.15e;\n",
		V4ARGS( quat ) );
#endif
#endif
a296 1
#if 0
a297 10
#else
	struct run_rt *rrp;

	for (BU_LIST_FOR(rrp, run_rt, &head_run_rt.l)) {
		kill(rrp->pid, SIGKILL);
		rrp->aborted = 1;
	}

	return TCL_OK;
#endif
d300 1
d346 1
a355 1
#ifdef MGED_USE_VIEW_OBJ
a356 3
#else
    MAT4X3PNT( eye_model, view_state->vs_view2model, temp );
#endif
a365 1
#ifdef MGED_USE_VIEW_OBJ
a367 4
#else
    VSET(eye_model, -view_state->vs_toViewcenter[MDX],
	 -view_state->vs_toViewcenter[MDY], -view_state->vs_toViewcenter[MDZ]);
#endif
a382 1
#ifdef MGED_USE_VIEW_OBJ
a383 3
#else
    VMOVEN(direction, view_state->vs_Viewrot + 8, 3);
#endif
d408 1
d475 1
a485 1
#if 1
a493 60
#else
	register char **vp;
	register int i;
	char	pstring[32];

	CHECK_DBI_NULL;

	if(argc < 1 || MAXARGS < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help rt");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( not_state( ST_VIEW, "Ray-trace of current view" ) )
	  return TCL_ERROR;

	vp = &rt_cmd_vec[0];
	*vp++ = "rt";
	*vp++ = "-s512";
	*vp++ = "-M";
	*vp++ = "-v60";		/* Reduced RT logging when run interactively */
	if( mged_variables->mv_perspective > 0 )  {
		(void)sprintf(pstring, "-p%g", mged_variables->mv_perspective);
		*vp++ = pstring;
	}
	for( i=1; i < argc; i++ ) {
	    if( argv[i][0] == '-' && argv[i][1] == '-' &&
		argv[i][2] == '\0' ) {
		++i;
		break;
	    }
	    *vp++ = argv[i];
	}
	*vp++ = dbip->dbi_filename;

	/*
	 * Now that we've grabbed all the options, if no args remain,
	 * have setup_rt() append the names of all stuff currently displayed.
	 * Otherwise, simply append the remaining args.
	 */
	if ( i == argc )
	    setup_rt( vp, 1 );
	else {
	    while( i < argc )
		*vp++ = argv[i++];
	    *vp = 0;
	    vp = &rt_cmd_vec[0];
	    while( *vp )
	      Tcl_AppendResult(interp, *vp++, " ", (char *)NULL);

	    Tcl_AppendResult(interp, "\n", (char *)NULL);
	}
	(void)run_rt();

	return TCL_OK;
#endif
d539 1
d606 1
a613 1
#if 1
a616 108
#else
	register char **vp;
	register int i;
	int	pid; 	 
	int	i_pipe[2];	/* MGED reads results for building vectors */
	int	o_pipe[2];	/* MGED writes view parameters */
	int	e_pipe[2];	/* MGED reads textual results */
	FILE	*fp;
	struct rtcheck *rtcp;

	CHECK_DBI_NULL;

	if(argc < 1 || MAXARGS < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help rtcheck");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( not_state( ST_VIEW, "Overlap check in current view" ) )
	  return TCL_ERROR;

	vp = &rt_cmd_vec[0];
	*vp++ = "rtcheck";
	*vp++ = "-s50";
	*vp++ = "-M";
	for( i=1; i < argc; i++ )
		*vp++ = argv[i];
	*vp++ = dbip->dbi_filename;

	setup_rt( vp, 1 );

	(void)pipe( i_pipe );
	(void)pipe( o_pipe );
	(void)pipe( e_pipe );
	(void)signal( SIGINT, SIG_IGN );
	if ( ( pid = fork()) == 0 )  {
		/* Redirect stdin, stdout and stderr */
		(void)close(0);
		(void)dup(i_pipe[0]);
		(void)close(1);
		(void)dup(o_pipe[1]);
		(void)close(2);
		(void)dup(e_pipe[1]);

		/* close pipes */
		(void)close(i_pipe[0]);
		(void)close(i_pipe[1]);
		(void)close(o_pipe[0]);
		(void)close(o_pipe[1]);
		(void)close(e_pipe[0]);
		(void)close(e_pipe[1]);

		for( i=3; i < 20; i++ )
			(void)close(i);

		(void)signal( SIGINT, SIG_DFL );
		(void)execvp( rt_cmd_vec[0], rt_cmd_vec );
		perror( rt_cmd_vec[0] );
		exit(16);
	}

	/* As parent, send view information down pipe */
	(void)close(i_pipe[0]);
	fp = fdopen(i_pipe[1], "w");
	{
		vect_t temp;
		vect_t eye_model;

		VSET( temp, 0.0, 0.0, 1.0 );
#ifdef MGED_USE_VIEW_OBJ
		MAT4X3PNT(eye_model, view_state->vs_vop->vo_view2model, temp);
#else
		MAT4X3PNT( eye_model, view_state->vs_view2model, temp );
#endif
		rt_write(fp, eye_model );
	}
	(void)fclose(fp);

	/* close write end of pipes */
	(void)close(o_pipe[1]);
	(void)close(e_pipe[1]);

	BU_GETSTRUCT(rtcp, rtcheck);

	/* initialize the rtcheck struct */
	rtcp->fd = o_pipe[0];
	rtcp->fp = fdopen(o_pipe[0], "r");
	rtcp->pid = pid;
	rtcp->vbp = rt_vlblock_init();
	rtcp->vhead = rt_vlblock_find( rtcp->vbp, 0xFF, 0xFF, 0x00 );
#ifdef MGED_USE_VIEW_OBJ
	rtcp->csize = view_state->vs_vop->vo_scale * 0.01;
#else
	rtcp->csize = view_state->vs_Viewscale * 0.01;
#endif

	/* register file handlers */
	Tcl_CreateFileHandler(rtcp->fd, TCL_READABLE,
			      rtcheck_vector_handler, (ClientData)rtcp);
	Tcl_CreateFileHandler(e_pipe[0], TCL_READABLE,
			      rtcheck_output_handler, (ClientData)e_pipe[0]);

	return TCL_OK;
#endif
d686 2
a687 2
	if( mged_variables->mv_perspective > 0 )
		(void)fprintf(fp, "-p%g", mged_variables->mv_perspective);
a819 1
#ifdef MGED_USE_VIEW_OBJ
a846 29
#else
	    	case -1:
	    		/* First step:  put eye in center */
		       	view_state->vs_Viewscale = scale;
		       	MAT_COPY( view_state->vs_Viewrot, rot );
			MAT_DELTAS( view_state->vs_toViewcenter,
				-eye_model[X],
				-eye_model[Y],
				-eye_model[Z] );
	    		new_mats();
	    		/* Second step:  put eye in front */
	    		VSET( xlate, 0.0, 0.0, -1.0 );	/* correction factor */
	    		MAT4X3PNT( eye_model, view_state->vs_view2model, xlate );
			MAT_DELTAS( view_state->vs_toViewcenter,
				-eye_model[X],
				-eye_model[Y],
				-eye_model[Z] );
	    		new_mats();
	    		break;
	    	case 0:
		       	view_state->vs_Viewscale = scale;
			MAT_IDN(view_state->vs_Viewrot);	/* top view */
			MAT_DELTAS( view_state->vs_toViewcenter,
				-eye_model[X],
				-eye_model[Y],
				-eye_model[Z] );
			new_mats();
	    		break;
#endif
a949 1
#ifdef MGED_USE_VIEW_OBJ
a950 3
#else
	MAT4X3PNT( eye_model, view_state->vs_view2model, temp );
#endif
a1146 1
#ifdef MGED_USE_VIEW_OBJ
a1149 5
#else
	MAT_COPY(rtif_viewrot, view_state->vs_Viewrot);
	VSET(temp, 0.0, 0.0, 1.0);
	MAT4X3PNT(rtif_eye_model, view_state->vs_view2model, temp);
#endif
a1263 1
#ifdef MGED_USE_VIEW_OBJ
a1268 7
#else
	  MAT4X3PNT(center_model, view_state->vs_view2model, view_ray_orig);
	}else if(!use_input_orig){
	  VSET(center_model, -view_state->vs_toViewcenter[MDX],
	       -view_state->vs_toViewcenter[MDY], -view_state->vs_toViewcenter[MDZ]);
	}
#endif
a1275 1
#ifdef MGED_USE_VIEW_OBJ
a1276 3
#else
		MAT4X3PNT(eye, view_state->vs_view2model, pt);
#endif
a1287 1
#ifdef MGED_USE_VIEW_OBJ
a1288 3
#else
		VMOVEN(dir, view_state->vs_Viewrot + 8, 3);
#endif
d1322 1
a1322 1
	    int count;
a1342 2
	    else
	      count = 0;
a1583 1
#ifdef MGED_USE_VIEW_OBJ
a1584 3
#else
  MAT4X3PNT(center_model, view_state->vs_view2model, view_ray_orig);
#endif
a1633 1
#ifdef MGED_USE_VIEW_OBJ
a1634 3
#else
	view_state->vs_Viewscale = atof(argv[1])*0.5;
#endif
a1743 1
#ifdef MGED_USE_VIEW_OBJ
a1767 26
#else
	/* First step:  put eye at view center (view 0,0,0) */
       	MAT_COPY( view_state->vs_Viewrot, rtif_viewrot );
	MAT_DELTAS_VEC_NEG( view_state->vs_toViewcenter, rtif_eye_model );
	new_mats();

	/*
	 * Compute camera orientation notch to right (+X) and up (+Y)
	 * Done here, with eye in center of view.
	 */
	VSET( xv, 0.05, 0.0, 0.0 );
	VSET( yv, 0.0, 0.05, 0.0 );
	MAT4X3PNT( xm, view_state->vs_view2model, xv );
	MAT4X3PNT( ym, view_state->vs_view2model, yv );
	RT_ADD_VLIST( vhead, xm, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, rtif_eye_model, BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, ym, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, rtif_eye_model, BN_VLIST_LINE_MOVE );

	/*  Second step:  put eye at view 0,0,1.
	 *  For eye to be at 0,0,1, the old 0,0,-1 needs to become 0,0,0.
	 */
	VSET( xlate, 0.0, 0.0, -1.0 );	/* correction factor */
	MAT4X3PNT( new_cent, view_state->vs_view2model, xlate );
	MAT_DELTAS_VEC_NEG( view_state->vs_toViewcenter, new_cent );
#endif
a1937 1
#ifdef MGED_USE_VIEW_OBJ
a1939 4
#else
    VSET(ray_orig, -view_state->vs_toViewcenter[MDX],
	-view_state->vs_toViewcenter[MDY], -view_state->vs_toViewcenter[MDZ]);
#endif
a1959 1
#ifdef MGED_USE_VIEW_OBJ
a1960 3
#else
    VMOVEN(ray_dir, view_state->vs_Viewrot + 8, 3);
#endif
a1984 1
#ifdef MGED_USE_VIEW_OBJ
a1988 6
#else
    VMOVEN(unit_H, view_state->vs_model2view, 3);
    VMOVEN(unit_V, view_state->vs_model2view + 4, 3);
    VJOIN1(ray_orig, ray_orig, h * view_state->vs_Viewscale * INV_GED, unit_H);
    VJOIN1(ray_orig, ray_orig, v * view_state->vs_Viewscale * INV_GED, unit_V);
#endif
@


11.95
log
@*- modified commands to use new librt routines
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.94 2001/04/02 21:38:20 morrison Exp $ (BRL)";
d58 1
d129 3
d133 1
d137 3
d141 1
d164 15
d193 1
d198 1
a198 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l) {
d203 1
a203 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l) {
d218 1
a218 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l) {
d272 1
a272 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)
d274 1
a274 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
d290 1
a290 1
		for(BU_LIST_PFOR(forw, sp, solid, &HeadSolid.l)){
d327 1
a327 1
cmd_rt_abort(ClientData clientData,
d332 3
d343 1
d400 3
d404 1
d414 4
d420 1
d426 1
a426 1
    FOR_ALL_SOLIDS (sp, &HeadSolid.l){
d436 3
d440 1
d518 1
a518 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)
d536 4
a539 5
f_rt(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d541 10
d609 1
d672 1
a672 1
    FOR_ALL_SOLIDS(sp, &HeadSolid.l)
d723 4
a726 5
f_rtcheck(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d728 5
d805 3
d809 1
d826 3
d830 1
d839 1
d919 1
a919 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)
d921 1
a921 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
d930 1
a930 1
		for(BU_LIST_PFOR(forw, sp, solid, &HeadSolid.l)){
d948 1
a948 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)
d1011 1
a1011 1
		FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
d1043 29
d1099 1
d1203 3
d1207 1
d1404 5
d1412 1
d1527 7
d1539 1
d1547 3
d1551 1
d1563 3
d1567 1
d1807 1
a1807 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)
d1865 3
d1869 1
d1919 3
d1923 1
d2032 27
a2058 1
	
d2083 1
d2093 1
a2093 1
	  (void)f_zap( (ClientData)NULL, interp, 1, av );
d2254 4
d2260 1
d2270 1
a2270 1
    FOR_ALL_SOLIDS (sp, &HeadSolid.l)
d2281 3
d2285 1
d2310 6
d2320 1
d2361 1
a2361 1
#if 0
d2364 1
a2364 1
	return dg_who_cmd(dgp, interp, argc, argv);
d2405 1
a2405 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)
d2407 1
a2407 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
d2420 1
a2420 1
	  FOR_REST_OF_SOLIDS(forw, sp, &HeadSolid.l){
d2425 1
a2425 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)
@


11.94
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.93 2001/03/31 01:57:23 morrison Exp $ (BRL)";
d2192 1
a2192 1
	return invoke_db_wrapper(interp, argc, argv);
@


11.93
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.92 2001/03/26 19:15:55 bparker Exp $ (BRL)";
d981 1
a981 1
		       	bn_mat_copy( view_state->vs_Viewrot, rot );
d1305 1
a1305 1
	bn_mat_copy(rtif_viewrot, view_state->vs_Viewrot);
d1905 1
a1905 1
       	bn_mat_copy( view_state->vs_Viewrot, rtif_viewrot );
@


11.92
log
@*- check-in #if'd out unfinished work from tgm/offsite
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/rtif.c,v 11.91 2001/03/19 22:20:02 butler Exp $ (BRL)";
d998 1
a998 1
			bn_mat_idn(view_state->vs_Viewrot);	/* top view */
@


11.91
log
@patches to merge 5.3 into 6.0
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/rtif.c,v 11.90 2001/01/23 14:30:59 jra Exp $ (BRL)";
d2189 2
d2192 2
d2257 1
@


11.90
log
@Mods to get query ray to work in perspective mode
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.89 2001/01/05 15:54:45 bparker Exp $ (BRL)";
d1427 1
@


11.89
log
@Change default image size from "50" to "512"
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.88 2000/11/16 21:20:29 bparker Exp $ (BRL)";
d1371 1
a1396 1
	*vp++ = "-M";
d1427 27
a1456 5
	  vect_t cml;

	  VSCALE(cml, center_model, base2local);
	  VMOVEN(dir, view_state->vs_Viewrot + 8, 3);
	  VSCALE(dir, dir, -1.0);
d1465 1
a1465 6
	  bu_vls_init(&p_vls);
	  bu_vls_printf(&p_vls, "xyz %lf %lf %lf;",
			cml[X], cml[Y], cml[Z]);
	  bu_vls_printf(&p_vls, "dir %lf %lf %lf;",
			dir[X], dir[Y], dir[Z]);
	  bu_vls_printf(&p_vls, "s; fmt r \"\\n\"");
d1473 4
a1481 4
	    bu_vls_printf(&o_vls, "xyz %lf %lf %lf;",
			  cml[X], cml[Y], cml[Z]);
	    bu_vls_printf(&o_vls, "dir %lf %lf %lf;",
			  dir[X], dir[Y], dir[Z]);
d1505 1
a1505 1
	      bu_vls_printf(&o_vls, "s; fmt r \"\\n\" ");
d1507 1
a1507 1
	      bu_vls_printf(&o_vls, "s; fmt r \"\\n%*s\" ", count, val);
d1543 3
d1605 2
a1606 2
	/* As parent, send view information down pipe */
	rt_write(fp_in, center_model );
d1609 1
d1611 1
a1611 3
#if 1
	  bu_vls_free(&p_vls);   /* use to form "partition" part of nirt command above */
#endif
@


11.88
log
@Add rt_abort command that aborts all
rt processes forked by MGED.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.87 2000/10/26 19:05:52 bparker Exp $ (BRL)";
d521 1
a521 1
	*vp++ = "-s50";
@


11.87
log
@Code to once again wait for spawned
rt processes.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.86 2000/10/24 19:05:08 mike Exp $ (BRL)";
d64 1
a64 4
struct run_rt {
       int			fd;
       int			pid;
};
d301 16
d335 1
d344 2
d347 1
d350 4
d480 1
@


11.86
log
@
Fixed compiler lint, function declarations.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.85 2000/10/20 05:08:34 mike Exp $ (BRL)";
d64 5
d305 1
a305 3
rt_output_handler(clientData, mask)
ClientData clientData;
int mask;
d307 4
a310 3
  int fd = (int)((long)clientData & 0xFFFF);	/* fd's will be small */
  int count;
  char line[RT_MAXLINE];
d312 2
a313 3
  /* Get data from rt */
#if 0
  if((count = read((int)fd, line, RT_MAXLINE)) == 0){
d315 4
a318 1
  if((count = read((int)fd, line, 5120)) == 0){
d320 12
a331 2
    Tcl_DeleteFileHandler(fd);
    close(fd);
d333 2
a334 2
    return;
  }
d336 1
a336 1
  line[count] = '\0';
d338 2
a339 2
  /*XXX For now just blather to stderr */
  bu_log("%s", line);
d414 2
d420 1
a420 1
	if ( (fork()) == 0 )  {
d458 6
a463 2
	Tcl_CreateFileHandler(pipe_err[0], TCL_READABLE,
			      rt_output_handler, (ClientData)pipe_err[0]);
d696 1
a696 1
		(void)dup( o_pipe[0] );
d698 1
a698 1
		(void)dup( i_pipe[1] );
d700 1
a700 1
		(void)dup( e_pipe[1] );
d720 2
a721 2
	(void)close( o_pipe[0] );
	fp = fdopen( o_pipe[1], "w" );
d730 1
a730 1
	(void)fclose( fp );
d733 1
a733 1
	(void)close(i_pipe[1]);
d739 2
a740 2
	rtcp->fd = i_pipe[0];
	rtcp->fp = fdopen(i_pipe[0], "r");
d747 1
a747 1
	Tcl_CreateFileHandler(i_pipe[0], TCL_READABLE,
@


11.85
log
@
Moved DIR_USED from mged/rtif.c to h/raytrace.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.84 2000/10/20 05:04:39 mike Exp $ (BRL)";
d42 1
d236 1
a236 3
build_tops(start, end)
char **start;
register char **end;
@


11.84
log
@
s_path array has been replaced by a s_fullpath "struct db_full_path".
This has eliminated the MAX_PATH restriction in MGED.
member s_last is gone too.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.83 2000/09/06 21:14:50 mike Exp $ (BRL)";
a168 1
#define DIR_USED	0x80	/* XXX move to raytrace.h */
@


11.83
log
@
lint
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.82 2000/08/19 03:10:17 mike Exp $ (BRL)";
d172 2
a173 2
		for (i=0;i<=sp->s_last;i++) {
			sp->s_path[i]->d_flags &= ~DIR_USED;
d177 4
a180 2
		for (i=0; i<=sp->s_last; i++ ) {
			if (!(sp->s_path[i]->d_flags & DIR_USED)) {
d182 1
a182 1
				for (anp = sp->s_path[i]->d_animate; anp;
d186 1
a186 1
				sp->s_path[i]->d_flags |= DIR_USED;
d192 2
a193 2
		for (i=0;i<=sp->s_last;i++) {
			sp->s_path[i]->d_flags &= ~DIR_USED;
d251 1
d255 1
a255 1
		if( sp->s_path[0]->d_addr == RT_DIR_PHONY_ADDR )
d258 1
a258 1
			*vp++ = sp->s_path[0]->d_namep;
d261 1
a261 1
				   sp->s_path[0]->d_namep, "\n", (char *)NULL);
d266 1
a266 1
			if( forw->s_path[0] == sp->s_path[0] )
d816 1
d820 2
a821 2
		if (sp->s_path[0]->d_addr == RT_DIR_PHONY_ADDR) continue;
		(void)fprintf(fp, "'%s' ", sp->s_path[0]->d_namep);
d824 1
a824 1
			if( forw->s_path[0] == sp->s_path[0] )
d905 1
a905 1
			if( sp->s_path[(int)(sp->s_last)] != dp )  continue;
d2171 1
d2175 1
a2175 1
	  if (sp->s_path[0]->d_addr == RT_DIR_PHONY_ADDR){
d2180 1
a2180 1
	  Tcl_AppendResult(interp, sp->s_path[0]->d_namep, " ", (char *)NULL);
d2183 1
a2183 1
	    if( forw->s_path[0] == sp->s_path[0] )
@


11.82
log
@
Reduced use of MAXARGS
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.81 2000/08/16 21:46:19 mike Exp $ (BRL)";
d33 6
a40 1
#include <stdio.h>
d901 1
a901 1
			if( sp->s_path[sp->s_last] != dp )  continue;
d1083 26
a1108 26
	"start", "frame number", "start a new frame",
		cm_start,	2, 2,
	"viewsize", "size in mm", "set view size",
		cm_vsize,	2, 2,
	"eye_pt", "xyz of eye", "set eye point",
		cm_eyept,	4, 4,
	"lookat_pt", "x y z [yflip]", "set eye look direction, in X-Y plane",
		cm_lookat_pt,	4, 5,
	"orientation", "quaturnion", "set view direction from quaturnion",
		cm_orientation,	5, 5,
	"viewrot", "4x4 matrix", "set view direction from matrix",
		cm_vrot,	17,17,
	"end", 	"", "end of frame setup, begin raytrace",
		cm_end,		1, 1,
	"multiview", "", "produce stock set of views",
		cm_multiview,	1, 1,
	"anim", 	"path type args", "specify articulation animation",
		cm_anim,	4, 999,
	"tree", 	"treetop(s)", "specify alternate list of tree tops",
		cm_tree,	1, 999,
	"clean", "", "clean articulation from previous frame",
		cm_clean,	1, 1,
	"set", 	"", "show or set parameters",
		cm_set,		1, 999,
	(char *)0, (char *)0, (char *)0,
		0,		0, 0	/* END */
@


11.81
log
@
lint
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.80 2000/06/13 16:24:54 bparker Exp $ (BRL)";
d383 1
d775 1
a775 1
	if(argc < 2 || MAXARGS < argc){
d869 1
a869 1
	if(argc < 2 || MAXARGS < argc){
d1035 1
a1035 1
	if(argc < 2 || MAXARGS < argc){
d1177 1
a1177 1
	if(argc < 2 || MAXARGS < argc){
d1268 1
a1268 1
			    rtif_finalframe && rtif_currentframe > rtif_finalframe )  {
d1641 1
a1641 1
  if(argc < 3 || MAXARGS < argc){
d1704 1
d1716 1
d1727 1
d1741 1
d1779 1
d1794 1
d1886 1
d1949 1
d1966 1
@


11.80
log
@Use s_wflag (work flag) instead of s_iflag (illumination flag).
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.79 2000/02/17 16:34:03 mike Exp $ (BRL)";
d1900 1
a1900 1
  if( db_parse_anim( dbip, argc, argv ) < 0 )  {
@


11.80.2.1
log
@Code to once again wait for
spawned rt processes.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.80 2000/06/13 16:24:54 bparker Exp $ (BRL)";
a57 5
struct run_rt {
       int			fd;
       int			pid;
};

d294 3
a296 1
rt_output_handler(ClientData clientData, int mask)
d298 5
a302 2
	struct run_rt *run_rtp = (struct run_rt *)clientData;
	int count;
d304 1
a304 4
	char line[RT_MAXLINE+1];

	/* Get data from rt */
	if ((count = read((int)run_rtp->fd, line, RT_MAXLINE)) == 0) {
d306 1
a306 4
	char line[5120+1];

	/* Get data from rt */
	if ((count = read((int)run_rtp->fd, line, 5120)) == 0) {
d308 2
a309 2
		int retcode;
		int rpid;
d311 2
a312 2
		Tcl_DeleteFileHandler(run_rtp->fd);
		close(run_rtp->fd);
d314 1
a314 3
		/* wait for the forked process */
		while ((rpid = wait(&retcode)) != run_rtp->pid && rpid != -1)
			pr_wait_status(retcode);
d316 2
a317 10
		/* free run_rtp */
		bu_free((genptr_t)run_rtp, "rt_output_handler: run_rtp");

		return;
	}

	line[count] = '\0';

	/*XXX For now just blather to stderr */
	bu_log("%s", line);
a390 2
	int		pid; 	 
	struct run_rt	*run_rtp;
d395 1
a395 1
	if ((pid = fork()) == 0) {
d433 2
a434 6
	BU_GETSTRUCT(run_rtp, run_rt);
	run_rtp->fd = pipe_err[0];
	run_rtp->pid = pid;

	Tcl_CreateFileHandler(run_rtp->fd, TCL_READABLE,
			      rt_output_handler, (ClientData)run_rtp);
d667 1
a667 1
		(void)dup(i_pipe[0]);
d669 1
a669 1
		(void)dup(o_pipe[1]);
d671 1
a671 1
		(void)dup(e_pipe[1]);
d691 2
a692 2
	(void)close(i_pipe[0]);
	fp = fdopen(i_pipe[1], "w");
d701 1
a701 1
	(void)fclose(fp);
d704 1
a704 1
	(void)close(o_pipe[1]);
d710 2
a711 2
	rtcp->fd = o_pipe[0];
	rtcp->fp = fdopen(o_pipe[0], "r");
d718 1
a718 1
	Tcl_CreateFileHandler(rtcp->fd, TCL_READABLE,
@


11.80.2.2
log
@Add rt_abort command that will abort
any raytrace initiated from MGED.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.80.2.1 2000/10/26 19:06:45 bparker Exp $ (BRL)";
d58 4
a61 1
struct run_rt head_run_rt;
a297 16
int
cmd_rt_abort(ClientData clientData,
	     Tcl_Interp *interp,
	     int argc,
	     char **argv)
{
	struct run_rt *rrp;

	for (BU_LIST_FOR(rrp, run_rt, &head_run_rt.l)) {
		kill(rrp->pid, SIGKILL);
		rrp->aborted = 1;
	}

	return TCL_OK;
}

a315 1
		int aborted;
a323 2
		aborted = run_rtp->aborted;

a324 1
 		BU_LIST_DEQUEUE(&run_rtp->l);
a326 4
		if (aborted)
			bu_log("Raytrace aborted.\n");
		else
			bu_log("Raytrace complete.\n");
a451 1
	BU_LIST_APPEND(&head_run_rt.l, &run_rtp->l);
@


11.80.2.3
log
@Mods to get query ray to work in perspective mode
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.80.2.2 2000/11/15 21:31:19 bparker Exp $ (BRL)";
a1362 1
	vect_t cml;
d1388 1
a1419 28
	if( mged_variables->mv_perspective_mode )
	{
		point_t pt, eye;

		/* get eye point */
		VSET(pt, 0.0, 0.0, 1.0);
		MAT4X3PNT(eye, view_state->vs_view2model, pt);
		VSCALE(eye, eye, base2local);

		/* point passed in is actually the aim point */
		VSCALE(cml, center_model, base2local);
		VSUB2(dir, cml, eye);
		VUNITIZE(dir);

		/* copy eye point to cml (cml is used for the "xyz" command to nirt */
		VMOVE(cml, eye);
	} else {
		VSCALE(cml, center_model, base2local);
		VMOVEN(dir, view_state->vs_Viewrot + 8, 3);
		VSCALE(dir, dir, -1.0);
	}

	bu_vls_init(&p_vls);
	bu_vls_printf(&p_vls, "xyz %lf %lf %lf;",
		cml[X], cml[Y], cml[Z]);
	bu_vls_printf(&p_vls, "dir %lf %lf %lf; s",
		dir[X], dir[Y], dir[Z]);

d1422 5
d1435 6
a1440 1
	  /* ray start, direction, and 's' command */
a1447 4
	  /* ray start, direction, and 's' command */
	  *vp++ = "-e";
	  *vp++ = bu_vls_addr(&p_vls);

d1453 4
d1480 1
a1480 1
	      bu_vls_printf(&o_vls, " fmt r \"\\n\" ");
d1482 1
a1482 1
	      bu_vls_printf(&o_vls, " fmt r \"\\n%*s\" ", count, val);
a1517 3
        *vp++ = "-e";
        *vp++ = bu_vls_addr(&p_vls);

d1577 2
a1578 2
	/* send quit command to nirt */
	fwrite( "q\n", 1, 2, fp_in );
a1580 1
	bu_vls_free(&p_vls);   /* use to form "partition" part of nirt command above */
d1582 3
a1584 1

@


11.80.2.4
log
@Change default image size from "50" to "512"
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.80.2.3 2001/01/05 15:12:32 jra Exp $ (BRL)";
d514 1
a514 1
	*vp++ = "-s512";
@


11.79
log
@
Application of -v option to RT was backwards, has been fixed.
Want full logging for batch runs, reduced logging for interactive.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.78 2000/02/01 20:20:07 mike Exp $ (BRL)";
d238 1
a238 1
	 *  Mark ones already done with s_iflag == UP
d241 1
a241 1
		sp->s_iflag = DOWN;
d245 1
a245 1
		if( sp->s_iflag == UP )
d256 1
a256 1
		sp->s_iflag = UP;
d259 1
a259 1
				forw->s_iflag = UP;
d431 1
a431 1
		sp->s_iflag = DOWN;
d570 1
a570 1
      sp->s_iflag = DOWN;
d801 1
a801 1
	 *  Mark ones already done with s_iflag == UP
d804 1
a804 1
		sp->s_iflag = DOWN;
d808 1
a808 1
		if( sp->s_iflag == UP )
d812 1
a812 1
		sp->s_iflag = UP;
d815 1
a815 1
				forw->s_iflag = UP;
d832 1
a832 1
		sp->s_iflag = DOWN;
d1615 1
a1615 1
		sp->s_iflag = DOWN;
d2146 1
a2146 1
	 *  Mark ones already done with s_iflag == UP
d2149 1
a2149 1
	  sp->s_iflag = DOWN;
d2153 1
a2153 1
	  if( sp->s_iflag == UP )
d2161 1
a2161 1
	  sp->s_iflag = UP;
d2164 1
a2164 1
	      forw->s_iflag = UP;
d2168 1
a2168 1
		sp->s_iflag = DOWN;
@


11.78
log
@
fixed warning.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.77 2000/01/21 21:52:45 butler Exp $ (BRL)";
d472 1
d755 4
d791 2
a792 1
	(void)fprintf(fp, "#!/bin/sh\nrt -M -v60 ");
@


11.77
log
@Reduced the default level of chatter from rt within mged
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.76 1999/12/30 19:34:15 jra Exp $ (BRL)";
d298 1
a298 1
  int fd = (int)clientData;
d600 1
a600 1
  int fd = (int)clientData;
@


11.76
log
@Eliminated some unused variables
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.75 1999/12/27 18:51:26 bparker Exp $ (BRL)";
d786 1
a786 1
	(void)fprintf(fp, "#!/bin/sh\nrt -M ");
@


11.75
log
@*- use RT_MAXLINE instead of MAXLINE
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.74 1999/12/01 14:06:35 bparker Exp $ (BRL)";
a336 1
    vect_t  unit_H, unit_V;
a386 2
	int pid, rpid;
	int retcode;
a389 2
	char line[MAXLINE];
	struct bu_vls vls;
d395 1
a395 1
	if ( ( pid = fork()) == 0 )  {
a450 2
	int retcode;
	char *dm;
a451 1
	struct bu_vls cmd;
d503 1
a503 1
	retcode = run_rt();
a523 3
	int	retcode;
	char	*dm;
	struct bu_vls cmd;
d546 1
a546 1
	retcode = run_rt();
a627 1
	int	retcode;
a1310 1
	int use_air;
a1445 1
	  int j;
a1736 1
	int	yflip = 0;
a1742 2
	if( argc > 4 )
		yflip = atoi(argv[4]);
@


11.74
log
@*- mods to reflect changes in struct dm
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.73 1999/10/29 17:26:30 bparker Exp $ (BRL)";
d300 1
a300 1
  char line[MAXLINE];
d304 1
a304 1
  if((count = read((int)fd, line, MAXLINE)) == 0){
d610 1
a610 1
  char line[MAXLINE];
d615 1
a615 1
  if((count = read((int)fd, line, MAXLINE)) == 0){
d2109 3
a2111 1
/* list the objects currently being edited (displayed)*/
@


11.73
log
@*- mods to rtcheck_vector_handler()
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.72 1999/09/13 14:22:09 bparker Exp $ (BRL)";
d324 1
a324 1
  if((zclip_ptr != NULL && *zclip_ptr) || mged_variables->mv_perspective_mode){
@


11.72
log
@*- declare setup_rt to be static
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.71 1999/09/09 19:42:57 bparker Exp $ (BRL)";
d597 1
a597 1
  (void)rt_process_uplot_value( rtcp->vhead,
@


11.71
log
@*- make the new rt process a process group leader
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.70 1999/09/08 21:04:26 bparker Exp $ (BRL)";
d54 1
a54 1
void		setup_rt();
@


11.70
log
@*- pulled code from run_rt() to create rt_set_eye_model()
   (i.e. now calling rt_set_eye_model() from run_rt())
*- mods to f_saveview to honor the zclip setting by
   calling rt_set_eye_model()
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.69 1999/09/01 18:55:11 bparker Exp $ (BRL)";
d401 3
@


11.69
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.68 1999/08/16 14:42:59 bparker Exp $ (BRL)";
d275 1
a275 1
void
d320 61
d428 1
a428 53
	if((zclip_ptr != NULL && *zclip_ptr) || mged_variables->mv_perspective_mode){
	  vect_t temp;

	  VSET( temp, 0.0, 0.0, 1.0 );
	  MAT4X3PNT( eye_model, view_state->vs_view2model, temp );
	}else{ /* not doing zclipping, so back out of geometry */
	  double  t;
	  double  t_in;
	  vect_t  direction;
	  vect_t  extremum[2];
	  vect_t  minus, plus;    /* vers of this solid's bounding box */
	  vect_t  unit_H, unit_V;

	  VSET(eye_model, -view_state->vs_toViewcenter[MDX],
	        -view_state->vs_toViewcenter[MDY], -view_state->vs_toViewcenter[MDZ]);

	  for (i = 0; i < 3; ++i){
	    extremum[0][i] = INFINITY;
	    extremum[1][i] = -INFINITY;
	  }
	  FOR_ALL_SOLIDS (sp, &HeadSolid.l){
	    minus[X] = sp->s_center[X] - sp->s_size;
	    minus[Y] = sp->s_center[Y] - sp->s_size;
	    minus[Z] = sp->s_center[Z] - sp->s_size;
	    VMIN( extremum[0], minus );
	    plus[X] = sp->s_center[X] + sp->s_size;
	    plus[Y] = sp->s_center[Y] + sp->s_size;
	    plus[Z] = sp->s_center[Z] + sp->s_size;
	    VMAX( extremum[1], plus );
	  }
	  VMOVEN(direction, view_state->vs_Viewrot + 8, 3);
	  VSCALE(direction, direction, -1.0);
	  for(i = 0; i < 3; ++i)
	    if (NEAR_ZERO(direction[i], 1e-10))
	      direction[i] = 0.0;
	  if ((eye_model[X] >= extremum[0][X]) &&
	      (eye_model[X] <= extremum[1][X]) &&
	      (eye_model[Y] >= extremum[0][Y]) &&
	      (eye_model[Y] <= extremum[1][Y]) &&
	      (eye_model[Z] >= extremum[0][Z]) &&
	      (eye_model[Z] <= extremum[1][Z])){
	    t_in = -INFINITY;
	    for(i = 0; i < 6; ++i){
	      if (direction[i%3] == 0)
		continue;
	      t = (extremum[i/3][i%3] - eye_model[i%3]) /
		direction[i%3];
	      if ((t < 0) && (t > t_in))
		t_in = t;
	    }
	    VJOIN1(eye_model, eye_model, t_in, direction);
	  }
	}
d823 1
d825 1
a825 2
		vect_t temp;
		vect_t eye_model;
d827 2
a828 3
		VSET( temp, 0.0, 0.0, 1.0 );
		MAT4X3PNT( eye_model, view_state->vs_view2model, temp );
		rt_write(fp, eye_model);
d830 1
@


11.68
log
@*- mods to fix rtcheck
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.67 1999/07/02 22:18:38 mike Exp $ (BRL)";
d449 1
a449 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d524 1
a524 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d634 1
a634 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d767 1
a767 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d860 1
a860 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1168 1
a1168 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1326 1
a1326 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1634 1
a1634 2
  if(dbip == DBI_NULL)
    return TCL_OK;
@


11.67
log
@
Removed dependence on compat4.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.66 1999/06/11 20:16:55 bparker Exp $ (BRL)";
d56 10
a65 1
static int	tree_walk_needed;
a305 2
    /* anything bigger than 5120 causes the last line (i.e. bu_log("%s", line);)
       to hang if writing to a pipe */
d552 67
a618 5
/*
 *			F _ R T C H E C K
 *
 *  Invoke "rtcheck" to find overlaps, and display them as a vector overlay.
 */
d628 1
a628 1
	int	pid, rpid;
d630 3
a632 2
	int	o_pipe[2];
	int	i_pipe[2];
d634 1
a634 2
	struct solid *sp;
	struct bn_vlblock	*vbp;
d662 3
a664 2
	(void)pipe( o_pipe );			/* output from mged */
	(void)pipe( i_pipe );			/* input back to mged */
d667 1
d672 11
a700 4
#if 0
		/* This old way is no longer needed for RT */
		rt_oldwrite(fp, eye_model );
#endif
d705 1
a705 1
	/* Prepare to receive UNIX-plot back from child */
d707 1
a707 20
	fp = fdopen(i_pipe[0], "r");
	vbp = rt_vlblock_init();
	(void)rt_uplot_to_vlist( vbp, fp, view_state->vs_Viewscale * 0.01 );
	fclose(fp);

	/* Wait for program to finish */
	while ((rpid = wait(&retcode)) != pid && rpid != -1)
		;	/* NULL */

	if( retcode != 0 )
		pr_wait_status( retcode );

#if 0
	(void)signal(SIGINT, cur_sigint);
#else
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else
	  return TCL_OK;
#endif
d709 1
a709 2
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)
		sp->s_iflag = DOWN;
d711 13
a723 4
	/* Add overlay */
	cvt_vlblock_to_solids( vbp, "OVERLAPS", 0 );
	rt_vlblock_free(vbp);
	view_state->vs_flag = 1;
a724 1
	(void)signal( SIGINT, SIG_IGN );
d727 1
@


11.66
log
@*- pass qray's stored nirt script to nirt
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.65 1999/04/02 14:56:19 pjt Exp $ (BRL)";
d565 1
a565 1
	struct rt_vlblock	*vbp;
d795 1
a795 1
	register struct rt_vlist *vp;
d829 1
a829 1
			vp = BU_LIST_LAST( rt_vlist, &(sp->s_vlist) );
d891 1
a891 1
			vp = BU_LIST_LAST( rt_vlist, &(sp->s_vlist) );
d893 1
a893 1
			for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d900 2
a901 2
					case RT_VLIST_POLY_START:
					case RT_VLIST_POLY_VERTNORM:
d903 5
a907 5
					case RT_VLIST_LINE_MOVE:
					case RT_VLIST_LINE_DRAW:
					case RT_VLIST_POLY_MOVE:
					case RT_VLIST_POLY_DRAW:
					case RT_VLIST_POLY_END:
d921 1
a921 1
			vp = BU_LIST_LAST( rt_vlist, &(sp->s_vlist) );
d923 1
a923 1
			for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d930 2
a931 2
					case RT_VLIST_POLY_START:
					case RT_VLIST_POLY_VERTNORM:
d933 5
a937 5
					case RT_VLIST_LINE_MOVE:
					case RT_VLIST_LINE_DRAW:
					case RT_VLIST_POLY_MOVE:
					case RT_VLIST_POLY_DRAW:
					case RT_VLIST_POLY_END:
d1052 1
a1052 1
static struct rt_vlblock	*rtif_vbp;
d1085 1
a1085 1
		rtif_vbp = (struct rt_vlblock *)NULL;
d1216 1
a1216 1
		rtif_vbp = (struct rt_vlblock *)NULL;
d1261 1
a1261 1
	struct rt_vlblock *vbp;
d1695 1
a1695 1
	   At the moment mat_lookat will return NAN's if the direction vector
d1761 1
a1761 1
		RT_ADD_VLIST( vhead, rtif_eye_model, RT_VLIST_LINE_MOVE );
d1763 1
a1763 1
		RT_ADD_VLIST( vhead, rtif_eye_model, RT_VLIST_LINE_DRAW );
d1779 4
a1782 4
	RT_ADD_VLIST( vhead, xm, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, rtif_eye_model, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, ym, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, rtif_eye_model, RT_VLIST_LINE_MOVE );
@


11.65
log
@Modified the rt command to allow arguments beyond the options
that allow rendering other than everything-currently-displayed.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.64 1999/03/29 19:48:27 bparker Exp $ (BRL)";
d1402 6
@


11.64
log
@*- close file
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.63 1999/03/18 17:59:43 bparker Exp $ (BRL)";
d466 8
a473 2
	for( i=1; i < argc; i++ )
		*vp++ = argv[i];
d476 17
a492 1
	setup_rt( vp, 1 );
@


11.63
log
@*- make sure (zclip_ptr != NULL) before using
*- modified rt_output_handler's read
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.62 1999/01/27 19:17:51 bparker Exp $ (BRL)";
d302 2
d333 1
a333 1
	  /* Redirect stdin, stdout, stderr */
@


11.62
log
@*- cleanup
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.61 1999/01/21 18:31:20 bparker Exp $ (BRL)";
d294 1
d296 5
d358 1
a358 1
	if(*zclip_ptr || mged_variables->mv_perspective_mode){
@


11.61
log
@*- use helpdevel for help on developer commands
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.60 1998/11/06 22:32:42 bparker Exp $ (BRL)";
a52 3
extern void mged_update();
extern void reset_input_strings();
extern int event_check();
@


11.60
log
@*- use new structures
*- cleanup
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.59 1998/10/21 16:29:34 bparker Exp $ (BRL)";
d1898 1
a1898 1
      bu_vls_printf(&vls, "help solids_on_ray");
@


11.59
log
@*- use macro instead of literal
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.58 1998/06/11 19:41:48 bparker Exp $ (BRL)";
d118 1
a118 1
		(void)fprintf( fp, "%.9e ", Viewrot[i] );
d145 1
a145 1
		(void)fprintf( fp, "%.15e ", Viewrot[i] );
d151 1
a151 1
	quat_mat2quat( quat, Viewrot );
d355 1
a355 1
	if(*zclip_ptr || mged_variables->perspective_mode){
d359 1
a359 1
	  MAT4X3PNT( eye_model, view2model, temp );
d368 2
a369 2
	  VSET(eye_model, -toViewcenter[MDX],
	        -toViewcenter[MDY], -toViewcenter[MDZ]);
d385 1
a385 1
	  VMOVEN(direction, Viewrot + 8, 3);
d457 2
a458 2
	if( mged_variables->perspective > 0 )  {
		(void)sprintf(pstring, "-p%g", mged_variables->perspective);
d591 1
a591 1
		MAT4X3PNT( eye_model, view2model, temp );
d604 1
a604 1
	(void)rt_uplot_to_vlist( vbp, fp, Viewscale * 0.01 );
d629 1
a629 1
	dmaflag = 1;
d697 2
a698 2
	if( mged_variables->perspective > 0 )
		(void)fprintf(fp, "-p%g", mged_variables->perspective);
d729 1
a729 1
		MAT4X3PNT( eye_model, view2model, temp );
d833 3
a835 3
		       	Viewscale = scale;
		       	bn_mat_copy( Viewrot, rot );
			MAT_DELTAS( toViewcenter,
d842 2
a843 2
	    		MAT4X3PNT( eye_model, view2model, xlate );
			MAT_DELTAS( toViewcenter,
d850 3
a852 3
		       	Viewscale = scale;
			bn_mat_idn(Viewrot);	/* top view */
			MAT_DELTAS( toViewcenter,
d888 1
a888 1
		dmaflag = 1;
a921 4
#ifdef DO_SCROLL_UPDATES
	set_scroll();
#endif

d961 1
a961 1
	MAT4X3PNT( eye_model, view2model, temp );
d1097 1
a1097 1
	mged_variables->autosize = 0;
d1159 1
a1159 1
	bn_mat_copy(rtif_viewrot, Viewrot);
d1161 1
a1161 1
	MAT4X3PNT(rtif_eye_model, view2model, temp);
a1197 4
#ifdef DO_SCROLL_UPDATES
	set_scroll();
#endif

d1262 1
a1262 1
	  }else if(adc_draw)
d1264 1
a1264 1
	}else if(adc_draw)
d1267 1
a1267 1
	if(mged_variables->use_air){
d1273 1
a1273 1
	if(!use_input_orig && adc_draw){
d1276 1
a1276 1
	  VSET(view_ray_orig, (fastf_t)dv_xadc, (fastf_t)dv_yadc, GED_MAX);
d1278 1
a1278 1
	  MAT4X3PNT(center_model, view2model, view_ray_orig);
d1280 2
a1281 2
	  VSET(center_model, -toViewcenter[MDX],
	       -toViewcenter[MDY], -toViewcenter[MDZ]);
d1289 1
a1289 1
	  VMOVEN(dir, Viewrot + 8, 3);
d1389 1
a1389 1
	}else if(adc_draw)
d1576 1
a1576 1
  MAT4X3PNT(center_model, view2model, view_ray_orig);
d1624 1
a1624 1
	Viewscale = atof(argv[1])*0.5;
d1734 2
a1735 2
       	bn_mat_copy( Viewrot, rtif_viewrot );
	MAT_DELTAS_VEC_NEG( toViewcenter, rtif_eye_model );
d1744 2
a1745 2
	MAT4X3PNT( xm, view2model, xv );
	MAT4X3PNT( ym, view2model, yv );
d1755 2
a1756 2
	MAT4X3PNT( new_cent, view2model, xlate );
	MAT_DELTAS_VEC_NEG( toViewcenter, new_cent );
d1770 1
a1770 1
	dmaflag = 1;
d1772 1
a1772 1
	dmaflag = 1;
d1924 2
a1925 2
    VSET(ray_orig, -toViewcenter[MDX],
	-toViewcenter[MDY], -toViewcenter[MDZ]);
d1946 1
a1946 1
    VMOVEN(ray_dir, Viewrot + 8, 3);
d1971 4
a1974 4
    VMOVEN(unit_H, model2view, 3);
    VMOVEN(unit_V, model2view + 4, 3);
    VJOIN1(ray_orig, ray_orig, h * Viewscale * INV_GED, unit_H);
    VJOIN1(ray_orig, ray_orig, v * Viewscale * INV_GED, unit_V);
@


11.58
log
@*- using floating point literals to initialize floats
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/rtif.c,v 11.57 1998/03/19 17:54:31 bparker Exp $ (BRL)";
d1284 1
a1284 1
	  VSET(view_ray_orig, (fastf_t)dv_xadc, (fastf_t)dv_yadc, 2047.0);
d1540 1
a1540 1
  fastf_t sf = 1.0/2047.0;
d1577 1
a1577 1
  view_ray_orig[Z] = 2047.0;
d1925 1
a1925 1
    if ((-2047 > h)  || (h > 2047) || (-2047 > v)  || (v > 2047))
d1981 2
a1982 2
    VJOIN1(ray_orig, ray_orig, h * Viewscale / 2047.0, unit_H);
    VJOIN1(ray_orig, ray_orig, v * Viewscale / 2047.0, unit_V);
@


11.57
log
@*- use "Query Ray" variables instead of mged_variables
*- moved query_ray_data_to_vlist() to qray.c
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.56 1998/03/06 22:36:45 bparker Exp bparker $ (BRL)";
d358 1
a358 1
	  VSET( temp, 0, 0, 1 );
d590 1
a590 1
		VSET( temp, 0, 0, 1 );
d728 1
a728 1
		VSET( temp, 0, 0, 1 );
d841 1
a841 1
	    		VSET( xlate, 0, 0, -1 );	/* correction factor */
d964 1
a964 1
	VSET( temp, 0, 0, 1 );
d1164 1
a1164 1
	VSET(temp, 0, 0, 1);
d1750 2
a1751 2
	VSET( xv, 0.05, 0, 0 );
	VSET( yv, 0, 0.05, 0 );
d1762 1
a1762 1
	VSET( xlate, 0, 0, -1 );	/* correction factor */
@


11.56
log
@*- clean up some old ADC related code
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.55 1998/03/03 19:13:31 bparker Exp bparker $ (BRL)";
d51 1
a58 39
/* query ray stuff */
extern struct bu_vls query_ray_basename;

struct query_ray_fmt {
    struct bu_vls tclName;
    struct bu_vls fmt;
};
extern struct query_ray_fmt *query_ray_fmts;

struct query_ray_fmt_data {
  char type;
  char *fmt;
};
extern struct query_ray_fmt_data def_query_ray_fmt_data[];

#define QUERY_RAY_TEXT 't'
#define QUERY_RAY_GRAPHICS 'g'
#define QUERY_RAY_BOTH 'b'
#define DO_QUERY_RAY_TEXT (mged_variables->query_ray_behavior == QUERY_RAY_TEXT ||\
		      mged_variables->query_ray_behavior == QUERY_RAY_BOTH)
#define DO_QUERY_RAY_GRAPHICS (mged_variables->query_ray_behavior == QUERY_RAY_GRAPHICS ||\
			  mged_variables->query_ray_behavior == QUERY_RAY_BOTH)
#define DO_QUERY_RAY_BOTH (mged_variables->query_ray_behavior == QUERY_RAY_BOTH)
#define QUERY_RAY_FORMAT_P_CMD "fmt p \"%e %e %e %e\\n\" x_in y_in z_in los"
#define QUERY_RAY_FORMAT_NULL_CMD "fmt r \"\"; fmt h \"\"; fmt m \"\"; fmt o \"\"; fmt f \"\""

struct query_ray_dataList {
  struct bu_list l;
  fastf_t x_in;
  fastf_t y_in;
  fastf_t z_in;
  fastf_t los;
};

struct query_ray_dataList HeadQuery_RayData;
void query_ray_data_to_vlist();

/* End query_ray format stuff */

d1239 3
a1241 1
	struct bu_vls g_vls;
d1243 2
a1244 1
	struct query_ray_dataList *ndlp;
d1270 1
a1270 1
	  }else if(mged_variables->adcflag)
d1272 1
a1272 1
	}else if(mged_variables->adcflag)
d1275 5
d1281 1
a1281 1
	if(!use_input_orig && mged_variables->adcflag){
d1293 1
a1293 1
	if(DO_QUERY_RAY_GRAPHICS){
d1301 16
a1316 1
	  *vp++ = QUERY_RAY_FORMAT_NULL_CMD;
d1318 1
a1318 1
	  *vp++ = QUERY_RAY_FORMAT_P_CMD;
d1320 1
a1320 1
	  if(DO_QUERY_RAY_TEXT){
d1324 2
a1325 2
	    bu_vls_init(&g_vls);
	    bu_vls_printf(&g_vls, "xyz %lf %lf %lf;",
d1327 1
a1327 1
	    bu_vls_printf(&g_vls, "dir %lf %lf %lf;",
d1331 1
a1331 1
	    val = Tcl_GetVar(interp, bu_vls_addr(&query_ray_fmts[0].tclName), TCL_GLOBAL_ONLY);
d1352 1
a1352 1
	      bu_vls_printf(&g_vls, "s; fmt r \"\\n\" ");
d1354 1
a1354 1
	      bu_vls_printf(&g_vls, "s; fmt r \"\\n%*s\" ", count, val);
d1357 1
a1357 1
	      bu_vls_printf(&g_vls, "%s", val);
d1363 1
a1363 1
	    *vp++ = bu_vls_addr(&g_vls);
d1367 13
a1379 10
	if(DO_QUERY_RAY_TEXT){
	  /* read Tcl format variables and load into vp here */
	  for(; def_query_ray_fmt_data[i].fmt != (char *)NULL; ++i){
	    *vp++ = "-e";
	    val = Tcl_GetVar(interp, bu_vls_addr(&query_ray_fmts[i].tclName), TCL_GLOBAL_ONLY);
	    bu_vls_trunc(&query_ray_fmts[i].fmt, 0);
	    bu_vls_printf(&query_ray_fmts[i].fmt, "fmt %c %s", def_query_ray_fmt_data[i].type, val);
	    *vp++ = bu_vls_addr(&query_ray_fmts[i].fmt);
	  }
	}
d1381 2
a1382 3
	if(mged_variables->use_air){
	  *vp++ = "-u";
	  *vp++ = "1";
d1389 1
a1389 1
	setup_rt( vp, mged_variables->query_ray_cmd_echo );
d1397 1
a1397 1
	}else if(mged_variables->adcflag)
d1432 1
a1432 1
	/* use fp_in to feed view info to query_ray */
d1448 6
a1453 3
	if(DO_QUERY_RAY_GRAPHICS){
	  if(DO_QUERY_RAY_TEXT)
	    bu_vls_free(&g_vls); /* used to form part of query_ray command above */
d1455 1
a1455 1
	  BU_LIST_INIT(&HeadQuery_RayData.l);
d1457 1
d1464 2
a1465 2
	    BU_GETSTRUCT(ndlp, query_ray_dataList);
	    BU_LIST_APPEND(HeadQuery_RayData.l.back, &ndlp->l);
d1473 23
a1495 7
	  query_ray_data_to_vlist(vbp, &HeadQuery_RayData, dir);
	  bu_list_free(&HeadQuery_RayData.l);
	  val = Tcl_GetVar(interp, bu_vls_addr(&query_ray_basename), TCL_GLOBAL_ONLY);
	  if(val == NULL) /* user must have unset query_ray_basename */
	    cvt_vlblock_to_solids(vbp, "query_ray", 0);
	  else
	    cvt_vlblock_to_solids(vbp, val, 0);
d1497 1
d1501 3
a1503 1
	if(DO_QUERY_RAY_TEXT){
d1565 2
a1566 2
   * converted to local units before being handed to query_ray. All other
   * arguments are passed straight through to query_ray.
a1612 45
}

void
query_ray_data_to_vlist(vbp, headp, dir)
struct rt_vlblock *vbp;
struct query_ray_dataList *headp;
vect_t dir;
{
  register int i = 0;
  register struct bu_list *vhead;
  register struct query_ray_dataList *ndlp;
  vect_t in, out;
  vect_t last_out, last_in;

  for(BU_LIST_FOR(ndlp, query_ray_dataList, &headp->l)){
    if(i % 2)
      vhead = rt_vlblock_find(vbp,
			      mged_variables->query_ray_color_odd[0],
			      mged_variables->query_ray_color_odd[1],
			      mged_variables->query_ray_color_odd[2]);
    else
      vhead = rt_vlblock_find(vbp,
			      mged_variables->query_ray_color_even[0],
			      mged_variables->query_ray_color_even[1],
			      mged_variables->query_ray_color_even[2]);

    VSET(in, ndlp->x_in, ndlp->y_in, ndlp->z_in);
    VJOIN1(out, in, ndlp->los, dir);
    VSCALE(in, in, local2base);
    VSCALE(out, out, local2base);
    RT_ADD_VLIST( vhead, in, RT_VLIST_LINE_MOVE );
    RT_ADD_VLIST( vhead, out, RT_VLIST_LINE_DRAW );

    if(i && !VAPPROXEQUAL(last_out,in,SQRT_SMALL_FASTF)){
      vhead = rt_vlblock_find(vbp,
			      mged_variables->query_ray_color_void[0],
			      mged_variables->query_ray_color_void[1],
			      mged_variables->query_ray_color_void[2]);
      RT_ADD_VLIST( vhead, last_out, RT_VLIST_LINE_MOVE );
      RT_ADD_VLIST( vhead, in, RT_VLIST_LINE_DRAW );
    }

    VMOVE(last_out, out);
    ++i;
  }
@


11.55
log
@*- mod to run_rt() so that raytraced image lines up with wireframe in perspective mode
*- change echo_query_ray_cmd to query_ray_cmd_echo
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.54 1998/02/26 16:25:28 bparker Exp bparker $ (BRL)";
a1312 1
	  fastf_t sf = 1.0/2047.0;
d1314 2
a1315 2
	  VSET(view_ray_orig, curs_x, curs_y, 2047.0);
	  VSCALE(view_ray_orig, view_ray_orig, sf);
@


11.54
log
@*- mods necessary to move to Tcl 8.0
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.53 1998/02/20 23:18:33 bparker Exp bparker $ (BRL)";
d393 1
a393 1
	if(*zclip_ptr){
d1403 1
a1403 1
	setup_rt( vp, mged_variables->echo_query_ray_cmd );
@


11.53
log
@*- mods to run_rt() ---- no longer waits for rt to finish
*- add rt_output_handler() to handle stderr spew from rt
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.52 1998/02/06 22:04:57 bparker Exp bparker $ (BRL)";
d336 1
a336 2
    Tcl_DeleteFileHandler(Tcl_GetFile((ClientData)fd, TCL_UNIX_FD));
    Tcl_FreeFile(Tcl_GetFile((ClientData)fd, TCL_UNIX_FD));
d452 2
a453 2
	Tcl_CreateFileHandler(Tcl_GetFile((ClientData)pipe_err[0], TCL_UNIX_FD),
			      TCL_READABLE, rt_output_handler, (ClientData)pipe_err[0]);
@


11.52
log
@*- use mged_variables to control drawing of query/nirt ray
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.51 1998/01/28 16:17:49 bparker Exp bparker $ (BRL)";
d52 1
d325 22
a355 1
	int o_pipe[2];
a356 1
	FILE *fp_out, *fp_err;
a357 1
	int pipe_out[2];
a363 1
	(void)pipe( pipe_out );
a369 2
	  (void)close(1);
	  (void)dup( pipe_out[1] );
a375 2
	  (void)close(pipe_out[0]);
	  (void)close(pipe_out[1]);
a391 5
	/* use fp_out to read back anything that might be here */
	(void)close( pipe_out[1] );
	fp_out = fdopen( pipe_out[0], "r" );

	/* use fp_err to read any error messages */
a392 1
	fp_err = fdopen( pipe_err[0], "r" );
d447 1
a447 1
	rt_write(fp_in, eye_model );
d453 2
a454 50
#ifdef USE_FRAMEBUFFER
	{
	  struct dm_list *dlp;

	  dlp = curr_dm_list;
	  reset_input_strings();

	  /* loop until fb_busy_flag gets incremented */
	  i = fb_busy_flag + 1;
	  while(fb_busy_flag < i){
	    event_check(1);  /* non-blocking */

	    if(sedraw > 0)
	      sedit();

	    refresh();
	  }

	  while(fb_busy_flag){
	    event_check(1);  /* non-blocking */

	    if(sedraw > 0)
	      sedit();

	    if(dlp->_mged_variables->fb)
	      dlp->_dirty = 1;  /* redraw display manager window contents */

	    refresh();
	  }
	}
#endif

	while(fgets(line, MAXLINE, fp_out) != (char *)NULL)
	  Tcl_AppendResult(interp, line, (char *)NULL);
	(void)fclose(fp_out);

	while(fgets(line, MAXLINE, fp_err) != (char *)NULL)
	  Tcl_AppendResult(interp, line, (char *)NULL);
	(void)fclose(fp_err);

	/* Wait for program to finish */
	while ((rpid = wait(&retcode)) != pid && rpid != -1)
	  ; /* Null */

	if( retcode != 0 )
		pr_wait_status( retcode );

#if 0
	(void)signal(SIGINT, cur_sigint);
#endif
d456 1
a456 1
	return(retcode);
@


11.51
log
@*- mods to reflect the fact that nirt_behavior is now a char
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.50 1998/01/16 21:59:10 bparker Exp bparker $ (BRL)";
d57 2
a58 5
/* nirt stuff */
extern struct bu_vls nirt_even_color;
extern struct bu_vls nirt_odd_color;
extern struct bu_vls nirt_void_color;
extern struct bu_vls nirt_basename;
d60 1
a60 1
struct nirt_fmt {
d64 1
a64 1
extern struct nirt_fmt *nirt_fmts;
d66 1
a66 1
struct nirt_fmt_data {
d70 1
a70 1
extern struct nirt_fmt_data def_nirt_fmt_data[];
d72 10
a81 10
#define NIRT_TEXT 't'
#define NIRT_GRAPHICS 'g'
#define NIRT_BOTH 'b'
#define DO_NIRT_TEXT (mged_variables->nirt_behavior == NIRT_TEXT ||\
		      mged_variables->nirt_behavior == NIRT_BOTH)
#define DO_NIRT_GRAPHICS (mged_variables->nirt_behavior == NIRT_GRAPHICS ||\
			  mged_variables->nirt_behavior == NIRT_BOTH)
#define DO_NIRT_BOTH (mged_variables->nirt_behavior == NIRT_BOTH)
#define NIRT_FORMAT_P_CMD "fmt p \"%e %e %e %e\\n\" x_in y_in z_in los"
#define NIRT_FORMAT_NULL_CMD "fmt r \"\"; fmt h \"\"; fmt m \"\"; fmt o \"\"; fmt f \"\""
d83 1
a83 1
struct nirt_dataList {
d91 2
a92 2
struct nirt_dataList HeadNirtData;
void nirt_data_to_vlist();
d94 1
a94 1
/* End nirt format stuff */
d1291 1
a1291 1
 *  Invoke NIRT with the current view & stuff
d1319 1
a1319 1
	struct nirt_dataList *ndlp;
d1326 1
a1326 1
	  bu_vls_printf(&vls, "help nirt");
d1364 1
a1364 1
	if(DO_NIRT_GRAPHICS){
d1372 1
a1372 1
	  *vp++ = NIRT_FORMAT_NULL_CMD;
d1374 1
a1374 1
	  *vp++ = NIRT_FORMAT_P_CMD;
d1376 1
a1376 1
	  if(DO_NIRT_TEXT){
d1387 1
a1387 1
	    val = Tcl_GetVar(interp, bu_vls_addr(&nirt_fmts[0].tclName), TCL_GLOBAL_ONLY);
d1423 1
a1423 1
	if(DO_NIRT_TEXT){
d1425 1
a1425 1
	  for(; def_nirt_fmt_data[i].fmt != (char *)NULL; ++i){
d1427 4
a1430 4
	    val = Tcl_GetVar(interp, bu_vls_addr(&nirt_fmts[i].tclName), TCL_GLOBAL_ONLY);
	    bu_vls_trunc(&nirt_fmts[i].fmt, 0);
	    bu_vls_printf(&nirt_fmts[i].fmt, "fmt %c %s", def_nirt_fmt_data[i].type, val);
	    *vp++ = bu_vls_addr(&nirt_fmts[i].fmt);
d1443 1
a1443 1
	setup_rt( vp, mged_variables->echo_nirt_cmd );
d1486 1
a1486 1
	/* use fp_in to feed view info to nirt */
d1502 3
a1504 3
	if(DO_NIRT_GRAPHICS){
	  if(DO_NIRT_TEXT)
	    bu_vls_free(&g_vls); /* used to form part of nirt command above */
d1506 1
a1506 1
	  BU_LIST_INIT(&HeadNirtData.l);
d1514 2
a1515 2
	    BU_GETSTRUCT(ndlp, nirt_dataList);
	    BU_LIST_APPEND(HeadNirtData.l.back, &ndlp->l);
d1523 5
a1527 5
	  nirt_data_to_vlist(vbp, &HeadNirtData, dir);
	  bu_list_free(&HeadNirtData.l);
	  val = Tcl_GetVar(interp, bu_vls_addr(&nirt_basename), TCL_GLOBAL_ONLY);
	  if(val == NULL) /* user must have unset nirt_ray_basename */
	    cvt_vlblock_to_solids(vbp, "nirt_ray", 0);
d1534 1
a1534 1
	if(DO_NIRT_TEXT){
d1585 1
a1585 1
    bu_vls_printf(&vls, "help vnirt");
d1596 2
a1597 2
   * converted to local units before being handed to nirt. All other
   * arguments are passed straight through to nirt.
d1602 1
a1602 1
    bu_vls_printf(&vls, "help vnirt");
d1647 1
a1647 1
nirt_data_to_vlist(vbp, headp, dir)
d1649 1
a1649 1
struct nirt_dataList *headp;
d1654 1
a1654 1
  register struct nirt_dataList *ndlp;
a1656 31
  char *color;
  int even_red, even_green, even_blue;
  int odd_red, odd_green, odd_blue;
  int void_red, void_green, void_blue;

  /* get even color */
  color = Tcl_GetVar(interp, bu_vls_addr(&nirt_even_color), TCL_GLOBAL_ONLY);
  if(sscanf(color, "%d %d %d", &even_red, &even_green, &even_blue) != 3){
    /* user must have improperly set or perhaps unset nirt_ray_colors(even) */
    even_red = 255;
    even_green = 255;
    even_blue = 0;
  }

  /* get odd color */
  color = Tcl_GetVar(interp, bu_vls_addr(&nirt_odd_color), TCL_GLOBAL_ONLY);
  if(sscanf(color, "%d %d %d", &odd_red, &odd_green, &odd_blue) != 3){
    /* user must have improperly set or perhaps unset nirt_ray_colors(odd) */
    odd_red = 0;
    odd_green = 255;
    odd_blue = 255;
  }

  /* get void color */
  color = Tcl_GetVar(interp, bu_vls_addr(&nirt_void_color), TCL_GLOBAL_ONLY);
  if(sscanf(color, "%d %d %d", &void_red, &void_green, &void_blue) != 3){
    /* user must have improperly set or perhaps unset nirt_ray_colors(void) */
    void_red = 255;
    void_green = 0;
    void_blue = 255;
  }
d1658 1
a1658 1
  for(BU_LIST_FOR(ndlp, nirt_dataList, &headp->l)){
d1660 4
a1663 1
      vhead = rt_vlblock_find(vbp, odd_red, odd_green, odd_blue); /* odd */
d1665 4
a1668 1
      vhead = rt_vlblock_find(vbp, even_red, even_green, even_blue); /* even */
d1678 4
a1681 1
      vhead = rt_vlblock_find(vbp, void_red, void_green, void_blue); /* between partitions */
@


11.50
log
@mods to run_rt() to utilize MGED's new framebuffer code
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.49 1997/12/23 14:20:08 bparker Exp bparker $ (BRL)";
d75 3
a77 3
#define NIRT_TEXT 0
#define NIRT_GRAPHICS 1
#define NIRT_BOTH 2
@


11.49
log
@mods to f_nirt()
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.48 1997/12/17 23:38:56 mike Exp bparker $ (BRL)";
d52 2
d444 35
d489 1
a489 1
		;	/* NULL */
a496 3

	FOR_ALL_SOLIDS(sp, &HeadSolid.l)
		sp->s_iflag = DOWN;
@


11.48
log
@Silenced compiler warnings.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.47 1997/12/17 23:37:28 mike Exp mike $ (BRL)";
a55 1
extern struct bu_vls nirt_void_color;
d58 1
a59 2
extern struct bu_vls nirt_use_air;
extern struct bu_vls nirt_print_cmd;
d93 1
a1278 1
	int print_cmd;
a1286 1
	struct bu_vls air_vls;
d1403 4
a1406 8
	val = Tcl_GetVar(interp, bu_vls_addr(&nirt_use_air), TCL_GLOBAL_ONLY);
	if(sscanf(val, "%d", &use_air) != 1)
	  use_air = 1;

	*vp++ = "-e";
	bu_vls_init(&air_vls);
	bu_vls_printf(&air_vls, "useair %d",  use_air);
	*vp++ = bu_vls_addr(&air_vls);
d1412 1
a1412 5
	val = Tcl_GetVar(interp, bu_vls_addr(&nirt_print_cmd), TCL_GLOBAL_ONLY);
	if(sscanf(val, "%d", &print_cmd) != 1)
	  print_cmd = 0;

	setup_rt( vp, print_cmd );
a1470 2
	bu_vls_free(&air_vls);

d1492 1
a1492 1
	  (void)nirt_data_to_vlist(vbp, &HeadNirtData, dir);
d1615 1
a1615 1
int
a1679 1
  return 42;
@


11.47
log
@BParker additions
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.46 1997/12/04 14:50:06 bparker Exp bparker $ (BRL)";
d1693 1
@


11.46
log
@mods to f_nirt
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.45 1997/09/08 18:36:46 bparker Exp bparker $ (BRL)";
d55 43
d309 1
a309 1
setup_rt( vp )
d311 1
d316 5
a320 4
  /* Print out the command we are about to run */
  vp = &rt_cmd_vec[0];
  while( *vp )
    Tcl_AppendResult(interp, *vp++, " ", (char *)NULL);
d322 2
a323 1
  Tcl_AppendResult(interp, "\n", (char *)NULL);
d336 8
a343 1
	FILE *fp;
d345 3
a347 1
	(void)pipe( o_pipe );
d350 23
a372 8
		(void)close(0);
		(void)dup( o_pipe[0] );
		for( i=3; i < 20; i++ )
			(void)close(i);
		(void)signal( SIGINT, SIG_DFL );
		(void)execvp( rt_cmd_vec[0], rt_cmd_vec );
		perror( rt_cmd_vec[0] );
		exit(16);
d376 2
a377 5
	(void)close( o_pipe[0] );
	fp = fdopen( o_pipe[1], "w" );
	{
		vect_t temp;
		vect_t eye_model;
d379 60
a438 3
		VSET( temp, 0, 0, 1 );
		MAT4X3PNT( eye_model, view2model, temp );
		rt_write(fp, eye_model );
d440 10
a449 1
	(void)fclose( fp );
d513 1
a513 1
	setup_rt( vp );
d560 1
a560 1
	setup_rt( vp );
d612 1
a612 1
	setup_rt( vp );
d970 4
d1201 1
a1201 1
	setup_rt( &rt_cmd_vec[1] );
d1250 4
d1271 2
a1272 6
	register int i;
	register struct solid *sp;
	double	t;
	double	t_in;
	FILE *fp;
	FILE *fp2;
d1275 3
a1277 3
	int o_pipe[2];
	int o_pipe2[2];
	int c;
d1279 6
d1286 6
a1291 7
	fastf_t xorig, yorig;
	vect_t	center_model;
	vect_t  view_ray_orig;
	vect_t	direction;
	vect_t	extremum[2];
	vect_t	minus, plus;	/* vers of this solid's bounding box */
	vect_t	unit_H, unit_V;
a1296 2
	  struct bu_vls vls;

d1301 1
a1304 6
	if( not_state( ST_VIEW, "Single ray-trace from current view" ) )
	  return TCL_ERROR;

	VSET(center_model, -toViewcenter[MDX],
	     -toViewcenter[MDY], -toViewcenter[MDZ]);

a1307 43
#if 1
	/*
	 * Look through options for -p ----> process that one here.
	 * Pass everything else to nirt.
	 */
	bu_optind = 1;
	while((c = bu_getopt(argc, argv, "Msvu:x:p:")) != EOF)
	  switch(c){
	  case 'M':
	    /* ignore */
	    break;
	  case 's':
	    *vp++ = "-s";
	    break;
	  case 'v':
	    *vp++ = "-v";
	    break;
	  case 'u':
	    *vp++ = "-u";
	    *vp++ = bu_optarg;
	    break;
	  case 'x':
	    *vp++ = "-x";
	    *vp++ = bu_optarg;
	    break;
	  case 'p':
	    {
	      if(sscanf(bu_optarg, "%lf", &xorig) != 1)
		xorig = 0.0;

	      if(bu_optind >= argc){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help nirt");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	      }

	      if(sscanf(argv[bu_optind], "%lf", &yorig) != 1)
		yorig = 0.0;
	      ++bu_optind;
d1309 77
a1385 1
	      use_input_orig = 1;
d1387 5
d1393 21
a1414 3
	argc -= (bu_optind - 1);
	argv += (bu_optind - 1);
#endif
d1419 3
a1421 1
	setup_rt( vp );
d1423 18
a1440 2
	(void)pipe( o_pipe );
	(void)pipe( o_pipe2 );
d1443 1
d1445 1
a1445 1
		(void)dup( o_pipe[0] );
d1447 11
a1457 5
		(void)dup( o_pipe2[1] );
		(void)close(o_pipe[0]);
		(void)close(o_pipe[1]);
		(void)close(o_pipe2[0]);
		(void)close(o_pipe2[1]);
d1466 12
d1479 23
a1501 28
	(void)close( o_pipe[0] );
	fp = fdopen( o_pipe[1], "w" );
	/* We also need to read back the result */
	(void)close( o_pipe2[1] );
	fp2 = fdopen( o_pipe2[0], "r" );

	if (mged_variables->adcflag || use_input_orig){
	  if(use_input_orig){
	    struct bu_vls vls;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "Firing from (%lf, %lf, 0.0)...\n",
			  xorig, yorig);
	    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	    bu_vls_free(&vls);
	  }else{
	    Tcl_AppendResult(interp, "Firing through angle/distance cursor...\n",
			     (char *)NULL);
	    xorig = curs_x;
	    yorig = curs_y;
	  }
#if 1
	  {
	    fastf_t sf = 1.0/2047.0;
	      
	    VSET(view_ray_orig, xorig, yorig, 2047.0);
	    VSCALE(view_ray_orig, view_ray_orig, sf);
	    MAT4X3PNT(center_model, view2model, view_ray_orig);
a1502 54
#else
		    /*
		     * Compute bounding box of all objects displayed.
		     * Borrowed from size_reset() in chgview.c
		     */
		    for (i = 0; i < 3; ++i)
		    {
			extremum[0][i] = INFINITY;
			extremum[1][i] = -INFINITY;
		    }
		    FOR_ALL_SOLIDS (sp, &HeadSolid.l)
		    {
			    minus[X] = sp->s_center[X] - sp->s_size;
			    minus[Y] = sp->s_center[Y] - sp->s_size;
			    minus[Z] = sp->s_center[Z] - sp->s_size;
			    VMIN( extremum[0], minus );
			    plus[X] = sp->s_center[X] + sp->s_size;
			    plus[Y] = sp->s_center[Y] + sp->s_size;
			    plus[Z] = sp->s_center[Z] + sp->s_size;
			    VMAX( extremum[1], plus );
#if 0
			    bu_log("(%g,%g,%g)+-%g->(%g,%g,%g)(%g,%g,%g)->(%g,%g,%g)(%g,%g,%g)\n",
				sp->s_center[X], sp->s_center[Y], sp->s_center[Z],
				sp->s_size,
				minus[X], minus[Y], minus[Z],
				plus[X], plus[Y], plus[Z],
				extremum[0][X], extremum[0][Y], extremum[0][Z],
				extremum[1][X], extremum[1][Y], extremum[1][Z]);
#endif
		    }
		    VMOVEN(direction, Viewrot + 8, 3);
		    VSCALE(direction, direction, -1.0);
		    for (i = 0; i < 3; ++i)
			if (NEAR_ZERO(direction[i], 1e-10))
			    direction[i] = 0.0;
		    if ((center_model[X] >= extremum[0][X]) &&
			(center_model[X] <= extremum[1][X]) &&
			(center_model[Y] >= extremum[0][Y]) &&
			(center_model[Y] <= extremum[1][Y]) &&
			(center_model[Z] >= extremum[0][Z]) &&
			(center_model[Z] <= extremum[1][Z]))
		    {
			t_in = -INFINITY;
			for (i = 0; i < 6; ++i)
			{
			    if (direction[i%3] == 0)
				continue;
			    t = (extremum[i/3][i%3] - center_model[i%3]) /
				    direction[i%3];
			    if ((t < 0) && (t > t_in))
				t_in = t;
			}
			VJOIN1(center_model, center_model, t_in, direction);
		    }
d1504 16
a1519 16
		    VMOVEN(unit_H, model2view, 3);
		    VMOVEN(unit_V, model2view + 4, 3);
#if 1
		    VJOIN1(center_model,
			center_model, xorig * Viewscale / 2047.0, unit_H);
		    VJOIN1(center_model,
			center_model, yorig * Viewscale / 2047.0, unit_V);
#else
		    VJOIN1(center_model,
			center_model, curs_x * Viewscale / 2047.0, unit_H);
		    VJOIN1(center_model,
			center_model, curs_y * Viewscale / 2047.0, unit_V);
#endif
#endif
	}else
	  Tcl_AppendResult(interp, "Firing from view center...\n", (char *)NULL);
d1521 1
a1521 1
	rt_write(fp, center_model );
d1523 1
a1523 2
	(void)fclose( fp );
	while(fgets(line, MAXLINE, fp2) != (char *)NULL)
d1525 1
a1525 1
	(void)fclose( fp2 );
d1542 151
@


11.45
log
@*- mged_variables is now a pointer
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.44 1997/08/22 22:38:22 mike Exp bparker $ (BRL)";
d1135 1
d1139 5
d1145 1
d1167 3
d1173 51
d1231 1
d1236 6
d1253 28
a1280 7
	{
		VSET(center_model, -toViewcenter[MDX],
		    -toViewcenter[MDY], -toViewcenter[MDZ]);
		if (mged_variables->adcflag)
		{
		   Tcl_AppendResult(interp, "Firing through angle/distance cursor...\n",
				    (char *)NULL);
d1337 1
d1339 5
d1347 6
a1352 3
		}
		else
		  Tcl_AppendResult(interp, "Firing from view center...\n", (char *)NULL);
a1353 2
		rt_write(fp, center_model );
	}
d1355 3
@


11.44
log
@Made use of bu_getopt() explicit, rather than depending on
#define in bu.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.43 1997/07/01 22:09:08 bparker Exp mike $ (BRL)";
d372 2
a373 2
	if( mged_variables.perspective > 0 )  {
		(void)sprintf(pstring, "-p%g", mged_variables.perspective);
d612 2
a613 2
	if( mged_variables.perspective > 0 )
		(void)fprintf(fp, "-p%g", mged_variables.perspective);
d969 1
a969 1
	mged_variables = rtif_saved_state;	/* struct copy */
d1011 2
a1012 2
	rtif_saved_state = mged_variables;	/* struct copy */
	mged_variables.autosize = 0;
d1109 1
a1109 1
	mged_variables = rtif_saved_state;	/* struct copy */
d1188 1
a1188 1
		if (mged_variables.adcflag)
@


11.43
log
@mods to run without a database
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.42 1997/05/22 19:49:38 mike Exp bparker $ (BRL)";
d1020 2
a1021 2
	optind = 1;			/* re-init getopt() */
	while( (c=getopt(argc,argv,"d:vD:K:")) != EOF )  {
d1024 1
a1024 1
			rtif_delay = atof(optarg);
d1027 1
a1027 1
			rtif_desiredframe = atof(optarg);
d1030 1
a1030 1
			rtif_finalframe = atof(optarg);
d1052 2
a1053 2
	argc -= optind-1;
	argv += optind-1;
@


11.42
log
@Don't add trailing newlines to tcl returns.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.41 1997/04/24 18:03:58 bparker Exp mike $ (BRL)";
d352 3
d406 3
d455 3
d591 3
d685 3
d963 3
d994 3
d1144 3
d1474 3
d1522 3
@


11.41
log
@modify calls to Tcl_Eval
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.40 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
a1714 1
	Tcl_AppendResult(interp, "\n", (char *)NULL);
@


11.40
log
@mods so that commands check args internally
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.39 1997/02/14 08:52:06 mike Exp bparker $ (BRL)";
d353 6
a358 1
	  Tcl_Eval(interp, "help rt");
d404 6
a409 1
	  Tcl_Eval(interp, "help rrt");
d450 6
a455 1
	  Tcl_Eval(interp, "help rtcheck");
d583 6
a588 1
	  Tcl_Eval(interp, "help saveview");
d674 6
a679 1
	  Tcl_Eval(interp, "help rmats");
d840 6
a845 1
	  Tcl_Eval(interp, "help savekey");
d977 6
a982 1
	  Tcl_Eval(interp, "help preview");
d1124 6
a1129 1
	  Tcl_Eval(interp, "help nirt");
d1535 6
a1540 1
      Tcl_Eval(interp, "help solids_on_ray");
d1658 6
a1663 1
	  Tcl_Eval(interp, "help who");
@


11.39
log
@Macro cleanup.
Print eye_pt at better point in file.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.38 1997/02/06 22:04:41 bparker Exp mike $ (BRL)";
d352 2
a353 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d355 1
d398 2
a399 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d401 1
d439 2
a440 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d442 1
d567 2
a568 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d570 1
d653 2
a654 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d656 1
d814 2
a815 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d817 1
d946 2
a947 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d949 1
d1088 2
a1089 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1091 1
d1494 2
a1495 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1497 1
d1612 4
a1615 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
		return TCL_ERROR;
@


11.38
log
@mods to f_preview
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.37 1997/01/29 03:41:35 mike Exp bparker $ (BRL)";
a137 2
	(void)fprintf(fp, "eye_pt %.15e %.15e %.15e;\n",
		eye_model[X], eye_model[Y], eye_model[Z] );
d151 4
a154 1
#define DIR_USED	0x80
d1325 1
a1325 4
	MAT_DELTAS( toViewcenter,
		-rtif_eye_model[X],
		-rtif_eye_model[Y],
		-rtif_eye_model[Z] );
d1346 1
a1346 4
	MAT_DELTAS( toViewcenter,
		-new_cent[X],
		-new_cent[Y],
		-new_cent[Z] );
@


11.37
log
@Don't need db.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.36 1997/01/10 17:19:11 bparker Exp $ (BRL)";
d1039 2
@


11.36
log
@call mged_svbase to set view base (original Viewscale and position --- these
are used to do absolute slewing and scaling) and dmaflag
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.35 1997/01/02 19:33:14 bparker Exp bparker $ (BRL)";
a44 1
#include "db.h"
a634 1
	union record	rec;
a662 1
		db_get( dbip,  dp, &rec, 0 , 1);
@


11.35
log
@mods to use libbn and libbu
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.34 1996/10/04 15:06:23 bparker Exp bparker $ (BRL)";
d53 1
d785 1
a785 1
	dmaflag = 1;
d787 1
@


11.34
log
@cast bu_free's 1st argument to genptr_t
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.33 1996/10/03 20:41:05 bparker Exp bparker $ (BRL)";
d700 1
a700 1
		       	mat_copy( Viewrot, rot );
d717 1
a717 1
			mat_idn(Viewrot);	/* top view */
d898 1
a898 1
 *  WARNING:  If the ^C happened when bu_free() had already done a RES_ACQUIRE,
d1004 1
a1004 1
	mat_copy(rtif_viewrot, Viewrot);
d1257 1
a1257 1
	  mat_fromto( rtif_viewrot, dir, neg_Z_axis);
d1260 1
a1260 1
	mat_lookat( rtif_viewrot, dir, yflip );
d1322 1
a1322 1
       	mat_copy( Viewrot, rtif_viewrot );
@


11.33
log
@*** empty log message ***
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.32 1996/10/01 17:26:29 bparker Exp bparker $ (BRL)";
d1019 1
a1019 1
				bu_free( cmd, "preview ! cmd" );
d1026 1
a1026 1
		bu_free( cmd, "preview cmd" );
d1580 1
a1580 1
    bu_free((char *) snames, "solid names");
@


11.32
log
@ignore SIGINT
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.31 1996/09/30 19:49:28 bparker Exp bparker $ (BRL)";
d938 1
a938 1
		return CMD_BAD;
@


11.31
log
@cleanup
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.30 1996/09/25 20:16:42 bparker Exp bparker $ (BRL)";
d515 1
d787 1
d1041 1
@


11.30
log
@now using more generalized solid macros
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.29 1996/09/23 18:21:14 bparker Exp bparker $ (BRL)";
a312 4
#if 0
		/* This old way is no longer needed for RT */
		rt_oldwrite(fp, eye_model );
#endif
a347 1
	int	needs_reattach;
a356 12
#if 0
	/*
	 * This may be a workstation where RT and MGED have to share the
	 * display, so let display go.  We will try to reattach at the end.
	 */
	if( (needs_reattach = dmp->dmr_releasedisplay) != 0 ){
	  bu_vls_init(&cmd);
	  bu_vls_printf(&cmd, "attach %s %s\n", dmp->dmr_name, dname);
	  release(NULL);
	}
#endif

a371 13
#if 0
	if( needs_reattach && retcode == 0 )  {
		/* Wait for a return, then reattach display */
		bu_log("Press RETURN to reattach\007\n");
		while( getchar() != '\n' )
			/* NIL */  ;
	}
	if( needs_reattach ){
	  cmdline(&cmd, FALSE);
	  bu_vls_free(&cmd);
	}
#endif

a392 1
	int	needs_reattach;
a400 12
#if 0
	/*
	 * This may be a workstation where RT and MGED have to share the
	 * display, so let display go.  We will try to reattach at the end.
	 */
	if( needs_reattach = dmp->dmr_releasedisplay ){
	  bu_vls_init(&cmd);
	  bu_vls_printf(&cmd, "attach %s %s\n", dmp->dmr_name, dname);
	  release(NULL);
	}
#endif

a407 14

#if 0
/*XXX*/
	if( needs_reattach && retcode == 0 )  {
	  /* Wait for a return, then reattach display */
		bu_log("Press RETURN to reattach\007\n");
		while( getchar() != '\n' )
			/* NIL */  ;
	}
	if( needs_reattach ){
	  cmdline(&cmd, FALSE);
	  bu_vls_free(&cmd);
	}
#endif
@


11.29
log
@changed dm.h to mged_dm.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.28 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d49 1
a49 1
#include "./solid.h"
d155 1
a155 1
	FOR_ALL_SOLIDS(sp) {
d160 1
a160 1
	FOR_ALL_SOLIDS(sp) {
d173 1
a173 1
	FOR_ALL_SOLIDS(sp) {
d229 1
a229 1
	FOR_ALL_SOLIDS( sp )
d231 1
a231 1
	FOR_ALL_SOLIDS( sp )  {
d246 1
a246 1
		for( forw=sp->s_forw; forw != &HeadSolid; forw=forw->s_forw) {
d332 1
a332 1
	FOR_ALL_SOLIDS( sp )
d564 1
a564 1
	FOR_ALL_SOLIDS( sp )
d637 1
a637 1
	FOR_ALL_SOLIDS( sp )
d639 1
a639 1
	FOR_ALL_SOLIDS( sp )  {
d647 1
a647 1
		for( forw=sp->s_forw; forw != &HeadSolid; forw=forw->s_forw) {
d665 1
a665 1
	FOR_ALL_SOLIDS( sp )
d721 1
a721 1
		FOR_ALL_SOLIDS(sp)  {
d1173 1
a1173 1
		    FOR_ALL_SOLIDS (sp)
d1243 1
a1243 1
	FOR_ALL_SOLIDS( sp )
d1570 1
a1570 1
    FOR_ALL_SOLIDS (sp)
d1681 18
a1698 18
	FOR_ALL_SOLIDS( sp )
		sp->s_iflag = DOWN;
	FOR_ALL_SOLIDS( sp )  {
		register struct solid *forw;	/* XXX */

		if( sp->s_iflag == UP )
			continue;
		if (sp->s_path[0]->d_addr == RT_DIR_PHONY_ADDR){
			if (skip_phony) continue;
		} else {
			if (skip_real) continue;
		}
		Tcl_AppendResult(interp, sp->s_path[0]->d_namep, " ", (char *)NULL);
		sp->s_iflag = UP;
		for( forw=sp->s_forw; forw != &HeadSolid; forw=forw->s_forw) {
			if( forw->s_path[0] == sp->s_path[0] )
				forw->s_iflag = UP;
		}
d1700 1
a1700 1
	FOR_ALL_SOLIDS( sp )
@


11.28
log
@rt_list ---> bu_list
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.27 1996/08/28 22:24:53 cnuzman Exp bparker $ (BRL)";
d50 1
a50 1
#include "./dm.h"
@


11.27
log
@extraneous (I think) f_zap caused bug with preview -K option
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.26 1996/08/27 20:30:05 bparker Exp cnuzman $ (BRL)";
d41 1
d723 2
a724 2
			if( RT_LIST_IS_EMPTY( &(sp->s_vlist) ) )  continue;
			vp = RT_LIST_LAST( rt_vlist, &(sp->s_vlist) );
d785 2
a786 2
	    		if( RT_LIST_IS_EMPTY( &(sp->s_vlist) ) )  break;
			vp = RT_LIST_LAST( rt_vlist, &(sp->s_vlist) );
d788 1
a788 1
			for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d815 2
a816 2
		if( RT_LIST_NON_EMPTY( &(sp->s_vlist) ) )  {
			vp = RT_LIST_LAST( rt_vlist, &(sp->s_vlist) );
d818 1
a818 1
			for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d1362 1
a1362 1
	struct rt_list		*vhead = &rtif_vbp->head[0];
d1369 1
a1369 1
	if( RT_LIST_IS_EMPTY( vhead ) )  {
@


11.26
log
@now using libbu
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.25 1996/08/21 14:14:43 jra Exp bparker $ (BRL)";
d1496 1
a1496 1
	f_zap( (ClientData)NULL, interp, 0, (char **)0 );
@


11.25
log
@minor mods for IRIX 6.2.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.24 1996/07/31 00:19:20 cnuzman Exp jra $ (BRL)";
d71 1
a71 1
  struct rt_vls tmp_vls;
d78 2
a79 2
  rt_vls_init(&tmp_vls);
  rt_vls_printf(&tmp_vls, "Abnormal exit x%x", status);
d82 1
a82 1
    rt_vls_printf(&tmp_vls, ", core dumped");
d85 1
a85 1
    rt_vls_printf(&tmp_vls, ", terminating signal = %d", sig );
d87 1
a87 1
    rt_vls_printf(&tmp_vls, ", return (exit) code = %d", ret );
d89 2
a90 2
  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), "\n", (char *)NULL);
  rt_vls_free(&tmp_vls);
d353 1
a353 1
	struct rt_vls cmd;
d367 2
a368 2
	  rt_vls_init(&cmd);
	  rt_vls_printf(&cmd, "attach %s %s\n", dmp->dmr_name, dname);
d391 1
a391 1
		rt_log("Press RETURN to reattach\007\n");
d397 1
a397 1
	  rt_vls_free(&cmd);
d423 1
a423 1
	struct rt_vls cmd;
d437 2
a438 2
	  rt_vls_init(&cmd);
	  rt_vls_printf(&cmd, "attach %s %s\n", dmp->dmr_name, dname);
d455 1
a455 1
		rt_log("Press RETURN to reattach\007\n");
d461 1
a461 1
	  rt_vls_free(&cmd);
d952 2
a953 2
 *  WARNING:  If the ^C happened when rt_free() had already done a RES_ACQUIRE,
 *  then any further calls to rt_free() will hang.
d1021 1
a1021 1
		    struct rt_vls tmp_vls;
d1023 8
a1030 8
		    rt_vls_init(&tmp_vls);
		    rt_vls_printf(&tmp_vls, "option '%c' unknown\n", c);
		    rt_vls_printf(&tmp_vls, "        -d#     inter-frame delay\n");
		    rt_vls_printf(&tmp_vls, "        -v      polygon rendering (visual)\n");
		    rt_vls_printf(&tmp_vls, "        -D#     desired starting frame\n");
		    rt_vls_printf(&tmp_vls, "        -K#     final frame\n");
		    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		    rt_vls_free(&tmp_vls);
d1073 1
a1073 1
				rt_free( cmd, "preview ! cmd" );
d1080 1
a1080 1
		rt_free( cmd, "preview cmd" );
d1183 1
a1183 1
			    rt_log("(%g,%g,%g)+-%g->(%g,%g,%g)(%g,%g,%g)->(%g,%g,%g)(%g,%g,%g)\n",
d1528 1
a1528 1
    struct rt_vls		vls;
d1615 1
a1615 1
    rt_vls_init(&vls);
d1623 2
a1624 2
	Tcl_AppendResult(interp, rt_vls_addr(&vls), (char *)NULL);
	rt_vls_free(&vls);
d1628 1
a1628 1
    rt_vls_free(&vls);
d1633 1
a1633 1
    rt_free((char *) snames, "solid names");
@


11.24
log
@added cmd_who
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.23 1996/07/15 20:36:08 bparker Exp cnuzman $ (BRL)";
a1672 1
			break;
@


11.23
log
@hack to appease sun4's complaining about aggregate initialization
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.22 1996/06/21 16:08:21 bparker Exp bparker $ (BRL)";
d633 1
a633 1
	/* Find all unique top-level entrys.
d1636 69
@


11.22
log
@*** empty log message ***
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.21 1996/06/06 13:59:02 bparker Exp bparker $ (BRL)";
d1307 3
a1309 1
	  vect_t neg_Z_axis = { 0.0, 0.0, -1.0 };
d1408 4
a1411 1
	  char *av[] = {"Z", NULL};
@


11.21
log
@applied workaround for mat_lookat as suggested by Lee.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.20 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d1159 1
a1159 1
		if (adcflag)
@


11.20
log
@Still Tcl'ing the code
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.19 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d1300 11
d1312 2
@


11.19
log
@still tcl-converting
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.18 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d326 2
d329 1
d553 2
d556 6
d740 1
d743 6
d970 1
a970 1
	sig2();			/* Call main SIGINT handler */
d1062 5
a1066 2
	/* If user hits ^C, preview will stop, and clean up */
	(void)signal(SIGINT, rtif_sigint);
d1237 2
d1240 1
@


11.18
log
@convert commands to Tcl
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.17 1996/03/22 18:33:05 bparker Exp bparker $ (BRL)";
d1369 3
a1371 1
	  (void)f_zap( (ClientData)NULL, interp, 0, 0 );
@


11.17
log
@cleanup
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.16 1996/03/08 18:32:51 bparker Exp bparker $ (BRL)";
d68 23
a90 16
	int	sig = status & 0x7f;
	int	core = status & 0x80;
	int	ret = status >> 8;

	if( status == 0 )  {
		rt_log("Normal exit\n");
		return;
	}
	rt_log("Abnormal exit x%x", status);
	if( core )
		rt_log(", core dumped");
	if( sig )
		rt_log(", terminating signal = %d", sig );
	else
		rt_log(", return (exit) code = %d", ret );
	rt_log("\n");
d240 3
a242 3
			rt_log("mged: ran out of comand vector space  at %s\n",
				sp->s_path[0]->d_namep );
			break;
d267 2
a268 2
	rt_cmd_vec_len = vp - rt_cmd_vec;
	rt_cmd_vec_len += build_tops(vp, &rt_cmd_vec[MAXARGS]);
d270 4
a273 5
	/* Print out the command we are about to run */
	vp = &rt_cmd_vec[0];
	while( *vp )
		rt_log("%s ", *vp++ );
	rt_log("\n");
d275 1
d338 3
a340 1
f_rt( argc, argv )
d350 1
d352 3
d356 1
a356 1
		return CMD_BAD;
d358 1
d363 3
a365 2
	dm = dmp->dmr_name;
	if( (needs_reattach = dmp->dmr_releasedisplay) != 0 )
d367 2
d384 2
d392 5
a396 2
	if( needs_reattach )
		attach( dm );
d398 1
a398 1
	return CMD_OK;
d409 3
a411 1
f_rrt( argc, argv )
d420 1
d422 3
d426 1
a426 1
		return CMD_BAD;
d428 1
d433 3
a435 2
	dm = dmp->dmr_name;
	if( needs_reattach = dmp->dmr_releasedisplay )
d437 2
d447 3
d451 1
a451 1
		/* Wait for a return, then reattach display */
d456 5
a460 2
	if( needs_reattach )
		attach( dm );
d462 1
a462 1
	return CMD_OK;
d471 3
a473 1
f_rtcheck( argc, argv )
d487 3
d491 1
a491 1
		return CMD_BAD;
d560 1
a560 1
	return CMD_OK;
d593 3
a595 1
f_saveview( argc, argv )
d604 3
d608 2
a609 2
		perror(argv[1]);
		return CMD_BAD;
d611 1
d656 1
a656 1
	return CMD_OK;
d670 3
a672 1
f_rmats( argc, argv )
d689 3
d693 1
a693 1
		return CMD_BAD;
d696 2
a697 2
		perror(argv[1]);
		return CMD_BAD;
d715 1
a715 1
			rt_log("animating EYE solid\n");
d721 3
a723 3
		mode = -1;
		rt_log("default mode:  eyepoint at (0,0,1) viewspace\n");
		break;
d725 2
a726 2
		rt_log("rotation supressed, center is eyepoint\n");
		break;
d824 1
a824 1
	return CMD_OK;
d829 3
a831 1
f_savekey( argc, argv )
d840 3
d844 2
a845 2
		perror(argv[1]);
		return CMD_BAD;
d848 2
a849 2
		time = atof( argv[2] );
		(void)fprintf(fp,"%f\n", time);
d859 1
a859 1
	return CMD_OK;
d960 3
a962 1
f_preview( argc, argv )
d970 3
d1002 14
a1015 6
			rt_log("option '%c' unknown\n", c);
			rt_log("	-d#	inter-frame delay\n");
			rt_log("	-v	polygon rendering (visual)\n");
			rt_log("	-D#	desired starting frame\n");
			rt_log("	-K#	final frame\n");
			break;
d1024 2
a1025 2
		perror(argv[1]);
		return CMD_BAD;
d1034 1
a1034 1
	rt_log("eyepoint at (0,0,1) viewspace\n");
d1057 2
a1058 1
			rt_log("command failed: %s\n", cmd);
d1074 1
a1074 1
	return CMD_OK;
d1083 3
a1085 1
f_nirt( argc, argv )
d1104 3
d1108 1
a1108 1
		return CMD_BAD;
d1140 2
a1141 1
		    rt_log("Firing through angle/distance cursor...\n");
d1204 1
a1204 1
		    rt_log("Firing from view center...\n");
d1221 1
a1221 1
	return CMD_OK;
d1369 2
a1370 2
		(void)f_zap( 0, 0 );
		edit_com( rt_cmd_vec_len, rt_cmd_vec, rtif_mode, 0 );
d1407 4
a1410 4
	if( db_parse_anim( dbip, argc, argv ) < 0 )  {
		rt_log("cm_anim:  %s %s failed\n", argv[1], argv[2]);
		return(-1);		/* BAD */
	}
d1412 1
a1412 1
	tree_walk_needed = 1;
d1414 1
a1414 1
	return(0);
d1452 1
a1452 1
	f_zap( 0, (char **)0 );
d1470 2
a1471 2
int cmd_solids_on_ray (clientData, interp, argc, argv)

a1475 1

d1491 3
d1496 1
a1496 1
	Tcl_SetResult(interp, "Usage: 'solids_on_ray [h v]'", TCL_STATIC);
d1578 1
a1578 1
	Tcl_SetResult(interp, "Error executing skewer_solids: ", TCL_STATIC);
@


11.16
log
@*** empty log message ***
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.15 1996/03/01 19:28:39 bparker Exp bparker $ (BRL)";
a350 1
#ifdef MULTI_ATTACH
a351 3
#else
		release();		/* changes dmp */
#endif
a405 1
#ifdef MULTI_ATTACH
a406 3
#else
		release();		/* changes dmp */
#endif
a862 1
#ifdef MULTI_ATTACH
a863 3
#else
static struct mged_variables	rtif_saved_state;	/* saved state variables */
#endif
@


11.15
log
@remove unused XMGED stuff
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.14 1995/12/27 22:31:29 bparker Exp bparker $ (BRL)";
d351 3
d355 1
d410 3
d414 1
@


11.14
log
@*** empty log message ***
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.13 1995/08/02 21:33:54 gdurf Exp bparker $ (BRL)";
a51 4
#ifdef XMGED
extern  int     mged_wait();
#endif

a282 4
#ifdef XMGED
	alarm((unsigned)0);     /* shut off alarm */
#endif

a313 4
#ifdef XMGED
	while ((rpid = mged_wait(&retcode, pid)) != pid && rpid != -1)
                ;       /* NULL */
#else
a315 1
#endif
a369 3
#ifdef XMGED
		while( mged_fgetc(stdin) != '\n' )
#else
a370 1
#endif
a417 3
#ifdef XMGED
		while( mged_fgetc(stdin) != '\n' )
#else
a418 1
#endif
a449 4
#ifdef XMGED
/*XXX*/ alarm((unsigned)0);     /* shut off alarm */
#endif

a501 4
#ifdef XMGED
	while ((rpid = mged_wait(&retcode, pid)) != pid && rpid != -1)
                ;       /* NULL */
#else
d504 1
a504 1
#endif
a1035 4
#ifdef XMGED
	alarm((unsigned)0);     /* shut off alarm */
#endif

a1135 4
#ifdef XMGED
	while ((rpid = mged_wait(&retcode, pid)) != pid && rpid != -1)
		;	/* NULL */
#else
d1138 1
a1138 1
#endif
@


11.13
log
@Added include of mgedtcl.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.12 1995/07/25 17:53:49 gdurf Exp gdurf $ (BRL)";
d892 3
d896 1
@


11.12
log
@Wrapped skewer_solids error messages
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.11 1995/07/20 14:14:48 pjt Exp gdurf $ (BRL)";
d39 1
a39 1
#include "tk.h"
d42 2
a46 2
#include "raytrace.h"
#include "externs.h"
d50 1
@


11.11
log
@Added an argument in call of skewer_solids() to conform to
new prototype
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.10 1995/07/20 14:04:40 gdurf Exp pjt $ (BRL)";
d1533 2
a1534 1
	Tcl_SetResult(interp, rt_vls_addr(&vls), TCL_VOLATILE);
@


11.10
log
@Added rt_log wrappers
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.9 1995/07/12 16:53:34 pjt Exp gdurf $ (BRL)";
d1528 1
a1528 1
    snames = skewer_solids(rt_cmd_vec_len, rt_cmd_vec, ray_orig, ray_dir);
@


11.9
log
@First version of cmd_solids_on_ray now works...
Yet to handle multiply referenced solids, though
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.8 1995/07/11 19:14:14 pjt Exp pjt $ (BRL)";
a1524 3
    if ((snames = skewer_solids(rt_cmd_vec_len, rt_cmd_vec, ray_orig, ray_dir))
	== 0)
	return (TCL_OK);
a1525 5
    for (i = 0; snames[i] != 0; ++i)
	Tcl_AppendResult(interp, snames[i], " ", NULL);
    rt_free((char *) snames, "solid names");

#if 0
d1527 3
a1529 3
    rt_vls_printf(&vls, "%g %g %g", ray_orig[X], ray_orig[Y], ray_orig[Z]);
    Tcl_SetResult(interp, rt_vls_addr(&vls), TCL_VOLATILE);
    rt_vls_free(&vls);
d1531 6
a1536 2
    return (TCL_OK);
#endif
a1537 8
#if 0
    if (Tcl_GetDouble(interp, argv[1], &viewX) != TCL_OK) return TCL_ERROR;

    /* Do stuff. */

    Tcl_SetResult(interp, "foo", TCL_STATIC);

    Tcl_SetResult(interp, rt_vls_addr(&vls), TCL_VOLATILE);
d1540 4
a1543 3

    Tcl_AppendElement(interp, "This { is really \\ fu\"nk}y.");
#endif
@


11.8
log
@1. Changed extern declaration of skewer_solids()
2. cmd_solids_on_ray() now conses up results of skewer_solids()
   using Tcl_AppendResult().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.7 1995/07/10 20:09:55 pjt Exp pjt $ (BRL)";
d1529 2
a1530 5
    while (*snames != 0)
    {
	rt_log("Appending '%s '\n", *snames);
	Tcl_AppendResult(interp, *(snames++), " ", NULL);
    }
@


11.7
log
@Moved all of cmd_solids_on_ray()'s support routines to
solids_on_ray.c
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.6 1995/07/07 20:17:47 pjt Exp pjt $ (BRL)";
d1425 1
a1425 1
extern struct rt_list *skewer_solids ();
d1435 1
d1525 10
a1534 1
    skewer_solids(rt_cmd_vec_len, rt_cmd_vec, ray_orig, ray_dir);
@


11.6
log
@Began implementing cmd_solids_on_ray()
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.5 1995/06/13 16:15:49 pjt Exp $ (BRL)";
d1425 1
a1425 98
/*
 *			    N O _ O P
 *
 *	    Null event handler for use by rt_shootray().
 *
 *	Does nothing.  Returns 1.
 */
static int no_op (ap, ph)

struct application	*ap;
struct partition	*ph;

{
    return (1);
}

/*
 *			R P T _ S O L I D S
 *
 *		Hit handler for use by rt_shootray().
 *
 *	Grabs the first partition it sees, extracting thence
 *	the segment list.  Rpt_solids() sorts the solids along
 *	the ray by first encounter.  As a side-effect, rpt_solids()
 *	fills the rt_list structure pointed to by ap.a_uptr with
 *	the names of the solids.  It returns 1.
 */

static int rpt_solids (ap, ph)

struct application	*ap;
struct partition	*ph;

{
    rt_log("I hit it!\n");
    return (1);
}

/*
 *		S K E W E R _ S O L I D S
 *
 *	Fire a ray at some geometry and return a list of
 *	the solids encountered, sorted by first intersection.
 *
 *	N.B. - It is the caller's responsibility to free the list.
 */
struct rt_list *skewer_solids (argc, argv, ray_orig, ray_dir)

int		argc;
CONST char	**argv;
point_t		ray_orig;
vect_t		ray_dir;

{
    struct application	ap;
    struct rt_i		*rtip;
    struct rt_list	*sol_list;
	
    if ((rtip = rt_dirbuild(dbip -> dbi_filename, (char *) 0, 0)) == RTI_NULL)
    {
	rt_log("Cannot build directory for file '%s'\n",
	    dbip -> dbi_filename);
	return ((struct rt_list *) 0);
    }
    rtip -> useair = 1;
    /*
     *	XXX	I've hardwired in here to use a single CPU.
     *		Should that be rt_avail_cpus()?
     */
    if (rt_gettrees(rtip, argc, argv, 1) == -1)
	return ((struct rt_list *) 0);
    rt_prep(rtip);

    /*
     *	Allocate and initialize the solid list
     */
    sol_list = (struct rt_list *)
		    rt_malloc(sizeof(struct rt_list), "solid list");
    RT_LIST_INIT(sol_list);

    /*
     *	Initialize the application
     */
    ap.a_hit = rpt_solids;
    ap.a_miss = no_op;
    ap.a_resource = RESOURCE_NULL;
    ap.a_overlap = no_op;
    ap.a_onehit = 0;
    ap.a_uptr = (genptr_t) sol_list;
    ap.a_rt_i = rtip;
    ap.a_zero1 = ap.a_zero2 = 0;
    ap.a_purpose = "skewer_solids()";
    VMOVE(ap.a_ray.r_pt, ray_orig);
    VMOVE(ap.a_ray.r_dir, ray_dir);

    (void) rt_shootray(&ap);
    return (sol_list);
}
@


11.5
log
@Swapped "$*" and "-o %s.pix" in output of f_saveview
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.4 95/03/10 20:47:06 mike Exp $ (BRL)";
d38 2
d1423 224
@


11.4
log
@Moved MAXARGS to ged.h, standardized on it's use, increased to 9000.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.3 95/01/17 13:05:01 bparker Exp Locker: mike $ (BRL)";
d596 1
a596 1
	(void)fprintf(fp,"\\\n $*\\\n -o %s.pix\\\n", base);
@


11.3
log
@merging xmged sources
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/rtif.c,v 11.2 95/01/17 11:44:21 bparker Exp $ (BRL)";
d253 1
a253 2
#define LEN	2000
static char	*rt_cmd_vec[LEN];
d255 1
a255 1
static char	rt_cmd_storage[LEN*9];
d262 1
a262 1
	rt_cmd_vec_len += build_tops(vp, &rt_cmd_vec[LEN]);
d1385 1
a1385 1
	for( i = 1;  i < argc && i < LEN; i++ )  {
@


11.2
log
@Assuaged warning-causing if statement
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 11.1 95/01/04 10:03:31 mike Rel4_4 Locker: gdurf $ (BRL)";
d49 4
d285 4
d320 4
d326 2
d381 3
d385 1
d433 3
d437 1
d469 4
d525 4
d531 1
d1059 4
d1163 4
d1169 1
@


11.1
log
@Release_4.4
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.30 94/12/23 23:02:09 gdurf Exp $ (BRL)";
d215 1
a215 1
	 * Find all unique top-level entrys.
d347 1
a347 1
	if( needs_reattach = dmp->dmr_releasedisplay )
@


10.30
log
@Removed superfluous fflush(stdout)
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.29 94/12/23 23:01:31 mike Exp Locker: gdurf $ (BRL)";
@


10.29
log
@Per vertex normals.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.28 94/12/16 20:33:48 gdurf Exp Locker: mike $ (BRL)";
d1122 1
a1122 1
		fflush(stdout);
@


10.28
log
@Converted putchar to rt_log
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.27 1994/12/16 19:37:17 gdurf Exp gdurf $ (BRL)";
d719 1
d749 1
@


10.27
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.26 1994/11/05 03:52:12 mike Exp gdurf $ (BRL)";
d80 1
a80 1
	(void)putchar('\n');
@


10.26
log
@Irix 6
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.25 94/10/18 00:10:56 mike Exp Locker: mike $ (BRL)";
d70 1
a70 1
		(void)printf("Normal exit\n");
d73 1
a73 1
	(void)printf("Abnormal exit x%x", status);
d75 1
a75 1
		(void)printf(", core dumped");
d77 1
a77 1
		(void)printf(", terminating signal = %d", sig );
d79 1
a79 1
		(void)printf(", return (exit) code = %d", ret );
d264 2
a265 2
		(void)printf("%s ", *vp++ );
	(void)printf("\n");
d366 1
a366 1
		printf("Press RETURN to reattach\007\n");
d414 1
a414 1
		printf("Press RETURN to reattach\007\n");
d657 1
a657 1
			printf("animating EYE solid\n");
d664 1
a664 1
		printf("default mode:  eyepoint at (0,0,1) viewspace\n");
d667 1
a667 1
		printf("rotation supressed, center is eyepoint\n");
d932 5
a936 5
			printf("option '%c' unknown\n", c);
			printf("	-d#	inter-frame delay\n");
			printf("	-v	polygon rendering (visual)\n");
			printf("	-D#	desired starting frame\n");
			printf("	-K#	final frame\n");
d956 1
a956 1
	printf("eyepoint at (0,0,1) viewspace\n");
d1056 1
a1056 1
		    (void) printf("Firing through angle/distance cursor...\n");
d1077 1
a1077 1
			    printf("(%g,%g,%g)+-%g->(%g,%g,%g)(%g,%g,%g)->(%g,%g,%g)(%g,%g,%g)\n",
d1119 1
a1119 1
		    (void) printf("Firing from view center...\n");
@


10.25
log
@Calmed the Solaris compiler.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.24 94/08/25 17:53:04 gdurf Exp Locker: mike $ (BRL)";
d213 1
a213 1
	register int i;
a257 3
	register struct solid *sp;
	register int i;

a772 1
	register int i;
a1162 2
	vect_t	x, y;

a1235 1
	int	move;
@


10.24
log
@Fixed typo.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.23 1994/08/24 19:09:25 gdurf Exp gdurf $ (BRL)";
d878 2
a879 1
rtif_sigint()
@


10.23
log
@Fixed typo
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.22 1994/08/24 18:41:26 gdurf Exp $ (BRL)";
d1303 1
a1303 1
		tv.tv_usec = (long)((rtif_delay - sec) * 1000000);
@


10.22
log
@Exterminated bsdselect
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.21 1994/08/24 18:38:46 gdurf Exp gdurf $ (BRL)";
d1304 1
a1304 1
		select( 1, &readfds, (fd_set *)0, (fd_set *)0, &tv );
@


10.21
log
@Changes by mike
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.20 94/08/02 18:08:34 mike Exp Locker: mike $ (BRL)";
d31 2
d36 2
d1297 8
a1304 3
		int	sec = (int)rtif_delay;
		int	us = (int)((rtif_delay - sec) * 1000000);
		(void)bsdselect( 1<<fileno(stdin), sec, us );
@


10.20
log
@Added support for -D and -K options to "preview" command.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.19 94/08/02 14:31:30 mike Exp Locker: mike $ (BRL)";
d970 6
a975 4
		if( rtif_currentframe < rtif_desiredframe &&
		    cmd[0] == '!' )  {
			rt_free( cmd, "preview cmd" );
		    	continue;
@


10.19
log
@Fix to allow preview scripts to work.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.18 94/06/03 17:33:14 gdurf Exp Locker: mike $ (BRL)";
d859 3
d911 2
d916 1
a916 1
	while( (c=getopt(argc,argv,"d:v")) != EOF )  {
d921 6
d932 4
d969 6
d1141 1
a1141 1
	/* Has frame number */
d1237 4
@


10.18
log
@typo correction
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.17 1994/06/01 17:07:45 gdurf Exp gdurf $ (BRL)";
d257 2
a258 1
	rt_cmd_vec_len = build_tops(vp, &rt_cmd_vec[LEN]);
d1121 1
d1258 1
@


10.17
log
@Converted f_ functions to use new command return codes.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.16 1994/04/06 00:09:40 cjohnson Exp gdurf $ (BRL)";
d1333 1
a1333 1
	f_zap( 0, (char *)0 );
@


10.16
log
@savekey should not mention phony solids like _OVERLAY_
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.15 1994/04/05 19:10:05 cjohnson Exp cjohnson $ (BRL)";
d325 1
a325 1
void
d338 1
a338 1
		return;
d370 2
d381 1
a381 1
void
d393 1
a393 1
		return;
d418 2
d427 1
a427 1
void
d443 1
a443 1
		return;
d510 2
d543 1
a543 1
void
d555 1
a555 1
		return;
d600 2
d614 1
a614 1
void
d633 1
a633 1
		return;
d637 1
a637 1
		return;
d761 2
d766 1
a766 1
void
d779 1
a779 1
		return;
d792 2
d889 1
a889 1
void
d899 1
a899 1
		return;
d930 1
a930 1
		return;
d969 2
d978 1
a978 1
void
d999 1
a999 1
		return;
d1109 2
@


10.15
log
@rt_write now writes out the animation structures.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.14 1994/03/30 19:35:47 cjohnson Exp cjohnson $ (BRL)";
d571 1
@


10.14
log
@Split setup_rt into two parts, setup_rt which calls build_tops
and prints rt_cmd_vec, and build_tops that finds "tops" of the
solid structure and adds them to ANY cmd vector.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.13 1994/03/18 01:36:12 mike Exp cjohnson $ (BRL)";
d120 1
d138 27
a164 1
	(void)fprintf(fp, "start 0;\nend;\n");
@


10.13
log
@rt_uplot_to_vlist() is the new name, in librt/vlist.c
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.12 93/09/25 11:57:52 mike Exp Locker: mike $ (BRL)";
d171 1
a171 2
/*
 *			S E T U P _ R T
d173 1
a173 2
 *  Set up command line for one of the RT family of programs,
 *  with all objects in view enumerated.
d175 4
a178 8
#define LEN	2000
static char	*rt_cmd_vec[LEN];
static int	rt_cmd_vec_len;
static char	rt_cmd_storage[LEN*9];

void
setup_rt( vp )
register char	**vp;
d180 1
a182 1

d196 1
a196 1
		if( vp < &rt_cmd_vec[LEN] )
d199 1
a199 1
			(void)printf("mged: ran out of rt_cmd_vec at %s\n",
d209 22
a230 2
	*vp = (char *)0;
	rt_cmd_vec_len = vp - rt_cmd_vec;
@


10.12
log
@Added a void to function
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.11 93/03/24 05:29:27 phil Exp Locker: mike $ (BRL)";
d448 1
a448 1
	(void)uplot_vlist( vbp, fp );
@


10.11
log
@Initialized "preview" view to current one in MGED.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.10 1993/03/24 04:04:43 phil Exp phil $ (BRL)";
d57 1
@


10.10
log
@Created a storage area for saving rt_cmd_vec strings since
they might be volatile (from parsing command lines).
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.9 1992/11/23 20:53:56 mike Exp phil $ (BRL)";
d841 1
d885 8
@


10.9
log
@Won't try to RT phony solids any more.
added preview -v flag, to "ev" on animation.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.8 92/11/23 19:37:37 mike Exp Locker: mike $ (BRL)";
d179 1
d1241 1
d1244 3
a1246 1
		rt_cmd_vec[i] = argv[i];
@


10.8
log
@Still wrestling with SIGINT handling in preview command.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.7 92/11/23 18:53:43 mike Exp Locker: mike $ (BRL)";
d198 2
d801 1
d804 2
d849 1
d853 1
a853 1
	while( (c=getopt(argc,argv,"d:")) != EOF )  {
d858 3
d1187 1
a1187 1
		edit_com( rt_cmd_vec_len, rt_cmd_vec, 1, 0 );
@


10.7
log
@Made preview command dispose of animations, so that
subsequent "e" commands are normal.
Added sigint handling, to prevent leaving open files, etc.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.6 92/11/23 18:14:45 mike Exp Locker: mike $ (BRL)";
d798 1
d803 4
d811 1
a811 2
	if(rtif_fp)  fclose(rtif_fp);
	rtif_fp = NULL;
d813 7
a819 3
	/* Draw what path was accomplished */
	cvt_vlblock_to_solids( rtif_vbp, "EYE_PATH", 0 );
	rt_vlblock_free(rtif_vbp);
d839 4
d860 2
d887 4
a890 1
	rt_vlblock_free(rtif_vbp);
d892 3
d1178 1
a1178 1
		f_edit( rt_cmd_vec_len, rt_cmd_vec );
@


10.6
log
@Got scale right.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.5 92/09/03 19:54:21 mike Exp Locker: mike $ (BRL)";
d796 2
d799 21
d825 2
a826 2
	register FILE	*fp;
	char		*cmd;
d831 18
a848 1
	if( (fp = fopen(argv[1], "r")) == NULL )  {
d857 2
d861 2
a862 2
	/* If user hits ^C, this will stop, but will leave hanging filedes */
	(void)signal(SIGINT, cur_sigint);
d864 1
a864 3
	rtif_vbp = rt_vlblock_init();

	while( ( cmd = rt_read_cmd( fp )) != NULL )  {
d869 2
a870 1
	fclose(fp);
d874 1
d1164 5
@


10.5
log
@Added support for ANIM, TREE, and CLEAN commands from an RT animation
script, so that it can be properly previewed.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.4 92/09/03 19:19:06 mike Exp Locker: mike $ (BRL)";
d989 1
a989 1
	Viewscale = atof(argv[1]);
d1186 4
@


10.4
log
@Added "orientation" command to "preview" scripts.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.3 92/06/05 21:12:09 mike Exp Locker: mike $ (BRL)";
d47 2
d178 1
d212 1
d812 5
d1060 4
d1114 5
d1131 7
d1147 3
d1152 7
d1163 11
a1173 1
	return(-1);
d1175 6
d1185 3
a1187 1
	return(-1);
d1189 1
@


10.3
log
@Added new arg to cvt_vlblock_to_solids
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.2 92/04/18 01:04:01 mike Exp Locker: mike $ (BRL)";
d745 1
d756 2
d1035 13
@


10.2
log
@Now informs RT of perspective.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 10.1 91/10/12 06:44:15 mike Rel4_0 Locker: mike $ (BRL)";
d454 1
a454 1
	cvt_vlblock_to_solids( vbp, "OVERLAPS" );
d819 1
a819 1
	cvt_vlblock_to_solids( rtif_vbp, "EYE_PATH" );
@


10.1
log
@Release_4.0
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 9.11 91/07/02 08:38:35 pjt Exp $ (BRL)";
d286 1
d303 4
d505 2
@


9.11
log
@Removed diagnostic printf()'s from f_nirt()
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 9.10 91/06/25 16:05:11 pjt Exp $ (BRL)";
@


9.10
log
@Added f_nirt
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/pjt2/RCS/rtif.c,v 9.9 91/03/01 16:14:31 mike Exp $ (BRL)";
a871 2
		printf("OK, at first center=(%g, %g, %g)\n",
		    center_model[X], center_model[Y], center_model[Z]);
a927 2
		    printf("OK, after backing up center=(%g, %g, %g)\n",
			center_model[X], center_model[Y], center_model[Z]);
a934 2
		    printf("OK, after shifting for ADC center=(%g, %g, %g)\n",
			center_model[X], center_model[Y], center_model[Z]);
@


9.9
log
@Changed from sending "viewrot" command with 4x4 matrix, to
"orientation" command, with a 4-tuple quaturnion.
@
text
@d13 1
d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 9.8 91/02/02 00:01:52 mike Exp $ (BRL)";
d814 144
@


9.8
log
@Converted to new rt_vlist structure
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 9.7 90/12/07 01:01:16 mike Exp $ (BRL)";
d114 2
a115 1
	register int i;
d117 2
a118 2
	(void)fprintf(fp, "viewsize %.9e;\n", VIEWSIZE );
	(void)fprintf(fp, "eye_pt %.9e %.9e %.9e;\n",
d120 1
d123 1
a123 1
		(void)fprintf( fp, "%.9e ", Viewrot[i] );
d128 5
@


9.7
log
@lint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 9.6 90/11/11 04:51:32 mike Exp $ (BRL)";
d374 1
a374 1
	struct vlblock	*vbp;
d557 1
a557 1
	register struct vlist *vp;
d578 3
a580 2
			if( sp->s_vlist == VL_NULL )  continue;
			VMOVE( sav_start, sp->s_vlist->vl_pnt );
d633 21
a653 4
	    		if( sp->s_vlist == VL_NULL )  break;
	    		VSUB2( xlate, eye_model, sp->s_vlist->vl_pnt );
			for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
				VADD2( vp->vl_pnt, vp->vl_pnt, xlate );
d662 21
a682 4
		if( sp->s_vlist != VL_NULL )  {
	    		VSUB2( xlate, sav_start, sp->s_vlist->vl_pnt );
			for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
				VADD2( vp->vl_pnt, vp->vl_pnt, xlate );
d773 1
a773 1
static struct vlblock *rtif_vbp;
d891 1
a891 1
	struct vlhead	*vhead = &rtif_vbp->cvp[0].head;
d894 5
a898 2
	move = vhead->vh_first != VL_NULL;
	ADD_VL( vhead, rtif_eye_model, move );
d916 4
a919 4
	ADD_VL( vhead, xm, 1 );
	ADD_VL( vhead, rtif_eye_model, 0 );
	ADD_VL( vhead, ym, 1 );
	ADD_VL( vhead, rtif_eye_model, 0 );
@


9.6
log
@A beginning of ANIM command support
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 9.5 90/11/04 06:35:50 mike Exp $ (BRL)";
d548 1
a548 1
	register struct solid *sp;
@


9.5
log
@EYE_PATH was wrong.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 9.4 90/05/24 04:17:43 mike Exp $ (BRL)";
d907 1
a908 1
int	argc;
d910 6
a915 1
	return(-1);
@


9.4
log
@Modified for new vlist stuff
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/rtif.c,v 9.3 89/12/29 12:44:32 mike Exp $ (BRL)";
d769 1
a769 1
	cvt_vlblock_to_solids( "EYE_PATH", rtif_vbp );
@


9.3
log
@Converted to argc/argv
neatened saveview script slightly
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: rtif.c,v 9.2 89/12/28 15:40:12 mike Locked $ (BRL)";
a367 1
	struct vlhead	vhead;
d374 1
d426 2
a427 2
	vhead.vh_first = vhead.vh_last = VL_NULL;
	(void)uplot_vlist( &vhead, fp );
d441 3
a443 2
	invent_solid( "OVERLAPS", &vhead );
	dmaflag++;
d738 1
a738 1
static struct vlhead rtif_vhead;
d760 1
a760 1
	rtif_vhead.vh_first = rtif_vhead.vh_last = VL_NULL;
d767 1
d769 2
a770 2
	invent_solid( "EYE_PATH", &rtif_vhead );
	fclose(fp);
d856 1
d859 2
a860 2
	move = rtif_vhead.vh_first != VL_NULL;
	ADD_VL( &rtif_vhead, rtif_eye_model, move );
d878 4
a881 4
	ADD_VL( &rtif_vhead, xm, 1 );
	ADD_VL( &rtif_vhead, rtif_eye_model, 0 );
	ADD_VL( &rtif_vhead, ym, 1 );
	ADD_VL( &rtif_vhead, rtif_eye_model, 0 );
@


9.2
log
@Added identification to error message.
increased command buffer to 10k.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: rtif.c,v 9.1 89/05/19 06:03:43 mike Locked $ (BRL)";
a43 3
extern int	numargs;	/* number of args */
extern char	*cmd_args[];	/* array of pointers to args */

d166 1
a166 1
#define LEN	10240
d269 3
a271 1
f_rt()
d294 2
a295 2
	for( i=1; i < numargs; i++ )
		*vp++ = cmd_args[i];
d318 3
a320 1
f_rrt()
d340 2
a341 2
	for( i=1; i < numargs; i++ )
		*vp++ = cmd_args[i];
d362 3
a364 1
f_rtcheck()
d383 2
a384 2
	for( i=1; i < numargs; i++ )
		*vp++ = cmd_args[i];
d475 3
a477 1
f_saveview()
d484 2
a485 2
	if( (fp = fopen( cmd_args[1], "a")) == NULL )  {
		perror(cmd_args[1]);
d488 2
a489 2
	base = basename( cmd_args[1], ".sh" );
	(void)chmod( cmd_args[1], 0755 );	/* executable */
d491 3
a493 3
	for( i=2; i < numargs; i++ )
		(void)fprintf(fp,"%s ", cmd_args[i]);
	(void)fprintf(fp,"$*\\\n -o %s.pix\\\n", base);
d513 1
a513 1
	(void)fprintf(fp,"\\\n 2> %s.log\\\n", base);
d541 3
a543 1
f_rmats()
d561 2
a562 2
	if( (fp = fopen(cmd_args[1], "r")) == NULL )  {
		perror(cmd_args[1]);
d566 2
a567 2
	if( numargs > 2 )
		mode = atoi(cmd_args[2]);
d656 3
a658 1
f_savekey()
d666 2
a667 2
	if( (fp = fopen( cmd_args[1], "a")) == NULL )  {
		perror(cmd_args[1]);
d670 2
a671 2
	if( numargs > 2 ) {
		time = atof( cmd_args[2] );
d740 3
a742 1
f_preview()
d750 2
a751 2
	if( (fp = fopen(cmd_args[1], "r")) == NULL )  {
		perror(cmd_args[1]);
@


9.1
log
@Release_3.5
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: rtif.c,v 8.7 89/04/06 20:18:17 mike Exp $ (BRL)";
d169 1
a169 1
#define LEN	128
d193 1
a193 1
			(void)printf("ran out of rt_cmd_vec at %s\n",
@


8.7
log
@Converted to externs.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: rtif.c,v 8.6 89/02/11 04:03:04 mike Locked $ (BRL)";
@


8.6
log
@Changed to set new format RT script on RT and RRT commands.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: rtif.c,v 8.5 89/01/09 05:10:22 mike Locked $ (BRL)";
d39 1
a42 4

extern void	perror();
extern int	atoi(), execl(), fork(), nice(), wait();
extern long	time();
@


8.5
log
@Moved command table here,
improved "preview" command somewhat.
Added "lookat_pt" support.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: rtif.c,v 8.4 88/12/28 22:03:56 mike Locked $ (BRL)";
d250 2
d253 2
d304 1
a304 1
	if( retcode == 0 )  {
d348 1
a348 1
	if( retcode == 0 )  {
d415 2
d418 2
@


8.4
log
@Fixed reattach logic in "rt" and "rrt" commands.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: rtif.c,v 8.3 88/12/06 02:48:07 mike Locked $ (BRL)";
d669 39
a720 1
#include "../rt/cmd.c"
d728 2
a729 2
	register FILE *fp;
	char	buf[512];
d745 4
a748 3
	while( read_cmd( fp, buf, sizeof(buf) ) >= 0 )  {
		if( do_cmd( buf ) < 0 )
			rt_log("command failed: %s\n", buf);
d790 25
d837 1
d840 2
a841 1
	ADD_VL( &rtif_vhead, rtif_eye_model, rtif_vhead.vh_first != VL_NULL );
d850 14
a874 11
#if 1
	/* Draw camera orientation notch to right (+X) and up (+Y) */
	VSET( xv, 0.05, 0, 0 );
	VSET( yv, 0, 0.05, 0 );
	MAT4X3PNT( xm, view2model, xv );
	MAT4X3PNT( ym, view2model, yv );
	ADD_VL( &rtif_vhead, xm, 1 );
	ADD_VL( &rtif_vhead, ym, 1 );
	ADD_VL( &rtif_vhead, rtif_eye_model, 1 );
#endif

d877 1
@


8.3
log
@Declaration of atof() conflicted with the one in <math.h> on _STDC_
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: rtif.c,v 8.2 88/12/06 02:31:54 mike Locked $ (BRL)";
d53 29
d258 1
a258 1
		(void)printf("Abnormal exit status x%x\n", retcode);
d277 1
d287 2
a288 2
	if(dmp->dmr_releasedisplay)
		release();
d306 1
a306 1
	if(dmp->dmr_releasedisplay)
d324 1
d334 2
a335 2
	if(dmp->dmr_releasedisplay)
		release();
d350 1
a350 1
	if(dmp->dmr_releasedisplay)
d426 1
a426 1
		(void)printf("Abnormal exit status x%x\n", retcode);
@


8.2
log
@Converted to new db_*() routines.
Preparations for reading RT command scripts
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/rtif.c,v 1.3 88/10/30 02:35:57 mike Exp $ (BRL)";
a45 1
extern double	atof();
@


8.1
log
@Release_3.0
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: rtif.c,v 1.4 88/09/17 02:33:12 reschly Exp $ (BRL)";
d38 1
a39 1
#include "./objdir.h"
d46 1
a47 2
extern char	*filename;	/* Name of database file */

d110 1
a110 1
 *  Read in one view in RT format.
d267 1
a267 1
	*vp++ = filename;
d310 1
a310 1
	*vp++ = filename;
d351 1
a351 1
	*vp++ = filename;
d454 1
a454 1
	(void)fprintf(fp," %s\\\n ", filename);
d528 1
a528 1
		if( (dp=lookup("EYE",LOOKUP_NOISY)) == DIR_NULL )  {
d532 1
a532 1
		db_getrec( dp, &rec, 0 );
d637 173
@


1.4
log
@added code to conditionally release display before using framebuffer.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: rtif.c,v 1.3 88/05/15 23:05:18 reschly Locked $ (BRL)";
@


1.3
log
@lint fixes
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: rtif.c,v 1.2 88/02/27 01:21:36 mike Locked $ (BRL)";
a207 1

d259 2
a260 1
	release();
d278 2
a279 1
	attach( dm );
d305 2
a306 1
	release();
d321 2
a322 1
	attach( dm );
@


1.2
log
@Added support for rtcheck, pushed some common code into subroutines
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: rtif.c,v 1.1 88/02/26 22:57:35 mike Locked $ (BRL)";
d52 2
d148 1
@


1.1
log
@Initial revision
@
text
@d9 1
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 7.6 88/02/25 06:04:45 mike Locked $ (BRL)";
d48 1
a48 1
int		drawreg;	/* if > 0, process and draw regions */
d137 11
a147 3
#define LEN 32
void
f_rt()
a148 1
	register char **vp;
a150 6
	int pid, rpid;
	int retcode;
	int o_pipe[2];
	char *vec[LEN];
	char *dm;
	FILE *fp;
a151 3
	if( not_state( ST_VIEW, "Ray-trace of current view" ) )
		return;

d153 1
a153 15
	 * This may be a workstation where RT and MGED have to share the
	 * display, so let display go.  We will try to reattach at the end.
	 */
	dm = dmp->dmr_name;
	release();

	vp = &vec[0];
	*vp++ = "rt";
	*vp++ = "-s50";
	*vp++ = "-M";
	for( i=1; i < numargs; i++ )
		*vp++ = cmd_args[i];
	*vp++ = filename;

	/* Find all unique top-level entrys.
d159 1
a159 1
		register struct solid *forw;	/* XXX */
d163 1
a163 1
		if( vp < &vec[LEN] )
d165 2
a166 2
		else
			(void)printf("ran out of vec for %s\n",
d168 2
d178 2
a179 1
	vp = &vec[0];
d184 14
d207 3
a209 3
		(void)execvp( "rt", vec );
		perror( "rt" );
		exit(42);
d211 2
a212 1
	/* Connect up to pipe */
d224 2
a225 2
	
	/* Wait for rt to finish */
d235 34
a288 1
	register struct solid *sp;
d290 2
a291 6
	int pid, rpid;
	int retcode;
	int o_pipe[2];
	char *vec[LEN];
	char *dm;
	FILE *fp;
d303 1
a303 1
	vp = &vec[0];
d308 7
a314 20
	/* Find all unique top-level entrys.
	 *  Mark ones already done with s_iflag == UP
	 */
	FOR_ALL_SOLIDS( sp )
		sp->s_iflag = DOWN;
	FOR_ALL_SOLIDS( sp )  {
		register struct solid *forw;	/* XXX */

		if( sp->s_iflag == UP )
			continue;
		if( vp < &vec[LEN] )
			*vp++ = sp->s_path[0]->d_namep;
		else
			(void)printf("ran out of vec for %s\n",
				sp->s_path[0]->d_namep );
		sp->s_iflag = UP;
		for( forw=sp->s_forw; forw != &HeadSolid; forw=forw->s_forw) {
			if( forw->s_path[0] == sp->s_path[0] )
				forw->s_iflag = UP;
		}
d316 2
a317 1
	*vp = (char *)0;
d319 17
a335 4
	vp = &vec[0];
	while( *vp )
		(void)printf("%s ", *vp++ );
	(void)printf("\n");
d337 15
a351 1
	(void)pipe( o_pipe );
d356 2
d362 3
a364 3
		(void)execvp( cmd_args[1], vec );
		perror( cmd_args[1] );
		exit(42);
d366 2
a367 1
	/* Connect up to pipe */
d379 9
a387 2
	
	/* Wait for rt to finish */
d397 3
a399 7
	if( retcode == 0 )  {
		/* Wait for a return, then reattach display */
		printf("Press RETURN to reattach\007\n");
		while( getchar() != '\n' )
			/* NIL */  ;
	}
	attach( dm );
d403 1
a403 1
 *  				B A S E N A M E
d428 3
@
