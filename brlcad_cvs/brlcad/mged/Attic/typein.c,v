head	11.65;
access;
symbols
	ansi-20040405-merged:11.60.2.4
	postmerge-20040405-ansi:11.63
	premerge-20040404-ansi:11.62
	postmerge-autoconf:11.62
	autoconf-freeze:11.61.4.2
	premerge-autoconf:11.62
	postmerge-20040315-windows:11.62
	premerge-20040315-windows:11.62
	windows-20040315-freeze:11.60.4.1
	autoconf-20031203:11.61
	autoconf-20031202:11.61
	autoconf-branch:11.61.0.4
	phong-branch:11.61.0.2
	photonmap-branch:11.60.0.6
	rel-6-1-DP:11.60
	windows-branch:11.60.0.4
	rel-6-0-2:11.58
	ansi-branch:11.60.0.2
	rel-6-0-1-branch:11.58.0.2
	hartley-6-0-post:11.59
	hartley-6-0-pre:11.58
	rel-6-0-1:11.58
	rel-6-0:11.58
	rel-5-4:11.34.2.3
	offsite-5-3-pre:11.44
	rel-5-3:11.34.2.3
	rel-5-2:11.34
	rel-5-1-branch:11.34.0.2
	rel-5-1:11.34
	rel-5-0:11.28
	rel-5-0-beta:11.27
	rel-4-5:11.23
	ctj-4-5-post:11.20
	ctj-4-5-pre:11.20
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1
	rt-2:1.2;
locks; strict;
comment	@ * @;


11.65
date	2004.05.21.17.47.50;	author morrison;	state dead;
branches;
next	11.64;

11.64
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.63;

11.63
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.62;

11.62
date	2004.02.02.17.39.35;	author morrison;	state Exp;
branches;
next	11.61;

11.61
date	2003.07.28.18.13.50;	author jra;	state Exp;
branches
	11.61.4.1;
next	11.60;

11.60
date	2002.08.20.17.08.26;	author jra;	state Exp;
branches
	11.60.2.1
	11.60.4.1
	11.60.6.1;
next	11.59;

11.59
date	2002.08.15.20.55.39;	author hartley;	state Exp;
branches;
next	11.58;

11.58
date	2001.11.09.14.19.09;	author jra;	state Exp;
branches;
next	11.57;

11.57
date	2001.11.02.01.02.38;	author butler;	state Exp;
branches;
next	11.56;

11.56
date	2001.10.10.22.05.04;	author bparker;	state Exp;
branches;
next	11.55;

11.55
date	2001.10.05.18.56.32;	author butler;	state Exp;
branches;
next	11.54;

11.54
date	2001.10.05.18.50.00;	author jra;	state Exp;
branches;
next	11.53;

11.53
date	2001.10.05.15.40.23;	author jra;	state Exp;
branches;
next	11.52;

11.52
date	2001.10.02.19.24.32;	author jra;	state Exp;
branches;
next	11.51;

11.51
date	2001.08.11.13.16.11;	author butler;	state Exp;
branches;
next	11.50;

11.50
date	2001.08.02.20.07.09;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	2001.06.01.19.23.25;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	2001.03.31.01.57.24;	author morrison;	state Exp;
branches;
next	11.47;

11.47
date	2001.03.23.22.35.57;	author butler;	state Exp;
branches;
next	11.46;

11.46
date	2001.03.23.22.05.36;	author jra;	state Exp;
branches;
next	11.45;

11.45
date	2001.03.21.22.37.42;	author jra;	state Exp;
branches;
next	11.44;

11.44
date	2001.02.13.22.48.36;	author bparker;	state Exp;
branches;
next	11.43;

11.43
date	2001.01.30.13.16.18;	author jra;	state Exp;
branches;
next	11.42;

11.42
date	2001.01.29.21.04.12;	author jra;	state Exp;
branches;
next	11.41;

11.41
date	2000.10.24.19.55.21;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	2000.09.08.05.55.49;	author mike;	state Exp;
branches;
next	11.39;

11.39
date	2000.08.19.03.10.17;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	2000.07.24.22.22.12;	author mike;	state Exp;
branches;
next	11.37;

11.37
date	2000.07.24.19.27.31;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	2000.06.30.19.54.07;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	2000.06.29.14.55.38;	author butler;	state Exp;
branches;
next	11.34;

11.34
date	2000.02.14.04.42.39;	author butler;	state Exp;
branches
	11.34.2.1;
next	11.33;

11.33
date	99.12.30.19.36.43;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	99.12.29.23.23.26;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	99.11.26.19.42.58;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	99.11.24.14.26.42;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	99.11.17.18.42.27;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	99.09.01.18.55.11;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	99.03.30.16.17.50;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	99.02.05.18.47.33;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	98.06.29.15.28.43;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	98.04.03.01.42.26;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	98.01.06.18.52.23;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	97.08.22.22.38.22;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	97.05.22.09.29.07;	author butler;	state Exp;
branches;
next	11.19;

11.19
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	97.04.04.20.05.46;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	97.03.20.23.03.05;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	97.03.20.14.07.31;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	97.02.28.21.46.29;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	97.02.28.19.29.48;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.10.03.20.28.03;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.09.23.18.18.05;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.08.26.18.12.43;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.05.17.12.36.44;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.04.03.22.06.58;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	96.03.01.19.26.50;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.05.14;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.44;	author mike;	state Rel4_4;
branches;
next	10.15;

10.15
date	94.12.27.14.18.00;	author jra;	state Exp;
branches;
next	10.14;

10.14
date	94.12.16.19.37.30;	author gdurf;	state Exp;
branches;
next	10.13;

10.13
date	94.11.15.15.39.53;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.11.10.12.06.16;	author jra;	state Exp;
branches;
next	10.11;

10.11
date	94.10.25.22.32.29;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.09.23.09.57.47;	author jra;	state Exp;
branches;
next	10.9;

10.9
date	94.08.11.01.31.39;	author gdurf;	state Exp;
branches;
next	10.8;

10.8
date	94.08.09.18.45.51;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.06.13.19.04.08;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.06.01.16.47.17;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	92.06.23.09.53.44;	author mm;	state Exp;
branches;
next	10.4;

10.4
date	92.03.24.16.30.11;	author mmark;	state Exp;
branches;
next	10.3;

10.3
date	92.03.24.14.22.45;	author mmark;	state Exp;
branches;
next	10.2;

10.2
date	92.02.05.15.33.01;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.23;	author mike;	state Rel4_0;
branches;
next	9.13;

9.13
date	91.09.26.22.37.51;	author butler;	state Exp;
branches;
next	9.12;

9.12
date	91.08.30.17.15.42;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.06.14.06.31.39;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.02.27.22.07.48;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.01.15.01.38.51;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.01.14.22.53.47;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.01.14.22.38.35;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.12.20.20.19.29;	author butler;	state Exp;
branches;
next	9.5;

9.5
date	90.12.08.00.31.27;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.04.21.06.06.23;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.12.28.16.09.57;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.22.08;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.04.08;	author mike;	state Rel3_5;
branches;
next	8.7;

8.7
date	89.05.18.00.00.45;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.05.17.23.34.47;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.05.11.21.42.40;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.04.06.19.26.35;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	89.01.16.22.51.52;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.02.34.27;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.37.31;	author mike;	state Rel3_0;
branches;
next	7.7;

7.7
date	88.09.21.02.34.11;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.09.17.02.33.59;	author reschly;	state Exp;
branches;
next	7.5;

7.5
date	88.09.06.16.05.20;	author stay;	state Exp;
branches;
next	7.4;

7.4
date	88.05.15.23.05.24;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.29.16.08.54;	author stay;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.07.11;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.02.11;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.05.42;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.22.32;	author mike;	state Rel;
branches;
next	4.3;

4.3
date	87.02.13.00.13.20;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.15.23.15.46;	author kermit;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.23.23;	author mike;	state Rel1;
branches;
next	1.7;

1.7
date	86.09.23.17.42.08;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.08.12.06.51.10;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.07.18.02.45.19;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.07.17.17.16.44;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.09.14.05.37.33;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	85.08.07.05.19.59;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.06.19.03.02.37;	author mike;	state Exp;
branches;
next	;

11.34.2.1
date	2001.01.29.21.20.16;	author jra;	state Exp;
branches;
next	11.34.2.2;

11.34.2.2
date	2001.01.30.13.17.20;	author jra;	state Exp;
branches;
next	11.34.2.3;

11.34.2.3
date	2001.02.13.22.47.03;	author bparker;	state Exp;
branches;
next	;

11.60.2.1
date	2002.09.19.18.02.06;	author morrison;	state Exp;
branches;
next	11.60.2.2;

11.60.2.2
date	2003.01.31.00.11.55;	author morrison;	state Exp;
branches;
next	11.60.2.3;

11.60.2.3
date	2003.02.02.06.12.45;	author morrison;	state Exp;
branches;
next	11.60.2.4;

11.60.2.4
date	2004.03.17.21.22.05;	author morrison;	state Exp;
branches;
next	;

11.60.4.1
date	2004.03.11.23.46.37;	author morrison;	state Exp;
branches;
next	;

11.60.6.1
date	2003.08.26.14.03.43;	author justin;	state Exp;
branches;
next	;

11.61.4.1
date	2004.02.12.18.34.16;	author erikg;	state Exp;
branches;
next	11.61.4.2;

11.61.4.2
date	2004.03.15.14.07.41;	author erikg;	state Exp;
branches;
next	;


desc
@Kermit's dandy routine for allowing precise
numerical description of a solid, with prompting
for missing information.
@


11.65
log
@moved to src/mged/
@
text
@/*
 *  			T Y P E I N
 *
 * This module contains functions which allow solid parameters to
 * be entered by keyboard.
 *
 * Functions -
 *	f_in		decides what solid needs to be entered and
 *			calls the appropriate solid parameter reader
 *	arb_in		reads ARB params from keyboard
 *	sph_in		reads sphere params from keyboard
 *	ell_in		reads params for all ELLs
 *	tor_in		gets params for torus from keyboard
 *	tgc_in		reads params for TGC from keyboard
 *	rcc_in		reads params for RCC from keyboard
 *	rec_in		reads params for REC from keyboard
 *	tec_in		reads params for TEC from keyboard
 *	trc_in		reads params for TRC from keyboard
 *	box_in		gets params for BOX and RAW from keyboard
 *	rpp_in		gets params for RPP from keyboard
 *	ars_in		gets ARS param from keyboard
 *	half_in		gets HALFSPACE params from keyboard
 *	rpc_in		reads right parabolic cylinder params from keyboard
 *	rhc_in		reads right hyperbolic cylinder params from keyboard
 *	epa_in		reads elliptical paraboloid params from keyboard
 *	ehy_in		reads elliptical hyperboloid params from keyboard
 *	eto_in		reads elliptical torus params from keyboard
 *	part_in		reads particle params from keyboard
 *	extrude_in	reads extrude params from keyboard
 *	superell_in		reads params for all SUPERELLs
 *	checkv		checks for zero vector from keyboard
 *
 * Authors -
 *	Charles M. Kennedy
 *	Keith A. Applin
 *	Michael J. Muuss
 *	Michael J. Markowski
 *
 * Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 * Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/typein.c,v 11.64 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <signal.h>
#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "nurb.h"
#include "wdb.h"
#include "./ged.h"
#include "./mged_dm.h"
#include "./cmd.h"

void	aexists(char *name);

int		vals;		/* number of args for s_values[] */
char		**promp;	/* the prompt string */

char *p_half[] = {
	"Enter X, Y, Z of outward pointing normal vector: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter the distance from the origin: "
};

char *p_dsp_v4[] = {
	"Enter name of displacement-map file: ",
	"Enter width of displacement-map (number of values): ",
	"Enter length of displacement-map (number of values): ",
	"Normal Interpolation? 0=no 1=yes: ",
	"Cell size: ",
	"Unit elevation: "
};


char *p_dsp_v5[] = {
	"Take data from file or database binary object [f|o]:",
	"Enter name of file/object: ",
	"Enter width of displacement-map (number of values): ",
	"Enter length of displacement-map (number of values): ",
	"Normal Interpolation? 0=no 1=yes: ",
	"Cut direction [ad|lR|Lr] ",
	"Cell size: ",
	"Unit elevation: "
};

char *p_hf[] = {
	"Enter name of control file (or \"\" for none): ",
	"Enter name of data file (containing heights): ",
	"Enter 'cv' style format of data [h|n][s|u]c|s|i|l|d|8|16|32|64: ",
	"Enter number of values in 'x' direction: ",
	"Enter number of values in 'y' direction: ",
	"Enter '1' if data can be stored as 'short' in memory, or 0: ",
	"Enter factor to convert file data to mm: ",
	"Enter coordinates to position HF solid: ",
	"Enter Y coordinate: ",
	"Enter Z coordinate: ",
	"Enter direction vector for 'x' direction: ",
	"Enter Y coordinate: ",
	"Enter Z coordinate: ",
	"Enter direction vector for 'y' direction: ",
	"Enter Y coordinate: ",
	"Enter Z coordinate: ",
	"Enter length of HF in 'x' direction: ",
	"Enter width of HF in 'y' direction: ",
	"Enter scale factor for height (after conversion to mm): "
};

char *p_ebm[] = {
	"Enter name of bit-map file: ",
	"Enter width of bit-map (number of cells): ",
	"Enter height of bit-map (number of cells): ",
	"Enter extrusion distance: "
};

char *p_submodel[] = {
	"Enter name of treetop: ",
	"Enter space partitioning method: ",
	"Enter name of .g file (or \"\" for none): "
};

char *p_vol[] = {
	"Enter name of file containing voxel data: ",
	"Enter X, Y, Z dimensions of file (number of cells): ",
	"Enter Y dimension of file (number of cells): ",
	"Enter Z dimension of file (number of cells): ",
	"Enter lower threshold value: ",
	"Enter upper threshold value: ",
	"Enter X, Y, Z dimensions of a cell: ",
	"Enter Y dimension of a cell: ",
	"Enter Z dimension of a cell: ",
};

char *p_bot[] = {
	"Enter number of vertices: ",
	"Enter number of triangles: ",
	"Enter mode (1->surface, 2->solid, 3->plate): ",
	"Enter triangle orientation (1->unoriented, 2->counter-clockwise, 3->clockwise): ",
	"Enter X, Y, Z",
	"Enter Y",
	"Enter Z",
	"Enter three vertex numbers",
	"Enter second vertex number",
	"Enter third vertex number",
	"Enter face_mode (0->centered, 1->appended) and thickness",
	"Enter thickness"
};

char *p_arbn[] = {
	"Enter number of planes: ",
	"Enter coefficients",
	"Enter Y-coordinate of normal",
	"Enter Z-coordinate of normal",
	"Enter distance of plane along normal from origin"
};

char *p_pipe[] = {
	"Enter number of points: ",
	"Enter X, Y, Z, inner diameter, outer diameter, and bend radius for first point: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter inner diameter: ",
	"Enter outer diameter: ",
	"Enter bend radius: ",
	"Enter X, Y, Z, inner diameter, outer diameter, and bend radius",
	"Enter Y",
	"Enter Z",
	"Enter inner diameter",
	"Enter outer diameter",
	"Enter bend radius"
};

char *p_ars[] = {
	"Enter number of points per waterline, and number of waterlines: ",
	"Enter number of waterlines: ",
	"Enter X, Y, Z for First row point: ",
	"Enter Y for First row point: ",
	"Enter Z for First row point: ",
	"Enter X  Y  Z",
	"Enter Y",
	"Enter Z",
};

char *p_arb[] = {
	"Enter X, Y, Z for point 1: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z for point 2: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z for point 3: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z for point 4: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z for point 5: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z for point 6: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z for point 7: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z for point 8: ",
	"Enter Y: ",
	"Enter Z: "
};

char *p_sph[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter radius: "
};

char *p_ellg[] = {
	"Enter X, Y, Z of focus point 1: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of focus point 2: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter axis length L: "
};

char *p_ell1[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector A: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter radius of revolution: "
};

char *p_ell[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector A: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector B: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector C: ",
	"Enter Y: ",
	"Enter Z: "
};

char *p_tor[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of normal vector: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter radius 1: ",
	"Enter radius 2: "
};

char *p_rcc[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of height (H) vector: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter radius: "
};

char *p_tec[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of height (H) vector: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector A: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector B: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter ratio: "
};

char *p_rec[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of height (H) vector: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector A: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector B: ",
	"Enter Y: ",
	"Enter Z: "
};

char *p_trc[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of height (H) vector: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter radius of base: ",
	"Enter radius of top: "
};

char *p_tgc[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of height (H) vector: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector A: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector B: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter scalar c: ",
	"Enter scalar d: "
};

char *p_box[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector H: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector W: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector D: ",
	"Enter Y: ",
	"Enter Z: "
};

char *p_rpp[] = {
	"Enter XMIN, XMAX, YMIN, YMAX, ZMIN, ZMAX: ",
	"Enter XMAX: ",
	"Enter YMIN, YMAX, ZMIN, ZMAX: ",
	"Enter YMAX: ",
	"Enter ZMIN, ZMAX: ",
	"Enter ZMAX: "
};

char *p_orpp[] = {
	"Enter XMAX, YMAX, ZMAX: ",
	"Enter YMAX, ZMAX: ",
	"Enter ZMAX: "
};

char *p_rpc[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z, of vector H: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z, of vector B: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter rectangular half-width, r: "
};

char *p_part[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z, of vector H: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter v end radius: ",
	"Enter h end radius: "
};

char *p_rhc[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z, of vector H: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z, of vector B: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter rectangular half-width, r: ",
	"Enter apex-to-asymptotes distance, c: "
};

char *p_epa[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z, of vector H: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z, of vector A: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter magnitude of vector B: "
};

char *p_ehy[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z, of vector H: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z, of vector A: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter magnitude of vector B: ",
	"Enter apex-to-asymptotes distance, c: "
};

char *p_eto[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z, of normal vector: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter radius of revolution, r: ",
	"Enter X, Y, Z, of vector C: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter magnitude of elliptical semi-minor axis, d: "
};

char *p_binunif[] = {
	"Enter minor type (f,d,c,s,i,L,C,S,I, or L): ",
	"Enter name of file containing the data: "
};

char *p_extrude[] = {
	"Enter X, Y, Z of vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of H: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of A: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of B: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter name of sketch: ",
	"Enter K: ",
	NULL
};

char *p_grip[] = {
	"Enter X, Y, Z of center: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of normal: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter Magnitude: ",
	NULL
};

char *p_superell[] = {
	"Enter X, Y, Z of superellipse vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector A: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector B: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector C: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter n, e of north-south and east-west power: ",
	"Enter e: "
};

/*	F _ I N ( ) :  	decides which solid reader to call
 *			Used for manual entry of solids.
 */
int
f_in(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register struct directory *dp;
	char			*name;
	struct rt_db_internal	internal;
	char			*new_cmd[3], **menu;
	int			c;
	int			do_solid_edit = 0;
	int			dont_draw = 0;
	int			nvals, (*fn_in)();
	int			arb_in(char **cmd_argvs, struct rt_db_internal *intern), box_in(char **cmd_argvs, struct rt_db_internal *intern), ehy_in(char **cmd_argvs, struct rt_db_internal *intern), ell_in(char **cmd_argvs, struct rt_db_internal *intern),
				epa_in(char **cmd_argvs, struct rt_db_internal *intern), eto_in(char **cmd_argvs, struct rt_db_internal *intern), half_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name), rec_in(char **cmd_argvs, struct rt_db_internal *intern),
				rcc_in(char **cmd_argvs, struct rt_db_internal *intern), rhc_in(char **cmd_argvs, struct rt_db_internal *intern), rpc_in(char **cmd_argvs, struct rt_db_internal *intern), rpp_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name), orpp_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name),
				sph_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name), tec_in(char **cmd_argvs, struct rt_db_internal *intern), tgc_in(char **cmd_argvs, struct rt_db_internal *intern), tor_in(char **cmd_argvs, struct rt_db_internal *intern), ars_in(int argc, char **argv, struct rt_db_internal *intern, char **promp),
				trc_in(char **cmd_argvs, struct rt_db_internal *intern), ebm_in(char **cmd_argvs, struct rt_db_internal *intern), vol_in(char **cmd_argvs, struct rt_db_internal *intern), hf_in(char **cmd_argvs, struct rt_db_internal *intern), bot_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt),
				dsp_in_v4(char **cmd_argvs, struct rt_db_internal *intern),dsp_in_v5(char **cmd_argvs, struct rt_db_internal *intern), submodel_in(char **cmd_argvs, struct rt_db_internal *intern), part_in(char **cmd_argvs, struct rt_db_internal *intern), pipe_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt),
				binunif_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name), arbn_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt), extrude_in(char **cmd_argvs, struct rt_db_internal *intern), grip_in(char **cmd_argvs, struct rt_db_internal *intern), superell_in(char **cmd_argvs, struct rt_db_internal *intern);

	CHECK_DBI_NULL;

	if(argc < 1){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help in");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* Parse options. */
	bu_optind = 1;		/* re-init bu_getopt() */
	bu_opterr = 0;          /* suppress bu_getopt()'s error message */
	while( (c=bu_getopt(argc,argv,"sf")) != EOF )  {
		switch(c)  {
		case 's':
			do_solid_edit = 1;
			break;
		case 'f':
			dont_draw = 1;
			break;
		default:
		  {
		    struct bu_vls tmp_vls;

		    bu_vls_init(&tmp_vls);
		    bu_vls_printf(&tmp_vls, "in: option '%c' unknown\n", bu_optopt);
		    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		    bu_vls_free(&tmp_vls);
		  }

		  break;
		}
	}
	argc -= bu_optind-1;
	argv += bu_optind-1;

	vals = 0;

	/* Get the name of the solid to be created */
	if( argc < 2 )  {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter name of solid: ", (char *)NULL);
	  return TCL_ERROR;
	}
	if( db_lookup( dbip,  argv[1], LOOKUP_QUIET ) != DIR_NULL )  {
	  aexists( argv[1] );
	  return TCL_ERROR;
	}
	if( dbip->dbi_version <= 4 && (int)strlen(argv[1]) >= NAMESIZE )  {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "ERROR, v4 names are limited to %d characters\n", NAMESIZE-1);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  return TCL_ERROR;
	}
	/* Save the solid name */
	name = argv[1];

	/* Get the solid type to be created and make it */
	if( argc < 3 )  {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter solid type: ", (char *)NULL);
	  return TCL_ERROR;
	}

	RT_INIT_DB_INTERNAL( &internal );

	/*
	 * Decide which solid to make and get the rest of the args
	 * make name <half|arb[4-8]|sph|ell|ellg|ell1|tor|tgc|tec|
			rec|trc|rcc|box|raw|rpp|rpc|rhc|epa|ehy|eto|superell>
	 */
	if( strcmp( argv[2], "ebm" ) == 0 )  {
		nvals = 4;
		menu = p_ebm;
		fn_in = ebm_in;
	} else if( strcmp( argv[2], "arbn" ) == 0 ) {
		switch( arbn_in(argc, argv, &internal, &p_arbn[0]) ) {
		case CMD_BAD:
		  Tcl_AppendResult(interp, "ERROR, ARBN not made!\n",
				   (char *)NULL);
		  rt_db_free_internal( &internal, &rt_uniresource );
		  return TCL_ERROR;
		case CMD_MORE:
		  return TCL_ERROR;
		}
		goto do_new_update;
	} else if( strcmp( argv[2], "bot" ) == 0 ) {
		switch( bot_in(argc, argv, &internal, &p_bot[0]) ) {
		case CMD_BAD:
		  Tcl_AppendResult(interp, "ERROR, BOT not made!\n",
				   (char *)NULL);
		  rt_db_free_internal( &internal, &rt_uniresource );
		  return TCL_ERROR;
		case CMD_MORE:
		  return TCL_ERROR;
		}
		goto do_new_update;
	} else if( strcmp( argv[2], "submodel" ) == 0 )  {
		nvals = 3;
		menu = p_submodel;
		fn_in = submodel_in;
	} else if( strcmp( argv[2], "vol" ) == 0 )  {
		nvals = 9;
		menu = p_vol;
		fn_in = vol_in;
	} else if( strcmp( argv[2], "hf" ) == 0 )  {
		if (dbip->dbi_version <= 4) {
			nvals = 19;
			menu = p_hf;
			fn_in = hf_in;
			Tcl_AppendResult(interp, "in: the height field is deprecated. Use the dsp primitive.\n", (char *)NULL);
		} else {
			Tcl_AppendResult(interp, "in: the height field is deprecated and not supported by this command when using a new\nstyle database. Use the dsp primitive.\n", (char *)NULL);
			return TCL_ERROR;
		}
	} else if (strcmp(argv[2], "poly") == 0 ||
		   strcmp(argv[2], "pg") == 0) {
		Tcl_AppendResult(interp, "in: the polysolid is deprecated and not supported by this command.\nUse the bot primitive.\n", (char *)NULL);
		return TCL_ERROR;
	} else if( strcmp( argv[2], "dsp" ) == 0 )  {
		if (dbip->dbi_version <= 4) {
			nvals = 6;
			menu = p_dsp_v4;
			fn_in = dsp_in_v4;
		} else {
			nvals = 8;
			menu = p_dsp_v5;
			fn_in = dsp_in_v5;
		}

	} else if( strcmp( argv[2], "pipe" ) == 0 ) {
		switch( pipe_in(argc, argv, &internal, &p_pipe[0]) ) {
		case CMD_BAD:
		  Tcl_AppendResult(interp, "ERROR, pipe not made!\n", (char *)NULL);
		  rt_db_free_internal( &internal, &rt_uniresource );
		  return TCL_ERROR;
		case CMD_MORE:
		  return TCL_ERROR;
		}
		goto do_new_update;
	} else if( strcmp( argv[2], "ars" ) == 0 )  {
		switch( ars_in(argc, argv, &internal, &p_ars[0]) ) {
		case CMD_BAD:
		  Tcl_AppendResult(interp, "ERROR, ars not made!\n", (char *)NULL);
		  rt_db_free_internal( &internal, &rt_uniresource );
		  return TCL_ERROR;
		case CMD_MORE:
		  return TCL_ERROR;
		}
		goto do_new_update;
	} else if( strcmp( argv[2], "half" ) == 0 )  {
		nvals = 3*1 + 1;
		menu = p_half;
		fn_in = half_in;
	} else if( strncmp( argv[2], "arb", 3 ) == 0 )  {
		int n = atoi(&argv[2][3]);

		if(n < 4 || 8 < n){
			Tcl_AppendResult(interp, "ERROR: \"", argv[2],
					 "\" not supported!\n", (char *)0);
			Tcl_AppendResult(interp, "supported arbs: arb4 arb5 arb6 arb7 arb8\n",
						 (char *)0);
			return TCL_ERROR;
		}

		nvals = 3*n;
		menu = p_arb;
		fn_in = arb_in;
	} else if( strcmp( argv[2], "sph" ) == 0 )  {
		nvals = 3*1 + 1;
		menu = p_sph;
		fn_in = sph_in;
	} else if( strcmp( argv[2], "ellg" ) == 0 )  {
		nvals = 3*2 + 1;
		menu = p_ellg;
		fn_in = ell_in;
	} else if( strcmp( argv[2], "ell" ) == 0 )  {
		nvals = 3*4;
		menu = p_ell;
		fn_in = ell_in;
	} else if( strcmp( argv[2], "ell1" ) == 0 )  {
		nvals = 3*2 + 1;
		menu = p_ell1;
		fn_in = ell_in;
	} else if( strcmp( argv[2], "tor" ) == 0 )  {
		nvals = 3*2 + 2;
		menu = p_tor;
		fn_in = tor_in;
	} else if( strcmp( argv[2], "tgc" ) == 0 ) {
		nvals = 3*4 + 2;
		menu = p_tgc;
		fn_in = tgc_in;
	} else if( strcmp( argv[2], "tec" ) == 0 )  {
		nvals = 3*4 + 1;
		menu = p_tec;
		fn_in = tec_in;
	} else if( strcmp( argv[2], "rec" ) == 0 )  {
		nvals = 3*4;
		menu = p_rec;
		fn_in = rec_in;
	} else if( strcmp( argv[2], "trc" ) == 0 )  {
		nvals = 3*2 + 2;
		menu = p_trc;
		fn_in = trc_in;
	} else if( strcmp( argv[2], "rcc" ) == 0 )  {
		nvals = 3*2 + 1;
		menu = p_rcc;
		fn_in = rcc_in;
	} else if( strcmp( argv[2], "box" ) == 0 
		|| strcmp( argv[2], "raw" ) == 0 )  {
		nvals = 3*4;
		menu = p_box;
		fn_in = box_in;
	} else if( strcmp( argv[2], "rpp" ) == 0 )  {
		nvals = 3*2;
		menu = p_rpp;
		fn_in = rpp_in;
	} else if( strcmp( argv[2], "orpp" ) == 0 )  {
		nvals = 3*1;
		menu = p_orpp;
		fn_in = orpp_in;
	} else if( strcmp( argv[2], "rpc" ) == 0 )  {
		nvals = 3*3 + 1;
		menu = p_rpc;
		fn_in = rpc_in;
	} else if( strcmp( argv[2], "rhc" ) == 0 )  {
		nvals = 3*3 + 2;
		menu = p_rhc;
		fn_in = rhc_in;
	} else if( strcmp( argv[2], "epa" ) == 0 )  {
		nvals = 3*3 + 1;
		menu = p_epa;
		fn_in = epa_in;
	} else if( strcmp( argv[2], "ehy" ) == 0 )  {
		nvals = 3*3 + 2;
		menu = p_ehy;
		fn_in = ehy_in;
	} else if( strcmp( argv[2], "eto" ) == 0 )  {
		nvals = 3*3 + 2;
		menu = p_eto;
		fn_in = eto_in;
	} else if( strcmp( argv[2], "part" ) == 0 )  {
		nvals = 2*3 + 2;
		menu = p_part;
		fn_in = part_in;
	} else if( strcmp( argv[2], "binunif" ) == 0 ) {
		if (dbip->dbi_version <= 4) {
			Tcl_AppendResult(interp, "in: the binunif primitive is not supported by this command when using an old style database", (char *)NULL);
			return TCL_ERROR;
		} else {
			nvals = 2;
			menu = p_binunif;
			fn_in = binunif_in;
			do_solid_edit = 0;
			dont_draw = 1;
		}
	} else if (strcmp(argv[2], "extrude") == 0) {
		nvals = 4*3 + 2;
		menu = p_extrude;
		fn_in = extrude_in;
	} else if (strcmp(argv[2], "grip") == 0) {
		nvals = 2*3 + 1;
		menu = p_grip;
		fn_in = grip_in;
	} else if( strcmp( argv[2], "superell" ) == 0 )  {
		nvals = 3*4 + 2;
		menu = p_superell;
		fn_in = superell_in;
	} else if (strcmp(argv[2], "cline") == 0 ||
		   strcmp(argv[2], "grip") == 0 ||
		   strcmp(argv[2], "nmg") == 0 ||
		   strcmp(argv[2], "nurb") == 0 ||
		   strcmp(argv[2], "sketch") == 0 ||
		   strcmp(argv[2], "spline") == 0) {
		Tcl_AppendResult(interp, "in: the ", argv[2], " primitive is not supported by this command", (char *)NULL);
		return TCL_ERROR;
	} else {
	  Tcl_AppendResult(interp, "f_in:  ", argv[2], " is not a known primitive\n",
			   (char *)NULL);
	  return TCL_ERROR;
	}
	
	/* Read arguments */
	if( argc < 3+nvals )  {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, menu[argc-3], (char *)NULL);
	  return TCL_ERROR;
	}

	if (fn_in(argv, &internal, name) != 0)  {
	  Tcl_AppendResult(interp, "ERROR, ", argv[2], " not made!\n", (char *)NULL);
	  if( internal.idb_ptr ) {
		  /* a few input functions do not use the internal pointer
		   * only free it, if it has been used
		   */
		  rt_db_free_internal( &internal, &rt_uniresource );
	  }
	  return TCL_ERROR;
	}

do_new_update:
	/* The function may have already written via LIBWDB */
	if( internal.idb_ptr != NULL )  {
		if( (dp=db_diradd( dbip, name, -1L, 0, DIR_SOLID, (genptr_t)&internal.idb_type)) == DIR_NULL )  {
			rt_db_free_internal( &internal, &rt_uniresource );
			Tcl_AppendResult(interp, "Cannot add '", name, "' to directory\n", (char *)NULL );
			return TCL_ERROR;
		}
		if( rt_db_put_internal( dp, dbip, &internal, &rt_uniresource ) < 0 )
		{
			rt_db_free_internal( &internal, &rt_uniresource );
			TCL_WRITE_ERR_return;
		}
	}

	if( dont_draw )  return TCL_OK;

	/* draw the newly "made" solid */
	new_cmd[0] = "e";
	new_cmd[1] = name;
	new_cmd[2] = (char *)NULL;
	(void)cmd_draw( clientData, interp, 2, new_cmd );

	if( do_solid_edit )  {
		/* Also kick off solid edit mode */
		new_cmd[0] = "sed";
		new_cmd[1] = name;
		new_cmd[2] = (char *)NULL;
		(void)f_sed( clientData, interp, 2, new_cmd );
	}
	return TCL_OK;
}

int
binunif_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
{
	unsigned int minor_type;

	CHECK_DBI_NULL;

	intern->idb_ptr = NULL;

	if( strlen( cmd_argvs[3] ) != 1 ) {
		bu_log( "Unrecognized minor type (%s)\n", cmd_argvs[3] );
		return 1;
	}
	
	switch( *cmd_argvs[3] ) {
		case 'f':
			minor_type = DB5_MINORTYPE_BINU_FLOAT;
			break;
		case 'd':
			minor_type = DB5_MINORTYPE_BINU_DOUBLE;
			break;
		case 'c':
			minor_type = DB5_MINORTYPE_BINU_8BITINT;
			break;
		case 's':
			minor_type = DB5_MINORTYPE_BINU_16BITINT;
			break;
		case 'i':
			minor_type = DB5_MINORTYPE_BINU_32BITINT;
			break;
		case 'l':
			minor_type = DB5_MINORTYPE_BINU_64BITINT;
			break;
		case 'C':
			minor_type = DB5_MINORTYPE_BINU_8BITINT_U;
			break;
		case 'S':
			minor_type = DB5_MINORTYPE_BINU_16BITINT_U;
			break;
		case 'I':
			minor_type = DB5_MINORTYPE_BINU_32BITINT_U;
			break;
		case 'L':
			minor_type = DB5_MINORTYPE_BINU_64BITINT_U;
			break;
		default:
			bu_log( "Unrecognized minor type (%c)\n", *cmd_argvs[3] );
			return 1;
	}
	if( mk_binunif( wdbp, name, cmd_argvs[4], minor_type ) ) {
		bu_log( "Failed to create binary object %s from file %s\n",
			name, cmd_argvs[4] );
		return 1;
	}

	return 0;
}

/*			E B M _ I N
 *
 *	Read EBM solid from keyboard
 *
 */
int
ebm_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	struct rt_ebm_internal	*ebm;

	CHECK_DBI_NULL;

	BU_GETSTRUCT( ebm, rt_ebm_internal );
	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_EBM;
	intern->idb_meth = &rt_functab[ID_EBM];
	intern->idb_ptr = (genptr_t)ebm;
	ebm->magic = RT_EBM_INTERNAL_MAGIC;

	strcpy( ebm->file, cmd_argvs[3] );
	ebm->xdim = atoi( cmd_argvs[4] );
	ebm->ydim = atoi( cmd_argvs[5] );
	ebm->tallness = atof( cmd_argvs[6] ) * local2base;
	MAT_IDN( ebm->mat );

	return( 0 );
}

/*			S U B M O D E L _ I N
 *
 *	Read submodel from keyboard
 *
 */
int
submodel_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	struct rt_submodel_internal	*sip;

	CHECK_DBI_NULL;

	BU_GETSTRUCT( sip, rt_submodel_internal );
	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_SUBMODEL;
	intern->idb_meth = &rt_functab[ID_SUBMODEL];
	intern->idb_ptr = (genptr_t)sip;
	sip->magic = RT_SUBMODEL_INTERNAL_MAGIC;

	bu_vls_init( &sip->treetop );
	bu_vls_strcpy( &sip->treetop, cmd_argvs[3] );
	sip->meth = atoi( cmd_argvs[4] );
	bu_vls_init( &sip->file );
	bu_vls_strcpy( &sip->file, cmd_argvs[5] );

	return( 0 );
}

/*			D S P _ I N
 *
 *	Read DSP solid from keyboard
 */
int
dsp_in_v4 (char **cmd_argvs, struct rt_db_internal *intern)
{
	struct rt_dsp_internal	*dsp;

	BU_GETSTRUCT( dsp, rt_dsp_internal );
	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_DSP;
	intern->idb_meth = &rt_functab[ID_DSP];
	intern->idb_ptr = (genptr_t)dsp;
	dsp->magic = RT_DSP_INTERNAL_MAGIC;

	bu_vls_init( &dsp->dsp_name );
	bu_vls_strcpy( &dsp->dsp_name, cmd_argvs[3] );

	dsp->dsp_xcnt = atoi( cmd_argvs[4] );
	dsp->dsp_ycnt = atoi( cmd_argvs[5] );
	dsp->dsp_smooth = atoi( cmd_argvs[6] );
	MAT_IDN( dsp->dsp_stom );
	
	dsp->dsp_stom[0] = dsp->dsp_stom[5] = 
		atof( cmd_argvs[7] ) * local2base;

	dsp->dsp_stom[10] = atof( cmd_argvs[8] ) * local2base;

	bn_mat_inv( dsp->dsp_mtos, dsp->dsp_stom );

	return( 0 );
}

extern void dsp_dump(struct rt_dsp_internal *dsp);

/*			D S P _ I N
 *
 *	Read DSP solid from keyboard
 */
int
dsp_in_v5 (char **cmd_argvs, struct rt_db_internal *intern)
{
	struct rt_dsp_internal	*dsp;

	BU_GETSTRUCT( dsp, rt_dsp_internal );
	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_DSP;
	intern->idb_meth = &rt_functab[ID_DSP];
	intern->idb_ptr = (genptr_t)dsp;
	dsp->magic = RT_DSP_INTERNAL_MAGIC;

	if (*cmd_argvs[3] == 'f' || *cmd_argvs[3] == 'F')
		dsp->dsp_datasrc = RT_DSP_SRC_FILE;
	else if (*cmd_argvs[3] == 'O' || *cmd_argvs[3] == 'o')
		dsp->dsp_datasrc = RT_DSP_SRC_OBJ;
	else
		return -1;

	bu_vls_init( &dsp->dsp_name );
	bu_vls_strcpy( &dsp->dsp_name, cmd_argvs[4] );

	dsp->dsp_xcnt = atoi( cmd_argvs[5] );
	dsp->dsp_ycnt = atoi( cmd_argvs[6] );
	dsp->dsp_smooth = atoi( cmd_argvs[7] );
	switch ( *cmd_argvs[8] ) {
	case 'a':	/* adaptive */
	case 'A': 
	    dsp->dsp_cuttype = DSP_CUT_DIR_ADAPT;
	    break;
	case 'l':	/* lower left to upper right */
	    dsp->dsp_cuttype = DSP_CUT_DIR_llUR;
	    break;
	case 'L':	/* Upper Left to lower right */
	    dsp->dsp_cuttype = DSP_CUT_DIR_ULlr;
	    break;
	default:
	    bu_log("Error: dsp_cuttype:\"%s\"\n", cmd_argvs[8]);
	    return -1;
	    break;
	}

	MAT_IDN( dsp->dsp_stom );
	
	dsp->dsp_stom[0] = dsp->dsp_stom[5] = 
		atof( cmd_argvs[9] ) * local2base;

	dsp->dsp_stom[10] = atof( cmd_argvs[10] ) * local2base;

	bn_mat_inv( dsp->dsp_mtos, dsp->dsp_stom );

	return( 0 );
}



/*			H F _ I N
 *
 *	Read HF solid from keyboard
 *
 */
int
hf_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	struct rt_hf_internal	*hf;

	CHECK_DBI_NULL;

	BU_GETSTRUCT( hf, rt_hf_internal );
	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_HF;
	intern->idb_meth = &rt_functab[ID_HF];
	intern->idb_ptr = (genptr_t)hf;
	hf->magic = RT_HF_INTERNAL_MAGIC;

	strcpy( hf->cfile, cmd_argvs[3] );
	strcpy( hf->dfile, cmd_argvs[4] );
	strncpy( hf->fmt, cmd_argvs[5], 7 );
	hf->fmt[7] = '\0';
	hf->w = atoi( cmd_argvs[6] );
	hf->n = atoi( cmd_argvs[7] );
	hf->shorts = atoi( cmd_argvs[8] );
	hf->file2mm = atof( cmd_argvs[9] );
	hf->v[0] = atof( cmd_argvs[10] ) * local2base;
	hf->v[1] = atof( cmd_argvs[11] ) * local2base;
	hf->v[2] = atof( cmd_argvs[12] ) * local2base;
	hf->x[0] = atof( cmd_argvs[13] );
	hf->x[1] = atof( cmd_argvs[14] );
	hf->x[2] = atof( cmd_argvs[15] );
	hf->y[0] = atof( cmd_argvs[16] );
	hf->y[1] = atof( cmd_argvs[17] );
	hf->y[2] = atof( cmd_argvs[18] );
	hf->xlen = atof( cmd_argvs[19] ) * local2base;
	hf->ylen = atof( cmd_argvs[20] ) * local2base;
	hf->zscale = atof( cmd_argvs[21] );

	if( hf->w < 2 || hf->n < 2 )
	{
		Tcl_AppendResult(interp, "ERROR: length or width of fta file is too small\n", (char *)NULL );
		return( 1 );
	}

	if( hf->xlen <= 0 || hf->ylen <= 0 )
	{
		Tcl_AppendResult(interp, "ERROR: length and width of HF solid must be greater than 0\n", (char *)NULL );
		return( 1 );
	}

	/* XXXX should check for orthogonality of 'x' and 'y' vectors */

	if( !(hf->mp = bu_open_mapped_file( hf->dfile, "hf" )) )
	{
		Tcl_AppendResult(interp, "ERROR: cannot open data file\n", (char *)NULL );
		hf->mp = (struct bu_mapped_file *)NULL;
		return( 1 );
	}

	return( 0 );
}

/*			V O L _ I N
 *
 *	Read VOL solid from keyboard
 *
 */
int
vol_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	struct rt_vol_internal	*vol;

	CHECK_DBI_NULL;

	BU_GETSTRUCT( vol, rt_vol_internal );
	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_VOL;
	intern->idb_meth = &rt_functab[ID_VOL];
	intern->idb_ptr = (genptr_t)vol;
	vol->magic = RT_VOL_INTERNAL_MAGIC;

	strcpy( vol->file, cmd_argvs[3] );
	vol->xdim = atoi( cmd_argvs[4] );
	vol->ydim = atoi( cmd_argvs[5] );
	vol->zdim = atoi( cmd_argvs[6] );
	vol->lo = atoi( cmd_argvs[7] );
	vol->hi = atoi( cmd_argvs[8] );
	vol->cellsize[0] = atof( cmd_argvs[9] ) * local2base;
	vol->cellsize[1] = atof( cmd_argvs[10] ) * local2base;
	vol->cellsize[2] = atof( cmd_argvs[11] ) * local2base;
	MAT_IDN( vol->mat );

	return( 0 );
}

/*
 *			B O T _ I N
 */
int
bot_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt)
{
	int i;
	int num_verts, num_faces;
	int mode, orientation;
	int arg_count;
	struct rt_bot_internal *bot;

	CHECK_DBI_NULL;

	if( argc < 7 ) {
		Tcl_AppendResult(interp, MORE_ARGS_STR, prompt[argc-3], (char *)NULL);
		return CMD_MORE;
	}

	num_verts = atoi( argv[3] );
	if( num_verts < 3 )
	{
		Tcl_AppendResult(interp, "Invalid number of vertices (must be at least 3)\n", (char *)NULL);
		return CMD_BAD;
	}

	num_faces = atoi( argv[4] );
	if( num_faces < 1 )
	{
		Tcl_AppendResult(interp, "Invalid number of triangles (must be at least 1)\n", (char *)NULL);
		return CMD_BAD;
	}

	mode = atoi( argv[5] );
	if( mode < 1 || mode > 3 )
	{
		Tcl_AppendResult(interp, "Invalid mode (must be 1, 2, or 3)\n", (char *)NULL );
		return CMD_BAD;
	}

	orientation = atoi( argv[6] );
	if( orientation < 1 || orientation > 3 )
	{
		Tcl_AppendResult(interp, "Invalid orientation (must be 1, 2, or 3)\n", (char *)NULL );
		return CMD_BAD;
	}

	arg_count = argc - 7;
	if( arg_count < num_verts*3 )
	{
		struct bu_vls tmp_vls;

		bu_vls_init( &tmp_vls );
		bu_vls_printf( &tmp_vls, "%s for vertex %d : ", prompt[4+arg_count%3], arg_count/3 );

		Tcl_AppendResult(interp, MORE_ARGS_STR, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);

		return CMD_MORE;
	}

	arg_count = argc - 7 - num_verts*3;
	if( arg_count < num_faces*3 )
	{
		struct bu_vls tmp_vls;

		bu_vls_init( &tmp_vls );
		bu_vls_printf( &tmp_vls, "%s for triangle %d : ", prompt[7+arg_count%3], arg_count/3 );

		Tcl_AppendResult(interp, MORE_ARGS_STR, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);

		return CMD_MORE;
	}

	if( mode == RT_BOT_PLATE )
	{
		arg_count = argc - 7 - num_verts*3 - num_faces*3;
		if( arg_count < num_faces*2 )
		{
			struct bu_vls tmp_vls;

			bu_vls_init( &tmp_vls );
			bu_vls_printf( &tmp_vls, "%s for face %d : ", prompt[10+arg_count%2], arg_count/2 );

			Tcl_AppendResult(interp, MORE_ARGS_STR, bu_vls_addr(&tmp_vls), (char *)NULL);
			bu_vls_free(&tmp_vls);

			return CMD_MORE;
		}
	}

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_BOT;
	intern->idb_meth = &rt_functab[ID_BOT];
	bot = (struct rt_bot_internal *)bu_calloc( 1, sizeof( struct rt_bot_internal ), "rt_bot_internal" );
	intern->idb_ptr = (genptr_t)bot;
	bot->magic = RT_BOT_INTERNAL_MAGIC;
	bot->num_vertices = num_verts;
	bot->num_faces = num_faces;
	bot->mode = mode;
	bot->orientation = orientation;
	bot->faces = (int *)bu_calloc( bot->num_faces * 3, sizeof( int ), "bot faces" );
	bot->vertices = (fastf_t *)bu_calloc( bot->num_vertices * 3, sizeof( fastf_t ), "bot vertices" );
	bot->thickness = (fastf_t *)NULL;
	bot->face_mode = (struct bu_bitv *)NULL;

	for( i=0 ; i<num_verts ; i++ )
	{
		bot->vertices[i*3] = atof( argv[7+i*3] );
		bot->vertices[i*3+1] = atof( argv[8+i*3] );
		bot->vertices[i*3+2] = atof( argv[9+i*3] );
	}

	arg_count = 7 + num_verts*3;
	for( i=0 ; i<num_faces ; i++ )
	{
		bot->faces[i*3] = atoi( argv[arg_count + i*3] );
		bot->faces[i*3+1] = atoi( argv[arg_count + i*3 + 1] );
		bot->faces[i*3+2] = atoi( argv[arg_count + i*3 + 2] );
	}

	if( mode == RT_BOT_PLATE )
	{
		arg_count = 7 + num_verts*3 + num_faces*3;
		bot->thickness = (fastf_t *)bu_calloc( num_faces, sizeof( fastf_t ), "bot thickness" );
		bot->face_mode = bu_bitv_new( num_faces );
		bu_bitv_clear( bot->face_mode );
		for( i=0 ; i<num_faces ; i++ )
		{
			int j;

			j = atoi( argv[arg_count + i*2] );
			if( j == 1 )
				BU_BITSET( bot->face_mode, i );
			else if( j != 0 )
			{
				Tcl_AppendResult(interp, "Invalid face mode (must be 0 or 1)\n", (char *)NULL );
				return CMD_BAD;
			}
			bot->thickness[i] = atof( argv[arg_count + i*2 + 1] );
		}
	}

	return CMD_OK;
}

/*
 *			A R B N _ I N
 */
int arbn_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt)
{
	struct rt_arbn_internal *arbn;
	int num_planes=0;
	int i;

	CHECK_DBI_NULL;

	if( argc < 4 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, prompt[argc-3], (char *)NULL);
	  return CMD_MORE;
	}

	num_planes = atoi( argv[3] );

	if( argc < num_planes * 4 + 4 ) {
		struct bu_vls tmp_vls;

		bu_vls_init( &tmp_vls );
		bu_vls_printf( &tmp_vls, "%s for plane %d : ", prompt[(argc-4)%4 + 1], 1+(argc-4)/4 );

		Tcl_AppendResult(interp, MORE_ARGS_STR, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);

		return CMD_MORE;
	}

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_ARBN;
	intern->idb_meth = &rt_functab[ID_ARBN];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof( struct rt_arbn_internal ),
					       "rt_arbn_internal" );
	arbn = (struct rt_arbn_internal *)intern->idb_ptr;
	arbn->magic = RT_ARBN_INTERNAL_MAGIC;
	arbn->neqn = num_planes;
	arbn->eqn = (plane_t *)bu_calloc( arbn->neqn, sizeof( plane_t ), "arbn planes" );
	for( i=0 ; i<arbn->neqn ; i++ ) {
		arbn->eqn[i][0] = atof( argv[4+i*4] );
		arbn->eqn[i][1] = atof( argv[4+i*4+1] );
		arbn->eqn[i][2] = atof( argv[4+i*4+2] );
		arbn->eqn[i][3] = atof( argv[4+i*4+3] );
	}

	return CMD_OK;
}

/*
 *			P I P E _ I N
 */
int
pipe_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt)
{
	register struct rt_pipe_internal *pipe;
	int i,num_points;

	CHECK_DBI_NULL;

	if( argc < 4 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, prompt[argc-3], (char *)NULL);
	  return CMD_MORE;
	}

	num_points = atoi( argv[3] );
	if( num_points < 2 )
	{
		Tcl_AppendResult(interp, "Invalid number of points (must be at least 2)\n", (char *)NULL);
		return CMD_BAD;
	}

	if( argc < 10 )
	{
		Tcl_AppendResult(interp, MORE_ARGS_STR, prompt[argc-3], (char *)NULL);
		return CMD_MORE;
	}

	if( argc < 4 + num_points*6 )
	{
		struct bu_vls tmp_vls;

		bu_vls_init( &tmp_vls );
		bu_vls_printf( &tmp_vls, "%s for point %d : ", prompt[7+(argc-10)%6], 1+(argc-4)/6 );

		Tcl_AppendResult(interp, MORE_ARGS_STR, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);

		return CMD_MORE;
	}

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_PIPE;
	intern->idb_meth = &rt_functab[ID_PIPE];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof( struct rt_pipe_internal ), "rt_pipe_internal" );
	pipe = (struct rt_pipe_internal *)intern->idb_ptr;
	pipe->pipe_magic = RT_PIPE_INTERNAL_MAGIC;
	BU_LIST_INIT( &pipe->pipe_segs_head );
	for( i=4 ; i<argc ; i+= 6 )
	{
		struct wdb_pipept *pipept;

		pipept = (struct wdb_pipept *)bu_malloc( sizeof( struct wdb_pipept ), "wdb_pipept" );
		pipept->pp_coord[0] = atof( argv[i] ) * local2base;
		pipept->pp_coord[1] = atof( argv[i+1] ) * local2base;
		pipept->pp_coord[2] = atof( argv[i+2] ) * local2base;
		pipept->pp_id = atof( argv[i+3] ) * local2base;
		pipept->pp_od = atof( argv[i+4] ) * local2base;
		pipept->pp_bendradius = atof( argv[i+5] ) * local2base;

		BU_LIST_INSERT( &pipe->pipe_segs_head, &pipept->l );
	}

	if( rt_pipe_ck(  &pipe->pipe_segs_head ) )
	{
		Tcl_AppendResult(interp, "Illegal pipe, solid not made!!\n", (char *)NULL );
		return CMD_BAD;
	}

	return CMD_OK;
}

/*
 *			A R S _ I N
 */
int
ars_in(int argc, char **argv, struct rt_db_internal *intern, char **promp)
{
	register struct rt_ars_internal	*arip;
	register int			i;
	int			total_points;
	int			cv;	/* current curve (waterline) # */
	int			axis;	/* current fastf_t in waterline */
	int			ncurves_minus_one;
	int num_pts = 0;
	int num_curves = 0;
	int vals_present, total_vals_needed;
	struct bu_vls tmp_vls;

	CHECK_DBI_NULL;

	vals_present = argc - 3;

	if (vals_present > 0) {
	    num_pts = atoi(argv[3]);
	    if (num_pts < 3 ) {
		Tcl_AppendResult(interp,
				 "points per waterline must be >= 3\n",
				 (char *)NULL);
		intern->idb_meth = &rt_functab[ID_ARS];
		return CMD_BAD;
	    }
	}

	if (vals_present > 1) {
	    num_curves = atoi(argv[4]);
	    if (num_curves < 3) {
		Tcl_AppendResult(interp, "points per waterline must be >= 3\n",
				 (char *)NULL);
		intern->idb_meth = &rt_functab[ID_ARS];
		return CMD_BAD;
	    }
	}

	if (vals_present < 5) {
	    /* for #rows, #pts/row & first point, 
	     * pre-formatted prompts exist
	     */
	  Tcl_AppendResult(interp, MORE_ARGS_STR,
			   promp[vals_present], (char *)NULL);
	  return CMD_MORE;
	}

	total_vals_needed = 2 +		/* #rows, #pts/row */
	    (ELEMENTS_PER_PT * 2) +	/* the first point, and very last */
	    (num_pts * ELEMENTS_PER_PT * (num_curves-2)); /* the curves */

	if (vals_present < (total_vals_needed - ELEMENTS_PER_PT)) {
	    /* if we're looking for points on the curves, and not 
	     * the last point which makes up the last curve, we
	     * have to format up a prompt string
	     */
	    bu_vls_init(&tmp_vls);

	    switch ((vals_present-2) % 3) {
	    case 0:
		bu_vls_printf(&tmp_vls, "%s for Waterline %d, Point %d : ",
			      promp[5],
			      1+(argc-8)/3/num_pts,
			      ((argc-8)/3)%num_pts );
		break;
	    case 1:
		bu_vls_printf(&tmp_vls, "%s for Waterline %d, Point %d : ",
			      promp[6], 
			      1+(argc-8)/3/num_pts,
			      ((argc-8)/3)%num_pts );
		break;
	    case 2:
		bu_vls_printf(&tmp_vls, "%s for Waterline %d, Point %d : ",
			      promp[7], 
			      1+(argc-8)/3/num_pts,
			      ((argc-8)/3)%num_pts );
		break;
	    }

	    Tcl_AppendResult(interp, MORE_ARGS_STR, bu_vls_addr(&tmp_vls),
			     (char *)NULL);
	    bu_vls_free(&tmp_vls);

	    return CMD_MORE;
	} else if (vals_present < total_vals_needed) {
	    /* we're looking for the last point which is used for all points
	     * on the last curve
	     */
	    bu_vls_init(&tmp_vls);


	    switch ((vals_present-2) % 3) {
	    case 0:
		bu_vls_printf(&tmp_vls, "%s for pt of last Waterline : ",
			      promp[5],
			      1+(argc-8)/3/num_pts,
			      ((argc-8)/3)%num_pts );
		break;
	    case 1:
		bu_vls_printf(&tmp_vls, "%s for pt of last Waterline : ",
			      promp[6], 
			      1+(argc-8)/3/num_pts,
			      ((argc-8)/3)%num_pts );
		break;
	    case 2:
		bu_vls_printf(&tmp_vls, "%s for pt of last Waterline : ",
			      promp[7], 
			      1+(argc-8)/3/num_pts,
			      ((argc-8)/3)%num_pts );
		break;
	    }


	    Tcl_AppendResult(interp, MORE_ARGS_STR, bu_vls_addr(&tmp_vls),
			     (char *)NULL);
	    bu_vls_free(&tmp_vls);

	    return CMD_MORE;
	}

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_ARS;
	intern->idb_meth = &rt_functab[ID_ARS];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_ars_internal), "rt_ars_internal");
	arip = (struct rt_ars_internal *)intern->idb_ptr;
	arip->magic = RT_ARS_INTERNAL_MAGIC;
	arip->pts_per_curve = num_pts;
	arip->ncurves = num_curves;
	ncurves_minus_one = arip->ncurves - 1;
	total_points = arip->ncurves * arip->pts_per_curve;

	arip->curves = (fastf_t **)bu_malloc(
		(arip->ncurves+1) * sizeof(fastf_t **), "ars curve ptrs" );
	for( i=0; i < arip->ncurves+1; i++ )  {
		/* Leave room for first point to be repeated */
		arip->curves[i] = (fastf_t *)bu_malloc(
		    (arip->pts_per_curve+1) * sizeof(point_t),
		    "ars curve" );
	}

	/* fill in the point of the first row */
	arip->curves[0][0] = atof(argv[5]) * local2base;
	arip->curves[0][1] = atof(argv[6]) * local2base;
	arip->curves[0][2] = atof(argv[7]) * local2base;

	/* The first point is duplicated across the first curve */
	for (i=1 ; i < arip->pts_per_curve ; ++i) {
		VMOVE( arip->curves[0]+3*i, arip->curves[0] );
	}

	cv = 1;
	axis = 0;
	/* scan each of the other points we've already got */
	for (i=8 ; i < argc && i < total_points * ELEMENTS_PER_PT ; ++i) {
		arip->curves[cv][axis] = atof(argv[i]) * local2base;
		if (++axis >= arip->pts_per_curve * ELEMENTS_PER_PT) {
			axis = 0;
			cv++;
		}
	}

	/* The first point is duplicated across the last curve */
	for (i=1 ; i < arip->pts_per_curve ; ++i) {
		VMOVE( arip->curves[ncurves_minus_one]+3*i,
			arip->curves[ncurves_minus_one] );
	}

	return CMD_OK;
}

/*   H A L F _ I N ( ) :   	reads halfspace parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
half_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
{
	vect_t norm;
	double d;

	CHECK_DBI_NULL;

	intern->idb_ptr = NULL;

	norm[X] = atof(cmd_argvs[3+0]);
	norm[Y] = atof(cmd_argvs[3+1]);
	norm[Z] = atof(cmd_argvs[3+2]);
	d = atof(cmd_argvs[3+3]) * local2base;

	if (MAGNITUDE(norm) < RT_LEN_TOL) {
	  Tcl_AppendResult(interp, "ERROR, normal vector is too small!\n", (char *)NULL);
	  return(1);	/* failure */
	}

	VUNITIZE( norm );
	if( mk_half( wdbp, name, norm, d ) < 0 )
		return 1;	/* failure */
	return 0;	/* success */
}

/*   A R B _ I N ( ) :   	reads arb parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
arb_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	int			i, j, n;
	struct rt_arb_internal	*aip;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_ARB8;
	intern->idb_meth = &rt_functab[ID_ARB8];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal),
		"rt_arb_internal" );
	aip = (struct rt_arb_internal *)intern->idb_ptr;
	aip->magic = RT_ARB_INTERNAL_MAGIC;

	n = atoi(&cmd_argvs[2][3]);	/* get # from "arb#" */
	for (j = 0; j < n; j++)
	  for (i = 0; i < ELEMENTS_PER_PT; i++)
	    aip->pt[j][i] = atof(cmd_argvs[3+i+3*j]) * local2base;

	if (!strcmp("arb4", cmd_argvs[2])) {
		VMOVE( aip->pt[7], aip->pt[3] );
		VMOVE( aip->pt[6], aip->pt[3] );
		VMOVE( aip->pt[5], aip->pt[3] );
		VMOVE( aip->pt[4], aip->pt[3] );
		VMOVE( aip->pt[3], aip->pt[0] );
	} else if (!strcmp("arb5", cmd_argvs[2])) {
		VMOVE( aip->pt[7], aip->pt[4] );
		VMOVE( aip->pt[6], aip->pt[4] );
		VMOVE( aip->pt[5], aip->pt[4] );
	} else if (!strcmp("arb6", cmd_argvs[2])) {
		VMOVE( aip->pt[7], aip->pt[5] );
		VMOVE( aip->pt[6], aip->pt[5] );
		VMOVE( aip->pt[5], aip->pt[4] );
	} else if (!strcmp("arb7", cmd_argvs[2])) {
		VMOVE( aip->pt[7], aip->pt[4] );
	}

	return(0);	/* success */
}

/*   S P H _ I N ( ) :   	reads sph parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
sph_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
{
	point_t			center;
	fastf_t			r;
	int			i;

	CHECK_DBI_NULL;

	intern->idb_ptr = NULL;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		center[i] = atof(cmd_argvs[3+i]) * local2base;
	}
	r = atof(cmd_argvs[6]) * local2base;
	
	if (r < RT_LEN_TOL) {
	  Tcl_AppendResult(interp, "ERROR, radius must be greater than zero!\n", (char *)NULL);
	  return(1);	/* failure */
	}

	if( mk_sph( wdbp, name, center, r ) < 0 )
		return 1;	/* failure */
	return 0;	/* success */
}

/*   E L L _ I N ( ) :   	reads ell parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
ell_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	fastf_t			len, mag_b, r_rev, vals[12];
	int			i, n;
	struct rt_ell_internal	*eip;

	CHECK_DBI_NULL;

	n = 12;				/* ELL has twelve params */
	if (cmd_argvs[2][3] != '\0')	/* ELLG and ELL1 have seven */
		n = 7;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_ELL;
	intern->idb_meth = &rt_functab[ID_ELL];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_ell_internal),
		"rt_ell_internal" );
	eip = (struct rt_ell_internal *)intern->idb_ptr;
	eip->magic = RT_ELL_INTERNAL_MAGIC;

	/* convert typed in args to reals */
	for (i = 0; i < n; i++) {
		vals[i] = atof(cmd_argvs[3+i]) * local2base;
	}

	if (!strcmp("ell", cmd_argvs[2])) {	/* everything's ok */
		/* V, A, B, C */
		VMOVE( eip->v, &vals[0] );
		VMOVE( eip->a, &vals[3] );
		VMOVE( eip->b, &vals[6] );
		VMOVE( eip->c, &vals[9] );
		return(0);
	}
	
	if (!strcmp("ellg", cmd_argvs[2])) {
		/* V, f1, f2, len */
		/* convert ELLG format into ELL1 format */
		len = vals[6];
		/* V is halfway between the foci */
		VADD2( eip->v, &vals[0], &vals[3] );
		VSCALE( eip->v, eip->v, 0.5);
		VSUB2( eip->b, &vals[3], &vals[0] );
		mag_b = MAGNITUDE( eip->b );
		if ( NEAR_ZERO( mag_b, RT_LEN_TOL )) {
		  Tcl_AppendResult(interp, "ERROR, foci are coincident!\n", (char *)NULL);
		  return(1);
		}
		/* calculate A vector */
		VSCALE( eip->a, eip->b, .5*len/mag_b );
		/* calculate radius of revolution (for ELL1 format) */
		r_rev = sqrt( MAGSQ( eip->a ) - (mag_b*.5)*(mag_b*.5) );
	} else if (!strcmp("ell1", cmd_argvs[2])) {
		/* V, A, r */
		VMOVE( eip->v, &vals[0] );
		VMOVE( eip->a, &vals[3] );
		r_rev = vals[6];
	} else {
		r_rev = 0;
	}
	
	/* convert ELL1 format into ELLG format */
	/* calculate B vector */
	bn_vec_ortho( eip->b, eip->a );
	VUNITIZE( eip->b );
	VSCALE( eip->b, eip->b, r_rev);

	/* calculate C vector */
	VCROSS( eip->c, eip->a, eip->b );
	VUNITIZE( eip->c );
	VSCALE( eip->c, eip->c, r_rev );
	return(0);	/* success */
}

/*   T O R _ I N ( ) :   	reads tor parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
tor_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	int			i;
	struct rt_tor_internal	*tip;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_TOR;
	intern->idb_meth = &rt_functab[ID_TOR];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tor_internal),
		"rt_tor_internal" );
	tip = (struct rt_tor_internal *)intern->idb_ptr;
	tip->magic = RT_TOR_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		tip->v[i] = atof(cmd_argvs[3+i]) * local2base;
		tip->h[i] = atof(cmd_argvs[6+i]) * local2base;
	}
	tip->r_a = atof(cmd_argvs[9]) * local2base;
	tip->r_h = atof(cmd_argvs[10]) * local2base;
	/* Check for radius 2 >= radius 1 */
	if( tip->r_a <= tip->r_h )  {
	  Tcl_AppendResult(interp, "ERROR, radius 2 >= radius 1 ....\n", (char *)NULL);
	  return(1);	/* failure */
	}
	
	if (MAGNITUDE( tip->h ) < RT_LEN_TOL) {
	  Tcl_AppendResult(interp, "ERROR, normal must be greater than zero!\n", (char *)NULL);
	  return(1);	/* failure */
	}
	
	return(0);	/* success */
}

/*   T G C _ I N ( ) :   	reads tgc parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
tgc_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	fastf_t			r1, r2;
	int			i;
	struct rt_tgc_internal	*tip;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_TGC;
	intern->idb_meth = &rt_functab[ID_TGC];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal),
		"rt_tgc_internal" );
	tip = (struct rt_tgc_internal *)intern->idb_ptr;
	tip->magic = RT_TGC_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		tip->v[i] = atof(cmd_argvs[3+i]) * local2base;
		tip->h[i] = atof(cmd_argvs[6+i]) * local2base;
		tip->a[i] = atof(cmd_argvs[9+i]) * local2base;
		tip->b[i] = atof(cmd_argvs[12+i]) * local2base;
	}
	r1 = atof(cmd_argvs[15]) * local2base;
	r2 = atof(cmd_argvs[16]) * local2base;
	
	if (MAGNITUDE(tip->h) < RT_LEN_TOL
		|| MAGNITUDE(tip->a) < RT_LEN_TOL
		|| MAGNITUDE(tip->b) < RT_LEN_TOL
		|| r1 < RT_LEN_TOL || r2 < RT_LEN_TOL) {
	  Tcl_AppendResult(interp, "ERROR, all dimensions must be greater than zero!\n",
			   (char *)NULL);
	  return(1);	/* failure */
	}

	/* calculate C */
	VMOVE( tip->c, tip->a );
	VUNITIZE( tip->c );
	VSCALE( tip->c, tip->c, r1);

	/* calculate D */
	VMOVE( tip->d, tip->b );
	VUNITIZE( tip->d );
	VSCALE( tip->d, tip->d, r2);
	
	return(0);	/* success */
}

/*   R C C _ I N ( ) :   	reads rcc parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
rcc_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	fastf_t			r;
	int			i;
	struct rt_tgc_internal	*tip;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_TGC;
	intern->idb_meth = &rt_functab[ID_TGC];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal),
		"rt_tgc_internal" );
	tip = (struct rt_tgc_internal *)intern->idb_ptr;
	tip->magic = RT_TGC_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		tip->v[i] = atof(cmd_argvs[3+i]) * local2base;
		tip->h[i] = atof(cmd_argvs[6+i]) * local2base;
	}
	r = atof(cmd_argvs[9]) * local2base;
	
	if (MAGNITUDE(tip->h) < RT_LEN_TOL || r < RT_LEN_TOL) {
	  Tcl_AppendResult(interp, "ERROR, all dimensions must be greater than zero!\n",
			   (char *)NULL);
	  return(1);	/* failure */
	}

	bn_vec_ortho( tip->a, tip->h );
	VUNITIZE( tip->a );
	VCROSS( tip->b, tip->h, tip->a );
	VUNITIZE( tip->b );

	VSCALE( tip->a, tip->a, r );
	VSCALE( tip->b, tip->b, r );
	VMOVE( tip->c, tip->a );
	VMOVE( tip->d, tip->b );
	
	return(0);	/* success */
}

/*   T E C _ I N ( ) :   	reads tec parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
tec_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	fastf_t			ratio;
	int			i;
	struct rt_tgc_internal	*tip;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_TGC;
	intern->idb_meth = &rt_functab[ID_TGC];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal),
		"rt_tgc_internal" );
	tip = (struct rt_tgc_internal *)intern->idb_ptr;
	tip->magic = RT_TGC_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		tip->v[i] = atof(cmd_argvs[3+i]) * local2base;
		tip->h[i] = atof(cmd_argvs[6+i]) * local2base;
		tip->a[i] = atof(cmd_argvs[9+i]) * local2base;
		tip->b[i] = atof(cmd_argvs[12+i]) * local2base;
	}
	ratio = atof(cmd_argvs[15]);
	if (MAGNITUDE(tip->h) < RT_LEN_TOL
		|| MAGNITUDE(tip->a) < RT_LEN_TOL
		|| MAGNITUDE(tip->b) < RT_LEN_TOL
		|| ratio < RT_LEN_TOL) {
	  Tcl_AppendResult(interp, "ERROR, all dimensions must be greater than zero!\n",
			   (char *)NULL);
	  return(1);	/* failure */
	}

	VSCALE( tip->c, tip->a, 1./ratio );	/* C vector */
	VSCALE( tip->d, tip->b, 1./ratio );	/* D vector */
	
	return(0);	/* success */
}

/*   R E C _ I N ( ) :   	reads rec parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
rec_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	int			i;
	struct rt_tgc_internal	*tip;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_TGC;
	intern->idb_meth = &rt_functab[ID_TGC];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal),
		"rt_tgc_internal" );
	tip = (struct rt_tgc_internal *)intern->idb_ptr;
	tip->magic = RT_TGC_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		tip->v[i] = atof(cmd_argvs[3+i]) * local2base;
		tip->h[i] = atof(cmd_argvs[6+i]) * local2base;
		tip->a[i] = atof(cmd_argvs[9+i]) * local2base;
		tip->b[i] = atof(cmd_argvs[12+i]) * local2base;
	}
	
	if (MAGNITUDE(tip->h) < RT_LEN_TOL
		|| MAGNITUDE(tip->a) < RT_LEN_TOL
		|| MAGNITUDE(tip->b) < RT_LEN_TOL ) {
	  Tcl_AppendResult(interp, "ERROR, all dimensions must be greater than zero!\n",
			   (char *)NULL);
	  return(1);	/* failure */
	}

	VMOVE( tip->c, tip->a );		/* C vector */
	VMOVE( tip->d, tip->b );		/* D vector */
	
	return(0);	/* success */
}

/*   T R C _ I N ( ) :   	reads trc parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
trc_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	fastf_t			r1, r2;
	int			i;
	struct rt_tgc_internal	*tip;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_TGC;
	intern->idb_meth = &rt_functab[ID_TGC];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal),
		"rt_tgc_internal" );
	tip = (struct rt_tgc_internal *)intern->idb_ptr;
	tip->magic = RT_TGC_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		tip->v[i] = atof(cmd_argvs[3+i]) * local2base;
		tip->h[i] = atof(cmd_argvs[6+i]) * local2base;
	}
	r1 = atof(cmd_argvs[9]) * local2base;
	r2 = atof(cmd_argvs[10]) * local2base;
	
	if (MAGNITUDE(tip->h) < RT_LEN_TOL
		|| r1 < RT_LEN_TOL || r2 < RT_LEN_TOL) {
	  Tcl_AppendResult(interp, "ERROR, all dimensions must be greater than zero!\n",
			   (char *)NULL);
	  return(1);	/* failure */
	}

	bn_vec_ortho( tip->a, tip->h );
	VUNITIZE( tip->a );
	VCROSS( tip->b, tip->h, tip->a );
	VUNITIZE( tip->b );
	VMOVE( tip->c, tip->a );
	VMOVE( tip->d, tip->b );

	VSCALE( tip->a, tip->a, r1 );
	VSCALE( tip->b, tip->b, r1 );
	VSCALE( tip->c, tip->c, r2 );
	VSCALE( tip->d, tip->d, r2 );
	
	return(0);	/* success */
}

/*   B O X _ I N ( ) :   	reads box parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
box_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	int			i;
	struct rt_arb_internal	*aip;
	vect_t			Dpth, Hgt, Vrtx, Wdth;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_ARB8;
	intern->idb_meth = &rt_functab[ID_ARB8];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal),
		"rt_arb_internal" );
	aip = (struct rt_arb_internal *)intern->idb_ptr;
	aip->magic = RT_ARB_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		Vrtx[i] = atof(cmd_argvs[3+i]) * local2base;
		Hgt[i] = atof(cmd_argvs[6+i]) * local2base;
		Wdth[i] = atof(cmd_argvs[9+i]) * local2base;
		Dpth[i] = atof(cmd_argvs[12+i]) * local2base;
	}
	
	if (MAGNITUDE(Dpth) < RT_LEN_TOL || MAGNITUDE(Hgt) < RT_LEN_TOL
		|| MAGNITUDE(Wdth) < RT_LEN_TOL) {
	  Tcl_AppendResult(interp, "ERROR, all dimensions must be greater than zero!\n",
			   (char *)NULL);
	  return(1);	/* failure */
	}

	if (!strcmp("box", cmd_argvs[2])) {
		VMOVE( aip->pt[0], Vrtx );
		VADD2( aip->pt[1], Vrtx, Wdth );
		VADD3( aip->pt[2], Vrtx, Wdth, Hgt );
		VADD2( aip->pt[3], Vrtx, Hgt );
		VADD2( aip->pt[4], Vrtx, Dpth );
		VADD3( aip->pt[5], Vrtx, Dpth, Wdth );
		VADD4( aip->pt[6], Vrtx, Dpth, Wdth, Hgt );
		VADD3( aip->pt[7], Vrtx, Dpth, Hgt );
	} else { /* "raw" */
		VADD2( aip->pt[0], Vrtx, Wdth );
		VADD2( aip->pt[1], Vrtx, Hgt );
		VADD2( aip->pt[2], aip->pt[1], Dpth );
		VADD2( aip->pt[3], aip->pt[0], Dpth );
		VMOVE( aip->pt[4], Vrtx );
		VMOVE( aip->pt[5], Vrtx );
		VADD2( aip->pt[6], Vrtx, Dpth );
		VMOVE( aip->pt[7], aip->pt[6] );
	}

	return(0);	/* success */
}

/*   R P P _ I N ( ) :   	reads rpp parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
rpp_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
{
	point_t		min, max;

	CHECK_DBI_NULL;

	intern->idb_ptr = NULL;

	min[X] = atof(cmd_argvs[3+0]) * local2base;
	max[X] = atof(cmd_argvs[3+1]) * local2base;
	min[Y] = atof(cmd_argvs[3+2]) * local2base;
	max[Y] = atof(cmd_argvs[3+3]) * local2base;
	min[Z] = atof(cmd_argvs[3+4]) * local2base;
	max[Z] = atof(cmd_argvs[3+5]) * local2base;

	if (min[X] >= max[X]) {
	  Tcl_AppendResult(interp, "ERROR, XMIN greater than XMAX!\n", (char *)NULL);
	  return(1);	/* failure */
	}
	if (min[Y] >= max[Y]) {
	  Tcl_AppendResult(interp, "ERROR, YMIN greater than YMAX!\n", (char *)NULL);
	  return(1);	/* failure */
	}
	if (min[Z] >= max[Z]) {
	  Tcl_AppendResult(interp, "ERROR, ZMIN greater than ZMAX!\n", (char *)NULL);
	  return(1);	/* failure */
	}

	if( mk_rpp( wdbp, name, min, max ) < 0 )
		return 1;
	return 0;	/* success */
}

/*
 *			O R P P _ I N ( )
 *
 * Reads origin-min rpp (box) parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
orpp_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
{
	point_t		min, max;

	CHECK_DBI_NULL;

	intern->idb_ptr = NULL;

	VSETALL( min, 0 );
	max[X] = atof(cmd_argvs[3+0]) * local2base;
	max[Y] = atof(cmd_argvs[3+1]) * local2base;
	max[Z] = atof(cmd_argvs[3+2]) * local2base;

	if (min[X] >= max[X]) {
	  Tcl_AppendResult(interp, "ERROR, XMIN greater than XMAX!\n", (char *)NULL);
	  return(1);	/* failure */
	}
	if (min[Y] >= max[Y]) {
	  Tcl_AppendResult(interp, "ERROR, YMIN greater than YMAX!\n", (char *)NULL);
	  return(1);	/* failure */
	}
	if (min[Z] >= max[Z]) {
	  Tcl_AppendResult(interp, "ERROR, ZMIN greater than ZMAX!\n", (char *)NULL);
	  return(1);	/* failure */
	}

	if( mk_rpp( wdbp, name, min, max ) < 0 )
		return 1;
	return 0;	/* success */
}

/*   P A R T _ I N ( ) :	reads particle parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
part_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	int			i;
	struct rt_part_internal *part_ip;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_PARTICLE;
	intern->idb_meth = &rt_functab[ID_PARTICLE];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_part_internal),
		"rt_part_internal" );
	part_ip = (struct rt_part_internal *)intern->idb_ptr;
	part_ip->part_magic = RT_PART_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		part_ip->part_V[i] = atof(cmd_argvs[3+i]) * local2base;
		part_ip->part_H[i] = atof(cmd_argvs[6+i]) * local2base;
	}
	part_ip->part_vrad = atof(cmd_argvs[9]) * local2base;
	part_ip->part_hrad = atof(cmd_argvs[10]) * local2base;

	if (MAGNITUDE(part_ip->part_H) < RT_LEN_TOL
		|| part_ip->part_vrad <= RT_LEN_TOL
		|| part_ip->part_hrad <= RT_LEN_TOL) {
	  Tcl_AppendResult(interp,
			   "ERROR, height, v radius and h radius must be greater than zero!\n",
			   (char *)NULL);
	  return(1);    /* failure */
	}

	return(0);      /* success */
}

/*   R P C _ I N ( ) :   	reads rpc parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
rpc_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	int			i;
	struct rt_rpc_internal	*rip;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_RPC;
	intern->idb_meth = &rt_functab[ID_RPC];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_rpc_internal),
		"rt_rpc_internal" );
	rip = (struct rt_rpc_internal *)intern->idb_ptr;
	rip->rpc_magic = RT_RPC_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		rip->rpc_V[i] = atof(cmd_argvs[3+i]) * local2base;
		rip->rpc_H[i] = atof(cmd_argvs[6+i]) * local2base;
		rip->rpc_B[i] = atof(cmd_argvs[9+i]) * local2base;
	}
	rip->rpc_r = atof(cmd_argvs[12]) * local2base;
	
	if (MAGNITUDE(rip->rpc_H) < RT_LEN_TOL
		|| MAGNITUDE(rip->rpc_B) < RT_LEN_TOL
		|| rip->rpc_r <= RT_LEN_TOL) {
	  Tcl_AppendResult(interp,
			   "ERROR, height, breadth, and width must be greater than zero!\n",
			   (char *)NULL);
	  return(1);	/* failure */
	}
	
	return(0);	/* success */
}

/*   R H C _ I N ( ) :   	reads rhc parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
rhc_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	int			i;
	struct rt_rhc_internal	*rip;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_RHC;
	intern->idb_meth = &rt_functab[ID_RHC];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_rhc_internal),
		"rt_rhc_internal" );
	rip = (struct rt_rhc_internal *)intern->idb_ptr;
	rip->rhc_magic = RT_RHC_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		rip->rhc_V[i] = atof(cmd_argvs[3+i]) * local2base;
		rip->rhc_H[i] = atof(cmd_argvs[6+i]) * local2base;
		rip->rhc_B[i] = atof(cmd_argvs[9+i]) * local2base;
	}
	rip->rhc_r = atof(cmd_argvs[12]) * local2base;
	rip->rhc_c = atof(cmd_argvs[13]) * local2base;
	
	if (MAGNITUDE(rip->rhc_H) < RT_LEN_TOL
		|| MAGNITUDE(rip->rhc_B) < RT_LEN_TOL
		|| rip->rhc_r <= RT_LEN_TOL || rip->rhc_c <= RT_LEN_TOL) {
	  Tcl_AppendResult(interp,
			   "ERROR, height, breadth, and width must be greater than zero!\n",
			   (char *)NULL);
	  return(1);	/* failure */
	}
	
	return(0);	/* success */
}

/*   E P A _ I N ( ) :   	reads epa parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
epa_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	int			i;
	struct rt_epa_internal	*rip;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_EPA;
	intern->idb_meth = &rt_functab[ID_EPA];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_epa_internal),
		"rt_epa_internal" );
	rip = (struct rt_epa_internal *)intern->idb_ptr;
	rip->epa_magic = RT_EPA_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		rip->epa_V[i] = atof(cmd_argvs[3+i]) * local2base;
		rip->epa_H[i] = atof(cmd_argvs[6+i]) * local2base;
		rip->epa_Au[i] = atof(cmd_argvs[9+i]) * local2base;
	}
	rip->epa_r1 = MAGNITUDE(rip->epa_Au);
	rip->epa_r2 = atof(cmd_argvs[12]) * local2base;
	VUNITIZE(rip->epa_Au);
	
	if (MAGNITUDE(rip->epa_H) < RT_LEN_TOL
		|| rip->epa_r1 <= RT_LEN_TOL || rip->epa_r2 <= RT_LEN_TOL) {
	  Tcl_AppendResult(interp, "ERROR, height and axes must be greater than zero!\n",
			   (char *)NULL);
	  return(1);	/* failure */
	}

	if (rip->epa_r2 > rip->epa_r1) {
	  Tcl_AppendResult(interp, "ERROR, |A| must be greater than |B|!\n", (char *)NULL);
	  return(1);	/* failure */
	}
	
	return(0);	/* success */
}

/*   E H Y _ I N ( ) :   	reads ehy parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
ehy_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	int			i;
	struct rt_ehy_internal	*rip;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_EHY;
	intern->idb_meth = &rt_functab[ID_EHY];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_ehy_internal),
		"rt_ehy_internal" );
	rip = (struct rt_ehy_internal *)intern->idb_ptr;
	rip->ehy_magic = RT_EHY_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		rip->ehy_V[i] = atof(cmd_argvs[3+i]) * local2base;
		rip->ehy_H[i] = atof(cmd_argvs[6+i]) * local2base;
		rip->ehy_Au[i] = atof(cmd_argvs[9+i]) * local2base;
	}
	rip->ehy_r1 = MAGNITUDE(rip->ehy_Au);
	rip->ehy_r2 = atof(cmd_argvs[12]) * local2base;
	rip->ehy_c = atof(cmd_argvs[13]) * local2base;
	VUNITIZE(rip->ehy_Au);
	
	if (MAGNITUDE(rip->ehy_H) < RT_LEN_TOL
		|| rip->ehy_r1 <= RT_LEN_TOL || rip->ehy_r2 <= RT_LEN_TOL
		|| rip->ehy_c <= RT_LEN_TOL) {
	  Tcl_AppendResult(interp, "ERROR, height, axes, and distance to asymptotes must be greater than zero!\n", (char *)NULL);
	  return(1);	/* failure */
	}

	if (rip->ehy_r2 > rip->ehy_r1) {
	  Tcl_AppendResult(interp, "ERROR, |A| must be greater than |B|!\n", (char *)NULL);
	  return(1);	/* failure */
	}
	
	return(0);	/* success */
}

/*   E T O _ I N ( ) :   	reads eto parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
eto_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	int			i;
	struct rt_eto_internal	*eip;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_ETO;
	intern->idb_meth = &rt_functab[ID_ETO];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_eto_internal),
		"rt_eto_internal" );
	eip = (struct rt_eto_internal *)intern->idb_ptr;
	eip->eto_magic = RT_ETO_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		eip->eto_V[i] = atof(cmd_argvs[3+i]) * local2base;
		eip->eto_N[i] = atof(cmd_argvs[6+i]) * local2base;
		eip->eto_C[i] = atof(cmd_argvs[10+i]) * local2base;
	}
	eip->eto_r = atof(cmd_argvs[9]) * local2base;
	eip->eto_rd = atof(cmd_argvs[13]) * local2base;
	
	if (MAGNITUDE(eip->eto_N) < RT_LEN_TOL
		|| MAGNITUDE(eip->eto_C) < RT_LEN_TOL
		|| eip->eto_r <= RT_LEN_TOL || eip->eto_rd <= RT_LEN_TOL) {
	  Tcl_AppendResult(interp,
			   "ERROR, normal, axes, and radii must be greater than zero!\n",
			   (char *)NULL);
	  return(1);	/* failure */
	}

	if (eip->eto_rd > MAGNITUDE(eip->eto_C)) {
	  Tcl_AppendResult(interp, "ERROR, |C| must be greater than |D|!\n", (char *)NULL);
	  return(1);	/* failure */
	}
	
	return(0);	/* success */
}

/*   E X T R U D E _ I N ( ) :   	reads extrude parameters from keyboard
 *					returns 0 if successful read
 *					1 if unsuccessful read
 */
int
extrude_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	int			i;
	struct rt_extrude_internal	*eip;
	struct rt_db_internal		tmp_ip;
	struct directory		*dp;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_EXTRUDE;
	intern->idb_meth = &rt_functab[ID_EXTRUDE];
	intern->idb_ptr = (genptr_t)bu_malloc(sizeof(struct rt_extrude_internal),
					      "rt_extrude_internal");
	eip = (struct rt_extrude_internal *)intern->idb_ptr;
	eip->magic = RT_EXTRUDE_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		eip->V[i] = atof(cmd_argvs[3+i]) * local2base;
		eip->h[i] = atof(cmd_argvs[6+i]) * local2base;
		eip->u_vec[i] = atof(cmd_argvs[9+i]) * local2base;
		eip->v_vec[i] = atof(cmd_argvs[12+i]) * local2base;
	}
	eip->sketch_name = bu_strdup(cmd_argvs[15]);
	eip->keypoint = atoi(cmd_argvs[16]);

	if ((dp=db_lookup(dbip, eip->sketch_name, LOOKUP_NOISY)) == DIR_NULL) {
		Tcl_AppendResult(interp, "Cannot find sketch (", eip->sketch_name,
				 ") for extrusion (", cmd_argvs[1], ")\n", (char *)NULL);
		eip->skt = (struct rt_sketch_internal *)NULL;
		return 1;
	}

	if (rt_db_get_internal(&tmp_ip, dp, dbip, bn_mat_identity, &rt_uniresource) != ID_SKETCH) {
		Tcl_AppendResult(interp, "Cannot import sketch (", eip->sketch_name,
				 ") for extrusion (", cmd_argvs[1], ")\n", (char *)NULL);
		eip->skt = (struct rt_sketch_internal *)NULL;
		return 1;
	} else
		eip->skt = (struct rt_sketch_internal *)tmp_ip.idb_ptr;

	return 0;	/* success */
}

/*   G R I P _ I N ( ) :   	reads grip parameters from keyboard
 *				returns 0 if successful read
 *				1 if unsuccessful read
 */
int
grip_in(char **cmd_argvs, struct rt_db_internal *intern)
{
	int			i;
	struct rt_grip_internal	*gip;

	CHECK_DBI_NULL;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_GRIP;
	intern->idb_meth = &rt_functab[ID_GRIP];
	intern->idb_ptr = (genptr_t)bu_malloc(sizeof(struct rt_grip_internal),
					      "rt_grip_internal");
	gip = (struct rt_grip_internal *)intern->idb_ptr;
	gip->magic = RT_GRIP_INTERNAL_MAGIC;

	for (i = 0; i < ELEMENTS_PER_PT; i++) {
		gip->center[i] = atof(cmd_argvs[3+i]) * local2base;
		gip->normal[i] = atof(cmd_argvs[6+i]) * local2base;
	}

	gip->mag = atof(cmd_argvs[9]);

	return 0;
}

/*   S U P E R E L L _ I N ( ) :   	reads superell parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
superell_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
{
	fastf_t			vals[14];
	int			i, n;
	struct rt_superell_internal	*eip;

	CHECK_DBI_NULL;

	n = 14;				/* SUPERELL has 12 (same as ELL) + 2 (for <n,e>) params */

	intern->idb_type = ID_SUPERELL;
	intern->idb_meth = &rt_functab[ID_SUPERELL];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_superell_internal),
		"rt_superell_internal" );
	eip = (struct rt_superell_internal *)intern->idb_ptr;
	eip->magic = RT_SUPERELL_INTERNAL_MAGIC;

	/* convert typed in args to reals and convert to local units */
	for (i = 0; i < n - 2; i++) {
		vals[i] = atof(cmd_argvs[3+i]) * local2base;
	}
	vals[12] = atof(cmd_argvs[3 + 12]);
	vals[13] = atof(cmd_argvs[3 + 13]);

	/* V, A, B, C */
	VMOVE( eip->v, &vals[0] );
	VMOVE( eip->a, &vals[3] );
	VMOVE( eip->b, &vals[6] );
	VMOVE( eip->c, &vals[9] );
	eip->n = vals[12];
	eip->e = vals[13];
	return(0);
}
@


11.64
log
@change conf.h to a wrapped config.h
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/typein.c,v 11.63 2004/04/05 09:09:12 morrison Exp $ (BRL)";
@


11.63
log
@merge of ansi-6-0-branch into HEAD
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d52 5
a56 1
#include "conf.h"
@


11.62
log
@update copyright to include span through 2003
@
text
@d30 1
d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.61 2003/07/28 18:13:50 jra Exp $ (BRL)";
d75 1
a75 1
void	aexists();
d497 17
d518 1
a518 5
f_in(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d528 7
a534 7
	int			arb_in(), box_in(), ehy_in(), ell_in(),
				epa_in(), eto_in(), half_in(), rec_in(),
				rcc_in(), rhc_in(), rpc_in(), rpp_in(), orpp_in(),
				sph_in(), tec_in(), tgc_in(), tor_in(), ars_in(),
				trc_in(), ebm_in(), vol_in(), hf_in(), bot_in(),
				dsp_in_v4(),dsp_in_v5(), submodel_in(), part_in(), pipe_in(),
				binunif_in(), arbn_in(), extrude_in(), grip_in();
d608 1
a608 1
			rec|trc|rcc|box|raw|rpp|rpc|rhc|epa|ehy|eto>
d803 4
d872 1
a872 4
binunif_in( cmd_argvs, intern, name )
char			*cmd_argvs[];
struct rt_db_internal	*intern;
const char		*name;
d935 1
a935 3
ebm_in( cmd_argvs, intern )
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d963 1
a963 3
submodel_in( cmd_argvs, intern )
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d990 1
a990 3
dsp_in_v4 ( cmd_argvs, intern )
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1026 1
a1026 3
dsp_in_v5 ( cmd_argvs, intern )
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1087 1
a1087 3
hf_in( cmd_argvs, intern )
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1151 1
a1151 3
vol_in( cmd_argvs, intern )
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1182 1
a1182 5
bot_in( argc, argv, intern, prompt )
int			argc;
char			**argv;
struct rt_db_internal	*intern;
char			*prompt[];
d1328 1
a1328 5
int arbn_in( argc, argv, intern, prompt )
int			argc;
char			**argv;
struct rt_db_internal	*intern;
char			*prompt[];
d1378 1
a1378 5
pipe_in( argc, argv, intern, prompt )
int			argc;
char			**argv;
struct rt_db_internal	*intern;
char			*prompt[];
d1451 1
a1451 5
ars_in( argc, argv, intern, promp )
int			argc;
char			**argv;
struct rt_db_internal	*intern;
char			*promp[];
d1626 1
a1626 4
half_in(cmd_argvs, intern, name)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
const char		*name;
d1656 1
a1656 3
arb_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1702 1
a1702 4
sph_in(cmd_argvs, intern, name)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
const char		*name;
d1732 1
a1732 3
ell_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1810 1
a1810 3
tor_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1850 1
a1850 3
tgc_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1902 1
a1902 3
rcc_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1948 1
a1948 3
tec_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1991 1
a1991 3
rec_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2032 1
a2032 3
trc_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2082 1
a2082 3
box_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2140 1
a2140 4
rpp_in(cmd_argvs, intern, name)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
const char		*name;
d2181 1
a2181 4
orpp_in(cmd_argvs, intern, name)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
const char		*name;
d2217 1
a2217 3
part_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2256 1
a2256 3
rpc_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2295 1
a2295 3
rhc_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2335 1
a2335 3
epa_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2379 1
a2379 3
ehy_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2424 1
a2424 3
eto_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2469 1
a2469 3
extrude_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2518 1
a2518 3
grip_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2541 41
@


11.61
log
@Forgot to initialize an rt_bot_internal structure!!!
@
text
@d44 1
a44 1
 *	This software is Copyright (C) 1985 by the United States Army.
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.60 2002/08/20 17:08:26 jra Exp $ (BRL)";
@


11.61.4.1
log
@merge from HEAD
@
text
@d44 1
a44 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.62 2004/02/02 17:39:35 morrison Exp $ (BRL)";
@


11.61.4.2
log
@merge from head
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.61.4.1 2004/02/12 18:34:16 erikg Exp $ (BRL)";
@


11.60
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.58 2001/11/09 14:19:09 jra Exp $ (BRL)";
d1274 1
a1274 1
	bot = (struct rt_bot_internal *)bu_malloc( sizeof( struct rt_bot_internal ), "rt_bot_internal" );
@


11.60.4.1
log
@sync to HEAD...
@
text
@d44 1
a44 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/typein.c,v 11.62 2004/02/02 17:39:35 morrison Exp $ (BRL)";
d1274 1
a1274 1
	bot = (struct rt_bot_internal *)bu_calloc( 1, sizeof( struct rt_bot_internal ), "rt_bot_internal" );
@


11.60.6.1
log
@updated for merging
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.61 2003/07/28 18:13:50 jra Exp $ (BRL)";
d1274 1
a1274 1
	bot = (struct rt_bot_internal *)bu_calloc( 1, sizeof( struct rt_bot_internal ), "rt_bot_internal" );
@


11.60.2.1
log
@Initial ANSIfication
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.60 2002/08/20 17:08:26 jra Exp $ (BRL)";
d74 1
a74 1
void	aexists(char *name);
d500 5
a504 1
f_in(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d514 7
a520 7
	int			arb_in(char **cmd_argvs, struct rt_db_internal *intern), box_in(char **cmd_argvs, struct rt_db_internal *intern), ehy_in(char **cmd_argvs, struct rt_db_internal *intern), ell_in(char **cmd_argvs, struct rt_db_internal *intern),
				epa_in(char **cmd_argvs, struct rt_db_internal *intern), eto_in(char **cmd_argvs, struct rt_db_internal *intern), half_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name), rec_in(char **cmd_argvs, struct rt_db_internal *intern),
				rcc_in(char **cmd_argvs, struct rt_db_internal *intern), rhc_in(char **cmd_argvs, struct rt_db_internal *intern), rpc_in(char **cmd_argvs, struct rt_db_internal *intern), rpp_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name), orpp_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name),
				sph_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name), tec_in(char **cmd_argvs, struct rt_db_internal *intern), tgc_in(char **cmd_argvs, struct rt_db_internal *intern), tor_in(char **cmd_argvs, struct rt_db_internal *intern), ars_in(int argc, char **argv, struct rt_db_internal *intern, char **promp),
				trc_in(char **cmd_argvs, struct rt_db_internal *intern), ebm_in(char **cmd_argvs, struct rt_db_internal *intern), vol_in(char **cmd_argvs, struct rt_db_internal *intern), hf_in(char **cmd_argvs, struct rt_db_internal *intern), bot_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt),
				dsp_in_v4(char **cmd_argvs, struct rt_db_internal *intern),dsp_in_v5(char **cmd_argvs, struct rt_db_internal *intern), submodel_in(char **cmd_argvs, struct rt_db_internal *intern), part_in(char **cmd_argvs, struct rt_db_internal *intern), pipe_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt),
				binunif_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name), arbn_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt), extrude_in(char **cmd_argvs, struct rt_db_internal *intern), grip_in(char **cmd_argvs, struct rt_db_internal *intern);
d854 4
a857 1
binunif_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
d920 3
a922 1
ebm_in(char **cmd_argvs, struct rt_db_internal *intern)
d950 3
a952 1
submodel_in(char **cmd_argvs, struct rt_db_internal *intern)
d979 3
a981 1
dsp_in_v4 (char **cmd_argvs, struct rt_db_internal *intern)
d1017 3
a1019 1
dsp_in_v5 (char **cmd_argvs, struct rt_db_internal *intern)
d1080 3
a1082 1
hf_in(char **cmd_argvs, struct rt_db_internal *intern)
d1146 3
a1148 1
vol_in(char **cmd_argvs, struct rt_db_internal *intern)
d1179 5
a1183 1
bot_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt)
d1329 5
a1333 1
int arbn_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt)
d1383 5
a1387 1
pipe_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt)
d1460 5
a1464 1
ars_in(int argc, char **argv, struct rt_db_internal *intern, char **promp)
d1639 4
a1642 1
half_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
d1672 3
a1674 1
arb_in(char **cmd_argvs, struct rt_db_internal *intern)
d1720 4
a1723 1
sph_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
d1753 3
a1755 1
ell_in(char **cmd_argvs, struct rt_db_internal *intern)
d1833 3
a1835 1
tor_in(char **cmd_argvs, struct rt_db_internal *intern)
d1875 3
a1877 1
tgc_in(char **cmd_argvs, struct rt_db_internal *intern)
d1929 3
a1931 1
rcc_in(char **cmd_argvs, struct rt_db_internal *intern)
d1977 3
a1979 1
tec_in(char **cmd_argvs, struct rt_db_internal *intern)
d2022 3
a2024 1
rec_in(char **cmd_argvs, struct rt_db_internal *intern)
d2065 3
a2067 1
trc_in(char **cmd_argvs, struct rt_db_internal *intern)
d2117 3
a2119 1
box_in(char **cmd_argvs, struct rt_db_internal *intern)
d2177 4
a2180 1
rpp_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
d2221 4
a2224 1
orpp_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
d2260 3
a2262 1
part_in(char **cmd_argvs, struct rt_db_internal *intern)
d2301 3
a2303 1
rpc_in(char **cmd_argvs, struct rt_db_internal *intern)
d2342 3
a2344 1
rhc_in(char **cmd_argvs, struct rt_db_internal *intern)
d2384 3
a2386 1
epa_in(char **cmd_argvs, struct rt_db_internal *intern)
d2430 3
a2432 1
ehy_in(char **cmd_argvs, struct rt_db_internal *intern)
d2477 3
a2479 1
eto_in(char **cmd_argvs, struct rt_db_internal *intern)
d2524 3
a2526 1
extrude_in(char **cmd_argvs, struct rt_db_internal *intern)
d2575 3
a2577 1
grip_in(char **cmd_argvs, struct rt_db_internal *intern)
@


11.60.2.2
log
@Added initial stubbed support for a new primitive -- a superquadric ellipsoid.  The primitive may be created in mged, but it has the same guts as the ellipsoid
@
text
@a29 1
 *	superell_in		reads params for all SUPERELLs
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.60.2.1 2002/09/19 18:02:06 morrison Exp $ (BRL)";
a495 15
char *p_superell[] = {
	"Enter X, Y, Z of superellipse vertex: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector A: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector B: ",
	"Enter Y: ",
	"Enter Z: ",
	"Enter X, Y, Z of vector C: ",
	"Enter Y: ",
	"Enter Z: "
};

d516 1
a516 1
				binunif_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name), arbn_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt), extrude_in(char **cmd_argvs, struct rt_db_internal *intern), grip_in(char **cmd_argvs, struct rt_db_internal *intern), superell_in(char **cmd_argvs, struct rt_db_internal *intern);
d590 1
a590 1
			rec|trc|rcc|box|raw|rpp|rpc|rhc|epa|ehy|eto|superell>
a784 4
	} else if( strcmp( argv[2], "superell" ) == 0 )  {
		nvals = 3*4;
		menu = p_superell;
		fn_in = superell_in;
a2518 57
}

/*   S U P E R E L L _ I N ( ) :   	reads superell parameters from keyboard
 *				returns 0 if successful read
 *					1 if unsuccessful read
 */
int
superell_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
{
	fastf_t			len, mag_b, r_rev, vals[12];
	int			i, n;
	struct rt_superell_internal	*eip;

	CHECK_DBI_NULL;

	n = 12;				/* SUPERELL has twelve params */
	if (cmd_argvs[2][3] != '\0')	/* ELLG and ELL1 have seven */
		n = 7;

	/* need to handle special params to make sph and box objects */

	intern->idb_type = ID_SUPERELL;
	intern->idb_meth = &rt_functab[ID_SUPERELL];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_superell_internal),
		"rt_superell_internal" );
	eip = (struct rt_superell_internal *)intern->idb_ptr;
	eip->magic = RT_SUPERELL_INTERNAL_MAGIC;

	/* convert typed in args to reals */
	for (i = 0; i < n; i++) {
		vals[i] = atof(cmd_argvs[3+i]) * local2base;
	}

	if (!strcmp("superell", cmd_argvs[2])) {	/* everything's ok */
		/* V, A, B, C */
		VMOVE( eip->v, &vals[0] );
		VMOVE( eip->a, &vals[3] );
		VMOVE( eip->b, &vals[6] );
		VMOVE( eip->c, &vals[9] );
		return(0);
	}
	
	r_rev = 0;
	
	/* convert ELL1 format into ELLG format */
	/* calculate B vector */
	bn_vec_ortho( eip->b, eip->a );
	VUNITIZE( eip->b );
	VSCALE( eip->b, eip->b, r_rev);

	/* calculate C vector */
	VCROSS( eip->c, eip->a, eip->b );
	VUNITIZE( eip->c );
	VSCALE( eip->c, eip->c, r_rev );
	return(0);	/* success */
@


11.60.2.3
log
@Added the superell specific options and database support for <n,e>, the north-south and east-west curvature params.
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.60.2.2 2003/01/31 00:11:55 morrison Exp $ (BRL)";
d509 1
a509 3
	"Enter Z: ",
	"Enter n, e of north-south and east-west power: ",
	"Enter e: "
d802 1
a802 1
		nvals = 3*4 + 2;
d2550 1
a2550 1
	fastf_t			vals[14];
d2556 5
a2560 1
	n = 14;				/* SUPERELL has 12 (same as ELL) + 2 (for <n,e>) params */
d2569 2
a2570 2
	/* convert typed in args to reals and convert to local units */
	for (i = 0; i < n - 2; i++) {
a2572 2
	vals[12] = atof(cmd_argvs[3 + 12]);
	vals[13] = atof(cmd_argvs[3 + 13]);
d2574 22
a2595 8
	/* V, A, B, C */
	VMOVE( eip->v, &vals[0] );
	VMOVE( eip->a, &vals[3] );
	VMOVE( eip->b, &vals[6] );
	VMOVE( eip->c, &vals[9] );
	eip->n = vals[12];
	eip->e = vals[13];
	return(0);
@


11.60.2.4
log
@sync branch with HEAD
@
text
@d45 1
a45 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d49 1
a49 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d1273 1
a1273 1
	bot = (struct rt_bot_internal *)bu_calloc( 1, sizeof( struct rt_bot_internal ), "rt_bot_internal" );
@


11.59
log
@Converted from K&R to ANSI C - RFH
@
text
@d74 1
a74 1
void	aexists(char *name);
d500 5
a504 1
f_in(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d514 7
a520 7
	int			arb_in(char **cmd_argvs, struct rt_db_internal *intern), box_in(char **cmd_argvs, struct rt_db_internal *intern), ehy_in(char **cmd_argvs, struct rt_db_internal *intern), ell_in(char **cmd_argvs, struct rt_db_internal *intern),
				epa_in(char **cmd_argvs, struct rt_db_internal *intern), eto_in(char **cmd_argvs, struct rt_db_internal *intern), half_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name), rec_in(char **cmd_argvs, struct rt_db_internal *intern),
				rcc_in(char **cmd_argvs, struct rt_db_internal *intern), rhc_in(char **cmd_argvs, struct rt_db_internal *intern), rpc_in(char **cmd_argvs, struct rt_db_internal *intern), rpp_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name), orpp_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name),
				sph_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name), tec_in(char **cmd_argvs, struct rt_db_internal *intern), tgc_in(char **cmd_argvs, struct rt_db_internal *intern), tor_in(char **cmd_argvs, struct rt_db_internal *intern), ars_in(int argc, char **argv, struct rt_db_internal *intern, char **promp),
				trc_in(char **cmd_argvs, struct rt_db_internal *intern), ebm_in(char **cmd_argvs, struct rt_db_internal *intern), vol_in(char **cmd_argvs, struct rt_db_internal *intern), hf_in(char **cmd_argvs, struct rt_db_internal *intern), bot_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt),
				dsp_in_v4(char **cmd_argvs, struct rt_db_internal *intern),dsp_in_v5(char **cmd_argvs, struct rt_db_internal *intern), submodel_in(char **cmd_argvs, struct rt_db_internal *intern), part_in(char **cmd_argvs, struct rt_db_internal *intern), pipe_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt),
				binunif_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name), arbn_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt), extrude_in(char **cmd_argvs, struct rt_db_internal *intern), grip_in(char **cmd_argvs, struct rt_db_internal *intern);
d854 4
a857 1
binunif_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
d920 3
a922 1
ebm_in(char **cmd_argvs, struct rt_db_internal *intern)
d950 3
a952 1
submodel_in(char **cmd_argvs, struct rt_db_internal *intern)
d979 3
a981 1
dsp_in_v4 (char **cmd_argvs, struct rt_db_internal *intern)
d1017 3
a1019 1
dsp_in_v5 (char **cmd_argvs, struct rt_db_internal *intern)
d1080 3
a1082 1
hf_in(char **cmd_argvs, struct rt_db_internal *intern)
d1146 3
a1148 1
vol_in(char **cmd_argvs, struct rt_db_internal *intern)
d1179 5
a1183 1
bot_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt)
d1329 5
a1333 1
int arbn_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt)
d1383 5
a1387 1
pipe_in(int argc, char **argv, struct rt_db_internal *intern, char **prompt)
d1460 5
a1464 1
ars_in(int argc, char **argv, struct rt_db_internal *intern, char **promp)
d1639 4
a1642 1
half_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
d1672 3
a1674 1
arb_in(char **cmd_argvs, struct rt_db_internal *intern)
d1720 4
a1723 1
sph_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
d1753 3
a1755 1
ell_in(char **cmd_argvs, struct rt_db_internal *intern)
d1833 3
a1835 1
tor_in(char **cmd_argvs, struct rt_db_internal *intern)
d1875 3
a1877 1
tgc_in(char **cmd_argvs, struct rt_db_internal *intern)
d1929 3
a1931 1
rcc_in(char **cmd_argvs, struct rt_db_internal *intern)
d1977 3
a1979 1
tec_in(char **cmd_argvs, struct rt_db_internal *intern)
d2022 3
a2024 1
rec_in(char **cmd_argvs, struct rt_db_internal *intern)
d2065 3
a2067 1
trc_in(char **cmd_argvs, struct rt_db_internal *intern)
d2117 3
a2119 1
box_in(char **cmd_argvs, struct rt_db_internal *intern)
d2177 4
a2180 1
rpp_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
d2221 4
a2224 1
orpp_in(char **cmd_argvs, struct rt_db_internal *intern, const char *name)
d2260 3
a2262 1
part_in(char **cmd_argvs, struct rt_db_internal *intern)
d2301 3
a2303 1
rpc_in(char **cmd_argvs, struct rt_db_internal *intern)
d2342 3
a2344 1
rhc_in(char **cmd_argvs, struct rt_db_internal *intern)
d2384 3
a2386 1
epa_in(char **cmd_argvs, struct rt_db_internal *intern)
d2430 3
a2432 1
ehy_in(char **cmd_argvs, struct rt_db_internal *intern)
d2477 3
a2479 1
eto_in(char **cmd_argvs, struct rt_db_internal *intern)
d2524 3
a2526 1
extrude_in(char **cmd_argvs, struct rt_db_internal *intern)
d2575 3
a2577 1
grip_in(char **cmd_argvs, struct rt_db_internal *intern)
@


11.58
log
@Some of the "in" functions were not using the passed in "internal" struct.
If they failed, the calling function called rt_db_free_internal() on the unused
internal and caused a dump. Now all input functions that do not use the internal struct
set internal.idb_ptr to NULL, and the caller checks this before freeing.
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.57 2001/11/02 01:02:38 butler Exp $ (BRL)";
d74 1
a74 1
void	aexists();
d500 1
a500 5
f_in(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d510 7
a516 7
	int			arb_in(), box_in(), ehy_in(), ell_in(),
				epa_in(), eto_in(), half_in(), rec_in(),
				rcc_in(), rhc_in(), rpc_in(), rpp_in(), orpp_in(),
				sph_in(), tec_in(), tgc_in(), tor_in(), ars_in(),
				trc_in(), ebm_in(), vol_in(), hf_in(), bot_in(),
				dsp_in_v4(),dsp_in_v5(), submodel_in(), part_in(), pipe_in(),
				binunif_in(), arbn_in(), extrude_in(), grip_in();
d850 1
a850 4
binunif_in( cmd_argvs, intern, name )
char			*cmd_argvs[];
struct rt_db_internal	*intern;
const char		*name;
d913 1
a913 3
ebm_in( cmd_argvs, intern )
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d941 1
a941 3
submodel_in( cmd_argvs, intern )
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d968 1
a968 3
dsp_in_v4 ( cmd_argvs, intern )
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1004 1
a1004 3
dsp_in_v5 ( cmd_argvs, intern )
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1065 1
a1065 3
hf_in( cmd_argvs, intern )
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1129 1
a1129 3
vol_in( cmd_argvs, intern )
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1160 1
a1160 5
bot_in( argc, argv, intern, prompt )
int			argc;
char			**argv;
struct rt_db_internal	*intern;
char			*prompt[];
d1306 1
a1306 5
int arbn_in( argc, argv, intern, prompt )
int			argc;
char			**argv;
struct rt_db_internal	*intern;
char			*prompt[];
d1356 1
a1356 5
pipe_in( argc, argv, intern, prompt )
int			argc;
char			**argv;
struct rt_db_internal	*intern;
char			*prompt[];
d1429 1
a1429 5
ars_in( argc, argv, intern, promp )
int			argc;
char			**argv;
struct rt_db_internal	*intern;
char			*promp[];
d1604 1
a1604 4
half_in(cmd_argvs, intern, name)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
const char		*name;
d1634 1
a1634 3
arb_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1680 1
a1680 4
sph_in(cmd_argvs, intern, name)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
const char		*name;
d1710 1
a1710 3
ell_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1788 1
a1788 3
tor_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1828 1
a1828 3
tgc_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1880 1
a1880 3
rcc_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1926 1
a1926 3
tec_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d1969 1
a1969 3
rec_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2010 1
a2010 3
trc_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2060 1
a2060 3
box_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2118 1
a2118 4
rpp_in(cmd_argvs, intern, name)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
const char		*name;
d2159 1
a2159 4
orpp_in(cmd_argvs, intern, name)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
const char		*name;
d2195 1
a2195 3
part_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2234 1
a2234 3
rpc_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2273 1
a2273 3
rhc_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2313 1
a2313 3
epa_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2357 1
a2357 3
ehy_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2402 1
a2402 3
eto_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2447 1
a2447 3
extrude_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
d2496 1
a2496 3
grip_in(cmd_argvs, intern)
char			*cmd_argvs[];
struct rt_db_internal	*intern;
@


11.57
log
@changes to make DSP get/put work
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.56 2001/10/10 22:05:04 bparker Exp $ (BRL)";
d811 6
a816 1
	  rt_db_free_internal( &internal, &rt_uniresource );
d863 2
a910 2
	intern->idb_ptr = NULL;

d1649 2
d1731 2
d2186 2
d2229 2
@


11.56
log
@Added support for grip and extrude to the "in" command (i.e. f_in).
Also return more appropriate messages for unsupported primitives.
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.55 2001/10/05 18:56:32 butler Exp $ (BRL)";
d1038 1
a1038 1
	switch ( *cmd_argvs[8] == 'a' ) {
d1049 4
a1052 1
	
@


11.55
log
@Fixed typein for ARS
@
text
@d29 1
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.54 2001/10/05 18:50:00 jra Exp $ (BRL)";
d467 29
d520 1
a520 1
				binunif_in(), arbn_in();
d631 13
a643 3
		nvals = 19;
		menu = p_hf;
		fn_in = hf_in;
d771 26
a796 5
		nvals = 2;
		menu = p_binunif;
		fn_in = binunif_in;
		do_solid_edit = 0;
		dont_draw = 1;
d2503 82
@


11.54
log
@Added support for ARBN in the "in" command
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.53 2001/10/05 15:40:23 jra Exp $ (BRL)";
d196 2
a197 2
	"Enter Y: ",
	"Enter Z: ",
a1362 5

	if( argc != 4 + num_points*6 ) {
		return CMD_BAD;
	}

d1403 4
a1406 1
	int num_pts, num_curves;
d1408 1
d1410 1
a1410 1
	CHECK_DBI_NULL;
d1412 9
a1420 3
	if( argc < 5 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, promp[argc-3], (char *)NULL);
	  return CMD_MORE;
d1423 8
a1430 6
	num_pts = atoi(argv[3]);
	num_curves = atoi(argv[4]);

	if (num_pts < 3 || num_curves < 3 ) {
	  Tcl_AppendResult(interp, "Invalid number of lines or pts_per_curve\n", (char *)NULL);
	  return CMD_BAD;
d1433 6
a1438 2
	if( argc < 8 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, promp[argc-3], (char *)NULL);
d1442 69
a1510 7
#if 0
	if( argc < 8+((num_curves-2)*num_pts*3) ) {
		bu_log("%s for Waterline %d, Point %d : ",
			promp[5+(argc-8)%3], 1+(argc-8)/3/num_pts, ((argc-8)/3)%
			num_pts );
		return CMD_MORE;
	}
d1512 1
a1512 4
	if( argc < 8+((num_curves-2)*num_pts*3+3)) {
		bu_log("%s for point of last waterline : ",
			promp[5+(argc-8)%3]);
		return CMD_MORE;
a1513 20
#else
	if( argc < 5+3*(num_curves-1)*num_pts ) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "%s for Waterline %d, Point %d : ",
			promp[5+(argc-8)%3], 1+(argc-8)/3/num_pts, ((argc-8)/3)%num_pts );

	  Tcl_AppendResult(interp, MORE_ARGS_STR, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);

	  return CMD_MORE;
	}

	if( argc < 5+3*num_curves*num_pts ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, promp[5+(argc-8)%3],
			   " for point of last waterline : ", (char *)NULL);
	  return CMD_MORE;
	}
#endif
@


11.53
log
@Improved arg checking slightly for pipe_in()
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.52 2001/10/02 19:24:32 jra Exp $ (BRL)";
d168 8
d490 1
a490 1
				binunif_in();
d570 11
d1252 53
@


11.52
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.51 2001/08/11 13:16:11 butler Exp $ (BRL)";
d1291 5
@


11.51
log
@misc compiler warning changes
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.50 2001/08/02 20:07:09 jra Exp $ (BRL)";
d844 1
d874 1
d901 1
d939 1
d1001 1
d1067 1
d1183 1
d1284 1
d1388 1
d1483 1
d1567 1
d1642 1
d1685 1
d1739 1
d1787 1
d1831 1
d1875 1
d1927 1
d2065 1
d2106 1
d2147 1
d2189 1
d2235 1
d2282 1
@


11.50
log
@Added support for binunif in "in" command
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.49 2001/06/01 19:23:25 bparker Exp $ (BRL)";
d101 1
d591 1
a591 1
			nvals = 7;
d954 14
d971 1
a971 1
		atof( cmd_argvs[8] ) * local2base;
d973 1
a973 1
	dsp->dsp_stom[10] = atof( cmd_argvs[9] ) * local2base;
@


11.49
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.48 2001/03/31 01:57:24 morrison Exp $ (BRL)";
d452 5
d480 2
a481 1
				dsp_in_v4(),dsp_in_v5(), submodel_in(), part_in(), pipe_in();
d710 6
d765 61
@


11.48
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.47 2001/03/23 22:35:57 butler Exp $ (BRL)";
d71 1
d743 1
a743 1
	(void)f_edit( clientData, interp, 2, new_cmd );
@


11.47
log
@Changes to support new DSP primitive representation
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /n/tgm/d/CVS/brlcad/mged/typein.c,v 11.46 2001/03/23 22:05:36 jra Exp $ (BRL)";
d778 1
a778 1
	bn_mat_idn( ebm->mat );
d835 1
a835 1
	bn_mat_idn( dsp->dsp_stom );
d879 1
a879 1
	bn_mat_idn( dsp->dsp_stom );
d987 1
a987 1
	bn_mat_idn( vol->mat );
@


11.46
log
@Support for major and minor types in directory structure
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/typein.c,v 11.45 2001/03/21 22:37:42 jra Exp $ (BRL)";
d84 1
a84 1
char *p_dsp[] = {
d93 11
d474 1
a474 1
				dsp_in(), submodel_in(), part_in(), pipe_in();
d557 2
a558 1
		  Tcl_AppendResult(interp, "ERROR, BOT not made!\n", (char *)NULL);
d578 10
a587 3
		nvals = 6;
		menu = p_dsp;
		fn_in = dsp_in;
d817 1
a817 1
dsp_in ( cmd_argvs, intern )
d829 2
a830 2
	bu_vls_init( &dsp->dsp_file );
	bu_vls_strcpy( &dsp->dsp_file, cmd_argvs[3] );
d841 44
@


11.45
log
@Submodel now has unlimited length names
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/typein.c,v 11.44 2001/02/13 22:48:36 bparker Exp $ (BRL)";
d705 1
a705 1
		if( (dp=db_diradd( dbip, name, -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )  {
@


11.44
log
@*- move radius of revolution before vector C
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.43 2001/01/30 13:16:18 jra Exp $ (BRL)";
d784 2
a785 1
	strcpy( sip->treetop, cmd_argvs[3] );
d787 2
a788 1
	strcpy( sip->file, cmd_argvs[5] );
@


11.43
log
@Changed prompt for ETO semi-minor axis
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.42 2001/01/29 21:04:12 jra Exp $ (BRL)";
d433 1
a436 1
	"Enter radius of revolution, r: ",
d2115 1
a2115 1
		eip->eto_C[i] = atof(cmd_argvs[9+i]) * local2base;
d2117 1
a2117 1
	eip->eto_r = atof(cmd_argvs[12]) * local2base;
@


11.42
log
@"in" command now correctly distinguishes "ell", "ell1", and "ellg"
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.41 2000/10/24 19:55:21 mike Exp $ (BRL)";
d437 1
a437 1
	"Enter elliptical semi-minor axis, d: "
@


11.41
log
@possible uninit
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.40 2000/09/08 05:55:49 mike Exp $ (BRL)";
d216 1
a216 1
char *p_ell[] = {
d236 1
a236 1
char *p_ellg[] = {
d611 1
a611 1
	} else if( strcmp( argv[2], "ell" ) == 0 )  {
d613 1
a613 1
		menu = p_ell;
d615 1
a615 1
	} else if( strcmp( argv[2], "ellg" ) == 0 )  {
d617 1
a617 1
		menu = p_ellg;
d1399 3
a1401 3
	n = 7;				/* ELL and ELL1 have seven params */
	if (cmd_argvs[2][3] == 'g')	/* ELLG has twelve */
		n = 12;
d1415 1
a1415 1
	if (!strcmp("ellg", cmd_argvs[2])) {	/* everything's ok */
d1424 1
a1424 1
	if (!strcmp("ell", cmd_argvs[2])) {
d1426 1
a1426 1
		/* convert ELL format into ELL1 format */
@


11.40
log
@
Tree routines now need resource structure.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.39 2000/08/19 03:10:17 mike Exp $ (BRL)";
d1446 2
@


11.39
log
@
Reduced use of MAXARGS
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.38 2000/07/24 22:22:12 mike Exp $ (BRL)";
d547 1
a547 1
		  rt_db_free_internal( &internal );
d573 1
a573 1
		  rt_db_free_internal( &internal );
d583 1
a583 1
		  rt_db_free_internal( &internal );
d698 1
a698 1
	  rt_db_free_internal( &internal );
d706 1
a706 1
			rt_db_free_internal( &internal );
d710 1
a710 1
		if( rt_db_put_internal( dp, dbip, &internal ) < 0 )
d712 1
a712 1
			rt_db_free_internal( &internal );
@


11.38
log
@
More new-libwdb-related cleanups
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.37 2000/07/24 19:27:31 mike Exp $ (BRL)";
d451 1
a451 1
	char			name[NAMESIZE+2];
d467 1
a467 1
	if(argc < 1 || MAXARGS < argc){
d515 1
a515 1
	if( (int)strlen(argv[1]) >= NAMESIZE )  {
d519 1
a519 1
	  bu_vls_printf(&tmp_vls, "ERROR, names are limited to %d characters\n", NAMESIZE-1);
d523 2
a524 2
	/* Save the solid name since argv[] might get bashed */
	strcpy( name, argv[1] );
@


11.37
log
@
Changed mged/typin.c to start using libwdb interfaces.
Which means mged/ged.c now also opens a libwdb interface.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.36 2000/06/30 19:54:07 mike Exp $ (BRL)";
d1280 1
a1280 1
half_in(cmd_argvs, intern)
d1283 1
d1285 2
a1286 2
	int			i;
	struct rt_half_internal	*hip;
d1290 4
a1293 6
	intern->idb_type = ID_HALF;
	intern->idb_meth = &rt_functab[ID_HALF];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_half_internal),
		"rt_half_internal" );
	hip = (struct rt_half_internal *)intern->idb_ptr;
	hip->magic = RT_HALF_INTERNAL_MAGIC;
d1295 1
a1295 6
	for (i = 0; i < ELEMENTS_PER_PLANE; i++) {
		hip->eqn[i] = atof(cmd_argvs[3+i]) * local2base;
	}
	VUNITIZE( hip->eqn );
	
	if (MAGNITUDE(hip->eqn) < RT_LEN_TOL) {
d1299 5
a1303 2
	
	return(0);	/* success */
@


11.36
log
@
ft_ifree replaced
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.35 2000/06/29 14:55:38 butler Exp $ (BRL)";
d355 6
d460 2
a461 2
				rcc_in(), rhc_in(), rpc_in(), rpp_in(),
				sph_in(), tec_in(), tgc_in(), tor_in(),
d653 1
a653 1
		nvals = 6*1;
d656 4
d696 1
a696 1
	if (fn_in(argv, &internal, menu) != 0)  {
d703 12
a714 10
	if( (dp=db_diradd( dbip, name, -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )
	{
		rt_db_free_internal( &internal );
		Tcl_AppendResult(interp, "Cannot add '", name, "' to directory\n", (char *)NULL );
		return TCL_ERROR;
	}
	if( rt_db_put_internal( dp, dbip, &internal ) < 0 )
	{
		rt_db_free_internal( &internal );
		TCL_WRITE_ERR_return;
d1361 1
a1361 1
sph_in(cmd_argvs, intern)
d1364 1
d1366 1
a1368 1
	struct rt_ell_internal	*sip;
a1371 7
	intern->idb_type = ID_ELL;
	intern->idb_meth = &rt_functab[ID_ELL];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_ell_internal),
		"rt_ell_internal" );
	sip = (struct rt_ell_internal *)intern->idb_ptr;
	sip->magic = RT_ELL_INTERNAL_MAGIC;

d1373 1
a1373 1
		sip->v[i] = atof(cmd_argvs[3+i]) * local2base;
a1375 3
	VSET( sip->a, r, 0., 0. );
	VSET( sip->b, 0., r, 0. );
	VSET( sip->c, 0., 0., r );
d1381 4
a1384 2
	
	return(0);	/* success */
d1806 1
a1806 1
rpp_in(cmd_argvs, intern)
d1809 1
d1811 1
a1811 2
	fastf_t			xmin, xmax, ymin, ymax, zmin, zmax;
	struct rt_arb_internal	*aip;
d1815 41
a1855 6
	intern->idb_type = ID_ARB8;
	intern->idb_meth = &rt_functab[ID_ARB8];
	intern->idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal),
		"rt_arb_internal" );
	aip = (struct rt_arb_internal *)intern->idb_ptr;
	aip->magic = RT_ARB_INTERNAL_MAGIC;
d1857 4
a1860 6
	xmin = atof(cmd_argvs[3+0]) * local2base;
	xmax = atof(cmd_argvs[3+1]) * local2base;
	ymin = atof(cmd_argvs[3+2]) * local2base;
	ymax = atof(cmd_argvs[3+3]) * local2base;
	zmin = atof(cmd_argvs[3+4]) * local2base;
	zmax = atof(cmd_argvs[3+5]) * local2base;
d1862 1
a1862 1
	if (xmin >= xmax) {
d1866 1
a1866 1
	if (ymin >= ymax) {
d1870 1
a1870 1
	if (zmin >= zmax) {
d1875 3
a1877 10
	VSET( aip->pt[0], xmax, ymin, zmin );
	VSET( aip->pt[1], xmax, ymax, zmin );
	VSET( aip->pt[2], xmax, ymax, zmax );
	VSET( aip->pt[3], xmax, ymin, zmax );
	VSET( aip->pt[4], xmin, ymin, zmin );
	VSET( aip->pt[5], xmin, ymax, zmin );
	VSET( aip->pt[6], xmin, ymax, zmax );
	VSET( aip->pt[7], xmin, ymin, zmax );

	return(0);	/* success */
@


11.35
log
@Updates to DSP code
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.34 2000/02/14 04:42:39 butler Exp $ (BRL)";
d541 1
a541 2
		  if(internal.idb_type) rt_functab[internal.idb_type].
					  ft_ifree( &internal );
d567 1
a567 2
		  if(internal.idb_type) rt_functab[internal.idb_type].
					  ft_ifree( &internal );
d577 1
a577 2
		  if(internal.idb_type) rt_functab[internal.idb_type].
					  ft_ifree( &internal );
d688 1
a688 2
	  if(internal.idb_type) rt_functab[internal.idb_type].
				  ft_ifree( &internal );
@


11.34
log
@Changes to support more arguments to the DSP
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.33 1999/12/30 19:36:43 jra Exp $ (BRL)";
d800 3
a802 1
	strcpy( dsp->dsp_file, cmd_argvs[3] );
@


11.34.2.1
log
@"in" command now correctly distinghishes "ell", :ell1", and "ellg"
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.34 2000/02/14 04:42:39 butler Exp $ (BRL)";
d216 1
a216 1
char *p_ellg[] = {
d236 1
a236 1
char *p_ell[] = {
d608 1
a608 1
	} else if( strcmp( argv[2], "ellg" ) == 0 )  {
d610 1
a610 1
		menu = p_ellg;
d612 1
a612 1
	} else if( strcmp( argv[2], "ell" ) == 0 )  {
d614 1
a614 1
		menu = p_ell;
d1399 3
a1401 3
	n = 12;				/* ELL has twelve params */
	if (cmd_argvs[2][3] != '\0')	/* ELLG and ELL1 have seven */
		n = 7;
d1415 1
a1415 1
	if (!strcmp("ell", cmd_argvs[2])) {	/* everything's ok */
d1424 1
a1424 1
	if (!strcmp("ellg", cmd_argvs[2])) {
a1445 2
	} else {
		r_rev = 0;
@


11.34.2.2
log
@changes ETO prompt for semi-minor axis
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.34.2.1 2001/01/29 21:20:16 jra Exp $ (BRL)";
d431 1
a431 1
	"Enter magnitude of elliptical semi-minor axis, d: "
@


11.34.2.3
log
@*- Move radius of revolution before vector C
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.34.2.2 2001/01/30 13:17:20 jra Exp $ (BRL)";
a426 1
	"Enter radius of revolution, r: ",
d430 1
d2089 1
a2089 1
		eip->eto_C[i] = atof(cmd_argvs[10+i]) * local2base;
d2091 1
a2091 1
	eip->eto_r = atof(cmd_argvs[9]) * local2base;
@


11.33
log
@Eliminated some unused variables
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.32 1999/12/29 23:23:26 mike Exp $ (BRL)";
d88 3
a90 1
	"Normal Interpolation? 0=no 1=yes default=1: "
d561 1
a561 1
		nvals = 4;
a803 1
	bn_mat_idn( dsp->dsp_mtos );
d805 7
@


11.32
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.31 1999/11/26 19:42:58 jra Exp $ (BRL)";
a444 1
	struct bu_external	external;
a445 2
	int			ngran;		/* number of db granules */
	int			id;
a820 1
	vect_t work;
@


11.31
log
@Added support for BOT solid
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.30 1999/11/24 14:26:42 jra Exp $ (BRL)";
d698 1
a698 1
	if( (dp=db_diradd( dbip, name, -1L, 0, DIR_SOLID)) == DIR_NULL )
@


11.30
log
@All solid/combination creation  routines needed values assigned to idb_meth
in the rt_db_internal struct
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.29 1999/11/17 18:42:27 jra Exp $ (BRL)";
d138 15
d457 1
a457 1
				trc_in(), ebm_in(), vol_in(), hf_in(),
d538 11
d911 150
@


11.29
log
@Removed extra definition of rt_submodel_internal
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.28 1999/09/01 18:55:11 bparker Exp $ (BRL)";
d718 1
d747 1
d771 1
d804 1
d869 1
d934 1
d1037 1
d1100 1
d1134 1
d1182 1
d1224 1
d1296 1
d1338 1
d1391 1
d1438 1
d1481 1
d1524 1
d1575 1
d1633 1
d1686 1
d1726 1
d1766 1
d1807 1
d1852 1
d1898 1
@


11.28
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.27 1999/03/30 16:17:50 jra Exp $ (BRL)";
a728 15

/* parameters for solid, internal representation
 * XXX This goes in rtgeom.h
 */
/* parameters for solid, internal representation */
struct rt_submodel_internal {
	long	magic;
	char	file[128];	/* .g filename, 0-len --> this database. */
	char	treetop[128];	/* one treetop only */
	int	meth;		/* space partitioning method */
	/* other option flags (lazy prep, etc.)?? */
	/* REMAINING ELEMENTS PROVIDED BY IMPORT, UNUSED BY EXPORT */
	mat_t	root2leaf;
};
#define RT_SUBMODEL_INTERNAL_MAGIC	0x7375626d	/* subm */
@


11.27
log
@Added pipe solid to the "in" command.
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.26 1999/02/05 18:47:33 bparker Exp $ (BRL)";
d445 1
a445 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d714 1
a714 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d757 1
a757 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d812 1
a812 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d876 1
a876 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d910 1
a910 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d991 1
a991 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1105 1
a1105 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1138 1
a1138 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1185 1
a1185 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1222 1
a1222 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1297 1
a1297 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1338 1
a1338 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1390 1
a1390 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1436 1
a1436 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1478 1
a1478 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1520 1
a1520 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1570 1
a1570 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1627 1
a1627 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1679 1
a1679 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1718 1
a1718 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1757 1
a1757 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1797 1
a1797 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1841 1
a1841 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1886 1
a1886 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
@


11.26
log
@*- add support for particle solid to f_in()
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.25 1998/06/29 15:28:43 bparker Exp $ (BRL)";
d67 2
d138 16
d443 1
a443 1
				dsp_in(), submodel_in(), part_in();
d540 11
d900 76
@


11.25
log
@*- mods to f_in() to check the range for type arb
@
text
@d28 1
d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/typein.c,v 11.24 1998/04/03 01:42:26 mike Exp $ (BRL)";
d333 11
d425 1
a425 1
				dsp_in(), submodel_in();
d620 4
d1579 40
@


11.24
log
@Added support for submodel
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.23 1998/01/06 18:52:23 bparker Exp mike $ (BRL)";
d526 11
a536 1
		nvals = 3*atoi(&argv[2][3]);
@


11.23
log
@fix f_in()'s error message
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.22 1997/08/22 22:38:22 mike Exp bparker $ (BRL)";
d117 6
d413 1
a413 1
				dsp_in();
d494 4
d673 42
@


11.22
log
@Made use of bu_getopt() explicit, rather than depending on
#define in bu.h
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.21 1997/07/01 22:09:08 bparker Exp mike $ (BRL)";
d424 1
d438 1
a438 1
		    bu_vls_printf(&tmp_vls, "in: option '%c' unknown\n", c);
@


11.21
log
@mods to run without a database
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.20 1997/05/22 09:29:07 butler Exp bparker $ (BRL)";
d423 2
a424 2
	optind = 1;		/* re-init getopt() */
	while( (c=getopt(argc,argv,"sf")) != EOF )  {
d445 2
a446 2
	argc -= optind-1;
	argv += optind-1;
@


11.20
log
@added support for dsp solid
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.19 1997/04/24 18:03:58 bparker Exp butler $ (BRL)";
d83 3
a85 2
	"Enter width of displacement-map (number of cells): ",
	"Enter length of displacement-map (number of cells): "
d409 3
d496 1
a496 1
		nvals = 3;
d649 3
d685 1
d707 3
d772 3
d810 2
d813 2
a814 1
	int num_pts, num_curves;
d928 3
d962 3
d1010 3
d1048 3
d1124 3
d1166 3
d1219 3
d1266 3
d1309 3
d1352 3
d1403 3
d1461 3
d1514 3
d1554 3
d1595 3
d1640 3
d1685 3
@


11.19
log
@modify calls to Tcl_Eval
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.18 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d81 6
d405 2
a406 1
				trc_in(), ebm_in(), vol_in(), hf_in();
d491 4
d658 27
@


11.18
log
@mods so that commands check args internally
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.17 1997/04/04 20:05:46 bparker Exp bparker $ (BRL)";
d402 6
a407 1
	  Tcl_Eval(interp, "help in");
@


11.17
log
@mods to f_in to handle parameters in local units instead of mm
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.16 1997/03/20 23:03:05 bparker Exp bparker $ (BRL)";
d401 2
a402 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d404 1
@


11.16
log
@added type cast to please sun4
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.15 1997/03/20 14:07:31 bparker Exp bparker $ (BRL)";
d89 1
a89 1
	"Enter coordinates to position HF solid (mm): ",
d98 2
a99 2
	"Enter length of HF in 'x' direction (mm): ",
	"Enter width of HF in 'y' direction (mm): ",
d107 1
a107 1
	"Enter extrusion distance (mm): "
d117 3
a119 3
	"Enter X, Y, Z dimensions of a cell (mm)",
	"Enter Y dimension of a cell (mm)",
	"Enter Z dimension of a cell (mm)",
d635 1
a635 1
	ebm->tallness = atof( cmd_argvs[6] );
d667 3
a669 3
	hf->v[0] = atof( cmd_argvs[10] );
	hf->v[1] = atof( cmd_argvs[11] );
	hf->v[2] = atof( cmd_argvs[12] );
d676 2
a677 2
	hf->xlen = atof( cmd_argvs[19] );
	hf->ylen = atof( cmd_argvs[20] );
d727 3
a729 3
	vol->cellsize[0] = atof( cmd_argvs[9] );
	vol->cellsize[1] = atof( cmd_argvs[10] );
	vol->cellsize[2] = atof( cmd_argvs[11] );
d825 3
a827 3
	arip->curves[0][0] = atof(argv[5]);
	arip->curves[0][1] = atof(argv[6]);
	arip->curves[0][2] = atof(argv[7]);
d838 1
a838 1
		arip->curves[cv][axis] = atof(argv[i]);
d873 1
a873 1
		hip->eqn[i] = atof(cmd_argvs[3+i]);
d905 2
a906 2
		for (i = 0; i < ELEMENTS_PER_PT; i++)
			aip->pt[j][i] = atof(cmd_argvs[3+i+3*j]);
d949 1
a949 1
		sip->v[i] = atof(cmd_argvs[3+i]);
d951 1
a951 1
	r = atof(cmd_argvs[6]);
d989 1
a989 1
		vals[i] = atof(cmd_argvs[3+i]);
d1057 2
a1058 2
		tip->v[i] = atof(cmd_argvs[3+i]);
		tip->h[i] = atof(cmd_argvs[6+i]);
d1060 2
a1061 2
	tip->r_a = atof(cmd_argvs[9]);
	tip->r_h = atof(cmd_argvs[10]);
d1096 4
a1099 4
		tip->v[i] = atof(cmd_argvs[3+i]);
		tip->h[i] = atof(cmd_argvs[6+i]);
		tip->a[i] = atof(cmd_argvs[9+i]);
		tip->b[i] = atof(cmd_argvs[12+i]);
d1101 2
a1102 2
	r1 = atof(cmd_argvs[15]);
	r2 = atof(cmd_argvs[16]);
d1146 2
a1147 2
		tip->v[i] = atof(cmd_argvs[3+i]);
		tip->h[i] = atof(cmd_argvs[6+i]);
d1149 1
a1149 1
	r = atof(cmd_argvs[9]);
d1190 4
a1193 4
		tip->v[i] = atof(cmd_argvs[3+i]);
		tip->h[i] = atof(cmd_argvs[6+i]);
		tip->a[i] = atof(cmd_argvs[9+i]);
		tip->b[i] = atof(cmd_argvs[12+i]);
d1230 4
a1233 4
		tip->v[i] = atof(cmd_argvs[3+i]);
		tip->h[i] = atof(cmd_argvs[6+i]);
		tip->a[i] = atof(cmd_argvs[9+i]);
		tip->b[i] = atof(cmd_argvs[12+i]);
d1270 2
a1271 2
		tip->v[i] = atof(cmd_argvs[3+i]);
		tip->h[i] = atof(cmd_argvs[6+i]);
d1273 2
a1274 2
	r1 = atof(cmd_argvs[9]);
	r2 = atof(cmd_argvs[10]);
d1318 4
a1321 4
		Vrtx[i] = atof(cmd_argvs[3+i]);
		Hgt[i] = atof(cmd_argvs[6+i]);
		Wdth[i] = atof(cmd_argvs[9+i]);
		Dpth[i] = atof(cmd_argvs[12+i]);
d1372 6
a1377 6
	xmin = atof(cmd_argvs[3+0]);
	xmax = atof(cmd_argvs[3+1]);
	ymin = atof(cmd_argvs[3+2]);
	ymax = atof(cmd_argvs[3+3]);
	zmin = atof(cmd_argvs[3+4]);
	zmax = atof(cmd_argvs[3+5]);
d1423 3
a1425 3
		rip->rpc_V[i] = atof(cmd_argvs[3+i]);
		rip->rpc_H[i] = atof(cmd_argvs[6+i]);
		rip->rpc_B[i] = atof(cmd_argvs[9+i]);
d1427 1
a1427 1
	rip->rpc_r = atof(cmd_argvs[12]);
d1460 3
a1462 3
		rip->rhc_V[i] = atof(cmd_argvs[3+i]);
		rip->rhc_H[i] = atof(cmd_argvs[6+i]);
		rip->rhc_B[i] = atof(cmd_argvs[9+i]);
d1464 2
a1465 2
	rip->rhc_r = atof(cmd_argvs[12]);
	rip->rhc_c = atof(cmd_argvs[13]);
d1498 3
a1500 3
		rip->epa_V[i] = atof(cmd_argvs[3+i]);
		rip->epa_H[i] = atof(cmd_argvs[6+i]);
		rip->epa_Au[i] = atof(cmd_argvs[9+i]);
d1503 1
a1503 1
	rip->epa_r2 = atof(cmd_argvs[12]);
d1540 3
a1542 3
		rip->ehy_V[i] = atof(cmd_argvs[3+i]);
		rip->ehy_H[i] = atof(cmd_argvs[6+i]);
		rip->ehy_Au[i] = atof(cmd_argvs[9+i]);
d1545 2
a1546 2
	rip->ehy_r2 = atof(cmd_argvs[12]);
	rip->ehy_c = atof(cmd_argvs[13]);
d1583 3
a1585 3
		eip->eto_V[i] = atof(cmd_argvs[3+i]);
		eip->eto_N[i] = atof(cmd_argvs[6+i]);
		eip->eto_C[i] = atof(cmd_argvs[9+i]);
d1587 2
a1588 2
	eip->eto_r = atof(cmd_argvs[12]);
	eip->eto_rd = atof(cmd_argvs[13]);
@


11.15
log
@fixed typo
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.14 1997/02/28 21:46:29 jra Exp bparker $ (BRL)";
d629 1
a629 1
	intern->idb_ptr = ebm;
d718 1
a718 1
	intern->idb_ptr = vol;
@


11.14
log
@removed include of db.h
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.13 1997/02/28 19:29:48 jra Exp jra $ (BRL)";
d82 1
a82 1
	"Enter name of control file (or '""' for none): ",
@


11.13
log
@eliminated use of "union record".
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.12 1997/01/02 19:35:05 bparker Exp jra $ (BRL)";
a63 1
#include "db.h"
@


11.12
log
@mods to use libbn and libbu
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.11 1996/10/03 20:28:03 bparker Exp bparker $ (BRL)";
d82 41
d400 1
a400 1
				trc_in();
d467 3
a469 8
		switch( strsol_in( &external, "ebm", argc, argv ) ) {
		case CMD_BAD:
		  Tcl_AppendResult(interp, "ERROR, EBM solid not made!\n", (char *)NULL);
		  return TCL_ERROR;
		case CMD_MORE:
		  return TCL_ERROR;
		}
		goto do_extern_update;
d471 3
a473 8
		switch( strsol_in( &external, "vol", argc, argv ) )  {
		case CMD_BAD:
		  Tcl_AppendResult(interp, "ERROR, VOL solid not made!\n", (char *)NULL);
		  return TCL_ERROR;
		case CMD_MORE:
		  return TCL_ERROR;
		}
		goto do_extern_update;
d475 3
a477 8
		switch( strsol_in( &external, "hf", argc, argv ) )  {
		case CMD_BAD:
		  Tcl_AppendResult(interp, "ERROR, HF solid not made!\n", (char *)NULL);
		  return TCL_ERROR;
		case CMD_MORE:
		  return TCL_ERROR;
		}
		goto do_extern_update;
d586 9
a594 18
	RT_CK_DB_INTERNAL( &internal );
	id = internal.idb_type;
	if( rt_functab[id].ft_export( &external, &internal, local2base ) < 0 )  {
	  Tcl_AppendResult(interp, "export failure\n", (char *)NULL);
	  rt_functab[id].ft_ifree( &internal );
	  return TCL_ERROR;
	}
	rt_functab[id].ft_ifree( &internal );	/* free internal rep */

do_extern_update:
	ngran = (external.ext_nbytes+sizeof(union record)-1) / sizeof(union record);
	if ((dp=db_diradd(dbip, name, -1L, ngran, DIR_SOLID)) == DIR_NULL ||
	     db_alloc(dbip, dp, ngran ) < 0) {
		db_free_external( &external );
	    	TCL_ALLOC_ERR_return;
	}
	if (db_put_external( &external, dp, dbip ) < 0 )  {
		db_free_external( &external );
a596 1
	db_free_external( &external );
d616 29
a644 2
/*
 *			S T R S O L _ I N
a645 2
 *  Read string solid info from keyboard
 *  "in" name ebm|vol arg(s)
d648 3
a650 5
strsol_in( ep, sol, argc, argv )
struct bu_external	*ep;
char			*sol;
int 			 argc;
char 		       **argv;
d652 2
a653 2
	struct bu_vls	str;
	union record	*rec;
d655 45
a699 4
	/* Read at least one "arg(s)" */
	if( argc < 3+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, sol, " Arg? ", (char *)NULL);
	  return CMD_MORE;
d702 2
a703 4
	BU_INIT_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record)*DB_SS_NGRAN;
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "ebm external");
	rec = (union record *)ep->ext_buf;
d705 11
a715 2
	bu_vls_init( &str );
	bu_vls_from_argv( &str, argc-3, &argv[3] );
d717 15
a731 4
	rec->ss.ss_id = DBID_STRSOL;
	strncpy( rec->ss.ss_keyword, sol, NAMESIZE-1 );
	strncpy( rec->ss.ss_args, bu_vls_addr(&str), DB_SS_LEN-1 );
	bu_vls_free( &str );
d733 1
a733 1
	return CMD_OK;		/* OK */
@


11.11
log
@remove calls to signal with f_in
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.10 1996/09/23 18:18:05 bparker Exp bparker $ (BRL)";
d347 1
a347 1
	struct rt_external	external;
d608 1
a608 1
struct rt_external	*ep;
d622 1
a622 1
	RT_INIT_EXTERNAL(ep);
d930 1
a930 1
	vec_ortho( eip->b, eip->a );
d1060 1
a1060 1
	vec_ortho( tip->a, tip->h );
d1186 1
a1186 1
	vec_ortho( tip->a, tip->h );
@


11.10
log
@changed dm.h to mged_dm.h
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.9 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
a389 2
	(void)signal( SIGINT, sig2);    /* allow interupts */

a569 3
	/* don't allow interrupts while we update the database! */
	(void)signal( SIGINT, SIG_IGN);

@


11.9
log
@rt_list ---> bu_list
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.8 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d68 1
a68 1
#include "./dm.h"
@


11.8
log
@now using libbu
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.7 1996/08/26 18:12:43 bparker Exp bparker $ (BRL)";
d62 1
@


11.7
log
@fixed return value in f_in()
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.6 1996/05/17 12:36:44 bparker Exp bparker $ (BRL)";
d375 1
a375 1
		    struct rt_vls tmp_vls;
d377 4
a380 4
		    rt_vls_init(&tmp_vls);
		    rt_vls_printf(&tmp_vls, "in: option '%c' unknown\n", c);
		    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		    rt_vls_free(&tmp_vls);
d403 1
a403 1
	  struct rt_vls tmp_vls;
d405 3
a407 3
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "ERROR, names are limited to %d characters\n", NAMESIZE-1);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
d617 1
a617 1
	struct rt_vls	str;
d628 1
a628 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "ebm external");
d631 2
a632 2
	RT_VLS_INIT( &str );
	rt_vls_from_argv( &str, argc-3, &argv[3] );
d636 2
a637 2
	strncpy( rec->ss.ss_args, rt_vls_addr(&str), DB_SS_LEN-1 );
	rt_vls_free( &str );
d681 1
a681 1
		rt_log("%s for Waterline %d, Point %d : ",
d688 1
a688 1
		rt_log("%s for point of last waterline : ",
d694 1
a694 1
	  struct rt_vls tmp_vls;
d696 2
a697 2
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "%s for Waterline %d, Point %d : ",
d700 2
a701 2
	  Tcl_AppendResult(interp, MORE_ARGS_STR, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d714 1
a714 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_ars_internal), "rt_ars_internal");
d722 1
a722 1
	arip->curves = (fastf_t **)rt_malloc(
d726 1
a726 1
		arip->curves[i] = (fastf_t *)rt_malloc(
d774 1
a774 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_half_internal),
d805 1
a805 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_arb_internal),
d850 1
a850 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_ell_internal),
d889 1
a889 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_ell_internal),
d958 1
a958 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_tor_internal),
d997 1
a997 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_tgc_internal),
d1047 1
a1047 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_tgc_internal),
d1091 1
a1091 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_tgc_internal),
d1131 1
a1131 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_tgc_internal),
d1171 1
a1171 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_tgc_internal),
d1219 1
a1219 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_arb_internal),
d1274 1
a1274 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_arb_internal),
d1324 1
a1324 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_rpc_internal),
d1361 1
a1361 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_rhc_internal),
d1399 1
a1399 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_epa_internal),
d1441 1
a1441 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_ehy_internal),
d1484 1
a1484 1
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_eto_internal),
@


11.6
log
@*** empty log message ***
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.5 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d586 1
a586 1
	if( dont_draw )  return CMD_OK;
@


11.5
log
@convert commands to Tcl
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.4 1996/04/03 22:06:58 bparker Exp bparker $ (BRL)";
d663 1
a663 1
	  return TCL_ERROR;
d671 1
a671 1
	  return TCL_ERROR;
d676 1
a676 1
	  return TCL_ERROR;
d703 1
a703 1
	  return TCL_ERROR;
d709 1
a709 1
	  return TCL_ERROR;
@


11.4
log
@changed ars_in so that it works in CMD_MORE mode
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.3 1996/03/01 19:26:50 bparker Exp bparker $ (BRL)";
d337 3
a339 1
f_in(argc, argv)
d360 3
d374 10
a383 2
			rt_log("in: option '%c' unknown\n", c);
			break;
d395 2
a396 2
		rt_log("Enter name of solid: ");
		return CMD_MORE;
d399 2
a400 2
		aexists( argv[1] );
		return CMD_BAD;
d403 6
a408 2
		rt_log("ERROR, names are limited to %d characters\n", NAMESIZE-1);
		return CMD_BAD;
d415 2
a416 2
		rt_log("Enter solid type: ");
		return CMD_MORE;
d429 2
a430 2
			rt_log("ERROR, EBM solid not made!\n");
			return CMD_BAD;
d432 1
a432 1
			return CMD_MORE;
d438 2
a439 2
			rt_log("ERROR, VOL solid not made!\n");
			return CMD_BAD;
d441 1
a441 1
			return CMD_MORE;
d447 2
a448 2
			rt_log("ERROR, HF solid not made!\n");
			return CMD_BAD;
d450 1
a450 1
			return CMD_MORE;
d456 4
a459 4
			rt_log("ERROR, ars not made!\n");
			if(internal.idb_type) rt_functab[internal.idb_type].
				ft_ifree( &internal );
			return CMD_BAD;
d461 1
a461 1
			return CMD_MORE;
d542 3
a544 2
		rt_log("f_in:  %s is not a known primitive\n", argv[2]);
		return CMD_BAD;
d549 2
a550 2
		rt_log("%s", menu[argc-3]);
		return CMD_MORE;
d554 4
a557 4
		rt_log("ERROR, %s not made!\n", argv[2]);
		if(internal.idb_type) rt_functab[internal.idb_type].
			ft_ifree( &internal );
		return CMD_BAD;
d564 3
a566 3
		rt_log("export failure\n");
		rt_functab[id].ft_ifree( &internal );
		return CMD_BAD;
d578 1
a578 2
	    	ALLOC_ERR;
		return CMD_BAD;
d582 1
a582 2
		WRITE_ERR;
		return CMD_BAD;
d592 1
a592 1
	(void)f_edit( 2, new_cmd );
d599 1
a599 1
		(void)f_sed( 2, new_cmd );
d601 1
a601 1
	return CMD_OK;
d622 2
a623 2
		rt_log("%s Arg? ", sol);
		return CMD_MORE;
d662 2
a663 2
		rt_log("%s", promp[argc-3]);
		return CMD_MORE;
d670 2
a671 2
	    	rt_log("Invalid number of lines or pts_per_curve\n");
		return CMD_BAD;
d675 2
a676 2
		rt_log("%s", promp[argc-3]);
		return CMD_MORE;
d694 10
a703 4
		rt_log("%s for Waterline %d, Point %d : ",
			promp[5+(argc-8)%3], 1+(argc-8)/3/num_pts, ((argc-8)/3)%
			num_pts );
		return CMD_MORE;
d707 3
a709 3
		rt_log("%s for point of last waterline : ",
			promp[5+(argc-8)%3]);
		return CMD_MORE;
d785 2
a786 2
		rt_log("ERROR, normal vector is too small!\n");
		return(1);	/* failure */
d864 2
a865 2
		rt_log("ERROR, radius must be greater than zero!\n");
		return(1);	/* failure */
d918 2
a919 2
			rt_log( "ERROR, foci are coincident!\n");
			return(1);
d971 2
a972 2
		rt_log("ERROR, radius 2 >= radius 1 ....\n");
		return(1);	/* failure */
d976 2
a977 2
		rt_log("ERROR, normal must be greater than zero!\n");
		return(1);	/* failure */
d1015 3
a1017 2
		rt_log("ERROR, all dimensions must be greater than zero!\n");
		return(1);	/* failure */
d1059 3
a1061 2
		rt_log("ERROR, all dimensions must be greater than zero!\n");
		return(1);	/* failure */
d1107 3
a1109 2
		rt_log("ERROR, all dimensions must be greater than zero!\n");
		return(1);	/* failure */
d1146 3
a1148 2
		rt_log("ERROR, all dimensions must be greater than zero!\n");
		return(1);	/* failure */
d1185 3
a1187 2
		rt_log("ERROR, all dimensions must be greater than zero!\n");
		return(1);	/* failure */
d1233 3
a1235 2
		rt_log("ERROR, dimensions must all be greater than zero!\n");
		return(1);	/* failure */
d1287 2
a1288 2
		rt_log("ERROR, XMIN greater than XMAX!\n");
		return(1);	/* failure */
d1291 2
a1292 2
		rt_log("ERROR, YMIN greater than YMAX!\n");
		return(1);	/* failure */
d1295 2
a1296 2
		rt_log("ERROR, ZMIN greater than ZMAX!\n");
		return(1);	/* failure */
d1339 4
a1342 2
		rt_log("ERROR, height, breadth, and width must be greater than zero!\n");
		return(1);	/* failure */
d1377 4
a1380 2
		rt_log("ERROR, height, breadth, and width must be greater than zero!\n");
		return(1);	/* failure */
d1415 3
a1417 2
		rt_log("ERROR, height and axes must be greater than zero!\n");
		return(1);	/* failure */
d1421 2
a1422 2
		rt_log("ERROR, |A| must be greater than |B|!\n");
		return(1);	/* failure */
d1459 2
a1460 2
		rt_log("ERROR, height, axes, and distance to asymptotes must be greater than zero!\n");
		return(1);	/* failure */
d1464 2
a1465 2
		rt_log("ERROR, |A| must be greater than |B|!\n");
		return(1);	/* failure */
d1500 4
a1503 2
		rt_log("ERROR, normal, axes, and radii must be greater than zero!\n");
		return(1);	/* failure */
d1507 2
a1508 2
		rt_log("ERROR, |C| must be greater than |D|!\n");
		return(1);	/* failure */
@


11.3
log
@remove unused XMGED stuff
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 11.2 1995/01/17 13:05:14 bparker Exp bparker $ (BRL)";
d663 1
d676 14
@


11.2
log
@merging xmged sources
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/typein.c,v 11.2 95/01/17 11:44:38 bparker Exp $ (BRL)";
a375 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint);	/* allow interrupts */
#else
a376 1
#endif
@


11.1
log
@Release_4.4
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 10.15 94/12/27 14:18:00 jra Exp $ (BRL)";
d376 5
a380 1
	(void)signal( SIGINT, sig2);	/* allow interrupts */
@


10.15
log
@Fixed typein for "raw".
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 10.14 94/12/16 19:37:30 gdurf Exp Locker: jra $ (BRL)";
@


10.14
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 10.13 1994/11/15 15:39:53 mike Exp gdurf $ (BRL)";
d1205 8
a1212 8
		VMOVE( aip->pt[0], Vrtx );
		VADD2( aip->pt[1], Vrtx, Wdth );
		VADD2( aip->pt[3], Vrtx, Hgt );	/* next lines fliped for 4d uopt bug */
		VMOVE( aip->pt[2], aip->pt[1] );
		VADD2( aip->pt[4], Vrtx, Dpth );
		VADD3( aip->pt[5], Vrtx, Dpth, Wdth );
		VMOVE( aip->pt[6], aip->pt[5] );
		VADD3( aip->pt[7], Vrtx, Dpth, Hgt );
@


10.13
log
@Added -s and -f args to IN command.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 10.12 94/11/10 12:06:16 jra Exp Locker: mike $ (BRL)";
d369 1
a369 1
			printf("in: option '%c' unknown\n", c);
d382 1
a382 1
		(void)printf("Enter name of solid: ");
d390 1
a390 1
		(void)printf("ERROR, names are limited to %d characters\n", NAMESIZE-1);
d398 1
a398 1
		(void)printf("Enter solid type: ");
d412 1
a412 1
			(void)printf("ERROR, EBM solid not made!\n");
d421 1
a421 1
			(void)printf("ERROR, VOL solid not made!\n");
d430 1
a430 1
			(void)printf("ERROR, HF solid not made!\n");
d439 1
a439 1
			(void)printf("ERROR, ars not made!\n");
d525 1
a525 1
		(void)printf("f_in:  %s is not a known primitive\n", argv[2]);
d531 1
a531 1
		(void)printf("%s", menu[argc-3]);
d536 1
a536 1
		(void)printf("ERROR, %s not made!\n", argv[2]);
d546 1
a546 1
		printf("export failure\n");
d606 1
a606 1
		(void)printf("%s Arg? ", sol);
d646 1
a646 1
		(void)printf("%s", promp[argc-3]);
d654 1
a654 1
	    	printf("Invalid number of lines or pts_per_curve\n");
d659 1
a659 1
		(void)printf("%s", promp[argc-3]);
d664 1
a664 1
		(void)printf("%s for Waterline %d, Point %d : ",
d671 1
a671 1
		(void)printf("%s for point of last waterline : ",
d748 1
a748 1
		(void)printf("ERROR, normal vector is too small!\n");
d827 1
a827 1
		(void)printf("ERROR, radius must be greater than zero!\n");
d881 1
a881 1
			fprintf(stderr, "ERROR, foci are coincident!\n");
d934 1
a934 1
		(void)printf("ERROR, radius 2 >= radius 1 ....\n");
d939 1
a939 1
		(void)printf("ERROR, normal must be greater than zero!\n");
d978 1
a978 1
		(void)printf("ERROR, all dimensions must be greater than zero!\n");
d1021 1
a1021 1
		(void)printf("ERROR, all dimensions must be greater than zero!\n");
d1068 1
a1068 1
		(void)printf("ERROR, all dimensions must be greater than zero!\n");
d1106 1
a1106 1
		(void)printf("ERROR, all dimensions must be greater than zero!\n");
d1144 1
a1144 1
		(void)printf("ERROR, all dimensions must be greater than zero!\n");
d1191 1
a1191 1
		(void)printf("ERROR, dimensions must all be greater than zero!\n");
d1244 1
a1244 1
		(void)printf("ERROR, XMIN greater than XMAX!\n");
d1248 1
a1248 1
		(void)printf("ERROR, YMIN greater than YMAX!\n");
d1252 1
a1252 1
		(void)printf("ERROR, ZMIN greater than ZMAX!\n");
d1296 1
a1296 1
		(void)printf("ERROR, height, breadth, and width must be greater than zero!\n");
d1332 1
a1332 1
		(void)printf("ERROR, height, breadth, and width must be greater than zero!\n");
d1368 1
a1368 1
		(void)printf("ERROR, height and axes must be greater than zero!\n");
d1373 1
a1373 1
		(void)printf("ERROR, |A| must be greater than |B|!\n");
d1411 1
a1411 1
		(void)printf("ERROR, height, axes, and distance to asymptotes must be greater than zero!\n");
d1416 1
a1416 1
		(void)printf("ERROR, |A| must be greater than |B|!\n");
d1452 1
a1452 1
		(void)printf("ERROR, normal, axes, and radii must be greater than zero!\n");
d1457 1
a1457 1
		(void)printf("ERROR, |C| must be greater than |D|!\n");
@


10.12
log
@Irix 6.0.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/typein.c,v 10.11 1994/10/25 22:32:29 mike Exp jra $ (BRL)";
d348 3
d358 18
d570 3
a572 1
	/* draw the "made" solid */
d576 10
a585 1
	return f_edit( 2, new_cmd );
@


10.11
log
@Added height field.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 10.10 94/09/23 09:57:47 jra Exp Locker: mike $ (BRL)";
a340 1
	register int i;
a609 1
	int arg;
d732 1
a732 1
	int			argcnt, i, j, n;
a884 1
	fastf_t			r;
a974 1
	vect_t			work;
a1056 1
	vect_t			work;
a1195 1
	int			i;
a1196 1
	vect_t			Dpth, Hgt, Vrtx, Wdth;
@


10.10
log
@Fixed bug in strsol.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 10.9 94/08/11 01:31:39 gdurf Exp Locker: jra $ (BRL)";
d402 9
@


10.9
log
@Added include of externs.h
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 10.8 1994/08/09 18:45:51 gdurf Exp gdurf $ (BRL)";
d399 1
a399 1
		switch( strsol_in( &external, "vol" ) )  {
d579 1
a579 1
	strncpy( rec->ss.ss_keyword, "ebm", NAMESIZE-1 );
@


10.8
log
@Factored ifdefs
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 10.7 1994/06/13 19:04:08 gdurf Exp gdurf $ (BRL)";
d61 1
@


10.7
log
@Expunged cmd_args[], numargs, and getcmd().
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 10.6 1994/06/01 16:47:17 gdurf Exp gdurf $ (BRL)";
d49 2
d54 3
a56 1
#ifdef BSD
a57 2
#else
#include <string.h>
@


10.6
log
@Converted f_in to use new command return codes.
@
text
@a28 1
 *	getcmd		reads and parses input parameters from keyboard
d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 10.5 1992/06/23 09:53:44 mm Exp gdurf $ (BRL)";
a66 1
extern void f_quit();
a67 2
int		args;		/* total number of args available */
int		argcnt;		/* holder for number of args added later */
a68 4
int		newargs;	/* number of args from getcmd() */
extern int	numargs;	/* number of args */
extern int	maxargs;	/* size of cmd_args[] */
extern char	*cmd_args[];	/* array of pointers to args */
d334 3
a336 1
f_in()
a354 3
	/* Save the number of args loaded initially */
	args = numargs;
	argcnt = 0;
d358 1
a358 1
	while( args < 2 )  {
d360 1
a360 3
		argcnt = getcmd(args);
		/* Add any new args slurped up */
		args += argcnt;
d362 2
a363 2
	if( db_lookup( dbip,  cmd_args[1], LOOKUP_QUIET ) != DIR_NULL )  {
		aexists( cmd_args[1] );
d366 1
a366 1
	if( (int)strlen(cmd_args[1]) >= NAMESIZE )  {
d370 2
a371 2
	/* Save the solid name since cmd_args[] might get bashed */
	strcpy( name, cmd_args[1] );
d374 1
a374 1
	while( args < 3 )  {
d376 1
a376 3
		argcnt = getcmd(args);
		/* Add any new args slurped up */
		args += argcnt;
d378 3
d386 3
a388 2
	if( strcmp( cmd_args[2], "ebm" ) == 0 )  {
		if( strsol_in( &external, "ebm" ) < 0 )  {
d391 2
d395 3
a397 2
	} else if( strcmp( cmd_args[2], "vol" ) == 0 )  {
		if( strsol_in( &external, "vol" ) < 0 )  {
d400 2
d404 3
a406 2
	} else if( strcmp( cmd_args[2], "ars" ) == 0 )  {
		if (ars_in(args, cmd_args, &internal, &p_ars[0]) != 0)  {
d411 2
d415 1
a415 1
	} else if( strcmp( cmd_args[2], "half" ) == 0 )  {
d419 2
a420 2
	} else if( strncmp( cmd_args[2], "arb", 3 ) == 0 )  {
		nvals = 3*atoi(&cmd_args[2][3]);
d423 1
a423 1
	} else if( strcmp( cmd_args[2], "sph" ) == 0 )  {
d427 1
a427 1
	} else if( strcmp( cmd_args[2], "ell" ) == 0 )  {
d431 1
a431 1
	} else if( strcmp( cmd_args[2], "ellg" ) == 0 )  {
d435 1
a435 1
	} else if( strcmp( cmd_args[2], "ell1" ) == 0 )  {
d439 1
a439 1
	} else if( strcmp( cmd_args[2], "tor" ) == 0 )  {
d443 1
a443 1
	} else if( strcmp( cmd_args[2], "tgc" ) == 0 ) {
d447 1
a447 1
	} else if( strcmp( cmd_args[2], "tec" ) == 0 )  {
d451 1
a451 1
	} else if( strcmp( cmd_args[2], "rec" ) == 0 )  {
d455 1
a455 1
	} else if( strcmp( cmd_args[2], "trc" ) == 0 )  {
d459 1
a459 1
	} else if( strcmp( cmd_args[2], "rcc" ) == 0 )  {
d463 2
a464 2
	} else if( strcmp( cmd_args[2], "box" ) == 0 
		|| strcmp( cmd_args[2], "raw" ) == 0 )  {
d468 1
a468 1
	} else if( strcmp( cmd_args[2], "rpp" ) == 0 )  {
d472 1
a472 1
	} else if( strcmp( cmd_args[2], "rpc" ) == 0 )  {
d476 1
a476 1
	} else if( strcmp( cmd_args[2], "rhc" ) == 0 )  {
d480 1
a480 1
	} else if( strcmp( cmd_args[2], "epa" ) == 0 )  {
d484 1
a484 1
	} else if( strcmp( cmd_args[2], "ehy" ) == 0 )  {
d488 1
a488 1
	} else if( strcmp( cmd_args[2], "eto" ) == 0 )  {
d493 1
a493 1
		(void)printf("f_in:  %s is not a known primitive\n", cmd_args[2]);
d498 2
a499 2
	if( args < 3+nvals )  {
		(void)printf("%s", menu[args-3]);
d503 2
a504 3
	RT_INIT_DB_INTERNAL( &internal );
	if (fn_in(cmd_args, &internal, menu) != 0)  {
		(void)printf("ERROR, %s not made!\n", cmd_args[2]);
d552 1
a552 1
strsol_in( ep, sol )
d555 2
d562 1
a562 1
	while( args < (3 + 1) )  {
d564 1
a564 4
		if( (argcnt = getcmd(args)) < 0 )  {
			return(-1);	/* failure */
		}
		args += argcnt;
d573 1
a573 1
	rt_vls_from_argv( &str, args-3, &cmd_args[3] );
d580 1
a580 1
	return(0);		/* OK */
d599 28
d628 4
a631 6
	while (args < 5) {
		(void)printf("%s", promp[args-3]);
		if ((argcnt=getcmd(args)) < 0) {
			return(1);	/* failure */
		}
		args += argcnt;
d638 2
a639 7

	if ((arip->pts_per_curve = atoi(cmd_args[3])) < 3 ||
	    (arip->ncurves =  atoi(cmd_args[4])) < 3 ) {
	    	printf("Invalid number of lines or pts_per_curve\n");
		return(1);
	}
	printf("Waterlines: %d, curve points: %d\n", arip->ncurves, arip->pts_per_curve);
a640 1

d645 1
a645 1
	for( i=0; i < arip->ncurves; i++ )  {
a651 7
	while (args < 8) {
		(void)printf("%s", promp[args-3]);
		if ((argcnt=getcmd(args)) < 0) {
			return(1);	/* failure */
		}
		args += argcnt;
	}
d653 3
a655 3
	arip->curves[0][0] = atof(cmd_args[5]);
	arip->curves[0][1] = atof(cmd_args[6]);
	arip->curves[0][2] = atof(cmd_args[7]);
d665 2
a666 3
	for (i=8 ; i < args && i < total_points * ELEMENTS_PER_PT ; ++i) {

		arip->curves[cv][axis] = atof(cmd_args[i]);
a672 26
	/* go get the waterline points from the user */
	while( cv < arip->ncurves )  {
		if (cv < ncurves_minus_one)
			(void)printf("%s for Waterline %d, Point %d : ",
				promp[5+axis%3], cv, axis/3 );
		else
			(void)printf("%s for point of last waterline : ",
				promp[5+axis%3] );

		/* Get some more input */
		*cmd_args[0] = '\0';
		if ((argcnt = getcmd(1)) < 0)
			return(1);

		/* scan each of the args we've already got */
		for (i=1 ; i < argcnt+1 &&
		    cv < arip->ncurves && axis < 3*arip->pts_per_curve; i++ )  {
			arip->curves[cv][axis] = atof(cmd_args[i]);
			if (++axis >= arip->pts_per_curve * ELEMENTS_PER_PT) {
				axis = 0;
				cv++;
			}
		}
		if( cv >= ncurves_minus_one && axis >= ELEMENTS_PER_PT )  break;
	}

d678 2
a679 1
	return(0);
a1426 85
/*   C H E C K V ( ) :		checks for zero vector at cmd_args[loc]
 *				returns 0 if vector non-zero
 *				       -1 if vector is zero
 */
int
checkv( loc )
int loc;
{
	register int	i;
	vect_t	work;

	for(i=0; i<3; i++) {
		work[i] = atof(cmd_args[(loc+i)]);
	}
	if( MAGNITUDE(work) < 1e-10 ) {
		(void)printf("ERROR, zero vector ....\n");
		return(-1);	/* zero vector */
	}
	return(0);	/* vector is non-zero */
}

/*   G E T C M D ( ) :	gets keyboard input command lines, parses and
 *			saves pointers to the beginning of each element
 *			starting at cmd_args[pos] and returns:
 *				the number of args	if successful
 *						-1	if unsuccessful
 */
int
getcmd(pos)
int pos;
{
	register char *lp;
	register char *lp1;

	newargs = 0;
	/*
	 * Now we go to the last argument string read and then position
	 * ourselves at the end of the string.  This is IMPORTANT so we
	 * don't overwrite what we've already read into line[].
	 */
	lp = cmd_args[pos-1];		/* Beginning of last arg string */
	while( *lp++ != '\0' )  {	/* Get positioned at end of string */
		;
	}

	/* Read input line */
	(void)fgets( lp, MAXLINE, stdin );

	/* Check for Control-D (EOF) */
	if( feof( stdin ) )  {
		/* Control-D typed, let's hit the road */
		f_quit();
		/* NOTREACHED */
	}

	cmd_args[newargs + pos] = lp;

	if( *lp == '\n' )
		return(0);		/* NOP */

	/* In case first character is not "white space" */
	if( (*lp != ' ') && (*lp != '\t') && (*lp != '\0') )
		newargs++;		/* holds # of args */

	for( ; *lp != '\0'; lp++ )  {
		if( (*lp == ' ') || (*lp == '\t') || (*lp == '\n') )  {
			*lp = '\0';
			lp1 = lp + 1;
			if( (*lp1 != ' ') && (*lp1 != '\t') &&
			    (*lp1 != '\n') && (*lp1 != '\0') )  {
				if( (newargs + pos) >= maxargs )  {
					(void)printf("More than %d arguments, excess flushed\n", maxargs);
					cmd_args[maxargs] = (char *)0;
					return(maxargs - pos);
				}
				cmd_args[newargs + pos] = lp1;
			    	newargs++;
			}
		}
		/* Finally, a non-space char */
	}
	/* Null terminate pointer array */
	cmd_args[newargs + pos] = (char *)0;
	return(newargs);
}
@


10.5
log
@fixed arb point entry bug
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 10.4 92/03/24 16:30:11 mmark Exp $ (BRL)";
d341 1
a341 1
void
d375 1
a375 1
		return;
d379 1
a379 1
		return;
d399 1
a399 1
			return;
d405 1
a405 1
			return;
d413 1
a413 1
			return;
d495 1
a495 1
		return;
d499 1
a499 1
	while( args < 3+nvals )  {
d501 1
a501 5
		if( (argcnt = getcmd(args)) < 0 )  {
			fprintf(stderr, "in: not enough args!\n");
			return;	/* failure */
		}
		args += argcnt;
d509 1
a509 1
		return;
d518 1
a518 1
		return;
d530 2
a531 1
	    	ALLOC_ERR_return;
d535 2
a536 1
		WRITE_ERR_return;
d544 1
a544 1
	f_edit( 2, new_cmd );
@


10.4
log
@added input checking for epa, ehy, eto
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 10.3 92/03/24 14:22:45 mmark Exp Locker: mmark $ (BRL)";
d421 1
a421 1
		nvals = atoi(&cmd_args[2][3]);
@


10.3
log
@added erim solids
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 10.2 92/02/05 15:33:01 mike Exp $ (BRL)";
d1352 5
d1395 5
d1434 5
@


10.2
log
@db_put_external() handles adding the name.
@
text
@d14 5
a18 1
 *	cyl_in		reads params for all cylinders
d23 5
a29 1
 *	cvt_ged		converts typed in params to GED database format
d35 1
d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 10.1 91/10/12 06:44:23 mike Rel4_0 Locker: mike $ (BRL)";
d132 10
d148 5
a152 1
	"Enter X, Y, Z of vector B: ",
d155 1
a155 1
	"Enter X, Y, Z of vector C: ",
d158 1
a158 2
	"Enter radius of revolution: ",		/* 12 ELL1 Lookout! */
	"Enter X, Y, Z of focus point 1: ",	/* 13 ELL  Lookout! */
d161 1
a161 1
	"Enter X, Y, Z of focus point 2: ",
d163 1
a163 2
	"Enter Z: ",
	"Enter axis length L: "
d177 52
d236 8
a243 12
	"Enter X, Y, Z of vector A: ",		/*  6         REC TEC TGC */
	"Enter Y: ",				/*  7         REC TEC TGC */
	"Enter Z: ",				/*  8         REC TEC TGC */
	"Enter X, Y, Z of vector B: ",		/*  9         REC TEC TGC */
	"Enter Y: ",				/* 10         REC TEC TGC */
	"Enter Z: ",				/* 11         REC TEC TGC */
	"Enter scalar c: ",			/* 12                 TGC */
	"Enter scalar d: ",			/* 13                 TGC */
	"Enter radius: ",			/* 14 RCC                 */
	"Enter radius of base: ",		/* 15     TRC             */
	"Enter radius of top: ",		/* 16     TRC             */
	"Enter ratio: "				/* 17             TEC     */
d270 68
a345 1
	union record record;
d349 1
a349 1
	char			*new_cmd[3];
d352 6
d382 1
a382 2
	NAMEMOVE( cmd_args[1], record.s.s_name );
	strncpy( name, cmd_args[1], sizeof(name) );
a383 3
	/* Make sure to note this is a solid record */
	record.s.s_id = ID_SOLID;

d394 1
a394 1
			rec|trc|rcc|box|raw|rpp>
d396 1
a396 153
	if( strcmp( cmd_args[2], "half" ) == 0 )  {
		record.s.s_type = HALFSPACE;
		record.s.s_cgtype = HALFSPACE;
		promp = &p_half[0];		/* or promp = p_half */
		if( half_in() != 0 )  {
			(void)printf("ERROR, halfspace not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "arb8" ) == 0 )  {
		record.s.s_type = GENARB8;
		record.s.s_cgtype = ARB8;
		promp = &p_arb[0];		/* or promp = p_arb */
		if( arb_in( 8 ) != 0 )  {
			(void)printf("ERROR, arb8 not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "arb7" ) == 0 )  {
		record.s.s_type = GENARB8;
		record.s.s_cgtype = ARB7;
		promp = &p_arb[0];
		if( arb_in( 7 ) != 0 )  {
			(void)printf("ERROR, arb7 not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "arb6" ) == 0 )  {
		record.s.s_type = GENARB8;
		record.s.s_cgtype = ARB6;
		promp = &p_arb[0];
		if( arb_in( 6 ) != 0 )  {
			(void)printf("ERROR, arb6 not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "arb5" ) == 0 )  {
		record.s.s_type = GENARB8;
		record.s.s_cgtype = ARB5;
		promp = &p_arb[0];
		if( arb_in( 5 ) != 0 )  {
			(void)printf("ERROR, arb5 not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "arb4" ) == 0 )  {
		record.s.s_type = GENARB8;
		record.s.s_cgtype = ARB4;
		promp = &p_arb[0];
		if( arb_in( 4 ) != 0 )  {
			(void)printf("ERROR, arb4 not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "sph" ) == 0 )  {
		record.s.s_type = GENELL;
		record.s.s_cgtype = SPH;
		promp = &p_sph[0];
		if( sph_in() != 0 )  {
			(void)printf("ERROR, sphere not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "ell" ) == 0 )  {
		record.s.s_type = GENELL;
		record.s.s_cgtype = ELL;
		promp = &p_ell[0];
		if( ell_in( ELL ) != 0 )  {
			(void)printf("ERROR, ell not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "ellg" ) == 0 )  {
		record.s.s_type = GENELL;
		record.s.s_cgtype = ELLG;
		promp = &p_ell[0];
		if( ell_in( ELLG ) != 0 )  {
			(void)printf("ERROR, ellg not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "ell1" ) == 0 )  {
		record.s.s_type = GENELL;
		record.s.s_cgtype = ELL1;
		promp = &p_ell[0];
		if( ell_in( ELL1 ) != 0 )  {
			(void)printf("ERROR, ell1 not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "tor" ) == 0 )  {
		record.s.s_type = TOR;
		record.s.s_cgtype = TOR;
		promp = &p_tor[0];
		if( tor_in() != 0 )  {
			(void)printf("ERROR, tor not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "tgc" ) == 0 )  {
		record.s.s_type = GENTGC;
		record.s.s_cgtype = TGC;
		promp = &p_tgc[0];
		if( cyl_in( TGC ) != 0 )  {
			(void)printf("ERROR, tgc not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "tec" ) == 0 )  {
		record.s.s_type = GENTGC;
		record.s.s_cgtype = TEC;
		promp = &p_tgc[0];
		if( cyl_in( TEC ) != 0 )  {
			(void)printf("ERROR, tec not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "rec" ) == 0 )  {
		record.s.s_type = GENTGC;
		record.s.s_cgtype = REC;
		promp = &p_tgc[0];
		if( cyl_in( REC ) != 0 )  {
			(void)printf("ERROR, rec not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "trc" ) == 0 )  {
		record.s.s_type = GENTGC;
		record.s.s_cgtype = TRC;
		promp = &p_tgc[0];
		if( cyl_in( TRC ) != 0 )  {
			(void)printf("ERROR, trc not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "rcc" ) == 0 )  {
		record.s.s_type = GENTGC;
		record.s.s_cgtype = RCC;
		promp = &p_tgc[0];
		if( cyl_in( RCC ) != 0 )  {
			(void)printf("ERROR, rcc not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "box" ) == 0 )  {
		record.s.s_type = GENARB8;
		record.s.s_cgtype = BOX;
		promp = &p_box[0];
		if( box_in() != 0 )  {
			(void)printf("ERROR, box not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "raw" ) == 0 )  {
		record.s.s_type = GENARB8;
		record.s.s_cgtype = RAW;
		promp = &p_box[0];
		if( box_in() != 0 )  {
			(void)printf("ERROR, raw not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "rpp" ) == 0 )  {
		record.s.s_type = GENARB8;
		record.s.s_cgtype = RPP;
		promp = &p_rpp[0];
		if( rpp_in() != 0 )  {
			(void)printf("ERROR, rpp not made!\n");
			return;
		}
	} else if( strcmp( cmd_args[2], "ebm" ) == 0 )  {
d409 1
a409 1
		if (ars_in(numargs, cmd_args, &internal) != 0)  {
d416 77
d497 9
a505 4

	/* Zero out record.s.s_values[] */
	for( i = 0; i < 24; i++ )  {
		record.s.s_values[i] = 0.0;
d508 6
a513 3
	/* Convert and copy cmd_args[] to record.s.s_values[] */
	for( i = 0; i < vals; i++ )  {
		record.s.s_values[i] = atof(cmd_args[3+i])*local2base;
a515 23
	/* Convert to GED notion of database */
	if( cvt_ged( &record.s ) )  {
		(void)printf("ERROR, cvt_ged failure, database not updated!\n");
		return;		/* failure */
	}

	/* don't allow interrupts while we update the database! */
	(void)signal( SIGINT, SIG_IGN);
 
	/* Add to in-core directory */
	if( (dp = db_diradd( dbip,  name, -1L, 0, DIR_SOLID )) == DIR_NULL ||
	    db_alloc( dbip, dp, 1 ) < 0 )  {
	    	ALLOC_ERR_return;
	}
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 )  WRITE_ERR_return;

	/* draw the "made" solid */
	new_cmd[0] = "e";
	new_cmd[1] = name;
	new_cmd[2] = (char *)NULL;
	f_edit( 2, new_cmd );
	return;

d592 1
a592 1
ars_in( argc, argv, intern )
d596 1
d606 1
a606 1
		(void)printf("%s", p_ars[args-3]);
a612 1
	RT_INIT_DB_INTERNAL( intern );
d638 1
a638 1
		(void)printf("%s", p_ars[args-3]);
d670 1
a670 1
				p_ars[5+axis%3], cv, axis/3 );
d673 1
a673 1
				p_ars[5+axis%3] );
d700 1
a700 1
/*	H A L F _ I N ( ) :    	reads halfspace parameters from keyboard
a702 2
 *
 *	where's half_out?  This cat named Schrodinger wants to know.
d705 3
a707 1
half_in()
d709 11
a719 7
	/* Read outward pointing normal vector and distance from origin */
	while( args < (3 + (3*1 + 1)) )  {
		(void)printf("%s", promp[args-3] );
		if( (argcnt = getcmd(args)) < 0 )  {
			return(1);	/* failure */
		}
		args += argcnt;
d721 3
a723 2
	/* Check for "very small" normal vector */
	if( checkv(3) )  {
d727 1
a727 1
	vals = 4;
d731 1
a731 1
/*	A R B _ I N ( ) :    	reads arb parameters from keyboard
d736 3
a738 2
arb_in( numpts )
int numpts;
d740 30
a769 3
	if( numpts > 8 || numpts < 4 )  {
		(void)printf("ERROR arb_in: numpts out of range!\n");
		return(1);	/* failure */
a771 8
	while( args < (3 + (3*numpts)) )  {
		(void)printf("%s", promp[args-3] );
		if( (argcnt = getcmd(args)) < 0 )  {
			return(1);	/* failure */
		}
		args += argcnt;
	}
	vals = numpts*3;
d775 1
a775 1
/*   S P H _ I N ( ) :   	reads sphere parameters from keyboard
d780 3
a782 1
sph_in()
d784 12
a795 7
	/* Read vertex and radius */
	while( args < (3 + (3*1 + 1)) )  {
		(void)printf("%s", promp[args-3]);
		if( (argcnt = getcmd(args)) < 0 )  {
			return(1);	/* failure */
		}
		args += argcnt;
d797 6
a802 2
	/* Check for zero radius */
	if( atof(cmd_args[6]) <= 0.0 )  {
d806 1
a806 1
	vals = 4;
d810 1
a810 1
/*	E L L _ I N ( ) :	reads parameters for ells
d815 3
a817 2
ell_in( type )
int type;
d819 17
a835 15
	if( type == ELL )  {
		while( args < (3 + 7) )  {
			(void)printf("%s", promp[args-3+13]);	/* Lookout! */
			if( (argcnt = getcmd(args)) < 0 )  {
				return(1);	/* failure */
			}
			args += argcnt;
		}
		/* Check for zero axis length */
		if( atof(cmd_args[9]) <= 0.0 )  {
			(void)printf("ERROR, axis length must be greater than zero!\n");
			return(1);	/* failure */
		}
		vals = 7;
		return(0);	/* success */
d838 21
a858 5
	/* Have ELL1 or ELLG.  Get Vertex(X, Y, Z)  and vector A(X, Y, Z) */
	while( args < (3 + 6) )  {
		(void)printf("%s", promp[args-3]);
		if( (argcnt = getcmd(args)) < 0 )  {
			return(1);	/* failure */
d860 9
a868 1
		args += argcnt;
d870 42
a911 3
	/* Check for zero length vector A */
	if( checkv(6) )  {
		(void)printf("ERROR, vector A length must be greater than zero!\n");
d914 4
a917 15
	if( type == ELL1 )  {
		while( args < (3 + 7) )  {
			(void)printf("%s", promp[12]);		/* Lookout! */
			if( (argcnt = getcmd(args)) < 0 )  {
				return(1);	/* failure */
			}
			args += argcnt;
		}
		/* Check for zero radius */
		if( atof(cmd_args[9]) <= 0.0 )  {
			(void)printf("ERROR, radius must be greater than zero!\n");
			return(1);	/* failure */
		}
		vals = 7;
		return(0);	/* success */
d919 3
d923 24
a946 21
	/* Should have ELLG.  Get vector B and C */
	if( type == ELLG )  {
		while( args < (3 + 12) )  {
			(void)printf("%s", promp[args-3]);
			if( (argcnt = getcmd(args)) < 0 )  {
				return(1);	/* failure */
			}
			args += argcnt;
		}
		/* Check for zero length vector B */
		if( checkv(9) )  {
			(void)printf("ERROR, vector B length must be greater than zero!\n");
			return(1);	/* failure */
		}
		/* Check for zero length vector C */
		if( checkv(12) )  {
			(void)printf("ERROR, vector C length must be greater than zero!\n");
			return(1);	/* failure */
		}
		vals = 12;
		return(0);	/* success */
d948 10
d959 11
a969 3
	/* Protect ourselves */
	(void)printf("ERROR ell_in(): uknown type of GENELL\n");
	return(1);	/* failure */
d972 1
a972 1
/*	T O R _ I N ( ) :	gets parameters of torus from keyboard
d977 3
a979 1
tor_in()
d981 4
a984 1
	fastf_t rad1, rad2;
d986 9
a994 6
	while( args < (3 + 8) )  {
		(void)printf("%s", promp[args-3]);
		if( (argcnt = getcmd(args)) < 0 )  {
			return(1);	/* failure */
		}
		args += argcnt;
d996 4
a999 3
	/* Check for zero length normal vector */
	if( checkv(6) )  {
		(void)printf("ERROR, normal vector length must be greater than zero!\n");
d1002 38
a1039 4
	/* Check for zero radius 1 */
	if( (rad1 = atof(cmd_args[9])) <= 0.0 )  {
		(void)printf("ERROR, radius 1 must be greater than zero!\n");
		return(1);	/* failure */
d1041 6
a1046 3
	/* Check for zero radius 2 */
	if( (rad2 = atof(cmd_args[10])) <= 0.0 )  {
		(void)printf("ERROR, radius 2 must be greater than zero!\n");
d1049 37
a1085 3
	/* Check for radius 2 >= radius 1 */
	if( rad1 <= rad2 )  {
		(void)printf("ERROR, radius 2 >= radius 1 ....\n");
d1088 4
a1091 1
	vals = 8;
d1095 3
a1097 1
/*   C Y L _ I N ( ) :		reads parameters for all cylinders 
d1100 3
a1102 2
cyl_in( type )
int type;
d1104 3
d1108 9
a1116 7
	/* Get vertex and height vectors */
	while( args < (3 + 6) )  {
		(void)printf("%s", promp[args-3]);
		if( (argcnt = getcmd(args)) < 0 )  {
			return(1);	/* failure */
		}
		args += argcnt;
d1118 6
a1123 3
	/* Check for zero length height vector */
	if( checkv(6) )  {
		(void)printf("ERROR, height vector length must be greater than zero!\n");
d1127 39
a1165 16
	if( type == RCC )  {
		/* Get radius */
		while( args < (3 + 7) )  {
			(void)printf("%s", promp[14]);		/* Lookout! */
			if( (argcnt = getcmd(args)) < 0 )  {
				return(1);	/* failure */
			}
			args += argcnt;
		}
		/* Check for zero radius */
		if( atof(cmd_args[9]) <= 0.0 )  {
			(void)printf("ERROR, radius must be greater than zero!\n");
			return(1);	/* failure */
		}
		vals = 7;
		return(0);	/* success */
d1167 6
d1174 18
a1191 28
	if( type == TRC )  {
		/* Get radius of base and top */
		while( args < (3 + 7) )  {
			(void)printf("%s", promp[15]);		/* Lookout! */
			if( (argcnt = getcmd(args)) < 0 )  {
				return(1);	/* failure */
			}
			args += argcnt;
		}
		/* Check for zero top radius */
		if( atof(cmd_args[9]) <= 0.0 )  {
			(void)printf("ERROR, radius must be greater than zero!\n");
			return(1);	/* failure */
		}
		while( args < (3 + 8) )  {
			(void)printf("%s", promp[16]);		/* Lookout! */
			if( (argcnt = getcmd(args)) < 0 )  {
				return(1);	/* failure */
			}
			args += argcnt;
		}
		/* Check for zero bottom radius (rad2)*/
		if( atof(cmd_args[10]) <= 0.0 )  {
			(void)printf("ERROR, radius must be greater than zero!\n");
			return(1);	/* failure */
		}
		vals = 8;
		return(0);	/* success */
d1194 33
a1226 10
	/*
	 * Must have REC, TEC, or TGC
	 * Get A and B vectors
	 */
	while( args < (3 + 12) )  {
		(void)printf("%s", promp[args-3]);
		if( (argcnt = getcmd(args)) < 0 )  {
			return(1);	/* failure */
		}
		args += argcnt;
d1228 2
a1229 3
	/* Check for zero length A vector */
	if( checkv(9) )  {
		(void)printf("ERROR, A vector length must be greater than zero!\n");
d1232 2
a1233 3
	/* Check for zero length B vector */
	if( checkv(12) )  {
		(void)printf("ERROR, B vector length must be greater than zero!\n");
d1237 8
a1244 4
	if( type == REC )  {
		vals = 12;
		return(0);	/* success */
	}
d1246 2
a1247 16
	if( type == TEC )  {
		while( args < (3 + 13) )  {
			(void)printf("%s", promp[17]);		/* Lookout! */
			if( (argcnt = getcmd(args)) < 0 )  {
				return(1);	/* failure */
			}
			args += argcnt;
		}
		/* Check for ratio greater than 1.0 */
		if( atof(cmd_args[15]) < 1.0 )  {
			(void)printf("ERROR, ratio must be greater than one!\n");
			return(1);	/* failure */
		}
		vals = 13;
		return(0);	/* success */
	}
d1249 22
a1270 20
	if( type == TGC )  {
		while( args < (3 + 14) )  {
			(void)printf("%s", promp[args-3]);	/* Lookout! */
			if( (argcnt = getcmd(args)) < 0 )  {
				return(1);	/* failure */
			}
			args += argcnt;
		}
		/* Check for zero radius */
		if( atof(cmd_args[15]) <= 0.0 )  {
			(void)printf("ERROR, must be greater than zero!\n");
			return(1);	/* failure */
		}
		/* Check for zero radius (rad1) */
		if( atof(cmd_args[16]) <= 0.0 )  {
			(void)printf("ERROR, must be greater than zero!\n");
			return(1);	/* failure */
		}
		vals = 14;
		return(0);	/* success */
d1272 10
a1281 4

	/* Protect ourselves */
	(void)printf("ERROR cyl_in(): uknown type of GENTGC\n");
	return(1);	/* failure */
d1284 1
a1284 1
/*   B O X _ I N ( ) :		reads parameters for BOX and RAW
d1286 1
a1286 1
 *				        1 if unsuccessful read
d1289 3
a1291 1
box_in()
d1293 13
a1305 6
	while( args < (3 + 12) )  {
		(void)printf("%s", promp[args-3]);
		if( (argcnt = getcmd(args)) < 0 )  {
			return(1);	/* failure */
		}
		args += argcnt;
d1307 7
a1313 3
	/* Check for zero H vector */
	if( checkv(6) )  {
		(void)printf("ERROR, H vector length must be greater than zero!\n");
d1316 26
a1341 4
	/* Check for zero W vector */
	if( checkv(9) )  {
		(void)printf("ERROR, W vector length must be greater than zero!\n");
		return(1);	/* failure */
d1343 7
a1349 3
	/* Check for zero D vector */
	if( checkv(12) )  {
		(void)printf("ERROR, D vector length must be greater than zero!\n");
d1352 1
a1352 1
	vals = 12;
d1356 1
a1356 1
/*   R P P _ I N ( ) :		reads parameters for RPP
d1358 1
a1358 1
 *				        1 if unsuccessful read
d1361 3
a1363 1
rpp_in()
d1365 13
a1377 6
	while( args < (3 + 6) )  {
		(void)printf("%s", promp[args-3]);
		if( (argcnt = getcmd(args)) < 0 )  {
			return(1);	/* failure */
		}
		args += argcnt;
d1379 9
a1387 3
	/* Check input */
	if( atof(cmd_args[3]) >= atof(cmd_args[4]) )  {
		(void)printf("ERROR, XMIN greater than XMAX!\n");
d1390 26
a1415 3
	if( atof(cmd_args[5]) >= atof(cmd_args[6]) )  {
		(void)printf("ERROR, YMIN greater than YMAX!\n");
		return(1);	/* failure */
d1417 7
a1423 2
	if( atof(cmd_args[7]) >= atof(cmd_args[8]) )  {
		(void)printf("ERROR, ZMIN greater than ZMAX!\n");
d1426 1
a1426 1
	vals = 6;
a1513 414
}

/*   C V T _ G E D ( ) :	converts solid parameters to GED format
 *				Adapted from convert.c of CVT
 *				returns		-1 if not successful
 *						 0 if successful
 */

#define Xmin	iv[0]
#define Xmax	iv[1]
#define Ymin	iv[2]
#define Ymax	iv[3]
#define Zmin	iv[4]
#define Zmax	iv[5]

/*
 * Input Vector Fields
 */
#define Fi	iv+(i-1)*3
#define F1	iv+(1-1)*3
#define F2	iv+(2-1)*3
#define F3	iv+(3-1)*3
#define F4	iv+(4-1)*3
#define F5	iv+(5-1)*3
#define F6	iv+(6-1)*3
#define F7	iv+(7-1)*3
#define F8	iv+(8-1)*3
/*
 * Output vector fields
 */
#define Oi	ov+(i-1)*3
#define O1	ov+(1-1)*3
#define O2	ov+(2-1)*3
#define O3	ov+(3-1)*3
#define O4	ov+(4-1)*3
#define O5	ov+(5-1)*3
#define O6	ov+(6-1)*3
#define O7	ov+(7-1)*3
#define O8	ov+(8-1)*3
#define O9	ov+(9-1)*3
#define O10	ov+(10-1)*3
#define O11	ov+(11-1)*3
#define O12	ov+(12-1)*3
#define O13	ov+(13-1)*3
#define O14	ov+(14-1)*3
#define O15	ov+(15-1)*3
#define O16	ov+(16-1)*3

int
cvt_ged( in )
struct solidrec *in;
{
	register dbfloat_t *iv;
	register fastf_t *ov;
#ifdef mips
	register fastf_t * o_ptr;
#endif
	fastf_t	points[3*8];
	register int i;
	fastf_t r1, r2, r3, r4;
	vect_t	work;
	fastf_t m1, m2, m3;
	fastf_t m5, m6;
	short cgtype;
	static fastf_t pi = 3.14159265358979323264;

	/* Get positioned at s_values[0] to begin conversion */
	iv = &in->s_values[0];
	ov = &points[0];
	cgtype = in->s_cgtype;

	switch( cgtype )  {

	case HALFSPACE:
		/* HALFSPACE format is N, d */
		VUNITIZE( F1 );
		return(0);	/* Success */

	case RPP:
#ifndef mips
		VSET( O1, Xmax, Ymin, Zmin );
		VSET( O2, Xmax, Ymax, Zmin );
		VSET( O3, Xmax, Ymax, Zmax );
		VSET( O4, Xmax, Ymin, Zmax );
		VSET( O5, Xmin, Ymin, Zmin );
		VSET( O6, Xmin, Ymax, Zmin );
		VSET( O7, Xmin, Ymax, Zmax );
		VSET( O8, Xmin, Ymin, Zmax );
#else
		o_ptr = ov;
		*(o_ptr++)   = in->s_values[1];
		*(o_ptr++) = in->s_values[2];
		*(o_ptr++) = in->s_values[4];

		*(o_ptr++) = in->s_values[1];
		*(o_ptr++) = in->s_values[3];
		*(o_ptr++) = in->s_values[4];

		*(o_ptr++) = in->s_values[1];
		*(o_ptr++) = in->s_values[3];
		*(o_ptr++) = in->s_values[5];

		*(o_ptr++) = in->s_values[1];
		*(o_ptr++) = in->s_values[2];
		*(o_ptr++) = in->s_values[5];

		*(o_ptr++) = in->s_values[0];
		*(o_ptr++) = in->s_values[2];
		*(o_ptr++) = in->s_values[4];

		*(o_ptr++) = in->s_values[0];
		*(o_ptr++) = in->s_values[3];
		*(o_ptr++) = in->s_values[4];

		*(o_ptr++) = in->s_values[0];
		*(o_ptr++) = in->s_values[3];
		*(o_ptr++) = in->s_values[5];

		*(o_ptr++) = in->s_values[0];
		*(o_ptr++) = in->s_values[2];
		*(o_ptr++) = in->s_values[5];
#endif
		goto ccommon;

	case BOX:
		VMOVE( O1, F1 );
		VADD2( O2, F1, F3 );
		VADD3( O3, F1, F3, F2 );
		VADD2( O4, F1, F2 );
		VADD2( O5, F1, F4 );
		VADD3( O6, F1, F4, F3 );
		VADD4( O7, F1, F4, F3, F2 );
		VADD3( O8, F1, F4, F2 );
		goto ccommon;

	case RAW:
		VMOVE( O1, F1 );
		VADD2( O2, F1, F3 );
		VADD2( O4, F1, F2 );	/* next lines fliped for 4d uopt bug */
		VMOVE( O3, O2 );
		VADD2( O5, F1, F4 );
		VADD3( O6, F1, F4, F3 );
		VMOVE( O7, O6 );
		VADD3( O8, F1, F4, F2 );
	ccommon:
		VMOVE( F1, O1 );
		for( i=2; i<=8; i++ )  {
			VSUB2( Fi, Oi, O1 );
		}
		return(0);	/* Success */

	case ARB8:
	arbcommon:
		for( i=2; i<=8; i++ )  {
			VSUB2( Fi, Fi, F1 );
		}
		return(0);	/* Success */

	case ARB7:
		VMOVE( F8, F5 );
		goto arbcommon;

	case ARB6:
		/* NOTE: the ordering is important, as data is in F5, F6 */
		VMOVE( F8, F6 );
		VMOVE( F7, F6 );
		VMOVE( F6, F5 );
		goto arbcommon;

	case ARB5:
		VMOVE( F6, F5 );
		VMOVE( F7, F5 );
		VMOVE( F8, F5 );
		goto arbcommon;

	case ARB4:
		/* Order is important, data is in F4 */
		VMOVE( F8, F4 );
		VMOVE( F7, F4 );
		VMOVE( F6, F4 );
		VMOVE( F5, F4 );
		VMOVE( F4, F1 );
		goto arbcommon;
	case RCC:
		r1 = iv[6];	/* Radius */
		r2 = iv[6];
		goto trccommon;		/* sorry */

	case REC:
		VMOVE( F5, F3 );
		VMOVE( F6, F4 );
		return(0);	/* Success */

		/*
		 * For the TRC, if the V vector (F1) is of zero length,
		 * a divide by zero will occur when scaling by the magnitude.
		 * We add the vector [pi, pi, pi] to V to produce a unique
		 * (and most likely non-zero) resultant vector.  This will
		 * do nicely for purposes of cross-product.
		 * THIS DOES NOT GO OUT INTO THE FILE!!
		 * work[] must NOT be colinear with F2[].  We check for this
		 * later.
		 */

	case TRC:
		r1 = iv[6];	/* Radius 1 */
		r2 = iv[7];	/* Radius 2 */
	trccommon:
		VMOVE( work, F1 );
		work[0] += pi;
		work[1] += pi;
		work[2] += pi;
		VCROSS( F3, work, F2 );
		m1 = MAGNITUDE( F3 );
		if( m1 == 0.0 )  {
			work[1] = 0.0;		/* Vector is colinear, so */
			work[2] = 0.0;		/* make it different */
			VCROSS( F3, work, F2 );
			m1 = MAGNITUDE( F3 );
			if( m1 == 0.0 )  {
				(void)printf("ERROR, magnitude is zero!\n");
				return(-1);	/* failure */
			}
		}
		VSCALE( F3, F3, r1/m1 );

		VCROSS( F4, F2, F3 );
		m2 = MAGNITUDE( F4 );
		if( m2 == 0.0 )  {
			(void)printf("ERROR, magnitude is zero!\n");
			return(-1);	/* failure */
		}
		VSCALE( F4, F4, r1/m2 );

		if( r1 == 0.0 )  {
			(void)printf("ERROR, magnitude is zero!\n");
			return(-1);	/* failure */
		}
		VSCALE( F5, F3, r2/r1 );
		VSCALE( F6, F4, r2/r1 );
		return(0);	/* success */

	case TEC:
		/* r1 is a ratio, hence "unitless".  However, during input
		 *	it was converted to base units along with the other
		 *	parameters, so this must be "undone".
		 */
		r1 = iv[12] * base2local;

		if( r1 == 0.0 )  {
			(void)printf("ERROR, magnitude is zero!\n");
			return(-1);	/* failure */
		}
		VSCALE( F5, F3, (1.0/r1) );
		VSCALE( F6, F4, (1.0/r1) );
		return(0);	/* success */

	case TGC:
		/* This should have been checked earlier but we'll check */
		if( (MAGNITUDE( F3 ) == 0.0) || (MAGNITUDE( F4) == 0.0) )  {
			(void)printf("ERROR, magnitude is zero!\n");
			return(-1);	/* failure */
		}
		r1 = iv[12] / MAGNITUDE( F3 );	/* A/|A| * C */
		r2 = iv[13] / MAGNITUDE( F4 );	/* B/|B| * D */
		VSCALE( F5, F3, r1 );
		VSCALE( F6, F4, r2 );
		return(0);	/* success */

	case SPH:
		/* SPH format is V, r */
		r1 = iv[3];		/* Radius */
		VSET( F2, r1,  0,  0 );
		VSET( F3,  0, r1,  0 );
		VSET( F4,  0,  0, r1 );
		return(0);	/* success */

	case ELL:
		/*
		 * For simplicity, an ELL is converted to an ELL1, then
		 * falls through to the ELL1 code.
		 * ELL format is F1, F2, l and ELL1 format is V, A, r
		 */
		r1 = iv[6];		/* Length */
		VADD2( O1, F1, F2 );
		VSCALE( O1, O1, 0.5 );	/* O1 holds V */

		VSUB2( O3, F2, F1 );	/* O3 holds F2 - F1 */
		m1 = MAGNITUDE(O3);
		/* XXX check this later */
		if( m1 == 0.0 )  {
			(void)printf("ERROR, magnitude is zero!\n");
			return(-1);	/* failure */
		}
		r2 = 0.5 * r1 / m1;
		VSCALE( O2, O3, r2 );	/* O2 holds A */

		iv[6] = sqrt( MAGSQ( O2 ) - (m1 * 0.5)*(m1 * 0.5) );	/* r */
		VMOVE( F1, O1 );	/* Move V */
		VMOVE( F2, O2 );	/* Move A */
		/* fall through */

	case ELL1:
		/* GENELL format is V, A, B, C */
		r1 = iv[6];		/* Radius */

		/*
		 * To allow for V being (0,0,0), for VCROSS purposes only,
		 * we add (pi,pi,pi).  THIS DOES NOT GO OUT INTO THE FILE!!
		 * work[] must NOT be colinear with F2[].  We check for this
		 * later.
		 */
		VMOVE( work, F1 );
		work[0] += pi;
		work[1] += pi;
		work[2] += pi;

		VCROSS( F3, work, F2 );
		m1 = MAGNITUDE( F3 );
		if( m1 == 0.0 )  {
			work[1] = 0.0;		/* Vector is colinear, so */
			work[2] = 0.0;		/* make it different */
			VCROSS( F3, work, F2 );
			m1 = MAGNITUDE( F3 );
			if( m1 == 0.0 )  {
				(void)printf("ERROR, magnitude is zero!\n");
				return(-1);	/* failure */
			}
		}
		VSCALE( F3, F3, r1/m1 );

		VCROSS( F4, F2, F3 );
		m2 = MAGNITUDE( F4 );
		if( m2 == 0.0 )  {
			(void)printf("ERROR, magnitude is zero!\n");
			return(-1);	/* failure */
		}
		VSCALE( F4, F4, r1/m2 );
		return(0);	/* success */

	case ELLG:
		/* Everything is already okay.  ELLG format is V, A, B, C */
		return(0);	/* success */

	case TOR:
		/* TOR format is V, N, r1, r2 */
		r1=iv[6];	/* Dist from end of V to center of (solid portion) of TORUS */
		r2=iv[7];	/* Radius of solid portion of TORUS */
		r3=r1-r2;	/* Radius to inner circular edge */
		r4=r1+r2;	/* Radius to outer circular edge */

		/*
		 * To allow for V being (0,0,0), for VCROSS purposes only,
		 * we add (pi,pi,pi).  THIS DOES NOT GO OUT INTO THE FILE!!
		 * work[] must NOT be colinear with N[].  We check for this
		 * later.
		 */
		VMOVE(work,F1);
		work[0] +=pi;
		work[1] +=pi;
		work[2] +=pi;

		m2 = MAGNITUDE( F2 );	/* F2 is NORMAL to Torus, with Radius length */
		if( m2 == 0.0 )  {
			(void)printf("ERROR, normal magnitude is zero!\n");
			return(-1);	/* failure */
		}
		VSCALE( F2, F2, r2/m2 );

		/* F3, F4 are perpendicular, goto center of Torus (solid part), for top/bottom */
		VCROSS(F3,work,F2);
		m1=MAGNITUDE(F3);
		if( m1 == 0.0 )  {
			work[1] = 0.0;		/* Vector is colinear, so */
			work[2] = 0.0;		/* make it different */
			VCROSS(F3,work,F2);
			m1=MAGNITUDE(F3);
			if( m1 == 0.0 )  {
				(void)printf("ERROR, cross product vector is zero!\n");
				return(-1);	/* failure */
			}
		}
		VSCALE(F3,F3,r1/m1);

		VCROSS(F4,F3,F2);
		m3=MAGNITUDE(F4);
		if( m3 == 0.0 )  {
			(void)printf("ERROR, magnitude is zero!\n");
			return(-1);	 /* failure */
		}

		VSCALE(F4,F4,r1/m3);

		m5 = MAGNITUDE(F3);
		m6 = MAGNITUDE( F4 );
		if( m5 == 0.0 || m6 == 0.0 )  {
			(void)printf("ERROR, magnitude is zero!\n");
			return(-1);	/* failure */
		}

		/* F5, F6 are perpendicular, goto inner edge of ellipse */
		VSCALE( F5, F3, r3/m5 );
		VSCALE( F6, F4, r3/m6 );

		/* F7, F8 are perpendicular, goto outer edge of ellipse */
		VSCALE( F7, F3, r4/m5 );
		VSCALE( F8, F4, r4/m6 );
 
		return(0);	 /* success finally */

	default:
		(void)printf("cvt_ged(): unknown solid type\n");
		return(-1);	/* failure */
	}
@


10.1
log
@Release_4.0
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 9.13 91/09/26 22:37:51 butler Exp $ (BRL)";
a480 7

	/* Add name to database record */
	{
		union record	*rec = (union record *)external.ext_buf;
		/* NOTE:  This depends on name always being in the same place */
		NAMEMOVE( name, rec->s.s_name );
	}
@


9.13
log
@removed unused label
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 9.12 91/08/30 17:15:42 mike Exp Locker: butler $ (BRL)";
@


9.12
log
@strlen returns unsigned, ANSI comparison with int requires cast.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 9.11 91/06/14 06:31:39 mike Exp $ (BRL)";
a450 1
do_update:
@


9.11
log
@Modified for new string solid database record
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 9.10 91/02/27 22:07:48 mike Exp $ (BRL)";
d235 1
a235 1
	if( strlen(cmd_args[1]) >= NAMESIZE )  {
@


9.10
log
@Simplified slightly so Gould compiler would not run out of stack space.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 9.9 91/01/15 01:38:51 mike Exp $ (BRL)";
d411 1
a411 1
		if( strsol_in( &record, "ebm" ) < 0 )  {
d415 1
a415 1
		goto do_update;
d417 1
a417 1
		if( strsol_in( &record, "vol" ) < 0 )  {
d421 1
a421 1
		goto do_update;
a469 3
	/* don't allow interrupts while we update the database! */
	(void)signal( SIGINT, SIG_IGN);

d479 4
d516 3
a518 3
strsol_in( rp, sol )
union record	*rp;
char		*sol;
d520 2
a521 4
	int	left;
	register char	*cp;
	int	i;
	int	len;
d532 4
a535 20
	/* Up to DB_SS_LEN chars of arg, space separated, null terminated */
	left = DB_SS_LEN-1;
	cp = &rp->ss.ss_str[0];
	len = strlen(sol);
	strncpy( cp, sol, len );
	cp += len;
	*cp++ = ' ';
	left -= len+1;
	for( i = 3; i < args; i++ )  {
		len = strlen( cmd_args[i] );
		if( len > left )  {
			(void)printf("Too long, truncating\n");
			break;
		}
		if( i > 3 ) *cp++ = ' ';
		strncpy( cp, cmd_args[i], len );
		cp += len;
		left -= len+1;
	}
	*cp++ = '\0';
d537 8
a544 1
	rp->ss.ss_id = DBID_STRSOL;
@


9.9
log
@Changes handling of EBM and VOL solids
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 9.9 91/01/14 22:56:19 mike Exp $ (BRL)";
d54 1
d68 1
a68 1
char		**promp;	/* pointer to a pointer to a char */
a560 11

/* XXX this should come from a header file.  Must match librt/g_ars.c */
/* The internal (in memory) form of an ARS */
struct ars_internal {
	int	magic;
	int	ncurves;
	int	pts_per_curve;
	fastf_t	**curves;
};
#define RT_ARS_INTERNAL_MAGIC	0x77ddbbe3

d567 2
a568 2
	struct ars_internal	*arip;
	int			i;
d572 1
d584 2
a585 2
	intern->idb_ptr = (genptr_t)rt_malloc( sizeof(struct ars_internal), "ars_internal");
	arip = (struct ars_internal *)intern->idb_ptr;
d594 2
a595 1
	/* */
d638 1
a638 1
		if (cv < arip->ncurves-1)
d659 1
a659 1
		if( cv >= arip->ncurves-1 && axis >= ELEMENTS_PER_PT )  break;
d664 2
a665 2
		VMOVE( arip->curves[arip->ncurves-1]+3*i,
			arip->curves[arip->ncurves-1] );
@


9.8
log
@DBID_STRSOL
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 9.7 91/01/14 22:38:35 mike Exp $ (BRL)";
d409 3
a411 3
	} else if( strcmp( cmd_args[2], "str" ) == 0 )  {
		if( strsol_in( &record ) < 0 )  {
			(void)printf("ERROR, string solid not made!\n");
d415 6
d511 1
a511 1
 *  "in" name str arg(s)
d514 1
a514 1
strsol_in( rp )
d516 1
d525 1
a525 1
		(void)printf("Arg? ");
d535 5
@


9.7
log
@Changed IN command support for ARS to use new import/export interface.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 9.6 90/12/20 20:19:29 butler Exp $ (BRL)";
d541 1
a541 1
	rp->ss.ss_id = ID_STRSOL;
@


9.6
log
@60% implementation of typein of ars solids
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 9.5 90/12/08 00:31:27 mike Exp $ (BRL)";
d209 6
d240 1
d416 1
a416 2
#ifdef ARS_DEBUGGED
		if (ars_in(&record) != 0)
d418 5
a422 5
		return;
#else
		(void)printf("typein ars not implimented yet\n");
		return;
#endif
d449 1
a449 1
	if( (dp = db_diradd( dbip,  record.s.s_name, -1, 0, DIR_SOLID )) == DIR_NULL ||
d456 43
a498 1
	f_edit( 2, cmd_args );	/* depends on name being in argv[1] */
a543 11
#ifdef ARS_DEBUGGED
static void
mk_mem_ars( rec, p_data, total_points, pts_per_curve, n_waterlines )
union record *rec;
fastf_t p_data[][ELEMENTS_PER_PT];
int total_points, pts_per_curve, n_waterlines;
{
	register struct directory *dp;
	union record *p_recs;
	int i, j;
	int tot_recs, gran_per_curve;
d545 3
a547 2
	gran_per_curve = (pts_per_curve+7)/8;
	tot_recs = gran_per_curve * n_waterlines;
d549 9
a557 1
	p_recs = (union record *)rt_malloc(sizeof(union record) * tot_recs+1);
a558 43
	NAMEMOVE( rec->a.a_name, p_recs[0].a.a_name );

	p_recs[0].a.a_id = ID_ARS_A;
	p_recs[0].a.a_type = ARS;	/* obsolete? */
	p_recs[0].a.a_m = n_waterlines;
	p_recs[0].a.a_n = pts_per_curve;
	p_recs[0].a.a_curlen = gran_per_curve;
	p_recs[0].a.a_totlen = tot_recs; /* total granules */

	for (i=0,j=1 ; i < total_points ; i += 8 ) {
		p_recs[j].b.b_id = ID_ARS_B;
		p_recs[j].b.b_type = ARSCONT;	/* obsolete? */
		p_recs[j].b.b_n = i / pts_per_curve;/* obs? curve number */
		p_recs[j].b.b_ngranule = ((i%pts_per_curve)/8)+1; /* obs? */

		for (j=0 ; j < 8 ; ++j)
			VSCALE(&(p_recs[j].b.b_values[j]),
				&(p_data[i][j]), local2base);
	}

	if ((dp=db_diradd(dbip, p_recs[0].a.a_name, -1, tot_recs, DIR_SOLID))
	    == DIR_NULL || db_alloc(dbip, dp, tot_recs ) < 0) {
	    	ALLOC_ERR_return;
	}


	if (db_put(dbip, dp, p_recs, 0, tot_recs) < 0 )  {
		WRITE_ERR_return;
	}

	/* draw the "made" solid */
	strcpy(cmd_args[0], "e");

	cmd_args[1] = cmd_args[0] + 2;
	bcopy( rec->a.a_name , cmd_args[1], sizeof(rec->a.a_name));
	*((char *)(cmd_args[1] + sizeof(rec->a.a_name))) = '\0';

	cmd_args[2] = (char *)NULL;

	f_edit( 2, cmd_args );	/* depends on name being in argv[1] */
}


d560 4
a563 2
ars_in(rec)
union record *rec;
d565 5
a569 7
	int pts_per_curve;
	int n_waterlines;
	int i;
	int total_points;
	int axis;	/* current element in pt vector */
	int pt;	/* current point in waterline */
	fastf_t (*point_data)[ELEMENTS_PER_PT];
d579 8
a586 2
	if ((pts_per_curve = atoi(cmd_args[3])) < 3 ||
	    (n_waterlines =  atoi(cmd_args[4])) < 3 ) {
d590 1
a590 1
	printf("Waterlines: %d curve points: %d\n", n_waterlines, pts_per_curve);
d592 1
a592 1
	total_points = n_waterlines * pts_per_curve;
d594 8
a601 2
	point_data = (fastf_t (*)[ELEMENTS_PER_PT])rt_malloc(
			sizeof(point_t) * total_points);
d611 3
a613 3
	point_data[0][0] = atof(cmd_args[5]);
	point_data[0][1] = atof(cmd_args[6]);
	point_data[0][2] = atof(cmd_args[7]);
d615 3
a617 5
	/* fill in the other points of the first row */
	for (pt=1 ; pt < pts_per_curve ; ++pt) {
		point_data[pt][0] = point_data[0][0];
		point_data[pt][1] = point_data[0][1];
		point_data[pt][2] = point_data[0][2];
d620 1
d625 2
a626 2
		point_data[pt][axis] = atof(cmd_args[i]);
		if (++axis >= ELEMENTS_PER_PT) {
d628 1
a628 1
			++pt;
d633 2
a634 2
	while (pt < total_points-pts_per_curve+1) {
		if (pt < total_points-pts_per_curve)
d636 1
a636 3
				p_ars[5+axis],
				pt / pts_per_curve +1,
				pt % pts_per_curve +1);
d639 1
a639 3
				p_ars[5+axis],
				pt / pts_per_curve +1,
				pt % pts_per_curve +1);
d641 1
d648 3
a650 3
		    pt < n_waterlines * pts_per_curve * ELEMENTS_PER_PT ; ++i) {
			point_data[pt][axis] = atof(cmd_args[i]);
			if (++axis >= ELEMENTS_PER_PT) {
d652 1
a652 1
				++pt;
d655 1
d658 4
a661 5
	/* replicate last point */
	for (i=pt+1 ; i < total_points ; ++i) {
		point_data[i][0] = point_data[pt][0];
		point_data[i][1] = point_data[pt][1];
		point_data[i][2] = point_data[pt][2];
a662 14

	/* now it's time to make the in-memory database records */

	rec->a.a_id = ID_ARS_A;
	rec->a.a_type = ARS;	/* obsolete? */
	rec->a.a_m = n_waterlines;
	rec->a.a_n = pts_per_curve;
	rec->a.a_curlen = (pts_per_curve+7)/8;	/* granules per curve */
	rec->a.a_totlen = rec->a.a_curlen * n_waterlines; /* total granules */

	mk_mem_ars(rec, point_data, total_points,
			pts_per_curve, n_waterlines);

	rt_free((char *)point_data);
d665 1
a665 1
#endif
@


9.5
log
@Added error checking around calls to db_*() routines
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/typein.c,v 9.4 90/04/21 06:06:23 mike Exp $ (BRL)";
d76 11
d409 5
d416 1
d496 11
d508 161
d672 2
@


9.4
log
@redraw() and drawtree() replaced.
More emphasis on argv/argc use in command functions.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 9.3 89/12/28 16:09:57 mike Locked $ (BRL)";
d426 3
a428 3
	if( (dp = db_diradd( dbip,  record.s.s_name, -1, 0, DIR_SOLID )) == DIR_NULL )  {
		(void)printf("ERROR, dir_add failure, database not updated!\n");
		return;		/* failure */
d430 1
a430 2
	db_alloc( dbip, dp, 1 );
	db_put( dbip, dp, &record, 0, 1 );
@


9.3
log
@Made MAXARGS local to cmd.c, global 'maxargs' is used to learn of size.
Improved error checking in command globbing.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 9.2 89/10/10 16:22:08 mike Locked $ (BRL)";
d431 1
d433 2
a434 5
	db_put( dbip, dp, &record, 0, 1 );
	/* draw the "typed-in" solid */
	drawtree( dp );
	dmp->dmr_colorchange();
	dmaflag = 1;
@


9.2
log
@Added "in" command support for string solid
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 9.1 89/05/19 06:04:08 mike Rel3_5 $ (BRL)";
d65 1
d952 4
a955 4
				if( (newargs + pos) >= MAXARGS )  {
					(void)printf("More than %d arguments, excess flushed\n", MAXARGS);
					cmd_args[MAXARGS] = (char *)0;
					return(MAXARGS - pos);
@


9.1
log
@Release_3.5
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 8.7 89/05/18 00:00:45 mike Exp $ (BRL)";
d390 6
d420 1
d436 44
@


8.7
log
@Missing include file
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 8.6 89/05/17 23:34:47 mike Locked $ (BRL)";
@


8.6
log
@Added colorchange() call.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 8.5 89/05/11 21:42:40 mike Locked $ (BRL)";
d55 1
@


8.5
log
@db_diradd had the length and flags parameters backward
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 8.4 89/04/06 19:26:35 phil Locked $ (BRL)";
d426 1
@


8.4
log
@moved MAXLINE and MAXARGS to ged.h
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 8.3 89/01/16 22:51:52 phil Locked $ (BRL)";
d417 1
a417 1
	if( (dp = db_diradd( dbip,  record.s.s_name, -1, DIR_SOLID, 0 )) == DIR_NULL )  {
@


8.3
log
@drawHobj() --> drawtree()
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 8.2 88/12/06 02:34:27 mike Locked $ (BRL)";
a66 2
#define MAXLINE		512	/* Maximum number of chars per line */

a858 1
#define MAXARGS		200	/* Maximum number of args per line */
@


8.2
log
@Converted to new db_*() routines.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/typein.c,v 1.2 88/10/23 13:57:01 mike Exp $ (BRL)";
d427 1
a427 1
	drawHobj(dp, ROOT, 0, identity);
@


8.1
log
@Release_3.0
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 7.7 88/09/21 02:34:11 mike Exp $ (BRL)";
d53 1
a54 1
#include "./objdir.h"
d213 1
a213 1
	if( lookup( cmd_args[1], LOOKUP_QUIET ) != DIR_NULL )  {
d419 1
a419 1
	if( (dp = dir_add( record.s.s_name, -1, DIR_SOLID, 0 )) == DIR_NULL )  {
d423 1
a423 1
	db_alloc( dp, 1 );
d425 1
a425 1
	db_putrec( dp, &record, 0 );
@


7.7
log
@get atof() extern from math.h
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 7.6 88/09/17 02:33:59 mike Locked $ (BRL)";
@


7.6
log
@fixed typo.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 7.5 88/09/06 16:05:20 reschly Locked $ (BRL)";
d43 1
a56 1
extern double atof();
@


7.5
log
@Fix 4D compiler bug Can be taken out after operating system
release 3.1 unitl then this ugly hack...
-Paul
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 7.4 88/05/15 23:05:24 stay Locked $ (BRL)";
d994 1
a994 1
#ifdef !mips
@


7.4
log
@lint fixes
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 7.3 88/02/29 16:08:54 mike Locked $ (BRL)";
d969 3
d994 1
d1003 34
@


7.3
log
@4d/60T clover had a optimizer bug which required
two lines of code top be swapped (uopt should not core dump
but should turn off optimization.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 7.2 87/11/05 05:07:11 stay Locked $ (BRL)";
d214 1
a214 1
		(void)aexists( cmd_args[1] );
d882 1
a882 1
		(void)f_quit();
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 7.1 87/11/03 00:02:11 mike Rel $ (BRL)";
d1015 1
a1016 1
		VADD2( O4, F1, F2 );
@


7.1
log
@Release 2.3
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 6.1 87/07/11 08:05:42 mike Rel $ (BRL)";
d49 1
a49 1
#include "./machine.h"	/* special copy */
d593 1
a593 1
	float rad1, rad2;
d838 2
a839 2
	int i;
	float work[3];
d967 3
a969 3
	static struct solidrec out;
	register float *iv;
	register float *ov;
d971 4
a974 4
	float r1, r2, r3, r4;
	float work[3];
	float m1, m2, m3;
	float m5, m6;
d976 1
a976 1
	static float pi = 3.14159265358979323264;
d980 1
a980 1
	ov = &out.s_values[0];
@


6.1
log
@Release 2.0
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 5.1 87/06/24 22:22:32 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 4.3 87/02/13 00:13:20 mike Exp $ (BRL)";
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 4.2 87/01/15 23:15:46 kermit Exp $ (BRL)";
@


4.2
log
@Fixed vals read counter so it gets it right
in arb_in().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 4.1 86/12/29 03:23:23 kermit Locked $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 1.7 86/09/23 17:42:08 mike Exp $ (BRL)";
d475 1
a475 1
	vals = 24;
@


1.7
log
@Minor cleanup for cray
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 1.6 86/08/12 06:51:10 mike Exp $ (BRL)";
@


1.6
log
@Changed #includes for CC -I../h
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 1.5 86/07/18 02:45:19 mike Exp $ (BRL)";
d43 1
d45 4
@


1.5
log
@Modified to include halfspace.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 1.4 86/07/17 17:16:44 mike Exp $ (BRL)";
d45 4
a48 4
#include "../h/vmath.h"
#include "../h/db.h"
#include "ged.h"
#include "objdir.h"
@


1.4
log
@Fixed ratio conversion.
@
text
@d18 1
d23 5
d32 4
d38 1
a38 1
static char RCSid[] = "@@(#)$Header: typein.c,v 1.3 85/09/14 05:37:33 mike Exp $ (BRL)";
d64 7
d231 2
a232 1
	 * make name <arb[4-8]|sph|ell|ellg|ell1|tor|tgc|tec|rec|trc|rcc|box|raw|rpp>
d234 9
a242 1
	if( strcmp( cmd_args[2], "arb8" ) == 0 )  {
d406 2
a407 1
		return;
d414 4
a417 2
	if( (dp = dir_add( record.s.s_name, -1, DIR_SOLID, 0 )) == DIR_NULL )
		return;
d426 24
d516 1
a516 1
			(void)printf("ERROR, length must be greater than zero!\n");
d533 1
d564 1
d569 1
d599 1
d638 1
d703 1
d708 1
d777 1
d782 1
d787 1
d839 1
a839 1
	if( MAGNITUDE(work) == 0.0 ) {
d980 5
d1021 1
a1021 1
		return(0);
d1028 1
a1028 1
		return(0);
d1063 1
a1063 1
		return(0);
d1093 1
a1093 1
				return(-1);
d1102 1
a1102 1
			return(-1);
d1108 1
a1108 1
			return(-1);
d1112 1
a1112 1
		return(0);
d1123 1
a1123 1
			return(-1);
d1127 1
a1127 1
		return(0);
d1133 1
a1133 1
			return(-1);
d1139 1
a1139 1
		return(0);
d1147 1
a1147 1
		return(0);
d1164 1
a1164 1
			return(-1);
d1198 1
a1198 1
				return(-1);
d1207 1
a1207 1
			return(-1);
d1210 1
a1210 1
		return(0);
d1214 1
a1214 1
		return(0);
d1237 1
a1237 1
			return(-1);
d1251 1
a1251 1
				return(-1);
d1260 1
a1260 1
			return(-1);
d1269 1
a1269 1
			return(-1);
d1272 1
a1272 1
		/* F5, F6 are perpindicular, goto inner edge of ellipse */
d1280 1
a1280 1
		return(0);
d1284 1
a1284 1
		return(-1);
@


1.3
log
@Lint-inspired cleanup.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: typein.c,v 1.2 85/08/07 05:19:59 mike Exp $ (BRL)";
d1047 6
a1052 1
		r1 = iv[12];	/* P */
@


1.2
log
@Changed to use common ../h/vmath.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: typein.c,v 1.1 85/06/19 03:02:37 mike Exp $ (BRL)";
d551 1
a551 1
	if( (rad1 = atof(cmd_args[10])) <= 0.0 )  {
a569 1
	float rad1, rad2;
d594 1
a594 1
		if( (rad1 = atof(cmd_args[9])) <= 0.0 )  {
d612 1
a612 1
		if( (rad1 = atof(cmd_args[9])) <= 0.0 )  {
d623 2
a624 2
		/* Check for zero bottom radius */
		if( (rad2 = atof(cmd_args[10])) <= 0.0 )  {
d666 1
a666 1
		if( (rad1 = atof(cmd_args[15])) < 1.0 )  {
d683 1
a683 1
		if( (rad1 = atof(cmd_args[15])) <= 0.0 )  {
d687 2
a688 2
		/* Check for zero radius */
		if( (rad1 = atof(cmd_args[16])) <= 0.0 )  {
a795 1
	static char line[MAXLINE];
@


1.1
log
@Initial revision
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: typein.c,v 1.1 85/05/05 01:20:24 kermit Exp $ (BRL)";
d34 2
a35 1
#include "ged_types.h"
a36 1
#include "../h/vmath.h"
@
