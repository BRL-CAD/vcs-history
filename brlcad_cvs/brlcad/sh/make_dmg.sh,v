head	1.23;
access;
symbols
	rel-7-10-4:1.20
	STABLE:1.20.0.2
	stable-branch:1.13
	rel-7-10-2:1.20
	rel-7-10-0:1.20
	rel-7-8-4:1.18
	rel-7-8-2:1.18
	rel-7-8-0:1.18
	trimnurbs-branch:1.18.0.2
	help:1.18
	temp_tag:1.17
	bobWinPort-20051223-freeze:1.15
	postmerge-20051223-bobWinPort:1.17
	premerge-20051223-bobWinPort:1.17
	rel-7-6-6:1.17
	rel-7-6-4:1.17
	rel-7-6-2:1.15
	rel-7-6-branch:1.15.0.6
	rel-7-6-0:1.15
	rel-7-4-2:1.15
	rel-7-4-branch:1.15.0.4
	bobWinPort:1.15.0.2
	rel-7-4-0:1.15
	rel-7-2-6:1.14
	rel-7-2-4:1.13
	rel-7-2-2:1.3
	rel-7-2-0:1.2;
locks; strict;
comment	@# @;


1.23
date	2007.12.04.22.43.45;	author brlcad;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.04.19.54.06;	author brlcad;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.08.15.46.06;	author brlcad;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.26.23.32.26;	author brlcad;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.20.13.57.25;	author brlcad;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.18.06.46.11;	author brlcad;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.01.08.54.23;	author brlcad;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.22.17.36.02;	author brlcad;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.16.11.34.53;	author brlcad;	state Exp;
branches
	1.15.6.1;
next	1.14;

1.14
date	2005.06.06.16.58.22;	author brlcad;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.12.05.51.43;	author brlcad;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.12.05.31.24;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.12.04.39.51;	author brlcad;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.12.04.15.00;	author brlcad;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.12.04.12.43;	author brlcad;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.12.03.31.37;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.11.00.51.44;	author brlcad;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.10.20.54.05;	author brlcad;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.07.04.41.19;	author brlcad;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.06.06.44.15;	author brlcad;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.11.14.15.47;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.31.04.16.17;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.30.04.21.35;	author brlcad;	state Exp;
branches;
next	;

1.15.6.1
date	2005.11.13.13.46.10;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.23
log
@bah, convert the du size to megabytes for hdiutil, otherwise just caps out at a gb
@
text
@#!/bin/sh
#                     M A K E _ D M G . S H
# BRL-CAD
#
# Copyright (c) 2005-2007 United States Government as represented by
# the U.S. Army Research Laboratory.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following
# disclaimer in the documentation and/or other materials provided
# with the distribution.
#
# 3. The name of the author may not be used to endorse or promote
# products derived from this software without specific prior written
# permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
###
#
# Script for generating a Mac OS X disk mounting image (.dmg) from a
# clean installation. The script should generate a .dmg that works on
# 10.2+ but may require a recent version of Mac OS X to successfully
# generate the disk mounting image.
#
# Author: Christopher Sean Morrison
#
######################################################################

NAME="$1"
VERSION="$2"
if [ "x$NAME" = "x" ] ; then
    echo "Usage: $0 title version [background] [contents ...]"
    echo "ERROR: must specify a title for the package name"
    exit 1
fi
if [ "x$VERSION" = "x" ] ; then
    echo "Usage: $0 title version [background] [contents ...]"
    echo "ERROR: must specify a version"
    exit 1
fi
shift 2

OPENUP=`dirname $0`/../misc/macosx/openUp

PATH=/bin:/usr/bin:/usr/sbin
LC_ALL=C
umask 002

# TMPDIR=/tmp
if [ "x$TMPDIR" = "x" ] || [ ! -w $TMPDIR ] ; then
    if [ -w /usr/tmp ] ; then
	TMPDIR=/usr/tmp
    elif [ -w /var/tmp ] ; then
	TMPDIR=/var/tmp
    elif [ -w /tmp ] ; then
	TMPDIR=/tmp
    else
	TMPDIR=.
    fi
fi

DMG_NAME="${NAME}-${VERSION}"
DMG="${DMG_NAME}.dmg"
if [ -d "$DMG" ] ; then
    echo "ERROR: there is a directory of same name in the way of creating $DMG"
    exit 1
fi
if [ -f "$DMG" ] ; then
    remove=""
    while [ "x$remove" = "x" ] ; do
	echo "WARNING: the disk mounting image ($DMG) already exists, remove it?"
	echo -n "yes/no? "
	read remove
	case x$remove in
	    x[yY][eE][sS])
		remove=yes
		;;
	    x[yY])
		remove=yes
		;;
	    x[nN][oO])
		remove=no
		;;
	    x[nN])
		remove=no
		;;
	    *)
		remove=""
		;;
	esac
    done

    if [ "x$remove" = "xyes" ] ; then
	rm -f "$DMG"
    fi
    if [ -f "$DMG" ] ; then
	echo "ERROR: cannot continue with $DMG in the way"
	exit 1
    fi
fi

if [ -f "${DMG}.sparseimage" ] ; then
    rm -f "${DMG}.sparseimage"
    if [ ! "x$?" = "x0" ] ; then
	echo "ERROR: unable to successfully remove the previous ${DMG}.sparseimage"
	exit 1
    fi
    if [ -f "${DMG}.sparseimage" ] ; then
	echo "ERROR: ${DMG}.sparseimage is in the way"
	exit 1
    fi
fi

PKG="${DMG_NAME}.pkg"
if [ -d "$PKG" ] ; then
    :
elif [ -d "/tmp/$PKG" ] ; then
    PKG="/tmp/${DMG_NAME}.pkg"
fi

# calculate capacity required
DMG_CAPACITY=50
while [ ! "x$*" = "x" ] ; do
    ARG="$1"
    shift
    size="`du -ks $ARG | awk '{print $1}'`"
    size="`echo \"$size 1024 / p\" | dc`"
    DMG_CAPACITY="`expr $DMG_CAPACITY + $size`"
done

hdiutil create "$DMG" -megabytes $DMG_CAPACITY -layout NONE -type SPARSE -volname $DMG_NAME
if [ ! "x$?" = "x0" ] ; then
    echo "ERROR: hdiutil failed to complete successfully"
    exit 1
fi
if [ ! -f "${DMG}.sparseimage" ] ; then
    echo "ERROR: hdiutil failed to create ${DMG}.sparseimage"
    exit 1
fi

hdidDisk=`hdid -nomount "${DMG}.sparseimage" | head -n 1 | grep '/dev/disk[0-9]*' | awk '{print $1}'`
if [ ! "x$?" = "x0" ] ; then
    echo "ERROR: unable to successfully get the hdid device name"
    exit 1
fi
if [ "x$hdidDisk" = "x" ] ; then
    echo "ERROR: unable to get the hdid device name"
    exit 1
fi

/sbin/newfs_hfs -v ${DMG_NAME} -b 4096 $hdidDisk
if [ ! "x$?" = "x0" ] ; then
    echo "ERROR: unable to successfully create a new hfs filesystem on $hdidDisk"
    exit 1
fi

hdiutil eject $hdidDisk
if [ ! "x$?" = "x0" ] ; then
    echo "ERROR: unable to successfully eject $hdidDisk"
    exit 1
fi

VOL_DIR="/Volumes/${DMG_NAME}"
if [ -d "$VOL_DIR" ] ; then
    echo "ERROR: there is already a disk mounted at $VOL_DIR"
    exit 1
fi

hdidMountedDisk=`hdid ${DMG}.sparseimage | head -n 1 | grep '/dev/disk[0-9]*' | awk '{print $1}'`
if [ ! "x$?" = "x0" ] ; then
    echo "ERROR: unable to successfully get the mounted hdid device name"
    exit 1
fi
if [ "x$hdidMountedDisk" = "x" ] ; then
    echo "ERROR: unable to get the mounted hdid device name"
    exit 1
fi

timeout=20
while [ $timeout -gt 0 ] ; do
    if [ -d "$VOL_DIR" ] ; then
	timeout=1
    fi
    timeout="`expr $timeout - 1`"
    sleep 1
done
if [ ! -d "$VOL_DIR" ] ; then
    echo "ERROR: timed out waiting for $DMG to mount"
    hdiutil eject $hdidMountedDisk
    exit 1
fi

if [ -d "$PKG" ] ; then
    if [ ! -r "$PKG" ] ; then
	echo "ERROR: unable to read the installer package"
	hdiutil eject $hdidMountedDisk
	exit 1
    fi

    cp -pR "$PKG" "${VOL_DIR}/."
    if [ ! "x$?" = "x0" ] ; then
	echo "ERROR: unable to successfully copy $PKG to $VOL_DIR"
	hdiutil eject $hdidMountedDisk
	exit 1
    fi
fi

found_background=no
while [ ! "x$*" = "x" ] ; do
    ARG="$1"
    shift

    if [ ! -r "$ARG" ] ; then
	if [ ! -f "$ARG" ] ; then
	    echo "ERROR: specified content ($ARG) does not exist"
	    hdiutil eject $hdidMountedDisk
	    exit 1
	fi
	echo "ERROR: specified content ($ARG) is not readable"
	hdiutil eject $hdidMountedDisk
	exit 1
    fi

    argname="`basename $ARG`"
    if [ "x$argname" = "x" ] ; then
	echo "ERROR: unable to determine the $ARG base name"
	hdiutil eject $hdidMountedDisk
	exit 1
    fi

    if [ -d "$ARG" ] ; then
	cp -pR "$ARG" "${VOL_DIR}/."
	if [ ! "x$?" = "x0" ] ; then
	    echo "ERROR: unable to successfully copy $ARG to $VOL_DIR"
	    hdiutil eject $hdidMountedDisk
	    exit 1
	fi
	if [ ! -d "${VOL_DIR}/${argname}" ] ; then
	    echo "ERROR: $argname failed to copy to the disk image"
	    hdiutil eject $hdidMountedDisk
	    exit 1
	fi

    elif [ -f "$ARG" ] ; then

	cp -p "$ARG" "${VOL_DIR}/."
	if [ ! "x$?" = "x0" ] ; then
	    echo "ERROR: unable to successfully copy $ARG to $VOL_DIR"
	    hdiutil eject $hdidMountedDisk
	    exit 1
	fi
	if [ ! -f "${VOL_DIR}/${argname}" ] ; then
	    echo "ERROR: $argname failed to copy to the disk image"
	    hdiutil eject $hdidMountedDisk
	    exit 1
	fi

	for dstore in DS_Store .DS_Store ; do
	    if [ "x$argname" = "x$dstore" ] ; then
		if [ ! -f "${VOL_DIR}/.DS_Store" ] ; then
		    mv "${VOL_DIR}/$dstore" "${VOL_DIR}/.DS_Store"
		    if [ ! "x$?" = "x0" ] ; then
			echo "ERROR: unable to successfully move $dstore to .DS_Store"
			hdiutil eject $hdidMountedDisk
			exit 1
		    fi
		    if [ -f "${VOL_DIR}/DS_Store" ] ; then
			echo "ERROR: unable to move $dstore to .DS_Store"
			hdiutil eject $hdidMountedDisk
			exit 1
		    fi
		fi
	    fi
	done

	if [ "x$found_background" = "xno" ] ; then
	    background="`echo $argname | sed 's/^[bB][aA][cC][kK][gG][rR][oO][uU][nN][dD]\.[a-zA-Z][a-zA-Z][a-zA-Z]*$/__bg__/'`"
	    if [ "x$background" = "x__bg__" ] ; then
		found_background="$argname"
	    fi
	fi
    else
	echo "ERROR: $ARG does not exist as a file or directory (sanity check)"
	hdiutil eject $hdidMountedDisk
	exit 1
    fi
done

if [ ! "x$found_background" = "xno" ] ; then
    echo "You now have 60 seconds to set the background on the disk image."
fi
osascript <<EOF
set oldApp to (path to frontmost application as string)
tell application "Finder"
    activate
    make new Finder window
    set target of Finder window 1 to disk "$DMG_NAME"

--    set imageFile to file "$found_background" of disk "$DMG_NAME"

    tell Finder window 1
	set toolbar visible to false
	set zoomed to false
	set bounds to {0, 0, 512, 320}
	set position to {10, 54}
	set current view to icon view

	tell its icon view options
	    set icon size to 96
	    set arrangement to arranged by kind
	    try
-- only 10.4
--              set background picture to imageFile
	    end try
	end tell
    end tell

    tell application "System Events"
	keystroke "j" using command down
    end tell

    say "You now have one minute to set a background on the disk image."
    delay 60

    tell application "System Events"
	keystroke "j" using command down
    end tell

    update disk "$DMG_NAME"
    close window 1
end tell
tell application oldApp
	activate
end tell
EOF
if [ ! "x$?" = "x0" ] ; then
    echo "ERROR: unable to run osascript successfully to set initial window properties"
    hdiutil eject $hdidMountedDisk
    exit 1
fi

if [ ! "x$found_background" = "xno" ] ; then
    if [ -x /Developer/Tools/SetFile ] ; then
	if [ -f "${VOL_DIR}/${found_background}" ] ; then
	    /Developer/Tools/SetFile -a V "${VOL_DIR}/${found_background}"
	    if [ ! "x$?" = "x0" ] ; then
		echo "ERROR: unable to successfully set $found_background invisible"
		hdiutil eject $hdidMountedDisk
		exit 1
	    fi
	fi
    fi
fi

if [ -x "$OPENUP" ] ; then
    $OPENUP "${VOL_DIR}/."
    if [ ! "x$?" = "x0" ] ; then
	echo "ERROR: sanity check failure -- unexpected error returned from $OPENUP ($?)"
	hdiutil eject $hdidMountedDisk
	exit 1
    fi
fi

# "recreate" a new Finder window via the open command and set the
# parameters again before detaching as a last-ditch effort to make the
# parameters stick.
open "/Volumes/$DMG_NAME"
osascript <<EOF
set oldApp to (path to frontmost application as string)
tell application "Finder"
    activate
    tell Finder window 1
	set toolbar visible to false
	set zoomed to false
	set bounds to {0, 0, 512, 320}
	set position to {10, 54}
	set current view to icon view
    end tell
    update disk "$DMG_NAME"
    delay 2
    close window 1
end tell
EOF
if [ ! "x$?" = "x0" ] ; then
    echo "ERROR: unable to run osascript successfully (again) to set window properties"
    hdiutil eject $hdidMountedDisk
    exit 1
fi

hdiutil eject $hdidMountedDisk
if [ ! "x$?" = "x0" ] ; then
    echo "ERROR: unable to successfully eject $hdidMountedDisk"
    exit 1
fi

# UDCO for pre 10.2
hdiutil convert "${DMG}.sparseimage" -o "$DMG" -format UDZO -imagekey zlib-level=9
if [ ! "x$?" = "x0" ] ; then
    echo "ERROR: unable to successfully compress $DMG via hdiutil convert"
    exit 1
fi
if [ ! -f "$DMG" ] ; then
    echo "ERROR: hdiutil failed to compress ${DMG}.sparseimage to $DMG"
    exit 1
fi

rm "${DMG}.sparseimage"
if [ ! "x$?" = "x0" ] ; then
    echo "ERROR: unable to successfully remove the ${DMG}.sparseimage temporary"
    exit 1
fi
if [ -f "${DMG}.sparseimage" ] ; then
    echo "ERROR: the ${DMG}.sparseimage temporary still exists"
    exit 1
fi


# Local Variables:
# mode: sh
# tab-width: 8
# sh-indentation: 4
# sh-basic-offset: 4
# indent-tabs-mode: t
# End:
# ex: shiftwidth=4 tabstop=8
@


1.22
log
@update the helper build scripts to the new version variables now that MAJOR_, MINOR_, and PATCH_ are no longer being individually subst'd.  simplify them to only require a single version number in triplet form instead of separated out individually (only mac make_pkg script needed it broken up anyways).
@
text
@d145 1
a147 2
pkg_size="`du -ks $PKG | awk '{print $1}'`"
DMG_CAPACITY="`expr $DMG_CAPACITY + $pkg_size`"
@


1.21
log
@dynamically calculate the size that the DMG needs to be (since the 7.10.4 release already surpassed the 250MB barrier) .. and give me at least a minute to find that background image :)
@
text
@d48 1
a48 3
MAJOR_VERSION="$2"
MINOR_VERSION="$3"
PATCH_VERSION="$4"
d50 1
a50 1
    echo "Usage: $0 title major_version minor_version patch_version [background] [contents ...]"
d54 3
a56 3
if [ "x$MINOR_VERSION" = "x" ] ; then
    echo "Usage: $0 title major_version minor_version patch_version [background] [contents ...]"
    echo "ERROR: must specify a major package version"
d59 1
a59 11
if [ "x$MINOR_VERSION" = "x" ] ; then
    echo "ERROR: must specify a minor package version"
    echo "Usage: $0 title major_version minor_version patch_version [background] [contents ...]"
    exit 1
fi
if [ "x$PATCH_VERSION" = "x" ] ; then
    echo "Usage: $0 title major_version minor_version patch_version [background] [contents ...]"
    echo "ERROR: must specify a patch package version"
    exit 1
fi
shift 4
a79 1
VERSION="${MAJOR_VERSION}.${MINOR_VERSION}.${PATCH_VERSION}"
@


1.20
log
@ws
@
text
@a72 1
DMG_CAPACITY=250
d145 18
d183 1
a183 1
/sbin/newfs_hfs -w -v ${DMG_NAME} -b 4096 $hdidDisk
a224 6
PKG="${DMG_NAME}.pkg"
if [ -d "$PKG" ] ; then
    :
elif [ -d "/tmp/$PKG" ] ; then
    PKG="/tmp/${DMG_NAME}.pkg"
fi
d322 1
a322 1
    echo "You now have 30 seconds to set the background on the disk image."
d354 2
a355 2
    say "You now have half a minute to set a background on the disk image."
    delay 30
@


1.19
log
@update copyright to 2007
@
text
@d108 1
a108 1
	        remove=yes
d111 1
a111 1
	        remove=yes
d114 1
a114 1
	        remove=no
d117 1
a117 1
	        remove=no
d334 1
a334 1
--		set background picture to imageFile
@


1.18
log
@update copyright to 2006
@
text
@d5 1
a5 1
# Copyright (c) 2005-2006 United States Government as represented by
@


1.17
log
@presume posix behavior in the tools, accepting a modified version of stefan fiedler's e-mailed patch.  solaris is known to have issues but that should not be relevant to this script at all
@
text
@d5 1
a5 1
# Copyright (c) 2005 United States Government as represented by
@


1.16
log
@ws
@
text
@d156 1
a156 1
hdidDisk=`hdid -nomount "${DMG}.sparseimage" | head -1 | grep '/dev/disk[0-9]*' | awk '{print $1}'`
d184 1
a184 1
hdidMountedDisk=`hdid ${DMG}.sparseimage | head -1 | grep '/dev/disk[0-9]*' | awk '{print $1}'`
@


1.15
log
@reorder the applescript and add an update and secondary method to attempt to force the window bounds and position
@
text
@d15 1
a15 1
# 2. Redistributions in binary form must reproduce the above 
@


1.15.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d15 1
a15 1
# 2. Redistributions in binary form must reproduce the above
d156 1
a156 1
hdidDisk=`hdid -nomount "${DMG}.sparseimage" | head -n 1 | grep '/dev/disk[0-9]*' | awk '{print $1}'`
d184 1
a184 1
hdidMountedDisk=`hdid ${DMG}.sparseimage | head -n 1 | grep '/dev/disk[0-9]*' | awk '{print $1}'`
@


1.14
log
@with a little applescripting, set the Finder window parameters and allow time for the background image to be set since there's no apparent programmatic means to set the background image automatically yet (10.4 might).  also, fix the path to the openUp tool.
@
text
@d310 3
d314 1
d316 1
d320 1
a320 1
--  set imageFile to file "$found_background" of disk "$DMG_NAME"
a337 7
end tell
EOF
if [ ! "x$?" = "x0" ] ; then
    echo "ERROR: unable to run osascript successfully to set window properties"
    hdiutil eject $hdidMountedDisk
    exit 1
fi
d339 1
a339 8
if [ ! "x$found_background" = "xno" ] ; then
    echo "You now have one minute to set the background on the disk image."
    osascript <<EOF
set oldApp to (path to frontmost application as string)
tell application "Finder"
    activate
end tell
tell application "System Events"
d341 6
a346 4
end tell
say "You now have one minute to set the background on the disk image."
delay 60
tell application "System Events"
d348 4
a355 1

d357 5
a361 5
    if [ ! "x$?" = "x0" ] ; then
	echo "ERROR: unable to run osascript to set window background"
	hdiutil eject $hdidMountedDisk
	exit 1
    fi
d363 1
d385 26
@


1.13
log
@screw the .background .. there can be only one
@
text
@d74 1
a74 1
OPENUP=`dirname $0`/misc/macosx/openUp
d248 1
d261 1
d275 1
d279 4
a282 5
	if [ "x$found_background" = "xno" ] ; then
	    background="`echo $argname | sed 's/^[bB][aA][cC][kK][gG][rR][oO][uU][nN][dD]\.[a-zA-Z][a-zA-Z][a-zA-Z]*$/__bg__/'`"
	    if [ "x$background" = "x__bg__" ] ; then
		if [ -x /Developer/Tools/SetFile ] ; then
		    /Developer/Tools/SetFile -a V "${VOL_DIR}/${argname}"
d284 6
a289 1
			echo "ERROR: unable to successfully set $argname invisible"
a292 1
		    found_background=yes
d295 7
d310 69
d383 1
d387 1
a387 1
    
@


1.12
log
@run openUp on the volume so that OS X 10.2 will automatically open the directory in Finder when mounted.  while we're at it, make sure a disk with the same name we're trying is not already mounted
@
text
@d229 1
d276 3
a278 5
	background="`echo $argname | sed 's/^[bB][aA][cC][kK][gG][rR][oO][uU][nN][dD]\.[a-zA-Z][a-zA-Z][a-zA-Z]*$/__bg__/'`"
	if [ "x$background" = "x__bg__" ] ; then

	    if [ ! -f "${VOL_DIR}/.background" ] ; then

d286 1
a286 21
		fi

		cp -p "${VOL_DIR}/$argname" "${VOL_DIR}/.background"
		if [ ! "x$?" = "x0" ] ; then
		    echo "ERROR: unable to successfully copy $argname to .background"
		    hdiutil eject $hdidMountedDisk
		    exit 1
		fi
		if [ ! -f "${VOL_DIR}/.background" ] ; then
		    echo "ERROR: unable to copy the background image to .background on the disk image"
		    hdiutil eject $hdidMountedDisk
		    exit 1
		fi
		
		if [ -x /Developer/Tools/SetFile ] ; then
		    /Developer/Tools/SetFile -a V "${VOL_DIR}/.background"
		    if [ ! "x$?" = "x0" ] ; then
			echo "ERROR: unable to successfully set .background invisible"
			hdiutil eject $hdidMountedDisk
			exit 1
		    fi
@


1.11
log
@the engrish was suckish, so make it slightly less suckish
@
text
@d74 1
d178 6
a194 1
VOL_DIR="/Volumes/${DMG_NAME}"
d318 8
@


1.10
log
@try to fit on a 250 zip
@
text
@d39 3
a41 3
# clean installation. The script should work on 10.2+, this script
# itself though, may require a recent version for some of the hdiutil
# options.
a50 2
DMG_CAPACITY=250

d73 2
@


1.9
log
@search /usr/sbin too
@
text
@d51 1
a51 1
DMG_CAPACITY=650
@


1.8
log
@ensure the environment by overriding the path, the locale, and the umask.  search for a suitable tmpdir.
@
text
@d75 1
a75 1
PATH=/bin:/usr/bin
@


1.7
log
@a pkg in the build directory takes precedence over one in /tmp
@
text
@d75 16
a90 5
#if [ "x`id -u`" != "x0" ] ; then
#    echo "This script requires superuser privileges, restarting via sudo"
#    sudo "$0" "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9"
#    exit $?
#fi
a144 1
echo hdiutil create "$DMG" -megabytes $DMG_CAPACITY -layout NONE -type SPARSE -volname $DMG_NAME
a317 10
#mv "$DMG" "${DMG}.prep.dmg"
#if [ ! "x$?" = "x0" ] ; then
#    echo "ERROR: unable to successfully rename $DMG to ${DMG}.prep.dmg"
#    exit 1
#fi
#if [ ! -f "${DMG}.prep.dmg" ] ; then
#    echo "ERROR: failed to rename $DMG to ${DMG}.prep.dmg"
#    exit 1
#fi

@


1.6
log
@improvement to set the background image, find the alternate pkg dir in /tmp, and create a sparse dmg image instead of a fixed-size dmg.
@
text
@d193 3
a195 1
if [ -d "/tmp/$PKG" ] ; then
@


1.5
log
@SWEET! It now has the basic components and will create a DMG on demand.  It still does not do anything with the background image yes thought it does detect it.  The script also does not run misc/macosx/openUp yet either.  Still, sweet progress.
@
text
@d39 3
a41 2
# clean installation.  The dmg should be compatible with all versions
# of the autodiskmount daemon (tested on 10.2 and 10.3).
d51 1
a51 1
DMG_CAPACITY=100
d82 2
a83 1
DMG="${NAME}-${VERSION}.dmg"
d122 14
a135 1
hdiutil create "$DMG" -megabytes $DMG_CAPACITY -layout NONE
d140 2
a141 2
if [ ! -f "$DMG" ] ; then
    echo "ERROR: hdiutil failed to create $DMG"
d145 1
a145 1
hdidDisk=`hdid -nomount "$DMG" | head -1 | grep '/dev/disk[0-9]*' | awk '{print $1}'`
d155 1
a155 1
/sbin/newfs_hfs -w -v ${NAME}-${VERSION} -b 4096 $hdidDisk
d167 1
a167 1
hdidMountedDisk=`hdid $DMG | head -1 | grep '/dev/disk[0-9]*' | awk '{print $1}'`
d178 1
a178 1
VOL_DIR="/Volumes/${NAME}-${VERSION}"
d188 1
d192 6
a197 3
PKG_NAME="${NAME}-${VERSION}.pkg"
if [ -d "${PKG_NAME}" ] ; then
    if [ ! -r "${PKG_NAME}" ] ; then
d203 1
a203 1
    cp -pR "$PKG_NAME" "${VOL_DIR}/."
d205 1
a205 1
	echo "ERROR: unable to successfully copy $PKG_NAME to $VOL_DIR"
d226 6
d239 5
d252 4
d257 34
a290 5
	filename="`basename $ARG`"
	if [ ! "x$filename" = "x" ] ; then
	    background="`echo $filename | sed 's/^[bB][aA][cC][kK][gG][rR][oO][uU][nN][dD]\.[a-zA-Z][a-zA-Z][a-zA-Z]*$/__bg__/'`"
	    if [ "x$background" = "x__bg__" ] ; then
		echo "$ARG is a background"
d306 9
a314 9
mv "$DMG" "${DMG}.prep.dmg"
if [ ! "x$?" = "x0" ] ; then
    echo "ERROR: unable to successfully rename $DMG to ${DMG}.prep.dmg"
    exit 1
fi
if [ ! -f "${DMG}.prep.dmg" ] ; then
    echo "ERROR: failed to rename $DMG to ${DMG}.prep.dmg"
    exit 1
fi
d316 2
a317 1
hdiutil convert "${DMG}.prep.dmg" -format UDCO -o "$DMG"
d323 1
a323 1
    echo "ERROR: hdiutil failed to compress ${DMG}.prep.dmg to $DMG"
d327 1
a327 1
rm "${DMG}.prep.dmg"
d329 1
a329 1
    echo "ERROR: unable to successfully remove the ${DMG}.prep.dmg temporary"
d332 2
a333 2
if [ -f "${DMG}.prep.dmg" ] ; then
    echo "ERROR: the ${DMG}.prep.dmg temporary still exists"
@


1.4
log
@initial stub of a dmg script with potential to actually do something useful
@
text
@d50 1
a50 1
BACKGROUND="$5"
d53 1
a53 1
    echo "Usage: $0 title major_version minor_version patch_version [background]"
d58 1
a58 1
    echo "Usage: $0 title major_version minor_version patch_version [background]"
d64 1
a64 1
    echo "Usage: $0 title major_version minor_version patch_version [background]"
d68 1
a68 1
    echo "Usage: $0 title major_version minor_version patch_version [background]"
d72 1
a72 6
if [ ! "x$BACKGROUND" = "x" ] ; then
    if [ ! -r "$BACKGROUND" ] ; then
	echo "ERROR: specified content (${BACKGROUND}) is not readable"
	exit 1
    fi
fi
d81 95
d177 73
a249 2
if [ ! -d "${PKG_NAME}" ] ; then
    echo "ERROR: unable to locate the installer package"
d253 19
a271 2
DMG_NAME="${NAME}-${VERSION}.dmg"
echo "creating $DMG_NAME"
@


1.3
log
@provide more arguments to the dmg script
@
text
@d38 3
a40 3
# Script for generating a Mac OS X Installer package (.pkg) from a
# clean package installation.  The package should be compatible with
# old and new versions of Installer.
d50 1
a50 1
CONTENT="$5"
d53 2
a54 2
    echo "Usage: $0 title major_version minor_version patch_version [content]"
    echo "ERROR: must specify a package name"
d58 1
a58 1
    echo "Usage: $0 title major_version minor_version patch_version [content]"
d64 1
a64 1
    echo "Usage: $0 title major_version minor_version patch_version [content]"
d68 1
a68 1
    echo "Usage: $0 title major_version minor_version patch_version [content]"
d72 5
a76 4
if [ "x$ARCHIVE" = "x" ] ; then
    echo "Usage: $0 title major_version minor_version patch_version [content]"
    echo "ERROR: must specify an archive directory"
    exit 1
d78 11
a88 2
if [ ! -r "$CONTENT" ] ; then
    echo "ERROR: specified content (${CONTENT}) is not readable"
d92 2
a93 8
if [ "x`id -u`" != "x0" ] ; then
    echo "This script requires superuser privileges, restarting via sudo"
    sudo "$0" "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9"
    exit $?
fi

VERSION="${MAJOR_VERSION}.${MINOR_VERSION}.${PATCH_VERSION}"
DMG_NAME="${NAME}-${VERSION}"
@


1.2
log
@headers and footers
@
text
@d37 54
@


1.1
log
@initial stub script to make a package distribution
@
text
@d2 44
@

