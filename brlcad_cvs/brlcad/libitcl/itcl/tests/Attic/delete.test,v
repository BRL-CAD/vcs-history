head	1.2;
access;
symbols
	ansi-20040405-merged:1.1.6.1
	postmerge-20040405-ansi:1.1
	premerge-20040404-ansi:1.1
	postmerge-autoconf:1.1
	autoconf-freeze:1.1.4.1
	premerge-autoconf:1.1
	postmerge-20040315-windows:1.1
	premerge-20040315-windows:1.1
	windows-20040315-freeze:1.1.2.1
	autoconf-branch:1.1.0.4
	windows-branch:1.1.0.2
	ansi-branch:1.1.0.6;
locks; strict;
comment	@# @;


1.2
date	2004.05.21.18.05.53;	author morrison;	state dead;
branches;
next	1.1;

1.1
date	2004.03.09.20.48.58;	author morrison;	state Exp;
branches
	1.1.2.1
	1.1.4.1
	1.1.6.1;
next	;

1.1.2.1
date	2004.03.12.09.57.56;	author morrison;	state Exp;
branches;
next	;

1.1.4.1
date	2004.03.15.14.06.37;	author erikg;	state Exp;
branches;
next	;

1.1.6.1
date	2004.03.17.21.17.38;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.2
log
@moved from top-level to src/other/.
@
text
@#
# Tests for deleting classes and objects
# ----------------------------------------------------------------------
#   AUTHOR:  Michael J. McLennan
#            Bell Labs Innovations for Lucent Technologies
#            mmclennan@@lucent.com
#            http://www.tcltk.com/itcl
#
#      RCS:  $Id: delete.test,v 1.1 2004/03/09 20:48:58 morrison Exp $
# ----------------------------------------------------------------------
#            Copyright (c) 1993-1998  Lucent Technologies, Inc.
# ======================================================================
# See the file "license.terms" for information on usage and
# redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES.

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2.1
    namespace import -force ::tcltest::test
}

::tcltest::loadTestedCommands

# ----------------------------------------------------------------------
#  Deleting classes and objects
# ----------------------------------------------------------------------
test delete-1.1 {define a simple classes with inheritance} {
    itcl::class test_delete_base {
        variable num 0
        method show {} {
            return $num
        }
    }
} ""

test delete-1.2 {create some base class objects} {
    for {set i 0} {$i < 5} {incr i} {
        test_delete_base #auto
    }
    lsort [itcl::find objects -class test_delete_base]
} {test_delete_base0 test_delete_base1 test_delete_base2 test_delete_base3 test_delete_base4}

test delete-1.3 {delete the base class--class and all objects go away} {
    list [itcl::delete class test_delete_base] \
         [itcl::find classes test_delete_base] \
         [namespace children :: test_delete_base] \
         [namespace which -command test_delete_base] \
         [itcl::find objects test_delete_base*]
} {{} {} {} {} {}}

# ----------------------------------------------------------------------
#  Deleting classes and objects with inheritance
# ----------------------------------------------------------------------
test delete-2.1 {define a simple classes with inheritance} {
    variable ::test_delete_watch ""
    itcl::class test_delete_base {
        variable num 0
        method show {} {
            return $num
        }
        destructor {
            global ::test_delete_watch
            lappend test_delete_watch $this
        }
    }
    itcl::class test_delete {
        inherit test_delete_base
        method show {} {
            return ">$num<"
        }
    }
} ""

test delete-2.2 {create some base and derived class objects} {
    for {set i 0} {$i < 3} {incr i} {
        test_delete_base #auto
    }
    for {set i 0} {$i < 3} {incr i} {
        test_delete #auto
    }
    lsort [itcl::find objects -isa test_delete_base]
} {test_delete0 test_delete1 test_delete2 test_delete_base0 test_delete_base1 test_delete_base2}

test delete-2.3 {delete the base class--class and all objects go away} {
    list [itcl::delete class test_delete_base] \
         [itcl::find classes test_delete*] \
         [namespace children :: test_delete*] \
         [namespace which -command test_delete_base] \
         [namespace which -command test_delete] \
         [itcl::find objects test_delete*]
} {{} {} {} {} {} {}}

test delete-2.4 {object destructors get invoked properly} {
    lsort $test_delete_watch
} {::test_delete0 ::test_delete1 ::test_delete2 ::test_delete_base0 ::test_delete_base1 ::test_delete_base2}

# ----------------------------------------------------------------------
#  Deleting class namespaces
# ----------------------------------------------------------------------
test delete-3.1 {redefine classes with inheritance} {
    variable ::test_delete_watch ""
    itcl::class test_delete_base {
        variable num 0
        method show {} {
            return $num
        }
        destructor {
            global test_delete_watch
            lappend test_delete_watch $this
        }
    }
    itcl::class test_delete {
        inherit test_delete_base
        method show {} {
            return ">$num<"
        }
    }
} ""

test delete-3.2 {create some base and derived class objects} {
    for {set i 0} {$i < 3} {incr i} {
        test_delete_base #auto
    }
    for {set i 0} {$i < 3} {incr i} {
        test_delete #auto
    }
    lsort [itcl::find objects -isa test_delete_base]
} {test_delete0 test_delete1 test_delete2 test_delete_base0 test_delete_base1 test_delete_base2}

test delete-3.3 {deleting a class namespace is like deleting a class} {
    list [namespace delete test_delete_base] \
         [itcl::find classes test_delete*] \
         [namespace children :: test_delete*] \
         [namespace which -command test_delete_base] \
         [namespace which -command test_delete] \
         [itcl::find objects test_delete*]
} {{} {} {} {} {} {}}

test delete-3.4 {object destructors get invoked, even during catastrophe} {
    lsort $test_delete_watch
} {::test_delete0 ::test_delete1 ::test_delete2 ::test_delete_base0 ::test_delete_base1 ::test_delete_base2}

# ----------------------------------------------------------------------
#  Self-destructing objects
# ----------------------------------------------------------------------
test basic-4.1 {define a class where objects destroy themselves} {
    itcl::class test_delete {
        public variable x ""
        public variable deletecommand ""
        constructor {args} {
            eval configure $args
        }
        destructor {
            eval $deletecommand
        }
        method killme {code} {
            itcl::delete object $this
            eval $code
        }
    }
} {}

test basic-4.2 {an object can delete itself} {
    set obj [test_delete #auto -x "data stays"]
    list [$obj killme {return $x}] [itcl::find objects -isa test_delete]
} {{data stays} {}}

test basic-4.3 {the "this" variable becomes null after delete} {
    set obj [test_delete #auto]
    list [$obj killme {return $this}] [itcl::find objects -isa test_delete]
} {{} {}}

test basic-4.4 {an object being destructed can't be deleted} {
    set obj [test_delete #auto -deletecommand {itcl::delete object $this}]
    list [catch {itcl::delete object $obj} msg] $msg
} {1 {can't delete an object while it is being destructed}}

namespace delete test_delete

# ----------------------------------------------------------------------
#  Delete objects using path names and scoped values
# ----------------------------------------------------------------------
test basic-5.1 {define a simple class} {
    itcl::class test_delete_name {
        private variable x 0
        method test {x} {
            return $x
        }
    }
} {}

test basic-5.2 {delete using a qualified name} {
    namespace eval test_delete2 {test_delete_name #auto}
    set cmd {itcl::delete object test_delete2::test_delete_name0}
    list [catch $cmd msg] $msg [itcl::find objects -isa test_delete_name]
} {0 {} {}}

test basic-5.3 {delete using a scoped value} {
    set obj [namespace eval test_delete2 {itcl::code [test_delete_name #auto]}]
    set cmd [list itcl::delete object $obj]
    list [catch $cmd msg] $msg [itcl::find objects -isa test_delete_name]
} {0 {} {}}

test basic-5.4 {scoped command names are decoded properly} {
    list [catch {itcl::delete object {namespace inscope ::xyzzy xxx}} msg] $msg \
         [catch {itcl::delete object {namespace inscope :: xxx yyy}} msg] $msg \
         [catch {itcl::delete object {namespace inscope :: xyzzy}} msg] $msg
} {1 {unknown namespace "::xyzzy"} 1 {malformed command "namespace inscope :: xxx yyy": should be "namespace inscope namesp command"} 1 {object "namespace inscope :: xyzzy" not found}}

namespace delete test_delete_name test_delete2

::tcltest::cleanupTests
return
@


1.1
log
@initial addition of libitcl synced to current itcl cvs (3.3 development)
@
text
@d9 1
a9 1
#      RCS:  $Id: delete.test,v 1.4 2004/02/12 18:09:50 davygrvy Exp $
@


1.1.6.1
log
@sync branch with HEAD
@
text
@d9 1
a9 1
#      RCS:  $Id$
@


1.1.4.1
log
@merge from head
@
text
@d9 1
a9 1
#      RCS:  $Id: delete.test,v 1.1 2004/03/09 20:48:58 morrison Exp $
@


1.1.2.1
log
@merge from HEAD
@
text
@d9 1
a9 1
#      RCS:  $Id$
@

