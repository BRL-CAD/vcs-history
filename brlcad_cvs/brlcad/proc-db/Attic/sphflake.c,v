head	11.22;
access;
symbols
	ansi-20040405-merged:11.17.2.2
	postmerge-20040405-ansi:11.20
	premerge-20040404-ansi:11.19
	postmerge-autoconf:11.19
	autoconf-freeze:11.19
	premerge-autoconf:11.19
	postmerge-20040315-windows:11.19
	premerge-20040315-windows:11.19
	windows-20040315-freeze:11.17.4.1
	autoconf-20031203:11.19
	autoconf-20031202:11.19
	autoconf-branch:11.19.0.2
	phong-branch:11.17.0.8
	photonmap-branch:11.17.0.6
	rel-6-1-DP:11.17
	windows-branch:11.17.0.4
	rel-6-0-2:11.15
	ansi-branch:11.17.0.2
	rel-6-0-1-branch:11.15.0.2
	hartley-6-0-post:11.16
	hartley-6-0-pre:11.15
	rel-6-0-1:11.15
	rel-6-0:11.14
	rel-5-4:11.9
	offsite-5-3-pre:11.12
	rel-5-3:11.9
	rel-5-2:11.9
	rel-5-1-branch:11.9.0.2
	rel-5-1:11.9
	rel-5-0:11.8
	rel-5-0-beta:11.8;
locks; strict;
comment	@ * @;


11.22
date	2004.05.21.17.33.46;	author morrison;	state dead;
branches;
next	11.21;

11.21
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.20;

11.20
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2003.09.11.20.41.28;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2003.09.11.20.28.09;	author morrison;	state Exp;
branches;
next	11.17;

11.17
date	2002.08.20.17.08.35;	author jra;	state Exp;
branches
	11.17.2.1
	11.17.4.1
	11.17.8.1;
next	11.16;

11.16
date	2002.08.15.20.55.46;	author hartley;	state Exp;
branches;
next	11.15;

11.15
date	2002.05.17.12.42.24;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2001.08.11.13.17.46;	author butler;	state Exp;
branches;
next	11.13;

11.13
date	2001.04.20.22.31.15;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2000.08.24.04.48.36;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.07.12.21.59.08;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.07.10.23.35.40;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.03.31.03.07.32;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.01.20.06.23.29;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	99.01.15.23.53.02;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	98.12.31.05.29.57;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	98.12.30.08.25.05;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	98.12.18.18.37.46;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	98.12.16.04.01.57;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	98.07.06.12.26.41;	author jlowens;	state Exp;
branches;
next	11.1;

11.1
date	98.07.01.17.17.24;	author jlowens;	state Exp;
branches;
next	;

11.17.2.1
date	2002.09.19.18.02.13;	author morrison;	state Exp;
branches;
next	11.17.2.2;

11.17.2.2
date	2004.03.17.21.22.55;	author morrison;	state Exp;
branches;
next	;

11.17.4.1
date	2004.03.10.15.06.37;	author morrison;	state Exp;
branches;
next	;

11.17.8.1
date	2003.09.13.18.02.23;	author butler;	state Exp;
branches;
next	;


desc
@@


11.22
log
@moved to src/proc-db/
@
text
@/*
  TITLE: sphflake1.c 
  
  AUTHOR: Jason Owens
  
  DESCRIPTION: Program to create a sphere-flake utilizing libwdb
  
  */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "wdb.h" 

#define D2R(x) (((x)/180)*3.14159265358979)
#define MATXPNT(d, m, v) { \
  register double _i = 1.0/((m)[12]*(v)[0] + (m)[13]*(v)[1] + (m)[14]*(v)[2] + (m)[15]*1); \
	      (d)[0] = ((m)[0]*(v)[0] + (m)[1]*(v)[1] + (m)[2]*(v)[2] + (m)[3])*_i; \
              (d)[1] = ((m)[4]*(v)[0] + (m)[5]*(v)[1] + (m)[6]*(v)[2] + (m)[7])*_i; \
              (d)[2] = ((m)[8]*(v)[0] + (m)[9]*(v)[1] + (m)[10]*(v)[2] + (m)[11])*_i; \
}


#define DEFAULT_FILENAME "sflake.g"
#define DEFAULT_MAXRADIUS 1000
#define DEFAULT_MAXDEPTH 3
#define DEFAULT_DELTARADIUS .3
#define DEFAULT_ORIGIN_X 0
#define DEFAULT_ORIGIN_Y 0
#define DEFAULT_ORIGIN_Z 0

#define DEFAULT_MAT "mirror"
#define DEFAULT_MATPARAM "sh=50 sp=.7 di=.3 re=.5"
#define DEFAULT_MATCOLOR "80 255 255"
#define DEFAULT_SCALE 10.3
#define ADDITIONAL_OBJECTS 5
#define SCENE_ID 0
#define LIGHT0_ID 1
#define LIGHT0_MAT "light"
#define LIGHT0_MATPARAM "inten=10000 shadows=1"
#define LIGHT0_MATCOLOR "255 255 255"
#define LIGHT1_ID 2
#define LIGHT1_MAT "light"
#define LIGHT1_MATPARAM "inten=5000 shadows=1 fract=.5"
#define LIGHT1_MATCOLOR "255 255 255" 
#define PLANE_ID 3
#define PLANE_MAT "stack"
#define PLANE_MATPARAM "checker; plastic sh=20 sp=.1 di=.9"
#define PLANE_MATCOLOR "255 255 255"
#define ENVIRON_ID 4
#define ENVIRON_MAT "envmap"
#define ENVIRON_MATPARAM "cloud"

#define MAX_INPUT_LENGTH 48

extern char *optarg;
extern int optind, opterr, getopt(int, char *const *, const char *);

struct depthMat { 
  char name[MAX_INPUT_LENGTH];
  char params[MAX_INPUT_LENGTH];
  unsigned char color[3];
};
typedef struct depthMat depthMat_t;

struct params {
  char fileName[MAX_INPUT_LENGTH];
  int  maxRadius;
  int  maxDepth;
  double deltaRadius;
  point_t pos;
  depthMat_t *matArray;
};
typedef struct params params_t;

int count = 0; /* global sphere count */
struct rt_wdb *fp;
mat_t IDENT;

/* make the wmember structs, in order to produce individual     
   combinations so we can have separate materials among differing
   depths */
struct wmember *wmemberArray;

/* the vector directions, in which the flakes will be drawn */
/* theta,phi */
int dir[9][2] = {  {0,-90},
		   {60,-90},
		   {120,-90},
		   {180,-90},
		   {240,-90},
		   {300,-90},
		   {120,-30},
		   {240,-30},
		   {360,-30} };

/****** Function Prototypes ******/
BU_EXTERN(void initializeInfo, (params_t *p, int inter, char *name, int depth));
BU_EXTERN(void createSphereflake, (params_t *p));
BU_EXTERN(void createLights, (params_t *p));
BU_EXTERN(void createPlane, (params_t *p));
BU_EXTERN(void createScene, (params_t *p));
BU_EXTERN(void createEnvironMap, (params_t *p));
BU_EXTERN(void getYRotMat, (mat_t *mat, fastf_t theta));
BU_EXTERN(void getZRotMat, (mat_t *mat, fastf_t phi));
BU_EXTERN(void getTrans, (mat_t *trans, int i, int j, fastf_t v)); 
BU_EXTERN(void makeFlake, (int depth, mat_t *trans, point_t center, fastf_t radius, double delta, int maxDepth));
BU_EXTERN(void usage, (char *n));


int main(int argc, char **argv)
{
  int i;
  int optc;

  params_t params;

  int inter = 0;
  char fileName[MAX_INPUT_LENGTH];
  int depth;

  memset(fileName, 0, MAX_INPUT_LENGTH);
  depth = DEFAULT_MAXDEPTH;
  strncpy(fileName, DEFAULT_FILENAME, MAX_INPUT_LENGTH);

  opterr = 0;

  while ( (optc = getopt( argc, argv, "hHiIDd:f:F:" )) != -1 ) {
    switch (optc) {
    case 'I' :
    case 'i' : /* interactive mode */
      inter = 1;
      break;
    case 'D':  /* Use ALL default parameters */
      memset(fileName, 0, MAX_INPUT_LENGTH);
      strncpy(fileName, DEFAULT_FILENAME, MAX_INPUT_LENGTH);
      depth = DEFAULT_MAXDEPTH;
      break;
    case 'd':  /* Use a user-defined depth */
      depth = atoi(optarg);
      if (depth > 5) {
	printf("\nWARNING: Depths greater than 5 produce extremely large numbers of objects.\n");
      }
      break;
    case 'F':
    case 'f':  /* Use a user-defined filename */
      memset(fileName, 0, MAX_INPUT_LENGTH);
      strncpy(fileName, optarg, MAX_INPUT_LENGTH);
      break;
    case 'h':
    case 'H':
    case '?':
      usage(argv[0]);
      exit(0);
    default:
      break;
    }
  }
  if (optind <= 1) {
    printf("Using all default parameters. Try %s -h for assistance\n", argv[0]);
    inter = 0;
  }
  
  initializeInfo(&params, inter, fileName, depth);
  
  /* now open a file for outputting the database */
  fp = wdb_fopen(params.fileName);
  
  /* create the initial id */
  i = mk_id_units(fp, "SphereFlake", "mm");
  
  /* initialize the wmember structs... 
     this is for creating the regions */
  wmemberArray = (struct wmember *)malloc(sizeof(struct wmember)
					  *(params.maxDepth+1+ADDITIONAL_OBJECTS));
  for (i = 0; i <= params.maxDepth+ADDITIONAL_OBJECTS; i++) {
    BU_LIST_INIT(&(wmemberArray[i].l));
  }
  
  /****** Create the SphereFlake ******/
  
  createSphereflake(&params);
  
  /* 
     now that the entire sphereflake has been created, we can create the 
     additional objects needed to complete the scene.
     */
  /****** Create the Lights ******/
  
  createLights(&params);
  
  /****** Create the Plane ******/
  
  createPlane(&params);
  
  /****** Create the Environment map ******/
  
  createEnvironMap(&params);
  
  /****** Create the entire Scene combination ******/
  
  createScene(&params);
  
  wdb_close(fp);
  
  return 0;
}

void usage(char *n)
{
  printf(
	 "\nUSAGE: %s -D -d# -i -f fileName\n\
          D -- use default parameters\n\
          d -- set the recursive depth of the procedure\n\
          i -- use interactive mode\n\
          f -- specify output file\n\n", n);
}

void initializeInfo(params_t *p, int inter, char *name, int depth)
{
  char input[MAX_INPUT_LENGTH];
  int i = 0;
  int len = 0;
  unsigned int c[3];

  if (name == NULL) {
    strncpy(p->fileName, DEFAULT_FILENAME, MAX_INPUT_LENGTH);
  }
  else {
    strncpy(p->fileName, name, MAX_INPUT_LENGTH);
  }
  p->maxRadius = DEFAULT_MAXRADIUS;
  p->maxDepth =  (depth > 0) ? (depth) : (DEFAULT_MAXDEPTH);
  p->deltaRadius = DEFAULT_DELTARADIUS;
  p->pos[X] = DEFAULT_ORIGIN_X;
  p->pos[Y] = DEFAULT_ORIGIN_Y;
  p->pos[Z] = DEFAULT_ORIGIN_Z;

  p->matArray = (depthMat_t *)malloc(sizeof(depthMat_t) * (p->maxDepth+1));

  for (i = 0; i <= p->maxDepth; i++) {
    strncpy(p->matArray[i].name, DEFAULT_MAT, MAX_INPUT_LENGTH);
    strncpy(p->matArray[i].params, DEFAULT_MATPARAM, MAX_INPUT_LENGTH);
    sscanf(DEFAULT_MATCOLOR, "%u %u %u", &(c[0]), &(c[1]), &(c[2]));
    p->matArray[i].color[0] = c[0];
    p->matArray[i].color[1] = c[1];
    p->matArray[i].color[2] = c[2];
  }

  if (inter) {
    /* prompt the user for some data */
    /* no error checking here.... */
    printf("\nPlease enter a filename for sphereflake output: [%s] ", p->fileName);
    if (! fgets(input, MAX_INPUT_LENGTH, stdin) ) {
      fprintf(stderr, "sphereflake: initializeInfo: fgets filename read error.\n");
      fprintf(stderr, "Continuing with default value.\n");
    }
    else {
      len = strlen(input);
      if ((len > 0) && (input[len-1] == '\n')) input[len-1] = 0;
      if (strncmp(input, "", MAX_INPUT_LENGTH) != 0) { 
	sscanf(input, "%s", p->fileName);
      }
    }
    fflush(stdin);
    
    printf("Initial position X Y Z: [%.2f %.2f %.2f] ", p->pos[X], p->pos[Y], p->pos[Z]);
    if (! fgets(input, MAX_INPUT_LENGTH, stdin) ) {
      fprintf(stderr, "sphereflake: initializeInfo: fgets position read error.\n");
      fprintf(stderr, "Continuing with default values.\n");
    }
    else {
      len = strlen(input);
      if ((len > 0) && (input[len-1] == '\n')) input[len-1] = 0;
      if (strncmp(input, "", MAX_INPUT_LENGTH) == 0) {
	sscanf(input, "%lg %lg %lg", &(p->pos[X]), &(p->pos[Y]), &(p->pos[Z]));
      }
    }
    fflush(stdin);
    
    printf("maxRadius: [%d] ", p->maxRadius);
    if (! fgets(input, MAX_INPUT_LENGTH, stdin) ) {
      fprintf(stderr, "sphereflake: initializeInfo: fgets maxradius read error.\n");
      fprintf(stderr, "Continuing with default value.\n");
    }
    else {
      len = strlen(input);
      if ((len > 0) && (input[len-1] == '\n')) input[len-1] = 0;
      if (strncmp(input, "", MAX_INPUT_LENGTH) != 0) {
	sscanf(input, "%d", &(p->maxRadius));
      }
    }
    fflush(stdin);

    printf("deltaRadius: [%.2f] ", p->deltaRadius);
    if (! fgets(input, MAX_INPUT_LENGTH, stdin) ) {
      fprintf(stderr, "sphereflake: initializeInfo: fgets deltaradius read error.\n");
      fprintf(stderr, "Continuing with default value.\n");
    }
    else {
      len = strlen(input);
      if ((len > 0) && (input[len-1] == '\n')) input[len-1] = 0;
      if (strncmp(input, "", MAX_INPUT_LENGTH) != 0) {
	sscanf(input, "%lg", &(p->deltaRadius));
      }
    }
    fflush(stdin);

    printf("maxDepth: [%d] ", p->maxDepth);
    if (! fgets(input, MAX_INPUT_LENGTH, stdin) ) {
      fprintf(stderr, "sphereflake: initializeInfo: fgets maxdepth read error.\n");
      fprintf(stderr, "Continuing with default value.\n");
    } 
    else {
      len = strlen(input);
      if ((len > 0) && (input[len-1] == '\n')) input[len-1] = 0;
      if (strncmp(input, "", MAX_INPUT_LENGTH) != 0) {
	sscanf(input, "%d", &(p->maxDepth));
      }
    }
    fflush(stdin);

    
    for (i = 0; i <= p->maxDepth; i++) {
      printf("Material for depth %d: [%s] ", i, p->matArray[i].name);
      if ( ! fgets(input, MAX_INPUT_LENGTH, stdin) ) {
	fprintf(stderr, "sphereflake: initializeInfo: fgets material read error.\n");
	fprintf(stderr, "Continuing with default value.\n");
      }
      else {
	len = strlen(input);
	if ((len > 0) && (input[len-1] == '\n')) input[len-1] = 0;
	if (strncmp(input, "", MAX_INPUT_LENGTH) != 0) {
	  sscanf(input, "%s", p->matArray[i].name);
	}
      }
      fflush(stdin);

      printf("Mat. params for depth %d: [%s] ", i, p->matArray[i].params);
      if ( ! fgets(input, MAX_INPUT_LENGTH, stdin) ) {
	fprintf(stderr, "sphereflake: initializeInfo: fgets params read error.\n");
	fprintf(stderr, "Continuing with default value.\n");
      }
      else {
	len = strlen(input);
	if ((len > 0) && (input[len-1] == '\n')) input[len-1] = 0;
	if (strncmp(input, "", MAX_INPUT_LENGTH) != 0) {
	  sscanf(input, "%s", p->matArray[i].params);
	}
      }
      fflush(stdin);

      printf("Mat. color for depth %d: [%d %d %d] ", i, p->matArray[i].color[0], p->matArray[i].color[1], p->matArray[i].color[2]);
      if (! fgets(input, MAX_INPUT_LENGTH, stdin) ) {
	fprintf(stderr, "sphereflake: initializeInfo: fgets color read error.\n");
	fprintf(stderr, "Continuing with default values.\n");
      }
      else {
	len = strlen(input);
	if ((len > 0) && (input[len-1] == '\n')) input[len-1] = 0;
	if (strncmp(input, "", MAX_INPUT_LENGTH) != 0) {
	  sscanf(input, "%d %d %d", (int *)&(c[0]), (int *)&(c[1]), (int *)&(c[2]));
	  p->matArray[i].color[0] = c[0];
	  p->matArray[i].color[1] = c[1];
	  p->matArray[i].color[2] = c[2];
	}
      }
      fflush(stdin);
    }
  }
  MAT_IDN(IDENT);
}

void createSphereflake(params_t *p)
{
  mat_t trans;
  char name[MAX_INPUT_LENGTH];
  int i = 0;
  
  /* now begin the creation of the sphereflake... */
  MAT_IDN(trans); /* get the identity matrix */
  makeFlake(0, &trans, p->pos, (fastf_t)p->maxRadius * DEFAULT_SCALE, p->deltaRadius, p->maxDepth);
  /* 
     Now create the depth combinations/regions
     This is done to facilitate application of different
     materials to the different depths */

  for (i = 0; i <= p->maxDepth; i++) {
    memset(name, 0, MAX_INPUT_LENGTH);
    sprintf(name, "depth%d.r", i);
    mk_lcomb(fp, name, &(wmemberArray[i+ADDITIONAL_OBJECTS]), 1, p->matArray[i].name, p->matArray[i].params, p->matArray[i].color, 0);
  }
  printf("\nSphereFlake created");
  
}

void createLights(params_t *p)
{
  char name[MAX_INPUT_LENGTH];
  point_t lPos;
  int r, g, b;
  unsigned char c[3];
  
  
  /* first create the light spheres */
  VSET(lPos, p->pos[X]+(5 * p->maxRadius), p->pos[Y]+(-5 * p->maxRadius), p->pos[Z]+(150 * p->maxRadius));
  memset(name, 0, MAX_INPUT_LENGTH);
  sprintf(name, "light0");
  mk_sph(fp, name, lPos, p->maxRadius*5);
  
  /* now make the light region... */
  mk_addmember(name, &(wmemberArray[LIGHT0_ID].l), NULL, WMOP_UNION);
  strcat(name, ".r");
  sscanf(LIGHT0_MATCOLOR, "%d %d %d", &r, &g, &b);
  c[0] = (char)r;
  c[1] = (char)g;
  c[2] = (char)b;
  mk_lcomb(fp, name, &(wmemberArray[LIGHT0_ID]), 1, LIGHT0_MAT, LIGHT0_MATPARAM,
	   (const unsigned char *) c, 0);
  
  VSET(lPos, p->pos[X]+(13 * p->maxRadius), p->pos[Y]+(-13 * p->maxRadius), p->pos[Z]+(152 * p->maxRadius));
  sprintf(name, "light1");
  mk_sph(fp, name, lPos, p->maxRadius*5);
  
  /* now make the light region... */
  mk_addmember(name, &(wmemberArray[LIGHT1_ID].l), NULL, WMOP_UNION);
  strcat(name, ".r");
  sscanf(LIGHT1_MATCOLOR, "%d %d %d", &r, &g, &b);
  c[0] = (char)r;
  c[1] = (char)g;
  c[2] = (char)b;
  mk_lcomb(fp, name, &(wmemberArray[LIGHT1_ID]), 1, LIGHT1_MAT, LIGHT1_MATPARAM,
	   (const unsigned char *) c, 0);
  
  printf("\nLights created");
}

void createPlane(params_t *p)
{
  char name[MAX_INPUT_LENGTH];
  point_t lPos;
  
  VSET(lPos, 0, 0, 1); /* set the normal */
  memset(name, 0, MAX_INPUT_LENGTH);
  sprintf(name, "plane");
  mk_half(fp, name, lPos, -p->maxRadius * 2 * DEFAULT_SCALE);
  
  /* now make the plane region... */
  mk_addmember(name, &(wmemberArray[PLANE_ID].l), NULL, WMOP_UNION);
  strcat(name, ".r");
  mk_lcomb(fp, name, &(wmemberArray[PLANE_ID]), 1, PLANE_MAT, PLANE_MATPARAM, (unsigned char *)PLANE_MATCOLOR, 0);
  
  printf("\nPlane created");
}

void createEnvironMap(params_t *p)
{
  char name[MAX_INPUT_LENGTH];
  
  memset(name, 0, MAX_INPUT_LENGTH);
  sprintf(name, "light0");
  mk_addmember(name, &(wmemberArray[ENVIRON_ID].l), NULL, WMOP_UNION);
  memset(name, 0, MAX_INPUT_LENGTH);
  sprintf(name, "environ.r");
  mk_lcomb(fp, name, &(wmemberArray[ENVIRON_ID]), 1, ENVIRON_MAT, ENVIRON_MATPARAM, (unsigned char *)"0 0 0", 0);
  
  printf("\nEnvironment map created");
  
}

void createScene(params_t *p)
{
  int i;
  char name[MAX_INPUT_LENGTH];
  
  for (i = 0; i < p->maxDepth+1; i++) {
    memset(name, 0, MAX_INPUT_LENGTH);
    sprintf(name, "depth%d.r", i);
    mk_addmember(name, &(wmemberArray[SCENE_ID].l), NULL, WMOP_UNION);
  }
  mk_addmember("light0.r", &(wmemberArray[SCENE_ID].l), NULL, WMOP_UNION);
  mk_addmember("light1.r", &(wmemberArray[SCENE_ID].l), NULL, WMOP_UNION);
  mk_addmember("plane.r", &(wmemberArray[SCENE_ID].l), NULL, WMOP_UNION);
  mk_addmember("environ.r", &(wmemberArray[SCENE_ID].l), NULL, WMOP_UNION);
  memset(name, 0, MAX_INPUT_LENGTH);
  sprintf(name, "scene.r");
  mk_lfcomb(fp, name, &(wmemberArray[SCENE_ID]), 0);
  
  printf("\nScene created (FILE: %s)\n", p->fileName);
}

void printMatrix(char *n, fastf_t *m)
{
  int i = 0;
  printf("\n-----%s------\n", n);
  for (i = 0; i < 16; i++) {
    if (i%4 == 0 && i != 0) printf("\n");
    printf("%6.2f ", m[i]);
  }
  printf("\n-----------\n");
}

void getTrans(mat_t (*t), int theta, int phi, fastf_t radius)
{
  mat_t z;
  mat_t y;
  mat_t toRelative;
  mat_t newPos;
  MAT_IDN(z);
  MAT_IDN(y);
  MAT_IDN(newPos);
  MAT_IDN(toRelative);
  
  MAT_DELTAS(toRelative, 0, 0, radius);
  
  getZRotMat(&z, theta);
  getYRotMat(&y, phi);
  
  bn_mat_mul2(toRelative, newPos); /* translate to new position */
  bn_mat_mul2(y, newPos);          /* rotate z */
  bn_mat_mul2(z, newPos);          /* rotate y */
  MAT_DELTAS(*t, 0,0,0);
  bn_mat_mul2(*t, newPos);
  
  memcpy(*t, newPos, sizeof(newPos));
}

void getYRotMat(mat_t (*t), fastf_t theta)
{
  fastf_t sin_ = sin(D2R(theta));
  fastf_t cos_ = cos(D2R(theta));
  mat_t r;
  MAT_ZERO(r);
  r[0] = cos_;
  r[2] = sin_;
  r[5] = 1;
  r[8] = -sin_;
  r[10] = cos_;
  r[15] = 1;
  memcpy(*t, r, sizeof(*t));
}

void getZRotMat(mat_t (*t), fastf_t phi)
{
  fastf_t sin_ = sin(D2R(phi));
  fastf_t cos_ = cos(D2R(phi));
  mat_t r;
  MAT_ZERO(r);
  r[0] = cos_;
  r[1] = -sin_;
  r[4] = sin_;
  r[5] = cos_;
  r[10] = 1;
  r[15] = 1;
  memcpy(*t, r, sizeof(*t));
}

/*
void makeFlake(int depth, mat_t *trans, point_t center, fastf_t radius, float delta, int maxDepth)
*/


void makeFlake(int depth, mat_t (*trans), fastf_t *center, fastf_t radius, double delta, int maxDepth)
{
  char name[MAX_INPUT_LENGTH];
  int i = 0;
  point_t pcent;
  fastf_t newRadius;
  mat_t temp;
  point_t origin;
  point_t pcentTemp;
  
  VSET(origin, 0, 0, 0);
  
  /* just return if depth == maxDepth */
  if (depth > maxDepth) return;
  
  
  /* create self, then recurse for each different angle */
  count++;
  sprintf(name, "sph%d", count);
  mk_sph(fp, name, center, radius);
  newRadius = radius*delta;
  
  /* add the sphere to the correct combination */
  mk_addmember(name, &(wmemberArray[depth+ADDITIONAL_OBJECTS].l), NULL, WMOP_UNION);
  
  for (i = 0; i < 9; i++) {
    memcpy(temp, trans, sizeof(temp));
    getTrans(&temp, dir[i][0], dir[i][1], radius+newRadius);
    MATXPNT(pcentTemp, temp, origin);
    VADD2(pcent, pcentTemp, center);
    makeFlake(depth+1, &temp, pcent, newRadius, delta, maxDepth);
  }
}
@


11.21
log
@change conf.h to a wrapped config.h
@
text
@@


11.20
log
@merge of ansi-6-0-branch into head
@
text
@d10 5
a14 1
#include "conf.h"
@


11.19
log
@more testing
@
text
@d64 1
a64 1
extern int optind, opterr, getopt();
d226 1
a226 5
void initializeInfo(p, inter, name, depth)
     params_t *p;
     int inter;
     char *name;
     int depth;
d381 1
a381 2
void createSphereflake(p)
     params_t *p;
d404 1
a404 2
void createLights(p)
     params_t *p;
d445 1
a445 2
void createPlane(p)
     params_t *p;
d463 1
a463 2
void createEnvironMap(p)
     params_t *p;
d478 1
a478 2
void createScene(p)
     params_t *p;
d499 1
a499 3
void printMatrix(n, m)
     char *n;
     mat_t m;
d510 1
a510 5
void getTrans(t, theta, phi, radius)
     mat_t *t;
     int theta;
     int phi;
     fastf_t radius;
d535 1
a535 3
void getYRotMat(t, theta)
     mat_t *t;
     fastf_t theta;
d550 1
a550 3
void getZRotMat(t, phi)
     mat_t *t;
     fastf_t phi;
d570 1
a570 7
void makeFlake(depth, trans, center, radius, delta, maxDepth)
     int depth;
     mat_t *trans;
     point_t center;
     fastf_t radius;
     double delta;
     int maxDepth;
@


11.18
log
@dummy test
@
text
@d216 1
a216 2
void usage(n)
     char *n;
@


11.17
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@a9 1

d118 1
a118 3
int main(argc, argv)
     int argc;
     char **argv;
@


11.17.4.1
log
@merge in updates from HEAD
@
text
@d10 1
d119 3
a121 1
int main(int argc, char **argv)
d219 2
a220 1
void usage(char *n)
@


11.17.8.1
log
@Merged head into branch
@
text
@d10 1
d119 3
a121 1
int main(int argc, char **argv)
d219 2
a220 1
void usage(char *n)
@


11.17.2.1
log
@Initial ANSIfication
@
text
@d65 1
a65 1
extern int optind, opterr, getopt(int, char *const *, const char *);
d119 3
a121 1
int main(int argc, char **argv)
d219 2
a220 1
void usage(char *n)
d230 5
a234 1
void initializeInfo(params_t *p, int inter, char *name, int depth)
d389 2
a390 1
void createSphereflake(params_t *p)
d413 2
a414 1
void createLights(params_t *p)
d455 2
a456 1
void createPlane(params_t *p)
d474 2
a475 1
void createEnvironMap(params_t *p)
d490 2
a491 1
void createScene(params_t *p)
d512 3
a514 1
void printMatrix(char *n, fastf_t *m)
d525 5
a529 1
void getTrans(mat_t (*t), int theta, int phi, fastf_t radius)
d554 3
a556 1
void getYRotMat(mat_t (*t), fastf_t theta)
d571 3
a573 1
void getZRotMat(mat_t (*t), fastf_t phi)
d593 7
a599 1
void makeFlake(int depth, mat_t (*trans), fastf_t *center, fastf_t radius, double delta, int maxDepth)
@


11.17.2.2
log
@sync branch with HEAD
@
text
@d10 1
@


11.16
log
@Converted from K&R to ANSI C - RFH
@
text
@d65 1
a65 1
extern int optind, opterr, getopt(int, char *const *, const char *);
d119 3
a121 1
int main(int argc, char **argv)
d219 2
a220 1
void usage(char *n)
d230 5
a234 1
void initializeInfo(params_t *p, int inter, char *name, int depth)
d389 2
a390 1
void createSphereflake(params_t *p)
d413 2
a414 1
void createLights(params_t *p)
d455 2
a456 1
void createPlane(params_t *p)
d474 2
a475 1
void createEnvironMap(params_t *p)
d490 2
a491 1
void createScene(params_t *p)
d512 3
a514 1
void printMatrix(char *n, fastf_t *m)
d525 5
a529 1
void getTrans(mat_t (*t), int theta, int phi, fastf_t radius)
d554 3
a556 1
void getYRotMat(mat_t (*t), fastf_t theta)
d571 3
a573 1
void getZRotMat(mat_t (*t), fastf_t phi)
d593 7
a599 1
void makeFlake(int depth, mat_t (*trans), fastf_t *center, fastf_t radius, double delta, int maxDepth)
@


11.15
log
@added matrix parameter to mk_addmember()
@
text
@d65 1
a65 1
extern int optind, opterr, getopt();
d119 1
a119 3
int main(argc, argv)
     int argc;
     char **argv;
d217 1
a217 2
void usage(n)
     char *n;
d227 1
a227 5
void initializeInfo(p, inter, name, depth)
     params_t *p;
     int inter;
     char *name;
     int depth;
d382 1
a382 2
void createSphereflake(p)
     params_t *p;
d405 1
a405 2
void createLights(p)
     params_t *p;
d446 1
a446 2
void createPlane(p)
     params_t *p;
d464 1
a464 2
void createEnvironMap(p)
     params_t *p;
d479 1
a479 2
void createScene(p)
     params_t *p;
d500 1
a500 3
void printMatrix(n, m)
     char *n;
     mat_t m;
d511 1
a511 5
void getTrans(t, theta, phi, radius)
     mat_t *t;
     int theta;
     int phi;
     fastf_t radius;
d536 1
a536 3
void getYRotMat(t, theta)
     mat_t *t;
     fastf_t theta;
d551 1
a551 3
void getZRotMat(t, phi)
     mat_t *t;
     fastf_t phi;
d571 1
a571 7
void makeFlake(depth, trans, center, radius, delta, maxDepth)
     int depth;
     mat_t *trans;
     point_t center;
     fastf_t radius;
     double delta;
     int maxDepth;
@


11.14
log
@misc comipler warning changes
@
text
@d429 1
a429 1
  mk_addmember(name, &(wmemberArray[LIGHT0_ID].l), WMOP_UNION);
d443 1
a443 1
  mk_addmember(name, &(wmemberArray[LIGHT1_ID].l), WMOP_UNION);
d467 1
a467 1
  mk_addmember(name, &(wmemberArray[PLANE_ID].l), WMOP_UNION);
d481 1
a481 1
  mk_addmember(name, &(wmemberArray[ENVIRON_ID].l), WMOP_UNION);
d499 1
a499 1
    mk_addmember(name, &(wmemberArray[SCENE_ID].l), WMOP_UNION);
d501 4
a504 4
  mk_addmember("light0.r", &(wmemberArray[SCENE_ID].l), WMOP_UNION);
  mk_addmember("light1.r", &(wmemberArray[SCENE_ID].l), WMOP_UNION);
  mk_addmember("plane.r", &(wmemberArray[SCENE_ID].l), WMOP_UNION);
  mk_addmember("environ.r", &(wmemberArray[SCENE_ID].l), WMOP_UNION);
d622 1
a622 1
  mk_addmember(name, &(wmemberArray[depth+ADDITIONAL_OBJECTS].l), WMOP_UNION);
@


11.13
log
@CONST to const
@
text
@d377 1
a377 1
	  sscanf(input, "%d %d %d", &(c[0]), &(c[1]), &(c[2]));
d469 1
a469 1
  mk_lcomb(fp, name, &(wmemberArray[PLANE_ID]), 1, PLANE_MAT, PLANE_MATPARAM, PLANE_MATCOLOR, 0);
d484 1
a484 1
  mk_lcomb(fp, name, &(wmemberArray[ENVIRON_ID]), 1, ENVIRON_MAT, ENVIRON_MATPARAM, "0 0 0", 0);
@


11.12
log
@
mk_addmember
@
text
@d436 1
a436 1
	   (CONST unsigned char *) c, 0);
d450 1
a450 1
	   (CONST unsigned char *) c, 0);
@


11.11
log
@
Converted to use new version of LIBWDB.
@
text
@d429 1
a429 1
  mk_addmember(name, &(wmemberArray[LIGHT0_ID]), WMOP_UNION);
d443 1
a443 1
  mk_addmember(name, &(wmemberArray[LIGHT1_ID]), WMOP_UNION);
d467 1
a467 1
  mk_addmember(name, &(wmemberArray[PLANE_ID]), WMOP_UNION);
d481 1
a481 1
  mk_addmember(name, &(wmemberArray[ENVIRON_ID]), WMOP_UNION);
d499 1
a499 1
    mk_addmember(name, &(wmemberArray[SCENE_ID]), WMOP_UNION);
d501 4
a504 4
  mk_addmember("light0.r", &(wmemberArray[SCENE_ID]), WMOP_UNION);
  mk_addmember("light1.r", &(wmemberArray[SCENE_ID]), WMOP_UNION);
  mk_addmember("plane.r", &(wmemberArray[SCENE_ID]), WMOP_UNION);
  mk_addmember("environ.r", &(wmemberArray[SCENE_ID]), WMOP_UNION);
d622 1
a622 1
  mk_addmember(name, &(wmemberArray[depth+ADDITIONAL_OBJECTS]), WMOP_UNION);
@


11.10
log
@
raytrace.h before wdb.h
Eliminated use of db.h
@
text
@d85 1
a85 1
FILE *fp;
d177 1
a177 1
  fp = fopen(params.fileName, "w");
d214 1
a214 1
  fclose(fp);
@


11.9
log
@
Changed RT_ to BU_ / BN_
@
text
@d20 1
@


11.8
log
@Added some error checking to the interactive input mode.
Modified the way command-line args are handled.
Removed some redundant and/or unnecessary vars.
Modified the interactive input mode to include default values for
all input requested (previously only on the string level info).
@
text
@d186 1
a186 1
    RT_LIST_INIT(&(wmemberArray[i].l));
d544 3
a546 3
  mat_mul2(toRelative, newPos); /* translate to new position */
  mat_mul2(y, newPos);          /* rotate z */
  mat_mul2(z, newPos);          /* rotate y */
d548 1
a548 1
  mat_mul2(*t, newPos);
@


11.7
log
@updated fence and sphereflake to not use gets and use fgets instead.

the last character of the fgets is chomped off since it should be the
newline.
@
text
@d3 1
a3 1

d5 1
a5 1

d61 5
d67 2
a68 2
  char name[20];
  char params[50];
d74 1
a74 1
  char fileName[20];
a122 1
  extern char *optarg;
d124 1
d126 1
d128 10
a137 6
  int def = 0;
  int depth = 0;
  char fileName[20];
  int opts = 0;
  
  while ( (optc = getopt( argc, argv, "hiDd:f:" )) != -1 ) {
d139 1
a141 1
      opts = 1;
d144 3
a146 4
      def = 1;
      depth = 3;
      strcpy(fileName, DEFAULT_FILENAME);
      opts = 1;
a152 6
      if (def) {
	depth = 3;
	break;
      }
      strcpy(fileName, DEFAULT_FILENAME);
      opts = 1;
d154 1
d156 2
a157 2
      strcpy(fileName, optarg);
      opts = 1;
d160 1
d168 2
a169 2
  if (!opts) {
    printf("Using all defaults. Try %s -h\n", argv[0]);
a170 3
    def = 1;
    depth = 3;
    strcpy(fileName, DEFAULT_FILENAME);
a172 1
  
d235 1
a235 1
  char matName[20];
d237 3
a239 3
  int r, g, b;
  
  
d241 1
a241 1
    strcpy(p->fileName, DEFAULT_FILENAME);
d244 1
a244 1
    strcpy(p->fileName, name);
d247 1
a247 1
  p->maxDepth =  (depth != 0) ? (depth) : (DEFAULT_MAXDEPTH);
d256 6
a261 6
    strcpy(p->matArray[i].name, DEFAULT_MAT);
    strcpy(p->matArray[i].params, DEFAULT_MATPARAM);
    sscanf(DEFAULT_MATCOLOR, "%d %d %d", &r, &g, &b);
    p->matArray[i].color[0] = (char)r;
    p->matArray[i].color[1] = (char)g;
    p->matArray[i].color[2] = (char)b;
d267 13
a279 5
    if (name != NULL) {
      printf("\nPlease enter a filename: ");
      scanf("%s", p->fileName);
    } else
      strcpy(p->fileName, name);
d281 13
a293 9
    printf("maxRadius: ");
    scanf("%d", &(p->maxRadius));
    printf("maxDepth: ");
    scanf("%d", &(p->maxDepth));
    printf("deltaRadius: ");
    scanf("%lg", &(p->deltaRadius));
    printf("init. position X Y Z: ");
    scanf("%lg %lg %lg", &(p->pos[X]), &(p->pos[Y]), &(p->pos[Z]));
    getchar();
d295 42
d339 32
a370 20
      printf("Material for depth %d: [%s] ", i, DEFAULT_MAT);
      fgets(p->matArray[i].name, 20, stdin);
      if (strlen(p->matArray[i].name) > 0) p->matArray[i].name[strlen(p->matArray[i].name)-1] = 0;
      if (strcmp(p->matArray[i].name, "") == 0) {
	strcpy(p->matArray[i].name, DEFAULT_MAT);
      }
      printf("Mat. params for depth %d: [%s] ", i, DEFAULT_MATPARAM);
      fgets(p->matArray[i].params, 50, stdin);
      if (strlen(p->matArray[i].params) > 0) p->matArray[i].params[strlen(p->matArray[i].params)-1] = 0;
      if (strcmp(p->matArray[i].params, "") == 0) {
	strcpy(p->matArray[i].params, DEFAULT_MATPARAM);
      }
      printf("Mat. color for depth %d: [%s] ", i, DEFAULT_MATCOLOR);
      fgets(matName, 20, stdin);
      if (strlen(matName) > 0) matName[strlen(matName)-1] = 0;
      if (strcmp(matName, "") == 0) {
	sscanf(DEFAULT_MATCOLOR, "%d %d %d", &r, &g, &b);
	p->matArray[i].color[0] = (char)r;
	p->matArray[i].color[1] = (char)g;
	p->matArray[i].color[2] = (char)b;
d373 8
a380 4
	sscanf(matName, "%d %d %d", &r, &g, &b);
	p->matArray[i].color[0] = (char)r;
	p->matArray[i].color[1] = (char)g;
	p->matArray[i].color[2] = (char)b;
d382 1
d392 1
a392 1
  char name[20];
d404 1
a404 1
    memset(name, 0, 20);
d415 1
a415 1
  char name[20];
d418 1
a418 1
  char c[3];
d423 1
a423 1
  memset(name, 0, 20);
d457 1
a457 1
  char name[20];
d461 1
a461 1
  memset(name, 0, 20);
d476 1
a476 1
  char name[20];
d478 1
a478 1
  memset(name, 0, 20);
d481 1
a481 1
  memset(name, 0, 20);
d493 1
a493 1
  char name[20];
d496 1
a496 1
    memset(name, 0, 20);
d504 1
a504 1
  memset(name, 0, 20);
d600 1
a600 1
  char name[20];
@


11.6
log
@Fixed sphereflake.  There was some initialization needed/overlooked in one of the methods that was causing a segfault.
Also took care of the compiler/linker error given when k&r C was added (float->double).
@
text
@d285 2
a286 1
      gets(p->matArray[i].name);
d291 2
a292 1
      gets(p->matArray[i].params);
d297 2
a298 1
      gets(matName);
@


11.5
log
@Ported to SunOS 4.1.4
@
text
@d11 1
d19 1
d25 3
a27 3
  (d)[0] = ((m)[0]*(v)[0] + (m)[1]*(v)[1] + (m)[2]*(v)[2] + (m)[3])*_i; \
  (d)[1] = ((m)[4]*(v)[0] + (m)[5]*(v)[1] + (m)[6]*(v)[2] + (m)[7])*_i; \
  (d)[2] = ((m)[8]*(v)[0] + (m)[9]*(v)[1] + (m)[10]*(v)[2] + (m)[11])*_i; \
d54 2
a55 2
#define PLANE_MAT "stack checker; plastic"
#define PLANE_MATPARAM "sh=20 sp=.1 di=.9"
d58 2
a59 1
#define ENVIRON_MAT "envmap cloud"
d72 1
a72 1
  float deltaRadius;
d100 1
a100 1
BU_EXTERN(void initializeInfo, (params_t *p, int inter, int def, char *name, int depth));
d106 4
a109 4
BU_EXTERN(void getYRotMat, (mat_t *, fastf_t theta));
BU_EXTERN(void getZRotMat, (mat_t *, fastf_t phi));
BU_EXTERN(void getTrans, (mat_t *, int, int, fastf_t)); 
BU_EXTERN(void makeFlake, (int depth,mat_t *trans,point_t center, fastf_t radius, float delta,int maxDepth));
d113 3
a115 3
void main(argc, argv)
int argc;
char **argv;
d117 1
a117 1
  int i, j;
d126 1
a126 1

d172 2
a173 2
  initializeInfo(&params, inter, def, fileName, depth);
	   
d176 1
a176 1

d179 1
a179 1

d187 1
a187 1

d189 1
a189 1

d195 1
a195 1
  */
d197 1
a197 1

d201 1
a201 1

d203 1
a203 1

d207 1
a207 1

d211 1
a211 1

d214 1
a214 1
  return;
d218 1
a218 1
char *n;
d221 5
a225 5
"\nUSAGE: %s -D -d# -i -f fileName\n\
       D -- use default parameters\n\
       d -- set the recursive depth of the procedure\n\
       i -- use interactive mode\n\
       f -- specify output file\n\n", n);
d228 5
a232 6
void initializeInfo(p, inter, def, name, depth)
params_t *p;
int inter;
int def;
char *name;
int depth;
a235 1
  char c[3];
d237 2
a238 2


d251 12
d271 1
a271 1

d277 1
a277 1
    scanf("%f", &(p->deltaRadius));
d282 1
a282 2
    p->matArray = (depthMat_t *)malloc(sizeof(depthMat_t) * (p->maxDepth+1));

d314 1
a314 1
params_t *p;
d319 1
a319 1

d322 1
a322 1
  makeFlake(0, trans, p->pos, (fastf_t)p->maxRadius * DEFAULT_SCALE, p->deltaRadius, p->maxDepth);
d327 1
d329 1
d331 1
a331 2
    mk_lcomb(fp, name, &(wmemberArray[i+ADDITIONAL_OBJECTS]), 1, 
	     p->matArray[i].name, p->matArray[i].params, p->matArray[i].color,0);
d334 1
a334 1

d338 1
a338 1
params_t *p;
d345 1
a345 1

d348 1
d360 1
a360 1
	(CONST unsigned char *) c, 0);
d365 1
a365 1

d374 2
a375 2
	(CONST unsigned char *) c, 0);

d380 1
a380 1
params_t *p;
d384 1
a384 1

d386 1
d389 1
a389 1

d394 1
a394 1

d399 1
a399 1
params_t *p;
d403 1
d406 1
d408 2
a409 2
  mk_lcomb(fp, name, &(wmemberArray[ENVIRON_ID]), 1, ENVIRON_MAT, "", "0 0 0", 0);

d411 1
a411 1

d415 1
a415 1
params_t *p;
d419 1
a419 1

d421 1
d429 1
d432 1
a432 1

d437 2
a438 2
char *n;
mat_t m;
d450 4
a453 4
mat_t *t;
int theta;
int phi;
fastf_t radius;
d463 1
a463 1
 
d465 4
a468 4

  getZRotMat(z, theta);
  getYRotMat(y, phi);

d479 2
a480 2
mat_t *t;
fastf_t theta;
d496 2
a497 2
mat_t *t;
fastf_t phi;
d512 5
d518 6
a523 6
int depth;
mat_t *trans;
point_t center;
fastf_t radius;
float delta;
int maxDepth;
a529 1
  mat_t invTrans;
d532 1
a532 1

d534 1
a534 1

d537 2
a538 2


d544 1
a544 1

d547 1
a547 1

d550 1
a550 1
    getTrans(temp, dir[i][0], dir[i][1], radius+newRadius);
d553 1
a553 1
    makeFlake(depth+1, temp, pcent, newRadius, delta, maxDepth);
@


11.4
log
@*- fixed typo
@
text
@d16 1
d97 17
a113 14
void initializeInfo(params_t *p, int inter, int def, char *name, int depth);
void createSphereflake(params_t *p);
void createLights(params_t *p);
void createPlane(params_t *p);
void createScene(params_t *p);
void createEnvironMap(params_t *p);
void getYRotMat(mat_t *, fastf_t theta);
void getZRotMat(mat_t *, fastf_t phi);
void getTrans(mat_t *, int, int, fastf_t); 
void makeFlake(int depth,mat_t *trans,point_t center, fastf_t radius, float delta,int maxDepth);
void usage(char *n);


void main(int argc, char **argv) {
d214 18
a231 9
void usage(char *n) {
  printf("\nUSAGE: %s -D -d# -i -f fileName\n"
	   "       D -- use default parameters\n"
	   "       d -- set the recursive depth of the procedure\n"
	   "       i -- use interactive mode\n"
	 "       f -- specify output file\n\n", n);
}

void initializeInfo(params_t *p, int inter, int def, char *name, int depth) {
d301 3
a303 1
void createSphereflake(params_t *p) {
d310 1
a310 1
  makeFlake(0, &trans, p->pos, (fastf_t)p->maxRadius * DEFAULT_SCALE, p->deltaRadius, p->maxDepth);
d324 3
a326 1
void createLights(params_t *p) {
d345 2
a346 1
  mk_lcomb(fp, name, &(wmemberArray[LIGHT0_ID]), 1, LIGHT0_MAT, LIGHT0_MATPARAM, (const unsigned char *) c, 0);
d359 2
a360 1
  mk_lcomb(fp, name, &(wmemberArray[LIGHT1_ID]), 1, LIGHT1_MAT, LIGHT1_MATPARAM, (const unsigned char *) c, 0);
d365 3
a367 1
void createPlane(params_t *p) {
d383 3
a385 1
void createEnvironMap(params_t *p) {
d397 3
a399 1
void createScene(params_t *p) {
d417 4
a420 1
void printMatrix(char *n, mat_t m) {
d430 6
a435 1
void getTrans(mat_t *t, int theta, int phi, fastf_t radius) {
d447 2
a448 2
  getZRotMat(&z, theta);
  getYRotMat(&y, phi);
d459 4
a462 1
void getYRotMat(mat_t *t, fastf_t theta) {
d476 4
a479 1
void getZRotMat(mat_t *t, fastf_t phi) {
d493 8
a500 4
void makeFlake(int depth, mat_t *trans, 
	       point_t center, 
	       fastf_t radius, float delta, 
	       int maxDepth) {
d527 1
a527 1
    getTrans(&temp, dir[i][0], dir[i][1], radius+newRadius);
d530 1
a530 1
    makeFlake(depth+1, &temp, pcent, newRadius, delta, maxDepth);
@


11.3
log
@Made some changes to get it to compile
@
text
@d115 2
a116 2
  def = 0;
  depth = 0;
@


11.2
log
@Corrected a bug.
@
text
@d21 1
a21 1
  register _i = 1.0/((m)[12]*(v)[0] + (m)[13]*(v)[1] + (m)[14]*(v)[2] + (m)[15]*1); \
d114 3
a116 1
  int inter = 0, def = 0, depth = 0;
a236 8
  for (i = 0; i <= p->maxDepth; i++) {
    strcpy(p->matArray[i].name, DEFAULT_MAT);
    strcpy(p->matArray[i].params, DEFAULT_MATPARAM);
    sscanf(DEFAULT_MATCOLOR, "%d %d %d", &r, &g, &b);
    p->matArray[i].color[0] = (char)r;
    p->matArray[i].color[1] = (char)g;
    p->matArray[i].color[2] = (char)b;
  }
d243 1
a243 2
    }
    else 
d245 1
d253 1
a253 1
    scanf("%d %d %d", &(p->pos[X]), &(p->pos[Y]), &(p->pos[Z]));
d257 1
d328 1
a328 1
  mk_lcomb(fp, name, &(wmemberArray[LIGHT0_ID]), 1, LIGHT0_MAT, LIGHT0_MATPARAM, c, 0);
d341 1
a341 1
  mk_lcomb(fp, name, &(wmemberArray[LIGHT1_ID]), 1, LIGHT1_MAT, LIGHT1_MATPARAM, c, 0);
a489 18


















@


11.1
log
@Program to generate a sphereflake. CF Hearn & Baker p.533 2nd Ed. '97
@
text
@d230 1
a230 1
  p->maxDepth =  DEFAULT_MAXDEPTH;
a288 3
  }
  if (depth != 0) {
    p->maxDepth = depth;
@
