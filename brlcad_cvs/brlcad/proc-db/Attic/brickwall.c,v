head	11.8;
access;
symbols
	ansi-20040405-merged:11.5.2.1
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.8
date	2004.05.21.17.33.43;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.08.33;	author jra;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	2002.08.15.20.55.46;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	2000.07.12.21.59.07;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.06.11.00.59.53;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.06.10;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.23.18.50.46;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.09.19.09.57;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.35;	author mike;	state Rel4_0;
branches;
next	1.3;

1.3
date	91.07.12.16.56.03;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	91.07.01.22.50.40;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	91.06.19.21.06.16;	author butler;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.02.11;	author morrison;	state Exp;
branches;
next	;


desc
@generate a command script to build a brick wall.  The command script
is suitable for feeding to mged.
@


11.8
log
@moved to src/proc-db/
@
text
@/*	
 *
 *	Options
 *	h	help
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>

#include "machine.h"
#include "externs.h"
#include "bu.h"

/* declarations to support use of getopt() system call */
char *options = "w:h:d:W:H:sn:t:Du:mc:C:";

char *progname = "(noname)";
double brick_width=8.0;
double brick_height=2.25;
double brick_depth=3.325;
double wall_width=0.0;
double wall_height=0.0;
char *brick_name="brick";
int standalone=0;
int make_mortar=0;	/* put mortar between bricks */
double tol=0.125;	/* minimum mortar thickness in in */
double tol2;		/* minimum brick dimension allowed */
int debug=0;
double units_conv=25.4;	/* default to inches */
char color[32] = "160 40 40";
char mortar_color[32] = "190 190 190";
/*
 *	U S A G E --- tell user how to invoke this program, then exit
 */
void usage(char *s)
{
	if (s) (void)fputs(s, stderr);

	(void) fprintf(stderr, 
	"Usage: %s %s\n%s\n%s\n%s\n",
			progname, 
	"  [ -u units ] [ -s(tandalone) ] [-t tolerance ]",
	"  [-m(ortar) ] [ -c R/G/B (brick) ] [ -C R/G/B (mortar)]",
	"  -w brick_width -h brick_height -d brick_depth -n brick_name",
	"  -W wall_width -H wall_height\n  > mged_commands \n");

	exit(1);
}

/*
 *	P A R S E _ A R G S --- Parse through command line flags
 */
int parse_args(int ac, char **av)
{
	int  c;
	double d;
	int red, grn, blu;

	if (  ! (progname=strrchr(*av, '/'))  )
		progname = *av;
	else
		++progname;
	
	/* Turn off getopt's error messages */
	opterr = 0;

	/* get all the option flags from the command line */
	while ((c=getopt(ac,av,options)) != EOF)
		switch (c) {
		case 'c'	: if ((c=sscanf(optarg, "%d/%d/%d",
				      &red, &grn, &blu)) == 3)
					(void)sprintf(color, "%d %d %d", red&0x0ff,
							grn&0x0ff, blu&0x0ff);
				break;
		case 'C'	: if ((c=sscanf(optarg, "%d/%d/%d",
				     &red, &grn, &blu)) == 3)
					(void)sprintf(mortar_color, "%d %d %d",
					red&0x0ff, grn&0x0ff, blu&0x0ff);
							
				break;
		case 'm'	: make_mortar = !make_mortar;
				break;
		case 'u'	: units_conv = bu_units_conversion(optarg);
				break;
		case 'D'	: debug = !debug;
				break;
		case 't'	: if ((d=atof(optarg)) != 0.0) tol = d; 
				break;
		case 'w'	: if ((d=atof(optarg)) != 0.0) brick_width = d;
				break;
		case 'h'	: if ((d=atof(optarg)) != 0.0) brick_height = d;
				break;
		case 'd'	: if ((d=atof(optarg)) != 0.0) brick_depth = d;
				break;
		case 'W'	: if ((d=atof(optarg)) != 0.0) wall_width = d;
				break;
		case 'H'	: if ((d=atof(optarg)) != 0.0) wall_height = d;
				break;
		case 'n'	: brick_name = optarg;
				break;
		case 's'	: standalone = !standalone;
				break;
		case '?'	:
		default		: usage("bad command line option"); break;
		}

	brick_width *= units_conv;
	brick_height *= units_conv;
	brick_depth *= units_conv;

	wall_width *= units_conv;
	wall_height *= units_conv;

	tol *= units_conv;
	tol2 = tol * 2;

	if (brick_width <= tol2)
		usage("brick width too small\n");

	if (brick_height <= tol2)
		usage("brick height too small\n");
	
	if (brick_depth <= tol2)
		usage("brick depth too small\n");
		
	if (wall_width < brick_width)
		usage("wall width < brick width\n");
	
	if (wall_height < brick_height)
		usage("wall height < brick height\n");
	
	if (brick_name == (char *)NULL || *brick_name == '\0')
	    	usage("bad or no brick name\n");

	return(optind);
}

void gen_mortar(int horiz_bricks, int vert_bricks, double horiz_spacing, double vert_spacing)
{
	int row;
	int i;
	double xstart;
	double zstart;

	if (vert_spacing > tol)
		if (horiz_spacing > tol)
			(void)fprintf(stderr, "generating mortar\n");
		else
			(void)fprintf(stderr, "generating vertical mortar\n");
	else
		if (horiz_spacing > tol)
			(void)fprintf(stderr, "generating horizontal mortar\n");
		else {
			(void)fprintf(stderr, "bricks too close for mortar\n");
			return;
		}

	for (row=0 ; row < vert_bricks ; ++row) {

	    if (vert_spacing > tol) {
		if (row % 2) xstart = brick_depth;
		else xstart = 0.0;

		zstart = brick_height + (vert_spacing+brick_height) * row;

		/* generate a slab of mortar underneath the brick row */
		(void)fprintf(stdout,
			"in s.%s.rm.%d rpp %g %g  %g %g  %g %g\n",
			brick_name, row,
			xstart, xstart + (wall_width - brick_depth),
			0.0, brick_depth,
			zstart, zstart+vert_spacing);

	    	(void)fprintf(stdout,
	    		"r r.m.%s u s.%s.rm.%d\n",
	    		brick_name, brick_name, row);
	    }
	    if (horiz_spacing > tol) {
		/* generate mortar between bricks */

		for(i=0 ; i < horiz_bricks ; ++i) {
			if (row %2)
				xstart = brick_depth + (brick_width+horiz_spacing)*i;
			else
				xstart = brick_width + (brick_width+horiz_spacing)*i;

			zstart = (brick_height+vert_spacing) * row;

			(void)fprintf(stdout,
				"in s.%s.bm.%d.%d rpp %g %g  %g %g  %g %g\n",
				brick_name, row, i,
				xstart, xstart + horiz_spacing,
				0.0, brick_depth,
				zstart, zstart+brick_height);

		    	(void)fprintf(stdout,
		    		"r r.m.%s u s.%s.bm.%d.%d\n",
		    		brick_name, brick_name, row, i);

		}
	    }
	}

	(void)fprintf(stdout, "mater r.m.%s\nplastic\n%s\n%s\n\n",
		brick_name, "sh=40 di=0.9 sp=0.1", mortar_color);

	(void)fprintf(stdout, "g g.%s g.%s.wall r.m.%s\n",
		brick_name, brick_name, brick_name);

}

/*
 *	G E N _ B R I C K S 
 *
 *	generate the brick solids, regions thereof, groups for rows
 *	and a group for the wall as a whole.
 */
void gen_bricks(int horiz_bricks, int vert_bricks, double horiz_spacing, double vert_spacing)
{
	int row;
	int brick;
	double offset;
	double xstart;
	double zstart;

	/* print the commands to make the wall */

	(void)fprintf(stdout, "\n\n");

	for (row=0 ; row < vert_bricks ; ++row) {

		if (row % 2) offset = brick_depth + horiz_spacing;
		else offset = 0.0;


		for (brick=0 ; brick < horiz_bricks ; ++ brick) {
			xstart = brick * brick_width +
				 brick * horiz_spacing + offset;
			zstart = row * brick_height + row * vert_spacing;

			(void)fprintf(stdout, 
				"in s.%s.%d.%d rpp %g %g  %g %g  %g %g\n",
					brick_name, row, brick,
					xstart, xstart + brick_width,
					0.0, brick_depth,
					zstart, zstart + brick_height);
			
			(void)fprintf(stdout, 
				"r r.%s.%d.%d u s.%s.%d.%d\n",
					brick_name, row, brick,
					brick_name, row, brick);

			(void)fprintf(stdout, "g g.%s.r.%d r.%s.%d.%d\n",
				brick_name, row, brick_name, row, brick);
		}

		(void)fprintf(stdout, "g g.%s.wall g.%s.r.%d\n",
				brick_name, brick_name, row);
	}

	(void)fprintf(stdout, "mater g.%s.wall\nplastic\n%s\n%s\n\n",
			brick_name, "sh=40 di=0.9 sp=0.1", color);
}
/*
 *	M A I N
 *
 *	Call parse_args to handle command line arguments first, then
 *	process input.
 */
int main(int ac, char **av)
{
	int horiz_bricks;
	int vert_bricks;
	double horiz_spacing;
	double vert_spacing;


	/* parse command flags, and make sure there are arguments
	 * left over for processing.
	 */
	if (parse_args(ac, av) < ac) usage("Excess command line arguments");


	/* build the wall

	if (debug)
	    (void)fprintf(stderr,
		"bw %g  bh %g  bd %g  ww %g  wh %g  bn\"%s\"\n",
		brick_width, brick_height, brick_depth,
		wall_width, wall_height, brick_name);
 */

	horiz_bricks = (int)(wall_width / brick_width);

	/* leave room for sideways brick at one end */
	while (horiz_bricks * brick_width + brick_depth > wall_width &&
	    horiz_bricks > 0)
		--horiz_bricks;

	if (horiz_bricks <= 0) {
		(void)fprintf(stderr, "wall not wide enough for brick\n");
		return(-1);
	}

	if (standalone) {
		horiz_spacing =
		    (wall_width - horiz_bricks * brick_width) /
					(horiz_bricks - 1);
	} else {
		horiz_spacing =
		    (wall_width - (horiz_bricks * brick_width + brick_depth))/
					horiz_bricks;
	}

	
	vert_bricks = (int)(wall_height / (brick_height+(horiz_spacing*0.5)));

	vert_spacing = 
			(wall_height - vert_bricks * brick_height) /
				(vert_bricks - 1);


	(void)fprintf(stderr, "wall %d bricks wide,  %d bricks high\n",
		horiz_bricks, vert_bricks);
	(void)fprintf(stderr, "distance between adjacent bricks %g\n",
		horiz_spacing / units_conv);
	(void)fprintf(stderr, "distance between layers of bricks %g\n",
		vert_spacing / units_conv);


	(void)putc((int)'\n', stdout);
	gen_bricks(horiz_bricks, vert_bricks, horiz_spacing, vert_spacing);

	if (make_mortar && (vert_spacing > tol || horiz_spacing > tol))
		gen_mortar(horiz_bricks, vert_bricks, horiz_spacing, vert_spacing);

	return(0);
}
@


11.7
log
@change conf.h to a wrapped config.h
@
text
@@


11.6
log
@merge of ansi-6-0-branch into head
@
text
@d6 5
a10 1
#include "conf.h"
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d41 1
a41 2
void usage(s)
char *s;
d59 1
a59 3
int parse_args(ac, av)
int ac;
char *av[];
d144 1
a144 5
void gen_mortar(horiz_bricks, vert_bricks, horiz_spacing, vert_spacing)
int horiz_bricks;
int vert_bricks;
double horiz_spacing;
double vert_spacing;
d224 1
a224 5
void gen_bricks(horiz_bricks, vert_bricks, horiz_spacing, vert_spacing)
int horiz_bricks;
int vert_bricks;
double horiz_spacing;
double vert_spacing;
d276 1
a276 3
int main(ac,av)
int ac;
char *av[];
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d41 2
a42 1
void usage(char *s)
d60 3
a62 1
int parse_args(int ac, char **av)
d147 5
a151 1
void gen_mortar(int horiz_bricks, int vert_bricks, double horiz_spacing, double vert_spacing)
d231 5
a235 1
void gen_bricks(int horiz_bricks, int vert_bricks, double horiz_spacing, double vert_spacing)
d287 3
a289 1
int main(int ac, char **av)
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d41 2
a42 1
void usage(char *s)
d60 3
a62 1
int parse_args(int ac, char **av)
d147 5
a151 1
void gen_mortar(int horiz_bricks, int vert_bricks, double horiz_spacing, double vert_spacing)
d231 5
a235 1
void gen_bricks(int horiz_bricks, int vert_bricks, double horiz_spacing, double vert_spacing)
d287 3
a289 1
int main(int ac, char **av)
@


11.3
log
@
Converted to use new version of LIBWDB.
@
text
@d41 1
a41 2
void usage(s)
char *s;
d59 1
a59 3
int parse_args(ac, av)
int ac;
char *av[];
d144 1
a144 5
void gen_mortar(horiz_bricks, vert_bricks, horiz_spacing, vert_spacing)
int horiz_bricks;
int vert_bricks;
double horiz_spacing;
double vert_spacing;
d224 1
a224 5
void gen_bricks(horiz_bricks, vert_bricks, horiz_spacing, vert_spacing)
int horiz_bricks;
int vert_bricks;
double horiz_spacing;
double vert_spacing;
d276 1
a276 3
int main(ac,av)
int ac;
char *av[];
@


11.2
log
@rt_units_conversion moved into libbu
@
text
@d18 1
@


11.1
log
@Release_4.4
@
text
@d91 1
a91 1
		case 'u'	: units_conv = rt_units_conversion(optarg);
@


10.3
log
@Factored ifdefs
@
text
@@


10.2
log
@Factored ifdefs
@
text
@d9 5
@


10.1
log
@Release_4.0
@
text
@d6 2
d10 4
a15 2
extern char *optarg;
extern int optind, opterr, getopt();
a58 4
#if defined(BSD) && BSD < 43
#define strrchr rindex
#endif
	char *strrchr();
@


1.3
log
@added strrchr define for BSD < 43
@
text
@@


1.2
log
@Improvements
@
text
@d55 3
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
char *options = "w:h:d:W:H:sn:t:Du:";
d14 3
a16 3
double brick_width=9.0;
double brick_height=3.0;
double brick_depth=4.0;
d21 2
a22 1
double tol=0.125;	/* minimum mortar thickness in mm */
d26 2
a27 2


d37 1
a37 1
"Usage: %s -w brick_width -h brick_height -d brick_depth -n brick_name\n%s\n",
d39 5
a43 1
"  -W wall_width -H wall_height\n  [-u units] [ -s(tandalone) ] [-t tolerance] > mged_commands \n");
d57 1
d70 19
a88 3
		case 'u'	: units_conv = rt_units_conversion(optarg); break;
		case 'D'	: debug = !debug; break;
		case 't'	: if ((d=atof(optarg)) != 0.0) tol = d;
d99 4
a102 2
		case 'n'	: brick_name = optarg; break;
		case 's'	: standalone = !standalone; break;
d115 1
a115 1
	tol2 = tol * tol;
d138 78
d217 56
a281 1
	int arg_index;
d284 2
a285 7
	int row;
	int brick;
	int offset;
	double xstart;
	double zstart;
	double horiz_mortar;
	double vert_mortar;
d291 1
a291 1
	if ((arg_index = parse_args(ac, av)) < ac) usage((char *)NULL);
d294 1
a294 1
	/* build the wall */
d301 1
a302 1

d316 1
a316 1
		horiz_mortar =
d320 1
a320 1
		horiz_mortar =
d325 2
a326 1
	vert_bricks = (int)(wall_height / brick_height);
d328 2
a329 1
	vert_mortar = (wall_height - vert_bricks * brick_height) /
d336 1
a336 1
		horiz_mortar);
d338 1
a338 1
		vert_mortar);
d341 2
a342 1
	/* print the commands to make the wall */
d344 2
a345 32
	(void)fprintf(stdout, "\n\n");

	for (row=0 ; row < vert_bricks ; ++row) {

		if (row % 2) offset = brick_depth + horiz_mortar;
		else offset = 0;


		for (brick=0 ; brick < horiz_bricks ; ++ brick) {
			xstart = brick * brick_width +
				 brick * horiz_mortar + offset;
			zstart = row * brick_height + row * vert_mortar;

			(void)fprintf(stdout, 
				"in s.%s.%d.%d rpp %g %g  %g %g  %g %g\n",
					brick_name, row, brick,
					xstart, xstart + brick_width,
					0, brick_depth,
					zstart, zstart + brick_height);
			
			(void)fprintf(stdout, 
				"r r.%s.%d.%d u s.%s.%d.%d\n",
					brick_name, row, brick,
					brick_name, row, brick);

			(void)fprintf(stdout, "g g.row.%d r.%s.%d.%d\n",
				row, brick_name, row, brick);
		}

		(void)fprintf(stdout, "g g.wall g.row.%d\n", row);
		
	}
@
