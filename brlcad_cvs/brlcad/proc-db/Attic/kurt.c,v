head	11.17;
access;
symbols
	ansi-20040405-merged:11.13.2.2
	postmerge-20040405-ansi:11.15
	premerge-20040404-ansi:11.14
	postmerge-autoconf:11.14
	autoconf-freeze:11.13.10.2
	premerge-autoconf:11.14
	postmerge-20040315-windows:11.14
	premerge-20040315-windows:11.14
	windows-20040315-freeze:11.13.4.1
	autoconf-20031203:11.13
	autoconf-20031202:11.13
	autoconf-branch:11.13.0.10
	phong-branch:11.13.0.8
	photonmap-branch:11.13.0.6
	rel-6-1-DP:11.13
	windows-branch:11.13.0.4
	rel-6-0-2:11.11
	ansi-branch:11.13.0.2
	rel-6-0-1-branch:11.11.0.2
	hartley-6-0-post:11.12
	hartley-6-0-pre:11.11
	rel-6-0-1:11.11
	rel-6-0:11.11
	rel-5-4:11.5
	offsite-5-3-pre:11.10
	rel-5-3:11.5
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:1.4;
locks; strict;
comment	@ * @;


11.17
date	2004.05.21.17.33.44;	author morrison;	state dead;
branches;
next	11.16;

11.16
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.15;

11.15
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2004.02.02.17.39.37;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2002.08.20.17.08.34;	author jra;	state Exp;
branches
	11.13.2.1
	11.13.4.1
	11.13.10.1;
next	11.12;

11.12
date	2002.08.15.20.55.46;	author hartley;	state Exp;
branches;
next	11.11;

11.11
date	2001.03.31.01.57.28;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2000.08.24.22.30.30;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.07.12.21.59.07;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.07.12.03.44.52;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.10.23.46.49;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.07.10.23.38.21;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.03.31.03.07.31;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.12.20.20.43.02;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	99.11.17.20.55.10;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	99.11.16.19.15.39;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.06.13;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.12.30.08.01.50;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	94.11.14.22.14.14;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.09.19.12.10;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.38;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.04.47;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.38.20;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.08.20.07.26.34;	author phil;	state Exp;
branches;
next	7.3;

7.3
date	88.05.15.23.00.14;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.03.22.59.04;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.16.49.11;	author mike;	state Rel;
branches;
next	1.4;

1.4
date	87.10.13.23.07.37;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	87.09.26.03.15.41;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	87.09.26.03.11.56;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.09.25.21.53.05;	author mike;	state Exp;
branches;
next	;

11.13.2.1
date	2002.09.19.18.02.12;	author morrison;	state Exp;
branches;
next	11.13.2.2;

11.13.2.2
date	2004.03.17.21.22.54;	author morrison;	state Exp;
branches;
next	;

11.13.4.1
date	2004.03.10.15.06.36;	author morrison;	state Exp;
branches;
next	;

11.13.10.1
date	2004.02.12.19.50.51;	author erikg;	state Exp;
branches;
next	11.13.10.2;

11.13.10.2
date	2004.03.15.14.08.05;	author erikg;	state Exp;
branches;
next	;


desc
@Generate polygons from multi-valued functions
@


11.17
log
@moved to src/proc-db/
@
text
@/*
 *			K U R T . C
 * 
 *  Program to generate polygons from a multi-valued function.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright 
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/proc-db/kurt.c,v 11.16 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "wdb.h"

mat_t	identity;
double degtorad = 0.0174532925199433;

struct val {
	double	v_z[3];
	double	v_x;
	double	v_y;
	int	v_n;
} val[20][20];

void	do_cell(struct val *vp, double xc, double yc);
void	draw_rect(struct val *a, struct val *b, struct val *c, struct val *d);
void	pnorms(fastf_t (*norms)[3], fastf_t (*verts)[3], fastf_t *centroid, int npts);
void	do_light(char *name, fastf_t *pos, fastf_t *dir_at, int da_flag, double r, unsigned char *rgb);

struct rt_wdb	*outfp;

int
main(int argc, char **argv)
{
	int	ix, iy;
	double	x, y;
	double	size;
	double	base;
	int	quant;

	outfp = wdb_fopen("kurt.g");
	mk_id( outfp, "Kurt's multi-valued function");

	/* Create the detail cells */
	size = 10;	/* mm */
	quant = 18;
	base = -size*(quant/2);
	for( ix=quant-1; ix>=0; ix-- )  {
		x = base + ix*size;
		for( iy=quant-1; iy>=0; iy-- )  {
			y = base + iy*size;
			do_cell( &val[ix][iy], x, y );
		}
	}
	/* Draw cells */
/* XXX This should be a height field / DSP solid! */
#if 0
	mk_polysolid( outfp, "kurt" );
	for( ix=quant-2; ix>=0; ix-- )  {
		for( iy=quant-2; iy>=0; iy-- )  {
			draw_rect( &val[ix][iy],
				   &val[ix+1][iy], 
				   &val[ix][iy+1], 
				   &val[ix+1][iy+1] );
		}
	}
#endif

#ifdef never
	/* Create some light */
	white[0] = white[1] = white[2] = 255;
	base = size*(quant/2+1);
	VSET( aim, 0, 0, 0 );
	VSET( pos, base, base, size );
	do_light( "l1", pos, aim, 1, 100.0, white );
	VSET( pos, -base, base, size );
	do_light( "l2", pos, aim, 1, 100.0, white );
	VSET( pos, -base, -base, size );
	do_light( "l3", pos, aim, 1, 100.0, white );
	VSET( pos, base, -base, size );
	do_light( "l4", pos, aim, 1, 100.0, white );

	/* Build the overall combination */
	mk_fcomb( outfp, "clut", quant*quant+1+4, 0 );
	mk_memb( outfp, "plane.r", identity, UNION );
	for( ix=quant-1; ix>=0; ix-- )  {
		for( iy=quant-1; iy>=0; iy-- )  {
			sprintf( name, "x%dy%d", ix, iy );
			mk_memb( outfp, name, identity, UNION );
		}
	}
	mk_memb( outfp, "l1", identity, UNION );
	mk_memb( outfp, "l2", identity, UNION );
	mk_memb( outfp, "l3", identity, UNION );
	mk_memb( outfp, "l4", identity, UNION );
#endif
	return 0;
}

void
do_cell(struct val *vp, double xc, double yc)
          	    
      	       		/* center coordinates, z=0+ */
{
	LOCAL poly	polynom;
	LOCAL bn_complex_t	roots[4];	/* roots of final equation */
	int		l;
	int		nroots;
	int		lim;

	polynom.dgr = 3;
	polynom.cf[0] = 1;
	polynom.cf[1] = 0;
	polynom.cf[2] = yc;
	polynom.cf[3] = xc;
	vp->v_n = 0;
	vp->v_x = xc;
	vp->v_y = yc;
	nroots = rt_poly_roots( &polynom, roots );
	if( nroots < 0 || (nroots & 1) == 0 )  {
		fprintf(stderr,"%d roots?\n", nroots);
		return;
	}
	for ( l=0; l < nroots; l++ ){
		if ( NEAR_ZERO( roots[l].im, 0.0001 ) )
			vp->v_z[vp->v_n++] = roots[l].re;
	}
	/* Sort in increasing Z */
	for( lim = nroots-1; lim > 0; lim-- )  {
		for( l=0; l < lim; l++ )  {
			register double t;
			if( (t=vp->v_z[l]) > vp->v_z[l+1] )  {
				vp->v_z[l] = vp->v_z[l+1];
				vp->v_z[l+1] = t;
			}
		}
	}
}

void
draw_rect(struct val *a, struct val *b, struct val *c, struct val *d)
{
	int min, max;
	register int i;
	point_t	centroid, work;
	int	ndiff;
	int	lvl;
	int	j;
	struct val	*vp[4];

	/* Find min and max # of points at the 4 vertices */
	max = a->v_n;
	if( b->v_n > max )  max = b->v_n;
	if( c->v_n > max )  max = c->v_n;
	if( d->v_n > max )  max = d->v_n;
	min = a->v_n;
	if( b->v_n < min )  min = b->v_n;
	if( c->v_n < min )  min = c->v_n;
	if( d->v_n < min )  min = d->v_n;

	ndiff = 0;
	if( a->v_n > min )  vp[ndiff++] = a;
	if( b->v_n > min )  vp[ndiff++] = b;
	if( c->v_n > min )  vp[ndiff++] = c;
	if( d->v_n > min )  vp[ndiff++] = d;

	
	VSET( work, a->v_x, a->v_y, a->v_z[0] );
	VMOVE( centroid, work );
	VSET( work, b->v_x, b->v_y, b->v_z[0] );
	VADD2( centroid, centroid, work );
	VSET( work, c->v_x, c->v_y, c->v_z[0] );
	VADD2( centroid, centroid, work );
	VSET( work, d->v_x, d->v_y, d->v_z[0] );
	VADD2( centroid, centroid, work );
	VSCALE( centroid, centroid, 0.25 );

	/* First, the simple part.  Assume that all 4-way shared levels
	 * are stacked plates.  Do them now, then worry about oddities.
	 * For general functions, this may be dangerous, but works fine here.
	 */
	for( i=0; i<min; i++ )  {
#if 0
		VSET( verts[0], a->v_x, a->v_y, a->v_z[i] );
		VSET( verts[1], b->v_x, b->v_y, b->v_z[i] );
		VSET( verts[2], c->v_x, c->v_y, c->v_z[i] );
		/* even # faces point up, odd#s point down */
		pnorms( norms, verts, (i&1)?down:up, 3 );
		mk_poly( outfp, 3, verts, norms );

		VSET( verts[0], d->v_x, d->v_y, d->v_z[i] );
		VSET( verts[1], b->v_x, b->v_y, b->v_z[i] );
		VSET( verts[2], c->v_x, c->v_y, c->v_z[i] );
		/* even # faces point up, odd#s point down */
		pnorms( norms, verts, (i&1)?down:up, 3 );
		mk_poly( outfp, 3, verts, norms );
#endif
	}
	/* If 0 or 1 corners have something above them, nothing needs drawn */
	if( ndiff == 0 || ndiff == 1 )  return;
	/* Harder case:  handle different depths on corners */
	if( ndiff == 2 &&
	    vp[0]->v_x != vp[1]->v_x &&
	    vp[0]->v_y != vp[1]->v_y )  {
		fprintf(stderr, "2 corners on diagonal differ?\n");
	    	return;
	}

	/* Draw 1 or 2 extra faces to close off each new upper zone */
	for( lvl = min; lvl < max; lvl += 2 )  {
		for( i=0; i<ndiff-1; i++ )  {
			for( j=i; j<ndiff; j++ )  {
				/* Reject diagonals */
				if( vp[i]->v_x != vp[j]->v_x &&
				    vp[i]->v_y != vp[j]->v_y )
					continue;

#if 0
				VSET( verts[0],
					vp[i]->v_x, vp[i]->v_y,
					vp[i]->v_z[lvl] );
				VSET( verts[1],
					vp[j]->v_x, vp[j]->v_y,
					vp[j]->v_z[lvl] );
				VSET( verts[2],
					vp[i]->v_x, vp[i]->v_y,
					vp[i]->v_z[lvl+1] );

				VSUB2( work, centroid, verts[0] );
				VUNITIZE( work );
				pnorms( norms, verts, work, 3 );
				mk_poly( outfp, 3, verts, norms );

				VSET( verts[0],
					vp[i]->v_x, vp[i]->v_y,
					vp[i]->v_z[lvl+1] );
				VSET( verts[1],
					vp[j]->v_x, vp[j]->v_y,
					vp[j]->v_z[lvl] );
				VSET( verts[2],
					vp[j]->v_x, vp[j]->v_y,
					vp[j]->v_z[lvl+1] );

				VSUB2( work, centroid, verts[0] );
				VUNITIZE( work );
				pnorms( norms, verts, work, 3 );
				mk_poly( outfp, 3, verts, norms );
#endif
			}
		}
	}
}

/*
 *  Find the single outward pointing normal for a facet.
 *  Assumes all points are coplanar (they better be!).
 */
void
pnorms(fastf_t (*norms)[3], fastf_t (*verts)[3], fastf_t *out, int npts)
       	            
       	            
      	    		/* hopefully points outwards */
   	     
{
	register int i;
	vect_t	ab, ac;
	vect_t	n;

	VSUB2( ab, verts[1], verts[0] );
	VSUB2( ac, verts[2], verts[0] );
	VCROSS( n, ab, ac );
	VUNITIZE( n );

	/* If normal points inwards, flip it */
	if( VDOT( n, out ) < 0 )  {
		VREVERSE( n, n );
	}

	/* Use same normal for all vertices (flat shading) */
	for( i=0; i<npts; i++ )  {
		VMOVE( norms[i], n );
	}
}

void
do_light(char *name, fastf_t *pos, fastf_t *dir_at, int da_flag, double r, unsigned char *rgb)
    	      
       	    
      	       		/* direction or aim point */
   	        	/* 0 = direction, !0 = aim point */
      	  		/* radius of light */
             	     
{
	char	nbuf[64];
	vect_t	center;
	mat_t	rot;
	mat_t	xlate;
	mat_t	both;
	vect_t	from;
	vect_t	dir;

	if( da_flag )  {
		VSUB2( dir, dir_at, pos );
		VUNITIZE( dir );
	} else {
		VMOVE( dir, dir_at );
	}

	sprintf( nbuf, "%s.s", name );
	VSETALL( center, 0 );
	mk_sph( outfp, nbuf, center, r );

	/*
	 * Need to rotate from 0,0,-1 to vect "dir",
	 * then xlate to final position.
	 */
	VSET( from, 0, 0, -1 );
	bn_mat_fromto( rot, from, dir );
	MAT_IDN( xlate );
	MAT_DELTAS( xlate, pos[X], pos[Y], pos[Z] );
	bn_mat_mul( both, xlate, rot );

	mk_region1( outfp, name, nbuf, "light", "shadows=1", rgb );
}
@


11.16
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/proc-db/kurt.c,v 11.15 2004/04/05 05:45:58 morrison Exp $ (BRL)";
@


11.15
log
@merge of ansi-6-0-branch into head
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d22 5
a26 1
#include "conf.h"
@


11.14
log
@update copyright to include span through 2003
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.13 2002/08/20 17:08:34 jra Exp $ (BRL)";
d43 4
a46 1
void	do_cell(), draw_rect(), pnorms(), do_light();
d51 1
a51 2
main(argc, argv)
char	**argv;
d119 3
a121 3
do_cell( vp, xc, yc )
struct val	*vp;
double	xc, yc;		/* center coordinates, z=0+ */
d159 1
a159 2
draw_rect( a, b, c, d )
struct val *a, *b, *c, *d;
d277 5
a281 5
pnorms( norms, verts, out, npts )
fastf_t	norms[5][3];
fastf_t	verts[5][3];
vect_t	out;		/* hopefully points outwards */
int	npts;
d304 7
a310 7
do_light( name, pos, dir_at, da_flag, r, rgb )
char	*name;
point_t	pos;
vect_t	dir_at;		/* direction or aim point */
int	da_flag;	/* 0 = direction, !0 = aim point */
double	r;		/* radius of light */
unsigned char	*rgb;
@


11.13
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.11 2001/03/31 01:57:28 morrison Exp $ (BRL)";
@


11.13.4.1
log
@merge in updates from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/proc-db/kurt.c,v 11.14 2004/02/02 17:39:37 morrison Exp $ (BRL)";
@


11.13.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.14 2004/02/02 17:39:37 morrison Exp $ (BRL)";
@


11.13.10.2
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.13.10.1 2004/02/12 19:50:51 erikg Exp $ (BRL)";
@


11.13.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.13 2002/08/20 17:08:34 jra Exp $ (BRL)";
d43 1
a43 1
void	do_cell(struct val *vp, double xc, double yc), draw_rect(struct val *a, struct val *b, struct val *c, struct val *d), pnorms(fastf_t (*norms)[3], fastf_t (*verts)[3], fastf_t *centroid, int npts), do_light(char *name, fastf_t *pos, fastf_t *dir_at, int da_flag, double r, unsigned char *rgb);
d48 2
a49 1
main(int argc, char **argv)
d117 3
a119 3
do_cell(struct val *vp, double xc, double yc)
          	    
      	       		/* center coordinates, z=0+ */
d157 2
a158 1
draw_rect(struct val *a, struct val *b, struct val *c, struct val *d)
d276 5
a280 5
pnorms(fastf_t (*norms)[3], fastf_t (*verts)[3], fastf_t *out, int npts)
       	            
       	            
      	    		/* hopefully points outwards */
   	     
d303 7
a309 7
do_light(char *name, fastf_t *pos, fastf_t *dir_at, int da_flag, double r, unsigned char *rgb)
    	      
       	    
      	       		/* direction or aim point */
   	        	/* 0 = direction, !0 = aim point */
      	  		/* radius of light */
             	     
@


11.13.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.12
log
@Converted from K&R to ANSI C - RFH
@
text
@d43 1
a43 1
void	do_cell(struct val *vp, double xc, double yc), draw_rect(struct val *a, struct val *b, struct val *c, struct val *d), pnorms(fastf_t (*norms)[3], fastf_t (*verts)[3], fastf_t *centroid, int npts), do_light(char *name, fastf_t *pos, fastf_t *dir_at, int da_flag, double r, unsigned char *rgb);
d48 2
a49 1
main(int argc, char **argv)
d117 3
a119 3
do_cell(struct val *vp, double xc, double yc)
          	    
      	       		/* center coordinates, z=0+ */
d157 2
a158 1
draw_rect(struct val *a, struct val *b, struct val *c, struct val *d)
d276 5
a280 5
pnorms(fastf_t (*norms)[3], fastf_t (*verts)[3], fastf_t *out, int npts)
       	            
       	            
      	    		/* hopefully points outwards */
   	     
d303 7
a309 7
do_light(char *name, fastf_t *pos, fastf_t *dir_at, int da_flag, double r, unsigned char *rgb)
    	      
       	    
      	       		/* direction or aim point */
   	        	/* 0 = direction, !0 = aim point */
      	  		/* radius of light */
             	     
@


11.11
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.10 2000/08/24 22:30:30 mike Exp $ (BRL)";
d43 1
a43 1
void	do_cell(), draw_rect(), pnorms(), do_light();
d48 1
a48 2
main(argc, argv)
char	**argv;
d116 3
a118 3
do_cell( vp, xc, yc )
struct val	*vp;
double	xc, yc;		/* center coordinates, z=0+ */
d156 1
a156 2
draw_rect( a, b, c, d )
struct val *a, *b, *c, *d;
d274 5
a278 5
pnorms( norms, verts, out, npts )
fastf_t	norms[5][3];
fastf_t	verts[5][3];
vect_t	out;		/* hopefully points outwards */
int	npts;
d301 7
a307 7
do_light( name, pos, dir_at, da_flag, r, rgb )
char	*name;
point_t	pos;
vect_t	dir_at;		/* direction or aim point */
int	da_flag;	/* 0 = direction, !0 = aim point */
double	r;		/* radius of light */
unsigned char	*rgb;
@


11.10
log
@
lint
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.9 2000/07/12 21:59:07 mike Exp $ (BRL)";
d336 1
a336 1
	bn_mat_idn( xlate );
@


11.9
log
@
Converted to use new version of LIBWDB.
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.8 2000/07/12 03:44:52 mike Exp $ (BRL)";
a35 3
static vect_t	up = {0, 0, 1};
static vect_t	down = {0, 0, -1};

a162 2
	fastf_t	verts[5][3];
	fastf_t	norms[5][3];
@


11.8
log
@
Converted to new way, using mk_lfcomb().
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.7 2000/07/10 23:46:49 mike Exp $ (BRL)";
d48 2
d60 2
a61 1
	mk_id( stdout, "Kurt's multi-valued function");
d75 3
a77 1
	mk_polysolid( stdout, "kurt" );
d86 1
d103 2
a104 2
	mk_fcomb( stdout, "clut", quant*quant+1+4, 0 );
	mk_memb( stdout, "plane.r", identity, UNION );
d108 1
a108 1
			mk_memb( stdout, name, identity, UNION );
d111 4
a114 4
	mk_memb( stdout, "l1", identity, UNION );
	mk_memb( stdout, "l2", identity, UNION );
	mk_memb( stdout, "l3", identity, UNION );
	mk_memb( stdout, "l4", identity, UNION );
d205 1
d211 1
a211 1
		mk_poly( stdout, 3, verts, norms );
d218 2
a219 1
		mk_poly( stdout, 3, verts, norms );
d240 1
d254 1
a254 1
				mk_poly( stdout, 3, verts, norms );
d269 2
a270 1
				mk_poly( stdout, 3, verts, norms );
d333 1
a333 1
	mk_sph( stdout, nbuf, center, r );
d345 1
a345 1
	mk_region1( stdout, name, nbuf, "light", "shadows=1", rgb );
@


11.7
log
@
lint
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.6 2000/07/10 23:38:21 mike Exp $ (BRL)";
d335 1
a335 2
	mk_comb( stdout, name, 1, 1, "light", "shadows=1", rgb, 0 );
	mk_memb( stdout, nbuf, both, WMOP_UNION );
@


11.6
log
@
const RCSid
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.5 2000/03/31 03:07:31 mike Exp $ (BRL)";
d48 1
d110 1
@


11.5
log
@
Changed RT_ to BU_ / BN_
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.4 1999/12/20 20:43:02 mike Exp $ (BRL)";
@


11.4
log
@
Removed unnecessary header file
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.3 1999/11/17 20:55:10 mike Exp $ (BRL)";
d117 1
a117 1
	LOCAL complex	roots[4];	/* roots of final equation */
d328 2
a329 2
	mat_fromto( rot, from, dir );
	mat_idn( xlate );
d331 1
a331 1
	mat_mul( both, xlate, rot );
@


11.3
log
@
Lint warning
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.2 1999/11/16 19:15:39 mike Exp $ (BRL)";
a31 2

#include "../librt/polyno.h"
@


11.2
log
@
Fixed fuzz resulting from elimination of dummy file ../librt/complex.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/kurt.c,v 11.1 1995/01/04 10:06:13 mike Rel4_4 $ (BRL)";
d304 1
a304 1
char	*rgb;
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/kurt.c,v 10.4 94/12/30 08:01:50 jra Exp $ (BRL)";
d27 1
a27 1
#include "db.h"
d29 1
d31 1
a32 1
#include "../librt/complex.h"
d336 1
a336 1
	mk_memb( stdout, nbuf, both, UNION );
@


10.4
log
@Converted polyRoots to rt_poly_roots.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/kurt.c,v 10.3 94/11/14 22:14:14 mike Exp Locker: jra $ (BRL)";
@


10.3
log
@Irix 6
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/kurt.c,v 10.2 94/08/09 19:12:10 gdurf Exp Locker: mike $ (BRL)";
d131 1
a131 1
	nroots = polyRoots( &polynom, roots );
@


10.2
log
@Added include
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/kurt.c,v 10.1 1991/10/12 06:44:38 mike Rel4_0 gdurf $ (BRL)";
a51 1
	char	rgb[3];
a56 3
	char	name[64];
	vect_t	pos, aim;
	char	white[3];
d119 1
a119 2
	fastf_t		k[4];
	int		i, l;
a158 1
	point_t pt[4];
a160 1
	static struct val v[3];
a309 2
	vect_t	begin;
	vect_t	trial;
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/kurt.c,v 9.1 89/05/19 06:04:47 mike Rel3_5 $ (BRL)";
d21 2
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: kurt.c,v 8.1 88/10/05 00:38:20 mike Rel3_0 $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: kurt.c,v 7.4 88/08/20 07:26:34 phil Exp $ (BRL)";
@


7.4
log
@libwdb changes
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: kurt.c,v 7.3 88/05/15 23:00:14 phil Locked $ (BRL)";
@


7.3
log
@lint fixes
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: kurt.c,v 7.2 87/11/03 22:59:04 mike Locked $ (BRL)";
d99 1
a99 1
	mk_comb( stdout, "clut", quant*quant+1+4, 0 );
d208 1
a208 1
		mk_facet( stdout, 3, verts, norms );
d215 1
a215 1
		mk_facet( stdout, 3, verts, norms );
d249 1
a249 1
				mk_facet( stdout, 3, verts, norms );
d264 1
a264 1
				mk_facet( stdout, 3, verts, norms );
d341 1
a341 1
	mk_mcomb( stdout, name, 1, 1, "light", "shadows=1", 1, rgb );
@


7.2
log
@mat_fromto() moved to librt/mat.c
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: kurt.c,v 7.1 87/11/03 16:49:11 mike Locked $ (BRL)";
d45 2
d114 1
d155 1
d274 1
d278 1
a278 1
vect_t	out;
a283 1
	vect_t	out;		/* hopefully points outwards */
d301 1
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: kurt.c,v 1.4 87/10/13 23:07:37 mike Exp $ (BRL)";
a337 56
}

/* wrapper for atan2.  On SGI (and perhaps others), x==0 returns infinity */
double
xatan2(y,x)
double	y,x;
{
	if( x > -1.0e-20 && x < 1.0e-20 )  return(0.0);
	return( atan2( y, x ) );
}
/*
 *			M A T _ F R O M T O
 *
 *  Given two vectors, compute a rotation matrix that will transform
 *  space by the angle between the two.  Since there are many
 *  candidate matricies, the method used here is to convert the vectors
 *  to azimuth/elevation form (azimuth is +X, elevation is +Z),
 *  take the difference, and form the rotation matrix.
 *  See mat_ae for that algorithm.
 *
 *  The input 'from' and 'to' vectors must be unit length.
 */
mat_fromto( m, from, to )
mat_t	m;
vect_t	from;
vect_t	to;
{
	double	az, el;
	LOCAL double sin_az, sin_el;
	LOCAL double cos_az, cos_el;

	az = xatan2( to[Y], to[X] ) - xatan2( from[Y], from[X] );
	el = asin( to[Z] ) - asin( from[Z] );

	sin_az = sin(az);
	cos_az = cos(az);
	sin_el = sin(el);
	cos_el = cos(el);

	m[0] = cos_el * cos_az;
	m[1] = -sin_az;
	m[2] = -sin_el * cos_az;
	m[3] = 0;

	m[4] = cos_el * sin_az;
	m[5] = cos_az;
	m[6] = -sin_el * sin_az;
	m[7] = 0;

	m[8] = sin_el;
	m[9] = 0;
	m[10] = cos_el;
	m[11] = 0;

	m[12] = m[13] = m[14] = 0;
	m[15] = 1.0;
@


1.4
log
@Explicitly named librt headers
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: kurt.c,v 1.3 87/09/26 03:15:41 mike Locked $ (BRL)";
@


1.3
log
@Changed to new mk_memb, mk_sph calling sequences.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: kurt.c,v 1.2 87/09/26 03:11:56 mike Locked $ (BRL)";
d29 2
a30 2
#include "./complex.h"
#include "./polyno.h"
@


1.2
log
@Modified to handle sections of surface where number of roots
goes up.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pyramid.c,v 1.2 87/09/16 23:01:32 mike Locked $ (BRL)";
d98 1
a98 1
	mk_memb( stdout, UNION, "plane.r", identity );
d102 1
a102 1
			mk_memb( stdout, UNION, name, identity );
d105 4
a108 4
	mk_memb( stdout, UNION, "l1", identity );
	mk_memb( stdout, UNION, "l2", identity );
	mk_memb( stdout, UNION, "l3", identity );
	mk_memb( stdout, UNION, "l4", identity );
d306 1
d323 2
a324 1
	mk_sph( stdout, nbuf, 0.0, 0.0, 0.0, r );
d337 1
a337 1
	mk_memb( stdout, UNION, nbuf, both );
@


1.1
log
@Initial revision
@
text
@d35 3
a47 1
	vect_t	norm;
d155 1
a155 1
	register int lvl;
d157 1
d162 4
d167 9
a175 5
	/* Find max # of points at any of the 4 vertices */
	lvl = a->v_n;
	if( b->v_n > lvl )  lvl = b->v_n;
	if( c->v_n > lvl )  lvl = c->v_n;
	if( d->v_n > lvl )  lvl = d->v_n;
d177 43
a219 10
	if( a->vn == lvl && b->vn == lvl && 
	    c->vn == lvl && d->vn == lvl )  {
		for( i=0; i<lvl; i++ )  {
			VSET( verts[0], a->v_x, a->v_y, a->v_z[i] );
			VSET( verts[1], b->v_x, b->v_y, b->v_z[i] );
			VSET( verts[2], c->v_x, c->v_y, c->v_z[i] );
			/* even # faces point up, odd#s point down */
			pnorms( norms, verts, i&1, 3 );
			mk_facet( stdout, 3, verts, norms );
		}
d222 42
a263 1
	/* Harder case:  handle different depths on corners */
d270 1
a270 1
pnorms( norms, verts, down, npts )
d273 1
a273 1
int	down;		/* 0 = norms up, 1 = norms down */
d286 3
a288 9
	/* If normal points opposite to flag, flip it */
	if( down )  {
		if( n[Z] > 0 )  {
			VREVERSE( n, n );
		}
	} else {
		if( n[Z] < 0 )  {
			VREVERSE( n, n );
		}
@
