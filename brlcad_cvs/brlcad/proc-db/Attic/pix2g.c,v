head	1.8;
access;
symbols
	ansi-20040405-merged:1.4.2.2
	postmerge-20040405-ansi:1.6
	premerge-20040404-ansi:1.5
	postmerge-autoconf:1.5
	autoconf-freeze:1.5
	premerge-autoconf:1.5
	postmerge-20040315-windows:1.5
	premerge-20040315-windows:1.5
	windows-20040315-freeze:1.4.4.1
	autoconf-20031203:1.5
	autoconf-20031202:1.5
	autoconf-branch:1.5.0.4
	phong-branch:1.5.0.2
	photonmap-branch:1.4.0.6
	rel-6-1-DP:1.4
	windows-branch:1.4.0.4
	rel-6-0-2:1.2
	ansi-branch:1.4.0.2
	rel-6-0-1-branch:1.2.0.2
	hartley-6-0-post:1.3
	hartley-6-0-pre:1.2
	rel-6-0-1:1.2;
locks; strict;
comment	@ * @;


1.8
date	2004.05.21.17.33.45;	author morrison;	state dead;
branches;
next	1.7;

1.7
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.04.19.02.42;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.20.17.08.34;	author jra;	state Exp;
branches
	1.4.2.1
	1.4.4.1;
next	1.3;

1.3
date	2002.08.15.20.55.46;	author hartley;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.17.23.57.58;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.17.12.40.13;	author morrison;	state Exp;
branches;
next	;

1.4.2.1
date	2002.09.19.18.02.12;	author morrison;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2004.03.17.21.22.54;	author morrison;	state Exp;
branches;
next	;

1.4.4.1
date	2004.03.10.15.06.36;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.8
log
@moved to src/proc-db/
@
text
@/*	P I X 2 G . C
 *
 * Generates geometry from an pixmap file
 *
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <unistd.h>
#include <math.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "wdb.h"

/* workers acquire semaphore number 0 on smp machines */
#define P2G_WORKER RT_SEM_LAST
#define P2G_INIT_COUNT P2G_WORKER+1
int done=0;
int ncpu=1;

char *progname ="pix2g";

/* procedure variable start */
struct rt_wdb *db_fp;
int is_region=1;
/*	struct wmember allPixelList; */ /* defined in wdb.h */ 
struct wmember allScanlineList; /* defined in wdb.h */
int width=512;
int height=512;
double cellSize=1.0;
double objectSize=1.0;
const char *prototype="pixel";

int nextAvailableRow=0;

/* image file */
struct bu_mapped_file *image;

/* procedure variable end */


void usage(void)
{
	fprintf(stderr, "Usage: %s image_file.pix db_file.g [pixelWidth [pixelHeight [cellSize [objectSize]]]\n", progname);
	exit(-1);
}

void computeScanline( int pid, genptr_t arg ) {
	int i=0;
	/* working pixel component value */
	unsigned char *value = image->buf;
 
	/*	struct wmember *allScanlineList = (struct wmember *)arg;*/
	fflush(stdout);
	sync();

	while (i < height) {
		int j;
		char scratch[256]="";
		struct wmember scanlineList;
		BU_LIST_INIT(&scanlineList.l);
		
		bu_semaphore_acquire(P2G_WORKER);
		i=nextAvailableRow;
		nextAvailableRow++;
		bu_semaphore_release(P2G_WORKER);

		if (i >= height) {
			break;
		}

		/* cheap pretty printing */
		if (i % 64 == 0) {
			if (i != 0) {
				bu_log("[%d%%]\n[%.4d]", (int)((float)i/(float)height*100.0), i);
			} else {
				bu_log("\n[%.4d]", i);
			}
		} else {
			bu_log(".");
		}

		for (j=0; j<width; j++) {
			/*			char solidName[256]="";*/
			unsigned int r,g,b;
			unsigned char rgb[3];
			point_t p1;
			mat_t matrix;
			struct wmember wm_hd; /* defined in wdb.h */
			BU_LIST_INIT(&wm_hd.l);

			/*			bu_log("[%f:%f]", (float)i*cellSize,(float)j*cellSize);*/
			
			VSET(p1,(float)i*cellSize, (float)j*cellSize, 0.0);
			
			/* make the primitive */
			/* we do not need to make a bazillion objects if they are not going to
			 * be modified.  as such, we created one prototypical object, and all
			 * of the regions will use it.
			 ***
			   sprintf(solidName, "%dx%d.s", i+1,j+1);
				 bu_semaphore_acquire(P2G_WORKER);
				 mk_sph(db_fp, solidName, p1, objectSize/2.0);
				 bu_semaphore_release(P2G_WORKER);
			*/

			/* make the region */
			mk_addmember(prototype, &wm_hd.l, NULL, WMOP_UNION);
			/* mk_addmember(solidName, &wm_hd.l, NULL, WMOP_UNION); */
			
			/* get the rgb color values */
			r = *(value+(i*width*3)+(j*3));
			g = *(value+(i*width*3)+(j*3)+1);
			b = *(value+(i*width*3)+(j*3)+2);			
			VSET(rgb, r, g, b);
			/* VSET(rgb, 200 , 200, 200); */

			sprintf(scratch, "%dx%d.r", i+1,j+1);
			MAT_IDN(matrix);
			MAT_DELTAS(matrix, p1[0], p1[1], 0.0);

			bu_semaphore_acquire(P2G_WORKER);
			mk_lcomb(db_fp, scratch, &wm_hd, is_region, NULL, NULL, rgb, 0);			
			bu_semaphore_release(P2G_WORKER);
			
			mk_addmember(scratch, &scanlineList.l, matrix, WMOP_UNION);
		}
		
		/* write out a combination for each scanline */
		sprintf(scratch, "%d.c", i+1);
		bu_semaphore_acquire(P2G_WORKER);
		mk_lcomb(db_fp, scratch, &scanlineList, 0, NULL, NULL, NULL, 0);
		bu_semaphore_release(P2G_WORKER);
		
		/* all threads keep track of the scan line (in case they get to the end first */
		sprintf(scratch, "%d.c", i+1);
		mk_addmember(scratch, &allScanlineList.l, NULL, WMOP_UNION);
	}

}

int
main(int ac, char *av[])
{
	char imageFileName[256]="";
	char databaseFileName[256]="";
	char scratch[256]="";
	point_t origin;

	progname = *av;

	if (ac < 3) usage();

	sprintf(imageFileName, "%s", av[1]);
	sprintf(databaseFileName, "%s", av[2]);

	if (ac > 3) width=(int)atoi(av[3]);
	if (ac > 4) height=(int)atoi(av[4]);
	if (ac > 5) cellSize=(double)atof(av[5]);
	if (ac > 6) objectSize=(double)atof(av[6]);

	/*	bu_log("{%s} {%s} {%s} {%s} {%s} {%s} {%s}\n", av[0], av[1], av[2], av[3], av[4], av[5], av[6]); */

	if ((db_fp = wdb_fopen(databaseFileName)) == NULL) {
	  bu_log("unable to open database [%s]\n", databaseFileName);
		perror("Unable to open database file");
		exit(-1);
	}

	if ((image = bu_open_mapped_file(imageFileName, NULL)) == NULL) {
	  bu_log("unable to open image [%s]\n", imageFileName);
		perror("Unable to open file");
		exit(-2);
	}

	bu_log("Loading image %s from file...", imageFileName);
	if (image->buflen < width * height * 3) {
		bu_log("\nWARNING: %s needs %d bytes, file only contains %d bytes\n", width*height*3, image->buflen);
	} else if (image->buflen > width* height * 3) {
		bu_log("\nWarning: Image file size is larger than specified texture size\n");
	}
	bu_log("...done loading image\n");

	bu_log("Image size is %dx%d (%d bytes)\n", width, height, image->buflen);
	bu_log("Objects are %f with %f spacing\n", objectSize, cellSize);
	

	sprintf(scratch, "%s Geometry Image", imageFileName);
	mk_id(db_fp, scratch); /* create the database header record */

	/* make a region that is the union of these two objects
	 * To accomplish this, we need to create a linked list of the
	 * items that make up the combination.  The wm_hd structure serves
	 * as the head of the list of items.
	 */
	/*	BU_LIST_INIT(&allPixelList.l); */
	BU_LIST_INIT(&allScanlineList.l);

	/* 
	 * write out the image primitives
	 ***************/
	is_region = 1;
		
	ncpu=bu_avail_cpus();

	if (ncpu > 1) {
		bu_log("Found %d cpu\'s!  Sweet.\n", ncpu);
	}
			
	/* the first critical section semaphore is for coordinating work, the
	 * second for writing out the final record and cleaning up. 
	 */
	/* XXX must use RT_SEM_LAST if we plan on calling bu_parallel since the
	 * semaphore count is held in a global
	 */
	bu_semaphore_init(P2G_INIT_COUNT);

	bu_log("Writing database...\n");

	/* write out the prototypical pixel object */
	VSET(origin, 0.0, 0.0, 0.0);
	mk_sph(db_fp, prototype, origin, objectSize/2.0);

	/* XXX I do not like the idea of having to pass everything around in global
	 * space. but forking on our own is just as bad (need IPC)
	 */
	bu_parallel(computeScanline, ncpu, &allScanlineList);
		
	/* XXX We cannot write out one BIG combination of all the pixels due to
	 * library stack limitations and tree build implementation 
	 */
	/*	mk_lcomb(db_fp, "image.c", &allPixelList, 0, NULL, NULL, NULL, 0); */
	/* write out the main image combination */
		
	mk_lcomb(db_fp, "image.c", &allScanlineList, 0, NULL, NULL, NULL, 0);
		
	bu_log("\n...done! (see %s)\n", databaseFileName);
	
	bu_close_mapped_file(image);
	
	wdb_close(db_fp);
	
	return 0;
}
@


1.7
log
@change conf.h to a wrapped config.h
@
text
@@


1.6
log
@merge of ansi-6-0-branch into head
@
text
@d6 5
a10 1
#include "conf.h"
@


1.5
log
@cleaned up the file arguement processing and fixed some swapped indices
@
text
@d47 1
a47 1
void usage()
@


1.4
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@a36 1
char fileName[256]="";
d150 2
d159 4
a162 2
	if (ac > 2) width=(int)atoi(av[2]);
	if (ac > 3) sprintf(fileName, "%s", av[3]);
d169 3
a171 2
	if ((db_fp = wdb_fopen(av[1])) == NULL) {
		perror(av[1]);
d175 2
a176 1
	if ((image = bu_open_mapped_file(fileName, NULL)) == NULL) {
d181 1
a181 1
	bu_log("Loading image %s from file...", fileName);
d193 1
a193 1
	sprintf(scratch, "%s Geometry Image", fileName);
d242 1
a242 1
	bu_log("\n...done! (see %s)\n", av[1]);
@


1.4.4.1
log
@merge in updates from HEAD
@
text
@d37 1
a150 2
	char imageFileName[256]="";
	char databaseFileName[256]="";
d158 2
a159 4
	sprintf(imageFileName, "%s", av[1]);
	sprintf(databaseFileName, "%s", av[2]);

	if (ac > 3) width=(int)atoi(av[3]);
d166 2
a167 3
	if ((db_fp = wdb_fopen(databaseFileName)) == NULL) {
	  bu_log("unable to open database [%s]\n", databaseFileName);
		perror("Unable to open database file");
d171 1
a171 2
	if ((image = bu_open_mapped_file(imageFileName, NULL)) == NULL) {
	  bu_log("unable to open image [%s]\n", imageFileName);
d176 1
a176 1
	bu_log("Loading image %s from file...", imageFileName);
d188 1
a188 1
	sprintf(scratch, "%s Geometry Image", imageFileName);
d237 1
a237 1
	bu_log("\n...done! (see %s)\n", databaseFileName);
@


1.4.2.1
log
@Initial ANSIfication
@
text
@d48 1
a48 1
void usage(void)
@


1.4.2.2
log
@sync branch with HEAD
@
text
@d37 1
a150 2
	char imageFileName[256]="";
	char databaseFileName[256]="";
d158 2
a159 4
	sprintf(imageFileName, "%s", av[1]);
	sprintf(databaseFileName, "%s", av[2]);

	if (ac > 3) width=(int)atoi(av[3]);
d166 2
a167 3
	if ((db_fp = wdb_fopen(databaseFileName)) == NULL) {
	  bu_log("unable to open database [%s]\n", databaseFileName);
		perror("Unable to open database file");
d171 1
a171 2
	if ((image = bu_open_mapped_file(imageFileName, NULL)) == NULL) {
	  bu_log("unable to open image [%s]\n", imageFileName);
d176 1
a176 1
	bu_log("Loading image %s from file...", imageFileName);
d188 1
a188 1
	sprintf(scratch, "%s Geometry Image", imageFileName);
d237 1
a237 1
	bu_log("\n...done! (see %s)\n", databaseFileName);
@


1.3
log
@Converted from K&R to ANSI C - RFH
@
text
@d48 1
a48 1
void usage(void)
@


1.2
log
@swapped arg 2 and 3 around so they are consistent with the other conversion tools
@
text
@d48 1
a48 1
void usage()
@


1.1
log
@renamed pix2geometry.c to pix2g.c
Added matrix mulitplication capabilities to mk_addmember so translation happens properly.
@
text
@d50 1
a50 1
	fprintf(stderr, "Usage: %s db_file.g imageFile [pixelWidth [pixelHeight [cellSize [objectSize]]]\n", progname);
d158 2
a159 2
	if (ac > 2) sprintf(fileName, "%s", av[2]);
	if (ac > 3) width=(int)atoi(av[3]);
@

