head	11.14;
access;
symbols
	ansi-20040405-merged:11.11.2.1
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.11
	premerge-autoconf:11.11
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.11
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.10
	phong-branch:11.11.0.8
	photonmap-branch:11.11.0.6
	rel-6-1-DP:11.11
	windows-branch:11.11.0.4
	rel-6-0-2:11.9
	ansi-branch:11.11.0.2
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.8
	rel-5-4:11.4
	offsite-5-3-pre:11.7
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.14
date	2004.05.21.17.33.48;	author morrison;	state dead;
branches;
next	11.13;

11.13
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.12;

11.12
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2002.08.20.17.08.35;	author jra;	state Exp;
branches
	11.11.2.1;
next	11.10;

11.10
date	2002.08.15.20.55.47;	author hartley;	state Exp;
branches;
next	11.9;

11.9
date	2002.05.17.12.42.25;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2001.04.20.22.31.15;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2000.08.24.04.48.36;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.07.12.21.59.08;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.07.10.23.35.41;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.03.31.03.07.32;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.01.31.15.27.43;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.07.15.18.16.22;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.06.22;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.12.30.03.23.02;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.10.20.00.10.01;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.10.18.16.18.39;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.10.12.00.41.26;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.09.23.18.58.24;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.09.19.16.44;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.44;	author mike;	state Rel4_0;
branches;
next	1.6;

1.6
date	91.08.30.21.33.46;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	91.07.19.03.51.03;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	91.07.18.03.56.11;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	91.07.12.18.41.02;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	91.07.03.03.14.31;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.07.02.01.50.12;	author butler;	state Exp;
branches;
next	;

11.11.2.1
date	2002.09.19.18.02.13;	author morrison;	state Exp;
branches;
next	;


desc
@wall builder
@


11.14
log
@moved to src/proc-db/
@
text
@/*	W A L L . C --- build a wall.
 *
 *	Currently builds "wood frame" walls for typical building constructs.
 *	
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "raytrace.h"
#include "wdb.h"

#define min(_a, _b) ((_a) < (_b) ? (_a) : (_b))
#define max(_a, _b) ((_a) > (_b) ? (_a) : (_b))

/* declarations to support use of getopt() system call */
char *options = "w:o:n:t:b:u:c:rlhdm:T:R:";
extern char *optarg;
extern int optind, opterr, getopt(int, char *const *, const char *);

int debug = 0;
char *progname = "(noname)";
char *obj_name = "wall";
char sol_name[64];
int sol_num = 0;
char *type = "frame";
char *units = "mm";
double unit_conv = 1.0;
matp_t trans_matrix = (matp_t)NULL; 
const double degtorad =  0.01745329251994329573;

int log_cmds = 0;	/* log sessions to a log file */
/* standard construction brick:
 * 8" by 2 1/4" by 3 3/8"
 */
double brick_height = 8.0 * 25.4;
double brick_width = 2.25 * 25.4;
double brick_depth = 3.25 * 25.4;
double min_mortar = 0.25 * 25.4;

unsigned char *color;
unsigned char def_color[3];
unsigned char brick_color[3] = {160, 40, 40};
unsigned char mortar_color[3] = {190, 190, 190};

int rand_brick_color = 0;
int make_mortar = 1;

/* real dimensions of a "2 by 4" board */
double bd_thick = 3.25 * 25.4;
double bd_thin = 1.5 * 25.4;
double beam_height = 5.5 * 25.4;
double sr_thick = 0.75 * 25.4;	/* sheetrock thickness */
double stud_spacing = 16.0 * 25.4; /* spacing between vertical studs */

unsigned char sheetrock_color[3] = { 200, 200, 200 };
unsigned char stud_color[3] = { 250, 178, 108 };

char *stud_properties[] = { "plastic", "sh=10 di=0.7 sp=0.3" };

struct opening {
	struct bu_list	l;
	double		sx;	/* start in X direction */
	double		sz;	/* start in Z direction */
	double		ex;	/* end in X direction */
	double		ez;	/* end in Z direction */
} ol_hd;

#define WALL_WIDTH ol_hd.ex
#define WALL_HEIGHT ol_hd.ez

struct boardseg {
	struct bu_list	l;
	double		s;	/* start */
	double		e;	/* end */
};


/*
 *	U S A G E --- tell user how to invoke this program, then exit
 */
void usage(char *s)
{
	if (s) (void)bu_log("%s\n", s);

	bu_log("Usage: %s %s\n%s\n%s\n%s\n",
progname,
"[ -u units ] -w(all) width,height [-o(pening) lx,lz,hx,hz ...]",
" [-n name] [ -d(ebug) ] [-t {frame|brick|block|sheetrock} ] [-c R/G/B]",
" [-l(og_commands)] [-R(otate) rx/ry/rz] [-T(ranslate) dx/dy/dz]",
" brick sub-options: [-r(and_color)] [-b width,height,depth ] [-m min_mortar]"
);

	exit(1);
}


void
set_translate(char *s)
{
	double dx, dy, dz;

	if (sscanf(s, "%lf/%lf/%lf", &dx, &dy, &dz) != 3)
		usage("translation option problem\n");

    	if (!trans_matrix) {
    		trans_matrix = (matp_t)bu_calloc(sizeof(mat_t), 1,
    					"transformation matrix");
    		bcopy( (char *)bn_mat_identity, (char *)trans_matrix, sizeof(mat_t));
    	}
	
    	MAT_DELTAS(trans_matrix, dx*unit_conv, dy*unit_conv, dz*unit_conv);
}

/*
 *			B U I L D H R O T
 *
 * This routine builds a Homogeneous rotation matrix, given
 * alpha, beta, and gamma as angles of rotation.
 *
 * NOTE:  Only initialize the rotation 3x3 parts of the 4x4
 * There is important information in dx,dy,dz,s .
 */
void
buildHrot(register matp_t mat, double alpha, double beta, double ggamma)
{
	static fastf_t calpha, cbeta, cgamma;
	static fastf_t salpha, sbeta, sgamma;

	calpha = cos( alpha );
	cbeta = cos( beta );
	cgamma = cos( ggamma );

	salpha = sin( alpha );
	sbeta = sin( beta );
	sgamma = sin( ggamma );

	/*
	 * compute the new rotation to apply to the previous
	 * viewing rotation.
	 * Alpha is angle of rotation about the X axis, and is done third.
	 * Beta is angle of rotation about the Y axis, and is done second.
	 * Gamma is angle of rotation about Z axis, and is done first.
	 */
#ifdef m_RZ_RY_RX
	/* view = model * RZ * RY * RX (Neuman+Sproul, premultiply) */
	mat[0] = cbeta * cgamma;
	mat[1] = -cbeta * sgamma;
	mat[2] = -sbeta;

	mat[4] = -salpha * sbeta * cgamma + calpha * sgamma;
	mat[5] = salpha * sbeta * sgamma + calpha * cgamma;
	mat[6] = -salpha * cbeta;

	mat[8] = calpha * sbeta * cgamma + salpha * sgamma;
	mat[9] = -calpha * sbeta * sgamma + salpha * cgamma;
	mat[10] = calpha * cbeta;
#endif
	/* This is the correct form for this version of GED */
	/* view = RX * RY * RZ * model (Rodgers, postmultiply) */
	/* Point thumb along axis of rotation.  +Angle as hand closes */
	mat[0] = cbeta * cgamma;
	mat[1] = -cbeta * sgamma;
	mat[2] = sbeta;

	mat[4] = salpha * sbeta * cgamma + calpha * sgamma;
	mat[5] = -salpha * sbeta * sgamma + calpha * cgamma;
	mat[6] = -salpha * cbeta;

	mat[8] = -calpha * sbeta * cgamma + salpha * sgamma;
	mat[9] = calpha * sbeta * sgamma + salpha * cgamma;
	mat[10] = calpha * cbeta;
}

void
set_rotate(char *s)
{
	double rx, ry, rz;

	if (sscanf(s, "%lf/%lf/%lf", &rx, &ry, &rz) != 3)
		usage("rotation option problem\n");

    	if (!trans_matrix) {
    		trans_matrix = (matp_t)bu_calloc(sizeof(mat_t), 1,
	    		"rotation matrix");
    		bcopy((char *)bn_mat_identity, (char *)trans_matrix, sizeof(mat_t));
    	}
	buildHrot(trans_matrix,
		rx * degtorad,
		ry * degtorad,
		rz * degtorad);
}


/*
 *	P A R S E _ A R G S --- Parse through command line flags
 */
int parse_args(int ac, char **av)
{
	int  c;
	struct opening *op;
	double dx, dy, width, height;
	int R, G, B;
	int units_lock=0;
	FILE *logfile;

	if (  ! (progname=strrchr(*av, '/'))  )
		progname = *av;
	else
		++progname;


	BU_LIST_INIT(&ol_hd.l);

	/* Turn off getopt's error messages */
	opterr = 0;

	/* get all the option flags from the command line */
	while ((c=getopt(ac,av,options)) != EOF)
		switch (c) {
		case 'T'	: set_translate(optarg);
				units_lock = 1;
				break;
		case 'R'	: set_rotate(optarg);
				break;
		case 'b'	: if (sscanf(optarg, "%lf,%lf,%lf",
				     &width, &height, &dy) == 3) {
					brick_width = width * unit_conv;
					brick_height = height * unit_conv;
					brick_depth = dy * unit_conv;
				     	units_lock = 1;
				  } else
				  	usage("error parsing -b option\n");

				  break;
		case 'c'	: if (sscanf(optarg, "%d %d %d", &R, &G, &B)
				     == 3) {
				     	color = def_color;
					color[0] = R & 0x0ff;
					color[1] = G & 0x0ff;
					color[2] = B & 0x0ff;
				  }
				  break;
		case 'd'	: debug = !debug; break;
		case 'l'	: log_cmds = !log_cmds; break;
		case 'm'	: if ((dx=atof(optarg)) > 0.0) {
					min_mortar = dx * unit_conv;
					units_lock = 1;
					make_mortar = 1;
				} else
					usage("error parsing -m option\n");

				  break;
		case 'n'	: obj_name = optarg; break;
		case 'o'	: if (ol_hd.ex == 0.0)
					usage("set wall dim before openings\n");
				  else if (sscanf(optarg, "%lf,%lf,%lf,%lf",
				     &dx, &dy, &width, &height) == 4) {
					op = (struct opening *)bu_calloc(1, sizeof(struct opening), "calloc opening");
				     	BU_LIST_INSERT(&ol_hd.l, &op->l);
				     	op->sx = dx * unit_conv;
				     	op->sz = dy * unit_conv;
				     	op->ex = width * unit_conv;
				     	op->ez = height * unit_conv;

				     	/* do bounds checking */
				     	if (op->sx < 0.0) op->sx = 0.0;
				     	if (op->sz < 0.0) op->sz = 0.0;
				     	if (op->ex > WALL_WIDTH)
				     		op->ex = WALL_WIDTH;
				     	if (op->ez > WALL_HEIGHT)
				     		op->ez = WALL_HEIGHT;

				     	units_lock = 1;
				} else
					usage("error parsing -o option\n");
				break;
		case 'r'	: rand_brick_color = !rand_brick_color; break;
		case 't'	: type = optarg; break;
		case 'u'	: if (units_lock)
					bu_log(
					"Warning: attempting to change units in mid-parse\n");
				if ((dx=rt_units_conversion(optarg)) != 0.0) {
					unit_conv = dx;
					units = optarg;
				} else
					usage("error parsing -u (units)\n");
				break;
		case 'w'	: if (sscanf(optarg, "%lf,%lf",
				     &width, &height) == 2) {
					WALL_WIDTH = width * unit_conv;
					WALL_HEIGHT = height * unit_conv;
				     	units_lock = 1;
				  } else
				  	usage("error parsing -w (wall dimensions)\n");
				break;
		case '?'	:
		case 'h'	:
		default		: usage("Bad or help flag specified\n"); break;
		}


	if (log_cmds) {
		if ((logfile=fopen("wall.log", "a+")) == (FILE *)NULL) {
			perror("wall.log");
			exit(-1);
		}
		for (R=0 ; R < ac ; R++)
			(void)fprintf(logfile, "%s ", av[R]);
		(void)putc('\n', logfile);
		(void)fclose(logfile);
	}

	return(optind);

}


#if 0
void
v_segs(sz, ez, seglist, sx, ex)
double sz, ez, sx, ex;
struct boardseg *seglist;
{
	struct opening *op;
	struct boardseg *seg, *sp;

	seg = (struct boardseg *)bu_calloc(1, sizeof(struct boardseg), "initial seg");
	seg->s = sz;
	seg->e = ez;

	if (!seg) abort();

	/* trim opening to X bounds of wall */
    	if (seg->s < ol_hd.sz) seg->s = ol_hd.sz;
    	if (seg->e > WALL_HEIGHT) seg->e = WALL_HEIGHT;
	BU_LIST_APPEND(&(seglist->l), &(seg->l));


	for (BU_LIST_FOR(op, opening, &ol_hd.l) ) {
	    if ((sx >= op->sx && sx <= op->ex) ||
	    	    (ex >= op->sx && ex <= op->ex) ||
	    	    (sx <= op->sx && ex >= op->ex) ) {

    	    	/* opening in vertical segment */
	    	for (BU_LIST_FOR(seg, boardseg, &(seglist->l)) ) {


			if (op->sz <= seg->s) {
			    if (op->ez >= seg->e) {
			    	/* opening covers entire segment.
			    	 * segement gets deleted
			    	 */
			    	sp = BU_LIST_PLAST(boardseg, &(seg->l));
			    	BU_LIST_DEQUEUE(&(seg->l));
			    	bu_free((char *)seg, "seg free");
				if (debug)
				 	bu_log("deleting segment\n");
			    	seg = sp;
			    } else if (op->ez > seg->s) {
			    	/* opening covers begining of segment */
			    	seg->s = op->ez;
			    }
				/* else opening is entirely prior to seg->s */
			} else if (op->ez >= seg->e) {
			    if (op->sz < seg->e) {
			    	/* opening covers end of segment */
			    	seg->e = op->sz;
			    } 
			    /* else opening entirely after segment */
			} else {
				/* there is an opening in the middle of the
				 * segment.  We must divide the segment into
				 * 2 segements
				 */
				 sp = (struct boardseg *)bu_calloc(1, sizeof(struct boardseg), "alloc boardseg");
				 sp->s = seg->s;
				 sp->e = op->sz;
				 seg->s = op->ez;
				 BU_LIST_INSERT(&(seg->l), &(sp->l));
				 if (debug)
				 	bu_log("splitting segment\n");
			}



	    	    }
	    }
	}
}
#endif


void
h_segs(double sz, double ez, struct boardseg *seglist, double sx, double ex)
{
	struct opening *op;
	struct boardseg *seg, *sp;

	seg = (struct boardseg *)bu_calloc(1, sizeof(struct boardseg), "initial seg");
	seg->s = sx;
	seg->e = ex;
	/* trim opening to X bounds of wall */
    	if (seg->s < ol_hd.sx) seg->s = ol_hd.sx;
    	if (seg->e > WALL_WIDTH) seg->e = WALL_WIDTH;
	BU_LIST_APPEND(&(seglist->l), &(seg->l));



	for(BU_LIST_FOR(op, opening, &ol_hd.l) ) {

	    if ((op->sz >= sz && op->sz <= ez) ||
		(op->ez >= sz && op->ez <= ez) ||
		(op->sz <= sz && op->ez >= ez) ) {

		/* opening in horizontal segment */
	    	for (BU_LIST_FOR(seg, boardseg, &(seglist->l)) ) {
			if (op->sx <= seg->s) {
			    if (op->ex >= seg->e) {
			    	/* opening covers entire segment.
			    	 * segement gets deleted
			    	 */
			    	sp = BU_LIST_PLAST(boardseg, &(seg->l));
			    	BU_LIST_DEQUEUE(&(seg->l));
			    	bu_free((char *)seg, "seg free 2");
			    	seg = sp;

			    } else if (op->ex > seg->s) {
			    	/* opening covers begining of segment */
			    	seg->s = op->ex;
			    }
				/* else opening is entirely prior to seg->s */
			} else if (op->ex >= seg->e) {
			    if (op->sx < seg->e) {
			    	/* opening covers end of segment */
			    	seg->e = op->sx;
			    } 
			    /* else opening entirely after segment */
			} else {
				/* there is an opening in the middle of the
				 * segment.  We must divide the segment into
				 * 2 segements
				 */
				 sp = (struct boardseg *)bu_calloc(1, sizeof(struct boardseg), "alloc boardseg");
				 sp->s = seg->s;
				 sp->e = op->sx;
				 seg->s = op->ex;
				 BU_LIST_INSERT(&(seg->l), &(sp->l));
			}
		}
	    }
	}

}

void
mksolid(struct rt_wdb *fd, point_t (*pts), struct wmember *wm_hd)
{
	struct wmember *wm;
	(void)sprintf(sol_name, "s.%s.%d", obj_name, sol_num++);

	mk_arb8(fd, sol_name, &pts[0][X]);
	wm = mk_addmember(sol_name, &(wm_hd->l), NULL, WMOP_UNION);

	if (trans_matrix)
		bcopy((char *)trans_matrix, (char *)wm->wm_mat, sizeof(mat_t));
}

void
mk_h_rpp(struct rt_wdb *fd, struct wmember *wm_hd, double xmin, double xmax, double ymin, double ymax, double zmin, double zmax)
{
	point_t pts[8];
	
	VSET(pts[0], xmin, ymin, zmin);
	VSET(pts[1], xmin, ymin, zmax);
	VSET(pts[2], xmin, ymax, zmax);
	VSET(pts[3], xmin, ymax, zmin);
	VSET(pts[4], xmax, ymin, zmin);
	VSET(pts[5], xmax, ymin, zmax);
	VSET(pts[6], xmax, ymax, zmax);
	VSET(pts[7], xmax, ymax, zmin);

	mksolid(fd, pts, wm_hd);
}

void
mk_v_rpp(struct rt_wdb *fd, struct wmember *wm_hd, double xmin, double xmax, double ymin, double ymax, double zmin, double zmax)
{
	point_t pts[8];
	
	VSET(pts[0], xmin, ymin, zmin);
	VSET(pts[1], xmax, ymin, zmin);
	VSET(pts[2], xmax, ymax, zmin);
	VSET(pts[3], xmin, ymax, zmin);
	VSET(pts[4], xmin, ymin, zmax);
	VSET(pts[5], xmax, ymin, zmax);
	VSET(pts[6], xmax, ymax, zmax);
	VSET(pts[7], xmin, ymax, zmax);

	mksolid(fd, pts, wm_hd);
}

/*
 *	put the sides on a frame opening
 */
void
frame_o_sides(struct rt_wdb *fd, struct wmember *wm_hd, struct opening *op, double h)
{
	double sx, ex;

	/* put in the side(s) of the window */
	if (op->sx-bd_thin >= 0.0) {
		/* put in a closing board on the side */
		sx = op->sx-bd_thin;

		if (sx < bd_thin) sx = 0.0;
		mk_v_rpp(fd, wm_hd,
			sx,	 op->sx,
			0.0,	 bd_thick,
			bd_thin, h);

				
		if (op->sx-bd_thin*2.0 >= 0.0) {
			/* put in reinforcing board on side */

			if ((sx=op->sx-bd_thin*2.0) < bd_thin)
				sx = 0.0;

			mk_v_rpp(fd, wm_hd,
				sx,	op->sx-bd_thin,
				0.0, 	bd_thick,
				bd_thin,WALL_HEIGHT-bd_thin);
		}
	}

	/* close off the end of the opening */
	if (op->ex+bd_thin <= WALL_WIDTH) {

		ex = op->ex+bd_thin;
			
		if (ex > WALL_WIDTH-bd_thin)
			ex = WALL_WIDTH;

		mk_v_rpp(fd, wm_hd,
			op->ex,	 ex,
			0.0,	 bd_thick,
			bd_thin, h);

		if (ex+bd_thin <= WALL_WIDTH) {

			if ((ex += bd_thin) > WALL_WIDTH-bd_thin)
				ex = WALL_WIDTH;

			mk_v_rpp(fd, wm_hd,
				ex-bd_thin,	ex,
				0.0,		bd_thick,
				bd_thin,	WALL_HEIGHT-bd_thin);
		}
	}

}


/*
 *	Make the frame opening (top & bottom, call frame_o_sides for sides)
 */
void
frame_opening(struct rt_wdb *fd, struct wmember *wm_hd, struct opening *op)
{
	double pos;
	int studs;
	double dx, span;

	/* 2 vertical studs @@ op->sx-bd_thin*2.0 && op->ex+bd_thin*2.0 */




	/* build the bottom of the opening */
	if (op->sz > bd_thin) {
		/* put in bottom board of opening */

		if (op->sz-bd_thin >= bd_thin) pos = op->sz - bd_thin;
		else pos = bd_thin;

		mk_h_rpp(fd, wm_hd, op->sx, op->ex, 0.0, bd_thick,
			pos, op->sz);

		if (op->sz > bd_thin*2.0) {
			/* put in support for bottom board */
			if (op->ex - op->sx < bd_thin*2) {
				/* one wide board to support */
				mk_v_rpp(fd, wm_hd,
					op->sx, op->ex,
					0.0,	bd_thick,
					bd_thin, op->sz-bd_thin);
			} else {

				/* multiple support boards */
				mk_v_rpp(fd, wm_hd, 
					op->sx, op->sx+bd_thin,
					0.0, bd_thick,
					bd_thin, op->sz-bd_thin);

				mk_v_rpp(fd, wm_hd,
					op->ex-bd_thin, op->ex,
					0.0,	bd_thick,
					bd_thin, op->sz-bd_thin);

				/* do we need some in the span? */
				span = op->ex - op->sx;
				span -= bd_thin*2.0;

				studs = (int) (span/stud_spacing);

				dx = span / ((double)studs+1.0);

				if (debug)
					bu_log("making %d xtra studs, spacing %g on span %g\n",
						studs, dx / unit_conv,
						span / unit_conv);

				for(pos=op->sx+dx ; studs ; pos+=dx,studs--) {
					if (debug)
						bu_log("making xtra stud @@ %g\n",
						pos / unit_conv);

					mk_v_rpp(fd,	wm_hd,
						pos,	pos+bd_thin,
						0.0,	bd_thick,
						bd_thin,
						op->sz-bd_thin);
				}
			}
		}

	}


	/* build the top of the opening */
	if (op->ez < WALL_HEIGHT-bd_thin*2.0) {
		/* put in board in top of opening */


		if (op->ez+bd_thin+beam_height < WALL_HEIGHT-bd_thin) {
			/* there's room to separate the beam from the
			 * board at the top of the opening.  First, we
			 * put in the board for the top of the opening.
			 */
			mk_h_rpp(fd, wm_hd,
				op->sx, op->ex,
				0.0, bd_thick,
				op->ez, op->ez+bd_thin);


			/* put the beam in */
			mk_h_rpp(fd, wm_hd,
				max(0.0, op->sx-bd_thin),
				min(WALL_WIDTH,op->ex+bd_thin),
				0.0, bd_thick,
				WALL_HEIGHT-bd_thin-beam_height,
				WALL_HEIGHT-bd_thin);

			/* put in the offset boards */
			mk_v_rpp(fd, wm_hd, 
				op->sx, op->sx+bd_thin,
			    	0.0, bd_thick,
				op->ez+bd_thin,
				WALL_HEIGHT-bd_thin-beam_height);

			mk_v_rpp(fd, wm_hd, 
				op->ex-bd_thin, op->ex,
			    	0.0, bd_thick,
				op->ez+bd_thin,
				WALL_HEIGHT-bd_thin-beam_height);


			span = op->ex - op->sx;
			span -= bd_thin*2.0;
			
			studs = (int) (span/stud_spacing);
			dx = span / ((double)studs+1.0);

			for(pos=op->sx+dx ; studs-- ; pos += dx) {
				mk_v_rpp(fd, wm_hd, 
					pos, pos+bd_thin,
				    	0.0, bd_thick,
					op->ez+bd_thin,
					WALL_HEIGHT-bd_thin-beam_height);
			}

			frame_o_sides(fd, wm_hd, op,
				WALL_HEIGHT-bd_thin-beam_height);


		} else {
			/* Make the beam on the top of the window the top
			 * of the window.
			 */

			mk_h_rpp(fd, wm_hd,
				max(0.0, op->sx-bd_thin),
				min(WALL_WIDTH,op->ex+bd_thin),
				0.0, bd_thick,
				op->ez, WALL_HEIGHT-bd_thin);

			/* put in the sides of the opening */
			frame_o_sides(fd, wm_hd, op,
				op->ez);
		}
	} else {
		/* There is no top board capping the opening 
		 * (with the possible exception of the top rail of the wall)
		 */

		frame_o_sides(fd, wm_hd, op, WALL_HEIGHT-bd_thin);
	}
}


void
frame(struct rt_wdb *fd)
{
	struct boardseg *s_hd, *seg;
	struct opening *op;
	double pos;
	struct wmember wm_hd;

	if (WALL_WIDTH <= bd_thin*2) {
		bu_log("wall width must exceed %g.\n", (bd_thin*2)/unit_conv);
		return;
	}
	if (WALL_HEIGHT <= bd_thin*2) {
		bu_log("wall height must exceed %g.\n", (bd_thin*2)/unit_conv);
		return;
	}
	BU_LIST_INIT(&wm_hd.l);

	if (!color) color = stud_color;


	mk_id(fd, "A wall");


	/* find the segments of the base-board */
	s_hd = (struct boardseg *)bu_calloc(1, sizeof(struct boardseg), "s_hd");
	BU_LIST_INIT(&(s_hd->l));
	
	h_segs(0.0, bd_thin, s_hd, 0.0, WALL_WIDTH);
	
	/* make the base-board segments */
	while (BU_LIST_WHILE(seg, boardseg, &(s_hd->l))) {

		if (debug) {
			bu_log("baseboard seg: %g -> %g\n",
				seg->s/unit_conv, seg->e/unit_conv);
		}

		mk_h_rpp(fd, &wm_hd,
			seg->s, seg->e,
			0.0, bd_thick,
			0.0, bd_thin);

		BU_LIST_DEQUEUE(&(seg->l));
		bu_free( (char *)seg, "seg free 3");
	}

	/* now find the segments of the cap board */

	h_segs(WALL_HEIGHT - bd_thin, WALL_HEIGHT, s_hd, 0.0, WALL_WIDTH);

	/* make the cap board segments */
	while (BU_LIST_WHILE(seg, boardseg, &(s_hd->l))) {

		if (debug) {
			bu_log("capboard seg: %g -> %g\n",
				seg->s/unit_conv, seg->e/unit_conv);
		}

		mk_h_rpp(fd, &wm_hd,
			seg->s, seg->e,
			0.0, bd_thick,
			WALL_HEIGHT-bd_thin, WALL_HEIGHT);

		BU_LIST_DEQUEUE(&(seg->l));
		bu_free( (char *)seg, "seg_free 4");
	}



	/* put in the vertical stud boards that are not a part of an
	 * opening for a window or a door.
	 */
	for (pos = 0.0 ; pos <= WALL_WIDTH-bd_thin ; pos += stud_spacing) {
		register int mk_stud_flag;

		if (pos > WALL_WIDTH-bd_thin*2.0)
			pos = WALL_WIDTH-bd_thin;

		mk_stud_flag = 1;
		/* make sure stud doesn't overlap an opening */
		for (BU_LIST_FOR(op, opening, &ol_hd.l)) {
			if ((pos > op->sx-bd_thin*2.0 &&
				pos < op->ex+bd_thin*2.0) ||
			    (pos+bd_thin > op->sx-bd_thin*2.0 &&
				pos+bd_thin < op->ex+bd_thin*2.0)
			    ) {
			    	if (debug)
			    		bu_log("not making stud @@ %g\n", pos / unit_conv);

				mk_stud_flag = 0;
				break;
			}
		}
		if (mk_stud_flag) {
			/* put in the vertical stud */
		    	if (debug)
		    		bu_log("Making stud @@ %g\n", pos / unit_conv);

			mk_v_rpp(fd, &wm_hd,
				pos, pos+bd_thin,
				0.0, bd_thick,
				bd_thin, WALL_HEIGHT-bd_thin);
		}


		if (pos < WALL_WIDTH-bd_thin && 
		    pos+stud_spacing > WALL_WIDTH-bd_thin)
		    	pos = WALL_WIDTH - bd_thin - stud_spacing;
	}

	for (BU_LIST_FOR(op, opening, &ol_hd.l))
		frame_opening(fd, &wm_hd, op);


	/* put all the studding in a region */
	(void)sprintf(sol_name, "r.%s.studs", obj_name);
	mk_lcomb(fd, sol_name, &wm_hd, 1,
		stud_properties[0], stud_properties[1], color, 0);

}

void
sheetrock(struct rt_wdb *fd)
{
	point_t pts[8];
	struct wmember wm_hd;
	struct opening *op;
	int i=0;
	
	if (!color) color = sheetrock_color;

	BU_LIST_INIT(&wm_hd.l);

	/* now add the sheetrock */
	VSET(pts[0], 0.0, 0.0, 0.0);
	VSET(pts[1], 0.0, sr_thick, 0.0);
	VSET(pts[2], 0.0, sr_thick, WALL_HEIGHT);
	VSET(pts[3], 0.0, 0.0, WALL_HEIGHT);
	VSET(pts[4], WALL_WIDTH, 0.0, 0.0);
	VSET(pts[5], WALL_WIDTH, sr_thick, 0.0);
	VSET(pts[6], WALL_WIDTH, sr_thick, WALL_HEIGHT);
	VSET(pts[7], WALL_WIDTH, 0.0, WALL_HEIGHT);

	(void)sprintf(sol_name, "s.%s.sr1", obj_name);
	mk_arb8(fd, sol_name, &pts[0][X]);
	(void)mk_addmember(sol_name, &wm_hd.l, NULL, WMOP_UNION);

	for (BU_LIST_FOR(op, opening, &ol_hd.l)) {
		VSET(pts[0], op->sx, -0.01,		op->sz);
		VSET(pts[1], op->sx, sr_thick+0.01,	op->sz);
		VSET(pts[2], op->sx, sr_thick+0.01,	op->ez);
		VSET(pts[3], op->sx, -0.01,		op->ez);
		VSET(pts[4], op->ex, -0.01,		op->sz);
		VSET(pts[5], op->ex, sr_thick+0.01,	op->sz);
		VSET(pts[6], op->ex, sr_thick+0.01,	op->ez);
		VSET(pts[7], op->ex, -0.01,		op->ez);

		(void)sprintf(sol_name, "s.%s.o.%d", obj_name, i++);
		mk_arb8(fd, sol_name, &pts[0][X]);
		(void)mk_addmember(sol_name, &wm_hd.l, NULL, WMOP_SUBTRACT);
	}

	(void)sprintf(sol_name, "r.%s.sr1", obj_name);
	mk_lcomb(fd, sol_name, &wm_hd, 1, (char *)NULL, (char *)NULL,
		color, 0);

}

void
mortar_brick(struct rt_wdb *fd)
{
	struct wmember wm_hd;
#if 0
	int horiz_bricks;
	int vert_bricks;
	double mortar_height;
	double mortar_width;
	point_t pts[8];
	
	horiz_bricks = (WALL_WIDTH-brick_depth) / (brick_width + min_mortar);

	/* compute excess distance to be used in mortar */
	mortar_width = WALL_WIDTH - 
			(horiz_bricks * (brick_width + min_mortar) +
			brick_depth);

	mortar_width = min_mortar + mortar_width / (double)horiz_bricks;

	vert_bricks = WALL_HEIGHT / (brick_height+min_mortar);
	mortar_height = WALL_HEIGHT - vert_bricks * (brick_height+min_mortar);
	mortar_height = min_mortar + mortar_height/vert_bricks;


	/* make prototype brick */

	VSET(pts[0], 0.0,	  0.0,		mortar_height);
	VSET(pts[1], 0.0,	  brick_depth,	mortar_height);
	VSET(pts[2], brick_width, brick_depth,	mortar_height);
	VSET(pts[3], brick_width, 0.0,		mortar_height);

	VSET(pts[4], 0.0,	  0.0,		mortar_height+brick_height);
	VSET(pts[5], 0.0,	  brick_depth,	mortar_height+brick_height);
	VSET(pts[6], brick_width, brick_depth,	mortar_height+brick_height);
	VSET(pts[7], brick_width, 0.0,		mortar_height+brick_height);

	(void)sprintf(sol_name, "s.%s.b", obj_name);
	mk_arb8(fd, sol_name, &pts[0][X]);

	(void)mk_addmember(sol_name, &wm_hd.l, NULL, WMOP_UNION);
	*sol_name = 'r';

	if (rand_brick_color)
		mk_lcomb(fd, sol_name, &wm_hd, 1, (char *)NULL, (char *)NULL,
			(char *)NULL, 0);
	else
		mk_lcomb(fd, sol_name, &wm_hd, 1, (char *)NULL, (char *)NULL,
			brick_color, 0);


	/* make prototype mortar upon which brick will sit */
	VSET(pts[0], 0.0,	  0.0,		0.0);
	VSET(pts[1], 0.0,	  brick_depth,	0.0);
	VSET(pts[2], brick_width, brick_depth,	0.0);
	VSET(pts[3], brick_width, 0.0,		0.0);

	VSET(pts[4], 0.0,	  0.0,		mortar_height);
	VSET(pts[5], 0.0,	  brick_depth,	mortar_height);
	VSET(pts[6], brick_width, brick_depth,	mortar_height);
	VSET(pts[7], brick_width, 0.0,		mortar_height);
		
	(void)sprintf(sol_name, "s.%s.vm", obj_name);
	mk_arb8(fd, sol_name, &pts[0][X]);

	(void)mk_addmember(sol_name, &wm_hd.l, NULL, WMOP_UNION);
	*sol_name = 'r';
	mk_lcomb(fd, sol_name, &wm_hd, 1, (char *)NULL, (char *)NULL,
		mortar_color, 0);


	/* make the mortar that goes between
	 * horizontally adjacent bricks
	 */
	VSET(pts[0], 0.0,	  0.0,		0.0);
	VSET(pts[1], 0.0,	  brick_depth,	0.0);
	VSET(pts[2], 0.0,	  brick_depth,	mortar_height+brick_height);
	VSET(pts[3], 0.0,	  0.0,		mortar_height+brick_height);

	VSET(pts[4], -mortar_width, 0.0,	 0.0);
	VSET(pts[5], -mortar_width, brick_depth, 0.0);
	VSET(pts[6], -mortar_width, brick_depth, mortar_height+brick_height);
	VSET(pts[7], -mortar_width, 0.0,	 mortar_height+brick_height);

	(void)sprintf(sol_name, "s.%s.vm", obj_name);
	mk_arb8(fd, sol_name, &pts[0][X]);

	(void)mk_addmember(sol_name, &wm_hd.l, NULL, WMOP_UNION);
	*sol_name = 'r';
	mk_lcomb(fd, sol_name, &wm_hd, 1, (char *)NULL, (char *)NULL,
		mortar_color, 0);
#else
	BU_LIST_INIT(&wm_hd.l);

	bu_log("Not Yet Implemented\n");
	exit(0);

#endif
}


void
brick(struct rt_wdb *fd)
{
	struct wmember wm_hd;
#if 0
	int horiz_bricks;
	int vert_bricks;
	double mortar_height;
	double mortar_width;
	point_t pts[8];
	char proto_brick[64];
	
	if (!color) color = brick_color;

	horiz_bricks = (WALL_WIDTH-brick_depth) / brick_width;
	mortar_width = WALL_WIDTH - horiz_bricks * brick_width;
	mortar_width /= horiz_bricks;
		
	vert_bricks = WALL_HEIGHT / brick_height;
	mortar_height = 0.0;


	/* make prototype brick */

	VSET(pts[0], 0.0,	  0.0,		mortar_height);
	VSET(pts[1], 0.0,	  brick_depth,	mortar_height);
	VSET(pts[2], brick_width, brick_depth,	mortar_height);
	VSET(pts[3], brick_width, 0.0,		mortar_height);

	VSET(pts[4], 0.0,	  0.0,		mortar_height+brick_height);
	VSET(pts[5], 0.0,	  brick_depth,	mortar_height+brick_height);
	VSET(pts[6], brick_width, brick_depth,	mortar_height+brick_height);
	VSET(pts[7], brick_width, 0.0,		mortar_height+brick_height);

	(void)sprintf(proto_brick, "s.%s.b", obj_name);
	mk_arb8(fd, proto_brick, &pts[0][X]);
	(void)mk_addmember(proto_brick, &wm_hd.l, NULL, WMOP_UNION);
	*proto_brick = 'r';

	mk_lcomb(fd, proto_brick, &wm_hd, 1, (char *)NULL, (char *)NULL,
			(char *)NULL, 0);
#else
	BU_LIST_INIT(&wm_hd.l);

	bu_log("Not Yet Implemented\n");
	exit(0);

#endif
}


/*
 *	M A I N
 *
 *	Call parse_args to handle command line arguments first, then
 *	process input.
 */
int main(int ac, char **av)
{
	struct opening *op;
	struct rt_wdb *db_fd;

	ol_hd.ex = ol_hd.ez = 0.0;

	if ((parse_args(ac, av)) < ac)
		usage("excess command line arguments\n");

	if (ac < 2) usage((char *)NULL);

	(void)sprintf(sol_name, "%s.g", obj_name);
	if ((db_fd = wdb_fopen(sol_name)) == (struct rt_wdb *)NULL) {
		perror(sol_name);
		return(-1);
	}

	if (debug) {
		bu_log("Wall \"%s\"(%g) %g by %g\n", units, unit_conv,
			WALL_WIDTH/unit_conv, WALL_HEIGHT/unit_conv);
		for (BU_LIST_FOR(op, opening, &ol_hd.l)) {
			bu_log("opening at %g %g to %g %g\n",
				op->sx/unit_conv, op->sz/unit_conv,
				op->ex/unit_conv, op->ez/unit_conv);
		}
	}

	if (*type == 'f') frame(db_fd);
	else if (*type == 's') sheetrock(db_fd);
	else if (*type == 'b') {
		if (type[1] == 'm' ) mortar_brick(db_fd);
		else brick(db_fd);
	}

	wdb_close(db_fd);
	return 0;
}
@


11.13
log
@change conf.h to a wrapped config.h
@
text
@@


11.12
log
@merge of ansi-6-0-branch into head
@
text
@d6 5
a10 1
#include "conf.h"
@


11.11
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d27 1
a27 1
extern int optind, opterr, getopt();
d90 1
a90 2
void usage(s)
char *s;
d107 1
a107 2
set_translate(s)
char *s;
d133 1
a133 3
buildHrot( mat, alpha, beta, ggamma )
register matp_t mat;
double alpha, beta, ggamma;
d184 1
a184 2
set_rotate(s)
char *s;
d206 1
a206 3
int parse_args(ac, av)
int ac;
char *av[];
d403 1
a403 3
h_segs(sz, ez, seglist, sx, ex)
double sz, ez, sx, ex;
struct boardseg *seglist;
d465 1
a465 4
mksolid(fd, pts, wm_hd)
struct rt_wdb *fd;
point_t pts[8];
struct wmember *wm_hd;
d478 1
a478 4
mk_h_rpp(fd, wm_hd, xmin, xmax, ymin, ymax, zmin, zmax)
struct rt_wdb *fd;
struct wmember *wm_hd;
double xmin, xmax, ymin, ymax, zmin, zmax;
d495 1
a495 4
mk_v_rpp(fd, wm_hd, xmin, xmax, ymin, ymax, zmin, zmax)
struct rt_wdb *fd;
struct wmember *wm_hd;
double xmin, xmax, ymin, ymax, zmin, zmax;
d515 1
a515 5
frame_o_sides(fd, wm_hd, op, h)
struct rt_wdb *fd;
struct wmember *wm_hd;
struct opening *op;
double h;
d576 1
a576 4
frame_opening(fd, wm_hd, op)
struct rt_wdb *fd;
struct wmember *wm_hd;
struct opening *op;
d730 1
a730 2
frame(fd)
struct rt_wdb *fd;
d852 1
a852 2
sheetrock(fd)
struct rt_wdb *fd;
d899 1
a899 2
mortar_brick(fd)
struct rt_wdb *fd;
d1000 1
a1000 2
brick(fd)
struct rt_wdb *fd;
d1056 1
a1056 3
int main(ac,av)
int ac;
char *av[];
@


11.11.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
extern int optind, opterr, getopt(int, char *const *, const char *);
d90 2
a91 1
void usage(char *s)
d108 2
a109 1
set_translate(char *s)
d135 3
a137 1
buildHrot(register matp_t mat, double alpha, double beta, double ggamma)
d188 2
a189 1
set_rotate(char *s)
d211 3
a213 1
int parse_args(int ac, char **av)
d410 3
a412 1
h_segs(double sz, double ez, struct boardseg *seglist, double sx, double ex)
d474 4
a477 1
mksolid(struct rt_wdb *fd, point_t (*pts), struct wmember *wm_hd)
d490 4
a493 1
mk_h_rpp(struct rt_wdb *fd, struct wmember *wm_hd, double xmin, double xmax, double ymin, double ymax, double zmin, double zmax)
d510 4
a513 1
mk_v_rpp(struct rt_wdb *fd, struct wmember *wm_hd, double xmin, double xmax, double ymin, double ymax, double zmin, double zmax)
d533 5
a537 1
frame_o_sides(struct rt_wdb *fd, struct wmember *wm_hd, struct opening *op, double h)
d598 4
a601 1
frame_opening(struct rt_wdb *fd, struct wmember *wm_hd, struct opening *op)
d755 2
a756 1
frame(struct rt_wdb *fd)
d878 2
a879 1
sheetrock(struct rt_wdb *fd)
d926 2
a927 1
mortar_brick(struct rt_wdb *fd)
d1028 2
a1029 1
brick(struct rt_wdb *fd)
d1085 3
a1087 1
int main(int ac, char **av)
@


11.10
log
@Converted from K&R to ANSI C - RFH
@
text
@d27 1
a27 1
extern int optind, opterr, getopt(int, char *const *, const char *);
d90 2
a91 1
void usage(char *s)
d108 2
a109 1
set_translate(char *s)
d135 3
a137 1
buildHrot(register matp_t mat, double alpha, double beta, double ggamma)
d188 2
a189 1
set_rotate(char *s)
d211 3
a213 1
int parse_args(int ac, char **av)
d410 3
a412 1
h_segs(double sz, double ez, struct boardseg *seglist, double sx, double ex)
d474 4
a477 1
mksolid(struct rt_wdb *fd, point_t (*pts), struct wmember *wm_hd)
d490 4
a493 1
mk_h_rpp(struct rt_wdb *fd, struct wmember *wm_hd, double xmin, double xmax, double ymin, double ymax, double zmin, double zmax)
d510 4
a513 1
mk_v_rpp(struct rt_wdb *fd, struct wmember *wm_hd, double xmin, double xmax, double ymin, double ymax, double zmin, double zmax)
d533 5
a537 1
frame_o_sides(struct rt_wdb *fd, struct wmember *wm_hd, struct opening *op, double h)
d598 4
a601 1
frame_opening(struct rt_wdb *fd, struct wmember *wm_hd, struct opening *op)
d755 2
a756 1
frame(struct rt_wdb *fd)
d878 2
a879 1
sheetrock(struct rt_wdb *fd)
d926 2
a927 1
mortar_brick(struct rt_wdb *fd)
d1028 2
a1029 1
brick(struct rt_wdb *fd)
d1085 3
a1087 1
int main(int ac, char **av)
@


11.9
log
@added matrix parameter to mk_addmember()
@
text
@d27 1
a27 1
extern int optind, opterr, getopt();
d90 1
a90 2
void usage(s)
char *s;
d107 1
a107 2
set_translate(s)
char *s;
d133 1
a133 3
buildHrot( mat, alpha, beta, ggamma )
register matp_t mat;
double alpha, beta, ggamma;
d184 1
a184 2
set_rotate(s)
char *s;
d206 1
a206 3
int parse_args(ac, av)
int ac;
char *av[];
d403 1
a403 3
h_segs(sz, ez, seglist, sx, ex)
double sz, ez, sx, ex;
struct boardseg *seglist;
d465 1
a465 4
mksolid(fd, pts, wm_hd)
struct rt_wdb *fd;
point_t pts[8];
struct wmember *wm_hd;
d478 1
a478 4
mk_h_rpp(fd, wm_hd, xmin, xmax, ymin, ymax, zmin, zmax)
struct rt_wdb *fd;
struct wmember *wm_hd;
double xmin, xmax, ymin, ymax, zmin, zmax;
d495 1
a495 4
mk_v_rpp(fd, wm_hd, xmin, xmax, ymin, ymax, zmin, zmax)
struct rt_wdb *fd;
struct wmember *wm_hd;
double xmin, xmax, ymin, ymax, zmin, zmax;
d515 1
a515 5
frame_o_sides(fd, wm_hd, op, h)
struct rt_wdb *fd;
struct wmember *wm_hd;
struct opening *op;
double h;
d576 1
a576 4
frame_opening(fd, wm_hd, op)
struct rt_wdb *fd;
struct wmember *wm_hd;
struct opening *op;
d730 1
a730 2
frame(fd)
struct rt_wdb *fd;
d852 1
a852 2
sheetrock(fd)
struct rt_wdb *fd;
d899 1
a899 2
mortar_brick(fd)
struct rt_wdb *fd;
d1000 1
a1000 2
brick(fd)
struct rt_wdb *fd;
d1056 1
a1056 3
int main(ac,av)
int ac;
char *av[];
@


11.8
log
@CONST to const
@
text
@d483 1
a483 1
	wm = mk_addmember(sol_name, &(wm_hd->l), WMOP_UNION);
d902 1
a902 1
	(void)mk_addmember(sol_name, &wm_hd.l, WMOP_UNION);
d916 1
a916 1
		(void)mk_addmember(sol_name, &wm_hd.l, WMOP_SUBTRACT);
d966 1
a966 1
	(void)mk_addmember(sol_name, &wm_hd.l, WMOP_UNION);
d991 1
a991 1
	(void)mk_addmember(sol_name, &wm_hd.l, WMOP_UNION);
d1013 1
a1013 1
	(void)mk_addmember(sol_name, &wm_hd.l, WMOP_UNION);
d1064 1
a1064 1
	(void)mk_addmember(proto_brick, &wm_hd.l, WMOP_UNION);
@


11.7
log
@
mk_addmember
@
text
@d38 1
a38 1
CONST double degtorad =  0.01745329251994329573;
@


11.6
log
@
Converted to use new version of LIBWDB.
@
text
@d483 1
a483 1
	wm = mk_addmember(sol_name, wm_hd, WMOP_UNION);
d902 1
a902 1
	(void)mk_addmember(sol_name, &wm_hd, WMOP_UNION);
d916 1
a916 1
		(void)mk_addmember(sol_name, &wm_hd, WMOP_SUBTRACT);
d966 1
a966 1
	(void)mk_addmember(sol_name, &wm_hd, WMOP_UNION);
d991 1
a991 1
	(void)mk_addmember(sol_name, &wm_hd, WMOP_UNION);
d1013 1
a1013 1
	(void)mk_addmember(sol_name, &wm_hd, WMOP_UNION);
d1064 1
a1064 1
	(void)mk_addmember(proto_brick, &wm_hd, WMOP_UNION);
@


11.5
log
@
raytrace.h before wdb.h
Eliminated use of db.h
@
text
@d475 1
a475 1
FILE *fd;
d491 1
a491 1
FILE *fd;
d511 1
a511 1
FILE *fd;
d534 1
a534 1
FILE *fd;
d599 1
a599 1
FILE *fd;
d756 1
a756 1
FILE *fd;
d879 1
a879 1
FILE *fd;
d927 1
a927 1
FILE *fd;
d1029 1
a1029 1
FILE *fd;
d1090 1
a1090 1
	FILE *db_fd;
d1100 1
a1100 1
	if ((db_fd = fopen(sol_name, "w")) == (FILE *)NULL) {
d1122 2
a1123 1
	return(fclose(db_fd));
@


11.4
log
@
Changed RT_ to BU_ / BN_
@
text
@d17 2
a18 1
#include "rtlist.h"
a19 1
#include "raytrace.h"
@


11.3
log
@Eliminated some unused variables
@
text
@d70 1
a70 1
	struct rt_list	l;
d81 1
a81 1
	struct rt_list	l;
d93 1
a93 1
	if (s) (void)rt_log("%s\n", s);
d95 1
a95 1
	rt_log("Usage: %s %s\n%s\n%s\n%s\n",
d117 1
a117 1
    		trans_matrix = (matp_t)rt_calloc(sizeof(mat_t), 1,
d119 1
a119 1
    		bcopy( (char *)rt_identity, (char *)trans_matrix, sizeof(mat_t));
d197 1
a197 1
    		trans_matrix = (matp_t)rt_calloc(sizeof(mat_t), 1,
d199 1
a199 1
    		bcopy((char *)rt_identity, (char *)trans_matrix, sizeof(mat_t));
d228 1
a228 1
	RT_LIST_INIT(&ol_hd.l);
d274 2
a275 2
					op = (struct opening *)rt_calloc(1, sizeof(struct opening), "calloc opening");
				     	RT_LIST_INSERT(&ol_hd.l, &op->l);
d296 1
a296 1
					rt_log(
d343 1
a343 1
	seg = (struct boardseg *)rt_calloc(1, sizeof(struct boardseg), "initial seg");
d352 1
a352 1
	RT_LIST_APPEND(&(seglist->l), &(seg->l));
d355 1
a355 1
	for (RT_LIST_FOR(op, opening, &ol_hd.l) ) {
d361 1
a361 1
	    	for (RT_LIST_FOR(seg, boardseg, &(seglist->l)) ) {
d369 3
a371 3
			    	sp = RT_LIST_PLAST(boardseg, &(seg->l));
			    	RT_LIST_DEQUEUE(&(seg->l));
			    	rt_free((char *)seg, "seg free");
d373 1
a373 1
				 	rt_log("deleting segment\n");
d391 1
a391 1
				 sp = (struct boardseg *)rt_calloc(1, sizeof(struct boardseg), "alloc boardseg");
d395 1
a395 1
				 RT_LIST_INSERT(&(seg->l), &(sp->l));
d397 1
a397 1
				 	rt_log("splitting segment\n");
d417 1
a417 1
	seg = (struct boardseg *)rt_calloc(1, sizeof(struct boardseg), "initial seg");
d423 1
a423 1
	RT_LIST_APPEND(&(seglist->l), &(seg->l));
d427 1
a427 1
	for(RT_LIST_FOR(op, opening, &ol_hd.l) ) {
d434 1
a434 1
	    	for (RT_LIST_FOR(seg, boardseg, &(seglist->l)) ) {
d440 3
a442 3
			    	sp = RT_LIST_PLAST(boardseg, &(seg->l));
			    	RT_LIST_DEQUEUE(&(seg->l));
			    	rt_free((char *)seg, "seg free 2");
d461 1
a461 1
				 sp = (struct boardseg *)rt_calloc(1, sizeof(struct boardseg), "alloc boardseg");
d465 1
a465 1
				 RT_LIST_INSERT(&(seg->l), &(sp->l));
d652 1
a652 1
					rt_log("making %d xtra studs, spacing %g on span %g\n",
d658 1
a658 1
						rt_log("making xtra stud @@ %g\n",
d764 1
a764 1
		rt_log("wall width must exceed %g.\n", (bd_thin*2)/unit_conv);
d768 1
a768 1
		rt_log("wall height must exceed %g.\n", (bd_thin*2)/unit_conv);
d771 1
a771 1
	RT_LIST_INIT(&wm_hd.l);
d780 2
a781 2
	s_hd = (struct boardseg *)rt_calloc(1, sizeof(struct boardseg), "s_hd");
	RT_LIST_INIT(&(s_hd->l));
d786 1
a786 1
	while (RT_LIST_WHILE(seg, boardseg, &(s_hd->l))) {
d789 1
a789 1
			rt_log("baseboard seg: %g -> %g\n",
d798 2
a799 2
		RT_LIST_DEQUEUE(&(seg->l));
		rt_free( (char *)seg, "seg free 3");
d807 1
a807 1
	while (RT_LIST_WHILE(seg, boardseg, &(s_hd->l))) {
d810 1
a810 1
			rt_log("capboard seg: %g -> %g\n",
d819 2
a820 2
		RT_LIST_DEQUEUE(&(seg->l));
		rt_free( (char *)seg, "seg_free 4");
d836 1
a836 1
		for (RT_LIST_FOR(op, opening, &ol_hd.l)) {
d843 1
a843 1
			    		rt_log("not making stud @@ %g\n", pos / unit_conv);
d852 1
a852 1
		    		rt_log("Making stud @@ %g\n", pos / unit_conv);
d866 1
a866 1
	for (RT_LIST_FOR(op, opening, &ol_hd.l))
d888 1
a888 1
	RT_LIST_INIT(&wm_hd.l);
d904 1
a904 1
	for (RT_LIST_FOR(op, opening, &ol_hd.l)) {
d1018 1
a1018 1
	RT_LIST_INIT(&wm_hd.l);
d1020 1
a1020 1
	rt_log("Not Yet Implemented\n");
d1070 1
a1070 1
	RT_LIST_INIT(&wm_hd.l);
d1072 1
a1072 1
	rt_log("Not Yet Implemented\n");
d1106 1
a1106 1
		rt_log("Wall \"%s\"(%g) %g by %g\n", units, unit_conv,
d1108 2
a1109 2
		for (RT_LIST_FOR(op, opening, &ol_hd.l)) {
			rt_log("opening at %g %g to %g %g\n",
@


11.2
log
@Minor Mods for IRIX 6.2
@
text
@d929 2
a935 1
	struct wmember wm_hd;
a936 6
	RT_LIST_INIT(&wm_hd.l);

	rt_log("Not Yet Implemented\n");
	exit(0);

#if 0
d1017 6
d1031 2
a1037 1
	struct wmember wm_hd;
a1039 6
	RT_LIST_INIT(&wm_hd.l);

	rt_log("Not Yet Implemented\n");
	exit(0);

#if 0
d1069 6
a1088 1
	int arg_index;
d1094 1
a1094 1
	if ((arg_index=parse_args(ac, av)) < ac)
@


11.1
log
@Release_4.4
@
text
@d473 1
d489 1
d509 1
@


10.7
log
@DEC Alpha
@
text
@@


10.6
log
@mk_arb[48]() prototype change
@
text
@d119 1
a119 1
    		bcopy(rt_identity, trans_matrix, sizeof(mat_t));
d199 1
a199 1
    		bcopy(rt_identity, trans_matrix, sizeof(mat_t));
d485 1
a485 1
		bcopy(trans_matrix, wm->wm_mat, sizeof(mat_t));
@


10.5
log
@unsigned char complaining.
@
text
@d481 1
a481 1
	mk_arb8(fd, sol_name, pts);
d898 1
a898 1
	mk_arb8(fd, sol_name, pts);
d912 1
a912 1
		mk_arb8(fd, sol_name, pts);
d966 1
a966 1
	mk_arb8(fd, sol_name, pts);
d991 1
a991 1
	mk_arb8(fd, sol_name, pts);
d1013 1
a1013 1
	mk_arb8(fd, sol_name, pts);
d1064 1
a1064 1
	mk_arb8(fd, proto_brick, pts);
@


10.4
log
@unsigned char.
@
text
@a36 2
char *color;
char def_color[3];
d48 3
d53 1
d63 1
d66 1
@


10.3
log
@#if 0 on unused code.
@
text
@d50 2
a51 2
char brick_color[3] = {160, 40, 40};
char mortar_color[3] = {190, 190, 190};
d61 2
a62 2
char sheetrock_color[3] = { 200, 200, 200 };
char stud_color[3] = { 250, 178, 108 };
@


10.2
log
@Factored ifdefs
@
text
@d934 1
d1015 1
d1036 1
d1066 1
a1066 2

	
@


10.1
log
@Release_4.0
@
text
@d6 2
d9 3
a11 1
#ifdef BSD
a12 2
#else
#include <string.h>
@


1.6
log
@removed extern for strrchr() and added include of string(s).h
@
text
@@


1.5
log
@removed define for strrchr on BSD (now in machine.h)
@
text
@d7 5
a209 1
	char *strrchr();
@


1.4
log
@enhanced the construction of openings in frame walls.
added translation matrix so that walls may be constructed in final position.
@
text
@a204 4

#if defined(BSD) && BSD < 43
#define strrchr rindex
#endif
@


1.3
log
@added better color properties to studding.
separated studding from sheetrock in building process
added preliminary work for brick.
@
text
@d14 3
d18 1
a18 1
char *options = "w:o:n:t:b:u:c:rlhdm:";
a23 1
FILE *fd;
d32 2
d51 1
d82 1
a82 1
	if (s) (void)fputs(s, stderr);
d84 1
a84 1
	(void) fprintf(stderr, "Usage: %s %s\n%s\n%s\n%s\n",
d88 1
a88 1
" [-l(og_commands)]",
d96 5
d102 12
d115 83
d230 5
d264 3
a266 1
		case 'o'	: if (sscanf(optarg, "%lf,%lf,%lf,%lf",
d274 9
d290 1
a290 1
					(void)fprintf(stderr,
d328 1
d367 1
a367 1
				 	printf("deleting segment\n");
d391 1
a391 1
				 	printf("splitting segment\n");
d400 1
d402 1
d466 1
d472 2
a473 1
	sprintf(sol_name, "s.%s.%d", obj_name, sol_num++);
d476 4
a479 1
	(void)mk_addmember(sol_name, wm_hd, WMOP_UNION);
d482 41
d524 222
d750 1
a750 2
	struct opening *op, *nop;
	point_t pts[8];
d755 1
a755 1
		(void)fprintf(stderr, "wall width must exceed %g.\n", (bd_thin*2)/unit_conv);
d759 1
a759 1
		(void)fprintf(stderr, "wall height must exceed %g.\n", (bd_thin*2)/unit_conv);
a768 9
	/* add the thickness of the opening frame to the size of the
	 * openings
	 */
	for (RT_LIST_FOR(op, opening, &ol_hd.l)) {
		op->sx -= bd_thin;
		op->ex += bd_thin;
		op->sz -= bd_thin;
		op->ez += bd_thin;
	}
d780 1
a780 1
			printf("baseboard seg: %g -> %g\n",
d784 4
a787 8
		VSET(pts[0], seg->s, 0.0, 0.0);
		VSET(pts[1], seg->s, bd_thick, 0.0);
		VSET(pts[2], seg->s, bd_thick, bd_thin);
		VSET(pts[3], seg->s, 0.0, bd_thin);
		VSET(pts[4], seg->e, 0.0, 0.0);
		VSET(pts[5], seg->e, bd_thick, 0.0);
		VSET(pts[6], seg->e, bd_thick, bd_thin);
		VSET(pts[7], seg->e, 0.0, bd_thin);
a790 2

		mksolid(fd, pts, &wm_hd);
d801 1
a801 1
			printf("capboard seg: %g -> %g\n",
d805 4
a808 8
		VSET(pts[0], seg->s, 0.0, WALL_HEIGHT);
		VSET(pts[1], seg->s, bd_thick, WALL_HEIGHT);
		VSET(pts[2], seg->s, bd_thick, WALL_HEIGHT-bd_thin);
		VSET(pts[3], seg->s, 0.0, WALL_HEIGHT-bd_thin);
		VSET(pts[4], seg->e, 0.0, WALL_HEIGHT);
		VSET(pts[5], seg->e, bd_thick, WALL_HEIGHT);
		VSET(pts[6], seg->e, bd_thick, WALL_HEIGHT-bd_thin);
		VSET(pts[7], seg->e, 0.0, WALL_HEIGHT-bd_thin);
a811 2

		mksolid(fd, pts, &wm_hd);
a813 2
	/* make the base board for each of the openings */
	for (RT_LIST_FOR(op, opening, &ol_hd.l)) {
a814 2
	    nop = RT_LIST_NEXT(opening, &op->l);
	    RT_LIST_DEQUEUE(&(op->l));
d816 5
a820 2
	    if (op->sz > 0.0) {
		/* build base board segments for the opening */
d822 2
a823 1
		h_segs(op->sz, op->sz+bd_thin, s_hd, op->sx, op->ex);
d825 10
a834 2
		/* make opening base board(s) */
		while (RT_LIST_WHILE(seg, boardseg, &(s_hd->l))) {
d836 2
a837 3
			if (debug) {
				printf("opening base-board seg: %g -> %g (%d)\n",
					seg->s/unit_conv, seg->e/unit_conv, sol_num);
d839 5
d845 4
a848 13
			VSET(pts[0], seg->s, 0.0, op->sz);
			VSET(pts[1], seg->s, bd_thick, op->sz);
			VSET(pts[2], seg->s, bd_thick, op->sz+bd_thin);
			VSET(pts[3], seg->s, 0.0, op->sz+bd_thin);
			VSET(pts[4], seg->e, 0.0, op->sz);
			VSET(pts[5], seg->e, bd_thick, op->sz);
			VSET(pts[6], seg->e, bd_thick, op->sz+bd_thin);
			VSET(pts[7], seg->e, 0.0, op->sz+bd_thin);

			RT_LIST_DEQUEUE(&(seg->l));
			rt_free( (char *)seg, "seg_free 5");

			mksolid(fd, pts, &wm_hd);
a849 4
	    }
	    
	    if (op->ez < WALL_HEIGHT) {
		/* build cap board segments for the opening */
a850 4
		h_segs(op->ez-bd_thin, op->ez, s_hd, op->sx, op->ex);
		
		/* make opening cap board(s) */
		while (RT_LIST_WHILE(seg, boardseg, &(s_hd->l))) {
d852 3
a854 21
			if (debug) {
				printf("opening capboard seg: %g -> %g\n",
					seg->s/unit_conv, seg->e/unit_conv);
			}

			VSET(pts[0], seg->s, 0.0, op->ez);
			VSET(pts[1], seg->s, bd_thick, op->ez);
			VSET(pts[2], seg->s, bd_thick, op->ez-bd_thin);
			VSET(pts[3], seg->s, 0.0, op->ez-bd_thin);
			VSET(pts[4], seg->e, 0.0, op->ez);
			VSET(pts[5], seg->e, bd_thick, op->ez);
			VSET(pts[6], seg->e, bd_thick, op->ez-bd_thin);
			VSET(pts[7], seg->e, 0.0, op->ez-bd_thin);

			RT_LIST_DEQUEUE(&(seg->l));
			rt_free( (char *)seg, "seg_free 6");

			mksolid(fd, pts, &wm_hd);
		}
	    }
	    RT_LIST_INSERT(&(nop->l), &(op->l));
d857 2
a858 11
	/* this concludes the horizontal segments.  It's time to build the
	 * vertical studs.
	 */

	for (pos=0.0 ; pos+bd_thin*2.0 <= WALL_WIDTH ; pos += stud_spacing) {
		v_segs(bd_thin, WALL_HEIGHT-bd_thin, s_hd, pos, pos+bd_thin);
		while (RT_LIST_WHILE(seg, boardseg, &(s_hd->l))) {
			if (debug)
				printf("stud %d @@ %g Zmin:%g  Zmax:%g\n",
					sol_num, pos/unit_conv,
					seg->s/unit_conv, seg->e/unit_conv);
a859 9
			
			VSET(pts[0], pos, 	  0.0,	     seg->s);
			VSET(pts[1], pos,	  bd_thick, seg->s);
			VSET(pts[2], pos+bd_thin, bd_thick, seg->s);
			VSET(pts[3], pos+bd_thin, 0.0,	     seg->s);
			VSET(pts[4], pos, 	  0.0,	     seg->e);
			VSET(pts[5], pos,	  bd_thick, seg->e);
			VSET(pts[6], pos+bd_thin, bd_thick, seg->e);
			VSET(pts[7], pos+bd_thin, 0.0,	     seg->e);
a860 93
			RT_LIST_DEQUEUE(&(seg->l));
			rt_free( (char *)seg, "seg_free 7");

			mksolid(fd, pts, &wm_hd);
		}
	}

	/* make sure the closing stud is in place */
	if (pos - stud_spacing + bd_thin*2.0 < WALL_WIDTH ) {
		pos = WALL_WIDTH - bd_thin;
		v_segs(bd_thin, WALL_HEIGHT-bd_thin, s_hd, pos, pos+bd_thin);
		while (RT_LIST_WHILE(seg, boardseg, &(s_hd->l))) {
			if (debug)
				printf("last stud %d @@ %g Zmin:%g  Zmax:%g\n",
					sol_num, pos/unit_conv,
					seg->s/unit_conv, seg->e/unit_conv);

			VSET(pts[0], pos,	  0.0,	     seg->s);
			VSET(pts[1], pos,	  bd_thick, seg->s);
			VSET(pts[2], pos+bd_thin, bd_thick, seg->s);
			VSET(pts[3], pos+bd_thin, 0.0,          seg->s);
			VSET(pts[4], pos,	  0.0,          seg->e);
			VSET(pts[5], pos,	  bd_thick, seg->e);
			VSET(pts[6], pos+bd_thin, bd_thick, seg->e);
			VSET(pts[7], pos+bd_thin, 0.0,	     seg->e);

			RT_LIST_DEQUEUE(&(seg->l));
			rt_free( (char *)seg, "seg_free 8");

			mksolid(fd, pts, &wm_hd);
		}
	}


	/* put the vertical frame pieces in the openings */
	for (RT_LIST_FOR(op, opening, &ol_hd.l)) {

	    nop = RT_LIST_NEXT(opening, &op->l);
	    RT_LIST_DEQUEUE(&(op->l));

	    if (op->sx > 0.0) {
	    	v_segs(op->sz+bd_thin, op->ez-bd_thin, s_hd, op->sx, op->sx+bd_thin);
		while (RT_LIST_WHILE(seg, boardseg, &(s_hd->l))) {
			if (debug)
				printf("opening vl frame @@ %g Zmin:%g  Zmax:%g\n",
					op->sx/unit_conv,
					seg->s/unit_conv, seg->e/unit_conv);

			VSET(pts[0], op->sx,	     0.0,		seg->s);
			VSET(pts[1], op->sx,	     bd_thick, seg->s);
			VSET(pts[2], op->sx+bd_thin, bd_thick, seg->s);
			VSET(pts[3], op->sx+bd_thin, 0.0,		seg->s);
			VSET(pts[4], op->sx,	     0.0,		seg->e);
			VSET(pts[5], op->sx,	     bd_thick, seg->e);
			VSET(pts[6], op->sx+bd_thin, bd_thick, seg->e);
			VSET(pts[7], op->sx+bd_thin, 0.0,		seg->e);

			RT_LIST_DEQUEUE(&(seg->l));
			rt_free( (char *)seg, "seg free 9");

			mksolid(fd, pts, &wm_hd);
		}
	    	
	    }
	    if (op->ex < WALL_WIDTH) {
	    	v_segs(op->sz+bd_thin, op->ez-bd_thin, s_hd, op->ex-bd_thin, op->ex);
		while (RT_LIST_WHILE(seg, boardseg, &(s_hd->l))) {
			if (debug)
				printf("opening vr frame @@ %g Zmin:%g  Zmax:%g\n",
					op->sx/unit_conv,
					seg->s/unit_conv, seg->e/unit_conv);

			VSET(pts[0], op->ex-bd_thin, 0.0,		seg->s);
			VSET(pts[1], op->ex-bd_thin, bd_thick,	seg->s);
			VSET(pts[2], op->ex, 	     bd_thick, seg->s);
			VSET(pts[3], op->ex,	     0.0,		seg->s);
			VSET(pts[4], op->ex-bd_thin, 0.0,		seg->e);
			VSET(pts[5], op->ex-bd_thin, bd_thick, seg->e);
			VSET(pts[6], op->ex,	     bd_thick, seg->e);
			VSET(pts[7], op->ex,	     0.0,		seg->e);

			RT_LIST_DEQUEUE(&(seg->l));
			rt_free( (char *)seg, "seg_free 10");

			mksolid(fd, pts, &wm_hd);
		}
	    }

	    RT_LIST_INSERT(&(nop->l), &(op->l));

	}


d862 1
a862 1
	sprintf(sol_name, "r.%s.studs", obj_name);
d891 1
a891 1
	sprintf(sol_name, "s.%s.sr1", obj_name);
d905 1
a905 1
		sprintf(sol_name, "s.%s.o.%d", obj_name, i++);
d910 1
a910 1
	sprintf(sol_name, "r.%s.sr1", obj_name);
a923 1
	int make_mortar = (type[1] == 'm');
d929 1
a929 1
	fputs("Not Yet Implemented\n", stderr);
d958 1
a958 1
	sprintf(sol_name, "s.%s.b", obj_name);
d983 1
a983 1
	sprintf(sol_name, "s.%s.vm", obj_name);
d1005 1
a1005 1
	sprintf(sol_name, "s.%s.vm", obj_name);
a1022 1
	int make_mortar = (type[1] == 'm');
d1029 1
a1029 1
	fputs("Not Yet Implemented\n", stderr);
d1054 1
a1054 1
	sprintf(proto_brick, "s.%s.b", obj_name);
d1078 1
d1080 2
d1087 2
a1088 2
	sprintf(sol_name, "%s.g", obj_name);
	if ((fd = fopen(sol_name, "w")) == (FILE *)NULL) {
d1094 1
a1094 1
		printf("Wall \"%s\"(%g) %g by %g\n", units, unit_conv,
d1097 1
a1097 1
			printf("opening at %g %g to %g %g\n",
d1103 2
a1104 2
	if (*type == 'f') frame(fd);
	else if (*type == 's') sheetrock(fd);
d1106 2
a1107 2
		if (type[1] == 'm' ) mortar_brick(fd);
		else brick(fd);
d1110 1
a1110 1
	return(fclose(fd));
@


1.2
log
@ANSI lint
@
text
@d1 4
a4 3
/*
 *	Options
 *	h	help
d12 1
d14 4
d19 34
d61 3
a69 4
/* declarations to support use of getopt() system call */
char *options = "w:o:hn:d";
extern char *optarg;
extern int optind, opterr, getopt();
a70 8
int debug =0;
char *progname = "(noname)";
FILE *fd;
char *name = "wall";
char sol_name[64];
int sol_num = 0;
char sheetrock_color[3] = { '\200', '\200', '\200' };
char stud_color[3] = { '\200', '\200', '\150' };
d79 8
a86 3
	(void) fprintf(stderr,
	"Usage: %s -w(all) width,height [-o(pening) lx,lz,hx,hz ...] model.g\n",
			progname);
d90 2
d100 4
d107 3
d116 1
d125 18
d144 10
a153 7
		case 'w'	: if (sscanf(optarg, "%lf,%lf",
					&width, &height)
				      == 2 && width > 3.0 && height > 3.0) {
					ol_hd.ex = width;
					ol_hd.ez = height;
				      }
				break;
d158 7
a164 5
				     	op->sx = dx;
				     	op->sz = dy;
				     	op->ex = width;
				     	op->ez = height;
				}
d166 19
a184 1
		case 'n'	: name = optarg; break;
a189 2
	if (ol_hd.ex <= 3.0) usage("wall width must exceed 3.0 in.\n");
	if (ol_hd.ez <= 3.0) usage("wall height must exceed 3.0 in.\n");
d191 11
d203 1
a205 6
void
fix_units(pts)
point_t pts[8];
{
	double unit_conv=25.4;
	int i;
a206 7
	for (i=0 ; i < 8 ; ++i) {
		(pts[i])[0] *= unit_conv;
		(pts[i])[1] *= unit_conv;
		(pts[i])[2] *= unit_conv;
	}
}

d218 3
d223 1
a223 1
    	if (seg->e > ol_hd.ez) seg->e = ol_hd.ez;
d226 1
d228 3
a230 5
	    for (RT_LIST_FOR(seg, boardseg, &(seglist->l)) ) {
	    	if ((op->sx >= sx && op->sx <= ex) ||
	    	    (op->ex >= sx && op->ez <= ex) ||
	    	    (op->sx <= sx && op->ex >= ex) ) {
	    	    	/* opening in vertical segment */
d232 4
d241 1
d243 4
a246 1
			    	rt_free((char *)seg);
d268 2
d292 1
a292 1
    	if (seg->e < ol_hd.ex) seg->e = ol_hd.ex;
a297 1
	    for (RT_LIST_FOR(seg, boardseg, &(seglist->l)) ) {
d299 6
a304 4
		if ((op->sz >= sz && op->sz <= ez) ||
		    (op->ez >= sz && op->ez <= ez) ||
		    (op->sz <= sz && op->ez >= ez) ) {
			/* opening in horizontal segment */
d310 1
d312 3
a314 1
			    	rt_free((char *)seg);
d347 1
a347 3
	struct wmember *wm;
	
	sprintf(sol_name, "s.%s.%d", name, sol_num++);
d349 2
a350 5
	fix_units(pts);
	mk_arb8(fd, sol_name, (CONST point_t *)pts);


	wm = mk_addmember(sol_name, wm_hd, WMOP_UNION);
d361 1
a361 2
	int i=0;
	struct wmember wm_hd, wm_hd2, *wm;
d363 8
a371 1
	RT_LIST_INIT(&wm_hd2.l);
d373 3
d382 4
a385 4
		op->sx -= 1.5;
		op->ex += 1.5;
		op->sz -= 1.5;
		op->ez += 1.5;
d392 1
a392 1
	h_segs(0.0, 1.5, s_hd, 0.0, ol_hd.ex);
d398 2
a399 1
			printf("baseboard seg: %g -> %g\n", seg->s, seg->e);
d402 8
a409 8
		VSET(pts[0], seg->s, 0.75, 0.0);
		VSET(pts[1], seg->s, 4.075, 0.0);
		VSET(pts[2], seg->s, 4.075, 1.5);
		VSET(pts[3], seg->s, 0.75, 1.5);
		VSET(pts[4], seg->e, 0.75, 0.0);
		VSET(pts[5], seg->e, 4.075, 0.0);
		VSET(pts[6], seg->e, 4.075, 1.5);
		VSET(pts[7], seg->e, 0.75, 1.5);
d412 1
a412 1
		rt_free( (char *)seg);
d419 1
a419 1
	h_segs(ol_hd.ez - 1.5, ol_hd.ez, s_hd, 0.0, ol_hd.ex);
d425 2
a426 1
			printf("capboard seg: %g -> %g\n", seg->s, seg->e);
d429 8
a436 8
		VSET(pts[0], seg->s, 0.75, ol_hd.ez);
		VSET(pts[1], seg->s, 4.075, ol_hd.ez);
		VSET(pts[2], seg->s, 4.075, ol_hd.ez-1.5);
		VSET(pts[3], seg->s, 0.75, ol_hd.ez-1.5);
		VSET(pts[4], seg->e, 0.75, ol_hd.ez);
		VSET(pts[5], seg->e, 4.075, ol_hd.ez);
		VSET(pts[6], seg->e, 4.075, ol_hd.ez-1.5);
		VSET(pts[7], seg->e, 0.75, ol_hd.ez-1.5);
d439 1
a439 1
		rt_free( (char *)seg);
d453 2
a454 2
		h_segs(op->sz, op->sz+1.5, s_hd, op->sx, op->ex);
		
d459 2
a460 1
				printf("opening base-board seg: %g -> %g\n", seg->s, seg->e);
d463 8
a471 9
			VSET(pts[0], op->sx, 0.75, op->sz);
			VSET(pts[1], op->sx, 4.075, op->sz);
			VSET(pts[2], op->sx, 4.075, op->sz+1.5);
			VSET(pts[3], op->sx, 0.75, op->sz+1.5);
			VSET(pts[4], op->ex, 0.75, op->sz);
			VSET(pts[5], op->ex, 4.075, op->sz);
			VSET(pts[6], op->ex, 4.075, op->sz+1.5);
			VSET(pts[7], op->ex, 0.75, op->sz+1.5);

d473 1
a473 1
			rt_free( (char *)seg);
d479 1
a479 1
	    if (op->ez < ol_hd.ez) {
d482 1
a482 1
		h_segs(op->ez-1.5, op->ez, s_hd, op->sx, op->ex);
d489 1
a489 1
					seg->s, seg->e);
d492 8
a499 8
			VSET(pts[0], op->sx, 0.75, op->ez);
			VSET(pts[1], op->sx, 4.075, op->ez);
			VSET(pts[2], op->sx, 4.075, op->ez-1.5);
			VSET(pts[3], op->sx, 0.75, op->ez-1.5);
			VSET(pts[4], op->ex, 0.75, op->ez);
			VSET(pts[5], op->ex, 4.075, op->ez);
			VSET(pts[6], op->ex, 4.075, op->ez-1.5);
			VSET(pts[7], op->ex, 0.75, op->ez-1.5);
d502 1
a502 1
			rt_free( (char *)seg);
d514 2
a515 2
	for (pos = 0.0 ; pos <= ol_hd.ex-1.5 ; pos += 16.0) {
		v_segs(1.5, ol_hd.ez-1.5, s_hd, pos, pos+1.5);
d518 3
a520 2
				printf("stud @@ %g Zmin:%g  Zmax:%g\n",
					pos, seg->s, seg->e);
d523 8
a530 8
			VSET(pts[0], pos, 0.75, seg->s);
			VSET(pts[1], pos, 4.075, seg->s);
			VSET(pts[2], pos+1.5, 4.075, seg->s);
			VSET(pts[3], pos+1.5, 4.075, seg->s);
			VSET(pts[4], pos, 0.75, seg->e);
			VSET(pts[5], pos, 4.075, seg->e);
			VSET(pts[6], pos+1.5, 4.075, seg->e);
			VSET(pts[7], pos+1.5, 4.075, seg->e);
d533 1
a533 1
			rt_free( (char *)seg);
d540 3
a542 3
	if (pos-16.0 < ol_hd.ex-3.0) {
		pos = ol_hd.ex - 1.5;
		v_segs(1.5, ol_hd.ez-1.5, s_hd, pos, pos+1.5);
d545 3
a547 2
				printf("stud @@ %g Zmin:%g  Zmax:%g\n",
					pos, seg->s, seg->e);
d549 8
a556 8
			VSET(pts[0], pos, 0.75, seg->s);
			VSET(pts[1], pos, 4.075, seg->s);
			VSET(pts[2], pos+1.5, 4.075, seg->s);
			VSET(pts[3], pos+1.5, 4.075, seg->s);
			VSET(pts[4], pos, 0.75, seg->e);
			VSET(pts[5], pos, 4.075, seg->e);
			VSET(pts[6], pos+1.5, 4.075, seg->e);
			VSET(pts[7], pos+1.5, 4.075, seg->e);
d559 1
a559 1
			rt_free( (char *)seg);
d573 1
a573 1
	    	v_segs(op->sz+1.5, op->ez-1.5, s_hd, op->sx, op->sx+1.5);
d577 2
a578 1
					op->sx, seg->s, seg->e);
d580 8
a587 8
			VSET(pts[0], op->sx, 0.75, seg->s);
			VSET(pts[1], op->sx, 4.075, seg->s);
			VSET(pts[2], op->sx+1.5, 4.075, seg->s);
			VSET(pts[3], op->sx+1.5, 0.75, seg->s);
			VSET(pts[4], op->sx, 0.75, seg->e);
			VSET(pts[5], op->sx, 4.075, seg->e);
			VSET(pts[6], op->sx+1.5, 4.075, seg->e);
			VSET(pts[7], op->sx+1.5, 0.75, seg->e);
d590 1
a590 1
			rt_free( (char *)seg);
d596 2
a597 2
	    if (op->ex < ol_hd.ex) {
	    	v_segs(op->sz+1.5, op->ez-1.5, s_hd, op->ex-1.5, op->ex);
d600 3
a602 2
				printf("opening vl frame @@ %g Zmin:%g  Zmax:%g\n",
					op->sx, seg->s, seg->e);
d604 8
a611 8
			VSET(pts[0], op->ex-1.5, 0.75, seg->s);
			VSET(pts[1], op->ex-1.5, 4.075, seg->s);
			VSET(pts[2], op->ex, 4.075, seg->s);
			VSET(pts[3], op->ex, 0.75, seg->s);
			VSET(pts[4], op->ex-1.5, 0.75, seg->e);
			VSET(pts[5], op->ex-1.5, 4.075, seg->e);
			VSET(pts[6], op->ex, 4.075, seg->e);
			VSET(pts[7], op->ex, 0.75, seg->e);
d614 1
a614 1
			rt_free( (char *)seg);
d624 1
d626 3
a628 3
	sprintf(sol_name, "r.%s.studs", name);
	mk_lcomb(fd, sol_name, &wm_hd, 1, (char *)NULL, (char *)NULL,
		stud_color, 0);
d630 1
a630 9
	/* add some sheet-rock */
	VSET(pts[0], 0.0, 0.0, 0.0);
	VSET(pts[1], 0.0, 0.75, 0.0);
	VSET(pts[2], 0.0, 0.75, ol_hd.ez);
	VSET(pts[3], 0.0, 0.0, ol_hd.ez);
	VSET(pts[4], ol_hd.ex, 0.0, 0.0);
	VSET(pts[5], ol_hd.ex, 0.75, 0.0);
	VSET(pts[6], ol_hd.ex, 0.75, ol_hd.ez);
	VSET(pts[7], ol_hd.ex, 0.0, ol_hd.ez);
d632 10
a641 4
	sprintf(sol_name, "s.%s.sr1", name);
	fix_units(pts);
	mk_arb8(fd, sol_name, (CONST point_t *)pts);
	wm = mk_addmember(sol_name, &wm_hd, WMOP_UNION);
d643 1
d645 9
a653 8
	VSET(pts[0], 0.0, 4.075, 0.0);
	VSET(pts[1], 0.0, 4.825, 0.0);
	VSET(pts[2], 0.0, 4.825, ol_hd.ez);
	VSET(pts[3], 0.0, 4.075, ol_hd.ez);
	VSET(pts[4], ol_hd.ex, 4.075, 0.0);
	VSET(pts[5], ol_hd.ex, 4.825, 0.0);
	VSET(pts[6], ol_hd.ex, 4.825, ol_hd.ez);
	VSET(pts[7], ol_hd.ex, 4.075, ol_hd.ez);
d655 3
a657 4
	sprintf(sol_name, "s.%s.sr2", name);
	fix_units(pts);
	mk_arb8(fd, sol_name, (CONST point_t *)pts);
	wm = mk_addmember(sol_name, &wm_hd2, WMOP_UNION);
a658 1

d660 8
a667 8
		VSET(pts[0], op->sx, -0.01, op->sz);
		VSET(pts[1], op->sx, 4.826, op->sz);
		VSET(pts[2], op->sx, 4.826, op->ez);
		VSET(pts[3], op->sx, -0.01, op->ez);
		VSET(pts[4], op->ex, -0.01, op->sz);
		VSET(pts[5], op->ex, 4.826, op->sz);
		VSET(pts[6], op->ex, 4.826, op->ez);
		VSET(pts[7], op->ex, -0.01, op->ez);
d669 3
a671 5
		sprintf(sol_name, "s.%s.o.%d", name, i++);
		fix_units(pts);
		mk_arb8(fd, sol_name, (CONST point_t *)pts);
		wm = mk_addmember(sol_name, &wm_hd, WMOP_SUBTRACT);
		wm = mk_addmember(sol_name, &wm_hd2, WMOP_SUBTRACT);
d674 1
a674 1
	sprintf(sol_name, "r.%s.sr1", name);
d676 1
a676 1
		sheetrock_color, 0);
a677 3
	sprintf(sol_name, "r.%s.sr2", name);
	mk_lcomb(fd, sol_name, &wm_hd2, 1, (char *)NULL, (char *)NULL,
		sheetrock_color, 0);
d680 152
d845 2
a846 2
	if ((arg_index=parse_args(ac, av)) >= ac)
		usage("no database file specified\n");
d848 1
d850 3
a852 2
	if ((fd = fopen(av[arg_index], "w")) == (FILE *)NULL) {
		perror(av[arg_index]);
d857 2
a858 1
		printf("Wall %g by %g\n", ol_hd.ex, ol_hd.ez);
d861 2
a862 1
				op->sx, op->sz, op->ex, op->ez);
d866 6
a871 1
	frame(fd);
@


1.1
log
@Initial revision
@
text
@d252 1
a252 1
	mk_arb8(fd, sol_name, pts);
d531 1
a531 1
	mk_arb8(fd, sol_name, pts);
d546 1
a546 1
	mk_arb8(fd, sol_name, pts);
d562 1
a562 1
		mk_arb8(fd, sol_name, pts);
@
