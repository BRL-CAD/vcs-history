head	11.19;
access;
symbols
	ansi-20040405-merged:11.15.2.2
	postmerge-20040405-ansi:11.17
	premerge-20040404-ansi:11.16
	postmerge-autoconf:11.16
	autoconf-freeze:11.15.10.2
	premerge-autoconf:11.16
	postmerge-20040315-windows:11.16
	premerge-20040315-windows:11.16
	windows-20040315-freeze:11.15.4.1
	autoconf-20031203:11.15
	autoconf-20031202:11.15
	autoconf-branch:11.15.0.10
	phong-branch:11.15.0.8
	photonmap-branch:11.15.0.6
	rel-6-1-DP:11.15
	windows-branch:11.15.0.4
	rel-6-0-2:11.13
	ansi-branch:11.15.0.2
	rel-6-0-1-branch:11.13.0.2
	hartley-6-0-post:11.14
	hartley-6-0-pre:11.13
	rel-6-0-1:11.13
	rel-6-0:11.12
	rel-5-4:11.4
	offsite-5-3-pre:11.11
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:1.7;
locks; strict;
comment	@ * @;


11.19
date	2004.05.21.17.33.43;	author morrison;	state dead;
branches;
next	11.18;

11.18
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.17;

11.17
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2004.02.02.17.39.37;	author morrison;	state Exp;
branches;
next	11.15;

11.15
date	2002.08.20.17.08.33;	author jra;	state Exp;
branches
	11.15.2.1
	11.15.4.1
	11.15.10.1;
next	11.14;

11.14
date	2002.08.15.20.55.46;	author hartley;	state Exp;
branches;
next	11.13;

11.13
date	2002.05.17.12.42.24;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2001.03.31.01.57.27;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2000.08.24.04.37.03;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.07.12.21.59.07;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.07.12.03.16.33;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.07.10.23.46.49;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.10.23.42.20;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.07.10.23.38.20;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.07.10.23.35.38;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.10.30.03.06.26;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	97.01.08.04.48.02;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.01.08.04.47.26;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.06.11;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.11.14.22.12.10;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.10.21.20.05.46;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.10.20.00.09.10;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.09.19.10.21;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.35;	author mike;	state Rel4_0;
branches;
next	9.5;

9.5
date	91.07.02.03.09.35;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.08.06.10.04;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.11.01.05.14.47;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.10.16.11.18.17;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.04.40;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.04.30.21.38.13;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.38.13;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.08.20.07.26.20;	author phil;	state Exp;
branches;
next	7.4;

7.4
date	88.05.15.23.00.08;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	87.12.24.06.55.46;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.12.24.02.20.08;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.16.49.04;	author mike;	state Rel;
branches;
next	1.7;

1.7
date	87.10.30.15.34.11;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	87.10.15.02.36.58;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	87.10.15.01.23.18;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	87.09.26.08.06.08;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	87.09.25.23.20.23;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	87.09.22.02.59.51;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.09.20.12.11.20;	author mike;	state Exp;
branches;
next	;

11.15.2.1
date	2002.09.19.18.02.11;	author morrison;	state Exp;
branches;
next	11.15.2.2;

11.15.2.2
date	2004.03.17.21.22.54;	author morrison;	state Exp;
branches;
next	;

11.15.4.1
date	2004.03.10.15.06.36;	author morrison;	state Exp;
branches;
next	;

11.15.10.1
date	2004.02.12.19.50.50;	author erikg;	state Exp;
branches;
next	11.15.10.2;

11.15.10.2
date	2004.03.15.14.08.05;	author erikg;	state Exp;
branches;
next	;


desc
@Program for generating procedural clutter.
@


11.19
log
@moved to src/proc-db/
@
text
@/*
 *			C L U T T E R . C
 * 
 *  Program to generate procedural clutter out of primitive
 *  geometric objects.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright 
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/proc-db/clutter.c,v 11.18 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "wdb.h"

mat_t	identity;
double degtorad = 0.0174532925199433;
double sin60;

struct mtab {
	char	mt_name[64];
	char	mt_param[96];
} mtab[] = {
	{"plastic",	""},
	{"glass",	""},
	{"plastic",	""},
	{"mirror",	""},
	{"plastic",	""},
	{"testmap",	""},
	{"plastic",	""},
	{"",		""}
};
int	nmtab = sizeof(mtab)/sizeof(struct mtab);

#define PICK_MAT	((rand() % nmtab) )

double ball_stack(char *bname, double xc, double yc, double size);
double prim_stack(char *pname, double xc, double yc, double size);
double crystal_stack(char *cname, double xc, double yc, double size);
double crystal_layer(char *crname, fastf_t *center, double radius, fastf_t *maj, fastf_t *min, double var, double ratio, int nsolids);

void	do_plate(char *name, double xc, double yc, double size);
void	do_rings(char *ringname, fastf_t *center, double r1, double r2, double incr, int n);

void	get_rgb(unsigned char *rgb);
void	do_light(char *name, point_t pos, vect_t dir_at, int da_flag, double r, unsigned char *rgb, struct wmember *headp);

struct bn_unif	*rbuf;

struct rt_wdb	*outfp;

int
main(int argc, char **argv)
{
	vect_t	norm;
	unsigned char	rgb[3];
	int	ix, iy;
	double	x, y;
	double	size;
	double	base;
	int	quant;
	char	name[64];
	vect_t	pos, aim;
	unsigned char	white[3];
	int	n;
	double	height, maxheight, minheight;
	struct wmember head;

	bu_debug = BU_DEBUG_COREDUMP;
	rbuf = bn_unif_init( 0, 0 );

#define rand_num(p)	(BN_UNIF_DOUBLE(p)+0.5)



	BU_LIST_INIT( &head.l );

	sin60 = sin(60.0 * 3.14159265358979323846264 / 180.0);

	outfp = wdb_fopen( "clutter.g" );
	mk_id( outfp, "Procedural Clutter" );

	/* Create the underpinning */
	VSET( norm, 0, 0, 1 );
	mk_half( outfp, "plane", norm, -10.0 );
	rgb[0] = 240;	/* gold/brown */
	rgb[1] = 180;
	rgb[2] = 64;
	MAT_IDN( identity );

	mk_region1( outfp, "plane.r", "plane", NULL, NULL, rgb );

	(void)mk_addmember( "plane.r", &head.l, NULL, WMOP_UNION );

	/* Create the detail cells */
	size = 1000;	/* mm */
	quant = 7;	/* XXXX 5 */
	base = -size*(quant/2);
	maxheight = size/2;		/* keep lights off the floor */
	for( ix=quant-1; ix>=0; ix-- )  {
		x = base + ix*size;
		for( iy=quant-1; iy>=0; iy-- )  {
			y = base + iy*size;
			sprintf( name, "Bx%dy%d", ix, iy );
			do_plate( name, x, y, size );
			(void)mk_addmember( name, &head.l, NULL, WMOP_UNION );

			sprintf( name, "x%dy%d", ix, iy );
			(void)mk_addmember( name, &head.l, NULL, WMOP_UNION );
			n = rand() & 03;
			switch(n)  {
			case 0:
				height = ball_stack( name, x, y, size );
				break;
			case 1:
				height = crystal_stack( name, x, y, size );
				break;
			default:
				height = prim_stack( name, x, y, size );
				break;
			}
			if( height > maxheight )  maxheight = height;
		}
	}

	/* Enclose in some rings */
	minheight = size/2;
	VSET( pos, 0, 0, size/4 );
	do_rings( "rings", pos, 2*size*quant/2, size/4, size, 4 );
	(void)mk_addmember( "rings", &head.l, NULL, WMOP_UNION );

	if( maxheight < minheight ) maxheight = minheight;

	/* Create some light */
	white[0] = white[1] = white[2] = 255;
	base = size*(quant/2+1);
	VSET( aim, 0, 0, 0 );
	VSET( pos, base, base, minheight+maxheight*rand_num(rbuf) );
	do_light( "l1", pos, aim, 1, 100.0, white, &head );
	VSET( pos, -base, base, minheight+maxheight*rand_num(rbuf) );
	do_light( "l2", pos, aim, 1, 100.0, white, &head );
	VSET( pos, -base, -base, minheight+maxheight*rand_num(rbuf) );
	do_light( "l3", pos, aim, 1, 100.0, white, &head );
	VSET( pos, base, -base, minheight+maxheight*rand_num(rbuf) );
	do_light( "l4", pos, aim, 1, 100.0, white, &head );

	/* Build the overall combination */
	mk_lfcomb( outfp, "clut", &head, 0 );

	return 0;
}

double
crystal_stack(char *cname, double xc, double yc, double size)
    	       
      	       		/* center coordinates, z=0+ */
      	     
{
	int	i;
	point_t	center;
	vect_t	maj, min;
	int	nsolids;
	unsigned char	rgb[4];		/* needs all 4 */
	double	high;
	double	height = 0;
	double	esz;
	char	name[64];
	char	rppname[64];
	char	crystalname[64];
	vect_t	minpt, maxpt;
	struct wmember head;
	struct wmember reg_head;

	BU_LIST_INIT( &head.l );

	/* These should change somewhat for each layer, and be done by rots */
	VSET( maj, 1, 0, .2 );
	VSET( min, 0, 1, .2 );
	VUNITIZE( maj );
	VUNITIZE( min );

	for( i=0; i<3; i++ )  {
		sprintf( name, "%sL%c", cname, 'a'+i);
		(void)mk_addmember( name, &head.l, NULL, WMOP_UNION );
		VSET( center, xc, yc, size/2*i );
		nsolids = 3 + (rand() & 7);

		high = crystal_layer( name, center, size/2,
			maj, min,
			rand_num(rbuf) * 90.0,
			rand_num(rbuf) * 8.0 + 2.0,
			nsolids );
		if( high > height )  height = high;
	}

	/* Build the crystal union */
	sprintf( crystalname, "%scrystal", cname );
	mk_lfcomb( outfp, crystalname, &head, 0 );

	/* Make the trimming RPP */
	esz = size*0.5;	/* dist from ctr to edge of base */
	VSET( minpt, xc-esz, yc-esz, 10 );
	VSET( maxpt, xc+esz, yc+esz, height );
	sprintf( rppname, "%srpp", cname );
	mk_rpp( outfp, rppname, minpt, maxpt );

	/* Build the final combination */
	BU_LIST_INIT( &reg_head.l );
	get_rgb(rgb);
	i = PICK_MAT;
	(void)mk_addmember( crystalname, &reg_head.l, NULL, WMOP_UNION );
	(void)mk_addmember( rppname, &reg_head.l, NULL, WMOP_INTERSECT );
	mk_lcomb( outfp, cname, &reg_head, 1,
		mtab[i].mt_name, mtab[i].mt_param, rgb, 0 );
	return(height);
}

double
crystal_layer(char *crname, fastf_t *center, double radius, fastf_t *maj, fastf_t *min, double var, double ratio, int nsolids)
    	        
       	       		/* center coordinates, (min Z) */
      	       		/* cell radius */
      	    		/* main axis of growth */
      	    		/* minor axis of growth */
      	    		/* max degrees of variation off axis (0..90) */
      	      		/* len/width ratio */
   	        	/* number of solids for this layer */
{
	int	todo;
	double	height = center[Z];
	int	index = 0;
	point_t	loc_cent;
	point_t	a,b;
	fastf_t	*maj_axis, *min_axis;
	vect_t	long_axis, short_axis;
	vect_t	other_axis;
	double	cos_var;
	double	m_cos_var;
	double	length, width;
	point_t	pt[8];
	char	name[32];
	int	i;
	struct wmember head;

	BU_LIST_INIT( &head.l );

	for( todo = nsolids-1; todo >= 0; todo-- )  {
		cos_var = cos( var*rand_num(rbuf) );
		m_cos_var = 1 - cos_var;
		/* Blend together two original axes for new orthog. set */
		if( rand() & 1 )  {
			maj_axis = maj;
			min_axis = min;
		}  else  {
			maj_axis = min;
			min_axis = maj;
		}
		VSETALL( long_axis, 0 );
		VSETALL( short_axis, 0 );
		VJOIN2( long_axis, long_axis,
			cos_var, maj_axis,
			m_cos_var, min_axis );
		VJOIN2( short_axis, short_axis,
			m_cos_var, maj_axis,
			cos_var, min_axis );
		VCROSS( other_axis, long_axis, short_axis );

		/* dither center position */
		VMOVE(loc_cent, center );
		loc_cent[X] += rand_num(rbuf) * radius;
		loc_cent[Y] += rand_num(rbuf) * radius;

		length = radius * rand_num(rbuf);
		width = length / ratio;

		VJOIN1( a, loc_cent, length, long_axis );
		VJOIN2( pt[0], a, -width, short_axis, -width, other_axis );
		VJOIN2( pt[1], a,  width, short_axis, -width, other_axis );
		VJOIN2( pt[2], a,  width, short_axis,  width, other_axis );
		VJOIN2( pt[3], a, -width, short_axis,  width, other_axis );

		VJOIN1( b, loc_cent, -length, long_axis );
		VJOIN2( pt[4], b, -width, short_axis, -width, other_axis );
		VJOIN2( pt[5], b,  width, short_axis, -width, other_axis );
		VJOIN2( pt[6], b,  width, short_axis,  width, other_axis );
		VJOIN2( pt[7], b, -width, short_axis,  width, other_axis );

		/* Consider fusing points here, for visual complexity */

		sprintf( name, "%s%d", crname, index++ );
		mk_arb8( outfp, name, &pt[0][X] );
		(void)mk_addmember( name, &head.l, NULL, WMOP_UNION );

		for( i=0; i<8; i++ )  {
			if( pt[i][Z] > height )
				height = pt[i][Z];
		}
	}

	mk_lfcomb( outfp, crname, &head, 0 );
	return(height);
}

void
do_plate(char *name, double xc, double yc, double size)
    	      
      	       		/* center coordinates, z=0+ */
      	     
{
	double	esz;
	vect_t	minpt, maxpt;
	char	sname[64];
	unsigned char	rgb[4];		/* needs all 4 */
	int	i;

	sprintf(sname, "%s.s", name);
	/* Make the base */
	esz = size*0.5*0.9;	/* dist from ctr to edge of base */
	VSET( minpt, xc-esz, yc-esz, -9 );
	VSET( maxpt, xc+esz, yc+esz, -1 );
	mk_rpp( outfp, sname, minpt, maxpt );

	/* Needs to be in a region, with color!  */
	get_rgb(rgb);
	i = PICK_MAT;
	mk_region1( outfp, name, sname, 
		mtab[i].mt_name, mtab[i].mt_param, rgb );
}

double
ball_stack(char *bname, double xc, double yc, double size)
    	       
      	       		/* center coordinates, z=0+ */
      	     
{
	point_t	center;
	double	esz;
	unsigned char	rgb[4];		/* needs all 4 */
	int	i;
	int	n;
	char	name[32];
	struct wmember head;

	BU_LIST_INIT( &head.l );

	/* Make some objects */
	esz = size*0.5*0.9;	/* dist from ctr to edge of base */
	n = rand()&7;
	for( i=0; i<n; i++ )  {
		sprintf( name, "%s%c", bname, 'A'+i );
		VSET( center, xc, yc, size/2+i*size );
		mk_sph( outfp, name, center, esz/2 );
		(void)mk_addmember( name, &head.l, NULL, WMOP_UNION );
	}

	/* Build the combination */
	get_rgb(rgb);
	mk_lcomb( outfp, bname, &head, 0, (char *)0, "", rgb, 0 );

	return( n*size );
}

double
prim_stack(char *pname, double xc, double yc, double size)
    	       
      	       		/* center coordinates, z=0+ */
      	     
{
	point_t	pt[8];
	vect_t	min, max;
	vect_t	base, hvec;
	point_t	center;
	unsigned char	rgb[4];		/* needs all 4 */
	int	nobj;
	int	i;
	int	n;
	double	vpos = 0.0;
	double	height;
	double	xbase, ybase;
	char	name[32];
	struct wmember head;

	BU_LIST_INIT( &head.l );

	size *= 0.3;		/* Don't occupy full cell */
	xbase = xc - size/2;
	ybase = yc - size/2;

	/* Make some objects */
	n = (rand()&7)+1;
	for( nobj=0; nobj<n; nobj++ )  {
		sprintf( name, "%s%c", pname, 'A'+nobj );
		(void)mk_addmember( name, &head.l, NULL, WMOP_UNION );
		height = ((rand()&7)+1)*size/3;
		i = rand()%5;
		switch(i)  {
		default:
			VSET( center, xc, yc, vpos+size/2 );
			mk_sph( outfp, name, center, size/2 );
			vpos += size;
			break;
		case 0:
			VSET( min, xc-size/2, yc-size/2, vpos );
			VSET( max, xc+size/2, yc+size/2, vpos+height );
			mk_rpp( outfp, name, min, max );
			vpos += height;
			break;
		case 1:
			VSET( base, xc, yc, vpos );
			VSET( hvec, 0, 0, height );
			mk_rcc( outfp, name, base, hvec, size/2 );
			vpos += height;
			break;
		case 2:
			VSET( pt[0], xbase, ybase, vpos);
			VSET( pt[1], xbase+size, ybase, vpos);
			VSET( pt[2], xbase+size/2, ybase+size, vpos);
			VSET( pt[3], xbase+size/2, ybase+size*sin60/3, vpos+height );
			mk_arb4( outfp, name, &pt[0][X] );
			vpos += height;
			break;
		case 3:
			VSET( center, xc, yc, vpos+height/2 );
			VSET( pt[0], size/2, 0, 0 );
			VSET( pt[1], 0, size/2, 0 );
			VSET( pt[2], 0, 0, height/2 );
			mk_ell( outfp, name, center,
				pt[0], pt[1], pt[2] );
			vpos += height;
			break;
		}
	}

	/* Build the combination */
	get_rgb( rgb );
	i = PICK_MAT;
	mk_lcomb( outfp, pname, &head, 0,
		mtab[i].mt_name, mtab[i].mt_param,
		rgb, 0 );
	return(vpos);
}

void
do_rings(char *ringname, fastf_t *center, double r1, double r2, double incr, int n)
{
	int	i;
	vect_t	normal;
	unsigned char	rgb[4];
	char	rname[32];
	char	sname[32];
	struct wmember head;

	BU_LIST_INIT( &head.l );

	VSET( normal, 0, 0, 1 );
	for( i=0; i<n; i++ )  {
		sprintf( sname, "%s%ds", ringname, i );
		sprintf( rname, "%s%dr", ringname, i );

		mk_tor( outfp, sname, center, normal, r1, r2 );
		r1 += incr;

		/* Build the region that contains each solid */
		get_rgb(rgb);
		mk_region1( outfp, rname, sname, NULL, NULL, rgb );
		(void)mk_addmember( rname, &head.l, NULL, WMOP_UNION );
	}

	/* Build the group that holds all the regions */
	mk_lfcomb( outfp, ringname, &head, 0 );
}
@


11.18
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/proc-db/clutter.c,v 11.17 2004/04/05 05:45:58 morrison Exp $ (BRL)";
@


11.17
log
@merge of ansi-6-0-branch into head
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.16
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.15 2002/08/20 17:08:33 jra Exp $ (BRL)";
d55 7
a61 2
double	ball_stack(), prim_stack(), crystal_stack(), crystal_layer();
void	do_plate(), do_rings();
d64 1
a64 2
void	do_light(char *name, point_t pos, vect_t dir_at, int da_flag,
		double r, unsigned char *rgb, struct wmember *headp);
d71 1
a71 2
main(argc, argv)
char	**argv;
d172 4
a175 4
crystal_stack( cname, xc, yc, size )
char	*cname;
double	xc, yc;		/* center coordinates, z=0+ */
double	size;
d237 9
a245 9
crystal_layer( crname, center, radius, maj, min, var, ratio, nsolids )
char	*crname;
point_t	center;		/* center coordinates, (min Z) */
double	radius;		/* cell radius */
vect_t	maj;		/* main axis of growth */
vect_t	min;		/* minor axis of growth */
double	var;		/* max degrees of variation off axis (0..90) */
double	ratio;		/* len/width ratio */
int	nsolids;	/* number of solids for this layer */
d323 4
a326 4
do_plate( name, xc, yc, size )
char	*name;
double	xc, yc;		/* center coordinates, z=0+ */
double	size;
d349 4
a352 4
ball_stack( bname, xc, yc, size )
char	*bname;
double	xc, yc;		/* center coordinates, z=0+ */
double	size;
d382 4
a385 4
prim_stack( pname, xc, yc, size )
char	*pname;
double	xc, yc;		/* center coordinates, z=0+ */
double	size;
d462 1
a462 7
do_rings( ringname, center, r1, r2, incr, n )
char	*ringname;
point_t	center;
double	r1;
double	r2;
double	incr;
int	n;
@


11.15
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.13 2002/05/17 12:42:24 morrison Exp $ (BRL)";
@


11.15.4.1
log
@merge in updates from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/proc-db/clutter.c,v 11.16 2004/02/02 17:39:37 morrison Exp $ (BRL)";
@


11.15.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.16 2004/02/02 17:39:37 morrison Exp $ (BRL)";
@


11.15.10.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.15.10.1 2004/02/12 19:50:50 erikg Exp $ (BRL)";
@


11.15.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.15 2002/08/20 17:08:33 jra Exp $ (BRL)";
d55 2
a56 2
double	ball_stack(char *bname, double xc, double yc, double size), prim_stack(char *pname, double xc, double yc, double size), crystal_stack(char *cname, double xc, double yc, double size), crystal_layer(char *crname, fastf_t *center, double radius, fastf_t *maj, fastf_t *min, double var, double ratio, int nsolids);
void	do_plate(char *name, double xc, double yc, double size), do_rings(char *ringname, fastf_t *center, double r1, double r2, double incr, int n);
d67 2
a68 1
main(int argc, char **argv)
d169 4
a172 4
crystal_stack(char *cname, double xc, double yc, double size)
    	       
      	       		/* center coordinates, z=0+ */
      	     
d234 9
a242 9
crystal_layer(char *crname, fastf_t *center, double radius, fastf_t *maj, fastf_t *min, double var, double ratio, int nsolids)
    	        
       	       		/* center coordinates, (min Z) */
      	       		/* cell radius */
      	    		/* main axis of growth */
      	    		/* minor axis of growth */
      	    		/* max degrees of variation off axis (0..90) */
      	      		/* len/width ratio */
   	        	/* number of solids for this layer */
d320 4
a323 4
do_plate(char *name, double xc, double yc, double size)
    	      
      	       		/* center coordinates, z=0+ */
      	     
d346 4
a349 4
ball_stack(char *bname, double xc, double yc, double size)
    	       
      	       		/* center coordinates, z=0+ */
      	     
d379 4
a382 4
prim_stack(char *pname, double xc, double yc, double size)
    	       
      	       		/* center coordinates, z=0+ */
      	     
d459 7
a465 1
do_rings(char *ringname, fastf_t *center, double r1, double r2, double incr, int n)
@


11.15.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.14
log
@Converted from K&R to ANSI C - RFH
@
text
@d55 2
a56 2
double	ball_stack(char *bname, double xc, double yc, double size), prim_stack(char *pname, double xc, double yc, double size), crystal_stack(char *cname, double xc, double yc, double size), crystal_layer(char *crname, fastf_t *center, double radius, fastf_t *maj, fastf_t *min, double var, double ratio, int nsolids);
void	do_plate(char *name, double xc, double yc, double size), do_rings(char *ringname, fastf_t *center, double r1, double r2, double incr, int n);
d67 2
a68 1
main(int argc, char **argv)
d169 4
a172 4
crystal_stack(char *cname, double xc, double yc, double size)
    	       
      	       		/* center coordinates, z=0+ */
      	     
d234 9
a242 9
crystal_layer(char *crname, fastf_t *center, double radius, fastf_t *maj, fastf_t *min, double var, double ratio, int nsolids)
    	        
       	       		/* center coordinates, (min Z) */
      	       		/* cell radius */
      	    		/* main axis of growth */
      	    		/* minor axis of growth */
      	    		/* max degrees of variation off axis (0..90) */
      	      		/* len/width ratio */
   	        	/* number of solids for this layer */
d320 4
a323 4
do_plate(char *name, double xc, double yc, double size)
    	      
      	       		/* center coordinates, z=0+ */
      	     
d346 4
a349 4
ball_stack(char *bname, double xc, double yc, double size)
    	       
      	       		/* center coordinates, z=0+ */
      	     
d379 4
a382 4
prim_stack(char *pname, double xc, double yc, double size)
    	       
      	       		/* center coordinates, z=0+ */
      	     
d459 7
a465 1
do_rings(char *ringname, fastf_t *center, double r1, double r2, double incr, int n)
@


11.13
log
@added matrix parameter to mk_addmember()
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.12 2001/03/31 01:57:27 morrison Exp $ (BRL)";
d55 2
a56 2
double	ball_stack(), prim_stack(), crystal_stack(), crystal_layer();
void	do_plate(), do_rings();
d67 1
a67 2
main(argc, argv)
char	**argv;
d168 4
a171 4
crystal_stack( cname, xc, yc, size )
char	*cname;
double	xc, yc;		/* center coordinates, z=0+ */
double	size;
d233 9
a241 9
crystal_layer( crname, center, radius, maj, min, var, ratio, nsolids )
char	*crname;
point_t	center;		/* center coordinates, (min Z) */
double	radius;		/* cell radius */
vect_t	maj;		/* main axis of growth */
vect_t	min;		/* minor axis of growth */
double	var;		/* max degrees of variation off axis (0..90) */
double	ratio;		/* len/width ratio */
int	nsolids;	/* number of solids for this layer */
d319 4
a322 4
do_plate( name, xc, yc, size )
char	*name;
double	xc, yc;		/* center coordinates, z=0+ */
double	size;
d345 4
a348 4
ball_stack( bname, xc, yc, size )
char	*bname;
double	xc, yc;		/* center coordinates, z=0+ */
double	size;
d378 4
a381 4
prim_stack( pname, xc, yc, size )
char	*pname;
double	xc, yc;		/* center coordinates, z=0+ */
double	size;
d458 1
a458 7
do_rings( ringname, center, r1, r2, incr, n )
char	*ringname;
point_t	center;
double	r1;
double	r2;
double	incr;
int	n;
@


11.12
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.11 2000/08/24 04:37:03 mike Exp $ (BRL)";
d108 1
a108 1
	(void)mk_addmember( "plane.r", &head.l, WMOP_UNION );
d121 1
a121 1
			(void)mk_addmember( name, &head.l, WMOP_UNION );
d124 1
a124 1
			(void)mk_addmember( name, &head.l, WMOP_UNION );
d145 1
a145 1
	(void)mk_addmember( "rings", &head.l, WMOP_UNION );
d199 1
a199 1
		(void)mk_addmember( name, &head.l, WMOP_UNION );
d226 2
a227 2
	(void)mk_addmember( crystalname, &reg_head.l, WMOP_UNION );
	(void)mk_addmember( rppname, &reg_head.l, WMOP_INTERSECT );
d307 1
a307 1
		(void)mk_addmember( name, &head.l, WMOP_UNION );
d368 1
a368 1
		(void)mk_addmember( name, &head.l, WMOP_UNION );
d408 1
a408 1
		(void)mk_addmember( name, &head.l, WMOP_UNION );
d487 1
a487 1
		(void)mk_addmember( rname, &head.l, WMOP_UNION );
@


11.11
log
@
mk_addmember
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.10 2000/07/12 21:59:07 mike Exp $ (BRL)";
d104 1
a104 1
	bn_mat_idn( identity );
@


11.10
log
@
Converted to use new version of LIBWDB.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.9 2000/07/12 03:16:33 mike Exp $ (BRL)";
d108 1
a108 1
	(void)mk_addmember( "plane.r", &head, WMOP_UNION );
d121 1
a121 1
			(void)mk_addmember( name, &head, WMOP_UNION );
d124 1
a124 1
			(void)mk_addmember( name, &head, WMOP_UNION );
d145 1
a145 1
	(void)mk_addmember( "rings", &head, WMOP_UNION );
d199 1
a199 1
		(void)mk_addmember( name, &head, WMOP_UNION );
d226 2
a227 2
	(void)mk_addmember( crystalname, &reg_head, WMOP_UNION );
	(void)mk_addmember( rppname, &reg_head, WMOP_INTERSECT );
d307 1
a307 1
		(void)mk_addmember( name, &head, WMOP_UNION );
d368 1
a368 1
		(void)mk_addmember( name, &head, WMOP_UNION );
d408 1
a408 1
		(void)mk_addmember( name, &head, WMOP_UNION );
d487 1
a487 1
		(void)mk_addmember( rname, &head, WMOP_UNION );
@


11.9
log
@
Modified to use mk_region1() instead of old routines
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.8 2000/07/10 23:46:49 mike Exp $ (BRL)";
d64 2
d95 2
a96 1
	mk_id( stdout, "Procedural Clutter" );
d100 1
a100 1
	mk_half( stdout, "plane", norm, -10.0 );
d106 1
a106 1
	mk_region1( stdout, "plane.r", "plane", NULL, NULL, rgb );
d163 1
a163 1
	mk_lfcomb( stdout, "clut", &head, 0 );
d213 1
a213 1
	mk_lfcomb( stdout, crystalname, &head, 0 );
d220 1
a220 1
	mk_rpp( stdout, rppname, minpt, maxpt );
d228 1
a228 1
	mk_lcomb( stdout, cname, &reg_head, 1,
d306 1
a306 1
		mk_arb8( stdout, name, &pt[0][X] );
d315 1
a315 1
	mk_lfcomb( stdout, crname, &head, 0 );
d336 1
a336 1
	mk_rpp( stdout, sname, minpt, maxpt );
d341 1
a341 1
	mk_region1( stdout, name, sname, 
d367 1
a367 1
		mk_sph( stdout, name, center, esz/2 );
d373 1
a373 1
	mk_lcomb( stdout, bname, &head, 0, (char *)0, "", rgb, 0 );
d414 1
a414 1
			mk_sph( stdout, name, center, size/2 );
d420 1
a420 1
			mk_rpp( stdout, name, min, max );
d426 1
a426 1
			mk_rcc( stdout, name, base, hvec, size/2 );
d434 1
a434 1
			mk_arb4( stdout, name, &pt[0][X] );
d442 1
a442 1
			mk_ell( stdout, name, center,
d452 1
a452 1
	mk_lcomb( stdout, pname, &head, 0,
d481 1
a481 1
		mk_tor( stdout, sname, center, normal, r1, r2 );
d486 1
a486 1
		mk_region1( stdout, rname, sname, NULL, NULL, rgb );
d491 1
a491 1
	mk_lfcomb( stdout, ringname, &head, 0 );
@


11.8
log
@
lint
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.7 2000/07/10 23:42:20 mike Exp $ (BRL)";
d102 3
a104 2
	mk_comb( stdout, "plane.r", 1, 1, "", "", rgb, 0 );
	mk_memb( stdout, "plane", identity, WMOP_UNION );
d184 1
d220 1
d223 4
a226 3
	mk_comb( stdout, cname, 2, 1, mtab[i].mt_name, mtab[i].mt_param, rgb, 0 );
	mk_memb( stdout, crystalname, identity, WMOP_UNION );
	mk_memb( stdout, rppname, identity, WMOP_INTERSECT );
d338 2
a339 2
	mk_comb( stdout, name, 1, 1, mtab[i].mt_name, mtab[i].mt_param, rgb, 0 );
	mk_memb( stdout, sname, identity, WMOP_UNION );
d483 1
a483 2
		mk_comb( stdout, rname, 1, 1, "", "", rgb, 0 );
		mk_memb( stdout, sname, identity, WMOP_UNION );
@


11.7
log
@
lint
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.6 2000/07/10 23:38:20 mike Exp $ (BRL)";
d77 1
a77 1
	char	white[3];
@


11.6
log
@
const RCSid
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.5 2000/07/10 23:35:38 mike Exp $ (BRL)";
d42 8
a49 7
	"plastic",	"",
	"glass",	"",
	"plastic",	"",
	"mirror",	"",
	"plastic",	"",
	"testmap",	"",
	"plastic",	""
d58 4
d64 1
d160 2
@


11.5
log
@
raytrace.h before wdb.h
Eliminated use of db.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.4 1999/10/30 03:06:26 butler Exp $ (BRL)";
@


11.4
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/clutter.c,v 11.3 1997/01/08 04:48:02 mike Exp $ (BRL)";
a27 1
#include "db.h"
d31 1
d97 1
a97 1
	mk_memb( stdout, "plane", identity, UNION );
d213 2
a214 2
	mk_memb( stdout, crystalname, identity, UNION );
	mk_memb( stdout, rppname, identity, INTERSECT );
d327 1
a327 1
	mk_memb( stdout, sname, identity, UNION );
d472 1
a472 1
		mk_memb( stdout, sname, identity, UNION );
@


11.3
log
@sed4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/clutter.c,v 11.2 1997/01/08 04:47:26 mike Exp mike $ (BRL)";
d79 3
a81 1
#define rand0to1(p)	(BN_UNIF_DOUBLE(p)+0.5)
d143 1
a143 1
	VSET( pos, base, base, minheight+maxheight*rand0to1(rbuf) );
d145 1
a145 1
	VSET( pos, -base, base, minheight+maxheight*rand0to1(rbuf) );
d147 1
a147 1
	VSET( pos, -base, -base, minheight+maxheight*rand0to1(rbuf) );
d149 1
a149 1
	VSET( pos, base, -base, minheight+maxheight*rand0to1(rbuf) );
d192 2
a193 2
			rand0to1(rbuf) * 90.0,
			rand0to1(rbuf) * 8.0 + 2.0,
d248 1
a248 1
		cos_var = cos( var*rand0to1(rbuf) );
d270 2
a271 2
		loc_cent[X] += BN_UNIF_DOUBLE(rbuf) * radius;
		loc_cent[Y] += BN_UNIF_DOUBLE(rbuf) * radius;
d273 1
a273 1
		length = radius * rand0to1(rbuf);
@


11.2
log
@Changed over to using LIBBN msr.c
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/clutter.c,v 11.1 1995/01/04 10:06:11 mike Rel4_4 mike $ (BRL)";
d81 1
a81 1
	RT_LIST_INIT( &head.l );
d93 1
a93 1
	mat_idn( identity );
d174 1
a174 1
	RT_LIST_INIT( &head.l );
d243 1
a243 1
	RT_LIST_INIT( &head.l );
d342 1
a342 1
	RT_LIST_INIT( &head.l );
d381 1
a381 1
	RT_LIST_INIT( &head.l );
d457 1
a457 1
	RT_LIST_INIT( &head.l );
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/clutter.c,v 10.5 94/11/14 22:12:10 mike Exp $ (BRL)";
d29 1
d31 1
a31 1
#include "rtlist.h"
a33 2
#include "../rt/mathtab.h"

d57 2
a74 1
	float	*randp = (float *)0;
d76 5
d141 1
a141 1
	VSET( pos, base, base, minheight+maxheight*rand0to1(randp) );
d143 1
a143 1
	VSET( pos, -base, base, minheight+maxheight*rand0to1(randp) );
d145 1
a145 1
	VSET( pos, -base, -base, minheight+maxheight*rand0to1(randp) );
d147 1
a147 1
	VSET( pos, base, -base, minheight+maxheight*rand0to1(randp) );
a172 1
	float	*randp = (float *)0;
d190 2
a191 2
			rand0to1(randp) * 90.0,
			rand0to1(randp) * 8.0 + 2.0,
a241 1
	float	*randp = (float *)0;
d246 1
a246 1
		cos_var = cos( var*rand0to1(randp) );
d268 2
a269 2
		loc_cent[X] += rand_half(randp) * radius;
		loc_cent[Y] += rand_half(randp) * radius;
d271 1
a271 1
		length = radius * rand0to1(randp);
@


10.5
log
@Irix 6
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/clutter.c,v 10.4 94/10/21 20:05:46 mike Exp Locker: mike $ (BRL)";
@


10.4
log
@rgb is unsigned char now.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/clutter.c,v 10.3 94/10/20 00:09:10 mike Exp Locker: mike $ (BRL)";
a330 1
	vect_t	min, max;
@


10.3
log
@mk_arb[48]() prototype change
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/clutter.c,v 10.2 94/08/09 19:10:21 gdurf Exp Locker: mike $ (BRL)";
d62 1
a62 1
	char	rgb[3];
d159 1
a159 1
	char	rgb[4];		/* needs all 4 */
d308 1
a308 1
	char	rgb[4];		/* needs all 4 */
d334 1
a334 1
	char	rgb[4];		/* needs all 4 */
d369 1
a369 1
	char	rgb[4];		/* needs all 4 */
d450 1
a450 1
	char	rgb[4];
@


10.2
log
@Added include
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/clutter.c,v 10.1 1991/10/12 06:44:35 mike Rel4_0 gdurf $ (BRL)";
d286 1
a286 1
		mk_arb8( stdout, name, (CONST point_t *)pt );
d415 1
a415 1
			mk_arb4( stdout, name, (CONST point_t *)pt );
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/clutter.c,v 9.5 91/07/02 03:09:35 mike Exp $ (BRL)";
d22 2
@


9.5
log
@ANSI lint
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/clutter.c,v 9.4 90/12/08 06:10:04 mike Exp $ (BRL)";
@


9.4
log
@lint
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/clutter.c,v 9.3 90/11/01 05:14:47 mike Exp $ (BRL)";
d284 1
a284 1
		mk_arb8( stdout, name, pt );
d413 1
a413 1
			mk_arb4( stdout, name, pt );
@


9.3
log
@Changed calling sequence to mk_addmember().  Added boolean op as 3rd arg.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/clutter.c,v 9.2 90/10/16 11:18:17 mike Exp $ (BRL)";
d72 1
a72 1
	float	*randp;
d166 1
a166 1
	float	*randp;
d236 1
a236 1
	float	*randp;
d352 1
a352 1
	mk_lcomb( stdout, bname, &head, (char *)0, "", rgb, 0 );
d431 1
a431 1
	mk_lcomb( stdout, pname, &head,
d440 1
@


9.2
log
@Changed to using rtlist.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/clutter.c,v 9.1 89/05/19 06:04:40 mike Rel3_5 $ (BRL)";
d89 1
a89 1
	(void)mk_addmember( "plane.r", &head );
d102 1
a102 1
			(void)mk_addmember( name, &head );
d105 1
a105 1
			(void)mk_addmember( name, &head );
d126 1
a126 1
	(void)mk_addmember( "rings", &head );
d178 1
a178 1
		(void)mk_addmember( name, &head );
d285 1
a285 1
		(void)mk_addmember( name, &head );
d347 1
a347 1
		(void)mk_addmember( name, &head );
d387 1
a387 1
		(void)mk_addmember( name, &head );
d466 1
a466 1
		(void)mk_addmember( rname, &head );
@


9.1
log
@Release_3.5
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: clutter.c,v 8.2 89/04/30 21:38:13 mike Exp $ (BRL)";
d28 1
d74 1
a74 1
	head.wm_forw = head.wm_back = &head;
d168 1
a168 1
	head.wm_forw = head.wm_back = &head;
d238 1
a238 1
	head.wm_forw = head.wm_back = &head;
d338 1
a338 1
	head.wm_forw = head.wm_back = &head;
d377 1
a377 1
	head.wm_forw = head.wm_back = &head;
d452 1
a452 1
	head.wm_forw = head.wm_back = &head;
@


8.2
log
@New rand() needs table pointer arg.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: clutter.c,v 8.1 88/10/05 00:38:13 mike Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: clutter.c,v 7.5 88/08/20 07:26:20 phil Exp $ (BRL)";
d71 1
d133 1
a133 1
	VSET( pos, base, base, minheight+maxheight*rand0to1() );
d135 1
a135 1
	VSET( pos, -base, base, minheight+maxheight*rand0to1() );
d137 1
a137 1
	VSET( pos, -base, -base, minheight+maxheight*rand0to1() );
d139 1
a139 1
	VSET( pos, base, -base, minheight+maxheight*rand0to1() );
d165 1
d183 2
a184 2
			rand0to1() * 90.0,
			rand0to1() * 8.0 + 2.0,
d235 1
d240 1
a240 1
		cos_var = cos( var*rand0to1() );
d262 2
a263 2
		loc_cent[X] += rand_half() * radius;
		loc_cent[Y] += rand_half() * radius;
d265 1
a265 1
		length = radius * rand0to1();
@


7.5
log
@libwdb changes
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: clutter.c,v 7.4 88/05/15 23:00:08 phil Locked $ (BRL)";
@


7.4
log
@lint fixes
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: clutter.c,v 7.3 87/12/24 06:55:46 mike Locked $ (BRL)";
d80 1
a80 1
	mk_half( stdout, "plane", -10.0, norm );
d85 1
a85 1
	mk_mcomb( stdout, "plane.r", 1, 1, "", "", 1, rgb );
d142 1
a142 1
	mk_lfcomb( stdout, "clut", 0, &head );
d189 1
a189 1
	mk_lfcomb( stdout, crystalname, 0, &head );
d201 1
a201 1
	mk_mcomb( stdout, cname, 2, 1, mtab[i].mt_name, mtab[i].mt_param, 1, rgb );
d289 1
a289 1
	mk_lfcomb( stdout, crname, 0, &head );
d315 1
a315 1
	mk_mcomb( stdout, name, 1, 1, mtab[i].mt_name, mtab[i].mt_param, 1, rgb );
d348 1
a348 1
	mk_lcomb( stdout, bname, 1, (char *)0, "", 1, rgb, &head );
d427 1
a427 1
	mk_lcomb( stdout, pname, 1,
d429 1
a429 1
		1, rgb, &head );
d460 1
a460 1
		mk_mcomb( stdout, rname, 1, 1, "", "", 1, rgb );
d466 1
a466 1
	mk_lfcomb( stdout, ringname, 0, &head );
@


7.3
log
@Split out common.c from clutter and room
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: clutter.c,v 1.7 87/10/30 15:34:11 mike Exp $ (BRL)";
d53 1
d293 1
d433 1
@


7.2
log
@Converted to using mk_addmember and mk_lcomb
@
text
@a430 39
struct colors {
	char		*name;
	unsigned char	c_pixel[3];
}colortab[] = {
	"black",	20,20,20,
	"blue",		0,0,255,
	"brown",	200,130,0,
	"cyan",		0,255,200,
	"flesh",	255,200,160,
	"gray",		120,120,120,
	"green",	0,255,0,
	"lime", 	200,255,0,
	"magenta",	255,0,255,
	"olive",	220,190,0,
	"orange",	255,100,0,
	"pink",		255,200,200,
	"red",		255,0,0,
	"rose",		255,0,175,
	"rust",		200,100,0,
	"silver",	237,237,237,
	"sky",		0,255,255,
	"violet",	200,0,255,
	"white",	255,255,255,
	"yellow",	255,200,0
};
int	ncolors = sizeof(colortab)/sizeof(struct colors);
int	curcolor = 0;

get_rgb( rgb )
register char	*rgb;
{
	register struct colors *cp;
	if( ++curcolor >= ncolors )  curcolor = 0;
	cp = &colortab[curcolor];
	rgb[0] = cp->c_pixel[0];
	rgb[1] = cp->c_pixel[1];
	rgb[2] = cp->c_pixel[2];
}

a464 47

do_light( name, pos, dir_at, da_flag, r, rgb, headp )
char	*name;
point_t	pos;
vect_t	dir_at;		/* direction or aim point */
int	da_flag;	/* 0 = direction, !0 = aim point */
double	r;		/* radius of light */
char	*rgb;
struct wmember	*headp;
{
	char	nbuf[64];
	vect_t	center;
	mat_t	rot;
	mat_t	xlate;
	mat_t	both;
	vect_t	begin;
	vect_t	trial;
	vect_t	from;
	vect_t	dir;

	if( da_flag )  {
		VSUB2( dir, dir_at, pos );
		VUNITIZE( dir );
	} else {
		VMOVE( dir, dir_at );
	}

	sprintf( nbuf, "%s.s", name );
	VSETALL( center, 0 );
	mk_sph( stdout, nbuf, center, r );

	/*
	 * Need to rotate from 0,0,-1 to vect "dir",
	 * then xlate to final position.
	 */
	VSET( from, 0, 0, -1 );
	mat_fromto( rot, from, dir );
	mat_idn( xlate );
	MAT_DELTAS( xlate, pos[X], pos[Y], pos[Z] );
	mat_mul( both, xlate, rot );

	mk_mcomb( stdout, name, 1, 1, "light", "shadows=1", 1, rgb );
	mk_memb( stdout, nbuf, both, UNION );
	(void)mk_addmember( name, headp );
}

rt_log(str) {fprintf(stderr,"rt_log: %s\n", str);}
@


7.1
log
@Release 2.3
@
text
@d28 1
a35 4
struct ntab {
	char	nm[64];
} ntab[64];

d69 1
d71 2
d86 1
d99 2
d102 1
d123 1
d132 1
a132 1
	do_light( "l1", pos, aim, 1, 100.0, white );
d134 1
a134 1
	do_light( "l2", pos, aim, 1, 100.0, white );
d136 1
a136 1
	do_light( "l3", pos, aim, 1, 100.0, white );
d138 1
a138 1
	do_light( "l4", pos, aim, 1, 100.0, white );
d141 1
a141 15
	mk_comb( stdout, "clut", 2*quant*quant+1+4+1, 0 );
	mk_memb( stdout, "plane.r", identity, UNION );
	for( ix=quant-1; ix>=0; ix-- )  {
		for( iy=quant-1; iy>=0; iy-- )  {
			sprintf( name, "Bx%dy%d", ix, iy );
			mk_memb( stdout, name, identity, UNION );
			sprintf( name, "x%dy%d", ix, iy );
			mk_memb( stdout, name, identity, UNION );
		}
	}
	mk_memb( stdout, "l1", identity, UNION );
	mk_memb( stdout, "l2", identity, UNION );
	mk_memb( stdout, "l3", identity, UNION );
	mk_memb( stdout, "l4", identity, UNION );
	mk_memb( stdout, "rings", identity, UNION );
d145 2
a146 2
crystal_stack( name, xc, yc, size )
char	*name;
a153 2
	struct ntab	names[32];
	int	len = 0;
d158 1
d162 1
d164 2
d173 2
a174 1
		sprintf( names[len].nm, "%sl%c", name, 'a'+i);
d178 1
a178 1
		high = crystal_layer( names[len++].nm, center, size/2,
d186 4
d194 1
a194 1
	sprintf( rppname, "%srpp", name );
d197 1
a197 8
	/* Build the crystal union */
	sprintf( crystalname, "%scrystal", name );
	mk_comb( stdout, crystalname, len, 0 );
	for( i=0; i<len; i++ )  {
		mk_memb( stdout, names[i].nm, identity, UNION );
	}

	/* Build the combination */
d200 1
a200 1
	mk_mcomb( stdout, name, 2, 1, mtab[i].mt_name, mtab[i].mt_param, 1, rgb );
d207 2
a208 2
crystal_layer( name, center, radius, maj, min, var, ratio, nsolids )
char	*name;
a217 1
	struct ntab	*crname;
d219 1
a219 1
	int	len = 0;
d229 1
d231 1
d233 1
a233 1
	crname = (struct ntab *)malloc( sizeof(struct ntab)*nsolids );
d278 3
a280 2
		sprintf( ntab[len].nm, "%s%d", name, len );
		mk_arb8( stdout, ntab[len++].nm, pt );
d288 1
a288 4
	mk_comb( stdout, name, len, 0 );
	for( todo = nsolids-1; todo >= 0; todo-- )  {
		mk_memb( stdout, ntab[todo].nm, identity, UNION );
	}
d318 2
a319 2
ball_stack( name, xc, yc, size )
char	*name;
a326 1
	int	len;
d329 2
d332 1
a332 1
	len = 0;
d338 1
a338 1
		sprintf( ntab[len].nm, "%s%c", name, 'A'+len );
d340 2
a341 1
		mk_sph( stdout, ntab[len++].nm, center, esz/2 );
d346 3
a348 5
	mk_mcomb( stdout, name, len, 1, "", "", 1, rgb );
	for( i=0; i<len; i++ )  {
		mk_memb( stdout, ntab[i].nm, identity, UNION );
	}
	return( i*size );
d352 2
a353 2
prim_stack( name, xc, yc, size )
char	*name;
a357 1
	int	len;
d368 2
d371 1
a371 1
	len = 0;
d380 2
a381 1
		sprintf( ntab[len].nm, "%s%c", name, 'A'+len );
d387 1
a387 1
			mk_sph( stdout, ntab[len++].nm, center, size/2 );
d393 1
a393 1
			mk_rpp( stdout, ntab[len++].nm, min, max );
d399 1
a399 1
			mk_rcc( stdout, ntab[len++].nm, base, hvec, size/2 );
d407 1
a407 1
			mk_arb4( stdout, ntab[len++].nm, pt );
d415 1
a415 1
			mk_ell( stdout, ntab[len++].nm, center,
d425 3
a427 4
	mk_mcomb( stdout, name, len, 1, mtab[i].mt_name, mtab[i].mt_param, 1, rgb );
	for( i=0; i<len; i++ )  {
		mk_memb( stdout, ntab[i].nm, identity, UNION );
	}
d470 2
a471 2
do_rings( name, center, r1, r2, incr, n )
char	*name;
a476 1
	struct ntab snames[32];
a477 1
	int	len = 0;	/* combination length, in ntab & snames */
d480 3
d484 2
d488 4
a491 3
		sprintf( snames[len].nm, "%s%ds", name, i );
		sprintf( ntab[len].nm, "%s%dr", name, i );
		mk_tor( stdout, snames[len++].nm, center, normal, r1, r2 );
a492 1
	}
d494 1
a494 2
	/* Build the region that contains each solid */
	for( i=0; i<n; i++ )  {
d496 3
a498 2
		mk_mcomb( stdout, ntab[i].nm, 1, 1, "", "", 1, rgb );
		mk_memb( stdout, snames[i].nm, identity, UNION );
d502 1
a502 3
	mk_comb( stdout, name, n, 0 );
	for( i=0; i<n; i++ )
		mk_memb( stdout, ntab[i].nm, identity, UNION );
d505 1
a505 1
do_light( name, pos, dir_at, da_flag, r, rgb )
d512 1
d547 1
@


1.7
log
@Added rt_log routine.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: clutter.c,v 1.6 87/10/15 02:36:58 mike Exp $ (BRL)";
@


1.6
log
@This version with material properties, independent base plates.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: clutter.c,v 1.4 87/09/26 08:06:08 mike Exp $ (BRL)";
d556 1
a556 60
/* wrapper for atan2.  On SGI (and perhaps others), x==0 returns infinity */
double
xatan2(y,x)
double	y,x;
{
	if( x > -1.0e-20 && x < 1.0e-20 )  {
		/* X is equal to zero, check Y */
		if( y < -1.0e-20 )  return( -3.14159265358979323/2 );
		if( y >  1.0e-20 )  return(  3.14159265358979323/2 );
		return(0.0);
	}
	return( atan2( y, x ) );
}
/*
 *			M A T _ F R O M T O
 *
 *  Given two vectors, compute a rotation matrix that will transform
 *  space by the angle between the two.  Since there are many
 *  candidate matricies, the method used here is to convert the vectors
 *  to azimuth/elevation form (azimuth is +X, elevation is +Z),
 *  take the difference, and form the rotation matrix.
 *  See mat_ae for that algorithm.
 *
 *  The input 'from' and 'to' vectors must be unit length.
 */
mat_fromto( m, from, to )
mat_t	m;
vect_t	from;
vect_t	to;
{
	double	az, el;
	LOCAL double sin_az, sin_el;
	LOCAL double cos_az, cos_el;

	az = xatan2( to[Y], to[X] ) - xatan2( from[Y], from[X] );
	el = asin( to[Z] ) - asin( from[Z] );

	sin_az = sin(az);
	cos_az = cos(az);
	sin_el = sin(el);
	cos_el = cos(el);

	m[0] = cos_el * cos_az;
	m[1] = -sin_az;
	m[2] = -sin_el * cos_az;
	m[3] = 0;

	m[4] = cos_el * sin_az;
	m[5] = cos_az;
	m[6] = -sin_el * sin_az;
	m[7] = 0;

	m[8] = sin_el;
	m[9] = 0;
	m[10] = cos_el;
	m[11] = 0;

	m[12] = m[13] = m[14] = 0;
	m[15] = 1.0;
}
@


1.5
log
@Added beginnings of crystals.
@
text
@d39 16
d89 1
a89 1
	quant = 1;	/* XXXX 5 */
d96 2
a98 2
maxheight = height = crystal_stack( name, x, y, size );
continue;
d104 3
d118 1
a118 1
	do_rings( "rings", pos, 1.414*size, size/4, size, 4 );
d136 1
a136 1
	mk_comb( stdout, "clut", quant*quant+1+4+1, 0 );
d140 2
a168 2
	vect_t	minpt, maxpt;
	char	basename[64];
d171 1
a172 7
	/* Make the base */
	esz = size*0.5*0.9;	/* dist from ctr to edge of base */
	VSET( minpt, xc-esz, yc-esz, 0 );
	VSET( maxpt, xc+esz, yc+esz, 10 );
	sprintf( basename, "%sbase", name );
	mk_rpp( stdout, basename, minpt, maxpt );

d208 2
a209 2
	/* XXX should be mirror or glass */
	mk_mcomb( stdout, name, 3, 1, "", "", 1, rgb );
a211 1
	mk_memb( stdout, basename, identity, UNION );
d302 25
d343 1
a343 1
	/* Make the base */
a344 6
	VSET( min, xc-esz, yc-esz, 0 );
	VSET( max, xc+esz, yc+esz, 10 );
	sprintf( ntab[len].nm, "%s%c", name, 'A'+len );
	mk_rpp( stdout, ntab[len++].nm, min, max );

	/* Make some objects */
d349 1
a349 2
		mk_sph( stdout, ntab[len].nm, center, esz/2 );
		len++;
a378 1
	double	esz;
a381 8
	/* Make the base */
	esz = size*0.5*0.9;	/* dist from ctr to edge of base */
	height = 10;
	VSET( min, xc-esz, yc-esz, 0 );
	VSET( max, xc+esz, yc+esz, height );
	sprintf( ntab[len].nm, "%s%c", name, 'A'+len );
	mk_rpp( stdout, ntab[len++].nm, min, max );

d432 2
a433 1
	mk_mcomb( stdout, name, len, 1, "", "", 1, rgb );
@


1.4
log
@Added prim_stack, and do_rings.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: clutter.c,v 1.3 87/09/25 23:20:23 mike Exp $ (BRL)";
d29 2
d39 1
a39 1
double	ball_stack(), prim_stack();
d55 1
a55 1
	double	height, maxheight = 0;
d73 1
a73 1
	quant = 5;
d75 1
d81 2
d96 7
d107 1
a107 1
	VSET( pos, base, base, maxheight*((rand()&7)+1)/8 );
d109 1
a109 1
	VSET( pos, -base, base, maxheight*((rand()&7)+1)/8 );
d111 1
a111 1
	VSET( pos, -base, -base, maxheight*((rand()&7)+1)/8 );
d113 1
a113 1
	VSET( pos, base, -base, maxheight*((rand()&7)+1)/8 );
a115 3
	VSET( pos, 0, 0, size/2 );
	do_rings( "rings", pos, 1.414*base, size/2, 4 );

d133 158
d457 1
a457 1
do_rings( name, center, r1, r2, n )
d461 1
d475 1
a475 1
		r1 += 4*r2;
@


1.3
log
@Changed for new mk_sph and mk_memb calling sequences.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: clutter.c,v 1.2 87/09/22 02:59:51 mike Exp $ (BRL)";
d31 1
d33 6
d52 2
d55 2
d71 1
a71 1
	quant = 3;
d78 10
a87 1
			do_cell( name, x, y, size );
d95 1
a95 1
	VSET( pos, base, base, size );
d97 1
a97 1
	VSET( pos, -base, base, size );
d99 1
a99 1
	VSET( pos, -base, -base, size );
d101 1
a101 1
	VSET( pos, base, -base, size );
d104 3
d108 1
a108 1
	mk_comb( stdout, "clut", quant*quant+1+4, 0 );
d120 1
d123 2
a124 1
do_cell( name, xc, yc, size )
a131 3
	struct ntab {
		char	nm[64];
	} ntab[9];
d144 1
a144 2
	mk_rpp( stdout, ntab[len].nm, min, max );
	len++;
d156 1
a156 2
	rgb[0] = rgb[1] = rgb[2] = 32;
	rgb[rand()&3] = 200;
d161 1
d164 159
d371 6
a376 1
	if( x > -1.0e-20 && x < 1.0e-20 )  return(0.0);
@


1.2
log
@Now includes light aiming.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: pyramid.c,v 1.2 87/09/16 23:01:32 mike Locked $ (BRL)";
d56 1
a56 1
	mk_memb( stdout, UNION, "plane", identity );
d86 1
a86 1
	mk_memb( stdout, UNION, "plane.r", identity );
d90 1
a90 1
			mk_memb( stdout, UNION, name, identity );
d93 4
a96 4
	mk_memb( stdout, UNION, "l1", identity );
	mk_memb( stdout, UNION, "l2", identity );
	mk_memb( stdout, UNION, "l3", identity );
	mk_memb( stdout, UNION, "l4", identity );
d105 1
d129 2
a130 1
		mk_sph( stdout, ntab[len].nm, xc, yc, size/2+i*size, esz/2 );
d139 1
a139 1
		mk_memb( stdout, UNION, ntab[i].nm, identity );
d152 1
d169 2
a170 1
	mk_sph( stdout, nbuf, 0.0, 0.0, 0.0, r );
d183 1
a183 1
	mk_memb( stdout, UNION, nbuf, both );
@


1.1
log
@Initial revision
@
text
@a66 1
fprintf(stderr,"%d %d at %g %g\n", ix, iy, x, y );
d151 2
a152 1
	vect_t	work;
d155 2
d158 5
a162 4
	if( dir_at )  {
		VSUB2( work, dir_at, pos );
		VUNITIZE( work );
		VMOVE( dir_at, work );
d166 1
a166 1
	mk_sph( stdout, nbuf, pos[X], pos[Y], pos[Z], r );
d168 9
a176 8
	mat_idn( rot );
	/* Here, need to rotate from 0,0,-1 to vect "dir_at" */
	mat_angles( rot, acos(dir_at[X]), acos(dir_at[Y]), acos(dir_at[Z]) );
	VSET( begin, 0, 0, -1 );
	MAT4X3VEC( trial, rot, begin );
	VPRINT( "wanted", dir_at );
	VPRINT( "got   ", trial );
	mat_idn( rot );
d178 2
a179 2
	mk_mcomb( stdout, name, 1, 1, "light", "shadow=1", 1, rgb );
	mk_memb( stdout, UNION, nbuf, rot );
d182 8
d191 1
a191 1
 *			M A T _ A N G L E S
d193 8
a200 2
 * This routine builds a Homogeneous rotation matrix, given
 * alpha, beta, and gamma as angles of rotation, in degrees.
d202 4
a205 3
mat_angles( mat, alpha, beta, ggamma )
register matp_t mat;
double alpha, beta, ggamma;
d207 3
a209 2
	LOCAL double calpha, cbeta, cgamma;
	LOCAL double salpha, sbeta, sgamma;
d211 2
a212 4
	if( alpha == 0.0 && beta == 0.0 && ggamma == 0.0 )  {
		mat_idn( mat );
		return;
	}
d214 4
a217 3
	alpha *= degtorad;
	beta *= degtorad;
	ggamma *= degtorad;
d219 4
a222 3
	calpha = cos( alpha );
	cbeta = cos( beta );
	cgamma = cos( ggamma );
d224 4
a227 3
	salpha = sin( alpha );
	sbeta = sin( beta );
	sgamma = sin( ggamma );
d229 4
a232 11
	/*
	 * compute the new rotation to apply to the previous
	 * viewing rotation.
	 * Alpha is angle of rotation about the X axis, and is done third.
	 * Beta is angle of rotation about the Y axis, and is done second.
	 * Gamma is angle of rotation about Z axis, and is done first.
	 */
	mat[0] = cbeta * cgamma;
	mat[1] = -cbeta * sgamma;
	mat[2] = -sbeta;
	mat[3] = 0.0;
d234 2
a235 11
	mat[4] = -salpha * sbeta * cgamma + calpha * sgamma;
	mat[5] = salpha * sbeta * sgamma + calpha * cgamma;
	mat[6] = -salpha * cbeta;
	mat[7] = 0.0;

	mat[8] = calpha * sbeta * cgamma + salpha * sgamma;
	mat[9] = -calpha * sbeta * sgamma + salpha * cgamma;
	mat[10] = calpha * cbeta;
	mat[11] = 0.0;
	mat[12] = mat[13] = mat[14] = 0.0;
	mat[15] = 1.0;
@
