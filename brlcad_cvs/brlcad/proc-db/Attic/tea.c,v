head	11.19;
access;
symbols
	ansi-20040405-merged:11.15.2.2
	postmerge-20040405-ansi:11.17
	premerge-20040404-ansi:11.16
	postmerge-autoconf:11.16
	autoconf-freeze:11.16
	premerge-autoconf:11.16
	postmerge-20040315-windows:11.16
	premerge-20040315-windows:11.16
	windows-20040315-freeze:11.15.4.1
	autoconf-20031203:11.16
	autoconf-20031202:11.16
	autoconf-branch:11.16.0.4
	phong-branch:11.16.0.2
	photonmap-branch:11.15.0.6
	rel-6-1-DP:11.15
	windows-branch:11.15.0.4
	rel-6-0-2:11.13
	ansi-branch:11.15.0.2
	rel-6-0-1-branch:11.13.0.2
	hartley-6-0-post:11.14
	hartley-6-0-pre:11.13
	rel-6-0-1:11.13
	rel-6-0:11.13
	rel-5-4:11.6
	offsite-5-3-pre:11.10
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.4
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.19
date	2004.05.21.17.33.46;	author morrison;	state dead;
branches;
next	11.18;

11.18
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.17;

11.17
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2003.09.10.16.40.13;	author morrison;	state Exp;
branches;
next	11.15;

11.15
date	2002.08.20.17.08.35;	author jra;	state Exp;
branches
	11.15.2.1
	11.15.4.1;
next	11.14;

11.14
date	2002.08.15.20.55.47;	author hartley;	state Exp;
branches;
next	11.13;

11.13
date	2001.10.12.18.40.29;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	2001.06.22.12.51.23;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	2001.05.17.20.05.56;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2000.09.08.05.57.49;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.07.12.21.59.08;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.07.12.03.46.42;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.10.23.35.40;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.03.31.03.07.32;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.01.27.13.37.23;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	97.10.08.21.15.12;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.07.15.18.16.22;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.12.01.16.14.27;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.06.19;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.11.14.22.15.31;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.09.19.42.20;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	92.05.29.01.28.18;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.29.00.58.49;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.42;	author mike;	state Rel4_0;
branches;
next	9.6;

9.6
date	91.10.11.08.25.21;	author butler;	state Exp;
branches;
next	9.5;

9.5
date	91.07.02.01.49.23;	author stay;	state Exp;
branches;
next	9.4;

9.4
date	91.06.12.22.20.46;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	91.01.04.00.47.48;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	91.01.03.22.54.21;	author butler;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.04.54;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.38.28;	author mike;	state Rel3_0;
branches;
next	1.2;

1.2
date	88.10.01.01.51.48;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	88.09.02.13.08.59;	author stay;	state Exp;
branches;
next	;

11.15.2.1
date	2002.09.19.18.02.13;	author morrison;	state Exp;
branches;
next	11.15.2.2;

11.15.2.2
date	2004.03.17.21.22.55;	author morrison;	state Exp;
branches;
next	;

11.15.4.1
date	2004.03.10.15.06.37;	author morrison;	state Exp;
branches;
next	;


desc
@Converting IEEE teapot example from the famous UTAH TEAPOT to 
BRLCAD spline database.
@


11.19
log
@moved to src/proc-db/
@
text
@/*		T E A . C
 *
 * Convert the Utah Teapot description from the IEEE CG&A database to the
 * BRL-CAD spline format. (Note that this has the closed bottom)
 *
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>		/* Direct the output to stdout */
#include <unistd.h>
#include "machine.h"		/* BRLCAD specific machine data types */
#include "vmath.h"		/* BRLCAD Vector macros */
#include "nurb.h"		/* BRLCAD Spline data structures */
#include "raytrace.h"
#include "wdb.h"

#include "./tea.h"		/* IEEE Data Structures */
#include "./ducks.h"		/* Teapot Vertex data */
#include "./patches.h"		/* Teapot Patch data */

extern dt ducks[DUCK_COUNT];		/* Vertex data of teapot */
extern pt patches[PATCH_COUNT];		/* Patch data of teapot */

struct face_g_snurb **surfaces;

char *Usage = "This program ordinarily generates a database on stdout.\n\
	Your terminal probably wouldn't like it.";

/*void dump_patch(int (*patch)[4]);*/
void dump_patch( struct face_g_snurb **surfp, pt patch );

struct rt_wdb *outfp;

int
main(int argc, char **argv) 			/* really has no arguments */
                       
{
	char * id_name = "Spline Example";
	char * tea_name = "UtahTeapot";
	int i;

	rt_init_resource( &rt_uniresource, 0, NULL );

	outfp = wdb_fopen("teapot.g");

	while ((i=getopt(argc, argv, "d")) != EOF) {
		switch (i) {
		case 'd' : rt_g.debug |= DEBUG_MEM | DEBUG_MEM_FULL; break;
		default	:
			(void)fprintf(stderr,
				"Usage: %s [-d]\n", *argv);
			return(-1);
		}
	}

	/* Setup information 
   	 * Database header record
	 *	File name
	 * B-Spline Solid record
	 * 	Name, Number of Surfaces, resolution (not used)
	 *
	 */

	mk_id( outfp, id_name);

	/* Step through each patch and create a B_SPLINE surface
	 * representing the patch then dump them out.
	 */

	surfaces = (struct face_g_snurb **)bu_calloc( PATCH_COUNT+2,
			       sizeof( struct face_g_snurb *), "surfaces" );

	for( i = 0; i < PATCH_COUNT; i++)
	{
		dump_patch( &surfaces[i], patches[i] );
	}
	surfaces[PATCH_COUNT] = NULL;

	mk_bspline( outfp, tea_name, surfaces );

	return(0);
}

/* IEEE patch number of the Bi-Cubic Bezier patch and convert it
 * to a B-Spline surface (Bezier surfaces are a subset of B-spline surfaces
 * and output it to a BRLCAD binary format.
 */
void
dump_patch( struct face_g_snurb **surfp, pt patch )
{
	struct face_g_snurb * b_patch;
	int i,j, pt_type;
	fastf_t * mesh_pointer;

	/* U and V parametric Direction Spline parameters
	 * Cubic = order 4, 
	 * knot size is Control point + order = 4
	 * control point size is 4
	 * point size is 3
	 */

	pt_type = RT_NURB_MAKE_PT_TYPE(3, 2,0); /* see nurb.h for details */

	b_patch = (struct face_g_snurb *) rt_nurb_new_snurb( 4, 4, 8, 8, 4, 4,
		pt_type, &rt_uniresource);
	*surfp = b_patch;
	
	/* Now fill in the pieces */

	/* Both u and v knot vectors are [ 0 0 0 0 1 1 1 1] 
	 * spl_kvknot( order, lower parametric value, upper parametric value,
	 * 		Number of interior knots )
 	 */
	

	bu_free((char *)b_patch->u.knots, "dumping u knots I'm about to realloc");
	rt_nurb_kvknot( &b_patch->u, 4, 0.0, 1.0, 0, &rt_uniresource);

	bu_free((char *)b_patch->v.knots, "dumping v_kv knots I'm about to realloc");
	rt_nurb_kvknot( &b_patch->v, 4, 0.0, 1.0, 0, &rt_uniresource);

	if (RT_G_DEBUG) {
		rt_ck_malloc_ptr(b_patch, "b_patch");
		rt_ck_malloc_ptr(b_patch->u.knots,
			"b_patch->u.knots");
		rt_ck_malloc_ptr(b_patch->v.knots,
			"b_patch->v.knots");
	}

	/* Copy the control points */

	mesh_pointer = b_patch->ctl_points;

	for( i = 0; i< 4; i++)
	for( j = 0; j < 4; j++)
	{
		*mesh_pointer = ducks[patch[i][j]-1].x * 1000;
		*(mesh_pointer+1) = ducks[patch[i][j]-1].y * 1000;
		*(mesh_pointer+2) = ducks[patch[i][j]-1].z * 1000;
		mesh_pointer += 3;
	}
}
@


11.18
log
@change conf.h to a wrapped config.h
@
text
@@


11.17
log
@merge of ansi-6-0-branch into head
@
text
@d8 5
a12 1
#include "conf.h"
@


11.16
log
@removed useless comment
@
text
@d30 2
a31 1
void dump_patch();
d36 2
a37 2
main(argc, argv) 			/* really has no arguments */
int argc; char *argv[];
@


11.15
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@a7 2
/* Header files which are used for this example */

@


11.15.4.1
log
@merge in updates from HEAD
@
text
@d8 2
@


11.15.2.1
log
@Initial ANSIfication
@
text
@d32 1
a32 2
/*void dump_patch(int (*patch)[4]);*/
void dump_patch( struct face_g_snurb **surfp, pt patch );
d37 2
a38 2
main(int argc, char **argv) 			/* really has no arguments */
                       
@


11.15.2.2
log
@sync branch with HEAD
@
text
@d8 2
@


11.14
log
@Converted from K&R to ANSI C - RFH
@
text
@d32 1
a32 2
/*void dump_patch(int (*patch)[4]);*/
void dump_patch( struct face_g_snurb **surfp, pt patch );
d37 2
a38 2
main(int argc, char **argv) 			/* really has no arguments */
                       
@


11.13
log
@Misc compiler warnings fixed.
@
text
@d32 2
a33 1
void dump_patch();
d38 2
a39 2
main(argc, argv) 			/* really has no arguments */
int argc; char *argv[];
@


11.12
log
@Fix to eliminate core dumping behavior in rt_nurb_ifree() (surface pointers are now dynamically allocated)
@
text
@d13 1
@


11.11
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d26 1
a26 1
struct face_g_snurb *surfaces[PATCH_COUNT+2];
d70 3
@


11.10
log
@
Tree routines need resource structure
@
text
@d120 1
a120 1
	if (rt_g.debug) {
@


11.9
log
@
Converted to use new version of LIBWDB.
@
text
@d43 1
a43 1
	rt_init_resource( &rt_uniresource, 1 );
@


11.8
log
@
Header files
@
text
@d26 2
d33 3
d45 1
a45 4
	if (isatty(fileno(stdout))) {
		(void)fprintf(stderr, "%s: %s\n", *argv, Usage);
		return(-1);
	}
d52 1
a52 1
				"Usage: %s [-d] > database.g\n", *argv);
d65 1
a65 2
	mk_id( stdout, id_name);
	mk_bsolid( stdout, tea_name, PATCH_COUNT, 1.0);
d73 1
a73 1
		dump_patch( patches[i] );
d75 4
d87 1
a87 2
dump_patch( patch )
pt patch;
d104 1
a139 3

	/* Output the the b_spline through the libwdb interface */
	mk_bsurf( stdout, b_patch);
@


11.7
log
@
raytrace.h before wdb.h
Eliminated use of db.h
@
text
@d17 1
a17 1
#include "../librt/debug.h"	/* rt_g.debug flag settings */
@


11.6
log
@
Changed RT_ to BU_ / BN_
@
text
@a13 1
#include "db.h"			/* BRLCAD data base format */
@


11.5
log
@Corrected resource initialization
@
text
@d110 1
a110 1
	rt_free((char *)b_patch->u.knots, "dumping u knots I'm about to realloc");
d113 1
a113 1
	rt_free((char *)b_patch->v.knots, "dumping v_kv knots I'm about to realloc");
@


11.4
log
@Splines take resources
@
text
@d39 1
a39 1
	rt_uniresource.re_magic = RESOURCE_MAGIC;
@


11.3
log
@Minor Mods for IRIX 6.2
@
text
@d39 2
d99 2
a100 1
	b_patch = (struct face_g_snurb *) rt_nurb_new_snurb( 4, 4, 8, 8, 4, 4, pt_type);
d111 1
a111 1
	rt_nurb_kvknot( &b_patch->u, 4, 0.0, 1.0, 0);
d114 1
a114 1
	rt_nurb_kvknot( &b_patch->v, 4, 0.0, 1.0, 0);
@


11.2
log
@New NURBS data structures
@
text
@d30 2
d80 1
a80 1

@


11.1
log
@Release_4.4
@
text
@d82 1
a82 1
	struct snurb * b_patch;
d95 1
a95 1
	b_patch = (struct snurb *) rt_nurb_new_snurb( 4, 4, 8, 8, 4, 4, pt_type);
d105 2
a106 2
	rt_free((char *)b_patch->u_knots.knots, "dumping u_knots knots I'm about to realloc");
	rt_nurb_kvknot( &b_patch->u_knots, 4, 0.0, 1.0, 0);
d108 2
a109 2
	rt_free((char *)b_patch->v_knots.knots, "dumping v_kv knots I'm about to realloc");
	rt_nurb_kvknot( &b_patch->v_knots, 4, 0.0, 1.0, 0);
d113 4
a116 4
		rt_ck_malloc_ptr(b_patch->u_knots.knots,
			"b_patch->u_knots.knots");
		rt_ck_malloc_ptr(b_patch->v_knots.knots,
			"b_patch->v_knots.knots");
@


10.5
log
@Irix 6
@
text
@@


10.4
log
@Added include of conf.h
@
text
@a48 1
			break;
@


10.3
log
@New data structures
@
text
@d10 2
@


10.2
log
@Modified to track NURB data structure changes
@
text
@d120 1
a120 1
	mesh_pointer = b_patch->mesh.ctl_points;
@


10.1
log
@Release_4.0
@
text
@d92 1
a92 1
	pt_type = MAKE_PT_TYPE(3, 2,0); /* see nurb.h for details */
d104 2
a105 4
	rt_free((char *)b_patch->u_knots->knots, "dumping u_knots knots I'm about to realloc");
	rt_free((char *)b_patch->u_knots, "dumping u_knots I'm about to realloc");
	b_patch->u_knots = 
	    (struct knot_vector *) rt_nurb_kvknot( 4, 0.0, 1.0, 0);
d107 2
a108 2
	rt_free((char *)b_patch->v_knots->knots, "dumping v_kv knots I'm about to realloc");
	rt_free((char *)b_patch->v_knots, "dumping v_kv I'm about to realloc");
a109 3
	b_patch->v_knots = 
	    (struct knot_vector *) rt_nurb_kvknot( 4, 0.0, 1.0, 0);

d112 4
a115 6
		rt_ck_malloc_ptr(b_patch->u_knots, "b_patch->u_knots");
		rt_ck_malloc_ptr(b_patch->u_knots->knots,
			"b_patch->u_knots->knots");
		rt_ck_malloc_ptr(b_patch->v_knots, "b_patch->v_knots");
		rt_ck_malloc_ptr(b_patch->v_knots->knots,
			"b_patch->v_knots->knots");
d120 1
a120 1
	mesh_pointer = b_patch->mesh->ctl_points;
@


9.6
log
@added "return(0)" to end of main()
@
text
@@


9.5
log
@Converted to libnurb
@
text
@d70 1
a70 1

@


9.4
log
@lint
@
text
@d14 1
a14 1
#include "../libspl/b_spline.h"		/* BRLCAD Spline data structures */
a21 1

a34 1

a50 1

d81 2
a82 2
	struct b_spline * b_patch;
	int i,j;
d92 3
a94 1
	b_patch = (struct b_spline *) spl_new( 4, 4, 8, 8, 4, 4, 3);
d104 4
a107 4
	rt_free((char *)b_patch->u_kv->knots, "dumping u_kv knots I'm about to realloc");
	rt_free((char *)b_patch->u_kv, "dumping u_kv I'm about to realloc");
	b_patch->u_kv = 
	    (struct knot_vec *) spl_kvknot( 4, 0.0, 1.0, 0);
d109 2
a110 4
	rt_free((char *)b_patch->v_kv->knots, "dumping v_kv knots I'm about to realloc");
	rt_free((char *)b_patch->v_kv, "dumping v_kv I'm about to realloc");
	b_patch->v_kv = 
	    (struct knot_vec *) spl_kvknot( 4, 0.0, 1.0, 0);
d112 3
d117 6
a122 6
		rt_ck_malloc_ptr(b_patch->u_kv, "b_patch->u_kv");
		rt_ck_malloc_ptr(b_patch->u_kv->knots,
			"b_patch->u_kv->knots");
		rt_ck_malloc_ptr(b_patch->v_kv, "b_patch->v_kv");
		rt_ck_malloc_ptr(b_patch->v_kv->knots,
			"b_patch->v_kv->knots");
d127 1
a127 1
	mesh_pointer = b_patch->ctl_mesh->mesh;
@


9.3
log
@Added type cast
@
text
@d15 3
d21 1
a21 2
#include "raytrace.h"
#include "../librt/debug.h"	/* rt_g.debug flag settings */
@


9.2
log
@added calls to rt_free for things that were re-malloc'ed in libspl, and
calls to rt_ck_malloc_ptr
@
text
@d103 2
a104 2
	rt_free(b_patch->u_kv->knots, "dumping u_kv knots I'm about to realloc");
	rt_free(b_patch->u_kv, "dumping u_kv I'm about to realloc");
d108 2
a109 2
	rt_free(b_patch->v_kv->knots, "dumping v_kv knots I'm about to realloc");
	rt_free(b_patch->v_kv, "dumping v_kv I'm about to realloc");
@


9.1
log
@Release_3.5
@
text
@d18 2
a20 1

d24 3
d35 17
d102 3
d108 2
d113 9
d130 3
a132 3
		*mesh_pointer = ducks[patch[i][j]-1].x;
		*(mesh_pointer+1) = ducks[patch[i][j]-1].y;
		*(mesh_pointer+2) = ducks[patch[i][j]-1].z;
@


8.1
log
@Release_3.0
@
text
@@


1.2
log
@Fixed name problem with space in the middle.
@
text
@@


1.1
log
@Initial revision
@
text
@d27 1
a27 1
	char * tea_name = "Utah Teapot";
@
