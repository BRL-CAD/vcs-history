head	11.17;
access;
symbols
	ansi-20040405-merged:11.13.2.2
	postmerge-20040405-ansi:11.15
	premerge-20040404-ansi:11.14
	postmerge-autoconf:11.14
	autoconf-freeze:11.13.10.2
	premerge-autoconf:11.14
	postmerge-20040315-windows:11.14
	premerge-20040315-windows:11.14
	windows-20040315-freeze:11.13.4.1
	autoconf-20031203:11.13
	autoconf-20031202:11.13
	autoconf-branch:11.13.0.10
	phong-branch:11.13.0.8
	photonmap-branch:11.13.0.6
	rel-6-1-DP:11.13
	windows-branch:11.13.0.4
	rel-6-0-2:11.11
	ansi-branch:11.13.0.2
	rel-6-0-1-branch:11.11.0.2
	hartley-6-0-post:11.12
	hartley-6-0-pre:11.11
	rel-6-0-1:11.11
	rel-6-0:11.10
	rel-5-4:11.5
	offsite-5-3-pre:11.9
	rel-5-3:11.5
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.17
date	2004.05.21.17.33.47;	author morrison;	state dead;
branches;
next	11.16;

11.16
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.15;

11.15
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2004.02.02.17.39.38;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2002.08.20.17.08.35;	author jra;	state Exp;
branches
	11.13.2.1
	11.13.4.1
	11.13.10.1;
next	11.12;

11.12
date	2002.08.15.20.55.47;	author hartley;	state Exp;
branches;
next	11.11;

11.11
date	2002.05.17.12.42.25;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2001.03.31.01.57.28;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2000.08.24.04.48.36;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.07.12.21.59.08;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.10.23.38.23;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.07.10.23.35.41;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.03.31.03.07.32;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.10.08.21.13.22;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.08.31.11.37.32;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.12.01.16.08.19;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.06.22;	author mike;	state Rel4_4;
branches;
next	10.6;

10.6
date	94.11.14.22.15.02;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.10.21.20.02.11;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.09.19.42.42;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	92.05.29.01.27.59;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.29.00.58.57;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.43;	author mike;	state Rel4_0;
branches;
next	9.6;

9.6
date	91.07.01.22.48.27;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.06.14.10.13.17;	author stay;	state Exp;
branches;
next	9.4;

9.4
date	90.12.08.06.16.18;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.11.01.05.15.19;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.10.16.11.18.26;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.04.56;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.04.30.21.37.58;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.38.30;	author mike;	state Rel3_0;
branches;
next	1.15;

1.15
date	88.08.20.07.26.44;	author phil;	state Exp;
branches;
next	1.14;

1.14
date	88.05.15.23.00.20;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	88.01.16.07.53.05;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	88.01.16.07.09.29;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	88.01.16.00.59.40;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	87.12.31.08.49.05;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	87.12.31.07.45.00;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	87.12.31.04.16.42;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	87.12.31.02.59.25;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	87.12.31.01.20.38;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	87.12.31.00.07.36;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	87.12.30.23.21.01;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	87.12.30.17.47.40;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	87.12.30.17.42.30;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.12.30.04.43.27;	author mike;	state Exp;
branches;
next	;

11.13.2.1
date	2002.09.19.18.02.13;	author morrison;	state Exp;
branches;
next	11.13.2.2;

11.13.2.2
date	2004.03.17.21.22.55;	author morrison;	state Exp;
branches;
next	;

11.13.4.1
date	2004.03.10.15.06.37;	author morrison;	state Exp;
branches;
next	;

11.13.10.1
date	2004.02.12.19.50.52;	author erikg;	state Exp;
branches;
next	11.13.10.2;

11.13.10.2
date	2004.03.15.14.08.05;	author erikg;	state Exp;
branches;
next	;


desc
@Program to generate tubes (More Park's Sausages Mom, Please!)
@


11.17
log
@moved to src/proc-db/
@
text
@/*
 *			T U B E . C
 *
 *  Program to generate a gun-tube as a procedural spline.
 *  The tube's core lies on the X axis.
 *
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright 
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/proc-db/tube.c,v 11.16 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "nurb.h"
#include "raytrace.h"
#include "wdb.h"

mat_t	identity;
double	degtorad = 0.0174532925199433;
double	inches2mm = 25.4;

void	build_spline(char *name, int npts, double radius), read_pos(FILE *fp), build_cyl(char *cname, int npts, double radius), xfinddir(fastf_t *dir, double x, fastf_t *loc);
int	read_frame( FILE *fp );

#define N_CIRCLE_KNOTS	12
fastf_t	circle_knots[N_CIRCLE_KNOTS] = {
	0,	0,	0,
	1,	1,
	2,	2,
	3,	3,
	4,	4,	4
};

#define IRT2	0.70710678	/* 1/sqrt(2) */
#define NCOLS	9
/* When scaling, multiply only XYZ, not W */
fastf_t polyline[NCOLS*4] = {
	0,	1,	0,	1,
	0,	IRT2,	IRT2,	IRT2,
	0,	0,	1,	1,
	0,	-IRT2,	IRT2,	IRT2,
	0,	-1,	0,	1,
	0,	-IRT2,	-IRT2,	IRT2,
	0,	0,	-1,	1,
	0,	IRT2,	-IRT2,	IRT2,
	0,	1,	0,	1
};

/*
 * X displacement table for Kathy's gun tube center of masses, in mm,
 * with X=0 at rear of projectile (on diagram, junction between m1 & m2)
 *  This table lists x positions of centers of mass m1..m12, which
 *  will be used as the end-points of the cylinders
 */
double	dxtab[] = {
	-555,		/* breach rear */
	-280.5,		/* m1 */
	341,
	700+316,
	700+650+246.4,
	700+650+650+301.8,				/* m5 */
	700+650+650+600+238.7,
	700+650+650+600+500+178.9,
	700+650+650+600+500+400+173.4,			/* m8 */
	700+650+650+600+500+400+350+173.3,
	700+650+650+600+500+400+350+350+148.7,
	700+650+650+600+500+400+350+350+300+147.4,
	700+650+650+600+500+400+350+350+300+300+119,	/* m12 */
	700+650+650+600+500+400+350+350+300+300+238,	/* muzzle end */
	0,
};

double	projectile_pos;
point_t	sample[1024];
int	nsamples;

double	iradius, oradius;
double	length;
double	spacing;

int	nframes = 10;
double	delta_t = 0.02;		/* ms/step */
FILE	*pos_fp;
double	cur_time;

struct rt_wdb	*outfp;

int
main(int argc, char **argv)
{
	int	frame;
	char	name[128];
	char	gname[128];
	vect_t	normal;
	struct wmember head, ghead;
	matp_t	matp;
	mat_t	xlate;
	mat_t	rot1, rot2, rot3;
	vect_t	from, to;
	vect_t	offset;

	BU_LIST_INIT( &head.l );
	BU_LIST_INIT( &ghead.l );
	rt_uniresource.re_magic = RESOURCE_MAGIC;

	outfp = wdb_fopen("tube.g");
	if( (pos_fp = fopen( "pos.dat", "r" )) == NULL )
		perror( "pos.dat" );	/* Just warn */

	mk_id( outfp, "Procedural Gun Tube with Projectile" );

	VSET( normal, 0, -1, 0 );
	mk_half( outfp, "cut", normal, 0.0 );
	VSET( normal, 0, 1, 0 );
	mk_half( outfp, "bg.s", normal, -1000.0 );
	(void)mk_addmember( "bg.s", &head.l, NULL, WMOP_UNION );	/* temp use of "head" */
	mk_lcomb( outfp, "bg.r", &head, 1,
		"texture", "file=movie128bw.pix w=128",
		(unsigned char *)0, 0 );

#ifdef never
	/* Numbers for a 105-mm M68 gun */
	oradius = 5 * inches2mm / 2;		/* 5" outer diameter */
	iradius = 4.134 * inches2mm / 2;	/* 5" inner (land) diameter */
#else
	/* Numbers invented to match 125-mm KE (Erline) round */
	iradius = 125.0/2;
	oradius = iradius + (5-4.134) * inches2mm / 2;		/* 5" outer diameter */
#endif
	fprintf(stderr,"inner radius=%gmm, outer radius=%gmm\n", iradius, oradius);

	length = 187 * inches2mm;
#ifdef never
	spacing = 100;			/* mm per sample */
	nsamples = ceil(length/spacing);
	fprintf(stderr,"length=%gmm, spacing=%gmm\n", length, spacing);
	fprintf(stderr,"nframes=%d\n", nframes);
#endif

	for( frame=0;; frame++ )  {
		cur_time = frame * delta_t;
#ifdef never
		/* Generate some dummy sample data */
		if( frame < 16 ) break;
		for( i=0; i<nsamples; i++ )  {
			sample[i][X] = i * spacing;
			sample[i][Y] = 0;
			sample[i][Z] = 4 * oradius * sin(
				((double)i*i)/nsamples * 2 * 3.14159265358979323 +
				frame * 3.141592 * 2 / 8 );
		}
		projectile_pos = ((double)frame)/nframes *
			(sample[nsamples-1][X] - sample[0][X]); /* length */
#else
		if( read_frame(stdin) < 0 )  break;
		if( pos_fp != NULL )  read_pos(pos_fp);
#endif

#define build_spline build_cyl
		sprintf( name, "tube%do", frame);
		build_spline( name, nsamples, oradius );
		(void)mk_addmember( name, &head.l, NULL, WMOP_UNION );

		sprintf( name, "tube%di", frame);
		build_spline( name, nsamples, iradius );
		mk_addmember( name, &head.l, NULL, WMOP_SUBTRACT );

		mk_addmember( "cut", &head.l, NULL, WMOP_SUBTRACT );

		sprintf( name, "tube%d", frame);
		mk_lcomb( outfp, name, &head, 1,
			"plastic", "",
			(unsigned char *)0, 0 );

		/*  Place the tube region and the ammo together.
		 *  The origin of the ammo is expected to be the center
		 *  of the rearmost plate.
		 */
		mk_addmember( name, &ghead.l, NULL, WMOP_UNION );
		matp = mk_addmember( "ke", &ghead.l, NULL, WMOP_UNION )->wm_mat;

		VSET( from, 0, -1, 0 );
		VSET( to, 1, 0, 0 );		/* to X axis */
		bn_mat_fromto( rot1, from, to );

		VSET( from, 1, 0, 0 );
		/* Projectile is 480mm long -- use center pt, not end */
		xfinddir( to, projectile_pos + 480.0/2, offset );
		bn_mat_fromto( rot2, from, to );

		MAT_IDN( xlate );
		MAT_DELTAS( xlate, offset[X], offset[Y], offset[Z] );
		bn_mat_mul( rot3, rot2, rot1 );
		bn_mat_mul( matp, xlate, rot3 );

		(void)mk_addmember( "light.r", &ghead.l, NULL, WMOP_UNION );
		(void)mk_addmember( "bg.r", &ghead.l, NULL, WMOP_UNION );

		sprintf( gname, "g%d", frame);
		mk_lcomb( outfp, gname, &ghead, 0,
			(char *)0, "", (unsigned char *)0, 0 );

		fprintf( stderr, "%d, ", frame );  fflush(stderr);
	}
	wdb_close(outfp);
	fflush(stderr);
	system("cat ke.g");	/* XXX need library routine */
	exit(0);
}
#undef build_spline

void
build_spline(char *name, int npts, double radius)
{
	struct face_g_snurb *bp;
	register int i;
	int	nv;
	int	cur_kv;
	fastf_t	*meshp;
	register int col;
	vect_t	point;

	/*
	 *  This spline will look like a cylinder.
	 *  In the mesh, the circular cross section will be presented
	 *  across the first row by filling in the 9 (NCOLS) columns.
	 *
	 *  The U direction is across the first row,
	 *  and has NCOLS+order[U] positions, 12 in this instance.
	 *  The V direction is down the first column,
	 *  and has NROWS+order[V] positions.
	 */
	bp = rt_nurb_new_snurb( 3,	4,		/* u,v order */
		N_CIRCLE_KNOTS,	npts+6,		/* u,v knot vector size */
		npts+2,		NCOLS,		/* nrows, ncols */
		RT_NURB_MAKE_PT_TYPE(4,2,1),
		&rt_uniresource);

	/*  Build the U knots */
	for( i=0; i<N_CIRCLE_KNOTS; i++ )
		bp->u.knots[i] = circle_knots[i];

	/* Build the V knots */
	cur_kv = 0;		/* current knot value */
	nv = 0;			/* current knot subscript */
	for( i=0; i<4; i++ )
		bp->v.knots[nv++] = cur_kv;
	cur_kv++;
	for( i=4; i<(npts+4-2); i++ )
		bp->v.knots[nv++] = cur_kv++;
	for( i=0; i<4; i++ )
		bp->v.knots[nv++] = cur_kv;

	/*
	 *  The control mesh is stored in row-major order,
	 *  which works out well for us, as a row is one
	 *  circular slice through the tube.  So we just
	 *  have to write down the slices, one after another.
	 *  The first and last "slice" are the center points that
	 *  create the end caps.
	 */
	meshp = bp->ctl_points;

	/* Row 0 */
	for( col=0; col<9; col++ )  {
		*meshp++ = sample[0][X];
		*meshp++ = sample[0][Y];
		*meshp++ = sample[0][Z];
		*meshp++ = 1;
	}

	/* Rows 1..npts */
	for( i=0; i<npts; i++ )  {
		/* row = i; */
		VMOVE( point, sample[i] );
		for( col=0; col<9; col++ )  {
			register fastf_t h;

			h = polyline[col*4+H];
			*meshp++ = polyline[col*4+X]*radius + point[X]*h;
			*meshp++ = polyline[col*4+Y]*radius + point[Y]*h;
			*meshp++ = polyline[col*4+Z]*radius + point[Z]*h;
			*meshp++ = h;
		}
	}

	/* Row npts+1 */
	for( col=0; col<9; col++ )  {
		*meshp++ = sample[npts-1][X];
		*meshp++ = sample[npts-1][Y];
		*meshp++ = sample[npts-1][Z];
		*meshp++ = 1;
	}

	{
		struct face_g_snurb *surfp[2];
		surfp[0] = bp;
		surfp[1] = NULL;
		mk_bspline( outfp, name, surfp );
	}
		
	rt_nurb_free_snurb( bp, &rt_uniresource );
}

/* Returns -1 if done, 0 if something to draw */
int
read_frame( FILE *fp )
{
	char	buf[256];
	int	i;
	static float	last_read_time = -5;
	double	dx = 0.0;

	if( feof(fp) )
		return(-1);

#ifdef never
	/* Phils format */
	for( nsamples=0;;nsamples++)  {
		if( fgets( buf, sizeof(buf), fp ) == NULL )  return(-1);
		if( buf[0] == '\0' || buf[0] == '\n' )
			/* Blank line, marks break in implicit connection */
			fprintf(stderr,"implicit break unimplemented\n");
			continue;
		}
		if( buf[0] == '=' )  {
			/* End of frame */
			break;
		}
		i = sscanf( buf, "%f %f %f",
			&sample[nsamples][X],
			&sample[nsamples][Y],
			&sample[nsamples][Z] );
		if( i != 3 )  {
			fprintf(stderr, "input line didn't have 3 numbers: %s\n", buf);
			break;
		}
		/* Phil's numbers are in meters, not mm */
		sample[nsamples][X] *= 1000;
		sample[nsamples][Y] *= 1000;
		sample[nsamples][Z] *= 1000;
	}
#else
	/* Kurt's / Kathy's format, in inches */
	if( cur_time <= 0 )  {
		/* Really should use Y and Z initial conditions, too */
		for( nsamples=0; nsamples < (sizeof(dxtab)/sizeof(dxtab[0])); nsamples++ )  {
			sample[nsamples][X] = dxtab[nsamples];
			sample[nsamples][Y] = sample[nsamples][Z] = 0;
		}
		return(0);		/* OK */
	}
	if( last_read_time > cur_time )
		return(0);		/* OK, reuse last step's data */
	/* Ferret out next time marker */
	while(1)  {
		if( fgets( buf, sizeof(buf), fp ) == NULL )  {
			fprintf(stderr,"EOF?\n");
			return(-1);
		}
		if( strncmp(buf, "TIME", strlen("TIME")) != 0 )  continue;
		if( sscanf(buf, "TIME %f", &last_read_time ) < 1 )  {
			fprintf(stderr, "bad TIME\n");
			return(-1);
		}
		break;
	}

	for( nsamples=0;;nsamples++)  {
		int	nmass;
		float	kx, ky, kz;

		buf[0] = '\0';
		if( fgets( buf, sizeof(buf), fp ) == NULL )  return(-1);
		/* center of mass #, +X, +Z, -Y (chg of coordinates) */
		if( buf[0] == '\0' || buf[0] == '\n' )
			break;		/* stop at a blank line */
		i = sscanf( buf, "%d %f %f %f",
			&nmass, &kx, &ky, &kz );
		if( i != 4 )  {
			fprintf( stderr, "input line in error: %s\n", buf );
			return(-1);
		}
		if( nmass-1 != nsamples )  {
			fprintf( stderr, "nmass %d / nsamples %d mismatch\n",
				nmass, nsamples );
			return(-1);
		}
#define EXAGERATION	(4 * oradius)
		/* scale = EXAGERATIONmm / MAX_DEVIATIONmm */
		/* Deviations used here manually derived */
		dx = kx * inches2mm * EXAGERATION / (0.95 * inches2mm);
		sample[nsamples][X] = dx + dxtab[nsamples];
		sample[nsamples][Y] = kz * inches2mm *
			EXAGERATION / (0.00002 * inches2mm) /5;
		sample[nsamples][Z] = -ky * inches2mm *
			EXAGERATION / (0.02 * inches2mm);
	}
	/* Extrapolate data for the right side -- end of muzzle */
	sample[nsamples][X] = dxtab[nsamples] + dx;	/* reuse last displacement */
	sample[nsamples][Y] = sample[nsamples-1][Y] * 2 - sample[nsamples-2][Y];
	sample[nsamples][Z] = sample[nsamples-1][Z] * 2 - sample[nsamples-2][Z];
	nsamples++;
#endif
	if( nsamples <= 4 )  {
		fprintf(stderr,"insufficient samples\n");
		return(-1);
	}
	return(0);			/* OK */
}

void
read_pos(FILE *fp)
{
	static float	last_read_time = -5;
	static float	pos = 0;

	/* Skip over needless intermediate time steps */
	while( last_read_time < cur_time )  {
		if( feof(fp) )
			break;
		fscanf( fp, "%f %f", &last_read_time, &pos );
		/* HACK:  tmax[kathy]=6.155ms, tmax[kurt]=9.17 */
		/* we just read a Kurt number, make it a Kathy number */
		last_read_time = last_read_time / 9.17 * 6.155;
	}

	/* Kurt's data is in inches */
	projectile_pos = pos * inches2mm;
}

void
build_cyl(char *cname, int npts, double radius)
{
	register int i;
	vect_t	v, h, a, b;
	char	name[32];
	struct wmember head;

	BU_LIST_INIT( &head.l );

	for( i=0; i<npts-1; i++ )  {
		VMOVE( v, sample[i] );
		VSUB2( h, sample[i+1], v );
		VSET( a, 0, radius, 0 );
		VSET( b, 0, 0, radius );

		sprintf( name, "%s%d", cname, i );
		mk_tgc( outfp, name, v, h, a, b, a, b );
		(void)mk_addmember( name, &head.l, NULL, WMOP_UNION );
	}
	mk_lfcomb( outfp, cname, &head, 0 );
}

/*
 * Find which section a given X value is in, and indicate what
 * direction the tube is headed in then.
 */
void
xfinddir(fastf_t *dir, double x, fastf_t *loc)
{
	register int i;
	fastf_t	ratio;

	for( i=0; i<nsamples-1; i++ )  {
		if( x < sample[i][X] )
			break;
		if( x >= sample[i+1][X] )
			continue;
		goto out;
	}
	fprintf(stderr, "xfinddir: x=%g is past last segment, using final direction\n", x);
	i = nsamples-2;
out:
	VSUB2( dir, sample[i+1], sample[i] );
	ratio = (x-sample[i][X]) / (sample[i+1][X]-sample[i][X]);
	VJOIN1( loc, sample[i], ratio, dir );

	VUNITIZE( dir );
	return;
}
@


11.16
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/proc-db/tube.c,v 11.15 2004/04/05 05:45:58 morrison Exp $ (BRL)";
@


11.15
log
@merge of ansi-6-0-branch into head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.14
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/tube.c,v 11.13 2002/08/20 17:08:35 jra Exp $ (BRL)";
d44 1
a44 1
void	build_spline(), read_pos(), build_cyl(), xfinddir();
d111 1
a111 2
main(argc, argv)
char	**argv;
d235 1
a235 4
build_spline( name, npts, radius )
char	*name;
int	npts;
double	radius;
d435 1
a435 2
read_pos(fp)
FILE	*fp;
d455 1
a455 4
build_cyl( cname, npts, radius )
char	*cname;
int	npts;
double	radius;
d482 1
a482 4
xfinddir( dir, x, loc)
vect_t	dir;
double	x;
point_t	loc;
@


11.13
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/tube.c,v 11.11 2002/05/17 12:42:25 morrison Exp $ (BRL)";
@


11.13.4.1
log
@merge in updates from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/proc-db/tube.c,v 11.14 2004/02/02 17:39:38 morrison Exp $ (BRL)";
@


11.13.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/tube.c,v 11.14 2004/02/02 17:39:38 morrison Exp $ (BRL)";
@


11.13.10.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/tube.c,v 11.13.10.1 2004/02/12 19:50:52 erikg Exp $ (BRL)";
@


11.13.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/tube.c,v 11.13 2002/08/20 17:08:35 jra Exp $ (BRL)";
d44 1
a44 1
void	build_spline(char *name, int npts, double radius), read_pos(FILE *fp), build_cyl(char *cname, int npts, double radius), xfinddir(fastf_t *dir, double x, fastf_t *loc);
d111 2
a112 1
main(int argc, char **argv)
d236 4
a239 1
build_spline(char *name, int npts, double radius)
d439 2
a440 1
read_pos(FILE *fp)
d460 4
a463 1
build_cyl(char *cname, int npts, double radius)
d490 4
a493 1
xfinddir(fastf_t *dir, double x, fastf_t *loc)
@


11.13.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.12
log
@Converted from K&R to ANSI C - RFH
@
text
@d44 1
a44 1
void	build_spline(char *name, int npts, double radius), read_pos(FILE *fp), build_cyl(char *cname, int npts, double radius), xfinddir(fastf_t *dir, double x, fastf_t *loc);
d111 2
a112 1
main(int argc, char **argv)
d236 4
a239 1
build_spline(char *name, int npts, double radius)
d439 2
a440 1
read_pos(FILE *fp)
d460 4
a463 1
build_cyl(char *cname, int npts, double radius)
d490 4
a493 1
xfinddir(fastf_t *dir, double x, fastf_t *loc)
@


11.11
log
@added matrix parameter to mk_addmember()
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/tube.c,v 11.10 2001/03/31 01:57:28 morrison Exp $ (BRL)";
d44 1
a44 1
void	build_spline(), read_pos(), build_cyl(), xfinddir();
d111 1
a111 2
main(argc, argv)
char	**argv;
d235 1
a235 4
build_spline( name, npts, radius )
char	*name;
int	npts;
double	radius;
d435 1
a435 2
read_pos(fp)
FILE	*fp;
d455 1
a455 4
build_cyl( cname, npts, radius )
char	*cname;
int	npts;
double	radius;
d482 1
a482 4
xfinddir( dir, x, loc)
vect_t	dir;
double	x;
point_t	loc;
@


11.10
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/tube.c,v 11.9 2000/08/24 04:48:36 mike Exp $ (BRL)";
d139 1
a139 1
	(void)mk_addmember( "bg.s", &head.l, WMOP_UNION );	/* temp use of "head" */
d185 1
a185 1
		(void)mk_addmember( name, &head.l, WMOP_UNION );
d189 1
a189 1
		mk_addmember( name, &head.l, WMOP_SUBTRACT );
d191 1
a191 1
		mk_addmember( "cut", &head.l, WMOP_SUBTRACT );
d202 2
a203 2
		mk_addmember( name, &ghead.l, WMOP_UNION );
		matp = mk_addmember( "ke", &ghead.l, WMOP_UNION )->wm_mat;
d219 2
a220 2
		(void)mk_addmember( "light.r", &ghead.l, WMOP_UNION );
		(void)mk_addmember( "bg.r", &ghead.l, WMOP_UNION );
d480 1
a480 1
		(void)mk_addmember( name, &head.l, WMOP_UNION );
@


11.9
log
@
mk_addmember
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/tube.c,v 11.8 2000/07/12 21:59:08 mike Exp $ (BRL)";
d214 1
a214 1
		bn_mat_idn( xlate );
@


11.8
log
@
Converted to use new version of LIBWDB.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/tube.c,v 11.7 2000/07/10 23:38:23 mike Exp $ (BRL)";
d139 1
a139 1
	(void)mk_addmember( "bg.s", &head, WMOP_UNION );	/* temp use of "head" */
d185 1
a185 1
		(void)mk_addmember( name, &head, WMOP_UNION );
d189 1
a189 1
		mk_addmember( name, &head, WMOP_SUBTRACT );
d191 1
a191 1
		mk_addmember( "cut", &head, WMOP_SUBTRACT );
d202 2
a203 2
		mk_addmember( name, &ghead, WMOP_UNION );
		matp = mk_addmember( "ke", &ghead, WMOP_UNION )->wm_mat;
d219 2
a220 2
		(void)mk_addmember( "light.r", &ghead, WMOP_UNION );
		(void)mk_addmember( "bg.r", &ghead, WMOP_UNION );
d480 1
a480 1
		(void)mk_addmember( name, &head, WMOP_UNION );
@


11.7
log
@
const RCSid
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/tube.c,v 11.6 2000/07/10 23:35:41 mike Exp $ (BRL)";
d27 5
d45 1
d108 3
d129 1
d133 1
a133 1
	mk_id( stdout, "Procedural Gun Tube with Projectile" );
d136 1
a136 1
	mk_half( stdout, "cut", normal, 0.0 );
d138 1
a138 1
	mk_half( stdout, "bg.s", normal, -1000.0 );
d140 1
a140 1
	mk_lcomb( stdout, "bg.r", &head, 1,
d194 1
a194 1
		mk_lcomb( stdout, name, &head, 1,
d223 1
a223 1
		mk_lcomb( stdout, gname, &ghead, 0,
d228 2
a229 1
	fflush(stdout); fflush(stderr);
d320 7
a327 2
	mk_bsolid( stdout, name, 1, 0.1 );
	mk_bsurf( stdout, bp );
d333 1
a333 2
read_frame(fp)
FILE	*fp;
d479 1
a479 1
		mk_tgc( stdout, name, v, h, a, b, a, b );
d482 1
a482 1
	mk_lfcomb( stdout, cname, &head, 0 );
@


11.6
log
@
raytrace.h before wdb.h
Eliminated use of db.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/tube.c,v 11.5 2000/03/31 03:07:32 mike Exp $ (BRL)";
@


11.5
log
@
Changed RT_ to BU_ / BN_
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/proc-db/tube.c,v 11.4 1997/10/08 21:13:22 mike Exp $ (BRL)";
a28 1
#include "db.h"
d30 1
a30 1
#include "rtlist.h"
d32 1
@


11.4
log
@Splines take resources
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 11.3 1996/08/31 11:37:32 mike Exp mike $ (BRL)";
d116 2
a117 2
	RT_LIST_INIT( &head.l );
	RT_LIST_INIT( &ghead.l );
d197 1
a197 1
		mat_fromto( rot1, from, to );
d202 1
a202 1
		mat_fromto( rot2, from, to );
d204 1
a204 1
		mat_idn( xlate );
d206 2
a207 2
		mat_mul( rot3, rot2, rot1 );
		mat_mul( matp, xlate, rot3 );
d455 1
a455 1
	RT_LIST_INIT( &head.l );
@


11.3
log
@Avoided 'poly' from compat4.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 11.2 1995/12/01 16:08:19 mike Exp mike $ (BRL)";
d118 1
d251 2
a252 1
		RT_NURB_MAKE_PT_TYPE(4,2,1));
d312 1
a312 1
	rt_nurb_free_snurb( bp );
@


11.2
log
@New BURBS data structures
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 11.1 95/01/04 10:06:22 mike Rel4_4 $ (BRL)";
d53 1
a53 1
fastf_t poly[NCOLS*4] = {
d292 4
a295 4
			h = poly[col*4+H];
			*meshp++ = poly[col*4+X]*radius + point[X]*h;
			*meshp++ = poly[col*4+Y]*radius + point[Y]*h;
			*meshp++ = poly[col*4+Z]*radius + point[Z]*h;
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 10.6 94/11/14 22:15:02 mike Exp $ (BRL)";
d229 1
a229 1
	struct snurb *bp;
d254 1
a254 1
		bp->u_knots.knots[i] = circle_knots[i];
d260 1
a260 1
		bp->v_knots.knots[nv++] = cur_kv;
d263 1
a263 1
		bp->v_knots.knots[nv++] = cur_kv++;
d265 1
a265 1
		bp->v_knots.knots[nv++] = cur_kv;
@


10.6
log
@Irix 6
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 10.5 94/10/21 20:02:11 mike Exp Locker: mike $ (BRL)";
@


10.5
log
@Match prototypes of unsigned char rgb
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 10.4 94/08/09 19:42:42 gdurf Exp Locker: mike $ (BRL)";
a104 1
	register int i;
d111 1
a111 1
	mat_t	xlate, prod;
a234 1
	int	row;
@


10.4
log
@Added include of conf.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 10.3 1992/05/29 01:27:59 mike Exp gdurf $ (BRL)";
d132 1
a132 1
		(char *)0, 0 );
d186 1
a186 1
			(char *)0, 0 );
d214 1
a214 1
			(char *)0, "", (char *)0, 0 );
@


10.3
log
@New data structures
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 10.2 92/05/29 00:58:57 mike Exp Locker: mike $ (BRL)";
d23 2
@


10.2
log
@Modified to track NURB data structure changes
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 10.1 91/10/12 06:44:43 mike Rel4_0 Locker: mike $ (BRL)";
d275 1
a275 1
	meshp = bp->mesh.ctl_points;
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 9.6 91/07/01 22:48:27 mike Exp $ (BRL)";
d250 1
a250 1
		MAKE_PT_TYPE(4,2,1));
d254 1
a254 1
		bp->u_knots->knots[i] = circle_knots[i];
d260 1
a260 1
		bp->v_knots->knots[nv++] = cur_kv;
d263 1
a263 1
		bp->v_knots->knots[nv++] = cur_kv++;
d265 1
a265 1
		bp->v_knots->knots[nv++] = cur_kv;
d275 1
a275 1
	meshp = bp->mesh->ctl_points;
@


9.6
log
@ANSI lint
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 9.5 91/06/14 10:13:17 stay Exp $ (BRL)";
@


9.5
log
@changed to nwe spline library and defines.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 9.4 90/12/08 06:16:18 mike Exp $ (BRL)";
d31 1
a31 3
#include "wdb.h"			/* after b_spline.h */

extern struct snurb * rt_nurb_new_snurb();
@


9.4
log
@lint
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 9.3 90/11/01 05:15:19 mike Exp $ (BRL)";
d30 1
a30 1
#include "../libspl/b_spline.h"
d33 1
a33 1
extern struct b_spline *spl_new();
d230 1
a230 1
	struct b_spline *bp;
d249 1
a249 1
	bp = spl_new( 3,	4,		/* u,v order */
d252 1
a252 1
		P4 );
d256 1
a256 1
		bp->u_kv->knots[i] = circle_knots[i];
d262 1
a262 1
		bp->v_kv->knots[nv++] = cur_kv;
d265 1
a265 1
		bp->v_kv->knots[nv++] = cur_kv++;
d267 1
a267 1
		bp->v_kv->knots[nv++] = cur_kv;
d277 1
a277 1
	meshp = bp->ctl_mesh->mesh;
d312 1
a312 1
	spl_sfree( bp );
@


9.3
log
@Changed calling sequence to mk_addmember().  Added boolean op as 3rd arg.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 9.2 90/10/16 11:18:26 mike Exp $ (BRL)";
a29 2
#include "wdb.h"

d31 1
d214 1
a214 2
			(char *)0, "",
			0, (char *)0, &ghead );
d323 1
a323 1
	double	dx;
@


9.2
log
@Changed to using rtlist.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/proc-db/RCS/tube.c,v 9.1 89/05/19 06:04:56 mike Rel3_5 $ (BRL)";
d130 1
a130 1
	(void)mk_addmember( "bg.s", &head );	/* temp use of "head" */
d176 1
a176 1
		(void)mk_addmember( name, &head );
d180 1
a180 1
		mk_addmember( name, &head )->wm_op = SUBTRACT;
d182 1
a182 1
		mk_addmember( "cut", &head )->wm_op = SUBTRACT;
d193 2
a194 2
		mk_addmember( name, &ghead );
		matp = mk_addmember( "ke", &ghead )->wm_mat;
d210 2
a211 2
		(void)mk_addmember( "light.r", &ghead );
		(void)mk_addmember( "bg.r", &ghead );
d467 1
a467 1
		(void)mk_addmember( name, &head );
@


9.1
log
@Release_3.5
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tube.c,v 8.2 89/04/30 21:37:58 mike Exp $ (BRL)";
d29 1
d118 2
a119 2
	head.wm_forw = head.wm_back = &head;
	ghead.wm_forw = ghead.wm_back = &ghead;
d457 1
a457 1
	head.wm_forw = head.wm_back = &head;
@


8.2
log
@No longer requires mathtab.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tube.c,v 8.1 88/10/05 00:38:30 mike Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tube.c,v 1.15 88/08/20 07:26:44 phil Exp $ (BRL)";
a31 1
#include "../rt/mathtab.h"
@


1.15
log
@libwdb changes
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tube.c,v 1.14 88/05/15 23:00:20 phil Locked $ (BRL)";
@


1.14
log
@lint fixes
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tube.c,v 1.13 88/01/16 07:53:05 mike Locked $ (BRL)";
d127 1
a127 1
	mk_half( stdout, "cut", 0.0, normal );
d129 1
a129 1
	mk_half( stdout, "bg.s", -1000.0, normal );
d131 1
a131 1
	mk_lcomb( stdout, "bg.r", 1,
d133 1
a133 1
		0, (char *)0, &head );
d185 1
a185 1
		mk_lcomb( stdout, name, 1,
d187 1
a187 1
			0, (char *)0, &head );
d214 1
a214 1
		mk_lcomb( stdout, gname, 0,
d469 1
a469 4
	mk_lcomb( stdout, cname, 0,
		(char *)0, "",
		0, (char *)0,
		&head );
@


1.13
log
@Added fflush() calls before atting ammo database onto the end.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tube.c,v 1.3 87/12/30 17:47:40 mike Exp $ (BRL)";
d40 2
d226 1
d318 1
d425 1
d446 1
d479 1
@


1.12
log
@Added support for reading tube displacement data in Kurt/Kathy
format, on stdin.
Various parts of the code have intimate knowledge of the
geometry involved, but for now it gets the job done.
@
text
@d218 1
@


1.11
log
@Changed to read Kurt's projectile position data
@
text
@d64 24
d92 1
d96 2
a97 2
int	nframes = 64;
double	delta_t = 0.15;		/* ms/step */
a107 1
	double	iradius, oradius;
a142 1
	fprintf(stderr,"nframes=%d\n", nframes);
d149 1
d199 2
a200 1
		xfinddir( to, projectile_pos, offset );
d218 2
d319 2
d325 2
d328 2
a329 2
		if( fgets( buf, sizeof(buf), fp ) == NULL )  break;
		if( buf[0] == '\0' )  {
d343 1
a343 1
			fprintf("input line didn't have 3 numbers: %s\n", buf);
d351 64
a414 1
	if( nsamples <= 0 )
d416 2
a417 1
	return(0);
d431 3
a434 1
fprintf(stderr,"t=%g, p=%g\n", last_read_time, projectile_pos);
d485 8
a492 3
		VSUB2( dir, sample[i+1], sample[i] );
		ratio = (x-sample[i][X]) / (sample[i+1][X]-sample[i][X]);
		VJOIN1( loc, sample[i], ratio, dir );
d494 2
a495 5
		VUNITIZE( dir );
		return;
	}
	fprintf(stderr, "xfinddir: couldn't find x=%g\n", x);
	VSET( dir, 1, 0, 0 );
@


1.10
log
@Made it easier to change the number of frames (you have to know how many).
@
text
@d64 1
d71 4
a74 1
int	nframes = 300;
a88 1
	fastf_t	pos;
d95 2
a96 1
	mk_id( stdout, "Spline Tube" );
d98 2
d101 7
a107 1
	mk_half( stdout, "cut", 0, normal );
d129 1
d140 5
a145 1
		if( read_frame() < 0 )  break;
a168 2
		pos = ((double)frame)/nframes *
			(sample[nsamples-1][X] - sample[0][X]); /* length */
d175 1
a175 1
		xfinddir( to, pos, offset );
d184 2
d287 2
a288 1
read_frame()
d293 1
a293 1
	if( feof(stdin) )
d297 1
a297 1
		if( fgets( buf, sizeof(buf), stdin ) == NULL )  break;
d323 18
@


1.9
log
@Added reference to "ke" and rotation/translation animation
appropriate for a bullet traveling up the tube at constant
velocity.  Also added references to "light.r" for each frame.
@
text
@d70 2
d107 1
d152 1
a152 1
		pos = ((double)frame)/64 *	/* XXX hack: nframes */
@


1.8
log
@Change of strategy -- now using TGCs for each segment, rather than
splines, as an efficiency measure.
@
text
@d76 1
d79 7
a85 1
	struct wmember head;
d88 1
d95 2
d99 5
d105 2
a107 1
	length = 187 * inches2mm;
d142 29
d330 28
@


1.7
log
@This version reads animation data from Phil's program on stdin
@
text
@d111 1
d124 1
a124 1
			"testmap", "",
d129 1
d259 2
a260 2
build_cyl( name, npts, radius )
char	*name;
d265 20
@


1.6
log
@Added gun bore, by subtracting out inside.
Also added cutting plane.
@
text
@d65 1
a72 1
	int	npts;
d89 2
d93 1
a93 2
	npts = ceil(length/spacing);
	fprintf(stderr,"inner radius=%gmm, outer radius=%gmm\n", iradius, oradius);
d95 1
d97 2
a98 1
	for( frame=0; frame<16; frame++ )  {
d100 2
a101 1
		for( i=0; i<npts; i++ )  {
d105 1
a105 1
				((double)i*i)/npts * 2 * 3.14159265358979323 +
d108 2
d112 1
a112 1
		build_spline( name, npts, oradius );
d116 1
a116 1
		build_spline( name, npts, iradius );
d125 1
d217 46
@


1.5
log
@Multiple frames
@
text
@a65 1
double	radius;
d76 3
d80 2
d84 5
a88 1
	radius = 5 * inches2mm / 2;	/* 5" diameter */
d92 2
a93 1
	fprintf(stderr,"radius=%gmm, length=%gmm, spacing=%gmm\n", radius, length, spacing);
d100 1
a100 1
			sample[i][Z] = 4 * radius * sin(
d105 10
d116 3
a118 1
		build_spline( name, npts );
d122 1
a122 1
build_spline( name, npts )
d125 1
@


1.4
log
@Version that generates amazingly curvaceous tubes which
successfully raytrace.
@
text
@a72 1
	struct b_spline *bp;
d75 2
a76 6
	int	nv;
	int	cur_kv;
	fastf_t	*meshp;
	register int col;
	int	row;
	vect_t	point;
d78 2
d86 12
a97 6
	/* Generate some dummy sample data */
	for( i=0; i<npts; i++ )  {
		sample[i][X] = i * spacing;
		sample[i][Y] = 0;
		sample[i][Z] = 4 * radius * sin(
			((double)i*i)/npts * 2 * 3.14159265358979323 );
d99 1
d101 13
d185 1
a185 2
	mk_id( stdout, "Spline Tube" );
	mk_bsolid( stdout, "tube", 1, 0.1 );
d187 1
@


1.3
log
@Scaling change from Paul Stay
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tube.c,v 1.1 87/12/30 04:43:27 mike Exp $ (BRL)";
d37 2
a38 1
double degtorad = 0.0174532925199433;
a48 1
#define MPY	100
d51 1
d53 9
a61 9
	0,	MPY,		0,		1,
	0,	IRT2*MPY,	IRT2*MPY,	IRT2,
	0,	0,		MPY,		1,
	0,	-IRT2*MPY,	IRT2*MPY,	IRT2,
	0,	-MPY,		0,		1,
	0,	-IRT2*MPY,	-IRT2*MPY,	IRT2,
	0,	0,		-MPY,		1,
	0,	IRT2*MPY,	-IRT2*MPY,	IRT2,
	0,	MPY,		0,		1
d64 6
d74 1
a74 1
	int	npts = 4;
d83 14
d139 3
a141 3
		*meshp++ = 0;	/* firstx; */
		*meshp++ = 0;
		*meshp++ = 0;
d147 2
a148 2
		row = i;
		VSET( point, row * MPY, 0, 0 );
d151 1
d153 3
a155 3
			*meshp++ = poly[col*4+X] + point[X]*h;
			*meshp++ = poly[col*4+Y] + point[Y]*h;
			*meshp++ = poly[col*4+Z] + point[Z]*h;
d162 3
a164 3
		*meshp++ = row * MPY;		/* lastx; */
		*meshp++ = 0;
		*meshp++ = 0;
a167 2
rt_pr_spl("Ta Da!", bp);

@


1.2
log
@First fixes from Paul Stay
@
text
@d48 1
d52 9
a60 9
	0,	1,	0,	1,
	0,	IRT2,	IRT2,	IRT2,
	0,	0,	1,	1,
	0,	-IRT2,	IRT2,	IRT2,
	0,	-1,	0,	1,
	0,	-IRT2,	-IRT2,	IRT2,
	0,	0,	-1,	1,
	0,	IRT2,	-IRT2,	IRT2,
	0,	1,	0,	1
d101 1
a101 1
	for( i=4; i<(npts+4-1); i++ )
d127 1
a127 1
		VSET( point, row, 0, 0 );
d140 1
a140 1
		*meshp++ = row;		/* lastx; */
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: clutter.c,v 1.7 87/10/30 15:34:11 mike Exp $ (BRL)";
d97 1
a97 1
	for( i=0; i<3; i++ )
d100 1
a100 1
	for( i=0; i<npts; i++ )
d102 1
a102 1
	for( i=0; i<3; i++ )
@
