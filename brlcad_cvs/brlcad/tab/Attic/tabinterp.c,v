head	11.11;
access;
symbols
	ansi-20040405-merged:11.8.4.1
	postmerge-20040405-ansi:11.9
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.8.12.2
	premerge-autoconf:11.9
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.8.6.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.12
	phong-branch:11.8.0.10
	photonmap-branch:11.8.0.8
	rel-6-1-DP:11.8
	windows-branch:11.8.0.6
	rel-6-0-2:11.8
	ansi-branch:11.8.0.4
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.8
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.6
	offsite-5-3-pre:11.8
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.6
	rel-5-0-beta:11.6
	rel-4-5:11.4
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:1.12;
locks; strict;
comment	@ * @;


11.11
date	2004.05.21.16.43.12;	author morrison;	state dead;
branches;
next	11.10;

11.10
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	11.9;

11.9
date	2004.02.02.17.39.42;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2000.10.24.19.41.47;	author mike;	state Exp;
branches
	11.8.4.1
	11.8.6.1
	11.8.12.1;
next	11.7;

11.7
date	2000.08.24.23.01.01;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.05.21.05.02.28;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.02.09.16.05.29;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.07.17.14.43.08;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	96.06.11.21.14.36;	author cnuzman;	state Exp;
branches;
next	11.2;

11.2
date	96.01.23.16.06.58;	author cnuzman;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.19.30;	author mike;	state Rel4_4;
branches;
next	10.11;

10.11
date	94.11.14.23.23.12;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.09.23.19.02.41;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.08.11.18.04.22;	author gdurf;	state Exp;
branches;
next	10.8;

10.8
date	94.08.03.19.18.27;	author cnuzman;	state Exp;
branches;
next	10.7;

10.7
date	93.10.26.03.35.13;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.10.26.03.31.39;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	93.10.26.03.19.58;	author jgrosh;	state Exp;
branches;
next	10.4;

10.4
date	92.11.19.22.34.55;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.08.28.01.32.28;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.08.27.22.48.29;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.51.21;	author mike;	state Rel4_0;
branches;
next	1.19;

1.19
date	91.07.02.04.27.30;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	90.11.27.21.39.46;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	90.11.03.21.51.26;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	90.11.03.20.58.17;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	90.11.03.18.48.02;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	89.10.10.15.49.41;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	89.08.12.00.40.13;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	89.01.09.05.18.02;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	89.01.07.02.28.42;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	89.01.02.07.04.13;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	89.01.02.03.23.51;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	89.01.02.03.17.35;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	89.01.02.02.17.39;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	89.01.02.01.48.39;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	89.01.01.23.48.20;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	89.01.01.23.12.50;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	88.12.31.07.02.49;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.12.30.09.00.52;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.12.30.08.51.42;	author mike;	state Exp;
branches;
next	;

11.8.4.1
date	2004.03.17.21.23.03;	author morrison;	state Exp;
branches;
next	;

11.8.6.1
date	2004.03.11.23.48.35;	author morrison;	state Exp;
branches;
next	;

11.8.12.1
date	2004.02.12.19.42.56;	author erikg;	state Exp;
branches;
next	11.8.12.2;

11.8.12.2
date	2004.03.15.14.08.09;	author erikg;	state Exp;
branches;
next	;


desc
@Table interpolator
@


11.11
log
@moved to src/tab/
@
text
@/*
 *			T A B I N T E R P . C
 *
 *  This program is the crucial middle step in the key-frame animation
 *  software.
 *
 *  First, one or more files, on different time scales, are read into
 *  internal "channels", with FILE and RATE commands.
 *
 *  Next, the TIMES command is given.
 *
 *  Next, a section of those times is interpolated, and
 *  multi-channel output is produced, on uniform time samples.
 *
 *  This multi-channel output is fed to the next stage to generate
 *  control scripts, etc.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/tab/tabinterp.c,v 11.10 2004/05/10 15:30:50 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"

#include "../librt/debug.h"

struct chan {
	/* INPUTS */
	int	c_ilen;		/* length of input array */
	char	*c_itag;	/* description of input source */
	fastf_t	*c_itime;	/* input time array */
	fastf_t	*c_ival;	/* input value array */
	/* OUTPUTS */
	fastf_t	*c_oval;	/* output value array */
	/* FLAGS */
	int	c_interp;	/* linear or spline? */
#define INTERP_STEP	1
#define	INTERP_LINEAR	2
#define	INTERP_SPLINE	3
#define INTERP_RATE	4
#define INTERP_ACCEL	5
#define	INTERP_QUAT	6	/* first chan of 4 that define a quaternion */
#define INTERP_QUAT2	7	/* an additional quaterion chan (2,3,4) */
#define INTERP_NEXT	8	/* method to look forward/backward in time */
	int	c_periodic;	/* cyclic end conditions? */
	int	c_sourcechan;	/* index of source chan (QUAT, NEXT) */
	int	c_offset;	/* source offset (NEXT) */
};

extern int optind;
extern char *optarg;

int		verbose = 1;

int		o_len;		/* length of all output arrays */
fastf_t		*o_time;	/* pointer to output time array */
int		fps;		/* frames/sec of output */

int		nchans;		/* number of chan[] elements in use */
int		max_chans;	/* current size of chan[] array */
struct chan	*chan;		/* ptr to array of chan structs */

extern int	cm_file();
extern int	cm_times();
extern int	cm_interp();
extern int	cm_idump();
extern int	cm_rate();
extern int	cm_accel();
extern int	cm_next();
extern int	cm_help();

void		linear_interpolate();
void		rate_interpolate();
void		accel_interpolate();
void		go();
void		output();
void		pr_ichan();
void		next_interpolate();
void		step_interpolate();
void		quat_interpolate();
int get_args(int argc, char **argv);
int create_chan( char *num, int len, char *itag );
int chan_not_loaded_or_specified( int ch );
int spline( struct chan *chp, fastf_t *times );


struct command_tab cmdtab[] = {
	{"file", "filename chan_num(s)", "load channels from file",
		cm_file,	3, 999},
	{"times", "start stop fps", "specify time range and fps rate",
		cm_times,	4, 4},
	{"interp", "{step|linear|spline|cspline|quat} chan_num(s)", "set interpolation type",
		cm_interp,	3, 999},
	{"next", "dest_chan src_chan [+/- #nsamp]", "lookahead in time",
		cm_next,	3, 4},
	{"idump", "[chan_num(s)]", "dump input channel values",
		cm_idump,	1, 999},
	{"rate", "chan_num init_value incr_per_sec [comment]", "create rate based channel",
		cm_rate,	4, 5},
	{"accel", "chan_num init_value mult_per_sec [comment]", "create acceleration based channel",
		cm_accel,	4, 5},
	{"help", "", "print help message",
		cm_help,	1, 999},
	{(char *)0, (char *)0, (char *)0,
		0,		0, 0}	/* END */
};


/*
 *			M A I N
 */
int
main( argc, argv )
int	argc;
char	**argv;
{
	register char	*buf;
	register int	ret;

	get_args(argc,argv);
	/*
	 * All the work happens in the functions
	 * called by rt_do_cmd().
	 * NOTE that the value of MAXWORDS in rt_do_cmd() limits
	 * the maximum number of columns that a 'file' command can list.
	 */
	while( (buf = rt_read_cmd( stdin )) != (char *)0 )  {
		if(verbose) bu_log("cmd: %s\n", buf );
		ret = rt_do_cmd( 0, buf, cmdtab );
		bu_free( buf, "cmd buf" );
		if( ret < 0 )  {
			if(verbose) bu_log("aborting\n");
			exit(1);
		}
	}

	if(verbose) bu_log("performing interpolations\n");
	go();

	if(verbose) bu_log("writing output\n");
	output();

	exit(0);	
}

/*
 *   XXX this really should go in librt/cmd.c as rt_help_cmd().
 */
int
cm_help( argc, argv )
int	argc;
char	**argv;
{
	register struct command_tab	*ctp;

	if( argc <= 1 )
	{
		bu_log("The following commands are available:\n\n");
		for( ctp = cmdtab; ctp->ct_cmd != (char *)0; ctp++ )  {
			bu_log("%s %s\n\t%s\n",
				ctp->ct_cmd, ctp->ct_parms,
				ctp->ct_comment );
		}
		return 0;
	}
	bu_log("Detailed help is not yet available.\n");
	return -1;
}

/*
 *			C M _ F I L E
 */
int
cm_file( argc, argv )
int	argc;
char	**argv;
{
	FILE	*fp;
	char	*file;
	char	lbuf[512];	/* temporary label buffer */
	int	*cnum;
	int	i;
	int	line;
	char	**iwords;
	int	nlines;		/* number of lines in input file */
	int	nwords;		/* number of words on each input line */
	fastf_t	*times;
	auto double	d;
	int	errors = 0;
	struct bu_vls	buf;	/* unlimited size input line buffer */

	file = argv[1];
	if( (fp = fopen( file, "r" )) == NULL )  {
		perror( file );
		return(0);
	}

	/* First step, count number of lines in file */
	nlines = 0;
	{
		register int	c;

		while( (c = fgetc(fp)) != EOF )  {
			if( c == '\n' )
				nlines++;
		}
	}
	rewind(fp);

	/* Intermediate dynamic memory */

	cnum = (int *)bu_malloc( argc * sizeof(int), "cnum[]");
	nwords = argc - 1;
	iwords = (char **)bu_malloc( (nwords+1) * sizeof(char *), "iwords[]" );
	bu_vls_init(&buf);

	/* Retained dynamic memory */
	times = (fastf_t *)bu_malloc( nlines * sizeof(fastf_t), "times");

	/* Now, create & allocate memory for each chan */
	for( i = 1; i < nwords; i++ )  {
		/* See if this column is not wanted */
		if( argv[i+1][0] == '-' )  {
			cnum[i] = -1;
			continue;
		}

		sprintf( lbuf, "File '%s', Column %d", file, i );
		if( (cnum[i] = create_chan( argv[i+1], nlines, lbuf )) < 0 )  {
			errors = 1;
			goto out;
		}
		/* Share array of times */
		chan[cnum[i]].c_itime = times;
	}

	for( line=0; line < nlines; line++ )  {
		register char *bp;

		bu_vls_trunc( &buf, 0 );
		if( bu_vls_gets( &buf, fp ) == -1 )  break;
		bp = bu_vls_addr(&buf);

		if( bp[0] == '#' )  {
			line--;
			nlines--;
			for( i = 1; i < nwords; i++ )  {
				if( cnum[i] < 0 )  continue;
				chan[cnum[i]].c_ilen--;
			}
			continue;
		}

		i = rt_split_cmd( iwords, nwords+1, bp );

		if( i != nwords )  {
			bu_log("File '%s', Line %d:  expected %d columns, got %d\n",
				file, line, nwords, i );
			while( i < nwords )  {
				iwords[i++] = "0.123456789";
				errors++;
			}
		}

		/* Obtain the time from the first column */
		sscanf( iwords[0], "%lf", &d );
		times[line] = d;
		if( line > 0 && times[line-1] > times[line] )  {
			bu_log("File '%s', Line %d:  time sequence error %g > %g\n",
		    		file, line, times[line-1], times[line] );
			errors++;
		}

		/* Obtain the desired values from the remaining columns,
		 * and assign them to the channels indicated in cnum[]
		 */
		for( i=1; i < nwords; i++ )  {
			if( cnum[i] < 0 )  continue;
			if( sscanf( iwords[i], "%lf", &d ) != 1 )  {
				bu_log("File '%s', Line %d:  scanf failure on '%s'\n",
			    		file, line, iwords[i] );
				d = 0.0;
				errors++;
			}
		    	chan[cnum[i]].c_ival[line] = d;
		}
	}
	fclose(fp);

	/* Free intermediate dynamic memory */
out:
	bu_free( (char *)cnum, "cnum[]");
	bu_free( (char *)iwords, "iwords[]");
	bu_vls_free(&buf);

	if(errors)
		return(-1);	/* abort */
	return(0);
}

/*
 *			C R E A T E _ C H A N
 */
int
create_chan( char *num, int len, char *itag )
{
	int	n;

	n = atoi(num);
	if( n < 0 )  return(-1);

	if( n >= max_chans )  {
		int	prev = max_chans;

		if( max_chans <= 0 )  {
			max_chans = 32;
			chan = (struct chan *)bu_calloc( 1, 
				max_chans * sizeof(struct chan),
				"chan[]" );
		} else {
			while( n >= max_chans )
				max_chans *= 2;
			if(verbose) bu_log("reallocating from %d to %d chans\n",
				prev, max_chans);
			chan = (struct chan *)bu_realloc( (char *)chan,
				max_chans * sizeof(struct chan),
				"chan[]" );
			bzero( (char *)(&chan[prev]),
				(max_chans-prev)*sizeof(struct chan) );
		}
	}
	/* Allocate and clear channels */
	while( nchans <= n )  {
		if( chan[nchans].c_ilen > 0 ) {
			bu_log("create_chan: internal error\n");
			return -1;
		} else {
			bzero( (char *)&chan[nchans++], sizeof(struct chan) );
		}
	}

	if(verbose) bu_log("chan %d:  %s\n", n, itag );
	chan[n].c_ilen = len;
	chan[n].c_itag = bu_strdup( itag );
	chan[n].c_ival = (fastf_t *)bu_malloc( len * sizeof(fastf_t), "c_ival");
	return(n);
}

/*
 *			C M _ I D U M P
 *
 *  Dump the indicated input channels, or all, if none specified.
 */
int
cm_idump( argc, argv )
int	argc;
char	**argv;
{
	register int	ch;
	register int	i;

	if( argc <= 1 )  {
		for( ch=0; ch < nchans; ch++ )  {
			pr_ichan( ch );
		}
	} else {
		for( i = 1; i < argc; i++ )  {
			pr_ichan( atoi( argv[i] ) );
		}
	}
	return(0);
}

/*
 *			P R _ I C H A N S
 *
 *  Print input channel values.
 */
void
pr_ichan( ch )
register int		ch;
{
	register struct chan	*cp;
	register int		i;

	if( ch < 0 || ch >= nchans )  {
		bu_log("pr_ichan(%d) out of range\n", ch );
		return;
	}
	cp = &chan[ch];
	if( cp->c_itag == (char *)0 )  cp->c_itag = "_no_file_";
	bu_log("--- Channel %d, ilen=%d (%s):\n",
		ch, cp->c_ilen, cp->c_itag );
	for( i=0; i < cp->c_ilen; i++ )  {
		bu_log(" %g\t%g\n", cp->c_itime[i], cp->c_ival[i]);
	}
}

/*
 *			O U T P U T
 */
void
output()
{
	register int		ch;
	register struct chan	*cp;
	register int		t;

	if( !o_time )  {
		bu_log("times command not given, aborting\n");
		return;
	}

	for( t=0; t < o_len; t++ )  {
		printf("%g", o_time[t]);

		for( ch=0; ch < nchans; ch++ )  {
			cp = &chan[ch];
			if( cp->c_ilen <= 0 )  {
				printf("\t.");
				continue;
			}
			printf("\t%g", cp->c_oval[t] );
		}
		printf("\n");
	}
}

/*
 *			C M _ T I M E S
 */
int
cm_times( argc, argv )
int	argc;
char	**argv;
{
	double		a, b;
	register int	i;

	a = atof(argv[1]);
	b = atof(argv[2]);
	fps = atoi(argv[3]);

	if( a >= b )  {
		bu_log("times:  %g >= %g\n", a, b );
		return(0);
	}
	if( o_len > 0 )  {
		bu_log("times:  already specified\n");
		return(0);	/* ignore */
	}
	o_len = ((b-a) * fps) + 0.999;
	o_len++;	/* one final step to reach endpoint */
	o_time = (fastf_t *)bu_malloc( o_len * sizeof(fastf_t), "o_time[]");

	/*
	 *  Don't use an incremental algorithm, to avoid acrueing error
	 */
	for( i=0; i<o_len; i++ )
		o_time[i] = a + ((double)i)/fps;


	return(0);
}

/*
 *			C M _ I N T E R P
 */
int
cm_interp( argc, argv )
int	argc;
char	**argv;
{
	int	interp = 0;
	int	periodic = 0;
	int	i;
	int	ch;
	struct chan	*chp;

	if( strcmp( argv[1], "step" ) == 0 )  {
		interp = INTERP_STEP;
		periodic = 0;
	} else if( strcmp( argv[1], "cstep" ) == 0 )  {
		interp = INTERP_STEP;
		periodic = 1;
	} else if( strcmp( argv[1], "linear" ) == 0 )  {
		interp = INTERP_LINEAR;
		periodic = 0;
	} else if( strcmp( argv[1], "clinear" ) == 0 )  {
		interp = INTERP_LINEAR;
		periodic = 1;
	} else if( strcmp( argv[1], "spline" ) == 0 )  {
		interp = INTERP_SPLINE;
		periodic = 0;
	} else if( strcmp( argv[1], "cspline" ) == 0 )  {
		interp = INTERP_SPLINE;
		periodic = 1;
	} else if( strcmp( argv[1], "quat" ) == 0 )  {
		interp = INTERP_QUAT;
		periodic = 0;
	} else {
		bu_log("interpolation type '%s' unknown\n", argv[1] );
		interp = INTERP_LINEAR;
	}

	for( i = 2; i < argc; i++ )  {
		ch = atoi( argv[i] );
		chp = &chan[ch];
		if( chan_not_loaded_or_specified(ch) )  continue;
		chp->c_interp = interp;
		chp->c_periodic = periodic;
		if( interp == INTERP_QUAT )  {
			int	j;
			for( j = 1; j < 4; j++ )  {
				chp = &chan[ch+j];
				if( chan_not_loaded_or_specified(ch+j) )  continue;
				chp->c_interp = INTERP_QUAT2;
				chp->c_periodic = periodic;
				chp->c_sourcechan = ch;
			}
		}
	}
	return(0);
}


/*
 *			G O
 *
 *  Perform the requested interpolation on each channel
 */
void
go()
{
	int	ch;
	struct chan	*chp;
	fastf_t		*times;
	register int	t;

	if( !o_time )  {
		bu_log("times command not given\n");
		return;
	}

	times = (fastf_t *)bu_malloc( o_len*sizeof(fastf_t), "periodic times");

	/* First, get memory for all output channels */
	for( ch=0; ch < nchans; ch++ )  {
		chp = &chan[ch];
		if( chp->c_ilen <= 0 )
			continue;

		/* Allocate memory for all the output values */
		chan[ch].c_oval = (fastf_t *)bu_malloc(
			o_len * sizeof(fastf_t), "c_oval[]");
	}

	/* Interpolate values for all "interp" channels */
	for( ch=0; ch < nchans; ch++ )  {
		chp = &chan[ch];
		if( chp->c_ilen <= 0 )
			continue;
		if( chp->c_interp == INTERP_NEXT )  continue;

		/*  As a service to interpolators, if this is a periodic
		 *  interpolation, build the mapped time array.
		 */
		if( chp->c_periodic )  {
			for( t=0; t < o_len; t++ )  {
				register double	cur_t;

				cur_t = o_time[t];

				while( cur_t > chp->c_itime[chp->c_ilen-1] )  {
					cur_t -= (chp->c_itime[chp->c_ilen-1] -
					    chp->c_itime[0] );
				}
				while( cur_t < chp->c_itime[0] )  {
					cur_t += (chp->c_itime[chp->c_ilen-1] -
					    chp->c_itime[0] );
				}
				times[t] = cur_t;
			}
		} else {
			for( t=0; t < o_len; t++ )  {
				times[t] = o_time[t];
			}
		}
again:
		switch( chp->c_interp )  {
		default:
			bu_log("channel %d: unknown interpolation type %d\n", ch, chp->c_interp);
			break;
		case INTERP_LINEAR:
			linear_interpolate( chp, times );
			break;
		case INTERP_STEP:
			step_interpolate( chp, times );
			break;
		case INTERP_SPLINE:
			if( spline( chp, times ) <= 0 )  {
				bu_log("spline failure, switching to linear\n");
				chp->c_interp = INTERP_LINEAR;
				goto again;
			}
			break;
		case INTERP_RATE:
			rate_interpolate( chp, times );
			break;
		case INTERP_ACCEL:
			accel_interpolate( chp, times );
			break;
		case INTERP_QUAT:
			quat_interpolate( chp, &chan[ch+1], &chan[ch+2], &chan[ch+3], times );
			break;
		case INTERP_QUAT2:
			/* Don't touch these here, handled above */
			continue;
		}
	}

	/* Copy out values for all "next" channels */
	for( ch=0; ch < nchans; ch++ )  {
		chp = &chan[ch];
		if( chp->c_ilen <= 0 )
			continue;
		if( chp->c_interp != INTERP_NEXT )  continue;
		next_interpolate( chp );
	}

	bu_free( (char *)times, "loc times");
}

/*
 *			N E X T _ I N T E R P O L A T E
 */
void
next_interpolate( chp )
register struct chan	*chp;
{
	register int	t;		/* output time index */
	register int	i;		/* input time index */
	register struct chan	*ip;

	ip = &chan[chp->c_sourcechan];

	for( t=0; t<o_len; t++ )  {
		i = t + chp->c_offset;
		if( i <= 0 )  {
			chp->c_oval[t] = ip->c_oval[0];
			continue;
		}
		if( i >= o_len )  {
			chp->c_oval[t] = ip->c_oval[o_len-1];
			continue;
		}
		chp->c_oval[t] = ip->c_oval[i];
	}
}

/*
 *			S T E P _ I N T E R P O L A T E
 *
 *  Simply select the value at the beinning of the interval.
 *  This allows parameters to take instantaneous jumps in value
 *  at specified times.
 *
 *  This routine takes advantage of (and depends on) the fact that
 *  the input and output is sorted in increasing time values.
 */
void
step_interpolate( chp, times )
register struct chan	*chp;
register fastf_t	*times;
{
	register int	t;		/* output time index */
	register int	i;		/* input time index */

	i = 0;
	for( t=0; t<o_len; t++ )  {
		/* Check for below initial time */
		if( times[t] < chp->c_itime[0] )  {
			chp->c_oval[t] = chp->c_ival[0];
			continue;
		}

		/* Find time range in input data. */
		while( i < chp->c_ilen-1 )  {
			if( times[t] >= chp->c_itime[i] && 
			    times[t] <  chp->c_itime[i+1] )
				break;
			i++;
		}

		/* Check for above final time */
		if( i >= chp->c_ilen-1 )  {
			chp->c_oval[t] = chp->c_ival[chp->c_ilen-1];
			continue;
		}

		/* Select value at beginning of interval */
		chp->c_oval[t] = chp->c_ival[i];
	}
}

/*
 *			L I N E A R _ I N T E R P O L A T E
 *
 *  This routine takes advantage of (and depends on) the fact that
 *  the input and output arrays are sorted in increasing time values.
 */
void
linear_interpolate( chp, times )
register struct chan	*chp;
register fastf_t	*times;
{
	register int	t;		/* output time index */
	register int	i;		/* input time index */

	if( chp->c_ilen < 2 )  {
		bu_log("lienar_interpolate:  need at least 2 points\n");
		return;
	}

	i = 0;
	for( t=0; t<o_len; t++ )  {
		/* Check for below initial time */
		if( times[t] < chp->c_itime[0] )  {
			chp->c_oval[t] = chp->c_ival[0];
			continue;
		}

		/* Find time range in input data. */
		while( i < chp->c_ilen-1 )  {
			if( times[t] >= chp->c_itime[i] && 
			    times[t] <  chp->c_itime[i+1] )
				break;
			i++;
		}

		/* Check for above final time */
		if( i >= chp->c_ilen-1 )  {
			chp->c_oval[t] = chp->c_ival[chp->c_ilen-1];
			continue;
		}

		/* Perform actual interpolation */
		chp->c_oval[t] = chp->c_ival[i] +
			(times[t] - chp->c_itime[i]) *
			(chp->c_ival[i+1] - chp->c_ival[i]) /
			(chp->c_itime[i+1] - chp->c_itime[i]);
	}
}

/*
 *			R A T E _ I N T E R P O L A T E
 *
 *  The one (and only) input value is interpreted as rate, in
 *  unspecified units per second.
 *  This is really just a hack to allow multiplying the time by a constant.
 */
void
rate_interpolate( chp, times )
register struct chan	*chp;
register fastf_t	*times;
{
	register int	t;		/* output time index */
	register double	ival;
	register double	rate;

	if( chp->c_ilen != 2 )  {
		bu_log("rate_interpolate:  only 2 points (ival & rate) may be specified\n");
		return;
	}
	ival = chp->c_ival[0];
	rate = chp->c_ival[1];

	for( t=0; t < o_len; t++ )  {
		chp->c_oval[t] = ival + rate * times[t];
	}
}

/*
 *			A C C E L _ I N T E R P O L A T E
 *
 */
void
accel_interpolate( chp, times )
register struct chan	*chp;
register fastf_t	*times;
{
	register int	t;		/* output time index */
	double	ival;
	double	mul;
	register double scale;

	if( chp->c_ilen != 2 )  {
		bu_log("accel_interpolate:  only 2 points (ival & mul) may be specified\n");
		return;
	}
	ival = chp->c_ival[0];
	mul = chp->c_ival[1];
	/* scale ^ fps = mul */
	scale = exp( log(mul) / fps );

	chp->c_oval[0] = ival;
	for( t=1; t < o_len; t++ )  {
		chp->c_oval[t] = chp->c_oval[t-1] * scale;
	}
}

/*
 *			S P L I N E
 *
 *  Fit an interpolating spline to the data points given.
 *  Time in the independent (x) variable, and the single channel
 *  of data values is the dependent (y) variable.
 *
 *  Returns -
 *	0	bad
 *	1	OK
 */
int
spline( register struct chan *chp, fastf_t *times )
{
	double	d,s;
	double	u = 0;
	double	v = 0;
	double	hi;			/* horiz interval i-1 to i */
	double	hi1;			/* horiz interval i to i+1 */
	double	D2yi;			/* D2 of y[i] */
	double	D2yi1;			/* D2 of y[i+1] */
	double	D2yn1;			/* D2 of y[n-1] (last point) */
	double	a;
	int	end;
	double	corr;
	double	konst = 0.0;		/* derriv. at endpts, non-periodic */
	double		*diag = (double *)0;
	double		*rrr = (double *)0;
	register int	i;
	register int	t;

	if(chp->c_ilen<3) {
		bu_log("spline(%s): need at least 3 points\n", chp->c_itag);
		goto bad;
	}

	/* First, as a quick hack, do linear interpolation to fill in
	 * values off the endpoints, in non-periodic case
	 */
	if( chp->c_periodic == 0 )
		linear_interpolate( chp, times );

	if( chp->c_periodic && chp->c_ival[0] != chp->c_ival[chp->c_ilen-1] )  {
		bu_log("spline(%s): endpoints don't match, replacing final data value\n", chp->c_itag);
		chp->c_ival[chp->c_ilen-1] = chp->c_ival[0];
	}

	i = (chp->c_ilen+1)*sizeof(double);
	diag = (double *)bu_malloc((unsigned)i, "diag");
	rrr = (double *)bu_malloc((unsigned)i, "rrr");
	if( !rrr || !diag )  {
		bu_log("spline: malloc failure\n");
		goto bad;
	}

	if(chp->c_periodic) konst = 0;
	d = 1;
	rrr[0] = 0;
	s = chp->c_periodic?-1:0;
	/* triangularize */
	for( i=0; ++i < chp->c_ilen - !chp->c_periodic; )  {
		double rhs;

		hi = chp->c_itime[i]-chp->c_itime[i-1];
		hi1 = (i==chp->c_ilen-1) ?
			chp->c_itime[1] - chp->c_itime[0] :
			chp->c_itime[i+1] - chp->c_itime[i];
		if(hi1*hi<=0) {
			bu_log(
			    "spline: Horiz. interval changed sign at i=%d, time=%g\n",
			    i, chp->c_itime[i]);
			goto bad;
		}
		if( i <= 1 )  {
			u = v = 0.0;		/* First time through */
		} else {
			u = u - s * s / d;
			v = v - s * rrr[i-1] / d;
		}

		rhs = (i==chp->c_ilen-1) ?
			(chp->c_ival[1] - chp->c_ival[0]) /
			(chp->c_itime[1] - chp->c_itime[0]) :
			(chp->c_ival[i+1] - chp->c_ival[i]) /
			(chp->c_itime[i+1] - chp->c_itime[i]);
		rhs = 6 * ( rhs  -
			( (chp->c_ival[i] - chp->c_ival[i-1]) /
			(chp->c_itime[i] - chp->c_itime[i-1]) ) );

		rrr[i] = rhs - hi * rrr[i-1] / d;

		s = -hi*s/d;
		a = 2*(hi+hi1);
		if(i==1) a += konst*hi;
		if(i==chp->c_ilen-2) a += konst*hi1;
		diag[i] = d = i==1? a:
		    a - hi*hi/d; 
	}
	D2yi = D2yn1 = 0;
	/* back substitute */
	for( i = chp->c_ilen - !chp->c_periodic; --i >= 0; )  {
		end = i==chp->c_ilen-1;
		/* hi1 is range of time covered in this interval */
		hi1 = end ? chp->c_itime[1] - chp->c_itime[0]:
			chp->c_itime[i+1] - chp->c_itime[i];
		D2yi1 = D2yi;
		if(i>0){
			hi = chp->c_itime[i]-chp->c_itime[i-1];
			corr = end ? 2*s+u : 0.0;
			D2yi = (end*v+rrr[i]-hi1*D2yi1-s*D2yn1)/
				(diag[i]+corr);
			if(end) D2yn1 = D2yi;
			if(i>1){
				a = 2*(hi+hi1);
				if(i==1) a += konst*hi;
				if(i==chp->c_ilen-2) a += konst*hi1;
				d = diag[i-1];
				s = -s*d/hi; 
			}
		}
		else D2yi = D2yn1;
		if(!chp->c_periodic) {
			if(i==0) D2yi = konst*D2yi1;
			if(i==chp->c_ilen-2) D2yi1 = konst*D2yi;
		}
		if(end) continue;

		/* Sweep downward in times[], looking for times in this span */
		for( t=o_len-1; t>=0; t-- )  {
			register double	x0;	/* fraction from [i+0] */
			register double	x1;	/* fraction from [i+1] */
			register double	yy;
			register double	cur_t;

			cur_t = times[t];
			if( cur_t > chp->c_itime[i+1] )
				continue;
			if( cur_t < chp->c_itime[i] )
				continue;
			x1 = (cur_t - chp->c_itime[i]) /
			    (chp->c_itime[i+1] - chp->c_itime[i]);
			x0 = 1 - x1;
			/* Linear interpolation, with correction */
			yy = D2yi * (x0 - x0*x0*x0) + D2yi1 * (x1 - x1*x1*x1);
			yy = chp->c_ival[i] * x0 + chp->c_ival[i+1] * x1 - 
				hi1 * hi1 * yy / 6;
			chp->c_oval[t] = yy;
		}
	}
	bu_free( (char *)diag, "diag");
	bu_free( (char *)rrr, "rrr" );
	return(1);
bad:
	if(diag) bu_free( (char *)diag, "diag");
	if(rrr) bu_free( (char *)rrr, "rrr" );
	return(0);
}

/*
 *			C M _ R A T E
 *
 *  Just to communiate with the "interpolator", use two input values.
 *  First is initial value, second is change PER SECOND
 *  Input time values are meaningless.
 */
int
cm_rate( argc, argv )
int	argc;
char	**argv;
{
	register struct chan	*chp;
	int	ch;
	int	nvals = 2;

	ch = create_chan( argv[1], nvals, argc>4?argv[4]:"rate chan" );
	chp = &chan[ch];
	chp->c_interp = INTERP_RATE;
	chp->c_periodic = 0;
	chp->c_itime = (fastf_t *)bu_malloc( nvals * sizeof(fastf_t), "rate times");
	chp->c_itime[0] = chp->c_itime[1] = 0;
	chp->c_ival[0] = atof(argv[2]);
	chp->c_ival[1] = atof(argv[3]);
	return(0);
}

/*
 *			C M _ A C C E L
 *
 *  Just to communiate with the "interpolator", use two input values.
 *  First is initial value, second is change PER SECOND
 *  Input time values are meaningless.
 */
int
cm_accel( argc, argv )
int	argc;
char	**argv;
{
	register struct chan	*chp;
	int	ch;
	int	nvals = 2;

	ch = create_chan( argv[1], nvals, argc>4?argv[4]:"accel chan" );
	chp = &chan[ch];
	chp->c_interp = INTERP_ACCEL;
	chp->c_periodic = 0;
	chp->c_itime = (fastf_t *)bu_malloc( nvals * sizeof(fastf_t), "accel times");
	chp->c_itime[0] = chp->c_itime[1] = 0;
	chp->c_ival[0] = atof(argv[2]);
	chp->c_ival[1] = atof(argv[3]);
	return(0);
}

/*
 *			Q U A T _ I N T E R P O L A T E
 *
 *  Do linear interpolation for first and last span.
 *  Use Bezier interpolation for all the rest.
 *
 *  This routine depends on the four input channels having identical
 *  time stamps, because only the "x" input times are used.
 */
void
quat_interpolate( x, y, z, w, times )
struct chan	*x, *y, *z, *w;
register fastf_t	*times;
{
	register int	t;		/* output time index */
	register int	i;		/* input time index */

#define QIGET(_q,_it)  QSET( (_q), x->c_ival[(_it)], y->c_ival[(_it)], z->c_ival[(_it)], w->c_ival[(_it)] );
#define QPUT(_q)	{ x->c_oval[t] = (_q)[X]; y->c_oval[t] = (_q)[Y]; \
			z->c_oval[t] = (_q)[Z]; w->c_oval[t] = (_q)[W]; }

	i = 0;
	for( t=0; t<o_len; t++ )  {
		register fastf_t	now = times[t];

		/* Check for below initial time */
		if( now <= x->c_itime[0] )  {
			quat_t	q1;

			QIGET( q1, 0 );
			QUNITIZE( q1 );
			QPUT( q1 );
			continue;
		}

		/* Find time range in input data. */
		while( i < x->c_ilen-1 )  {
			if( now >= x->c_itime[i] && 
			    now <  x->c_itime[i+1] )
				break;
			i++;
		}

		/* Check for above final time */
		if( i >= x->c_ilen-1 )  {
			quat_t	q1;

			i = x->c_ilen-1;
			QIGET( q1, i );
			QUNITIZE( q1 );
			QPUT( q1 );
			continue;
		}

		/* Check for being in first or last time span */
		if( i == 0 || i >= x->c_ilen-2 )
		{
			fastf_t	f;
			quat_t	qout, q1, q2, q3, qtemp1, qtemp2, qtemp3;

			f = (now - x->c_itime[i]) /
			    (x->c_itime[i+1] - x->c_itime[i]);

			if (i==0)
			{
				QIGET( q1, i );
				QIGET( q2, i+1 );
				QIGET( q3, i+2);
				QUNITIZE( q1 );
				QUNITIZE( q2 );
				QUNITIZE( q3 );
				quat_make_nearest( q2, q1 );
				quat_make_nearest( q3, q2 );
			}
			else
			{
				QIGET( q1, i+1 );
				QIGET( q2, i );
				QIGET( q3, i-1 );
				f = 1.0 - f;
				QUNITIZE( q1 );
				QUNITIZE( q2 );
				QUNITIZE( q3 );
				quat_make_nearest( q2, q3 );
				quat_make_nearest( q1, q2 );
			}

			/* find middle control point */
			quat_slerp( qtemp1, q3, q2, 2.0 );
			quat_slerp( qtemp2, qtemp1, q1, 0.5 );
			quat_slerp( qtemp3, q2, qtemp2, 0.33333 );

			/* do 3-point bezier interpolation */
			quat_slerp( qtemp1, q1, qtemp3, f );
			quat_slerp( qtemp2, qtemp3, q2, f );
			quat_slerp( qout, qtemp1, qtemp2, f );

			QPUT( qout );
			continue;
		}

		/* In an intermediate time span */
		{
			fastf_t	f;
			quat_t	qout, q1, q2, q3, q4, qa, qb, qtemp1, qtemp2;

			f = (now - x->c_itime[i]) /
			    (x->c_itime[i+1] - x->c_itime[i]);

			QIGET( q1, i-1 );
			QIGET( q2, i );
			QIGET( q3, i+1 );
			QIGET( q4, i+2 );

			QUNITIZE( q1 );
			QUNITIZE( q2 );
			QUNITIZE( q3 );
			QUNITIZE( q4 );
			quat_make_nearest( q2, q1 );
			quat_make_nearest( q3, q2 );
			quat_make_nearest( q4, q3 );

			/* find two middle control points */
			quat_slerp( qtemp1, q1, q2, 2.0 );
			quat_slerp( qtemp2, qtemp1, q3, 0.5 );
			quat_slerp( qa, q2, qtemp2, 0.333333 );

			quat_slerp( qtemp1, q4, q3, 2.0 );
			quat_slerp( qtemp2, qtemp1, q2, 0.5 );
			quat_slerp( qb, q3, qtemp2, 0.333333 );
			
			quat_sberp( qout, q2, qa, qb, q3, f );
			QPUT( qout );
		}

	}
}

int
cm_next( argc, argv )
int	argc;
char	*argv[];
{
	int	ochan, ichan;
	int	offset = 1;
	char	buf[128];

	ochan = atoi(argv[1]);
	ichan = atoi(argv[2]);
	if( argc > 3 )  offset = atoi(argv[3]);
	/* If input channel not loaded, or not interpolated, error */
	if( chan[ichan].c_ilen <= 0 || chan[ichan].c_interp <= 0 )  {
		bu_log("ERROR next: ichan %d not loaded yet\n");
		return 0;
	}
	/* If output channel is loaded, error */
	if( chan[ochan].c_ilen > 0 )  {
		bu_log("ERROR next: ochan %d previous loaded\n");
		return 0;
	}
	sprintf(buf, "next: value of chan %d [%d]", ichan, offset);
	if( create_chan( argv[1], chan[ichan].c_ilen, buf ) < 0 )  {
		bu_log("ERROR next: uanble to create output channel\n");
		return 0;
	}
	/* c_ilen, c_itag, c_ival are now initialized */
	chan[ochan].c_interp = INTERP_NEXT;
	chan[ochan].c_sourcechan = ichan;
	chan[ochan].c_offset = offset;
	chan[ochan].c_periodic = 0;
	chan[ochan].c_itime = chan[ichan].c_itime;	/* share time array */
	/* c_ival[] will not be loaded with anything */
	return 0;
}

/*
 *  Returns -
 *	-1 on error
 *	 0 if data loaded, and interpolator not yet set.
 *	 1 if no data, or interpolator already set (message printed)
 */
int
chan_not_loaded_or_specified( int ch )
{
	if( ch < 0 || ch >= nchans )  return -1;
	if( chan[ch].c_ilen <= 0 )  {
		bu_log("error: attempt to set interpolation type on unallocated channel %d\n", ch);
		return 1;
	}
	if( chan[ch].c_interp > 0 )  {
		bu_log("error: attempt to modify channel %d which already has interpolation type set\n", ch);
		return 1;
	}
	return 0;
}

#define OPT_STR "q"
int get_args(int argc, char **argv)
{
	int c;
	while ( (c=getopt(argc,argv,OPT_STR)) != EOF) {
		switch(c){
		case 'q':
			verbose = 0;
			break;
		default:
			fprintf(stderr,"Unknown option: -%c\n",c);
			return(0);
		}
	}
	return(1);
}
@


11.10
log
@change conf.h to a wrapped config.h
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/tab/tabinterp.c,v 11.9 2004/02/02 17:39:42 morrison Exp $ (BRL)";
@


11.9
log
@update copyright to include span through 2003
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabinterp.c,v 11.8 2000/10/24 19:41:47 mike Exp $ (BRL)";
d34 5
a38 1
#include "conf.h"
@


11.8
log
@
compiler lint
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1988 by the United States Army.
d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabinterp.c,v 11.7 2000/08/24 23:01:01 mike Exp $ (BRL)";
@


11.8.4.1
log
@sync branch with HEAD
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d31 1
a31 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.8.6.1
log
@sync to HEAD...
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/tab/tabinterp.c,v 11.9 2004/02/02 17:39:42 morrison Exp $ (BRL)";
@


11.8.12.1
log
@merge from HEAD
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabinterp.c,v 11.9 2004/02/02 17:39:42 morrison Exp $ (BRL)";
@


11.8.12.2
log
@merge from head
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabinterp.c,v 11.8.12.1 2004/02/12 19:42:56 erikg Exp $ (BRL)";
@


11.7
log
@
lint
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabinterp.c,v 11.6 1999/05/21 05:02:28 mike Exp $ (BRL)";
d38 5
d45 2
d48 1
a48 1
#include "rtstring.h"
d107 5
a145 4
#if 0
	rt_g.debug = DEBUG_MEM;
#endif

d331 1
a331 4
create_chan( num, len, itag )
char	*num;
int	len;
char	*itag;
d351 1
a351 1
			chan = (struct chan *)rt_realloc( (char *)chan,
d850 1
a850 3
spline( chp, times )
register struct chan	*chp;
fastf_t			*times;
d1232 1
a1232 2
chan_not_loaded_or_specified( ch )
int	ch;
d1247 1
a1247 3
int get_args(argc,argv)
int argc;
char **argv;
@


11.6
log
@
Changed to Release 5.0 function names.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabinterp.c,v 11.5 1999/02/09 16:05:29 jra Exp $ (BRL)";
d102 18
a119 18
	"file", "filename chan_num(s)", "load channels from file",
		cm_file,	3, 999,
	"times", "start stop fps", "specify time range and fps rate",
		cm_times,	4, 4,
	"interp", "{step|linear|spline|cspline|quat} chan_num(s)", "set interpolation type",
		cm_interp,	3, 999,
	"next", "dest_chan src_chan [+/- #nsamp]", "lookahead in time",
		cm_next,	3, 4,
	"idump", "[chan_num(s)]", "dump input channel values",
		cm_idump,	1, 999,
	"rate", "chan_num init_value incr_per_sec [comment]", "create rate based channel",
		cm_rate,	4, 5,
	"accel", "chan_num init_value mult_per_sec [comment]", "create acceleration based channel",
		cm_accel,	4, 5,
	"help", "", "print help message",
		cm_help,	1, 999,
	(char *)0, (char *)0, (char *)0,
		0,		0, 0	/* END */
d126 1
d375 1
d453 1
d490 1
d1000 1
d1027 1
@


11.5
log
@create_chan() was using rt_malloc() switched to rt_calloc()
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabinterp.c,v 11.4 1996/07/17 14:43:08 jra Exp $ (BRL)";
d145 1
a145 1
		if(verbose) rt_log("cmd: %s\n", buf );
d147 1
a147 1
		rt_free( buf, "cmd buf" );
d149 1
a149 1
			if(verbose) rt_log("aborting\n");
d154 1
a154 1
	if(verbose) rt_log("performing interpolations\n");
d157 1
a157 1
	if(verbose) rt_log("writing output\n");
d175 1
a175 1
		rt_log("The following commands are available:\n\n");
d177 1
a177 1
			rt_log("%s %s\n\t%s\n",
d183 1
a183 1
	rt_log("Detailed help is not yet available.\n");
d207 1
a207 1
	struct rt_vls	buf;	/* unlimited size input line buffer */
d229 1
a229 1
	cnum = (int *)rt_malloc( argc * sizeof(int), "cnum[]");
d231 2
a232 2
	iwords = (char **)rt_malloc( (nwords+1) * sizeof(char *), "iwords[]" );
	rt_vls_init(&buf);
d235 1
a235 1
	times = (fastf_t *)rt_malloc( nlines * sizeof(fastf_t), "times");
d257 3
a259 3
		rt_vls_trunc( &buf, 0 );
		if( rt_vls_gets( &buf, fp ) == -1 )  break;
		bp = rt_vls_addr(&buf);
d274 1
a274 1
			rt_log("File '%s', Line %d:  expected %d columns, got %d\n",
d286 1
a286 1
			rt_log("File '%s', Line %d:  time sequence error %g > %g\n",
d297 1
a297 1
				rt_log("File '%s', Line %d:  scanf failure on '%s'\n",
d309 3
a311 3
	rt_free( (char *)cnum, "cnum[]");
	rt_free( (char *)iwords, "iwords[]");
	rt_vls_free(&buf);
d337 1
a337 1
			chan = (struct chan *)rt_calloc( 1, 
d343 1
a343 1
			if(verbose) rt_log("reallocating from %d to %d chans\n",
d355 1
a355 1
			rt_log("create_chan: internal error\n");
d362 1
a362 1
	if(verbose) rt_log("chan %d:  %s\n", n, itag );
d364 2
a365 2
	chan[n].c_itag = rt_strdup( itag );
	chan[n].c_ival = (fastf_t *)rt_malloc( len * sizeof(fastf_t), "c_ival");
d406 1
a406 1
		rt_log("pr_ichan(%d) out of range\n", ch );
d411 1
a411 1
	rt_log("--- Channel %d, ilen=%d (%s):\n",
d414 1
a414 1
		rt_log(" %g\t%g\n", cp->c_itime[i], cp->c_ival[i]);
d429 1
a429 1
		rt_log("times command not given, aborting\n");
d463 1
a463 1
		rt_log("times:  %g >= %g\n", a, b );
d467 1
a467 1
		rt_log("times:  already specified\n");
d472 1
a472 1
	o_time = (fastf_t *)rt_malloc( o_len * sizeof(fastf_t), "o_time[]");
d519 1
a519 1
		rt_log("interpolation type '%s' unknown\n", argv[1] );
d558 1
a558 1
		rt_log("times command not given\n");
d562 1
a562 1
	times = (fastf_t *)rt_malloc( o_len*sizeof(fastf_t), "periodic times");
d571 1
a571 1
		chan[ch].c_oval = (fastf_t *)rt_malloc(
d609 1
a609 1
			rt_log("channel %d: unknown interpolation type %d\n", ch, chp->c_interp);
d619 1
a619 1
				rt_log("spline failure, switching to linear\n");
d648 1
a648 1
	rt_free( (char *)times, "loc times");
d738 1
a738 1
		rt_log("lienar_interpolate:  need at least 2 points\n");
d789 1
a789 1
		rt_log("rate_interpolate:  only 2 points (ival & rate) may be specified\n");
d815 1
a815 1
		rt_log("accel_interpolate:  only 2 points (ival & mul) may be specified\n");
d863 1
a863 1
		rt_log("spline(%s): need at least 3 points\n", chp->c_itag);
d874 1
a874 1
		rt_log("spline(%s): endpoints don't match, replacing final data value\n", chp->c_itag);
d879 2
a880 2
	diag = (double *)rt_malloc((unsigned)i, "diag");
	rrr = (double *)rt_malloc((unsigned)i, "rrr");
d882 1
a882 1
		rt_log("spline: malloc failure\n");
d899 1
a899 1
			rt_log(
d980 2
a981 2
	rt_free( (char *)diag, "diag");
	rt_free( (char *)rrr, "rrr" );
d984 2
a985 2
	if(diag) rt_free( (char *)diag, "diag");
	if(rrr) rt_free( (char *)rrr, "rrr" );
d1008 1
a1008 1
	chp->c_itime = (fastf_t *)rt_malloc( nvals * sizeof(fastf_t), "rate times");
d1034 1
a1034 1
	chp->c_itime = (fastf_t *)rt_malloc( nvals * sizeof(fastf_t), "accel times");
d1193 1
a1193 1
		rt_log("ERROR next: ichan %d not loaded yet\n");
d1198 1
a1198 1
		rt_log("ERROR next: ochan %d previous loaded\n");
d1203 1
a1203 1
		rt_log("ERROR next: uanble to create output channel\n");
d1228 1
a1228 1
		rt_log("error: attempt to set interpolation type on unallocated channel %d\n", ch);
d1232 1
a1232 1
		rt_log("error: attempt to modify channel %d which already has interpolation type set\n", ch);
@


11.4
log
@Minor Mods for IRIX 6.2
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 11.3 1996/06/11 21:14:36 cnuzman Exp jra $ (BRL)";
d337 1
a337 1
			chan = (struct chan *)rt_malloc(
@


11.3
log
@fixed cspline bug
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 11.2 1996/01/23 16:06:58 cnuzman Exp cnuzman $ (BRL)";
d97 3
d654 1
d688 1
d1050 1
@


11.2
log
@added -q "quiet" option to suppress verbose output
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 11.1 1995/01/04 10:19:30 mike Rel4_4 cnuzman $ (BRL)";
d907 5
a911 4
			chp->c_ival[1] - chp->c_ival[0] :
			chp->c_ival[i+1] - chp->c_ival[i];
		rhs = 6 * ( (rhs /
			(chp->c_itime[i+1]-chp->c_itime[i]) ) -
d914 1
@


11.1
log
@Release_4.4
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 10.11 94/11/14 23:23:12 mike Exp $ (BRL)";
d69 3
d134 1
d1228 19
@


10.11
log
@Irix 6
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 10.10 94/09/23 19:02:41 mike Exp Locker: mike $ (BRL)";
@


10.10
log
@Fixed warning message.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 10.9 94/08/11 18:04:22 gdurf Exp Locker: mike $ (BRL)";
a449 1
	int		ch;
a775 1
	register int	i;		/* input time index */
a800 1
	register int	i;		/* input time index */
@


10.9
log
@Added include of conf.h
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 10.8 1994/08/03 19:18:27 cnuzman Exp gdurf $ (BRL)";
a165 1
#if 0
a166 1
#endif
d176 1
a176 1
	/* XXX What here? */
@


10.8
log
@fixed quaternion interpolation to be smooth rather than linear
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 10.7 93/10/26 03:35:13 mike Exp Locker: cnuzman $ (BRL)";
d33 2
@


10.7
log
@ANSI C
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 10.6 93/10/26 03:31:39 mike Exp Locker: mike $ (BRL)";
d1086 2
a1087 4
		/* Check for being in first or last two time spans */
#if 0
		if( i == 0 || i >= x->c_ilen-3 )
#endif
d1090 1
a1090 1
			quat_t	qout, q1, q2;
d1095 34
a1128 5
			QIGET( q1, i );
			QIGET( q2, i+1 );
			QUNITIZE( q1 );
			QUNITIZE( q2 );
			quat_slerp( qout, q1, q2, f );
d1132 1
a1132 6
#if 0
		/* XXX This does not work.  q1 needs to be start of THIS span,
		 * XXX (e.g. [i], not [i-1]),
		 * XXX and q4 the end of this span, with the two in the
		 * XXX middle somehow specially chosen.
		 */
d1136 1
a1136 1
			quat_t	qout, q1, q2, q3, q4;
d1145 19
a1163 1
			quat_sberp( qout, q1, q2, q3, q4, f );
d1166 1
a1166 1
#endif
@


10.6
log
@Modified to allow data files to have lines of unlimited length.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 10.5 93/10/26 03:19:58 jgrosh Exp Locker: mike $ (BRL)";
d86 7
d174 1
a174 1
		return;
d177 1
d391 1
d414 1
d543 1
d721 1
d771 1
d797 1
d829 4
d834 1
@


10.5
log
@Increased buf[] in cm_file()
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 10.4 1992/11/19 22:34:55 mike Exp jgrosh $ (BRL)";
d39 1
d125 2
d182 1
a182 2
	char	buf[4096*7];	/* old:	char	buf[512]; */

d192 1
d217 1
d230 5
a234 3
		sprintf( buf, "File '%s', Column %d", file, i );
		if( (cnum[i] = create_chan( argv[i+1], nlines, buf )) < 0 )
			return(-1);	/* abort */
d240 1
a240 2
		buf[0] = '\0';
		(void)fgets( buf, sizeof(buf), fp );
d242 5
a246 1
		if( buf[0] == '#' )  {
d256 1
a256 1
		i = rt_split_cmd( iwords, nwords+1, buf );
d293 1
d296 1
a1168 13

#if 0

/* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX */
/* X  H A C K !!!!!!                                                 X */
/* X                                                                 X */
/* X  Also, the size of buf[] in cm_file limits the amount of        X */
/* X  of columns of data one can read into tabinterp.                X */
/* X                                                                 X */
/* X                    - JG                                         X */
/* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX */

#endif
@


10.4
log
@Added help command.
Changed from fprintf(stderr to rt_log().
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 10.3 92/08/28 01:32:28 mike Exp Locker: mike $ (BRL)";
d179 2
a180 1
	char	buf[512];
d210 1
d236 1
d248 1
d308 1
d1158 13
@


10.3
log
@Added "next" command, as a way of looking ahead and behind
in other channel's values.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 10.2 92/08/27 22:48:29 mike Exp Locker: mike $ (BRL)";
d66 2
d83 1
d100 2
d106 1
d126 1
a126 1
		fprintf(stderr,"cmd: %s\n", buf );
d130 1
a130 1
			fprintf(stderr,"aborting\n");
d135 1
a135 1
	fprintf(stderr,"performing interpolations\n");
d138 1
a138 1
	fprintf(stderr,"writing output\n");
d145 25
d246 1
a246 1
			fprintf(stderr,"File '%s', Line %d:  expected %d columns, got %d\n",
d258 1
a258 1
		    	fprintf(stderr,"File '%s', Line %d:  time sequence error %g > %g\n",
d269 1
a269 1
			    	fprintf(stderr,"File '%s', Line %d:  scanf failure on '%s'\n",
d312 1
a312 1
			fprintf(stderr,"reallocating from %d to %d chans\n",
d324 1
a324 1
			fprintf(stderr,"create_chan: internal error\n");
d331 1
a331 1
fprintf(stderr, "chan %d:  %s\n", n, itag );
d374 1
a374 1
		fprintf(stderr, "pr_ichan(%d) out of range\n", ch );
d379 1
a379 1
	fprintf(stderr,"--- Channel %d, ilen=%d (%s):\n",
d382 1
a382 1
		fprintf(stderr," %g\t%g\n", cp->c_itime[i], cp->c_ival[i]);
d396 1
a396 1
		fprintf(stderr,"times command not given\n");
d431 1
a431 1
		fprintf(stderr,"times:  %g >= %g\n", a, b );
d435 1
a435 1
		fprintf(stderr,"times:  already specified\n");
d487 1
a487 1
		fprintf( stderr, "interpolation type '%s' unknown\n", argv[1] );
d525 1
a525 1
		fprintf(stderr,"times command not given\n");
d576 1
a576 1
			fprintf(stderr,"channel %d: unknown interpolation type %d\n", ch, chp->c_interp);
d586 1
a586 1
				fprintf(stderr, "spline failure, switching to linear\n");
d702 1
a702 1
		fprintf(stderr,"lienar_interpolate:  need at least 2 points\n");
d753 1
a753 1
		fprintf(stderr,"rate_interpolate:  only 2 points (ival & rate) may be specified\n");
d779 1
a779 1
		fprintf(stderr,"accel_interpolate:  only 2 points (ival & mul) may be specified\n");
d822 1
a822 1
		fprintf(stderr,"spline(%s): need at least 3 points\n", chp->c_itag);
d833 1
a833 1
		fprintf(stderr,"spline(%s): endpoints don't match, replacing final data value\n", chp->c_itag);
d841 1
a841 1
		fprintf(stderr, "spline: malloc failure\n");
d858 1
a858 1
			fprintf(stderr,
d1109 1
a1109 1
		fprintf(stderr,"ERROR next: ichan %d not loaded yet\n");
d1114 1
a1114 1
		fprintf(stderr,"ERROR next: ochan %d previous loaded\n");
d1119 1
a1119 1
		fprintf(stderr,"ERROR next: uanble to create output channel\n");
d1144 1
a1144 1
		fprintf(stderr,"error: attempt to set interpolation type on unallocated channel %d\n", ch);
d1148 1
a1148 1
		fprintf(stderr,"error: attempt to modify channel %d which already has interpolation type set\n", ch);
@


10.2
log
@Added "quat" interpolation
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 10.1 91/10/12 06:51:21 mike Rel4_0 Locker: mike $ (BRL)";
d60 1
d62 2
d80 1
d89 2
d294 1
d463 1
a463 8
		if( chp->c_ilen <= 0 )  {
			fprintf(stderr,"error: attempt to set interpolation type on unallocated channel %d\n", ch);
			continue;
		}
		if( chp->c_interp > 0 )  {
			fprintf(stderr,"error: attempt to modify channel %d already specified by 'interp'\n", i);
			continue;
		}
d470 1
a470 8
				if( chp->c_ilen <= 0 )  {
					fprintf(stderr,"error: attempt to set interpolation type on unallocated channel %d\n", ch);
				continue;
				}
				if( chp->c_interp > 0 )  {
					fprintf(stderr,"error: attempt to modify channel %d already specified by 'interp'\n", i);
					continue;
				}
d473 1
d511 1
d516 1
d574 10
d588 26
d1062 59
@


10.1
log
@Release_4.0
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 1.19 91/07/02 04:27:30 mike Exp $ (BRL)";
d58 2
d83 1
a83 1
	"interp", "{step|linear|spline|cspline} chan_num(s)", "set interpolation type",
d445 3
d460 4
d466 16
d506 1
d515 1
d517 5
d570 6
d605 2
a606 6
		/* Check for above final time */
		if( times[t] > chp->c_itime[chp->c_ilen-1] )  {
			chp->c_oval[t] = chp->c_ival[chp->c_ilen-1];
			continue;
		}
		/* Find time range in input data.  Could range check? */
d613 7
d650 2
a651 6
		/* Check for above final time */
		if( times[t] > chp->c_itime[chp->c_ilen-1] )  {
			chp->c_oval[t] = chp->c_ival[chp->c_ilen-1];
			continue;
		}
		/* Find time range in input data.  Could range check? */
d658 7
d933 97
@


1.19
log
@Cray being picky
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabinterp.c,v 1.18 90/11/27 21:39:46 mike Exp $ (BRL)";
@


1.18
log
@Fixed bug with allocating more channels.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/rots/RCS/tabinterp.c,v 1.17 90/11/03 21:51:26 mike Exp $ (BRL)";
d698 2
a699 1
	double	u,v;
@


1.17
log
@Added "acceleration" (multiplication) channel as well.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/rots/RCS/tabinterp.c,v 1.16 90/11/03 20:58:17 mike Exp $ (BRL)";
d264 1
d271 1
a271 1
			while( n > max_chans )
d273 2
d278 2
@


1.16
log
@A more reasonable implementation of rate channels.
Not necessary to put the rate value into a file
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/rots/RCS/tabinterp.c,v 1.15 90/11/03 18:48:02 mike Exp $ (BRL)";
d57 1
d74 1
d85 4
a88 2
	"rate", "chan_num initial_value [comment]", "create rate based channel",
		cm_rate,	3, 4,
d530 3
d637 1
d640 2
a641 2
	if( chp->c_ilen != 1 )  {
		fprintf(stderr,"rate_interpolate:  only 1 point (the rate) may be specified\n");
d644 2
a645 1
	rate = chp->c_ival[0];
d648 1
a648 1
		chp->c_oval[t] = rate * times[t];
d653 29
d833 7
d846 1
a846 1
	double	val;
d848 1
a848 2
	val = atof(argv[2]);
	ch = create_chan( argv[1], 1, argc>3?argv[3]:"rate chan" );
d852 30
a881 3
	chp->c_itime = (fastf_t *)rt_malloc( 1 * sizeof(fastf_t), "rate times");
	chp->c_itime[0] = 0;
	chp->c_ival[0] = val;
@


1.15
log
@Added rate-based "inpterpolation"
@
text
@d8 1
a8 1
 *  internal "channels".
d10 3
a12 1
 *  Secondly, a section of those times is interpolated, and
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /n/spark/m/cad/rots/RCS/tabinterp.c,v 1.14 89/10/10 15:49:41 mike Exp $ (BRL)";
d72 1
d79 1
a79 1
	"interp", "{step|linear|spline|cspline|rate} chan_num(s)", "set interpolation type",
d83 2
a433 3
	} else if( strcmp( argv[1], "rate" ) == 0 )  {
		interp = INTERP_RATE;
		periodic = 0;
d792 19
@


1.14
log
@Now allows "times" command to be given anywhere in the input sequence.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: tabinterp.c,v 1.13 89/08/12 00:40:13 mike Exp $ (BRL)";
d54 1
d76 1
a76 1
	"interp", "{step|linear|spline|cspline} chan_num(s)", "set interpolation type",
d429 3
d521 3
d574 1
a574 1
 *  the input and output is sorted in increasing time values.
d612 26
@


1.13
log
@Printf()s improved
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: tabinterp.c,v 1.12 89/01/09 05:18:02 mike Locked $ (BRL)";
d340 5
a392 7
	/* Allocate memory for all the output values */
	for( ch = 0; ch < nchans; ch++ )  {
		if( chan[ch].c_ilen <= 0 )
			continue;
		chan[ch].c_oval = (fastf_t *)rt_malloc(
			o_len * sizeof(fastf_t), "c_oval[]");
	}
d459 5
d470 4
@


1.12
log
@removed stray printf

@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: tabinterp.c,v 1.11 89/01/07 02:28:42 mike Locked $ (BRL)";
d629 1
a629 1
		fprintf(stderr,"spline: need at least 3 points\n");
d640 1
a640 1
		fprintf(stderr,"spline: endpoints don't match, replacing final data value\n");
@


1.11
log
@Permit comments in input data files.
Added some more debugging
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: tabinterp.c,v 1.10 89/01/02 07:04:13 mike Locked $ (BRL)";
a464 1
fprintf(stderr,"go: ch %d, len=%d\n", ch, chp->c_ilen);
@


1.10
log
@this version seems to work!
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: tabinterp.c,v 1.9 89/01/02 03:23:51 mike Locked $ (BRL)";
d105 4
a108 2
		if( ret < 0 )
			break;
d111 1
d114 1
d169 6
d185 10
d218 1
d276 1
d458 1
a458 1
	fastf_t	*times;
d465 1
d496 2
a497 2
			fprintf(stderr,"unknown interpolation type %d\n", chp->c_interp);
			/* FALL THROUGH */
d570 5
d629 5
d638 1
a638 6
		linear_interpolate( chp );

	if(chp->c_ilen<3) {
		fprintf(stderr,"spline: need at least 3 points\n");
		goto bad;
	}
@


1.9
log
@Added check for no file name.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: tabinterp.c,v 1.8 89/01/02 03:17:35 mike Locked $ (BRL)";
d392 4
d398 4
d436 2
d439 2
d445 25
d476 1
a476 1
			linear_interpolate( chp );
d479 1
a479 1
			step_interpolate( chp );
d482 1
a482 1
			if( spline( chp ) <= 0 )  {
d490 1
d503 1
a503 1
step_interpolate( chp )
d505 1
d513 1
a513 1
		if( o_time[t] < chp->c_itime[0] )  {
d518 1
a518 1
		if( o_time[t] > chp->c_itime[chp->c_ilen-1] )  {
d524 2
a525 2
			if( o_time[t] >= chp->c_itime[i] && 
			    o_time[t] <  chp->c_itime[i+1] )
d540 1
a540 1
linear_interpolate( chp )
d542 1
d550 1
a550 1
		if( o_time[t] < chp->c_itime[0] )  {
d555 1
a555 1
		if( o_time[t] > chp->c_itime[chp->c_ilen-1] )  {
d561 2
a562 2
			if( o_time[t] >= chp->c_itime[i] && 
			    o_time[t] <  chp->c_itime[i+1] )
d568 1
a568 1
			(o_time[t] - chp->c_itime[i]) *
d581 1
a581 1
spline( chp )
d583 1
a597 1
	double		*times = (double *)0;
d620 1
a620 2
	times = (double *)rt_malloc( o_len*sizeof(double), "local times");
	if( !rrr || !diag || !times )  {
a624 23
	if( chp->c_periodic )  {
		for( t=0; t < o_len; t++ )  {
			register double	cur_t;

			cur_t = o_time[t];

			while( cur_t > chp->c_itime[chp->c_ilen-1] )  {
				cur_t -= (chp->c_itime[chp->c_ilen-1] -
				    chp->c_itime[0] );
			}
			while( cur_t < chp->c_itime[0] )  {
				cur_t += (chp->c_itime[chp->c_ilen-1] -
				    chp->c_itime[0] );
			}
			times[t] = cur_t;
		}
	} else {
		for( t=0; t < o_len; t++ )  {
			times[t] = o_time[t];
		}
	}
		

a718 1
	rt_free( (char *)times, "loc times");
a722 1
	if(times) rt_free( (char *)times, "loc times");
@


1.8
log
@Added idump keyword.
Fixed malloc length error
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: tabinterp.c,v 1.7 89/01/02 02:17:39 mike Locked $ (BRL)";
a256 1
fprintf(stderr,"c_itag=%s\n", chan[n].c_itag);
d301 1
@


1.7
log
@Neatened spline code.
Added step_interpolate routine
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: tabinterp.c,v 1.6 89/01/02 01:48:39 mike Locked $ (BRL)";
d39 2
d68 1
d75 1
a75 1
	"interp", "{linear|spline|cspline} chan_num(s)", "set interpolation type",
d77 2
d93 4
a108 2
	pr_ichans();

d161 1
a161 1
	times = (fastf_t *)rt_malloc( nwords * sizeof(fastf_t), "times");
d246 8
a253 2
	for( ; n >= nchans; nchans++ )
		bzero( (char *)&chan[nchans], sizeof(struct chan) );
d257 1
d263 24
d291 2
a292 1
pr_ichans()
a293 1
	register int		ch;
d297 3
a299 7
	for( ch=0; ch < nchans; ch++ )  {
		cp = &chan[ch];
		fprintf(stderr,"--- Channel %d, ilen=%d (%s):\n",
			ch, cp->c_ilen, cp->c_itag );
		for( i=0; i < cp->c_ilen; i++ )  {
			fprintf(stderr," %g\t%g\n", cp->c_itime[i], cp->c_ival[i]);
		}
d301 6
d419 5
a423 1
/* Perform linear interpolation on each channel */
@


1.6
log
@Working continuous splines
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: tabinterp.c,v 1.5 89/01/01 23:48:20 mike Locked $ (BRL)";
d397 3
d412 40
d478 1
a478 1
			    o_time[t] <= chp->c_itime[i+1] )
d490 7
a496 17
/* Spline fit technique, derrived from /usr/src/usr.bin/spline.c */

double
rhs(i, chp)
register int		i;
register struct chan	*chp;
{
	register int i_;
	double zz;

	i_ = (i==chp->c_ilen-1) ? 0 : i;
	zz = (chp->c_ival[i] - chp->c_ival[i-1])/
		(chp->c_itime[i] - chp->c_itime[i-1]);
	return( 6 * ((chp->c_ival[i_+1]-chp->c_ival[i_])/
		(chp->c_itime[i+1]-chp->c_itime[i]) - zz));
}

d571 2
d583 16
a598 3
		u = i==1?0.0:u-s*s/d;
		v = i==1?0.0:v-s*rrr[i-1]/d;
		rrr[i] = rhs(i,chp)-hi*rrr[i-1]/d;
@


1.5
log
@Working splines!!
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: tabinterp.c,v 1.4 89/01/01 23:12:50 mike Locked $ (BRL)";
d49 3
a51 2
#define	INTERP_LINEAR	1
#define	INTERP_SPLINE	2
d350 3
a352 1
	if( strcmp( argv[1], "linear" ) == 0 )  {
d467 2
a468 1
	float d,s,u,v;
d471 11
a481 8
	float h;
	float D2yi,D2yi1,D2yn1;
	float a;
	int end;
	float corr;
	register int i,j,m;
	float konst = 0.0;		/* derriv. at endpts, non-periodic */
	float *diag, *rrr;
d487 2
a488 1
	linear_interpolate( chp );
d491 1
a491 1
		printf("need at least 3 points to spline\n");
d495 11
a505 5
	i = (chp->c_ilen+1)*sizeof(float);
	diag = (float *)rt_malloc((unsigned)i, "diag");
	rrr = (float *)rt_malloc((unsigned)i, "rrr");
	if( !rrr || !diag )  {
		printf("malloc failure\n");
d509 23
d562 1
d568 1
a568 1
			corr = end?2*s+u:0.0;
d587 2
a588 9
		/* hi1 is range of time covered in this interval */
#if 0
		/* m will be number of samples in this interval */
		m = hi1 * fps;
		if(m<=0) m = 1;

		/* interpolate, high to low */
		for(j=m;j>0||i==0&&j==0;j--) {
			register int sub;
a591 15

			x1 = (double)j / (double) m;
			x0 = 1 - x1;
			yy = D2yi * (x0 - x0*x0*x0) + D2yi1 * (x1 - x1*x1*x1);
			yy = chp->c_ival[i] * x0 + chp->c_ival[i+1] * x1 - 
				hi1 * hi1 * yy / 6;
			sub = (int)((chp->c_itime[i]+x1*hi1)*fps);
			chp->c_oval[sub] = yy;
		}
#endif
		/* Sweep o_time[], looking for times in this span */
		for( t=0; t<o_len; t++ )  {
			register double	x0;	/* fraction from [i+0] */
			register double	x1;	/* fraction from [i+1] */
			register double	yy;
d594 1
a594 8
			cur_t = o_time[t];
			if( chp->c_periodic )  {
				/* Should be pre-computed once/sline call XXX */
				while( cur_t > chp->c_itime[chp->c_ilen-1] )
					cur_t -= chp->c_itime[0];
				while( cur_t < chp->c_itime[0] );
					cur_t += chp->c_itime[chp->c_ilen-1];
			}
d611 1
d614 3
a616 2
	rt_free( (char *)diag, "diag");
	rt_free( (char *)rrr, "rrr" );
@


1.4
log
@Spline code improvements, still does not work.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: tabinterp.c,v 1.3 88/12/31 07:02:49 mike Locked $ (BRL)";
d586 1
a586 1
			if( cur_t > chp->c_ival[i+1] )
d588 1
a588 1
			if( cur_t < chp->c_ival[i] )
d590 4
a593 3
			x0 = (cur_t - chp->c_ival[i]) /
			    (chp->c_ival[i+1] - chp->c_ival[i]);
			x1 = 1 - x0;
@


1.3
log
@Spline code added.  It compiles, but does not yet work.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: tabinterp.c,v 1.2 88/12/30 09:00:52 mike Locked $ (BRL)";
d464 3
a466 1
	float d,s,u,v,hi,hi1;
d468 2
a469 1
	float D2yi,D2yi1,D2yn1,x0,x1,yy,a;
d473 1
a473 1
	float konst = 0.0;		/* ?? */
d475 1
d477 5
d488 2
a489 4
	if( !diag )
		diag = (float *)rt_malloc((unsigned)i, "diag");
	if( !rrr )
		rrr = (float *)rt_malloc((unsigned)i, "rrr");
d499 2
a500 1
	for(i=0;++i<chp->c_ilen-!chp->c_periodic;){	/* triangularize */
d502 3
a504 2
		hi1 = i==chp->c_ilen-1?chp->c_itime[1]-chp->c_itime[0]:
			chp->c_itime[i+1]-chp->c_itime[i];
d506 3
a508 1
			printf("spline: ??\n");
d522 2
a523 1
	for(i=chp->c_ilen-!chp->c_periodic;--i>=0;){	/* back substitute */
d525 2
a526 2
		hi1 = end?chp->c_itime[1]-chp->c_itime[0]:
			chp->c_itime[i+1]-chp->c_itime[i];
d550 1
a553 1
		h = hi1/m;
d558 10
a567 5
			x0 = (m-j)*h/hi1;
			x1 = j*h/hi1;
			yy = D2yi*(x0-x0*x0*x0)+D2yi1*(x1-x1*x1*x1);
			yy = chp->c_ival[i]*x0+chp->c_ival[i+1]*x1 -hi1*hi1*yy/6;
			sub = (int)((chp->c_itime[i]+j*h)*fps);
d569 28
@


1.2
log
@Bugs fixed
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: tabinterp.c,v 1.1 88/12/30 08:51:42 mike Locked $ (BRL)";
d40 1
d45 1
d47 1
d49 3
a51 3
#define	INTERP_LINEAR	0
#define	INTERP_SPLINE	1
	int	c_cyclic;	/* cyclic end conditions? */
d56 1
d63 2
d69 4
d99 1
a99 1
	pr_chans();
d101 4
d127 1
d169 1
a169 1
			printf("File '%s', Line %d:  expected %d columns, got %d\n",
d171 1
a171 1
			while( i < nwords )
d173 2
d181 1
a181 1
		    	printf("File '%s', Line %d:  time sequence error %g > %g\n",
d183 1
d191 1
a191 1
			    	printf("File '%s', Line %d:  scanf failure on '%s'\n",
d194 1
d205 2
d210 3
d224 1
a224 1
	if( n > max_chans )  {
d247 6
a252 1
pr_chans()
d260 1
a260 1
		printf("--- Channel %d, ilen=%d (%s):\n",
d263 1
a263 1
			printf(" %g\t%g\n", cp->c_itime[i], cp->c_ival[i]);
a264 1
		/* Later, c_oval's */
d266 295
@


1.1
log
@Initial revision
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d142 1
a142 1
		sprintf( buf, "File %s, Column %d", file, i );
d154 1
a154 1
			printf("File %s, Line %s:  expected %d columns, got %d\n",
d157 1
a157 1
				iwords[i++] = (char *)0;
d159 2
d163 8
a171 1
			d = 2.34;
d173 1
a173 1
			    	printf("File %s, Line %s:  scanf failure on '%s'\n",
@
