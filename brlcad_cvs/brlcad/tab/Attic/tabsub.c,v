head	11.19;
access;
symbols
	ansi-20040405-merged:11.15.2.2
	postmerge-20040405-ansi:11.17
	premerge-20040404-ansi:11.16
	postmerge-autoconf:11.16
	autoconf-freeze:11.15.10.2
	premerge-autoconf:11.16
	postmerge-20040315-windows:11.16
	premerge-20040315-windows:11.16
	windows-20040315-freeze:11.15.4.1
	autoconf-20031203:11.15
	autoconf-20031202:11.15
	autoconf-branch:11.15.0.10
	phong-branch:11.15.0.8
	photonmap-branch:11.15.0.6
	rel-6-1-DP:11.15
	windows-branch:11.15.0.4
	rel-6-0-2:11.13
	ansi-branch:11.15.0.2
	rel-6-0-1-branch:11.13.0.2
	hartley-6-0-post:11.14
	hartley-6-0-pre:11.13
	rel-6-0-1:11.13
	rel-6-0:11.13
	rel-5-4:11.7
	offsite-5-3-pre:11.11
	rel-5-3:11.7
	rel-5-2:11.7
	rel-5-1-branch:11.7.0.2
	rel-5-1:11.7
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:1.4;
locks; strict;
comment	@ * @;


11.19
date	2004.05.21.16.43.12;	author morrison;	state dead;
branches;
next	11.18;

11.18
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	11.17;

11.17
date	2004.04.05.05.46.00;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2004.02.02.17.39.42;	author morrison;	state Exp;
branches;
next	11.15;

11.15
date	2002.08.20.17.08.46;	author jra;	state Exp;
branches
	11.15.2.1
	11.15.4.1
	11.15.10.1;
next	11.14;

11.14
date	2002.08.15.20.55.58;	author hartley;	state Exp;
branches;
next	11.13;

11.13
date	2001.08.10.19.00.52;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	2001.03.31.01.57.37;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2000.10.24.19.38.31;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.08.31.19.35.06;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.08.24.23.02.09;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.08.24.23.01.02;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.01.31.16.13.08;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	99.12.20.20.58.46;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.05.21.05.02.29;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.05.21.04.59.15;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	99.05.15.16.21.25;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.07.17.14.43.08;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.19.32;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.11.14.23.23.48;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.08.11.18.07.15;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.08.11.18.06.01;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	92.11.20.21.36.03;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.08.28.01.47.21;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.08.27.22.48.03;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.51.22;	author mike;	state Rel4_0;
branches;
next	1.11;

1.11
date	91.09.27.05.52.51;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	91.07.06.00.34.48;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	91.07.01.21.27.38;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	90.11.04.10.42.34;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	90.11.03.21.52.33;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	90.11.03.19.52.41;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	89.12.29.14.56.45;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	89.01.09.06.30.10;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.01.07.04.14.58;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.01.02.07.04.54;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.01.02.04.40.21;	author mike;	state Exp;
branches;
next	;

11.15.2.1
date	2002.09.19.18.02.27;	author morrison;	state Exp;
branches;
next	11.15.2.2;

11.15.2.2
date	2004.03.17.21.23.03;	author morrison;	state Exp;
branches;
next	;

11.15.4.1
date	2004.03.11.23.48.35;	author morrison;	state Exp;
branches;
next	;

11.15.10.1
date	2004.02.12.19.42.56;	author erikg;	state Exp;
branches;
next	11.15.10.2;

11.15.10.2
date	2004.03.15.14.08.09;	author erikg;	state Exp;
branches;
next	;


desc
@Program to substitute fields from tabular data into prototype document.
@


11.19
log
@moved to src/tab/
@
text
@/*
 *			T A B S U B . C
 *
 *  This program is a simple macro processor for taking
 *  a big table of input values, and a prototype output document,
 *  and generating an instantiation of the output document
 *  for each line of input values.
 *
 *  This program follows "tabinterp", and is the last step in creating
 *  RT animation scripts.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/tab/tabsub.c,v 11.18 2004/05/10 15:30:50 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <math.h>
#if defined(HAVE_UNIX_IO)
# include <sys/types.h>
# include <sys/stat.h>
#endif


#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"

int	debug = 0;

char	*prototype;		/* Contains full text of prototype document */

void	get_proto(char *file);
void	do_lines(FILE *fp);
void	out_mat(matp_t m, FILE *fp);
int	str2chan_index( char *s );
int	multi_words( char *words[], int	nwords );


/*
 *			M A I N
 *
 */
int
main(int argc, char **argv)
{
	FILE	*table;

	if( argc < 1 || argc > 3 )  {
		fprintf(stderr,"Usage:  tabsub prototype_file [table_file]\n");
		exit(12);
	}

	/* Acquire in-core copy of prototype file */
	get_proto( argv[1] );

	if( argc < 3 )  {
		table = stdin;
	} else {
		if( (table = fopen( argv[2], "r" )) == NULL )  {
			perror( argv[2] );
			exit(3);
		}
	}
	do_lines( table );
	return 0;
}

void
get_proto(char *file)
{
	struct stat	sb;
	int	fd;

	if( (fd = open( file, 0 )) < 0 || stat( file, &sb ) < 0 )  {
		perror(file);
		exit(1);
	}
	if( sb.st_size == 0 )  {
		fprintf(stderr,"tabsub:  %s is empty\n", file );
		exit(1);
	}
	prototype = bu_malloc( sb.st_size+4, "prototype document");
	if( read( fd, prototype, sb.st_size ) != sb.st_size )  {
		perror(file);
		exit(2);
	}
	prototype[sb.st_size] = '\0';
}

#define	NCHANS	1024
char	linebuf[NCHANS*10];
int	line;				/* input line number */

char	*chanwords[NCHANS+1];
int	nwords;				/* # words in chanwords[] */

#define NTOKENWORDS	16
char	*tokenwords[NTOKENWORDS+1];

void
do_lines(FILE *fp)
{
#define TOKLEN	128
	char	token[TOKLEN];
	int	ntokenwords;
	register char	*cp;
	register char	*tp;
	int	i;

	for( line=0; /*NIL*/; line++ )  {
		linebuf[0] = '\0';
		(void)fgets( linebuf, sizeof(linebuf), fp );
		if( feof(fp) )
			break;

		/* Skip blank or commented out lines */
		if( linebuf[0] == '\0' ||
		    linebuf[0] == '#' ||
		    linebuf[0] == '\n' )
			continue;

		if(debug)  {
			fprintf(stderr, "Prototype=\n%s", prototype);
			fprintf(stderr, "Line %d='%s'\n", line, linebuf);
		}

		/* Here, there is no way to check for too many words */
		nwords = rt_split_cmd( chanwords, NCHANS+1, linebuf );

		for( cp=prototype; *cp != '\0'; )  {
			if(debug) fputc( *cp, stderr );
			/* Copy all plain text, verbatim */
			if( *cp != '@@' )  {
				putc( *cp++, stdout );
				continue;
			}

			/* An '@@' sign has been seen, slurp up a token */
			cp++;			/* skip '@@' */
			if( *cp == '@@' )  {
				/* Double '@@' is escape for single one
				 * (just like ARPANET TACs)
				 */
				putc( '@@', stdout );
				cp++;		/* skip '@@' */
				continue;
			}
			if( *cp == '(' )  {
				cp++;		/* skip '(' */
				tp = token;
				while( *cp && *cp != ')' && tp<&token[TOKLEN-1])  {
					*tp++ = *cp++;
				}
				*tp++ = '\0';
				cp++;		/* skip ')' */
			} else if( isdigit( *cp ) )  {
				tp = token;
				while( isdigit( *cp ) && tp<&token[TOKLEN-1] )  {
					*tp++ = *cp++;
				}
				*tp++ = '\0';
			} else {
				fprintf( stderr,"Line %d:  Bad sequence '@@%c'\n", line, *cp);
				fprintf( stdout, "@@%c", *cp++ );
				continue;
			}
			if(debug) fprintf(stderr,"token='%s'\n", token);

			if( isdigit( token[0] ) )  {
				fputs( chanwords[str2chan_index(token)],
					stdout );
				continue;
			}
			if( strcmp( token, "line" ) == 0 )  {
				fprintf(stdout, "%d", line );
				continue;
			}
			if( strcmp( token, "time" ) == 0 )  {
				fputs( chanwords[0], stdout );
				continue;
			}

			/* Check here for multi-word tokens */
			ntokenwords = rt_split_cmd( tokenwords, NTOKENWORDS+1,
				token );

			/*  If first character of a word is '@@' or '%', that
			 *  signifies substituting the value of the
			 *  indicated channel.  Otherwise the word is literal.
			 */
			for( i=1; i<ntokenwords; i++ )  {
				char	c;
				int	chan;
				c = tokenwords[i][0];
				if( c != '@@' && c != '%' )  continue;
				chan = str2chan_index( &tokenwords[i][1] );
				tokenwords[i] = chanwords[chan];
			}

			if( (i=multi_words( tokenwords, ntokenwords )) >= 0 )
				continue;

			if( i == -1 )  {
				fprintf(stderr,
					"Line %d: keyword @@(%s) encountered error\n",
					line, token);
				fprintf(stdout,
					"@@(%s)", token );
			} else {
				fprintf(stderr,
					"Line %d: keyword @@(%s) unknown\n",
					line, token);
				fprintf(stdout,
					"@@(%s)", token );
			}
			for( i=0; i<ntokenwords; i++ )  {
				fprintf( stderr,
					"word[%2d] = '%s'\n",
					i, tokenwords[i] );
			}
		}
	}
}

/*
 *  Returns -
 *	-2	unknown keyword
 *	-1	error in processing keyword
 *	 0	OK
 */
int
multi_words( char *words[], int	nwords )
{

	if( strcmp( words[0], "rot" ) == 0 )  {
		mat_t	mat;

		/* Expects rotations rx, ry, rz, in degrees */
		if( nwords < 4 )  return(-1);
		MAT_IDN( mat );
		bn_mat_angles( mat, 
		    atof( words[1] ),
		    atof( words[2] ),
		    atof( words[3] ) );
		out_mat( mat, stdout );
		return(0);
	}
	if( strcmp( words[0], "xlate" ) == 0 )  {
		mat_t	mat;

		if( nwords < 4 )  return(-1);
		/* Expects translations tx, ty, tz */
		MAT_IDN( mat );
		MAT_DELTAS( mat, 
		    atof( words[1] ),
		    atof( words[2] ),
		    atof( words[3] ) );
		out_mat( mat, stdout );
		return(0);
	}
	if( strcmp( words[0], "rot_at" ) == 0 )  {
		mat_t	mat;
		mat_t	mat1;
		mat_t	mat2;
		mat_t	mat3;

		/* JG - Expects x, y, z, rx, ry, rz               */
		/* Translation back to the origin by (-x,-y,-z)   */
		/* is done first, then the rotation, and finally  */
		/* back into the original position by (+x,+y,+z). */

		if( nwords < 7 )  return(-1);

		MAT_IDN( mat1 );
		MAT_IDN( mat2 );
		MAT_IDN( mat3 );

		MAT_DELTAS( mat1, 
		    -atof( words[1] ),
		    -atof( words[2] ),
		    -atof( words[3] ) );

		bn_mat_angles( mat2, 
		    atof( words[4] ),
		    atof( words[5] ),
		    atof( words[6] ) );

		MAT_DELTAS( mat3, 
		    atof( words[1] ),
		    atof( words[2] ),
		    atof( words[3] ) );

		bn_mat_mul( mat, mat2, mat1 );
		bn_mat_mul2( mat3, mat );

		out_mat( mat, stdout );
		return(0);
	}
	if( strcmp( words[0], "orient" ) == 0 )  {
		register int i;
		mat_t	mat;
		double	args[8];

		/* Expects tx, ty, tz, rx, ry, rz, [scale]. */
		/* All rotation is done first, then translation */
		/* Note: word[0] and args[0] are the keyword */
		if( nwords < 6+1 )  return(-1);
		for( i=1; i<6+1; i++ )
			args[i] = 0;
		args[7] = 1.0;	/* optional arg, default to 1 */
		for( i=1; i<nwords; i++ )
			args[i] = atof( words[i] );
		MAT_IDN( mat );
		bn_mat_angles( mat, args[4], args[5], args[6] );
		MAT_DELTAS( mat, args[1], args[2], args[3] );
		if( NEAR_ZERO( args[7], VDIVIDE_TOL ) )  {
			/* Nearly zero, signal error */
			fprintf(stderr,"Orient scale arg is near zero ('%s')\n",
				words[7] );
			return(-1);
		} else {
			mat[15] = 1 / args[7];
		}
		out_mat( mat, stdout );
		return(0);
	}
	if( strcmp( words[0], "ae" ) == 0 )  {
		mat_t	mat;
		fastf_t	az, el;

		if( nwords < 3 )  return(-1);
		/* Expects azimuth, elev, optional twist */
		az = atof(words[1]);
		el = atof(words[2]);
#if 0
		if( nwords == 3 )
			twist = 0.0;
		else
			twist = atof(words[3]);
#endif
		MAT_IDN( mat );
		/* XXX does not take twist, for now XXX */
		bn_mat_ae( mat, az, el );
		out_mat( mat, stdout );
		return(0);
	}
	if( strcmp( words[0], "arb_rot_pt" ) == 0 )  {
		mat_t	mat;
		point_t	pt1, pt2;
		vect_t	dir;
		fastf_t	ang;

		if( nwords < 1+3+3+1 )  return(-1);
		/* Expects point1, point2, angle */
		VSET( pt1, atof(words[1]), atof(words[2]), atof(words[3]) );
		VSET( pt2, atof(words[4]), atof(words[5]), atof(words[6]) );
		ang = atof(words[7]) * bn_degtorad;
		VSUB2( dir, pt2, pt2 );
		VUNITIZE(dir);
		MAT_IDN( mat );
		bn_mat_arb_rot( mat, pt1, dir, ang );
		out_mat( mat, stdout );
		return(0);
	}
	if( strcmp( words[0], "arb_rot_dir" ) == 0 )  {
		mat_t	mat;
		point_t	pt1;
		vect_t	dir;
		fastf_t	ang;

		if( nwords < 1+3+3+1 )  return(-1);
		/* Expects point1, dir, angle */
		VSET( pt1, atof(words[1]), atof(words[2]), atof(words[3]) );
		VSET( dir, atof(words[4]), atof(words[5]), atof(words[6]) );
		ang = atof(words[7]) * bn_degtorad;
		VUNITIZE(dir);
		MAT_IDN( mat );
		bn_mat_arb_rot( mat, pt1, dir, ang );
		out_mat( mat, stdout );
		return(0);
	}
	if( strcmp( words[0], "quat" ) == 0 )  {
		mat_t	mat;
		quat_t	quat;

		/* Usage: quat x,y,z,w */
		if( nwords < 5 ) return -1;
		QSET( quat, atof(words[1]), atof(words[2]),
			atof(words[3]), atof(words[4]) );

		quat_quat2mat( mat, quat );
		out_mat( mat, stdout);
		return 0;
	}
	if( strcmp( words[0], "fromto" ) == 0 )  {
		mat_t	mat;
		point_t	cur;
		point_t	next;
		vect_t	from;
		vect_t	to;

		/* Usage: fromto +Z cur_xyz next_xyz */
		if( nwords < 8 )  return -1;
		if( strcmp( words[1], "+X" ) == 0 )  {
			VSET( from, 1, 0, 0 );
		} else if( strcmp( words[1], "-X" ) == 0 )  {
			VSET( from, -1, 0, 0 );
		} else if( strcmp( words[1], "+Y" ) == 0 )  {
			VSET( from, 0, 1, 0 );
		} else if( strcmp( words[1], "-Y" ) == 0 )  {
			VSET( from, 0, -1, 0 );
		} else if( strcmp( words[1], "+Z" ) == 0 )  {
			VSET( from, 0, 0, 1 );
		} else if( strcmp( words[1], "-Z" ) == 0 )  {
			VSET( from, 0, 0, -1 );
		} else {
			fprintf(stderr,"fromto '%s' is not +/-XYZ\n", words[1]);
			return -1;
		}
		VSET( cur, atof(words[2]), atof(words[3]), atof(words[4]) );
		VSET( next, atof(words[5]), atof(words[6]), atof(words[7]) );
		VSUB2( to, next, cur );
		VUNITIZE(to);
		bn_mat_fromto( mat, from, to );
		/* Check to see if it worked. */
		{
			vect_t	got;

			MAT4X3VEC( got, mat, from );
			if( VDOT( got, to ) < 0.9 )  {
				bu_log("\ntabsub ERROR: At t=%s, bn_mat_fromto failed!\n", chanwords[0] );
				VPRINT("\tfrom", from);
				VPRINT("\tto", to);
				VPRINT("\tgot", got);
			}
		}
		out_mat( mat, stdout );
		return 0;
	}
	return(-2);		/* Unknown keyword */
}

/*
 *			S T R 2 C H A N _ I N D E X
 *
 *  Convert an ascii string to a channel index.
 *  Specifying channel 0 selects column (and thus subscript) 1,
 *  because column 0 contains the current time.
 *  Thus, valid channel values are 0 through nwords-2,
 *  resulting in column numbers 1 through nwords-1.
 *
 *  To signal an error, 0 is returned;  this will index the time column.
 */
int
str2chan_index( char *s )
{
	int	chan;

	chan = atoi( s );
	if( chan < 0 || chan > nwords-2 )  {
		fprintf(stderr,"Line %d:  chan %d out of range 0..%d\n", line, chan, nwords-2 );
		return(0);		/* Flag [0]:  time channel */
	}
	return(chan+1);
}

void
out_mat(matp_t m, FILE *fp)
{
	fprintf( fp, "\t%.9e %.9e %.9e %.9e\n", m[0], m[1], m[2], m[3] );
	fprintf( fp, "\t%.9e %.9e %.9e %.9e\n", m[4], m[5], m[6], m[7] );
	fprintf( fp, "\t%.9e %.9e %.9e %.9e\n", m[8], m[9], m[10], m[11] );
	fprintf( fp, "\t%.9e %.9e %.9e %.9e", m[12], m[13], m[14], m[15] );
}
@


11.18
log
@change conf.h to a wrapped config.h
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/tab/tabsub.c,v 11.17 2004/04/05 05:46:00 morrison Exp $ (ARL)";
@


11.17
log
@merge of ansi-6-0-branch into head
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d32 5
a36 1
#include "conf.h"
@


11.16
log
@update copyright to include span through 2003
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.15 2002/08/20 17:08:46 jra Exp $ (ARL)";
d58 3
a60 3
void	get_proto();
void	do_lines();
void	out_mat();
d70 1
a70 3
main( argc, argv )
int	argc;
char	**argv;
d95 1
a95 2
get_proto( file )
char	*file;
d127 1
a127 2
do_lines( fp )
FILE	*fp;
d494 1
a494 3
out_mat( m, fp )
matp_t	m;
FILE	*fp;
@


11.15
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1998 by the United States Army
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.13 2001/08/10 19:00:52 jra Exp $ (ARL)";
@


11.15.4.1
log
@sync to HEAD...
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/tab/tabsub.c,v 11.16 2004/02/02 17:39:42 morrison Exp $ (ARL)";
@


11.15.10.1
log
@merge from HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.16 2004/02/02 17:39:42 morrison Exp $ (ARL)";
@


11.15.10.2
log
@merge from head
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.15.10.1 2004/02/12 19:42:56 erikg Exp $ (ARL)";
@


11.15.2.1
log
@Initial ANSIfication
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.15 2002/08/20 17:08:46 jra Exp $ (ARL)";
d58 3
a60 3
void	get_proto(char *file);
void	do_lines(FILE *fp);
void	out_mat(matp_t m, FILE *fp);
d70 3
a72 1
main(int argc, char **argv)
d97 2
a98 1
get_proto(char *file)
d130 2
a131 1
do_lines(FILE *fp)
d498 3
a500 1
out_mat(matp_t m, FILE *fp)
@


11.15.2.2
log
@sync branch with HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.14
log
@Converted from K&R to ANSI C - RFH
@
text
@d58 3
a60 3
void	get_proto(char *file);
void	do_lines(FILE *fp);
void	out_mat(matp_t m, FILE *fp);
d70 3
a72 1
main(int argc, char **argv)
d97 2
a98 1
get_proto(char *file)
d130 2
a131 1
do_lines(FILE *fp)
d498 3
a500 1
out_mat(matp_t m, FILE *fp)
@


11.13
log
@lint
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.12 2001/03/31 01:57:37 morrison Exp $ (ARL)";
d58 3
a60 3
void	get_proto();
void	do_lines();
void	out_mat();
d70 1
a70 3
main( argc, argv )
int	argc;
char	**argv;
d95 1
a95 2
get_proto( file )
char	*file;
d127 1
a127 2
do_lines( fp )
FILE	*fp;
d494 1
a494 3
out_mat( m, fp )
matp_t	m;
FILE	*fp;
@


11.12
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.11 2000/10/24 19:38:31 mike Exp $ (ARL)";
d33 6
@


11.11
log
@
lint
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.10 2000/08/31 19:35:06 mike Exp $ (ARL)";
d264 1
a264 1
		bn_mat_idn( mat );
d277 1
a277 1
		bn_mat_idn( mat );
d298 3
a300 3
		bn_mat_idn( mat1 );
		bn_mat_idn( mat2 );
		bn_mat_idn( mat3 );
d337 1
a337 1
		bn_mat_idn( mat );
d365 1
a365 1
		bn_mat_idn( mat );
d384 1
a384 1
		bn_mat_idn( mat );
d401 1
a401 1
		bn_mat_idn( mat );
@


11.10
log
@
"../tab/tabsub.c": Warning: Attempted divide by zero
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.9 2000/08/24 23:02:09 mike Exp $ (ARL)";
d55 3
d256 1
a256 3
multi_words( words, nwords )
char	*words[];
int	nwords;
d479 1
a479 2
str2chan_index( s )
char	*s;
@


11.9
log
@
lint
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.8 2000/08/24 23:01:02 mike Exp $ (ARL)";
d339 1
a339 1
		if( args[7] > -1e-17 && args[7] < 1e-17 )  {
@


11.8
log
@
lint
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.7 2000/01/31 16:13:08 jra Exp $ (ARL)";
d60 1
d84 1
@


11.7
log
@Eliminated an unused variable
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.6 1999/12/20 20:58:46 mike Exp $ (ARL)";
@


11.6
log
@
A vain attempt to eliminate "Warning: Attempted divide by zero" message
from m4i64 compiler.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.5 1999/05/21 05:02:29 mike Exp $ (ARL)";
d350 1
a350 1
		fastf_t	az, el, twist;
d356 1
d361 1
@


11.5
log
@
Changed to Release 5.0 function names.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.4 1999/05/21 04:59:15 mike Exp $ (ARL)";
d331 1
a331 1
		args[7] = 1.0;	/* optional */
d342 2
a344 1
		mat[15] = 1 / args[7];
@


11.4
log
@
Added two new commands to tabsub, mirroring the routine bn_mat_arb_rot().
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d100 1
a100 1
	prototype = rt_malloc( sb.st_size+4, "prototype document");
d261 2
a262 2
		mat_idn( mat );
		mat_angles( mat, 
d274 1
a274 1
		mat_idn( mat );
d295 3
a297 3
		mat_idn( mat1 );
		mat_idn( mat2 );
		mat_idn( mat3 );
d304 1
a304 1
		mat_angles( mat2, 
d314 2
a315 2
		mat_mul( mat, mat2, mat1 );
		mat_mul2( mat3, mat );
d334 2
a335 2
		mat_idn( mat );
		mat_angles( mat, args[4], args[5], args[6] );
d359 1
a359 1
		mat_idn( mat );
d361 1
a361 1
		mat_ae( mat, az, el );
d378 1
a378 1
		mat_idn( mat );
d395 1
a395 1
		mat_idn( mat );
d442 1
a442 1
		mat_fromto( mat, from, to );
d449 1
a449 1
				rt_log("\ntabsub ERROR: At t=%s, mat_fromto failed!\n", chanwords[0] );
@


11.3
log
@Removed irritating debug printf
@
text
@d16 2
a17 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d19 5
d25 2
a26 2
 *	This software is Copyright (C) 1988 by the United States Army.
 *	All rights reserved.
d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/tab/tabsub.c,v 11.2 1996/07/17 14:43:08 jra Exp $ (BRL)";
d259 1
a259 1
		/* Expects rotations rx, ry, rz */
d362 35
@


11.2
log
@Minor Mods for IRIX 6.2
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabsub.c,v 11.1 1995/01/04 10:19:32 mike Rel4_4 jra $ (BRL)";
a354 1
fprintf(stderr,"az=%g, el=%g, twist=%g\n", az, el, twist);
@


11.1
log
@Release_4.4
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabsub.c,v 10.7 94/11/14 23:23:48 mike Exp $ (BRL)";
d48 3
d81 1
d114 1
d448 1
@


10.7
log
@Irix 6
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabsub.c,v 10.6 94/08/11 18:07:15 gdurf Exp Locker: mike $ (BRL)";
@


10.6
log
@Factored ifdefs
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabsub.c,v 10.5 1994/08/11 18:06:01 gdurf Exp gdurf $ (BRL)";
a117 1
	int	chan;
a273 1
		register int i;
@


10.5
log
@Changes by phil
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabsub.c,v 10.4 92/11/20 21:36:03 mike Exp $ (BRL)";
d28 2
d33 5
d40 1
a42 5

#if defined(unix) || defined(__unix) || defined(__unix__)
# include <sys/types.h>
# include <sys/stat.h>
#endif
@


10.4
log
@For macros which take arguments, allow "@@" to indicate
channel number, rather than the old "%" notation.
e.g., @@(xlate @@3 @@4 29)
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabsub.c,v 10.3 92/08/28 01:47:21 mike Exp Locker: mike $ (BRL)";
d268 39
@


10.3
log
@Added "fromto" keyword.  When used with tabinterp's "next" feature,
can be used to have an object's orientation follow it's flightpath.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabsub.c,v 10.2 92/08/27 22:48:03 mike Exp Locker: mike $ (BRL)";
d195 1
a195 1
			/*  If first character of a word is '%', that
d200 1
d202 2
a203 1
				if( tokenwords[i][0] != '%' )  continue;
@


10.2
log
@Added "quat" command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabsub.c,v 10.1 91/10/12 06:51:22 mike Rel4_0 Locker: mike $ (BRL)";
d326 45
@


10.1
log
@Release_4.0
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabsub.c,v 1.11 91/09/27 05:52:51 butler Exp $ (BRL)";
d314 13
@


1.11
log
@added __unix__ from convex
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabsub.c,v 1.10 91/07/06 00:34:48 mike Exp Locker: butler $ (BRL)";
@


1.10
log
@unix --> __unix in ANSI
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/tab/RCS/tabsub.c,v 1.9 91/07/01 21:27:38 mike Exp $ (BRL)";
d36 1
a36 1
#if defined(unix) || defined(__unix)
@


1.9
log
@Added beginnings of an "ae" command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/rots/RCS/tabsub.c,v 1.8 90/11/04 10:42:34 mike Exp $ (BRL)";
d36 1
a36 1
#ifdef unix
@


1.8
log
@Prototypes can have '#' (comments) in them now.
I have no idea why I prohibited that, first go around.

Also fixed memory over-run.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/rots/RCS/tabsub.c,v 1.7 90/11/03 21:52:33 mike Exp $ (BRL)";
d293 19
@


1.7
log
@Fixed diagnostic
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/rots/RCS/tabsub.c,v 1.6 90/11/03 19:52:41 mike Exp $ (BRL)";
a79 2
	char	*proto;
	register char	*ip, *op;
d89 2
a90 3
	prototype = rt_malloc( sb.st_size, "prototype document");
	proto = rt_malloc( sb.st_size, "temporary prototype document");
	if( read( fd, proto, sb.st_size ) != sb.st_size )  {
d94 1
a94 15

	/* Eliminate comments from input */
	ip = proto;
	op = prototype;
	while( *ip )  {
		if( *ip != '#' )  {
			*op++ = *ip++;
			continue;
		}
		/* Start of comment seen, gobble until newline or EOF */
		ip++;
		while( *ip && *ip != '\n' )
			ip++;
	}
	rt_free( proto, "temporary prototype document" );
@


1.6
log
@This version works as well as the previous version did
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/rots/RCS/tabsub.c,v 1.5 89/12/29 14:56:45 mike Exp $ (BRL)";
d305 2
a306 1
			fprintf(stderr,"Line %d, orient scale arg '%s' is zero\n", words[7] );
@


1.5
log
@Fixed pointer declaration botch
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: tabsub.c,v 1.4 89/01/09 06:30:10 mike Locked $ (BRL)";
d41 1
d127 2
a128 1
	char	token[128];
d133 1
d147 5
d156 1
d176 1
a176 1
				while( *cp && *cp != ')' )
d178 1
d183 1
a183 1
				while( isdigit( *cp ) )
d185 1
d192 1
d209 2
a210 1
			ntokenwords = rt_split_cmd( tokenwords, NTOKENWORDS+1, token );
d212 10
a221 2
			if( strcmp( tokenwords[0], "rot" ) == 0 )  {
				mat_t	mat;
d223 1
a223 6
				mat_idn( mat );
				mat_angles( mat, 
				    atof( chanwords[str2chan_index(tokenwords[1])] ),
				    atof( chanwords[str2chan_index(tokenwords[2])] ),
				    atof( chanwords[str2chan_index(tokenwords[3])] ) );
				out_mat( mat, stdout );
a224 3
			}
			if( strcmp( tokenwords[0], "xlate" ) == 0 )  {
				mat_t	mat;
d226 12
a237 7
				mat_idn( mat );
				MAT_DELTAS( mat, 
				    atof( chanwords[str2chan_index(tokenwords[1])] ),
				    atof( chanwords[str2chan_index(tokenwords[2])] ),
				    atof( chanwords[str2chan_index(tokenwords[3])] ) );
				out_mat( mat, stdout );
				continue;
d239 8
d248 59
a306 2
			fprintf(stderr,"Line %d: keyword @@(%s) unknown\n", line, token);
			fprintf(stdout, "@@(%s)", token );
d308 3
d312 1
@


1.4
log
@Added xlate keyword
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: tabsub.c,v 1.3 89/01/07 04:14:58 mike Locked $ (BRL)";
d117 1
a117 1
char	**chanwords[NCHANS+1];
d121 1
a121 1
char	**tokenwords[NTOKENWORDS+1];
d239 1
@


1.3
log
@Removed comments from prototype file before expanding.
Neatened matrix output routine.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: tabsub.c,v 1.2 89/01/02 07:04:54 mike Locked $ (BRL)";
d204 11
@


1.2
log
@this version seems to work!
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: tabsub.c,v 1.1 89/01/02 04:40:21 mike Locked $ (BRL)";
d79 2
d91 2
a92 1
	if( read( fd, prototype, sb.st_size ) != sb.st_size )  {
d96 15
d144 1
a144 1
		/* Here, there is not way to check for too many words */
d245 4
a248 7
	register int	i;

	for( i=0; i < 16; i++ )  {
		(void)fprintf( fp, "%.9e ", m[i] );
		if( (i%4) == 3 )
			(void)fprintf(fp, "\n");
	}
@


1.1
log
@Initial revision
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: tabinterp.c,v 1.9 89/01/02 03:23:51 mike Locked $ (BRL)";
d97 2
d100 1
d102 3
a107 1
	int	line;
d109 1
a111 1
	int	nwords;
d165 2
a166 8
				chan = atoi(token);
				if( chan < 0 || chan > nwords-2 )  {
					fprintf(stderr,"Line %d:  chan %d out of range 0..%d\n", line, chan, nwords-2 );
					fprintf(stdout,"@@(%d)", chan);
					continue;
				}
				/* [0] has the time */
				fputs( chanwords[chan+1], stdout );
d177 16
d196 37
@
