head	11.21;
access;
symbols
	ansi-20040405-merged:11.18.2.1
	postmerge-20040405-ansi:11.19
	premerge-20040404-ansi:11.18
	postmerge-autoconf:11.18
	autoconf-freeze:11.18
	premerge-autoconf:11.18
	ansi-20040316-freeze:11.18.2.1
	postmerge-20040315-windows:11.18
	premerge-20040315-windows:11.18
	windows-20040315-freeze:11.18
	autoconf-20031203:11.18
	autoconf-20031202:11.18
	autoconf-branch:11.18.0.10
	phong-branch:11.18.0.8
	photonmap-branch:11.18.0.6
	rel-6-1-DP:11.18
	windows-branch:11.18.0.4
	rel-6-0-2:11.16
	ansi-branch:11.18.0.2
	rel-6-0-1-branch:11.16.0.2
	hartley-6-0-post:11.17
	hartley-6-0-pre:11.16
	rel-6-0-1:11.16
	rel-6-0:11.16
	rel-5-4:11.10
	offsite-5-3-pre:11.13
	rel-5-3:11.10
	rel-5-2:11.10
	rel-5-1-branch:11.10.0.2
	rel-5-1:11.10
	rel-5-0:11.7
	rel-5-0-beta:11.7
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.21
date	2004.05.21.17.49.01;	author morrison;	state dead;
branches;
next	11.20;

11.20
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.19;

11.19
date	2004.04.05.07.47.38;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2002.08.20.17.07.32;	author jra;	state Exp;
branches
	11.18.2.1;
next	11.17;

11.17
date	2002.08.15.20.54.45;	author hartley;	state Exp;
branches;
next	11.16;

11.16
date	2001.08.11.13.11.14;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	2001.05.17.20.05.10;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2001.04.05.19.35.21;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2000.11.02.02.17.01;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.09.08.05.56.48;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.08.24.04.55.34;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.01.31.15.29.45;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	2000.01.04.17.58.20;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	99.12.29.23.23.14;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.05.10.21.56.45;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.07.15.18.22.38;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.06.20.01.09.41;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.02.25.03.18.00;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.02.22.05.29.15;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.02.17.01.17.32;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.06.25;	author mike;	state Rel4_4;
branches;
next	1.32;

1.32
date	94.12.19.18.04.33;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	94.12.08.17.55.20;	author jra;	state Exp;
branches;
next	1.30;

1.30
date	94.11.08.04.25.03;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	94.07.04.02.31.02;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	94.07.04.00.02.17;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	94.07.03.23.47.12;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	94.02.24.00.30.16;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	93.12.14.18.40.34;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	93.11.13.00.09.14;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	93.11.12.23.12.37;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	93.10.28.23.53.07;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	93.10.28.23.51.39;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	93.10.28.22.44.36;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	93.10.28.20.47.25;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	93.04.03.05.00.32;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	93.04.03.04.35.58;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	93.04.03.04.11.08;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	93.04.03.04.03.40;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	93.04.03.03.53.40;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	93.04.03.03.40.10;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	93.03.25.21.10.03;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	93.03.22.23.39.04;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	93.03.18.15.38.23;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	93.03.17.05.37.03;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	93.03.17.05.28.51;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	93.03.08.22.55.55;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	93.02.24.20.43.24;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	93.01.22.21.58.13;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	92.12.14.18.10.20;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	92.11.16.14.56.03;	author mm;	state Exp;
branches;
next	1.2;

1.2
date	92.11.11.00.01.08;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	92.11.10.22.39.36;	author mm;	state Exp;
branches;
next	;

11.18.2.1
date	2002.09.19.18.01.01;	author morrison;	state Exp;
branches;
next	;


desc
@BRL-CAD .g to JACK Psurf converter
@


11.21
log
@moved to src/jack/
@
text
@/*
 *			G - J A C K . C
 *
 *  Program to convert a BRL-CAD model (in a .g file) to a JACK Psurf file,
 *  by calling on the NMG booleans.
 *
 *  Author -
 *	Michael J. Markowski
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/jack/g-jack.c,v 11.20 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "plot3.h"
#include "../librt/debug.h"

RT_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data));
void	nmg_to_psurf(struct nmgregion *r, FILE *fp_psurf);
void	jack_faces(struct nmgregion *r, FILE *fp_psurf, int *map);

extern double nmg_eue_dist;		/* from nmg_plot.c */

static char	usage[] = "\
Usage: %s [-v] [-d] [-f] [-xX lvl] [-u eu_dist]\n\
	[-a abs_tess_tol] [-r rel_tess_tol] [-n norm_tess_tol]\n\
	[-D dist_calc_tol]\n\
	[-p prefix] brlcad_db.g object(s)\n";

static int	NMG_debug;	/* saved arg of -X, for longjmp handling */
static int	verbose;
static int	no_file_output=0;	/* -f:  Don't bother writing output files */
static int	debug_plots;	/* Make debugging plots */
static int	ncpu = 1;	/* Number of processors */
static char	*prefix = NULL;	/* output filename prefix. */
static FILE	*fp_fig;	/* Jack Figure file. */
static struct db_i		*dbip;
static struct rt_vls		base_seg;
static struct rt_tess_tol	ttol;
static struct rt_tol		tol;
static struct model		*the_model;

static struct db_tree_state	jack_tree_state;	/* includes tol & model */

static int	regions_tried = 0;
static int	regions_done = 0;

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	char		*dot;
	register int	c;
	double		percent;
	struct rt_vls	fig_file;

#ifdef BSD
	setlinebuf( stderr );
#else
#	if defined( SYSV ) && !defined( sgi ) && !defined(CRAY2) && \
	 !defined(n16)
		(void) setvbuf( stderr, (char *) NULL, _IOLBF, BUFSIZ );
#	endif
#	if defined(sgi) && defined(mips)
		if( setlinebuf( stderr ) != 0 )
			perror("setlinebuf(stderr)");
#	endif
#endif

#if MEMORY_LEAK_CHECKING
	rt_g.debug |= DEBUG_MEM_FULL;
#endif
	jack_tree_state = rt_initial_tree_state;	/* struct copy */
	jack_tree_state.ts_tol = &tol;
	jack_tree_state.ts_ttol = &ttol;
	jack_tree_state.ts_m = &the_model;

	ttol.magic = RT_TESS_TOL_MAGIC;
	/* Defaults, updated by command line options. */
	ttol.abs = 0.0;
	ttol.rel = 0.01;
	ttol.norm = 0.0;

	/* XXX These need to be improved */
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-5;
	tol.para = 1 - tol.perp;

	/* XXX For visualization purposes, in the debug plot files */
	{
		extern fastf_t	nmg_eue_dist;	/* librt/nmg_plot.c */
		/* XXX This value is specific to the Bradley */
		/* Set it here, before the getopt() */
		nmg_eue_dist = 2.0;
	}

	rt_init_resource( &rt_uniresource, 0, NULL );

	the_model = nmg_mm();
	RT_LIST_INIT( &rt_g.rtg_vlfree );	/* for vlist macros */

	/* Get command line arguments. */
	while ((c = getopt(argc, argv, "a:dfn:p:r:u:vx:D:P:X:")) != EOF) {
		switch (c) {
		case 'a':		/* Absolute tolerance. */
			ttol.abs = atof(optarg);
			break;
		case 'd':
			debug_plots = 1;
			break;
		case 'f':
			no_file_output = 1;
			break;
		case 'n':		/* Surface normal tolerance. */
			ttol.norm = atof(optarg);
			break;
		case 'p':		/* Prefix for Jack file names. */
			prefix = optarg;
			break;
		case 'r':		/* Relative tolerance. */
			ttol.rel = atof(optarg);
			break;
		case 'u':
			nmg_eue_dist = atof(optarg);
			break;
		case 'v':
			verbose++;
			break;
		case 'P':
			ncpu = atoi( optarg );
			rt_g.debug = 1;	/* XXX DEBUG_ALLRAYS -- to get core dumps */
			break;
		case 'x':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
			break;
		case 'D':
			tol.dist = atof(optarg);
			tol.dist_sq = tol.dist * tol.dist;
			rt_pr_tol( &tol );
			break;
		case 'X':
			sscanf( optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
			NMG_debug = rt_g.NMG_debug;
			break;
		default:
			fprintf(stderr, usage, argv[0]);
			exit(1);
			break;
		}
	}

	if (optind+1 >= argc) {
		fprintf(stderr, usage, argv[0]);
		exit(1);
	}

	/* Open brl-cad database */
	argc -= optind;
	argv += optind;
	if ((dbip = db_open(argv[0], "r")) == DBI_NULL) {
		perror(argv[0]);
		exit(1);
	}
	db_dirbuild(dbip);

	/* Create .fig file name and open it. */
	rt_vls_init( &fig_file );
	/* Ignore leading path name. */
	if ((dot = strrchr(argv[0], '/')) != (char *)NULL) {
		if (prefix)
			rt_vls_strcpy( &fig_file, prefix );
		rt_vls_strcat( &fig_file, dot+1 );
	} else {
		if (prefix)
			rt_vls_strcpy( &fig_file, prefix );
		rt_vls_strcat( &fig_file, argv[0] );
	}

	/* Get rid of any file name extension (probably .g). */
	if ((dot = strrchr(rt_vls_addr(&fig_file), '.')) != (char *)NULL)  {
		*dot = (char)NULL;
		/* Recalculate shorter VLS length.  Ugh. */
		rt_vls_trunc( &fig_file, dot - rt_vls_addr(&fig_file) );
	}
	rt_vls_strcat( &fig_file, ".fig");	/* Add required Jack suffix. */

	if ((fp_fig = fopen(rt_vls_addr(&fig_file), "w")) == NULL)  {
		perror(rt_vls_addr(&fig_file));
		return 2;
	}
	fprintf(fp_fig, "figure {\n");
	rt_vls_init(&base_seg);		/* .fig figure file's main segment. */

RT_CK_TOL(jack_tree_state.ts_tol);
RT_CK_TESS_TOL(jack_tree_state.ts_ttol);

	/* Walk indicated tree(s).  Each region will be output separately */
	(void) db_walk_tree(dbip, argc-1, (const char **)(argv+1),
		1,			/* ncpu */
		&jack_tree_state,
		0,			/* take all regions */
		do_region_end,
		nmg_booltree_leaf_tess,
		(genptr_t)NULL);	/* in librt/nmg_bool.c */

	fprintf(fp_fig, "\troot=%s_seg.base;\n", rt_vls_addr(&base_seg));
	fprintf(fp_fig, "}\n");
	fclose(fp_fig);
	rt_vls_free(&fig_file);
	rt_vls_free(&base_seg);

	percent = 0;
	if(regions_tried>0)  percent = ((double)regions_done * 100) / regions_tried;
	printf("Tried %d regions, %d converted successfully.  %g%%\n",
		regions_tried, regions_done, percent);

	/* Release dynamic storage */
	nmg_km(the_model);
	rt_vlist_cleanup();
	db_close(dbip);

#if MEMORY_LEAK_CHECKING
	rt_prmem("After complete G-JACK conversion");
#endif

	return 0;
}

/*
*			D O _ R E G I O N _ E N D
*
*  Called from db_walk_tree().
*
*  This routine must be prepared to run in parallel.
*/
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	extern FILE		*fp_fig;
	union tree		*ret_tree;
	struct rt_list		vhead;
	struct nmgregion	*r;

	RT_CK_FULL_PATH(pathp);
	RT_CK_TREE(curtree);
	RT_CK_TESS_TOL(tsp->ts_ttol);
	RT_CK_TOL(tsp->ts_tol);
	NMG_CK_MODEL(*tsp->ts_m);

	RT_LIST_INIT(&vhead);

	if (RT_G_DEBUG&DEBUG_TREEWALK || verbose) {
		char	*sofar = db_path_to_string(pathp);
		rt_log("\ndo_region_end(%d %d%%) %s\n",
			regions_tried,
			regions_tried>0 ? (regions_done * 100) / regions_tried : 0,
			sofar);
		rt_free(sofar, "path string");
	}

	if (curtree->tr_op == OP_NOP)
		return  curtree;

	regions_tried++;
	/* Begin rt_bomb() protection */
	if( ncpu == 1 ) {
		if( RT_SETJUMP )  {
			/* Error, bail out */
			RT_UNSETJUMP;		/* Relinquish the protection */

			/* Sometimes the NMG library adds debugging bits when
			 * it detects an internal error, before rt_bomb().
			 */
			rt_g.NMG_debug = NMG_debug;	/* restore mode */

			/* Release any intersector 2d tables */
			nmg_isect2d_final_cleanup();

			/* Release the tree memory & input regions */
			db_free_tree(curtree, &rt_uniresource);		/* Does an nmg_kr() */

			/* Get rid of (m)any other intermediate structures */
			if( (*tsp->ts_m)->magic == NMG_MODEL_MAGIC )  {
				nmg_km(*tsp->ts_m);
			} else {
				rt_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
			}

			/* Now, make a new, clean model structure for next pass. */
			*tsp->ts_m = nmg_mm();
			goto out;
		}
	}
	ret_tree = nmg_booltree_evaluate( curtree, tsp->ts_tol, &rt_uniresource );	/* librt/nmg_bool.c */
	RT_UNSETJUMP;		/* Relinquish the protection */
	if( ret_tree )
		r = ret_tree->tr_d.td_r;
	else
		r = (struct nmgregion *)NULL;
	regions_done++;
	if( r && !no_file_output )  {
		FILE	*fp_psurf;
		int	i;
		struct rt_vls	file_base;
		struct rt_vls	file;

		rt_vls_init(&file_base);
		rt_vls_init(&file);
		rt_vls_strcpy(&file_base, prefix);
		rt_vls_strcat(&file_base, DB_FULL_PATH_CUR_DIR(pathp)->d_namep);
		/* Dots confuse Jack's Peabody language.  Change to '_'. */
		for (i = 0; i < file_base.vls_len; i++)
			if (file_base.vls_str[i] == '.')
				file_base.vls_str[i] = '_';

		/* Write color attribute to .fig figure file. */
		if (tsp->ts_mater.ma_color_valid != 0) {
			fprintf(fp_fig, "\tattribute %s {\n",
				rt_vls_addr(&file_base));
			fprintf(fp_fig, "\t\trgb = (%f, %f, %f);\n",
				V3ARGS(tsp->ts_mater.ma_color));
			fprintf(fp_fig, "\t\tambient = 0.18;\n");
			fprintf(fp_fig, "\t\tdiffuse = 0.72;\n");
			fprintf(fp_fig, "\t}\n");
		}

		/* Write segment attributes to .fig figure file. */
		fprintf(fp_fig, "\tsegment %s_seg {\n", rt_vls_addr(&file_base));
		fprintf(fp_fig, "\t\tpsurf=\"%s.pss\";\n", rt_vls_addr(&file_base));
		if (tsp->ts_mater.ma_color_valid != 0)
			fprintf(fp_fig,
				"\t\tattribute=%s;\n", rt_vls_addr(&file_base));
		fprintf(fp_fig, "\t\tsite base->location=trans(0,0,0);\n");
		fprintf(fp_fig, "\t}\n");

		if( rt_vls_strlen(&base_seg) <= 0 )  {
			rt_vls_vlscat( &base_seg, &file_base );
		} else {
			fprintf(fp_fig, "\tjoint %s_jt {\n",
				rt_vls_addr(&file_base));
			fprintf(fp_fig,
				"\t\tconnect %s_seg.base to %s_seg.base;\n",
				rt_vls_addr(&file_base),
				rt_vls_addr(&base_seg) );
			fprintf(fp_fig, "\t}\n");
		}

		rt_vls_vlscat(&file, &file_base);
		rt_vls_strcat(&file, ".pss");	/* Required Jack suffix. */

		/* Write psurf to .pss file. */
		if ((fp_psurf = fopen(rt_vls_addr(&file), "w")) == NULL)
			perror(rt_vls_addr(&file));
		else {
			nmg_to_psurf(r, fp_psurf);
			fclose(fp_psurf);
			if(verbose) rt_log("*** Wrote %s\n", rt_vls_addr(&file));
		}
		rt_vls_free(&file);

		/* Also write as UNIX-plot file, if desired */
		if( debug_plots )  {
			FILE	*fp;
			rt_vls_vlscat(&file, &file_base);
			rt_vls_strcat(&file, ".pl");

			if ((fp = fopen(rt_vls_addr(&file), "w")) == NULL)
				perror(rt_vls_addr(&file));
			else {
				struct rt_list	vhead;
				pl_color( fp,
					(int)(tsp->ts_mater.ma_color[0] * 255),
					(int)(tsp->ts_mater.ma_color[1] * 255),
					(int)(tsp->ts_mater.ma_color[2] * 255) );
				/* nmg_pl_r( fp, r ); */
				RT_LIST_INIT( &vhead );
				nmg_r_to_vlist( &vhead, r, 0 );
				rt_vlist_to_uplot( fp, &vhead );
				fclose(fp);
				RT_FREE_VLIST( &vhead );
				if(verbose) rt_log("*** Wrote %s\n", rt_vls_addr(&file));
			}
			rt_vls_free(&file);
		}
		rt_vls_free(&file_base);
	}
	if( no_file_output )  {
		if(verbose) rt_log("*** Completed %s\n",
			DB_FULL_PATH_CUR_DIR(pathp)->d_namep );
	}

	/*
	 *  Dispose of original tree, so that all associated dynamic
	 *  memory is released now, not at the end of all regions.
	 *  A return of TREE_NULL from this routine signals an error,
	 *  and there is no point to adding _another_ message to our output,
	 *  so we need to cons up an OP_NOP node to return.
	 */
	db_free_tree(curtree, &rt_uniresource);		/* Does an nmg_kr() */

out:
	GETUNION(curtree, tree);
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;
	return(curtree);
}

/*
*	N M G _ T O _ P S U R F
*
*	Convert an nmg region into Jack format.  This routine makes a
*	list of unique vertices and writes them to the ascii Jack
*	data base file.  Then a routine to generate the face vertex
*	data is called.
*/

void
nmg_to_psurf(struct nmgregion *r, FILE *fp_psurf)
                    		/* NMG region to be converted. */
    		          	/* Jack format file to write vertex list to. */
{
	int			i;
	int			*map;	/* map from v->index to Jack vert # */
	struct nmg_ptbl		vtab;	/* vertex table */

	map = (int *)rt_calloc(r->m_p->maxindex, sizeof(int *), "Jack vert map");

	/* Built list of vertex structs */
	nmg_vertex_tabulate( &vtab, &r->l.magic );

	/* XXX What to do if 0 vertices?  */

	/* Print list of unique vertices and convert from mm to cm. */
	for (i = 0; i < NMG_TBL_END(&vtab); i++)  {
		struct vertex			*v;
		register struct vertex_g	*vg;
		v = (struct vertex *)NMG_TBL_GET(&vtab,i);
		NMG_CK_VERTEX(v);
		vg = v->vg_p;
		NMG_CK_VERTEX_G(vg);
		NMG_INDEX_ASSIGN( map, v, i+1 );  /* map[v->index] = i+1 */
		fprintf(fp_psurf, "%f\t%f\t%f\n",
			vg->coord[X] / 10.,
			vg->coord[Y] / 10.,
			vg->coord[Z] / 10.);
	}
	fprintf(fp_psurf, ";;\n");

	jack_faces(r, fp_psurf, map);

	nmg_tbl( &vtab, TBL_FREE, 0 );
	rt_free( (char *)map, "Jack vert map" );
}


/*
*	J A C K _ F A C E S
*
*	Continues the conversion of an nmg into Jack format.  Before
*	this routine is called, a list of unique vertices has been
*	stored in a heap.  Using this heap and the nmg structure, a
*	list of face vertices is written to the Jack data base file.
*/
void
jack_faces(struct nmgregion *r, FILE *fp_psurf, int *map)
                    		/* NMG region to be converted. */
    		          	/* Jack format file to write face vertices to. */
   		     
{
	struct edgeuse		*eu;
	struct faceuse		*fu;
	struct loopuse		*lu;
	struct shell		*s;
	struct vertex		*v;

	for (RT_LIST_FOR(s, shell, &r->s_hd)) {
		/* Shell is made of faces. */
		for (RT_LIST_FOR(fu, faceuse, &s->fu_hd)) {
			NMG_CK_FACEUSE(fu);
			if (fu->orientation != OT_SAME)
				continue;
			for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
				NMG_CK_LOOPUSE(lu);
				if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
					for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
						NMG_CK_EDGEUSE(eu);
						NMG_CK_EDGE(eu->e_p);
						NMG_CK_VERTEXUSE(eu->vu_p);
						NMG_CK_VERTEX(eu->vu_p->v_p);
						NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
		    				fprintf(fp_psurf, "%d ", NMG_INDEX_GET(map,eu->vu_p->v_p));
					}
				} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
		  			== NMG_VERTEXUSE_MAGIC) {
		  			v = RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
					NMG_CK_VERTEX(v);
					NMG_CK_VERTEX_G(v->vg_p);
		  			fprintf(fp_psurf, "%d ", NMG_INDEX_GET(map,v));
				} else
					rt_log("jack_faces: loopuse mess up! (1)\n");
				fprintf(fp_psurf, ";\n");
			}
		}

		/* Shell contains loops. */
		for (RT_LIST_FOR(lu, loopuse, &s->lu_hd)) {
			NMG_CK_LOOPUSE(lu);
			if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
				for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
					NMG_CK_EDGEUSE(eu);
					NMG_CK_EDGE(eu->e_p);
					NMG_CK_VERTEXUSE(eu->vu_p);
					NMG_CK_VERTEX(eu->vu_p->v_p);
					NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
		  			fprintf(fp_psurf, "%d ", NMG_INDEX_GET(map,eu->vu_p->v_p));
				}
			} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
				== NMG_VERTEXUSE_MAGIC) {
				v = RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
				NMG_CK_VERTEX(v);
				NMG_CK_VERTEX_G(v->vg_p);
				fprintf(fp_psurf, "%d ", NMG_INDEX_GET(map,v));
			} else
				rt_log("jack_faces: loopuse mess up! (1)\n");
			fprintf(fp_psurf, ";\n");
		}

		/* Shell contains edges. */
		for (RT_LIST_FOR(eu, edgeuse, &s->eu_hd)) {
			NMG_CK_EDGEUSE(eu);
			NMG_CK_EDGE(eu->e_p);
			NMG_CK_VERTEXUSE(eu->vu_p);
			NMG_CK_VERTEX(eu->vu_p->v_p);
			NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
			fprintf(fp_psurf, "%d ", NMG_INDEX_GET(map,eu->vu_p->v_p));
		}
		if (RT_LIST_FIRST_MAGIC(&s->eu_hd) == NMG_EDGEUSE_MAGIC)
			fprintf(fp_psurf, ";\n");

		/* Shell contains a single vertex. */
		if (s->vu_p) {
			NMG_CK_VERTEXUSE(s->vu_p);
			NMG_CK_VERTEX(s->vu_p->v_p);
			NMG_CK_VERTEX_G(s->vu_p->v_p->vg_p);
			fprintf(fp_psurf, "%d;\n", NMG_INDEX_GET(map,s->vu_p->v_p));
		}

		if (RT_LIST_IS_EMPTY(&s->fu_hd) &&
			RT_LIST_IS_EMPTY(&s->lu_hd) &&
			RT_LIST_IS_EMPTY(&s->eu_hd) && !s->vu_p) {
			rt_log("WARNING jack_faces: empty shell\n");
		}

	}
	fprintf(fp_psurf, ";;\n");
}
@


11.20
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/jack/g-jack.c,v 11.19 2004/04/05 07:47:38 morrison Exp $ (BRL)";
@


11.19
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d22 5
a26 1
#include "conf.h"
@


11.18
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jack/g-jack.c,v 11.16 2001/08/11 13:11:14 butler Exp $ (BRL)";
d41 2
a42 2
void	nmg_to_psurf();
void	jack_faces();
d74 1
a74 3
main(argc, argv)
int	argc;
char	*argv[];
d262 1
a262 5
union tree *do_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d443 3
a445 3
nmg_to_psurf(r, fp_psurf)
struct nmgregion *r;		/* NMG region to be converted. */
FILE		*fp_psurf;	/* Jack format file to write vertex list to. */
d490 4
a493 4
jack_faces(r, fp_psurf, map)
struct nmgregion *r;		/* NMG region to be converted. */
FILE		*fp_psurf;	/* Jack format file to write face vertices to. */
int		*map;
@


11.18.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jack/g-jack.c,v 11.18 2002/08/20 17:07:32 jra Exp $ (BRL)";
d41 2
a42 2
void	nmg_to_psurf(struct nmgregion *r, FILE *fp_psurf);
void	jack_faces(struct nmgregion *r, FILE *fp_psurf, int *map);
d74 3
a76 1
main(int argc, char **argv)
d264 5
a268 1
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d449 3
a451 3
nmg_to_psurf(struct nmgregion *r, FILE *fp_psurf)
                    		/* NMG region to be converted. */
    		          	/* Jack format file to write vertex list to. */
d496 4
a499 4
jack_faces(struct nmgregion *r, FILE *fp_psurf, int *map)
                    		/* NMG region to be converted. */
    		          	/* Jack format file to write face vertices to. */
   		     
@


11.17
log
@Converted from K&R to ANSI C - RFH
@
text
@d41 2
a42 2
void	nmg_to_psurf(struct nmgregion *r, FILE *fp_psurf);
void	jack_faces(struct nmgregion *r, FILE *fp_psurf, int *map);
d74 3
a76 1
main(int argc, char **argv)
d264 5
a268 1
union tree *do_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d449 3
a451 3
nmg_to_psurf(struct nmgregion *r, FILE *fp_psurf)
                    		/* NMG region to be converted. */
    		          	/* Jack format file to write vertex list to. */
d496 4
a499 4
jack_faces(struct nmgregion *r, FILE *fp_psurf, int *map)
                    		/* NMG region to be converted. */
    		          	/* Jack format file to write face vertices to. */
   		     
@


11.16
log
@Misc compiler warning changes
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jack/g-jack.c,v 11.15 2001/05/17 20:05:10 morrison Exp $ (BRL)";
d41 2
a42 2
void	nmg_to_psurf();
void	jack_faces();
d74 1
a74 3
main(argc, argv)
int	argc;
char	*argv[];
d262 1
a262 5
union tree *do_region_end(tsp, pathp, curtree, client_data)
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d443 3
a445 3
nmg_to_psurf(r, fp_psurf)
struct nmgregion *r;		/* NMG region to be converted. */
FILE		*fp_psurf;	/* Jack format file to write vertex list to. */
d490 4
a493 4
jack_faces(r, fp_psurf, map)
struct nmgregion *r;		/* NMG region to be converted. */
FILE		*fp_psurf;	/* Jack format file to write face vertices to. */
int		*map;
@


11.15
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jack/g-jack.c,v 11.14 2001/04/05 19:35:21 morrison Exp $ (BRL)";
d162 1
a162 1
			sscanf( optarg, "%x", &rt_g.debug );
d170 1
a170 1
			sscanf( optarg, "%x", &rt_g.NMG_debug );
@


11.14
log
@updated SIGNED to signed
updated CONST to const
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jack/g-jack.c,v 11.13 2000/11/02 02:17:01 mike Exp $ (BRL)";
d283 1
a283 1
	if (rt_g.debug&DEBUG_TREEWALK || verbose) {
@


11.13
log
@
db_dirbuild() handles v5
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jack/g-jack.c,v 11.12 2000/09/08 05:56:48 mike Exp $ (BRL)";
d226 1
a226 1
	(void) db_walk_tree(dbip, argc-1, (CONST char **)(argv+1),
@


11.12
log
@
Tree routines need resource pointer.
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jack/g-jack.c,v 11.11 2000/08/24 04:55:34 mike Exp $ (BRL)";
d192 1
a192 1
	db_scan(dbip, (int (*)())db_diradd, 1, NULL);
@


11.11
log
@
lint
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jack/g-jack.c,v 11.10 2000/01/31 15:29:45 jra Exp $ (BRL)";
d125 2
d311 1
a311 1
			db_free_tree(curtree);		/* Does an nmg_kr() */
d325 1
a325 1
	ret_tree = nmg_booltree_evaluate( curtree, tsp->ts_tol );	/* librt/nmg_bool.c */
d430 1
a430 1
	db_free_tree(curtree);		/* Does an nmg_kr() */
@


11.10
log
@Eliminated an unused variable
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jack/g-jack.c,v 11.9 2000/01/04 17:58:20 bparker Exp $ (BRL)";
d37 1
@


11.9
log
@*- add client_data to db_walk_tree
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jack/g-jack.c,v 11.8 1999/12/29 23:23:14 mike Exp $ (BRL)";
a270 1
	int			failed;
@


11.8
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jack/g-jack.c,v 11.7 1999/05/10 21:56:45 mike Exp $ (BRL)";
d39 1
a39 1
RT_EXTERN(union tree *do_region_end, (struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree));
d228 2
a229 1
		nmg_booltree_leaf_tess);	/* in librt/nmg_bool.c */
d261 1
a261 1
union tree *do_region_end(tsp, pathp, curtree)
d265 1
@


11.7
log
@ma_override to ma_color_valid
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/jack/g-jack.c,v 11.6 1996/07/15 18:22:38 jra Exp $ (BRL)";
d189 1
a189 1
	db_scan(dbip, (int (*)())db_diradd, 1);
@


11.6
log
@Mods for change in nmg_booltree_evaluate() return.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 11.5 1995/06/20 01:09:41 mike Exp jra $ (BRL)";
d344 1
a344 1
		if (tsp->ts_mater.ma_override != 0) {
d357 1
a357 1
		if (tsp->ts_mater.ma_override != 0)
@


11.5
log
@Added -f flag, to supress file output.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/jack/RCS/g-jack.c,v 11.4 1995/02/25 03:18:00 mike Exp mike $ (BRL)";
d41 1
d53 1
a53 1
static int	no_file_output;	/* -f:  Don't bother writing output files */
d266 1
d268 1
d321 1
a321 1
	failed = nmg_boolean( curtree, *tsp->ts_m, tsp->ts_tol );	/* librt/nmg_bool.c */
d323 4
d328 1
a328 1
	if( !failed && !no_file_output )  {
d382 1
a382 1
			nmg_to_psurf(curtree->tr_d.td_r, fp_psurf);
d404 1
a404 1
				nmg_r_to_vlist( &vhead, curtree->tr_d.td_r, 0 );
d491 1
@


11.4
log
@Changed to use nmg_boolean() interface routine.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 11.3 1995/02/22 05:29:15 mike Exp mike $ (BRL)";
d45 1
a45 1
Usage: %s [-v] [-d] [-xX lvl] [-u eu_dist]\n\
d52 1
d127 1
a127 1
	while ((c = getopt(argc, argv, "a:dn:p:r:u:vx:D:P:X:")) != EOF) {
d135 3
d321 1
a321 1
	if( !failed )  {
d406 4
@


11.3
log
@Perform the nmg_model_fuse() required for booleans.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 11.2 1995/02/17 01:17:32 mike Exp mike $ (BRL)";
d262 1
d314 1
a314 2
	(void)nmg_model_fuse( *tsp->ts_m, tsp->ts_tol );
	curtree = nmg_booltree_evaluate(curtree, tsp->ts_tol);	/* librt/nmg_bool.c */
d317 1
a317 2
	if( curtree != 0 && curtree->tr_op == OP_NMG_TESS &&
	    curtree->tr_d.td_r != 0 )  {
d408 1
@


11.2
log
@Return from nmg_booltree_evaluate changed.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 11.1 95/01/04 10:06:25 mike Rel4_4 Locker: mike $ (BRL)";
d313 1
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.32 94/12/19 18:04:33 mike Exp $ (BRL)";
a260 1
	struct nmgregion	*r;
d313 1
a313 1
	r = nmg_booltree_evaluate(curtree, tsp->ts_tol);	/* librt/nmg_bool.c */
d316 2
a317 1
	if (r != 0) {
d371 1
a371 1
			nmg_to_psurf(r, fp_psurf);
d393 1
a393 1
				nmg_r_to_vlist( &vhead, r, 0 );
a400 3

		/* NMG region is no longer necessary */
		nmg_kr(r);
@


1.32
log
@Linux fix
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.31 94/12/08 17:55:20 jra Exp Locker: mike $ (BRL)";
@


1.31
log
@Mod for CRAY2
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/jack/RCS/g-jack.c,v 1.30 94/11/08 04:25:03 mike Exp Locker: jra $ (BRL)";
d22 2
d26 1
d28 3
@


1.30
log
@Irix 6
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.29 94/07/04 02:31:02 mike Exp Locker: mike $ (BRL)";
d280 4
a283 3
	if( ncpu == 1 && RT_SETJUMP )  {
		/* Error, bail out */
		RT_UNSETJUMP;		/* Relinquish the protection */
d285 4
a288 4
		/* Sometimes the NMG library adds debugging bits when
		 * it detects an internal error, before rt_bomb().
		 */
		rt_g.NMG_debug = NMG_debug;	/* restore mode */
d290 2
a291 2
		/* Release any intersector 2d tables */
		nmg_isect2d_final_cleanup();
d293 2
a294 2
		/* Release the tree memory & input regions */
		db_free_tree(curtree);		/* Does an nmg_kr() */
d296 10
a305 5
		/* Get rid of (m)any other intermediate structures */
		if( (*tsp->ts_m)->magic == NMG_MODEL_MAGIC )  {
			nmg_km(*tsp->ts_m);
		} else {
			rt_log("WARNING: tsp->ts_m pointer corrupted, ignoring it.\n");
a306 4
	
		/* Now, make a new, clean model structure for next pass. */
		*tsp->ts_m = nmg_mm();
		goto out;
@


1.29
log
@Added magic number setting and checking.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.28 94/07/04 00:02:17 mike Exp Locker: mike $ (BRL)";
d34 1
a43 1
static fastf_t	dist_calc_tol = 0; /* arg of -D */
a69 1
	int		i, ret;
d212 1
a212 1
	ret = db_walk_tree(dbip, argc-1, (CONST char **)(argv+1),
d423 1
a423 1
int
@


1.28
log
@Reduced default angular tolerance.
If distance tolerance is reduced, it increases likelyhood that
the classifier's ray-tracer will hit an edge and die.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.27 94/07/03 23:47:12 mike Exp Locker: mike $ (BRL)";
d259 2
d410 1
@


1.27
log
@Added ability to set rt_tol distance value (tol.dist).
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.26 94/02/24 00:30:16 mike Exp Locker: mike $ (BRL)";
d106 1
a106 1
	tol.perp = 1e-6;
@


1.26
log
@Added -u option, to get better debugging plots.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.25 93/12/14 18:40:34 mike Exp Locker: mike $ (BRL)";
d39 2
a40 1
	[-a abs_tol] [-r rel_tol] [-n norm_tol]\n\
d43 1
d121 1
a121 1
	while ((c = getopt(argc, argv, "a:dn:p:r:u:vx:P:X:")) != EOF) {
d151 5
d208 3
@


1.25
log
@Routine name changed from nmg_region_vertex_list() to nmg_vertex_tabulate().
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.24 93/11/13 00:09:14 mike Exp Locker: mike $ (BRL)";
d35 1
d37 4
a40 1
static char	usage[] = "Usage: %s [-v] [-d] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-p prefix] brlcad_db.g object(s)\n";
d111 1
d119 1
a119 1
	while ((c = getopt(argc, argv, "a:dn:p:r:vx:P:X:")) != EOF) {
d135 3
@


1.24
log
@Check for model corruption
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.23 93/11/12 23:12:37 mike Exp Locker: mike $ (BRL)";
d415 1
a415 1
	nmg_region_vertex_list( &vtab, r );
@


1.23
log
@Special hack to release (huge) intersector 2d tables on rt_bomb()
longjmp().
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.22 93/10/28 23:53:07 mike Exp Locker: mike $ (BRL)";
d277 1
a277 1
		if( (*tsp->ts_m)->magic != -1L )
d279 3
@


1.22
log
@Made memory leak checking conditional.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.21 93/10/28 23:51:39 mike Exp Locker: mike $ (BRL)";
d269 3
@


1.21
log
@Fixed length problem with string fig_file by changing over to
rt_vls strings.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.20 93/10/28 22:44:36 mike Exp Locker: mike $ (BRL)";
d82 3
a84 1
rt_g.debug |= DEBUG_MEM_FULL;
d218 3
a220 1
rt_prmem("After complete conversion");
@


1.20
log
@Release the dynamic storage.
(Run with memory debugging).
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.19 93/10/28 20:47:25 mike Exp Locker: mike $ (BRL)";
d63 1
a63 1
	char		*dot, *fig_file;
d67 1
d165 1
a165 1
	fig_file = rt_malloc(sizeof(prefix) + sizeof(argv[0] + 4), "st");
d169 2
a170 3
			strcat(strcpy(fig_file, prefix), 1 + dot);
		else
			strcpy(fig_file, 1 + dot);
d173 2
a174 3
			strcat(strcpy(fig_file, prefix), argv[0]);
		else
			strcpy(fig_file, argv[0]);
d178 1
a178 1
	if ((dot = strrchr(fig_file, '.')) != (char *)NULL)
d180 4
a183 1
	strcat(fig_file, ".fig");	/* Add required Jack suffix. */
d185 4
a188 2
	if ((fp_fig = fopen(fig_file, "w")) == NULL)
		perror(fig_file);
d203 1
a203 1
	rt_free(fig_file, "st");
@


1.19
log
@Increase edgeuse distance, for Bradley visualization
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.18 93/04/03 05:00:32 mike Exp Locker: mike $ (BRL)";
d81 1
d207 7
d355 1
d363 1
@


1.18
log
@Oops, forgot to change one tolerance pointer
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.17 93/04/03 04:35:58 mike Exp Locker: mike $ (BRL)";
d98 7
@


1.17
log
@Moved nmg_booltree_leaf_tess() and nmg_booltree_evaluate() off
to librt/nmg_bool.c
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.16 93/04/03 04:11:08 mike Exp Locker: mike $ (BRL)";
d258 1
a258 1
	r = nmg_booltree_evaluate(curtree, &tol);	/* librt/nmg_bool.c */
@


1.16
log
@Moved all the heap support to librt/nmg_junk.c to save it.
Changed to use nmg_region_vertex_list().
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.15 93/04/03 04:03:40 mike Exp Locker: mike $ (BRL)";
a32 3
RT_EXTERN(struct nmgregion *nmg_booltree_evaluate, (union tree *tp, CONST struct rt_tol *tol));
RT_EXTERN(union tree *nmg_booltree_leaf_tess, (struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_external *ep, int id));

d44 1
a44 1
static struct db_i	*dbip;
a201 1

a202 146
 *			N M G _ B O O L T R E E _ E V A L U A T E
 *
 *  Given a tree of leaf nodes tesselated earlier by nmg_booltree_leaf_tess(),
 *  use recursion to do a depth-first traversal of the tree,
 *  evaluating each pair of boolean operations
 *  and reducing that result to a single nmgregion.
 *
 *  Usually called from a do_region_end() handler from db_walk_tree().
 *  For an example of one, see XXX.
 *
 * Swiped from mged/dodraw.c mged_nmg_doit().
 */
struct nmgregion *
nmg_booltree_evaluate(tp, tol)
register union tree		*tp;
CONST struct rt_tol		*tol;
{
	register struct nmgregion	*l;
	register struct nmgregion	*r;
	int			op;

	RT_CK_TOL(tol);

	switch(tp->tr_op) {
	case OP_NOP:
		return(0);
	case OP_NMG_TESS:
		/* Hit a tree leaf, just grab nmgregion and return it */
		r = tp->tr_d.td_r;
		tp->tr_d.td_r = (struct nmgregion *)NULL;	/* Disconnect */
		tp->tr_op = OP_NOP;	/* Keep quiet */
		return r;
	case OP_UNION:
		op = NMG_BOOL_ADD;
		break;
	case OP_INTERSECT:
		op = NMG_BOOL_ISECT;
		break;
	case OP_SUBTRACT:
		op = NMG_BOOL_SUB;
		break;
	default:
		rt_log("nmg_booltree_evaluate: bad op %d\n", tp->tr_op);
		return(0);
	}
	l = nmg_booltree_evaluate(tp->tr_b.tb_left, tol);
	r = nmg_booltree_evaluate(tp->tr_b.tb_right, tol);
	if (l == 0) {
		if (r == 0)
			return 0;
		if( op == NMG_BOOL_ADD )
			return r;
		/* For sub and intersect, if lhs is 0, result is null */
		nmg_kr(r);
		return 0;
	}
	if (r == 0) {
		if (l == 0)
			return 0;
		if( op == NMG_BOOL_ISECT )  {
			nmg_kr(l);
			return 0;
		}
		/* For sub and add, if rhs is 0, result is lhs */
		return l;
	}

	NMG_CK_REGION(r);
	NMG_CK_REGION(l);
	if (nmg_ck_closed_region(r) != 0)
	    	rt_log("nmg_booltree_evaluate:  WARNING, non-closed shell (r), barging ahead\n");
	if (nmg_ck_closed_region(l) != 0)
	    	rt_log("nmg_booltree_evaluate:  WARNING, non-closed shell (l), barging ahead\n");

	/* input r1 and r2 are destroyed, output is new r1 */
	r = nmg_do_bool(l, r, op, tol);

	NMG_CK_REGION(r);
	return r;
}

/*
 *			N M G _ B O O L T R E E _ L E A F _ T E S S
 *
 *  Called from db_walk_tree() each time a tree leaf is encountered.
 *  The primitive solid, in external format, is provided in 'ep',
 *  and the type of that solid (e.g. ID_ELL) is in 'id'.
 *  The full tree state including the accumulated transformation matrix
 *  and the current tolerancing is in 'tsp',
 *  and the full path from root to leaf is in 'pathp'.
 *
 *  Import the solid, tessellate it into an NMG, stash a pointer to
 *  the tessellation in a new tree structure (union), and return a
 *  pointer to that.
 *
 *  This routine must be prepared to run in parallel.
 */
union tree *
nmg_booltree_leaf_tess(tsp, pathp, ep, id)
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_external	*ep;
int			id;
{
	struct rt_db_internal	intern;
	struct nmgregion	*r1;
	union tree		*curtree;
	struct directory	*dp;

	RT_CK_TESS_TOL(tsp->ts_ttol);
	RT_CK_TOL(tsp->ts_tol);
	NMG_CK_MODEL(*tsp->ts_m);

	/* RT_CK_FULL_PATH(pathp) */
	dp = DB_FULL_PATH_CUR_DIR(pathp);
	RT_CK_DIR(dp);

	RT_INIT_DB_INTERNAL(&intern);
	if (rt_functab[id].ft_import(&intern, ep, tsp->ts_mat) < 0) {
		rt_log("nmg_booltree_leaf_tess(%s):  solid import failure\n", dp->d_namep);
	    	if (intern.idb_ptr)  rt_functab[id].ft_ifree(&intern);
	    	return(TREE_NULL);		/* ERROR */
	}
	RT_CK_DB_INTERNAL(&intern);

	if (rt_functab[id].ft_tessellate(
	    &r1, *tsp->ts_m, &intern, tsp->ts_ttol, tsp->ts_tol) < 0) {
		rt_log("nmg_booltree_leaf_tess(%s): tessellation failure\n", dp->d_namep);
		rt_functab[id].ft_ifree(&intern);
	    	return(TREE_NULL);
	}
	rt_functab[id].ft_ifree(&intern);

	NMG_CK_REGION(r1);

	GETUNION(curtree, tree);
	curtree->tr_op = OP_NMG_TESS;
	curtree->tr_d.td_r = r1;

	if (rt_g.debug&DEBUG_TREEWALK)
		rt_log("nmg_booltree_leaf_tess(%s) OK\n", dp->d_namep);

	return(curtree);
}

/*
d204 2
@


1.15
log
@Changed to use nmg_region_vertex_list().
This has the nice property of making the Jack vertex indices "nice".
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.14 93/04/03 03:53:40 mike Exp Locker: mike $ (BRL)";
a37 3
int		heap_find(), heap_insert();
struct vertex	**init_heap();
void		heap_increase();
a38 1

a44 1
int		heap_cur_sz;	/* Next free spot in heap. */
d189 1
a189 1
		nmg_booltree_leaf_tess);
d406 1
a406 1
	r = nmg_booltree_evaluate(curtree, &tol);
d525 1
a525 6
	int			cnt, i, sz;
	struct edgeuse		*eu;
	struct faceuse		*fu;
	struct loopuse		*lu;
	struct shell		*s;
	struct vertex		*v, **verts[1];
d531 2
a532 4
#if 0
	sz = 1000;
	verts[0] = init_heap(sz);
	cnt = 0;
d534 1
a534 26
	for (RT_LIST_FOR(s, shell, &r->s_hd)) {
		/* Shell is made of faces. */
		for (RT_LIST_FOR(fu, faceuse, &s->fu_hd)) {
			NMG_CK_FACEUSE(fu);
			if (fu->orientation != OT_SAME)
				continue;
			for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
				NMG_CK_LOOPUSE(lu);
				if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
					for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
						NMG_CK_EDGEUSE(eu);
						NMG_CK_EDGE(eu->e_p);
						NMG_CK_VERTEXUSE(eu->vu_p);
						NMG_CK_VERTEX(eu->vu_p->v_p);
						NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
						cnt = heap_insert(verts, &sz, eu->vu_p->v_p);
					}
				} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
					== NMG_VERTEXUSE_MAGIC) {
					v = RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
					NMG_CK_VERTEX(v);
					NMG_CK_VERTEX_G(v->vg_p);
					cnt = heap_insert(verts, &sz, v);
				} else
					rt_log("nmg_to_psurf: loopuse mess up! (1)\n");
			}
a535 50
			/* Shell contains loops. */
			for (RT_LIST_FOR(lu, loopuse, &s->lu_hd)) {
				NMG_CK_LOOPUSE(lu);
				if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
					for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
						NMG_CK_EDGEUSE(eu);
						NMG_CK_EDGE(eu->e_p);
						NMG_CK_VERTEXUSE(eu->vu_p);
						NMG_CK_VERTEX(eu->vu_p->v_p);
						NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
						cnt = heap_insert(verts, &sz, eu->vu_p->v_p);
					}
				} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
					== NMG_VERTEXUSE_MAGIC) {
					v = RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
					NMG_CK_VERTEX(v);
					NMG_CK_VERTEX_G(v->vg_p);
					cnt = heap_insert(verts, &sz, v);
				} else
					rt_log("nmg_to_psurf: loopuse mess up! (1)\n");
			}

			/* Shell contains edges. */
			for (RT_LIST_FOR(eu, edgeuse, &s->eu_hd)) {
				NMG_CK_EDGEUSE(eu);
				NMG_CK_EDGE(eu->e_p);
				NMG_CK_VERTEXUSE(eu->vu_p);
				NMG_CK_VERTEX(eu->vu_p->v_p);
				NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
				cnt = heap_insert(verts, &sz, eu->vu_p->v_p);
			}

			/* Shell contains a single vertex. */
			if (s->vu_p) {
				NMG_CK_VERTEXUSE(s->vu_p);
				NMG_CK_VERTEX(s->vu_p->v_p);
				NMG_CK_VERTEX_G(s->vu_p->v_p->vg_p);
				cnt = heap_insert(verts, &sz, s->vu_p->v_p);
			}

			if (RT_LIST_IS_EMPTY(&s->fu_hd) &&
				RT_LIST_IS_EMPTY(&s->lu_hd) &&
				RT_LIST_IS_EMPTY(&s->eu_hd) && !s->vu_p) {
				rt_log("WARNING nmg_to_psurf: empty shell\n");
			}
		}
	}

	/* XXX What to do if cnt == 0 ? */

a536 17
	for (i = 1; i < cnt; i++)  {
		struct vertex			*v;
		register struct vertex_g	*vg;
		v = verts[0][i];
		NMG_CK_VERTEX(v);
		vg = v->vg_p;
		NMG_CK_VERTEX_G(vg);
		NMG_INDEX_ASSIGN( map, v, i );	/* map[v] = i */
		fprintf(fp_psurf, "%f\t%f\t%f\n",
			vg->coord[X] / 10.,
			vg->coord[Y] / 10.,
			vg->coord[Z] / 10.);
	}
#else
	nmg_region_vertex_list( &vtab, r );

	/* Print list of unique vertices and convert from mm to cm. */
d544 1
a544 1
		NMG_INDEX_ASSIGN( map, v, i+1 );	/* map[v] = i+1 */
d550 4
a554 6
#endif
	fprintf(fp_psurf, ";;\n");
	jack_faces(r, fp_psurf, verts[0], cnt-1, map);
#if 0
	rt_free((char *)(verts[0]), "heap");
#endif
d567 1
a567 1
jack_faces(r, fp_psurf, verts, sz, map)
a569 2
struct vertex	**verts;	/* Heap of vertex structs. */
int		sz;	/* Size of vertex heap. */
a571 1
	point_t			vert;
a657 114
}

/*
*	I N I T _ H E A P
*
*	Initialize an array-based implementation of a heap of vertex structs.
*	(Heap: Binary tree w/value of parent > than that of children.)
*/
struct vertex **
init_heap(n)
int	n;
{
	extern int	heap_cur_sz;
	struct vertex	**heap;

	heap_cur_sz = 1;
	heap = (struct vertex **)
		rt_malloc(1 + n*sizeof(struct vertex *), "heap");
	if (heap == (struct vertex **)NULL) {
		rt_log("init_heap: no mem\n");
		rt_bomb("");
	}
	return(heap);
}

/*
*	H E A P _ I N C R E A S E
*
*	Make a heap bigger to make room for new entries.
*/
void
heap_increase(h, n)
struct vertex	**h[1];
int	*n;
{
	struct vertex	**big_heap;
	int	i;

	big_heap = (struct vertex **)
		rt_malloc(1 + 3 * (*n) * sizeof(struct vertex *), "heap");
	if (big_heap == (struct vertex **)NULL)
		rt_bomb("heap_increase: no mem\n");
	for (i = 1; i <= *n; i++)
		big_heap[i] = h[0][i];
	*n *= 3;
	rt_free((char *)h[0], "heap");
	h[0] = big_heap;
}

/*
*	H E A P _ I N S E R T
*
*	Insert a vertex struct into the heap (only if it is
*	not already there).
*/
int
heap_insert(h, n, i)
struct vertex	**h[1];	/* Heap of vertices. */
int		*n;	/* Max size of heap. */
struct vertex	*i;	/* Item to insert. */
{
	extern int	heap_cur_sz;
	struct vertex	**new_heap, *tmp;
	int		cur, done;

	if (heap_find(h[0], heap_cur_sz, i, 1))	/* Already in heap. */
		return(heap_cur_sz);

	if (heap_cur_sz > *n)
		heap_increase(h, n);

	cur = heap_cur_sz;
	h[0][cur] = i;	/* Put at bottom of heap. */

	/* Bubble item up in heap. */
	done = 0;
	while (cur > 1 && !done)
		if (h[0][cur] < h[0][cur>>1]) {
			tmp          = h[0][cur>>1];
			h[0][cur>>1] = h[0][cur];
			h[0][cur]    = tmp;
			cur >>= 1;
		} else
			done = 1;
	heap_cur_sz++;
	return(heap_cur_sz);
}

/*
*	H E A P _ F I N D
*
*	See if a given vertex struct is in the heap.  If so,
*	return its location in the heap array.
*/
int
heap_find(h, n, i, loc)
struct vertex	**h;	/* Heap of vertexs. */
int		n;	/* Max size of heap. */
struct vertex	*i;	/* Item to search for. */
int		loc;	/* Location to start search at. */
{
	int		retval;

	if (loc > n || h[loc] > i)
		retval = 0;
	else if (h[loc] == i)
		retval = loc;
	else {
		loc <<= 1;
		retval = heap_find(h, n, i, loc);
		if (!retval)
			retval = heap_find(h, n, i, loc+1);
	}
	return(retval);
@


1.14
log
@Replaced heap_find() binary search with a table access.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.13 93/04/03 03:40:10 mike Exp Locker: mike $ (BRL)";
d537 1
d541 1
d637 19
d658 1
d660 1
@


1.13
log
@Tidy up the interface between the tree walker and the NMG tesselators.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.12 93/03/25 21:10:03 mike Exp Locker: mike $ (BRL)";
d536 1
d538 2
d623 1
d625 3
a627 2
		NMG_CK_VERTEX(verts[0][i]);
		vg = verts[0][i]->vg_p;
d629 1
d636 1
a636 1
	jack_faces(r, fp_psurf, verts[0], cnt-1);
d638 1
d650 1
a650 1
jack_faces(r, fp_psurf, verts, sz)
d655 1
d679 1
a679 1
		    				fprintf(fp_psurf, "%d ", heap_find(verts, sz, eu->vu_p->v_p, 1));
d686 1
a686 1
		  			fprintf(fp_psurf, "%d ", heap_find(verts, sz, v, 1));
d703 1
a703 1
		  			fprintf(fp_psurf, "%d ", heap_find(verts, sz, eu->vu_p->v_p, 1));
d710 1
a710 1
				fprintf(fp_psurf, "%d ", heap_find(verts, sz, v, 1));
d723 1
a723 1
			fprintf(fp_psurf, "%d ", heap_find(verts, sz, eu->vu_p->v_p, 1));
d733 1
a733 1
			fprintf(fp_psurf, "%d;\n", heap_find(verts, sz, s->vu_p->v_p, 1));
@


1.12
log
@For debugging, when -P is given, set rt_g.debug.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.11 93/03/22 23:39:04 mike Exp Locker: mike $ (BRL)";
d33 3
a35 2
RT_EXTERN(struct nmgregion * doit, (union tree	*tp, struct rt_tess_tol	*ttol));
RT_EXTERN(union tree *do_leaf, (struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_external *ep, int id));
d53 1
a53 1
static struct model		*the_model;
d56 1
a56 1
static struct rt_vls		base_seg;
d58 2
d89 5
d191 1
a191 1
		&rt_initial_tree_state,
d194 1
a194 1
		do_leaf);
d212 12
a223 4
*			D O I T
*
* Swiped from mged/dodraw.c mged_nmg_doit().
*/
d225 3
a227 3
doit(tp, ttol_arg)
register union tree	*tp;
struct rt_tess_tol	*ttol_arg;
a230 2
	vect_t			diag;
	fastf_t			rel;
a231 1
	struct rt_tol		tol;
d233 1
a233 1
	RT_CK_TESS_TOL(ttol_arg);
d239 1
d243 1
a243 1
		return(r);
d246 1
a246 1
		goto com;
d249 1
a249 1
		goto com;
d252 1
a252 1
		goto com;
d254 1
a254 1
		rt_log("doit: bad op %d\n", tp->tr_op);
d257 2
a258 3
com:
	l = doit(tp->tr_b.tb_left, ttol_arg);
	r = doit(tp->tr_b.tb_right, ttol_arg);
d261 6
a266 2
			return(0);
		return(r);
d270 7
a276 2
			return(0);
		return(l);
d278 1
a278 1
	/* debug */
d282 1
a282 1
	    	rt_log("doit:  WARNING, non-closed shell (r), barging ahead\n");
d284 1
a284 1
	    	rt_log("doit:  WARNING, non-closed shell (l), barging ahead\n");
a285 28
	/*
	 *  Compute appropriate tolerance for the boolean routine.
	 *  This tolerance is an absolute distance metric.
	 *  The geometry is guaranteed to contain no errors larger than
	 *  this tolerance value.
	 */
	tol.dist = ttol_arg->abs;
	if (ttol_arg->rel > 0.0) {
		if (l->ra_p) {
			VSUB2(diag, l->ra_p->max_pt, l->ra_p->min_pt);
			rel = MAGNITUDE(diag) * ttol_arg->rel;
			if (tol.dist <= 0.0 || rel < tol.dist)  tol.dist = rel;
		}
		if (r->ra_p) {
			VSUB2(diag, r->ra_p->max_pt, r->ra_p->min_pt);
			rel = MAGNITUDE(diag) * ttol_arg->rel;
			if (tol.dist <= 0.0 || rel < tol.dist)  tol.dist = rel;
		}
	}
	if (tol.dist <= 0.0)  tol.dist = 0.1;		/* mm */

	/* XXX These need to be improved */
	tol.magic = RT_TOL_MAGIC;
	tol.dist /= 128;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

d287 1
a287 1
	r = nmg_do_bool(l, r, op, &tol);
a288 1
	/* debug */
d290 1
a290 2
	(void)nmg_ck_closed_region(r);
	return(r);
d294 17
a310 7
*			D O _ L E A F
*
*  Tessellate Solid into NMG
*
*  This routine must be prepared to run in parallel.
*/
union tree *do_leaf(tsp, pathp, ep, id)
d321 5
d327 1
d331 1
a331 2
		rt_log("%s:  solid import failure\n",
			DB_FULL_PATH_CUR_DIR(pathp)->d_namep);
d338 2
a339 2
	    &r1, the_model, &intern, &ttol, &tol) < 0) {
		rt_log("%s: tessellation failure\n", dp->d_namep);
a344 1
	/* debug */
a345 1
	(void) nmg_ck_closed_region(r1);	/* ignore error return */
d352 1
a352 1
		rt_log("do_leaf()\n");
d371 4
d404 2
a405 2
		if( the_model->magic != -1L )
			nmg_km(the_model);
d408 1
a408 1
		the_model = nmg_mm();
d411 1
a411 1
	r = doit(curtree, &ttol);
@


1.11
log
@Bug protection around the nmg_km() call.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.10 93/03/18 15:38:23 mike Exp Locker: mike $ (BRL)";
a101 2
/**	rt_g.debug = 1;			/* DEBUG_ALLRAYS -- to get core dumps */

d125 1
@


1.10
log
@1)  Added "on the fly" percentage printing.
2)  Did a nicer job of memory cleanup on longjmp().
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.9 93/03/17 05:37:03 mike Exp Locker: mike $ (BRL)";
d396 2
a397 1
		nmg_km(the_model);
@


1.9
log
@nmg_mk.c and nmg_mod.c are stable enough that it should be safe
to run an nmg_km() when rt_bomb() is called.  This greatly reduces
the memory demand of the "report card" tests.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.8 93/03/17 05:28:51 mike Exp Locker: mike $ (BRL)";
d371 1
a371 1
		rt_log("\ndo_region_end(%d) path='%s'\n",
d373 1
d386 4
a389 1
		rt_log("bailed out via longjmp\n");
d391 5
a395 6
		/*
		 *  Eliminate whatever stuff is leftover.
		 *  Basic routines should be sturdy enough that
		 *  this can be done safely.  If it dumps core,
		 *  well, that's worth knowing about.
		 */
d397 1
a397 1

d399 2
a400 2
		the_model = nmg_mm();	/* sanity -- ignore current memory */
		return	curtree;
d493 11
a503 1
	/* Return original tree -- it needs to be freed (by caller) */
@


1.8
log
@Print current count of regions tried, for operator entertainment.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.7 93/03/08 22:55:55 mike Exp Locker: mike $ (BRL)";
d384 1
d387 9
@


1.7
log
@Added -P option for #cpus.
But for the moment, it just deactivates the RT_SETJMP stuff so that
core dumps are possible
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.6 93/02/24 20:43:24 mike Exp Locker: mike $ (BRL)";
d371 2
a372 1
		rt_log("\ndo_region_end() path='%s'\n",
@


1.6
log
@Added setlinebuf(stderr) to speed up debugging prints
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.5 93/01/22 21:58:13 mike Exp Locker: mike $ (BRL)";
d47 1
d102 2
d105 1
a105 1
	while ((c = getopt(argc, argv, "a:dn:p:r:vx:X:")) != EOF) {
d125 3
d381 1
a381 1
	if( RT_SETJUMP )  {
@


1.5
log
@Added -d flag, to also drop UNIX-Plot files of the conversion,
as a debugging aid.
Fixed freeing null pointer problem with the "base_name" pointer by
changing to a vls
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.4 92/12/14 18:10:20 mike Exp Locker: mike $ (BRL)";
d71 13
@


1.4
log
@Fixed bug with "cnt" being uninitialized.
When 0 verts occur in an NMG, would cause random value to be used.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.3 92/11/16 14:56:03 mm Exp Locker: mike $ (BRL)";
d42 1
a42 1
static char	usage[] = "Usage: %s [-v] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-p prefix] brlcad_db.g object(s)\n";
d46 1
d54 1
a54 1
static char			*base_seg;
d59 4
d86 1
d89 1
a89 1
	while ((c = getopt(argc, argv, "a:n:p:r:vx:X:")) != EOF) {
d94 3
d160 1
a160 1
	base_seg = NULL;	/* .fig figure file's main segment. */
d170 1
a170 1
	fprintf(fp_fig, "\troot=%s_seg.base;\n", base_seg);
d174 1
a174 1
	rt_free(base_seg, "s");
d375 1
d378 1
d380 2
a381 2
		rt_vls_strcpy(&file, prefix);
		rt_vls_strcat(&file, DB_FULL_PATH_CUR_DIR(pathp)->d_namep);
d383 3
a385 3
		for (i = 0; i < file.vls_len; i++)
			if (file.vls_str[i] == '.')
				file.vls_str[i] = '_';
d390 1
a390 1
				rt_vls_addr(&file));
d399 2
a400 2
		fprintf(fp_fig, "\tsegment %s_seg {\n", rt_vls_addr(&file));
		fprintf(fp_fig, "\t\tpsurf=\"%s.pss\";\n", rt_vls_addr(&file));
d403 1
a403 1
				"\t\tattribute=%s;\n", rt_vls_addr(&file));
d407 2
a408 3
		if (!base_seg) {
			base_seg = rt_malloc(1+sizeof(rt_vls_addr(&file)), "s");
			strcpy(base_seg, rt_vls_addr(&file));
d411 1
a411 1
				rt_vls_addr(&file));
d414 2
a415 1
				rt_vls_addr(&file), base_seg);
d419 1
a425 1
			if(verbose) rt_log("*** Wrote %s\n", rt_vls_addr(&file));
d428 1
d431 24
@


1.3
log
@used ma_override to determine when Jack 'attribute' is generated
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.2 92/11/11 00:01:08 mike Exp Locker: mm $ (BRL)";
d451 1
d528 2
d531 5
a535 1
	for (i = 1; i < cnt; i++)
d537 4
a540 3
			verts[0][i]->vg_p->coord[X] / 10.,
			verts[0][i]->vg_p->coord[Y] / 10.,
			verts[0][i]->vg_p->coord[Z] / 10.);
@


1.2
log
@Added -v, -x, and -X flags.
Added RT_SETJMP protection.
Added summary of how many regions worked.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/jack/RCS/g-jack.c,v 1.1 92/11/10 22:39:36 mm Exp Locker: mike $ (BRL)";
d390 3
a392 1
		fprintf(fp_fig, "\t\tattribute=%s;\n", rt_vls_addr(&file));
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d42 1
a42 1
static char	usage[] = "Usage: %s [-p prefix] brlcad_db.g object(s)\n";
d44 2
d55 3
d65 1
d83 1
a83 1
	while ((c = getopt(argc, argv, "a:n:p:r:")) != EOF) {
d97 10
d167 5
d341 1
a341 1
	if (rt_g.debug&DEBUG_TREEWALK) {
d343 1
a343 1
		rt_log("do_region_end() path='%s'\n",
d351 9
d361 2
d412 1
d427 1
a427 1
*	N M G _ T O _ P S U R F S
@
