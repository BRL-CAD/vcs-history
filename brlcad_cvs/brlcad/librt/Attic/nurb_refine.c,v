head	11.13;
access;
symbols
	ansi-20040405-merged:11.9.2.2
	postmerge-20040405-ansi:11.11
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.9.10.1
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.9.2.1
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.9.4.1
	autoconf-20031203:11.9
	autoconf-20031202:11.9
	autoconf-branch:11.9.0.10
	phong-branch:11.9.0.8
	photonmap-branch:11.9.0.6
	rel-6-1-DP:11.9
	windows-branch:11.9.0.4
	rel-6-0-2:11.7
	ansi-branch:11.9.0.2
	rel-6-0-1-branch:11.7.0.2
	hartley-6-0-post:11.8
	hartley-6-0-pre:11.7
	rel-6-0-1:11.7
	rel-6-0:11.7
	rel-5-4:11.5.2.1
	offsite-5-3-pre:11.6
	rel-5-3:11.5.2.1
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.5
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.13
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.12;

11.12
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.11;

11.11
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2002.08.20.17.08.07;	author jra;	state Exp;
branches
	11.9.2.1
	11.9.4.1
	11.9.10.1;
next	11.8;

11.8
date	2002.08.15.20.55.20;	author hartley;	state Exp;
branches;
next	11.7;

11.7
date	2001.04.20.22.29.55;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2000.11.14.21.13.21;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	99.06.03.01.39.15;	author mike;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	97.10.06.21.39.27;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.12.01.02.49.33;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.52;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	10.6;

10.6
date	94.08.11.01.17.46;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	92.06.02.22.52.05;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.05.29.01.20.08;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.05.29.00.52.28;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.28.22.12.14;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.11;	author mike;	state Rel4_0;
branches;
next	1.2;

1.2
date	91.06.14.09.42.21;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	91.05.18.02.35.51;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.5.2.1
date	2000.11.14.21.35.30;	author jra;	state Exp;
branches;
next	;

11.9.2.1
date	2002.09.19.18.01.45;	author morrison;	state Exp;
branches;
next	11.9.2.2;

11.9.2.2
date	2004.03.17.21.18.56;	author morrison;	state Exp;
branches;
next	;

11.9.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.9.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	;


desc
@Surface refinement
@


11.13
log
@moved to src/
@
text
@/* 
 *       R E F I N E _ S R F . C
 *
 * Function -
 *     Refines a surface by inserting knots with respect to the row or
 *     columns of the control points resulting in the same surface with new
 *     control points.
 * 
 * Author -
 *     Paul R. Stay
 *
 * Source -
 *     SECAD/VLD Computing Consortium, Bldg 394
 *     The U.S. Army Ballistic Research Laboratory
 *     Aberdeen Proving Ground, Maryland 21005
 *
 * Copyright Notice -
 *     This software is Copyright (C) 1986-2004 by the United States Army.
 *     All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"

/*
 *			R T _ N U R B _ S _ R E F I N E
 *
 *  Returns a refined surface.
 *  The original surface is unmodified.
 */
struct face_g_snurb *
rt_nurb_s_refine(const struct face_g_snurb *srf, int dir, struct knot_vector *kv, struct resource *res)
                                		/* Old surface to be refined */
        				/* Direction to refine */
					/* Row = 0, Col = 1 */
                       			/* New knot vector */
                     
{
	register struct face_g_snurb * nurb_srf;
	struct oslo_mat *oslo;	/* oslo refinement matrix */
	int i;   

	NMG_CK_SNURB(srf);

	if (dir == RT_NURB_SPLIT_ROW) {		/* Row (u) direction */
		GET_SNURB(nurb_srf);
		nurb_srf->order[0] = srf->order[0];
		nurb_srf->order[1] = srf->order[1];
		
		rt_nurb_kvcopy(&nurb_srf->u, kv, res);
		rt_nurb_kvcopy(&nurb_srf->v, &srf->v, res);

		nurb_srf->s_size[0] = srf->s_size[0];
		nurb_srf->s_size[1] = kv->k_size - srf->order[0];
		nurb_srf->pt_type = srf->pt_type;
		nurb_srf->ctl_points = (fastf_t *)
				bu_malloc( sizeof (fastf_t) * 
				nurb_srf->s_size[0] *
				nurb_srf->s_size[1] *
				RT_NURB_EXTRACT_COORDS( nurb_srf->pt_type),
				"rt_nurb_s_refine: row mesh control points");

		oslo = (struct oslo_mat *)
		      rt_nurb_calc_oslo (srf -> order[RT_NURB_SPLIT_ROW], &srf->u, kv, res);

		for( i = 0; i < nurb_srf->s_size[0]; i++)
		{
			fastf_t * old_mesh_ptr;
			fastf_t * new_mesh_ptr;

			old_mesh_ptr = &srf->ctl_points[
				i * srf->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf->pt_type)];
			new_mesh_ptr = &nurb_srf->ctl_points[
				i * nurb_srf->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( nurb_srf->pt_type)];
			rt_nurb_map_oslo( oslo, old_mesh_ptr, new_mesh_ptr,
				RT_NURB_EXTRACT_COORDS( srf->pt_type ),
				RT_NURB_EXTRACT_COORDS( nurb_srf->pt_type ),
				0, kv->k_size - nurb_srf->order[0],
				nurb_srf->pt_type);
		}

		rt_nurb_free_oslo(oslo, res);

	} else 	{		/* Col (v) direction */
		GET_SNURB(nurb_srf);
		nurb_srf->order[0] = srf->order[0];
		nurb_srf->order[1] = srf->order[1];
		
		rt_nurb_kvcopy(&nurb_srf->u, &srf->u, res);
		rt_nurb_kvcopy(&nurb_srf->v, kv, res);

		nurb_srf->s_size[0] = kv->k_size - srf->order[1]; 
		nurb_srf->s_size[1] = srf->s_size[1];

		nurb_srf->pt_type = srf->pt_type;
		nurb_srf->ctl_points = (fastf_t *)
				bu_malloc( sizeof (fastf_t) * 
				nurb_srf->s_size[0] *
				nurb_srf->s_size[1] *
				RT_NURB_EXTRACT_COORDS( nurb_srf->pt_type),
				"rt_nurb_s_refine: row mesh control points");

		oslo = (struct oslo_mat *)
		      rt_nurb_calc_oslo (srf->order[RT_NURB_SPLIT_COL], &srf->v, kv, res);

		for( i = 0; i < nurb_srf->s_size[1]; i++)
		{
			fastf_t * old_mesh_ptr;
			fastf_t * new_mesh_ptr;

			old_mesh_ptr = &srf->ctl_points[
				i * RT_NURB_EXTRACT_COORDS( srf->pt_type)];
			new_mesh_ptr = &nurb_srf->ctl_points[
				i * RT_NURB_EXTRACT_COORDS( nurb_srf->pt_type)];
			rt_nurb_map_oslo( oslo, old_mesh_ptr, new_mesh_ptr,
				srf->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf->pt_type ),
				nurb_srf->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( nurb_srf->pt_type ),
				0, kv->k_size - nurb_srf->order[1],
				nurb_srf->pt_type);
		}
		rt_nurb_free_oslo( oslo, res );
	} 
	return nurb_srf;
}

struct edge_g_cnurb *
rt_nurb_c_refine(const struct edge_g_cnurb *crv, struct knot_vector *kv)
{
	struct oslo_mat * oslo;
	struct edge_g_cnurb * new_crv;
	int i, coords;

	NMG_CK_CNURB(crv);

	coords = RT_NURB_EXTRACT_COORDS( crv->pt_type);

	new_crv = ( struct edge_g_cnurb *) rt_nurb_new_cnurb(
		crv->order, kv->k_size, kv->k_size - crv->order,
		crv->pt_type);

	oslo = (struct oslo_mat *) rt_nurb_calc_oslo(
		crv->order, &crv->k, kv, (struct resource *)NULL);

	rt_nurb_map_oslo( oslo, crv->ctl_points, 
		new_crv->ctl_points, 
		coords, coords, 0, 
		kv->k_size - new_crv->order,
		new_crv->pt_type);

	new_crv->k.k_size = kv->k_size;

	for( i = 0; i < kv->k_size; i++)
		new_crv->k.knots[i] = kv->knots[i];

	rt_nurb_free_oslo( oslo, (struct resource *)NULL );

	return new_crv;
}
@


11.12
log
@change conf.h to a wrapped config.h
@
text
@@


11.11
log
@merge of ansi-6-0-branch into HEAD
@
text
@d22 5
a26 1
#include "conf.h"
@


11.10
log
@update copyright to include span through 2003
@
text
@d38 3
a40 3
rt_nurb_s_refine( srf, dir, kv, res )
const struct face_g_snurb * srf;		/* Old surface to be refined */
int dir;				/* Direction to refine */
d42 2
a43 2
struct knot_vector *kv;			/* New knot vector */
struct resource *res;
d137 1
a137 3
rt_nurb_c_refine( crv, kv )
const struct edge_g_cnurb * crv;
struct knot_vector * kv;
@


11.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
 *     This software is Copyright (C) 1986 by the United States Army.
@


11.9.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *     This software is Copyright (C) 1986-2004 by the United States Army.
@


11.9.10.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *     This software is Copyright (C) 1986-2004 by the United States Army.
@


11.9.2.1
log
@Initial ANSIfication
@
text
@d38 3
a40 3
rt_nurb_s_refine(const struct face_g_snurb *srf, int dir, struct knot_vector *kv, struct resource *res)
                                		/* Old surface to be refined */
        				/* Direction to refine */
d42 2
a43 2
                       			/* New knot vector */
                     
d137 3
a139 1
rt_nurb_c_refine(const struct edge_g_cnurb *crv, struct knot_vector *kv)
@


11.9.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *     This software is Copyright (C) 1986-2004 by the United States Army.
@


11.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d38 3
a40 3
rt_nurb_s_refine(const struct face_g_snurb *srf, int dir, struct knot_vector *kv, struct resource *res)
                                		/* Old surface to be refined */
        				/* Direction to refine */
d42 2
a43 2
                       			/* New knot vector */
                     
d137 3
a139 1
rt_nurb_c_refine(const struct edge_g_cnurb *crv, struct knot_vector *kv)
@


11.7
log
@CONST to const
@
text
@d38 3
a40 3
rt_nurb_s_refine( srf, dir, kv, res )
const struct face_g_snurb * srf;		/* Old surface to be refined */
int dir;				/* Direction to refine */
d42 2
a43 2
struct knot_vector *kv;			/* New knot vector */
struct resource *res;
d137 1
a137 3
rt_nurb_c_refine( crv, kv )
const struct edge_g_cnurb * crv;
struct knot_vector * kv;
@


11.6
log
@Eliminated pmalloc (a failed experiment)
@
text
@d39 1
a39 1
CONST struct face_g_snurb * srf;		/* Old surface to be refined */
d138 1
a138 1
CONST struct edge_g_cnurb * crv;
@


11.5
log
@
sed4
@
text
@d62 1
a62 9
		if( res )
			nurb_srf->ctl_points = (fastf_t *)
				rt_pmalloc( sizeof (fastf_t) * 
				nurb_srf->s_size[0] *
				nurb_srf->s_size[1] *
				RT_NURB_EXTRACT_COORDS( nurb_srf->pt_type),
				&res->re_pmem);
		else
			nurb_srf->ctl_points = (fastf_t *)
d104 1
a104 9
		if( res )
			nurb_srf->ctl_points = (fastf_t *)
				rt_pmalloc( sizeof (fastf_t) * 
				nurb_srf->s_size[0] *
				nurb_srf->s_size[1] *
				RT_NURB_EXTRACT_COORDS( nurb_srf->pt_type),
				&res->re_pmem);
		else
			nurb_srf->ctl_points = (fastf_t *)
@


11.5.2.1
log
@Eliminated pmalloc (a failed experiment)
@
text
@d62 9
a70 1
		nurb_srf->ctl_points = (fastf_t *)
d112 9
a120 1
		nurb_srf->ctl_points = (fastf_t *)
@


11.4
log
@rt_pmalloc
@
text
@d71 1
a71 1
				rt_malloc( sizeof (fastf_t) * 
d121 1
a121 1
				rt_malloc( sizeof (fastf_t) * 
@


11.3
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d64 1
a64 1
				pmalloc( sizeof (fastf_t) * 
d114 1
a114 1
				pmalloc( sizeof (fastf_t) * 
@


11.2
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d38 1
a38 1
rt_nurb_s_refine( srf, dir, kv )
d43 1
d56 2
a57 2
		rt_nurb_kvcopy(&nurb_srf->u, kv);
		rt_nurb_kvcopy(&nurb_srf->v, &srf->v);
d62 3
a64 2
		nurb_srf->ctl_points = (fastf_t *)
			rt_malloc( sizeof (fastf_t) * 
d68 7
d78 1
a78 1
		      rt_nurb_calc_oslo (srf -> order[RT_NURB_SPLIT_ROW], &srf->u, kv);
d98 1
a98 1
		rt_nurb_free_oslo(oslo);
d105 2
a106 2
		rt_nurb_kvcopy(&nurb_srf->u, &srf->u);
		rt_nurb_kvcopy(&nurb_srf->v, kv);
d112 10
a121 2
		nurb_srf->ctl_points = (fastf_t *)
			rt_malloc( sizeof (fastf_t) * 
d128 1
a128 1
		      rt_nurb_calc_oslo (srf->order[RT_NURB_SPLIT_COL], &srf->v, kv);
d147 1
a147 1
		rt_nurb_free_oslo( oslo );
d170 1
a170 1
		crv->order, &crv->k, kv);
d183 1
a183 1
	rt_nurb_free_oslo( oslo );
@


11.1
log
@Release_4.4
@
text
@d37 1
a37 1
struct snurb *
d39 1
a39 1
CONST struct snurb * srf;		/* Old surface to be refined */
d44 1
a44 1
	register struct snurb * nurb_srf;
d55 2
a56 2
		rt_nurb_kvcopy(&nurb_srf->u_knots, kv);
		rt_nurb_kvcopy(&nurb_srf->v_knots, &srf->v_knots);
d69 1
a69 1
		      rt_nurb_calc_oslo (srf -> order[RT_NURB_SPLIT_ROW], &srf->u_knots, kv);
d96 2
a97 2
		rt_nurb_kvcopy(&nurb_srf->u_knots, &srf->u_knots);
		rt_nurb_kvcopy(&nurb_srf->v_knots, kv);
d111 1
a111 1
		      rt_nurb_calc_oslo (srf->order[RT_NURB_SPLIT_COL], &srf->v_knots, kv);
d135 1
a135 1
struct cnurb *
d137 1
a137 1
CONST struct cnurb * crv;
d141 1
a141 1
	struct cnurb * new_crv;
d148 1
a148 1
	new_crv = ( struct cnurb *) rt_nurb_new_cnurb(
d153 1
a153 1
		crv->order, &crv->knot, kv);
d161 1
a161 1
	new_crv->knot.k_size = kv->k_size;
d164 1
a164 1
		new_crv->knot.knots[i] = kv->knots[i];
@


11.1.1.1
log
@Release_4.5
@
text
@d37 3
a39 3
struct face_g_snurb *
rt_nurb_s_refine( srf, dir, kv, res )
CONST struct face_g_snurb * srf;		/* Old surface to be refined */
a42 1
struct resource *res;
d44 1
a44 1
	register struct face_g_snurb * nurb_srf;
d55 2
a56 2
		rt_nurb_kvcopy(&nurb_srf->u, kv, res);
		rt_nurb_kvcopy(&nurb_srf->v, &srf->v, res);
d61 2
a62 10
		if( res )
			nurb_srf->ctl_points = (fastf_t *)
				rt_pmalloc( sizeof (fastf_t) * 
				nurb_srf->s_size[0] *
				nurb_srf->s_size[1] *
				RT_NURB_EXTRACT_COORDS( nurb_srf->pt_type),
				&res->re_pmem);
		else
			nurb_srf->ctl_points = (fastf_t *)
				rt_malloc( sizeof (fastf_t) * 
d69 1
a69 1
		      rt_nurb_calc_oslo (srf -> order[RT_NURB_SPLIT_ROW], &srf->u, kv, res);
d89 1
a89 1
		rt_nurb_free_oslo(oslo, res);
d96 2
a97 2
		rt_nurb_kvcopy(&nurb_srf->u, &srf->u, res);
		rt_nurb_kvcopy(&nurb_srf->v, kv, res);
d103 2
a104 10
		if( res )
			nurb_srf->ctl_points = (fastf_t *)
				rt_pmalloc( sizeof (fastf_t) * 
				nurb_srf->s_size[0] *
				nurb_srf->s_size[1] *
				RT_NURB_EXTRACT_COORDS( nurb_srf->pt_type),
				&res->re_pmem);
		else
			nurb_srf->ctl_points = (fastf_t *)
				rt_malloc( sizeof (fastf_t) * 
d111 1
a111 1
		      rt_nurb_calc_oslo (srf->order[RT_NURB_SPLIT_COL], &srf->v, kv, res);
d130 1
a130 1
		rt_nurb_free_oslo( oslo, res );
d135 1
a135 1
struct edge_g_cnurb *
d137 1
a137 1
CONST struct edge_g_cnurb * crv;
d141 1
a141 1
	struct edge_g_cnurb * new_crv;
d148 1
a148 1
	new_crv = ( struct edge_g_cnurb *) rt_nurb_new_cnurb(
d153 1
a153 1
		crv->order, &crv->k, kv, (struct resource *)NULL);
d161 1
a161 1
	new_crv->k.k_size = kv->k_size;
d164 1
a164 1
		new_crv->k.knots[i] = kv->knots[i];
d166 1
a166 1
	rt_nurb_free_oslo( oslo, (struct resource *)NULL );
@


10.6
log
@Added include of conf.h
@
text
@@


10.5
log
@Changed lists to use rt_list structures
Made some args CONST where appropriate
Switched to GET_CNURB() macros
Added calls to NMG_CK_SNURB()
@
text
@d22 2
@


10.4
log
@Control polygon/mesh is now just part of the cnurb/snurb structures,
rather than being a separate structure of their own.
@
text
@d25 2
d29 6
d37 1
a37 1
struct snurb * srf;			/* Old surface to be refined */
d46 2
d49 1
a49 5

    		nurb_srf = (struct snurb *) rt_malloc( sizeof (struct snurb),
			"rt_nurb_s_refine: row snurb struct");
		
		nurb_srf->next = (struct snurb *) 0;
d90 1
a90 5

    		nurb_srf = (struct snurb *) rt_malloc( sizeof (struct snurb),
			"rt_nurb_s_refine: row snurb struct");
		
		nurb_srf->next = (struct snurb *) 0;
d130 1
a130 2

    return nurb_srf;
d135 1
a135 1
struct cnurb * crv;
d141 2
@


10.3
log
@Modifications due to data structure revisions:  mesh and knots are no
longer pointers, but in-place structures.
@
text
@d50 4
a53 4
		nurb_srf->mesh.s_size[0] = srf->mesh.s_size[0];
		nurb_srf->mesh.s_size[1] = kv->k_size - srf->order[0];
		nurb_srf->mesh.pt_type = srf->mesh.pt_type;
		nurb_srf->mesh.ctl_points = (fastf_t *)
d55 3
a57 3
				nurb_srf->mesh.s_size[0] *
				nurb_srf->mesh.s_size[1] *
				RT_NURB_EXTRACT_COORDS( nurb_srf->mesh.pt_type),
d63 1
a63 1
		for( i = 0; i < nurb_srf->mesh.s_size[0]; i++)
d68 6
a73 6
			old_mesh_ptr = &srf->mesh.ctl_points[
				i * srf->mesh.s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf->mesh.pt_type)];
			new_mesh_ptr = &nurb_srf->mesh.ctl_points[
				i * nurb_srf->mesh.s_size[1] * 
				RT_NURB_EXTRACT_COORDS( nurb_srf->mesh.pt_type)];
d75 2
a76 2
				RT_NURB_EXTRACT_COORDS( srf->mesh.pt_type ),
				RT_NURB_EXTRACT_COORDS( nurb_srf->mesh.pt_type ),
d78 1
a78 1
				nurb_srf->mesh.pt_type);
d95 2
a96 2
		nurb_srf->mesh.s_size[0] = kv->k_size - srf->order[1]; 
		nurb_srf->mesh.s_size[1] = srf->mesh.s_size[1];
d98 2
a99 2
		nurb_srf->mesh.pt_type = srf->mesh.pt_type;
		nurb_srf->mesh.ctl_points = (fastf_t *)
d101 3
a103 3
				nurb_srf->mesh.s_size[0] *
				nurb_srf->mesh.s_size[1] *
				RT_NURB_EXTRACT_COORDS( nurb_srf->mesh.pt_type),
d109 1
a109 1
		for( i = 0; i < nurb_srf->mesh.s_size[1]; i++)
d114 4
a117 4
			old_mesh_ptr = &srf->mesh.ctl_points[
				i * RT_NURB_EXTRACT_COORDS( srf->mesh.pt_type)];
			new_mesh_ptr = &nurb_srf->mesh.ctl_points[
				i * RT_NURB_EXTRACT_COORDS( nurb_srf->mesh.pt_type)];
d119 4
a122 4
				srf->mesh.s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf->mesh.pt_type ),
				nurb_srf->mesh.s_size[1] * 
				RT_NURB_EXTRACT_COORDS( nurb_srf->mesh.pt_type ),
d124 1
a124 1
				nurb_srf->mesh.pt_type);
d141 1
a141 1
	coords = RT_NURB_EXTRACT_COORDS( crv->mesh.pt_type);
d145 1
a145 1
		crv->mesh.pt_type);
d150 2
a151 2
	rt_nurb_map_oslo( oslo, crv->mesh.ctl_points, 
		new_crv->mesh.ctl_points, 
d154 1
a154 1
		new_crv->mesh.pt_type);
@


10.2
log
@Expanded names of manifest constants
@
text
@d47 2
a48 4
		nurb_srf->u_knots = (struct knot_vector *)
			rt_nurb_kvcopy(kv);
		nurb_srf->v_knots = (struct knot_vector *)
			rt_nurb_kvcopy(srf->v_knots);
d50 4
a53 7
		nurb_srf->mesh = (struct s_mesh *) rt_malloc(
			sizeof( struct s_mesh ), "rt_nurb_s_refine: row s_mesh");
		
		nurb_srf->mesh->s_size[0] = srf->mesh->s_size[0];
		nurb_srf->mesh->s_size[1] = kv->k_size - srf->order[0];
		nurb_srf->mesh->pt_type = srf->mesh->pt_type;
		nurb_srf->mesh->ctl_points = (fastf_t *)
d55 3
a57 3
				nurb_srf->mesh->s_size[0] *
				nurb_srf->mesh->s_size[1] *
				RT_NURB_EXTRACT_COORDS( nurb_srf->mesh->pt_type),
d61 1
a61 1
		      rt_nurb_calc_oslo (srf -> order[RT_NURB_SPLIT_ROW], srf->u_knots, kv);
d63 1
a63 1
		for( i = 0; i < nurb_srf->mesh->s_size[0]; i++)
d68 6
a73 6
			old_mesh_ptr = &srf->mesh->ctl_points[
				i * srf->mesh->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf->mesh->pt_type)];
			new_mesh_ptr = &nurb_srf->mesh->ctl_points[
				i * nurb_srf->mesh->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( nurb_srf->mesh->pt_type)];
d75 2
a76 2
				RT_NURB_EXTRACT_COORDS( srf->mesh->pt_type ),
				RT_NURB_EXTRACT_COORDS( nurb_srf->mesh->pt_type ),
d78 1
a78 1
				nurb_srf->mesh->pt_type);
d92 2
a93 4
		nurb_srf->u_knots = (struct knot_vector *)
			rt_nurb_kvcopy(srf->u_knots);
		nurb_srf->v_knots = (struct knot_vector *)
			rt_nurb_kvcopy(kv);
d95 2
a96 5
		nurb_srf->mesh = (struct s_mesh *) rt_malloc(
			sizeof( struct s_mesh ), "rt_nurb_s_refine: row s_mesh");
		
		nurb_srf->mesh->s_size[0] = kv->k_size - srf->order[1]; 
		nurb_srf->mesh->s_size[1] = srf->mesh->s_size[1];
d98 2
a99 2
		nurb_srf->mesh->pt_type = srf->mesh->pt_type;
		nurb_srf->mesh->ctl_points = (fastf_t *)
d101 3
a103 3
				nurb_srf->mesh->s_size[0] *
				nurb_srf->mesh->s_size[1] *
				RT_NURB_EXTRACT_COORDS( nurb_srf->mesh->pt_type),
d107 1
a107 1
		      rt_nurb_calc_oslo (srf->order[RT_NURB_SPLIT_COL], srf->v_knots, kv);
d109 1
a109 1
		for( i = 0; i < nurb_srf->mesh->s_size[1]; i++)
d114 4
a117 4
			old_mesh_ptr = &srf->mesh->ctl_points[
				i * RT_NURB_EXTRACT_COORDS( srf->mesh->pt_type)];
			new_mesh_ptr = &nurb_srf->mesh->ctl_points[
				i * RT_NURB_EXTRACT_COORDS( nurb_srf->mesh->pt_type)];
d119 4
a122 4
				srf->mesh->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf->mesh->pt_type ),
				nurb_srf->mesh->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( nurb_srf->mesh->pt_type ),
d124 1
a124 1
				nurb_srf->mesh->pt_type);
d141 1
a141 1
	coords = RT_NURB_EXTRACT_COORDS( crv->mesh->pt_type);
d145 1
a145 1
		crv->mesh->pt_type);
d148 1
a148 1
		crv->order, crv->knot, kv);
d150 2
a151 2
	rt_nurb_map_oslo( oslo, crv->mesh->ctl_points, 
		new_crv->mesh->ctl_points, 
d154 1
a154 1
		new_crv->mesh->pt_type);
d156 1
a156 1
	new_crv->knot->k_size = kv->k_size;
d159 1
a159 1
		new_crv->knot->knots[i] = kv->knots[i];
@


10.1
log
@Release_4.0
@
text
@d38 1
a38 1
	if (dir == ROW) {		/* Row (u) direction */
d62 1
a62 1
				EXTRACT_COORDS( nurb_srf->mesh->pt_type),
d66 1
a66 1
		      rt_nurb_calc_oslo (srf -> order[ROW], srf->u_knots, kv);
d75 1
a75 1
				EXTRACT_COORDS( srf->mesh->pt_type)];
d78 1
a78 1
				EXTRACT_COORDS( nurb_srf->mesh->pt_type)];
d80 2
a81 2
				EXTRACT_COORDS( srf->mesh->pt_type ),
				EXTRACT_COORDS( nurb_srf->mesh->pt_type ),
d113 1
a113 1
				EXTRACT_COORDS( nurb_srf->mesh->pt_type),
d117 1
a117 1
		      rt_nurb_calc_oslo (srf->order[COL], srf->v_knots, kv);
d125 1
a125 1
				i * EXTRACT_COORDS( srf->mesh->pt_type)];
d127 1
a127 1
				i * EXTRACT_COORDS( nurb_srf->mesh->pt_type)];
d130 1
a130 1
				EXTRACT_COORDS( srf->mesh->pt_type ),
d132 1
a132 1
				EXTRACT_COORDS( nurb_srf->mesh->pt_type ),
d151 1
a151 1
	coords = EXTRACT_COORDS( crv->mesh->pt_type);
@


1.2
log
@fixed nurb.h
@
text
@@


1.1
log
@Initial revision
@
text
@d25 1
a25 1
#include "./nurb.h"
@
