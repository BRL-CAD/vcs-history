head	11.30;
access;
symbols
	ansi-20040405-merged:11.26.2.2
	postmerge-20040405-ansi:11.28
	premerge-20040404-ansi:11.27
	postmerge-autoconf:11.27
	autoconf-freeze:11.26.10.2
	premerge-autoconf:11.27
	ansi-20040316-freeze:11.26.2.1
	postmerge-20040315-windows:11.27
	premerge-20040315-windows:11.27
	windows-20040315-freeze:11.26.4.1
	autoconf-20031203:11.26
	autoconf-20031202:11.26
	autoconf-branch:11.26.0.10
	phong-branch:11.26.0.8
	photonmap-branch:11.26.0.6
	rel-6-1-DP:11.26
	windows-branch:11.26.0.4
	rel-6-0-2:11.24
	ansi-branch:11.26.0.2
	rel-6-0-1-branch:11.24.0.2
	hartley-6-0-post:11.25
	hartley-6-0-pre:11.24
	rel-6-0-1:11.24
	rel-6-0:11.24
	rel-5-4:11.16
	offsite-5-3-pre:11.21
	rel-5-3:11.16
	rel-5-2:11.16
	rel-5-1-branch:11.16.0.2
	rel-5-1:11.16
	rel-5-0:11.8
	rel-5-0-beta:11.8
	rel-4-5:11.7
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.30
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	11.29;

11.29
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.28;

11.28
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2002.08.20.17.07.57;	author jra;	state Exp;
branches
	11.26.2.1
	11.26.4.1
	11.26.10.1;
next	11.25;

11.25
date	2002.08.15.20.55.10;	author hartley;	state Exp;
branches;
next	11.24;

11.24
date	2001.10.04.19.36.09;	author rbowers;	state Exp;
branches;
next	11.23;

11.23
date	2001.05.17.20.05.23;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2001.04.20.22.29.42;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2000.09.08.05.54.41;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.07.13.02.20.37;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.07.13.01.13.02;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.07.12.01.13.11;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.07.10.23.01.28;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.03.04.05.53.45;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.03.02.14.47.27;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	2000.01.07.04.21.06;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.01.07.02.26.47;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.01.06.22.36.34;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.12.29.23.23.09;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.11.08.15.08.05;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	99.10.12.13.58.12;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	98.03.19.15.00.40;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	97.12.16.06.09.51;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.06.03.16.03.59;	author pjt;	state Exp;
branches;
next	11.5;

11.5
date	96.11.20.19.49.35;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.12.28.14.26.36;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.07.28.19.15.53;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.18;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.12.27.16.56.59;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.11.05.04.41.23;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.10.18.03.39;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.04;	author mike;	state Rel4_0;
branches;
next	9.11;

9.11
date	91.07.01.02.03.15;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.06.14.06.26.34;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.02.27.19.48.52;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.02.06.22.32.57;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.01.14.22.46.06;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.01.12.06.52.59;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.07.05.51.18;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.10.11.02.36.46;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.12.08.06.14.36;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.13.18;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.55.47;	author mike;	state Rel3_5;
branches;
next	1.2;

1.2
date	89.05.08.21.42.57;	author phil;	state Exp;
branches;
next	1.1;

1.1
date	88.12.06.00.09.23;	author mike;	state Exp;
branches;
next	;

11.26.2.1
date	2002.09.19.18.01.31;	author morrison;	state Exp;
branches;
next	11.26.2.2;

11.26.2.2
date	2004.03.17.21.18.44;	author morrison;	state Exp;
branches;
next	;

11.26.4.1
date	2004.03.11.23.43.36;	author morrison;	state Exp;
branches;
next	;

11.26.10.1
date	2004.02.12.18.37.38;	author erikg;	state Exp;
branches;
next	11.26.10.2;

11.26.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@db_scan
@


11.30
log
@moved to src/
@
text
@/*
 *			D B _ S C A N . C
 *
 * Functions -
 *	db_scan		Sequentially read database, send objects to handler()
 *	db_ident	Update database IDENT record
 *      db_conversions  Update unit conversion factors
 *
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db_scan.c,v 11.29 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "raytrace.h"

#include "./debug.h"

#define DEBUG_PR(aaa, rrr) 	{\
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_scan x%x %c (0%o)\n", \
		aaa,rrr.u_id,rrr.u_id ); }

/*
 *			D B _ S C A N
 *
 *  This routine sequentially reads through the model database file and
 *  builds a directory of the object names, to allow rapid
 *  named access to objects.
 *
 *  Note that some multi-record database items include length fields.
 *  These length fields are not used here.
 *  Instead, the sizes of multi-record items are determined by
 *  reading ahead and computing the actual size.
 *  This prevents difficulties arising from external "adjustment" of
 *  the number of records without corresponding adjustment of the length fields.
 *  In the future, these length fields will be phased out.
 *
 *  The handler will be called with a variety of args.
 *  The handler is responsible for handling name strings of exactly
 *  NAMESIZE chars.
 *  The most common example of such a function is db_diradd().
 *
 *  Note that the handler may do I/O, including repositioning the
 *  file pointer, so this must be taken into account.
 *
 * Returns -
 *	 0	Success
 *	-1	Fatal Error
 */
int
db_scan(register struct db_i *dbip, int (*handler) (struct db_i *, const char *, long int, int, int, genptr_t), int do_old_matter, genptr_t client_data)
                    	      
   			                                                                                                           
   			              
        		            	/* argument for handler */
{
	union record	record;		/* Initial record, holds name */
	union record	rec2;		/* additional record(s) */
	register long	addr;		/* start of current rec */
	register long	here;		/* intermediate positions */
	register long	next;		/* start of next rec */
	register int	nrec;		/* # records for this solid */
	register int	totrec;		/* # records for database */
	register int	j;

	RT_CK_DBI(dbip);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_scan( x%x, x%x )\n", dbip, handler);

	/* XXXX Note that this ignores dbip->dbi_inmem */
	/* In a portable way, read the header (even if not rewound) */
	rewind( dbip->dbi_fp );
	if( fread( (char *)&record, sizeof record, 1, dbip->dbi_fp ) != 1  ||
	    record.u_id != ID_IDENT )  {
		bu_log("db_scan ERROR:  File is lacking a proper MGED database header\n");
	    	return(-1);
	}
	rewind( dbip->dbi_fp );
	next = ftell(dbip->dbi_fp);

	here = addr = -1L;
	totrec = 0;
	while(1)  {
		nrec = 0;
		if( fseek(dbip->dbi_fp, next, 0) != 0 )  {
			bu_log("db_scan:  fseek(offset=%d) failure\n", next);
			return(-1);
		}
		addr = next;

		if( fread( (char *)&record, sizeof record, 1, dbip->dbi_fp ) != 1
		    || feof(dbip->dbi_fp) )
			break;
		next = ftell(dbip->dbi_fp);
		DEBUG_PR( addr, record );

		nrec++;
		switch( record.u_id )  {
		case ID_IDENT:
			if( strcmp( record.i.i_version, ID_VERSION) != 0 )  {
				bu_log("db_scan WARNING: File is Version %s, Program is version %s\n",
					record.i.i_version, ID_VERSION );
			}
			/* Record first IDENT records title string */
			if( dbip->dbi_title == (char *)0 )  {
				dbip->dbi_title = bu_strdup( record.i.i_title );
				db_conversions( dbip, record.i.i_units );
			}
			break;
		case ID_FREE:
			/* Inform db manager of avail. space */
			rt_memfree( &(dbip->dbi_freep), (unsigned)1,
				addr/sizeof(union record) );
			break;
		case ID_ARS_A:
			while(1) {
				here = ftell( dbip->dbi_fp );
				if( fread( (char *)&rec2, sizeof(rec2),
				    1, dbip->dbi_fp ) != 1 )
					break;
				DEBUG_PR( here, rec2 );
				if( rec2.u_id != ID_ARS_B )  {
					fseek( dbip->dbi_fp, here, 0 );
					break;
				}
				nrec++;
			}
			next = ftell(dbip->dbi_fp);
			handler( dbip, record.a.a_name, addr, nrec,
				DIR_SOLID, client_data );
			break;
		case ID_ARS_B:
			bu_log("db_scan ERROR: Unattached ARS 'B' record\n");
			break;
		case ID_SOLID:
			handler( dbip, record.s.s_name, addr, nrec,
				DIR_SOLID, client_data );
			break;
		case DBID_STRSOL:
			for( ; nrec < DB_SS_NGRAN; nrec++ )  {
				if( fread( (char *)&rec2, sizeof(rec2),
				    1, dbip->dbi_fp ) != 1 )
					break;
			}
			next = ftell(dbip->dbi_fp);
			handler( dbip, record.ss.ss_name, addr, nrec,
				DIR_SOLID, client_data );
			break;
		case ID_MATERIAL:
			if( do_old_matter ) {
				/* This is common to RT and MGED */
				rt_color_addrec(
					record.md.md_low,
					record.md.md_hi,
					record.md.md_r,
					record.md.md_g,
					record.md.md_b,
					addr );
			}
			break;
		case ID_P_HEAD:
			while(1) {
				here = ftell( dbip->dbi_fp );
				if( fread( (char *)&rec2, sizeof(rec2),
				    1, dbip->dbi_fp ) != 1 )
					break;
				DEBUG_PR( here, rec2 );
				if( rec2.u_id != ID_P_DATA )  {
					fseek( dbip->dbi_fp, here, 0 );
					break;
				}
				nrec++;
			}
			next = ftell(dbip->dbi_fp);
			handler( dbip, record.p.p_name, addr, nrec,
				DIR_SOLID, client_data );
			break;
		case ID_P_DATA:
			bu_log("db_scan ERROR: Unattached P_DATA record\n");
			break;
		case ID_BSOLID:
			while(1) {
				/* Find and skip subsequent BSURFs */
				here = ftell( dbip->dbi_fp );
				if( fread( (char *)&rec2, sizeof(rec2),
				    1, dbip->dbi_fp ) != 1 )
					break;
				DEBUG_PR( here, rec2 );
				if( rec2.u_id != ID_BSURF )  {
					fseek( dbip->dbi_fp, here, 0 );
					break;
				}

				/* Just skip over knots and control mesh */
				j = (rec2.d.d_nknots + rec2.d.d_nctls);
				nrec += j+1;
				while( j-- > 0 )
					fread( (char *)&rec2, sizeof(rec2), 1, dbip->dbi_fp );
				next = ftell(dbip->dbi_fp);
			}
			handler( dbip, record.B.B_name, addr, nrec,
				DIR_SOLID, client_data );
			break;
		case ID_BSURF:
			bu_log("db_scan ERROR: Unattached B-spline surface record\n");

			/* Just skip over knots and control mesh */
			j = (record.d.d_nknots + record.d.d_nctls);
			nrec += j;
			while( j-- > 0 )
				fread( (char *)&rec2, sizeof(rec2), 1, dbip->dbi_fp );
			break;
		case DBID_ARBN:
			j = bu_glong(record.n.n_grans);
			nrec += j;
			while( j-- > 0 )
				fread( (char *)&rec2, sizeof(rec2), 1, dbip->dbi_fp );
			next = ftell(dbip->dbi_fp);
			handler( dbip, record.n.n_name, addr, nrec,
				DIR_SOLID, client_data );
			break;
		case DBID_PARTICLE:
			handler( dbip, record.part.p_name, addr, nrec,
				DIR_SOLID, client_data );
			break;
		case DBID_PIPE:
			j = bu_glong(record.pwr.pwr_count);
			nrec += j;
			while( j-- > 0 )
				fread( (char *)&rec2, sizeof(rec2), 1, dbip->dbi_fp );
			next = ftell(dbip->dbi_fp);
			handler( dbip, record.pwr.pwr_name, addr, nrec,
				DIR_SOLID, client_data );
			break;
		case DBID_NMG:
			j = bu_glong(record.nmg.N_count);
			nrec += j;
			while( j-- > 0 )
				(void)fread( (char *)&rec2, sizeof(rec2), 1, dbip->dbi_fp );
			next = ftell(dbip->dbi_fp);
			handler( dbip, record.nmg.N_name, addr, nrec,
				DIR_SOLID, client_data );
			break;
		case DBID_SKETCH:
			j = bu_glong(record.skt.skt_count);
			nrec += j;
			while( j-- > 0 )
				(void)fread( (char *)&rec2, sizeof(rec2), 1, dbip->dbi_fp );
			next = ftell(dbip->dbi_fp);
			handler( dbip, record.skt.skt_name, addr, nrec,
				DIR_SOLID, client_data );
			break;
		case DBID_EXTR:
			j = bu_glong(record.extr.ex_count);
			nrec += j;
			while( j-- > 0 )
				(void)fread( (char *)&rec2, sizeof(rec2), 1, dbip->dbi_fp );
			next = ftell(dbip->dbi_fp);
			handler( dbip, record.extr.ex_name, addr, nrec,
				DIR_SOLID, client_data );
			break;
		case DBID_CLINE:
			handler( dbip, record.s.s_name, addr, nrec,
				DIR_SOLID, client_data );
			break;
		case DBID_BOT:
			j = bu_glong( record.bot.bot_nrec );
			nrec += j;
			while( j-- > 0 )
				(void)fread( (char *)&rec2, sizeof(rec2), 1, dbip->dbi_fp );
			next = ftell(dbip->dbi_fp);
			handler( dbip, record.s.s_name, addr, nrec,
				DIR_SOLID, client_data );
			break;
		case ID_MEMB:
			bu_log("db_scan ERROR: Unattached combination MEMBER record\n");
			break;
		case ID_COMB:
			while(1) {
				here = ftell( dbip->dbi_fp );
				if( fread( (char *)&rec2, sizeof(rec2),
				    1, dbip->dbi_fp ) != 1 )
					break;
				DEBUG_PR( here, rec2 );
				if( rec2.u_id != ID_MEMB )  {
					fseek( dbip->dbi_fp, here, 0 );
					break;
				}
				nrec++;
			}
			next = ftell(dbip->dbi_fp);
			switch(record.c.c_flags)  {
			default:
			case DBV4_NON_REGION:
				j = DIR_COMB;
				break;
			case DBV4_REGION:
			case DBV4_REGION_FASTGEN_PLATE:
			case DBV4_REGION_FASTGEN_VOLUME:
				j = DIR_COMB|DIR_REGION;
				break;
			}
			handler( dbip, record.c.c_name, addr, nrec, j,
				client_data );
			break;
		default:
			bu_log("db_scan ERROR:  bad record %c (0%o), addr=x%x\n",
				record.u_id, record.u_id, addr );
			/* skip this record */
			break;
		}
		totrec += nrec;
	}
	dbip->dbi_nrec = totrec;
	dbip->dbi_eof = ftell( dbip->dbi_fp );
	rewind( dbip->dbi_fp );

	return( 0 );			/* OK */
}

/*
 *			D B _ U P D A T E _ I D E N T
 *
 *  Update the existing v4 IDENT record with new title and units.
 *  To permit using db_get and db_put, a custom directory entry is crafted.
 *
 *  Note:  Special care is required, because the "title" arg may actually
 *  be passed in as dbip->dbi_title.
 */
int
db_update_ident( struct db_i *dbip, const char *new_title, double local2mm )
{
	struct directory	dir;
	union record		rec;
	char			*old_title;
	int			v4units;

	RT_CK_DBI(dbip);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_update_ident( x%x, '%s', %g )\n",
		dbip, new_title, local2mm );

	BU_ASSERT_LONG( dbip->dbi_version, >, 0 );

	if( dbip->dbi_read_only )
		return(-1);

	if( dbip->dbi_version > 4 )  return db5_update_ident( dbip, new_title, local2mm );

	RT_DIR_SET_NAMEP(&dir, "/IDENT/");
	dir.d_addr = 0L;
	dir.d_len = 1;
	dir.d_magic = RT_DIR_MAGIC;
	dir.d_flags = 0;
	if( db_get( dbip, &dir, &rec, 0, 1 ) < 0 ||
	    rec.u_id != ID_IDENT )  {
	    	bu_log("db_update_ident() corrupted database header!\n");
	    	dbip->dbi_read_only = 1;
		return(-1);
	}

	rec.i.i_title[0] = '\0';
	(void)strncpy(rec.i.i_title, new_title, sizeof(rec.i.i_title)-1 );

	old_title = dbip->dbi_title;
	dbip->dbi_title = bu_strdup( new_title );

	if( (v4units = db_v4_get_units_code(bu_units_string(local2mm))) < 0 )  {
		bu_log("db_update_ident(): \
Due to a restriction in previous versions of the BRL-CAD database format, your\n\
editing units %g will not be remembered on your next editing session.\n\
This will not harm the integrity of your database.\n\
You may wish to consider upgrading your database using \"dbupgrade\".\n",
			local2mm);
		v4units = ID_MM_UNIT;
	}
	rec.i.i_units = v4units;

	if( old_title )
		bu_free( old_title, "old dbi_title" );

	return( db_put( dbip, &dir, &rec, 0, 1 ) );

}

/*
 *			D B _ F W R I T E _ I D E N T
 *
 *  Fwrite an IDENT record with given title and editing scale.
 *  Attempts to map the editing scale into a v4 database unit
 *  as best it can.  No harm done if it doesn't map.
 *
 *  This should be called by db_create() only.
 *  All others should call db_update_ident().
 *
 * Returns -
 *	 0	Success
 *	-1	Fatal Error
 */
int
db_fwrite_ident( FILE *fp, const char *title, double local2mm )
{
	union record		rec;
	int			code;

	code = db_v4_get_units_code(bu_units_string(local2mm));

	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_fwrite_ident( x%x, '%s', %g ) code=%d\n",
		fp, title, local2mm, code );

	bzero( (char *)&rec, sizeof(rec) );
	rec.i.i_id = ID_IDENT;
	rec.i.i_units = code;
	(void)strncpy( rec.i.i_version, ID_VERSION, sizeof(rec.i.i_version) );
	(void)strncpy(rec.i.i_title, title, sizeof(rec.i.i_title)-1 );

	if( fwrite( (char *)&rec, sizeof(rec), 1, fp ) != 1 )
		return -1;
	return 0;
}

/*
 *			D B _ C O N V E R S I O N S
 *
 *	Initialize conversion factors given the v4 database unit
 */
void
db_conversions(struct db_i *dbip, int local)
           	      
          					/* one of ID_??_UNIT */
{
	RT_CK_DBI(dbip);

	/* Base unit is MM */
	switch( local ) {

	case ID_NO_UNIT:
		/* no local unit specified ... use the base unit */
		dbip->dbi_local2base = 1.0;
		break;

	case ID_UM_UNIT:
		/* local unit is um */
		dbip->dbi_local2base = 0.001;		/* UM to MM */
		break;

	case ID_MM_UNIT:
		/* local unit is mm */
		dbip->dbi_local2base = 1.0;
		break;

	case ID_CM_UNIT:
		/* local unit is cm */
		dbip->dbi_local2base = 10.0;		/* CM to MM */
		break;

	case ID_M_UNIT:
		/* local unit is meters */
		dbip->dbi_local2base = 1000.0;		/* M to MM */
		break;

	case ID_KM_UNIT:
		/* local unit is km */
		dbip->dbi_local2base = 1000000.0;	/* KM to MM */
		break;

	case ID_IN_UNIT:
		/* local unit is inches */
		dbip->dbi_local2base = 25.4;		/* IN to MM */
		break;

	case ID_FT_UNIT:
		/* local unit is feet */
		dbip->dbi_local2base = 304.8;		/* FT to MM */
		break;

	case ID_YD_UNIT:
		/* local unit is yards */
		dbip->dbi_local2base = 914.4;		/* YD to MM */
		break;

	case ID_MI_UNIT:
		/* local unit is miles */
		dbip->dbi_local2base = 1609344;		/* MI to MM */
		break;

	default:
		dbip->dbi_local2base = 1.0;
		break;
	}
	dbip->dbi_base2local = 1.0 / dbip->dbi_local2base;
}

/*
 *			D B _ V 4 _ G E T _ U N I T S _ C O D E
 *
 *  Given a string, return the V4 database code representing
 *  the user's preferred editing units.
 *  The v4 database format does not have many choices.
 *
 *  Returns -
 *	-1	Not a legal V4 database code
 *	#	The V4 database code number
 */
int
db_v4_get_units_code( const char *str )
{
	if( !str )  return ID_NO_UNIT;	/* no units specified */

	if( strcmp(str, "mm") == 0 || strcmp(str, "millimeters") == 0 ) 
		return ID_MM_UNIT;
	if( strcmp(str, "um") == 0 || strcmp(str, "micrometers") == 0) 
		return ID_UM_UNIT;
	if( strcmp(str, "cm") == 0 || strcmp(str, "centimeters") == 0) 
		return ID_CM_UNIT;
	if( strcmp(str,"m")==0 || strcmp(str,"meters")==0 ) 
		return ID_M_UNIT;
	if( strcmp(str, "km") == 0 || strcmp(str, "kilometers") == 0) 
		return ID_KM_UNIT;
	if( strcmp(str,"in")==0 || strcmp(str,"inches")==0 || strcmp(str,"inch")==0 ) 
		return ID_IN_UNIT;
	if( strcmp(str,"ft")==0 || strcmp(str,"feet")==0 || strcmp(str,"foot")==0 ) 
		return ID_FT_UNIT;
	if( strcmp(str,"yd")==0 || strcmp(str,"yards")==0 || strcmp(str,"yard")==0 ) 
		return ID_YD_UNIT;
	if( strcmp(str,"mi")==0 || strcmp(str,"miles")==0 || strcmp(str,"mile")==0 ) 
		return ID_MI_UNIT;

	return -1;		/* error */
}
@


11.29
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db_scan.c,v 11.28 2004/04/05 08:48:56 morrison Exp $ (ARL)";
@


11.28
log
@merge of ansi-6-0-branch into HEAD
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d30 5
a34 1
#include "conf.h"
@


11.27
log
@update copyright to include span through 2003
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.26 2002/08/20 17:07:57 jra Exp $ (ARL)";
d78 5
a82 5
db_scan( dbip, handler, do_old_matter, client_data )
register struct db_i	*dbip;
int			(*handler)BU_ARGS((struct db_i *, const char *name, long addr, int nrec, int flags, genptr_t client_data));
int			do_old_matter;
genptr_t		client_data;	/* argument for handler */
d453 3
a455 3
db_conversions( dbip, local )
struct db_i	*dbip;
int local;					/* one of ID_??_UNIT */
@


11.26
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1994 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.24 2001/10/04 19:36:09 rbowers Exp $ (ARL)";
@


11.26.4.1
log
@sync to HEAD...
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/db_scan.c,v 11.27 2004/02/02 17:39:15 morrison Exp $ (ARL)";
@


11.26.10.1
log
@merge from HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.27 2004/02/02 17:39:15 morrison Exp $ (ARL)";
@


11.26.10.2
log
@merge from head
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.26.10.1 2004/02/12 18:37:38 erikg Exp $ (ARL)";
@


11.26.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.26 2002/08/20 17:07:57 jra Exp $ (ARL)";
d78 5
a82 5
db_scan(register struct db_i *dbip, int (*handler) (struct db_i *, const char *, long int, int, int, genptr_t), int do_old_matter, genptr_t client_data)
                    	      
   			                                                                                                           
   			              
        		            	/* argument for handler */
d453 3
a455 3
db_conversions(struct db_i *dbip, int local)
           	      
          					/* one of ID_??_UNIT */
@


11.26.2.2
log
@sync branch with HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.25
log
@Converted from K&R to ANSI C - RFH
@
text
@d78 5
a82 5
db_scan(register struct db_i *dbip, int (*handler) (struct db_i *, const char *, long int, int, int, genptr_t), int do_old_matter, genptr_t client_data)
                    	      
   			                                                                                                           
   			              
        		            	/* argument for handler */
d453 3
a455 3
db_conversions(struct db_i *dbip, int local)
           	      
          					/* one of ID_??_UNIT */
@


11.24
log
@-* modified to eliminate user-visible v4 references.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.23 2001/05/17 20:05:23 morrison Exp $ (ARL)";
d78 5
a82 5
db_scan( dbip, handler, do_old_matter, client_data )
register struct db_i	*dbip;
int			(*handler)BU_ARGS((struct db_i *, const char *name, long addr, int nrec, int flags, genptr_t client_data));
int			do_old_matter;
genptr_t		client_data;	/* argument for handler */
d453 3
a455 3
db_conversions( dbip, local )
struct db_i	*dbip;
int local;					/* one of ID_??_UNIT */
@


11.23
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.22 2001/04/20 22:29:42 morrison Exp $ (ARL)";
d395 1
a395 1
Due to a database restriction in the v4 format of .g files, your\n\
d398 1
a398 1
You may wish to consider upgrading your database to v5 format.\n",
@


11.22
log
@CONST to const
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.21 2000/09/08 05:54:41 mike Exp $ (ARL)";
d47 1
a47 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_scan x%x %c (0%o)\n", \
d94 1
a94 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_scan( x%x, x%x )\n", dbip, handler);
d365 1
a365 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_update_ident( x%x, '%s', %g )\n",
d433 1
a433 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_fwrite_ident( x%x, '%s', %g ) code=%d\n",
@


11.21
log
@
Modified tree routines to take resource pointer.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.20 2000/07/13 02:20:37 mike Exp $ (ARL)";
d80 1
a80 1
int			(*handler)BU_ARGS((struct db_i *, CONST char *name, long addr, int nrec, int flags, genptr_t client_data));
@


11.20
log
@
Sanity check.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.19 2000/07/13 01:13:02 mike Exp $ (ARL)";
d375 1
a375 1
	dir.d_namep = "/IDENT/";
@


11.19
log
@
Changed db_ident() to db_update_ident().
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.18 2000/07/12 01:13:11 mike Exp $ (ARL)";
d367 2
@


11.18
log
@
New calling sequence to rt_color_addrec()
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.17 2000/07/10 23:01:28 mike Exp $ (ARL)";
d348 1
a348 1
 *			D B _ I D E N T
d350 1
a350 1
 *  Update the IDENT record with new title and units.
a354 8
 *
 *  Note:  requires v4 database code for 'units' parameter.
 *  Should be changed to accept a local2mm scale factor, and
 *  cope with it from there.
 *
 * Returns -
 *	 0	Success
 *	-1	Fatal Error
d357 1
a357 4
db_ident( dbip, new_title, units )
struct db_i	*dbip;
char		*new_title;
int		units;
d362 1
d365 2
a366 2
	if(rt_g.debug&DEBUG_DB) bu_log("db_ident( x%x, '%s', %d )\n",
		dbip, new_title, units );
d371 2
d379 3
a381 1
	    rec.u_id != ID_IDENT )
d383 1
d390 11
a400 1
	rec.i.i_units = units;
d406 1
d416 3
d424 1
a424 4
db_fwrite_ident( fp, title, local2mm )
FILE		*fp;
CONST char	*title;
double		local2mm;
d529 1
a529 2
db_v4_get_units_code( str )
CONST char *str;
@


11.17
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.16 2000/03/04 05:53:45 mike Exp $ (ARL)";
d178 7
a184 1
				rt_color_addrec( &record, addr );
@


11.16
log
@
Added support for FASTGEN PLATE and VOLUME mode regions,
which are special cases of the orginary BRL-CAD region.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.15 2000/03/02 14:47:27 jra Exp $ (ARL)";
@


11.15
log
@Eliminated FGP solid and added cline solid
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.14 2000/01/07 04:21:06 mike Exp $ (ARL)";
d312 12
a323 3
			handler( dbip, record.c.c_name, addr, nrec,
				record.c.c_flags == 'R' ?
					DIR_COMB|DIR_REGION : DIR_COMB,
@


11.14
log
@
Eliminated dbi_localunit.  This is a v4 database anachronism.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.13 2000/01/07 02:26:47 mike Exp $ (ARL)";
d282 1
a282 1
		case DBID_FGP:
@


11.13
log
@
Added error checking, so multiple library routines can be cascaded.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.12 2000/01/06 22:36:34 mike Exp $ (ARL)";
d133 1
a133 2
				dbip->dbi_localunit = record.i.i_units;
				db_conversions( dbip, dbip->dbi_localunit );
d341 4
d380 1
a380 1
	dbip->dbi_localunit = rec.i.i_units = units;
d389 36
d427 1
a427 1
 *	Builds conversion factors given the local unit
a440 1
		dbip->dbi_localunit = ID_MM_UNIT;
a490 7
		/*
		 *	XXX	dbi_localunit is set to 10 here
		 *		as a sentinel for out of range!
		 *		A constant buried in the code as
		 *		a sentinel??  Yecch!!
		 */
		dbip->dbi_localunit = 10;
d511 1
a511 1
	if( !str )  return -1;	/* error */
@


11.12
log
@
Provided new routine db_v4_get_units_code()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.11 1999/12/29 23:23:09 mike Exp $ (ARL)";
d480 1
@


11.11
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.10 1999/11/08 15:08:05 jra Exp $ (ARL)";
d393 1
a393 1
int local;
d463 38
@


11.10
log
@
Added BOT solid.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.9 1999/10/12 13:58:12 jra Exp $ (ARL)";
d78 1
a78 1
db_scan( dbip, handler, do_old_matter )
d80 1
a80 1
int			(*handler)();
d82 1
d157 1
a157 1
				DIR_SOLID );
d164 1
a164 1
				DIR_SOLID );
d174 1
a174 1
				DIR_SOLID );
d197 1
a197 1
				DIR_SOLID );
d223 1
a223 1
				DIR_SOLID );
d241 1
a241 1
				DIR_SOLID );
d245 1
a245 1
				DIR_SOLID );
d254 1
a254 1
				DIR_SOLID );
d263 1
a263 1
				DIR_SOLID );
d272 1
a272 1
				DIR_SOLID );
d281 1
a281 1
				DIR_SOLID );
d285 1
a285 1
				DIR_SOLID );
d294 1
a294 1
				DIR_SOLID );
d315 2
a316 1
					DIR_COMB|DIR_REGION : DIR_COMB );
@


11.9
log
@Added fgp solid (FastGen Plate mode)
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_scan.c,v 11.8 1998/03/19 15:00:40 jra Exp $ (ARL)";
d283 9
@


11.8
log
@Added sketch and extrusion.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 11.7 1997/12/16 06:09:51 mike Exp jra $ (ARL)";
d280 4
@


11.7
log
@Ran h/sed4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 11.6 1997/06/03 16:03:59 pjt Exp mike $ (ARL)";
d262 18
@


11.6
log
@Added units um, km, yd, mi, and other minor improvements
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 11.5 1996/11/20 19:49:35 jra Exp bparker $ (ARL)";
d347 1
a347 1
		rt_free( old_title, "old dbi_title" );
@


11.5
log
@db_ident() needed to assign a magic number to conjured-up directory entry.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 11.4 1996/09/27 08:27:30 mike Exp jra $ (ARL)";
d334 1
d373 5
d393 5
d408 10
d420 7
a426 1
		dbip->dbi_localunit = 6;
@


11.4
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 11.3 1995/12/28 14:26:36 jra Exp mike $ (ARL)";
d333 1
@


11.3
log
@Added XXXX note about db_scan ignoring dbip->dbi_inmem.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 11.2 1995/07/28 19:15:53 jra Exp jra $ (ARL)";
d47 1
a47 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_scan x%x %c (0%o)\n", \
d93 1
a93 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_scan( x%x, x%x )\n", dbip, handler);
d100 1
a100 1
		rt_log("db_scan ERROR:  File is lacking a proper MGED database header\n");
d111 1
a111 1
			rt_log("db_scan:  fseek(offset=%d) failure\n", next);
d126 1
a126 1
				rt_log("db_scan WARNING: File is Version %s, Program is version %s\n",
d131 1
a131 1
				dbip->dbi_title = rt_strdup( record.i.i_title );
d159 1
a159 1
			rt_log("db_scan ERROR: Unattached ARS 'B' record\n");
d199 1
a199 1
			rt_log("db_scan ERROR: Unattached P_DATA record\n");
d225 1
a225 1
			rt_log("db_scan ERROR: Unattached B-spline surface record\n");
d234 1
a234 1
			j = rt_glong(record.n.n_grans);
d247 1
a247 1
			j = rt_glong(record.pwr.pwr_count);
d256 1
a256 1
			j = rt_glong(record.nmg.N_count);
d265 1
a265 1
			rt_log("db_scan ERROR: Unattached combination MEMBER record\n");
d286 1
a286 1
			rt_log("db_scan ERROR:  bad record %c (0%o), addr=x%x\n",
d324 1
a324 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_ident( x%x, '%s', %d )\n",
d341 1
a341 1
	dbip->dbi_title = rt_strdup( new_title );
@


11.2
log
@Modified for new definition of pipe solid.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 11.1 1995/01/04 09:56:18 mike Rel4_4 jra $ (ARL)";
d95 1
@


11.1
log
@Release_4.4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 10.4 94/12/27 16:56:59 mike Exp $ (ARL)";
d246 1
a246 1
			j = rt_glong(record.pw.pw_count);
d251 1
a251 1
			handler( dbip, record.pw.pw_name, addr, nrec,
@


10.4
log
@Fixed bug #247, added rt_ prefix to memalloc(), etc.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 10.3 94/11/05 04:41:23 mike Exp Locker: mike $ (ARL)";
@


10.3
log
@Cleanup
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d137 1
a137 1
			memfree( &(dbip->dbi_freep), (unsigned)1,
@


10.2
log
@Factored ifdefs
@
text
@d14 2
a15 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d17 5
d23 2
a24 2
 *	This software is Copyright (C) 1988 by the United States Army.
 *	All rights reserved.
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 10.1 1991/10/12 06:40:04 mike Rel4_0 gdurf $ (BRL)";
a297 21

#ifdef never
db_suckin()
{
	/*
	 * Obtain in-core copy of database, rather than doing lots of
	 * random-access reads.  Here, "addr" is really "nrecords".
	 */
	if( (rtip->rti_db = (union record *)rt_malloc(
	    addr*sizeof(union record), "in-core database"))
	    == (union record *)0 )
	    	rt_bomb("in-core database malloc failure");
	rewind(dbip->dbi_fp);
	if( fread( (char *)rtip->rti_db, sizeof(union record), addr,
	    dbip->dbi_fp) != addr )  {
	    	rt_log("rt_dirbuild:  problem reading db on 2nd pass\n");
	    	goto bad;
	}
}
#endif

@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 9.11 91/07/01 02:03:15 mike Exp $ (BRL)";
d26 2
d29 3
a31 1
#ifdef BSD
a32 2
#else
#include <string.h>
@


9.11
log
@Fixed bug that caused mged "units" command to scrogg the database title.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 9.10 91/06/14 06:26:34 mike Exp $ (BRL)";
@


9.10
log
@Modified for new string solid database record.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 9.9 91/02/27 19:48:52 mike Exp $ (BRL)";
d86 1
a87 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_scan:  bad dbip\n");
d320 3
d328 1
a328 1
db_ident( dbip, title, units )
d330 1
a330 1
char		*title;
d335 1
d337 3
a339 3
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_ident:  bad dbip\n");
	if(rt_g.debug&DEBUG_DB) rt_log("db_ident( x%x, %s, %d )\n",
		dbip, title, units );
d352 1
a352 1
	(void)strncpy(rec.i.i_title, title, sizeof(rec.i.i_title)-1 );
d354 2
a355 3
	if( dbip->dbi_title )
		rt_free( dbip->dbi_title, "dbi_title" );
	dbip->dbi_title = rt_strdup( title );
d358 3
d374 2
@


9.9
log
@Chagned database format to use completely machine-independent format
for NMG, PIPE, and ARBN.
In this case, only the granule count was still in machine-specific format.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 9.8 91/02/06 22:32:57 mike Exp $ (BRL)";
d159 6
@


9.8
log
@Added DBID_NMG
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 9.7 91/01/14 22:46:06 mike Exp $ (BRL)";
d221 2
a222 2
			j = record.n.n_grans;
			nrec += record.n.n_grans;
d234 2
a235 2
			j = record.pw.pw_count-1;
			nrec += record.pw.pw_count-1;
d243 1
a243 1
			j = record.nmg.N_count;
@


9.7
log
@STRSOL
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 9.6 91/01/12 06:52:59 mike Exp $ (BRL)";
d240 9
@


9.6
log
@db.h must come before raytrace.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 9.5 90/12/07 05:51:18 mike Exp $ (BRL)";
d158 1
a158 1
		case ID_STRSOL:
@


9.5
log
@Added extra arg, to enable/disable processing of
region-id based coloring records.
Modified so that handler performing I/O on file
will not disrupt the scanning process.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_scan.c,v 9.4 90/10/11 02:36:46 mike Exp $ (BRL)";
d35 1
a36 1
#include "db.h"
@


9.4
log
@Added particles and pipes
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: db_scan.c,v 9.3 89/12/08 06:14:36 mike Exp $ (BRL)";
d64 3
d72 1
a72 1
db_scan( dbip, handler )
d75 1
d81 1
d97 1
d99 1
a99 1
	here = addr = -1;
d103 2
a104 2
		if( (addr = ftell(dbip->dbi_fp)) == EOF )  {
			rt_log("db_scan:  ftell() failure\n");
d107 1
d112 1
d147 1
d163 4
a166 2
			/* This is common to RT and MGED */
			rt_color_addrec( &record, addr );
d181 1
d206 1
d225 1
d238 1
d258 1
@


9.3
log
@Added support for ARBN
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: db_scan.c,v 9.2 89/10/10 16:13:18 mike Locked $ (BRL)";
d213 12
@


9.2
log
@Added support for ID_STRSOL
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: db_scan.c,v 9.1 89/05/19 05:55:47 mike Rel3_5 $ (BRL)";
d203 1
d206 8
@


9.1
log
@Release_3.5
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: db_scan.c,v 1.2 89/05/08 21:42:57 phil Exp $ (BRL)";
d147 4
@


1.2
log
@added db_conversions() routines
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: db_scan.c,v 1.1 88/12/06 00:09:23 phil Locked $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d7 1
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/libdb/RCS/scan.c,v 1.7 88/10/27 09:29:24 mike Exp $ (BRL)";
d118 1
a118 3
				/* conversions() XXX */
				dbip->dbi_local2base = 1.0;
				dbip->dbi_base2local = 1.0;
d300 52
@
