head	11.33;
access;
symbols
	ansi-20040405-merged:11.29.2.2
	postmerge-20040405-ansi:11.31
	premerge-20040404-ansi:11.30
	postmerge-autoconf:11.30
	autoconf-freeze:11.29.10.2
	premerge-autoconf:11.30
	ansi-20040316-freeze:11.29.2.1
	postmerge-20040315-windows:11.30
	premerge-20040315-windows:11.30
	windows-20040315-freeze:11.29.4.1
	autoconf-20031203:11.29
	autoconf-20031202:11.29
	autoconf-branch:11.29.0.10
	phong-branch:11.29.0.8
	photonmap-branch:11.29.0.6
	rel-6-1-DP:11.29
	windows-branch:11.29.0.4
	rel-6-0-2:11.27
	ansi-branch:11.29.0.2
	rel-6-0-1-branch:11.27.0.2
	hartley-6-0-post:11.28
	hartley-6-0-pre:11.27
	rel-6-0-1:11.27
	rel-6-0:11.27
	rel-5-4:11.22
	offsite-5-3-pre:11.25
	rel-5-3:11.22
	rel-5-2:11.22
	rel-5-1-branch:11.22.0.2
	rel-5-1:11.22
	rel-5-0:11.20
	rel-5-0-beta:11.18
	rel-4-5:11.16
	ctj-4-5-post:11.15
	ctj-4-5-pre:11.15
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.33
date	2004.05.21.18.07.33;	author morrison;	state dead;
branches;
next	11.32;

11.32
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.31;

11.31
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2004.02.02.17.39.24;	author morrison;	state Exp;
branches;
next	11.29;

11.29
date	2002.08.20.17.08.05;	author jra;	state Exp;
branches
	11.29.2.1
	11.29.4.1
	11.29.10.1;
next	11.28;

11.28
date	2002.08.15.20.55.17;	author hartley;	state Exp;
branches;
next	11.27;

11.27
date	2001.04.05.19.35.35;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2001.03.31.01.57.12;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2000.10.24.00.02.25;	author butler;	state Exp;
branches;
next	11.24;

11.24
date	2000.08.21.02.02.33;	author butler;	state Exp;
branches;
next	11.23;

11.23
date	2000.07.10.23.01.45;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.04.01.03.30.40;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	99.11.24.21.44.30;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	99.06.03.01.57.01;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.06.03.01.39.15;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	99.05.27.21.59.04;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	98.09.14.15.59.17;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	96.07.12.12.17.41;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	95.12.02.03.11.31;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	95.12.01.02.47.38;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	95.11.30.15.12.49;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	95.11.29.23.53.13;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	95.11.28.20.47.53;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	95.07.03.18.39.21;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	95.07.03.18.34.42;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.06.28.19.29.16;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.02.14.22.24.21;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.02.14.06.04.03;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.02.14.04.32.42;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.02.11.00.04.51;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.08;	author mike;	state Rel4_4;
branches;
next	10.45;

10.45
date	95.01.04.07.59.44;	author mike;	state Exp;
branches;
next	10.44;

10.44
date	94.12.30.00.43.29;	author mike;	state Exp;
branches;
next	10.43;

10.43
date	94.12.29.16.31.31;	author jra;	state Exp;
branches;
next	10.42;

10.42
date	94.12.27.17.47.28;	author mike;	state Exp;
branches;
next	10.41;

10.41
date	94.12.27.10.35.51;	author stay;	state Exp;
branches;
next	10.40;

10.40
date	94.12.23.19.36.01;	author mike;	state Exp;
branches;
next	10.39;

10.39
date	94.11.17.17.03.33;	author jra;	state Exp;
branches;
next	10.38;

10.38
date	94.11.04.06.55.47;	author mike;	state Exp;
branches;
next	10.37;

10.37
date	94.10.24.21.17.37;	author mike;	state Exp;
branches;
next	10.36;

10.36
date	94.10.22.07.22.05;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	94.09.16.20.20.44;	author mike;	state Exp;
branches;
next	10.34;

10.34
date	94.09.16.05.01.43;	author mike;	state Exp;
branches;
next	10.33;

10.33
date	94.09.10.04.58.45;	author mike;	state Exp;
branches;
next	10.32;

10.32
date	94.09.02.00.32.39;	author mike;	state Exp;
branches;
next	10.31;

10.31
date	94.08.09.19.38.23;	author mike;	state Exp;
branches;
next	10.30;

10.30
date	94.04.25.02.25.51;	author butler;	state Exp;
branches;
next	10.29;

10.29
date	94.04.24.18.27.42;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	94.04.22.02.47.27;	author butler;	state Exp;
branches;
next	10.27;

10.27
date	94.04.14.03.16.53;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	94.03.18.01.53.18;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	94.03.17.23.20.13;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	94.03.17.22.58.40;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	94.03.10.06.46.25;	author butler;	state Exp;
branches;
next	10.22;

10.22
date	94.02.24.06.42.19;	author butler;	state Exp;
branches;
next	10.21;

10.21
date	94.02.23.03.23.23;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	94.02.23.02.33.11;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	94.02.03.22.51.35;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	94.01.29.00.21.34;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	94.01.14.03.19.47;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	94.01.14.03.11.14;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	93.12.03.03.35.45;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	93.09.10.23.20.52;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	93.07.20.21.04.38;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	93.05.15.01.05.38;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	93.05.15.00.22.48;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	93.04.02.02.57.47;	author butler;	state Exp;
branches;
next	10.9;

10.9
date	93.04.02.01.31.16;	author butler;	state Exp;
branches;
next	10.8;

10.8
date	93.03.24.03.21.34;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.10.06.23.12.00;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.07.23.05.06.01;	author butler;	state Exp;
branches;
next	10.5;

10.5
date	92.07.22.22.17.36;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.07.20.23.07.57;	author butler;	state Exp;
branches;
next	10.3;

10.3
date	92.06.25.20.08.31;	author butler;	state Exp;
branches;
next	10.2;

10.2
date	92.06.19.22.39.49;	author butler;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.50;	author mike;	state Rel4_0;
branches;
next	1.24;

1.24
date	91.06.17.20.42.19;	author butler;	state Exp;
branches;
next	1.23;

1.23
date	91.06.12.20.58.19;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	91.05.25.03.31.17;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	91.03.02.00.17.59;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	91.03.01.22.43.23;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	91.03.01.22.27.22;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	91.02.07.20.32.43;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	91.01.28.23.53.01;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	91.01.12.08.39.48;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	90.12.05.06.12.39;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	90.05.31.00.06.59;	author butler;	state Exp;
branches;
next	1.13;

1.13
date	90.05.25.18.50.31;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	90.05.25.07.15.09;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	90.05.25.02.46.34;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	90.05.25.01.08.45;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	90.05.24.20.26.29;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	90.05.24.19.02.53;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	90.05.24.03.57.51;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	90.05.24.03.04.08;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	90.05.24.02.18.49;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	90.05.23.22.05.58;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	90.05.23.21.47.43;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.05.23.21.18.14;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.05.23.19.43.05;	author mike;	state Exp;
branches;
next	;

11.29.2.1
date	2002.09.19.18.01.41;	author morrison;	state Exp;
branches;
next	11.29.2.2;

11.29.2.2
date	2004.03.17.21.18.54;	author morrison;	state Exp;
branches;
next	;

11.29.4.1
date	2004.03.11.23.43.43;	author morrison;	state Exp;
branches;
next	;

11.29.10.1
date	2004.02.12.18.37.45;	author erikg;	state Exp;
branches;
next	11.29.10.2;

11.29.10.2
date	2004.03.15.14.07.27;	author erikg;	state Exp;
branches;
next	;


desc
@Routines to display (plot) NMG objects and structures
@


11.33
log
@moved to src/
@
text
@/*
 *			N M G _ P L O T . C
 *
 *  This file contains routines that create VLISTs and UNIX-plot files.
 *  Some routines are essential to the MGED interface, some are
 *  more for diagnostic and visualization purposes.
 *
 *  There are several distinct families -
 *	nmg_ENTITY_to_vlist	Wireframes & polgyons.  For MGED "ev".
 *	nmg_pl_ENTITY		Fancy edgeuse drawing, to plot file.
 *	nmg_vlblock_ENTITY	Fancy edgeuse drawing, into vlblocks.
 *	show_broken_ENTITY	Graphical display of classifier results.
 *	...as well as assorted wrappers for debugging use.
 *
 *  In the interest of having only a single way of creating the fancy
 *  drawings, the code is migrating to creating everything first as
 *  VLBLOCKS, and converting that to UNIX-plot files or other formats
 *  as appropriate.
 *
 *  Authors -
 *	Lee A. Butler
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_plot.c,v 11.32 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <signal.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "plot3.h"

#define US_DELAY	10	/* Additional delay between frames */

void		(*nmg_plot_anim_upcall)();	/* For I/F with MGED */
void		(*nmg_vlblock_anim_upcall)();	/* For I/F with MGED */
void		(*nmg_mged_debug_display_hack)();
double nmg_eue_dist = 0.05;

/************************************************************************
 *									*
 *		NMG to VLIST routines, for MGED "ev" command.		*
 * XXX should take a flags array, to ensure each item done only once!   *
 *									*
 ************************************************************************/

/*
 *			N M G _ V U _ T O _ V L I S T
 *
 *  Plot a single vertexuse
 */
void
nmg_vu_to_vlist(struct bu_list *vhead, const struct vertexuse *vu)
{
	struct vertex	*v;
	register struct vertex_g *vg;

	NMG_CK_VERTEXUSE(vu);
	v = vu->v_p;
	NMG_CK_VERTEX(v);
	vg = v->vg_p;
	if( vg )  {
		/* Only thing in this shell is a point */
		NMG_CK_VERTEX_G(vg);
		RT_ADD_VLIST( vhead, vg->coord, BN_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vhead, vg->coord, BN_VLIST_LINE_DRAW );
	}
}

/*
 *			N M G _ E U _ T O _ V L I S T
 *
 *  Plot a list of edgeuses.  The last edge is joined back to the first.
 */
void
nmg_eu_to_vlist(struct bu_list *vhead, const struct bu_list *eu_hd)
{
	struct edgeuse		*eu;
	struct edgeuse		*eumate;
	struct vertexuse	*vu;
	struct vertexuse	*vumate;
	register struct vertex_g *vg;
	register struct vertex_g *vgmate;

	/* Consider all the edges in the wire edge list */
	for( BU_LIST_FOR( eu, edgeuse, eu_hd ) )  {
		/* This wire edge runs from vertex to mate's vertex */
		NMG_CK_EDGEUSE(eu);
		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		NMG_CK_VERTEX(vu->v_p);
		vg = vu->v_p->vg_p;

		eumate = eu->eumate_p;
		NMG_CK_EDGEUSE(eumate);
		vumate = eumate->vu_p;
		NMG_CK_VERTEXUSE(vumate);
		NMG_CK_VERTEX(vumate->v_p);
		vgmate = vumate->v_p->vg_p;

		if( !vg || !vgmate ) {
			bu_log("nmg_eu_to_vlist() no vg or mate?\n");
			continue;
		}
		NMG_CK_VERTEX_G(vg);
		NMG_CK_VERTEX_G(vgmate);

		RT_ADD_VLIST( vhead, vg->coord, BN_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vhead, vgmate->coord, BN_VLIST_LINE_DRAW );
	}
}

/*
 *			N M G _ L U _ T O _ V L I S T
 *
 *  Plot a single loopuse into a bn_vlist chain headed by vhead.
 *
 *  Needs to be able to handle both linear edges and cnurb edges.
 */
void
nmg_lu_to_vlist(struct bu_list *vhead, const struct loopuse *lu, int poly_markers, const vectp_t normal)
              		       
                    	    
   			             		/* bit vector! */
             		       
{
	const struct edgeuse		*eu;
	const struct vertexuse		*vu;
	const struct vertex		*v;
	register const struct vertex_g	*vg;
	const struct vertex_g		*first_vg;
	const struct vertexuse		*first_vu;
	int		isfirst;
	point_t		centroid;
	int		npoints;

	BU_CK_LIST_HEAD(vhead);

	NMG_CK_LOOPUSE(lu);
	if( BU_LIST_FIRST_MAGIC(&lu->down_hd)==NMG_VERTEXUSE_MAGIC )  {
		/* Process a loop of a single vertex */
		vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
		nmg_vu_to_vlist( vhead, vu );
		return;
	}

	/* Consider all the edges in the loop */
	isfirst = 1;
	first_vg = (struct vertex_g *)0;
	first_vu = (struct vertexuse *)0;
	npoints = 0;
	VSETALL( centroid, 0 );
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {

		/* Consider this edge */
		NMG_CK_EDGEUSE(eu);
		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		v = vu->v_p;
		NMG_CK_VERTEX(v);
		vg = v->vg_p;
		if( !vg ) {
			continue;
		}
		NMG_CK_VERTEX_G(vg);
		VADD2( centroid, centroid, vg->coord );
		npoints++;
		if (isfirst) {
			if( poly_markers & NMG_VLIST_STYLE_POLYGON ) {
				/* Insert a "start polygon, normal" marker */
				RT_ADD_VLIST( vhead, normal, BN_VLIST_POLY_START );
				if( poly_markers & NMG_VLIST_STYLE_USE_VU_NORMALS
				    && vu->a.magic_p ) {
					RT_ADD_VLIST( vhead,
						vu->a.plane_p->N,
						BN_VLIST_POLY_VERTNORM );
				}
				RT_ADD_VLIST( vhead, vg->coord, BN_VLIST_POLY_MOVE );
			} else {
				/* move */
				RT_ADD_VLIST( vhead, vg->coord, BN_VLIST_LINE_MOVE );
			}
			isfirst = 0;
			first_vg = vg;
			first_vu = vu;
		} else {
			if( poly_markers & NMG_VLIST_STYLE_POLYGON ) {
				if( poly_markers & NMG_VLIST_STYLE_USE_VU_NORMALS
				    && vu->a.magic_p ) {
					RT_ADD_VLIST( vhead,
						vu->a.plane_p->N,
						BN_VLIST_POLY_VERTNORM );
				}
				RT_ADD_VLIST( vhead, vg->coord, BN_VLIST_POLY_DRAW );
			} else {
				/* Draw */
				RT_ADD_VLIST( vhead, vg->coord, BN_VLIST_LINE_DRAW );
			}
		}

		if( !eu->g.magic_p )
			continue;

		/* If cnurb edgeuse, draw points interior to the curve here */
		if( *eu->g.magic_p != NMG_EDGE_G_CNURB_MAGIC )  continue;

		/* XXX only use poly markers when face is planar, not snurb */
		nmg_cnurb_to_vlist( vhead, eu, 10,
			(poly_markers & NMG_VLIST_STYLE_POLYGON ) ?
				BN_VLIST_POLY_DRAW : BN_VLIST_LINE_DRAW );
	}

	/* Draw back to the first vertex used */
	if( !isfirst && first_vg )  {
		if( poly_markers & NMG_VLIST_STYLE_POLYGON  )  {
			/* Draw, end polygon */
			if( poly_markers & NMG_VLIST_STYLE_USE_VU_NORMALS
			    && first_vu->a.magic_p ) {
				RT_ADD_VLIST( vhead,
					first_vu->a.plane_p->N,
					BN_VLIST_POLY_VERTNORM );
			}
			RT_ADD_VLIST( vhead, first_vg->coord, BN_VLIST_POLY_END );
		} else {
			/* Draw */
			RT_ADD_VLIST( vhead, first_vg->coord, BN_VLIST_LINE_DRAW );
		}
	}
	if( (poly_markers  & NMG_VLIST_STYLE_VISUALIZE_NORMALS) && npoints > 2 )  {
		/* Draw surface normal as a little vector */
		double	f;
		vect_t	tocent;
		point_t	tip;
		struct faceuse *fu;
		struct face *fp;

		if( *lu->up.magic_p == NMG_FACEUSE_MAGIC )
		{
			fu = lu->up.fu_p;
			NMG_CK_FACEUSE( fu );

			fp = fu->f_p;
		}
		else
			fp = (struct face *)NULL;

		f = 1.0 / npoints;
		VSCALE( centroid, centroid, f );
		VSUB2( tocent, first_vg->coord, centroid );
		f = MAGNITUDE( tocent ) * 0.5;
		if( *fp->g.magic_p != NMG_FACE_G_SNURB_MAGIC )
		{
			/* snurb normals are plotted in nmg_snurb_fu_to_vlist() */
			RT_ADD_VLIST( vhead, centroid, BN_VLIST_LINE_MOVE );
			VJOIN1( tip, centroid, f, normal );
			RT_ADD_VLIST( vhead, tip, BN_VLIST_LINE_DRAW );
		}

		/* For any vertexuse attributes with normals, draw them too */
		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			struct vertexuse_a_plane	*vua;
			/* Consider this edge */
			vu = eu->vu_p;
			if( !vu->a.magic_p || *vu->a.magic_p != NMG_VERTEXUSE_A_PLANE_MAGIC )  continue;
			vua = vu->a.plane_p;
			v = vu->v_p;
			vg = v->vg_p;
			if( !vg )  continue;
			NMG_CK_VERTEX_G(vg);
			RT_ADD_VLIST( vhead, vg->coord, BN_VLIST_LINE_MOVE );
			VJOIN1( tip, vg->coord, f, vua->N );
			RT_ADD_VLIST( vhead, tip, BN_VLIST_LINE_DRAW );
		}
	}
}

/*
 *			N M G _ S N U R B _ F U _ T O _ V L I S T
 */
void
nmg_snurb_fu_to_vlist(struct bu_list *vhead, const struct faceuse *fu, int poly_markers)
{
	struct face_g_snurb	*fg;

	BU_CK_LIST_HEAD(vhead);

	NMG_CK_FACEUSE(fu);
	NMG_CK_FACE(fu->f_p);
	fg = fu->f_p->g.snurb_p;
	NMG_CK_FACE_G_SNURB(fg);

	/* XXX For now, draw the whole surface, not just the interior */
	nmg_snurb_to_vlist( vhead, fg, 10 );

	if( poly_markers & NMG_VLIST_STYLE_VISUALIZE_NORMALS )
	{
		fastf_t f;
		point_t uv_centroid;
		point_t mid_srf;
		point_t corner;
		vect_t fu_norm;
		vect_t tocent;
		point_t tip;

		uv_centroid[0] = (fg->u.knots[fg->u.k_size-1] + fg->u.knots[0])/2.0;
		uv_centroid[1] = (fg->v.knots[fg->v.k_size-1] + fg->v.knots[0])/2.0;
		uv_centroid[2] = 1.0;

		nmg_snurb_fu_get_norm( fu, uv_centroid[0], uv_centroid[1], fu_norm );
		nmg_snurb_fu_eval( fu, uv_centroid[0], uv_centroid[1], mid_srf );

		nmg_snurb_fu_eval( fu, fg->u.knots[0], fg->v.knots[0], corner );
		VSUB2( tocent, corner, mid_srf );
		f = MAGNITUDE( tocent ) * 0.5;

		RT_ADD_VLIST( vhead, mid_srf, BN_VLIST_LINE_MOVE );
		VJOIN1( tip, mid_srf, f, fu_norm );
		RT_ADD_VLIST( vhead, tip, BN_VLIST_LINE_DRAW );
	}
}

/*
 *			N M G _ S _ T O _ V L I S T
 *
 *  Plot the entire contents of a shell.
 *
 *  poly_markers =
 *	0 for vectors
 *	1 for polygons
 *	2 for polygons and surface normals drawn with vectors
 */
void
nmg_s_to_vlist(struct bu_list *vhead, const struct shell *s, int poly_markers)
{
	struct faceuse	*fu;
	struct face_g_plane	*fg;
	register struct loopuse	*lu;
	vect_t		normal;

	NMG_CK_SHELL(s);

	/* faces */
	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		vect_t		n;

		/* Consider this face */
		NMG_CK_FACEUSE(fu);
		if (fu->orientation != OT_SAME)  continue;
		NMG_CK_FACE(fu->f_p);

		if( fu->f_p->g.magic_p && *fu->f_p->g.magic_p == NMG_FACE_G_SNURB_MAGIC )  {

			if( !(poly_markers & NMG_VLIST_STYLE_NO_SURFACES) )
				nmg_snurb_fu_to_vlist( vhead, fu, poly_markers );

			VSET( n, 1, 0, 0 );	/* sanity */
			for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
			   	nmg_lu_to_vlist( vhead, lu, poly_markers, n );
			}
			continue;
		}

		/* Handle planar faces directly */
		fg = fu->f_p->g.plane_p;
		NMG_CK_FACE_G_PLANE(fg);
		NMG_GET_FU_NORMAL( n, fu );
		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		   	nmg_lu_to_vlist( vhead, lu, poly_markers, n );
		}
	}

	/* wire loops.  poly_markers=0 so wires are always drawn as vectors */
	VSETALL(normal, 0);
	for( BU_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
		nmg_lu_to_vlist( vhead, lu, 0, normal );
	}

	/* wire edges */
	nmg_eu_to_vlist( vhead, &s->eu_hd );

	/* single vertices */
	if (s->vu_p)  {
		nmg_vu_to_vlist( vhead, s->vu_p );
	}
}

/*
 *			N M G _ R _ T O _ V L I S T
 */
void
nmg_r_to_vlist(struct bu_list *vhead, const struct nmgregion *r, int poly_markers)
{
	register struct shell	*s;

	NMG_CK_REGION( r );
	for( BU_LIST_FOR( s, shell, &r->s_hd ) )  {
		nmg_s_to_vlist( vhead, s, poly_markers );
	}
}

/*
 *			N M G _ M _ T O _ V L I S T
 *
 */
void
nmg_m_to_vlist(struct bu_list *vhead, struct model *m, int poly_markers)
{
	register struct nmgregion	*r;

	NMG_CK_MODEL( m );
	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
		NMG_CK_REGION( r );
		nmg_r_to_vlist( vhead, r, poly_markers );
	}
}
/************************************************************************
 *									*
 *		Routines to lay out the fancy edgeuse drawings		*
 *									*
 ************************************************************************/

#define LEE_DIVIDE_TOL	(1.0e-5)	/* sloppy tolerance */


/*
 *			N M G _ O F F S E T _ E U _ V E R T
 *
 *	Given an edgeuse, find an offset for its vertexuse which will place
 *	it "above" and "inside" the area of the face.
 *
 *  The point will be offset inwards along the edge
 *  slightly, to avoid obscuring the vertex, and will be offset off the
 *  face (in the direction of the face normal) slightly, to avoid
 *  obscuring the edge itself.
 *	
 */
void
nmg_offset_eu_vert(fastf_t *base, const struct edgeuse *eu, const fastf_t *face_normal, int tip)
{
	struct edgeuse	*prev_eu;
	const struct edgeuse	*this_eu;
	vect_t		prev_vec;	/* from cur_pt to prev_pt */
	vect_t		eu_vec;		/* from cur_pt to next_pt */
	vect_t		prev_left;
	vect_t		eu_left;
	vect_t		delta_vec;	/* offset vector from vertex */
	struct vertex_g	*this_vg, *mate_vg, *prev_vg;

	bzero( (char *)delta_vec, sizeof(vect_t)),
	prev_eu = BU_LIST_PPREV_CIRC( edgeuse, eu ); 
	this_eu = eu;

	NMG_CK_EDGEUSE(this_eu);
	NMG_CK_VERTEXUSE(this_eu->vu_p);
	NMG_CK_VERTEX(this_eu->vu_p->v_p);
    	this_vg = this_eu->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G(this_vg);

	NMG_CK_EDGEUSE(this_eu->eumate_p);
	NMG_CK_VERTEXUSE(this_eu->eumate_p->vu_p);
	NMG_CK_VERTEX(this_eu->eumate_p->vu_p->v_p);
    	mate_vg = this_eu->eumate_p->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G(mate_vg);

	NMG_CK_EDGEUSE(prev_eu);
	NMG_CK_VERTEXUSE(prev_eu->vu_p);
	NMG_CK_VERTEX(prev_eu->vu_p->v_p);
    	prev_vg = prev_eu->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G(prev_vg);

	/* get "left" vector for edgeuse */
	VSUB2(eu_vec, mate_vg->coord, this_vg->coord); 
	VUNITIZE(eu_vec);
	VCROSS(eu_left, face_normal, eu_vec);


	/* get "left" vector for previous edgeuse */
	VSUB2(prev_vec, this_vg->coord, prev_vg->coord);
	VUNITIZE(prev_vec);
	VCROSS(prev_left, face_normal, prev_vec);

	/* get "delta" vector to apply to vertex */
	VADD2(delta_vec, prev_left, eu_left);

	if (MAGSQ(delta_vec) > VDIVIDE_TOL) {
		VUNITIZE(delta_vec);
		VJOIN2(base, this_vg->coord,
			(nmg_eue_dist*1.3),delta_vec,
			(nmg_eue_dist*0.8),face_normal);
		
	} else if (tip) {
		VJOIN2(base, this_vg->coord,
			(nmg_eue_dist*1.3),prev_left,
			(nmg_eue_dist*0.8),face_normal);
	} else {
		VJOIN2(base, this_vg->coord,
			(nmg_eue_dist*1.3),eu_left,
			(nmg_eue_dist*0.8),face_normal);
	}
}



/*			N M G _ E U _ C O O R D S
 *
 *  Get the two (offset and shrunken) endpoints that represent
 *  an edgeuse.
 *  Return the base point, and a point 60% along the way towards the
 *  other end.
 */
static void nmg_eu_coords(const struct edgeuse *eu, fastf_t *base, fastf_t *tip60)
{
	point_t	tip;

	NMG_CK_EDGEUSE(eu);

	if (*eu->up.magic_p == NMG_SHELL_MAGIC ||
	    (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
	    *eu->up.lu_p->up.magic_p == NMG_SHELL_MAGIC) ) {
	    	/* Wire edge, or edge in wire loop */
	    	VMOVE( base, eu->vu_p->v_p->vg_p->coord );
		NMG_CK_EDGEUSE(eu->eumate_p);
		VMOVE( tip, eu->eumate_p->vu_p->v_p->vg_p->coord );
	}
	else if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
	    *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC) {
	    	/* Loop in face */
	    	struct faceuse	*fu;
	    	vect_t		face_normal;

	    	fu = eu->up.lu_p->up.fu_p;
	    	NMG_GET_FU_NORMAL( face_normal, fu );


	    	nmg_offset_eu_vert(base, eu, face_normal, 0);
		nmg_offset_eu_vert(tip, BU_LIST_PNEXT_CIRC(edgeuse, eu),
			face_normal, 1);

	} else
		rt_bomb("nmg_eu_coords: bad edgeuse up. What's going on?\n");

	VBLEND2( tip60, 0.4, base, 0.6, tip );
}

/*
 *			N M G _ E U _ R A D I A L
 *
 *  Find location for 80% tip on edgeuse's radial edgeuse.
 */
static void nmg_eu_radial(const struct edgeuse *eu, fastf_t *tip)
{
	point_t	b2, t2;

	NMG_CK_EDGEUSE(eu->radial_p);
	NMG_CK_VERTEXUSE(eu->radial_p->vu_p);
	NMG_CK_VERTEX(eu->radial_p->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->radial_p->vu_p->v_p->vg_p);

	nmg_eu_coords(eu->radial_p, b2, t2);

	/* find point 80% along other eu where radial pointer should touch */
	VCOMB2( tip, 0.8, t2, 0.2, b2 );
}

#if 0
/*
 *			N M G _ E U _ L A S T
 *
 *  Find the tip of the last (previous) edgeuse from 'eu'.
 */
static void nmg_eu_last( eu, tip_out )
const struct edgeuse	*eu;
point_t		tip_out;
{
	point_t		radial_base;
	point_t		radial_tip;
	point_t		last_base;
	point_t		last_tip;
	point_t		p;
	struct edgeuse	*eulast;

	NMG_CK_EDGEUSE(eu);
	eulast = BU_LIST_PPREV_CIRC( edgeuse, eu );
	NMG_CK_EDGEUSE(eulast);
	NMG_CK_VERTEXUSE(eulast->vu_p);
	NMG_CK_VERTEX(eulast->vu_p->v_p);
	NMG_CK_VERTEX_G(eulast->vu_p->v_p->vg_p);

	nmg_eu_coords(eulast->radial_p, radial_base, radial_tip);

	/* find pt 80% along LAST eu's radial eu where radial ptr touches */
	VCOMB2( p, 0.8, radial_tip, 0.2, radial_base );

	/* get coordinates of last edgeuse */
	nmg_eu_coords(eulast, last_base, last_tip);

	/* Find pt 80% along other eu where last pointer should touch */
	VCOMB2( tip_out, 0.8, last_tip, 0.2, p );
}
#endif

/*
 *			N M G _ E U _ N E X T
 *
 *  Return the base of the next edgeuse
 */
static void nmg_eu_next_base(const struct edgeuse *eu, fastf_t *next_base)
{
	point_t	t2;
	register struct edgeuse	*nexteu;

	NMG_CK_EDGEUSE(eu);
	nexteu = BU_LIST_PNEXT_CIRC( edgeuse, eu );
	NMG_CK_EDGEUSE(nexteu);
	NMG_CK_VERTEXUSE(nexteu->vu_p);
	NMG_CK_VERTEX(nexteu->vu_p->v_p);
	NMG_CK_VERTEX_G(nexteu->vu_p->v_p->vg_p);

	nmg_eu_coords(nexteu, next_base, t2);
}

/************************************************************************
 *									*
 *		NMG to UNIX-Plot routines, for visualization		*
 *  XXX These should get replaced with calls to the vlblock routines	*
 *									*
 ************************************************************************/

/*
 *			N M G _ P L _ V
 */
void
nmg_pl_v(FILE *fp, const struct vertex *v, long int *b)
{
	pointp_t p;
	static char label[128];

	NMG_INDEX_RETURN_IF_SET_ELSE_SET(b, v->index);

	NMG_CK_VERTEX(v);
	NMG_CK_VERTEX_G(v->vg_p);
	p = v->vg_p->coord;

	pl_color(fp, 255, 255, 255);
	if (rt_g.NMG_debug & DEBUG_LABEL_PTS) {
		(void)sprintf(label, "%g %g %g", p[0], p[1], p[2]);
		pdv_3move( fp, p );
		pl_label(fp, label);
	}
	pdv_3point(fp, p);
}

/*
 *			N M G _ P L _ E
 */
void
nmg_pl_e(FILE *fp, const struct edge *e, long int *b, int red, int green, int blue)
{
	pointp_t	p0, p1;
	point_t		end0, end1;
	vect_t		v;

	NMG_INDEX_RETURN_IF_SET_ELSE_SET(b, e->index);
	
	NMG_CK_EDGEUSE(e->eu_p);
	NMG_CK_VERTEXUSE(e->eu_p->vu_p);
	NMG_CK_VERTEX(e->eu_p->vu_p->v_p);
	NMG_CK_VERTEX_G(e->eu_p->vu_p->v_p->vg_p);
	p0 = e->eu_p->vu_p->v_p->vg_p->coord;

	NMG_CK_VERTEXUSE(e->eu_p->eumate_p->vu_p);
	NMG_CK_VERTEX(e->eu_p->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(e->eu_p->eumate_p->vu_p->v_p->vg_p);
	p1 = e->eu_p->eumate_p->vu_p->v_p->vg_p->coord;

	/* leave a little room between the edge endpoints and the vertex
	 * compute endpoints by forming a vector between verets, scale vector
	 * and modify points
	 */
	VSUB2SCALE(v, p1, p0, 0.95);
	VADD2(end0, p0, v);
	VSUB2(end1, p1, v);

	pl_color(fp, red, green, blue);
	pdv_3line( fp, end0, end1 );

	nmg_pl_v(fp, e->eu_p->vu_p->v_p, b);
	nmg_pl_v(fp, e->eu_p->eumate_p->vu_p->v_p, b);
}

/*
 *			M N G _ P L _ E U
 */
void
nmg_pl_eu(FILE *fp, const struct edgeuse *eu, long int *b, int red, int green, int blue)
{
	point_t base, tip;
	point_t	radial_tip;
	point_t	next_base;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGE(eu->e_p);
	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);

	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);

	NMG_INDEX_RETURN_IF_SET_ELSE_SET(b, eu->index);

	nmg_pl_e(fp, eu->e_p, b, red, green, blue);

	if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
	    *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC) {

	    	nmg_eu_coords(eu, base, tip);
	    	if (eu->up.lu_p->up.fu_p->orientation == OT_SAME)
	    		red += 50;
		else if (eu->up.lu_p->up.fu_p->orientation == OT_OPPOSITE)
			red -= 50;
	    	else
	    		red = green = blue = 255;

		pl_color(fp, red, green, blue);
	    	pdv_3line( fp, base, tip );

	    	nmg_eu_radial( eu, radial_tip );
		pl_color(fp, red, green-20, blue);
	    	pdv_3line( fp, tip, radial_tip );

		pl_color(fp, 0, 100, 0);
	    	nmg_eu_next_base( eu, next_base );
	    	pdv_3line( fp, tip, next_base );

/*** presently unused ***
	    	nmg_eu_last( eu, last_tip );
		pl_color(fp, 0, 200, 0);
	    	pdv_3line( fp, base, last_tip );
****/
	    }
}

/*
 *			N M G _ P L _ L U
 */
void
nmg_pl_lu(FILE *fp, const struct loopuse *lu, long int *b, int red, int green, int blue)
{
	struct bn_vlblock	*vbp;

	vbp = rt_vlblock_init();
	nmg_vlblock_lu(vbp, lu, b, red, green, blue, 0, 0);
	rt_plot_vlblock(fp, vbp);
	rt_vlblock_free(vbp);
}

/*
 *			M N G _ P L _ F U
 */
void
nmg_pl_fu(FILE *fp, const struct faceuse *fu, long int *b, int red, int green, int blue)
{
	struct loopuse		*lu;
	struct bn_vlblock	*vbp;
	int 		loopnum = 0;

	NMG_CK_FACEUSE(fu);
	NMG_INDEX_RETURN_IF_SET_ELSE_SET(b, fu->index);

	vbp = rt_vlblock_init();

	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		nmg_vlblock_lu(vbp, lu, b, red, green, blue, 1, loopnum++);
	}

	rt_plot_vlblock(fp, vbp);
	rt_vlblock_free(vbp);
}

/*
 *			N M G _ P L _ S
 *
 *  Note that "b" should probably be defined a level higher,
 *  to reduce malloc/free calls when plotting multiple shells.
 */
void
nmg_pl_s(FILE *fp, const struct shell *s)
{
	struct bn_vlblock	*vbp;

	vbp = rt_vlblock_init();
	nmg_vlblock_s(vbp, s, 0);
	rt_plot_vlblock(fp, vbp);
	rt_vlblock_free(vbp);
}

void
nmg_pl_shell(FILE *fp, const struct shell *s, int fancy)
{
	struct bn_vlblock	*vbp;

	vbp = rt_vlblock_init();
	nmg_vlblock_s(vbp, s, fancy);
	rt_plot_vlblock(fp, vbp);
	rt_vlblock_free(vbp);
}

/*
 *			N M G _ P L _ R
 */
void
nmg_pl_r(FILE *fp, const struct nmgregion *r)
{
	struct bn_vlblock	*vbp;

	vbp = rt_vlblock_init();
	nmg_vlblock_r(vbp, r, 0);
	rt_plot_vlblock(fp, vbp);
	rt_vlblock_free(vbp);
}

/*
 *			N M G _ P L _ M
 */
void
nmg_pl_m(FILE *fp, const struct model *m)
{
	struct bn_vlblock	*vbp;

	vbp = rt_vlblock_init();
	nmg_vlblock_m(vbp, m, 0);
	rt_plot_vlblock(fp, vbp);
	rt_vlblock_free(vbp);
}

/************************************************************************
 *									*
 *		Visualization of fancy edgeuses into VLBLOCKs		*
 *									*
 *  This is the preferred method of obtaining fancy NMG displays.	*
 *									*
 ************************************************************************/

/*
 *			N M G _ V L B L O C K _ V
 */
void
nmg_vlblock_v(struct bn_vlblock *vbp, const struct vertex *v, long int *tab)
{
	pointp_t p;
	struct bu_list	*vh;

	BN_CK_VLBLOCK(vbp);
	NMG_CK_VERTEX(v);
	NMG_INDEX_RETURN_IF_SET_ELSE_SET( tab, v->index );

	NMG_CK_VERTEX_G(v->vg_p);
	p = v->vg_p->coord;

	vh = rt_vlblock_find( vbp, 255, 255, 255 );
#if 0
	if (rt_g.NMG_debug & DEBUG_LABEL_PTS) {
		static char label[128];
		mat_t	mat;
		MAT_IDN(mat);
		(void)sprintf(label, "%g %g %g", p[0], p[1], p[2]);
		/* XXX What size characters to use? */
		bn_vlist_3string( vh, vbp->free_vlist_hd, label, p, mat, scale );
	}
#endif
	RT_ADD_VLIST( vh, p, BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vh, p, BN_VLIST_LINE_DRAW );
}

/*
 *			N M G _ V L B L O C K _ E
 */
void
nmg_vlblock_e(struct bn_vlblock *vbp, const struct edge *e, long int *tab, int red, int green, int blue, int fancy)
{
	pointp_t p0, p1;
	point_t end0, end1;
	vect_t v;
	struct bu_list	*vh;

	BN_CK_VLBLOCK(vbp);
	NMG_CK_EDGE(e);
	NMG_INDEX_RETURN_IF_SET_ELSE_SET( tab, e->index );
	
	NMG_CK_EDGEUSE(e->eu_p);
	NMG_CK_VERTEXUSE(e->eu_p->vu_p);
	NMG_CK_VERTEX(e->eu_p->vu_p->v_p);
	NMG_CK_VERTEX_G(e->eu_p->vu_p->v_p->vg_p);
	p0 = e->eu_p->vu_p->v_p->vg_p->coord;

	NMG_CK_VERTEXUSE(e->eu_p->eumate_p->vu_p);
	NMG_CK_VERTEX(e->eu_p->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(e->eu_p->eumate_p->vu_p->v_p->vg_p);
	p1 = e->eu_p->eumate_p->vu_p->v_p->vg_p->coord;

	/* leave a little room between the edge endpoints and the vertex
	 * compute endpoints by forming a vector between verets, scale vector
	 * and modify points
	 */
	VSUB2SCALE(v, p1, p0, 0.90);
	VADD2(end0, p0, v);
	VSUB2(end1, p1, v);

	vh = rt_vlblock_find( vbp, red, green, blue );
	RT_ADD_VLIST( vh, end0, BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vh, end1, BN_VLIST_LINE_DRAW );

	nmg_vlblock_v(vbp, e->eu_p->vu_p->v_p, tab);
	nmg_vlblock_v(vbp, e->eu_p->eumate_p->vu_p->v_p, tab);
}

/*
 *			M N G _ V L B L O C K _ E U
 */
void
nmg_vlblock_eu(struct bn_vlblock *vbp, const struct edgeuse *eu, long int *tab, int red, int green, int blue, int fancy, int loopnum)
{
	point_t base, tip;
	point_t	radial_tip;
	point_t	next_base;
	struct bu_list	*vh;

	BN_CK_VLBLOCK(vbp);
	NMG_CK_EDGEUSE(eu);
	NMG_INDEX_RETURN_IF_SET_ELSE_SET( tab, eu->index );

	NMG_CK_EDGE(eu->e_p);
	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);

	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);

	nmg_vlblock_e(vbp, eu->e_p, tab, red, green, blue, fancy);

	if( !fancy )  return;

	if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
	    *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC) {

	    	/* if "fancy" doesn't specify plotting edgeuses of this
	    	 * particular face orientation, return
	    	 */
	    	if ( (eu->up.lu_p->up.fu_p->orientation == OT_SAME &&
	    	     (fancy & 1) == 0) ||
		     (eu->up.lu_p->up.fu_p->orientation == OT_OPPOSITE &&
		     (fancy & 2) == 0) )
	    		return;

	    	nmg_eu_coords(eu, base, tip);
	    	/* draw edgeuses of an OT_SAME faceuse in bright green,
	    	 * and  edgeuses of an OT_OPPOSITE faceuse in cyan.
	    	 * WIRE/UNSPEC edgeuses are drawn white.
	    	 */
	    	if (eu->up.lu_p->up.fu_p->orientation == OT_SAME) {
	    		if (eu->up.lu_p->orientation == OT_SAME) {
	    			/* green */
	    			red = 75;
	    			green = 250;
	    			blue = 75;
	    		} else if (eu->up.lu_p->orientation == OT_OPPOSITE) {
	    			/* yellow */
	    			red = 250;
	    			green = 250;
	    			blue = 75;
	    		} else {
	    			red = 250;
	    			green = 50;
	    			blue = 250;
	    		}
		} else if (eu->up.lu_p->up.fu_p->orientation == OT_OPPOSITE) {
	    		if (eu->up.lu_p->orientation == OT_SAME) {
	    			/* blue */
	    			red = 100;
	    			green = 100;
	    			blue = 250;
	    		} else if (eu->up.lu_p->orientation == OT_OPPOSITE) {
	    			/* cyan */
	    			red = 200;
	    			green = 100;
	    			blue = 250;
	    		} else {
	    			/* dark magenta */
	    			red = 125;
	    			green = 0;
	    			blue = 125;
	    		}
	    	} else
	    		red = green = blue = 255;

	    	/* draw the portion from the vertexuse to just beyond the
	    	 * midway point to represent the edgeuse
	    	 */
		vh = rt_vlblock_find( vbp, red, green, blue );
		RT_ADD_VLIST( vh, base, BN_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vh, tip, BN_VLIST_LINE_DRAW );

	    	/* draw a line from the tip of the edgeuse part to a point
	    	 * behind the tip of the radial edgeuse.  This provides 2
	    	 * visual cues.  First it allows us to identify the radial
	    	 * edgeuse, and second, it makes a "half arrowhead" on the
	    	 * edgeuse, making it easier to recognize the direction
	    	 * of the edgeuse
	    	 */
	    	nmg_eu_radial( eu, radial_tip );
		vh = rt_vlblock_find( vbp, red, green-20, blue );
		RT_ADD_VLIST( vh, tip, BN_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vh, radial_tip, BN_VLIST_LINE_DRAW );

	    	/* we draw a line from the tip of the edgeuse line
	    	 * to the vertexuse/start of the next edgeuse in the loop.
	    	 * This helps us to visually trace the loop from edgeuse to
	    	 * edgeuse.  The color of this part encodes the loopuse
	    	 * orientation.
	    	 */
	    	nmg_eu_next_base( eu, next_base );
	    	red *= 0.5;
	    	green *= 0.5;
	    	blue *= 0.5;
		vh = rt_vlblock_find( vbp, red, green, blue );
		RT_ADD_VLIST( vh, tip, BN_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vh, next_base, BN_VLIST_LINE_DRAW );
	}
}

/*
 *			N M G _ V L B L O C K _ E U L E F T
 *
 *  Draw the left vector for this edgeuse.
 *  At the tip, write the angle around the edgeuse, in degrees.
 *
 *  Color is determined by caller.
 */
void
nmg_vlblock_euleft(struct bu_list *vh, const struct edgeuse *eu, const fastf_t *center, const fastf_t *mat, const fastf_t *xvec, const fastf_t *yvec, double len, const struct bn_tol *tol)
{
	vect_t		left;
	point_t		tip;
	fastf_t		fan_len;
	fastf_t		char_scale;
	double		ang;
	char		str[128];

	NMG_CK_EDGEUSE(eu);
	BN_CK_TOL(tol);

	if( nmg_find_eu_leftvec( left, eu ) < 0 )  return;

	/* fan_len is baed on length of eu */
	fan_len = len * 0.2;
	VJOIN1( tip, center, fan_len, left );

	RT_ADD_VLIST( vh, center, BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vh, tip, BN_VLIST_LINE_DRAW );

	ang = bn_angle_measure( left, xvec, yvec ) * bn_radtodeg;
	sprintf( str, "%g", ang );

	/* char_scale is based on length of eu */
	char_scale = len * 0.05;
	bn_vlist_3string( vh, &rt_g.rtg_vlfree, str, tip, mat, char_scale );
}

/*
 *			N M G _ V L B L O C K _ A R O U N D _ E U
 *
 *  Given an edgeuse, plot all the edgeuses around the common edge.
 *  A graphical parallel to nmg_pr_fu_around_eu_vecs().
 *
 *  If the "fancy" flag is set, draw an angle fan around the edge midpoint,
 *  using the same angular reference as nmg_pr_fu_around_eu_vecs(), so
 *  that the printed output can be cross-referenced to this display.
 */
void
nmg_vlblock_around_eu(struct bn_vlblock *vbp, const struct edgeuse *arg_eu, long int *tab, int fancy, const struct bn_tol *tol)
{
	const struct edgeuse		*orig_eu;
	register const struct edgeuse	*eu;
	vect_t			xvec, yvec, zvec;
	point_t			center;
	mat_t			mat;
	struct bu_list		*vh;
	fastf_t			len;

	BN_CK_VLBLOCK(vbp);
	NMG_CK_EDGEUSE(arg_eu);
	BN_CK_TOL(tol);

	if( fancy )  {
		VSUB2( xvec, arg_eu->eumate_p->vu_p->v_p->vg_p->coord,
			arg_eu->vu_p->v_p->vg_p->coord );
		len = MAGNITUDE( xvec );

		/* Erect coordinate system around eu */
		nmg_eu_2vecs_perp( xvec, yvec, zvec, arg_eu, tol );

		/*  Construct matrix to rotate characters from 2D drawing space
		 *  into model coordinates, oriented in plane perpendicular to eu.
		 */
		MAT_ZERO( mat );
		mat[0] = xvec[X];
		mat[4] = xvec[Y];
		mat[8] = xvec[Z];

		mat[1] = yvec[X];
		mat[5] = yvec[Y];
		mat[9] = yvec[Z];

		mat[2] = zvec[X];
		mat[6] = zvec[Y];
		mat[10] = zvec[Z];
		mat[15] = 1;

		VADD2SCALE( center, arg_eu->vu_p->v_p->vg_p->coord,
			arg_eu->eumate_p->vu_p->v_p->vg_p->coord, 0.5 );

		/* Yellow, for now */
		vh = rt_vlblock_find( vbp, 255, 200, 0 );
	} else {
		vh = (struct bu_list *)NULL;
		len = 1;
	}

	orig_eu = arg_eu->eumate_p;

	eu = orig_eu;
	do {
		if(fancy) nmg_vlblock_euleft( vh, eu, center, mat, xvec, yvec, len, tol );

		nmg_vlblock_eu(vbp, eu, tab, 80, 100, 170, 3, 0);
		eu = eu->eumate_p;

		nmg_vlblock_eu(vbp, eu, tab, 80, 100, 170, 3, 0);
		eu = eu->radial_p;
	} while( eu != orig_eu );
}

/*
 *			N M G _ V L B L O C K _ L U
 */
void
nmg_vlblock_lu(struct bn_vlblock *vbp, const struct loopuse *lu, long int *tab, int red, int green, int blue, int fancy, int loopnum)
{
	struct edgeuse	*eu;
	long		magic1;
	struct vertexuse *vu;

	BN_CK_VLBLOCK(vbp);
	NMG_CK_LOOPUSE(lu);
	NMG_INDEX_RETURN_IF_SET_ELSE_SET( tab, lu->index );

	magic1 = BU_LIST_FIRST_MAGIC( &lu->down_hd );
	if (magic1 == NMG_VERTEXUSE_MAGIC &&
	    lu->orientation != OT_BOOLPLACE) {
	    	vu = BU_LIST_PNEXT(vertexuse, &lu->down_hd);
	    	NMG_CK_VERTEXUSE(vu);
	    	nmg_vlblock_v(vbp, vu->v_p, tab);
	} else if (magic1 == NMG_EDGEUSE_MAGIC) {
		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			nmg_vlblock_eu(vbp, eu, tab, red, green, blue,
				fancy, loopnum);
		}
	}
}

/*
 *			M N G _ V L B L O C K _ F U
 */
void
nmg_vlblock_fu(struct bn_vlblock *vbp, const struct faceuse *fu, long int *tab, int fancy)
{
	struct loopuse *lu;
	int 		loopnum = 0;

	BN_CK_VLBLOCK(vbp);
	NMG_CK_FACEUSE(fu);
	NMG_INDEX_RETURN_IF_SET_ELSE_SET( tab, fu->index );

	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		/* Draw in pale blue / purple */
		if( fancy )  {
			nmg_vlblock_lu(vbp, lu, tab, 80, 100, 170, fancy, loopnum++ );
		} else {
			/* Non-fancy */
			nmg_vlblock_lu(vbp, lu, tab, 80, 100, 170, 0, loopnum++ );
		}
	}
}

/*
 *			N M G _ V L B L O C K _ S
 */
void
nmg_vlblock_s(struct bn_vlblock *vbp, const struct shell *s, int fancy)
{
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct model	*m;
	long		*tab;

	BN_CK_VLBLOCK(vbp);
	NMG_CK_SHELL(s);
	NMG_CK_REGION(s->r_p);
	m = s->r_p->m_p;
	NMG_CK_MODEL(m);

	/* get space for list of items processed */
	tab = (long *)bu_calloc( m->maxindex+1, sizeof(long),
		"nmg_vlblock_s tab[]");

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
		nmg_vlblock_fu(vbp, fu, tab, fancy );
	}

	for( BU_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		if( fancy ) {
			nmg_vlblock_lu(vbp, lu, tab, 255, 0, 0, fancy, 0);
		} else {
			/* non-fancy, wire loops in red */
			nmg_vlblock_lu(vbp, lu, tab, 200, 0, 0, 0, 0);
		}
	}

	for( BU_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGE(eu->e_p);

		if( fancy )  {
			nmg_vlblock_eu(vbp, eu, tab, 200, 200, 0, fancy, 0 );
		} else {
			/* non-fancy, wire edges in yellow */
			nmg_vlblock_eu(vbp, eu, tab, 200, 200, 0, 0, 0); 
		}
	}
	if (s->vu_p) {
		nmg_vlblock_v(vbp, s->vu_p->v_p, tab );
	}

	bu_free( (char *)tab, "nmg_vlblock_s tab[]" );
}

/*
 *			N M G _ V L B L O C K _ R
 */
void
nmg_vlblock_r(struct bn_vlblock *vbp, const struct nmgregion *r, int fancy)
{
	struct shell *s;

	BN_CK_VLBLOCK(vbp);
	NMG_CK_REGION(r);

	for( BU_LIST_FOR( s, shell, &r->s_hd ) )  {
		nmg_vlblock_s(vbp, s, fancy);
	}
}

/*
 *			N M G _ V L B L O C K _ M
 */
void
nmg_vlblock_m(struct bn_vlblock *vbp, const struct model *m, int fancy)
{
	struct nmgregion *r;

	BN_CK_VLBLOCK(vbp);
	NMG_CK_MODEL(m);

	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
		nmg_vlblock_r(vbp, r, fancy);
	}
}

/************************************************************************
 *									*
 *		Visualization helper routines				*
 *									*
 ************************************************************************/

/*
 *  If another use of this edge is in another shell, plot all the
 *  uses around this edge.
 */
void
nmg_pl_edges_in_2_shells(struct bn_vlblock *vbp, long int *b, const struct edgeuse *eu, int fancy, const struct bn_tol *tol)
{
	const struct edgeuse	*eur;
	const struct shell	*s;

	BN_CK_TOL(tol);
	eur = eu;
	NMG_CK_EDGEUSE(eu);
	NMG_CK_LOOPUSE(eu->up.lu_p);
	NMG_CK_FACEUSE(eu->up.lu_p->up.fu_p);
	s = eu->up.lu_p->up.fu_p->s_p;
	NMG_CK_SHELL(s);

	do {
		NMG_CK_EDGEUSE(eur);

		if (*eur->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    *eur->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
		    eur->up.lu_p->up.fu_p->s_p != s) {
		    	nmg_vlblock_around_eu(vbp, eu, b, fancy, tol);
		    	break;
		    }

		eur = eur->radial_p->eumate_p;
	} while (eur != eu);
}

/*
 *			N M G _ P L _ I S E C T
 *
 *  Called by nmg_bool.c
 */
void
nmg_pl_isect(const char *filename, const struct shell *s, const struct bn_tol *tol)
{
	struct faceuse		*fu;
	struct loopuse		*lu;
	struct edgeuse		*eu;
	long			*b;
	FILE			*fp;
	long			magic1;
	struct bn_vlblock	*vbp;

	NMG_CK_SHELL(s);
	BN_CK_TOL(tol);

	if ((fp=fopen(filename, "w")) == (FILE *)NULL) {
		(void)perror(filename);
		exit(-1);
	}

	b = (long *)bu_calloc( s->r_p->m_p->maxindex+1, sizeof(long),
		"nmg_pl_isect flags[]" );

	vbp = rt_vlblock_init();

	bu_log("overlay %s\n", filename);
	if( s->sa_p )  {
		NMG_CK_SHELL_A( s->sa_p );
#if 0
		pdv_3space( fp, s->sa_p->min_pt, s->sa_p->max_pt );
#endif
	}

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
			NMG_CK_LOOPUSE(lu);
			magic1 = BU_LIST_FIRST_MAGIC( &lu->down_hd );
			if (magic1 == NMG_EDGEUSE_MAGIC) {
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
					NMG_CK_EDGEUSE(eu);
					nmg_pl_edges_in_2_shells(vbp, b, eu, 0, tol);
				}
			} else if (magic1 == NMG_VERTEXUSE_MAGIC) {
				;
			} else {
				rt_bomb("nmg_pl_isect() bad loopuse down\n");
			}
		}
	}

	rt_plot_vlblock(fp, vbp);
	rt_vlblock_free(vbp);

	bu_free( (char *)b, "nmg_pl_isect flags[]" );

	(void)fclose(fp);
}

/*
 *			N M G _ P L _ C O M B _ F U
 *
 *  Called from nmg_bool.c/nmg_face_combine()
 */
void
nmg_pl_comb_fu(int num1, int num2, const struct faceuse *fu1)
{
	FILE			*fp;
	char			name[64];
	int			do_plot = 0;
	int			do_anim = 0;
	struct model		*m;
	long			*tab;
	struct bn_vlblock	*vbp;

	if(rt_g.NMG_debug & DEBUG_PLOTEM &&
	   rt_g.NMG_debug & DEBUG_FCUT ) do_plot = 1;
	if( rt_g.NMG_debug & DEBUG_PL_ANIM )  do_anim = 1;

	if( !do_plot && !do_anim )  return;

	m = nmg_find_model( &fu1->l.magic );
	NMG_CK_MODEL(m);
	/* get space for list of items processed */
	tab = (long *)bu_calloc( m->maxindex+1, sizeof(long),
		"nmg_pl_comb_fu tab[]");

	vbp = rt_vlblock_init();

	nmg_vlblock_fu(vbp, fu1, tab, 3);

	if( do_plot )  {
	    	(void)sprintf(name, "comb%d.%d.pl", num1, num2);
		if ((fp=fopen(name, "w")) == (FILE *)NULL) {
			(void)perror(name);
			return;
		}
		bu_log("overlay %s\n", name);

		rt_plot_vlblock(fp, vbp);

		(void)fclose(fp);
	}

	if( do_anim )  {
		if( nmg_vlblock_anim_upcall )  {
			(*nmg_vlblock_anim_upcall)( vbp,
				(rt_g.NMG_debug&DEBUG_PL_SLOW) ? US_DELAY : 0,
				0 );
		} else {
			bu_log("null nmg_vlblock_anim_upcall, no animation\n");
		}
	}
	rt_vlblock_free(vbp);
	bu_free( (char *)tab, "nmg_pl_comb_fu tab[]" );
}

/*
 *			N M G _ P L _ 2 F U
 *
 *  Note that 'str' is expected to contain a %d to place the frame number.
 *
 *  Called from nmg_isect_2faces and other places.
 */
void
nmg_pl_2fu(const char *str, int unused, const struct faceuse *fu1, const struct faceuse *fu2, int show_mates)
{
	FILE		*fp;
	char		name[32];
	struct model	*m;
	long		*tab;
	static int	num = 1;
	struct bn_vlblock	*vbp;

	if( (rt_g.NMG_debug & (DEBUG_PLOTEM|DEBUG_PL_ANIM)) == 0 )  return;

	m = nmg_find_model( &fu1->l.magic );
	NMG_CK_MODEL(m);
	/* get space for list of items processed */
	tab = (long *)bu_calloc( m->maxindex+1, sizeof(long),
		"nmg_pl_comb_fu tab[]");

	/* Create the vlblock */
	vbp = rt_vlblock_init();

	nmg_vlblock_fu( vbp, fu1, tab, 3);
	if( show_mates )
		nmg_vlblock_fu( vbp, fu1->fumate_p, tab, 3);

	nmg_vlblock_fu( vbp, fu2, tab, 3);
	if( show_mates )
		nmg_vlblock_fu( vbp, fu2->fumate_p, tab, 3);

	if( rt_g.NMG_debug & DEBUG_PLOTEM )  {
		(void)sprintf(name, str, num++);
		bu_log("overlay %s\n", name);
		if ((fp=fopen(name, "w")) == (FILE *)NULL)  {
			perror(name);
			return;
		}
		rt_plot_vlblock( fp, vbp );
		(void)fclose(fp);
	}

	if( rt_g.NMG_debug & DEBUG_PL_ANIM )  {
		/* Cause animation of boolean operation as it proceeds! */
		if( nmg_vlblock_anim_upcall )  {
			(*nmg_vlblock_anim_upcall)( vbp,
				(rt_g.NMG_debug&DEBUG_PL_SLOW) ? US_DELAY : 0,
				0 );
		}
	}

	rt_vlblock_free(vbp);
	bu_free( (char *)tab, "nmg_pl_2fu tab[]" );
}

/************************************************************************
 *									*
 *			Graphical display of classifier results		*
 *									*
 ************************************************************************/

int		nmg_class_nothing_broken=1;
static long	**global_classlist;
static long	*broken_tab;
static int	broken_tab_len;
static int 	broken_color;
static unsigned char broken_colors[][3] = {
	{ 100, 100, 255 },	/* NMG_CLASS_AinB (bright blue) */
	{ 255,  50,  50 },	/* NMG_CLASS_AonBshared (red) */
	{ 255,  50, 255 }, 	/* NMG_CLASS_AonBanti (magenta) */
	{  50, 255,  50 },	/* NMG_CLASS_AoutB (bright green) */
	{ 255, 255, 255 },	/* UNKNOWN (white) */
	{ 255, 255, 125 }	/* no classification list (cyan) */
};
#define PICK_BROKEN_COLOR(p) { \
	if (global_classlist == (long **)NULL) { \
		broken_color = 5; \
	} else if( NMG_INDEX_TEST(global_classlist[NMG_CLASS_AinB], (p)) ) \
		broken_color = NMG_CLASS_AinB; \
	else if( NMG_INDEX_TEST(global_classlist[NMG_CLASS_AonBshared], (p)) ) \
		broken_color = NMG_CLASS_AonBshared; \
	else if( NMG_INDEX_TEST(global_classlist[NMG_CLASS_AonBanti], (p)) ) \
		broken_color = NMG_CLASS_AonBanti; \
	else if ( NMG_INDEX_TEST(global_classlist[NMG_CLASS_AoutB], (p)) ) \
		broken_color = NMG_CLASS_AoutB; \
	else \
		broken_color = 4;}

/*
 *			S H O W _ B R O K E N _ V U
 */
static void
show_broken_vu(struct bn_vlblock *vbp, const struct vertexuse *vu, int fancy)
{
	pointp_t p;
	struct bu_list	*vh;
	struct vertex *v;
	point_t pt;

	NMG_CK_VERTEXUSE(vu);
	v = vu->v_p;
	NMG_CK_VERTEX(v);
	NMG_CK_VERTEX_G(v->vg_p);

	NMG_INDEX_RETURN_IF_SET_ELSE_SET( broken_tab, v->index );

	NMG_CK_VERTEX_G(v->vg_p);
	p = v->vg_p->coord;

	PICK_BROKEN_COLOR(vu->v_p);
	if (broken_color == 4) {
/*		fprintf(stderr, "vertex broken_color %d...", broken_color); */
		PICK_BROKEN_COLOR(vu);
/*		fprintf(stderr, "vertexuse broken_color %d\n", broken_color); */
	}
	vh = rt_vlblock_find( vbp, 
		broken_colors[broken_color][0], broken_colors[broken_color][1], broken_colors[broken_color][2]);

	RT_ADD_VLIST( vh, p, BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vh, p, BN_VLIST_LINE_DRAW );


	VMOVE(pt, p);
	pt[0] += 0.05;
	RT_ADD_VLIST( vh, pt, BN_VLIST_LINE_MOVE );
	VMOVE(pt, p);
	pt[0] -= 0.05;
	RT_ADD_VLIST( vh, pt, BN_VLIST_LINE_DRAW );

	VMOVE(pt, p);
	pt[1] += 0.05;
	RT_ADD_VLIST( vh, pt, BN_VLIST_LINE_MOVE );
	VMOVE(pt, p);
	pt[1] -= 0.05;
	RT_ADD_VLIST( vh, pt, BN_VLIST_LINE_DRAW );

	VMOVE(pt, p);
	pt[2] += 0.05;
	RT_ADD_VLIST( vh, pt, BN_VLIST_LINE_MOVE );
	VMOVE(pt, p);
	pt[2] -= 0.05;
	RT_ADD_VLIST( vh, pt, BN_VLIST_LINE_DRAW );

	RT_ADD_VLIST( vh, p, BN_VLIST_LINE_MOVE );
}

static void
show_broken_e(struct bn_vlblock *vbp, const struct edgeuse *eu, int fancy)
{
	pointp_t p0, p1;
	point_t end0, end1;
	vect_t v;
	struct bu_list	*vh;

	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);

	NMG_INDEX_RETURN_IF_SET_ELSE_SET( broken_tab, eu->e_p->index );

	p0 = eu->vu_p->v_p->vg_p->coord;
	p1 = eu->eumate_p->vu_p->v_p->vg_p->coord;

	/* leave a little room between the edge endpoints and the vertex
	 * compute endpoints by forming a vector between verts, scale vector,
	 * and modify points
	 */
	VSUB2SCALE(v, p1, p0, 0.90);
	VADD2(end0, p0, v);
	VSUB2(end1, p1, v);


	PICK_BROKEN_COLOR(eu->e_p);
	if (broken_color == 4) {
/*		fprintf(stderr, "edge broken_color %d... ", broken_color); */
		PICK_BROKEN_COLOR(eu);
/*		fprintf(stderr, "edgeuse broken_color %d\n", broken_color); */
	}

	vh = rt_vlblock_find( vbp, 
		broken_colors[broken_color][0], broken_colors[broken_color][1], broken_colors[broken_color][2]);

	RT_ADD_VLIST( vh, end0, BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vh, end1, BN_VLIST_LINE_DRAW );

	show_broken_vu(vbp, eu->vu_p, fancy);
	show_broken_vu(vbp, eu->eumate_p->vu_p, fancy);

}


static void
show_broken_eu(struct bn_vlblock *vbp, const struct edgeuse *eu, int fancy)
{
	struct bu_list	*vh;
    	int red, green, blue;
	point_t base, tip;
	point_t	radial_tip;
	point_t	next_base;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGE(eu->e_p);

	show_broken_e(vbp, eu, fancy);

	if (!fancy) return;

	/* paint the edgeuse lines */
	if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
	    *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC) {

	    	red = broken_colors[broken_color][0];
	    	green = broken_colors[broken_color][1];
	    	blue = broken_colors[broken_color][2];

	    	nmg_eu_coords(eu, base, tip);
	    	if (eu->up.lu_p->up.fu_p->orientation == OT_SAME)
	    		red += 50;
		else if (eu->up.lu_p->up.fu_p->orientation == OT_OPPOSITE)
			red -= 50;
	    	else
	    		red = green = blue = 255;

		vh = rt_vlblock_find( vbp, red, green, blue );
		RT_ADD_VLIST( vh, base, BN_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vh, tip, BN_VLIST_LINE_DRAW );

	    	nmg_eu_radial( eu, radial_tip );
		vh = rt_vlblock_find( vbp, red, green-20, blue );
		RT_ADD_VLIST( vh, tip, BN_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vh, radial_tip, BN_VLIST_LINE_DRAW );

	    	nmg_eu_next_base( eu, next_base );
		vh = rt_vlblock_find( vbp, 0, 100, 0 );
		RT_ADD_VLIST( vh, tip, BN_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vh, next_base, BN_VLIST_LINE_DRAW );
	}

}

static void
show_broken_lu(struct bn_vlblock *vbp, const struct loopuse *lu, int fancy)
{
	register struct edgeuse *eu;
	struct bu_list	*vh;
	vect_t		n;

	NMG_CK_LOOPUSE(lu);

	if( BU_LIST_FIRST_MAGIC(&lu->down_hd)==NMG_VERTEXUSE_MAGIC )  {
		register struct vertexuse *vu;
		vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
		show_broken_vu(vbp, vu, fancy);
		return;
	}

	if (rt_g.NMG_debug & DEBUG_GRAPHCL)  {
		for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd))
			show_broken_eu(vbp, eu, fancy);
	}

	/* Draw colored polygons for the actual face loops */
	/* Faces are not classified, only loops */
	/* This can obscure the edge/vertex info */
	PICK_BROKEN_COLOR(lu->l_p);
	vh = rt_vlblock_find( vbp, 
		broken_colors[broken_color][0], broken_colors[broken_color][1], broken_colors[broken_color][2]);

	if( *lu->up.magic_p == NMG_FACEUSE_MAGIC )  {
		NMG_GET_FU_NORMAL( n, lu->up.fu_p );
	} else {
		/* For wire loops, use a constant normal */
		VSET( n, 0, 0, 1 );
	}

	if ((rt_g.NMG_debug & (DEBUG_GRAPHCL|DEBUG_PL_LOOP)) == (DEBUG_PL_LOOP) ) {
		/* If only DEBUG_PL_LOOP set, just draw lu as wires */
		nmg_lu_to_vlist( vh, lu, 0, n );
	} else if ((rt_g.NMG_debug & (DEBUG_GRAPHCL|DEBUG_PL_LOOP)) == (DEBUG_GRAPHCL|DEBUG_PL_LOOP) ) {
		/* Draw as polygons if both set */
		nmg_lu_to_vlist( vh, lu, 1, n );
	} else {
		/* If only DEBUG_GRAPHCL set, don't draw lu's at all */
	}
}



static void
show_broken_fu(struct bn_vlblock *vbp, const struct faceuse *fu, int fancy)
{
	register struct loopuse *lu;

	NMG_CK_FACEUSE(fu);
	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		show_broken_lu(vbp, lu, fancy);
	}
}

static void
show_broken_s(struct bn_vlblock *vbp, const struct shell *s, int fancy)
{
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;

	NMG_CK_SHELL(s);
	for ( BU_LIST_FOR(fu, faceuse, &s->fu_hd ))
		show_broken_fu(vbp, fu, fancy);
	for ( BU_LIST_FOR(lu, loopuse, &s->lu_hd ))
		show_broken_lu(vbp, lu, fancy);
	for ( BU_LIST_FOR(eu, edgeuse, &s->eu_hd ))
		show_broken_eu(vbp, eu, fancy);
	if ( s->vu_p )
		show_broken_vu(vbp, s->vu_p, fancy);
}
static void
show_broken_r(struct bn_vlblock *vbp, const struct nmgregion *r, int fancy)
{
	register struct shell *s;

	NMG_CK_REGION(r);
	for ( BU_LIST_FOR(s, shell, & r->s_hd))
		show_broken_s(vbp, s, fancy);
}

static void
show_broken_m(struct bn_vlblock *vbp, const struct model *m, int fancy)
{
	register struct nmgregion *r;

	NMG_CK_MODEL(m);
	for (BU_LIST_FOR(r, nmgregion, &m->r_hd))
		show_broken_r(vbp, r, fancy);
}

static struct bn_vlblock *vbp = (struct bn_vlblock *)NULL;
static int stepalong = 0;

void
nmg_plot_sigstepalong(int i)
{
	stepalong=1;
}

/*
 *			S H O W _ B R O K E N _ S T U F F
 *
 * XXX Needs new name, with nmg_ prefix, and a stronger indication
 * that this is a graphical display of classifier operation.
 */
void
nmg_show_broken_classifier_stuff(long int *p, long int **classlist, int all_new, int fancy, const char *a_string)
{
	struct model *m;

/*	printf("showing broken stuff\n"); */

	global_classlist = classlist;

	nmg_class_nothing_broken = 0;

	if (!vbp)
		vbp = rt_vlblock_init();
	else if (all_new) {
		rt_vlblock_free(vbp);
		vbp = (struct bn_vlblock *)NULL;
		vbp = rt_vlblock_init();
	}

	m = nmg_find_model(p);
	/* get space for list of items processed */
	if (!broken_tab) {
		broken_tab = (long *)bu_calloc( m->maxindex+1, sizeof(long),
			"nmg_vlblock_s tab[]");
		broken_tab_len = m->maxindex+1;
	} else {
		if( broken_tab_len < m->maxindex+1 ) {
			bu_log("nmg_show_broken_classifier_stuff() maxindex increased! was %d, now %d\n",
				broken_tab_len, m->maxindex+1 );
			broken_tab = (long *)rt_realloc( (char *)broken_tab,
				(m->maxindex+1) * sizeof(long),
				"nmg_vlblock_s tab[] enlargement");
			broken_tab_len = m->maxindex+1;
		}
		if (all_new) {
			bzero( (char *)broken_tab,  (m->maxindex+1) * sizeof(long));
		}
	}


	switch (*p) {
	case NMG_MODEL_MAGIC:
		show_broken_m( vbp, (struct model *)p, fancy);
		break;
	case NMG_REGION_MAGIC:
		show_broken_r( vbp, (struct nmgregion *)p, fancy);
		break;
	case NMG_SHELL_MAGIC:
		show_broken_s( vbp, (struct shell *)p, fancy);
		break;
	case NMG_FACE_MAGIC:
		show_broken_fu( vbp, ((struct face *)p)->fu_p, fancy);
		break;
	case NMG_FACEUSE_MAGIC:
		show_broken_fu( vbp, (struct faceuse *)p, fancy);
#if 0
		{
			struct bn_vlblock *vbp2 = vbp;
			register struct loopuse *lu;
			struct faceuse *fu = (struct faceuse *)p;
			int i;
			void            (*cur_sigint)();

			cur_sigint = signal(SIGINT, nmg_plot_sigstepalong);
			for (stepalong=0;!stepalong;) {
				for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
					nmg_show_broken_classifier_stuff(lu, classlist, 1, fancy);
					for (i=0 ; ++i ; );
				}
			}
			signal(SIGINT, cur_sigint);

			show_broken_fu( vbp, (struct faceuse *)p, fancy);
		}
#endif
		break;
	case NMG_LOOPUSE_MAGIC:
		show_broken_lu( vbp, (struct loopuse *)p, fancy);
		break;
	case NMG_EDGE_MAGIC:
		 show_broken_eu( vbp, ((struct edge *)p)->eu_p, fancy);
		 break;
	case NMG_EDGEUSE_MAGIC:
		show_broken_eu( vbp, (struct edgeuse *)p, fancy);
		break;
	case NMG_VERTEXUSE_MAGIC:
		show_broken_vu( vbp, (struct vertexuse *)p, fancy);
		break;
	default: fprintf(stderr, "Unknown magic number %ld %0lx %lu %0lx\n", *p, *p, (unsigned long)p, (unsigned long)p);
				break;
	}

	/* Cause animation of boolean operation as it proceeds! */
	/* The "copy" flag on nmg_vlblock_anim_upcall() means that
	 * the vlist will remain, undisturbed, for further use. */
	if( nmg_vlblock_anim_upcall )  {
		void            (*cur_sigint)();

		if (!a_string) {
			(*nmg_vlblock_anim_upcall)( vbp,
				(rt_g.NMG_debug&DEBUG_PL_SLOW) ? US_DELAY : 0,
				1 );
		} else {

			bu_log("NMG Intermediate display Ctrl-C to continue (%s)\n", a_string);
			cur_sigint = signal(SIGINT, nmg_plot_sigstepalong);
			(*nmg_vlblock_anim_upcall)( vbp,
				(rt_g.NMG_debug&DEBUG_PL_SLOW) ? US_DELAY : 0,
				1 );
			for (stepalong = 0; !stepalong ; ) {
				(*nmg_mged_debug_display_hack)();
			}
			signal(SIGINT, cur_sigint);
			bu_log("Continuing\n");
		}
	} else {
		/* Non interactive, drop a plot file */
		char	buf[128];
		static int	num=0;
		FILE		*fp;

		sprintf( buf, "cbroke%d.pl", num++ );
		if( (fp = fopen(buf, "w")) )  {
			rt_plot_vlblock(fp, vbp);
			fclose(fp);
			bu_log("overlay %s for %s\n", buf, a_string);
		}

		rt_vlblock_free(vbp);
		vbp = (struct bn_vlblock *)NULL;
		bu_free((char *)broken_tab, "broken_tab");
		broken_tab = (long *)NULL;
		broken_tab_len = 0;
	}
}

/*
 *			N M G _ F A C E _ P L O T
 */
void
nmg_face_plot(const struct faceuse *fu)
{
	FILE		*fp;
	char		name[32];
	extern void (*nmg_vlblock_anim_upcall)();
	struct model		*m;
	struct bn_vlblock	*vbp;
	long		*tab;
	int		fancy;
	static int	num = 1;

	if( (rt_g.NMG_debug & (DEBUG_PLOTEM|DEBUG_PL_ANIM)) == 0 )  return;

	NMG_CK_FACEUSE(fu);

	m = nmg_find_model( (long *)fu );
	NMG_CK_MODEL(m);

	/* get space for list of items processed */
	tab = (long *)bu_calloc( m->maxindex+1, sizeof(long),
		"nmg_face_plot tab[]");

	vbp = rt_vlblock_init();

	fancy = 3;	/* show both types of edgeuses */
	nmg_vlblock_fu(vbp, fu, tab, fancy );

	if( rt_g.NMG_debug & DEBUG_PLOTEM )  {
		(void)sprintf(name, "face%d.pl", num++);
		bu_log("overlay %s\n", name);
		if ((fp=fopen(name, "w")) == (FILE *)NULL)  {
			perror(name);
			return;
		}
		rt_plot_vlblock( fp, vbp );
		(void)fclose(fp);
	}

	if( rt_g.NMG_debug & DEBUG_PL_ANIM )  {
		/* Cause animation of boolean operation as it proceeds! */
		if( nmg_vlblock_anim_upcall )  {
			/* if requested, delay 3/4 second */
			(*nmg_vlblock_anim_upcall)( vbp,
				(rt_g.NMG_debug&DEBUG_PL_SLOW) ? 750000 : 0,
				0 );
		} else {
			bu_log("null nmg_vlblock_anim_upcall, no animation\n");
		}
	}
	rt_vlblock_free(vbp);
	bu_free( (char *)tab, "nmg_face_plot tab[]" );

}

/*
 *			N M G _ 2 F A C E _ P L O T
 *
 *  Just like nmg_face_plot, except it draws two faces each iteration.
 */
void
nmg_2face_plot(const struct faceuse *fu1, const struct faceuse *fu2)
{
	extern void (*nmg_vlblock_anim_upcall)();
	struct model		*m;
	struct bn_vlblock	*vbp;
	long		*tab;
	int		fancy;

	if( ! (rt_g.NMG_debug & DEBUG_PL_ANIM) )  return;

	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);

	m = nmg_find_model( (long *)fu1 );
	NMG_CK_MODEL(m);

	/* get space for list of items processed */
	tab = (long *)bu_calloc( m->maxindex+1, sizeof(long),
		"nmg_2face_plot tab[]");

	vbp = rt_vlblock_init();

	fancy = 3;	/* show both types of edgeuses */
	nmg_vlblock_fu(vbp, fu1, tab, fancy );
	nmg_vlblock_fu(vbp, fu2, tab, fancy );

	/* Cause animation of boolean operation as it proceeds! */
	if( nmg_vlblock_anim_upcall )  {
		/* if requested, delay 3/4 second */
		(*nmg_vlblock_anim_upcall)( vbp,
			(rt_g.NMG_debug&DEBUG_PL_SLOW) ? 750000 : 0,
			0 );
	} else {
		bu_log("null nmg_vlblock_anim_upcall, no animation\n");
	}
	rt_vlblock_free(vbp);
	bu_free( (char *)tab, "nmg_2face_plot tab[]" );

}

/*
 *			N M G _ F A C E _ L U _ P L O T
 *
 *  Plot the loop, and a ray from vu1 to vu2.
 */
void
nmg_face_lu_plot(const struct loopuse *lu, const struct vertexuse *vu1, const struct vertexuse *vu2)
{
	FILE	*fp;
	struct model	*m;
	long		*b;
	char		buf[128];
	static int	num = 0;
	vect_t		dir;
	point_t		p1, p2;

	if(!(rt_g.NMG_debug&DEBUG_PLOTEM)) return;

	NMG_CK_LOOPUSE(lu);
	NMG_CK_VERTEXUSE(vu1);
	NMG_CK_VERTEXUSE(vu2);

	m = nmg_find_model((long *)lu);
	sprintf(buf, "loop%d.pl", num++ );

	if( (fp = fopen(buf, "w")) == NULL )  {
		perror(buf);
		return;
	}
	b = (long *)bu_calloc( m->maxindex, sizeof(long), "nmg_face_lu_plot flag[]" );
	nmg_pl_lu(fp, lu, b, 255, 0, 0);

	/*
	 *  Two yellow lines for the ray.
	 *  Overshoot edge by +/-10%, for visibility.
	 *  Don't draw over top of the actual edge, it might hide verts.
	 */
	pl_color(fp, 255, 255, 0);
	VSUB2( dir, vu2->v_p->vg_p->coord, vu1->v_p->vg_p->coord );
	VJOIN1( p1, vu1->v_p->vg_p->coord, -0.1, dir );
	pdv_3line(fp, p1, vu1->v_p->vg_p->coord );
	VJOIN1( p2, vu1->v_p->vg_p->coord,  1.1, dir );
	pdv_3line(fp, vu2->v_p->vg_p->coord, p2 );

	fclose(fp);
	bu_log("overlay %s\n", buf);
	bu_free( (char *)b, "nmg_face_lu_plot flag[]" );
}

/*
 *			N M G _ P L O T _ L U _ R A Y
 *
 *  Plot the loop, a ray from vu1 to vu2, and the left vector.
 */
void
nmg_plot_lu_ray(const struct loopuse *lu, const struct vertexuse *vu1, const struct vertexuse *vu2, const fastf_t *left)
{
	FILE	*fp;
	struct model	*m;
	long		*b;
	char		buf[128];
	static int	num = 0;
	vect_t		dir;
	point_t		p1, p2;
	fastf_t		left_mag;

	if(!(rt_g.NMG_debug&DEBUG_PLOTEM)) return;

	NMG_CK_LOOPUSE(lu);
	NMG_CK_VERTEXUSE(vu1);
	NMG_CK_VERTEXUSE(vu2);

	m = nmg_find_model((long *)lu);
	sprintf(buf, "loop%d.pl", num++ );

	if( (fp = fopen(buf, "w")) == NULL )  {
		perror(buf);
		return;
	}
	b = (long *)bu_calloc( m->maxindex, sizeof(long), "nmg_plot_lu_ray flag[]" );
	nmg_pl_lu(fp, lu, b, 255, 0, 0);

	/*
	 *  Two yellow lines for the ray, and a third for the left vector.
	 *  Overshoot edge by +/-10%, for visibility.
	 *  Don't draw over top of the actual edge, it might hide verts.
	 */
	pl_color(fp, 255, 255, 0);
	VSUB2( dir, vu2->v_p->vg_p->coord, vu1->v_p->vg_p->coord );
	VJOIN1( p1, vu1->v_p->vg_p->coord, -0.1, dir );
	pdv_3line(fp, p1, vu1->v_p->vg_p->coord );
	VJOIN1( p2, vu1->v_p->vg_p->coord,  1.1, dir );
	pdv_3line(fp, vu2->v_p->vg_p->coord, p2 );

	/* The left vector */
	left_mag = 0.1 * MAGNITUDE(dir);
	VJOIN1( p2, p1, left_mag, left );
	pdv_3line(fp, p1, p2);

	fclose(fp);
	bu_log("overlay %s\n", buf);
	bu_free( (char *)b, "nmg_plot_lu_ray flag[]" );
}

/*
 *			N M G _ P L O T _ R A Y _ F A C E
 */
void
nmg_plot_ray_face(const char *fname, fastf_t *pt, const fastf_t *dir, const struct faceuse *fu)
{
	FILE *fd;
	long *b;
	point_t pp;
	static int i=0;
	char name[1024];

	if ( ! (rt_g.NMG_debug & DEBUG_NMGRT) )
		return;

	sprintf(name, "%s%0d.pl", fname, i++);
	if ((fd = fopen(name, "w")) == (FILE *)NULL) {
		perror(name);
		bu_log("plot_ray_face cannot open %s", name);
		rt_bomb("aborting");
	}

	b = (long *)bu_calloc( fu->s_p->r_p->m_p->maxindex, sizeof(long), "bit vec");

	nmg_pl_fu(fd, fu, b, 200, 200, 200);

	bu_free((char *)b, "bit vec");

	VSCALE(pp, dir, 1000.0);
	VADD2(pp, pt, pp);
	pdv_3line( fd, pt, pp );
	(void)fclose(fd);
	bu_log("overlay %s\n", name);
}

/*
 *			N M G _ P L O T _ L U _ A R O U N D _ E U
 *
 *  Draw and label all the loopuses gathered around this edgeuse.
 *
 *  Called by nmg_radial_join_eu().
 */
void
nmg_plot_lu_around_eu(const char *prefix, const struct edgeuse *eu, const struct bn_tol *tol)
{
	char			file[256];
	static int		num=0;
	struct model		*m;
	struct bn_vlblock	*vbp;
	long			*tab;
	const struct edgeuse	*eur;
	FILE			*fp;

	NMG_CK_EDGEUSE(eu);
	BN_CK_TOL(tol);

	sprintf(file, "%s%0d.pl", prefix, num++);
	bu_log("overlay %s\n", file);
	if ((fp = fopen(file, "w")) == (FILE *)NULL) {
		bu_log("plot_lu_around_eu() cannot open %s", file);
		return;
	}

	m = nmg_find_model( (long *)eu );
	NMG_CK_MODEL(m);
	tab = (long *)bu_calloc( m->maxindex, sizeof(long), "bit vec");

	vbp = rt_vlblock_init();

	/* Draw all the left vectors, and a fancy edgeuse plot */
	nmg_vlblock_around_eu(vbp, eu, tab, 3, tol );

	eur = eu;
	do {
		NMG_CK_EDGEUSE(eur);

		if (*eur->up.magic_p == NMG_LOOPUSE_MAGIC )  {
			/* Draw this loop in non-fancy format, for context */
			nmg_vlblock_lu(vbp, eur->up.lu_p, tab, 80, 100, 170, 0, 0 );
		}
		eur = eur->radial_p->eumate_p;
	} while (eur != eu);

	rt_plot_vlblock( fp, vbp );
	(void)fclose(fp);
	rt_vlblock_free(vbp);
	bu_free((char *)tab, "bit vec");
}

/*
 *			N M G _ S N U R B _ T O _ V L I S T
 *
 *  A routine to draw the entire surface of a face_g_snurb.
 *  No handling of trimming curves is done.
 */
int
nmg_snurb_to_vlist(struct bu_list *vhead, const struct face_g_snurb *fg, int n_interior)
              			       
                         	    
   				           	/* typ. 10 */
{
	register int		i;
	register int		j;
	register fastf_t	* vp;
	struct knot_vector 	tkv1,
				tkv2,
				tau1,
				tau2;
	struct face_g_snurb	*r, *c;
	int 		coords;

	BU_CK_LIST_HEAD( vhead );
	NMG_CK_FACE_G_SNURB(fg);

	rt_nurb_kvgen( &tkv1,
		fg->u.knots[0],
		fg->u.knots[fg->u.k_size-1], n_interior, (struct resource *)NULL);

	rt_nurb_kvgen( &tkv2,
		fg->v.knots[0],
		fg->v.knots[fg->v.k_size-1], n_interior, (struct resource *)NULL);
		
	rt_nurb_kvmerge(&tau1, &tkv1, &fg->u, (struct resource *)NULL);
	rt_nurb_kvmerge(&tau2, &tkv2, &fg->v, (struct resource *)NULL);

/**	nmg_hack_snurb( &n, fg );	/ XXX */

	r = rt_nurb_s_refine( fg, RT_NURB_SPLIT_COL, &tau2, (struct resource *)NULL);
	NMG_CK_SNURB(r);
	c = rt_nurb_s_refine( r, RT_NURB_SPLIT_ROW, &tau1, (struct resource *)NULL);
	NMG_CK_SNURB(c);

	coords = RT_NURB_EXTRACT_COORDS(c->pt_type);
	
	if( RT_NURB_IS_PT_RATIONAL(c->pt_type))
	{
		vp = c->ctl_points;
		for(i= 0; 
			i < c->s_size[0] * c->s_size[1]; 
			i++)
		{
			FAST fastf_t	div;
			vp[0] *= (div = 1/vp[3]);
			vp[1] *= div;
			vp[2] *= div;
			vp[3] *= div;
			vp += coords;
		}
	}

	vp = c->ctl_points;
	for( i = 0; i < c->s_size[0]; i++)
	{
		RT_ADD_VLIST( vhead, vp, BN_VLIST_LINE_MOVE );
		vp += coords;
		for( j = 1; j < c->s_size[1]; j++)
		{
			RT_ADD_VLIST( vhead, vp, BN_VLIST_LINE_DRAW );
			vp += coords;
		}
	}

	for( j = 0; j < c->s_size[1]; j++)
	{
		int stride;
			
		stride = c->s_size[1] * coords;
		vp = &c->ctl_points[j * coords];
		RT_ADD_VLIST( vhead, vp, BN_VLIST_LINE_MOVE );
		vp += stride;
		for( i = 1; i < c->s_size[0]; i++)
		{
			RT_ADD_VLIST( vhead, vp, BN_VLIST_LINE_DRAW );
			vp += stride;
		}
	}
	rt_nurb_free_snurb(c, (struct resource *)NULL);
	rt_nurb_free_snurb(r, (struct resource *)NULL);

	bu_free( (char *) tau1.knots, "rt_nurb_plot:tau1.knots");
	bu_free( (char *) tau2.knots, "rt_nurb_plot:tau2.knots");
	bu_free( (char *) tkv1.knots, "rt_nurb_plot:tkv1>knots");
	bu_free( (char *) tkv2.knots, "rt_nurb_plot:tkv2.knots");

	return(0);
}

/*
 *			N M G _ C N U R B _ T O _ V L I S T
 *
 *  Draw interior points on a cnurb curve.
 *  The endpoints are not drawn, as those points are (should) match
 *  the vertices at the end of the edgeuse, and are handled by the caller.
 *
 *  Special processing is performed for the order <= 0 (linear) cnurbs.
 *
 *  If the curve is on a snurb face, it is in parameter space.
 *  If the curve is on a planar face, it is in XYZ space.
 */
void
nmg_cnurb_to_vlist(struct bu_list *vhead, const struct edgeuse *eu, int n_interior, int cmd)
              			       
                    		    
   				           	/* typ. 10 */
   				    		/* BN_VLIST_LINE_DRAW, etc */
{
	const struct edge_g_cnurb	*eg;
	const struct faceuse	*fu;
	register int		i;
	register fastf_t	*vp = (fastf_t	*)NULL;
	struct edge_g_cnurb	n;
	const struct edge_g_cnurb	*c;
	int 			coords;

	BU_CK_LIST_HEAD( vhead );
	NMG_CK_EDGEUSE(eu);
	eg = eu->g.cnurb_p;
	NMG_CK_EDGE_G_CNURB(eg);

	fu = nmg_find_fu_of_eu(eu);	/* may return NULL */
	NMG_CK_FACEUSE(fu);
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_cnurb_to_vlist() eu=x%x, n=%d, order=%d\n",
			eu, n_interior, eg->order);
	}

	if( eg->order <= 0 )  {
		/* linear cnurb on planar face -- no intermediate points to draw */
		if( *fu->f_p->g.magic_p == NMG_FACE_G_PLANE_MAGIC )
			return;

		/* linear cnurb on snurb face -- cnurb ctl pts are UV */
		n.order = 2;
		n.l.magic = RT_CNURB_MAGIC;
		rt_nurb_gen_knot_vector( &n.k, n.order, 0.0, 1.0, (struct resource *)NULL );
		n.c_size = 2;
		n.pt_type = RT_NURB_MAKE_PT_TYPE(2, RT_NURB_PT_UV, RT_NURB_PT_NONRAT );
		n.ctl_points = (fastf_t *)bu_malloc(
			sizeof(fastf_t) * RT_NURB_EXTRACT_COORDS(n.pt_type) *
			n.c_size, "nmg_cnurb_to_vlist() order0 ctl_points[]");
		/* Set ctl points to parametric values */
		NMG_CK_VERTEXUSE_A_CNURB(eu->vu_p->a.cnurb_p);
		n.ctl_points[0] = eu->vu_p->a.cnurb_p->param[0];
		n.ctl_points[1] = eu->vu_p->a.cnurb_p->param[1];
		n.ctl_points[2] = eu->eumate_p->vu_p->a.cnurb_p->param[0];
		n.ctl_points[3] = eu->eumate_p->vu_p->a.cnurb_p->param[1];
		c = &n;
	} else {
		/* Just use eg */
		c = eg;
	}

	NMG_CK_CNURB( c );

	coords = RT_NURB_EXTRACT_COORDS( c->pt_type );
	
	if( *fu->f_p->g.magic_p == NMG_FACE_G_PLANE_MAGIC )  {
		/* cnurb on planar face -- ctl points are XYZ */

		vp = c->ctl_points;
		/* Omit first and last points */
		for( i = 1; i < c->c_size-1; i++)  {
			RT_ADD_VLIST( vhead, vp, cmd );
			vp += coords;
		}
	} else {
		const struct face_g_snurb	*s;
		fastf_t		final[4];
		fastf_t		inv_homo;
		fastf_t		param_delta;
		fastf_t		crv_param;

		/* cnurb on spline face -- ctl points are UV or UVW */
		if( coords != 2 && !RT_NURB_IS_PT_RATIONAL(c->pt_type) ) bu_log("nmg_cnurb_to_vlist() coords=%d\n", coords);
		s = fu->f_p->g.snurb_p;

		/* This section uses rt_nurb_c_eval(), but rt_nurb_c_refine is likely faster.
		 * XXXX Need a way to selectively and recursively refine curve to avoid
		 * feeding rt_nurb_s_eval() parameters outside domain of surface.
		 */
		param_delta = (c->k.knots[c->k.k_size-1] - c->k.knots[0])/(fastf_t)(n_interior+1);
		crv_param = c->k.knots[0];
		for( i = 0; i < n_interior; i++)  {
			point_t uvw;

			/* evaluate curve at parameter values */
			crv_param += param_delta; 

			VSETALL(uvw,0);

			rt_nurb_c_eval( c, crv_param, uvw );

			if( RT_NURB_IS_PT_RATIONAL( c->pt_type ) )
			{
				uvw[0] = uvw[0]/uvw[2];
				uvw[1] = uvw[1]/uvw[2];
			}

			/* convert 'uvw' from UV coord to XYZ coord via surf! */
			rt_nurb_s_eval( s, uvw[0], uvw[1], final );

			if( RT_NURB_IS_PT_RATIONAL( s->pt_type ) )
			{
				/* divide out homogeneous coordinate */
				inv_homo = 1.0/final[3];
				VSCALE( final, final, inv_homo );
			}

			RT_ADD_VLIST( vhead, final, cmd );
			vp += coords;
		}
	}

	if( eg->order <= 0 )  {
		bu_free( (char *)n.k.knots, "nmg_cnurb_to_vlist() n.knot.knots");
		bu_free( (char *)n.ctl_points, "nmg_cnurb_to_vlist() ctl_points");
	}
}
@


11.32
log
@change conf.h to a wrapped config.h
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_plot.c,v 11.31 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.31
log
@merge of ansi-6-0-branch into HEAD
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d41 5
a45 1
#include "conf.h"
@


11.30
log
@update copyright to include span through 2003
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.29 2002/08/20 17:08:05 jra Exp $ (ARL)";
d73 1
a73 3
nmg_vu_to_vlist( vhead, vu )
struct bu_list		*vhead;
const struct vertexuse	*vu;
d96 1
a96 3
nmg_eu_to_vlist( vhead, eu_hd )
struct bu_list		*vhead;
const struct bu_list	*eu_hd;
d141 5
a145 5
nmg_lu_to_vlist( vhead, lu, poly_markers, normal )
struct bu_list		*vhead;
const struct loopuse	*lu;
int			poly_markers;		/* bit vector! */
const vectp_t		normal;
d301 1
a301 4
nmg_snurb_fu_to_vlist( vhead, fu, poly_markers )
struct bu_list		*vhead;
const struct faceuse	*fu;
int			poly_markers;
d353 1
a353 4
nmg_s_to_vlist( vhead, s, poly_markers )
struct bu_list		*vhead;
const struct shell	*s;
int			poly_markers;
d411 1
a411 4
nmg_r_to_vlist( vhead, r, poly_markers )
struct bu_list		*vhead;
const struct nmgregion	*r;
int			poly_markers;
d426 1
a426 4
nmg_m_to_vlist( vhead, m, poly_markers )
struct bu_list	*vhead;
struct model	*m;
int		poly_markers;
d458 1
a458 5
nmg_offset_eu_vert(base, eu, face_normal, tip)
point_t			base;
const struct edgeuse	*eu;
const vect_t		face_normal;
int			tip;
d531 1
a531 3
static void nmg_eu_coords(eu, base, tip60)
const struct edgeuse *eu;
point_t base, tip60;
d570 1
a570 3
static void nmg_eu_radial(eu, tip)
const struct edgeuse *eu;
point_t tip;
d627 1
a627 3
static void nmg_eu_next_base( eu, next_base)
const struct edgeuse	*eu;
point_t		next_base;
d653 1
a653 4
nmg_pl_v(fp, v, b)
FILE			*fp;
const struct vertex	*v;
long			*b;
d677 1
a677 5
nmg_pl_e(fp, e, b, red, green, blue)
FILE			*fp;
const struct edge	*e;
long			*b;
int			red, green, blue;
d715 1
a715 5
nmg_pl_eu(fp, eu, b, red, green, blue)
FILE			*fp;
const struct edgeuse	*eu;
long			*b;
int			red, green, blue;
d769 1
a769 5
nmg_pl_lu(fp, lu, b, red, green, blue)
FILE			*fp;
const struct loopuse	*lu;
long			*b;
int			red, green, blue;
d783 1
a783 5
nmg_pl_fu(fp, fu, b, red, green, blue)
FILE			*fp;
const struct faceuse	*fu;
long			*b;
int			red, green, blue;
d809 1
a809 3
nmg_pl_s(fp, s)
FILE			*fp;
const struct shell	*s;
d820 1
a820 4
nmg_pl_shell(fp, s, fancy)
FILE			*fp;
const struct shell	*s;
int			fancy;
d834 1
a834 3
nmg_pl_r(fp, r)
FILE			*fp;
const struct nmgregion	*r;
d848 1
a848 3
nmg_pl_m(fp, m)
FILE			*fp;
const struct model	*m;
d870 1
a870 4
nmg_vlblock_v(vbp, v, tab)
struct bn_vlblock		*vbp;
const struct vertex		*v;
long				*tab;
d901 1
a901 6
nmg_vlblock_e(vbp, e, tab, red, green, blue, fancy)
struct bn_vlblock	*vbp;
const struct edge	*e;
long			*tab;
int			red, green, blue;
int			fancy;
d943 1
a943 7
nmg_vlblock_eu(vbp, eu, tab, red, green, blue, fancy, loopnum)
struct bn_vlblock		*vbp;
const struct edgeuse		*eu;
long				*tab;
int				red, green, blue;
int				fancy;
int				loopnum;
d1064 1
a1064 9
nmg_vlblock_euleft( vh, eu, center, mat, xvec, yvec, len, tol )
struct bu_list			*vh;
const struct edgeuse		*eu;
const point_t			center;
const mat_t			mat;
const vect_t			xvec;
const vect_t			yvec;
double				len;
const struct bn_tol		*tol;
d1104 1
a1104 6
nmg_vlblock_around_eu(vbp, arg_eu, tab, fancy, tol )
struct bn_vlblock		*vbp;
const struct edgeuse		*arg_eu;
long				*tab;
int				fancy;
const struct bn_tol		*tol;
d1171 1
a1171 7
nmg_vlblock_lu(vbp, lu, tab, red, green, blue, fancy, loopnum)
struct bn_vlblock	*vbp;
const struct loopuse	*lu;
long			*tab;
int			red, green, blue;
int			fancy;
int	 		loopnum;
d1199 1
a1199 5
nmg_vlblock_fu(vbp, fu, tab, fancy)
struct bn_vlblock	*vbp;
const struct faceuse	*fu;
long			*tab;
int			fancy;
d1223 1
a1223 4
nmg_vlblock_s(vbp, s, fancy)
struct bn_vlblock	*vbp;
const struct shell	*s;
int			fancy;
d1278 1
a1278 4
nmg_vlblock_r(vbp, r, fancy)
struct bn_vlblock	*vbp;
const struct nmgregion	*r;
int			fancy;
d1294 1
a1294 4
nmg_vlblock_m(vbp, m, fancy)
struct bn_vlblock	*vbp;
const struct model	*m;
int			fancy;
d1317 1
a1317 6
nmg_pl_edges_in_2_shells(vbp, b, eu, fancy, tol)
struct bn_vlblock	*vbp;
long			*b;
const struct edgeuse	*eu;
int			fancy;
const struct bn_tol	*tol;
d1350 1
a1350 4
nmg_pl_isect(filename, s, tol)
const char		*filename;
const struct shell	*s;
const struct bn_tol	*tol;
d1413 1
a1413 4
nmg_pl_comb_fu( num1, num2, fu1 )
int	num1;
int	num2;
const struct faceuse	*fu1;
d1473 1
a1473 6
nmg_pl_2fu( str, unused, fu1, fu2, show_mates )
const char		*str;
int			unused;
const struct faceuse	*fu1;
const struct faceuse	*fu2;
int			show_mates;
d1562 1
a1562 4
show_broken_vu(vbp, vu, fancy)
struct bn_vlblock *vbp;
int fancy;
const struct vertexuse *vu;
d1617 1
a1617 4
show_broken_e(vbp, eu, fancy)
struct bn_vlblock *vbp;
int fancy;
const struct edgeuse *eu;
d1665 1
a1665 4
show_broken_eu(vbp, eu, fancy)
struct bn_vlblock *vbp;
int fancy;
const struct edgeuse *eu;
d1714 1
a1714 4
show_broken_lu(vbp, lu, fancy)
struct bn_vlblock *vbp;
int fancy;
const struct loopuse *lu;
d1762 1
a1762 4
show_broken_fu(vbp, fu, fancy)
struct bn_vlblock *vbp;
int fancy;
const struct faceuse *fu;
d1773 1
a1773 4
show_broken_s(vbp, s, fancy)
struct bn_vlblock *vbp;
const struct shell *s;
int fancy;
d1790 1
a1790 4
show_broken_r(vbp, r, fancy)
struct bn_vlblock *vbp;
const struct nmgregion *r;
int fancy;
d1800 1
a1800 4
show_broken_m(vbp, m, fancy)
struct bn_vlblock *vbp;
const struct model *m;
int fancy;
d1813 1
a1813 2
nmg_plot_sigstepalong(i)
int i;
d1825 1
a1825 6
nmg_show_broken_classifier_stuff(p, classlist, all_new, fancy, a_string)
long	*p;
long	*classlist[4];
int	all_new;
int	fancy;
const char	*a_string;
d1964 1
a1964 2
nmg_face_plot( fu )
const struct faceuse	*fu;
d2024 1
a2024 2
nmg_2face_plot( fu1, fu2 )
const struct faceuse	*fu1, *fu2;
d2070 1
a2070 3
nmg_face_lu_plot( lu, vu1, vu2 )
const struct loopuse		*lu;
const struct vertexuse		*vu1, *vu2;
d2119 1
a2119 5
nmg_plot_lu_ray( lu, vu1, vu2, left )
const struct loopuse		*lu;
const struct vertexuse		*vu1;
const struct vertexuse		*vu2;
const vect_t			left;
d2172 1
a2172 5
nmg_plot_ray_face(fname, pt, dir, fu)
const char *fname;
point_t pt;
const vect_t dir;
const struct faceuse *fu;
d2211 1
a2211 4
nmg_plot_lu_around_eu( prefix, eu, tol )
const char		*prefix;
const struct edgeuse	*eu;
const struct bn_tol	*tol;
d2264 4
a2267 4
nmg_snurb_to_vlist( vhead, fg, n_interior )
struct bu_list			*vhead;
const struct face_g_snurb	*fg;
int				n_interior;	/* typ. 10 */
d2368 5
a2372 5
nmg_cnurb_to_vlist( vhead, eu, n_interior, cmd )
struct bu_list			*vhead;
const struct edgeuse		*eu;
int				n_interior;	/* typ. 10 */
int				cmd;		/* BN_VLIST_LINE_DRAW, etc */
@


11.29
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1993 by the United States Army
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.27 2001/04/05 19:35:35 morrison Exp $ (ARL)";
@


11.29.4.1
log
@sync to HEAD...
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_plot.c,v 11.30 2004/02/02 17:39:24 morrison Exp $ (ARL)";
@


11.29.10.1
log
@merge from HEAD
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.30 2004/02/02 17:39:24 morrison Exp $ (ARL)";
@


11.29.10.2
log
@merge from head
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.29.10.1 2004/02/12 18:37:45 erikg Exp $ (ARL)";
@


11.29.2.1
log
@Initial ANSIfication
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.29 2002/08/20 17:08:05 jra Exp $ (ARL)";
d73 3
a75 1
nmg_vu_to_vlist(struct bu_list *vhead, const struct vertexuse *vu)
d98 3
a100 1
nmg_eu_to_vlist(struct bu_list *vhead, const struct bu_list *eu_hd)
d145 5
a149 5
nmg_lu_to_vlist(struct bu_list *vhead, const struct loopuse *lu, int poly_markers, const vectp_t normal)
              		       
                    	    
   			             		/* bit vector! */
             		       
d305 4
a308 1
nmg_snurb_fu_to_vlist(struct bu_list *vhead, const struct faceuse *fu, int poly_markers)
d360 4
a363 1
nmg_s_to_vlist(struct bu_list *vhead, const struct shell *s, int poly_markers)
d421 4
a424 1
nmg_r_to_vlist(struct bu_list *vhead, const struct nmgregion *r, int poly_markers)
d439 4
a442 1
nmg_m_to_vlist(struct bu_list *vhead, struct model *m, int poly_markers)
d474 5
a478 1
nmg_offset_eu_vert(fastf_t *base, const struct edgeuse *eu, const fastf_t *face_normal, int tip)
d551 3
a553 1
static void nmg_eu_coords(const struct edgeuse *eu, fastf_t *base, fastf_t *tip60)
d592 3
a594 1
static void nmg_eu_radial(const struct edgeuse *eu, fastf_t *tip)
d651 3
a653 1
static void nmg_eu_next_base(const struct edgeuse *eu, fastf_t *next_base)
d679 4
a682 1
nmg_pl_v(FILE *fp, const struct vertex *v, long int *b)
d706 5
a710 1
nmg_pl_e(FILE *fp, const struct edge *e, long int *b, int red, int green, int blue)
d748 5
a752 1
nmg_pl_eu(FILE *fp, const struct edgeuse *eu, long int *b, int red, int green, int blue)
d806 5
a810 1
nmg_pl_lu(FILE *fp, const struct loopuse *lu, long int *b, int red, int green, int blue)
d824 5
a828 1
nmg_pl_fu(FILE *fp, const struct faceuse *fu, long int *b, int red, int green, int blue)
d854 3
a856 1
nmg_pl_s(FILE *fp, const struct shell *s)
d867 4
a870 1
nmg_pl_shell(FILE *fp, const struct shell *s, int fancy)
d884 3
a886 1
nmg_pl_r(FILE *fp, const struct nmgregion *r)
d900 3
a902 1
nmg_pl_m(FILE *fp, const struct model *m)
d924 4
a927 1
nmg_vlblock_v(struct bn_vlblock *vbp, const struct vertex *v, long int *tab)
d958 6
a963 1
nmg_vlblock_e(struct bn_vlblock *vbp, const struct edge *e, long int *tab, int red, int green, int blue, int fancy)
d1005 7
a1011 1
nmg_vlblock_eu(struct bn_vlblock *vbp, const struct edgeuse *eu, long int *tab, int red, int green, int blue, int fancy, int loopnum)
d1132 9
a1140 1
nmg_vlblock_euleft(struct bu_list *vh, const struct edgeuse *eu, const fastf_t *center, const fastf_t *mat, const fastf_t *xvec, const fastf_t *yvec, double len, const struct bn_tol *tol)
d1180 6
a1185 1
nmg_vlblock_around_eu(struct bn_vlblock *vbp, const struct edgeuse *arg_eu, long int *tab, int fancy, const struct bn_tol *tol)
d1252 7
a1258 1
nmg_vlblock_lu(struct bn_vlblock *vbp, const struct loopuse *lu, long int *tab, int red, int green, int blue, int fancy, int loopnum)
d1286 5
a1290 1
nmg_vlblock_fu(struct bn_vlblock *vbp, const struct faceuse *fu, long int *tab, int fancy)
d1314 4
a1317 1
nmg_vlblock_s(struct bn_vlblock *vbp, const struct shell *s, int fancy)
d1372 4
a1375 1
nmg_vlblock_r(struct bn_vlblock *vbp, const struct nmgregion *r, int fancy)
d1391 4
a1394 1
nmg_vlblock_m(struct bn_vlblock *vbp, const struct model *m, int fancy)
d1417 6
a1422 1
nmg_pl_edges_in_2_shells(struct bn_vlblock *vbp, long int *b, const struct edgeuse *eu, int fancy, const struct bn_tol *tol)
d1455 4
a1458 1
nmg_pl_isect(const char *filename, const struct shell *s, const struct bn_tol *tol)
d1521 4
a1524 1
nmg_pl_comb_fu(int num1, int num2, const struct faceuse *fu1)
d1584 6
a1589 1
nmg_pl_2fu(const char *str, int unused, const struct faceuse *fu1, const struct faceuse *fu2, int show_mates)
d1678 4
a1681 1
show_broken_vu(struct bn_vlblock *vbp, const struct vertexuse *vu, int fancy)
d1736 4
a1739 1
show_broken_e(struct bn_vlblock *vbp, const struct edgeuse *eu, int fancy)
d1787 4
a1790 1
show_broken_eu(struct bn_vlblock *vbp, const struct edgeuse *eu, int fancy)
d1839 4
a1842 1
show_broken_lu(struct bn_vlblock *vbp, const struct loopuse *lu, int fancy)
d1890 4
a1893 1
show_broken_fu(struct bn_vlblock *vbp, const struct faceuse *fu, int fancy)
d1904 4
a1907 1
show_broken_s(struct bn_vlblock *vbp, const struct shell *s, int fancy)
d1924 4
a1927 1
show_broken_r(struct bn_vlblock *vbp, const struct nmgregion *r, int fancy)
d1937 4
a1940 1
show_broken_m(struct bn_vlblock *vbp, const struct model *m, int fancy)
d1953 2
a1954 1
nmg_plot_sigstepalong(int i)
d1966 6
a1971 1
nmg_show_broken_classifier_stuff(long int *p, long int **classlist, int all_new, int fancy, const char *a_string)
d2110 2
a2111 1
nmg_face_plot(const struct faceuse *fu)
d2171 2
a2172 1
nmg_2face_plot(const struct faceuse *fu1, const struct faceuse *fu2)
d2218 3
a2220 1
nmg_face_lu_plot(const struct loopuse *lu, const struct vertexuse *vu1, const struct vertexuse *vu2)
d2269 5
a2273 1
nmg_plot_lu_ray(const struct loopuse *lu, const struct vertexuse *vu1, const struct vertexuse *vu2, const fastf_t *left)
d2326 5
a2330 1
nmg_plot_ray_face(const char *fname, fastf_t *pt, const fastf_t *dir, const struct faceuse *fu)
d2369 4
a2372 1
nmg_plot_lu_around_eu(const char *prefix, const struct edgeuse *eu, const struct bn_tol *tol)
d2425 4
a2428 4
nmg_snurb_to_vlist(struct bu_list *vhead, const struct face_g_snurb *fg, int n_interior)
              			       
                         	    
   				           	/* typ. 10 */
d2529 5
a2533 5
nmg_cnurb_to_vlist(struct bu_list *vhead, const struct edgeuse *eu, int n_interior, int cmd)
              			       
                    		    
   				           	/* typ. 10 */
   				    		/* BN_VLIST_LINE_DRAW, etc */
@


11.29.2.2
log
@sync branch with HEAD
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.28
log
@Converted from K&R to ANSI C - RFH
@
text
@d73 3
a75 1
nmg_vu_to_vlist(struct bu_list *vhead, const struct vertexuse *vu)
d98 3
a100 1
nmg_eu_to_vlist(struct bu_list *vhead, const struct bu_list *eu_hd)
d145 5
a149 5
nmg_lu_to_vlist(struct bu_list *vhead, const struct loopuse *lu, int poly_markers, const vectp_t normal)
              		       
                    	    
   			             		/* bit vector! */
             		       
d305 4
a308 1
nmg_snurb_fu_to_vlist(struct bu_list *vhead, const struct faceuse *fu, int poly_markers)
d360 4
a363 1
nmg_s_to_vlist(struct bu_list *vhead, const struct shell *s, int poly_markers)
d421 4
a424 1
nmg_r_to_vlist(struct bu_list *vhead, const struct nmgregion *r, int poly_markers)
d439 4
a442 1
nmg_m_to_vlist(struct bu_list *vhead, struct model *m, int poly_markers)
d474 5
a478 1
nmg_offset_eu_vert(fastf_t *base, const struct edgeuse *eu, const fastf_t *face_normal, int tip)
d551 3
a553 1
static void nmg_eu_coords(const struct edgeuse *eu, fastf_t *base, fastf_t *tip60)
d592 3
a594 1
static void nmg_eu_radial(const struct edgeuse *eu, fastf_t *tip)
d651 3
a653 1
static void nmg_eu_next_base(const struct edgeuse *eu, fastf_t *next_base)
d679 4
a682 1
nmg_pl_v(FILE *fp, const struct vertex *v, long int *b)
d706 5
a710 1
nmg_pl_e(FILE *fp, const struct edge *e, long int *b, int red, int green, int blue)
d748 5
a752 1
nmg_pl_eu(FILE *fp, const struct edgeuse *eu, long int *b, int red, int green, int blue)
d806 5
a810 1
nmg_pl_lu(FILE *fp, const struct loopuse *lu, long int *b, int red, int green, int blue)
d824 5
a828 1
nmg_pl_fu(FILE *fp, const struct faceuse *fu, long int *b, int red, int green, int blue)
d854 3
a856 1
nmg_pl_s(FILE *fp, const struct shell *s)
d867 4
a870 1
nmg_pl_shell(FILE *fp, const struct shell *s, int fancy)
d884 3
a886 1
nmg_pl_r(FILE *fp, const struct nmgregion *r)
d900 3
a902 1
nmg_pl_m(FILE *fp, const struct model *m)
d924 4
a927 1
nmg_vlblock_v(struct bn_vlblock *vbp, const struct vertex *v, long int *tab)
d958 6
a963 1
nmg_vlblock_e(struct bn_vlblock *vbp, const struct edge *e, long int *tab, int red, int green, int blue, int fancy)
d1005 7
a1011 1
nmg_vlblock_eu(struct bn_vlblock *vbp, const struct edgeuse *eu, long int *tab, int red, int green, int blue, int fancy, int loopnum)
d1132 9
a1140 1
nmg_vlblock_euleft(struct bu_list *vh, const struct edgeuse *eu, const fastf_t *center, const fastf_t *mat, const fastf_t *xvec, const fastf_t *yvec, double len, const struct bn_tol *tol)
d1180 6
a1185 1
nmg_vlblock_around_eu(struct bn_vlblock *vbp, const struct edgeuse *arg_eu, long int *tab, int fancy, const struct bn_tol *tol)
d1252 7
a1258 1
nmg_vlblock_lu(struct bn_vlblock *vbp, const struct loopuse *lu, long int *tab, int red, int green, int blue, int fancy, int loopnum)
d1286 5
a1290 1
nmg_vlblock_fu(struct bn_vlblock *vbp, const struct faceuse *fu, long int *tab, int fancy)
d1314 4
a1317 1
nmg_vlblock_s(struct bn_vlblock *vbp, const struct shell *s, int fancy)
d1372 4
a1375 1
nmg_vlblock_r(struct bn_vlblock *vbp, const struct nmgregion *r, int fancy)
d1391 4
a1394 1
nmg_vlblock_m(struct bn_vlblock *vbp, const struct model *m, int fancy)
d1417 6
a1422 1
nmg_pl_edges_in_2_shells(struct bn_vlblock *vbp, long int *b, const struct edgeuse *eu, int fancy, const struct bn_tol *tol)
d1455 4
a1458 1
nmg_pl_isect(const char *filename, const struct shell *s, const struct bn_tol *tol)
d1521 4
a1524 1
nmg_pl_comb_fu(int num1, int num2, const struct faceuse *fu1)
d1584 6
a1589 1
nmg_pl_2fu(const char *str, int unused, const struct faceuse *fu1, const struct faceuse *fu2, int show_mates)
d1678 4
a1681 1
show_broken_vu(struct bn_vlblock *vbp, const struct vertexuse *vu, int fancy)
d1736 4
a1739 1
show_broken_e(struct bn_vlblock *vbp, const struct edgeuse *eu, int fancy)
d1787 4
a1790 1
show_broken_eu(struct bn_vlblock *vbp, const struct edgeuse *eu, int fancy)
d1839 4
a1842 1
show_broken_lu(struct bn_vlblock *vbp, const struct loopuse *lu, int fancy)
d1890 4
a1893 1
show_broken_fu(struct bn_vlblock *vbp, const struct faceuse *fu, int fancy)
d1904 4
a1907 1
show_broken_s(struct bn_vlblock *vbp, const struct shell *s, int fancy)
d1924 4
a1927 1
show_broken_r(struct bn_vlblock *vbp, const struct nmgregion *r, int fancy)
d1937 4
a1940 1
show_broken_m(struct bn_vlblock *vbp, const struct model *m, int fancy)
d1953 2
a1954 1
nmg_plot_sigstepalong(int i)
d1966 6
a1971 1
nmg_show_broken_classifier_stuff(long int *p, long int **classlist, int all_new, int fancy, const char *a_string)
d2110 2
a2111 1
nmg_face_plot(const struct faceuse *fu)
d2171 2
a2172 1
nmg_2face_plot(const struct faceuse *fu1, const struct faceuse *fu2)
d2218 3
a2220 1
nmg_face_lu_plot(const struct loopuse *lu, const struct vertexuse *vu1, const struct vertexuse *vu2)
d2269 5
a2273 1
nmg_plot_lu_ray(const struct loopuse *lu, const struct vertexuse *vu1, const struct vertexuse *vu2, const fastf_t *left)
d2326 5
a2330 1
nmg_plot_ray_face(const char *fname, fastf_t *pt, const fastf_t *dir, const struct faceuse *fu)
d2369 4
a2372 1
nmg_plot_lu_around_eu(const char *prefix, const struct edgeuse *eu, const struct bn_tol *tol)
d2425 4
a2428 4
nmg_snurb_to_vlist(struct bu_list *vhead, const struct face_g_snurb *fg, int n_interior)
              			       
                         	    
   				           	/* typ. 10 */
d2529 5
a2533 5
nmg_cnurb_to_vlist(struct bu_list *vhead, const struct edgeuse *eu, int n_interior, int cmd)
              			       
                    		    
   				           	/* typ. 10 */
   				    		/* BN_VLIST_LINE_DRAW, etc */
@


11.27
log
@updated SIGNED to signed
updated CONST to const
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.26 2001/03/31 01:57:12 morrison Exp $ (ARL)";
d73 1
a73 3
nmg_vu_to_vlist( vhead, vu )
struct bu_list		*vhead;
const struct vertexuse	*vu;
d96 1
a96 3
nmg_eu_to_vlist( vhead, eu_hd )
struct bu_list		*vhead;
const struct bu_list	*eu_hd;
d141 5
a145 5
nmg_lu_to_vlist( vhead, lu, poly_markers, normal )
struct bu_list		*vhead;
const struct loopuse	*lu;
int			poly_markers;		/* bit vector! */
const vectp_t		normal;
d301 1
a301 4
nmg_snurb_fu_to_vlist( vhead, fu, poly_markers )
struct bu_list		*vhead;
const struct faceuse	*fu;
int			poly_markers;
d353 1
a353 4
nmg_s_to_vlist( vhead, s, poly_markers )
struct bu_list		*vhead;
const struct shell	*s;
int			poly_markers;
d411 1
a411 4
nmg_r_to_vlist( vhead, r, poly_markers )
struct bu_list		*vhead;
const struct nmgregion	*r;
int			poly_markers;
d426 1
a426 4
nmg_m_to_vlist( vhead, m, poly_markers )
struct bu_list	*vhead;
struct model	*m;
int		poly_markers;
d458 1
a458 5
nmg_offset_eu_vert(base, eu, face_normal, tip)
point_t			base;
const struct edgeuse	*eu;
const vect_t		face_normal;
int			tip;
d531 1
a531 3
static void nmg_eu_coords(eu, base, tip60)
const struct edgeuse *eu;
point_t base, tip60;
d570 1
a570 3
static void nmg_eu_radial(eu, tip)
const struct edgeuse *eu;
point_t tip;
d627 1
a627 3
static void nmg_eu_next_base( eu, next_base)
const struct edgeuse	*eu;
point_t		next_base;
d653 1
a653 4
nmg_pl_v(fp, v, b)
FILE			*fp;
const struct vertex	*v;
long			*b;
d677 1
a677 5
nmg_pl_e(fp, e, b, red, green, blue)
FILE			*fp;
const struct edge	*e;
long			*b;
int			red, green, blue;
d715 1
a715 5
nmg_pl_eu(fp, eu, b, red, green, blue)
FILE			*fp;
const struct edgeuse	*eu;
long			*b;
int			red, green, blue;
d769 1
a769 5
nmg_pl_lu(fp, lu, b, red, green, blue)
FILE			*fp;
const struct loopuse	*lu;
long			*b;
int			red, green, blue;
d783 1
a783 5
nmg_pl_fu(fp, fu, b, red, green, blue)
FILE			*fp;
const struct faceuse	*fu;
long			*b;
int			red, green, blue;
d809 1
a809 3
nmg_pl_s(fp, s)
FILE			*fp;
const struct shell	*s;
d820 1
a820 4
nmg_pl_shell(fp, s, fancy)
FILE			*fp;
const struct shell	*s;
int			fancy;
d834 1
a834 3
nmg_pl_r(fp, r)
FILE			*fp;
const struct nmgregion	*r;
d848 1
a848 3
nmg_pl_m(fp, m)
FILE			*fp;
const struct model	*m;
d870 1
a870 4
nmg_vlblock_v(vbp, v, tab)
struct bn_vlblock		*vbp;
const struct vertex		*v;
long				*tab;
d901 1
a901 6
nmg_vlblock_e(vbp, e, tab, red, green, blue, fancy)
struct bn_vlblock	*vbp;
const struct edge	*e;
long			*tab;
int			red, green, blue;
int			fancy;
d943 1
a943 7
nmg_vlblock_eu(vbp, eu, tab, red, green, blue, fancy, loopnum)
struct bn_vlblock		*vbp;
const struct edgeuse		*eu;
long				*tab;
int				red, green, blue;
int				fancy;
int				loopnum;
d1064 1
a1064 9
nmg_vlblock_euleft( vh, eu, center, mat, xvec, yvec, len, tol )
struct bu_list			*vh;
const struct edgeuse		*eu;
const point_t			center;
const mat_t			mat;
const vect_t			xvec;
const vect_t			yvec;
double				len;
const struct bn_tol		*tol;
d1104 1
a1104 6
nmg_vlblock_around_eu(vbp, arg_eu, tab, fancy, tol )
struct bn_vlblock		*vbp;
const struct edgeuse		*arg_eu;
long				*tab;
int				fancy;
const struct bn_tol		*tol;
d1171 1
a1171 7
nmg_vlblock_lu(vbp, lu, tab, red, green, blue, fancy, loopnum)
struct bn_vlblock	*vbp;
const struct loopuse	*lu;
long			*tab;
int			red, green, blue;
int			fancy;
int	 		loopnum;
d1199 1
a1199 5
nmg_vlblock_fu(vbp, fu, tab, fancy)
struct bn_vlblock	*vbp;
const struct faceuse	*fu;
long			*tab;
int			fancy;
d1223 1
a1223 4
nmg_vlblock_s(vbp, s, fancy)
struct bn_vlblock	*vbp;
const struct shell	*s;
int			fancy;
d1278 1
a1278 4
nmg_vlblock_r(vbp, r, fancy)
struct bn_vlblock	*vbp;
const struct nmgregion	*r;
int			fancy;
d1294 1
a1294 4
nmg_vlblock_m(vbp, m, fancy)
struct bn_vlblock	*vbp;
const struct model	*m;
int			fancy;
d1317 1
a1317 6
nmg_pl_edges_in_2_shells(vbp, b, eu, fancy, tol)
struct bn_vlblock	*vbp;
long			*b;
const struct edgeuse	*eu;
int			fancy;
const struct bn_tol	*tol;
d1350 1
a1350 4
nmg_pl_isect(filename, s, tol)
const char		*filename;
const struct shell	*s;
const struct bn_tol	*tol;
d1413 1
a1413 4
nmg_pl_comb_fu( num1, num2, fu1 )
int	num1;
int	num2;
const struct faceuse	*fu1;
d1473 1
a1473 6
nmg_pl_2fu( str, unused, fu1, fu2, show_mates )
const char		*str;
int			unused;
const struct faceuse	*fu1;
const struct faceuse	*fu2;
int			show_mates;
d1562 1
a1562 4
show_broken_vu(vbp, vu, fancy)
struct bn_vlblock *vbp;
int fancy;
const struct vertexuse *vu;
d1617 1
a1617 4
show_broken_e(vbp, eu, fancy)
struct bn_vlblock *vbp;
int fancy;
const struct edgeuse *eu;
d1665 1
a1665 4
show_broken_eu(vbp, eu, fancy)
struct bn_vlblock *vbp;
int fancy;
const struct edgeuse *eu;
d1714 1
a1714 4
show_broken_lu(vbp, lu, fancy)
struct bn_vlblock *vbp;
int fancy;
const struct loopuse *lu;
d1762 1
a1762 4
show_broken_fu(vbp, fu, fancy)
struct bn_vlblock *vbp;
int fancy;
const struct faceuse *fu;
d1773 1
a1773 4
show_broken_s(vbp, s, fancy)
struct bn_vlblock *vbp;
const struct shell *s;
int fancy;
d1790 1
a1790 4
show_broken_r(vbp, r, fancy)
struct bn_vlblock *vbp;
const struct nmgregion *r;
int fancy;
d1800 1
a1800 4
show_broken_m(vbp, m, fancy)
struct bn_vlblock *vbp;
const struct model *m;
int fancy;
d1813 1
a1813 2
nmg_plot_sigstepalong(i)
int i;
d1825 1
a1825 6
nmg_show_broken_classifier_stuff(p, classlist, all_new, fancy, a_string)
long	*p;
long	*classlist[4];
int	all_new;
int	fancy;
const char	*a_string;
d1964 1
a1964 2
nmg_face_plot( fu )
const struct faceuse	*fu;
d2024 1
a2024 2
nmg_2face_plot( fu1, fu2 )
const struct faceuse	*fu1, *fu2;
d2070 1
a2070 3
nmg_face_lu_plot( lu, vu1, vu2 )
const struct loopuse		*lu;
const struct vertexuse		*vu1, *vu2;
d2119 1
a2119 5
nmg_plot_lu_ray( lu, vu1, vu2, left )
const struct loopuse		*lu;
const struct vertexuse		*vu1;
const struct vertexuse		*vu2;
const vect_t			left;
d2172 1
a2172 5
nmg_plot_ray_face(fname, pt, dir, fu)
const char *fname;
point_t pt;
const vect_t dir;
const struct faceuse *fu;
d2211 1
a2211 4
nmg_plot_lu_around_eu( prefix, eu, tol )
const char		*prefix;
const struct edgeuse	*eu;
const struct bn_tol	*tol;
d2264 4
a2267 4
nmg_snurb_to_vlist( vhead, fg, n_interior )
struct bu_list			*vhead;
const struct face_g_snurb	*fg;
int				n_interior;	/* typ. 10 */
d2368 5
a2372 5
nmg_cnurb_to_vlist( vhead, eu, n_interior, cmd )
struct bu_list			*vhead;
const struct edgeuse		*eu;
int				n_interior;	/* typ. 10 */
int				cmd;		/* BN_VLIST_LINE_DRAW, etc */
@


11.26
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.25 2000/10/24 00:02:25 butler Exp $ (ARL)";
d75 1
a75 1
CONST struct vertexuse	*vu;
d100 1
a100 1
CONST struct bu_list	*eu_hd;
d147 1
a147 1
CONST struct loopuse	*lu;
d149 1
a149 1
CONST vectp_t		normal;
d151 6
a156 6
	CONST struct edgeuse		*eu;
	CONST struct vertexuse		*vu;
	CONST struct vertex		*v;
	register CONST struct vertex_g	*vg;
	CONST struct vertex_g		*first_vg;
	CONST struct vertexuse		*first_vu;
d307 1
a307 1
CONST struct faceuse	*fu;
d362 1
a362 1
CONST struct shell	*s;
d423 1
a423 1
CONST struct nmgregion	*r;
d476 2
a477 2
CONST struct edgeuse	*eu;
CONST vect_t		face_normal;
d481 1
a481 1
	CONST struct edgeuse	*this_eu;
d552 1
a552 1
CONST struct edgeuse *eu;
d593 1
a593 1
CONST struct edgeuse *eu;
d616 1
a616 1
CONST struct edgeuse	*eu;
d652 1
a652 1
CONST struct edgeuse	*eu;
d681 1
a681 1
CONST struct vertex	*v;
d708 1
a708 1
CONST struct edge	*e;
d750 1
a750 1
CONST struct edgeuse	*eu;
d808 1
a808 1
CONST struct loopuse	*lu;
d826 1
a826 1
CONST struct faceuse	*fu;
d856 1
a856 1
CONST struct shell	*s;
d869 1
a869 1
CONST struct shell	*s;
d886 1
a886 1
CONST struct nmgregion	*r;
d902 1
a902 1
CONST struct model	*m;
d926 1
a926 1
CONST struct vertex		*v;
d960 1
a960 1
CONST struct edge	*e;
d1007 1
a1007 1
CONST struct edgeuse		*eu;
d1134 5
a1138 5
CONST struct edgeuse		*eu;
CONST point_t			center;
CONST mat_t			mat;
CONST vect_t			xvec;
CONST vect_t			yvec;
d1140 1
a1140 1
CONST struct bn_tol		*tol;
d1182 1
a1182 1
CONST struct edgeuse		*arg_eu;
d1185 1
a1185 1
CONST struct bn_tol		*tol;
d1187 2
a1188 2
	CONST struct edgeuse		*orig_eu;
	register CONST struct edgeuse	*eu;
d1254 1
a1254 1
CONST struct loopuse	*lu;
d1288 1
a1288 1
CONST struct faceuse	*fu;
d1316 1
a1316 1
CONST struct shell	*s;
d1374 1
a1374 1
CONST struct nmgregion	*r;
d1393 1
a1393 1
CONST struct model	*m;
d1420 1
a1420 1
CONST struct edgeuse	*eu;
d1422 1
a1422 1
CONST struct bn_tol	*tol;
d1424 2
a1425 2
	CONST struct edgeuse	*eur;
	CONST struct shell	*s;
d1456 3
a1458 3
CONST char		*filename;
CONST struct shell	*s;
CONST struct bn_tol	*tol;
d1524 1
a1524 1
CONST struct faceuse	*fu1;
d1585 1
a1585 1
CONST char		*str;
d1587 2
a1588 2
CONST struct faceuse	*fu1;
CONST struct faceuse	*fu2;
d1681 1
a1681 1
CONST struct vertexuse *vu;
d1739 1
a1739 1
CONST struct edgeuse *eu;
d1790 1
a1790 1
CONST struct edgeuse *eu;
d1842 1
a1842 1
CONST struct loopuse *lu;
d1893 1
a1893 1
CONST struct faceuse *fu;
d1906 1
a1906 1
CONST struct shell *s;
d1926 1
a1926 1
CONST struct nmgregion *r;
d1939 1
a1939 1
CONST struct model *m;
d1971 1
a1971 1
CONST char	*a_string;
d2111 1
a2111 1
CONST struct faceuse	*fu;
d2172 1
a2172 1
CONST struct faceuse	*fu1, *fu2;
d2219 2
a2220 2
CONST struct loopuse		*lu;
CONST struct vertexuse		*vu1, *vu2;
d2270 4
a2273 4
CONST struct loopuse		*lu;
CONST struct vertexuse		*vu1;
CONST struct vertexuse		*vu2;
CONST vect_t			left;
d2327 1
a2327 1
CONST char *fname;
d2329 2
a2330 2
CONST vect_t dir;
CONST struct faceuse *fu;
d2370 3
a2372 3
CONST char		*prefix;
CONST struct edgeuse	*eu;
CONST struct bn_tol	*tol;
d2379 1
a2379 1
	CONST struct edgeuse	*eur;
d2427 1
a2427 1
CONST struct face_g_snurb	*fg;
d2531 1
a2531 1
CONST struct edgeuse		*eu;
d2535 2
a2536 2
	CONST struct edge_g_cnurb	*eg;
	CONST struct faceuse	*fu;
d2540 1
a2540 1
	CONST struct edge_g_cnurb	*c;
d2595 1
a2595 1
		CONST struct face_g_snurb	*s;
@


11.25
log
@Initializations to eliminate compiler warnings
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.24 2000/08/21 02:02:33 butler Exp $ (ARL)";
d944 1
a944 1
		bn_mat_idn(mat);
d1210 1
a1210 1
		bn_mat_zero( mat );
@


11.24
log
@Massive compilation warnings eliminated
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.23 2000/07/10 23:01:45 mike Exp $ (ARL)";
d2538 1
a2538 1
	register fastf_t	*vp;
@


11.23
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.22 2000/04/01 03:30:40 mike Exp $ (ARL)";
d43 1
d1598 1
a1598 1
	if( rt_g.NMG_debug & (DEBUG_PLOTEM|DEBUG_PL_ANIM) == 0 )  return;
d2058 1
a2058 1
	default: fprintf(stderr, "Unknown magic number %ld %0lx %lu %0lx\n", *p, *p, p, p);
d2092 1
a2092 1
		if( fp = fopen(buf, "w") )  {
d2122 1
a2122 1
	if( rt_g.NMG_debug & (DEBUG_PLOTEM|DEBUG_PL_ANIM) == 0 )  return;
@


11.22
log
@
Added externs for nmg_plot.c to raytrace.h
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.21 1999/11/24 21:44:30 mike Exp $ (ARL)";
@


11.21
log
@
Removed includes of compat header files rtstring.h and rtlist.h
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.20 1999/06/03 01:57:01 mike Exp $ (ARL)";
d1966 1
a1967 1
long	*p;
d1969 1
d2270 2
a2271 1
CONST struct vertexuse		*vu1, *vu2;
@


11.20
log
@
sed4 oops fixes
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.19 1999/06/03 01:39:15 mike Exp $ (ARL)";
a50 1
#include "rtstring.h"
@


11.19
log
@
sed4
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.18 1999/05/27 21:59:04 mike Exp $ (ARL)";
d817 1
a817 1
	bn_vlblock_free(vbp);
d844 1
a844 1
	bn_vlblock_free(vbp);
d863 1
a863 1
	bn_vlblock_free(vbp);
d877 1
a877 1
	bn_vlblock_free(vbp);
d893 1
a893 1
	bn_vlblock_free(vbp);
d909 1
a909 1
	bn_vlblock_free(vbp);
d1508 1
a1508 1
	bn_vlblock_free(vbp);
d1572 1
a1572 1
	bn_vlblock_free(vbp);
d1637 1
a1637 1
	bn_vlblock_free(vbp);
d1983 1
a1983 1
		bn_vlblock_free(vbp);
d2097 1
a2097 1
		bn_vlblock_free(vbp);
d2159 1
a2159 1
	bn_vlblock_free(vbp);
d2206 1
a2206 1
	bn_vlblock_free(vbp);
d2412 1
a2412 1
	bn_vlblock_free(vbp);
@


11.18
log
@
font.c moved from librt to libbn
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.17 1998/09/14 15:59:17 bparker Exp $ (ARL)";
d87 2
a88 2
		RT_ADD_VLIST( vhead, vg->coord, RT_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vhead, vg->coord, RT_VLIST_LINE_DRAW );
d132 2
a133 2
		RT_ADD_VLIST( vhead, vg->coord, RT_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vhead, vgmate->coord, RT_VLIST_LINE_DRAW );
d140 1
a140 1
 *  Plot a single loopuse into a rt_vlist chain headed by vhead.
d195 1
a195 1
				RT_ADD_VLIST( vhead, normal, RT_VLIST_POLY_START );
d200 1
a200 1
						RT_VLIST_POLY_VERTNORM );
d202 1
a202 1
				RT_ADD_VLIST( vhead, vg->coord, RT_VLIST_POLY_MOVE );
d205 1
a205 1
				RT_ADD_VLIST( vhead, vg->coord, RT_VLIST_LINE_MOVE );
d216 1
a216 1
						RT_VLIST_POLY_VERTNORM );
d218 1
a218 1
				RT_ADD_VLIST( vhead, vg->coord, RT_VLIST_POLY_DRAW );
d221 1
a221 1
				RT_ADD_VLIST( vhead, vg->coord, RT_VLIST_LINE_DRAW );
d234 1
a234 1
				RT_VLIST_POLY_DRAW : RT_VLIST_LINE_DRAW );
d245 1
a245 1
					RT_VLIST_POLY_VERTNORM );
d247 1
a247 1
			RT_ADD_VLIST( vhead, first_vg->coord, RT_VLIST_POLY_END );
d250 1
a250 1
			RT_ADD_VLIST( vhead, first_vg->coord, RT_VLIST_LINE_DRAW );
d278 1
a278 1
			RT_ADD_VLIST( vhead, centroid, RT_VLIST_LINE_MOVE );
d280 1
a280 1
			RT_ADD_VLIST( vhead, tip, RT_VLIST_LINE_DRAW );
d294 1
a294 1
			RT_ADD_VLIST( vhead, vg->coord, RT_VLIST_LINE_MOVE );
d296 1
a296 1
			RT_ADD_VLIST( vhead, tip, RT_VLIST_LINE_DRAW );
d343 1
a343 1
		RT_ADD_VLIST( vhead, mid_srf, RT_VLIST_LINE_MOVE );
d345 1
a345 1
		RT_ADD_VLIST( vhead, tip, RT_VLIST_LINE_DRAW );
d812 1
a812 1
	struct rt_vlblock	*vbp;
d817 1
a817 1
	rt_vlblock_free(vbp);
d831 1
a831 1
	struct rt_vlblock	*vbp;
d844 1
a844 1
	rt_vlblock_free(vbp);
d858 1
a858 1
	struct rt_vlblock	*vbp;
d863 1
a863 1
	rt_vlblock_free(vbp);
d872 1
a872 1
	struct rt_vlblock	*vbp;
d877 1
a877 1
	rt_vlblock_free(vbp);
d888 1
a888 1
	struct rt_vlblock	*vbp;
d893 1
a893 1
	rt_vlblock_free(vbp);
d904 1
a904 1
	struct rt_vlblock	*vbp;
d909 1
a909 1
	rt_vlblock_free(vbp);
d925 1
a925 1
struct rt_vlblock		*vbp;
d932 1
a932 1
	RT_CK_VLBLOCK(vbp);
d944 1
a944 1
		mat_idn(mat);
d950 2
a951 2
	RT_ADD_VLIST( vh, p, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vh, p, RT_VLIST_LINE_DRAW );
d959 1
a959 1
struct rt_vlblock	*vbp;
d970 1
a970 1
	RT_CK_VLBLOCK(vbp);
d994 2
a995 2
	RT_ADD_VLIST( vh, end0, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vh, end1, RT_VLIST_LINE_DRAW );
d1006 1
a1006 1
struct rt_vlblock		*vbp;
d1018 1
a1018 1
	RT_CK_VLBLOCK(vbp);
d1092 2
a1093 2
		RT_ADD_VLIST( vh, base, RT_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vh, tip, RT_VLIST_LINE_DRAW );
d1104 2
a1105 2
		RT_ADD_VLIST( vh, tip, RT_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vh, radial_tip, RT_VLIST_LINE_DRAW );
d1118 2
a1119 2
		RT_ADD_VLIST( vh, tip, RT_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vh, next_base, RT_VLIST_LINE_DRAW );
d1158 2
a1159 2
	RT_ADD_VLIST( vh, center, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vh, tip, RT_VLIST_LINE_DRAW );
d1181 1
a1181 1
struct rt_vlblock		*vbp;
d1195 1
a1195 1
	RT_CK_VLBLOCK(vbp);
d1210 1
a1210 1
		mat_zero( mat );
d1253 1
a1253 1
struct rt_vlblock	*vbp;
d1264 1
a1264 1
	RT_CK_VLBLOCK(vbp);
d1287 1
a1287 1
struct rt_vlblock	*vbp;
d1295 1
a1295 1
	RT_CK_VLBLOCK(vbp);
d1315 1
a1315 1
struct rt_vlblock	*vbp;
d1325 1
a1325 1
	RT_CK_VLBLOCK(vbp);
d1332 1
a1332 1
	tab = (long *)rt_calloc( m->maxindex+1, sizeof(long),
d1365 1
a1365 1
	rt_free( (char *)tab, "nmg_vlblock_s tab[]" );
d1373 1
a1373 1
struct rt_vlblock	*vbp;
d1379 1
a1379 1
	RT_CK_VLBLOCK(vbp);
d1392 1
a1392 1
struct rt_vlblock	*vbp;
d1398 1
a1398 1
	RT_CK_VLBLOCK(vbp);
d1418 1
a1418 1
struct rt_vlblock	*vbp;
d1466 1
a1466 1
	struct rt_vlblock	*vbp;
d1476 1
a1476 1
	b = (long *)rt_calloc( s->r_p->m_p->maxindex+1, sizeof(long),
d1508 1
a1508 1
	rt_vlblock_free(vbp);
d1510 1
a1510 1
	rt_free( (char *)b, "nmg_pl_isect flags[]" );
d1532 1
a1532 1
	struct rt_vlblock	*vbp;
d1543 1
a1543 1
	tab = (long *)rt_calloc( m->maxindex+1, sizeof(long),
d1572 2
a1573 2
	rt_vlblock_free(vbp);
	rt_free( (char *)tab, "nmg_pl_comb_fu tab[]" );
d1596 1
a1596 1
	struct rt_vlblock	*vbp;
d1603 1
a1603 1
	tab = (long *)rt_calloc( m->maxindex+1, sizeof(long),
d1637 2
a1638 2
	rt_vlblock_free(vbp);
	rt_free( (char *)tab, "nmg_pl_2fu tab[]" );
d1679 1
a1679 1
struct rt_vlblock *vbp;
d1707 2
a1708 2
	RT_ADD_VLIST( vh, p, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vh, p, RT_VLIST_LINE_DRAW );
d1713 1
a1713 1
	RT_ADD_VLIST( vh, pt, RT_VLIST_LINE_MOVE );
d1716 1
a1716 1
	RT_ADD_VLIST( vh, pt, RT_VLIST_LINE_DRAW );
d1720 1
a1720 1
	RT_ADD_VLIST( vh, pt, RT_VLIST_LINE_MOVE );
d1723 1
a1723 1
	RT_ADD_VLIST( vh, pt, RT_VLIST_LINE_DRAW );
d1727 1
a1727 1
	RT_ADD_VLIST( vh, pt, RT_VLIST_LINE_MOVE );
d1730 1
a1730 1
	RT_ADD_VLIST( vh, pt, RT_VLIST_LINE_DRAW );
d1732 1
a1732 1
	RT_ADD_VLIST( vh, p, RT_VLIST_LINE_MOVE );
d1737 1
a1737 1
struct rt_vlblock *vbp;
d1777 2
a1778 2
	RT_ADD_VLIST( vh, end0, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vh, end1, RT_VLIST_LINE_DRAW );
d1788 1
a1788 1
struct rt_vlblock *vbp;
d1822 2
a1823 2
		RT_ADD_VLIST( vh, base, RT_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vh, tip, RT_VLIST_LINE_DRAW );
d1827 2
a1828 2
		RT_ADD_VLIST( vh, tip, RT_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vh, radial_tip, RT_VLIST_LINE_DRAW );
d1832 2
a1833 2
		RT_ADD_VLIST( vh, tip, RT_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vh, next_base, RT_VLIST_LINE_DRAW );
d1840 1
a1840 1
struct rt_vlblock *vbp;
d1891 1
a1891 1
struct rt_vlblock *vbp;
d1905 1
a1905 1
struct rt_vlblock *vbp;
d1925 1
a1925 1
struct rt_vlblock *vbp;
d1938 1
a1938 1
struct rt_vlblock *vbp;
d1949 1
a1949 1
static struct rt_vlblock *vbp = (struct rt_vlblock *)NULL;
d1983 2
a1984 2
		rt_vlblock_free(vbp);
		vbp = (struct rt_vlblock *)NULL;
d1991 1
a1991 1
		broken_tab = (long *)rt_calloc( m->maxindex+1, sizeof(long),
d2026 1
a2026 1
			struct rt_vlblock *vbp2 = vbp;
d2097 3
a2099 3
		rt_vlblock_free(vbp);
		vbp = (struct rt_vlblock *)NULL;
		rt_free((char *)broken_tab, "broken_tab");
d2116 1
a2116 1
	struct rt_vlblock	*vbp;
d2129 1
a2129 1
	tab = (long *)rt_calloc( m->maxindex+1, sizeof(long),
d2159 2
a2160 2
	rt_vlblock_free(vbp);
	rt_free( (char *)tab, "nmg_face_plot tab[]" );
d2175 1
a2175 1
	struct rt_vlblock	*vbp;
d2188 1
a2188 1
	tab = (long *)rt_calloc( m->maxindex+1, sizeof(long),
d2206 2
a2207 2
	rt_vlblock_free(vbp);
	rt_free( (char *)tab, "nmg_2face_plot tab[]" );
d2242 1
a2242 1
	b = (long *)rt_calloc( m->maxindex, sizeof(long), "nmg_face_lu_plot flag[]" );
d2259 1
a2259 1
	rt_free( (char *)b, "nmg_face_lu_plot flag[]" );
d2295 1
a2295 1
	b = (long *)rt_calloc( m->maxindex, sizeof(long), "nmg_plot_lu_ray flag[]" );
d2317 1
a2317 1
	rt_free( (char *)b, "nmg_plot_lu_ray flag[]" );
d2346 1
a2346 1
	b = (long *)rt_calloc( fu->s_p->r_p->m_p->maxindex, sizeof(long), "bit vec");
d2350 1
a2350 1
	rt_free((char *)b, "bit vec");
d2375 1
a2375 1
	struct rt_vlblock	*vbp;
d2392 1
a2392 1
	tab = (long *)rt_calloc( m->maxindex, sizeof(long), "bit vec");
d2412 2
a2413 2
	rt_vlblock_free(vbp);
	rt_free((char *)tab, "bit vec");
d2480 1
a2480 1
		RT_ADD_VLIST( vhead, vp, RT_VLIST_LINE_MOVE );
d2484 1
a2484 1
			RT_ADD_VLIST( vhead, vp, RT_VLIST_LINE_DRAW );
d2495 1
a2495 1
		RT_ADD_VLIST( vhead, vp, RT_VLIST_LINE_MOVE );
d2499 1
a2499 1
			RT_ADD_VLIST( vhead, vp, RT_VLIST_LINE_DRAW );
d2506 4
a2509 4
	rt_free( (char *) tau1.knots, "rt_nurb_plot:tau1.knots");
	rt_free( (char *) tau2.knots, "rt_nurb_plot:tau2.knots");
	rt_free( (char *) tkv1.knots, "rt_nurb_plot:tkv1>knots");
	rt_free( (char *) tkv2.knots, "rt_nurb_plot:tkv2.knots");
d2531 1
a2531 1
int				cmd;		/* RT_VLIST_LINE_DRAW, etc */
d2564 1
a2564 1
		n.ctl_points = (fastf_t *)rt_malloc(
d2641 2
a2642 2
		rt_free( (char *)n.k.knots, "nmg_cnurb_to_vlist() n.knot.knots");
		rt_free( (char *)n.ctl_points, "nmg_cnurb_to_vlist() ctl_points");
@


11.17
log
@*- fix typos
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_plot.c,v 11.16 1997/09/18 20:32:45 jra Exp $ (ARL)";
d947 1
a947 1
		rt_vlist_3string( vh, label, p, mat, scale );
d1166 1
a1166 1
	rt_vlist_3string( vh, str, tip, mat, char_scale );
a1831 1
#if 0
a1833 31
#else
	    	{
	    		register struct rt_vlist *_vp = BU_LIST_LAST( rt_vlist, (vh) );
	    		if( BU_LIST_IS_HEAD( _vp, (vh) ) || _vp->nused >= RT_VLIST_CHUNK ) {
#if 0
	    			RT_GET_VLIST(_vp);
#else
	    			_vp = BU_LIST_FIRST( rt_vlist, &rt_g.rtg_vlfree );
	    			if( BU_LIST_IS_HEAD( _vp, &rt_g.rtg_vlfree ) ) {
					_vp = (struct rt_vlist *)rt_malloc(sizeof(struct rt_vlist), "rt_vlist");
					_vp->l.magic = RT_VLIST_MAGIC;
				} else {
					BU_LIST_DEQUEUE( &(_vp->l) );
				}
				_vp->nused = 0;
#endif
	    			BU_LIST_INSERT( (vh), &(_vp->l) );
	    		}
	    		VMOVE( _vp->pt[_vp->nused], (tip) );
	    		_vp->cmd[_vp->nused++] = (RT_VLIST_LINE_MOVE);
	    	}
	    	{
	    		register struct rt_vlist *_vp = BU_LIST_LAST( rt_vlist, (vh) );
	    		if( BU_LIST_IS_HEAD( _vp, (vh) ) || _vp->nused >= RT_VLIST_CHUNK ) {
	    			RT_GET_VLIST(_vp);
	    			BU_LIST_INSERT( (vh), &(_vp->l) );
	    		}
	    		VMOVE( _vp->pt[_vp->nused], (next_base) );
	    		_vp->cmd[_vp->nused++] = (RT_VLIST_LINE_DRAW);
	    	}
#endif
@


11.16
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 11.15 1996/09/27 08:27:30 mike Exp jra $ (ARL)";
d2089 1
a2089 1
	default: fprintf(stderr, "Unknown magic number %ld %0x %ld %0x\n", *p, *p, p, p);
@


11.15
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 11.14 1996/07/12 12:17:41 jra Exp mike $ (ARL)";
d2475 1
a2475 1
		fg->u.knots[fg->u.k_size-1], n_interior);
d2479 1
a2479 1
		fg->v.knots[fg->v.k_size-1], n_interior);
d2481 2
a2482 2
	rt_nurb_kvmerge(&tau1, &tkv1, &fg->u);
	rt_nurb_kvmerge(&tau2, &tkv2, &fg->v);
d2486 1
a2486 1
	r = rt_nurb_s_refine( fg, RT_NURB_SPLIT_COL, &tau2);
d2488 1
a2488 1
	c = rt_nurb_s_refine( r, RT_NURB_SPLIT_ROW, &tau1);
d2535 2
a2536 2
	rt_nurb_free_snurb(c);
	rt_nurb_free_snurb(r);
d2593 1
a2593 1
		rt_nurb_gen_knot_vector( &n.k, n.order, 0.0, 1.0 );
@


11.14
log
@Minor Mods for IRIX 6.2
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 11.13 1995/12/02 03:11:31 mike Exp jra $ (ARL)";
d74 1
a74 1
struct rt_list		*vhead;
d99 2
a100 2
struct rt_list		*vhead;
CONST struct rt_list	*eu_hd;
d110 1
a110 1
	for( RT_LIST_FOR( eu, edgeuse, eu_hd ) )  {
d126 1
a126 1
			rt_log("nmg_eu_to_vlist() no vg or mate?\n");
d146 1
a146 1
struct rt_list		*vhead;
d161 1
a161 1
	RT_CK_LIST_HEAD(vhead);
d164 1
a164 1
	if( RT_LIST_FIRST_MAGIC(&lu->down_hd)==NMG_VERTEXUSE_MAGIC )  {
d166 1
a166 1
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d177 1
a177 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d284 1
a284 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d306 1
a306 1
struct rt_list		*vhead;
d312 1
a312 1
	RT_CK_LIST_HEAD(vhead);
d361 1
a361 1
struct rt_list		*vhead;
d373 1
a373 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
d387 1
a387 1
			for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d397 1
a397 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d404 1
a404 1
	for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
d422 1
a422 1
struct rt_list		*vhead;
d429 1
a429 1
	for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
d440 1
a440 1
struct rt_list	*vhead;
d447 1
a447 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
d490 1
a490 1
	prev_eu = RT_LIST_PLAST_CIRC( edgeuse, eu ); 
d578 1
a578 1
		nmg_offset_eu_vert(tip, RT_LIST_PNEXT_CIRC(edgeuse, eu),
d627 1
a627 1
	eulast = RT_LIST_PLAST_CIRC( edgeuse, eu );
d659 1
a659 1
	nexteu = RT_LIST_PNEXT_CIRC( edgeuse, eu );
d839 1
a839 1
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d930 1
a930 1
	struct rt_list	*vh;
d968 1
a968 1
	struct rt_list	*vh;
d1016 1
a1016 1
	struct rt_list	*vh;
d1133 1
a1133 1
struct rt_list			*vh;
d1140 1
a1140 1
CONST struct rt_tol		*tol;
d1150 1
a1150 1
	RT_CK_TOL(tol);
d1161 1
a1161 1
	ang = rt_angle_measure( left, xvec, yvec ) * rt_radtodeg;
d1185 1
a1185 1
CONST struct rt_tol		*tol;
d1192 1
a1192 1
	struct rt_list		*vh;
d1197 1
a1197 1
	RT_CK_TOL(tol);
d1230 1
a1230 1
		vh = (struct rt_list *)NULL;
d1268 1
a1268 1
	magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
d1271 1
a1271 1
	    	vu = RT_LIST_PNEXT(vertexuse, &lu->down_hd);
d1275 1
a1275 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d1299 1
a1299 1
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d1335 1
a1335 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
d1340 1
a1340 1
	for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
d1350 1
a1350 1
	for( RT_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
d1382 1
a1382 1
	for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
d1401 1
a1401 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
d1422 1
a1422 1
CONST struct rt_tol	*tol;
d1427 1
a1427 1
	RT_CK_TOL(tol);
d1458 1
a1458 1
CONST struct rt_tol	*tol;
d1469 1
a1469 1
	RT_CK_TOL(tol);
d1481 1
a1481 1
	rt_log("overlay %s\n", filename);
d1489 1
a1489 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
d1491 1
a1491 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d1493 1
a1493 1
			magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
d1495 1
a1495 1
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d1556 1
a1556 1
		rt_log("overlay %s\n", name);
d1569 1
a1569 1
			rt_log("null nmg_vlblock_anim_upcall, no animation\n");
d1619 1
a1619 1
		rt_log("overlay %s\n", name);
d1684 1
a1684 1
	struct rt_list	*vh;
d1744 1
a1744 1
	struct rt_list	*vh;
d1792 1
a1792 1
	struct rt_list	*vh;
d1837 2
a1838 2
	    		register struct rt_vlist *_vp = RT_LIST_LAST( rt_vlist, (vh) );
	    		if( RT_LIST_IS_HEAD( _vp, (vh) ) || _vp->nused >= RT_VLIST_CHUNK ) {
d1842 2
a1843 2
	    			_vp = RT_LIST_FIRST( rt_vlist, &rt_g.rtg_vlfree );
	    			if( RT_LIST_IS_HEAD( _vp, &rt_g.rtg_vlfree ) ) {
d1847 1
a1847 1
					RT_LIST_DEQUEUE( &(_vp->l) );
d1851 1
a1851 1
	    			RT_LIST_INSERT( (vh), &(_vp->l) );
d1857 2
a1858 2
	    		register struct rt_vlist *_vp = RT_LIST_LAST( rt_vlist, (vh) );
	    		if( RT_LIST_IS_HEAD( _vp, (vh) ) || _vp->nused >= RT_VLIST_CHUNK ) {
d1860 1
a1860 1
	    			RT_LIST_INSERT( (vh), &(_vp->l) );
d1877 1
a1877 1
	struct rt_list	*vh;
d1882 1
a1882 1
	if( RT_LIST_FIRST_MAGIC(&lu->down_hd)==NMG_VERTEXUSE_MAGIC )  {
d1884 1
a1884 1
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d1890 1
a1890 1
		for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd))
d1930 1
a1930 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
d1946 1
a1946 1
	for ( RT_LIST_FOR(fu, faceuse, &s->fu_hd ))
d1948 1
a1948 1
	for ( RT_LIST_FOR(lu, loopuse, &s->lu_hd ))
d1950 1
a1950 1
	for ( RT_LIST_FOR(eu, edgeuse, &s->eu_hd ))
d1964 1
a1964 1
	for ( RT_LIST_FOR(s, shell, & r->s_hd))
d1977 1
a1977 1
	for (RT_LIST_FOR(r, nmgregion, &m->r_hd))
d2028 1
a2028 1
			rt_log("nmg_show_broken_classifier_stuff() maxindex increased! was %d, now %d\n",
d2066 1
a2066 1
				for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
d2105 1
a2105 1
			rt_log("NMG Intermediate display Ctrl-C to continue (%s)\n", a_string);
d2114 1
a2114 1
			rt_log("Continuing\n");
d2126 1
a2126 1
			rt_log("overlay %s for %s\n", buf, a_string);
d2171 1
a2171 1
		rt_log("overlay %s\n", name);
d2188 1
a2188 1
			rt_log("null nmg_vlblock_anim_upcall, no animation\n");
d2236 1
a2236 1
		rt_log("null nmg_vlblock_anim_upcall, no animation\n");
d2290 1
a2290 1
	rt_log("overlay %s\n", buf);
d2348 1
a2348 1
	rt_log("overlay %s\n", buf);
d2374 1
a2374 1
		rt_log("plot_ray_face cannot open %s", name);
d2388 1
a2388 1
	rt_log("overlay %s\n", name);
d2402 1
a2402 1
CONST struct rt_tol	*tol;
d2413 1
a2413 1
	RT_CK_TOL(tol);
d2416 1
a2416 1
	rt_log("overlay %s\n", file);
d2418 1
a2418 1
		rt_log("plot_lu_around_eu() cannot open %s", file);
d2456 1
a2456 1
struct rt_list			*vhead;
d2470 1
a2470 1
	RT_CK_LIST_HEAD( vhead );
d2560 1
a2560 1
struct rt_list			*vhead;
d2573 1
a2573 1
	RT_CK_LIST_HEAD( vhead );
d2581 1
a2581 1
		rt_log("nmg_cnurb_to_vlist() eu=x%x, n=%d, order=%d\n",
d2632 1
a2632 1
		if( coords != 2 && !RT_NURB_IS_PT_RATIONAL(c->pt_type) ) rt_log("nmg_cnurb_to_vlist() coords=%d\n", coords);
@


11.13
log
@Eliminated debug printing
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 11.11 1995/11/30 15:12:49 jra Exp $ (ARL)";
d2484 1
a2484 1
/**	nmg_hack_snurb( &n, fg );	/* XXX */
@


11.12
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@a2611 1
rt_nurb_c_print(c);
a2633 1
rt_nurb_s_print("srf", s);
d2646 3
a2648 1
VSETALL(uvw,0);
a2650 2
rt_log("%g \n", crv_param);
VPRINT("uvw1", uvw);
a2654 1
VPRINT("uvw2", uvw);
a2655 4
if(uvw[0] >= 1 || uvw[1] >= 1 )  {
	nmg_pr_eg( (CONST long *) eg, 0 );
	continue;
}
d2659 1
@


11.11
log
@Fixed stupid mistake in nmg_snurb_fu_to_vlist().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 11.10 1995/11/29 23:53:13 mike Exp $ (ARL)";
a2448 58
 *			N M G _ H A C K _ S N U R B
 *
 *  Convert a new NMG format snurb to the older LIBNURB format,
 *  by copying data and pointers.
 *  Under no circumstances should the output of this routine be freed,
 *  or it will corrupt the NMG original!  Just discard it.
 *
 *  XXX Temporary hack until LIBNURB is updated to new data structures.
 */
void
nmg_hack_snurb( old, fg )
struct snurb	*old;
CONST struct face_g_snurb	*fg;
{
	bzero( (char *)old, sizeof(struct snurb) );

	RT_LIST_INIT( &old->l );
	old->l.magic = RT_SNURB_MAGIC;

	old->order[0] = fg->order[0];
	old->order[1] = fg->order[1];
	old->u_knots = fg->u;		/* struct copy, including pointers! */
	old->v_knots = fg->v;
	old->s_size[0] = fg->s_size[0];
	old->s_size[1] = fg->s_size[1];
	old->pt_type = fg->pt_type;
	old->ctl_points = fg->ctl_points;	/* pointer */
}

/*
 *			N M G _ H A C K _ C N U R B
 *
 *  Convert a new NMG format cnurb to the older LIBNURB format,
 *  by copying data and pointers.
 *  Under no circumstances should the output of this routine be freed,
 *  or it will corrupt the NMG original!  Just discard it.
 *
 *  XXX Temporary hack until LIBNURB is updated to new data structures.
 */
void
nmg_hack_cnurb( old, eg )
struct cnurb	*old;
CONST struct edge_g_cnurb	*eg;
{
	NMG_CK_EDGE_G_CNURB(eg);
	bzero( (char *)old, sizeof(struct cnurb) );

	RT_LIST_INIT( &old->l );
	old->l.magic = RT_CNURB_MAGIC;

	old->order = eg->order;
	old->knot = eg->k;			/* struct copy, including pointers! */
	old->c_size = eg->c_size;
	old->pt_type = eg->pt_type;
	old->ctl_points = eg->ctl_points;	/* pointer */
}

/*
d2467 1
a2467 2
	struct snurb		n;	/* XXX hack, don't free! */
	struct snurb 	*r, *c;
d2484 3
a2486 3
	nmg_hack_snurb( &n, fg );	/* XXX */
	NMG_CK_SNURB(&n);
	r = rt_nurb_s_refine( &n, RT_NURB_SPLIT_COL, &tau2);
d2569 2
a2570 2
	struct cnurb		n;		/* XXX hack, don't free */
	struct cnurb		*c;
d2593 1
a2593 1
		rt_nurb_gen_knot_vector( &n.knot, n.order, 0.0, 1.0 );
d2605 5
a2609 2
	} else
		nmg_hack_cnurb( &n, eg );	/* don't free it! */
d2611 2
a2612 2
	NMG_CK_CNURB( &n );
	c = &n;
d2626 1
a2626 1
		struct snurb	s;	/* XXX hack, don't free! */
d2634 2
a2635 1
		nmg_hack_snurb( &s, fu->f_p->g.snurb_p );
d2641 2
a2642 2
		param_delta = (c->knot.knots[c->knot.k_size-1] - c->knot.knots[0])/(fastf_t)(n_interior+1);
		crv_param = c->knot.knots[0];
d2648 1
d2651 2
d2657 1
d2659 4
d2665 2
a2666 2
			rt_nurb_s_eval( &s, uvw[0], uvw[1], final );
			if( RT_NURB_IS_PT_RATIONAL( s.pt_type ) )
d2679 1
a2679 1
		rt_free( (char *)n.knot.knots, "nmg_cnurb_to_vlist() n.knot.knots");
@


11.10
log
@Honor flag to draw trimming curves only.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 11.9 1995/11/28 20:47:53 jra Exp $ (ARL)";
d332 2
a333 2
		uv_centroid[0] = (fg->u.knots[fg->u.k_size-1] - fg->u.knots[0])/2.0;
		uv_centroid[1] = (fg->v.knots[fg->v.k_size-1] - fg->v.knots[0])/2.0;
@


11.9
log
@Modified nmg_lu_to_vlist() and nmg_snurb_fu_to_vlist() to get NURB faceuse normals plotted.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 11.8 1995/07/03 18:39:21 jra Exp jra $ (ARL)";
d383 2
a384 1
			nmg_snurb_fu_to_vlist( vhead, fu, poly_markers );
@


11.8
log
@Added an XXXX comment about using rt_nurb_c_eval() in nmg_cnurb_to_vlist().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 11.7 1995/07/03 18:34:42 jra Exp $ (ARL)";
d258 13
a272 1
		RT_ADD_VLIST( vhead, centroid, RT_VLIST_LINE_MOVE );
d275 7
a281 2
		VJOIN1( tip, centroid, f, normal );
		RT_ADD_VLIST( vhead, tip, RT_VLIST_LINE_DRAW );
d321 26
@


11.7
log
@Converted nmg_cnurb_to_vlist() to use rt_nurb_c_eval() rather than rt_nurb_c_refine() to avoid
using control points that are outside parameter space of surface.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 11.6 1995/06/28 19:29:16 jra Exp jra $ (ARL)";
d2648 4
@


11.6
log
@nmg_cnurb_to_vlist() was not dividing out the homogeneous coordinate from the
return of rt_nurb_s_eval().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 11.5 1995/02/14 22:24:21 mike Exp jra $ (ARL)";
a2583 1
	struct knot_vector 	tau;
d2620 2
a2621 4

		rt_nurb_kvknot( &tau, 1, 0.0, 1.0, n_interior );
	} else {
		struct knot_vector 	tkv;
a2622 6
		nmg_hack_cnurb( &n, eg );	/* don't free it! */
		rt_nurb_kvgen( &tkv, eg->k.knots[0],
			eg->k.knots[eg->k.k_size-1], n_interior );
		rt_nurb_kvmerge( &tau, &tkv, &eg->k );
		rt_free( (char *) tkv.knots, "nmg_cnurb_to_vlist() tkv.knots");
	}
d2624 1
a2624 2
	c = rt_nurb_c_refine( &n, &tau );
	NMG_CK_CNURB( c );
d2626 1
a2626 1
	coords = RT_NURB_EXTRACT_COORDS(c->pt_type);
a2627 12
	if( RT_NURB_IS_PT_RATIONAL(c->pt_type))  {
		vp = c->ctl_points;
		for(i= 0; i < c->c_size; i++)  {
			FAST fastf_t	div;
			register int	j;
			div = 1/vp[coords-1];
			for( j=0; j < coords; j++ )  {
				*vp++ *= div;
			}
		}
	}

d2641 2
d2644 2
a2645 2
		/* cnurb on spline face -- ctl points are UV */
		if( coords != 2 ) rt_log("nmg_cnurb_to_vlist() coords=%d\n", coords);
d2648 14
a2661 4
		vp = c->ctl_points;
		/* Skip first and last points */
		vp += coords;		/* skip i=0 */
		for( i = 1; i < c->c_size-1; i++)  {
d2663 2
a2664 2
			/* convert 'vp' from UV coord to XYZ coord via surf! */
			rt_nurb_s_eval( &s, vp[0], vp[1], final );
d2671 1
a2676 2
	rt_nurb_free_cnurb(c);
	rt_free( (char *)tau.knots, "nmg_cnurb_to_vlist() tau.knots");
@


11.5
log
@Changed "Plotting to %s" messages to "overlay %s",
so that the whole line can be cut and pasted into an MGED session.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 11.4 95/02/14 06:04:03 mike Exp $ (ARL)";
d2662 1
d2675 6
@


11.4
log
@When in batch mode, still write the classifier plot files.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 11.3 95/02/14 04:32:42 mike Exp Locker: mike $ (ARL)";
d1437 1
a1437 1
	rt_log("Plotting to \"%s\"\n", filename);
d1512 1
a1512 1
		rt_log("Plotting %s\n", name);
d1575 1
a1575 1
		rt_log("plotting to %s\n", name);
d2082 1
a2082 1
			rt_log("Wrote %s for %s\n", buf, a_string);
d2127 1
a2127 1
		rt_log("plotting to %s\n", name);
d2246 1
a2246 1
	rt_log("wrote %s\n", buf);
d2304 1
a2304 1
	rt_log("wrote %s\n", buf);
d2344 1
d2372 1
a2372 1
	rt_log("plotting to %s\n", file);
@


11.3
log
@broken_tab can increase in size!
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 11.2 95/02/11 00:04:51 mike Exp Locker: mike $ (ARL)";
d2061 1
a2061 1
			fprintf(stderr, "NMG Intermediate display Ctrl-C to continue (%s)\n", a_string);
d2070 1
a2070 1
			fprintf(stderr, "Continuing\n");
d2073 12
@


11.2
log
@Removed some deadwood, added nmg_pl_shell().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 11.1 95/01/04 09:58:08 mike Rel4_4 Locker: mike $ (ARL)";
d1606 1
d1981 13
a1993 2
	} else if (all_new) {
		bzero( (char *)broken_tab,  (m->maxindex+1) * sizeof(long));
d2077 1
@


11.1
log
@Release_4.4
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.45 95/01/04 07:59:44 mike Exp $ (ARL)";
a767 17
#if 0
	struct edgeuse	*eu;
	long		magic1;

	NMG_CK_LOOPUSE(lu);
	NMG_INDEX_RETURN_IF_SET_ELSE_SET(b, lu->index);

	magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
	if (magic1 == NMG_VERTEXUSE_MAGIC &&
	    lu->orientation != OT_BOOLPLACE) {
	    	nmg_pl_v(fp, RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p, b);
	} else if (magic1 == NMG_EDGEUSE_MAGIC) {
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			nmg_pl_eu(fp, eu, b, red, green, blue);
		}
	}
#else
a773 1
#endif
a785 12
#if 0
	struct loopuse *lu;

	NMG_CK_FACEUSE(fu);

	NMG_INDEX_RETURN_IF_SET_ELSE_SET(b, fu->index);

	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {

		nmg_pl_lu(fp, lu, b, red, green, blue);
	}
#else
a800 1
#endif
d814 1
a814 5
#if 0
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	long		*b;
d816 5
a820 5
	NMG_CK_SHELL(s);
	if( s->sa_p )  {
		NMG_CK_SHELL_A( s->sa_p );
		pdv_3space( fp, s->sa_p->min_pt, s->sa_p->max_pt );
	}
d822 6
a827 32
	/* get space for flag array, to ensure each item is done once */
	b = (long *)rt_calloc( s->r_p->m_p->maxindex, sizeof(long),
		"nmg_pl_s flag[]" );

	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
		nmg_pl_fu(fp, fu, b, 80, 100, 170);
	}

	for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		nmg_pl_lu(fp, lu, b, 255, 0, 0);
	}

	for( RT_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGE(eu->e_p);

		nmg_pl_eu(fp, eu, b, 200, 200, 0 );
	}
	if (s->vu_p) {
		nmg_pl_v(fp, s->vu_p->v_p, b );
	}

	if( RT_LIST_IS_EMPTY( &s->fu_hd ) &&
	    RT_LIST_IS_EMPTY( &s->lu_hd ) &&
	    RT_LIST_IS_EMPTY( &s->eu_hd ) && !s->vu_p) {
	    	rt_log("WARNING nmg_pl_s(): shell has no children\n");
	}

	rt_free( (char *)b, "nmg_pl_s flag[]" );
#else
d831 1
a831 1
	nmg_vlblock_s(vbp, s, 0);
a833 1
#endif
@


10.45
log
@Cray C90
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.44 94/12/30 00:43:29 mike Exp Locker: mike $ (ARL)";
@


10.44
log
@DEC Alpha
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.43 94/12/29 16:31:31 jra Exp Locker: mike $ (ARL)";
d1247 3
@


10.43
log
@Eliminated doubling of a point in nmg_snurb_to_vlist.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.42 94/12/27 17:47:28 mike Exp Locker: jra $ (ARL)";
d445 1
a445 1
	bzero(delta_vec, sizeof(vect_t)),
d2040 1
a2040 1
		bzero(broken_tab,  (m->maxindex+1) * sizeof(long));
@


10.42
log
@Bug 247, changed show_broken_stuff to nmg_show_broken_classifier_stuff().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.41 94/12/27 10:35:51 stay Exp Locker: mike $ (ARL)";
d2576 2
a2577 1
		for( i = 0; i < c->s_size[0]; i++)
d2694 1
a2703 1
			fastf_t		final[4];
@


10.41
log
@fixed call to rt_nurb_s_eval
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.40 94/12/23 19:36:01 mike Exp Locker: stay $ (ARL)";
d1999 1
a1999 1
sigstepalong(i)
d2012 1
a2012 1
show_broken_stuff(p, classlist, all_new, fancy, a_string)
d2067 1
a2067 1
			cur_sigint = signal(SIGINT, sigstepalong);
d2070 1
a2070 1
					show_broken_stuff(lu, classlist, 1, fancy);
d2109 1
a2109 1
			cur_sigint = signal(SIGINT, sigstepalong);
@


10.40
log
@Added support for per-vertex surface normals.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.39 94/11/17 17:03:33 jra Exp Locker: mike $ (ARL)";
d2702 1
a2702 1
			fastf_t		*final;
d2705 1
a2705 1
			final = rt_nurb_s_eval( &s, vp[0], vp[1] );
a2706 1
			rt_free( (char *)final, "nmg_cnurb_to_vlist() XYZ coord");
@


10.39
log
@Mod to nmg_lu_to_vlist to avoid crashing on edgeuses with no geometry.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.38 94/11/04 06:55:47 mike Exp Locker: jra $ (ARL)";
d148 1
a148 1
int			poly_markers;
d156 1
d174 1
d193 1
a193 1
			if( poly_markers) {
d196 6
d209 1
d211 7
a217 1
			if( poly_markers) {
d232 3
a234 2
		nmg_cnurb_to_vlist( vhead, eu, 10,  poly_markers ?
			RT_VLIST_POLY_DRAW : RT_VLIST_LINE_DRAW );
d239 1
a239 1
		if( poly_markers )  {
d241 6
d253 1
a253 1
	if( poly_markers > 1 && npoints > 2 )  {
@


10.38
log
@Irix 6
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.37 94/10/24 21:17:37 mike Exp Locker: mike $ (ARL)";
d209 4
@


10.37
log
@Delete misleading comments.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.36 94/10/22 07:22:05 mike Exp Locker: mike $ (ARL)";
d539 1
d574 1
a686 1
	point_t	last_tip;
a921 1
	static char label[128];
d934 1
a1007 1
	point_t	last_tip;
a1637 1
static struct rt_vlblock *vbp_old;
a1671 1
	static char label[128];
a1779 1
	vect_t v;
a1784 1
	point_t	last_tip;
a1931 1
	struct vertexuse *vu;
a2073 4
		struct rt_vlblock *vbp2 = vbp;
		register struct loopuse *lu;
		struct faceuse *fu = (struct faceuse *)p;
		int i;
a2112 1
	struct face_g_plane	*fg;
a2171 1
	struct face_g_plane	*fg;
a2483 1
	int			s;
@


10.36
log
@Now draws the cnurb trimming curves too.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.35 94/09/16 20:20:44 mike Exp Locker: mike $ (ARL)";
a275 1
	/* First step, draw the surface. */
a277 2

	/* Second step, draw the trimming curves */
@


10.35
log
@Moved stuff to raytrace.h
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.34 94/09/16 05:01:43 mike Exp Locker: mike $ (ARL)";
d141 2
d176 1
d209 6
d316 1
d318 5
d2452 1
a2452 1
	old->ctl_points = fg->ctl_points;
d2456 28
d2523 1
a2523 1
	r = (struct snurb *) rt_nurb_s_refine( &n, RT_NURB_SPLIT_COL, &tau2);
d2525 1
a2525 1
	c = (struct snurb *) rt_nurb_s_refine( r, RT_NURB_SPLIT_ROW, &tau1);
d2580 127
@


10.34
log
@Initial t-NURBS NMG plotting capability.
@
text
@a0 3
/* XXX Move to raytrace.h */
#define RT_CK_LIST(_hd)	RT_CKMAG(_hd, RT_LIST_HEAD_MAGIC, "struct rt_list");
/* Near definition of RT_GET_VLIST(), note: */
a1 5
 *  Applications that are going to use RT_ADD_VLIST are required to
 *  first execute this macro:	RT_LIST_INIT( &rt_g.rtg_vlfree );
 */

/*
d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.33 94/09/10 04:58:45 mike Exp Locker: mike $ (ARL)";
d158 1
a158 1
	RT_CK_LIST(vhead);
d260 1
a260 1
	RT_CK_LIST(vhead);
d2464 1
a2464 1
	RT_CK_LIST( vhead );
@


10.33
log
@If there are vertexuse attribute normals,
"ev -w -n" will now display them.
@
text
@d1 3
d5 5
d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.32 94/09/02 00:32:39 mike Exp Locker: mike $ (ARL)";
d57 1
d166 1
a166 1
	RT_CKMAG(vhead, RT_LIST_HEAD_MAGIC, "struct rt_list");
d258 25
d311 1
d313 7
a321 1
		if (fu->orientation != OT_SAME)  continue;
d2416 129
@


10.32
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.31 94/08/09 19:38:23 mike Exp Locker: mike $ (ARL)";
d221 1
d227 18
a244 3
		VSCALE( tocent, normal, f );
		VADD2( centroid, centroid, tocent );
		RT_ADD_VLIST( vhead, centroid, RT_VLIST_LINE_DRAW );
@


10.31
log
@Added GDurf's new "conf.h"
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.30 94/04/25 02:25:51 butler Exp Locker: mike $ (ARL)";
d249 1
a249 1
	struct face_g	*fg;
d262 2
a263 2
		fg = fu->f_p->fg_p;
		NMG_CK_FACE_G(fg);
d2061 1
a2061 1
	struct face_g	*fg;
d2121 1
a2121 1
	struct face_g	*fg;
@


10.30
log
@added calls to NMG_CK for parameters to some subroutines that didn't have
them.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.29 94/04/24 18:27:42 mike Exp Locker: butler $ (ARL)";
d41 1
@


10.29
log
@Wrote nmg_plot_lu_ray
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.28 94/04/22 02:47:27 butler Exp Locker: mike $ (ARL)";
d1254 1
d1307 2
d1326 2
@


10.28
log
@changes to the color of edgeuse plotting, and added a missing fclose() to
nmg_plot_ray_face()
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.27 94/04/14 03:16:53 mike Exp Locker: butler $ (ARL)";
d2178 4
a2181 1
	fp = fopen(buf, "w");
d2185 5
a2189 1
	/* A yellow line for the ray.  Overshoot edge by +/-10%, for visibility. */
d2193 1
d2195 1
a2195 1
	pdv_3line(fp, p1, p2 );
d2200 58
@


10.27
log
@Added nmg_plot_lu_around_eu()
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.26 94/03/18 01:53:18 mike Exp Locker: mike $ (ARL)";
d699 1
a699 1
	nmg_vlblock_lu(vbp, lu, b, red, green, blue, 0);
d729 1
d737 1
a737 1
		nmg_vlblock_lu(vbp, lu, b, red, green, blue, 1);
d934 1
a934 1
nmg_vlblock_eu(vbp, eu, tab, red, green, blue, fancy)
d940 1
d978 38
a1015 5
	    	if (eu->up.lu_p->up.fu_p->orientation == OT_SAME)
	    		red += 50;
		else if (eu->up.lu_p->up.fu_p->orientation == OT_OPPOSITE)
			red -= 50;
	    	else
d1018 3
d1025 7
d1037 6
d1044 4
a1047 1
		vh = rt_vlblock_find( vbp, 0, 100, 0 );
d1167 1
a1167 1
		nmg_vlblock_eu(vbp, eu, tab, 80, 100, 170, 3 );
d1170 1
a1170 1
		nmg_vlblock_eu(vbp, eu, tab, 80, 100, 170, 3 );
d1179 1
a1179 1
nmg_vlblock_lu(vbp, lu, tab, red, green, blue, fancy)
d1185 1
d1203 2
a1204 1
			nmg_vlblock_eu(vbp, eu, tab, red, green, blue, fancy);
d1220 1
d1229 1
a1229 1
			nmg_vlblock_lu(vbp, lu, tab, 80, 100, 170, fancy );
d1232 1
a1232 1
			nmg_vlblock_lu(vbp, lu, tab, 80, 100, 170, 0 );
d1269 1
a1269 1
			nmg_vlblock_lu(vbp, lu, tab, 255, 0, 0, fancy);
d1272 1
a1272 1
			nmg_vlblock_lu(vbp, lu, tab, 200, 0, 0, 0);
d1281 1
a1281 1
			nmg_vlblock_eu(vbp, eu, tab, 200, 200, 0, fancy );
d1284 1
a1284 1
			nmg_vlblock_eu(vbp, eu, tab, 200, 200, 0, 0 ); 
d2215 1
d2229 1
d2278 1
a2278 1
			nmg_vlblock_lu(vbp, eur->up.lu_p, tab, 80, 100, 170, 0 );
@


10.26
log
@Moved common vlblock routines off to librt/vlist.c
Added nmg_vlblock_euleft(),
added fancy flag to nmg_vlblock_around_eu().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.25 94/03/17 23:20:13 mike Exp Locker: mike $ (ARL)";
d2173 56
@


10.25
log
@Minor neatening, additional comments
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.24 94/03/17 22:58:40 mike Exp Locker: mike $ (ARL)";
a59 110
 *			Generic VLBLOCK routines			*
 *									*
 ************************************************************************/

struct rt_vlblock *
rt_vlblock_init()
{
	struct rt_vlblock *vbp;
	int	i;

	if (RT_LIST_UNINITIALIZED( &rt_g.rtg_vlfree ))
		RT_LIST_INIT( &rt_g.rtg_vlfree );

	GETSTRUCT( vbp, rt_vlblock );
	vbp->magic = RT_VLBLOCK_MAGIC;
	vbp->max = 32;
	vbp->head = (struct rt_list *)rt_calloc( vbp->max,
		sizeof(struct rt_list), "head[]" );
	vbp->rgb = (long *)rt_calloc( vbp->max,
		sizeof(long), "rgb[]" );

	for( i=0; i < vbp->max; i++ )  {
		vbp->rgb[i] = 0;	/* black, unused */
		RT_LIST_INIT( &(vbp->head[i]) );
	}
	vbp->rgb[0] = 0xFFFF00L;	/* Yellow, default */
	vbp->rgb[1] = 0xFFFFFFL;	/* White */
	vbp->nused = 2;

	return(vbp);
}

void
rt_vlblock_free(vbp)
struct rt_vlblock *vbp;
{
	int	i;

	RT_CK_VLBLOCK(vbp);
	for( i=0; i < vbp->nused; i++ )  {
		/* Release any remaining vlist storage */
		if( vbp->rgb[i] == 0 )  continue;
		if( RT_LIST_IS_EMPTY( &(vbp->head[i]) ) )  continue;
		RT_FREE_VLIST( &(vbp->head[i]) );
	}

	rt_free( (char *)(vbp->head), "head[]" );
	rt_free( (char *)(vbp->rgb), "rgb[]" );
	rt_free( (char *)vbp, "rt_vlblock" );
}

struct rt_list *
rt_vlblock_find( vbp, r, g, b )
struct rt_vlblock *vbp;
int	r, g, b;
{
	long	new;
	int	n;

	RT_CK_VLBLOCK(vbp);

	new = ((r&0xFF)<<16)|((g&0xFF)<<8)|(b&0xFF);

	/* Map black plots into default color (yellow) */
	if( new == 0 ) return( &(vbp->head[0]) );

	for( n=0; n < vbp->nused; n++ )  {
		if( vbp->rgb[n] == new )
			return( &(vbp->head[n]) );
	}
	if( vbp->nused < vbp->max )  {
		/* Allocate empty slot */
		n = vbp->nused++;
		vbp->rgb[n] = new;
		return( &(vbp->head[n]) );
	}
	/*  RGB does not match any existing entry, and table is full.
	 *  Eventually, enlarge table.
	 *  For now, just default to yellow.
	 */
	return( &(vbp->head[0]) );
}

/*
 *			R T _ P L O T _ V L B L O C K
 *
 *  Output a rt_vlblock object in extended UNIX-plot format.
 */
void
rt_plot_vlblock( fp, vbp )
FILE			*fp;
CONST struct rt_vlblock	*vbp;
{
	int	i;

	RT_CK_VLBLOCK(vbp);

	for( i=0; i < vbp->nused; i++ )  {
		if( vbp->rgb[i] == 0 )  continue;
		if( RT_LIST_IS_EMPTY( &(vbp->head[i]) ) )  continue;
		pl_color( fp,
			(vbp->rgb[i]>>16) & 0xFF,
			(vbp->rgb[i]>> 8) & 0xFF,
			(vbp->rgb[i]    ) & 0xFF );
		rt_vlist_to_uplot( fp, &(vbp->head[i]) );
	}
}

/************************************************************************
 *									*
d329 2
a330 1
/*	N M G _ O F F S E T _ E U _ V E R T
d871 2
d874 2
a875 2
		pdv_3move( vbp, p );
		pl_label(vbp, label);
d1000 46
d1050 4
d1056 1
a1056 1
nmg_vlblock_around_eu(vbp, orig_eu, tab )
d1058 1
a1058 1
CONST struct edgeuse		*orig_eu;
d1060 2
d1063 1
d1065 5
d1072 2
a1073 1
	orig_eu = orig_eu->eumate_p;
d1075 34
d1111 2
d1115 1
d1282 1
a1282 1
nmg_pl_edges_in_2_shells(vbp, b, eu)
d1286 2
d1292 1
d1306 1
a1306 1
		    	nmg_vlblock_around_eu(vbp, eu, b);
d1314 5
d1320 1
a1320 1
nmg_pl_isect(filename, s)
d1323 1
d1334 1
d1362 1
a1362 1
					nmg_pl_edges_in_2_shells(vbp, b, eu);
@


10.24
log
@Lee added lots of checking of 'vbp' pointers.
And added automatic initialization of rt_g.rtg_vlfree.
@
text
@d8 12
d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.23 94/03/10 06:46:25 butler Exp $ (ARL)";
d170 1
a170 1
 *		NMG to VLIST routines, for MGED interface		*
d432 1
a432 1
 *		NMG to UNIX-Plot routines, for visualization		*
d643 7
d951 1
a951 1
 *		Visualization as VLIST routines				*
d953 2
a1288 17
 *  Plot all edgeuses around an edge
 */
void
nmg_pl_around_edge(fd, b, eu)
FILE			*fd;
long			*b;
CONST struct edgeuse	*eu;
{
	CONST struct edgeuse *eur = eu;
	do {
		NMG_CK_EDGEUSE(eur);
		nmg_pl_eu(fd, eur, b, 180, 180, 180);
		eur = eur->radial_p->eumate_p;
	} while (eur != eu);
}

/*
a1313 3
#if 0
			nmg_pl_around_edge(fd, b, eu);
#else
a1314 1
#endif
d1507 5
d1861 6
@


10.23
log
@made nmg_pl_fu call nmg_vlblock_lu() with the fancy option
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.22 94/02/24 06:42:19 butler Exp Locker: butler $ (ARL)";
d58 3
d86 1
d107 2
d143 2
d949 1
d984 1
d1032 1
d1099 1
d1126 1
d1155 1
d1185 1
d1238 1
d1255 1
@


10.22
log
@First cut at converting nmg_pl_* routines to use nmg_vlblock_* to
consolidate plotting/visualization functions.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.21 1994/02/23 03:23:23 mike Exp butler $ (ARL)";
d818 1
a818 1
		nmg_vlblock_lu(vbp, lu, b, red, green, blue, 0);
@


10.21
log
@Added nmg_vlblock_around_eu()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.20 94/02/23 02:33:11 mike Exp Locker: mike $ (ARL)";
a417 39
/*
 *			N M G _ O F F S E T _ E U _ C O O R D
 *
 *  Given an edgeuse structure, return the coordinates of
 *  the "base" and "tip" of this edge, suitable for visualization.
 *  These points will be offset inwards along the edge
 *  slightly, to avoid obscuring the vertex, and will be offset off the
 *  face (in the direction of the face normal) slightly, to avoid
 *  obscuring the edge itself.
 *
 *		    final_pt_p		    next_pt_p
 *			* <-------------------- *
 *				final_vec	^
 *						|
 *						|
 *						| edge_vec
 *						|
 *						|
 *				prev_vec	|
 *			* <-------------------- *
 *		    prev_pt_p		     cur_pt_p
 */
static void nmg_offset_eu_coord( base, tip, eu, face_normal )
point_t		base;
point_t		tip;
struct edgeuse	*eu;
vect_t		face_normal;
{
	fastf_t		dist1;
	struct edgeuse	*prev_eu;
	struct edgeuse	*next_eu;
	struct edgeuse	*final_eu;
	vect_t		edge_vec;	/* from cur_pt to next_pt */
	vect_t		prev_vec;	/* from cur_pt to prev_pt */
	vect_t		final_vec;	/* from next_pt to final_pt */
	pointp_t	prev_pt_p;
	pointp_t	cur_pt_p;
	pointp_t	next_pt_p;
	pointp_t	final_pt_p;
a418 52
	NMG_CK_EDGEUSE(eu);
	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);

	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);

	cur_pt_p = eu->vu_p->v_p->vg_p->coord;
	next_pt_p = eu->eumate_p->vu_p->v_p->vg_p->coord;
	VSUB2(edge_vec, next_pt_p, cur_pt_p); 
	VUNITIZE(edge_vec);

	/* find previous vertex in the loop, not colinear with the edge */
	prev_eu = RT_LIST_PLAST_CIRC( edgeuse, eu );
	prev_pt_p = prev_eu->vu_p->v_p->vg_p->coord;
	dist1 = rt_dist_line_point(cur_pt_p, edge_vec, prev_pt_p);
	while (NEAR_ZERO(dist1, LEE_DIVIDE_TOL) && prev_eu != eu) {
		prev_eu = RT_LIST_PLAST_CIRC( edgeuse, prev_eu );
		prev_pt_p = prev_eu->vu_p->v_p->vg_p->coord;
		dist1 = rt_dist_line_point(cur_pt_p, edge_vec, prev_pt_p);
	}

	/* find vertex after "next" in the loop, not colinear with the edge */
	next_eu = RT_LIST_PNEXT_CIRC( edgeuse, eu );
	final_eu = RT_LIST_PNEXT_CIRC( edgeuse, next_eu );
	final_pt_p = final_eu->vu_p->v_p->vg_p->coord;
	dist1 = rt_dist_line_point(cur_pt_p, edge_vec, final_pt_p);
	while (NEAR_ZERO(dist1, LEE_DIVIDE_TOL) && final_eu != eu) {
		final_eu = RT_LIST_PNEXT_CIRC( edgeuse, final_eu );
		final_pt_p = final_eu->vu_p->v_p->vg_p->coord;
		dist1 = rt_dist_line_point(cur_pt_p, edge_vec, final_pt_p);
	}

	VSUB2(prev_vec, prev_pt_p, cur_pt_p);
	VADD2( prev_vec, prev_vec, edge_vec );
	VUNITIZE(prev_vec);

	VSUB3(final_vec, final_pt_p, next_pt_p, edge_vec);
	VUNITIZE(final_vec);

	/* XXX offset vector lengths should be scaled by 5% of face size */

/*	dist1=MAGNITUDE(edge_vec); */
	dist1=0.125;

	VJOIN2(base, cur_pt_p, dist1,prev_vec, nmg_eue_dist,face_normal);
	VJOIN2(tip, next_pt_p, dist1,final_vec, nmg_eue_dist,face_normal);
}

d532 2
a533 3
#if 0
		nmg_offset_eu_coord(base, tip, eu, face_normal);
#else
d537 1
a537 1
#endif
d761 1
d777 8
d797 1
d805 1
d808 16
d837 1
d880 8
d898 1
a898 1
	struct shell *s;
d900 4
a903 3
	for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
		nmg_pl_s(fp, s);
	}
d914 1
a914 1
	struct nmgregion *r;
d916 4
a919 3
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
		nmg_pl_r(fp, r);
	}
d1272 2
a1273 2
nmg_pl_edges_in_2_shells(fd, b, eu)
FILE			*fd;
d1293 1
d1295 3
d1310 7
a1316 6
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	long		*b;
	FILE	*fp;
	long	magic1;
d1328 2
d1333 1
d1335 1
d1346 1
a1346 1
					nmg_pl_edges_in_2_shells(fp, b, eu);
d1355 4
d1375 7
a1381 6
	FILE	*fp;
	char	name[64];
	int	do_plot = 0;
	int	do_anim = 0;
	struct model	*m;
	long	*tab;
d1395 4
d1406 3
a1408 1
		nmg_pl_fu(fp, fu1, tab, 200, 200, 200);
a1412 6
		struct rt_vlblock	*vbp;

		vbp = rt_vlblock_init();

		nmg_vlblock_fu(vbp, fu1, tab, 3);

a1419 1
		rt_vlblock_free(vbp);
d1421 1
@


10.20
log
@Added vlblock to unix-plot routine
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.19 94/02/03 22:51:35 mike Exp Locker: mike $ (ARL)";
d1126 25
@


10.19
log
@Now plots _all_ broken edges, when used in "new" mode.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.18 94/01/29 00:21:34 mike Exp Locker: mike $ (ARL)";
d125 23
d1448 1
a1448 1
nmg_pl_2fu( str, num, fu1, fu2, show_mates )
d1450 1
a1450 1
int			num;
d1459 2
d1462 2
d1470 11
d1482 1
a1482 1
		(void)sprintf(name, str, num);
d1488 1
a1488 9

		nmg_pl_fu(fp, fu1, tab, 100, 100, 180);
		if( show_mates )
			nmg_pl_fu(fp, fu1->fumate_p, tab, 100, 100, 180);

		nmg_pl_fu(fp, fu2, tab, 100, 100, 180);
		if( show_mates )
			nmg_pl_fu(fp, fu2->fumate_p, tab, 100, 100, 180);

a1492 12
		struct rt_vlblock	*vbp;

		vbp = rt_vlblock_init();

		nmg_vlblock_fu( vbp, fu1, tab, 3);
		if( show_mates )
			nmg_vlblock_fu( vbp, fu1->fumate_p, tab, 3);

		nmg_vlblock_fu( vbp, fu2, tab, 3);
		if( show_mates )
			nmg_vlblock_fu( vbp, fu2->fumate_p, tab, 3);

a1498 1
		rt_vlblock_free(vbp);
d1500 2
d1981 2
d1989 1
d1991 1
a1991 1
	if( ! (rt_g.NMG_debug & DEBUG_PL_ANIM) )  return;
d2007 21
a2027 8
	/* Cause animation of boolean operation as it proceeds! */
	if( nmg_vlblock_anim_upcall )  {
		/* if requested, delay 3/4 second */
		(*nmg_vlblock_anim_upcall)( vbp,
			(rt_g.NMG_debug&DEBUG_PL_SLOW) ? 750000 : 0,
			0 );
	} else {
		rt_log("null nmg_vlblock_anim_upcall, no animation\n");
@


10.18
log
@Added handling of wire loops.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.17 94/01/14 03:19:47 mike Exp Locker: mike $ (ARL)";
d1594 1
d1600 1
a1600 1
	 * compute endpoints by forming a vector between verets, scale vector
d1644 1
a1644 2
	if ( ! NMG_INDEX_TEST_AND_SET(broken_tab, eu->e_p) )
		show_broken_e(vbp, eu, fancy);
@


10.17
log
@Fixed PICK_BROKEN_COLOR() macro, which was unnecessarily complicated,
and in one place, was being given a loop pointer while being told it
was a face pointer.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.16 94/01/14 03:11:14 mike Exp Locker: mike $ (ARL)";
d1744 6
a1749 1
	NMG_GET_FU_NORMAL( n, lu->up.fu_p );
@


10.16
log
@Changed name of macro, moved macro to nmg.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d1500 1
a1500 1
#define PICK_BROKEN_COLOR(type, p) { \
d1503 1
a1503 1
	} else if( NMG_INDEX_TEST(global_classlist[NMG_CLASS_AinB], ((struct type *)p)) ) \
d1505 1
a1505 1
	else if( NMG_INDEX_TEST(global_classlist[NMG_CLASS_AonBshared], ((struct type *)p)) ) \
d1507 1
a1507 1
	else if( NMG_INDEX_TEST(global_classlist[NMG_CLASS_AonBanti], ((struct type *)p)) ) \
d1509 1
a1509 1
	else if ( NMG_INDEX_TEST(global_classlist[NMG_CLASS_AoutB], ((struct type *)p)) ) \
d1539 1
a1539 1
	PICK_BROKEN_COLOR(vertex, vu->v_p);
d1542 1
a1542 1
		PICK_BROKEN_COLOR(vertexuse, vu);
d1607 1
a1607 1
	PICK_BROKEN_COLOR(edge, eu->e_p);
d1610 1
a1610 1
		PICK_BROKEN_COLOR(edgeuse, eu);
d1740 1
a1740 1
	PICK_BROKEN_COLOR(face, lu->l_p);
@


10.15
log
@Access to plane equation / surface normal in face_geometry structure
is now done through macros NMG_GET_FU_PLANE() NMG_GET_FU_NORMAL(),
which honor the f->flip flag.
@
text
@d13 2
a14 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d16 5
d22 2
a23 2
 *	This software is Copyright (C) 1990 by the United States Army.
 *	All rights reserved.
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.14 93/09/10 23:20:52 mike Exp Locker: mike $ (BRL)";
a38 2


a40 4
#define NMG_TAB_RETURN_IF_SET_ELSE_SET(_tab,_index)	\
	{ if( (_tab)[_index] )  return; \
	  else (_tab)[_index] = 1; }

d45 1
d704 1
a704 1
	NMG_TAB_RETURN_IF_SET_ELSE_SET(b, v->index);
d733 1
a733 1
	NMG_TAB_RETURN_IF_SET_ELSE_SET(b, e->index);
d786 1
a786 1
	NMG_TAB_RETURN_IF_SET_ELSE_SET(b, eu->index);
d834 1
a834 1
	NMG_TAB_RETURN_IF_SET_ELSE_SET(b, lu->index);
d861 1
a861 1
	NMG_TAB_RETURN_IF_SET_ELSE_SET(b, fu->index);
d973 1
a973 1
	NMG_TAB_RETURN_IF_SET_ELSE_SET( tab, v->index );
d1007 1
a1007 1
	NMG_TAB_RETURN_IF_SET_ELSE_SET( tab, e->index );
d1054 1
a1054 1
	NMG_TAB_RETURN_IF_SET_ELSE_SET( tab, eu->index );
d1121 1
a1121 1
	NMG_TAB_RETURN_IF_SET_ELSE_SET( tab, lu->index );
d1149 1
a1149 1
	NMG_TAB_RETURN_IF_SET_ELSE_SET( tab, fu->index );
d1534 1
a1534 1
	NMG_TAB_RETURN_IF_SET_ELSE_SET( broken_tab, v->index );
@


10.14
log
@Extended the yellow (ray) line beyond the end points by 10%, to make it easier to tell apart from an edge.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.13 93/07/20 21:04:38 mike Exp Locker: mike $ (BRL)";
d324 2
d332 1
d334 1
a334 1
		   	nmg_lu_to_vlist( vhead, lu, poly_markers, fg->N );
d600 1
a600 5
		if (fu->orientation == OT_OPPOSITE) {
			VREVERSE( face_normal, fu->f_p->fg_p->N );
		} else {
		    	VMOVE( face_normal, fu->f_p->fg_p->N );
		}
d1722 1
d1745 2
d1749 1
a1749 1
		nmg_lu_to_vlist( vh, lu, 0, lu->up.fu_p->f_p->fg_p->N );
d1752 1
a1752 1
		nmg_lu_to_vlist( vh, lu, 1, lu->up.fu_p->f_p->fg_p->N );
@


10.13
log
@ANSI lint
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.12 93/05/15 01:05:38 mike Exp Locker: mike $ (BRL)";
d2043 2
d2056 2
d2071 2
a2072 1
	/* A yellow line for the ray */
d2074 5
a2078 1
	pdv_3line(fp, vu1->v_p->vg_p->coord, vu2->v_p->vg_p->coord );
@


10.12
log
@Now GRAPHCL and PL_LOOP can be set separately
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.11 93/05/15 00:22:48 mike Exp Locker: mike $ (BRL)";
d377 1
a377 1
	register struct region	*r;
d380 1
a380 1
	for( RT_LIST_FOR( r, region, &m->r_hd ) )  {
d1267 1
a1267 1
	struct edgeuse *eur = eu;
d1908 1
a1908 1
		show_broken_vu( vbp, ((struct vertexuse *)p)->v_p, fancy);
@


10.11
log
@Added DEBUG_PL_LOOP to dray polygonal faces colored by loopuse
classification.
Modified nmg_lu_to_vlist() calling sequence.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.10 93/04/02 02:57:47 butler Exp Locker: mike $ (BRL)";
d1733 4
a1736 2
	for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd))
		show_broken_eu(vbp, eu, fancy);
d1738 12
a1749 7
	if (rt_g.NMG_debug & (DEBUG_GRAPHCL|DEBUG_PL_LOOP) ) {
		/* Draw colored polygons for the actual face loops */
		/* Faces are not classified, only loops */
		/* This can obscure the edge/vertex info */
		PICK_BROKEN_COLOR(face, lu->l_p);
		vh = rt_vlblock_find( vbp, 
			broken_colors[broken_color][0], broken_colors[broken_color][1], broken_colors[broken_color][2]);
d1751 2
@


10.10
log
@moved nmg_plot_ray_face() from g_nmg.c
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.9 93/04/02 01:31:16 butler Exp Locker: butler $ (BRL)";
d206 1
a206 1
 *  Plot a list of loopuses.
d209 1
a209 1
nmg_lu_to_vlist( vhead, lu_hd, poly_markers, normal )
d211 1
a211 1
CONST struct rt_list	*lu_hd;
d215 8
a222 5
	struct loopuse	*lu;
	struct edgeuse	*eu;
	struct vertexuse *vu;
	struct vertex	*v;
	register struct vertex_g *vg;
d224 1
a224 5
	for( RT_LIST_FOR( lu, loopuse, lu_hd ) )  {
		int		isfirst;
		struct vertex_g	*first_vg;
		point_t		centroid;
		int		npoints;
d226 22
a247 6
		/* Consider this loop */
		NMG_CK_LOOPUSE(lu);
		if( RT_LIST_FIRST_MAGIC(&lu->down_hd)==NMG_VERTEXUSE_MAGIC )  {
			/* loop of a single vertex */
			vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
			nmg_vu_to_vlist( vhead, vu );
d250 8
a257 30
		/* Consider all the edges in the loop */
		isfirst = 1;
		first_vg = (struct vertex_g *)0;
		npoints = 0;
		VSETALL( centroid, 0 );
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			/* Consider this edge */
			NMG_CK_EDGEUSE(eu);
			vu = eu->vu_p;
			NMG_CK_VERTEXUSE(vu);
			v = vu->v_p;
			NMG_CK_VERTEX(v);
			vg = v->vg_p;
			if( !vg ) {
				continue;
			}
			NMG_CK_VERTEX_G(vg);
			VADD2( centroid, centroid, vg->coord );
			npoints++;
			if (isfirst) {
				if( poly_markers) {
					/* Insert a "start polygon, normal" marker */
					RT_ADD_VLIST( vhead, normal, RT_VLIST_POLY_START );
					RT_ADD_VLIST( vhead, vg->coord, RT_VLIST_POLY_MOVE );
				} else {
					/* move */
					RT_ADD_VLIST( vhead, vg->coord, RT_VLIST_LINE_MOVE );
				}
				isfirst = 0;
				first_vg = vg;
d259 2
a260 6
				if( poly_markers) {
					RT_ADD_VLIST( vhead, vg->coord, RT_VLIST_POLY_DRAW );
				} else {
					/* Draw */
					RT_ADD_VLIST( vhead, vg->coord, RT_VLIST_LINE_DRAW );
				}
d262 5
a266 7
		}

		/* Draw back to the first vertex used */
		if( !isfirst && first_vg )  {
			if( poly_markers )  {
				/* Draw, end polygon */
				RT_ADD_VLIST( vhead, first_vg->coord, RT_VLIST_POLY_END );
d269 1
a269 1
				RT_ADD_VLIST( vhead, first_vg->coord, RT_VLIST_LINE_DRAW );
d272 10
a281 12
		if( poly_markers > 1 && npoints > 2 )  {
			/* Draw surface normal as a little vector */
			double	f;
			vect_t	tocent;
			f = 1.0 / npoints;
			VSCALE( centroid, centroid, f );
			RT_ADD_VLIST( vhead, centroid, RT_VLIST_LINE_MOVE );
			VSUB2( tocent, first_vg->coord, centroid );
			f = MAGNITUDE( tocent ) * 0.5;
			VSCALE( tocent, normal, f );
			VADD2( centroid, centroid, tocent );
			RT_ADD_VLIST( vhead, centroid, RT_VLIST_LINE_DRAW );
d284 13
d317 1
d330 3
a332 1
	   	nmg_lu_to_vlist( vhead, &fu->lu_hd, poly_markers, fg->N );
d337 3
a339 1
	nmg_lu_to_vlist( vhead, &s->lu_hd, 0, normal );
d1495 6
a1500 6
	{ 100, 100, 255 },	/* NMG_CLASS_AinB */
	{ 255,  50,  50 },	/* NMG_CLASS_AonBshared */
	{ 255,  50, 255 }, 	/* NMG_CLASS_AonBanti */
	{  50, 255,  50 },	/* NMG_CLASS_AoutB */
	{ 255, 255, 255 },	/* UNKNOWN */
	{ 255, 255, 125 }	/* no classification list */
d1722 2
d1735 10
@


10.9
log
@moved nmg_m_to_vlist() from g_nmg.c
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.8 93/03/24 03:21:34 mike Exp Locker: butler $ (BRL)";
d1970 1
a1970 1
 *			N M G _ F A C E _ P L O T
d2050 37
@


10.8
log
@Most NMG arguments became CONST, to declare our true intentions of
only reading them, not changing them.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.7 92/10/06 23:12:00 mike Exp Locker: mike $ (BRL)";
d364 18
@


10.7
log
@DEBUG_COMBINE -> DEBUG_FCUT
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.6 92/07/23 05:06:01 butler Exp Locker: mike $ (BRL)";
d141 1
a141 1
struct vertexuse	*vu;
d165 2
a166 2
struct rt_list	*vhead;
struct rt_list	*eu_hd;
d210 4
a213 4
struct rt_list	*vhead;
struct rt_list	*lu_hd;
int		poly_markers;
vectp_t		normal;
d313 3
a315 3
struct rt_list	*vhead;
struct shell	*s;
int		poly_markers;
d352 3
a354 3
struct rt_list	*vhead;
struct nmgregion	*r;
int		poly_markers;
d477 4
a480 4
point_t		base;
struct edgeuse	*eu;
vect_t		face_normal;
int		tip;
d483 1
a483 1
	struct edgeuse	*this_eu;
d554 1
a554 1
struct edgeuse *eu;
d600 1
a600 1
struct edgeuse *eu;
d622 1
a622 1
struct edgeuse	*eu;
d657 1
a657 1
struct edgeuse	*eu;
d678 3
a680 3
FILE		*fp;
struct vertex	*v;
long		*b;
d705 4
a708 4
FILE		*fp;
struct edge	*e;
long		*b;
int		red, green, blue;
d747 4
a750 4
FILE		*fp;
struct edgeuse	*eu;
long		*b;
int		red, green, blue;
d806 4
a809 4
FILE		*fp;
struct loopuse	*lu;
long		*b;
int		red, green, blue;
d833 4
a836 4
FILE		*fp;
struct faceuse	*fu;
long		*b;
int		red, green, blue;
d857 2
a858 2
FILE		*fp;
struct shell	*s;
d909 2
a910 2
FILE		*fp;
struct nmgregion *r;
d924 2
a925 2
FILE		*fp;
struct model	*m;
d945 3
a947 3
struct rt_vlblock	*vbp;
struct vertex		*v;
long			*tab;
d977 4
a980 4
struct edge	*e;
long		*tab;
int		red, green, blue;
int		fancy;
d1022 5
a1026 5
struct rt_vlblock	*vbp;
struct edgeuse		*eu;
long			*tab;
int			red, green, blue;
int			fancy;
d1092 4
a1095 4
struct loopuse	*lu;
long		*tab;
int		red, green, blue;
int		fancy;
d1123 3
a1125 3
struct faceuse	*fu;
long		*tab;
int		fancy;
d1149 2
a1150 2
struct shell	*s;
int		fancy;
d1205 2
a1206 2
struct nmgregion *r;
int		fancy;
d1221 2
a1222 2
struct model	*m;
int		fancy;
d1242 3
a1244 3
FILE		*fd;
long		*b;
struct edgeuse	*eu;
d1260 3
a1262 3
FILE		*fd;
long		*b;
struct edgeuse	*eu;
d1264 2
a1265 2
	struct edgeuse	*eur;
	struct shell	*s;
d1290 2
a1291 2
char		*filename;
struct shell	*s;
d1347 1
a1347 1
struct faceuse	*fu1;
d1407 5
a1411 5
char		*str;
int		num;
struct faceuse	*fu1;
struct faceuse	*fu2;
int		show_mates;
d1471 2
a1472 2
long		*broken_tab;
int 		broken_color;
d1495 3
a1497 1

d1502 1
a1502 1
struct vertexuse *vu;
d1561 1
a1561 1
struct edgeuse *eu;
d1611 1
a1611 1
struct edgeuse *eu;
d1698 1
a1698 1
struct loopuse *lu;
d1720 1
a1720 1
struct faceuse *fu;
d1733 1
a1733 1
struct shell *s;
d1754 1
a1754 1
struct nmgregion *r;
d1767 1
a1767 1
struct model *m;
d1792 1
a1792 1
char	*a_string;
d1912 1
a1912 1
struct faceuse	*fu;
d1958 1
a1958 1
struct faceuse	*fu1, *fu2;
d2004 2
a2005 2
struct loopuse		*lu;
struct vertexuse	*vu1, *vu2;
@


10.6
log
@changed plotting of "wire edge" or "crack edge" edgeuses.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.5 92/07/22 22:17:36 mike Exp Locker: butler $ (BRL)";
d1357 1
a1357 1
	   rt_g.NMG_debug & DEBUG_COMBINE ) do_plot = 1;
@


10.5
log
@Brought in three more routines, from nmg_fcut.c.
Fixed bug in one visualization routine.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.4 92/07/20 23:07:57 butler Exp Locker: mike $ (BRL)";
d476 1
a476 1
nmg_offset_eu_vert(base, eu, face_normal)
d480 1
a481 1
	vect_t		eu_vec;	/* from cur_pt to next_pt */
d485 1
d488 1
a488 4
	vect_t		delta_vec;
	struct vertex	*this_v;
	struct vertex	*mate_v;
	struct vertex	*prev_v;
d493 1
d495 5
a499 3
	for(this_eu = eu ; MAGSQ(delta_vec) <= VDIVIDE_TOL && prev_eu != eu ;
	    prev_eu = RT_LIST_PLAST_CIRC( edgeuse, prev_eu ),
	    this_eu = RT_LIST_PNEXT_CIRC( edgeuse, this_eu ) ) {
d501 5
a505 6
		NMG_CK_EDGEUSE(this_eu);
		NMG_CK_VERTEXUSE(this_eu->vu_p);
	    	this_v = this_eu->vu_p->v_p;
		NMG_CK_VERTEX(this_v);
	    	this_vg = this_v->vg_p;
		NMG_CK_VERTEX_G(this_vg);
d507 5
a511 6
		NMG_CK_EDGEUSE(this_eu->eumate_p);
		NMG_CK_VERTEXUSE(this_eu->eumate_p->vu_p);
	    	mate_v = this_eu->eumate_p->vu_p->v_p;
		NMG_CK_VERTEX(mate_v);
	    	mate_vg = mate_v->vg_p;
		NMG_CK_VERTEX_G(mate_vg);
d513 4
a516 6
		NMG_CK_EDGEUSE(prev_eu);
		NMG_CK_VERTEXUSE(prev_eu->vu_p);
	    	prev_v = prev_eu->vu_p->v_p;
		NMG_CK_VERTEX(prev_v);
	    	prev_vg = prev_v->vg_p;
		NMG_CK_VERTEX_G(prev_vg);
a517 2
		if (prev_eu->e_p == this_eu->e_p)
			continue;
d519 4
a522 4
		/* get "left" vector for edgeuse */
		VSUB2(eu_vec, mate_vg->coord, this_vg->coord); 
		VUNITIZE(eu_vec);
		VCROSS(eu_left, face_normal, eu_vec);
d524 2
a525 4
		/* get "left" vector for previous edgeuse */
		VSUB2(prev_vec, this_vg->coord, prev_vg->coord);
		VUNITIZE(prev_vec);
		VCROSS(prev_left, face_normal, prev_vec);
a526 4
		/* get "delta" vector to apply to vertex */
		VADD2(delta_vec, prev_left, eu_left);
	}

d532 5
d584 3
a586 2
	    	nmg_offset_eu_vert(base, eu, face_normal);
	    	nmg_offset_eu_vert(tip, RT_LIST_PNEXT_CIRC( edgeuse, eu ), face_normal);
@


10.4
log
@debugging display hacks added
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.3 92/06/25 20:08:31 butler Exp Locker: butler $ (BRL)";
a480 3
	pointp_t	cur_pt_p;
	pointp_t	next_pt_p;
	pointp_t	prev_pt_p;
d488 4
a492 2


d502 5
a506 2
		NMG_CK_VERTEX(this_eu->vu_p->v_p);
		NMG_CK_VERTEX_G(this_eu->vu_p->v_p->vg_p);
d509 5
a513 2
		NMG_CK_VERTEX(this_eu->eumate_p->vu_p->v_p);
		NMG_CK_VERTEX_G(this_eu->eumate_p->vu_p->v_p->vg_p);
d516 4
a519 2
		NMG_CK_VERTEX(prev_eu->vu_p->v_p);
		NMG_CK_VERTEX_G(prev_eu->vu_p->v_p->vg_p);
d525 1
a525 3
		cur_pt_p = this_eu->vu_p->v_p->vg_p->coord;
		next_pt_p = this_eu->eumate_p->vu_p->v_p->vg_p->coord;
		VSUB2(eu_vec, next_pt_p, cur_pt_p); 
d530 1
a530 2
		prev_pt_p = prev_eu->vu_p->v_p->vg_p->coord;
		VSUB2(prev_vec, cur_pt_p, prev_pt_p);
d540 1
a540 1
		VJOIN2(base, cur_pt_p,
d544 1
a544 1
		VJOIN2(base, cur_pt_p,
d1908 126
@


10.3
log
@adjusted scaling of edgeuse plotting so that edgeuses are further "in" along
the surface of the face than they are "above" the surface.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 10.2 92/06/19 22:39:49 butler Exp Locker: butler $ (BRL)";
d35 2
d45 1
a1502 1

d1521 1
a1521 1
		fprintf(stderr, "vertex broken_color %d...", broken_color);
d1523 1
a1523 1
		fprintf(stderr, "vertexuse broken_color %d\n", broken_color);
d1557 1
a1557 1
show_broken_eu(vbp, eu, fancy)
a1566 4
	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGE(eu->e_p);
	NMG_TAB_RETURN_IF_SET_ELSE_SET( broken_tab, eu->e_p->index );

a1569 2
	p0 = eu->vu_p->v_p->vg_p->coord;

d1573 3
d1589 1
a1589 1
		fprintf(stderr, "edge broken_color %d... ", broken_color);
d1591 1
a1591 1
		fprintf(stderr, "edgeuse broken_color %d\n", broken_color);
d1603 1
d1605 21
a1630 5
	    	int red, green, blue;
		point_t base, tip;
		point_t	radial_tip;
		point_t	next_base;
		point_t	last_tip;
d1655 1
d1658 31
d1787 1
a1787 1
show_broken_stuff(p, classlist, all_new, fancy)
d1791 1
d1875 23
a1897 3
		(*nmg_vlblock_anim_upcall)( vbp,
			(rt_g.NMG_debug&DEBUG_PL_SLOW) ? US_DELAY : 0,
			1 );
@


10.2
log
@added "show_broken_stuff()" and new edgeuse vertex visualization routines.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_plot.c,v 10.1 91/10/12 06:40:50 mike Rel4_0 Locker: butler $ (BRL)";
d465 6
d533 3
a535 1
		VJOIN2(base, cur_pt_p, nmg_eue_dist,delta_vec, nmg_eue_dist,face_normal);
d537 3
a539 1
		VJOIN2(base, cur_pt_p, nmg_eue_dist,eu_left, nmg_eue_dist,face_normal);
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.24 91/06/17 20:42:19 butler Exp $ (BRL)";
d26 2
d33 1
d43 1
a43 1

d453 6
a458 3
	
	VJOIN2(base, cur_pt_p, 0.125,prev_vec, 0.05,face_normal);
	VJOIN2(tip, next_pt_p, 0.125,final_vec, 0.05,face_normal);
d461 21
d483 52
d570 1
a570 1

d572 4
d993 1
a993 1
	VSUB2SCALE(v, p1, p0, 0.95);
d1041 9
d1177 1
a1177 1
			nmg_vlblock_eu(vbp, eu, tab, 200, 200, 0, 0 );
d1372 1
a1372 1
		nmg_vlblock_fu(vbp, fu1, tab, 1);
d1376 2
a1377 1
				(rt_g.NMG_debug&DEBUG_PL_SLOW) ? US_DELAY : 0 );
d1436 1
a1436 1
		nmg_vlblock_fu( vbp, fu1, tab, 1);
d1438 1
a1438 1
			nmg_vlblock_fu( vbp, fu1->fumate_p, tab, 1);
d1440 1
a1440 1
		nmg_vlblock_fu( vbp, fu2, tab, 1);
d1442 1
a1442 1
			nmg_vlblock_fu( vbp, fu2->fumate_p, tab, 1);
d1447 2
a1448 1
				(rt_g.NMG_debug&DEBUG_PL_SLOW) ? US_DELAY : 0 );
d1453 372
@


1.24
log
@changed function declarations so that all global functions have their
"nmg_" at the begining of the line.  Static functions have their function
names on the same line as the "static" modifier.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.23 91/06/12 20:58:19 mike Exp $ (BRL)";
@


1.23
log
@nmg.h comes before raytrace.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.22 91/05/25 03:31:17 mike Exp $ (BRL)";
d132 1
d157 1
d202 1
d581 2
a582 1
void nmg_pl_v(fp, v, b)
d709 2
a710 1
void nmg_pl_lu(fp, lu, b, red, green, blue)
d736 2
a737 1
void nmg_pl_fu(fp, fu, b, red, green, blue)
d760 2
a761 1
void nmg_pl_s(fp, s)
d812 2
a813 1
void nmg_pl_r(fp, r)
d827 2
a828 1
void nmg_pl_m(fp, m)
d848 2
a849 1
void nmg_vlblock_v(vbp, v, tab)
d879 2
a880 1
void nmg_vlblock_e(vbp, e, tab, red, green, blue, fancy)
d925 2
a926 1
void nmg_vlblock_eu(vbp, eu, tab, red, green, blue, fancy)
d985 2
a986 1
void nmg_vlblock_lu(vbp, lu, tab, red, green, blue, fancy)
d1016 2
a1017 1
void nmg_vlblock_fu(vbp, fu, tab, fancy)
d1042 2
a1043 1
void nmg_vlblock_s(vbp, s, fancy)
d1098 2
a1099 1
void nmg_vlblock_r(vbp, r, fancy)
d1114 2
a1115 1
void nmg_vlblock_m(vbp, m, fancy)
d1136 2
a1137 1
void nmg_pl_around_edge(fd, b, eu)
d1154 2
a1155 1
void nmg_pl_edges_in_2_shells(fd, b, eu)
d1184 2
a1185 1
void nmg_pl_isect(filename, s)
@


1.22
log
@Added DEBUG_PL_SLOW bit
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.21 91/03/02 00:17:59 mike Exp $ (BRL)";
d28 1
a29 1
#include "nmg.h"
@


1.21
log
@All the plotting routines changed to using flags arrays
instead of nmg_ptbl structures.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.20 91/03/01 22:43:23 mike Exp $ (BRL)";
d1263 2
a1264 1
			(*nmg_vlblock_anim_upcall)( vbp, US_DELAY );
d1333 2
a1334 1
			(*nmg_vlblock_anim_upcall)( vbp, US_DELAY );
@


1.20
log
@Moved VJOIN3 to vmath.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.19 91/03/01 22:27:22 mike Exp $ (BRL)";
d28 1
a29 1
#include "raytrace.h"
d123 1
d578 4
a581 4
static void nmg_pl_v(fp, v, b)
FILE *fp;
struct vertex *v;
struct nmg_ptbl *b;
d586 1
a586 1
	if (nmg_tbl(b, TBL_INS_UNIQUE, &v->magic) >= 0) return;
d604 2
a605 1
void nmg_pl_e(fp, e, b, red, green, blue)
d608 1
a608 1
struct nmg_ptbl	*b;
d611 3
a613 3
	pointp_t p0, p1;
	point_t end0, end1;
	vect_t v;
d615 1
a615 1
	if (nmg_tbl(b, TBL_INS_UNIQUE, &e->magic) >= 0) return;
d646 2
a647 1
void nmg_pl_eu(fp, eu, b, red, green, blue)
d650 1
a650 1
struct nmg_ptbl	*b;
d668 1
a668 1
	if (nmg_tbl(b, TBL_INS_UNIQUE, &eu->l.magic) >= 0) return;
d708 1
a708 1
struct nmg_ptbl	*b;
d715 1
a715 1
	if (nmg_tbl(b, TBL_INS_UNIQUE, &lu->l.magic) >= 0) return;
d732 4
a735 4
FILE *fp;
struct faceuse *fu;
struct nmg_ptbl *b;
int red, green, blue;
a739 1
	if (nmg_tbl(b, TBL_INS_UNIQUE, &fu->l.magic) >= 0) return;
d741 2
d750 3
d755 2
a756 2
FILE *fp;
struct shell *s;
d761 1
a761 1
	struct nmg_ptbl b;
a762 1

d769 3
a771 2
	/* get space for list of items processed */
	(void)nmg_tbl(&b, TBL_INIT, (long *)0);	
d775 1
a775 1
		nmg_pl_fu(fp, fu, &b, 80, 100, 170);
d780 1
a780 1
		nmg_pl_lu(fp, lu, &b, 255, 0, 0);
d787 1
a787 1
		nmg_pl_eu(fp, eu, &b, 200, 200, 0 );
d790 1
a790 1
		nmg_pl_v(fp, s->vu_p->v_p, &b );
d796 1
a796 1
	    	rt_log("WARNING nmg_pl_s() shell has no children\n");
d799 1
a799 1
	(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
d806 1
a806 1
FILE *fp;
d820 2
a821 2
FILE *fp;
struct model *m;
d839 1
a839 1
static void nmg_vlblock_v(vbp, v, tab)
d841 2
a842 2
struct vertex	*v;
long		*tab;
d869 1
a869 1
static void nmg_vlblock_e(vbp, e, tab, red, green, blue, fancy)
d916 4
a919 4
struct edgeuse	*eu;
long		*tab;
int		red, green, blue;
int		fancy;
d974 1
a974 1
struct vlblock	*vbp;
d982 1
d990 3
a992 1
	    	nmg_vlblock_v(vbp, RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p, tab);
d1004 2
a1005 2
struct vlblock	*vbp;
struct faceuse *fu;
d1029 1
a1029 1
struct vlblock	*vbp;
d1084 1
a1084 1
struct vlblock	*vbp;
d1099 1
a1099 1
struct vlblock	*vbp;
d1119 4
a1122 4
static void nmg_pl_around_edge(fd, b, eu)
FILE *fd;
struct nmg_ptbl *b;
struct edgeuse *eu;
d1137 3
a1139 3
FILE *fd;
struct nmg_ptbl *b;
struct edgeuse *eu;
d1166 2
a1167 2
char *filename;
struct shell *s;
d1172 1
a1172 1
	struct nmg_ptbl b;
d1183 2
a1184 1
	(void)nmg_tbl(&b, TBL_INIT, (long *)NULL);
d1200 1
a1200 1
					nmg_pl_edges_in_2_shells(fp, &b, eu);
d1209 1
a1209 1
	(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
d1229 2
a1230 1
	struct nmg_ptbl	tbl;
d1238 6
d1251 1
a1251 4
		(void)nmg_tbl(&tbl, TBL_INIT, (long *)NULL);

		nmg_pl_fu(fp, fu1, &tbl, 200, 200, 200);

a1252 1
		(void)nmg_tbl(&tbl, TBL_FREE, (long *)NULL);
a1256 2
		long			*tab;
		struct model		*m;
a1257 5
		m = nmg_find_model( &fu1->l.magic );
		NMG_CK_MODEL(m);
		/* get space for list of items processed */
		tab = (long *)rt_calloc( m->maxindex+1, sizeof(long),
			"nmg_pl_comb_fu tab[]");
d1260 1
a1260 1
		nmg_vlblock_fu(vbp, fu1, tab, 200, 200, 200, 1);
a1261 2
		rt_free( (char *)tab, "nmg_pl_comb_fu tab[]" );

d1269 1
d1289 2
a1290 1
	struct nmg_ptbl	b;
d1292 6
a1298 2
		(void)nmg_tbl(&b, TBL_INIT, (long *)NULL);

d1306 1
a1306 1
		(void)nmg_pl_fu(fp, fu1, &b, 100, 100, 180);
d1308 1
a1308 1
			(void)nmg_pl_fu(fp, fu1->fumate_p, &b, 100, 100, 180);
d1310 1
a1310 1
		(void)nmg_pl_fu(fp, fu2, &b, 100, 100, 180);
d1312 1
a1312 1
			(void)nmg_pl_fu(fp, fu2->fumate_p, &b, 100, 100, 180);
a1314 1
		(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
a1318 2
		long			*tab;
		struct model		*m;
a1319 5
		m = nmg_find_model( &fu1->l.magic );
		NMG_CK_MODEL(m);
		/* get space for list of items processed */
		tab = (long *)rt_calloc( m->maxindex+1, sizeof(long),
			"nmg_pl_2fu tab[]");
d1322 1
a1322 1
		nmg_vlblock_fu( vbp, fu1, tab, 100, 100, 180, 1);
d1324 1
a1324 1
			nmg_vlblock_fu( vbp, fu1->fumate_p, tab, 100, 100, 180, 1);
d1326 1
a1326 1
		nmg_vlblock_fu( vbp, fu2, tab, 100, 100, 180, 1);
d1328 1
a1328 1
			nmg_vlblock_fu( vbp, fu2->fumate_p, tab, 100, 100, 180, 1);
a1329 2
		rt_free( (char *)tab, "nmg_pl_2fu tab[]" );

d1336 1
@


1.19
log
@Added slight delay.
Alas, this does not seem to make any difference.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.18 91/02/07 20:32:43 mike Exp $ (BRL)";
a32 6

/* Move to vmath.h */
#define VJOIN3(a,b,c,d,e,f,g,h)	\
	(a)[X] = (b)[X] + (c)*(d)[X] + (e)*(f)[X] + (g)*(h)[X];\
	(a)[Y] = (b)[Y] + (c)*(d)[Y] + (e)*(f)[Y] + (g)*(h)[Y];\
	(a)[Z] = (b)[Z] + (c)*(d)[Z] + (e)*(f)[Z] + (g)*(h)[Z]
@


1.18
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.17 91/01/28 23:53:01 mike Exp $ (BRL)";
d32 2
d1264 1
a1264 1
			(*nmg_vlblock_anim_upcall)( vbp, 0 );
d1337 1
a1337 1
			(*nmg_vlblock_anim_upcall)( vbp, 0 );
@


1.17
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.16 91/01/12 08:39:48 mike Exp $ (BRL)";
d161 1
a161 1
struct nmg_list	*eu_hd;
d171 1
a171 1
	for( NMG_LIST( eu, edgeuse, eu_hd ) )  {
d205 1
a205 1
struct nmg_list	*lu_hd;
d215 1
a215 1
	for( NMG_LIST( lu, loopuse, lu_hd ) )  {
d223 1
a223 1
		if( NMG_LIST_FIRST_MAGIC(&lu->down_hd)==NMG_VERTEXUSE_MAGIC )  {
d225 1
a225 1
			vu = NMG_LIST_FIRST(vertexuse, &lu->down_hd);
d234 1
a234 1
		for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d318 1
a318 1
	for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
d353 1
a353 1
	for( NMG_LIST( s, shell, &r->s_hd ) )  {
d422 1
a422 1
	prev_eu = NMG_LIST_PLAST_CIRC( edgeuse, eu );
d426 1
a426 1
		prev_eu = NMG_LIST_PLAST_CIRC( edgeuse, prev_eu );
d432 2
a433 2
	next_eu = NMG_LIST_PNEXT_CIRC( edgeuse, eu );
	final_eu = NMG_LIST_PNEXT_CIRC( edgeuse, next_eu );
d437 1
a437 1
		final_eu = NMG_LIST_PNEXT_CIRC( edgeuse, final_eu );
d538 1
a538 1
	eulast = NMG_LIST_PLAST_CIRC( edgeuse, eu );
d569 1
a569 1
	nexteu = NMG_LIST_PNEXT_CIRC( edgeuse, eu );
d718 1
a718 1
	magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
d721 1
a721 1
	    	nmg_pl_v(fp, NMG_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p, b);
d723 1
a723 1
		for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d743 1
a743 1
	for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
d770 1
a770 1
	for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
d775 1
a775 1
	for( NMG_LIST( lu, loopuse, &s->lu_hd ) )  {
d780 1
a780 1
	for( NMG_LIST( eu, edgeuse, &s->eu_hd ) )  {
d790 3
a792 3
	if( NMG_LIST_IS_EMPTY( &s->fu_hd ) &&
	    NMG_LIST_IS_EMPTY( &s->lu_hd ) &&
	    NMG_LIST_IS_EMPTY( &s->eu_hd ) && !s->vu_p) {
d808 1
a808 1
	for( NMG_LIST( s, shell, &r->s_hd ) )  {
d822 1
a822 1
	for( NMG_LIST( r, nmgregion, &m->r_hd ) )  {
d983 1
a983 1
	magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
d986 1
a986 1
	    	nmg_vlblock_v(vbp, NMG_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p, tab);
d988 1
a988 1
		for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d1008 1
a1008 1
	for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
d1041 1
a1041 1
	for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
d1046 1
a1046 1
	for( NMG_LIST( lu, loopuse, &s->lu_hd ) )  {
d1056 1
a1056 1
	for( NMG_LIST( eu, edgeuse, &s->eu_hd ) )  {
d1084 1
a1084 1
	for( NMG_LIST( s, shell, &r->s_hd ) )  {
d1099 1
a1099 1
	for( NMG_LIST( r, nmgregion, &m->r_hd ) )  {
d1185 1
a1185 1
	for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
d1187 1
a1187 1
		for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
d1189 1
a1189 1
			magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
d1191 1
a1191 1
				for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
@


1.16
log
@plot3.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.15 90/12/05 06:12:39 mike Exp $ (BRL)";
d51 1
a51 1
struct vlblock *
d54 1
a54 1
	struct vlblock *vbp;
d57 7
a63 5
	GETSTRUCT( vbp, vlblock );
	vbp->count = 32;
	vbp->cvp = (struct color_vlhead *)rt_malloc(
		vbp->count * sizeof(struct color_vlhead),
		"color_vlhead[]");
d65 3
a67 4
	for( i=0; i < vbp->count; i++ )  {
		vbp->cvp[i].rgb = 0;	/* black, unused */
		vbp->cvp[i].head.vh_first = VL_NULL;
		vbp->cvp[i].head.vh_last = VL_NULL;
d69 3
a71 2
	vbp->cvp[0].rgb = 0xFFFF00L;	/* Yellow, default */
	vbp->cvp[1].rgb = 0xFFFFFFL;	/* White */
d78 1
a78 1
struct vlblock *vbp;
d82 1
a82 1
	for( i=0; i < vbp->count; i++ )  {
d84 3
a86 3
		if( vbp->cvp[i].rgb == 0 )  continue;
		if( vbp->cvp[i].head.vh_first == VL_NULL) continue;
		FREE_VL( vbp->cvp[i].head.vh_first );
d89 3
a91 2
	rt_free( (char *)(vbp->cvp), "color_vlhead[]" );
	rt_free( (char *)vbp, "vlblock" );
d94 1
a94 1
struct vlhead *
d96 1
a96 1
struct vlblock *vbp;
d105 1
a105 1
	if( new == 0 ) return( &vbp->cvp[0].head );
d107 3
a109 8
	for( n=0; n < vbp->count; n++ )  {
		if( vbp->cvp[n].rgb == 0 )  {
			/* Allocate empty slot */
			vbp->cvp[n].rgb = new;
			return( &vbp->cvp[n].head );
		}
		if( vbp->cvp[n].rgb == new )
			return( &vbp->cvp[n].head );
d111 6
d121 1
a121 1
	return( &vbp->cvp[0].head );
d136 1
a136 1
struct vlhead		*vhead;
d149 2
a150 2
		ADD_VL( vhead, vg->coord, VL_CMD_LINE_MOVE );
		ADD_VL( vhead, vg->coord, VL_CMD_LINE_DRAW );
d160 1
a160 1
struct vlhead	*vhead;
d193 2
a194 2
		ADD_VL( vhead, vg->coord, VL_CMD_LINE_MOVE );
		ADD_VL( vhead, vgmate->coord, VL_CMD_LINE_DRAW );
d204 1
a204 1
struct vlhead	*vhead;
d251 2
a252 2
					ADD_VL( vhead, normal, VL_CMD_POLY_START );
					ADD_VL( vhead, vg->coord, VL_CMD_POLY_MOVE );
d255 1
a255 1
					ADD_VL( vhead, vg->coord, VL_CMD_LINE_MOVE );
d261 1
a261 1
					ADD_VL( vhead, vg->coord, VL_CMD_POLY_DRAW );
d264 1
a264 1
					ADD_VL( vhead, vg->coord, VL_CMD_LINE_DRAW );
d273 1
a273 1
				ADD_VL( vhead, first_vg->coord, VL_CMD_POLY_END );
d276 1
a276 1
				ADD_VL( vhead, first_vg->coord, VL_CMD_LINE_DRAW );
d285 1
a285 1
			ADD_VL( vhead, centroid, VL_CMD_LINE_MOVE );
d290 1
a290 1
			ADD_VL( vhead, centroid, VL_CMD_LINE_DRAW );
d307 1
a307 1
struct vlhead	*vhead;
d346 1
a346 1
struct vlhead	*vhead;
d837 1
a837 1
struct vlblock	*vbp;
d843 1
a843 1
	struct vlhead	*vh;
d859 2
a860 2
	ADD_VL( vh, p, VL_CMD_LINE_MOVE );
	ADD_VL( vh, p, VL_CMD_LINE_DRAW );
d867 1
a867 1
struct vlblock	*vbp;
d876 1
a876 1
	struct vlhead	*vh;
d901 2
a902 2
	ADD_VL( vh, end0, VL_CMD_LINE_MOVE );
	ADD_VL( vh, end1, VL_CMD_LINE_DRAW );
d912 1
a912 1
struct vlblock	*vbp;
d922 1
a922 1
	struct vlhead	*vh;
d952 2
a953 2
		ADD_VL( vh, base, VL_CMD_LINE_MOVE );
		ADD_VL( vh, tip, VL_CMD_LINE_DRAW );
d957 2
a958 2
		ADD_VL( vh, tip, VL_CMD_LINE_MOVE );
		ADD_VL( vh, radial_tip, VL_CMD_LINE_DRAW );
d962 2
a963 2
		ADD_VL( vh, tip, VL_CMD_LINE_MOVE );
		ADD_VL( vh, next_base, VL_CMD_LINE_DRAW );
d1246 3
a1248 3
		struct vlblock	*vbp;
		long		*tab;
		struct model	*m;
d1312 3
a1314 3
		struct vlblock *vbp;
		long		*tab;
		struct model	*m;
@


1.15
log
@lint
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.14 90/05/31 00:06:59 butler Exp $ (BRL)";
d28 1
d30 1
a30 1
#include "nmg.h"
@


1.14
log
@added arguments red, green, blue to nmg_pl_fu in nmg_plot.c so that
all the calls we make to this function now have the right number of
parameters.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_plot.c,v 1.13 90/05/25 18:50:31 mike Exp $ (BRL)";
d458 1
a458 1
static nmg_eu_coords(eu, base, tip60)
d861 1
a861 1
static nmg_vlblock_e(vbp, e, tab, red, green, blue, fancy)
d1207 1
@


1.13
log
@Added "fancy" flag to vlblock drawing routines.
When fancy is set, all the uses are drawn, as before.
When fancy is zero, only the edges and vertices are drawn;
this is *much* faster, and for the boolean evaluation stage,
easier to understand (although less pretty).
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.12 90/05/25 07:15:09 mike Exp $ (BRL)";
d727 1
a727 1
void nmg_pl_fu(fp, fu, b)
d731 1
d739 1
a739 1
		nmg_pl_lu(fp, lu, b, 80, 100, 170 );
d767 1
a767 1
		nmg_pl_fu(fp, fu, &b );
@


1.12
log
@Slightly more efficient version.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.11 90/05/25 02:46:34 mike Exp $ (BRL)";
d860 1
a860 1
static nmg_vlblock_e(vbp, e, tab, red, green, blue)
d865 1
d905 1
a905 1
void nmg_vlblock_eu(vbp, eu, tab, red, green, blue)
d910 1
d930 1
a930 1
	nmg_vlblock_e(vbp, eu->e_p, tab, red, green, blue);
d932 2
d964 1
a964 1
void nmg_vlblock_lu(vbp, lu, tab, red, green, blue)
d969 1
d983 1
a983 1
			nmg_vlblock_eu(vbp, eu, tab, red, green, blue);
d991 1
a991 1
void nmg_vlblock_fu(vbp, fu, tab)
d995 1
d1003 7
a1009 1
		nmg_vlblock_lu(vbp, lu, tab, 80, 100, 170 );
d1016 1
a1016 1
void nmg_vlblock_s(vbp, s)
d1018 2
a1019 1
struct shell *s;
d1037 1
a1037 1
		nmg_vlblock_fu(vbp, fu, tab );
d1042 6
a1047 1
		nmg_vlblock_lu(vbp, lu, tab, 255, 0, 0);
d1054 6
a1059 1
		nmg_vlblock_eu(vbp, eu, tab, 200, 200, 0 );
d1071 1
a1071 1
void nmg_vlblock_r(vbp, r)
d1074 1
d1079 1
a1079 1
		nmg_vlblock_s(vbp, s);
d1086 1
a1086 1
void nmg_vlblock_m(vbp, m)
d1088 2
a1089 1
struct model *m;
d1094 1
a1094 1
		nmg_vlblock_r(vbp, r);
d1250 1
a1250 1
		nmg_vlblock_fu(vbp, fu1, tab, 200, 200, 200);
d1316 1
a1316 1
		nmg_vlblock_fu( vbp, fu1, tab, 100, 100, 180);
d1318 1
a1318 1
			nmg_vlblock_fu( vbp, fu1->fumate_p, tab, 100, 100, 180);
d1320 1
a1320 1
		nmg_vlblock_fu( vbp, fu2, tab, 100, 100, 180);
d1322 1
a1322 1
			nmg_vlblock_fu( vbp, fu2->fumate_p, tab, 100, 100, 180);
@


1.11
log
@Minor efficiency improvement.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.10 90/05/25 01:08:45 mike Exp $ (BRL)";
d31 6
d362 1
a362 1
 *			N M G _ E U _ C O O R D
d364 3
a366 2
 *  Given an edgeuse structure, return the coordinates of the "base point"
 *  of this edge.  This base point will be offset inwards along the edge
d370 12
d383 5
a387 3
static void nmg_eu_coord(eu, base)
struct edgeuse *eu;
point_t base;
d389 11
a399 7
	fastf_t dist1;
	struct edgeuse *peu;
	struct loopuse *lu;
	vect_t v_eu,		/* vector of edgeuse */
		v_other,	/* vector of last edgeuse */
		N;		/* normal vector for this edgeuse's face */
	pointp_t pt_other, pt_eu;
d411 4
a414 2
	pt_eu = eu->vu_p->v_p->vg_p->coord;
	pt_other = eu->eumate_p->vu_p->v_p->vg_p->coord;
d416 8
a423 4
	if (*eu->up.magic_p != NMG_LOOPUSE_MAGIC ||
	    *eu->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC) {
		rt_log("in %s at %d edgeuse has bad parent\n", __FILE__, __LINE__);
		rt_bomb("nmg_eu_coord\n");
d426 9
a434 7
	lu = eu->up.lu_p;
	NMG_CK_FACE(lu->up.fu_p->f_p);
	NMG_CK_FACE_G(lu->up.fu_p->f_p->fg_p);

	VMOVE(N, lu->up.fu_p->f_p->fg_p->N);
	if (lu->up.fu_p->orientation == OT_OPPOSITE) {
		VREVERSE(N,N);
d437 3
a439 5
	/* v_eu is the vector of the edgeuse
	 * mag is the magnitude of the edge vector
	 */
	VSUB2(v_eu, pt_other, pt_eu); 
	VUNITIZE(v_eu);
d441 2
a442 9
	/* find a point not on the edge */
	peu = NMG_LIST_PLAST_CIRC( edgeuse, eu );
	pt_other = peu->vu_p->v_p->vg_p->coord;
	dist1 = rt_dist_line_point(pt_eu, v_eu, pt_other);
	while (NEAR_ZERO(dist1, LEE_DIVIDE_TOL) && peu != eu) {
		peu = NMG_LIST_PLAST_CIRC( edgeuse, peu );
		pt_other = peu->vu_p->v_p->vg_p->coord;
		dist1 = rt_dist_line_point(pt_eu, v_eu, pt_other);
	}
d444 1
a444 10
	/* make a vector from the "last" edgeuse (reversed) */
	VSUB2(v_other, pt_other, pt_eu); VUNITIZE(v_other);

	/* combine the two vectors to get a vector
	 * pointing to the location where the edgeuse
	 * should start
	 */
	VADD2(v_other, v_other, v_eu); VUNITIZE(v_other);

	/* XXX vector lengths should be scaled by 5% of face size */
d446 2
a447 2
	/* compute the start of the edgeuse */
	VJOIN2(base, pt_eu, 0.125,v_other, 0.05,N);
d477 11
a487 5
	    	register struct edgeuse *eutmp;
		nmg_eu_coord(eu, base);
		eutmp = NMG_LIST_PNEXT_CIRC(edgeuse, eu);
		NMG_CK_EDGEUSE(eutmp);
		nmg_eu_coord( eutmp, tip );
d631 1
a631 1
	VREVERSE(v, v);
a632 2
	VADD2(end1, p1, v);

d891 1
a891 3
	VREVERSE(v, v);

	VADD2(end1, p1, v);
@


1.10
log
@Converted vlblock plotting over to using table & structure index
stuff, rather than nmg_tbl().  Much faster!
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.9 90/05/24 20:26:29 mike Exp $ (BRL)";
a388 7
	if (*eu->up.magic_p == NMG_SHELL_MAGIC || 
	    (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
	     *eu->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC) ) {
	     	/* Wire edge, or edge in wire loop */
		VMOVE(base, pt_eu);
		return;
	}
a450 1
	nmg_eu_coord(eu, base);
d455 1
d457 1
a457 1
		nmg_eu_coord( eu->eumate_p, tip );
d463 1
@


1.9
log
@Changed to TBL_INS_UNIQUE
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.8 90/05/24 19:02:53 mike Exp $ (BRL)";
d31 4
d817 1
a817 1
static void nmg_vlblock_v(vbp, v, b)
d819 2
a820 2
struct vertex *v;
struct nmg_ptbl *b;
d826 2
a827 1
	if (nmg_tbl(b, TBL_INS_UNIQUE, &v->magic) >= 0) return;
a828 1
	NMG_CK_VERTEX(v);
d847 1
a847 1
static nmg_vlblock_e(vbp, e, b, red, green, blue)
d850 1
a850 1
struct nmg_ptbl	*b;
d858 2
a859 1
	if (nmg_tbl(b, TBL_INS_UNIQUE, &e->magic) >= 0) return;
d886 2
a887 2
	nmg_vlblock_v(vbp, e->eu_p->vu_p->v_p, b);
	nmg_vlblock_v(vbp, e->eu_p->eumate_p->vu_p->v_p, b);
d893 1
a893 1
void nmg_vlblock_eu(vbp, eu, b, red, green, blue)
d896 1
a896 1
struct nmg_ptbl *b;
d906 2
d917 1
a917 1
	if (nmg_tbl(b, TBL_INS_UNIQUE, &eu->l.magic) >= 0) return;
a918 2
	nmg_vlblock_e(vbp, eu->e_p, b, red, green, blue);

d949 1
a949 1
void nmg_vlblock_lu(vbp, lu, b, red, green, blue)
d952 1
a952 1
struct nmg_ptbl	*b;
d959 1
a959 1
	if (nmg_tbl(b, TBL_INS_UNIQUE, &lu->l.magic) >= 0) return;
d964 1
a964 1
	    	nmg_vlblock_v(vbp, NMG_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p, b);
d967 1
a967 1
			nmg_vlblock_eu(vbp, eu, b, red, green, blue);
d975 1
a975 1
void nmg_vlblock_fu(vbp, fu, b)
d978 1
a978 1
struct nmg_ptbl *b;
d983 1
a983 1
	if (nmg_tbl(b, TBL_INS_UNIQUE, &fu->l.magic) >= 0) return;
d986 1
a986 1
		nmg_vlblock_lu(vbp, lu, b, 80, 100, 170 );
d1000 2
a1001 1
	struct nmg_ptbl b;
d1004 2
d1008 2
a1009 1
	(void)nmg_tbl(&b, TBL_INIT, (long *)0);	
d1013 1
a1013 1
		nmg_vlblock_fu(vbp, fu, &b );
d1018 1
a1018 1
		nmg_vlblock_lu(vbp, lu, &b, 255, 0, 0);
d1025 1
a1025 1
		nmg_vlblock_eu(vbp, eu, &b, 200, 200, 0 );
d1028 1
a1028 1
		nmg_vlblock_v(vbp, s->vu_p->v_p, &b );
d1031 1
a1031 7
	if( NMG_LIST_IS_EMPTY( &s->fu_hd ) &&
	    NMG_LIST_IS_EMPTY( &s->lu_hd ) &&
	    NMG_LIST_IS_EMPTY( &s->eu_hd ) && !s->vu_p) {
	    	rt_log("WARNING nmg_vlblock_s() shell has no children\n");
	}

	(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
d1203 3
a1205 2
		extern void (*nmg_vlblock_anim_upcall)();
		struct vlblock *vbp;
d1207 5
a1211 1
		(void)nmg_tbl(&tbl, TBL_INIT, (long *)NULL);
d1214 1
a1214 1
		nmg_vlblock_fu(vbp, fu1, &tbl, 200, 200, 200);
d1216 1
a1216 1
		(void)nmg_tbl(&tbl, TBL_FREE, (long *)NULL);
a1224 1

d1270 2
d1273 5
a1277 1
		(void)nmg_tbl(&b, TBL_INIT, (long *)NULL);
d1280 1
a1280 1
		nmg_vlblock_fu( vbp, fu1, &b, 100, 100, 180);
d1282 1
a1282 1
			nmg_vlblock_fu( vbp, fu1->fumate_p, &b, 100, 100, 180);
d1284 1
a1284 1
		nmg_vlblock_fu( vbp, fu2, &b, 100, 100, 180);
d1286 1
a1286 1
			nmg_vlblock_fu( vbp, fu2->fumate_p, &b, 100, 100, 180);
d1288 1
a1288 1
		(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
a1293 1

@


1.8
log
@Changed rgb args from char to int.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.7 90/05/24 03:57:51 mike Exp $ (BRL)";
d565 1
a565 1
	if (nmg_tbl(b, TBL_LOC, &v->magic) >= 0) return;
a566 2
	(void)nmg_tbl(b, TBL_INS, &v->magic);

d593 1
a593 3
	if (nmg_tbl(b, TBL_LOC, &e->magic) >= 0) return;

	(void)nmg_tbl(b, TBL_INS, &e->magic);
d647 1
a647 2
	if (nmg_tbl(b, TBL_LOC, &eu->l.magic) >= 0) return;
	(void)nmg_tbl(b, TBL_INS, &eu->l.magic);
d694 1
a694 1
	if (nmg_tbl(b, TBL_LOC, &lu->l.magic) >= 0) return;
a695 2
	(void)nmg_tbl(b, TBL_INS, &lu->l.magic);

d718 1
a718 2
	if (nmg_tbl(b, TBL_LOC, &fu->l.magic) >= 0) return;
	(void)nmg_tbl(b, TBL_INS, &fu->l.magic);
d822 1
a822 1
	if (nmg_tbl(b, TBL_LOC, &v->magic) >= 0) return;
a823 2
	(void)nmg_tbl(b, TBL_INS, &v->magic);

d854 1
a854 3
	if (nmg_tbl(b, TBL_LOC, &e->magic) >= 0) return;

	(void)nmg_tbl(b, TBL_INS, &e->magic);
d910 1
a910 2
	if (nmg_tbl(b, TBL_LOC, &eu->l.magic) >= 0) return;
	(void)nmg_tbl(b, TBL_INS, &eu->l.magic);
d954 1
a954 1
	if (nmg_tbl(b, TBL_LOC, &lu->l.magic) >= 0) return;
a955 2
	(void)nmg_tbl(b, TBL_INS, &lu->l.magic);

d978 1
a978 2
	if (nmg_tbl(b, TBL_LOC, &fu->l.magic) >= 0) return;
	(void)nmg_tbl(b, TBL_INS, &fu->l.magic);
@


1.7
log
@Absorbed two additional plotting functions.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.6 90/05/24 03:04:08 mike Exp $ (BRL)";
d585 5
a589 5
static nmg_pl_e(fp, e, b, R, G, B)
FILE *fp;
struct edge *e;
struct nmg_ptbl *b;
unsigned char R, G, B;
d620 1
a620 1
	pl_color(fp, R, G, B);
d630 5
a634 5
void nmg_pl_eu(fp, eu, b, R, G, B)
FILE *fp;
struct edgeuse *eu;
struct nmg_ptbl *b;
unsigned char R, G, B;
d654 1
a654 1
	nmg_pl_e(fp, eu->e_p, b, R, G, B);
d661 1
a661 1
	    		R += 50;
d663 1
a663 1
			R -= 50;
d665 1
a665 1
	    		R = G = B = (unsigned char)255;
d667 1
a667 1
		pl_color(fp, R, G, B);
d671 1
a671 1
		pl_color(fp, R, G-20, B);
d689 5
a693 5
void nmg_pl_lu(fp, lu, b, R, G, B)
FILE *fp;
struct loopuse *lu;
struct nmg_ptbl *b;
unsigned char R, G, B;
d709 1
a709 1
			nmg_pl_eu(fp, eu, b, R, G, B);
d853 1
a853 1
static nmg_vlblock_e(vbp, e, b, R, G, B)
d855 3
a857 3
struct edge *e;
struct nmg_ptbl *b;
unsigned char R, G, B;
d889 1
a889 1
	vh = rt_vlblock_find( vbp, R, G, B );
d900 1
a900 1
void nmg_vlblock_eu(vbp, eu, b, R, G, B)
d902 1
a902 1
struct edgeuse *eu;
d904 1
a904 1
int		R, G, B;
d925 1
a925 1
	nmg_vlblock_e(vbp, eu->e_p, b, R, G, B);
d932 1
a932 1
	    		R += 50;
d934 1
a934 1
			R -= 50;
d936 1
a936 1
	    		R = G = B = (unsigned char)255;
d938 1
a938 1
		vh = rt_vlblock_find( vbp, R, G, B );
d943 1
a943 1
		vh = rt_vlblock_find( vbp, R, G-20, B );
d957 1
a957 1
void nmg_vlblock_lu(vbp, lu, b, R, G, B)
d959 3
a961 3
struct loopuse *lu;
struct nmg_ptbl *b;
unsigned char R, G, B;
d977 1
a977 1
			nmg_vlblock_eu(vbp, eu, b, R, G, B);
@


1.6
log
@Added nmg_vlblock_*() routines
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.5 90/05/24 02:18:49 mike Exp $ (BRL)";
d31 3
d889 1
a889 1
	vh = rt_vlblock_find( vbp, 255, 255, 255 );
d1176 124
@


1.5
log
@Added vlblock routines
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.4 90/05/23 22:05:58 mike Exp $ (BRL)";
d766 1
a766 3
		nmg_pl_eu(fp, eu, &b, (unsigned char)200, 
			(unsigned char)200, 
			(unsigned char)0);
d806 263
@


1.4
log
@Added "space" directives to plot file.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.3 90/05/23 21:47:43 mike Exp $ (BRL)";
d30 75
@


1.3
log
@More neatness
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.2 90/05/23 21:18:14 mike Exp $ (BRL)";
d669 4
d812 5
@


1.2
log
@A bit more tidy now, no change in functionality.
(At least, none intended).
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_plot.c,v 1.1 90/05/23 19:43:05 mike Exp $ (BRL)";
d479 1
a479 1
static void nmg_pl_v(fp, v, b, R, G, B)
a482 1
unsigned char R, G, B;
d494 1
a495 2

	pd_3move(fp, p[0], p[1], p[2]);
d498 1
d501 1
a501 4
	pd_3point(fp, p[0], p[1], p[2]);


	pl_color(fp, R, G, B);
d543 4
a546 3
	pd_3line(fp, end0[0], end0[1], end0[2], end1[0], end1[1], end1[2]);
	nmg_pl_v(fp, e->eu_p->vu_p->v_p, b, R, G, B);
	nmg_pl_v(fp, e->eu_p->eumate_p->vu_p->v_p, b, R, G, B);
d628 1
a628 2
	    	nmg_pl_v(fp, NMG_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p,
	    		b, R, G, B );
d639 1
a639 1
void nmg_pl_fu(fp, fu, b, R, G, B)
a642 1
unsigned char R, G, B;
d651 1
a651 1
		nmg_pl_lu(fp, lu, b, R, G, B);
d675 1
a675 1
		nmg_pl_fu(fp, fu, &b, 80, 100, 170);
d692 1
a692 1
		nmg_pl_v(fp, s->vu_p->v_p, &b, 180, 180, 180);
d748 1
d795 1
a795 1
	FILE *fd, *fopen();
d800 1
a800 1
	if ((fd=fopen(filename, "w")) == (FILE *)NULL) {
d816 1
a816 1
					nmg_pl_edges_in_2_shells(fd, &b, eu);
d827 1
a827 1
	(void)fclose(fd);
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d273 9
a306 5
	/* v_eu is the vector of the edgeuse
	 * mag is the magnitude of the edge vector
	 */
	VSUB2(v_eu, pt_other, pt_eu); 

d310 1
a310 1

a311 10
	     	dist1 = MAGNITUDE(v_eu);
	     	/* whichever component of the edge is the least significant,
	     	 * we perturb 
	     	if (base[0] <= base[1] && base[0] <= base[2])
	     		base[0] += dist1 * 0.1;
	     	else if (base[1] <= base[0] && base[1] <= base[2])
	     		base[1] += dist1 * 0.1;
	     	else if (base[2] <= base[1] && base[2] <= base[0])
	     		base[2] += dist1 * 0.1;
	     	*/
a313 1

a320 1

a323 4
#ifdef DEBUG_PLEU
	HPRINT("Normal", lu->up.fu_p->f_p->fg_p->N);
	nmg_pr_orient(lu->up.fu_p->orientation, "");
#endif
a327 3
#ifdef DEBUG_PLEU
	VPRINT("Adjusted Normal", N);
#endif
d329 4
d353 2
d363 4
a366 1
 *	compute a pair of coordinates for representing an edgeuse
d368 1
a368 1
static nmg_eu_coords(eu, base, tip)
d370 1
a370 1
point_t base, tip;
d372 1
a372 1
	vect_t eu_vec;
d380 1
a380 1

d386 1
d392 1
a392 1
		rt_bomb("nmg_eu_coords: What's going on?\n");
d394 1
a394 5
	/* compute edgeuse vector */
	VSUB2SCALE(eu_vec, tip, base, 0.6);

	/* compute tip location from edgeuse vector */
	VADD2(tip, base, eu_vec);
d399 2
d402 1
a402 2
static void nmg_eu_radial(fp, eu, tip, R, G, B)
FILE *fp;
a404 1
unsigned char R, G, B;
d406 1
a406 2
	point_t b2, t2, p;
	vect_t v;
d415 2
a416 9
	/* form vector of other edgeuse and scale down */
	VSUB2SCALE(v, t2, b2, 0.8);

	/* find point along other edgeuse where radial pointer should touch */
	VADD2(p, b2, v);

	pl_color(fp, R, G-20, B);
	pd_3line(fp, tip[0], tip[1], tip[2], p[0], p[1], p[2]);
	pl_color(fp, R, G, B);
d421 2
d424 3
a426 4
static void nmg_eu_last(fp, eu, base)
FILE *fp;
struct edgeuse *eu;
point_t base;
d428 5
a432 1
	point_t b2, t2, p;
a433 1
	vect_t v;
d442 1
a442 1
	nmg_eu_coords(eulast->radial_p, b2, t2);
d444 2
a445 2
	/* form vector of last edgeuse's radial edgeuse and scale down */
	VSUB2SCALE(v, t2, b2, 0.8);
a446 5
	/* find point along last edgeuse's radial edgeuse
	 * where radial pointer should touch 
	 */
	VADD2(p, b2, v);

d448 1
a448 1
	nmg_eu_coords(eulast, b2, t2);
d450 2
a451 10
	/* form vector of last edgeuse's radial pointer and scale down */
	VSUB2SCALE(v, p, t2, 0.2);

	/* find point along other edgeuse's radial pointer where 
	 * last pointer should touch
	 */
	VADD2(p, t2, v);

	pl_color(fp, 0, 200, 0);
	pd_3line(fp, base[0], base[1], base[2], p[0], p[1], p[2]);
d456 2
d459 3
a461 4
static void nmg_eu_next(fp, eu, tip)
FILE *fp;
struct edgeuse *eu;
point_t tip;
d463 1
a463 1
	point_t b2, t2;
d473 1
a473 4
	nmg_eu_coords(nexteu, b2, t2);

	pl_color(fp, 0, 100, 0);
	pd_3line(fp, tip[0], tip[1], tip[2], b2[0], b2[1], b2[2]);
d562 3
a565 2
	

d593 1
d595 3
a597 2
		pd_3line(fp, base[0], base[1], base[2],
			tip[0], tip[1], tip[2]);
d599 3
d603 5
a607 3
	    	nmg_eu_radial(fp, eu, tip, R, G, B);
	    	nmg_eu_next(fp, eu, tip);
/*	    	nmg_eu_last(fp, eu, base); */
@
