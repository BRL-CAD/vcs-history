head	11.31;
access;
symbols
	ansi-20040405-merged:11.26.2.2
	postmerge-20040405-ansi:11.28
	premerge-20040404-ansi:11.27
	postmerge-autoconf:11.27
	autoconf-freeze:11.26.10.2
	premerge-autoconf:11.27
	ansi-20040316-freeze:11.26.2.1
	postmerge-20040315-windows:11.27
	premerge-20040315-windows:11.27
	windows-20040315-freeze:11.26.4.1
	autoconf-20031203:11.26
	autoconf-20031202:11.26
	autoconf-branch:11.26.0.10
	phong-branch:11.26.0.8
	photonmap-branch:11.26.0.6
	rel-6-1-DP:11.26
	windows-branch:11.26.0.4
	rel-6-0-2:11.24
	ansi-branch:11.26.0.2
	rel-6-0-1-branch:11.24.0.2
	hartley-6-0-post:11.25
	hartley-6-0-pre:11.24
	rel-6-0-1:11.24
	rel-6-0:11.24
	rel-5-4:11.7.2.5
	offsite-5-3-pre:11.17
	rel-5-3:11.7.2.4
	rel-5-2:11.7.2.2
	rel-5-1-branch:11.7.0.2
	rel-5-1:11.7;
locks; strict;
comment	@ * @;


11.31
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	11.30;

11.30
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.29;

11.29
date	2004.05.10.15.25.27;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2004.02.02.17.39.19;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2002.08.20.17.07.58;	author jra;	state Exp;
branches
	11.26.2.1
	11.26.4.1
	11.26.10.1;
next	11.25;

11.25
date	2002.08.15.20.55.11;	author hartley;	state Exp;
branches;
next	11.24;

11.24
date	2001.10.02.19.24.28;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	2001.07.26.14.02.12;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	2001.07.09.20.50.53;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	2001.06.21.18.07.25;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	2001.04.20.22.29.43;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2001.04.13.15.13.29;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	2001.03.19.22.19.57;	author butler;	state Exp;
branches;
next	11.17;

11.17
date	2000.12.07.13.32.11;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	2000.09.12.14.41.10;	author pjt;	state Exp;
branches;
next	11.15;

11.15
date	2000.08.23.08.41.50;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.08.22.21.21.53;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.08.21.02.02.29;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	2000.08.17.14.17.57;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	2000.07.10.23.01.30;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.06.30.15.38.02;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.06.30.15.31.14;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.06.29.18.21.10;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	2000.04.12.02.34.31;	author mike;	state Exp;
branches
	11.7.2.1;
next	11.6;

11.6
date	2000.03.03.21.29.08;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	2000.03.03.18.16.41;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	2000.03.03.13.47.26;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	2000.03.02.18.32.39;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	2000.03.02.15.44.49;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	2000.03.02.14.47.28;	author jra;	state Exp;
branches;
next	;

11.7.2.1
date	2000.08.17.15.23.52;	author jra;	state Exp;
branches;
next	11.7.2.2;

11.7.2.2
date	2000.08.24.13.32.52;	author jra;	state Exp;
branches;
next	11.7.2.3;

11.7.2.3
date	2000.10.30.18.21.38;	author jra;	state Exp;
branches;
next	11.7.2.4;

11.7.2.4
date	2000.11.22.13.35.35;	author jra;	state Exp;
branches;
next	11.7.2.5;

11.7.2.5
date	2001.07.11.12.31.52;	author jra;	state Exp;
branches;
next	;

11.26.2.1
date	2002.09.19.18.01.32;	author morrison;	state Exp;
branches;
next	11.26.2.2;

11.26.2.2
date	2004.03.17.21.18.45;	author morrison;	state Exp;
branches;
next	;

11.26.4.1
date	2004.03.11.23.43.37;	author morrison;	state Exp;
branches;
next	;

11.26.10.1
date	2004.02.12.18.37.40;	author erikg;	state Exp;
branches;
next	11.26.10.2;

11.26.10.2
date	2004.03.15.14.07.18;	author erikg;	state Exp;
branches;
next	;


desc
@@


11.31
log
@moved to src/
@
text
@/*
 *			G _ C L I N E . C
 *
 *  Purpose -
 *	Intersect a ray with a FASTGEN4 CLINE element
 *
 *  Authors -
 *  	John Anderson
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 2000-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCScline[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_cline.c,v 11.30 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "tcl.h"
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"

/* ray tracing form of solid, including precomputed terms */
struct cline_specific {
	point_t V;
	vect_t height;
	fastf_t radius;
	fastf_t thickness;
	vect_t h;	/* unitized height */
};

#define	RT_CLINE_O(m)	offsetof( struct rt_cline_internal, m )

const struct bu_structparse rt_cline_parse[] = {
	{ "%f", 3, "V", RT_CLINE_O( v ),  BU_STRUCTPARSE_FUNC_NULL },
	{ "%f", 3, "H", RT_CLINE_O( h ),  BU_STRUCTPARSE_FUNC_NULL },
	{ "%f", 1, "r", RT_CLINE_O( radius ), BU_STRUCTPARSE_FUNC_NULL },
	{ "%f", 1, "t", RT_CLINE_O( thickness ), BU_STRUCTPARSE_FUNC_NULL },
	{ {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
	};

/* shared with do.c */
fastf_t rt_cline_radius=-1.0;

/*
 *  			R T _ C L I N E _ P R E P
 *  
 *  Given a pointer to a GED database record,
 *  determine if this is a valid cline solid, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	cline is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct cline_specific is created, and it's address is stored in
 *  	stp->st_specific for use by rt_cline_shot().
 */
int
rt_cline_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_cline_internal		*cline_ip;
	register struct cline_specific		*cline;
	vect_t					work;
	vect_t					rad;
	point_t					top;
	fastf_t					tmp;
	fastf_t					max_tr;

	RT_CK_DB_INTERNAL(ip);
	cline_ip = (struct rt_cline_internal *)ip->idb_ptr;
	RT_CLINE_CK_MAGIC(cline_ip);

	BU_GETSTRUCT( cline, cline_specific );
	cline->thickness = cline_ip->thickness;
	cline->radius = cline_ip->radius;
	VMOVE( cline->V, cline_ip->v );
	VMOVE( cline->height, cline_ip->h );
	VMOVE( cline->h, cline_ip->h );
	VUNITIZE( cline->h );
	stp->st_specific = (genptr_t)cline;

	if( rt_cline_radius > 0.0 )
		max_tr = rt_cline_radius;
	else
		max_tr = 0.0;
	tmp = MAGNITUDE( cline_ip->h ) * 0.5;
	stp->st_aradius = sqrt( tmp*tmp + cline_ip->radius*cline_ip->radius );
	stp->st_bradius = stp->st_aradius + max_tr;
	VSETALL( stp->st_min, MAX_FASTF );
	VREVERSE( stp->st_max, stp->st_min );

	VSETALL( rad, cline_ip->radius + max_tr );
	VADD2( work, cline_ip->v, rad );
	VMINMAX( stp->st_min,stp->st_max, work );
	VSUB2( work, cline_ip->v, rad );
	VMINMAX( stp->st_min,stp->st_max, work );
	VADD2( top, cline_ip->v, cline_ip->h );
	VADD2( work, top, rad );
	VMINMAX( stp->st_min,stp->st_max, work );
	VSUB2( work, top, rad );
	VMINMAX( stp->st_min,stp->st_max, work );

	return( 0 );
}

/*
 *			R T _ C L I N E _ P R I N T
 */
void
rt_cline_print(register const struct soltab *stp)
{
	register const struct cline_specific *cline =
		(struct cline_specific *)stp->st_specific;

	VPRINT( "V", cline->V );
	VPRINT( "Height", cline->height );
	VPRINT( "Unit Height", cline->h );
	bu_log( "Radius: %g\n", cline->radius );
	if( cline->thickness > 0.0 )
		bu_log( "Plate Mode Thickness: %g\n", cline->thickness );
	else
		bu_log( "Volume mode\n" );
}

/*
 *  			R T _ C L I N E _ S H O T
 *  
 *  Intersect a ray with a cline mode solid.
 *  If an intersection occurs, at least one struct seg will be acquired
 *  and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_cline_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct cline_specific *cline =
		(struct cline_specific *)stp->st_specific;
	struct seg		ref_seghead;
	register struct seg	*segp;
	fastf_t reff;
	fastf_t dist[3];
	fastf_t cosa, sina;
	fastf_t half_los;
	point_t pt1, pt2;
	vect_t diff;
	fastf_t tmp;
	fastf_t distmin, distmax;
	fastf_t add_radius;

	BU_LIST_INIT( &ref_seghead.l );

	/* This is a CLINE FASTGEN element */
	if( rt_cline_radius > 0.0 )
	{
		add_radius = rt_cline_radius;
		reff = cline->radius + add_radius;
	}
	else
	{
		add_radius = 0.0;
		reff = cline->radius;
	}

	cosa = VDOT( rp->r_dir, cline->h );

	if( cosa > 0.0 )
		tmp = cosa - 1.0;
	else
		tmp = cosa + 1.0;

	(void)bn_distsq_line3_line3( dist, cline->V, cline->height,
				     rp->r_pt, rp->r_dir, pt1, pt2 );

	if( NEAR_ZERO( tmp, RT_DOT_TOL ) )
	{
		/* ray is parallel to CLINE */
#if 1
		/* FASTGEN developers claim they report hits on volume mode
		 * when ray is parallel to CLINE axis, but their code drops
		 * this case from consideration before their intersection code
		 * is even called (see SUBROUTINE BULK)
		 */
		return( 0 );
#else

		if( cline->thickness > 0.0 )
			return( 0 );	/* No end-on hits for plate mode cline */

		if( dist[2] > reff*reff )
			return( 0 );	/* missed */

		VJOIN2( diff, cline->V, 1.0, cline->height, -1.0, rp->r_pt );
		dist[0] = VDOT( diff, rp->r_dir );
		if( dist[1] < dist[0] )
		{
			dist[2] = dist[0];
			dist[0] = dist[1];
			dist[1] = dist[2];
		}

		/* vloume mode */

		RT_GET_SEG( segp, ap->a_resource);
		segp->seg_stp = stp;
		segp->seg_in.hit_dist = dist[0];
		segp->seg_in.hit_surfno = 1;
		if( cosa > 0.0 )
			VREVERSE( segp->seg_in.hit_normal, cline->h )
		else
			VMOVE( segp->seg_in.hit_normal, cline->h );

		segp->seg_out.hit_dist = dist[1];
		segp->seg_out.hit_surfno = -1;
		if( cosa < 0.0 )
			VREVERSE( segp->seg_out.hit_normal, cline->h )
		else
			VMOVE( segp->seg_out.hit_normal, cline->h );
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		return( 1 );
#endif
	}

	if( dist[2] > reff*reff )
		return( 0 );	/* missed */


	/* Exactly ==0 and ==1 are hits, not misses */
	if( dist[0] < 0.0 || dist[0] > 1.0 )
		return( 0 );	/* missed */

	sina = sqrt( 1.0 - cosa*cosa);
	tmp = sqrt( dist[2] ) - add_radius;
	if( dist[2] > add_radius * add_radius )
		half_los = sqrt( cline->radius*cline->radius - tmp*tmp) / sina;
	else
		half_los = cline->radius / sina;

	VSUB2( diff, cline->V, rp->r_pt );
	distmin = VDOT( rp->r_dir, diff );
	VADD2( diff, cline->V, cline->height );
	VSUB2( diff, diff, rp->r_pt );
	distmax = VDOT( rp->r_dir, diff );

	if( distmin > distmax )
	{
		tmp = distmin;
		distmin = distmax;
		distmax = tmp;
	}

	distmin -= cline->radius;
	distmax += cline->radius;

	if( cline->thickness <= 0.0 )
	{
		/* volume mode */

		RT_GET_SEG( segp, ap->a_resource);
		segp->seg_stp = stp;
		segp->seg_in.hit_surfno = 2;
		segp->seg_in.hit_dist = dist[1] - half_los;
		if( segp->seg_in.hit_dist < distmin )
			segp->seg_in.hit_dist = distmin;
		VMOVE( segp->seg_in.hit_vpriv, cline->h );

		segp->seg_out.hit_surfno = -2;
		segp->seg_out.hit_dist = dist[1] + half_los;
		if( segp->seg_out.hit_dist > distmax )
			segp->seg_out.hit_dist = distmax;
		VMOVE( segp->seg_out.hit_vpriv, cline->h );
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );

		return( 1 );
	}
	else
	{
		/* plate mode */

		RT_GET_SEG( segp, ap->a_resource);
                        segp->seg_stp = stp;
                        segp->seg_in.hit_surfno = 2;
		segp->seg_in.hit_dist = dist[1] - half_los;
		if( segp->seg_in.hit_dist < distmin )
			segp->seg_in.hit_dist = distmin;
		VMOVE( segp->seg_in.hit_vpriv, cline->h );

		segp->seg_out.hit_surfno = -2;
		segp->seg_out.hit_dist = segp->seg_in.hit_dist + cline->thickness;
		VMOVE( segp->seg_out.hit_vpriv, cline->h );
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );

		RT_GET_SEG( segp, ap->a_resource);
                        segp->seg_stp = stp;
                        segp->seg_in.hit_surfno = 2;
		segp->seg_in.hit_dist = dist[1] + half_los;
		if( segp->seg_in.hit_dist > distmax )
			segp->seg_in.hit_dist = distmax;
		segp->seg_in.hit_dist -=  cline->thickness;
		VMOVE( segp->seg_in.hit_vpriv, cline->h );

		segp->seg_out.hit_surfno = -2;
		segp->seg_out.hit_dist = segp->seg_in.hit_dist + cline->thickness;
		VMOVE( segp->seg_out.hit_vpriv, cline->h );
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );

		return( 2 );
	}
}

#define RT_CLINE_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ C L I N E _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_cline_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	rt_vstub( stp, rp, segp, n, ap );
}

/*
 *  			R T _ C L I N E _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_cline_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	vect_t tmp;
	fastf_t dot;

	if( hitp->hit_surfno == 1 || hitp->hit_surfno == -1 )
		return;

	/* only need to do some calculations for surfno 2 or -2 */

	/* this is wrong, but agrees with FASTGEN */
	VCROSS( tmp, rp->r_dir, hitp->hit_vpriv );
	VCROSS( hitp->hit_normal, tmp, hitp->hit_vpriv );
	VUNITIZE( hitp->hit_normal );
	dot = VDOT( hitp->hit_normal, rp->r_dir );
	if( dot < 0.0 && hitp->hit_surfno < 0 )
		VREVERSE( hitp->hit_normal, hitp->hit_normal )
	else if( dot >  0.0 && hitp->hit_surfno > 0 )
		VREVERSE( hitp->hit_normal, hitp->hit_normal )

	if( MAGNITUDE( hitp->hit_normal ) < 0.9 ) {
		bu_log( "BAD normal for solid %s for ray -p %g %g %g -d %g %g %g\n",
			stp->st_name, V3ARGS( rp->r_pt ), V3ARGS( rp->r_dir ) );
		bu_bomb( "BAD normal\n" );
	}
    	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
}

/*
 *			R T _ C L I N E _ C U R V E
 *
 *  Return the curvature of the cline.
 */
void
rt_cline_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{

	/* for now, don't do curvature */
 	cvp->crv_c1 = cvp->crv_c2 = 0;

	/* any tangent direction */
 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
}

/*
 *  			R T _ C L I N E_ U V
 *  
 *  For a hit on the surface of an cline, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 */
void
rt_cline_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	uvp->uv_u = 0.0;
	uvp->uv_v = 0.0;
	uvp->uv_du = 0.0;
	uvp->uv_dv = 0.0;
}

/*
 *		R T _ C L I N E _ F R E E
 */
void
rt_cline_free(register struct soltab *stp)
{
	register struct cline_specific *cline =
		(struct cline_specific *)stp->st_specific;

	bu_free( (char *)cline, "cline_specific" );
}

/*
 *			R T _ C L I N E _ C L A S S
 */
int
rt_cline_class(const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
{

	return( 0 );
}

/*
 *			R T _ C L I N E _ P L O T
 */
int
rt_cline_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct rt_cline_internal	*cline_ip;
        LOCAL fastf_t           top[16*3];
        LOCAL fastf_t           bottom[16*3];
	point_t top_pt;
	vect_t unit_a, unit_b;
	vect_t a, b;
	fastf_t inner_radius;
	int i;

	RT_CK_DB_INTERNAL(ip);
	cline_ip = (struct rt_cline_internal *)ip->idb_ptr;
	RT_CLINE_CK_MAGIC(cline_ip);

	VADD2( top_pt, cline_ip->v, cline_ip->h );
	bn_vec_ortho( unit_a, cline_ip->h );
	VCROSS( unit_b, unit_a, cline_ip->h );
	VUNITIZE( unit_b );
	VSCALE( a, unit_a, cline_ip->radius );
	VSCALE( b, unit_b, cline_ip->radius );

	rt_ell_16pts( bottom, cline_ip->v, a, b );
	rt_ell_16pts( top, top_pt, a, b );

        /* Draw the top */
        RT_ADD_VLIST( vhead, &top[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
        for( i=0; i<16; i++ )  {
                RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
        }

        /* Draw the bottom */
        RT_ADD_VLIST( vhead, &bottom[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
        for( i=0; i<16; i++ )  {
                RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
        }

        /* Draw connections */
        for( i=0; i<16; i += 4 )  {
                RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
                RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
        }

	if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
	{
		/* draw inner cylinder */

		inner_radius = cline_ip->radius - cline_ip->thickness;

		VSCALE( a, unit_a, inner_radius );
		VSCALE( b, unit_b, inner_radius );

		rt_ell_16pts( bottom, cline_ip->v, a, b );
		rt_ell_16pts( top, top_pt, a, b );

	        /* Draw the top */
	        RT_ADD_VLIST( vhead, &top[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	        for( i=0; i<16; i++ )  {
	                RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	        }

	        /* Draw the bottom */
	        RT_ADD_VLIST( vhead, &bottom[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	        for( i=0; i<16; i++ )  {
	                RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	        }

	        /* Draw connections */
	        for( i=0; i<16; i += 4 )  {
	                RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	                RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	        }

	}

        return(0);
}

struct cline_vert {
	point_t pt;
	struct vertex *v;
};

/*
 *			R T _ C L I N E _ T E S S
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_cline_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct shell			*s;
	struct rt_cline_internal	*cline_ip;
	fastf_t				ang_tol, abs_tol, norm_tol, rel_tol;
	int				nsegs, seg_no, i;
	struct cline_vert		*base_outer, *base_inner, *top_outer, *top_inner;
	struct cline_vert		base_center, top_center;
	vect_t				v1, v2;
	point_t				top;
	struct bu_ptbl			faces;

	RT_CK_DB_INTERNAL(ip);
	cline_ip = (struct rt_cline_internal *)ip->idb_ptr;
	RT_CLINE_CK_MAGIC(cline_ip);

	*r = nmg_mrsv( m );
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	ang_tol = bn_halfpi;
	abs_tol = bn_halfpi;
	rel_tol = bn_halfpi;
	norm_tol = bn_halfpi;

	if( ttol->abs <= 0.0 && ttol->rel <= 0.0 && ttol->norm <= 0.0 )
	{
		/* no tolerances specified, use 10% relative tolerance */
		ang_tol = 2.0 * acos( 0.9 );
	}
	else
	{
		if( ttol->abs > 0.0 && ttol->abs < cline_ip->radius )
			abs_tol = 2.0 * acos( 1.0 - ttol->abs / cline_ip->radius );
		if( ttol->rel > 0.0 && ttol->rel < 1.0 )
			rel_tol = 2.0 * acos( 1.0 - ttol->rel );
		if( ttol->norm > 0.0 )
			norm_tol = 2.0 * ttol->norm;
	}

	if( abs_tol < ang_tol )
		ang_tol = abs_tol;
	if( rel_tol < ang_tol )
		ang_tol = rel_tol;
	if( norm_tol < ang_tol )
		ang_tol = norm_tol;

	/* get number of segments per quadrant */
	nsegs = (int)(bn_halfpi / ang_tol + 0.9999);
	if( nsegs < 2 )
		nsegs = 2;

	ang_tol = bn_halfpi / nsegs;

	/* and for complete circle */
	nsegs *= 4;

	/* allocate memory for arrays of vertices */
	base_outer = (struct cline_vert *)bu_calloc( nsegs, sizeof( struct cline_vert ), "base outer vertices" );
	top_outer = (struct cline_vert *)bu_calloc( nsegs, sizeof( struct cline_vert ), "top outer vertices" );

	if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
	{
		base_inner = (struct cline_vert *)bu_calloc( nsegs, sizeof( struct cline_vert ), "base inner vertices" );
		top_inner = (struct cline_vert *)bu_calloc( nsegs, sizeof( struct cline_vert ), "top inner vertices" );
	} else {
		base_inner = NULL;
		top_inner = NULL;
	}

	/* calculate geometry for each vertex */
	bn_vec_ortho( v1, cline_ip->h );
	VCROSS( v2, cline_ip->h, v1 );
	VUNITIZE( v2 );
	VADD2( top, cline_ip->v, cline_ip->h );
	for( seg_no = 0; seg_no < nsegs ; seg_no++ )
	{
		fastf_t a, b, c, d, angle;

		angle = ang_tol * seg_no;

		a = cos( angle );
		b = sin( angle );

		if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
		{
			c = a * (cline_ip->radius - cline_ip->thickness);
			d = b * (cline_ip->radius - cline_ip->thickness);
		} else {
			c = d = 0;
		}

		a *= cline_ip->radius;
		b *= cline_ip->radius;

		VJOIN2( base_outer[seg_no].pt, cline_ip->v, a, v1, b, v2 );
		VADD2( top_outer[seg_no].pt, base_outer[seg_no].pt, cline_ip->h );

		if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
		{
			VJOIN2( base_inner[seg_no].pt, cline_ip->v, c, v1, d, v2 );
			VADD2( top_inner[seg_no].pt, base_inner[seg_no].pt, cline_ip->h );
		}
	}

	bu_ptbl_init( &faces , 64, "faces");
	/* build outer faces */
	for( seg_no=0 ; seg_no<nsegs ; seg_no++ )
	{
		int next_seg;
		struct vertex **verts[3];
		struct faceuse *fu;

		next_seg = seg_no + 1;
		if( next_seg == nsegs )
			next_seg = 0;

		verts[2] = &top_outer[seg_no].v;
		verts[1] = &top_outer[next_seg].v;
		verts[0] = &base_outer[seg_no].v;

		fu = nmg_cmface( s, verts, 3 );
		bu_ptbl_ins( &faces , (long *)fu );

		verts[2] = &base_outer[seg_no].v;
		verts[1] = &top_outer[next_seg].v;
		verts[0] = &base_outer[next_seg].v;

		fu = nmg_cmface( s, verts, 3 );
		bu_ptbl_ins( &faces , (long *)fu );
	}

	/* build inner faces */
	if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
	{
		for( seg_no=0 ; seg_no<nsegs ; seg_no++ )
		{
			int next_seg;
			struct vertex **verts[3];
			struct faceuse *fu;

			next_seg = seg_no + 1;
			if( next_seg == nsegs )
				next_seg = 0;

			verts[0] = &top_inner[seg_no].v;
			verts[1] = &top_inner[next_seg].v;
			verts[2] = &base_inner[seg_no].v;

			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );

			verts[0] = &base_inner[seg_no].v;
			verts[1] = &top_inner[next_seg].v;
			verts[2] = &base_inner[next_seg].v;

			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );
		}
	}

	/* build top faces */
	top_center.v = (struct vertex *)NULL;
	VMOVE( top_center.pt, top );
	for( seg_no=0 ; seg_no<nsegs ; seg_no++ )
	{
		int next_seg;
		struct vertex **verts[3];
		struct faceuse *fu;

		next_seg = seg_no + 1;
		if( next_seg == nsegs )
			next_seg = 0;

		if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
		{
			verts[2] = &top_outer[seg_no].v;
			verts[1] = &top_inner[seg_no].v;
			verts[0] = &top_inner[next_seg].v;
			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );

			verts[2] = &top_inner[next_seg].v;
			verts[1] = &top_outer[next_seg].v;
			verts[0] = &top_outer[seg_no].v;
			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );
		}
		else
		{
			verts[2] = &top_outer[seg_no].v;
			verts[1] = &top_center.v;
			verts[0] = &top_outer[next_seg].v;
			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );
		}
	}

	/* build base faces */
	base_center.v = (struct vertex *)NULL;
	VMOVE( base_center.pt, cline_ip->v );
	for( seg_no=0 ; seg_no<nsegs ; seg_no++ )
	{
		int next_seg;
		struct vertex **verts[3];
		struct faceuse *fu;

		next_seg = seg_no + 1;
		if( next_seg == nsegs )
			next_seg = 0;

		if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
		{
			verts[0] = &base_outer[seg_no].v;
			verts[1] = &base_inner[seg_no].v;
			verts[2] = &base_inner[next_seg].v;
			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );

			verts[0] = &base_inner[next_seg].v;
			verts[1] = &base_outer[next_seg].v;
			verts[2] = &base_outer[seg_no].v;
			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );
		}
		else
		{
			verts[0] = &base_outer[seg_no].v;
			verts[1] = &base_center.v;
			verts[2] = &base_outer[next_seg].v;
			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );
		}
	}

	/* assign vertex geometry */
	if( top_center.v )
		nmg_vertex_gv( top_center.v, top_center.pt );
	if( base_center.v )
		nmg_vertex_gv( base_center.v, base_center.pt );

	for( seg_no=0 ; seg_no<nsegs ; seg_no++ )
	{
		nmg_vertex_gv( top_outer[seg_no].v, top_outer[seg_no].pt );
		nmg_vertex_gv( base_outer[seg_no].v, base_outer[seg_no].pt );
	}

	if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
	{
		for( seg_no=0 ; seg_no<nsegs ; seg_no++ )
		{
			nmg_vertex_gv( top_inner[seg_no].v, top_inner[seg_no].pt );
			nmg_vertex_gv( base_inner[seg_no].v, base_inner[seg_no].pt );
		}
	}

	bu_free( (char *)base_outer, "base outer vertices" );
	bu_free( (char *)top_outer, "top outer vertices" );
	if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
	{
		bu_free( (char *)base_inner, "base inner vertices" );
		bu_free( (char *)top_inner, "top inner vertices" );
	}

	/* Associate face plane equations */
	for( i=0 ; i<BU_PTBL_END( &faces ) ; i++ )
	{
		struct faceuse *fu;

		fu = (struct faceuse *)BU_PTBL_GET( &faces , i );
		NMG_CK_FACEUSE( fu );

		if( nmg_calc_face_g( fu ) )
		{
			bu_log( "rt_tess_cline: failed to calculate plane equation\n" );
			nmg_pr_fu_briefly( fu, "" );
			return( -1 );
		}
	}

	nmg_region_a( *r , tol );
	bu_ptbl_free( &faces );

	return(0);
}

/*
 *			R T _ C L I N E _ I M P O R T
 *
 *  Import an cline from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_cline_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	LOCAL struct rt_cline_internal	*cline_ip;
	union record			*rp;
	point_t 			work;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */

	if( rp->u_id != DBID_CLINE )  {
		bu_log("rt_cline_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_CLINE;
	ip->idb_meth = &rt_functab[ID_CLINE];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_cline_internal), "rt_cline_internal");
	cline_ip = (struct rt_cline_internal *)ip->idb_ptr;
	cline_ip->magic = RT_CLINE_INTERNAL_MAGIC;
	ntohd( (unsigned char *)(&cline_ip->thickness), rp->cli.cli_thick, 1 );
	cline_ip->thickness /= mat[15];
	ntohd( (unsigned char *)(&cline_ip->radius), rp->cli.cli_radius, 1 );
	cline_ip->radius /= mat[15];
	ntohd( (unsigned char *)(&work), rp->cli.cli_V, 3 );
	MAT4X3PNT( cline_ip->v, mat, work );
	ntohd( (unsigned char *)(&work), rp->cli.cli_h, 3 );
	MAT4X3VEC( cline_ip->h, mat, work );

	return(0);			/* OK */
}

/*
 *			R T _ C L I N E _ E X P O R T
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_cline_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_cline_internal	*cline_ip;
	union record			*rec;
	fastf_t				tmp;
	point_t				work;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_CLINE )  return(-1);
	cline_ip = (struct rt_cline_internal *)ip->idb_ptr;
	RT_CLINE_CK_MAGIC(cline_ip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "cline external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->cli.cli_id = DBID_CLINE;	/* GED primitive type from db.h */

	tmp = cline_ip->thickness * local2mm;
	htond( rec->cli.cli_thick, (unsigned char *)(&tmp), 1 );
	tmp = cline_ip->radius * local2mm;
	htond( rec->cli.cli_radius, (unsigned char *)(&tmp), 1 );
	VSCALE( work, cline_ip->v, local2mm );
	htond( rec->cli.cli_V, (unsigned char *)work, 3 );
	VSCALE( work, cline_ip->h, local2mm );
	htond( rec->cli.cli_h, (unsigned char *)work, 3 );

	return(0);
}

/*
 *			R T _ C L I N E _ I M P O R T 5
 *
 *  Import an cline from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_cline_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_cline_internal	*cline_ip;
	fastf_t				vec[8];

	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 8 );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_CLINE;
	ip->idb_meth = &rt_functab[ID_CLINE];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_cline_internal), "rt_cline_internal");

	cline_ip = (struct rt_cline_internal *)ip->idb_ptr;
	cline_ip->magic = RT_CLINE_INTERNAL_MAGIC;

	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)vec, ep->ext_buf, 8 );

	cline_ip->thickness = vec[0] / mat[15];
	cline_ip->radius = vec[1] / mat[15];
	MAT4X3PNT(cline_ip->v, mat, &vec[2]);
	MAT4X3VEC(cline_ip->h, mat, &vec[5]);

	return(0);			/* OK */
}

/*
 *			R T _ C L I N E _ E X P O R T 5
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_cline_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_cline_internal	*cline_ip;
	fastf_t				vec[8];

	RT_CK_DB_INTERNAL(ip);
	if (ip->idb_type != ID_CLINE)  return(-1);
	cline_ip = (struct rt_cline_internal *)ip->idb_ptr;
	RT_CLINE_CK_MAGIC(cline_ip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 8;
	ep->ext_buf = (genptr_t)bu_malloc(ep->ext_nbytes, "cline external");

	vec[0] = cline_ip->thickness * local2mm;
	vec[1] = cline_ip->radius * local2mm;
	VSCALE(&vec[2], cline_ip->v, local2mm);
	VSCALE(&vec[5], cline_ip->h, local2mm);

	/* Convert from internal (host) to database (network) format */
	htond(ep->ext_buf, (unsigned char *)vec, 8);

	return(0);
}

/*
 *			R T _ C L I N E _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_cline_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_cline_internal	*cline_ip =
		(struct rt_cline_internal *)ip->idb_ptr;
	char	buf[256];
	point_t local_v;
	vect_t local_h;

	RT_CLINE_CK_MAGIC(cline_ip);
	bu_vls_strcat( str, "cline solid (CLINE)\n");

	VSCALE( local_v, cline_ip->v, mm2local );
	VSCALE( local_h, cline_ip->h, mm2local );

	if( cline_ip->thickness > 0.0 )
	{
		sprintf( buf, "\tV (%g %g %g)\n\tH (%g %g %g)\n\tradius %g\n\tplate mode thickness %g",
				V3ARGS( local_v ), V3ARGS( local_h ), cline_ip->radius*mm2local, cline_ip->thickness*mm2local );
	}
	else
	{
		sprintf( buf, "\tV (%g %g %g)\n\tH (%g %g %g)\n\tradius %g\n\tVolume mode\n",
				V3ARGS( local_v ), V3ARGS( local_h ), cline_ip->radius*mm2local );
	}
	bu_vls_strcat( str, buf );

	return(0);
}

/*
 *			R T _ C L I N E _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_cline_ifree(struct rt_db_internal *ip)
{
	register struct rt_cline_internal	*cline_ip;

	RT_CK_DB_INTERNAL(ip);
	cline_ip = (struct rt_cline_internal *)ip->idb_ptr;
	RT_CLINE_CK_MAGIC(cline_ip);
	cline_ip->magic = 0;			/* sanity */

	bu_free( (char *)cline_ip, "cline ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

int
rt_cline_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
{
	return( 1 );
}

int
rt_cline_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
	register struct rt_cline_internal *cli = 
		(struct rt_cline_internal *)intern->idb_ptr;
	Tcl_DString     ds;
	struct bu_vls   vls;
	int ret=TCL_OK;

	RT_CLINE_CK_MAGIC( cli );

	Tcl_DStringInit( &ds );
	bu_vls_init( &vls );

	if( attr == (char *)NULL )
	{
		bu_vls_strcpy( &vls, "cline" );
		bu_vls_printf( &vls, " V {%.25G %.25G %.25G}", V3ARGS( cli->v ) );
		bu_vls_printf( &vls, " H {%.25G %.25G %.25G}", V3ARGS( cli->h ) );
		bu_vls_printf( &vls, " R %.25G T %.25G", cli->radius, cli->thickness );
	}
	else if( *attr == 'V')
		bu_vls_printf( &vls, "%.25G %.25G %.25G", V3ARGS( cli->v ) );
	else if( *attr == 'H' )
		bu_vls_printf( &vls, "%.25G %.25G %.25G", V3ARGS( cli->h ) );
	else if( *attr == 'R' )
		bu_vls_printf( &vls, "%.25G", cli->radius );
	else if( *attr == 'T' )
		bu_vls_printf( &vls, "%.25G", cli->thickness );
	else
	{
		bu_vls_strcat( &vls, "ERROR: unrecognized attribute, must be V, H, R, or T!!!" );
		ret = TCL_ERROR;
	}

        Tcl_DStringAppend( &ds, bu_vls_addr( &vls ), -1 );
        Tcl_DStringResult( interp, &ds );
        Tcl_DStringFree( &ds );
        bu_vls_free( &vls );
        return( ret );
}

int
rt_cline_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
{
	struct rt_cline_internal *cli =
		(struct rt_cline_internal *)intern->idb_ptr;
	fastf_t *new;

	RT_CK_DB_INTERNAL( intern );
	RT_CLINE_CK_MAGIC( cli );

	while( argc >= 2 )
	{
		int array_len=3;

		if( *argv[0] == 'V' )
		{
			new = cli->v;
			if( tcl_list_to_fastf_array( interp, argv[1], &new, &array_len ) !=
			    array_len ) {
				Tcl_SetResult( interp,
				      "ERROR: Incorrect number of coordinates for vector\n",
				      TCL_STATIC );
				return( TCL_ERROR );
			}
		}
		else if( *argv[0] == 'H' )
		{
			new = cli->h;
			if( tcl_list_to_fastf_array( interp, argv[1], &new, &array_len ) !=
			    array_len ) {
				Tcl_SetResult( interp,
				      "ERROR: Incorrect number of coordinates for point\n",
				      TCL_STATIC );
				return( TCL_ERROR );
			}
		}
		else if( *argv[0] == 'R' )
			cli->radius = atof( argv[1] );
		else if( *argv[0] == 'T' )
			cli->thickness = atof( argv[1] );

		argc -= 2;
		argv += 2;
	}

	return( TCL_OK );
}

int
rt_cline_tclform( const struct rt_functab *ftp, Tcl_Interp *interp )
{
        RT_CK_FUNCTAB(ftp);

        Tcl_AppendResult( interp,
			  "V {%f %f %f} H {%f %f %f} R %f T %f", (char *)NULL );

        return TCL_OK;

}
@


11.30
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /cvs/brlcad/librt/g_cline.c,v 11.29 2004/05/10 15:25:27 morrison Exp $ (BRL)";
@


11.29
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.28 2004/04/05 08:48:56 morrison Exp $ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.28
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header$ (BRL)";
d377 1
@


11.27
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.26 2002/08/20 17:07:58 jra Exp $ (BRL)";
d74 1
a74 4
rt_cline_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d125 1
a125 2
rt_cline_print( stp )
register const struct soltab *stp;
d152 1
a152 5
rt_cline_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d336 6
a341 6
rt_cline_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d352 1
a352 4
rt_cline_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d385 1
a385 4
rt_cline_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d402 1
a402 5
rt_cline_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d414 1
a414 2
rt_cline_free( stp )
register struct soltab *stp;
d426 1
a426 4
rt_cline_class( stp, min, max, tol )
const struct soltab    *stp;
const vect_t		min, max;
const struct bn_tol    *tol;
d436 1
a436 5
rt_cline_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d527 1
a527 6
rt_cline_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d819 1
a819 5
rt_cline_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d859 1
a859 5
rt_cline_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d898 1
a898 5
rt_cline_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d933 1
a933 5
rt_cline_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d966 1
a966 5
rt_cline_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1001 1
a1001 2
rt_cline_ifree( ip )
struct rt_db_internal	*ip;
d1015 1
a1015 5
rt_cline_tnurb( r, m, ip, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct bn_tol		*tol;
d1021 1
a1021 4
rt_cline_tclget( interp, intern, attr )
Tcl_Interp                      *interp;
const struct rt_db_internal     *intern;
const char                      *attr;
d1063 1
a1063 5
rt_cline_tcladjust( interp, intern, argc, argv )
Tcl_Interp              *interp;
struct rt_db_internal   *intern;
int                     argc;
char                    **argv;
@


11.26
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 2000 by the United States Army.
d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.24 2001/10/02 19:24:28 jra Exp $ (BRL)";
@


11.26.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 2000-2004 by the United States Army.
d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_cline.c,v 11.27 2004/02/02 17:39:19 morrison Exp $ (BRL)";
@


11.26.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 2000-2004 by the United States Army.
d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.27 2004/02/02 17:39:19 morrison Exp $ (BRL)";
@


11.26.10.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.26.10.1 2004/02/12 18:37:40 erikg Exp $ (BRL)";
@


11.26.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.26 2002/08/20 17:07:58 jra Exp $ (BRL)";
d74 4
a77 1
rt_cline_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d128 2
a129 1
rt_cline_print(register const struct soltab *stp)
d156 5
a160 1
rt_cline_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d344 6
a349 6
rt_cline_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d360 4
a363 1
rt_cline_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d396 4
a399 1
rt_cline_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d416 5
a420 1
rt_cline_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d432 2
a433 1
rt_cline_free(register struct soltab *stp)
d445 4
a448 1
rt_cline_class(const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
d458 5
a462 1
rt_cline_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d553 6
a558 1
rt_cline_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d850 5
a854 1
rt_cline_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d894 5
a898 1
rt_cline_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d937 5
a941 1
rt_cline_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d976 5
a980 1
rt_cline_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1013 5
a1017 1
rt_cline_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1052 2
a1053 1
rt_cline_ifree(struct rt_db_internal *ip)
d1067 5
a1071 1
rt_cline_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
d1077 4
a1080 1
rt_cline_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d1122 5
a1126 1
rt_cline_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


11.26.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 2000-2004 by the United States Army.
d20 1
a20 1
static const char RCScline[] = "@@(#)$Header$ (BRL)";
@


11.25
log
@Converted from K&R to ANSI C - RFH
@
text
@d74 4
a77 1
rt_cline_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d128 2
a129 1
rt_cline_print(register const struct soltab *stp)
d156 5
a160 1
rt_cline_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d344 6
a349 6
rt_cline_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d360 4
a363 1
rt_cline_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d396 4
a399 1
rt_cline_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d416 5
a420 1
rt_cline_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d432 2
a433 1
rt_cline_free(register struct soltab *stp)
d445 4
a448 1
rt_cline_class(const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
d458 5
a462 1
rt_cline_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d553 6
a558 1
rt_cline_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d850 5
a854 1
rt_cline_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d894 5
a898 1
rt_cline_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d937 5
a941 1
rt_cline_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d976 5
a980 1
rt_cline_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1013 5
a1017 1
rt_cline_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1052 2
a1053 1
rt_cline_ifree(struct rt_db_internal *ip)
d1067 5
a1071 1
rt_cline_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
d1077 4
a1080 1
rt_cline_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d1122 5
a1126 1
rt_cline_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


11.24
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.23 2001/07/26 14:02:12 jra Exp $ (BRL)";
d74 1
a74 4
rt_cline_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d125 1
a125 2
rt_cline_print( stp )
register const struct soltab *stp;
d152 1
a152 5
rt_cline_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d336 6
a341 6
rt_cline_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d352 1
a352 4
rt_cline_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d385 1
a385 4
rt_cline_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d402 1
a402 5
rt_cline_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d414 1
a414 2
rt_cline_free( stp )
register struct soltab *stp;
d426 1
a426 4
rt_cline_class( stp, min, max, tol )
const struct soltab    *stp;
const vect_t		min, max;
const struct bn_tol    *tol;
d436 1
a436 5
rt_cline_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d527 1
a527 6
rt_cline_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d819 1
a819 5
rt_cline_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d859 1
a859 5
rt_cline_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d898 1
a898 5
rt_cline_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d933 1
a933 5
rt_cline_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d966 1
a966 5
rt_cline_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1001 1
a1001 2
rt_cline_ifree( ip )
struct rt_db_internal	*ip;
d1015 1
a1015 5
rt_cline_tnurb( r, m, ip, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct bn_tol		*tol;
d1021 1
a1021 4
rt_cline_tclget( interp, intern, attr )
Tcl_Interp                      *interp;
const struct rt_db_internal     *intern;
const char                      *attr;
d1063 1
a1063 5
rt_cline_tcladjust( interp, intern, argc, argv )
Tcl_Interp              *interp;
struct rt_db_internal   *intern;
int                     argc;
char                    **argv;
@


11.23
log
@CLINE components are now not hit when ray is parallel to axis (agrees with FASTGEN4)
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.22 2001/07/09 20:50:53 jra Exp $ (BRL)";
d870 1
d951 1
@


11.22
log
@Parallel test in rt_cline_shot was too stringent
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.21 2001/06/21 18:07:25 jra Exp $ (BRL)";
d203 8
d246 1
@


11.21
log
@Continueing to add tcladjust and tclget support
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.20 2001/04/20 22:29:43 morrison Exp $ (BRL)";
d192 9
a200 1
	if( bn_distsq_line3_line3( dist, cline->V, cline->height, rp->r_pt, rp->r_dir, pt1, pt2 ) )
d373 6
@


11.20
log
@CONST to const
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.19 2001/04/13 15:13:29 jra Exp $ (BRL)";
a1104 1
	int ret;
d1117 7
a1123 2
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new, &array_len ) ) )
				return( ret );
d1128 7
a1134 2
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new, &array_len ) ) )
				return( ret );
@


11.19
log
@Added tclform for cline and extrude solids
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.18 2001/03/19 22:19:57 butler Exp $ (BRL)";
d47 1
a47 1
CONST struct bu_structparse rt_cline_parse[] = {
d129 1
a129 1
register CONST struct soltab *stp;
d131 1
a131 1
	register CONST struct cline_specific *cline =
d423 3
a425 3
CONST struct soltab    *stp;
CONST vect_t		min, max;
CONST struct bn_tol    *tol;
d438 2
a439 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d534 2
a535 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d829 3
a831 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d872 1
a872 1
CONST struct rt_db_internal	*ip;
d874 1
a874 1
CONST struct db_i		*dbip;
d915 3
a917 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d953 1
a953 1
CONST struct rt_db_internal	*ip;
d955 1
a955 1
CONST struct db_i		*dbip;
d990 1
a990 1
CONST struct rt_db_internal	*ip;
d1046 1
a1046 1
CONST struct bn_tol		*tol;
d1054 2
a1055 2
CONST struct rt_db_internal     *intern;
CONST char                      *attr;
@


11.18
log
@patches to merge 5.3 into 6.0
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /d/CVS/brlcad/librt/g_cline.c,v 11.17 2000/12/07 13:32:11 jra Exp $ (BRL)";
d1137 12
@


11.17
log
@Correct tclget routine and added support for "rt_cline_radius"
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.16 2000/09/12 14:41:10 pjt Exp $ (BRL)";
d234 1
@


11.16
log
@Fixed a spelling error in a comment
(Damn, I make valuable contributions!)
@
text
@d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.15 2000/08/23 08:41:50 mike Exp $ (BRL)";
d55 3
d85 1
a85 1
	fastf_t					max_tr=50.0;
d100 4
a103 1
	/* XXXX max_tr (maximum threat radius) is a temporary kludge */
d106 1
a106 1
	stp->st_bradius = stp->st_aradius + 50.0;
d174 1
d179 10
a188 1
	reff = cline->radius + ap->a_rbeam;
d240 2
a241 2
	tmp = sqrt( dist[2] ) - ap->a_rbeam;
	if( dist[2] > ap->a_rbeam * ap->a_rbeam )
d1070 3
a1072 3
		bu_vls_printf( &vls, " V {%.25g %.25g %.25g}", V3ARGS( cli->v ) );
		bu_vls_printf( &vls, " H {%.25g %.25g %.25g}", V3ARGS( cli->h ) );
		bu_vls_printf( &vls, " R %.25g T %.25g", cli->radius, cli->thickness );
d1075 1
a1075 1
		bu_vls_printf( &vls, "%.25g %.25g %.25g", V3ARGS( cli->v ) );
d1077 1
a1077 1
		bu_vls_printf( &vls, "%.25g %.25g %.25g", V3ARGS( cli->h ) );
d1079 1
a1079 1
		bu_vls_printf( &vls, "%.25g", cli->radius );
d1081 1
a1081 1
		bu_vls_printf( &vls, "%.25g", cli->thickness );
@


11.15
log
@
Fixed boundary condition.  dist 0 and 1 are hits on ends of CLINE,
not misses.
@
text
@d5 1
a5 1
 *	Intersect a ray with a FSTGEN4 CLINE element
d20 1
a20 1
static const char RCScline[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.14 2000/08/22 21:21:53 mike Exp $ (BRL)";
@


11.14
log
@
lint
@
text
@d219 2
a220 1
	if( dist[0] <= 0.0 || dist[0] >= 1.0 )
@


11.13
log
@Massive compilation warnings eliminated
@
text
@d20 1
a20 1
static const char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.12 2000/08/17 14:17:57 jra Exp $ (BRL)";
d581 3
d604 2
@


11.12
log
@Added tessellation for CLINE solids
@
text
@d20 1
a20 1
static const char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.11 2000/07/10 23:01:30 mike Exp $ (BRL)";
d52 2
a53 1
	{0} };
@


11.11
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d20 1
a20 1
static const char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.10 2000/06/30 15:38:02 mike Exp $ (BRL)";
d498 5
d518 9
a526 1
	LOCAL struct rt_cline_internal	*cline_ip;
d532 262
a793 1
	return(-1);
@


11.10
log
@
export methods should not init the external structure, just check them.
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.9 2000/06/30 15:31:14 mike Exp $ (BRL)";
@


11.9
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.8 2000/06/29 18:21:10 bparker Exp $ (BRL)";
d588 1
a588 1
	BU_INIT_EXTERNAL(ep);
d667 1
a667 1
	BU_INIT_EXTERNAL(ep);
@


11.8
log
@Add rt_cline_import5 and rt_cline_export5 routines.
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.7 2000/04/12 02:34:31 mike Exp $ (BRL)";
d548 1
a548 1
	RT_INIT_DB_INTERNAL( ip );
d628 1
a628 1
	RT_INIT_DB_INTERNAL( ip );
@


11.7
log
@
NT port, non-compat4
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.6 2000/03/03 21:29:08 jra Exp $ (BRL)";
d604 74
@


11.7.2.1
log
@Add tesellation support
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.7 2000/04/12 02:34:31 mike Exp $ (BRL)";
a497 5
struct cline_vert {
	point_t pt;
	struct vertex *v;
};

d513 1
a513 9
	struct shell			*s;
	struct rt_cline_internal	*cline_ip;
	fastf_t				ang_tol, abs_tol, norm_tol, rel_tol;
	int				nsegs, seg_no, i;
	struct cline_vert		*base_outer, *base_inner, *top_outer, *top_inner;
	struct cline_vert		base_center, top_center;
	vect_t				v1, v2;
	point_t				top;
	struct bu_ptbl			faces;
d519 1
a519 262
	*r = nmg_mrsv( m );
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	ang_tol = bn_halfpi;
	abs_tol = bn_halfpi;
	rel_tol = bn_halfpi;
	norm_tol = bn_halfpi;

	if( ttol->abs <= 0.0 && ttol->rel <= 0.0 && ttol->norm <= 0.0 )
	{
		/* no tolerances specified, use 10% relative tolerance */
		ang_tol = 2.0 * acos( 0.9 );
	}
	else
	{
		if( ttol->abs > 0.0 && ttol->abs < cline_ip->radius )
			abs_tol = 2.0 * acos( 1.0 - ttol->abs / cline_ip->radius );
		if( ttol->rel > 0.0 && ttol->rel < 1.0 )
			rel_tol = 2.0 * acos( 1.0 - ttol->rel );
		if( ttol->norm > 0.0 )
			norm_tol = 2.0 * ttol->norm;
	}

	if( abs_tol < ang_tol )
		ang_tol = abs_tol;
	if( rel_tol < ang_tol )
		ang_tol = rel_tol;
	if( norm_tol < ang_tol )
		ang_tol = norm_tol;

	/* get number of segments per quadrant */
	nsegs = (int)(bn_halfpi / ang_tol + 0.9999);
	if( nsegs < 2 )
		nsegs = 2;

	ang_tol = bn_halfpi / nsegs;

	/* and for complete circle */
	nsegs *= 4;

	/* allocate memory for arrays of vertices */
	base_outer = (struct cline_vert *)bu_calloc( nsegs, sizeof( struct cline_vert ), "base outer vertices" );
	top_outer = (struct cline_vert *)bu_calloc( nsegs, sizeof( struct cline_vert ), "top outer vertices" );

	if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
	{
		base_inner = (struct cline_vert *)bu_calloc( nsegs, sizeof( struct cline_vert ), "base inner vertices" );
		top_inner = (struct cline_vert *)bu_calloc( nsegs, sizeof( struct cline_vert ), "top inner vertices" );
	}

	/* calculate geometry for each vertex */
	bn_vec_ortho( v1, cline_ip->h );
	VCROSS( v2, cline_ip->h, v1 );
	VUNITIZE( v2 );
	VADD2( top, cline_ip->v, cline_ip->h );
	for( seg_no = 0; seg_no < nsegs ; seg_no++ )
	{
		fastf_t a, b, c, d, angle;

		angle = ang_tol * seg_no;

		a = cos( angle );
		b = sin( angle );

		if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
		{
			c = a * (cline_ip->radius - cline_ip->thickness);
			d = b * (cline_ip->radius - cline_ip->thickness);
		}

		a *= cline_ip->radius;
		b *= cline_ip->radius;

		VJOIN2( base_outer[seg_no].pt, cline_ip->v, a, v1, b, v2 );
		VADD2( top_outer[seg_no].pt, base_outer[seg_no].pt, cline_ip->h );

		if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
		{
			VJOIN2( base_inner[seg_no].pt, cline_ip->v, c, v1, d, v2 );
			VADD2( top_inner[seg_no].pt, base_inner[seg_no].pt, cline_ip->h );
		}
	}

	bu_ptbl_init( &faces , 64, "faces");
	/* build outer faces */
	for( seg_no=0 ; seg_no<nsegs ; seg_no++ )
	{
		int next_seg;
		struct vertex **verts[3];
		struct faceuse *fu;

		next_seg = seg_no + 1;
		if( next_seg == nsegs )
			next_seg = 0;

		verts[2] = &top_outer[seg_no].v;
		verts[1] = &top_outer[next_seg].v;
		verts[0] = &base_outer[seg_no].v;

		fu = nmg_cmface( s, verts, 3 );
		bu_ptbl_ins( &faces , (long *)fu );

		verts[2] = &base_outer[seg_no].v;
		verts[1] = &top_outer[next_seg].v;
		verts[0] = &base_outer[next_seg].v;

		fu = nmg_cmface( s, verts, 3 );
		bu_ptbl_ins( &faces , (long *)fu );
	}

	/* build inner faces */
	if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
	{
		for( seg_no=0 ; seg_no<nsegs ; seg_no++ )
		{
			int next_seg;
			struct vertex **verts[3];
			struct faceuse *fu;

			next_seg = seg_no + 1;
			if( next_seg == nsegs )
				next_seg = 0;

			verts[0] = &top_inner[seg_no].v;
			verts[1] = &top_inner[next_seg].v;
			verts[2] = &base_inner[seg_no].v;

			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );

			verts[0] = &base_inner[seg_no].v;
			verts[1] = &top_inner[next_seg].v;
			verts[2] = &base_inner[next_seg].v;

			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );
		}
	}

	/* build top faces */
	top_center.v = (struct vertex *)NULL;
	VMOVE( top_center.pt, top );
	for( seg_no=0 ; seg_no<nsegs ; seg_no++ )
	{
		int next_seg;
		struct vertex **verts[3];
		struct faceuse *fu;

		next_seg = seg_no + 1;
		if( next_seg == nsegs )
			next_seg = 0;

		if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
		{
			verts[2] = &top_outer[seg_no].v;
			verts[1] = &top_inner[seg_no].v;
			verts[0] = &top_inner[next_seg].v;
			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );

			verts[2] = &top_inner[next_seg].v;
			verts[1] = &top_outer[next_seg].v;
			verts[0] = &top_outer[seg_no].v;
			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );
		}
		else
		{
			verts[2] = &top_outer[seg_no].v;
			verts[1] = &top_center.v;
			verts[0] = &top_outer[next_seg].v;
			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );
		}
	}

	/* build base faces */
	base_center.v = (struct vertex *)NULL;
	VMOVE( base_center.pt, cline_ip->v );
	for( seg_no=0 ; seg_no<nsegs ; seg_no++ )
	{
		int next_seg;
		struct vertex **verts[3];
		struct faceuse *fu;

		next_seg = seg_no + 1;
		if( next_seg == nsegs )
			next_seg = 0;

		if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
		{
			verts[0] = &base_outer[seg_no].v;
			verts[1] = &base_inner[seg_no].v;
			verts[2] = &base_inner[next_seg].v;
			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );

			verts[0] = &base_inner[next_seg].v;
			verts[1] = &base_outer[next_seg].v;
			verts[2] = &base_outer[seg_no].v;
			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );
		}
		else
		{
			verts[0] = &base_outer[seg_no].v;
			verts[1] = &base_center.v;
			verts[2] = &base_outer[next_seg].v;
			fu = nmg_cmface( s, verts, 3 );
			bu_ptbl_ins( &faces , (long *)fu );
		}
	}

	/* assign vertex geometry */
	if( top_center.v )
		nmg_vertex_gv( top_center.v, top_center.pt );
	if( base_center.v )
		nmg_vertex_gv( base_center.v, base_center.pt );

	for( seg_no=0 ; seg_no<nsegs ; seg_no++ )
	{
		nmg_vertex_gv( top_outer[seg_no].v, top_outer[seg_no].pt );
		nmg_vertex_gv( base_outer[seg_no].v, base_outer[seg_no].pt );
	}

	if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
	{
		for( seg_no=0 ; seg_no<nsegs ; seg_no++ )
		{
			nmg_vertex_gv( top_inner[seg_no].v, top_inner[seg_no].pt );
			nmg_vertex_gv( base_inner[seg_no].v, base_inner[seg_no].pt );
		}
	}

	bu_free( (char *)base_outer, "base outer vertices" );
	bu_free( (char *)top_outer, "top outer vertices" );
	if( cline_ip->thickness > 0.0 && cline_ip->thickness < cline_ip->radius )
	{
		bu_free( (char *)base_inner, "base inner vertices" );
		bu_free( (char *)top_inner, "top inner vertices" );
	}

	/* Associate face plane equations */
	for( i=0 ; i<BU_PTBL_END( &faces ) ; i++ )
	{
		struct faceuse *fu;

		fu = (struct faceuse *)BU_PTBL_GET( &faces , i );
		NMG_CK_FACEUSE( fu );

		if( nmg_calc_face_g( fu ) )
		{
			bu_log( "rt_tess_cline: failed to calculate plane equation\n" );
			nmg_pr_fu_briefly( fu, "" );
			return( -1 );
		}
	}

	nmg_region_a( *r , tol );
	bu_ptbl_free( &faces );

	return(0);
@


11.7.2.2
log
@changed hit check to allow hits exactly on ends of cline
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.7.2.1 2000/08/17 15:23:52 jra Exp $ (BRL)";
d218 1
a218 1
	if( dist[0] < 0.0 || dist[0] > 1.0 )
@


11.7.2.3
log
@switched tcl output to use "%.25G" as other solids do
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.7.2.2 2000/08/24 13:32:52 jra Exp $ (BRL)";
d973 3
a975 3
		bu_vls_printf( &vls, " V {%.25G %.25G %.25G}", V3ARGS( cli->v ) );
		bu_vls_printf( &vls, " H {%.25G %.25G %.25G}", V3ARGS( cli->h ) );
		bu_vls_printf( &vls, " R %.25G T %.25G", cli->radius, cli->thickness );
d978 1
a978 1
		bu_vls_printf( &vls, "%.25G %.25G %.25G", V3ARGS( cli->v ) );
d980 1
a980 1
		bu_vls_printf( &vls, "%.25G %.25G %.25G", V3ARGS( cli->h ) );
d982 1
a982 1
		bu_vls_printf( &vls, "%.25G", cli->radius );
d984 1
a984 1
		bu_vls_printf( &vls, "%.25G", cli->thickness );
@


11.7.2.4
log
@Mods to support CLINE radius addition
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.7.2.3 2000/10/30 18:21:38 jra Exp $ (BRL)";
a53 3
/* shared with do.c */
fastf_t rt_cline_radius=-1.0;

d81 1
a81 1
	fastf_t					max_tr;
d96 1
a96 4
	if( rt_cline_radius > 0.0 )
		max_tr = rt_cline_radius;
	else
		max_tr = 0.0;
d99 1
a99 1
	stp->st_bradius = stp->st_aradius + max_tr;
a166 1
	fastf_t add_radius;
d171 1
a171 10
	if( rt_cline_radius > 0.0 )
	{
		add_radius = rt_cline_radius;
		reff = cline->radius + add_radius;
	}
	else
	{
		add_radius = 0.0;
		reff = cline->radius;
	}
d222 2
a223 2
	tmp = sqrt( dist[2] ) - add_radius;
	if( dist[2] > add_radius * add_radius )
@


11.7.2.5
log
@Backporting bug fixes for release 5.4
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.7.2.4 2000/11/22 13:35:35 jra Exp $ (BRL)";
a189 4
        if( cosa > 0.0 )
               tmp = cosa - 1.0;
        else
               tmp = cosa + 1.0;
d191 1
a191 3
	(void) bn_distsq_line3_line3( dist, cline->V, cline->height, rp->r_pt, rp->r_dir, pt1, pt2 );

	if( NEAR_ZERO( tmp, RT_DOT_TOL ) )
@


11.6
log
@Corrected tclget routines
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.5 2000/03/03 18:16:41 jra Exp $ (BRL)";
d364 1
a364 1
 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.5
log
@Added tclget and put routines
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.4 2000/03/03 13:47:26 jra Exp $ (BRL)";
d717 1
a717 1
        Tcl_DStringAppendElement( &ds, bu_vls_addr( &vls ) );
@


11.4
log
@According to Hugh, plate mode CLINEs do not get hits when parallel to shotline
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.3 2000/03/02 18:32:39 jra Exp $ (BRL)";
d27 1
d677 88
@


11.3
log
@Added Limitations on distances as in FASTGEN
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.2 2000/03/02 15:44:49 jra Exp $ (BRL)";
d177 4
d193 1
a193 3
		if( cline->thickness <= 0.0 )
		{
			/* vloume mode */
d195 6
a200 18
			RT_GET_SEG( segp, ap->a_resource);
			segp->seg_stp = stp;
			segp->seg_in.hit_dist = dist[0];
			segp->seg_in.hit_surfno = 1;
			if( cosa > 0.0 )
				VREVERSE( segp->seg_in.hit_normal, cline->h )
			else
				VMOVE( segp->seg_in.hit_normal, cline->h );

			segp->seg_out.hit_dist = dist[1];
			segp->seg_out.hit_surfno = -1;
			if( cosa < 0.0 )
				VREVERSE( segp->seg_out.hit_normal, cline->h )
			else
				VMOVE( segp->seg_out.hit_normal, cline->h );
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );
			return( 1 );
		}
d202 1
a202 2
		{
			/* plate mode */
d204 8
a211 36
			RT_GET_SEG( segp, ap->a_resource);
			segp->seg_stp = stp;
			segp->seg_in.hit_dist = dist[0];
			segp->seg_in.hit_surfno = 1;
			if( cosa > 0.0 )
				VREVERSE( segp->seg_in.hit_normal, cline->h )
			else
				VMOVE( segp->seg_in.hit_normal, cline->h );

			segp->seg_out.hit_dist = dist[0] + cline->thickness;
			segp->seg_out.hit_surfno = -1;
			if( cosa < 0.0 )
				VREVERSE( segp->seg_out.hit_normal, cline->h )
			else
				VMOVE( segp->seg_out.hit_normal, cline->h );
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );

			RT_GET_SEG( segp, ap->a_resource);
			segp->seg_stp = stp;
			segp->seg_in.hit_dist = dist[1];
			segp->seg_in.hit_surfno = 1;
			if( cosa > 0.0 )
				VREVERSE( segp->seg_in.hit_normal, cline->h )
			else
				VMOVE( segp->seg_in.hit_normal, cline->h );

			segp->seg_out.hit_dist = dist[1] + cline->thickness;
			segp->seg_out.hit_surfno = -1;
			if( cosa < 0.0 )
				VREVERSE( segp->seg_out.hit_normal, cline->h )
			else
				VMOVE( segp->seg_out.hit_normal, cline->h );
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );

			return( 2 );
		}
@


11.2
log
@Eliminated some unused variables
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.1 2000/03/02 14:47:28 jra Exp $ (BRL)";
d165 1
a165 1

d182 1
a182 1
		if( dist[1] > dist[0] )
d266 16
d290 2
d296 2
d311 2
d323 4
a326 1
		segp->seg_in.hit_dist = dist[1] + half_los - cline->thickness;
@


11.1
log
@Eliminated FGP solid and added cline solid
@
text
@d20 1
a20 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_cline.c,v 11.8 2000/02/10 19:46:36 jra Exp $ (BRL)";
d157 1
a157 5
	register struct seg	*segp, *new_seg;
	int			ref_ret, hit_count=0;
	fastf_t			cos_in, cos_out;
	fastf_t			dist1;
	vect_t			norm_in, norm_out;
a212 2
			fastf_t dot;

a341 2
	register struct cline_specific *cline =
		(struct cline_specific *)stp->st_specific;
@

