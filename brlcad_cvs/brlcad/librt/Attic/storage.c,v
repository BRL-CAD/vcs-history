head	11.13;
access;
symbols
	ansi-20040405-merged:11.10.2.1
	postmerge-20040405-ansi:11.11
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.10
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.10.2.1
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.10
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.10
	phong-branch:11.10.0.8
	photonmap-branch:11.10.0.6
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.7
	offsite-5-3-pre:11.8
	rel-5-3:11.7
	rel-5-2:11.7
	rel-5-1-branch:11.7.0.2
	rel-5-1:11.7
	rel-5-0:11.6
	rel-5-0-beta:11.6
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.13
date	2004.05.21.18.07.35;	author morrison;	state dead;
branches;
next	11.12;

11.12
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.11;

11.11
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2002.08.20.17.08.09;	author jra;	state Exp;
branches
	11.10.2.1;
next	11.9;

11.9
date	2002.08.15.20.55.21;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2000.07.10.23.01.49;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.05.02.01.42.23;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.08.31.04.20.54;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	96.08.31.03.15.29;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.08.29.06.05.39;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.08.27.02.03.43;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.11.07.15.19.46;	author adam;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.42;	author mike;	state Rel4_4;
branches;
next	10.11;

10.11
date	94.11.08.03.28.31;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.08.25.17.50.10;	author gdurf;	state Exp;
branches;
next	10.9;

10.9
date	94.08.10.20.05.51;	author gdurf;	state Exp;
branches;
next	10.8;

10.8
date	93.10.28.23.50.30;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	93.07.20.22.49.06;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.01.08.09.44.49;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.11.16.22.53.59;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.08.25.23.13.55;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.06.12.00.01.40;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.04.15.59.09;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.03;	author mike;	state Rel4_0;
branches;
next	9.17;

9.17
date	91.06.29.22.14.10;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.04.01.19.55.48;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.02.21.15.53.50;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.01.29.10.40.24;	author cjohnson;	state Exp;
branches;
next	9.13;

9.13
date	91.01.26.02.46.55;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.12.21.14.50.53;	author butler;	state Exp;
branches;
next	9.11;

9.11
date	90.11.02.03.55.29;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.11.02.03.40.42;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.10.06.02.05.44;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.07.29.23.28.42;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.05.21.13.36.10;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.05.01.02.38.46;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.04.24.02.41.15;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.04.13.03.37.45;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.12.31.07.38.32;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.12.30.05.26.34;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.57.16;	author mike;	state Rel3_5;
branches;
next	8.7;

8.7
date	89.05.05.02.00.10;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.04.03.21.30.19;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.03.15.15.49.41;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.03.15.14.21.51;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.02.27.01.04.27;	author phil;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.11.42;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.31.49;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.08.28.00.54.31;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.08.18.04.33.14;	author phil;	state Exp;
branches;
next	7.3;

7.3
date	88.08.08.21.58.21;	author phil;	state Exp;
branches;
next	7.2;

7.2
date	88.05.14.00.57.52;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.34.26;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.56.43;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.12.38;	author mike;	state Rel;
branches;
next	4.5;

4.5
date	87.05.28.07.36.25;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.03.30.16.25.43;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.03.23.23.41.20;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.12.22.12.03;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.46.06;	author mike;	state Rel1;
branches;
next	3.5;

3.5
date	86.12.24.08.06.18;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.08.12.04.16.39;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.08.08.07.16.01;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.11.22.01.33;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.11.01.32.54;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.33.58;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	86.06.09.21.51.11;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.09.06.02.29.35;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.05.02.20.49;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.06.30;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.07.30.05.55.21;	author mike;	state Exp;
branches;
next	;

11.10.2.1
date	2002.09.19.18.01.47;	author morrison;	state Exp;
branches;
next	;


desc
@Visible memory allocators, plus bulk freelist refillers.
@


11.13
log
@moved to src/
@
text
@/*
 *			S T O R A G E . C
 *
 * Ray Tracing program, storage manager.
 *
 *  Functions -
 *	rt_get_seg	Invoked by GET_SEG() macro
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char RCSstorage[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/storage.c,v 11.12 2004/05/10 15:30:47 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "bu.h"
#include "./debug.h"

/*
 *  			R T _ G E T _ S E G
 *  
 *  This routine is called by the GET_SEG macro when the freelist
 *  is exhausted.  Rather than simply getting one additional structure,
 *  we get a whole batch, saving overhead.  When this routine is called,
 *  the seg resource must already be locked.
 *  malloc() locking is done in bu_malloc.
 */
void
rt_get_seg(register struct resource *res)
{
	register struct seg	*sp;
	register int		bytes;

	RT_RESOURCE_CHECK(res);

	if( BU_LIST_UNINITIALIZED( &res->re_seg ) )  {
		BU_LIST_INIT( &(res->re_seg) );
		bu_ptbl_init( &res->re_seg_blocks, 64, "re_seg_blocks ptbl" );
	}
	bytes = bu_malloc_len_roundup(64*sizeof(struct seg));
	sp = (struct seg *)bu_malloc(bytes, "rt_get_seg()");
	bu_ptbl_ins( &res->re_seg_blocks, (long *)sp );
	while( bytes >= sizeof(struct seg) )  {
		sp->l.magic = RT_SEG_MAGIC;
		BU_LIST_INSERT(&(res->re_seg), &(sp->l));
		res->re_seglen++;
		sp++;
		bytes -= sizeof(struct seg);
	}
}
@


11.12
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSstorage[] = "@@(#)$Header: /cvs/brlcad/librt/storage.c,v 11.11 2004/04/05 08:48:58 morrison Exp $ (ARL)";
@


11.11
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSstorage[] = "@@(#)$Header$ (ARL)";
d23 5
a27 1
#include "conf.h"
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
static const char RCSstorage[] = "@@(#)$Header: /c/CVS/brlcad/librt/storage.c,v 11.8 2000/07/10 23:01:49 mike Exp $ (ARL)";
d48 1
a48 2
rt_get_seg(res)
register struct resource	*res;
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSstorage[] = "@@(#)$Header: /c/CVS/brlcad/librt/storage.c,v 11.10 2002/08/20 17:08:09 jra Exp $ (ARL)";
d48 2
a49 1
rt_get_seg(register struct resource *res)
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d48 2
a49 1
rt_get_seg(register struct resource *res)
@


11.8
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d20 1
a20 1
static const char RCSstorage[] = "@@(#)$Header: /c/CVS/brlcad/librt/storage.c,v 11.7 2000/05/02 01:42:23 mike Exp $ (ARL)";
d48 1
a48 2
rt_get_seg(res)
register struct resource	*res;
@


11.7
log
@
BU_ macros
@
text
@d20 1
a20 1
static char RCSstorage[] = "@@(#)$Header: /c/CVS/brlcad/librt/storage.c,v 11.6 1996/08/31 04:20:54 mike Exp $ (ARL)";
@


11.6
log
@Changed calling sequence to bu_ptbl_init() to have reason string
for bu_malloc() tracking
@
text
@d20 1
a20 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 11.5 1996/08/31 03:15:29 mike Exp mike $ (ARL)";
d56 2
a57 2
	if( RT_LIST_UNINITIALIZED( &res->re_seg ) )  {
		RT_LIST_INIT( &(res->re_seg) );
d65 1
a65 1
		RT_LIST_INSERT(&(res->re_seg), &(sp->l));
@


11.5
log
@Added rti_resources, and rt_free_resource(), to allow returning
all the per-CPU memory allocations.
@
text
@d20 1
a20 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 11.4 1996/08/29 06:05:39 mike Exp mike $ (ARL)";
d58 1
a58 1
		bu_ptbl_init( &res->re_seg_blocks, 64 );
@


11.4
log
@Eliminated rt_get_pt() routine; struct partition is no longer
variable length.
Allocation is handled in raytrace.h
@
text
@d20 1
a20 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 11.3 1996/08/27 02:03:43 mike Exp mike $ (ARL)";
d56 3
a58 2
	if( res->re_seg.l.forw == RT_LIST_NULL )  {
		RT_LIST_INIT( &(res->re_seg.l) );
d62 1
d65 1
a65 1
		RT_LIST_INSERT(&(res->re_seg.l), &(sp->l));
@


11.3
log
@Most stuff moved into libbu/malloc.c
@
text
@a7 1
 *	rt_get_pt	Invoked by GET_PT() macro
d20 1
a20 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 11.2 1995/11/07 15:19:46 adam Exp mike $ (ARL)";
a66 66
	}
}

/*
 *  			R T _ G E T _ P T
 *  
 *  This routine is called by the GET_PT macro when the freelist
 *  is exhausted.  Rather than simply getting one additional structure,
 *  we get a whole batch, saving subroutine call overhead.
 *
 *  Also note that there is a bit of trickery going on here:
 *  the *real* size of pt_solhit[] array is determined at runtime, here.
 *
 *  Each partition structure is separately allocated with bu_malloc(),
 *  so that it can be freed later.  Note that if the desired length
 *  for a new structure does not match the existing length of the first
 *  free structure on the free queue, this routine is also called.
 *  In this case, all wrong size structures are released, and then
 *  some new ones are obtained.
 *
 *  At some time in the future, it may be worth considering a more
 *  intelligent cache algorithm;  for now, let bu_malloc() handle it.
 */
void
rt_get_pt(rtip, res)
struct rt_i		*rtip;
register struct resource *res;
{
	register int			bytes;
	register struct partition	*pp;
	register int			i;

	RT_CHECK_RTI(rtip);
	RT_RESOURCE_CHECK(res);

	if( RT_LIST_FIRST(partition, &res->re_parthead) == PT_NULL )  {
		RT_LIST_INIT( &res->re_parthead );
		res->re_partlen = 0;
	}

	bytes = rtip->rti_pt_bytes;

	/* First, march through the free queue, discarding wrong sizes */
	pp = RT_LIST_FIRST( partition, &res->re_parthead );
	while( RT_LIST_NOT_HEAD( pp, &res->re_parthead ) )  {
		RT_CHECK_PT(pp);
		if( pp->pt_len != bytes )  {
			register struct partition	*nextpp;

			nextpp = pp->pt_forw;
			DEQUEUE_PT( pp );
			bu_free( (genptr_t)pp, "wrong size partition struct");
			res->re_partlen--;
			pp = nextpp;
			continue;
		}
		pp = pp->pt_forw;
	}

	/* Obtain a few new structures of the desired size */
	for( i=10; i>0; i-- )  {
		pp = (struct partition *)bu_malloc(bytes, "struct partition");
		pp->pt_len = bytes;
		pp->pt_magic = PT_MAGIC;
		FREE_PT(pp, res);
		res->re_partlen++;
@


11.2
log
@Matching malloc and free messages -- rt_strdup duplicate string
@
text
@a6 6
 *	rt_malloc	Allocate storage, with visibility & checking
 *	rt_free		Similarly, free storage
 *	rt_realloc	Reallocate storage, with visibility & checking
 *	rt_calloc	Allocate zero'ed storage
 *	rt_prmem	When debugging, print memory map
 *	rt_strdup	Duplicate a string in dynamic memory
a8 1
 *	rt_byte_roundup	Optimize sizing of malloc() requests
d14 2
a15 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d17 2
a18 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1990 by the United States Army.
 *	All rights reserved.
d21 1
a21 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 11.1 1995/01/04 09:58:42 mike Rel4_4 adam $";
d36 1
a38 10
#define MDB_MAGIC	0x12348969
struct memdebug {
	char		*mdb_addr;
	CONST char	*mdb_str;
	int		mdb_len;
};
static struct memdebug	*rt_memdebug;
static int		rt_memdebug_len = 0;
#define MEMDEBUG_NULL	((struct memdebug *)0)

a39 351
 *			R T _ M E M D E B U G _ A D D
 *
 *  Add another entry to the memory debug table
 */
HIDDEN void
rt_memdebug_add( ptr, cnt, str )
char		*ptr;
unsigned int	cnt;
CONST char	*str;
{
	register struct memdebug *mp;
top:
	if( rt_g.rtg_parallel )  {
		RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
	}
	if( rt_memdebug )  {
		mp = &rt_memdebug[rt_memdebug_len-1];
		for( ; mp >= rt_memdebug; mp-- )  {
			/* Search for an empty slot */
			if( mp->mdb_len > 0 )  continue;
			mp->mdb_addr = ptr;
			mp->mdb_len = cnt;
			mp->mdb_str = str;
			if( rt_g.rtg_parallel ) {
				RES_RELEASE( &rt_g.res_syscall ); /* unlock */
			}
			return;
		}
	}

	/* Need to make more slots */
	if( rt_memdebug_len <= 0 )  {
		rt_memdebug_len = 510;
		rt_memdebug = (struct memdebug *)calloc(
			rt_memdebug_len, sizeof(struct memdebug) );
	} else {
		int	old_len = rt_memdebug_len;
		rt_memdebug_len *= 4;
		rt_memdebug = (struct memdebug *)realloc(
			(char *)rt_memdebug,
			sizeof(struct memdebug) * rt_memdebug_len );
		bzero( (char *)&rt_memdebug[old_len],
			(rt_memdebug_len-old_len) * sizeof(struct memdebug) );
	}
	if( rt_g.rtg_parallel ) {
		RES_RELEASE( &rt_g.res_syscall );		/* unlock */
	}
	if( rt_memdebug == (struct memdebug *)0 )
		rt_bomb("rt_memdebug_add() malloc failure\n");
	goto top;
}

/*
 *			R T _ M E M D E B U G _ C H E C K
 *
 *  Check an entry against the memory debug table, based upon it's address.
 */
HIDDEN struct memdebug *
rt_memdebug_check( ptr, str )
register char	*ptr;
CONST char	*str;
{
	register struct memdebug *mp = &rt_memdebug[rt_memdebug_len-1];
	register long	*ip;

	if( rt_memdebug == (struct memdebug *)0 )  {
		rt_log("rt_memdebug_check(x%x, %s)  no memdebug table yet\n",
			ptr, str);
		return MEMDEBUG_NULL;
	}
	for( ; mp >= rt_memdebug; mp-- )  {
		if( mp->mdb_len <= 0 )  continue;
		if( mp->mdb_addr != ptr )  continue;
		ip = (long *)(ptr+mp->mdb_len-sizeof(long));
		if( *ip != MDB_MAGIC )  {
			rt_log("ERROR rt_memdebug_check(x%x, %s) %s, barrier word corrupted!\nbarrier at x%x was=x%x s/b=x%x, len=%d\n",
				ptr, str, mp->mdb_str,
				ip, *ip, MDB_MAGIC, mp->mdb_len);
			rt_bomb("rt_memdebug_check() memory corruption\n");
		}
		return(mp);		/* OK */
	}
	return MEMDEBUG_NULL;
}

/*
 *			R T _ M E M _ B A R R I E R C H E C K
 *
 *  Check *all* entries in the memory debug table for barrier word
 *  corruption.
 *  Intended to be called periodicly through an application during debugging.
 *
 *  Returns -
 *	-1	something is wrong
 *	 0	all is OK;
 */
int
rt_mem_barriercheck()
{
	register struct memdebug *mp = &rt_memdebug[rt_memdebug_len-1];
	register long	*ip;

	if( rt_memdebug == (struct memdebug *)0 )  {
		rt_log("rt_mem_barriercheck()  no memdebug table yet\n");
		return 0;
	}
	for( ; mp >= rt_memdebug; mp-- )  {
		if( mp->mdb_len <= 0 )  continue;
		ip = (long *)(mp->mdb_addr+mp->mdb_len-sizeof(long));
		if( *ip != MDB_MAGIC )  {
			rt_log("ERROR rt_mem_barriercheck(x%x, len=%d) barrier word corrupted!\nbarrier at x%x was=x%x s/b=x%x\n",
				mp->mdb_addr, mp->mdb_len,
				ip, *ip, MDB_MAGIC);
			return -1;	/* FAIL */
		}
	}
	return 0;			/* OK */
}

/*
 *			R T _ M E M D E B U G _ M O V E
 *
 *  realloc() has moved to a new memory block.
 *  Update our notion as well.
 */
HIDDEN void
rt_memdebug_move( old_ptr, new_ptr, new_cnt, new_str )
char	*old_ptr;
char	*new_ptr;
int	new_cnt;
CONST char	*new_str;
{
	register struct memdebug *mp = &rt_memdebug[rt_memdebug_len-1];

	if( rt_memdebug == (struct memdebug *)0 )  {
		rt_log("rt_memdebug_move(x%x, x%x, %d., %s)  no memdebug table yet\n",
			old_ptr, new_ptr, new_cnt, new_str);
		return;
	}
	for( ; mp >= rt_memdebug; mp-- )  {
		if( mp->mdb_len > 0 && (mp->mdb_addr == old_ptr) ) {
			mp->mdb_addr = new_ptr;
			mp->mdb_len = new_cnt;
			mp->mdb_str = new_str;
			return;
		}
	}
	rt_log("rt_memdebug_move(): old memdebug entry not found!\n");
	rt_log(" old_ptr=x%x, new_ptr=x%x, new_cnt=%d., new_str=%s\n",
		old_ptr, new_ptr, new_cnt, new_str );
}

/*
 *			R T _ M A L L O C
 *
 *  This routine only returns on successful allocation.
 *  Failure results in rt_bomb() being called.
 */
char *
rt_malloc(cnt, str)
unsigned int	cnt;
CONST char	*str;
{
	register char *ptr;

	if( cnt == 0 )  {
		rt_log("ERROR: rt_malloc count=0 %s\n", str );
		rt_bomb("ERROR: rt_malloc(0)\n");
	}
	if( rt_g.debug&DEBUG_MEM_FULL )  {
		/* Pad, plus full int for magic number */
		cnt = (cnt+2*sizeof(long)-1)&(~(sizeof(long)-1));
	}
	if( rt_g.rtg_parallel )  {
		RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
	}
	ptr = malloc(cnt);
	if( rt_g.rtg_parallel ) {
		RES_RELEASE( &rt_g.res_syscall );		/* unlock */
	}

	if( ptr==(char *)0 || rt_g.debug&DEBUG_MEM )
		rt_log("%8x malloc%6d %s\n", ptr, cnt, str);
	if( ptr==(char *)0 )  {
		rt_log("rt_malloc: Insufficient memory available, sbrk(0)=x%x\n", sbrk(0));
		rt_bomb("rt_malloc: malloc failure");
	}
	if( rt_g.debug&DEBUG_MEM_FULL )  {
		rt_memdebug_add( ptr, cnt, str );

		/* Install a barrier word at the end of the dynamic arena */
		/* Correct location depends on 'cnt' being rounded up, above */

		*((long *)(ptr+cnt-sizeof(long))) = MDB_MAGIC;
	}
	return(ptr);
}

/*
 *			R T _ F R E E
 */
void
rt_free(ptr,str)
char		*ptr;
CONST char	*str;
{
	if(rt_g.debug&DEBUG_MEM) rt_log("%8x free %s\n", ptr, str);
	if(ptr == (char *)0 || ptr == (char *)(-1L) )  {
		rt_log("%8x free ERROR %s\n", ptr, str);
		return;
	}
	if( rt_g.debug&DEBUG_MEM_FULL )  {
		struct memdebug	*mp;
		if( (mp = rt_memdebug_check( ptr, str )) == MEMDEBUG_NULL )  {
			rt_log("ERROR rt_free(x%x, %s) pointer bad, or not allocated with rt_malloc!  Ignored.\n",
				ptr, str);
			return;
		} else {
			mp->mdb_len = 0;	/* successful delete */
		}
	}
	if( rt_g.rtg_parallel ) {
		RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
	}
	*((int *)ptr) = -1;	/* zappo! */
	free(ptr);
	if( rt_g.rtg_parallel ) {
		RES_RELEASE( &rt_g.res_syscall );		/* unlock */
	}
}

/*
 *			R T _ R E A L L O C
 */
char *
rt_realloc(ptr, cnt, str)
register char	*ptr;
unsigned int	cnt;
CONST char	*str;
{
	char	*original_ptr = ptr;

	if( rt_g.debug&DEBUG_MEM_FULL )  {
		if( rt_memdebug_check( ptr, str ) == MEMDEBUG_NULL )  {
			rt_log("%8x realloc%6d %s ** barrier check failure\n",
				ptr, cnt, str );
		}
		/* Pad, plus full int for magic number */
		cnt = (cnt+2*sizeof(long)-1)&(~(sizeof(long)-1));
	}

	if( rt_g.rtg_parallel ) {
		RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
	}
	ptr = realloc(ptr,cnt);
	if( rt_g.rtg_parallel ) {
		RES_RELEASE( &rt_g.res_syscall );		/* unlock */
	}

	if( ptr==(char *)0 || rt_g.debug&DEBUG_MEM )  {
		rt_log("%8x realloc%6d %s %s\n", ptr, cnt, str,
			ptr == original_ptr ? "[grew in place]" : "[moved]" );
	}
	if( ptr==(char *)0 )  {
		rt_log("rt_realloc: Insufficient memory available, sbrk(0)=x%x\n", sbrk(0));
		rt_bomb("rt_realloc: malloc failure");
	}
	if( rt_g.debug&DEBUG_MEM_FULL )  {
		/* Even if ptr didn't change, need to update cnt & barrier */
		rt_memdebug_move( original_ptr, ptr, cnt, str );

		/* Install a barrier word at the end of the dynamic arena */
		/* Correct location depends on 'cnt' being rounded up, above */
		*((long *)(ptr+cnt-sizeof(long))) = MDB_MAGIC;
	}
	return(ptr);
}

/*
 *			R T _ C A L L O C
 */
char *
rt_calloc( nelem, elsize, str )
unsigned int	nelem;
unsigned int	elsize;
CONST char	*str;
{
	unsigned	len;
	char		*ret;

	ret = rt_malloc( (len = nelem*elsize), str );
	bzero( ret, len );
	return(ret);
}

/*
 *			R T _ P R M E M
 * 
 *  Print map of memory currently in use.
 */
void
rt_prmem(str)
char *str;
{
	register struct memdebug *mp;
	register int *ip;

	rt_log("\nrt_prmem(): LIBRT memory use (%s)\n", str);
	if( (rt_g.debug&DEBUG_MEM_FULL) == 0 )  {
		rt_log("\tMemory debugging is now OFF\n");
	}
	rt_log("\t%d elements in memdebug table\n Address Length Purpose\n",
		rt_memdebug_len);
	if( rt_memdebug_len <= 0 )  return;

	mp = &rt_memdebug[rt_memdebug_len-1];
	for( ; mp >= rt_memdebug; mp-- )  {
		if( mp->mdb_len <= 0 )  continue;
		ip = (int *)(mp->mdb_addr+mp->mdb_len-sizeof(int));
		rt_log("%8x %6x %s %s\n",
			mp->mdb_addr, mp->mdb_len, mp->mdb_str,
			*ip!=MDB_MAGIC ? "-BAD-" : "" );
		if( *ip != MDB_MAGIC )
			rt_log("\t%x\t%x\n", *ip, MDB_MAGIC);
	}
}

/*
 *			R T _ S T R D U P
 *
 * Given a string, allocate enough memory to hold it using rt_malloc(),
 * duplicate the strings, returns a pointer to the new string.
 */
char *
rt_strdup( cp )
register CONST char *cp;
{
	register char	*base;
	register int	len;

	if(rt_g.debug&DEBUG_MEM) rt_log("rt_strdup(%s) x%x\n", cp, cp);

	len = strlen( cp )+2;
	if( (base = rt_malloc( len, "rt_strdup duplicate string" )) == (char *)0 )
		rt_bomb("rt_strdup:  unable to allocate memory");

	memcpy( base, cp, len );
	return(base);
}

/*
d46 1
a46 1
 *  malloc() locking is done in rt_malloc.
d60 2
a61 2
	bytes = rt_byte_roundup(64*sizeof(struct seg));
	sp = (struct seg *)rt_malloc(bytes, "rt_get_seg()");
d81 1
a81 1
 *  Each partition structure is separately allocated with rt_malloc(),
d89 1
a89 1
 *  intelligent cache algorithm;  for now, let rt_malloc() handle it.
d119 1
a119 1
			rt_free( (char *)pp, "wrong size partition struct");
d129 1
a129 1
		pp = (struct partition *)rt_malloc(bytes, "struct partition");
a134 99
}

/*
 *  			R T _ B Y T E _ R O U N D U P
 *  
 *  On systems with the CalTech malloc(), the amount of storage
 *  ACTUALLY ALLOCATED is the amount requested rounded UP to the
 *  nearest power of two.  For structures which are acquired and
 *  released often, this works well, but for structures which will
 *  remain unchanged for the duration of the program, this wastes
 *  as much as 50% of the address space (and usually memory as well).
 *  Here, we round up a byte size to the nearest power of two,
 *  leaving off the malloc header, so as to ask for storage without
 *  wasting any.
 *  
 *  On systems with the traditional malloc(), this strategy will just
 *  consume the memory in somewhat larger chunks, but overall little
 *  unused memory will be consumed.
 */
int
rt_byte_roundup(nbytes)
register int nbytes;
{
#if !defined(HAVE_CALTECH_MALLOC)
	return(nbytes);
#else
	static int pagesz;
	register int n;
	register int amt;

	if (pagesz == 0)
		pagesz = getpagesize();

#define OVERHEAD	(4*sizeof(unsigned char) + \
			2*sizeof(unsigned short) + \
			sizeof(unsigned int) )
	n = pagesz - OVERHEAD;
	if (nbytes <= n)
		return(n);
	amt = pagesz;

	while (nbytes > amt + n) {
		amt <<= 1;
	}
	return(amt-OVERHEAD-sizeof(int));
#endif
}

/*	R T _ C K _ M A L L O C _ P T R
 *
 *	Check the magic number stored with memory allocated with rt_malloc
 *	when DEBUG_MEM_FULL is set.
 *
 *	return:
 *		0	pointer good or DEBUG_MEM_FULL not set
 *		other	memory corrupted.
 */
void
rt_ck_malloc_ptr( ptr, str )
char	*ptr;
char	*str;
{
	register struct memdebug *mp = &rt_memdebug[rt_memdebug_len-1];
	register long	*ip;


	/* if memory debugging isn't turned on, we have no way
	 * of knowing if the pointer is good or not
	 */
	if ((rt_g.debug&DEBUG_MEM_FULL) == 0) return;


	if (ptr == (char *)NULL) {
		rt_log("rt_ck_malloc_ptr(x%x, %s) null pointer\n\n", ptr, str);
		rt_bomb("Goodbye");
	}

	if( rt_memdebug == (struct memdebug *)0 )  {
		rt_log("rt_ck_malloc_ptr(x%x, %s)  no memdebug table yet\n",
			ptr, str);
		/* warning only -- the program is just getting started */
		return;
	}

	for( ; mp >= rt_memdebug; mp-- )  {
		if( mp->mdb_len <= 0 || mp->mdb_addr != ptr )  continue;

		ip = (long *)(ptr+mp->mdb_len-sizeof(long));
		if( *ip != MDB_MAGIC )  {
			rt_log("ERROR rt_ck_malloc_ptr(x%x, %s) barrier word corrupted! was=x%x s/b=x%x\n",
				ptr, str, *ip, MDB_MAGIC);
			rt_bomb("rt_ck_malloc_ptr\n");
		}
		return;		/* OK */
	}
	rt_log("ERROR rt_ck_malloc_ptr(x%x, %s)\n\
	pointer not in table of allocated memory.\n", ptr, str);

	rt_bomb("rt_ck_malloc_ptr\n");
@


11.1
log
@Release_4.4
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 10.11 94/11/08 03:28:31 mike Exp $";
d401 1
a401 1
	if( (base = rt_malloc( len, "rt_strdup" )) == (char *)0 )
@


10.11
log
@Irix 6
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 10.10 94/08/25 17:50:10 gdurf Exp Locker: mike $";
@


10.10
log
@Fixed include ordering
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 10.9 1994/08/10 20:05:51 gdurf Exp $";
d265 1
a265 1
	if(ptr == (char *)0 || (int)ptr == -1)  {
d527 3
a533 3
#if !defined(HAVE_CALTECH_MALLOC)
	return(nbytes);
#else
@


10.9
log
@Factored ifdefs
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 10.8 1993/10/28 23:50:30 mike Exp gdurf $";
a35 5
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./debug.h"

d41 5
@


10.8
log
@Increased width of hex pointers to 8 characters.
Print mdb_str on rt_memdebug_check() as well as argument str.
Bomb when rt_memdebug_check() fails.
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 10.7 93/07/20 22:49:06 mike Exp $";
d33 2
d41 3
a43 1
#ifdef BSD
a44 2
#else
# include <string.h>
a348 3
#ifdef SYSV
	(void)memset( ret, '\0', len );
#else
a349 1
#endif
a403 3
#ifdef BSD
	bcopy( cp, base, len );
#else
a404 1
#endif
d531 1
a531 1
#ifdef SYSV
@


10.7
log
@strings from user are CONST
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 10.6 93/01/08 09:44:49 mike Exp Locker: mike $";
d131 4
a134 2
			rt_log("ERROR rt_memdebug_check(x%x, %s) barrier word corrupted!\nbarrier at x%x was=x%x s/b=x%x, len=%d\n",
				ptr, str, ip, *ip, MDB_MAGIC, mp->mdb_len);
d238 1
a238 1
		rt_log("%7x malloc%6d %s\n", ptr, cnt, str);
d262 1
a262 1
	if(rt_g.debug&DEBUG_MEM) rt_log("%7x free %s\n", ptr, str);
d264 1
a264 1
		rt_log("%7x free ERROR %s\n", ptr, str);
d300 1
a300 1
			rt_log("%7x realloc%6d %s ** barrier check failure\n",
d316 1
a316 1
		rt_log("%7x realloc%6d %s %s\n", ptr, cnt, str,
d371 2
a372 1
	rt_log("\t%d elements in memdebug table\n", rt_memdebug_len);
d379 1
a379 1
		rt_log("%7x %5x %s %s\n",
d601 1
a601 1
			rt_bomb("Goodbye");
d608 1
a608 1
	rt_bomb("Goodbye");
@


10.6
log
@Added rt_mem_barriercheck().
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 10.5 92/11/16 22:53:59 mike Exp Locker: mike $";
d47 3
a49 3
	char	*mdb_addr;
	char	*mdb_str;
	int	mdb_len;
d62 3
a64 3
char	*ptr;
unsigned int cnt;
char	*str;
d116 1
a116 1
char		*str;
d184 1
a184 1
char	*new_str;
@


10.5
log
@Lint
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 10.4 92/08/25 23:13:55 mike Exp Locker: mike $";
d137 34
@


10.4
log
@Added error robustness to rt_free().
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 10.3 92/06/12 00:01:40 mike Exp Locker: mike $";
d441 1
a441 1
	if( res->re_parthead.forw == PT_NULL )  {
@


10.3
log
@Not having turned on memory debugging in time should generate
only a warning, not an rt_bomb().
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 10.2 92/05/04 15:59:09 mike Exp Locker: mike $";
d234 1
a234 1
			rt_log("ERROR rt_free(x%x, %s) pointer bad, or not allocated with rt_malloc!\n",
d236 1
@


10.2
log
@Began the conversion of raytrace.h partition structures to RT_LIST macros.
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 10.1 91/10/12 06:41:03 mike Rel4_0 Locker: mike $";
d552 2
a553 1
		rt_bomb("Goodbye");
@


10.1
log
@Release_4.0
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 9.17 91/06/29 22:14:10 mike Exp $";
d440 2
a441 3
	if( res->re_parthead.pt_forw == PT_NULL )  {
		res->re_parthead.pt_forw = res->re_parthead.pt_back =
			&(res->re_parthead);
d448 2
a449 1
	for( pp = res->re_parthead.pt_forw; pp != &(res->re_parthead); )  {
@


9.17
log
@ANSI lint
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 9.16 91/04/01 19:55:48 mike Exp $";
@


9.16
log
@Added check for freeing -1, since that is the "zappo" value.
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 9.15 91/02/21 15:53:50 mike Exp $";
d180 2
a181 2
unsigned int cnt;
char	*str;
d223 2
a224 2
char	*ptr;
char	*str;
d255 3
a257 3
register char *ptr;
unsigned int cnt;
char *str;
d304 1
a304 1
char		*str;
d357 1
a357 1
register char *cp;
@


9.15
log
@Added debugging
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 9.14 91/01/29 10:40:24 cjohnson Exp $";
d227 1
a227 1
	if(ptr == (char *)0)  {
@


9.14
log
@Fix some noise with rt_realloc if MEM_DEBUG_FULL was NOT set.
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 9.13 91/01/26 02:46:55 mike Exp $";
d450 1
@


9.13
log
@Fixed bug in DEBUG_MEM_FULL mode where rt_realloc() sometimes
didn't move the barrier word properly.
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 9.12 90/12/21 14:50:53 butler Exp $";
a260 4
	if( rt_memdebug_check( ptr, str ) == MEMDEBUG_NULL )  {
		rt_log("%7x realloc%6d %s ** barrier check failure\n",
			ptr, cnt, str );
	}
d262 4
@


9.12
log
@added rt_ck_malloc_ptr() which checks pointers allocated with
rt_malloc or rt_calloc when DEBUG_MEM_FULL is set
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 9.11 90/11/02 03:55:29 mike Exp $";
d53 1
d109 1
a109 1
 *			R T _ M E M D E B U G _ D E L E T E
d111 1
a111 1
 *  Delete an entry from the memory debug table, based upon it's address.
d113 2
a114 2
HIDDEN int
rt_memdebug_delete( ptr, str )
d122 1
a122 1
		rt_log("rt_memdebug_delete(x%x, %s)  no memdebug table yet\n",
d124 1
a124 1
		return(-3);
a129 1
		mp->mdb_len = 0;	/* successful free */
d131 2
a132 3
			rt_log("ERROR rt_memdebug_delete(x%x, %s) barrier word corrupted! was=x%x s/b=x%x\n",
				ptr, str, *ip, MDB_MAGIC);
			return(-2);
d134 1
a134 1
		return(0);		/* OK */
d136 1
a136 1
	return(-1);
d232 2
a233 1
		if( rt_memdebug_delete( ptr, str ) < 0 )  {
d236 2
d261 4
d286 2
a287 1
	if( ptr != original_ptr && rt_g.debug&DEBUG_MEM_FULL )  {
@


9.11
log
@Fixed multi-processor race in MEM_FULL debugging
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 9.10 90/11/02 03:40:42 mike Exp $";
d213 1
d510 52
@


9.10
log
@Fussed with error messages.
Made barrier word code consistent.
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 9.9 90/10/06 02:05:44 mike Exp $";
d67 3
d78 3
a85 3
	if( rt_g.rtg_parallel )  {
		RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
	}
@


9.9
log
@Converted seg structures to use doubly linked lists.
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 9.8 90/07/29 23:28:42 mike Exp $";
d128 1
a128 1
			rt_log("ERROR rt_memdebug_delete(x%x, %s) corrupted! was=x%x s/b=x%x\n",
d208 2
a209 1
		/* This depends on 'cnt' being rounded up, above */
d230 1
a230 1
			rt_log("ERROR rt_free(x%x, %s) bad pointer!\n",
d277 1
a277 1
		register long *ip = (long *)(ptr+cnt-sizeof(long));
d279 3
a281 2
		rt_memdebug_move( original_ptr, ptr, cnt, str );
		*ip = MDB_MAGIC;
@


9.8
log
@Oops.  Missing parens.
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 9.7 90/05/21 13:36:10 mike Exp $";
d374 1
a374 1
register struct resource *res;
d376 2
a377 3
	register char *cp;
	register struct seg *sp;
	register int bytes;
d381 3
d385 1
a385 4
	if( (cp = rt_malloc(bytes, "rt_get_seg")) == (char *)0 )  {
		rt_bomb("rt_get_seg: malloc failure\n");
	}
	sp = (struct seg *)cp;
d387 2
a388 2
		sp->seg_next = res->re_seg;
		res->re_seg = sp++;
d390 1
@


9.7
log
@Fixed bug
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: /m/cad/librt/RCS/storage.c,v 9.6 90/05/01 02:38:46 mike Exp $";
d318 2
a319 2
	if( rt_g.debug&DEBUG_MEM_FULL == 0 )  {
		rt_log("\tMemory debugging is now off\n");
@


9.6
log
@Fixed minor nit in rt_prmem.
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 9.5 90/04/24 02:41:15 mike Locked $";
d88 1
a88 1
		int	old_len;
@


9.5
log
@Changed memory debugging from a compile-time option to a run-time
option.  Removed limit on number of memory items that can be traced.
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 9.4 90/04/13 03:37:45 mike Locked $";
d314 1
a314 1
	register struct memdebug *mp = &rt_memdebug[rt_memdebug_len-1];
d317 1
a317 1
	rt_log("\nLIBRT memory use\t\t%s\n", str);
d319 1
a319 2
		rt_log("\tMemory debugging is off\n");
		return;
d322 3
@


9.4
log
@rt_malloc(0) will now bomb.
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1987 by the United States Army.
d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 9.3 89/12/31 07:38:32 mike Locked $";
a44 4
/** #define MEMDEBUG 1 **/

#ifdef MEMDEBUG
#define MDB_SIZE	500
d50 3
a52 2
} rt_mdb[MDB_SIZE];
#endif /* MEMDEBUG */
d55 116
d179 1
a179 1
char *str;
d187 4
a190 3
#ifdef MEMDEBUG
	cnt = (cnt+2*sizeof(int)-1)&(~(sizeof(int)-1));
#endif /* MEMDEBUG */
d205 5
a209 11
#ifdef MEMDEBUG
	{
		register struct memdebug *mp = rt_mdb;
		for( ; mp < &rt_mdb[MDB_SIZE]; mp++ )  {
			if( mp->mdb_len > 0 )  continue;
			mp->mdb_addr = ptr;
			mp->mdb_len = cnt;
			mp->mdb_str = str;
			goto ok;
		}
		rt_log("rt_malloc:  memdebug overflow\n");
a210 6
ok:	;
	{
		register int *ip = (int *)(ptr+cnt-sizeof(int));
		*ip = MDB_MAGIC;
	}
#endif /* MEMDEBUG */
a221 22
#ifdef MEMDEBUG
	{
		register struct memdebug *mp = rt_mdb;
		for( ; mp < &rt_mdb[MDB_SIZE]; mp++ )  {
			if( mp->mdb_len <= 0 )  continue;
			if( mp->mdb_addr != ptr )  continue;
			{
				register int *ip = (int *)(ptr+mp->mdb_len-sizeof(int));
				if( *ip != MDB_MAGIC )  {
					rt_log("ERROR rt_free(x%x, %s) corrupted! x%x!=x%x\n", ptr, str, *ip, MDB_MAGIC);
					return;
				}
			}
			mp->mdb_len = 0;	/* successful free */
			goto ok;
		}
		rt_log("ERROR rt_free(x%x, %s) bad pointer!\n", ptr, str);
		return;
	}
ok:	;
#endif /* MEMDEBUG */

d227 6
d252 1
a252 2
#ifdef MEMDEBUG
	register char *savedptr;
d254 4
a257 3
	savedptr = ptr;
	cnt = (cnt+2*sizeof(int)-1)&(~(sizeof(int)-1));
#endif /* MEMDEBUG */
d267 4
a270 2
	if( ptr==(char *)0 || rt_g.debug&DEBUG_MEM )
		rt_log("%7x realloc%6d %s\n", ptr, cnt, str);
d272 1
a272 1
		rt_log("rt_realloc: Insufficient memory available, using %d\n", sbrk(0));
d275 4
a278 18
#ifdef MEMDEBUG
	if( ptr != savedptr )
	{
		/* replace old entry with new one */
		register struct memdebug *mp = rt_mdb;
		for( ; mp < &rt_mdb[MDB_SIZE]; mp++ )  {
			if( mp->mdb_len > 0 && (mp->mdb_addr == savedptr) ) {
				mp->mdb_addr = ptr;
				mp->mdb_len = cnt;
				mp->mdb_str = str;
				goto ok;
			}
		}
		rt_log("rt_realloc: old entry not found!\n");
	}
ok:	;
	{
		register int *ip = (int *)(ptr+cnt-sizeof(int));
a280 1
#endif /* MEMDEBUG */
d314 1
a314 2
#ifdef MEMDEBUG
	register struct memdebug *mp = rt_mdb;
d317 7
a323 2
	rt_log("\nRT memory use\t\t%s\n", str);
	for( ; mp < &rt_mdb[MDB_SIZE]; mp++ )  {
a331 1
#endif /* MEMDEBUG */
@


9.3
log
@Removed debugging print
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 9.2 89/12/30 05:26:34 mike Locked $";
d59 3
d71 2
a72 1
		rt_log("WARNING: rt_malloc count=0 %s\n", str );
@


9.2
log
@Changed allocation of partition structures.
WARNING:  There is still a memory leak of partition structures.
Some extra printfs remain.
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 9.1 89/05/19 05:57:16 mike Locked $";
a351 2
/* XXX there is a memory leak in partition structures */
rt_log("rt_get_pt(), %d bytes\n", bytes);
@


9.1
log
@Release_3.5
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 8.7 89/05/05 02:00:10 mike Exp $";
d298 2
d318 1
a318 1
 *  we get a whole batch, saving overhead.
d322 10
a331 2
 *  XXX WARNING:  If multiple models are being used, we need to cope
 *  XXX with their differing size requirements, nworkers * N(rt_i)!
d338 3
a340 3
	register char *cp;
	register int bytes;
	register int size;		/* size of structure to really get */
d342 2
a343 1
	if( rtip->rti_magic != RTI_MAGIC )  rt_bomb("rt_get_pt:  bad rtip\n");
d345 5
a349 7
	size = rtip->rti_pt_bytes;
	size = (size + sizeof(bitv_t)-1) & (~(sizeof(bitv_t)-1));
	if( size <= 0 )
		rt_bomb("rt_get_pt: bad size");
	bytes = rt_byte_roundup(64*size);
	if( (cp = rt_malloc(bytes, "rt_get_pt")) == (char *)0 )
		rt_bomb("rt_get_pt: malloc failure\n");
d351 25
a375 3
	while( bytes >= size )  {
		((struct partition *)cp)->pt_forw = res->re_part;
		res->re_part = (struct partition *)cp;
a376 2
		cp += size;
		bytes -= size;
@


8.7
log
@Added check for malloc of 0 bytes.
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 8.6 89/04/03 21:30:19 mike Locked $";
@


8.6
log
@removed local declarations of libc routines.
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 8.5 89/03/15 15:49:41 mike Locked $";
d67 3
@


8.5
log
@Added an include file, changed exit() to rt_bomb
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 8.4 89/03/15 14:21:51 mike Locked $";
a65 1
	extern char *malloc();
a158 2
	extern char *realloc();

d161 1
d165 1
@


8.4
log
@Added rt_calloc() for Phil
@
text
@d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 8.3 89/02/27 01:04:27 mike Locked $";
d39 6
d337 3
a339 4
	if( (cp = rt_malloc(bytes, "rt_get_pt")) == (char *)0 )  {
		rt_log("rt_get_pt: malloc failure\n");
		exit(17);
	}
@


8.3
log
@#endif /* comment */
@
text
@d10 1
d30 1
a30 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 8.2 88/12/06 00:11:42 phil Locked $";
d131 4
d197 21
@


8.2
log
@Only use RES_ACQUIRE()/RES_RELEASE() if needed.
widened some fields
@
text
@d29 1
a29 1
static char RCSstorage[] = "@@(#)$Header: /cad/d/mike/cad/librt/RCS/storage.c,v 1.2 88/10/27 09:43:26 mike Exp $";
d48 1
a48 1
#endif MEMDEBUG
d63 1
a63 1
#endif MEMDEBUG
d95 1
a95 1
#endif MEMDEBUG
d127 1
a127 1
#endif MEMDEBUG
d155 1
a155 1
#endif MEMDEBUG
d190 1
a190 1
#endif MEMDEBUG
d217 1
a217 1
#endif MEMDEBUG
@


8.1
log
@Release_3.0
@
text
@d29 1
a29 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 7.5 88/08/28 00:54:31 mike Exp $";
d64 3
a66 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d68 3
a70 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d73 1
a73 1
		rt_log("%7x malloc%5d %s\n", ptr, cnt, str);
d75 1
a75 1
		rt_log("rt_malloc: Insufficient memory available, using %d\n", sbrk(0));
d130 3
a132 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d135 3
a137 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d156 3
a158 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d160 3
a162 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d165 1
a165 1
		rt_log("%7x realloc%5d %s\n", ptr, cnt, str);
@


7.5
log
@Added bcopy/memcpy conditional on BSD
@
text
@d29 1
a29 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 7.4 88/08/18 04:33:14 mike Locked $";
@


7.4
log
@added rt_realloc()
@
text
@d29 1
a29 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 7.3 88/08/08 21:58:21 phil Locked $";
d227 1
d229 3
@


7.3
log
@moved free log message above actual free (so if it failed you can
tell what it thought it was trying to free).
@
text
@d9 1
d29 1
a29 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 7.2 88/05/14 00:57:52 phil Locked $";
d130 50
@


7.2
log
@lint fix.
@
text
@d28 1
a28 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 7.1 87/11/02 23:34:26 mike Locked $";
d124 1
a128 1
	if(rt_g.debug&DEBUG_MEM) rt_log("%7x freed %s\n", ptr, str);
@


7.1
log
@Release 2.3
@
text
@d28 1
a28 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 6.1 87/07/11 07:56:43 mike Rel $";
d99 2
a100 1
char *ptr;
@


6.1
log
@Release 2.0
@
text
@d28 1
a28 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 5.1 87/06/24 22:12:38 mike Rel $";
@


5.1
log
@Release 1.24
@
text
@d28 1
a28 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 4.5 87/05/28 07:36:25 mike Exp $";
@


4.5
log
@Added more helpful error message when malloc fails.
@
text
@d28 1
a28 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 4.4 87/03/30 16:25:43 mike Locked $";
@


4.4
log
@Left MEMDEBUG code in, but not active.
@
text
@d28 1
a28 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 4.3 87/03/23 23:41:20 mike Locked $";
d69 2
a70 1
	if( ptr==(char *)0 )
d72 1
@


4.3
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d28 1
a28 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 4.2 87/02/12 22:12:03 mike Exp $";
d37 1
a37 1
#define MEMDEBUG 1
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d7 7
d21 1
a21 1
 *	Aberdeen Proving Ground, Maryland  21005
d24 1
a24 1
 *	This software is Copyright (C) 1985 by the United States Army.
d28 1
a28 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 4.1 86/12/29 03:46:06 mike Rel1 $";
d37 1
d39 10
d60 4
a63 1
	RES_ACQUIRE( &rt_g.res_malloc );		/* lock */
d65 1
a65 1
	RES_RELEASE( &rt_g.res_malloc );		/* unlock */
d68 1
a68 1
		rt_log("%x=malloc(%d) %s\n", ptr, cnt, str);
d71 18
d99 23
a121 1
	RES_ACQUIRE( &rt_g.res_malloc );		/* lock */
d124 2
a125 2
	RES_RELEASE( &rt_g.res_malloc );		/* unlock */
	if(rt_g.debug&DEBUG_MEM) rt_log("%x freed %s\n", ptr, str);
d129 26
d157 1
a157 1
 * Given a string, allocate enough memory to hold it using malloc(),
d212 1
a212 3
 *  we get a whole batch, saving overhead.  When this routine is called,
 *  the partition resource must already be locked.
 *  malloc() locking is done in rt_malloc.
d216 2
d220 2
a221 1
rt_get_pt(res)
d228 6
a233 2
	size = PT_BYTES;		/* depends on rt_i.nsolids */
	size = (size + sizeof(long) -1) & (~(sizeof(long)-1));
d273 3
d277 1
a277 1
		pagesz = 1024;		/* getpagesize(); */
d291 1
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d21 1
a21 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 3.5 86/12/24 08:06:18 mike Locked $";
@


3.5
log
@Revised for resource structure.
@
text
@d21 1
a21 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 3.4 86/08/12 04:16:39 mike Exp $";
@


3.4
log
@Changed #include directives for use with CC -I convention
@
text
@d21 1
a21 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 3.3 86/08/08 07:16:01 mike Exp $";
d100 3
a102 1
rt_get_seg()  {
d109 1
a109 2
		rt_log("rt_get_seg: malloc failure\n");
		exit(17);
d113 3
a115 2
		sp->seg_next = rt_g.FreeSeg;
		rt_g.FreeSeg = sp++;
d133 3
a135 1
rt_get_pt()  {
d148 3
a150 2
		((struct partition *)cp)->pt_forw = rt_g.FreePart;
		rt_g.FreePart = (struct partition *)cp;
@


3.3
log
@Changed rt_strdup to have debugging prints,
and to use strlen and bcopy.
@
text
@d21 1
a21 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 3.2 86/07/11 22:01:33 mike Exp $";
d25 4
a28 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/raytrace.h"
#include "debug.h"
@


3.2
log
@removed extra extern.
@
text
@d21 1
a21 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 3.1 86/07/11 01:32:54 mike Exp $";
d78 1
a78 1
	register char	*current;
d80 4
a83 2
	RES_ACQUIRE( &rt_g.res_malloc );		/* lock */
	if( (base = malloc( strlen(cp)+1 )) == (char *)0 )
a84 1
	RES_RELEASE( &rt_g.res_malloc );		/* unlock */
d86 1
a86 5
	current = base;
	do  {
		*current++ = *cp;
	}  while( *cp++ != '\0' );

@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d21 1
a21 1
static char RCSstorage[] = "@@(#)$Header: storage.c,v 3.0 86/06/10 01:33:58 mike Exp $";
a59 2
	extern void free();

@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: storage.c,v 2.4 86/06/09 21:51:11 mike Exp $";
@


2.4
log
@rt and librt separated
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: storage.c,v 2.3 85/09/06 02:29:35 mike Exp $";
d32 1
a32 1
 *  malloc/Free wrappers, for debugging
d35 1
a35 1
vmalloc(cnt, str)
d42 1
a42 1
	RES_ACQUIRE( &res_malloc );		/* lock */
d44 1
a44 1
	RES_RELEASE( &res_malloc );		/* unlock */
d46 2
a47 2
	if( ptr==(char *)0 || debug&DEBUG_MEM )
		rtlog("%x=malloc(%d) %s\n", ptr, cnt, str);
d49 1
a49 1
		rtbomb("vmalloc: malloc failure");
d53 3
d57 1
a57 1
vfree(ptr,str)
d62 1
a62 1
	RES_ACQUIRE( &res_malloc );		/* lock */
d65 2
a66 2
	RES_RELEASE( &res_malloc );		/* unlock */
	if(debug&DEBUG_MEM) rtlog("%x freed %s\n", ptr, str);
d70 27
a96 1
 *  			G E T _ S E G
d102 1
a102 1
 *  malloc() locking is done in vmalloc.
d105 1
a105 1
get_seg()  {
d110 3
a112 3
	bytes = byte_roundup(64*sizeof(struct seg));
	if( (cp = vmalloc(bytes, "get_seg")) == (char *)0 )  {
		rtlog("get_seg: malloc failure\n");
d117 2
a118 2
		sp->seg_next = FreeSeg;
		FreeSeg = sp++;
d124 1
a124 1
 *  			G E T _ P T
d130 1
a130 1
 *  malloc() locking is done in vmalloc.
d136 1
a136 1
get_pt()  {
d141 1
a141 1
	size = PT_BYTES;		/* depends on nsolids */
d143 3
a145 3
	bytes = byte_roundup(64*size);
	if( (cp = vmalloc(bytes, "get_pt")) == (char *)0 )  {
		rtlog("get_pt: malloc failure\n");
d149 2
a150 2
		((struct partition *)cp)->pt_forw = FreePart;
		FreePart = (struct partition *)cp;
d157 1
a157 1
 *  			B Y T E _ R O U N D U P
d174 1
a174 1
byte_roundup(nbytes)
@


2.3
log
@Added routine byte_roundup to adjust malloc requests to
less wasteful sizes, when appropriate.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: storage.c,v 2.2 85/09/05 02:20:49 mike Exp $";
d27 1
a27 1
#include "raytrace.h"
@


2.2
log
@Changed to clobber the memory BEFORE freeing it.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: storage.c,v 2.1 85/08/31 06:06:30 mike Exp $";
d48 2
d81 1
a81 1
	bytes = 64*sizeof(struct seg);
d114 1
a114 1
	bytes = 64*size;
d125 42
@


2.1
log
@Version 2 of RT
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: storage.c,v 1.1 85/07/30 05:55:21 mike Exp $";
d58 1
a61 1
	*((int *)ptr) = -1;	/* zappo! */
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header$";
d47 1
a47 1
		fprintf(stderr,"%x=malloc(%d) %s\n", ptr, cnt, str);
d60 1
a60 1
	if(debug&DEBUG_MEM) fprintf(stderr,"%x freed %s\n", ptr, str);
d81 1
a81 1
		fprintf(stderr,"get_seg: malloc failure\n");
d100 3
a106 1
	register struct partition *pp;
d108 1
d110 3
a112 1
	bytes = 64*sizeof(struct partition);
d114 1
a114 1
		fprintf(stderr,"get_pt: malloc failure\n");
d117 5
a121 5
	pp = (struct partition *)cp;
	while( bytes >= sizeof(struct partition) )  {
		pp->pt_forw = FreePart;
		FreePart = pp++;
		bytes -= sizeof(struct partition);
@
