head	11.36;
access;
symbols
	ansi-20040405-merged:11.32.2.2
	postmerge-20040405-ansi:11.34
	premerge-20040404-ansi:11.33
	postmerge-autoconf:11.33
	autoconf-freeze:11.32.10.2
	premerge-autoconf:11.33
	ansi-20040316-freeze:11.32.2.1
	postmerge-20040315-windows:11.33
	premerge-20040315-windows:11.33
	windows-20040315-freeze:11.32.4.1
	autoconf-20031203:11.32
	autoconf-20031202:11.32
	autoconf-branch:11.32.0.10
	phong-branch:11.32.0.8
	photonmap-branch:11.32.0.6
	rel-6-1-DP:11.32
	windows-branch:11.32.0.4
	rel-6-0-2:11.30
	ansi-branch:11.32.0.2
	rel-6-0-1-branch:11.30.0.2
	hartley-6-0-post:11.31
	hartley-6-0-pre:11.30
	rel-6-0-1:11.30
	rel-6-0:11.29
	rel-5-4:11.23.2.1
	offsite-5-3-pre:11.28
	rel-5-3:11.23.2.1
	rel-5-2:11.23
	rel-5-1-branch:11.23.0.2
	rel-5-1:11.23
	rel-5-0:11.19
	rel-5-0-beta:11.18
	rel-4-5:11.16
	ctj-4-5-post:11.15
	ctj-4-5-pre:11.14
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.36
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.35;

11.35
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.34;

11.34
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.33;

11.33
date	2004.02.02.17.39.27;	author morrison;	state Exp;
branches;
next	11.32;

11.32
date	2002.08.20.17.08.06;	author jra;	state Exp;
branches
	11.32.2.1
	11.32.4.1
	11.32.10.1;
next	11.31;

11.31
date	2002.08.15.20.55.19;	author hartley;	state Exp;
branches;
next	11.30;

11.30
date	2002.08.06.14.41.29;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	2001.04.05.19.35.36;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2000.09.01.02.19.10;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.08.21.02.02.33;	author butler;	state Exp;
branches;
next	11.26;

11.26
date	2000.07.25.16.46.06;	author butler;	state Exp;
branches;
next	11.25;

11.25
date	2000.07.14.17.14.35;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	2000.07.10.23.01.46;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.05.02.01.46.05;	author mike;	state Exp;
branches
	11.23.2.1;
next	11.22;

11.22
date	2000.03.28.20.41.05;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.03.28.20.39.12;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	99.12.30.04.55.28;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.06.03.01.43.38;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	99.05.11.21.01.32;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	99.05.11.19.26.14;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	98.01.29.15.57.18;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	97.08.15.19.25.30;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	97.06.23.13.27.33;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	97.06.19.22.27.11;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	96.09.06.17.43.33;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	96.08.14.03.44.14;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	96.05.16.21.48.55;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	96.04.24.22.14.13;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	96.04.23.14.53.30;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.04.18.18.46.01;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.04.12.14.19.39;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.03.17.20.16.42;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	95.02.15.22.38.37;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.02.15.10.06.08;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.18;	author mike;	state Rel4_4;
branches;
next	1.48;

1.48
date	94.12.27.16.07.51;	author mike;	state Exp;
branches;
next	1.47;

1.47
date	94.12.27.11.30.47;	author jra;	state Exp;
branches;
next	1.46;

1.46
date	94.12.20.15.46.48;	author jra;	state Exp;
branches;
next	1.45;

1.45
date	94.12.05.19.03.03;	author butler;	state Exp;
branches;
next	1.44;

1.44
date	94.11.10.15.33.46;	author jra;	state Exp;
branches;
next	1.43;

1.43
date	94.11.10.15.01.30;	author jra;	state Exp;
branches;
next	1.42;

1.42
date	94.11.08.04.01.08;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	94.11.08.03.56.41;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	94.10.12.03.36.29;	author butler;	state Exp;
branches;
next	1.39;

1.39
date	94.09.30.22.15.36;	author butler;	state Exp;
branches;
next	1.38;

1.38
date	94.09.24.07.26.43;	author butler;	state Exp;
branches;
next	1.37;

1.37
date	94.09.24.05.40.11;	author butler;	state Exp;
branches;
next	1.36;

1.36
date	94.09.16.20.52.59;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	94.08.24.22.49.51;	author butler;	state Exp;
branches;
next	1.34;

1.34
date	94.08.10.21.15.16;	author gdurf;	state Exp;
branches;
next	1.33;

1.33
date	94.08.10.18.58.19;	author gdurf;	state Exp;
branches;
next	1.32;

1.32
date	94.08.09.19.38.31;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	94.04.23.11.51.06;	author butler;	state Exp;
branches;
next	1.30;

1.30
date	94.04.22.10.04.26;	author butler;	state Exp;
branches;
next	1.29;

1.29
date	94.04.21.07.22.37;	author butler;	state Exp;
branches;
next	1.28;

1.28
date	94.04.19.16.44.58;	author butler;	state Exp;
branches;
next	1.27;

1.27
date	94.03.10.06.47.44;	author butler;	state Exp;
branches;
next	1.26;

1.26
date	94.02.24.08.27.57;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	94.02.23.23.38.29;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	94.02.17.11.14.42;	author butler;	state Exp;
branches;
next	1.23;

1.23
date	94.01.07.09.56.06;	author jra;	state Exp;
branches;
next	1.22;

1.22
date	94.01.06.19.16.11;	author butler;	state Exp;
branches;
next	1.21;

1.21
date	94.01.03.18.04.47;	author butler;	state Exp;
branches;
next	1.20;

1.20
date	93.12.27.22.45.42;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	93.12.27.22.36.05;	author butler;	state Exp;
branches;
next	1.18;

1.18
date	93.12.23.08.15.49;	author butler;	state Exp;
branches;
next	1.17;

1.17
date	93.12.23.05.38.59;	author butler;	state Exp;
branches;
next	1.16;

1.16
date	93.12.23.01.00.08;	author butler;	state Exp;
branches;
next	1.15;

1.15
date	93.12.22.23.35.32;	author butler;	state Exp;
branches;
next	1.14;

1.14
date	93.12.22.06.12.03;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	93.12.03.03.35.51;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	93.12.02.20.29.53;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	93.12.02.20.28.33;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	93.11.19.04.10.47;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	93.11.18.06.50.24;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	93.11.18.01.39.38;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	93.11.18.01.32.31;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	93.11.06.02.02.12;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	93.11.06.01.32.10;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	93.10.01.20.48.21;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	93.10.01.20.47.00;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	93.06.04.20.50.50;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	93.02.26.00.55.45;	author butler;	state Exp;
branches;
next	;

11.23.2.1
date	2000.11.09.14.40.59;	author jra;	state Exp;
branches;
next	;

11.32.2.1
date	2002.09.19.18.01.42;	author morrison;	state Exp;
branches;
next	11.32.2.2;

11.32.2.2
date	2004.03.17.21.18.55;	author morrison;	state Exp;
branches;
next	;

11.32.4.1
date	2004.03.11.23.43.43;	author morrison;	state Exp;
branches;
next	;

11.32.10.1
date	2004.02.12.18.37.45;	author erikg;	state Exp;
branches;
next	11.32.10.2;

11.32.10.2
date	2004.03.15.14.07.28;	author erikg;	state Exp;
branches;
next	;


desc
@NMG face(use) triangulation support
@


11.36
log
@moved to src/
@
text
@/*			N M G _ T R I . C
 *
 *  Triangulate the faces of a polygonal NMG
 * 
 *  Author -
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_tri.c,v 11.35 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "plot3.h"

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/* macros for comparing 2D points in scanline order */
#if 0
#define P_GT_V(_p, _v) \
	(((_p)->coord[Y] > (_v)->coord[Y]) || ((_p)->coord[Y] == (_v)->coord[Y] && (_p)->coord[X] < (_v)->coord[X]))
#define P_LT_V(_p, _v) \
	(((_p)->coord[Y] < (_v)->coord[Y]) || ((_p)->coord[Y] == (_v)->coord[Y] && (_p)->coord[X] > (_v)->coord[X]))
#define P_GE_V(_p, _v) \
	(((_p)->coord[Y] > (_v)->coord[Y]) || ((_p)->coord[Y] == (_v)->coord[Y] && (_p)->coord[X] <= (_v)->coord[X]))
#define P_LE_V(_p, _v) \
	(((_p)->coord[Y] < (_v)->coord[Y]) || ((_p)->coord[Y] == (_v)->coord[Y] && (_p)->coord[X] >= (_v)->coord[X]))
#else
#define TOL_2D	1.0e-10
#define P_GT_V(_p, _v) \
	(((_p)->coord[Y] - (_v)->coord[Y]) > TOL_2D || (NEAR_ZERO((_p)->coord[Y] - (_v)->coord[Y], TOL_2D) && (_p)->coord[X] < (_v)->coord[X]))
#define P_LT_V(_p, _v) \
	(((_p)->coord[Y] - (_v)->coord[Y]) < (-TOL_2D) || (NEAR_ZERO((_p)->coord[Y] - (_v)->coord[Y], TOL_2D) && (_p)->coord[X] > (_v)->coord[X]))
#define P_GE_V(_p, _v) \
	(((_p)->coord[Y] - (_v)->coord[Y]) > TOL_2D || (NEAR_ZERO((_p)->coord[Y] - (_v)->coord[Y], TOL_2D) && (_p)->coord[X] <= (_v)->coord[X]))
#define P_LE_V(_p, _v) \
	(((_p)->coord[Y] - (_v)->coord[Y]) < (-TOL_2D) || (NEAR_ZERO((_p)->coord[Y] - (_v)->coord[Y], TOL_2D) && (_p)->coord[X] >= (_v)->coord[X]))
#endif

#define NMG_PT2D_MAGIC	0x2d2d2d2d
#define NMG_TRAP_MAGIC  0x1ab1ab
#define	NMG_CK_PT2D(_p)	NMG_CKMAG(_p, NMG_PT2D_MAGIC, "pt2d")
#define	NMG_CK_TRAP(_p)	{NMG_CKMAG(_p, NMG_TRAP_MAGIC, "trap");\
	if ( ! BU_LIST_PREV(bu_list, &(_p)->l) ) {\
		bu_log("%s %d bad prev pointer of trapezoid 0x%08x\n",\
			__FILE__, __LINE__, &(_p)->l);\
		rt_bomb("NMG_CK_TRAP: aborting");\
	} else if (! BU_LIST_NEXT(bu_list, &(_p)->l) ) {\
		bu_log("%s %d bad next pointer of trapezoid 0x%08x\n",\
			__FILE__, __LINE__, &(_p)->l);\
		rt_bomb("NMG_CL_TRAP: aborting");\
	}}

#define NMG_TBL2D_MAGIC 0x3e3e3e3e
#define NMG_CK_TBL2D(_p) NMG_CKMAG(_p, NMG_TBL2D_MAGIC, "tbl2d")

/* macros to retrieve the next/previous 2D point about loop */
#define PT2D_NEXT(tbl, pt) pt2d_pn(tbl, pt, 1)
#define PT2D_PREV(tbl, pt) pt2d_pn(tbl, pt, -1)

struct pt2d {
	struct bu_list	l;		/* scanline ordered list of points */
	fastf_t	coord[3];		/* point coordinates in 2-D space */
	struct vertexuse *vu_p;		/* associated vertexuse */
};


struct trap {
	struct bu_list	l;
	struct pt2d	*top;	   /* point at top of trapezoid */
	struct pt2d	*bot;	   /* point at bottom of trapezoid */
	struct edgeuse	*e_left;
	struct edgeuse	*e_right;
};

/* if there is an edge in this face which connects the points
 *	return 1
 * else
 *	return 0
 */


/* subroutine version to pass to the rt_tree functions */
int PvsV(struct trap *p, struct trap *v)
{
	NMG_CK_TRAP(p);
	NMG_CK_TRAP(v);

	if (p->top->coord[Y] > v->top->coord[Y]) return(1);
	else if (p->top->coord[Y] < v->top->coord[Y]) return(-1);
	else if (p->top->coord[X] < v->top->coord[X]) return(1);
	else if (p->top->coord[X] > v->top->coord[X]) return(-1);
	else	return(0);
}


static struct pt2d *find_pt2d(struct bu_list *tbl2d, struct vertexuse *vu);	
static FILE *plot_fd;

static void
print_2d_eu(char *s, struct edgeuse *eu, struct bu_list *tbl2d)
{
	struct pt2d *pt, *pt_next;
	NMG_CK_TBL2D(tbl2d);
	NMG_CK_EDGEUSE(eu);

	pt = find_pt2d(tbl2d, eu->vu_p);
	pt_next = find_pt2d(tbl2d, (BU_LIST_PNEXT_CIRC(edgeuse, eu))->vu_p);
	bu_log("%s: 0x%08x %g %g -> %g %g\n", s, eu,
		pt->coord[X], pt->coord[Y],
		pt_next->coord[X], pt_next->coord[Y]);	
}


static void
print_trap(struct trap *tp, struct bu_list *tbl2d)
{
	NMG_CK_TBL2D(tbl2d);
	NMG_CK_TRAP(tp);

	bu_log("trap 0x%08x top pt2d: 0x%08x %g %g vu:0x%08x\n",
			tp,
			&tp->top, tp->top->coord[X], tp->top->coord[Y],
			tp->top->vu_p);

	if (tp->bot)
		bu_log("\t\tbot pt2d: 0x%08x %g %g vu:0x%08x\n",
			&tp->bot, tp->bot->coord[X], tp->bot->coord[Y],
			tp->bot->vu_p);
	else {
		bu_log("\tbot (nil)\n");
	}
			
	if (tp->e_left)
		print_2d_eu("\t\t  e_left", tp->e_left, tbl2d);

	if (tp->e_right)
		print_2d_eu("\t\t e_right", tp->e_right, tbl2d);
}
static void
print_tlist(struct bu_list *tbl2d, struct bu_list *tlist)
{
	struct trap *tp;
	NMG_CK_TBL2D(tbl2d);

	bu_log("Trapezoid list start ----------\n");
	for (BU_LIST_FOR(tp, trap, tlist)) {
		NMG_CK_TRAP(tp);
		print_trap(tp, tbl2d);
	}
	bu_log("Trapezoid list end ----------\n");
}

static int flatten_debug=1;

static struct pt2d *
find_pt2d(struct bu_list *tbl2d, struct vertexuse *vu)
{
	struct pt2d *p;
	NMG_CK_TBL2D(tbl2d);
	NMG_CK_VERTEXUSE(vu);

	for (BU_LIST_FOR(p, pt2d, tbl2d)) {
		if (p->vu_p == vu) {
			return p;
		}
	}
	return (struct pt2d *)NULL;
}

static void
nmg_tri_plfu(struct faceuse *fu, struct bu_list *tbl2d)
{
	static int file_number=0;
	FILE *fd;
	char name[25];
	char buf[80];
	long *b;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct vertexuse *vu;
	struct pt2d *p;

	NMG_CK_TBL2D(tbl2d);
	NMG_CK_FACEUSE(fu);
	
	sprintf(name, "tri%02d.pl", file_number++);
	if ((fd=fopen(name, "w")) == (FILE *)NULL) {
		perror(name);
		abort();
	}

	bu_log("\tplotting %s\n", name);
	b = (long *)bu_calloc( fu->s_p->r_p->m_p->maxindex,
		sizeof(long), "bit vec"),

	pl_erase(fd);
	pd_3space(fd,
		fu->f_p->min_pt[0]-1.0,
		fu->f_p->min_pt[1]-1.0,
		fu->f_p->min_pt[2]-1.0,
		fu->f_p->max_pt[0]+1.0,
		fu->f_p->max_pt[1]+1.0,
		fu->f_p->max_pt[2]+1.0);
	
	nmg_pl_fu(fd, fu, b, 255, 255, 255);

	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		NMG_CK_LOOPUSE(lu);
		if ( BU_LIST_IS_EMPTY(&lu->down_hd) ) {
			bu_log("Empty child list for loopuse %s %d\n", __FILE__, __LINE__);
		} else if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC){
			vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
			pdv_3move(fd, vu->v_p->vg_p->coord);
			if ( (p=find_pt2d(tbl2d, vu)) ) {
				sprintf(buf, "%g, %g",
					p->coord[0], p->coord[1]);
				pl_label(fd, buf);
			} else
				pl_label(fd, "X, Y (no 2D coords)");

		} else {
			eu = BU_LIST_FIRST(edgeuse, &lu->down_hd);
			NMG_CK_EDGEUSE( eu );

			for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				if ( (p=find_pt2d(tbl2d,eu->vu_p)) ) {
					pdv_3move(fd, eu->vu_p->v_p->vg_p->coord);

					sprintf(buf, "%g, %g",
						p->coord[0], p->coord[1]);
					pl_label(fd, buf);
				} else
					pl_label(fd, "X, Y (no 2D coords)");
			}
		}
	}


	bu_free((char *)b, "plot table");
	fclose(fd);
}



/*	P T 2 D _ P N
 *
 *	Return Prev/Next 2D pt about loop from given 2D pt.
 *	if vertex is child of loopuse, return parameter 2D pt.
 */
static struct pt2d *
pt2d_pn(struct bu_list *tbl, struct pt2d *pt, int dir)
{
	struct edgeuse *eu, *eu_other;
	struct pt2d *new_pt;

	NMG_CK_TBL2D(tbl);
	NMG_CK_PT2D( pt );
	NMG_CK_VERTEXUSE( (pt)->vu_p );

	if ( *(pt)->vu_p->up.magic_p == NMG_EDGEUSE_MAGIC) {
		eu = (pt)->vu_p->up.eu_p;
		NMG_CK_EDGEUSE( eu );
		if (dir < 0)
			eu_other = BU_LIST_PPREV_CIRC(edgeuse, eu);
		else
			eu_other = BU_LIST_PNEXT_CIRC(edgeuse, eu);

		new_pt = find_pt2d(tbl, eu_other->vu_p);
		if (new_pt == (struct pt2d *)NULL) {
			if (dir < 0)
				bu_log("can't find prev of %g %g\n",
					pt->coord[X],
					pt->coord[Y]);
			else
				bu_log("can't find next of %g %g\n",
					pt->coord[X],
					pt->coord[Y]);
			rt_bomb("goodbye\n");
		}
		NMG_CK_PT2D( new_pt );
		return new_pt;
	}

	if ( *(pt)->vu_p->up.magic_p != NMG_LOOPUSE_MAGIC) {
		bu_log("%s %d Bad vertexuse parent (%g %g %g)\n",
			__FILE__, __LINE__,
			V3ARGS( (pt)->vu_p->v_p->vg_p->coord ) );
		rt_bomb("goodbye\n");
	}

	return pt;
}



/*	M A P _ V U _ T O _ 2 D
 *
 *	Add a vertex to the 2D table if it isn't already there.
 */
static void
map_vu_to_2d(struct vertexuse *vu, struct bu_list *tbl2d, fastf_t *mat, struct faceuse *fu)
{
	struct vertex_g *vg;
	struct vertexuse *vu_p;
	struct vertex *vp;
	struct pt2d *p, *np;

	NMG_CK_TBL2D(tbl2d);
	NMG_CK_VERTEXUSE(vu);
	NMG_CK_FACEUSE(fu);

	/* if this vertexuse has already been transformed, we're done */
	if (find_pt2d(tbl2d, vu)) return;


	np = (struct pt2d *)bu_calloc(1, sizeof(struct pt2d), "pt2d struct");
	np->coord[2] = 0.0;
	np->vu_p = vu;
	BU_LIST_MAGIC_SET(&np->l, NMG_PT2D_MAGIC);

	/* if one of the other vertexuses has been mapped, use that data */
	for (BU_LIST_FOR(vu_p, vertexuse, &vu->v_p->vu_hd)) {
		if ( (p = find_pt2d(tbl2d, vu_p)) ) {
			VMOVE(np->coord, p->coord);
			return;
		}
	}

	/* transform the 3-D vertex into a 2-D vertex */
	vg = vu->v_p->vg_p;
	MAT4X3PNT(np->coord, mat, vg->coord);


	if (rt_g.NMG_debug & DEBUG_TRI && flatten_debug) bu_log(
		"Transforming 0x%x 3D(%g, %g, %g) to 2D(%g, %g, %g)\n",
		vu, V3ARGS(vg->coord), V3ARGS(np->coord) );

	/* find location in scanline ordered list for vertex */
	for ( BU_LIST_FOR(p, pt2d, tbl2d) ) {
		if (P_GT_V(p, np)) continue;
		break;
	}
	BU_LIST_INSERT(&p->l, &np->l);

	if (rt_g.NMG_debug & DEBUG_TRI && flatten_debug)
		bu_log("transforming other vertexuses...\n");

	/* for all other uses of this vertex in this face, store the
	 * transformed 2D vertex
	 */
	vp = vu->v_p;

	for (BU_LIST_FOR(vu_p, vertexuse, &vp->vu_hd)) {
		register struct faceuse *fu_of_vu;
		NMG_CK_VERTEXUSE(vu_p);

		if (vu_p == vu) continue;

		fu_of_vu = nmg_find_fu_of_vu(vu_p);
		if( !fu_of_vu )  continue;	/* skip vu's of wire edges */
		NMG_CK_FACEUSE(fu_of_vu);
		if (fu_of_vu != fu) continue;

		if (rt_g.NMG_debug & DEBUG_TRI && flatten_debug)
			bu_log("transform 0x%x... ", vu_p);

		/* if vertexuse already transformed, skip it */
		if (find_pt2d(tbl2d, vu_p)) {
			if (rt_g.NMG_debug & DEBUG_TRI && flatten_debug) {
				bu_log("vertexuse already transformed\n", vu);
				nmg_pr_vu(vu, NULL);
			}
			continue;
		}

		/* add vertexuse to list */
		p = (struct pt2d *)bu_calloc(1, sizeof(struct pt2d), "pt2d");
		p->vu_p = vu_p;
		VMOVE(p->coord, np->coord);
		BU_LIST_MAGIC_SET(&p->l, NMG_PT2D_MAGIC);

		BU_LIST_APPEND(&np->l, &p->l);

		if (rt_g.NMG_debug & DEBUG_TRI && flatten_debug)
			(void)bu_log( "vertexuse transformed\n");
	}
	if (rt_g.NMG_debug & DEBUG_TRI && flatten_debug)
		(void)bu_log( "Done.\n");
}

/*	N M G _ F L A T T E N _ F A C E
 *
 *	Create the 2D coordinate table for the vertexuses of a face.
 *
 *	---------	-----------------------------------
 *	|pt2d --+-----> |     struct pt2d.{magic,coord[3]} |
 *	---------	-----------------------------------
 *			|     struct pt2d.{magic,coord[3]} |
 *			-----------------------------------
 *			|     struct pt2d.{magic,coord[3]} |
 *			-----------------------------------
 *	
 *	When the caller is done, nmg_free_2d_map() should be called to dispose
 *	of the map
 */
struct bu_list *
nmg_flatten_face(struct faceuse *fu, fastf_t *TformMat)
{
	static const vect_t twoDspace = { 0.0, 0.0, 1.0 };
	struct bu_list *tbl2d;
	struct vertexuse *vu;
	struct loopuse *lu;
	struct edgeuse *eu;
	vect_t Normal;

	NMG_CK_FACEUSE(fu);

	tbl2d = (struct bu_list *)bu_calloc(1, sizeof(struct bu_list),
		"2D coordinate list");

	/* we use the 0 index entry in the table as the head of the sorted
	 * list of verticies.  This is safe since the 0 index is always for
	 * the model structure
	 */

	BU_LIST_INIT( tbl2d );
	BU_LIST_MAGIC_SET(tbl2d, NMG_TBL2D_MAGIC);

	/* construct the matrix that maps the 3D coordinates into 2D space */
	NMG_GET_FU_NORMAL(Normal, fu);
	bn_mat_fromto( TformMat, Normal, twoDspace );

	if (rt_g.NMG_debug & DEBUG_TRI && flatten_debug)
		bn_mat_print( "TformMat", TformMat );


	/* convert each vertex in the face to its 2-D equivalent */
	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		if (rt_g.NMG_debug & DEBUG_TRI) {
			switch (lu->orientation) {
			case OT_NONE:	bu_log("flattening OT_NONE loop\n"); break;
			case OT_SAME:	bu_log("flattening OT_SAME loop\n"); break;
			case OT_OPPOSITE:bu_log("flattening OT_OPPOSITE loop\n"); break;
			case OT_UNSPEC:	bu_log("flattening OT_UNSPEC loop\n"); break;
			case OT_BOOLPLACE:bu_log("flattening OT_BOOLPLACE loop\n"); break;
			default: bu_log("flattening bad orientation loop\n"); break;
			}
		}
		if (BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC) {
			vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
  			if (rt_g.NMG_debug & DEBUG_TRI && flatten_debug)
				bu_log("vertex loop\n");
			map_vu_to_2d(vu, tbl2d, TformMat, fu);

		} else if (BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC) {
			if (rt_g.NMG_debug & DEBUG_TRI && flatten_debug)
				bu_log("edge loop\n");
			for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				vu = eu->vu_p;
				if (rt_g.NMG_debug & DEBUG_TRI && flatten_debug)
					bu_log("(%g %g %g) -> (%g %g %g)\n",
						V3ARGS(vu->v_p->vg_p->coord),
						V3ARGS(eu->eumate_p->vu_p->v_p->vg_p->coord));
				map_vu_to_2d(vu, tbl2d, TformMat, fu);
			}
		} else rt_bomb("bad magic of loopuse child\n");
	}

	return(tbl2d);
}



static int
is_convex(struct pt2d *a, struct pt2d *b, struct pt2d *c, const struct bn_tol *tol)
{
	vect_t ab, bc, pv, N;
	double angle;
	
	NMG_CK_PT2D(a);
	NMG_CK_PT2D(b);
	NMG_CK_PT2D(c);

	/* invent surface normal */
	VSET(N, 0.0, 0.0, 1.0);

	/* form vector from a->b */
	VSUB2(ab, b->coord, a->coord);

	/* Form "left" vector */
	VCROSS(pv, N, ab);

	/* form vector from b->c */
	VSUB2(bc, c->coord, b->coord);

	/* find angle about normal in "pv" direction from a->b to b->c */
	angle = bn_angle_measure( bc, ab, pv );

	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("\tangle == %g tol angle: %g\n", angle, tol->perp);

	return (angle > tol->perp && angle <= M_PI-tol->perp);
}

#define POLY_SIDE 1
#define HOLE_START 2
#define POLY_START 3
#define HOLE_END 4
#define POLY_END 5
#define HOLE_POINT 6
#define POLY_POINT 7



/*
 *
 *	characterize the edges which meet at this vertex.
 *
 *	  1 	     2	       3	   4	    5	      6		7
 *
 *      /- -\	  -------		-\   /-     \---/  -------
 *     /-- --\	  ---O---	O	--\ /--      \-/   ---O---	O
 *    O--- ---O	  --/ \--      /-\	---O---       O	   -------
 *     \-- --/	  -/   \-     /---\	-------	
 *      \- -/	
 *
 *    Poly Side		    Poly Start 		   Poly End
 *	         Hole Start    		Hole end   
 */
static int
vtype2d(struct pt2d *v, struct bu_list *tbl2d, const struct bn_tol *tol)
{
	struct pt2d *p, *n;	/* previous/this edge endpoints */
	struct loopuse *lu;

	NMG_CK_TBL2D(tbl2d);
	NMG_CK_PT2D(v);

	/* get the next/previous points relative to v */
	p = PT2D_PREV(tbl2d, v);
	n = PT2D_NEXT(tbl2d, v);


	lu = nmg_find_lu_of_vu( v->vu_p );

	if (p == n && n == v) {
		/* loopuse of vertexuse or loopuse of 1 edgeuse */
		if (lu->orientation == OT_SAME)
			return(POLY_POINT);
		else if (lu->orientation == OT_OPPOSITE)
			return(HOLE_POINT);
	}

	if (P_GT_V(n, v) && P_GT_V(p, v)) {
		/* 
		 *   \   /
		 *    \ /
		 *     .
		 *
		 * if this is a convex point, this is a polygon end
		 * if it is a concave point, this is a hole end
		 */

		if (p == n) {
			if (lu->orientation == OT_OPPOSITE)
				return(HOLE_END);
			else if (lu->orientation == OT_SAME)
				return(POLY_END);
			else {
				bu_log("%s: %d loopuse is not OT_SAME or OT_OPPOSITE\n",
					__FILE__, __LINE__);
				rt_bomb("bombing\n");
			}
		}

		if (is_convex(p, v, n, tol)) return(POLY_END);
		else return(HOLE_END);
		
	}

	if (P_LT_V(n, v) && P_LT_V(p, v)) {
		/*      .
		 *     / \
		 *    /   \
		 *
		 * if this is a convex point, this is a polygon start
		 * if this is a concave point, this is a hole start
		 */

		if (p == n) {
			if (lu->orientation == OT_OPPOSITE)
				return(HOLE_START);
			else if (lu->orientation == OT_SAME)
				return(POLY_START);
			else {
				bu_log("%s: %d loopuse is not OT_SAME or OT_OPPOSITE\n",
					__FILE__, __LINE__);
				rt_bomb("bombing\n");
			}
		}

		if (is_convex(p, v, n, tol))
			return(POLY_START);
		else
			return(HOLE_START);
	}
	if ( (P_GT_V(n, v) && P_LT_V(p, v)) ||
	    (P_LT_V(n, v) && P_GT_V(p, v)) ) {
	    	/*
	    	 *  |
	    	 *  |
	    	 *  .
	    	 *   \
	    	 *    \
	    	 *
	    	 * This is the "side" of a polygon.
	    	 */
		return(POLY_SIDE);
	}
	bu_log(
		"%s %d HELP! special case:\n(%g %g)->(%g %g)\n(%g %g)->(%g %g)\n",
		__FILE__, __LINE__,
		p->coord[X], p->coord[Y],
		v->coord[X], v->coord[Y],
		n->coord[X], n->coord[Y]);

	return(0);
}

/*	Polygon point start.
 *
 *	  O
 *	 /-\
 *	/---\
 *	v
 *
 *	start new trapezoid
 */
static void
poly_start_vertex(struct pt2d *pt, struct bu_list *tbl2d, struct bu_list *tlist)
{
	struct trap *new_trap;

	NMG_CK_TBL2D(tbl2d);
	NMG_CK_PT2D(pt);
	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log( "%g %g is polygon start vertex\n",
				pt->coord[X], pt->coord[Y]);

	new_trap = (struct trap *)bu_calloc(sizeof(struct trap), 1, "new poly_start trap");
	new_trap->top = pt;
	new_trap->bot = (struct pt2d *)NULL;
	new_trap->e_left = pt->vu_p->up.eu_p;
	new_trap->e_right = BU_LIST_PPREV_CIRC(edgeuse, pt->vu_p->up.eu_p);
	BU_LIST_MAGIC_SET(&new_trap->l, NMG_TRAP_MAGIC);

	/* add new trapezoid */
	BU_LIST_APPEND(tlist, &new_trap->l);
	NMG_CK_TRAP(new_trap);
}

/*
 *		^
 *	  /-	-\
 *	 /--	--\
 *	O---	---O
 *	 \--	--/
 *	  \-	-/
 *	   v
 *
 *	finish trapezoid from vertex, start new trapezoid from vertex
 */
static void
poly_side_vertex(struct pt2d *pt, struct pt2d *tbl2d, struct bu_list *tlist)
{
	struct trap *new_trap, *tp;
	struct edgeuse *upper_edge=NULL, *lower_edge=NULL;
	struct pt2d *pnext, *plast;

	NMG_CK_TBL2D(tbl2d);
	NMG_CK_PT2D(pt);
	pnext = PT2D_NEXT(&tbl2d->l, pt);
	plast = PT2D_PREV(&tbl2d->l, pt);
	if (rt_g.NMG_debug & DEBUG_TRI) {
		bu_log( "%g %g is polygon side vertex\n",
			pt->coord[X], pt->coord[Y]);
		bu_log( "%g %g -> %g %g -> %g %g\n",
			plast->coord[X],
			plast->coord[Y],
			pt->coord[X], pt->coord[Y],
			pnext->coord[X],
			pnext->coord[Y]);
	}

	/* find upper edge */
	if (P_LT_V(plast, pt) && P_GT_V(pnext, pt)) {
		/* ascending edge */
		upper_edge = pt->vu_p->up.eu_p;
		lower_edge = plast->vu_p->up.eu_p;
	} else if (P_LT_V(pnext, pt) && P_GT_V(plast, pt)) {
		/* descending edge */
		upper_edge = plast->vu_p->up.eu_p;
		lower_edge = pt->vu_p->up.eu_p;
 	}

	NMG_CK_EDGEUSE(upper_edge);
	NMG_CK_EDGEUSE(lower_edge);

	/* find the uncompleted trapezoid in the tree
	 * which contains the upper edge.  This is the trapezoid we will
	 * complete, and where we will add a new trapezoid
	 */
	for (BU_LIST_FOR(tp, trap, tlist)) {
		NMG_CK_TRAP(tp);
		NMG_CK_EDGEUSE(tp->e_left);
		NMG_CK_EDGEUSE(tp->e_right);
		if ((tp->e_left == upper_edge || tp->e_right == upper_edge) &&
		    tp->bot == (struct pt2d *)NULL) {
			break;
		    }
	}

	if (BU_LIST_MAGIC_WRONG(&tp->l, NMG_TRAP_MAGIC))
		rt_bomb ("didn't find trapezoid parent\n");

	/* complete trapezoid */
	tp->bot = pt;

	/* create new trapezoid with other (not upper) edge */
	new_trap = (struct trap *)bu_calloc(sizeof(struct trap), 1, "new side trap");
	BU_LIST_MAGIC_SET(&new_trap->l, NMG_TRAP_MAGIC);
	new_trap->top = pt;
	new_trap->bot = (struct pt2d *)NULL;
	if (tp->e_left == upper_edge) {
		new_trap->e_left = lower_edge;
		new_trap->e_right = tp->e_right;
	} else if (tp->e_right == upper_edge) {
		new_trap->e_right = lower_edge;
		new_trap->e_left = tp->e_left;
	} else	/* how did I get here? */
		rt_bomb("Why me?  Always me!\n");

	BU_LIST_INSERT(tlist, &new_trap->l);
	NMG_CK_TRAP(new_trap);
}


/*	Polygon point end.
 *
 *	     ^
 *	\---/
 *	 \-/
 *	  O
 *
 *	complete trapezoid
 */
static void
poly_end_vertex(struct pt2d *pt, struct bu_list *tbl2d, struct bu_list *tlist)
{
	struct trap *tp;
	struct edgeuse *e_left, *e_right;
	struct pt2d *pprev;

	NMG_CK_TBL2D(tbl2d);
	NMG_CK_PT2D(pt);
	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log( "%g %g is polygon end vertex\n",
			pt->coord[X], pt->coord[Y]);

	/* get the two edges which end at this point */
	pprev = PT2D_PREV(tbl2d, pt);
	if (pprev == pt)
		rt_bomb("pprev == pt!\n");

	e_left = pprev->vu_p->up.eu_p;
	e_right = pt->vu_p->up.eu_p;

	/* find the trapezoid in tree which has
	 * both edges ending at this point.
	 */
	for (BU_LIST_FOR(tp, trap, tlist)) {
		NMG_CK_TRAP(tp);
		if (tp->e_left == e_left && tp->e_right == e_right && !tp->bot) {
			goto trap_found;
		} else if (tp->e_right == e_left && tp->e_left == e_right &&
		    !tp->bot) {
			/* straighten things out for notational convenience*/
			e_right = tp->e_right;
			e_left = tp->e_left;
			goto trap_found;
		}
	}

	rt_bomb("Didn't find trapezoid to close!\n");

	/* Complete the trapezoid. */
trap_found:
	tp->bot = pt;
}








/*	Hole Start in polygon
 *
 *	-------
 *	---O---
 *	--/ \--
 *	-/   \-
 *	      v
 *
 *	Finish existing trapezoid, start 2 new ones
 */
static void
hole_start_vertex(struct pt2d *pt, struct bu_list *tbl2d, struct bu_list *tlist)
{
	struct trap *tp, *new_trap;
	vect_t pv, ev, n;
	struct pt2d *e_pt, *next_pt;

	NMG_CK_TBL2D(tbl2d);
	NMG_CK_PT2D(pt);
	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log( "%g %g is hole start vertex\n", 
			pt->coord[X], pt->coord[Y]);

	/* we need to find the un-completed trapezoid which encloses this
	 * point.
	 */
	for (BU_LIST_FOR(tp, trap, tlist)) {
		NMG_CK_TRAP(tp);
		/* obviously, if the trapezoid has been completed, it's not
		 * the one we want.
		 */
		if (tp->bot) {
			if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log("Trapezoid %g %g / %g %g completed... Skipping\n",
					tp->top->coord[X],
					tp->top->coord[Y],
					tp->bot->coord[X],
					tp->bot->coord[Y]);
			continue;
		}

		/* if point is at the other end of either the left edge
		 * or the right edge, we've found the trapezoid to complete.
		 *
		 * First, we check the left edge
		 */
		e_pt = find_pt2d(tbl2d, tp->e_left->vu_p);
		next_pt = find_pt2d(tbl2d,
			(BU_LIST_PNEXT_CIRC(edgeuse, tp->e_left))->vu_p);

		if (e_pt->vu_p->v_p == pt->vu_p->v_p ||
		    next_pt->vu_p->v_p == pt->vu_p->v_p)
			goto gotit;


		/* check to see if the point is at the end of the right edge
		 * of the trapezoid
		 */
		e_pt = find_pt2d(tbl2d, tp->e_right->vu_p);
		next_pt = find_pt2d(tbl2d,
			(BU_LIST_PNEXT_CIRC(edgeuse, tp->e_right))->vu_p);

		if (e_pt->vu_p->v_p == pt->vu_p->v_p ||
		    next_pt->vu_p->v_p == pt->vu_p->v_p)
			goto gotit;


		/* if point is right of left edge and left of right edge
		 * we've found the trapezoid we need to work with.
		 */

		/* form a vector from the start point of each edge to pt.
		 * if crossing this vector with the vector of the edge
		 * produces a vector with a positive Z component then the pt
		 * is "inside" the trapezoid as far as this edge is concerned
		 */
		e_pt = find_pt2d(tbl2d, tp->e_left->vu_p);
		next_pt = find_pt2d(tbl2d,
			(BU_LIST_PNEXT_CIRC(edgeuse, tp->e_left))->vu_p);
		VSUB2(pv, pt->coord, e_pt->coord);
		VSUB2(ev, next_pt->coord, e_pt->coord);
		VCROSS(n, ev, pv);
		if (n[2] <= 0.0) {
			if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log("Continue #1\n");
			continue;
		}

		e_pt = find_pt2d(tbl2d, tp->e_right->vu_p);
		next_pt = find_pt2d(tbl2d,
			(BU_LIST_PNEXT_CIRC(edgeuse, tp->e_right))->vu_p);
		VSUB2(pv, pt->coord, e_pt->coord);
		VSUB2(ev, next_pt->coord, e_pt->coord);
		VCROSS(n, ev, pv);
		if (n[2] <= 0.0) {
			if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log("Continue #2\n");
			continue;
		}

		goto gotit;

	}

	bu_log("didn't find trapezoid for hole-start point at:\n\t%g %g %g\n",
		V3ARGS(pt->vu_p->v_p->vg_p->coord) );

	nmg_stash_model_to_file("tri_lone_hole.g",
		nmg_find_model(&pt->vu_p->l.magic),
		"lone hole start");

	rt_bomb("bombing\n");
gotit:
	/* complete existing trapezoid */
	tp->bot = pt;
	/* create new left and right trapezoids */

	new_trap = (struct trap *)bu_calloc(sizeof(struct trap), 1, "New hole start trapezoids");
	new_trap->top = pt;
	new_trap->bot = (struct pt2d *)NULL;
	new_trap->e_left = tp->e_left;
	new_trap->e_right = BU_LIST_PPREV_CIRC(edgeuse, pt->vu_p->up.eu_p);
	BU_LIST_MAGIC_SET(&new_trap->l, NMG_TRAP_MAGIC);
	BU_LIST_APPEND(&tp->l, &new_trap->l);

	new_trap = (struct trap *)bu_calloc(sizeof(struct trap), 1, "New hole start trapezoids");
	new_trap->top = pt;
	new_trap->bot = (struct pt2d *)NULL;
	new_trap->e_left = pt->vu_p->up.eu_p;
	new_trap->e_right = tp->e_right;
	BU_LIST_MAGIC_SET(&new_trap->l, NMG_TRAP_MAGIC);
	BU_LIST_APPEND(&tp->l, &new_trap->l);
}


/*	Close hole
 *
 *	^
 *	-\   /-
 *	--\ /--
 *	---O---
 *	-------
 *
 *	complete right and left trapezoids
 *	start new trapezoid
 *
 */
static void
hole_end_vertex(struct pt2d *pt, struct bu_list *tbl2d, struct bu_list *tlist)
{
	struct edgeuse *eunext, *euprev;
	struct trap *tp, *tpnext, *tpprev;

	NMG_CK_TBL2D(tbl2d);
	NMG_CK_PT2D(pt);
	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log( "%g %g is hole end vertex\n",
			pt->coord[X], pt->coord[Y]);

	/* find the trapezoids that will end at this vertex */
	eunext = pt->vu_p->up.eu_p;
	euprev = BU_LIST_PPREV_CIRC(edgeuse, eunext);
	tpnext = tpprev = (struct trap *)NULL;

	if (rt_g.NMG_debug & DEBUG_TRI) {
		print_2d_eu("eunext", eunext, tbl2d);
		print_2d_eu("euprev", euprev, tbl2d);
	}

	for (BU_LIST_FOR(tp, trap, tlist)) {
		NMG_CK_TRAP(tp);
		/* obviously, if the trapezoid has been completed, it's not
		 * the one we want.
		 */
		NMG_CK_TRAP(tp);

		if (tp->bot) {
#if 0
			if (rt_g.NMG_debug & DEBUG_TRI) {
				print_trap(tp, tbl2d);
				bu_log("Completed... Skipping\n");
			}
#endif
			continue;
		} else {
			if (rt_g.NMG_debug & DEBUG_TRI)
				print_trap(tp, tbl2d);
		}

		if (tp->e_left == eunext || tp->e_right == eunext) {
			if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log("Found tpnext\n");
			tpnext = tp;
		}

		if (tp->e_right == euprev || tp->e_left == euprev) {
			if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log("Found tpprev\n");
			tpprev = tp;
		}
		if (tpnext && tpprev)
			goto gotem;
	}
	
	rt_bomb("couldn't find both trapezoids of hole closing vertex\n");
gotem:
	NMG_CK_TRAP(tpnext);
	NMG_CK_TRAP(tpprev);

	/* finish off the two trapezoids */
	tpnext->bot = pt;
	tpprev->bot = pt;

	/* start one new trapezoid */

	tp = (struct trap *)bu_calloc(1, sizeof(struct pt2d), "pt2d struct");
	tp->top = pt;
	tp->bot = (struct pt2d *)NULL;
	if (tpnext->e_left == eunext) {
		tp->e_right = tpnext->e_right;
		tp->e_left = tpprev->e_left;
	} else if (tpnext->e_right == eunext) {
		tp->e_left = tpnext->e_left;
		tp->e_right = tpprev->e_right;
	} else
		rt_bomb("Which is my left and which is my right?\n");

	BU_LIST_MAGIC_SET(&tp->l, NMG_TRAP_MAGIC);
	BU_LIST_APPEND(&tpprev->l, &tp->l);
}


/*
 *	N M G _ T R A P _ F A C E 
 *
 *	Produce the trapezoidal decomposition of a face from the set of
 *	2D points.
 */
static void
nmg_trap_face(struct bu_list *tbl2d, struct bu_list *tlist, const struct bn_tol *tol)
{
	struct pt2d *pt;

	NMG_CK_TBL2D(tbl2d);

	for (BU_LIST_FOR(pt, pt2d, tbl2d)) {
		NMG_CK_PT2D(pt);
		switch(vtype2d(pt, tbl2d, tol)) {
		case POLY_SIDE:
			poly_side_vertex(pt, (struct pt2d *)tbl2d, tlist);
			break;
		case HOLE_START:
			hole_start_vertex(pt, tbl2d, tlist);
			break;
		case POLY_START:
			poly_start_vertex(pt, tbl2d, tlist);
			break;
		case HOLE_END:
			hole_end_vertex(pt, tbl2d, tlist);
			break;
		case POLY_END:
			poly_end_vertex(pt, tbl2d, tlist);
			break;
		default:
			bu_log( "%g %g is UNKNOWN type vertex %s %d\n",
				pt->coord[X], pt->coord[Y],
				__FILE__, __LINE__);
			break;
		}
	}

}


static void
map_new_vertexuse(struct bu_list *tbl2d, struct vertexuse *vu_p)
{
	struct vertexuse *vu;
	struct pt2d *p, *new_pt2d;

	NMG_CK_TBL2D(tbl2d);
	NMG_CK_VERTEXUSE(vu_p);

	/* if it's already mapped we're outta here! */
	if ( (p = find_pt2d(tbl2d, vu_p)) ) {
		if (rt_g.NMG_debug & DEBUG_TRI)
		    bu_log("%s %d map_new_vertexuse() vertexuse already mapped!\n",
			__FILE__, __LINE__);
		return;
	}
	/* allocate memory for new 2D point */
	new_pt2d = (struct pt2d *)
		bu_calloc(1, sizeof(struct pt2d), "pt2d struct");

	/* find another use of the same vertex that is already mapped */
	for ( BU_LIST_FOR(vu, vertexuse, &vu_p->v_p->vu_hd) ) {
		NMG_CK_VERTEXUSE(vu);
		if (! (p=find_pt2d(tbl2d, vu)) )
			continue;

		/* map parameter vertexuse */
		new_pt2d->vu_p = vu_p;
		VMOVE(new_pt2d->coord, p->coord);
		BU_LIST_MAGIC_SET(&new_pt2d->l, NMG_PT2D_MAGIC);
		BU_LIST_APPEND(&p->l, &new_pt2d->l);
		return;
	}

	rt_bomb("Couldn't find mapped vertexuse of vertex!\n");
}

/* Support routine for 
 * nmg_find_first_last_use_of_v_in_fu
 *
 * The object of the game here is to find uses of the given vertex whose
 * departing edges have the min/max dot product with the direction vector.
 *
 */
static void
pick_edges(struct vertex *v, struct vertexuse **vu_first, int *min_dir, struct vertexuse **vu_last, int *max_dir, struct faceuse *fu, const struct bn_tol *tol, fastf_t *dir)
                 
                                       
                   
                       	/* 1: forward -1 reverse */
                   	     
           
{
	struct vertexuse *vu;
	struct edgeuse *eu_next, *eu_last;
	struct vertexuse *vu_next, *vu_prev;
	double dot_max = -2.0;
	double dot_min = 2.0;
	double vu_dot;
	double eu_length_sq;
	vect_t eu_dir;
	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("\t    pick_edges(v:(%g %g %g) dir:(%g %g %g))\n",
			V3ARGS(v->vg_p->coord), V3ARGS(dir));

	/* Look at all the uses of this vertex, and find the uses
	 * associated with an edgeuse in this faceuse.  
	 *
	 * Compute the dot product of the direction vector with the vector
	 * of the edgeuse, and the PRIOR edgeuse in the loopuse.
	 *
	 * We're looking for the vertexuses with the min/max edgeuse
	 * vector dot product.
	 */
	*vu_last = *vu_first = (struct vertexuse *)NULL;
	for (BU_LIST_FOR(vu, vertexuse, &v->vu_hd)) {
		NMG_CK_VERTEXUSE(vu);
		NMG_CK_VERTEX(vu->v_p);
		NMG_CK_VERTEX_G(vu->v_p->vg_p);

		if (vu->v_p != v)
			rt_bomb("vertexuse does not acknoledge parents\n");

		if (nmg_find_fu_of_vu(vu) != fu ||
		    *vu->up.magic_p == NMG_LOOPUSE_MAGIC) {
			if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log("\t\tskipping irrelevant vertexuse\n");
			continue;
		}

		NMG_CK_EDGEUSE(vu->up.eu_p);

		/* compute/compare vu/eu vector w/ ray vector */
		eu_next = BU_LIST_PNEXT_CIRC(edgeuse, vu->up.eu_p);
		NMG_CK_EDGEUSE(eu_next);
		vu_next = eu_next->vu_p;
		NMG_CK_VERTEXUSE(vu_next);
		NMG_CK_VERTEX(vu_next->v_p);
		NMG_CK_VERTEX_G(vu_next->v_p->vg_p);
		VSUB2(eu_dir, vu_next->v_p->vg_p->coord, vu->v_p->vg_p->coord);
		eu_length_sq = MAGSQ(eu_dir);
		VUNITIZE(eu_dir);

		if (rt_g.NMG_debug & DEBUG_TRI)
			bu_log("\t\tchecking forward edgeuse to %g %g %g\n",
				V3ARGS(vu_next->v_p->vg_p->coord) );

		if (eu_length_sq >= SMALL_FASTF) { 
			if ((vu_dot = VDOT(eu_dir, dir)) > dot_max) {
				if (rt_g.NMG_debug & DEBUG_TRI) {
					bu_log("\t\t\teu_dir %g %g %g\n",
						V3ARGS(eu_dir));

					bu_log("\t\t\tnew_last/max 0x%08x %g %g %g -> %g %g %g vdot %g\n",
						vu,
						V3ARGS(vu->v_p->vg_p->coord),
						V3ARGS(vu_next->v_p->vg_p->coord),
						vu_dot);
				}
				dot_max = vu_dot;
				*vu_last = vu;
				*max_dir = 1;
			}
			if (vu_dot < dot_min) {
				if (rt_g.NMG_debug & DEBUG_TRI) {
					bu_log("\t\t\teu_dir %g %g %g\n", V3ARGS(eu_dir));
					bu_log("\t\t\tnew_first/min 0x%08x %g %g %g -> %g %g %g vdot %g\n",
						vu, 
						V3ARGS(vu->v_p->vg_p->coord),
						V3ARGS(vu_next->v_p->vg_p->coord),
						vu_dot);
				}

				dot_min = vu_dot;
				*vu_first = vu;
				*min_dir = 1;
			}
		}





		/* compute/compare vu/prev_eu vector w/ ray vector */
		eu_last = BU_LIST_PPREV_CIRC(edgeuse, vu->up.eu_p);
		NMG_CK_EDGEUSE(eu_last);
		vu_prev = eu_last->vu_p;
		NMG_CK_VERTEXUSE(vu_prev);
		NMG_CK_VERTEX(vu_prev->v_p);
		NMG_CK_VERTEX_G(vu_prev->v_p->vg_p);
		/* form vector in reverse direction so that all vectors
		 * "point out" from the vertex in question.
		 */
		VSUB2(eu_dir, vu_prev->v_p->vg_p->coord, vu->v_p->vg_p->coord);
		eu_length_sq = MAGSQ(eu_dir);
		VUNITIZE(eu_dir);

		if (rt_g.NMG_debug & DEBUG_TRI)
			bu_log("\t\tchecking reverse edgeuse to %g %g %g\n",
				V3ARGS(vu_prev->v_p->vg_p->coord) );

		if (eu_length_sq >= SMALL_FASTF) {
			if ((vu_dot = VDOT(eu_dir, dir)) > dot_max) {
				if (rt_g.NMG_debug & DEBUG_TRI) {
					bu_log("\t\t\t-eu_dir %g %g %g\n", 
						V3ARGS(eu_dir));
					bu_log("\t\t\tnew_last/max 0x%08x %g %g %g <- %g %g %g vdot %g\n",
						vu, 
						V3ARGS(vu->v_p->vg_p->coord),
						V3ARGS(vu_prev->v_p->vg_p->coord),
						vu_dot);
				}
				dot_max = vu_dot;
				*vu_last = vu;
				*max_dir = -1;
			}
			if (vu_dot < dot_min) {
				if (rt_g.NMG_debug & DEBUG_TRI) {
					bu_log("\t\t\teu_dir %g %g %g\n", V3ARGS(eu_dir));
					bu_log("\t\t\tnew_first/min 0x%08x %g %g %g <- %g %g %g vdot %g\n",
						vu,
						V3ARGS(vu->v_p->vg_p->coord),
						V3ARGS(vu_prev->v_p->vg_p->coord),
						vu_dot);
				}
				dot_min = vu_dot;
				*vu_first = vu;
				*min_dir = -1;
			}
		}
	}

}

/* Support routine for 
 * nmg_find_first_last_use_of_v_in_fu
 * 
 * Given and edgeuse and a faceuse, pick the use of the edge in the faceuse
 * 	whose left vector has the largest/smallest dot product with the given 
 *	direction vector.  The parameter "find_max" determines whether we
 *	return the edgeuse with the largest (find_max != 0) or the smallest
 *	(find_max == 0) left-dot-product.
 */
struct edgeuse *
pick_eu(struct edgeuse *eu_p, struct faceuse *fu, fastf_t *dir, int find_max)
{
	struct edgeuse *eu, *keep_eu=NULL, *eu_next;
	int go_radial_not_mate = 0;
	double dot_limit;
	double euleft_dot;
	vect_t left, eu_vect;

	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("\t    pick_eu(%g %g %g  <-> %g %g %g, dir:%g %g %g,  %s)\n",
			V3ARGS(eu_p->vu_p->v_p->vg_p->coord ),
			V3ARGS(eu_p->eumate_p->vu_p->v_p->vg_p->coord ),
			V3ARGS(dir), (find_max==0?"find min":"find max") );

	if (find_max) dot_limit = -2.0;
	else dot_limit = 2.0;

	/* walk around the edge looking for uses in this face */
	eu = eu_p;
	do {
		if (nmg_find_fu_of_eu(eu) == fu) {
			/* compute the vector for this edgeuse */
			eu_next = BU_LIST_PNEXT_CIRC(edgeuse, eu);
			VSUB2(eu_vect, eu_next->vu_p->v_p->vg_p->coord,
				eu->vu_p->v_p->vg_p->coord);
			VUNITIZE(eu_vect);

			/* compute the "left" vector for this edgeuse */
			if (nmg_find_eu_leftvec(left, eu)) {
				bu_log("%s %d: edgeuse no longer in faceuse?\n", __FILE__, __LINE__);
				rt_bomb("bombing");
			}

			euleft_dot = VDOT(left, dir);

			if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log("\t\tchecking: %g %g %g -> %g %g %g left vdot:%g\n",
					V3ARGS(eu->vu_p->v_p->vg_p->coord),
					V3ARGS(eu_next->vu_p->v_p->vg_p->coord),
					euleft_dot);


			/* if this is and edgeuse we need to remember, keep
			 * track of it while we go onward
			 */
			if (find_max) {
				if (euleft_dot > dot_limit) {
					dot_limit = euleft_dot;
					keep_eu = eu;
					if (rt_g.NMG_debug & DEBUG_TRI)
						bu_log("\t\tnew max\n");
				}
			} else {
				if (euleft_dot < dot_limit) {
					dot_limit = euleft_dot;
					keep_eu = eu;
					if (rt_g.NMG_debug & DEBUG_TRI)
						bu_log("\t\tnew min\n");
				}
			}
		}

		if (go_radial_not_mate) eu = eu->eumate_p;
		else eu = eu->radial_p;
		go_radial_not_mate = ! go_radial_not_mate;

	} while ( eu != eu_p );

	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("\t\tpick_eu() returns %g %g %g -> %g %g %g\n\t\t\tbecause vdot(left) = %g\n",
			V3ARGS(keep_eu->vu_p->v_p->vg_p->coord),
			V3ARGS(keep_eu->eumate_p->vu_p->v_p->vg_p->coord),
			dot_limit);

	return keep_eu;
}




/*
 *	Given a pointer to a vertexuse in a face and a ray, find the
 *	"first" and "last" uses of the vertex along the ray in the face.
 *	Consider the diagram below where 4 OT_SAME loopuses meet at a single
 *	vertex.  The ray enters from the upper left and proceeds to the lower
 *	right.  The ray encounters vertexuse (represented by "o" below)
 *	number 1 first and vertexuse 3 last.
 *
 *
 *			 edge A
 *			 |
 *		     \  ^||
 *		      \ |||
 *		       1||V2
 *		------->o|o------->
 *  edge D --------------.-------------edge B
 *		<-------o|o<------
 *		       4^||3
 *		        ||| \
 *		        |||  \
 *		        ||V   \|
 *			 |    -
 *		    edge C
 *
 *	The primary purpose of this routine is to find the vertexuses
 *	that should be the parameters to nmg_cut_loop() and nmg_join_loop().
 */
void
nmg_find_first_last_use_of_v_in_fu(struct vertex *v, struct vertexuse **first_vu, struct vertexuse **last_vu, fastf_t *dir, struct faceuse *fu, const struct bn_tol *tol)
{
	struct vertexuse *vu_first, *vu_last;
	int max_dir, min_dir;	/* 1: forward -1 reverse */
	struct edgeuse *eu_first, *eu_last, *eu_p=NULL;

	NMG_CK_VERTEX(v);
	NMG_CK_FACEUSE(fu);
	if (first_vu == (struct vertexuse **)(NULL)) {
		bu_log("%s: %d first_vu is null ptr\n", __FILE__, __LINE__);
		rt_bomb("terminating\n");
	}
	if (last_vu == (struct vertexuse **)(NULL)) {
		bu_log("%s: %d last_vu is null ptr\n", __FILE__, __LINE__);
		rt_bomb("terminating\n");
	}

	VUNITIZE(dir);

	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("\t  nmg_find_first(v:(%g %g %g) dir:(%g %g %g))\n",
			V3ARGS(v->vg_p->coord), V3ARGS(dir));

	/* go find the edges which are "closest" to the direction vector */
	pick_edges(v, &vu_first, &min_dir, &vu_last, &max_dir, fu, tol, dir);


	/* Now we know which 2 edges are most important to look at.
	 * The question now is which vertexuse on this edge to pick.
	 * For example, in the diagram above we will choose a use of edge C
	 * for our "max".  Either vu3 OR vu4 could be chosen.
	 *
	 * For our max/last point, we choose the use for which:
	 * 		vdot(ray, eu_left_vector)
	 * is largest.
	 *
	 * For our min/first point, we choose the use for which:
	 * 		vdot(ray, eu_left_vector)
	 * is smallest.
	 */

	/* get an edgeuse of the proper edge */
	NMG_CK_VERTEXUSE(vu_first);
	switch (min_dir) {
	case -1:
		eu_p = BU_LIST_PPREV_CIRC(edgeuse, vu_first->up.eu_p);
		break;
	case 1:
		eu_p = vu_first->up.eu_p;
		break;
	default:
		rt_bomb("bad max_dir\n");
		break;
	}

	NMG_CK_EDGEUSE(eu_p);
	NMG_CK_VERTEXUSE(eu_p->vu_p);

	eu_first = pick_eu(eu_p, fu, dir, 0);
	NMG_CK_EDGEUSE(eu_first);
	NMG_CK_VERTEXUSE(eu_first->vu_p);
	NMG_CK_VERTEX(eu_first->vu_p->v_p);
	NMG_CK_VERTEX_G(eu_first->vu_p->v_p->vg_p);

	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("\t   first_eu: %g %g %g -> %g %g %g\n",
			V3ARGS(eu_first->vu_p->v_p->vg_p->coord),
			V3ARGS(eu_first->eumate_p->vu_p->v_p->vg_p->coord));


	if (eu_first->vu_p->v_p == v)
		/* if we wound up with and edgeuse whose vertexuse is
		 * actually on the vertex "v" we're in business, we
		 * simply record the vertexuse with this edgeuse.
		 */
		*first_vu = eu_first->vu_p;
	else {
		/* It looks like we wound up choosing an edgeuse which is
		 * "before" the vertex "v" (an edgeuse that points at "v")
		 * so we need to pick the vertexuse of the NEXT edgeuse
		 */
		NMG_CK_EDGEUSE(eu_first->eumate_p);
		NMG_CK_VERTEXUSE(eu_first->eumate_p->vu_p);
		NMG_CK_VERTEX(eu_first->eumate_p->vu_p->v_p);

		if (eu_first->eumate_p->vu_p->v_p == v) {
			eu_p = BU_LIST_PNEXT_CIRC(edgeuse, eu_first);
			NMG_CK_EDGEUSE(eu_p);
			NMG_CK_VERTEXUSE(eu_p->vu_p);
			*first_vu = eu_p->vu_p;
		} else {
			bu_log("I got eu_first: %g %g %g -> %g %g %g but...\n",
				V3ARGS(eu_first->vu_p->v_p->vg_p->coord),
				V3ARGS(eu_first->eumate_p->vu_p->v_p->vg_p->coord));
			rt_bomb("I can't find the right vertex\n");
		}
	}


	NMG_CK_VERTEXUSE(vu_last);
	switch (max_dir) {
	case -1:
		eu_p = BU_LIST_PPREV_CIRC(edgeuse, vu_last->up.eu_p);
		break;
	case 1:
		eu_p = vu_last->up.eu_p;
		break;
	default:
		rt_bomb("bad min_dir\n");
		break;
	}

	NMG_CK_EDGEUSE(eu_p);
	NMG_CK_VERTEXUSE(eu_p->vu_p);

	eu_last = pick_eu(eu_p, fu, dir, 1);

	NMG_CK_EDGEUSE(eu_last);
	NMG_CK_VERTEXUSE(eu_last->vu_p);
	NMG_CK_VERTEX(eu_last->vu_p->v_p);
	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("\t   last_eu: %g %g %g -> %g %g %g\n",
			V3ARGS(eu_last->vu_p->v_p->vg_p->coord),
			V3ARGS(eu_last->eumate_p->vu_p->v_p->vg_p->coord));



	if (eu_last->vu_p->v_p == v)
		/* if we wound up with and edgeuse whose vertexuse is
		 * actually on the vertex "v" we're in business, we
		 * simply record the vertexuse with this edgeuse.
		 */
		*last_vu = eu_last->vu_p;
	else {
		/* It looks like we wound up choosing an edgeuse which is
		 * "before" the vertex "v" (an edgeuse that points at "v")
		 * so we need to pick the vertexuse of the NEXT edgeuse
		 */
		NMG_CK_EDGEUSE(eu_last->eumate_p);
		NMG_CK_VERTEXUSE(eu_last->eumate_p->vu_p);
		NMG_CK_VERTEX(eu_last->eumate_p->vu_p->v_p);

		if (eu_last->eumate_p->vu_p->v_p == v) {
			eu_p = BU_LIST_PNEXT_CIRC(edgeuse, eu_last);
			NMG_CK_EDGEUSE(eu_p);
			NMG_CK_VERTEXUSE(eu_p->vu_p);
			*last_vu = eu_p->vu_p;
		} else {
			bu_log("I got eu_last: %g %g %g -> %g %g %g but...\n",
				V3ARGS(eu_last->vu_p->v_p->vg_p->coord),
				V3ARGS(eu_last->eumate_p->vu_p->v_p->vg_p->coord));
			rt_bomb("I can't find the right vertex\n");
		}
	}


	NMG_CK_VERTEXUSE(*first_vu);
	NMG_CK_VERTEXUSE(*last_vu);
}

static void
pick_pt2d_for_cutjoin(struct bu_list *tbl2d, struct pt2d **p1, struct pt2d **p2, const struct bn_tol *tol)
{
	struct vertexuse *cut_vu1, *cut_vu2, *junk_vu;
	struct faceuse *fu;
	vect_t dir;

	NMG_CK_TBL2D(tbl2d);

	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("\tpick_pt2d_for_cutjoin()\n");

	BN_CK_TOL(tol);
	NMG_CK_PT2D(*p1);
	NMG_CK_PT2D(*p2);
	NMG_CK_VERTEXUSE((*p1)->vu_p);
	NMG_CK_VERTEXUSE((*p2)->vu_p);
	
	cut_vu1 = (*p1)->vu_p;
	cut_vu2 = (*p2)->vu_p;

	NMG_CK_VERTEX(cut_vu1->v_p);
	NMG_CK_VERTEX_G(cut_vu1->v_p->vg_p);
	NMG_CK_VERTEX(cut_vu2->v_p);
	NMG_CK_VERTEX_G(cut_vu2->v_p->vg_p);

	/* form direction vector for the cut we want to make */
	VSUB2(dir, cut_vu2->v_p->vg_p->coord,
		   cut_vu1->v_p->vg_p->coord);

	if (rt_g.NMG_debug & DEBUG_TRI)
		VPRINT("\t\tdir", dir);

	if ( ! (fu = nmg_find_fu_of_vu(cut_vu1)) ) {
		bu_log("%s: %d no faceuse parent of vu\n", __FILE__, __LINE__);
		rt_bomb("Bye now\n");
	}

	nmg_find_first_last_use_of_v_in_fu((*p1)->vu_p->v_p,
		&junk_vu, &cut_vu1, dir, fu, tol);

	NMG_CK_VERTEXUSE(junk_vu);
	NMG_CK_VERTEXUSE(cut_vu1);
	*p1 = find_pt2d(tbl2d, cut_vu1);

	if (rt_g.NMG_debug & DEBUG_TRI) {
		struct pt2d *pj, *pj_n, *p1_n;

		pj = find_pt2d(tbl2d, junk_vu);
		pj_n = PT2D_NEXT(tbl2d, pj);

		p1_n = PT2D_NEXT(tbl2d, (*p1));

		bu_log("\tp1 pick %g %g -> %g %g (first)\n\t\t%g %g -> %g %g (last)\n",
			pj->coord[0], pj->coord[1],
			pj_n->coord[0], pj_n->coord[1],
			(*p1)->coord[0], (*p1)->coord[1],
			p1_n->coord[0], p1_n->coord[1]);
	}


	nmg_find_first_last_use_of_v_in_fu((*p2)->vu_p->v_p,
		&cut_vu2, &junk_vu, dir, fu, tol);


	*p2 = find_pt2d(tbl2d, cut_vu2);
	if (rt_g.NMG_debug & DEBUG_TRI) {
		struct pt2d *pj, *pj_n, *p2_n;

		pj = find_pt2d(tbl2d, junk_vu);
		pj_n = PT2D_NEXT(tbl2d, pj);

		p2_n = PT2D_NEXT(tbl2d, (*p2));
		bu_log("\tp2 pick %g %g -> %g %g (first)\n\t\t%g %g -> %g %g (last)\n",
			(*p2)->coord[0], (*p2)->coord[1],
			p2_n->coord[0], p2_n->coord[1],
			pj->coord[0], pj->coord[1],
			pj_n->coord[0], pj_n->coord[1]);
	}

}



/*
 *
 *  Cut a loop which has a 2D mapping.  Since this entails the creation
 *  of new vertexuses, it is necessary to add a 2D mapping for the new
 *  vertexuses.
 *
 *
 *
 */
static void join_mapped_loops(struct bu_list *tbl2d, struct pt2d *p1, struct pt2d *p2, const int *color, const struct bn_tol *tol);
static struct pt2d *
cut_mapped_loop(struct bu_list *tbl2d, struct pt2d *p1, struct pt2d *p2, const int *color, const struct bn_tol *tol, int void_ok)
{
	struct loopuse *new_lu;
	struct loopuse *old_lu;
	struct edgeuse *eu;

	NMG_CK_TBL2D(tbl2d);
	BN_CK_TOL(tol);
	NMG_CK_PT2D(p1);
	NMG_CK_PT2D(p2);
	NMG_CK_VERTEXUSE(p1->vu_p);
	NMG_CK_VERTEXUSE(p2->vu_p);

	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("\tcutting loop @@ %g %g -> %g %g\n",
			p1->coord[X], p1->coord[Y],
			p2->coord[X], p2->coord[Y]);

	if (p1->vu_p->up.eu_p->up.lu_p != p2->vu_p->up.eu_p->up.lu_p) {
		bu_log("parent loops are not the same %s %d\n", __FILE__, __LINE__);
		rt_bomb("cut_mapped_loop() goodnight 1\n");
	}
	
	pick_pt2d_for_cutjoin(tbl2d, &p1, &p2, tol);

	if (p1->vu_p->up.eu_p->up.lu_p != p2->vu_p->up.eu_p->up.lu_p) {
		if (void_ok) {
			if(rt_g.NMG_debug)
				bu_log("cut_mapped_loop() parent loops are not the same %s %d, trying join\n", __FILE__, __LINE__);
			join_mapped_loops(tbl2d, p1, p2, color, tol);
			return (struct pt2d *)NULL;
		} else {
			char buf[80];
			char name[32];
			static int iter=0;
			vect_t cut_vect, cut_start, cut_end;
			FILE *fd;

			bu_log("parent loops are not the same %s %d\n",
				__FILE__, __LINE__);


			sprintf(buf, "cut %g %g %g -> %g %g %g\n",
				V3ARGS(p1->vu_p->v_p->vg_p->coord),
				V3ARGS(p2->vu_p->v_p->vg_p->coord) );

			sprintf(name, "bad_tri_cut%d.g", iter++);
			if ((fd=fopen("bad_tri_cut.pl", "w")) == (FILE *)NULL)
				rt_bomb("cut_mapped_loop() goodnight 2\n");
			
			VSUB2(cut_vect, p2->vu_p->v_p->vg_p->coord, p1->vu_p->v_p->vg_p->coord);
			/* vector goes past end point by 50% */
			VJOIN1(cut_end, p2->vu_p->v_p->vg_p->coord, 0.5, cut_vect);
			/* vector starts before start point by 25% */
			VJOIN1(cut_start, p1->vu_p->v_p->vg_p->coord, -0.25, cut_vect);

			pl_color(fd, 100, 100, 100);
			pdv_3line(fd, cut_start, p1->vu_p->v_p->vg_p->coord);
			pl_color(fd, 255, 255, 255);
			pdv_3line(fd, p1->vu_p->v_p->vg_p->coord, p2->vu_p->v_p->vg_p->coord);
			pl_color(fd, 100, 100, 100);
			pdv_3line(fd, p2->vu_p->v_p->vg_p->coord, cut_end);

			(void)fclose(fd);
			nmg_stash_model_to_file( "bad_tri_cut.g",
						 nmg_find_model(&p1->vu_p->l.magic), buf );

			rt_bomb("cut_mapped_loop() goodnight 2\n");
		}
	}

	if (plot_fd) {
		pl_color(plot_fd, V3ARGS(color) );
		pdv_3line(plot_fd, p1->coord, p2->coord);
	}

	old_lu = p1->vu_p->up.eu_p->up.lu_p;
	NMG_CK_LOOPUSE(old_lu);
	new_lu = nmg_cut_loop(p1->vu_p, p2->vu_p);
	NMG_CK_LOOPUSE(new_lu);
	NMG_CK_LOOP(new_lu->l_p);
	nmg_loop_g(new_lu->l_p, tol);

	/* XXX Does anyone care about loopuse orientations at this stage?
	nmg_lu_reorient( old_lu );
	nmg_lu_reorient( new_lu );
	 */

	/* get the edgeuse of the new vertexuse we just created */
	eu = BU_LIST_PPREV_CIRC(edgeuse, &new_lu->down_hd);
	NMG_CK_EDGEUSE(eu);

	/* if the original vertexuses had normals,
	 * copy them to the new vertexuses.
	 */
	if( p1->vu_p->a.magic_p && *p1->vu_p->a.magic_p == NMG_VERTEXUSE_A_PLANE_MAGIC )
	{
		struct vertexuse *vu;
		struct faceuse *fu;
		struct loopuse *lu;
		vect_t ot_same_normal;
		vect_t ot_opposite_normal;

		/* get vertexuse normal */
		VMOVE( ot_same_normal , p1->vu_p->a.plane_p->N );
		fu = nmg_find_fu_of_vu( p1->vu_p );
		NMG_CK_FACEUSE( fu );
		if( fu->orientation == OT_OPPOSITE )
			VREVERSE( ot_same_normal , ot_same_normal )

		VREVERSE( ot_opposite_normal , ot_same_normal );

		/* look for new vertexuses in new_lu and old_lu */
		for( BU_LIST_FOR( vu , vertexuse , &p1->vu_p->v_p->vu_hd ) )
		{
			if( vu->a.magic_p )
				continue;

			lu = nmg_find_lu_of_vu( vu );
			if( lu != old_lu && lu != old_lu->lumate_p &&
			    lu != new_lu && lu != new_lu->lumate_p )
				continue;

			/* assign appropriate normal */
			fu = nmg_find_fu_of_vu( vu );
			if( fu->orientation == OT_SAME )
				nmg_vertexuse_nv( vu , ot_same_normal );
			else if( fu->orientation == OT_OPPOSITE )
				nmg_vertexuse_nv( vu , ot_opposite_normal );
		}
	}
	if( p2->vu_p->a.magic_p && *p2->vu_p->a.magic_p == NMG_VERTEXUSE_A_PLANE_MAGIC )
	{
		struct vertexuse *vu;
		struct faceuse *fu;
		struct loopuse *lu;
		vect_t ot_same_normal;
		vect_t ot_opposite_normal;

		/* get vertexuse normal */
		VMOVE( ot_same_normal , p2->vu_p->a.plane_p->N );
		fu = nmg_find_fu_of_vu( p2->vu_p );
		NMG_CK_FACEUSE( fu );
		if( fu->orientation == OT_OPPOSITE )
			VREVERSE( ot_same_normal , ot_same_normal )

		VREVERSE( ot_opposite_normal , ot_same_normal );

		/* look for new vertexuses in new_lu and old_lu */
		for( BU_LIST_FOR( vu , vertexuse , &p2->vu_p->v_p->vu_hd ) )
		{
			if( vu->a.magic_p )
				continue;

			lu = nmg_find_lu_of_vu( vu );
			if( lu != old_lu && lu != old_lu->lumate_p &&
			    lu != new_lu && lu != new_lu->lumate_p )
				continue;

			/* assign appropriate normal */
			fu = nmg_find_fu_of_vu( vu );
			if( fu->orientation == OT_SAME )
				nmg_vertexuse_nv( vu , ot_same_normal );
			else if( fu->orientation == OT_OPPOSITE )
				nmg_vertexuse_nv( vu , ot_opposite_normal );
		}
	}

	/* map it to the 2D plane */
	map_new_vertexuse(tbl2d, eu->vu_p);

	/* now map the vertexuse on the radially-adjacent edgeuse */
	NMG_CK_EDGEUSE(eu->radial_p);
	map_new_vertexuse(tbl2d, eu->radial_p->vu_p);

	eu = BU_LIST_PPREV_CIRC( edgeuse, &(p1->vu_p->up.eu_p->l));
	return find_pt2d(tbl2d, eu->vu_p);
}

/*
 *
 *	Join 2 loops (one forms a hole in the other usually )
 *
 */
static void
join_mapped_loops(struct bu_list *tbl2d, struct pt2d *p1, struct pt2d *p2, const int *color, const struct bn_tol *tol)
{
	struct vertexuse *vu1, *vu2;
	struct vertexuse *vu;
	struct edgeuse *eu;
	struct loopuse *lu;

	NMG_CK_TBL2D(tbl2d);
	NMG_CK_PT2D(p1);
	NMG_CK_PT2D(p2);
	BN_CK_TOL(tol);

	vu1 = p1->vu_p;
	vu2 = p2->vu_p;

	NMG_CK_VERTEXUSE(vu1);
	NMG_CK_VERTEXUSE(vu2);

	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("join_mapped_loops()\n");


	if (p1 == p2) {
		bu_log("%s %d: Attempting to join loop to itself at (%g %g %g)?\n",
			__FILE__, __LINE__,
			V3ARGS(p1->vu_p->v_p->vg_p->coord) );
		rt_bomb("bombing\n");
	} else if (p1->vu_p->up.eu_p->up.lu_p == p2->vu_p->up.eu_p->up.lu_p) {
		bu_log("parent loops are the same %s %d\n", __FILE__, __LINE__);
		rt_bomb("goodnight\n");
	}
	/* check to see if we're joining two loops that share a vertex */
	if (p1->vu_p->v_p == p2->vu_p->v_p) {
#if 1
		if (rt_g.NMG_debug & DEBUG_TRI)
			bu_log("Joining two loops that share a vertex at (%g %g %g)\n",
				V3ARGS(p1->vu_p->v_p->vg_p->coord) );
		(void)nmg_join_2loops(p1->vu_p,  p2->vu_p);
#else
		if (rt_g.NMG_debug & DEBUG_TRI)
			bu_log("NOT Joining two loops that share a vertex at (%g %g %g)\n",
				V3ARGS(p1->vu_p->v_p->vg_p->coord) );
#endif
		return;
	}

	pick_pt2d_for_cutjoin(tbl2d, &p1, &p2, tol);

	vu1 = p1->vu_p;
	vu2 = p2->vu_p;
	NMG_CK_VERTEXUSE(vu1);
	NMG_CK_VERTEXUSE(vu2);

	if (p1 == p2) {
		bu_log("%s: %d I'm a fool...\n\ttrying to join a vertexuse (%g %g %g) to itself\n",
			__FILE__, __LINE__,
			V3ARGS(p1->vu_p->v_p->vg_p->coord) );
	} else if (p1->vu_p->up.eu_p->up.lu_p == p2->vu_p->up.eu_p->up.lu_p) {
		if (rt_g.NMG_debug & DEBUG_TRI) {
			bu_log("parent loops are the same %s %d\n",
				__FILE__, __LINE__);
		}
		(void)cut_mapped_loop(tbl2d, p1, p2, color, tol, 1);
		return;
	}


	/* XXX nmg_join_2loops() requires that the two loops not be BOTH
	 *	OT_OPPOSITE.  We should check for this here.
	 *
	 * XXX what if vu2 is a vertex loop?
	 */

	NMG_CK_EDGEUSE(vu2->up.eu_p);

	/* need to save this so we can use it later to get
	 * the new "next" edge/vertexuse
	 */
	eu = BU_LIST_PPREV_CIRC(edgeuse, vu2->up.eu_p);


    	if (rt_g.NMG_debug & DEBUG_TRI) {
    		struct edgeuse *pr1_eu;
    		struct edgeuse *pr2_eu;

    		pr1_eu = BU_LIST_PNEXT_CIRC(edgeuse, vu1->up.eu_p);
    		pr2_eu = BU_LIST_PNEXT_CIRC(edgeuse, vu2->up.eu_p);

    		bu_log("joining loops between:\n\t%g %g %g -> (%g %g %g)\n\tand%g %g %g -> (%g %g %g)\n",
			V3ARGS(vu1->v_p->vg_p->coord),
			V3ARGS(pr1_eu->vu_p->v_p->vg_p->coord),
			V3ARGS(vu2->v_p->vg_p->coord),
			V3ARGS(pr2_eu->vu_p->v_p->vg_p->coord) );
    	}

	vu = nmg_join_2loops(vu1, vu2);
	if (plot_fd) {
		pl_color(plot_fd, V3ARGS(color) );
		pdv_3line(plot_fd, p1->coord,  p2->coord);
	}


	NMG_CK_VERTEXUSE(vu);

	if (vu == vu2)
		return;

	/* since we've just made some new vertexuses
	 * we need to map them to the 2D plane.  
	 *
	 * XXX This should be made more direct and efficient.  For now we
	 * just go looking for vertexuses without a mapping.
	 */
	NMG_CK_EDGEUSE(vu->up.eu_p);
	NMG_CK_LOOPUSE(vu->up.eu_p->up.lu_p);
	lu = vu->up.eu_p->up.lu_p;
	for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
		if (! find_pt2d(tbl2d, eu->vu_p))
			map_new_vertexuse(tbl2d, eu->vu_p);
	}
}
/*
 *  Check to see if the edge between the top/bottom of the trapezoid
 * already exists.
 */
static int
skip_cut(struct bu_list *tbl2d, struct pt2d *top, struct pt2d *bot)
{
	struct vertexuse *vu_top;
	struct vertexuse *vu_bot;
	struct vertexuse *vu;
	struct vertex *v;
	struct faceuse *fu;
	struct edgeuse *eu;
	struct edgeuse *eu_next;
	struct pt2d *top_next, *bot_next;

	NMG_CK_TBL2D(tbl2d);
	NMG_CK_PT2D(top);
	NMG_CK_PT2D(bot);


	top_next = PT2D_NEXT(tbl2d, top);
	bot_next = PT2D_NEXT(tbl2d, bot);

	if (top_next == bot || bot_next == top) {
	    	return 1;
	}

	vu_top = top->vu_p;
	vu_bot = bot->vu_p;
	NMG_CK_VERTEXUSE(vu_top);
	NMG_CK_VERTEXUSE(vu_bot);

	v = vu_top->v_p;
	NMG_CK_VERTEX(v);
	NMG_CK_VERTEX(vu_bot->v_p);

	fu = nmg_find_fu_of_vu(vu_top);

	for (BU_LIST_FOR(vu, vertexuse, &v->vu_hd)) {
		/* if parent is edge of this loop/face, and next
		 * vertex around loop is the one for vu_bot, don't
		 * make the cut.
		 */
		if (nmg_find_fu_of_vu(vu) != fu) continue;
		if (!vu->up.magic_p) {
			bu_log("NULL vertexuse up %s %d\n",
				__FILE__, __LINE__);
			rt_bomb("");
		}
		if (*vu->up.magic_p != NMG_EDGEUSE_MAGIC) continue;
		eu = vu->up.eu_p;
		eu_next = BU_LIST_PNEXT_CIRC(edgeuse, eu);

		/* if the edge exists, don't try to re-cut it */
		if (eu_next->vu_p->v_p == vu_bot->v_p)
			return 1; 
	}

	fu = nmg_find_fu_of_vu(vu_bot);
	v = vu_bot->v_p;
	for (BU_LIST_FOR(vu, vertexuse, &v->vu_hd)) {
		/* if parent is edge of this loop/face, and next
		 * vertex around loop is the one for vu_bot, don't
		 * make the cut.
		 */
		if (nmg_find_fu_of_vu(vu) != fu) continue;
		if (!vu->up.magic_p) {
			bu_log("NULL vertexuse up %s %d\n",
				__FILE__, __LINE__);
			rt_bomb("");
		}
		if (*vu->up.magic_p != NMG_EDGEUSE_MAGIC) continue;
		eu = vu->up.eu_p;
		eu_next = BU_LIST_PNEXT_CIRC(edgeuse, eu);

		/* if the edge exists, don't try to re-cut it */
		if (eu_next->vu_p->v_p == vu_top->v_p)
			return 1; 
	}
	return 0;
}

static void
cut_diagonals(struct bu_list *tbl2d, struct bu_list *tlist, const struct faceuse *fu, const struct bn_tol *tol)
{
	struct trap *tp;
	int cut_count=0;

	static const int cut_color[3] = {255, 80, 80};
	static const int join_color[3] = {80, 80, 255};

	extern struct loopuse *nmg_find_lu_of_vu(const struct vertexuse *vu);
	struct loopuse *toplu, *botlu;
	struct loopuse *lu;

	NMG_CK_TBL2D(tbl2d);
	BN_CK_TOL(tol);

	/* Convert trap list to unimonotone polygons */
	for (BU_LIST_FOR(tp, trap, tlist)) {
		/* if top and bottom points are not on same edge of 
		 * trapezoid, we cut across the trapezoid with a new edge.
		 */

		/* If the edge already exists in the face, don't bother
		 * to add it.
		 */
		if( !tp->top || !tp->bot )
		{
			bu_log( "tp->top and/or tp->bot is/are NULL!!!!!!!\n" );
		    	if (rt_g.NMG_debug & DEBUG_TRI)
			{
				nmg_pr_fu_briefly( fu, "" );
				if( tp->top )
					bu_log( "tp->top is (%g %g %g)\n", V3ARGS( tp->top->vu_p->v_p->vg_p->coord ) );
				if( tp->bot )
					bu_log( "tp->bot is (%g %g %g)\n", V3ARGS( tp->bot->vu_p->v_p->vg_p->coord ) );
			}
			rt_bomb( "tp->top and/or tp->bot is/are NULL" );
		}
		if (nmg_find_eu_in_face(tp->top->vu_p->v_p, tp->bot->vu_p->v_p, fu,
		    (struct edgeuse *)NULL, 0) != (struct edgeuse *)NULL) {
		    	if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log("skipping %g %g/%g %g ... edge exists\n",
					tp->top->coord[X],
					tp->top->coord[Y],
					tp->bot->coord[X],
					tp->bot->coord[Y]);
			continue;
		}


		if (skip_cut(tbl2d, tp->top, tp->bot)) {
		    	if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log("skipping %g %g/%g %g ... pts on same edge\n",
					tp->top->coord[X],
					tp->top->coord[Y],
					tp->bot->coord[X],
					tp->bot->coord[Y]);
			continue;
		}

		if (rt_g.NMG_debug & DEBUG_TRI) {
			bu_log("trying to cut ...\n");
			print_trap(tp, tbl2d);
		}

		/* top/bottom points are not on same side of trapezoid. */

		toplu = nmg_find_lu_of_vu(tp->top->vu_p);
		botlu = nmg_find_lu_of_vu(tp->bot->vu_p);
		NMG_CK_VERTEXUSE(tp->top->vu_p);
		NMG_CK_VERTEXUSE(tp->bot->vu_p);
		NMG_CK_LOOPUSE(toplu);
		NMG_CK_LOOPUSE(botlu);

		if (toplu == botlu){

			/* if points are the same, this is a split-loop op */
			if (tp->top->vu_p->v_p == tp->bot->vu_p->v_p) {

				int touching_jaunt=0;
				struct edgeuse *eu1, *eu2, *eu1_prev, *eu2_prev;

				eu1 = tp->top->vu_p->up.eu_p;
				eu2 = tp->bot->vu_p->up.eu_p;

				eu1_prev = BU_LIST_PPREV_CIRC( edgeuse, &eu1->l );
				eu2_prev = BU_LIST_PPREV_CIRC( edgeuse, &eu2->l );
				if( NMG_ARE_EUS_ADJACENT( eu1, eu1_prev ) )
					touching_jaunt = 1;
				else if( NMG_ARE_EUS_ADJACENT( eu2, eu2_prev ) )
					touching_jaunt = 1;

				if( touching_jaunt )
				{
					if (rt_g.NMG_debug & DEBUG_TRI)
						bu_log("splitting self-touching jaunt loop at (%g %g %g)\n",
						V3ARGS(tp->bot->vu_p->v_p->vg_p->coord) );

					nmg_loop_split_at_touching_jaunt(toplu, tol);
				}
				else
				{
					if (rt_g.NMG_debug & DEBUG_TRI)
						bu_log("splitting self-touching loop at (%g %g %g)\n",
						V3ARGS(tp->bot->vu_p->v_p->vg_p->coord) );

					nmg_split_touchingloops(toplu, tol);
				}
				for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
					nmg_lu_reorient(lu);

				if (rt_g.NMG_debug & DEBUG_TRI)
				{
					char fname[32];

					sprintf( fname, "split%d.g", cut_count );
					nmg_stash_model_to_file( fname,
						nmg_find_model( &toplu->l.magic ),
						"after split_touching_loop()" );
					cut_count++;
				}

			} else {

				/* points are in same loop.  Cut the loop */

				(void)cut_mapped_loop(tbl2d, tp->top,
					tp->bot, cut_color, tol, 1);

				if (rt_g.NMG_debug & DEBUG_TRI)
				{
					char fname[32];

					sprintf( fname, "cut%d.g", cut_count );
					nmg_stash_model_to_file( fname,
						nmg_find_model( &toplu->l.magic ),
						"after cut_mapped_loop()" );
					cut_count++;
				}

			}

#if 0
			/* if the bottom vertexuse is on a rising edge and
			 * is a top vertex of another trapezoid then
			 * 	replace the occurrance of the old bottom
			 *	vertexuse with the new one in trapezoid "top"
			 *	locations.
			 */
			bot_next = PT2D_NEXT(tbl2d, tp->bot );

			if ( P_LT_V( tp->bot, bot_next ) ) {
				register struct pt2d *new_pt;
				struct trap *trp;

				/* find the new vertexuse of this vertex */
				new_pt = PT2D_PREV(tbl2d, tp->top);

				/* replace all "top" uses of tp->bot with
				 * new_pt
				 */
				for (BU_LIST_FOR(trp, trap, tlist)) {
					if (trp->top == tp->bot) {
						trp->top = new_pt;
					}
				}

				/* clean up old trapezoid so that top/bot
				 * are in same loop
				 */
				tp->top = PT2D_PREV( tbl2d, tp->bot );
			}
#endif
		} else {

			/* points are in different loops, join the
			 * loops together.
			 */

			if (toplu->orientation == OT_OPPOSITE &&
				botlu->orientation == OT_OPPOSITE)
					rt_bomb("trying to join 2 interior loops in triangulator?\n");

			if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log("joining 2 loops @@ %g %g -> %g %g\n",
					tp->top->coord[X],
					tp->top->coord[Y],
					tp->bot->coord[X],
					tp->bot->coord[Y]);

			join_mapped_loops(tbl2d, tp->top, tp->bot, join_color, tol);
			NMG_CK_LOOPUSE(toplu);

			if (rt_g.NMG_debug & DEBUG_TRI)
			{
				char fname[32];

				sprintf( fname, "join%d.g", cut_count );
				nmg_stash_model_to_file( fname,
					nmg_find_model( &toplu->l.magic ),
					"after join_mapped_loop()" );
				cut_count++;
			}

		}

		if (rt_g.NMG_debug & DEBUG_TRI) {
			nmg_tri_plfu( nmg_find_fu_of_vu(tp->top->vu_p),  tbl2d );
			print_tlist(tbl2d, tlist);
		}
	}

}


/*	C U T _ U N I M O N O T O N E
 *
 *	Given a unimonotone loopuse, triangulate it into multiple loopuses
 */
static void
cut_unimonotone(struct bu_list *tbl2d, struct bu_list *tlist, struct loopuse *lu, const struct bn_tol *tol)
{
	struct pt2d *min, *max, *new, *first=NULL, *prev, *next, *current;
	struct edgeuse *eu;
	int verts=0;
	int vert_count_sq;	/* XXXXX Hack for catching infinite loop */
	int loop_count=0;	/* See above */
	static const int cut_color[3] = { 90, 255, 90};

	NMG_CK_TBL2D(tbl2d);
	BN_CK_TOL(tol);
	NMG_CK_LOOPUSE(lu);

	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("cutting unimonotone:\n");

	min = max = (struct pt2d *)NULL;

	/* find min/max points & count vertex points */
	for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
		new = find_pt2d(tbl2d, eu->vu_p);
		if (!new) {
			bu_log("why can't I find a 2D point for %g %g %g?\n",
			V3ARGS(eu->vu_p->v_p->vg_p->coord));
			rt_bomb("bombing\n");
		}

		if (rt_g.NMG_debug & DEBUG_TRI)
			bu_log("%g %g\n", new->coord[X], new->coord[Y]);

		verts++;

		if (!min || P_LT_V(new, min))
			min = new;
		if (!max || P_GT_V(new, max))
			max = new;
	}
	vert_count_sq = verts * verts;

	/* pick the pt which does NOT have the other as a "next" pt in loop 
	 * as the place from which we start marching around the uni-monotone
	 */
	if (PT2D_NEXT(tbl2d, max) == min)
		first = min;
	else if (PT2D_NEXT(tbl2d, min) == max)
		first = max;
	else {
		bu_log("is this a unimonotone loop of just 2 points?:\t%g %g %g and %g %g %g?\n",
			V3ARGS(min->vu_p->v_p->vg_p->coord), 
			V3ARGS(max->vu_p->v_p->vg_p->coord) );

		rt_bomb("aborting\n");
	}
	
	/* */
	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("%d verts in unimonotone, Min: %g %g  Max: %g %g first:%g %g 0x%08x\n", verts,
			min->coord[X], min->coord[Y],
			max->coord[X], max->coord[Y],
			first->coord[X], first->coord[Y], first);

	current = PT2D_NEXT(tbl2d, first);

	while (verts > 3) {

		loop_count++;
		if( loop_count > vert_count_sq )
		{
			bu_log( "Cut_unimontone is in an infinite loop!!!\n" );
			rt_bomb( "Cut_unimontone is in an infinite loop" );
		}

		prev = PT2D_PREV(tbl2d, current);
		next = PT2D_NEXT(tbl2d, current);

		if (rt_g.NMG_debug & DEBUG_TRI)
			bu_log("%g %g -> %g %g -> %g %g ...\n",
				prev->coord[X],
				prev->coord[Y],
				current->coord[X],
				current->coord[Y],
				next->coord[X],
				next->coord[Y]);

		if (is_convex(prev, current, next, tol)) {
			struct pt2d *t;
			/* cut a triangular piece off of the loop to
			 * create a new loop.
			 */
			NMG_CK_LOOPUSE(lu);
			if (rt_g.NMG_debug & DEBUG_TRI)
			{
				bu_log( "Before cut loop:\n" );
				nmg_pr_fu_briefly( lu->up.fu_p, "" );
			}
			current = cut_mapped_loop(tbl2d, next, prev, cut_color, tol, 0);
			if (rt_g.NMG_debug & DEBUG_TRI)
			{
				bu_log( "After cut loop:\n" );
				nmg_pr_fu_briefly( lu->up.fu_p, "" );
			}
			verts--;
			NMG_CK_LOOPUSE(lu);

			if (rt_g.NMG_debug & DEBUG_TRI)
				nmg_tri_plfu( lu->up.fu_p, tbl2d );

			if (current->vu_p->v_p == first->vu_p->v_p) { 
				t = PT2D_NEXT(tbl2d, first);
				if (rt_g.NMG_debug & DEBUG_TRI)
					bu_log("\tfirst(0x%08x -> %g %g\n", first, t->coord[X], t->coord[Y]);
				t = PT2D_NEXT(tbl2d, current);

				if (rt_g.NMG_debug & DEBUG_TRI)
					bu_log("\tcurrent(0x%08x) -> %g %g\n", current, t->coord[X], t->coord[Y]);

				current = PT2D_NEXT(tbl2d, current);
				if (rt_g.NMG_debug & DEBUG_TRI)
					bu_log("\tcurrent(0x%08x) -> %g %g\n", current, t->coord[X], t->coord[Y]);
			}
		} else {
			if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log("\tConcave, moving ahead\n");
			current = next;
		}
	}
}



static void
nmg_plot_flat_face(struct faceuse *fu, struct bu_list *tbl2d)
{
	struct loopuse *lu;
	struct edgeuse *eu;
	char buf[80];
	vect_t pt;
	struct pt2d *p, *pn;

	NMG_CK_TBL2D(tbl2d);
	NMG_CK_FACEUSE(fu);

	if (!plot_fd && (plot_fd = fopen("triplot.pl", "w")) == (FILE *)NULL) {
		bu_log( "cannot open triplot.pl\n");
	}

	pl_erase(plot_fd);
	pd_3space(plot_fd,
		fu->f_p->min_pt[0]-1.0,
		fu->f_p->min_pt[1]-1.0,
		fu->f_p->min_pt[2]-1.0,
		fu->f_p->max_pt[0]+1.0,
		fu->f_p->max_pt[1]+1.0,
		fu->f_p->max_pt[2]+1.0);

	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		if (BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC) {
			register struct vertexuse *vu;

			vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
			if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log( "lone vert @@ %g %g %g\n",
					V3ARGS(vu->v_p->vg_p->coord) );

			pl_color(plot_fd, 200, 200, 100);

			if (! (p=find_pt2d(tbl2d, vu)) )
				rt_bomb("didn't find vertexuse in list!\n");

			pdv_3point(plot_fd, p->coord);
			sprintf(buf, "%g, %g", p->coord[0], p->coord[1]);
			pl_label(plot_fd, buf);

			continue;
		}
		
		for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd ) ) {
			register struct edgeuse *eu_pnext;

			eu_pnext = BU_LIST_PNEXT_CIRC(edgeuse, &eu->l);

#if 0
			if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log( "eu vert @@ %g %g %g\n",
					V3ARGS(eu->vu_p->v_p->vg_p->coord) );

#endif
			if (! (p=find_pt2d(tbl2d, eu->vu_p)) )
				rt_bomb("didn't find vertexuse in list!\n");

			if (! (pn=find_pt2d(tbl2d, eu_pnext->vu_p)) )
				rt_bomb("didn't find vertexuse in list!\n");


			VSUB2(pt, pn->coord, p->coord);

			VSCALE(pt, pt, 0.80);
			VADD2(pt, p->coord, pt);

			pl_color(plot_fd, 200, 200, 200);
			pdv_3line(plot_fd, p->coord, pt);
			pd_3move(plot_fd, V3ARGS(p->coord));

			sprintf(buf, "%g, %g", p->coord[0], p->coord[1]);
			pl_label(plot_fd, buf);
		}
	}
}


void
nmg_triangulate_fu(struct faceuse *fu, const struct bn_tol *tol)
{
	mat_t TformMat;
	struct bu_list *tbl2d;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct vertexuse *vu;
	struct bu_list tlist;
	struct trap *tp;
	struct pt2d *pt;
	int vert_count;
	static int iter=0;
	static int monotone=0;
	vect_t N;

	char db_name[32];

	BN_CK_TOL(tol);
	NMG_CK_FACEUSE(fu);

	if (rt_g.NMG_debug & DEBUG_TRI) {
		NMG_GET_FU_NORMAL(N, fu);
		bu_log("---------------- Triangulate face %g %g %g\n",
			V3ARGS(N));
	}


	/* make a quick check to see if we need to bother or not */
	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		if (lu->orientation != OT_SAME) {
			if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log("faceuse has non-OT_SAME orientation loop\n");
			goto triangulate;
		}
		vert_count = 0;
		for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd ))
			if (++vert_count > 3) {
				if (rt_g.NMG_debug & DEBUG_TRI)
					bu_log("loop has more than 3 verticies\n");
				goto triangulate;
			}
	}

	if (rt_g.NMG_debug & DEBUG_TRI) {
		bu_log("---------------- face %g %g %g already triangular\n",
			V3ARGS(N));

		for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
			for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd ))
				VPRINT("pt", eu->vu_p->v_p->vg_p->coord );

	}
	return;

triangulate:
	if (rt_g.NMG_debug & DEBUG_TRI) {
		vect_t N;
		NMG_GET_FU_NORMAL(N, fu);
		bu_log("---------------- proceeding to triangulate face %g %g %g\n", V3ARGS(N));
	}


	/* convert 3D face to face in the X-Y plane */
	tbl2d = nmg_flatten_face(fu, TformMat);

	/* avoid having a hole start as the first point */
	{
		struct pt2d *pt1, *pt2;

		pt1 = BU_LIST_FIRST( pt2d, tbl2d );
		pt2 = BU_LIST_PNEXT( pt2d, &pt1->l );

		if( vtype2d( pt1, tbl2d, tol ) == HOLE_START &&
		    pt1->vu_p->v_p == pt2->vu_p->v_p )
		{
			/* swap first and second points */
			if (rt_g.NMG_debug & DEBUG_TRI)
				bu_log( "Swapping first two points on vertex list (first one was a HOLE_START)\n" );

			BU_LIST_DEQUEUE( &pt1->l );
			BU_LIST_APPEND( &pt2->l, &pt1->l );
		}
	}

	if (rt_g.NMG_debug & DEBUG_TRI) {
		struct pt2d *pt;
		bu_log( "Face Flattened\n");
		bu_log( "Vertex list:\n");
		for (BU_LIST_FOR(pt, pt2d, tbl2d)) {
			bu_log("\tpt2d %26.20e %26.20e\n", pt->coord[0], pt->coord[1]);
		}

		nmg_tri_plfu( fu, tbl2d );
		nmg_plot_flat_face(fu, tbl2d);
		bu_log( "Face plotted\n\tmaking trapezoids...\n");
	}


	BU_LIST_INIT(&tlist);
	nmg_trap_face(tbl2d, &tlist, tol);

	if (rt_g.NMG_debug & DEBUG_TRI){
		print_tlist(tbl2d, &tlist);

		bu_log("Cutting diagonals ----------\n");
	}
	cut_diagonals(tbl2d, &tlist, fu, tol);
	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("Diagonals are cut ----------\n");

	if (rt_g.NMG_debug & DEBUG_TRI) {
		sprintf(db_name, "uni%d.g", iter);
		nmg_stash_model_to_file(db_name,
			nmg_find_model(&fu->s_p->l.magic),
			"trangles and unimonotones");
	}

	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
		(void)nmg_loop_split_at_touching_jaunt(lu, tol);

	if (rt_g.NMG_debug & DEBUG_TRI) {
		sprintf(db_name, "uni_sj%d.g", iter);
		nmg_stash_model_to_file(db_name,
			nmg_find_model(&fu->s_p->l.magic),
			"after split_at_touching_jaunt");
	}

	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
		nmg_split_touchingloops( lu, tol );

	if (rt_g.NMG_debug & DEBUG_TRI) {
		sprintf(db_name, "uni_split%d.g", iter++);
		nmg_stash_model_to_file(db_name,
			nmg_find_model(&fu->s_p->l.magic),
			"split trangles and unimonotones");
	}
	
	/* now we're left with a face that has some triangle loops and some
	 * uni-monotone loops.  Find the uni-monotone loops and triangulate.
	 */
	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {

		if (BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC) {
			vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
			
			bu_log("How did I miss this vertex loop %g %g %g?\n%s\n",
				V3ARGS(vu->v_p->vg_p->coord),
				"I'm supposed to be dealing with unimonotone loops now");
			rt_bomb("aborting\n");

		} else if (BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC) {
			vert_count = 0;
			for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd )) {
				if (++vert_count > 3) {
					cut_unimonotone(tbl2d, &tlist, lu, tol);

					if (rt_g.NMG_debug & DEBUG_TRI) {
						sprintf(db_name, "uni_mono%d.g", monotone++);
						nmg_stash_model_to_file(db_name,
							nmg_find_model(&fu->s_p->l.magic),
							"newly cut unimonotone");
					}

					break;
				}
			}
		}
	}


	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
		nmg_lu_reorient(lu);

	if (rt_g.NMG_debug & DEBUG_TRI)
		nmg_tri_plfu( fu, tbl2d );

	while (BU_LIST_WHILE(tp, trap, &tlist)) {
		BU_LIST_DEQUEUE(&tp->l);
		bu_free((char *)tp, "trapezoid free");
	}

	while (BU_LIST_WHILE(pt, pt2d, tbl2d)) {
		BU_LIST_DEQUEUE(&pt->l);
		bu_free((char *)pt, "pt2d free");
	}
	bu_free((char *)tbl2d, "discard tbl2d");

	return;
}

void
nmg_triangulate_shell(struct shell *s, const struct bn_tol *tol)
{
	struct faceuse *fu;

	BN_CK_TOL(tol);
	NMG_CK_SHELL( s );

	for (BU_LIST_FOR(fu, faceuse, &s->fu_hd)) {
		NMG_CK_FACEUSE(fu);
		if (fu->orientation == OT_SAME)
			nmg_triangulate_fu(fu, tol);
	}
}

void
nmg_triangulate_model(struct model *m, const struct bn_tol *tol)
{
	struct nmgregion *r;
	struct shell *s;
	struct faceuse *fu;
	
	BN_CK_TOL(tol);
	NMG_CK_MODEL(m);
	nmg_vmodel(m);

	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("Triangulating NMG\n");

	(void)nmg_model_edge_g_fuse( m, tol );

	(void)nmg_unbreak_region_edges( &m->magic );

	for (BU_LIST_FOR(r, nmgregion, &m->r_hd)) {
		NMG_CK_REGION(r);
		for (BU_LIST_FOR(s, shell, &r->s_hd)) {
			NMG_CK_SHELL(s);
			nmg_s_split_touchingloops(s, tol);

			for (BU_LIST_FOR(fu, faceuse, &s->fu_hd)) {
				NMG_CK_FACEUSE(fu);
				if (fu->orientation == OT_SAME)
					nmg_triangulate_fu(fu, tol);
			}
		}
	}
	nmg_vmodel(m);

	if (rt_g.NMG_debug & DEBUG_TRI)
		bu_log("Triangulation completed\n");
}
@


11.35
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_tri.c,v 11.34 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.34
log
@merge of ansi-6-0-branch into HEAD
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d25 5
a29 1
#include "conf.h"
@


11.33
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.32 2002/08/20 17:08:06 jra Exp $ (ARL)";
d117 1
a117 1
static struct pt2d *find_pt2d();	
d121 1
a121 4
print_2d_eu(s, eu, tbl2d)
char *s;
struct edgeuse *eu;
struct bu_list *tbl2d;
d136 1
a136 3
print_trap(tp, tbl2d)
struct trap *tp;
struct bu_list *tbl2d;
d161 1
a161 2
print_tlist(tbl2d, tlist)
struct bu_list *tbl2d, *tlist;
d177 1
a177 3
find_pt2d(tbl2d, vu)
struct bu_list *tbl2d;
struct vertexuse *vu;
d192 1
a192 3
nmg_tri_plfu( fu, tbl2d )
struct faceuse *fu;
struct bu_list *tbl2d;
d272 1
a272 4
pt2d_pn(tbl, pt, dir)
struct bu_list *tbl;
struct pt2d *pt;
int dir;
d322 1
a322 5
map_vu_to_2d(vu, tbl2d, mat, fu)
struct vertexuse *vu;
struct bu_list *tbl2d;
mat_t mat;
struct faceuse *fu;
d428 1
a428 3
nmg_flatten_face(fu, TformMat)
struct faceuse *fu;
mat_t		TformMat;
d496 1
a496 3
is_convex(a, b, c, tol)
struct pt2d *a, *b, *c;
const struct bn_tol *tol;
d552 1
a552 4
vtype2d(v, tbl2d, tol)
struct pt2d *v;
struct bu_list *tbl2d;
const struct bn_tol *tol;
d661 1
a661 3
poly_start_vertex(pt, tbl2d, tlist)
struct pt2d *pt;
struct bu_list *tbl2d, *tlist;
d695 1
a695 3
poly_side_vertex(pt, tbl2d, tlist)
struct pt2d *pt, *tbl2d;
struct bu_list *tlist;
d779 1
a779 3
poly_end_vertex(pt, tbl2d, tlist)
struct pt2d *pt;
struct bu_list *tbl2d, *tlist;
d840 1
a840 3
hole_start_vertex(pt, tbl2d, tlist)
struct pt2d *pt;
struct bu_list *tlist, *tbl2d;
d977 1
a977 3
hole_end_vertex(pt, tbl2d, tlist)
struct pt2d *pt; 
struct bu_list *tlist, *tbl2d;
d1068 1
a1068 3
nmg_trap_face(tbl2d, tlist, tol)
struct bu_list *tbl2d, *tlist;
const struct bn_tol *tol;
d1104 1
a1104 3
map_new_vertexuse(tbl2d, vu_p)
struct bu_list *tbl2d;
struct vertexuse *vu_p;
d1148 7
a1154 7
pick_edges(v, vu_first, min_dir, vu_last, max_dir, fu, tol, dir)
struct vertex *v;
struct vertexuse **vu_last, **vu_first;
struct faceuse *fu;
int *max_dir, *min_dir;	/* 1: forward -1 reverse */
const struct bn_tol	*tol;
vect_t dir;
d1307 1
a1307 5
pick_eu(eu_p, fu, dir, find_max)
struct edgeuse *eu_p;
struct faceuse *fu;
vect_t dir;
int find_max;
d1415 1
a1415 7
nmg_find_first_last_use_of_v_in_fu(v, first_vu, last_vu, dir, fu, tol)
struct vertex *v;
struct vertexuse **first_vu;
struct vertexuse **last_vu;
vect_t 		dir;
struct faceuse	*fu;
const struct bn_tol	*tol;
d1576 1
a1576 4
pick_pt2d_for_cutjoin(tbl2d, p1, p2, tol)
struct bu_list *tbl2d;
struct pt2d **p1, **p2;
const struct bn_tol *tol;
d1668 1
a1668 1
static void join_mapped_loops();
d1670 1
a1670 6
cut_mapped_loop(tbl2d, p1, p2, color, tol, void_ok)
struct bu_list *tbl2d;
struct pt2d *p1, *p2;
const int color[3];
const struct bn_tol	*tol;
int void_ok;
d1855 1
a1855 5
join_mapped_loops(tbl2d, p1, p2, color, tol)
struct bu_list *tbl2d;
struct pt2d *p1, *p2;
const int color[3];
const struct bn_tol	*tol;
d1981 1
a1981 3
skip_cut(tbl2d, top, bot)
struct bu_list *tbl2d;
struct pt2d *top, *bot;
d2060 1
a2060 4
cut_diagonals(tbl2d, tlist, fu, tol)
struct bu_list *tbl2d, *tlist;
const struct faceuse	*fu;
const struct bn_tol	*tol;
d2068 1
a2068 1
	extern struct loopuse *nmg_find_lu_of_vu();
d2279 1
a2279 4
cut_unimonotone( tbl2d, tlist, lu, tol )
struct bu_list *tbl2d, *tlist;
struct loopuse *lu;
const struct bn_tol *tol;
d2410 1
a2410 3
nmg_plot_flat_face(fu, tbl2d)
struct faceuse *fu;
struct bu_list *tbl2d;
d2490 1
a2490 3
nmg_triangulate_fu(fu, tol)
struct faceuse *fu;
const struct bn_tol	*tol;
d2681 1
a2681 3
nmg_triangulate_shell(s, tol)
struct shell *s;
const struct bn_tol   *tol;
d2696 1
a2696 3
nmg_triangulate_model(m, tol)
struct model *m;
const struct bn_tol   *tol;
@


11.32
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1994 by the United States Army
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.30 2002/08/06 14:41:29 jra Exp $ (ARL)";
@


11.32.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_tri.c,v 11.33 2004/02/02 17:39:27 morrison Exp $ (ARL)";
@


11.32.10.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.33 2004/02/02 17:39:27 morrison Exp $ (ARL)";
@


11.32.10.2
log
@merge from head
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.32.10.1 2004/02/12 18:37:45 erikg Exp $ (ARL)";
@


11.32.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.32 2002/08/20 17:08:06 jra Exp $ (ARL)";
d117 1
a117 1
static struct pt2d *find_pt2d(struct bu_list *tbl2d, struct vertexuse *vu);	
d121 4
a124 1
print_2d_eu(char *s, struct edgeuse *eu, struct bu_list *tbl2d)
d139 3
a141 1
print_trap(struct trap *tp, struct bu_list *tbl2d)
d166 2
a167 1
print_tlist(struct bu_list *tbl2d, struct bu_list *tlist)
d183 3
a185 1
find_pt2d(struct bu_list *tbl2d, struct vertexuse *vu)
d200 3
a202 1
nmg_tri_plfu(struct faceuse *fu, struct bu_list *tbl2d)
d282 4
a285 1
pt2d_pn(struct bu_list *tbl, struct pt2d *pt, int dir)
d335 5
a339 1
map_vu_to_2d(struct vertexuse *vu, struct bu_list *tbl2d, fastf_t *mat, struct faceuse *fu)
d445 3
a447 1
nmg_flatten_face(struct faceuse *fu, fastf_t *TformMat)
d515 3
a517 1
is_convex(struct pt2d *a, struct pt2d *b, struct pt2d *c, const struct bn_tol *tol)
d573 4
a576 1
vtype2d(struct pt2d *v, struct bu_list *tbl2d, const struct bn_tol *tol)
d685 3
a687 1
poly_start_vertex(struct pt2d *pt, struct bu_list *tbl2d, struct bu_list *tlist)
d721 3
a723 1
poly_side_vertex(struct pt2d *pt, struct pt2d *tbl2d, struct bu_list *tlist)
d807 3
a809 1
poly_end_vertex(struct pt2d *pt, struct bu_list *tbl2d, struct bu_list *tlist)
d870 3
a872 1
hole_start_vertex(struct pt2d *pt, struct bu_list *tbl2d, struct bu_list *tlist)
d1009 3
a1011 1
hole_end_vertex(struct pt2d *pt, struct bu_list *tbl2d, struct bu_list *tlist)
d1102 3
a1104 1
nmg_trap_face(struct bu_list *tbl2d, struct bu_list *tlist, const struct bn_tol *tol)
d1140 3
a1142 1
map_new_vertexuse(struct bu_list *tbl2d, struct vertexuse *vu_p)
d1186 7
a1192 7
pick_edges(struct vertex *v, struct vertexuse **vu_first, int *min_dir, struct vertexuse **vu_last, int *max_dir, struct faceuse *fu, const struct bn_tol *tol, fastf_t *dir)
                 
                                       
                   
                       	/* 1: forward -1 reverse */
                   	     
           
d1345 5
a1349 1
pick_eu(struct edgeuse *eu_p, struct faceuse *fu, fastf_t *dir, int find_max)
d1457 7
a1463 1
nmg_find_first_last_use_of_v_in_fu(struct vertex *v, struct vertexuse **first_vu, struct vertexuse **last_vu, fastf_t *dir, struct faceuse *fu, const struct bn_tol *tol)
d1624 4
a1627 1
pick_pt2d_for_cutjoin(struct bu_list *tbl2d, struct pt2d **p1, struct pt2d **p2, const struct bn_tol *tol)
d1719 1
a1719 1
static void join_mapped_loops(struct bu_list *tbl2d, struct pt2d *p1, struct pt2d *p2, const int *color, const struct bn_tol *tol);
d1721 6
a1726 1
cut_mapped_loop(struct bu_list *tbl2d, struct pt2d *p1, struct pt2d *p2, const int *color, const struct bn_tol *tol, int void_ok)
d1911 5
a1915 1
join_mapped_loops(struct bu_list *tbl2d, struct pt2d *p1, struct pt2d *p2, const int *color, const struct bn_tol *tol)
d2041 3
a2043 1
skip_cut(struct bu_list *tbl2d, struct pt2d *top, struct pt2d *bot)
d2122 4
a2125 1
cut_diagonals(struct bu_list *tbl2d, struct bu_list *tlist, const struct faceuse *fu, const struct bn_tol *tol)
d2133 1
a2133 1
	extern struct loopuse *nmg_find_lu_of_vu(const struct vertexuse *vu);
d2344 4
a2347 1
cut_unimonotone(struct bu_list *tbl2d, struct bu_list *tlist, struct loopuse *lu, const struct bn_tol *tol)
d2478 3
a2480 1
nmg_plot_flat_face(struct faceuse *fu, struct bu_list *tbl2d)
d2560 3
a2562 1
nmg_triangulate_fu(struct faceuse *fu, const struct bn_tol *tol)
d2753 3
a2755 1
nmg_triangulate_shell(struct shell *s, const struct bn_tol *tol)
d2770 3
a2772 1
nmg_triangulate_model(struct model *m, const struct bn_tol *tol)
@


11.32.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.31
log
@Converted from K&R to ANSI C - RFH
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.29 2001/04/05 19:35:36 morrison Exp $ (ARL)";
d117 1
a117 1
static struct pt2d *find_pt2d(struct bu_list *tbl2d, struct vertexuse *vu);	
d121 4
a124 1
print_2d_eu(char *s, struct edgeuse *eu, struct bu_list *tbl2d)
d139 3
a141 1
print_trap(struct trap *tp, struct bu_list *tbl2d)
d166 2
a167 1
print_tlist(struct bu_list *tbl2d, struct bu_list *tlist)
d183 3
a185 1
find_pt2d(struct bu_list *tbl2d, struct vertexuse *vu)
d200 3
a202 1
nmg_tri_plfu(struct faceuse *fu, struct bu_list *tbl2d)
d282 4
a285 1
pt2d_pn(struct bu_list *tbl, struct pt2d *pt, int dir)
d335 5
a339 1
map_vu_to_2d(struct vertexuse *vu, struct bu_list *tbl2d, fastf_t *mat, struct faceuse *fu)
d445 3
a447 1
nmg_flatten_face(struct faceuse *fu, fastf_t *TformMat)
d515 3
a517 1
is_convex(struct pt2d *a, struct pt2d *b, struct pt2d *c, const struct bn_tol *tol)
d573 4
a576 1
vtype2d(struct pt2d *v, struct bu_list *tbl2d, const struct bn_tol *tol)
d685 3
a687 1
poly_start_vertex(struct pt2d *pt, struct bu_list *tbl2d, struct bu_list *tlist)
d721 3
a723 1
poly_side_vertex(struct pt2d *pt, struct pt2d *tbl2d, struct bu_list *tlist)
d807 3
a809 1
poly_end_vertex(struct pt2d *pt, struct bu_list *tbl2d, struct bu_list *tlist)
d870 3
a872 1
hole_start_vertex(struct pt2d *pt, struct bu_list *tbl2d, struct bu_list *tlist)
d965 3
a971 3
	bu_log("didn't find trapezoid for hole-start point at:\n\t%g %g %g\n",
		V3ARGS(pt->vu_p->v_p->vg_p->coord) );

d1009 3
a1011 1
hole_end_vertex(struct pt2d *pt, struct bu_list *tbl2d, struct bu_list *tlist)
d1102 3
a1104 1
nmg_trap_face(struct bu_list *tbl2d, struct bu_list *tlist, const struct bn_tol *tol)
d1140 3
a1142 1
map_new_vertexuse(struct bu_list *tbl2d, struct vertexuse *vu_p)
d1186 7
a1192 7
pick_edges(struct vertex *v, struct vertexuse **vu_first, int *min_dir, struct vertexuse **vu_last, int *max_dir, struct faceuse *fu, const struct bn_tol *tol, fastf_t *dir)
                 
                                       
                   
                       	/* 1: forward -1 reverse */
                   	     
           
d1345 5
a1349 1
pick_eu(struct edgeuse *eu_p, struct faceuse *fu, fastf_t *dir, int find_max)
d1457 7
a1463 1
nmg_find_first_last_use_of_v_in_fu(struct vertex *v, struct vertexuse **first_vu, struct vertexuse **last_vu, fastf_t *dir, struct faceuse *fu, const struct bn_tol *tol)
d1624 4
a1627 1
pick_pt2d_for_cutjoin(struct bu_list *tbl2d, struct pt2d **p1, struct pt2d **p2, const struct bn_tol *tol)
d1719 1
a1719 1
static void join_mapped_loops(struct bu_list *tbl2d, struct pt2d *p1, struct pt2d *p2, const int *color, const struct bn_tol *tol);
d1721 6
a1726 1
cut_mapped_loop(struct bu_list *tbl2d, struct pt2d *p1, struct pt2d *p2, const int *color, const struct bn_tol *tol, int void_ok)
a1771 3
			nmg_stash_model_to_file( "bad_tri_cut.g",
				nmg_find_model(&p1->vu_p->l.magic), buf );

d1775 1
a1775 1
	
d1790 3
d1911 5
a1915 1
join_mapped_loops(struct bu_list *tbl2d, struct pt2d *p1, struct pt2d *p2, const int *color, const struct bn_tol *tol)
d2041 3
a2043 1
skip_cut(struct bu_list *tbl2d, struct pt2d *top, struct pt2d *bot)
d2122 4
a2125 1
cut_diagonals(struct bu_list *tbl2d, struct bu_list *tlist, const struct faceuse *fu, const struct bn_tol *tol)
d2133 1
a2133 1
	extern struct loopuse *nmg_find_lu_of_vu(const struct vertexuse *vu);
d2344 4
a2347 1
cut_unimonotone(struct bu_list *tbl2d, struct bu_list *tlist, struct loopuse *lu, const struct bn_tol *tol)
d2478 3
a2480 1
nmg_plot_flat_face(struct faceuse *fu, struct bu_list *tbl2d)
d2560 3
a2562 1
nmg_triangulate_fu(struct faceuse *fu, const struct bn_tol *tol)
d2753 3
a2755 1
nmg_triangulate_shell(struct shell *s, const struct bn_tol *tol)
d2770 3
a2772 1
nmg_triangulate_model(struct model *m, const struct bn_tol *tol)
@


11.30
log
@Moved calls to nmg_stash_model to just before bomb
(to avoid trying to use the model after it is gone)
@
text
@d117 1
a117 1
static struct pt2d *find_pt2d();	
d121 1
a121 4
print_2d_eu(s, eu, tbl2d)
char *s;
struct edgeuse *eu;
struct bu_list *tbl2d;
d136 1
a136 3
print_trap(tp, tbl2d)
struct trap *tp;
struct bu_list *tbl2d;
d161 1
a161 2
print_tlist(tbl2d, tlist)
struct bu_list *tbl2d, *tlist;
d177 1
a177 3
find_pt2d(tbl2d, vu)
struct bu_list *tbl2d;
struct vertexuse *vu;
d192 1
a192 3
nmg_tri_plfu( fu, tbl2d )
struct faceuse *fu;
struct bu_list *tbl2d;
d272 1
a272 4
pt2d_pn(tbl, pt, dir)
struct bu_list *tbl;
struct pt2d *pt;
int dir;
d322 1
a322 5
map_vu_to_2d(vu, tbl2d, mat, fu)
struct vertexuse *vu;
struct bu_list *tbl2d;
mat_t mat;
struct faceuse *fu;
d428 1
a428 3
nmg_flatten_face(fu, TformMat)
struct faceuse *fu;
mat_t		TformMat;
d496 1
a496 3
is_convex(a, b, c, tol)
struct pt2d *a, *b, *c;
const struct bn_tol *tol;
d552 1
a552 4
vtype2d(v, tbl2d, tol)
struct pt2d *v;
struct bu_list *tbl2d;
const struct bn_tol *tol;
d661 1
a661 3
poly_start_vertex(pt, tbl2d, tlist)
struct pt2d *pt;
struct bu_list *tbl2d, *tlist;
d695 1
a695 3
poly_side_vertex(pt, tbl2d, tlist)
struct pt2d *pt, *tbl2d;
struct bu_list *tlist;
d779 1
a779 3
poly_end_vertex(pt, tbl2d, tlist)
struct pt2d *pt;
struct bu_list *tbl2d, *tlist;
d840 1
a840 3
hole_start_vertex(pt, tbl2d, tlist)
struct pt2d *pt;
struct bu_list *tlist, *tbl2d;
a932 3
	bu_log("didn't find trapezoid for hole-start point at:\n\t%g %g %g\n",
		V3ARGS(pt->vu_p->v_p->vg_p->coord) );

d937 3
d977 1
a977 3
hole_end_vertex(pt, tbl2d, tlist)
struct pt2d *pt; 
struct bu_list *tlist, *tbl2d;
d1068 1
a1068 3
nmg_trap_face(tbl2d, tlist, tol)
struct bu_list *tbl2d, *tlist;
const struct bn_tol *tol;
d1104 1
a1104 3
map_new_vertexuse(tbl2d, vu_p)
struct bu_list *tbl2d;
struct vertexuse *vu_p;
d1148 7
a1154 7
pick_edges(v, vu_first, min_dir, vu_last, max_dir, fu, tol, dir)
struct vertex *v;
struct vertexuse **vu_last, **vu_first;
struct faceuse *fu;
int *max_dir, *min_dir;	/* 1: forward -1 reverse */
const struct bn_tol	*tol;
vect_t dir;
d1307 1
a1307 5
pick_eu(eu_p, fu, dir, find_max)
struct edgeuse *eu_p;
struct faceuse *fu;
vect_t dir;
int find_max;
d1415 1
a1415 7
nmg_find_first_last_use_of_v_in_fu(v, first_vu, last_vu, dir, fu, tol)
struct vertex *v;
struct vertexuse **first_vu;
struct vertexuse **last_vu;
vect_t 		dir;
struct faceuse	*fu;
const struct bn_tol	*tol;
d1576 1
a1576 4
pick_pt2d_for_cutjoin(tbl2d, p1, p2, tol)
struct bu_list *tbl2d;
struct pt2d **p1, **p2;
const struct bn_tol *tol;
d1668 1
a1668 1
static void join_mapped_loops();
d1670 1
a1670 6
cut_mapped_loop(tbl2d, p1, p2, color, tol, void_ok)
struct bu_list *tbl2d;
struct pt2d *p1, *p2;
const int color[3];
const struct bn_tol	*tol;
int void_ok;
d1716 3
d1722 1
a1722 1
			
a1736 3
			nmg_stash_model_to_file( "bad_tri_cut.g",
						 nmg_find_model(&p1->vu_p->l.magic), buf );

d1855 1
a1855 5
join_mapped_loops(tbl2d, p1, p2, color, tol)
struct bu_list *tbl2d;
struct pt2d *p1, *p2;
const int color[3];
const struct bn_tol	*tol;
d1981 1
a1981 3
skip_cut(tbl2d, top, bot)
struct bu_list *tbl2d;
struct pt2d *top, *bot;
d2060 1
a2060 4
cut_diagonals(tbl2d, tlist, fu, tol)
struct bu_list *tbl2d, *tlist;
const struct faceuse	*fu;
const struct bn_tol	*tol;
d2068 1
a2068 1
	extern struct loopuse *nmg_find_lu_of_vu();
d2279 1
a2279 4
cut_unimonotone( tbl2d, tlist, lu, tol )
struct bu_list *tbl2d, *tlist;
struct loopuse *lu;
const struct bn_tol *tol;
d2410 1
a2410 3
nmg_plot_flat_face(fu, tbl2d)
struct faceuse *fu;
struct bu_list *tbl2d;
d2490 1
a2490 3
nmg_triangulate_fu(fu, tol)
struct faceuse *fu;
const struct bn_tol	*tol;
d2681 1
a2681 3
nmg_triangulate_shell(s, tol)
struct shell *s;
const struct bn_tol   *tol;
d2696 1
a2696 3
nmg_triangulate_model(m, tol)
struct model *m;
const struct bn_tol   *tol;
@


11.29
log
@updated SIGNED to signed
updated CONST to const
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.28 2000/09/01 02:19:10 mike Exp $ (ARL)";
d965 3
a971 3
	bu_log("didn't find trapezoid for hole-start point at:\n\t%g %g %g\n",
		V3ARGS(pt->vu_p->v_p->vg_p->coord) );

a1771 3
			nmg_stash_model_to_file( "bad_tri_cut.g",
				nmg_find_model(&p1->vu_p->l.magic), buf );

d1775 1
a1775 1
	
d1790 3
@


11.28
log
@
lint
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.27 2000/08/21 02:02:33 butler Exp $ (ARL)";
d449 1
a449 1
	static CONST vect_t twoDspace = { 0.0, 0.0, 1.0 };
d517 1
a517 1
CONST struct bn_tol *tol;
d576 1
a576 1
CONST struct bn_tol *tol;
d1104 1
a1104 1
CONST struct bn_tol *tol;
d1191 1
a1191 1
CONST struct bn_tol	*tol;
d1463 1
a1463 1
CONST struct bn_tol	*tol;
d1627 1
a1627 1
CONST struct bn_tol *tol;
d1724 2
a1725 2
CONST int color[3];
CONST struct bn_tol	*tol;
d1914 2
a1915 2
CONST int color[3];
CONST struct bn_tol	*tol;
d2124 2
a2125 2
CONST struct faceuse	*fu;
CONST struct bn_tol	*tol;
d2130 2
a2131 2
	static CONST int cut_color[3] = {255, 80, 80};
	static CONST int join_color[3] = {80, 80, 255};
d2347 1
a2347 1
CONST struct bn_tol *tol;
d2354 1
a2354 1
	static CONST int cut_color[3] = { 90, 255, 90};
d2562 1
a2562 1
CONST struct bn_tol	*tol;
d2755 1
a2755 1
CONST struct bn_tol   *tol;
d2772 1
a2772 1
CONST struct bn_tol   *tol;
@


11.27
log
@Massive compilation warnings eliminated
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.26 2000/07/25 16:46:06 butler Exp $ (ARL)";
d726 1
a726 1
	struct edgeuse *upper_edge, *lower_edge;
d1351 1
a1351 1
	struct edgeuse *eu, *keep_eu, *eu_next;
d1467 1
a1467 1
	struct edgeuse *eu_first, *eu_last, *eu_p;
d2349 1
a2349 1
	struct pt2d *min, *max, *new, *first, *prev, *next, *current;
@


11.26
log
@Fixed bad practice in db5_update_ident definition: implicit int return
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.25 2000/07/14 17:14:35 jra Exp $ (ARL)";
d32 1
d245 1
a245 1
			if (p=find_pt2d(tbl2d, vu)) {
d257 1
a257 1
				if (p=find_pt2d(tbl2d,eu->vu_p)) {
d361 1
a361 1
		if (p = find_pt2d(tbl2d, vu_p)) {
d1151 1
a1151 1
	if (p = find_pt2d(tbl2d, vu_p)) {
@


11.25
log
@Added nmg_triangulate_shell()
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.24 2000/07/10 23:01:46 mike Exp $ (ARL)";
d103 1
a103 2
PvsV(p, v)
struct trap *p, *v;
@


11.24
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.23 2000/05/02 01:46:05 mike Exp $ (ARL)";
d2750 17
@


11.23
log
@
Changed from rt_list to bu_list
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.22 2000/03/28 20:41:05 mike Exp $ (ARL)";
@


11.23.2.1
log
@Added nmg_triangulate_shell()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.23 2000/05/02 01:46:05 mike Exp $ (ARL)";
a2788 18
}


void
nmg_triangulate_shell(s, tol)
struct shell *s;
CONST struct bn_tol   *tol;
{
	struct faceuse *fu;

	BN_CK_TOL(tol);
	NMG_CK_SHELL( s );

	for (BU_LIST_FOR(fu, faceuse, &s->fu_hd)) {
		NMG_CK_FACEUSE(fu);
		if (fu->orientation == OT_SAME)
			nmg_triangulate_fu(fu, tol);
	}
@


11.22
log
@
Eliminated name conflict
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.21 2000/03/28 20:39:12 mike Exp $ (ARL)";
d63 1
a63 1
	if ( ! BU_LIST_PREV(rt_list, &(_p)->l) ) {\
d66 2
a67 2
		rt_bomb("aborting");\
	} else if (! BU_LIST_NEXT(rt_list, &(_p)->l) ) {\
d70 1
a70 1
		rt_bomb("aborting");\
@


11.21
log
@
Removed stray structure definition
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.20 1999/12/30 04:55:28 mike Exp $ (ARL)";
d200 1
a200 1
plfu( fu, tbl2d )
d2331 1
a2331 1
			plfu( nmg_find_fu_of_vu(tp->top->vu_p),  tbl2d );
d2452 1
a2452 1
				plfu( lu->up.fu_p, tbl2d );
d2654 1
a2654 1
		plfu( fu, tbl2d );
d2736 1
a2736 1
		plfu( fu, tbl2d );
@


11.20
log
@
removed lint
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.19 1999/06/03 01:43:38 mike Exp $ (ARL)";
a99 19

/* The "ray" here is the intersection line between two faces */
struct nmg_ray_state {
	struct vertexuse	**vu;		/* ptr to vu array */
	int			nvu;		/* len of vu[] */
	point_t			pt;		/* The ray */
	vect_t			dir;
	struct edge_g_lseg	*eg_p;		/* Edge geom of the ray */
	struct shell		*sA;
	struct shell		*sB;
	struct faceuse		*fu1;
	struct faceuse		*fu2;
	vect_t			left;		/* points left of ray, on face */
	int			state;		/* current (old) state */
	int			last_action;	/* last action taken */
	vect_t			ang_x_dir;	/* x axis for angle measure */
	vect_t			ang_y_dir;	/* y axis for angle measure */
	CONST struct bn_tol	*tol;
};
@


11.19
log
@
sed4
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.18 1999/05/11 21:01:32 jra Exp $ (ARL)";
a1967 2
		struct vertexuse *vu;

d1971 1
a1971 1
		vu = nmg_join_2loops(p1->vu_p,  p2->vu_p);
@


11.18
log
@hole_start_vertex() was mallocing 2 "trap" structs with one malloc and trying to free them seperately.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.17 1999/05/11 19:26:14 mike Exp $ (ARL)";
d243 1
a243 1
	b = (long *)rt_calloc( fu->s_p->r_p->m_p->maxindex,
d289 1
a289 1
	rt_free((char *)b, "plot table");
d373 1
a373 1
	np = (struct pt2d *)rt_calloc(1, sizeof(struct pt2d), "pt2d struct");
d434 1
a434 1
		p = (struct pt2d *)rt_calloc(1, sizeof(struct pt2d), "pt2d");
d477 1
a477 1
	tbl2d = (struct bu_list *)rt_calloc(1, sizeof(struct bu_list),
d490 1
a490 1
	mat_fromto( TformMat, Normal, twoDspace );
d493 1
a493 1
		mat_print( "TformMat", TformMat );
d716 1
a716 1
	new_trap = (struct trap *)rt_calloc(sizeof(struct trap), 1, "new poly_start trap");
d798 1
a798 1
	new_trap = (struct trap *)rt_calloc(sizeof(struct trap), 1, "new side trap");
d997 1
a997 1
	new_trap = (struct trap *)rt_calloc(sizeof(struct trap), 1, "New hole start trapezoids");
d1005 1
a1005 1
	new_trap = (struct trap *)rt_calloc(sizeof(struct trap), 1, "New hole start trapezoids");
d1097 1
a1097 1
	tp = (struct trap *)rt_calloc(1, sizeof(struct pt2d), "pt2d struct");
d1178 1
a1178 1
		rt_calloc(1, sizeof(struct pt2d), "pt2d struct");
d2761 1
a2761 1
		rt_free((char *)tp, "trapezoid free");
d2766 1
a2766 1
		rt_free((char *)pt, "pt2d free");
d2768 1
a2768 1
	rt_free((char *)tbl2d, "discard tbl2d");
@


11.17
log
@Neatened up output blather
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_tri.c,v 11.16 1998/01/29 15:57:18 jra Exp $ (ARL)";
d997 1
a997 1
	new_trap = (struct trap *)rt_calloc(sizeof(struct trap), 2, "New hole start trapezoids");
d1005 1
a1005 1
	new_trap++;
@


11.16
log
@Added some debug messages.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.15 1997/08/15 19:25:30 jra Exp jra $ (ARL)";
d1772 2
a1773 1
			bu_log("parent loops are not the same %s %d,\n\ttrying join ", __FILE__, __LINE__);
@


11.15
log
@Added debug logging, added code to avoid having a hole start as the first point in
a faces scan line sorted vertex list, use nmg_loop_split_at_touching_jaunt() whenever
spiltting a loop with a touching jaunt.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.14 1997/06/23 13:27:33 jra Exp jra $ (ARL)";
d2172 8
@


11.14
log
@Added a call to nmg_model_edge_g_fuse() at the start of nmg_triangulate_model()
Changed macros for comparing 2D points in scanline order to use a tolerance.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.13 1997/06/19 22:27:11 jra Exp $ (ARL)";
d1966 1
d1968 4
a1971 2
	bu_log("Joining two loops that share a vertex at (%g %g %g)\n",
			V3ARGS(p1->vu_p->v_p->vg_p->coord) );
d1973 5
a1977 1

d2148 1
d2215 26
a2240 3
				if (rt_g.NMG_debug & DEBUG_TRI)
					bu_log("splitting self-touching loop at (%g %g %g)\n",
					V3ARGS(tp->bot->vu_p->v_p->vg_p->coord) );
d2242 2
a2243 1
				nmg_split_touchingloops(toplu, tol);
d2247 11
d2264 12
d2328 12
d2449 5
d2455 5
d2639 6
d2646 12
d2689 10
@


11.13
log
@Added nmg_unbreak_region_edges() call to nmg_triangulate_model().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.12 1996/09/27 08:27:30 mike Exp jra $ (ARL)";
d38 1
d47 11
a58 1

d2568 1
a2568 1
			bu_log("\tpt2d %g %g\n", pt->coord[0], pt->coord[1]);
d2674 2
@


11.12
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.11 1996/09/06 17:43:33 jra Exp mike $ (ARL)";
d2663 2
@


11.11
log
@Minor mod to pick_edges() to handle short edges.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.10 1996/08/14 03:44:14 butler Exp jra $ (ARL)";
d52 2
a53 2
	if ( ! RT_LIST_PREV(rt_list, &(_p)->l) ) {\
		rt_log("%s %d bad prev pointer of trapezoid 0x%08x\n",\
d56 2
a57 2
	} else if (! RT_LIST_NEXT(rt_list, &(_p)->l) ) {\
		rt_log("%s %d bad next pointer of trapezoid 0x%08x\n",\
d70 1
a70 1
	struct rt_list	l;		/* scanline ordered list of points */
d77 1
a77 1
	struct rt_list	l;
d106 1
a106 1
	CONST struct rt_tol	*tol;
d132 1
a132 1
struct rt_list *tbl2d;
d139 2
a140 2
	pt_next = find_pt2d(tbl2d, (RT_LIST_PNEXT_CIRC(edgeuse, eu))->vu_p);
	rt_log("%s: 0x%08x %g %g -> %g %g\n", s, eu,
d149 1
a149 1
struct rt_list *tbl2d;
d154 1
a154 1
	rt_log("trap 0x%08x top pt2d: 0x%08x %g %g vu:0x%08x\n",
d160 1
a160 1
		rt_log("\t\tbot pt2d: 0x%08x %g %g vu:0x%08x\n",
d164 1
a164 1
		rt_log("\tbot (nil)\n");
d175 1
a175 1
struct rt_list *tbl2d, *tlist;
d180 2
a181 2
	rt_log("Trapezoid list start ----------\n");
	for (RT_LIST_FOR(tp, trap, tlist)) {
d185 1
a185 1
	rt_log("Trapezoid list end ----------\n");
d192 1
a192 1
struct rt_list *tbl2d;
d199 1
a199 1
	for (RT_LIST_FOR(p, pt2d, tbl2d)) {
d210 1
a210 1
struct rt_list *tbl2d;
d231 1
a231 1
	rt_log("\tplotting %s\n", name);
d246 1
a246 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
d248 4
a251 4
		if ( RT_LIST_IS_EMPTY(&lu->down_hd) ) {
			rt_log("Empty child list for loopuse %s %d\n", __FILE__, __LINE__);
		} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC){
			vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d261 1
a261 1
			eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
d264 1
a264 1
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d291 1
a291 1
struct rt_list *tbl;
d306 1
a306 1
			eu_other = RT_LIST_PPREV_CIRC(edgeuse, eu);
d308 1
a308 1
			eu_other = RT_LIST_PNEXT_CIRC(edgeuse, eu);
d313 1
a313 1
				rt_log("can't find prev of %g %g\n",
d317 1
a317 1
				rt_log("can't find next of %g %g\n",
d327 1
a327 1
		rt_log("%s %d Bad vertexuse parent (%g %g %g)\n",
d345 1
a345 1
struct rt_list *tbl2d;
d365 1
a365 1
	RT_LIST_MAGIC_SET(&np->l, NMG_PT2D_MAGIC);
d368 1
a368 1
	for (RT_LIST_FOR(vu_p, vertexuse, &vu->v_p->vu_hd)) {
d380 1
a380 1
	if (rt_g.NMG_debug & DEBUG_TRI && flatten_debug) rt_log(
d385 1
a385 1
	for ( RT_LIST_FOR(p, pt2d, tbl2d) ) {
d389 1
a389 1
	RT_LIST_INSERT(&p->l, &np->l);
d392 1
a392 1
		rt_log("transforming other vertexuses...\n");
d399 1
a399 1
	for (RT_LIST_FOR(vu_p, vertexuse, &vp->vu_hd)) {
d411 1
a411 1
			rt_log("transform 0x%x... ", vu_p);
d416 1
a416 1
				rt_log("vertexuse already transformed\n", vu);
d426 1
a426 1
		RT_LIST_MAGIC_SET(&p->l, NMG_PT2D_MAGIC);
d428 1
a428 1
		RT_LIST_APPEND(&np->l, &p->l);
d431 1
a431 1
			(void)rt_log( "vertexuse transformed\n");
d434 1
a434 1
		(void)rt_log( "Done.\n");
d452 1
a452 1
struct rt_list *
d458 1
a458 1
	struct rt_list *tbl2d;
d466 1
a466 1
	tbl2d = (struct rt_list *)rt_calloc(1, sizeof(struct rt_list),
d474 2
a475 2
	RT_LIST_INIT( tbl2d );
	RT_LIST_MAGIC_SET(tbl2d, NMG_TBL2D_MAGIC);
d486 1
a486 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
d489 6
a494 6
			case OT_NONE:	rt_log("flattening OT_NONE loop\n"); break;
			case OT_SAME:	rt_log("flattening OT_SAME loop\n"); break;
			case OT_OPPOSITE:rt_log("flattening OT_OPPOSITE loop\n"); break;
			case OT_UNSPEC:	rt_log("flattening OT_UNSPEC loop\n"); break;
			case OT_BOOLPLACE:rt_log("flattening OT_BOOLPLACE loop\n"); break;
			default: rt_log("flattening bad orientation loop\n"); break;
d497 2
a498 2
		if (RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC) {
			vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d500 1
a500 1
				rt_log("vertex loop\n");
d503 1
a503 1
		} else if (RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC) {
d505 2
a506 2
				rt_log("edge loop\n");
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d509 1
a509 1
					rt_log("(%g %g %g) -> (%g %g %g)\n",
d525 1
a525 1
CONST struct rt_tol *tol;
d547 1
a547 1
	angle = rt_angle_measure( bc, ab, pv );
d550 1
a550 1
		rt_log("\tangle == %g tol angle: %g\n", angle, tol->perp);
d583 2
a584 2
struct rt_list *tbl2d;
CONST struct rt_tol *tol;
d623 1
a623 1
				rt_log("%s: %d loopuse is not OT_SAME or OT_OPPOSITE\n",
d649 1
a649 1
				rt_log("%s: %d loopuse is not OT_SAME or OT_OPPOSITE\n",
d673 1
a673 1
	rt_log(
d695 1
a695 1
struct rt_list *tbl2d, *tlist;
d702 1
a702 1
		rt_log( "%g %g is polygon start vertex\n",
d709 2
a710 2
	new_trap->e_right = RT_LIST_PLAST_CIRC(edgeuse, pt->vu_p->up.eu_p);
	RT_LIST_MAGIC_SET(&new_trap->l, NMG_TRAP_MAGIC);
d713 1
a713 1
	RT_LIST_APPEND(tlist, &new_trap->l);
d731 1
a731 1
struct rt_list *tlist;
d742 1
a742 1
		rt_log( "%g %g is polygon side vertex\n",
d744 1
a744 1
		rt_log( "%g %g -> %g %g -> %g %g\n",
d770 1
a770 1
	for (RT_LIST_FOR(tp, trap, tlist)) {
d780 1
a780 1
	if (RT_LIST_MAGIC_WRONG(&tp->l, NMG_TRAP_MAGIC))
d788 1
a788 1
	RT_LIST_MAGIC_SET(&new_trap->l, NMG_TRAP_MAGIC);
d800 1
a800 1
	RT_LIST_INSERT(tlist, &new_trap->l);
d817 1
a817 1
struct rt_list *tbl2d, *tlist;
d826 1
a826 1
		rt_log( "%g %g is polygon end vertex\n",
d840 1
a840 1
	for (RT_LIST_FOR(tp, trap, tlist)) {
d880 1
a880 1
struct rt_list *tlist, *tbl2d;
d889 1
a889 1
		rt_log( "%g %g is hole start vertex\n", 
d895 1
a895 1
	for (RT_LIST_FOR(tp, trap, tlist)) {
d902 1
a902 1
				rt_log("Trapezoid %g %g / %g %g completed... Skipping\n",
d917 1
a917 1
			(RT_LIST_PNEXT_CIRC(edgeuse, tp->e_left))->vu_p);
d929 1
a929 1
			(RT_LIST_PNEXT_CIRC(edgeuse, tp->e_right))->vu_p);
d947 1
a947 1
			(RT_LIST_PNEXT_CIRC(edgeuse, tp->e_left))->vu_p);
d953 1
a953 1
				rt_log("Continue #1\n");
d959 1
a959 1
			(RT_LIST_PNEXT_CIRC(edgeuse, tp->e_right))->vu_p);
d965 1
a965 1
				rt_log("Continue #2\n");
d977 1
a977 1
	rt_log("didn't find trapezoid for hole-start point at:\n\t%g %g %g\n",
d990 3
a992 3
	new_trap->e_right = RT_LIST_PLAST_CIRC(edgeuse, pt->vu_p->up.eu_p);
	RT_LIST_MAGIC_SET(&new_trap->l, NMG_TRAP_MAGIC);
	RT_LIST_APPEND(&tp->l, &new_trap->l);
d999 2
a1000 2
	RT_LIST_MAGIC_SET(&new_trap->l, NMG_TRAP_MAGIC);
	RT_LIST_APPEND(&tp->l, &new_trap->l);
d1019 1
a1019 1
struct rt_list *tlist, *tbl2d;
d1027 1
a1027 1
		rt_log( "%g %g is hole end vertex\n",
d1032 1
a1032 1
	euprev = RT_LIST_PLAST_CIRC(edgeuse, eunext);
d1040 1
a1040 1
	for (RT_LIST_FOR(tp, trap, tlist)) {
d1051 1
a1051 1
				rt_log("Completed... Skipping\n");
d1062 1
a1062 1
				rt_log("Found tpnext\n");
d1068 1
a1068 1
				rt_log("Found tpprev\n");
d1098 2
a1099 2
	RT_LIST_MAGIC_SET(&tp->l, NMG_TRAP_MAGIC);
	RT_LIST_APPEND(&tpprev->l, &tp->l);
d1111 2
a1112 2
struct rt_list *tbl2d, *tlist;
CONST struct rt_tol *tol;
d1118 1
a1118 1
	for (RT_LIST_FOR(pt, pt2d, tbl2d)) {
d1137 1
a1137 1
			rt_log( "%g %g is UNKNOWN type vertex %s %d\n",
d1149 1
a1149 1
struct rt_list *tbl2d;
d1161 1
a1161 1
		    rt_log("%s %d map_new_vertexuse() vertexuse already mapped!\n",
d1170 1
a1170 1
	for ( RT_LIST_FOR(vu, vertexuse, &vu_p->v_p->vu_hd) ) {
d1178 2
a1179 2
		RT_LIST_MAGIC_SET(&new_pt2d->l, NMG_PT2D_MAGIC);
		RT_LIST_APPEND(&p->l, &new_pt2d->l);
d1199 1
a1199 1
CONST struct rt_tol	*tol;
d1211 1
a1211 1
		rt_log("\t    pick_edges(v:(%g %g %g) dir:(%g %g %g))\n",
d1224 1
a1224 1
	for (RT_LIST_FOR(vu, vertexuse, &v->vu_hd)) {
d1235 1
a1235 1
				rt_log("\t\tskipping irrelevant vertexuse\n");
d1242 1
a1242 1
		eu_next = RT_LIST_PNEXT_CIRC(edgeuse, vu->up.eu_p);
d1253 1
a1253 1
			rt_log("\t\tchecking forward edgeuse to %g %g %g\n",
d1259 1
a1259 1
					rt_log("\t\t\teu_dir %g %g %g\n",
d1262 1
a1262 1
					rt_log("\t\t\tnew_last/max 0x%08x %g %g %g -> %g %g %g vdot %g\n",
d1274 2
a1275 2
					rt_log("\t\t\teu_dir %g %g %g\n", V3ARGS(eu_dir));
					rt_log("\t\t\tnew_first/min 0x%08x %g %g %g -> %g %g %g vdot %g\n",
d1293 1
a1293 1
		eu_last = RT_LIST_PLAST_CIRC(edgeuse, vu->up.eu_p);
d1307 1
a1307 1
			rt_log("\t\tchecking reverse edgeuse to %g %g %g\n",
d1313 1
a1313 1
					rt_log("\t\t\t-eu_dir %g %g %g\n", 
d1315 1
a1315 1
					rt_log("\t\t\tnew_last/max 0x%08x %g %g %g <- %g %g %g vdot %g\n",
d1327 2
a1328 2
					rt_log("\t\t\teu_dir %g %g %g\n", V3ARGS(eu_dir));
					rt_log("\t\t\tnew_first/min 0x%08x %g %g %g <- %g %g %g vdot %g\n",
d1366 1
a1366 1
		rt_log("\t    pick_eu(%g %g %g  <-> %g %g %g, dir:%g %g %g,  %s)\n",
d1379 1
a1379 1
			eu_next = RT_LIST_PNEXT_CIRC(edgeuse, eu);
d1386 1
a1386 1
				rt_log("%s %d: edgeuse no longer in faceuse?\n", __FILE__, __LINE__);
d1393 1
a1393 1
				rt_log("\t\tchecking: %g %g %g -> %g %g %g left vdot:%g\n",
d1407 1
a1407 1
						rt_log("\t\tnew max\n");
d1414 1
a1414 1
						rt_log("\t\tnew min\n");
d1426 1
a1426 1
		rt_log("\t\tpick_eu() returns %g %g %g -> %g %g %g\n\t\t\tbecause vdot(left) = %g\n",
d1471 1
a1471 1
CONST struct rt_tol	*tol;
d1480 1
a1480 1
		rt_log("%s: %d first_vu is null ptr\n", __FILE__, __LINE__);
d1484 1
a1484 1
		rt_log("%s: %d last_vu is null ptr\n", __FILE__, __LINE__);
d1491 1
a1491 1
		rt_log("\t  nmg_find_first(v:(%g %g %g) dir:(%g %g %g))\n",
d1516 1
a1516 1
		eu_p = RT_LIST_PLAST_CIRC(edgeuse, vu_first->up.eu_p);
d1536 1
a1536 1
		rt_log("\t   first_eu: %g %g %g -> %g %g %g\n",
d1557 1
a1557 1
			eu_p = RT_LIST_PNEXT_CIRC(edgeuse, eu_first);
d1562 1
a1562 1
			rt_log("I got eu_first: %g %g %g -> %g %g %g but...\n",
d1573 1
a1573 1
		eu_p = RT_LIST_PLAST_CIRC(edgeuse, vu_last->up.eu_p);
d1592 1
a1592 1
		rt_log("\t   last_eu: %g %g %g -> %g %g %g\n",
d1614 1
a1614 1
			eu_p = RT_LIST_PNEXT_CIRC(edgeuse, eu_last);
d1619 1
a1619 1
			rt_log("I got eu_last: %g %g %g -> %g %g %g but...\n",
d1633 1
a1633 1
struct rt_list *tbl2d;
d1635 1
a1635 1
CONST struct rt_tol *tol;
d1644 1
a1644 1
		rt_log("\tpick_pt2d_for_cutjoin()\n");
d1646 1
a1646 1
	RT_CK_TOL(tol);
d1668 1
a1668 1
		rt_log("%s: %d no faceuse parent of vu\n", __FILE__, __LINE__);
d1687 1
a1687 1
		rt_log("\tp1 pick %g %g -> %g %g (first)\n\t\t%g %g -> %g %g (last)\n",
d1707 1
a1707 1
		rt_log("\tp2 pick %g %g -> %g %g (first)\n\t\t%g %g -> %g %g (last)\n",
d1730 1
a1730 1
struct rt_list *tbl2d;
d1733 1
a1733 1
CONST struct rt_tol	*tol;
d1741 1
a1741 1
	RT_CK_TOL(tol);
d1748 1
a1748 1
		rt_log("\tcutting loop @@ %g %g -> %g %g\n",
d1753 1
a1753 1
		rt_log("parent loops are not the same %s %d\n", __FILE__, __LINE__);
d1761 1
a1761 1
			rt_log("parent loops are not the same %s %d,\n\ttrying join ", __FILE__, __LINE__);
d1771 1
a1771 1
			rt_log("parent loops are not the same %s %d\n",
d1822 1
a1822 1
	eu = RT_LIST_PPREV_CIRC(edgeuse, &new_lu->down_hd);
d1846 1
a1846 1
		for( RT_LIST_FOR( vu , vertexuse , &p1->vu_p->v_p->vu_hd ) )
d1882 1
a1882 1
		for( RT_LIST_FOR( vu , vertexuse , &p2->vu_p->v_p->vu_hd ) )
d1908 1
a1908 1
	eu = RT_LIST_PPREV_CIRC( edgeuse, &(p1->vu_p->up.eu_p->l));
d1919 1
a1919 1
struct rt_list *tbl2d;
d1922 1
a1922 1
CONST struct rt_tol	*tol;
d1932 1
a1932 1
	RT_CK_TOL(tol);
d1941 1
a1941 1
		rt_log("join_mapped_loops()\n");
d1945 1
a1945 1
		rt_log("%s %d: Attempting to join loop to itself at (%g %g %g)?\n",
d1950 1
a1950 1
		rt_log("parent loops are the same %s %d\n", __FILE__, __LINE__);
d1956 1
a1956 1
	rt_log("Joining two loops that share a vertex at (%g %g %g)\n",
d1971 1
a1971 1
		rt_log("%s: %d I'm a fool...\n\ttrying to join a vertexuse (%g %g %g) to itself\n",
d1976 1
a1976 1
			rt_log("parent loops are the same %s %d\n",
d1995 1
a1995 1
	eu = RT_LIST_PPREV_CIRC(edgeuse, vu2->up.eu_p);
d2002 2
a2003 2
    		pr1_eu = RT_LIST_PNEXT_CIRC(edgeuse, vu1->up.eu_p);
    		pr2_eu = RT_LIST_PNEXT_CIRC(edgeuse, vu2->up.eu_p);
d2005 1
a2005 1
    		rt_log("joining loops between:\n\t%g %g %g -> (%g %g %g)\n\tand%g %g %g -> (%g %g %g)\n",
d2033 1
a2033 1
	for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d2044 1
a2044 1
struct rt_list *tbl2d;
d2079 1
a2079 1
	for (RT_LIST_FOR(vu, vertexuse, &v->vu_hd)) {
d2086 1
a2086 1
			rt_log("NULL vertexuse up %s %d\n",
d2092 1
a2092 1
		eu_next = RT_LIST_PNEXT_CIRC(edgeuse, eu);
d2101 1
a2101 1
	for (RT_LIST_FOR(vu, vertexuse, &v->vu_hd)) {
d2108 1
a2108 1
			rt_log("NULL vertexuse up %s %d\n",
d2114 1
a2114 1
		eu_next = RT_LIST_PNEXT_CIRC(edgeuse, eu);
d2125 1
a2125 1
struct rt_list *tbl2d, *tlist;
d2127 1
a2127 1
CONST struct rt_tol	*tol;
d2139 1
a2139 1
	RT_CK_TOL(tol);
d2142 1
a2142 1
	for (RT_LIST_FOR(tp, trap, tlist)) {
d2152 1
a2152 1
			rt_log( "tp->top and/or tp->bot is/are NULL!!!!!!!\n" );
d2158 1
a2158 1
				rt_log("skipping %g %g/%g %g ... edge exists\n",
d2169 1
a2169 1
				rt_log("skipping %g %g/%g %g ... pts on same edge\n",
d2178 1
a2178 1
			rt_log("trying to cut ...\n");
d2197 1
a2197 1
					rt_log("splitting self-touching loop at (%g %g %g)\n",
d2201 1
a2201 1
				for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))
d2231 1
a2231 1
				for (RT_LIST_FOR(trp, trap, tlist)) {
d2254 1
a2254 1
				rt_log("joining 2 loops @@ %g %g -> %g %g\n",
d2279 1
a2279 1
struct rt_list *tbl2d, *tlist;
d2281 1
a2281 1
CONST struct rt_tol *tol;
d2291 1
a2291 1
	RT_CK_TOL(tol);
d2295 1
a2295 1
		rt_log("cutting unimonotone:\n");
d2300 1
a2300 1
	for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d2303 1
a2303 1
			rt_log("why can't I find a 2D point for %g %g %g?\n",
d2309 1
a2309 1
			rt_log("%g %g\n", new->coord[X], new->coord[Y]);
d2328 1
a2328 1
		rt_log("is this a unimonotone loop of just 2 points?:\t%g %g %g and %g %g %g?\n",
d2337 1
a2337 1
		rt_log("%d verts in unimonotone, Min: %g %g  Max: %g %g first:%g %g 0x%08x\n", verts,
d2349 1
a2349 1
			rt_log( "Cut_unimontone is in an infinite loop!!!\n" );
d2357 1
a2357 1
			rt_log("%g %g -> %g %g -> %g %g ...\n",
d2381 1
a2381 1
					rt_log("\tfirst(0x%08x -> %g %g\n", first, t->coord[X], t->coord[Y]);
d2385 1
a2385 1
					rt_log("\tcurrent(0x%08x) -> %g %g\n", current, t->coord[X], t->coord[Y]);
d2389 1
a2389 1
					rt_log("\tcurrent(0x%08x) -> %g %g\n", current, t->coord[X], t->coord[Y]);
d2393 1
a2393 1
				rt_log("\tConcave, moving ahead\n");
d2404 1
a2404 1
struct rt_list *tbl2d;
d2416 1
a2416 1
		rt_log( "cannot open triplot.pl\n");
d2428 2
a2429 2
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		if (RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC) {
d2432 1
a2432 1
			vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d2434 1
a2434 1
				rt_log( "lone vert @@ %g %g %g\n",
d2449 1
a2449 1
		for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd ) ) {
d2452 1
a2452 1
			eu_pnext = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);
d2456 1
a2456 1
				rt_log( "eu vert @@ %g %g %g\n",
d2486 1
a2486 1
CONST struct rt_tol	*tol;
d2489 1
a2489 1
	struct rt_list *tbl2d;
d2493 1
a2493 1
	struct rt_list tlist;
d2503 1
a2503 1
	RT_CK_TOL(tol);
d2508 1
a2508 1
		rt_log("---------------- Triangulate face %g %g %g\n",
d2514 1
a2514 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
d2517 1
a2517 1
				rt_log("faceuse has non-OT_SAME orientation loop\n");
d2521 1
a2521 1
		for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd ))
d2524 1
a2524 1
					rt_log("loop has more than 3 verticies\n");
d2530 1
a2530 1
		rt_log("---------------- face %g %g %g already triangular\n",
d2533 2
a2534 2
		for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd ))
d2544 1
a2544 1
		rt_log("---------------- proceeding to triangulate face %g %g %g\n", V3ARGS(N));
d2554 4
a2557 4
		rt_log( "Face Flattened\n");
		rt_log( "Vertex list:\n");
		for (RT_LIST_FOR(pt, pt2d, tbl2d)) {
			rt_log("\tpt2d %g %g\n", pt->coord[0], pt->coord[1]);
d2562 1
a2562 1
		rt_log( "Face plotted\n\tmaking trapezoids...\n");
d2566 1
a2566 1
	RT_LIST_INIT(&tlist);
d2572 1
a2572 1
		rt_log("Cutting diagonals ----------\n");
d2576 1
a2576 1
		rt_log("Diagonals are cut ----------\n");
d2585 1
a2585 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))
d2598 1
a2598 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
d2600 2
a2601 2
		if (RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC) {
			vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d2603 1
a2603 1
			rt_log("How did I miss this vertex loop %g %g %g?\n%s\n",
d2608 1
a2608 1
		} else if (RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC) {
d2610 1
a2610 1
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd )) {
d2628 1
a2628 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))
d2634 2
a2635 2
	while (RT_LIST_WHILE(tp, trap, &tlist)) {
		RT_LIST_DEQUEUE(&tp->l);
d2639 2
a2640 2
	while (RT_LIST_WHILE(pt, pt2d, tbl2d)) {
		RT_LIST_DEQUEUE(&pt->l);
d2651 1
a2651 1
CONST struct rt_tol   *tol;
d2657 1
a2657 1
	RT_CK_TOL(tol);
d2662 1
a2662 1
		rt_log("Triangulating NMG\n");
d2664 1
a2664 1
	for (RT_LIST_FOR(r, nmgregion, &m->r_hd)) {
d2666 1
a2666 1
		for (RT_LIST_FOR(s, shell, &r->s_hd)) {
d2670 1
a2670 1
			for (RT_LIST_FOR(fu, faceuse, &s->fu_hd)) {
d2680 1
a2680 1
		rt_log("Triangulation completed\n");
@


11.10
log
@checkpoint
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.9 1996/05/16 21:48:55 jra Exp butler $ (ARL)";
d1256 1
a1256 1
		if (eu_length_sq >= tol->dist_sq) {
d1310 1
a1310 1
		if (eu_length_sq >= tol->dist_sq) {
@


11.9
log
@Removed tolerance args from calls to nmg_lu_reorient() (no longer needed).
@
text
@d1 1
a1 2
/*
 *			N M G _ T R I . C
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.8 1996/04/24 22:14:13 butler Exp jra $ (ARL)";
d329 1
a329 3
			(pt)->vu_p->v_p->vg_p->coord[0],
			(pt)->vu_p->v_p->vg_p->coord[1],
			(pt)->vu_p->v_p->vg_p->coord[2]);
d978 1
a978 3
		pt->vu_p->v_p->vg_p->coord[0],
		pt->vu_p->v_p->vg_p->coord[1],
		pt->vu_p->v_p->vg_p->coord[2]);
d1254 1
a1254 3
				vu_next->v_p->vg_p->coord[0],
				vu_next->v_p->vg_p->coord[1],
				vu_next->v_p->vg_p->coord[2]);
d1259 3
a1261 1
					rt_log("\t\t\teu_dir %g %g %g\n", eu_dir[0], eu_dir[1], eu_dir[2]);
d1274 1
a1274 1
					rt_log("\t\t\teu_dir %g %g %g\n", eu_dir[0], eu_dir[1], eu_dir[2]);
d1308 1
a1308 3
				vu_prev->v_p->vg_p->coord[0],
				vu_prev->v_p->vg_p->coord[1],
				vu_prev->v_p->vg_p->coord[2]);
d1313 2
a1314 1
					rt_log("\t\t\t-eu_dir %g %g %g\n", eu_dir[0], eu_dir[1], eu_dir[2]);
d1327 1
a1327 1
					rt_log("\t\t\teu_dir %g %g %g\n", eu_dir[0], eu_dir[1], eu_dir[2]);
d1776 2
a1777 6
				p1->vu_p->v_p->vg_p->coord[0],
				p1->vu_p->v_p->vg_p->coord[1],
				p1->vu_p->v_p->vg_p->coord[2],
				p2->vu_p->v_p->vg_p->coord[0],
				p2->vu_p->v_p->vg_p->coord[1],
				p2->vu_p->v_p->vg_p->coord[2]);
d1805 1
a1805 1
		pl_color(plot_fd, color[0], color[1], color[2]);
d1942 2
d1947 1
a1947 3
			p1->vu_p->v_p->vg_p->coord[0],
			p1->vu_p->v_p->vg_p->coord[1],
			p1->vu_p->v_p->vg_p->coord[2]);
d1953 9
d1973 1
a1973 3
			p1->vu_p->v_p->vg_p->coord[0],
			p1->vu_p->v_p->vg_p->coord[1],
			p1->vu_p->v_p->vg_p->coord[2]);
d2014 1
a2014 1
		pl_color(plot_fd, color[0], color[1], color[2]);
d2198 1
a2198 3
					tp->bot->vu_p->v_p->vg_p->coord[0],
					tp->bot->vu_p->v_p->vg_p->coord[1],
					tp->bot->vu_p->v_p->vg_p->coord[2]);
d2304 1
a2304 3
			eu->vu_p->v_p->vg_p->coord[0],
			eu->vu_p->v_p->vg_p->coord[1],
			eu->vu_p->v_p->vg_p->coord[2]);
d2329 3
a2331 6
			min->vu_p->v_p->vg_p->coord[0],
			min->vu_p->v_p->vg_p->coord[1],
			min->vu_p->v_p->vg_p->coord[2],
			max->vu_p->v_p->vg_p->coord[0],
			max->vu_p->v_p->vg_p->coord[1],
			max->vu_p->v_p->vg_p->coord[2]);
d2435 2
a2436 3
					vu->v_p->vg_p->coord[0],
					vu->v_p->vg_p->coord[1],
					vu->v_p->vg_p->coord[2]);
d2457 2
a2458 3
					eu->vu_p->v_p->vg_p->coord[0],
					eu->vu_p->v_p->vg_p->coord[1],
					eu->vu_p->v_p->vg_p->coord[2]);
d2474 2
a2475 1
			pd_3move(plot_fd, p->coord[0], p->coord[1], p->coord[2]);
d2508 2
a2509 1
		rt_log("---------------- Triangulate face %g %g %g\n", N[0], N[1], N[2]);
d2531 1
a2531 1
			N[0], N[1], N[2]);
d2540 1
a2540 1
	triangulate:
d2544 1
a2544 1
		rt_log("---------------- proceeding to triangulate face %g %g %g\n", N[0], N[1], N[2]);
d2604 1
a2604 3
				vu->v_p->vg_p->coord[0],
				vu->v_p->vg_p->coord[1],
				vu->v_p->vg_p->coord[2],
@


11.8
log
@more debugging to figure out that it was a shared library problem.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.7 1996/04/23 14:53:30 jra Exp butler $ (ARL)";
d1827 2
a1828 2
	nmg_lu_reorient( old_lu, tol );
	nmg_lu_reorient( new_lu, tol );
d2207 1
a2207 1
					nmg_lu_reorient(lu, tol);
d2641 1
a2641 1
		nmg_lu_reorient(lu, tol);
@


11.7
log
@Added HACK to cut_unimonotone() to catch infinite loop.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.6 1996/04/18 18:46:01 jra Exp jra $ (ARL)";
d1922 5
d1950 2
d1966 5
d1999 15
@


11.6
log
@Added a check in cut_diagonals() for NULL pointers tp->top, tp->bot.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.5 1996/04/12 14:19:39 jra Exp jra $ (ARL)";
d2264 2
d2298 1
d2328 7
@


11.5
log
@nmg_find_first_last_use_of_v_in_fu() was setting rt_g.debug!!!!!!!!
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.4 1995/03/17 20:16:42 butler Exp jra $ (ARL)";
d2126 5
@


11.4
log
@added tolerance computation to is_convex()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.3 1995/02/15 22:38:37 mike Exp butler $ (ARL)";
a1481 2

	rt_g.debug = 1;
@


11.3
log
@Added a test, so that vu search would not be confused by wire edges.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.2 95/02/15 10:06:08 jra Exp Locker: mike $ (ARL)";
d189 1
a189 1
static int flatten_debug=0;
d383 2
a384 2
	if (flatten_debug) rt_log(
		"Transforming 0x%x old (%g, %g, %g) new (%g, %g, %g)\n",
d394 1
a394 1
	if (flatten_debug)
a407 3
		if (flatten_debug)
			rt_log("transform 0x%x... ", vu_p);

d411 4
a414 5
		if (fu_of_vu != fu) {
			if (flatten_debug)
				rt_log("vertexuse not in faceuse (That's OK)\n");
			continue;
		}
d418 1
a418 1
			if (flatten_debug) {
d433 1
a433 1
		if (flatten_debug)
d436 1
a436 1
	if (flatten_debug)
d484 1
a484 1
	if (flatten_debug)
d502 2
d507 2
d511 4
d526 1
a526 1
is_convex(a, b, c)
d528 1
d537 1
d540 1
d542 2
d546 1
d549 1
d553 1
a553 1
		rt_log("\tangle == %g\n", angle);
d555 1
a555 2
	/* XXX this should be a toleranced comparison */
	return (angle > SQRT_SMALL_FASTF && angle <= M_PI);
d584 1
a584 1
vtype2d(v, tbl2d)
d587 1
d632 1
a632 1
		if (is_convex(p, v, n)) return(POLY_END);
d658 1
a658 1
		if (is_convex(p, v, n))
d1115 1
a1115 1
nmg_trap_face(tbl2d, tlist)
d1117 1
d1125 1
a1125 1
		switch(vtype2d(pt, tbl2d)) {
d2294 3
a2296 1
	/* pick the pt which does NOT have the other as a "next" pt in loop */
d2335 1
a2335 1
		if (is_convex(prev, current, next)) {
d2487 1
a2487 1
				rt_log("faceus has non-OT_SAME orientation loop\n");
d2514 1
a2514 1
		rt_log("---------------- Triangulate face %g %g %g\n", N[0], N[1], N[2]);
d2537 1
a2537 1
	nmg_trap_face(tbl2d, &tlist);
@


11.2
log
@pick_edges was comparing the length of a unitized eu_dir with tol->dist_sq.
I created eu_length_sq to be compared instead.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 11.1 95/01/04 09:58:18 mike Rel4_4 Locker: jra $ (ARL)";
d412 1
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 1.48 94/12/27 16:07:51 mike Exp $ (ARL)";
d1200 1
d1241 1
d1250 1
a1250 1
		if (MAGSQ(eu_dir) >= tol->dist_sq) {
d1295 1
d1304 1
a1304 1
		if (MAGSQ(eu_dir) >= tol->dist_sq) {
@


1.48
log
@Added if (rt_g.NMG_debug & DEBUG_TRI) check in front of
parent loops are the same message.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 1.47 94/12/27 11:30:47 jra Exp Locker: mike $ (ARL)";
@


1.47
log
@Added code to copy vertexuse normals when a loop is cut.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 1.46 94/12/20 15:46:48 jra Exp Locker: jra $ (ARL)";
d1952 4
a1955 2
		rt_log("parent loops are the same %s %d\n",
			__FILE__, __LINE__);
@


1.46
log
@mods for CRAY.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 1.45 94/12/05 19:03:03 butler Exp $ (ARL)";
d1820 76
@


1.45
log
@conditionalized debugging output
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 1.44 1994/11/10 15:33:46 jra Exp butler $ (ARL)";
d730 2
a731 2
	pnext = PT2D_NEXT(tbl2d, pt);
	plast = PT2D_PREV(tbl2d, pt);
d1114 1
a1114 1
			poly_side_vertex(pt, tbl2d, tlist);
d1191 1
a1191 1
struct rt_tol	*tol;
d1461 1
a1461 1
struct rt_tol	*tol;
d1724 1
a1724 1
int color[3];
d1836 1
a1836 1
int color[3];
a2167 1
	static CONST int join_color[3] = { 190, 255, 190};
@


1.44
log
@undid change from revision 1.43, that wan't the right way.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 1.43 94/11/10 15:01:30 jra Exp Locker: jra $ (ARL)";
d2538 3
a2540 1
	rt_log("Triangulating NMG\n");
d2555 3
a2557 1
	rt_log("Triangulation completed\n");
@


1.43
log
@Added "nmg_loop_g( old_lu, tol)" to "cut_mapped_loop".
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 1.42 94/11/08 04:01:08 mike Exp $ (ARL)";
a1810 1
	nmg_loop_g(old_lu->l_p, tol);
@


1.42
log
@Irix 6
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 1.41 94/11/08 03:56:41 mike Exp Locker: mike $ (ARL)";
d1811 1
@


1.41
log
@Lee added an extra print
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 1.40 1994/10/12 03:36:29 butler Exp butler $ (ARL)";
a151 1
	struct pt2d *pt, *pt_next;
a178 1
	struct pt2d *pt, *pt_next;
a351 1
	point_t	pt;
a354 1
	struct edgeuse *eu;
a577 1
	struct edgeuse *eu;
a688 1
	struct edgeuse *eu;
a1730 3
	struct vertexuse *vu;
	struct vertex *v;
	struct pt2d *new_pt2d, *p;
a1731 1

a2013 2
	struct pt2d *top_next, *bot_next;
	struct pt2d *top, *bot;
a2020 1
	struct faceuse *fu_p;
a2055 3
		top = tp->top;
		bot = tp->bot;

a2070 2
			struct loopuse *new_lu;
			register struct pt2d *bot_next;
a2071 1

d2164 1
a2164 1
	struct pt2d *min, *max, *new, *first, *prev, *next, *current, *save;
@


1.40
log
@More debugging info on faces, less debugging info on trapezoids being filled.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 1.39 1994/09/30 22:15:36 butler Exp $ (ARL)";
d2555 1
d2571 2
a2572 1

@


1.39
log
@#if 0'd out some old code.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 1.38 1994/09/24 07:26:43 butler Exp butler $ (ARL)";
d497 10
a1044 2
		if (rt_g.NMG_debug & DEBUG_TRI)
			print_trap(tp, tbl2d);
d1047 3
a1049 1
			if (rt_g.NMG_debug & DEBUG_TRI)
d1051 2
d1054 3
d2394 1
d2401 6
d2409 3
a2411 1
		if (lu->orientation != OT_SAME)
d2413 1
a2413 1

d2416 5
a2420 1
			if (++vert_count > 3) goto triangulate;
a2423 2
		vect_t N;
		NMG_GET_FU_NORMAL(N, fu);
@


1.38
log
@extra debugging output
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 1.37 1994/09/24 05:40:11 butler Exp butler $ (ARL)";
d156 2
a157 1
	rt_log("trap top pt2d: 0x%08x %g %g vu:0x%08x\n",
d162 1
a162 1
		rt_log("     bot pt2d: 0x%08x %g %g vu:0x%08x\n",
d170 1
a170 1
		print_2d_eu("       e_left", tp->e_left, tbl2d);
d173 1
a173 1
		print_2d_eu("      e_right", tp->e_right, tbl2d);
d2097 1
d2127 1
a2127 1

@


1.37
log
@now triangulates triangular faces with triangular holes
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_tri.c,v 1.36 1994/09/16 20:52:59 mike Exp butler $ (ARL)";
d2147 1
a2147 1
		if (rt_g.NMG_debug & DEBUG_TRI)		
d2149 2
@


1.36
log
@Eliminated edge_g crutch.
They are now explicitly edge_g_lseg.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d2383 3
d2391 11
@


1.35
log
@added informational message "Triangulating NMG" for user
@
text
@d1 4
a4 1
/*	N M G _ T R I . C --- Triangulate the faces of a polygonal NMG
d6 15
d22 4
d97 1
a97 1
	struct edge_g		*eg_p;		/* Edge geom of the ray */
@


1.34
log
@Added missing #define
@
text
@d2490 1
@


1.33
log
@Removed unnecessary include
@
text
@d12 3
a14 1

@


1.32
log
@Added GDurf's new "conf.h"
@
text
@a5 4
#if !defined(convex) && !defined(__convex__)
/* XXX What on earth is this? */
#include <values.h>
#endif
@


1.31
log
@OK, we can now do r409 of the bradley.g test
@
text
@d4 1
d6 2
d9 1
@


1.30
log
@better debugging output
@
text
@d1207 1
d1209 5
a1213 1
			rt_log("\t\tchecking forward edgeuse\n");
a1243 2
		if (rt_g.NMG_debug & DEBUG_TRI)
			rt_log("\t\tchecking reverse edgeuse\n");
d1245 3
d1260 7
d1271 1
a1271 1
					rt_log("\t\t\tnew_max 0x%08x %g %g %g <- %g %g %g vdot %g\n",
d1284 1
a1284 1
					rt_log("\t\t\tnew_min 0x%08x %g %g %g <- %g %g %g vdot %g\n",
d1341 4
a1344 1
			VCROSS(left, fu->f_p->fg_p->N, eu_vect);
d1730 2
d1736 1
a1736 1
			sprintf(name, "bad_tri_cut%d.g", iter++);
d1745 1
a1745 1
			nmg_stash_model_to_file( name, 
d1747 19
d2356 17
@


1.29
log
@another day, another bug.  But is that added or fixed?
@
text
@d1789 5
a1793 2
		rt_log("%s %d: Attempting to join loop to itself?\n",
			__FILE__, __LINE__);
d1803 5
a1807 2
		rt_log("%s: %d I'm a fool trying to join a vertexuse to itself\n",
			__FILE__, __LINE__);
@


1.28
log
@Got it to do Test16.r
@
text
@d132 1
a132 1
	rt_log("trap top pt2d:0x%08x %g %g vu:0x%08x\n",
d137 1
a137 1
		rt_log("\tbot pt2d:0x%08x %g %g vu:0x%08x\n",
d145 1
a145 1
		print_2d_eu("\te_left", tp->e_left, tbl2d);
d148 1
a148 1
		print_2d_eu("\te_right", tp->e_right, tbl2d);
d557 3
a567 2
	lu = nmg_find_lu_of_vu( v->vu_p );

d578 12
d603 13
d864 5
a868 1
				rt_log("Trapezoid completed... Skipping\n");
d872 26
d935 10
a944 1
	rt_bomb("didn't find trapezoid for hole-start point\n");
d1710 20
a1730 2
		rt_log("parent loops are not the same %s %d\n", __FILE__, __LINE__);
		rt_bomb("cut_mapped_loop() goodnight 2\n");
d1745 1
a1745 1
/* XXX Does anyone care about loopuse orientations at this stage?
d1748 2
a1749 1
 */
d1788 5
a1792 1
	if (p1->vu_p->up.eu_p->up.lu_p == p2->vu_p->up.eu_p->up.lu_p) {
d1797 1
a1797 1
	pick_pt2d_for_cutjoin(tbl2d, &p1, &p2, tol);	
d1799 6
a1804 2
	if (p1->vu_p->up.eu_p->up.lu_p == p2->vu_p->up.eu_p->up.lu_p) {
		rt_log("parent loops are the same %s %d\n", __FILE__, __LINE__);
d1974 2
d2060 1
a2063 1
			/* XXX This is un-tested */
d2115 7
a2121 1
		if (!new) rt_bomb("why can't I find this?\n");
d2139 10
a2148 2
	else 
		rt_bomb("is this a loop of just 2 points?\n");
d2223 2
a2224 2
	if (!plot_fd && (plot_fd = popen("pl-fb", "w")) == (FILE *)NULL) {
		rt_log( "cannot open pipe\n");
d2301 1
d2306 2
d2309 2
d2344 7
a2350 1
	
d2354 7
a2360 3
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))
		nmg_lu_reorient(lu, tol);

d2367 9
a2375 1
			rt_bomb("How did I miss this?\n");
d2381 8
d2395 3
@


1.27
log
@debugging changes
@
text
@d305 5
a309 1
		rt_log("%s %d Bad vertexuse parent\n", __FILE__, __LINE__);
d1541 3
a1543 1
	VPRINT("\t\tdir", dir);
d1757 17
d1775 3
d1779 63
d1843 1
a1843 1
cut_diagonals(tbl2d, tlist, tol)
d1845 1
d1857 2
d1869 5
a1873 8
		top = tp->top;
		bot = tp->bot;

		top_next = PT2D_NEXT(tbl2d, top);
		bot_next = PT2D_NEXT(tbl2d, bot);

		if (top_next == tp->bot || bot_next == tp->top ||
		    top_next == bot || bot_next == top) {
d1875 1
a1875 1
				rt_log("skipping %g %g/%g %g because pts on same edge\n",
d1882 9
d1892 3
a1899 5
/*		pick_pt2d_for_cutjoin(tbl2d, &top, &bot, tol);

		if (rt_g.NMG_debug & DEBUG_TRI)
			rt_log("....postulated\n"); */

d1902 4
a1905 4
		toplu = nmg_find_lu_of_vu(top->vu_p);
		botlu = nmg_find_lu_of_vu(bot->vu_p);
		NMG_CK_VERTEXUSE(top->vu_p);
		NMG_CK_VERTEXUSE(bot->vu_p);
a1912 1
			/* points are in same loop.  Cut the loop */
d1914 2
a1915 1
			(void)cut_mapped_loop(tbl2d, top, bot, cut_color, tol, 1);
d1917 18
d1982 1
a1982 1
			join_mapped_loops(tbl2d, top, bot, join_color, tol);
d2227 1
a2227 1
	cut_diagonals(tbl2d, &tlist,tol);
d2231 6
@


1.26
log
@Called nmg_loop_g() after cutting loops.
Moved call to nmg_s_split_touchingloops() up a level.
@
text
@d225 4
a228 1
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC){
d238 4
a241 1
		} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC){
a251 2
		} else {
			rt_bomb("bogus loopuse child\n");
@


1.25
log
@Added magic number and related checking to tbl2d.  A couple of RT_LIST_PREV()
calls became RT_LIST_PPREV_CIRC().  Ported to the ancient complier that Sun
ships with SunOS 4.1.3.
@
text
@d1649 2
a2081 1
	nmg_s_split_touchingloops(fu->s_p, tol);
d2166 2
@


1.24
log
@Successfully ran the zigzag test
@
text
@d24 1
d39 3
d112 1
a112 1

d129 1
a129 1

d156 1
d174 1
d190 1
a190 1
	static int fileno=0;
d199 2
a200 1
	
d203 1
a203 1
	sprintf(name, "tri%02d.pl", fileno++);
d272 1
d328 1
d434 1
a434 1
	CONST vect_t twoDspace = { 0.0, 0.0, 1.0 };
d452 1
d542 1
d627 1
d665 1
d751 1
d814 1
d915 1
d1001 2
d1040 1
d1510 2
d1611 1
d1650 1
a1650 1
	/* XXX Does anyone care about loopuse orientations at this stage?
d1655 1
a1655 1
	eu = RT_LIST_PREV(edgeuse, &new_lu->down_hd);
d1665 1
a1665 1
	eu = RT_LIST_PREV( edgeuse, &(p1->vu_p->up.eu_p->l));
d1681 1
d1756 2
a1757 2
	int cut_color[3] = {255, 80, 80};
	int join_color[3] = {80, 80, 255};
d1762 1
d1779 2
a1780 1
			rt_log("skipping %g %g/%g %g because pts on same edge\n",
d1886 2
a1887 2
	int cut_color[3] = { 90, 255, 90};
	int join_color[3] = { 190, 255, 190};
d1889 1
d1992 1
@


1.23
log
@minor fix to get it to compile
@
text
@d2 1
a2 1
 *
a11 1
#define	tri_debug	&
d13 1
d491 1
a491 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d617 1
a617 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d656 1
a656 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI) {
d739 1
a739 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d801 1
a801 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d814 1
a814 1
			if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d835 1
a835 1
			if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d847 1
a847 1
			if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d901 1
a901 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d910 1
a910 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI) {
d921 1
a921 1
		if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d925 1
a925 1
			if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d931 1
a931 1
			if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d937 1
a937 1
			if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d1026 1
a1026 1
		if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d1054 4
d1060 1
a1060 1
pick_edges(v, vu_max, vu_min, fu, max_dir, min_dir, tol, dir)
d1062 1
a1062 1
struct vertexuse **vu_max, **vu_min;
d1070 1
a1070 1
	struct vertexuse *vu_next, *vu_last;
d1075 2
a1076 2
	if (rt_g.NMG_debug tri_debug DEBUG_TRI)
		rt_log("pick_edges(v:(%g %g %g) dir:(%g %g %g))\n",
d1088 1
a1088 1
	*vu_max = *vu_min = (struct vertexuse *)NULL;
d1099 2
a1100 2
			if (rt_g.NMG_debug tri_debug DEBUG_TRI)
				rt_log("skipping irrelevant vertexuse\n");
d1115 2
a1116 2
		if (rt_g.NMG_debug tri_debug DEBUG_TRI)
			rt_log("checking forward edgeuse\n");
d1119 3
a1121 3
				if (rt_g.NMG_debug tri_debug DEBUG_TRI) {
					rt_log("\teu_dir %g %g %g\n", eu_dir[0], eu_dir[1], eu_dir[2]);
					rt_log("\tnew_last/max 0x%08x %g %g %g -> %g %g %g vdot %g\n",
d1128 1
a1128 1
				*vu_max = vu;
d1132 3
a1134 3
				if (rt_g.NMG_debug tri_debug DEBUG_TRI) {
					rt_log("\teu_dir %g %g %g\n", eu_dir[0], eu_dir[1], eu_dir[2]);
					rt_log("\tnew_first/min 0x%08x %g %g %g -> %g %g %g vdot %g\n",
d1142 1
a1142 1
				*vu_min = vu;
d1147 2
a1148 2
		if (rt_g.NMG_debug tri_debug DEBUG_TRI)
			rt_log("checking reverse edgeuse\n");
d1153 4
a1156 4
		vu_last = eu_last->vu_p;
		NMG_CK_VERTEXUSE(vu_last);
		NMG_CK_VERTEX(vu_last->v_p);
		NMG_CK_VERTEX_G(vu_last->v_p->vg_p);
d1160 1
a1160 1
		VSUB2(eu_dir, vu_last->v_p->vg_p->coord, vu->v_p->vg_p->coord);
d1164 3
a1166 3
				if (rt_g.NMG_debug tri_debug DEBUG_TRI) {
					rt_log("\teu_dir %g %g %g\n", eu_dir[0], eu_dir[1], eu_dir[2]);
					rt_log("\tnew_max 0x%08x %g %g %g <- %g %g %g vdot %g\n",
d1169 1
a1169 1
						V3ARGS(vu_last->v_p->vg_p->coord),
d1173 1
a1173 1
				*vu_max = vu;
d1177 3
a1179 3
				if (rt_g.NMG_debug tri_debug DEBUG_TRI) {
					rt_log("\teu_dir %g %g %g\n", eu_dir[0], eu_dir[1], eu_dir[2]);
					rt_log("\tnew_min 0x%08x %g %g %g <- %g %g %g vdot %g\n",
d1182 1
a1182 1
						V3ARGS(vu_last->v_p->vg_p->coord),
d1186 1
a1186 1
				*vu_min = vu;
d1196 6
d1207 1
a1208 1
vect_t dir;
d1216 5
a1220 3
	if (rt_g.NMG_debug tri_debug DEBUG_TRI)
		rt_log("pick_eu(%g %g %g  <-> %g %g %g,   %g %g %g)\n",
			V3ARGS(eu_p->vu_p->v_p->vg_p ) );
d1233 1
d1239 8
d1254 2
d1261 2
d1272 7
d1321 1
a1321 1
	struct vertexuse *vu_max, *vu_min;
d1323 1
a1323 1
	struct edgeuse *eu_max, *eu_min, *eu_p;
d1338 4
a1341 2
	if (rt_g.NMG_debug tri_debug DEBUG_TRI)
		rt_log("nmg_find_first(v:(%g %g %g) dir:(%g %g %g))\n",
a1343 2
	VUNITIZE(dir);

d1345 1
a1345 1
	pick_edges(v, &vu_max, &vu_min, fu, &max_dir, &min_dir, tol, dir);
d1353 1
a1353 1
	 * For our max point, we choose the use for which:
d1357 1
a1357 1
	 * For our min point, we choose the use for which:
a1361 1

d1363 2
a1364 2
	NMG_CK_VERTEXUSE(vu_max);
	switch (max_dir) {
d1366 1
a1366 3
		eu_p = RT_LIST_PLAST_CIRC(edgeuse, vu_max->up.eu_p);
		vu_max = eu_p->vu_p;
		NMG_CK_VERTEXUSE(vu_max);
d1369 1
a1369 1
		eu_p = vu_max->up.eu_p;
d1375 1
a1375 1
		
d1377 1
d1379 5
a1383 1
	eu_max = pick_eu(eu_p, fu, dir, 1);
d1385 37
a1421 2
	NMG_CK_VERTEXUSE(vu_min);
	switch (min_dir) {
d1423 1
a1423 3
		eu_p = RT_LIST_PLAST_CIRC(edgeuse, vu_min->up.eu_p);
		vu_min = eu_p->vu_p;
		NMG_CK_VERTEXUSE(vu_min);
d1426 1
a1426 1
		eu_p = vu_min->up.eu_p;
d1434 1
a1434 1
	eu_min = pick_eu(eu_p, fu, dir, 0);
d1436 43
d1491 2
a1492 2
	if (rt_g.NMG_debug tri_debug DEBUG_TRI)
		rt_log("pick_pt2d_for_cutjoin()\n");
d1512 1
a1512 1
	VPRINT("\tdir", dir);
d1521 2
d1525 1
a1525 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI) {
d1546 1
a1546 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI) {
d1596 1
a1596 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d1763 1
a1763 1
		if (rt_g.NMG_debug tri_debug DEBUG_TRI) {
d1770 1
a1770 1
		if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d1830 1
a1830 1
			if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d1841 1
a1841 1
		if (rt_g.NMG_debug tri_debug DEBUG_TRI)		
d1867 1
a1867 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d1877 1
a1877 1
		if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d1897 1
a1897 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d1910 1
a1910 1
		if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d1929 1
a1929 1
			if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d1934 1
a1934 1
				if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d1938 1
a1938 1
				if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d1942 1
a1942 1
				if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d1946 1
a1946 1
			if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d1986 1
a1986 1
			if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d2009 1
a2009 1
			if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d2059 1
a2059 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI) {
d2076 1
a2076 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI){
d2082 1
a2082 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI)
d2105 1
a2105 1
	if (rt_g.NMG_debug tri_debug DEBUG_TRI)
@


1.22
log
@misc work on vertex sorter
@
text
@d12 2
d1208 1
a1208 1
			V3ARGS(eu_p->vu_p->v_p->vg_p
@


1.21
log
@misc changes
@
text
@a159 1
int tri_debug = 1;
a160 1

d489 1
a489 1
	if (tri_debug)
d615 1
a615 1
	if (tri_debug)
d654 1
a654 1
	if (tri_debug) {
d737 1
a737 1
	if (tri_debug)
d799 1
a799 1
	if (tri_debug)
d812 1
a812 1
			if (tri_debug)
d833 1
a833 1
			if (tri_debug)
d845 1
a845 1
			if (tri_debug)
d899 1
a899 1
	if (tri_debug)
d908 1
a908 1
	if (tri_debug) {
d919 1
a919 1
		if (tri_debug)
d923 1
a923 1
			if (tri_debug)
d929 1
a929 1
			if (tri_debug)
d935 1
a935 1
			if (tri_debug)
d1024 1
a1024 1
		if (tri_debug)
d1069 3
d1088 3
d1092 5
a1096 1
		    *vu->up.magic_p == NMG_LOOPUSE_MAGIC) continue;
d1109 2
a1110 1
		
d1113 1
a1113 1
				if (tri_debug) {
d1126 1
a1126 1
				if (tri_debug) {
d1141 3
d1158 1
a1158 1
				if (tri_debug) {
d1171 1
a1171 1
				if (tri_debug) {
d1204 4
d1291 2
d1304 4
d1311 1
a1311 1
	pick_edges(v, &vu_max, &vu_min, fu, &max_dir, &min_dir, dir);
d1330 3
a1332 1
	if (max_dir == -1) {
d1335 6
a1340 1
	} else if (max_dir != 1)
d1342 4
d1349 3
a1351 1
	if (min_dir == -1) {
d1354 6
a1359 1
	} else if (min_dir != 1)
d1361 2
d1364 1
d1379 1
a1379 1
	if (tri_debug)
d1411 1
a1411 1
	if (tri_debug) {
d1432 1
a1432 1
	if (tri_debug) {
d1482 1
a1482 1
	if (tri_debug)
d1649 1
a1649 1
		if (tri_debug) {
d1656 1
a1656 1
		if (tri_debug)
d1716 1
a1716 1
			if (tri_debug)
d1727 1
a1727 1
		if (tri_debug)		
d1753 1
a1753 1
	if (tri_debug)
d1763 1
a1763 1
		if (tri_debug)
d1783 1
a1783 1
	if (tri_debug)
d1796 1
a1796 1
		if (tri_debug)
d1815 1
a1815 1
			if (tri_debug)
d1820 1
a1820 1
				if (tri_debug)
d1824 1
a1824 1
				if (tri_debug)
d1828 1
a1828 1
				if (tri_debug)
d1832 1
a1832 1
			if (tri_debug)
d1872 1
a1872 1
			if (tri_debug)
d1895 1
a1895 1
			if (tri_debug)
d1945 1
a1945 1
	if (tri_debug) {
d1962 1
a1962 1
	if (tri_debug){
d1968 1
a1968 1
	if (tri_debug)
d1991 1
a1991 1
	if (tri_debug)
@


1.20
log
@Moved bounding box for faces from struct face_g to struct face.
Necessary because face geometry is now shared by multiple faces
@
text
@d1052 2
a1053 24


/*
 *	Given a pointer to a vertexuse in a face and a ray, find the
 *	"first" and "last" uses of the vertex along the ray in the face.
 *	Consider the diagram below where 4 OT_SAME loopuses meet at a single
 *	vertex.  The ray enters from the upper left and proceeds to the lower
 *	right.  The ray encounters vertexuse 1 first and vertexuse 3 last.
 *
 *
 *		     \  ^ |
 *		      \ | |
 *		       1| V2
 *		------->o o------->
 *		         .
 *		<-------o o<------
 *		       4^ |3
 *		        | | \
 *		        | |  \
 *		        | V   \|
 *			      -
 *
 *	The primary purpose of this routine is to find the vertexuses
 *	that should be the parameters to nmg_cut_loop() and nmg_join_loop().
d1055 2
a1056 2
void
nmg_find_first_last_use_of_v_in_fu(v, first_vu, last_vu, dir, fu, tol)
d1058 3
a1060 4
struct vertexuse **first_vu;
struct vertexuse **last_vu;
vect_t 		dir;
struct faceuse	*fu;
d1062 1
d1065 2
a1069 2
	struct edgeuse *eu_next, *eu_last;
	struct vertexuse *vu_next, *vu_last;
a1071 13
	NMG_CK_VERTEX(v);
	NMG_CK_FACEUSE(fu);
	if (first_vu == (struct vertexuse **)(NULL)) {
		rt_log("%s: %d first_vu is null ptr\n", __FILE__, __LINE__);
		rt_bomb("terminating\n");
	}
	if (last_vu == (struct vertexuse **)(NULL)) {
		rt_log("%s: %d last_vu is null ptr\n", __FILE__, __LINE__);
		rt_bomb("terminating\n");
	}

	VUNITIZE(dir);

d1081 1
d1092 1
d1113 2
a1114 1
				*last_vu = vu;
d1127 2
a1128 1
				*first_vu = vu;
d1132 1
d1139 3
d1155 2
a1156 1
				*first_vu = vu;
d1168 2
a1169 1
				*last_vu = vu;
d1173 1
d1176 149
@


1.19
log
@misc debugging messages
@
text
@d208 6
a213 6
		fu->f_p->fg_p->min_pt[0]-1.0,
		fu->f_p->fg_p->min_pt[1]-1.0,
		fu->f_p->fg_p->min_pt[2]-1.0,
		fu->f_p->fg_p->max_pt[0]+1.0,
		fu->f_p->fg_p->max_pt[1]+1.0,
		fu->f_p->fg_p->max_pt[2]+1.0);
d1692 6
a1697 6
		fu->f_p->fg_p->min_pt[0]-1.0,
		fu->f_p->fg_p->min_pt[1]-1.0,
		fu->f_p->fg_p->min_pt[2]-1.0,
		fu->f_p->fg_p->max_pt[0]+1.0,
		fu->f_p->fg_p->max_pt[1]+1.0,
		fu->f_p->fg_p->max_pt[2]+1.0);
@


1.18
log
@misc work on vertex sorting
@
text
@d1134 1
d1137 3
a1139 2
				if (tri_debug)
					rt_log("new_max 0x%08x %g %g %g -> %g %g %g vdot %g\n",
d1144 1
d1146 1
a1146 1
				*first_vu = vu;
d1149 3
a1151 2
				if (tri_debug)
					rt_log("new_min 0x%08x %g %g %g -> %g %g %g vdot %g\n",
d1156 1
d1159 1
a1159 1
				*last_vu = vu;
d1173 3
a1175 2
				if (tri_debug)
					rt_log("new_max 0x%08x %g %g %g <- %g %g %g vdot %g\n",
d1180 1
d1185 3
a1187 2
				if (tri_debug)
					rt_log("new_min 0x%08x %g %g %g <- %g %g %g vdot %g\n",
d1192 1
d1232 1
@


1.17
log
@removed tbl2d as a parameter to nmg_find_first_and_last_use_of_v_in_fu_on_ray()
@
text
@d1077 2
a1078 1
nmg_find_first_and_last_use_of_v_in_fu_on_ray( v, first_vu, last_vu, dir, fu, tol)
d1105 1
d1133 1
d1136 6
d1146 7
d1164 2
a1165 1
		VSUB2(eu_dir, vu->v_p->vg_p->coord, vu_last->v_p->vg_p->coord);
d1168 6
d1178 6
a1191 68
static struct pt2d *
sort_pt(tbl2d, pt1, pt2, tol)
struct rt_list *tbl2d;
struct pt2d *pt1, *pt2;
CONST struct rt_tol *tol;
{
	struct pt2d *save_pt, *pt_next, *pt_prev, *pt;
	vect_t ray_dir, eu_dir;
	struct vertexuse *vu, *vu1, *vu2;
	struct faceuse *fu1;
	double prev_max;

	RT_CK_TOL(tol);
	NMG_CK_PT2D(pt1);
	NMG_CK_PT2D(pt2);

	NMG_CK_VERTEXUSE(pt1->vu_p);
	NMG_CK_VERTEX(pt1->vu_p->v_p);
	NMG_CK_VERTEX_G(pt1->vu_p->v_p->vg_p);

	NMG_CK_VERTEXUSE(pt2->vu_p);
	NMG_CK_VERTEX(pt2->vu_p->v_p);
	NMG_CK_VERTEX_G(pt2->vu_p->v_p->vg_p);

	vu1 = pt1->vu_p;
	vu2 = pt2->vu_p;

	/* form a vector to represent the cut we want to make */
	/* XXX what if the points are the same? */
	VSUB2(ray_dir, pt2->coord, pt1->coord);

	if ((fu1 = nmg_find_fu_of_vu(vu1)) == (struct faceuse *)NULL) {
		rt_log("no faceuse parent of vertexuse %s %d\n", __FILE__, __LINE__);
		rt_bomb("help!\n");
	}

	prev_max = 0.0;
	save_pt = pt1;

	for (RT_LIST_FOR(vu, vertexuse, &vu1->v_p->vu_hd)) {
		NMG_CK_VERTEXUSE(vu);
		NMG_CK_VERTEX(vu->v_p);
		NMG_CK_VERTEX_G(vu->v_p->vg_p);

		if (nmg_find_fu_of_vu(vu) != fu1 ||
		    *vu->up.magic_p == NMG_LOOPUSE_MAGIC) continue;

		if ((pt = find_pt2d(tbl2d, vu)) == (struct pt2d *)NULL)
			rt_bomb("I want my mommy\n");

		/* compute the angle of the outbound edgeuse to the ray */
		pt_next = PT2D_NEXT(tbl2d, pt1);
		VSUB2(eu_dir, pt_next->coord, pt->coord);
		if (VDOT(ray_dir, eu_dir) > prev_max)
			save_pt = pt;

		/* compute the angle of the inbound edgeuse to the ray */
		pt_prev = PT2D_PREV(tbl2d, pt1);
		VSUB2(eu_dir, pt_prev->coord, pt->coord);
		if (VDOT(ray_dir, eu_dir) > prev_max)
			save_pt = pt;
	}
	return save_pt;
}




d1193 1
a1193 1
collect_and_sort_vu(tbl2d, p1, p2, tol)
d1198 2
a1199 4
	struct nmg_ray_state rs;
	struct nmg_ptbl b;
	struct pt2d *pt1, *pt2, *sp;
	point_t pt;
a1200 4
	struct faceuse *fu1, *fu2;
	struct loopuse *lu;
	struct vertexuse *vu, *vu1, *vu2;
	int mid, end, k;
d1202 2
a1203 1
	/* build the nmg_ptbl that nmg_face_rs_init() needs */
d1208 2
d1211 2
a1212 4
	pt1 = *p1;
	pt2 = *p2;
	NMG_CK_VERTEXUSE(pt1->vu_p);
	NMG_CK_VERTEXUSE(pt2->vu_p);
d1214 4
a1217 4
	if (tri_debug)
	    rt_log("collect_and_sort_vu(tbl2d,\n\t0x%08x (%g %g),\n\t0x%08x (%g %g))\n",
		pt1->vu_p, pt1->coord[0], pt1->coord[1],
		pt2->vu_p, pt2->coord[0], pt2->coord[1]);
d1219 3
a1221 2
	sp = sort_pt(tbl2d, p1, p2, tol);
	sp = sort_pt(tbl2d, p2, p1, tol);
d1223 3
a1225 9
	nmg_tbl(&b, TBL_INIT, (long *)NULL); 
	
	vu1 = pt1->vu_p;
	vu2 = pt2->vu_p;

	/* put the vertexuses for vu1->v_p from this loop on the list */
	if ((fu1 = nmg_find_fu_of_vu(vu1)) == (struct faceuse *)NULL) {
		rt_log("no faceuse parent of vertexuse %s %d\n", __FILE__, __LINE__);
		rt_bomb("help!\n");
a1226 5
	for (RT_LIST_FOR(vu, vertexuse, &vu1->v_p->vu_hd)) {
		NMG_CK_VERTEXUSE(vu);
		if (nmg_find_fu_of_vu(vu) == fu1)
			mid = nmg_tbl(&b, TBL_INS, (long *)vu);
	}
d1228 2
a1229 14
	/* put the vertexuses for vu2->v_p from this loop on the list */
	if ((fu2 = nmg_find_fu_of_vu(vu2)) == (struct faceuse *)NULL) {
		rt_log("no faceuse parent of vertexuse %s %d\n", __FILE__, __LINE__);
		rt_bomb("help!\n");
	} else if (fu2 != fu1) {
		rt_log("faceuses are not the same %s %d\n", __FILE__, __LINE__);
		rt_bomb("The vertexuse is familiar, but I can't place the face\n");
	}
	for (RT_LIST_FOR(vu, vertexuse, &vu2->v_p->vu_hd)) {
		NMG_CK_VERTEXUSE(vu);
		if (nmg_find_fu_of_vu(vu) == fu2)
			end = nmg_tbl(&b, TBL_INS, (long *)vu);
	}
 
d1231 1
a1231 4
	VMOVE(pt,  vu1->v_p->vg_p->coord);
	VSUB2(dir, vu2->v_p->vg_p->coord, pt);
	VUNITIZE(dir);
	nmg_face_rs_init(&rs, &b, fu1, fu1->fumate_p, pt, dir, tol);
a1232 5
	if (mid == 0 && end == 1) {
		if (tri_debug) rt_log("\tNo sorting necessary\n");
		return;
	}

d1234 1
a1234 6
		rt_log("\tunsorted vertexuse lists\n\t--list1--\n");
		for (k = 0 ; k <= mid ; k++) {
			vu = (struct vertexuse *)b.buffer[k];
			NMG_CK_VERTEXUSE( vu );
			pt1 = find_pt2d(tbl2d, vu);
			pt2 = PT2D_NEXT(tbl2d, pt1);
d1236 2
a1237 9
			rt_log("\t0x%08x %g %g -> 0x%08x %g %g\n",
				pt1->vu_p, pt1->coord[0], pt1->coord[1], 
				pt2->vu_p, pt2->coord[0], pt2->coord[1]);
		}
	}
	if (mid > 0)
		nmg_face_coincident_vu_sort(&rs, 0, mid+1);
	else if (tri_debug)
		rt_log("\tlist of length 1 is sorted\n");
d1239 1
d1241 5
a1245 12
	if (tri_debug) {
		rt_log("\t--list2--\n");
		for (k = mid+1 ; k <= end ; k++) {
			vu = (struct vertexuse *)b.buffer[k];
			NMG_CK_VERTEXUSE( vu );
			pt1 = find_pt2d(tbl2d, vu);
			pt2 = PT2D_NEXT(tbl2d, pt1);

			rt_log("\t0x%08x %g %g -> 0x%08x %g %g\n",
				pt1->vu_p, pt1->coord[0], pt1->coord[1], 
				pt2->vu_p, pt2->coord[0], pt2->coord[1]);
		}
a1246 4
	if (end-mid > 1)
		nmg_face_coincident_vu_sort(&rs, mid+1, end+1);
	else if (tri_debug)
		rt_log("\tlist of length 1 is sorted\n");
d1249 2
a1250 2
	if (tri_debug) {
		rt_log("\tsorted vertexuses:\n\t--list1--\n");
a1251 5
		for (k=0 ; k <= end ; k++) {
			vu = (struct vertexuse *)b.buffer[k];
			NMG_CK_VERTEXUSE( vu );
			pt1 = find_pt2d(tbl2d, vu);
			pt2 = PT2D_NEXT(tbl2d, pt1);
d1253 3
a1255 2
			if (k == mid) *p1 = pt1;
			else if (k== mid+1) *p2 = pt1;
d1257 2
a1258 3
			rt_log("\t0x%08x %g %g -> 0x%08x %g %g\n",
				pt1->vu_p, pt1->coord[0], pt1->coord[1], 
				pt2->vu_p, pt2->coord[0], pt2->coord[1]);
d1260 6
a1265 5
			if (k== mid) rt_log("\t--list2--\n");
		}
	    rt_log("\tpicking 0x%08x %g %g -> 0x%08x %g %g\n",
		(*p1)->vu_p, (*p1)->coord[0], (*p1)->coord[1], 
		(*p2)->vu_p, (*p2)->coord[0], (*p2)->coord[1]);
d1267 1
a1271 2


d1297 1
d1313 3
a1315 1
	collect_and_sort_vu(tbl2d, &p1, &p2, tol);
d1336 1
a1336 1
	/* XXX Does anyone care about loopuse orientations at this stage? */
d1339 1
a1339 1

d1382 1
a1382 1
	collect_and_sort_vu(tbl2d, &p1, &p2, tol);
a1473 2

			rt_log("postulating....\n");
d1476 1
a1476 1
		collect_and_sort_vu(tbl2d, &top, &bot, tol);
d1479 1
a1479 1
			rt_log("....postulated\n");
@


1.16
log
@added nmg_find_first_and_last_use_of_v_in_fu_on_ray()
@
text
@d1077 1
a1077 2
nmg_find_first_and_last_use_of_v_in_fu_on_ray(tbl2d, v, first_vu, last_vu, dir, fu, tol)
struct rt_list *tbl2d;
@


1.15
log
@stub of nmg_find_first_and_last_vu_in_fu_on_ray() added
@
text
@d1077 1
a1077 1
nmg_first_and_last_vu_in_fu_on_ray(tbl2d, vu, first_vu, last_vu, dir, fu, tol)
d1079 1
a1079 1
struct vertexuse *vu;
d1084 1
d1086 75
@


1.14
log
@Have to reorient after nmg_cut_loop() and nmg_split_lu_at_vu() calls.
@
text
@d1054 34
@


1.13
log
@Access to plane equation / surface normal in face_geometry structure
is now done through macros NMG_GET_FU_PLANE() NMG_GET_FU_NORMAL(),
which honor the f->flip flag.
@
text
@d1283 1
d1302 1
a1302 1
		rt_bomb("goodnight\n");
d1312 1
a1312 1
		rt_bomb("goodnight\n");
d1320 2
d1325 4
d1752 1
a1752 3
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		nmg_split_touchingloops(lu);
	}
@


1.12
log
@This version at least compiles.
@
text
@d430 1
a430 1
	plane_t Normal;
d1096 1
a1096 1
		NMG_CK_VERTEX_g(vu->v_p->vg_p);
d1191 1
a1191 2
	nmg_face_rs_init(&rs, &b, fu1, fu1->fumate_p, pt, dir);
	rs.tol = tol;
@


1.11
log
@Lee added calls to sort_pt().
@
text
@d1130 1
a1130 1
	struct pt2d *pt1, *pt2, sp;
@


1.10
log
@More data integrity checking, better classification of trapezoid verticies.
@
text
@d1053 69
d1130 1
a1130 1
	struct pt2d *pt1, *pt2;
d1153 3
@


1.9
log
@changed nmg_triangulate_face() to nmg_triangulate_fu()
@
text
@d191 1
d194 1
d196 1
a196 1
	sprintf(name, "tri%d.pl", fileno++);
d219 3
a221 2
			if (p=find_pt2d(tbl2d,RT_LIST_FIRST(vertexuse, &lu->down_hd))) {
				pd_move(fd, p->coord[0], p->coord[1]);
d226 1
a226 1
				pl_label(fd, "X, Y");
d231 2
a232 1
					pd_move(fd, p->coord[0], p->coord[1]);
d237 1
a237 1
					pl_label(fd, "X, Y");
d471 27
d505 3
d520 2
d532 2
d549 12
a560 4
		if (lu->orientation == OT_OPPOSITE)
			return(HOLE_END);
		else if (lu->orientation == OT_SAME)
			return(POLY_END);
d564 10
a573 1
		if (lu->orientation == OT_OPPOSITE)
a574 2
		else if (lu->orientation == OT_SAME)
			return(POLY_START);
d576 11
a586 1
	if ( (P_GT_V(n, v) && P_LT_V(p, v)) || (P_LT_V(n, v) && P_GT_V(p, v)) )
d588 1
a588 1

d616 1
d653 1
d738 1
d800 1
d835 2
a836 1
			rt_log("Continue #1\n");
d847 2
a848 1
			rt_log("Continue #2\n");
d900 1
d910 5
a914 3
	print_2d_eu("eunext", eunext, tbl2d);
	print_2d_eu("euprev", euprev, tbl2d);
	
d921 3
a923 1
		print_trap(tp, tbl2d);
d925 2
a926 1
			rt_log("Completed... Skipping\n");
d931 2
a932 1
			rt_log("Found tpnext\n");
d935 1
d937 2
a938 1
			rt_log("Found tpprev\n");
d1004 3
a1006 2
			rt_log( "%g %g is UNKNOWN type vertex\n",
				pt->coord[X], pt->coord[Y]);
d1026 2
a1027 1
		rt_log("%s %d map_new_vertexuse() vertexuse already mapped!\n",
d1057 1
a1057 1
struct rt_tol *tol;
d1071 1
d1074 1
d1080 2
a1081 1
	rt_log("collect_and_sort_vu(tbl2d,\n\t0x%08x (%g %g),\n\t0x%08x (%g %g))\n",
d1114 1
a1115 1

d1123 1
a1123 1
		rt_log("\tNo sorting necessary\n");
d1127 7
d1135 9
a1143 1
	rt_log("\tun-sorted vertexuses:\n");
a1144 5
	for (k=0 ; k <= end ; k++) {
		vu = (struct vertexuse *)b.buffer[k];
		NMG_CK_VERTEXUSE( vu );
		pt1 = find_pt2d(tbl2d, vu);
		pt2 = PT2D_NEXT(tbl2d, pt1);
d1146 12
a1157 3
		rt_log("\t0x%08x %g %g -> 0x%08x %g %g\n",
			pt1->vu_p, pt1->coord[0], pt1->coord[1], 
			pt2->vu_p, pt2->coord[0], pt2->coord[1]);
a1158 3

	if (mid > 0)
		nmg_face_coincident_vu_sort(&rs, 0, mid+1);
d1161 2
a1163 1
	rt_log("\tsorted vertexuses:\n");
d1165 2
a1166 5
	for (k=0 ; k <= end ; k++) {
		vu = (struct vertexuse *)b.buffer[k];
		NMG_CK_VERTEXUSE( vu );
		pt1 = find_pt2d(tbl2d, vu);
		pt2 = PT2D_NEXT(tbl2d, pt1);
d1168 5
a1172 2
		if (k == mid) *p1 = pt1;
		else if (k== mid+1) *p2 = pt1;
d1174 2
a1175 4
		rt_log("\t0x%08x %g %g -> 0x%08x %g %g\n",
			pt1->vu_p, pt1->coord[0], pt1->coord[1], 
			pt2->vu_p, pt2->coord[0], pt2->coord[1]);
	}
d1177 7
a1183 1
	rt_log("\tpicking 0x%08x %g %g -> 0x%08x %g %g\n",
d1186 1
d1208 1
a1208 1
struct rt_tol	*tol;
d1217 1
d1271 1
a1271 1
struct rt_tol	*tol;
d1278 4
d1346 1
a1346 1
struct rt_tol	*tol;
d1358 2
d1382 3
a1384 2
		rt_log("trying to cut ...\n");
		print_trap(tp, tbl2d);
d1386 3
a1388 1
		rt_log("postulating....\n");
a1389 1
		rt_log("....postulated\n");
d1391 3
d1462 2
a1463 2
		
		plfu( nmg_find_fu_of_vu(tp->top->vu_p),  tbl2d );
a1467 8
static int
is_convex(a, b, c)
struct pt2d *a, *b, *c;
{
	vect_t ab, bc, pv, N;
	double angle;
	
	VSET(N, 0.0, 0.0, 1.0);
a1468 14
	VSUB2(ab, b->coord, a->coord);
	VCROSS(pv, N, ab);

	VSUB2(bc, c->coord, b->coord);

	angle = rt_angle_measure( bc, ab, pv );

	if (tri_debug)
		rt_log("\tangle == %g\n", angle);

	/* XXX this should be a toleranced comparison */
	return (angle > SQRT_SMALL_FASTF && angle <= M_PI);
}

d1474 1
a1474 1
cut_unimonotone( tbl2d, tlist, lu )
d1477 1
d1485 1
d1546 1
a1546 1
			current = cut_mapped_loop(tbl2d, next, prev, cut_color, 0);
d1550 2
a1551 1
			plfu( lu->up.fu_p, tbl2d );
d1555 2
a1556 1
				rt_log("\tfirst(0x%08x -> %g %g\n", first, t->coord[X], t->coord[Y]);
a1557 1
				rt_log("\tcurrent(0x%08x) -> %g %g\n", current, t->coord[X], t->coord[Y]);
d1559 3
d1563 2
a1564 1
				rt_log("\tcurrent(0x%08x) -> %g %g\n", current, t->coord[X], t->coord[Y]);
d1587 1
d1661 1
a1661 1
struct rt_tol	*tol;
d1672 2
d1699 2
a1700 1
	print_tlist(tbl2d, &tlist);
d1702 2
a1703 1
	rt_log("Cutting diagonals ----------\n");
d1705 2
a1706 1
	rt_log("Diagonals are cut ----------\n");
d1720 1
a1720 1
					cut_unimonotone(tbl2d, &tlist, lu);
d1728 2
a1729 1
	plfu( fu, tbl2d );
d1748 1
a1748 1
struct rt_tol   *tol;
d1754 1
@


1.8
log
@Changed to work with NMG_GET_FU_NORMAL() to get plane normal.
@
text
@d99 1
a99 1
void
d117 1
a117 1
void
d487 1
a487 1
int
d545 1
a545 1
void
d580 1
a580 1
void
d664 1
a664 1
void
d725 1
a725 1
void
d823 1
a823 1
void
d973 1
a973 1
void
d1474 1
a1474 1
void
d1556 1
a1556 1
nmg_triangulate_face(fu, tol)
d1636 1
d1654 1
a1654 1
					nmg_triangulate_face(fu, tol);
@


1.7
log
@I think we have reached a plateau of functionality.  Works on the 4 or 5
test cases I created.
@
text
@d426 1
d441 2
a442 1
	mat_fromto( TformMat, fu->f_p->fg_p->N, twoDspace );
@


1.6
log
@gross hack to get more test cases to work.
@
text
@d160 1
a160 1
static int tri_debug = 1;
d1033 1
d1124 1
a1124 1
	collect_and_sort_vu(tbl2d, &p1, &p2);
a1125 1
		rt_log("parent loops are not the same %s %d\n", __FILE__, __LINE__);
d1127 1
d1131 1
d1181 1
a1181 1
	collect_and_sort_vu(tbl2d, &p1, &p2);
d1271 4
d1277 4
a1280 4
		toplu = nmg_find_lu_of_vu(tp->top->vu_p);
		botlu = nmg_find_lu_of_vu(tp->bot->vu_p);
		NMG_CK_VERTEXUSE(tp->top->vu_p);
		NMG_CK_VERTEXUSE(tp->bot->vu_p);
d1290 1
a1290 1
			(void)cut_mapped_loop(tbl2d, tp->top, tp->bot, cut_color, tol, 1);
d1339 2
a1340 2
			join_mapped_loops(tbl2d,tp->top, tp->bot, join_color, tol);

d1343 2
a1344 1
		plfu( toplu->up.fu_p, tbl2d );
d1387 2
d1446 1
d1449 1
d1598 1
d1634 23
@


1.5
log
@miscelaneous improvements, including sorting vertexuses to pick appropriate
ones for doing cut/join against.  First version to properly handle a holed
polygon face
@
text
@d1094 1
d1096 1
a1096 1
cut_mapped_loop(tbl2d, p1, p2, color, tol)
d1101 1
d1126 4
d1183 1
a1183 1
		(void)cut_mapped_loop(tbl2d, p1, p2, color, tol);
a1252 1

d1256 2
a1257 1
		if (top_next == tp->bot || bot_next == tp->top) {
d1284 1
a1284 1
			(void)cut_mapped_loop(tbl2d, tp->top, tp->bot, cut_color, tol);
d1437 1
a1437 1
			current = cut_mapped_loop(tbl2d, next, prev, cut_color);
@


1.4
log
@Added missing 'static'.
@
text
@d55 26
d82 1
a82 1
PvsV(p, v) \
d151 1
d156 1
d971 114
d1095 1
a1095 1
cut_mapped_loop(tbl2d, p1, p2)
d1098 2
a1108 1

d1117 15
d1151 1
a1151 1
join_mapped_loops(tbl2d, vu1, vu2)
d1153 3
a1155 1
struct vertexuse *vu1, *vu2;
d1157 1
d1162 3
d1168 14
d1196 4
d1201 1
d1224 1
a1224 1
cut_diagonals(tbl2d, tlist)
d1226 1
d1229 2
a1230 1
	struct pt2d *tn, *bn;
d1232 3
d1244 2
a1245 2
		tn = PT2D_NEXT(tbl2d, tp->top);
		bn = PT2D_NEXT(tbl2d, tp->bot);
d1247 5
a1251 1
		if (tn == tp->bot || bn == tp->top) {
a1264 6

		if (plot_fd) {
			pl_color(plot_fd, 200, 90, 90);
			pdv_3line(plot_fd, tp->top->coord, tp->bot->coord);
		}

d1278 1
a1278 1
			(void)cut_mapped_loop(tbl2d, tp->top, tp->bot);
d1327 2
a1328 1
			join_mapped_loops(tbl2d,tp->top->vu_p,tp->bot->vu_p);
d1371 2
d1431 1
a1431 1
			current = cut_mapped_loop(tbl2d, next, prev);
d1537 1
a1537 1
nmg_triangulate_face(fu)
d1539 1
d1577 3
a1579 1
	cut_diagonals(tbl2d, &tlist);
@


1.3
log
@Minor updates
@
text
@d70 1
a70 1
struct pt2d *find_pt2d();	
@


1.2
log
@miscelaneous development.
@
text
@d5 1
a10 1
#include "rt_tree.h"
d195 2
a196 1
				rt_bomb("error finding loop vertex in 2D list\n");
d205 1
a205 1
					rt_bomb("error finding edge vertex in 2D list\n");
d985 2
a986 3
	eu = eu->radial_p;
	NMG_CK_EDGEUSE(eu);
	map_new_vertexuse(tbl2d, eu->vu_p);
d988 2
a989 1

d999 1
d1025 4
a1028 1
	 * we need to map them to the 2D plane.
d1030 7
a1036 6
	map_new_vertexuse(tbl2d, vu);
	NMG_CK_EDGEUSE(eu);
	eu = RT_LIST_PNEXT_CIRC(edgeuse, eu);
	NMG_CK_VERTEXUSE(eu->vu_p);

	map_new_vertexuse(tbl2d, eu->vu_p);
d1238 1
d1247 1
a1247 2
			if (current->vu_p->v_p == first->vu_p->v_p) {
				struct pt2d *t;
d1254 1
@


1.1
log
@Initial revision
@
text
@d5 1
d10 1
d12 10
d23 1
a23 1
#define NMG_TRAP_MAGIC	0x4d4d4d4d
d25 15
d42 2
a43 4
	fastf_t	coord[3];
	struct vertexuse *vu_p;
	long next, prev;		/* Index #'s of next/prev vu's in loop */
	struct trap *trap1, *trap2;
a45 5
struct trapezoid {
	struct rt_list l;
	struct pt2d *top, *bot;
	struct edgeuse *left, *right;	/* edges really */
};
d48 5
a52 5
	long	magic;
	struct pt2d	*top_v, *bot_v;	/* top/bottom vertex of trapezoid */
	struct edgeuse	*eu_l, *eu_r;	/* left/right edgeuses of trapezoid */
	struct trap	*lc, *rc;	/* left/right child of trapezoid */
	struct trap	*np;		/* new trapezoid tree outside trap. */
d55 6
a60 1
/* macros for comparing 2D points in scanline order */
d62 6
a67 8
#define PgtV(_p, _v) \
	(((_p)->coord[Y] > (_v)->coord[Y]) || ((_p)->coord[Y] == (_v)->coord[Y] && (_p)->coord[X] < (_v)->coord[X]))
#define PltV(_p, _v) \
	(((_p)->coord[Y] < (_v)->coord[Y]) || ((_p)->coord[Y] == (_v)->coord[Y] && (_p)->coord[X] > (_v)->coord[X]))
#define PgeV(_p, _v) \
	(((_p)->coord[Y] > (_v)->coord[Y]) || ((_p)->coord[Y] == (_v)->coord[Y] && (_p)->coord[X] <= (_v)->coord[X]))
#define PleV(_p, _v) \
	(((_p)->coord[Y] < (_v)->coord[Y]) || ((_p)->coord[Y] == (_v)->coord[Y] && (_p)->coord[X] >= (_v)->coord[X]))
a68 1
void nmg_plot_flat_face();
d70 1
d72 3
a74 4
static int flatten_debug=1;
static int tri_debug = 1;
	
nmg_pr_trap(s, tp, tbl2d)
d76 17
d94 1
a94 1
struct pt2d tbl2d[];
d96 1
a96 1
	struct edgeuse *eu;
d98 1
a98 2
	if (s)
		fprintf(stderr, "%s\n", s);
d100 3
a102 2
	if (!tp)
		fprintf(stderr, "Null trapezoid pointer\n");
d104 10
a113 1
	(void)fprintf(stderr, "0x%0x\n", tp->magic);
d115 9
a123 4
	if (tp->top_v)
		(void)fprintf(stderr, "\ttop_v %g %g\n", tp->top_v->coord[0], tp->top_v->coord[1]);
	else
		(void)fprintf(stderr, "\tnull top_v pointer\n");
d125 5
d131 2
a132 4
	if (tp->bot_v)
		(void)fprintf(stderr, "\tbot_v %g %g\n", tp->bot_v->coord[0], tp->bot_v->coord[1]);
	else
		(void)fprintf(stderr, "\tnull bot_v pointer\n");
d135 7
a141 5
	if (tp->eu_l) {
		eu = RT_LIST_PNEXT_CIRC(edgeuse, &tp->eu_l->l);
		fprintf(stderr, "\teu_l %g %g -> %g %g\n",
			tbl2d[tp->eu_l->vu_p->index].coord[0],
			tbl2d[tp->eu_l->vu_p->index].coord[1],
d143 7
a149 4
			tbl2d[eu->vu_p->index].coord[0],
			tbl2d[eu->vu_p->index].coord[1]);
	} else
		(void)fprintf(stderr, "\tNull eu_l edgeuse\n");
d151 20
d172 3
d176 10
a185 5
	if (tp->eu_r) {
		eu = RT_LIST_PNEXT_CIRC(edgeuse, &tp->eu_r->l);
		fprintf(stderr, "\teu_r %g %g -> %g %g\n",
			tbl2d[tp->eu_r->vu_p->index].coord[0],
			tbl2d[tp->eu_r->vu_p->index].coord[1],
d187 23
a209 4
			tbl2d[eu->vu_p->index].coord[0],
			tbl2d[eu->vu_p->index].coord[1]);
	} else
		(void)fprintf(stderr, "\tNull eu_r edgeuse\n");
d211 3
d216 3
a218 1
/*	N M G _ F I N D _ F U _ O F _ V U
d220 2
a221 2
 *	return a pointer to the parent faceuse of the vertexuse
 *	or a null pointer if vu is not a child of a faceuse.
d223 5
a227 3
struct faceuse *
nmg_find_fu_of_vu(vu)
struct vertexuse *vu;
d229 2
a230 2
	struct loopuse *lu_p;
	NMG_CK_VERTEXUSE(vu);
d232 22
a253 21
	switch (*vu->up.magic_p) {
	case NMG_SHELL_MAGIC:
		return ((struct faceuse *)NULL);
		break;
	case NMG_LOOPUSE_MAGIC:
		lu_p = vu->up.lu_p;
gotaloop:
		switch (*lu_p->up.magic_p) {
		case NMG_FACEUSE_MAGIC:
			return (vu->up.lu_p->up.fu_p);
		case NMG_SHELL_MAGIC:
			return ((struct faceuse *)NULL);
			break;
		default:
			fprintf(stderr,
				"Error at %s %d:\nInvalid loopuse parent magic (0x%x %d)\n",
				__FILE__, __LINE__,
				*vu->up.lu_p->up.magic_p,
				*vu->up.lu_p->up.magic_p);
			abort();
			break;
d255 2
a256 26
		break;
	case NMG_EDGEUSE_MAGIC:
		switch (*vu->up.eu_p->up.magic_p) {
		case NMG_LOOPUSE_MAGIC:
			lu_p = vu->up.eu_p->up.lu_p;
			goto gotaloop;
			break;
		case NMG_SHELL_MAGIC:
			return ((struct faceuse *)NULL);
			break;
		default:
			fprintf(stderr,
				"Error at %s %d:\nInvalid loopuse parent magic 0x%x\n",
				__FILE__, __LINE__,
				*vu->up.lu_p->up.magic_p);
			abort();
			break;
		}
		break;
	default:
		fprintf(stderr,
			"Error at %s %d:\nInvalid vertexuse parent magic 0x%x\n",
			__FILE__, __LINE__,
			*vu->up.magic_p);
		abort();
		break;
a257 1
}
d259 4
d264 1
a264 9
/*	N M G _ V U _ I S _ I N _ F U
 *
 *	Returns 1 if vu is child of fu, 0 otherwise
 */
nmg_vu_is_in_fu(vu_p, fu)
struct vertexuse *vu_p;
struct faceuse *fu;
{
	return (nmg_find_fu_of_vu(vu_p) == fu);
d274 1
a274 1
map_vu_to_2d(vu, tbl2d, mat, fu, hv)
d276 1
a276 1
struct pt2d *tbl2d;
d283 1
d285 1
a285 1
	struct pt2d *p;
d287 3
d291 1
a291 2
	if (RT_LIST_MAGIC_OK(&tbl2d[vu->index].l, NMG_PT2D_MAGIC) )
		return;
d293 14
d309 1
a309 4
	MAT4X3PNT(tbl2d[vu->index].coord, mat, vg->coord);
	if (flatten_debug)
		(void)fprintf(stderr, "old (%g, %g, %g) new (%g, %g, %g)\n",
			V3ARGS(vg->coord), V3ARGS(tbl2d[vu->index].coord) );
a310 2
	tbl2d[vu->index].coord[2] = 0.0;
	tbl2d[vu->index].vu_p = vu;
d312 4
d317 2
a318 4
	for (RT_LIST_FOR(p, pt2d, &tbl2d[0].l)) {
		if (PgtV(p, &tbl2d[vu->index])) continue;
		RT_LIST_INSERT(&p->l, &tbl2d[vu->index].l);
		RT_LIST_MAGIC_SET(&tbl2d[vu->index].l, NMG_PT2D_MAGIC);
d321 1
a321 4
	if (RT_LIST_MAGIC_WRONG(&tbl2d[vu->index].l, NMG_PT2D_MAGIC)) {
		RT_LIST_INSERT( &tbl2d[0].l, &tbl2d[vu->index].l);
		RT_LIST_MAGIC_SET(&tbl2d[vu->index].l, NMG_PT2D_MAGIC);
	}
d323 2
a324 11
	/* if vu part of edge in loop remember next/prev vertexuse in
	 * loop.
	 */
	if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC &&
	     *vu->up.eu_p->up.magic_p == NMG_LOOPUSE_MAGIC) {
	     
		eu = RT_LIST_PNEXT_CIRC(edgeuse, &vu->up.eu_p->l);
		tbl2d[vu->index].next = eu->vu_p->index;
		eu = RT_LIST_PLAST_CIRC(edgeuse, &vu->up.eu_p->l);
		tbl2d[vu->index].prev = eu->vu_p->index;
	}
d329 1
a329 2
	for (RT_LIST_FOR(vu_p, vertexuse, &vu->v_p->vu_hd)) {
		if (!nmg_vu_is_in_fu(vu_p, fu)) continue;
d331 3
a333 4
		RT_LIST_APPEND(&tbl2d[vu->index].l, &tbl2d[vu_p->index].l);
		RT_LIST_MAGIC_SET(&tbl2d[vu_p->index].l, NMG_PT2D_MAGIC);
		VMOVE(tbl2d[vu_p->index].coord, tbl2d[vu->index].coord);
		tbl2d[vu_p->index].vu_p = vu_p;
d335 11
a345 10
		/* if vu_p part of edge in loop remember next/prev
		 * vertexuse in loop.
		 */
		if (*vu_p->up.magic_p == NMG_EDGEUSE_MAGIC &&
		     *vu_p->up.eu_p->up.magic_p == NMG_LOOPUSE_MAGIC) {
	     
			eu = RT_LIST_PNEXT_CIRC(edgeuse, &vu_p->up.eu_p->l);
			tbl2d[vu_p->index].next = eu->vu_p->index;
			eu = RT_LIST_PLAST_CIRC(edgeuse, &vu_p->up.eu_p->l);
			tbl2d[vu_p->index].prev = eu->vu_p->index;
d347 20
d368 2
d387 1
a387 1
struct pt2d *
d393 1
a393 1
	struct pt2d *tbl2d;
d400 2
a402 3
	tbl2d = (struct pt2d *)rt_calloc(fu->s_p->r_p->m_p->maxindex,
		sizeof(struct pt2d), "2D coordinate table");

d408 1
a408 1
	RT_LIST_INIT( &tbl2d[0].l );
d411 2
a412 1
	mat_fromto( TformMat, twoDspace, fu->f_p->fg_p->N );
d421 1
a421 1
			map_vu_to_2d(vu, tbl2d, TformMat);
d426 1
a426 1
				map_vu_to_2d(vu, tbl2d, TformMat);
d436 7
a442 2


d447 1
a447 1
 *	  1 	     2	       3	   4	    5
d449 4
a452 4
 *      /- -\	  -------		-\   /-     \---/
 *     /-- --\	  ---O---	O	--\ /--      \-/
 *    O--- ---O	  --/ \--      /-\	---O---       O
 *     \-- --/	  -/   \-     /---\	-------
d458 2
a459 2
struct pt2d * v;
struct pt2d *tbl2d;
d463 1
d465 10
a474 10
	/* get the indicies of the 2D versions of the verticies
	 * on the other ends of the edgeuses which meet at this 
	 * 2D vertexuse.
	 *
	 * XXX parent of vertex might be loopuse
	 */
	if (*v->vu_p->up.magic_p != NMG_EDGEUSE_MAGIC ||
	    *v->vu_p->up.eu_p->up.magic_p != NMG_LOOPUSE_MAGIC ) {
		printf("oops\n");
		abort();
d477 1
a477 2
	n = &tbl2d[v->next];
	p = &tbl2d[v->prev];
d479 5
a483 8
	NMG_CK_PT2D(n);
	NMG_CK_PT2D(p);

	if (PgtV(n, v) && PgtV(p, v)) {
		if (v->vu_p->up.eu_p->up.lu_p->orientation == OT_OPPOSITE)
			return(4);
		else if (v->vu_p->up.eu_p->up.lu_p->orientation == OT_SAME)
			return(5);
d486 5
a490 5
	if (PltV(n, v) && PltV(p, v)) {
		if (v->vu_p->up.eu_p->up.lu_p->orientation == OT_OPPOSITE)
			return(2);
		else if (v->vu_p->up.eu_p->up.lu_p->orientation == OT_SAME)
			return(3);
d492 2
a493 2
	if ( (PgtV(n, v) && PltV(p, v)) || (PltV(n, v) && PgtV(p, v)) )
		return(1);
d495 1
a495 1
	fprintf(stderr,
d505 8
a512 4
/*
 *	if "prev_trap" is incomplete and has an edgeuse of "upper_eu"
 *	then complete "prev_trap" and create a new trapezoid as a child
 *	of "prev_trap"
d514 4
a517 5
int
new_type1_trap(pt, prev_trap, upper_eu, lower_eu)
struct pt2d pt;
struct trap *prev_trap;
struct edgeuse *upper_eu, *lower_eu;
d519 2
a520 4
#if 0
	/* if trapezoid complete, it can't be the right one */
	if (prev_trap->bot_v)
		return (0);
d522 3
a524 4
	/* trapezoid is incomplete, check to see if it uses proper edgesue */
	if (prev_pt->eu_l == upper_eu) {
		/* complete trapezoid */
	    	prev_trap->bot_v = pt;
d526 6
a531 4
		/* start new trapezoid */
		new_trap = (struct trap *)
			rt_calloc(1, sizeof(struct trap),
			"new trapezoid");
d533 3
a535 32
		new_trap->top = pt;

	    	new_trap->eu_l = lower_eu;
	    	new_trap->eu_r = prev_trap->eu_r;
		new_trap->magic = NMG_TRAP_MAGIC;

		/* make new trapezoid child of old one */
		prev_trap->lc = new;

	    	return(1);
	} else if (prev_pt->eu_r == upper_eu) {
		/* complete trapezoid */
	    	prev_trap->bot_v = pt;

		/* start new trapezoid */
		new_trap = (struct trap *)
			rt_calloc(1, sizeof(struct trap),
			"new trapezoid");

		new_trap->top = pt;

	    	new_trap->eu_l = prev_trap->eu_l;
	    	new_trap->eu_r = lower_eu;
		new_trap->magic = NMG_TRAP_MAGIC;

		/* make new trapezoid child of old one */
		prev_trap->rc = new;

	    	return(1);
	}
	return(0);
#endif
d545 1
a545 1
 *	  V
d550 1
a550 1
type1vertex(pt, tbl2d, trap)
d552 1
a552 1
struct trap *trap;
d554 3
a556 5
	struct trap *tp, *new;
	struct edgeuse *upper_eu, *lower_eu;
	struct edgeuse *other_eu;
	struct pt2d *n, *p;
	struct pt2d *prev_pt;
d558 4
a561 2
	if (tri_debug)
		fprintf(stderr, "%g %g is type 1 vertex\n",
d563 7
d571 10
a580 2
	n = &tbl2d[pt->next];
	p = &tbl2d[pt->prev];
d582 2
a583 34
	if (PgeV(n, pt) && PleV(p, pt)) {
	    /* rising */
	    if (tri_debug) {
		other_eu = RT_LIST_PNEXT_CIRC(edgeuse, &pt->vu_p->up.eu_p->l);
		fprintf(stderr, "(%g %g)\n\t<- (%g %g)\n\t\t<- ",
			tbl2d[other_eu->vu_p->index].coord[0],
			tbl2d[other_eu->vu_p->index].coord[1],
			pt->coord[0],
			pt->coord[1]);
		other_eu = RT_LIST_PLAST_CIRC(edgeuse, &pt->vu_p->up.eu_p->l);
		fprintf(stderr, "(%g %g)\n",
			tbl2d[other_eu->vu_p->index].coord[0],
			tbl2d[other_eu->vu_p->index].coord[1]);
	    }
	    upper_eu = pt->vu_p->up.eu_p;
	    lower_eu = RT_LIST_PLAST_CIRC(edgeuse, &pt->vu_p->up.eu_p->l);
	} else {
	    /* decending */
	    if (tri_debug) {
		other_eu = RT_LIST_PLAST_CIRC(edgeuse, &pt->vu_p->up.eu_p->l);
		fprintf(stderr, "(%g %g) ->\n\t(%g %g) ->\n\t\t",
			tbl2d[other_eu->vu_p->index].coord[0],
			tbl2d[other_eu->vu_p->index].coord[1],
			pt->coord[0],
			pt->coord[1]);
		other_eu = RT_LIST_PNEXT_CIRC(edgeuse, &pt->vu_p->up.eu_p->l);
		fprintf(stderr, "(%g %g)\n",
			tbl2d[other_eu->vu_p->index].coord[0],
			tbl2d[other_eu->vu_p->index].coord[1]);
	    }
	    upper_eu = RT_LIST_PLAST_CIRC(edgeuse, &pt->vu_p->up.eu_p->l);
	    lower_eu = pt->vu_p->up.eu_p;
	}
#if 0
d585 3
a587 3
	/* search backwards in the sorted list of 2d vertex structures for
	 * the vertex which has an incomplete trapezoid with the upper 
	 * edge of this vertex.
d589 8
a596 13
	for (prev_pt = RT_LIST_PLAST(pt2d, pt) ;
	    RT_LIST_MAGIC(&prev_pt->l) != RT_LIST_HEAD_MAGIC ;
	    prev_pt = RT_LIST_PLAST(pt2d, prev) ) {

	    	prev_trap = prev_pt->trap2;

		if (prev_pt->trap2 &&
		    new_type1_trap(pt, prev_pt->trap2, upper_eu, lower_eu))
			return;

		if (prev_pt->trap1 &&
		    new_type1_trap(pt, prev_pt->trap1, upper_eu, lower_eu))
			return;
a597 6
	(void)fprintf(stderr,
		"%s %d didn't find trapezoid for type 1 vertex\n",
		__FILE__, __LINE__);
	abort();
#endif
}
d599 2
d602 2
d605 13
d619 3
d624 17
d642 3
d646 4
d651 2
d654 15
d670 1
d672 4
a678 6
pt_insize_trap(pt, tp)
struct pt2d *pt, *tp;
{
	vect_t lv, lp, rv, rp, result;
	/* form vector of left edge of trap */
	/* form vector from left edge start to pt */
a680 2
	/* form vector of right edge of trap */
	/* form vector from right edge start to pt */
a681 2
	VCROSS(result, lv, lp);
	/* if Z component is negative, point is inside */
a682 3
	VCROSS(result, rv, rp);
	/* if Z component is negative, point is inside */
	
a683 1
}
d690 1
a690 1
 *	      V
d694 4
a697 4
struct trap
type2vertex(pt, tbl2d, trap)
struct pt2d *pt, *tbl2d;
struct trap *trap;
d699 3
a701 1
	struct trap *tp, *save;
d704 1
a704 1
		fprintf(stderr, "%g %g is type 2 vertex\n", 
d707 12
a718 11
#if 0

	save = (struct trap *)NULL;
	for (RT_LIST_FOR(tp, trap, &partial->l)) {
		if (PleV(tp, pt))
			save = tp;

		if (pt_inside_trap(pt, tp)) {
			/* finish this trapezoid & start 2 new ones */
			/* XXX */
			return;
a719 7
	}
#endif
	(void)fprintf(stderr,
		"%s %d Didn't find trapezoid for type 2 vertex\n",
		__FILE__, __LINE__);
	abort();
}
d721 3
a723 15
/*	Polygon point start.
 *
 *	  O
 *	 /-\
 *	/---\
 *	    V
 *
 *	start new trapezoid
 */
struct trap
type3vertex(pt, tbl2d, trap)
struct pt2d *pt, *tbl2d;
struct trap *trap;
{
	struct trap *tp;
d725 4
a728 25
	if (tri_debug)
		fprintf(stderr, "%g %g is type 3 vertex\n",
				pt->coord[X], pt->coord[Y]);

	/* make a single new trapezoid */
	tp = (struct trap *)
		rt_calloc(1, sizeof(struct trap), "new trapezoid");

	tp->top_v = pt;
	tp->eu_l = pt->vu_p->up.eu_p;
	tp->eu_r = RT_LIST_PLAST_CIRC(edgeuse, pt->vu_p->up.eu_p);
	tp->magic = NMG_TRAP_MAGIC;


	pt->trap1 = tp;
	pt->trap2 = (struct trap *)NULL;


	if (RT_LIST_LAST_MAGIC(&pt->l) != RT_LIST_HEAD_MAGIC) {
		struct pt2d *prev_pt;
		struct trap *parent_trap;	/* disney movie */

		/* attach this trapezoid to the "np" pointer of the
		 * right-most trapezoid of the previous vertex
		 * in the sorted list.
d730 10
d741 10
a750 1
		prev_pt = RT_LIST_LAST(trap, &pt->l);
d752 1
a752 4
		if (prev_pt->trap2)
			parent_trap = prev_pt->trap2;
		else
			parent_trap = prev_pt->trap1;
a753 1
		parent_trap->np = tp;
d756 5
d762 7
a768 2
	if (tri_debug)
		nmg_pr_trap("New trapezoid", tp, tbl2d);
d770 7
a776 2
	return (tp);

d779 1
d792 4
a795 4
struct trap
type4vertex(pt, tbl2d, trap)
struct pt2d *pt, *tbl2d;
struct trap *trap;
d797 2
a798 4
	if (tri_debug)
		fprintf(stderr, "%g %g is type 4 vertex\n",
			pt->coord[X], pt->coord[Y]);
}
a799 19


/*	Polygon point end.
 *
 *	     ^
 *	\---/
 *	 \-/
 *	  O
 *
 *	complete trapezoid
 */
struct trap
type5vertex(pt, tbl2d, trap)
struct pt2d *pt, *tbl2d;
struct trap *trap;
{
	struct trap *tp;
	struct edgeuse *my_left, *my_right;

d801 1
a801 1
		fprintf(stderr, "%g %g is type 5 vertex\n",
d804 4
a807 2
	my_right = pt->vu_p->up.eu_p;
	my_left = RT_LIST_PLAST_CIRC(edgeuse,  pt->vu_p->up.eu_p);
d809 14
a822 1
	/* find the trapezoid which has these two edges in it */
d824 16
d841 3
a843 1
	/* complete the trapezoid */
d845 1
d847 11
d859 2
a860 4
	(void)fprintf(stderr,
		"%s %d Didn't find trapezoid for type 5 vertex\n",
		__FILE__, __LINE__);
	abort();
d871 2
a872 2
nmg_trap_face(tbl2d)
struct pt2d *tbl2d;
a874 2
	struct trap *traptree
	
d876 1
a876 2

	for (RT_LIST_FOR(pt, pt2d, &tbl2d[0].l)) {
d879 2
a880 2
		case 1:
			type1vertex(pt, tbl2d, traptree);
d882 2
a883 2
		case 2:
			type2vertex(pt, tbl2d, traptree);
d885 2
a886 5
		case 3:
			if (!traptree)
				traptree = type3vertex(pt, tbl2d, traptree);
			else
				(void)type3vertex(pt, tbl2d, traptree);
d888 2
a889 2
		case 4:
			type4vertex(pt, tbl2d, traptree);
d891 2
a892 2
		case 5:
			type5vertex(pt, tbl2d, traptree);
d895 1
a895 1
			fprintf(stderr, "%g %g is UNKNOWN type vertex\n",
d904 4
a907 3
void
nmg_triangulate_face(fu)
struct faceuse *fu;
d909 2
a910 2
	mat_t TformMat;
	struct pt2d *tbl2d;
d912 7
a918 2
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		nmg_split_touchingloops(lu);
d920 3
d924 5
a928 1
	tbl2d = nmg_flatten_face(fu, TformMat);
d930 7
a936 1
	nmg_plot_flat_face(fu, tbl2d, "tri1.pl");
d938 2
a939 1
	nmg_trap_face(tbl2d);
d941 48
a988 1
	rt_free((char *)tbl2d, "discard tbl2d");
d991 268
d1260 1
a1260 1
nmg_plot_flat_face(fu, tbl2d, filename)
d1262 1
a1262 2
struct pt2d *tbl2d;
char *filename;
d1266 3
d1270 3
a1272 3
	if ((plot_fd=fopen(filename, "w")) == (FILE *)NULL) {
		perror(filename);
		abort();
d1275 8
a1282 1
	pd_3space(plot_fd, -300.0, -300.0, -1.0, 100.0, 100.0, 1.0);
d1284 3
a1286 1
	pl_color(plot_fd, 200, 200, 200);
d1288 15
a1302 2
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		if (RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC)
d1304 2
d1307 1
a1307 1
			register struct edgeuse *eu_p;
d1309 1
a1309 1
			eu_p = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);
d1311 24
a1334 3
			pdv_3line(plot_fd,
				    tbl2d[eu->vu_p->index].coord,
				    tbl2d[eu_p->vu_p->index].coord);
d1338 79
@
