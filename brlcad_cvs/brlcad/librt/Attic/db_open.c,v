head	11.48;
access;
symbols
	ansi-20040405-merged:11.42.2.2
	postmerge-20040405-ansi:11.45
	premerge-20040404-ansi:11.44
	postmerge-autoconf:11.44
	autoconf-freeze:11.42.10.3
	premerge-autoconf:11.44
	ansi-20040316-freeze:11.42.2.1
	postmerge-20040315-windows:11.44
	premerge-20040315-windows:11.43
	windows-20040315-freeze:11.42.4.2
	autoconf-20031203:11.42
	autoconf-20031202:11.42
	autoconf-branch:11.42.0.10
	phong-branch:11.42.0.8
	photonmap-branch:11.42.0.6
	rel-6-1-DP:11.42
	windows-branch:11.42.0.4
	rel-6-0-2:11.40
	ansi-branch:11.42.0.2
	rel-6-0-1-branch:11.40.0.2
	hartley-6-0-post:11.41
	hartley-6-0-pre:11.40
	rel-6-0-1:11.40
	rel-6-0:11.40
	rel-5-4:11.20.2.3
	offsite-5-3-pre:11.35
	rel-5-3:11.20.2.3
	rel-5-2:11.20.2.1
	rel-5-1-branch:11.20.0.2
	rel-5-1:11.20
	rel-5-0:11.9
	rel-5-0-beta:11.9
	rel-4-5:11.7
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.48
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	11.47;

11.47
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.46;

11.46
date	2004.05.04.18.39.42;	author morrison;	state Exp;
branches;
next	11.45;

11.45
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.44;

11.44
date	2004.03.16.20.03.08;	author morrison;	state Exp;
branches;
next	11.43;

11.43
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	11.42;

11.42
date	2002.08.20.17.07.57;	author jra;	state Exp;
branches
	11.42.2.1
	11.42.4.1
	11.42.10.1;
next	11.41;

11.41
date	2002.08.15.20.55.10;	author hartley;	state Exp;
branches;
next	11.40;

11.40
date	2001.10.04.15.28.22;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	2001.05.17.20.05.23;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2001.04.20.22.29.41;	author morrison;	state Exp;
branches;
next	11.37;

11.37
date	2001.03.23.22.05.30;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	2001.03.19.22.19.57;	author butler;	state Exp;
branches;
next	11.35;

11.35
date	2001.03.16.19.33.43;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	2001.03.16.14.45.23;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	2001.01.24.15.57.15;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	2000.11.01.20.37.16;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	2000.09.08.05.54.41;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	2000.08.24.22.02.35;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.08.24.18.05.34;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	2000.07.25.16.50.47;	author butler;	state Exp;
branches;
next	11.27;

11.27
date	2000.07.25.16.46.06;	author butler;	state Exp;
branches;
next	11.26;

11.26
date	2000.07.20.23.23.15;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.07.13.02.21.57;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.07.13.01.13.24;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.07.10.23.01.28;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.07.08.01.55.21;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.06.29.18.20.55;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.03.03.01.00.20;	author mike;	state Exp;
branches
	11.20.2.1;
next	11.19;

11.19
date	2000.03.02.03.50.56;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.01.12.21.38.41;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.01.07.04.21.05;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	99.12.30.22.53.24;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.12.30.04.56.59;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	99.12.29.18.45.23;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	99.12.29.18.24.01;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	99.12.22.04.58.32;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.12.22.04.57.12;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.12.22.02.01.50;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	98.05.12.17.44.20;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	98.03.26.07.42.50;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.12.16.06.09.51;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.10.09.02.57.23;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.05.20.21.54.19;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.02.14.21.50.55;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.01.29.20.59.13;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.17;	author mike;	state Rel4_4;
branches;
next	10.9;

10.9
date	94.12.27.16.56.58;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.11.05.05.38.49;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.11.04.05.38.35;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.09.28.02.54.54;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.23.17.26.30;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.08.10.18.01.40;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	93.10.28.23.43.28;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.10.28.21.28.20;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.03;	author mike;	state Rel4_0;
branches;
next	9.9;

9.9
date	91.09.27.05.51.32;	author butler;	state Exp;
branches;
next	9.8;

9.8
date	91.08.30.23.08.56;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.08.30.01.22.23;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.07.06.00.53.01;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.07.05.23.46.40;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.01.12.06.51.03;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.05.21.21.10.19;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.05.21.14.24.11;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.55.45;	author mike;	state Rel3_5;
branches;
next	1.3;

1.3
date	88.12.08.05.28.41;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.12.08.04.45.36;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.12.06.00.09.19;	author mike;	state Exp;
branches;
next	;

11.20.2.1
date	2000.08.24.17.40.07;	author jra;	state Exp;
branches;
next	11.20.2.2;

11.20.2.2
date	2000.10.11.16.06.14;	author bparker;	state Exp;
branches;
next	11.20.2.3;

11.20.2.3
date	2001.01.24.14.45.46;	author jra;	state Exp;
branches;
next	;

11.42.2.1
date	2002.09.19.18.01.31;	author morrison;	state Exp;
branches;
next	11.42.2.2;

11.42.2.2
date	2004.03.17.21.18.44;	author morrison;	state Exp;
branches;
next	;

11.42.4.1
date	2002.09.26.23.04.01;	author morrison;	state Exp;
branches;
next	11.42.4.2;

11.42.4.2
date	2004.03.11.23.43.35;	author morrison;	state Exp;
branches;
next	;

11.42.10.1
date	2004.02.12.18.37.38;	author erikg;	state Exp;
branches;
next	11.42.10.2;

11.42.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	11.42.10.3;

11.42.10.3
date	2004.03.18.18.10.29;	author erikg;	state Exp;
branches;
next	;


desc
@db_open
@


11.48
log
@moved to src/
@
text
@/*
 *			D B _ O P E N . C
 *
 * Functions -
 *	db_open		Open the database
 *	db_create	Create a new database
 *	db_close	Close a database, releasing dynamic memory
 *
 *
 *  Authors -
 *	Michael John Muuss
 *	Robert Jon Reschly Jr.
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db_open.c,v 11.47 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#include <fcntl.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"

#ifdef HAVE_UNIX_IO
# include <sys/types.h>
# include <sys/stat.h>
#endif

#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "db.h"
#include "wdb.h"

#include "./debug.h"

#ifndef SEEK_SET
# define SEEK_SET	0
#endif

/*
 *  			D B _ O P E N
 *
 *  Open the named database.
 *  The 'mode' parameter specifies read-only or read-write mode.
 *
 *  As a convenience, dbi_filepath is a C-style argv array of dirs to search
 *  when attempting to open related files (such as data files for EBM
 *  solids or texture-maps).  The default values are "." and the
 *  directory containing the ".g" file.  They may be overriden by
 *  setting the environment variable BRLCAD_FILE_PATH.
 *
 *  Returns:
 *	DBI_NULL	error
 *	db_i *		success
 */
struct db_i *
db_open(const char *name, const char *mode)
{
	register struct db_i	*dbip = DBI_NULL;
	register int		i;

	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_open(%s, %s)\n", name, mode );

	if( mode[0] == 'r' && mode[1] == '\0' )  {
		struct bu_mapped_file	*mfp;
		/* Read-only mode */
		mfp = bu_open_mapped_file( name, "db_i" );
		if( mfp == NULL )  goto fail;

		/* Is this a re-use of a previously mapped file? */
		if( mfp->apbuf )  {
			dbip = (struct db_i *)mfp->apbuf;
			RT_CK_DBI(dbip);
			dbip->dbi_uses++;
			if(RT_G_DEBUG&DEBUG_DB)
				bu_log("db_open(%s) dbip=x%x: reused previously mapped file\n", name, dbip);
			return dbip;
		}

		BU_GETSTRUCT( dbip, db_i );
		dbip->dbi_eof = -1L;
		dbip->dbi_mf = mfp;
		dbip->dbi_eof = mfp->buflen;
		dbip->dbi_inmem = mfp->buf;
		dbip->dbi_mf->apbuf = (genptr_t)dbip;

#ifdef HAVE_UNIX_IO
		/* Do this too, so we can seek around on the file */
		if( (dbip->dbi_fd = open( name, O_RDONLY )) < 0 )
			goto fail;
		if( (dbip->dbi_fp = fdopen( dbip->dbi_fd, "r" )) == NULL )
			goto fail;
#else /* HAVE_UNIX_IO */
		if( (dbip->dbi_fp = fopen( name, "r")) == NULL )
			goto fail;
		dbip->dbi_fd = -1;
#endif
		dbip->dbi_read_only = 1;
	}  else  {
		/* Read-write mode */
		BU_GETSTRUCT( dbip, db_i );
		dbip->dbi_eof = -1L;

#		ifdef HAVE_UNIX_IO
			if( (dbip->dbi_fd = open( name, O_RDWR )) < 0 )
				goto fail;
			if( (dbip->dbi_fp = fdopen( dbip->dbi_fd, "r+w" )) == NULL )
				goto fail;
#		else /* HAVE_UNIX_IO */
			if( (dbip->dbi_fp = fopen( name, "r+w")) == NULL )
				goto fail;
			dbip->dbi_fd = -1;
#		endif
		dbip->dbi_read_only = 0;
	}

	/* Initialize fields */
	for( i=0; i<RT_DBNHASH; i++ )
		dbip->dbi_Head[i] = DIR_NULL;

	dbip->dbi_local2base = 1.0;		/* mm */
	dbip->dbi_base2local = 1.0;
	dbip->dbi_title = (char *)0;
	dbip->dbi_uses = 1;

	/* Record the filename and file path */
	dbip->dbi_filename = bu_strdup(name);

	/* XXX At some point, expand with getenv("BRLCAD_FILE_PATH"); */
	{
		char **argv = (char **)bu_malloc( 3 * sizeof(char *), "dbi_filepath[3]" );
		argv[0] = bu_strdup( "." );
		argv[1] = bu_dirname( name );
		argv[2] = NULL;
		dbip->dbi_filepath = argv;
	}

	/* determine version */
	dbip->dbi_version = db_get_version( dbip );

	bu_ptbl_init( &dbip->dbi_clients, 128, "dbi_clients[]" );
	dbip->dbi_magic = DBI_MAGIC;		/* Now it's valid */

	if(RT_G_DEBUG&DEBUG_DB)
		bu_log("db_open(%s) dbip=x%x\n", dbip->dbi_filename, dbip);
	return dbip;
fail:
	if(RT_G_DEBUG&DEBUG_DB)
		bu_log("db_open(%s) FAILED\n", name);
	if(dbip) bu_free( (char *)dbip, "struct db_i" );
	return DBI_NULL;
}

/*
 *			D B _ C R E A T E
 *
 *  Create a new database containing just a header record,
 *  regardless of whether the database previously existed or not,
 *  and open it for reading and writing.
 *
 *  New in BRL-CAD Release 6.0 is that this routine also calls
 *  db_dirbuild(), so the caller shouldn't.
 *
 *
 *  Returns:
 *	DBI_NULL	error
 *	db_i *		success
 */
struct db_i *
db_create( const char *name, int version )
{
	FILE	*fp;
	struct db_i	*dbip;

	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_create(%s, %d)\n", name, version );

	if( (fp = fopen( name, "w" )) == NULL )  {
		perror(name);
		return(DBI_NULL);
	}

	switch( version )  {
	default:
	case 5:
		/* Create a v5 database */
		if( db5_fwrite_ident(fp,"Untitled BRL-CAD Database",1.0)<0){
			(void)fclose(fp);
			return DBI_NULL;
		}
		break;
	case 4:
		/* Create a v4 database */
		if(db_fwrite_ident(fp,"Untitled BRL-CAD Database",1.0)<0) {
			(void)fclose(fp);
			return DBI_NULL;
		}
		break;
	}

	(void)fclose(fp);

	if( (dbip = db_open( name, "r+w" ) ) == DBI_NULL )
		return DBI_NULL;


	/* Do a quick scan to determine version, find _GLOBAL, etc. */
	if( db_dirbuild( dbip ) < 0 )
		return DBI_NULL;
	return dbip;
}

/*
 *			D B _ C L O S E _ C L I E N T
 *
 *  De-register a client of this database instance, and close out the instance.
 */
void
db_close_client(struct db_i *dbip, long int *client)
{
	RT_CK_DBI(dbip);
	(void)bu_ptbl_rm( &dbip->dbi_clients, client );
	db_close(dbip);
}

/*
 *			D B _ C L O S E
 *
 *  Close a database, releasing dynamic memory
 *  Wait until last user is done, though.
 */
void
db_close(register struct db_i *dbip)
{
	register int		i;
	register struct directory *dp, *nextdp;

	RT_CK_DBI(dbip);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_close(%s) x%x uses=%d\n",
		dbip->dbi_filename, dbip, dbip->dbi_uses );

	if( (--dbip->dbi_uses) > 0 )  {
		if(dbip->dbi_mf) bu_close_mapped_file( dbip->dbi_mf );
		return;
	}
	/* Use count is now zero */

	if( dbip->dbi_mf )  {
		/*
		 *  We're using an instance of a memory mapped file.
		 *  We have two choices:
		 *  Either deassociate from the memory mapped file
		 *  by clearing dbi_mf->apbuf, or
		 *  keeping our already-scanned dbip ready for
		 *  further use, with our dbi_uses counter at 0.
		 *  For speed of re-open, at the price of some address space,
		 *  the second choice is taken.
		 */
		bu_close_mapped_file( dbip->dbi_mf );
		bu_free_mapped_files( 0 );
		dbip->dbi_mf = (struct bu_mapped_file *)NULL;
	}

#ifdef HAVE_UNIX_IO
	(void)close( dbip->dbi_fd );
#endif
	fclose( dbip->dbi_fp );
	if( dbip->dbi_title )
		bu_free( dbip->dbi_title, "dbi_title" );
	if( dbip->dbi_filename )
		bu_free( dbip->dbi_filename, "dbi_filename" );

	db_free_anim( dbip );
	rt_color_free();		/* Free MaterHead list */

	/* Release map of database holes */
	rt_mempurge( &(dbip->dbi_freep) );
	rt_memclose();

	dbip->dbi_inmem = NULL;		/* sanity */

	bu_ptbl_free(&dbip->dbi_clients);

	/* Free all directory entries */
	for( i=0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; )  {
			RT_CK_DIR(dp);
			nextdp = dp->d_forw;
			RT_DIR_FREE_NAMEP(dp);	/* frees d_namep */

			/* Put 'dp' back on the freelist */
			dp->d_forw = rt_uniresource.re_directory_hd;
			rt_uniresource.re_directory_hd = dp;
			dp->d_forw = NULL;

			dp = nextdp;
		}
		dbip->dbi_Head[i] = DIR_NULL;	/* sanity*/
	}

	if (dbip->dbi_filepath != NULL) {
	  if (dbip->dbi_filepath[0] != NULL)
	    bu_free((char *)dbip->dbi_filepath[0], "dbip->dbi_filepath");
	  if (dbip->dbi_filepath[1] != NULL)
	    bu_free((char *)dbip->dbi_filepath[1], "dbip->dbi_filepath");
	  bu_free((char *)dbip->dbi_filepath, "dbip->dbi_filepath");
	}

	bu_free( (char *)dbip, "struct db_i" );
}

/*
 *			D B _ D U M P
 *
 *  Dump a full copy of one database into another.
 *  This is a good way of committing a ".inmem" database to a ".g" file.
 *  The input is a database instance, the output is a LIBWDB object,
 *  which could be a disk file or another database instance.
 *
 *  Returns -
 *	-1	error
 *	0	success
 */
int
db_dump(struct rt_wdb *wdbp, struct db_i *dbip)
             	      		/* output */
           	      		/* input */
{
	register int		i;
	register struct directory *dp;
	struct bu_external	ext;

	RT_CK_DBI(dbip);
	RT_CK_WDB(wdbp);

	/* Output all directory entries */
	for( i=0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
			RT_CK_DIR(dp);
/* XXX Need to go to internal form, if database versions don't match */
			if( db_get_external( &ext, dp, dbip ) < 0 )  {
				bu_log("db_dump() read failed on %s, skipping\n", dp->d_namep );
				continue;
			}
			if( wdb_export_external( wdbp, &ext, dp->d_namep, dp->d_flags, dp->d_minor_type ) < 0 )  {
				bu_log("db_dump() write failed on %s, aborting\n", dp->d_namep);
				bu_free_external( &ext );
				return -1;
			}
			bu_free_external( &ext );
		}
	}
	return 0;
}

/*
 *			D B _ C L O N E _ D B I
 *
 *  Obtain an additional instance of this same database.
 *  The new client is registered at the same time.
 */
struct db_i *
db_clone_dbi(struct db_i *dbip, long int *client)
{
	RT_CK_DBI(dbip);

	dbip->dbi_uses++;
	bu_ptbl_ins_unique( &dbip->dbi_clients, client );
	return dbip;
}

/*
 *			D B _ S Y N C
 *
 *  Ensure that the on-disk database has been completely written
 *  out of the operating system's cache.
 */
void
db_sync(struct db_i *dbip)
{
	RT_CK_DBI(dbip);

	bu_semaphore_acquire(BU_SEM_SYSCALL);

#  ifdef WIN32
	fflush(dbip->dbi_fp);
#  elif defined(HAVE_UNIX_IO)
	fsync(dbip->dbi_fd);
#  else
	sync();
#  endif /* WIN32 */

	bu_semaphore_release(BU_SEM_SYSCALL);
}
@


11.47
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db_open.c,v 11.46 2004/05/04 18:39:42 morrison Exp $ (BRL)";
@


11.46
log
@Modification from Bob: free the dbi_filepath when we close.  also cleaned up some of the flush logic a bit.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d27 5
a31 1
#include "conf.h"
@


11.45
log
@merge of ansi-6-0-branch into HEAD
@
text
@d319 8
a400 1
#ifdef WIN32
d402 2
d405 1
a405 5
	bu_semaphore_release(BU_SEM_SYSCALL);
#else

#ifdef HAVE_UNIX_IO
	bu_semaphore_acquire(BU_SEM_SYSCALL);
d407 1
a407 3
	bu_semaphore_release(BU_SEM_SYSCALL);
#else
	bu_semaphore_acquire(BU_SEM_SYSCALL);
d409 2
a411 2
#endif
#endif
@


11.44
log
@merge of windows-6-0-branch into head
@
text
@d76 1
a76 3
db_open( name, mode )
const char	*name;
const char	*mode;
d237 1
a237 3
db_close_client( dbip, client )
struct db_i	*dbip;
long		*client;
d251 1
a251 2
db_close( dbip )
register struct db_i	*dbip;
d335 3
a337 3
db_dump( wdbp, dbip )
struct rt_wdb	*wdbp;		/* output */
struct db_i	*dbip;		/* input */
d373 1
a373 3
db_clone_dbi( dbip, client )
struct db_i	*dbip;
long		*client;
d389 1
a389 2
db_sync( dbip )
struct db_i	*dbip;
@


11.43
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.42 2002/08/20 17:07:57 jra Exp $ (BRL)";
d30 1
d32 1
d401 6
d415 1
@


11.42
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1988 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.40 2001/10/04 15:28:22 bparker Exp $ (BRL)";
@


11.42.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.43 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


11.42.10.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.42.10.1 2004/02/12 18:37:38 erikg Exp $ (BRL)";
@


11.42.10.3
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a29 1
#ifdef HAVE_UNISTD_H
a30 1
#endif
a398 6
#ifdef WIN32
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	fflush(dbip->dbi_fp);
	bu_semaphore_release(BU_SEM_SYSCALL);
#else

a406 1
#endif
@


11.42.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.42 2002/08/20 17:07:57 jra Exp $ (BRL)";
a29 1
#ifdef HAVE_UNISTD_H
a30 1
#endif
a398 6
#ifdef WIN32
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	fflush(dbip->dbi_fp);
	bu_semaphore_release(BU_SEM_SYSCALL);
#else

a406 1
#endif
@


11.42.4.2
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/db_open.c,v 11.42.4.1 2002/09/26 23:04:01 morrison Exp $ (BRL)";
@


11.42.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.42 2002/08/20 17:07:57 jra Exp $ (BRL)";
d74 3
a76 1
db_open(const char *name, const char *mode)
d237 3
a239 1
db_close_client(struct db_i *dbip, long int *client)
d253 2
a254 1
db_close(register struct db_i *dbip)
d338 3
a340 3
db_dump(struct rt_wdb *wdbp, struct db_i *dbip)
             	      		/* output */
           	      		/* input */
d376 3
a378 1
db_clone_dbi(struct db_i *dbip, long int *client)
d394 2
a395 1
db_sync(struct db_i *dbip)
@


11.42.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a29 1
#ifdef HAVE_UNISTD_H
a30 1
#endif
a390 6
#ifdef WIN32
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	fflush(dbip->dbi_fp);
	bu_semaphore_release(BU_SEM_SYSCALL);
#else

a398 1
#endif
@


11.41
log
@Converted from K&R to ANSI C - RFH
@
text
@d74 3
a76 1
db_open(const char *name, const char *mode)
d237 3
a239 1
db_close_client(struct db_i *dbip, long int *client)
d253 2
a254 1
db_close(register struct db_i *dbip)
d338 3
a340 3
db_dump(struct rt_wdb *wdbp, struct db_i *dbip)
             	      		/* output */
           	      		/* input */
d376 3
a378 1
db_clone_dbi(struct db_i *dbip, long int *client)
d394 2
a395 1
db_sync(struct db_i *dbip)
@


11.40
log
@*- remove mention of database version in warnings
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.39 2001/05/17 20:05:23 morrison Exp $ (BRL)";
d74 1
a74 3
db_open( name, mode )
const char	*name;
const char	*mode;
d235 1
a235 3
db_close_client( dbip, client )
struct db_i	*dbip;
long		*client;
d249 1
a249 2
db_close( dbip )
register struct db_i	*dbip;
d333 3
a335 3
db_dump( wdbp, dbip )
struct rt_wdb	*wdbp;		/* output */
struct db_i	*dbip;		/* input */
d371 1
a371 3
db_clone_dbi( dbip, client )
struct db_i	*dbip;
long		*client;
d387 1
a387 2
db_sync( dbip )
struct db_i	*dbip;
@


11.39
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.38 2001/04/20 22:29:41 morrison Exp $ (BRL)";
d205 1
a205 1
		if( db5_fwrite_ident(fp,"Untitled v5 BRL-CAD Database",1.0)<0){
d212 1
a212 1
		if(db_fwrite_ident(fp,"Untitled v4 BRL-CAD Database",1.0)<0) {
@


11.38
log
@CONST to const
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.37 2001/03/23 22:05:30 jra Exp $ (BRL)";
d81 1
a81 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_open(%s, %s)\n", name, mode );
d94 1
a94 1
			if(rt_g.debug&DEBUG_DB)
d163 1
a163 1
	if(rt_g.debug&DEBUG_DB)
d167 1
a167 1
	if(rt_g.debug&DEBUG_DB)
d194 1
a194 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_create(%s, %d)\n", name, version );
d260 1
a260 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_close(%s) x%x uses=%d\n",
@


11.37
log
@Support for major and minor types in directory structure
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db_open.c,v 11.36 2001/03/19 22:19:57 butler Exp $ (BRL)";
d75 2
a76 2
CONST char	*name;
CONST char	*mode;
d189 1
a189 1
db_create( CONST char *name, int version )
@


11.36
log
@patches to merge 5.3 into 6.0
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db_open.c,v 11.35 2001/03/16 19:33:43 jra Exp $ (BRL)";
d358 1
a358 1
			if( wdb_export_external( wdbp, &ext, dp->d_namep, dp->d_flags ) < 0 )  {
@


11.35
log
@db_open() now calls db_get_version() to determine database version
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.34 2001/03/16 14:45:23 jra Exp $ (BRL)";
d100 1
d205 1
a205 1
		if( db5_fwrite_ident( fp, "Untitled v5 BRL-CAD Database", 1.0 ) < 0 )  {
d212 1
a212 1
		if( db_fwrite_ident( fp, "Untitled v4 BRL-CAD Database", 1.0 ) < 0 )  {
d223 1
@


11.34
log
@db_open now determines the version type and fills in "dbip->dbi_version"
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.33 2001/01/24 15:57:15 jra Exp $ (BRL)";
a79 1
	unsigned char		header[8];
d157 1
a157 13
	rewind(dbip->dbi_fp);
	if( fread( header, sizeof header, 1, dbip->dbi_fp ) != 1  )  {
		bu_log("db_open(%s) ERROR, file too short to be BRL-CAD database\n",
			dbip->dbi_filename);
		goto fail;
	}

	
	if( db5_header_is_valid( header ) ) {
		dbip->dbi_version = 5;
	} else {
		dbip->dbi_version = 4;
	}
@


11.33
log
@db_close() now calls bu_free_mapped_files() and actually cleans up the db_i
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.32 2000/11/01 20:37:16 mike Exp $ (BRL)";
d80 1
d155 15
@


11.32
log
@
db_create() got version argument
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.31 2000/09/08 05:54:41 mike Exp $ (BRL)";
d276 2
a277 1
		return;
@


11.31
log
@
Modified tree routines to take resource pointer.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.30 2000/08/24 22:02:35 mike Exp $ (BRL)";
d185 1
a185 2
db_create( name )
CONST char *name;
d190 1
a190 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_create(%s, %s)\n", name );
d197 16
a212 5
#if 1
	/* Create a v5 database */
	if( db5_fwrite_ident( fp, "Untitled v5 BRL-CAD Database", 1.0 ) < 0 )  {
		(void)fclose(fp);
		return DBI_NULL;
a213 7
#else
	/* Create a v4 database */
	if( db_fwrite_ident( fp, "Untitled v4 BRL-CAD Database", 1.0 ) < 0 )  {
		(void)fclose(fp);
		return DBI_NULL;
	}
#endif
@


11.30
log
@
Removed double init.
I'm not sure previous patch actually improved anything,
db_scan is what sizes the file the first time.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.29 2000/08/24 18:05:34 jra Exp $ (BRL)";
d301 7
a307 3
			bu_free( dp->d_namep, "d_namep" );
			dp->d_namep = (char *)NULL;
			bu_free( (char *)dp, "dir");
@


11.29
log
@db_open "initialization" was clobbering dbip->dbi_eof!!!!!
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.28 2000/07/25 16:50:47 butler Exp $ (BRL)";
a99 1
		dbip->dbi_eof = -1L;
@


11.28
log
@Re-assert v5 database format default
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.27 2000/07/25 16:46:06 butler Exp $ (BRL)";
d100 1
d121 1
a139 1
	dbip->dbi_eof = -1L;
@


11.27
log
@Fixed bad practice in db5_update_ident definition: implicit int return
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.26 2000/07/20 23:23:15 mike Exp $ (BRL)";
d198 1
a198 1
#if 0
@


11.26
log
@
Expanded on comment for db_create(), noting that it now calls
db_dirbuild(), so caller shouldn't.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.25 2000/07/13 02:21:57 mike Exp $ (BRL)";
d30 1
d198 1
a198 1
#if 1
@


11.25
log
@
After creating an (empty) database, db_dirbuild() it to determine
version, locate the _GLOBAL object, etc.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.24 2000/07/13 01:13:24 mike Exp $ (BRL)";
d171 2
a172 2
 *  Create a new database containing just an IDENT record,
 *  regardless of whether it previously existed or not,
d174 3
@


11.24
log
@
Changed to use existing db_fwrite_ident()
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.23 2000/07/10 23:01:28 mike Exp $ (BRL)";
d185 1
d210 7
a216 1
	return( db_open( name, "r+w" ) );
@


11.23
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.22 2000/07/08 01:55:21 mike Exp $ (BRL)";
d200 4
a203 10
	{
		union record new;

		/* Prepare the v4 IDENT record */
		bzero( (char *)&new, sizeof(new) );
		new.i.i_id = ID_IDENT;
		new.i.i_units = ID_MM_UNIT;
		strncpy( new.i.i_version, ID_VERSION, sizeof(new.i.i_version) );
		strcpy( new.i.i_title, "Untitled MGED Database" );
		(void)fwrite( (char *)&new, 1, sizeof(new), fp );
@


11.22
log
@
Changed db_create() to make v5 databases now.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.21 2000/06/29 18:20:55 mike Exp $ (BRL)";
@


11.21
log
@
Changed from db_free_external() to bu_free_external()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.20 2000/03/03 01:00:20 mike Exp $ (BRL)";
d184 1
a184 1
	union record new;
d188 4
a191 6
	/* Prepare the IDENT record */
	bzero( (char *)&new, sizeof(new) );
	new.i.i_id = ID_IDENT;
	new.i.i_units = ID_MM_UNIT;
	strncpy( new.i.i_version, ID_VERSION, sizeof(new.i.i_version) );
	strcpy( new.i.i_title, "Untitled MGED Database" );
d193 5
a197 7
#ifdef HAVE_UNIX_IO
	{
		int	fd;
		if( (fd = creat(name, 0644)) < 0 ||
		    write( fd, (char *)&new, sizeof(new) ) != sizeof(new) )
			return(DBI_NULL);
		(void)close(fd);
d199 1
a199 1
#else /* HAVE_UNIX_IO */
d201 8
a208 3
		FILE	*fp;
		if( (fp = fopen( name, "w" )) == NULL )
			return(DBI_NULL);
a209 1
		(void)fclose(fp);
d212 2
@


11.20
log
@
Added extra CONST to dbi_filepath to please GCC compilers.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.19 2000/03/02 03:50:56 mike Exp $ (BRL)";
d333 1
d340 1
a340 1
				db_free_external( &ext );
d343 1
a343 1
			db_free_external( &ext );
@


11.20.2.1
log
@db_open was clobbering dbip->dbi_eof with an "initialization"
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.20 2000/03/03 01:00:20 mike Exp $ (BRL)";
a98 1
		dbip->dbi_eof = -1L;
a118 1
		dbip->dbi_eof = -1L;
d137 1
@


11.20.2.2
log
@Copy guts of db_create from developmental version.
This fixes a bug that shows up in MGED (i.e. Mged
was modified to use the new db_create, but was still
getting the old one).
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.20.2.1 2000/08/24 17:40:07 jra Exp $ (BRL)";
d185 1
a185 2
	FILE	*fp;
	struct db_i	*dbip;
d189 6
a194 4
	if( (fp = fopen( name, "w" )) == NULL )  {
		perror(name);
		return(DBI_NULL);
	}
d196 7
a202 5
#if 0
	/* Create a v5 database */
	if( db5_fwrite_ident( fp, "Untitled v5 BRL-CAD Database", 1.0 ) < 0 )  {
		(void)fclose(fp);
		return DBI_NULL;
d204 6
a209 3
#else
	/* Create a v4 database */
	if( db_fwrite_ident( fp, "Untitled v4 BRL-CAD Database", 1.0 ) < 0 )  {
a210 1
		return DBI_NULL;
d214 1
a214 9
	(void)fclose(fp);

	if( (dbip = db_open( name, "r+w" ) ) == DBI_NULL )
		return DBI_NULL;

	/* Do a quick scan to determine version, find _GLOBAL, etc. */
	if( db_dirbuild( dbip ) < 0 )
		return DBI_NULL;
	return dbip;
@


11.20.2.3
log
@db_close() now calls bu_free_mapped_files() and actually cleans up the db_i
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.20.2.2 2000/10/11 16:06:14 bparker Exp $ (BRL)";
d270 1
a270 2
		bu_free_mapped_files( 0 );
		dbip->dbi_mf = (struct bu_mapped_file *)NULL;
@


11.19
log
@
Changed to use dbi_filepath
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.18 2000/01/12 21:38:41 mike Exp $ (BRL)";
d147 7
a153 4
	dbip->dbi_filepath = (char **)bu_malloc( 3 * sizeof(char *), "dbi_filepath[3]" );
	dbip->dbi_filepath[0] = bu_strdup( "." );
	dbip->dbi_filepath[1] = bu_dirname( name );
	dbip->dbi_filepath[2] = NULL;
@


11.18
log
@
Improved efficiency of db_open() by postponing BU_GETSTRUCT() when
not needed, and eliminating stat() call.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.17 2000/01/07 04:21:05 mike Exp $ (BRL)";
d62 6
d143 1
d145 7
@


11.17
log
@
Eliminated dbi_localunit.  This is a v4 database anachronism.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.16 1999/12/30 22:53:24 mike Exp $ (BRL)";
d71 1
a71 1
	register struct db_i	*dbip;
a72 3
#ifdef HAVE_UNIX_IO
	struct stat		sb;
#endif
a75 16
	BU_GETSTRUCT( dbip, db_i );

	for( i=0; i<RT_DBNHASH; i++ )
		dbip->dbi_Head[i] = DIR_NULL;

	dbip->dbi_eof = -1L;
	dbip->dbi_local2base = 1.0;		/* mm */
	dbip->dbi_base2local = 1.0;
	dbip->dbi_title = (char *)0;
	dbip->dbi_uses = 1;

#ifdef HAVE_UNIX_IO
	if( stat( name, &sb ) < 0 )
		goto fail;
#endif

a83 1
			bu_free( (genptr_t)dbip, "db_open: unwanted db_i");
d92 1
d112 2
d127 10
d147 1
a147 1
	bu_free( (char *)dbip, "struct db_i" );
@


11.16
log
@
Added db_sync(), as a less costly replacement for sync(),
which on machines O200 machines like CAD can take 20 seconds.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.15 1999/12/30 04:56:59 mike Exp $ (BRL)";
d85 1
a85 2
	dbip->dbi_localunit = 0;		/* mm */
	dbip->dbi_local2base = 1.0;
@


11.15
log
@
Additional datastructures to support the submodel.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.14 1999/12/29 18:45:23 mike Exp $ (BRL)";
d355 23
@


11.14
log
@
Installed matching code in db_close() to keep existing databases around.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.13 1999/12/29 18:24:01 mike Exp $ (BRL)";
d146 1
d208 15
d239 4
a242 1
	if( (--dbip->dbi_uses) > 0 )  return;
d256 1
d276 3
a278 1
	/* dbi_inmem */
d337 18
@


11.13
log
@
Fixed dbip sharing
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.12 1999/12/22 04:58:32 mike Exp $ (BRL)";
d224 15
@


11.12
log
@
Removed unnecessary defines and includes
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.11 1999/12/22 04:57:12 mike Exp $ (BRL)";
d97 1
d99 2
a100 2
		dbip->dbi_mf = bu_open_mapped_file( name, "db_i" );
		if( dbip->dbi_mf == NULL )  goto fail;
d103 1
a103 1
		if( dbip->dbi_mf->apbuf )  {
d105 1
a105 1
			dbip = (struct db_i *)dbip->dbi_mf->apbuf;
d113 3
a115 2
		dbip->dbi_eof = dbip->dbi_mf->buflen;
		dbip->dbi_inmem = dbip->dbi_mf->buf;
@


11.11
log
@
db_open(file,"r") now uses bu_open_mapped_file().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.10 1999/12/22 02:01:50 mike Exp $ (BRL)";
a43 4
#ifdef HAVE_SYS_MMAN_H
# include <sys/mman.h>
#endif

a53 27
#endif

/*
 *  This constant determines what the maximum size database is that
 *  will be buffered entirely in memory.
 *  Architecture constraints suggest different values for each vendor.
 */
#ifdef CRAY1
#	define	INMEM_LIM	1*1024*1024	/* includes XMP */
#endif
#ifdef CRAY2
#	define	INMEM_LIM	32*8*1024*1024
#endif
#ifdef sun
#	define	INMEM_LIM	1*1024*1024
#endif
#ifdef gould
#	define	INMEM_LIM	1*1024*1024
#endif
#ifdef vax
#	define	INMEM_LIM	8*1024*1024
#endif
#if (defined(sgi) && defined(mips)) || (defined(__sgi) && defined(__mips))
#	define	INMEM_LIM	8*1024*1024
#endif
#if !defined(INMEM_LIM)
#	define	INMEM_LIM	1*1024*1024	/* default */
@


11.10
log
@
Removed unused vars
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_open.c,v 11.9 1998/05/12 17:44:20 mike Exp $ (BRL)";
d129 18
d148 1
a148 1
		if( sb.st_size == 0 )  goto fail;
a152 30

#		ifdef HAVE_SYS_MMAN_H
			/* Attempt to access as memory-mapped file */
			dbip->dbi_eof = sb.st_size;	/* needed by db_read() */
			if( (dbip->dbi_inmem = mmap(
			    (caddr_t)0, sb.st_size, PROT_READ, MAP_PRIVATE,
			    dbip->dbi_fd, (off_t)0 )) == (caddr_t)-1L )  {
				perror("mmap");
				dbip->dbi_inmem = (char *)0;
			} else {
				if(rt_g.debug&DEBUG_DB)
					bu_log("db_open: memory mapped file, addr=x%x\n", dbip->dbi_inmem);
			}
#		endif

		if( !dbip->dbi_inmem && sb.st_size <= INMEM_LIM )  {
			dbip->dbi_inmem = bu_malloc( sb.st_size,
				"in-memory database" );
			if( read( dbip->dbi_fd, dbip->dbi_inmem,
			    sb.st_size ) != sb.st_size )
				goto fail;

			/* Lseek required by Linux to get "fd" and "fp"
			   in agreement at start of file */
			if( lseek( dbip->dbi_fd, 0, SEEK_SET ) == (-1) )
				goto fail;
			dbip->dbi_eof = sb.st_size;	/* needed by db_read() */
			if(rt_g.debug&DEBUG_DB)
				bu_log("db_open: in-memory file\n");
		}
@


11.9
log
@Added ".inmem dump" directive to Tcl interface,
to write the current state of a database out to a file.
Added db_dump() as underlying C implementation.
Added wdb_export_external() for a clean path out via LIBWDB.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 11.8 1998/03/26 07:42:50 mike Exp mike $ (BRL)";
d318 1
a318 1
	register struct directory *dp, *nextdp;
@


11.8
log
@Honor dbi_uses use-count protocol.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 11.7 1997/12/16 06:09:51 mike Exp mike $ (BRL)";
d52 1
d99 2
a100 2
char	*name;
char	*mode;
d213 1
a213 1
char *name;
d298 43
@


11.7
log
@Ran h/sed4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 11.6 1997/10/09 02:57:23 mike Exp mike $ (BRL)";
d119 1
d250 1
d259 5
a263 3
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_close:  bad dbip\n");
	if(rt_g.debug&DEBUG_DB) bu_log("db_close(%s) x%x\n",
		dbip->dbi_filename, dbip );
@


11.6
log
@VGR port
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 11.5 1997/05/20 21:54:19 mike Exp mike $ (BRL)";
d149 1
a149 1
			dbip->dbi_inmem = rt_malloc( sb.st_size,
d193 1
a193 1
	rt_free( (char *)dbip, "struct db_i" );
d266 1
a266 1
		rt_free( dbip->dbi_title, "dbi_title" );
d268 1
a268 1
		rt_free( dbip->dbi_filename, "dbi_filename" );
d284 1
a284 1
			rt_free( dp->d_namep, "d_namep" );
d286 1
a286 1
			rt_free( (char *)dp, "dir");
d292 1
a292 1
	rt_free( (char *)dbip, "struct db_i" );
@


11.5
log
@externs.h needs to go before raytrace.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 11.4 1996/09/27 08:27:30 mike Exp mike $ (BRL)";
d54 4
@


11.4
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 11.3 1996/02/14 21:50:55 jra Exp mike $ (BRL)";
d48 1
a51 1
#include "externs.h"
@


11.3
log
@Added missing "dbip->dbi_eof = sb.st_size" to db_open().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 11.2 1996/01/29 20:59:13 jra Exp jra $ (BRL)";
d103 1
a103 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_open(%s, %s)\n", name, mode );
d105 1
a105 1
	GETSTRUCT( dbip, db_i );
d140 1
a140 1
					rt_log("db_open: memory mapped file, addr=x%x\n", dbip->dbi_inmem);
d157 1
a157 1
				rt_log("db_open: in-memory file\n");
d180 1
a180 1
	dbip->dbi_filename = rt_strdup(name);
d184 1
a184 1
		rt_log("db_open(%s) dbip=x%x\n", dbip->dbi_filename, dbip);
d188 1
a188 1
		rt_log("db_open(%s) FAILED\n", name);
d211 1
a211 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_create(%s, %s)\n", name );
d254 1
a254 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_close(%s) x%x\n",
@


11.2
log
@Added lseek (rewind) for Linux.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 11.1 1995/01/04 09:56:17 mike Rel4_4 jra $ (BRL)";
d155 1
@


11.1
log
@Release_4.4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 10.9 94/12/27 16:56:58 mike Exp $ (BRL)";
d149 5
@


10.9
log
@Fixed bug #247, added rt_ prefix to memalloc(), etc.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 10.8 94/11/05 05:38:49 mike Exp Locker: mike $ (BRL)";
@


10.8
log
@Minor cleanups while debugging on Irix 6.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 10.7 94/11/04 05:38:35 mike Exp Locker: mike $ (BRL)";
d264 2
a265 2
	mempurge( &(dbip->dbi_freep) );
	memclose();
@


10.7
log
@Irix 6
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 10.6 94/09/28 02:54:54 mike Exp Locker: mike $ (BRL)";
d130 13
a142 13
#ifdef HAVE_SYS_MMAN_H
		/* Attempt to access as memory-mapped file */
		dbip->dbi_eof = sb.st_size;	/* needed by db_read() */
		if( (dbip->dbi_inmem = mmap(
		    (caddr_t)0, sb.st_size, PROT_READ, MAP_PRIVATE,
		    dbip->dbi_fd, (off_t)0 )) == (caddr_t)-1L )  {
			perror("mmap");
			dbip->dbi_inmem = (char *)0;
		} else {
			if(rt_g.debug&DEBUG_DB)
				rt_log("db_open: memory mapped file\n");
		}
#endif
d161 10
a170 10
#ifdef HAVE_UNIX_IO
		if( (dbip->dbi_fd = open( name, O_RDWR )) < 0 )
			goto fail;
		if( (dbip->dbi_fp = fdopen( dbip->dbi_fd, "r+w" )) == NULL )
			goto fail;
#else /* HAVE_UNIX_IO */
		if( (dbip->dbi_fp = fopen( name, "r+w")) == NULL )
			goto fail;
		dbip->dbi_fd = -1;
#endif
d177 3
a179 1
	return(dbip);
d181 2
d184 1
a184 1
	return( DBI_NULL );
@


10.6
log
@Added code to check for going off the end of the file when
using memory mapped files or inmem files.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 10.5 94/08/23 17:26:30 gdurf Exp Locker: mike $ (BRL)";
d135 1
a135 1
		    dbip->dbi_fd, (off_t)0 )) == (caddr_t)-1 )  {
@


10.5
log
@Fix typo
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 10.4 1994/08/10 18:01:40 gdurf Exp gdurf $ (BRL)";
a105 1
	dbip->dbi_magic = DBI_MAGIC;
d107 9
d132 1
a173 8
	for( i=0; i<RT_DBNHASH; i++ )
		dbip->dbi_Head[i] = DIR_NULL;

	dbip->dbi_eof = -1L;
	dbip->dbi_localunit = 0;		/* mm */
	dbip->dbi_local2base = 1.0;
	dbip->dbi_base2local = 1.0;
	dbip->dbi_title = (char *)0;
d175 1
@


10.4
log
@Factored ifdefs
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 10.3 1993/10/28 23:43:28 mike Exp gdurf $ (BRL)";
d39 1
a39 1
#ifdef USE_UNIX_IO
@


10.3
log
@Expanded db_close() to release more of the dbip related dyanmic memory.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 10.2 93/10/28 21:28:20 mike Exp Locker: mike $ (BRL)";
d27 2
d31 3
a33 1
#ifdef BSD
a34 2
#else
#include <string.h>
d37 1
a37 1
#include "machine.h"	/* before looking at __unix */
d39 1
a39 1
#if defined(unix) || defined(__unix) || defined(__unix__)
d44 1
a44 1
#if (defined(sgi) && defined(mips)) || (defined(__sgi) && defined(__mips))
d99 1
a99 1
#if defined(unix) || defined(__unix) || defined(__unix__)
d108 1
a108 1
#if defined(unix) || defined(__unix) || defined(__unix__)
d115 34
a148 34
#		if defined(unix) || defined(__unix) || defined(__unix__)
			if( sb.st_size == 0 )  goto fail;
			if( (dbip->dbi_fd = open( name, O_RDONLY )) < 0 )
				goto fail;
			if( (dbip->dbi_fp = fdopen( dbip->dbi_fd, "r" )) == NULL )
				goto fail;

#			if (defined(sgi) && defined(mips)) || (defined(__sgi) && defined(_mips))
			/* Attempt to access as memory-mapped file */
			if( (dbip->dbi_inmem = mmap(
			    (caddr_t)0, sb.st_size, PROT_READ, MAP_PRIVATE,
			    dbip->dbi_fd, (off_t)0 )) == (caddr_t)-1 )  {
				perror("mmap");
				dbip->dbi_inmem = (char *)0;
			} else {
				if(rt_g.debug&DEBUG_DB)
					rt_log("db_open: memory mapped file\n");
			}
#endif

			if( !dbip->dbi_inmem && sb.st_size <= INMEM_LIM )  {
				dbip->dbi_inmem = rt_malloc( sb.st_size,
					"in-memory database" );
				if( read( dbip->dbi_fd, dbip->dbi_inmem,
				    sb.st_size ) != sb.st_size )
					goto fail;
				if(rt_g.debug&DEBUG_DB)
					rt_log("db_open: in-memory file\n");
			}
#		else
			if( (dbip->dbi_fp = fopen( name, "r")) == NULL )
				goto fail;
			dbip->dbi_fd = -1;
#		endif
d152 10
a161 10
#		if defined(unix) || defined(__unix) || defined(__unix__)
			if( (dbip->dbi_fd = open( name, O_RDWR )) < 0 )
				goto fail;
			if( (dbip->dbi_fp = fdopen( dbip->dbi_fd, "r+w" )) == NULL )
				goto fail;
#		else
			if( (dbip->dbi_fp = fopen( name, "r+w")) == NULL )
				goto fail;
			dbip->dbi_fd = -1;
#		endif
d208 1
a208 1
#	if defined(unix) || defined(__unix) || defined(__unix__)
d216 1
a216 1
#	else
d224 1
a224 1
#	endif
d245 1
a245 1
#if defined(unix) || defined(__unix) || defined(__unix__)
@


10.2
log
@Expanded db_close()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 10.1 91/10/12 06:40:03 mike Rel4_0 Locker: mike $ (BRL)";
d253 1
d255 4
a258 1
	/* dbi_freep */
d264 1
d266 2
@


10.1
log
@Release_4.0
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 9.9 91/09/27 05:51:32 butler Exp $ (BRL)";
d251 5
@


9.9
log
@added __unix__ to list of symbols checked.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 9.8 91/08/30 23:08:56 mike Exp Locker: butler $ (BRL)";
@


9.8
log
@Needs externs.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 9.7 91/08/30 01:22:23 mike Exp $ (BRL)";
d37 1
a37 1
#if defined(unix) || defined(__unix)
d97 1
a97 1
#if defined(unix) || defined(__unix)
d106 1
a106 1
#if defined(unix) || defined(__unix)
d113 1
a113 1
#		if defined(unix) || defined(__unix)
d150 1
a150 1
#		if defined(unix) || defined(__unix)
d206 1
a206 1
#	if defined(unix) || defined(__unix)
d243 1
a243 1
#if defined(unix) || defined(__unix)
@


9.7
log
@include machine.h before looking at __unix
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 9.6 91/07/06 00:53:01 mike Exp $ (BRL)";
d49 1
@


9.6
log
@More careful about defined() checking
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 9.5 91/07/05 23:46:40 mike Exp $ (BRL)";
d35 2
a45 1
#include "machine.h"
@


9.5
log
@Made read-only open on 0-length database return failure.
Mostly so that benchmarks being run on 0-length databases
because of some error building asc2g don't give really obscure
error messages in librt.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 9.4 91/01/12 06:51:03 mike Exp $ (BRL)";
d35 1
a35 1
#ifdef unix
d40 1
a40 1
#if defined(sgi) && defined(mips)
d71 1
a71 1
#if defined(sgi) && defined(mips)
d95 1
a95 1
#if unix
d104 1
a104 1
#if unix
d111 1
a111 1
#		if unix
d118 1
a118 1
#			if defined(sgi) && defined(mips)
d148 1
a148 1
#		if unix
d204 1
a204 1
#	if unix
d241 1
a241 1
#if unix
@


9.4
log
@Eliminated extra declaration of mmap().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 9.3 90/05/21 21:10:19 mike Exp $ (BRL)";
d112 1
@


9.3
log
@Support for memory mapped files, on the SGI.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 9.2 90/05/21 14:24:11 mike Exp $ (BRL)";
a41 1
extern caddr_t	mmap();
@


9.2
log
@lint
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_open.c,v 9.1 89/05/19 05:55:45 mike Rel3_5 $ (BRL)";
d40 5
d72 2
a73 2
#ifdef mips
#	define	INMEM_LIM	2*1024*1024
d117 15
a131 1
			if( sb.st_size <= INMEM_LIM )  {
d137 2
@


9.1
log
@Release_3.5
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: db_open.c,v 1.3 88/12/08 05:28:41 mike Exp $ (BRL)";
a172 2
	int	fd;
	FILE	*fp;
d184 2
d190 1
d192 2
d198 1
@


1.3
log
@XMP values of INMEM_LIM were too generous
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: db_open.c,v 1.2 88/12/08 04:45:36 mike Locked $ (BRL)";
@


1.2
log
@Added dbi_inmem capability, to buffer read-only databases
in memory, if they are small enough.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: db_open.c,v 1.1 88/12/06 00:09:19 mike Locked $ (BRL)";
d53 1
a53 1
#	define	INMEM_LIM	1*8*1024*1024	/* includes XMP */
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/libdb/RCS/open.c,v 1.5 88/10/23 13:54:43 mike Exp $ (BRL)";
d35 5
d48 27
d91 3
d100 5
d112 7
@
