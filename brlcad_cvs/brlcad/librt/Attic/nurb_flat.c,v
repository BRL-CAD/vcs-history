head	11.9;
access;
symbols
	ansi-20040405-merged:11.5.2.2
	postmerge-20040405-ansi:11.7
	premerge-20040404-ansi:11.6
	postmerge-autoconf:11.6
	autoconf-freeze:11.5.10.1
	premerge-autoconf:11.6
	ansi-20040316-freeze:11.5.2.1
	postmerge-20040315-windows:11.6
	premerge-20040315-windows:11.6
	windows-20040315-freeze:11.5.4.1
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.4
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.3
	offsite-5-3-pre:11.3
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.9
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.8;

11.8
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.7;

11.7
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.08.07;	author jra;	state Exp;
branches
	11.5.2.1
	11.5.4.1
	11.5.10.1;
next	11.4;

11.4
date	2002.08.15.20.55.19;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	99.06.03.01.39.15;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.12.01.02.49.33;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.46;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	10.7;

10.7
date	94.08.11.01.11.54;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	92.06.03.01.29.52;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.05.29.01.20.03;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.05.29.00.52.23;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.05.28.22.12.08;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.27.16.57.54;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.07;	author mike;	state Rel4_0;
branches;
next	1.4;

1.4
date	91.07.03.02.23.54;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.06.23.03.42.19;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.06.14.09.42.14;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	91.05.18.02.35.27;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.5.2.1
date	2002.09.19.18.01.43;	author morrison;	state Exp;
branches;
next	11.5.2.2;

11.5.2.2
date	2004.03.17.21.18.55;	author morrison;	state Exp;
branches;
next	;

11.5.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.5.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	;


desc
@Flatness checking
@


11.9
log
@moved to src/
@
text
@/* 
 *       N U R B _ F L A T . C
 *
 * Function -
 *     Tests the NURB surface to see if its flat depending
 *     on the epsilon passed.
 * 
 * Author -
 *     Paul R. Stay
 *
 * Source -
 *     SECAD/VLD Computing Consortium, Bldg 394
 *     The U.S. Army Ballistic Research Laboratory
 *     Aberdeen Proving Ground, Maryland 21005
 *
 * Copyright Notice -
 *     This software is Copyright (C) 1990-2004 by the United States Army.
 *     All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "nurb.h"

int
rt_nurb_s_flat(struct face_g_snurb *srf, fastf_t epsilon)
                         
                		/* Epsilon value for flatness testing */
{
	register fastf_t 	max_row_dist;
	register fastf_t 	max_col_dist;
	register fastf_t 	max_dist;
	int	dir;
	fastf_t        * mesh_ptr = srf->ctl_points;
	int	coords = RT_NURB_EXTRACT_COORDS(srf->pt_type);
	int	j, i, k;
	int	mesh_elt;
	vect_t          p1, p2, p3, p4, v1, v2, v3;
	vect_t          nrm;
	fastf_t         nrmln;
	fastf_t         dist;
	fastf_t        * crv;
	fastf_t 	spl_crv_flat();
	int	otherdir;

	dir = srf->dir;

	otherdir = (dir == RT_NURB_SPLIT_ROW) ? RT_NURB_SPLIT_COL : RT_NURB_SPLIT_ROW;

	max_row_dist = max_col_dist = -INFINITY;

	crv = (fastf_t * ) bu_malloc( sizeof(fastf_t) * 
	    RT_NURB_EXTRACT_COORDS(srf->pt_type) * srf->s_size[1], 
	    "rt_nurb_s_flat: crv");

	/* Test Row and RT_NURB_SPLIT_COL curves for flatness, 
	 * If a curve is not flat than get distance to line */

	/* Test Row Curves */

	for (i = 0; i < (srf->s_size[0]); i++) {
		fastf_t rdist;
		for (j = 0; 
		    j < (srf->s_size[1] * 
			RT_NURB_EXTRACT_COORDS(srf->pt_type)); 
		    j++)
			crv[j] = *mesh_ptr++;

		rdist = rt_nurb_crv_flat(crv, srf->s_size[1], 
		    srf->pt_type);
		max_row_dist = MAX(max_row_dist, rdist);
	}

	bu_free( (char *)crv, "rt_nurb_s_flat: crv" );

	crv = (fastf_t * ) bu_malloc(sizeof(fastf_t) * 
	    RT_NURB_EXTRACT_COORDS(srf->pt_type) *  
	    srf->s_size[0], 	"rt_nurb_s_flat: crv");

	for (i = 0; i < (coords * srf->s_size[1]); i += coords) {
		fastf_t rdist;

		for (j = 0; j < (srf->s_size[0]); j++) {
			mesh_elt = 
			    (j * (srf->s_size[1] * coords)) + i;

			for (k = 0; k < coords; k++)
				crv[j * coords + k] = 
				    srf->ctl_points[mesh_elt + k];
		}

		rdist = rt_nurb_crv_flat(crv, 
		    srf->s_size[0], srf->pt_type);

		max_col_dist = MAX( max_col_dist, rdist);
	}

	bu_free((char *)crv, "rt_nurb_s_flat: crv");

	max_dist = MAX( max_row_dist, max_col_dist);

	if ( max_dist > epsilon) {
		if ( max_row_dist > max_col_dist )
			return RT_NURB_SPLIT_ROW;
		else
			return RT_NURB_SPLIT_COL;
	}

	/* Test the corners to see if they lie in a plane. */

	/*
	 * Extract the four corners and put a plane through three of them and
	 * see how far the fourth is to the plane. 
	 */

	mesh_ptr = srf->ctl_points;

	if ( !RT_NURB_IS_PT_RATIONAL(srf->pt_type) ) {

		VMOVE(p1, mesh_ptr);
		VMOVE(p2,
		    (mesh_ptr + (srf->s_size[1] - 1) * coords));
		VMOVE(p3,
		    (mesh_ptr + 
		    ((srf->s_size[1] * 
		    (srf->s_size[0] - 1)) + 
		    (srf->s_size[1] - 1)) * coords));

		VMOVE(p4,
		    (mesh_ptr + 
		    (srf->s_size[1] * 
		    (srf->s_size[0] - 1)) * coords));
	} else
	 {
		hvect_t h1, h2, h3, h4;
	 	int	offset;

		HMOVE(h1, mesh_ptr);
		HDIVIDE( p1, h1 );

	 	offset = (srf->s_size[1] - 1) * coords;
		HMOVE(h2, mesh_ptr + offset);
		HDIVIDE( p2, h2 );

	 	offset = 
		    ((srf->s_size[1] * 
		    (srf->s_size[0] - 1)) + 
		    (srf->s_size[1] - 1)) * coords;
		HMOVE(h3, mesh_ptr + offset);
		HDIVIDE( p3, h3 );

	 	offset = 
		    (srf->s_size[1] * 
		    (srf->s_size[0] - 1)) * coords;
		HMOVE(h4, mesh_ptr + offset);
		HDIVIDE( p4, h4 );
	}

	VSUB2(v1, p2, p1);
	VSUB2(v2, p3, p1);

	VCROSS(nrm, v1, v2);

	nrmln = MAGNITUDE(nrm);
	if( nrmln < 0.0001 )			/* XXX Why this constant? */
		return RT_NURB_SPLIT_FLAT;

	VSUB2(v3, p4, p1);

	dist = fabs(VDOT( v3, nrm)) / nrmln;

	if (dist > epsilon)
		return otherdir;

	return RT_NURB_SPLIT_FLAT;		/* Must be flat */

}


fastf_t 
rt_nurb_crv_flat(fastf_t *crv, int size, int pt_type)
{
	point_t         p1, p2;
	vect_t          ln;
	int	i;
	fastf_t         dist;
	fastf_t 	max_dist;
	fastf_t         length;
	fastf_t        * c_ptr;
	vect_t          testv, xp;
	hvect_t         h1, h2;
	int	coords;
	int	rational;

	coords = RT_NURB_EXTRACT_COORDS( pt_type);
	rational = RT_NURB_IS_PT_RATIONAL( pt_type);
	max_dist = -INFINITY;

	if ( !rational) {
		VMOVE(p1, crv);
	} else	 {
		HMOVE( h1, crv);
		HDIVIDE( p1, h1);
	}

	length = 0.0;

	/*
	 * loop through all of the points until a line is found which may not
	 * be the end pts of the curve if the endpoints are the same. 
	 */
	for (i = size - 1; (i > 0) && length < SQRT_SMALL_FASTF; i--) {
		if ( !rational) {
			VMOVE(p2, (crv + (i * coords)));
		} else {
			HMOVE( h2, (crv + ( i * coords)));
			HDIVIDE( p2, h2 );
		}

		VSUB2(ln, p1, p2);
		length = MAGNITUDE(ln);
	}


	if( length >= SQRT_SMALL_FASTF )  {
		VSCALE(ln, ln, 1.0 / length);
		c_ptr = crv + coords;

		for (i = 1; i < size; i++) {
			if ( !rational ) {
				VSUB2(testv, p1, c_ptr);
			} else		    {
				HDIVIDE(h2, c_ptr);
				VSUB2( testv, p1, h2);
			}

			VCROSS(xp, testv, ln);
			dist = MAGNITUDE(xp);
			max_dist = MAX( max_dist, dist);
			c_ptr += coords;
		}
	}
	return max_dist;
}
@


11.8
log
@change conf.h to a wrapped config.h
@
text
@@


11.7
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 5
a25 1
#include "conf.h"
@


11.6
log
@update copyright to include span through 2003
@
text
@d31 3
a33 3
rt_nurb_s_flat( srf, epsilon )
struct face_g_snurb *srf;
fastf_t epsilon;		/* Epsilon value for flatness testing */
d186 1
a186 4
rt_nurb_crv_flat( crv, size, pt_type )
fastf_t *crv;
int	size;
int	pt_type;
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *     This software is Copyright (C) 1990 by the United States Army.
@


11.5.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *     This software is Copyright (C) 1990-2004 by the United States Army.
@


11.5.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *     This software is Copyright (C) 1990-2004 by the United States Army.
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d31 3
a33 3
rt_nurb_s_flat(struct face_g_snurb *srf, fastf_t epsilon)
                         
                		/* Epsilon value for flatness testing */
d186 4
a189 1
rt_nurb_crv_flat(fastf_t *crv, int size, int pt_type)
@


11.5.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *     This software is Copyright (C) 1990-2004 by the United States Army.
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d31 3
a33 3
rt_nurb_s_flat(struct face_g_snurb *srf, fastf_t epsilon)
                         
                		/* Epsilon value for flatness testing */
d186 4
a189 1
rt_nurb_crv_flat(fastf_t *crv, int size, int pt_type)
@


11.3
log
@
sed4
@
text
@d31 3
a33 3
rt_nurb_s_flat( srf, epsilon )
struct face_g_snurb *srf;
fastf_t epsilon;		/* Epsilon value for flatness testing */
d186 1
a186 4
rt_nurb_crv_flat( crv, size, pt_type )
fastf_t *crv;
int	size;
int	pt_type;
@


11.2
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d57 1
a57 1
	crv = (fastf_t * ) rt_malloc( sizeof(fastf_t) * 
d79 1
a79 1
	rt_free( (char *)crv, "rt_nurb_s_flat: crv" );
d81 1
a81 1
	crv = (fastf_t * ) rt_malloc(sizeof(fastf_t) * 
d103 1
a103 1
	rt_free((char *)crv, "rt_nurb_s_flat: crv");
@


11.1
log
@Release_4.4
@
text
@d32 1
a32 1
struct snurb *srf;
@


11.1.1.1
log
@Release_4.5
@
text
@d32 1
a32 1
struct face_g_snurb *srf;
@


10.7
log
@Added includes
@
text
@@


10.6
log
@Made epsilon values explicit.
@
text
@d21 2
d27 1
@


10.5
log
@Control polygon/mesh is now just part of the cnurb/snurb structures,
rather than being a separate structure of their own.
@
text
@d167 1
a167 2

	if (APX_EQ(nrmln, 0.0))
d217 1
a217 1
	for (i = size - 1; (i > 0) && APX_EQ(length, 0.0); i--) {
d230 1
a230 1
	if (!APX_EQ(length, 0.0)) {
@


10.4
log
@Modifications due to data structure revisions:  mesh and knots are no
longer pointers, but in-place structures.
@
text
@d36 2
a37 2
	fastf_t        * mesh_ptr = srf->mesh.ctl_points;
	int	coords = RT_NURB_EXTRACT_COORDS(srf->mesh.pt_type);
d55 1
a55 1
	    RT_NURB_EXTRACT_COORDS(srf->mesh.pt_type) * srf->mesh.s_size[1], 
d63 1
a63 1
	for (i = 0; i < (srf->mesh.s_size[0]); i++) {
d66 2
a67 2
		    j < (srf->mesh.s_size[1] * 
			RT_NURB_EXTRACT_COORDS(srf->mesh.pt_type)); 
d71 2
a72 2
		rdist = rt_nurb_crv_flat(crv, srf->mesh.s_size[1], 
		    srf->mesh.pt_type);
d79 2
a80 2
	    RT_NURB_EXTRACT_COORDS(srf->mesh.pt_type) *  
	    srf->mesh.s_size[0], 	"rt_nurb_s_flat: crv");
d82 1
a82 1
	for (i = 0; i < (coords * srf->mesh.s_size[1]); i += coords) {
d85 1
a85 1
		for (j = 0; j < (srf->mesh.s_size[0]); j++) {
d87 1
a87 1
			    (j * (srf->mesh.s_size[1] * coords)) + i;
d91 1
a91 1
				    srf->mesh.ctl_points[mesh_elt + k];
d95 1
a95 1
		    srf->mesh.s_size[0], srf->mesh.pt_type);
d118 1
a118 1
	mesh_ptr = srf->mesh.ctl_points;
d120 1
a120 1
	if ( !RT_NURB_IS_PT_RATIONAL(srf->mesh.pt_type) ) {
d124 1
a124 1
		    (mesh_ptr + (srf->mesh.s_size[1] - 1) * coords));
d127 3
a129 3
		    ((srf->mesh.s_size[1] * 
		    (srf->mesh.s_size[0] - 1)) + 
		    (srf->mesh.s_size[1] - 1)) * coords));
d133 2
a134 2
		    (srf->mesh.s_size[1] * 
		    (srf->mesh.s_size[0] - 1)) * coords));
d143 1
a143 1
	 	offset = (srf->mesh.s_size[1] - 1) * coords;
d148 3
a150 3
		    ((srf->mesh.s_size[1] * 
		    (srf->mesh.s_size[0] - 1)) + 
		    (srf->mesh.s_size[1] - 1)) * coords;
d155 2
a156 2
		    (srf->mesh.s_size[1] * 
		    (srf->mesh.s_size[0] - 1)) * coords;
@


10.3
log
@Expanded names of manifest constants
@
text
@d36 2
a37 2
	fastf_t        * mesh_ptr = srf->mesh->ctl_points;
	int	coords = RT_NURB_EXTRACT_COORDS(srf->mesh->pt_type);
d55 1
a55 1
	    RT_NURB_EXTRACT_COORDS(srf->mesh->pt_type) * srf->mesh->s_size[1], 
d63 1
a63 1
	for (i = 0; i < (srf->mesh->s_size[0]); i++) {
d66 2
a67 2
		    j < (srf->mesh->s_size[1] * 
			RT_NURB_EXTRACT_COORDS(srf->mesh->pt_type)); 
d71 2
a72 2
		rdist = rt_nurb_crv_flat(crv, srf->mesh->s_size[1], 
		    srf->mesh->pt_type);
d79 2
a80 2
	    RT_NURB_EXTRACT_COORDS(srf->mesh->pt_type) *  
	    srf->mesh->s_size[0], 	"rt_nurb_s_flat: crv");
d82 1
a82 1
	for (i = 0; i < (coords * srf->mesh->s_size[1]); i += coords) {
d85 1
a85 1
		for (j = 0; j < (srf->mesh->s_size[0]); j++) {
d87 1
a87 1
			    (j * (srf->mesh->s_size[1] * coords)) + i;
d91 1
a91 1
				    srf->mesh->ctl_points[mesh_elt + k];
d95 1
a95 1
		    srf->mesh->s_size[0], srf->mesh->pt_type);
d118 1
a118 1
	mesh_ptr = srf->mesh->ctl_points;
d120 1
a120 1
	if ( !RT_NURB_IS_PT_RATIONAL(srf->mesh->pt_type) ) {
d124 1
a124 1
		    (mesh_ptr + (srf->mesh->s_size[1] - 1) * coords));
d127 3
a129 3
		    ((srf->mesh->s_size[1] * 
		    (srf->mesh->s_size[0] - 1)) + 
		    (srf->mesh->s_size[1] - 1)) * coords));
d133 2
a134 2
		    (srf->mesh->s_size[1] * 
		    (srf->mesh->s_size[0] - 1)) * coords));
d143 1
a143 1
	 	offset = (srf->mesh->s_size[1] - 1) * coords;
d148 3
a150 3
		    ((srf->mesh->s_size[1] * 
		    (srf->mesh->s_size[0] - 1)) + 
		    (srf->mesh->s_size[1] - 1)) * coords;
d155 2
a156 2
		    (srf->mesh->s_size[1] * 
		    (srf->mesh->s_size[0] - 1)) * coords;
@


10.2
log
@rt_nurb_ prefix put on "internal" routines.
SPL_INFINIT changed to INFINITY
@
text
@d37 1
a37 1
	int	coords = EXTRACT_COORDS(srf->mesh->pt_type);
d50 1
a50 1
	otherdir = (dir == ROW) ? COL : ROW;
d55 1
a55 1
	    EXTRACT_COORDS(srf->mesh->pt_type) * srf->mesh->s_size[1], 
d58 1
a58 1
	/* Test Row and COL curves for flatness, 
d67 1
a67 1
			EXTRACT_COORDS(srf->mesh->pt_type)); 
d79 1
a79 1
	    EXTRACT_COORDS(srf->mesh->pt_type) *  
d106 1
a106 1
			return ROW;
d108 1
a108 1
			return COL;
d120 1
a120 1
	if ( !EXTRACT_RAT(srf->mesh->pt_type) ) {
d169 1
a169 1
		return FLAT;
d178 1
a178 1
	return FLAT;		/* Must be flat */
d201 2
a202 2
	coords = EXTRACT_COORDS( pt_type);
	rational = EXTRACT_RAT( pt_type);
@


10.1
log
@Release_4.0
@
text
@d52 1
a52 1
	max_row_dist = max_col_dist = -SPL_INFINIT;
d71 1
a71 1
		rdist = internal_crv_flat(crv, srf->mesh->s_size[1], 
d94 1
a94 1
		rdist = internal_crv_flat(crv, 
d184 1
a184 1
internal_crv_flat( crv, size, pt_type )
d203 1
a203 1
	max_dist = -SPL_INFINIT;
@


1.4
log
@Changed HVMOVE to HMOVE.
Slightly reorganized code to be more efficient, in the process.
@
text
@@


1.3
log
@minor lint
@
text
@d138 1
d140 8
a147 5
		HVMOVE(h1, mesh_ptr);
		HVMOVE(h2,
		    (mesh_ptr + (srf->mesh->s_size[1] - 1) * coords));
		HVMOVE(h3,
		    (mesh_ptr + 
d150 3
a152 1
		    (srf->mesh->s_size[1] - 1)) * coords));
d154 1
a154 2
		HVMOVE(h4,
		    (mesh_ptr + 
d156 2
a157 5
		    (srf->mesh->s_size[0] - 1)) * coords));

		HDIVIDE( p1, h1 );
		HDIVIDE( p2, h2 );
		HDIVIDE( p3, h3 );
d208 1
a208 1
		HVMOVE( h1, crv);
d222 1
a222 1
			HVMOVE( h2, (crv + ( i * coords)));
@


1.2
log
@fixed nurb.h
@
text
@a26 2
fastf_t internal_crv_flat();

@


1.1
log
@Initial revision
@
text
@d25 1
a25 1
#include "./nurb.h"
@
