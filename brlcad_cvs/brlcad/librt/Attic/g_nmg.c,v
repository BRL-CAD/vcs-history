head	11.43;
access;
symbols
	ansi-20040405-merged:11.39.2.2
	postmerge-20040405-ansi:11.41
	premerge-20040404-ansi:11.40
	postmerge-autoconf:11.40
	autoconf-freeze:11.39.10.2
	premerge-autoconf:11.40
	ansi-20040316-freeze:11.39.2.1
	postmerge-20040315-windows:11.40
	premerge-20040315-windows:11.40
	windows-20040315-freeze:11.39.4.1
	autoconf-20031203:11.39
	autoconf-20031202:11.39
	autoconf-branch:11.39.0.10
	phong-branch:11.39.0.8
	photonmap-branch:11.39.0.6
	rel-6-1-DP:11.39
	windows-branch:11.39.0.4
	rel-6-0-2:11.37
	ansi-branch:11.39.0.2
	rel-6-0-1-branch:11.37.0.2
	hartley-6-0-post:11.38
	hartley-6-0-pre:11.37
	rel-6-0-1:11.37
	rel-6-0:11.36
	rel-5-4:11.17
	offsite-5-3-pre:11.28
	rel-5-3:11.17
	rel-5-2:11.17
	rel-5-1-branch:11.17.0.2
	rel-5-1:11.17
	rel-5-0:11.13
	rel-5-0-beta:11.13
	rel-4-5:11.11
	ctj-4-5-post:11.10
	ctj-4-5-pre:11.10
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.43
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.42;

11.42
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.41;

11.41
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.40;

11.40
date	2004.02.02.17.39.20;	author morrison;	state Exp;
branches;
next	11.39;

11.39
date	2002.08.20.17.08.00;	author jra;	state Exp;
branches
	11.39.2.1
	11.39.4.1
	11.39.10.1;
next	11.38;

11.38
date	2002.08.15.20.55.12;	author hartley;	state Exp;
branches;
next	11.37;

11.37
date	2002.05.09.19.24.46;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	2001.10.02.19.24.29;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	2001.10.02.17.54.11;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	2001.07.18.19.30.43;	author morrison;	state Exp;
branches;
next	11.33;

11.33
date	2001.07.17.13.19.22;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	2001.05.17.20.05.24;	author morrison;	state Exp;
branches;
next	11.31;

11.31
date	2001.04.20.22.29.45;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2001.04.05.13.06.56;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	2001.03.21.21.01.42;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	2000.08.21.02.02.30;	author butler;	state Exp;
branches;
next	11.27;

11.27
date	2000.08.10.05.24.37;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.08.10.03.53.20;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.07.10.23.01.32;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.07.06.22.19.36;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.06.30.21.37.49;	author cjohnson;	state Exp;
branches;
next	11.22;

11.22
date	2000.06.30.15.59.36;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.06.30.15.38.03;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.06.30.15.31.15;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.06.29.20.45.16;	author cjohnson;	state Exp;
branches;
next	11.18;

11.18
date	2000.06.28.22.33.34;	author cjohnson;	state Exp;
branches;
next	11.17;

11.17
date	2000.04.12.02.34.34;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	99.11.26.21.46.47;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.11.24.21.44.29;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	99.11.17.02.41.59;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	99.05.27.19.10.39;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	99.01.13.21.54.03;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	97.09.09.13.49.08;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	97.01.09.16.15.46;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	96.07.12.12.10.21;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	96.05.16.21.46.52;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	96.03.07.20.27.24;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.12.02.03.09.46;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.12.01.02.47.38;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.06.27.19.41.43;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.03.03.11.52.35;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.02.17.03.39.08;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.44;	author mike;	state Rel4_4;
branches;
next	10.49;

10.49
date	94.12.20.14.22.08;	author jra;	state Exp;
branches;
next	10.48;

10.48
date	94.12.19.16.34.01;	author jra;	state Exp;
branches;
next	10.47;

10.47
date	94.11.30.03.58.38;	author butler;	state Exp;
branches;
next	10.46;

10.46
date	94.11.17.16.57.00;	author jra;	state Exp;
branches;
next	10.45;

10.45
date	94.11.16.17.01.49;	author jra;	state Exp;
branches;
next	10.44;

10.44
date	94.11.04.05.47.22;	author mike;	state Exp;
branches;
next	10.43;

10.43
date	94.10.24.21.47.27;	author mike;	state Exp;
branches;
next	10.42;

10.42
date	94.09.23.20.42.37;	author mike;	state Exp;
branches;
next	10.41;

10.41
date	94.09.22.04.09.13;	author mike;	state Exp;
branches;
next	10.40;

10.40
date	94.09.21.03.49.54;	author mike;	state Exp;
branches;
next	10.39;

10.39
date	94.09.21.03.37.49;	author mike;	state Exp;
branches;
next	10.38;

10.38
date	94.09.21.03.06.38;	author mike;	state Exp;
branches;
next	10.37;

10.37
date	94.09.21.02.14.17;	author mike;	state Exp;
branches;
next	10.36;

10.36
date	94.09.21.00.37.03;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	94.09.16.23.35.51;	author mike;	state Exp;
branches;
next	10.34;

10.34
date	94.09.16.19.36.03;	author mike;	state Exp;
branches;
next	10.33;

10.33
date	94.09.16.05.00.52;	author mike;	state Exp;
branches;
next	10.32;

10.32
date	94.09.16.04.05.42;	author mike;	state Exp;
branches;
next	10.31;

10.31
date	94.09.10.05.41.42;	author mike;	state Exp;
branches;
next	10.30;

10.30
date	94.09.10.04.36.22;	author mike;	state Exp;
branches;
next	10.29;

10.29
date	94.09.09.10.58.36;	author jra;	state Exp;
branches;
next	10.28;

10.28
date	94.09.03.03.01.03;	author mike;	state Exp;
branches;
next	10.27;

10.27
date	94.09.02.19.07.44;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	94.09.02.17.58.34;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	94.09.02.01.14.27;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	94.09.02.00.32.49;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	94.08.10.22.37.45;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	94.08.10.18.35.10;	author gdurf;	state Exp;
branches;
next	10.21;

10.21
date	94.08.10.18.34.54;	author gdurf;	state Exp;
branches;
next	10.20;

10.20
date	94.04.25.01.58.03;	author butler;	state Exp;
branches;
next	10.19;

10.19
date	94.04.25.00.37.36;	author butler;	state Exp;
branches;
next	10.18;

10.18
date	94.01.12.02.49.46;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	94.01.11.04.24.53;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	94.01.10.16.09.24;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	93.11.18.02.27.46;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	93.11.18.01.43.20;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	93.11.17.19.50.50;	author butler;	state Exp;
branches;
next	10.12;

10.12
date	93.07.22.02.25.17;	author butler;	state Exp;
branches;
next	10.11;

10.11
date	93.06.04.20.51.49;	author butler;	state Exp;
branches;
next	10.10;

10.10
date	93.04.07.05.58.04;	author butler;	state Exp;
branches;
next	10.9;

10.9
date	93.03.05.23.55.20;	author butler;	state Exp;
branches;
next	10.8;

10.8
date	92.11.11.00.05.00;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.11.10.22.54.26;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.11.02.15.33.22;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.11.02.15.32.02;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.06.25.20.11.57;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.06.25.20.06.17;	author butler;	state Exp;
branches;
next	10.2;

10.2
date	92.02.25.07.16.19;	author butler;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.17;	author mike;	state Rel4_0;
branches;
next	1.35;

1.35
date	91.09.20.23.11.08;	author butler;	state Exp;
branches;
next	1.34;

1.34
date	91.06.30.00.10.51;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	91.06.29.21.06.32;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	91.06.22.22.30.25;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	91.06.22.20.10.10;	author butler;	state Exp;
branches;
next	1.30;

1.30
date	91.06.13.22.30.06;	author butler;	state Exp;
branches;
next	1.29;

1.29
date	91.06.13.05.42.44;	author butler;	state Exp;
branches;
next	1.28;

1.28
date	91.05.25.03.02.32;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	91.05.18.03.00.58;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	91.05.17.20.21.59;	author butler;	state Exp;
branches;
next	1.25;

1.25
date	91.04.29.15.41.28;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	91.02.28.02.05.29;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	91.02.27.23.36.37;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	91.02.27.23.14.13;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	91.02.27.22.42.54;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	91.02.27.22.23.22;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	91.02.27.22.14.36;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	91.02.27.21.43.07;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	91.02.27.21.33.12;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	91.02.27.19.49.19;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	91.02.27.19.17.30;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	91.02.27.04.30.18;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	91.02.27.03.35.34;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	91.02.27.02.46.34;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	91.02.27.02.33.21;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	91.02.27.01.57.02;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	91.02.27.01.45.21;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	91.02.26.21.24.31;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	91.02.09.02.33.31;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	91.02.09.01.38.55;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.02.08.02.48.33;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.02.08.00.34.29;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.02.07.22.51.37;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.02.07.20.32.21;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.02.07.01.11.33;	author mike;	state Exp;
branches;
next	;

11.39.2.1
date	2002.09.19.18.01.34;	author morrison;	state Exp;
branches;
next	11.39.2.2;

11.39.2.2
date	2004.03.17.21.18.47;	author morrison;	state Exp;
branches;
next	;

11.39.4.1
date	2004.03.11.23.43.38;	author morrison;	state Exp;
branches;
next	;

11.39.10.1
date	2004.02.12.18.37.41;	author erikg;	state Exp;
branches;
next	11.39.10.2;

11.39.10.2
date	2004.03.15.14.07.19;	author erikg;	state Exp;
branches;
next	;


desc
@LIBRT Geometry module for NMG solids
@


11.43
log
@moved to src/
@
text
@#define DEBUG	0
/*
 *			G _ N M G . C
 *
 *  Purpose -
 *	Intersect a ray with an NMG solid
 *
 *  Authors -
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSnmg[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_nmg.c,v 11.42 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "./debug.h"

/* rt_nmg_internal is just "model", from nmg.h */

#define	NMG_SPEC_START_MAGIC	6014061
#define	NMG_SPEC_END_MAGIC		7013061

/* This is the solid information specific to an nmg solid */
struct nmg_specific {
	int			nmg_smagic;	/* STRUCT START magic number */
	struct model		*nmg_model;
	char			*manifolds; /*  structure 1-3manifold table */
	vect_t			nmg_invdir;
	int			nmg_emagic;	/* STRUCT END magic number */
};

struct tmp_v {
	point_t pt;
	struct vertex *v;
};


/*
 *  			R T _ N M G _ P R E P
 *  
 *  Given a pointer to a ged database record, and a transformation matrix,
 *  determine if this is a valid nmg, and if so, precompute various
 *  terms of the formula.
 *  
 *  returns -
 *  	0	nmg is ok
 *  	!0	error in description
 *  
 *  implicit return -
 *  	a struct nmg_specific is created, and it's address is stored in
 *  	stp->st_specific for use by nmg_shot().
 */
int
rt_nmg_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct model		*m;
	register struct nmg_specific	*nmg_s;
	struct nmgregion *rp;
	vect_t work;	

	RT_CK_DB_INTERNAL(ip);
	m = (struct model *)ip->idb_ptr;
	NMG_CK_MODEL(m);

	BU_GETSTRUCT( nmg_s, nmg_specific );
	stp->st_specific = (genptr_t)nmg_s;
	nmg_s->nmg_model = m;
	ip->idb_ptr = (genptr_t)NULL;
	nmg_s->nmg_smagic = NMG_SPEC_START_MAGIC;
	nmg_s->nmg_emagic = NMG_SPEC_END_MAGIC;

	/* get bounding box of NMG solid */
	VSETALL(stp->st_min, MAX_FASTF);
	VSETALL(stp->st_max, -MAX_FASTF);

	/* the model bounding box is an amalgam of the 
	 * nmgregion bounding boxes.
	 */
	for (BU_LIST_FOR(rp, nmgregion, &m->r_hd )) {
		NMG_CK_REGION(rp);
		NMG_CK_REGION_A(rp->ra_p);

		VMINMAX(stp->st_min, stp->st_max, rp->ra_p->min_pt);
		VMINMAX(stp->st_min, stp->st_max, rp->ra_p->max_pt);

		nmg_ck_vs_in_region( rp , &rtip->rti_tol );

	}

	VADD2SCALE( stp->st_center, stp->st_min, stp->st_max, 0.5 );
	VSUB2SCALE( work, stp->st_max, stp->st_min, 0.5 );
	stp->st_aradius = stp->st_bradius = MAGNITUDE(work);

	/* build table indicating the manifold level
	 * of each sub-element of NMG solid
	 */
	nmg_s->manifolds = nmg_manifolds(m);

	return(0);
}

/*
 *			R T _ N M G _ P R I N T
 */
void
rt_nmg_print(register const struct soltab *stp)
{
	register struct model *m =
		(struct model *)stp->st_specific;

	NMG_CK_MODEL(m);
	nmg_pr_m(m);
}



/*
 *  			R T _ N M G _ S H O T
 *  
 *  Intersect a ray with a nmg.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_nmg_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
             		     
                    	    	/* info about the ray */
                  	    	
          		         	/* intersection w/ ray */
{
	struct ray_data rd;
	int status;
	struct nmg_specific *nmg =
		(struct nmg_specific *)stp->st_specific;

	if(rt_g.NMG_debug & DEBUG_NMGRT) {
		bu_log("rt_nmg_shot()\n\t");
		rt_pr_tol(&ap->a_rt_i->rti_tol);
	}

	/* check validity of nmg specific structure */
 	if (nmg->nmg_smagic != NMG_SPEC_START_MAGIC)
		rt_bomb("start of NMG st_specific structure corrupted\n");

 	if (nmg->nmg_emagic != NMG_SPEC_END_MAGIC)
		rt_bomb("end of NMG st_specific structure corrupted\n");

	/* Compute the inverse of the direction cosines */
	if( !NEAR_ZERO( rp->r_dir[X], SQRT_SMALL_FASTF ) )  {
		nmg->nmg_invdir[X]=1.0/rp->r_dir[X];
	} else {
		nmg->nmg_invdir[X] = INFINITY;
		rp->r_dir[X] = 0.0;
	}
	if( !NEAR_ZERO( rp->r_dir[Y], SQRT_SMALL_FASTF ) )  {
		nmg->nmg_invdir[Y]=1.0/rp->r_dir[Y];
	} else {
		nmg->nmg_invdir[Y] = INFINITY;
		rp->r_dir[Y] = 0.0;
	}
	if( !NEAR_ZERO( rp->r_dir[Z], SQRT_SMALL_FASTF ) )  {
		nmg->nmg_invdir[Z]=1.0/rp->r_dir[Z];
	} else {
		nmg->nmg_invdir[Z] = INFINITY;
		rp->r_dir[Z] = 0.0;
	}

	/* build the NMG per-ray data structure */
	rd.rd_m = nmg->nmg_model;
	rd.manifolds = nmg->manifolds;
	VMOVE(rd.rd_invdir, nmg->nmg_invdir);
	rd.rp = rp;
	rd.tol = &ap->a_rt_i->rti_tol;
	rd.ap = ap;
	rd.stp = stp;
	rd.seghead = seghead;
	rd.classifying_ray = 0;
	
	/* create a table to keep track of which elements have been
	 * processed before and which haven't.  Elements in this table
	 * will either be:
	 *		(NULL)		item not previously processed
	 *		hitmiss ptr	item previously processed
	 */
	rd.hitmiss = (struct hitmiss **)bu_calloc( rd.rd_m->maxindex,
		sizeof(struct hitmiss *), "nmg geom hit list");

	/* initialize the lists of things that have been hit/missed */
	BU_LIST_INIT(&rd.rd_hit);
	BU_LIST_INIT(&rd.rd_miss);
	rd.magic = NMG_RAY_DATA_MAGIC;

	/* intersect the ray with the geometry */
	nmg_isect_ray_model(&rd);

	/* build the segment lists */
	status = nmg_ray_segs(&rd);

	/* free the hitmiss table */
	bu_free( (char *)rd.hitmiss, "free nmg geom hit list");

	return(status);
}


#define RT_NMG_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ N M G _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_nmg_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	rt_vstub( stp, rp, segp, n, ap );
}

/*
 *  			R T _ N M G _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_nmg_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
}

/*
 *			R T _ N M G _ C U R V E
 *
 *  Return the curvature of the nmg.
 */
void
rt_nmg_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
/*	register struct nmg_specific *nmg =
		(struct nmg_specific *)stp->st_specific; */

 	cvp->crv_c1 = cvp->crv_c2 = 0;

	/* any tangent direction */
 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
}

/*
 *  			R T _ N M G _ U V
 *  
 *  For a hit on the surface of an nmg, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_nmg_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
/*	register struct nmg_specific *nmg =
		(struct nmg_specific *)stp->st_specific; */
}

/*
 *		R T _ N M G _ F R E E
 */
void
rt_nmg_free(register struct soltab *stp)
{
	register struct nmg_specific *nmg =
		(struct nmg_specific *)stp->st_specific;

	nmg_km( nmg->nmg_model );
	bu_free( (char *)nmg, "nmg_specific" );
}

/*
 *			R T _ N M G _ C L A S S
 */
int
rt_nmg_class(void)
{
	return(0);
}


/*
 *			R T _ N M G _ P L O T
 */
int
rt_nmg_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct model	*m;

	RT_CK_DB_INTERNAL(ip);
	m = (struct model *)ip->idb_ptr;
	NMG_CK_MODEL(m);

	nmg_m_to_vlist( vhead, m, 0 );

	return(0);
}

/*
 *			R T _ N M G _ T E S S
 *
 * XXX This routine "destroys" the internal nmg solid.
 * This means that once you tesselate an NMG solid, your in-memory
 * copy becomes invalid, and you can't do anything else with it
 * until you get a new copy from disk.
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_nmg_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct model	*lm;

	NMG_CK_MODEL(m);

	RT_CK_DB_INTERNAL(ip);
	lm = (struct model *)ip->idb_ptr;
	NMG_CK_MODEL(lm);

	if( BU_LIST_IS_EMPTY( &(lm->r_hd) ) )  {
		/* No regions in imported geometry, can't give valid 'r' */
		*r = (struct nmgregion *)NULL;
		return -1;
	}

	/* XXX A big hack, just for testing ***/

	*r = BU_LIST_FIRST(nmgregion, &(lm->r_hd) );
	NMG_CK_REGION(*r);
	if( BU_LIST_NEXT_NOT_HEAD( *r, &(lm->r_hd) ) )  {
		struct nmgregion *r2;

		r2 = BU_LIST_PNEXT( nmgregion, &((*r)->l) );
		while( BU_LIST_NOT_HEAD( &r2->l, &(lm->r_hd) ) )
		{
			struct nmgregion *next_r;

			next_r = BU_LIST_PNEXT( nmgregion, &r2->l );
			nmg_merge_regions( *r, r2, tol );

			r2 = next_r;
		}
	}


	/* XXX The next two lines "destroy" the internal nmg solid.
	 * This means that once you tesselate an NMG solid, your in-memory
	 * copy becomes invalid, and you can't do anything else with it
	 * until you get a new copy from disk.
	 */
	nmg_merge_models(m, lm);
	ip->idb_ptr = GENPTR_NULL;

	return(0);
}

#define RT_CK_DISKMAGIC(_cp,_magic)	\
	if( bu_glong(_cp) != _magic )  { \
		bu_log("RT_CK_DISKMAGIC: magic mis-match, got x%x, s/b x%x, file %s, line %d\n", \
			bu_glong(_cp), _magic, __FILE__, __LINE__); \
		rt_bomb("bad magic\n"); \
	}

/*
 * ----------------------------------------------------------------------
 *
 *  Definitions for the binary, machine-independent format of
 *  the NMG data structures.
 *
 *  There are two special values that may be assigned to an disk_index_t
 *  to signal special processing when the structure is re-imported.
 */
#define DISK_INDEX_NULL		0
#define DISK_INDEX_LISTHEAD	-1

#define DISK_MODEL_VERSION	1	/* V0 was Release 4.0 */

typedef	unsigned char	disk_index_t[4];
struct disk_rt_list  {
	disk_index_t		forw;
	disk_index_t		back;
};

#define DISK_MODEL_MAGIC	0x4e6d6f64	/* Nmod */
struct disk_model {
	unsigned char		magic[4];
	unsigned char		version[4];	/* unused */
	struct disk_rt_list	r_hd;
};

#define DISK_REGION_MAGIC	0x4e726567	/* Nreg */
struct disk_nmgregion {
	unsigned char		magic[4];
	struct disk_rt_list	l;
	disk_index_t   		m_p;
	disk_index_t		ra_p;
	struct disk_rt_list	s_hd;
};

#define DISK_REGION_A_MAGIC	0x4e725f61	/* Nr_a */
struct disk_nmgregion_a {
	unsigned char		magic[4];
	unsigned char		min_pt[3*8];
	unsigned char		max_pt[3*8];
};

#define DISK_SHELL_MAGIC	0x4e73686c	/* Nshl */
struct disk_shell {
	unsigned char		magic[4];
	struct disk_rt_list	l;
	disk_index_t		r_p;
	disk_index_t		sa_p;
	struct disk_rt_list	fu_hd;
	struct disk_rt_list	lu_hd;
	struct disk_rt_list	eu_hd;
	disk_index_t			vu_p;
};

#define DISK_SHELL_A_MAGIC	0x4e735f61	/* Ns_a */
struct disk_shell_a {
	unsigned char		magic[4];
	unsigned char		min_pt[3*8];
	unsigned char		max_pt[3*8];
};

#define DISK_FACE_MAGIC		0x4e666163	/* Nfac */
struct disk_face {
	unsigned char		magic[4];
	struct disk_rt_list	l;
	disk_index_t		fu_p;
	disk_index_t		g;
	unsigned char		flip[4];
};

#define DISK_FACE_G_PLANE_MAGIC	0x4e666770	/* Nfgp */
struct disk_face_g_plane {
	unsigned char		magic[4];
	struct disk_rt_list	f_hd;
	unsigned char		N[4*8];
};

#define DISK_FACE_G_SNURB_MAGIC	0x4e666773	/* Nfgs */
struct disk_face_g_snurb {
	unsigned char		magic[4];
	struct disk_rt_list	f_hd;
	unsigned char		u_order[4];
	unsigned char		v_order[4];
	unsigned char		u_size[4];	/* u.k_size */
	unsigned char		v_size[4];	/* v.k_size */
	disk_index_t		u_knots;	/* u.knots subscript */
	disk_index_t		v_knots;	/* v.knots subscript */
	unsigned char		us_size[4];
	unsigned char		vs_size[4];
	unsigned char		pt_type[4];
	disk_index_t		ctl_points;	/* subscript */
};

#define DISK_FACEUSE_MAGIC	0x4e667520	/* Nfu */
struct disk_faceuse {
	unsigned char		magic[4];
	struct disk_rt_list	l;
	disk_index_t		s_p;
	disk_index_t		fumate_p;
	unsigned char		orientation[4];
	disk_index_t		f_p;
	disk_index_t		fua_p;
	struct disk_rt_list	lu_hd;
};

#define DISK_LOOP_MAGIC		0x4e6c6f70	/* Nlop */
struct disk_loop {
	unsigned char		magic[4];
	disk_index_t		lu_p;
	disk_index_t		lg_p;
};

#define DISK_LOOP_G_MAGIC	0x4e6c5f67	/* Nl_g */
struct disk_loop_g {
	unsigned char		magic[4];
	unsigned char		min_pt[3*8];
	unsigned char		max_pt[3*8];
};

#define DISK_LOOPUSE_MAGIC	0x4e6c7520	/* Nlu */
struct disk_loopuse {
	unsigned char		magic[4];
	struct disk_rt_list	l;
	disk_index_t		up;
	disk_index_t		lumate_p;
	unsigned char		orientation[4];
	disk_index_t		l_p;
	disk_index_t		lua_p;
	struct disk_rt_list	down_hd;
};

#define DISK_EDGE_MAGIC		0x4e656467	/* Nedg */
struct disk_edge {
	unsigned char		magic[4];
	disk_index_t		eu_p;
	unsigned char		is_real[4];
};

#define DISK_EDGE_G_LSEG_MAGIC	0x4e65676c	/* Negl */
struct disk_edge_g_lseg {
	unsigned char		magic[4];
	struct disk_rt_list	eu_hd2;
	unsigned char		e_pt[3*8];
	unsigned char		e_dir[3*8];
};

#define DISK_EDGE_G_CNURB_MAGIC	0x4e656763	/* Negc */
struct disk_edge_g_cnurb {
	unsigned char		magic[4];
	struct disk_rt_list	eu_hd2;
	unsigned char		order[4];
	unsigned char		k_size[4];	/* k.k_size */
	disk_index_t		knots;		/* knot.knots subscript */
	unsigned char		c_size[4];
	unsigned char		pt_type[4];
	disk_index_t		ctl_points;	/* subscript */
};

#define DISK_EDGEUSE_MAGIC	0x4e657520	/* Neu */
struct disk_edgeuse {
	unsigned char		magic[4];
	struct disk_rt_list	l;
	struct disk_rt_list	l2;
	disk_index_t		up;
	disk_index_t		eumate_p;
	disk_index_t		radial_p;
	disk_index_t		e_p;
	disk_index_t		eua_p;
	unsigned char  		orientation[4];
	disk_index_t		vu_p;
	disk_index_t		g;
};

#define DISK_VERTEX_MAGIC	0x4e767274	/* Nvrt */
struct disk_vertex {
	unsigned char		magic[4];
	struct disk_rt_list	vu_hd;
	disk_index_t			vg_p;
};

#define DISK_VERTEX_G_MAGIC	0x4e765f67	/* Nv_g */
struct disk_vertex_g {
	unsigned char		magic[4];
	unsigned char		coord[3*8];
};

#define DISK_VERTEXUSE_MAGIC	0x4e767520	/* Nvu */
struct disk_vertexuse {
	unsigned char		magic[4];
	struct disk_rt_list	l;
	disk_index_t		up;
	disk_index_t		v_p;
	disk_index_t		a;
};

#define DISK_VERTEXUSE_A_PLANE_MAGIC	0x4e767561	/* Nvua */
struct disk_vertexuse_a_plane {
	unsigned char		magic[4];
	unsigned char		N[3*8];
};

#define DISK_VERTEXUSE_A_CNURB_MAGIC	0x4e766163	/* Nvac */
struct disk_vertexuse_a_cnurb {
	unsigned char		magic[4];
	unsigned char		param[3*8];
};

#define DISK_DOUBLE_ARRAY_MAGIC	0x4e666172		/* Narr */
struct disk_double_array  {
	unsigned char		magic[4];
	unsigned char		ndouble[4];	/* # of doubles to follow */
	unsigned char		vals[1*8];	/* actually [ndouble*8] */
};

/* ---------------------------------------------------------------------- */
/* All these arrays and defines have to use the same implicit index values */
#define NMG_KIND_MODEL		0
#define NMG_KIND_NMGREGION	1
#define NMG_KIND_NMGREGION_A	2
#define NMG_KIND_SHELL		3
#define NMG_KIND_SHELL_A	4
#define NMG_KIND_FACEUSE	5
#define NMG_KIND_FACE		6
#define NMG_KIND_FACE_G_PLANE	7
#define NMG_KIND_FACE_G_SNURB	8
#define NMG_KIND_LOOPUSE	9
#define NMG_KIND_LOOP		10
#define NMG_KIND_LOOP_G		11
#define NMG_KIND_EDGEUSE	12
#define NMG_KIND_EDGE		13
#define NMG_KIND_EDGE_G_LSEG	14
#define NMG_KIND_EDGE_G_CNURB	15
#define NMG_KIND_VERTEXUSE	16
#define NMG_KIND_VERTEXUSE_A_PLANE	17
#define NMG_KIND_VERTEXUSE_A_CNURB	18
#define NMG_KIND_VERTEX		19
#define NMG_KIND_VERTEX_G	20
/* 21 through 24 are unassigned, and reserved for future use */

#define NMG_KIND_DOUBLE_ARRAY	25		/* special, variable sized */

/* This number must have some extra space, for upwards compatability */
/* 26 is the limit, in the current incarnation of db.h */
#define NMG_N_KINDS		26		/* number of kinds */

const int	rt_nmg_disk_sizes[NMG_N_KINDS] = {
	sizeof(struct disk_model),		/* 0 */
	sizeof(struct disk_nmgregion),
	sizeof(struct disk_nmgregion_a),
	sizeof(struct disk_shell),
	sizeof(struct disk_shell_a),
	sizeof(struct disk_faceuse),
	sizeof(struct disk_face),
	sizeof(struct disk_face_g_plane),
	sizeof(struct disk_face_g_snurb),
	sizeof(struct disk_loopuse),
	sizeof(struct disk_loop),		/* 10 */
	sizeof(struct disk_loop_g),
	sizeof(struct disk_edgeuse),
	sizeof(struct disk_edge),
	sizeof(struct disk_edge_g_lseg),
	sizeof(struct disk_edge_g_cnurb),
	sizeof(struct disk_vertexuse),
	sizeof(struct disk_vertexuse_a_plane),
	sizeof(struct disk_vertexuse_a_cnurb),
	sizeof(struct disk_vertex),
	sizeof(struct disk_vertex_g),		/* 20 */
	0,
	0,
	0,
	0,
	0  /* disk_double_array, MUST BE ZERO */	/* 25: MUST BE ZERO */
};
const char	rt_nmg_kind_names[NMG_N_KINDS+2][18] = {
	"model",				/* 0 */
	"nmgregion",
	"nmgregion_a",
	"shell",
	"shell_a",
	"faceuse",
	"face",
	"face_g_plane",
	"face_g_snurb",
	"loopuse",
	"loop",					/* 10 */
	"loop_g",
	"edgeuse",
	"edge",
	"edge_g_lseg",
	"edge_g_cnurb",
	"vertexuse",
	"vertexuse_a_plane",
	"vertexuse_a_cnurb",
	"vertex",
	"vertex_g",				/* 20 */
	"k21",
	"k22",
	"k23",
	"k24",
	"double_array",				/* 25 */
	"k26-OFF_END",
	"k27-OFF_END"
};

/*
 *			R T _ N M G _ M A G I C _ T O _ K I N D
 *
 *  Given the magic number for an NMG structure, return the
 *  manifest constant which identifies that structure kind.
 */
int
rt_nmg_magic_to_kind(register long int magic)
{
	switch(magic)  {
	case NMG_MODEL_MAGIC:
		return NMG_KIND_MODEL;
	case NMG_REGION_MAGIC:
		return NMG_KIND_NMGREGION;
	case NMG_REGION_A_MAGIC:
		return NMG_KIND_NMGREGION_A;
	case NMG_SHELL_MAGIC:
		return NMG_KIND_SHELL;
	case NMG_SHELL_A_MAGIC:
		return NMG_KIND_SHELL_A;
	case NMG_FACEUSE_MAGIC:
		return NMG_KIND_FACEUSE;
	case NMG_FACE_MAGIC:
		return NMG_KIND_FACE;
	case NMG_FACE_G_PLANE_MAGIC:
		return NMG_KIND_FACE_G_PLANE;
	case NMG_FACE_G_SNURB_MAGIC:
		return NMG_KIND_FACE_G_SNURB;
	case NMG_LOOPUSE_MAGIC:
		return NMG_KIND_LOOPUSE;
	case NMG_LOOP_G_MAGIC:
		return NMG_KIND_LOOP_G;
	case NMG_LOOP_MAGIC:
		return NMG_KIND_LOOP;
	case NMG_EDGEUSE_MAGIC:
		return NMG_KIND_EDGEUSE;
	case NMG_EDGE_MAGIC:
		return NMG_KIND_EDGE;
	case NMG_EDGE_G_LSEG_MAGIC:
		return NMG_KIND_EDGE_G_LSEG;
	case NMG_EDGE_G_CNURB_MAGIC:
		return NMG_KIND_EDGE_G_CNURB;
	case NMG_VERTEXUSE_MAGIC:
		return NMG_KIND_VERTEXUSE;
	case NMG_VERTEXUSE_A_PLANE_MAGIC:
		return NMG_KIND_VERTEXUSE_A_PLANE;
	case NMG_VERTEXUSE_A_CNURB_MAGIC:
		return NMG_KIND_VERTEXUSE_A_CNURB;
	case NMG_VERTEX_MAGIC:
		return NMG_KIND_VERTEX;
	case NMG_VERTEX_G_MAGIC:
		return NMG_KIND_VERTEX_G;
	}
	/* default */
	bu_log("magic = x%x\n", magic);
	rt_bomb("rt_nmg_magic_to_kind: bad magic");
	return -1;
}

/* ---------------------------------------------------------------------- */

struct nmg_exp_counts {
	long	new_subscript;
	long	per_struct_index;
	int	kind;
	long	first_fastf_relpos;	/* for snurb and cnurb. */
	long	byte_offset;		/* for snurb and cnurb. */
};

/* XXX These are horribly non-PARALLEL, and they *must* be PARALLEL ! */
static unsigned char	*rt_nmg_fastf_p;
static unsigned int	rt_nmg_cur_fastf_subscript;

/*
 *			R T _ N M G _ E X P O R T _ F A S T F
 *
 *  Format a variable sized array of fastf_t's into external format
 *  (IEEE big endian double precision) with a 2 element header.
 *
 *		+-----------+
 *		|  magic    |
 *		+-----------+
 *		|  count    |
 *		+-----------+
 *		|           |
 *		~  doubles  ~
 *		~    :      ~
 *		|           |
 *		+-----------+
 *
 *  Increments the pointer to the next free byte in the external array,
 *  and increments the subscript number of the next free array.
 *
 *  Note that this subscript number is consistent with the rest of the
 *  NMG external subscript numbering, so that the first disk_double_array
 *  subscript will be one larger than the largest disk_vertex_g subscript,
 *  and in the external record the array of fastf_t arrays will follow
 *  the array of disk_vertex_g structures.
 *
 *  Returns -
 *	subscript number of this array, in the external form.
 */
int
rt_nmg_export_fastf(const fastf_t *fp, int count, int pt_type, double scale)
             	    
   		      
   		        	/* If zero, means literal array of values */
      		      
{
	register unsigned char	*cp;

	if( pt_type )
		count *= RT_NURB_EXTRACT_COORDS(pt_type);

	cp = rt_nmg_fastf_p;
	(void)bu_plong( cp + 0, DISK_DOUBLE_ARRAY_MAGIC );
	(void)bu_plong( cp + 4, count );
	if( pt_type == 0 || scale == 1.0 )  {
		htond( cp + (4+4), (unsigned char *)fp, count );
	} else {
		fastf_t		*new;

		/* Need to scale data by 'scale' ! */
		new = (fastf_t *)bu_malloc( count*sizeof(fastf_t), "rt_nmg_export_fastf" );
		if( RT_NURB_IS_PT_RATIONAL(pt_type) )  {
			/* Don't scale the homogeneous (rational) coord */
			register int	i;
			int		nelem;	/* # elements per tuple */

			nelem = RT_NURB_EXTRACT_COORDS(pt_type);
			for( i = 0; i < count; i += nelem )  {
				VSCALEN( &new[i], &fp[i], scale, nelem-1 );
				new[i+nelem-1] = fp[i+nelem-1];
			}
		} else {
			/* Scale everything as one long array */
			VSCALEN( new, fp, scale, count );
		}
		htond( cp + (4+4), (unsigned char *)new, count );
		bu_free( (char *)new, "rt_nmg_export_fastf" );
	}
	cp += (4+4) + count * 8;
	rt_nmg_fastf_p = cp;
	return rt_nmg_cur_fastf_subscript++;
}

/*
 *			R T _ N M G _ I M P O R T _ F A S T F
 */
fastf_t *
rt_nmg_import_fastf(const unsigned char *base, struct nmg_exp_counts *ecnt, long int subscript, const matp_t mat, int len, int pt_type)
                   	      
                     	      
    			          
            		    
   			    		/* expected size */
   			        
{
	const unsigned char	*cp;
	register int		count;
	fastf_t			*ret;
	fastf_t			*tmp;

	if( ecnt[subscript].byte_offset <= 0 || ecnt[subscript].kind != NMG_KIND_DOUBLE_ARRAY )  {
		bu_log("subscript=%d, byte_offset=%d, kind=%d (expected %d)\n",
			subscript, ecnt[subscript].byte_offset,
			ecnt[subscript].kind, NMG_KIND_DOUBLE_ARRAY );
		rt_bomb("rt_nmg_import_fastf() bad ecnt table\n");
	}


	cp = base + ecnt[subscript].byte_offset;
	if( bu_glong( cp ) != DISK_DOUBLE_ARRAY_MAGIC )  {
		bu_log("magic mis-match, got x%x, s/b x%x, file %s, line %d\n",
			bu_glong(cp), DISK_DOUBLE_ARRAY_MAGIC, __FILE__, __LINE__);
		bu_log("subscript=%d, byte_offset=%d\n",
			 subscript, ecnt[subscript].byte_offset);
		rt_bomb("rt_nmg_import_fastf() bad magic\n");
	}

	if( pt_type )
		len *= RT_NURB_EXTRACT_COORDS(pt_type);

	count = bu_glong( cp + 4 );
	if( count != len )  {
		bu_log("rt_nmg_import_fastf() subscript=%d, expected len=%d, got=%d\n",
			subscript, len, count );
		rt_bomb("rt_nmg_import_fastf()\n");
	}
	ret = (fastf_t *)bu_malloc( count * sizeof(fastf_t), "rt_nmg_import_fastf[]" );
	if( !mat )  {
		ntohd( (unsigned char *)ret, cp + (4+4), count );
		return ret;
	}

	/*
	 *  An amazing amount of work: transform all points by 4x4 mat.
	 *  Need to know width of data points, may be 3, or 4-tuples.
	 *  The vector times matrix calculation can't be done in place.
	 */
	tmp = (fastf_t *)bu_malloc( count * sizeof(fastf_t), "rt_nmg_import_fastf tmp[]" );
	ntohd( (unsigned char *)tmp, cp + (4+4), count );
	switch( RT_NURB_EXTRACT_COORDS(pt_type) )  {
	case 3:
		if( RT_NURB_IS_PT_RATIONAL(pt_type) )  rt_bomb("rt_nmg_import_fastf() Rational 3-tuple?\n");
		for( count -= 3 ; count >= 0; count -= 3 )  {
			MAT4X3PNT( &ret[count], mat, &tmp[count] );
		}
		break;
	case 4:
		if( !RT_NURB_IS_PT_RATIONAL(pt_type) )  rt_bomb("rt_nmg_import_fastf() non-rational 4-tuple?\n");
		for( count -= 4 ; count >= 0; count -= 4 )  {
			MAT4X4PNT( &ret[count], mat, &tmp[count] );
		}
		break;
	default:
		rt_bomb("rt_nmg_import_fastf() unsupported # of coords in ctl_point\n");
	}
	bu_free( (char *)tmp, "rt_nmg_import_fastf tmp[]" );
	return ret;
}

/*
 *			R T _ N M G _ R E I N D E X
 *
 *  Depends on ecnt[0].byte_offset having been set to maxindex.
 *
 *  There are some special values for the disk index returned here:
 *	>0	normal structure index.
 *	 0	substitute a null pointer when imported.
 *	-1	substitute pointer to within-struct list head when imported.
 */
int
rt_nmg_reindex(genptr_t p, struct nmg_exp_counts *ecnt)
{
	int	index;
	int	ret=0;	/* zero is NOT the default value, this is just to satisfy CRAY compilers */

	/* If null pointer, return new subscript of zero */
	if( p == 0 )  {
		ret = 0;
		index = 0;	/* sanity */
	} else {
		index = nmg_index_of_struct((long *)(p));
		if( index == -1 )  {
			ret = DISK_INDEX_LISTHEAD; /* FLAG:  special list head */
		} else if( index < -1 ) {
			rt_bomb("rt_nmg_reindex(): unable to obtain struct index\n");
		} else {
			ret = ecnt[index].new_subscript;
			if( ecnt[index].kind < 0 )  {
				bu_log("rt_nmg_reindex(p=x%x), p->index=%d, ret=%d, kind=%d\n", p, index, ret, ecnt[index].kind);
				rt_bomb("rt_nmg_reindex() This index not found in ecnt[]\n");
			}
			/* ret == 0 on supressed loop_g ptrs, etc */
			if( ret < 0 || ret > ecnt[0].byte_offset )  {
				bu_log("rt_nmg_reindex(p=x%x) %s, p->index=%d, ret=%d, maxindex=%d\n",
					p,
					bu_identify_magic(*(long *)p),
					index, ret, ecnt[0].byte_offset);
				rt_bomb("rt_nmg_reindex() subscript out of range\n");
			}
		}
	}
/*bu_log("rt_nmg_reindex(p=x%x), p->index=%d, ret=%d\n", p, index, ret);*/
	return( ret );
}

/* forw may never be null;  back may be null for loopuse (sigh) */
#define INDEX(o,i,elem)	\
	(void)bu_plong(&(o)->elem[0], rt_nmg_reindex((genptr_t)((i)->elem), ecnt))
#define INDEXL(oo,ii,elem)	{ \
	register long _f = rt_nmg_reindex((genptr_t)((ii)->elem.forw), ecnt); \
	if( _f == DISK_INDEX_NULL )  bu_log("Warning rt_nmg_edisk: reindex forw to null?\n"); \
	(void)bu_plong( (oo)->elem.forw, _f ); \
	(void)bu_plong( (oo)->elem.back, rt_nmg_reindex((genptr_t)((ii)->elem.back), ecnt) ); }
#define PUTMAGIC(_magic)	(void)bu_plong( &d->magic[0], _magic )

/*
 *			R T _ N M G _ E D I S K
 *
 *  Export a given structure from memory to disk format
 *
 *  Scale geometry by 'local2mm'
 */
void
rt_nmg_edisk(genptr_t op, genptr_t ip, struct nmg_exp_counts *ecnt, int index, double local2mm)
        	   		/* base of disk array */
        	   		/* ptr to in-memory structure */
                     	      
   		      
      		         
{
	int	oindex;		/* index in op */

	oindex = ecnt[index].per_struct_index;
	switch(ecnt[index].kind)  {
	case NMG_KIND_MODEL:
		{
			struct model	*m = (struct model *)ip;
			struct disk_model	*d;
			d = &((struct disk_model *)op)[oindex];
			NMG_CK_MODEL(m);
			PUTMAGIC( DISK_MODEL_MAGIC );
			bu_plong( d->version, 0 );
			INDEXL( d, m, r_hd );
		}
		return;
	case NMG_KIND_NMGREGION:
		{
			struct nmgregion	*r = (struct nmgregion *)ip;
			struct disk_nmgregion	*d;
			d = &((struct disk_nmgregion *)op)[oindex];
			NMG_CK_REGION(r);
			PUTMAGIC( DISK_REGION_MAGIC );
			INDEXL( d, r, l );
			INDEX( d, r, m_p );
			INDEX( d, r, ra_p );
			INDEXL( d, r, s_hd );
		}
		return;
	case NMG_KIND_NMGREGION_A:
		{
			struct nmgregion_a	*r = (struct nmgregion_a *)ip;
			struct disk_nmgregion_a	*d;
			point_t			min, max;
			d = &((struct disk_nmgregion_a *)op)[oindex];
			NMG_CK_REGION_A(r);
			PUTMAGIC( DISK_REGION_A_MAGIC );
			VSCALE( min, r->min_pt, local2mm );
			VSCALE( max, r->max_pt, local2mm );
			htond( d->min_pt, (unsigned char *)min, 3 );
			htond( d->max_pt, (unsigned char *)max, 3 );
		}
		return;
	case NMG_KIND_SHELL:
		{
			struct shell	*s = (struct shell *)ip;
			struct disk_shell	*d;
			d = &((struct disk_shell *)op)[oindex];
			NMG_CK_SHELL(s);
			PUTMAGIC( DISK_SHELL_MAGIC );
			INDEXL( d, s, l );
			INDEX( d, s, r_p );
			INDEX( d, s, sa_p );
			INDEXL( d, s, fu_hd );
			INDEXL( d, s, lu_hd );
			INDEXL( d, s, eu_hd );
			INDEX( d, s, vu_p );
		}
		return;
	case NMG_KIND_SHELL_A:
		{
			struct shell_a	*sa = (struct shell_a *)ip;
			struct disk_shell_a	*d;
			point_t			min, max;
			d = &((struct disk_shell_a *)op)[oindex];
			NMG_CK_SHELL_A(sa);
			PUTMAGIC( DISK_SHELL_A_MAGIC );
			VSCALE( min, sa->min_pt, local2mm );
			VSCALE( max, sa->max_pt, local2mm );
			htond( d->min_pt, (unsigned char *)min, 3 );
			htond( d->max_pt, (unsigned char *)max, 3 );
		}
		return;
	case NMG_KIND_FACEUSE:
		{
			struct faceuse	*fu = (struct faceuse *)ip;
			struct disk_faceuse	*d;
			d = &((struct disk_faceuse *)op)[oindex];
			NMG_CK_FACEUSE(fu);
			NMG_CK_FACEUSE(fu->fumate_p);
			NMG_CK_FACE(fu->f_p);
			if( fu->f_p != fu->fumate_p->f_p )  bu_log("faceuse export, differing faces\n");
			PUTMAGIC( DISK_FACEUSE_MAGIC );
			INDEXL( d, fu, l );
			INDEX( d, fu, s_p );
			INDEX( d, fu, fumate_p );
			bu_plong( d->orientation, fu->orientation );
			INDEX( d, fu, f_p );
			INDEXL( d, fu, lu_hd );
		}
		return;
	case NMG_KIND_FACE:
		{
			struct face	*f = (struct face *)ip;
			struct disk_face	*d;
			d = &((struct disk_face *)op)[oindex];
			NMG_CK_FACE(f);
			PUTMAGIC( DISK_FACE_MAGIC );
			INDEXL( d, f, l );	/* face is member of fg list */
			INDEX( d, f, fu_p );
			bu_plong( d->g, rt_nmg_reindex((genptr_t)(f->g.magic_p), ecnt) );
			bu_plong( d->flip, f->flip );
		}
		return;
	case NMG_KIND_FACE_G_PLANE:
		{
			struct face_g_plane	*fg = (struct face_g_plane *)ip;
			struct disk_face_g_plane	*d;
			plane_t			plane;
			d = &((struct disk_face_g_plane *)op)[oindex];
			NMG_CK_FACE_G_PLANE(fg);
			PUTMAGIC( DISK_FACE_G_PLANE_MAGIC );
			INDEXL( d, fg, f_hd );
			VMOVE( plane, fg->N );
			plane[3] = fg->N[3] * local2mm;
			htond( d->N, (unsigned char *)plane, 4 );
		}
		return;
	case NMG_KIND_FACE_G_SNURB:
		{
			struct face_g_snurb	*fg = (struct face_g_snurb *)ip;
			struct disk_face_g_snurb	*d;

			d = &((struct disk_face_g_snurb *)op)[oindex];
			NMG_CK_FACE_G_SNURB(fg);
			PUTMAGIC( DISK_FACE_G_SNURB_MAGIC );
			INDEXL( d, fg, f_hd );
			bu_plong( d->u_order, fg->order[0] );
			bu_plong( d->v_order, fg->order[1] );
			bu_plong( d->u_size, fg->u.k_size );
			bu_plong( d->v_size, fg->v.k_size );
			bu_plong( d->u_knots,
				rt_nmg_export_fastf( fg->u.knots,
					fg->u.k_size, 0, 1.0 ) );
			bu_plong( d->v_knots,
				rt_nmg_export_fastf( fg->v.knots,
					fg->v.k_size, 0, 1.0 ) );
			bu_plong( d->us_size, fg->s_size[0] );
			bu_plong( d->vs_size, fg->s_size[1] );
			bu_plong( d->pt_type, fg->pt_type );
			/* scale XYZ ctl_points by local2mm */
			bu_plong( d->ctl_points,
				rt_nmg_export_fastf( fg->ctl_points,
					fg->s_size[0] * fg->s_size[1],
					fg->pt_type,
					local2mm ) );
		}
		return;
	case NMG_KIND_LOOPUSE:
		{
			struct loopuse	*lu = (struct loopuse *)ip;
			struct disk_loopuse	*d;
			d = &((struct disk_loopuse *)op)[oindex];
			NMG_CK_LOOPUSE(lu);
			PUTMAGIC( DISK_LOOPUSE_MAGIC );
			INDEXL( d, lu, l );
			bu_plong( d->up, rt_nmg_reindex((genptr_t)(lu->up.magic_p), ecnt) );
			INDEX( d, lu, lumate_p );
			bu_plong( d->orientation, lu->orientation );
			INDEX( d, lu, l_p );
			INDEXL( d, lu, down_hd );
		}
		return;
	case NMG_KIND_LOOP:
		{
			struct loop	*loop = (struct loop *)ip;
			struct disk_loop	*d;
			d = &((struct disk_loop *)op)[oindex];
			NMG_CK_LOOP(loop);
			PUTMAGIC( DISK_LOOP_MAGIC );
			INDEX( d, loop, lu_p );
			INDEX( d, loop, lg_p );
		}
		return;
	case NMG_KIND_LOOP_G:
		{
			struct loop_g	*lg = (struct loop_g *)ip;
			struct disk_loop_g	*d;
			point_t			min, max;
			d = &((struct disk_loop_g *)op)[oindex];
			NMG_CK_LOOP_G(lg);
			PUTMAGIC( DISK_LOOP_G_MAGIC );
			VSCALE( min, lg->min_pt, local2mm );
			VSCALE( max, lg->max_pt, local2mm );
			htond( d->min_pt, (unsigned char *)min, 3 );
			htond( d->max_pt, (unsigned char *)max, 3 );
		}
		return;
	case NMG_KIND_EDGEUSE:
		{
			struct edgeuse	*eu = (struct edgeuse *)ip;
			struct disk_edgeuse	*d;
			d = &((struct disk_edgeuse *)op)[oindex];
			NMG_CK_EDGEUSE(eu);
			PUTMAGIC( DISK_EDGEUSE_MAGIC );
			INDEXL( d, eu, l );
			/* NOTE The pointers in l2 point at other l2's.
			 * nmg_index_of_struct() will point 'em back
			 * at the top of the edgeuse.  Beware on import.
			 */
			INDEXL( d, eu, l2 );
			bu_plong( d->up, rt_nmg_reindex((genptr_t)(eu->up.magic_p), ecnt) );
			INDEX( d, eu, eumate_p );
			INDEX( d, eu, radial_p );
			INDEX( d, eu, e_p );
			bu_plong( d->orientation, eu->orientation);
			INDEX( d, eu, vu_p );
			bu_plong( d->g, rt_nmg_reindex((genptr_t)(eu->g.magic_p), ecnt) );
		}
		return;
	case NMG_KIND_EDGE:
		{
			struct edge	*e = (struct edge *)ip;
			struct disk_edge	*d;
			d = &((struct disk_edge *)op)[oindex];
			NMG_CK_EDGE(e);
			PUTMAGIC( DISK_EDGE_MAGIC );
			bu_plong( d->is_real, e->is_real );
			INDEX( d, e, eu_p );
		}
		return;
	case NMG_KIND_EDGE_G_LSEG:
		{
			struct edge_g_lseg	*eg = (struct edge_g_lseg *)ip;
			struct disk_edge_g_lseg	*d;
			point_t			pt;
			d = &((struct disk_edge_g_lseg *)op)[oindex];
			NMG_CK_EDGE_G_LSEG(eg);
			PUTMAGIC( DISK_EDGE_G_LSEG_MAGIC );
			INDEXL( d, eg, eu_hd2 );
			VSCALE( pt, eg->e_pt, local2mm );
			htond( d->e_pt, (unsigned char *)pt, 3);
			htond( d->e_dir, (unsigned char *)eg->e_dir, 3);
		}
		return;
	case NMG_KIND_EDGE_G_CNURB:
		{
			struct edge_g_cnurb	*eg = (struct edge_g_cnurb *)ip;
			struct disk_edge_g_cnurb	*d;
			d = &((struct disk_edge_g_cnurb *)op)[oindex];
			NMG_CK_EDGE_G_CNURB(eg);
			PUTMAGIC( DISK_EDGE_G_CNURB_MAGIC );
			INDEXL( d, eg, eu_hd2 );
			bu_plong( d->order, eg->order );

			/* If order is zero, everything else is NULL */
			if( eg->order == 0 )  return;

			bu_plong( d->k_size, eg->k.k_size );
			bu_plong( d->knots,
				rt_nmg_export_fastf( eg->k.knots,
					eg->k.k_size, 0, 1.0 ) );
			bu_plong( d->c_size, eg->c_size );
			bu_plong( d->pt_type, eg->pt_type );
			/*
			 * The curve's control points are in parameter space
			 * for cnurbs on snurbs, and in XYZ for cnurbs on planar faces.
			 * UV values do NOT get transformed, XYZ values do!
			 */
			bu_plong( d->ctl_points,
				rt_nmg_export_fastf( eg->ctl_points,
					eg->c_size,
					eg->pt_type,
					RT_NURB_EXTRACT_PT_TYPE( eg->pt_type ) == RT_NURB_PT_UV ?
						1.0 : local2mm ) );
		}
		return;
	case NMG_KIND_VERTEXUSE:
		{
			struct vertexuse	*vu = (struct vertexuse *)ip;
			struct disk_vertexuse	*d;
			d = &((struct disk_vertexuse *)op)[oindex];
			NMG_CK_VERTEXUSE(vu);
			PUTMAGIC( DISK_VERTEXUSE_MAGIC );
			INDEXL( d, vu, l );
			bu_plong( d->up,
				rt_nmg_reindex((genptr_t)(vu->up.magic_p), ecnt) );
			INDEX( d, vu, v_p );
			if(vu->a.magic_p)NMG_CK_VERTEXUSE_A_EITHER(vu->a.magic_p);
			bu_plong( d->a,
				rt_nmg_reindex((genptr_t)(vu->a.magic_p), ecnt) );
		}
		return;
	case NMG_KIND_VERTEXUSE_A_PLANE:
		{
			struct vertexuse_a_plane	*vua = (struct vertexuse_a_plane *)ip;
			struct disk_vertexuse_a_plane	*d;
			d = &((struct disk_vertexuse_a_plane *)op)[oindex];
			NMG_CK_VERTEXUSE_A_PLANE(vua);
			PUTMAGIC( DISK_VERTEXUSE_A_PLANE_MAGIC );
			/* Normal vectors don't scale */
			/* This is not a plane equation here */
			htond( d->N, (unsigned char *)vua->N, 3 );
		}
		return;
	case NMG_KIND_VERTEXUSE_A_CNURB:
		{
			struct vertexuse_a_cnurb	*vua = (struct vertexuse_a_cnurb *)ip;
			struct disk_vertexuse_a_cnurb	*d;

			d = &((struct disk_vertexuse_a_cnurb *)op)[oindex];
			NMG_CK_VERTEXUSE_A_CNURB(vua);
			PUTMAGIC( DISK_VERTEXUSE_A_CNURB_MAGIC );
			/* (u,v) parameters on curves don't scale */
			htond( d->param, (unsigned char *)vua->param, 3 );
		}
		return;
	case NMG_KIND_VERTEX:
		{
			struct vertex	*v = (struct vertex *)ip;
			struct disk_vertex	*d;
			d = &((struct disk_vertex *)op)[oindex];
			NMG_CK_VERTEX(v);
			PUTMAGIC( DISK_VERTEX_MAGIC );
			INDEXL( d, v, vu_hd );
			INDEX( d, v, vg_p );
		}
		return;
	case NMG_KIND_VERTEX_G:
		{
			struct vertex_g	*vg = (struct vertex_g *)ip;
			struct disk_vertex_g	*d;
			point_t			pt;
			d = &((struct disk_vertex_g *)op)[oindex];
			NMG_CK_VERTEX_G(vg);
			PUTMAGIC( DISK_VERTEX_G_MAGIC );
			VSCALE( pt, vg->coord, local2mm );
			htond( d->coord, (unsigned char *)pt, 3 );
		}
		return;
	}
	bu_log("rt_nmg_edisk kind=%d unknown\n", ecnt[index].kind);
}
#undef INDEX
#undef INDEXL

/*
 *  For symmetry with export, use same macro names and arg ordering,
 *  but here take from "o" (outboard) variable and put in "i" (internal).
 *
 *  NOTE that the "< 0" test here is a comparison with DISK_INDEX_LISTHEAD.
 */
#define INDEX(o,i,ty,elem)	(i)->elem = (struct ty *)ptrs[bu_glong((o)->elem)]
#define INDEXL_HD(oo,ii,elem,hd)	{ \
	register int	sub; \
	if( (sub = bu_glong((oo)->elem.forw)) < 0 ) \
		(ii)->elem.forw = &(hd); \
	else	(ii)->elem.forw = (struct bu_list *)ptrs[sub]; \
	if( (sub = bu_glong((oo)->elem.back)) < 0 ) \
		(ii)->elem.back = &(hd); \
	else	(ii)->elem.back = (struct bu_list *)ptrs[sub]; }

/* For use with the edgeuse l2 / edge_g eu2_hd secondary list */
/* The subscripts will point to the edgeuse, not the edgeuse's l2 rt_list */
#define INDEXL_HD2(oo,ii,elem,hd)	{ \
	register int	sub; \
	register struct edgeuse	*eu2; \
	if( (sub = bu_glong((oo)->elem.forw)) < 0 ) { \
		(ii)->elem.forw = &(hd); \
	} else { \
		eu2 = (struct edgeuse *)ptrs[sub]; \
		NMG_CK_EDGEUSE(eu2); \
		(ii)->elem.forw = &eu2->l2; \
	} \
	if( (sub = bu_glong((oo)->elem.back)) < 0 ) { \
		(ii)->elem.back = &(hd); \
	} else { \
		eu2 = (struct edgeuse *)ptrs[sub]; \
		NMG_CK_EDGEUSE(eu2); \
		(ii)->elem.back = &eu2->l2; \
	} }


/*
 *			R T _ N M G _ I D I S K
 *
 *  Import a given structure from disk to memory format.
 *
 *  Transform geometry by given matrix.
 */
int
rt_nmg_idisk(genptr_t op, genptr_t ip, struct nmg_exp_counts *ecnt, int index, long int **ptrs, const fastf_t *mat, const unsigned char *basep)
        	   		/* ptr to in-memory structure */
        	   		/* base of disk array */
                     	      
   		      
    		       
           	    
                   	       	/* base of whole import record */
{
	int	iindex;		/* index in ip */

	iindex = 0;
	switch(ecnt[index].kind)  {
	case NMG_KIND_MODEL:
		{
			struct model	*m = (struct model *)op;
			struct disk_model	*d;
			d = &((struct disk_model *)ip)[iindex];
			NMG_CK_MODEL(m);
			RT_CK_DISKMAGIC( d->magic, DISK_MODEL_MAGIC );
			INDEXL_HD( d, m, r_hd, m->r_hd );
		}
		return 0;
	case NMG_KIND_NMGREGION:
		{
			struct nmgregion	*r = (struct nmgregion *)op;
			struct disk_nmgregion	*d;
			d = &((struct disk_nmgregion *)ip)[iindex];
			NMG_CK_REGION(r);
			RT_CK_DISKMAGIC( d->magic, DISK_REGION_MAGIC );
			INDEX( d, r, model, m_p );
			INDEX( d, r, nmgregion_a, ra_p );
			INDEXL_HD( d, r, s_hd, r->s_hd );
			INDEXL_HD( d, r, l, r->m_p->r_hd ); /* do after m_p */
			NMG_CK_MODEL(r->m_p);
		}
		return 0;
	case NMG_KIND_NMGREGION_A:
		{
			struct nmgregion_a	*r = (struct nmgregion_a *)op;
			struct disk_nmgregion_a	*d;
			point_t			min, max;
			d = &((struct disk_nmgregion_a *)ip)[iindex];
			NMG_CK_REGION_A(r);
			RT_CK_DISKMAGIC( d->magic, DISK_REGION_A_MAGIC );
			ntohd( (unsigned char *)min, d->min_pt, 3 );
			ntohd( (unsigned char *)max, d->max_pt, 3 );
			bn_rotate_bbox( r->min_pt, r->max_pt, mat, min, max );
		}
		return 0;
	case NMG_KIND_SHELL:
		{
			struct shell	*s = (struct shell *)op;
			struct disk_shell	*d;
			d = &((struct disk_shell *)ip)[iindex];
			NMG_CK_SHELL(s);
			RT_CK_DISKMAGIC( d->magic, DISK_SHELL_MAGIC );
			INDEX( d, s, nmgregion, r_p );
			INDEX( d, s, shell_a, sa_p );
			INDEXL_HD( d, s, fu_hd, s->fu_hd );
			INDEXL_HD( d, s, lu_hd, s->lu_hd );
			INDEXL_HD( d, s, eu_hd, s->eu_hd );
			INDEX( d, s, vertexuse, vu_p );
			NMG_CK_REGION(s->r_p);
			INDEXL_HD( d, s, l, s->r_p->s_hd ); /* after s->r_p */
		}
		return 0;
	case NMG_KIND_SHELL_A:
		{
			struct shell_a	*sa = (struct shell_a *)op;
			struct disk_shell_a	*d;
			point_t			min, max;
			d = &((struct disk_shell_a *)ip)[iindex];
			NMG_CK_SHELL_A(sa);
			RT_CK_DISKMAGIC( d->magic, DISK_SHELL_A_MAGIC );
			ntohd( (unsigned char *)min, d->min_pt, 3 );
			ntohd( (unsigned char *)max, d->max_pt, 3 );
			bn_rotate_bbox( sa->min_pt, sa->max_pt, mat, min, max );
		}
		return 0;
	case NMG_KIND_FACEUSE:
		{
			struct faceuse	*fu = (struct faceuse *)op;
			struct disk_faceuse	*d;
			d = &((struct disk_faceuse *)ip)[iindex];
			NMG_CK_FACEUSE(fu);
			RT_CK_DISKMAGIC( d->magic, DISK_FACEUSE_MAGIC );
			INDEX( d, fu, shell, s_p );
			INDEX( d, fu, faceuse, fumate_p );
			fu->orientation = bu_glong( d->orientation );
			INDEX( d, fu, face, f_p );
			INDEXL_HD( d, fu, lu_hd, fu->lu_hd );
			INDEXL_HD( d, fu, l, fu->s_p->fu_hd ); /* after fu->s_p */
			NMG_CK_FACE(fu->f_p);
			NMG_CK_FACEUSE(fu->fumate_p);
		}
		return 0;
	case NMG_KIND_FACE:
		{
			struct face	*f = (struct face *)op;
			struct disk_face	*d;
			int			g_index;

			d = &((struct disk_face *)ip)[iindex];
			NMG_CK_FACE(f);
			RT_CK_DISKMAGIC( d->magic, DISK_FACE_MAGIC );
			INDEX( d, f, faceuse, fu_p );
			g_index = bu_glong(d->g);
			f->g.magic_p = (long *)ptrs[g_index];
			f->flip = bu_glong( d->flip );
			/* Enrole this face on fg's list of users */
			NMG_CK_FACE_G_EITHER(f->g.magic_p);
			INDEXL_HD( d, f, l, f->g.plane_p->f_hd ); /* after fu->fg_p set */
			NMG_CK_FACEUSE(f->fu_p);
		}
		return 0;
	case NMG_KIND_FACE_G_PLANE:
		{
			struct face_g_plane	*fg = (struct face_g_plane *)op;
			struct disk_face_g_plane	*d;
			plane_t			plane;
			d = &((struct disk_face_g_plane *)ip)[iindex];
			NMG_CK_FACE_G_PLANE(fg);
			RT_CK_DISKMAGIC( d->magic, DISK_FACE_G_PLANE_MAGIC );
			INDEXL_HD( d, fg, f_hd, fg->f_hd );
			ntohd( (unsigned char *)plane, d->N, 4 );
			bn_rotate_plane( fg->N, mat, plane );
		}
		return 0;
	case NMG_KIND_FACE_G_SNURB:
		{
			struct face_g_snurb	*fg = (struct face_g_snurb *)op;
			struct disk_face_g_snurb	*d;
			d = &((struct disk_face_g_snurb *)ip)[iindex];
			NMG_CK_FACE_G_SNURB(fg);
			RT_CK_DISKMAGIC( d->magic, DISK_FACE_G_SNURB_MAGIC );
			INDEXL_HD( d, fg, f_hd, fg->f_hd );
			fg->order[0] = bu_glong( d->u_order );
			fg->order[1] = bu_glong( d->v_order );
			fg->u.k_size = bu_glong( d->u_size );
			fg->u.knots = rt_nmg_import_fastf( basep, ecnt,
				bu_glong( d->u_knots ), (matp_t)NULL,
				fg->u.k_size, 0 );
			fg->v.k_size = bu_glong( d->v_size );
			fg->v.knots = rt_nmg_import_fastf( basep, ecnt,
				bu_glong( d->v_knots ), (matp_t)NULL,
				fg->v.k_size, 0 );
			fg->s_size[0] = bu_glong( d->us_size );
			fg->s_size[1] = bu_glong( d->vs_size );
			fg->pt_type = bu_glong( d->pt_type );
			/* Transform ctl_points by 'mat' */
			fg->ctl_points = rt_nmg_import_fastf( basep, ecnt,
				bu_glong( d->ctl_points ), (matp_t)mat,
				fg->s_size[0] * fg->s_size[1],
				fg->pt_type );
		}
		return 0;
	case NMG_KIND_LOOPUSE:
		{
			struct loopuse	*lu = (struct loopuse *)op;
			struct disk_loopuse	*d;
			int			up_index;
			int			up_kind;

			d = &((struct disk_loopuse *)ip)[iindex];
			NMG_CK_LOOPUSE(lu);
			RT_CK_DISKMAGIC( d->magic, DISK_LOOPUSE_MAGIC );
			up_index = bu_glong(d->up);
			lu->up.magic_p = (long *)ptrs[up_index];
			INDEX( d, lu, loopuse, lumate_p );
			lu->orientation = bu_glong( d->orientation );
			INDEX( d, lu, loop, l_p );
			up_kind = ecnt[up_index].kind;
			if( up_kind == NMG_KIND_FACEUSE )  {
				INDEXL_HD( d, lu, l, lu->up.fu_p->lu_hd );
			} else if( up_kind == NMG_KIND_SHELL )  {
				INDEXL_HD( d, lu, l, lu->up.s_p->lu_hd );
			} else bu_log("bad loopuse up, index=%d, kind=%d\n", up_index, up_kind);
			INDEXL_HD( d, lu, down_hd, lu->down_hd );
			if( lu->down_hd.forw == BU_LIST_NULL )
				rt_bomb("rt_nmg_idisk: null loopuse down_hd.forw\n");
			NMG_CK_LOOP(lu->l_p);
		}
		return 0;
	case NMG_KIND_LOOP:
		{
			struct loop	*loop = (struct loop *)op;
			struct disk_loop	*d;
			d = &((struct disk_loop *)ip)[iindex];
			NMG_CK_LOOP(loop);
			RT_CK_DISKMAGIC( d->magic, DISK_LOOP_MAGIC );
			INDEX( d, loop, loopuse, lu_p );
			INDEX( d, loop, loop_g, lg_p );
			NMG_CK_LOOPUSE(loop->lu_p);
		}
		return 0;
	case NMG_KIND_LOOP_G:
		{
			struct loop_g	*lg = (struct loop_g *)op;
			struct disk_loop_g	*d;
			point_t			min, max;
			d = &((struct disk_loop_g *)ip)[iindex];
			NMG_CK_LOOP_G(lg);
			RT_CK_DISKMAGIC( d->magic, DISK_LOOP_G_MAGIC );
			ntohd( (unsigned char *)min, d->min_pt, 3 );
			ntohd( (unsigned char *)max, d->max_pt, 3 );
			bn_rotate_bbox( lg->min_pt, lg->max_pt, mat, min, max );
		}
		return 0;
	case NMG_KIND_EDGEUSE:
		{
			struct edgeuse	*eu = (struct edgeuse *)op;
			struct disk_edgeuse	*d;
			int			up_index;
			int			up_kind;

			d = &((struct disk_edgeuse *)ip)[iindex];
			NMG_CK_EDGEUSE(eu);
			RT_CK_DISKMAGIC( d->magic, DISK_EDGEUSE_MAGIC );
			up_index = bu_glong(d->up);
			eu->up.magic_p = (long *)ptrs[up_index];
			INDEX( d, eu, edgeuse, eumate_p );
			INDEX( d, eu, edgeuse, radial_p );
			INDEX( d, eu, edge, e_p );
			eu->orientation = bu_glong( d->orientation );
			INDEX( d, eu, vertexuse, vu_p );
			up_kind = ecnt[up_index].kind;
			if( up_kind == NMG_KIND_LOOPUSE )  {
				INDEXL_HD( d, eu, l, eu->up.lu_p->down_hd );
			} else if( up_kind == NMG_KIND_SHELL )  {
				INDEXL_HD( d, eu, l, eu->up.s_p->eu_hd );
			} else bu_log("bad edgeuse up, index=%d, kind=%d\n", up_index, up_kind);
			eu->g.magic_p = (long *)ptrs[bu_glong(d->g)];
			NMG_CK_EDGE(eu->e_p);
			NMG_CK_EDGEUSE(eu->eumate_p);
			NMG_CK_EDGEUSE(eu->radial_p);
			NMG_CK_VERTEXUSE(eu->vu_p);
			if( eu->g.magic_p != NULL )
			{
				NMG_CK_EDGE_G_EITHER(eu->g.magic_p);

				/* Note that l2 subscripts will be for edgeuse, not l2 */
				/* g.lseg_p->eu_hd2 is a pun for g.cnurb_p->eu_hd2 also */
				INDEXL_HD2( d, eu, l2, eu->g.lseg_p->eu_hd2 );
			}
			else
			{
				eu->l2.forw = &eu->l2;
				eu->l2.back = &eu->l2;
			}
		}
		return 0;
	case NMG_KIND_EDGE:
		{
			struct edge	*e = (struct edge *)op;
			struct disk_edge	*d;
			d = &((struct disk_edge *)ip)[iindex];
			NMG_CK_EDGE(e);
			RT_CK_DISKMAGIC( d->magic, DISK_EDGE_MAGIC );
			e->is_real = bu_glong( d->is_real );
			INDEX( d, e, edgeuse, eu_p );
			NMG_CK_EDGEUSE(e->eu_p);
		}
		return 0;
	case NMG_KIND_EDGE_G_LSEG:
		{
			struct edge_g_lseg	*eg = (struct edge_g_lseg *)op;
			struct disk_edge_g_lseg	*d;
			point_t			pt;
			vect_t			dir;

			d = &((struct disk_edge_g_lseg *)ip)[iindex];
			NMG_CK_EDGE_G_LSEG(eg);
			RT_CK_DISKMAGIC( d->magic, DISK_EDGE_G_LSEG_MAGIC );
			/* Forw subscript points to edgeuse, not edgeuse2 */
			INDEXL_HD2( d, eg, eu_hd2, eg->eu_hd2 );
			ntohd((unsigned char *)pt, d->e_pt, 3);
			ntohd((unsigned char *)dir, d->e_dir, 3);
			MAT4X3PNT( eg->e_pt, mat, pt );
			MAT4X3VEC( eg->e_dir, mat, dir );
		}
		return 0;
	case NMG_KIND_EDGE_G_CNURB:
		{
			struct edge_g_cnurb	*eg = (struct edge_g_cnurb *)op;
			struct disk_edge_g_cnurb	*d;
			d = &((struct disk_edge_g_cnurb *)ip)[iindex];
			NMG_CK_EDGE_G_CNURB(eg);
			RT_CK_DISKMAGIC( d->magic, DISK_EDGE_G_CNURB_MAGIC );
			INDEXL_HD2( d, eg, eu_hd2, eg->eu_hd2 );
			eg->order = bu_glong( d->order );

			/* If order is zero, so is everything else */
			if( eg->order == 0 )  return 0;

			eg->k.k_size = bu_glong( d->k_size );
			eg->k.knots = rt_nmg_import_fastf( basep, ecnt,
				bu_glong( d->knots ), (matp_t)NULL,
				eg->k.k_size, 0 );
			eg->c_size = bu_glong( d->c_size );
			eg->pt_type = bu_glong( d->pt_type );
			/*
			 * The curve's control points are in parameter space.
			 * They do NOT get transformed!
			 */
			if( RT_NURB_EXTRACT_PT_TYPE(eg->pt_type) == RT_NURB_PT_UV )  {
				/* UV coords on snurb surface don't get xformed */
				eg->ctl_points = rt_nmg_import_fastf( basep,
					ecnt,
					bu_glong( d->ctl_points ), (matp_t)NULL,
					eg->c_size, eg->pt_type );
			} else {
				/* XYZ coords on planar face DO get xformed */
				eg->ctl_points = rt_nmg_import_fastf( basep,
					ecnt,
					bu_glong( d->ctl_points ), (matp_t)mat,
					eg->c_size, eg->pt_type );
			}
		}
		return 0;
	case NMG_KIND_VERTEXUSE:
		{
			struct vertexuse	*vu = (struct vertexuse *)op;
			struct disk_vertexuse	*d;
			d = &((struct disk_vertexuse *)ip)[iindex];
			NMG_CK_VERTEXUSE(vu);
			RT_CK_DISKMAGIC( d->magic, DISK_VERTEXUSE_MAGIC );
			vu->up.magic_p = (long *)ptrs[bu_glong(d->up)];
			INDEX( d, vu, vertex, v_p );
			vu->a.magic_p = (long *)ptrs[bu_glong(d->a)];
			NMG_CK_VERTEX(vu->v_p);
			if(vu->a.magic_p)NMG_CK_VERTEXUSE_A_EITHER(vu->a.magic_p);
			INDEXL_HD( d, vu, l, vu->v_p->vu_hd );
		}
		return 0;
	case NMG_KIND_VERTEXUSE_A_PLANE:
		{
			struct vertexuse_a_plane	*vua = (struct vertexuse_a_plane *)op;
			struct disk_vertexuse_a_plane	*d;
			vect_t			norm;
			d = &((struct disk_vertexuse_a_plane *)ip)[iindex];
			NMG_CK_VERTEXUSE_A_PLANE(vua);
			RT_CK_DISKMAGIC( d->magic, DISK_VERTEXUSE_A_PLANE_MAGIC );
			ntohd( (unsigned char *)norm, d->N, 3 );
			MAT4X3VEC( vua->N, mat, norm );
		}
		return 0;
	case NMG_KIND_VERTEXUSE_A_CNURB:
		{
			struct vertexuse_a_cnurb	*vua = (struct vertexuse_a_cnurb *)op;
			struct disk_vertexuse_a_cnurb	*d;
			d = &((struct disk_vertexuse_a_cnurb *)ip)[iindex];
			NMG_CK_VERTEXUSE_A_CNURB(vua);
			RT_CK_DISKMAGIC( d->magic, DISK_VERTEXUSE_A_CNURB_MAGIC );
			/* These parameters are invarient w.r.t. 'mat' */
			ntohd( (unsigned char *)vua->param, d->param, 3 );
		}
		return 0;
	case NMG_KIND_VERTEX:
		{
			struct vertex	*v = (struct vertex *)op;
			struct disk_vertex	*d;
			d = &((struct disk_vertex *)ip)[iindex];
			NMG_CK_VERTEX(v);
			RT_CK_DISKMAGIC( d->magic, DISK_VERTEX_MAGIC );
			INDEXL_HD( d, v, vu_hd, v->vu_hd );
			INDEX( d, v, vertex_g, vg_p );
		}
		return 0;
	case NMG_KIND_VERTEX_G:
		{
			struct vertex_g	*vg = (struct vertex_g *)op;
			struct disk_vertex_g	*d;
			point_t			pt;
			d = &((struct disk_vertex_g *)ip)[iindex];
			NMG_CK_VERTEX_G(vg);
			RT_CK_DISKMAGIC( d->magic, DISK_VERTEX_G_MAGIC );
			ntohd( (unsigned char *)pt, d->coord, 3 );
			MAT4X3PNT( vg->coord, mat, pt );
		}
		return 0;
	}
	bu_log("rt_nmg_idisk kind=%d unknown\n", ecnt[index].kind);
	return -1;
}

/*
 *			R T _ N M G _ I A L L O C
 *
 *  Allocate storage for all the in-memory NMG structures,
 *  in preparation for the importation operation,
 *  using the GET_xxx() macros, so that m->maxindex, etc,
 *  are all appropriately handled.
 */
struct model *
rt_nmg_ialloc(long int **ptrs, struct nmg_exp_counts *ecnt, int *kind_counts)
{
	struct model		*m = (struct model *)0;
	int			subscript;
	int			kind;
	int			j;

	subscript = 1;
	for( kind = 0; kind < NMG_N_KINDS; kind++ )  {
#if DEBUG
bu_log("%d  %s\n", kind_counts[kind], rt_nmg_kind_names[kind] );
#endif
		if( kind == NMG_KIND_DOUBLE_ARRAY )  continue;
		for( j = 0; j < kind_counts[kind]; j++ )  {
			ecnt[subscript].kind = kind;
			ecnt[subscript].per_struct_index = 0; /* unused on import */
			switch( kind )  {
			case NMG_KIND_MODEL:
				if( m )  rt_bomb("multiple models?");
				m = nmg_mm();
				/* Keep disk indices & new indices equal... */
				m->maxindex++;
				ptrs[subscript] = (long *)m;
				break;
			case NMG_KIND_NMGREGION:
				{
					struct nmgregion	*r;
					GET_REGION( r, m );
					r->l.magic = NMG_REGION_MAGIC;
					BU_LIST_INIT( &r->s_hd );
					ptrs[subscript] = (long *)r;
				}
				break;
			case NMG_KIND_NMGREGION_A:
				{
					struct nmgregion_a		*ra;
					GET_REGION_A( ra, m );
					ra->magic = NMG_REGION_A_MAGIC;
					ptrs[subscript] = (long *)ra;
				}
				break;
			case NMG_KIND_SHELL:
				{
					struct shell	*s;
					GET_SHELL( s, m );
					s->l.magic = NMG_SHELL_MAGIC;
					BU_LIST_INIT( &s->fu_hd );
					BU_LIST_INIT( &s->lu_hd );
					BU_LIST_INIT( &s->eu_hd );
					ptrs[subscript] = (long *)s;
				}
				break;
			case NMG_KIND_SHELL_A:
				{
					struct shell_a	*sa;
					GET_SHELL_A( sa, m );
					sa->magic = NMG_SHELL_A_MAGIC;
					ptrs[subscript] = (long *)sa;
				}
				break;
			case NMG_KIND_FACEUSE:
				{
					struct faceuse	*fu;
					GET_FACEUSE( fu, m );
					fu->l.magic = NMG_FACEUSE_MAGIC;
					BU_LIST_INIT( &fu->lu_hd );
					ptrs[subscript] = (long *)fu;
				}
				break;
			case NMG_KIND_FACE:
				{
					struct face	*f;
					GET_FACE( f, m );
					f->l.magic = NMG_FACE_MAGIC;
					ptrs[subscript] = (long *)f;
				}
				break;
			case NMG_KIND_FACE_G_PLANE:
				{
					struct face_g_plane	*fg;
					GET_FACE_G_PLANE( fg, m );
					fg->magic = NMG_FACE_G_PLANE_MAGIC;
					BU_LIST_INIT( &fg->f_hd );
					ptrs[subscript] = (long *)fg;
				}
				break;
			case NMG_KIND_FACE_G_SNURB:
				{
					struct face_g_snurb	*fg;
					GET_FACE_G_SNURB( fg, m );
					fg->l.magic = NMG_FACE_G_SNURB_MAGIC;
					BU_LIST_INIT( &fg->f_hd );
					ptrs[subscript] = (long *)fg;
				}
				break;
			case NMG_KIND_LOOPUSE:
				{
					struct loopuse	*lu;
					GET_LOOPUSE( lu, m );
					lu->l.magic = NMG_LOOPUSE_MAGIC;
					BU_LIST_INIT( &lu->down_hd );
					ptrs[subscript] = (long *)lu;
				}
				break;
			case NMG_KIND_LOOP:
				{
					struct loop	*l;
					GET_LOOP( l, m );
					l->magic = NMG_LOOP_MAGIC;
					ptrs[subscript] = (long *)l;
				}
				break;
			case NMG_KIND_LOOP_G:
				{
					struct loop_g	*lg;
					GET_LOOP_G( lg, m );
					lg->magic = NMG_LOOP_G_MAGIC;
					ptrs[subscript] = (long *)lg;
				}
				break;
			case NMG_KIND_EDGEUSE:
				{
					struct edgeuse	*eu;
					GET_EDGEUSE( eu, m );
					eu->l.magic = NMG_EDGEUSE_MAGIC;
					eu->l2.magic = NMG_EDGEUSE2_MAGIC;
					ptrs[subscript] = (long *)eu;
				}
				break;
			case NMG_KIND_EDGE:
				{
					struct edge	*e;
					GET_EDGE( e, m );
					e->magic = NMG_EDGE_MAGIC;
					ptrs[subscript] = (long *)e;
				}
				break;
			case NMG_KIND_EDGE_G_LSEG:
				{
					struct edge_g_lseg	*eg;
					GET_EDGE_G_LSEG( eg, m );
					eg->l.magic = NMG_EDGE_G_LSEG_MAGIC;
					BU_LIST_INIT( &eg->eu_hd2 );
					ptrs[subscript] = (long *)eg;
				}
				break;
			case NMG_KIND_EDGE_G_CNURB:
				{
					struct edge_g_cnurb	*eg;
					GET_EDGE_G_CNURB( eg, m );
					eg->l.magic = NMG_EDGE_G_CNURB_MAGIC;
					BU_LIST_INIT( &eg->eu_hd2 );
					ptrs[subscript] = (long *)eg;
				}
				break;
			case NMG_KIND_VERTEXUSE:
				{
					struct vertexuse	*vu;
					GET_VERTEXUSE( vu, m );
					vu->l.magic = NMG_VERTEXUSE_MAGIC;
					ptrs[subscript] = (long *)vu;
				}
				break;
			case NMG_KIND_VERTEXUSE_A_PLANE:
				{
					struct vertexuse_a_plane	*vua;
					GET_VERTEXUSE_A_PLANE( vua, m );
					vua->magic = NMG_VERTEXUSE_A_PLANE_MAGIC;
					ptrs[subscript] = (long *)vua;
				}
				break;
			case NMG_KIND_VERTEXUSE_A_CNURB:
				{
					struct vertexuse_a_cnurb	*vua;
					GET_VERTEXUSE_A_CNURB( vua, m );
					vua->magic = NMG_VERTEXUSE_A_CNURB_MAGIC;
					ptrs[subscript] = (long *)vua;
				}
				break;
			case NMG_KIND_VERTEX:
				{
					struct vertex	*v;
					GET_VERTEX( v, m );
					v->magic = NMG_VERTEX_MAGIC;
					BU_LIST_INIT( &v->vu_hd );
					ptrs[subscript] = (long *)v;
				}
				break;
			case NMG_KIND_VERTEX_G:
				{
					struct vertex_g	*vg;
					GET_VERTEX_G( vg, m );
					vg->magic = NMG_VERTEX_G_MAGIC;
					ptrs[subscript] = (long *)vg;
				}
				break;
			default:
				bu_log("bad kind = %d\n", kind);
				ptrs[subscript] = (long *)0;
				break;
			}
#if DEBUG
bu_log("   disk_index=%d, kind=%s, ptr=x%x, final_index=%d\n",
subscript, rt_nmg_kind_names[kind],
ptrs[subscript], nmg_index_of_struct(ptrs[subscript]) );
#endif
			/* new_subscript unused on import except for printf()s */
			ecnt[subscript].new_subscript = nmg_index_of_struct(ptrs[subscript]);
			subscript++;
		}
	}
	return(m);
}

/*
 *			R T _ N M G _ I 2 A L L O C
 *
 *  Find the locations of all the variable-sized fastf_t arrays in
 *  the input record.  Record that position as a byte offset from the
 *  very front of the input record in ecnt[], indexed by subscript number.
 *
 *  No storage is allocated here, that will be done by rt_nmg_import_fastf()
 *  on the fly.
 *  A separate call to bu_malloc() will be used, so that nmg_keg(), etc.,
 *  can kill each array as appropriate.
 */
void
rt_nmg_i2alloc(struct nmg_exp_counts *ecnt, unsigned char *cp, int *kind_counts, int maxindex)
{
	register int	kind;
	int		nkind;
	int		subscript;
	int		offset;
	int		i;

	nkind = kind_counts[NMG_KIND_DOUBLE_ARRAY];
	if( nkind <= 0 )  return;

	/* First, find the beginning of the fastf_t arrays */
	subscript = 1;
	offset = 0;
	for( kind = 0; kind < NMG_N_KINDS; kind++ )  {
		if( kind == NMG_KIND_DOUBLE_ARRAY )  continue;
		offset += rt_nmg_disk_sizes[kind] * kind_counts[kind];
		subscript += kind_counts[kind];
	}

	/* Should have found the first one now */
	RT_CK_DISKMAGIC( cp + offset, DISK_DOUBLE_ARRAY_MAGIC );
#if DEBUG
bu_log("rt_nmg_i2alloc() first one at cp=x%x, offset=%d, subscript=%d\n", cp, offset, subscript );
#endif
	for( i=0; i < nkind; i++ )  {
		int	ndouble;
		RT_CK_DISKMAGIC( cp + offset, DISK_DOUBLE_ARRAY_MAGIC );
		ndouble = bu_glong( cp + offset + 4 );
		ecnt[subscript].kind = NMG_KIND_DOUBLE_ARRAY;
		/* Stored byte offset is from beginning of disk record */
		ecnt[subscript].byte_offset = offset;
		offset += (4+4) + 8*ndouble;
		subscript++;
	}
}

/*
 *			R T _ N M G _ I M P O R T _ I N T E R N A L
 *
 *  Import an NMG from the database format to the internal format.
 *  Apply modeling transformations as well.
 *
 *  Special subscripts are used in the disk file:
 *	-1	indicates a pointer to the rt_list structure which
 *		heads a linked list, and is not the first struct element.
 *	 0	indicates that a null pointer should be used.
 */
int
rt_nmg_import_internal(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, int rebound, const struct bn_tol *tol)
{
	struct model			*m;
	union record			*rp;
	int				kind_counts[NMG_N_KINDS];
	unsigned char			*cp;
	long				**real_ptrs;
	long				**ptrs;
	struct nmg_exp_counts		*ecnt;
	int				i;
	int				maxindex;
	int				kind;
	static long			bad_magic = 0x999;

	BU_CK_EXTERNAL( ep );
	BN_CK_TOL( tol );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != DBID_NMG )  {
		bu_log("rt_nmg_import: defective record\n");
		return(-1);
	}

	/*
	 *  Check for proper version.
	 *  In the future, this will be the backwards-compatability hook.
	 */
	if( rp->nmg.N_version != DISK_MODEL_VERSION )  {
		bu_log("rt_nmg_import:  expected NMG '.g' format version %d, got version %d, aborting.\n",
			DISK_MODEL_VERSION,
			rp->nmg.N_version );
		return -1;
	}

	/* Obtain counts of each kind of structure */
	maxindex = 1;
	for( kind = 0; kind < NMG_N_KINDS; kind++ )  {
		kind_counts[kind] = bu_glong( rp->nmg.N_structs+4*kind );
		maxindex += kind_counts[kind];
	}
#if DEBUG
	bu_log("import maxindex=%d\n", maxindex);
#endif

	/* Collect overall new subscripts, and structure-specific indices */
	ecnt = (struct nmg_exp_counts *)bu_calloc( maxindex+3,
		sizeof(struct nmg_exp_counts), "ecnt[]" );
	real_ptrs = (long **)bu_calloc( maxindex+3,
		sizeof(long *), "ptrs[]" );
	/* So that indexing [-1] gives an appropriately bogus magic # */
	ptrs = real_ptrs+1;
	ptrs[-1] = &bad_magic;		/* [-1] gives bad magic */
	ptrs[0] = (long *)0;		/* [0] gives NULL */
	ptrs[maxindex] = &bad_magic;	/* [maxindex] gives bad magic */
	ptrs[maxindex+1] = &bad_magic;	/* [maxindex+1] gives bad magic */

	/* Allocate storage for all the NMG structs, in ptrs[] */
	m = rt_nmg_ialloc( ptrs, ecnt, kind_counts );

	/* Locate the variably sized fastf_t arrays.  ecnt[] has room. */
	cp = (unsigned char *)(rp+1);	/* start at first granule in */
	rt_nmg_i2alloc( ecnt, cp, kind_counts, maxindex );

	/* Import each structure, in turn */
	for( i=1; i < maxindex; i++ )  {
		/* If we made it to the last kind, stop.  Nothing follows */
		if( ecnt[i].kind == NMG_KIND_DOUBLE_ARRAY )  break;
		if( rt_nmg_idisk( (genptr_t)(ptrs[i]), (genptr_t)cp,
			ecnt, i, ptrs, mat, (unsigned char *)(rp+1) ) < 0 )
				return -1;	/* FAIL */
		cp += rt_nmg_disk_sizes[ecnt[i].kind];
	}

	if( rebound )  {
		/* Recompute all bounding boxes in model */
		nmg_rebound(m, tol);
	} else {
		/*
		 *  Need to recompute bounding boxes for the faces here.
		 *  Other bounding boxes will exist and be intact if NMG
		 *  exporter wrote the _a structures.
		 */
		for( i=1; i < maxindex; i++ )  {
			if( ecnt[i].kind != NMG_KIND_FACE )  continue;
			nmg_face_bb( (struct face *)ptrs[i], tol );
		}
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_NMG;
	ip->idb_meth = &rt_functab[ID_NMG];
	ip->idb_ptr = (genptr_t)m;

	bu_free( (char *)ecnt, "ecnt[]" );
	bu_free( (char *)real_ptrs, "ptrs[]" );

	return(0);			/* OK */
}

/*
 *			R T _ N M G _ E X P O R T _ I N T E R N A L
 *
 *  The name is added by the caller, in the usual place.
 *
 *  When the "compact" flag is set, bounding boxes from (at present)
 *	nmgregion_a
 *	shell_a
 *	loop_g
 *  are not converted for storage in the database.
 *  They should be re-generated at import time.
 *
 *  If the "compact" flag is not set, then the NMG model is saved, verbatim.
 *
 *  The overall layout of the on-disk NMG is like this:
 *
 *	+---------------------------+
 *	|  NMG header granule       |
 *	|    solid name             |
 *	|    # additional granules  |
 *	|    format version         |
 *	|    kind_count[] array     |
 *	+---------------------------+
 *	|                           |
 *	|                           |
 *	~     N_count granules      ~
 *	~              :            ~
 *	|              :            |
 *	|                           |
 *	+---------------------------+
 *
 *  In the additional granules, all structures of "kind" 0 (model) go first,
 *  followed by all structures of kind 1 (nmgregion), etc.
 *  As each structure is output, it is assigned a subscript number,
 *  starting with #1 for the model structure.
 *  All pointers are converted to the matching subscript numbers.
 *  An on-disk subscript of zero indicates a corresponding NULL pointer in memory.
 *  All integers are converted to network (Big-Endian) byte order.
 *  All floating point values are stored in network (Big-Endian IEEE) format.
 */
int
rt_nmg_export_internal(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, int compact)
{
	struct model			*m;
	union record			*rp;
	struct nmg_struct_counts	cntbuf;
	long				**ptrs;
	struct nmg_exp_counts		*ecnt;
	int				i;
	int				subscript;
	int				kind_counts[NMG_N_KINDS];
	genptr_t			disk_arrays[NMG_N_KINDS];
	int				additional_grans;
	int				tot_size;
	int				kind;
	char				*cp;
	int				double_count;
	int				fastf_byte_count;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_NMG )  return(-1);
	m = (struct model *)ip->idb_ptr;
	NMG_CK_MODEL(m);

	/* As a by-product, this fills in the ptrs[] array! */
	bzero( (char *)&cntbuf, sizeof(cntbuf) );
	ptrs = nmg_m_struct_count( &cntbuf, m );
#if DEBUG
	nmg_pr_struct_counts( &cntbuf, "Counts in rt_nmg_export" );
#endif

	/* Collect overall new subscripts, and structure-specific indices */
	ecnt = (struct nmg_exp_counts *)bu_calloc( m->maxindex+1,
		sizeof(struct nmg_exp_counts), "ecnt[]" );
	for( i = 0; i < NMG_N_KINDS; i++ )
		kind_counts[i] = 0;
	subscript = 1;		/* must be larger than DISK_INDEX_NULL */
	double_count = 0;
	fastf_byte_count = 0;
	for( i=0; i < m->maxindex; i++ )  {
		if( ptrs[i] == (long *)0 )  {
			ecnt[i].kind = -1;
			continue;
		}
		kind = rt_nmg_magic_to_kind( *(ptrs[i]) );
		ecnt[i].per_struct_index = kind_counts[kind]++;
		ecnt[i].kind = kind;
		/* Handle the variable sized kinds */
		switch(kind)  {
		case NMG_KIND_FACE_G_SNURB:
			{
				struct face_g_snurb	*fg;
				int			ndouble;
				fg = (struct face_g_snurb *)ptrs[i];
				ecnt[i].first_fastf_relpos = kind_counts[NMG_KIND_DOUBLE_ARRAY];
				kind_counts[NMG_KIND_DOUBLE_ARRAY] += 3;
				ndouble =  fg->u.k_size +
					   fg->v.k_size +
					   fg->s_size[0] * fg->s_size[1] *
				   RT_NURB_EXTRACT_COORDS(fg->pt_type);
				double_count += ndouble;
				ecnt[i].byte_offset = fastf_byte_count;
				fastf_byte_count += 3*(4+4) + 8*ndouble;
			}
			break;
		case NMG_KIND_EDGE_G_CNURB:
			{
				struct edge_g_cnurb	*eg;
				int			ndouble;
				eg = (struct edge_g_cnurb *)ptrs[i];
				ecnt[i].first_fastf_relpos = kind_counts[NMG_KIND_DOUBLE_ARRAY];
				/* If order is zero, no knots or ctl_points */
				if( eg->order == 0 )  break;
				kind_counts[NMG_KIND_DOUBLE_ARRAY] += 2;
				ndouble = eg->k.k_size + eg->c_size *
					RT_NURB_EXTRACT_COORDS(eg->pt_type);
				double_count += ndouble;
				ecnt[i].byte_offset = fastf_byte_count;
				fastf_byte_count += 2*(4+4) + 8*ndouble;
			}
			break;
		}
	}
	if( compact )  {
		kind_counts[NMG_KIND_NMGREGION_A] = 0;
		kind_counts[NMG_KIND_SHELL_A] = 0;
		kind_counts[NMG_KIND_LOOP_G] = 0;
	}

	/* Assign new subscripts to ascending guys of same kind */
	for( kind = 0; kind < NMG_N_KINDS; kind++ )  {
		if( compact && ( kind == NMG_KIND_NMGREGION_A ||
		    kind == NMG_KIND_SHELL_A ||
		    kind == NMG_KIND_LOOP_G ) )  {
			/*
			 * Don't assign any new subscripts for them.
		    	 * Instead, use DISK_INDEX_NULL, yielding null ptrs.
		    	 */
			for( i=0; i < m->maxindex; i++ )  {
				if( ptrs[i] == (long *)0 )  continue;
				if( ecnt[i].kind != kind )  continue;
				ecnt[i].new_subscript = DISK_INDEX_NULL;
			}
			continue;
		}
		for( i=0; i < m->maxindex; i++ )  {
			if( ptrs[i] == (long *)0 )  continue;
			if( ecnt[i].kind != kind )  continue;
			ecnt[i].new_subscript = subscript++;
		}
	}
	/* Tack on the variable sized fastf_t arrays at the end */
	rt_nmg_cur_fastf_subscript = subscript;
	subscript += kind_counts[NMG_KIND_DOUBLE_ARRAY];

	/* Sanity checking */
#if DEBUG
bu_log("Mapping of old index to new index, and kind\n");
#endif
	for( i=0; i < m->maxindex; i++ )  {
		if( ptrs[i] == (long *)0 )  continue;
#if DEBUG
		bu_log(" %4d %4d %s (%d)\n",
			i, ecnt[i].new_subscript,
			rt_nmg_kind_names[ecnt[i].kind], ecnt[i].kind);
#endif
		if( nmg_index_of_struct(ptrs[i]) != i )  {
			bu_log("***ERROR, ptrs[%d]->index = %d\n",
				i, nmg_index_of_struct(ptrs[i]) );
		}
		if( rt_nmg_magic_to_kind(*ptrs[i]) != ecnt[i].kind )  {
			bu_log("@@@@@@ERROR, ptrs[%d] kind(%d) != %d\n",
				i, rt_nmg_magic_to_kind(*ptrs[i]),
				ecnt[i].kind);
		}
	}

	tot_size = 0;
	for( i = 0; i < NMG_N_KINDS; i++ )  {
#if DEBUG
		bu_log("%d of kind %s (%d)\n",
			kind_counts[i], rt_nmg_kind_names[i], i);
#endif
		if( kind_counts[i] <= 0 )  {
			disk_arrays[i] = GENPTR_NULL;
			continue;
		}
		tot_size += kind_counts[i] * rt_nmg_disk_sizes[i];
	}
	/* Account for variable sized double arrays, at the end */
	tot_size += kind_counts[NMG_KIND_DOUBLE_ARRAY] * (4+4) +
			double_count * 8;

	ecnt[0].byte_offset = subscript; /* implicit arg to rt_nmg_reindex() */

	additional_grans = (tot_size + sizeof(union record)-1) / sizeof(union record);
	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = (1 + additional_grans) * sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "nmg external");
	rp = (union record *)ep->ext_buf;
	rp->nmg.N_id = DBID_NMG;
	rp->nmg.N_version = DISK_MODEL_VERSION;
	(void)bu_plong( rp->nmg.N_count, additional_grans );

	/* Record counts of each kind of structure */
	for( kind = 0; kind < NMG_N_KINDS; kind++ )  {
		(void)bu_plong( rp->nmg.N_structs+4*kind, kind_counts[kind] );
	}

	cp = (char *)(rp+1);	/* advance one granule */
	for( i=0; i < NMG_N_KINDS; i++ )  {
		disk_arrays[i] = (genptr_t)cp;
		cp += kind_counts[i] * rt_nmg_disk_sizes[i];
	}
	/* disk_arrays[NMG_KIND_DOUBLE_ARRAY] is set properly because it is last */
	rt_nmg_fastf_p = (unsigned char *)disk_arrays[NMG_KIND_DOUBLE_ARRAY];

	/* Convert all the structures to their disk versions */
	for( i = m->maxindex-1; i >= 0; i-- )  {
		if( ptrs[i] == (long *)0 )  continue;
		kind = ecnt[i].kind;
		if( kind_counts[kind] <= 0 )  continue;
		rt_nmg_edisk( (genptr_t)(disk_arrays[kind]),
			(genptr_t)(ptrs[i]), ecnt, i, local2mm );
	}

	bu_free( (char *)ptrs, "ptrs[]" );
	bu_free( (char *)ecnt, "ecnt[]" );

	return(0);
}

/*
 *			R T _ N M G _ I M P O R T
 *
 *  Import an NMG from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_nmg_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct model			*m;
	union record			*rp;
	struct bn_tol			tol;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != DBID_NMG )  {
		bu_log("rt_nmg_import: defective record\n");
		return(-1);
	}

	/* XXX The bounding box routines need a tolerance.
	 * XXX This is sheer guesswork here.
	 * As long as this NMG is going to be turned into vlist, or
	 * handed off to the boolean evaluator, any non-zero numbers are fine.
	 */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	if( rt_nmg_import_internal( ip, ep, mat, 1, &tol ) < 0 )
		return(-1);

	m = (struct model *)ip->idb_ptr;
	NMG_CK_MODEL(m);

	if( RT_G_DEBUG || rt_g.NMG_debug )
		nmg_vmodel(m);

	return(0);			/* OK */
}

/*
 *			R T _ N M G _ I M P O R T 5
 */
int
rt_nmg_import5( struct rt_db_internal	*ip,
		struct bu_external	*ep,
		register const mat_t	mat,
		const struct db_i	*dbip )
{
	struct model		*m;
	struct bn_tol		tol;
	int			maxindex;
	int			kind;
	int			kind_counts[NMG_N_KINDS];
	unsigned char		*dp;		/* data pointer */
	genptr_t		startdata;	/* data pointer */
	long			**real_ptrs;
	long			**ptrs;
	struct nmg_exp_counts	*ecnt;
	register int		i;
	static long		bad_magic = 0x999;

	BU_CK_EXTERNAL( ep );
	dp = (genptr_t)ep->ext_buf;

	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	{
		int version;
		version = bu_glong(dp);
		dp+= SIZEOF_NETWORK_LONG;
		if (version != DISK_MODEL_VERSION ) {
			bu_log("rt_nmg_import: expected NMG '.g' format version %d, got %d, aborting nmg solid import\n",
				DISK_MODEL_VERSION, version);
			return -1;
		}
	}
	maxindex = 1;
	for (kind =0 ; kind < NMG_N_KINDS; kind++) {
		kind_counts[kind] = bu_glong( dp );
		dp+= SIZEOF_NETWORK_LONG;
		maxindex += kind_counts[kind];
	}

	startdata = dp;

	/* Collect overall new subscripts, and structure-specific indices */
	ecnt = (struct nmg_exp_counts *) bu_calloc( maxindex+3, 
		sizeof(struct nmg_exp_counts), "ecnt[]");
	real_ptrs = (long **)bu_calloc( maxindex+3, sizeof(long *), "ptrs[]");
	/* some safety checking.  Indexing by, -1, 0, n+1, N+2 give interesting results */
	ptrs = real_ptrs+1;
	ptrs[-1] = &bad_magic;
	ptrs[0] = (long *)0;
	ptrs[maxindex] = &bad_magic;
	ptrs[maxindex+1] = &bad_magic;

	m = rt_nmg_ialloc( ptrs, ecnt, kind_counts );

	rt_nmg_i2alloc( ecnt, dp, kind_counts, maxindex );

	/* Now import each structure, in turn */
	for (i=1; i < maxindex; i++) {
		/* We know that the DOUBLE_ARRAY is the last thing to process */
		if (ecnt[i].kind == NMG_KIND_DOUBLE_ARRAY) break;
		if (rt_nmg_idisk( (genptr_t)(ptrs[i]), (genptr_t)dp, ecnt,
		    i, ptrs, mat, (unsigned char *)startdata) < 0) {
		    	return -1;
		    }
		dp += rt_nmg_disk_sizes[ecnt[i].kind];
	}

	/* Face min_pt and max_pt are not stored, so this is mandatory. */
	nmg_rebound(m, &tol);

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_NMG;
	ip->idb_meth = &rt_functab[ ID_NMG ];
	ip->idb_ptr = (genptr_t)m;
	NMG_CK_MODEL(m);
	bu_free( (char *)ecnt, "ecnt[]");
	bu_free( (char *)real_ptrs, "ptrs[]");

	if ( RT_G_DEBUG || rt_g.NMG_debug ) {
		nmg_vmodel(m);
	}
	return 0;		/* OK */
}

/*
 *			R T _ N M G _ E X P O R T
 *
 *  The name is added by the caller, in the usual place.
 *
 */
int
rt_nmg_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct model			*m;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_NMG )  return(-1);
	m = (struct model *)ip->idb_ptr;
	NMG_CK_MODEL(m);

	/* To ensure that a decent database is written, verify source first */
	nmg_vmodel(m);

	/* The "compact" flag is used to save space in the database */
	return  rt_nmg_export_internal( ep, ip, local2mm, 1 );
}

/*
 *			R T _ N M G _ E X P O R T 5
 */
int
rt_nmg_export5(
	       struct bu_external		*ep,
	       const struct rt_db_internal	*ip,
	       double				local2mm,
	       const struct db_i		*dbip)
{
	struct model			*m;
	char				*dp;
	long				**ptrs;
	struct nmg_struct_counts	cntbuf;
	struct nmg_exp_counts		*ecnt;
	int				kind_counts[NMG_N_KINDS];
	genptr_t			disk_arrays[NMG_N_KINDS];
	int				tot_size;
	int				kind;
	int				double_count;
	register int			i;
	int				subscript, fastf_byte_count;

	RT_CK_DB_INTERNAL(ip);
	if (ip->idb_type != ID_NMG) return -1;
	m = (struct model *)ip->idb_ptr;
	NMG_CK_MODEL(m);

	bzero((char *)&cntbuf, sizeof(cntbuf));
	ptrs = nmg_m_struct_count( &cntbuf, m);

	ecnt = (struct nmg_exp_counts *)bu_calloc( m->maxindex+1,
		sizeof(struct nmg_exp_counts), "ecnt[]");
	for (i=0; i<NMG_N_KINDS; i++) {
		kind_counts[i] = 0;
	}
	subscript = 1; 
	double_count = 0;
	fastf_byte_count = 0;
	for (i=0; i< m->maxindex; i++) {
		if (ptrs[i] == (long *)0 ) {
			ecnt[i].kind = -1;
			continue;
		}

		kind = rt_nmg_magic_to_kind( *(ptrs[i]) );
		ecnt[i].per_struct_index = kind_counts[kind]++;
		ecnt[i].kind = kind;

		/* 
		 * SNURB and CNURBS are variable sized and as such need
		 * special handling
		 */
		if (kind == NMG_KIND_FACE_G_SNURB) {
			struct face_g_snurb *fg;
			int ndouble;
			fg = (struct face_g_snurb *)ptrs[i];
			ecnt[i].first_fastf_relpos = kind_counts[NMG_KIND_DOUBLE_ARRAY];
			kind_counts[NMG_KIND_DOUBLE_ARRAY] += 3;
			ndouble = fg->u.k_size +
				  fg->v.k_size +
				  fg->s_size[0] * fg->s_size[1] *
				  RT_NURB_EXTRACT_COORDS(fg->pt_type);
			double_count += ndouble;
			ecnt[i].byte_offset = fastf_byte_count;
			fastf_byte_count += 3*(4*4) + 89*ndouble;
		} else if (kind == NMG_KIND_EDGE_G_CNURB) {
			struct edge_g_cnurb	*eg;
			int			ndouble;
			eg = (struct edge_g_cnurb *)ptrs[i];
			ecnt[i].first_fastf_relpos =
			    kind_counts[NMG_KIND_DOUBLE_ARRAY];
			if (eg->order == 0) break;
			kind_counts[NMG_KIND_DOUBLE_ARRAY] += 2;
			ndouble = eg->k.k_size +eg->c_size *
			    RT_NURB_EXTRACT_COORDS(eg->pt_type);
			double_count += ndouble;
			ecnt[i].byte_offset = fastf_byte_count;
			fastf_byte_count += 2*(4+4) +  8*ndouble;
		}
	}
#if 1	/* Compacting wanted */
	kind_counts[NMG_KIND_NMGREGION_A] = 0;
	kind_counts[NMG_KIND_SHELL_A] = 0;
	kind_counts[NMG_KIND_LOOP_G] = 0;
#endif
	/* Assign new subscripts to ascending struts of the same kind */
	for (kind=0; kind < NMG_N_KINDS; kind++) {
#if 1		/* Compacting */
		if ( kind == NMG_KIND_NMGREGION_A ||
		     kind == NMG_KIND_SHELL_A ||
		     kind == NMG_KIND_LOOP_G ) {
		     	for (i=0; i<m->maxindex; i++) {
		     		if (ptrs[i] == (long *)0) continue;
		     		if (ecnt[i].kind != kind) continue;
		     		ecnt[i].new_subscript = DISK_INDEX_NULL;
		     	}
		     	continue;
		}
#endif
		for (i=0; i< m->maxindex;i++) {
			if (ptrs[i] == (long *)0) continue;
			if (ecnt[i].kind != kind) continue;
			ecnt[i].new_subscript = subscript++;
		}
	}
	/* Tack on the variable sized fastf_t arrays at the end */
	rt_nmg_cur_fastf_subscript = subscript;
	subscript += kind_counts[NMG_KIND_DOUBLE_ARRAY];

	/* Now do some checking to make sure the world is not totally mad */
	for (i=0; i<m->maxindex; i++) {
		if (ptrs[i] == (long *)0) continue;

		if (nmg_index_of_struct(ptrs[i]) != i) {
			bu_log("***ERROR, ptrs[%d]->index = %d\n",
				i, nmg_index_of_struct(ptrs[i]));
		}
		if (rt_nmg_magic_to_kind(*ptrs[i]) != ecnt[i].kind ) {
			bu_log("***ERROR, ptrs[%d] kind(%d) != %d\n",
			    i, rt_nmg_magic_to_kind(*ptrs[i]),
			    ecnt[i].kind);
		}

	}

	tot_size = 0;
	for (i=0; i< NMG_N_KINDS; i++) {
		if (kind_counts[i] <= 0) {
			disk_arrays[i] = GENPTR_NULL;
			continue;
		}
		tot_size += kind_counts[i] * rt_nmg_disk_sizes[i];
	}

	/* Account for variable sized double arrays, at the end */
	tot_size += kind_counts[NMG_KIND_DOUBLE_ARRAY] * (4+4) + 
	    double_count*8;

	ecnt[0].byte_offset = subscript; /* implicit arg to rt_nmg_reindex() */
	tot_size += SIZEOF_NETWORK_LONG*(NMG_N_KINDS + 1); /* one for magic */
	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = tot_size;
	ep->ext_buf = (genptr_t)bu_calloc(1, ep->ext_nbytes, "nmg external5");
	dp = ep->ext_buf;
	(void)bu_plong((unsigned char *)dp, DISK_MODEL_VERSION);
	dp+=SIZEOF_NETWORK_LONG;

	for (kind=0; kind <NMG_N_KINDS; kind++) {
		(void)bu_plong((unsigned char *) dp, kind_counts[kind]);
		dp+=SIZEOF_NETWORK_LONG;
	}
	for (i=0; i< NMG_N_KINDS; i++) {
		disk_arrays[i] = (genptr_t)dp;
		dp += kind_counts[i] * rt_nmg_disk_sizes[i];
	}
	rt_nmg_fastf_p = (unsigned char*)disk_arrays[NMG_KIND_DOUBLE_ARRAY];

	for (i = m->maxindex-1;i >=0; i--) {
		if (ptrs[i] == (long *)0) continue;
		kind = ecnt[i].kind;
		if (kind_counts[kind] <= 0) continue;
		rt_nmg_edisk((genptr_t)(disk_arrays[kind]),
			(genptr_t)(ptrs[i]), ecnt, i, local2mm);
	}

	bu_free((char *)ptrs, "ptrs[]");
	bu_free((char *)ecnt, "ecnt[]");
	return 0;		/* OK */
}

/*
 *			R T _ N M G _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_nmg_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct model	*m =
		(struct model *)ip->idb_ptr;

	NMG_CK_MODEL(m);
	bu_vls_printf( str, "n-Manifold Geometry solid (NMG) maxindex=%d\n",
		m->maxindex);

	if( !verbose )  return(0);

#if 0
	{
	struct nmg_struct_counts	count;
	long			**ptrs;
	/* This really is not useful for the MGED overlay! */
	ptrs = nmg_m_struct_count( &count, m );

	/* If verbose, should print out structure counts */
	nmg_vls_struct_counts( str, &count );

	bu_free( (char *)ptrs, "struct_count *ptrs[]" );
	}
#endif

	return(0);
}

/*
 *			R T _ N M G _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_nmg_ifree(struct rt_db_internal *ip)
{
	register struct model	*m;

	RT_CK_DB_INTERNAL(ip);
	if (ip->idb_ptr) {
		m = (struct model *)ip->idb_ptr;
		NMG_CK_MODEL(m);
		nmg_km( m );
	}

	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

int
rt_nmg_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
	register struct model *m=(struct model *)intern->idb_ptr;
	Tcl_DString		ds;
	struct bu_vls		vls;
	struct bu_ptbl		verts;
	struct nmgregion	*r;
	struct shell		*s;
	struct faceuse		*fu;
	struct loopuse		*lu;
	struct edgeuse		*eu;
	struct vertexuse	*vu;
	struct vertex		*v;
	struct vertex_g		*vg;
	int			i;

	NMG_CK_MODEL( m );

	Tcl_DStringInit( &ds );
	bu_vls_init( &vls );

	if( attr == (char *)NULL )
	{
		bu_vls_strcpy( &vls, "nmg" );
		bu_ptbl_init( &verts, 256, "nmg verts" );
		nmg_vertex_tabulate( &verts, &m->magic );

		/* first list all the vertices */
		bu_vls_strcat( &vls, " V {" );
		for( i=0 ; i<BU_PTBL_LEN( &verts ) ; i++ ) {
			v = (struct vertex *) BU_PTBL_GET( &verts, i );
			NMG_CK_VERTEX( v );
			vg = v->vg_p;
			if( !vg ) {
				Tcl_SetResult( interp, "Vertex has no geometry\n", TCL_STATIC );
				bu_ptbl_free( &verts );
				bu_vls_free( &vls );
				return( TCL_ERROR );
			}
			bu_vls_printf( &vls, " { %.25g %.25g %.25g }", V3ARGS( vg->coord ) );
		}
		bu_vls_strcat( &vls, " }" );

		/* use the backwards macros here so that "asc2g" will build the same structures */
		/* now all the nmgregions */
		for( BU_LIST_FOR_BACKWARDS( r, nmgregion, &m->r_hd ) ) {
			/* bu_vls_strcat( &vls, " R {" ); */

			/* and all the shells */
			for( BU_LIST_FOR_BACKWARDS( s, shell, &r->s_hd ) ) {
				/* bu_vls_strcat( &vls, " S {" ); */

				/* all the faces */
				if( BU_LIST_NON_EMPTY( &s->fu_hd ) ) {
					for( BU_LIST_FOR_BACKWARDS( fu, faceuse, &s->fu_hd ) ) {
						if( fu->orientation != OT_SAME )
							continue;

						bu_vls_strcat( &vls, " F {" );

						/* all the loops in this face */
						for( BU_LIST_FOR_BACKWARDS( lu, loopuse, &fu->lu_hd ) ) {

							if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC ) {
								vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
								bu_vls_printf( &vls, " %d",
									bu_ptbl_locate( &verts, (long *)vu->v_p ) );
							} else {
								bu_vls_strcat( &vls, " {" );
								for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) ) {
									vu = eu->vu_p;
									bu_vls_printf( &vls, " %d",
									       bu_ptbl_locate( &verts, (long *)vu->v_p ) );
								}
								/* end of this loop */
								bu_vls_strcat( &vls, " }" );
							}
						}

						/* end of this face */
						bu_vls_strcat( &vls, " }" );
					}
				}
#if 0
				/* all the wire loopuses */
				if( BU_LIST_NON_EMPTY( &s->lu_hd ) ) {
					for( BU_LIST_FOR( lu, loopuse, &s->lu_hd ) ) {
					}
				}

				/* all the wire edges */
				if( BU_LIST_NON_EMPTY( &s->eu_hd ) ) {
					for( BU_LIST_FOR( eu, edgeuse, &s->eu_hd ) ) {
					}
				}

				/* and maybe a single vertexuse */
				if( s->vu_p ) {
					bu_vls_printf( &vls, " VU %d", bu_ptbl_locate( &verts, (long *)s->vu_p->v_p ) );
				}

				/* end if this shell */
				bu_vls_strcat( &vls, " }" );
#endif
			}
			/* end of this nmgregion */
			/* bu_vls_strcat( &vls, " }" ); */
		}
		bu_ptbl_free( &verts );
	} else if( !strcmp( attr, "V" ) ) {
		/* list of vertices */

		bu_ptbl_init( &verts, 256, "nmg verts" );
		nmg_vertex_tabulate( &verts, &m->magic );
		for( i=0 ; i<BU_PTBL_LEN( &verts ) ; i++ ) {
			v = (struct vertex *) BU_PTBL_GET( &verts, i );
			NMG_CK_VERTEX( v );
			vg = v->vg_p;
			if( !vg ) {
				Tcl_SetResult( interp, "Vertex has no geometry\n", TCL_STATIC );
				bu_ptbl_free( &verts );
				bu_vls_free( &vls );
				return( TCL_ERROR );
			}
			bu_vls_printf( &vls, " { %.25g %.25g %.25g }", V3ARGS( vg->coord ) );
		}
		bu_ptbl_free( &verts );
	} else {
		Tcl_SetResult( interp, "Unrecognized parameter\n", TCL_STATIC );
		return( TCL_ERROR );
	}

	Tcl_DStringAppend( &ds, bu_vls_addr( &vls ), -1 );
	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );
	bu_vls_free( &vls );

	return( TCL_OK );
}

int
rt_nmg_tcladjust( Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv, struct resource *resp)
{
	struct model	*m;
	struct nmgregion	*r=NULL;
	struct shell	*s=NULL;
	struct faceuse *fu=NULL;
	Tcl_Obj		*obj, **obj_array;
	int		len;
	int		num_verts, num_loops;
	int		*loop;
	int		loop_len;
	int		i, j;
	struct tmp_v	*verts;
	fastf_t         *tmp;
	struct bn_tol   tol;

	RT_CK_DB_INTERNAL( intern );
	m = (struct model *)intern->idb_ptr;
	NMG_CK_MODEL( m );

	verts = (struct tmp_v *)NULL;
	for( i=0 ; i<argc ; i += 2 ) {
		if( !strcmp( argv[i], "V" ) ) { 
			obj = Tcl_NewStringObj( argv[i+1], -1 );
			if( Tcl_ListObjGetElements( interp, obj, &num_verts,
						    &obj_array) != TCL_OK) {
				Tcl_SetResult( interp,
				     "ERROR: failed to parse vertex list\n",
				      TCL_STATIC );
				Tcl_DecrRefCount( obj );
				return( TCL_ERROR );
			}
			verts = (struct tmp_v *)bu_calloc( num_verts,
							   sizeof( struct tmp_v ),
							   "verts" );
			for( j=0 ; j<num_verts ; j++ ) {
				len = 3;
				tmp = &verts[j].pt[0];
				if( tcl_obj_to_fastf_array( interp, obj_array[j],
					  &tmp, &len ) != 3 ) {
					Tcl_SetResult( interp,
					    "ERROR: incorrect number of coordinates for vertex\n",
					     TCL_STATIC );
					return( TCL_ERROR );
				}
			}
			
		}
	}

	while( argc >= 2 ) {
		struct vertex ***face_verts;
		struct faceuse *fu;

		if( !strcmp( argv[0], "V" ) ) {
			/* vertex list handled above */
			goto cont;
		} else if( !strcmp( argv[0], "F" ) ) {
			if( !verts ) {
				Tcl_SetResult( interp,
				    "ERROR: cannot set faces without vertices\n",
				    TCL_STATIC );
				return( TCL_ERROR );
			}
			if( BU_LIST_IS_EMPTY( &m->r_hd ) ) {
			  r = nmg_mrsv( m );
			  s = BU_LIST_FIRST( shell, &r->s_hd );
			} else {
			  r = BU_LIST_FIRST( nmgregion, &m->r_hd );
			  s = BU_LIST_FIRST( shell, &r->s_hd );
			}
			obj = Tcl_NewStringObj( argv[1], -1 );
			if( Tcl_ListObjGetElements( interp, obj, &num_loops,
						    &obj_array) != TCL_OK) {
				Tcl_SetResult( interp,
				     "ERROR: failed to parse face list\n",
				      TCL_STATIC );
				Tcl_DecrRefCount( obj );
				return( TCL_ERROR );
			}
			for( i=0, fu=NULL ; i<num_loops ; i++ ) {
				struct vertex **loop_verts;
				/* struct faceuse fu is initialized in earlier scope */

				loop_len = 0;
				(void)tcl_obj_to_int_array( interp, obj_array[i],
							    &loop, &loop_len);
				if( !loop_len ) {
					Tcl_SetResult( interp,
					     "ERROR: unable to parse face list\n",
					     TCL_STATIC );
					return( TCL_ERROR );
				}
				if( i ) {
					loop_verts = (struct vertex **)bu_calloc(
						      loop_len,
						      sizeof( struct vertex * ),
						      "loop_verts" );
					for( i=0 ; i<loop_len ; i++ ) {
						loop_verts[i] = verts[loop[i]].v;
					}
					fu = nmg_add_loop_to_face( s, fu,
						   loop_verts, loop_len,
						   OT_OPPOSITE );
					for( i=0 ; i<loop_len ; i++ ) {
						verts[loop[i]].v = loop_verts[i];
					}
				} else {
					face_verts = (struct vertex ***)bu_calloc(
						 loop_len,
						 sizeof( struct vertex **),
						 "face_verts" );
					for( j=0 ; j<loop_len ; j++ ) {
						face_verts[j] = &verts[loop[j]].v;
					}
					fu = nmg_cmface( s, face_verts, loop_len );
					bu_free((char *)face_verts, "face_verts" );
				}
			}
		} else {
			Tcl_SetResult( interp,
			      "ERROR: Unrecognized parameter, must be V or F\n",
			      TCL_STATIC );
			return( TCL_ERROR );
		}
	cont:
		argc -= 2;
		argv += 2;
	}

	/* assign geometry for entire vertex list (if we have one) */
	for( i=0 ; i<num_verts ; i++ ) {
		if( verts[i].v )
			nmg_vertex_gv( verts[i].v, verts[i].pt );
	}

	/* assign face geometry */
	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) ) {
		if( fu->orientation != OT_SAME )
			continue;
		nmg_calc_face_g( fu );
	}

	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	nmg_rebound( m, &tol );

	return( TCL_OK );
}


void
rt_nmg_make( const struct rt_functab *ftp, struct rt_db_internal *intern, double d )
{
	struct model *m;

	m = nmg_mm();
	intern->idb_ptr = (genptr_t )m;
	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_NMG;
	intern->idb_meth = ftp;
}
@


11.42
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /cvs/brlcad/librt/g_nmg.c,v 11.41 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.41
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.40
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.39 2002/08/20 17:08:00 jra Exp $ (BRL)";
d79 1
a79 4
rt_nmg_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d131 1
a131 2
rt_nmg_print( stp )
register const struct soltab *stp;
d154 5
a158 5
rt_nmg_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;	/* info about the ray */
struct application	*ap;	
struct seg		*seghead;	/* intersection w/ ray */
d243 6
a248 6
rt_nmg_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d259 1
a259 4
rt_nmg_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d270 1
a270 4
rt_nmg_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d290 1
a290 5
rt_nmg_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d300 1
a300 2
rt_nmg_free( stp )
register struct soltab *stp;
d313 1
a313 1
rt_nmg_class()
d323 1
a323 5
rt_nmg_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d349 1
a349 6
rt_nmg_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d715 1
a715 2
rt_nmg_magic_to_kind( magic )
register long	magic;
d811 5
a815 5
rt_nmg_export_fastf( fp, count, pt_type, scale )
const fastf_t	*fp;
int		count;
int		pt_type;	/* If zero, means literal array of values */
double		scale;
d858 7
a864 7
rt_nmg_import_fastf( base, ecnt, subscript, mat, len, pt_type )
const unsigned char	*base;
struct nmg_exp_counts	*ecnt;
long			subscript;
const matp_t		mat;
int			len;		/* expected size */
int			pt_type;
d941 1
a941 3
rt_nmg_reindex(p, ecnt)
genptr_t		p;
struct nmg_exp_counts	*ecnt;
d994 6
a999 6
rt_nmg_edisk( op, ip, ecnt, index, local2mm )
genptr_t	op;		/* base of disk array */
genptr_t	ip;		/* ptr to in-memory structure */
struct nmg_exp_counts	*ecnt;
int		index;
double		local2mm;
d1381 8
a1388 8
rt_nmg_idisk( op, ip, ecnt, index, ptrs, mat, basep )
genptr_t	op;		/* ptr to in-memory structure */
genptr_t	ip;		/* base of disk array */
struct nmg_exp_counts	*ecnt;
int		index;
long		**ptrs;
const mat_t	mat;
const unsigned char	*basep;	/* base of whole import record */
d1776 1
a1776 4
rt_nmg_ialloc( ptrs, ecnt, kind_counts )
long				**ptrs;
struct nmg_exp_counts		*ecnt;
int				kind_counts[NMG_N_KINDS];
d2003 1
a2003 5
rt_nmg_i2alloc( ecnt, cp, kind_counts, maxindex )
struct nmg_exp_counts	*ecnt;
unsigned char		*cp;
int			kind_counts[NMG_N_KINDS];
int			maxindex;
d2052 1
a2052 6
rt_nmg_import_internal( ip, ep, mat, rebound, tol )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
int				rebound;
const struct bn_tol		*tol;
d2193 1
a2193 5
rt_nmg_export_internal( ep, ip, local2mm, compact )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
int				compact;
d2391 1
a2391 5
rt_nmg_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d2529 1
a2529 5
rt_nmg_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d2724 1
a2724 5
rt_nmg_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d2758 1
a2758 2
rt_nmg_ifree( ip )
struct rt_db_internal	*ip;
d2773 1
a2773 4
rt_nmg_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
@


11.39
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990 by the United States Army.
d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.37 2002/05/09 19:24:46 jra Exp $ (BRL)";
@


11.39.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_nmg.c,v 11.40 2004/02/02 17:39:20 morrison Exp $ (BRL)";
@


11.39.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.40 2004/02/02 17:39:20 morrison Exp $ (BRL)";
@


11.39.10.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.39.10.1 2004/02/12 18:37:41 erikg Exp $ (BRL)";
@


11.39.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.39 2002/08/20 17:08:00 jra Exp $ (BRL)";
d79 4
a82 1
rt_nmg_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d134 2
a135 1
rt_nmg_print(register const struct soltab *stp)
d158 5
a162 5
rt_nmg_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
             		     
                    	    	/* info about the ray */
                  	    	
          		         	/* intersection w/ ray */
d247 6
a252 6
rt_nmg_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d263 4
a266 1
rt_nmg_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d277 4
a280 1
rt_nmg_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d300 5
a304 1
rt_nmg_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d314 2
a315 1
rt_nmg_free(register struct soltab *stp)
d328 1
a328 1
rt_nmg_class(void)
d338 5
a342 1
rt_nmg_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d368 6
a373 1
rt_nmg_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d739 2
a740 1
rt_nmg_magic_to_kind(register long int magic)
d836 5
a840 5
rt_nmg_export_fastf(const fastf_t *fp, int count, int pt_type, double scale)
             	    
   		      
   		        	/* If zero, means literal array of values */
      		      
d883 7
a889 7
rt_nmg_import_fastf(const unsigned char *base, struct nmg_exp_counts *ecnt, long int subscript, const matp_t mat, int len, int pt_type)
                   	      
                     	      
    			          
            		    
   			    		/* expected size */
   			        
d966 3
a968 1
rt_nmg_reindex(genptr_t p, struct nmg_exp_counts *ecnt)
d1021 6
a1026 6
rt_nmg_edisk(genptr_t op, genptr_t ip, struct nmg_exp_counts *ecnt, int index, double local2mm)
        	   		/* base of disk array */
        	   		/* ptr to in-memory structure */
                     	      
   		      
      		         
d1408 8
a1415 8
rt_nmg_idisk(genptr_t op, genptr_t ip, struct nmg_exp_counts *ecnt, int index, long int **ptrs, const fastf_t *mat, const unsigned char *basep)
        	   		/* ptr to in-memory structure */
        	   		/* base of disk array */
                     	      
   		      
    		       
           	    
                   	       	/* base of whole import record */
d1803 4
a1806 1
rt_nmg_ialloc(long int **ptrs, struct nmg_exp_counts *ecnt, int *kind_counts)
d2033 5
a2037 1
rt_nmg_i2alloc(struct nmg_exp_counts *ecnt, unsigned char *cp, int *kind_counts, int maxindex)
d2086 6
a2091 1
rt_nmg_import_internal(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, int rebound, const struct bn_tol *tol)
d2232 5
a2236 1
rt_nmg_export_internal(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, int compact)
d2434 5
a2438 1
rt_nmg_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d2576 5
a2580 1
rt_nmg_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d2775 5
a2779 1
rt_nmg_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d2813 2
a2814 1
rt_nmg_ifree(struct rt_db_internal *ip)
d2829 4
a2832 1
rt_nmg_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
@


11.39.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header$ (BRL)";
@


11.38
log
@Converted from K&R to ANSI C - RFH
@
text
@d79 4
a82 1
rt_nmg_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d134 2
a135 1
rt_nmg_print(register const struct soltab *stp)
d158 5
a162 5
rt_nmg_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
             		     
                    	    	/* info about the ray */
                  	    	
          		         	/* intersection w/ ray */
d247 6
a252 6
rt_nmg_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d263 4
a266 1
rt_nmg_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d277 4
a280 1
rt_nmg_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d300 5
a304 1
rt_nmg_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d314 2
a315 1
rt_nmg_free(register struct soltab *stp)
d328 1
a328 1
rt_nmg_class(void)
d338 5
a342 1
rt_nmg_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d368 6
a373 1
rt_nmg_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d739 2
a740 1
rt_nmg_magic_to_kind(register long int magic)
d836 5
a840 5
rt_nmg_export_fastf(const fastf_t *fp, int count, int pt_type, double scale)
             	    
   		      
   		        	/* If zero, means literal array of values */
      		      
d883 7
a889 7
rt_nmg_import_fastf(const unsigned char *base, struct nmg_exp_counts *ecnt, long int subscript, const matp_t mat, int len, int pt_type)
                   	      
                     	      
    			          
            		    
   			    		/* expected size */
   			        
d966 3
a968 1
rt_nmg_reindex(genptr_t p, struct nmg_exp_counts *ecnt)
d1021 6
a1026 6
rt_nmg_edisk(genptr_t op, genptr_t ip, struct nmg_exp_counts *ecnt, int index, double local2mm)
        	   		/* base of disk array */
        	   		/* ptr to in-memory structure */
                     	      
   		      
      		         
d1408 8
a1415 8
rt_nmg_idisk(genptr_t op, genptr_t ip, struct nmg_exp_counts *ecnt, int index, long int **ptrs, const fastf_t *mat, const unsigned char *basep)
        	   		/* ptr to in-memory structure */
        	   		/* base of disk array */
                     	      
   		      
    		       
           	    
                   	       	/* base of whole import record */
d1803 4
a1806 1
rt_nmg_ialloc(long int **ptrs, struct nmg_exp_counts *ecnt, int *kind_counts)
d2033 5
a2037 1
rt_nmg_i2alloc(struct nmg_exp_counts *ecnt, unsigned char *cp, int *kind_counts, int maxindex)
d2086 6
a2091 1
rt_nmg_import_internal(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, int rebound, const struct bn_tol *tol)
d2232 5
a2236 1
rt_nmg_export_internal(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, int compact)
d2434 5
a2438 1
rt_nmg_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d2576 5
a2580 1
rt_nmg_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d2775 5
a2779 1
rt_nmg_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d2813 2
a2814 1
rt_nmg_ifree(struct rt_db_internal *ip)
d2829 4
a2832 1
rt_nmg_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
@


11.37
log
@Changed many BU_LIST_FOR macros to BU_LIST_FOR_BACKWARDS so that "asc2g" would create
the same structures and "g_diff" would be happy
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.36 2001/10/02 19:24:29 jra Exp $ (BRL)";
d79 1
a79 4
rt_nmg_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d131 1
a131 2
rt_nmg_print( stp )
register const struct soltab *stp;
d154 5
a158 5
rt_nmg_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;	/* info about the ray */
struct application	*ap;	
struct seg		*seghead;	/* intersection w/ ray */
d243 6
a248 6
rt_nmg_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d259 1
a259 4
rt_nmg_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d270 1
a270 4
rt_nmg_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d290 1
a290 5
rt_nmg_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d300 1
a300 2
rt_nmg_free( stp )
register struct soltab *stp;
d313 1
a313 1
rt_nmg_class()
d323 1
a323 5
rt_nmg_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d349 1
a349 6
rt_nmg_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d715 1
a715 2
rt_nmg_magic_to_kind( magic )
register long	magic;
d811 5
a815 5
rt_nmg_export_fastf( fp, count, pt_type, scale )
const fastf_t	*fp;
int		count;
int		pt_type;	/* If zero, means literal array of values */
double		scale;
d858 7
a864 7
rt_nmg_import_fastf( base, ecnt, subscript, mat, len, pt_type )
const unsigned char	*base;
struct nmg_exp_counts	*ecnt;
long			subscript;
const matp_t		mat;
int			len;		/* expected size */
int			pt_type;
d941 1
a941 3
rt_nmg_reindex(p, ecnt)
genptr_t		p;
struct nmg_exp_counts	*ecnt;
d994 6
a999 6
rt_nmg_edisk( op, ip, ecnt, index, local2mm )
genptr_t	op;		/* base of disk array */
genptr_t	ip;		/* ptr to in-memory structure */
struct nmg_exp_counts	*ecnt;
int		index;
double		local2mm;
d1381 8
a1388 8
rt_nmg_idisk( op, ip, ecnt, index, ptrs, mat, basep )
genptr_t	op;		/* ptr to in-memory structure */
genptr_t	ip;		/* base of disk array */
struct nmg_exp_counts	*ecnt;
int		index;
long		**ptrs;
const mat_t	mat;
const unsigned char	*basep;	/* base of whole import record */
d1776 1
a1776 4
rt_nmg_ialloc( ptrs, ecnt, kind_counts )
long				**ptrs;
struct nmg_exp_counts		*ecnt;
int				kind_counts[NMG_N_KINDS];
d2003 1
a2003 5
rt_nmg_i2alloc( ecnt, cp, kind_counts, maxindex )
struct nmg_exp_counts	*ecnt;
unsigned char		*cp;
int			kind_counts[NMG_N_KINDS];
int			maxindex;
d2052 1
a2052 6
rt_nmg_import_internal( ip, ep, mat, rebound, tol )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
int				rebound;
const struct bn_tol		*tol;
d2193 1
a2193 5
rt_nmg_export_internal( ep, ip, local2mm, compact )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
int				compact;
d2391 1
a2391 5
rt_nmg_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d2529 1
a2529 5
rt_nmg_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d2724 1
a2724 5
rt_nmg_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d2758 1
a2758 2
rt_nmg_ifree( ip )
struct rt_db_internal	*ip;
d2773 1
a2773 4
rt_nmg_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
@


11.36
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.35 2001/10/02 17:54:11 jra Exp $ (BRL)";
d2875 1
d2877 1
a2877 1
		for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) ) {
d2881 1
a2881 1
			for( BU_LIST_FOR( s, shell, &r->s_hd ) ) {
d2886 1
a2886 1
					for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) ) {
d2893 1
a2893 1
						for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) ) {
@


11.35
log
@rt_xxx_make() routines were not setting idb_major_type
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.34 2001/07/18 19:30:43 morrison Exp $ (BRL)";
d2180 1
d2555 1
@


11.34
log
@Quelled compile warnings for m4i65
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.33 2001/07/17 13:19:22 jra Exp $ (BRL)";
d3132 1
@


11.33
log
@Added tclget and tcladjust for NMGs
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.32 2001/05/17 20:05:24 morrison Exp $ (BRL)";
d3022 1
d3050 1
a3050 2
			for( i=0 ; i<num_loops ; i++ ) {
				struct faceuse *fu;
d3052 1
@


11.32
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.31 2001/04/20 22:29:45 morrison Exp $ (BRL)";
d27 4
d32 2
d57 5
a126 4




d2824 309
@


11.31
log
@CONST to const
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.30 2001/04/05 13:06:56 jra Exp $ (BRL)";
d2461 1
a2461 1
	if( rt_g.debug || rt_g.NMG_debug )
d2554 1
a2554 1
	if ( rt_g.debug || rt_g.NMG_debug ) {
@


11.30
log
@Eliminated some excess debug prints
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.29 2001/03/21 21:01:42 jra Exp $ (BRL)";
d128 1
a128 1
register CONST struct soltab *stp;
d334 2
a335 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d365 2
a366 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d666 1
a666 1
CONST int	rt_nmg_disk_sizes[NMG_N_KINDS] = {
d694 1
a694 1
CONST char	rt_nmg_kind_names[NMG_N_KINDS+2][18] = {
d830 1
a830 1
CONST fastf_t	*fp;
d877 1
a877 1
CONST unsigned char	*base;
d880 1
a880 1
CONST matp_t		mat;
d884 1
a884 1
	CONST unsigned char	*cp;
d1407 2
a1408 2
CONST mat_t	mat;
CONST unsigned char	*basep;	/* base of whole import record */
d2081 2
a2082 2
CONST struct bu_external	*ep;
register CONST mat_t		mat;
d2084 1
a2084 1
CONST struct bn_tol		*tol;
d2226 1
a2226 1
CONST struct rt_db_internal	*ip;
d2428 3
a2430 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d2569 1
a2569 1
CONST struct rt_db_internal	*ip;
d2571 1
a2571 1
CONST struct db_i		*dbip;
d2768 1
a2768 1
CONST struct rt_db_internal	*ip;
@


11.29
log
@Eliminated excess logging
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /d/CVS/brlcad/librt/g_nmg.c,v 11.28 2000/08/21 02:02:30 butler Exp $ (BRL)";
a2381 1
bu_log("total of disk NMG(v4)=%d\n", tot_size);
a2399 2
bu_log("V4: kind=%d, count=%d, disk_size = %d, total_size=%d\n",
    i, kind_counts[i], cp-(char *)disk_arrays[i], cp-(char *)disk_arrays[0]);
@


11.28
log
@Massive compilation warnings eliminated
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.27 2000/08/10 05:24:37 mike Exp $ (BRL)";
a2730 1
bu_log("total of disk NMG(v5)=%d\n", tot_size);
a2744 2
bu_log("V5: kind=%d, count=%d, disk_size = %d, total_size=%d\n",
    i, kind_counts[i], dp-(char *)disk_arrays[i], dp-(char *)disk_arrays[0]);
@


11.27
log
@
Added important comment.
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.26 2000/08/10 03:53:20 mike Exp $ (BRL)";
d27 1
@


11.26
log
@
Fixed minor bug.  Bumping by sizeof double rather than sizeof long.
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.25 2000/07/10 23:01:32 mike Exp $ (BRL)";
d2545 1
a2545 1
	/* Always? */
@


11.25
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d20 1
a20 1
static const char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.24 2000/07/06 22:19:36 mike Exp $ (BRL)";
d2513 1
a2513 1
		dp+= SIZEOF_NETWORK_DOUBLE;
@


11.24
log
@
Fixed lint
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.23 2000/06/30 21:37:49 cjohnson Exp $ (BRL)";
@


11.23
log
@Correct some typos and brain farts.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.22 2000/06/30 15:59:36 mike Exp $ (BRL)";
d2401 1
a2401 1
    i, kind_counts[i], (genptr_t)cp-disk_arrays[i], (genptr_t)cp-disk_arrays[0]);
d2735 1
a2735 1
	(void)bu_plong((char *)dp, DISK_MODEL_VERSION);
d2739 1
a2739 1
		(void)bu_plong((char *) dp, kind_counts[kind]);
d2746 1
a2746 1
    i, kind_counts[i], (genptr_t)dp-disk_arrays[i], (genptr_t)dp-disk_arrays[0]);
@


11.22
log
@
Modified to compile on IRIX64
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.21 2000/06/30 15:38:03 mike Exp $ (BRL)";
d2381 1
d2400 2
d2600 1
a2600 1
	genptr_t			*dp, *startdata;
d2670 1
a2670 1
#if 0	/* Compacting wanted */
d2677 1
a2677 1
#if 0		/* Compacting */
d2680 2
a2681 2
		     kind == NMG_KIND_LOOP_G )) {
		     	for (i=0; i<m->maxinde; i++) {
d2689 1
a2689 1
		for (i=0; m->maxindex;i++) {
d2728 3
a2730 2
	ecnt[i].byte_offset = subscript; /* implicit arg to rt_nmg_reindex() */

d2745 2
@


11.21
log
@
export methods should not init the external structure, just check them.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.20 2000/06/30 15:31:15 mike Exp $ (BRL)";
d2480 2
a2481 1
	genptr_t		dp, startdata;	/* data pointer */
@


11.20
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.19 2000/06/29 20:45:16 cjohnson Exp $ (BRL)";
d2382 1
a2382 1
	BU_INIT_EXTERNAL(ep);
d2726 1
a2726 1
	BU_INIT_EXTERNAL(ep);
@


11.19
log
@Untested but compiling/linking version with db5 export.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.18 2000/06/28 22:33:34 cjohnson Exp $ (BRL)";
d2171 1
a2171 1
	RT_INIT_DB_INTERNAL( ip );
d2544 1
a2544 1
	RT_INIT_DB_INTERNAL( ip );
@


11.18
log
@import5 is done, but untested. (It compiles, ship it)
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.17 2000/04/12 02:34:34 mike Exp $ (BRL)";
d2285 1
a2285 1
					   RT_NURB_EXTRACT_COORDS(fg->pt_type);
d2583 171
@


11.17
log
@
NT port, non-compat4
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.16 1999/11/26 21:46:47 mike Exp $ (BRL)";
d2464 92
@


11.16
log
@
Lint cleanups
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.15 1999/11/24 21:44:29 mike Exp $ (BRL)";
d280 1
a280 1
 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.15
log
@
Removed includes of compat header files rtstring.h and rtlist.h
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.14 1999/11/17 02:41:59 mike Exp $ (BRL)";
d2425 1
a2425 1
rt_nmg_import( ip, ep, mat )
d2429 1
d2473 1
a2473 1
rt_nmg_export( ep, ip, local2mm )
d2477 1
d2503 1
a2503 1
struct rt_db_internal	*ip;
@


11.14
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.13 1999/05/27 19:10:39 mike Exp $ (BRL)";
a30 2
#include "rtstring.h"
#include "rtlist.h"
@


11.13
log
@
sed4
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.12 1999/01/13 21:54:03 mike Exp $ (BRL)";
d2175 1
@


11.12
log
@Fixed htond() arg types
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nmg.c,v 11.11 1997/09/09 13:49:08 jra Exp $ (BRL)";
d83 1
a83 1
	GETSTRUCT( nmg_s, nmg_specific );
d97 1
a97 1
	for (RT_LIST_FOR(rp, nmgregion, &m->r_hd )) {
d164 1
a164 1
		rt_log("rt_nmg_shot()\n\t");
d212 1
a212 1
	rd.hitmiss = (struct hitmiss **)rt_calloc( rd.rd_m->maxindex,
d216 2
a217 2
	RT_LIST_INIT(&rd.rd_hit);
	RT_LIST_INIT(&rd.rd_miss);
d227 1
a227 1
	rt_free( (char *)rd.hitmiss, "free nmg geom hit list");
d315 1
a315 1
	rt_free( (char *)nmg, "nmg_specific" );
d333 1
a333 1
struct rt_list		*vhead;
d336 1
a336 1
CONST struct rt_tol	*tol;
d367 1
a367 1
CONST struct rt_tol	*tol;
d377 1
a377 1
	if( RT_LIST_IS_EMPTY( &(lm->r_hd) ) )  {
d385 1
a385 1
	*r = RT_LIST_FIRST(nmgregion, &(lm->r_hd) );
d387 1
a387 1
	if( RT_LIST_NEXT_NOT_HEAD( *r, &(lm->r_hd) ) )  {
d390 2
a391 2
		r2 = RT_LIST_PNEXT( nmgregion, &((*r)->l) );
		while( RT_LIST_NOT_HEAD( &r2->l, &(lm->r_hd) ) )
d395 1
a395 1
			next_r = RT_LIST_PNEXT( nmgregion, &r2->l );
d415 3
a417 3
	if( rt_glong(_cp) != _magic )  { \
		rt_log("RT_CK_DISKMAGIC: magic mis-match, got x%x, s/b x%x, file %s, line %d\n", \
			rt_glong(_cp), _magic, __FILE__, __LINE__); \
d781 1
a781 1
	rt_log("magic = x%x\n", magic);
d842 2
a843 2
	(void)rt_plong( cp + 0, DISK_DOUBLE_ARRAY_MAGIC );
	(void)rt_plong( cp + 4, count );
d850 1
a850 1
		new = (fastf_t *)rt_malloc( count*sizeof(fastf_t), "rt_nmg_export_fastf" );
d866 1
a866 1
		rt_free( (char *)new, "rt_nmg_export_fastf" );
d891 1
a891 1
		rt_log("subscript=%d, byte_offset=%d, kind=%d (expected %d)\n",
d899 4
a902 4
	if( rt_glong( cp ) != DISK_DOUBLE_ARRAY_MAGIC )  {
		rt_log("magic mis-match, got x%x, s/b x%x, file %s, line %d\n",
			rt_glong(cp), DISK_DOUBLE_ARRAY_MAGIC, __FILE__, __LINE__);
		rt_log("subscript=%d, byte_offset=%d\n",
d910 1
a910 1
	count = rt_glong( cp + 4 );
d912 1
a912 1
		rt_log("rt_nmg_import_fastf() subscript=%d, expected len=%d, got=%d\n",
d916 1
a916 1
	ret = (fastf_t *)rt_malloc( count * sizeof(fastf_t), "rt_nmg_import_fastf[]" );
d927 1
a927 1
	tmp = (fastf_t *)rt_malloc( count * sizeof(fastf_t), "rt_nmg_import_fastf tmp[]" );
d945 1
a945 1
	rt_free( (char *)tmp, "rt_nmg_import_fastf tmp[]" );
d980 1
a980 1
				rt_log("rt_nmg_reindex(p=x%x), p->index=%d, ret=%d, kind=%d\n", p, index, ret, ecnt[index].kind);
d985 1
a985 1
				rt_log("rt_nmg_reindex(p=x%x) %s, p->index=%d, ret=%d, maxindex=%d\n",
d987 1
a987 1
					rt_identify_magic(*(long *)p),
d993 1
a993 1
/*rt_log("rt_nmg_reindex(p=x%x), p->index=%d, ret=%d\n", p, index, ret);*/
d999 1
a999 1
	(void)rt_plong(&(o)->elem[0], rt_nmg_reindex((genptr_t)((i)->elem), ecnt))
d1002 4
a1005 4
	if( _f == DISK_INDEX_NULL )  rt_log("Warning rt_nmg_edisk: reindex forw to null?\n"); \
	(void)rt_plong( (oo)->elem.forw, _f ); \
	(void)rt_plong( (oo)->elem.back, rt_nmg_reindex((genptr_t)((ii)->elem.back), ecnt) ); }
#define PUTMAGIC(_magic)	(void)rt_plong( &d->magic[0], _magic )
d1033 1
a1033 1
			rt_plong( d->version, 0 );
d1102 1
a1102 1
			if( fu->f_p != fu->fumate_p->f_p )  rt_log("faceuse export, differing faces\n");
d1107 1
a1107 1
			rt_plong( d->orientation, fu->orientation );
d1121 2
a1122 2
			rt_plong( d->g, rt_nmg_reindex((genptr_t)(f->g.magic_p), ecnt) );
			rt_plong( d->flip, f->flip );
d1148 5
a1152 5
			rt_plong( d->u_order, fg->order[0] );
			rt_plong( d->v_order, fg->order[1] );
			rt_plong( d->u_size, fg->u.k_size );
			rt_plong( d->v_size, fg->v.k_size );
			rt_plong( d->u_knots,
d1155 1
a1155 1
			rt_plong( d->v_knots,
d1158 3
a1160 3
			rt_plong( d->us_size, fg->s_size[0] );
			rt_plong( d->vs_size, fg->s_size[1] );
			rt_plong( d->pt_type, fg->pt_type );
d1162 1
a1162 1
			rt_plong( d->ctl_points,
d1177 1
a1177 1
			rt_plong( d->up, rt_nmg_reindex((genptr_t)(lu->up.magic_p), ecnt) );
d1179 1
a1179 1
			rt_plong( d->orientation, lu->orientation );
d1222 1
a1222 1
			rt_plong( d->up, rt_nmg_reindex((genptr_t)(eu->up.magic_p), ecnt) );
d1226 1
a1226 1
			rt_plong( d->orientation, eu->orientation);
d1228 1
a1228 1
			rt_plong( d->g, rt_nmg_reindex((genptr_t)(eu->g.magic_p), ecnt) );
d1238 1
a1238 1
			rt_plong( d->is_real, e->is_real );
d1264 1
a1264 1
			rt_plong( d->order, eg->order );
d1269 2
a1270 2
			rt_plong( d->k_size, eg->k.k_size );
			rt_plong( d->knots,
d1273 2
a1274 2
			rt_plong( d->c_size, eg->c_size );
			rt_plong( d->pt_type, eg->pt_type );
d1280 1
a1280 1
			rt_plong( d->ctl_points,
d1296 1
a1296 1
			rt_plong( d->up,
d1300 1
a1300 1
			rt_plong( d->a,
d1352 1
a1352 1
	rt_log("rt_nmg_edisk kind=%d unknown\n", ecnt[index].kind);
d1363 1
a1363 1
#define INDEX(o,i,ty,elem)	(i)->elem = (struct ty *)ptrs[rt_glong((o)->elem)]
d1366 1
a1366 1
	if( (sub = rt_glong((oo)->elem.forw)) < 0 ) \
d1368 2
a1369 2
	else	(ii)->elem.forw = (struct rt_list *)ptrs[sub]; \
	if( (sub = rt_glong((oo)->elem.back)) < 0 ) \
d1371 1
a1371 1
	else	(ii)->elem.back = (struct rt_list *)ptrs[sub]; }
d1378 1
a1378 1
	if( (sub = rt_glong((oo)->elem.forw)) < 0 ) { \
d1385 1
a1385 1
	if( (sub = rt_glong((oo)->elem.back)) < 0 ) { \
d1449 1
a1449 1
			rt_rotate_bbox( r->min_pt, r->max_pt, mat, min, max );
d1479 1
a1479 1
			rt_rotate_bbox( sa->min_pt, sa->max_pt, mat, min, max );
d1491 1
a1491 1
			fu->orientation = rt_glong( d->orientation );
d1509 1
a1509 1
			g_index = rt_glong(d->g);
d1511 1
a1511 1
			f->flip = rt_glong( d->flip );
d1528 1
a1528 1
			rt_rotate_plane( fg->N, mat, plane );
d1539 3
a1541 3
			fg->order[0] = rt_glong( d->u_order );
			fg->order[1] = rt_glong( d->v_order );
			fg->u.k_size = rt_glong( d->u_size );
d1543 1
a1543 1
				rt_glong( d->u_knots ), (matp_t)NULL,
d1545 1
a1545 1
			fg->v.k_size = rt_glong( d->v_size );
d1547 1
a1547 1
				rt_glong( d->v_knots ), (matp_t)NULL,
d1549 3
a1551 3
			fg->s_size[0] = rt_glong( d->us_size );
			fg->s_size[1] = rt_glong( d->vs_size );
			fg->pt_type = rt_glong( d->pt_type );
d1554 1
a1554 1
				rt_glong( d->ctl_points ), (matp_t)mat,
d1569 1
a1569 1
			up_index = rt_glong(d->up);
d1572 1
a1572 1
			lu->orientation = rt_glong( d->orientation );
d1579 1
a1579 1
			} else rt_log("bad loopuse up, index=%d, kind=%d\n", up_index, up_kind);
d1581 1
a1581 1
			if( lu->down_hd.forw == RT_LIST_NULL )
d1608 1
a1608 1
			rt_rotate_bbox( lg->min_pt, lg->max_pt, mat, min, max );
d1621 1
a1621 1
			up_index = rt_glong(d->up);
d1626 1
a1626 1
			eu->orientation = rt_glong( d->orientation );
d1633 2
a1634 2
			} else rt_log("bad edgeuse up, index=%d, kind=%d\n", up_index, up_kind);
			eu->g.magic_p = (long *)ptrs[rt_glong(d->g)];
d1661 1
a1661 1
			e->is_real = rt_glong( d->is_real );
d1692 1
a1692 1
			eg->order = rt_glong( d->order );
d1697 1
a1697 1
			eg->k.k_size = rt_glong( d->k_size );
d1699 1
a1699 1
				rt_glong( d->knots ), (matp_t)NULL,
d1701 2
a1702 2
			eg->c_size = rt_glong( d->c_size );
			eg->pt_type = rt_glong( d->pt_type );
d1711 1
a1711 1
					rt_glong( d->ctl_points ), (matp_t)NULL,
d1717 1
a1717 1
					rt_glong( d->ctl_points ), (matp_t)mat,
d1729 1
a1729 1
			vu->up.magic_p = (long *)ptrs[rt_glong(d->up)];
d1731 1
a1731 1
			vu->a.magic_p = (long *)ptrs[rt_glong(d->a)];
d1784 1
a1784 1
	rt_log("rt_nmg_idisk kind=%d unknown\n", ecnt[index].kind);
d1810 1
a1810 1
rt_log("%d  %s\n", kind_counts[kind], rt_nmg_kind_names[kind] );
d1829 1
a1829 1
					RT_LIST_INIT( &r->s_hd );
d1846 3
a1848 3
					RT_LIST_INIT( &s->fu_hd );
					RT_LIST_INIT( &s->lu_hd );
					RT_LIST_INIT( &s->eu_hd );
d1865 1
a1865 1
					RT_LIST_INIT( &fu->lu_hd );
d1882 1
a1882 1
					RT_LIST_INIT( &fg->f_hd );
d1891 1
a1891 1
					RT_LIST_INIT( &fg->f_hd );
d1900 1
a1900 1
					RT_LIST_INIT( &lu->down_hd );
d1942 1
a1942 1
					RT_LIST_INIT( &eg->eu_hd2 );
d1951 1
a1951 1
					RT_LIST_INIT( &eg->eu_hd2 );
d1984 1
a1984 1
					RT_LIST_INIT( &v->vu_hd );
d1997 1
a1997 1
				rt_log("bad kind = %d\n", kind);
d2002 1
a2002 1
rt_log("   disk_index=%d, kind=%s, ptr=x%x, final_index=%d\n",
d2023 1
a2023 1
 *  A separate call to rt_malloc() will be used, so that nmg_keg(), etc.,
d2054 1
a2054 1
rt_log("rt_nmg_i2alloc() first one at cp=x%x, offset=%d, subscript=%d\n", cp, offset, subscript );
d2059 1
a2059 1
		ndouble = rt_glong( cp + offset + 4 );
d2082 1
a2082 1
CONST struct rt_external	*ep;
d2085 1
a2085 1
CONST struct rt_tol		*tol;
d2099 2
a2100 2
	RT_CK_EXTERNAL( ep );
	RT_CK_TOL( tol );
d2104 1
a2104 1
		rt_log("rt_nmg_import: defective record\n");
d2113 1
a2113 1
		rt_log("rt_nmg_import:  expected NMG '.g' format version %d, got version %d, aborting.\n",
d2122 1
a2122 1
		kind_counts[kind] = rt_glong( rp->nmg.N_structs+4*kind );
d2126 1
a2126 1
	rt_log("import maxindex=%d\n", maxindex);
d2130 1
a2130 1
	ecnt = (struct nmg_exp_counts *)rt_calloc( maxindex+3,
d2132 1
a2132 1
	real_ptrs = (long **)rt_calloc( maxindex+3,
d2177 2
a2178 2
	rt_free( (char *)ecnt, "ecnt[]" );
	rt_free( (char *)real_ptrs, "ptrs[]" );
d2225 1
a2225 1
struct rt_external		*ep;
d2259 1
a2259 1
	ecnt = (struct nmg_exp_counts *)rt_calloc( m->maxindex+1,
d2344 1
a2344 1
rt_log("Mapping of old index to new index, and kind\n");
d2349 1
a2349 1
		rt_log(" %4d %4d %s (%d)\n",
d2354 1
a2354 1
			rt_log("***ERROR, ptrs[%d]->index = %d\n",
d2358 1
a2358 1
			rt_log("@@@@@@ERROR, ptrs[%d] kind(%d) != %d\n",
d2367 1
a2367 1
		rt_log("%d of kind %s (%d)\n",
d2383 1
a2383 1
	RT_INIT_EXTERNAL(ep);
d2385 1
a2385 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "nmg external");
d2389 1
a2389 1
	(void)rt_plong( rp->nmg.N_count, additional_grans );
d2393 1
a2393 1
		(void)rt_plong( rp->nmg.N_structs+4*kind, kind_counts[kind] );
d2413 2
a2414 2
	rt_free( (char *)ptrs, "ptrs[]" );
	rt_free( (char *)ecnt, "ecnt[]" );
d2428 1
a2428 1
CONST struct rt_external	*ep;
d2433 1
a2433 1
	struct rt_tol			tol;
d2435 1
a2435 1
	RT_CK_EXTERNAL( ep );
d2439 1
a2439 1
		rt_log("rt_nmg_import: defective record\n");
d2448 1
a2448 1
	tol.magic = RT_TOL_MAGIC;
d2474 1
a2474 1
struct rt_external		*ep;
d2501 1
a2501 1
struct rt_vls		*str;
d2510 1
a2510 1
	rt_vls_printf( str, "n-Manifold Geometry solid (NMG) maxindex=%d\n",
d2525 1
a2525 1
	rt_free( (char *)ptrs, "struct_count *ptrs[]" );
@


11.11
log
@rt_nmg_shot() was missing assignment :rd.magic = NMG_RAY_DATA_MAGIC;
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 11.10 1997/01/09 16:15:46 jra Exp jra $ (BRL)";
d1060 2
a1061 2
			htond( d->min_pt, min, 3 );
			htond( d->max_pt, max, 3 );
d1090 2
a1091 2
			htond( d->min_pt, min, 3 );
			htond( d->max_pt, max, 3 );
d1136 1
a1136 1
			htond( d->N, plane, 4 );
d1205 2
a1206 2
			htond( d->min_pt, min, 3 );
			htond( d->max_pt, max, 3 );
d1252 2
a1253 2
			htond( d->e_pt, pt, 3);
			htond( d->e_dir, eg->e_dir, 3);
d1313 1
a1313 1
			htond( d->N, vua->N, 3 );
d1325 1
a1325 1
			htond( d->param, vua->param, 3 );
d1348 1
a1348 1
			htond( d->coord, pt, 3 );
d1447 2
a1448 2
			ntohd( min, d->min_pt, 3 );
			ntohd( max, d->max_pt, 3 );
d1477 2
a1478 2
			ntohd( min, d->min_pt, 3 );
			ntohd( max, d->max_pt, 3 );
d1527 1
a1527 1
			ntohd( plane, d->N, 4 );
d1606 2
a1607 2
			ntohd( min, d->min_pt, 3 );
			ntohd( max, d->max_pt, 3 );
d1678 2
a1679 2
			ntohd(pt, d->e_pt, 3);
			ntohd(dir, d->e_dir, 3);
d1745 1
a1745 1
			ntohd( norm, d->N, 3 );
d1757 1
a1757 1
			ntohd( vua->param, d->param, 3 );
d1779 1
a1779 1
			ntohd( pt, d->coord, 3 );
@


11.10
log
@Removed include of nmg_rt.h.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 11.9 1996/07/12 12:10:21 jra Exp jra $ (BRL)";
d218 1
@


11.9
log
@Minor Mods for IRIX 6.2
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 11.8 1996/05/16 21:46:52 jra Exp jra $ (BRL)";
a36 1
#include "./nmg_rt.h"
@


11.8
log
@Initialized rd.classifying_ray in rt_nmg_shot().
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 11.7 1996/03/07 20:27:24 jra Exp jra $ (BRL)";
d880 1
a880 1
int			subscript;
d2083 1
a2083 1
CONST register mat_t		mat;
@


11.7
log
@Added code to merge regions of imported models.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 11.6 1995/12/02 03:09:46 mike Exp $ (BRL)";
d205 1
@


11.6
log
@edge_g_lseg got an rt_list structure, for symmetry with edge_g_cnurb.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 11.4 1995/06/27 19:41:43 jra Exp $ (BRL)";
d387 12
a398 2
		rt_log("rt_nmg_tess: WARNING, NMG model contains more than one nmgregion.\n\tYou probably won't get what you expect!\n");
		/* Let it proceed, on the off chance it's useful */
@


11.5
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d1930 1
a1930 1
					eg->magic = NMG_EDGE_G_LSEG_MAGIC;
@


11.4
log
@Modified rt_nmg_edisk() under "case NMG_KIND_EDGE_G_CNURB" to pass the point type to rt_nmg_export_fastf()
and pass a scale factor of 1.0 if the curve is type RT_NURB_PT_UV.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 11.3 1995/03/03 11:52:35 butler Exp jra $ (BRL)";
d1879 1
a1879 1
					fg->magic = NMG_FACE_G_SNURB_MAGIC;
d1939 1
a1939 1
					eg->magic = NMG_EDGE_G_CNURB_MAGIC;
@


11.3
log
@added call to nmg_ck_vs_in_region() to prep routines to make sure we have
planar faces.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 11.2 1995/02/17 03:39:08 mike Exp butler $ (BRL)";
d1272 3
a1274 3
					RT_NURB_EXTRACT_PT_TYPE(eg->pt_type) == RT_NURB_PT_UV ?
						0 : eg->pt_type,
					local2mm ) );
@


11.2
log
@No regions in an NMG solid now gives an error on import.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 11.1 95/01/04 09:56:44 mike Rel4_4 Locker: mike $ (BRL)";
d104 3
d117 4
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.49 94/12/20 14:22:08 jra Exp $ (BRL)";
d370 3
a372 2
		/* No regions in imported geometry, that is OK */
		return(0);
@


10.49
log
@Another minor MOD for CRAYS.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.48 94/12/19 16:34:01 jra Exp Locker: jra $ (BRL)";
@


10.48
log
@Mods for CRAY.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/g_nmg.c,v 10.47 94/11/30 03:58:38 butler Exp Locker: jra $ (BRL)";
d946 1
a946 1
	int	ret;
@


10.47
log
@added call to rt_free for hitmiss table
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.46 94/11/17 16:57:00 jra Exp Locker: butler $ (BRL)";
d1535 1
a1535 1
				rt_glong( d->ctl_points ), mat,
d1698 1
a1698 1
					rt_glong( d->ctl_points ), mat,
@


10.46
log
@Changed bomb to a wrning in INDEXL and set eu->l2.forw and back to point to itself
for an edgeuse with no geometry.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.45 94/11/16 17:01:49 jra Exp Locker: jra $ (BRL)";
d217 3
@


10.45
log
@Allow rt_nmg_idisk to import eu's without geometry.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.44 94/11/04 05:47:22 mike Exp Locker: jra $ (BRL)";
d980 1
a980 1
	if( _f == DISK_INDEX_NULL )  rt_bomb("rt_nmg_edisk: reindex forw to null?\n"); \
d1624 5
@


10.44
log
@Irix 6
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.43 94/10/24 21:47:27 mike Exp Locker: mike $ (BRL)";
d1617 3
a1619 1
			NMG_CK_EDGE_G_EITHER(eu->g.magic_p);
d1621 4
a1624 3
			/* Note that l2 subscripts will be for edgeuse, not l2 */
			/* g.lseg_p->eu_hd2 is a pun for g.cnurb_p->eu_hd2 also */
			INDEXL_HD2( d, eu, l2, eu->g.lseg_p->eu_hd2 );
@


10.43
log
@t-NURBs NMG snurbs and cnurbs are now properly transformed
on export and import.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.42 94/09/23 20:42:37 mike Exp Locker: mike $ (BRL)";
a250 3
	register struct nmg_specific *nmg =
		(struct nmg_specific *)stp->st_specific;

a358 1
	struct nmgregion	*lr;
a1120 1
			int	relpos;
a1121 1
			relpos = ecnt[index].first_fastf_relpos;
a2477 2
	struct nmg_struct_counts	count;
	long			**ptrs;
d2486 3
d2496 1
@


10.42
log
@Fixed bug that Lee reported.  eg->eu_hd2 forw/back pointers were not
pointing to edgeuse2 list, but the main edgeuse rt_list.
Fixed by establishing INDEXL_HD2() macro to properly handle.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.41 94/09/22 04:09:13 mike Exp Locker: mike $ (BRL)";
d826 1
a826 6
#if 0
	if( scale == 1.0 )  {
#else
	/* XXX */
	if(1) {
#endif
d831 1
a831 2
		/* Blah, need to scale data by 'scale' ! */
/* XXX Needs stride!  Don't want to scale the homogeneous coord, if present! */
d833 14
a846 1
		VSCALEN( new, fp, scale, count );
a898 2
/* Bypass matrix stuff for now. */
#if 0
a899 3
#else
	{
#endif
a910 1
	/* XXX This isn't quite right */
d913 1
d919 1
d1145 1
a1145 1
			/* scale ctl_points by local2mm */
d1260 3
a1262 2
			 * The curve's control points are in parameter space.
			 * They do NOT get transformed!
d1267 3
a1269 2
					eg->pt_type,
					1.0 ) );
d1683 13
a1695 3
			eg->ctl_points = rt_nmg_import_fastf( basep, ecnt,
				rt_glong( d->ctl_points ), (matp_t)NULL,
				eg->c_size, eg->pt_type );
d2029 1
d2031 1
a2031 1

@


10.41
log
@Fixed pointer complaint from Sun.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.40 94/09/21 03:49:54 mike Exp Locker: mike $ (BRL)";
d1350 1
a1350 1
	else (ii)->elem.back = (struct rt_list *)ptrs[sub]; }
d1352 21
a1592 1
			struct edgeuse	*eu2;
a1595 1
			int			sub;
d1622 1
a1622 15
			/* inline INDEXL_HD( d, eu, l2, eu->g.lseg_p->eu_hd2 ); */
			if( (sub = rt_glong(d->l2.forw)) < 0 )  {
				eu->l2.forw = &(eu->g.lseg_p->eu_hd2);
			} else  {
				eu2 = (struct edgeuse *)ptrs[sub];
				NMG_CK_EDGEUSE(eu2);
				eu->l2.forw = &eu2->l2;
			}
			if( (sub = rt_glong(d->l2.back)) < 0 )  {
				eu->l2.back = &(eu->g.lseg_p->eu_hd2);
			} else  {
				eu2 = (struct edgeuse *)ptrs[sub];
				NMG_CK_EDGEUSE(eu2);
				eu->l2.back = &eu2->l2;
			}
d1647 2
a1648 1
			INDEXL_HD( d, eg, eu_hd2, eg->eu_hd2 );
d1662 1
a1662 1
			INDEXL_HD( d, eg, eu_hd2, eg->eu_hd2 );
d1886 1
d2219 1
a2219 1
	ecnt = (struct nmg_exp_counts *)rt_calloc( m->maxindex,
@


10.40
log
@Eliminated model_a structure
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.39 94/09/21 03:37:49 mike Exp Locker: mike $ (BRL)";
d2355 1
a2355 1
	rt_nmg_fastf_p = disk_arrays[NMG_KIND_DOUBLE_ARRAY];
@


10.39
log
@deleted "manifolds" from struct model, and moved it to struct ray_data.
Added extra argument to nmg_dangling_face().
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.38 94/09/21 03:06:38 mike Exp Locker: mike $ (BRL)";
a426 1
	disk_index_t		ma_p;
a429 6
/* XXX This is another unused structure! */
#define DISK_MODEL_A_MAGIC	0x4e6d5f61	/* Nm_a */
struct disk_model_a {
	unsigned char		magic[4];
};

d621 21
a641 21
#define NMG_KIND_MODEL_A	1
#define NMG_KIND_NMGREGION	2
#define NMG_KIND_NMGREGION_A	3
#define NMG_KIND_SHELL		4
#define NMG_KIND_SHELL_A	5
#define NMG_KIND_FACEUSE	6
#define NMG_KIND_FACE		7
#define NMG_KIND_FACE_G_PLANE	8
#define NMG_KIND_FACE_G_SNURB	9
#define NMG_KIND_LOOPUSE	10
#define NMG_KIND_LOOP		11
#define NMG_KIND_LOOP_G		12
#define NMG_KIND_EDGEUSE	13
#define NMG_KIND_EDGE		14
#define NMG_KIND_EDGE_G_LSEG	15
#define NMG_KIND_EDGE_G_CNURB	16
#define NMG_KIND_VERTEXUSE	17
#define NMG_KIND_VERTEXUSE_A_PLANE	18
#define NMG_KIND_VERTEXUSE_A_CNURB	19
#define NMG_KIND_VERTEX		20
#define NMG_KIND_VERTEX_G	21
a650 1
	sizeof(struct disk_model_a),
d659 2
a660 2
	sizeof(struct disk_loopuse),		/* 10 */
	sizeof(struct disk_loop),
d669 2
a670 2
	sizeof(struct disk_vertex),		/* 20 */
	sizeof(struct disk_vertex_g),
d674 1
a678 1
	"model_a",
d687 2
a688 2
	"loopuse",				/* 10 */
	"loop",
d697 3
a699 2
	"vertex",				/* 20 */
	"vertex_g",
a720 2
	case NMG_MODEL_A_MAGIC:
		return NMG_KIND_MODEL_A;
a1012 1
			INDEX( d, m, ma_p );
a1015 9
	case NMG_KIND_MODEL_A:
		{
			struct model_a	*ma = (struct model_a *)ip;
			struct disk_model_a	*d;
			d = &((struct disk_model_a *)op)[oindex];
			NMG_CK_MODEL_A(ma);
			PUTMAGIC( DISK_MODEL_A_MAGIC );
		}
		return;
a1379 1
			INDEX( d, m, model_a, ma_p );
a1382 9
	case NMG_KIND_MODEL_A:
		{
			struct model_a	*ma = (struct model_a *)op;
			struct disk_model_a	*d;
			d = &((struct disk_model_a *)ip)[iindex];
			NMG_CK_MODEL_A(ma);
			RT_CK_DISKMAGIC( d->magic, DISK_MODEL_A_MAGIC );
		}
		return 0;
a1777 8
				break;
			case NMG_KIND_MODEL_A:
				{
					struct model_a	*ma;
					GET_MODEL_A( ma, m );
					ma->magic = NMG_MODEL_A_MAGIC;
					ptrs[subscript] = (long *)ma;
				}
@


10.38
log
@Changed check for uninitialized pointers to use kind of -1, not 0
because 0 is NMG_KIND_MODEL.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.37 94/09/21 02:14:17 mike Exp Locker: mike $ (BRL)";
d46 3
a48 2
	int				nmg_smagic;	/* STRUCT START magic number */
	struct model	*nmg_model;
d50 1
a50 1
	int				nmg_emagic;	/* STRUCT END magic number */
d113 1
a113 1
	nmg_manifolds(m);
d191 1
@


10.37
log
@Added debugging to rt_nmg_reindex() to catch pointers to structures
that were not cited in the ptrs[] table.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.36 94/09/21 00:37:03 mike Exp Locker: mike $ (BRL)";
d965 1
a965 1
			if( ecnt[index].kind <= 0 )  {
d2255 4
a2258 1
		if( ptrs[i] == (long *)0 )  continue;
@


10.36
log
@Removed debug prints.
Added two nmg_vmodel() calls, performed only when debugging is on.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.35 94/09/16 23:35:51 mike Exp Locker: mike $ (BRL)";
d429 1
d938 2
d965 12
d979 1
a979 1
/*rt_log("rt_nmg_reindex(p=x%x), index=%d, newindex=%d\n", p, index, ret);*/
d1292 2
a1293 1
			rt_plong( d->up, rt_nmg_reindex((genptr_t)(vu->up.magic_p), ecnt) );
d1295 3
a1297 1
			rt_plong( d->a, rt_nmg_reindex((genptr_t)(vu->a.magic_p), ecnt) );
d1308 1
d1715 1
d1790 1
a1790 2
	/* Specifically avoid the last kind, fastf_t arrays */
	for( kind = 0; kind < NMG_N_KINDS-1; kind++ )  {
d1794 1
d2127 1
d2365 2
d2470 2
a2471 2
	if( rt_g.debug || rt_g.NMG_debug )
		nmg_vmodel(m);
@


10.35
log
@Added code to handle eg->order == 0 special case.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.34 94/09/16 19:36:03 mike Exp Locker: mike $ (BRL)";
a2273 1
rt_log("kind_counts[DOUBLE]=%d, double_count=%d\n", kind_counts[NMG_KIND_DOUBLE_ARRAY], double_count);
a2303 1
rt_log("first fastf subscript=%d, count=%d\n", subscript, kind_counts[NMG_KIND_DOUBLE_ARRAY] );
d2422 3
d2446 3
@


10.34
log
@Tidyness pass

@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.33 94/09/16 05:00:52 mike Exp Locker: mike $ (BRL)";
d1248 4
d1666 4
d2262 2
@


10.33
log
@For the teapot_nmg program, this version works.
Some details still need cleaning up.
@
text
@a0 9
/* XXX Move to nmg.h */
#define NMG_CK2MAG(_ptr, _magic1, _magic2, _str)	\
	if( !(_ptr) || (*((long *)(_ptr)) != (_magic1) && *((long *)(_ptr)) != (_magic2) ) )  { \
		rt_badmagic( (long *)(_ptr), _magic1, _str, __FILE__, __LINE__ ); \
	}
#define NMG_CK_FACE_G_EITHER(_p)	NMG_CK2MAG(_p, NMG_FACE_G_PLANE_MAGIC, NMG_FACE_G_SNURB_MAGIC, "face_g_plane|face_g_snurb")
#define NMG_CK_EDGE_G_EITHER(_p)	NMG_CK2MAG(_p, NMG_EDGE_G_LSEG_MAGIC, NMG_EDGE_G_CNURB_MAGIC, "edge_g_lseg|edge_g_cnurb")


d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.32 94/09/16 04:05:42 mike Exp Locker: mike $ (BRL)";
d37 1
a37 1
#include "./nmg_rt.h"		/* XXX Why do we need this? */
@


10.32
log
@This version will import/export t-NURBS without dumping core.
However, the control points are somehow garbled.
@
text
@d29 1
a29 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.31 94/09/10 05:41:42 mike Exp Locker: mike $ (BRL)";
d827 1
a827 1
rt_nmg_export_fastf( fp, count, scale )
d830 1
d835 3
d841 1
d843 4
d867 1
a867 1
rt_nmg_import_fastf( base, ecnt, subscript, mat, len, stride )
d873 1
a873 1
int			stride;
d896 4
d907 2
d910 3
d924 2
a925 1
	switch( stride )  {
d1145 2
a1146 1
				rt_nmg_export_fastf( fg->u.knots, fg->u.k_size, 1.0 ) );
d1148 2
a1149 1
				rt_nmg_export_fastf( fg->v.knots, fg->v.k_size, 1.0 ) );
d1157 1
d1259 2
a1260 1
				rt_nmg_export_fastf( eg->k.knots, eg->k.k_size, 1.0 ) );
d1269 3
a1271 1
					eg->c_size, 1.0 ) );
d1515 1
a1515 1
				fg->u.k_size, 1 );
d1518 2
a1519 2
				rt_glong( d->v_knots ), (matp_t)NULL, fg->v.k_size,
				1 );
d1527 1
a1527 1
				RT_NURB_EXTRACT_COORDS(fg->pt_type) );
d1674 1
a1674 1
				eg->k.k_size, 1 );
d1683 1
a1683 1
				eg->c_size, 1 );
d2250 2
a2251 1
					   fg->s_size[0] * fg->s_size[1];
d2264 2
a2265 1
				ndouble = eg->k.k_size + eg->c_size;
@


10.31
log
@Had to do custom import for edgeuse l2 pointers.
@
text
@d1 9
d29 1
a29 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.30 94/09/10 04:36:22 mike Exp Locker: mike $ (BRL)";
d44 1
d46 1
a46 1
#include "./nmg_rt.h"
d403 7
d487 1
a487 1
#define DISK_FACE_G_PLANE_MAGIC	0x4e665f70	/* Nf_p */
d494 1
a494 1
#define DISK_FACE_G_SNURB_MAGIC	0x4e665f73	/* Nf_s */
d502 2
a503 2
	/* XXXXXX knot vetor??? u.knots */
	/* XXXXXX knot vetor??? v.knots */
d507 1
a507 1
	/* XXXXXX ctl_points ???? */
a551 1
	disk_index_t		eg_p;
d555 1
a555 1
#define DISK_EDGE_G_LSEG_MAGIC	0x4e655f67	/* Ne_g */
d563 1
a563 1
#define DISK_EDGE_G_CNURB_MAGIC	0x4e655f63	/* Ne_c */
d569 1
a569 1
	/* XXXXXXX knot vector???   knot.knots */
d572 1
a572 1
	/* XXXXXXX ctl_points[] ???? */
d624 7
d662 1
a662 1
int	rt_nmg_disk_sizes[NMG_N_KINDS] = {
d688 1
a688 1
	0					/* 25: MUST BE ZERO */
d690 1
a690 1
char	rt_nmg_kind_names[NMG_N_KINDS+2][18] = {
d789 2
d793 4
d798 127
d1114 1
d1116 1
d1125 4
d1132 5
a1136 2
			/* XXX scale ctl_points by local2mm */
/* XXX */		rt_bomb("face_g_snurb knot & ctl_points export\n");
d1236 2
d1240 7
a1246 2
			/* XXX Scale ctl_points by local2mm */
/* XXX */		rt_bomb("edge_g_cnurb knots and ctl_points export\n");
a1313 8
#define RT_CK_DISKMAGIC(_cp,_magic)	\
	if( rt_glong(_cp) != _magic )  { \
		rt_log("RT_CK_DISKMAGIC: magic mis-match, got x%x, s/b x%x, file %s, line %d\n", \
			rt_glong(_cp), _magic, __FILE__, __LINE__); \
		rt_bomb("bad magic\n"); \
	}


d1338 1
a1338 1
rt_nmg_idisk( op, ip, ecnt, index, ptrs, mat )
d1344 2
a1345 1
mat_t		mat;
d1459 1
a1459 1
			NMG_CK_FACE_G_PLANE(f->g.plane_p);
d1488 3
d1492 3
d1498 5
a1502 2
			/* XXX Must transform ctl_points by 'mat' */
/* XXX */		rt_bomb("snurb u.knots, v.knots, ctl_points\n");
d1587 1
a1587 1
			NMG_CK_EDGE_G_LSEG(eu->g.lseg_p);	/* XXX */
a1644 1
			/* XXX Must transform ctl_points by 'mat' */
d1647 3
d1652 7
a1658 1
/* XXX */		rt_bomb("cnurb knots and ctl_points?\n");
d1746 2
a1747 1
	for( kind = 0; kind < NMG_N_KINDS; kind++ )  {
d1960 53
d2034 1
a2034 1
	char				*cp;
d2087 4
a2091 1
	cp = (char *)(rp+1);	/* start at first granule in */
d2093 2
d2096 1
a2096 1
			ecnt, i, ptrs, mat ) < 0 )
d2186 2
d2207 2
d2214 31
d2246 1
d2275 4
d2314 4
d2337 2
@


10.30
log
@Converted NMG data structures to have edge_g pointer in edgeuse, not edge.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.29 94/09/09 10:58:36 jra Exp $ (BRL)";
d1022 4
d1386 1
d1390 1
d1414 18
a1431 1
			INDEXL_HD( d, eu, l2, eu->g.lseg_p->eu_hd2 );	/* pun for g.cnurb_p->eu_hd2 also */
@


10.29
log
@Added NMG_LOOP_MAGIC to rt_nmg_magic_to_kind.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.28 94/09/03 03:01:03 mike Exp $ (BRL)";
d470 1
a470 1
#define DISK_FACE_G_PLANE_MAGIC	0x4e665f61	/* Nf_a */
a474 4
	/*
	 * Note that min_pt and max_pt are not stored on disk,
	 * regardless of "compact" flag setting.
	 */
d477 16
a504 5
#define DISK_FACEUSE_A_MAGIC	0x4e667561	/* Nfua */
struct disk_faceuse_a {
	unsigned char		magic[4];	/* XXX */
};

a530 5
#define DISK_LOOPUSE_A_MAGIC	0x4e6c7561	/* Nlua */
struct disk_loopuse_a {
	unsigned char		magic[4];	/* XXX */
};

d539 1
a539 1
#define DISK_EDGE_G_MAGIC	0x4e655f67	/* Ne_g */
a541 1
	/* usage is gone */
d547 12
d571 1
a573 5
#define DISK_EDGEUSE_A_MAGIC	0x4e657561	/* Neua */
struct disk_edgeuse_a {
	unsigned char		magic[4];	/* XXX */
};

d617 3
a619 3
#define NMG_KIND_FACEUSE_A	7		/* XXX */
#define NMG_KIND_FACE		8
#define NMG_KIND_FACE_G_PLANE	9
d621 9
a629 11
#define NMG_KIND_LOOPUSE_A	11		/* XXX */
#define NMG_KIND_LOOP		12
#define NMG_KIND_LOOP_G		13
#define NMG_KIND_EDGEUSE	14
#define NMG_KIND_EDGEUSE_A	15		/* XXX */
#define NMG_KIND_EDGE		16
#define NMG_KIND_EDGE_G_LSEG		17
#define NMG_KIND_EDGE_G_CNURB		0	/* XXX reuse */
#define NMG_KIND_VERTEXUSE	18
#define NMG_KIND_VERTEXUSE_A_PLANE	19
#define NMG_KIND_VERTEXUSE_A_CNURB	0	/* XXX reuse */
d633 2
d640 1
a640 1
	sizeof(struct disk_model),
a646 1
	sizeof(struct disk_faceuse_a),
d649 2
a650 2
	sizeof(struct disk_loopuse),
	sizeof(struct disk_loopuse_a),
a653 1
	sizeof(struct disk_edgeuse_a),
d656 1
d659 7
a665 2
	sizeof(struct disk_vertex),
	sizeof(struct disk_vertex_g)
d667 2
a668 2
char	rt_nmg_kind_names[NMG_N_KINDS][18] = {
	"model",
a674 1
	"faceuse_a",
d677 2
a678 2
	"loopuse",
	"loopuse_a",
a681 1
	"edgeuse_a",
d684 1
d687 9
a695 2
	"vertex",
	"vertex_g"
d727 2
d741 2
d816 2
a926 3
	case NMG_KIND_FACEUSE_A:
		rt_bomb("nmg_kind_faceuse_a\n");
		return;
d954 20
a988 3
	case NMG_KIND_LOOPUSE_A:
		rt_bomb("nmg_kind_loopuse_a\n");
		return;
d1029 1
a1031 3
	case NMG_KIND_EDGEUSE_A:
		rt_bomb("nmg_kind_edgeuse_a\n");
		return;
a1040 1
			INDEX( d, e, eg_p );
d1047 1
d1050 1
a1050 1
			PUTMAGIC( DISK_EDGE_G_MAGIC );
d1052 2
a1053 1
			htond( d->e_pt, eg->e_pt, 3);
d1057 16
a1089 1
			plane_t			plane;
d1093 2
a1094 3
			VMOVE( plane, vua->N );
			plane[3] = vua->N[3] * local2mm;
			htond( d->N, plane, 4 );
d1097 12
d1166 2
a1275 3
	case NMG_KIND_FACEUSE_A:
		rt_bomb("nmg_kind_faceuse_a\n");
		return 0;
d1308 19
a1353 3
	case NMG_KIND_LOOPUSE_A:
		rt_bomb("nmg_kind_loopuse_a\n");
		return 0;
d1402 1
d1407 2
a1408 2
			NMG_CK_EDGE_G_LSEG(eu->e_p->eg_p);
			INDEXL_HD( d, eu, l2, eu->e_p->eg_p->eu_hd2 );
a1410 3
	case NMG_KIND_EDGEUSE_A:
		rt_bomb("nmg_kind_edgeuse_a\n");
		return 0;
a1419 1
			INDEX( d, e, edge_g_lseg, eg_p );
d1427 3
d1432 1
a1432 4
			RT_CK_DISKMAGIC( d->magic, DISK_EDGE_G_MAGIC );
			/* usage is gone */
			ntohd(eg->e_pt, d->e_pt, 3);
			ntohd(eg->e_dir, d->e_dir, 3);
d1434 4
d1440 16
d1474 1
a1474 1
			plane_t			plane;
d1478 2
a1479 2
			ntohd( plane, d->N, 4 );
			rt_rotate_plane( vua->N, mat, plane );
a1481 1
#if 0
d1487 3
a1489 2
			NMG_CK_VERTEXUSE_A_PLANE(vua);
			RT_CK_DISKMAGIC( d->magic, DISK_VERTEXUSE_A_PLANE_MAGIC );
a1492 1
#endif
d1525 1
a1608 3
			case NMG_KIND_FACEUSE_A:
				rt_bomb("nmg_kind_faceuse_a\n");
				break;
d1626 9
a1643 3
			case NMG_KIND_LOOPUSE_A:
				rt_bomb("nmg_kind_loopuse_a\n");
				break;
a1667 3
			case NMG_KIND_EDGEUSE_A:
				rt_bomb("nmg_kind_edgeuse_a\n");
				break;
d1681 1
d1685 9
a1709 1
#if 0
a1717 1
#endif
a1872 1
 *  (Saving space in face_g_plane is problematic).
d1875 26
@


10.28
log
@Snapshot of non-working intermediate stage in edge_g evolution.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.27 94/09/02 19:07:44 mike Exp Locker: mike $ (BRL)";
d712 2
@


10.27
log
@vertexuse_a is now vertexuse_a_plane and vertexuse_a_cnurb
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.26 94/09/02 17:58:34 mike Exp Locker: mike $ (BRL)";
d405 2
a413 1
#define DISK_MODEL_VERSION	0x656c2032	/* el 2 */
d416 1
a416 1
	unsigned char		version[4];
d538 1
a538 1
struct disk_edge_g {
d540 2
a541 1
	unsigned char		usage[4];
d550 1
d618 2
a619 1
#define NMG_KIND_EDGE_G		17
d626 3
a628 1
#define NMG_N_KINDS		22		/* number of kinds */
d648 1
a648 1
	sizeof(struct disk_edge_g),
d664 1
a664 1
	"face_g",
d672 1
a672 1
	"edge_g",
d716 2
a717 2
	case NMG_EDGE_G_MAGIC:
		return NMG_KIND_EDGE_G;
d811 1
a811 1
			rt_plong( d->version, DISK_MODEL_VERSION );
d981 1
d1005 1
a1005 1
	case NMG_KIND_EDGE_G:
d1007 4
a1010 4
			struct edge_g	*eg = (struct edge_g *)ip;
			struct disk_edge_g	*d;
			d = &((struct disk_edge_g *)op)[oindex];
			NMG_CK_EDGE_G(eg);
d1012 1
a1012 1
			rt_plong( d->usage, eg->usage );
a1120 9
			/*
			 * In the future, it may be necessary to be able to
			 * read older versions as well.  This is the hook.
			 */
			if( rt_glong( d->version ) != DISK_MODEL_VERSION )  {
				rt_log("rt_nmg_idisk() NMG version number mis-match, got x%x, s/b x%x\n",
					rt_glong(d->version), DISK_MODEL_MAGIC );
				return -1;
			}
d1325 2
d1341 1
a1341 1
			INDEX( d, e, edge_g, eg_p );
d1345 1
a1345 1
	case NMG_KIND_EDGE_G:
d1347 4
a1350 4
			struct edge_g	*eg = (struct edge_g *)op;
			struct disk_edge_g	*d;
			d = &((struct disk_edge_g *)ip)[iindex];
			NMG_CK_EDGE_G(eg);
d1352 1
a1352 1
			eg->usage = rt_glong( d->usage );
d1355 1
d1578 1
a1578 1
			case NMG_KIND_EDGE_G:
d1580 3
a1582 3
					struct edge_g	*eg;
					GET_EDGE_G( eg, m );
					eg->magic = NMG_EDGE_G_MAGIC;
d1687 11
d1885 1
@


10.26
log
@faceuse_a, loopuse_a, and edgeuse_a have been eliminated.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.25 94/09/02 01:14:27 mike Exp Locker: mike $ (BRL)";
d581 1
a581 1
	disk_index_t		vua_p;
d584 2
a585 2
#define DISK_VERTEXUSE_A_MAGIC	0x4e767561	/* Nvua */
struct disk_vertexuse_a {
d590 6
d644 1
a644 1
	sizeof(struct disk_vertexuse_a),
d1020 1
a1020 1
			INDEX( d, vu, vua_p );
d1025 2
a1026 2
			struct vertexuse_a	*vua = (struct vertexuse_a *)ip;
			struct disk_vertexuse_a	*d;
d1028 3
a1030 3
			d = &((struct disk_vertexuse_a *)op)[oindex];
			NMG_CK_VERTEXUSE_A(vua);
			PUTMAGIC( DISK_VERTEXUSE_A_MAGIC );
d1366 1
a1366 1
			INDEX( d, vu, vertexuse_a, vua_p );
d1373 2
a1374 2
			struct vertexuse_a	*vua = (struct vertexuse_a *)op;
			struct disk_vertexuse_a	*d;
d1376 3
a1378 3
			d = &((struct disk_vertexuse_a *)ip)[iindex];
			NMG_CK_VERTEXUSE_A(vua);
			RT_CK_DISKMAGIC( d->magic, DISK_VERTEXUSE_A_MAGIC );
d1383 12
d1595 3
a1597 3
					struct vertexuse_a	*vua;
					GET_VERTEXUSE_A( vua, m );
					vua->magic = NMG_VERTEXUSE_A_MAGIC;
d1601 10
@


10.25
log
@More fallout from face_g changes.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.24 94/09/02 00:32:49 mike Exp Locker: mike $ (BRL)";
d494 1
a494 1
	unsigned char		magic[4];
d525 1
a525 1
	unsigned char		magic[4];
d559 1
a559 1
	unsigned char		magic[4];
d599 1
a599 1
#define NMG_KIND_FACEUSE_A	7
d603 1
a603 1
#define NMG_KIND_LOOPUSE_A	11
d607 1
a607 1
#define NMG_KIND_EDGEUSE_A	15
d611 2
a612 1
#define NMG_KIND_VERTEXUSE_A	19
d642 1
a642 1
char	rt_nmg_kind_names[NMG_N_KINDS][12] = {
d662 1
a662 1
	"vertexuse_a",
a691 2
	case NMG_FACEUSE_A_MAGIC:
		return NMG_KIND_FACEUSE_A;
a697 4
	case NMG_LOOPUSE_A_MAGIC:
		return NMG_KIND_LOOPUSE_A;
	case NMG_LOOP_MAGIC:
		return NMG_KIND_LOOP;
a701 2
	case NMG_EDGEUSE_A_MAGIC:
		return NMG_KIND_EDGEUSE_A;
d708 4
a711 2
	case NMG_VERTEXUSE_A_MAGIC:
		return NMG_KIND_VERTEXUSE_A;
a884 1
			INDEX( d, fu, fua_p );
d889 1
a889 7
		{
			struct faceuse_a	*fua = (struct faceuse_a *)ip;
			struct disk_faceuse_a	*d;
			d = &((struct disk_faceuse_a *)op)[oindex];
			NMG_CK_FACEUSE_A(fua);
			PUTMAGIC( DISK_FACEUSE_A_MAGIC );
		}
a929 1
			INDEX( d, lu, lua_p );
d934 1
a934 7
		{
			struct loopuse_a	*lua = (struct loopuse_a *)ip;
			struct disk_loopuse_a	*d;
			d = &((struct disk_loopuse_a *)op)[oindex];
			NMG_CK_LOOPUSE_A(lua);
			PUTMAGIC( DISK_LOOPUSE_A_MAGIC );
		}
a972 1
			INDEX( d, eu, eua_p );
d978 1
a978 7
		{
			struct edgeuse_a	*eua = (struct edgeuse_a *)ip;
			struct disk_edgeuse_a	*d;
			d = &((struct disk_edgeuse_a *)op)[oindex];
			NMG_CK_EDGEUSE_A(eua);
			PUTMAGIC( DISK_EDGEUSE_A_MAGIC );
		}
d1017 1
a1017 1
	case NMG_KIND_VERTEXUSE_A:
a1197 1
			INDEX( d, fu, faceuse_a, fua_p );
d1205 1
a1205 7
		{
			struct faceuse_a	*fua = (struct faceuse_a *)op;
			struct disk_faceuse_a	*d;
			d = &((struct disk_faceuse_a *)ip)[iindex];
			NMG_CK_FACEUSE_A(fua);
			RT_CK_DISKMAGIC( d->magic, DISK_FACEUSE_A_MAGIC );
		}
a1253 1
			INDEX( d, lu, loopuse_a, lua_p );
d1267 1
a1267 7
		{
			struct loopuse_a	*lua = (struct loopuse_a *)op;
			struct disk_loopuse_a	*d;
			d = &((struct disk_loopuse_a *)ip)[iindex];
			NMG_CK_LOOPUSE_A(lua);
			RT_CK_DISKMAGIC( d->magic, DISK_LOOPUSE_A_MAGIC );
		}
a1308 1
			INDEX( d, eu, edgeuse_a, eua_p );
d1324 1
a1324 7
		{
			struct edgeuse_a	*eua = (struct edgeuse_a *)op;
			struct disk_edgeuse_a	*d;
			d = &((struct disk_edgeuse_a *)ip)[iindex];
			NMG_CK_EDGEUSE_A(eua);
			RT_CK_DISKMAGIC( d->magic, DISK_EDGEUSE_A_MAGIC );
		}
d1365 1
a1365 1
	case NMG_KIND_VERTEXUSE_A:
d1493 1
a1493 6
				{
					struct faceuse_a	*fua;
					GET_FACEUSE_A( fua, m );
					fua->magic = NMG_FACEUSE_A_MAGIC;
					ptrs[subscript] = (long *)fua;
				}
d1522 1
a1522 6
				{
					struct loopuse_a	*lua;
					GET_LOOPUSE_A( lua, m );
					lua->magic = NMG_LOOPUSE_A_MAGIC;
					ptrs[subscript] = (long *)lua;
				}
d1549 1
a1549 6
				{
					struct edgeuse_a	*eua;
					GET_EDGEUSE_A( eua, m );
					eua->magic = NMG_EDGEUSE_A_MAGIC;
					ptrs[subscript] = (long *)eua;
				}
d1575 1
a1575 1
			case NMG_KIND_VERTEXUSE_A:
@


10.24
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.23 94/08/10 22:37:45 mike Exp Locker: mike $ (BRL)";
d918 1
a918 1
			struct face_g_plane	*fg = (struct face_g *)ip;
d1261 1
a1261 1
			struct face_g_plane	*fg = (struct face_g *)op;
@


10.23
log
@index_t is used by a system header file.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.22 94/08/10 18:35:10 gdurf Exp Locker: mike $ (BRL)";
d465 1
a465 1
	disk_index_t		fg_p;
d469 2
a470 2
#define DISK_FACE_G_MAGIC	0x4e665f61	/* Nf_a */
struct disk_face_g {
d601 1
a601 1
#define NMG_KIND_FACE_G		9
d627 1
a627 1
	sizeof(struct disk_face_g),
d695 2
a696 2
	case NMG_FACE_G_MAGIC:
		return NMG_KIND_FACE_G;
d912 1
a912 1
			INDEX( d, f, fg_p );
d916 1
a916 1
	case NMG_KIND_FACE_G:
d918 2
a919 2
			struct face_g	*fg = (struct face_g *)ip;
			struct disk_face_g	*d;
d921 3
a923 3
			d = &((struct disk_face_g *)op)[oindex];
			NMG_CK_FACE_G(fg);
			PUTMAGIC( DISK_FACE_G_MAGIC );
d1244 2
d1250 2
a1251 1
			INDEX( d, f, face_g, fg_p );
d1254 2
a1255 2
			NMG_CK_FACE_G(f->fg_p);
			INDEXL_HD( d, f, l, f->fg_p->f_hd ); /* after fu->fg_p set */
d1259 1
a1259 1
	case NMG_KIND_FACE_G:
d1261 2
a1262 2
			struct face_g	*fg = (struct face_g *)op;
			struct disk_face_g	*d;
d1264 3
a1266 3
			d = &((struct disk_face_g *)ip)[iindex];
			NMG_CK_FACE_G(fg);
			RT_CK_DISKMAGIC( d->magic, DISK_FACE_G_MAGIC );
d1555 1
a1555 1
			case NMG_KIND_FACE_G:
d1557 3
a1559 3
					struct face_g	*fg;
					GET_FACE_G( fg, m );
					fg->magic = NMG_FACE_G_MAGIC;
d1789 1
a1789 1
 *  (Saving space in face_g is problematic).
@


10.22
log
@Added include of conf.h
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.21 1994/08/10 18:34:54 gdurf Exp gdurf $ (BRL)";
d28 1
d399 1
a399 1
 *  There are two special values that may be assigned to an index_t
d405 1
a405 1
typedef	unsigned char	index_t[4];
d407 2
a408 2
	index_t		forw;
	index_t		back;
d416 1
a416 1
	index_t			ma_p;
d429 2
a430 2
	index_t   		m_p;
	index_t			ra_p;
d445 2
a446 2
	index_t			r_p;
	index_t			sa_p;
d450 1
a450 1
	index_t			vu_p;
d464 2
a465 2
	index_t			fu_p;
	index_t			fg_p;
d484 2
a485 2
	index_t			s_p;
	index_t			fumate_p;
d487 2
a488 2
	index_t			f_p;
	index_t			fua_p;
d500 2
a501 2
	index_t			lu_p;
	index_t			lg_p;
d515 2
a516 2
	index_t			up;
	index_t			lumate_p;
d518 2
a519 2
	index_t			l_p;
	index_t			lua_p;
d531 2
a532 2
	index_t			eu_p;
	index_t			eg_p;
d548 5
a552 5
	index_t			up;
	index_t			eumate_p;
	index_t			radial_p;
	index_t			e_p;
	index_t			eua_p;
d554 1
a554 1
	index_t			vu_p;
d566 1
a566 1
	index_t			vg_p;
d579 3
a581 3
	index_t			up;
	index_t			v_p;
	index_t			vua_p;
@


10.21
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.20 94/04/25 01:58:03 butler Exp Locker: butler $ (BRL)";
d22 2
@


10.20
log
@added warnings about nmg_tess destroying solid, and code to null the
idp_ptr for the NMG once the model has been stolen.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.19 94/04/25 00:37:36 butler Exp Locker: butler $ (BRL)";
d152 4
a155 2
	if(rt_g.NMG_debug & DEBUG_NMGRT)
		rt_log("rt_nmg_shot\n");
@


10.19
log
@converted importer to use nmg_merge_models()
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.18 94/01/12 02:49:46 mike Exp Locker: butler $ (BRL)";
d336 5
d377 5
d383 1
a384 1

d2044 5
a2048 3
	m = (struct model *)ip->idb_ptr;
	NMG_CK_MODEL(m);
	nmg_km( m );
@


10.18
log
@Eliminated crud from NMG overlay.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.17 94/01/11 04:24:53 mike Exp Locker: mike $ (BRL)";
a370 1
	/* What follows should probably be made a generic nmg operation */
d372 1
a372 6
	/* Dest must be empty to avoid index confusion */
	if( RT_LIST_NON_EMPTY( &(m->r_hd) ) )  {
		rt_log("rt_nmg_tess: destination model non-empty\n");
		/* XXX Here, should use some kind of nmg_copy() */
		return(-1);
	}
a373 8
	/* Swipe newly imported model's stuff */
	RT_LIST_APPEND_LIST( &(m->r_hd), &(lm->r_hd) );
	m->maxindex += lm->maxindex;	/* just barely OK for a hack */

	/* Re-home regions to new model (which was empty until now) */
	for( RT_LIST_FOR( lr, nmgregion, &(m->r_hd) ) )  {
		lr->m_p = m;
	}
@


10.17
log
@A faintly working rt_nmg_describe()
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.16 94/01/10 16:09:24 mike Exp Locker: mike $ (BRL)";
d2023 2
d2031 1
@


10.16
log
@Improved debugging.
Fixed problem with import of new face_g structures.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.15 93/11/18 02:27:46 mike Exp Locker: mike $ (BRL)";
d2014 2
d2018 2
a2019 1
	rt_vls_strcat( str, "n-Manifold Geometry solid (NMG)\n");
d2023 2
a2024 1
	/* Should print out # of database granules used */
d2026 3
a2028 1
	nmg_pr_m(m);
@


10.15
log
@Need a struct rt_tol for importing an NMG, to do the bounding boxes.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.14 93/11/18 01:43:20 mike Exp Locker: mike $ (BRL)";
d760 1
a760 1
			ret = DISK_INDEX_NULL;	/* ERROR. Use null ptr on import */
d909 1
a909 1
			INDEXL( d, f, l );
d1086 2
a1087 1
		rt_log("RT_CK_DISKMAGIC: magic mis-match, got x%x, s/b x%x\n", rt_glong(_cp), _magic); \
d1195 1
a1196 1
			NMG_CK_REGION(s->r_p);
d1249 2
d1556 1
@


10.14
log
@Modified for new face/face_g format
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/g_nmg.c,v 10.13 93/11/17 19:50:50 butler Exp $ (BRL)";
d1941 1
d1951 12
a1962 1
	if( rt_nmg_import_internal( ip, ep, mat, 1 ) < 0 )
@


10.13
log
@moved construction of the nmg ray-data struct to rt_shot()
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.12 1993/07/22 02:25:17 butler Exp butler $ (BRL)";
d411 1
d414 1
d462 1
d465 1
d471 1
d803 1
d909 1
d912 1
d923 1
d1112 1
a1112 1
void
d1132 9
d1144 1
a1144 1
		return;
d1153 1
a1153 1
		return;
d1167 1
a1167 1
		return;
d1180 1
a1180 1
		return;
d1197 1
a1197 1
		return;
d1210 1
a1210 1
		return;
d1228 1
a1228 1
		return;
d1237 1
a1237 1
		return;
d1247 2
d1251 1
a1251 1
		return;
d1260 1
d1264 1
a1264 1
		return;
d1292 1
a1292 1
		return;
d1301 1
a1301 1
		return;
d1313 1
a1313 1
		return;
d1326 1
a1326 1
		return;
d1356 1
a1356 1
		return;
d1365 1
a1365 1
		return;
d1378 1
a1378 1
		return;
d1390 1
a1390 1
		return;
d1404 1
a1404 1
		return;
d1416 1
a1416 1
		return;
d1427 1
a1427 1
		return;
d1439 1
a1439 1
		return;
d1442 1
d1544 1
a1544 1
					f->magic = NMG_FACE_MAGIC;
d1684 1
a1684 1
rt_nmg_import_internal( ip, ep, mat, rebound )
d1689 1
d1704 1
d1739 3
a1741 2
		rt_nmg_idisk( (genptr_t)(ptrs[i]), (genptr_t)cp,
			ecnt, i, ptrs, mat );
d1747 1
a1747 1
		nmg_rebound(m);
d1756 1
a1756 1
			nmg_face_bb( (struct face *)ptrs[i] );
@


10.12
log
@removed absolute setting of DEBUG_NMGRT
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.11 1993/06/04 20:51:49 butler Exp butler $ (BRL)";
d33 1
d37 2
a38 2
#define	G_NMG_START_MAGIC	6014061
#define	G_NMG_END_MAGIC		7013061
d40 7
d48 1
d71 1
a71 1
	register struct nmg_specific	*nmg;
a74 3
	/* XXX  Cause debugging output always
	rt_g.NMG_debug |= DEBUG_NMGRT;	 */

d79 3
a81 3
	GETSTRUCT( nmg, nmg_specific );
	stp->st_specific = (genptr_t)nmg;
	nmg->nmg_model = m;
d83 2
a84 2
	nmg->nmg_smagic = G_NMG_START_MAGIC;
	nmg->nmg_emagic = G_NMG_END_MAGIC;
d118 1
a118 1
register const struct soltab *stp;
d147 3
a149 1
	register struct nmg_specific *nmg =
d156 1
a156 1
 	if (nmg->nmg_smagic != G_NMG_START_MAGIC)
d159 1
a159 1
 	if (nmg->nmg_emagic != G_NMG_END_MAGIC)
d182 29
a210 1
	return(nmg_ray_isect_segs(stp, rp, ap, seghead, nmg));
d212 1
@


10.11
log
@turned off mandatory debugging
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.10 93/04/07 05:58:04 butler Exp Locker: butler $ (BRL)";
d66 2
a67 2
	/* XXX  Cause debugging output always */
	rt_g.NMG_debug |= DEBUG_NMGRT;	
@


10.10
log
@Moved NMG ray-tracing support to nmg_rt.c
@
text
@d6 1
a6 1
 *	Intersect a ray with a 
d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.9 93/03/05 23:55:20 butler Exp Locker: butler $ (BRL)";
d66 2
a67 1
	rt_g.NMG_debug |= DEBUG_NMGRT;
d80 1
a80 1
	/* get bounding box of solid */
d99 3
d206 1
a206 1
/*	register struct nmg_specific *nmg =
d209 1
a209 1
	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir ); */
@


10.9
log
@Fixed vertexuse linked list import problem.
@
text
@d9 1
a9 1
 *  
d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.8 92/11/11 00:05:00 mike Exp Locker: butler $ (BRL)";
a35 12
struct hitlist {
	struct rt_list	l;
	struct hit	hit;
};

struct nmg_specific {
	int		nmg_smagic;
	vect_t		nmg_V;	/* */
	struct model	*nmg_model;
	vect_t		nmg_invdir;
	int		nmg_emagic;
};
a38 17
/*	EDGE-FACE correlation data
 * 	used in edge_hit() for 3manifold case
 */
struct ef_data {
    	fastf_t		fdotr;	/* face vector VDOT with ray */
    	fastf_t		fdotl;	/* face vector VDOT with ray-left */
    	fastf_t		ndotr;	/* face normal VDOT with ray */
    	struct edgeuse *eu;
};
static
struct structparse ef_parsetab[] = {
	{"%f", 1, "fdotr", offsetof(struct ef_data, fdotr), FUNC_NULL},
	{"%f", 1, "fdotl", offsetof(struct ef_data, fdotl), FUNC_NULL},
	{"%f", 1, "ndotr", offsetof(struct ef_data, ndotr), FUNC_NULL},
	{"%x", 1, "eu",   offsetof(struct ef_data, eu),   FUNC_NULL},
	{"", 0, (char *)NULL,	  0,			  FUNC_NULL}
};
a39 11
static
struct structparse hit_parsetab[] = {
{"%f", 1, "hit_dist", offsetof(struct hit, hit_dist), FUNC_NULL},
{"%f", 3, "hit_point", offsetofarray(struct hit, hit_point), FUNC_NULL},
{"%f", 4, "hit_normal", offsetofarray(struct hit, hit_normal), FUNC_NULL},
{"%f", 3, "hit_vpriv", offsetofarray(struct hit, hit_vpriv), FUNC_NULL},
{"%x", 1, "hit_private", offsetof(struct hit, hit_private), FUNC_NULL},
{"%d", 1, "hit_surfno", offsetof(struct hit, hit_surfno), FUNC_NULL},
{"", 0, (char *)NULL,	  0,			  FUNC_NULL}
};

d43 2
a44 2
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid NMG, and if so, precompute various
d47 3
a49 3
 *  Returns -
 *  	0	NMG is OK
 *  	!0	Error in description
d51 2
a52 2
 *  Implicit return -
 *  	A struct nmg_specific is created, and it's address is stored in
d79 1
a79 1
	/* Get Bounding box of solid */
d108 1
a108 1
register CONST struct soltab *stp;
a116 14
/*
 *			P L O T _ R A Y _ F A C E
 */
static void
plot_ray_face(pt, dir, fu)
point_t pt;
vect_t dir;
struct faceuse *fu;
{
	FILE *fd;
	long *b;
	point_t pp;
	static int i=0;
	char name[32];
a117 2
	if ( ! (rt_g.NMG_debug & DEBUG_NMGRT) )
		return;
a118 19
	sprintf(name, "lee%0d.pl", i++);
	if ((fd = fopen(name, "w")) == (FILE *)NULL) {
		rt_log("plot_ray_face cannot open %s", name);
		rt_bomb("aborting");
	}


	b = (long *)rt_calloc( fu->s_p->r_p->m_p->maxindex, sizeof(long), "bit vec");

	nmg_pl_fu(fd, fu, b, 200, 200, 200);

	rt_free((char *)b, "bit vec");

	VSCALE(pp, dir, 1000.0);
	VADD2(pp, pt, pp);
	pdv_3line( fd, pt, pp );
}


a119 1004
 *	We know we've hit a wire.  Make the appropriate 0-length segment.
 *	The caller is responsible for removing the hit point from the hitlist.
 */
static int
wire_hit(e_p, seg_p, rp, a_hit)
struct edge	*e_p;
struct seg	*seg_p;
struct xray	*rp;
struct hitlist	*a_hit;
{
	vect_t eray;

	/* we've got a wire edge.
	 *
	 * Generate a normal for the edge which is perpendicular to
	 * the edge in the plane formed by the ray and the edge.
	 *
	 */

	bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
	bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));

	/* make the normal for the ray
	 *
	 * make ray of edge
	 */
	VSUB2(eray, e_p->eu_p->vu_p->v_p->vg_p->coord,
		e_p->eu_p->eumate_p->vu_p->v_p->vg_p->coord);
	
	/* make N perpendicular to ray and edge */
	VCROSS(seg_p->seg_in.hit_normal, rp->r_dir, eray);

	/* make N point toward ray origin in plane of ray and edge */
	VCROSS(seg_p->seg_in.hit_normal, eray,
		seg_p->seg_in.hit_normal);

	/* reverse normal for out-point */
	VREVERSE(seg_p->seg_out.hit_normal, seg_p->seg_in.hit_normal);

	return(2);
}

#define LEFT_MIN_ENTER	0
#define LEFT_MIN_EXIT	1
#define LEFT_MAX_ENTER	2
#define LEFT_MAX_EXIT	3
#define RIGHT_MIN_ENTER	4
#define RIGHT_MIN_EXIT	5
#define RIGHT_MAX_ENTER	6
#define RIGHT_MAX_EXIT	7


static void
sort_eus(prime_uses, e_p, tbl, rp, left_vect)
struct ef_data prime_uses[];
struct edge *e_p;
char tbl[];
struct xray *rp;
vect_t left_vect;
{
	struct ef_data tmp;
	struct face_g *fg_p;
	vect_t face_vect;
	vect_t edge_vect;
	vect_t edge_opp_vect;
	vect_t eu_vect;
	struct edgeuse *teu;

	if (rt_g.NMG_debug & DEBUG_NMGRT)
		rt_log("sort_eus\n");

	NMG_CK_EDGE(e_p);
	NMG_CK_EDGE_G(e_p->eg_p);


	VPRINT("ray_vect", rp->r_dir);

	VMOVE(edge_vect, e_p->eg_p->e_dir);
	VREVERSE(edge_opp_vect, e_p->eg_p->e_dir);
	VPRINT("edge_vect", edge_vect);

	/* compute the "left" vector  which is perpendicular to the edge
	 * and the ray
	 */
	VCROSS(left_vect, edge_vect, rp->r_dir);

	VPRINT("left_vect", left_vect);

	VUNITIZE(left_vect);

	/* compute the relevant dot products for each edge/face about
	 * this edge.
	 */
	tmp.eu = e_p->eu_p;
	do {
	    /* we only care about the 3-manifold edge uses */
		
	    if (NMG_MANIFOLDS(tbl, tmp.eu) & NMG_3MANIFOLD) {

		NMG_CK_LOOPUSE(tmp.eu->up.lu_p);
		NMG_CK_FACEUSE(tmp.eu->up.lu_p->up.fu_p);
		   NMG_CK_FACE(tmp.eu->up.lu_p->up.fu_p->f_p);
		 NMG_CK_FACE_G(tmp.eu->up.lu_p->up.fu_p->f_p->fg_p);

		fg_p = tmp.eu->up.lu_p->up.fu_p->f_p->fg_p;
	    	rt_log("\n");
		HPRINT("face_normal", fg_p->N);
	    	
	    	if (tmp.eu->up.lu_p->up.fu_p->orientation == OT_SAME)
	    		teu = tmp.eu;
	    	else
	    		teu = tmp.eu->eumate_p;

	    	VSUB2(eu_vect, teu->vu_p->v_p->vg_p->coord,
	    		teu->eumate_p->vu_p->v_p->vg_p->coord);

	    	if (VDOT(e_p->eg_p->e_dir, eu_vect) < 0) {
			VCROSS(face_vect, edge_opp_vect, fg_p->N);
	    	} else {
			VCROSS(face_vect, edge_vect, fg_p->N);
	    	}
		VUNITIZE(face_vect);

		VPRINT("face_vect", face_vect);

		/* figure out if this is one of the prime edgeuses */
		tmp.fdotr = VDOT(face_vect, rp->r_dir);
		tmp.fdotl = VDOT(face_vect, left_vect);
		tmp.ndotr = VDOT(fg_p->N,   rp->r_dir);

#define SAVE(a) prime_uses[a].fdotl = tmp.fdotl;	\
		prime_uses[a].fdotr = tmp.fdotr;	\
		prime_uses[a].ndotr = tmp.ndotr;	\
		prime_uses[a].eu = tmp.eu

	    	rt_structprint("tmp", ef_parsetab, (char *)&tmp);
	    	

		if (tmp.fdotl >= 0.0) {
			/* face is on "left" of ray */
			if ( tmp.ndotr > 0.0 ) {
				/* ray is "leaving" face */
				if (tmp.fdotr < prime_uses[LEFT_MIN_EXIT].fdotr) {
					SAVE(LEFT_MIN_EXIT);
				}
				if (tmp.fdotr > prime_uses[LEFT_MAX_EXIT].fdotr) {
					SAVE(LEFT_MAX_EXIT);
				}
			} else {
				/* ray is "entering" face */
				if (tmp.fdotr < prime_uses[LEFT_MIN_ENTER].fdotr) {
					SAVE(LEFT_MIN_ENTER);
				}
				if (tmp.fdotr > prime_uses[LEFT_MAX_ENTER].fdotr) {
					SAVE(LEFT_MAX_ENTER);
				}
			}
		} else {
			/* face is on "right" of ray */
			if ( tmp.ndotr > 0.0 ) {
				/* ray is "leaving face */
				if (tmp.fdotr < prime_uses[RIGHT_MIN_EXIT].fdotr) {
					SAVE(RIGHT_MIN_EXIT);
				}
				if (tmp.fdotr > prime_uses[RIGHT_MAX_EXIT].fdotr) {
					SAVE(RIGHT_MAX_EXIT);
				}
			} else {
				/* ray is "entering" face */
				if (tmp.fdotr < prime_uses[RIGHT_MIN_ENTER].fdotr) {
					SAVE(RIGHT_MIN_ENTER);
				}
				if (tmp.fdotr > prime_uses[RIGHT_MAX_ENTER].fdotr) {
					SAVE(RIGHT_MAX_ENTER);
				}
			}
		}
	    }
	    tmp.eu = tmp.eu->radial_p->eumate_p;

	} while (tmp.eu != e_p->eu_p);
}


static
v_neighborhood(v_p, tbl, rp)
struct vertex *v_p;
char		*tbl;
struct xray	*rp;
{

	NMG_CK_VERTEX(v_p);
	

}


/*
 *	if we hit a 3 manifold for seg_in we enter the solid
 *	if we hit a 3 manifold for seg_out we leave the solid
 *	if we hit a 0,1or2 manifold for seg_in, we enter/leave the solid.
 *	if we hit a 0,1or2 manifold for seg_out, we ignore it.
 */
static int
vertex_hit(v_p, seg_p, rp, tbl, a_hit, filled)
struct vertex	*v_p;
struct seg	*seg_p;
struct xray	*rp;
char		*tbl;
struct hitlist	*a_hit;
int		filled;
{
	char manifolds = NMG_MANIFOLDS(tbl, v_p);
	struct faceuse *fu_p;
	struct vertexuse *vu_p;
	int entries = 0;
	int exits = 0;
	vect_t	saved_normal;
	fastf_t BestRdotN = 5.0;
	fastf_t RdotN;
	struct face_g *fg;

	if (manifolds & NMG_3MANIFOLD) {

		for (RT_LIST_FOR(vu_p, vertexuse, &v_p->vu_hd)) {
			if (NMG_MANIFOLDS(tbl, vu_p) & NMG_3MANIFOLD ||
			    NMG_MANIFOLDS(tbl, vu_p) & NMG_2MANIFOLD) {

				switch (*vu_p->up.magic_p) {
				case NMG_EDGEUSE_MAGIC:
					NMG_CK_LOOPUSE(vu_p->up.eu_p->up.lu_p);
					NMG_CK_FACEUSE(vu_p->up.eu_p->up.lu_p->up.fu_p);
					   NMG_CK_FACE(vu_p->up.eu_p->up.lu_p->up.fu_p->f_p);
					 NMG_CK_FACE_G(vu_p->up.eu_p->up.lu_p->up.fu_p->f_p->fg_p);
					fg = vu_p->up.eu_p->up.lu_p->up.fu_p->f_p->fg_p;

					break;
				case NMG_LOOPUSE_MAGIC:
					NMG_CK_FACEUSE(vu_p->up.eu_p->up.lu_p->up.fu_p);
					NMG_CK_FACE(vu_p->up.eu_p->up.lu_p->up.fu_p->f_p);
					NMG_CK_FACE_G(vu_p->up.eu_p->up.lu_p->up.fu_p->f_p->fg_p);
					fg = vu_p->up.eu_p->up.lu_p->up.fu_p->f_p->fg_p;
					break;
				}

				if ((RdotN = VDOT(rp->r_dir, fg->N)) < 0) {
			    		entries++;
					if (-1.0 * RdotN < BestRdotN) {
						BestRdotN = fabs(RdotN);
						VMOVE(saved_normal, fg->N);
					}
				} else {
					exits++;
					if (RdotN < BestRdotN) {
						BestRdotN = fabs(RdotN);
						VMOVE(saved_normal, fg->N);
					}
				}
			}
		}

		if (entries && !exits && filled == 0) {
			/* single in-bound hit */
			bcopy(&a_hit->hit, &seg_p->seg_in,sizeof(struct hit));
			VMOVE(seg_p->seg_in.hit_normal, saved_normal);
			filled++;
		} else if (exits && !entries && filled) {
			/* single out-bound hit */
			bcopy(&a_hit->hit, &seg_p->seg_in,sizeof(struct hit));
			VMOVE(seg_p->seg_in.hit_normal, saved_normal);
			filled++;
		}else {

			/* there are both faces which the ray "enters" and
			 * faces which it "exits" at this vertex  We have
			 * to determine what is really happening here.
			 */
			v_neighborhood(v_p, tbl, rp);
		}

		RT_LIST_DEQUEUE(&a_hit->l);
		rt_free((char *)a_hit, "freeing hitpoint");

	} else if (manifolds & NMG_2MANIFOLD) {
	    /* we've hit the corner of a dangling face */
	    if (filled == 0) {
	    	register int found=0;

	    	/* find a surface normal */
	    	for (RT_LIST_FOR(vu_p, vertexuse, &v_p->vu_hd)) {

	    		if (NMG_MANIFOLDS(tbl, vu_p) & NMG_2MANIFOLD &&
	    		    !(NMG_MANIFOLDS(tbl, vu_p) & NMG_3MANIFOLD) ) {
	    		    	found = 1; break;
	    		}
	    	}
	    	
		bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));

	    	if (found) {
		    	/* we've found a 2manifold vertexuse.
		    	 * get a pointer to the faceuse and get the
		    	 * normal from the face
		    	 */

		    	if (*vu_p->up.magic_p == NMG_EDGEUSE_MAGIC)
		    		fu_p = vu_p->up.eu_p->up.lu_p->up.fu_p;
		    	else if (*vu_p->up.magic_p == NMG_LOOPUSE_MAGIC)
		    		fu_p = vu_p->up.lu_p->up.fu_p;
	    		else  {
	    			fu_p = (struct faceuse *)NULL;
	    			rt_bomb("vertex_hit: bad vu->up\n");
	    			/* NOTREACHED */
	    		}

		    	if (VDOT(fu_p->f_p->fg_p->N, rp->r_dir) > 0.0) {
				VREVERSE(seg_p->seg_in.hit_normal,
					fu_p->f_p->fg_p->N);
				VMOVE(seg_p->seg_out.hit_normal,
					fu_p->f_p->fg_p->N);
		    	} else {
				VMOVE(seg_p->seg_in.hit_normal,
					fu_p->f_p->fg_p->N);
				VREVERSE(seg_p->seg_out.hit_normal,
					fu_p->f_p->fg_p->N);
		    	}

		} else {
	    		/* we didn't find a face.  How did this happen? */
	    		rt_log("2manifold lone vertex?\n");
			VREVERSE(seg_p->seg_in.hit_normal, rp->r_dir);
			VMOVE(seg_p->seg_out.hit_normal, rp->r_dir);

			filled = 2;
	    	}
	    }
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");

	} else if (manifolds & NMG_1MANIFOLD) {
	    /* we've hit the end of a wire.
	     * this is the same as for hitting a wire.
	     */
	    if (filled == 0) {
	    	/* go looking for a wire edge */
		for (RT_LIST_FOR(vu_p, vertexuse, &v_p->vu_hd)) {
		    /* if we find an edge which is only a 1 manifold
		     * we'll call edge_hit with it
		     */
		    if (*vu_p->up.magic_p == NMG_EDGEUSE_MAGIC &&
			! (NMG_MANIFOLDS(tbl, vu_p->up.eu_p->e_p) &
			(NMG_3MANIFOLD|NMG_2MANIFOLD)) &&
			(NMG_MANIFOLDS(tbl, vu_p->up.eu_p->e_p) &
			NMG_1MANIFOLD) ) {
			    filled = wire_hit(vu_p->up.eu_p->e_p,
			    			seg_p, rp, a_hit);
			    			
			    break;
		    }
		}
	    	if (filled == 0) {
	    		/* we didn't find an edge.  How did this happen? */
	    		rt_log("1manifold lone vertex?\n");
			bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
			bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));
			VREVERSE(seg_p->seg_in.hit_normal, rp->r_dir);
			VMOVE(seg_p->seg_out.hit_normal, rp->r_dir);

			filled = 2;
	    	}
	    }
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");

	} else if (manifolds & NMG_0MANIFOLD ) {
	    if (filled == 0) {
		/* we've hit a lone vertex */
		bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));
		VREVERSE(seg_p->seg_in.hit_normal, rp->r_dir);
		VMOVE(seg_p->seg_out.hit_normal, rp->r_dir);

		filled = 2;
	    }
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");
	}
	return(filled);
}



/*
 *	Fill in a seg struct to reflect a grazing hit of a solid on an
 *	edge.
 *
 *	^  /___
 *	| /____
 *	|/_____
 *	o______
 *	|\_____
 *	| \____
 *	|  \___
 */
static void
edge_ray_graze(a_hit, seg_p, i_u, in, out, s)
struct seg	*seg_p;
struct hitlist	*a_hit;
struct ef_data i_u[8];	/* "important" uses of edge */
int in, out;
char *s;
{
	if (rt_g.NMG_debug & DEBUG_NMGRT)
		rt_log("edge_ray_graze(%s)\n", s);

	bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
	bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));
				
	VMOVE(seg_p->seg_in.hit_normal,
		i_u[in].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
	    			
	VMOVE(seg_p->seg_out.hit_normal,
		i_u[out].eu->up.lu_p->up.fu_p->f_p->fg_p->N);

	RT_LIST_DEQUEUE(&a_hit->l);
	rt_free((char *)a_hit, "freeing hitpoint");
}
/*
 *	Fill in a seg struct to reflect entering a solid at a point
 *	on the edge.
 */
static void
edge_enter_solid(a_hit, seg_p, i_u)
struct seg	*seg_p;
struct hitlist	*a_hit;
struct ef_data *i_u;	/* "important" uses of edge */
{
	if (rt_g.NMG_debug & DEBUG_NMGRT)
		rt_log("edge_enter_solid()\n");
	/* we enter solid, normal from face
	 * with most anti-rayward normal
	 *
	 *	____ ______
	 *      ____^______
	 *      ____|______
    	 *	____o______
	 *	___/|\_____
	 *	__/ | \____
	 *	_/  |  \___
	 */

		if (rt_g.NMG_debug & DEBUG_NMGRT) {
			rt_log("edge_enter_solid w/ ray_hit_distance %g (%g %g %g)",
				a_hit->hit.hit_dist,
				a_hit->hit.hit_point[0],
				a_hit->hit.hit_point[1],
				a_hit->hit.hit_point[2]);

			switch ( *(int*)a_hit->hit.hit_private) {
			case NMG_FACE_MAGIC: rt_log("\tface\n"); break;
			case NMG_EDGE_MAGIC: rt_log("\tedge\n"); break;
			case NMG_VERTEX_MAGIC: rt_log("\tvertex\n"); break;
			default : rt_log(" hit unknown magic (%d)\n", 
				*(int*)a_hit->hit.hit_private); break;
			}
		}

	bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));

	if (i_u[LEFT_MIN_ENTER].ndotr < i_u[RIGHT_MIN_ENTER].ndotr) {
		VMOVE(seg_p->seg_in.hit_normal,
		    i_u[LEFT_MIN_ENTER].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
	} else {
		VMOVE(seg_p->seg_in.hit_normal,
		    i_u[RIGHT_MIN_ENTER].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
	}

	RT_LIST_DEQUEUE(&a_hit->l);
	rt_free((char *)a_hit, "freeing hitpoint");
}



/*
 *	Fill in seg struct to reflect hitting an edge & exiting solid
 *	at same point on edge
 */
static void
edge_zero_depth_hit(a_hit, seg_p, i_u)
struct seg	*seg_p;
struct hitlist	*a_hit;
struct ef_data *i_u;	/* "important" uses of edge */
{
	if (rt_g.NMG_debug & DEBUG_NMGRT)
		rt_log("edge_zero_depth_hit()\n");
	/* zero depth hit
    	 *
	 *	_\  ^  /___
	 *	__\ | /____
	 *	___\|/_____
    	 *	____o______
	 *	___/|\_____
	 *	__/ | \____
	 *	_/  |  \___
	 */
	bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
	bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));

    	/* choose an entry hit normal */
	if (i_u[LEFT_MIN_ENTER].ndotr < i_u[RIGHT_MIN_ENTER].ndotr) {
		VMOVE(seg_p->seg_in.hit_normal,
		    i_u[LEFT_MIN_ENTER].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
	} else {
		VMOVE(seg_p->seg_in.hit_normal,
		    i_u[RIGHT_MIN_ENTER].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
	}

    	/* choose an exit hit normal */
	if (i_u[LEFT_MIN_EXIT].ndotr > i_u[RIGHT_MIN_EXIT].ndotr) {
		VMOVE(seg_p->seg_out.hit_normal,
		    i_u[LEFT_MIN_EXIT].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
	} else {
		VMOVE(seg_p->seg_out.hit_normal,
		    i_u[RIGHT_MIN_EXIT].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
	}
	RT_LIST_DEQUEUE(&a_hit->l);
	rt_free((char *)a_hit, "freeing hitpoint");
}

/*
 *	Fill in seg structure to reflect that the ray leaves the solid at
 *	this hit location.
 */
static void
edge_leave_solid(a_hit, seg_p, i_u)
struct seg	*seg_p;
struct hitlist	*a_hit;
struct ef_data *i_u;	/* "important" uses of edge */
{
	if (rt_g.NMG_debug & DEBUG_NMGRT)
		rt_log("edge_leave_solid()\n");
	/* leave solid
	*
	* 	   ^
	*	   |
	*	   o
	*	  /|\
	*	 /_|_\
	*	/__|__\
	*          |
	*/

	bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));

	/* pick an exit normal */
	if (i_u[LEFT_MIN_EXIT].ndotr > i_u[RIGHT_MIN_EXIT].ndotr) {
		VMOVE(seg_p->seg_out.hit_normal,
			i_u[LEFT_MIN_EXIT].eu->up.lu_p->up.fu_p->f_p->fg_p->N);

	} else {
		VMOVE(seg_p->seg_out.hit_normal,
			i_u[RIGHT_MIN_EXIT].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
	}

	RT_LIST_DEQUEUE(&a_hit->l);
	rt_free((char *)a_hit, "freeing hitpoint");
}

static void
edge_confusion(a_hit, i_u, file, line)
struct hitlist	*a_hit;
struct ef_data i_u[8];	/* "important" uses of edge */
char *file;
int line;
{
	if (file)
		rt_log("edge_hit() in %s at %d is confused\n", file, line);

	rt_structprint("LEFT_MIN_ENTER", ef_parsetab,
		(char *)&i_u[LEFT_MIN_ENTER]);
	rt_structprint("LEFT_MIN_EXIT", ef_parsetab,
		(char *)&i_u[LEFT_MIN_EXIT]);
	rt_structprint("LEFT_MAX_ENTER", ef_parsetab,
		(char *)&i_u[LEFT_MAX_ENTER]);
	rt_structprint("LEFT_MAX_EXIT", ef_parsetab,
		(char *)&i_u[LEFT_MAX_EXIT]);
	rt_structprint("RIGHT_MIN_ENTER", ef_parsetab,
		(char *)&i_u[RIGHT_MIN_ENTER]);
	rt_structprint("RIGHT_MIN_EXIT", ef_parsetab,
		(char *)&i_u[RIGHT_MIN_EXIT]);
	rt_structprint("RIGHT_MAX_ENTER", ef_parsetab,
		(char *)&i_u[RIGHT_MAX_ENTER]);
	rt_structprint("RIGHT_MAX_EXIT", ef_parsetab,
		(char *)&i_u[RIGHT_MAX_EXIT]);

}

/*
 *	if we hit a 3 manifold for seg_in we enter the solid
 *	if we hit a 3 manifold for seg_out we leave the solid
 *	if we hit a 1or2 manifold for seg_in, we enter/leave the solid.
 *	if we hit a 1or2 manifold for seg_out, we ignore it.
 */
static int
edge_hit(e_p, seg_p, rp, tbl, a_hit, filled)
struct edge	*e_p;
struct seg	*seg_p;
struct xray	*rp;
char		*tbl;
struct hitlist	*a_hit;
int		filled;
{
	struct edgeuse *eu_p;
	char manifolds = NMG_MANIFOLDS(tbl, e_p);
	
	if (rt_g.NMG_debug & DEBUG_NMGRT)
	    	rt_log("edge_hit()\n");

	if (manifolds & NMG_3MANIFOLD) {
	
	    /* if the ray enters or leaves the solid via an edge, it is at
	     * the juncture of exactly two faces.  To determine which two
	     * faces, it is necessary to sort the faces about this edge
	     * radially about the edge.
	     *
	     * Taking the cross product of an edgeuse vector and the face
	     * normal, we get a pointer "into" and "along the surface" of
	     * the face.  We enter the solid between the two faces for which
	     * these "face vectors" are most anti-ray-ward and whose surface
	     * normals have an anti-ray-ward component.  There must
	     * be such a face on each "side" of the edge to enter or leave
	     * the solid at this edge.
	     *
	     * Likewise, we leave the solid between the two faces for which
	     * the "face vectors" are most ray-ward and whose surface normals
	     * have a ray-ward component.
	     *
	     * To differentiate sidedness, we cross the ray with an edge
	     * vector to get a vector perpendicular to the edge and the ray.
	     * this vector is said to point "left" of the ray wrt the edge.
	     *
	     *		 	^  _
	     *			|  /|
	     *			| /
	     *			|/
	     *	 "left"	<-------/
	     *		       /|
	     *		      / |
	     *		     /  |
	     *		   ray  edge
	     *
	     *
	     * If we are found to be entering the solid at an edge, we leave
	     * it again at the edge if there is a pair of "exit" faces
	     * (faces on each side of the ray/edge with ray-ward pointing
	     * "face vectors")
	     * "behind" the entry faces.  Likewise, a ray leaving a solid at
	     * an edge may re-enter the solid at the edge if there are a
	     * pair of "entry" faces "behind" the exit faces.
	     */
	    vect_t left_vect;
	    struct ef_data i_u[8];	/* "important" uses of edge */
	    register int i;

	    /*
	     * First we "sort" the faces to find the "important" ones.
	     */

	    bzero(i_u, sizeof(i_u));

	    i_u[LEFT_MIN_ENTER].fdotr = 2.0;
	    i_u[LEFT_MAX_ENTER].fdotr = -2.0;
	    i_u[LEFT_MIN_EXIT].fdotr = 2.0;
	    i_u[LEFT_MAX_EXIT].fdotr = -2.0;

	    i_u[RIGHT_MIN_ENTER].fdotr = 2.0;
	    i_u[RIGHT_MAX_ENTER].fdotr = -2.0;
	    i_u[RIGHT_MIN_EXIT].fdotr = 2.0;
	    i_u[RIGHT_MAX_EXIT].fdotr = -2.0;

	    sort_eus(i_u, e_p, tbl, rp, left_vect);

	    if (rt_g.NMG_debug & DEBUG_NMGRT) {
	    	rt_log("\nedge_hit 3MANIFOLD\n");
	    	edge_confusion(a_hit, i_u, (char *)NULL, 0);
	    }

	    /* now find the two faces we're looking for */
	    if (filled) {
	    	/* we're looking for an exit (then entry) point */

	    	if (i_u[LEFT_MIN_EXIT].eu) {
	    		if (i_u[RIGHT_MIN_EXIT].eu) {
	    			if (i_u[LEFT_MAX_ENTER].eu !=
	    			    i_u[LEFT_MIN_ENTER].eu &&
	    			    i_u[RIGHT_MAX_ENTER].eu !=
	    			    i_u[RIGHT_MIN_ENTER].eu ){

	    			    	/* leave & re-enter solid */

					if (rt_g.NMG_debug & DEBUG_NMGRT)
						rt_log("edge_hit leave&re-enter\n");

					RT_LIST_DEQUEUE(&a_hit->l);
					rt_free((char *)a_hit,
						"freeing hitpoint");

	    			} else {
	    				/* leave solid */
	    				edge_leave_solid(a_hit, seg_p, i_u);
	    				filled++;
	    			}
	    		} else if (i_u[LEFT_MAX_ENTER].eu){
	    			/* graze exterior of solid on left */

				RT_LIST_DEQUEUE(&a_hit->l);
				rt_free((char *)a_hit, "freeing hitpoint");

				if (rt_g.NMG_debug & DEBUG_NMGRT)
					rt_log("edge_hit graze exterior on left\n");
	    		} else {
	    			/* What's going on? */

	    			edge_confusion(a_hit, i_u, __FILE__, __LINE__);
				rt_bomb("goodbye\n");

				RT_LIST_DEQUEUE(&a_hit->l);
				rt_free((char *)a_hit, "freeing hitpoint");
	    		}
	    	} else if (i_u[RIGHT_MIN_EXIT].eu &&
		    i_u[RIGHT_MAX_ENTER].eu != i_u[RIGHT_MIN_EXIT].eu) {

	    		/* grazing exterior of solid on right */
			if (rt_g.NMG_debug & DEBUG_NMGRT)
				rt_log("edge_hit graze exterior on right\n");
			RT_LIST_DEQUEUE(&a_hit->l);
			rt_free((char *)a_hit, "freeing hitpoint");
	    	} else {
	    		/* What's going on? */
    			edge_confusion(a_hit, i_u, __FILE__, __LINE__);
			rt_bomb("goodbye\n");

			RT_LIST_DEQUEUE(&a_hit->l);
			rt_free((char *)a_hit, "freeing hitpoint");
	    	}

	    } else if (i_u[LEFT_MIN_ENTER].eu) /* filled == 0 */ {
	    	/* we're looking for an entry (then exit) point on the 
	    	 * solid at this point.
		 */

		if (i_u[RIGHT_MIN_ENTER].eu) {
			if (i_u[LEFT_MAX_ENTER].eu !=
			    i_u[LEFT_MIN_ENTER].eu &&
			    i_u[RIGHT_MAX_ENTER].eu != 
			    i_u[RIGHT_MIN_ENTER].eu ) {
				edge_zero_depth_hit(a_hit, seg_p, i_u);
    				filled = 2;
			} else {
				edge_enter_solid(a_hit, seg_p, i_u);
    				filled = 1;
				rt_log("added %d to segment: ", filled);
				rt_pr_seg(seg_p);
			}
		} else if (i_u[LEFT_MAX_EXIT].eu &&
	    		i_u[LEFT_MAX_EXIT].eu !=
	    		i_u[LEFT_MAX_ENTER].eu) {

			/* grazing hit on solid to left
			 *
			 *	__\ ^
			 *	___\|
			 *	____o
			 *	___/|
			 *	__/ |
			 */
			edge_ray_graze(a_hit, seg_p, i_u,
					LEFT_MIN_ENTER, LEFT_MAX_EXIT, "left");
			filled = 2;
		} else {
	    		/* How did I get here? */
    			edge_confusion(a_hit, i_u, __FILE__, __LINE__);
			rt_bomb("goodbye\n");

			RT_LIST_DEQUEUE(&a_hit->l);
			rt_free((char *)a_hit, "freeing hitpoint");
		}
	    } else if (i_u[RIGHT_MIN_ENTER].eu &&
			i_u[RIGHT_MAX_EXIT].eu !=
			i_u[RIGHT_MIN_ENTER].eu) {
    			/* grazing hit on solid to right
		   	 *
			 *	^ /____
			 *	|/_____
		    	 *	o______
			 *	|\_____
			 *	| \____
    		    	 */
			edge_ray_graze(a_hit, seg_p, i_u,
				RIGHT_MIN_ENTER, RIGHT_MAX_EXIT, "right");
			filled = 2;
	    } else {
    			/* How did this happen? */
    			edge_confusion(a_hit, i_u, __FILE__, __LINE__);
			rt_bomb("goodbye\n");

			RT_LIST_DEQUEUE(&a_hit->l);
			rt_free((char *)a_hit, "freeing hitpoint");
	    }

	} else if (manifolds & NMG_2MANIFOLD) {
	    if (filled == 0) {
	    	/* hit a 2-manifold in space ( dangling face ) */

		bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));

	    	eu_p = e_p->eu_p;

	    	/* go looking for a use of this edge in a 2-Manifold */

	    	while ( ! (NMG_MANIFOLDS(tbl, eu_p) & NMG_2MANIFOLD) &&
		    eu_p->radial_p->eumate_p != e_p->eu_p)
			eu_p = eu_p->radial_p->eumate_p;

	    	if (NMG_MANIFOLDS(tbl, eu_p) & NMG_2MANIFOLD ) {
	    		fastf_t *normal =
	    			&eu_p->up.lu_p->up.fu_p->f_p->fg_p->N[0];

		    	if (VDOT(normal, rp->r_dir) > 0.0) {
		    		VMOVE(seg_p->seg_out.hit_normal, normal);
		    		VREVERSE(seg_p->seg_in.hit_normal, normal);
		    	} else {
				VMOVE(seg_p->seg_in.hit_normal, normal);
		    		VREVERSE(seg_p->seg_out.hit_normal, normal);
		    	}
	    	}
	    	
	    }
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");

	} else if (manifolds & NMG_1MANIFOLD) {
	    if (filled == 0) {
		filled = wire_hit(e_p, seg_p, rp, a_hit);
	    }
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");
	}
	return(filled);
}

/*
 *	if we hit a 3 manifold face for seg_in, we're entering a solid
 *	if we hit a 3 manifold face for seg_out, we're leaving a solid
 *	if we hit a 2 manifold face for seg_in, we're entering/leaving a solid
 *	if we hit a 2 manifold face for seg_out, it's ignored
 */
static int
face_hit(f_p, seg_p, rp, tbl, a_hit, filled)
struct face	*f_p;
struct seg	*seg_p;
struct xray	*rp;
char		*tbl;
struct hitlist	*a_hit;
int		filled;
{
	char manifolds = NMG_MANIFOLDS(tbl, f_p);

	RT_CK_SEG(seg_p);

	if (manifolds & NMG_3MANIFOLD) {
		if (filled == 0) {
			/* entering solid */
			bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
			VMOVE(seg_p->seg_in.hit_normal, f_p->fg_p->N);
			filled = 1;
		} else {
			/* leaving solid */
			bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));
			VMOVE(seg_p->seg_out.hit_normal, f_p->fg_p->N);
			filled = 2;
		}

		if (rt_g.NMG_debug & DEBUG_NMGRT) {
			rt_log("added %d to segment: ", filled);
			rt_pr_seg(seg_p);
		}

	} else if (filled == 0) {
		/* just hit an exterior dangling face */

		bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));
		if (VDOT(f_p->fg_p->N, rp->r_dir) <= 0.0) {
			/* face normal points back along ray */
			VMOVE(seg_p->seg_in.hit_normal, f_p->fg_p->N);
			VMOVE(seg_p->seg_out.hit_normal, f_p->fg_p->N);
		} else {
			VREVERSE(seg_p->seg_in.hit_normal, f_p->fg_p->N);
			VREVERSE(seg_p->seg_out.hit_normal, f_p->fg_p->N);
		}

		filled = 2;
		if (rt_g.NMG_debug & DEBUG_NMGRT) {
			rt_log("added %d to segment: ", filled);
			rt_pr_seg(seg_p);
		}
	}

	RT_LIST_DEQUEUE(&a_hit->l);
	rt_free((char *)a_hit, "freeing hitpoint");

	return(filled);
}


static int
build_segs(hl, ap, nmg_spec, seghead, rp, stp)
struct hitlist		*hl;
struct application	*ap;
struct nmg_specific	*nmg_spec;
struct seg		*seghead;	/* intersection w/ ray */
register struct xray	*rp;	/* info about the ray */
struct soltab		*stp;
{
	struct seg *seg_p;
	int seg_count=0;
	struct hitlist *a_hit;
	char *tbl;
	int hits_filled;

	tbl = nmg_spec->nmg_model->manifolds;

	/* build up the list of segments based upon the hit points.
	 */

	while (RT_LIST_NON_EMPTY(&hl->l) ) {
	    RT_GET_SEG(seg_p, ap->a_resource);

	    RT_CK_SEG(seg_p);

	    seg_p->seg_stp = stp;

	    hits_filled = 0;

	    while (hits_filled < 2 ) {
	    	if (RT_LIST_IS_EMPTY(&hl->l) && hits_filled > 0)
	    		rt_bomb("Infinite NMG?");
	    	
		a_hit = RT_LIST_FIRST(hitlist, &hl->l);

		if (rt_g.NMG_debug & DEBUG_NMGRT) {
			rt_log("build_seg w/ ray_hit_distance %g (%g %g %g)",
				a_hit->hit.hit_dist,
				a_hit->hit.hit_point[0],
				a_hit->hit.hit_point[1],
				a_hit->hit.hit_point[2]);

			switch ( *(int*)a_hit->hit.hit_private) {
			case NMG_FACE_MAGIC: rt_log("\tface\n"); break;
			case NMG_EDGE_MAGIC: rt_log("\tedge\n"); break;
			case NMG_VERTEX_MAGIC: rt_log("\tvertex\n"); break;
			default : rt_log(" hit unknown magic (%d)\n", 
				*(int*)a_hit->hit.hit_private); break;
			}
		}

		switch (*(int *)a_hit->hit.hit_private) {
		case NMG_VERTEX_MAGIC:
			hits_filled = vertex_hit(
			(struct vertex *)a_hit->hit.hit_private,
			seg_p, rp, tbl, a_hit, hits_filled);
			break;
		case NMG_EDGE_MAGIC:
			hits_filled = edge_hit(
			(struct edge *)a_hit->hit.hit_private,
			seg_p, rp, tbl, a_hit, hits_filled);
			break;
		case NMG_FACE_MAGIC:
			hits_filled = face_hit(
			(struct face *)a_hit->hit.hit_private,
			seg_p, rp, tbl, a_hit, hits_filled);
			break;
		default: rt_log("bogus topology hit?\n"); abort();
			break;
		}
	    }


	    ++seg_count;
	    if (rt_g.NMG_debug & DEBUG_NMGRT) {
	    	rt_log("adding segment %d to seg list\n", seg_count);
		rt_pr_seg(seg_p);
	    }

	    RT_LIST_INSERT(&(seghead->l), &(seg_p->l) );
	}
	return(seg_count);
}


/*
a138 3
	struct hitlist *hl, *a_hit, *nmg_isect_ray();
	struct seg *seg_p;
	int seg_count=0;
d170 1
a170 56
	hl = nmg_isect_ray(rp, nmg->nmg_invdir, nmg->nmg_model, &ap->a_rt_i->rti_tol);

	if (! hl || RT_LIST_IS_EMPTY(&hl->l)) {
		if (rt_g.NMG_debug & DEBUG_NMGRT)
			rt_log("ray missed NMG\n");
		return(0);			/* MISS */
	}

	if (rt_g.NMG_debug & DEBUG_NMGRT) {
		rt_log("\nsorted nmg/ray hit list\n");
		for (RT_LIST_FOR(a_hit, hitlist, &hl->l)) {
			rt_log("ray_hit_distance %g (%g %g %g)",
				a_hit->hit.hit_dist,
				a_hit->hit.hit_point[0],
				a_hit->hit.hit_point[1],
				a_hit->hit.hit_point[2]);

			switch ( *(int*)a_hit->hit.hit_private) {
			case NMG_FACE_MAGIC: rt_log("\tface\n"); break;
			case NMG_EDGE_MAGIC: rt_log("\tedge\n"); break;
			case NMG_VERTEX_MAGIC: rt_log("\tvertex\n"); break;
			default : rt_log(" hit unknown magic (%d)\n", 
				*(int*)a_hit->hit.hit_private); break;
			}
		}
	}

	seg_count = build_segs(hl, ap, nmg, seghead, rp, stp);
	
	if (!(rt_g.NMG_debug & DEBUG_NMGRT))
		return(seg_count);

	/* print debugging data before returning */
	rt_log("segment list (%d)\n", seg_count);
	for (RT_LIST_FOR(seg_p, seg, &seghead->l) ) {
		rt_log("dist %g  pt(%g,%g,%g)  N(%g,%g,%g)  =>  ",
		seg_p->seg_in.hit_dist,
		seg_p->seg_in.hit_point[0],
		seg_p->seg_in.hit_point[1],
		seg_p->seg_in.hit_point[2],
		seg_p->seg_in.hit_normal[0],
		seg_p->seg_in.hit_normal[1],
		seg_p->seg_in.hit_normal[2]);
		rt_log("dist %g  pt(%g,%g,%g)  N(%g,%g,%g)\n",
		seg_p->seg_out.hit_dist,
		seg_p->seg_out.hit_point[0],
		seg_p->seg_out.hit_point[1],
		seg_p->seg_out.hit_point[2],
		seg_p->seg_out.hit_normal[0],
		seg_p->seg_out.hit_normal[1],
		seg_p->seg_out.hit_normal[2]);
	}

	rt_log("returning\n");

	return(seg_count);
a269 11
/*
 *			N M G _ M _ T O _ V L I S T
 * XXX move to nmg_plot.c
 */
void
nmg_m_to_vlist( vhead, m, poly_markers )
struct rt_list	*vhead;
struct model	*m;
int		poly_markers;
{
	register struct region	*r;
a270 7
	NMG_CK_MODEL( m );
	for( RT_LIST_FOR( r, region, &m->r_hd ) )  {
		NMG_CK_REGION( r );
		nmg_r_to_vlist( vhead, r, poly_markers );
	}
}

d279 1
a279 1
struct rt_tol		*tol;
d305 1
a305 1
struct rt_tol		*tol;
@


10.8
log
@Decided to fix ../h/db.h instead of args to plong/glong
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.7 92/11/10 22:54:26 mike Exp Locker: mike $ (BRL)";
a2490 1
			INDEXL_HD( d, vu, l, vu->l );
d2495 1
@


10.7
log
@Tightened up types on rt_plong and rt_glong.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.6 92/11/02 15:33:22 mike Exp Locker: mike $ (BRL)";
d2805 1
a2805 1
		kind_counts[kind] = rt_glong( (unsigned char *) rp->nmg.N_structs+4*kind );
d2988 1
a2988 1
	(void)rt_plong( (unsigned char *)rp->nmg.N_count, additional_grans );
d2992 1
a2992 1
		(void)rt_plong( (unsigned char *)rp->nmg.N_structs+4*kind, kind_counts[kind] );
@


10.6
log
@Fix to args of bcopy(), noticed by Chris Johnson.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.5 92/11/02 15:32:02 mike Exp Locker: mike $ (BRL)";
d1518 1
a1518 1
typedef	char		index_t[4];
d1526 1
a1526 1
	char			magic[4];
d1533 1
a1533 1
	char			magic[4];
d1538 1
a1538 1
	char			magic[4];
d1547 3
a1549 3
	char			magic[4];
	char			min_pt[3*8];
	char			max_pt[3*8];
d1554 1
a1554 1
	char			magic[4];
d1566 3
a1568 3
	char			magic[4];
	char			min_pt[3*8];
	char			max_pt[3*8];
d1573 1
a1573 1
	char			magic[4];
d1580 2
a1581 2
	char			magic[4];
	char			N[4*8];
d1590 1
a1590 1
	char			magic[4];
d1594 1
a1594 1
	char			orientation[4];
d1602 1
a1602 1
	char			magic[4];
d1607 1
a1607 1
	char			magic[4];
d1614 3
a1616 3
	char			magic[4];
	char			min_pt[3*8];
	char			max_pt[3*8];
d1621 1
a1621 1
	char			magic[4];
d1625 1
a1625 1
	char			orientation[4];
d1633 1
a1633 1
	char			magic[4];
d1638 1
a1638 1
	char			magic[4];
d1641 1
a1641 1
	char			is_real[4];
d1646 4
a1649 4
	char			magic[4];
	char			usage[4];
	char			e_pt[3*8];
	char			e_dir[3*8];
d1654 1
a1654 1
	char			magic[4];
d1661 1
a1661 1
	char	  		orientation[4];
d1667 1
a1667 1
	char			magic[4];
d1672 1
a1672 1
	char			magic[4];
d1679 2
a1680 2
	char			magic[4];
	char			coord[3*8];
d1685 1
a1685 1
	char			magic[4];
d1694 2
a1695 2
	char			magic[4];
	char			N[3*8];
d1880 1
a1880 1
	(void)rt_plong((o)->elem, rt_nmg_reindex((genptr_t)((i)->elem), ecnt))
d1886 1
d1911 1
a1911 1
			rt_plong( d->magic, DISK_MODEL_MAGIC );
d1922 1
a1922 1
			rt_plong( d->magic, DISK_MODEL_A_MAGIC );
d1931 1
a1931 1
			rt_plong( d->magic, DISK_REGION_MAGIC );
d1945 1
a1945 1
			rt_plong( d->magic, DISK_REGION_A_MAGIC );
d1958 1
a1958 1
			rt_plong( d->magic, DISK_SHELL_MAGIC );
d1975 1
a1975 1
			rt_plong( d->magic, DISK_SHELL_A_MAGIC );
d1991 1
a1991 1
			rt_plong( d->magic, DISK_FACEUSE_MAGIC );
d2007 1
a2007 1
			rt_plong( d->magic, DISK_FACEUSE_A_MAGIC );
d2016 1
a2016 1
			rt_plong( d->magic, DISK_FACE_MAGIC );
d2028 1
a2028 1
			rt_plong( d->magic, DISK_FACE_G_MAGIC );
d2040 1
a2040 1
			rt_plong( d->magic, DISK_LOOPUSE_MAGIC );
d2056 1
a2056 1
			rt_plong( d->magic, DISK_LOOPUSE_A_MAGIC );
d2065 1
a2065 1
			rt_plong( d->magic, DISK_LOOP_MAGIC );
d2077 1
a2077 1
			rt_plong( d->magic, DISK_LOOP_G_MAGIC );
d2090 1
a2090 1
			rt_plong( d->magic, DISK_EDGEUSE_MAGIC );
d2107 1
a2107 1
			rt_plong( d->magic, DISK_EDGEUSE_A_MAGIC );
d2116 1
a2116 1
			rt_plong( d->magic, DISK_EDGE_MAGIC );
d2128 1
a2128 1
			rt_plong( d->magic, DISK_EDGE_G_MAGIC );
d2140 1
a2140 1
			rt_plong( d->magic, DISK_VERTEXUSE_MAGIC );
d2154 1
a2154 1
			rt_plong( d->magic, DISK_VERTEXUSE_A_MAGIC );
d2166 1
a2166 1
			rt_plong( d->magic, DISK_VERTEX_MAGIC );
d2178 1
a2178 1
			rt_plong( d->magic, DISK_VERTEX_G_MAGIC );
d2805 1
a2805 1
		kind_counts[kind] = rt_glong( rp->nmg.N_structs+4*kind );
d2988 1
a2988 1
	(void)rt_plong( rp->nmg.N_count, additional_grans );
d2992 1
a2992 1
		(void)rt_plong( rp->nmg.N_structs+4*kind, kind_counts[kind] );
@


10.5
log
@Butlers mods through 24-Aug
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.4 92/06/25 20:11:57 mike Exp Locker: butler $ (BRL)";
d214 2
a215 2
	bcopy(&a_hit->hit, seg_p->seg_in, sizeof(struct hit));
	bcopy(&a_hit->hit, seg_p->seg_out, sizeof(struct hit));
d492 2
a493 2
		bcopy(&a_hit->hit, seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, seg_p->seg_out, sizeof(struct hit));
d559 2
a560 2
			bcopy(&a_hit->hit, seg_p->seg_in, sizeof(struct hit));
			bcopy(&a_hit->hit, seg_p->seg_out, sizeof(struct hit));
d573 2
a574 2
		bcopy(&a_hit->hit, seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, seg_p->seg_out, sizeof(struct hit));
d1088 2
a1089 2
		bcopy(&a_hit->hit, seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, seg_p->seg_out, sizeof(struct hit));
@


10.4
log
@Fixed error in definition of disk_edge_g
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.3 92/06/25 20:06:17 butler Exp Locker: mike $ (BRL)";
a384 7
	char *nbh=(char *)NULL;
	int hood;
	int idx;
	struct model *m;
	struct vertexuse *vu_p;
	vect_t left_vect;
	struct ef_data i_u[8];	/* "important" uses of edge */
a387 1
	m = nmg_find_model((long *)v_p);
a388 24
	nbh = rt_calloc(m->maxindex, sizeof (char),
		"get nbh table");

	hood = 1;
	for (RT_LIST_FOR(vu_p, vertexuse, &v_p->vu_hd)) {
		switch(*vu_p->up.magic_p) {
		case NMG_EDGEUSE_MAGIC:
			NMG_CK_EDGE(vu_p->up.eu_p->e_p);
			if (NMG_INDEX_TEST(nbh, vu_p->up.eu_p->e_p)) break;

			/* edge hasn't been seen, sort uses wrt seen edges */
			sort_eus(i_u, vu_p->up.eu_p->e_p, tbl, rp, left_vect);
			NMG_INDEX_ASSIGN(nbh, vu_p->up.eu_p->e_p, hood++);

			break;
		case NMG_LOOPUSE_MAGIC:
			rt_bomb("XXX 3-Mainifold vertex loop hit\n");
			break;
		}
	}

	/* determine last/first faces */
	

d468 4
a472 1

d3094 1
@


10.3
log
@Work to allow interpretation of ray/vertex intersection
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.2 92/02/25 07:16:19 butler Exp Locker: butler $ (BRL)";
d1676 1
a1676 1
	long			usage;
@


10.2
log
@ratracing 3Manifold edges work.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 10.1 91/10/12 06:40:17 mike Rel4_0 Locker: butler $ (BRL)";
a236 138

/*
 *
 *
 *	if we hit a 3 manifold for seg_in we enter the solid
 *	if we hit a 3 manifold for seg_out we leave the solid
 *	if we hit a 0,1or2 manifold for seg_in, we enter/leave the solid.
 *	if we hit a 0,1or2 manifold for seg_out, we ignore it.
 */
static int
vertex_hit(v_p, seg_p, rp, tbl, a_hit, filled)
struct vertex	*v_p;
struct seg	*seg_p;
struct xray	*rp;
char		*tbl;
struct hitlist	*a_hit;
int		filled;
{
	char manifolds = NMG_MANIFOLDS(tbl, v_p);
	struct faceuse *fu_p;
	struct vertexuse *vu_p;

	if (manifolds & NMG_3MANIFOLD) {

	    /* XXX */
	    rt_bomb("God have mercy!\n");
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");

	} else if (manifolds & NMG_2MANIFOLD) {
	    /* we've hit the corner of a dangling face */
	    if (filled == 0) {
	    	register int found=0;

	    	/* find a surface normal */
	    	for (RT_LIST_FOR(vu_p, vertexuse, &v_p->vu_hd)) {

	    		if (NMG_MANIFOLDS(tbl, vu_p) & NMG_2MANIFOLD &&
	    		    !(NMG_MANIFOLDS(tbl, vu_p) & NMG_3MANIFOLD) ) {
	    		    	found = 1; break;
	    		}
	    	}
	    	
		bcopy(&a_hit->hit, seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, seg_p->seg_out, sizeof(struct hit));

	    	if (found) {
		    	/* we've found a 2manifold vertexuse.
		    	 * get a pointer to the faceuse and get the
		    	 * normal from the face
		    	 */

		    	if (*vu_p->up.magic_p == NMG_EDGEUSE_MAGIC)
		    		fu_p = vu_p->up.eu_p->up.lu_p->up.fu_p;
		    	else if (*vu_p->up.magic_p == NMG_LOOPUSE_MAGIC)
		    		fu_p = vu_p->up.lu_p->up.fu_p;
	    		else  {
	    			fu_p = (struct faceuse *)NULL;
	    			rt_bomb("vertex_hit: bad vu->up\n");
	    			/* NOTREACHED */
	    		}

		    	if (VDOT(fu_p->f_p->fg_p->N, rp->r_dir) > 0.0) {
				VREVERSE(seg_p->seg_in.hit_normal,
					fu_p->f_p->fg_p->N);
				VMOVE(seg_p->seg_out.hit_normal,
					fu_p->f_p->fg_p->N);
		    	} else {
				VMOVE(seg_p->seg_in.hit_normal,
					fu_p->f_p->fg_p->N);
				VREVERSE(seg_p->seg_out.hit_normal,
					fu_p->f_p->fg_p->N);
		    	}

		} else {
	    		/* we didn't find a face.  How did this happen? */
	    		rt_log("2manifold lone vertex?\n");
			VREVERSE(seg_p->seg_in.hit_normal, rp->r_dir);
			VMOVE(seg_p->seg_out.hit_normal, rp->r_dir);

			filled = 2;
	    	}
	    }
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");

	} else if (manifolds & NMG_1MANIFOLD) {
	    /* we've hit the end of a wire.
	     * this is the same as for hitting a wire.
	     */
	    if (filled == 0) {
	    	/* go looking for a wire edge */
		for (RT_LIST_FOR(vu_p, vertexuse, &v_p->vu_hd)) {
		    /* if we find an edge which is only a 1 manifold
		     * we'll call edge_hit with it
		     */
		    if (*vu_p->up.magic_p == NMG_EDGEUSE_MAGIC &&
			! (NMG_MANIFOLDS(tbl, vu_p->up.eu_p->e_p) &
			(NMG_3MANIFOLD|NMG_2MANIFOLD)) &&
			(NMG_MANIFOLDS(tbl, vu_p->up.eu_p->e_p) &
			NMG_1MANIFOLD) ) {
			    filled = wire_hit(vu_p->up.eu_p->e_p,
			    			seg_p, rp, a_hit);
			    			
			    break;
		    }
		}
	    	if (filled == 0) {
	    		/* we didn't find an edge.  How did this happen? */
	    		rt_log("1manifold lone vertex?\n");
			bcopy(&a_hit->hit, seg_p->seg_in, sizeof(struct hit));
			bcopy(&a_hit->hit, seg_p->seg_out, sizeof(struct hit));
			VREVERSE(seg_p->seg_in.hit_normal, rp->r_dir);
			VMOVE(seg_p->seg_out.hit_normal, rp->r_dir);

			filled = 2;
	    	}
	    }
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");

	} else if (manifolds & NMG_0MANIFOLD ) {
	    if (filled == 0) {
		/* we've hit a lone vertex */
		bcopy(&a_hit->hit, seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, seg_p->seg_out, sizeof(struct hit));
		VREVERSE(seg_p->seg_in.hit_normal, rp->r_dir);
		VMOVE(seg_p->seg_out.hit_normal, rp->r_dir);

		filled = 2;
	    }
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");
	}
	return(filled);
}


a245 9
static void
edge_confusion(a_hit, i_u, file, line)
struct hitlist	*a_hit;
struct ef_data i_u[8];	/* "important" uses of edge */
char *file;
int line;
{
	if (file)
		rt_log("edge_hit() in %s at %d is confused\n", file, line);
a246 20
	rt_structprint("LEFT_MIN_ENTER", ef_parsetab,
		(char *)&i_u[LEFT_MIN_ENTER]);
	rt_structprint("LEFT_MIN_EXIT", ef_parsetab,
		(char *)&i_u[LEFT_MIN_EXIT]);
	rt_structprint("LEFT_MAX_ENTER", ef_parsetab,
		(char *)&i_u[LEFT_MAX_ENTER]);
	rt_structprint("LEFT_MAX_EXIT", ef_parsetab,
		(char *)&i_u[LEFT_MAX_EXIT]);
	rt_structprint("RIGHT_MIN_ENTER", ef_parsetab,
		(char *)&i_u[RIGHT_MIN_ENTER]);
	rt_structprint("RIGHT_MIN_EXIT", ef_parsetab,
		(char *)&i_u[RIGHT_MIN_EXIT]);
	rt_structprint("RIGHT_MAX_ENTER", ef_parsetab,
		(char *)&i_u[RIGHT_MAX_ENTER]);
	rt_structprint("RIGHT_MAX_EXIT", ef_parsetab,
		(char *)&i_u[RIGHT_MAX_EXIT]);

}


d378 46
d425 193
d791 29
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.35 91/09/20 23:11:08 butler Exp $ (BRL)";
d55 3
a57 4
    	struct rt_list	l;
    	fastf_t		rdot;	/* face vector VDOT with ray */
    	fastf_t		ldot;	/* face vector VDOT with ray-left */
    	fastf_t		ndot;	/* face normal VDOT with ray */
d60 8
d69 11
d261 2
d375 15
a389 6
/* 
 * compute the dot products needed for computing entry/exit on 3manifold edge
 */
static void doangle(efd, rayvect, lvect)
struct ef_data *efd;
vect_t	rayvect, lvect;
d391 32
d424 5
a428 1
	vect_t eu_vect, face_vect;
d430 2
d433 2
a434 1
	NMG_CK_EDGEUSE(efd->eu);
a435 2
	if (efd->eu->up.lu_p->up.fu_p->orientation != OT_SAME)
		efd->eu = efd->eu->eumate_p;
d437 1
a437 1
	fg_p = efd->eu->up.lu_p->up.fu_p->f_p->fg_p;
d439 3
a441 3
	/* create vector of the edge */
	VSUB2(eu_vect, efd->eu->vu_p->v_p->vg_p->coord,
		efd->eu->eumate_p->vu_p->v_p->vg_p->coord);
d443 4
a446 2
	/* get vector pointing along surface of face */
	VCROSS(face_vect, eu_vect, fg_p->N);
d448 1
a448 4
	efd->rdot = VDOT(rayvect, face_vect);
	efd->ldot = VDOT(lvect, face_vect);
	efd->ndot = VDOT(rayvect, fg_p->N);
}
d450 1
d452 8
d461 4
a464 10
static void
edge_outin(ef_hd, li, lo, ri, ro)
struct ef_data *ef_hd, **li, **lo, **ri, **ro;
{
	struct ef_data *left_in = (struct ef_data *)NULL;
	struct ef_data *right_in = (struct ef_data *)NULL;
	struct ef_data *left_out = (struct ef_data *)NULL;
	struct ef_data *right_out = (struct ef_data *)NULL;
	struct ef_data *efd;
	register struct ef_data *pefd;
d466 8
a473 4
    	/* find the 2 exit faces */
	for ( RT_LIST_FOR(efd, ef_data, &(ef_hd->l)) ) {
    	    if (efd->ndot >= 0.0) {
    		/* face has rayward normal */
d475 2
a476 18
    		if (efd->ldot >= 0.0) {
    			/* left-side face, is it the best left-side
    			 * exit?
    			 */
    			if (!left_out || efd->rdot > left_out->rdot)
    				left_out = efd;
    		} else {
    			/* right-side face, is it the best right-side
    			 * exit?
    			 */
    			if (!right_out || efd->rdot > right_out->rdot)
    				right_out = efd;
    		}
    	    }
	}
	if (left_out) {
		pefd = left_out;
		efd = RT_LIST_NEXT(ef_data, &pefd->l);
d478 6
a483 4
		/* while rdot is still increasing, we're on the left */
		while (efd->rdot >= pefd->rdot) {
			/* if face has anti-ray-ward normal */
			if (efd->ndot < 0.0) left_in = efd;
d485 1
a485 7
			pefd = efd;
			efd = RT_LIST_NEXT(ef_data, &(efd->l));
		}
	}
	if (right_out) {
		pefd = right_out;
		efd = RT_LIST_PREV(ef_data, &pefd->l);
d487 4
a490 5
		/* while rdot is still increasing, we're on the right
		 */
		while (efd->rdot >= pefd->rdot) {
			/* if face has anti-ray-ward normal */
			if (efd->ndot < 0.0) right_in = efd;
d492 46
a537 2
			pefd = efd;
			efd = RT_LIST_PREV(ef_data, &(efd->l));
d539 2
a540 1
	}
d542 1
a542 5
	*li = left_in;
	*lo = left_out;
	*ri = right_in;
	*ro = right_out;

d545 12
d558 6
a563 2
edge_inout(ef_hd, li, lo, ri, ro)
struct ef_data *ef_hd, **li, **lo, **ri, **ro;
d565 2
a566 6
	struct ef_data *left_in = (struct ef_data *)NULL;
	struct ef_data *right_in = (struct ef_data *)NULL;
	struct ef_data *left_out = (struct ef_data *)NULL;
	struct ef_data *right_out = (struct ef_data *)NULL;
	struct ef_data *efd;
	register struct ef_data *pefd;
d568 8
a575 4
    	/* find the 2 entry faces */
	for ( RT_LIST_FOR(efd, ef_data, &(ef_hd->l)) ) {
    	    if (efd->ndot < 0.0) {
    		/* face has anti-rayward normal */
d577 26
a602 22
    		if (efd->ldot >= 0.0) {
    			/* left-side face, is it the best left-side
    			 * entry?
    			 */
    			if (!left_in || efd->rdot < left_in->rdot)
    				left_in = efd;
    		} else {
    			/* right-side face, is it the best right-side
    			 * entry?
    			 */
    			if (!right_in || efd->rdot < right_in->rdot)
    				right_in = efd;
    		}
    	    }
	}
	if (left_in) {
		/* go looking for left_out.
		 * Find a (the last) left-hand face with a 
		 * ray-ward surface normal, behind left_in face
		 */
		pefd = left_in;
		efd = RT_LIST_NEXT(ef_data, &pefd->l);
d604 6
a609 5
		/* while rdot is still increasing, we're on the left
		 */
		while (efd->rdot >= pefd->rdot) {
			/* if face has ray-ward normal */
			if (efd->ndot < 0.0) left_out = efd;
d611 7
a617 2
			pefd = efd;
			efd = RT_LIST_NEXT(ef_data, &(efd->l));
a618 8
	}
	if (right_in) {
		/* go looking for right_out.
		 * Find a (the last) right-hand face with a ray-ward
		 * surface normal, behind right_in face
		 */
		pefd = right_in;
		efd = RT_LIST_PREV(ef_data, &pefd->l);
d620 1
a620 5
		/* while rdot is still increasing, we're on the right
		 */
		while (efd->rdot >= pefd->rdot) {
			/* if face has ray-ward normal */
			if (efd->ndot < 0.0) right_out = efd;
d622 6
a627 3
			pefd = efd;
			efd = RT_LIST_PREV(ef_data, &(efd->l));
		}
d630 2
a631 4
	*li = left_in;
	*lo = left_out;
	*ri = right_in;
	*ro = right_out;
d635 10
a644 6
static void sort_eus(ef_hd, e_p, tbl, rp, left_vect)
struct ef_data *ef_hd;
struct edge *e_p;
char tbl[];
struct xray *rp;
vect_t left_vect;
d646 11
a656 5
	struct edgeuse *tmp_eu;
	struct ef_data *efd;

	/* compute the relevant dot products for each edge/face about
	 * this edge.
d658 2
a659 7
	tmp_eu = e_p->eu_p;
	do {
		/* we only care about the 3-manifold edge uses */
		if (NMG_MANIFOLDS(tbl, tmp_eu) & NMG_3MANIFOLD) {
			efd = (struct ef_data *)rt_calloc(1,
						sizeof(struct ef_data), 
						"edge-face data element");
d661 8
a668 1
 		   	RT_LIST_MAGIC_SET(&(efd->l), 0xe1e10);
d670 11
a680 1
			doangle(efd, rp->r_dir, left_vect);
d682 22
a703 3
			RT_LIST_APPEND(&(ef_hd->l), &(efd->l));
		}
		tmp_eu = tmp_eu->radial_p->eumate_p;
d705 14
a718 1
	} while (tmp_eu != e_p->eu_p);
a721 1
 *
d739 3
d785 2
a786 2
	    struct ef_data *ef_hd;
	    struct ef_data *left_in, *right_in, *left_out, *right_out;
d789 1
a789 1
	     * First we "sort" the faces
d792 1
d794 4
a797 2
	    ef_hd = (struct ef_data *)rt_calloc(1, sizeof(struct ef_data),
	    			"head of edge-face data list");
d799 4
a802 1
	    RT_LIST_INIT(&(ef_hd->l));
d804 1
a804 1
	    sort_eus(ef_hd, e_p, tbl, rp, left_vect);
d806 4
d813 1
a813 1
	    	/* we're looking for an exit/entry point */
d815 6
a820 1
	    	edge_outin(ef_hd, &left_in, &left_out, &right_in, &right_out);
d822 1
a822 8
	    	if (left_out && right_out) {
	    		/* we're outbound */
	    		if (left_in && right_in) {
	    			/* we go right back in again */
	    			
	    		}
	    	}
	    	
d824 2
a825 2
	    } else {
	    	/* we're looking for an entry/exit point */
d827 3
a829 1
	    	edge_inout(ef_hd, &left_in, &left_out, &right_in, &right_out);
d831 13
a843 6
	    	if (left_in && right_in) {
	    		/* we're inbound on the solid */
	    		if (left_out && right_out) {
	    			/* we come right back out,
	    			 * thus making a 0 length segment.
	    			 */
d845 7
a851 3
	    			/* we go in but we don't come back out 
	    			 * at this edge
	    			 */
d853 15
a867 4
	    	} else if ((left_in && left_out) || (right_in && right_out)) {
	    		/* we've grazed the solid.
	    		 * Thus we make a 0 length segment
	    		 */
a868 1
	    	
d870 4
d875 16
a890 1
	    }
d892 15
d908 21
a928 2
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");
d930 4
d938 2
a939 2
		bcopy(&a_hit->hit, seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, seg_p->seg_out, sizeof(struct hit));
d950 2
d953 3
a955 7
			VMOVE(seg_p->seg_in.hit_normal,
				eu_p->up.lu_p->up.fu_p->f_p->fg_p->N);
		    	if (VDOT(seg_p->seg_in.hit_normal, rp->r_dir) > 0.0) {
		    		VMOVE(seg_p->seg_out.hit_normal,
		    			seg_p->seg_in.hit_normal);
		    		VREVERSE(seg_p->seg_in.hit_normal,
		    			seg_p->seg_in.hit_normal);
d957 2
a958 2
		    		VREVERSE(seg_p->seg_out.hit_normal,
		    			seg_p->seg_in.hit_normal);
d1070 4
a1073 1
	    while (hits_filled < 2) {
d1076 16
d1409 1
a1409 1
		rt_log("rt_nmg_tess: WARNING, disk record contains more than 1 region, you probably won't get what you expect!\n");
d1569 1
a1569 1
	long			is_real;
@


1.35
log
@removing fuzz with lint
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.34 91/06/30 00:10:51 mike Exp $ (BRL)";
@


1.34
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.33 91/06/29 21:06:32 mike Exp $ (BRL)";
d1016 2
a1017 2
	register struct nmg_specific *nmg =
		(struct nmg_specific *)stp->st_specific;
d1040 2
a1041 2
	register struct nmg_specific *nmg =
		(struct nmg_specific *)stp->st_specific;
a1683 1
			point_t			min, max;
a2009 1
			point_t			min, max;
a2687 1
	struct nmgregion		*r;
a2719 1
	union record			*rp;
a2745 1
	char	buf[256];
@


1.33
log
@lint
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.32 91/06/22 22:30:25 mike Exp $ (BRL)";
d130 1
a130 1
register struct soltab *stp;
d132 5
a136 2
	register struct nmg_specific *nmg =
		(struct nmg_specific *)stp->st_specific;
d2438 4
a2441 4
struct rt_db_internal	*ip;
struct rt_external	*ep;
register mat_t		mat;
int			rebound;
d2537 4
a2540 4
struct rt_external	*ep;
struct rt_db_internal	*ip;
double			local2mm;
int			compact;
d2685 3
a2687 3
struct rt_db_internal	*ip;
struct rt_external	*ep;
register mat_t		mat;
d2718 3
a2720 3
struct rt_external	*ep;
struct rt_db_internal	*ip;
double			local2mm;
@


1.32
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.31 91/06/22 20:10:10 butler Exp $ (BRL)";
d271 1
@


1.31
log
@Now can do everything except edges and vertices of 3-manifolds.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.30 91/06/13 22:30:06 butler Exp $ (BRL)";
d78 1
a78 1
rt_nmg_prep( stp, ip, rtip, tol )
a81 1
CONST struct rt_tol	*tol;
d270 4
d387 5
a391 1
	struct ef_data *left_in, *right_in, *left_out, *right_out, *efd;
a394 3
    	left_out = (struct ef_data *)NULL;
    	right_out = (struct ef_data *)NULL;

d453 5
a457 1
	struct ef_data *left_in, *right_in, *left_out, *right_out, *efd;
a460 3
    	left_in = (struct ef_data *)NULL;
    	right_in = (struct ef_data *)NULL;

d866 1
a866 1
rt_nmg_shot( stp, rp, ap, seghead, tol )
a870 1
CONST struct rt_tol	*tol;
d908 1
a908 1
	hl = nmg_isect_ray(rp, nmg->nmg_invdir, nmg->nmg_model, &tol);
d974 1
a974 1
rt_nmg_vshot( stp, rp, segp, n, resp, tol )
d979 1
a979 2
struct resource         *resp; /* pointer to a list of free segs */
CONST struct rt_tol	*tol;
d981 1
a981 1
	rt_vstub( stp, rp, segp, n, resp, tol );
@


1.30
log
@just another checkpoint in the evolution of nmg raytracing
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.29 91/06/13 05:42:44 butler Exp $ (BRL)";
d51 10
d175 44
d236 2
d240 6
a245 3
	} else if (manifolds & NMG_2MANIFOLD && filled == 0) {
	} else if (manifolds & NMG_1MANIFOLD && filled == 0) {
	} else if (manifolds & NMG_0MANIFOLD ( {
d247 86
d347 204
d570 45
d616 58
a673 1
	if (manifolds & NMG_3MANIFOLD) {
a677 1

d689 13
a701 9
		VMOVE(seg_p->seg_in.hit_normal, eu_p->up.lu_p->up.fu_p->f_p->fg_p->N);
	    	if (VDOT(seg_p->seg_in.hit_normal, rp->r_dir) > 0.0) {
	    		VMOVE(seg_p->seg_out.hit_normal,
	    			seg_p->seg_in.hit_normal);
	    		VREVERSE(seg_p->seg_in.hit_normal,
	    			seg_p->seg_in.hit_normal);
	    	} else {
	    		VREVERSE(seg_p->seg_out.hit_normal,
	    			seg_p->seg_in.hit_normal);
d707 1
d710 1
a710 30
		vect_t eray;

		/* we've got a wire edge.
		 *
		 * Generate a normal for the edge which is perpendicular to
		 * the edge in the plane formed by the ray and the edge.
		 *
		 */

		bcopy(&a_hit->hit, seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, seg_p->seg_out, sizeof(struct hit));

		/* make the normal for the ray
		 *
		 * make ray of edge
		 */
		VSUB2(eray, e_p->eu_p->vu_p->v_p->vg_p->coord,
			e_p->eu_p->eumate_p->vu_p->v_p->vg_p->coord);
		
		/* make N perpendicular to ray and edge */
		VCROSS(seg_p->seg_in.hit_normal, rp->r_dir, eray);

		/* make N point toward ray origin in plane of ray and edge */
		VCROSS(seg_p->seg_in.hit_normal, eray,
			seg_p->seg_in.hit_normal);

		/* reverse normal for out-point */
		VREVERSE(seg_p->seg_out.hit_normal, seg_p->seg_in.hit_normal);

		filled = 2;
d735 2
d738 1
a738 1
		if (filled = 0) {
d740 1
a740 1
			bcopy(&a_hit->hit, seg_p->seg_in, sizeof(struct hit));
d745 1
a745 1
			bcopy(&a_hit->hit, seg_p->seg_out, sizeof(struct hit));
d750 5
d770 4
d784 4
a787 4
build_segs(hl, ap, nmg_spec, seghead, rp)
struct hitlist *hl;
struct application *ap;
struct nmg_specific *nmg_spec;
d790 1
d806 4
a836 1
	    RT_LIST_APPEND(&seghead->l, &seg_p->l);
d838 6
d870 1
a870 1
	struct hitlist *hl, *a_hit, *isect_ray_nmg();
d904 1
a904 1
	hl = isect_ray_nmg(rp, nmg->nmg_invdir, nmg->nmg_model, &tol);
d931 1
a931 1
	seg_count = build_segs(hl, ap, nmg, seghead, rp);
d937 1
a937 1
	rt_log("segment list\n");
d939 1
a939 1
		rt_log("dist %g  pt(%g,%g,%g)  Norm(%g,%g,%g)\n",
d947 8
d1294 1
d1300 3
d1770 1
d1782 3
d2120 1
d2133 3
@


1.29
log
@intermediate checkpoint of revisions.  ray tracing development still in
progress.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: g_nmg.c,v 1.28 91/05/25 03:02:32 butler Locked $ (BRL)";
d164 16
a179 6
static void
vertex_hit(v_p, tbl, N, discard)
struct vertex *v_p;
char *tbl;
fastf_t	N[];
int *discard;
d182 16
a197 3
	if (manifolds == 0) {
		/* normal is reversed ray */
		
d199 1
a199 1

d202 15
a216 8
static void
edge_hit(e_p, tbl, N, discard, rp, inout)
struct edge *e_p;
char *tbl;
fastf_t	N[];
int *discard;
register struct xray	*rp;	/* info about the ray */
int inout;			/* 0 entering segment, 1 leaving segment */
a217 1
	vect_t eray;
a218 1
	struct faceuse *fu_p, *best_fu;
d220 1
a220 3
	fastf_t best_dot=0.0;
	fastf_t tmp_dot;
	int leaventer=0;
d222 4
a225 3
	/* if it's a 2 or 3 manifold element, we have to get the normal from
	 * the face(s) to which the edge contributes
	 */
d227 31
a257 6
	if (manifolds & NMG_3MANIFOLD) {
		/* go looking around the edge for a face normal to use
		 *	if we're inbound on the solid, we want the face whose
		 *	normal is closest to perpendicular to the ray while
		 *	still maintaining a component in the direction 
		 *	opposite the ray.
d259 3
a261 3
		 *	if we're outbound, we want the face whose normal is
		 *	closest to perpendicular to the ray, yet maintains
		 *	a component in the same direction as the ray.
d264 2
a265 4
		eu_p = e_p->eu_p;
		best_dot=0.0;
		best_fu = (struct faceuse *)NULL;
		do {
d267 9
a275 2
			if (NMG_MANIFOLDS(tbl, eu_p) == NMG_3MANIFOLD) {
				fu_p = eu_p->up.lu_p->up.fu_p;
d277 3
a279 2
				if (fu_p->orientation != OT_SAME)
					fu_p = fu_p->fumate_p;
d281 2
a282 1
				tmp_dot = VDOT(fu_p->f_p->fg_p->N, rp->r_dir);
d284 7
a290 12
				if (inout == 0) {
					/* inbound */
					if (tmp_dot > 0.0 && 
					    tmp_dot < best_dot) {
						/* new inbound best */
						best_fu = fu_p;
						best_dot = tmp_dot;
					}
					if (tmp_dot > 0.0)
						leaventer++;
					else if (tmp_dot < 0.0)
						leaventer--;
d292 16
a307 8
				} else if (inout == 1) {
					/* outbound */
					if(tmp_dot < 0.0 && 
					    tmp_dot > best_dot) {
						/* new outbound best */
						best_fu = fu_p;
						best_dot = tmp_dot;
					}
d309 12
a320 8
					if (tmp_dot > 0.0)
						leaventer++;
					else if (tmp_dot < 0.0)
						leaventer--;
				}
			}
			eu_p = eu_p->radial_p->eumate_p;
		} while (eu_p != e_p->eu_p);
d322 2
a323 2
		/* we now have the face/normal we're looking for */
		bcopy(best_fu->f_p->fg_p->N, N, sizeof(vect_t));
d325 6
a330 13
		if (inout == 0) {
			/* entering (seg_in) */
			if (leaventer == 0) {
				/* grazing, hit this edge twice 
				 * (in & out again)
				 */
				*discard = ! *discard;
			} else if (leaventer > 0) {
				/* really entering, hit this edge once */
				*discard = 1;
			} else {
				rt_bomb("ray screams \"aiiieee\" they're all against me!\n");
			}
d332 2
a333 12
			/* leaving segment (seg_out) */
			if (leaventer == 0) {
				/* leaving, but entering again immediately.
				 * hit edge twice
				 */
				*discard = ! *discard;
			} else if (leaventer < 0) {
				/* really leaving.  hit this edge once */
				*discard = 1;
			} else {
				rt_bomb("ray screams \"aiiieee\" they're all pushing me along!\n");
			}
a334 2
		return;
	}
d336 1
a336 7
	/* edge not used in 3-manifold */
	if (manifolds & NMG_2MANIFOLD) {
		/* find 2manifold face with normal most perpendicular to
		 * ray while maintaining a component opposite the ray.
		 * Hit that face twice.
		 */

d339 2
a340 4
	/* if it's a 1 manifold, 
	 * 	generate a normal for the edge
	 *	the edge gets used twice in the segment list
	 */
d342 1
a342 15
	/* make ray of edge */
	VSUB2(eray, e_p->eu_p->vu_p->v_p->vg_p->coord,
		e_p->eu_p->eumate_p->vu_p->v_p->vg_p->coord);
		
	/* make N perpendicular to ray and edge */
	VCROSS(N, rp->r_dir, eray);
		
	/* make N point toward ray origin in plane of ray and edge */
	VCROSS(N, eray, N);

	if (*discard == 0)
		*discard = 1;
	else
		*discard = 0;
	return;
a344 8
static void
face_hit(f_p, tbl, N, discard)
struct face *f_p;
char *tbl;
fastf_t	N[];
int *discard;
{
	char manifolds = NMG_MANIFOLDS(tbl, f_p);
d346 1
a346 11
	bcopy(f_p->fg_p->N, N, sizeof(vect_t));
	
	if (manifolds & NMG_3MANIFOLD) *discard = 1;
	else if (manifolds & (NMG_2MANIFOLD) && *discard == 1) {
		/* this isn't the last hit we'll record on this object */
		*discard = 0;
	} else
		*discard = 1;
}

static void
a356 3
	struct edge *e_p;
	struct vertex *v_p;
	struct face *f_p;
d358 1
a358 1
	int discard=1;
d366 1
a366 1
		RT_GET_SEG(seg_p, ap->a_resource);
d368 1
d370 1
a371 9
		switch (*(int *)a_hit->hit.hit_private) {
		case NMG_VERTEX_MAGIC:  vertex_hit((struct vertex *)a_hit->hit.hit_private, tbl, a_hit->hit.hit_normal, &discard);
					break;
		case NMG_EDGE_MAGIC:	edge_hit((struct edge *)a_hit->hit.hit_private, tbl, a_hit->hit.hit_normal, &discard, rp, 0);
					break;
		case NMG_FACE_MAGIC:	face_hit((struct face *)a_hit->hit.hit_private, tbl, a_hit->hit.hit_normal, &discard);
					break;
		default: rt_log("bogus topology hit?\n"); abort(); break;
		}
a372 14
		bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));

		if (discard == 0) {
			RT_LIST_DEQUEUE(&a_hit->l);
			rt_free((char *)a_hit, "freeing hitpoint");
		}




		if (RT_LIST_IS_EMPTY(&hl->l) ) {
			rt_bomb("why does this happen to me?\n");
		}
		a_hit = RT_LIST_FIRST(hitlist, &hl->l);
d374 17
a390 7
		case NMG_VERTEX_MAGIC:  vertex_hit((struct vertex *)a_hit->hit.hit_private, tbl, a_hit->hit.hit_normal, &discard);
					break;
		case NMG_EDGE_MAGIC:	edge_hit((struct edge *)a_hit->hit.hit_private, tbl, a_hit->hit.hit_normal, &discard, 1);
					break;
		case NMG_FACE_MAGIC:	face_hit((struct face *)a_hit->hit.hit_private, tbl, a_hit->hit.hit_normal, &discard);
					break;
		default: rt_log("bogus topology hit?\n"); abort(); break;
d392 1
a393 1
		bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));
d395 2
a396 9
		if (discard == 0) {
			RT_LIST_DEQUEUE(&a_hit->l);
			rt_free((char *)a_hit, "freeing hitpoint");
		}


		RT_LIST_APPEND(&seghead->l, &seg_p->l);
		++seg_count;

d398 1
d424 1
d484 2
a485 5

	return(0);
	build_segs(hl, ap, nmg, seghead, rp);
#if 0	

d487 1
a487 1
		return(seg_count);			/* MISS */
d489 1
d503 2
a504 2
	return(seg_count);			/* MISS */
#endif
@


1.28
log
@Added error checking
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.27 91/05/18 03:00:58 mike Exp $ (BRL)";
d38 1
a38 1
	struct hit	*hit;
d79 2
d111 2
d164 12
d177 1
d179 236
d436 1
a436 6
	register struct seg *segp;
	struct nmgregion *r_p;
	struct shell *s_p;
	struct faceuse *fu_p;
	int status;
	int state;
a437 2
	struct hitlist *hl, *a_hit, *b_hit, *isect_ray_nmg();
	long *novote;	/* faces that can't vode in hit/miss/list */
d439 3
a468 1
	rt_g.NMG_debug |= DEBUG_NMGRT;
d478 16
a493 7
		rt_log("sorted nmg/ray hit list\n");
		for (RT_LIST_FOR(a_hit, hitlist, &hl->l))
			rt_log("hit_distance %g (%g %g %g)\n",
				a_hit->hit->hit_dist,
				a_hit->hit->hit_point[0],
				a_hit->hit->hit_point[1],
				a_hit->hit->hit_point[2]);
a495 1
return(0);	/* XXX */
d497 3
d501 2
a502 13
	/* build up the list of segments based upon the hit points.
	 * state	face	action			New state
	 *  0 pt	MF	new, in = pt		1 pt
	 *  0 pt	NMF	new, in = out = pt	0 pt
	 *  0 pt	none	done
	 *  1 pt	MF	out = pt		0 pt
	 *  1 pt	NMF	out=pt, new, in=pt	1 pt
	 *  1 pt	none	error?
	 */
	state = 0;
	for (RT_LIST_FOR(a_hit, hitlist, &hl->l)) {
		if (state == 0) {
			RT_GET_SEG(segp, ap->a_resource );
d504 10
a513 79
			if (rt_g.NMG_debug & DEBUG_NMGRT)
				rt_log("first hit in seg %g", a_hit->hit->hit_dist);

			bcopy(&a_hit->hit, &segp->seg_in, sizeof(struct hit));

			if (rt_g.NMG_debug & DEBUG_NMGRT)
				rt_log(" (%g) \n", segp->seg_in.hit_dist);

			if (!nmg_manifold_face(
			    (struct faceuse *)a_hit->hit->hit_private) ) {


				if (rt_g.NMG_debug & DEBUG_NMGRT)
					rt_log("secod hit in seg %g", a_hit->hit->hit_dist);

				bcopy(a_hit->hit, &segp->seg_out,
					sizeof(struct hit));

				if (rt_g.NMG_debug & DEBUG_NMGRT)
					rt_log(" (%g) \n",
						segp->seg_out.hit_dist);


			    	segp->seg_stp = stp;

			    	if (rt_g.NMG_debug & DEBUG_NMGRT)
			    		rt_log("new seg (prior ins) %g <-> %g\n",
			    			segp->seg_in.hit_dist,
			    			segp->seg_out.hit_dist);

				RT_LIST_INSERT( &(seghead->l), &(segp->l) );
			    	seg_count++;

			    	if (rt_g.NMG_debug & DEBUG_NMGRT)
			    		rt_log("new seg (post ins) %g <-> %g\n",
			    			segp->seg_in.hit_dist,
			    			segp->seg_out.hit_dist);
			} else 
				state = 1;
		} else {
			if (rt_g.NMG_debug & DEBUG_NMGRT)
				rt_log("fisrt and secod hit in seg %g -> %g", a_hit->hit->hit_dist);

			bcopy(&a_hit->hit, &segp->seg_out, sizeof(struct hit));

			if (rt_g.NMG_debug & DEBUG_NMGRT)
				rt_log(" (%g) \n", segp->seg_out.hit_dist);


		    	segp->seg_stp = stp;

		    	if (rt_g.NMG_debug & DEBUG_NMGRT)
		    		rt_log("new seg (pr ins) %g <-> %g\n",
		    			segp->seg_in.hit_dist,
		    			segp->seg_out.hit_dist);

			RT_LIST_INSERT( &(seghead->l), &(segp->l) );

		    	seg_count++;
		    	if (rt_g.NMG_debug & DEBUG_NMGRT)
		    		rt_log("new seg %g <-> %g\n",
		    			segp->seg_in.hit_dist,
		    			segp->seg_out.hit_dist);

			if (!nmg_manifold_face(
			    (struct faceuse *)a_hit->hit->hit_private) ) {
				RT_GET_SEG(segp, ap->a_resource );
				if (rt_g.NMG_debug & DEBUG_NMGRT)
					rt_log("first hit in seg %g", a_hit->hit->hit_dist);

				bcopy(&a_hit->hit, &segp->seg_in,
					sizeof(struct hit));

				if (rt_g.NMG_debug & DEBUG_NMGRT)
					rt_log(" (%g) \n",
						segp->seg_in.hit_dist);
			} else
				state = 0;
		}
a514 3
	if (state != 0) {
		rt_bomb("I've got an extra hit-point on an NMG!\n");
	}
d516 1
a516 4

	for (RT_LIST_FOR(a_hit, hitlist, &hl->l))
		rt_free((char *)a_hit, "free a hit");

d518 1
@


1.27
log
@Converted to new tolerance interface
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.26 91/05/17 20:21:59 butler Exp $ (BRL)";
d912 1
d916 3
a918 1
	(void)rt_plong( (oo)->elem.forw, rt_nmg_reindex((genptr_t)((ii)->elem.forw), ecnt) ); \
a1404 1
			INDEXL_HD( d, lu, down_hd, lu->down_hd );
d1411 3
@


1.26
log
@More work
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.25 91/04/29 15:41:28 butler Exp $ (BRL)";
d68 1
a68 1
rt_nmg_prep( stp, ip, rtip )
d72 1
d174 1
a174 1
rt_nmg_shot( stp, rp, ap, seghead )
d179 1
a192 3
	fastf_t tol=0.05;


d221 1
a221 1
	hl = isect_ray_nmg(rp, nmg->nmg_invdir, nmg->nmg_model, tol);
d239 1
a239 1
	return(0);
d355 1
a355 1
rt_nmg_vshot( stp, rp, segp, n, resp)
d361 1
d363 1
a363 1
	rt_vstub( stp, rp, segp, n, resp );
d468 1
a468 1
rt_nmg_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
d471 2
a472 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
d493 1
a493 1
rt_nmg_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d497 2
a498 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
@


1.25
log
@can now ray-trace faces (but not edges)
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.24 91/02/28 02:05:29 mike Exp $ (BRL)";
d38 1
a38 1
	struct hit	hit;
a159 20
 
/*	I S E C T _ R A Y _ F A C E U S E
 *
 *	intersect a ray with a faceuse.
 *
 *	Returns:
 *		1	hit
 */
struct hitlist *
nmg_isect_ray_faceuse(stp, rp, fu_p, novote)
struct soltab		*stp;
register struct xray	*rp;	/* info about the ray */
struct faceuse		*fu_p;
long 			*novote;
{
	register struct nmg_specific *nmg =
		(struct nmg_specific *)stp->st_specific;
	point_t	pt_in_plane;
	int status;
	fastf_t dist=0.0;
a160 65
	NMG_CK_FACEUSE(fu_p);
	NMG_CK_FACE(fu_p->f_p);
	NMG_CK_FACE_G(fu_p->f_p->fg_p);

	if (rt_g.NMG_debug & DEBUG_NMGRT)
		rt_log("doing faceuse %0x (fumate %0x)\n", fu_p, fu_p->fumate_p);

	if (!rt_in_rpp(rp, nmg->nmg_invdir,
	    fu_p->f_p->fg_p->min_pt,fu_p->f_p->fg_p->max_pt) )
		return((struct hitlist *)0);	/* MISS */
	    
	status = rt_isect_ray_plane(&dist, rp->r_pt, rp->r_dir,
			fu_p->f_p->fg_p->N);

/*	rt_g.NMG_debug |= DEBUG_NMGRT|DEBUG_CLASSIFY; */

	if (rt_g.NMG_debug & DEBUG_NMGRT) {
		plot_ray_face(rp->r_pt, rp->r_dir, fu_p);

		rt_log("Ray (%g %g %g) -> %g %g %g\nNMG f:(%g %g %g %g) dist:%g\n",
			rp->r_pt[0], rp->r_pt[1], rp->r_pt[2],
			rp->r_dir[0], rp->r_dir[1], rp->r_dir[2],
			fu_p->f_p->fg_p->N[0], fu_p->f_p->fg_p->N[1],
			fu_p->f_p->fg_p->N[2], fu_p->f_p->fg_p->N[3],
			dist);
	}

	/* translate ray start point into plane of faceuse
	 * to determine ray/plane intercept location
	 */
	VJOIN1(pt_in_plane, rp->r_pt, dist, rp->r_dir);

	/* we need to find the closest edge in the face to the intersection
	 * point so that we can decide whether the ray actually hits the face
	 * or not.
	 *
	 * XXX alas, we have to "invent" a tolerance to call pt_hitmis_f
	 */
	status = nmg_pt_hitmis_f(pt_in_plane, fu_p, SQRT_SMALL_FASTF, novote);


	if (status) {
		/* we hit the face, fill in a hit structure */
		struct hitlist *hit;

		hit = (struct hitlist *)rt_calloc(1, sizeof(struct hitlist), "face hit structure");
		hit->hit.hit_dist = dist;
		VMOVE(hit->hit.hit_point, pt_in_plane);
		VMOVEN(hit->hit.hit_normal, fu_p->f_p->fg_p->N, 4);
		hit->hit.hit_private = (genptr_t)fu_p;
		hit->hit.hit_surfno = fu_p->f_p->index;

		if (rt_g.NMG_debug & DEBUG_NMGRT)
			rt_log("NMG/ray hit\n");
		return(hit);
	}

	if (rt_g.NMG_debug & DEBUG_NMGRT)
		rt_log("NMG/ray miss\n");

	return((struct hitlist *)0); /* MISS */

}


d188 1
a188 1
	struct hitlist hl, *a_hit, *b_hit;
d191 1
a192 2
	bzero(&hl, sizeof(struct hitlist));
	RT_LIST_INIT(&hl.l);
d221 2
a222 1
	NMG_CK_MODEL(nmg->nmg_model);
d224 1
a224 57
	novote = (long *)rt_calloc( nmg->nmg_model->maxindex,
		sizeof(long), "pt_inout_s novote[]" );

	/* at this point, we know the ray intersects the nmg model RPP */
	for (RT_LIST_FOR(r_p, nmgregion, &nmg->nmg_model->r_hd) ) {
		NMG_CK_REGION(r_p);
		NMG_CK_REGION_A(r_p->ra_p);

		if ( !rt_in_rpp(rp, nmg->nmg_invdir,
		    r_p->ra_p->min_pt, r_p->ra_p->max_pt) )
			continue;

		/* we now know the ray intersects the nmgregion RPP */
		for (RT_LIST_FOR(s_p, shell, &r_p->s_hd)) {
			NMG_CK_SHELL(s_p);
			NMG_CK_SHELL_A(s_p->sa_p);
			if (!rt_in_rpp(rp, nmg->nmg_invdir,
			    s_p->sa_p->min_pt, s_p->sa_p->max_pt) )
				continue;
			
			/* we now know that the ray intersects the
			 * nmg shell RPP
			 */
			for (RT_LIST_FOR(fu_p, faceuse, &s_p->fu_hd) ) {

				if ( NMG_INDEX_TEST( novote, fu_p ) ) {
					if (rt_g.NMG_debug & DEBUG_NMGRT)
						rt_log("skipping faceuse %0x (fumate %0x)\n", fu_p, fu_p->fumate_p);
					continue;
				}

				a_hit = nmg_isect_ray_faceuse(stp, rp,
						fu_p, novote);

				NMG_INDEX_SET(novote, fu_p->f_p);
				NMG_INDEX_SET(novote, fu_p);
				NMG_INDEX_SET(novote, fu_p->fumate_p);

				/* if we found a hit, add it to the list
				 * of hit locations.  Keep the list sorted
				 * in ascending hit distance.
				 */
				if (a_hit) {
				    for(RT_LIST_FOR(b_hit, hitlist, &hl.l))
					if (b_hit->hit.hit_dist >
					    a_hit->hit.hit_dist )
					    	break;

				    RT_LIST_INSERT(&b_hit->l, &(a_hit->l));
				}
			}
		}
	}

	rt_free( (char *)novote, "pt_inout_s novote[]" );

	if (RT_LIST_IS_EMPTY(&hl.l)) {
d232 6
a237 2
		for (RT_LIST_FOR(a_hit, hitlist, &hl.l))
			rt_log("hit_distance %g\n", a_hit->hit.hit_dist);
d240 3
d253 1
a253 1
	for (RT_LIST_FOR(a_hit, hitlist, &hl.l)) {
d258 1
a258 1
				rt_log("first hit in seg %g", a_hit->hit.hit_dist);
d266 1
a266 1
			    (struct faceuse *)a_hit->hit.hit_private) ) {
d270 1
a270 1
					rt_log("secod hit in seg %g", a_hit->hit.hit_dist);
d298 1
a298 1
				rt_log("fisrt and secod hit in seg %g -> %g", a_hit->hit.hit_dist);
d322 1
a322 1
			    (struct faceuse *)a_hit->hit.hit_private) ) {
d325 1
a325 1
					rt_log("first hit in seg %g", a_hit->hit.hit_dist);
d342 1
a342 1
	for (RT_LIST_FOR(a_hit, hitlist, &hl.l))
@


1.24
log
@Implemented space-savings policies for saving space on disk.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.23 91/02/27 23:36:37 mike Exp $ (BRL)";
d36 5
d42 5
a46 1
	vect_t	nmg_V;
d48 2
d51 1
d75 2
d81 28
d123 124
d260 3
a262 3
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d267 8
d276 204
a479 1
	return(2);			/* HIT */
d511 1
a511 1
	register struct nmg_specific *nmg =
d514 1
a514 1
	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
d566 1
@


1.23
log
@Split apart import/export interface, and the internal support
routines that do most of the work.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.22 91/02/27 23:14:13 mike Exp $ (BRL)";
d378 4
a381 2
	char			min_pt[3*8];
	char			max_pt[3*8];
d670 2
a671 1
#define INDEX(o,i,elem)		(void)rt_plong( (o)->elem, rt_nmg_reindex((genptr_t)((i)->elem), ecnt) )
a820 4
			VSCALE( min, fg->min_pt, local2mm );
			VSCALE( max, fg->max_pt, local2mm );
			htond( d->min_pt, min, 3 );
			htond( d->max_pt, max, 3 );
a1140 2
			ntohd( min, d->min_pt, 3 );
			ntohd( max, d->max_pt, 3 );
a1141 1
			rt_rotate_bbox( fg->min_pt, fg->max_pt, mat, min, max );
d1556 1
a1556 1
rt_nmg_import_internal( ip, ep, mat )
d1560 1
d1614 14
a1627 2
	/* XXX Perhaps bounding boxes should be recomputed here? */
	/* XXX Perhaps _a structures need not be stored to disk? */
d1645 3
a1647 1
 *	nmgregion_a, shell_a, and loop_g
d1692 1
a1692 1
	subscript = 1;
d1699 6
d1707 14
d1728 1
d1785 1
d1820 1
a1820 1
	if( rt_nmg_import_internal( ip, ep, mat ) < 0 )
a1825 2
	/* XXX Perhaps bounding boxes should be recomputed here? */

a1848 2
	/* XXX Perhaps some _a structures need not be stored to disk? */

d1850 1
a1850 1
	return  rt_nmg_export_internal( ep, ip, local2mm, 0 );
@


1.22
log
@Code shuffling.  2 subroutines sent off to plane.c
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.21 91/02/27 22:42:54 mike Exp $ (BRL)";
d1549 1
a1549 1
 *			R T _ N M G _ I M P O R T
d1560 1
a1560 1
rt_nmg_import( ip, ep, mat )
d1631 1
a1631 1
 *			R T _ N M G _ E X P O R T
d1635 7
d1644 1
a1644 1
rt_nmg_export( ep, ip, local2mm )
d1648 1
d1761 61
@


1.21
log
@Modified storage of kind_count[] info in database header record
to be much simpler and easier to understand.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.20 91/02/27 22:23:22 mike Exp $ (BRL)";
d303 7
a309 5
 *  Transform a bounding box (RPP) by the given 4x4 matrix.
 *  There are 8 corners to the bounding RPP.
 *  Each one needs to be transformed and min/max'ed.
 *  This is not minimal, but does fully contain any internal object,
 *  using an axis-aligned RPP.
d311 2
a312 10
void
rt_rotate_bbox( omin, omax, mat, imin, imax )
point_t		omin;
point_t		omax;
mat_t		mat;
point_t		imin;
point_t		imax;
{
	point_t		rmin, rmax;
	point_t		pt;
a313 87
	MAT4X3PNT( rmin, mat, imin );
	MAT4X3PNT( rmax, mat, imax );

	VSET( omin, rmin[X], rmin[Y], rmin[Z] );
	VMOVE( omax, omin );

	VSET( pt, rmax[X], rmin[Y], rmin[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmin[X], rmax[Y], rmin[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmax[X], rmax[Y], rmin[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmin[X], rmin[Y], rmax[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmax[X], rmin[Y], rmax[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmin[X], rmax[Y], rmax[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmax[X], rmax[Y], rmax[Z] );
	VMINMAX( omin, omax, pt );
}

/*
 *  Transform a plane equation by the given 4x4 matrix.
 */
void
rt_rotate_plane( oplane, mat, iplane )
plane_t		oplane;
mat_t		mat;
plane_t		iplane;
{
	point_t		orig_pt;
	point_t		new_pt;

	/* First, pick a point that lies on the original halfspace */
	VSCALE( orig_pt, iplane, iplane[3] );

	/* Transform the surface normal */
	MAT4X3VEC( oplane, mat, iplane );

	/* Transform the point from original to new halfspace */
	MAT4X3PNT( new_pt, mat, orig_pt );

	/*
	 *  The transformed normal is all that is required.
	 *  The new distance is found from the transformed point on the plane.
	 */
	oplane[3] = VDOT( new_pt, oplane );
}

/* Format of db.h nmg.N_nstructs info, sucked straight from nmg_struct_counts */
#define NMG_O(m)	offsetof(struct nmg_struct_counts, m)

struct rt_imexport rt_nmg_structs_fmt[] = {
	"%d",	NMG_O(model),		1,
	"%d",	NMG_O(model_a),		1,
	"%d",	NMG_O(region),		1,
	"%d",	NMG_O(region_a),	1,
	"%d",	NMG_O(shell),		1,
	"%d",	NMG_O(shell_a),		1,
	"%d",	NMG_O(faceuse),		1,
	"%d",	NMG_O(faceuse_a),	1,
	"%d",	NMG_O(face),		1,
	"%d",	NMG_O(face_g),		1,
	"%d",	NMG_O(loopuse),		1,
	"%d",	NMG_O(loopuse_a),	1,
	"%d",	NMG_O(loop),		1,
	"%d",	NMG_O(loop_g),		1,
	"%d",	NMG_O(edgeuse),		1,
	"%d",	NMG_O(edgeuse_a),	1,
	"%d",	NMG_O(edge),		1,
	"%d",	NMG_O(edge_g),		1,
	"%d",	NMG_O(vertexuse),	1,
	"%d",	NMG_O(vertexuse_a),	1,
	"%d",	NMG_O(vertex),		1,
	"%d",	NMG_O(vertex_g),	1,
	"",	0,			0
};

/* ---------------------------------------------------------------------- */

a319 2
/* ---------------------------------------------------------------------- */

d513 3
a515 2
#define NMG_N_KINDS	22
int	rt_disk_sizes[NMG_N_KINDS] = {
a562 1
/* ---------------------------------------------------------------------- */
d564 6
d626 2
d636 5
d657 1
a657 1
			ret = -1;	/* FLAG:  special list head */
d659 1
a659 1
			ret = 0;	/* ERROR. Use null ptr on import */
d985 2
d1614 1
a1614 1
		cp += rt_disk_sizes[ecnt[i].kind];
d1720 1
a1720 1
		tot_size += kind_counts[i] * rt_disk_sizes[i];
d1730 5
d1738 1
a1738 1
		cp += kind_counts[i] * rt_disk_sizes[i];
d1749 2
a1750 4
	/* Record counts of each kind of structure */
	for( kind = 0; kind < NMG_N_KINDS; kind++ )  {
		(void)rt_plong( rp->nmg.N_structs+4*kind, kind_counts[kind] );
	}
d1774 1
a1774 1
	rt_vls_strcat( str, "truncated general nmg (NMG)\n");
d1776 2
a1779 8

#if 0
	sprintf(buf, "\tV (%g, %g, %g)\n",
		m->v[X] * mm2local,
		m->v[Y] * mm2local,
		m->v[Z] * mm2local );
	rt_vls_strcat( str, buf );
#endif
@


1.20
log
@Moved nmg_index_of_struct to nmg_index.c
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.19 91/02/27 22:14:36 mike Exp $ (BRL)";
a1646 2
	struct nmg_struct_counts	cntbuf;
	struct rt_external		count_ext;
d1665 1
a1665 12
	bzero( (char *)&cntbuf, sizeof(cntbuf) );
	RT_INIT_EXTERNAL(&count_ext);
	count_ext.ext_nbytes = sizeof(rp->nmg.N_structs);
	count_ext.ext_buf = rp->nmg.N_structs;
	if( rt_struct_import( (genptr_t)&cntbuf, rt_nmg_structs_fmt, &count_ext ) <= 0 )  {
		rt_log("rt_struct_import failure\n");
		return(-1);
	}
#if DEBUG
	nmg_pr_struct_counts( &cntbuf, "After import" );
#endif

d1668 1
a1668 1
		kind_counts[kind] = ((long *)&cntbuf)[kind];
a1724 1
	struct rt_external		count_ext;
d1741 1
d1824 3
a1826 4
	RT_INIT_EXTERNAL(&count_ext);
	if( rt_struct_export( &count_ext, (genptr_t)&cntbuf, rt_nmg_structs_fmt ) < 0 )  {
		rt_log("rt_struct_export() failure\n");
		return(-1);
a1827 4
	if( count_ext.ext_nbytes > sizeof(rp->nmg.N_structs) )
		rt_bomb("nmg.N_structs overflow");
	bcopy( count_ext.ext_buf, rp->nmg.N_structs, count_ext.ext_nbytes );
	db_free_external( &count_ext );
@


1.19
log
@Reorganized code, broke out rt_nmg_ialloc().
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.18 91/02/27 21:43:07 mike Exp $ (BRL)";
a714 58
int
rt_nmg_index_of_struct( p )
register long	*p;
{
	switch(*p)  {
	case NMG_MODEL_MAGIC:
		return ((struct model *)p)->index;
	case NMG_MODEL_A_MAGIC:
		return ((struct model_a *)p)->index;
	case NMG_REGION_MAGIC:
		return ((struct nmgregion *)p)->index;
	case NMG_REGION_A_MAGIC:
		return ((struct nmgregion_a *)p)->index;
	case NMG_SHELL_MAGIC:
		return ((struct shell *)p)->index;
	case NMG_SHELL_A_MAGIC:
		return ((struct shell_a *)p)->index;
	case NMG_FACEUSE_MAGIC:
		return ((struct faceuse *)p)->index;
	case NMG_FACEUSE_A_MAGIC:
		return ((struct faceuse_a *)p)->index;
	case NMG_FACE_MAGIC:
		return ((struct face *)p)->index;
	case NMG_FACE_G_MAGIC:
		return ((struct face_g *)p)->index;
	case NMG_LOOPUSE_MAGIC:
		return ((struct loopuse *)p)->index;
	case NMG_LOOPUSE_A_MAGIC:
		return ((struct loopuse_a *)p)->index;
	case NMG_LOOP_MAGIC:
		return ((struct loop *)p)->index;
	case NMG_LOOP_G_MAGIC:
		return ((struct loop_g *)p)->index;
	case NMG_EDGEUSE_MAGIC:
		return ((struct edgeuse *)p)->index;
	case NMG_EDGEUSE_A_MAGIC:
		return ((struct edgeuse_a *)p)->index;
	case NMG_EDGE_MAGIC:
		return ((struct edge *)p)->index;
	case NMG_EDGE_G_MAGIC:
		return ((struct edge_g *)p)->index;
	case NMG_VERTEXUSE_MAGIC:
		return ((struct vertexuse *)p)->index;
	case NMG_VERTEXUSE_A_MAGIC:
		return ((struct vertexuse_a *)p)->index;
	case NMG_VERTEX_MAGIC:
		return ((struct vertex *)p)->index;
	case NMG_VERTEX_G_MAGIC:
		return ((struct vertex_g *)p)->index;
	case RT_LIST_HEAD_MAGIC:
		/* indicate special list head encountered */
		return -1;
	}
	/* default */
	rt_log("rt_nmg_index_of_struct: magicp = x%x, magic = x%x\n", p, *p);
	return -2;	/* indicate error */
}

d721 3
d737 1
a737 1
		index = rt_nmg_index_of_struct((long *)(p));
d1618 1
a1618 1
ptrs[subscript], rt_nmg_index_of_struct(ptrs[subscript]) );
d1621 1
a1621 1
			ecnt[subscript].new_subscript = rt_nmg_index_of_struct(ptrs[subscript]);
d1792 1
a1792 1
		if( rt_nmg_index_of_struct(ptrs[i]) != i )  {
d1794 1
a1794 1
				i, rt_nmg_index_of_struct(ptrs[i]) );
@


1.18
log
@lint
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.17 91/02/27 21:33:12 mike Exp $ (BRL)";
d810 5
d1133 5
d1457 1
a1457 1
 *			R T _ N M G _ I M P O R T
d1459 3
a1461 7
 *  Import an NMG from the database format to the internal format.
 *  Apply modeling transformations as well.
 *
 *  Special subscripts are used in the disk file:
 *	-1	indicates a pointer to the rt_list structure which
 *		heads a linked list, and is not the first struct element.
 *	 0	indicates that a null pointer should be used.
d1463 5
a1467 5
int
rt_nmg_import( ip, ep, mat )
struct rt_db_internal	*ip;
struct rt_external	*ep;
register mat_t		mat;
d1469 4
a1472 15
	LOCAL struct model		*m = (struct model *)0;
	union record			*rp;
	struct nmg_struct_counts	cntbuf;
	struct rt_external		count_ext;
	int				kind_counts[NMG_N_KINDS];
	char				*cp;
	long				**real_ptrs;
	long				**ptrs;
	struct nmg_exp_counts		*ecnt;
	int				i;
	int				j;
	int				maxindex;
	int				subscript;
	int				kind;
	static long			bad_magic = 0x999;
a1473 45
	RT_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != DBID_NMG )  {
		rt_log("rt_nmg_import: defective record\n");
		return(-1);
	}

	bzero( (char *)&cntbuf, sizeof(cntbuf) );
	RT_INIT_EXTERNAL(&count_ext);
	count_ext.ext_nbytes = sizeof(rp->nmg.N_structs);
	count_ext.ext_buf = rp->nmg.N_structs;
	if( rt_struct_import( (genptr_t)&cntbuf, rt_nmg_structs_fmt, &count_ext ) <= 0 )  {
		rt_log("rt_struct_import failure\n");
		return(-1);
	}
#if DEBUG
	nmg_pr_struct_counts( &cntbuf, "After import" );
#endif

	maxindex = 1;
	for( kind = 0; kind < NMG_N_KINDS; kind++ )  {
		kind_counts[kind] = ((long *)&cntbuf)[kind];
		maxindex += kind_counts[kind];
	}
#if DEBUG
	rt_log("import maxindex=%d\n", maxindex);
#endif

	/* Collect overall new subscripts, and structure-specific indices */
	ecnt = (struct nmg_exp_counts *)rt_calloc( maxindex+3,
		sizeof(struct nmg_exp_counts), "ecnt[]" );
	real_ptrs = (long **)rt_calloc( maxindex+3,
		sizeof(long *), "ptrs[]" );
	/* So that indexing [-1] gives an appropriately bogus magic # */
	ptrs = real_ptrs+1;
	ptrs[-1] = &bad_magic;		/* [-1] gives bad magic */
	ptrs[0] = (long *)0;		/* [0] gives NULL */
	ptrs[maxindex] = &bad_magic;	/* [maxindex] gives bad magic */

	/*
	 *  Allocate storage for all the in-memory NMG structures,
	 *  using the GET_xxx() macros, so that m->maxindex, etc,
	 *  is all appropriately handled.
	 */
d1680 76
@


1.17
log
@Minor cleanups
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.16 91/02/27 19:49:19 mike Exp $ (BRL)";
d28 1
d781 1
a781 1
long	*p;
d805 1
a805 1
#define INDEX(o,i,elem)		(void)rt_plong( (o)->elem, rt_nmg_reindex((i)->elem, ecnt) )
d807 2
a808 2
	(void)rt_plong( (oo)->elem.forw, rt_nmg_reindex((ii)->elem.forw, ecnt) ); \
	(void)rt_plong( (oo)->elem.back, rt_nmg_reindex((ii)->elem.back, ecnt) ); }
d964 1
a964 1
			rt_plong( d->up, rt_nmg_reindex(lu->up.magic_p, ecnt) );
d1014 1
a1014 1
			rt_plong( d->up, rt_nmg_reindex(eu->up.magic_p, ecnt) );
d1060 1
a1060 1
			rt_plong( d->up, rt_nmg_reindex(vu->up.magic_p, ecnt) );
d1734 2
a1735 1
		rt_nmg_idisk( ptrs[i], cp, ecnt, i, ptrs, mat );
a1773 1
	int				disk_sizes[NMG_N_KINDS];
d1862 2
a1863 1
		rt_nmg_edisk( disk_arrays[kind], ptrs[i], ecnt, i, local2mm );
@


1.16
log
@Chagned database format to use completely machine-independent format.
In this case, only the granule count was still in machine-specific format.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.15 91/02/27 19:17:30 mike Exp $ (BRL)";
a1466 1
	genptr_t			disk_arrays[NMG_N_KINDS];
d1512 1
a1512 1
	/* So that indexing [-1] gives an appropriately bogus pointer */
d1518 5
a1522 1
	/* Mark off each kind of structure, and how many of them */
a1523 1
	cp = (char *)(rp+1);	/* start at first granule in */
d1526 1
a1526 2
rt_log("%d  %s\n",
	kind_counts[kind], rt_nmg_kind_names[kind] );
a1527 6
		if( kind_counts[kind] <= 0 )  {
			disk_arrays[kind] = GENPTR_NULL;
			continue;
		}
		disk_arrays[kind] = (genptr_t)cp;
		/* Mark off all the entries of this kind */
d1530 1
a1530 2
			ecnt[subscript].per_struct_index = j+1;
			ecnt[subscript].new_subscript = 0; /* unused on import */
d1724 1
a1727 1
		cp += kind_counts[kind] * rt_disk_sizes[kind];
@


1.15
log
@This version has closure:  can repeatedly import and export,
and get the same results.
Rotation, translation, and scaling seem to work.
@
text
@d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.14 91/02/27 04:30:18 mike Exp $ (BRL)";
d1855 1
a1855 1
	rp->nmg.N_count = additional_grans;
@


1.14
log
@Minor nits
@
text
@d1 1
d20 1
a20 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.13 91/02/27 03:35:34 mike Exp $ (BRL)";
d272 10
d285 1
a287 2
	*r = RT_LIST_FIRST(nmgregion, &(lm->r_hd) );
	NMG_CK_REGION(*r);
d291 1
d293 1
d1495 1
a1495 1
#if 0
d1504 1
a1504 1
#if 0
d1523 1
a1523 1
#if 0
d1558 1
d1575 3
d1594 1
d1627 1
d1708 1
d1725 1
a1725 1
#if 0
d1791 1
a1791 1
#if 0
d1816 1
a1816 1
#if 0
d1821 1
a1821 1
#if 0
d1839 1
a1839 1
#if 0
@


1.13
log
@A bit of a hack for the tessellator,
but otherwise, it seems to work!
@
text
@d19 1
a19 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.12 91/02/27 02:46:34 mike Exp $ (BRL)";
d1253 1
a1253 1
			htond( plane, d->N, 4 );
d1402 1
a1402 1
			htond( plane, d->N, 4 );
d1483 1
d1485 1
d1492 1
d1494 1
d1724 3
d1772 1
d1774 1
d1820 1
d1823 1
d1884 3
@


1.12
log
@This version has worked once.  Ship it!
@
text
@d19 1
a19 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.11 91/02/27 02:33:21 mike Exp $ (BRL)";
d256 2
a257 1
	LOCAL struct model	*m;
a258 2
	RT_CK_DB_INTERNAL(ip);
	m = (struct model *)ip->idb_ptr;
d261 26
a286 1
	return(-1);
a902 2
rt_log("fu disk_index=%d, fumate=%d, f=%d\n", ecnt[index].new_subscript,
 rt_glong(d->fumate_p), rt_glong(d->f_p) );
a1220 2
rt_log("fu index=%d, fumate=%d, f=%d\n",
 fu->index, fu->fumate_p->index, fu->f_p->index );
d1507 4
a1510 2
		rt_log("%d  %s\n",
			kind_counts[kind], rt_nmg_kind_names[kind] );
d1702 1
d1706 1
a1712 1
rt_log("starting to convert to internal form\n");
a1718 1
rt_log("all structures imported\n");
d1788 3
a1790 1
	rt_log("Mapping of old index to new index, and kind\n");
d1793 1
d1797 1
@


1.11
log
@Hunting faceuses
@
text
@d19 1
a19 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.10 91/02/27 01:57:02 mike Exp $ (BRL)";
d1473 1
a1473 1
	ecnt = (struct nmg_exp_counts *)rt_calloc( maxindex+1,
d1751 1
a1751 1
	for( i = m->maxindex-1; i >= 0; i-- )  {
@


1.10
log
@Improved
@
text
@d19 1
a19 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.9 91/02/27 01:45:21 mike Exp $ (BRL)";
a793 3
rt_log("model ma_p index=%d\n", rt_glong(d->ma_p) );
rt_log("model r_hd.forw=%d\n", rt_glong(d->r_hd.forw) );
rt_log("model r_hd.back=%d\n", rt_glong(d->r_hd.back) );
d868 3
d879 2
d1024 1
a1024 1
		/***	INDEXL( d, vu, l ); ***/	/* tough */
a1083 3
#define INDEXL(oo,ii,elem)	{ \
	(ii)->elem.forw = (struct rt_list *)ptrs[rt_glong((oo)->elem.forw)]; \
	(ii)->elem.back = (struct rt_list *)ptrs[rt_glong((oo)->elem.back)]; }
a1103 1
/**	iindex = ecnt[index].per_struct_index; **/
a1114 3
rt_log("model ma_p index=%d\n", rt_glong(d->ma_p) );
rt_log("model r_hd.forw=%d\n", rt_glong(d->r_hd.forw) );
rt_log("model r_hd.back=%d\n", rt_glong(d->r_hd.back) );
d1198 3
d1325 2
d1367 1
a1367 1
		/***	INDEXL( d, vu, l ); ***/	/* tough */
d1487 2
a1488 2
		rt_log("%d of kind %s (%d)\n",
			kind_counts[kind], rt_nmg_kind_names[kind], kind);
a1493 1
rt_log("  magic=%4.4s\n", cp );
a1495 1
rt_log("   index=%d, kind=%s (%d)\n", subscript, rt_nmg_kind_names[kind], kind );
d1498 1
a1498 1
			ecnt[subscript].new_subscript = 0;
d1503 2
d1680 4
@


1.9
log
@Getting closer
@
text
@d19 1
a19 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.8 91/02/26 21:24:31 mike Exp $ (BRL)";
d1116 1
a1116 1
			INDEXL( d, m, r_hd );
d1140 1
a1140 1
			INDEXL( d, r, s_hd );
d1167 3
a1169 3
			INDEXL( d, s, fu_hd );
			INDEXL( d, s, lu_hd );
			INDEXL( d, s, eu_hd );
d1200 1
a1200 1
			INDEXL( d, fu, lu_hd );
d1258 1
a1258 1
			INDEXL( d, lu, down_hd );
d1393 1
a1393 1
			INDEXL( d, v, vu_hd );
@


1.8
log
@More code added.
@
text
@d19 1
a19 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.7 91/02/09 02:33:31 mike Exp $ (BRL)";
d213 1
d547 26
a572 2
#define NSTRUCTS	22
int	rt_disk_sizes[NSTRUCTS] = {
d596 24
d628 1
a628 1
		return 0;
d630 1
a630 1
		return 1;
d632 1
a632 1
		return 2;
d634 1
a634 1
		return 3;
d636 1
a636 1
		return 4;
d638 1
a638 1
		return 5;
d640 1
a640 1
		return 6;
d642 1
a642 1
		return 7;
d644 1
a644 1
		return 8;
d646 1
a646 1
		return 9;
d648 1
a648 1
		return 10;
d650 1
a650 1
		return 11;
d652 1
a652 1
		return 12;
d654 1
a654 1
		return 13;
d656 1
a656 1
		return 14;
d658 1
a658 1
		return 15;
d660 1
a660 1
		return 16;
d662 1
a662 1
		return 17;
d664 1
a664 1
		return 18;
d666 1
a666 1
		return 19;
d668 1
a668 1
		return 20;
d670 1
a670 1
		return 21;
d728 2
a729 2
		rt_log("rt_nmg_index_of_struct:  LIST HEAD!\n");
		return 0;
d732 2
a733 3
	rt_log("magicp = x%x, magic = x%x\n", p, *p);
	rt_bomb("rt_nmg_index_of_struct: bad magic");
	return -1;
d756 7
a762 1
		ret = ecnt[index].new_subscript;
d785 1
a785 2
	case 0:
		/* model */
d794 3
d799 1
a799 2
	case 1:
		/* model_a */
d808 1
a808 2
	case 2:
		/* region */
d821 1
a821 2
	case 3:
		/* region_a */
d835 1
a835 2
	case 4:
		/* shell */
d851 1
a851 2
	case 5:
		/* shell_a */
d865 1
a865 2
	case 6:
		/* faceuse */
d881 1
a881 2
	case 7:
		/* faceuse_a */
d890 1
a890 2
	case 8:
		/* face */
d901 1
a901 2
	case 9:
		/* face_g */
d919 1
a919 2
	case 10:
		/* loopuse */
d935 1
a935 2
	case 11:
		/* loopuse_a */
d944 1
a944 2
	case 12:
		/* loop */
d955 1
a955 2
	case 13:
		/* loop_g */
d969 1
a969 2
	case 14:
		/* edgeuse */
d986 1
a986 2
	case 15:
		/* edgeuse_a */
d995 1
a995 2
	case 16:
		/* edge */
d1006 1
a1006 2
	case 17:
		/* edge_g */
d1015 1
a1015 2
	case 18:
		/* vertexuse */
d1028 1
a1028 2
	case 19:
		/* vertexuse_a */
d1041 1
a1041 2
	case 20:
		/* vertex */
d1052 1
a1052 2
	case 21:
		/* vertex_g */
d1085 8
d1105 2
a1106 1
	iindex = ecnt[index].per_struct_index;
d1108 1
a1108 2
	case 0:
		/* model */
d1117 3
d1122 1
a1122 2
	case 1:
		/* model_a */
d1131 1
a1131 2
	case 2:
		/* region */
a1137 1
			INDEXL( d, r, l );
d1141 2
d1145 1
a1145 2
	case 3:
		/* region_a */
d1158 1
a1158 2
	case 4:
		/* shell */
a1164 1
			INDEXL( d, s, l );
d1171 2
d1175 1
a1175 2
	case 5:
		/* shell_a */
d1188 1
a1188 2
	case 6:
		/* faceuse */
a1194 1
			INDEXL( d, fu, l );
d1201 2
d1205 1
a1205 2
	case 7:
		/* faceuse_a */
d1214 1
a1214 2
	case 8:
		/* face */
d1223 1
d1226 1
a1226 2
	case 9:
		/* face_g */
d1242 1
a1242 2
	case 10:
		/* loopuse */
d1246 3
d1252 2
a1253 2
			INDEXL( d, lu, l );
			lu->up.magic_p = (long *)ptrs[rt_glong(d->up)];
d1259 7
d1268 1
a1268 2
	case 11:
		/* loopuse_a */
d1277 1
a1277 2
	case 12:
		/* loop */
d1286 1
d1289 1
a1289 2
	case 13:
		/* loop_g */
d1302 1
a1302 2
	case 14:
		/* edgeuse */
d1306 3
d1312 2
a1313 2
			INDEXL( d, eu, l );
			eu->up.magic_p = (long *)ptrs[rt_glong(d->up)];
d1320 8
d1330 1
a1330 2
	case 15:
		/* edgeuse_a */
d1339 1
a1339 2
	case 16:
		/* edge */
d1348 1
d1351 1
a1351 2
	case 17:
		/* edge_g */
d1360 1
a1360 2
	case 18:
		/* vertexuse */
d1371 1
d1374 1
a1374 2
	case 19:
		/* vertexuse_a */
d1386 1
a1386 2
	case 20:
		/* vertex */
d1397 1
a1397 2
	case 21:
		/* vertex_g */
d1418 5
d1434 2
a1435 2
	int				indices[NSTRUCTS];
	genptr_t			disk_arrays[NSTRUCTS];
d1437 1
d1444 2
d1466 3
a1468 3
	for( i = 0; i < NSTRUCTS; i++ )  {
		indices[i] = ((long *)&cntbuf)[i];
		maxindex += indices[i];
d1475 1
a1475 1
	ptrs = (long **)rt_calloc( maxindex+1,
d1477 5
d1486 5
a1490 4
	for( i = 0; i < NSTRUCTS; i++ )  {
		rt_log("%d of kind %d\n", indices[i], i);
		if( indices[i] <= 0 )  {
			disk_arrays[i] = GENPTR_NULL;
d1493 1
a1493 1
		disk_arrays[i] = (genptr_t)cp;
d1496 3
a1498 2
		for( j = 0; j < indices[i]; j++ )  {
			ecnt[subscript].kind = i;
d1501 2
a1502 2
			switch( i )  {
			case 0:
d1507 1
a1507 1
			case 1:
d1515 1
a1515 1
			case 2:
d1523 1
a1523 1
			case 3:
d1531 1
a1531 1
			case 4:
d1539 1
a1539 1
			case 5:
d1547 1
a1547 1
			case 6:
d1555 1
a1555 1
			case 7:
d1563 1
a1563 1
			case 8:
d1571 1
a1571 1
			case 9:
d1579 1
a1579 1
			case 10:
d1587 1
a1587 1
			case 11:
d1595 1
a1595 1
			case 12:
d1603 1
a1603 1
			case 13:
d1611 1
a1611 1
			case 14:
d1619 1
a1619 1
			case 15:
d1627 1
a1627 1
			case 16:
d1635 1
a1635 1
			case 17:
d1643 1
a1643 1
			case 18:
d1651 1
a1651 1
			case 19:
d1659 1
a1659 1
			case 20:
d1667 1
a1667 1
			case 21:
d1676 1
a1676 1
				rt_log("bad kind\n");
d1682 1
a1682 1
		cp += indices[i] * rt_disk_sizes[i];
d1698 3
d1708 1
d1724 3
a1726 3
	int				indices[NSTRUCTS];
	genptr_t			disk_arrays[NSTRUCTS];
	int				disk_sizes[NSTRUCTS];
d1744 2
a1745 2
	for( i = 0; i < NSTRUCTS; i++ )
		indices[i] = 0;
d1750 1
a1750 1
		ecnt[i].per_struct_index = indices[kind]++;
d1754 3
a1756 2
	for( kind = 0; kind < NSTRUCTS; kind++ )  {
		for( i=0; i < m->maxindex-1; i++ )  {
d1762 17
d1780 4
a1783 3
	for( i = 0; i < NSTRUCTS; i++ )  {
		rt_log("%d of kind %d\n", indices[i], i);
		if( indices[i] <= 0 )  {
d1787 1
a1787 1
		tot_size += indices[i] * rt_disk_sizes[i];
d1798 1
a1798 1
	for( i=0; i < NSTRUCTS; i++ )  {
d1800 1
a1800 1
		cp += indices[i] * rt_disk_sizes[i];
@


1.7
log
@Partway into importation now.
@
text
@d19 1
a19 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.6 91/02/09 01:38:55 mike Exp $ (BRL)";
d200 18
d234 3
a236 1
	return(-1);
d264 74
d772 1
d776 4
a779 3
/* XXX local2mm */
			htond( d->min_pt, r->min_pt, 3 );
			htond( d->max_pt, r->max_pt, 3 );
d804 1
d808 4
a811 3
/* XXX local2mm */
			htond( d->min_pt, sa->min_pt, 3 );
			htond( d->max_pt, sa->max_pt, 3 );
d858 2
d863 7
a869 4
/* XXX local2mm */
			htond( d->N, fg->N, 4 );
			htond( d->min_pt, fg->min_pt, 3 );
			htond( d->max_pt, fg->max_pt, 3 );
d916 1
d920 4
a923 3
/* XXX local2mm */
			htond( d->min_pt, lg->min_pt, 3 );
			htond( d->max_pt, lg->max_pt, 3 );
d995 1
d999 3
a1001 2
/* XXX local2mm */
			htond( d->N, vua->N, 4 );
d1021 1
d1025 2
a1026 2
/* XXX local2mm */
			htond( d->coord, vg->coord, 3 );
d1032 2
d1035 7
d1043 318
d1617 9
a1625 2
return(-1);
#if 0
d1628 1
a1628 3
	ip->idb_ptr = rt_malloc( sizeof(struct model), "model");
	m = (struct model *)ip->idb_ptr;
	m->magic = RT_NMG_INTERNAL_MAGIC;
a1630 1
#endif
@


1.6
log
@Added ASCII-legible magic numbers for disk versions of nmg structs
@
text
@d19 1
a19 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.5 91/02/08 02:48:33 mike Exp $ (BRL)";
a272 47
/*
 *			R T _ N M G _ I M P O R T
 *
 *  Import an NMG from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_nmg_import( ip, ep, mat )
struct rt_db_internal	*ip;
struct rt_external	*ep;
register mat_t		mat;
{
	LOCAL struct model		*m;
	union record			*rp;
	struct nmg_struct_counts	cntbuf;
	struct rt_external		count_ext;

	RT_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != DBID_NMG )  {
		rt_log("rt_nmg_import: defective record\n");
		return(-1);
	}

	bzero( (char *)&cntbuf, sizeof(cntbuf) );
	RT_INIT_EXTERNAL(&count_ext);
	count_ext.ext_nbytes = sizeof(rp->nmg.N_structs);
	count_ext.ext_buf = rp->nmg.N_structs;
	if( rt_struct_import( (genptr_t)&cntbuf, rt_nmg_structs_fmt, &count_ext ) <= 0 )  {
		rt_log("rt_struct_import failure\n");
		return(-1);
	}
	nmg_pr_struct_counts( &cntbuf, "After import" );

return(-1);
#if 0
	RT_INIT_DB_INTERNAL( ip );
	ip->idb_type = ID_NMG;
	ip->idb_ptr = rt_malloc( sizeof(struct model), "model");
	m = (struct model *)ip->idb_ptr;
	m->magic = RT_NMG_INTERNAL_MAGIC;

	return(0);			/* OK */
#endif
}

d923 269
@


1.5
log
@Beginning to take shape.
@
text
@d19 1
a19 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.4 91/02/08 00:34:29 mike Exp $ (BRL)";
d330 1
d337 1
d342 1
d351 1
d358 1
d370 1
d377 1
d384 1
d392 1
d404 1
d409 1
d416 1
d423 1
d435 1
d440 1
d447 1
d452 1
d465 1
d470 1
d477 1
d483 1
d492 1
d691 1
a691 1
			rt_plong( d->magic, m->magic );
d703 1
a703 1
			rt_plong( d->magic, ma->magic );	/* NOOP */
d713 1
a713 1
			rt_plong( d->magic, r->l.magic );
d727 1
d740 1
a740 1
			rt_plong( d->magic, s->l.magic );
d757 2
a758 1
			rt_plong( d->magic, sa->magic );
d770 1
a770 1
			rt_plong( d->magic, fu->l.magic );
d787 1
a787 1
			rt_plong( d->magic, fua->magic );	/* NOOP */
d797 1
a797 1
			rt_plong( d->magic, f->magic );
d809 2
a810 1
			rt_plong( d->magic, fg->magic );
d823 1
a823 1
			rt_plong( d->magic, lu->l.magic );
d840 1
a840 1
			rt_plong( d->magic, lua->magic );	/* NOOP */
d850 1
a850 1
			rt_plong( d->magic, loop->magic );
d862 2
a863 1
			rt_plong( d->magic, lg->magic );
d875 1
a875 1
			rt_plong( d->magic, eu->l.magic );
d893 1
a893 1
			rt_plong( d->magic, eua->magic );	/* NOOP */
d903 1
a903 1
			rt_plong( d->magic, e->magic );
d915 1
a915 1
			rt_plong( d->magic, eg->magic );	/* NOOP */
d925 1
a925 1
			rt_plong( d->magic, vu->l.magic );
d939 2
a940 1
			rt_plong( d->magic, vua->magic );
d951 1
a951 1
			rt_plong( d->magic, v->magic );
d963 2
a964 1
			rt_plong( d->magic, vg->magic );
@


1.4
log
@More typing
@
text
@d19 1
a19 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.3 91/02/07 22:51:37 mike Exp $ (BRL)";
d322 1
a322 1
typedef	long		index_t;
d331 1
a334 5
struct rt_imexport rt_fmt_disk_model[] = {
	"%d",	offsetof(struct disk_model, ma_p),		1,
	"%d",	offsetof(struct disk_model, r_hd),		2,
	"",	0,						0
};
d337 1
a337 1
	long			magic;
a338 4
struct rt_imexport rt_fmt_disk_model_a[] = {
	"%d",	offsetof(struct disk_model_a, magic),		1,
	"",	0,						0
};
d341 1
a346 7
struct rt_imexport rt_fmt_disk_nmgregion[] = {
	"%d",	offsetof(struct disk_nmgregion, l),		2,
	"%d",	offsetof(struct disk_nmgregion, m_p),		1,
	"%d",	offsetof(struct disk_nmgregion, ra_p),		1,
	"%d",	offsetof(struct disk_nmgregion, s_hd),		2,
	"",	0,						0
};
d349 3
a351 2
	fastf_t			min_pt[3];
	fastf_t			max_pt[3];
a352 5
struct rt_imexport rt_fmt_nmgregion_a[] = {
	"%f",	offsetofarray(struct nmgregion_a, min_pt),	3,
	"%f",	offsetofarray(struct nmgregion_a, max_pt),	3,
	"",	0,						0
};
d355 1
a363 10
struct rt_imexport rt_fmt_disk_shell[] = {
	"%d",	offsetof(struct disk_shell, l),			2,
	"%d",	offsetof(struct disk_shell, r_p),		1,
	"%d",	offsetof(struct disk_shell, sa_p),		1,
	"%d",	offsetof(struct disk_shell, fu_hd),		2,
	"%d",	offsetof(struct disk_shell, lu_hd),		2,
	"%d",	offsetof(struct disk_shell, eu_hd),		2,
	"%d",	offsetof(struct disk_shell, vu_p),		1,
	"",	0,						0
};
d366 3
a368 2
	fastf_t			min_pt[3];
	fastf_t			max_pt[3];
a369 5
struct rt_imexport rt_fmt_disk_shell_a[] = {
	"%f",	offsetofarray(struct disk_shell_a, min_pt),	3,
	"%f",	offsetofarray(struct disk_shell_a, max_pt),	3,
	"",	0,						0
};
d372 1
a375 5
struct rt_imexport rt_fmt_disk_face[] = {
	"%d",	offsetof(struct disk_face, fu_p),		1,
	"%d",	offsetof(struct disk_face, fg_p),		1,
	"",	0,						0
};
d378 4
a381 3
	fastf_t			N[4];
	fastf_t			min_pt[3];
	fastf_t			max_pt[3];
a382 6
struct rt_imexport rt_fmt_disk_face_g[] = {
	"%f",	offsetofarray(struct disk_face_g, N),		4,
	"%f",	offsetofarray(struct disk_face_g, min_pt),	3,
	"%f",	offsetofarray(struct disk_face_g, max_pt),	3,
	"",	0,						0
};
d385 1
d389 1
a389 1
	int			orientation;
a393 10
struct rt_imexport rt_fmt_faceuse[] = {
	"%d",	offsetof(struct faceuse, l),			2,
	"%d",	offsetof(struct faceuse, s_p),			1,
	"%d",	offsetof(struct faceuse, fumate_p),		1,
	"%d",	offsetof(struct faceuse, orientation),		1,
	"%d",	offsetof(struct faceuse, f_p),			1,
	"%d",	offsetof(struct faceuse, fua_p),		1,
	"%d",	offsetof(struct faceuse, lu_hd),		2,
	"",	0,						0
};
d396 1
a396 1
	long			magic;
a397 4
struct rt_imexport rt_fmt_faceuse_a[] = {
	"%d",	offsetof(struct faceuse_a, magic),		1,
	"",	0,						0
};
d400 1
a403 5
struct rt_imexport rt_fmt_disk_loop[] = {
	"%d",	offsetof(struct disk_loop, lu_p),		1,
	"%d",	offsetof(struct disk_loop, lg_p),		1,
	"",	0,						0
};
d406 3
a408 2
	fastf_t			min_pt[3];
	fastf_t			max_pt[3];
a409 5
struct rt_imexport rt_fmt_disk_loop_g[] = {
	"%f",	offsetofarray(struct disk_loop_g, min_pt),	3,
	"%f",	offsetofarray(struct disk_loop_g, max_pt),	3,
	"",	0,						0
};
d412 1
d416 1
a416 1
	int			orientation;
a420 10
struct rt_imexport rt_fmt_disk_loopuse[] = {
	"%d",	offsetof(struct disk_loopuse, l),		2,
	"%d",	offsetof(struct disk_loopuse, up),		1,
	"%d",	offsetof(struct disk_loopuse, lumate_p),	1,
	"%d",	offsetof(struct disk_loopuse, orientation),	1,
	"%d",	offsetof(struct disk_loopuse, l_p),		1,
	"%d",	offsetof(struct disk_loopuse, lua_p),		1,
	"%d",	offsetof(struct disk_loopuse, down_hd),		2,
	"",	0,						0
};
d423 1
a423 1
	long			magic;
a424 4
struct rt_imexport rt_fmt_disk_loopuse_a[] = {
	"%d",	offsetof(struct loopuse_a, magic),		1,
	"",	0,						0
};
d427 1
a430 5
struct rt_imexport rt_fmt_disk_edge[] = {
	"%d",	offsetof(struct disk_edge, eu_p),		1,
	"%d",	offsetof(struct disk_edge, eg_p),		1,
	"",	0,						0
};
d433 1
a433 1
	long			magic;
a434 4
struct rt_imexport rt_fmt_disk_edge_g[] = {
	"%d",	offsetof(struct disk_edge_g, magic),		1,
	"",	0,						0
};
d437 1
d444 1
a444 1
	int	  		orientation;
a446 11
struct rt_imexport rt_fmt_edgeuse[] = {
	"%d",	offsetof(struct edgeuse, l),			2,
	"%d",	offsetof(struct edgeuse, up),			1,
	"%d",	offsetof(struct edgeuse, eumate_p),		1,
	"%d",	offsetof(struct edgeuse, radial_p),		1,
	"%d",	offsetof(struct edgeuse, e_p),			1,
	"%d",	offsetof(struct edgeuse, eua_p),		1,
	"%d",	offsetof(struct edgeuse, orientation),		1,
	"%d",	offsetof(struct edgeuse, vu_p),			1,
	"",	0,						0
};
d449 1
a449 1
	long			magic;
a450 4
struct rt_imexport rt_fmt_edgeuse_a[] = {
	"%d",	offsetof(struct edgeuse_a, magic),		1,
	"",	0,						0
};
d453 1
a456 5
struct rt_imexport rt_fmt_disk_vertex[] = {
	"%d",	offsetof(struct disk_vertex, vu_hd),		2,
	"%d",	offsetof(struct disk_vertex, vg_p),		1,
	"",	0,						0
};
d459 2
a460 1
	fastf_t			coord[3];
a461 4
struct rt_imexport rt_fmt_disk_vertex_g[] = {
	"%f",	offsetofarray(struct disk_vertex_g, coord),	3,
	"",	0,						0
};
d464 1
a469 7
struct rt_imexport rt_fmt_vertexuse[] = {
	"%d",	offsetof(struct vertexuse, l),			2,
	"%d",	offsetof(struct vertexuse, up),			1,
	"%d",	offsetof(struct vertexuse, v_p),		1,
	"%d",	offsetof(struct vertexuse, vua_p),		1,
	"",	0,						0
};
d472 2
a473 1
	fastf_t			N[3];
a474 4
struct rt_imexport rt_fmt_vertexuse_a[] = {
	"%f",	offsetofarray(struct vertexuse_a, N),		3,
	"",	0,						0
};
d609 3
d625 21
a645 2
#define REINDEX(p)	(ecnt[nmg_index_of_struct((long *)(p))].new_subscript)
#define INDEX(o,i,elem)		(o)->elem = REINDEX((i)->elem)
d647 2
a648 2
	(oo)->elem.forw = REINDEX((ii)->elem.forw); \
	(oo)->elem.back = REINDEX((ii)->elem.back); }
d650 2
a651 1
rt_nmg_edisk( op, ip, ecnt, index )
d656 1
d669 1
d681 1
a681 1
			d->magic = ma->magic;	/* NOOP */
d691 1
d705 3
a707 2
			VMOVE( d->min_pt, r->min_pt );
			VMOVE( d->max_pt, r->max_pt );
d717 1
d734 3
a736 2
			VMOVE( d->min_pt, sa->min_pt );
			VMOVE( d->max_pt, sa->max_pt );
d746 1
d750 1
a750 1
			d->orientation = fu->orientation;
d763 1
a763 1
			d->magic = fua->magic;	/* NOOP */
d773 1
d785 4
a788 3
			VMOVEN( d->N, fg->N, 4 );
			VMOVE( d->min_pt, fg->min_pt );
			VMOVE( d->max_pt, fg->max_pt );
d798 1
d800 1
a800 1
			d->up = REINDEX(lu->up.magic_p);
d802 1
a802 1
			d->orientation = lu->orientation;
d815 1
a815 1
			d->magic = lua->magic;	/* NOOP */
d821 1
a821 1
			struct loop	*l = (struct loop *)ip;
d824 4
a827 3
			NMG_CK_LOOP(l);
			INDEX( d, l, lu_p );
			INDEX( d, l, lg_p );
d837 3
a839 2
			VMOVE( d->min_pt, lg->min_pt );
			VMOVE( d->max_pt, lg->max_pt );
d849 1
d851 1
a851 1
			d->up = REINDEX(eu->up.magic_p);
d856 1
a856 1
			d->orientation = eu->orientation;
d867 1
a867 1
			d->magic = eua->magic;	/* NOOP */
d877 1
d889 1
a889 1
			d->magic = eg->magic;	/* NOOP */
d899 3
a901 2
			INDEXL( d, vu, l );
			d->up = REINDEX(vu->up.magic_p);
d913 2
a914 1
			VMOVEN( d->N, vua->N, 4 );
d924 1
d936 2
a937 1
			VMOVE( d->coord, vg->coord );
d941 1
d965 3
d969 1
d1000 1
d1007 1
a1007 2
		disk_arrays[i] = (genptr_t)rt_calloc( indices[i],
			rt_disk_sizes[i], "disk_arrays[i]" );
d1009 7
d1017 6
d1027 1
a1027 1
		rt_nmg_edisk( disk_arrays[kind], ptrs[i], ecnt, i );
a1028 7

	RT_INIT_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "nmg external");
	rp = (union record *)ep->ext_buf;
	rp->nmg.N_id = DBID_NMG;
	rp->nmg.N_count = 0;		/* XXX for now */
@


1.3
log
@Lots of typeing
@
text
@d19 1
a19 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.2 91/02/07 20:32:21 mike Exp $ (BRL)";
d589 26
d617 1
a617 1
rt_nmg_magic_to_subscript( magic )
a620 3
	default:
		rt_bomb("rt_nmg_magic_to_subscript: bad magic");
		return -1;
d666 4
d672 342
a1029 4
	struct nmg_exp_counts {
		long	new_subscript;
		long	per_struct_index;
	};
d1033 3
a1035 1
	int				indices[22];
d1049 1
a1049 1
	for( i = 0; i < 22; i++ )
d1054 3
a1056 3
		ecnt[i].new_subscript = subscript++;
		ecnt[i].per_struct_index = indices[
			rt_nmg_magic_to_subscript( (long)(ptrs[i]) )]++;
d1058 9
a1066 1
	for( i = 0; i < 22; i++ )
d1068 14
@


1.2
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d19 1
a19 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.1 91/02/07 01:11:33 mike Exp $ (BRL)";
d320 325
d661 8
d678 15
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSnmg[] = "@@(#)$Header: /m/cad/librt/RCS/g_nmg.c,v 1.5 91/01/28 23:53:26 mike Exp $ (BRL)";
d335 1
d343 1
a343 1
	nmg_m_struct_count( &cntbuf, m );
@
