head	1.40;
access;
symbols
	ansi-20040405-merged:1.34.2.2
	postmerge-20040405-ansi:1.38
	premerge-20040404-ansi:1.37
	postmerge-autoconf:1.37
	autoconf-freeze:1.35.6.2
	premerge-autoconf:1.37
	ansi-20040316-freeze:1.34.2.1
	postmerge-20040315-windows:1.37
	premerge-20040315-windows:1.36
	windows-20040315-freeze:1.34.4.2
	autoconf-20031203:1.35
	autoconf-20031202:1.35
	autoconf-branch:1.35.0.6
	phong-branch:1.35.0.4
	photonmap-branch:1.35.0.2
	rel-6-1-DP:1.34
	windows-branch:1.34.0.4
	rel-6-0-2:1.32
	ansi-branch:1.34.0.2
	rel-6-0-1-branch:1.32.0.2
	hartley-6-0-post:1.33
	hartley-6-0-pre:1.32
	rel-6-0-1:1.32
	rel-6-0:1.31
	rel-5-4:1.12
	offsite-5-3-pre:1.16
	rel-5-3:1.12
	rel-5-2:1.12
	rel-5-1-branch:1.12.0.2
	rel-5-1:1.12;
locks; strict;
comment	@ * @;


1.40
date	2004.05.21.18.07.35;	author morrison;	state dead;
branches;
next	1.39;

1.39
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.16.20.03.10;	author morrison;	state Exp;
branches;
next	1.36;

1.36
date	2004.02.02.17.39.29;	author morrison;	state Exp;
branches;
next	1.35;

1.35
date	2003.04.02.15.16.15;	author jra;	state Exp;
branches
	1.35.6.1;
next	1.34;

1.34
date	2002.08.20.17.08.10;	author jra;	state Exp;
branches
	1.34.2.1
	1.34.4.1;
next	1.33;

1.33
date	2002.08.15.20.55.22;	author hartley;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.18.19.56.06;	author rbowers;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.12.18.22.44;	author bparker;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.15.20.37.35;	author bparker;	state Exp;
branches;
next	1.29;

1.29
date	2001.10.03.15.29.26;	author bparker;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.19.15.31.32;	author bparker;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.18.15.28.29;	author bparker;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.14.18.13.50;	author bparker;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.19.15.34.49;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.05.15.47.42;	author bparker;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.01.22.15.25;	author bparker;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.01.17.20.43;	author bparker;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.02.22.25.31;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.02.14.07.06;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.20.22.29.57;	author morrison;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.02.21.38.10;	author morrison;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.31.01.57.12;	author morrison;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.09.15.17.02;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.18.18.10.36;	author butler;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.23.01.09.17;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.25.16.46.06;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.26.14.32.20;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.19.18.51.07;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.03.18.46.34;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.22.21.40.50;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.18.21.06.30;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.31.15.01.28;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.28.16.13.27;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.10.22.51.28;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.03.21.50.38;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.03.15.07.42;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	99.12.28.15.42.22;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	99.12.27.20.49.55;	author bparker;	state Exp;
branches;
next	;

1.34.2.1
date	2002.09.19.18.01.48;	author morrison;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2004.03.17.21.19.00;	author morrison;	state Exp;
branches;
next	;

1.34.4.1
date	2002.09.26.23.04.04;	author morrison;	state Exp;
branches;
next	1.34.4.2;

1.34.4.2
date	2004.03.11.23.43.47;	author morrison;	state Exp;
branches;
next	;

1.35.6.1
date	2004.02.12.18.37.48;	author erikg;	state Exp;
branches;
next	1.35.6.2;

1.35.6.2
date	2004.03.18.18.10.29;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.40
log
@moved to src/
@
text
@/*
 *				V I E W _ O B J . C
 *
 * A view object contains the attributes and methods for
 * controlling viewing transformations. Much of this code
 * was extracted from MGED and modified to work herein.
 * 
 * Source -
 *	SLAD CAD Team
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 * Author -
 *	Robert G. Parker
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#include "tcl.h"
#include "machine.h"
#include "externs.h"
#include "cmd.h"		/* includes bu.h */
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"


int Vo_Init(Tcl_Interp *interp);

static int vo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_size_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_invSize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_aet_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_rmat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_center_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_model2view_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_pmodel2view_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_view2model_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_perspective_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_pmat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_rot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_tra_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_sca_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_slew_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

static int vo_eye_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_eye_pos_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_lookat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_orientation_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_pov_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_units_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_zoom_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_local2base_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_base2local_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_coord_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_rotate_about_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_keypoint_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_setview_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_arot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_vrot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_mrot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

static int vo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
void vo_update(struct view_obj *vop, Tcl_Interp *interp, int oflag);
void vo_mat_aet(struct view_obj *vop);
static void vo_persp_mat(fastf_t *m, fastf_t fovy, fastf_t aspect, fastf_t near1, fastf_t far1, fastf_t backoff);
static void vo_mike_persp_mat(fastf_t *pmat, const fastf_t *eye);

struct view_obj HeadViewObj;		/* head of view object list */

static struct bu_cmdtab vo_cmds[] = 
{
	{"ae",			vo_aet_tcl},
	{"arot",		vo_arot_tcl},
	{"base2local",		vo_base2local_tcl},
	{"center",		vo_center_tcl},
	{"coord",		vo_coord_tcl},
	{"eye",			vo_eye_tcl},
	{"eye_pos",		vo_eye_pos_tcl},
	{"invSize",		vo_invSize_tcl},
	{"keypoint",		vo_keypoint_tcl},
	{"local2base",		vo_local2base_tcl},
	{"lookat",		vo_lookat_tcl},
	{"model2view",		vo_model2view_tcl},
	{"mrot",		vo_mrot_tcl},
	{"observer",		vo_observer_tcl},
	{"orientation",		vo_orientation_tcl},
	{"perspective",		vo_perspective_tcl},
	{"pmat",		vo_pmat_tcl},
	{"pmodel2view",		vo_pmodel2view_tcl},
	{"pov",			vo_pov_tcl},
	{"rmat",		vo_rmat_tcl},
	{"rot",			vo_rot_tcl},
	{"rotate_about",	vo_rotate_about_tcl},
	{"sca",			vo_sca_tcl},
	{"setview",		vo_setview_tcl},
	{"size",		vo_size_tcl},
	{"slew",		vo_slew_tcl},
	{"tra",			vo_tra_tcl},
	{"units",		vo_units_tcl},
	{"view2model",		vo_view2model_tcl},
	{"vrot",		vo_vrot_tcl},
	{"zoom",		vo_zoom_tcl},
#if 0
	{"knob",		vo_knob_tcl},
	{"qorot",		vo_qorot_tcl},
	{"qvrot",		vo_qvrot_tcl},
	{"status",		vo_status_tcl},
	{"",		vo__tcl},
#endif
	{(char *)0,		(int (*)())0}
};

static int
vo_cmd(ClientData	clientData,
       Tcl_Interp	*interp,
       int		argc,
       char		**argv)
{
	return bu_cmd(clientData, interp, argc, argv, vo_cmds, 1);
}

int
Vo_Init(Tcl_Interp *interp)
{
	BU_LIST_INIT(&HeadViewObj.l);
	(void)Tcl_CreateCommand(interp, "v_open", vo_open_tcl,
				(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

	return TCL_OK;
}

static void
vo_deleteProc(ClientData clientData)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	/* free observers */
	bu_observer_free(&vop->vo_observers);

	bu_vls_free(&vop->vo_name);
	BU_LIST_DEQUEUE(&vop->l);
	bu_free((genptr_t)vop, "vo_deleteProc: vop");
}

/*
 * Create an command/object named "oname" in "interp".
 */
struct view_obj *
vo_open_cmd(char	*oname)
{
	Tcl_Interp	*interp = (Tcl_Interp *)NULL;
	struct view_obj *vop;

	BU_GETSTRUCT(vop,view_obj);

	/* initialize view_obj */
	bu_vls_init(&vop->vo_name);
	bu_vls_strcpy(&vop->vo_name, oname);
	vop->vo_scale = 1.0;
	vop->vo_size = 2.0 * vop->vo_scale;
	vop->vo_invSize = 1.0 / vop->vo_size;
	vop->vo_local2base = 1.0;		/* default units - mm */
	vop->vo_base2local = 1.0;		/* default units - mm */
	VSET(vop->vo_eye_pos, 0.0, 0.0, 1.0);
	MAT_IDN(vop->vo_rotation);
	MAT_IDN(vop->vo_center);
	VSETALL(vop->vo_keypoint, 0.0);
	vop->vo_coord = 'v';
	vop->vo_rotate_about = 'v';
	vo_update(vop, interp, 0);
	BU_LIST_INIT(&vop->vo_observers.l);
	vop->vo_callback = (void (*)())0;

	/* append to list of view_obj's */
	BU_LIST_APPEND(&HeadViewObj.l,&vop->l);

	return vop;
}

/*
 * Open a view object.
 *
 * USAGE: v_open [name]
 */
static int
vo_open_tcl(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	struct view_obj *vop;

	if (argc == 1) {
		/* get list of view objects */
		for (BU_LIST_FOR(vop, view_obj, &HeadViewObj.l))
			Tcl_AppendResult(interp, bu_vls_addr(&vop->vo_name), " ", (char *)NULL);

		return TCL_OK;
	}

	/* first, delete any commands by this name */
	(void)Tcl_DeleteCommand(interp, argv[1]);

	vop = vo_open_cmd(argv[1]);
	(void)Tcl_CreateCommand(interp,
				bu_vls_addr(&vop->vo_name),
				(Tcl_CmdProc *)vo_cmd,
				(ClientData)vop,
				vo_deleteProc);

	/* Return new function name as result */
	Tcl_ResetResult(interp);
	Tcl_AppendResult(interp, bu_vls_addr(&vop->vo_name), (char *)NULL);

	return TCL_OK;
}

/****************** View Object Methods ********************/

#if 0
/* skeleton functions for view_obj methods */
int
vo__cmd(struct view_obj	*vop,
	 Tcl_Interp	*interp,
	 int		argc,
	 char 		**argv)
{
}

/*
 * Usage:
 *        procname 
 */
static int
vo__tcl(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo__cmd(vop, interp, argc-1, argv+1);
}
#endif

void
vo_size(struct view_obj	*vop,
	Tcl_Interp	*interp,
	fastf_t		size)
{
	vop->vo_size = vop->vo_local2base * size;
	if (vop->vo_size < RT_MINVIEWSIZE)
		vop->vo_size = RT_MINVIEWSIZE;
	vop->vo_invSize = 1.0 / vop->vo_size;
	vop->vo_scale = 0.5 * vop->vo_size;
	vo_update(vop, interp, 1);
}

int
vo_size_cmd(struct view_obj	*vop,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv)
{
	struct bu_vls vls;
	fastf_t size;

	/* get view size */
	if (argc == 1) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%g", vop->vo_size * vop->vo_base2local);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	/* set view size */
	if (argc == 2) {
		if (sscanf(argv[1], "%lf", &size) != 1 ||
		    size <= 0 ||
		    NEAR_ZERO(size, SMALL_FASTF)) {
			Tcl_AppendResult(interp, "bad size - ",
					 argv[1], (char *)NULL);
			return TCL_ERROR;
		}

		vo_size(vop, interp, size);
		return TCL_OK;
	}

	/* compose error message */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_size %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Get or set the view size.
 *
 * Usage:
 *        procname size [s]
 */
static int
vo_size_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_size_cmd(vop, interp, argc-1, argv+1);
}

int
vo_invSize_cmd(struct view_obj	*vop,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	struct bu_vls vls;

	if (argc == 1) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%g", vop->vo_invSize * vop->vo_base2local);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	/* compose error message */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_invSize %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Get the inverse view size.
 *
 * Usage:
 *        procname 
 */
static int
vo_invSize_tcl(ClientData	clientData,
		Tcl_Interp	*interp,
		int		argc,
		char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_invSize_cmd(vop, interp, argc-1, argv+1);
}

int
vo_aet_cmd(struct view_obj	*vop,
	   Tcl_Interp		*interp,
	   int			argc,
	   char 		**argv)
{
	struct bu_vls	vls;
	vect_t		aet;
	int		iflag = 0;

	if (argc == 1) { /* get aet */
		bu_vls_init(&vls);
		bn_encode_vect(&vls, vop->vo_aet);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	/* Check for -i option */
	if (argv[1][0] == '-' && argv[1][1] == 'i') {
		iflag = 1;  /* treat arguments as incremental values */
		++argv;
		--argc;
	}

	if (argc == 2) {  /* set aet */
		int n;

		if ((n = bn_decode_vect(aet, argv[1])) == 2)
			aet[2] = 0;
		else if (n != 3)
			goto bad;

		if (iflag) {
			VADD2(vop->vo_aet, vop->vo_aet, aet);
		} else {
			VMOVE(vop->vo_aet, aet);
		}
		vo_mat_aet(vop);
		vo_update(vop, interp, 1);

		return TCL_OK;
	}

	if (argc == 3 || argc == 4) {
		if (sscanf(argv[1], "%lf", &aet[X]) != 1) {
			Tcl_AppendResult(interp, "vo_aet: bad azimuth - ", argv[1], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[2], "%lf", &aet[Y]) != 1) {
			Tcl_AppendResult(interp, "vo_aet: bad elevation - ", argv[2], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (argc == 4) {
			if (sscanf(argv[3], "%lf", &aet[Z]) != 1) {
				Tcl_AppendResult(interp, "vo_aet: bad twist - ", argv[3], "\n", (char *)0);
				return TCL_ERROR;
			}
		} else
			aet[Z] = 0.0;

		if (iflag) {
			VADD2(vop->vo_aet, vop->vo_aet, aet);
		} else {
			VMOVE(vop->vo_aet, aet);
		}
		vo_mat_aet(vop);
		vo_update(vop, interp, 1);

		return TCL_OK;
	}

 bad:
	/* compose error message */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_aet %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Get or set the azimuth, elevation and twist.
 *
 * Usage:
 *        procname ae [[-i] az el [tw]]
 */
static int
vo_aet_tcl(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_aet_cmd(vop, interp, argc-1, argv+1);
}

int
vo_rmat_cmd(struct view_obj	*vop,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv)
{
	struct bu_vls vls;
	mat_t rotation;

	if (argc == 1) { /* get rotation matrix */
		bu_vls_init(&vls);
		bn_encode_mat(&vls, vop->vo_rotation);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	} else if (argc == 2) {  /* set rotation matrix */
		if (bn_decode_mat(rotation, argv[1]) != 16)
			return TCL_ERROR;

		MAT_COPY(vop->vo_rotation, rotation);
		vo_update(vop, interp , 1);

		return TCL_OK;
	}

	/* compose error message */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_rmat %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Get or set the rotation matrix.
 *
 * Usage:
 *        procname 
 */
static int
vo_rmat_tcl(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_rmat_cmd(vop, interp, argc-1, argv+1);
}

void
vo_center(struct view_obj	*vop,
	  Tcl_Interp		*interp,
	  point_t		center)
{
	VSCALE(center, center, vop->vo_local2base);
	MAT_DELTAS_VEC_NEG(vop->vo_center, center);
	vo_update(vop, interp, 1);
}

int
vo_center_cmd(struct view_obj	*vop,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{
	point_t		center;
	struct bu_vls	vls;


	/* get view center */
	if (argc == 1) {
		MAT_DELTAS_GET_NEG(center, vop->vo_center);
		VSCALE(center, center, vop->vo_base2local);
		bu_vls_init(&vls);
		bn_encode_vect(&vls, center);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	/* set view center */
	if (argc == 2 || argc == 4) {
		if (argc == 2) {
			if (bn_decode_vect(center, argv[1]) != 3)
				goto bad;
		} else {
			if (sscanf(argv[1], "%lf", &center[X]) != 1) {
				Tcl_AppendResult(interp, "vo_center: bad X value - ", argv[1], "\n", (char *)0);
				return TCL_ERROR;
			}

			if (sscanf(argv[2], "%lf", &center[Y]) != 1) {
				Tcl_AppendResult(interp, "vo_center: bad Y value - ", argv[2], "\n", (char *)0);
				return TCL_ERROR;
			}

			if (sscanf(argv[3], "%lf", &center[Z]) != 1) {
				Tcl_AppendResult(interp, "vo_center: bad Z value - ", argv[3], "\n", (char *)0);
				return TCL_ERROR;
			}
		}

		vo_center(vop, interp, center);
		return TCL_OK;
	}

 bad:
	/* compose error message */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_center %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Get or set the view center.
 *
 * Usage:
 *        procname 
 */
static int
vo_center_tcl(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_center_cmd(vop, interp, argc-1, argv+1);
}

int
vo_model2view_cmd(struct view_obj	*vop,
		  Tcl_Interp		*interp,
		  int			argc,
		  char 			**argv)
{
	struct bu_vls vls;

	if (argc == 1) {
		bu_vls_init(&vls);
		bn_encode_mat(&vls, vop->vo_model2view);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	/* compose error message */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_model2view %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Get the model2view matrix.
 *
 * Usage:
 *        procname 
 */
static int
vo_model2view_tcl(ClientData	clientData,
		  Tcl_Interp	*interp,
		  int		argc,
		  char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_model2view_cmd(vop, interp, argc-1, argv+1);
}

int
vo_pmodel2view_cmd(struct view_obj	*vop,
		   Tcl_Interp		*interp,
		   int			argc,
		   char 		**argv)
{
	struct bu_vls vls;

	if (argc == 1) {
		bu_vls_init(&vls);
		bn_encode_mat(&vls, vop->vo_pmodel2view);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	/* compose error message */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_pmodel2view %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Get the pmodel2view matrix.
 *
 * Usage:
 *        procname pmodel2view
 */
static int
vo_pmodel2view_tcl(ClientData	clientData,
		   Tcl_Interp	*interp,
		   int		argc,
		   char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_pmodel2view_cmd(vop, interp, argc-1, argv+1);
}

int
vo_view2model_cmd(struct view_obj	*vop,
		  Tcl_Interp		*interp,
		  int			argc,
		  char 			**argv)
{
	struct bu_vls vls;

	if (argc == 1) {
		bu_vls_init(&vls);
		bn_encode_mat(&vls, vop->vo_view2model);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	/* compose error message */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_view2model %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Usage:
 *        procname view2model
 */
static int
vo_view2model_tcl(ClientData	clientData,
		  Tcl_Interp	*interp,
		  int		argc,
		  char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_view2model_cmd(vop, interp, argc-1, argv+1);
}

int
vo_perspective_cmd(struct view_obj	*vop,
		   Tcl_Interp		*interp,
		   int			argc,
		   char 		**argv)
{
	struct bu_vls vls;
	fastf_t perspective;

	/* get the perspective angle */
	if (argc == 1) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%g", vop->vo_perspective);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	/* set the perspective angle */
	if (argc == 2) {
		if (sscanf(argv[1], "%lf", &perspective) != 1) {
			Tcl_AppendResult(interp, "bad perspective angle - ",
					 argv[1], (char *)NULL);
			return TCL_ERROR;
		}

		vop->vo_perspective = perspective;

#if 1
		/* This way works, with reasonable Z-clipping */
		vo_persp_mat(vop->vo_pmat, vop->vo_perspective,
			     1.0, 0.01, 1.0e10, 1.0);
#else
		vo_mike_persp_mat(vop->vo_pmat, vop->vo_eye_pos);
#endif
		vo_update(vop, interp, 1);

		return TCL_OK;
	}

	/* Compose error message */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_perspective %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Get/set the perspective angle.
 *
 * Usage:
 *        procname perspective [angle]
 */
static int
vo_perspective_tcl(ClientData	clientData,
		   Tcl_Interp	*interp,
		   int		argc,
		   char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_perspective_cmd(vop, interp, argc-1, argv+1);
}

int
vo_pmat_cmd(struct view_obj	*vop,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv)
{
	struct bu_vls vls;

	if (argc == 1) {
		bu_vls_init(&vls);
		bn_encode_mat(&vls, vop->vo_pmat);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	/* compose error message */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_pmat %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Get the perspective matrix.
 *
 * Usage:
 *        procname pmat
 */
static int
vo_pmat_tcl(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_pmat_cmd(vop, interp, argc-1, argv+1);
}

int
vo_eye_cmd(struct view_obj	*vop,
	   Tcl_Interp		*interp,
	   int			argc,
	   char 		**argv)
{
	point_t		eye_model;
	vect_t		xlate;
	vect_t		new_cent;
	struct bu_vls 	vls;

	/* get eye */
	if (argc == 1) {
	  point_t eye;

	  /* calculate eye point */
	  VSET(xlate, 0.0, 0.0, 1.0);
	  MAT4X3PNT(eye, vop->vo_view2model, xlate);
	  VSCALE(eye, eye, vop->vo_base2local);

	  bu_vls_init(&vls);
	  bn_encode_vect(&vls, eye);
	  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	  bu_vls_free(&vls);

	  return TCL_OK;
	}

	if (argc != 2 && argc != 4)
		goto bad;

	if (argc == 2) {
		if (bn_decode_vect(eye_model, argv[1]) != 3)
			goto bad;
	} else {
		if (sscanf(argv[1], "%lf", &eye_model[X]) != 1) {
			Tcl_AppendResult(interp, "vo_eye: bad X value - ", argv[1], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[2], "%lf", &eye_model[Y]) != 1) {
			Tcl_AppendResult(interp, "vo_eye: bad Y value - ", argv[2], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[3], "%lf", &eye_model[Z]) != 1) {
			Tcl_AppendResult(interp, "vo_eye: bad Z value - ", argv[3], "\n", (char *)0);
			return TCL_ERROR;
		}
	}

	VSCALE(eye_model, eye_model, vop->vo_local2base);

	/* First step:  put eye at view center (view 0,0,0) */
	MAT_DELTAS_VEC_NEG(vop->vo_center, eye_model);
	vo_update(vop, interp, 0);

	/*  Second step:  put eye at view 0,0,1.
	 *  For eye to be at 0,0,1, the old 0,0,-1 needs to become 0,0,0.
	 */
	VSET(xlate, 0.0, 0.0, -1.0);	/* correction factor */
	MAT4X3PNT(new_cent, vop->vo_view2model, xlate);
	MAT_DELTAS_VEC_NEG(vop->vo_center, new_cent);
	vo_update(vop, interp, 1);

	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_eye %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Get/set the eye point.
 *
 * Usage:
 *	procname eye [eye_point]
 */
static int
vo_eye_tcl(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_eye_cmd(vop, interp, argc-1, argv+1);
}

int
vo_eye_pos_cmd(struct view_obj	*vop,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	vect_t		eye_pos;
	struct bu_vls	vls;

	if (argc != 2 && argc != 4)
		goto bad;

	if (argc == 2) {
		if (bn_decode_vect(eye_pos, argv[1]) != 3)
			goto bad;
	} else {
		if (sscanf(argv[1], "%lf", &eye_pos[X]) != 1) {
			Tcl_AppendResult(interp, "vo_eye_pos: bad X value - ", argv[1], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[2], "%lf", &eye_pos[Y]) != 1) {
			Tcl_AppendResult(interp, "vo_eye_pos: bad Y value - ", argv[2], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[3], "%lf", &eye_pos[Z]) != 1) {
			Tcl_AppendResult(interp, "vo_eye_pos: bad Z value - ", argv[3], "\n", (char *)0);
			return TCL_ERROR;
		}
	}

	VSCALE(eye_pos, eye_pos, vop->vo_local2base);
	VMOVE(vop->vo_eye_pos, eye_pos);

	/* update perspective matrix */
	vo_mike_persp_mat(vop->vo_pmat, vop->vo_eye_pos);

	/* update all other view related matrices */
	vo_update(vop, interp, 1);

	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_eye_pos %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Set the eye position.
 *
 * Usage:
 *	procname eye_pos pos
 */
static int
vo_eye_pos_tcl(ClientData	clientData,
	       Tcl_Interp	*interp,
	       int		argc,
	       char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_eye_pos_cmd(vop, interp, argc-1, argv+1);
}

int
vo_lookat_cmd(struct view_obj	*vop,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{
	point_t look;
	point_t eye;
	point_t tmp;
	point_t new_center;
	vect_t dir;
	fastf_t new_az, new_el;
	struct bu_vls vls;

	if (argc != 2 && argc != 4)
		goto bad;

	if (argc == 2) {
		if (bn_decode_vect(look, argv[1]) != 3)
			goto bad;
	} else {
		if (sscanf(argv[1], "%lf", &look[X]) != 1) {
			Tcl_AppendResult(interp, "vo_lookat: bad X value - ", argv[1], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[2], "%lf", &look[Y]) != 1) {
			Tcl_AppendResult(interp, "vo_lookat: bad Y value - ", argv[2], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[3], "%lf", &look[Z]) != 1) {
			Tcl_AppendResult(interp, "vo_lookat: bad Z value - ", argv[3], "\n", (char *)0);
			return TCL_ERROR;
		}
	}

	VSCALE(look, look, vop->vo_local2base);

	VSET(tmp, 0.0, 0.0, 1.0);
	MAT4X3PNT(eye, vop->vo_view2model, tmp);

	VSUB2(dir, eye, look);
	VUNITIZE(dir);
	bn_ae_vec(&new_az, &new_el, dir);

	VSET(vop->vo_aet, new_az, new_el, vop->vo_aet[Z]);
	vo_mat_aet(vop);

	VJOIN1(new_center, eye, -vop->vo_scale, dir);
	MAT_DELTAS_VEC_NEG(vop->vo_center, new_center);

	vo_update(vop, interp, 1);

	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_lookat %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Set look-at point.
 *
 * Usage:
 *	procname lookat lookat_point
 */
static int
vo_lookat_tcl(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_lookat_cmd(vop, interp, argc-1, argv+1);
}

int
vo_orientation_cmd(struct view_obj	*vop,
		   Tcl_Interp		*interp,
		   int			argc,
		   char 		**argv)
{
	quat_t		quat;
	struct bu_vls	vls;

	if (argc != 2 && argc != 5)
		goto bad;

	if (argc == 2) {
		if (bn_decode_quat(quat, argv[1]) != 4)
			goto bad;
	} else {
		int	i;

		for (i = 1; i < 5; ++i)
			if (sscanf(argv[i], "%lf", &quat[i-1]) != 1)
				goto bad;
	}

	quat_quat2mat(vop->vo_rotation, quat);
	vo_update(vop, interp, 1);

	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_orient %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Usage:
 *	procname orient quat
 */
static int
vo_orientation_tcl(ClientData	clientData,
		   Tcl_Interp	*interp,
		   int		argc,
		   char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_orientation_cmd(vop, interp, argc-1, argv+1);
}

int
vo_pov_cmd(struct view_obj	*vop,
	   Tcl_Interp		*interp,
	   int			argc,
	   char 		**argv)
{
	vect_t		center;
	quat_t		quat;
	vect_t		eye_pos;
	fastf_t		scale;
	fastf_t		perspective;

	if (argc != 6) {
		struct bu_vls	vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias vo_pov %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/***************** Get the arguments *******************/

	if (bn_decode_vect(center, argv[1]) != 3) {
		Tcl_AppendResult(interp, "vo_pov: bad center - ", argv[1], "\n", (char *)0);
		return TCL_ERROR;
	}

	if (bn_decode_quat(quat, argv[2]) != 4) {
		Tcl_AppendResult(interp, "vo_pov: bad quat - ", argv[2], "\n", (char *)0);
		return TCL_ERROR;
	}

	if (sscanf(argv[3], "%lf", &scale) != 1) {
		Tcl_AppendResult(interp, "vo_pov: bad scale - ", argv[3], "\n", (char *)0);
		return TCL_ERROR;
	}

	if (bn_decode_vect(eye_pos, argv[4]) != 3) {
		Tcl_AppendResult(interp, "vo_pov: bad eye position - ", argv[4], "\n", (char *)0);
		return TCL_ERROR;
	}

	if (sscanf(argv[5], "%lf", &perspective) != 1) {
		Tcl_AppendResult(interp, "vo_pov: bad perspective - ", argv[5], "\n", (char *)0);
		return TCL_ERROR;
	}

	/***************** Use the arguments *******************/

	VSCALE(center, center, vop->vo_local2base);
	MAT_DELTAS_VEC_NEG(vop->vo_center, center);
	quat_quat2mat(vop->vo_rotation, quat);
	vop->vo_scale = vop->vo_local2base * scale;
	VSCALE(eye_pos, eye_pos, vop->vo_local2base);
	VMOVE(vop->vo_eye_pos, eye_pos);
	vop->vo_perspective = perspective;

	vo_update(vop, interp, 1);

	return TCL_OK;
}

/*
 * Usage:
 *	procname pov center quat scale eye_pos perspective
 */
static int
vo_pov_tcl(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_pov_cmd(vop, interp, argc-1, argv+1);
}

int
vo_zoom(struct view_obj	*vop,
	Tcl_Interp	*interp,
	fastf_t		sf)
{
	if (sf < SMALL_FASTF || INFINITY < sf) {
		Tcl_AppendResult(interp, "vo_zoom - scale factor out of range\n", (char *)0);
		return TCL_ERROR;
	}

	vop->vo_scale /= sf;
	if (vop->vo_scale < RT_MINVIEWSCALE)
		vop->vo_scale = RT_MINVIEWSCALE;
	vop->vo_size = 2.0 * vop->vo_scale;
	vop->vo_invSize = 1.0 / vop->vo_size;
	vo_update(vop, interp, 1);

	return TCL_OK;
}

int
vo_zoom_cmd(struct view_obj	*vop,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv)
{
	fastf_t sf;

	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias vo_zoom %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	if (sscanf(argv[1], "%lf", &sf) != 1) {
		Tcl_AppendResult(interp, "bad zoom value - ", argv[1], "\n", (char *)0);
		return TCL_ERROR;
	}

	return vo_zoom(vop, interp, sf);
}

/*
 * Usage:
 *	procname zoom scale_factor
 */
static int
vo_zoom_tcl(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_zoom_cmd(vop, interp, argc-1, argv+1);
}

int
vo_units_cmd(struct view_obj	*vop,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	struct bu_vls vls;

	/* get units */
	if (argc == 1) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%s", bu_units_string(vop->vo_local2base));
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	/* set units */
	if (argc == 2) {
		double uval;

		if ((uval = bu_units_conversion(argv[1])) == 0) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "unrecognized unit type - %s\n", argv[1]);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}

		vop->vo_local2base = uval;
		vop->vo_base2local = 1.0 / vop->vo_local2base;

		return TCL_OK;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_units %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Set/get local units.
 *
 * Usage:
 *	procname units [unit_spec]
 */
static int
vo_units_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_units_cmd(vop, interp, argc-1, argv+1);
}

int
vo_base2local_cmd(struct view_obj	*vop,
		  Tcl_Interp		*interp,
		  int			argc,
		  char 			**argv)
{
	struct bu_vls vls;

	bu_vls_init(&vls);

	if (argc != 1) {
		bu_vls_printf(&vls, "helplib_alias vo_base2local %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	bu_vls_printf(&vls, "%g", vop->vo_base2local);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;
}

/*
 * Get base2local conversion factor.
 *
 * Usage:
 *	procname base2local
 */
static int
vo_base2local_tcl(ClientData	clientData,
		  Tcl_Interp	*interp,
		  int		argc,
		  char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_base2local_cmd(vop, interp, argc-1, argv+1);
}

int
vo_local2base_cmd(struct view_obj	*vop,
		  Tcl_Interp		*interp,
		  int			argc,
		  char 			**argv)
{
	struct bu_vls vls;

	bu_vls_init(&vls);

	if (argc != 1) {
		bu_vls_printf(&vls, "helplib_alias vo_local2base %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	bu_vls_printf(&vls, "%g", vop->vo_local2base);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;
}

/*
 * Get local2base conversion factor.
 *
 * Usage:
 *	procname local2base
 */
static int
vo_local2base_tcl(ClientData	clientData,
		  Tcl_Interp	*interp,
		  int		argc,
		  char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_local2base_cmd(vop, interp, argc-1, argv+1);
}

int
vo_rot(struct view_obj	*vop,
       Tcl_Interp	*interp,
       char		coord,
       char		rotate_about,
       mat_t		rmat,
       int		(*func)())
{
	mat_t temp1, temp2;

	if (func != (int (*)())0)
		return (*func)(vop, interp, coord, rotate_about, rmat);

	switch (coord) {
	case 'm':
		/* transform model rotations into view rotations */
		bn_mat_inv(temp1, vop->vo_rotation);
		bn_mat_mul(temp2, vop->vo_rotation, rmat);
		bn_mat_mul(rmat, temp2, temp1);
		break;
	case 'v':
	default:
		break;
	}

	/* Calculate new view center */
	if (rotate_about != 'v') {
		point_t		rot_pt;
		point_t		new_origin;
		mat_t		viewchg, viewchginv;
		point_t		new_cent_view;
		point_t		new_cent_model;

		switch (rotate_about) {
		case 'e':
			VSET(rot_pt, 0.0, 0.0, 1.0);
			break;
		case 'k':
			MAT4X3PNT(rot_pt, vop->vo_model2view, vop->vo_keypoint);
			break;
		case 'm':
			/* rotate around model center (0,0,0) */
			VSET(new_origin, 0.0, 0.0, 0.0);
			MAT4X3PNT(rot_pt, vop->vo_model2view, new_origin);
			break;
		default:
			{
				struct bu_vls vls;

				bu_vls_init(&vls);
				bu_vls_printf(&vls, "vo_rot_tcl: bad rotate_about - %c\n", rotate_about);
				Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)0);
				bu_vls_free(&vls);
				return TCL_ERROR;
			}
		}

		bn_mat_xform_about_pt(viewchg, rmat, rot_pt);
		bn_mat_inv(viewchginv, viewchg);

		/* Convert origin in new (viewchg) coords back to old view coords */
		VSET(new_origin, 0.0, 0.0, 0.0);
		MAT4X3PNT(new_cent_view, viewchginv, new_origin);
		MAT4X3PNT(new_cent_model, vop->vo_view2model, new_cent_view);
		MAT_DELTAS_VEC_NEG(vop->vo_center, new_cent_model);
	}

	/* pure rotation */
	bn_mat_mul2(rmat, vop->vo_rotation);
	vo_update(vop, interp, 1);

	return TCL_OK;
}

int
vo_rot_cmd(struct view_obj	*vop,
	   Tcl_Interp		*interp,
	   int			argc,
	   char 		**argv,
	   int			(*func)())
{
	vect_t		rvec;
	mat_t		rmat;
	char		coord = vop->vo_coord;
	struct bu_vls	vls;

	if (argc < 2 || 5 < argc)
		goto bad;

	/* process coord flag */
	if (argv[1][0] == '-' && (argv[1][1] == 'v' || argv[1][1] == 'm') && argv[1][2] == '\0') {
		coord = argv[1][1];
		--argc;
		++argv;
	}

	if (argc != 2 && argc != 4)
		goto bad;

	if (argc == 2) {
		if (bn_decode_vect(rvec, argv[1]) != 3)
			goto bad;
	} else {
		if (sscanf(argv[1], "%lf", &rvec[X]) != 1) {
			Tcl_AppendResult(interp, "vo_rot: bad X value - ", argv[1], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[2], "%lf", &rvec[Y]) != 1) {
			Tcl_AppendResult(interp, "vo_rot: bad Y value - ", argv[2], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[3], "%lf", &rvec[Z]) != 1) {
			Tcl_AppendResult(interp, "vo_rot: bad Z value - ", argv[3], "\n", (char *)0);
			return TCL_ERROR;
		}
	}

	VSCALE(rvec, rvec, -1.0);
	bn_mat_angles(rmat, rvec[X], rvec[Y], rvec[Z]);

	return vo_rot(vop, interp, coord, vop->vo_rotate_about, rmat, func);

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_rot %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Rotate the view according to xyz.
 *
 * Usage:
 *	procname rot [-v|-m] xyz
 */
static int
vo_rot_tcl(ClientData	clientData,
	   Tcl_Interp	*interp,
	   int		argc,
	   char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_rot_cmd(vop, interp, argc-1, argv+1, (int (*)())0);
}

int
vo_tra(struct view_obj	*vop,
       Tcl_Interp	*interp,
       char		coord,
       vect_t		tvec,
       int		(*func)())
{
	point_t delta;
	point_t work;
	point_t vc, nvc;

	if (func != (int (*)())0)
		return (*func)(vop, interp, coord, tvec);

	switch (coord) {
	case 'm':
		VSCALE(delta, tvec, vop->vo_local2base);
		MAT_DELTAS_GET_NEG(vc, vop->vo_center);
		break;
	case 'v':
	default:
		VSCALE(tvec, tvec, -2.0*vop->vo_local2base*vop->vo_invSize);
		MAT4X3PNT(work, vop->vo_view2model, tvec);
		MAT_DELTAS_GET_NEG(vc, vop->vo_center);
		VSUB2(delta, work, vc);
		break;
	}

	VSUB2(nvc, vc, delta);
	MAT_DELTAS_VEC_NEG(vop->vo_center, nvc);
	vo_update(vop, interp, 1);

	return TCL_OK;
}

int
vo_tra_cmd(struct view_obj	*vop,
	   Tcl_Interp		*interp,
	   int			argc,
	   char 		**argv,
	   int			(*func)())
{
	vect_t		tvec;
	char		coord = vop->vo_coord;
	struct bu_vls	vls;

	if (argc < 2 || 5 < argc)
		goto bad;

	/* process coord flag */
	if (argv[1][0] == '-' && (argv[1][1] == 'v' || argv[1][1] == 'm') && argv[1][2] == '\0') {
		coord = argv[1][1];
		--argc;
		++argv;
	}

	if (argc != 2 && argc != 4)
		goto bad;

	if (argc == 2) {
		if (bn_decode_vect(tvec, argv[1]) != 3)
			goto bad;
	} else {
		if (sscanf(argv[1], "%lf", &tvec[X]) != 1) {
			Tcl_AppendResult(interp, "vo_tra: bad X value - ", argv[1], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[2], "%lf", &tvec[Y]) != 1) {
			Tcl_AppendResult(interp, "vo_tra: bad Y value - ", argv[2], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[3], "%lf", &tvec[Z]) != 1) {
			Tcl_AppendResult(interp, "vo_tra: bad Z value - ", argv[3], "\n", (char *)0);
			return TCL_ERROR;
		}
	}

	return vo_tra(vop, interp, coord, tvec, func);

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_tra %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Translate the view according to xyz.
 *
 * Usage:
 *	procname tra [-v|-m] xyz
 */
static int
vo_tra_tcl(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_tra_cmd(vop, interp, argc-1, argv+1, (int (*)())0);
}

int
vo_slew(struct view_obj	*vop,
	Tcl_Interp	*interp,
	vect_t		svec)
{
	point_t model_center;

	MAT4X3PNT(model_center, vop->vo_view2model, svec);
	MAT_DELTAS_VEC_NEG(vop->vo_center, model_center);
	vo_update(vop, interp, 1);

	return TCL_OK;
}

int
vo_slew_cmd(struct view_obj	*vop,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv)
{
	struct bu_vls	vls;
	vect_t		svec;

	if (argc == 2) {
		int	n;

		if ((n = bn_decode_vect(svec, argv[1])) != 3) {
			if (n != 2)
				goto bad;

			svec[Z] = 0.0;
		}

		return vo_slew(vop, interp, svec);
	}

	if (argc == 3 || argc == 4) {
		if (sscanf(argv[1], "%lf", &svec[X]) != 1) {
			Tcl_AppendResult(interp, "vo_slew: bad X value - ", argv[1], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[2], "%lf", &svec[Y]) != 1) {
			Tcl_AppendResult(interp, "vo_slew: bad Y value - ", argv[2], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (argc == 4) {
			if (sscanf(argv[3], "%lf", &svec[Z]) != 1) {
				Tcl_AppendResult(interp, "vo_slew: bad Z value - ", argv[3], "\n", (char *)0);
				return TCL_ERROR;
			}
		} else
			svec[Z] = 0.0;

		return vo_slew(vop, interp, svec);
	}

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_slew %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Make xyz the new view center.
 *
 * Usage:
 *	procname slew xy
 */
static int
vo_slew_tcl(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_slew_cmd(vop, interp, argc-1, argv+1);
}

int
vo_observer_cmd(struct view_obj	*vop,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	if (argc < 2) {
		struct bu_vls vls;

		/* return help message */
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias vo_observer %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	return bu_cmd((ClientData)&vop->vo_observers,
		      interp, argc - 1, argv + 1, bu_observer_cmds, 0);
}

/*
 * Attach/detach observers to/from list.
 *
 * Usage:
 *	  procname observer cmd [args]
 */
static int
vo_observer_tcl(ClientData	clientData,
		Tcl_Interp	*interp,
		int		argc,
		char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_observer_cmd(vop, interp, argc-1, argv+1);
}

int
vo_coord_cmd(struct view_obj	*vop,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	struct bu_vls vls;

	/* Get coord */
	if (argc == 1) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%c", vop->vo_coord);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)0);
		bu_vls_free(&vls);
		return TCL_OK;
	}

	/* Set coord */
	if (argc == 2) {
		switch (argv[1][0]) {
		case 'm':
		case 'v':
			vop->vo_coord = argv[1][0];
			return TCL_OK;
		}
	}

	/* return help message */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_coord %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Get/set the coordinate system.
 *
 * Usage:
 *	  procname coord [v|m]
 */
static int
vo_coord_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_coord_cmd(vop, interp, argc-1, argv+1);
}

int
vo_rotate_about_cmd(struct view_obj	*vop,
		    Tcl_Interp		*interp,
		    int			argc,
		    char 		**argv)
{
	struct bu_vls vls;

	/* Get rotate_about */
	if (argc == 1) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%c", vop->vo_rotate_about);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)0);
		bu_vls_free(&vls);
		return TCL_OK;
	}

	/* Set rotate_about */
	if (argc == 2 && argv[1][1] == '\0') {
		switch (argv[1][0]) {
		case 'e':
		case 'k':
		case 'm':
		case 'v':
			vop->vo_rotate_about = argv[1][0];
			return TCL_OK;
		}
	}

	/* return help message */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_rotate_about %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Get/set the rotate about point.
 *
 * Usage:
 *	  procname rotate_about [e|k|m|v]
 */
static int
vo_rotate_about_tcl(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_rotate_about_cmd(vop, interp, argc-1, argv+1);
}

int
vo_keypoint_cmd(struct view_obj	*vop,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	struct bu_vls	vls;
	vect_t		tvec;

	/* Get the keypoint */
	if (argc == 1) {
		bu_vls_init(&vls);
		VSCALE(tvec, vop->vo_keypoint, vop->vo_base2local);
		bn_encode_vect(&vls, tvec);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)0);
		bu_vls_free(&vls);
		return TCL_OK;
	}

	/* Set the keypoint */
	if (argc == 2) {
		if (bn_decode_vect(tvec, argv[1]) != 3)
			goto bad;
	} else if (argc == 4) {
		if (sscanf(argv[1], "%lf", &tvec[X]) != 1) {
			Tcl_AppendResult(interp, "vo_keypoint: bad X value - ", argv[1], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[2], "%lf", &tvec[Y]) != 1) {
			Tcl_AppendResult(interp, "vo_keypoint: bad Y value - ", argv[2], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[3], "%lf", &tvec[Z]) != 1) {
			Tcl_AppendResult(interp, "vo_keypoint: bad Z value - ", argv[3], "\n", (char *)0);
			return TCL_ERROR;
		}
	}

	VSCALE(vop->vo_keypoint, tvec, vop->vo_local2base);
	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_keypoint %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Get/set the keypoint.
 *
 * Usage:
 *	  procname keypoint [point]
 */
static int
vo_keypoint_tcl(ClientData	clientData,
		Tcl_Interp	*interp,
		int		argc,
		char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_keypoint_cmd(vop, interp, argc-1, argv+1);
}

/*
 *			V O _ S E T V I E W
 *
 * Set the view.  Angles are DOUBLES, in degrees.
 *
 * Given that viewvec = scale . rotate . (xlate to view center) . modelvec,
 * we just replace the rotation matrix.
 * (This assumes rotation around the view center).
 */
void
vo_setview(struct view_obj	*vop,
	   Tcl_Interp		*interp,
	   vect_t		rvec)		/* DOUBLE angles, in degrees */
{
	bn_mat_angles(vop->vo_rotation, rvec[X], rvec[Y], rvec[Z]);
	vo_update(vop, interp, 1);
}

int
vo_setview_cmd(struct view_obj	*vop,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	vect_t		rvec;
	struct bu_vls	vls;

	if (argc != 2 && argc != 4)
		goto bad;

	if (argc == 2) {
		if (bn_decode_vect(rvec, argv[1]) != 3)
			goto bad;
	} else {
		if (sscanf(argv[1], "%lf", &rvec[X]) != 1) {
			Tcl_AppendResult(interp, "vo_setview_cmd: bad X value - ", argv[1], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[2], "%lf", &rvec[Y]) != 1) {
			Tcl_AppendResult(interp, "vo_setview_cmd: bad Y value - ", argv[2], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[3], "%lf", &rvec[Z]) != 1) {
			Tcl_AppendResult(interp, "vo_setview_cmd: bad Z value - ", argv[3], "\n", (char *)0);
			return TCL_ERROR;
		}
	}

	vo_setview(vop, interp, rvec);
	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_setview %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Usage:
 *        procname setview x y z
 */
static int
vo_setview_tcl(ClientData	clientData,
	       Tcl_Interp	*interp,
	       int		argc,
	       char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_setview_cmd(vop, interp, argc-1, argv+1);
}

int
vo_arot_cmd(struct view_obj	*vop,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv,
	    int			(*func)())
{
	mat_t newrot;
	point_t pt;
	vect_t axis;
	fastf_t angle;

	if (argc != 5) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias vo_arot %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (sscanf(argv[1], "%lf", &axis[X]) != 1) {
		Tcl_AppendResult(interp, "vo_arot: bad X value - ", argv[1], "\n", (char *)0);
		return TCL_ERROR;
	}

	if (sscanf(argv[2], "%lf", &axis[Y]) != 1) {
		Tcl_AppendResult(interp, "vo_arot: bad Y value - ", argv[2], "\n", (char *)0);
		return TCL_ERROR;
	}

	if (sscanf(argv[3], "%lf", &axis[Z]) != 1) {
		Tcl_AppendResult(interp, "vo_arot: bad Z value - ", argv[3], "\n", (char *)0);
		return TCL_ERROR;
	}

	if (sscanf(argv[4], "%lf", &angle) != 1) {
		Tcl_AppendResult(interp, "vo_arot: bad angle - ", argv[4], "\n", (char *)0);
		return TCL_ERROR;
	}

	VSETALL(pt, 0.0);
	VUNITIZE(axis);

	bn_mat_arb_rot(newrot, pt, axis, angle*bn_degtorad);

	return vo_rot(vop, interp, vop->vo_coord, vop->vo_rotate_about, newrot, func);
}

/*
 * Usage:
 *        procname arot x y z angle
 */
static int
vo_arot_tcl(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_arot_cmd(vop, interp, argc-1, argv+1, (int (*)())0);
}

int
vo_vrot_cmd(struct view_obj	*vop,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv)
{
	vect_t		rvec;
	mat_t		rmat;
	struct bu_vls	vls;

	if (argc != 2 && argc != 4)
		goto bad;

	if (argc == 2) {
		if (bn_decode_vect(rvec, argv[1]) != 3)
			goto bad;
	} else {
		if (sscanf(argv[1], "%lf", &rvec[X]) < 1) {
			Tcl_AppendResult(interp, "vo_vrot: bad X value - ", argv[1], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[2], "%lf", &rvec[Y]) < 1) {
			Tcl_AppendResult(interp, "vo_vrot: bad Y value - ", argv[2], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[3], "%lf", &rvec[Z]) < 1) {
			Tcl_AppendResult(interp, "vo_vrot: bad Z value - ", argv[3], "\n", (char *)0);
			return TCL_ERROR;
		}
	}

	VSCALE(rvec, rvec, -1.0);
	bn_mat_angles(rmat, rvec[X], rvec[Y], rvec[Z]);

	return vo_rot(vop, interp, 'v', vop->vo_rotate_about, rmat, (int (*)())0);

bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_vrot %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Usage:
 *        procname vrot x y z
 */
static int
vo_vrot_tcl(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_vrot_cmd(vop, interp, argc-1, argv+1);
}

int
vo_mrot_cmd(struct view_obj	*vop,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv,
	    int			(*func)())
{
	vect_t		rvec;
	mat_t		rmat;
	struct bu_vls	vls;

	if (argc != 2 && argc != 4)
		goto bad;

	if (argc == 2) {
		if (bn_decode_vect(rvec, argv[1]) != 3)
			goto bad;
	} else {
		if (sscanf(argv[1], "%lf", &rvec[X]) < 1) {
			Tcl_AppendResult(interp, "vo_mrot: bad X value - ", argv[1], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[2], "%lf", &rvec[Y]) < 1) {
			Tcl_AppendResult(interp, "vo_mrot: bad Y value - ", argv[2], "\n", (char *)0);
			return TCL_ERROR;
		}

		if (sscanf(argv[3], "%lf", &rvec[Z]) < 1) {
			Tcl_AppendResult(interp, "vo_mrot: bad Z value - ", argv[3], "\n", (char *)0);
			return TCL_ERROR;
		}
	}

	VSCALE(rvec, rvec, -1.0);
	bn_mat_angles(rmat, rvec[X], rvec[Y], rvec[Z]);

	return vo_rot(vop, interp, 'm', vop->vo_rotate_about, rmat, func);

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias vo_mrot %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Usage:
 *        procname mrot x y z
 */
static int
vo_mrot_tcl(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_mrot_cmd(vop, interp, argc-1, argv+1, (int (*)())0);
}

int
vo_sca(struct view_obj	*vop,
       Tcl_Interp	*interp,
       fastf_t		sf,
       int		(*func)())
{
	if (func != (int (*)())0)
		return (*func)(vop, interp, sf);

	if (sf < SMALL_FASTF || INFINITY < sf)
		return TCL_OK;

	vop->vo_scale *= sf;
	if (vop->vo_scale < RT_MINVIEWSIZE)
		vop->vo_scale = RT_MINVIEWSIZE;
	vop->vo_size = 2.0 * vop->vo_scale;
	vop->vo_invSize = 1.0 / vop->vo_size;
	vo_update(vop, interp, 1);
	return TCL_OK;
}

int
vo_sca_cmd(struct view_obj	*vop,
	   Tcl_Interp		*interp,
	   int			argc,
	   char 		**argv,
	   int			(*func)())
{
	fastf_t sf;

	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias vo_sca %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (sscanf(argv[1], "%lf", &sf) != 1) {
		Tcl_AppendResult(interp, "vo_sca: bad scale factor - ", argv[1], "\n", (char *)0);
		return TCL_ERROR;
	}

	return vo_sca(vop, interp, sf, func);
}

/*
 * Usage:
 *        procname sca [sf]
 */
static int
vo_sca_tcl(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo_sca_cmd(vop, interp, argc-1, argv+1, (int (*)())0);
}

#if 0
/* skeleton functions for view_obj methods */
int
vo__cmd(struct view_obj	*vop,
	 Tcl_Interp	*interp,
	 int		argc,
	 char 		**argv)
{
}

/*
 * Usage:
 *        procname 
 */
static int
vo__tcl(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct view_obj *vop = (struct view_obj *)clientData;

	return vo__cmd(vop, interp, argc-1, argv+1);
}
#endif

/****************** Utility Routines ********************/
void
vo_update(struct view_obj	*vop,
	  Tcl_Interp		*interp,
	  int			oflag)
{
	vect_t work, work1;
	vect_t temp, temp1;

	bn_mat_mul(vop->vo_model2view,
		   vop->vo_rotation,
		   vop->vo_center);
	vop->vo_model2view[15] = vop->vo_scale;
	bn_mat_inv(vop->vo_view2model, vop->vo_model2view);

	/* Find current azimuth, elevation, and twist angles */
	VSET(work, 0.0, 0.0, 1.0);       /* view z-direction */
	MAT4X3VEC(temp , vop->vo_view2model , work);
	VSET(work1 , 1.0, 0.0, 0.0);      /* view x-direction */
	MAT4X3VEC(temp1 , vop->vo_view2model , work1);

	/* calculate angles using accuracy of 0.005, since display
	 * shows 2 digits right of decimal point */
	bn_aet_vec(&vop->vo_aet[0],
		   &vop->vo_aet[1],
		   &vop->vo_aet[2],
		   temp, temp1, (fastf_t)0.005);

	/* Force azimuth range to be [0,360] */
	if ((NEAR_ZERO(vop->vo_aet[1] - 90.0,(fastf_t)0.005) ||
	     NEAR_ZERO(vop->vo_aet[1] + 90.0,(fastf_t)0.005)) &&
	    vop->vo_aet[0] < 0 &&
	    !NEAR_ZERO(vop->vo_aet[0],(fastf_t)0.005))
		vop->vo_aet[0] += 360.0;
	else if (NEAR_ZERO(vop->vo_aet[0],(fastf_t)0.005))
		vop->vo_aet[0] = 0.0;

	/* apply the perspective angle to model2view */
	bn_mat_mul(vop->vo_pmodel2view, vop->vo_pmat, vop->vo_model2view);

	if (vop->vo_callback)
		(*vop->vo_callback)(vop->vo_clientData, vop);
	else if (oflag && interp != (Tcl_Interp *)NULL)
		bu_observer_notify(interp, &vop->vo_observers, bu_vls_addr(&vop->vo_name));
}

void
vo_mat_aet(struct view_obj *vop)
{
	mat_t tmat;
	fastf_t twist;
	fastf_t c_twist;
	fastf_t s_twist;

	bn_mat_angles(vop->vo_rotation,
		      270.0 + vop->vo_aet[1],
		      0.0,
		      270.0 - vop->vo_aet[0]);

	twist = -vop->vo_aet[2] * bn_degtorad;
	c_twist = cos(twist);
	s_twist = sin(twist);
	bn_mat_zrot(tmat, s_twist, c_twist);
	bn_mat_mul2(tmat, vop->vo_rotation);
}

/*
 *			P E R S P _ M A T
 *
 *  This code came from mged/dozoom.c.
 *  Compute a perspective matrix for a right-handed coordinate system.
 *  Reference: SGI Graphics Reference Appendix C
 *  (Note:  SGI is left-handed, but the fix is done in the Display Manger).
 */
static void
vo_persp_mat(mat_t	m,
	     fastf_t	fovy,
	     fastf_t	aspect,
	     fastf_t	near1,
	     fastf_t	far1,
	     fastf_t	backoff)
{
	mat_t	m2, tran;

	fovy *= 3.1415926535/180.0;

	MAT_IDN(m2);
	m2[5] = cos(fovy/2.0) / sin(fovy/2.0);
	m2[0] = m2[5]/aspect;
	m2[10] = (far1+near1) / (far1-near1);
	m2[11] = 2*far1*near1 / (far1-near1);	/* This should be negative */

	m2[14] = -1;		/* XXX This should be positive */
	m2[15] = 0;

	/* Move eye to origin, then apply perspective */
	MAT_IDN(tran);
	tran[11] = -backoff;
	bn_mat_mul(m, m2, tran);
}

/*
 *  This code came from mged/dozoom.c.
 *  Create a perspective matrix that transforms the +/1 viewing cube,
 *  with the acutal eye position (not at Z=+1) specified in viewing coords,
 *  into a related space where the eye has been sheared onto the Z axis
 *  and repositioned at Z=(0,0,1), with the same perspective field of view
 *  as before.
 *
 *  The Zbuffer clips off stuff with negative Z values.
 *
 *  pmat = persp * xlate * shear
 */
static void
vo_mike_persp_mat(mat_t		pmat,
		  const point_t	eye)
{
	mat_t	shear;
	mat_t	persp;
	mat_t	xlate;
	mat_t	t1, t2;
	point_t	sheared_eye;

	if( eye[Z] < SMALL )  {
		VPRINT("mike_persp_mat(): ERROR, z<0, eye", eye);
		return;
	}

	/* Shear "eye" to +Z axis */
	MAT_IDN(shear);
	shear[2] = -eye[X]/eye[Z];
	shear[6] = -eye[Y]/eye[Z];

	MAT4X3VEC( sheared_eye, shear, eye );
	if( !NEAR_ZERO(sheared_eye[X], .01) || !NEAR_ZERO(sheared_eye[Y], .01) )  {
		VPRINT("ERROR sheared_eye", sheared_eye);
		return;
	}

	/* Translate along +Z axis to put sheared_eye at (0,0,1). */
	MAT_IDN(xlate);
	/* XXX should I use MAT_DELTAS_VEC_NEG()?  X and Y should be 0 now */
	MAT_DELTAS( xlate, 0, 0, 1-sheared_eye[Z] );

	/* Build perspective matrix inline, substituting fov=2*atan(1,Z) */
	MAT_IDN( persp );
	/* From page 492 of Graphics Gems */
	persp[0] = sheared_eye[Z];	/* scaling: fov aspect term */
	persp[5] = sheared_eye[Z];	/* scaling: determines fov */

	/* From page 158 of Rogers Mathematical Elements */
	/* Z center of projection at Z=+1, r=-1/1 */
	persp[14] = -1;

	bn_mat_mul( t1, xlate, shear );
	bn_mat_mul( t2, persp, t1 );

	/* Now, move eye from Z=1 to Z=0, for clipping purposes */
	MAT_DELTAS( xlate, 0, 0, -1 );

	bn_mat_mul( pmat, xlate, t2 );
}


@


1.39
log
@change conf.h to a wrapped config.h
@
text
@@


1.38
log
@merge of ansi-6-0-branch into HEAD
@
text
@d29 5
a33 1
#include "conf.h"
@


1.37
log
@merge of windows-6-0-branch into head
@
text
@a43 5
/*
NOTES:
	Changed near to near1 for win32 compatibility 
	Changed far to far1 for win32 compatibility 
*/
d45 1
d47 15
a61 1
int Vo_Init();
d63 17
a79 15
static int vo_open_tcl();
static int vo_size_tcl();
static int vo_invSize_tcl();
static int vo_aet_tcl();
static int vo_rmat_tcl();
static int vo_center_tcl();
static int vo_model2view_tcl();
static int vo_pmodel2view_tcl();
static int vo_view2model_tcl();
static int vo_perspective_tcl();
static int vo_pmat_tcl();
static int vo_rot_tcl();
static int vo_tra_tcl();
static int vo_sca_tcl();
static int vo_slew_tcl();
d81 5
a85 23
static int vo_eye_tcl();
static int vo_eye_pos_tcl();
static int vo_lookat_tcl();
static int vo_orientation_tcl();
static int vo_pov_tcl();
static int vo_units_tcl();
static int vo_zoom_tcl();
static int vo_local2base_tcl();
static int vo_base2local_tcl();
static int vo_observer_tcl();
static int vo_coord_tcl();
static int vo_rotate_about_tcl();
static int vo_keypoint_tcl();
static int vo_setview_tcl();
static int vo_arot_tcl();
static int vo_vrot_tcl();
static int vo_mrot_tcl();

static int vo_cmd();
void vo_update();
void vo_mat_aet();
static void vo_persp_mat();
static void vo_mike_persp_mat();
@


1.36
log
@update copyright to include span through 2003
@
text
@d44 7
d2425 2
a2426 2
	     fastf_t	near,
	     fastf_t	far,
d2436 2
a2437 2
	m2[10] = (far+near) / (far-near);
	m2[11] = 2*far*near / (far-near);	/* This should be negative */
@


1.35
log
@Added a cast to quiet the compiler
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1997 by the United States Army
@


1.35.6.1
log
@merge from HEAD
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
@


1.35.6.2
log
@merge from head
@
text
@a43 7
/*
NOTES:
	Changed near to near1 for win32 compatibility 
	Changed far to far1 for win32 compatibility 
*/


d2418 2
a2419 2
	     fastf_t	near1,
	     fastf_t	far1,
d2429 2
a2430 2
	m2[10] = (far1+near1) / (far1-near1);
	m2[11] = 2*far1*near1 / (far1-near1);	/* This should be negative */
@


1.34
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d225 1
a225 1
				vo_cmd,
@


1.34.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@a43 7
/*
NOTES:
	Changed near to near1 for win32 compatibility 
	Changed far to far1 for win32 compatibility 
*/


d2418 2
a2419 2
	     fastf_t	near1,
	     fastf_t	far1,
d2429 2
a2430 2
	m2[10] = (far1+near1) / (far1-near1);
	m2[11] = 2*far1*near1 / (far1-near1);	/* This should be negative */
@


1.34.4.2
log
@sync to HEAD...
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d232 1
a232 1
				(Tcl_CmdProc *)vo_cmd,
@


1.34.2.1
log
@Initial ANSIfication
@
text
@d44 1
a44 1
int Vo_Init(Tcl_Interp *interp);
d46 15
a60 15
static int vo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_size_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_invSize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_aet_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_rmat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_center_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_model2view_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_pmodel2view_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_view2model_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_perspective_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_pmat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_rot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_tra_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_sca_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_slew_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d62 17
a78 17
static int vo_eye_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_eye_pos_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_lookat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_orientation_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_pov_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_units_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_zoom_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_local2base_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_base2local_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_coord_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_rotate_about_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_keypoint_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_setview_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_arot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_vrot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_mrot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d80 5
a84 5
static int vo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
void vo_update(struct view_obj *vop, Tcl_Interp *interp, int oflag);
void vo_mat_aet(struct view_obj *vop);
static void vo_persp_mat(fastf_t *m, fastf_t fovy, fastf_t aspect, fastf_t near, fastf_t far, fastf_t backoff);
static void vo_mike_persp_mat(fastf_t *pmat, const fastf_t *eye);
@


1.34.2.2
log
@sync branch with HEAD
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
a43 1

d83 1
a83 1
static void vo_persp_mat(fastf_t *m, fastf_t fovy, fastf_t aspect, fastf_t near1, fastf_t far1, fastf_t backoff);
d225 1
a225 1
				(Tcl_CmdProc *)vo_cmd,
d2418 2
a2419 2
	     fastf_t	near1,
	     fastf_t	far1,
d2429 2
a2430 2
	m2[10] = (far1+near1) / (far1-near1);
	m2[11] = 2*far1*near1 / (far1-near1);	/* This should be negative */
@


1.33
log
@Converted from K&R to ANSI C - RFH
@
text
@d44 1
a44 1
int Vo_Init(Tcl_Interp *interp);
d46 15
a60 15
static int vo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_size_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_invSize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_aet_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_rmat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_center_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_model2view_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_pmodel2view_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_view2model_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_perspective_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_pmat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_rot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_tra_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_sca_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_slew_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d62 17
a78 17
static int vo_eye_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_eye_pos_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_lookat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_orientation_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_pov_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_units_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_zoom_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_local2base_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_base2local_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_coord_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_rotate_about_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_keypoint_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_setview_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_arot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_vrot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vo_mrot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d80 5
a84 5
static int vo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
void vo_update(struct view_obj *vop, Tcl_Interp *interp, int oflag);
void vo_mat_aet(struct view_obj *vop);
static void vo_persp_mat(fastf_t *m, fastf_t fovy, fastf_t aspect, fastf_t near, fastf_t far, fastf_t backoff);
static void vo_mike_persp_mat(fastf_t *pmat, const fastf_t *eye);
@


1.32
log
@-* Bob Parker improved support for the "eye" command.
@
text
@d44 1
a44 1
int Vo_Init();
d46 15
a60 15
static int vo_open_tcl();
static int vo_size_tcl();
static int vo_invSize_tcl();
static int vo_aet_tcl();
static int vo_rmat_tcl();
static int vo_center_tcl();
static int vo_model2view_tcl();
static int vo_pmodel2view_tcl();
static int vo_view2model_tcl();
static int vo_perspective_tcl();
static int vo_pmat_tcl();
static int vo_rot_tcl();
static int vo_tra_tcl();
static int vo_sca_tcl();
static int vo_slew_tcl();
d62 17
a78 17
static int vo_eye_tcl();
static int vo_eye_pos_tcl();
static int vo_lookat_tcl();
static int vo_orientation_tcl();
static int vo_pov_tcl();
static int vo_units_tcl();
static int vo_zoom_tcl();
static int vo_local2base_tcl();
static int vo_base2local_tcl();
static int vo_observer_tcl();
static int vo_coord_tcl();
static int vo_rotate_about_tcl();
static int vo_keypoint_tcl();
static int vo_setview_tcl();
static int vo_arot_tcl();
static int vo_vrot_tcl();
static int vo_mrot_tcl();
d80 5
a84 5
static int vo_cmd();
void vo_update();
void vo_mat_aet();
static void vo_persp_mat();
static void vo_mike_persp_mat();
@


1.31
log
@*- move vrot in vo_cmds
@
text
@d866 17
d931 1
a931 1
 * Set the eye point.
d934 1
a934 1
 *	procname eye eye_point
d2502 2
@


1.30
log
@*- add interp parameter to callback functions
@
text
@d118 1
a119 1
	{"view2model",		vo_view2model_tcl},
@


1.29
log
@*- change aet method to ae
@
text
@d1428 1
a1428 1
		return (*func)(vop, coord, rotate_about, rmat);
d1579 1
a1579 1
		return (*func)(vop, coord, tvec);
@


1.28
log
@*- check input to size command
@
text
@d90 1
a90 1
	{"aet",			vo_aet_tcl},
d468 1
a468 1
 *        procname aet [[-i] az el [tw]]
@


1.27
log
@*- fixed bug in vo_size
@
text
@d298 3
a300 1
		if (sscanf(argv[1], "%lf", &size) != 1) {
@


1.26
log
@*- change helplib to helplib_alias
@
text
@d272 2
a273 2
	vop->vo_invSize = 1.0 / size;
	vop->vo_scale = 0.5 * size;
@


1.25
log
@*- mods to vo_tra to make the default
   coord 'v'.
@
text
@d310 1
a310 1
	bu_vls_printf(&vls, "helplib vo_size");
d353 1
a353 1
	bu_vls_printf(&vls, "helplib vo_invSize");
d455 1
a455 1
	bu_vls_printf(&vls, "helplib vo_aet");
d507 1
a507 1
	bu_vls_printf(&vls, "helplib vo_rmat");
d592 1
a592 1
	bu_vls_printf(&vls, "helplib vo_center");
d635 1
a635 1
	bu_vls_printf(&vls, "helplib vo_model2view");
d678 1
a678 1
	bu_vls_printf(&vls, "helplib vo_pmodel2view");
d721 1
a721 1
	bu_vls_printf(&vls, "helplib vo_view2model");
d786 1
a786 1
	bu_vls_printf(&vls, "helplib vo_perspective");
d829 1
a829 1
	bu_vls_printf(&vls, "helplib vo_pmat");
d905 1
a905 1
	bu_vls_printf(&vls, "helplib vo_eye");
d973 1
a973 1
	bu_vls_printf(&vls, "helplib vo_eye_pos");
d1054 1
a1054 1
	bu_vls_printf(&vls, "helplib vo_lookat");
d1107 1
a1107 1
	bu_vls_printf(&vls, "helplib vo_orient");
d1144 1
a1144 1
		bu_vls_printf(&vls, "helplib vo_pov");
d1239 1
a1239 1
		bu_vls_printf(&vls, "helplib vo_zoom");
d1307 1
a1307 1
	bu_vls_printf(&vls, "helplib vo_units");
d1342 1
a1342 1
		bu_vls_printf(&vls, "helplib vo_base2local");
d1384 1
a1384 1
		bu_vls_printf(&vls, "helplib vo_local2base");
d1541 1
a1541 1
	bu_vls_printf(&vls, "helplib vo_rot");
d1648 1
a1648 1
	bu_vls_printf(&vls, "helplib vo_tra");
d1732 1
a1732 1
	bu_vls_printf(&vls, "helplib vo_slew");
d1767 1
a1767 1
		bu_vls_printf(&vls, "helplib vo_observer");
d1823 1
a1823 1
	bu_vls_printf(&vls, "helplib vo_coord");
d1877 1
a1877 1
	bu_vls_printf(&vls, "helplib vo_rotate_about");
d1945 1
a1945 1
	bu_vls_printf(&vls, "helplib vo_keypoint");
d2023 1
a2023 1
	bu_vls_printf(&vls, "helplib vo_setview");
d2060 1
a2060 1
		bu_vls_printf(&vls, "helplib vo_arot");
d2149 1
a2149 1
	bu_vls_printf(&vls, "helplib vo_vrot");
d2211 1
a2211 1
	bu_vls_printf(&vls, "helplib vo_mrot");
d2266 1
a2266 1
		bu_vls_printf(&vls, "helplib vo_sca");
@


1.24
log
@*- added -i option to vo_aet_cmd
*- mods to many routines to accept both
   separate arguments or a list of arguments
@
text
@d1585 1
@


1.23
log
@*- mods to vo_aet:
   * added -i for treating values incrementally
   * added support for values to be handed over
     as a vector or as single arguments
*- fixed misuse of Tcl_AppendResult (i.e. it was being
   used like printf, which is how it should have
   been implemented)
   On the other hand, since Tcl_AppendResult has been
   deprecated, any use of it is probably a misuse. :-)
@
text
@a46 3
#if 0
static int vo_close_tcl();
#endif
a93 3
#if 0
	{"close",		vo_close_tcl},
#endif
a162 32
#if 0
/*
 * Close a view object.
 *
 * USAGE:
 *        procname close
 */
static int
vo_close_tcl(clientData, interp, argc, argv)
     ClientData      clientData;
     Tcl_Interp      *interp;
     int             argc;
     char            **argv;
{
	struct bu_vls vls;
	struct view_obj *vop = (struct view_obj *)clientData;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib vo_close");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* Among other things, this will call vo_deleteProc. */
	Tcl_DeleteCommand(interp, bu_vls_addr(&vop->vo_name));

	return TCL_OK;
}
#endif

d409 1
a409 1
			goto error;
d452 1
a452 1
error:
d466 1
a466 1
 *        procname 
d569 14
a582 6
			if (sscanf(argv[1], "%lf", &center[X]) != 1)
				goto bad;
			if (sscanf(argv[2], "%lf", &center[Y]) != 1)
				goto bad;
			if (sscanf(argv[3], "%lf", &center[Z]) != 1)
				goto bad;
d689 1
a689 1
 *        procname 
d730 1
a730 1
 *        procname 
d859 4
a862 3
	point_t	eye_model;
	vect_t	xlate;
	vect_t	new_cent;
d864 2
a865 9
	if (argc != 2 && argc != 4) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib vo_eye");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
d869 1
a869 1
			return TCL_ERROR;
d871 2
a872 1
		if (sscanf(argv[1], "%lf", &eye_model[X]) != 1)
d874 4
a877 1
		if (sscanf(argv[2], "%lf", &eye_model[Y]) != 1)
d879 4
a882 1
		if (sscanf(argv[3], "%lf", &eye_model[Z]) != 1)
d884 1
d902 7
d934 5
a938 1
	vect_t eye_pos;
d940 13
a952 2
	if (argc != 2) {
		struct bu_vls vls;
d954 4
a957 5
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib vo_eye_pos");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
a959 3
	if (bn_decode_vect(eye_pos, argv[1]) != 3)
		return TCL_ERROR;

d970 7
d1017 14
a1030 6
		if (sscanf(argv[1], "%lf", &look[X]) != 1)
			goto bad;
		if (sscanf(argv[2], "%lf", &look[Y]) != 1)
			goto bad;
		if (sscanf(argv[3], "%lf", &look[Z]) != 1)
			goto bad;
d1083 2
a1084 1
	quat_t quat;
d1086 2
a1087 2
	if (argc != 2) {
		struct bu_vls vls;
d1089 5
a1093 6
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib vo_orient");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
d1095 3
a1097 2
	if (bn_decode_quat(quat, argv[1]) != 4) {
		return TCL_ERROR;
d1104 7
d1134 5
a1138 5
	vect_t center;
	quat_t quat;
	vect_t eye_pos;
	fastf_t scale;
	fastf_t perspective;
d1141 1
a1141 1
		struct bu_vls vls;
d1153 1
d1158 1
d1163 1
d1168 1
d1172 2
a1173 1
	if (sscanf(argv[3], "%lf", &perspective) != 1) {
d1247 1
a1247 2
		Tcl_AppendResult(interp, "bad zoom value - ",
				 argv[1], (char *)0);
d1496 4
a1499 3
	vect_t rvec;
	mat_t rmat;
	char coord = vop->vo_coord;
d1501 2
a1502 2
	if (argc < 2 || 3 < argc) {
		struct bu_vls vls;
d1504 5
a1508 6
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib vo_rot");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
d1511 2
a1512 10
	/* process coord flag */
	if (argc == 3) {
		if (argv[1][0] == '-' &&
		    (argv[1][1] == 'v' || argv[1][1] == 'm') &&
		    argv[1][2] == '\0') {
			coord = argv[1][1];
			--argc;
			++argv;
		} else {
			struct bu_vls vls;
d1514 8
a1521 4
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "helplib vo_rot");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
d1523 2
a1526 1
	}
d1528 4
a1531 3
	if (bn_decode_vect(rvec, argv[1]) != 3) {
		Tcl_AppendResult(interp, "vo_rot: bad xyz - ", argv[1], (char *)NULL);
		return TCL_ERROR;
d1538 8
d1606 3
a1608 2
	vect_t tvec;
	char coord = vop->vo_coord;
d1610 2
a1611 2
	if (argc < 2 || 3 < argc) {
		struct bu_vls vls;
d1613 5
a1617 6
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib vo_tra");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
d1620 2
a1621 10
	/* process coord flag */
	if (argc == 3) {
		if (argv[1][0] == '-' &&
		    (argv[1][1] == 'v' || argv[1][1] == 'm') &&
		    argv[1][2] == '\0') {
			coord = argv[1][1];
			--argc;
			++argv;
		} else {
			struct bu_vls vls;
d1623 8
a1630 4
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "helplib vo_tra");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
d1632 2
a1635 1
	}
d1637 4
a1640 3
	if (bn_decode_vect(tvec, argv[1]) != 3) {
		Tcl_AppendResult(interp, "vo_tra: bad xyz - ", argv[1], (char *)NULL);
		return TCL_ERROR;
d1644 8
d1658 1
a1658 1
 *	procname tra xyz
d1698 2
a1699 4
			if (n != 2) {
				Tcl_AppendResult(interp, "vo_slew: bad xyz - ", argv[1], (char *)0);
				return TCL_ERROR;
			}
d1709 1
a1709 1
			Tcl_AppendResult(interp, "vo_slew: bad x value - ", argv[1], "\n", (char *)0);
d1714 1
a1714 1
			Tcl_AppendResult(interp, "vo_slew: bad y value - ", argv[2], "\n", (char *)0);
d1720 1
a1720 1
				Tcl_AppendResult(interp, "vo_slew: bad z value - ", argv[3], "\n", (char *)0);
d1729 1
d1905 2
a1906 2
	struct bu_vls vls;
	vect_t tvec;
d1920 5
a1924 2
		if (bn_decode_vect(tvec, argv[1]) != 3) {
			Tcl_AppendResult(interp, "vo_keypoint: bad xyz - ", argv[1], (char *)0);
d1928 9
a1936 2
		VSCALE(vop->vo_keypoint, tvec, vop->vo_local2base)
		return TCL_OK;
d1939 4
a1942 1
	/* return help message */
d1979 1
a1979 3
	   double		a1,
	   double		a2,
	   double		a3)		/* DOUBLE angles, in degrees */
d1981 1
a1981 1
	bn_mat_angles(vop->vo_rotation, a1, a2, a3);
d1991 2
a1992 1
	double	x, y, z;
d1994 2
a1995 2
	if (argc < 4 || 4 < argc) {
		struct bu_vls vls;
d1997 8
a2004 6
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib vo_setview");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
d2006 4
a2009 5
	if (sscanf(argv[1], "%lf", &x) < 1) {
		Tcl_AppendResult(interp, "vo_setview_cmd: bad x value - ",
				 argv[1], "\n", (char *)0);
		return TCL_ERROR;
	}
d2011 4
a2014 4
	if (sscanf(argv[2], "%lf", &y) < 1) {
		Tcl_AppendResult(interp, "vo_setview_cmd: bad y value - ",
				 argv[2], "\n", (char *)0);
		return TCL_ERROR;
d2017 2
a2018 5
	if (sscanf(argv[3], "%lf", &z) < 1) {
		Tcl_AppendResult(interp, "vo_setview_cmd: bad z value - ",
				 argv[3], "\n", (char *)0);
		return TCL_ERROR;
	}
d2020 6
a2025 2
	vo_setview(vop, interp, x, y, z);
	return TCL_OK;
d2055 1
a2055 1
	if (argc != 4) {
d2065 2
a2066 2
	if (sscanf(argv[1], "%lf", &axis[X]) < 1) {
		Tcl_AppendResult(interp, "vo_arot: bad x value - ", argv[1], "\n", (char *)0);
d2070 2
a2071 2
	if (sscanf(argv[2], "%lf", &axis[Y]) < 1) {
		Tcl_AppendResult(interp, "vo_arot: bad y value - ", argv[2], "\n", (char *)0);
d2075 2
a2076 2
	if (sscanf(argv[3], "%lf", &axis[Z]) < 1) {
		Tcl_AppendResult(interp, "vo_arot: bad z value - ", argv[3], "\n", (char *)0);
d2080 1
a2080 1
	if (sscanf(argv[4], "%lf", &angle) < 1) {
d2095 1
a2095 1
 *        procname arot 
d2114 3
a2116 2
	vect_t rvec;
	mat_t rmat;
d2118 2
a2119 9
	if (argc != 2 && argc != 4) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib vo_vrot");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
d2122 2
a2123 4
		if (bn_decode_vect(rvec, argv[1]) != 3) {
			Tcl_AppendResult(interp, "vo_vrot: bad xyz - ", argv[1], (char *)0);
			return TCL_ERROR;
		}
d2126 1
a2126 1
			Tcl_AppendResult(interp, "vo_vrot: bad x value - ", argv[1], "\n", (char *)0);
d2131 1
a2131 1
			Tcl_AppendResult(interp, "vo_vrot: bad y value - ", argv[2], "\n", (char *)0);
d2136 1
a2136 1
			Tcl_AppendResult(interp, "vo_vrot: bad z value - ", argv[3], "\n", (char *)0);
d2145 7
d2176 3
a2178 2
	vect_t rvec;
	mat_t rmat;
d2180 2
a2181 9
	if (argc != 2 && argc != 4) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib vo_mrot");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
d2184 2
a2185 4
		if (bn_decode_vect(rvec, argv[1]) != 3) {
			Tcl_AppendResult(interp, "vo_mrot: bad xyz - ", argv[1], (char *)0);
			return TCL_ERROR;
		}
d2188 1
a2188 1
			Tcl_AppendResult(interp, "vo_mrot: bad x value - ", argv[1], "\n", (char *)0);
d2193 1
a2193 1
			Tcl_AppendResult(interp, "vo_mrot: bad y value - ", argv[2], "\n", (char *)0);
d2198 1
a2198 1
			Tcl_AppendResult(interp, "vo_mrot: bad z value - ", argv[3], "\n", (char *)0);
d2207 7
@


1.22
log
@*- added the following methods:
	arot, mrot, sca, setview, vrot
*- formatting
@
text
@d421 3
a423 2
	struct bu_vls vls;
	vect_t aet;
d432 10
a441 1
	} else if (argc == 2) {  /* set aet */
d449 35
a483 1
		VMOVE(vop->vo_aet, aet);
d1195 1
a1195 1
		Tcl_AppendResult(interp, "vo_zoom - scale factor out of range\n", (char *)NULL);
d1230 1
a1230 1
				 argv[1], (char *)NULL);
d1670 1
a1670 1
				Tcl_AppendResult(interp, "vo_slew: bad xyz - ", argv[1], (char *)NULL);
d1682 1
a1682 1
			Tcl_AppendResult(interp, "vo_slew: bad x value - %s\n", argv[1]);
d1687 1
a1687 1
			Tcl_AppendResult(interp, "vo_slew: bad y value - %s\n", argv[2]);
d1693 1
a1693 1
				Tcl_AppendResult(interp, "vo_slew: bad z value - %s\n", argv[3]);
d1966 1
a1966 1
				 argv[1], "\n", (char *)NULL);
d1972 1
a1972 1
				 argv[2], "\n", (char *)NULL);
d1978 1
a1978 1
				 argv[3], "\n", (char *)NULL);
d2024 1
a2024 1
		Tcl_AppendResult(interp, "vo_arot: bad x value - %s\n", argv[1]);
d2029 1
a2029 1
		Tcl_AppendResult(interp, "vo_arot: bad y value - %s\n", argv[2]);
d2034 1
a2034 1
		Tcl_AppendResult(interp, "vo_arot: bad z value - %s\n", argv[3]);
d2039 1
a2039 1
		Tcl_AppendResult(interp, "vo_arot: bad angle - %s\n", argv[4]);
d2087 1
a2087 1
			Tcl_AppendResult(interp, "vo_vrot: bad xyz - ", argv[1], (char *)NULL);
d2092 1
a2092 1
			Tcl_AppendResult(interp, "vo_vrot: bad x value - %s\n", argv[1]);
d2097 1
a2097 1
			Tcl_AppendResult(interp, "vo_vrot: bad y value - %s\n", argv[2]);
d2102 1
a2102 1
			Tcl_AppendResult(interp, "vo_vrot: bad z value - %s\n", argv[3]);
d2142 1
a2142 1
		bu_vls_printf(&vls, "helplib vo_vrot");
d2150 1
a2150 1
			Tcl_AppendResult(interp, "vo_mrot: bad xyz - ", argv[1], (char *)NULL);
d2155 1
a2155 1
			Tcl_AppendResult(interp, "vo_mrot: bad x value - %s\n", argv[1]);
d2160 1
a2160 1
			Tcl_AppendResult(interp, "vo_mrot: bad y value - %s\n", argv[2]);
d2165 1
a2165 1
			Tcl_AppendResult(interp, "vo_mrot: bad z value - %s\n", argv[3]);
@


1.21
log
@*- break vo_somecmd_tcl routines into vo_somecmd_cmd
   and vo_somecmd_tcl (i.e. providing C and Tcl APIs)
@
text
@a48 1
static int vo_scale_tcl();
d62 1
d78 4
d84 2
a85 2
static void vo_update();
static void vo_mat_aet();
d94 1
d108 1
d118 2
a119 3
#if 0
	{"scale",		vo_scale_tcl},
#endif
d124 1
d127 7
d138 4
a141 5
vo_cmd(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int		argc;
     char		**argv;
d147 1
a147 2
Vo_Init(interp)
     Tcl_Interp *interp;
d157 1
a157 2
vo_deleteProc(clientData)
     ClientData clientData;
d205 1
a205 2
vo_open_cmd(Tcl_Interp		*interp,
	    char		*oname)
d207 1
d228 1
d241 5
a245 4
int vo_open_tcl(ClientData	clientData,
		Tcl_Interp	*interp,
		int             argc,
		char            **argv)
d260 1
a260 1
	vop = vo_open_cmd(interp, argv[1]);
d274 2
d277 9
d287 2
a288 1
 * Get or set the view scale.
d291 4
a294 5
vo_scale_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a296 2
	struct bu_vls vls;
	fastf_t scale;
d298 3
a300 6
	/* get view scale */
	if (argc == 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%g", vop->vo_scale * vop->vo_base2local);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
d302 11
a312 26
		return TCL_OK;
	}

	/* set view scale */
	if (argc == 3) {
		if (sscanf(argv[2], "%lf", &scale) != 1) {
			Tcl_AppendResult(interp, "bad scale value - ",
					 argv[2], (char *)NULL);
			return TCL_ERROR;
		}

		vop->vo_scale = vop->vo_local2base * scale;
		vop->vo_size = 2.0 * scale;
		vop->vo_invSize = 1.0 / vop->vo_size;
		vo_update(vop, interp, 1);

		return TCL_OK;
	}

	/* compose error message */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib vo_scale");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
a313 1
#endif
d342 1
a342 5
		vop->vo_size = vop->vo_local2base * size;
		vop->vo_invSize = 1.0 / size;
		vop->vo_scale = 0.5 * size;
		vo_update(vop, interp, 1);

d525 10
d541 3
a543 2
	vect_t center;
	struct bu_vls vls;
d558 12
a569 7
	if (argc == 2) {
		if (bn_decode_vect(center, argv[1]) != 3)
			return TCL_ERROR;

		VSCALE(center, center, vop->vo_local2base);
		MAT_DELTAS_VEC_NEG(vop->vo_center, center);
		vo_update(vop, interp, 1);
d571 1
d575 1
d832 1
a832 1
	    char		**argv)
a838 160
static void
vo_update(struct view_obj	*vop,
	  Tcl_Interp		*interp,
	  int			oflag)
{
	vect_t work, work1;
	vect_t temp, temp1;

	bn_mat_mul(vop->vo_model2view,
		   vop->vo_rotation,
		   vop->vo_center);
	vop->vo_model2view[15] = vop->vo_scale;
	bn_mat_inv(vop->vo_view2model, vop->vo_model2view);

	/* Find current azimuth, elevation, and twist angles */
	VSET(work, 0.0, 0.0, 1.0);       /* view z-direction */
	MAT4X3VEC(temp , vop->vo_view2model , work);
	VSET(work1 , 1.0, 0.0, 0.0);      /* view x-direction */
	MAT4X3VEC(temp1 , vop->vo_view2model , work1);

	/* calculate angles using accuracy of 0.005, since display
	 * shows 2 digits right of decimal point */
	bn_aet_vec(&vop->vo_aet[0],
		   &vop->vo_aet[1],
		   &vop->vo_aet[2],
		   temp, temp1, (fastf_t)0.005);

	/* Force azimuth range to be [0,360] */
	if ((NEAR_ZERO(vop->vo_aet[1] - 90.0,(fastf_t)0.005) ||
	     NEAR_ZERO(vop->vo_aet[1] + 90.0,(fastf_t)0.005)) &&
	    vop->vo_aet[0] < 0 &&
	    !NEAR_ZERO(vop->vo_aet[0],(fastf_t)0.005))
		vop->vo_aet[0] += 360.0;
	else if (NEAR_ZERO(vop->vo_aet[0],(fastf_t)0.005))
		vop->vo_aet[0] = 0.0;

	/* apply the perspective angle to model2view */
	bn_mat_mul(vop->vo_pmodel2view, vop->vo_pmat, vop->vo_model2view);

	if (oflag)
		bu_observer_notify(interp, &vop->vo_observers, bu_vls_addr(&vop->vo_name));
}

static void
vo_mat_aet(struct view_obj *vop)
{
	mat_t tmat;
	fastf_t twist;
	fastf_t c_twist;
	fastf_t s_twist;

	bn_mat_angles(vop->vo_rotation,
		      270.0 + vop->vo_aet[1],
		      0.0,
		      270.0 - vop->vo_aet[0]);

	twist = -vop->vo_aet[2] * bn_degtorad;
	c_twist = cos(twist);
	s_twist = sin(twist);
	bn_mat_zrot(tmat, s_twist, c_twist);
	bn_mat_mul2(tmat, vop->vo_rotation);
}

/*
 *			P E R S P _ M A T
 *
 *  This code came from mged/dozoom.c.
 *  Compute a perspective matrix for a right-handed coordinate system.
 *  Reference: SGI Graphics Reference Appendix C
 *  (Note:  SGI is left-handed, but the fix is done in the Display Manger).
 */
static void
vo_persp_mat(mat_t	m,
	     fastf_t	fovy,
	     fastf_t	aspect,
	     fastf_t	near,
	     fastf_t	far,
	     fastf_t	backoff)
{
	mat_t	m2, tran;

	fovy *= 3.1415926535/180.0;

	MAT_IDN(m2);
	m2[5] = cos(fovy/2.0) / sin(fovy/2.0);
	m2[0] = m2[5]/aspect;
	m2[10] = (far+near) / (far-near);
	m2[11] = 2*far*near / (far-near);	/* This should be negative */

	m2[14] = -1;		/* XXX This should be positive */
	m2[15] = 0;

	/* Move eye to origin, then apply perspective */
	MAT_IDN(tran);
	tran[11] = -backoff;
	bn_mat_mul(m, m2, tran);
}

/*
 *  This code came from mged/dozoom.c.
 *  Create a perspective matrix that transforms the +/1 viewing cube,
 *  with the acutal eye position (not at Z=+1) specified in viewing coords,
 *  into a related space where the eye has been sheared onto the Z axis
 *  and repositioned at Z=(0,0,1), with the same perspective field of view
 *  as before.
 *
 *  The Zbuffer clips off stuff with negative Z values.
 *
 *  pmat = persp * xlate * shear
 */
static void
vo_mike_persp_mat(mat_t		pmat,
		  const point_t	eye)
{
	mat_t	shear;
	mat_t	persp;
	mat_t	xlate;
	mat_t	t1, t2;
	point_t	sheared_eye;

	if( eye[Z] < SMALL )  {
		VPRINT("mike_persp_mat(): ERROR, z<0, eye", eye);
		return;
	}

	/* Shear "eye" to +Z axis */
	MAT_IDN(shear);
	shear[2] = -eye[X]/eye[Z];
	shear[6] = -eye[Y]/eye[Z];

	MAT4X3VEC( sheared_eye, shear, eye );
	if( !NEAR_ZERO(sheared_eye[X], .01) || !NEAR_ZERO(sheared_eye[Y], .01) )  {
		VPRINT("ERROR sheared_eye", sheared_eye);
		return;
	}

	/* Translate along +Z axis to put sheared_eye at (0,0,1). */
	MAT_IDN(xlate);
	/* XXX should I use MAT_DELTAS_VEC_NEG()?  X and Y should be 0 now */
	MAT_DELTAS( xlate, 0, 0, 1-sheared_eye[Z] );

	/* Build perspective matrix inline, substituting fov=2*atan(1,Z) */
	MAT_IDN( persp );
	/* From page 492 of Graphics Gems */
	persp[0] = sheared_eye[Z];	/* scaling: fov aspect term */
	persp[5] = sheared_eye[Z];	/* scaling: determines fov */

	/* From page 158 of Rogers Mathematical Elements */
	/* Z center of projection at Z=+1, r=-1/1 */
	persp[14] = -1;

	bn_mat_mul( t1, xlate, shear );
	bn_mat_mul( t2, persp, t1 );

	/* Now, move eye from Z=1 to Z=0, for clipping purposes */
	MAT_DELTAS( xlate, 0, 0, -1 );

	bn_mat_mul( pmat, xlate, t2 );
}

d849 1
a849 1
	if (argc != 2) {
d859 11
a869 2
	if (bn_decode_vect(eye_model, argv[1]) != 3)
		return TCL_ERROR;
d967 1
d969 2
a970 2
	if (argc != 2) {
		struct bu_vls vls;
d972 10
a981 9
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib vo_lookat");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (bn_decode_vect(look, argv[1]) != 3) {
		return TCL_ERROR;
d1002 7
d1146 24
a1169 4
vo_zoom_cmd(struct view_obj	*vop,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv)
d1190 1
a1190 6
	vop->vo_scale /= sf;
	vop->vo_size = 2.0 * vop->vo_scale;
	vop->vo_invSize = 1.0 / vop->vo_size;
	vo_update(vop, interp, 1);

	return TCL_OK;
d1355 6
a1360 4
vo_rot_cmd(struct view_obj	*vop,
	   Tcl_Interp		*interp,
	   int			argc,
	   char 		**argv)
a1361 2
	vect_t rvec;
	mat_t rmat;
a1362 37
	char coord = vop->vo_coord;

	if (argc < 2 || 3 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib vo_rot");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	/* process coord flag */
	if (argc == 3) {
		if (argv[1][0] == '-' &&
		    (argv[1][1] == 'v' || argv[1][1] == 'm') &&
		    argv[1][2] == '\0') {
			coord = argv[1][1];
			--argc;
			++argv;
		} else {
			struct bu_vls vls;

			bu_vls_init(&vls);
			bu_vls_printf(&vls, "helplib vo_rot");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);

			return TCL_ERROR;
		}
	}

	if (bn_decode_vect(rvec, argv[1]) != 3) {
		Tcl_AppendResult(interp, "vo_rot: bad xyz - ", argv[1], (char *)NULL);
		return TCL_ERROR;
	}
d1364 2
a1365 2
	VSCALE(rvec, rvec, -1.0);
	bn_mat_angles(rmat, rvec[X], rvec[Y], rvec[Z]);
d1380 1
a1380 1
	if (vop->vo_rotate_about != 'v') {
d1387 1
a1387 1
		switch (vop->vo_rotate_about) {
d1404 1
a1404 1
				bu_vls_printf(&vls, "vo_rot_tcl: bad rotate_about - %c\n", vop->vo_rotate_about);
d1428 53
d1495 35
a1529 1
	return vo_rot_cmd(vop, interp, argc-1, argv+1);
d1536 2
a1537 1
	   char 		**argv)
a1539 3
	point_t delta;
	point_t work;
	point_t vc, nvc;
d1578 1
a1578 18
	switch (coord) {
	case 'm':
		VSCALE(delta, tvec, vop->vo_local2base);
		MAT_DELTAS_GET_NEG(vc, vop->vo_center);
		break;
	case 'v':
		VSCALE(tvec, tvec, -2.0*vop->vo_local2base*vop->vo_invSize);
		MAT4X3PNT(work, vop->vo_view2model, tvec);
		MAT_DELTAS_GET_NEG(vc, vop->vo_center);
		VSUB2(delta, work, vc);
		break;
	}

	VSUB2(nvc, vc, delta);
	MAT_DELTAS_VEC_NEG(vop->vo_center, nvc);
	vo_update(vop, interp, 1);

	return TCL_OK;
d1595 15
a1609 1
	return vo_tra_cmd(vop, interp, argc-1, argv+1);
d1618 5
a1622 2
	vect_t slewvec;
	point_t model_center;
d1624 5
a1628 2
	if (argc != 2) {
		struct bu_vls vls;
d1630 2
a1631 4
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib vo_slew");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
d1633 1
a1633 1
		return TCL_ERROR;
d1636 20
a1655 3
	if (sscanf(argv[1], "%lf %lf", &slewvec[X], &slewvec[Y]) != 2) {
		Tcl_AppendResult(interp, "vo_slew: bad xy - ", argv[1], (char *)NULL);
		return TCL_ERROR;
d1658 4
a1661 4
	slewvec[Z] = 0.0;
	MAT4X3PNT(model_center, vop->vo_view2model, slewvec);
	MAT_DELTAS_VEC_NEG(vop->vo_center, model_center);
	vo_update(vop, interp, 1);
d1663 1
a1663 1
	return TCL_OK;
d1880 517
@


1.20
log
@*- create new function, vo_open_cmd, that
   returns "struct view_obj *"
@
text
@d47 1
a48 1
#if 0
d92 1
d94 1
d159 1
d189 1
d313 5
a317 9
/*
 * Get or set the view size.
 */
static int
vo_size_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a318 1
	struct view_obj *vop = (struct view_obj *)clientData;
d323 1
a323 1
	if (argc == 2) {
d333 2
a334 2
	if (argc == 3) {
		if (sscanf(argv[2], "%lf", &size) != 1) {
d336 1
a336 1
					 argv[2], (char *)NULL);
d358 4
a361 1
 * Get the inverse view size.
d364 4
a367 5
vo_invSize_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d370 10
d382 1
a382 1
	if (argc == 2) {
d401 4
a404 1
 * Get or set the azimuth, elevation and twist.
d407 4
a410 5
vo_aet_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d413 10
d426 1
a426 1
	if (argc == 2) { /* get aet */
d433 1
a433 1
	} else if (argc == 3) {  /* set aet */
d436 1
a436 1
		if ((n = bn_decode_vect(aet, argv[2])) == 2)
d459 4
a462 1
 * Get or set the rotation matrix.
d465 4
a468 5
vo_rmat_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d471 10
d484 1
a484 1
	if (argc == 2) { /* get rotation matrix */
d491 2
a492 2
	} else if (argc == 3) {  /* set rotation matrix */
		if (bn_decode_mat(rotation, argv[2]) != 16)
d511 4
a514 1
 * Get or set the view center.
d517 4
a520 5
vo_center_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d523 10
d537 1
a537 1
	if (argc == 2) {
d549 2
a550 2
	if (argc == 3) {
		if (bn_decode_vect(center, argv[2]) != 3)
d570 4
a573 1
 * Get the model2view matrix.
d576 4
a579 5
vo_model2view_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d582 10
d594 1
a594 1
	if (argc == 2) {
d613 4
a616 1
 * Get the pmodel2view matrix.
d619 4
a622 5
vo_pmodel2view_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d625 10
d637 1
a637 1
	if (argc == 2) {
d656 4
a659 1
 * Get the view2model matrix.
d662 4
a665 5
vo_view2model_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d668 10
d680 1
a680 1
	if (argc == 2) {
a698 2
 * Get/set the perspective angle.
 *
d700 1
a700 2
 *        procname perspective [angle]
 *
d703 4
a706 5
vo_perspective_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d709 10
d723 1
a723 1
	if (argc == 2) {
d733 2
a734 2
	if (argc == 3) {
		if (sscanf(argv[2], "%lf", &perspective) != 1) {
d736 1
a736 1
					 argv[2], (char *)NULL);
d764 4
a767 1
 * Get the perspective matrix.
d770 4
a773 5
vo_pmat_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d776 10
d788 1
a788 1
	if (argc == 2) {
d806 17
d824 3
a826 4
vo_update(vop, interp, oflag)
     struct view_obj *vop;
     Tcl_Interp *interp;
     int oflag;
d867 1
a867 2
vo_mat_aet(vop)
     struct view_obj *vop;
d895 6
a900 3
vo_persp_mat(m, fovy, aspect, near, far, backoff)
     mat_t	m;
     fastf_t	fovy, aspect, near, far, backoff;
d934 2
a935 3
vo_mike_persp_mat(pmat, eye)
     mat_t		pmat;
     const point_t	eye;
d983 5
a987 12
/*
 * Set the eye point.
 *
 * Usage:
 *	procname eye eye_point
 */
static int
vo_eye_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a988 1
	struct view_obj *vop = (struct view_obj *)clientData;
d993 1
a993 1
	if (argc != 3) {
d1003 1
a1003 1
	if (bn_decode_vect(eye_model, argv[2]) != 3)
d1024 1
a1024 1
 * Set the eye position.
d1027 1
a1027 1
 *	procname eye_pos pos
d1030 4
a1033 5
vo_eye_pos_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1036 10
d1048 1
a1048 1
	if (argc != 3) {
d1058 1
a1058 1
	if (bn_decode_vect(eye_pos, argv[2]) != 3)
d1074 1
a1074 1
 * Set look-at point.
d1077 1
a1077 1
 *	procname lookat lookat_point
d1080 4
a1083 5
vo_lookat_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1086 10
d1103 1
a1103 1
	if (argc != 3) {
d1113 1
a1113 1
	if (bn_decode_vect(look, argv[2]) != 3) {
d1138 2
d1141 1
a1141 1
 *	procname orient quat
d1144 4
a1147 5
vo_orientation_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1150 10
d1162 1
a1162 1
	if (argc != 3) {
d1172 1
a1172 1
	if (bn_decode_quat(quat, argv[2]) != 4) {
d1184 1
a1184 1
 *	procname pov center quat scale eye_pos perspective
d1187 4
a1190 5
vo_pov_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1193 10
d1209 1
a1209 1
	if (argc != 7) {
d1221 1
a1221 1
	if (bn_decode_vect(center, argv[2]) != 3) {
d1225 1
a1225 1
	if (bn_decode_quat(quat, argv[3]) != 4) {
d1229 1
a1229 1
	if (sscanf(argv[4], "%lf", &scale) != 1) {
d1233 1
a1233 1
	if (bn_decode_vect(eye_pos, argv[5]) != 3) {
d1237 1
a1237 1
	if (sscanf(argv[4], "%lf", &perspective) != 1) {
d1258 1
a1258 1
 *	procname zoom scale_factor
d1261 4
a1264 5
vo_zoom_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1267 10
d1279 1
a1279 1
	if (argc != 3) {
d1290 1
a1290 1
	if (sscanf(argv[2], "%lf", &sf) != 1) {
d1292 1
a1292 1
				 argv[2], (char *)NULL);
a1304 2
 * Set/get local units.
 *
d1306 1
a1306 1
 *	procname units unit_spec
d1309 4
a1312 5
vo_units_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1315 10
d1328 1
a1328 1
	if (argc == 2) {
d1338 1
a1338 1
	if (argc == 3) {
d1341 1
a1341 1
		if ((uval = bu_units_conversion(argv[2])) == 0) {
d1343 1
a1343 1
			bu_vls_printf(&vls, "unrecognized unit type - %s\n", argv[2]);
d1365 1
a1365 1
 * Get base2local conversion factor.
d1368 1
a1368 1
 *	procname base2local
d1371 4
a1374 5
vo_base2local_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1377 10
d1391 1
a1391 1
	if (argc != 2) {
d1407 1
a1407 1
 * Get local2base conversion factor.
d1410 1
a1410 1
 *	procname local2base
d1413 4
a1416 5
vo_local2base_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1419 10
d1433 1
a1433 1
	if (argc != 2) {
d1449 1
a1449 1
 * Rotate the view according to xyz.
d1452 1
a1452 1
 *	procname rot [-v|-m] xyz
d1455 4
a1458 5
vo_rot_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1461 10
d1476 1
a1476 1
	if (argc < 3 || 4 < argc) {
d1488 5
a1492 5
	if (argc == 4) {
		if (argv[2][0] == '-' &&
		    (argv[2][1] == 'v' || argv[2][1] == 'm') &&
		    argv[2][2] == '\0') {
			coord = argv[2][1];
d1507 2
a1508 2
	if (bn_decode_vect(rvec, argv[2]) != 3) {
		Tcl_AppendResult(interp, "vo_rot: bad xyz - ", argv[2], (char *)NULL);
d1577 1
a1577 1
 * Translate the view according to xyz.
d1580 1
a1580 1
 *	procname tra xyz
d1583 4
a1586 5
vo_tra_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1589 10
d1605 1
a1605 1
	if (argc < 3 || 4 < argc) {
d1617 5
a1621 5
	if (argc == 4) {
		if (argv[2][0] == '-' &&
		    (argv[2][1] == 'v' || argv[2][1] == 'm') &&
		    argv[2][2] == '\0') {
			coord = argv[2][1];
d1636 2
a1637 2
	if (bn_decode_vect(tvec, argv[2]) != 3) {
		Tcl_AppendResult(interp, "vo_tra: bad xyz - ", argv[2], (char *)NULL);
d1662 1
a1662 1
 * Make xyz the new view center.
d1665 1
a1665 1
 *	procname slew xy
d1668 4
a1671 5
vo_slew_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1674 10
d1687 1
a1687 1
	if (argc != 3) {
d1698 2
a1699 2
	if (sscanf(argv[2], "%lf %lf", &slewvec[X], &slewvec[Y]) != 2) {
		Tcl_AppendResult(interp, "vo_slew: bad xy - ", argv[2], (char *)NULL);
d1712 1
a1712 1
 * Attach/detach observers to/from list.
d1715 1
a1715 2
 *	  procname observer cmd [args]
 *
d1718 4
a1721 5
vo_observer_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1725 10
a1734 1
	if (argc < 3) {
d1746 1
a1746 1
		      interp, argc - 2, argv + 2, bu_observer_cmds, 0);
d1750 1
a1750 1
 * Get/set the coordinate system.
d1753 1
a1753 2
 *	  procname coord [v|m]
 *
d1756 15
a1770 5
vo_coord_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a1772 1
	struct view_obj *vop = (struct view_obj *)clientData;
d1775 1
a1775 1
	if (argc == 2) {
d1784 2
a1785 2
	if (argc == 3) {
		switch (argv[2][0]) {
d1788 1
a1788 1
			vop->vo_coord = argv[2][0];
d1802 1
a1802 1
 * Get/set the rotate about point.
d1805 1
a1805 2
 *	  procname rotate_about [e|k|m|v]
 *
d1808 15
a1822 5
vo_rotate_about_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a1824 1
	struct view_obj *vop = (struct view_obj *)clientData;
d1827 1
a1827 1
	if (argc == 2) {
d1836 2
a1837 2
	if (argc == 3 && argv[2][1] == '\0') {
		switch (argv[2][0]) {
d1842 1
a1842 1
			vop->vo_rotate_about = argv[2][0];
d1856 1
a1856 1
 * Get/set the keypoint.
d1859 1
a1859 2
 *	  procname keypoint [point]
 *
d1862 15
a1876 5
vo_keypoint_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a1879 1
	struct view_obj *vop = (struct view_obj *)clientData;
d1882 1
a1882 1
	if (argc == 2) {
d1892 3
a1894 3
	if (argc == 3) {
		if (bn_decode_vect(tvec, argv[2]) != 3) {
			Tcl_AppendResult(interp, "vo_keypoint: bad xyz - ", argv[2], (char *)0);
d1908 17
@


1.19
log
@CONST to const
@
text
@d5 2
a6 1
 * controlling the view.
d188 1
a188 3
 * Open a view object.
 *
 * USAGE: v_open [name]
d190 3
a192 5
int vo_open_tcl(clientData, interp, argc, argv)
     ClientData      clientData;
     Tcl_Interp      *interp;
     int             argc;
     char            **argv;
d196 1
a196 7
	if (argc == 1) {
		/* get list of view objects */
		for (BU_LIST_FOR(vop, view_obj, &HeadViewObj.l))
			Tcl_AppendResult(interp, bu_vls_addr(&vop->vo_name), " ", (char *)NULL);

		return TCL_OK;
	}
d198 1
a198 10
	/* check to see if view object exists */
	for (BU_LIST_FOR(vop, view_obj, &HeadViewObj.l)) {
		if (strcmp(argv[1],bu_vls_addr(&vop->vo_name)) == 0) {
			Tcl_AppendResult(interp, "vo_open: ", argv[1],
					 " exists.\n", (char *)NULL);
			return TCL_ERROR;
		}
	}

	BU_GETSTRUCT(vop,view_obj);
d200 1
a200 1
	bu_vls_strcpy(&vop->vo_name,argv[1]);
a212 1

d218 27
d254 1
@


1.18
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d808 1
a808 1
     CONST point_t	eye;
@


1.17
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d451 1
a451 1
		bn_mat_copy(vop->vo_rotation, rotation);
@


1.16
log
@*- add new methods to view obj:
   - vo_coord_tcl - set/get coordinate system
   - vo_rotate_about_tcl - set/get point about which to rotate
   - vo_keypoint_tcl - set/get keypoint
*- mods to vo_rot_tcl to consider the coordinate system and
   the rotation point
*- mods to vo_tra_tcl to consider the coordinate system
@
text
@d225 2
a226 2
	bn_mat_idn(vop->vo_rotation);
	bn_mat_idn(vop->vo_center);
d778 1
a778 1
	bn_mat_idn(m2);
d788 1
a788 1
	bn_mat_idn(tran);
d822 1
a822 1
	bn_mat_idn(shear);
d833 1
a833 1
	bn_mat_idn(xlate);
d838 1
a838 1
	bn_mat_idn( persp );
@


1.15
log
@Patches for compiling under RedHat 7.0
@
text
@d29 1
a29 1
#ifdef HAVE_STRING_H
d31 2
d74 3
d92 1
d96 1
d108 1
d227 3
d1261 1
a1261 1
 *	procname rot xyz
d1273 2
d1276 1
a1276 1
	if (argc != 3) {
d1287 20
d1314 57
a1370 1
	bn_mat_mul2(rmat, vop->vo_rotation); /* pure rotation */
d1394 1
d1396 1
a1396 1
	if (argc != 3) {
d1407 20
d1432 13
a1444 4
	VSCALE(tvec, tvec, -2.0*vop->vo_local2base*vop->vo_invSize);
	MAT4X3PNT(work, vop->vo_view2model, tvec);
	MAT_DELTAS_GET_NEG(vc, vop->vo_center);
	VSUB2(delta, work, vc);
d1522 137
@


1.14
log
@
lint
@
text
@d29 3
@


1.13
log
@Fixed bad practice in db5_update_ident definition: implicit int return
@
text
@d80 18
a97 18
	"aet",			vo_aet_tcl,
	"base2local",		vo_base2local_tcl,
	"center",		vo_center_tcl,
	"close",		vo_close_tcl,
	"eye",			vo_eye_tcl,
	"eye_pos",		vo_eye_pos_tcl,
	"invSize",		vo_invSize_tcl,
	"local2base",		vo_local2base_tcl,
	"lookat",		vo_lookat_tcl,
	"model2view",		vo_model2view_tcl,
	"observer",		vo_observer_tcl,
	"orientation",		vo_orientation_tcl,
	"perspective",		vo_perspective_tcl,
	"pmat",			vo_pmat_tcl,
	"pmodel2view",		vo_pmodel2view_tcl,
	"pov",			vo_pov_tcl,
	"rmat",			vo_rmat_tcl,
	"rot",			vo_rot_tcl,
d99 1
a99 1
	"scale",		vo_scale_tcl,
d101 7
a107 7
	"size",			vo_size_tcl,
	"slew",			vo_slew_tcl,
	"tra",			vo_tra_tcl,
	"units",		vo_units_tcl,
	"view2model",		vo_view2model_tcl,
	"zoom",			vo_zoom_tcl,
	(char *)0,		(int (*)())0
@


1.12
log
@*- change to helplib argument
@
text
@d180 1
a180 1
vo_open_tcl(clientData, interp, argc, argv)
@


1.11
log
@*- alphabetize command list
@
text
@d644 1
a644 1
	bu_vls_printf(&vls, "helplib vo_pmat");
@


1.10
log
@*- mods to vo_aet_tcl to accept two or three
   values. If only two are given then twist is 0.
@
text
@d42 1
d44 1
d90 1
d95 1
d98 1
a98 1
	"pov",			vo_pov_tcl,
d100 1
a106 1
	"observer",		vo_observer_tcl,
d178 1
a178 1
 * USAGE: v_open [name [args]]
d235 1
d284 1
@


1.9
log
@*- import persp_mat from mged/dozoom
@
text
@d382 6
a387 2
		if (bn_decode_vect(aet, argv[2]) != 3)
			return TCL_ERROR;
d396 1
@


1.8
log
@*- add observer command
@
text
@d71 1
d618 6
d625 1
d734 32
@


1.7
log
@Eliminnated some unused variables
@
text
@d66 1
d101 1
d132 3
d211 6
a216 1
	vo_update(vop);
a222 1
	BU_LIST_APPEND(&HeadViewObj.l,&vop->l);
d265 1
a265 1
		vo_update(vop);
d314 1
a314 1
		vo_update(vop);
d386 1
a386 1
		vo_update(vop);
d426 1
a426 1
		vo_update(vop);
d473 1
a473 1
		vo_update(vop);
d618 1
a618 1
		vo_update(vop);
d664 1
a664 1
vo_update(vop)
d666 2
d702 3
d826 1
a826 1
	vo_update(vop);
d834 1
a834 1
	vo_update(vop);
d875 1
a875 1
	vo_update(vop);
d930 1
a930 1
	vo_update(vop);
d964 1
a964 1
	vo_update(vop);
d1029 1
a1029 1
	vo_update(vop);
d1068 1
a1068 1
	vo_update(vop);
a1205 1
	struct bu_vls vls;
d1209 2
a1210 1
	bu_vls_init(&vls);
d1212 1
a1212 1
	if (argc != 3) {
d1228 1
a1228 1
	vo_update(vop);
a1246 1
	struct bu_vls vls;
d1252 2
a1253 1
	bu_vls_init(&vls);
d1255 1
a1255 1
	if (argc != 3) {
d1274 1
a1274 1
	vo_update(vop);
d1296 11
d1315 1
a1315 1
	vo_update(vop);
d1318 31
@


1.6
log
@*- mods to vo_zoom_tcl
@
text
@a330 1
	fastf_t size;
a371 2
		mat_t m;

a885 1
	struct bu_vls vls;
a932 1
	register int i;
a1278 1
	struct bu_vls vls;
@


1.5
log
@*- add commands slew, tra, and rot
*- old command "rot" becomes rmat
@
text
@d297 1
a297 1
			Tcl_AppendResult(interp, "bad size value - ",
d1057 2
@


1.4
log
@*- just cleaning
@
text
@d46 1
a46 1
static int vo_rot_tcl();
d53 3
d90 2
a92 1
	"rot",			vo_rot_tcl,
d95 2
d398 1
a398 1
vo_rot_tcl(clientData, interp, argc, argv)
d427 1
a427 1
	bu_vls_printf(&vls, "helplib vo_rot");
d1152 1
a1152 1
 *	procname 
d1177 118
@


1.3
log
@*- add view object commands: eye, eye_pos, lookat, orientation,
			pov, units, zoom, local2base, base2local
@
text
@a882 1
	int status;
d916 1
a916 1
	return status;
@


1.2
log
@*- create list of potential commands
@
text
@d40 28
a67 18
HIDDEN int vo_open_tcl();
HIDDEN int vo_close_tcl();
HIDDEN int vo_scale_tcl();
HIDDEN int vo_size_tcl();
HIDDEN int vo_invSize_tcl();
HIDDEN int vo_aet_tcl();
HIDDEN int vo_rot_tcl();
HIDDEN int vo_center_tcl();
HIDDEN int vo_model2view_tcl();
HIDDEN int vo_pmodel2view_tcl();
HIDDEN int vo_view2model_tcl();
HIDDEN int vo_perspective_tcl();
HIDDEN int vo_pmat_tcl();
HIDDEN int vo_update_tcl();
HIDDEN int vo_cmd();
HIDDEN void vo_update();
HIDDEN void vo_mat_aet();
HIDDEN void vo_mike_persp_mat();
a69 1
HIDDEN point_t vo_eye_pos_scr = {0, 0, 1};
d71 1
a71 1
HIDDEN struct bu_cmdtab vo_cmds[] = 
a72 3
	"scale",		vo_scale_tcl,
	"size",			vo_size_tcl,
	"invSize",		vo_invSize_tcl,
d74 1
a74 1
	"rot",			vo_rot_tcl,
d76 6
d83 1
a83 2
	"pmodel2view",		vo_pmodel2view_tcl,
	"view2model",		vo_view2model_tcl,
d86 1
a86 5
	"update",		vo_update_tcl,
#if 0
	"eye",			vo_eye_tcl,
	"lookat",		vo_lookat_tcl,
	"orientation",		vo_orientation_tcl,
d88 3
a90 2
	"read_view"		vo_read_view_tcl,
	"write_view"		vo_write_view_tcl,
d92 1
a93 2
#endif
	"close",		vo_close_tcl,
d97 1
a97 1
HIDDEN int
d99 4
a102 4
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char		**argv;
d104 1
a104 1
  return bu_cmd(clientData, interp, argc, argv, vo_cmds, 1);
d109 1
a109 1
Tcl_Interp *interp;
d111 3
a113 3
  BU_LIST_INIT(&HeadViewObj.l);
  (void)Tcl_CreateCommand(interp, "v_open", vo_open_tcl,
			  (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
d115 1
a115 1
  return TCL_OK;
d118 1
a118 1
HIDDEN void
d120 1
a120 1
ClientData clientData;
d122 1
a122 1
  struct view_obj *vop = (struct view_obj *)clientData;
d124 3
a126 3
  bu_vls_free(&vop->vo_name);
  BU_LIST_DEQUEUE(&vop->l);
  bu_free((genptr_t)vop, "vo_deleteProc: vop");
d135 1
a135 1
HIDDEN int
d137 4
a140 4
ClientData      clientData;
Tcl_Interp      *interp;
int             argc;
char            **argv;
d165 48
a212 43
ClientData      clientData;
Tcl_Interp      *interp;
int             argc;
char            **argv;
{
  struct view_obj *vop;

  if (argc == 1) {
    /* get list of view objects */
    for (BU_LIST_FOR(vop, view_obj, &HeadViewObj.l))
      Tcl_AppendResult(interp, bu_vls_addr(&vop->vo_name), " ", (char *)NULL);

    return TCL_OK;
  }

  /* check to see if view object exists */
  for (BU_LIST_FOR(vop, view_obj, &HeadViewObj.l)) {
    if (strcmp(argv[1],bu_vls_addr(&vop->vo_name)) == 0) {
      Tcl_AppendResult(interp, "vo_open: ", argv[1],
		       " exists.\n", (char *)NULL);
      return TCL_ERROR;
    }
  }

  BU_GETSTRUCT(vop,view_obj);
  bu_vls_init(&vop->vo_name);
  bu_vls_strcpy(&vop->vo_name,argv[1]);
  vop->vo_scale = 1.0;
  bn_mat_idn(vop->vo_rotation);
  bn_mat_idn(vop->vo_center);
  vo_update(vop);

  (void)Tcl_CreateCommand(interp,
			  bu_vls_addr(&vop->vo_name),
			  vo_cmd,
			  (ClientData)vop,
			  vo_deleteProc);
  BU_LIST_APPEND(&HeadViewObj.l,&vop->l);

  /* Return new function name as result */
  Tcl_ResetResult(interp);
  Tcl_AppendResult(interp, bu_vls_addr(&vop->vo_name), (char *)NULL);
  return TCL_OK;
d218 1
a218 1
HIDDEN int
d220 34
a253 37
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct view_obj *vop = (struct view_obj *)clientData;
  struct bu_vls vls;
  fastf_t scale;

  if (argc == 2) { /* get view scale */
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%g", vop->vo_scale);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_OK;
  }

  if (argc == 3) {  /* set view scale */
    if (sscanf(argv[2], "%lf", &scale) != 1) {
      Tcl_AppendResult(interp, "bad scale value - ",
		       argv[2], (char *)NULL);
      return TCL_ERROR;
    }

    vop->vo_scale = scale;
    vop->vo_size = 2.0 * scale;
    vop->vo_invSize = 1.0 / vop->vo_size;

    return TCL_OK;
  }

  /* compose error message */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib vo_scale");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d255 7
a261 1
  return TCL_ERROR;
d267 1
a267 1
HIDDEN int
d269 31
a299 39
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct view_obj *vop = (struct view_obj *)clientData;
  struct bu_vls vls;
  fastf_t size;

  /* get view size */
  if (argc == 2) {
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%g", vop->vo_size);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_OK;
  }

  /* set view size */
  if (argc == 3) {
    if (sscanf(argv[2], "%lf", &size) != 1) {
      Tcl_AppendResult(interp, "bad size value - ",
		       argv[2], (char *)NULL);
      return TCL_ERROR;
    }

    vop->vo_size = size;
    vop->vo_invSize = 1.0 / size;
    vop->vo_scale = 0.5 * size;

    return TCL_OK;
  }

  /* compose error message */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib vo_size");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d301 10
a310 1
  return TCL_ERROR;
d316 1
a316 1
HIDDEN int
d318 8
a325 23
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct view_obj *vop = (struct view_obj *)clientData;
  struct bu_vls vls;
  fastf_t size;

  if (argc == 2) {
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%g", vop->vo_invSize);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_OK;
  }

  /* compose error message */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib vo_invSize");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d327 16
a342 1
  return TCL_ERROR;
d348 1
a348 1
HIDDEN int
d350 34
a383 31
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct view_obj *vop = (struct view_obj *)clientData;
  struct bu_vls vls;

  if (argc == 2) { /* get aet */
    bu_vls_init(&vls);
    bn_encode_vect(&vls, vop->vo_aet);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_OK;
  } else if (argc == 3) {  /* set aet */
    mat_t m;

    if (bn_decode_vect(vop->vo_aet, argv[2]) != 3)
      return TCL_ERROR;

    vo_mat_aet(vop);

    return TCL_OK;
  }

  /* compose error message */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib vo_aet");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d385 1
a385 1
  return TCL_ERROR;
d391 1
a391 1
HIDDEN int
d393 14
a406 27
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct view_obj *vop = (struct view_obj *)clientData;
  struct bu_vls vls;

  if (argc == 2) { /* get rotation matrix */
    bu_vls_init(&vls);
    bn_encode_mat(&vls, vop->vo_rotation);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_OK;
  } else if (argc == 3) {  /* set rotation matrix */
    if (bn_decode_mat(vop->vo_rotation, argv[2]) != 16)
      return TCL_ERROR;

    return TCL_OK;
  }

  /* compose error message */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib vo_rot");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d408 18
a425 1
  return TCL_ERROR;
d431 1
a431 1
HIDDEN int
d433 17
a449 31
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct view_obj *vop = (struct view_obj *)clientData;
  vect_t center;
  struct bu_vls vls;

  if (argc == 2) { /* get view center */
    MAT_DELTAS_GET_NEG(center, vop->vo_center);
    bu_vls_init(&vls);
    bn_encode_vect(&vls, center);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_OK;
  } else if (argc == 3) {  /* set view center */
    if (bn_decode_vect(center, argv[2]) != 3)
      return TCL_ERROR;

    MAT_DELTAS_VEC_NEG(vop->vo_center, center);

    return TCL_OK;
  }

  /* compose error message */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib vo_center");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d451 22
a472 1
  return TCL_ERROR;
d478 1
a478 1
HIDDEN int
d480 16
a495 22
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct view_obj *vop = (struct view_obj *)clientData;
  struct bu_vls vls;

  if (argc == 2) {
    bu_vls_init(&vls);
    bn_encode_mat(&vls, vop->vo_model2view);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_OK;
  }

  /* compose error message */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib vo_model2view");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d497 7
a503 1
  return TCL_ERROR;
d509 1
a509 1
HIDDEN int
d511 22
a532 22
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct view_obj *vop = (struct view_obj *)clientData;
  struct bu_vls vls;

  if (argc == 2) {
    bu_vls_init(&vls);
    bn_encode_mat(&vls, vop->vo_pmodel2view);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_OK;
  }

  /* compose error message */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib vo_pmodel2view");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d534 1
a534 1
  return TCL_ERROR;
d540 1
a540 1
HIDDEN int
d542 22
a563 22
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct view_obj *vop = (struct view_obj *)clientData;
  struct bu_vls vls;

  if (argc == 2) {
    bu_vls_init(&vls);
    bn_encode_mat(&vls, vop->vo_view2model);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_OK;
  }

  /* compose error message */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib vo_view2model");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d565 1
a565 1
  return TCL_ERROR;
d575 1
a575 1
HIDDEN int
d577 33
a609 38
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct view_obj *vop = (struct view_obj *)clientData;
  struct bu_vls vls;
  fastf_t perspective;

  /* get the perspective angle */
  if (argc == 2) {
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%g", vop->vo_perspective);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_OK;
  }

  /* set the perspective angle */
  if (argc == 3) {
    if (sscanf(argv[2], "%lf", &perspective) != 1) {
      Tcl_AppendResult(interp, "bad perspective angle - ",
		       argv[2], (char *)NULL);
      return TCL_ERROR;
    }

    vop->vo_perspective = perspective;
    vo_mike_persp_mat(vop->vo_pmat, vo_eye_pos_scr);

    return TCL_OK;
  }

  /* Compose error message */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib vo_pmat");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d611 7
a617 1
  return TCL_ERROR;
d623 1
a623 1
HIDDEN int
d625 4
a628 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d630 2
a631 2
  struct view_obj *vop = (struct view_obj *)clientData;
  struct bu_vls vls;
d633 5
a637 5
  if (argc == 2) {
    bu_vls_init(&vls);
    bn_encode_mat(&vls, vop->vo_pmat);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
d639 2
a640 2
    return TCL_OK;
  }
d642 5
a646 5
  /* compose error message */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib vo_pmat");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d648 1
a648 1
  return TCL_ERROR;
d651 1
a651 1
HIDDEN void
d653 1
a653 1
struct view_obj *vop;
d655 2
a656 2
  vect_t work, work1;
  vect_t temp, temp1;
d658 27
a684 48
  bn_mat_mul(vop->vo_model2view,
	     vop->vo_rotation,
	     vop->vo_center);
  vop->vo_model2view[15] = vop->vo_scale;
  bn_mat_inv(vop->vo_view2model, vop->vo_model2view);

  /* Find current azimuth, elevation, and twist angles */
  VSET( work , 0.0, 0.0, 1.0 );       /* view z-direction */
  MAT4X3VEC( temp , vop->vo_view2model , work );
  VSET( work1 , 1.0, 0.0, 0.0 );      /* view x-direction */
  MAT4X3VEC( temp1 , vop->vo_view2model , work1 );

  /* calculate angles using accuracy of 0.005, since display
   * shows 2 digits right of decimal point */
  bn_aet_vec( &vop->vo_aet[0],
	      &vop->vo_aet[1],
	      &vop->vo_aet[2],
	      temp , temp1 , (fastf_t)0.005 );

  /* Force azimuth range to be [0,360] */
  if((NEAR_ZERO(vop->vo_aet[1] - 90.0,(fastf_t)0.005) ||
      NEAR_ZERO(vop->vo_aet[1] + 90.0,(fastf_t)0.005)) &&
     vop->vo_aet[0] < 0 &&
     !NEAR_ZERO(vop->vo_aet[0],(fastf_t)0.005))
    vop->vo_aet[0] += 360.0;
  else if(NEAR_ZERO(vop->vo_aet[0],(fastf_t)0.005))
    vop->vo_aet[0] = 0.0;

  /* apply the perspective angle to model2view */
  bn_mat_mul(vop->vo_pmodel2view, vop->vo_pmat, vop->vo_model2view);
}

HIDDEN int
vo_update_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct view_obj *vop = (struct view_obj *)clientData;

  if (argc != 2) {
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helplib vo_update");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
d686 2
a687 5
    return TCL_ERROR;
  }

  vo_update(vop);
  return TCL_OK;
d690 1
a690 1
HIDDEN void
d692 1
a692 1
struct view_obj *vop;
d694 15
a708 15
  mat_t tmat;
  fastf_t twist;
  fastf_t c_twist;
  fastf_t s_twist;

  bn_mat_angles(vop->vo_rotation,
		270.0 + vop->vo_aet[1],
		0.0,
		270.0 - vop->vo_aet[0]);

  twist = -vop->vo_aet[2] * bn_degtorad;
  c_twist = cos(twist);
  s_twist = sin(twist);
  bn_mat_zrot(tmat, s_twist, c_twist);
  bn_mat_mul2(tmat, vop->vo_rotation);
d723 1
a723 1
HIDDEN void
d725 430
a1154 2
mat_t		pmat;
CONST point_t	eye;
d1156 18
a1173 88
  mat_t	shear;
  mat_t	persp;
  mat_t	xlate;
  mat_t	t1, t2;
  point_t	sheared_eye;
#if 0
  fastf_t	near, far;
  point_t	a,b;
#endif

  if( eye[Z] < SMALL )  {
    VPRINT("mike_persp_mat(): ERROR, z<0, eye", eye);
    return;
  }

  /* Shear "eye" to +Z axis */
  bn_mat_idn(shear);
  shear[2] = -eye[X]/eye[Z];
  shear[6] = -eye[Y]/eye[Z];

  MAT4X3VEC( sheared_eye, shear, eye );
  if( !NEAR_ZERO(sheared_eye[X], .01) || !NEAR_ZERO(sheared_eye[Y], .01) )  {
    VPRINT("ERROR sheared_eye", sheared_eye);
    return;
  }
#if 0
  VPRINT("sheared_eye", sheared_eye);
#endif

  /* Translate along +Z axis to put sheared_eye at (0,0,1). */
  bn_mat_idn(xlate);
  /* XXX should I use MAT_DELTAS_VEC_NEG()?  X and Y should be 0 now */
  MAT_DELTAS( xlate, 0, 0, 1-sheared_eye[Z] );

  /* Build perspective matrix inline, substituting fov=2*atan(1,Z) */
  bn_mat_idn( persp );
  /* From page 492 of Graphics Gems */
  persp[0] = sheared_eye[Z];	/* scaling: fov aspect term */
  persp[5] = sheared_eye[Z];	/* scaling: determines fov */

  /* From page 158 of Rogers Mathematical Elements */
  /* Z center of projection at Z=+1, r=-1/1 */
  persp[14] = -1;

  bn_mat_mul( t1, xlate, shear );
  bn_mat_mul( t2, persp, t1 );
#if 0
  /* t2 has perspective matrix, with Z ranging from -1 to +1.
   * In order to control "near" and "far clipping planes,
   * need to scale and translate in Z.
   * For example, to get Z effective Z range of -1 to +11,
   * divide Z by 12/2, then xlate by (6-1).
   */
  t2[10] /= 6;		/* near+far/2 */
  MAT_DELTAS( xlate, 0, 0, -5 );
#else
  /* Now, move eye from Z=1 to Z=0, for clipping purposes */
  MAT_DELTAS( xlate, 0, 0, -1 );
#endif
  bn_mat_mul( pmat, xlate, t2 );
#if 0
  bn_mat_print("pmat",pmat);

  /* Some quick checking */
  VSET( a, 0.0, 0.0, -1.0 );
  MAT4X3PNT( b, pmat, a );
  VPRINT("0,0,-1 ->", b);

  VSET( a, 1.0, 1.0, -1.0 );
  MAT4X3PNT( b, pmat, a );
  VPRINT("1,1,-1 ->", b);

  VSET( a, 0.0, 0.0, 0.0 );
  MAT4X3PNT( b, pmat, a );
  VPRINT("0,0,0 ->", b);

  VSET( a, 1.0, 1.0, 0.0 );
  MAT4X3PNT( b, pmat, a );
  VPRINT("1,1,0 ->", b);

  VSET( a, 1.0, 1.0, 1.0 );
  MAT4X3PNT( b, pmat, a );
  VPRINT("1,1,1 ->", b);

  VSET( a, 0.0, 0.0, 1.0 );
  MAT4X3PNT( b, pmat, a );
  VPRINT("0,0,1 ->", b);
#endif
@


1.1
log
@View Object
@
text
@d76 10
@

