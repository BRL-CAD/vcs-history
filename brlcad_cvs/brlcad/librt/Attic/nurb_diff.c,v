head	11.10;
access;
symbols
	ansi-20040405-merged:11.6.2.2
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.6.10.1
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.6.4.1
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.3
	offsite-5-3-pre:11.3
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.3
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.10
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.08.06;	author jra;	state Exp;
branches
	11.6.2.1
	11.6.4.1
	11.6.10.1;
next	11.5;

11.5
date	2002.08.15.20.55.19;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2001.04.20.22.29.54;	author morrison;	state Exp;
branches;
next	11.3;

11.3
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.12.01.02.49.33;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.45;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	10.7;

10.7
date	94.08.11.01.11.02;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	92.06.02.22.51.58;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.05.29.01.20.01;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.05.29.00.52.21;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.05.28.22.12.06;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.27.16.57.21;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.06;	author mike;	state Rel4_0;
branches;
next	1.2;

1.2
date	91.06.14.09.42.12;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	91.05.18.02.35.20;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.6.2.1
date	2002.09.19.18.01.42;	author morrison;	state Exp;
branches;
next	11.6.2.2;

11.6.2.2
date	2004.03.17.21.18.55;	author morrison;	state Exp;
branches;
next	;

11.6.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.6.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	;


desc
@Differences
@


11.10
log
@moved to src/
@
text
@/*	N U R B _ D I F F . C
 *
 *  Function -
 *	Differentiate a Non Uniform Rational B-Spline (NURB) Surface.
 *  Author -
 *	Paul Randal Stay
 * 
 *  Source -
 * 	SECAD/VLD Computing Consortium, Bldg 394
 *	The U.S. Army Ballistic Research Laboratory
 * 	Aberdeen Proving Ground, Maryland 21005
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"

/* Given a NURB surface and a direction, differentiate the surface
 * and return a new surface which is the derivative of the original
 * surface.
 *
 * The algorithm is found in the following reference:
 *	Carl De Boor, "A Practical Guide To Splines", page 139
 *
 * The algorithm deals mainly with the new control mesh, but the new knot
 * vector is a subset of the original. (subtract a knot from each of 
 * the ends).
 *
 * Arguments to rt_nurb_s_diff() --
 *	srf - NURB surface
 *	dir - parametric direction of the split.
 */

struct face_g_snurb *
rt_nurb_s_diff(const struct face_g_snurb *srf, int dir)
{
	struct face_g_snurb *nsrf;
	int	i;

	NMG_CK_SNURB(srf);

	if (dir == RT_NURB_SPLIT_ROW) {
		nsrf = (struct face_g_snurb *)
		rt_nurb_new_snurb( srf->order[0] - 1, srf->order[1], 
		    srf->u.k_size - 2, srf->v.k_size,
		    srf->s_size[0], srf->s_size[1] - 1, 
		    srf->pt_type, (struct resource *)NULL );

		for ( i = 0; i < srf->s_size[0]; i++) {
			fastf_t * old_points, *new_points;

			old_points = srf->ctl_points + 
			    i * RT_NURB_EXTRACT_COORDS(srf->pt_type)
			*srf->s_size[1];

			new_points = nsrf->ctl_points + 
			    i * RT_NURB_EXTRACT_COORDS(nsrf->pt_type)
			*nsrf->s_size[1];

			rt_nurb_mesh_diff( srf->order[0], 
			    old_points, new_points, srf->u.knots,
			    RT_NURB_EXTRACT_COORDS(srf->pt_type),
			    RT_NURB_EXTRACT_COORDS(nsrf->pt_type),
			    srf->s_size[1], srf->pt_type);
		}

		for (i = 1; i < srf->u.k_size - 1; i++)
			nsrf->u.knots[i - 1] = srf->u.knots[i];

		for (i = 0; i < srf->v.k_size; i++)
			nsrf->v.knots[i] = srf->v.knots[i];
	} else	 {
		nsrf = (struct face_g_snurb *) rt_nurb_new_snurb( 
		    srf->order[0], srf->order[1] - 1, 
		    srf->u.k_size, srf->v.k_size - 2,
		    srf->s_size[0] - 1, srf->s_size[1], 
		    srf->pt_type, (struct resource *)NULL );

		for ( i = 0; i < srf->s_size[1]; i++) {
			fastf_t * old_points, *new_points;

			old_points = srf->ctl_points + 
			    i * RT_NURB_EXTRACT_COORDS(srf->pt_type);

			new_points = nsrf->ctl_points + 
			    i * RT_NURB_EXTRACT_COORDS(nsrf->pt_type);

			rt_nurb_mesh_diff( srf->order[1], 
			    old_points, new_points, srf->v.knots,
			    RT_NURB_EXTRACT_COORDS(srf->pt_type) * 
			    srf->s_size[1],
			    RT_NURB_EXTRACT_COORDS(nsrf->pt_type) * 
			    nsrf->s_size[1],
			    srf->s_size[0], srf->pt_type);
		}

		for (i = 0; i < srf->u.k_size; i++)
			nsrf->u.knots[i] = srf->u.knots[i];

		for (i = 1; i < srf->v.k_size - 1; i++)
			nsrf->v.knots[i-1] = srf->v.knots[i];
	}
	return nsrf;
}

/* Do the same thing for a curve. */

struct edge_g_cnurb *
rt_nurb_c_diff(const struct edge_g_cnurb *crv)
{

	struct edge_g_cnurb *ncrv;
	fastf_t * opts, *npts;
	int	i;

	NMG_CK_CNURB(crv);

	ncrv = (struct edge_g_cnurb *) rt_nurb_new_cnurb( crv->order - 1, 
	    crv->k.k_size - 2, crv->c_size - 1, 
	    crv->pt_type);

	opts = (fastf_t * ) crv->ctl_points;
	npts = (fastf_t * ) ncrv->ctl_points;

	rt_nurb_mesh_diff( crv->order, opts, npts, crv->k.knots, 
	    RT_NURB_EXTRACT_COORDS( crv->pt_type),
	    RT_NURB_EXTRACT_COORDS( ncrv->pt_type),
	    crv->c_size, crv->pt_type );

	for ( i = 1; i < crv->k.k_size - 1; i++)
		ncrv->k.knots[ i - 1] = crv->k.knots[i];

	return ncrv;

}

void
rt_nurb_mesh_diff(int order, const fastf_t *o_pts, fastf_t *n_pts, const fastf_t *knots, int o_stride, int n_stride, int o_size, int pt_type)
{
	int	i, k;
	int	coords;
	fastf_t denom;

	coords = RT_NURB_EXTRACT_COORDS(pt_type);

	for ( i = 1; i < o_size; i++) {
		denom = knots[ i + order - 1] - knots[i];
		for (k = 0; k < coords; k++) {
			if (denom == 0.0)
				n_pts[k] = 0.0;
			else
				n_pts[k] = (order - 1) * 
				    (o_pts[k+o_stride] - o_pts[k]) / 
				    denom;
		}
		n_pts += n_stride;
		o_pts += o_stride;
	}
}

@


11.9
log
@change conf.h to a wrapped config.h
@
text
@@


11.8
log
@merge of ansi-6-0-branch into HEAD
@
text
@d18 5
a22 1
#include "conf.h"
@


11.7
log
@update copyright to include span through 2003
@
text
@d44 1
a44 3
rt_nurb_s_diff( srf, dir )
const struct face_g_snurb *srf;
int	dir;
d118 1
a118 2
rt_nurb_c_diff( crv )
const struct edge_g_cnurb *crv;
d147 1
a147 9
rt_nurb_mesh_diff( order, o_pts, n_pts, knots, o_stride, n_stride, o_size, pt_type)
int	order;
const fastf_t *o_pts;
fastf_t *n_pts;
const fastf_t *knots;
int	o_stride;
int	n_stride;
int	o_size;
int	pt_type;
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1986 by the United States Army.
@


11.6.4.1
log
@sync to HEAD...
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
@


11.6.10.1
log
@merge from HEAD
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d44 3
a46 1
rt_nurb_s_diff(const struct face_g_snurb *srf, int dir)
d120 2
a121 1
rt_nurb_c_diff(const struct edge_g_cnurb *crv)
d150 9
a158 1
rt_nurb_mesh_diff(int order, const fastf_t *o_pts, fastf_t *n_pts, const fastf_t *knots, int o_stride, int n_stride, int o_size, int pt_type)
@


11.6.2.2
log
@sync branch with HEAD
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d44 3
a46 1
rt_nurb_s_diff(const struct face_g_snurb *srf, int dir)
d120 2
a121 1
rt_nurb_c_diff(const struct edge_g_cnurb *crv)
d150 9
a158 1
rt_nurb_mesh_diff(int order, const fastf_t *o_pts, fastf_t *n_pts, const fastf_t *knots, int o_stride, int n_stride, int o_size, int pt_type)
@


11.4
log
@CONST to const
@
text
@d44 1
a44 3
rt_nurb_s_diff( srf, dir )
const struct face_g_snurb *srf;
int	dir;
d118 1
a118 2
rt_nurb_c_diff( crv )
const struct edge_g_cnurb *crv;
d147 1
a147 9
rt_nurb_mesh_diff( order, o_pts, n_pts, knots, o_stride, n_stride, o_size, pt_type)
int	order;
const fastf_t *o_pts;
fastf_t *n_pts;
const fastf_t *knots;
int	o_stride;
int	n_stride;
int	o_size;
int	pt_type;
@


11.3
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d45 1
a45 1
CONST struct face_g_snurb *srf;
d121 1
a121 1
CONST struct edge_g_cnurb *crv;
d152 1
a152 1
CONST fastf_t *o_pts;
d154 1
a154 1
CONST fastf_t *knots;
@


11.2
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d58 1
a58 1
		    srf->pt_type );
d88 1
a88 1
		    srf->pt_type );
@


11.1
log
@Release_4.4
@
text
@d43 1
a43 1
struct snurb *
d45 1
a45 1
CONST struct snurb *srf;
d48 1
a48 1
	struct snurb *nsrf;
d54 1
a54 1
		nsrf = (struct snurb *)
d56 1
a56 1
		    srf->u_knots.k_size - 2, srf->v_knots.k_size,
d72 1
a72 1
			    old_points, new_points, srf->u_knots.knots,
d78 2
a79 2
		for (i = 1; i < srf->u_knots.k_size - 1; i++)
			nsrf->u_knots.knots[i - 1] = srf->u_knots.knots[i];
d81 2
a82 2
		for (i = 0; i < srf->v_knots.k_size; i++)
			nsrf->v_knots.knots[i] = srf->v_knots.knots[i];
d84 1
a84 1
		nsrf = (struct snurb *) rt_nurb_new_snurb( 
d86 1
a86 1
		    srf->u_knots.k_size, srf->v_knots.k_size - 2,
d100 1
a100 1
			    old_points, new_points, srf->v_knots.knots,
d108 2
a109 2
		for (i = 0; i < srf->u_knots.k_size; i++)
			nsrf->u_knots.knots[i] = srf->u_knots.knots[i];
d111 2
a112 2
		for (i = 1; i < srf->v_knots.k_size - 1; i++)
			nsrf->v_knots.knots[i-1] = srf->v_knots.knots[i];
d119 1
a119 1
struct cnurb *
d121 1
a121 1
CONST struct cnurb *crv;
d124 1
a124 1
	struct cnurb *ncrv;
d130 2
a131 2
	ncrv = (struct cnurb *) rt_nurb_new_cnurb( crv->order - 1, 
	    crv->knot.k_size - 2, crv->c_size - 1, 
d137 1
a137 1
	rt_nurb_mesh_diff( crv->order, opts, npts, crv->knot.knots, 
d142 2
a143 2
	for ( i = 1; i < crv->knot.k_size - 1; i++)
		ncrv->knot.knots[ i - 1] = crv->knot.knots[i];
@


11.1.1.1
log
@Release_4.5
@
text
@d43 1
a43 1
struct face_g_snurb *
d45 1
a45 1
CONST struct face_g_snurb *srf;
d48 1
a48 1
	struct face_g_snurb *nsrf;
d54 1
a54 1
		nsrf = (struct face_g_snurb *)
d56 1
a56 1
		    srf->u.k_size - 2, srf->v.k_size,
d58 1
a58 1
		    srf->pt_type, (struct resource *)NULL );
d72 1
a72 1
			    old_points, new_points, srf->u.knots,
d78 2
a79 2
		for (i = 1; i < srf->u.k_size - 1; i++)
			nsrf->u.knots[i - 1] = srf->u.knots[i];
d81 2
a82 2
		for (i = 0; i < srf->v.k_size; i++)
			nsrf->v.knots[i] = srf->v.knots[i];
d84 1
a84 1
		nsrf = (struct face_g_snurb *) rt_nurb_new_snurb( 
d86 1
a86 1
		    srf->u.k_size, srf->v.k_size - 2,
d88 1
a88 1
		    srf->pt_type, (struct resource *)NULL );
d100 1
a100 1
			    old_points, new_points, srf->v.knots,
d108 2
a109 2
		for (i = 0; i < srf->u.k_size; i++)
			nsrf->u.knots[i] = srf->u.knots[i];
d111 2
a112 2
		for (i = 1; i < srf->v.k_size - 1; i++)
			nsrf->v.knots[i-1] = srf->v.knots[i];
d119 1
a119 1
struct edge_g_cnurb *
d121 1
a121 1
CONST struct edge_g_cnurb *crv;
d124 1
a124 1
	struct edge_g_cnurb *ncrv;
d130 2
a131 2
	ncrv = (struct edge_g_cnurb *) rt_nurb_new_cnurb( crv->order - 1, 
	    crv->k.k_size - 2, crv->c_size - 1, 
d137 1
a137 1
	rt_nurb_mesh_diff( crv->order, opts, npts, crv->k.knots, 
d142 2
a143 2
	for ( i = 1; i < crv->k.k_size - 1; i++)
		ncrv->k.knots[ i - 1] = crv->k.knots[i];
@


10.7
log
@Added include of conf.h
@
text
@@


10.6
log
@Changed lists to use rt_list structures
Made some args CONST where appropriate
Switched to GET_CNURB() macros
Added calls to NMG_CK_SNURB()
@
text
@d18 2
@


10.5
log
@Control polygon/mesh is now just part of the cnurb/snurb structures,
rather than being a separate structure of their own.
@
text
@d21 2
d43 1
a43 1
struct snurb *srf;
d49 2
d119 1
a119 1
struct cnurb *crv;
d126 2
d150 1
a150 1
fastf_t *o_pts;
d152 1
a152 1
fastf_t *knots;
@


10.4
log
@Modifications due to data structure revisions:  mesh and knots are no
longer pointers, but in-place structures.
@
text
@d51 2
a52 2
		    srf->mesh.s_size[0], srf->mesh.s_size[1] - 1, 
		    srf->mesh.pt_type );
d54 1
a54 1
		for ( i = 0; i < srf->mesh.s_size[0]; i++) {
d57 3
a59 3
			old_points = srf->mesh.ctl_points + 
			    i * RT_NURB_EXTRACT_COORDS(srf->mesh.pt_type)
			*srf->mesh.s_size[1];
d61 3
a63 3
			new_points = nsrf->mesh.ctl_points + 
			    i * RT_NURB_EXTRACT_COORDS(nsrf->mesh.pt_type)
			*nsrf->mesh.s_size[1];
d67 3
a69 3
			    RT_NURB_EXTRACT_COORDS(srf->mesh.pt_type),
			    RT_NURB_EXTRACT_COORDS(nsrf->mesh.pt_type),
			    srf->mesh.s_size[1], srf->mesh.pt_type);
d81 2
a82 2
		    srf->mesh.s_size[0] - 1, srf->mesh.s_size[1], 
		    srf->mesh.pt_type );
d84 1
a84 1
		for ( i = 0; i < srf->mesh.s_size[1]; i++) {
d87 2
a88 2
			old_points = srf->mesh.ctl_points + 
			    i * RT_NURB_EXTRACT_COORDS(srf->mesh.pt_type);
d90 2
a91 2
			new_points = nsrf->mesh.ctl_points + 
			    i * RT_NURB_EXTRACT_COORDS(nsrf->mesh.pt_type);
d95 5
a99 5
			    RT_NURB_EXTRACT_COORDS(srf->mesh.pt_type) * 
			    srf->mesh.s_size[1],
			    RT_NURB_EXTRACT_COORDS(nsrf->mesh.pt_type) * 
			    nsrf->mesh.s_size[1],
			    srf->mesh.s_size[0], srf->mesh.pt_type);
d123 2
a124 2
	    crv->knot.k_size - 2, crv->mesh.c_size - 1, 
	    crv->mesh.pt_type);
d126 2
a127 2
	opts = (fastf_t * ) crv->mesh.ctl_points;
	npts = (fastf_t * ) ncrv->mesh.ctl_points;
d130 3
a132 3
	    RT_NURB_EXTRACT_COORDS( crv->mesh.pt_type),
	    RT_NURB_EXTRACT_COORDS( ncrv->mesh.pt_type),
	    crv->mesh.c_size, crv->mesh.pt_type );
@


10.3
log
@Expanded names of manifest constants
@
text
@d50 3
a52 3
		    srf->u_knots->k_size - 2, srf->v_knots->k_size,
		    srf->mesh->s_size[0], srf->mesh->s_size[1] - 1, 
		    srf->mesh->pt_type );
d54 1
a54 1
		for ( i = 0; i < srf->mesh->s_size[0]; i++) {
d57 3
a59 3
			old_points = srf->mesh->ctl_points + 
			    i * RT_NURB_EXTRACT_COORDS(srf->mesh->pt_type)
			*srf->mesh->s_size[1];
d61 3
a63 3
			new_points = nsrf->mesh->ctl_points + 
			    i * RT_NURB_EXTRACT_COORDS(nsrf->mesh->pt_type)
			*nsrf->mesh->s_size[1];
d66 4
a69 4
			    old_points, new_points, srf->u_knots->knots,
			    RT_NURB_EXTRACT_COORDS(srf->mesh->pt_type),
			    RT_NURB_EXTRACT_COORDS(nsrf->mesh->pt_type),
			    srf->mesh->s_size[1], srf->mesh->pt_type);
d72 2
a73 2
		for (i = 1; i < srf->u_knots->k_size - 1; i++)
			nsrf->u_knots->knots[i - 1] = srf->u_knots->knots[i];
d75 2
a76 2
		for (i = 0; i < srf->v_knots->k_size; i++)
			nsrf->v_knots->knots[i] = srf->v_knots->knots[i];
d80 3
a82 3
		    srf->u_knots->k_size, srf->v_knots->k_size - 2,
		    srf->mesh->s_size[0] - 1, srf->mesh->s_size[1], 
		    srf->mesh->pt_type );
d84 1
a84 1
		for ( i = 0; i < srf->mesh->s_size[1]; i++) {
d87 2
a88 2
			old_points = srf->mesh->ctl_points + 
			    i * RT_NURB_EXTRACT_COORDS(srf->mesh->pt_type);
d90 2
a91 2
			new_points = nsrf->mesh->ctl_points + 
			    i * RT_NURB_EXTRACT_COORDS(nsrf->mesh->pt_type);
d94 6
a99 6
			    old_points, new_points, srf->v_knots->knots,
			    RT_NURB_EXTRACT_COORDS(srf->mesh->pt_type) * 
			    srf->mesh->s_size[1],
			    RT_NURB_EXTRACT_COORDS(nsrf->mesh->pt_type) * 
			    nsrf->mesh->s_size[1],
			    srf->mesh->s_size[0], srf->mesh->pt_type);
d102 2
a103 2
		for (i = 0; i < srf->u_knots->k_size; i++)
			nsrf->u_knots->knots[i] = srf->u_knots->knots[i];
d105 2
a106 2
		for (i = 1; i < srf->v_knots->k_size - 1; i++)
			nsrf->v_knots->knots[i-1] = srf->v_knots->knots[i];
d123 2
a124 2
	    crv->knot->k_size - 2, crv->mesh->c_size - 1, 
	    crv->mesh->pt_type);
d126 2
a127 2
	opts = (fastf_t * ) crv->mesh->ctl_points;
	npts = (fastf_t * ) ncrv->mesh->ctl_points;
d129 4
a132 4
	rt_nurb_mesh_diff( crv->order, opts, npts, crv->knot->knots, 
	    RT_NURB_EXTRACT_COORDS( crv->mesh->pt_type),
	    RT_NURB_EXTRACT_COORDS( ncrv->mesh->pt_type),
	    crv->mesh->c_size, crv->mesh->pt_type );
d134 2
a135 2
	for ( i = 1; i < crv->knot->k_size - 1; i++)
		ncrv->knot->knots[ i - 1] = crv->knot->knots[i];
@


10.2
log
@rt_nurb_ prefix put on "internal" routines.
SPL_INFINIT changed to INFINITY
@
text
@d47 1
a47 1
	if (dir == ROW) {
d58 1
a58 1
			    i * EXTRACT_COORDS(srf->mesh->pt_type)
d62 1
a62 1
			    i * EXTRACT_COORDS(nsrf->mesh->pt_type)
d67 2
a68 2
			    EXTRACT_COORDS(srf->mesh->pt_type),
			    EXTRACT_COORDS(nsrf->mesh->pt_type),
d88 1
a88 1
			    i * EXTRACT_COORDS(srf->mesh->pt_type);
d91 1
a91 1
			    i * EXTRACT_COORDS(nsrf->mesh->pt_type);
d95 1
a95 1
			    EXTRACT_COORDS(srf->mesh->pt_type) * 
d97 1
a97 1
			    EXTRACT_COORDS(nsrf->mesh->pt_type) * 
d130 2
a131 2
	    EXTRACT_COORDS( crv->mesh->pt_type),
	    EXTRACT_COORDS( ncrv->mesh->pt_type),
d156 1
a156 1
	coords = EXTRACT_COORDS(pt_type);
@


10.1
log
@Release_4.0
@
text
@d65 1
a65 1
			internal_mesh_diff( srf->order[0], 
d93 1
a93 1
			internal_mesh_diff( srf->order[1], 
d129 1
a129 1
	internal_mesh_diff( crv->order, opts, npts, crv->knot->knots, 
d141 2
a142 2

internal_mesh_diff( order, o_pts, n_pts, knots, o_stride, n_stride, o_size, pt_type)
@


1.2
log
@fixed nurb.h
@
text
@@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
#include "./nurb.h"
@
