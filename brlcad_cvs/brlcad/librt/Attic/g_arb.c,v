head	11.47;
access;
symbols
	ansi-20040405-merged:11.43.2.2
	postmerge-20040405-ansi:11.45
	premerge-20040404-ansi:11.44
	postmerge-autoconf:11.44
	autoconf-freeze:11.43.10.2
	premerge-autoconf:11.44
	ansi-20040316-freeze:11.43.2.1
	postmerge-20040315-windows:11.44
	premerge-20040315-windows:11.44
	windows-20040315-freeze:11.43.4.1
	autoconf-20031203:11.43
	autoconf-20031202:11.43
	autoconf-branch:11.43.0.10
	phong-branch:11.43.0.8
	photonmap-branch:11.43.0.6
	rel-6-1-DP:11.43
	windows-branch:11.43.0.4
	rel-6-0-2:11.40
	ansi-branch:11.43.0.2
	rel-6-0-1-branch:11.40.0.2
	hartley-6-0-post:11.42
	hartley-6-0-pre:11.41
	rel-6-0-1:11.40
	rel-6-0:11.40
	rel-5-4:11.23
	offsite-5-3-pre:11.36
	rel-5-3:11.23
	rel-5-2:11.23
	rel-5-1-branch:11.23.0.2
	rel-5-1:11.23
	rel-5-0:11.14
	rel-5-0-beta:11.13
	rel-4-5:11.12
	ctj-4-5-post:11.10
	ctj-4-5-pre:11.8
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1
	rt-2:2.1
	rt:1.1;
locks; strict;
comment	@ * @;


11.47
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	11.46;

11.46
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.45;

11.45
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.44;

11.44
date	2004.02.02.17.39.16;	author morrison;	state Exp;
branches;
next	11.43;

11.43
date	2002.08.20.17.07.58;	author jra;	state Exp;
branches
	11.43.2.1
	11.43.4.1
	11.43.10.1;
next	11.42;

11.42
date	2002.08.15.20.55.11;	author hartley;	state Exp;
branches;
next	11.41;

11.41
date	2002.08.11.02.05.17;	author morrison;	state Exp;
branches;
next	11.40;

11.40
date	2001.10.02.19.24.28;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	2001.05.17.20.05.24;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2001.05.16.21.38.04;	author morrison;	state Exp;
branches;
next	11.37;

11.37
date	2001.04.05.19.35.34;	author morrison;	state Exp;
branches;
next	11.36;

11.36
date	2000.10.24.18.42.34;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	2000.10.24.18.09.39;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	2000.09.08.05.54.41;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	2000.09.07.01.55.31;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	2000.08.21.02.02.29;	author butler;	state Exp;
branches;
next	11.31;

11.31
date	2000.07.13.02.36.25;	author cjohnson;	state Exp;
branches;
next	11.30;

11.30
date	2000.07.11.06.00.13;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.07.10.23.01.29;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.06.30.15.38.02;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.06.30.15.31.14;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.06.29.18.20.56;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.06.27.15.07.03;	author cjohnson;	state Exp;
branches;
next	11.24;

11.24
date	2000.06.26.20.07.07;	author cjohnson;	state Exp;
branches;
next	11.23;

11.23
date	2000.04.12.02.34.30;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.03.29.02.43.08;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	99.11.26.21.46.44;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	99.11.26.20.36.11;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.11.26.20.32.34;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	99.11.24.23.12.06;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	99.11.24.21.44.29;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	99.11.17.04.39.20;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.11.17.02.41.55;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	99.07.02.22.19.22;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	99.05.27.19.10.35;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	97.12.16.00.13.37;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	97.11.21.21.02.47;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	97.09.02.17.58.15;	author gdurf;	state Exp;
branches;
next	11.9;

11.9
date	97.08.01.17.57.26;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	97.07.23.06.42.42;	author gdurf;	state Exp;
branches;
next	11.7;

11.7
date	97.06.19.22.29.46;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	97.06.17.19.25.55;	author gdurf;	state Exp;
branches;
next	11.5;

11.5
date	97.01.24.21.20.32;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.03.18.18.50.48;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.11.29.21.16.19;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.11.29.03.50.20;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.27;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.09.30.16.24.21;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.09.13.15.46.43;	author jra;	state Exp;
branches;
next	10.6;

10.6
date	94.09.09.11.03.16;	author jra;	state Exp;
branches;
next	10.5;

10.5
date	94.08.10.18.23.56;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.04.22.10.05.15;	author butler;	state Exp;
branches;
next	10.3;

10.3
date	93.11.18.01.43.50;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.10.27.16.16.46;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.10;	author mike;	state Rel4_0;
branches;
next	9.40;

9.40
date	91.09.20.22.41.15;	author butler;	state Exp;
branches;
next	9.39;

9.39
date	91.07.06.00.52.35;	author mike;	state Exp;
branches;
next	9.38;

9.38
date	91.07.04.02.33.11;	author mike;	state Exp;
branches;
next	9.37;

9.37
date	91.06.30.00.10.31;	author mike;	state Exp;
branches;
next	9.36;

9.36
date	91.06.22.22.29.32;	author mike;	state Exp;
branches;
next	9.35;

9.35
date	91.06.14.06.52.24;	author mike;	state Exp;
branches;
next	9.34;

9.34
date	91.05.18.03.00.21;	author mike;	state Exp;
branches;
next	9.33;

9.33
date	91.04.01.20.08.47;	author mike;	state Exp;
branches;
next	9.32;

9.32
date	91.04.01.19.58.45;	author mike;	state Exp;
branches;
next	9.31;

9.31
date	91.04.01.18.02.41;	author mike;	state Exp;
branches;
next	9.30;

9.30
date	91.02.07.20.31.58;	author mike;	state Exp;
branches;
next	9.29;

9.29
date	91.01.28.23.53.03;	author mike;	state Exp;
branches;
next	9.28;

9.28
date	91.01.26.03.14.37;	author mike;	state Exp;
branches;
next	9.27;

9.27
date	91.01.25.21.17.55;	author mike;	state Exp;
branches;
next	9.26;

9.26
date	91.01.23.22.46.22;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	90.12.15.04.52.37;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	90.12.11.22.06.23;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	90.11.01.04.43.02;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	90.10.15.12.00.27;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	90.10.06.02.05.06;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	90.05.21.13.03.37;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	90.05.18.07.25.01;	author butler;	state Exp;
branches;
next	9.18;

9.18
date	90.05.09.21.11.30;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	90.05.03.09.32.51;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	90.05.03.03.55.30;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	90.05.03.03.12.16;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	90.05.02.05.43.24;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.04.28.02.08.15;	author butler;	state Exp;
branches;
next	9.12;

9.12
date	90.04.27.02.15.53;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.04.26.00.45.39;	author butler;	state Exp;
branches;
next	9.10;

9.10
date	90.03.15.01.06.22;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.03.14.22.36.39;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.03.14.21.21.17;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.03.14.15.05.27;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.03.05.23.57.29;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.02.28.01.53.42;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.02.27.21.46.42;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.12.09.01.36.48;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.15.30;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.01;	author mike;	state Rel3_5;
branches;
next	8.19;

8.19
date	89.04.29.09.18.31;	author mike;	state Exp;
branches;
next	8.18;

8.18
date	89.04.28.00.28.40;	author mike;	state Exp;
branches;
next	8.17;

8.17
date	89.04.26.20.02.04;	author mike;	state Exp;
branches;
next	8.16;

8.16
date	89.04.26.16.12.00;	author mike;	state Exp;
branches;
next	8.15;

8.15
date	89.04.25.19.05.51;	author mike;	state Exp;
branches;
next	8.14;

8.14
date	89.04.25.18.48.56;	author mike;	state Exp;
branches;
next	8.13;

8.13
date	89.04.17.17.09.50;	author mike;	state Exp;
branches;
next	8.12;

8.12
date	89.04.17.16.02.54;	author mike;	state Exp;
branches;
next	8.11;

8.11
date	89.04.17.12.48.34;	author mike;	state Exp;
branches;
next	8.10;

8.10
date	89.04.14.00.51.50;	author mike;	state Exp;
branches;
next	8.9;

8.9
date	89.04.11.11.52.52;	author phil;	state Exp;
branches;
next	8.8;

8.8
date	89.04.08.05.48.48;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.04.08.03.40.37;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.04.08.03.12.11;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.04.08.02.35.21;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.08.02.19.25;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.04.08.01.37.41;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.05.23.59.29;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.30.55;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.05.14.00.00.29;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.06.05.36.16;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.13.01.50.34;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.32.41;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.09.17.07.04.32;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.55.10;	author mike;	state Rel;
branches;
next	5.3;

5.3
date	87.07.07.01.36.19;	author mike;	state Exp;
branches;
next	5.2;

5.2
date	87.07.06.21.43.59;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.10.41;	author mike;	state Rel;
branches;
next	4.6;

4.6
date	87.04.28.00.26.55;	author phil;	state Exp;
branches;
next	4.5;

4.5
date	87.03.23.23.42.50;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.03.10.23.41.31;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.12.22.10.41;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.28.20.59.38;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.44.27;	author mike;	state Rel1;
branches;
next	3.7;

3.7
date	86.12.24.08.05.11;	author mike;	state Exp;
branches;
next	3.6;

3.6
date	86.12.14.14.02.37;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.10.11.01.19.52;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.08.12.04.14.37;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.24.06.07.58;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.22.03.19.46;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.11.01.31.21;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.32.23;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	86.06.09.21.49.15;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	86.05.29.01.46.09;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	86.03.14.21.53.56;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.09.11.00.31.52;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.06.02.27.12;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.02.40;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	85.07.30.05.51.51;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	85.03.25.11.34.14;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	84.11.30.03.59.09;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	84.11.24.02.59.35;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	84.11.23.20.53.39;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	84.11.22.09.06.28;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	84.11.20.20.13.57;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	84.11.16.23.49.25;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	84.11.16.06.25.50;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	84.11.15.21.47.02;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	84.10.19.01.37.43;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	84.05.04.09.13.41;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	84.05.03.06.54.27;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	84.05.02.05.09.49;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	84.05.01.06.38.59;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	84.05.01.05.56.09;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.04.26.06.49.03;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.04.26.05.34.11;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.04.25.06.20.03;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.04.18.02.19.20;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.04.02.16.41.33;	author mike;	state Exp;
branches;
next	;

11.43.2.1
date	2002.09.19.18.01.32;	author morrison;	state Exp;
branches;
next	11.43.2.2;

11.43.2.2
date	2004.03.17.21.18.44;	author morrison;	state Exp;
branches;
next	;

11.43.4.1
date	2004.03.11.23.43.36;	author morrison;	state Exp;
branches;
next	;

11.43.10.1
date	2004.02.12.18.37.39;	author erikg;	state Exp;
branches;
next	11.43.10.2;

11.43.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@Intersects Ray with ARB8
@


11.47
log
@moved to src/
@
text
@/*
 *  			G _ A R B . C
 *  
 *  Function -
 *  	Intersect a ray with an Arbitrary Regular Polyhedron with
 *  	as many as 8 vertices.
 *
 *  An ARB is a convex volume bounded by 4 (pyramid), 5 (wedge), or 6 (box)
 *  planes.  This analysis depends on the properties of objects with convex
 *  hulls.  Let the ray in question be defined such that any point X on the
 *  ray may be expressed as X = P + k D.  Intersect the ray with each of the
 *  planes bounding the ARB as discussed above, and record the values of the
 *  parametric distance k along the ray.
 *
 *  With outward pointing normal vectors,
 *  note that the ray enters the half-space defined by a plane when D cdot N <
 *  0, is parallel to the plane when D cdot N = 0, and exits otherwise.  Find
 *  the entry point farthest away from the starting point bold P, i.e.  it has
 *  the largest value of k among the entry points.
 *  The ray enters the solid at this point.
 *  Similarly, find the exit point closest to point P, i.e. it has
 *  the smallest value of k among the exit points.  The ray exits the solid
 *  here.
 *
 *  This algorithm is due to Cyrus & Beck, USAF.
 *  
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSarb[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_arb.c,v 11.46 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "nmg.h"
#include "db.h"
#include "raytrace.h"
#include "nurb.h"
#include "rtgeom.h"
#include "./debug.h"

#define RT_SLOPPY_DOT_TOL	0.0087	/* inspired by RT_DOT_TOL, but less tight (.5 deg) */

/* Optionally, one of these for each face.  (Lazy evaluation) */
struct oface {
	fastf_t	arb_UVorig[3];		/* origin of UV coord system */
	fastf_t	arb_U[3];		/* unit U vector (along B-A) */
	fastf_t	arb_V[3];		/* unit V vector (perp to N and U) */
	fastf_t	arb_Ulen;		/* length of U basis (for du) */
	fastf_t	arb_Vlen;		/* length of V basis (for dv) */
};

/* One of these for each face */
struct aface {
	fastf_t	A[3];			/* "A" point */
	plane_t	peqn;			/* Plane equation, unit normal */
};

/* One of these for each ARB, custom allocated to size */
struct arb_specific  {
	int		arb_nmfaces;	/* number of faces */
	struct oface	*arb_opt;	/* pointer to optional info */
	struct aface	arb_face[4];	/* May really be up to [6] faces */
};

/* These hold temp values for the face being prep'ed */
struct prep_arb {
	vect_t		pa_center;	/* center point */
	int		pa_faces;	/* Number of faces done so far */
	int		pa_npts[6];	/* # of points on face's plane */
	int		pa_pindex[4][6]; /* subscr in arbi_pt[] */
	int		pa_clockwise[6];	/* face normal was flipped */
	struct aface	pa_face[6];	/* required face info work area */
	struct oface	pa_opt[6];	/* optional face info work area */
	/* These elements must be initialized before using */
	fastf_t		pa_tol_sq;	/* points-are-equal tol sq */
	int		pa_doopt;	/* compute pa_opt[] stuff */
};

/*
 *  Layout of arb in input record.
 *  Points are listed in "clockwise" order,
 *  to make proper outward-pointing face normals.
 *  (Although the cross product wants counter-clockwise order)
 */
struct arb_info {
	char	*ai_title;
	int	ai_sub[4];
};
static const struct arb_info rt_arb_info[6] = {
	{ "1234", {3, 2, 1, 0} },		/* "bottom" face */
	{ "8765", {4, 5, 6, 7} },		/* "top" face */
	{ "1485", {4, 7, 3, 0} },
	{ "2673", {2, 6, 5, 1} },
	{ "1562", {1, 5, 4, 0} },
	{ "4378", {7, 6, 2, 3} }
};

RT_EXTERN(void rt_arb_ifree, (struct rt_db_internal *) );

const struct bu_structparse rt_arb_parse[] = {
    { "%f", 3, "V1", offsetof(struct rt_arb_internal, pt[0][X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "V2", offsetof(struct rt_arb_internal, pt[1][X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "V3", offsetof(struct rt_arb_internal, pt[2][X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "V4", offsetof(struct rt_arb_internal, pt[3][X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "V5", offsetof(struct rt_arb_internal, pt[4][X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "V6", offsetof(struct rt_arb_internal, pt[5][X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "V7", offsetof(struct rt_arb_internal, pt[6][X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "V8", offsetof(struct rt_arb_internal, pt[7][X]), BU_STRUCTPARSE_FUNC_NULL },
    { {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
};

/*  rt_arb_get_cgtype(), rt_arb_std_type(), and rt_arb_centroid() 
 *  stolen from mged/arbs.c */
#define NO	0
#define YES	1
	
/*
 *			R T _ A R B _ G E T _ C G T Y P E
 *
 * C G A R B S :   determines COMGEOM arb types from GED general arbs
 *
 *  Inputs -
 *
 *  Returns -
 *	#	Number of distinct edge vectors
 *		(Number of entries in uvec array)
 *
 *  Implicit returns -
 *	*cgtype		Comgeom type (number range 4..8;  ARB4 .. ARB8).
 *	uvec[8]
 *	svec[11]
 *			Entries [0] and [1] are special
 */
int
rt_arb_get_cgtype(
	int			*cgtype,
	struct rt_arb_internal	*arb,
	const struct bn_tol	*tol,
	register int *uvec,	/* array of unique points */
	register int *svec)	/* array of like points */
{
	register int i,j;
	int	numuvec, unique, done;
	int	si;
	
	RT_ARB_CK_MAGIC(arb);
	BN_CK_TOL(tol);
	
	done = NO;		/* done checking for like vectors */
	
	svec[0] = svec[1] = 0;
	si = 2;
	
	for(i=0; i<7; i++) {
		unique = YES;
		if(done == NO) {
			svec[si] = i;
		}
		for(j=i+1; j<8; j++) {
			int tmp;
			vect_t vtmp;
			
			VSUB2( vtmp, arb->pt[i], arb->pt[j] );
			
			if( fabs(vtmp[0]) > tol->dist) tmp = 0;
			else 	if( fabs(vtmp[1]) > tol->dist) tmp = 0;
			else 	if( fabs(vtmp[2]) > tol->dist) tmp = 0;
			else tmp = 1;
			
			if( tmp ) {
				if( done == NO )
					svec[++si] = j;
				unique = NO;
			}
		}
		if( unique == NO ) {  	/* point i not unique */
			if( si > 2 && si < 6 ) {
				svec[0] = si - 1;
				if(si == 5 && svec[5] >= 6)
					done = YES;
				si = 6;
			}
			if( si > 6 ) {
				svec[1] = si - 5;
				done = YES;
			}
		}
	}
	
	if( si > 2 && si < 6 ) {
		svec[0] = si - 1;
	}
	if( si > 6 ) {
		svec[1] = si - 5;
	}
	for(i=1; i<=svec[1]; i++) {
		svec[svec[0]+1+i] = svec[5+i];
	}
	for(i=svec[0]+svec[1]+2; i<11; i++) {
		svec[i] = -1;
	}
	
	/* find the unique points */
	numuvec = 0;
	for(j=0; j<8; j++) {
		unique = YES;
		for(i=2; i<svec[0]+svec[1]+2; i++) {
			if( j == svec[i] ) {
				unique = NO;
				break;
			}
		}
		if( unique == YES ) {
			uvec[numuvec++] = j;
		}
	}

	/* Figure out what kind of ARB this is */
	switch( numuvec ) {
		
	case 8:
		*cgtype = ARB8;		/* ARB8 */
		break;

	case 6:
		*cgtype = ARB7;		/* ARB7 */
		break;

	case 4:
		if(svec[0] == 2)
			*cgtype = ARB6;	/* ARB6 */
		else
			*cgtype = ARB5;	/* ARB5 */
		break;

	case 2:
		*cgtype = ARB4;		/* ARB4 */
		break;

	default:
		bu_log( "rt_arb_get_cgtype: bad number of unique vectors (%d)\n",
			  numuvec);

		return(0);
	}
#if 0
	bu_log("uvec: ");
	for(j=0; j<8; j++) bu_log("%d, ", uvec[j]);
	bu_log("\nsvec: ");
	for(j=0; j<11; j++ ) bu_log("%d, ", svec[j]);
	bu_log("\n");
#endif
	return( numuvec );
}

/*
 *			R T _ A R B _ S T D _ T Y P E
 *
 *  Given an ARB in internal form, return it's specific ARB type.
 *
 *  Set tol.dist = 0.0001 to obtain past behavior.
 *
 *  Returns -
 *	0	Error in input ARB
 *	4	ARB4
 *	5	ARB5
 *	6	ARB6
 *	7	ARB7
 *	8	ARB8
 *
 *  Implicit return -
 *	rt_arb_internal pt[] array reorganized into GIFT "standard" order.
 */
int
rt_arb_std_type( const struct rt_db_internal *ip, const struct bn_tol *tol )
{
	struct rt_arb_internal	*arb;
	int uvec[8], svec[11];
	int	cgtype = 0;

	RT_CK_DB_INTERNAL(ip);
	BN_CK_TOL(tol);

	if( ip->idb_type != ID_ARB8 )  bu_bomb("rt_arb_std_type: not ARB!\n");

	arb = (struct rt_arb_internal *)ip->idb_ptr;
	RT_ARB_CK_MAGIC(arb);

	if( rt_arb_get_cgtype( &cgtype, arb, tol, uvec, svec ) == 0 )
		return(0);

	return( cgtype );
}


/* 
 *			R T _ A R B _ C E N T R O I D
 *
 * Find the center point for the arb whose values are in the s array,
 * with the given number of verticies.  Return the point in center_pt.
 */
void
rt_arb_centroid( point_t center_pt, const struct rt_arb_internal *arb, int npoints )
{
	register int	j;
	fastf_t		div;
	point_t		sum;

	RT_ARB_CK_MAGIC(arb);

	VSETALL(sum, 0);

	for( j=0; j < npoints; j++ )  {
		VADD2( sum, sum, arb->pt[j] );
	}
	div = 1.0 / npoints;
	VSCALE( center_pt, sum, div );
}

/*
 *			R T _ A R B _ A D D _ P T
 *
 *  Add another point to a struct arb_specific, checking for unique pts.
 *  The first two points are easy.  The third one triggers most of the
 *  plane calculations, and forth and subsequent ones are merely
 *  checked for validity.
 *
 *  Returns -
 *	 0	point was accepted
 *	-1	point was rejected
 */
HIDDEN int
rt_arb_add_pt(register pointp_t point, const char *title, struct prep_arb *pap, int ptno, const char *name)
                        
          	       
               	     
   		     	/* current point # on face */
          	      
{
	LOCAL vect_t	work;
	LOCAL vect_t	P_A;		/* new point minus A */
	FAST fastf_t	f;
	register struct aface	*afp;
	register struct oface	*ofp;

	afp = &pap->pa_face[pap->pa_faces];
	ofp = &pap->pa_opt[pap->pa_faces];

	/* The first 3 points are treated differently */
	switch( ptno )  {
	case 0:
		VMOVE( afp->A, point );
		if( pap->pa_doopt )  {
			VMOVE( ofp->arb_UVorig, point );
		}
		return(0);				/* OK */
	case 1:
		VSUB2( ofp->arb_U, point, afp->A );	/* B-A */
		f = MAGNITUDE( ofp->arb_U );
		if( NEAR_ZERO( f, SQRT_SMALL_FASTF ) )  {
			return(-1);			/* BAD */
		}
		ofp->arb_Ulen = f;
		f = 1/f;
		VSCALE( ofp->arb_U, ofp->arb_U, f );
		/* Note that arb_U is used to build N, below */
		return(0);				/* OK */
	case 2:
		VSUB2( P_A, point, afp->A );	/* C-A */
		/* Pts are given clockwise, so reverse terms of cross prod. */
		/* peqn = (C-A)x(B-A), which points inwards */
		VCROSS( afp->peqn, P_A, ofp->arb_U );
		/* Check for co-linear, ie, |(B-A)x(C-A)| ~= 0 */
		f = MAGNITUDE( afp->peqn );
		if( NEAR_ZERO(f,RT_SLOPPY_DOT_TOL) )  {
			return(-1);			/* BAD */
		}
		f = 1/f;
		VSCALE( afp->peqn, afp->peqn, f );

		if( pap->pa_doopt )  {
			/*
			 * Get vector perp. to AB in face of plane ABC.
			 * Scale by projection of AC, make this V.
			 */
			VCROSS( work, afp->peqn, ofp->arb_U );
			VUNITIZE( work );
			f = VDOT( work, P_A );
			VSCALE( ofp->arb_V, work, f );
			f = MAGNITUDE( ofp->arb_V );
			ofp->arb_Vlen = f;
			f = 1/f;
			VSCALE( ofp->arb_V, ofp->arb_V, f );

			/* Check for new Ulen */
			VSUB2( P_A, point, ofp->arb_UVorig );
			f = VDOT( P_A, ofp->arb_U );
			if( f > ofp->arb_Ulen ) {
				ofp->arb_Ulen = f;
			} else if( f < 0.0 ) {
				VJOIN1( ofp->arb_UVorig, ofp->arb_UVorig, f,
					ofp->arb_U );
				ofp->arb_Ulen += (-f);
			}
		}

		/*
		 *  If C-A is clockwise from B-A, then the normal
		 *  points inwards, so we need to fix it here.
		 *  Build a vector from the centroid to vertex A.
		 *  If the surface normal points in the same direction,
		 *  then the vertcies were given in CCW order;
		 *  otherwise, vertices were given in CW order, and
		 *  the normal needs to be flipped.
		 */
		VSUB2( work, afp->A, pap->pa_center );
		f = VDOT( work, afp->peqn );
		if( f < 0.0 )  {
			VREVERSE(afp->peqn, afp->peqn);	/* "fix" normal */
			pap->pa_clockwise[pap->pa_faces] = 1;
		} else {
			pap->pa_clockwise[pap->pa_faces] = 0;
		}
		afp->peqn[3] = VDOT( afp->peqn, afp->A );
		return(0);				/* OK */
	default:
		/* Merely validate 4th and subsequent points */
		if( pap->pa_doopt )  {
			VSUB2( P_A, point, ofp->arb_UVorig );
			/* Check for new Ulen, Vlen */
			f = VDOT( P_A, ofp->arb_U );
			if( f > ofp->arb_Ulen ) {
				ofp->arb_Ulen = f;
			} else if( f < 0.0 ) {
				VJOIN1( ofp->arb_UVorig, ofp->arb_UVorig, f,
					ofp->arb_U );
				ofp->arb_Ulen += (-f);
			}
			f = VDOT( P_A, ofp->arb_V );
			if( f > ofp->arb_Vlen ) {
				ofp->arb_Vlen = f;
			} else if( f < 0.0 ) {
				VJOIN1( ofp->arb_UVorig, ofp->arb_UVorig, f,
					ofp->arb_V );
				ofp->arb_Vlen += (-f);
			}
		}

		VSUB2( P_A, point, afp->A );
		VUNITIZE( P_A );		/* Checking direction only */
		f = VDOT( afp->peqn, P_A );
		if( ! NEAR_ZERO(f,RT_SLOPPY_DOT_TOL) )  {
			/* Non-planar face */
			bu_log("arb(%s): face %s[%d] non-planar, dot=%g\n",
				name, title, ptno, f );
#ifdef CONSERVATIVE
			return(-1);			/* BAD */
#endif
		}
		return(0);				/* OK */
	}
	/* NOTREACHED */
}

/*
 *			R T _ A R B _ M K _ P L A N E S
 *
 *  Given an rt_arb_internal structure with 8 points in it,
 *  compute the face information.
 *
 *  Returns -
 *	 0	OK
 *	<0	failure
 */
HIDDEN int
rt_arb_mk_planes(register struct prep_arb *pap, struct rt_arb_internal *aip, const char *name)
{
	LOCAL vect_t	sum;		/* Sum of all endpoints */
	register int	i;
	register int	j;
	register int	k;
	int		equiv_pts[8];

	/*
	 *  Determine a point which is guaranteed to be within the solid.
	 *  This is done by averaging all the vertices.  This center is
	 *  needed for rt_arb_add_pt, which demands a point inside the solid.
	 *  The center of the enclosing RPP strategy used for the bounding
	 *  sphere can be tricked by thin plates which are non-axis aligned,
	 *  so this dual-strategy is required.  (What a bug hunt!).
	 */
	VSETALL( sum, 0 );
#	include "noalias.h"
	for( i=0; i<8; i++ )  {
		VADD2( sum, sum, aip->pt[i] );
	}
	VSCALE( pap->pa_center, sum, 0.125 );	/* sum/8 */

	/*
	 *  Find all points that are equivalent, within the specified tol.
	 *  Build the array equiv_pts[] so that it is indexed by
	 *  vertex number, and returns the lowest numbered equivalent
	 *  vertex (or its own vertex number, if non-equivalent).
	 */
	equiv_pts[0] = 0;
	for( i=1; i<8; i++ )  {
		for( j = i-1; j >= 0; j-- )  {
			/* Compare vertices I and J */
			LOCAL vect_t		work;

			VSUB2( work, aip->pt[i], aip->pt[j] );
			if( MAGSQ( work ) < pap->pa_tol_sq )  {
				/* Points I and J are the same, J is lower */
				equiv_pts[i] = equiv_pts[j];
				goto next_point;
			}
		}
		equiv_pts[i] = i;
	next_point: ;
	}
	if( RT_G_DEBUG & DEBUG_ARB8 )  {
		bu_log("arb(%s) equiv_pts[] = %d %d %d %d %d %d %d %d\n",
			name,
			equiv_pts[0], equiv_pts[1], equiv_pts[2], equiv_pts[3],
			equiv_pts[4], equiv_pts[5], equiv_pts[6], equiv_pts[7]);
	}

	pap->pa_faces = 0;
	for( i=0; i<6; i++ )  {
		int		npts;

		npts = 0;
		for( j=0; j<4; j++ )  {
			int	pt_index;

			pt_index = rt_arb_info[i].ai_sub[j];
			if( RT_G_DEBUG & DEBUG_ARB8 )  {
				bu_log("face %d, j=%d, npts=%d, orig_vert=%d, vert=%d\n",
					i, j, npts,
					pt_index, equiv_pts[pt_index] );
			}
			pt_index = equiv_pts[pt_index];

			/* Verify that this point is not the same
			 * as an earlier point, by checking point indices
			 */
#			include "noalias.h"
			for( k = npts-1; k >= 0; k-- )  {
				if( pap->pa_pindex[k][pap->pa_faces] == pt_index )  {
					/* Point is the same -- skip it */
					goto skip_pt;
				}
			}
			if( rt_arb_add_pt( aip->pt[pt_index],
			    rt_arb_info[i].ai_title, pap, npts, name ) == 0 )  {
				/* Point was accepted */
				pap->pa_pindex[npts][pap->pa_faces] = pt_index;
				npts++;
			}

skip_pt:		;
		}

		if( npts < 3 )  {
			/* This face is BAD */
			continue;
		}

		if( pap->pa_doopt )  {
			register struct oface	*ofp;

			ofp = &pap->pa_opt[pap->pa_faces];
			/* Scale U and V basis vectors by
			 * the inverse of Ulen and Vlen
			 */
			ofp->arb_Ulen = 1.0 / ofp->arb_Ulen;
			ofp->arb_Vlen = 1.0 / ofp->arb_Vlen;
			VSCALE( ofp->arb_U, ofp->arb_U, ofp->arb_Ulen );
			VSCALE( ofp->arb_V, ofp->arb_V, ofp->arb_Vlen );
		}

		pap->pa_npts[pap->pa_faces] = npts;
		pap->pa_faces++;
	}
	if( pap->pa_faces < 4  || pap->pa_faces > 6 )  {
		bu_log("arb(%s):  only %d faces present\n",
			name, pap->pa_faces);
		return(-1);			/* Error */
	}
	return(0);			/* OK */
}

/*
 *			R T _ A R B _ S E T U P
 *
 *  This is packaged as a separate function, so that it can also be
 *  called "on the fly" from the UV mapper.
 *
 *  Returns -
 *	 0	OK
 *	!0	failure
 */
HIDDEN int
rt_arb_setup(struct soltab *stp, struct rt_arb_internal *aip, struct rt_i *rtip, int uv_wanted)
{
	register int		i;
	struct prep_arb		pa;

	RT_ARB_CK_MAGIC(aip);

	pa.pa_doopt = uv_wanted;
	pa.pa_tol_sq = rtip->rti_tol.dist_sq;

	if( rt_arb_mk_planes( &pa, aip, stp->st_dp->d_namep ) < 0 )  {
		return(-2);		/* Error */
	}

	/*
	 *  Allocate a private copy of the accumulated parameters
	 *  of exactly the right size.
	 *  The size to malloc is chosen based upon the
	 *  exact number of faces.
	 */
	{
		register struct arb_specific	*arbp;
		if( (arbp = (struct arb_specific *)stp->st_specific) == 0 )  {
			arbp = (struct arb_specific *)bu_malloc(
				sizeof(struct arb_specific) +
				sizeof(struct aface) * (pa.pa_faces - 4),
				"arb_specific" );
			stp->st_specific = (genptr_t)arbp;
		}
		arbp->arb_nmfaces = pa.pa_faces;
		bcopy( (char *)pa.pa_face, (char *)arbp->arb_face,
			pa.pa_faces * sizeof(struct aface) );

		if( uv_wanted )  {
			register struct oface	*ofp;

			/*
			 * To avoid a multi-processor race here,
			 * copy the data first, THEN update arb_opt,
			 * because arb_opt doubles as the "UV avail" flag.
			 */
			ofp = (struct oface *)bu_malloc(
				pa.pa_faces * sizeof(struct oface), "arb_opt");
			bcopy( (char *)pa.pa_opt, (char *)ofp,
				pa.pa_faces * sizeof(struct oface) );
			arbp->arb_opt = ofp;
		} else {
			arbp->arb_opt = (struct oface *)0;
		}
	}

	/*
	 * Compute bounding sphere which contains the bounding RPP.
	 * Find min and max of the point co-ordinates to find the
	 * bounding RPP.  Note that this center is NOT guaranteed
	 * to be contained within the solid!
	 */
	{
		LOCAL vect_t		work;
		register fastf_t	f;

#		include "noalias.h"
		for( i=0; i< 8; i++ ) {
			VMINMAX( stp->st_min, stp->st_max, aip->pt[i] );
		}
		VADD2SCALE( stp->st_center, stp->st_min, stp->st_max, 0.5 );
		VSUB2SCALE( work, stp->st_max, stp->st_min, 0.5 );

		f = work[X];
		if( work[Y] > f )  f = work[Y];
		if( work[Z] > f )  f = work[Z];
		stp->st_aradius = f;
		stp->st_bradius = MAGNITUDE(work);
	}
	return(0);		/* OK */
}

/*
 *  			R T _ A R B _ P R E P
 *
 *  This is the actual LIBRT "prep" interface.
 *
 *  Returns -
 *	 0	OK
 *	!0	failure
 */
int
rt_arb_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_arb_internal	*aip;

	aip = (struct rt_arb_internal *)ip->idb_ptr;
	RT_ARB_CK_MAGIC(aip);

	return( rt_arb_setup( stp, aip, rtip, 0 ) );
}

/*
 *  			R T _ A R B _ P R I N T
 */
void
rt_arb_print(register const struct soltab *stp)
{
	register struct arb_specific *arbp =
		(struct arb_specific *)stp->st_specific;
	register struct aface	*afp;
	register int i;

	if( arbp == (struct arb_specific *)0 )  {
		bu_log("arb(%s):  no faces\n", stp->st_name);
		return;
	}
	bu_log("%d faces:\n", arbp->arb_nmfaces);
	for( i=0; i < arbp->arb_nmfaces; i++ )  {
		afp = &(arbp->arb_face[i]);
		VPRINT( "A", afp->A );
		HPRINT( "Peqn", afp->peqn );
		if( arbp->arb_opt )  {
			register struct oface	*op;
			op = &(arbp->arb_opt[i]);
			VPRINT( "UVorig", op->arb_UVorig );
			VPRINT( "U", op->arb_U );
			VPRINT( "V", op->arb_V );
			bu_log( "Ulen = %g, Vlen = %g\n",
				op->arb_Ulen, op->arb_Vlen);
		}
	}
}

/*
 *			R T _ A R B _ S H O T
 *  
 * Function -
 *	Shoot a ray at an ARB8.
 *
 * Algorithm -
 * 	The intersection distance is computed for each face.
 *  The largest IN distance and the smallest OUT distance are
 *  used as the entry and exit points.
 *  
 * Returns -
 *	0	MISS
 *	>0	HIT
 */
int
rt_arb_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	struct arb_specific *arbp = (struct arb_specific *)stp->st_specific;
	LOCAL int		iplane, oplane;
	LOCAL fastf_t		in, out;	/* ray in/out distances */
	register struct aface	*afp;
	register int		j;

	in = -INFINITY;
	out = INFINITY;
	iplane = oplane = -1;

	if (RT_G_DEBUG & DEBUG_ARB8) {
		bu_log("\n\n------------\n arb: ray point %g %g %g -> %g %g %g\n",
			V3ARGS(rp->r_pt),
			V3ARGS(rp->r_dir));
	}

	/* consider each face */
	for( afp = &arbp->arb_face[j=arbp->arb_nmfaces-1]; j >= 0; j--, afp-- )  {
		FAST fastf_t	dn;		/* Direction dot Normal */
		FAST fastf_t	dxbdn;
		FAST fastf_t	s;

		/* XXX some of this math should be prep work 
		 * (including computing dxbdn/dn ?) *$*/
		dxbdn = VDOT( afp->peqn, rp->r_pt ) - afp->peqn[3];
		dn = -VDOT( afp->peqn, rp->r_dir );

	        if (RT_G_DEBUG & DEBUG_ARB8) {
	        	HPRINT("arb: Plane Equation", afp->peqn);
			bu_log("arb: dn=%g dxbdn=%g s=%g\n", dn, dxbdn, dxbdn/dn);
	        }

		if( dn < -SQRT_SMALL_FASTF )  {
			/* exit point, when dir.N < 0.  out = min(out,s) */
			if( out > (s = dxbdn/dn) )  {
				out = s;
				oplane = j;
			}
		} else if ( dn > SQRT_SMALL_FASTF )  {
			/* entry point, when dir.N > 0.  in = max(in,s) */
			if( in < (s = dxbdn/dn) )  {
				in = s;
				iplane = j;
			}
		}  else  {
			/* ray is parallel to plane when dir.N == 0.
			 * If it is outside the solid, stop now.
			 * Allow very small amount of slop, to catch
			 * rays that lie very nearly in the plane of a face.
			 */
			if( dxbdn > SQRT_SMALL_FASTF )
				return( 0 );	/* MISS */
		}
		if( in > out )
			return( 0 );	/* MISS */
	}
	/* Validate */
	if( iplane == -1 || oplane == -1 )  {
		bu_log("rt_arb_shoot(%s): 1 hit => MISS\n",
			stp->st_name);
		return( 0 );	/* MISS */
	}
	if( in >= out || out >= INFINITY )
		return( 0 );	/* MISS */

	{
		register struct seg *segp;

		RT_GET_SEG( segp, ap->a_resource );
		segp->seg_stp = stp;
		segp->seg_in.hit_dist = in;
		segp->seg_in.hit_surfno = iplane;

		segp->seg_out.hit_dist = out;
		segp->seg_out.hit_surfno = oplane;
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	}
	return(2);			/* HIT */
}

#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	
/*
 *			R T _ A R B _ V S H O T
 *
 *  This is the Becker vector version
 */
void
rt_arb_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		 	       /* Number of ray/object pairs */
                  	    
{
	register int    j, i;
	register struct arb_specific *arbp;
	FAST fastf_t	dn;		/* Direction dot Normal */
	FAST fastf_t	dxbdn;
	FAST fastf_t	s;

	/* Intialize return values */
#	include "noalias.h"
	for(i = 0; i < n; i++){
		segp[i].seg_stp = stp[i];	/* Assume hit, if 0 then miss */
                segp[i].seg_in.hit_dist = -INFINITY;    /* used as in */
                segp[i].seg_in.hit_surfno = -1;		/* used as iplane */
                segp[i].seg_out.hit_dist = INFINITY;    /* used as out */
                segp[i].seg_out.hit_surfno = -1;	/* used as oplane */
/**                segp[i].seg_next = SEG_NULL;**/
	}

	/* consider each face */
	for(j = 0; j < 6; j++)  {
		/* for each ray/arb_face pair */
#		include "noalias.h"
		for(i = 0; i < n; i++)  {
			if (stp[i] == 0) continue;	/* skip this ray */
			if ( segp[i].seg_stp == 0 ) continue;	/* miss */

			arbp= (struct arb_specific *) stp[i]->st_specific;
			if ( arbp->arb_nmfaces <= j )
				continue; /* faces of this ARB are done */

			dxbdn = VDOT( arbp->arb_face[j].peqn, rp[i]->r_pt ) -
				arbp->arb_face[j].peqn[3];
			if( (dn = -VDOT( arbp->arb_face[j].peqn, rp[i]->r_dir )) <
							-SQRT_SMALL_FASTF )  {
			   /* exit point, when dir.N < 0.  out = min(out,s) */
			   if( segp[i].seg_out.hit_dist > (s = dxbdn/dn) )  {
			   	   segp[i].seg_out.hit_dist = s;
				   segp[i].seg_out.hit_surfno = j;
			   }
			} else if ( dn > SQRT_SMALL_FASTF )  {
			   /* entry point, when dir.N > 0.  in = max(in,s) */
			   if( segp[i].seg_in.hit_dist < (s = dxbdn/dn) )  {
				   segp[i].seg_in.hit_dist = s;
				   segp[i].seg_in.hit_surfno = j;
			   }
		        }  else  {
			   /* ray is parallel to plane when dir.N == 0.
			    * If it is outside the solid, stop now */
			   if( dxbdn > SQRT_SMALL_FASTF ) {
				SEG_MISS(segp[i]);		/* MISS */
			   }
			}
		        if(segp[i].seg_in.hit_dist > segp[i].seg_out.hit_dist) {
			   SEG_MISS(segp[i]);		/* MISS */
			}
		} /* for each ray/arb_face pair */
	} /* for each arb_face */

	/*
	 *  Validate for each ray/arb_face pair
	 *  Segment was initialized as "good" (seg_stp set valid);
	 *  that is revoked here on misses.
	 */
#	include "noalias.h"
	for(i = 0; i < n; i++){
		if (stp[i] == 0) continue;		/* skip this ray */
		if ( segp[i].seg_stp == 0 ) continue;	/* missed */

		if( segp[i].seg_in.hit_surfno == -1 ||
		    segp[i].seg_out.hit_surfno == -1 )  {
			SEG_MISS(segp[i]);		/* MISS */
		}
		else if(segp[i].seg_in.hit_dist >= segp[i].seg_out.hit_dist ||
			segp[i].seg_out.hit_dist >= INFINITY ) {
			SEG_MISS(segp[i]);		/* MISS */
		}
	}
}

/*
 *  			R T _ A R B _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_arb_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct arb_specific *arbp =
		(struct arb_specific *)stp->st_specific;
	register int	h;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	h = hitp->hit_surfno;
	VMOVE( hitp->hit_normal, arbp->arb_face[h].peqn );
}

/*
 *			R T _ A R B _ C U R V E
 *
 *  Return the "curvature" of the ARB face.
 *  Pick a principle direction orthogonal to normal, and 
 *  indicate no curvature.
 */
void
rt_arb_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{

	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
	cvp->crv_c1 = cvp->crv_c2 = 0;
}

/*
 *  			R T _ A R B _ U V
 *  
 *  For a hit on a face of an ARB, return the (u,v) coordinates
 *  of the hit point.  0 <= u,v <= 1.
 *  u extends along the arb_U direction defined by B-A,
 *  v extends along the arb_V direction defined by Nx(B-A).
 */
void
rt_arb_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct arb_specific *arbp =
		(struct arb_specific *)stp->st_specific;
	struct oface	*ofp;
	LOCAL vect_t	P_A;
	LOCAL fastf_t	r;
	LOCAL vect_t	rev_dir;
	LOCAL fastf_t	dot_N;
	LOCAL vect_t	UV_dir;
	LOCAL fastf_t	*norm;
	LOCAL fastf_t	min_r_U, min_r_V;

	if( arbp->arb_opt == (struct oface *)0 )  {
		register int		ret = 0;
		struct rt_db_internal	intern;
		struct rt_arb_internal	*aip;

		if( rt_db_get_internal( &intern, stp->st_dp, ap->a_rt_i->rti_dbip, stp->st_matp, ap->a_resource ) < 0 )  {
			bu_log("rt_arb_uv(%s) rt_db_get_internal failure\n",
				stp->st_name);
			return;
		}
		RT_CK_DB_INTERNAL( &intern );
		aip = (struct rt_arb_internal *)intern.idb_ptr;
		RT_ARB_CK_MAGIC(aip);

		/*
		 *  The double check of arb_opt is to avoid the case
		 *  where another processor did the UV setup while
		 *  this processor was waiting in bu_semaphore_acquire().
		 */
		bu_semaphore_acquire( RT_SEM_MODEL );
		if( arbp->arb_opt == (struct oface *)0 )  {
			ret = rt_arb_setup(stp, aip, ap->a_rt_i, 1 );
		}
		bu_semaphore_release( RT_SEM_MODEL );

		rt_db_free_internal( &intern, ap->a_resource );

		if( ret != 0 || arbp->arb_opt == (struct oface *)0 )  {
			bu_log("rt_arb_uv(%s) dyanmic setup failure st_specific=x%x, optp=x%x\n",
				stp->st_name,
		    		stp->st_specific, arbp->arb_opt );
			return;
		}
		if(RT_G_DEBUG&DEBUG_SOLIDS)  rt_pr_soltab( stp );
	}

	ofp = &arbp->arb_opt[hitp->hit_surfno];

	VSUB2( P_A, hitp->hit_point, ofp->arb_UVorig );
	/* Flipping v is an artifact of how the faces are built */
	uvp->uv_u = VDOT( P_A, ofp->arb_U );
	uvp->uv_v = 1.0 - VDOT( P_A, ofp->arb_V );
	if( uvp->uv_u < 0 || uvp->uv_v < 0 || uvp->uv_u > 1 || uvp->uv_v > 1 )  {
		bu_log("arb_uv: bad uv=%g,%g\n", uvp->uv_u, uvp->uv_v);
		/* Fix it up */
		if( uvp->uv_u < 0 )  uvp->uv_u = (-uvp->uv_u);
		if( uvp->uv_v < 0 )  uvp->uv_v = (-uvp->uv_v);
	}
	r = ap->a_rbeam + ap->a_diverge * hitp->hit_dist;
	min_r_U = r * ofp->arb_Ulen;
	min_r_V = r * ofp->arb_Vlen;
	VREVERSE( rev_dir, ap->a_ray.r_dir )
	norm = &arbp->arb_face[hitp->hit_surfno].peqn[0];
	dot_N = VDOT( rev_dir, norm );
	VJOIN1( UV_dir, rev_dir, -dot_N, norm )
	VUNITIZE( UV_dir )
	uvp->uv_du = r * VDOT( UV_dir, ofp->arb_U ) / dot_N;
	uvp->uv_dv = r * VDOT( UV_dir, ofp->arb_V ) / dot_N;
	if( uvp->uv_du < 0.0 )
		uvp->uv_du = -uvp->uv_du;
	if( uvp->uv_du < min_r_U )
		uvp->uv_du = min_r_U;
	if( uvp->uv_dv < 0.0 )
		uvp->uv_dv = -uvp->uv_dv;
	if( uvp->uv_dv < min_r_V )
		uvp->uv_dv = min_r_V;
}

/*
 *			R T _ A R B _ F R E E
 */
void
rt_arb_free(register struct soltab *stp)
{
	register struct arb_specific *arbp =
		(struct arb_specific *)stp->st_specific;

	if( arbp->arb_opt )
		bu_free( (char *)arbp->arb_opt, "arb_opt" );
	bu_free( (char *)arbp, "arb_specific" );
}

#define ARB_FACE( valp, a, b, c, d ) \
	RT_ADD_VLIST( vhead, valp[a], BN_VLIST_LINE_MOVE ); \
	RT_ADD_VLIST( vhead, valp[b], BN_VLIST_LINE_DRAW ); \
	RT_ADD_VLIST( vhead, valp[c], BN_VLIST_LINE_DRAW ); \
	RT_ADD_VLIST( vhead, valp[d], BN_VLIST_LINE_DRAW );

/*
 *  			R T _ A R B _ P L O T
 *
 *  Plot an ARB by tracing out four "U" shaped contours
 *  This draws each edge only once.
 *  XXX No checking for degenerate faces is done, but probably should be.
 */
int
rt_arb_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct rt_arb_internal	*aip;

	RT_CK_DB_INTERNAL(ip);
	aip = (struct rt_arb_internal *)ip->idb_ptr;
	RT_ARB_CK_MAGIC(aip);

	ARB_FACE( aip->pt, 0, 1, 2, 3 );
	ARB_FACE( aip->pt, 4, 0, 3, 7 );
	ARB_FACE( aip->pt, 5, 4, 7, 6 );
	ARB_FACE( aip->pt, 1, 5, 6, 2 );
	return(0);
}

/*
 *			R T _ A R B _ C L A S S
 */
int
rt_arb_class(const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
{
	register struct arb_specific *arbp =
		(struct arb_specific *)stp->st_specific;
	register int i;
	
	if( arbp == (struct arb_specific *)0 ) {
		bu_log("arb(%s): no faces\n", stp->st_name);
		return RT_CLASSIFY_UNIMPLEMENTED;
	}

	for( i=0; i<arbp->arb_nmfaces; i++ ) {
		if( bn_hlf_class( arbp->arb_face[i].peqn, min, max, tol ) ==
		    BN_CLASSIFY_OUTSIDE )
			return RT_CLASSIFY_OUTSIDE;
	}

	/* We need to test for RT_CLASSIFY_INSIDE vs. RT_CLASSIFY_OVERLAPPING!
	   XXX Do this soon */
	return RT_CLASSIFY_UNIMPLEMENTED; /* let the caller assume the worst */
}

/*
 *			R T _ A R B _ I M P O R T
 *
 *  Import an ARB8 from the database format to the internal format.
 *  There are two parts to this:  First, the database is presently
 *  single precision binary floating point.
 *  Second, the ARB in the database is represented as a vector
 *  from the origin to the first point, and 7 vectors
 *  from the first point to the remaining points.  In 1979 it seemed
 *  like a good idea...
 *
 *  Convert from vector to point notation
 *  by rotating each vector and adding in the base vector.
 */
int
rt_arb_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_arb_internal	*aip;
	union record		*rp;
	register int		i;
	LOCAL vect_t		work;
	LOCAL fastf_t		vec[3*8];
	
	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_arb_import: defective record, id=x%x\n", rp->u_id);
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_ARB8;
	ip->idb_meth = &rt_functab[ID_ARB8];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_arb_internal), "rt_arb_internal");
	aip = (struct rt_arb_internal *)ip->idb_ptr;
	aip->magic = RT_ARB_INTERNAL_MAGIC;

	/* Convert from database to internal format */
	rt_fastf_float( vec, rp->s.s_values, 8 );

	/*
	 * Convert from vector notation (in database) to point notation.
	 */
	MAT4X3PNT( aip->pt[0], mat, &vec[0] );

#	include "noalias.h"
	for( i=1; i<8; i++ )  {
		VADD2( work, &vec[0*3], &vec[i*3] );
		MAT4X3PNT( aip->pt[i], mat, work );
	}
	return(0);			/* OK */
}

/*
 *			R T _ A R B _ E X P O R T
 */
int
rt_arb_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_arb_internal	*aip;
	union record		*rec;
	register int		i;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ARB8 )  return(-1);
	aip = (struct rt_arb_internal *)ip->idb_ptr;
	RT_ARB_CK_MAGIC(aip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "arb external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->s.s_type = GENARB8;

	/* NOTE: This also converts to dbfloat_t */
	VSCALE( &rec->s.s_values[3*0], aip->pt[0], local2mm );
	for( i=1; i < 8; i++ )  {
		VSUB2SCALE( &rec->s.s_values[3*i],
			aip->pt[i], aip->pt[0], local2mm );
	}
	return(0);
}

/*
 *			R T _ A R B _ I M P O R T 5
 *
 * Import an arb from the db5 format and convert to the internal structure.
 * Code duplicated from rt_arb_import() with db5 help from g_ell.c
 */
int
rt_arb_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_arb_internal *aip;
	register int		i;
	fastf_t			vec[3*8];

	BU_CK_EXTERNAL( ep );
	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 3*8);
	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_ARB8;
	ip->idb_meth = &rt_functab[ID_ARB8];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_arb_internal), "rt_arb_internal");

	aip = (struct rt_arb_internal *)ip->idb_ptr;
	aip->magic = RT_ARB_INTERNAL_MAGIC;

	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)vec, ep->ext_buf, 8*3);
	for (i=0; i<8; i++) {
		MAT4X3PNT( aip->pt[i], mat, &vec[i*3]);
	}
	return 0;	/* OK */
}
/*
 *			R T _ A R B _ E X P O R T 5
 */
int
rt_arb_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_arb_internal	*aip;
	fastf_t			vec[3*8];
	register int		i;

	RT_CK_DB_INTERNAL(ip);
	if (ip->idb_type != ID_ARB8) return -1;
	aip = (struct rt_arb_internal *)ip->idb_ptr;
	RT_ARB_CK_MAGIC(aip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 8 * 3;
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "arb external");
	for (i=0; i<8; i++) {
		VSCALE( &vec[i*3], aip->pt[i], local2mm );
	}
	htond( ep->ext_buf, (unsigned char *)vec, 8*3);
	return 0;
}
/*
 *			R T _ A R B _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_arb_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_arb_internal	*aip =
		(struct rt_arb_internal *)ip->idb_ptr;
	char	buf[256];
	int	i;
	int	arb_type;
	struct bn_tol tmp_tol;	/* temporay tolerance */

	RT_ARB_CK_MAGIC(aip);

	tmp_tol.magic = BN_TOL_MAGIC;
	tmp_tol.dist = 0.0001; /* to get old behavior of rt_arb_std_type() */
	tmp_tol.dist_sq = tmp_tol.dist * tmp_tol.dist;
	tmp_tol.perp = 1e-5;
	tmp_tol.para = 1 - tmp_tol.perp;

	arb_type = rt_arb_std_type( ip, &tmp_tol );

	if( !arb_type )
	{

		bu_vls_strcat( str, "ARB8\n");

		/* Use 1-based numbering, to match vertex labels in MGED */
		sprintf(buf, "\t1 (%g, %g, %g)\n",
			aip->pt[0][X] * mm2local,
			aip->pt[0][Y] * mm2local,
			aip->pt[0][Z] * mm2local );
		bu_vls_strcat( str, buf );

		if( !verbose )  return(0);

		for( i=1; i < 8; i++ )  {
			sprintf(buf, "\t%d (%g, %g, %g)\n", i+1,
				aip->pt[i][X] * mm2local,
				aip->pt[i][Y] * mm2local,
				aip->pt[i][Z] * mm2local );
			bu_vls_strcat( str, buf );
		}
	}
	else
	{
		sprintf( buf, "ARB%d\n", arb_type );
		bu_vls_strcat( str, buf );
		switch( arb_type )
		{
			case ARB8:
				for( i=0 ; i<8 ; i++ )
				{
					sprintf( buf, "\t%d (%g, %g, %g)\n", i+1,
						aip->pt[i][X] * mm2local,
						aip->pt[i][Y] * mm2local,
						aip->pt[i][Z] * mm2local );
						bu_vls_strcat( str, buf );
				}
				break;
			case ARB7:
				for( i=0 ; i<7 ; i++ )
				{
					sprintf( buf, "\t%d (%g, %g, %g)\n", i+1,
						aip->pt[i][X] * mm2local,
						aip->pt[i][Y] * mm2local,
						aip->pt[i][Z] * mm2local );
						bu_vls_strcat( str, buf );
				}
				break;
			case ARB6:
				for( i=0 ; i<5 ; i++ )
				{
					sprintf( buf, "\t%d (%g, %g, %g)\n", i+1,
						aip->pt[i][X] * mm2local,
						aip->pt[i][Y] * mm2local,
						aip->pt[i][Z] * mm2local );
						bu_vls_strcat( str, buf );
				}
				sprintf( buf, "\t6 (%g, %g, %g)\n",
					aip->pt[6][X] * mm2local,
					aip->pt[6][Y] * mm2local,
					aip->pt[6][Z] * mm2local );
				bu_vls_strcat( str, buf );
				break;
			case ARB5:
				for( i=0 ; i<5 ; i++ )
				{
					sprintf( buf, "\t%d (%g, %g, %g)\n", i+1,
						aip->pt[i][X] * mm2local,
						aip->pt[i][Y] * mm2local,
						aip->pt[i][Z] * mm2local );
						bu_vls_strcat( str, buf );
				}
				break;
			case ARB4:
				for( i=0 ; i<3 ; i++ )
				{
					sprintf( buf, "\t%d (%g, %g, %g)\n", i+1,
						aip->pt[i][X] * mm2local,
						aip->pt[i][Y] * mm2local,
						aip->pt[i][Z] * mm2local );
						bu_vls_strcat( str, buf );
				}
				sprintf( buf, "\t4 (%g, %g, %g)\n",
					aip->pt[4][X] * mm2local,
					aip->pt[4][Y] * mm2local,
					aip->pt[4][Z] * mm2local );
				bu_vls_strcat( str, buf );
				break;
		}
	}
	return(0);
}

/*
 *			R T _ A R B _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_arb_ifree(struct rt_db_internal *ip)
{
	RT_CK_DB_INTERNAL(ip);
	bu_free( ip->idb_ptr, "arb ifree" );
	ip->idb_ptr = (genptr_t)NULL;
}

/*
 *			R T _ A R B _ T E S S
 *
 *  "Tessellate" an ARB into an NMG data structure.
 *  Purely a mechanical transformation of one faceted object
 *  into another.
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_arb_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct rt_arb_internal	*aip;
	struct shell		*s;
	struct prep_arb		pa;
	register int		i;
	struct faceuse		*fu[6];
	struct vertex		*verts[8];
	struct vertex		**vertp[4];

	RT_CK_DB_INTERNAL(ip);
	aip = (struct rt_arb_internal *)ip->idb_ptr;
	RT_ARB_CK_MAGIC(aip);

	bzero( (char *)&pa, sizeof(pa) );
	pa.pa_doopt = 0;		/* no UV stuff */
	pa.pa_tol_sq = tol->dist_sq;
	if( rt_arb_mk_planes( &pa, aip, "(tess)" ) < 0 )  return(-2);

	for( i=0; i<8; i++ )  verts[i] = (struct vertex *)0;

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	/* Process each face */
	for( i=0; i < pa.pa_faces; i++ )  {
		if( pa.pa_clockwise[i] != 0 )  {
			/* Counter-Clockwise orientation (CCW) */
			vertp[0] = &verts[pa.pa_pindex[0][i]];
			vertp[1] = &verts[pa.pa_pindex[1][i]];
			vertp[2] = &verts[pa.pa_pindex[2][i]];
			if( pa.pa_npts[i] > 3 ) {
				vertp[3] = &verts[pa.pa_pindex[3][i]];
			}
		} else {
			register struct vertex	***vertpp = vertp;
			/* Clockwise orientation (CW) */
			if( pa.pa_npts[i] > 3 ) {
				*vertpp++ = &verts[pa.pa_pindex[3][i]];
			}
			*vertpp++ = &verts[pa.pa_pindex[2][i]];
			*vertpp++ = &verts[pa.pa_pindex[1][i]];
			*vertpp++ = &verts[pa.pa_pindex[0][i]];
		}
		if( RT_G_DEBUG & DEBUG_ARB8 )  {
			bu_log("face %d, npts=%d, verts %d %d %d %d\n",
				i, pa.pa_npts[i],
				pa.pa_pindex[0][i], pa.pa_pindex[1][i],
				pa.pa_pindex[2][i], pa.pa_pindex[3][i] );
		}
		if( (fu[i] = nmg_cmface( s, vertp, pa.pa_npts[i] )) == 0 )  {
			bu_log("rt_arb_tess(%s): nmg_cmface() fail on face %d\n", i);
			continue;
		}
	}

	/* Associate vertex geometry */
	for( i=0; i<8; i++ )
		if(verts[i]) nmg_vertex_gv(verts[i], aip->pt[i]);

	/* Associate face geometry */
	for( i=0; i < pa.pa_faces; i++ )  {
#if 1
		/* We already know the plane equations, this is fast */
		nmg_face_g( fu[i], pa.pa_face[i].peqn );
#else
		/* For the cautious, ensure topology and geometry match */
		if( nmg_fu_planeeqn( fu[i], tol ) < 0 )
			return -1;		/* FAIL */
#endif
	}

	/* Mark edges as real */
	(void)nmg_mark_edges_real( &s->l.magic );

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

	/* Some arbs may not be within tolerance, so triangulate faces where needed */
	nmg_make_faces_within_tol( s, tol );

	return(0);
}

static const fastf_t rt_arb_uvw[5*3] = {
	0, 0, 0,
	1, 0, 0,
	1, 1, 0,
	0, 1, 0,
	0, 0, 0
};
static const int rt_arb_vert_index_scramble[4] = { 0, 1, 3, 2 };

/*
 *			R T _ A R B _ T N U R B
 *
 *  "Tessellate" an ARB into a trimmed-NURB-NMG data structure.
 *  Purely a mechanical transformation of one faceted object
 *  into another.
 *
 *  Depending on the application, it might be beneficial to keep ARBs
 *  as planar-NMG objects; there is no real benefit to using B-splines
 *  here, other than uniformity of the conversion for all solids.
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_arb_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
{
	LOCAL struct rt_arb_internal	*aip;
	struct shell		*s;
	struct prep_arb		pa;
	register int		i;
	struct faceuse		*fu[6];
	struct vertex		*verts[8];
	struct vertex		**vertp[4];
	struct edgeuse		*eu;
	struct loopuse		*lu;

	RT_CK_DB_INTERNAL(ip);
	aip = (struct rt_arb_internal *)ip->idb_ptr;
	RT_ARB_CK_MAGIC(aip);

	bzero( (char *)&pa, sizeof(pa) );
	pa.pa_doopt = 0;		/* no UV stuff */
	pa.pa_tol_sq = tol->dist_sq;
	if( rt_arb_mk_planes( &pa, aip, "(tnurb)" ) < 0 )  return(-2);

	for( i=0; i<8; i++ )  verts[i] = (struct vertex *)0;

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	/* Process each face */
	for( i=0; i < pa.pa_faces; i++ )  {
		if( pa.pa_clockwise[i] != 0 )  {
			/* Counter-Clockwise orientation (CCW) */
			vertp[0] = &verts[pa.pa_pindex[0][i]];
			vertp[1] = &verts[pa.pa_pindex[1][i]];
			vertp[2] = &verts[pa.pa_pindex[2][i]];
			if( pa.pa_npts[i] > 3 ) {
				vertp[3] = &verts[pa.pa_pindex[3][i]];
			}
		} else {
			register struct vertex	***vertpp = vertp;
			/* Clockwise orientation (CW) */
			if( pa.pa_npts[i] > 3 ) {
				*vertpp++ = &verts[pa.pa_pindex[3][i]];
			}
			*vertpp++ = &verts[pa.pa_pindex[2][i]];
			*vertpp++ = &verts[pa.pa_pindex[1][i]];
			*vertpp++ = &verts[pa.pa_pindex[0][i]];
		}
		if( RT_G_DEBUG & DEBUG_ARB8 )  {
			bu_log("face %d, npts=%d, verts %d %d %d %d\n",
				i, pa.pa_npts[i],
				pa.pa_pindex[0][i], pa.pa_pindex[1][i],
				pa.pa_pindex[2][i], pa.pa_pindex[3][i] );
		}
		/* The edges created will be linear, in parameter space...,
		 * but need to have edge_g_cnurb geometry. */
		if( (fu[i] = nmg_cmface( s, vertp, pa.pa_npts[i] )) == 0 )  {
			bu_log("rt_arb_tnurb(%s): nmg_cmface() fail on face %d\n", i);
			continue;
		}
		/* March around the fu's loop assigning uv parameter values */
		lu = BU_LIST_FIRST( loopuse, &fu[i]->lu_hd );
		NMG_CK_LOOPUSE(lu);
		eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
		NMG_CK_EDGEUSE(eu);

		/* Loop always has Counter-Clockwise orientation (CCW) */
		nmg_vertexuse_a_cnurb( eu->vu_p, &rt_arb_uvw[0*3] );
		nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &rt_arb_uvw[1*3] );
		eu = BU_LIST_NEXT( edgeuse, &eu->l );

		nmg_vertexuse_a_cnurb( eu->vu_p, &rt_arb_uvw[1*3] );
		nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &rt_arb_uvw[2*3] );
		eu = BU_LIST_NEXT( edgeuse, &eu->l );

		nmg_vertexuse_a_cnurb( eu->vu_p, &rt_arb_uvw[2*3] );
		if( pa.pa_npts[i] > 3 ) {
			nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &rt_arb_uvw[3*3] );

			eu = BU_LIST_NEXT( edgeuse, &eu->l );
			nmg_vertexuse_a_cnurb( eu->vu_p, &rt_arb_uvw[3*3] );
		}
		/* Final eu must end back at the beginning */
		nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &rt_arb_uvw[0*3] );
	}

	/* Associate vertex geometry */
	for( i=0; i<8; i++ )
		if(verts[i]) nmg_vertex_gv(verts[i], aip->pt[i]);

	/* Associate face geometry */
	for( i=0; i < pa.pa_faces; i++ )  {
		struct face_g_snurb	*fg;
		int	j;

		/* Let the library allocate all the storage */
		nmg_face_g_snurb( fu[i],
			2, 2,		/* u,v order */
			4, 4,		/* Number of knots, u,v */
			NULL, NULL,	/* initial u,v knot vectors */
			2, 2,		/* n_rows, n_cols */
			RT_NURB_MAKE_PT_TYPE( 3, RT_NURB_PT_XYZ, RT_NURB_PT_NONRAT ),
			NULL );		/* initial mesh */

		fg = fu[i]->f_p->g.snurb_p;
		NMG_CK_FACE_G_SNURB(fg);

		/* Assign surface knot vectors as 0, 0, 1, 1 */
		fg->u.knots[0] = fg->u.knots[1] = 0;
		fg->u.knots[2] = fg->u.knots[3] = 1;
		fg->v.knots[0] = fg->v.knots[1] = 0;
		fg->v.knots[2] = fg->v.knots[3] = 1;

		/* Assign surface control points from the corners */
		lu = BU_LIST_FIRST( loopuse, &fu[i]->lu_hd );
		NMG_CK_LOOPUSE(lu);
		eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
		NMG_CK_EDGEUSE(eu);

		/* For ctl_points, need 4 verts in order 0, 1, 3, 2 */
		for( j=0; j < pa.pa_npts[i]; j++ )  {
			VMOVE( &fg->ctl_points[rt_arb_vert_index_scramble[j]*3],
				eu->vu_p->v_p->vg_p->coord );

			/* Also associate edge geometry (trimming curve) */
			nmg_edge_g_cnurb_plinear(eu);
			eu = BU_LIST_NEXT( edgeuse, &eu->l );
		}
		if( pa.pa_npts[i] == 3 ) {
			vect_t	c_b;
			/*  Trimming curve describes a triangle ABC on face,
			 *  generate a phantom fourth corner at A + (C-B)
			 *  [3] = [0] + [2] - [1]
			 */
			VSUB2( c_b,
				&fg->ctl_points[rt_arb_vert_index_scramble[2]*3],
				&fg->ctl_points[rt_arb_vert_index_scramble[1]*3] );
			VADD2( &fg->ctl_points[rt_arb_vert_index_scramble[3]*3],
				&fg->ctl_points[rt_arb_vert_index_scramble[0]*3],
				c_b );
		}
	}


	/* Mark edges as real */
	(void)nmg_mark_edges_real( &s->l.magic );

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );
	return(0);
}

/* --- General ARB8 utility routines --- */

/*
 *			R T _ A R B _ C A L C _ P O I N T S
 *
 * Takes the planes[] array and intersects the planes to find the vertices
 * of a GENARB8.  The vertices are stored into arb->pt[].
 * This is an analog of rt_arb_calc_planes().
 */
int
rt_arb_calc_points(
	struct rt_arb_internal	*arb,		/* needs wdb.h */
	int			cgtype,
	const plane_t		planes[6],
	const struct bn_tol	*tol)
{
	int	i;
	point_t	pt[8];

	RT_ARB_CK_MAGIC(arb);

	/* find new points for entire solid */
	for(i=0; i<8; i++){
		if( rt_arb_3face_intersect( pt[i], planes, cgtype, i*3 ) < 0 )  {
		  bu_log("rt_arb_calc_points: Intersection of planes fails %d\n", i);
		  return -1;			/* FAIL */
		}
	}

	/* Move new points to arb */
	for( i=0; i<8; i++ )  {
		VMOVE( arb->pt[i], pt[i] );
	}
	return 0;					/* success */
}

/* planes to define ARB vertices */
const int rt_arb_planes[5][24] = {
	{0,1,3, 0,1,2, 0,2,3, 0,1,3, 1,2,3, 1,2,3, 1,2,3, 1,2,3},	/* ARB4 */
	{0,1,4, 0,1,2, 0,2,3, 0,3,4, 1,2,4, 1,2,4, 1,2,4, 1,2,4},	/* ARB5 */
	{0,2,3, 0,1,3, 0,1,4, 0,2,4, 1,2,3, 1,2,3, 1,2,4, 1,2,4},	/* ARB6 */
	{0,2,4, 0,3,4, 0,3,5, 0,2,5, 1,4,5, 1,3,4, 1,3,5, 1,2,4},	/* ARB7 */
	{0,2,4, 0,3,4, 0,3,5, 0,2,5, 1,2,4, 1,3,4, 1,3,5, 1,2,5},	/* ARB8 */
};

/*
 *			R T _ A R B _ 3 F A C E _ I N T E R S E C T
 *
 *	Finds the intersection point of three faces of an ARB.
 *
 *  Returns -
 *	  0	success, value is in 'point'
 *	 -1	failure
 */
int
rt_arb_3face_intersect(
	point_t			point,
	const plane_t		planes[6],
	int			type,		/* 4..8 */
	int			loc)
{
	int	j;
	int	i1, i2, i3;

	j = type - 4;

	i1 = rt_arb_planes[j][loc];
	i2 = rt_arb_planes[j][loc+1];
	i3 = rt_arb_planes[j][loc+2];

	return bn_mkpoint_3planes( point, planes[i1], planes[i2], planes[i3] );
}
@


11.46
log
@change conf.h to a wrapped config.h
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /cvs/brlcad/librt/g_arb.c,v 11.45 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.45
log
@merge of ansi-6-0-branch into HEAD
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header$ (BRL)";
d43 5
a47 1
#include "conf.h"
@


11.44
log
@update copyright to include span through 2003
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.43 2002/08/20 17:07:58 jra Exp $ (BRL)";
d355 6
a360 6
rt_arb_add_pt( point, title, pap, ptno, name )
register pointp_t point;
const char	*title;
struct prep_arb	*pap;
int		ptno;	/* current point # on face */
const char	*name;
d498 1
a498 4
rt_arb_mk_planes( pap, aip, name )
register struct prep_arb	*pap;
struct rt_arb_internal		*aip;
const char			*name;
d626 1
a626 5
rt_arb_setup( stp, aip, rtip, uv_wanted )
struct soltab		*stp;
struct rt_arb_internal	*aip;
struct rt_i		*rtip;
int			uv_wanted;
d713 1
a713 4
rt_arb_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d727 1
a727 2
rt_arb_print( stp )
register const struct soltab *stp;
d771 1
a771 5
rt_arb_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d860 6
a865 6
rt_arb_vshot( stp, rp, segp, n, ap)
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		 	    n; /* Number of ray/object pairs */
struct application	*ap;
d951 1
a951 4
rt_arb_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d970 1
a970 4
rt_arb_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d986 1
a986 5
rt_arb_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d1071 1
a1071 2
rt_arb_free( stp )
register struct soltab *stp;
d1095 1
a1095 5
rt_arb_plot( vhead, ip, ttol, tol )
struct bu_list			*vhead;
struct rt_db_internal		 *ip;
const struct rt_tess_tol	*ttol;
const struct bn_tol		*tol;
d1114 1
a1114 4
rt_arb_class( stp, min, max, tol )
const struct soltab    *stp;
const vect_t		min, max;
const struct bn_tol    *tol;
d1151 1
a1151 5
rt_arb_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const  mat_t		mat;
const struct db_i		*dbip;
d1195 1
a1195 5
rt_arb_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1230 1
a1230 5
rt_arb_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1258 1
a1258 5
rt_arb_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1286 1
a1286 5
rt_arb_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1404 1
a1404 2
rt_arb_ifree( ip )
struct rt_db_internal	*ip;
d1423 1
a1423 6
rt_arb_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol	*ttol;
const struct bn_tol		*tol;
d1532 1
a1532 5
rt_arb_tnurb( r, m, ip, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct bn_tol	*tol;
@


11.43
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1985 by the United States Army.
d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.41 2002/08/11 02:05:17 morrison Exp $ (BRL)";
@


11.43.4.1
log
@sync to HEAD...
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_arb.c,v 11.44 2004/02/02 17:39:16 morrison Exp $ (BRL)";
@


11.43.10.1
log
@merge from HEAD
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.44 2004/02/02 17:39:16 morrison Exp $ (BRL)";
@


11.43.10.2
log
@merge from head
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.43.10.1 2004/02/12 18:37:39 erikg Exp $ (BRL)";
@


11.43.2.1
log
@Initial ANSIfication
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.43 2002/08/20 17:07:58 jra Exp $ (BRL)";
d355 6
a360 6
rt_arb_add_pt(register pointp_t point, const char *title, struct prep_arb *pap, int ptno, const char *name)
                        
          	       
               	     
   		     	/* current point # on face */
          	      
d498 4
a501 1
rt_arb_mk_planes(register struct prep_arb *pap, struct rt_arb_internal *aip, const char *name)
d629 5
a633 1
rt_arb_setup(struct soltab *stp, struct rt_arb_internal *aip, struct rt_i *rtip, int uv_wanted)
d720 4
a723 1
rt_arb_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d737 2
a738 1
rt_arb_print(register const struct soltab *stp)
d782 5
a786 1
rt_arb_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d875 6
a880 6
rt_arb_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		 	       /* Number of ray/object pairs */
                  	    
d966 4
a969 1
rt_arb_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d988 4
a991 1
rt_arb_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d1007 5
a1011 1
rt_arb_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d1096 2
a1097 1
rt_arb_free(register struct soltab *stp)
d1121 5
a1125 1
rt_arb_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1144 4
a1147 1
rt_arb_class(const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
d1184 5
a1188 1
rt_arb_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1232 5
a1236 1
rt_arb_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1271 5
a1275 1
rt_arb_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1303 5
a1307 1
rt_arb_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1335 5
a1339 1
rt_arb_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1457 2
a1458 1
rt_arb_ifree(struct rt_db_internal *ip)
d1477 6
a1482 1
rt_arb_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1591 5
a1595 1
rt_arb_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
@


11.43.2.2
log
@sync branch with HEAD
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header$ (BRL)";
@


11.42
log
@Converted from K&R to ANSI C - RFH
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.40 2001/10/02 19:24:28 jra Exp $ (BRL)";
d167 1
a167 1

d170 1
a170 1

d172 1
a172 1

d175 1
a175 1

d178 1
a178 1
		if(done == NO)
d180 1
d184 1
a184 1

d186 1
a186 1

d191 1
a191 1

d211 2
a212 2

	if( si > 2 && si < 6 ) 
d214 2
a215 1
	if( si > 6 )
d217 2
a218 1
	for(i=1; i<=svec[1]; i++)
d220 2
a221 1
	for(i=svec[0]+svec[1]+2; i<11; i++)
d223 2
a224 1

d235 1
a235 1
		if( unique == YES )
d237 1
d242 1
a242 1

d355 6
a360 6
rt_arb_add_pt(register pointp_t point, const char *title, struct prep_arb *pap, int ptno, const char *name)
                        
          	       
               	     
   		     	/* current point # on face */
          	      
d498 4
a501 1
rt_arb_mk_planes(register struct prep_arb *pap, struct rt_arb_internal *aip, const char *name)
d629 5
a633 1
rt_arb_setup(struct soltab *stp, struct rt_arb_internal *aip, struct rt_i *rtip, int uv_wanted)
d720 4
a723 1
rt_arb_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d737 2
a738 1
rt_arb_print(register const struct soltab *stp)
d782 5
a786 1
rt_arb_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d875 6
a880 6
rt_arb_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		 	       /* Number of ray/object pairs */
                  	    
d966 4
a969 1
rt_arb_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d988 4
a991 1
rt_arb_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d1007 5
a1011 1
rt_arb_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d1096 2
a1097 1
rt_arb_free(register struct soltab *stp)
d1121 5
a1125 1
rt_arb_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1144 4
a1147 1
rt_arb_class(const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
d1184 5
a1188 1
rt_arb_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1232 5
a1236 1
rt_arb_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1271 5
a1275 1
rt_arb_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1303 5
a1307 1
rt_arb_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1335 5
a1339 1
rt_arb_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1457 2
a1458 1
rt_arb_ifree(struct rt_db_internal *ip)
d1477 6
a1482 1
rt_arb_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1591 5
a1595 1
rt_arb_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
@


11.41
log
@reformatted blocks adding braces for readability and to limit indentation misreading
@
text
@d167 1
a167 1
	
d170 1
a170 1
	
d172 1
a172 1
	
d175 1
a175 1
	
d178 1
a178 1
		if(done == NO) {
a179 1
		}
d183 1
a183 1
			
d185 1
a185 1
			
d190 1
a190 1
			
d210 2
a211 2
	
	if( si > 2 && si < 6 ) {
d213 1
a213 2
	}
	if( si > 6 ) {
d215 1
a215 2
	}
	for(i=1; i<=svec[1]; i++) {
d217 1
a217 2
	}
	for(i=svec[0]+svec[1]+2; i<11; i++) {
d219 1
a219 2
	}
	
d230 1
a230 1
		if( unique == YES ) {
a231 1
		}
d236 1
a236 1
		
d349 6
a354 6
rt_arb_add_pt( point, title, pap, ptno, name )
register pointp_t point;
const char	*title;
struct prep_arb	*pap;
int		ptno;	/* current point # on face */
const char	*name;
d492 1
a492 4
rt_arb_mk_planes( pap, aip, name )
register struct prep_arb	*pap;
struct rt_arb_internal		*aip;
const char			*name;
d620 1
a620 5
rt_arb_setup( stp, aip, rtip, uv_wanted )
struct soltab		*stp;
struct rt_arb_internal	*aip;
struct rt_i		*rtip;
int			uv_wanted;
d707 1
a707 4
rt_arb_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d721 1
a721 2
rt_arb_print( stp )
register const struct soltab *stp;
d765 1
a765 5
rt_arb_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d854 6
a859 6
rt_arb_vshot( stp, rp, segp, n, ap)
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		 	    n; /* Number of ray/object pairs */
struct application	*ap;
d945 1
a945 4
rt_arb_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d964 1
a964 4
rt_arb_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d980 1
a980 5
rt_arb_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d1065 1
a1065 2
rt_arb_free( stp )
register struct soltab *stp;
d1089 1
a1089 5
rt_arb_plot( vhead, ip, ttol, tol )
struct bu_list			*vhead;
struct rt_db_internal		 *ip;
const struct rt_tess_tol	*ttol;
const struct bn_tol		*tol;
d1108 1
a1108 4
rt_arb_class( stp, min, max, tol )
const struct soltab    *stp;
const vect_t		min, max;
const struct bn_tol    *tol;
d1145 1
a1145 5
rt_arb_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const  mat_t		mat;
const struct db_i		*dbip;
d1189 1
a1189 5
rt_arb_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1224 1
a1224 5
rt_arb_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1252 1
a1252 5
rt_arb_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1280 1
a1280 5
rt_arb_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1398 1
a1398 2
rt_arb_ifree( ip )
struct rt_db_internal	*ip;
d1417 1
a1417 6
rt_arb_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol	*ttol;
const struct bn_tol		*tol;
d1526 1
a1526 5
rt_arb_tnurb( r, m, ip, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct bn_tol	*tol;
@


11.40
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.39 2001/05/17 20:05:24 morrison Exp $ (BRL)";
d167 1
a167 1

d170 1
a170 1

d172 1
a172 1

d175 1
a175 1

d178 1
a178 1
		if(done == NO)
d180 1
d184 1
a184 1

d186 1
a186 1

d191 1
a191 1

d211 2
a212 2

	if( si > 2 && si < 6 ) 
d214 2
a215 1
	if( si > 6 )
d217 2
a218 1
	for(i=1; i<=svec[1]; i++)
d220 2
a221 1
	for(i=svec[0]+svec[1]+2; i<11; i++)
d223 2
a224 1

d235 1
a235 1
		if( unique == YES )
d237 1
d242 1
a242 1

@


11.39
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.38 2001/05/16 21:38:04 morrison Exp $ (BRL)";
d1199 1
d1278 1
@


11.38
log
@PRODUCTION optimizations
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.37 2001/04/05 19:35:34 morrison Exp $ (BRL)";
d540 1
a540 1
	if( rt_g.debug & DEBUG_ARB8 )  {
d556 1
a556 1
			if( rt_g.debug & DEBUG_ARB8 )  {
d792 1
a792 1
	if (rt_g.debug & DEBUG_ARB8) {
d809 1
a809 1
	        if (rt_g.debug & DEBUG_ARB8) {
d1051 1
a1051 1
		if(rt_g.debug&DEBUG_SOLIDS)  rt_pr_soltab( stp );
d1518 1
a1518 1
		if( rt_g.debug & DEBUG_ARB8 )  {
d1633 1
a1633 1
		if( rt_g.debug & DEBUG_ARB8 )  {
@


11.37
log
@updated SIGNED to signed
updated CONST to const
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.36 2000/10/24 18:42:34 mike Exp $ (BRL)";
d804 2
@


11.36
log
@
Added rt_arb_get_cgtype() to raytrace.h
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.35 2000/10/24 18:09:39 mike Exp $ (BRL)";
d111 1
a111 1
static CONST struct arb_info rt_arb_info[6] = {
d122 1
a122 1
CONST struct bu_structparse rt_arb_parse[] = {
d351 1
a351 1
CONST char	*title;
d354 1
a354 1
CONST char	*name;
d495 1
a495 1
CONST char			*name;
d732 1
a732 1
register CONST struct soltab *stp;
d1116 2
a1117 2
CONST struct rt_tess_tol	*ttol;
CONST struct bn_tol		*tol;
d1137 3
a1139 3
CONST struct soltab    *stp;
CONST vect_t		min, max;
CONST struct bn_tol    *tol;
d1178 3
a1180 3
CONST struct bu_external	*ep;
register CONST  mat_t		mat;
CONST struct db_i		*dbip;
d1225 1
a1225 1
CONST struct rt_db_internal	*ip;
d1227 1
a1227 1
CONST struct db_i		*dbip;
d1264 3
a1266 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1295 1
a1295 1
CONST struct rt_db_internal	*ip;
d1297 1
a1297 1
CONST struct db_i		*dbip;
d1327 1
a1327 1
CONST struct rt_db_internal	*ip;
d1471 2
a1472 2
CONST struct rt_tess_tol	*ttol;
CONST struct bn_tol		*tol;
d1556 1
a1556 1
static CONST fastf_t rt_arb_uvw[5*3] = {
d1563 1
a1563 1
static CONST int rt_arb_vert_index_scramble[4] = { 0, 1, 3, 2 };
d1585 1
a1585 1
CONST struct bn_tol	*tol;
d1772 1
a1772 1
CONST int rt_arb_planes[5][24] = {
@


11.35
log
@
Added externs from g_arb.c to raytrace.h
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.34 2000/09/08 05:54:41 mike Exp $ (BRL)";
d157 6
a162 6
rt_arb_get_cgtype( cgtype, arb, tol, uvec, svec )
int			*cgtype;
struct rt_arb_internal	*arb;
CONST struct bn_tol	*tol;
register int *uvec;	/* array of unique points */
register int *svec;	/* array of like points */
@


11.34
log
@
Modified tree routines to take resource pointer.
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.33 2000/09/07 01:55:31 mike Exp $ (BRL)";
d291 1
a291 3
rt_arb_std_type( ip, tol )
struct rt_db_internal	*ip;
CONST struct bn_tol	*tol;
a316 1
 * WARNING: The s array is dbfloat_t's not fastf_t's.
d319 1
a319 4
rt_arb_centroid( center_pt, arb, npoints )
point_t			center_pt;
struct rt_arb_internal	*arb;
int			npoints;
@


11.33
log
@
Moved 2 routines from mged/edarb.c to librt/g_arb.c
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.32 2000/08/21 02:02:29 butler Exp $ (BRL)";
d1027 1
a1027 1
		if( rt_db_get_internal( &intern, stp->st_dp, ap->a_rt_i->rti_dbip, stp->st_matp ) < 0 )  {
d1047 1
a1047 1
		rt_db_free_internal( &intern );
@


11.32
log
@Massive compilation warnings eliminated
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.31 2000/07/13 02:36:25 cjohnson Exp $ (BRL)";
d1739 73
@


11.31
log
@LINT from gcc -Wall
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.30 2000/07/11 06:00:13 mike Exp $ (BRL)";
d131 2
a132 1
    {0} };
@


11.30
log
@
Fixed problem in lazy-evaluation code in rt_arb_uv().
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.29 2000/07/10 23:01:29 mike Exp $ (BRL)";
d47 5
d112 6
a117 6
	{ "1234", 3, 2, 1, 0 },		/* "bottom" face */
	{ "8765", 4, 5, 6, 7 },		/* "top" face */
	{ "1485", 4, 7, 3, 0 },
	{ "2673", 2, 6, 5, 1 },
	{ "1562", 1, 5, 4, 0 },
	{ "4378", 7, 6, 2, 3 }
@


11.29
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d40 1
a40 1
static const char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.28 2000/06/30 15:38:02 mike Exp $ (BRL)";
a1017 1
		struct bu_external	ext;
d1021 2
a1022 3
		BU_CK_EXTERNAL(&ext);
		if( db_get_external( &ext, stp->st_dp, ap->a_rt_i->rti_dbip ) < 0 )  {
			bu_log("rt_arb_uv(%s) db_get_external failure\n",
a1025 9
		if( rt_arb_import( &intern, &ext,
		    stp->st_matp ? stp->st_matp : bn_mat_identity,
		    ap->a_rt_i->rti_dbip ) < 0 )  {
			bu_log("rt_arb_uv(%s) database import error\n",
				stp->st_name);
			bu_free_external( &ext );
			return;
		}
		bu_free_external( &ext );
d1041 1
a1041 1
		rt_arb_ifree( &intern );
@


11.28
log
@
export methods should not init the external structure, just check them.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.27 2000/06/30 15:31:14 mike Exp $ (BRL)";
@


11.27
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.26 2000/06/29 18:20:56 mike Exp $ (BRL)";
d1022 1
a1022 1
		BU_INIT_EXTERNAL(&ext);
d1249 1
a1249 1
	BU_INIT_EXTERNAL(ep);
d1319 1
a1319 1
	BU_INIT_EXTERNAL(ep);
@


11.26
log
@
Changed from db_free_external() to bu_free_external()
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.25 2000/06/27 15:07:03 cjohnson Exp $ (BRL)";
d1207 1
a1207 1
	RT_INIT_DB_INTERNAL( ip );
d1285 1
a1285 1
	RT_INIT_DB_INTERNAL( ip );
@


11.25
log
@Check input length to make sure it matches expected lengths.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.24 2000/06/26 20:07:07 cjohnson Exp $ (BRL)";
d1033 1
a1033 1
			db_free_external( &ext );
d1036 1
a1036 1
		db_free_external( &ext );
@


11.24
log
@Add import/export db5 formats for arb.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.23 2000/04/12 02:34:30 mike Exp $ (BRL)";
d1284 1
@


11.23
log
@
NT port, non-compat4
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.22 2000/03/29 02:43:08 mike Exp $ (BRL)";
d1266 61
@


11.22
log
@
Fixed invocation of nmg_mark_edges_real()
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.21 1999/11/26 21:46:44 mike Exp $ (BRL)";
d986 1
a986 1
	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.21
log
@
Lint cleanups
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.20 1999/11/26 20:36:11 mike Exp $ (BRL)";
d1494 1
a1494 1
	(void)nmg_mark_edges_real( &s->l );
d1677 1
a1677 1
	(void)nmg_mark_edges_real( &s->l );
@


11.20
log
@
Prototype matching
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.19 1999/11/26 20:32:34 mike Exp $ (BRL)";
d1276 1
a1276 1
struct rt_db_internal	*ip;
@


11.19
log
@
import template
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.18 1999/11/24 23:12:06 mike Exp $ (BRL)";
d1128 1
a1128 1
struct bn_tol			*tol;
d1234 1
a1234 1
rt_arb_export( ep, ip, local2mm )
d1238 1
d1421 1
a1421 1
struct bn_tol		*tol;
d1534 1
a1534 1
struct bn_tol		*tol;
@


11.18
log
@
Made structparse tables CONST
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.17 1999/11/24 21:44:29 mike Exp $ (BRL)";
d1029 2
a1030 1
		    stp->st_matp ? stp->st_matp : bn_mat_identity ) < 0 )  {
d1187 1
a1187 1
rt_arb_import( ip, ep, mat )
d1191 1
@


11.17
log
@
Removed includes of compat header files rtstring.h and rtlist.h
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.16 1999/11/17 04:39:20 mike Exp $ (BRL)";
d117 1
a117 1
struct bu_structparse rt_arb_parse[] = {
@


11.16
log
@
Added 3 new fields to rt_functab, in order to better support the TCL
interface to db get and db put.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.15 1999/11/17 02:41:55 mike Exp $ (BRL)";
a52 1
#include "rtstring.h"
@


11.15
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.14 1999/07/02 22:19:22 mike Exp $ (BRL)";
d118 1
a118 1
struct bu_structparse rt_arb8_parse[] = {
@


11.14
log
@
Removed dependence on compat4.h
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.13 1999/05/27 19:10:35 mike Exp $ (BRL)";
d1208 1
@


11.13
log
@
sed4
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arb.c,v 11.12 1997/12/16 00:13:37 mike Exp $ (BRL)";
d1111 4
a1114 4
	RT_ADD_VLIST( vhead, valp[a], RT_VLIST_LINE_MOVE ); \
	RT_ADD_VLIST( vhead, valp[b], RT_VLIST_LINE_DRAW ); \
	RT_ADD_VLIST( vhead, valp[c], RT_VLIST_LINE_DRAW ); \
	RT_ADD_VLIST( vhead, valp[d], RT_VLIST_LINE_DRAW );
@


11.12
log
@Converted to bu_semaphore_acquire()
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 11.11 1997/11/21 21:02:47 jra Exp mike $ (BRL)";
d471 1
a471 1
			rt_log("arb(%s): face %s[%d] non-planar, dot=%g\n",
d542 1
a542 1
		rt_log("arb(%s) equiv_pts[] = %d %d %d %d %d %d %d %d\n",
d558 1
a558 1
				rt_log("face %d, j=%d, npts=%d, orig_vert=%d, vert=%d\n",
d606 1
a606 1
		rt_log("arb(%s):  only %d faces present\n",
d651 1
a651 1
			arbp = (struct arb_specific *)rt_malloc(
d669 1
a669 1
			ofp = (struct oface *)rt_malloc(
d741 1
a741 1
		rt_log("arb(%s):  no faces\n", stp->st_name);
d744 1
a744 1
	rt_log("%d faces:\n", arbp->arb_nmfaces);
d755 1
a755 1
			rt_log( "Ulen = %g, Vlen = %g\n",
d794 1
a794 1
		rt_log("\n\n------------\n arb: ray point %g %g %g -> %g %g %g\n",
d810 1
a810 1
			rt_log("arb: dn=%g dxbdn=%g s=%g\n", dn, dxbdn, dxbdn/dn);
d839 1
a839 1
		rt_log("rt_arb_shoot(%s): 1 hit => MISS\n",
d856 1
a856 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d1019 1
a1019 1
		struct rt_external	ext;
d1023 1
a1023 1
		RT_INIT_EXTERNAL(&ext);
d1025 1
a1025 1
			rt_log("rt_arb_uv(%s) db_get_external failure\n",
d1031 1
a1031 1
			rt_log("rt_arb_uv(%s) database import error\n",
d1055 1
a1055 1
			rt_log("rt_arb_uv(%s) dyanmic setup failure st_specific=x%x, optp=x%x\n",
d1070 1
a1070 1
		rt_log("arb_uv: bad uv=%g,%g\n", uvp->uv_u, uvp->uv_v);
d1106 2
a1107 2
		rt_free( (char *)arbp->arb_opt, "arb_opt" );
	rt_free( (char *)arbp, "arb_specific" );
d1125 1
a1125 1
struct rt_list			*vhead;
d1128 1
a1128 1
struct rt_tol			*tol;
d1157 1
a1157 1
		rt_log("arb(%s): no faces\n", stp->st_name);
d1189 1
a1189 1
CONST struct rt_external	*ep;
d1198 1
a1198 1
	RT_CK_EXTERNAL( ep );
d1202 1
a1202 1
		rt_log("rt_arb_import: defective record, id=x%x\n", rp->u_id);
d1208 1
a1208 1
	ip->idb_ptr = rt_malloc( sizeof(struct rt_arb_internal), "rt_arb_internal");
d1233 1
a1233 1
struct rt_external		*ep;
d1246 1
a1246 1
	RT_INIT_EXTERNAL(ep);
d1248 1
a1248 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "arb external");
d1272 1
a1272 1
struct rt_vls		*str;
d1286 1
a1286 1
	tmp_tol.magic = RT_TOL_MAGIC;
d1297 1
a1297 1
		rt_vls_strcat( str, "ARB8\n");
d1304 1
a1304 1
		rt_vls_strcat( str, buf );
d1313 1
a1313 1
			rt_vls_strcat( str, buf );
d1319 1
a1319 1
		rt_vls_strcat( str, buf );
d1329 1
a1329 1
						rt_vls_strcat( str, buf );
d1339 1
a1339 1
						rt_vls_strcat( str, buf );
d1349 1
a1349 1
						rt_vls_strcat( str, buf );
d1355 1
a1355 1
				rt_vls_strcat( str, buf );
d1364 1
a1364 1
						rt_vls_strcat( str, buf );
d1374 1
a1374 1
						rt_vls_strcat( str, buf );
d1380 1
a1380 1
				rt_vls_strcat( str, buf );
d1397 1
a1397 1
	rt_free( ip->idb_ptr, "arb ifree" );
d1418 1
a1418 1
struct rt_tol		*tol;
d1440 1
a1440 1
	s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d1463 1
a1463 1
			rt_log("face %d, npts=%d, verts %d %d %d %d\n",
d1469 1
a1469 1
			rt_log("rt_arb_tess(%s): nmg_cmface() fail on face %d\n", i);
d1531 1
a1531 1
struct rt_tol		*tol;
d1555 1
a1555 1
	s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d1578 1
a1578 1
			rt_log("face %d, npts=%d, verts %d %d %d %d\n",
d1586 1
a1586 1
			rt_log("rt_arb_tnurb(%s): nmg_cmface() fail on face %d\n", i);
d1590 1
a1590 1
		lu = RT_LIST_FIRST( loopuse, &fu[i]->lu_hd );
d1592 1
a1592 1
		eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
d1598 1
a1598 1
		eu = RT_LIST_NEXT( edgeuse, &eu->l );
d1602 1
a1602 1
		eu = RT_LIST_NEXT( edgeuse, &eu->l );
d1608 1
a1608 1
			eu = RT_LIST_NEXT( edgeuse, &eu->l );
d1643 1
a1643 1
		lu = RT_LIST_FIRST( loopuse, &fu[i]->lu_hd );
d1645 1
a1645 1
		eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
d1655 1
a1655 1
			eu = RT_LIST_NEXT( edgeuse, &eu->l );
@


11.11
log
@Moved a line (no effect).
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 11.10 1997/09/02 17:58:15 gdurf Exp jra $ (BRL)";
d1044 1
a1044 1
		 *  this processor was waiting in RES_ACQUIRE().
d1046 1
a1046 1
		RES_ACQUIRE( &rt_g.res_model );
d1050 1
a1050 1
		RES_RELEASE( &rt_g.res_model );
@


11.10
log
@no changes
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 11.9 1997/08/01 17:57:26 jra Exp gdurf $ (BRL)";
d1084 1
a1088 1
	uvp->uv_dv = r * VDOT( UV_dir, ofp->arb_V ) / dot_N;
@


11.9
log
@Modified rt_arb_uv() to calculate better du and dv.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 11.8 1997/07/23 06:42:42 gdurf Exp jra $ (BRL)";
d1178 1
a1178 1
 *  Secondly, the ARB in the database is represented as a vector
@


11.8
log
@Added classifier for arbs (sorta slow)
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 11.7 1997/06/19 22:29:46 jra Exp gdurf $ (BRL)";
d1011 5
d1076 17
a1092 2
	uvp->uv_du = r * ofp->arb_Ulen;
	uvp->uv_dv = r * ofp->arb_Vlen;
@


11.7
log
@Added  rt_arb_get_cgtype(), rt_arb_std_type(), and rt_arb_centroid() from mged/arbs.c
Mods to get rt_arb_describe() to list vertices that agree with mged labels.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 11.6 1997/06/17 19:25:55 gdurf Exp jra $ (BRL)";
d523 1
a523 1
	 *  vertex (or it's own vertex number, if non-equivalent).
d1127 4
a1130 1
rt_arb_class()
d1132 18
a1149 1
	return(0);
@


11.6
log
@Added bu_structparse for arb8s
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 11.5 1997/01/24 21:20:32 bparker Exp gdurf $ (BRL)";
d129 208
d1241 2
d1246 12
a1257 4
	rt_vls_strcat( str, "ARB8\n");
	/* XXX For the future, might want to comment on what sub-type
	 * XXX of ARB this is (e.g., ARB4).
	 */
d1259 6
a1264 6
	/* Use 1-based numbering, to match vertex labels in MGED */
	sprintf(buf, "\t1 (%g, %g, %g)\n",
		aip->pt[0][X] * mm2local,
		aip->pt[0][Y] * mm2local,
		aip->pt[0][Z] * mm2local );
	rt_vls_strcat( str, buf );
d1266 1
a1266 1
	if( !verbose )  return(0);
d1268 11
a1278 5
	for( i=1; i < 8; i++ )  {
		sprintf(buf, "\t%d (%g, %g, %g)\n", i+1,
			aip->pt[i][X] * mm2local,
			aip->pt[i][Y] * mm2local,
			aip->pt[i][Z] * mm2local );
d1280 63
@


11.5
log
@*** empty log message ***
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 11.4 1996/03/18 18:50:48 jra Exp bparker $ (BRL)";
d117 11
@


11.4
log
@Modified tesselator to triangulate arb faces that are not within tolerance.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 11.3 1995/11/29 21:16:19 mike Exp jra $ (BRL)";
d48 1
d50 1
d806 1
a806 1
		    stp->st_matp ? stp->st_matp : rt_identity ) < 0 )  {
@


11.3
log
@A working ARB "tiler" / tesselator.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 11.1 95/01/04 09:56:27 mike Rel4_4 $ (BRL)";
d1155 4
@


11.2
log
@Initial tnurb conversion
@
text
@d1158 9
a1197 1
	point_t			uvw;
d1252 2
a1253 2
		VSET( uvw, 0, 0, 0 );
		nmg_vertexuse_a_cnurb( eu->vu_p, uvw );
d1256 2
a1257 2
		VSET( uvw, 1, 0, 0 );
		nmg_vertexuse_a_cnurb( eu->vu_p, uvw );
d1260 3
a1262 3
		VSET( uvw, 1, 1, 0 );
		nmg_vertexuse_a_cnurb( eu->vu_p, uvw );
		eu = RT_LIST_NEXT( edgeuse, &eu->l );
a1263 3
		if( pa.pa_npts[i] > 3 ) {
			VSET( uvw, 0, 1, 0 );
			nmg_vertexuse_a_cnurb( eu->vu_p, uvw );
d1265 1
d1267 2
d1294 1
a1294 1
		fg->u.knots[2] = fg->u.knots[2] = 1;
d1296 1
a1296 1
		fg->v.knots[2] = fg->v.knots[2] = 1;
d1304 1
d1306 2
a1307 2
			VMOVE( &fg->ctl_points[j*3], eu->vu_p->v_p->vg_p->coord );
			eu = RT_LIST_NEXT( edgeuse, &eu->l );
d1311 1
d1313 1
a1313 1
		if( pa.pa_npts[i] > 3 ) {
d1319 6
a1324 2
			VSUB2( c_b, &fg->ctl_points[2*3], &fg->ctl_points[1*3] );
			VADD2( &fg->ctl_points[3*3], &fg->ctl_points[0*3], c_b );
@


11.1
log
@Release_4.4
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 10.8 94/09/30 16:24:21 mike Exp $ (BRL)";
d53 1
d1149 165
@


10.8
log
@Null out ip->idb_ptr after freeing memory in rt_*_ifree()
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 10.7 94/09/13 15:46:43 jra Exp Locker: mike $ (BRL)";
@


10.7
log
@Removed vertexuse normals.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 10.6 94/09/09 11:03:16 jra Exp Locker: jra $ (BRL)";
d1057 1
@


10.6
log
@Added vertexuse normals and marked edges as real in tesselator.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 10.5 94/08/10 18:23:56 gdurf Exp Locker: jra $ (BRL)";
a1145 45
	}

	/* Associate normal vectors with vertexuses */
	for( i=0 ; i<pa.pa_faces ; i++ )
	{
		struct loopuse *lu;
		vect_t norm_opp;

		NMG_CK_FACEUSE( fu[i] );

		VREVERSE( norm_opp , pa.pa_face[i].peqn );

		for( RT_LIST_FOR( lu , loopuse , &fu[i]->lu_hd ) )
		{
			struct edgeuse *eu;

			NMG_CK_LOOPUSE( lu );

			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			{
				/* This is bad!! */
				rt_log( "Tesselating an arb, has a vertex-loop\n" );
				return -1;
			}

			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				struct vertexuse *vu;

				NMG_CK_EDGEUSE( eu );

				/* normals in same direction as faceuse normals */
				vu = eu->vu_p;
				NMG_CK_VERTEXUSE( vu );

				/* OT_SAME faceuse */
				nmg_vertexuse_nv( vu , pa.pa_face[i].peqn );

				vu = eu->eumate_p->vu_p;
				NMG_CK_VERTEXUSE( vu );

				/* OT_OPPOSITE faceuse */
				nmg_vertexuse_nv( vu , norm_opp );
			}
		}
@


10.5
log
@Added include of conf.h
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 10.4 1994/04/22 10:05:15 butler Exp gdurf $ (BRL)";
d1147 48
@


10.4
log
@more debugging opportunities
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 10.3 93/11/18 01:43:50 mike Exp Locker: butler $ (BRL)";
d42 2
@


10.3
log
@Added tol arg to bounding box routines
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 10.2 92/10/27 16:16:46 mike Exp $ (BRL)";
d569 6
d582 8
a589 1
		if( (dn = -VDOT( afp->peqn, rp->r_dir )) < -SQRT_SMALL_FASTF )  {
@


10.2
log
@Added printing of defective solid names when non-planar faces
are encountered.  Debugging is impossible otherwise.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 10.1 91/10/12 06:40:10 mike Rel4_0 Locker: mike $ (BRL)";
d1134 1
a1134 1
	nmg_region_a( *r );
@


10.1
log
@Release_4.0
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.40 91/09/20 22:41:15 butler Exp $ (BRL)";
d126 1
a126 1
rt_arb_add_pt( point, title, pap, ptno )
d131 1
d247 2
a248 2
			rt_log("arb(): face %s[%d] non-planar, dot=%g\n",
				title, ptno, f );
d269 1
a269 1
rt_arb_mk_planes( pap, aip )
d272 1
d318 4
a321 3
		rt_log("arb() equiv_pts[] = %d %d %d %d %d %d %d %d\n",
		equiv_pts[0], equiv_pts[1], equiv_pts[2], equiv_pts[3],
		equiv_pts[4], equiv_pts[5], equiv_pts[6], equiv_pts[7]);
d351 1
a351 1
			    rt_arb_info[i].ai_title, pap, npts ) == 0 )  {
d382 2
a383 2
		rt_log("arb():  only %d faces present\n",
			pap->pa_faces);
d414 1
a414 1
	if( rt_arb_mk_planes( &pa, aip ) < 0 )  {
d1078 1
a1078 1
	if( rt_arb_mk_planes( &pa, aip ) < 0 )  return(-2);
@


9.40
log
@removing the fuzz with lint
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.39 91/07/06 00:52:35 mike Exp $ (BRL)";
@


9.39
log
@CONST
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.38 91/07/04 02:33:11 mike Exp $ (BRL)";
a275 1
	LOCAL fastf_t	f;
a870 1
	int			i;
@


9.38
log
@Changed the arb_describe function to identify the vertices with
1-based subscripting (rather than 0-based), to match the vertex
labels on the screen in MGED.
Suggested by Paul Tanenbaum and William Potter.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.37 91/06/30 00:10:31 mike Exp $ (BRL)";
d98 1
a98 1
static struct arb_info {
d101 2
a102 1
} rt_arb_info[6] = {
d128 1
a128 1
char		*title;
@


9.37
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.36 91/06/22 22:29:32 mike Exp $ (BRL)";
d1010 2
a1011 1
	sprintf(buf, "\t0 (%g, %g, %g)\n",
d1020 1
a1020 1
		sprintf(buf, "\t%d (%g, %g, %g)\n", i,
@


9.36
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.35 91/06/14 06:52:24 mike Exp $ (BRL)";
d506 1
a506 1
register struct soltab *stp;
d909 3
a911 3
struct rt_db_internal	*ip;
struct rt_external	*ep;
register mat_t		mat;
d954 3
a956 3
struct rt_external	*ep;
struct rt_db_internal	*ip;
double			local2mm;
@


9.35
log
@st_pathmat changed to st_matp, which is a null pointer if an
identity matrix is in use.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.34 91/05/18 03:00:21 mike Exp $ (BRL)";
a109 2
static struct rt_tol	rt_arb_tol;

d397 1
a397 1
rt_arb_setup( stp, aip, rtip, uv_wanted, tol )
a401 1
CONST struct rt_tol	*tol;
d409 1
a409 1
	pa.pa_tol_sq = tol->dist_sq;
d488 1
a488 1
rt_arb_prep( stp, ip, rtip, tol )
a491 1
CONST struct rt_tol	*tol;
d498 1
a498 3
	if( rt_arb_tol.para <= 0 )  rt_arb_tol = *tol;	/* struct copy */

	return( rt_arb_setup( stp, aip, rtip, 0, tol ) );
d550 1
a550 1
rt_arb_shot( stp, rp, ap, seghead, tol )
a554 1
CONST struct rt_tol	*tol;
d628 1
a628 1
rt_arb_vshot( stp, rp, segp, n, resp, tol)
d633 1
a633 2
struct resource         *resp; /* pointer to a list of free segs */
CONST struct rt_tol	*tol;
d784 2
a785 1
		if( rt_arb_import( &intern, &ext, stp->st_matp ? stp->st_matp : rt_identity ) < 0 )  {
d803 1
a803 1
			ret = rt_arb_setup(stp, aip, ap->a_rt_i, 1, &rt_arb_tol);
@


9.34
log
@Converted to new tolerance interface
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.33 91/04/01 20:08:47 mike Exp $ (BRL)";
d792 1
a792 1
		if( rt_arb_import( &intern, &ext, stp->st_pathmat ) < 0 )  {
@


9.33
log
@More efficient, still correct
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.32 91/04/01 19:58:45 mike Exp $ (BRL)";
d110 2
d399 1
a399 1
rt_arb_setup( stp, aip, rtip, uv_wanted )
d404 1
d412 1
a412 1
	pa.pa_tol_sq = 0.005;
d491 1
a491 1
rt_arb_prep( stp, ip, rtip )
d495 1
d502 3
a504 1
	return( rt_arb_setup( stp, aip, rtip, 0 ) );
d556 1
a556 1
rt_arb_shot( stp, rp, ap, seghead )
d561 1
d635 1
a635 1
rt_arb_vshot( stp, rp, segp, n, resp)
d641 1
d810 1
a810 1
			ret = rt_arb_setup(stp, aip, ap->a_rt_i, 1);
d871 5
a875 6
rt_arb_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
struct rt_list	*vhead;
struct rt_db_internal *ip;
double		abs_tol;
double		rel_tol;
double		norm_tol;
d1060 1
a1060 1
rt_arb_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d1064 2
a1065 3
double		abs_tol;
double		rel_tol;
double		norm_tol;
d1081 1
a1081 1
	pa.pa_tol_sq = 0.005;	/* XXX need real tolerance here! XXX */
d1132 1
a1132 1
		if( nmg_fu_planeeqn( fu[i], pa.pa_tol_sq ) < 0 )
@


9.32
log
@Edges of loops now travel in a counter-clockwise (CCW) direction
around the face normal.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.31 91/04/01 18:02:41 mike Exp $ (BRL)";
d1121 1
a1121 1
#if 0
@


9.31
log
@Added comments
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.30 91/02/07 20:31:58 mike Exp $ (BRL)";
d84 1
a84 1
	int		pa_reversed[6];	/* face normal was flipped */
d201 5
d211 1
a211 1
			pap->pa_reversed[pap->pa_faces] = 1;
d213 1
a213 1
			pap->pa_reversed[pap->pa_faces] = 0;
d1085 2
a1086 2
		if( pa.pa_reversed[i] == 0 )  {
			/* Clockwise orientation (CW) */
d1095 1
a1095 1
			/* Counter-Clockwise orientation (CCW) */
d1121 1
a1121 1
#if 1
d1126 2
a1127 1
		rt_mk_nmg_planeeqn( fu[i], pa.pa_tol_sq );
a1132 64
	return(0);
}

/*
 *			R T _ M K _ N M G _ P L A N E E Q N
 *
 *  This routine is just a hack, for getting started quickly.
 *
 *  If face was built in clockwise manner from points A, B, C, then
 *	A is at eu
 *	B is at eu->last, and
 *	C is at eu->next
 *  as a consequence of the way nmg_cmface() makes the face.
 *
 *  Returns -
 *	0	OK
 *	-1	failure
 */
int
rt_mk_nmg_planeeqn( fu, tol_sq )
struct faceuse	*fu;
double		tol_sq;
{
	struct edgeuse		*eu, *eu_last, *eu_next;
	struct loopuse		*lu;
	plane_t			plane;
	struct vertex_g		*a, *b, *c;

	if( fu == (struct faceuse *)0 )  {
		rt_bomb("rt_mk_nmg_planeeqn(): null faceuse\n");
	}

	lu = RT_LIST_FIRST(loopuse, &fu->lu_hd);
	NMG_CK_LOOPUSE(lu);

	eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
	NMG_CK_EDGEUSE(eu);

	eu_last = RT_LIST_PLAST_CIRC(edgeuse, eu);
	eu_next = RT_LIST_PNEXT_CIRC(edgeuse, eu);
	NMG_CK_EDGEUSE(eu_last);
	NMG_CK_EDGEUSE(eu_next);

	a = eu->vu_p->v_p->vg_p;
	b = eu_last->vu_p->v_p->vg_p;
	c = eu_next->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G(a);
	NMG_CK_VERTEX_G(b);
	NMG_CK_VERTEX_G(c);

	if (rt_mk_plane_3pts(plane, a->coord, b->coord, c->coord, tol_sq) < 0 ) {
		rt_log("rt_mk_nmg_planeeqn(): rt_mk_plane_3pts failed on (%g,%g,%g) (%g,%g,%g) (%g,%g,%g)\n",
			V3ARGS( a->coord ),
			V3ARGS( b->coord ),
			V3ARGS( c->coord ) );
	    	HPRINT("plane", plane);
		return(-1);
	}
	if (plane[0] == 0.0 && plane[1] == 0.0 && plane[2] == 0.0) {
		rt_log("rt_mk_nmg_planeeqn():  Bad plane equation from rt_mk_plane_3pts\n" );
	    	HPRINT("plane", plane);
		return(-1);
	}
	nmg_face_g( fu, plane);
@


9.30
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.29 91/01/28 23:53:03 mike Exp $ (BRL)";
d162 1
d1081 1
a1081 1
			/* Normal orientation */
d1090 1
@


9.29
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.28 91/01/26 03:14:37 mike Exp $ (BRL)";
d1075 1
a1075 1
	s = NMG_LIST_FIRST(shell, &(*r)->s_hd);
d1157 1
a1157 1
	lu = NMG_LIST_FIRST(loopuse, &fu->lu_hd);
d1160 1
a1160 1
	eu = NMG_LIST_FIRST(edgeuse, &lu->down_hd);
d1163 2
a1164 2
	eu_last = NMG_LIST_PLAST_CIRC(edgeuse, eu);
	eu_next = NMG_LIST_PNEXT_CIRC(edgeuse, eu);
@


9.28
log
@Eliminated mat parameter on ft_plot and ft_tess
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.27 91/01/25 21:17:55 mike Exp $ (BRL)";
d844 4
a847 4
	ADD_VL( vhead, valp[a], 0 ); \
	ADD_VL( vhead, valp[b], 1 ); \
	ADD_VL( vhead, valp[c], 1 ); \
	ADD_VL( vhead, valp[d], 1 );
d858 1
a858 1
struct vlhead	*vhead;
@


9.27
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.26 91/01/23 22:46:22 mike Exp $ (BRL)";
d857 1
a857 1
rt_arb_plot( vhead, mat, ip, abs_tol, rel_tol, norm_tol )
a858 1
mat_t		mat;
d1047 1
a1047 1
rt_arb_tess( r, m, ip, mat, abs_tol, rel_tol, norm_tol )
a1050 1
register mat_t		mat;
@


9.26
log
@Changed to new interface
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.25 90/12/15 04:52:37 mike Exp $ (BRL)";
a89 1
	char		*pa_name;	/* string for error messages */
d239 2
a240 2
			rt_log("arb(%s): face %s[%d] non-planar, dot=%g\n",
				pap->pa_name, title, ptno, f );
d310 1
a310 2
		rt_log("arb(%s) equiv_pts[] = %d %d %d %d %d %d %d %d\n",
		pap->pa_name,
d373 2
a374 2
		rt_log("arb(%s):  only %d faces present\n",
			pap->pa_name, pap->pa_faces);
a402 1
	pa.pa_name = stp->st_name;
a480 1
#if NEW_IF
a486 10
#else
int
rt_arb_prep( stp, rec, rtip )
struct soltab	*stp;
union record	*rec;
struct rt_i	*rtip;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a488 12
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rec;
	ep->ext_nbytes = stp->st_dp->d_len*sizeof(union record);
	ip = &intern;
	if( rt_arb_import( ip, ep, stp->st_pathmat ) < 0 )
		return(-1);		/* BAD */
	RT_CK_DB_INTERNAL( ip );
#endif
a855 1
#if NEW_IF
a864 11
#else
int
rt_arb_plot( rp, mat, vhead, dp )
register union record	*rp;
register mat_t		mat;
struct vlhead		*vhead;
struct directory	*dp;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a867 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_arb_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_arb_plot(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
a1046 1
#if NEW_IF
a1056 15
#else
int
rt_arb_tess( r, m, rp, mat, dp, abs_tol, rel_tol, norm_tol )
struct nmgregion	**r;
struct model		*m;
union record		*rp;
mat_t			mat;
struct directory	*dp;
double			abs_tol;
double			rel_tol;
double			norm_tol;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a1064 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_arb_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_arb_tess(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
a1070 1
	pa.pa_name = dp->d_namep;
@


9.25
log
@Relaxed tolernace for sloppy faces to .5 degrees.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/g_arb.c,v 9.24 90/12/11 22:06:23 mike Exp $ (BRL)";
d49 1
d51 1
a55 5
/* The internal (in memory) form of an ARB8 -- 8 points in space */
struct arb_internal {
	fastf_t	arbi_pt[3*8];
};

d111 2
d254 1
a254 1
 *  Given an arb_internal structure with 8 points in it,
d264 1
a264 1
struct arb_internal		*aip;
a265 1
	register fastf_t *op;		/* Used for scanning vectors */
a281 1
	op = &aip->arbi_pt[0*ELEMENTS_PER_VECT];
d284 1
a284 2
		VADD2( sum, sum, op );
		op += ELEMENTS_PER_VECT;
a295 2
		register pointp_t	point;
		point = &aip->arbi_pt[i*ELEMENTS_PER_VECT];
d300 1
a300 1
			VSUB2( work, point, &aip->arbi_pt[j*ELEMENTS_PER_VECT] );
d343 1
a343 2
			if( rt_arb_add_pt(
			    &aip->arbi_pt[pt_index*ELEMENTS_PER_VECT],
d393 5
a397 5
rt_arb_setup( stp, rec, rtip, uv_wanted )
struct soltab	*stp;
union record	*rec;
struct rt_i	*rtip;
int		uv_wanted;
a399 1
	struct arb_internal	ai;
d402 1
a402 11
	if( rec == (union record *)0 )  {
		rec = db_getmrec( rtip->rti_dbip, stp->st_dp );
		i = rt_arb_import( &ai, rec, stp->st_pathmat );
		rt_free( (char *)rec, "arb record" );
	} else {
		i = rt_arb_import( &ai, rec, stp->st_pathmat );
	}
	if( i < 0 )  {
		rt_log("rt_arb_setup(%s): db import failure\n", stp->st_name);
		return(-1);		/* BAD */
	}
d408 1
a408 1
	if( rt_arb_mk_planes( &pa, &ai ) < 0 )  {
a455 1
		register fastf_t	*op;
a458 1
		op = &ai.arbi_pt[0];
d461 1
a461 2
			VMINMAX( stp->st_min, stp->st_max, op );
			op += ELEMENTS_PER_VECT;
d484 1
d486 7
d498 21
a518 1
	return( rt_arb_setup( stp, rec, rtip, 0 ) );
d793 4
a796 1
		register int	ret = 0;
d798 17
d822 1
a822 1
			ret = rt_arb_setup(stp, (union record *)0, ap->a_rt_i, 1);
d826 2
d870 4
a873 4
	ADD_VL( vhead, &valp[a*3], 0 ); \
	ADD_VL( vhead, &valp[b*3], 1 ); \
	ADD_VL( vhead, &valp[c*3], 1 ); \
	ADD_VL( vhead, &valp[d*3], 1 );
d882 1
d884 11
a894 1
rt_arb_plot( rp, matp, vhead, dp )
d896 1
a896 1
register matp_t		matp;
d900 5
a904 1
	struct arb_internal	ai;
d906 11
a916 3
	if( rt_arb_import( &ai, rp, matp ) < 0 )  {
		rt_log("rt_arb_plot(%s): db import failure\n", dp->d_namep);
		return(-1);
d918 5
d924 4
a927 4
	ARB_FACE( ai.arbi_pt, 0, 1, 2, 3 );
	ARB_FACE( ai.arbi_pt, 4, 0, 3, 7 );
	ARB_FACE( ai.arbi_pt, 5, 4, 7, 6 );
	ARB_FACE( ai.arbi_pt, 1, 5, 6, 2 );
d955 4
a958 4
rt_arb_import( aip, rp, matp )
struct arb_internal	*aip;
union record		*rp;
register matp_t		matp;
d960 2
a962 2
	register fastf_t	*ip;
	register fastf_t	*op;
d966 2
d974 6
d984 1
a984 1
	 * Convert from vector to point notation for drawing.
d986 1
a986 1
	MAT4X3PNT( &aip->arbi_pt[0], matp, &vec[0] );
a987 2
	ip = &vec[1*3];
	op = &aip->arbi_pt[1*3];
d990 2
a991 4
		VADD2( work, &vec[0], ip );
		MAT4X3PNT( op, matp, work );
		ip += 3;
		op += ELEMENTS_PER_VECT;
d997 92
d1099 1
d1101 11
d1122 4
a1126 1
	struct arb_internal	ai;
d1133 11
a1143 3
	if( rt_arb_import( &ai, rp, mat ) < 0 )  {
		rt_log("rt_arb_tess(%s): import failure\n", dp->d_namep);
		return(-1);
d1145 6
d1155 1
a1155 1
	if( rt_arb_mk_planes( &pa, &ai ) < 0 )  return(-2);
d1195 1
a1195 1
		if(verts[i]) nmg_vertex_gv(verts[i], &ai.arbi_pt[3*i]);
@


9.24
log
@#include db.h must come before #include raytrace.h
for union record declaration
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.23 90/11/01 04:43:02 mike Exp $ (BRL)";
d52 2
d167 1
a167 1
		if( NEAR_ZERO(f,0.005) )  {
d239 1
a239 1
		if( ! NEAR_ZERO(f,0.005) )  {
@


9.23
log
@Added tolerance parameters to rt_mk_nmg_planeeqn() and
rt_mk_plane_3pts().
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.22 90/10/15 12:00:27 mike Exp $ (BRL)";
a46 1
#include "raytrace.h"
d49 1
@


9.22
log
@Changed from using hit_private to hit_surfno for surface indicator
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.21 90/10/06 02:05:06 mike Exp $ (BRL)";
d1020 1
a1020 1
		rt_mk_nmg_planeeqn( fu[i] );
d1039 4
d1044 2
a1045 1
rt_mk_nmg_planeeqn( fu )
d1047 1
d1076 1
a1076 1
	if (rt_mk_plane_3pts(plane, a->coord, b->coord, c->coord) < 0 ) {
d1082 1
d1084 1
a1084 1
	else if (plane[0] == 0.0 && plane[1] == 0.0 && plane[2] == 0.0) {
d1087 1
d1089 2
a1090 1
	else nmg_face_g( fu, plane);
@


9.21
log
@Converted seg structures to use doubly linked lists.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.20 90/05/21 13:03:37 mike Exp $ (BRL)";
d623 1
a623 1
		segp->seg_in.hit_private = (char *)iplane;
d626 1
a626 1
		segp->seg_out.hit_private = (char *)oplane;
d656 4
a659 4
                segp[i].seg_in.hit_dist = -INFINITY;        /* used as in */
                segp[i].seg_in.hit_private = (char *) -1;   /* used as iplane */
                segp[i].seg_out.hit_dist = INFINITY;        /* used as out */
                segp[i].seg_out.hit_private = (char *) -1;  /* used as oplane */
d682 1
a682 1
				   segp[i].seg_out.hit_private = (char *) j;
d688 1
a688 1
				   segp[i].seg_in.hit_private = (char *) j;
d713 2
a714 2
		if( segp[i].seg_in.hit_private == (char *) -1 ||
		    segp[i].seg_out.hit_private == (char *) -1 )  {
d737 1
a737 1
	int	h;
d740 1
a740 1
	h = (int)hitp->hit_private;
d779 3
a781 3
	int	h;
	LOCAL vect_t P_A;
	LOCAL fastf_t r;
d806 1
a806 1
	h = (int)hitp->hit_private;
d808 1
a808 1
	VSUB2( P_A, hitp->hit_point, arbp->arb_opt[h].arb_UVorig );
d810 2
a811 2
	uvp->uv_u = VDOT( P_A, arbp->arb_opt[h].arb_U );
	uvp->uv_v = 1.0 - VDOT( P_A, arbp->arb_opt[h].arb_V );
d819 2
a820 2
	uvp->uv_du = r * arbp->arb_opt[h].arb_Ulen;
	uvp->uv_dv = r * arbp->arb_opt[h].arb_Vlen;
@


9.20
log
@Fixed planeeqn to use circular next/last.
Also added more checking
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.19 90/05/18 07:25:01 butler Exp $ (BRL)";
d558 1
a558 1
 *  	segp	HIT
d560 4
a563 4
struct seg *
rt_arb_shot( stp, rp, ap )
struct soltab *stp;
register struct xray *rp;
d565 1
d603 1
a603 1
				return( SEG_NULL );	/* MISS */
d606 1
a606 1
			return( SEG_NULL );	/* MISS */
d612 1
a612 1
		return( SEG_NULL );	/* MISS */
d615 1
a615 1
		return( SEG_NULL );	/* MISS */
d620 1
a620 1
		GET_SEG( segp, ap->a_resource );
d627 1
a627 1
		return(segp);			/* HIT */
d629 1
a629 1
	/* NOTREACHED */
d660 1
a660 1
                segp[i].seg_next = SEG_NULL;
@


9.19
log
@Halfway converted to new double-linked-list structures ;-)
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: /m/cad/librt/RCS/g_arb.c,v 9.18 90/05/09 21:11:30 mike Exp $ (BRL)";
d1045 1
d1057 4
a1060 2
	eu_last = NMG_LIST_PLAST(edgeuse, eu);
	eu_next = NMG_LIST_PNEXT(edgeuse, eu);
d1062 8
a1069 4
	if (rt_mk_plane_3pts(plane,
	    eu->vu_p->v_p->vg_p->coord,
	    eu_last->vu_p->v_p->vg_p->coord,
	    eu_next->vu_p->v_p->vg_p->coord) < 0 ) {
d1071 3
a1073 9
		    eu->vu_p->v_p->vg_p->coord[X],
		    eu->vu_p->v_p->vg_p->coord[Y],
		    eu->vu_p->v_p->vg_p->coord[Z],
		    eu_last->vu_p->v_p->vg_p->coord[X],
		    eu_last->vu_p->v_p->vg_p->coord[Y],
		    eu_last->vu_p->v_p->vg_p->coord[Z],
		    eu_next->vu_p->v_p->vg_p->coord[X],
		    eu_next->vu_p->v_p->vg_p->coord[Y],
		    eu_next->vu_p->v_p->vg_p->coord[Z] );
@


9.18
log
@This version (a) takes advantage of point ordering to
usually get surface normals right to start with.
When an inside-out ARB8 is presented, not only is the
surface normal flipping done, but the vertex topology is reversed
as well.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.17 90/05/03 09:32:51 mike Locked $ (BRL)";
d975 1
a975 1
	s = m->r_p->s_p;
d1042 2
a1043 1
	struct edgeuse		*eu;
d1050 9
a1058 1
	eu = fu->lu_p->down.eu_p;
d1061 2
a1062 2
	    eu->last->vu_p->v_p->vg_p->coord,
	    eu->next->vu_p->v_p->vg_p->coord) < 0 ) {
d1067 6
a1072 6
		    eu->last->vu_p->v_p->vg_p->coord[X],
		    eu->last->vu_p->v_p->vg_p->coord[Y],
		    eu->last->vu_p->v_p->vg_p->coord[Z],
		    eu->next->vu_p->v_p->vg_p->coord[X],
		    eu->next->vu_p->v_p->vg_p->coord[Y],
		    eu->next->vu_p->v_p->vg_p->coord[Z] );
@


9.17
log
@This version "tessellates" any kind of ARB, and constructs good
topology and geometry for it.
The search for duplicated points is several times faster in this
version, although the conversion process was certainly painful!
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.16 90/05/03 03:55:30 mike Locked $ (BRL)";
d85 1
d98 1
d161 2
a163 1
		VCROSS( afp->peqn, ofp->arb_U, P_A );
d205 3
d979 8
a986 5
		vertp[0] = &verts[pa.pa_pindex[0][i]];
		vertp[1] = &verts[pa.pa_pindex[1][i]];
		vertp[2] = &verts[pa.pa_pindex[2][i]];
		if( pa.pa_npts[i] > 3 ) {
			vertp[3] = &verts[pa.pa_pindex[3][i]];
d988 7
a994 1
			vertp[3] = (struct vertex **)0;
d1014 2
d1017 4
@


9.16
log
@Separated out the code to convert points to planes.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.15 90/05/03 03:12:16 mike Locked $ (BRL)";
a51 2
void	arb_print();

d69 1
a69 2
	fastf_t	N[3];			/* Unit-length Normal (outward) */
	fastf_t	NdotA;			/* Normal dot A */
a79 1
#define ARB_MAXPTS	4		/* All we need are 4 points */
a80 1
	point_t		pa_points[ARB_MAXPTS];	/* Actual points on plane */
a81 1
	int		pa_npts;	/* number of points on plane */
d83 2
d88 1
a92 2
HIDDEN void	arb_add_pt();

d101 1
a101 1
} arb_info[6] = {
d111 1
a111 1
 *			A R B _ M K _ P L A N E S
d113 134
d255 1
a255 1
arb_mk_planes( pap, aip )
a259 1
	LOCAL vect_t	work;		/* Vector addition work area */
d265 1
d270 1
a270 1
	 *  needed for arb_add_pt, which demands a point inside the solid.
d284 31
d317 3
a319 1
		pap->pa_npts = 0;
d321 1
a321 1
			register pointp_t point;
d323 7
a329 1
			point = &aip->arbi_pt[arb_info[i].ai_sub[j]*ELEMENTS_PER_VECT];
d332 1
a332 1
			 * as an earlier point
d335 4
a338 5
			for( k=0; k < pap->pa_npts; k++ )  {
				VSUB2( work, point, pap->pa_points[k] );
				if( MAGSQ( work ) < 0.005 )  {
					/* the same -- skip it */
					goto next_pt;
d341 7
a347 1
			VMOVE( pap->pa_points[pap->pa_npts], point );
d349 1
a349 4
			arb_add_pt(
				point,
				arb_info[i].ai_title, pap );
next_pt:		;
d352 1
a352 1
		if( pap->pa_npts < 3 )  {
d370 1
d382 1
a382 1
 *			A R B _ S E T U P
d392 1
a392 1
arb_setup( stp, rec, rtip, uv_wanted )
d398 3
a400 3
	register int	i;
	struct arb_internal ai;
	struct prep_arb	pa;
d404 1
a404 1
		i = arb_import( &ai, rec, stp->st_pathmat );
d407 1
a407 1
		i = arb_import( &ai, rec, stp->st_pathmat );
d410 1
a410 1
		rt_log("arb_setup(%s): db import failure\n", stp->st_name);
d416 1
d418 1
a418 1
	if( arb_mk_planes( &pa, &ai ) < 0 )  {
d489 1
a489 1
 *			A R B _ A D D _ P T
a490 131
 *  Add another point to a struct arb_specific, checking for unique pts.
 *  The first two points are easy.  The third one triggers most of the
 *  plane calculations, and forth and subsequent ones are merely
 *  checked for validity.
 *
 *  Static externs are used to build up the state of the current faces.
 */
HIDDEN void
arb_add_pt( point, title, pap )
register pointp_t point;
char		*title;
struct prep_arb	*pap;
{
	register int	i;
	LOCAL vect_t	work;
	LOCAL vect_t	P_A;		/* new point minus A */
	FAST fastf_t	f;
	register struct aface	*afp;
	register struct oface	*ofp;

	afp = &pap->pa_face[pap->pa_faces];
	ofp = &pap->pa_opt[pap->pa_faces];
	i = pap->pa_npts++;		/* Current point number */

	/* The first 3 points are treated differently */
	switch( i )  {
	case 0:
		VMOVE( afp->A, point );
		if( pap->pa_doopt )  {
			VMOVE( ofp->arb_UVorig, point );
		}
		return;					/* OK */
	case 1:
		VSUB2( ofp->arb_U, point, afp->A );	/* B-A */
		f = MAGNITUDE( ofp->arb_U );
		ofp->arb_Ulen = f;
		f = 1/f;
		VSCALE( ofp->arb_U, ofp->arb_U, f );
		/* Note that arb_U is used to build N, below */
		return;					/* OK */
	case 2:
		VSUB2( P_A, point, afp->A );	/* C-A */
		/* Check for co-linear, ie, |(B-A)x(C-A)| ~= 0 */
		VCROSS( afp->N, ofp->arb_U, P_A );
		f = MAGNITUDE( afp->N );
		if( NEAR_ZERO(f,0.005) )  {
			pap->pa_npts--;
			return;				/* BAD */
		}
		f = 1/f;
		VSCALE( afp->N, afp->N, f );

		if( pap->pa_doopt )  {
			/*
			 * Get vector perp. to AB in face of plane ABC.
			 * Scale by projection of AC, make this V.
			 */
			VCROSS( work, afp->N, ofp->arb_U );
			VUNITIZE( work );
			f = VDOT( work, P_A );
			VSCALE( ofp->arb_V, work, f );
			f = MAGNITUDE( ofp->arb_V );
			ofp->arb_Vlen = f;
			f = 1/f;
			VSCALE( ofp->arb_V, ofp->arb_V, f );

			/* Check for new Ulen */
			VSUB2( P_A, point, ofp->arb_UVorig );
			f = VDOT( P_A, ofp->arb_U );
			if( f > ofp->arb_Ulen ) {
				ofp->arb_Ulen = f;
			} else if( f < 0.0 ) {
				VJOIN1( ofp->arb_UVorig, ofp->arb_UVorig, f,
					ofp->arb_U );
				ofp->arb_Ulen += (-f);
			}
		}

		/*
		 *  If C-A is clockwise from B-A, then the normal
		 *  points inwards, so we need to fix it here.
		 */
		VSUB2( work, afp->A, pap->pa_center );
		f = VDOT( work, afp->N );
		if( f < 0.0 )  {
			VREVERSE(afp->N, afp->N);	/* "fix" normal */
		}
		afp->NdotA = VDOT( afp->N, afp->A );
		return;					/* OK */
	default:
		/* Merely validate 4th and subsequent points */
		if( pap->pa_doopt )  {
			VSUB2( P_A, point, ofp->arb_UVorig );
			/* Check for new Ulen, Vlen */
			f = VDOT( P_A, ofp->arb_U );
			if( f > ofp->arb_Ulen ) {
				ofp->arb_Ulen = f;
			} else if( f < 0.0 ) {
				VJOIN1( ofp->arb_UVorig, ofp->arb_UVorig, f,
					ofp->arb_U );
				ofp->arb_Ulen += (-f);
			}
			f = VDOT( P_A, ofp->arb_V );
			if( f > ofp->arb_Vlen ) {
				ofp->arb_Vlen = f;
			} else if( f < 0.0 ) {
				VJOIN1( ofp->arb_UVorig, ofp->arb_UVorig, f,
					ofp->arb_V );
				ofp->arb_Vlen += (-f);
			}
		}

		VSUB2( P_A, point, afp->A );
		VUNITIZE( P_A );		/* Checking direction only */
		f = VDOT( afp->N, P_A );
		if( ! NEAR_ZERO(f,0.005) )  {
			/* Non-planar face */
			rt_log("arb(%s): face %s non-planar, dot=%g\n",
				pap->pa_name, title, f );
#ifdef CONSERVATIVE
			pap->pa_npts--;
			return;				/* BAD */
#endif
		}
		return;					/* OK */
	}
}

/*
 *  			A R B _ P R E P
 *
d498 1
a498 1
arb_prep( stp, rec, rtip )
d503 1
a503 1
	return( arb_setup( stp, rec, rtip, 0 ) );
d507 1
a507 1
 *  			A R B _ P R I N T
d510 1
a510 1
arb_print( stp )
d526 1
a526 2
		VPRINT( "Normal", afp->N );
		rt_log( "N.A = %g\n", afp->NdotA );
d540 1
a540 1
 *			A R B _ S H O T
d555 1
a555 1
arb_shot( stp, rp, ap )
d576 2
a577 2
		dxbdn = VDOT( afp->N, rp->r_pt ) - afp->NdotA;
		if( (dn = -VDOT( afp->N, rp->r_dir )) < -SQRT_SMALL_FASTF )  {
d603 1
a603 1
		rt_log("arb_shoot(%s): 1 hit => MISS\n",
d627 1
a627 1
 *			A R B _ V S H O T
d632 1
a632 1
arb_vshot( stp, rp, segp, n, resp)
d668 3
a670 3
			dxbdn = VDOT( arbp->arb_face[j].N, rp[i]->r_pt ) -
				arbp->arb_face[j].NdotA;
			if( (dn = -VDOT( arbp->arb_face[j].N, rp[i]->r_dir )) <
d718 1
a718 1
 *  			A R B _ N O R M
d723 1
a723 1
arb_norm( hitp, stp, rp )
d734 1
a734 1
	VMOVE( hitp->hit_normal, arbp->arb_face[h].N );
d738 1
a738 1
 *			A R B _ C U R V E
d745 1
a745 1
arb_curve( cvp, hitp, stp )
d756 1
a756 1
 *  			A R B _ U V
d764 1
a764 1
arb_uv( ap, stp, hitp, uvp )
d786 1
a786 1
			ret = arb_setup(stp, (union record *)0, ap->a_rt_i, 1);
d791 1
a791 1
			rt_log("arb_uv(%s) dyanmic setup failure st_specific=x%x, optp=x%x\n",
d817 1
a817 1
 *			A R B _ F R E E
d820 1
a820 1
arb_free( stp )
d838 1
a838 1
 *  			A R B _ P L O T
d845 1
a845 1
arb_plot( rp, matp, vhead, dp )
d853 2
a854 2
	if( arb_import( &ai, rp, matp ) < 0 )  {
		rt_log("arb_plot(%s): db import failure\n", dp->d_namep);
d866 1
a866 1
 *			A R B _ C L A S S
d869 1
a869 1
arb_class()
d875 1
a875 1
 *			A R B _ I M P O R T
d889 1
a889 1
arb_import( aip, rp, matp )
d902 1
a902 1
		rt_log("arb_import: defective record, id=x%x\n", rp->u_id);
d927 1
a927 1
 *			A R B _ T E S S
d938 1
a938 1
arb_tess( r, m, rp, mat, dp )
d941 2
a942 2
register union record	*rp;
register mat_t		mat;
d944 3
d950 1
d952 1
a952 1
	struct faceuse		*outfaceuses[6];
a954 3
	int			face;
	plane_t			plane;
	int			j;
d956 2
a957 2
	if( arb_import( &ai, rp, mat ) < 0 )  {
		rt_log("arb_tess(%s): import failure\n", dp->d_namep);
d960 5
a965 1
	for( i=0; i<6; i++ )  outfaceuses[i] = (struct faceuse *)0;
d971 20
a990 9
	/*  List the vertices for each face in clockwise order */
	for( i=0; i<6; i++ )  {
		register struct arb_info	*aip = &arb_info[i];

		vertp[0] = &verts[aip->ai_sub[0]];
		vertp[1] = &verts[aip->ai_sub[1]];
		vertp[2] = &verts[aip->ai_sub[2]];
		vertp[3] = &verts[aip->ai_sub[3]];
		outfaceuses[i] = nmg_cmface(s, vertp, 4);
d998 2
a999 2
	for (i=0 ; i < 6 ; ++i) {
		if(outfaceuses[i])  rt_mk_nmg_planeeqn( outfaceuses[i] );
@


9.15
log
@Removed debugging
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.14 90/05/02 05:43:24 mike Locked $ (BRL)";
d86 1
d91 1
d93 1
d116 1
a116 13
 *  			A R B _ P R E P
 */
int
arb_prep( stp, rec, rtip )
struct soltab	*stp;
union record	*rec;
struct rt_i	*rtip;
{
	return( arb_setup( stp, rec, rtip, 0 ) );
}

/*
 *			A R B _ S E T U P
d118 3
d123 1
a123 1
 *	!0	failure
d125 4
a128 5
arb_setup( stp, rec, rtip, uv_wanted )
struct soltab	*stp;
union record	*rec;
struct rt_i	*rtip;
int		uv_wanted;
a136 2
	struct arb_internal ai;
	struct prep_arb	pa;
a137 14
	if( rec == (union record *)0 )  {
		rec = db_getmrec( rtip->rti_dbip, stp->st_dp );
		i = arb_import( &ai, rec, stp->st_pathmat );
		rt_free( (char *)rec, "arb record" );
	} else {
		i = arb_import( &ai, rec, stp->st_pathmat );
	}
	if( i < 0 )  {
		rt_log("arb_setup(%s): db import failure\n", stp->st_name);
		return(-1);		/* BAD */
	}

	pa.pa_doopt = uv_wanted;

d147 1
a147 1
	op = &ai.arbi_pt[0*ELEMENTS_PER_VECT];
d153 1
a153 1
	VSCALE( stp->st_center, sum, 0.125 );	/* sum/8 */
d155 1
a155 1
	pa.pa_faces = 0;
d157 1
a157 1
		pa.pa_npts = 0;
d161 1
a161 1
			point = &ai.arbi_pt[arb_info[i].ai_sub[j]*ELEMENTS_PER_VECT];
d167 2
a168 2
			for( k=0; k < pa.pa_npts; k++ )  {
				VSUB2( work, point, pa.pa_points[k] );
d174 1
a174 1
			VMOVE( pa.pa_points[pa.pa_npts], point );
d178 1
a178 1
				stp, arb_info[i].ai_title, &pa );
d182 1
a182 1
		if( pa.pa_npts < 3 )  {
d187 1
a187 1
		if( uv_wanted )  {
d190 1
a190 1
			ofp = &pa.pa_opt[pa.pa_faces];
d200 1
a200 1
		pa.pa_faces++;
d202 1
a202 1
	if( pa.pa_faces < 4  || pa.pa_faces > 6 )  {
d204 2
a205 2
			stp->st_name, pa.pa_faces);
		return(1);			/* Error */
d207 2
d210 40
d271 1
d293 19
a311 5
	op = &ai.arbi_pt[0];
#	include "noalias.h"
	for( i=0; i< 8; i++ ) {
		VMINMAX( stp->st_min, stp->st_max, op );
		op += ELEMENTS_PER_VECT;
a312 8
	VADD2SCALE( stp->st_center, stp->st_min, stp->st_max, 0.5 );
	VSUB2SCALE( work, stp->st_max, stp->st_min, 0.5 );

	f = work[X];
	if( work[Y] > f )  f = work[Y];
	if( work[Z] > f )  f = work[Z];
	stp->st_aradius = f;
	stp->st_bradius = MAGNITUDE(work);
d327 1
a327 1
arb_add_pt( point, stp, title, pap )
a328 1
struct soltab	*stp;
d332 4
a335 4
	register int i;
	LOCAL vect_t work;
	LOCAL vect_t P_A;		/* new point - A */
	FAST fastf_t f;
d401 1
a401 1
		VSUB2( work, afp->A, stp->st_center );
d437 1
a437 1
				stp->st_name, title, f );
d445 18
@


9.14
log
@Improved error blathering
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.13 90/04/28 02:08:15 mike Locked $ (BRL)";
d886 1
a886 1
#if 1
a890 8

#if 0
		rt_log("\ni:%d\n", i);
		for (j=0 ; j < 8 ; ++j)
			rt_log("verts[%d]: %8x\n", j, verts[j]);
		for (j=0 ; j < 4 ; ++j)
			rt_log("vertp[%d]:(%8x)->%8x\n", j, vertp[j], *vertp[j]);
#endif
a891 12
#else
		struct vertex	*vertlist[4];
		vertlist[0] = verts[aip->ai_sub[0]];
		vertlist[1] = verts[aip->ai_sub[1]];
		vertlist[2] = verts[aip->ai_sub[2]];
		vertlist[3] = verts[aip->ai_sub[3]];
		outfaceuses[i] = nmg_cface(s, vertlist, 4);
		verts[aip->ai_sub[0]] = vertlist[0];
		verts[aip->ai_sub[1]] = vertlist[1];
		verts[aip->ai_sub[2]] = vertlist[2];
		verts[aip->ai_sub[3]] = vertlist[3];
#endif
a902 5
#if 0
	/* Glue the edges of different outward pointing face uses together */
	nmg_gluefaces( outfaceuses, 6 );
#endif

a904 14

#if 0
	{
		FILE *file;
		if( (file = fopen("mged.pl", "w")) == NULL )  {
			perror("mged.pl");
		} else {
			nmg_pl_r( file, *r );
			fclose( file );
			printf("wrote mged.pl\n");
		}
	}
#endif

@


9.13
log
@removed calls to nmg_ck_closed_surf from geometry module tesselators
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.12 90/04/27 02:15:53 butler Locked $ (BRL)";
d972 12
a983 2
	    eu->next->vu_p->v_p->vg_p->coord)) {
		rt_log("rt_mk_nmg_planeeqn(): rt_mk_plane_3pts failed\n");
d987 1
@


9.12
log
@Improved error checking in rt_mk_nmg_planeeqn
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.11 90/04/26 00:45:39 mike Locked $ (BRL)";
a942 1
	nmg_ck_closed_surf(s);		/* debug */
@


9.11
log
@Added some optional debugging.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.10 90/03/15 01:06:22 butler Locked $ (BRL)";
d949 2
d959 2
a960 2
rt_mk_nmg_planeeqn( ofp )
struct faceuse	*ofp;
d965 9
a973 4
	eu = ofp->lu_p->down.eu_p;
	if (rt_mk_plane_3pts(plane, eu->vu_p->v_p->vg_p->coord,
				eu->last->vu_p->v_p->vg_p->coord,
				eu->next->vu_p->v_p->vg_p->coord)) {
d979 1
a979 1
	else nmg_face_g( ofp, plane);
@


9.10
log
@Various improvements.  cface() works, cmface() still has trouble.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.9 90/03/14 22:36:39 mike Locked $ (BRL)";
d870 1
d892 7
d931 1
d942 1
@


9.9
log
@Changed to nmg_cmface().
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.8 90/03/14 21:21:17 mike Locked $ (BRL)";
a867 1
	struct edgeuse		*eu, *eu2;
d876 1
a878 1
	/* Build all 6 faces of the ARB */
d882 8
a889 6
	/* make "top" */
	vertp[0] = &verts[0];
	vertp[1] = &verts[1];
	vertp[2] = &verts[2];
	vertp[3] = &verts[3];
	outfaceuses[0] = nmg_cmface(s, vertp, 4);
d891 14
a904 6
	/* make "bottom", going the other way around */
	vertp[0] = &verts[7];
	vertp[1] = &verts[6];
	vertp[2] = &verts[5];
	vertp[3] = &verts[4];
	outfaceuses[1] = nmg_cmface(s, vertp, 4);
a905 29
	/* make sure that vertices are listed in clockwise fashion when
	 * viewed from the outside of the face.  In this way the face
	 * geometry will be properly computed.
	 * ????? XXX
	 */
	vertp[0] = &verts[0];
	vertp[1] = &verts[1];
	vertp[2] = &verts[5];
	vertp[3] = &verts[4];
	outfaceuses[2] = nmg_cmface(s, vertp, 4);

	vertp[0] = &verts[0];
	vertp[1] = &verts[4];
	vertp[2] = &verts[7];
	vertp[3] = &verts[3];
	outfaceuses[3] = nmg_cmface(s, vertp, 4);

	vertp[0] = &verts[2];
	vertp[1] = &verts[6];
	vertp[2] = &verts[5];
	vertp[3] = &verts[1];
	outfaceuses[4] = nmg_cmface(s, vertp, 4);

	vertp[0] = &verts[2];
	vertp[1] = &verts[3];
	vertp[2] = &verts[7];
	vertp[3] = &verts[6];
	outfaceuses[5] = nmg_cmface(s, vertp, 4);

d908 1
a908 1
		nmg_vertex_gv(verts[i], &ai.arbi_pt[3*i]);
d912 1
a912 13
		eu = outfaceuses[i]->lu_p->down.eu_p;
		if (rt_mk_plane_3pts(plane, eu->vu_p->v_p->vg_p->coord,
					eu->next->vu_p->v_p->vg_p->coord,
					eu->last->vu_p->v_p->vg_p->coord)) {
			rt_log("At %d in %s\n", __LINE__, __FILE__);
			rt_bomb("cannot make plane equation\n");
		}
		else if (plane[0] == 0.0 && plane[1] == 0.0 && plane[2] == 0.0) {
			rt_log("Bad plane equation from rt_mk_plane_3pts at %d in %s\n",
					__LINE__, __FILE__);
			rt_bomb("BAD Plane Equation");
		}
		else nmg_face_g(outfaceuses[i], plane);
d915 5
d923 12
d936 27
@


9.8
log
@Changed calling sequence to tessellation routines.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.7 90/03/14 15:05:27 mike Locked $ (BRL)";
d95 5
a99 1
/* Layout of arb in input record */
d104 2
a105 2
	{ "1234", 3, 2, 1, 0 },
	{ "8765", 4, 5, 6, 7 },
d867 1
a867 1
	struct vertex		*vertlist[4];
d884 5
a888 1
	outfaceuses[0] = nmg_cface(s, verts, 4);
d891 5
a895 3
	for( i=0; i<4; i++ )  vertlist[i] = (struct vertex *)0;
	outfaceuses[1] = nmg_cface(s, vertlist, 4);
	for( i=0; i<4; i++ )  verts[8-1-i] = vertlist[i];
d902 5
a906 5
	vertlist[0] = verts[0];
	vertlist[1] = verts[1];
	vertlist[2] = verts[5];
	vertlist[3] = verts[4];
	outfaceuses[2] = nmg_cface(s, vertlist, 4);
d908 5
a912 5
	vertlist[0] = verts[0];
	vertlist[1] = verts[4];
	vertlist[2] = verts[7];
	vertlist[3] = verts[3];
	outfaceuses[3] = nmg_cface(s, vertlist, 4);
d914 5
a918 5
	vertlist[0] = verts[2];
	vertlist[1] = verts[6];
	vertlist[2] = verts[5];
	vertlist[3] = verts[1];
	outfaceuses[4] = nmg_cface(s, vertlist, 4);
d920 5
a924 5
	vertlist[0] = verts[2];
	vertlist[1] = verts[3];
	vertlist[2] = verts[7];
	vertlist[3] = verts[6];
	outfaceuses[5] = nmg_cface(s, vertlist, 4);
d947 2
a948 2
	/* Glue the edges of different outward pointing face uses together */
	nmg_gluefaces( outfaceuses, 6 );
@


9.7
log
@Changed type of st_specific to genptr_t
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.6 90/03/05 23:57:29 mike Locked $ (BRL)";
d757 1
a757 1
void
d768 1
a768 1
		return;
d775 1
d845 4
d850 4
a853 3
void
arb_tess( s, rp, mat, dp )
struct shell		*s;
d858 1
d870 1
a870 1
		return;
d876 2
d940 1
a940 1
	return;
@


9.6
log
@A neater way of waking the top and bottom faces
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.5 90/02/28 01:53:42 mike Locked $ (BRL)";
d240 1
a240 1
			stp->st_specific = (int *)arbp;
@


9.5
log
@Converted to new NMG library
@
text
@d2 1
a2 1
 *  			A R B . C
d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.4 90/02/27 21:46:42 mike Locked $ (BRL)";
d870 2
a871 5
	/* make top */
	outfaceuses[0] = nmg_cface(s, (struct vertex **)NULL, 4);
	for (eu = outfaceuses[0]->lu_p->down.eu_p->next, i = 0 ;
	    i < 4 ; ++i, eu = eu->next)
		verts[i] = eu->vu_p->v_p;
d873 4
a876 5
	/* make bottom */
	outfaceuses[1] = nmg_cface(s, (struct vertex **)NULL, 4);
	for (eu = outfaceuses[1]->lu_p->down.eu_p->next, i = 7 ;
	    i > 3 ; --i, eu = eu->next)
		verts[i] = eu->vu_p->v_p;
@


9.4
log
@Temporarily disabled nmgs, fixed a register type.
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.3 89/12/09 01:36:48 mike Locked $ (BRL)";
a851 1
#if 0
d853 2
a854 1
	struct edgeuse		*eu;
d856 4
a859 1
	register int		i;
a868 7
	if(
	    arb_t2( s, verts, 0, 1, 2, 3 ) < 0 ||
	    arb_t2( s, verts, 3, 7, 4, 0 ) < 0 ||
	    arb_t2( s, verts, 4, 7, 6, 5 ) < 0 ||
	    arb_t2( s, verts, 1, 5, 6, 2 ) < 0 ||
	    arb_t2( s, verts, 0, 1, 5, 4 ) < 0 ||
	    arb_t2( s, verts, 2, 3, 7, 6 ) < 0
d870 5
a874 4
	)  {
	    	rt_log("arb_tess(%s): NMG failure\n", dp->d_namep);
	    	return;
	}
d876 5
a880 17
	/* Now, associate some geometry with the vertices */
	for( i=0; i < 8; i++ )  {
		if( !verts[i] )  continue;
		if( verts[i]->magic != NMG_VERTEX_MAGIC )  {
			rt_log("arb_tess: bad verts magic\n");
			continue;
		}
		if( nmg_vertex_gv( verts[i], &ai.arbi_pt[3*i] ) ) {
			rt_log("arb_tess: nmg_vertex_gv fail\n");
			return;
		}
	}
	return;
#else
	nul_tess( s, rp, mat, dp );
#endif
}
d882 10
a891 12
#if 0
/*
 *			A R B _ T 2
 *
 *  XXX need to see if an edge already exists between two vertices.
 */
HIDDEN int
arb_t2( s, verts, a, b, c, d )
struct shell	*s;
struct vertex	*verts[];
int		a, b, c, d;
{
d893 5
a897 9
	nmg_mf( nmg_mlv(s) );
	if( verts[a] == 0 )  {
		/* First vertex better exist on all but 1st call! */
		if( nmg_mkface1(s) ) goto fail;
		verts[a] = s->downptr.fu_p->lu_p->eu_p->vu_p->v_p;
	} else {
		if( nmg_mkfaceN(s, verts[a]) ) goto fail;
		/* reused verts[a] */
	}
d899 5
a903 6
	if( verts[b] )  {
		if( nmg_insfacev( verts[b], s->downptr.fu_p->lu_p->eu_p ) ) goto fail;
	} else {
		if( nmg_newfacev(s->downptr.fu_p->lu_p->eu_p) ) goto fail;
		verts[b] = s->downptr.fu_p->lu_p->eu_p->vu_p->v_p;
	}
d905 25
a929 5
	if( verts[c] )  {
		if( nmg_insfacev( verts[c], s->downptr.fu_p->lu_p->eu_p ) ) goto fail;
	} else {
		if( nmg_newfacev(s->downptr.fu_p->lu_p->eu_p) ) goto fail;
		verts[c] = s->downptr.fu_p->lu_p->eu_p->vu_p->v_p;
d932 4
a935 9
	if( verts[d] )  {
		if( nmg_insfacev( verts[d], s->downptr.fu_p->lu_p->eu_p ) ) goto fail;
	} else {
		if( nmg_newfacev(s->downptr.fu_p->lu_p->eu_p) ) goto fail;
		verts[d] = s->downptr.fu_p->lu_p->eu_p->vu_p->v_p;
	}
	return(0);			/* OK */
fail:
	return(-1);
a936 1
#endif
@


9.3
log
@Added more error checking
@
text
@d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.2 89/10/10 16:15:30 mike Locked $ (BRL)";
d846 1
a846 1
arb_tess( s, rp, matp, dp )
d849 1
a849 1
register matp_t		matp;
d852 1
d858 1
a858 1
	if( arb_import( &ai, rp, matp ) < 0 )  {
d892 3
d897 1
d910 1
d944 1
@


9.2
log
@Added explicit arb_import() routine.
Added arb_tess() as well.
@
text
@d7 19
d40 1
a40 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 9.1 89/05/19 05:56:01 mike Rel3_5 $ (BRL)";
d54 1
a54 1
/* The internal (in memory form of an ARM -- 8 points in space */
d59 1
a59 23
/*
 *			Ray/ARB Intersection
 *
 *  An ARB is a convex volume bounded by 4 (pyramid), 5 (wedge), or 6 (box)
 *  planes.  This analysis depends on the properties of objects with convex
 *  hulls.  Let the ray in question be defined such that any point X on the
 *  ray may be expressed as X = P + k D.  Intersect the ray with each of the
 *  planes bounding the ARB as discussed above, and record the values of the
 *  parametric distance k along the ray.
 *
 *  With outward pointing normal vectors,
 *  note that the ray enters the half-space defined by a plane when D cdot N <
 *  0, is parallel to the plane when D cdot N = 0, and exits otherwise.  Find
 *  the entry point farthest away from the starting point bold P, i.e.  it has
 *  the largest value of k among the entry points.
 *  The ray enters the solid at this point.
 *  Similarly, find the exit point closest to point P, i.e. it has
 *  the smallest value of k among the exit points.  The ray exits the solid
 *  here.
 *
 *  This algorithm is due to Cyrus & Beck, USAF.
 */

d150 4
a153 1
	if( i < 0 )  return(-1);		/* BAD */
d766 4
a769 1
	(void)arb_import( &ai, rp, matp );
d814 1
a814 1
		rt_log("arb_import: defective record\n");
@


9.1
log
@Release_3.5
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 8.19 89/04/29 09:18:31 mike Exp $ (BRL)";
d29 1
d35 5
a87 1
	fastf_t		pa_vec[3*8];	/* Original points */
d143 1
d148 1
a148 2
		/* Convert from database to internal format */
		rt_fastf_float( pa.pa_vec, rec->s.s_values, 8 );
d151 1
a151 2
		/* Convert from database to internal format */
		rt_fastf_float( pa.pa_vec, rec->s.s_values, 8 );
d153 1
a157 21
	 * Process an ARB8, which is represented as a vector
	 * from the origin to the first point, and 7 vectors
	 * from the first point to the remaining points.
	 *
	 * Convert from vector to point notation IN PLACE
	 * by rotating vectors and adding base vector.
	 */
	VSETALL( sum, 0 );
	op = &pa.pa_vec[1*ELEMENTS_PER_VECT];
#	include "noalias.h"
	for( i=1; i<8; i++ )  {
		VADD2( work, &pa.pa_vec[0], op );
		MAT4X3PNT( op, stp->st_pathmat, work );
		VADD2( sum, sum, op );			/* build the sum */
		op += ELEMENTS_PER_VECT;
	}
	MAT4X3PNT( work, stp->st_pathmat, pa.pa_vec );	/* first point */
	VMOVE( pa.pa_vec, work );			/* 1st: IN PLACE*/
	VADD2( sum, sum, pa.pa_vec );			/* sum=0th element */

	/*
a163 1
	 *  The actual work is done in the loop, above.
d165 7
d180 1
a180 1
			point = &pa.pa_vec[arb_info[i].ai_sub[j]*ELEMENTS_PER_VECT];
d269 1
a269 1
	op = &pa.pa_vec[0];
d332 1
a332 1
		/* Check for co-linear, ie, (B-A)x(C-A) == 0 */
d753 3
a755 3
 * Plot an ARB, which is represented as a vector
 * from the origin to the first point, and 7 vectors
 * from the first point to the remaining points.
d764 39
d806 2
a807 3
	static vect_t		work;
	static fastf_t		vec[3*8];
	static fastf_t		points[3*8];
d809 6
d821 1
a821 1
	MAT4X3PNT( &points[0], matp, &vec[0] );
d824 1
a824 1
	op = &points[1*3];
d832 2
d835 53
a887 4
	ARB_FACE( points, 0, 1, 2, 3 );
	ARB_FACE( points, 4, 0, 3, 7 );
	ARB_FACE( points, 5, 4, 7, 6 );
	ARB_FACE( points, 1, 5, 6, 2 );
d890 10
a899 2
int
arb_class()
d901 33
a933 1
	return(0);
@


8.19
log
@Prevent multi-processor races in dynamic UV-parameter calculation.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 8.18 89/04/28 00:28:40 mike Locked $ (BRL)";
@


8.18
log
@Added debugging print on DEBUG_SOLIDS when doing lazy U-V parameter
preparation at runtime.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 8.17 89/04/26 20:02:04 mike Locked $ (BRL)";
d257 7
a263 1
			arbp->arb_opt = (struct oface *)rt_malloc(
d265 1
a265 1
			bcopy( (char *)pa.pa_opt, (char *)arbp->arb_opt,
d267 1
d700 2
d703 3
a705 2
		 * PARALLEL: This might want to be interlocked on res_model.
		 * The only harm now is wasting some memory, though. XXX
d707 7
a713 2
		if( arb_setup( stp, (union record *)0, ap->a_rt_i, 1 ) != 0 ||
		    arbp->arb_opt == (struct oface *)0 )  {
@


8.17
log
@Still futher optimized version -- use bcopy() rather than looping.
Better on vector machines.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 8.16 89/04/26 16:12:00 mike Locked $ (BRL)";
d693 4
d704 1
@


8.16
log
@Alliant 3.0 cc bug struck in the arb_opt stuff as well.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 8.15 89/04/25 19:05:51 mike Locked $ (BRL)";
d253 2
a254 9
		{
			register struct aface	*aip, *aop;
#			include "noalias.h"
			aip = &pa.pa_face[pa.pa_faces-1];
			aop = &arbp->arb_face[pa.pa_faces-1];
			for( i=pa.pa_faces-1; i>=0; i--, aip--, aop-- )  {
				*aop = *aip;	/* struct copy */
			}
		}
a256 1
			register struct oface	*oip, *oop;
d259 2
a260 5
#			include "noalias.h"
			oip = &pa.pa_opt[pa.pa_faces-1];
			oop = &arbp->arb_opt[pa.pa_faces-1];
			for( i = pa.pa_faces-1; i>=0; i--, oip--, oop-- )
				*oop = *oip;	/* struct copy */
@


8.15
log
@Oops, removed stray printfs.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 8.14 89/04/25 18:48:56 mike Locked $ (BRL)";
d264 1
d268 4
a271 2
			for( i = pa.pa_faces-1; i>=0; i-- )
				arbp->arb_opt[i] = pa.pa_opt[i];	/* struct copy */
@


8.14
log
@Code simplified (and sped up) to bypass Alliant CC bug.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 8.13 89/04/17 17:09:50 mike Locked $ (BRL)";
a328 2
VPRINT("pt", point );
VPRINT(" A", afp->A);
@


8.13
log
@Calling sequence to xxx_prep() shortened from 6 to 3 args.
Database conversion moved into prep routines.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 8.12 89/04/17 16:02:54 mike Locked $ (BRL)";
d32 1
d195 1
d244 1
a244 1
		register struct arb_specific *arbp;
d253 9
a261 2
		for( i=0; i < pa.pa_faces; i++ )
			arbp->arb_face[i] = pa.pa_face[i];	/* struct copy */
d266 2
a267 1
			for( i=0; i < pa.pa_faces; i++ )
d329 2
d486 5
a490 5
	register struct arb_specific *arbp =
		(struct arb_specific *)stp->st_specific;
	LOCAL int iplane, oplane;
	LOCAL fastf_t	in, out;	/* ray in/out distances */
	register int j;
d497 1
a497 1
	for( j = arbp->arb_nmfaces-1; j >= 0; j-- )  {
d502 2
a503 2
		dxbdn = VDOT( arbp->arb_face[j].N, rp->r_pt ) - arbp->arb_face[j].NdotA;
		if( (dn = -VDOT( arbp->arb_face[j].N, rp->r_dir )) < -SQRT_SMALL_FASTF )  {
@


8.12
log
@This version does not do the UV stuff at first,
but goes back on first use of arb_uv() and re-preps
for just that solid.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 8.11 89/04/17 12:48:34 mike Locked $ (BRL)";
d109 1
a109 2
arb_prep( Xvec, stp, Xmat, rec, rtip, dp )
fastf_t		*Xvec;
a110 1
matp_t		Xmat;
a112 1
struct directory *dp;
@


8.11
log
@Moved prep variables into special data structure.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: g_arb.c,v 8.10 89/04/14 00:51:50 mike Locked $ (BRL)";
d57 5
a61 5
	float	arb_UVorig[3];		/* origin of UV coord system */
	float	arb_U[3];		/* unit U vector (along B-A) */
	float	arb_V[3];		/* unit V vector (perp to N and U) */
	float	arb_Ulen;		/* length of U basis (for du) */
	float	arb_Vlen;		/* length of V basis (for dv) */
d81 4
a84 4
	fastf_t	pa_vec[3*8];		/* Original points */
	point_t	pa_points[ARB_MAXPTS];	/* Actual points on plane */
	int	pa_npts;		/* number of points on plane */
	int	pa_faces;		/* Number of faces done so far */
d87 1
d117 16
d142 9
a150 2
	/* Convert from database to internal format */
	rt_fastf_float( pa.pa_vec, rec->s.s_values, 8 );
d152 2
a185 2
	stp->st_specific = (int *) 0;

d217 2
a218 5
		/* Scale U and V basis vectors by the inverse of Ulen and Vlen */
		pa.pa_opt[pa.pa_faces].arb_Ulen = 1.0 / pa.pa_opt[pa.pa_faces].arb_Ulen;
		pa.pa_opt[pa.pa_faces].arb_Vlen = 1.0 / pa.pa_opt[pa.pa_faces].arb_Vlen;
		VSCALE( pa.pa_opt[pa.pa_faces].arb_U, pa.pa_opt[pa.pa_faces].arb_U, pa.pa_opt[pa.pa_faces].arb_Ulen );
		VSCALE( pa.pa_opt[pa.pa_faces].arb_V, pa.pa_opt[pa.pa_faces].arb_V, pa.pa_opt[pa.pa_faces].arb_Vlen );
d220 10
d246 7
a252 4
		arbp = (struct arb_specific *)rt_malloc(
			sizeof(struct arb_specific) +
			sizeof(struct aface) * (pa.pa_faces - 4),
			"arb_specific" );
d257 8
a264 7
		/* Eventually this will be optional */
		arbp->arb_opt = (struct oface *)rt_malloc(
			pa.pa_faces * sizeof(struct oface), "arb_opt");
		for( i=0; i < pa.pa_faces; i++ )
			arbp->arb_opt[i] = pa.pa_opt[i];	/* struct copy */

		stp->st_specific = (int *)arbp;
d322 3
a324 1
		VMOVE( ofp->arb_UVorig, point );
d332 1
d346 13
a358 12
		/*
		 * Get vector perp. to AB in face of plane ABC.
		 * Scale by projection of AC, make this V.
		 */
		VCROSS( work, afp->N, ofp->arb_U );
		VUNITIZE( work );
		f = VDOT( work, P_A );
		VSCALE( ofp->arb_V, work, f );
		f = MAGNITUDE( ofp->arb_V );
		ofp->arb_Vlen = f;
		f = 1/f;
		VSCALE( ofp->arb_V, ofp->arb_V, f );
d360 10
a369 8
		/* Check for new Ulen */
		VSUB2( P_A, point, ofp->arb_UVorig );
		f = VDOT( P_A, ofp->arb_U );
		if( f > ofp->arb_Ulen ) {
			ofp->arb_Ulen = f;
		} else if( f < 0.0 ) {
			VJOIN1( ofp->arb_UVorig, ofp->arb_UVorig, f, ofp->arb_U );
			ofp->arb_Ulen += (-f);
d385 19
a403 8
		VSUB2( P_A, point, ofp->arb_UVorig );
		/* Check for new Ulen, Vlen */
		f = VDOT( P_A, ofp->arb_U );
		if( f > ofp->arb_Ulen ) {
			ofp->arb_Ulen = f;
		} else if( f < 0.0 ) {
			VJOIN1( ofp->arb_UVorig, ofp->arb_UVorig, f, ofp->arb_U );
			ofp->arb_Ulen += (-f);
a404 7
		f = VDOT( P_A, ofp->arb_V );
		if( f > ofp->arb_Vlen ) {
			ofp->arb_Vlen = f;
		} else if( f < 0.0 ) {
			VJOIN1( ofp->arb_UVorig, ofp->arb_UVorig, f, ofp->arb_V );
			ofp->arb_Vlen += (-f);
		}
d693 10
d756 1
a756 1
	register dbfloat_t	*ip;
d759 1
d762 3
d768 1
a768 1
	MAT4X3PNT( &points[0], matp, &rp[0].s.s_values[0] );
d770 1
a770 1
	ip = &rp[0].s.s_values[1*3];
d774 1
a774 1
		VADD2( work, &rp[0].s.s_values[0], ip );
@


8.10
log
@If a ray lies in the plane of a face, a very small amount
of slop is now allowed, so that it is considered a "hit".
This is hopefully to deal with rays sneaking through the
crack between two abutting ARBs which *ought* to be the same face.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 8.9 89/04/11 11:52:52 mike Locked $ (BRL)";
d52 2
d56 1
a56 1
struct arb_opt {
a72 1
	struct arb_opt	*arb_opt;	/* pointer to optional info */
d74 1
d80 8
a87 2
static point_t	arb_points[ARB_MAXPTS];	/* Actual points on plane */
static int	arb_npts;		/* number of points on plane */
a88 4
static int	faces;			/* Number of faces done so far */
static struct aface	face[6];	/* work area */
static struct arb_opt	opt[6];		/* work area */

d108 2
a109 2
arb_prep( vec, stp, mat, rtip )
fastf_t		*vec;
d111 2
a112 1
matp_t		mat;
d114 1
d123 1
d125 3
d137 1
a137 1
	op = &vec[1*ELEMENTS_PER_VECT];
d140 2
a141 2
		VADD2( work, &vec[0], op );
		MAT4X3PNT( op, mat, work );
d145 3
a147 3
	MAT4X3PNT( work, mat, vec );			/* first point */
	VMOVE( vec, work );				/* 1st: IN PLACE*/
	VADD2( sum, sum, vec );				/* sum=0th element */
d162 1
a162 1
	faces = 0;
d164 1
a164 1
		arb_npts = 0;
d168 1
a168 1
			point = &vec[arb_info[i].ai_sub[j]*ELEMENTS_PER_VECT];
d173 2
a174 2
			for( k=0; k < arb_npts; k++ )  {
				VSUB2( work, point, arb_points[k] );
d180 1
a180 1
			VMOVE( arb_points[arb_npts], point );
d184 1
a184 1
				stp, arb_info[i].ai_title );
d188 1
a188 1
		if( arb_npts < 3 )  {
d194 4
a197 4
		opt[faces].arb_Ulen = 1.0 / opt[faces].arb_Ulen;
		opt[faces].arb_Vlen = 1.0 / opt[faces].arb_Vlen;
		VSCALE( opt[faces].arb_U, opt[faces].arb_U, opt[faces].arb_Ulen );
		VSCALE( opt[faces].arb_V, opt[faces].arb_V, opt[faces].arb_Vlen );
d199 1
a199 1
		faces++;
d201 1
a201 1
	if( faces < 4  || faces > 6 )  {
d203 1
a203 1
			stp->st_name, faces);
d217 1
a217 1
			sizeof(struct aface) * (faces - 4),
d219 3
a221 3
		arbp->arb_nmfaces = faces;
		for( i=0; i < faces; i++ )
			arbp->arb_face[i] = face[i];	/* struct copy */
d224 4
a227 4
		arbp->arb_opt = (struct arb_opt *)rt_malloc(
			faces * sizeof(struct arb_opt), "arb_opt");
		for( i=0; i < faces; i++ )
			arbp->arb_opt[i] = opt[i];	/* struct copy */
d238 1
a238 1
	op = &vec[0];
d266 1
a266 1
arb_add_pt( point, stp, title )
d268 3
a270 2
struct soltab *stp;
char	*title;
d277 1
d279 3
a281 2
	afp = &face[faces];
	i = arb_npts++;		/* Current point number */
d287 1
a287 1
		VMOVE( opt[faces].arb_UVorig, point );
d290 3
a292 3
		VSUB2( opt[faces].arb_U, point, afp->A );	/* B-A */
		f = MAGNITUDE( opt[faces].arb_U );
		opt[faces].arb_Ulen = f;
d294 1
a294 1
		VSCALE( opt[faces].arb_U, opt[faces].arb_U, f );
d299 1
a299 1
		VCROSS( afp->N, opt[faces].arb_U, P_A );
d302 1
a302 1
			arb_npts--;
d312 1
a312 1
		VCROSS( work, afp->N, opt[faces].arb_U );
d315 3
a317 3
		VSCALE( opt[faces].arb_V, work, f );
		f = MAGNITUDE( opt[faces].arb_V );
		opt[faces].arb_Vlen = f;
d319 1
a319 1
		VSCALE( opt[faces].arb_V, opt[faces].arb_V, f );
d322 4
a325 4
		VSUB2( P_A, point, opt[faces].arb_UVorig );
		f = VDOT( P_A, opt[faces].arb_U );
		if( f > opt[faces].arb_Ulen ) {
			opt[faces].arb_Ulen = f;
d327 2
a328 2
			VJOIN1( opt[faces].arb_UVorig, opt[faces].arb_UVorig, f, opt[faces].arb_U );
			opt[faces].arb_Ulen += (-f);
d344 1
a344 1
		VSUB2( P_A, point, opt[faces].arb_UVorig );
d346 3
a348 3
		f = VDOT( P_A, opt[faces].arb_U );
		if( f > opt[faces].arb_Ulen ) {
			opt[faces].arb_Ulen = f;
d350 2
a351 2
			VJOIN1( opt[faces].arb_UVorig, opt[faces].arb_UVorig, f, opt[faces].arb_U );
			opt[faces].arb_Ulen += (-f);
d353 3
a355 3
		f = VDOT( P_A, opt[faces].arb_V );
		if( f > opt[faces].arb_Vlen ) {
			opt[faces].arb_Vlen = f;
d357 2
a358 2
			VJOIN1( opt[faces].arb_UVorig, opt[faces].arb_UVorig, f, opt[faces].arb_V );
			opt[faces].arb_Vlen += (-f);
d369 1
a369 1
			arb_npts--;
d400 1
a400 1
			register struct arb_opt	*op;
@


8.9
log
@missing arg definition (lint)
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 8.8 89/04/08 05:48:48 phil Locked $ (BRL)";
d450 5
a454 2
			 * If it is outside the solid, stop now */
			if( dxbdn > 0.0 )
d545 1
a545 1
			   if( dxbdn > 0.0 ) {
@


8.8
log
@Major re-vamping for:
 1)  vectorization
 2)  hooks for lazy "prepping" of UV coordinate info, to save space.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 8.7 89/04/08 03:40:37 mike Locked $ (BRL)";
d682 1
@


8.7
log
@Allowed 3 more loops to vectorize.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 8.6 89/04/08 03:12:11 mike Locked $ (BRL)";
d54 1
a54 10
/* These hold temp values for the face being prep'ed */
#define ARB_MAXPTS	4		/* All we need are 4 points */
static point_t	arb_points[ARB_MAXPTS];	/* Actual points on plane */
static int	arb_npts;		/* number of points on plane */

/* One of these for each face */
struct arb_specific  {
	float	arb_A[3];		/* "A" point */
	float	arb_N[3];		/* Unit-length Normal (outward) */
	float	arb_NdotA;		/* Normal dot A */
a59 1
	struct arb_specific *arb_forw;	/* Forward link */
a60 1
#define ARB_NULL	((struct arb_specific *)0)
d62 6
a67 1
HIDDEN int	arb_face(), arb_add_pt();
d69 6
a74 1
static struct arb_specific *FreeArb;	/* Head of free list */
d76 11
a99 15
HIDDEN void
arb_getarb()
{
	register struct arb_specific *arbp;
	register int bytes;

	bytes = rt_byte_roundup(64*sizeof(struct arb_specific));
	arbp = (struct arb_specific *)rt_malloc(bytes, "get_arb");
	while( bytes >= sizeof(struct arb_specific) )  {
		arbp->arb_forw = FreeArb;
		FreeArb = arbp++;
		bytes -= sizeof(struct arb_specific);
	}
}

a112 1
	LOCAL int	faces;		/* # of faces produced */
a116 1
	register struct arb_specific *arbp;
a153 3
		while( (arbp=FreeArb) == ARB_NULL )  arb_getarb();
		FreeArb = arbp->arb_forw;

d174 1
a174 1
				stp, arbp, arb_info[i].ai_title );
a179 2
			arbp->arb_forw = FreeArb;
			FreeArb = arbp;
d184 4
a187 4
		arbp->arb_Ulen = 1.0 / arbp->arb_Ulen;
		arbp->arb_Vlen = 1.0 / arbp->arb_Vlen;
		VSCALE( arbp->arb_U, arbp->arb_U, arbp->arb_Ulen );
		VSCALE( arbp->arb_V, arbp->arb_V, arbp->arb_Vlen );
a188 4
		/* Add this face onto the linked list for this solid */
		arbp->arb_forw = (struct arb_specific *)stp->st_specific;
		stp->st_specific = (int *)arbp;

a193 1
		/* Should free storage for good faces */
d198 25
d252 2
d255 2
a256 2
HIDDEN int
arb_add_pt( point, stp, arbp, title )
a258 1
register struct arb_specific *arbp;
d265 1
d267 1
d273 3
a275 3
		VMOVE( arbp->arb_A, point );
		VMOVE( arbp->arb_UVorig, point );
		return(1);				/* OK */
d277 3
a279 3
		VSUB2( arbp->arb_U, point, arbp->arb_A );	/* B-A */
		f = MAGNITUDE( arbp->arb_U );
		arbp->arb_Ulen = f;
d281 2
a282 2
		VSCALE( arbp->arb_U, arbp->arb_U, f );
		return(1);				/* OK */
d284 1
a284 1
		VSUB2( P_A, point, arbp->arb_A );	/* C-A */
d286 2
a287 2
		VCROSS( arbp->arb_N, arbp->arb_U, P_A );
		f = MAGNITUDE( arbp->arb_N );
d290 1
a290 1
			return(0);			/* BAD */
d293 1
a293 1
		VSCALE( arbp->arb_N, arbp->arb_N, f );
d299 1
a299 1
		VCROSS( work, arbp->arb_N, arbp->arb_U );
d302 3
a304 3
		VSCALE( arbp->arb_V, work, f );
		f = MAGNITUDE( arbp->arb_V );
		arbp->arb_Vlen = f;
d306 1
a306 1
		VSCALE( arbp->arb_V, arbp->arb_V, f );
d309 4
a312 4
		VSUB2( P_A, point, arbp->arb_UVorig );
		f = VDOT( P_A, arbp->arb_U );
		if( f > arbp->arb_Ulen ) {
			arbp->arb_Ulen = f;
d314 2
a315 2
			VJOIN1( arbp->arb_UVorig, arbp->arb_UVorig, f, arbp->arb_U );
			arbp->arb_Ulen += (-f);
d322 2
a323 2
		VSUB2( work, arbp->arb_A, stp->st_center );
		f = VDOT( work, arbp->arb_N );
d325 1
a325 1
			VREVERSE(arbp->arb_N, arbp->arb_N);	/* "fix" normal */
d327 2
a328 2
		arbp->arb_NdotA = VDOT( arbp->arb_N, arbp->arb_A );
		return(1);				/* OK */
d331 1
a331 1
		VSUB2( P_A, point, arbp->arb_UVorig );
d333 3
a335 3
		f = VDOT( P_A, arbp->arb_U );
		if( f > arbp->arb_Ulen ) {
			arbp->arb_Ulen = f;
d337 2
a338 2
			VJOIN1( arbp->arb_UVorig, arbp->arb_UVorig, f, arbp->arb_U );
			arbp->arb_Ulen += (-f);
d340 3
a342 3
		f = VDOT( P_A, arbp->arb_V );
		if( f > arbp->arb_Vlen ) {
			arbp->arb_Vlen = f;
d344 2
a345 2
			VJOIN1( arbp->arb_UVorig, arbp->arb_UVorig, f, arbp->arb_V );
			arbp->arb_Vlen += (-f);
d348 1
a348 1
		VSUB2( P_A, point, arbp->arb_A );
d350 1
a350 1
		f = VDOT( arbp->arb_N, P_A );
d357 1
a357 1
			return(0);				/* BAD */
d360 1
a360 1
		return(1);			/* OK */
d373 1
d380 16
a395 10
	do {
		VPRINT( "A", arbp->arb_A );
		VPRINT( "Normal", arbp->arb_N );
		rt_log( "N.A = %g\n", arbp->arb_NdotA );
		VPRINT( "UVorig", arbp->arb_UVorig );
		VPRINT( "U", arbp->arb_U );
		VPRINT( "V", arbp->arb_V );
		rt_log( "Ulen = %g, Vlen = %g\n",
			arbp->arb_Ulen, arbp->arb_Vlen);
	} while( arbp = arbp->arb_forw );
d421 1
a421 1
	LOCAL struct arb_specific *iplane, *oplane;
d423 1
d427 1
a427 1
	iplane = oplane = ARB_NULL;
d430 1
a430 1
	for( ; arbp; arbp = arbp->arb_forw )  {
d435 2
a436 2
		dxbdn = VDOT( arbp->arb_N, rp->r_pt ) - arbp->arb_NdotA;
		if( (dn = -VDOT( arbp->arb_N, rp->r_dir )) < -SQRT_SMALL_FASTF )  {
d440 1
a440 1
				oplane = arbp;
d446 1
a446 1
				iplane = arbp;
a453 2
		if( rt_g.debug & DEBUG_ARB8 )
			rt_log("arb: in=%g, out=%g\n", in, out);
d458 1
a458 1
	if( iplane == ARB_NULL || oplane == ARB_NULL )  {
d481 1
d483 91
d585 2
a586 1
		(struct arb_specific *)hitp->hit_private;
d589 2
a590 1
	VMOVE( hitp->hit_normal, arbp->arb_N );
a605 2
	register struct arb_specific *arbp =
		(struct arb_specific *)hitp->hit_private;
d627 2
a628 1
		(struct arb_specific *)hitp->hit_private;
d632 3
a634 1
	VSUB2( P_A, hitp->hit_point, arbp->arb_UVorig );
d636 2
a637 2
	uvp->uv_u = VDOT( P_A, arbp->arb_U );
	uvp->uv_v = 1.0 - VDOT( P_A, arbp->arb_V );
d645 2
a646 2
	uvp->uv_du = r * arbp->arb_Ulen;
	uvp->uv_dv = r * arbp->arb_Vlen;
d659 3
a661 7
	while( arbp != ARB_NULL )  {
		register struct arb_specific *nextarb = arbp->arb_forw;

		arbp->arb_forw = FreeArb;
		FreeArb = arbp;
		arbp = nextarb;
	}
@


8.6
log
@Moved loop to check for repeated points up into main prep routine.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 8.5 89/04/08 02:35:21 mike Locked $ (BRL)";
d135 1
d221 1
d588 1
@


8.5
log
@Moved "arb_face()" inline.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 8.4 89/04/08 02:19:25 mike Locked $ (BRL)";
d121 1
d165 16
d182 1
a182 1
				&vec[arb_info[i].ai_sub[j]*ELEMENTS_PER_VECT],
d184 1
a235 48
 *			A R B _ F A C E
 *
 *  This function is called with pointers to 4 points,
 *  and is used to prepare both ARS and ARB8 faces.
 *  a,b,c,d are "index" values, merely decorative.
 *  ap, bp, cp, dp point to vect_t points.
 *  noise is non-zero for ARB8, for non-planar face complaints.
 *
 * Return -
 *	0	if the 4 points didn't form a plane (eg, colinear, etc).
 *	#pts	(>=3) if a valid plane resulted.  # valid pts is returned.
 */
HIDDEN int
arb_face( stp, ap, bp, cp, dp, title )
struct soltab *stp;
pointp_t ap, bp, cp, dp;
char	*title;
{
	register struct arb_specific *arbp;

	while( (arbp=FreeArb) == ARB_NULL )  arb_getarb();
	FreeArb = arbp->arb_forw;

	arb_npts = 0;
	arb_add_pt( ap, stp, arbp, title );
	arb_add_pt( bp, stp, arbp, title );
	arb_add_pt( cp, stp, arbp, title );
	arb_add_pt( dp, stp, arbp, title );

	if( arb_npts < 3 )  {
		arbp->arb_forw = FreeArb;
		FreeArb = arbp;
		return(0);				/* BAD */
	}

	/* Scale U and V basis vectors by the inverse of Ulen and Vlen */
	arbp->arb_Ulen = 1.0 / arbp->arb_Ulen;
	arbp->arb_Vlen = 1.0 / arbp->arb_Vlen;
	VSCALE( arbp->arb_U, arbp->arb_U, arbp->arb_Ulen );
	VSCALE( arbp->arb_V, arbp->arb_V, arbp->arb_Vlen );

	/* Add this face onto the linked list for this solid */
	arbp->arb_forw = (struct arb_specific *)stp->st_specific;
	stp->st_specific = (int *)arbp;
	return(arb_npts);					/* OK */
}

/*
a254 6
	/* Verify that this point is not the same as an earlier point */
	for( i=0; i < arb_npts; i++ )  {
		VSUB2( work, point, arb_points[i] );
		if( MAGSQ( work ) < 0.005 )
			return(0);			/* BAD */
	}
a255 1
	VMOVE( arb_points[i], point );
@


8.4
log
@Converted to structure-driven looping version.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 8.3 89/04/08 01:37:41 mike Locked $ (BRL)";
d120 1
d122 1
a156 1
#define P(x)	(&vec[(x)*ELEMENTS_PER_VECT])
a157 15
#if 0
	if( arb_face( stp, P(3), P(2), P(1), P(0), "1234" ) )
		faces++;					/* 1234 */
	if( arb_face( stp, P(4), P(5), P(6), P(7), "8765" ) )
		faces++;					/* 8765 */
	if( arb_face( stp, P(4), P(7), P(3), P(0), "1485" ) )
		faces++;					/* 1485 */
	if( arb_face( stp, P(2), P(6), P(5), P(1), "2673" ) )
		faces++;					/* 2673 */
	if( arb_face( stp, P(1), P(5), P(4), P(0), "1562" ) )
		faces++;					/* 1562 */
	if( arb_face( stp, P(7), P(6), P(2), P(3), "4378" ) )
		faces++;					/* 4378 */
#undef P
#else
d159 28
a186 6
		if( arb_face( stp,
			P(arb_info[i].ai_sub[0]),
			P(arb_info[i].ai_sub[1]),
			P(arb_info[i].ai_sub[2]),
			P(arb_info[i].ai_sub[3]),
			arb_info[i].ai_title ) )  faces++;
a187 1
#endif
@


8.3
log
@Eliminated arb_code[], reduced # of args to arb_face by 3 ==> faster.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 8.2 88/12/05 23:59:29 mike Locked $ (BRL)";
d77 28
d157 1
d171 10
a180 1

d231 1
a231 12
	while( (arbp=FreeArb) == ARB_NULL )  {
		register struct arb_specific *arbp;
		register int bytes;

		bytes = rt_byte_roundup(64*sizeof(struct arb_specific));
		arbp = (struct arb_specific *)rt_malloc(bytes, "get_arb");
		while( bytes >= sizeof(struct arb_specific) )  {
			arbp->arb_forw = FreeArb;
			FreeArb = arbp++;
			bytes -= sizeof(struct arb_specific);
		}
	}
@


8.2
log
@Added _plot() routines, and db_*() interfaces.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: /cad/d/mike/cad/librt/RCS/arb.c,v 1.2 88/11/03 12:34:56 mike Exp $ (BRL)";
a57 1
static char	arb_code[ARB_MAXPTS+1];	/* Face code string.  Decorative. */
d129 1
a129 1
	if( arb_face( stp, 3, 2, 1, 0, P(3), P(2), P(1), P(0) ) )
d131 1
a131 1
	if( arb_face( stp, 4, 5, 6, 7, P(4), P(5), P(6), P(7) ) )
d133 1
a133 1
	if( arb_face( stp, 4, 7, 3, 0, P(4), P(7), P(3), P(0) ) )
d135 1
a135 1
	if( arb_face( stp, 2, 6, 5, 1, P(2), P(6), P(5), P(1) ) )
d137 1
a137 1
	if( arb_face( stp, 1, 5, 4, 0, P(1), P(5), P(4), P(0) ) )
d139 1
a139 1
	if( arb_face( stp, 7, 6, 2, 3, P(7), P(6), P(2), P(3) ) )
d186 1
a186 1
arb_face( stp, a, b, c, d, ap, bp, cp, dp )
a187 1
int a, b, c, d;
d189 1
d208 4
a211 4
	arb_add_pt( ap, stp, arbp, a );
	arb_add_pt( bp, stp, arbp, b );
	arb_add_pt( cp, stp, arbp, c );
	arb_add_pt( dp, stp, arbp, d );
d240 1
a240 1
arb_add_pt( point, stp, arbp, a )
d244 1
a244 1
int a;
a258 2
	arb_code[i] = '0'+a;
	arb_code[i+1] = '\0';
a279 1
			arb_code[2] = '\0';
d344 1
a344 1
				stp->st_name, arb_code, f );
a346 1
			arb_code[i] = '\0';
@


8.1
log
@Release_3.0
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 7.4 88/05/14 00:00:29 mike Exp $ (BRL)";
d29 1
a88 1
	LOCAL fastf_t dx, dy, dz;	/* For finding the bounding spheres */
d162 2
a163 4
	VSET( stp->st_center,
		(stp->st_max[X] + stp->st_min[X])/2,
		(stp->st_max[Y] + stp->st_min[Y])/2,
		(stp->st_max[Z] + stp->st_min[Z])/2 );
d165 3
a167 6
	dx = (stp->st_max[X] - stp->st_min[X])/2;
	f = dx;
	dy = (stp->st_max[Y] - stp->st_min[Y])/2;
	if( dy > f )  f = dy;
	dz = (stp->st_max[Z] - stp->st_min[Z])/2;
	if( dz > f )  f = dz;
d169 1
a169 1
	stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);
d562 13
d576 4
a579 1
arb_plot()
d581 24
@


7.4
log
@lint fixes
added zero _uv() routines to some modules
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 7.3 88/02/06 05:36:16 mike Locked $ (BRL)";
@


7.3
log
@rt_orthovec to vec_ortho
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 7.2 87/11/13 01:50:34 mike Locked $ (BRL)";
d80 1
d367 1
d480 1
d500 1
d521 1
d551 1
d567 1
d572 1
d575 1
@


7.2
log
@fixed u,v mapping
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 7.1 87/11/02 23:32:41 phil Locked $ (BRL)";
d505 1
a505 1
	rt_orthovec( cvp->crv_pdir, hitp->hit_normal );
@


7.1
log
@Release 2.3
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 6.2 87/09/17 07:04:32 mike Exp $ (BRL)";
d53 3
a55 2
#define ARB_MAXPTS	4			/* All we need are 4 points */
static point_t	arb_points[ARB_MAXPTS];		/* Actual points on plane */
d59 1
a61 2
	float	arb_Xbasis[3];		/* X (B-A) vector (for 2d coords) */
	float	arb_Ybasis[3];		/* "Y" vector (perp to N and X) */
d64 5
a68 2
	float	arb_XXlen;		/* 1/(Xbasis dot Xbasis) */
	float	arb_YYlen;		/* 1/(Ybasis dot Ybasis) */
d224 6
d271 1
d274 5
a278 2
		VSUB2( arbp->arb_Xbasis, point, arbp->arb_A );	/* B-A */
		arbp->arb_XXlen = 1.0 / VDOT( arbp->arb_Xbasis, arbp->arb_Xbasis );
d283 1
a283 1
		VCROSS( arbp->arb_N, arbp->arb_Xbasis, P_A );
d291 1
a291 1
		VSCALE( arbp->arb_N, arbp->arb_N, f);
d295 1
a295 1
		 * Scale by projection of AC, make this Ybasis.
d297 1
a297 1
		VCROSS( work, arbp->arb_N, arbp->arb_Xbasis );
d300 5
a304 2
		VSCALE( arbp->arb_Ybasis, work, f );
		arbp->arb_YYlen = 1.0 / VDOT( arbp->arb_Ybasis, arbp->arb_Ybasis );
d306 10
d329 17
a378 4
		VPRINT( "Xbasis", arbp->arb_Xbasis );
		VPRINT( "Ybasis", arbp->arb_Ybasis );
		rt_log("XXlen = %g, YYlen = %g\n",
			arbp->arb_XXlen, arbp->arb_YYlen);
d381 5
d514 2
a515 2
 *  u extends along the Xbasis direction defined by B-A,
 *  v extends along the "Ybasis" direction defined by (B-A)xN.
d528 1
a528 1
	VSUB2( P_A, hitp->hit_point, arbp->arb_A );
d530 3
a532 3
	uvp->uv_u = VDOT( P_A, arbp->arb_Xbasis ) * arbp->arb_XXlen;
	uvp->uv_v = 1.0 - ( VDOT( P_A, arbp->arb_Ybasis ) * arbp->arb_YYlen );
	if( uvp->uv_u < 0 || uvp->uv_v < 0 )  {
d539 2
a540 2
	uvp->uv_du = r * arbp->arb_XXlen;
	uvp->uv_dv = r * arbp->arb_YYlen;
@


6.2
log
@Changed to SQRT_SMALL_FASTF for tolerances.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 6.1 87/07/11 07:55:10 mike Rel $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 5.3 87/07/07 01:36:19 mike Exp $ (BRL)";
d382 1
a382 1
		if( (dn = -VDOT( arbp->arb_N, rp->r_dir )) < -1.0e-10 )  {
d388 1
a388 1
		} else if ( dn > 1.0e-10 )  {
@


5.3
log
@Fixed V mapping.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 5.2 87/07/06 21:43:59 mike Locked $ (BRL)";
@


5.2
log
@Changed %f to %g for printing.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 5.1 87/06/24 22:10:41 mike Locked $ (BRL)";
d277 11
a287 2
		VUNITIZE( arbp->arb_N );
		VCROSS( arbp->arb_Ybasis, arbp->arb_N, arbp->arb_Xbasis );
d489 1
a489 2
		if( rt_g.debug )
			rt_log("arb_uv: bad uv=%g,%g\n", uvp->uv_u, uvp->uv_v);
@


5.1
log
@Release 1.24
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 4.6 87/04/28 00:26:55 phil Exp $ (BRL)";
d299 1
a299 1
			rt_log("arb(%s): face %s non-planar, dot=%f\n",
d329 1
a329 1
		rt_log("XX fact =%f, YY fact = %f\n",
d332 1
a332 1
		rt_log( "N.A = %f\n", arbp->arb_NdotA );
d392 1
a392 1
			rt_log("arb: in=%f, out=%f\n", in, out);
d481 1
a481 1
			rt_log("arb_uv: bad uv=%f,%f\n", uvp->uv_u, uvp->uv_v);
@


4.6
log
@changed curve convention
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 4.5 87/03/23 23:42:50 phil Locked $ (BRL)";
@


4.5
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 4.4 87/03/10 23:41:31 mike Exp $ (BRL)";
d444 1
a444 1
arb_curve( cvp, hitp, stp, rp )
a447 1
struct xray *rp;
a454 1

@


4.4
log
@For Stay, switched 3rd arg to ft_shoot() from resource pointer
(member of application struct) to application struct pointer.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 4.3 87/02/12 22:10:41 mike Locked $ (BRL)";
d77 5
a81 4
arb_prep( vec, stp, mat )
fastf_t *vec;
struct soltab *stp;
matp_t mat;
d491 26
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 4.2 87/01/28 20:59:38 mike Exp $ (BRL)";
d351 1
a351 1
arb_shot( stp, rp, res )
d354 1
a354 1
struct resource *res;
d407 1
a407 1
		GET_SEG( segp, res );
@


4.2
log
@Release 1.16:  added curvature
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 4.1 86/12/29 03:44:27 mike Locked $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 3.7 86/12/24 08:05:11 mike Locked $ (BRL)";
d435 21
@


3.7
log
@Revised for resource structure.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 3.6 86/12/14 14:02:37 mike Locked $ (BRL)";
@


3.6
log
@One additional register.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 3.5 86/10/11 01:19:52 mike Locked $ (BRL)";
d351 1
a351 1
arb_shot( stp, rp )
d354 1
d407 1
a407 1
		GET_SEG( segp );
@


3.5
log
@Changed to VMINMAX, fixing ELEMENTS_PER_VECT problem.
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 3.4 86/08/12 04:14:37 mike Exp $ (BRL)";
d244 1
a244 1
	LOCAL fastf_t f;
@


3.4
log
@Changed #include directives for use with CC -I convention
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 3.3 86/07/24 06:07:58 mike Exp $ (BRL)";
a69 4
#define ARB_MINMAX(a,b,c)	{ FAST fastf_t ftemp;\
			if( (ftemp = (c)) < (a) )  a = ftemp;\
			if( ftemp > (b) )  b = ftemp; }

d154 2
a155 4
		ARB_MINMAX( stp->st_min[X], stp->st_max[X], *op++ );
		ARB_MINMAX( stp->st_min[Y], stp->st_max[Y], *op++ );
		ARB_MINMAX( stp->st_min[Z], stp->st_max[Z], *op++ );
		op++;		/* Depends on ELEMENTS_PER_VECT */
@


3.3
log
@Added uvcoord support
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 3.2 86/07/22 03:19:46 mike Exp $ (BRL)";
d26 4
a29 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/raytrace.h"
#include "debug.h"
@


3.2
log
@Slight additional error checking
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 3.1 86/07/11 01:31:21 mike Exp $ (BRL)";
d102 1
a102 1
	VSET( sum, 0, 0, 0 );
d449 2
a450 1
arb_uv( stp, hitp, uvp )
d453 1
a453 1
register fastf_t *uvp;
d458 1
d462 3
a464 3
	uvp[0] = VDOT( P_A, arbp->arb_Xbasis ) * arbp->arb_XXlen;
	uvp[1] = 1.0 - ( VDOT( P_A, arbp->arb_Ybasis ) * arbp->arb_YYlen );
	if( uvp[0] < 0 || uvp[1] < 0 )  {
d466 1
a466 1
			rt_log("arb_uv: bad uv=%f,%f\n", uvp[0], uvp[1]);
d468 2
a469 2
		if( uvp[0] < 0 )  uvp[0] = (-uvp[0]);
		if( uvp[1] < 0 )  uvp[1] = (-uvp[1]);
d471 3
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d21 1
a21 1
static char RCSarb[] = "@@(#)$Header: arb.c,v 3.0 86/06/10 01:32:23 mike Exp $ (BRL)";
d406 1
a406 1
	if( in >= out )
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: arb.c,v 2.6 86/06/09 21:49:15 mike Exp $ (BRL)";
d35 16
a50 21
An ARB is a convex volume bounded by
4 (pyramid), 5 (wedge), or 6 (box) planes.
This analysis depends on the properties of objects with convex hulls.
Let the ray in question be defined such that any point $bold X vec$
on the ray may be expressed as
$bold X vec = bold P vec + k bold D vec$.
Intersect the ray with each of the
planes bounding the ARB as discussed above,
and record the values of the
parametric distance $k$ along the ray.
With outward pointing normal vectors, note that the
ray \fIenters\fR the half-space defined by a plane when
$bold D vec cdot bold N vec < 0$,
is \fIparallel\fR to the plane when $bold D vec cdot bold N vec = 0$,
and \fIexits\fR otherwise.
Find the \fIentry\fR point farthest away from the starting point $bold P vec$,
i.e. it has the largest value of $k$ among the entry points.
The ray enters the solid at this point.
Similarly, find the \fIexit\fR point closest to point
$bold P vec$, i.e. it has the smallest value of $k$ among the exit points.
The ray exits the solid here.
d53 2
a54 2
#define MAXPTS	4			/* All we need are 4 points */
static point_t	points[MAXPTS];		/* Actual points on plane */
d56 1
a56 1
static char	arb_code[MAXPTS+1];	/* Face code string.  Decorative. */
d70 1
a70 1
#define MINMAX(a,b,c)	{ FAST fastf_t ftemp;\
a73 3
#undef EPSILON
#define EPSILON	0.005		/* More appropriate for NEAR_ZERO here */

d158 3
a160 3
		MINMAX( stp->st_min[X], stp->st_max[X], *op++ );
		MINMAX( stp->st_min[Y], stp->st_max[Y], *op++ );
		MINMAX( stp->st_min[Z], stp->st_max[Z], *op++ );
d254 2
a255 2
		VSUB2( work, point, points[i] );
		if( MAGSQ( work ) < EPSILON )
d259 1
a259 1
	VMOVE( points[i], point );
d277 1
a277 1
		if( NEAR_ZERO(f) )  {
d302 1
a302 1
		if( ! NEAR_ZERO(f) )  {
d406 1
a406 1
	if( out < -0.005 || in >= out )
@


2.6
log
@rt and librt separated
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: arb.c,v 2.5 86/05/29 01:46:09 mike Exp $ (BRL)";
d32 25
a56 1
/* Describe algorithm here */
d152 1
a152 1
		rtlog("arb(%s):  only %d faces present\n",
d212 2
a213 2
		bytes = byte_roundup(64*sizeof(struct arb_specific));
		arbp = (struct arb_specific *)vmalloc(bytes, "get_arb");
d312 1
a312 1
			rtlog("arb(%s): face %s non-planar, dot=%f\n",
d335 1
a335 1
		rtlog("arb(%s):  no faces\n", stp->st_name);
d342 1
a342 1
		rtlog("XX fact =%f, YY fact = %f\n",
d345 1
a345 1
		rtlog( "N.A = %f\n", arbp->arb_NdotA );
d403 2
a404 2
		if( debug & DEBUG_ARB8 )
			rtlog("arb: in=%f, out=%f\n", in, out);
d410 1
a410 1
		rtlog("arb_shoot(%s): 1 hit => MISS\n",
d471 2
a472 2
		if( debug )
			rtlog("arb_uv: bad uv=%f,%f\n", uvp[0], uvp[1]);
@


2.5
log
@Changed tolerances as suggested by Moss
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: arb.c,v 2.4 86/03/14 21:53:56 mike Exp $ (BRL)";
d28 1
a28 1
#include "raytrace.h"
@


2.4
log
@Neatened debug prints
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: arb.c,v 2.3 85/09/11 00:31:52 mike Exp $ (BRL)";
d361 1
a361 1
		if( (dn = -VDOT( arbp->arb_N, rp->r_dir )) < -EPSILON )  {
d367 1
a367 1
		} else if ( dn > EPSILON )  {
d390 1
a390 1
	if( out < 0.0 || in >= out )
@


2.3
log
@Fixed minor return code error in arb_face.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: arb.c,v 2.2 85/09/06 02:27:12 mike Exp $ (BRL)";
a321 1
		rtlog("\n");
d447 2
a448 1
		rtlog("arb_uv: bad uv=%f,%f\n", uvp[0], uvp[1]);
@


2.2
log
@Improved flatness testing, did some general cleanup.
Greatly reduced memory requirements of arb_specific structure,
and added routine to allocate them in larger chunks.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: arb.c,v 2.1 85/08/31 06:02:40 mike Exp $ (BRL)";
a182 1
	register int pts;
d213 1
a213 1
	return(pts);					/* OK */
@


2.1
log
@Version 2 of RT
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: arb.c,v 1.21 85/07/30 05:51:51 mike Exp $ (BRL)";
d36 2
d40 8
a47 10
	int	pl_npts;		/* number of points on plane */
	vect_t	pl_A;			/* "A" point */
	vect_t	pl_Xbasis;		/* X (B-A) vector (for 2d coords) */
	vect_t	pl_Ybasis;		/* "Y" vector (perp to N and X) */
	vect_t	pl_N;			/* Unit-length Normal (outward) */
	fastf_t	pl_NdotA;		/* Normal dot A */
	fastf_t	pl_XXlen;		/* 1/(Xbasis dot Xbasis) */
	fastf_t	pl_YYlen;		/* 1/(Ybasis dot Ybasis) */
	struct arb_specific *pl_forw;	/* Forward link */
	char	pl_code[MAXPTS+1];	/* Face code string.  Decorative. */
d49 1
d58 4
d101 1
a101 1
	 *  needed only for add_pt, which demands a point inside the solid.
d113 1
a113 1
	if( face( stp, 3, 2, 1, 0, P(3), P(2), P(1), P(0), 1 ) )
d115 1
a115 1
	if( face( stp, 4, 5, 6, 7, P(4), P(5), P(6), P(7), 1 ) )
d117 1
a117 1
	if( face( stp, 4, 7, 3, 0, P(4), P(7), P(3), P(0), 1 ) )
d119 1
a119 1
	if( face( stp, 2, 6, 5, 1, P(2), P(6), P(5), P(1), 1 ) )
d121 1
a121 1
	if( face( stp, 1, 5, 4, 0, P(1), P(5), P(4), P(0), 1 ) )
d123 1
a123 1
	if( face( stp, 7, 6, 2, 3, P(7), P(6), P(2), P(3), 1 ) )
d164 1
a164 1
 *			F A C E
d176 2
a177 1
face( stp, a, b, c, d, ap, bp, cp, dp, noise )
a180 1
int noise;
d182 1
a182 1
	register struct arb_specific *plp;
a183 1
	register int i;
d185 3
a187 6
	GETSTRUCT( plp, arb_specific );
	plp->pl_npts = 0;
	pts  = add_pt( ap, stp, plp, a, noise );
	pts += add_pt( bp, stp, plp, b, noise );
	pts += add_pt( cp, stp, plp, c, noise );
	pts += add_pt( dp, stp, plp, d, noise );
d189 19
a207 2
	if( pts < 3 )  {
		free(plp);
d212 2
a213 2
	plp->pl_forw = (struct arb_specific *)stp->st_specific;
	stp->st_specific = (int *)plp;
d218 1
a218 1
 *			A D D _ P T
d223 1
a223 2
 *  check for validity.  If noise!=0, then non-planar 4th points give
 *  a warning message.  noise=1 for ARB8's, and noise=0 for ARS's.
d225 2
a226 1
add_pt( point, stp, plp, a, noise )
d229 1
a229 1
register struct arb_specific *plp;
a230 1
int noise;			/* non-0: check 4,> pts for being planar */
d238 1
a238 1
	for( i=0; i < plp->pl_npts; i++ )  {
d243 1
a243 1
	i = plp->pl_npts++;		/* Current point number */
d245 2
a246 2
	plp->pl_code[i] = '0'+a;
	plp->pl_code[i+1] = '\0';
d251 1
a251 1
		VMOVE( plp->pl_A, point );
d254 2
a255 2
		VSUB2( plp->pl_Xbasis, point, plp->pl_A );	/* B-A */
		plp->pl_XXlen = 1.0 / VDOT( plp->pl_Xbasis, plp->pl_Xbasis );
d258 1
a258 1
		VSUB2( P_A, point, plp->pl_A );	/* C-A */
d260 2
a261 2
		VCROSS( plp->pl_N, plp->pl_Xbasis, P_A );
		f = MAGNITUDE( plp->pl_N );
d263 2
a264 2
			plp->pl_npts--;
			plp->pl_code[2] = '\0';
d267 3
a269 3
		VUNITIZE( plp->pl_N );
		VCROSS( plp->pl_Ybasis, plp->pl_N, plp->pl_Xbasis );
		plp->pl_YYlen = 1.0 / VDOT( plp->pl_Ybasis, plp->pl_Ybasis );
d275 2
a276 2
		VSUB2( work, plp->pl_A, stp->st_center );
		f = VDOT( work, plp->pl_N );
d278 1
a278 1
			VREVERSE(plp->pl_N, plp->pl_N);	/* "fix" normal */
d280 1
a280 1
		plp->pl_NdotA = VDOT( plp->pl_N, plp->pl_A );
d284 3
a286 2
		VSUB2( P_A, point, plp->pl_A );
		f = VDOT( plp->pl_N, P_A );
d289 2
a290 4
			if( noise )  {
				rtlog("ERROR: arb(%s) face %s non-planar, dot=%f\n",
				stp->st_name, plp->pl_code, f );
			}
d292 2
a293 2
			plp->pl_npts--;
			plp->pl_code[i] = '\0';
d307 1
a307 1
	register struct arb_specific *plp =
d311 1
a311 1
	if( plp == (struct arb_specific *)0 )  {
d316 3
a318 5
		rtlog( "......Face %s\n", plp->pl_code );
		rtlog( "%d vertices:\n", plp->pl_npts );
		VPRINT( "A", plp->pl_A );
		VPRINT( "Xbasis", plp->pl_Xbasis );
		VPRINT( "Ybasis", plp->pl_Ybasis );
d320 3
a322 3
			plp->pl_XXlen, plp->pl_YYlen);
		VPRINT( "Normal", plp->pl_N );
		rtlog( "N.A = %f\n", plp->pl_NdotA );
d324 1
a324 1
	} while( plp = plp->pl_forw );
d347 1
a347 1
	register struct arb_specific *plp =
a348 1
	register struct seg *segp;
a350 3
	FAST fastf_t	dxbdn;
	FAST fastf_t	dn;		/* Direction dot Normal */
	FAST fastf_t	s;
d354 1
a354 2
#define PLANE_NULL	(struct arb_specific *)0
	iplane = oplane = PLANE_NULL;
d357 4
a360 1
	for( ; plp; plp = plp->pl_forw )  {
d362 2
a363 7
		/* Ray Direction dot N.  (N is outward-pointing normal) */
		dn = -VDOT( plp->pl_N, rp->r_dir );
		dxbdn = VDOT( plp->pl_N, rp->r_pt ) - plp->pl_NdotA;
		if( debug & DEBUG_ARB8 )
			rtlog("arb: face %s.  N.Dir=%f dxbdn=%f\n", plp->pl_code, dn, dxbdn );

		if( dn < -EPSILON )  {
d367 1
a367 1
				oplane = plp;
d373 1
a373 1
				iplane = plp;
d387 2
a388 2
	if( iplane == PLANE_NULL || oplane == PLANE_NULL )  {
		rtlog("ERROR: arb(%s): 1 hit => MISS\n",
d395 2
a396 4
	GET_SEG( segp );
	segp->seg_stp = stp;
	segp->seg_in.hit_dist = in;
	segp->seg_in.hit_private = (char *)iplane;
d398 10
a407 3
	segp->seg_out.hit_dist = out;
	segp->seg_out.hit_private = (char *)oplane;
	return(segp);			/* HIT */
d420 3
d424 1
a424 2
	VMOVE( hitp->hit_normal,
		((struct arb_specific *)hitp->hit_private)->pl_N );
d440 2
a441 2
	register struct arb_specific *plp =
		(struct arb_specific *)stp->st_specific;
d444 1
a444 12
	/* First, find which face was involved.  Match normals */
	for( ; plp; plp = plp->pl_forw )  {
		if( plp->pl_N[X] == hitp->hit_normal[X] &&
		    plp->pl_N[Y] == hitp->hit_normal[Y] &&
   		    plp->pl_N[Z] == hitp->hit_normal[Z] )
			goto found;
	}
	rtlog("arb_uv:  face not found!\n");
	uvp[0] = uvp[1] = 0.0;
	return;
found:
	VSUB2( P_A, hitp->hit_point, plp->pl_A );
d446 2
a447 2
	uvp[0] = VDOT( P_A, plp->pl_Xbasis ) * plp->pl_XXlen;
	uvp[1] = 1.0 - ( VDOT( P_A, plp->pl_Ybasis ) * plp->pl_YYlen );
@


1.21
log
@Revised for joint GED/RT vmath.h;  some storage cleanups.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: arb.c,v 1.20 85/03/25 11:34:14 mike Exp $ (BRL)";
d25 1
d35 1
a35 1
#define pl_A	pl_points[0]		/* Synonym for A point */
d39 1
a39 1
	point_t	pl_points[MAXPTS];	/* Actual points on plane */
d41 1
d44 2
d70 2
a71 1
	LOCAL int	i;
d123 1
a123 1
		fprintf(stderr,"arb(%s):  only %d faces present\n",
d148 1
d150 1
d152 3
a154 1
	stp->st_radsq = dx*dx + dy*dy + dz*dz;
d222 1
a222 1
		VSUB2( work, point, plp->pl_points[i] );
d227 1
a227 1
	VMOVE( plp->pl_points[i], point );
d234 1
d238 1
d251 2
d272 1
a272 1
				fprintf(stderr,"ERROR: arb(%s) face %s non-planar, dot=%f\n",
d296 1
a296 1
		fprintf(stderr,"arb(%s):  no faces\n", stp->st_name);
d300 3
a302 5
		fprintf(stderr, "......Face %s\n", plp->pl_code );
		fprintf(stderr, "%d vertices:\n", plp->pl_npts );
		for( i=0; i < plp->pl_npts; i++ )  {
			VPRINT( "", plp->pl_points[i] );
		}
d304 3
d308 2
a309 2
		fprintf(stderr, "N.A = %f\n", plp->pl_NdotA );
		putc('\n',stderr);
d354 1
a354 1
			fprintf(stderr,"arb: face %s.  N.Dir=%f dxbdn=%f\n", plp->pl_code, dn, dxbdn );
d375 1
a375 1
			fprintf(stderr,"arb: in=%f, out=%f\n", in, out);
d381 1
a381 1
		fprintf(stderr,"ERROR: arb(%s): 1 hit => MISS\n",
a389 1
	segp->seg_flag = SEG_IN|SEG_OUT;
d391 1
a391 2
	VJOIN1( segp->seg_in.hit_point, rp->r_pt, in, rp->r_dir );
	VMOVE( segp->seg_in.hit_normal, iplane->pl_N );
d394 1
a394 2
	VJOIN1( segp->seg_out.hit_point, rp->r_pt, out, rp->r_dir );
	VMOVE( segp->seg_out.hit_normal, oplane->pl_N );
d396 55
@


1.20
log
@Made local epsilon.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: arb.c,v 1.19 84/11/30 03:59:09 mike Exp $ (BRL)";
d25 2
a26 1
#include "vmath.h"
@


1.19
log
@More efficient algorithm implemented
@
text
@d8 11
a18 7
 *  Contributors -
 *	Michael John Muuss	(Programming, Generalization)
 *
 * U. S. Army Ballistic Research Laboratory
 * April 18, 1984.
 *
 * $Revision: 1.18 $
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: arb.c,v 1.18 84/11/24 02:59:35 mike Exp $ (BRL)";
d49 3
d258 2
a259 2
				fprintf(stderr,"ERROR: arb(%s) face %s non-planar\n",
				stp->st_name, plp->pl_code );
@


1.18
log
@Removed max, min inits.
@
text
@a8 1
 *	Edwin O. Davisson	(Triangle & Intercept Analysis)
a9 1
 *	Douglas A. Gwyn		("Inside" routine)
d14 1
a14 1
 * $Revision: 1.17 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: arb.c,v 1.17 84/11/23 20:53:39 mike Exp $ (BRL)";
a23 1
#include "plane.h"
d25 1
d28 13
d160 1
a160 1
	register struct plane_specific *plp;
d164 1
a164 1
	GETSTRUCT( plp, plane_specific );
a174 2
	/* Make the 2d-point list contain the origin as start+end */
	plp->pl_2d_x[plp->pl_npts] = plp->pl_2d_y[plp->pl_npts] = 0.0;
a175 11
	/* Compute the common sub-expression for inside() */
	for( i=0; i < pts; i++ )  {
		LOCAL fastf_t f;
		f = (plp->pl_2d_y[i+1] - plp->pl_2d_y[i]);
		if( NEAR_ZERO(f) )
			plp->pl_2d_com[i] = 0.0;	/* anything */
		else
			plp->pl_2d_com[i] =
				(plp->pl_2d_x[i+1] - plp->pl_2d_x[i]) / f;
	}

d177 1
a177 1
	plp->pl_forw = (struct plane_specific *)stp->st_specific;
d185 1
a185 1
 *  Add another point to a struct plane_specific, checking for unique pts.
d194 1
a194 1
register struct plane_specific *plp;
a216 1
		plp->pl_2d_x[0] = plp->pl_2d_y[0] = 0.0;
a219 2
		plp->pl_2d_x[1] = VDOT( plp->pl_Xbasis, plp->pl_Xbasis );
		plp->pl_2d_y[1] = 0.0;
a241 2
		/* Generate an arbitrary Y basis perp to Xbasis & Normal */
		VCROSS( plp->pl_Ybasis, plp->pl_Xbasis, plp->pl_N );
a242 2
		plp->pl_2d_x[2] = VDOT( P_A, plp->pl_Xbasis );
		plp->pl_2d_y[2] = VDOT( P_A, plp->pl_Ybasis );
a246 3
		/* Project into 2-d, even if non-planar */
		plp->pl_2d_x[i] = VDOT( P_A, plp->pl_Xbasis );
		plp->pl_2d_y[i] = VDOT( P_A, plp->pl_Ybasis );
d270 2
a271 2
	register struct plane_specific *plp =
		(struct plane_specific *)stp->st_specific;
d274 1
a274 1
	if( plp == (struct plane_specific *)0 )  {
a284 1
		VPRINT( "Ybasis", plp->pl_Ybasis );
a286 6
		fprintf(stderr, "2-d projection of vertices:\n");
		for( i=0; i < plp->pl_npts; i++ )  {
			fprintf(stderr, "(%f,%f), ",
				plp->pl_2d_x[i],
				plp->pl_2d_y[i] );
		}
d296 5
d311 8
a318 8
	register struct plane_specific *plp =
		(struct plane_specific *)stp->st_specific;
#define MAXHITS 12		/* # surfaces hit, must be even */
	LOCAL struct hit hits[MAXHITS];
	register struct hit *hp;
	LOCAL int	nhits;
	LOCAL vect_t	work;
	LOCAL fastf_t	xt, yt;
d320 4
a323 2
	nhits = 0;
	hp = &hits[0];
d327 4
a330 6
		FAST fastf_t dn;		/* Direction dot Normal */
		FAST fastf_t k;		/* (NdotA - (N dot P))/ (N dot D) */
		/*
		 *  Ray Direction dot N.  (N is outward-pointing normal)
		 */
		dn = VDOT( plp->pl_N, rp->r_dir );
d332 1
a332 6
			fprintf(stderr,"Shooting at face %s.  N.Dir=%f\n", plp->pl_code, dn );
		/*
		 *  If ray lies directly along the face, drop this face.
		 */
		if( dn == 0.0 )
			continue;
d334 17
a350 27
		/* Compute distance along ray of intersection */
		k = (plp->pl_NdotA - VDOT(plp->pl_N, rp->r_pt)) / dn;

		/*  If dn < 0, we should be entering the solid.
		 *  However, we just assume in/out sorting later will work.
		 *  This code is an inline version of:
		 *
		 *	if( pl_shot( plp, rp, &in, k ) != 0 ) continue;
		 */
		VJOIN1( hp->hit_point, rp->r_pt, k, rp->r_dir );
		VSUB2( work, hp->hit_point, plp->pl_A );
		xt = VDOT( work, plp->pl_Xbasis );
		yt = VDOT( work, plp->pl_Ybasis );
		if( !inside(
			&xt, &yt,
			plp->pl_2d_x, plp->pl_2d_y, plp->pl_2d_com,
			plp->pl_npts )
		)
			continue;			/* MISS */

		/* HIT is within planar face */
		hp->hit_dist = k;
		VMOVE( hp->hit_normal, plp->pl_N );
		if(debug&DEBUG_ARB8) fprintf(stderr,"arb: hit dist=%f, dn=%f, k=%f\n", hp->hit_dist, dn, k );
		if( nhits++ >= MAXHITS )  {
			fprintf(stderr,"arb(%s): too many hits\n", stp->st_name);
			break;
d352 4
a355 1
		hp++;
d357 5
a361 20
	if( nhits == 0 )
		return(SEG_NULL);		/* MISS */

	/* Sort hits, Near to Far */
	HitSort( hits, nhits );

	if( nhits&1 )  {
		/*
		 * If this condition exists, it is almost certainly due to
		 * the dn==0 check above.  Thus, we will make the last
		 * surface infinitely thin and just replicate the entry
		 * point as the exit point.  This at least makes the
		 * presence of this solid known.  There may be something
		 * better we can do.
		 */
		hits[nhits] = hits[nhits-1];	/* struct copy */
		VREVERSE( hp->hit_normal, hits[nhits-1].hit_normal );
		fprintf(stderr,"ERROR: arb(%s): %d hits, false exit\n",
			stp->st_name, nhits);
		nhits++;
d363 2
d366 6
a371 19
	/* nhits is even, build segments */
	{
		register struct seg *segp;			/* XXX */
		segp = SEG_NULL;
		while( nhits > 0 )  {
			register struct seg *newseg;		/* XXX */
			GET_SEG(newseg);
			newseg->seg_next = segp;
			segp = newseg;
			segp->seg_stp = stp;
			segp->seg_flag = SEG_IN|SEG_OUT;
			segp->seg_in = hits[nhits-2];	/* struct copy */
			segp->seg_out = hits[nhits-1];	/* struct copy */
			nhits -= 2;
		}
		return(segp);			/* HIT */
	}
	/* NOTREACHED */
}
d373 4
a376 101
HitSort( h, nh )
register struct hit h[];
register int nh;
{
	register int i, j;
	LOCAL struct hit temp;

	for( i=0; i < nh-1; i++ )  {
		for( j=i+1; j < nh; j++ )  {
			if( h[i].hit_dist <= h[j].hit_dist )
				continue;
			temp = h[j];		/* struct copy */
			h[j] = h[i];		/* struct copy */
			h[i] = temp;		/* struct copy */
		}
	}
}

/*
 *  			P L _ S H O T
 *
 *  This routine has been expanded in-line, but is preserved here for
 *  study, and possible re-use elsewhere.
 */
pl_shot( plp, rp, hitp, k )
register struct plane_specific *plp;
register struct xray *rp;
register struct hit *hitp;
double	k;			/* dist along ray */
{
	LOCAL vect_t	hit_pt;		/* ray hits solid here */
	LOCAL vect_t	work;
	LOCAL fastf_t	xt, yt;

	VJOIN1( hit_pt, rp->r_pt, k, rp->r_dir );
	/* Project the hit point onto the plane, making this a 2-d problem */
	VSUB2( work, hit_pt, plp->pl_A );
	xt = VDOT( work, plp->pl_Xbasis );
	yt = VDOT( work, plp->pl_Ybasis );

	if( !inside(
		&xt, &yt,
		plp->pl_2d_x, plp->pl_2d_y, plp->pl_2d_com,
		plp->pl_npts )
	)
		return(1);			/* MISS */

	/* Hit is within planar face */
	hitp->hit_dist = k;
	VMOVE( hitp->hit_point, hit_pt );
	VMOVE( hitp->hit_normal, plp->pl_N );
	return(0);				/* HIT */
}

/*
 *  			I N S I D E
 *  
 * Function -
 *  	Determines whether test point (xt,yt) is inside the polygon
 *  	whose vertices have coordinates (in cyclic order) of
 *  	(x[i],y[i]) for i = 0 to n-1.
 *  
 * Returns -
 *  	1	iff test point is inside polygon
 *  	0	iff test point is outside polygon
 *  
 * Method -
 *  	A horizontal line through the test point intersects an even
 *  	number of the polygon's sides to the right of the point
 *  	IFF the point is exterior to the polygon (Jordan Curve Theorem).
 *  
 * Note -
 *  	For speed, we assume that x[n] == x[0], y[n] == y[0],
 *  	ie, that the starting point is repeated as the ending point.
 *
 * Credit -
 *	Douglas A. Gwyn (Algorithm, original FORTRAN subroutine)
 *	Michael Muuss (This "C" routine)
 */
inside( xt, yt, x, y, com, n )
register fastf_t *xt, *yt;
register fastf_t *x, *y, *com;
int n;
{
	register fastf_t *xend;
	LOCAL int ret;

	/*
	 * Starts with 0 intersections, an even number ==> outside.
	 * Proceed around the polygon, testing each side for intersection.
	 */
	xend = &x[n];
	for( ret=0; x < xend; x++,y++,com++ )  {
		/* See if edge is crossed by horiz line through test point */
		if( (*yt > *y || *yt <= y[1])  &&  (*yt <= *y || *yt > y[1]) )
			continue;
		/* Yes.  See if intersection is to the right of test point */
		if( (*xt - *x) < (*yt-*y) * (*com) )
			ret = !ret;
	}
	return(ret);
@


1.17
log
@Added LOCAL, fastf_t declarations.
Made shootray() recursive.
@
text
@d16 1
a16 1
 * $Revision: 1.16 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb.c,v 1.16 84/11/22 09:06:28 mike Exp $ (BRL)";
a48 4
	/* init maxima and minima */
	stp->st_max[X] = stp->st_max[Y] = stp->st_max[Z] = -INFINITY;
	stp->st_min[X] = stp->st_min[Y] = stp->st_min[Z] =  INFINITY;

d306 1
a306 1
		putchar('\n');
@


1.16
log
@Various cleanups
@
text
@d16 1
a16 1
 * $Revision: 1.15 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb.c,v 1.15 84/11/20 20:13:57 mike Exp $ (BRL)";
d43 5
a47 5
	static fastf_t dx, dy, dz;	/* For finding the bounding spheres */
	static vect_t	work;		/* Vector addition work area */
	static vect_t	sum;		/* Sum of all endpoints */
	static int	faces;		/* # of faces produced */
	static int	i;
d173 1
a173 1
		static fastf_t f;
d205 3
a207 3
	static vect_t work;
	static vect_t P_A;		/* new point - A */
	static fastf_t f;
d332 1
a332 1
	static struct hit hits[MAXHITS];
d334 3
a336 3
	static int	nhits;
	static vect_t	work;
	static fastf_t	xt, yt;
d434 1
a434 1
	static struct hit temp;
d459 3
a461 3
	static vect_t	hit_pt;		/* ray hits solid here */
	static vect_t	work;
	static fastf_t	xt, yt;
d514 1
a514 1
	static int ret;
@


1.15
log
@General cleanup
@
text
@d16 1
a16 1
 * $Revision: 1.14 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb.c,v 1.14 84/11/16 23:49:25 mike Exp $ (BRL)";
d380 1
a380 1
		if(debug&DEBUG_ARB8) printf("arb: hit dist=%f, dn=%f, k=%f\n", hp->hit_dist, dn, k );
@


1.14
log
@arb8 --> arb, for non-FLEXNAMES systems.
@
text
@d16 1
a16 1
 * $Revision: 1.13 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb.c,v 1.13 84/11/16 06:25:50 mike Exp $ (BRL)";
d103 1
a103 1
		printf("arb(%s):  only %d faces present\n",
d267 1
a267 1
				printf("ERROR: arb(%s) face %s non-planar\n",
d291 1
a291 1
		printf("arb(%s):  no faces\n", stp->st_name);
d295 2
a296 2
		printf( "......Face %s\n", plp->pl_code );
		printf( "%d vertices:\n", plp->pl_npts );
d303 2
a304 2
		printf( "N.A = %f\n", plp->pl_NdotA );
		printf( "2-d projection of vertices:\n");
d306 1
a306 1
			printf( "(%f,%f), ",
d350 1
a350 1
			printf("Shooting at face %s.  N.Dir=%f\n", plp->pl_code, dn );
d382 1
a382 1
			printf("arb(%s): too many hits\n", stp->st_name);
d404 1
a404 1
		printf("ERROR: arb(%s): %d hits, false exit\n",
@


1.13
log
@Reworked computation of the vertices of the ARB8
in arb8_prep to match the method used in GED.
@
text
@d2 1
a2 1
 *  			A R B 8 . C
d16 1
a16 1
 * $Revision: 1.12 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb8.c,v 1.12 84/11/15 21:47:02 mike Exp $ (BRL)";
d35 1
a35 1
 *  			A R B 8 _ P R E P
d37 1
a37 1
arb8_prep( vec, stp, mat )
d103 1
a103 1
		printf("arb8(%s):  only %d faces present\n",
d267 1
a267 1
				printf("ERROR: arb8(%s) face %s non-planar\n",
d281 1
a281 1
 *  			A R B 8 _ P R I N T
d283 1
a283 1
arb8_print( stp )
d291 1
a291 1
		printf("arb8(%s):  no faces\n", stp->st_name);
d315 1
a315 1
 *			A R B 8 _ S H O T
d325 1
a325 1
arb8_shot( stp, rp )
d380 1
a380 1
		if(debug&DEBUG_ARB8) printf("arb8: hit dist=%f, dn=%f, k=%f\n", hp->hit_dist, dn, k );
d382 1
a382 1
			printf("arb8(%s): too many hits\n", stp->st_name);
d404 1
a404 1
		printf("ERROR: arb8(%s): %d hits, false exit\n",
@


1.12
log
@For use with ARS, modified to allow multiple entry and exit points.
@
text
@d16 1
a16 1
 * $Revision: 1.11 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb8.c,v 1.11 84/10/19 01:37:43 mike Exp $ (BRL)";
d24 1
a24 1
#include "ray.h"
a42 2
	static fastf_t xmax, ymax, zmax;/* For finding the bounding spheres */
	static fastf_t xmin, ymin, zmin;/* For finding the bounding spheres */
d50 2
a51 2
	xmax = ymax = zmax = -INFINITY;
	xmin = ymin = zmin =  INFINITY;
d61 1
a61 4
	MAT4X3PNT( work, mat, vec );			/* 4x4: xlate, too */
	VMOVE( vec, work );				/* base vector */
	VMOVE( sum, vec );				/* sum=0th element */

d64 2
a65 2
		MAT3XVEC( work, mat, op );		/* 3x3: rot only */
		VADD2( op, &vec[0], work );
d69 3
d117 3
a119 3
		MINMAX( xmin, xmax, *op++ );
		MINMAX( ymin, ymax, *op++ );
		MINMAX( zmin, zmax, *op++ );
d123 3
a125 1
		(xmax + xmin)/2, (ymax + ymin)/2, (zmax + zmin)/2 );
d127 3
a129 3
	dx = (xmax - xmin)/2;
	dy = (ymax - ymin)/2;
	dz = (zmax - zmin)/2;
d327 1
a327 1
register struct ray *rp;
d455 1
a455 1
register struct ray *rp;
@


1.11
log
@Lint corrections
@
text
@d16 1
a16 1
 * $Revision: 1.10 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb8.c,v 1.10 84/05/04 09:13:41 mike Exp $ (BRL)";
d63 1
a63 1
	MAT4X3VEC( work, mat, vec );			/* 4x4: xlate, too */
d331 4
a334 4
	register struct seg *segp;
	static struct hit in, out;
	static int flags;
	static vect_t	hit_pt;		/* ray hits solid here */
d338 2
a339 1
	in.hit_dist = out.hit_dist = -INFINITY;	/* 'way back behind eye */
a340 1
	flags = 0;
d352 1
a352 2
		 *  Unless *exactly* along face, need to compute this anyways,
		 *  because other (entrance/exit) point is probably worth it.
d360 16
a375 17
		if( dn < 0 )  {
			/* Entering solid */
			if( flags & SEG_IN )  {
				if( debug & DEBUG_ARB8)printf("skipping nearby entry surface, k=%f\n", k);
				continue;
			}
			/* if( pl_shot( plp, rp, &in, k ) != 0 ) continue; */
			VJOIN1( hit_pt, rp->r_pt, k, rp->r_dir );
			VSUB2( work, hit_pt, plp->pl_A );
			xt = VDOT( work, plp->pl_Xbasis );
			yt = VDOT( work, plp->pl_Ybasis );
			if( !inside(
				&xt, &yt,
				plp->pl_2d_x, plp->pl_2d_y, plp->pl_2d_com,
				plp->pl_npts )
			)
				continue;			/* MISS */
d377 7
a383 30
			/* HIT is within planar face */
			in.hit_dist = k;
			VMOVE( in.hit_point, hit_pt );
			VMOVE( in.hit_normal, plp->pl_N );
			if(debug&DEBUG_ARB8) printf("arb8: entry dist=%f, dn=%f, k=%f\n", in.hit_dist, dn, k );
			flags |= SEG_IN;
		} else {
			/* Exiting solid */
			if( flags & SEG_OUT )  {
				if( debug & DEBUG_ARB8)printf("skipping nearby exit surface, k=%f\n", k);
				continue;
			}
			/* if( pl_shot( plp, rp, &out, k ) != 0 ) continue; */
			VJOIN1( hit_pt, rp->r_pt, k, rp->r_dir );
			VSUB2( work, hit_pt, plp->pl_A );
			xt = VDOT( work, plp->pl_Xbasis );
			yt = VDOT( work, plp->pl_Ybasis );
			if( !inside(
				&xt, &yt,
				plp->pl_2d_x, plp->pl_2d_y, plp->pl_2d_com,
				plp->pl_npts )
			)
				continue;			/* MISS */

			/* HIT is within planar face */
			out.hit_dist = k;
			VMOVE( out.hit_point, hit_pt );
			VMOVE( out.hit_normal, plp->pl_N );
			if(debug&DEBUG_ARB8) printf("arb8: exit dist=%f, dn=%f, k=%f\n", out.hit_dist, dn, k );
			flags |= SEG_OUT;
d385 1
d387 1
a387 1
	if( flags == 0 )
d390 5
a394 2
	if( flags == SEG_IN )  {
		/* It can start inside, but it should always leave.
d396 1
a396 1
		 * the dn==0 check above.  Thus, we will make the
d402 5
a406 4
		out.hit_dist = in.hit_dist;
		VMOVE( out.hit_point, in.hit_point );
		VREVERSE( out.hit_normal, in.hit_point );
		flags |= SEG_OUT;
d409 16
a424 3
	if( flags == SEG_OUT )  {
		VSET( in.hit_point, 0, 0, 0 );
		VSET( in.hit_normal, 0, 0, 0 );
d426 19
a444 7
	/* SEG_OUT, or SEG_IN|SEG_OUT */
	GET_SEG(segp);
	segp->seg_stp = stp;
	segp->seg_flag = flags;
	segp->seg_in = in;		/* struct copy */
	segp->seg_out = out;		/* struct copy */
	return(segp);			/* HIT */
@


1.10
log
@Bug fixes concerning correct calculation of center (Gwyn, Muuss).
@
text
@d16 1
a16 1
 * $Revision: 1.9 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb8.c,v 1.9 84/05/03 06:54:27 mike Exp $ (BRL)";
a48 1
	static fastf_t	scale;		/* width across widest axis */
d63 3
a65 3
	vec[3] = 1;					/* cvt to homog vec */
	matXvec( work, mat, vec );			/* 4x4: xlate, too */
	htov_move( vec, work );				/* divide out W */
a67 1
	VMOVE( sum, vec );				/* sum=0th element */
a344 1
		FAST fastf_t f;
d368 1
a368 1
			VCOMPOSE1( hit_pt, rp->r_pt, k, rp->r_dir );
d392 1
a392 1
			VCOMPOSE1( hit_pt, rp->r_pt, k, rp->r_dir );
d458 1
a458 1
	VCOMPOSE1( hit_pt, rp->r_pt, k, rp->r_dir );
@


1.9
log
@Performance enhancements, ARS fixes.
@
text
@d16 1
a16 1
 * $Revision: 1.8 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb8.c,v 1.8 84/05/02 05:09:49 mike Exp $ (BRL)";
d47 1
d69 1
d73 1
d78 7
a84 2
	 * Compute bounding sphere.
	 * Find min and max of the point co-ordinates
d86 1
a86 9
	op = &vec[0];
	for( i=0; i< 8; i++ ) {
		MINMAX( xmin, xmax, *op++ );
		MINMAX( ymin, ymax, *op++ );
		MINMAX( zmin, zmax, *op++ );
		op++;		/* Depends on ELEMENTS_PER_VECT */
	}
	VSET( stp->st_center,
		(xmax + xmin)/2, (ymax + ymin)/2, (zmax + zmin)/2 );
a87 4
	dx = (xmax - xmin)/2;
	dy = (ymax - ymin)/2;
	dz = (zmax - zmin)/2;
	stp->st_radsq = dx*dx + dy*dy + dz*dz;
d106 6
a111 2
	if( faces >= 4  && faces <= 6 )
		return(0);		/* OK */
d113 21
a133 3
	printf("arb8(%s):  only %d faces present\n", stp->st_name, faces);
	/* Should free storage for good faces */
	return(1);			/* Error */
d262 3
d266 4
a269 7
		if( NEAR_ZERO(f) )  {
			plp->pl_2d_x[i] = VDOT( P_A, plp->pl_Xbasis );
			plp->pl_2d_y[i] = VDOT( P_A, plp->pl_Ybasis );
			return(1);			/* OK */
		}
		if( noise )  {
			printf("ERROR: arb8(%s) face %s non-planar\n",
d271 6
d278 1
a278 3
		plp->pl_npts--;
		plp->pl_code[i] = '\0';
		return(0);				/* BAD */
d432 4
@


1.8
log
@More ARS support, fixes of all kinds.
@
text
@d16 1
a16 1
 * $Revision: 1.7 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb8.c,v 1.7 84/05/01 06:38:59 mike Exp $ (BRL)";
d216 3
a218 5
		/* Check for co-linear, ie, abs( (B-A).(C-A) ) == mag*mag */
		f = VDOT( plp->pl_Xbasis, P_A );
		if( f < 0.0 )
			f = -f;
		f -= ( MAGNITUDE(P_A) * MAGNITUDE(plp->pl_Xbasis) );
a223 1
		VCROSS( plp->pl_N, plp->pl_Xbasis, P_A );
d227 2
a228 4
		 *  For some reason, some (but not all) of the normals
		 *  come out pointing inwards.  Rather than try to understand
		 *  this, I'm just KLUDGEING it for now, because we have
		 *  enough information to fix it up.  1000 pardons.
a232 1
/**			printf("WARNING: arb8(%s) face %s has bad normal!  (A-cent).N=%f\n", stp->st_name, plp->pl_code, f); * */
d236 1
a236 1
		VCROSS( plp->pl_Ybasis, plp->pl_N, plp->pl_Xbasis );
d314 3
d324 1
a324 1
		static fastf_t k;	/* (NdotA - (N dot P))/ (N dot D) */
d332 5
a336 1
		if( NEAR_ZERO(dn) )
d344 1
a344 2
			f = k - in.hit_dist;
			if( NEAR_ZERO( f ) )  {
d348 16
a363 2
			if( pl_shot( plp, rp, &in, k ) != 0 )
				continue;
d368 1
a368 2
			f = k - out.hit_dist;
			if( NEAR_ZERO( f ) )  {
d372 16
a387 2
			if( pl_shot( plp, rp, &out, k ) != 0 )
				continue;
d396 12
a407 4
		/* it may start inside, but it can always leave */
		printf("Error: arb8(%s) ray never exited solid!\n",
			stp->st_name);
		return(SEG_NULL);		/* MISS */
d421 3
d433 1
a433 1
	FAST fastf_t	xt, yt;
a440 4
	if( debug & DEBUG_ARB8 )  {
		printf("k = %f, xt,yt=(%f,%f), ", k, xt, yt );
		VPRINT("hit_pt", hit_pt);
	}
a451 1
	if( debug & DEBUG_ARB8 )  printf("\t[Above was a hit]\n");
@


1.7
log
@Modifications for ARS, code unified to use fastf_t
@
text
@d16 1
a16 1
 * $Revision: 1.5 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb8.c,v 1.5 84/04/26 06:49:03 mike Exp $ (BRL)";
d67 1
a67 1
	op = &vec[1*3];
d216 5
a220 2
		f = VDOT( plp->pl_Xbasis, P_A ) -
			( MAGNITUDE(P_A) * MAGNITUDE(plp->pl_Xbasis) );
@


1.6
log
@Initial ARS hooks
@
text
@a24 1
#include "db.h"
d30 1
a30 1
#define MINMAX(a,b,c)	{ FAST float ftemp;\
d37 2
a38 2
arb8_prep( sp, stp, mat )
struct solidrec *sp;
d42 3
a44 3
	register float *op;		/* Used for scanning vectors */
	static float xmax, ymax, zmax;	/* For finding the bounding spheres */
	static float xmin, ymin, zmin;	/* For finding the bounding spheres */
a46 1
	static vect_t	homog;		/* Vect/Homog.Vect conversion buf */
d60 1
a60 1
	 * Convert from vector to point notation IN PLACE in s_values[]
d63 3
a65 5
	VMOVE( homog, &sp->s_values[0] );		/* cvt to fastf_t */
	homog[3] = 1;					/* & to homog vec */
	matXvec( work, mat, homog );			/* 4x4: xlate, too */
	htov_move( homog, work );			/* divide out W */
	VMOVE( &sp->s_values[0], homog );		/* cvt to float */
d67 1
a67 1
	op = &sp->s_values[1*3];
d69 3
a71 3
		MAT3XVEC( homog, mat, op );		/* 3x3: rot only */
		VADD2( op, &sp->s_values[0], homog );
		op += 3;
d78 1
a78 1
	op = &sp->s_values[0];
d83 1
d94 1
a94 1
#define P(x)	(&sp->s_values[(x)*3])
d124 1
a124 1
 *  ap, bp, cp, dp point to float[3] (NOT fastf_t) points.
d134 1
a134 1
float *ap, *bp, *cp, *dp;			/* not pointp_t */
d182 1
a182 1
register float *point;
d191 1
a191 1
	static float f;
@


1.5
log
@More twiddles for fastf_t -vs- htov_move().
@
text
@d16 1
a16 1
 * $Revision: 1.4 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb8.c,v 1.4 84/04/26 05:34:11 mike Exp $ (BRL)";
d27 1
d31 1
a31 18
#define MAXPTS	4			/* All we need are 4 points */
#define pl_A	pl_points[0]		/* Synonym for A point */

struct plane_specific  {
	int	pl_npts;		/* number of points on plane */
	point_t	pl_points[MAXPTS];	/* Actual points on plane */
	vect_t	pl_Xbasis;		/* X (B-A) vector (for 2d coords) */
	vect_t	pl_Ybasis;		/* Y (C-A) vector (for 2d coords) */
	vect_t	pl_N;			/* Unit-length Normal (outward) */
	fastf_t	pl_NdotA;		/* Normal dot A */
	fastf_t	pl_2d_x[MAXPTS];	/* X 2d-projection of points */
	fastf_t	pl_2d_y[MAXPTS];	/* Y 2d-projection of points */
	fastf_t	pl_2d_com[MAXPTS];	/* pre-computed common-term */
	struct plane_specific *pl_forw;	/* Forward link */
	char	pl_code[MAXPTS+1];	/* Face code string.  Decorative. */
};

#define MINMAX(a,b,c)	{ static float ftemp;\
d35 3
d97 1
d99 14
a112 14
	faces += face( sp->s_values, stp, 3, 2, 1, 0 );	/* 1234 */
	faces += face( sp->s_values, stp, 4, 5, 6, 7 );	/* 8765 */
	faces += face( sp->s_values, stp, 4, 7, 3, 0 );	/* 1485 */
	faces += face( sp->s_values, stp, 2, 6, 5, 1 );	/* 2673 */
	faces += face( sp->s_values, stp, 1, 5, 4, 0 );	/* 1562 */
	faces += face( sp->s_values, stp, 7, 6, 2, 3 );	/* 4378 */
#ifdef reversed
	faces += face( sp->s_values, stp, 0, 1, 2, 3 );	/* 1234 */
	faces += face( sp->s_values, stp, 7, 6, 5, 4 );	/* 8765 */
	faces += face( sp->s_values, stp, 0, 3, 7, 4 );	/* 1485 */
	faces += face( sp->s_values, stp, 1, 5, 6, 2 );	/* 2673 */
	faces += face( sp->s_values, stp, 0, 4, 5, 1 );	/* 1562 */
	faces += face( sp->s_values, stp, 3, 2, 6, 7 );	/* 4378 */
#endif
d121 14
a134 3
/*static */
face( vects, stp, a, b, c, d )
register float vects[];
d137 2
d146 4
a149 4
	pts = add_pt( vects, stp, plp, a );
	pts += add_pt( vects, stp, plp, b );
	pts += add_pt( vects, stp, plp, c );
	pts += add_pt( vects, stp, plp, d );
d172 1
a172 1
	return(1);					/* OK */
d175 11
a185 5
#define VERT(x)	(&vects[(x)*3])

/*static */
add_pt( vects, stp, plp, a )
float *vects;
d189 1
a191 1
	register float *point;
a195 2
	point = VERT(a);

d256 4
a259 2
		printf("ERROR: arb8(%s) face %s non-planar\n",
			stp->st_name, plp->pl_code );
d266 3
d384 3
@


1.4
log
@Improved speed.
@
text
@d16 1
a16 1
 * $Revision: 1.3 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb8.c,v 1.3 84/04/25 06:20:03 mike Exp $ (BRL)";
d47 1
a47 1
#define MINMAX(a,b,c)	{ register float ftemp;\
a64 1
	static vect_t	V;		/* vertex */
d75 1
a75 1
	 * Convert from vector to point notation in place
d78 5
a82 4
	VMOVE( V, sp->s_values );	/* cvt to fastf_t */
	vtoh_move( homog, V );
	matXvec( work, mat, homog );
	htov_move( V, work );		/* divide out W */
d86 2
a87 2
		MAT3XVEC( homog, mat, op );
		VADD2( op, V, homog );
@


1.3
log
@Major rewrite.  No longer uses triangles;  instead, now
projects into 2-d problem and uses Gwyn's INSIDE routine.
@
text
@d16 1
a16 1
 * $Revision: 1.2 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb8.c,v 1.2 84/04/18 02:19:20 mike Exp $ (BRL)";
d39 4
a42 3
	float	pl_NdotA;		/* Normal dot A */
	float	pl_2d_x[MAXPTS];	/* X 2d-projection of points */
	float	pl_2d_y[MAXPTS];	/* Y 2d-projection of points */
d59 1
a59 1
	static float dx, dy, dz;	/* For finding the bounding spheres */
d63 1
a63 1
	static float	scale;		/* width across widest axis */
d65 1
d79 2
a80 1
	vtoh_move( homog, sp->s_values );
d82 1
a82 1
	htov_move( sp->s_values, work );		/* divide out W */
d87 1
a87 1
		VADD2( op, sp->s_values, homog );
d141 1
d157 11
d184 1
a184 1
	register pointp_t point;
d224 6
a229 1
		/* Extra checking:  test for outward normal direction */
d233 2
a234 7
			printf("WARNING: arb8(%s) face %s has bad normal!  (A-cent).N=%f\n", stp->st_name, plp->pl_code, f);
			VPRINT("(A-cent)", work);
			VPRINT("N", plp->pl_N);
			/* HACK HACK HACK -- "fix" normal */
			plp->pl_N[0] = - plp->pl_N[0];
			plp->pl_N[1] = - plp->pl_N[1];
			plp->pl_N[2] = - plp->pl_N[2];
d303 1
a303 1
struct ray *rp;
d316 3
a318 2
		register float dn;	/* Direction dot Normal */
		static float k;		/* (NdotA - (N dot P))/ (N dot D) */
d333 2
a334 1
			if( NEAR_ZERO( k - in.hit_dist ) )  {
d344 2
a345 1
			if( NEAR_ZERO( k - out.hit_dist ) )  {
d366 1
a366 1
	GETSTRUCT(segp, seg);
d369 2
a370 2
	segp->seg_in = in;
	segp->seg_out = out;
d378 1
a378 1
register float	k;			/* dist along ray */
d382 1
a382 1
	static float	xt, yt;
d385 1
d394 5
a398 1
	if( !inside( xt, yt, plp->pl_2d_x, plp->pl_2d_y, plp->pl_npts ) )
d434 3
a436 3
inside( xt, yt, x, y, n )
register float xt, yt;
register float *x, *y;
d439 1
a439 1
	register float *xend = &x[n];
d446 2
a447 1
	for( ret=0; x < xend; x++,y++ )  {
d449 1
a449 1
		if( (yt  > *y || yt <= y[1])  &&  (yt <= *y || yt >  y[1]) )
d452 1
a452 1
		if( (xt - *x - (yt - *y) * (x[1] - *x) / (y[1] - *y)) < 0.0 )
@


1.2
log
@Boolean operation support
@
text
@d8 4
a11 3
 *  Authors -
 *	Edwin O. Davisson	(Analysis)
 *	Michael John Muuss	(Programming)
d14 1
a14 1
 * March 29, 1984.
d16 1
a16 1
 * $Revision: 1.1 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: arb8.c,v 1.1 84/04/02 16:41:33 mike Exp $ (BRL)";
d30 14
a43 12
struct triangle_specific  {
	struct triangle_specific *tri_forw;	/* Forward link */
	vect_t	tri_A;		/* A, temp */
	vect_t	tri_B;		/* B, temp */
	vect_t	tri_C;		/* C, temp */
	vect_t	tri_AxB;	/* VCROSS( A, B ) */
	vect_t	tri_BxC;	/* VCROSS( B, C ) */
	vect_t	tri_CxA;	/* VCROSS( C, A ) */
	vect_t	tri_Q;		/* (B-A) cross (C-A) */
	vect_t	tri_N;		/* Unit-length Normal (from Q) */
	float	tri_vol;	/* Q dot A */
	char	tri_code[4];	/* face code string.  Decorative. */
a49 2
static struct triangle_specific *facet();

d61 1
a61 1
	static int	facets;		/* # of facets produced */
d66 2
a67 2
	xmax = ymax = zmax = -100000000.0;
	xmin = ymin = zmin =  100000000.0;
d105 1
d107 7
a113 7
	facets = 0;
	facets += face( sp->s_values, stp, 3, 2, 1, 0 );	/* 1234 */
	facets += face( sp->s_values, stp, 4, 5, 6, 7 );	/* 8765 */
	facets += face( sp->s_values, stp, 4, 7, 3, 0 );	/* 1485 */
	facets += face( sp->s_values, stp, 2, 6, 5, 1 );	/* 2673 */
	facets += face( sp->s_values, stp, 1, 5, 4, 0 );	/* 1562 */
	facets += face( sp->s_values, stp, 7, 6, 2, 3 );	/* 4378 */
d115 6
a120 6
	facets += face( sp->s_values, stp, 0, 1, 2, 3 );	/* 1234 */
	facets += face( sp->s_values, stp, 7, 6, 5, 4 );	/* 8765 */
	facets += face( sp->s_values, stp, 0, 3, 7, 4 );	/* 1485 */
	facets += face( sp->s_values, stp, 1, 5, 6, 2 );	/* 2673 */
	facets += face( sp->s_values, stp, 0, 4, 5, 1 );	/* 1562 */
	facets += face( sp->s_values, stp, 3, 2, 6, 7 );	/* 4378 */
d122 1
a122 1
	if( facets >= 4  && facets <= 12 )
d125 2
a126 2
	printf("arb8(%s):  only %d facets present\n", stp->st_name, facets);
	/* Should free storage for good facets */
d130 1
a130 3
#define VERT(x)	(&vects[(x)*3])

static
d136 2
a137 4
	register struct triangle_specific *trip1;
	register struct triangle_specific *trip2;
	static vect_t X_A;
	static float f;
d139 6
a144 3
if(debug&DEBUG_ARB8)printf("face %d%d%d%d\n", a, b, c, d );
	trip1 = facet( vects, stp, a, b, c );
	trip2 = facet( vects, stp, a, c, d );
d146 3
a148 13
if(debug&DEBUG_ARB8)printf("face values x%x x%x\n", trip1, trip2);
	if( trip1 && trip2 )  {
		/*
		 *  If both facets exist, check to see if face is planar.
		 *  Check [ (B-A)x(C-A) ] dot (D-A) == 0
		 */
		VSUB2( X_A, VERT(d), VERT(a) );
		f = VDOT( trip1->tri_Q, X_A );
		if( NEAR_ZERO(f) )
			return(2);		/* OK */
		printf("arb8(%s):  face %d,%d,%d,%d non-planar (dot=%f)\n",
			stp->st_name, a,b,c,d, f);
		return(0);			/* BAD */
d150 7
a156 3
	if( trip1 || trip2 )
		return(1);			/* OK */
	return(0);				/* BAD */
d159 5
a163 3
static struct triangle_specific *
facet( vects, stp, a, b, c )
register float *vects;
d165 2
a166 1
int a, b, c;
d168 5
a172 5
	register struct triangle_specific *trip;
	static vect_t B_A;		/* B - A */
	static vect_t C_A;		/* C - A */
	static vect_t B_C;		/* B - C */
	static float scale;		/* for scaling normal vector */
d174 1
a174 3
	VSUB2( B_A, VERT(b), VERT(a) );
	VSUB2( C_A, VERT(c), VERT(a) );
	VSUB2( B_C, VERT(b), VERT(c) );
d176 10
a185 4
	/* If points are coincident, ignore facet */
	if( MAGSQ( B_A ) < EPSILON )  return(0);
	if( MAGSQ( C_A ) < EPSILON )  return(0);
	if( MAGSQ( B_C ) < EPSILON )  return(0);
d187 21
a207 1
	GETSTRUCT( trip, triangle_specific );
d209 32
a240 18
	VMOVE( trip->tri_A, VERT(a) );	/* Temp */
	VMOVE( trip->tri_B, VERT(b) );
	VMOVE( trip->tri_C, VERT(c) );
	trip->tri_code[0] = '0'+a;
	trip->tri_code[1] = '0'+b;
	trip->tri_code[2] = '0'+c;
	trip->tri_code[3] = '\0';

	VCROSS( trip->tri_AxB, VERT(a), VERT(b) );
	VCROSS( trip->tri_BxC, VERT(b), VERT(c) );
	VCROSS( trip->tri_CxA, VERT(c), VERT(a) );
	VCROSS( trip->tri_Q, B_A, C_A );
	trip->tri_vol = VDOT( trip->tri_Q, VERT(a) );
	if( NEAR_ZERO(trip->tri_vol) )  {
		printf("arb8(%s): Zero volume (%f), facet %s dropped\n",
			stp->st_name, trip->tri_vol, trip->tri_code );
		free(trip);
		return(0);		/* FAIL */
a241 10

	/* Compute Normal with unit length, and outward direction */
	scale = 1.0 / MAGNITUDE( trip->tri_Q );
	VSCALE( trip->tri_N, trip->tri_Q, scale );

	/* Add to linked list */
	trip->tri_forw = (struct triangle_specific *)stp->st_specific;
	stp->st_specific = (int *)trip;

	return(trip);
d247 3
a249 2
	register struct triangle_specific *trip =
		(struct triangle_specific *)stp->st_specific;
d251 2
a252 2
	if( trip == (struct triangle_specific *)0 )  {
		printf("arb8(%s):  no facets\n", stp->st_name);
d256 17
a272 11
		printf( "......Facet %s\n", trip->tri_code );
		VPRINT( "A", trip->tri_A );
		VPRINT( "B", trip->tri_B );
		VPRINT( "C", trip->tri_C );
		VPRINT( "AxB", trip->tri_AxB );
		VPRINT( "BxC", trip->tri_BxC );
		VPRINT( "CxA", trip->tri_CxA );
		VPRINT( "Q", trip->tri_Q );
		printf( "Vol=Q.A=%f\n", trip->tri_vol );
		VPRINT( "Normal", trip->tri_N );
	} while( trip = trip->tri_forw );
d290 2
a291 2
	register struct triangle_specific *trip =
		(struct triangle_specific *)stp->st_specific;
d296 1
a296 1
	in.hit_dist = out.hit_dist = -1000000;	/* 'way back behind eye */
d299 4
a302 3
	for( ; trip; trip = trip->tri_forw )  {
		register float dq;	/* D dot Q */
		static float k;		/* (vol - (Q dot P))/ (Q dot D) */
d304 1
a304 1
		 *  Ray Direction dot Q.  (Q is outward-pointing normal)
d306 1
a306 1
		dq = VDOT( trip->tri_Q, rp->r_dir );
d308 2
a309 2
			printf("Shooting at face %s.  Q.D=%f\n", trip->tri_code, dq );
		if( NEAR_ZERO(dq) )
d313 1
a313 1
		k = (trip->tri_vol - VDOT(trip->tri_Q, rp->r_pt)) / dq;
d315 1
a315 1
		if( dq < 0 )  {
d321 1
a321 1
			if( tri_shot( trip, rp, &in, k ) != 0 )
d323 1
a323 1
			if(debug&DEBUG_ARB8) printf("arb8: entry dist=%f, dq=%f, k=%f\n", in.hit_dist, dq, k );
d331 1
a331 1
			if( tri_shot( trip, rp, &out, k ) != 0 )
d333 1
a333 1
			if(debug&DEBUG_ARB8) printf("arb8: exit dist=%f, dq=%f, k=%f\n", out.hit_dist, dq, k );
d340 8
d356 2
a357 2
tri_shot( trip, rp, hitp, k )
register struct triangle_specific *trip;
d360 1
a360 1
register float	k;			/* (v - (Q dot P))/ (Q dot D) */
a361 1
	static float	av, bv, cv;	/* coeff's of linear combination */
d363 2
d367 3
a370 3
	av = VDOT( hit_pt, trip->tri_BxC );
	bv = VDOT( hit_pt, trip->tri_CxA );
	cv = VDOT( hit_pt, trip->tri_AxB );
d372 1
a372 1
		printf("k = %f,  ", k );
a373 1
		printf("av=%f, bv=%f, cv=%f\n", av, bv, cv);
d375 2
d378 1
a378 24
	{
		register float f;		/* XXX */
		f = av + bv + cv - trip->tri_vol;
		if( !NEAR_ZERO(f) )
			return(1);		/* MISS */
	}
	if( av < 0.0 )  {
		if( bv > 0.0 || cv > 0.0 )
			return(1);		/* MISS */
	} else if( av > 0.0 )  {
		if( bv < 0.0 || cv < 0.0 )
			return(1);		/* MISS */
	} else {
		/* av == 0.0 */
		if( bv < 0.0 )  {
			if( cv > 0.0 )
				return(1);	/* MISS */
		} else if( bv > 0.0 )  {
			if( cv < 0.0 )
				return(1);	/* MISS */
		} /* av == bv == 0.0 */
	}

	/* Hit is within the triangle */
d381 1
a381 1
	VMOVE( hitp->hit_normal, trip->tri_N );
d384 48
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
 * $Revision$
d18 1
a18 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
a59 1
	static mat_t	special;	/* Special, no xlate Rotation Mat */
a68 8
	 * Build the Special Matrix,
	 * which does not have the translation
	 * factor, for rotating/scaling relative vectors.
	 */
	mat_copy( special, mat );
	special[3] = special[7] = special[11] = 0.0;

	/*
d78 1
a78 1
	htov_move( sp->s_values, work );
d82 1
a82 3
		vtoh_move( homog, op );
		matXvec( work, special, homog );
		htov_move( homog, work );		/* divide out W */
d141 1
a141 1
if(debug&DEBUG_TESTING)printf("face %d%d%d%d\n", a, b, c, d );
d145 1
a145 1
if(debug&DEBUG_TESTING)printf("face values x%x x%x\n", trip1, trip2);
d153 1
a153 1
		if( f == 0.0 )
d242 11
a252 2
extern struct seg *HeadSeg;	/* Pointer to segment list */

d263 2
a264 2
	in.hit_dist = 1000000;
	out.hit_dist = -100000;
a270 3
		 *  	> 0	exiting solid
		 *  	==0	parallel to solid
		 *  	< 0	entering solid
d273 1
a273 1
		if( debug & DEBUG_TESTING )
d284 1
a284 1
				if( debug & DEBUG_TESTING)printf("skipping nearby entry surface, k=%f\n", k);
d289 1
d294 1
a294 1
				if( debug & DEBUG_TESTING)printf("skipping nearby exit surface, k=%f\n", k);
d299 1
d304 1
a304 1
		return(1);		/* MISS */
d311 1
a311 3
	segp->seg_next = HeadSeg;
	HeadSeg = segp;
	return(0);			/* HIT */
d328 1
a328 1
	if( debug & DEBUG_TESTING )  {
d361 1
a361 1
	if( debug & DEBUG_TESTING )  printf("\t[Above was a hit]\n");
@
