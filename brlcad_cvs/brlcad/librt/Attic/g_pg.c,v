head	11.47;
access;
symbols
	ansi-20040405-merged:11.42.2.2
	postmerge-20040405-ansi:11.45
	premerge-20040404-ansi:11.44
	postmerge-autoconf:11.44
	autoconf-freeze:11.43.6.2
	premerge-autoconf:11.44
	ansi-20040316-freeze:11.42.2.1
	postmerge-20040315-windows:11.44
	premerge-20040315-windows:11.44
	windows-20040315-freeze:11.42.4.1
	autoconf-20031203:11.43
	autoconf-20031202:11.43
	autoconf-branch:11.43.0.6
	phong-branch:11.43.0.4
	photonmap-branch:11.43.0.2
	rel-6-1-DP:11.42
	windows-branch:11.42.0.4
	rel-6-0-2:11.40
	ansi-branch:11.42.0.2
	rel-6-0-1-branch:11.40.0.2
	hartley-6-0-post:11.41
	hartley-6-0-pre:11.40
	rel-6-0-1:11.40
	rel-6-0:11.40
	rel-5-4:11.22
	offsite-5-3-pre:11.34
	rel-5-3:11.22
	rel-5-2:11.22
	rel-5-1-branch:11.22.0.2
	rel-5-1:11.22
	rel-5-0:11.15
	rel-5-0-beta:11.14
	rel-4-5:11.11
	ctj-4-5-post:11.11
	ctj-4-5-pre:11.11
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.47
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.46;

11.46
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.45;

11.45
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.44;

11.44
date	2004.02.02.17.39.21;	author morrison;	state Exp;
branches;
next	11.43;

11.43
date	2002.11.27.13.42.56;	author jra;	state Exp;
branches
	11.43.6.1;
next	11.42;

11.42
date	2002.08.20.17.08.00;	author jra;	state Exp;
branches
	11.42.2.1
	11.42.4.1;
next	11.41;

11.41
date	2002.08.15.20.55.13;	author hartley;	state Exp;
branches;
next	11.40;

11.40
date	2002.02.12.19.18.33;	author morrison;	state Exp;
branches;
next	11.39;

11.39
date	2001.11.08.22.36.34;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	2001.10.04.18.40.39;	author tranese;	state Exp;
branches;
next	11.37;

11.37
date	2001.10.02.19.24.30;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	2001.05.17.20.05.24;	author morrison;	state Exp;
branches;
next	11.35;

11.35
date	2001.04.20.22.29.46;	author morrison;	state Exp;
branches;
next	11.34;

11.34
date	2000.11.17.06.01.56;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	2000.10.24.19.13.01;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	2000.10.24.14.44.43;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	2000.09.08.05.54.42;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	2000.08.10.04.57.23;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.07.13.02.36.26;	author cjohnson;	state Exp;
branches;
next	11.28;

11.28
date	2000.07.12.21.56.21;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.07.10.23.01.33;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.07.06.22.45.54;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.06.30.15.38.03;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.06.30.15.31.15;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.06.29.14.42.36;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	2000.06.08.19.58.24;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	2000.05.11.21.21.17;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.04.12.02.34.35;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.12.22.02.18.00;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	99.11.26.21.46.48;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	99.11.17.02.42.00;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	99.10.30.03.53.27;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.07.02.22.19.23;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	99.05.27.19.10.40;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	99.05.11.14.45.48;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	98.07.09.14.18.16;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	97.06.11.17.34.40;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	97.06.04.20.14.58;	author gdurf;	state Exp;
branches;
next	11.9;

11.9
date	97.04.17.20.59.05;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	97.03.11.16.11.44;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	97.01.30.15.39.39;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	97.01.23.14.22.00;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	97.01.23.14.19.09;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.10.11.17.56.32;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.11.02.18.53.53;	author cjohnson;	state Exp;
branches;
next	11.2;

11.2
date	95.03.29.20.40.26;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.52;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.09.13.15.51.51;	author jra;	state Exp;
branches;
next	10.6;

10.6
date	94.09.02.16.03.32;	author jra;	state Exp;
branches;
next	10.5;

10.5
date	94.08.10.18.38.26;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.06.08.11.37.51;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	93.11.18.01.44.07;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.03.26.22.01.52;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.21;	author mike;	state Rel4_0;
branches;
next	9.17;

9.17
date	91.07.27.00.55.04;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.06.30.00.10.55;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.06.22.22.30.30;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.06.12.20.57.43;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.05.18.03.01.14;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.04.01.19.59.39;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.02.27.21.05.45;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.02.07.20.32.22;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.01.28.23.53.15;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.01.26.03.14.53;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.01.25.21.19.11;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.01.15.23.41.25;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.10.06.02.05.16;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.05.18.07.25.41;	author butler;	state Exp;
branches;
next	9.3;

9.3
date	90.04.28.03.30.06;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.03.14.15.05.53;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.19;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.04.17.17.19.45;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.11.12.24.58;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	89.03.14.02.00.41;	author phil;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.02.41;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.31.28;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.05.14.00.47.45;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.05.14.00.01.11;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.06.05.36.39;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.33.45;	author mike;	state Rel;
branches;
next	6.4;

6.4
date	87.09.26.03.09.45;	author mike;	state Exp;
branches;
next	6.3;

6.3
date	87.09.17.07.00.33;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.09.17.02.24.05;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.56.03;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.11.48;	author mike;	state Rel;
branches;
next	4.4;

4.4
date	87.03.23.23.41.56;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.03.10.23.42.56;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.12.22.11.30;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.45.28;	author mike;	state Rel1;
branches;
next	3.5;

3.5
date	86.12.24.08.05.53;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.08.12.04.16.00;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.19.04.42.13;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.17.18.19.47;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.11.01.32.15;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.33.18;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.06.09.21.50.38;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.09.24.18.33.18;	author mike;	state Exp;
branches;
next	;

11.42.2.1
date	2002.09.19.18.01.35;	author morrison;	state Exp;
branches;
next	11.42.2.2;

11.42.2.2
date	2004.03.17.21.18.47;	author morrison;	state Exp;
branches;
next	;

11.42.4.1
date	2004.03.11.23.43.38;	author morrison;	state Exp;
branches;
next	;

11.43.6.1
date	2004.02.12.18.37.41;	author erikg;	state Exp;
branches;
next	11.43.6.2;

11.43.6.2
date	2004.03.15.14.07.19;	author erikg;	state Exp;
branches;
next	;


desc
@Routines to handle explicit polygonal solids.
@


11.47
log
@moved to src/
@
text
@/*
 *			G _ P G . C
 *
 *  Function -
 *	Intersect a ray with a Polygonal Object
 *	that has no explicit topology.
 *	It is assumed that the solid has no holes.
 *  
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSpg[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_pg.c,v 11.46 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "./debug.h"
#include "./plane.h"

#define TRI_NULL	((struct tri_specific *)0)

HIDDEN int rt_pgface(struct soltab *stp, fastf_t *ap, fastf_t *bp, fastf_t *cp, const struct bn_tol *tol);

/* Describe algorithm here */


/*
 *			R T _ P G _ P R E P
 *  
 *  This routine is used to prepare a list of planar faces for
 *  being shot at by the triangle routines.
 *
 * Process a PG, which is represented as a vector
 * from the origin to the first point, and many vectors
 * from the first point to the remaining points.
 *  
 */
int
rt_pg_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_pg_internal	*pgp;
	register int	i;
	int		p;

	pgp = (struct rt_pg_internal *)ip->idb_ptr;
	RT_PG_CK_MAGIC(pgp);

	for( p = 0; p < pgp->npoly; p++ )  {
		LOCAL vect_t	work[3];

		VMOVE( work[0], &pgp->poly[p].verts[0*3] );
		VMINMAX( stp->st_min, stp->st_max, work[0] );
		VMOVE( work[1], &pgp->poly[p].verts[1*3] );
		VMINMAX( stp->st_min, stp->st_max, work[1] );

		for( i=2; i < pgp->poly[p].npts; i++ )  {
			VMOVE( work[2], &pgp->poly[p].verts[i*3] );
			VMINMAX( stp->st_min, stp->st_max, work[2] );

			/* output a face */
			(void)rt_pgface( stp,
				work[0], work[1], work[2], &rtip->rti_tol );

			/* Chop off a triangle, and continue */
			VMOVE( work[1], work[2] );
		}
	}
	if( stp->st_specific == (genptr_t)0 )  {
		bu_log("pg(%s):  no faces\n", stp->st_name);
		return(-1);		/* BAD */
	}

	{
		LOCAL fastf_t dx, dy, dz;
		LOCAL fastf_t	f;

		VADD2SCALE( stp->st_center, stp->st_max, stp->st_min, 0.5 );

		dx = (stp->st_max[X] - stp->st_min[X])/2;
		f = dx;
		dy = (stp->st_max[Y] - stp->st_min[Y])/2;
		if( dy > f )  f = dy;
		dz = (stp->st_max[Z] - stp->st_min[Z])/2;
		if( dz > f )  f = dz;
		stp->st_aradius = f;
		stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);
	}

	return(0);		/* OK */
}

/*
 *			R T _ P G F A C E
 *
 *  This function is called with pointers to 3 points,
 *  and is used to prepare PG faces.
 *  ap, bp, cp point to vect_t points.
 *
 * Return -
 *	0	if the 3 points didn't form a plane (eg, colinear, etc).
 *	#pts	(3) if a valid plane resulted.
 */
HIDDEN int
rt_pgface(struct soltab *stp, fastf_t *ap, fastf_t *bp, fastf_t *cp, const struct bn_tol *tol)
{
	register struct tri_specific *trip;
	vect_t work;
	LOCAL fastf_t m1, m2, m3, m4;

	BU_GETSTRUCT( trip, tri_specific );
	VMOVE( trip->tri_A, ap );
	VSUB2( trip->tri_BA, bp, ap );
	VSUB2( trip->tri_CA, cp, ap );
	VCROSS( trip->tri_wn, trip->tri_BA, trip->tri_CA );

	/* Check to see if this plane is a line or pnt */
	m1 = MAGNITUDE( trip->tri_BA );
	m2 = MAGNITUDE( trip->tri_CA );
	VSUB2( work, bp, cp );
	m3 = MAGNITUDE( work );
	m4 = MAGNITUDE( trip->tri_wn );
	if( m1 < tol->dist || m2 < tol->dist ||
	    m3 < tol->dist || m4 < tol->dist )  {
		bu_free( (char *)trip, "getstruct tri_specific");
		if( RT_G_DEBUG & DEBUG_ARB8 )
			bu_log("pg(%s): degenerate facet\n", stp->st_name);
		return(0);			/* BAD */
	}		

	/*  wn is a normal of not necessarily unit length.
	 *  N is an outward pointing unit normal.
	 *  We depend on the points being given in CCW order here.
	 */
	VMOVE( trip->tri_N, trip->tri_wn );
	VUNITIZE( trip->tri_N );

	/* Add this face onto the linked list for this solid */
	trip->tri_forw = (struct tri_specific *)stp->st_specific;
	stp->st_specific = (genptr_t)trip;
	return(3);				/* OK */
}

/*
 *  			R T _ P G _ P R I N T
 */
void
rt_pg_print(register const struct soltab *stp)
{
	register const struct tri_specific *trip =
		(struct tri_specific *)stp->st_specific;

	if( trip == TRI_NULL )  {
		bu_log("pg(%s):  no faces\n", stp->st_name);
		return;
	}
	do {
		VPRINT( "A", trip->tri_A );
		VPRINT( "B-A", trip->tri_BA );
		VPRINT( "C-A", trip->tri_CA );
		VPRINT( "BA x CA", trip->tri_wn );
		VPRINT( "Normal", trip->tri_N );
		bu_log("\n");
	} while( (trip = trip->tri_forw) );
}

/*
 *			R T _ P G _ S H O T
 *  
 * Function -
 *	Shoot a ray at a polygonal object.
 *  
 * Returns -
 *	0	MISS
 *	>0	HIT
 */
int
rt_pg_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct tri_specific *trip =
		(struct tri_specific *)stp->st_specific;
#define MAXHITS 128		/* # surfaces hit, must be even */
	LOCAL struct hit hits[MAXHITS];
	register struct hit *hp;
	LOCAL int	nhits;

	nhits = 0;
	hp = &hits[0];

	/* consider each face */
	for( ; trip; trip = trip->tri_forw )  {
		FAST fastf_t	dn;		/* Direction dot Normal */
		LOCAL fastf_t	abs_dn;
		FAST fastf_t	k;
		LOCAL fastf_t	alpha, beta;
		LOCAL vect_t	wxb;		/* vertex - ray_start */
		LOCAL vect_t	xp;		/* wxb cross ray_dir */

		/*
		 *  Ray Direction dot N.  (N is outward-pointing normal)
		 *  wn points inwards, and is not unit length.
		 */
		dn = VDOT( trip->tri_wn, rp->r_dir );

		/*
		 *  If ray lies directly along the face, (ie, dot product
		 *  is zero), drop this face.
		 */
		abs_dn = dn >= 0.0 ? dn : (-dn);
		if( abs_dn < SQRT_SMALL_FASTF )
			continue;
		VSUB2( wxb, trip->tri_A, rp->r_pt );
		VCROSS( xp, wxb, rp->r_dir );

		/* Check for exceeding along the one side */
		alpha = VDOT( trip->tri_CA, xp );
		if( dn < 0.0 )  alpha = -alpha;
		if( alpha < 0.0 || alpha > abs_dn )
			continue;

		/* Check for exceeding along the other side */
		beta = VDOT( trip->tri_BA, xp );
		if( dn > 0.0 )  beta = -beta;
		if( beta < 0.0 || beta > abs_dn )
			continue;
		if( alpha+beta > abs_dn )
			continue;
		k = VDOT( wxb, trip->tri_wn ) / dn;

		/* For hits other than the first one, might check
		 *  to see it this is approx. equal to previous one */

		/*  If dn < 0, we should be entering the solid.
		 *  However, we just assume in/out sorting later will work.
		 *  Really should mark and check this!
		 */
		VJOIN1( hp->hit_point, rp->r_pt, k, rp->r_dir );

		/* HIT is within planar face */
		hp->hit_magic = RT_HIT_MAGIC;
		hp->hit_dist = k;
		VMOVE( hp->hit_normal, trip->tri_N );
		if( ++nhits >= MAXHITS )  {
			bu_log("rt_pg_shot(%s): too many hits (%d)\n", stp->st_name, nhits);
			break;
		}
		hp++;
	}
	if( nhits == 0 )
		return(0);		/* MISS */

	/* Sort hits, Near to Far */
	rt_hitsort( hits, nhits );

	/* Remove duplicate hits.
	   We remove one of a pair of hits when they are
		1) close together, and
		2) both "entry" or both "exit" occurrences.
	   Two immediate "entry" or two immediate "exit" hits suggest
	   that we hit both of two joined faces, while we want to hit only
	   one.  An "entry" followed by an "exit" (or vice versa) suggests
	   that we grazed an edge, and thus we should leave both
	   in the hit list. */
	
	{
		register int i, j;

		for( i=0 ; i<nhits-1 ; i++ )
		{
			fastf_t dist;

			dist = hits[i].hit_dist - hits[i+1].hit_dist;
			if( NEAR_ZERO( dist, ap->a_rt_i->rti_tol.dist ) &&
				VDOT( hits[i].hit_normal, rp->r_dir ) *
			        VDOT( hits[i+1].hit_normal, rp->r_dir) > 0)
			{
				for( j=i ; j<nhits-1 ; j++ )
					hits[j] = hits[j+1];
				nhits--;
				i--;
			}
		}
	}


	if( nhits == 1 )
		nhits = 0;

	if( nhits&1 )  {
		register int i;
		static int nerrors = 0;		/* message counter */
		/*
		 * If this condition exists, it is almost certainly due to
		 * the dn==0 check above.  Thus, we will make the last
		 * surface rather thin.
		 * This at least makes the
		 * presence of this solid known.  There may be something
		 * better we can do.
		 */

		if( nerrors++ < 6 )  {
			bu_log("rt_pg_shot(%s): WARNING %d hits:\n", stp->st_name, nhits);
			bu_log( "\tray start = (%g %g %g) ray dir = (%g %g %g)\n",
				V3ARGS( rp->r_pt ), V3ARGS( rp->r_dir ) );
			for(i=0; i < nhits; i++ )
			{
				point_t tmp_pt;

				VJOIN1( tmp_pt, rp->r_pt, hits[i].hit_dist, rp->r_dir );
				if( VDOT( rp->r_dir, hits[i].hit_normal ) < 0.0 )
					bu_log("\tentrance at dist=%f (%g %g %g)\n", hits[i].hit_dist, V3ARGS( tmp_pt ) );
				else
					bu_log("\texit at dist=%f (%g %g %g)\n", hits[i].hit_dist, V3ARGS( tmp_pt ) );
			}
		}

		if( nhits > 2 )
		{
			fastf_t dot1,dot2;
			int j;

			/* likely an extra hit,
			 * look for consecutive entrances or exits */

			dot2 = 1.0;
			i = 0;
			while( i<nhits )
			{
				dot1 = dot2;
				dot2 = VDOT( rp->r_dir, hits[i].hit_normal );
				if( dot1 > 0.0 && dot2 > 0.0 )
				{
					/* two consectutive exits,
					 * manufacture an entrance at same distance
					 * as second exit.
					 */
					for( j=nhits ; j>i ; j-- )
						hits[j] = hits[j-1];	/* struct copy */

					VREVERSE( hits[i].hit_normal, hits[i].hit_normal );
					dot2 = VDOT( rp->r_dir, hits[i].hit_normal );
					nhits++;
					bu_log( "\t\tadding fictitious entry at %f (%s)\n", hits[i].hit_dist, stp->st_name );
				}
				else if( dot1 < 0.0 && dot2 < 0.0 )
				{
					/* two consectutive entrances,
					 * manufacture an exit between them.
					 */

					for( j=nhits ; j>i ; j-- )
						hits[j] = hits[j-1];	/* struct copy */

					hits[i] = hits[i-1];	/* struct copy */
					VREVERSE( hits[i].hit_normal, hits[i-1].hit_normal );
					dot2 = VDOT( rp->r_dir, hits[i].hit_normal );
					nhits++;
					bu_log( "\t\tadding fictitious exit at %f (%s)\n", hits[i].hit_dist, stp->st_name );
				}
				i++;
			}

		}
		else
		{
			hits[nhits] = hits[nhits-1];	/* struct copy */
			VREVERSE( hits[nhits].hit_normal, hits[nhits-1].hit_normal );
			bu_log( "\t\tadding fictitious hit at %f (%s)\n", hits[nhits].hit_dist, stp->st_name );
			nhits++;
		}
	}

	if( nhits&1 )
	{
		if( nhits < MAXHITS )
		{
			hits[nhits] = hits[nhits-1];	/* struct copy */
			VREVERSE( hits[nhits].hit_normal, hits[nhits-1].hit_normal );
			bu_log( "\t\tadding fictitious hit at %f (%s)\n", hits[nhits].hit_dist, stp->st_name );
			nhits++;
		}
		else
			nhits--;
	}

	/* nhits is even, build segments */
	{
		register struct seg *segp;
		register int	i;
		for( i=0; i < nhits; i += 2 )  {
			RT_GET_SEG(segp, ap->a_resource);
			segp->seg_stp = stp;
			segp->seg_in = hits[i];		/* struct copy */
			segp->seg_out = hits[i+1];	/* struct copy */
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		}
	}
	return(nhits);			/* HIT */
}

/*
 *			R T _ P G _ F R E E
 */
void
rt_pg_free(struct soltab *stp)
{
	register struct tri_specific *trip =
		(struct tri_specific *)stp->st_specific;

	while( trip != TRI_NULL )  {
		register struct tri_specific *nexttri = trip->tri_forw;

		bu_free( (char *)trip, "pg tri_specific");
		trip = nexttri;
	}
}

/*
 *			R T _ P G _ N O R M
 */
void
rt_pg_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	/* Normals computed in rt_pg_shot, nothing to do here */
}

/*
 *			R T _ P G _ U V
 */
void
rt_pg_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	/* Do nothing.  Really, should do what ARB does. */
	uvp->uv_u = uvp->uv_v = 0;
	uvp->uv_du = uvp->uv_dv = 0;
}

/*
 *			R T _ P G _ C L A S S
 */
int
rt_pg_class(void)
{
	return(0);
}

/*
 *			R T _ P G _ P L O T
 */
int
rt_pg_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register int	i;
	register int	p;	/* current polygon number */
	struct rt_pg_internal	*pgp;

	RT_CK_DB_INTERNAL(ip);
	pgp = (struct rt_pg_internal *)ip->idb_ptr;
	RT_PG_CK_MAGIC(pgp);

	for( p = 0; p < pgp->npoly; p++ )  {
		register struct rt_pg_face_internal	*pp;

		pp = &pgp->poly[p];
		RT_ADD_VLIST( vhead, &pp->verts[3*(pp->npts-1)],
			BN_VLIST_LINE_MOVE );
		for( i=0; i < pp->npts; i++ )  {
			RT_ADD_VLIST( vhead, &pp->verts[3*i],
				BN_VLIST_LINE_DRAW );
		}
	}
	return(0);		/* OK */
}

/*
 *			R T _ P G _ P L O T _ P O L Y
 *
 *  Convert to vlist, draw as polygons.
 */
int
rt_pg_plot_poly(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register int	i;
	register int	p;	/* current polygon number */
	struct rt_pg_internal	*pgp;

	RT_CK_DB_INTERNAL(ip);
	pgp = (struct rt_pg_internal *)ip->idb_ptr;
	RT_PG_CK_MAGIC(pgp);

	for( p = 0; p < pgp->npoly; p++ )  {
		register struct rt_pg_face_internal	*pp;
		vect_t aa, bb, norm;

		pp = &pgp->poly[p];
		if (pp->npts < 3)
			continue;
		VSUB2( aa, &pp->verts[3*(0)], &pp->verts[3*(1)] );
		VSUB2( bb, &pp->verts[3*(0)], &pp->verts[3*(2)] );
		VCROSS( norm, aa, bb );
		VUNITIZE(norm);
		RT_ADD_VLIST(vhead, norm, BN_VLIST_POLY_START);

		RT_ADD_VLIST(vhead, &pp->verts[3*(pp->npts-1)], BN_VLIST_POLY_MOVE);
		for (i=0; i < pp->npts-1; i++) {
			RT_ADD_VLIST(vhead, &pp->verts[3*i], BN_VLIST_POLY_DRAW);
		}
		RT_ADD_VLIST(vhead, &pp->verts[3*(pp->npts-1)], BN_VLIST_POLY_END);
	}
	return(0);		/* OK */
}

/*
 *			R T _ P G _ C U R V E
 */
void
rt_pg_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
	cvp->crv_c1 = cvp->crv_c2 = 0;
}

/*
 *			R T _ P G _ T E S S
 */
int
rt_pg_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register int	i;
	struct shell	*s;
	struct vertex	**verts;	/* dynamic array of pointers */
	struct vertex	***vertp;/* dynamic array of ptrs to pointers */
	struct faceuse	*fu;
	register int	p;	/* current polygon number */
	struct rt_pg_internal	*pgp;

	RT_CK_DB_INTERNAL(ip);
	pgp = (struct rt_pg_internal *)ip->idb_ptr;
	RT_PG_CK_MAGIC(pgp);

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	verts = (struct vertex **)bu_malloc(
		pgp->max_npts * sizeof(struct vertex *), "pg_tess verts[]");
	vertp = (struct vertex ***)bu_malloc(
		pgp->max_npts * sizeof(struct vertex **), "pg_tess vertp[]");
	for( i=0; i < pgp->max_npts; i++ )
		vertp[i] = &verts[i];

	for( p = 0; p < pgp->npoly; p++ )  {
		register struct rt_pg_face_internal	*pp;

		pp = &pgp->poly[p];

		/* Locate these points, if previously mentioned */
		for( i=0; i < pp->npts; i++ )  {
			verts[i] = nmg_find_pt_in_shell( s,
				&pp->verts[3*i], tol );
		}

		/* Construct the face.  Verts should be in CCW order */
		if( (fu = nmg_cmface( s, vertp, pp->npts )) == (struct faceuse *)0 )  {
			bu_log("rt_pg_tess() nmg_cmface failed, skipping face %d\n",
				p);
		}

		/* Associate vertex geometry, where none existed before */
		for( i=0; i < pp->npts; i++ )  {
			if( verts[i]->vg_p )  continue;
			nmg_vertex_gv( verts[i], &pp->verts[3*i] );
		}

		/* Associate face geometry */
		if( nmg_calc_face_g( fu ) )
		{
			nmg_pr_fu_briefly( fu, "" );
			bu_free( (char *)verts, "pg_tess verts[]" );
			bu_free( (char *)vertp, "pg_tess vertp[]" );
			return -1;			/* FAIL */
		}
	}

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

	/* Polysolids are often built with incorrect face normals.
	 * Don't depend on them here.
	 */
	nmg_fix_normals( s , tol );
#if 0
	/* mark edges as real */
	(void)nmg_mark_edges_real( &s->l );
#endif
	bu_free( (char *)verts, "pg_tess verts[]" );
	bu_free( (char *)vertp, "pg_tess vertp[]" );

	return(0);		/* OK */
}

/*
 *			R T _ P G _ I M P O R T
 *
 *  Read all the polygons in as a complex dynamic structure.
 *  The caller is responsible for freeing the dynamic memory.
 *  (vid rt_pg_ifree).
 */
int
rt_pg_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_pg_internal	*pgp;
	union record		*rp;
	register int		i;
	int			rno;		/* current record number */
	int			p;		/* current polygon index */

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	if( rp->u_id != ID_P_HEAD )  {
		bu_log("rt_pg_import: defective header record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_POLY;
	ip->idb_meth = &rt_functab[ID_POLY];
	ip->idb_ptr = bu_malloc(sizeof(struct rt_pg_internal), "rt_pg_internal");
	pgp = (struct rt_pg_internal *)ip->idb_ptr;
	pgp->magic = RT_PG_INTERNAL_MAGIC;

	pgp->npoly = (ep->ext_nbytes - sizeof(union record)) /
		sizeof(union record);
	if( pgp->npoly <= 0 )  {
		bu_log("rt_pg_import: polysolid with no polygons!\n");
		return -1;
	}
	if( pgp->npoly )
		pgp->poly = (struct rt_pg_face_internal *)bu_malloc(
			pgp->npoly * sizeof(struct rt_pg_face_internal), "rt_pg_face_internal");
	pgp->max_npts = 0;

	for( p=0; p < pgp->npoly; p++ )  {
		register struct rt_pg_face_internal	*pp;

		pp = &pgp->poly[p];
		rno = p+1;
		if( rp[rno].q.q_id != ID_P_DATA )  {
			bu_log("rt_pg_import: defective data record\n");
			return -1;
		}
		pp->npts = rp[rno].q.q_count;
		pp->verts = (fastf_t *)bu_malloc(
			pp->npts * 3 * sizeof(fastf_t), "pg verts[]" );
		pp->norms = (fastf_t *)bu_malloc(
			pp->npts * 3 * sizeof(fastf_t), "pg norms[]" );
#		include "noalias.h"
		for( i=0; i < pp->npts; i++ )  {
			/* Note:  side effect of importing dbfloat_t */
			MAT4X3PNT( &pp->verts[i*3], mat,
				rp[rno].q.q_verts[i] );
			MAT4X3VEC( &pp->norms[i*3], mat,
				rp[rno].q.q_norms[i] );
		}
		if( pp->npts > pgp->max_npts )  pgp->max_npts = pp->npts;
	}
	if( pgp->max_npts < 3 )  {
		bu_log("rt_pg_import: polysolid with all polygons of less than %d vertices!\n", pgp->max_npts);
		/* XXX free storage */
		return -1;
	}
	return( 0 );
}

/*
 *			R T _ P G _ E X P O R T
 *
 *  The name will be added by the caller.
 *  Generally, only libwdb will set conv2mm != 1.0
 */
int
rt_pg_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_pg_internal	*pgp;
	union record		*rec;
	register int		i;
	int			rno;		/* current record number */
	int			p;		/* current polygon index */

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_POLY )  return(-1);
	pgp = (struct rt_pg_internal *)ip->idb_ptr;
	RT_PG_CK_MAGIC(pgp);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = (1 + pgp->npoly) * sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "pg external");
	rec = (union record *)ep->ext_buf;

	rec[0].p.p_id = ID_P_HEAD;

	for( p=0; p < pgp->npoly; p++ )  {
		register struct rt_pg_face_internal	*pp;

		rno = p+1;
		pp = &pgp->poly[p];
		if( pp->npts < 3 || pp->npts > 5 )  {
			bu_log("rt_pg_export:  unable to support npts=%d\n",
				pp->npts);
			return(-1);
		}

		rec[rno].q.q_id = ID_P_DATA;
		rec[rno].q.q_count = pp->npts;
#		include "noalias.h"
		for( i=0; i < pp->npts; i++ )  {
			/* NOTE: type conversion to dbfloat_t */
			VSCALE( rec[rno].q.q_verts[i],
				&pp->verts[i*3], local2mm );
			VMOVE( rec[rno].q.q_norms[i], &pp->norms[i*3] );
		}
	}
	return(0);
}

int
rt_pg_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	bu_log( "As of release 6.0 the polysolid is superceded by the BOT primitive.\n" );
	bu_log( "\tTo convert polysolids to BOT primitives, use 'dbupgrade'.\n");
	/* The rt_pg_to_bot() routine can also be used. */
	return -1;
}

int
rt_pg_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	bu_log( "As of release 6.0 the polysolid is superceded by the BOT primitive.\n" );
	bu_log( "\tTo convert polysolids to BOT primitives, use 'dbupgrade'.\n" );
	/* The rt_pg_to_bot() routine can also be used. */
	return -1;
}

/*
 *			R T _ P G _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_pg_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register int			j;
	register struct rt_pg_internal	*pgp =
		(struct rt_pg_internal *)ip->idb_ptr;
	char				buf[256];
	int				i;

	RT_PG_CK_MAGIC(pgp);
	bu_vls_strcat( str, "polygon solid with no topology (POLY)\n");

	sprintf(buf, "\t%d polygons (faces)\n",
		pgp->npoly );
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tMost complex face has %d vertices\n",
		pgp->max_npts );
	bu_vls_strcat( str, buf );

	if( pgp->npoly )
	{
		sprintf(buf, "\tFirst vertex (%g, %g, %g)\n",
			pgp->poly[0].verts[X] * mm2local,
			pgp->poly[0].verts[Y] * mm2local,
			pgp->poly[0].verts[Z] * mm2local );
		bu_vls_strcat( str, buf );
	}

	if( !verbose )  return(0);

	/* Print out all the vertices of all the faces */
	for( i=0; i < pgp->npoly; i++ )  {
		register fastf_t *v = pgp->poly[i].verts;
		register fastf_t *n = pgp->poly[i].norms;

		sprintf( buf, "\tPolygon %d: (%d pts)\n",
			i, pgp->poly[i].npts );
		bu_vls_strcat( str, buf );
		for( j=0; j < pgp->poly[i].npts; j++ )  {
			sprintf(buf, "\t\tV (%g, %g, %g)\n\t\t N (%g, %g, %g)\n",
				v[X] * mm2local,
				v[Y] * mm2local,
				v[Z] * mm2local,
				n[X] * mm2local,
				n[Y] * mm2local,
				n[Z] * mm2local );
			bu_vls_strcat( str, buf );
			v += ELEMENTS_PER_VECT;
			n += ELEMENTS_PER_VECT;
		}
	}

	return(0);
}

/*
 *			R T _ P G _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_pg_ifree(struct rt_db_internal *ip)
{
	register struct rt_pg_internal	*pgp;
	register int			i;

	RT_CK_DB_INTERNAL(ip);
	pgp = (struct rt_pg_internal *)ip->idb_ptr;
	RT_PG_CK_MAGIC(pgp);

	/*
	 *  Free storage for each polygon
	 */
	for( i=0; i < pgp->npoly; i++ )  {
		bu_free( (char *)pgp->poly[i].verts, "pg verts[]");
		bu_free( (char *)pgp->poly[i].norms, "pg norms[]");
	}
	if( pgp->npoly )
		bu_free( (char *)pgp->poly, "pg poly[]" );
	pgp->magic = 0;			/* sanity */
	pgp->npoly = 0;
	bu_free( (char *)pgp, "pg ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

/*
 *			R T _ P G _ T O _ B O T
 *
 *  Convert in-memory form of a polysolid (pg) to a bag of triangles (BoT)
 *  There is no record in the V5 database for a polysolid.
 *
 *  Depends on the "max_npts" parameter having been set.
 *
 *  Returns -
 *	-1	FAIL
 *	0	OK
 */
int
rt_pg_to_bot( struct rt_db_internal *ip, const struct bn_tol *tol, struct resource *resp )
{
	struct rt_pg_internal *ip_pg;
	struct rt_bot_internal *ip_bot;
	int max_pts;
	int max_tri;
	int p, i;

	RT_CK_DB_INTERNAL(ip);
	RT_CK_TOL( tol );
	RT_CK_RESOURCE( resp );

	if( ip->idb_type != ID_POLY )
	{
		bu_log( "ERROR: rt_pt_to_bot() called with a non-polysolid!!!\n" );
		return -1;
	}
	ip_pg = (struct rt_pg_internal *)ip->idb_ptr;

	RT_PG_CK_MAGIC( ip_pg );

	ip_bot = (struct rt_bot_internal *)bu_malloc( sizeof( struct rt_bot_internal ), "BOT internal" );
	ip_bot->magic = RT_BOT_INTERNAL_MAGIC;
	ip_bot->mode = RT_BOT_SOLID;
	ip_bot->orientation = RT_BOT_CCW;
	ip_bot->bot_flags = 0;

	/* maximum possible vertices */
	max_pts = ip_pg->npoly * ip_pg->max_npts;
	BU_ASSERT_LONG( max_pts, >, 0 );

	/* maximum possible triangular faces */
	max_tri = ip_pg->npoly * 3;
	BU_ASSERT_LONG( max_tri, >, 0 );

	ip_bot->num_vertices = 0;
	ip_bot->num_faces = 0;
	ip_bot->thickness = (fastf_t *)NULL;
	ip_bot->face_mode = (struct bu_bitv *)NULL;

	ip_bot->vertices = (fastf_t *)bu_calloc( max_pts * 3, sizeof( fastf_t ), "BOT vertices" );
	ip_bot->faces = (int *)bu_calloc( max_tri * 3, sizeof( int ), "BOT faces" );

	for( p=0 ; p<ip_pg->npoly ; p++ )
	{
		LOCAL vect_t work[3], tmp;
		LOCAL struct tri_specific trip;
		LOCAL fastf_t m1, m2, m3, m4;
		LOCAL int first, v0=0, v2=0;

		first = 1;
		VMOVE( work[0], &ip_pg->poly[p].verts[0*3] );
		VMOVE( work[1], &ip_pg->poly[p].verts[1*3] );

		for( i=2; i < ip_pg->poly[p].npts; i++ )  {
			VMOVE( work[2], &ip_pg->poly[p].verts[i*3] );

			VSUB2( trip.tri_BA, work[1], work[0] );
			VSUB2( trip.tri_CA, work[2], work[0] );
			VCROSS( trip.tri_wn, trip.tri_BA, trip.tri_CA );

			/* Check to see if this plane is a line or pnt */
			m1 = MAGNITUDE( trip.tri_BA );
			m2 = MAGNITUDE( trip.tri_CA );
			VSUB2( tmp, work[1], work[2] );
			m3 = MAGNITUDE( tmp );
			m4 = MAGNITUDE( trip.tri_wn );
			if( m1 >= tol->dist && m2 >= tol->dist &&
			    m3 >= tol->dist && m4 >= tol->dist )  {

			    	/* add this triangle to the BOT */
				if( first ) {
					ip_bot->faces[ip_bot->num_faces * 3] = ip_bot->num_vertices;
					VMOVE( &ip_bot->vertices[ip_bot->num_vertices * 3], work[0] );
					v0 = ip_bot->num_vertices;
					ip_bot->num_vertices++;

					ip_bot->faces[ip_bot->num_faces * 3 + 1] = ip_bot->num_vertices;
					VMOVE( &ip_bot->vertices[ip_bot->num_vertices * 3], work[1] );
					ip_bot->num_vertices++;
					first = 0;
				} else {
					ip_bot->faces[ip_bot->num_faces * 3] = v0;
					ip_bot->faces[ip_bot->num_faces * 3 + 1] = v2;
				}
			    	VMOVE( &ip_bot->vertices[ip_bot->num_vertices * 3], work[2] );
			    	ip_bot->faces[ip_bot->num_faces * 3 + 2] = ip_bot->num_vertices;
				v2 = ip_bot->num_vertices;
			    	ip_bot->num_vertices++;

			    	ip_bot->num_faces++;
			}		

			/* Chop off a triangle, and continue */
			VMOVE( work[1], work[2] );
		}
	}

	(void)rt_bot_vertex_fuse( ip_bot );
	(void)rt_bot_condense( ip_bot );

	ip_bot->faces = (int *)bu_realloc( ip_bot->faces, ip_bot->num_faces * 3 * sizeof( int ), "BOT faces" );

	rt_db_free_internal( ip, resp );

	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_BOT;
	ip->idb_meth = &rt_functab[ID_BOT];
	ip->idb_ptr = ip_bot;

	return 0;
}
@


11.46
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /cvs/brlcad/librt/g_pg.c,v 11.45 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.45
log
@merge of ansi-6-0-branch into HEAD
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header$ (BRL)";
d25 5
a29 1
#include "conf.h"
@


11.44
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.43 2002/11/27 13:42:56 jra Exp $ (BRL)";
d40 1
a40 1
HIDDEN int rt_pgface();
d57 1
a57 4
rt_pg_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d122 1
a122 4
rt_pgface( stp, ap, bp, cp, tol )
struct soltab	*stp;
fastf_t		*ap, *bp, *cp;
const struct bn_tol	*tol;
d165 1
a165 2
rt_pg_print( stp )
register const struct soltab *stp;
d195 1
a195 5
rt_pg_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d422 1
a422 2
rt_pg_free( stp )
struct soltab *stp;
d439 1
a439 4
rt_pg_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d448 1
a448 5
rt_pg_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d459 1
a459 1
rt_pg_class()
d468 1
a468 5
rt_pg_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d498 1
a498 5
rt_pg_plot_poly( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d534 1
a534 4
rt_pg_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d544 1
a544 6
rt_pg_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d626 1
a626 5
rt_pg_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d699 1
a699 5
rt_pg_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d744 1
a744 5
rt_pg_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d753 1
a753 5
rt_pg_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d769 1
a769 5
rt_pg_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d830 1
a830 2
rt_pg_ifree( ip )
struct rt_db_internal	*ip;
@


11.43
log
@BOT primitives can now have vertex normals
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985 by the United States Army.
d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.42 2002/08/20 17:08:00 jra Exp $ (BRL)";
@


11.43.6.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.44 2004/02/02 17:39:21 morrison Exp $ (BRL)";
@


11.43.6.2
log
@merge from head
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.43.6.1 2004/02/12 18:37:41 erikg Exp $ (BRL)";
@


11.42
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.40 2002/02/12 19:18:33 morrison Exp $ (BRL)";
d948 1
a948 1
	ip_bot->error_mode = '\0';
@


11.42.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_pg.c,v 11.44 2004/02/02 17:39:21 morrison Exp $ (BRL)";
d948 1
a948 1
	ip_bot->bot_flags = 0;
@


11.42.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.42 2002/08/20 17:08:00 jra Exp $ (BRL)";
d40 1
a40 1
HIDDEN int rt_pgface(struct soltab *stp, fastf_t *ap, fastf_t *bp, fastf_t *cp, const struct bn_tol *tol);
d57 4
a60 1
rt_pg_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d125 4
a128 1
rt_pgface(struct soltab *stp, fastf_t *ap, fastf_t *bp, fastf_t *cp, const struct bn_tol *tol)
d171 2
a172 1
rt_pg_print(register const struct soltab *stp)
d202 5
a206 1
rt_pg_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d433 2
a434 1
rt_pg_free(struct soltab *stp)
d451 4
a454 1
rt_pg_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d463 5
a467 1
rt_pg_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d478 1
a478 1
rt_pg_class(void)
d487 5
a491 1
rt_pg_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d521 5
a525 1
rt_pg_plot_poly(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d561 4
a564 1
rt_pg_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d574 6
a579 1
rt_pg_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d661 5
a665 1
rt_pg_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d738 5
a742 1
rt_pg_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d787 5
a791 1
rt_pg_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d800 5
a804 1
rt_pg_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d820 5
a824 1
rt_pg_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d885 2
a886 1
rt_pg_ifree(struct rt_db_internal *ip)
@


11.42.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header$ (BRL)";
d892 1
a892 1
	ip_bot->bot_flags = 0;
@


11.41
log
@Converted from K&R to ANSI C - RFH
@
text
@d40 1
a40 1
HIDDEN int rt_pgface(struct soltab *stp, fastf_t *ap, fastf_t *bp, fastf_t *cp, const struct bn_tol *tol);
d57 4
a60 1
rt_pg_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d125 4
a128 1
rt_pgface(struct soltab *stp, fastf_t *ap, fastf_t *bp, fastf_t *cp, const struct bn_tol *tol)
d171 2
a172 1
rt_pg_print(register const struct soltab *stp)
d202 5
a206 1
rt_pg_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d433 2
a434 1
rt_pg_free(struct soltab *stp)
d451 4
a454 1
rt_pg_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d463 5
a467 1
rt_pg_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d478 1
a478 1
rt_pg_class(void)
d487 5
a491 1
rt_pg_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d521 5
a525 1
rt_pg_plot_poly(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d561 4
a564 1
rt_pg_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d574 6
a579 1
rt_pg_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d661 5
a665 1
rt_pg_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d738 5
a742 1
rt_pg_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d787 5
a791 1
rt_pg_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d800 5
a804 1
rt_pg_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d820 5
a824 1
rt_pg_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d885 2
a886 1
rt_pg_ifree(struct rt_db_internal *ip)
@


11.40
log
@quelled an unitialized variable warning.
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.39 2001/11/08 22:36:34 jra Exp $ (BRL)";
d40 1
a40 1
HIDDEN int rt_pgface();
d57 1
a57 4
rt_pg_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d122 1
a122 4
rt_pgface( stp, ap, bp, cp, tol )
struct soltab	*stp;
fastf_t		*ap, *bp, *cp;
const struct bn_tol	*tol;
d165 1
a165 2
rt_pg_print( stp )
register const struct soltab *stp;
d195 1
a195 5
rt_pg_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d422 1
a422 2
rt_pg_free( stp )
struct soltab *stp;
d439 1
a439 4
rt_pg_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d448 1
a448 5
rt_pg_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d459 1
a459 1
rt_pg_class()
d468 1
a468 5
rt_pg_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d498 1
a498 5
rt_pg_plot_poly( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d534 1
a534 4
rt_pg_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d544 1
a544 6
rt_pg_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d626 1
a626 5
rt_pg_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d699 1
a699 5
rt_pg_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d744 1
a744 5
rt_pg_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d753 1
a753 5
rt_pg_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d769 1
a769 5
rt_pg_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d830 1
a830 2
rt_pg_ifree( ip )
struct rt_db_internal	*ip;
@


11.39
log
@Mods to rt_pg_to_bot() to minimize creation of duplicate vertices
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.38 2001/10/04 18:40:39 tranese Exp $ (BRL)";
d971 1
a971 1
		LOCAL int first, v0, v2;
@


11.38
log
@Changed log messages in rt_pg_import5 and rt_pg_export5 to output the release number as opposed to the database version.  Also use dbupgrade not g4-g5.
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.37 2001/10/02 19:24:30 jra Exp $ (BRL)";
d971 1
d973 1
a973 1

d994 14
a1007 6
			    	VMOVE( &ip_bot->vertices[ip_bot->num_vertices * 3], work[0] );
			    	ip_bot->faces[ip_bot->num_faces * 3] = ip_bot->num_vertices;
			    	ip_bot->num_vertices++;
			    	VMOVE( &ip_bot->vertices[ip_bot->num_vertices * 3], work[1] );
			    	ip_bot->faces[ip_bot->num_faces * 3 + 1] = ip_bot->num_vertices;
			    	ip_bot->num_vertices++;
d1010 1
@


11.37
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.36 2001/05/17 20:05:24 morrison Exp $ (BRL)";
d793 3
a795 2
	bu_log( "Import of polysolids from a version 5 database is not allowed\n" );
	bu_log( "\tPolysolids should be converted to BOT solids using the rt_pg_to_bot() routine or g4-g5 utility.\n" );
d806 3
a808 2
	bu_log( "Export of polysolids to a version 5 database is not allowed\n" );
	bu_log( "\tPolysolids should be converted to BoT solids using the rt_pg_to_bot() routine or g4-g5 utility.\n" );
@


11.36
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.35 2001/04/20 22:29:46 morrison Exp $ (BRL)";
d681 1
d1016 1
@


11.35
log
@CONST to const
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.34 2000/11/17 06:01:56 mike Exp $ (BRL)";
d149 1
a149 1
		if( rt_g.debug & DEBUG_ARB8 )
@


11.34
log
@
Modified MGED's "fast path" through the "ev" command for drawing polygonal
objects to (a) use the g_xxx.c plot routine rather than duplicating the
code, and (b) added methods for drawing the polygonal version.
Extended fast path to work for Bots.
Also included fixes in new DGO stuff.
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.33 2000/10/24 19:13:01 mike Exp $ (BRL)";
d128 1
a128 1
CONST struct bn_tol	*tol;
d172 1
a172 1
register CONST struct soltab *stp;
d174 1
a174 1
	register CONST struct tri_specific *trip =
d490 2
a491 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d524 2
a525 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d578 2
a579 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d663 3
a665 3
CONST struct bu_external	*ep;
CONST mat_t			mat;
CONST struct db_i		*dbip;
d739 1
a739 1
CONST struct rt_db_internal	*ip;
d741 1
a741 1
CONST struct db_i		*dbip;
d788 3
a790 3
CONST struct bu_external	*ep;
CONST mat_t			mat;
CONST struct db_i		*dbip;
d800 1
a800 1
CONST struct rt_db_internal	*ip;
d802 1
a802 1
CONST struct db_i		*dbip;
d819 1
a819 1
CONST struct rt_db_internal	*ip;
@


11.33
log
@
Shuffled include order.
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.32 2000/10/24 14:44:43 mike Exp $ (BRL)";
d511 42
@


11.32
log
@
BoT support routines now start with rt_bot
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.31 2000/09/08 05:54:42 mike Exp $ (BRL)";
d33 1
a34 1
#include "rtgeom.h"
@


11.31
log
@
Modified tree routines to take resource pointer.
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.30 2000/08/10 04:57:23 mike Exp $ (BRL)";
d966 2
a967 2
	(void)bot_vertex_fuse( ip_bot );
	(void)bot_condense( ip_bot );
@


11.30
log
@
Fixed name of converstion routine in error message.
Added assertion checking to ensure valid inputs.
Added comment that optional input field is actually mandatory.
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.29 2000/07/13 02:36:26 cjohnson Exp $ (BRL)";
d878 1
a878 1
rt_pg_to_bot( struct rt_db_internal *ip, const struct bn_tol *tol )
d886 4
a897 1
	RT_CK_TOL( tol );
d971 1
a971 1
	rt_db_free_internal( ip );
@


11.29
log
@LINT from gcc -Wall
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.28 2000/07/12 21:56:21 mike Exp $ (BRL)";
d751 1
a751 1
	bu_log( "\tPolysolids should be converted to BOT solids using the rt_pg_bot() routine or g4-g5 utility.\n" );
d871 2
d904 1
d908 1
@


11.28
log
@
Improved error message
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.27 2000/07/10 23:01:33 mike Exp $ (BRL)";
d188 1
a188 1
	} while( trip = trip->tri_forw );
@


11.27
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.26 2000/07/06 22:45:54 mike Exp $ (BRL)";
d751 1
a751 1
	bu_log( "\tPolysolids should be converted to BOT solids using the pg_bot() routine or g4-g5 utility.\n" );
d876 1
a876 3
rt_pg_to_bot( ip, tol )
struct rt_db_internal *ip;
CONST struct bn_tol *tol;
@


11.26
log
@
Changed name of conversion routine to begin with rt_
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.25 2000/06/30 15:38:03 mike Exp $ (BRL)";
@


11.25
log
@
export methods should not init the external structure, just check them.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.24 2000/06/30 15:31:15 mike Exp $ (BRL)";
d763 1
a763 1
	bu_log( "\tPolysolids should be converted to BOT solids using the pg_bot() routine or g4-g5 utility.\n" );
d865 10
d876 1
a876 1
pg_bot( ip, tol )
d888 1
a888 1
		bu_log( "ERROR: pg_bot() called with a non-polysolid!!!\n" );
@


11.24
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.23 2000/06/29 14:42:36 jra Exp $ (BRL)";
d712 1
a712 1
	BU_INIT_EXTERNAL(ep);
@


11.23
log
@Added pg_bot() routine and stubs for version 5 import/export
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.22 2000/06/08 19:58:24 jra Exp $ (BRL)";
d638 1
a638 1
	RT_INIT_DB_INTERNAL( ip );
@


11.22
log
@Fixed a bug where an odd number of hits was being used to build segments
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.21 2000/05/11 21:21:17 mike Exp $ (BRL)";
d743 24
d863 100
@


11.21
log
@
Changed to use  rt_hitsort()
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.20 2000/04/12 02:34:35 mike Exp $ (BRL)";
d396 1
a396 1
			bu_log( "\t\tadding fictitious hit at %f\n", hits[nhits].hit_dist );
d399 13
@


11.20
log
@
NT port, non-compat4
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.19 1999/12/22 02:18:00 mike Exp $ (BRL)";
d281 1
a281 14
	{
		register int i, j;
		LOCAL struct hit temp;

		for( i=0; i < nhits-1; i++ )  {
			for( j=i+1; j < nhits; j++ )  {
				if( hits[i].hit_dist <= hits[j].hit_dist )
					continue;
				temp = hits[j];		/* struct copy */
				hits[j] = hits[i];	/* struct copy */
				hits[i] = temp;		/* struct copy */
			}
		}
	}
@


11.19
log
@
Eliminated dead vars
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.18 1999/11/26 21:46:48 mike Exp $ (BRL)";
d524 1
a524 1
	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.18
log
@
Lint cleanups
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.17 1999/11/17 02:42:00 mike Exp $ (BRL)";
a307 1
		LOCAL struct hit temp;
@


11.17
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.16 1999/10/30 03:53:27 mike Exp $ (BRL)";
d492 1
a492 1
struct bn_tol		*tol;
d538 1
a538 1
struct bn_tol		*tol;
d620 1
a620 1
rt_pg_import( ip, ep, mat )
d624 1
d696 1
a696 1
rt_pg_export( ep, ip, local2mm )
d700 1
d754 1
a754 1
struct rt_db_internal	*ip;
@


11.16
log
@
Added magic numbers for ray, hit, and application structures.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.15 1999/07/02 22:19:23 mike Exp $ (BRL)";
d640 1
@


11.15
log
@
Removed dependence on compat4.h
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.14 1999/05/27 19:10:40 mike Exp $ (BRL)";
d268 1
@


11.14
log
@
sed4
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.13 1999/05/11 14:45:48 mike Exp $ (BRL)";
d506 1
a506 1
			RT_VLIST_LINE_MOVE );
d509 1
a509 1
				RT_VLIST_LINE_DRAW );
@


11.13
log
@Don't dump core if a polysolid has no polygons.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.12 1998/07/09 14:18:16 jra Exp $ (BRL)";
d90 1
a90 1
		rt_log("pg(%s):  no faces\n", stp->st_name);
d128 1
a128 1
CONST struct rt_tol	*tol;
d134 1
a134 1
	GETSTRUCT( trip, tri_specific );
d148 1
a148 1
		rt_free( (char *)trip, "getstruct tri_specific");
d150 1
a150 1
			rt_log("pg(%s): degenerate facet\n", stp->st_name);
d178 1
a178 1
		rt_log("pg(%s):  no faces\n", stp->st_name);
d187 1
a187 1
		rt_log("\n");
d271 1
a271 1
			rt_log("rt_pg_shot(%s): too many hits (%d)\n", stp->st_name, nhits);
d343 2
a344 2
			rt_log("rt_pg_shot(%s): WARNING %d hits:\n", stp->st_name, nhits);
			rt_log( "\tray start = (%g %g %g) ray dir = (%g %g %g)\n",
d352 1
a352 1
					rt_log("\tentrance at dist=%f (%g %g %g)\n", hits[i].hit_dist, V3ARGS( tmp_pt ) );
d354 1
a354 1
					rt_log("\texit at dist=%f (%g %g %g)\n", hits[i].hit_dist, V3ARGS( tmp_pt ) );
d384 1
a384 1
					rt_log( "\t\tadding fictitious entry at %f (%s)\n", hits[i].hit_dist, stp->st_name );
d399 1
a399 1
					rt_log( "\t\tadding fictitious exit at %f (%s)\n", hits[i].hit_dist, stp->st_name );
d409 1
a409 1
			rt_log( "\t\tadding fictitious hit at %f\n", hits[nhits].hit_dist );
d423 1
a423 1
			RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d442 1
a442 1
		rt_free( (char *)trip, "pg tri_specific");
d488 1
a488 1
struct rt_list		*vhead;
d491 1
a491 1
struct rt_tol		*tol;
d537 1
a537 1
struct rt_tol		*tol;
d552 1
a552 1
	s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d554 1
a554 1
	verts = (struct vertex **)rt_malloc(
d556 1
a556 1
	vertp = (struct vertex ***)rt_malloc(
d574 1
a574 1
			rt_log("rt_pg_tess() nmg_cmface failed, skipping face %d\n",
d588 2
a589 2
			rt_free( (char *)verts, "pg_tess verts[]" );
			rt_free( (char *)vertp, "pg_tess vertp[]" );
d605 2
a606 2
	rt_free( (char *)verts, "pg_tess verts[]" );
	rt_free( (char *)vertp, "pg_tess vertp[]" );
d621 1
a621 1
CONST struct rt_external	*ep;
d630 1
a630 1
	RT_CK_EXTERNAL( ep );
d633 1
a633 1
		rt_log("rt_pg_import: defective header record\n");
d639 1
a639 1
	ip->idb_ptr = rt_malloc(sizeof(struct rt_pg_internal), "rt_pg_internal");
d650 1
a650 1
		pgp->poly = (struct rt_pg_face_internal *)rt_malloc(
d660 1
a660 1
			rt_log("rt_pg_import: defective data record\n");
d664 1
a664 1
		pp->verts = (fastf_t *)rt_malloc(
d666 1
a666 1
		pp->norms = (fastf_t *)rt_malloc(
d694 1
a694 1
struct rt_external		*ep;
d709 1
a709 1
	RT_INIT_EXTERNAL(ep);
d711 1
a711 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "pg external");
d722 1
a722 1
			rt_log("rt_pg_export:  unable to support npts=%d\n",
d749 1
a749 1
struct rt_vls		*str;
d761 1
a761 1
	rt_vls_strcat( str, "polygon solid with no topology (POLY)\n");
d765 1
a765 1
	rt_vls_strcat( str, buf );
d769 1
a769 1
	rt_vls_strcat( str, buf );
d777 1
a777 1
		rt_vls_strcat( str, buf );
d789 1
a789 1
		rt_vls_strcat( str, buf );
d798 1
a798 1
			rt_vls_strcat( str, buf );
d827 2
a828 2
		rt_free( (char *)pgp->poly[i].verts, "pg verts[]");
		rt_free( (char *)pgp->poly[i].norms, "pg norms[]");
d831 1
a831 1
		rt_free( (char *)pgp->poly, "pg poly[]" );
d834 1
a834 1
	rt_free( (char *)pgp, "pg ifree" );
@


11.12
log
@Polysolid edges shoud not be marked as real edges.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pg.c,v 11.11 1997/06/11 17:34:40 jra Exp $ (BRL)";
d645 4
a648 2
	if( pgp->npoly < 0 )
		pgp->npoly = 0;
d677 5
@


11.11
log
@Minor mods to prevent a polysolid with no polygons from causing a core dump.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 11.10 1997/06/04 20:14:58 gdurf Exp jra $ (BRL)";
d601 1
a601 1

d604 1
a604 1
	
@


11.10
log
@Corrected a bug in rt_pg_shot() in which one of a close-together exit/entrance
pair was unnecessarily removed.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 11.9 1997/04/17 20:59:05 jra Exp gdurf $ (BRL)";
d645 5
a649 2
	pgp->poly = (struct rt_pg_face_internal *)rt_malloc(
		pgp->npoly * sizeof(struct rt_pg_face_internal), "rt_pg_face_internal");
d764 8
a771 5
	sprintf(buf, "\tFirst vertex (%g, %g, %g)\n",
		pgp->poly[0].verts[X] * mm2local,
		pgp->poly[0].verts[Y] * mm2local,
		pgp->poly[0].verts[Z] * mm2local );
	rt_vls_strcat( str, buf );
d823 2
a824 1
	rt_free( (char *)pgp->poly, "pg poly[]" );
@


11.9
log
@Added some debug prints to the shot routine.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 11.8 1997/03/11 16:11:44 jra Exp $ (BRL)";
d295 10
a304 1
	/* remove duplicate hits */
d314 3
a316 1
			if( NEAR_ZERO( dist, ap->a_rt_i->rti_tol.dist ) )
d325 1
@


11.8
log
@Added code to eliminate duplicate hits.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 11.7 1997/01/30 15:39:39 jra Exp jra $ (BRL)";
d332 2
d336 3
d340 1
a340 1
					rt_log("\tentrance at %f\n", hits[i].hit_dist );
d342 1
a342 1
					rt_log("\texit at %f\n", hits[i].hit_dist );
@


11.7
log
@upped MAXHITS from 32 to 128 (getting complex polysolids from the Pro/E converter).
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 11.6 1997/01/23 14:22:00 jra Exp jra $ (BRL)";
d271 1
a271 1
			rt_log("rt_pg_shot(%s): too many hits\n", stp->st_name);
d295 23
d367 1
a367 1
					rt_log( "\t\tadding fictitious entry at %f\n", hits[i].hit_dist );
d382 1
a382 1
					rt_log( "\t\tadding fictitious exit at %f\n", hits[i].hit_dist );
@


11.6
log
@Minor correction to debug message.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 11.5 1997/01/23 14:19:09 jra Exp jra $ (BRL)";
d210 1
a210 1
#define MAXHITS 32		/* # surfaces hit, must be even */
@


11.5
log
@Improved handling of odd numbers of hits in rt_pg_shot().
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 11.4 1996/10/11 17:56:32 jra Exp $ (BRL)";
d369 1
a370 1
			rt_log( "\t\tadding fictitious hit at %f\n", hits[i].hit_dist );
@


11.4
log
@Moved call to nmg_region_a() a little earlier.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 11.3 1995/11/02 18:53:53 cjohnson Exp jra $ (BRL)";
d306 1
a306 3
		hits[nhits] = hits[nhits-1];	/* struct copy */
		VREVERSE( hits[nhits].hit_normal, hits[nhits-1].hit_normal );
		nhits++;
d308 1
a308 1
			rt_log("rt_pg_shot(%s): %d hits: ", stp->st_name, nhits-1);
d310 61
a370 2
				rt_log("%f, ", hits[i].hit_dist );
			rt_log("\n");
@


11.3
log
@We were using free() instead of rt_free for something that was rt_malloced()
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 11.2 1995/03/29 20:40:26 jra Exp cjohnson $ (BRL)";
d497 3
a503 3

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );
@


11.2
log
@replaced a call to nmg_fu_planeeqn() with a call to nmg_calc_face_g().
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 11.1 1995/01/04 09:56:52 mike Rel4_4 jra $ (BRL)";
d148 1
a148 1
		free( (char *)trip);
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 10.7 94/09/13 15:51:51 jra Exp $ (BRL)";
d488 1
a488 1
		if( nmg_fu_planeeqn( fu, tol ) < 0 )
d490 1
@


10.7
log
@Added call to mark_edges_real in tessellator.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 10.6 94/09/02 16:03:32 jra Exp Locker: jra $ (BRL)";
@


10.6
log
@Added scaling for scalar values on import where needed.
Added conversion to mm for scalar values where needed.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 10.5 94/08/10 18:38:26 gdurf Exp Locker: jra $ (BRL)";
d489 3
d493 1
d504 3
@


10.5
log
@Added include of conf.h
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 10.4 1994/06/08 11:37:51 jra Exp gdurf $ (BRL)";
d491 5
@


10.4
log
@Removed unused arg from rt_pgface to make it agree with its call.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 10.3 93/11/18 01:44:07 mike Exp Locker: jra $ (BRL)";
d24 2
@


10.3
log
@Added tol arg to bounding box routines
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 10.2 93/03/26 22:01:52 mike Exp $ (BRL)";
d123 1
a123 1
rt_pgface( stp, ap, bp, cp, np, tol )
a125 1
fastf_t		*np;
@


10.2
log
@Moved nmg_find_pt_in_shell() into nmg_info.c
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 10.1 91/10/12 06:40:21 mike Rel4_0 Locker: mike $ (BRL)";
d492 1
a492 1
	nmg_region_a( *r );
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.17 91/07/27 00:55:04 mike Exp $ (BRL)";
a430 114
 *			R T _ N M G _ F I N D _ P T _ I N _ S H E L L
 *
 *  Given a point in 3-space and a shell pointer, try to find a vertex
 *  anywhere in the shell which is within sqrt(tol_sq) distance of
 *  the given point.
 *
 *  Returns -
 *	pointer to vertex with matching geometry
 *	NULL
 */
struct vertex *
rt_nmg_find_pt_in_shell( s, pt, tol )
struct shell		*s;
CONST point_t		pt;
CONST struct rt_tol	*tol;
{
	struct faceuse	*fu;
	struct loopuse	*lu;
	struct edgeuse	*eu;
	struct vertexuse *vu;
	struct vertex	*v;
	struct vertex_g	*vg;
	vect_t		delta;

	NMG_CK_SHELL(s);
	RT_CK_TOL(tol);

	fu = RT_LIST_FIRST(faceuse, &s->fu_hd);
	while (RT_LIST_NOT_HEAD(fu, &s->fu_hd) ) {
		/* Shell has faces */
		NMG_CK_FACEUSE(fu);
			if( (vu = nmg_find_vu_in_face( pt, fu, tol )) )
				return(vu->v_p);

			if (RT_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
				fu = RT_LIST_PNEXT_PNEXT(faceuse, fu);
			else
				fu = RT_LIST_PNEXT(faceuse, fu);
	}

	for (RT_LIST_FOR(lu, loopuse, &s->lu_hd)) {
		NMG_CK_LOOPUSE(lu);
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
			vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
			NMG_CK_VERTEX(vu->v_p);
			if (vg = vu->v_p->vg_p) {
				NMG_CK_VERTEX_G(vg);
				VSUB2( delta, vg->coord, pt );
				if( MAGSQ(delta) < tol->dist_sq )
					return(vu->v_p);
			}
		} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC) {
			rt_log("in %s at %d ", __FILE__, __LINE__);
			rt_bomb("loopuse has bad child\n");
		} else {
			/* loopuse made of edgeuses */
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				
				NMG_CK_EDGEUSE(eu);
				NMG_CK_VERTEXUSE(eu->vu_p);
				v = eu->vu_p->v_p;
				NMG_CK_VERTEX(v);
				if( (vg = v->vg_p) )  {
					NMG_CK_VERTEX_G(vg);
					VSUB2( delta, vg->coord, pt );
					if( MAGSQ(delta) < tol->dist_sq )
						return(v);
				}
			}
		}
	}

	lu = RT_LIST_FIRST(loopuse, &s->lu_hd);
	while (RT_LIST_NOT_HEAD(lu, &s->lu_hd) ) {

			NMG_CK_LOOPUSE(lu);
			/* XXX what to do here? */
			rt_log("nmg_find_vu_in_face(): lu?\n");

			if (RT_LIST_PNEXT(loopuse, lu) == lu->lumate_p)
				lu = RT_LIST_PNEXT_PNEXT(loopuse, lu);
			else
				lu = RT_LIST_PNEXT(loopuse, lu);
	}

	for (RT_LIST_FOR(eu, edgeuse, &s->eu_hd)) {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_VERTEXUSE(eu->vu_p);
		v = eu->vu_p->v_p;
		NMG_CK_VERTEX(v);
		if( (vg = v->vg_p) )  {
			NMG_CK_VERTEX_G(vg);
			VSUB2( delta, vg->coord, pt );
			if( MAGSQ(delta) < tol->dist_sq )
				return(v);
		}
	}


	if (s->vu_p) {
		NMG_CK_VERTEXUSE(s->vu_p);
		v = s->vu_p->v_p;
		NMG_CK_VERTEX(v);
		if( (vg = v->vg_p) )  {
			NMG_CK_VERTEX_G( vg );
			VSUB2( delta, vg->coord, pt );
			if( MAGSQ(delta) < tol->dist_sq )
				return(v);
		}
	}
	return( (struct vertex *)0 );
}

/*
d470 1
a470 1
			verts[i] = rt_nmg_find_pt_in_shell( s,
@


9.17
log
@Fixed some parameter problems preventing tessellation from working.
Clarified surface normal use, so that CCW normals are required
throughout.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.16 91/06/30 00:10:55 mike Exp $ (BRL)";
@


9.16
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.15 91/06/22 22:30:30 mike Exp $ (BRL)";
a68 1
		LOCAL vect_t	norm;
a69 4
		/* Just use first normal as a face normal.  Ignore rest */
		VMOVE( norm, pgp->poly[p].norms );
		VUNITIZE( norm );

d81 1
a81 1
				work[0], work[1], work[2], norm, &rtip->rti_tol );
d153 1
a153 1
	/*  wn is a GIFT-style normal, not necessarily of unit length.
d155 1
a155 1
	 *  Eventually, N should be computed as a blend of the given normals.
d157 2
a158 9
	m3 = MAGNITUDE( np );
	if( !NEAR_ZERO( m3, 0.0001 ) )  {
		VMOVE( trip->tri_N, np );
		m3 = 1 / m3;
		VSCALE( trip->tri_N, trip->tri_N, m3 );
	} else {
		VMOVE( trip->tri_N, trip->tri_wn );
		VUNITIZE( trip->tri_N );
	}
d307 1
a307 1
		hits[nhits++].hit_dist += 0.1;	/* mm thick */
d320 1
a320 1
		for( i=0; i < nhits; i -= 2 )  {
a428 22
#if 0
/*	Superseeded by nmg_find_vu_in_face
 */
/*
 *			R T _ N M G _ F I N D _ P T _ I N _ F A C E
 *
 *  Given a point in 3-space and a face pointer, try to find a vertex
 *  in the face which is within sqrt(tol_sq) distance of the given point.
 *
 *  Returns -
 *	pointer to vertex with matching geometry
 *	NULL
 */
struct vertex *
rt_nmg_find_pt_in_face( fu, pt, tol_sq )
struct faceuse	*fu;
point_t		pt;
double		tol_sq;
{
	struct loopuse *lu;
	struct edgeuse *eu;
	vect_t		delta;
a429 25
	NMG_CK_FACEUSE(fu);
	lu = fu->lu_p;
	do {
		NMG_CK_LOOPUSE(lu);
		if (*lu->down.magic_p == NMG_VERTEXUSE_MAGIC) {
			VSUB2( delta, lu->down.vu_p->v_p->vg_p->coord, pt );
			if( MAGSQ(delta) < tol_sq )
				return(lu->down.vu_p->v_p);
		}
		else if (*lu->down.magic_p == NMG_EDGEUSE_MAGIC) {
			eu = lu->down.eu_p;
			do {
				VSUB2( delta, eu->vu_p->v_p->vg_p->coord, pt );
				if( MAGSQ(delta) < tol_sq )
					return(eu->vu_p->v_p);
				eu = eu->next;
			} while (eu != lu->down.eu_p);
		} else
			rt_bomb("rt_nmg_find_pt_in_face: Bogus child of loop\n");

		lu = lu->next;
	} while (lu != fu->lu_p);
	return ((struct vertex *)NULL);
}
#endif
d456 1
a502 2


d585 1
a585 1
				&pp->verts[3*i], tol->dist_sq );
@


9.15
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.14 91/06/12 20:57:43 mike Exp $ (BRL)";
d183 1
a183 1
register struct soltab *stp;
d185 1
a185 1
	register struct tri_specific *trip =
d683 3
a685 3
struct rt_db_internal	*ip;
struct rt_external	*ep;
mat_t			mat;
d747 3
a749 3
struct rt_external	*ep;
struct rt_db_internal	*ip;
double			local2mm;
@


9.14
log
@nmg.h must come before raytrace.h
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.13 91/05/18 03:01:14 mike Exp $ (BRL)";
d55 1
a55 1
rt_pg_prep( stp, ip, rtip, tol )
a58 1
CONST struct rt_tol	*tol;
d86 1
a86 1
				work[0], work[1], work[2], norm, tol );
d213 1
a213 1
rt_pg_shot( stp, rp, ap, seghead, tol )
a217 1
CONST struct rt_tol	*tol;
@


9.13
log
@Converted to new tolerance interface
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.12 91/04/01 19:59:39 mike Exp $ (BRL)";
d30 1
a31 1
#include "nmg.h"
@


9.12
log
@Edges of loops now travel in a counter-clockwise (CCW) direction
around the face normal.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.11 91/02/27 21:05:45 mike Exp $ (BRL)";
d55 1
a55 1
rt_pg_prep( stp, ip, rtip )
d59 1
d87 1
a87 1
				work[0], work[1], work[2], norm );
d129 1
a129 1
rt_pgface( stp, ap, bp, cp, np )
d133 1
d151 2
a152 2
	if( NEAR_ZERO(m1, 0.0001) || NEAR_ZERO(m2, 0.0001) ||
	    NEAR_ZERO(m3, 0.0001) || NEAR_ZERO(m4, 0.0001) )  {
d214 1
a214 1
rt_pg_shot( stp, rp, ap, seghead )
d219 1
d403 1
a403 1
rt_pg_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
d406 2
a407 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
d503 4
a506 4
rt_nmg_find_pt_in_shell( s, pt, tol_sq )
struct shell	*s;
point_t		pt;
double		tol_sq;
d522 1
a522 1
			if( (vu = nmg_find_vu_in_face( pt, fu, tol_sq )) )
d539 1
a539 1
				if( MAGSQ(delta) < tol_sq )
d556 1
a556 1
					if( MAGSQ(delta) < tol_sq )
d586 1
a586 1
			if( MAGSQ(delta) < tol_sq )
d599 1
a599 1
			if( MAGSQ(delta) < tol_sq )
d610 1
a610 1
rt_pg_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d614 2
a615 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
a621 2
	fastf_t		tol;
	fastf_t		tol_sq;
a631 7

	/* rel_tol is hard to deal with, given we don't know the RPP yet */
	tol = abs_tol;
	if( tol <= 0.0 )
		tol = 0.1;	/* mm */
	tol_sq = tol * tol;

d647 1
a647 1
				&pp->verts[3*i], tol_sq );
d663 2
a664 1
		if( nmg_fu_planeeqn( fu ) < 0 )  return -1;	/* FAIL */
@


9.11
log
@lint
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.10 91/02/07 20:32:22 mike Exp $ (BRL)";
d658 1
a658 1
		/* Construct the face */
d671 1
a671 1
		rt_mk_nmg_planeeqn( fu );
@


9.10
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.9 91/01/28 23:53:15 mike Exp $ (BRL)";
d839 1
a839 1
	if( !verbose )  return;
@


9.9
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.8 91/01/26 03:14:53 mike Exp $ (BRL)";
d516 2
a517 2
	fu = NMG_LIST_FIRST(faceuse, &s->fu_hd);
	while (NMG_LIST_MORE(fu, faceuse, &s->fu_hd) ) {
d523 2
a524 2
			if (NMG_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
				fu = NMG_LIST_PNEXT_PNEXT(faceuse, fu);
d526 1
a526 1
				fu = NMG_LIST_PNEXT(faceuse, fu);
d529 1
a529 1
	for (NMG_LIST(lu, loopuse, &s->lu_hd)) {
d531 2
a532 2
		if (NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
			vu = NMG_LIST_FIRST(vertexuse, &lu->down_hd);
d540 1
a540 1
		} else if (NMG_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC) {
d545 1
a545 1
			for (NMG_LIST(eu, edgeuse, &lu->down_hd)) {
d563 2
a564 2
	lu = NMG_LIST_FIRST(loopuse, &s->lu_hd);
	while (NMG_LIST_MORE(lu, loopuse, &s->lu_hd) ) {
d570 2
a571 2
			if (NMG_LIST_PNEXT(loopuse, lu) == lu->lumate_p)
				lu = NMG_LIST_PNEXT_PNEXT(loopuse, lu);
d573 1
a573 1
				lu = NMG_LIST_PNEXT(loopuse, lu);
d576 1
a576 1
	for (NMG_LIST(eu, edgeuse, &s->eu_hd)) {
d631 1
a631 1
	s = NMG_LIST_FIRST(shell, &(*r)->s_hd);
@


9.8
log
@Eliminated mat parameter on ft_plot and ft_tess
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.7 91/01/25 21:19:11 mike Exp $ (BRL)";
d401 1
a401 1
struct vlhead		*vhead;
d419 2
a420 2
		ADD_VL( vhead, &pp->verts[3*(pp->npts-1)],
			VL_CMD_LINE_MOVE );
d422 2
a423 1
			ADD_VL( vhead, &pp->verts[3*i], VL_CMD_LINE_DRAW );
@


9.7
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.6 91/01/15 23:41:25 mike Exp $ (BRL)";
d400 6
a405 7
rt_pg_plot( vhead, mat, ip, abs_tol, rel_tol, norm_tol )
struct vlhead	*vhead;
mat_t		mat;
struct rt_db_internal *ip;
double		abs_tol;
double		rel_tol;
double		norm_tol;
d607 1
a607 1
rt_pg_tess( r, m, ip, mat, abs_tol, rel_tol, norm_tol )
d611 3
a613 4
register mat_t		mat;
double		abs_tol;
double		rel_tol;
double		norm_tol;
@


9.6
log
@Converted to new import/export interface
@
text
@d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.5 90/10/06 02:05:16 mike Exp $ (BRL)";
a53 1
#if NEW_IF
a59 10
#else
int
rt_pg_prep( stp, rec, rtip )
struct soltab	*stp;
union record	*rec;
struct rt_i	*rtip;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a63 12
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rec;
	ep->ext_nbytes = stp->st_dp->d_len*sizeof(union record);
	ip = &intern;
	if( rt_pg_import( ip, ep, stp->st_pathmat ) < 0 )
		return(-1);		/* BAD */
	RT_CK_DB_INTERNAL( ip );
#endif
a398 1
#if NEW_IF
a407 11
#else
int
rt_pg_plot( rp, mat, vhead, dp )
union record	*rp;
mat_t		mat;
struct vlhead	*vhead;
struct directory *dp;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a411 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_pg_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_pg_plot(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
a606 1
#if NEW_IF
a616 14
#else
int
rt_pg_tess( r, m, rp, mat, dp, abs_tol, rel_tol )
struct nmgregion	**r;
struct model		*m;
register union record	*rp;
register mat_t		mat;
struct directory	*dp;
double			abs_tol;
double			rel_tol;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a626 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_pg_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_pg_tess(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
@


9.5
log
@Converted seg structures to use doubly linked lists.
@
text
@d6 2
d22 1
a22 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.4 90/05/18 07:25:41 butler Exp $ (BRL)";
d32 1
d54 1
d56 8
a63 1
rt_pg_prep( stp, rp, rtip )
d65 1
a65 1
union record	*rp;
d68 6
a73 3
	LOCAL vect_t	work[3];
	LOCAL vect_t	norm;
	register int	i, j;
d75 21
a95 14
	/* rp[0] has ID_P_HEAD record */
	for( j = 1; j < stp->st_dp->d_len; j++ )  {
		if( rp[j].u_id != ID_P_DATA )  {
			rt_log("rt_pg_prep(%s):  bad record 0%o\n",
				stp->st_name, rp[j].u_id );
			return(-1);		/* BAD */
		}
		if( rp[j].q.q_count < 3 || rp[j].q.q_count > 5 )  {
			rt_log("rt_pg_prep(%s):  q_count = %d\n",
				stp->st_name, rp[j].q.q_count);
			return(-1);		/* BAD */
		}
		/* Import dbfloat_t normal */
		MAT4X3PNT( norm, stp->st_pathmat, rp[j].q.q_norms[0] );
d97 2
a98 2
		/* Should worry about importing dbfloat_t here */
		MAT4X3PNT( work[0], stp->st_pathmat, rp[j].q.q_verts[0] );
d100 1
a100 2
		/* Should worry about importing dbfloat_t here */
		MAT4X3PNT( work[1], stp->st_pathmat, rp[j].q.q_verts[1] );
d102 3
a104 3
		for( i=2; i < rp[j].q.q_count; i++ )  {
			/* Should worry about importing dbfloat_t here */
			MAT4X3PNT( work[2], stp->st_pathmat, rp[j].q.q_verts[i] );
d106 1
d108 4
a111 1
			(void)rt_pgface( stp, work[0], work[1], work[2], norm );
d124 1
a124 4
		VSET( stp->st_center,
			(stp->st_max[X] + stp->st_min[X])/2,
			(stp->st_max[Y] + stp->st_min[Y])/2,
			(stp->st_max[Z] + stp->st_min[Z])/2 );
d422 1
d424 11
a434 1
rt_pg_plot( rp, xform, vhead, dp )
d436 1
a436 1
mat_t		xform;
d440 3
d444 2
a445 3
	register int	n;	/* number of P_DATA records involved */
	int		npts;
	vect_t		work[5];
d447 26
a472 4
	for( n=1; n < dp->d_len; n++ )  {
		if( (npts = rp[n].q.q_count) < 3 )  {
			rt_log("rt_pg_plot() face with only %d verts?\n", npts);
			continue;
a473 9
		if( npts > 5 )
			npts = 5;
		for( i=0; i < npts; i++ )  {
			MAT4X3PNT( work[i], xform, rp[n].q.q_verts[i] );
		}
		ADD_VL( vhead, work[npts-1], 0 );
		for( i=0; i < npts; i++ )  {
			ADD_VL( vhead, work[i], 1 );
		}
a654 2
 *
 *  This is ugly, need to deal with import/export issues!
d656 1
d658 11
d678 3
a681 2
	register int	n;	/* number of P_DATA records involved */
	vect_t		work[5];
d683 2
a684 2
	struct vertex	*verts[5];
	struct vertex	**vertp[5];
d688 2
a689 1
	int		npts;
d691 18
d719 5
a723 1
	for( i=0; i<5; i++ )
a724 10
	for( n=1; n < dp->d_len; n++ )  {
		if( (npts = rp[n].q.q_count) < 3 )  {
			rt_log("rt_pg_tess() face with only %d verts?\n", npts);
			continue;
		}
		if( npts > 5 )
			npts = 5;
		for( i=0; i < npts; i++ )  {
			MAT4X3PNT( work[i], mat, rp[n].q.q_verts[i] );
		}
d726 5
d732 3
a734 2
		for( i=0; i < npts; i++ )  {
			verts[i] = rt_nmg_find_pt_in_shell( s, work[i], tol_sq );
d738 1
a738 1
		if( (fu = nmg_cmface( s, vertp, rp[n].q.q_count )) == (struct faceuse *)0 )  {
d740 1
a740 1
				n);
d744 1
a744 1
		for( i=0; i < npts; i++ )  {
d746 1
a746 1
			nmg_vertex_gv( verts[i], work[i] );
d756 3
d760 213
@


9.4
log
@Halfway converted to new double-linked-list structures ;-)
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: /m/cad/librt/RCS/g_pg.c,v 9.3 90/04/28 03:30:06 mike Exp $ (BRL)";
d211 1
a211 1
 *  	segp	HIT
d213 2
a214 2
struct seg *
rt_pg_shot( stp, rp, ap )
d218 1
d289 1
a289 1
		return(SEG_NULL);		/* MISS */
d331 4
a334 7
		register struct seg *segp;			/* XXX */
		segp = SEG_NULL;
		while( nhits > 0 )  {
			register struct seg *newseg;		/* XXX */
			GET_SEG(newseg, ap->a_resource);
			newseg->seg_next = segp;
			segp = newseg;
d336 3
a338 3
			segp->seg_in = hits[nhits-2];	/* struct copy */
			segp->seg_out = hits[nhits-1];	/* struct copy */
			nhits -= 2;
a339 1
		return(segp);			/* HIT */
d341 1
a341 1
	/* NOTREACHED */
@


9.3
log
@Added initial tessellation support.
Added rt_ prefix to all routines.
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: g_pg.c,v 9.2 90/03/14 15:05:53 mike Locked $ (BRL)";
d446 3
a448 1

d493 1
a493 1

d514 1
d521 2
a522 1
	if( fu = s->fu_p ) {
d524 6
a529 7
		do {
			NMG_CK_FACEUSE(fu);
			if( (v = rt_nmg_find_pt_in_face( fu, pt, tol_sq )) )
				return(v);
			if (fu->next != s->fu_p &&
			    fu->next->f_p == fu->f_p)
				fu = fu->next->next;
d531 1
a531 2
				fu = fu->next;
		} while (fu != s->fu_p);
a532 7
	if( lu = s->lu_p ) {
		do {
			NMG_CK_LOOPUSE(lu);
			/* XXX what to do here? */
			rt_log("rt_nmg_find_pt_in_face(): lu?\n");
			lu = lu->next;
		} while (lu != s->fu_p->lu_p);
d534 6
a539 8
	}
	if( eu = s->eu_p ) {
		do {
			NMG_CK_EDGEUSE(eu);
			NMG_CK_VERTEXUSE(eu->vu_p);
			v = eu->vu_p->v_p;
			NMG_CK_VERTEX(v);
			if( (vg = v->vg_p) )  {
d543 1
a543 1
					return(v);
d545 19
a563 2
			eu = eu->next;
		} while (eu != s->eu_p);
d565 30
d636 2
a637 1
	s = m->r_p->s_p;
@


9.2
log
@Changed type of st_specific to genptr_t
@
text
@d2 1
a2 1
 *			P G . C
d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: g_pg.c,v 9.1 89/05/19 05:56:19 mike Locked $ (BRL)";
d29 1
d35 1
a35 1
HIDDEN int pgface();
d41 1
a41 1
 *			P G _ P R E P
d52 1
a52 1
pg_prep( stp, rp, rtip )
d64 1
a64 1
			rt_log("pg_prep(%s):  bad record 0%o\n",
d69 1
a69 1
			rt_log("pg_prep(%s):  q_count = %d\n",
d87 1
a87 1
			(void)pgface( stp, work[0], work[1], work[2], norm );
d119 1
a119 1
 *			P G F A C E
d130 1
a130 1
pgface( stp, ap, bp, cp, np )
d180 1
a180 1
 *  			P G _ P R I N T
d183 1
a183 1
pg_print( stp )
d204 1
a204 1
 *			P G _ S H O T
d214 1
a214 1
pg_shot( stp, rp, ap )
d221 1
a221 1
#define MAXHITS 12		/* # surfaces hit, must be even */
d281 2
a282 2
		if( nhits++ >= MAXHITS )  {
			rt_log("pg(%s): too many hits\n", stp->st_name);
d308 1
a308 1
		static int nerrors = 0;
d321 1
a321 1
			rt_log("pg(%s): %d hits: ", stp->st_name, nhits-1);
d348 1
a348 1
 *			P G _ F R E E
d351 1
a351 1
pg_free( stp )
d366 1
a366 1
 *			P G _ N O R M
d369 1
a369 1
pg_norm( hitp, stp, rp )
d374 1
a374 5
	/* Normals computed in pg_shot, nothing to do here */

	if( VDOT(rp->r_dir, hitp->hit_normal) > 0 ) {
		VREVERSE( hitp->hit_normal, hitp->hit_normal );
	}
d377 3
d381 1
a381 1
pg_uv( ap, stp, hitp, uvp )
d392 3
d396 1
a396 1
pg_class()
d402 1
a402 1
 *			P G _ P L O T
d404 2
a405 2
void
pg_plot( rp, xform, vhead, dp )
d413 2
a414 1
	static vect_t work[5];
d417 7
a423 3
		if( rp[n].q.q_count > 5 )
			rp[n].q.q_count = 5;
		for( i=0; i < rp[n].q.q_count; i++ )  {
d426 2
a427 2
		ADD_VL( vhead, work[rp[n].q.q_count-1], 0 );
		for( i=0; i < rp[n].q.q_count; i++ )  {
d431 1
d434 3
d438 1
a438 1
pg_curve( cvp, hitp, stp )
d445 197
@


9.1
log
@Release_3.5
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: g_pg.c,v 8.5 89/04/17 17:19:45 mike Exp $ (BRL)";
d90 1
a90 1
	if( stp->st_specific == 0 )  {
d174 1
a174 1
	stp->st_specific = (int *)trip;
@


8.5
log
@Calling sequence to xxx_prep() shortened from 6 to 3 args.
Database conversion moved into prep routines.
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: g_pg.c,v 8.4 89/04/11 12:24:58 mike Locked $ (BRL)";
@


8.4
log
@lint
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 8.3 89/03/14 02:00:41 phil Locked $ (BRL)";
d51 1
a51 2
pg_prep( vecxx, stp, mat, rp, rtip, dp )
fastf_t		*vecxx;
a52 1
matp_t		mat;
a54 1
struct directory *dp;
d61 1
a61 1
	for( j = 1; j < dp->d_len; j++ )  {
d73 1
a73 1
		MAT4X3PNT( norm, mat, rp[j].q.q_norms[0] );
d76 1
a76 1
		MAT4X3PNT( work[0], mat, rp[j].q.q_verts[0] );
d79 1
a79 1
		MAT4X3PNT( work[1], mat, rp[j].q.q_verts[1] );
d83 1
a83 1
			MAT4X3PNT( work[2], mat, rp[j].q.q_verts[i] );
@


8.3
log
@Fixed bug in reversal of wn (the algorithm requires that this have
whatever sign the cross product gives it).
Added code to break up four and five vertex polys into triangles
(this assumes that the poly is convex).
Added vector reversal in the normal routine based on ray direction
(this is not officially "correct" but it at least allows the rendering
of polygons until we get "plate mode polys" or some such implemented).
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 8.2 88/12/06 00:02:41 phil Locked $ (BRL)";
d34 2
d131 1
a189 1
	register int i;
@


8.2
log
@Added _plot() routines, and db_*() interfaces.
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: /cad/d/mike/cad/librt/RCS/pg.c,v 1.3 88/11/03 12:35:21 mike Exp $ (BRL)";
d68 1
a68 1
		if( rp[j].q.q_count != 3 )  {
d73 10
a82 1
		for( i=0; i < 3; i++ )  {
d84 5
a88 2
			MAT4X3PNT( work[i], mat, rp[j].q.q_verts[i] );
			VMINMAX( stp->st_min, stp->st_max, work[i] );
a89 3
		/* Import dbfloat_t normal */
		VMOVE( norm, &(rp[j].q.q_norms[0][X]) );
		(void)pgface( stp, work[0], work[1], work[2], norm );
d158 2
a159 3
	/*  wn is a GIFT-style
	 *  normal, needing to point inwards, whereas N is an outward
	 *  pointing normal.
d168 1
a168 1
		VREVERSE( trip->tri_N, trip->tri_wn );
a170 3
	if( VDOT( trip->tri_wn, trip->tri_N ) > 0 )  {
		VREVERSE( trip->tri_wn, trip->tri_wn );	/* point in */
	}
d375 4
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 7.4 88/05/14 00:47:45 mike Exp $ (BRL)";
a35 1
void	pg_hit_sort();
a46 2
 *  This routine is unusual in that it has to read additional
 *  database records to obtain all the necessary information.
d49 1
a49 1
pg_prep( vecxx, stp, mat, sp, rtip )
d53 1
a53 1
struct solidrec	*sp;
d55 1
d57 3
a59 6
	LOCAL union record rec;
	LOCAL fastf_t dx, dy, dz;	/* For finding the bounding spheres */
	LOCAL struct tri_specific *plp;
	LOCAL fastf_t f;
	LOCAL vect_t work;
	register int	i;
d61 8
a68 8
	for( ;; )  {
		i = fread( (char *)&rec, sizeof(rec), 1, rtip->fp );
		if( feof(rtip->fp) )
			break;
		if( i != 1 )
			rt_bomb("pg_prep():  read error");
		if( rec.u_id != ID_P_DATA )  break;
		if( rec.q.q_count != 3 )  {
d70 1
a70 1
				stp->st_name, rec.q.q_count);
d73 4
a76 4
		for( i=0; i < rec.q.q_count; i++ )  {
			MAT4X3PNT( work, mat, rec.q.q_verts[i] );
			VMOVE( rec.q.q_verts[i], work );
			VMINMAX( stp->st_min, stp->st_max, work );
d78 3
a80 5
		(void)pgface( stp,
			&(rec.q.q_verts[0][X]),
			&(rec.q.q_verts[1][X]),
			&(rec.q.q_verts[2][X]),
			&(rec.q.q_norms[0][X]) );
a85 4
	VSET( stp->st_center,
		(stp->st_max[X] + stp->st_min[X])/2,
		(stp->st_max[Y] + stp->st_min[Y])/2,
		(stp->st_max[Z] + stp->st_min[Z])/2 );
d87 3
a89 8
	dx = (stp->st_max[X] - stp->st_min[X])/2;
	f = dx;
	dy = (stp->st_max[Y] - stp->st_min[Y])/2;
	if( dy > f )  f = dy;
	dz = (stp->st_max[Z] - stp->st_min[Z])/2;
	if( dz > f )  f = dz;
	stp->st_aradius = f;
	stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);
d91 15
d121 3
a123 3
struct soltab *stp;
float *ap, *bp, *cp;
float *np;
d286 3
a288 1
	pg_hit_sort( hits, nhits );
d290 11
a341 19
void
pg_hit_sort( h, nh )
register struct hit h[];
register int nh;
{
	register int i, j;
	LOCAL struct hit temp;

	for( i=0; i < nh-1; i++ )  {
		for( j=i+1; j < nh; j++ )  {
			if( h[i].hit_dist <= h[j].hit_dist )
				continue;
			temp = h[j];		/* struct copy */
			h[j] = h[i];		/* struct copy */
			h[i] = temp;		/* struct copy */
		}
	}
}

d390 3
d394 5
a398 1
pg_plot()
d400 15
@


7.4
log
@lint fixes
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 7.3 88/05/14 00:01:11 mike Locked $ (BRL)";
@


7.3
log
@lint fixes
added zero _uv() routines to some modules
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 7.2 88/02/06 05:36:39 mike Locked $ (BRL)";
d35 2
@


7.2
log
@rt_orthovec to vec_ortho
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 7.1 87/11/02 23:33:45 mike Locked $ (BRL)";
d49 1
d175 1
d328 1
d350 1
d365 4
d377 6
a382 1
pg_uv()
d384 3
d389 1
d392 1
d395 1
d400 1
@


7.1
log
@Release 2.3
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 6.4 87/09/26 03:09:45 mike Exp $ (BRL)";
d386 1
a386 1
	rt_orthovec( cvp->crv_pdir, hitp->hit_normal );
@


6.4
log
@Modified handling of normals.  Problems still seem to remain.
Truncated error messages after 6 times.
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 6.3 87/09/17 07:00:33 mike Locked $ (BRL)";
@


6.3
log
@Changed to VMINMAX, used SQRT_SMALL_FASTF
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 6.2 87/09/17 02:24:05 mike Locked $ (BRL)";
d143 1
a143 1
			(void)rt_log("pg(%s): degenerate facet\n", stp->st_name);
d161 3
a226 1
		LOCAL fastf_t	ds;
d232 1
d235 1
a235 2
		if( rt_g.debug & DEBUG_ARB8 )
			rt_log("Face N.Dir=%f\n", dn );
d259 1
a259 2
		ds = VDOT( wxb, trip->tri_wn );
		k = ds / dn;		/* shot distance */
a272 1
		if(rt_g.debug&DEBUG_ARB8) rt_log("pg: hit dist=%f, dn=%f, k=%f\n", hp->hit_dist, dn, k );
d287 1
d291 2
a292 2
		 * surface infinitely thin and just replicate the entry
		 * point as the exit point.  This at least makes the
d298 7
a304 7
		hits[nhits].hit_dist += 0.1;	/* mm thick */
		rt_log("ERROR: pg(%s): %d hits, false exit\n",
			stp->st_name, nhits);
		nhits++;
		for(i=0; i < nhits; i++ )
			rt_log("%f, ", hits[i].hit_dist );
		rt_log("\n");
a388 1

@


6.2
log
@Removed incorrect warning from pg_norm() routine,
added pg_curve() support (not hard!).
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 6.1 87/07/11 07:56:03 mike Locked $ (BRL)";
a35 4
#define PGMINMAX(a,b,c)	{ FAST fastf_t ftemp;\
			if( (ftemp = (c)) < (a) )  a = ftemp;\
			if( ftemp > (b) )  b = ftemp; }

d78 1
a78 3
			PGMINMAX( stp->st_min[X], stp->st_max[X], work[X] );
			PGMINMAX( stp->st_min[Y], stp->st_max[Y], work[Y] );
			PGMINMAX( stp->st_min[Z], stp->st_max[Z], work[Z] );
d235 2
a236 1
		 *  If ray lies directly along the face, drop this face.
d239 1
a239 1
		if( abs_dn <= 0.0001 )
@


6.1
log
@Release 2.0
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 5.1 87/06/24 22:11:48 mike Rel $ (BRL)";
d46 1
a46 1
 * Process an PG, which is represented as a vector
d365 4
a368 1
pg_norm()
d370 1
a370 1
	rt_log("pg_norm?\n");
d385 4
a388 1
pg_curve()
d390 2
d393 1
@


5.1
log
@Release 1.24
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 4.4 87/03/23 23:41:56 mike Exp $ (BRL)";
@


4.4
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 4.3 87/03/10 23:42:56 mike Exp $ (BRL)";
@


4.3
log
@For Stay, switched 3rd arg to ft_shoot() from resource pointer
(member of application struct) to application struct pointer.
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 4.2 87/02/12 22:11:30 mike Locked $ (BRL)";
d32 2
d53 6
a58 5
pg_prep( vecxx, stp, mat, sp )
fastf_t *vecxx;
struct soltab *stp;
matp_t mat;
struct solidrec *sp;
d68 2
a69 2
		i = fread( (char *)&rec, sizeof(rec), 1, rt_i.fp );
		if( feof(rt_i.fp) )
d184 1
a184 1
	if( trip == (struct tri_specific *)0 )  {
d348 17
d367 1
d369 1
d371 12
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 4.1 86/12/29 03:45:28 mike Rel1 $ (BRL)";
d206 1
a206 1
pg_shot( stp, rp, res )
d209 1
a209 1
struct resource		*res;
d314 1
a314 1
			GET_SEG(newseg, res);
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 3.5 86/12/24 08:05:53 mike Locked $ (BRL)";
@


3.5
log
@Revised for resource structure.
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 3.4 86/08/12 04:16:00 mike Exp $ (BRL)";
@


3.4
log
@Changed #include directives for use with CC -I convention
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 3.3 86/07/19 04:42:13 mike Exp $ (BRL)";
d206 4
a209 3
pg_shot( stp, rp )
struct soltab *stp;
register struct xray *rp;
d314 1
a314 1
			GET_SEG(newseg);
@


3.3
log
@header file change
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 3.2 86/07/17 18:19:47 mike Exp $ (BRL)";
d25 6
a30 6
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/db.h"
#include "../h/raytrace.h"
#include "debug.h"
#include "plane.h"
@


3.2
log
@Upgraded to read the database using stdio.
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 3.1 86/07/11 01:32:15 mike Exp $ (BRL)";
a29 1
#include "rtdir.h"
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d20 1
a20 1
static char RCSpg[] = "@@(#)$Header: pg.c,v 3.0 86/06/10 01:33:18 mike Exp $ (BRL)";
d66 4
a69 3
		i = read( rt_i.fd, (char *) &rec, sizeof(rec) );
		if( i == 0 )  break;
		if( i != sizeof(rec) )
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: pg.c,v 1.2 86/06/09 21:50:38 mike Exp $ (BRL)";
d31 1
a39 12
 *  Describe the tri_specific structure.
 */
struct tri_specific  {
	point_t	tri_A;			/* triangle vertex (A) */
	vect_t	tri_BA;			/* B - A (second point) */
	vect_t	tri_CA;			/* C - A (third point) */
	vect_t	tri_wn;			/* facet normal (non-unit) */
	vect_t	tri_N;			/* unit normal vector */
	struct tri_specific *tri_forw;	/* Next facet */
};

/*
d142 2
a143 2
	if( NEAR_ZERO(m1) || NEAR_ZERO(m2) ||
	    NEAR_ZERO(m3) || NEAR_ZERO(m4) )  {
d156 1
a156 1
	if( !NEAR_ZERO( m3 ) )  {
@


1.2
log
@rt and librt separated
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: pg.c,v 1.1 85/09/24 18:33:18 mike Exp $ (BRL)";
d77 1
a77 1
		i = read( ged_fd, (char *) &rec, sizeof(rec) );
d80 1
a80 1
			rtbomb("pg_prep():  read error");
d83 1
a83 1
			rtlog("pg_prep(%s):  q_count = %d\n",
d101 1
a101 1
		rtlog("pg(%s):  no faces\n", stp->st_name);
d156 2
a157 2
		if( debug & DEBUG_ARB8 )
			(void)rtlog("pg(%s): degenerate facet\n", stp->st_name);
d193 1
a193 1
		rtlog("pg(%s):  no faces\n", stp->st_name);
d202 1
a202 1
		rtlog("\n");
d245 2
a246 2
		if( debug & DEBUG_ARB8 )
			rtlog("Face N.Dir=%f\n", dn );
d284 1
a284 1
		if(debug&DEBUG_ARB8) rtlog("pg: hit dist=%f, dn=%f, k=%f\n", hp->hit_dist, dn, k );
d286 1
a286 1
			rtlog("pg(%s): too many hits\n", stp->st_name);
d310 1
a310 1
		rtlog("ERROR: pg(%s): %d hits, false exit\n",
d314 2
a315 2
			rtlog("%f, ", hits[i].hit_dist );
		rtlog("\n");
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d28 1
a28 1
#include "raytrace.h"
@
