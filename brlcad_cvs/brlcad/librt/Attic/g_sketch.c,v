head	1.49;
access;
symbols
	ansi-20040405-merged:1.45.2.2
	postmerge-20040405-ansi:1.47
	premerge-20040404-ansi:1.46
	postmerge-autoconf:1.46
	autoconf-freeze:1.45.10.2
	premerge-autoconf:1.46
	ansi-20040316-freeze:1.45.2.1
	postmerge-20040315-windows:1.46
	premerge-20040315-windows:1.46
	windows-20040315-freeze:1.45.4.1
	autoconf-20031203:1.45
	autoconf-20031202:1.45
	autoconf-branch:1.45.0.10
	phong-branch:1.45.0.8
	photonmap-branch:1.45.0.6
	rel-6-1-DP:1.45
	windows-branch:1.45.0.4
	rel-6-0-2:1.43
	ansi-branch:1.45.0.2
	rel-6-0-1-branch:1.43.0.2
	hartley-6-0-post:1.44
	hartley-6-0-pre:1.43
	rel-6-0-1:1.43
	rel-6-0:1.41
	rel-5-4:1.23.2.1
	offsite-5-3-pre:1.32
	rel-5-3:1.23.2.1
	rel-5-2:1.23
	rel-5-1-branch:1.23.0.2
	rel-5-1:1.23
	rel-5-0:1.5
	rel-5-0-beta:1.4;
locks; strict;
comment	@ * @;


1.49
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	1.48;

1.48
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	1.47;

1.47
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	1.46;

1.46
date	2004.02.02.17.39.21;	author morrison;	state Exp;
branches;
next	1.45;

1.45
date	2002.08.20.17.08.01;	author jra;	state Exp;
branches
	1.45.2.1
	1.45.4.1
	1.45.10.1;
next	1.44;

1.44
date	2002.08.15.20.55.13;	author hartley;	state Exp;
branches;
next	1.43;

1.43
date	2002.07.16.15.13.31;	author jra;	state Exp;
branches;
next	1.42;

1.42
date	2002.07.16.02.16.30;	author jra;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.02.19.24.30;	author jra;	state Exp;
branches;
next	1.40;

1.40
date	2001.09.27.00.31.28;	author jra;	state Exp;
branches;
next	1.39;

1.39
date	2001.09.26.20.46.41;	author jra;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.28.04.53.31;	author jra;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.21.18.07.25;	author jra;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.30.21.09.46;	author jra;	state Exp;
branches;
next	1.35;

1.35
date	2001.04.25.13.43.29;	author jra;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.20.22.29.47;	author morrison;	state Exp;
branches;
next	1.33;

1.33
date	2001.04.13.15.03.54;	author jra;	state Exp;
branches;
next	1.32;

1.32
date	2000.11.16.21.38.10;	author jra;	state Exp;
branches;
next	1.31;

1.31
date	2000.10.18.18.10.35;	author butler;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.21.02.02.31;	author butler;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.21.19.33.31;	author jra;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.21.19.30.17;	author jra;	state Exp;
branches;
next	1.27;

1.27
date	2000.07.10.23.01.35;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.30.15.38.03;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.30.15.31.15;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.29.17.54.47;	author jra;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.12.02.34.36;	author mike;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2000.04.12.01.17.43;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.17.20.10.35;	author jra;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.16.13.39.27;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.16.01.12.09;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.03.21.29.08;	author jra;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.02.14.47.28;	author jra;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.10.19.49.45;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.31.14.45.49;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.31.13.40.50;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.03.19.34.27;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.03.16.35.01;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	99.12.30.14.23.16;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	99.12.29.22.59.29;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	99.12.29.21.07.44;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	99.11.26.22.02.53;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	99.11.26.21.46.49;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	99.11.17.02.42.01;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	99.07.02.22.19.24;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	99.05.27.19.10.42;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	99.01.13.21.56.30;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	98.06.25.08.24.18;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	98.05.29.14.18.47;	author jra;	state Exp;
branches;
next	;

1.23.2.1
date	2000.11.16.21.36.00;	author jra;	state Exp;
branches;
next	;

1.45.2.1
date	2002.09.19.18.01.35;	author morrison;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	2004.03.17.21.18.48;	author morrison;	state Exp;
branches;
next	;

1.45.4.1
date	2004.03.11.23.43.39;	author morrison;	state Exp;
branches;
next	;

1.45.10.1
date	2004.02.12.18.37.42;	author erikg;	state Exp;
branches;
next	1.45.10.2;

1.45.10.2
date	2004.03.15.14.07.20;	author erikg;	state Exp;
branches;
next	;


desc
@First cut at sketch object.
@


1.49
log
@moved to src/
@
text
@/*
 *			G _ S K E T C H . C
 *
 *  Purpose -
 *	Provide support for 2D sketches
 *
 * Adding a new solid type:
 *	Design disk record
 *
 *	define rt_sketch_internal --- parameters for solid
 *	define sketch_specific --- raytracing form, possibly w/precomuted terms
 *
 *	code import/export/describe/print/ifree/plot/prep/shot/curve/uv/tess
 *
 *	edit db.h add solidrec s_type define
 *	edit rtgeom.h to add rt_sketch_internal
 *	edit table.c:
 *		RT_DECLARE_INTERFACE()
 *		struct rt_functab entry
 *		rt_id_solid()
 *	edit raytrace.h to make ID_SKETCH, increment ID_MAXIMUM
 *	edit db_scan.c to add support for new solid type
 *	edit Cakefile to add g_sketch.c to compile
 *
 *	Then:
 *	go to /cad/libwdb and create mk_sketch() routine
 *	go to /cad/mged and create the edit support
 *
 *  Authors -
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSsketch[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_sketch.c,v 1.48 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include <ctype.h>
#include "tcl.h"
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "rtgeom.h"
#include "./debug.h"

#if !defined(M_PI)
#define M_PI            3.14159265358979323846
#endif

fastf_t rt_cnurb_par_edge(const struct edge_g_cnurb *crv, fastf_t epsilon);
extern void get_indices( genptr_t seg, int *start, int *end );	/* from g_extrude.c */

int
rt_check_curve(struct curve *crv, struct rt_sketch_internal *skt, int noisey)
{
	int i, j;
	int ret=0;

	for( i=0 ; i<crv->seg_count ; i++ )
	{
		struct line_seg *lsg;
		struct carc_seg *csg;
		struct nurb_seg *nsg;
		struct bezier_seg *bsg;
		long *lng;

		lng = (long *)crv->segments[i];

		switch( *lng )
		{
			case CURVE_LSEG_MAGIC:
				lsg = (struct line_seg *)lng;
				if( lsg->start >= skt->vert_count ||
				    lsg->end >= skt->vert_count )
					ret++;
				break;
			case CURVE_CARC_MAGIC:
				csg = (struct carc_seg *)lng;
				if( csg->start >= skt->vert_count ||
				    csg->end >= skt->vert_count )
					ret++;
				break;
			case CURVE_NURB_MAGIC:
				nsg = (struct nurb_seg *)lng;
				for( j=0 ; j<nsg->c_size ; j++ )
				{
					if( nsg->ctl_points[j] >= skt->vert_count )
					{
						ret++;
						break;
					}
				}
				break;
			case CURVE_BEZIER_MAGIC:
				bsg = (struct bezier_seg *)lng;
				for( j=0 ; j<=bsg->degree ; j++ ) {
					if( bsg->ctl_points[j] >= skt->vert_count ) {
						ret++;
						break;
					}
				}
				break;
			default:
				ret++;
				if( noisey )
					bu_log( "Unrecognized segment type in sketch\n");
				break;
		}
	}
	if( ret && noisey )
		bu_log( "sketch references non-existent vertices!!!\n" );
	return( ret );
}

/*
 *  			R T _ S K E T C H _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid SKETCH, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	SKETCH is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct sketch_specific is created, and it's address is stored in
 *  	stp->st_specific for use by sketch_shot().
 */
int
rt_sketch_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	stp->st_specific = (genptr_t)NULL;
	return( 0 );
}

/*
 *			R T _ S K E T C H _ P R I N T
 */
void
rt_sketch_print(register const struct soltab *stp)
{
}

/*
 *  			R T _ S K E T C H _ S H O T
 *  
 *  Intersect a ray with a sketch.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_sketch_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	return(0);			/* MISS */
}

#define RT_SKETCH_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ S K E T C H _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_sketch_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	rt_vstub( stp, rp, segp, n, ap );
}

/*
 *  			R T _ S K E T C H _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_sketch_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
}

/*
 *			R T _ S K E T C H _ C U R V E
 *
 *  Return the curvature of the sketch.
 */
void
rt_sketch_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
 	cvp->crv_c1 = cvp->crv_c2 = 0;

	/* any tangent direction */
 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
}

/*
 *  			R T _ S K E T C H _ U V
 *  
 *  For a hit on the surface of an sketch, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_sketch_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
}

/*
 *		R T _ S K E T C H _ F R E E
 */
void
rt_sketch_free(register struct soltab *stp)
{
}

/*
 *			R T _ S K E T C H _ C L A S S
 */
int
rt_sketch_class(void)
{
	return(0);
}

int
seg_to_vlist(struct bu_list *vhead, const struct rt_tess_tol *ttol, fastf_t *V, fastf_t *u_vec, fastf_t *v_vec, struct rt_sketch_internal *sketch_ip, genptr_t seg)
{
	int		ret=0;
	int		i;
	long		*lng;
	struct line_seg *lsg;
	struct carc_seg *csg;
	struct nurb_seg *nsg;
	struct bezier_seg *bsg;
	fastf_t delta;
	point_t center, start_pt;
	fastf_t pt[4];
	vect_t semi_a, semi_b;
	fastf_t radius;
	vect_t norm;

	lng = (long *)seg;
	switch( *lng )
	{
		case CURVE_LSEG_MAGIC:
			lsg = (struct line_seg *)lng;
			if( lsg->start >= sketch_ip->vert_count ||
			    lsg->end >= sketch_ip->vert_count )
			{
				ret++;
				break;
			}
			VJOIN2( pt, V, sketch_ip->verts[lsg->start][0], u_vec, sketch_ip->verts[lsg->start][1], v_vec);
			RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE )
			VJOIN2( pt, V, sketch_ip->verts[lsg->end][0], u_vec, sketch_ip->verts[lsg->end][1], v_vec);
			RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
			break;
		case CURVE_CARC_MAGIC:
		{
			point2d_t mid_pt, start2d, end2d, center2d, s2m, dir;
			fastf_t s2m_len_sq, len_sq, tmp_len, cross_z;
			fastf_t start_ang, end_ang, tot_ang, cosdel, sindel;
			fastf_t oldu, oldv, newu, newv;
			int nsegs;

			csg = (struct carc_seg *)lng;
			if( csg->start >= sketch_ip->vert_count ||
			    csg->end >= sketch_ip->vert_count )
			{
				ret++;
				break;
			}

			delta = M_PI/4.0;
			if( csg->radius <= 0.0 )
			{
				VJOIN2( center, V, sketch_ip->verts[csg->end][0], u_vec, sketch_ip->verts[csg->end][1], v_vec);
				VJOIN2( pt, V, sketch_ip->verts[csg->start][0], u_vec, sketch_ip->verts[csg->start][1], v_vec);
				VSUB2( semi_a, pt, center );
				VCROSS( norm, u_vec, v_vec );
				VCROSS( semi_b, norm, semi_a );
				VUNITIZE( semi_b );
				radius = MAGNITUDE( semi_a );
				VSCALE( semi_b, semi_b, radius );
			}
			else if( csg->radius < SMALL_FASTF )
			{
				bu_log( "Radius too small in sketch!!\n" );
				break;
			}
			else
				radius = csg->radius;

			if( ttol->abs > 0.0 )
			{
				fastf_t tmp_delta, ratio;

				ratio = ttol->abs / radius;
				if( ratio < 1.0 )
				{
					tmp_delta = 2.0 * acos( 1.0 - ratio);
					if( tmp_delta < delta )
						delta = tmp_delta;
				}
			}
			if( ttol->rel > 0.0 && ttol->rel < 1.0 )
			{
				fastf_t tmp_delta;

				tmp_delta = 2.0 * acos( 1.0 - ttol->rel );
				if( tmp_delta < delta )
					delta = tmp_delta;
			}
			if( ttol->norm > 0.0 )
			{
				fastf_t norm;

				norm = ttol->norm * M_PI / 180.0;
				if( norm < delta )
					delta = norm;
			}
			if( csg->radius <= 0.0 )
			{
				/* this is a full circle */
				nsegs = ceil( 2.0 * M_PI / delta );
				delta = 2.0 * M_PI / (double)nsegs;
				cosdel = cos( delta );
				sindel = sin( delta );
				oldu = 1.0;
				oldv = 0.0;
				VJOIN2( start_pt, center, oldu, semi_a, oldv, semi_b );
				RT_ADD_VLIST( vhead, start_pt, BN_VLIST_LINE_MOVE );
				for( i=1 ; i<nsegs ; i++ )
				{
					newu = oldu * cosdel - oldv * sindel;
					newv = oldu * sindel + oldv * cosdel;
					VJOIN2( pt, center, newu, semi_a, newv, semi_b );
					RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
					oldu = newu;
					oldv = newv;
				}
				RT_ADD_VLIST( vhead, start_pt, BN_VLIST_LINE_DRAW );
				break;
			}

			/* this is an arc (not a full circle) */
			V2MOVE( start2d, sketch_ip->verts[csg->start] );
			V2MOVE( end2d, sketch_ip->verts[csg->end] );
			mid_pt[0] = (start2d[0] + end2d[0]) * 0.5;
			mid_pt[1] = (start2d[1] + end2d[1]) * 0.5;
			V2SUB2( s2m, mid_pt, start2d )
			dir[0] = -s2m[1];
			dir[1] = s2m[0];
			s2m_len_sq =  s2m[0]*s2m[0] + s2m[1]*s2m[1];
			if( s2m_len_sq < SMALL_FASTF )
			{
				bu_log( "start and end points are too close together in circular arc of sketch\n" );
				break;
			}
			len_sq = radius*radius - s2m_len_sq;
			if( len_sq < 0.0 )
			{
				bu_log( "Impossible radius for specified start and end points in circular arc\n");
				break;
			}
			tmp_len = sqrt( dir[0]*dir[0] + dir[1]*dir[1] );
			dir[0] = dir[0] / tmp_len;
			dir[1] = dir[1] / tmp_len;
			tmp_len = sqrt( len_sq );
			V2JOIN1( center2d, mid_pt, tmp_len, dir )

			/* check center location */
			cross_z = ( end2d[X] - start2d[X] )*( center2d[Y] - start2d[Y] ) -
				( end2d[Y] - start2d[Y] )*( center2d[X] - start2d[X] );
			if( !(cross_z > 0.0 && csg->center_is_left) )
				V2JOIN1( center2d, mid_pt, -tmp_len, dir );
			start_ang = atan2( start2d[Y]-center2d[Y], start2d[X]-center2d[X] );
			end_ang = atan2( end2d[Y]-center2d[Y], end2d[X]-center2d[X] );
			if( csg->orientation ) /* clock-wise */
			{
				while( end_ang > start_ang )
					end_ang -= 2.0 * M_PI;
			}
			else /* counter-clock-wise */
			{
				while( end_ang < start_ang )
					end_ang += 2.0 * M_PI;
			}
			tot_ang = end_ang - start_ang;
			nsegs = ceil( tot_ang / delta );
			if( nsegs < 0 )
				nsegs = -nsegs;
			if( nsegs < 3 )
				nsegs = 3;
			delta = tot_ang / nsegs;
			cosdel = cos( delta );
			sindel = sin( delta );
			VJOIN2( center, V, center2d[0], u_vec, center2d[1], v_vec );
			VJOIN2( start_pt, V, start2d[0], u_vec, start2d[1], v_vec );
			oldu = (start2d[0] - center2d[0]);
			oldv = (start2d[1] - center2d[1]);
			RT_ADD_VLIST( vhead, start_pt, BN_VLIST_LINE_MOVE );
			for( i=0 ; i<nsegs ; i++ )
			{
				newu = oldu * cosdel - oldv * sindel;
				newv = oldu * sindel + oldv * cosdel;
				VJOIN2( pt, center, newu, u_vec, newv, v_vec );
				RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
				oldu = newu;
				oldv = newv;
			}
			break;
		}
		case CURVE_NURB_MAGIC:
		{
			struct edge_g_cnurb eg;
			int coords;
			fastf_t inv_weight;
			int num_intervals;
			fastf_t param_delta, epsilon;

			nsg = (struct nurb_seg *)lng;
			for( i=0 ; i<nsg->c_size ; i++ )
			{
				if( nsg->ctl_points[i] >= sketch_ip->vert_count )
				{
					ret++;
					break;
				}
			}
			if( nsg->order < 3 )
			{
				/* just straight lines */
				VJOIN2( start_pt, V, sketch_ip->verts[nsg->ctl_points[0]][0], u_vec, sketch_ip->verts[nsg->ctl_points[0]][1], v_vec );
				if( RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) )
				{
					inv_weight = 1.0/nsg->weights[0];
					VSCALE( start_pt, start_pt, inv_weight );
				}
				RT_ADD_VLIST( vhead, start_pt, BN_VLIST_LINE_MOVE );
				for( i=1 ; i<nsg->c_size ; i++ )
				{
					VJOIN2( pt, V, sketch_ip->verts[nsg->ctl_points[i]][0], u_vec, sketch_ip->verts[nsg->ctl_points[i]][1], v_vec );
					if( RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) )
					{
						inv_weight = 1.0/nsg->weights[i];
						VSCALE( pt, pt, inv_weight );
					}
					RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
				}
				break;
			}
			eg.l.magic = NMG_EDGE_G_CNURB_MAGIC;
			eg.order = nsg->order;
			eg.k.k_size = nsg->k.k_size;
			eg.k.knots = nsg->k.knots;
			eg.c_size = nsg->c_size;
			coords = 3 + RT_NURB_IS_PT_RATIONAL( nsg->pt_type );
			eg.pt_type = RT_NURB_MAKE_PT_TYPE( coords, 2, RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) );
			eg.ctl_points = (fastf_t *)bu_malloc( nsg->c_size * coords * sizeof( fastf_t ), "eg.ctl_points" );
			if( RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) )
			{
				for( i=0 ; i<nsg->c_size ; i++ )
				{
					VJOIN2( &eg.ctl_points[i*coords], V, sketch_ip->verts[nsg->ctl_points[i]][0], u_vec, sketch_ip->verts[nsg->ctl_points[i]][1], v_vec );
					eg.ctl_points[(i+1)*coords - 1] = nsg->weights[i];
				}
			}
			else
			{
				for( i=0 ; i<nsg->c_size ; i++ )
					VJOIN2( &eg.ctl_points[i*coords], V, sketch_ip->verts[nsg->ctl_points[i]][0], u_vec, sketch_ip->verts[nsg->ctl_points[i]][1], v_vec );
			}
			epsilon = MAX_FASTF;
			if( ttol->abs > 0.0 && ttol->abs < epsilon )
				epsilon = ttol->abs;
			if( ttol->rel > 0.0 )
			{
				point2d_t min_pt, max_pt, tmp_pt;
				point2d_t diff;
				fastf_t tmp_epsilon;

				min_pt[0] = MAX_FASTF;
				min_pt[1] = MAX_FASTF;
				max_pt[0] = -MAX_FASTF;
				max_pt[1] = -MAX_FASTF;

				for( i=0 ; i<nsg->c_size ; i++ )
				{
					V2MOVE( tmp_pt, sketch_ip->verts[nsg->ctl_points[i]] );
					if( tmp_pt[0] > max_pt[0] )
						max_pt[0] = tmp_pt[0];
					if( tmp_pt[1] > max_pt[1] )
						max_pt[1] = tmp_pt[1];
					if( tmp_pt[0] < min_pt[0] )
						min_pt[0] = tmp_pt[0];
					if( tmp_pt[1] < min_pt[1] )
						min_pt[1] = tmp_pt[1];
				}

				V2SUB2( diff, max_pt, min_pt )
				tmp_epsilon = ttol->rel * sqrt( MAG2SQ( diff ) );
				if( tmp_epsilon < epsilon )
					epsilon = tmp_epsilon;
				
			}
			param_delta = rt_cnurb_par_edge( &eg, epsilon );
			num_intervals = ceil( (nsg->k.knots[nsg->k.k_size-1] - nsg->k.knots[0])/param_delta );
			if( num_intervals < 3 )
				num_intervals = 3;
			if( num_intervals > 500 )
			{
				bu_log( "num_intervals was %d\n", num_intervals );
				num_intervals = 500;
			}
			param_delta = (nsg->k.knots[nsg->k.k_size-1] - nsg->k.knots[0])/(double)num_intervals;
			for( i=0 ; i<=num_intervals ; i++ )
			{
				fastf_t t;
				int j;

				t = nsg->k.knots[0] + i*param_delta;
				rt_nurb_c_eval( &eg, t, pt );
				if( RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) )
				{
					for( j=0 ; j<coords-1 ; j++ )
						pt[j] /= pt[coords-1];
				}
				if( i == 0 )
					RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE )
				else
					RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
			}
			bu_free( (char *)eg.ctl_points, "eg.ctl_points" );
			break;
		}
		case CURVE_BEZIER_MAGIC: {
			struct bezier_2d_list *bezier_hd, *bz;
			fastf_t epsilon;

			bsg = (struct bezier_seg *)lng;

			for( i=0 ; i<=bsg->degree ; i++ ) {
				if( bsg->ctl_points[i] >= sketch_ip->vert_count ) {
					ret++;
					break;
				}
			}

			if( bsg->degree < 1 ) {
				bu_log( "g_sketch: ERROR: Bezier curve with illegal degree (%d)\n",
					bsg->degree );
				ret++;
				break;
			}

			if( bsg->degree == 1 ) {
				/* straight line */
				VJOIN2( start_pt, V, sketch_ip->verts[bsg->ctl_points[0]][0],
					u_vec, sketch_ip->verts[bsg->ctl_points[0]][1], v_vec );
				RT_ADD_VLIST( vhead, start_pt, BN_VLIST_LINE_MOVE );
				for( i=1 ; i<=bsg->degree ; i++ ) {
					VJOIN2( pt, V, sketch_ip->verts[bsg->ctl_points[i]][0],
						u_vec, sketch_ip->verts[bsg->ctl_points[i]][1], v_vec );
					RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
				}
				break;
			}

			/* use tolerance to determine coarseness of plot */
			epsilon = MAX_FASTF;
			if( ttol->abs > 0.0 && ttol->abs < epsilon )
				epsilon = ttol->abs;
			if( ttol->rel > 0.0 )
			{
				point2d_t min_pt, max_pt, tmp_pt;
				point2d_t diff;
				fastf_t tmp_epsilon;

				min_pt[0] = MAX_FASTF;
				min_pt[1] = MAX_FASTF;
				max_pt[0] = -MAX_FASTF;
				max_pt[1] = -MAX_FASTF;

				for( i=0 ; i<=bsg->degree ; i++ )
				{
					V2MOVE( tmp_pt, sketch_ip->verts[bsg->ctl_points[i]] );
					if( tmp_pt[0] > max_pt[0] )
						max_pt[0] = tmp_pt[0];
					if( tmp_pt[1] > max_pt[1] )
						max_pt[1] = tmp_pt[1];
					if( tmp_pt[0] < min_pt[0] )
						min_pt[0] = tmp_pt[0];
					if( tmp_pt[1] < min_pt[1] )
						min_pt[1] = tmp_pt[1];
				}

				V2SUB2( diff, max_pt, min_pt )
				tmp_epsilon = ttol->rel * sqrt( MAG2SQ( diff ) );
				if( tmp_epsilon < epsilon )
					epsilon = tmp_epsilon;
				
			}
			

			/* Create an initial bezier_2d_list */
			bezier_hd = (struct bezier_2d_list *)bu_malloc( sizeof( struct bezier_2d_list ),
								     "g_sketch.c: bezier_hd" );
			BU_LIST_INIT( &bezier_hd->l );
			bezier_hd->ctl = (point2d_t *)bu_calloc( bsg->degree + 1, sizeof( point2d_t ),
								 "g_sketch.c: bezier_hd->ctl" );
			for( i=0 ; i<=bsg->degree ; i++ ) {
				V2MOVE( bezier_hd->ctl[i], sketch_ip->verts[bsg->ctl_points[i]] );
			}

			/* now do subdivision as necessary */
			bezier_hd = subdivide_bezier( bezier_hd, bsg->degree, epsilon, 0 );

			/* plot the results */
			bz = BU_LIST_FIRST( bezier_2d_list, &bezier_hd->l );
			VJOIN2( pt, V, bz->ctl[0][0], u_vec, bz->ctl[0][1], v_vec);
			RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE );

			while( BU_LIST_WHILE( bz, bezier_2d_list, &(bezier_hd->l) ) ) {
				BU_LIST_DEQUEUE( &bz->l );
				for( i=1 ; i<=bsg->degree ; i++ ) {
					VJOIN2( pt, V, bz->ctl[i][0], u_vec,
						bz->ctl[i][1], v_vec);
					RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
				}
				bu_free( (char *)bz->ctl, "g_sketch.c: bz->ctl" );
				bu_free( (char *)bz, "g_sketch.c: bz" );
			}
			bu_free( (char *)bezier_hd, "g_sketch.c: bezier_hd" );
			break;
		}
		default:
			bu_log( "seg_to_vlist: ERROR: unrecognized segment type!!!!\n" );
			break;
	}

	return( ret );
}

/*
 *			C U R V E _ T O _ V L I S T
 */
int
curve_to_vlist(struct bu_list *vhead, const struct rt_tess_tol *ttol, fastf_t *V, fastf_t *u_vec, fastf_t *v_vec, struct rt_sketch_internal *sketch_ip, struct curve *crv)
{
	int seg_no;
	int ret=0;

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at start of curve_to_vlist():\n" );
		bu_mem_barriercheck();
	}

	for( seg_no=0 ; seg_no < crv->seg_count ; seg_no++ )
	{
		ret += seg_to_vlist( vhead, ttol, V, u_vec, v_vec, sketch_ip, crv->segments[seg_no] );
	}

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at end of curve_to_vlist():\n" );
		bu_mem_barriercheck();
	}

	return( ret );
}

/*
 *			R T _ S K E T C H _ P L O T
 */
int
rt_sketch_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct rt_sketch_internal	*sketch_ip;
	int				ret;
	int				myret=0;

	RT_CK_DB_INTERNAL(ip);
	sketch_ip = (struct rt_sketch_internal *)ip->idb_ptr;
	RT_SKETCH_CK_MAGIC(sketch_ip);

	if( (ret=curve_to_vlist( vhead, ttol, sketch_ip->V, sketch_ip->u_vec, sketch_ip->v_vec, sketch_ip, &sketch_ip->skt_curve )) )
	{
		myret--;
		bu_log( "WARNING: Errors in sketch (%d segments reference non-existent vertices)\n",
			 ret );
	}

	return( myret );
}

/*
 *			R T _ S K E T C H _ T E S S
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_sketch_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	return(-1);
}

/*
 *			R T _ S K E T C H _ I M P O R T
 *
 *  Import an SKETCH from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_sketch_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	LOCAL struct rt_sketch_internal	*sketch_ip;
	union record			*rp;
	vect_t				v;
	int				seg_no;
	unsigned char			*ptr;
	struct curve			*crv;
	int				i;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != DBID_SKETCH )  {
		bu_log("rt_sketch_import: defective record\n");
		return(-1);
	}

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at start of sketch_import():\n" );
		bu_mem_barriercheck();
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_SKETCH;
	ip->idb_meth = &rt_functab[ID_SKETCH];
	ip->idb_ptr = bu_calloc( 1, sizeof(struct rt_sketch_internal), "rt_sketch_internal");
	sketch_ip = (struct rt_sketch_internal *)ip->idb_ptr;
	sketch_ip->magic = RT_SKETCH_INTERNAL_MAGIC;

	ntohd( (unsigned char *)v, rp->skt.skt_V, 3 );
	MAT4X3PNT( sketch_ip->V, mat, v );
	ntohd( (unsigned char *)v, rp->skt.skt_uvec, 3 );
	MAT4X3VEC( sketch_ip->u_vec, mat, v );
	ntohd( (unsigned char *)v, rp->skt.skt_vvec, 3 );
	MAT4X3VEC( sketch_ip->v_vec, mat, v );
	sketch_ip->vert_count = bu_glong( rp->skt.skt_vert_count );
	sketch_ip->skt_curve.seg_count = bu_glong( rp->skt.skt_seg_count );

	ptr = (unsigned char *)rp;
	ptr += sizeof( struct sketch_rec );
	if( sketch_ip->vert_count )
		sketch_ip->verts = (point2d_t *)bu_calloc( sketch_ip->vert_count, sizeof( point2d_t ), "sketch_ip->vert" );
	ntohd( (unsigned char *)sketch_ip->verts, ptr, sketch_ip->vert_count*2 );
	ptr += 16 * sketch_ip->vert_count;

	if( sketch_ip->skt_curve.seg_count )
		sketch_ip->skt_curve.segments = (genptr_t *)bu_calloc( sketch_ip->skt_curve.seg_count, sizeof( genptr_t ), "segs" );
	else
		sketch_ip->skt_curve.segments = (genptr_t *)NULL;
	for( seg_no=0 ; seg_no < sketch_ip->skt_curve.seg_count ; seg_no++ )
	{
		long magic;
		struct line_seg *lsg;
		struct carc_seg *csg;
		struct nurb_seg *nsg;
		struct bezier_seg *bsg;
		int i;

		magic = bu_glong( ptr );
		ptr += 4;
		switch( magic )
		{
			case CURVE_LSEG_MAGIC:
				lsg = (struct line_seg *)bu_malloc( sizeof( struct line_seg ), "lsg" );
				lsg->magic = magic;
				lsg->start = bu_glong( ptr );
				ptr += 4;
				lsg->end = bu_glong( ptr );
				ptr += 4;
				sketch_ip->skt_curve.segments[seg_no] = (genptr_t)lsg;
				break;
			case CURVE_CARC_MAGIC:
				csg = (struct carc_seg *)bu_malloc( sizeof( struct carc_seg ), "csg" );
				csg->magic = magic;
				csg->start = bu_glong( ptr );
				ptr += 4;
				csg->end = bu_glong( ptr );
				ptr += 4;
				csg->orientation = bu_glong( ptr );
				ptr += 4;
				csg->center_is_left = bu_glong( ptr );
				ptr += 4;
				ntohd( (unsigned char *)&csg->radius, ptr, 1 );
				ptr += 8;
				sketch_ip->skt_curve.segments[seg_no] = (genptr_t)csg;
				break;
			case CURVE_NURB_MAGIC:
				nsg = (struct nurb_seg *)bu_malloc( sizeof( struct nurb_seg ), "nsg" );
				nsg->magic = magic;
				nsg->order = bu_glong( ptr );
				ptr += 4;
				nsg->pt_type = bu_glong( ptr );
				ptr += 4;
				nsg->k.k_size = bu_glong( ptr );
				ptr += 4;
				nsg->k.knots = (fastf_t *)bu_malloc( nsg->k.k_size * sizeof( fastf_t ), "nsg->k.knots" );
				ntohd( (unsigned char *)nsg->k.knots, ptr, nsg->k.k_size );
				ptr += 8 * nsg->k.k_size;
				nsg->c_size = bu_glong( ptr );
				ptr += 4;
				nsg->ctl_points = (int *)bu_malloc( nsg->c_size * sizeof( int ), "nsg->ctl_points" );
				for( i=0 ; i<nsg->c_size ; i++ )
				{
					nsg->ctl_points[i] = bu_glong( ptr );
					ptr += 4;
				}
				if( RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) )
				{
					nsg->weights = (fastf_t *)bu_malloc( nsg->c_size * sizeof( fastf_t ), "nsg->weights" );
					ntohd( (unsigned char *)nsg->weights, ptr, nsg->c_size );
					ptr += 8 * nsg->c_size;
				}
				else
					nsg->weights = (fastf_t *)NULL;
				sketch_ip->skt_curve.segments[seg_no] = (genptr_t)nsg;
				break;
			case CURVE_BEZIER_MAGIC:
				bsg = (struct bezier_seg *)bu_malloc( sizeof( struct bezier_seg ), "bsg" );
				bsg->magic = magic;
				bsg->degree = bu_glong( ptr );
				ptr += 4;
				bsg->ctl_points = (int *)bu_calloc( bsg->degree + 1, sizeof( int ), "bsg->ctl_points" );
				for( i=0 ; i<=bsg->degree ; i++ ) {
					bsg->ctl_points[i] = bu_glong( ptr );
					ptr += 4;
				}
				sketch_ip->skt_curve.segments[seg_no] = (genptr_t)bsg;
				break;
			default:
				bu_bomb( "rt_sketch_import: ERROR: unrecognized segment type!!!\n" );
				break;
		}
	}

	crv = &sketch_ip->skt_curve;

	crv->reverse = (int *)bu_calloc( crv->seg_count, sizeof(int), "crv->reverse" );
	for( i=0 ; i<crv->seg_count ; i++ )
	{
		crv->reverse[i] = bu_glong( ptr );
		ptr += 4;
	}

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at end of sketch_import():\n" );
		bu_mem_barriercheck();
	}

	return(0);			/* OK */
}

/*
 *			R T _ S K E T C H _ E X P O R T
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_sketch_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_sketch_internal	*sketch_ip;
	union record		*rec;
	int	i, seg_no, nbytes=0, ngran;
	vect_t tmp_vec;
	unsigned char *ptr;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_SKETCH )  return(-1);
	sketch_ip = (struct rt_sketch_internal *)ip->idb_ptr;
	RT_SKETCH_CK_MAGIC(sketch_ip);

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at start of sketch_export():\n" );
		bu_mem_barriercheck();
	}

	BU_CK_EXTERNAL(ep);

	nbytes = sizeof(union record);		/* base record */
	nbytes += sketch_ip->vert_count*(8*2);	/* vertex list */

	for( seg_no=0 ; seg_no < sketch_ip->skt_curve.seg_count ; seg_no++ )
	{
		long *lng;
		struct nurb_seg *nseg;
		struct bezier_seg *bseg;

		lng = (long *)sketch_ip->skt_curve.segments[seg_no];
		switch( *lng )
		{
			case CURVE_LSEG_MAGIC:
				nbytes += 12;
				break;
			case CURVE_CARC_MAGIC:
				nbytes += 28;
				break;
			case CURVE_NURB_MAGIC:
				nseg = (struct nurb_seg *)lng;
				nbytes += 16 + sizeof( struct knot_vector) + nseg->k.k_size * 8 + nseg->c_size * 4;
				if( RT_NURB_IS_PT_RATIONAL( nseg->pt_type ) )
					nbytes += nseg->c_size * 8;	/* weights */
				break;
			case CURVE_BEZIER_MAGIC:
				bseg = (struct bezier_seg *)lng;
				nbytes += 8 + (bseg->degree + 1) * 4;
				break;
			default:
				bu_log( "rt_sketch_export: unsupported segement type (x%x)\n", *lng );
				bu_bomb( "rt_sketch_export: unsupported segement type\n" );
		}
	}

	ngran = ceil((double)(nbytes + sizeof(union record)) / sizeof(union record));
	ep->ext_nbytes = ngran * sizeof(union record);	
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "sketch external");

	rec = (union record *)ep->ext_buf;

	rec->skt.skt_id = DBID_SKETCH;

	/* convert from local editing units to mm and export
	 * to database record format
	 */
	VSCALE( tmp_vec, sketch_ip->V, local2mm );
	htond( rec->skt.skt_V, (unsigned char *)tmp_vec, 3 );

	/* uvec and uvec are unit vectors, do not convert to/from mm */
	htond( rec->skt.skt_uvec, (unsigned char *)sketch_ip->u_vec, 3 );
	htond( rec->skt.skt_vvec, (unsigned char *)sketch_ip->v_vec, 3 );

	(void)bu_plong( rec->skt.skt_vert_count, sketch_ip->vert_count );
	(void)bu_plong( rec->skt.skt_seg_count, sketch_ip->skt_curve.seg_count );
	(void)bu_plong( rec->skt.skt_count, ngran-1 );

	ptr = (unsigned char *)rec;
	ptr += sizeof( struct sketch_rec );
	/* convert 2D points to mm */
	for( i=0 ; i<sketch_ip->vert_count ; i++ )
	{
		point2d_t pt2d;

		V2SCALE( pt2d, sketch_ip->verts[i], local2mm )
		htond( ptr, (const unsigned char *)pt2d, 2 );
		ptr += 16;
	}

	for( seg_no=0 ; seg_no < sketch_ip->skt_curve.seg_count ; seg_no++ )
	{
		struct line_seg *lseg;
		struct carc_seg *cseg;
		struct nurb_seg *nseg;
		struct bezier_seg *bseg;
		long *lng;
		fastf_t tmp_fastf;

		/* write segment type ID, and segement parameters */
		lng = (long *)sketch_ip->skt_curve.segments[seg_no];
		switch (*lng )
		{
			case CURVE_LSEG_MAGIC:
				lseg = (struct line_seg *)lng;
				(void)bu_plong( ptr, CURVE_LSEG_MAGIC );
				ptr += 4;
				(void)bu_plong( ptr, lseg->start );
				ptr += 4;
				(void)bu_plong( ptr, lseg->end );
				ptr += 4;
				break;
			case CURVE_CARC_MAGIC:
				cseg = (struct carc_seg *)lng;
				(void)bu_plong( ptr, CURVE_CARC_MAGIC );
				ptr += 4;
				(void)bu_plong( ptr, cseg->start );
				ptr += 4;
				(void)bu_plong( ptr, cseg->end );
				ptr += 4;
				(void) bu_plong( ptr, cseg->orientation );
				ptr += 4;
				(void) bu_plong( ptr, cseg->center_is_left );
				ptr += 4;
				tmp_fastf = cseg->radius * local2mm;
				htond( ptr, (unsigned char *)&tmp_fastf, 1 );
				ptr += 8;
				break;
			case CURVE_NURB_MAGIC:
				nseg = (struct nurb_seg *)lng;
				(void)bu_plong( ptr, CURVE_NURB_MAGIC );
				ptr += 4;
				(void)bu_plong( ptr, nseg->order );
				ptr += 4;
				(void)bu_plong( ptr, nseg->pt_type );
				ptr += 4;
				(void)bu_plong( ptr, nseg->k.k_size );
				ptr += 4;
				htond( ptr, (const unsigned char *)nseg->k.knots, nseg->k.k_size );
				ptr += nseg->k.k_size * 8;
				(void)bu_plong( ptr, nseg->c_size );
				ptr += 4;
				for( i=0 ; i<nseg->c_size ; i++ )
				{
					(void)bu_plong( ptr, nseg->ctl_points[i] );
					ptr +=  4;
				}
				if( RT_NURB_IS_PT_RATIONAL( nseg->pt_type ) )
				{
					htond( ptr, (const unsigned char *)nseg->weights, nseg->c_size );
					ptr += 8 * nseg->c_size;
				}
				break;
			case CURVE_BEZIER_MAGIC:
				bseg = (struct bezier_seg *)lng;
				(void)bu_plong( ptr, CURVE_BEZIER_MAGIC );
				ptr += 4;
				(void)bu_plong( ptr, bseg->degree );
				ptr += 4;
				for( i=0 ; i<=bseg->degree ; i++ ) {
					(void)bu_plong( ptr, bseg->ctl_points[i] );
					ptr += 4;
				}
				break;
			default:
				bu_bomb( "rt_sketch_export: ERROR: unrecognized curve type!!!!\n" );
				break;
				
		}
	}

	for( seg_no=0 ; seg_no < sketch_ip->skt_curve.seg_count ; seg_no++ )
	{
		(void)bu_plong( ptr, sketch_ip->skt_curve.reverse[seg_no] );
		ptr += 4;
	}
	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at end of sketch_export():\n" );
		bu_mem_barriercheck();
	}

	return(0);
}


/*
 *			R T _ S K E T C H _ I M P O R T 5
 *
 *  Import an SKETCH from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_sketch_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	LOCAL struct rt_sketch_internal	*sketch_ip;
	vect_t				v;
	int				seg_no;
	unsigned char			*ptr;
	struct curve			*crv;
	int				i;

	BU_CK_EXTERNAL( ep );

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at start of sketch_import5():\n" );
		bu_mem_barriercheck();
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_SKETCH;
	ip->idb_meth = &rt_functab[ID_SKETCH];
	ip->idb_ptr = bu_calloc( 1, sizeof(struct rt_sketch_internal), "rt_sketch_internal");
	sketch_ip = (struct rt_sketch_internal *)ip->idb_ptr;
	sketch_ip->magic = RT_SKETCH_INTERNAL_MAGIC;

	ptr = ep->ext_buf;
	ntohd( (unsigned char *)v, ptr, 3 );
	MAT4X3PNT( sketch_ip->V, mat, v );
	ptr += SIZEOF_NETWORK_DOUBLE * 3;
	ntohd( (unsigned char *)v, ptr, 3 );
	MAT4X3VEC( sketch_ip->u_vec, mat, v );
	ptr += SIZEOF_NETWORK_DOUBLE * 3;
	ntohd( (unsigned char *)v, ptr, 3 );
	MAT4X3VEC( sketch_ip->v_vec, mat, v );
	ptr += SIZEOF_NETWORK_DOUBLE * 3;
	sketch_ip->vert_count = bu_glong( ptr );
	ptr += SIZEOF_NETWORK_LONG;
	sketch_ip->skt_curve.seg_count = bu_glong( ptr );
	ptr += SIZEOF_NETWORK_LONG;

	if( sketch_ip->vert_count )
		sketch_ip->verts = (point2d_t *)bu_calloc( sketch_ip->vert_count, sizeof( point2d_t ), "sketch_ip->vert" );
	ntohd( (unsigned char *)sketch_ip->verts, ptr, sketch_ip->vert_count*2 );
	ptr += SIZEOF_NETWORK_DOUBLE * 2 * sketch_ip->vert_count;

	if( sketch_ip->skt_curve.seg_count )
		sketch_ip->skt_curve.segments = (genptr_t *)bu_calloc( sketch_ip->skt_curve.seg_count, sizeof( genptr_t ), "segs" );
	else
		sketch_ip->skt_curve.segments = (genptr_t *)NULL;
	for( seg_no=0 ; seg_no < sketch_ip->skt_curve.seg_count ; seg_no++ )
	{
		long magic;
		struct line_seg *lsg;
		struct carc_seg *csg;
		struct nurb_seg *nsg;
		struct bezier_seg *bsg;
		int i;

		magic = bu_glong( ptr );
		ptr += SIZEOF_NETWORK_LONG;
		switch( magic )
		{
			case CURVE_LSEG_MAGIC:
				lsg = (struct line_seg *)bu_malloc( sizeof( struct line_seg ), "lsg" );
				lsg->magic = magic;
				lsg->start = bu_glong( ptr );
				ptr += SIZEOF_NETWORK_LONG;
				lsg->end = bu_glong( ptr );
				ptr += SIZEOF_NETWORK_LONG;
				sketch_ip->skt_curve.segments[seg_no] = (genptr_t)lsg;
				break;
			case CURVE_CARC_MAGIC:
				csg = (struct carc_seg *)bu_malloc( sizeof( struct carc_seg ), "csg" );
				csg->magic = magic;
				csg->start = bu_glong( ptr );
				ptr += SIZEOF_NETWORK_LONG;
				csg->end = bu_glong( ptr );
				ptr += SIZEOF_NETWORK_LONG;
				csg->orientation = bu_glong( ptr );
				ptr += SIZEOF_NETWORK_LONG;
				csg->center_is_left = bu_glong( ptr );
				ptr += SIZEOF_NETWORK_LONG;
				ntohd( (unsigned char *)&csg->radius, ptr, 1 );
				ptr += SIZEOF_NETWORK_DOUBLE;
				sketch_ip->skt_curve.segments[seg_no] = (genptr_t)csg;
				break;
			case CURVE_NURB_MAGIC:
				nsg = (struct nurb_seg *)bu_malloc( sizeof( struct nurb_seg ), "nsg" );
				nsg->magic = magic;
				nsg->order = bu_glong( ptr );
				ptr += SIZEOF_NETWORK_LONG;
				nsg->pt_type = bu_glong( ptr );
				ptr += SIZEOF_NETWORK_LONG;
				nsg->k.k_size = bu_glong( ptr );
				ptr += SIZEOF_NETWORK_LONG;
				nsg->k.knots = (fastf_t *)bu_malloc( nsg->k.k_size * sizeof( fastf_t ), "nsg->k.knots" );
				ntohd( (unsigned char *)nsg->k.knots, ptr, nsg->k.k_size );
				ptr += SIZEOF_NETWORK_DOUBLE * nsg->k.k_size;
				nsg->c_size = bu_glong( ptr );
				ptr += SIZEOF_NETWORK_LONG;
				nsg->ctl_points = (int *)bu_malloc( nsg->c_size * sizeof( int ), "nsg->ctl_points" );
				for( i=0 ; i<nsg->c_size ; i++ )
				{
					nsg->ctl_points[i] = bu_glong( ptr );
					ptr += SIZEOF_NETWORK_LONG;
				}
				if( RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) )
				{
					nsg->weights = (fastf_t *)bu_malloc( nsg->c_size * sizeof( fastf_t ), "nsg->weights" );
					ntohd( (unsigned char *)nsg->weights, ptr, nsg->c_size );
					ptr += SIZEOF_NETWORK_DOUBLE * nsg->c_size;
				}
				else
					nsg->weights = (fastf_t *)NULL;
				sketch_ip->skt_curve.segments[seg_no] = (genptr_t)nsg;
				break;
			case CURVE_BEZIER_MAGIC:
				bsg = (struct bezier_seg *)bu_malloc( sizeof( struct bezier_seg ), "bsg" );
				bsg->magic = magic;
				bsg->degree = bu_glong( ptr );
				ptr += SIZEOF_NETWORK_LONG;
				bsg->ctl_points = (int *)bu_calloc( bsg->degree+1, sizeof( int ), "bsg->ctl_points" );
				for( i=0 ; i<=bsg->degree ; i++ ) {
					bsg->ctl_points[i] = bu_glong( ptr );
					ptr += SIZEOF_NETWORK_LONG;
				}
				sketch_ip->skt_curve.segments[seg_no] = (genptr_t)bsg;
				break;
			default:
				bu_bomb( "rt_sketch_import: ERROR: unrecognized segment type!!!\n" );
				break;
		}
	}

	crv = &sketch_ip->skt_curve;

	crv->reverse = (int *)bu_calloc( crv->seg_count, sizeof(int), "crv->reverse" );
	for( i=0 ; i<crv->seg_count ; i++ )
	{
		crv->reverse[i] = bu_glong( ptr );
		ptr += SIZEOF_NETWORK_LONG;
	}

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at end of sketch_import5():\n" );
		bu_mem_barriercheck();
	}

	return(0);			/* OK */
}

/*
 *			R T _ S K E T C H _ E X P O R T 5
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_sketch_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_sketch_internal	*sketch_ip;
	unsigned char			*cp;
	int				seg_no;
	int				i;
	vect_t				tmp_vec;

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at start of sketch_export5():\n" );
		bu_mem_barriercheck();
	}

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_SKETCH )  return(-1);
	sketch_ip = (struct rt_sketch_internal *)ip->idb_ptr;
	RT_SKETCH_CK_MAGIC(sketch_ip);

	BU_CK_EXTERNAL(ep);

	/* tally up size of buffer needed */
	ep->ext_nbytes = 3 * (3 * SIZEOF_NETWORK_DOUBLE)	/* V, u_vec, v_vec */
		+ 2 * SIZEOF_NETWORK_LONG		/* vert_count and seg_count */
		+ 2 * sketch_ip->vert_count * SIZEOF_NETWORK_DOUBLE	/* 2D-vertices */
		+ sketch_ip->skt_curve.seg_count * SIZEOF_NETWORK_LONG;	/* reverse flags */

	for( seg_no=0 ; seg_no < sketch_ip->skt_curve.seg_count ; seg_no++ )
	{
		long *lng;
		struct nurb_seg *nseg;
		struct bezier_seg *bseg;

		lng = (long *)sketch_ip->skt_curve.segments[seg_no];
		switch( *lng )
		{
			case CURVE_LSEG_MAGIC:
				ep->ext_nbytes += 3 * SIZEOF_NETWORK_LONG;
				break;
			case CURVE_CARC_MAGIC:
				ep->ext_nbytes += 5 * SIZEOF_NETWORK_LONG + SIZEOF_NETWORK_DOUBLE;
				break;
			case CURVE_NURB_MAGIC:
				nseg = (struct nurb_seg *)lng;
				ep->ext_nbytes += 3 * SIZEOF_NETWORK_LONG; /* order, pt_type, c_size */
				ep->ext_nbytes +=  SIZEOF_NETWORK_LONG + nseg->k.k_size * SIZEOF_NETWORK_DOUBLE;	/* knot vector */
				ep->ext_nbytes += nseg->c_size * SIZEOF_NETWORK_LONG; /* control point indices */
				if( RT_NURB_IS_PT_RATIONAL( nseg->pt_type ) )
					ep->ext_nbytes += nseg->c_size * SIZEOF_NETWORK_DOUBLE;	/* weights */
				break;
			case CURVE_BEZIER_MAGIC:
				bseg = (struct bezier_seg *)lng;
				ep->ext_nbytes += (bseg->degree + 3) * SIZEOF_NETWORK_LONG;
				break;
			default:
				bu_log( "rt_sketch_export: unsupported segement type (x%x)\n", *lng );
				bu_bomb( "rt_sketch_export: unsupported segement type\n" );
		}
	}
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "sketch external");

	cp = (unsigned char *)ep->ext_buf;

	/* scale and export */
	VSCALE( tmp_vec, sketch_ip->V, local2mm );
	htond( cp, (unsigned char *)tmp_vec, 3 );
	cp += 3 * SIZEOF_NETWORK_DOUBLE;

	/* uvec and uvec are unit vectors, do not convert to/from mm */
	htond( cp, (unsigned char *)sketch_ip->u_vec, 3 );
	cp += 3 * SIZEOF_NETWORK_DOUBLE;
	htond( cp, (unsigned char *)sketch_ip->v_vec, 3 );
	cp += 3 * SIZEOF_NETWORK_DOUBLE;

	(void)bu_plong( cp, sketch_ip->vert_count );
	cp += SIZEOF_NETWORK_LONG;
	(void)bu_plong( cp, sketch_ip->skt_curve.seg_count );
	cp += SIZEOF_NETWORK_LONG;

	/* convert 2D points to mm */
	for( i=0 ; i<sketch_ip->vert_count ; i++ )
	{
		point2d_t pt2d;

		V2SCALE( pt2d, sketch_ip->verts[i], local2mm )
		htond( cp, (const unsigned char *)pt2d, 2 );
		cp += 2 * SIZEOF_NETWORK_DOUBLE;
	}

	for( seg_no=0 ; seg_no < sketch_ip->skt_curve.seg_count ; seg_no++ )
	{
		struct line_seg *lseg;
		struct carc_seg *cseg;
		struct nurb_seg *nseg;
		struct bezier_seg *bseg;
		long *lng;
		fastf_t tmp_fastf;

		/* write segment type ID, and segement parameters */
		lng = (long *)sketch_ip->skt_curve.segments[seg_no];
		switch (*lng )
		{
			case CURVE_LSEG_MAGIC:
				lseg = (struct line_seg *)lng;
				(void)bu_plong( cp, CURVE_LSEG_MAGIC );
				cp += SIZEOF_NETWORK_LONG;
				(void)bu_plong( cp, lseg->start );
				cp += SIZEOF_NETWORK_LONG;
				(void)bu_plong( cp, lseg->end );
				cp += SIZEOF_NETWORK_LONG;
				break;
			case CURVE_CARC_MAGIC:
				cseg = (struct carc_seg *)lng;
				(void)bu_plong( cp, CURVE_CARC_MAGIC );
				cp += SIZEOF_NETWORK_LONG;
				(void)bu_plong( cp, cseg->start );
				cp += SIZEOF_NETWORK_LONG;
				(void)bu_plong( cp, cseg->end );
				cp += SIZEOF_NETWORK_LONG;
				(void) bu_plong( cp, cseg->orientation );
				cp += SIZEOF_NETWORK_LONG;
				(void) bu_plong( cp, cseg->center_is_left );
				cp += SIZEOF_NETWORK_LONG;
				tmp_fastf = cseg->radius * local2mm;
				htond( cp, (unsigned char *)&tmp_fastf, 1 );
				cp += SIZEOF_NETWORK_DOUBLE;
				break;
			case CURVE_NURB_MAGIC:
				nseg = (struct nurb_seg *)lng;
				(void)bu_plong( cp, CURVE_NURB_MAGIC );
				cp += SIZEOF_NETWORK_LONG;
				(void)bu_plong( cp, nseg->order );
				cp += SIZEOF_NETWORK_LONG;
				(void)bu_plong( cp, nseg->pt_type );
				cp += SIZEOF_NETWORK_LONG;
				(void)bu_plong( cp, nseg->k.k_size );
				cp += SIZEOF_NETWORK_LONG;
				htond( cp, (const unsigned char *)nseg->k.knots, nseg->k.k_size );
				cp += nseg->k.k_size * SIZEOF_NETWORK_DOUBLE;
				(void)bu_plong( cp, nseg->c_size );
				cp += SIZEOF_NETWORK_LONG;
				for( i=0 ; i<nseg->c_size ; i++ )
				{
					(void)bu_plong( cp, nseg->ctl_points[i] );
					cp += SIZEOF_NETWORK_LONG;
				}
				if( RT_NURB_IS_PT_RATIONAL( nseg->pt_type ) )
				{
					htond( cp, (const unsigned char *)nseg->weights, nseg->c_size );
					cp += SIZEOF_NETWORK_DOUBLE * nseg->c_size;
				}
				break;
			case CURVE_BEZIER_MAGIC:
				bseg = (struct bezier_seg *)lng;
				(void)bu_plong( cp, CURVE_BEZIER_MAGIC );
				cp += SIZEOF_NETWORK_LONG;
				(void)bu_plong( cp, bseg->degree );
				cp += SIZEOF_NETWORK_LONG;
				for( i=0 ; i<=bseg->degree ; i++ ) {
					(void)bu_plong( cp, bseg->ctl_points[i] );
					cp += SIZEOF_NETWORK_LONG;
				}
				break;
			default:
				bu_bomb( "rt_sketch_export: ERROR: unrecognized curve type!!!!\n" );
				break;
				
		}
	}

	for( seg_no=0 ; seg_no < sketch_ip->skt_curve.seg_count ; seg_no++ )
	{
		(void)bu_plong( cp, sketch_ip->skt_curve.reverse[seg_no] );
		cp += SIZEOF_NETWORK_LONG;
	}

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at end of sketch_export5():\n" );
		bu_mem_barriercheck();
	}

	return(0);
}



/*
 *			R T _ S K E T C H _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_sketch_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_sketch_internal	*sketch_ip =
		(struct rt_sketch_internal *)ip->idb_ptr;
	int i;
	int seg_no;
	char	buf[256];
	point_t V;
	vect_t u, v;

	RT_SKETCH_CK_MAGIC(sketch_ip);
	bu_vls_strcat( str, "2D sketch (SKETCH)\n");

	VSCALE( V, sketch_ip->V, mm2local );
	VSCALE( u, sketch_ip->u_vec, mm2local );
	VSCALE( v, sketch_ip->v_vec, mm2local );

	sprintf(buf, "\tV = (%g %g %g),  A = (%g %g %g), B = (%g %g %g)\n\t%d vertices\n",
		V3ARGS( V ),
		V3ARGS( u ),
		V3ARGS( v ),
		sketch_ip->vert_count );
	bu_vls_strcat( str, buf );

	if( !verbose )
		return( 0 );

	if( sketch_ip->vert_count )
	{
		bu_vls_strcat( str, "\tVertices:\n\t" );
		for( i=0 ; i<sketch_ip->vert_count ; i++ )
		{
			sprintf( buf, " %d-(%g %g)", i, V2ARGS( sketch_ip->verts[i] ) );
			bu_vls_strcat( str, buf );
			if( i && (i+1)%3 == 0 )
				bu_vls_strcat( str, "\n\t" );
		}
	}
	bu_vls_strcat( str, "\n" );

	sprintf(buf, "\n\tCurve:\n" );
	bu_vls_strcat( str, buf );
	for( seg_no=0 ; seg_no < sketch_ip->skt_curve.seg_count ; seg_no++ )
	{
		struct line_seg *lsg;
		struct carc_seg *csg;
		struct nurb_seg *nsg;
		struct bezier_seg *bsg;

		lsg = (struct line_seg *)sketch_ip->skt_curve.segments[seg_no];
		switch( lsg->magic )
		{
			case CURVE_LSEG_MAGIC:
				lsg = (struct line_seg *)sketch_ip->skt_curve.segments[seg_no];
				if( lsg->start >= sketch_ip->vert_count ||
				    lsg->end >= sketch_ip->vert_count )
				{
					if( sketch_ip->skt_curve.reverse[seg_no] )
						sprintf( buf, "\t\tLine segment from vertex #%d to #%d\n",
							lsg->end, lsg->start );
					else
						sprintf( buf, "\t\tLine segment from vertex #%d to #%d\n",
							lsg->start, lsg->end );
				}
				else	
				{
					if( sketch_ip->skt_curve.reverse[seg_no] )
						sprintf( buf, "\t\tLine segment (%g %g) <-> (%g %g)\n",
							V2ARGS( sketch_ip->verts[lsg->end] ),
							V2ARGS( sketch_ip->verts[lsg->start] ) );
					else
						sprintf( buf, "\t\tLine segment (%g %g) <-> (%g %g)\n",
							V2ARGS( sketch_ip->verts[lsg->start] ),
							V2ARGS( sketch_ip->verts[lsg->end] ) );
				}
				bu_vls_strcat( str, buf );
				break;
			case CURVE_CARC_MAGIC:
				csg = (struct carc_seg *)sketch_ip->skt_curve.segments[seg_no];
				if( csg->radius < 0.0 )
				{
					bu_vls_strcat( str, "\t\tFull Circle:\n" );

					if( csg->end >= sketch_ip->vert_count ||
					    csg->start >= sketch_ip->vert_count )
					{
						sprintf( buf, "\t\tcenter at vertex #%d\n",
							csg->end );
						bu_vls_strcat( str, buf );
						sprintf( buf, "\t\tpoint on circle at vertex #%d\n",
							csg->start );
					}
					else
					{
						sprintf( buf, "\t\t\tcenter: (%g %g)\n",
							V2ARGS( sketch_ip->verts[csg->end] ) );
						bu_vls_strcat( str, buf );
						sprintf( buf, "\t\t\tpoint on circle: (%g %g)\n",
							V2ARGS( sketch_ip->verts[csg->start] ) );
					}
					bu_vls_strcat( str, buf );
				}
				else
				{
					bu_vls_strcat( str, "\t\tCircular Arc:\n" );

					if( csg->end >= sketch_ip->vert_count ||
					    csg->start >= sketch_ip->vert_count )
					{
						sprintf( buf, "\t\t\tstart at vertex #%d\n",
							csg->start );
						bu_vls_strcat( str, buf );
						sprintf( buf, "\t\t\tend at vertex #%d\n",
							csg->end );
						bu_vls_strcat( str, buf );
					}
					else
					{
						sprintf( buf, "\t\t\tstart: (%g, %g)\n",
							V2ARGS( sketch_ip->verts[csg->start] ) );
						bu_vls_strcat( str, buf );
						sprintf( buf, "\t\t\tend: (%g, %g)\n",
							V2ARGS( sketch_ip->verts[csg->end] ) );
						bu_vls_strcat( str, buf );
					}
					sprintf( buf, "\t\t\tradius: %g\n", csg->radius*mm2local );
					bu_vls_strcat( str, buf );
					if( csg->orientation )
						bu_vls_strcat( str, "\t\t\tcurve is clock-wise\n" );
					else
						bu_vls_strcat( str, "\t\t\tcurve is counter-clock-wise\n" );
					if( csg->center_is_left )
						bu_vls_strcat( str, "\t\t\tcenter of curvature is left of the line from start point to end point\n" );
					else
						bu_vls_strcat( str, "\t\t\tcenter of curvature is right of the line from start point to end point\n" );
					if( sketch_ip->skt_curve.reverse[seg_no] )
						bu_vls_strcat( str, "\t\t\tarc is reversed\n" );
				}
				break;
			case CURVE_NURB_MAGIC:
				nsg = (struct nurb_seg *)sketch_ip->skt_curve.segments[seg_no];
				bu_vls_strcat( str, "\t\tNURB Curve:\n" );
				if( RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) )
				{
					sprintf( buf, "\t\t\tCurve is rational\n" );
					bu_vls_strcat( str, buf );
				}
				sprintf( buf, "\t\t\torder = %d, number of control points = %d\n",
					nsg->order, nsg->c_size );
				bu_vls_strcat( str, buf );
				if( nsg->ctl_points[0] >= sketch_ip->vert_count ||
				    nsg->ctl_points[nsg->c_size-1] >= sketch_ip->vert_count )
				{
					if( sketch_ip->skt_curve.reverse[seg_no] )
						sprintf( buf, "\t\t\tstarts at vertex #%d\n\t\t\tends at vertex #%d\n",
							nsg->ctl_points[nsg->c_size-1],
							nsg->ctl_points[0] );
					else
						sprintf( buf, "\t\t\tstarts at vertex #%d\n\t\t\tends at vertex #%d\n",
							nsg->ctl_points[0],
							nsg->ctl_points[nsg->c_size-1] );
				}
				else
				{
					if( sketch_ip->skt_curve.reverse[seg_no] )
						sprintf( buf, "\t\t\tstarts at (%g %g)\n\t\t\tends at (%g %g)\n",
							V2ARGS( sketch_ip->verts[nsg->ctl_points[nsg->c_size-1]] ),
							V2ARGS( sketch_ip->verts[nsg->ctl_points[0]] ) );
					else
						sprintf( buf, "\t\t\tstarts at (%g %g)\n\t\t\tends at (%g %g)\n",
							V2ARGS( sketch_ip->verts[nsg->ctl_points[0]] ),
							V2ARGS( sketch_ip->verts[nsg->ctl_points[nsg->c_size-1]] ) );
				}
				bu_vls_strcat( str, buf );
				sprintf( buf, "\t\t\tknot values are %g to %g\n",
					nsg->k.knots[0], nsg->k.knots[nsg->k.k_size-1] );
				bu_vls_strcat( str, buf );
				break;
			case CURVE_BEZIER_MAGIC:
				bsg = (struct bezier_seg *)sketch_ip->skt_curve.segments[seg_no];
				bu_vls_strcat( str, "\t\tBezier segment:\n" );
				sprintf( buf, "\t\t\tdegree = %d\n", bsg->degree );
				bu_vls_strcat( str, buf );
				if( bsg->ctl_points[0] >= sketch_ip->vert_count ||
				    bsg->ctl_points[bsg->degree] >= sketch_ip->vert_count ) {
					if( sketch_ip->skt_curve.reverse[seg_no] ){
						sprintf( buf, "\t\t\tstarts at vertex #%d\n\t\t\tends at vertex #%d\n",
							 bsg->ctl_points[bsg->degree],
							 bsg->ctl_points[0] );
					} else {
						sprintf( buf, "\t\t\tstarts at vertex #%d\n\t\t\tends at vertex #%d\n",
							 bsg->ctl_points[0],
							 bsg->ctl_points[bsg->degree] );
					}
				} else {
					if( sketch_ip->skt_curve.reverse[seg_no] )
						sprintf( buf, "\t\t\tstarts at (%g %g)\n\t\t\tends at (%g %g)\n",
							V2ARGS( sketch_ip->verts[bsg->ctl_points[bsg->degree]]),
							V2ARGS( sketch_ip->verts[bsg->ctl_points[0]] ) );
					else
						sprintf( buf, "\t\t\tstarts at (%g %g)\n\t\t\tends at (%g %g)\n",
							V2ARGS( sketch_ip->verts[bsg->ctl_points[0]] ),
							V2ARGS( sketch_ip->verts[bsg->ctl_points[bsg->degree]]));
				}
				bu_vls_strcat( str, buf );
				break;
			default:
				bu_bomb( "rt_sketch_describe: ERROR: unrecognized segment type\n" );
		}
	}

	return(0);
}

void
rt_curve_free(struct curve *crv)
{
	int i;

	if( crv->seg_count )
		bu_free( (char *)crv->reverse, "crv->reverse" );
	for( i=0 ; i<crv->seg_count ; i++ )
	{
		long *lng;
		struct nurb_seg *nsg;
		struct bezier_seg *bsg;

		lng = (long *)crv->segments[i];
		switch( *lng )
		{
			case CURVE_NURB_MAGIC:
				nsg = (struct nurb_seg *)lng;
				bu_free( (char *)nsg->ctl_points, "nsg->ctl_points" );
				if( nsg->weights )
					bu_free( ( char *)nsg->weights, "nsg->weights" );
				bu_free( ( char *)nsg->k.knots, "nsg->k.knots" );
				bu_free( (char *)lng, "curve segment" );
				break;
			case CURVE_BEZIER_MAGIC:
				bsg = (struct bezier_seg *)lng;
				bu_free( (char *)bsg->ctl_points, "bsg->ctl_points" );
				bu_free( (char *)lng, "curve segment" );
				break;
			case CURVE_LSEG_MAGIC:
			case CURVE_CARC_MAGIC:
				bu_free( (char *)lng, "curve segment" );
				break;
			default:
				bu_log( "ERROR: rt_curve_free: unrecognized curve segments type!!!!\n");
				break;
		}
	}

	if( crv->seg_count > 0 )
		bu_free( (char *)crv->segments, "crv->segments" );

	crv->seg_count = 0;
	crv->reverse = (int *)NULL;
	crv->segments = (genptr_t)NULL;
}

/*
 *			R T _ S K E T C H _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_sketch_ifree( struct rt_db_internal	*ip )
{
	register struct rt_sketch_internal	*sketch_ip;
	struct curve				*crv;

	RT_CK_DB_INTERNAL(ip);
	sketch_ip = (struct rt_sketch_internal *)ip->idb_ptr;
	RT_SKETCH_CK_MAGIC(sketch_ip);
	sketch_ip->magic = 0;			/* sanity */

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at start of sketch_ifree():\n" );
		bu_mem_barriercheck();
	}

	if( sketch_ip->verts )
		bu_free( (char *)sketch_ip->verts, "sketch_ip->verts" );

	crv = &sketch_ip->skt_curve;

	rt_curve_free( crv );

	bu_free( (char *)sketch_ip, "sketch ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at end of sketch_ifree():\n" );
		bu_mem_barriercheck();
	}

}

void
rt_copy_curve(struct curve *crv_out, const struct curve *crv_in)
{
	int i, j;

	crv_out->seg_count = crv_in->seg_count;
	crv_out->reverse = (int *)bu_calloc( crv_out->seg_count, sizeof( int ), "crv->reverse" );
	crv_out->segments = (genptr_t *)bu_calloc( crv_out->seg_count, sizeof( genptr_t ), "crv->segments" );
	for( j=0 ; j<crv_out->seg_count ; j++ )
	{
		long *lng;
		struct line_seg *lsg_out, *lsg_in;
		struct carc_seg *csg_out, *csg_in;
		struct nurb_seg *nsg_out, *nsg_in;
		struct bezier_seg *bsg_out, *bsg_in;

		crv_out->reverse[j] = crv_in->reverse[j];
		lng = (long *)crv_in->segments[j];
		switch( *lng )
		{
			case CURVE_LSEG_MAGIC:
				lsg_in = (struct line_seg *)lng;
				lsg_out = (struct line_seg *)bu_malloc( sizeof( struct line_seg ), "line_seg" );
				crv_out->segments[j] = (genptr_t)lsg_out;
				*lsg_out = *lsg_in;
				break;
			case CURVE_CARC_MAGIC:
				csg_in = (struct carc_seg *)lng;
				csg_out = (struct carc_seg *)bu_malloc( sizeof( struct carc_seg ), "carc_seg" );
				crv_out->segments[j] = (genptr_t)csg_out;
				*csg_out = *csg_in;
				break;
			case CURVE_NURB_MAGIC:
				nsg_in = (struct nurb_seg *)lng;
				nsg_out = (struct nurb_seg *)bu_malloc( sizeof( struct nurb_seg ), "nurb_seg" );
				crv_out->segments[j] = (genptr_t)nsg_out;
				*nsg_out = *nsg_in;
				nsg_out->ctl_points = (int *)bu_calloc( nsg_in->c_size, sizeof( int ), "nsg_out->ctl_points" );
				for( i=0 ; i<nsg_out->c_size ; i++ )
					nsg_out->ctl_points[i] = nsg_in->ctl_points[i];
				if( RT_NURB_IS_PT_RATIONAL( nsg_in->pt_type ) )
				{
					nsg_out->weights = (fastf_t *)bu_malloc( nsg_out->c_size * sizeof( fastf_t ), "nsg_out->weights" );
					for( i=0 ; i<nsg_out->c_size ; i++ )
						nsg_out->weights[i] = nsg_in->weights[i];
				}
				else
					nsg_out->weights = (fastf_t *)NULL;
				nsg_out->k.knots = bu_malloc( nsg_in->k.k_size * sizeof( fastf_t ), "nsg_out->k.knots" );
				for( i=0 ; i<nsg_in->k.k_size ; i++ )
					nsg_out->k.knots[i] = nsg_in->k.knots[i];
				break;
			case CURVE_BEZIER_MAGIC:
				bsg_in = (struct bezier_seg *)lng;
				bsg_out = (struct bezier_seg *)bu_malloc( sizeof( struct bezier_seg ), "bezier_seg" );
				crv_out->segments[j] = (genptr_t)bsg_out;
				*bsg_out = *bsg_in;
				bsg_out->ctl_points = (int *)bu_calloc( bsg_out->degree + 1,
									sizeof( int ), "bsg_out->ctl_points" );
				for( i=0 ; i<=bsg_out->degree ; i++ ) {
					bsg_out->ctl_points[i] = bsg_in->ctl_points[i];
				}
				break;
			default:
				bu_bomb( "rt_copy_sketch: ERROR: unrecognized segment type!!!!\n" );
		}
	}
	
}

struct rt_sketch_internal *
rt_copy_sketch(const struct rt_sketch_internal *sketch_ip)
{
	struct rt_sketch_internal *out;
	int i;
	struct curve *crv_out;

	RT_SKETCH_CK_MAGIC( sketch_ip );

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at start of rt_copy_sketch():\n" );
		bu_mem_barriercheck();
	}

	out = (struct rt_sketch_internal *) bu_malloc( sizeof( struct rt_sketch_internal ), "rt_sketch_internal" );
	*out = *sketch_ip;	/* struct copy */

	out->verts = (point2d_t *)bu_calloc( out->vert_count, sizeof( point2d_t ), "out->verts" );
	for( i=0 ; i<out->vert_count ; i++ )
		V2MOVE( out->verts[i], sketch_ip->verts[i] );

	crv_out = &out->skt_curve;
	rt_copy_curve( crv_out, &sketch_ip->skt_curve );

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at end of rt_copy_sketch():\n" );
		bu_mem_barriercheck();
	}

	return( out );
}

int
curve_to_tcl_list(struct bu_vls *vls, struct curve *crv)
{
	int i,j;

	bu_vls_printf( vls, " SL {" );
	for( j=0 ; j<crv->seg_count ; j++ )
	{
		switch( (*(long *)crv->segments[j]) )
		{
		    case CURVE_LSEG_MAGIC:
			{
				struct line_seg *lsg = (struct line_seg *)crv->segments[j];
				bu_vls_printf( vls, " { line S %d E %d }", lsg->start, lsg->end );
			}
			break;
		    case CURVE_CARC_MAGIC:
			{
				struct carc_seg *csg = (struct carc_seg *)crv->segments[j];
				bu_vls_printf( vls, " { carc S %d E %d R %.25g L %d O %d }",
					csg->start, csg->end, csg->radius,
					csg->center_is_left, csg->orientation );
			}
			break;
		    case CURVE_BEZIER_MAGIC:
			{
				struct bezier_seg *bsg = (struct bezier_seg *)crv->segments[j];
				bu_vls_printf( vls, " { bezier D %d P {", bsg->degree );
				for( i=0 ; i<=bsg->degree ; i++ )
					bu_vls_printf( vls, " %d", bsg->ctl_points[i] );
				bu_vls_printf( vls, " } }" );
			}
			break;
		    case CURVE_NURB_MAGIC:
			{
				int k;
				struct nurb_seg *nsg = (struct nurb_seg *)crv->segments[j];
				bu_vls_printf( vls, " { nurb O %d T %d K {",
					nsg->order, nsg->pt_type );
				for( k=0 ; k<nsg->k.k_size ; k++ )
					bu_vls_printf( vls, " %.25g", nsg->k.knots[k] );
				bu_vls_strcat( vls, "} P {" );
				for( k=0 ; k<nsg->c_size ; k++ )
					bu_vls_printf( vls, " %d", nsg->ctl_points[k] );
				if( nsg->weights )
				{
					bu_vls_strcat( vls, "} W {" );
					for( k=0 ; k<nsg->c_size ; k++ )
						bu_vls_printf( vls, " %.25g", nsg->weights[k] );
					}
				bu_vls_strcat( vls, "} }" );
			}
			break;
		}
	}
	bu_vls_strcat( vls, " }" );	/* end of segment list */

	return( 0 );
}

int rt_sketch_tclform( const struct rt_functab *ftp, Tcl_Interp *interp)
{
	RT_CK_FUNCTAB(ftp);

	Tcl_AppendResult( interp,
			  "V {%f %f %f} A {%f %f %f} B {%f %f %f} VL { {%f %f} {%f %f} ...} SL { { segment_data } { segment_data} }" );

	return TCL_OK;
}

int
rt_sketch_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
	register struct rt_sketch_internal *skt=(struct rt_sketch_internal *)intern->idb_ptr;
	Tcl_DString     ds;
	struct bu_vls   vls;
	int i;
	struct curve	*crv;

	RT_SKETCH_CK_MAGIC( skt );

	Tcl_DStringInit( &ds );
	bu_vls_init( &vls );

	if( attr == (char *)NULL )
	{
		bu_vls_strcpy( &vls, "sketch" );
		bu_vls_printf( &vls, " V {%.25g %.25g %.25g}", V3ARGS( skt->V ) );
		bu_vls_printf( &vls, " A {%.25g %.25g %.25g}", V3ARGS( skt->u_vec ) );
		bu_vls_printf( &vls, " B {%.25g %.25g %.25g}", V3ARGS( skt->v_vec ) );
		bu_vls_strcat( &vls, " VL {" );
		for( i=0 ; i<skt->vert_count ; i++ )
			bu_vls_printf( &vls, " {%.25g %.25g}", V2ARGS( skt->verts[i] ) );
		bu_vls_strcat( &vls, " }" );

		crv = &skt->skt_curve;
		if( curve_to_tcl_list( &vls, crv ) )
		{
			bu_vls_free( &vls );
			return( TCL_ERROR );
		}
	}
	else if( !strcmp( attr, "V" ) )
		bu_vls_printf( &vls, "%.25g %.25g %.25g", V3ARGS( skt->V ) );
	else if( !strcmp( attr, "A" ) )
		bu_vls_printf( &vls, "%.25g %.25g %.25g", V3ARGS( skt->u_vec ) );
	else if( !strcmp( attr, "B" ) )
		bu_vls_printf( &vls, "%.25g %.25g %.25g", V3ARGS( skt->v_vec ) );
	else if( !strcmp( attr, "VL" ) )
	{
		for( i=0 ; i<skt->vert_count ; i++ )
			bu_vls_printf( &vls, " {%.25g %.25g}", V2ARGS( skt->verts[i] ) );
	}
	else if( !strcmp( attr, "SL" ) )
	{
		crv = &skt->skt_curve;
		if( curve_to_tcl_list( &vls, crv ) )
		{
			bu_vls_free( &vls );
			return( TCL_ERROR );
		}
	}
	else if( *attr == 'V' )
	{
		i = atoi( (attr+1) );
		if( i < 0 || i >= skt->vert_count )
		{
			Tcl_SetResult( interp, "ERROR: Illegal vertex number\n", TCL_STATIC );
			bu_vls_free( &vls );
			return( TCL_ERROR );
		}

		bu_vls_printf( &vls, "%.25g %.25g", V2ARGS( skt->verts[i] ) );
	}
	else	/* unrecognized attribute */
	{
		Tcl_SetResult( interp, "ERROR: Unknown attribute, choices are V, A, B, VL, SL, or V#\n", TCL_STATIC );
		bu_vls_free( &vls );
		return( TCL_ERROR );
	}

	Tcl_DStringAppend( &ds, bu_vls_addr( &vls ), -1 );
	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );
	bu_vls_free( &vls );
	return( TCL_OK );
}

int
get_tcl_curve(Tcl_Interp *interp, struct curve *crv, Tcl_Obj *seg_list)
{
	int seg_count;
	int ret, j;

	/* get number of segments */
	seg_count = 0;
	if( (ret=Tcl_ListObjLength( interp, seg_list, &seg_count ) ))
	{
		return( ret );
	}

	if( seg_count )
	{
		crv->seg_count = seg_count;
		crv->reverse = (int *)bu_calloc( seg_count, sizeof( int ), "crv->reverse" );
		crv->segments = (genptr_t *)bu_calloc( seg_count, sizeof( genptr_t ), "crv->segments" );
	}

	/* loop through all the segments */
	for( j=0 ; j<seg_count ; j++ )
	{
		Tcl_Obj *seg, *seg_type, *seg_elem, *seg_val;
		char *type, *elem;
		int k, seg_len;


		/* get the next segment */
		if( (ret=Tcl_ListObjIndex( interp, seg_list, j, &seg ) ))
		{
			return( ret );
		}

		if( (ret=Tcl_ListObjLength( interp, seg, &seg_len )) )
			return( ret );

		/* get the segment type */
		if( (ret=Tcl_ListObjIndex( interp, seg, 0, &seg_type ) ))
			return( ret );
		type = Tcl_GetString( seg_type );

		if( !strcmp( type, "line" ) )
		{
			struct line_seg *lsg;

			lsg = (struct line_seg *)bu_calloc( 1, sizeof( struct line_seg ), "lsg" );
			for( k=1 ; k<seg_len ; k += 2 )
			{
				if( (ret=Tcl_ListObjIndex( interp, seg, k, &seg_elem ) ))
					return( ret );

				if( (ret=Tcl_ListObjIndex( interp, seg, k+1, &seg_val ) ))
					return( ret );

				elem = Tcl_GetString( seg_elem );
				switch( *elem )
				{
					case 'S':
						Tcl_GetIntFromObj( interp, seg_val, &lsg->start );
						break;
					case 'E':
						Tcl_GetIntFromObj( interp, seg_val, &lsg->end );
						break;
				}
			}
			lsg->magic = CURVE_LSEG_MAGIC;
			crv->segments[j] = (genptr_t)lsg;
		}
		else if( !strcmp( type, "bezier" ) )
		{
			struct bezier_seg *bsg;
			int num_points;

			bsg = (struct bezier_seg *)bu_calloc( 1, sizeof( struct bezier_seg ), "bsg" );
			for( k=1 ; k<seg_len ; k+= 2 ) {

				if( (ret=Tcl_ListObjIndex( interp, seg, k, &seg_elem ) ))
					return( ret );

				if( (ret=Tcl_ListObjIndex( interp, seg, k+1, &seg_val ) ))
					return( ret );

				elem = Tcl_GetString( seg_elem );
				switch( *elem )
				{
					case 'D': /* degree */
						Tcl_GetIntFromObj( interp, seg_val,
								   &bsg->degree );
						break;
					case 'P': /* list of control points */
						num_points = 0;
						(void)tcl_obj_to_int_array( interp,
						              seg_val, &bsg->ctl_points,
							      &num_points );

						if( num_points != bsg->degree + 1 ) {
							Tcl_SetResult( interp, "ERROR: degree and number of control points disagree for a Bezier segment\n", TCL_STATIC );
							return( TCL_ERROR );
						}
				}
			}
			bsg->magic = CURVE_BEZIER_MAGIC;
			crv->segments[j] = (genptr_t)bsg;
		}
		else if( !strcmp( type, "carc" ) )
		{
			struct carc_seg *csg;
			double tmp;

			csg = (struct carc_seg *)bu_calloc( 1, sizeof( struct carc_seg ), "csg" );
			for( k=1 ; k<seg_len ; k += 2 )
			{
				if( (ret=Tcl_ListObjIndex( interp, seg, k, &seg_elem ) ))
					return( ret );

				if( (ret=Tcl_ListObjIndex( interp, seg, k+1, &seg_val ) ))
					return( ret );

				elem = Tcl_GetString( seg_elem );
				switch( *elem )
				{
					case 'S':
						Tcl_GetIntFromObj( interp, seg_val, &csg->start );
						break;
					case 'E':
						Tcl_GetIntFromObj( interp, seg_val, &csg->end );
						break;
					case 'R':
						Tcl_GetDoubleFromObj( interp, seg_val, &tmp );
						csg->radius = tmp;
						break;
					case 'L' :
						Tcl_GetBooleanFromObj( interp, seg_val, &csg->center_is_left );
						break;
					case 'O':
						Tcl_GetBooleanFromObj( interp, seg_val, &csg->orientation );
						break;
				}
			}
			csg->magic = CURVE_CARC_MAGIC;
			crv->segments[j] = (genptr_t)csg;
		}
		else if( !strcmp( type, "nurb" ) )
		{
			struct nurb_seg *nsg;

			nsg = (struct nurb_seg *)bu_calloc( 1, sizeof( struct nurb_seg ), "nsg" );
			for( k=1 ; k<seg_len ; k += 2 )
			{
				if( (ret=Tcl_ListObjIndex( interp, seg, k, &seg_elem ) ))
					return( ret );

				if( (ret=Tcl_ListObjIndex( interp, seg, k+1, &seg_val ) ))
					return( ret );

				elem = Tcl_GetString( seg_elem );
				switch( *elem )
				{
					case 'O':
						Tcl_GetIntFromObj( interp, seg_val, &nsg->order );
						break;
					case 'T':
						Tcl_GetIntFromObj( interp, seg_val, &nsg->pt_type );
						break;
					case 'K':
						tcl_obj_to_fastf_array( interp, seg_val, &nsg->k.knots, &nsg->k.k_size );
						break;
					case 'P' :
						tcl_obj_to_int_array( interp, seg_val, &nsg->ctl_points, &nsg->c_size );
						break;
					case 'W':
						tcl_obj_to_fastf_array( interp, seg_val, &nsg->weights, &nsg->c_size );
						break;
				}
			}
			nsg->magic = CURVE_NURB_MAGIC;
			crv->segments[j] = (genptr_t)nsg;
		}
		else
		{
			Tcl_ResetResult( interp );
			Tcl_AppendResult( interp, "ERROR: Unrecognized segment type: ",
				Tcl_GetString( seg ), (char *)NULL);
			return( TCL_ERROR );
		}
	}

	return( TCL_OK );
}

int
rt_sketch_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
{
	struct rt_sketch_internal *skt;
	int ret, array_len;
	fastf_t *new;

	RT_CK_DB_INTERNAL( intern );
	skt = (struct rt_sketch_internal *)intern->idb_ptr;
	RT_SKETCH_CK_MAGIC( skt );

	while( argc >= 2 )
	{
		if( !strcmp( argv[0], "V" ) )
		{
			new = skt->V;
			array_len = 3;
			if( tcl_list_to_fastf_array( interp, argv[1], &new, &array_len) != 
			    array_len ) {
				Tcl_SetResult( interp,
				      "ERROR: Incorrect number of coordinates for vertex\n",
				      TCL_STATIC );
				return( TCL_ERROR );
		         }
		}
		else if( !strcmp( argv[0], "A" ) )
		{
			new = skt->u_vec;
			array_len = 3;
			if( tcl_list_to_fastf_array( interp, argv[1], &new, &array_len) != 
			    array_len ) {
				Tcl_SetResult( interp,
				      "ERROR: Incorrect number of coordinates for vertex\n",
				      TCL_STATIC );
				return( TCL_ERROR );
		         }
		}
		else if( !strcmp( argv[0], "B" ) )
		{
			new = skt->v_vec;
			array_len = 3;
			if( tcl_list_to_fastf_array( interp, argv[1], &new, &array_len) != 
			    array_len ) {
				Tcl_SetResult( interp,
				      "ERROR: Incorrect number of coordinates for vertex\n",
				      TCL_STATIC );
				return( TCL_ERROR );
		         }
		}
		else if( !strcmp( argv[0], "VL" ) )
		{
			fastf_t *new_verts=(fastf_t *)NULL;
			int len;
			char *ptr;

			/* the vertex list is a list of lists (each element is a list of two coordinates)
			 * so eliminate all the '{' and '}' chars in the list
			 */
			ptr = argv[1];
			while( *ptr != '\0' )
			{
				if( *ptr == '{' || *ptr == '}' )
					*ptr = ' ';
				ptr++;
			}

			len = 0;
                        (void)tcl_list_to_fastf_array( interp, argv[1], &new_verts, &len );
                        if( len%2 ) {
				Tcl_SetResult( interp,
				    "ERROR: Incorrect number of coordinates for vertices\n",
				    TCL_STATIC );
				return( TCL_ERROR );
                        }

			if( skt->verts )
				bu_free( (char *)skt->verts, "verts" );
			skt->verts = (point2d_t *)new_verts;
			skt->vert_count = len / 2;
		}
		else if( !strcmp( argv[0], "SL" ) )	/* the entire segment list */
		{
			Tcl_Obj *tmp;
			struct curve *crv;

			/* create a Tcl object */
			tmp = Tcl_NewStringObj( argv[1], -1 );

			crv = &skt->skt_curve;
			crv->seg_count = 0;
			crv->reverse = (int *)NULL;
			crv->segments = (genptr_t)NULL;

			if( (ret=get_tcl_curve( interp, crv, tmp )) != TCL_OK )
				return( ret );
		}
		else if( *argv[0] == 'V' && isdigit( *(argv[0]+1) )  )
		{
			/* changing a specific vertex */
			int vert_no;
			fastf_t *new_vert;

			vert_no = atoi( argv[0] + 1 );
			new_vert = skt->verts[vert_no];
			if( vert_no < 0 || vert_no > skt->vert_count )
			{
				Tcl_SetResult( interp, "ERROR: Illegal vertex number\n",
					       TCL_STATIC );
				return( TCL_ERROR );
			}
			array_len = 2;
                        if(tcl_list_to_fastf_array( interp, argv[1], &new_vert, &array_len)
				!= array_len ) 
			{
				Tcl_SetResult( interp,
				    "ERROR: Incorrect number of coordinates for vertex\n",
				    TCL_STATIC );
				return( TCL_ERROR );
			}
		}

		argc -= 2;
		argv += 2;
	}

	return( TCL_OK );
}


void
rt_curve_reverse_segment( long *lng )
{
	struct line_seg *lsg;
	struct carc_seg *csg;
	struct bezier_seg *bsg;
	int tmp, i;

	switch( *lng ) {
		case CURVE_LSEG_MAGIC:
			lsg = (struct line_seg *)lng;
			tmp = lsg->start;
			lsg->start = lsg->end;
			lsg->end = tmp;
			break;
		case CURVE_CARC_MAGIC:
			csg = (struct carc_seg *)lng;
			if( csg->radius < 0.0 ) {
				/* this is a full circle */
				csg->orientation = !csg->orientation; /* no real effect, but just for completeness */
			} else {
				tmp = csg->start;
				csg->start = csg->end;
				csg->end = tmp;
				csg->center_is_left = !csg->center_is_left;
				csg->orientation = !csg->orientation;
			}
			break;
		case CURVE_BEZIER_MAGIC:
			bsg = (struct bezier_seg *)lng;
			for( i=0 ; i<bsg->degree/2 ; i++ ) {
				tmp = bsg->ctl_points[i];
				bsg->ctl_points[i] = bsg->ctl_points[bsg->degree-i];
				bsg->ctl_points[bsg->degree-i] = tmp;
			}
			break;
	}
}


void
rt_curve_order_segments( struct curve *crv )
{
	int i, j, k;
	int seg_count;
	int start1, end1, start2, end2, start3, end3;

	seg_count = crv->seg_count;
	if( seg_count < 2 ) {
		return;
	}

	for( j=1 ; j<seg_count ; j++ ) {
		i = j - 1;

		get_indices( crv->segments[i], &start1, &end1 );
		get_indices( crv->segments[j], &start2, &end2 );

		if( end1 != start2 ) {
			int fixed=0;

			for( k=j+1 ; k<seg_count ; k++ ) {
				get_indices( crv->segments[k], &start3, &end3 );
				if( start3 == end1 ) {
					int tmp_reverse;
					genptr_t tmp_seg;

					/* exchange j and k segments */
					tmp_seg = crv->segments[j];
					crv->segments[j] = crv->segments[k];
					crv->segments[k] = tmp_seg;

					tmp_reverse = crv->reverse[j];
					crv->reverse[j] = crv->reverse[k];
					crv->reverse[k] = tmp_reverse;
					fixed = 1;
					break;
				}
			}
			if( !fixed ) {
				/* try reversing a segment */
				for( k=j ; k<seg_count ; k++ ) {
					get_indices( crv->segments[k], &start3, &end3 );
					if( end3 == end1 ) {
						int tmp_reverse;	
						genptr_t tmp_seg;

						rt_curve_reverse_segment( crv->segments[k] );

						if( k != j ) {
							/* exchange j and k segments */
							tmp_seg = crv->segments[j];
							crv->segments[j] = crv->segments[k];
							crv->segments[k] = tmp_seg;

							tmp_reverse = crv->reverse[j];
							crv->reverse[j] = crv->reverse[k];
							crv->reverse[k] = tmp_reverse;
						}
						fixed = 1;
						break;
					}
				}
			}
		}
	}
}

@


1.48
log
@change conf.h to a wrapped config.h
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /cvs/brlcad/librt/g_sketch.c,v 1.47 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


1.47
log
@merge of ansi-6-0-branch into HEAD
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header$ (BRL)";
d44 5
a48 1
#include "conf.h"
@


1.46
log
@update copyright to include span through 2003
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.45 2002/08/20 17:08:01 jra Exp $ (BRL)";
d66 1
a66 1
fastf_t rt_cnurb_par_edge();
d70 1
a70 4
rt_check_curve( crv, skt, noisey )
struct curve *crv;
struct rt_sketch_internal *skt;
int noisey;
d147 1
a147 4
rt_sketch_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d157 1
a157 2
rt_sketch_print( stp )
register const struct soltab *stp;
d173 1
a173 5
rt_sketch_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d186 6
a191 6
rt_sketch_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d202 1
a202 4
rt_sketch_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d214 1
a214 4
rt_sketch_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d231 1
a231 5
rt_sketch_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d239 1
a239 2
rt_sketch_free( stp )
register struct soltab *stp;
d247 1
a247 1
rt_sketch_class()
d253 1
a253 7
seg_to_vlist( vhead, ttol, V, u_vec, v_vec, sketch_ip, seg )
struct bu_list          *vhead;
const struct rt_tess_tol *ttol;
point_t			V;
vect_t			u_vec, v_vec;
struct rt_sketch_internal *sketch_ip;
genptr_t seg;
d676 1
a676 7
curve_to_vlist( vhead, ttol, V, u_vec, v_vec, sketch_ip, crv )
struct bu_list          *vhead;
const struct rt_tess_tol *ttol;
point_t			V;
vect_t			u_vec, v_vec;
struct rt_sketch_internal *sketch_ip;
struct curve                    *crv;
d705 1
a705 5
rt_sketch_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d733 1
a733 6
rt_sketch_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d745 1
a745 5
rt_sketch_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d906 1
a906 5
rt_sketch_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1098 1
a1098 5
rt_sketch_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1256 1
a1256 5
rt_sketch_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1451 1
a1451 5
rt_sketch_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1666 1
a1666 2
rt_curve_free( crv )
struct curve *crv;
d1753 1
a1753 3
rt_copy_curve( crv_out, crv_in )
struct curve *crv_out;
const struct curve *crv_in;
d1823 1
a1823 2
rt_copy_sketch( sketch_ip )
const struct rt_sketch_internal *sketch_ip;
d1857 1
a1857 3
curve_to_tcl_list( vls, crv )
struct bu_vls *vls;
struct curve *crv;
d1927 1
a1927 4
rt_sketch_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d2005 1
a2005 4
get_tcl_curve( interp, crv, seg_list )
Tcl_Interp *interp;
struct curve *crv;
Tcl_Obj *seg_list;
d2196 1
a2196 5
rt_sketch_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
@


1.45
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d37 1
a37 1
 *	This software is Copyright (C) 1990 by the United States Army.
d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.43 2002/07/16 15:13:31 jra Exp $ (BRL)";
@


1.45.4.1
log
@sync to HEAD...
@
text
@d37 1
a37 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_sketch.c,v 1.46 2004/02/02 17:39:21 morrison Exp $ (BRL)";
@


1.45.10.1
log
@merge from HEAD
@
text
@d37 1
a37 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.46 2004/02/02 17:39:21 morrison Exp $ (BRL)";
@


1.45.10.2
log
@merge from head
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.45.10.1 2004/02/12 18:37:42 erikg Exp $ (BRL)";
@


1.45.2.1
log
@Initial ANSIfication
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.45 2002/08/20 17:08:01 jra Exp $ (BRL)";
d66 1
a66 1
fastf_t rt_cnurb_par_edge(const struct edge_g_cnurb *crv, fastf_t epsilon);
d70 4
a73 1
rt_check_curve(struct curve *crv, struct rt_sketch_internal *skt, int noisey)
d150 4
a153 1
rt_sketch_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d163 2
a164 1
rt_sketch_print(register const struct soltab *stp)
d180 5
a184 1
rt_sketch_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d197 6
a202 6
rt_sketch_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d213 4
a216 1
rt_sketch_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d228 4
a231 1
rt_sketch_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d248 5
a252 1
rt_sketch_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d260 2
a261 1
rt_sketch_free(register struct soltab *stp)
d269 1
a269 1
rt_sketch_class(void)
d275 7
a281 1
seg_to_vlist(struct bu_list *vhead, const struct rt_tess_tol *ttol, fastf_t *V, fastf_t *u_vec, fastf_t *v_vec, struct rt_sketch_internal *sketch_ip, genptr_t seg)
d704 7
a710 1
curve_to_vlist(struct bu_list *vhead, const struct rt_tess_tol *ttol, fastf_t *V, fastf_t *u_vec, fastf_t *v_vec, struct rt_sketch_internal *sketch_ip, struct curve *crv)
d739 5
a743 1
rt_sketch_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d771 6
a776 1
rt_sketch_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d788 5
a792 1
rt_sketch_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d953 5
a957 1
rt_sketch_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1149 5
a1153 1
rt_sketch_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1311 5
a1315 1
rt_sketch_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1510 5
a1514 1
rt_sketch_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1729 2
a1730 1
rt_curve_free(struct curve *crv)
d1817 3
a1819 1
rt_copy_curve(struct curve *crv_out, const struct curve *crv_in)
d1889 2
a1890 1
rt_copy_sketch(const struct rt_sketch_internal *sketch_ip)
d1924 3
a1926 1
curve_to_tcl_list(struct bu_vls *vls, struct curve *crv)
d1996 4
a1999 1
rt_sketch_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d2077 4
a2080 1
get_tcl_curve(Tcl_Interp *interp, struct curve *crv, Tcl_Obj *seg_list)
d2271 5
a2275 1
rt_sketch_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


1.45.2.2
log
@sync branch with HEAD
@
text
@d37 1
a37 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header$ (BRL)";
@


1.44
log
@Converted from K&R to ANSI C - RFH
@
text
@d66 1
a66 1
fastf_t rt_cnurb_par_edge(const struct edge_g_cnurb *crv, fastf_t epsilon);
d70 4
a73 1
rt_check_curve(struct curve *crv, struct rt_sketch_internal *skt, int noisey)
d150 4
a153 1
rt_sketch_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d163 2
a164 1
rt_sketch_print(register const struct soltab *stp)
d180 5
a184 1
rt_sketch_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d197 6
a202 6
rt_sketch_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d213 4
a216 1
rt_sketch_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d228 4
a231 1
rt_sketch_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d248 5
a252 1
rt_sketch_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d260 2
a261 1
rt_sketch_free(register struct soltab *stp)
d269 1
a269 1
rt_sketch_class(void)
d275 7
a281 1
seg_to_vlist(struct bu_list *vhead, const struct rt_tess_tol *ttol, fastf_t *V, fastf_t *u_vec, fastf_t *v_vec, struct rt_sketch_internal *sketch_ip, genptr_t seg)
d704 7
a710 1
curve_to_vlist(struct bu_list *vhead, const struct rt_tess_tol *ttol, fastf_t *V, fastf_t *u_vec, fastf_t *v_vec, struct rt_sketch_internal *sketch_ip, struct curve *crv)
d739 5
a743 1
rt_sketch_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d771 6
a776 1
rt_sketch_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d788 5
a792 1
rt_sketch_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d953 5
a957 1
rt_sketch_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1149 5
a1153 1
rt_sketch_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1311 5
a1315 1
rt_sketch_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1510 5
a1514 1
rt_sketch_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1729 2
a1730 1
rt_curve_free(struct curve *crv)
d1817 3
a1819 1
rt_copy_curve(struct curve *crv_out, const struct curve *crv_in)
d1889 2
a1890 1
rt_copy_sketch(const struct rt_sketch_internal *sketch_ip)
d1924 3
a1926 1
curve_to_tcl_list(struct bu_vls *vls, struct curve *crv)
d1996 4
a1999 1
rt_sketch_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d2077 4
a2080 1
get_tcl_curve(Tcl_Interp *interp, struct curve *crv, Tcl_Obj *seg_list)
d2271 5
a2275 1
rt_sketch_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


1.43
log
@Added declaration for get_indices() from g_extrude.c
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.42 2002/07/16 02:16:30 jra Exp $ (BRL)";
d66 1
a66 1
fastf_t rt_cnurb_par_edge();
d70 1
a70 4
rt_check_curve( crv, skt, noisey )
struct curve *crv;
struct rt_sketch_internal *skt;
int noisey;
d147 1
a147 4
rt_sketch_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d157 1
a157 2
rt_sketch_print( stp )
register const struct soltab *stp;
d173 1
a173 5
rt_sketch_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d186 6
a191 6
rt_sketch_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d202 1
a202 4
rt_sketch_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d214 1
a214 4
rt_sketch_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d231 1
a231 5
rt_sketch_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d239 1
a239 2
rt_sketch_free( stp )
register struct soltab *stp;
d247 1
a247 1
rt_sketch_class()
d253 1
a253 7
seg_to_vlist( vhead, ttol, V, u_vec, v_vec, sketch_ip, seg )
struct bu_list          *vhead;
const struct rt_tess_tol *ttol;
point_t			V;
vect_t			u_vec, v_vec;
struct rt_sketch_internal *sketch_ip;
genptr_t seg;
d676 1
a676 7
curve_to_vlist( vhead, ttol, V, u_vec, v_vec, sketch_ip, crv )
struct bu_list          *vhead;
const struct rt_tess_tol *ttol;
point_t			V;
vect_t			u_vec, v_vec;
struct rt_sketch_internal *sketch_ip;
struct curve                    *crv;
d705 1
a705 5
rt_sketch_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d733 1
a733 6
rt_sketch_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d745 1
a745 5
rt_sketch_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d906 1
a906 5
rt_sketch_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1098 1
a1098 5
rt_sketch_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1256 1
a1256 5
rt_sketch_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1451 1
a1451 5
rt_sketch_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1666 1
a1666 2
rt_curve_free( crv )
struct curve *crv;
d1753 1
a1753 3
rt_copy_curve( crv_out, crv_in )
struct curve *crv_out;
const struct curve *crv_in;
d1823 1
a1823 2
rt_copy_sketch( sketch_ip )
const struct rt_sketch_internal *sketch_ip;
d1857 1
a1857 3
curve_to_tcl_list( vls, crv )
struct bu_vls *vls;
struct curve *crv;
d1927 1
a1927 4
rt_sketch_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d2005 1
a2005 4
get_tcl_curve( interp, crv, seg_list )
Tcl_Interp *interp;
struct curve *crv;
Tcl_Obj *seg_list;
d2196 1
a2196 5
rt_sketch_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
@


1.42
log
@Added rt_curve_order_segments() and rt_curve_reverse_segment()
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.41 2001/10/02 19:24:30 jra Exp $ (BRL)";
d67 1
@


1.41
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.40 2001/09/27 00:31:28 jra Exp $ (BRL)";
d290 1
a290 1
	point_t center, start_pt, end_pt;
a453 1
			VJOIN2( end_pt, V, end2d[0], u_vec, end2d[1], v_vec );
d2399 109
@


1.40
log
@Eliminated a duplicate draw in seg_to_vlist()
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.39 2001/09/26 20:46:41 jra Exp $ (BRL)";
d817 1
d1171 1
@


1.39
log
@broke out seg_to_vlist as a separate function
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.38 2001/07/28 04:53:31 jra Exp $ (BRL)";
a466 1
			RT_ADD_VLIST( vhead, end_pt, BN_VLIST_LINE_DRAW );
@


1.38
log
@Eliminated some redundant calls to Tcl_DecrRefCount()
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.37 2001/06/21 18:07:25 jra Exp $ (BRL)";
a272 3
/*
 *			C U R V E _ T O _ V L I S T
 */
d274 1
a274 1
curve_to_vlist( vhead, ttol, V, u_vec, v_vec, sketch_ip, crv )
d280 1
a280 1
struct curve                    *crv;
d282 3
a284 2
	long *lng;
	int seg_no, i;
a294 1
	int ret=0;
d296 2
a297 1
	if( bu_debug&BU_DEBUG_MEM_CHECK )
d299 14
a312 8
		bu_log( "Barrier check at start of curve_to_vlist():\n" );
		bu_mem_barriercheck();
	}

	for( seg_no=0 ; seg_no < crv->seg_count ; seg_no++ )
	{
		lng = (long *)crv->segments[seg_no];
		switch( *lng )
d314 11
a324 12
			case CURVE_LSEG_MAGIC:
				lsg = (struct line_seg *)lng;
				if( lsg->start >= sketch_ip->vert_count ||
				    lsg->end >= sketch_ip->vert_count )
				{
					ret++;
					break;
				}
				VJOIN2( pt, V, sketch_ip->verts[lsg->start][0], u_vec, sketch_ip->verts[lsg->start][1], v_vec);
				RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE )
				VJOIN2( pt, V, sketch_ip->verts[lsg->end][0], u_vec, sketch_ip->verts[lsg->end][1], v_vec);
				RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
d326 15
a340 1
			case CURVE_CARC_MAGIC:
d342 5
a346 5
				point2d_t mid_pt, start2d, end2d, center2d, s2m, dir;
				fastf_t s2m_len_sq, len_sq, tmp_len, cross_z;
				fastf_t start_ang, end_ang, tot_ang, cosdel, sindel;
				fastf_t oldu, oldv, newu, newv;
				int nsegs;
d348 3
a350 31
				csg = (struct carc_seg *)lng;
				if( csg->start >= sketch_ip->vert_count ||
				    csg->end >= sketch_ip->vert_count )
				{
					ret++;
					break;
				}

				delta = M_PI/4.0;
				if( csg->radius <= 0.0 )
				{
					VJOIN2( center, V, sketch_ip->verts[csg->end][0], u_vec, sketch_ip->verts[csg->end][1], v_vec);
					VJOIN2( pt, V, sketch_ip->verts[csg->start][0], u_vec, sketch_ip->verts[csg->start][1], v_vec);
					VSUB2( semi_a, pt, center );
					VCROSS( norm, u_vec, v_vec );
					VCROSS( semi_b, norm, semi_a );
					VUNITIZE( semi_b );
					radius = MAGNITUDE( semi_a );
					VSCALE( semi_b, semi_b, radius );
				}
				else if( csg->radius < SMALL_FASTF )
				{
					bu_log( "Radius too small in sketch!!\n" );
					break;
				}
				else
					radius = csg->radius;

				if( ttol->abs > 0.0 )
				{
					fastf_t tmp_delta, ratio;
d352 2
a353 9
					ratio = ttol->abs / radius;
					if( ratio < 1.0 )
					{
						tmp_delta = 2.0 * acos( 1.0 - ratio);
						if( tmp_delta < delta )
							delta = tmp_delta;
					}
				}
				if( ttol->rel > 0.0 && ttol->rel < 1.0 )
d355 1
a355 3
					fastf_t tmp_delta;

					tmp_delta = 2.0 * acos( 1.0 - ttol->rel );
d359 4
a362 3
				if( ttol->norm > 0.0 )
				{
					fastf_t norm;
d364 7
a370 27
					norm = ttol->norm * M_PI / 180.0;
					if( norm < delta )
						delta = norm;
				}
				if( csg->radius <= 0.0 )
				{
					/* this is a full circle */
					nsegs = ceil( 2.0 * M_PI / delta );
					delta = 2.0 * M_PI / (double)nsegs;
					cosdel = cos( delta );
					sindel = sin( delta );
					oldu = 1.0;
					oldv = 0.0;
					VJOIN2( start_pt, center, oldu, semi_a, oldv, semi_b );
					RT_ADD_VLIST( vhead, start_pt, BN_VLIST_LINE_MOVE );
					for( i=1 ; i<nsegs ; i++ )
					{
						newu = oldu * cosdel - oldv * sindel;
						newv = oldu * sindel + oldv * cosdel;
						VJOIN2( pt, center, newu, semi_a, newv, semi_b );
						RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
						oldu = newu;
						oldv = newv;
					}
					RT_ADD_VLIST( vhead, start_pt, BN_VLIST_LINE_DRAW );
					break;
				}
d372 9
a380 52
				/* this is an arc (not a full circle) */
				V2MOVE( start2d, sketch_ip->verts[csg->start] );
				V2MOVE( end2d, sketch_ip->verts[csg->end] );
				mid_pt[0] = (start2d[0] + end2d[0]) * 0.5;
				mid_pt[1] = (start2d[1] + end2d[1]) * 0.5;
				V2SUB2( s2m, mid_pt, start2d )
				dir[0] = -s2m[1];
				dir[1] = s2m[0];
				s2m_len_sq =  s2m[0]*s2m[0] + s2m[1]*s2m[1];
				if( s2m_len_sq < SMALL_FASTF )
				{
					bu_log( "start and end points are too close together in circular arc (segment #%d)\n\
						of sketch\n", seg_no );
					break;
				}
				len_sq = radius*radius - s2m_len_sq;
				if( len_sq < 0.0 )
				{
					bu_log( "Impossible radius for specified start and end points in circular arc\n\
						(segment #%d) of sketch\n", seg_no);
					break;
				}
				tmp_len = sqrt( dir[0]*dir[0] + dir[1]*dir[1] );
				dir[0] = dir[0] / tmp_len;
				dir[1] = dir[1] / tmp_len;
				tmp_len = sqrt( len_sq );
				V2JOIN1( center2d, mid_pt, tmp_len, dir )

				/* check center location */
				cross_z = ( end2d[X] - start2d[X] )*( center2d[Y] - start2d[Y] ) -
					( end2d[Y] - start2d[Y] )*( center2d[X] - start2d[X] );
				if( !(cross_z > 0.0 && csg->center_is_left) )
					V2JOIN1( center2d, mid_pt, -tmp_len, dir );
				start_ang = atan2( start2d[Y]-center2d[Y], start2d[X]-center2d[X] );
				end_ang = atan2( end2d[Y]-center2d[Y], end2d[X]-center2d[X] );
				if( csg->orientation ) /* clock-wise */
				{
					while( end_ang > start_ang )
						end_ang -= 2.0 * M_PI;
				}
				else /* counter-clock-wise */
				{
					while( end_ang < start_ang )
						end_ang += 2.0 * M_PI;
				}
				tot_ang = end_ang - start_ang;
				nsegs = ceil( tot_ang / delta );
				if( nsegs < 0 )
					nsegs = -nsegs;
				if( nsegs < 3 )
					nsegs = 3;
				delta = tot_ang / nsegs;
d383 3
a385 5
				VJOIN2( center, V, center2d[0], u_vec, center2d[1], v_vec );
				VJOIN2( start_pt, V, start2d[0], u_vec, start2d[1], v_vec );
				VJOIN2( end_pt, V, end2d[0], u_vec, end2d[1], v_vec );
				oldu = (start2d[0] - center2d[0]);
				oldv = (start2d[1] - center2d[1]);
d387 1
a387 1
				for( i=0 ; i<nsegs ; i++ )
d391 1
a391 1
					VJOIN2( pt, center, newu, u_vec, newv, v_vec );
d396 1
a396 1
				RT_ADD_VLIST( vhead, end_pt, BN_VLIST_LINE_DRAW );
d399 60
a458 1
			case CURVE_NURB_MAGIC:
d460 17
a476 5
				struct edge_g_cnurb eg;
				int coords;
				fastf_t inv_weight;
				int num_intervals;
				fastf_t param_delta, epsilon;
d478 14
a491 2
				nsg = (struct nurb_seg *)lng;
				for( i=0 ; i<nsg->c_size ; i++ )
d493 2
a494 5
					if( nsg->ctl_points[i] >= sketch_ip->vert_count )
					{
						ret++;
						break;
					}
d496 2
a497 1
				if( nsg->order < 3 )
d499 1
a499 2
					/* just straight lines */
					VJOIN2( start_pt, V, sketch_ip->verts[nsg->ctl_points[0]][0], u_vec, sketch_ip->verts[nsg->ctl_points[0]][1], v_vec );
d502 2
a503 2
						inv_weight = 1.0/nsg->weights[0];
						VSCALE( start_pt, start_pt, inv_weight );
d505 1
a505 12
					RT_ADD_VLIST( vhead, start_pt, BN_VLIST_LINE_MOVE );
					for( i=1 ; i<nsg->c_size ; i++ )
					{
						VJOIN2( pt, V, sketch_ip->verts[nsg->ctl_points[i]][0], u_vec, sketch_ip->verts[nsg->ctl_points[i]][1], v_vec );
						if( RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) )
						{
							inv_weight = 1.0/nsg->weights[i];
							VSCALE( pt, pt, inv_weight );
						}
						RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
					}
					break;
d507 13
a519 9
				eg.l.magic = NMG_EDGE_G_CNURB_MAGIC;
				eg.order = nsg->order;
				eg.k.k_size = nsg->k.k_size;
				eg.k.knots = nsg->k.knots;
				eg.c_size = nsg->c_size;
				coords = 3 + RT_NURB_IS_PT_RATIONAL( nsg->pt_type );
				eg.pt_type = RT_NURB_MAKE_PT_TYPE( coords, 2, RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) );
				eg.ctl_points = (fastf_t *)bu_malloc( nsg->c_size * coords * sizeof( fastf_t ), "eg.ctl_points" );
				if( RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) )
d521 2
a522 5
					for( i=0 ; i<nsg->c_size ; i++ )
					{
						VJOIN2( &eg.ctl_points[i*coords], V, sketch_ip->verts[nsg->ctl_points[i]][0], u_vec, sketch_ip->verts[nsg->ctl_points[i]][1], v_vec );
						eg.ctl_points[(i+1)*coords - 1] = nsg->weights[i];
					}
d524 21
a544 1
				else
d546 9
a554 2
					for( i=0 ; i<nsg->c_size ; i++ )
						VJOIN2( &eg.ctl_points[i*coords], V, sketch_ip->verts[nsg->ctl_points[i]][0], u_vec, sketch_ip->verts[nsg->ctl_points[i]][1], v_vec );
a555 13
				epsilon = MAX_FASTF;
				if( ttol->abs > 0.0 && ttol->abs < epsilon )
					epsilon = ttol->abs;
				if( ttol->rel > 0.0 )
				{
					point2d_t min_pt, max_pt, tmp_pt;
					point2d_t diff;
					fastf_t tmp_epsilon;

					min_pt[0] = MAX_FASTF;
					min_pt[1] = MAX_FASTF;
					max_pt[0] = -MAX_FASTF;
					max_pt[1] = -MAX_FASTF;
d557 20
a576 12
					for( i=0 ; i<nsg->c_size ; i++ )
					{
						V2MOVE( tmp_pt, sketch_ip->verts[nsg->ctl_points[i]] );
						if( tmp_pt[0] > max_pt[0] )
							max_pt[0] = tmp_pt[0];
						if( tmp_pt[1] > max_pt[1] )
							max_pt[1] = tmp_pt[1];
						if( tmp_pt[0] < min_pt[0] )
							min_pt[0] = tmp_pt[0];
						if( tmp_pt[1] < min_pt[1] )
							min_pt[1] = tmp_pt[1];
					}
d578 3
a580 11
					V2SUB2( diff, max_pt, min_pt )
					tmp_epsilon = ttol->rel * sqrt( MAG2SQ( diff ) );
					if( tmp_epsilon < epsilon )
						epsilon = tmp_epsilon;
					
				}
				param_delta = rt_cnurb_par_edge( &eg, epsilon );
				num_intervals = ceil( (nsg->k.knots[nsg->k.k_size-1] - nsg->k.knots[0])/param_delta );
				if( num_intervals < 3 )
					num_intervals = 3;
				if( num_intervals > 500 )
d582 2
a583 2
					bu_log( "num_intervals was %d\n", num_intervals );
					num_intervals = 500;
d585 4
a588 20
				param_delta = (nsg->k.knots[nsg->k.k_size-1] - nsg->k.knots[0])/(double)num_intervals;
				for( i=0 ; i<=num_intervals ; i++ )
				{
					fastf_t t;
					int j;

					t = nsg->k.knots[0] + i*param_delta;
					rt_nurb_c_eval( &eg, t, pt );
					if( RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) )
					{
						for( j=0 ; j<coords-1 ; j++ )
							pt[j] /= pt[coords-1];
					}
					if( i == 0 )
						RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE )
					else
						RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
				}
				bu_free( (char *)eg.ctl_points, "eg.ctl_points" );
				break;
d590 6
a595 5
			case CURVE_BEZIER_MAGIC: {
				struct bezier_2d_list *bezier_hd, *bz;
				fastf_t epsilon;

				bsg = (struct bezier_seg *)lng;
d597 1
a597 6
				for( i=0 ; i<=bsg->degree ; i++ ) {
					if( bsg->ctl_points[i] >= sketch_ip->vert_count ) {
						ret++;
						break;
					}
				}
d599 2
a600 3
				if( bsg->degree < 1 ) {
					bu_log( "g_sketch: ERROR: Bezier curve with illegal degree (%d)\n",
						bsg->degree );
d604 1
d606 16
a621 11
				if( bsg->degree == 1 ) {
					/* straight line */
					VJOIN2( start_pt, V, sketch_ip->verts[bsg->ctl_points[0]][0],
						u_vec, sketch_ip->verts[bsg->ctl_points[0]][1], v_vec );
					RT_ADD_VLIST( vhead, start_pt, BN_VLIST_LINE_MOVE );
					for( i=1 ; i<=bsg->degree ; i++ ) {
						VJOIN2( pt, V, sketch_ip->verts[bsg->ctl_points[i]][0],
							u_vec, sketch_ip->verts[bsg->ctl_points[i]][1], v_vec );
						RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
					}
					break;
d623 2
d626 35
a660 14
				/* use tolerance to determine coarseness of plot */
				epsilon = MAX_FASTF;
				if( ttol->abs > 0.0 && ttol->abs < epsilon )
					epsilon = ttol->abs;
				if( ttol->rel > 0.0 )
				{
					point2d_t min_pt, max_pt, tmp_pt;
					point2d_t diff;
					fastf_t tmp_epsilon;

					min_pt[0] = MAX_FASTF;
					min_pt[1] = MAX_FASTF;
					max_pt[0] = -MAX_FASTF;
					max_pt[1] = -MAX_FASTF;
d662 9
a670 12
					for( i=0 ; i<=bsg->degree ; i++ )
					{
						V2MOVE( tmp_pt, sketch_ip->verts[bsg->ctl_points[i]] );
						if( tmp_pt[0] > max_pt[0] )
							max_pt[0] = tmp_pt[0];
						if( tmp_pt[1] > max_pt[1] )
							max_pt[1] = tmp_pt[1];
						if( tmp_pt[0] < min_pt[0] )
							min_pt[0] = tmp_pt[0];
						if( tmp_pt[1] < min_pt[1] )
							min_pt[1] = tmp_pt[1];
					}
d672 2
a673 7
					V2SUB2( diff, max_pt, min_pt )
					tmp_epsilon = ttol->rel * sqrt( MAG2SQ( diff ) );
					if( tmp_epsilon < epsilon )
						epsilon = tmp_epsilon;
					
				}
				
d675 11
a685 27
				/* Create an initial bezier_2d_list */
				bezier_hd = (struct bezier_2d_list *)bu_malloc( sizeof( struct bezier_2d_list ),
									     "g_sketch.c: bezier_hd" );
				BU_LIST_INIT( &bezier_hd->l );
				bezier_hd->ctl = (point2d_t *)bu_calloc( bsg->degree + 1, sizeof( point2d_t ),
									 "g_sketch.c: bezier_hd->ctl" );
				for( i=0 ; i<=bsg->degree ; i++ ) {
					V2MOVE( bezier_hd->ctl[i], sketch_ip->verts[bsg->ctl_points[i]] );
				}

				/* now do subdivision as necessary */
				bezier_hd = subdivide_bezier( bezier_hd, bsg->degree, epsilon, 0 );

				/* plot the results */
				bz = BU_LIST_FIRST( bezier_2d_list, &bezier_hd->l );
				VJOIN2( pt, V, bz->ctl[0][0], u_vec, bz->ctl[0][1], v_vec);
				RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE );

				while( BU_LIST_WHILE( bz, bezier_2d_list, &(bezier_hd->l) ) ) {
					BU_LIST_DEQUEUE( &bz->l );
					for( i=1 ; i<=bsg->degree ; i++ ) {
						VJOIN2( pt, V, bz->ctl[i][0], u_vec,
							bz->ctl[i][1], v_vec);
						RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
					}
					bu_free( (char *)bz->ctl, "g_sketch.c: bz->ctl" );
					bu_free( (char *)bz, "g_sketch.c: bz" );
d687 2
a688 2
				bu_free( (char *)bezier_hd, "g_sketch.c: bezier_hd" );
				break;
d690 2
a691 3
			default:
				bu_log( "curve_to_vlist: ERROR: unrecognized segment type!!!!\n" );
				break;
d693 32
@


1.37
log
@Continueing to add tcladjust and tclget support
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.36 2001/05/30 21:09:46 jra Exp $ (BRL)";
a2351 2
			{
				Tcl_DecrRefCount( tmp );
a2352 2
			}
			Tcl_DecrRefCount( tmp );
@


1.36
log
@Added Bezier capability to Tcl adjust
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.35 2001/04/25 13:43:29 jra Exp $ (BRL)";
d2150 2
a2151 1
						Tcl_GetIntFromObj( interp, seg_val, &bsg->degree );
d2155 3
a2157 2
						if( (ret=tcl_obj_to_int_array( interp, seg_val, &bsg->ctl_points, &num_points ) ) != TCL_OK )
							return( ret );
d2275 7
a2281 2
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new, &array_len )) != TCL_OK )
				return( ret );
d2287 7
a2293 2
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new, &array_len )) != TCL_OK )
				return( ret );
d2299 7
a2305 2
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new, &array_len )) != TCL_OK )
				return( ret );
d2325 7
a2331 2
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new_verts, &len )) != TCL_OK )
				return( ret );
d2358 1
a2358 1
		else if( *argv[0] == 'V' && isdigit( *(argv[0]+1) )  )	/* changing a specific vertex */
d2360 1
d2368 2
a2369 1
				Tcl_SetResult( interp, "ERROR: Illegal vertex number\n", TCL_STATIC );
d2373 8
a2380 2
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new_vert, &array_len )) != TCL_OK )
				return( ret );
@


1.35
log
@Added the start of support for bezier curves in a sketch
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.34 2001/04/20 22:29:47 morrison Exp $ (BRL)";
d1678 2
a1679 2
				bu_vls_strcat( str, "\t\tBezier Curve:\n" );
				sprintf( buf, "\t\tdegree = %d\n", bsg->degree );
a1711 53
/*
 *			R T _ S K E T C H _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_sketch_ifree( struct rt_db_internal	*ip )
{
	register struct rt_sketch_internal	*sketch_ip;
	struct curve				*crv;
	long					*lng;
	int					seg_no;

	RT_CK_DB_INTERNAL(ip);
	sketch_ip = (struct rt_sketch_internal *)ip->idb_ptr;
	RT_SKETCH_CK_MAGIC(sketch_ip);
	sketch_ip->magic = 0;			/* sanity */

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at start of sketch_ifree():\n" );
		bu_mem_barriercheck();
	}

	if( sketch_ip->verts )
		bu_free( (char *)sketch_ip->verts, "sketch_ip->verts" );

	crv = &sketch_ip->skt_curve;

	for( seg_no=0 ; seg_no < crv->seg_count ; seg_no++ )
	{
		lng = (long *)crv->segments[seg_no];
		if( *lng > 0 )
		{
			*lng = 0;
			bu_free( (char *)lng, "lng" );
		}
	}

	bu_free( (char *)crv->reverse, "crv->reverse" );
	bu_free( (char *)crv->segments, "crv->segments" );

	bu_free( (char *)sketch_ip, "sketch ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at end of sketch_ifree():\n" );
		bu_mem_barriercheck();
	}

}

d1751 4
d1760 40
d1912 1
a1912 1
	int j;
d1933 9
d2090 1
a2097 2
		{
			Tcl_DecrRefCount( seg );
a2098 1
		}
a2101 2
		{
			Tcl_DecrRefCount( seg );
a2102 1
		}
a2112 3
				{
					Tcl_DecrRefCount( seg_type );
					Tcl_DecrRefCount( seg );
d2114 1
a2114 1
				}
a2115 4
				{
					Tcl_DecrRefCount( seg_elem );
					Tcl_DecrRefCount( seg_type );
					Tcl_DecrRefCount( seg );
d2117 1
a2117 1
				}
d2131 34
a2164 3
			Tcl_DecrRefCount( seg_val );
			Tcl_DecrRefCount( seg_elem );
			Tcl_DecrRefCount( seg_type );
a2174 3
				{
					Tcl_DecrRefCount( seg_type );
					Tcl_DecrRefCount( seg );
d2176 1
a2176 1
				}
a2177 4
				{
					Tcl_DecrRefCount( seg_elem );
					Tcl_DecrRefCount( seg_type );
					Tcl_DecrRefCount( seg );
d2179 1
a2179 1
				}
a2202 3
			Tcl_DecrRefCount( seg_val );
			Tcl_DecrRefCount( seg_elem );
			Tcl_DecrRefCount( seg_type );
a2211 3
				{
					Tcl_DecrRefCount( seg_type );
					Tcl_DecrRefCount( seg );
d2213 1
a2213 1
				}
a2214 4
				{
					Tcl_DecrRefCount( seg_elem );
					Tcl_DecrRefCount( seg_type );
					Tcl_DecrRefCount( seg );
d2216 1
a2216 1
				}
a2238 3
			Tcl_DecrRefCount( seg_val );
			Tcl_DecrRefCount( seg_elem );
			Tcl_DecrRefCount( seg_type );
a2241 2
			Tcl_DecrRefCount( seg_type );
			Tcl_DecrRefCount( seg );
d2334 1
@


1.34
log
@CONST to const
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.33 2001/04/13 15:03:54 jra Exp $ (BRL)";
d82 1
d112 9
d290 1
d606 100
d835 1
d896 12
d970 1
d987 4
d1036 1
d1094 11
d1192 1
d1253 12
d1330 1
d1349 4
d1393 1
d1451 11
d1545 1
d1676 28
d1777 1
d1788 7
d1825 1
d1862 11
@


1.33
log
@Added tclform for sketch
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.32 2000/11/16 21:38:10 jra Exp $ (BRL)";
d153 1
a153 1
register CONST struct soltab *stp;
d269 1
a269 1
CONST struct rt_tess_tol *ttol;
d617 2
a618 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d650 2
a651 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d665 3
a667 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d816 1
a816 1
CONST struct rt_db_internal	*ip;
d818 1
a818 1
CONST struct db_i		*dbip;
d898 1
a898 1
		htond( ptr, (CONST unsigned char *)pt2d, 2 );
d949 1
a949 1
				htond( ptr, (CONST unsigned char *)nseg->k.knots, nseg->k.k_size );
d960 1
a960 1
					htond( ptr, (CONST unsigned char *)nseg->weights, nseg->c_size );
d995 3
a997 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1143 1
a1143 1
CONST struct rt_db_internal	*ip;
d1145 1
a1145 1
CONST struct db_i		*dbip;
d1225 1
a1225 1
		htond( cp, (CONST unsigned char *)pt2d, 2 );
d1276 1
a1276 1
				htond( cp, (CONST unsigned char *)nseg->k.knots, nseg->k.k_size );
d1287 1
a1287 1
					htond( cp, (CONST unsigned char *)nseg->weights, nseg->c_size );
d1325 1
a1325 1
CONST struct rt_db_internal	*ip;
d1604 1
a1604 1
CONST struct curve *crv_in;
d1663 1
a1663 1
CONST struct rt_sketch_internal *sketch_ip;
d1762 2
a1763 2
CONST struct rt_db_internal	*intern;
CONST char			*attr;
@


1.32
log
@Corrected calculation of number of segments to draw for an arc
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.31 2000/10/18 18:10:35 butler Exp $ (BRL)";
d1747 10
@


1.31
log
@Patches for compiling under RedHat 7.0
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.30 2000/08/21 02:02:31 butler Exp $ (BRL)";
d447 2
@


1.30
log
@Massive compilation warnings eliminated
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.29 2000/07/21 19:33:31 jra Exp $ (BRL)";
d47 3
@


1.29
log
@Eliminated some unused variables
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.28 2000/07/21 19:30:17 jra Exp $ (BRL)";
d48 1
d1513 1
a1513 2
rt_sketch_ifree( ip )
struct rt_db_internal	*ip;
@


1.28
log
@Fixed a memory corruption bug in rt_sketch_export5()
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.27 2000/07/10 23:01:35 mike Exp $ (BRL)";
a666 1
	int				curve_no;
a667 1
	genptr_t			*segs;
d816 1
a816 1
	int	i, curve_no, seg_no, nbytes=0, ngran;
a818 1
	struct curve *crv;
a995 1
	int				curve_no;
a996 1
	genptr_t			*segs;
a1661 1
	struct bu_ptbl curves;
d1831 1
a1831 2
	Tcl_Obj *SL, *segments;
	int len2, seg_count;
d2119 1
a2119 1
next_arg:
@


1.27
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d41 1
a41 1
static const char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.26 2000/06/30 15:38:03 mike Exp $ (BRL)";
d1009 1
a1009 1
		bu_log( "Barrier check at start of sketch_import():\n" );
d1127 1
a1127 1
		bu_log( "Barrier check at end of sketch_import():\n" );
d1154 1
a1154 1
		bu_log( "Barrier check at start of sketch_export():\n" );
d1180 1
a1180 1
				ep->ext_nbytes += 2 * SIZEOF_NETWORK_LONG;
d1276 1
a1276 1
				cp += nseg->k.k_size * 8;
d1302 1
d1305 1
a1305 1
		bu_log( "Barrier check at end of sketch_export():\n" );
@


1.26
log
@
export methods should not init the external structure, just check them.
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.25 2000/06/30 15:31:15 mike Exp $ (BRL)";
@


1.25
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.24 2000/06/29 17:54:47 jra Exp $ (BRL)";
d834 1
a834 1
	BU_INIT_EXTERNAL(ep);
d1163 1
a1163 1
	BU_INIT_EXTERNAL(ep);
@


1.24
log
@Added database v5 support
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.23 2000/04/12 02:34:36 mike Exp $ (BRL)";
d687 1
a687 1
	RT_INIT_DB_INTERNAL( ip );
d1013 1
a1013 1
	RT_INIT_DB_INTERNAL( ip );
@


1.23
log
@
NT port, non-compat4
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.22 2000/04/12 01:17:43 mike Exp $ (BRL)";
d981 331
@


1.23.2.1
log
@Fixed calculation of number of segments to draw for a curve
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.23 2000/04/12 02:34:36 mike Exp $ (BRL)";
a442 2
				if( nsegs < 0 )
					nsegs = -nsegs;
@


1.22
log
@
Moved TCL support from g_sketch.c to tcl.c
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.21 2000/03/17 20:10:35 jra Exp $ (BRL)";
d221 1
a221 1
 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


1.21
log
@Adjusted rt_sketch_tcladjust() for fact that sketches can only contain one curve
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.20 2000/03/16 13:39:27 jra Exp $ (BRL)";
a1496 112
}

int
tcl_obj_to_int_array( interp, list, array, array_len )
Tcl_Interp *interp;
Tcl_Obj *list;
int **array;
int *array_len;
{
	Tcl_Obj **obj_array;
	int len, i;
	int ret;

	if( (ret=Tcl_ListObjGetElements( interp, list, &len, &obj_array )) != TCL_OK )
		return( ret );

	if( len < 1 )
		return( TCL_OK );

	if( *array_len < 1 )
	{
		*array = (int *)bu_calloc( len, sizeof( int ), "array" );
		*array_len = len;
	}

	for( i=0 ; i<len && i<*array_len ; i++ )
		(*array)[i] = atoi( Tcl_GetStringFromObj( obj_array[i], NULL ) );

	return( TCL_OK );
}

int
tcl_list_to_int_array( interp, char_list, array, array_len )
Tcl_Interp *interp;
char *char_list;
int **array;
int *array_len;
{
	Tcl_Obj *obj, *list;
	int ret;

	obj = Tcl_NewStringObj( char_list, -1 );
	list = Tcl_NewListObj( 0, NULL );
	if( (ret=Tcl_ListObjAppendList( interp, list, obj )) != TCL_OK )
	{
		Tcl_DecrRefCount( list );
		Tcl_DecrRefCount( obj );
		return( ret );
	}

	ret = tcl_obj_to_int_array( interp, list, array, array_len );

	Tcl_DecrRefCount( list );
	Tcl_DecrRefCount( obj );

	return( ret );
}

int
tcl_obj_to_fastf_array( interp, list, array, array_len )
Tcl_Interp *interp;
Tcl_Obj *list;
fastf_t **array;
int *array_len;
{
	Tcl_Obj **obj_array;
	int len, i;
	int ret;

	if( (ret=Tcl_ListObjGetElements( interp, list, &len, &obj_array )) != TCL_OK )
		return( ret );

	if( len < 1 )
		return( TCL_OK );

	if( *array_len < 1 )
	{
		*array = (fastf_t *)bu_calloc( len, sizeof( fastf_t ), "array" );
		*array_len = len;
	}

	for( i=0 ; i<len && i<*array_len ; i++ )
		(*array)[i] = atof( Tcl_GetStringFromObj( obj_array[i], NULL ) );

	return( TCL_OK );
}

int
tcl_list_to_fastf_array( interp, char_list, array, array_len )
Tcl_Interp *interp;
char *char_list;
fastf_t **array;
int *array_len;
{
	Tcl_Obj *obj, *list;
	int ret;

	obj = Tcl_NewStringObj( char_list, -1 );
	list = Tcl_NewListObj( 0, NULL );
	if( (ret=Tcl_ListObjAppendList( interp, list, obj )) != TCL_OK )
	{
		Tcl_DecrRefCount( list );
		Tcl_DecrRefCount( obj );
		return( ret );
	}

	ret = tcl_obj_to_fastf_array( interp, list, array, array_len );

	Tcl_DecrRefCount( list );
	Tcl_DecrRefCount( obj );

	return( ret );
@


1.20
log
@Sketch solid can only have one curve now
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.19 2000/03/16 01:12:09 mike Exp $ (BRL)";
d1612 1
a1612 1
get_tcl_curve( interp, crv, crv_obj )
d1615 1
a1615 1
Tcl_Obj *crv_obj;
d1617 1
a1617 1
	Tcl_Obj *seg_list, *SL, *segments;
a1620 43
	/* get the segment list */
	if( (ret=Tcl_ListObjIndex( interp, crv_obj, 1, &seg_list ) ))
	{
		return( ret );
	}

	/* get length of segment list */
	if( (ret=Tcl_ListObjLength( interp, seg_list, &len2 ) ))
	{
		Tcl_DecrRefCount( seg_list );
		return( ret );
	}

	if( len2 != 2 )
	{
		Tcl_ResetResult( interp );
		Tcl_AppendResult( interp, "ERROR: Segment list must have two elements ('SL' and segment list)!!\n", "Erroneous segment list: ",
			Tcl_GetString( seg_list ), (char *)NULL);
		Tcl_DecrRefCount( seg_list );
		return( TCL_ERROR );
	}
	if( (ret=Tcl_ListObjIndex( interp, seg_list, 0, &SL ) ))
	{
		Tcl_DecrRefCount( seg_list );
		return( ret );
	}
	if( strcmp( "SL", Tcl_GetString( SL )) )
	{
		Tcl_DecrRefCount( seg_list );
		Tcl_DecrRefCount( SL );
		Tcl_ResetResult( interp );
		Tcl_AppendResult( interp, "ERROR: Segment list does not start with 'SL'!!\n", "Erroneous segment list: ",
			Tcl_GetString( seg_list ), (char *)NULL);
		return( TCL_ERROR );
	}
	Tcl_DecrRefCount( SL );

	/* now get actual list of segments */
	if( (ret=Tcl_ListObjIndex( interp, seg_list, 1, &segments ) ))
	{
		Tcl_DecrRefCount( seg_list );
		return( ret );
	}
d1623 1
a1623 1
	if( (ret=Tcl_ListObjLength( interp, segments, &seg_count ) ))
a1624 2
		Tcl_DecrRefCount( seg_list );
		Tcl_DecrRefCount( segments );
d1643 1
a1643 1
		if( (ret=Tcl_ListObjIndex( interp, segments, j, &seg ) ))
a1644 2
			Tcl_DecrRefCount( seg_list );
			Tcl_DecrRefCount( segments );
d1650 1
a1650 2
			Tcl_DecrRefCount( seg_list );
			Tcl_DecrRefCount( segments );
a1656 2
			Tcl_DecrRefCount( seg_list );
			Tcl_DecrRefCount( segments );
d1671 1
a1671 2
					Tcl_DecrRefCount( seg_list );
					Tcl_DecrRefCount( segments );
d1677 2
a1678 2
					Tcl_DecrRefCount( seg_list );
					Tcl_DecrRefCount( segments );
d1695 3
d1709 1
a1709 2
					Tcl_DecrRefCount( seg_list );
					Tcl_DecrRefCount( segments );
d1715 2
a1716 2
					Tcl_DecrRefCount( seg_list );
					Tcl_DecrRefCount( segments );
d1743 3
d1756 1
a1756 2
					Tcl_DecrRefCount( seg_list );
					Tcl_DecrRefCount( segments );
d1762 2
a1763 2
					Tcl_DecrRefCount( seg_list );
					Tcl_DecrRefCount( segments );
d1789 3
d1795 1
a1795 2
			Tcl_DecrRefCount( seg_list );
			Tcl_DecrRefCount( segments );
d1873 2
a1874 2
			Tcl_Obj *list, *tmp, *tmp_list;
			int len, len2, i;
a1877 1
			tmp_list = Tcl_NewListObj( 1, &tmp );
d1879 6
a1884 2
			/* get the actual list of curves */
			if( (ret=Tcl_ListObjIndex( interp, tmp_list, 0, &list )) != TCL_OK )
a1886 8
				Tcl_DecrRefCount( tmp_list );
				return( ret );
			}

			/* get the number of curves in the list */
			if( (ret=Tcl_ListObjLength( interp, list, &len )) != TCL_OK )
			{
				Tcl_DecrRefCount( list );
a1887 37
			}
			if( len < 1 )
				goto next_arg;

			/* loop through each curve */
			for( i=0 ; i<len ; i++ )
			{
				Tcl_Obj *crv_obj;
				struct curve *crv;

				/* get the curve */
				if( (ret=Tcl_ListObjIndex( interp, list, i, &crv_obj ) ))
				{
					Tcl_DecrRefCount( list );
					return( ret );
				}

				/* get length of this curve */
				if( (ret=Tcl_ListObjLength( interp, crv_obj, &len2 ) ))
				{
					Tcl_DecrRefCount( list );
					Tcl_DecrRefCount( crv_obj );
					return( ret );
				}

				crv = &skt->skt_curve;
				crv->seg_count = 0;
				crv->reverse = (int *)NULL;
				crv->segments = (genptr_t)NULL;

				if( (ret=get_tcl_curve( interp, crv, crv_obj )) != TCL_OK )
				{
					Tcl_DecrRefCount( list );
					Tcl_DecrRefCount( crv_obj );
					return( ret );
				}

@


1.19
log
@
Added M_PI if missing
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.18 2000/03/03 21:29:08 jra Exp $ (BRL)";
d80 1
a80 1
		lng = (long *)&crv->segments[i];
d110 1
a110 1
					bu_log( "Unrecognized segment type in curve (%s)\n", crv->crv_name );
d115 1
a115 1
		bu_log( "curve (%s) references non-existent vertices in sketch!!!\n", crv->crv_name );
d338 1
a338 1
					bu_log( "Radius too small in curve (%s)!!\n", crv->crv_name );
d408 1
a408 1
						of curve %s\n", seg_no, crv->crv_name );
d415 1
a415 1
						(segment #%d) of curve %s\n", seg_no, crv->crv_name );
a614 1
	int				curve_no;
d622 1
a622 1
	for( curve_no=0 ; curve_no < sketch_ip->curve_count ; curve_no++ )
d624 3
a626 6
		if( (ret=curve_to_vlist( vhead, ttol, sketch_ip->V, sketch_ip->u_vec, sketch_ip->v_vec, sketch_ip, &sketch_ip->curves[curve_no] )) )
		{
			myret--;
			bu_log( "WARNING: Errors in curve %s (%d segments reference non-existent vertices)\n",
				sketch_ip->curves[curve_no].crv_name, ret );
		}
a665 1
	int				seg_count;
d670 2
d701 1
a701 2
	sketch_ip->curve_count = bu_glong( rp->skt.skt_curve_count );
	seg_count = bu_glong( rp->skt.skt_seg_count );
d710 2
a711 2
	if( seg_count )
		segs = (genptr_t *)bu_calloc( seg_count, sizeof( genptr_t ), "segs" );
d713 2
a714 2
		segs = (genptr_t *)NULL;
	for( seg_no=0 ; seg_no < seg_count ; seg_no++ )
d733 1
a733 1
				segs[seg_no] = (genptr_t)lsg;
d748 1
a748 1
				segs[seg_no] = (genptr_t)csg;
d778 1
a778 1
				segs[seg_no] = (genptr_t)nsg;
d786 4
a789 3
	if( sketch_ip->curve_count )
		sketch_ip->curves = (struct curve *)bu_calloc( sketch_ip->curve_count, sizeof( struct curve ), "sketch_ip->curves" );
	for( curve_no=0 ; curve_no < sketch_ip->curve_count ; curve_no++ )
d791 1
a791 7
		struct curve *crv;
		int i;

		crv = &sketch_ip->curves[curve_no];
		NAMEMOVE( (char *)ptr, crv->crv_name );
		ptr += NAMESIZE;
		crv->seg_count = bu_glong( ptr );
a792 13

		crv->reverse = (int *)bu_calloc( crv->seg_count, sizeof(int), "crv->reverse" );
		crv->segments = (genptr_t *)bu_calloc( crv->seg_count, sizeof(genptr_t), "crv->segemnts" );
		for( i=0 ; i<crv->seg_count ; i++ )
		{
			int seg_index;

			crv->reverse[i] = bu_glong( ptr );
			ptr += 4;
			seg_index = bu_glong( ptr );
			ptr += 4;
			crv->segments[i] = segs[seg_index];
		}
a794 3
	if( segs )
		bu_free( (char *)segs, "segs" );

a818 1
	struct bu_ptbl segs;
d821 1
a835 1
	bu_ptbl_init( &segs, 64, "rt_sketch_export: segs" );
a837 11
	nbytes += sketch_ip->curve_count*(NAMESIZE+4);	/* curve name and seg_count */
	for( curve_no=0 ; curve_no < sketch_ip->curve_count ; curve_no++ )
	{
		struct curve *crv;

		crv = &sketch_ip->curves[curve_no];
		nbytes += 4 + crv->seg_count*8;	/* segment count + reverse flags and indices into segments array */

		for( seg_no=0 ; seg_no < crv->seg_count ; seg_no++ )
			bu_ptbl_ins_unique( &segs, (long *)crv->segments[seg_no] );
	}
d839 1
a839 1
	for( seg_no=0 ; seg_no < BU_PTBL_END( &segs ) ; seg_no++ )
d844 1
a844 1
		lng = BU_PTBL_GET( &segs, seg_no );
d884 1
a884 2
	(void)bu_plong( rec->skt.skt_curve_count, sketch_ip->curve_count );
	(void)bu_plong( rec->skt.skt_seg_count, BU_PTBL_END( &segs) );
d899 1
a899 1
	for( seg_no=0 ; seg_no < BU_PTBL_END( &segs) ; seg_no++ )
d908 1
a908 1
		lng = BU_PTBL_GET( &segs, seg_no );
d968 1
a968 1
	for( curve_no=0 ; curve_no < sketch_ip->curve_count ; curve_no++ )
d970 1
a970 9
		struct curve *crv;
		int i;

		crv = &sketch_ip->curves[curve_no];

		/* write curve parameters */
		NAMEMOVE( crv->crv_name, (char *)ptr );
		ptr += NAMESIZE;
		(void)bu_plong( ptr,  crv->seg_count );
a971 13
		for( i=0 ; i<crv->seg_count ; i++ )
		{
			int seg_index;

			(void)bu_plong( ptr, crv->reverse[i] );
			ptr += 4;
			seg_index = bu_ptbl_locate( &segs, (long *)crv->segments[i] );
			if( seg_index < 0 )
				bu_bomb( "rt_sketch_export: ERROR: unlisted segement encountered!!!\n" );

			(void)bu_plong( ptr, seg_index );
			ptr += 4;
		}
d998 1
a998 1
	int i, curve_no;
d1011 1
a1011 1
	sprintf(buf, "\tV = (%g %g %g),  A = (%g %g %g), B = (%g %g %g)\n\t%d vertices, %d curves\n",
d1015 1
a1015 2
		sketch_ip->vert_count,
		sketch_ip->curve_count );
d1034 3
a1036 1
	for( curve_no=0 ; curve_no < sketch_ip->curve_count ; curve_no++ )
d1038 6
a1043 3
		sprintf(buf, "\n\tCurve: %-16.16s\n", sketch_ip->curves[curve_no].crv_name );
		bu_vls_strcat( str, buf );
		for( seg_no=0 ; seg_no < sketch_ip->curves[curve_no].seg_count ; seg_no++ )
d1045 30
a1074 3
			struct line_seg *lsg;
			struct carc_seg *csg;
			struct nurb_seg *nsg;
d1076 2
a1077 7
			lsg = (struct line_seg *)sketch_ip->curves[curve_no].segments[seg_no];
			switch( lsg->magic )
			{
				case CURVE_LSEG_MAGIC:
					lsg = (struct line_seg *)sketch_ip->curves[curve_no].segments[seg_no];
					if( lsg->start >= sketch_ip->vert_count ||
					    lsg->end >= sketch_ip->vert_count )
d1079 5
a1083 6
						if( sketch_ip->curves[curve_no].reverse[seg_no] )
							sprintf( buf, "\t\tLine segment from vertex #%d to #%d\n",
								lsg->end, lsg->start );
						else
							sprintf( buf, "\t\tLine segment from vertex #%d to #%d\n",
								lsg->start, lsg->end );
d1085 1
a1085 1
					else	
d1087 5
a1091 8
						if( sketch_ip->curves[curve_no].reverse[seg_no] )
							sprintf( buf, "\t\tLine segment (%g %g) <-> (%g %g)\n",
								V2ARGS( sketch_ip->verts[lsg->end] ),
								V2ARGS( sketch_ip->verts[lsg->start] ) );
						else
							sprintf( buf, "\t\tLine segment (%g %g) <-> (%g %g)\n",
								V2ARGS( sketch_ip->verts[lsg->start] ),
								V2ARGS( sketch_ip->verts[lsg->end] ) );
d1094 7
a1100 4
					break;
				case CURVE_CARC_MAGIC:
					csg = (struct carc_seg *)sketch_ip->curves[curve_no].segments[seg_no];
					if( csg->radius < 0.0 )
d1102 5
a1106 19
						bu_vls_strcat( str, "\t\tFull Circle:\n" );

						if( csg->end >= sketch_ip->vert_count ||
						    csg->start >= sketch_ip->vert_count )
						{
							sprintf( buf, "\t\tcenter at vertex #%d\n",
								csg->end );
							bu_vls_strcat( str, buf );
							sprintf( buf, "\t\tpoint on circle at vertex #%d\n",
								csg->start );
						}
						else
						{
							sprintf( buf, "\t\t\tcenter: (%g %g)\n",
								V2ARGS( sketch_ip->verts[csg->end] ) );
							bu_vls_strcat( str, buf );
							sprintf( buf, "\t\t\tpoint on circle: (%g %g)\n",
								V2ARGS( sketch_ip->verts[csg->start] ) );
						}
d1111 2
a1112 22
						bu_vls_strcat( str, "\t\tCircular Arc:\n" );

						if( csg->end >= sketch_ip->vert_count ||
						    csg->start >= sketch_ip->vert_count )
						{
							sprintf( buf, "\t\t\tstart at vertex #%d\n",
								csg->start );
							bu_vls_strcat( str, buf );
							sprintf( buf, "\t\t\tend at vertex #%d\n",
								csg->end );
							bu_vls_strcat( str, buf );
						}
						else
						{
							sprintf( buf, "\t\t\tstart: (%g, %g)\n",
								V2ARGS( sketch_ip->verts[csg->start] ) );
							bu_vls_strcat( str, buf );
							sprintf( buf, "\t\t\tend: (%g, %g)\n",
								V2ARGS( sketch_ip->verts[csg->end] ) );
							bu_vls_strcat( str, buf );
						}
						sprintf( buf, "\t\t\tradius: %g\n", csg->radius*mm2local );
d1114 2
a1115 18
						if( csg->orientation )
							bu_vls_strcat( str, "\t\t\tcurve is clock-wise\n" );
						else
							bu_vls_strcat( str, "\t\t\tcurve is counter-clock-wise\n" );
						if( csg->center_is_left )
							bu_vls_strcat( str, "\t\t\tcenter of curvature is left of the line from start point to end point\n" );
						else
							bu_vls_strcat( str, "\t\t\tcenter of curvature is right of the line from start point to end point\n" );
						if( sketch_ip->curves[curve_no].reverse[seg_no] )
							bu_vls_strcat( str, "\t\t\tarc is reversed\n" );
					}
					break;
				case CURVE_NURB_MAGIC:
					nsg = (struct nurb_seg *)sketch_ip->curves[curve_no].segments[seg_no];
					bu_vls_strcat( str, "\t\tNURB Curve:\n" );
					if( RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) )
					{
						sprintf( buf, "\t\t\tCurve is rational\n" );
d1118 1
a1118 2
					sprintf( buf, "\t\t\torder = %d, number of control points = %d\n",
						nsg->order, nsg->c_size );
d1120 6
a1125 12
					if( nsg->ctl_points[0] >= sketch_ip->vert_count ||
					    nsg->ctl_points[nsg->c_size-1] >= sketch_ip->vert_count )
					{
						if( sketch_ip->curves[curve_no].reverse[seg_no] )
							sprintf( buf, "\t\t\tstarts at vertex #%d\n\t\t\tends at vertex #%d\n",
								nsg->ctl_points[nsg->c_size-1],
								nsg->ctl_points[0] );
						else
							sprintf( buf, "\t\t\tstarts at vertex #%d\n\t\t\tends at vertex #%d\n",
								nsg->ctl_points[0],
								nsg->ctl_points[nsg->c_size-1] );
					}
d1127 11
a1137 10
					{
						if( sketch_ip->curves[curve_no].reverse[seg_no] )
							sprintf( buf, "\t\t\tstarts at (%g %g)\n\t\t\tends at (%g %g)\n",
								V2ARGS( sketch_ip->verts[nsg->ctl_points[nsg->c_size-1]] ),
								V2ARGS( sketch_ip->verts[nsg->ctl_points[0]] ) );
						else
							sprintf( buf, "\t\t\tstarts at (%g %g)\n\t\t\tends at (%g %g)\n",
								V2ARGS( sketch_ip->verts[nsg->ctl_points[0]] ),
								V2ARGS( sketch_ip->verts[nsg->ctl_points[nsg->c_size-1]] ) );
					}
d1139 34
a1172 7
					sprintf( buf, "\t\t\tknot values are %g to %g\n",
						nsg->k.knots[0], nsg->k.knots[nsg->k.k_size-1] );
					bu_vls_strcat( str, buf );
					break;
				default:
					bu_bomb( "rt_sketch_describe: ERROR: unrecognized segment type\n" );
			}
d1190 1
a1190 1
	int					curve_no;
a1205 3
	for( curve_no=0 ; curve_no < sketch_ip->curve_count ; curve_no++ )
	{
		long *lng;
d1207 1
a1207 1
		crv = &sketch_ip->curves[curve_no];
d1209 4
a1212 1
		for( seg_no=0 ; seg_no < crv->seg_count ; seg_no++ )
d1214 2
a1215 6
			lng = (long *)crv->segments[seg_no];
			if( *lng > 0 )
			{
				*lng = 0;
				bu_free( (char *)lng, "lng" );
			}
d1217 4
a1221 5
		bu_free( (char *)crv->reverse, "crv->reverse" );
		bu_free( (char *)crv->segments, "crv->segments" );
	}
	if( sketch_ip->curves )
		bu_free( (char *)sketch_ip->curves, "sketch_ip->curves" );
a1275 1
	strncpy( crv_out->crv_name, crv_in->crv_name, SKETCH_NAME_LEN );
d1336 1
d1353 2
a1354 80
	out->curves = (struct curve *)bu_calloc( out->curve_count, sizeof( struct curve ), "out->curves" );
	for( i=0 ; i<out->curve_count ; i++ )
	{
		struct curve *crv_out, *crv_in;

		crv_out = &out->curves[i];
		crv_in = &sketch_ip->curves[i];
		rt_copy_curve( crv_out, crv_in );
	}

	/* fix back pointers */
	bu_ptbl_init( &curves, 10, "bu_ptbl curves" );
	for( i=0 ; i<out->curve_count ; i++ )
	{
		struct curve *crv_out;
		int j;

		crv_out = &out->curves[i];
		for( j=0 ; j<crv_out->seg_count ; j++ )
		{
			long *lng;
			int k;

			/* count how many curves use this segment */
			lng = (long *)crv_out->segments[j];
			for( k=0 ; k<out->curve_count ; k++ )
			{
				int l;
				struct curve *crv;

				crv = &out->curves[k];
				for( l=0 ; l< crv->seg_count ; l++ )
				{
					if( (long *)crv->segments[l] == lng )
						bu_ptbl_ins_unique( &curves, lng );
				}
			}

			switch( *lng )
			{
				int l;

				case CURVE_LSEG_MAGIC:
				{
					struct line_seg *lsg;

					lsg = (struct line_seg *)lng;
					lsg->curves = (struct curve **)bu_calloc( BU_PTBL_END( &curves ),
						sizeof( struct curve *), "lsg->curves" );
					for( l=0 ; l<BU_PTBL_END( &curves ) ; l++ )
						lsg->curves[l] = (struct curve *)BU_PTBL_GET( &curves, l );
				}
				break;
				case CURVE_CARC_MAGIC:
				{
					struct carc_seg *csg;

					csg = (struct carc_seg *)lng;
					csg->curves = (struct curve **)bu_calloc( BU_PTBL_END( &curves ),
						sizeof( struct curve *), "csg->curves" );
					for( l=0 ; l<BU_PTBL_END( &curves ) ; l++ )
						csg->curves[l] = (struct curve *)BU_PTBL_GET( &curves, l );
				}
				break;
				case CURVE_NURB_MAGIC:
				{
					struct nurb_seg *nsg;

					nsg = (struct nurb_seg *)lng;
					nsg->curves = (struct curve **)bu_calloc( BU_PTBL_END( &curves ),
						sizeof( struct curve *), "nsg->curves" );
					for( l=0 ; l<BU_PTBL_END( &curves ) ; l++ )
						nsg->curves[l] = (struct curve *)BU_PTBL_GET( &curves, l );
				}
				break;
			}
			bu_ptbl_trunc( &curves, 0 );
		}
	}
	bu_ptbl_free( &curves );
d1372 1
a1372 1
	bu_vls_printf( vls, " %s {SL {", crv->crv_name );
d1413 1
a1413 1
	bu_vls_strcat( vls, " }}" );	/* end of segment list */
d1428 1
d1445 3
a1447 2
		bu_vls_strcat( &vls, " CL {" );
		for( i=0 ; i<skt->curve_count ; i++ )
d1449 2
a1450 10
			struct curve *crv;

			crv = &skt->curves[i];
			bu_vls_strcat( &vls, " {" );
			if( curve_to_tcl_list( &vls, crv ) )
			{
				bu_vls_free( &vls );
				return( TCL_ERROR );
			}
			bu_vls_strcat( &vls, " }" );
a1451 1
		bu_vls_strcat( &vls, " }" );	/* end of curve list */
d1464 1
a1464 1
	else if( !strcmp( attr, "CL" ) )
d1466 2
a1467 1
		for( i=0 ; i<skt->curve_count ; i++ )
d1469 2
a1470 8
			struct curve *crv;

			crv = &skt->curves[i];
			if( curve_to_tcl_list( &vls, crv ) )
			{
				bu_vls_free( &vls );
				return( TCL_ERROR );
			}
d1485 1
a1485 1
	else	 /* asking for a curve by name */
d1487 3
a1489 15
		for( i=0 ; i<skt->curve_count ; i++ )
		{
			struct curve *crv=&skt->curves[i];;

			if( !strcmp( attr, crv->crv_name ) )
			{
				if( curve_to_tcl_list( &vls, crv ) )
				{
					Tcl_SetResult( interp, "ERROR: converting curve to TCL\n", TCL_STATIC );
					bu_vls_free( &vls );
					return( TCL_ERROR );
				}
				break;
			}
		}
a1743 2
			lsg->curve_count = 1;
			lsg->curves = &crv;
a1789 2
			csg->curve_count = 1;
			csg->curves = &crv;
a1833 2
			nsg->curve_count = 1;
			nsg->curves = &crv;
d1916 1
a1916 1
		else if( !strcmp( argv[0], "CL" ) )	/* the entire curve list */
d1945 1
a1945 3
				Tcl_Obj *crv_obj, *crv_name;
				char *name;
				int j;
d1963 4
a1966 41
				/* each curve must have two elements (a name and a segment list) */
				if( len2 != 2 )
				{
					Tcl_DecrRefCount( list );
					Tcl_DecrRefCount( crv_obj );
					Tcl_ResetResult( interp );
					Tcl_AppendResult( interp, "ERROR: Curve must have two elements (name and segment list!!\n", "Erroneous curve: ",
						Tcl_GetString( crv_obj ), (char *)NULL );
					return( TCL_ERROR );
				}

				/* get the curve name */
				if( (ret=Tcl_ListObjIndex( interp, crv_obj, 0, &crv_name ) ))
				{
					Tcl_DecrRefCount( list );
					Tcl_DecrRefCount( crv_obj );
					return( ret );
				}
				name = Tcl_GetString( crv_name );

				/* check if this curve already exists */
				crv = (struct curve *)NULL;
				for( j=0 ; j<skt->curve_count ; j++ )
				{
					crv = &skt->curves[j];
					if( !strcmp( crv->crv_name, name ) )
						break;
					else
						crv = (struct curve *)NULL;
				}
				if( !crv )
				{
					skt->curves = (struct curve *)bu_realloc( skt->curves, (++skt->curve_count)*sizeof( struct curve ), "skt->curves" );
					crv = &skt->curves[skt->curve_count-1];
					crv->seg_count = 0;
					crv->reverse = (int *)NULL;
					crv->segments = (genptr_t)NULL;
					NAMEMOVE( name, crv->crv_name );
				}
				else
					rt_curve_free( crv );
a1991 78
		}
		else	/* changing a specifically named curve, or adding a new curve */
		{
			Tcl_Obj *crv_obj, *objs[2];
			struct curve *crv=(struct curve *)NULL;
			struct curve save_curve;
			int j, k;
			char *crv_name;
			int new_curve=1;

			objs[0] = Tcl_NewStringObj( argv[0], -1 );
			crv_name = Tcl_GetStringFromObj( objs[0], &j );

			for( j=0 ; j<skt->curve_count ; j++ )
			{
				if( !strcmp( crv_name, skt->curves[j].crv_name ) )
				{
					new_curve = 0;
					crv = &skt->curves[j];
					break;
				}
			}

			if( !strcmp( argv[1], "del" ) )
			{
				/* delete this curve */
				if( crv )
				{
					rt_curve_free( crv );
					skt->curve_count--;
					for( k=j ; k<skt->curve_count ; k++ )
						skt->curves[k] = skt->curves[k+1];
					skt->curves = (struct curve *)bu_realloc( skt->curves, skt->curve_count*sizeof( struct curve ), "skt->curves" );
				}

				goto next_arg;
			}

			if( crv )
			{
				rt_copy_curve( &save_curve, crv );
				rt_curve_free( crv );
			}
			else
			{
				skt->curves = (struct curve *)bu_realloc( skt->curves, (++skt->curve_count)*sizeof( struct curve ), "skt->curves" );
				crv = &skt->curves[skt->curve_count-1];
				crv->seg_count = 0;
				crv->reverse = (int *)NULL;
				crv->segments = (genptr_t)NULL;
				NAMEMOVE( crv_name, crv->crv_name );
			}
			objs[1] = Tcl_NewStringObj( argv[1], -1 );
			crv_obj = Tcl_NewListObj( 2, objs );

			if( (ret=get_tcl_curve( interp, crv, crv_obj )) != TCL_OK )
			{
				if( new_curve )
				{
					/* eliminate the failed new curve */
					rt_curve_free( crv );
					skt->curves = (struct curve *)bu_realloc( skt->curves, (--skt->curve_count)*sizeof( struct curve ), "skt->curves" );
				}
				else
				{
					/* restore the original curve */
					rt_curve_free( crv );
					rt_copy_curve( crv, &save_curve );
					rt_curve_free( &save_curve );
				}
				return( TCL_ERROR );
			}
#if 0
			/* seems like we ought to free this stuff, but it core dumps!!!! */
			Tcl_DecrRefCount( crv_obj );
			Tcl_DecrRefCount( objs[0] );
			Tcl_DecrRefCount( objs[1] );
#endif
@


1.18
log
@Corrected tclget routines
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.17 2000/03/02 14:47:28 jra Exp $ (BRL)";
d57 4
@


1.17
log
@Eliminated FGP solid and added cline solid
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.16 2000/02/10 19:49:45 jra Exp $ (BRL)";
d1658 1
a1658 1
	Tcl_DStringAppendElement( &ds, bu_vls_addr( &vls ) );
@


1.16
log
@continued development of the sketch and extrusion solids
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.15 2000/01/31 14:45:49 jra Exp $ (BRL)";
d1056 2
d1062 4
d1067 3
a1069 3
		V3ARGS( sketch_ip->V ),
		V3ARGS( sketch_ip->u_vec ),
		V3ARGS( sketch_ip->v_vec ),
d1176 1
a1176 1
						sprintf( buf, "\t\t\tradius: %g\n", csg->radius );
@


1.15
log
@Eliminated some unused variables
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.14 2000/01/31 13:40:50 jra Exp $ (BRL)";
d60 55
a243 4
	register struct sketch_specific *sketch =
		(struct sketch_specific *)stp->st_specific;

	bu_free( (char *)sketch, "sketch_specific" );
d258 1
a258 1
void
d278 1
d293 6
d312 8
a320 1
				csg = (struct carc_seg *)lng;
d471 8
d596 2
d612 2
d621 6
a626 1
		curve_to_vlist( vhead, ttol, sketch_ip->V, sketch_ip->u_vec, sketch_ip->v_vec, sketch_ip, &sketch_ip->curves[curve_no] );
d629 1
a629 1
	return(0);
d689 1
a689 1
	ip->idb_ptr = bu_malloc( sizeof(struct rt_sketch_internal), "rt_sketch_internal");
d705 2
a706 1
	sketch_ip->verts = (point2d_t *)bu_calloc( sketch_ip->vert_count, sizeof( point2d_t ), "sketch_ip->vert" );
d710 4
a713 1
	segs = (genptr_t *)bu_calloc( seg_count, sizeof( genptr_t ), "segs" );
d786 2
a787 1
	sketch_ip->curves = (struct curve *)bu_calloc( sketch_ip->curve_count, sizeof( struct curve ), "sketch_ip->curves" );
d813 2
a814 1
	bu_free( (char *)segs, "segs" );
d1053 1
a1053 1
	int curve_no;
d1060 1
a1060 1
	sprintf(buf, "\tV = (%g %g %g)\n\t%d vertices, %d curves\n",
d1062 2
d1071 13
d1086 1
a1086 1
		sprintf(buf, "\tCurve: %-16.16s\n", sketch_ip->curves[curve_no].crv_name );
d1099 21
a1119 8
					if( sketch_ip->curves[curve_no].reverse[seg_no] )
						sprintf( buf, "\t\tLine segment (%g %g) <-> (%g %g)\n",
							V2ARGS( sketch_ip->verts[lsg->end] ),
							V2ARGS( sketch_ip->verts[lsg->start] ) );
					else
						sprintf( buf, "\t\tLine segment (%g %g) <-> (%g %g)\n",
							V2ARGS( sketch_ip->verts[lsg->start] ),
							V2ARGS( sketch_ip->verts[lsg->end] ) );
d1127 18
a1144 5
						sprintf( buf, "\t\t\tcenter: (%g %g)\n",
							V2ARGS( sketch_ip->verts[csg->end] ) );
						bu_vls_strcat( str, buf );
						sprintf( buf, "\t\t\tpoint on circle: (%g %g)\n",
							V2ARGS( sketch_ip->verts[csg->start] ) );
d1150 20
a1169 8
						if( sketch_ip->curves[curve_no].reverse[seg_no] )
							bu_vls_strcat( str, "\t\t\tarc is reversed\n" );
						sprintf( buf, "\t\t\tstart: (%g, %g)\n",
							V2ARGS( sketch_ip->verts[csg->start] ) );
						bu_vls_strcat( str, buf );
						sprintf( buf, "\t\t\tend: (%g, %g)\n",
							V2ARGS( sketch_ip->verts[csg->end] ) );
						bu_vls_strcat( str, buf );
d1180 2
d1195 12
a1206 4
					if( sketch_ip->curves[curve_no].reverse[seg_no] )
						sprintf( buf, "\t\t\tstarts at (%g %g)\n\t\t\tends at (%g %g)\n",
							V2ARGS( sketch_ip->verts[nsg->ctl_points[nsg->c_size-1]] ),
							V2ARGS( sketch_ip->verts[nsg->ctl_points[0]] ) );
d1208 10
a1217 3
						sprintf( buf, "\t\t\tstarts at (%g %g)\n\t\t\tends at (%g %g)\n",
							V2ARGS( sketch_ip->verts[nsg->ctl_points[0]] ),
							V2ARGS( sketch_ip->verts[nsg->ctl_points[nsg->c_size-1]] ) );
d1257 2
a1258 1
	bu_free( (char *)sketch_ip->verts, "sketch_ip->verts" );
d1278 2
a1279 1
	bu_free( (char *)sketch_ip->curves, "sketch_ip->curves" );
d1292 36
d1633 1
a1633 1
	else
d1658 626
@


1.14
log
@Getting the extrusion and sketch to work - not quite finished
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.13 2000/01/03 19:34:27 jra Exp $ (BRL)";
a1387 1
			int j;
a1415 1
			int j;
@


1.13
log
@Fixed bug in rt_sketch_copy()
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.12 2000/01/03 16:35:01 jra Exp $ (BRL)";
d48 1
d226 1
d256 1
a256 1
				if( csg->radius < 0.0 )
d261 3
a263 2
					VJOIN2( pt, V, -sketch_ip->verts[csg->start][1], u_vec, sketch_ip->verts[csg->start][0], v_vec);
					VSUB2( semi_b, pt, center );
d265 1
d303 1
a303 1
				if( csg->radius < 0.0 )
d364 1
a364 1
					if( end_ang > start_ang )
a365 1
					tot_ang = start_ang - end_ang;
d369 1
a369 1
					if( end_ang < start_ang )
a370 1
					tot_ang = end_ang - start_ang;
d372 1
d1131 61
a1218 1
		int j;
d1222 1
a1222 52
		strncpy( crv_out->crv_name, crv_in->crv_name, SKETCH_NAME_LEN );
		crv_out->seg_count = crv_in->seg_count;
		crv_out->reverse = (int *)bu_calloc( crv_out->seg_count, sizeof( int ), "crv->reverse" );
		crv_out->segments = (genptr_t *)bu_calloc( crv_out->seg_count, sizeof( genptr_t ), "crv->segments" );
		for( j=0 ; j<crv_out->seg_count ; j++ )
		{
			long *lng;
			struct line_seg *lsg_out, *lsg_in;
			struct carc_seg *csg_out, *csg_in;
			struct nurb_seg *nsg_out, *nsg_in;

			crv_out->reverse[j] = crv_in->reverse[j];
			lng = (long *)crv_in->segments[j];
			switch( *lng )
			{
				case CURVE_LSEG_MAGIC:
					lsg_in = (struct line_seg *)lng;
					lsg_out = (struct line_seg *)bu_malloc( sizeof( struct line_seg ), "line_seg" );
					crv_out->segments[j] = (genptr_t)lsg_out;
					*lsg_out = *lsg_in;
					break;
				case CURVE_CARC_MAGIC:
					csg_in = (struct carc_seg *)lng;
					csg_out = (struct carc_seg *)bu_malloc( sizeof( struct carc_seg ), "carc_seg" );
					crv_out->segments[j] = (genptr_t)csg_out;
					*csg_out = *csg_in;
					break;
				case CURVE_NURB_MAGIC:
					nsg_in = (struct nurb_seg *)lng;
					nsg_out = (struct nurb_seg *)bu_malloc( sizeof( struct nurb_seg ), "nurb_seg" );
					crv_out->segments[j] = (genptr_t)nsg_out;
					*nsg_out = *nsg_in;
					nsg_out->ctl_points = (int *)bu_calloc( nsg_in->c_size, sizeof( int ), "nsg_out->ctl_points" );
					for( i=0 ; i<nsg_out->c_size ; i++ )
						nsg_out->ctl_points[i] = nsg_in->ctl_points[i];
					if( RT_NURB_IS_PT_RATIONAL( nsg_in->pt_type ) )
					{
						nsg_out->weights = (fastf_t *)bu_malloc( nsg_out->c_size * sizeof( fastf_t ), "nsg_out->weights" );
						for( i=0 ; i<nsg_out->c_size ; i++ )
							nsg_out->weights[i] = nsg_in->weights[i];
					}
					else
						nsg_out->weights = (fastf_t *)NULL;
					nsg_out->k.knots = bu_malloc( nsg_in->k.k_size * sizeof( fastf_t ), "nsg_out->k.knots" );
					for( i=0 ; i<nsg_in->k.k_size ; i++ )
						nsg_out->k.knots[i] = nsg_in->k.knots[i];
					break;
				default:
					bu_log( "rt_copy_sketch: ERROR: unrecognized segment type!!!!\n" );
					return( (struct rt_sketch_internal *)NULL );
			}
		}
d1303 160
@


1.12
log
@Fixed a bug in the NURB curve drawing
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.11 1999/12/30 14:23:16 jra Exp $ (BRL)";
d1241 38
a1278 3
			crv_out->segments = bu_calloc( BU_PTBL_END( &curves ), sizeof( genptr_t ), "crv_out->segments" );
			for( k=0 ; k<BU_PTBL_END( &curves ) ; k++ )
				crv_out->segments = (genptr_t)BU_PTBL_GET( &curves, k );
@


1.11
log
@More stuff for the sketch and extrusion solids
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.9 1999/12/29 21:07:44 jra Exp $ (BRL)";
d221 2
a222 1
	point_t center, pt, start_pt, end_pt;
d491 1
a491 1
					fastf_t t, pt_skt[3];
d495 1
a495 1
					rt_nurb_c_eval( &eg, t, pt_skt );
d499 1
a499 1
							pt_skt[j] /= pt_skt[coords-1];
a500 1
					VJOIN2( pt, V, pt_skt[0], u_vec, pt_skt[1], v_vec );
@


1.10
log
@
Added better stub
@
text
@d57 1
a57 7
fastf_t rt_cnurb_par_edge( egp, epsilon )
struct edge_g_cnurb *egp;
fastf_t	epsilon;
{
	bu_bomb("rt_cnurb_par_edge()\n");
	/* NOTREACHED */
}
@


1.9
log
@Eliminated some unused variables
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.8 1999/11/26 22:02:53 mike Exp $ (BRL)";
d57 7
a63 1
fastf_t rt_cnurb_par_edge();
@


1.8
log
@
Lint fixed
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.7 1999/11/26 21:46:49 mike Exp $ (BRL)";
d53 1
d57 2
a90 2
	register CONST struct sketch_specific *sketch =
		(struct sketch_specific *)stp->st_specific;
a142 2
	register struct sketch_specific *sketch =
		(struct sketch_specific *)stp->st_specific;
a157 3
	register struct sketch_specific *sketch =
		(struct sketch_specific *)stp->st_specific;

a178 2
	register struct sketch_specific *sketch =
		(struct sketch_specific *)stp->st_specific;
d204 1
a204 1
 *			R T _ S K E T C H _ P L O T
d206 3
a208 4
int
rt_sketch_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
d210 4
a213 1
CONST struct bn_tol		*tol;
d215 9
a223 3
	LOCAL struct rt_sketch_internal	*sketch_ip;
	struct curve			*crv;
	int				curve_no;
d225 5
a229 3
	RT_CK_DB_INTERNAL(ip);
	sketch_ip = (struct rt_sketch_internal *)ip->idb_ptr;
	RT_SKETCH_CK_MAGIC(sketch_ip);
d231 1
a231 1
	for( curve_no=0 ; curve_no < sketch_ip->curve_count ; curve_no++ )
d233 60
a292 6
		long *lng;
		int seg_no;
		struct line_seg *lsg;
		int first=1;
		int start, end, prev=-1;
		point_t pt;
d294 27
a320 1
		crv = &sketch_ip->curves[curve_no];
d322 72
a393 4
		for( seg_no=0 ; seg_no < crv->seg_count ; seg_no++ )
		{
			lng = (long *)crv->segments[seg_no];
			switch( *lng )
d395 18
a412 3
				case CURVE_LSEG_MAGIC:
					lsg = (struct line_seg *)lng;
					if( crv->reverse[seg_no] )
d414 7
a420 2
						end = lsg->start;
						start = lsg->end;
d422 13
a434 1
					else
d436 2
a437 2
						start = lsg->start;
						end = lsg->end;
d439 21
a459 1
					if( first || start != prev )
d461 9
a469 2
						VJOIN2( pt, sketch_ip->V, sketch_ip->verts[start][0], sketch_ip->u_vec, sketch_ip->verts[start][1], sketch_ip->v_vec);
						RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE )
d471 18
a488 5
					VJOIN2( pt, sketch_ip->V, sketch_ip->verts[end][0], sketch_ip->u_vec, sketch_ip->verts[end][1], sketch_ip->v_vec);
					RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
					prev = end;
					break;
				default:
d490 15
a504 2
					bu_log( "rt_sketch_plot: ERROR: unrecognized segment type!!!!\n" );
					return( -1 );
d506 2
d509 3
a511 1
			first = 0;
d515 29
a581 1
	int				vert_no;
d621 2
a622 5
	for( vert_no=0 ; vert_no < sketch_ip->vert_count ; vert_no++ )
	{
		ntohd( (unsigned char *)&sketch_ip->verts[vert_no][0], ptr, 2 );
		ptr += 16;
	}
d630 2
d655 2
d661 30
d748 1
a748 1
	int	curve_no, seg_no, vert_no, nbytes=0, ngran;
a751 1
	double tmp[2];
d775 1
a775 1
		nbytes += crv->seg_count*8;	/* reverse flags and indices into segments array */
d784 1
d793 7
a799 1
				nbytes += 24;
d820 5
a824 4
	VSCALE( tmp_vec, sketch_ip->u_vec, local2mm );
	htond( rec->skt.skt_uvec, (unsigned char *)tmp_vec, 3 );
	VSCALE( tmp_vec, sketch_ip->v_vec, local2mm );
	htond( rec->skt.skt_vvec, (unsigned char *)tmp_vec, 3 );
d832 2
a833 1
	for( vert_no=0 ; vert_no < sketch_ip->vert_count ; vert_no++ )
d835 4
a838 3
		/* write 2D point coordinates */
		V2MOVE( tmp, sketch_ip->verts[vert_no] )
		htond( ptr, (unsigned char *)tmp, 2 );
d846 1
d848 1
d859 1
a859 1
				ptr +=4;
d873 4
a876 1
				htond( ptr, (unsigned char *)&cseg->radius, 1 );
d879 25
d993 8
a1000 3
					sprintf( buf, "\t\tLine segment (%g %g) <-> (%g %g)\n",
						V2ARGS( sketch_ip->verts[lsg->start] ),
						V2ARGS( sketch_ip->verts[lsg->end] ) );
d1005 43
a1047 1
					sprintf( buf, "\t\tCircular Arc:\n" );
d1049 8
a1056 2
					sprintf( buf, "\t\t\tstart: (%g, %g)\n",
						V2ARGS( sketch_ip->verts[csg->start] ) );
d1058 2
a1059 6
					sprintf( buf, "\t\t\tend: (%g, %g)\n",
						V2ARGS( sketch_ip->verts[csg->end] ) );
					bu_vls_strcat( str, buf );
					sprintf( buf, "\t\t\tradius: %g\n", csg->radius );
					bu_vls_strcat( str, buf );
					sprintf( buf, "\t\t\torientation: %d\n", csg->orientation );
a1082 1
	genptr_t				*seg_ptr;
d1134 1
d1168 1
d1186 20
d1212 36
@


1.7
log
@
Lint cleanups
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.6 1999/11/17 02:42:01 mike Exp $ (BRL)";
d742 1
a742 1
copy_sketch( sketch_ip )
d752 1
a752 1
		bu_log( "Barrier check at start of copy_sketch():\n" );
d798 1
a798 1
					bu_log( "copy_sketch: ERROR: unrecognized segment type!!!!\n" );
d806 1
a806 1
		bu_log( "Barrier check at end of copy_sketch():\n" );
@


1.6
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.5 1999/07/02 22:19:24 mike Exp $ (BRL)";
d217 1
a217 1
struct bn_tol		*tol;
d290 1
a290 1
struct bn_tol		*tol;
d617 1
a617 1
struct rt_db_internal	*ip;
@


1.5
log
@
Removed dependence on compat4.h
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.4 1999/05/27 19:10:42 mike Exp $ (BRL)";
d334 1
@


1.4
log
@
sed4
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.3 1999/01/13 21:56:30 mike Exp $ (BRL)";
d258 1
a258 1
						RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE )
d261 1
a261 1
					RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
@


1.3
log
@Fixed coding errors regarding missing & on args to htond()
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.2 1998/06/25 08:24:18 mike Exp $ (BRL)";
d197 1
a197 1
	rt_free( (char *)sketch, "sketch_specific" );
d214 1
a214 1
struct rt_list		*vhead;
d217 1
a217 1
struct rt_tol		*tol;
d290 1
a290 1
struct rt_tol		*tol;
d304 1
a304 1
CONST struct rt_external	*ep;
d318 1
a318 1
	RT_CK_EXTERNAL( ep );
d322 1
a322 1
		rt_log("rt_sketch_import: defective record\n");
d440 1
a440 1
struct rt_external		*ep;
d464 1
a464 1
	RT_INIT_EXTERNAL(ep);
d502 1
a502 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "sketch external");
d517 4
a520 4
	(void)rt_plong( rec->skt.skt_vert_count, sketch_ip->vert_count );
	(void)rt_plong( rec->skt.skt_curve_count, sketch_ip->curve_count );
	(void)rt_plong( rec->skt.skt_seg_count, BU_PTBL_END( &segs) );
	(void)rt_plong( rec->skt.skt_count, ngran-1 );
d615 1
a615 1
struct rt_vls		*str;
d627 1
a627 1
	rt_vls_strcat( str, "2D sketch (SKETCH)\n");
d633 1
a633 1
	rt_vls_strcat( str, buf );
d641 1
a641 1
		rt_vls_strcat( str, buf );
d656 1
a656 1
					rt_vls_strcat( str, buf );
d661 1
a661 1
					rt_vls_strcat( str, buf );
d664 1
a664 1
					rt_vls_strcat( str, buf );
d667 1
a667 1
					rt_vls_strcat( str, buf );
d669 1
a669 1
					rt_vls_strcat( str, buf );
d671 1
a671 1
					rt_vls_strcat( str, buf );
@


1.2
log
@unsigned char -vs- char
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sketch.c,v 1.1 1998/05/29 14:18:47 jra Exp $ (BRL)";
d338 1
a338 1
	ntohd( v, rp->skt.skt_V, 3 );
d340 1
a340 1
	ntohd( v, rp->skt.skt_uvec, 3 );
d342 1
a342 1
	ntohd( v, rp->skt.skt_vvec, 3 );
d353 1
a353 1
		ntohd( &sketch_ip->verts[vert_no][0], ptr, 2 );
d386 1
a386 1
				ntohd( csg->radius, ptr );
d512 1
a512 1
	htond( rec->skt.skt_V, tmp_vec, 3 );
d514 1
a514 1
	htond( rec->skt.skt_uvec, tmp_vec, 3 );
d516 1
a516 1
	htond( rec->skt.skt_vvec, tmp_vec, 3 );
d528 1
a528 1
		htond( ptr, tmp, 2 );
d561 1
a561 1
				htond( ptr, cseg->radius, 1 );
@


1.1
log
@Initial revision
@
text
@d41 1
a41 1
static char RCSsketch[] = "@@(#)$Header: /m/cad/librt/RCS/g_sketch.c,v 11.2 1997/09/22 05:16:19 butler Exp $ (BRL)";
d315 1
a315 1
	char				*ptr;
d348 1
a348 1
	ptr = (char *)rp;
d403 1
a403 1
		NAMEMOVE( ptr, crv->crv_name );
d579 1
a579 1
		NAMEMOVE( crv->crv_name, ptr );
@
