head	1.185;
access;
symbols
	ansi-20040405-merged:1.168.2.4
	postmerge-20040405-ansi:1.182
	premerge-20040404-ansi:1.181
	postmerge-autoconf:1.181
	autoconf-freeze:1.178.4.3
	premerge-autoconf:1.181
	ansi-20040316-freeze:1.168.2.2
	postmerge-20040315-windows:1.181
	premerge-20040315-windows:1.181
	windows-20040315-freeze:1.168.4.1
	autoconf-20031203:1.178.4.1
	autoconf-20031202:1.178
	autoconf-branch:1.178.0.4
	phong-branch:1.178.0.2
	photonmap-branch:1.176.0.2
	rel-6-1-DP:1.168
	windows-branch:1.168.0.4
	rel-6-0-2:1.166
	ansi-branch:1.168.0.2
	rel-6-0-1-branch:1.166.0.2
	hartley-6-0-post:1.167
	hartley-6-0-pre:1.166
	rel-6-0-1:1.166
	rel-6-0:1.160
	rel-5-4:1.53.2.5
	offsite-5-3-pre:1.86
	rel-5-3:1.53.2.5
	rel-5-2:1.53
	rel-5-1-branch:1.53.0.2
	rel-5-1:1.53;
locks; strict;
comment	@ * @;


1.185
date	2004.05.21.18.07.36;	author morrison;	state dead;
branches;
next	1.184;

1.184
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	1.183;

1.183
date	2004.05.10.15.25.27;	author morrison;	state Exp;
branches;
next	1.182;

1.182
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	1.181;

1.181
date	2004.02.03.21.53.01;	author jra;	state Exp;
branches;
next	1.180;

1.180
date	2004.02.02.17.39.29;	author morrison;	state Exp;
branches;
next	1.179;

1.179
date	2003.11.19.21.45.04;	author jra;	state Exp;
branches;
next	1.178;

1.178
date	2003.09.05.14.44.29;	author jra;	state Exp;
branches
	1.178.4.1;
next	1.177;

1.177
date	2003.09.03.00.23.36;	author jra;	state Exp;
branches;
next	1.176;

1.176
date	2003.04.02.15.10.30;	author jra;	state Exp;
branches;
next	1.175;

1.175
date	2003.04.01.19.16.18;	author jra;	state Exp;
branches;
next	1.174;

1.174
date	2003.02.24.19.17.52;	author jra;	state Exp;
branches;
next	1.173;

1.173
date	2003.01.31.13.38.22;	author jra;	state Exp;
branches;
next	1.172;

1.172
date	2002.12.11.21.36.19;	author jra;	state Exp;
branches;
next	1.171;

1.171
date	2002.12.11.18.49.30;	author jra;	state Exp;
branches;
next	1.170;

1.170
date	2002.12.09.20.37.11;	author jra;	state Exp;
branches;
next	1.169;

1.169
date	2002.12.03.20.01.27;	author jra;	state Exp;
branches;
next	1.168;

1.168
date	2002.08.20.17.08.11;	author jra;	state Exp;
branches
	1.168.2.1
	1.168.4.1;
next	1.167;

1.167
date	2002.08.15.20.55.22;	author hartley;	state Exp;
branches;
next	1.166;

1.166
date	2002.07.16.02.15.13;	author jra;	state Exp;
branches;
next	1.165;

1.165
date	2002.07.13.17.54.40;	author jra;	state Exp;
branches;
next	1.164;

1.164
date	2002.06.07.19.57.34;	author jra;	state Exp;
branches;
next	1.163;

1.163
date	2002.06.05.21.16.57;	author morrison;	state Exp;
branches;
next	1.162;

1.162
date	2002.05.10.13.00.32;	author jra;	state Exp;
branches;
next	1.161;

1.161
date	2002.05.09.19.01.03;	author jra;	state Exp;
branches;
next	1.160;

1.160
date	2002.02.25.16.05.14;	author jra;	state Exp;
branches;
next	1.159;

1.159
date	2002.02.25.15.23.25;	author jra;	state Exp;
branches;
next	1.158;

1.158
date	2002.02.25.13.57.22;	author jra;	state Exp;
branches;
next	1.157;

1.157
date	2002.02.15.19.04.13;	author jra;	state Exp;
branches;
next	1.156;

1.156
date	2002.02.15.18.38.45;	author jra;	state Exp;
branches;
next	1.155;

1.155
date	2002.02.05.03.11.09;	author jra;	state Exp;
branches;
next	1.154;

1.154
date	2002.01.24.14.40.40;	author jra;	state Exp;
branches;
next	1.153;

1.153
date	2002.01.22.19.01.44;	author jra;	state Exp;
branches;
next	1.152;

1.152
date	2002.01.16.20.29.14;	author butler;	state Exp;
branches;
next	1.151;

1.151
date	2002.01.10.18.12.41;	author butler;	state Exp;
branches;
next	1.150;

1.150
date	2002.01.09.19.58.19;	author jra;	state Exp;
branches;
next	1.149;

1.149
date	2002.01.08.21.56.53;	author jra;	state Exp;
branches;
next	1.148;

1.148
date	2002.01.08.20.49.00;	author jra;	state Exp;
branches;
next	1.147;

1.147
date	2002.01.08.18.00.24;	author jra;	state Exp;
branches;
next	1.146;

1.146
date	2002.01.08.17.52.02;	author jra;	state Exp;
branches;
next	1.145;

1.145
date	2002.01.08.15.45.59;	author jra;	state Exp;
branches;
next	1.144;

1.144
date	2001.12.13.19.36.21;	author jra;	state Exp;
branches;
next	1.143;

1.143
date	2001.12.12.18.39.11;	author bparker;	state Exp;
branches;
next	1.142;

1.142
date	2001.11.16.16.46.47;	author bparker;	state Exp;
branches;
next	1.141;

1.141
date	2001.11.15.22.05.56;	author bparker;	state Exp;
branches;
next	1.140;

1.140
date	2001.11.14.17.50.45;	author bparker;	state Exp;
branches;
next	1.139;

1.139
date	2001.11.13.22.22.49;	author jra;	state Exp;
branches;
next	1.138;

1.138
date	2001.11.08.22.04.01;	author butler;	state Exp;
branches;
next	1.137;

1.137
date	2001.11.02.05.04.23;	author butler;	state Exp;
branches;
next	1.136;

1.136
date	2001.11.01.21.38.35;	author bparker;	state Exp;
branches;
next	1.135;

1.135
date	2001.10.04.20.04.21;	author rbowers;	state Exp;
branches;
next	1.134;

1.134
date	2001.10.04.19.36.09;	author rbowers;	state Exp;
branches;
next	1.133;

1.133
date	2001.10.02.19.24.31;	author jra;	state Exp;
branches;
next	1.132;

1.132
date	2001.09.28.14.54.53;	author bparker;	state Exp;
branches;
next	1.131;

1.131
date	2001.09.17.18.22.29;	author bparker;	state Exp;
branches;
next	1.130;

1.130
date	2001.09.10.22.08.00;	author bparker;	state Exp;
branches;
next	1.129;

1.129
date	2001.09.07.17.05.59;	author bparker;	state Exp;
branches;
next	1.128;

1.128
date	2001.09.05.20.36.30;	author jra;	state Exp;
branches;
next	1.127;

1.127
date	2001.09.05.19.42.35;	author jra;	state Exp;
branches;
next	1.126;

1.126
date	2001.08.31.14.38.58;	author jra;	state Exp;
branches;
next	1.125;

1.125
date	2001.08.29.13.43.58;	author jra;	state Exp;
branches;
next	1.124;

1.124
date	2001.08.29.12.15.29;	author jra;	state Exp;
branches;
next	1.123;

1.123
date	2001.08.28.20.20.36;	author jra;	state Exp;
branches;
next	1.122;

1.122
date	2001.08.28.17.02.03;	author jra;	state Exp;
branches;
next	1.121;

1.121
date	2001.08.22.15.20.59;	author jra;	state Exp;
branches;
next	1.120;

1.120
date	2001.08.14.18.13.50;	author bparker;	state Exp;
branches;
next	1.119;

1.119
date	2001.06.06.16.46.07;	author bparker;	state Exp;
branches;
next	1.118;

1.118
date	2001.06.01.19.04.11;	author bparker;	state Exp;
branches;
next	1.117;

1.117
date	2001.06.01.17.34.14;	author bparker;	state Exp;
branches;
next	1.116;

1.116
date	2001.05.30.14.10.30;	author jra;	state Exp;
branches;
next	1.115;

1.115
date	2001.05.29.16.36.21;	author jra;	state Exp;
branches;
next	1.114;

1.114
date	2001.05.17.20.05.26;	author morrison;	state Exp;
branches;
next	1.113;

1.113
date	2001.05.14.01.49.19;	author jra;	state Exp;
branches;
next	1.112;

1.112
date	2001.05.04.14.19.25;	author bparker;	state Exp;
branches;
next	1.111;

1.111
date	2001.05.02.17.11.50;	author bparker;	state Exp;
branches;
next	1.110;

1.110
date	2001.04.27.19.29.51;	author morrison;	state Exp;
branches;
next	1.109;

1.109
date	2001.04.26.22.07.32;	author bparker;	state Exp;
branches;
next	1.108;

1.108
date	2001.04.20.22.29.57;	author morrison;	state Exp;
branches;
next	1.107;

1.107
date	2001.04.20.21.34.38;	author bparker;	state Exp;
branches;
next	1.106;

1.106
date	2001.04.20.19.53.54;	author bparker;	state Exp;
branches;
next	1.105;

1.105
date	2001.04.20.13.36.32;	author bparker;	state Exp;
branches;
next	1.104;

1.104
date	2001.04.15.02.19.42;	author jra;	state Exp;
branches;
next	1.103;

1.103
date	2001.04.03.14.24.42;	author jra;	state Exp;
branches;
next	1.102;

1.102
date	2001.04.02.21.38.10;	author morrison;	state Exp;
branches;
next	1.101;

1.101
date	2001.04.02.20.06.49;	author jra;	state Exp;
branches;
next	1.100;

1.100
date	2001.04.02.13.04.52;	author jra;	state Exp;
branches;
next	1.99;

1.99
date	2001.03.31.01.57.13;	author morrison;	state Exp;
branches;
next	1.98;

1.98
date	2001.03.30.21.13.50;	author jra;	state Exp;
branches;
next	1.97;

1.97
date	2001.03.27.23.07.50;	author bparker;	state Exp;
branches;
next	1.96;

1.96
date	2001.03.23.22.05.31;	author jra;	state Exp;
branches;
next	1.95;

1.95
date	2001.03.23.21.03.20;	author bparker;	state Exp;
branches;
next	1.94;

1.94
date	2001.03.23.15.56.53;	author bparker;	state Exp;
branches;
next	1.93;

1.93
date	2001.03.22.21.58.16;	author bparker;	state Exp;
branches;
next	1.92;

1.92
date	2001.03.22.20.24.14;	author bparker;	state Exp;
branches;
next	1.91;

1.91
date	2001.03.22.19.37.39;	author jra;	state Exp;
branches;
next	1.90;

1.90
date	2001.03.21.20.07.30;	author bparker;	state Exp;
branches;
next	1.89;

1.89
date	2001.03.21.15.56.27;	author bparker;	state Exp;
branches;
next	1.88;

1.88
date	2001.03.20.16.09.07;	author jra;	state Exp;
branches;
next	1.87;

1.87
date	2001.03.19.22.19.58;	author butler;	state Exp;
branches;
next	1.86;

1.86
date	2001.03.16.19.35.45;	author jra;	state Exp;
branches;
next	1.85;

1.85
date	2001.03.16.16.24.49;	author jra;	state Exp;
branches;
next	1.84;

1.84
date	2001.03.16.14.48.19;	author jra;	state Exp;
branches;
next	1.83;

1.83
date	2001.03.01.22.17.55;	author butler;	state Exp;
branches;
next	1.82;

1.82
date	2001.02.27.19.12.41;	author bparker;	state Exp;
branches;
next	1.81;

1.81
date	2001.02.18.04.16.03;	author jra;	state Exp;
branches;
next	1.80;

1.80
date	2001.02.16.22.38.47;	author bparker;	state Exp;
branches;
next	1.79;

1.79
date	2001.01.29.18.17.15;	author jra;	state Exp;
branches;
next	1.78;

1.78
date	2001.01.29.16.17.10;	author jra;	state Exp;
branches;
next	1.77;

1.77
date	2000.11.02.03.12.09;	author mike;	state Exp;
branches;
next	1.76;

1.76
date	2000.11.02.02.55.39;	author mike;	state Exp;
branches;
next	1.75;

1.75
date	2000.11.02.02.09.43;	author mike;	state Exp;
branches;
next	1.74;

1.74
date	2000.11.01.20.37.17;	author mike;	state Exp;
branches;
next	1.73;

1.73
date	2000.10.20.20.32.12;	author jra;	state Exp;
branches;
next	1.72;

1.72
date	2000.10.19.16.05.21;	author bparker;	state Exp;
branches;
next	1.71;

1.71
date	2000.10.17.21.30.29;	author mike;	state Exp;
branches;
next	1.70;

1.70
date	2000.09.09.04.30.48;	author mike;	state Exp;
branches;
next	1.69;

1.69
date	2000.09.08.05.54.43;	author mike;	state Exp;
branches;
next	1.68;

1.68
date	2000.08.31.03.56.50;	author mike;	state Exp;
branches;
next	1.67;

1.67
date	2000.08.24.21.17.12;	author mike;	state Exp;
branches;
next	1.66;

1.66
date	2000.08.22.06.49.25;	author mike;	state Exp;
branches;
next	1.65;

1.65
date	2000.08.21.02.02.34;	author butler;	state Exp;
branches;
next	1.64;

1.64
date	2000.08.10.23.57.26;	author mike;	state Exp;
branches;
next	1.63;

1.63
date	2000.07.20.14.01.57;	author jra;	state Exp;
branches;
next	1.62;

1.62
date	2000.07.13.01.39.27;	author mike;	state Exp;
branches;
next	1.61;

1.61
date	2000.07.11.23.57.45;	author mike;	state Exp;
branches;
next	1.60;

1.60
date	2000.07.08.02.23.06;	author mike;	state Exp;
branches;
next	1.59;

1.59
date	2000.06.30.20.49.20;	author mike;	state Exp;
branches;
next	1.58;

1.58
date	2000.06.30.18.11.12;	author mike;	state Exp;
branches;
next	1.57;

1.57
date	2000.06.29.20.23.36;	author mike;	state Exp;
branches;
next	1.56;

1.56
date	2000.06.29.18.36.55;	author mike;	state Exp;
branches;
next	1.55;

1.55
date	2000.06.29.18.20.56;	author mike;	state Exp;
branches;
next	1.54;

1.54
date	2000.06.29.14.33.31;	author mike;	state Exp;
branches;
next	1.53;

1.53
date	2000.05.26.14.32.20;	author bparker;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2000.05.19.18.51.07;	author bparker;	state Exp;
branches;
next	1.51;

1.51
date	2000.05.18.21.46.01;	author mike;	state Exp;
branches;
next	1.50;

1.50
date	2000.04.12.17.56.51;	author mike;	state Exp;
branches;
next	1.49;

1.49
date	2000.04.12.01.11.50;	author mike;	state Exp;
branches;
next	1.48;

1.48
date	2000.02.29.19.55.19;	author bparker;	state Exp;
branches;
next	1.47;

1.47
date	2000.02.25.22.06.29;	author bparker;	state Exp;
branches;
next	1.46;

1.46
date	2000.02.22.21.39.18;	author bparker;	state Exp;
branches;
next	1.45;

1.45
date	2000.02.18.21.06.30;	author bparker;	state Exp;
branches;
next	1.44;

1.44
date	2000.02.02.20.05.57;	author mike;	state Exp;
branches;
next	1.43;

1.43
date	2000.01.31.15.01.28;	author jra;	state Exp;
branches;
next	1.42;

1.42
date	2000.01.07.04.21.06;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	2000.01.07.03.33.44;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	2000.01.07.03.19.40;	author mike;	state Exp;
branches;
next	1.39;

1.39
date	2000.01.06.23.18.23;	author bparker;	state Exp;
branches;
next	1.38;

1.38
date	2000.01.06.19.26.39;	author bparker;	state Exp;
branches;
next	1.37;

1.37
date	2000.01.06.18.40.11;	author bparker;	state Exp;
branches;
next	1.36;

1.36
date	2000.01.06.16.16.31;	author bparker;	state Exp;
branches;
next	1.35;

1.35
date	2000.01.05.22.41.32;	author bparker;	state Exp;
branches;
next	1.34;

1.34
date	2000.01.05.21.39.55;	author bparker;	state Exp;
branches;
next	1.33;

1.33
date	2000.01.05.16.25.56;	author bparker;	state Exp;
branches;
next	1.32;

1.32
date	2000.01.05.15.58.25;	author bparker;	state Exp;
branches;
next	1.31;

1.31
date	2000.01.04.15.34.37;	author bparker;	state Exp;
branches;
next	1.30;

1.30
date	2000.01.03.21.42.48;	author bparker;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.03.15.27.17;	author bparker;	state Exp;
branches;
next	1.28;

1.28
date	99.12.30.23.39.49;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	99.12.30.23.07.28;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	99.12.30.22.55.09;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	99.12.30.22.40.30;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	99.12.30.22.00.24;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	99.12.30.21.03.36;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	99.12.30.20.40.37;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	99.12.30.19.40.35;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	99.12.30.05.26.20;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	99.12.30.02.58.40;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	99.12.29.23.23.12;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	99.12.29.22.38.16;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	99.12.29.21.47.20;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	99.12.29.21.25.13;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	99.12.29.21.13.49;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	99.12.29.21.09.42;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	99.12.29.16.28.19;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	99.12.29.15.31.29;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	99.12.28.21.36.37;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	99.12.28.20.51.21;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	99.12.28.20.29.50;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	99.12.28.18.57.10;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	99.12.28.18.13.55;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	99.12.28.15.42.22;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	99.12.27.20.46.09;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	99.12.22.02.24.08;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	99.12.21.17.11.33;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	99.12.20.20.42.16;	author bparker;	state Exp;
branches;
next	;

1.53.2.1
date	2000.10.19.16.05.54;	author bparker;	state Exp;
branches;
next	1.53.2.2;

1.53.2.2
date	2000.11.02.13.35.31;	author jra;	state Exp;
branches;
next	1.53.2.3;

1.53.2.3
date	2001.02.05.18.20.45;	author bparker;	state Exp;
branches;
next	1.53.2.4;

1.53.2.4
date	2001.02.05.21.05.16;	author bparker;	state Exp;
branches;
next	1.53.2.5;

1.53.2.5
date	2001.02.27.16.14.21;	author bparker;	state Exp;
branches;
next	;

1.168.2.1
date	2002.09.19.18.01.48;	author morrison;	state Exp;
branches;
next	1.168.2.2;

1.168.2.2
date	2003.02.12.01.13.13;	author morrison;	state Exp;
branches;
next	1.168.2.3;

1.168.2.3
date	2004.03.17.21.19.01;	author morrison;	state Exp;
branches;
next	1.168.2.4;

1.168.2.4
date	2004.04.02.16.09.01;	author morrison;	state Exp;
branches;
next	;

1.168.4.1
date	2004.03.11.23.43.47;	author morrison;	state Exp;
branches;
next	;

1.178.4.1
date	2003.12.03.16.24.08;	author erikg;	state Exp;
branches;
next	1.178.4.2;

1.178.4.2
date	2004.02.12.18.37.48;	author erikg;	state Exp;
branches;
next	1.178.4.3;

1.178.4.3
date	2004.03.15.14.07.30;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.185
log
@moved to src/
@
text
@/*
 *				W D B _ O B J . C
 *
 *  A database object contains the attributes and
 *  methods for controlling a BRLCAD database.
 * 
 *  Authors -
 *	Michael John Muuss
 *      Glenn Durfee
 *	Robert G. Parker
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 2000-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/wdb_obj.c,v 1.184 2004/05/10 15:30:47 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <ctype.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#if unix
# include <fcntl.h>
# include <sys/errno.h>
#endif
#include "tcl.h"
#include "machine.h"
#include "externs.h"
#include "cmd.h"		/* this includes bu.h */
#include "vmath.h"
#include "bn.h"
#include "db.h"
#include "mater.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"

#include "./debug.h"

/* defined in mater.c */
extern void rt_insert_color( struct mater *newp );

#define WDB_TCL_READ_ERR { \
	Tcl_AppendResult(interp, "Database read error, aborting.\n", (char *)NULL); \
	}

#define WDB_TCL_READ_ERR_return { \
	WDB_TCL_READ_ERR; \
	return TCL_ERROR; }

#define WDB_TCL_WRITE_ERR { \
	Tcl_AppendResult(interp, "Database write error, aborting.\n", (char *)NULL); \
	WDB_TCL_ERROR_RECOVERY_SUGGESTION; }

#define WDB_TCL_WRITE_ERR_return { \
	WDB_TCL_WRITE_ERR; \
	return TCL_ERROR; }

#define WDB_TCL_ALLOC_ERR { \
	Tcl_AppendResult(interp, "\
An error has occured while adding a new object to the database.\n", (char *)NULL); \
	WDB_TCL_ERROR_RECOVERY_SUGGESTION; }

#define WDB_TCL_ALLOC_ERR_return { \
	WDB_TCL_ALLOC_ERR; \
	return TCL_ERROR; }

#define WDB_TCL_DELETE_ERR(_name){ \
	Tcl_AppendResult(interp, "An error has occurred while deleting '", _name,\
	"' from the database.\n", (char *)NULL);\
	WDB_TCL_ERROR_RECOVERY_SUGGESTION; }

#define WDB_TCL_DELETE_ERR_return(_name){  \
	WDB_TCL_DELETE_ERR(_name); \
	return TCL_ERROR;  }

/* A verbose message to attempt to soothe and advise the user */
#define	WDB_TCL_ERROR_RECOVERY_SUGGESTION\
        Tcl_AppendResult(interp, "\
The in-memory table of contents may not match the status of the on-disk\n\
database.  The on-disk database should still be intact.  For safety,\n\
you should exit now, and resolve the I/O problem, before continuing.\n", (char *)NULL)

#define WDB_READ_ERR { \
	bu_log("Database read error, aborting\n"); }

#define WDB_READ_ERR_return { \
	WDB_READ_ERR; \
	return;  }

#define WDB_WRITE_ERR { \
	bu_log("Database write error, aborting.\n"); \
	WDB_ERROR_RECOVERY_SUGGESTION; }	

#define WDB_WRITE_ERR_return { \
	WDB_WRITE_ERR; \
	return;  }

/* For errors from db_diradd() or db_alloc() */
#define WDB_ALLOC_ERR { \
	bu_log("\nAn error has occured while adding a new object to the database.\n"); \
	WDB_ERROR_RECOVERY_SUGGESTION; }

#define WDB_ALLOC_ERR_return { \
	WDB_ALLOC_ERR; \
	return;  }

/* A verbose message to attempt to soothe and advise the user */
#define	WDB_ERROR_RECOVERY_SUGGESTION\
        bu_log(WDB_ERROR_RECOVERY_MESSAGE)

#define WDB_ERROR_RECOVERY_MESSAGE "\
The in-memory table of contents may not match the status of the on-disk\n\
database.  The on-disk database should still be intact.  For safety,\n\
you should exit now, and resolve the I/O problem, before continuing.\n"

#define	WDB_TCL_CHECK_READ_ONLY \
	if (wdbp->dbip->dbi_read_only) {\
		Tcl_AppendResult(interp, "Sorry, this database is READ-ONLY\n", (char *)NULL); \
		return TCL_ERROR; \
	}

#define WDB_MAX_LEVELS 12
#define WDB_CPEVAL	0
#define WDB_LISTPATH	1
#define WDB_LISTEVAL	2

struct wdb_trace_data {
	Tcl_Interp		*wtd_interp;
	struct db_i		*wtd_dbip;
	struct directory	*wtd_path[WDB_MAX_LEVELS];
	struct directory	*wtd_obj[WDB_MAX_LEVELS];
	mat_t			wtd_xform;
	int			wtd_objpos;
	int			wtd_prflag;
	int			wtd_flag;
};

struct wdb_killtree_data {
  Tcl_Interp	*interp;
  int		notify;
};

/* defined in libbn/bn_tcl.c */
BU_EXTERN(void		bn_tcl_mat_print, (Tcl_Interp *interp, const char *title, const mat_t m));

/* from librt/tcl.c */
extern int rt_tcl_rt(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv);
extern int rt_tcl_import_from_path(Tcl_Interp *interp, struct rt_db_internal *ip, const char *path, struct rt_wdb *wdb);
extern void rt_generic_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter);

/* from librt/wdb_comb_std.c */
extern int wdb_comb_std_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

/* from librt/g_bot.c */
extern int rt_bot_sort_faces( struct rt_bot_internal *bot, int tris_per_piece );
extern int rt_bot_decimate( struct rt_bot_internal *bot, fastf_t max_chord_error, fastf_t max_normal_error, fastf_t min_edge_length );

/* from db5_scan.c */
HIDDEN int db5_scan(struct db_i *dbip, void (*handler) (struct db_i *, const struct db5_raw_internal *, long int, genptr_t), genptr_t client_data);

int wdb_init_obj(Tcl_Interp *interp, struct rt_wdb *wdbp, char *oname);
int wdb_get_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int wdb_attr_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int wdb_pathsum_cmd(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv);

static int wdb_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
#if 0
static int wdb_close_tcl();
#endif
static int wdb_decode_dbip(Tcl_Interp *interp, char *dbip_string, struct db_i **dbipp);
static struct db_i *wdb_prep_dbip(Tcl_Interp *interp, char *filename);

static int wdb_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_match_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_put_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_adjust_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_form_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_tops_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_rt_gettrees_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_shells_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_dump_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_dbip_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_ls_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_list_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_pathsum_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_expand_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_kill_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_killall_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_killtree_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static void wdb_killtree_callback(struct db_i *dbip, register struct directory *dp, genptr_t *ptr);
static int wdb_copy_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_move_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_move_all_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_concat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_copyeval_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_dup_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_group_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_remove_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_region_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_comb_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_facetize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_find_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_which_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_title_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_track_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_tree_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_color_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_prcolor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_tol_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_push_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_whatid_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_keep_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_cat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_instance_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_reopen_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_make_bb_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_make_name_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_units_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_hide_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_unhide_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_xpush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_smooth_bot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_showmats_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_nmg_collapse_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_nmg_simplify_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_summary_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_pathlist_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_lt_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_version_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_binary_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_bot_face_sort_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_bot_decimate_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

static void wdb_deleteProc(ClientData clientData);
static void wdb_deleteProc_rt(ClientData clientData);

static void wdb_do_trace(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t user_ptr1, genptr_t user_ptr2, genptr_t user_ptr3);
static void wdb_trace(register struct directory *dp, int pathpos, const fastf_t *old_xlate, struct wdb_trace_data *wtdp);

int wdb_cmpdirname(const genptr_t a, const genptr_t b);
void wdb_vls_col_item(struct bu_vls *str, register char *cp, int *ccp, int *clp);
void wdb_vls_col_eol(struct bu_vls *str, int *ccp, int *clp);
void wdb_vls_col_pr4v(struct bu_vls *vls, struct directory **list_of_names, int num_in_list, int no_decorate);
void wdb_vls_long_dpp(struct bu_vls *vls, struct directory **list_of_names, int num_in_list, int aflag, int cflag, int rflag, int sflag);
void wdb_vls_line_dpp(struct bu_vls *vls, struct directory **list_of_names, int num_in_list, int aflag, int cflag, int rflag, int sflag);
void wdb_do_list(struct db_i *dbip, Tcl_Interp *interp, struct bu_vls *outstrp, register struct directory *dp, int verbose);
struct directory ** wdb_getspace(struct db_i *dbip, register int num_entries);
struct directory *wdb_combadd(Tcl_Interp *interp, struct db_i *dbip, register struct directory *objp, char *combname, int region_flag, int relation, int ident, int air, struct rt_wdb *wdbp);
void wdb_identitize(struct directory *dp, struct db_i *dbip, Tcl_Interp *interp);
static void wdb_dir_summary(struct db_i *dbip, Tcl_Interp *interp, int flag);
static struct directory ** wdb_dir_getspace(struct db_i *dbip, register int num_entries);
static union tree *wdb_pathlist_leaf_func(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data);


static struct bu_cmdtab wdb_cmds[] = {
	{"adjust",	wdb_adjust_tcl},
	{"attr",	wdb_attr_tcl},
	{"binary",	wdb_binary_tcl},
	{"bot_face_sort", wdb_bot_face_sort_tcl},
	{"bot_decimate", wdb_bot_decimate_tcl},
	{"c",		wdb_comb_std_tcl},
	{"cat",		wdb_cat_tcl},
#if 0
	{"close",	wdb_close_tcl},
#endif
	{"color",	wdb_color_tcl},
	{"comb",	wdb_comb_tcl},
	{"concat",	wdb_concat_tcl},
	{"copyeval",	wdb_copyeval_tcl},
	{"cp",		wdb_copy_tcl},
	{"dbip",	wdb_dbip_tcl},
	{"dump",	wdb_dump_tcl},
	{"dup",		wdb_dup_tcl},
	{"expand",	wdb_expand_tcl},
	{"facetize",	wdb_facetize_tcl},
	{"find",	wdb_find_tcl},
	{"form",	wdb_form_tcl},
	{"g",		wdb_group_tcl},
	{"get",		wdb_get_tcl},
	{"hide",	wdb_hide_tcl},
	{"i",		wdb_instance_tcl},
	{"keep",	wdb_keep_tcl},
	{"kill",	wdb_kill_tcl},
	{"killall",	wdb_killall_tcl},
	{"killtree",	wdb_killtree_tcl},
	{"l",		wdb_list_tcl},
	{"listeval",	wdb_pathsum_tcl},
	{"ls",		wdb_ls_tcl},
	{"lt",		wdb_lt_tcl},
	{"make_bb",	wdb_make_bb_tcl},
	{"make_name",	wdb_make_name_tcl},
	{"match",	wdb_match_tcl},
	{"mv",		wdb_move_tcl},
	{"mvall",	wdb_move_all_tcl},
	{"nmg_collapse",	wdb_nmg_collapse_tcl},
	{"nmg_simplify",	wdb_nmg_simplify_tcl},
	{"observer",	wdb_observer_tcl},
	{"open",	wdb_reopen_tcl},
	{"pathlist",	wdb_pathlist_tcl},
	{"paths",	wdb_pathsum_tcl},
	{"prcolor",	wdb_prcolor_tcl},
	{"push",	wdb_push_tcl},
	{"put",		wdb_put_tcl},
	{"r",		wdb_region_tcl},
	{"rm",		wdb_remove_tcl},
	{"rt_gettrees",	wdb_rt_gettrees_tcl},
	{"shells",	wdb_shells_tcl},
	{"showmats",	wdb_showmats_tcl},
	{"smooth_bot",	wdb_smooth_bot_tcl},
	{"summary",	wdb_summary_tcl},
	{"title",	wdb_title_tcl},
	{"tol",		wdb_tol_tcl},
	{"tops",	wdb_tops_tcl},
	{"track",	wdb_track_tcl},
	{"tree",	wdb_tree_tcl},
	{"unhide",	wdb_unhide_tcl},
	{"units",	wdb_units_tcl},
	{"version",	wdb_version_tcl},
	{"whatid",	wdb_whatid_tcl},
	{"whichair",	wdb_which_tcl},
	{"whichid",	wdb_which_tcl},
	{"xpush",	wdb_xpush_tcl},
#if 0
	/* Commands to be added */
	{"comb_color",	wdb_comb_color_tcl},
	{"copymat",	wdb_copymat_tcl},
	{"getmat",	wdb_getmat_tcl},
	{"putmat",	wdb_putmat_tcl},
	{"which_shader",	wdb_which_shader_tcl},
	{"rcodes",	wdb_rcodes_tcl},
	{"wcodes",	wdb_wcodes_tcl},
	{"rmater",	wdb_rmater_tcl},
	{"wmater",	wdb_wmater_tcl},
	{"analyze",	wdb_analyze_tcl},
	{"inside",	wdb_inside_tcl},
#endif
	{(char *)NULL,	(int (*)())0 }
};

int
Wdb_Init(Tcl_Interp *interp)
{
	(void)Tcl_CreateCommand(interp, "wdb_open", wdb_open_tcl,
				(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

	return TCL_OK;
}

/*
 *			W D B _ C M D
 *
 * Generic interface for database commands.
 * Usage:
 *        procname cmd ?args?
 *
 * Returns: result of wdb command.
 */
static int
wdb_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	return bu_cmd(clientData, interp, argc, argv, wdb_cmds, 1);
}

/*
 * Called by Tcl when the object is destroyed.
 */
static void
wdb_deleteProc(ClientData clientData)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	/* free observers */
	bu_observer_free(&wdbp->wdb_observers);

	/* notify drawable geometry objects of the impending close */
	dgo_impending_wdb_close(wdbp, wdbp->wdb_interp);

	RT_CK_WDB(wdbp);
	BU_LIST_DEQUEUE(&wdbp->l);
	bu_vls_free(&wdbp->wdb_name);
	wdb_close(wdbp);
}

/*
 * Create an command/object named "oname" in "interp"
 * using "wdbp" as its state.
 */
int
wdb_init_obj(Tcl_Interp		*interp,
	     struct rt_wdb	*wdbp,	/* pointer to object */
	     char		*oname)	/* object name */
{
	if (wdbp == RT_WDB_NULL) {
		Tcl_AppendResult(interp, "wdb_open ", oname, " failed", NULL);
		return TCL_ERROR;
	}

	/* initialize rt_wdb */
	bu_vls_init(&wdbp->wdb_name);
	bu_vls_strcpy(&wdbp->wdb_name, oname);

#if 0
	/*XXXX already initialize by wdb_dbopen */
	/* initilize tolerance structures */
	wdbp->wdb_ttol.magic = RT_TESS_TOL_MAGIC;
	wdbp->wdb_ttol.abs = 0.0;		/* disabled */
	wdbp->wdb_ttol.rel = 0.01;
	wdbp->wdb_ttol.norm = 0.0;		/* disabled */

	wdbp->wdb_tol.magic = BN_TOL_MAGIC;
	wdbp->wdb_tol.dist = 0.005;
	wdbp->wdb_tol.dist_sq = wdbp->wdb_tol.dist * wdbp->wdb_tol.dist;
	wdbp->wdb_tol.perp = 1e-6;
	wdbp->wdb_tol.para = 1 - wdbp->wdb_tol.perp;
#endif

	/* initialize tree state */
	wdbp->wdb_initial_tree_state = rt_initial_tree_state;  /* struct copy */
	wdbp->wdb_initial_tree_state.ts_ttol = &wdbp->wdb_ttol;
	wdbp->wdb_initial_tree_state.ts_tol = &wdbp->wdb_tol;

	/* default region ident codes */
	wdbp->wdb_item_default = 1000;
	wdbp->wdb_air_default = 0;
	wdbp->wdb_mat_default = 1;
	wdbp->wdb_los_default = 100;

	/* resource structure */
	wdbp->wdb_resp = &rt_uniresource;

	BU_LIST_INIT(&wdbp->wdb_observers.l);
	wdbp->wdb_interp = interp;

	/* append to list of rt_wdb's */
	BU_LIST_APPEND(&rt_g.rtg_headwdb.l,&wdbp->l);

	/* Instantiate the newprocname, with clientData of wdbp */
	/* Beware, returns a "token", not TCL_OK. */
	(void)Tcl_CreateCommand(interp, oname, (Tcl_CmdProc *)wdb_cmd,
				(ClientData)wdbp, wdb_deleteProc);

	/* Return new function name as result */
	Tcl_AppendResult(interp, oname, (char *)NULL);
	
	return TCL_OK;
}

/*
 *			W D B _ O P E N _ T C L
 *
 *  A TCL interface to wdb_fopen() and wdb_dbopen().
 *
 *  Implicit return -
 *	Creates a new TCL proc which responds to get/put/etc. arguments
 *	when invoked.  clientData of that proc will be rt_wdb pointer
 *	for this instance of the database.
 *	Easily allows keeping track of multiple databases.
 *
 *  Explicit return -
 *	wdb pointer, for more traditional C-style interfacing.
 *
 *  Example -
 *	set wdbp [wdb_open .inmem inmem $dbip]
 *	.inmem get box.s
 *	.inmem close
 *
 *	wdb_open db file "bob.g"
 *	db get white.r
 *	db close
 */
static int
wdb_open_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct rt_wdb *wdbp;

	if (argc == 1) {
		/* get list of database objects */
		for (BU_LIST_FOR(wdbp, rt_wdb, &rt_g.rtg_headwdb.l))
			Tcl_AppendResult(interp, bu_vls_addr(&wdbp->wdb_name), " ", (char *)NULL);

		return TCL_OK;
	}

	if (argc < 3 || 4 < argc) {
#if 0
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib wdb_open");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
#else
		Tcl_AppendResult(interp, "\
Usage: wdb_open\n\
       wdb_open newprocname file filename\n\
       wdb_open newprocname disk $dbip\n\
       wdb_open newprocname disk_append $dbip\n\
       wdb_open newprocname inmem $dbip\n\
       wdb_open newprocname inmem_append $dbip\n\
       wdb_open newprocname db filename\n\
       wdb_open newprocname filename\n",
				 NULL);
		return TCL_ERROR;
#endif
	}

	/* Delete previous proc (if any) to release all that memory, first */
	(void)Tcl_DeleteCommand(interp, argv[1]);

	if (argc == 3 || strcmp(argv[2], "db") == 0) {
		struct db_i	*dbip;
		int i;

		if (argc == 3)
			i = 2;
		else
			i = 3;

		if ((dbip = wdb_prep_dbip(interp, argv[i])) == DBI_NULL)
			return TCL_ERROR;
		RT_CK_DBI_TCL(interp,dbip);

		wdbp = wdb_dbopen(dbip, RT_WDB_TYPE_DB_DISK);
	} else if (strcmp(argv[2], "file") == 0) {
		wdbp = wdb_fopen( argv[3] );
	} else {
		struct db_i	*dbip;

		if (wdb_decode_dbip(interp, argv[3], &dbip) != TCL_OK)
			return TCL_ERROR;

		if (strcmp( argv[2], "disk" ) == 0)
			wdbp = wdb_dbopen(dbip, RT_WDB_TYPE_DB_DISK);
		else if (strcmp(argv[2], "disk_append") == 0)
			wdbp = wdb_dbopen(dbip, RT_WDB_TYPE_DB_DISK_APPEND_ONLY);
		else if (strcmp( argv[2], "inmem" ) == 0)
			wdbp = wdb_dbopen(dbip, RT_WDB_TYPE_DB_INMEM);
		else if (strcmp( argv[2], "inmem_append" ) == 0)
			wdbp = wdb_dbopen(dbip, RT_WDB_TYPE_DB_INMEM_APPEND_ONLY);
		else {
			Tcl_AppendResult(interp, "wdb_open ", argv[2],
					 " target type not recognized", NULL);
			return TCL_ERROR;
		}
	}

	return wdb_init_obj(interp, wdbp, argv[1]);
}

int
wdb_decode_dbip(Tcl_Interp *interp, char *dbip_string, struct db_i **dbipp)
{

	*dbipp = (struct db_i *)atol(dbip_string);

	/* Could core dump */
	RT_CK_DBI_TCL(interp,*dbipp);

	return TCL_OK;
}

/*
 * Open/Create the database and build the in memory directory.
 */
struct db_i *
wdb_prep_dbip(Tcl_Interp *interp, char *filename)
{
	struct db_i *dbip;

	/* open database */
	if (((dbip = db_open(filename, "r+w")) == DBI_NULL) &&
	    ((dbip = db_open(filename, "r"  )) == DBI_NULL)) {
		/*
		 * Check to see if we can access the database
		 */
#if unix
		if (access(filename, R_OK|W_OK) != 0 && errno != ENOENT) {
			perror(filename);
			return DBI_NULL;
		}
#endif
#if WIN32
#endif

		/* db_create does a db_dirbuild */
		if ((dbip = db_create(filename, 5)) == DBI_NULL) {
			Tcl_AppendResult(interp,
					 "wdb_open: failed to create ", filename,
					 (char *)NULL);
			if (dbip == DBI_NULL)
				Tcl_AppendResult(interp,
						 "opendb: no database is currently opened!", \
						 (char *)NULL);

			return DBI_NULL;
		}
	} else
		/* --- Scan geometry database and build in-memory directory --- */
		db_dirbuild(dbip);


	return dbip;
}

/****************** Database Object Methods ********************/
#if 0
int
wdb_close_cmd(struct rt_wdb	*wdbp,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{
	struct bu_vls vls;

	if (argc != 1) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib wdb_close");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/*
	 * Among other things, this will call wdb_deleteProc.
	 * Note - wdb_deleteProc is being passed clientdata.
	 *        It ought to get interp as well.
	 */
	Tcl_DeleteCommand(interp, bu_vls_addr(&wdbp->wdb_name));

	return TCL_OK;
}

/*
 * Close a BRLCAD database object.
 *
 * USAGE:
 *	  procname close
 */
static int
wdb_close_tcl(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_close_cmd(wdbp, interp, argc-1, argv+1);
}
#endif

int
wdb_reopen_cmd(struct rt_wdb	*wdbp,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	struct db_i *dbip;
	struct bu_vls vls;

	/* get database filename */
	if (argc == 1) {
		Tcl_AppendResult(interp, wdbp->dbip->dbi_filename, (char *)NULL);
		return TCL_OK;
	}

	/* set database filename */
	if (argc == 2) {
		if ((dbip = wdb_prep_dbip(interp, argv[1])) == DBI_NULL) {
			return TCL_ERROR;
		}

		/* XXXnotify observers */
		/* notify drawable geometry objects associated with this database */
		dgo_zapall(wdbp, interp);

		/* close current database */
		db_close(wdbp->dbip);

		wdbp->dbip = dbip;

		Tcl_AppendResult(interp, wdbp->dbip->dbi_filename, (char *)NULL);
		return TCL_OK;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias wdb_reopen %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 *
 * Usage:
 *        procname open [filename]
 */
static int
wdb_reopen_tcl(ClientData	clientData,
	       Tcl_Interp	*interp,
	       int		argc,
	       char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_reopen_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_match_cmd(struct rt_wdb	*wdbp,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{
	struct bu_vls	matches;

	RT_CK_WDB_TCL(interp,wdbp);
	
	/* Verify that this wdb supports lookup operations
	   (non-null dbip) */
	if (wdbp->dbip == 0) {
		Tcl_AppendResult( interp, "this database does not support lookup operations" );
		return TCL_ERROR;
	}

	bu_vls_init(&matches);
	for (++argv; *argv != NULL; ++argv) {
		if (db_regexp_match_all(&matches, wdbp->dbip, *argv) > 0)
			bu_vls_strcat(&matches, " ");
	}
	bu_vls_trimspace(&matches);
	Tcl_AppendResult(interp, bu_vls_addr(&matches), (char *)NULL);
	bu_vls_free(&matches);
	return TCL_OK;
}

/*
 *			W D B _ M A T C H _ T C L
 *
 * Returns (in interp->result) a list (possibly empty) of all matches to
 * the (possibly wildcard-containing) arguments given.
 * Does *NOT* return tokens that do not match anything, unlike the
 * "expand" command.
 */

static int
wdb_match_tcl(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_match_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_get_cmd(struct rt_wdb	*wdbp,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv)
{
	int			status;
	struct rt_db_internal	intern;

	if (argc < 2 || argc > 3) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_get %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* Verify that this wdb supports lookup operations
	   (non-null dbip) */
	if (wdbp->dbip == 0) {
		Tcl_AppendResult(interp,
				 "db does not support lookup operations",
				 (char *)NULL);
		return TCL_ERROR;
	}

	if (rt_tcl_import_from_path(interp, &intern, argv[1], wdbp) == TCL_ERROR)
		return TCL_ERROR;

	status = intern.idb_meth->ft_tclget(interp, &intern, argv[2]);
	rt_db_free_internal(&intern, &rt_uniresource);
	return status;
}

/*
 *			W D B _ G E T_ T C L
 *
 **
 ** For use with Tcl, this routine accepts as its first argument the name
 ** of an object in the database.  If only one argument is given, this routine
 ** then fills the result string with the (minimal) attributes of the item.
 ** If a second, optional, argument is provided, this function looks up the
 ** property with that name of the item given, and returns it as the result
 ** string.
 **/
/* NOTE: This is called directly by gdiff/g_diff.c */

int
wdb_get_tcl(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_get_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_put_cmd(struct rt_wdb	*wdbp,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv)
{
	struct rt_db_internal			intern;
	register const struct rt_functab	*ftp;
	int					i;
	char				       *name;
	char				        type[16];

	if (argc < 3) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_put %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	name = argv[1];
    
	/* Verify that this wdb supports lookup operations (non-null dbip).
	 * stdout/file wdb objects don't, but can still be written to.
	 * If not, just skip the lookup test and write the object
	 */
	if (wdbp->dbip && db_lookup(wdbp->dbip, argv[1], LOOKUP_QUIET) != DIR_NULL ) {
		Tcl_AppendResult(interp, argv[1], " already exists",
				 (char *)NULL);
		return TCL_ERROR;
	}

	RT_INIT_DB_INTERNAL(&intern);

	for (i = 0; argv[2][i] != 0 && i < 16; i++) {
		type[i] = isupper(argv[2][i]) ? tolower(argv[2][i]) :
			argv[2][i];
	}
	type[i] = 0;

	ftp = rt_get_functab_by_label(type);
	if (ftp == NULL) {
		Tcl_AppendResult(interp, type,
				 " is an unknown object type.",
				 (char *)NULL);
		return TCL_ERROR;
	}

	RT_CK_FUNCTAB(ftp);

	if (ftp->ft_make) {
	    if (ftp->ft_make == rt_nul_make) {
		Tcl_AppendResult(interp, "wdb_put_internal(", argv[1],
				 ") cannot put a ", type, (char *)NULL);

		return TCL_ERROR;
	    }
	    ftp->ft_make(ftp, &intern, 0.0);
	} else {
	    rt_generic_make(ftp, &intern, 0.0);
	}

	if (ftp->ft_tcladjust(interp, &intern, argc-3, argv+3, &rt_uniresource) == TCL_ERROR) {
		rt_db_free_internal(&intern, &rt_uniresource);
		return TCL_ERROR;
	}

	if (wdb_put_internal(wdbp, name, &intern, 1.0) < 0)  {
		Tcl_AppendResult(interp, "wdb_put_internal(", argv[1],
				 ") failure", (char *)NULL);
		rt_db_free_internal(&intern, &rt_uniresource);
		return TCL_ERROR;
	}

	rt_db_free_internal( &intern, &rt_uniresource );
	return TCL_OK;
}

/*
 *			W D B _ P U T _ T C L
 **
 ** Creates an object and stuffs it into the databse.
 ** All arguments must be specified.  Object cannot already exist.
 **/

static int
wdb_put_tcl(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_put_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_adjust_cmd(struct rt_wdb	*wdbp,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	register struct directory	*dp;
	int				 status;
	char				*name;
	struct rt_db_internal		 intern;

	if (argc < 4) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_adjust %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
	name = argv[1];

	/* Verify that this wdb supports lookup operations (non-null dbip) */
	RT_CK_DBI_TCL(interp,wdbp->dbip);

	dp = db_lookup(wdbp->dbip, name, LOOKUP_QUIET);
	if (dp == DIR_NULL) {
		Tcl_AppendResult(interp, name, ": not found",
				 (char *)NULL );
		return TCL_ERROR;
	}

	status = rt_db_get_internal(&intern, dp, wdbp->dbip, (matp_t)NULL, &rt_uniresource);
	if (status < 0) {
		Tcl_AppendResult(interp, "rt_db_get_internal(", name,
				 ") failure", (char *)NULL );
		return TCL_ERROR;
	}
	RT_CK_DB_INTERNAL(&intern);

	/* Find out what type of object we are dealing with and tweak it. */
	RT_CK_FUNCTAB(intern.idb_meth);

	status = intern.idb_meth->ft_tcladjust(interp, &intern, argc-2, argv+2, &rt_uniresource);
	if( status == TCL_OK && wdb_put_internal(wdbp, name, &intern, 1.0) < 0)  {
		Tcl_AppendResult(interp, "wdb_export(", name,
				 ") failure", (char *)NULL);
		rt_db_free_internal(&intern, &rt_uniresource);
		return TCL_ERROR;
	}

	/* notify observers */
	bu_observer_notify(interp, &wdbp->wdb_observers, bu_vls_addr(&wdbp->wdb_name));

	return status;
}

/*
 *			W D B _ A D J U S T _ T C L
 *
 **
 ** For use with Tcl, this routine accepts as its first argument an item in
 ** the database; as its remaining arguments it takes the properties that
 ** need to be changed and their values.
 *
 *  Example of adjust operation on a solid:
 *	.inmem adjust LIGHT V { -46 -13 5 }
 *
 *  Example of adjust operation on a combination:
 *	.inmem adjust light.r rgb { 255 255 255 }
 */

static int
wdb_adjust_tcl(ClientData	clientData,
	       Tcl_Interp	*interp,
	       int		argc,
	       char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_adjust_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_form_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	const struct rt_functab		*ftp;

	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_form %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if ((ftp = rt_get_functab_by_label(argv[1])) == NULL) {
		Tcl_AppendResult(interp, "There is no geometric object type \"",
				 argv[1], "\".", (char *)NULL);
		return TCL_ERROR;
	}
	return ftp->ft_tclform(ftp, interp);
}

/*
 *			W D B _ F O R M _ T C L
 */
static int
wdb_form_tcl(ClientData clientData,
	     Tcl_Interp *interp,
	     int	argc,
	     char	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_form_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_tops_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	register struct directory	*dp;
	register int			i;
	struct directory		**dirp;
	struct directory		**dirp0 = (struct directory **)NULL;
	struct bu_vls			vls;
	int				c;
	int				gflag = 0;
	int				uflag = 0;
	int				no_decorate = 0;

	RT_CK_WDB_TCL(interp, wdbp);
	RT_CK_DBI_TCL(interp, wdbp->dbip);

	/* process any options */
	bu_optind = 1;	/* re-init bu_getopt() */
	while ((c = bu_getopt(argc, argv, "gun")) != EOF) {
		switch (c) {
		case 'g':
			gflag = 1;
			break;
		case 'u':
			uflag = 1;
			break;
		case 'n':
			no_decorate = 1;
			break;
		default:
			break;
		}
	}

	argc -= (bu_optind - 1);
	argv += (bu_optind - 1);

	/* Can this be executed only sometimes?
	   Perhaps a "dirty bit" on the database? */
	db_update_nref(wdbp->dbip, &rt_uniresource);

	/*
	 * Find number of possible entries and allocate memory
	 */
	dirp = wdb_dir_getspace(wdbp->dbip, 0);
	dirp0 = dirp;

	if (wdbp->dbip->dbi_version < 5) {
		for (i = 0; i < RT_DBNHASH; i++)
			for (dp = wdbp->dbip->dbi_Head[i];
			     dp != DIR_NULL;
			     dp = dp->d_forw)  {
				if (dp->d_nref == 0)
					*dirp++ = dp;
			}
	} else {
		for (i = 0; i < RT_DBNHASH; i++)
			for (dp = wdbp->dbip->dbi_Head[i];
			     dp != DIR_NULL;
			     dp = dp->d_forw)  {
				if (dp->d_nref == 0 &&
				    ((!gflag || (gflag && dp->d_major_type == DB5_MAJORTYPE_BRLCAD)) &&
				     (!uflag || (uflag && !(dp->d_flags & DIR_HIDDEN)))))
					*dirp++ = dp;
			}
	}

	bu_vls_init(&vls);
	wdb_vls_col_pr4v(&vls, dirp0, (int)(dirp - dirp0), no_decorate);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)0);
	bu_vls_free(&vls);
        bu_free((genptr_t)dirp0, "wdb_tops_cmd: wdb_dir_getspace");

	return TCL_OK;
}

/*
 *			W D B _ T O P S _ T C L
 *
 *  NON-PARALLEL because of rt_uniresource
 */
static int
wdb_tops_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_tops_cmd(wdbp, interp, argc-1, argv+1);
}

/*
 *			R T _ T C L _ D E L E T E P R O C _ R T
 *
 *  Called when the named proc created by rt_gettrees() is destroyed.
 */
static void
wdb_deleteProc_rt(ClientData clientData)
{
	struct application	*ap = (struct application *)clientData;
	struct rt_i		*rtip;

	RT_AP_CHECK(ap);
	rtip = ap->a_rt_i;
	RT_CK_RTI(rtip);

	rt_free_rti(rtip);
	ap->a_rt_i = (struct rt_i *)NULL;

	bu_free( (genptr_t)ap, "struct application" );
}

int
wdb_rt_gettrees_cmd(struct rt_wdb	*wdbp,
		    Tcl_Interp		*interp,
		    int			argc,
		    char 		**argv)
{
	struct rt_i		*rtip;
	struct application	*ap;
	struct resource		*resp;
	char			*newprocname;

	RT_CK_WDB_TCL(interp, wdbp);
	RT_CK_DBI_TCL(interp, wdbp->dbip);

	if (argc < 3) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_rt_gettrees %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	rtip = rt_new_rti(wdbp->dbip);
	newprocname = argv[1];

	/* Delete previous proc (if any) to release all that memory, first */
	(void)Tcl_DeleteCommand(interp, newprocname);

	while (argv[2][0] == '-') {
		if (strcmp( argv[2], "-i") == 0) {
			rtip->rti_dont_instance = 1;
			argc--;
			argv++;
			continue;
		}
		if (strcmp(argv[2], "-u") == 0) {
			rtip->useair = 1;
			argc--;
			argv++;
			continue;
		}
		break;
	}

	if (rt_gettrees(rtip, argc-2, (const char **)&argv[2], 1) < 0) {
		Tcl_AppendResult(interp,
				 "rt_gettrees() returned error", (char *)NULL);
		rt_free_rti(rtip);
		return TCL_ERROR;
	}

	/* Establish defaults for this rt_i */
	rtip->rti_hasty_prep = 1;	/* Tcl isn't going to fire many rays */

	/*
	 *  In case of multiple instances of the library, make sure that
	 *  each instance has a separate resource structure,
	 *  because the bit vector lengths depend on # of solids.
	 *  And the "overwrite" sequence in Tcl is to create the new
	 *  proc before running the Tcl_CmdDeleteProc on the old one,
	 *  which in this case would trash rt_uniresource.
	 *  Once on the rti_resources list, rt_clean() will clean 'em up.
	 */
	BU_GETSTRUCT(resp, resource);
	rt_init_resource(resp, 0, rtip);
	BU_ASSERT_PTR( BU_PTBL_GET(&rtip->rti_resources, 0), !=, NULL );

	BU_GETSTRUCT(ap, application);
	ap->a_magic = RT_AP_MAGIC;
	ap->a_resource = resp;
	ap->a_rt_i = rtip;
	ap->a_purpose = "Conquest!";

	rt_ck(rtip);

	/* Instantiate the proc, with clientData of wdb */
	/* Beware, returns a "token", not TCL_OK. */
	(void)Tcl_CreateCommand(interp, newprocname, rt_tcl_rt,
				(ClientData)ap, wdb_deleteProc_rt);

	/* Return new function name as result */
	Tcl_AppendResult(interp, newprocname, (char *)NULL);

	return TCL_OK;
}

/*
 *			W D B _ R T _ G E T T R E E S _ T C L
 *
 *  Given an instance of a database and the name of some treetops,
 *  create a named "ray-tracing" object (proc) which will respond to
 *  subsequent operations.
 *  Returns new proc name as result.
 *
 *  Example:
 *	.inmem rt_gettrees .rt all.g light.r
 */
static int
wdb_rt_gettrees_tcl(ClientData	clientData,
		    Tcl_Interp     *interp,
		    int		argc,
		    char	      **argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_rt_gettrees_cmd(wdbp, interp, argc-1, argv+1);
}

struct showmats_data {
	Tcl_Interp	*smd_interp;
	int		smd_count;
	char		*smd_child;
	mat_t		smd_mat;
};

static void
Do_showmats(struct db_i			*dbip,
	    struct rt_comb_internal	*comb,
	    union tree			*comb_leaf,
	    genptr_t			user_ptr1,
	    genptr_t			user_ptr2,
	    genptr_t			user_ptr3)
{
	struct showmats_data	*smdp;

	RT_CK_DBI(dbip);
	RT_CK_TREE(comb_leaf);

	smdp = (struct showmats_data *)user_ptr1;

	if (strcmp(comb_leaf->tr_l.tl_name, smdp->smd_child))
		return;

	smdp->smd_count++;
	if (smdp->smd_count > 1) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "\n\tOccurrence #%d:\n", smdp->smd_count);
		Tcl_AppendResult(smdp->smd_interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
	}

	bn_tcl_mat_print(smdp->smd_interp, "", comb_leaf->tr_l.tl_mat);
	if (smdp->smd_count == 1) {
		mat_t tmp_mat;
		if (comb_leaf->tr_l.tl_mat) {
			bn_mat_mul(tmp_mat, smdp->smd_mat, comb_leaf->tr_l.tl_mat);
			MAT_COPY(smdp->smd_mat, tmp_mat);
		}
	}
}

int
wdb_showmats_cmd(struct rt_wdb	*wdbp,
		 Tcl_Interp	*interp,
		 int		argc,
		 char		**argv)
{
	struct showmats_data sm_data;
	char *parent;
	struct directory *dp;
	int max_count=1;

	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_showmats %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	sm_data.smd_interp = interp;
	MAT_IDN(sm_data.smd_mat);

	parent = strtok(argv[1], "/");
	while ((sm_data.smd_child = strtok((char *)NULL, "/")) != NULL) {
		struct rt_db_internal	intern;
		struct rt_comb_internal *comb;

		if ((dp = db_lookup(wdbp->dbip, parent, LOOKUP_NOISY)) == DIR_NULL)
			return TCL_ERROR;

		Tcl_AppendResult(interp, parent, "\n", (char *)NULL);

		if (!(dp->d_flags & DIR_COMB)) {
			Tcl_AppendResult(interp, "\tThis is not a combination\n", (char *)NULL);
			break;
		}

		if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource) < 0)
			WDB_TCL_READ_ERR_return;
		comb = (struct rt_comb_internal *)intern.idb_ptr;

		sm_data.smd_count = 0;

		if (comb->tree)
			db_tree_funcleaf(wdbp->dbip, comb, comb->tree, Do_showmats,
					 (genptr_t)&sm_data, (genptr_t)NULL, (genptr_t)NULL);
		rt_comb_ifree(&intern, &rt_uniresource);

		if (!sm_data.smd_count) {
			Tcl_AppendResult(interp, sm_data.smd_child, " is not a member of ",
					 parent, "\n", (char *)NULL);
			return TCL_ERROR;
		}
		if (sm_data.smd_count > max_count)
			max_count = sm_data.smd_count;

		parent = sm_data.smd_child;
	}
	Tcl_AppendResult(interp, parent, "\n", (char *)NULL);

	if (max_count > 1)
		Tcl_AppendResult(interp, "\nAccumulated matrix (using first occurrence of each object):\n", (char *)NULL);
	else
		Tcl_AppendResult(interp, "\nAccumulated matrix:\n", (char *)NULL);

	bn_tcl_mat_print(interp, "", sm_data.smd_mat);

	return TCL_OK;
}

static int
wdb_showmats_tcl(ClientData	clientData,
		 Tcl_Interp	*interp,
		 int		argc,
		 char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
	
	return wdb_showmats_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_shells_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char		**argv)
{
	struct directory *old_dp,*new_dp;
	struct rt_db_internal old_intern,new_intern;
	struct model *m_tmp,*m;
	struct nmgregion *r_tmp,*r;
	struct shell *s_tmp,*s;
	int shell_count=0;
	struct bu_vls shell_name;
	long **trans_tbl;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_shells %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if ((old_dp = db_lookup(wdbp->dbip,  argv[1], LOOKUP_NOISY)) == DIR_NULL)
		return TCL_ERROR;

	if (rt_db_get_internal(&old_intern, old_dp, wdbp->dbip, bn_mat_identity, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
		return TCL_ERROR;
	}

	if (old_intern.idb_type != ID_NMG) {
		Tcl_AppendResult(interp, "Object is not an NMG!!!\n", (char *)NULL);
		return TCL_ERROR;
	}

	m = (struct model *)old_intern.idb_ptr;
	NMG_CK_MODEL(m);

	bu_vls_init(&shell_name);
	for (BU_LIST_FOR(r, nmgregion, &m->r_hd)) {
		for (BU_LIST_FOR(s, shell, &r->s_hd)) {
			s_tmp = nmg_dup_shell(s, &trans_tbl, &wdbp->wdb_tol);
			bu_free((genptr_t)trans_tbl, "trans_tbl");

			m_tmp = nmg_mmr();
			r_tmp = BU_LIST_FIRST(nmgregion, &m_tmp->r_hd);

			BU_LIST_DEQUEUE(&s_tmp->l);
			BU_LIST_APPEND(&r_tmp->s_hd, &s_tmp->l);
			s_tmp->r_p = r_tmp;
			nmg_m_reindex(m_tmp, 0);
			nmg_m_reindex(m, 0);

			bu_vls_printf(&shell_name, "shell.%d", shell_count);
			while (db_lookup(wdbp->dbip, bu_vls_addr( &shell_name), 0) != DIR_NULL) {
				bu_vls_trunc(&shell_name, 0);
				shell_count++;
				bu_vls_printf(&shell_name, "shell.%d", shell_count);
			}

			/* Export NMG as a new solid */
			RT_INIT_DB_INTERNAL(&new_intern);
			new_intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
			new_intern.idb_type = ID_NMG;
			new_intern.idb_meth = &rt_functab[ID_NMG];
			new_intern.idb_ptr = (genptr_t)m_tmp;

			if ((new_dp=db_diradd(wdbp->dbip, bu_vls_addr(&shell_name), -1, 0,
					      DIR_SOLID, (genptr_t)&new_intern.idb_type)) == DIR_NULL) {
				WDB_TCL_ALLOC_ERR_return;
			}

			/* make sure the geometry/bounding boxes are up to date */
			nmg_rebound(m_tmp, &wdbp->wdb_tol);


			if (rt_db_put_internal(new_dp, wdbp->dbip, &new_intern, &rt_uniresource) < 0) {
				/* Free memory */
				nmg_km(m_tmp);
				Tcl_AppendResult(interp, "rt_db_put_internal() failure\n", (char *)NULL);
				return TCL_ERROR;
			}
			/* Internal representation has been freed by rt_db_put_internal */
			new_intern.idb_ptr = (genptr_t)NULL;
		}
	}
	bu_vls_free(&shell_name);

	return TCL_OK;
}

static int
wdb_shells_tcl(ClientData	clientData,
	       Tcl_Interp	*interp,
	       int		argc,
	       char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_shells_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_dump_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char		**argv)
{
	struct rt_wdb	*op;
	int		ret;

	RT_CK_WDB_TCL(interp, wdbp);
	RT_CK_DBI_TCL(interp, wdbp->dbip);

	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_dump %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if ((op = wdb_fopen(argv[1])) == RT_WDB_NULL) {
		Tcl_AppendResult(interp, "dump:  ", argv[1],
				 ": cannot create", (char *)NULL);
		return TCL_ERROR;
	}

	ret = db_dump(op, wdbp->dbip);
	wdb_close(op);

	if (ret < 0) {
		Tcl_AppendResult(interp, "dump ", argv[1],
				 ": db_dump() error", (char *)NULL);
		return TCL_ERROR;
	}

	return TCL_OK;
}

/*
 *			W D B _ D U M P _ T C L
 *
 *  Write the current state of a database object out to a file.
 *
 *  Example:
 *	.inmem dump "/tmp/foo.g"
 */
static int
wdb_dump_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_dump_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_dbip_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char		**argv)
{
	struct bu_vls vls;

	bu_vls_init(&vls);

	if (argc != 1) {
		bu_vls_printf(&vls, "helplib_alias wdb_dbip %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_printf(&vls, "%lu", (unsigned long)wdbp->dbip);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
	return TCL_OK;
}

/*
 *
 * Usage:
 *        procname dbip
 *
 * Returns: database objects dbip.
 */
static int
wdb_dbip_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_dbip_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_ls_cmd(struct rt_wdb	*wdbp,
	   Tcl_Interp		*interp,
	   int			argc,
	   char 		**argv)
{
	struct bu_vls vls;
	register struct directory *dp;
	register int i;
	int c;
	int aflag = 0;		/* print all objects without formatting */
	int cflag = 0;		/* print combinations */
	int rflag = 0;		/* print regions */
	int sflag = 0;		/* print solids */
	int lflag = 0;		/* use long format */
	int attr_flag = 0;	/* arguments are attribute name/value pairs */
	int or_flag = 0;	/* flag indicating that any one attribute match is sufficient
				 * default is all attributes must match.
				 */
	struct directory **dirp;
	struct directory **dirp0 = (struct directory **)NULL;

	bu_vls_init(&vls);

	if (argc < 1 || MAXARGS < argc) {
		bu_vls_printf(&vls, "helplib_alias wdb_ls %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_optind = 1;	/* re-init bu_getopt() */
	while ((c = bu_getopt(argc, argv, "acrslpAo")) != EOF) {
		switch (c) {
		case 'A':
			attr_flag = 1;
			break;
		case 'o':
			or_flag = 1;
			break;
		case 'a':
			aflag = 1;
			break;
		case 'c':
			cflag = 1;
			break;
		case 'r':
			rflag = 1;
			break;
		case 's':
		case 'p':
			sflag = 1;
			break;
		case 'l':
			lflag = 1;
			break;
		default:
			bu_vls_printf(&vls, "Unrecognized option - %c", c);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);
			return TCL_ERROR;
		}
	}
	argc -= (bu_optind - 1);
	argv += (bu_optind - 1);

	/* create list of selected objects from database */
	if( attr_flag ) {
		/* select objects based on attributes */
		struct bu_ptbl *tbl;
		struct bu_attribute_value_set avs;
		int dir_flags;
		int op;

		if( argc < 3 || argc%2 != 1 ) {
			/* should be odd number of args name/value pairs plus argv[0] */
			bu_vls_printf(&vls, "helplib_alias wdb_ls %s", argv[0]);
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		if( or_flag ) {
			op = 2;
		} else {
			op = 1;
		}

		dir_flags = 0;
		if( aflag ) dir_flags = -1;
		if( cflag ) dir_flags = DIR_COMB;
		if( sflag ) dir_flags = DIR_SOLID;
		if( rflag ) dir_flags = DIR_REGION;
		if( !dir_flags ) dir_flags = -1 ^ DIR_HIDDEN;

		bu_avs_init( &avs, argc-1, "wdb_ls_cmd avs" );
		for (i = 1; i < argc; i += 2) {
			if( or_flag ) {
				bu_avs_add_nonunique( &avs, argv[i], argv[i+1] );
			} else {
				bu_avs_add( &avs, argv[i], argv[i+1] );
			}
		}
		tbl = db_lookup_by_attr( wdbp->dbip, dir_flags, &avs, op );
		bu_avs_free( &avs );
		dirp = wdb_getspace(wdbp->dbip, BU_PTBL_LEN( tbl ));
		dirp0 = dirp;
		for( i=0 ; i<BU_PTBL_LEN( tbl ) ; i++ ) {
			*dirp++ = (struct directory *)BU_PTBL_GET( tbl, i );
		}
		bu_ptbl_free( tbl );
		bu_free( (char *)tbl, "wdb_ls_cmd ptbl" );
	} else if (argc > 1) {
		/* Just list specified names */
		dirp = wdb_getspace(wdbp->dbip, argc-1);
		dirp0 = dirp;
		/*
		 * Verify the names, and add pointers to them to the array.
		 */
		for (i = 1; i < argc; i++) {
			if ((dp = db_lookup(wdbp->dbip, argv[i], LOOKUP_NOISY)) == DIR_NULL)
				continue;
			*dirp++ = dp;
		}
	} else {
		/* Full table of contents */
		dirp = wdb_getspace(wdbp->dbip, 0);	/* Enough for all */
		dirp0 = dirp;
		/*
		 * Walk the directory list adding pointers (to the directory
		 * entries) to the array.
		 */
		for (i = 0; i < RT_DBNHASH; i++)
			for (dp = wdbp->dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw) {
				if( !aflag && (dp->d_flags & DIR_HIDDEN) )
					continue;
				*dirp++ = dp;
			}
	}

	if (lflag)
		wdb_vls_long_dpp(&vls, dirp0, (int)(dirp - dirp0),
				 aflag, cflag, rflag, sflag);
	else if (aflag || cflag || rflag || sflag)
		wdb_vls_line_dpp(&vls, dirp0, (int)(dirp - dirp0),
				 aflag, cflag, rflag, sflag);
	else
		wdb_vls_col_pr4v(&vls, dirp0, (int)(dirp - dirp0), 0);

	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
	bu_free((genptr_t)dirp0, "wdb_getspace dp[]");

	return TCL_OK;
}

/*
 *
 * Usage:
 *        procname ls [args]
 *
 * Returns: list objects in this database object.
 */
static int
wdb_ls_tcl(ClientData	clientData,
	   Tcl_Interp	*interp,
	   int		argc,
	   char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_ls_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_list_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	register struct directory	*dp;
	register int			arg;
	struct bu_vls			str;
	int				id;
	int				recurse = 0;
	char				*listeval = "listeval";
	struct rt_db_internal		intern;

	if (argc < 2 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_list %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (argc > 1 && strcmp(argv[1], "-r") == 0) {
		recurse = 1;

		/* skip past used args */
		--argc;
		++argv;
	}

	/* skip past used args */
	--argc;
	++argv;

	bu_vls_init(&str);

	for (arg = 0; arg < argc; arg++) {
		if (recurse) {
			char *tmp_argv[3];

			tmp_argv[0] = listeval;
			tmp_argv[1] = argv[arg];
			tmp_argv[2] = (char *)NULL;

			wdb_pathsum_cmd(wdbp, interp, 2, tmp_argv);
		} else if (strchr(argv[arg], '/')) {
			struct db_tree_state ts;
			struct db_full_path path;

			db_full_path_init( &path );
			ts = wdbp->wdb_initial_tree_state;     /* struct copy */
			ts.ts_dbip = wdbp->dbip;
			ts.ts_resp = &rt_uniresource;
			MAT_IDN(ts.ts_mat);

			if (db_follow_path_for_state(&ts, &path, argv[arg], 1))
				continue;

			dp = DB_FULL_PATH_CUR_DIR( &path );

			if ((id = rt_db_get_internal(&intern, dp, wdbp->dbip, ts.ts_mat, &rt_uniresource)) < 0) {
				Tcl_AppendResult(interp, "rt_db_get_internal(", dp->d_namep,
						 ") failure", (char *)NULL );
				continue;
			}

			db_free_full_path( &path );

			bu_vls_printf( &str, "%s:  ", argv[arg] );

			if (rt_functab[id].ft_describe(&str, &intern, 99, wdbp->dbip->dbi_base2local, &rt_uniresource, wdbp->dbip) < 0)
				Tcl_AppendResult(interp, dp->d_namep, ": describe error", (char *)NULL);

			rt_db_free_internal(&intern, &rt_uniresource);
		} else {
			if ((dp = db_lookup(wdbp->dbip, argv[arg], LOOKUP_NOISY)) == DIR_NULL)
				continue;

			wdb_do_list(wdbp->dbip, interp, &str, dp, 99);	/* very verbose */
		}
	}

	Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
	bu_vls_free(&str);

	return TCL_OK;
}

/*
 *
 *  Usage:
 *        procname l [-r] arg(s)
 *
 *  List object information, verbose.
 */
static int
wdb_list_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_list_cmd(wdbp, interp, argc-1, argv+1);
}

static void
wdb_do_trace(struct db_i		*dbip,
	     struct rt_comb_internal	*comb,
	     union tree			*comb_leaf,
	     genptr_t			user_ptr1,
	     genptr_t			user_ptr2,
	     genptr_t			user_ptr3)
{
	int			*pathpos;
	matp_t			old_xlate;
	mat_t			new_xlate;
	struct directory	*nextdp;
	struct wdb_trace_data	*wtdp;

	RT_CK_DBI(dbip);
	RT_CK_TREE(comb_leaf);

	if ((nextdp = db_lookup(dbip, comb_leaf->tr_l.tl_name, LOOKUP_NOISY)) == DIR_NULL)
		return;

	pathpos = (int *)user_ptr1;
	old_xlate = (matp_t)user_ptr2;
	wtdp = (struct wdb_trace_data *)user_ptr3;

	if (comb_leaf->tr_l.tl_mat) {
		bn_mat_mul(new_xlate, old_xlate, comb_leaf->tr_l.tl_mat);
	} else {
		MAT_COPY(new_xlate, old_xlate);
	}

	wdb_trace(nextdp, (*pathpos)+1, new_xlate, wtdp);
}

static void
wdb_trace(register struct directory	*dp,
	  int				pathpos,
	  const mat_t			old_xlate,
	  struct wdb_trace_data		*wtdp)
{
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	int			i;
	int			id;
	struct bu_vls		str;

#if 0
	if (dbip == DBI_NULL)
		return;
#endif

	bu_vls_init(&str);

	if (pathpos >= WDB_MAX_LEVELS) {
		struct bu_vls tmp_vls;

		bu_vls_init(&tmp_vls);
		bu_vls_printf(&tmp_vls, "nesting exceeds %d levels\n", WDB_MAX_LEVELS);
		Tcl_AppendResult(wtdp->wtd_interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);

		for (i=0; i<WDB_MAX_LEVELS; i++)
			Tcl_AppendResult(wtdp->wtd_interp, "/", wtdp->wtd_path[i]->d_namep, (char *)NULL);

		Tcl_AppendResult(wtdp->wtd_interp, "\n", (char *)NULL);
		return;
	}

	if (dp->d_flags & DIR_COMB) {
		if (rt_db_get_internal(&intern, dp, wtdp->wtd_dbip, (fastf_t *)NULL, &rt_uniresource) < 0)
			WDB_READ_ERR_return;

		wtdp->wtd_path[pathpos] = dp;
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		if (comb->tree)
			db_tree_funcleaf(wtdp->wtd_dbip, comb, comb->tree, wdb_do_trace,
				(genptr_t)&pathpos, (genptr_t)old_xlate, (genptr_t)wtdp);
		rt_comb_ifree(&intern, &rt_uniresource);
		return;
	}

	/* not a combination  -  should have a solid */

	/* last (bottom) position */
	wtdp->wtd_path[pathpos] = dp;

	/* check for desired path */
	if( wtdp->wtd_flag == WDB_CPEVAL ) {
		for (i=0; i<=pathpos; i++) {
			if (wtdp->wtd_path[i]->d_addr != wtdp->wtd_obj[i]->d_addr) {
				/* not the desired path */
				return;
			}
		}
	} else {
		for (i=0; i<wtdp->wtd_objpos; i++) {
			if (wtdp->wtd_path[i]->d_addr != wtdp->wtd_obj[i]->d_addr) {
				/* not the desired path */
				return;
			}
		}
	}

	/* have the desired path up to objpos */
	MAT_COPY(wtdp->wtd_xform, old_xlate);
	wtdp->wtd_prflag = 1;

	if (wtdp->wtd_flag == WDB_CPEVAL)
		return;

	/* print the path */
	for (i=0; i<pathpos; i++)
		Tcl_AppendResult(wtdp->wtd_interp, "/", wtdp->wtd_path[i]->d_namep, (char *)NULL);

	if (wtdp->wtd_flag == WDB_LISTPATH) {
		bu_vls_printf( &str, "/%s:\n", dp->d_namep );
		Tcl_AppendResult(wtdp->wtd_interp, bu_vls_addr(&str), (char *)NULL);
		bu_vls_free(&str);
		return;
	}

	/* NOTE - only reach here if wtd_flag == WDB_LISTEVAL */
	Tcl_AppendResult(wtdp->wtd_interp, "/", (char *)NULL);
	if ((id=rt_db_get_internal(&intern, dp, wtdp->wtd_dbip, wtdp->wtd_xform, &rt_uniresource)) < 0) {
		Tcl_AppendResult(wtdp->wtd_interp, "rt_db_get_internal(", dp->d_namep,
				 ") failure", (char *)NULL );
		return;
	}
	bu_vls_printf(&str, "%s:\n", dp->d_namep);
	if (rt_functab[id].ft_describe(&str, &intern, 1, wtdp->wtd_dbip->dbi_base2local, &rt_uniresource, wtdp->wtd_dbip) < 0)
		Tcl_AppendResult(wtdp->wtd_interp, dp->d_namep, ": describe error\n", (char *)NULL);
	rt_db_free_internal(&intern, &rt_uniresource);
	Tcl_AppendResult(wtdp->wtd_interp, bu_vls_addr(&str), (char *)NULL);
	bu_vls_free(&str);
}

int
wdb_pathsum_cmd(struct rt_wdb	*wdbp,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	int			i, pos_in;
	struct wdb_trace_data	wtd;

	if (argc < 2 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias %s%s %s", "wdb_", argv[0], argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/*
	 *	paths are matched up to last input member
	 *      ANY path the same up to this point is considered as matching
	 */

	/* initialize wtd */
	wtd.wtd_interp = interp;
	wtd.wtd_dbip = wdbp->dbip;
	wtd.wtd_flag = WDB_CPEVAL;
	wtd.wtd_prflag = 0;

	pos_in = 1;

	/* find out which command was entered */
	if (strcmp(argv[0], "paths") == 0) {
		/* want to list all matching paths */
		wtd.wtd_flag = WDB_LISTPATH;
	}
	if (strcmp(argv[0], "listeval") == 0) {
		/* want to list evaluated solid[s] */
		wtd.wtd_flag = WDB_LISTEVAL;
	}

	if (argc == 2 && strchr(argv[1], '/')) {
		char *tok;
		wtd.wtd_objpos = 0;

		tok = strtok(argv[1], "/");
		while (tok) {
			if ((wtd.wtd_obj[wtd.wtd_objpos++] = db_lookup(wdbp->dbip, tok, LOOKUP_NOISY)) == DIR_NULL)
				return TCL_ERROR;
			tok = strtok((char *)NULL, "/");
		}
	} else {
		wtd.wtd_objpos = argc-1;

		/* build directory pointer array for desired path */
		for (i=0; i<wtd.wtd_objpos; i++) {
			if ((wtd.wtd_obj[i] = db_lookup(wdbp->dbip, argv[pos_in+i], LOOKUP_NOISY)) == DIR_NULL)
				return TCL_ERROR;
		}
	}

	MAT_IDN(wtd.wtd_xform);

	wdb_trace(wtd.wtd_obj[0], 0, bn_mat_identity, &wtd);

	if (wtd.wtd_prflag == 0) {
		/* path not found */
		Tcl_AppendResult(interp, "PATH:  ", (char *)NULL);
		for (i=0; i<wtd.wtd_objpos; i++)
			Tcl_AppendResult(interp, "/", wtd.wtd_obj[i]->d_namep, (char *)NULL);

		Tcl_AppendResult(interp, "  NOT FOUND\n", (char *)NULL);
	}

	return TCL_OK;
}


/*
 *			W D B _ P A T H S U M _ T C L
 *
 *  Common code for several direct db methods: listeval, paths
 *  Also used as support routine for "l" (list) command.
 *
 *  1.  produces path for purposes of matching
 *  2.  gives all paths matching the input path OR
 *  3.  gives a summary of all paths matching the input path
 *	including the final parameters of the solids at the bottom
 *	of the matching paths
 *
 * Usage:
 *        procname (WDB_LISTEVAL|paths) args(s)
 */
static int
wdb_pathsum_tcl(ClientData	clientData,
		Tcl_Interp	*interp,
		int		argc,
		char		**argv)
{
	struct rt_wdb	*wdbp = (struct rt_wdb *)clientData;

	return wdb_pathsum_cmd(wdbp, interp, argc-1, argv+1);
}


static void
wdb_scrape_escapes_AppendResult(Tcl_Interp	*interp,
				char		*str)
{
	char buf[2];
	buf[1] = '\0';
    
	while (*str) {
		buf[0] = *str;
		if (*str != '\\') {
			Tcl_AppendResult(interp, buf, NULL);
		} else if (*(str+1) == '\\') {
			Tcl_AppendResult(interp, buf, NULL);
			++str;
		}
		if (*str == '\0')
			break;
		++str;
	}
}

int
wdb_expand_cmd(struct rt_wdb	*wdbp,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	register char *pattern;
	register struct directory *dp;
	register int i, whicharg;
	int regexp, nummatch, thismatch, backslashed;

	if (argc < 1 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_expand %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	nummatch = 0;
	backslashed = 0;
	for (whicharg = 1; whicharg < argc; whicharg++) {
		/* If * ? or [ are present, this is a regular expression */
		pattern = argv[whicharg];
		regexp = 0;
		do {
			if ((*pattern == '*' || *pattern == '?' || *pattern == '[') &&
			    !backslashed) {
				regexp = 1;
				break;
			}
			if (*pattern == '\\' && !backslashed)
				backslashed = 1;
			else
				backslashed = 0;
		} while (*pattern++);

		/* If it isn't a regexp, copy directly and continue */
		if (regexp == 0) {
			if (nummatch > 0)
				Tcl_AppendResult(interp, " ", NULL);
			wdb_scrape_escapes_AppendResult(interp, argv[whicharg]);
			++nummatch;
			continue;
		}
	
		/* Search for pattern matches.
		 * If any matches are found, we do not have to worry about
		 * '\' escapes since the match coming from dp->d_namep will be
		 * clean. In the case of no matches, just copy the argument
		 * directly.
		 */

		pattern = argv[whicharg];
		thismatch = 0;
		for (i = 0; i < RT_DBNHASH; i++) {
			for (dp = wdbp->dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw) {
				if (!db_regexp_match(pattern, dp->d_namep))
					continue;
				/* Successful match */
				if (nummatch == 0)
					Tcl_AppendResult(interp, dp->d_namep, NULL);
				else 
					Tcl_AppendResult(interp, " ", dp->d_namep, NULL);
				++nummatch;
				++thismatch;
			}
		}
		if (thismatch == 0) {
			if (nummatch > 0)
				Tcl_AppendResult(interp, " ", NULL);
			wdb_scrape_escapes_AppendResult(interp, argv[whicharg]);
		}
	}

	return TCL_OK;
}

/*
 * Performs wildcard expansion (matched to the database elements)
 * on its given arguments.  The result is returned in interp->result.
 *
 * Usage:
 *        procname expand [args]
 */
static int
wdb_expand_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_expand_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_kill_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char		**argv)
{
	register struct directory *dp;
	register int i;
	int	is_phony;
	int	verbose = LOOKUP_NOISY;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc < 2 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_kill %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* skip past "-f" */
	if (argc > 1 && strcmp(argv[1], "-f") == 0) {
		verbose = LOOKUP_QUIET;
		argc--;
		argv++;
	}

	for (i = 1; i < argc; i++) {
		if ((dp = db_lookup(wdbp->dbip,  argv[i], verbose)) != DIR_NULL) {
			is_phony = (dp->d_addr == RT_DIR_PHONY_ADDR);

			/* don't worry about phony objects */
			if (is_phony)
				continue;

			/* notify drawable geometry objects associated with this database object */
			if (i == argc-1)
			  dgo_eraseobjall_callback(wdbp->dbip, interp, dp, 1 /* notify other interested observers */);
			else
			  dgo_eraseobjall_callback(wdbp->dbip, interp, dp, 0);

			if (db_delete(wdbp->dbip, dp) < 0 ||
			    db_dirdelete(wdbp->dbip, dp) < 0) {
				/* Abort kill processing on first error */
				Tcl_AppendResult(interp,
						 "an error occurred while deleting ",
						 argv[i], (char *)NULL);
				return TCL_ERROR;
			}
		}
	}

	return TCL_OK;
}

/*
 * Usage:
 *        procname kill arg(s)
 */
static int
wdb_kill_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_kill_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_killall_cmd(struct rt_wdb	*wdbp,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	register int			i,k;
	register struct directory	*dp;
	struct rt_db_internal		intern;
	struct rt_comb_internal		*comb;
	int				ret;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc < 2 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias  wdb_killall %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	ret = TCL_OK;

	/* Examine all COMB nodes */
	for (i = 0; i < RT_DBNHASH; i++) {
		for (dp = wdbp->dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw) {
			if (!(dp->d_flags & DIR_COMB))
				continue;

			if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource) < 0) {
				Tcl_AppendResult(interp, "rt_db_get_internal(", dp->d_namep,
						 ") failure", (char *)NULL );
				ret = TCL_ERROR;
				continue;
			}
			comb = (struct rt_comb_internal *)intern.idb_ptr;
			RT_CK_COMB(comb);

			for (k=1; k<argc; k++) {
				int	code;

				code = db_tree_del_dbleaf(&(comb->tree), argv[k], &rt_uniresource);
				if (code == -1)
					continue;	/* not found */
				if (code == -2)
					continue;	/* empty tree */
				if (code < 0) {
					Tcl_AppendResult(interp, "  ERROR_deleting ",
							 dp->d_namep, "/", argv[k],
							 "\n", (char *)NULL);
					ret = TCL_ERROR;
				} else {
					Tcl_AppendResult(interp, "deleted ",
							 dp->d_namep, "/", argv[k],
							 "\n", (char *)NULL);
				}
			}

			if (rt_db_put_internal(dp, wdbp->dbip, &intern, &rt_uniresource) < 0) {
				Tcl_AppendResult(interp,
						 "ERROR: Unable to write new combination into database.\n",
						 (char *)NULL);
				ret = TCL_ERROR;
				continue;
			}
		}
	}

	if (ret != TCL_OK) {
		Tcl_AppendResult(interp,
				 "KILL skipped because of earlier errors.\n",
				 (char *)NULL);
		return ret;
	}

	/* ALL references removed...now KILL the object[s] */
	/* reuse argv[] */
	argv[0] = "kill";
	return wdb_kill_cmd(wdbp, interp, argc, argv);
}

/*
 * Kill object[s] and remove all references to the object[s].
 *
 * Usage:
 *        procname killall arg(s)
 */
static int
wdb_killall_tcl(ClientData	clientData,
		Tcl_Interp	*interp,
		int		argc,
		char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_killall_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_killtree_cmd(struct rt_wdb	*wdbp,
		 Tcl_Interp	*interp,
		 int		argc,
		 char 		**argv)
{
	register struct directory *dp;
	register int i;
	struct wdb_killtree_data ktd;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc < 2 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_killtree %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	ktd.interp = interp;
	ktd.notify = 0;

	for (i=1; i<argc; i++) {
		if ((dp = db_lookup(wdbp->dbip, argv[i], LOOKUP_NOISY)) == DIR_NULL)
			continue;

		/* ignore phony objects */
		if (dp->d_addr == RT_DIR_PHONY_ADDR)
			continue;

		if (i == argc-1)
		  ktd.notify = 1;

		db_functree(wdbp->dbip, dp,
			    wdb_killtree_callback, wdb_killtree_callback,
			    wdbp->wdb_resp, (genptr_t)&ktd);
	}

	return TCL_OK;
}

/*
 * Kill all paths belonging to an object.
 *
 * Usage:
 *        procname killtree arg(s)
 */
static int
wdb_killtree_tcl(ClientData	clientData,
		 Tcl_Interp	*interp,
		 int		argc,
		 char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_killtree_cmd(wdbp, interp, argc-1, argv+1);
}

/*
 *			K I L L T R E E
 */
static void
wdb_killtree_callback(struct db_i		*dbip,
		      register struct directory *dp,
		      genptr_t			*ptr) {
	struct wdb_killtree_data *ktdp = (struct wdb_killtree_data *)ptr;
	Tcl_Interp *interp = ktdp->interp;

	if (dbip == DBI_NULL)
		return;

	Tcl_AppendResult(interp, "KILL ", (dp->d_flags & DIR_COMB) ? "COMB" : "Solid",
			 ":  ", dp->d_namep, "\n", (char *)NULL);

	/* notify drawable geometry objects associated with this database object */
	dgo_eraseobjall_callback(interp, dbip, dp, ktdp->notify);

	if (db_delete(dbip, dp) < 0 || db_dirdelete(dbip, dp) < 0) {
		Tcl_AppendResult(interp,
				 "an error occurred while deleting ",
				 dp->d_namep, "\n", (char *)NULL);
	}
}

int
wdb_copy_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	register struct directory *proto;
	register struct directory *dp;
	struct bu_external external;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc != 3) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_copy %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if ((proto = db_lookup(wdbp->dbip,  argv[1], LOOKUP_NOISY)) == DIR_NULL)
		return TCL_ERROR;

	if (db_lookup(wdbp->dbip, argv[2], LOOKUP_QUIET) != DIR_NULL) {
		Tcl_AppendResult(interp, argv[2], ":  already exists", (char *)NULL);
		return TCL_ERROR;
	}

	if (db_get_external(&external , proto , wdbp->dbip)) {
		Tcl_AppendResult(interp, "Database read error, aborting", (char *)NULL);
		return TCL_ERROR;
	}

	if ((dp=db_diradd(wdbp->dbip, argv[2], -1, 0, proto->d_flags, (genptr_t)&proto->d_minor_type)) == DIR_NULL ) {
		Tcl_AppendResult(interp,
				 "An error has occured while adding a new object to the database.",
				 (char *)NULL);
		return TCL_ERROR;
	}

	if (db_put_external(&external, dp, wdbp->dbip) < 0) {
		bu_free_external(&external);
		Tcl_AppendResult(interp, "Database write error, aborting", (char *)NULL);
		return TCL_ERROR;
	}
	bu_free_external(&external);

	return TCL_OK;
}

/*
 * Usage:
 *        procname cp from to
 */
static int
wdb_copy_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_copy_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_move_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	register struct directory	*dp;
	struct rt_db_internal		intern;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc != 3) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_move %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if ((dp = db_lookup(wdbp->dbip,  argv[1], LOOKUP_NOISY)) == DIR_NULL)
		return TCL_ERROR;

	if (db_lookup(wdbp->dbip, argv[2], LOOKUP_QUIET) != DIR_NULL) {
		Tcl_AppendResult(interp, argv[2], ":  already exists", (char *)NULL);
		return TCL_ERROR;
	}

	if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "Database read error, aborting", (char *)NULL);
		return TCL_ERROR;
	}

	/*  Change object name in the in-memory directory. */
	if (db_rename(wdbp->dbip, dp, argv[2]) < 0) {
		rt_db_free_internal(&intern, &rt_uniresource);
		Tcl_AppendResult(interp, "error in db_rename to ", argv[2],
				 ", aborting", (char *)NULL);
		return TCL_ERROR;
	}

	/* Re-write to the database.  New name is applied on the way out. */
	if (rt_db_put_internal(dp, wdbp->dbip, &intern, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "Database write error, aborting", (char *)NULL);
		return TCL_ERROR;
	}

	return TCL_OK;
}

/*
 * Rename an object.
 *
 * Usage:
 *        procname mv from to
 */
static int
wdb_move_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_move_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_move_all_cmd(struct rt_wdb	*wdbp,
		 Tcl_Interp	*interp,
		 int		argc,
		 char 		**argv)
{
	register int	i;
	register struct directory *dp;
	struct rt_db_internal	intern;
	struct rt_comb_internal *comb;
	struct bu_ptbl		stack;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc != 3) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_moveall %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (wdbp->dbip->dbi_version < 5 && (int)strlen(argv[2]) > NAMESIZE) {
		struct bu_vls tmp_vls;

		bu_vls_init(&tmp_vls);
		bu_vls_printf(&tmp_vls, "ERROR: name length limited to %d characters in v4 databases\n", NAMESIZE);
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);
		return TCL_ERROR;
	}

	/* rename the record itself */
	if ((dp = db_lookup(wdbp->dbip, argv[1], LOOKUP_NOISY )) == DIR_NULL)
		return TCL_ERROR;

	if (db_lookup(wdbp->dbip, argv[2], LOOKUP_QUIET) != DIR_NULL) {
		Tcl_AppendResult(interp, argv[2], ":  already exists", (char *)NULL);
		return TCL_ERROR;
	}

	/*  Change object name in the directory. */
	if (db_rename(wdbp->dbip, dp, argv[2]) < 0) {
		Tcl_AppendResult(interp, "error in rename to ", argv[2],
				 ", aborting", (char *)NULL);
		return TCL_ERROR;
	}

	/* Change name in the file */
	if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "Database read error, aborting", (char *)NULL);
		return TCL_ERROR;
	}

	if (rt_db_put_internal(dp, wdbp->dbip, &intern, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "Database write error, aborting", (char *)NULL);
		return TCL_ERROR;
	}

	bu_ptbl_init(&stack, 64, "combination stack for wdb_mvall_cmd");

	/* Examine all COMB nodes */
	for (i = 0; i < RT_DBNHASH; i++) {
		for (dp = wdbp->dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw) {
			union tree	*comb_leaf;
			int		done=0;
			int		changed=0;

			if (!(dp->d_flags & DIR_COMB))
				continue;

			if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource) < 0)
				continue;
			comb = (struct rt_comb_internal *)intern.idb_ptr;

			bu_ptbl_reset(&stack);
			/* visit each leaf in the combination */
			comb_leaf = comb->tree;
			if (comb_leaf) {
				while (!done) {
					while(comb_leaf->tr_op != OP_DB_LEAF) {
						bu_ptbl_ins(&stack, (long *)comb_leaf);
						comb_leaf = comb_leaf->tr_b.tb_left;
					}

					if (!strcmp(comb_leaf->tr_l.tl_name, argv[1])) {
						bu_free(comb_leaf->tr_l.tl_name, "comb_leaf->tr_l.tl_name");
						comb_leaf->tr_l.tl_name = bu_strdup(argv[2]);
						changed = 1;
					}

					if (BU_PTBL_END(&stack) < 1) {
						done = 1;
						break;
					}
					comb_leaf = (union tree *)BU_PTBL_GET(&stack, BU_PTBL_END(&stack)-1);
					if (comb_leaf->tr_op != OP_DB_LEAF) {
						bu_ptbl_rm( &stack, (long *)comb_leaf );
						comb_leaf = comb_leaf->tr_b.tb_right;
					}
				}
			}

			if (changed) {
				if (rt_db_put_internal(dp, wdbp->dbip, &intern, &rt_uniresource)) {
					bu_ptbl_free( &stack );
					rt_db_free_internal( &intern, &rt_uniresource );
					Tcl_AppendResult(interp,
							 "Database write error, aborting",
							 (char *)NULL);
					return TCL_ERROR;
				}
			}
			else
				rt_db_free_internal(&intern, &rt_uniresource);
		}
	}

	bu_ptbl_free(&stack);
	return TCL_OK;
}

/*
 * Rename all occurences of an object
 *
 * Usage:
 *        procname mvall from to
 */
static int
wdb_move_all_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_move_all_cmd(wdbp, interp, argc-1, argv+1);
}

struct concat_data {
	int unique_mode;
	struct db_i *old_dbip;
	struct db_i *new_dbip;
	struct bu_vls prestr;
};

#define ADD_PREFIX 1
#define ADD_SUFFIX 2
#define OLD_PREFIX 3

static char *
get_new_name(
	     const char *name,
	     struct db_i *dbip,
	     Tcl_HashTable *name_tbl,
	     Tcl_HashTable *used_names_tbl,
	     struct concat_data *cc_data )
{
	int new=0;
	Tcl_HashEntry *ptr;
	struct bu_vls new_name;
	int num=0;
	char *aname;
	char *ret_name;

	ptr = Tcl_CreateHashEntry( name_tbl, name, &new );

	if( !new ) {
		return( (char *)Tcl_GetHashValue( ptr ) );
	}

	/* need to create a unique name for this item */
	bu_vls_init( &new_name );
	if( cc_data->unique_mode != OLD_PREFIX ) {
		bu_vls_strcpy( &new_name, name );
		aname = bu_vls_addr( &new_name );
		while(  db_lookup( dbip, aname, LOOKUP_QUIET ) != DIR_NULL ||
			Tcl_FindHashEntry( used_names_tbl, aname ) != NULL ) {
			bu_vls_trunc( &new_name, 0 );
			num++;
			if( cc_data->unique_mode == ADD_PREFIX ) {
				bu_vls_printf( &new_name, "%d_", num);
			}
			bu_vls_strcat( &new_name, name );
			if( cc_data->unique_mode == ADD_SUFFIX ) {
				bu_vls_printf( &new_name, "_%d", num );
			}
			aname = bu_vls_addr( &new_name );
		}
	} else {
		bu_vls_vlscat( &new_name, &cc_data->prestr );
		bu_vls_strcat( &new_name, name );
		if( cc_data->old_dbip->dbi_version < 5 ) {
			bu_vls_trunc( &new_name, RT_NAMESIZE );
		}
	}

	/* now have a unique name, make entries for it in both hash tables */

	ret_name = bu_vls_strgrab( &new_name );
	Tcl_SetHashValue( ptr, (ClientData)ret_name );
	(void)Tcl_CreateHashEntry( used_names_tbl, ret_name, &new );

	return( ret_name );
}

static void
adjust_names(
	     Tcl_Interp *interp,
	     union tree *trp,
	     struct db_i *dbip,
	     Tcl_HashTable *name_tbl,
	     Tcl_HashTable *used_names_tbl,
	     struct concat_data *cc_data )
{
	char *new_name;

	switch( trp->tr_op ) {
		case OP_DB_LEAF:
			new_name = get_new_name( trp->tr_l.tl_name, dbip,
						 name_tbl, used_names_tbl, cc_data );
			if( new_name ) {
				bu_free( trp->tr_l.tl_name, "leaf name" );
				trp->tr_l.tl_name = bu_strdup( new_name );
			}
			break;
		case OP_UNION:
		case OP_INTERSECT:
		case OP_SUBTRACT:
		case OP_XOR:
			adjust_names( interp, trp->tr_b.tb_left, dbip,
				      name_tbl, used_names_tbl, cc_data );
			adjust_names( interp, trp->tr_b.tb_right, dbip,
				      name_tbl, used_names_tbl, cc_data );
			break;
		case OP_NOT:
		case OP_GUARD:
		case OP_XNOP:
			adjust_names( interp, trp->tr_b.tb_left, dbip,	
				      name_tbl, used_names_tbl, cc_data );
			break;
	}
}

static int
copy_object(
	Tcl_Interp *interp,
	struct directory *input_dp,
	struct db_i *input_dbip,
	struct db_i *curr_dbip,
	Tcl_HashTable *name_tbl,
	Tcl_HashTable *used_names_tbl,
	struct concat_data *cc_data )
{
	struct rt_db_internal ip;
	struct rt_extrude_internal *extr;
	struct rt_dsp_internal *dsp;
	struct rt_comb_internal *comb;
	struct directory *new_dp;
	char *new_name;

	if( rt_db_get_internal( &ip, input_dp, input_dbip, NULL, &rt_uniresource) < 0 ) {
		Tcl_AppendResult(interp, "Failed to get internal form of object (", input_dp->d_namep,
				 ") - aborting!!!\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( ip.idb_major_type == DB5_MAJORTYPE_BRLCAD ) {
		/* adjust names of referenced object in any object that reference other objects */
		switch( ip.idb_minor_type ) {
			case DB5_MINORTYPE_BRLCAD_COMBINATION:
				comb = (struct rt_comb_internal *)ip.idb_ptr;
				RT_CK_COMB_TCL( interp, comb );
				adjust_names( interp, comb->tree, curr_dbip, name_tbl, used_names_tbl, cc_data );
				break;
			case DB5_MINORTYPE_BRLCAD_EXTRUDE:
				extr = (struct rt_extrude_internal *)ip.idb_ptr;
				RT_EXTRUDE_CK_MAGIC( extr );

				new_name = get_new_name( extr->sketch_name, curr_dbip, name_tbl, used_names_tbl, cc_data );
				if( new_name ) {
					bu_free( extr->sketch_name, "sketch name" );
					extr->sketch_name = bu_strdup( new_name );
				}
				break;
			case DB5_MINORTYPE_BRLCAD_DSP:
				dsp = (struct rt_dsp_internal *)ip.idb_ptr;
				RT_DSP_CK_MAGIC( dsp );

				if( dsp->dsp_datasrc == RT_DSP_SRC_OBJ ) {
					/* This dsp references a database object, may need to change its name */
					new_name = get_new_name( bu_vls_addr( &dsp->dsp_name ), curr_dbip,
								 name_tbl, used_names_tbl, cc_data );
					if( new_name ) {
						bu_vls_free( &dsp->dsp_name );
						bu_vls_strcpy( &dsp->dsp_name, new_name );
					}
				}
				break;
		}
	}

	new_name = get_new_name(input_dp->d_namep, curr_dbip, name_tbl, used_names_tbl , cc_data );
	if( !new_name ) {
		new_name = input_dp->d_namep;
	}
	if( (new_dp = db_diradd( curr_dbip, new_name, -1L, 0, input_dp->d_flags,
				 (genptr_t)&input_dp->d_minor_type ) ) == DIR_NULL ) {
		Tcl_AppendResult(interp, "Failed to add new object name (", new_name,
				 ") to directory - aborting!!\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( new_dp, curr_dbip, &ip, &rt_uniresource ) < 0 )  {
		Tcl_AppendResult(interp, "Failed to write new object (", new_name,
				 ") to database - aborting!!\n", (char *)NULL );
		return TCL_ERROR;
	}

	return TCL_OK;
}

int
wdb_concat_cmd(struct rt_wdb	*wdbp,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	struct db_i		*newdbp;
	int			bad = 0;
	int			file_index;
	struct directory	*dp;
	Tcl_HashTable		name_tbl;
	Tcl_HashTable		used_names_tbl;
	Tcl_HashEntry		*ptr;
	Tcl_HashSearch		search;
	struct concat_data	cc_data;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc != 3 ) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_concat %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_init( &cc_data.prestr );

	if( argv[1][0] == '-' ) {

		file_index = 2;

		if( argv[1][1] == 'p' ) {
			cc_data.unique_mode = ADD_PREFIX;
		} else if( argv[1][1] == 's' ) {
			cc_data.unique_mode = ADD_SUFFIX;
		} else {
			struct bu_vls vls;

			bu_vls_init(&vls);
			bu_vls_printf(&vls, "helplib_alias wdb_concat %s", argv[0]);
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}
	} else {
		file_index = 1;
		cc_data.unique_mode = OLD_PREFIX;

		if (strcmp(argv[2], "/") != 0) {
			(void)bu_vls_strcpy(&cc_data.prestr, argv[2]);
		}

		if( wdbp->dbip->dbi_version < 5 ) {
			if ( bu_vls_strlen(&cc_data.prestr) > 12) {
				bu_vls_trunc( &cc_data.prestr, 12 );
			}
		}
	}

	/* open the input file */
	if ((newdbp = db_open(argv[file_index], "r")) == DBI_NULL) {
		perror(argv[file_index]);
		Tcl_AppendResult(interp, "concat: Can't open ",
				 argv[file_index], (char *)NULL);
		return TCL_ERROR;
	}

	if( newdbp->dbi_version > 4 && wdbp->dbip->dbi_version < 5 ) {
		Tcl_AppendResult(interp, "concat: databases are incompatible, convert ",
				 wdbp->dbip->dbi_filename, " to version 5 first",
				 (char *)NULL );
		return TCL_ERROR;
	}

	db_dirbuild( newdbp );

	cc_data.new_dbip = newdbp;
	cc_data.old_dbip = wdbp->dbip;

	/* visit each directory pointer in the input database */
	Tcl_InitHashTable( &name_tbl, TCL_STRING_KEYS );
	Tcl_InitHashTable( &used_names_tbl, TCL_STRING_KEYS );
	FOR_ALL_DIRECTORY_START( dp, newdbp )
		if( dp->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY ) {
			/* skip GLOBAL object */
			continue;
		}

	        copy_object( interp, dp, newdbp, wdbp->dbip, &name_tbl,
				     &used_names_tbl, &cc_data );
	FOR_ALL_DIRECTORY_END;

	bu_vls_free( &cc_data.prestr );
	rt_mempurge(&(newdbp->dbi_freep));

	/* Free all the directory entries, and close the input database */
	db_close(newdbp);

	db_sync(wdbp->dbip);	/* force changes to disk */

	/* Free the Hash tables */
	ptr = Tcl_FirstHashEntry( &name_tbl, &search );
	while( ptr ) {
		bu_free( (char *)Tcl_GetHashValue( ptr ), "new name" );
		ptr = Tcl_NextHashEntry( &search );
	}
	Tcl_DeleteHashTable( &name_tbl );
	Tcl_DeleteHashTable( &used_names_tbl );

	return bad ? TCL_ERROR : TCL_OK;
}

/*
 *  Concatenate another GED file into the current file.
 *
 * Usage:
 *        procname concat file.g prefix
 */
static int
wdb_concat_tcl(ClientData	clientData,
	       Tcl_Interp	*interp,
	       int		argc,
	       char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_concat_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_copyeval_cmd(struct rt_wdb	*wdbp,
		 Tcl_Interp	*interp,
		 int		argc,
		 char 		**argv)
{
	struct directory	*dp;
	struct rt_db_internal	internal, new_int;
	mat_t			start_mat;
	int			id;
	int			i;
	int			endpos;
	struct wdb_trace_data	wtd;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc < 3 || 27 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_copyeval %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* initialize wtd */
	wtd.wtd_interp = interp;
	wtd.wtd_dbip = wdbp->dbip;
	wtd.wtd_flag = WDB_CPEVAL;
	wtd.wtd_prflag = 0;

	/* check if new solid name already exists in description */
	if (db_lookup(wdbp->dbip, argv[1], LOOKUP_QUIET) != DIR_NULL) {
		Tcl_AppendResult(interp, argv[1], ": already exists\n", (char *)NULL);
		return TCL_ERROR;
	}

	MAT_IDN(start_mat);

	/* build directory pointer array for desired path */
	if (argc == 3 && strchr(argv[2], '/')) {
		char *tok;

		endpos = 0;

		tok = strtok(argv[2], "/");
		while (tok) {
			if ((wtd.wtd_obj[endpos++] = db_lookup(wdbp->dbip, tok, LOOKUP_NOISY)) == DIR_NULL)
				return TCL_ERROR;
			tok = strtok((char *)NULL, "/");
		}
	} else {
		for (i=2; i<argc; i++) {
			if ((wtd.wtd_obj[i-2] = db_lookup(wdbp->dbip, argv[i], LOOKUP_NOISY)) == DIR_NULL)
				return TCL_ERROR;
		}
		endpos = argc - 2;
	}

	wtd.wtd_objpos = endpos - 1;

	/* Make sure that final component in path is a solid */
	if ((id = rt_db_get_internal(&internal, wtd.wtd_obj[endpos - 1], wdbp->dbip, bn_mat_identity, &rt_uniresource)) < 0) {
		Tcl_AppendResult(interp, "import failure on ",
				 argv[argc-1], "\n", (char *)NULL);
		return TCL_ERROR;
	}

	if (id >= ID_COMBINATION) {
		rt_db_free_internal(&internal, &rt_uniresource);
		Tcl_AppendResult(interp, "final component on path must be a solid!!!\n", (char *)NULL );
		return TCL_ERROR;
	}

	wdb_trace(wtd.wtd_obj[0], 0, start_mat, &wtd);

	if (wtd.wtd_prflag == 0) {
		Tcl_AppendResult(interp, "PATH:  ", (char *)NULL);

		for (i=0; i<wtd.wtd_objpos; i++)
			Tcl_AppendResult(interp, "/", wtd.wtd_obj[i]->d_namep, (char *)NULL);

		Tcl_AppendResult(interp, "  NOT FOUND\n", (char *)NULL);
		rt_db_free_internal(&internal, &rt_uniresource);
		return TCL_ERROR;
	}

	/* Have found the desired path - wdb_xform is the transformation matrix */
	/* wdb_xform matrix calculated in wdb_trace() */

	/* create the new solid */
	RT_INIT_DB_INTERNAL(&new_int);
	if (rt_generic_xform(&new_int, wtd.wtd_xform,
			     &internal, 0, wdbp->dbip, &rt_uniresource)) {
		rt_db_free_internal(&internal, &rt_uniresource);
		Tcl_AppendResult(interp, "wdb_copyeval_cmd: rt_generic_xform failed\n", (char *)NULL);
		return TCL_ERROR;
	}

	if ((dp=db_diradd(wdbp->dbip, argv[1], -1L, 0,
			  wtd.wtd_obj[endpos-1]->d_flags,
			  (genptr_t)&new_int.idb_type)) == DIR_NULL) {
		rt_db_free_internal(&internal, &rt_uniresource);
		rt_db_free_internal(&new_int, &rt_uniresource);
		WDB_TCL_ALLOC_ERR_return;
	}

	if (rt_db_put_internal(dp, wdbp->dbip, &new_int, &rt_uniresource) < 0) {
		rt_db_free_internal(&internal, &rt_uniresource);
		rt_db_free_internal(&new_int, &rt_uniresource);
		WDB_TCL_WRITE_ERR_return;
	}
	rt_db_free_internal(&internal, &rt_uniresource);
	rt_db_free_internal(&new_int, &rt_uniresource);

	return TCL_OK;
}

/*
 *  
 *
 * Usage:
 *        procname copyeval new_solid path_to_solid
 */
static int
wdb_copyeval_tcl(ClientData	clientData,
		 Tcl_Interp	*interp,
		 int		argc,
		 char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_copyeval_cmd(wdbp, interp, argc-1, argv+1);
}

BU_EXTERN(int wdb_dir_check, ( struct
db_i *input_dbip, const char *name, long laddr, int len, int flags,
genptr_t ptr));

struct dir_check_stuff {
 	struct db_i	*main_dbip;
	struct rt_wdb	*wdbp;
	struct directory **dup_dirp;
};

BU_EXTERN(void wdb_dir_check5, ( struct db_i *input_dbip, const struct db5_raw_internal *rip, long addr, genptr_t ptr));

void
wdb_dir_check5(register struct db_i		*input_dbip,
	       const struct db5_raw_internal	*rip,
	       long				addr,
	       genptr_t				ptr)
{
	char			*name;
	struct directory	*dupdp;
	struct bu_vls		local;
	struct dir_check_stuff	*dcsp = (struct dir_check_stuff *)ptr;

	if (dcsp->main_dbip == DBI_NULL)
		return;

	RT_CK_DBI(input_dbip);
	RT_CK_RIP( rip );

	if( rip->h_dli == DB5HDR_HFLAGS_DLI_HEADER_OBJECT ) return;
	if( rip->h_dli == DB5HDR_HFLAGS_DLI_FREE_STORAGE ) return;

	name = (char *)rip->name.ext_buf;

	if( name == (char *)NULL ) return;

	/* do not compare _GLOBAL */
	if( rip->major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY &&
	    rip->minor_type == 0 )
		return;

	/* Add the prefix, if any */
	bu_vls_init( &local );
	if( dcsp->main_dbip->dbi_version < 5 ) {
		if (dcsp->wdbp->wdb_ncharadd > 0) {
			bu_vls_strncpy( &local, bu_vls_addr( &dcsp->wdbp->wdb_prestr ), dcsp->wdbp->wdb_ncharadd );
			bu_vls_strcat( &local, name );
		} else {
			bu_vls_strncpy( &local, name, RT_NAMESIZE );
		}
		bu_vls_trunc( &local, RT_NAMESIZE );
	} else {
		if (dcsp->wdbp->wdb_ncharadd > 0) {
			(void)bu_vls_vlscat( &local, &dcsp->wdbp->wdb_prestr );
			(void)bu_vls_strcat( &local, name );
		} else {
			(void)bu_vls_strcat( &local, name );
		}
	}
		
	/* Look up this new name in the existing (main) database */
	if ((dupdp = db_lookup(dcsp->main_dbip, bu_vls_addr( &local ), LOOKUP_QUIET)) != DIR_NULL) {
		/* Duplicate found, add it to the list */
		dcsp->wdbp->wdb_num_dups++;
		*dcsp->dup_dirp++ = dupdp;
	}
	return;
}

/*
 *			W D B _ D I R _ C H E C K
 *
 * Check a name against the global directory.
 */
int
wdb_dir_check(register struct db_i *input_dbip, register const char *name, long int laddr, int len, int flags, genptr_t ptr)
{
	struct directory	*dupdp;
	struct bu_vls		local;
	struct dir_check_stuff	*dcsp = (struct dir_check_stuff *)ptr;

	if (dcsp->main_dbip == DBI_NULL)
		return 0;

	RT_CK_DBI(input_dbip);

	/* Add the prefix, if any */
	bu_vls_init( &local );
	if( dcsp->main_dbip->dbi_version < 5 ) {
		if (dcsp->wdbp->wdb_ncharadd > 0) {
			bu_vls_strncpy( &local, bu_vls_addr( &dcsp->wdbp->wdb_prestr ), dcsp->wdbp->wdb_ncharadd );
			bu_vls_strcat( &local, name );
		} else {
			bu_vls_strncpy( &local, name, RT_NAMESIZE );
		}
		bu_vls_trunc( &local, RT_NAMESIZE );
	} else {
		if (dcsp->wdbp->wdb_ncharadd > 0) {
			bu_vls_vlscat( &local, &dcsp->wdbp->wdb_prestr );
			bu_vls_strcat( &local, name );
		} else {
			bu_vls_strcat( &local, name );
		}
	}
		
	/* Look up this new name in the existing (main) database */
	if ((dupdp = db_lookup(dcsp->main_dbip, bu_vls_addr( &local ), LOOKUP_QUIET)) != DIR_NULL) {
		/* Duplicate found, add it to the list */
		dcsp->wdbp->wdb_num_dups++;
		*dcsp->dup_dirp++ = dupdp;
	}
	bu_vls_free( &local );
	return 0;
}

int
wdb_dup_cmd(struct rt_wdb	*wdbp,
	    Tcl_Interp		*interp,
	    int			argc,
	    char		**argv)
{
	struct db_i		*newdbp = DBI_NULL;
	struct directory	**dirp0 = (struct directory **)NULL;
	struct bu_vls vls;
	struct dir_check_stuff	dcs;

	if (argc < 2 || 3 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_dup %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_trunc( &wdbp->wdb_prestr, 0 );
	if (argc == 3)
		(void)bu_vls_strcpy(&wdbp->wdb_prestr, argv[2]);

	wdbp->wdb_num_dups = 0;
	if( wdbp->dbip->dbi_version < 5 ) {
		if ((wdbp->wdb_ncharadd = bu_vls_strlen(&wdbp->wdb_prestr)) > 12) {
			wdbp->wdb_ncharadd = 12;
			bu_vls_trunc( &wdbp->wdb_prestr, 12 );
		}
	} else {
		wdbp->wdb_ncharadd = bu_vls_strlen(&wdbp->wdb_prestr);
	}

	/* open the input file */
	if ((newdbp = db_open(argv[1], "r")) == DBI_NULL) {
		perror(argv[1]);
		Tcl_AppendResult(interp, "dup: Can't open ", argv[1], (char *)NULL);
		return TCL_ERROR;
	}

	Tcl_AppendResult(interp, "\n*** Comparing ",
			wdbp->dbip->dbi_filename,
			 "  with ", argv[1], " for duplicate names\n", (char *)NULL);
	if (wdbp->wdb_ncharadd) {
		Tcl_AppendResult(interp, "  For comparison, all names in ",
				 argv[1], " were prefixed with:  ",
				 bu_vls_addr( &wdbp->wdb_prestr ), "\n", (char *)NULL);
	}

	/* Get array to hold names of duplicates */
	if ((dirp0 = wdb_getspace(wdbp->dbip, 0)) == (struct directory **) 0) {
		Tcl_AppendResult(interp, "f_dup: unable to get memory\n", (char *)NULL);
		db_close( newdbp );
		return TCL_ERROR;
	}

	/* Scan new database for overlaps */
	dcs.main_dbip = wdbp->dbip;
	dcs.wdbp = wdbp;
	dcs.dup_dirp = dirp0;
	if( newdbp->dbi_version < 5 ) {
		if (db_scan(newdbp, wdb_dir_check, 0, (genptr_t)&dcs) < 0) {
			Tcl_AppendResult(interp, "dup: db_scan failure", (char *)NULL);
			bu_free((genptr_t)dirp0, "wdb_getspace array");
			db_close(newdbp);
			return TCL_ERROR;
		}
	} else {
		if( db5_scan( newdbp, wdb_dir_check5, (genptr_t)&dcs) < 0) {
			Tcl_AppendResult(interp, "dup: db_scan failure", (char *)NULL);
			bu_free((genptr_t)dirp0, "wdb_getspace array");
			db_close(newdbp);
			return TCL_ERROR;
		}
	}
	rt_mempurge( &(newdbp->dbi_freep) );        /* didn't really build a directory */

	bu_vls_init(&vls);
	wdb_vls_col_pr4v(&vls, dirp0, (int)(dcs.dup_dirp - dirp0), 0);
	bu_vls_printf(&vls, "\n -----  %d duplicate names found  -----", wdbp->wdb_num_dups);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
	bu_free((genptr_t)dirp0, "wdb_getspace array");
	db_close(newdbp);

	return TCL_OK;
}

/*
 * Usage:
 *        procname dup file.g [prefix]
 */
static int
wdb_dup_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_dup_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_group_cmd(struct rt_wdb	*wdbp,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{
	register struct directory *dp;
	register int i;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc < 3 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_group %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* get objects to add to group */
	for (i = 2; i < argc; i++) {
		if ((dp = db_lookup(wdbp->dbip, argv[i], LOOKUP_NOISY)) != DIR_NULL) {
			if (wdb_combadd(interp, wdbp->dbip, dp, argv[1], 0,
					WMOP_UNION, 0, 0, wdbp) == DIR_NULL)
				return TCL_ERROR;
		}  else
			Tcl_AppendResult(interp, "skip member ", argv[i], "\n", (char *)NULL);
	}
	return TCL_OK;
}

/*
 * Usage:
 *        procname g groupname object1 object2 .... objectn
 */
static int
wdb_group_tcl(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_group_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_remove_cmd(struct rt_wdb	*wdbp,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	register struct directory	*dp;
	register int			i;
	int				num_deleted;
	struct rt_db_internal		intern;
	struct rt_comb_internal		*comb;
	int				ret;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc < 3 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_remove %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if ((dp = db_lookup(wdbp->dbip,  argv[1], LOOKUP_NOISY)) == DIR_NULL)
		return TCL_ERROR;

	if ((dp->d_flags & DIR_COMB) == 0) {
		Tcl_AppendResult(interp, "rm: ", dp->d_namep,
				 " is not a combination", (char *)NULL );
		return TCL_ERROR;
	}

	if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "Database read error, aborting", (char *)NULL);
		return TCL_ERROR;
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB(comb);

	/* Process each argument */
	num_deleted = 0;
	ret = TCL_OK;
	for (i = 2; i < argc; i++) {
		if (db_tree_del_dbleaf( &(comb->tree), argv[i], &rt_uniresource ) < 0) {
			Tcl_AppendResult(interp, "  ERROR_deleting ",
					 dp->d_namep, "/", argv[i],
					 "\n", (char *)NULL);
			ret = TCL_ERROR;
		} else {
			Tcl_AppendResult(interp, "deleted ",
					 dp->d_namep, "/", argv[i],
					 "\n", (char *)NULL);
			num_deleted++;
		}
	}

	if (rt_db_put_internal(dp, wdbp->dbip, &intern, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "Database write error, aborting", (char *)NULL);
		return TCL_ERROR;
	}

	return ret;
}

/*
 * Remove members from a combination.
 *
 * Usage:
 *        procname remove comb object(s)
 */
static int
wdb_remove_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_remove_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_region_cmd(struct rt_wdb	*wdbp,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	register struct directory	*dp;
	int				i;
	int				ident, air;
	char				oper;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc < 4 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_region %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

 	ident = wdbp->wdb_item_default;
 	air = wdbp->wdb_air_default;

	/* Check for even number of arguments */
	if (argc & 01) {
		Tcl_AppendResult(interp, "error in number of args!", (char *)NULL);
		return TCL_ERROR;
	}

	if (db_lookup(wdbp->dbip, argv[1], LOOKUP_QUIET) == DIR_NULL) {
		/* will attempt to create the region */
		if (wdbp->wdb_item_default) {
			struct bu_vls tmp_vls;

			wdbp->wdb_item_default++;
			bu_vls_init(&tmp_vls);
			bu_vls_printf(&tmp_vls, "Defaulting item number to %d\n",
				wdbp->wdb_item_default);
			Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			bu_vls_free(&tmp_vls);
		}
	}

	/* Get operation and solid name for each solid */
	for (i = 2; i < argc; i += 2) {
		if (argv[i][1] != '\0') {
			Tcl_AppendResult(interp, "bad operation: ", argv[i],
					 " skip member: ", argv[i+1], "\n", (char *)NULL);
			continue;
		}
		oper = argv[i][0];
		if ((dp = db_lookup(wdbp->dbip,  argv[i+1], LOOKUP_NOISY )) == DIR_NULL) {
			Tcl_AppendResult(interp, "skipping ", argv[i+1], "\n", (char *)NULL);
			continue;
		}

		if (oper != WMOP_UNION && oper != WMOP_SUBTRACT && oper != WMOP_INTERSECT) {
			struct bu_vls tmp_vls;

			bu_vls_init(&tmp_vls);
			bu_vls_printf(&tmp_vls, "bad operation: %c skip member: %s\n",
				      oper, dp->d_namep );
			Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			bu_vls_free(&tmp_vls);
			continue;
		}

		/* Adding region to region */
		if (dp->d_flags & DIR_REGION) {
			Tcl_AppendResult(interp, "Note: ", dp->d_namep,
					 " is a region\n", (char *)NULL);
		}

		if (wdb_combadd(interp, wdbp->dbip, dp,
				argv[1], 1, oper, ident, air, wdbp) == DIR_NULL) {
			Tcl_AppendResult(interp, "error in combadd", (char *)NULL);
			return TCL_ERROR;
		}
	}

	if (db_lookup(wdbp->dbip, argv[1], LOOKUP_QUIET) == DIR_NULL) {
		/* failed to create region */
		if (wdbp->wdb_item_default > 1)
			wdbp->wdb_item_default--;
		return TCL_ERROR;
	}

	return TCL_OK;
}

/*
 * Usage:
 *        procname r rname object(s)
 */
static int
wdb_region_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_region_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_comb_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	register struct directory *dp;
	char	*comb_name;
	register int	i;
	char	oper;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc < 4 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_comb %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* Check for odd number of arguments */
	if (argc & 01) {
		Tcl_AppendResult(interp, "error in number of args!", (char *)NULL);
		return TCL_ERROR;
	}

	/* Save combination name, for use inside loop */
	comb_name = argv[1];
	if ((dp=db_lookup(wdbp->dbip, comb_name, LOOKUP_QUIET)) != DIR_NULL) {
		if (!(dp->d_flags & DIR_COMB)) {
			Tcl_AppendResult(interp,
					 "ERROR: ", comb_name,
					 " is not a combination", (char *)0 );
			return TCL_ERROR;
		}
	}

	/* Get operation and solid name for each solid */
	for (i = 2; i < argc; i += 2) {
		if (argv[i][1] != '\0') {
			Tcl_AppendResult(interp, "bad operation: ", argv[i],
					 " skip member: ", argv[i+1], "\n", (char *)NULL);
			continue;
		}
		oper = argv[i][0];
		if ((dp = db_lookup(wdbp->dbip,  argv[i+1], LOOKUP_NOISY)) == DIR_NULL) {
			Tcl_AppendResult(interp, "skipping ", argv[i+1], "\n", (char *)NULL);
			continue;
		}

		if (oper != WMOP_UNION && oper != WMOP_SUBTRACT && oper != WMOP_INTERSECT) {
			struct bu_vls tmp_vls;

			bu_vls_init(&tmp_vls);
			bu_vls_printf(&tmp_vls, "bad operation: %c skip member: %s\n",
				      oper, dp->d_namep);
			Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			continue;
		}

		if (wdb_combadd(interp, wdbp->dbip, dp, comb_name, 0, oper, 0, 0, wdbp) == DIR_NULL) {
			Tcl_AppendResult(interp, "error in combadd", (char *)NULL);
			return TCL_ERROR;
		}
	}

	if (db_lookup(wdbp->dbip, comb_name, LOOKUP_QUIET) == DIR_NULL) {
		Tcl_AppendResult(interp, "Error:  ", comb_name,
				 " not created", (char *)NULL);
		return TCL_ERROR;
	}

	return TCL_OK;
}

/*
 * Create or add to the end of a combination, with one or more solids,
 * with explicitly specified operations.
 *
 * Usage:
 *        procname comb comb_name opr1 sol1 opr2 sol2 ... oprN solN
 */
static int
wdb_comb_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_comb_cmd(wdbp, interp, argc-1, argv+1);
}

static void
wdb_find_ref(struct db_i		*dbip,
	     struct rt_comb_internal	*comb,
	     union tree			*comb_leaf,
	     genptr_t			object,
	     genptr_t			comb_name_ptr,
	     genptr_t			user_ptr3)
{
	char *obj_name;
	char *comb_name;
	Tcl_Interp *interp = (Tcl_Interp *)user_ptr3;

	RT_CK_TREE(comb_leaf);

	obj_name = (char *)object;
	if (strcmp(comb_leaf->tr_l.tl_name, obj_name))
		return;

	comb_name = (char *)comb_name_ptr;

	Tcl_AppendElement(interp, comb_name);
}

HIDDEN union tree *
facetize_region_end( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
{
	struct bu_list		vhead;
	union tree		**facetize_tree;

	facetize_tree = (union tree **)client_data;
	BU_LIST_INIT( &vhead );

	if( curtree->tr_op == OP_NOP )  return  curtree;

	if( *facetize_tree )  {
		union tree	*tr;
		tr = (union tree *)bu_calloc(1, sizeof(union tree), "union tree");
		tr->magic = RT_TREE_MAGIC;
		tr->tr_op = OP_UNION;
		tr->tr_b.tb_regionp = REGION_NULL;
		tr->tr_b.tb_left = *facetize_tree;
		tr->tr_b.tb_right = curtree;
		*facetize_tree = tr;
	} else {
		*facetize_tree = curtree;
	}

	/* Tree has been saved, and will be freed later */
	return( TREE_NULL );
}

int
wdb_facetize_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	int			i;
	register int		c;
	int			triangulate;
	char			*newname;
	struct rt_db_internal	intern;
	struct directory	*dp;
	int			failed;
	int			nmg_use_tnurbs = 0;
	int			make_bot;
	struct db_tree_state	init_state;
	struct db_i		*dbip;
	union tree		*facetize_tree;
	struct model		*nmg_model;

	if(argc < 3){
		Tcl_AppendResult(interp,
				 "Usage: ",
				 argv[0],
				 " new_object old_object [old_object2 old_object3 ...]\n",
				 (char *)NULL );
	  return TCL_ERROR;
	}

	dbip = wdbp->dbip;
	RT_CHECK_DBI(dbip);

	db_init_db_tree_state( &init_state, dbip, wdbp->wdb_resp );

	/* Establish tolerances */
	init_state.ts_ttol = &wdbp->wdb_ttol;
	init_state.ts_tol = &wdbp->wdb_tol;

	/* Initial vaues for options, must be reset each time */
	triangulate = 0;
	make_bot = 1;

	/* Parse options. */
	bu_optind = 1;		/* re-init bu_getopt() */
	while( (c=bu_getopt(argc,argv,"ntT")) != EOF )  {
		switch(c)  {
		case 'n':
			make_bot = 0;
			break;
		case 'T':
			triangulate = 1;
			break;
		case 't':
			nmg_use_tnurbs = 1;
			break;
		default:
		  {
		    struct bu_vls tmp_vls;

		    bu_vls_init(&tmp_vls);
		    bu_vls_printf(&tmp_vls, "option '%c' unknown\n", c);
		    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls),
				     "Usage: facetize [-ntT] object(s)\n",
				     "\t-n make NMG primitives rather than BOT's\n",
				     "\t-t Perform CSG-to-tNURBS conversion\n",
				     "\t-T enable triangulator\n", (char *)NULL);
		    bu_vls_free(&tmp_vls);
		  }
		  break;
		}
	}
	argc -= bu_optind;
	argv += bu_optind;
	if( argc < 0 ){
	  Tcl_AppendResult(interp, "facetize: missing argument\n", (char *)NULL);
	  return TCL_ERROR;
	}

	newname = argv[0];
	argv++;
	argc--;
	if( argc < 0 ){
	  Tcl_AppendResult(interp, "facetize: missing argument\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( db_lookup( dbip, newname, LOOKUP_QUIET ) != DIR_NULL )  {
	  Tcl_AppendResult(interp, "error: solid '", newname,
			   "' already exists, aborting\n", (char *)NULL);
	  return TCL_ERROR;
	}

	{
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls,
			"facetize:  tessellating primitives with tolerances a=%g, r=%g, n=%g\n",
			wdbp->wdb_ttol.abs, wdbp->wdb_ttol.rel, wdbp->wdb_ttol.norm );
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
	facetize_tree = (union tree *)0;
  	nmg_model = nmg_mm();
	init_state.ts_m = &nmg_model;

	i = db_walk_tree( dbip, argc, (const char **)argv,
		1,
		&init_state,
		0,			/* take all regions */
		facetize_region_end,
  		nmg_use_tnurbs ?
  			nmg_booltree_leaf_tnurb :
			nmg_booltree_leaf_tess,
		(genptr_t)&facetize_tree
		);


	if( i < 0 )  {
	  Tcl_AppendResult(interp, "facetize: error in db_walk_tree()\n", (char *)NULL);
	  /* Destroy NMG */
	  nmg_km( nmg_model );
	  return TCL_ERROR;
	}

	if( facetize_tree )
	{
		/* Now, evaluate the boolean tree into ONE region */
		Tcl_AppendResult(interp, "facetize:  evaluating boolean expressions\n", (char *)NULL);

		if( BU_SETJUMP )
		{
			BU_UNSETJUMP;
			Tcl_AppendResult(interp, "WARNING: facetization failed!!!\n", (char *)NULL );
			if( facetize_tree )
				db_free_tree( facetize_tree, &rt_uniresource );
			facetize_tree = (union tree *)NULL;
			nmg_km( nmg_model );
			nmg_model = (struct model *)NULL;
			return TCL_ERROR;
		}

		failed = nmg_boolean( facetize_tree, nmg_model, &wdbp->wdb_tol, &rt_uniresource );
		BU_UNSETJUMP;
	}
	else
		failed = 1;

	if( failed )  {
	  Tcl_AppendResult(interp, "facetize:  no resulting region, aborting\n", (char *)NULL);
	  if( facetize_tree )
		db_free_tree( facetize_tree, &rt_uniresource );
	  facetize_tree = (union tree *)NULL;
	  nmg_km( nmg_model );
	  nmg_model = (struct model *)NULL;
	  return TCL_ERROR;
	}
	/* New region remains part of this nmg "model" */
	NMG_CK_REGION( facetize_tree->tr_d.td_r );
	Tcl_AppendResult(interp, "facetize:  ", facetize_tree->tr_d.td_name,
			 "\n", (char *)NULL);

	/* Triangulate model, if requested */
	if( triangulate && !make_bot )
	{
		Tcl_AppendResult(interp, "facetize:  triangulating resulting object\n", (char *)NULL);
		if( BU_SETJUMP )
		{
			BU_UNSETJUMP;
			Tcl_AppendResult(interp, "WARNING: triangulation failed!!!\n", (char *)NULL );
			if( facetize_tree )
				db_free_tree( facetize_tree, &rt_uniresource );
			facetize_tree = (union tree *)NULL;
			nmg_km( nmg_model );
			nmg_model = (struct model *)NULL;
			return TCL_ERROR;
		}
		nmg_triangulate_model( nmg_model , &wdbp->wdb_tol );
		BU_UNSETJUMP;
	}

	if( make_bot )
	{
		struct rt_bot_internal *bot;
		struct nmgregion *r;
		struct shell *s;

		Tcl_AppendResult(interp, "facetize:  converting to BOT format\n", (char *)NULL);

		r = BU_LIST_FIRST( nmgregion, &nmg_model->r_hd );
		s = BU_LIST_FIRST( shell, &r->s_hd );
		bot = (struct rt_bot_internal *)nmg_bot( s, &wdbp->wdb_tol );
		nmg_km( nmg_model );
		nmg_model = (struct model *)NULL;

		/* Export BOT as a new solid */
		RT_INIT_DB_INTERNAL(&intern);
		intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		intern.idb_type = ID_BOT;
		intern.idb_meth = &rt_functab[ID_BOT];
		intern.idb_ptr = (genptr_t) bot;
	}
	else
	{

		Tcl_AppendResult(interp, "facetize:  converting NMG to database format\n", (char *)NULL);

		/* Export NMG as a new solid */
		RT_INIT_DB_INTERNAL(&intern);
		intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		intern.idb_type = ID_NMG;
		intern.idb_meth = &rt_functab[ID_NMG];
		intern.idb_ptr = (genptr_t)nmg_model;
		nmg_model = (struct model *)NULL;
	}

	if( (dp=db_diradd( dbip, newname, -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", newname, " to directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		Tcl_AppendResult(interp, "Failed to write ", newname, " to database\n", (char *)NULL );
		rt_db_free_internal( &intern, &rt_uniresource );
		return TCL_ERROR;
	}
	
	facetize_tree->tr_d.td_r = (struct nmgregion *)NULL;

	/* Free boolean tree, and the regions in it */
	db_free_tree( facetize_tree, &rt_uniresource );
    	facetize_tree = (union tree *)NULL;

	return TCL_OK;
}

int
wdb_find_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	register int				i,k;
	register struct directory		*dp;
	struct rt_db_internal			intern;
	register struct rt_comb_internal	*comb=(struct rt_comb_internal *)NULL;

	if (argc < 2 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_find %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* Examine all COMB nodes */
	for (i = 0; i < RT_DBNHASH; i++) {
		for (dp = wdbp->dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw) {
			if (!(dp->d_flags & DIR_COMB))
				continue;

			if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource) < 0) {
				Tcl_AppendResult(interp, "Database read error, aborting", (char *)NULL);
				return TCL_ERROR;
			}

			comb = (struct rt_comb_internal *)intern.idb_ptr;
			for (k=1; k<argc; k++)
				db_tree_funcleaf(wdbp->dbip, comb, comb->tree, wdb_find_ref, (genptr_t)argv[k], (genptr_t)dp->d_namep, (genptr_t)interp);

			rt_db_free_internal(&intern, &rt_uniresource);
		}
	}

	return TCL_OK;
}

static int
wdb_facetize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_facetize_cmd(wdbp, interp, argc-1, argv+1);
}


/*
 * Usage:
 *        procname find object(s)
 */
static int
wdb_find_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_find_cmd(wdbp, interp, argc-1, argv+1);
}

struct wdb_id_names {
	struct bu_list l;
	struct bu_vls name;		/* name associated with region id */
};

struct wdb_id_to_names {
	struct bu_list l;
	int id;				/* starting id (i.e. region id or air code) */
	struct wdb_id_names headName;	/* head of list of names */
};

int
wdb_which_cmd(struct rt_wdb	*wdbp,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{
	register int	i,j;
	register struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	struct wdb_id_to_names headIdName;
	struct wdb_id_to_names *itnp;
	struct wdb_id_names *inp;
	int isAir;
	int sflag;
	

	if (argc < 2 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_%s %s", argv[0], argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (!strcmp(argv[0], "whichair"))
		isAir = 1;
	else
		isAir = 0;

	if (strcmp(argv[1], "-s") == 0) {
		--argc;
		++argv;

		if (argc < 2) {
			struct bu_vls vls;

			bu_vls_init(&vls);
			bu_vls_printf(&vls, "helplib_alias wdb_%s %s", argv[-1], argv[-1]);
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		sflag = 1;
	} else {
		sflag = 0;
	}

	BU_LIST_INIT(&headIdName.l);

	/* Build list of id_to_names */
	for (j=1; j<argc; j++) {
		int n;
		int start, end;
		int range;
		int k;

		n = sscanf(argv[j], "%d%*[:-]%d", &start, &end);
		switch (n) {
		case 1:
			for (BU_LIST_FOR(itnp,wdb_id_to_names,&headIdName.l))
				if (itnp->id == start)
					break;

			/* id not found */
			if (BU_LIST_IS_HEAD(itnp,&headIdName.l)) {
				BU_GETSTRUCT(itnp,wdb_id_to_names);
				itnp->id = start;
				BU_LIST_INSERT(&headIdName.l,&itnp->l);
				BU_LIST_INIT(&itnp->headName.l);
			}

			break;
		case 2:
			if (start < end)
				range = end - start + 1;
			else if (end < start) {
				range = start - end + 1;
				start = end;
			} else
				range = 1;

			for (k = 0; k < range; ++k) {
				int id = start + k;

				for (BU_LIST_FOR(itnp,wdb_id_to_names,&headIdName.l))
					if (itnp->id == id)
						break;

				/* id not found */
				if (BU_LIST_IS_HEAD(itnp,&headIdName.l)) {
					BU_GETSTRUCT(itnp,wdb_id_to_names);
					itnp->id = id;
					BU_LIST_INSERT(&headIdName.l,&itnp->l);
					BU_LIST_INIT(&itnp->headName.l);
				}
			}

			break;
		}
	}

	/* Examine all COMB nodes */
	for (i = 0; i < RT_DBNHASH; i++) {
		for (dp = wdbp->dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw) {
			if (!(dp->d_flags & DIR_REGION))
				continue;

			if (rt_db_get_internal( &intern, dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource ) < 0) {
				Tcl_AppendResult(interp, "Database read error, aborting", (char *)NULL);
				return TCL_ERROR;
			}
			comb = (struct rt_comb_internal *)intern.idb_ptr;
			/* check to see if the region id or air code matches one in our list */
			for (BU_LIST_FOR(itnp,wdb_id_to_names,&headIdName.l)) {
				if ((!isAir && comb->region_id == itnp->id) ||
				    (isAir && comb->aircode == itnp->id)) {
					/* add region name to our name list for this region */
					BU_GETSTRUCT(inp,wdb_id_names);
					bu_vls_init(&inp->name);
					bu_vls_strcpy(&inp->name, dp->d_namep);
					BU_LIST_INSERT(&itnp->headName.l,&inp->l);
					break;
				}
			}

			rt_comb_ifree( &intern, &rt_uniresource );
		}
	}

	/* place data in interp and free memory */
	 while (BU_LIST_WHILE(itnp,wdb_id_to_names,&headIdName.l)) {
		if (!sflag) {
			struct bu_vls vls;

			bu_vls_init(&vls);
			bu_vls_printf(&vls, "Region[s] with %s %d:\n",
				      isAir ? "air code" : "ident", itnp->id);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);
		}

		while (BU_LIST_WHILE(inp,wdb_id_names,&itnp->headName.l)) {
			if (sflag)
				Tcl_AppendElement(interp, bu_vls_addr(&inp->name));
			else
				Tcl_AppendResult(interp, "   ", bu_vls_addr(&inp->name),
						 "\n", (char *)NULL);

			BU_LIST_DEQUEUE(&inp->l);
			bu_vls_free(&inp->name);
			bu_free((genptr_t)inp, "which: inp");
		}

		BU_LIST_DEQUEUE(&itnp->l);
		bu_free((genptr_t)itnp, "which: itnp");
	}

	return TCL_OK;
}

/*
 * Usage:
 *        procname whichair/whichid [-s] id(s)
 */
static int
wdb_which_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_wdb	*wdbp = (struct rt_wdb *)clientData;

	return wdb_which_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_title_cmd(struct rt_wdb	*wdbp,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{
	struct bu_vls	title;
	int		bad = 0;

	RT_CK_WDB(wdbp);
	RT_CK_DBI(wdbp->dbip);

	if (argc < 1 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_title %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* get title */
	if (argc == 1) {
		Tcl_AppendResult(interp, wdbp->dbip->dbi_title, (char *)NULL);
		return TCL_OK;
	}

	WDB_TCL_CHECK_READ_ONLY;

	/* set title */
	bu_vls_init(&title);
	bu_vls_from_argv(&title, argc-1, argv+1);

	if (db_update_ident(wdbp->dbip, bu_vls_addr(&title), wdbp->dbip->dbi_base2local) < 0) {
		Tcl_AppendResult(interp, "Error: unable to change database title");
		bad = 1;
	}

	bu_vls_free(&title);
	return bad ? TCL_ERROR : TCL_OK;
}

/*
 * Change or return the database title.
 *
 * Usage:
 *        procname title [description]
 */
static int
wdb_title_tcl(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_title_cmd(wdbp, interp, argc-1, argv+1);
}

static int
wdb_list_children(struct rt_wdb		*wdbp,
		  Tcl_Interp		*interp,
		  register struct directory *dp)
{
	register int			i;
	struct rt_db_internal		intern;
	struct rt_comb_internal		*comb;

	if (!(dp->d_flags & DIR_COMB))
		return TCL_OK;

	if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "Database read error, aborting", (char *)NULL);
		return TCL_ERROR;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;

	if (comb->tree) {
		struct bu_vls vls;
		int node_count;
		int actual_count;
		struct rt_tree_array *rt_tree_array;

		if (comb->tree && db_ck_v4gift_tree(comb->tree) < 0) {
			db_non_union_push(comb->tree, &rt_uniresource);
			if (db_ck_v4gift_tree(comb->tree) < 0) {
				Tcl_AppendResult(interp, "Cannot flatten tree for listing", (char *)NULL);
				return TCL_ERROR;
			}
		}
		node_count = db_tree_nleaves(comb->tree);
		if (node_count > 0) {
			rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count,
									   sizeof( struct rt_tree_array ), "tree list" );
			actual_count = (struct rt_tree_array *)db_flatten_tree(
				rt_tree_array, comb->tree, OP_UNION,
				1, &rt_uniresource ) - rt_tree_array;
			BU_ASSERT_PTR( actual_count, ==, node_count );
			comb->tree = TREE_NULL;
		} else {
			actual_count = 0;
			rt_tree_array = NULL;
		}

		bu_vls_init(&vls);
		for (i=0 ; i<actual_count ; i++) {
			char op;

			switch (rt_tree_array[i].tl_op) {
			case OP_UNION:
				op = 'u';
				break;
			case OP_INTERSECT:
				op = '+';
				break;
			case OP_SUBTRACT:
				op = '-';
				break;
			default:
				op = '?';
				break;
			}

			bu_vls_printf(&vls, "{%c %s} ", op, rt_tree_array[i].tl_tree->tr_l.tl_name);
			db_free_tree( rt_tree_array[i].tl_tree, &rt_uniresource );
		}
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)0);
		bu_vls_free(&vls);

		if (rt_tree_array)
			bu_free((char *)rt_tree_array, "printnode: rt_tree_array");
	}
	rt_db_free_internal(&intern, &rt_uniresource);

	return TCL_OK;
}

int
wdb_lt_cmd(struct rt_wdb	*wdbp,
	   Tcl_Interp		*interp,
	   int			argc,
	   char 		**argv)
{
	register struct directory	*dp;
	struct bu_vls			vls;

	if (argc != 2)
		goto bad;

	if ((dp = db_lookup(wdbp->dbip, argv[1], LOOKUP_NOISY)) == DIR_NULL)
		goto bad;

	return wdb_list_children(wdbp, interp, dp);

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias wdb_lt %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Usage:
 *        procname lt object
 */
static int
wdb_lt_tcl(ClientData	clientData,
	   Tcl_Interp	*interp,
	   int     	argc,
	   char    	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_lt_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_version_cmd(struct rt_wdb	*wdbp,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	struct bu_vls	vls;

	bu_vls_init(&vls);

	if (argc != 1) {
		bu_vls_printf(&vls, "helplib_alias wdb_version %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_printf(&vls, "%d", wdbp->dbip->dbi_version);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)0);
	bu_vls_free(&vls);

	return TCL_OK;
}

/*
 * Usage:
 *        procname version
 */
static int
wdb_version_tcl(ClientData	clientData,
		Tcl_Interp	*interp,
		int     	argc,
		char    	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_version_cmd(wdbp, interp, argc-1, argv+1);
}

/*
 *			W D B _ P R I N T _ N O D E
 *
 *  NON-PARALLEL due to rt_uniresource
 */
static void
wdb_print_node(struct rt_wdb		*wdbp,
	       Tcl_Interp		*interp,
	       register struct directory *dp,
	       int			pathpos,
	       char			prefix,
	       int			cflag)
{	
	register int			i;
	register struct directory	*nextdp;
	struct rt_db_internal		intern;
	struct rt_comb_internal		*comb;

	if (cflag && !(dp->d_flags & DIR_COMB))
		return;

	for (i=0; i<pathpos; i++) 
		Tcl_AppendResult(interp, "\t", (char *)NULL);

	if (prefix) {
		struct bu_vls tmp_vls;

		bu_vls_init(&tmp_vls);
		bu_vls_printf(&tmp_vls, "%c ", prefix);
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);
	}

	Tcl_AppendResult(interp, dp->d_namep, (char *)NULL);
	/* Output Comb and Region flags (-F?) */
	if(dp->d_flags & DIR_COMB)
		Tcl_AppendResult(interp, "/", (char *)NULL);
	if(dp->d_flags & DIR_REGION)
		Tcl_AppendResult(interp, "R", (char *)NULL);

	Tcl_AppendResult(interp, "\n", (char *)NULL);

	if(!(dp->d_flags & DIR_COMB))
		return;

	/*
	 *  This node is a combination (eg, a directory).
	 *  Process all the arcs (eg, directory members).
	 */

	if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "Database read error, aborting", (char *)NULL);
		return;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;

	if (comb->tree) {
		int node_count;
		int actual_count;
		struct rt_tree_array *rt_tree_array;

		if (comb->tree && db_ck_v4gift_tree(comb->tree) < 0) {
			db_non_union_push(comb->tree, &rt_uniresource);
			if (db_ck_v4gift_tree(comb->tree) < 0) {
				Tcl_AppendResult(interp, "Cannot flatten tree for listing", (char *)NULL);
				return;
			}
		}
		node_count = db_tree_nleaves(comb->tree);
		if (node_count > 0) {
			rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count,
									   sizeof( struct rt_tree_array ), "tree list" );
			actual_count = (struct rt_tree_array *)db_flatten_tree(
				rt_tree_array, comb->tree, OP_UNION,
				1, &rt_uniresource ) - rt_tree_array;
			BU_ASSERT_PTR( actual_count, ==, node_count );
			comb->tree = TREE_NULL;
		} else {
			actual_count = 0;
			rt_tree_array = NULL;
		}

		for (i=0 ; i<actual_count ; i++) {
			char op;

			switch (rt_tree_array[i].tl_op) {
			case OP_UNION:
				op = 'u';
				break;
			case OP_INTERSECT:
				op = '+';
				break;
			case OP_SUBTRACT:
				op = '-';
				break;
			default:
				op = '?';
				break;
			}

			if ((nextdp = db_lookup(wdbp->dbip, rt_tree_array[i].tl_tree->tr_l.tl_name, LOOKUP_NOISY)) == DIR_NULL) {
				int j;
				struct bu_vls tmp_vls;
  			
				for (j=0; j<pathpos+1; j++) 
					Tcl_AppendResult(interp, "\t", (char *)NULL);

				bu_vls_init(&tmp_vls);
				bu_vls_printf(&tmp_vls, "%c ", op);
				Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
				bu_vls_free(&tmp_vls);

				Tcl_AppendResult(interp, rt_tree_array[i].tl_tree->tr_l.tl_name, "\n", (char *)NULL);
			} else
				wdb_print_node(wdbp, interp, nextdp, pathpos+1, op, cflag);
			db_free_tree( rt_tree_array[i].tl_tree, &rt_uniresource );
		}
		if(rt_tree_array) bu_free((char *)rt_tree_array, "printnode: rt_tree_array");
	}
	rt_db_free_internal(&intern, &rt_uniresource);
}

/*
 * Usage:
 *        procname track args
 */
static int
wdb_track_tcl(ClientData clientData,
	      Tcl_Interp *interp,
	      int        argc,
	      char       **argv) {
  struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

  return wdb_track_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_tree_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	register struct directory	*dp;
	register int			j;
	int				cflag = 0;

	if (argc < 2 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_tree %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (argv[1][0] == '-' && argv[1][1] == 'c') {
		cflag = 1;
		--argc;
		++argv;
	}

	for (j = 1; j < argc; j++) {
		if (j > 1)
			Tcl_AppendResult(interp, "\n", (char *)NULL);
		if ((dp = db_lookup(wdbp->dbip, argv[j], LOOKUP_NOISY)) == DIR_NULL)
			continue;
		wdb_print_node(wdbp, interp, dp, 0, 0, cflag);
	}

	return TCL_OK;
}

/*
 * Usage:
 *        procname tree object(s)
 */
static int
wdb_tree_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_tree_cmd(wdbp, interp, argc-1, argv+1);
}

/*
 *  			W D B _ C O L O R _ P U T R E C
 *  
 *  Used to create a database record and get it written out to a granule.
 *  In some cases, storage will need to be allocated.
 */
static void
wdb_color_putrec(register struct mater	*mp,
		 Tcl_Interp		*interp,
		 struct db_i		*dbip)
{
	struct directory dir;
	union record rec;

	/* we get here only if database is NOT read-only */

	rec.md.md_id = ID_MATERIAL;
	rec.md.md_low = mp->mt_low;
	rec.md.md_hi = mp->mt_high;
	rec.md.md_r = mp->mt_r;
	rec.md.md_g = mp->mt_g;
	rec.md.md_b = mp->mt_b;

	/* Fake up a directory entry for db_* routines */
	RT_DIR_SET_NAMEP( &dir, "color_putrec" );
	dir.d_magic = RT_DIR_MAGIC;
	dir.d_flags = 0;

	if (mp->mt_daddr == MATER_NO_ADDR) {
		/* Need to allocate new database space */
		if (db_alloc(dbip, &dir, 1) < 0) {
			Tcl_AppendResult(interp,
					 "Database alloc error, aborting",
					 (char *)NULL);
			return;
		}
		mp->mt_daddr = dir.d_addr;
	} else {
		dir.d_addr = mp->mt_daddr;
		dir.d_len = 1;
	}

	if (db_put(dbip, &dir, &rec, 0, 1) < 0) {
		Tcl_AppendResult(interp,
				 "Database write error, aborting",
				 (char *)NULL);
		return;
	}
}

/*
 *  			W D B _ C O L O R _ Z A P R E C
 *  
 *  Used to release database resources occupied by a material record.
 */
static void
wdb_color_zaprec(register struct mater	*mp,
		 Tcl_Interp		*interp,
		 struct db_i		*dbip)
{
	struct directory dir;

	/* we get here only if database is NOT read-only */
	if (mp->mt_daddr == MATER_NO_ADDR)
		return;

	dir.d_magic = RT_DIR_MAGIC;
	RT_DIR_SET_NAMEP( &dir, "color_zaprec" );
	dir.d_len = 1;
	dir.d_addr = mp->mt_daddr;
	dir.d_flags = 0;

	if (db_delete(dbip, &dir) < 0) {
		Tcl_AppendResult(interp,
				 "Database delete error, aborting",
				 (char *)NULL);
		return;
	}
	mp->mt_daddr = MATER_NO_ADDR;
}

int
wdb_color_cmd(struct rt_wdb	*wdbp,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{
	register struct mater *newp,*next_mater;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc != 6) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_color %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (wdbp->dbip->dbi_version < 5) {
		/* Delete all color records from the database */
		newp = rt_material_head;
		while (newp != MATER_NULL) {
			next_mater = newp->mt_forw;
			wdb_color_zaprec(newp, interp, wdbp->dbip);
			newp = next_mater;
		}

		/* construct the new color record */
		BU_GETSTRUCT(newp, mater);
		newp->mt_low = atoi(argv[1]);
		newp->mt_high = atoi(argv[2]);
		newp->mt_r = atoi(argv[3]);
		newp->mt_g = atoi(argv[4]);
		newp->mt_b = atoi(argv[5]);
		newp->mt_daddr = MATER_NO_ADDR;		/* not in database yet */

		/* Insert new color record in the in-memory list */
		rt_insert_color(newp);

		/* Write new color records for all colors in the list */
		newp = rt_material_head;
		while (newp != MATER_NULL) {
			next_mater = newp->mt_forw;
			wdb_color_putrec(newp, interp, wdbp->dbip);
			newp = next_mater;
		}
	} else {
		struct bu_vls colors;

		/* construct the new color record */
		BU_GETSTRUCT(newp, mater);
		newp->mt_low = atoi(argv[1]);
		newp->mt_high = atoi(argv[2]);
		newp->mt_r = atoi(argv[3]);
		newp->mt_g = atoi(argv[4]);
		newp->mt_b = atoi(argv[5]);
		newp->mt_daddr = MATER_NO_ADDR;		/* not in database yet */

		/* Insert new color record in the in-memory list */
		rt_insert_color(newp);

		/*
		 * Gather color records from the in-memory list to build
		 * the _GLOBAL objects regionid_colortable attribute.
		 */
		newp = rt_material_head;
		bu_vls_init(&colors);
		while (newp != MATER_NULL) {
			next_mater = newp->mt_forw;
			bu_vls_printf(&colors, "{%d %d %d %d %d} ", newp->mt_low, newp->mt_high,
				      newp->mt_r, newp->mt_g, newp->mt_b);
			newp = next_mater;
		}

		db5_update_attribute("_GLOBAL", "regionid_colortable", bu_vls_addr(&colors), wdbp->dbip);
		bu_vls_free(&colors);
	}

	return TCL_OK;
}

/*
 * Usage:
 *        procname color low high r g b
 */
static int
wdb_color_tcl(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_color_cmd(wdbp, interp, argc-1, argv+1);
}

static void
wdb_pr_mater(register struct mater	*mp,
	     Tcl_Interp			*interp,
	     int			*ccp,
	     int			*clp)
{
	char buf[128];
	struct bu_vls vls;

	bu_vls_init(&vls);

	(void)sprintf(buf, "%5d..%d", mp->mt_low, mp->mt_high );
	wdb_vls_col_item(&vls, buf, ccp, clp);
	(void)sprintf( buf, "%3d,%3d,%3d", mp->mt_r, mp->mt_g, mp->mt_b);
	wdb_vls_col_item(&vls, buf, ccp, clp);
	wdb_vls_col_eol(&vls, ccp, clp);

	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
}

int
wdb_prcolor_cmd(struct rt_wdb	*wdbp,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	register struct mater *mp;
	int col_count = 0;
	int col_len = 0;

	if (argc != 1) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_prcolor %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (rt_material_head == MATER_NULL) {
		Tcl_AppendResult(interp, "none", (char *)NULL);
		return TCL_OK;
	}

	for (mp = rt_material_head; mp != MATER_NULL; mp = mp->mt_forw)
		wdb_pr_mater(mp, interp, &col_count, &col_len);

	return TCL_OK;
}

/*
 * Usage:
 *        procname prcolor
 */
static int
wdb_prcolor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_prcolor_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_tol_cmd(struct rt_wdb	*wdbp,
	    Tcl_Interp		*interp,
	    int			argc,
	    char		**argv)
{
	struct bu_vls vls;
	double	f;

	if (argc < 1 || 3 < argc){
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_tol %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* print all tolerance settings */
	if (argc == 1) {
		Tcl_AppendResult(interp, "Current tolerance settings are:\n", (char *)NULL);
		Tcl_AppendResult(interp, "Tesselation tolerances:\n", (char *)NULL );

		if (wdbp->wdb_ttol.abs > 0.0) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "\tabs %g mm\n", wdbp->wdb_ttol.abs);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);
		} else {
			Tcl_AppendResult(interp, "\tabs None\n", (char *)NULL);
		}

		if (wdbp->wdb_ttol.rel > 0.0) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "\trel %g (%g%%)\n",
				      wdbp->wdb_ttol.rel, wdbp->wdb_ttol.rel * 100.0 );
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);
		} else {
			Tcl_AppendResult(interp, "\trel None\n", (char *)NULL);
		}

		if (wdbp->wdb_ttol.norm > 0.0) {
			int	deg, min;
			double	sec;

			bu_vls_init(&vls);
			sec = wdbp->wdb_ttol.norm * bn_radtodeg;
			deg = (int)(sec);
			sec = (sec - (double)deg) * 60;
			min = (int)(sec);
			sec = (sec - (double)min) * 60;

			bu_vls_printf(&vls, "\tnorm %g degrees (%d deg %d min %g sec)\n",
				      wdbp->wdb_ttol.norm * bn_radtodeg, deg, min, sec);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);
		} else {
			Tcl_AppendResult(interp, "\tnorm None\n", (char *)NULL);
		}

		bu_vls_init(&vls);
		bu_vls_printf(&vls,"Calculational tolerances:\n");
		bu_vls_printf(&vls,
			      "\tdistance = %g mm\n\tperpendicularity = %g (cosine of %g degrees)",
			      wdbp->wdb_tol.dist, wdbp->wdb_tol.perp,
			      acos(wdbp->wdb_tol.perp)*bn_radtodeg);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	/* get the specified tolerance */
	if (argc == 2) {
		int status = TCL_OK;

		bu_vls_init(&vls);

		switch (argv[1][0]) {
		case 'a':
			if (wdbp->wdb_ttol.abs > 0.0)
				bu_vls_printf(&vls, "%g", wdbp->wdb_ttol.abs);
			else
				bu_vls_printf(&vls, "None");
			break;
		case 'r':
			if (wdbp->wdb_ttol.rel > 0.0)
				bu_vls_printf(&vls, "%g", wdbp->wdb_ttol.rel);
			else
				bu_vls_printf(&vls, "None");
			break;
		case 'n':
			if (wdbp->wdb_ttol.norm > 0.0)
				bu_vls_printf(&vls, "%g", wdbp->wdb_ttol.norm);
			else
				bu_vls_printf(&vls, "None");
			break;
		case 'd':
			bu_vls_printf(&vls, "%g", wdbp->wdb_tol.dist);
			break;
		case 'p':
			bu_vls_printf(&vls, "%g", wdbp->wdb_tol.perp);
			break;
		default:
			bu_vls_printf(&vls, "unrecognized tolerance type - %s", argv[1]);
			status = TCL_ERROR;
			break;
		}

		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
		return status;
	}

	/* set the specified tolerance */
	if (sscanf(argv[2], "%lf", &f) != 1) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "bad tolerance - %s", argv[2]);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	switch (argv[1][0]) {
	case 'a':
		/* Absolute tol */
		if (f <= 0.0)
			wdbp->wdb_ttol.abs = 0.0;
		else
			wdbp->wdb_ttol.abs = f;
		break;
	case 'r':
		if (f < 0.0 || f >= 1.0) {
			   Tcl_AppendResult(interp,
					    "relative tolerance must be between 0 and 1, not changed\n",
					    (char *)NULL);
			   return TCL_ERROR;
		}
		/* Note that a value of 0.0 will disable relative tolerance */
		wdbp->wdb_ttol.rel = f;
		break;
	case 'n':
		/* Normal tolerance, in degrees */
		if (f < 0.0 || f > 90.0) {
			Tcl_AppendResult(interp,
					 "Normal tolerance must be in positive degrees, < 90.0\n",
					 (char *)NULL);
			return TCL_ERROR;
		}
		/* Note that a value of 0.0 or 360.0 will disable this tol */
		wdbp->wdb_ttol.norm = f * bn_degtorad;
		break;
	case 'd':
		/* Calculational distance tolerance */
		if (f < 0.0) {
			Tcl_AppendResult(interp,
					 "Calculational distance tolerance must be positive\n",
					 (char *)NULL);
			return TCL_ERROR;
		}
		wdbp->wdb_tol.dist = f;
		wdbp->wdb_tol.dist_sq = wdbp->wdb_tol.dist * wdbp->wdb_tol.dist;
		break;
	case 'p':
		/* Calculational perpendicularity tolerance */
		if (f < 0.0 || f > 1.0) {
			Tcl_AppendResult(interp,
					 "Calculational perpendicular tolerance must be from 0 to 1\n",
					 (char *)NULL);
			return TCL_ERROR;
		}
		wdbp->wdb_tol.perp = f;
		wdbp->wdb_tol.para = 1.0 - f;
		break;
	default:
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "unrecognized tolerance type - %s", argv[1]);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	return TCL_OK;
}

/*
 * Usage:
 *        procname tol [abs|rel|norm|dist|perp [#]]
 *
 *  abs #	sets absolute tolerance.  # > 0.0
 *  rel #	sets relative tolerance.  0.0 < # < 1.0
 *  norm #	sets normal tolerance, in degrees.
 *  dist #	sets calculational distance tolerance
 *  perp #	sets calculational normal tolerance.
 *
 */
static int
wdb_tol_tcl(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_tol_cmd(wdbp, interp, argc-1, argv+1);
}

/* structure to hold all solids that have been pushed. */
struct wdb_push_id {
	long	magic;
	struct wdb_push_id *forw, *back;
	struct directory *pi_dir;
	mat_t	pi_mat;
};

#define WDB_MAGIC_PUSH_ID	0x50495323
#define FOR_ALL_WDB_PUSH_SOLIDS(_p,_phead) \
	for(_p=_phead.forw; _p!=&_phead; _p=_p->forw)
struct wdb_push_data {
	Tcl_Interp		*interp;
	struct wdb_push_id	pi_head;
	int			push_error;
};

/*
 *		P U S H _ L E A F
 *
 * This routine must be prepared to run in parallel.
 *
 * This routine is called once for eas leaf (solid) that is to
 * be pushed.  All it does is build at push_id linked list.  The 
 * linked list could be handled by bu_list macros but it is simple
 * enough to do hear with out them.
 */
static union tree *
wdb_push_leaf(struct db_tree_state	*tsp,
	      struct db_full_path	*pathp,
	      struct rt_db_internal	*ip,
	      genptr_t			client_data)
{
	union tree	*curtree;
	struct directory *dp;
	register struct wdb_push_id *pip;
	struct wdb_push_data *wpdp = (struct wdb_push_data *)client_data;

	RT_CK_TESS_TOL(tsp->ts_ttol);
	BN_CK_TOL(tsp->ts_tol);
	RT_CK_RESOURCE(tsp->ts_resp);

	dp = pathp->fp_names[pathp->fp_len-1];

	if (RT_G_DEBUG&DEBUG_TREEWALK) {
		char *sofar = db_path_to_string(pathp);

		Tcl_AppendResult(wpdp->interp, "wdb_push_leaf(",
				ip->idb_meth->ft_name,
				 ") path='", sofar, "'\n", (char *)NULL);
		bu_free((genptr_t)sofar, "path string");
	}
/*
 * XXX - This will work but is not the best method.  dp->d_uses tells us
 * if this solid (leaf) has been seen before.  If it hasn't just add
 * it to the list.  If it has, search the list to see if the matricies
 * match and do the "right" thing.
 *
 * (There is a question as to whether dp->d_uses is reset to zero
 *  for each tree walk.  If it is not, then d_uses is NOT a safe
 *  way to check and this method will always work.)
 */
	bu_semaphore_acquire(RT_SEM_WORKER);
	FOR_ALL_WDB_PUSH_SOLIDS(pip,wpdp->pi_head) {
		if (pip->pi_dir == dp ) {
			if (!bn_mat_is_equal(pip->pi_mat,
					     tsp->ts_mat, tsp->ts_tol)) {
				char *sofar = db_path_to_string(pathp);

				Tcl_AppendResult(wpdp->interp, "wdb_push_leaf: matrix mismatch between '", sofar,
						 "' and prior reference.\n", (char *)NULL);
				bu_free((genptr_t)sofar, "path string");
				wpdp->push_error = 1;
			}

			bu_semaphore_release(RT_SEM_WORKER);
			RT_GET_TREE(curtree, tsp->ts_resp);
			curtree->magic = RT_TREE_MAGIC;
			curtree->tr_op = OP_NOP;
			return curtree;
		}
	}
/*
 * This is the first time we have seen this solid.
 */
	pip = (struct wdb_push_id *) bu_malloc(sizeof(struct wdb_push_id), "Push ident");
	pip->magic = WDB_MAGIC_PUSH_ID;
	pip->pi_dir = dp;
	MAT_COPY(pip->pi_mat, tsp->ts_mat);
	pip->back = wpdp->pi_head.back;
	wpdp->pi_head.back = pip;
	pip->forw = &wpdp->pi_head;
	pip->back->forw = pip;
	bu_semaphore_release(RT_SEM_WORKER);
	RT_GET_TREE( curtree, tsp->ts_resp );
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;
	return curtree;
}
/*
 * A null routine that does nothing.
 */
static union tree *
wdb_push_region_end(register struct db_tree_state *tsp,
		    struct db_full_path		*pathp,
		    union tree			*curtree,
		    genptr_t			client_data)
{
	return curtree;
}

int
wdb_push_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	struct wdb_push_data	*wpdp;
	struct wdb_push_id	*pip;
	struct rt_db_internal	es_int;
	int			i;
	int			ncpu;
	int			c;
	int			old_debug;
	int			push_error;
	extern 	int		bu_optind;
	extern	char		*bu_optarg;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc < 2 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_push %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	RT_CHECK_DBI(wdbp->dbip);

	BU_GETSTRUCT(wpdp,wdb_push_data);
	wpdp->interp = interp;
	wpdp->push_error = 0;
	wpdp->pi_head.magic = WDB_MAGIC_PUSH_ID;
	wpdp->pi_head.forw = wpdp->pi_head.back = &wpdp->pi_head;
	wpdp->pi_head.pi_dir = (struct directory *) 0;

	old_debug = RT_G_DEBUG;

	/* Initial values for options, must be reset each time */
	ncpu = 1;

	/* Parse options */
	bu_optind = 1;	/* re-init bu_getopt() */
	while ((c=bu_getopt(argc, argv, "P:d")) != EOF) {
		switch (c) {
		case 'P':
			ncpu = atoi(bu_optarg);
			if (ncpu<1) ncpu = 1;
			break;
		case 'd':
			rt_g.debug |= DEBUG_TREEWALK;
			break;
		case '?':
		default:
		  Tcl_AppendResult(interp, "push: usage push [-P processors] [-d] root [root2 ...]\n", (char *)NULL);
			break;
		}
	}

	argc -= bu_optind;
	argv += bu_optind;

	/*
	 * build a linked list of solids with the correct
	 * matrix to apply to each solid.  This will also
	 * check to make sure that a solid is not pushed in two
	 * different directions at the same time.
	 */
	i = db_walk_tree(wdbp->dbip, argc, (const char **)argv,
			 ncpu,
			 &wdbp->wdb_initial_tree_state,
			 0,				/* take all regions */
			 wdb_push_region_end,
			 wdb_push_leaf, (genptr_t)wpdp);

	/*
	 * If there was any error, then just free up the solid
	 * list we just built.
	 */
	if (i < 0 || wpdp->push_error) {
		while (wpdp->pi_head.forw != &wpdp->pi_head) {
			pip = wpdp->pi_head.forw;
			pip->forw->back = pip->back;
			pip->back->forw = pip->forw;
			bu_free((genptr_t)pip, "Push ident");
		}
		rt_g.debug = old_debug;
		bu_free((genptr_t)wpdp, "wdb_push_tcl: wpdp");
		Tcl_AppendResult(interp,
				 "push:\tdb_walk_tree failed or there was a solid moving\n\tin two or more directions",
				 (char *)NULL);
		return TCL_ERROR;
	}
/*
 * We've built the push solid list, now all we need to do is apply
 * the matrix we've stored for each solid.
 */
	FOR_ALL_WDB_PUSH_SOLIDS(pip,wpdp->pi_head) {
		if (rt_db_get_internal(&es_int, pip->pi_dir, wdbp->dbip, pip->pi_mat, &rt_uniresource) < 0) {
			Tcl_AppendResult(interp, "f_push: Read error fetching '",
				   pip->pi_dir->d_namep, "'\n", (char *)NULL);
			wpdp->push_error = -1;
			continue;
		}
		RT_CK_DB_INTERNAL(&es_int);

		if (rt_db_put_internal(pip->pi_dir, wdbp->dbip, &es_int, &rt_uniresource) < 0) {
			Tcl_AppendResult(interp, "push(", pip->pi_dir->d_namep,
					 "): solid export failure\n", (char *)NULL);
		}
		rt_db_free_internal(&es_int, &rt_uniresource);
	}

	/*
	 * Now use the wdb_identitize() tree walker to turn all the
	 * matricies in a combination to the identity matrix.
	 * It would be nice to use db_tree_walker() but the tree
	 * walker does not give us all combinations, just regions.
	 * This would work if we just processed all matricies backwards
	 * from the leaf (solid) towards the root, but all in all it
	 * seems that this is a better method.
	 */

	while (argc > 0) {
		struct directory *db;
		db = db_lookup(wdbp->dbip, *argv++, 0);
		if (db)
			wdb_identitize(db, wdbp->dbip, interp);
		--argc;
	}

	/*
	 * Free up the solid table we built.
	 */
	while (wpdp->pi_head.forw != &wpdp->pi_head) {
		pip = wpdp->pi_head.forw;
		pip->forw->back = pip->back;
		pip->back->forw = pip->forw;
		bu_free((genptr_t)pip, "Push ident");
	}

	rt_g.debug = old_debug;
	push_error = wpdp->push_error;
	bu_free((genptr_t)wpdp, "wdb_push_tcl: wpdp");

	return push_error ? TCL_ERROR : TCL_OK;
}

/*
 * The push command is used to move matrices from combinations 
 * down to the solids. At some point, it is worth while thinking
 * about adding a limit to have the push go only N levels down.
 *
 * the -d flag turns on the treewalker debugging output.
 * the -P flag allows for multi-processor tree walking (not useful)
 *
 * Usage:
 *        procname push object(s)
 */
static int
wdb_push_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_push_cmd(wdbp, interp, argc-1, argv+1);
}

static void
increment_uses(struct db_i	*db_ip,
	       struct directory	*dp,
	       genptr_t		ptr)
{
	RT_CK_DIR(dp);

	dp->d_uses++;
}

static void
increment_nrefs(struct db_i		*db_ip,
		struct directory	*dp,
		genptr_t		ptr)
{
	RT_CK_DIR(dp);

	dp->d_nref++;
}

struct object_use
{
	struct bu_list		l;
	struct directory	*dp;
	mat_t			xform;
	int			used;
};

static void
Free_uses( struct db_i *dbip )
{
	int i;

	for (i=0 ; i<RT_DBNHASH ; i++) {
		struct directory *dp;
		struct object_use *use;

		for (dp=dbip->dbi_Head[i]; dp!=DIR_NULL; dp=dp->d_forw) {
			if (!(dp->d_flags & (DIR_SOLID | DIR_COMB)))
				continue;

			while (BU_LIST_NON_EMPTY(&dp->d_use_hd)) {
				use = BU_LIST_FIRST(object_use, &dp->d_use_hd);
				if( !use->used ) {
					if( use->dp->d_un.file_offset >= 0 ) {
						/* was written to disk */
						db_delete( dbip, use->dp );
					}
					db_dirdelete(dbip, use->dp);
				}
				BU_LIST_DEQUEUE(&use->l);
				bu_free((genptr_t)use, "Free_uses: use");
			}
			
		}
	}

}

static void
Make_new_name(struct db_i	*dbip,
	      struct directory	*dp,
	      genptr_t		ptr)
{
	struct object_use *use;
	int use_no;
	int digits;
	int suffix_start;
	int name_length;
	int j;
	char format_v4[25], format_v5[25];
	struct bu_vls name_v5;
	char name_v4[NAMESIZE];
	char *name;

	/* only one use and not referenced elsewhere, nothing to do */
	if (dp->d_uses < 2 && dp->d_uses == dp->d_nref)
		return;

	/* check if already done */
	if (BU_LIST_NON_EMPTY(&dp->d_use_hd))
		return;

	digits = log10((double)dp->d_uses) + 2.0;
	sprintf(format_v5, "%%s_%%0%dd", digits);
	sprintf(format_v4, "_%%0%dd", digits);

	name_length = strlen(dp->d_namep);
	if (name_length + digits + 1 > NAMESIZE - 1)
		suffix_start = NAMESIZE - digits - 2;
	else
		suffix_start = name_length;

	if (dbip->dbi_version >= 5)
		bu_vls_init(&name_v5);
	j = 0;
	for (use_no=0 ; use_no<dp->d_uses ; use_no++) {
		j++;
		use = (struct object_use *)bu_malloc( sizeof( struct object_use ), "Make_new_name: use" );

		/* set xform for this object_use to all zeros */
		MAT_ZERO(use->xform);
		use->used = 0;
		if (dbip->dbi_version < 5) {
			NAMEMOVE(dp->d_namep, name_v4);
			name_v4[NAMESIZE-1] = '\0';                /* ensure null termination */
		}

		/* Add an entry for the original at the end of the list
		 * This insures that the original will be last to be modified
		 * If original were modified earlier, copies would be screwed-up
		 */
		if (use_no == dp->d_uses-1 && dp->d_uses == dp->d_nref)
			use->dp = dp;
		else {
			if (dbip->dbi_version < 5) {
				sprintf(&name_v4[suffix_start], format_v4, j);
				name = name_v4;
			} else {
				bu_vls_trunc(&name_v5, 0);
				bu_vls_printf(&name_v5, format_v5, dp->d_namep, j);
				name = bu_vls_addr(&name_v5);
			}

			/* Insure that new name is unique */
			while (db_lookup( dbip, name, 0 ) != DIR_NULL) {
				j++;
				if (dbip->dbi_version < 5) {
					sprintf(&name_v4[suffix_start], format_v4, j);
					name = name_v4;
				} else {
					bu_vls_trunc(&name_v5, 0);
					bu_vls_printf(&name_v5, format_v5, dp->d_namep, j);
					name = bu_vls_addr(&name_v5);
				}
			}

			/* Add new name to directory */
			if ((use->dp = db_diradd(dbip, name, -1, 0, dp->d_flags,
						 (genptr_t)&dp->d_minor_type)) == DIR_NULL) {
				WDB_ALLOC_ERR_return;
			}
		}

		/* Add new directory pointer to use list for this object */
		BU_LIST_INSERT(&dp->d_use_hd, &use->l);
	}

	if (dbip->dbi_version >= 5)
		bu_vls_free(&name_v5);
}

static struct directory *
Copy_solid(struct db_i		*dbip,
	   struct directory	*dp,
	   mat_t		xform,
	   Tcl_Interp		*interp,
	   struct rt_wdb	*wdbp)
{
	struct directory *found;
	struct rt_db_internal sol_int;
	struct object_use *use;

	RT_CK_DIR(dp);

	if (!(dp->d_flags & DIR_SOLID)) {
		Tcl_AppendResult(interp, "Copy_solid: ", dp->d_namep,
				 " is not a solid!!!!\n", (char *)NULL);
		return (DIR_NULL);
	}

	/* If no transformation is to be applied, just use the original */
	if (bn_mat_is_identity(xform)) {
		/* find original in the list */
		for (BU_LIST_FOR(use, object_use, &dp->d_use_hd)) {
			if (use->dp == dp && use->used == 0) {
				use->used = 1;
				return (dp);
			}
		}
	}

	/* Look for a copy that already has this transform matrix */
	for (BU_LIST_FOR(use, object_use, &dp->d_use_hd)) {
		if (bn_mat_is_equal(xform, use->xform, &wdbp->wdb_tol)) {
			/* found a match, no need to make another copy */
			use->used = 1;
			return(use->dp);
		}
	}

	/* get a fresh use */
	found = DIR_NULL;
	for (BU_LIST_FOR(use, object_use, &dp->d_use_hd)) {
		if (use->used)
			continue;

		found = use->dp;
		use->used = 1;
		MAT_COPY(use->xform, xform);
		break;
	}

	if (found == DIR_NULL && dp->d_nref == 1 && dp->d_uses == 1) {
		/* only one use, take it */
		found = dp;
	}

	if (found == DIR_NULL) {
		Tcl_AppendResult(interp, "Ran out of uses for solid ",
				 dp->d_namep, "\n", (char *)NULL);
		return (DIR_NULL);
	}

	if (rt_db_get_internal(&sol_int, dp, dbip, xform, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "Cannot import solid ",
				 dp->d_namep, "\n", (char *)NULL);
		return (DIR_NULL);
	}

	RT_CK_DB_INTERNAL(&sol_int);
	if (rt_db_put_internal(found, dbip, &sol_int, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "Cannot write copy solid (", found->d_namep,
				 ") to database\n", (char *)NULL);
		return (DIR_NULL);
	}

	return (found);
}

static struct directory *Copy_object(struct db_i *dbip, struct directory *dp, fastf_t *xform, Tcl_Interp *interp, struct rt_wdb *wdbp);

HIDDEN void
Do_copy_membs(struct db_i		*dbip,
	      struct rt_comb_internal	*comb,
	      union tree		*comb_leaf,
	      genptr_t			user_ptr1,
	      genptr_t			user_ptr2,
	      genptr_t			user_ptr3)
{
	struct directory	*dp;
	struct directory	*dp_new;
	mat_t			new_xform;
	matp_t			xform;
	Tcl_Interp		*interp;
	struct rt_wdb		*wdbp;

	RT_CK_DBI(dbip);
	RT_CK_TREE(comb_leaf);

	if ((dp=db_lookup(dbip, comb_leaf->tr_l.tl_name, LOOKUP_QUIET)) == DIR_NULL)
		return;

	xform = (matp_t)user_ptr1;
	interp = (Tcl_Interp *)user_ptr2;
	wdbp = (struct rt_wdb *)user_ptr3;

	/* apply transform matrix for this arc */
	if (comb_leaf->tr_l.tl_mat) {
		bn_mat_mul(new_xform, xform, comb_leaf->tr_l.tl_mat);
	} else {
		MAT_COPY(new_xform, xform);
	}

	/* Copy member with current tranform matrix */
	if ((dp_new=Copy_object(dbip, dp, new_xform, interp, wdbp)) == DIR_NULL) {
		Tcl_AppendResult(interp, "Failed to copy object ",
				 dp->d_namep, "\n", (char *)NULL);
		return;
	}

	/* replace member name with new copy */
	bu_free(comb_leaf->tr_l.tl_name, "comb_leaf->tr_l.tl_name");
	comb_leaf->tr_l.tl_name = bu_strdup(dp_new->d_namep);

	/* make transform for this arc the identity matrix */
	if (!comb_leaf->tr_l.tl_mat) {
		comb_leaf->tr_l.tl_mat = (matp_t)bu_malloc(sizeof(mat_t), "tl_mat");
	}
	MAT_IDN(comb_leaf->tr_l.tl_mat);
}

static struct directory *
Copy_comb(struct db_i		*dbip,
	  struct directory	*dp,
	  mat_t			xform,
	  Tcl_Interp		*interp,
	  struct rt_wdb		*wdbp)
{
	struct object_use *use;
	struct directory *found;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;

	RT_CK_DIR(dp);

	/* Look for a copy that already has this transform matrix */
	for (BU_LIST_FOR(use, object_use, &dp->d_use_hd)) {
		if (bn_mat_is_equal(xform, use->xform, &wdbp->wdb_tol)) {
			/* found a match, no need to make another copy */
			use->used = 1;
			return (use->dp);
		}
	}

	/* if we can't get records for this combination, just leave it alone */
	if (rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource) < 0)
		return (dp);
	comb = (struct rt_comb_internal *)intern.idb_ptr;

	/* copy members */
	if (comb->tree)
		db_tree_funcleaf(dbip, comb, comb->tree, Do_copy_membs,
				 (genptr_t)xform, (genptr_t)interp, (genptr_t)wdbp);

	/* Get a use of this object */
	found = DIR_NULL;
	for (BU_LIST_FOR(use, object_use, &dp->d_use_hd)) {
		/* Get a fresh use of this object */
		if (use->used)
			continue;	/* already used */
		found = use->dp;
		use->used = 1;
		MAT_COPY(use->xform, xform);
		break;
	}

	if (found == DIR_NULL && dp->d_nref == 1 && dp->d_uses == 1) {
		/* only one use, so take original */
		found = dp;
	}

	if (found == DIR_NULL) {
		Tcl_AppendResult(interp, "Ran out of uses for combination ",
				 dp->d_namep, "\n", (char *)NULL);
		return (DIR_NULL);
	}

	if (rt_db_put_internal(found, dbip, &intern, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "rt_db_put_internal failed for ", dp->d_namep,
				 "\n", (char *)NULL);
		rt_comb_ifree(&intern, &rt_uniresource);
		return(DIR_NULL);
	}

	return(found);
}

static struct directory *
Copy_object(struct db_i		*dbip,
	    struct directory	*dp,
	    mat_t		xform,
	    Tcl_Interp		*interp,
	    struct rt_wdb	*wdbp)
{
	RT_CK_DIR(dp);

	if (dp->d_flags & DIR_SOLID)
		return (Copy_solid(dbip, dp, xform, interp, wdbp));
	else
		return (Copy_comb(dbip, dp, xform, interp, wdbp));
}

HIDDEN void
Do_ref_incr(struct db_i			*dbip,
	    struct rt_comb_internal	*comb,
	    union tree			*comb_leaf,
	    genptr_t			user_ptr1,
	    genptr_t			user_ptr2,
	    genptr_t			user_ptr3)
{
	struct directory *dp;

	RT_CK_DBI(dbip);
	RT_CK_TREE(comb_leaf);

	if ((dp = db_lookup(dbip, comb_leaf->tr_l.tl_name, LOOKUP_QUIET)) == DIR_NULL)
		return;

	dp->d_nref++;
}

int
wdb_xpush_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	struct directory *old_dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	struct bu_ptbl tops;
	mat_t xform;
	int i;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_xpush %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* get directory pointer for arg */
	if ((old_dp = db_lookup(wdbp->dbip,  argv[1], LOOKUP_NOISY)) == DIR_NULL)
		return TCL_ERROR;

	/* Initialize use and reference counts of all directory entries */
	for (i=0 ; i<RT_DBNHASH ; i++) {
		struct directory *dp;

		for (dp=wdbp->dbip->dbi_Head[i]; dp!=DIR_NULL; dp=dp->d_forw) {
			if (!(dp->d_flags & (DIR_SOLID | DIR_COMB)))
				continue;

			dp->d_uses = 0;
			dp->d_nref = 0;
		}
	}

	/* Count uses in the tree being pushed (updates dp->d_uses) */
	db_functree(wdbp->dbip, old_dp, increment_uses, increment_uses, &rt_uniresource, NULL);

	/* Do a simple reference count to find top level objects */
	for (i=0 ; i<RT_DBNHASH ; i++) {
		struct directory *dp;

		for (dp=wdbp->dbip->dbi_Head[i] ; dp!=DIR_NULL ; dp=dp->d_forw) {
			struct rt_db_internal intern;
			struct rt_comb_internal *comb;

			if (dp->d_flags & DIR_SOLID)
				continue;

			if (!(dp->d_flags & (DIR_SOLID | DIR_COMB)))
				continue;

			if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource) < 0)
				WDB_TCL_READ_ERR_return;
			comb = (struct rt_comb_internal *)intern.idb_ptr;
			if (comb->tree)
				db_tree_funcleaf(wdbp->dbip, comb, comb->tree, Do_ref_incr,
						 (genptr_t )NULL, (genptr_t )NULL, (genptr_t )NULL);
			rt_comb_ifree(&intern, &rt_uniresource);
		}
	}

	/* anything with zero references is a tree top */
	bu_ptbl_init(&tops, 0, "tops for xpush");
	for (i=0; i<RT_DBNHASH; i++) {
		struct directory *dp;

		for (dp=wdbp->dbip->dbi_Head[i]; dp!=DIR_NULL; dp=dp->d_forw) {
			if (dp->d_flags & DIR_SOLID)
				continue;

			if (!(dp->d_flags & (DIR_SOLID | DIR_COMB )))
				continue;

			if (dp->d_nref == 0)
				bu_ptbl(&tops, BU_PTBL_INS, (long *)dp);
		}
	}

	/* now re-zero the reference counts */
	for (i=0 ; i<RT_DBNHASH ; i++) {
		struct directory *dp;

		for (dp=wdbp->dbip->dbi_Head[i]; dp!=DIR_NULL; dp=dp->d_forw) {
			if (!(dp->d_flags & (DIR_SOLID | DIR_COMB)))
				continue;

			dp->d_nref = 0;
		}
	}

	/* accurately count references in entire model */
	for (i=0; i<BU_PTBL_END(&tops); i++) {
		struct directory *dp;

		dp = (struct directory *)BU_PTBL_GET(&tops, i);
		db_functree(wdbp->dbip, dp, increment_nrefs, increment_nrefs, &rt_uniresource, NULL);
	}

	/* Free list of tree-tops */
	bu_ptbl(&tops, BU_PTBL_FREE, (long *)NULL);

	/* Make new names */
	db_functree(wdbp->dbip, old_dp, Make_new_name, Make_new_name, &rt_uniresource, NULL);

	MAT_IDN(xform);

	/* Make new objects */
	if (rt_db_get_internal(&intern, old_dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource) < 0) {
		bu_log("ERROR: cannot load %s feom the database!!!\n", old_dp->d_namep);
		bu_log("\tNothing has been changed!!\n");
		Free_uses( wdbp->dbip );
		return TCL_ERROR;
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	if (!comb->tree) {
		Free_uses( wdbp->dbip );
		return TCL_OK;
	}

	db_tree_funcleaf(wdbp->dbip, comb, comb->tree, Do_copy_membs,
			 (genptr_t)xform, (genptr_t)interp, (genptr_t)wdbp);

	if (rt_db_put_internal(old_dp, wdbp->dbip, &intern, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "rt_db_put_internal failed for ", old_dp->d_namep,
				 "\n", (char *)NULL);
		rt_comb_ifree(&intern, &rt_uniresource);
		Free_uses( wdbp->dbip );
		return TCL_ERROR;
	}

	/* Free use lists and delete unused directory entries */
	Free_uses( wdbp->dbip );
	return TCL_OK;
}

static int
wdb_xpush_tcl(ClientData	clientData,
	     Tcl_Interp		*interp,
	     int		argc,
	     char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_xpush_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_whatid_cmd(struct rt_wdb	*wdbp,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	struct directory	*dp;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	struct bu_vls		vls;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_whatid %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if ((dp=db_lookup(wdbp->dbip, argv[1], LOOKUP_NOISY )) == DIR_NULL )
		return TCL_ERROR;

	if (!(dp->d_flags & DIR_REGION)) {
		Tcl_AppendResult(interp, argv[1], " is not a region", (char *)NULL );
		return TCL_ERROR;
	}

	if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource) < 0)
		return TCL_ERROR;
	comb = (struct rt_comb_internal *)intern.idb_ptr;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "%d", comb->region_id);
	rt_comb_ifree(&intern, &rt_uniresource);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;
}

/*
 * Usage:
 *        procname whatid object
 */
static int
wdb_whatid_tcl(ClientData	clientData,
	       Tcl_Interp	*interp,
	       int		argc,
	       char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_whatid_cmd(wdbp, interp, argc-1, argv+1);
}

struct wdb_node_data {
	FILE	     *fp;
	Tcl_Interp   *interp;
};

/*
 *			W D B _ N O D E _ W R I T E
 *
 *  Support for the 'keep' method.
 *  Write each node encountered exactly once.
 */
void
wdb_node_write(struct db_i		*dbip,
	       register struct directory *dp,
	       genptr_t			ptr)
{
	struct rt_wdb		*keepfp = (struct rt_wdb *)ptr;
	struct rt_db_internal	intern;

	RT_CK_WDB(keepfp);

	if (dp->d_nref++ > 0)
		return;		/* already written */

	if (rt_db_get_internal(&intern, dp, dbip, NULL, &rt_uniresource) < 0)
		WDB_READ_ERR_return;

	/* if this is an extrusion, keep the referenced sketch */
	if( dp->d_major_type == DB5_MAJORTYPE_BRLCAD && dp->d_minor_type == DB5_MINORTYPE_BRLCAD_EXTRUDE ) {
		struct rt_extrude_internal *extr;
		struct directory *dp2;

		extr = (struct rt_extrude_internal *)intern.idb_ptr;
		RT_EXTRUDE_CK_MAGIC( extr );

		if( (dp2 = db_lookup( dbip, extr->sketch_name, LOOKUP_QUIET )) != DIR_NULL ) {
			wdb_node_write( dbip, dp2, ptr );
		}
	} else if ( dp->d_major_type == DB5_MAJORTYPE_BRLCAD && dp->d_minor_type == DB5_MINORTYPE_BRLCAD_DSP ) {
		struct rt_dsp_internal *dsp;
		struct directory *dp2;

		/* this is a DSP, if it uses a binary object, keep it also */
		dsp = (struct rt_dsp_internal *)intern.idb_ptr;
		RT_DSP_CK_MAGIC( dsp );

		if( dsp->dsp_datasrc == RT_DSP_SRC_OBJ ) {
			/* need to keep this object */
			if( (dp2 = db_lookup( dbip, bu_vls_addr(&dsp->dsp_name),  LOOKUP_QUIET )) != DIR_NULL ) {
				wdb_node_write( dbip, dp2, ptr );	
			}
		}
	}

	if (wdb_put_internal(keepfp, dp->d_namep, &intern, 1.0) < 0)
		WDB_WRITE_ERR_return;
}

int
wdb_keep_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	struct rt_wdb		*keepfp;
	register struct directory *dp;
	struct bu_vls		title;
	register int		i;
	struct db_i		*new_dbip;

	if (argc < 3 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_keep %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* First, clear any existing counts */
	for (i = 0; i < RT_DBNHASH; i++) {
		for (dp = wdbp->dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
			dp->d_nref = 0;
	}

	/* Alert user if named file already exists */
	
	new_dbip = db_open(argv[1], "w");


	if (new_dbip != DBI_NULL) {
	    if (new_dbip->dbi_version != wdbp->dbip->dbi_version) {
		Tcl_AppendResult(interp,
				 "keep: File format mismatch between '",
				 argv[1], "' and '",
				 wdbp->dbip->dbi_filename, "'\n",
				 (char *)NULL);
		return TCL_ERROR;
	    }
	    
	    if ((keepfp = wdb_dbopen(new_dbip, RT_WDB_TYPE_DB_DISK)) == NULL) {
		Tcl_AppendResult(interp, "keep:  Error opening '", argv[1],
				 "'\n", (char *)NULL);
		return TCL_ERROR;
	    } else {
		Tcl_AppendResult(interp, "keep:  appending to '", argv[1],
				 "'\n", (char *)NULL);

		/* --- Scan geometry database and build in-memory directory --- */
		db_dirbuild(new_dbip);
	    }
	} else {
	    /* Create a new database */
	    keepfp = wdb_fopen_v(argv[1], wdbp->dbip->dbi_version);

	    if (keepfp == NULL) {
		perror(argv[1]);
		return TCL_ERROR;
	    }
	}
	
	/* ident record */
	bu_vls_init(&title);
	if (strncmp(wdbp->dbip->dbi_title, "Parts of: ", 10) != 0) {
	  bu_vls_strcat(&title, "Parts of: ");
	}
	bu_vls_strcat(&title, wdbp->dbip->dbi_title);

	if (db_update_ident(keepfp->dbip, bu_vls_addr(&title), wdbp->dbip->dbi_local2base) < 0) {
		perror("fwrite");
		Tcl_AppendResult(interp, "db_update_ident() failed\n", (char *)NULL);
		wdb_close(keepfp);
		bu_vls_free(&title);
		return TCL_ERROR;
	}
	bu_vls_free(&title);

	for (i = 2; i < argc; i++) {
		if ((dp = db_lookup(wdbp->dbip, argv[i], LOOKUP_NOISY)) == DIR_NULL)
			continue;
		db_functree(wdbp->dbip, dp, wdb_node_write, wdb_node_write, &rt_uniresource, (genptr_t)keepfp);
	}

	wdb_close(keepfp);
	return TCL_OK;
}

/*
 * Usage:
 *        procname keep file object(s)
 */
static int
wdb_keep_tcl(ClientData	clientData,
	     Tcl_Interp *interp,
	     int	argc,
	     char	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_keep_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_cat_cmd(struct rt_wdb	*wdbp,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv)
{
	register struct directory	*dp;
	register int			arg;
	struct bu_vls			str;

	if (argc < 2 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_cat %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_init(&str);
	for (arg = 1; arg < argc; arg++) {
		if ((dp = db_lookup(wdbp->dbip, argv[arg], LOOKUP_NOISY)) == DIR_NULL)
			continue;

		bu_vls_trunc(&str, 0);
		wdb_do_list(wdbp->dbip, interp, &str, dp, 0);	/* non-verbose */
		Tcl_AppendResult(interp, bu_vls_addr(&str), "\n", (char *)NULL);
	}
	bu_vls_free(&str);

	return TCL_OK;
}

/*
 * Usage:
 *        procname cat object(s)
 */
static int
wdb_cat_tcl(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_cat_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_instance_cmd(struct rt_wdb	*wdbp,
		 Tcl_Interp	*interp,
		 int		argc,
		 char 		**argv)
{
	register struct directory	*dp;
	char				oper;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc < 3 || 4 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_instance %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if ((dp = db_lookup(wdbp->dbip,  argv[1], LOOKUP_NOISY)) == DIR_NULL)
		return TCL_ERROR;

	oper = WMOP_UNION;
	if (argc == 4)
		oper = argv[3][0];

	if (oper != WMOP_UNION &&
	    oper != WMOP_SUBTRACT &&
	    oper != WMOP_INTERSECT) {
		struct bu_vls tmp_vls;

		bu_vls_init(&tmp_vls);
		bu_vls_printf(&tmp_vls, "bad operation: %c\n", oper);
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);
		return TCL_ERROR;
	}

	if (wdb_combadd(interp, wdbp->dbip, dp, argv[2], 0, oper, 0, 0, wdbp) == DIR_NULL)
		return TCL_ERROR;

	return TCL_OK;
}

/*
 * Add instance of obj to comb.
 *
 * Usage:
 *        procname i obj comb [op]
 */
static int
wdb_instance_tcl(ClientData	clientData,
		 Tcl_Interp	*interp,
		 int		argc,
		 char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_instance_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_observer_cmd(struct rt_wdb	*wdbp,
		 Tcl_Interp	*interp,
		 int		argc,
		 char 		**argv)
{
	if (argc < 2) {
		struct bu_vls vls;

		/* return help message */
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_observer %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	return bu_cmd((ClientData)&wdbp->wdb_observers,
		      interp, argc - 1, argv + 1, bu_observer_cmds, 0);
}

/*
 * Attach/detach observers to/from list.
 *
 * Usage:
 *	  procname observer cmd [args]
 *
 */
static int
wdb_observer_tcl(ClientData	clientData,
		 Tcl_Interp	*interp,
		 int		argc,
		 char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_observer_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_make_bb_cmd(struct rt_wdb	*wdbp,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	struct rt_i		*rtip;
	int			i;
	point_t			rpp_min,rpp_max;
	struct db_full_path	path;
	struct directory	*dp;
	struct rt_arb_internal	*arb;
	struct rt_db_internal	new_intern;
	struct region		*regp;
	char			*new_name;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc < 3 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_make_bb %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* Since arguments may be paths, make sure first argument isn't */
	if (strchr(argv[1], '/')) {
		Tcl_AppendResult(interp, "Do not use '/' in solid names: ", argv[1], "\n", (char *)NULL);
		return TCL_ERROR;
	}

	new_name = argv[1];
	if (db_lookup(wdbp->dbip, new_name, LOOKUP_QUIET) != DIR_NULL) {
		Tcl_AppendResult(interp, new_name, " already exists\n", (char *)NULL);
		return TCL_ERROR;
	}

	/* Make a new rt_i instance from the existing db_i sructure */
	if ((rtip=rt_new_rti(wdbp->dbip)) == RTI_NULL) {
		Tcl_AppendResult(interp, "rt_new_rti failure for ", wdbp->dbip->dbi_filename,
				 "\n", (char *)NULL);
		return TCL_ERROR;
	}

	/* Get trees for list of objects/paths */
	for (i = 2 ; i < argc ; i++) {
		int gottree;

		/* Get full_path structure for argument */
		db_full_path_init(&path);
		if (db_string_to_path(&path,  rtip->rti_dbip, argv[i])) {
			Tcl_AppendResult(interp, "db_string_to_path failed for ",
					 argv[i], "\n", (char *)NULL );
			rt_clean(rtip);
			bu_free((genptr_t)rtip, "wdb_make_bb_cmd: rtip");
			return TCL_ERROR;
		}

		/* check if we alerady got this tree */
		gottree = 0;
		for (BU_LIST_FOR(regp, region, &(rtip->HeadRegion))) {
			struct db_full_path tmp_path;

			db_full_path_init(&tmp_path);
			if (db_string_to_path(&tmp_path, rtip->rti_dbip, regp->reg_name)) {
				Tcl_AppendResult(interp, "db_string_to_path failed for ",
						 regp->reg_name, "\n", (char *)NULL);
				rt_clean(rtip);
				bu_free((genptr_t)rtip, "wdb_make_bb_cmd: rtip");
				return TCL_ERROR;
			}
			if (path.fp_names[0] == tmp_path.fp_names[0])
				gottree = 1;
			db_free_full_path(&tmp_path);
			if (gottree)
				break;
		}

		/* if we don't already have it, get it */
		if (!gottree && rt_gettree(rtip, path.fp_names[0]->d_namep)) {
			Tcl_AppendResult(interp, "rt_gettree failed for ",
					 argv[i], "\n", (char *)NULL );
			rt_clean(rtip);
			bu_free((genptr_t)rtip, "wdb_make_bb_cmd: rtip");
			return TCL_ERROR;
		}
		db_free_full_path(&path);
	}

	/* prep calculates bounding boxes of solids */
	rt_prep(rtip);

	/* initialize RPP bounds */
	VSETALL(rpp_min, MAX_FASTF);
	VREVERSE(rpp_max, rpp_min);
	for (i = 2 ; i < argc ; i++) {
		vect_t reg_min, reg_max;
		struct region *regp;
		const char *reg_name;

		/* check if input name is a region */
		for (BU_LIST_FOR(regp, region, &(rtip->HeadRegion))) {
			reg_name = regp->reg_name;
			if (*argv[i] != '/' && *reg_name == '/')
				reg_name++;

			if (!strcmp( reg_name, argv[i]))
				goto found;
				
		}
		goto not_found;

found:
		if (regp != REGION_NULL) {
			/* input name was a region  */
			if (rt_bound_tree(regp->reg_treetop, reg_min, reg_max)) {
				Tcl_AppendResult(interp, "rt_bound_tree failed for ",
						 regp->reg_name, "\n", (char *)NULL);
				rt_clean(rtip);
				bu_free((genptr_t)rtip, "wdb_make_bb_cmd: rtip");
				return TCL_ERROR;
			}
			VMINMAX(rpp_min, rpp_max, reg_min);
			VMINMAX(rpp_min, rpp_max, reg_max);
		} else {
			int name_len;
not_found:

			/* input name may be a group, need to check all regions under
			 * that group
			 */
			name_len = strlen( argv[i] );
			for (BU_LIST_FOR( regp, region, &(rtip->HeadRegion))) {
				reg_name = regp->reg_name;
				if (*argv[i] != '/' && *reg_name == '/')
					reg_name++;

				if (strncmp(argv[i], reg_name, name_len))
					continue;

				/* This is part of the group */
				if (rt_bound_tree(regp->reg_treetop, reg_min, reg_max)) {
					Tcl_AppendResult(interp, "rt_bound_tree failed for ",
							 regp->reg_name, "\n", (char *)NULL);
					rt_clean(rtip);
					bu_free((genptr_t)rtip, "wdb_make_bb_cmd: rtip");
					return TCL_ERROR;
				}
				VMINMAX(rpp_min, rpp_max, reg_min);
				VMINMAX(rpp_min, rpp_max, reg_max);
			}
		}
	}

	/* build bounding RPP */
	arb = (struct rt_arb_internal *)bu_malloc(sizeof(struct rt_arb_internal), "arb");
	VMOVE(arb->pt[0], rpp_min);
	VSET(arb->pt[1], rpp_min[X], rpp_min[Y], rpp_max[Z]);
	VSET(arb->pt[2], rpp_min[X], rpp_max[Y], rpp_max[Z]);
	VSET(arb->pt[3], rpp_min[X], rpp_max[Y], rpp_min[Z]);
	VSET(arb->pt[4], rpp_max[X], rpp_min[Y], rpp_min[Z]);
	VSET(arb->pt[5], rpp_max[X], rpp_min[Y], rpp_max[Z]);
	VMOVE(arb->pt[6], rpp_max);
	VSET(arb->pt[7], rpp_max[X], rpp_max[Y], rpp_min[Z]);
	arb->magic = RT_ARB_INTERNAL_MAGIC;

	/* set up internal structure */
	RT_INIT_DB_INTERNAL(&new_intern);
	new_intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
	new_intern.idb_type = ID_ARB8;
	new_intern.idb_meth = &rt_functab[ID_ARB8];
	new_intern.idb_ptr = (genptr_t)arb;

	if ((dp=db_diradd( wdbp->dbip, new_name, -1L, 0, DIR_SOLID, (genptr_t)&new_intern.idb_type)) == DIR_NULL) {
		Tcl_AppendResult(interp, "Cannot add ", new_name, " to directory\n", (char *)NULL);
		return TCL_ERROR;
	}

	if (rt_db_put_internal(dp, wdbp->dbip, &new_intern, wdbp->wdb_resp) < 0) {
		rt_db_free_internal(&new_intern, wdbp->wdb_resp);
		Tcl_AppendResult(interp, "Database write error, aborting.\n", (char *)NULL);
		return TCL_ERROR;
	}

	rt_clean(rtip);
	bu_free((genptr_t)rtip, "wdb_make_bb_cmd: rtip");
	return TCL_OK;
}

/*
 *	Build an RPP bounding box for the list of objects
 *	and/or paths passed to this routine
 *
 *	Usage:
 *		dbobjname make_bb bbname obj(s)
 */
static int
wdb_make_bb_tcl(ClientData	clientData,
		Tcl_Interp	*interp,
		int		argc,
		char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_make_bb_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_make_name_cmd(struct rt_wdb	*wdbp,
		  Tcl_Interp	*interp,
		  int		argc,
		  char 		**argv)
{
	struct bu_vls	obj_name;
	char		*cp, *tp;
	static int	i = 0;
	int		len;

	switch (argc) {
	case 2:
		if (strcmp(argv[1], "-s") != 0)
			break;
		else {
			i = 0;
			return TCL_OK;
		}
	case 3:
		{
			int	new_i;

			if ((strcmp(argv[1], "-s") == 0)
			    && (sscanf(argv[2], "%d", &new_i) == 1)) {
				i = new_i;
				return TCL_OK;
			}
		}
	default:
		{
			struct bu_vls	vls;

			bu_vls_init(&vls);
			bu_vls_printf(&vls, "helplib_alias wdb_make_name %s", argv[0]);
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}
	}

	bu_vls_init(&obj_name);
	for (cp = argv[1], len = 0; *cp != '\0'; ++cp, ++len) {
		if (*cp == '@@') {
			if (*(cp + 1) == '@@')
				++cp;
			else
				break;
		}
		bu_vls_putc(&obj_name, *cp);
	}
	bu_vls_putc(&obj_name, '\0');
	tp = (*cp == '\0') ? "" : cp + 1;

	do {
		bu_vls_trunc(&obj_name, len);
		bu_vls_printf(&obj_name, "%d", i++);
		bu_vls_strcat(&obj_name, tp);
	}
	while (db_lookup(wdbp->dbip, bu_vls_addr(&obj_name), LOOKUP_QUIET) != DIR_NULL);
	Tcl_AppendResult(interp, bu_vls_addr(&obj_name), (char *) NULL);
	bu_vls_free(&obj_name);
	return TCL_OK;
}

/*
 *
 * Generate an identifier that is guaranteed not to be the name
 * of any object currently in the database.
 *
 * Usage:
 *	dbobjname make_name (template | -s [num])
 *
 */
static int
wdb_make_name_tcl(ClientData	clientData,
		  Tcl_Interp	*interp,
		  int		argc,
		  char		**argv)

{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_make_name_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_units_cmd(struct rt_wdb	*wdbp,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{
	double		loc2mm;
	struct bu_vls 	vls;
	const char	*str;
	int 		sflag = 0;

	bu_vls_init(&vls);
	if (argc < 1 || 2 < argc) {
		bu_vls_printf(&vls, "helplib_alias wdb_units %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (argc == 2 && strcmp(argv[1], "-s") == 0) {
		--argc;
		++argv;

		sflag = 1;
	}

	if (argc < 2) {
		str = bu_units_string(wdbp->dbip->dbi_local2base);
		if (!str) str = "Unknown_unit";

		if (sflag)
			bu_vls_printf(&vls, "%s", str);
		else
			bu_vls_printf(&vls, "You are editing in '%s'.  1 %s = %g mm \n",
				      str, str, wdbp->dbip->dbi_local2base );

		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
		return TCL_OK;
	}

	/* Allow inputs of the form "25cm" or "3ft" */
	if ((loc2mm = bu_mm_value(argv[1]) ) <= 0) {
		Tcl_AppendResult(interp, argv[1], ": unrecognized unit\n",
				 "valid units: <um|mm|cm|m|km|in|ft|yd|mi>\n", (char *)NULL);
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

        if (db_update_ident(wdbp->dbip, wdbp->dbip->dbi_title, loc2mm) < 0) {
		Tcl_AppendResult(interp,
				 "Warning: unable to stash working units into database\n",
				 (char *)NULL);
        }

	wdbp->dbip->dbi_local2base = loc2mm;
	wdbp->dbip->dbi_base2local = 1.0 / loc2mm;

	str = bu_units_string(wdbp->dbip->dbi_local2base);
	if (!str) str = "Unknown_unit";
	bu_vls_printf(&vls, "You are now editing in '%s'.  1 %s = %g mm \n",
		      str, str, wdbp->dbip->dbi_local2base );
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;
}

/*
 * Set/get the database units. 
 *
 * Usage:
 *        dbobjname units [str]
 */
static int
wdb_units_tcl(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_units_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_hide_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	struct directory		*dp;
	struct db_i			*dbip;
	struct bu_external		ext;
	struct bu_external		tmp;
	struct db5_raw_internal		raw;
	int				i;

	WDB_TCL_CHECK_READ_ONLY;

	if( argc < 2 ) {
		struct bu_vls vls;

		bu_vls_init( &vls );
		bu_vls_printf(&vls, "helplib_alias wdb_hide %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	RT_CK_WDB( wdbp );

	dbip = wdbp->dbip;

	RT_CK_DBI( dbip );
	if( dbip->dbi_version < 5 ) {
	  Tcl_AppendResult(interp, 
			   "Database was created with a previous release of BRL-CAD.\nSelect \"Tools->Upgrade Database...\" to enable support for this feature.",
			   (char *)NULL );
		return TCL_ERROR;
	}

	for( i=1 ; i<argc ; i++ ) {
		if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY )) == DIR_NULL ) {
			continue;
		}

		RT_CK_DIR( dp );

		if( dp->d_major_type == DB5_MAJORTYPE_BRLCAD ) {
			int no_hide=0;

			/* warn the user that this might be a bad idea */
			if( isatty(fileno(stdin)) && isatty(fileno(stdout))) {
				char line[80];

				/* classic interactive MGED */
				while( 1 ) {
					bu_log( "Hiding BRL-CAD geometry (%s) is generaly a bad idea.\n", dp->d_namep );
					bu_log( "This may cause unexpected problems with other commands.\n" );
					bu_log( "Are you sure you want to do this?? (y/n)\n" );
					(void)fgets( line, sizeof( line ), stdin );
					if( line[0] == 'y' || line[0] == 'Y' ) break;
					if( line[0] == 'n' || line[0] == 'N' ) {
						no_hide = 1;
						break;
					}
				}
			} else if( Tcl_GetVar2Ex( interp, "tk_version", NULL, TCL_GLOBAL_ONLY ) ) {
				struct bu_vls vls;

				/* Tk is active, we can pop-up a window */
				bu_vls_init( &vls );
				bu_vls_printf( &vls, "Hiding BRL-CAD geometry (%s) is generaly a bad idea.\n", dp->d_namep );
				bu_vls_strcat( &vls, "This may cause unexpected problems with other commands.\n" );
				bu_vls_strcat( &vls, "Are you sure you want to do this??" );
				(void)Tcl_ResetResult( interp );
				if( Tcl_VarEval( interp, "tk_messageBox -type yesno ",
						 "-title Warning -icon question -message {",
						 bu_vls_addr( &vls ), "}",
						 (char *)NULL ) != TCL_OK ) {
					bu_log( "Unable to post question!!!\n" );
				} else {
					const char *result;

					result = Tcl_GetStringResult( interp );
					if( !strcmp( result, "no" ) ) {
						no_hide = 1;
					}
					(void)Tcl_ResetResult( interp );
				}
			}
			if( no_hide )
				continue;
		}

		BU_INIT_EXTERNAL(&ext);

		if( db_get_external( &ext, dp, dbip ) < 0 ) {
			Tcl_AppendResult(interp, "db_get_external failed for ",
					 dp->d_namep, " \n", (char *)NULL );
			continue;
		}

		if (db5_get_raw_internal_ptr(&raw, ext.ext_buf) == NULL) {
			Tcl_AppendResult(interp, "db5_get_raw_internal_ptr() failed for ",
					 dp->d_namep, " \n", (char *)NULL );
			bu_free_external( &ext );
			continue;
		}

		raw.h_name_hidden = (unsigned char)(0x1);

		BU_INIT_EXTERNAL( &tmp );
		db5_export_object3( &tmp, DB5HDR_HFLAGS_DLI_APPLICATION_DATA_OBJECT,
			dp->d_namep,
			raw.h_name_hidden,
			&raw.attributes,
			&raw.body,
			raw.major_type, raw.minor_type,
			raw.a_zzz, raw.b_zzz );
		bu_free_external( &ext );

		if( db_put_external( &tmp, dp, dbip ) ) {
			Tcl_AppendResult(interp, "db_put_external() failed for ",
					 dp->d_namep, " \n", (char *)NULL );
			bu_free_external( &tmp );
			continue;
		}
		bu_free_external( &tmp );
		dp->d_flags |= DIR_HIDDEN;
	}

	return TCL_OK;
}

static int
wdb_hide_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_hide_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_unhide_cmd(struct rt_wdb	*wdbp,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	struct directory		*dp;
	struct db_i			*dbip;
	struct bu_external		ext;
	struct bu_external		tmp;
	struct db5_raw_internal		raw;
	int				i;

	WDB_TCL_CHECK_READ_ONLY;

	if( argc < 2 ) {
		struct bu_vls vls;

		bu_vls_init( &vls );
		bu_vls_printf(&vls, "helplib_alias wdb_unhide %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	RT_CK_WDB( wdbp );

	dbip = wdbp->dbip;

	RT_CK_DBI( dbip );
	if( dbip->dbi_version < 5 ) {
	  Tcl_AppendResult(interp, 
			   "Database was created with a previous release of BRL-CAD.\nSelect \"Tools->Upgrade Database...\" to enable support for this feature.",
			   (char *)NULL );
		return TCL_ERROR;
	}

	for( i=1 ; i<argc ; i++ ) {
		if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY )) == DIR_NULL ) {
			continue;
		}

		RT_CK_DIR( dp );

		BU_INIT_EXTERNAL(&ext);

		if( db_get_external( &ext, dp, dbip ) < 0 ) {
			Tcl_AppendResult(interp, "db_get_external failed for ",
					 dp->d_namep, " \n", (char *)NULL );
			continue;
		}

		if (db5_get_raw_internal_ptr(&raw, ext.ext_buf) == NULL) {
			Tcl_AppendResult(interp, "db5_get_raw_internal_ptr() failed for ",
					 dp->d_namep, " \n", (char *)NULL );
			bu_free_external( &ext );
			continue;
		}

		raw.h_name_hidden = (unsigned char)(0x0);

		BU_INIT_EXTERNAL( &tmp );
		db5_export_object3( &tmp, DB5HDR_HFLAGS_DLI_APPLICATION_DATA_OBJECT,
			dp->d_namep,
			raw.h_name_hidden,
			&raw.attributes,
			&raw.body,
			raw.major_type, raw.minor_type,
			raw.a_zzz, raw.b_zzz );
		bu_free_external( &ext );

		if( db_put_external( &tmp, dp, dbip ) ) {
			Tcl_AppendResult(interp, "db_put_external() failed for ",
					 dp->d_namep, " \n", (char *)NULL );
			bu_free_external( &tmp );
			continue;
		}
		bu_free_external( &tmp );
		dp->d_flags &= (~DIR_HIDDEN);
	}

	return TCL_OK;
}

static int
wdb_unhide_tcl(ClientData	clientData,
	       Tcl_Interp	*interp,
	       int		argc,
	       char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_unhide_cmd(wdbp, interp, argc-1, argv+1);
}

/*		W D B _ A T T R _ C M D
 *
 *	implements the "attr" command
 *
 *	argv[1] is a sub-command:
 *		get - get attributes
 *		set - add a new attribute or replace an existing one
 *		rm  - remove an attribute
 *		append - append to an existing attribute
 *		edit - invoke an editor to edit all attributes
 *
 *	argv[2] is the name of the object
 *
 *	for "get" or "show", remaining args are attribute names (or none for all)
 *
 *	for "set", remaining args are attribute name, attribute value..
 *
 *	for "rm", remaining args are all attribute names
 *
 *	for "append", remaining args are attribute name, value to append, ...
 *
 *	for "edit", remaining args are attribute names
 */
int
wdb_attr_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	int			i;
	struct directory	*dp;
	struct bu_attribute_value_set avs;
	struct bu_attribute_value_pair	*avpp;

	/* this is only valid for v5 databases */
	if( wdbp->dbip->dbi_version < 5 ) {
		Tcl_AppendResult(interp, "Attributes are not available for this database format.\nPlease upgrade your database format using \"dbupgrade\" to enable attributes.", (char *)NULL );
		return TCL_ERROR;
	}

	if (argc < 3 ) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_attr %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* Verify that this wdb supports lookup operations
	   (non-null dbip) */
	if (wdbp->dbip == 0) {
		Tcl_AppendResult(interp,
				 "db does not support lookup operations",
				 (char *)NULL);
		return TCL_ERROR;
	}

	if( (dp=db_lookup( wdbp->dbip, argv[2], LOOKUP_QUIET)) == DIR_NULL ) {
		Tcl_AppendResult(interp,
				 argv[2],
				 " does not exist\n",
				 (char *)NULL );
		return TCL_ERROR;
	}

	
	if( db5_get_attributes( wdbp->dbip, &avs, dp ) ) {
		Tcl_AppendResult(interp,
				 "Cannot get attributes for object ", dp->d_namep, "\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( strcmp( argv[1], "get" ) == 0 ) {
		if( argc == 3 ) {
			/* just list all the attributes */
			avpp = avs.avp;
			for( i=0 ; i < avs.count ; i++, avpp++ ) {
				Tcl_AppendResult(interp, avpp->name, " {",
					 avpp->value, "} ", (char *)NULL );
			}
		} else {
			const char *val;
			int do_separators=argc-4; /* if more than one attribute */

			for( i=3 ; i<argc ; i++ ) {
				val = bu_avs_get( &avs, argv[i] );
				if( !val ) {
					Tcl_ResetResult( interp );
					Tcl_AppendResult(interp, "Object ",
					      dp->d_namep, " does not have a ",
					      argv[i], " attribute\n",
					      (char *)NULL );
					bu_avs_free( &avs );
					return TCL_ERROR;
				}
				if( do_separators ) {
					Tcl_AppendResult(interp,
							 "{",
							 val,
							 "} ",
						 (char *)NULL );
				} else {
					Tcl_AppendResult(interp, val,
						 (char *)NULL );
				}
			}
		}

		bu_avs_free( &avs );
		return TCL_OK;

	} else if( strcmp( argv[1], "set" ) == 0 ) {
		/* setting attribute/value pairs */
		if( (argc - 3) % 2 ) {
			Tcl_AppendResult(interp,
		          "Error: attribute names and values must be in pairs!!!\n",
			  (char *)NULL );
			bu_avs_free( &avs );
			return TCL_ERROR;
		}

		i = 3;
		while( i < argc ) {
			(void)bu_avs_add( &avs, argv[i], argv[i+1] );
			i += 2;
		}
		if( db5_update_attributes( dp, &avs, wdbp->dbip ) ) {
			Tcl_AppendResult(interp,
				      "Error: failed to update attributes\n",
				      (char *)NULL );
			bu_avs_free( &avs );
			return TCL_ERROR;
		}

		/* avs is freed by db5_update_attributes() */
		return TCL_OK;
	} else if( strcmp( argv[1], "rm" ) == 0 ) {
		i = 3;
		while( i < argc ) {
			(void)bu_avs_remove( &avs, argv[i] );
			i++;
		}
		if( db5_replace_attributes( dp, &avs, wdbp->dbip ) ) {
			Tcl_AppendResult(interp,
				 "Error: failed to update attributes\n",
				  (char *)NULL );
			bu_avs_free( &avs );
			return TCL_ERROR;
		}

		/* avs is freed by db5_replace_attributes() */
		return TCL_OK;
	} else if( strcmp( argv[1], "append" ) == 0 ) {
		if( (argc-3)%2 ) {
			Tcl_AppendResult(interp,
		          "Error: attribute names and values must be in pairs!!!\n",
			  (char *)NULL );
			bu_avs_free( &avs );
			return TCL_ERROR;
		}
		i = 3;
		while( i < argc ) {
			const char *old_val;

			old_val = bu_avs_get( &avs, argv[i] );
			if( !old_val ) {
				(void)bu_avs_add( &avs, argv[i], argv[i+1] );
			} else {
				struct bu_vls vls;

				bu_vls_init( &vls );
				bu_vls_strcat( &vls, old_val );
				bu_vls_strcat( &vls, argv[i+1] );
				bu_avs_add_vls( &avs, argv[i], &vls );
				bu_vls_free( &vls );
			}

			i += 2;
		}
		if( db5_replace_attributes( dp, &avs, wdbp->dbip ) ) {
			Tcl_AppendResult(interp,
				 "Error: failed to update attributes\n",
				  (char *)NULL );
			bu_avs_free( &avs );
			return TCL_ERROR;
		}

		/* avs is freed by db5_replace_attributes() */
		return TCL_OK;
	} else if( strcmp( argv[1], "show" ) == 0 ) {
		struct bu_vls vls;
		int max_attr_name_len=0;
		int tabs1=0;

		/* pretty print */
		bu_vls_init( &vls );
		if( dp->d_flags & DIR_COMB ) {
			if( dp->d_flags & DIR_REGION ) {
				bu_vls_printf( &vls, "%s region:\n", argv[2] );
			} else {
				bu_vls_printf( &vls, "%s combination:\n", argv[2] );
			}
		} else if( dp->d_flags & DIR_SOLID ) {
			bu_vls_printf( &vls, "%s %s:\n", argv[2],
				       rt_functab[dp->d_minor_type].ft_label );
		} else {
		    switch( dp->d_major_type ) {
			case DB5_MAJORTYPE_ATTRIBUTE_ONLY:
				bu_vls_printf( &vls, "%s global:\n", argv[2] );
				break;
			case DB5_MAJORTYPE_BINARY_EXPM:
				bu_vls_printf( &vls, "%s binary(expm):\n", argv[2] );
				break;
			case DB5_MAJORTYPE_BINARY_MIME:
				bu_vls_printf( &vls, "%s binary(mime):\n", argv[2] );
				break;	
			case DB5_MAJORTYPE_BINARY_UNIF:
				bu_vls_printf( &vls, "%s %s:\n", argv[2],
					       binu_types[dp->d_minor_type] );
				break;	
			}
		}
		if( argc == 3 ) {
			/* just display all attributes */
			avpp = avs.avp;
			for( i=0 ; i < avs.count ; i++, avpp++ ) {
				int len;

				len = strlen( avpp->name );
				if( len > max_attr_name_len ) {
					max_attr_name_len = len;
				}
			}
			tabs1 = 2 + max_attr_name_len/8;
			avpp = avs.avp;
			for( i=0 ; i < avs.count ; i++, avpp++ ) {
				const char *c;
				int tabs2;
				int k;
				int len;

				bu_vls_printf( &vls, "\t%s", avpp->name );
				len = strlen( avpp->name );
				tabs2 = tabs1 - 1 - len/8;
				for( k=0 ; k<tabs2 ; k++ ) {
					bu_vls_putc( &vls, '\t' );
				}
				c = avpp->value;
				while( *c ) {
					bu_vls_putc( &vls, *c );
					if( *c == '\n' ) {
						for( k=0 ; k<tabs1 ; k++ ) {
							bu_vls_putc( &vls, '\t' );
						}
					}
					c++;
				}
				bu_vls_putc( &vls, '\n' );
			}
		} else {
			const char *val;
			int len;

			/* show just the specified attributes */
			for( i=0 ; i<argc ; i++ ) {
				len = strlen( argv[i] );
				if( len > max_attr_name_len ) {
					max_attr_name_len = len;
				}
			}
			tabs1 = 2 + max_attr_name_len/8;
			for( i=3 ; i<argc ; i++ ) {
				int tabs2;
				int k;
				const char *c;

				val = bu_avs_get( &avs, argv[i] );
				if( !val ) {
					Tcl_ResetResult( interp );
					Tcl_AppendResult(interp, "Object ",
					      dp->d_namep, " does not have a ",
					      argv[i], " attribute\n",
					      (char *)NULL );
					bu_avs_free( &avs );
					return TCL_ERROR;
				}
				bu_vls_printf( &vls, "\t%s", argv[i] );
				len = strlen( val );
				tabs2 = tabs1 - 1 - len/8;
				for( k=0 ; k<tabs2 ; k++ ) {
					bu_vls_putc( &vls, '\t' );
				}
				c = val;
				while( *c ) {
					bu_vls_putc( &vls, *c );
					if( *c == '\n' ) {
						for( k=0 ; k<tabs1 ; k++ ) {
							bu_vls_putc( &vls, '\t' );
						}
					}
					c++;
				}
				bu_vls_putc( &vls, '\n' );
			}
		}
		Tcl_AppendResult(interp, bu_vls_addr( &vls ), (char *)NULL );
		bu_vls_free( &vls );
		return TCL_OK;
	} else {
		struct bu_vls vls;

		Tcl_AppendResult(interp,
				 "ERROR: unrecognized attr subcommand ",
				 argv[1], "\n",
				 (char *)NULL );
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_attr %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

}

int
wdb_attr_tcl(ClientData	clientData,
	     Tcl_Interp     *interp,
	     int		argc,
	     char	      **argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_attr_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_nmg_simplify_cmd(struct rt_wdb	*wdbp,
		     Tcl_Interp		*interp,
		     int		argc,
		     char 		**argv)
{
	struct directory *dp;
	struct rt_db_internal nmg_intern;
	struct rt_db_internal new_intern;
	struct model *m;
	struct nmgregion *r;
	struct shell *s;
	int do_all=1;
	int do_arb=0;
	int do_tgc=0;
	int do_poly=0;
	char *new_name;
	char *nmg_name;
	int success = 0;
	int shell_count=0;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc < 3 || 4 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_nmg_simplify %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	RT_INIT_DB_INTERNAL(&new_intern);

	if (argc == 4) {
		do_all = 0;
		if (!strncmp(argv[1], "arb", 3))
			do_arb = 1;
		else if (!strncmp(argv[1], "tgc", 3))
			do_tgc = 1;
		else if (!strncmp(argv[1], "poly", 4))
			do_poly = 1;
		else {
			struct bu_vls vls;

			bu_vls_init(&vls);
			bu_vls_printf(&vls, "helplib_alias wdb_nmg_simplify %s", argv[0]);
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		new_name = argv[2];
		nmg_name = argv[3];
	} else {
		new_name = argv[1];
		nmg_name = argv[2];
	}

	if (db_lookup(wdbp->dbip, new_name, LOOKUP_QUIET) != DIR_NULL) {
		Tcl_AppendResult(interp, new_name, " already exists\n", (char *)NULL);
		return TCL_ERROR;
	}

	if ((dp=db_lookup(wdbp->dbip, nmg_name, LOOKUP_QUIET)) == DIR_NULL) {
		Tcl_AppendResult(interp, nmg_name, " does not exist\n", (char *)NULL);
		return TCL_ERROR;
	}

	if (rt_db_get_internal(&nmg_intern, dp, wdbp->dbip, bn_mat_identity, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
		return TCL_ERROR;
	}

	if (nmg_intern.idb_type != ID_NMG) {
		Tcl_AppendResult(interp, nmg_name, " is not an NMG solid\n", (char *)NULL);
		rt_db_free_internal(&nmg_intern, &rt_uniresource);
		return TCL_ERROR;
	}

	m = (struct model *)nmg_intern.idb_ptr;
	NMG_CK_MODEL(m);

	/* count shells */
	for (BU_LIST_FOR(r, nmgregion, &m->r_hd)) {
		for (BU_LIST_FOR(s, shell, &r->s_hd))
			shell_count++;
	}

	if ((do_arb || do_all) && shell_count == 1) {
		struct rt_arb_internal *arb_int;

		BU_GETSTRUCT( arb_int, rt_arb_internal );

		if (nmg_to_arb(m, arb_int)) {
			new_intern.idb_ptr = (genptr_t)(arb_int);
			new_intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
			new_intern.idb_type = ID_ARB8;
			new_intern.idb_meth = &rt_functab[ID_ARB8];
			success = 1;
		} else if (do_arb) {
			/* see if we can get an arb by simplifying the NMG */

			r = BU_LIST_FIRST( nmgregion, &m->r_hd );
			s = BU_LIST_FIRST( shell, &r->s_hd );
			nmg_shell_coplanar_face_merge( s, &wdbp->wdb_tol, 1 );
			if (!nmg_kill_cracks(s)) {
				(void) nmg_model_edge_fuse( m, &wdbp->wdb_tol );
				(void) nmg_model_edge_g_fuse( m, &wdbp->wdb_tol );
				(void) nmg_unbreak_region_edges( &r->l.magic );
				if (nmg_to_arb(m, arb_int)) {
					new_intern.idb_ptr = (genptr_t)(arb_int);
					new_intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
					new_intern.idb_type = ID_ARB8;
					new_intern.idb_meth = &rt_functab[ID_ARB8];
					success = 1;
				}
			}
			if (!success) {
				rt_db_free_internal( &nmg_intern, &rt_uniresource );
				Tcl_AppendResult(interp, "Failed to construct an ARB equivalent to ",
						 nmg_name, "\n", (char *)NULL);
				return TCL_OK;
			}
		}
	}

	if ((do_tgc || do_all) && !success && shell_count == 1) {
		struct rt_tgc_internal *tgc_int;

		BU_GETSTRUCT( tgc_int, rt_tgc_internal );

		if (nmg_to_tgc(m, tgc_int, &wdbp->wdb_tol)) {
			new_intern.idb_ptr = (genptr_t)(tgc_int);
			new_intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
			new_intern.idb_type = ID_TGC;
			new_intern.idb_meth = &rt_functab[ID_TGC];
			success = 1;
		} else if (do_tgc) {
			rt_db_free_internal( &nmg_intern, &rt_uniresource );
			Tcl_AppendResult(interp, "Failed to construct a TGC equivalent to ",
					 nmg_name, "\n", (char *)NULL);
			return TCL_OK;
		}
	}

	/* see if we can get an arb by simplifying the NMG */
	if ((do_arb || do_all) && !success && shell_count == 1) {
		struct rt_arb_internal *arb_int;

		BU_GETSTRUCT( arb_int, rt_arb_internal );

		r = BU_LIST_FIRST( nmgregion, &m->r_hd );
		s = BU_LIST_FIRST( shell, &r->s_hd );
		nmg_shell_coplanar_face_merge( s, &wdbp->wdb_tol, 1 );
		if (!nmg_kill_cracks(s)) {
			(void) nmg_model_edge_fuse( m, &wdbp->wdb_tol );
			(void) nmg_model_edge_g_fuse( m, &wdbp->wdb_tol );
			(void) nmg_unbreak_region_edges( &r->l.magic );
			if (nmg_to_arb(m, arb_int )) {
				new_intern.idb_ptr = (genptr_t)(arb_int);
				new_intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
				new_intern.idb_type = ID_ARB8;
				new_intern.idb_meth = &rt_functab[ID_ARB8];
				success = 1;
			}
			else if (do_arb) {
				rt_db_free_internal( &nmg_intern, &rt_uniresource );
				Tcl_AppendResult(interp, "Failed to construct an ARB equivalent to ",
						 nmg_name, "\n", (char *)NULL);
				return TCL_OK;
			}
		}
	}

	if ((do_poly || do_all) && !success) {
		struct rt_pg_internal *poly_int;

		poly_int = (struct rt_pg_internal *)bu_malloc( sizeof( struct rt_pg_internal ), "f_nmg_simplify: poly_int" );

		if (nmg_to_poly( m, poly_int, &wdbp->wdb_tol)) {
			new_intern.idb_ptr = (genptr_t)(poly_int);
			new_intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
			new_intern.idb_type = ID_POLY;
			new_intern.idb_meth = &rt_functab[ID_POLY];
			success = 1;
		}
		else if (do_poly) {
			rt_db_free_internal( &nmg_intern, &rt_uniresource );
			Tcl_AppendResult(interp, nmg_name, " is not a closed surface, cannot make a polysolid\n", (char *)NULL);
			return TCL_OK;
		}
	}

	if (success) {
		r = BU_LIST_FIRST( nmgregion, &m->r_hd );
		s = BU_LIST_FIRST( shell, &r->s_hd );

		if (BU_LIST_NON_EMPTY( &s->lu_hd))
			Tcl_AppendResult(interp, "wire loops in ", nmg_name,
					 " have been ignored in conversion\n", (char *)NULL);

		if (BU_LIST_NON_EMPTY(&s->eu_hd))
			Tcl_AppendResult(interp, "wire edges in ", nmg_name,
					 " have been ignored in conversion\n", (char *)NULL);

		if (s->vu_p)
			Tcl_AppendResult(interp, "Single vertexuse in shell of ", nmg_name,
					 " has been ignored in conversion\n", (char *)NULL);

		rt_db_free_internal( &nmg_intern, &rt_uniresource );

		if ((dp=db_diradd(wdbp->dbip, new_name, -1L, 0, DIR_SOLID, (genptr_t)&new_intern.idb_type)) == DIR_NULL) {
			Tcl_AppendResult(interp, "Cannot add ", new_name, " to directory\n", (char *)NULL );
			return TCL_ERROR;
		}

		if (rt_db_put_internal(dp, wdbp->dbip, &new_intern, &rt_uniresource) < 0) {
			rt_db_free_internal( &new_intern, &rt_uniresource );
			WDB_TCL_WRITE_ERR_return;
		}
		return TCL_OK;
	}

	Tcl_AppendResult(interp, "simplification to ", argv[1],
			 " is not yet supported\n", (char *)NULL);
	return TCL_ERROR;
}

/*
 * Usage:
 *        procname nmg_simplify [arb|tgc|ell|poly] new_solid nmg_solid
 */
static int
wdb_nmg_simplify_tcl(ClientData		clientData,
		     Tcl_Interp		*interp,
		     int		argc,
		     char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_nmg_simplify_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_nmg_collapse_cmd(struct rt_wdb	*wdbp,
		      Tcl_Interp	*interp,
		      int		argc,
		      char 		**argv)
{
	char *new_name;
	struct model *m;
	struct rt_db_internal intern;
	struct directory *dp;
	long count;
	char count_str[32];
	fastf_t tol_coll;
	fastf_t min_angle;

	WDB_TCL_CHECK_READ_ONLY;

	if (argc < 4) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_nmg_collapse %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (strchr(argv[2], '/')) {
		Tcl_AppendResult(interp, "Do not use '/' in solid names: ", argv[2], "\n", (char *)NULL);
		return TCL_ERROR;
	}

	new_name = argv[2];
	
	if (db_lookup(wdbp->dbip, new_name, LOOKUP_QUIET) != DIR_NULL) {
		Tcl_AppendResult(interp, new_name, " already exists\n", (char *)NULL);
		return TCL_ERROR;
	}

	if ((dp=db_lookup(wdbp->dbip, argv[1], LOOKUP_NOISY)) == DIR_NULL)
		return TCL_ERROR;

	if (dp->d_flags & DIR_COMB) {
		Tcl_AppendResult(interp, argv[1], " is a combination, only NMG primitives are allowed here\n", (char *)NULL );
		return TCL_ERROR;
	}

	if (rt_db_get_internal(&intern, dp, wdbp->dbip, (matp_t)NULL, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "Failed to get internal form of ", argv[1], "!!!!\n", (char *)NULL);
		return TCL_ERROR;
	}

	if (intern.idb_type != ID_NMG) {
		Tcl_AppendResult(interp, argv[1], " is not an NMG solid!!!!\n", (char *)NULL);
		rt_db_free_internal(&intern, &rt_uniresource);
		return TCL_ERROR;
	}

	tol_coll = atof(argv[3]) * wdbp->dbip->dbi_local2base;
	if (tol_coll <= 0.0) {
		Tcl_AppendResult(interp, "tolerance distance too small\n", (char *)NULL);
		return TCL_ERROR;
	}

	if (argc == 5) {
		min_angle = atof(argv[4]);
		if (min_angle < 0.0) {
			Tcl_AppendResult(interp, "Minimum angle cannot be less than zero\n", (char *)NULL);
			return TCL_ERROR;
		}
	} else
		min_angle = 0.0;

	m = (struct model *)intern.idb_ptr;
	NMG_CK_MODEL(m);

	/* triangulate model */
	nmg_triangulate_model(m, &wdbp->wdb_tol);

	count = nmg_edge_collapse(m, &wdbp->wdb_tol, tol_coll, min_angle);

	if ((dp=db_diradd(wdbp->dbip, new_name, -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL) {
		Tcl_AppendResult(interp, "Cannot add ", new_name, " to directory\n", (char *)NULL);
		rt_db_free_internal(&intern, &rt_uniresource);
		return TCL_ERROR;
	}

	if (rt_db_put_internal(dp, wdbp->dbip, &intern, &rt_uniresource) < 0) {
		rt_db_free_internal(&intern, &rt_uniresource);
		WDB_TCL_WRITE_ERR_return;
	}

	rt_db_free_internal(&intern, &rt_uniresource);

	sprintf(count_str, "%ld", count);
	Tcl_AppendResult(interp, count_str, " edges collapsed\n", (char *)NULL);

	return TCL_OK;
}

/*
 * Usage:
 *        procname nmg_collapse nmg_solid new_solid maximum_error_distance [minimum_allowed_angle]
 */
static int
wdb_nmg_collapse_tcl(ClientData	clientData,
		      Tcl_Interp	*interp,
		      int		argc,
		      char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_nmg_collapse_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_summary_cmd(struct rt_wdb	*wdbp,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	register char *cp;
	int flags = 0;
	int bad = 0;

	if (argc < 1 || 2 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_summary %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (argc <= 1) {
		wdb_dir_summary(wdbp->dbip, interp, 0);
		return TCL_OK;
	}

	cp = argv[1];
	while (*cp)  switch(*cp++) {
	case 'p':
		flags |= DIR_SOLID;
		break;
	case 'r':
		flags |= DIR_REGION;
		break;
	case 'g':
		flags |= DIR_COMB;
		break;
	default:
		Tcl_AppendResult(interp, "summary:  P R or G are only valid parmaters\n",
				 (char *)NULL);
		bad = 1;
		break;
	}

	wdb_dir_summary(wdbp->dbip, interp, flags);
	return bad ? TCL_ERROR : TCL_OK;
}

/*
 * Usage:
 *        procname 
 */
static int
wdb_summary_tcl(ClientData	clientData,
		Tcl_Interp	*interp,
		int		argc,
		char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_summary_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_pathlist_cmd(struct rt_wdb	*wdbp,
		 Tcl_Interp	*interp,
		 int		argc,
		 char 		**argv)
{
	if (argc < 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_pathlist %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (db_walk_tree(wdbp->dbip, argc-1, (const char **)argv+1, 1,
			 &wdbp->wdb_initial_tree_state,
			 0, 0, wdb_pathlist_leaf_func, (genptr_t)interp) < 0) {
		Tcl_AppendResult(interp, "wdb_pathlist: db_walk_tree() error", (char *)NULL);
		return TCL_ERROR;
	}

	return TCL_OK;
}

/*
 * Usage:
 *        procname 
 */
static int
wdb_pathlist_tcl(ClientData	clientData,
		 Tcl_Interp	*interp,
		 int		argc,
		 char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_pathlist_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_smooth_bot_cmd(struct rt_wdb	*wdbp,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	char *new_bot_name, *old_bot_name;
	struct directory *dp_old, *dp_new;
	struct rt_bot_internal *old_bot;
	struct rt_db_internal intern;
	fastf_t tolerance_angle=180.0;
	int arg_index=1;
	int id;

	/* check that we are using a version 5 database */
	if( wdbp->dbip->dbi_version < 5 ) {
		Tcl_AppendResult(interp, "This is an older database version.\n",
			"It does not support BOT surface normals.\n",
			"Use \"dbupgrade\" to upgrade this database to the current version.\n",
			(char *)NULL );
		return TCL_ERROR;
	}

	if( argc < 3 ) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_smooth_bot %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	while( *argv[arg_index] == '-' ) {
		/* this is an option */
		if( !strcmp( argv[arg_index], "-t" ) ) {
			arg_index++;
			tolerance_angle = atof( argv[arg_index] );
		} else {
			struct bu_vls vls;

			bu_vls_init(&vls);
			bu_vls_printf(&vls, "helplib_alias wdb_smooth_bot %s", argv[0]);
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}
		arg_index++;
	}

	if( arg_index >= argc ) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_smooth_bot %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	new_bot_name = argv[arg_index++];
	old_bot_name = argv[arg_index];

	if( (dp_old=db_lookup( wdbp->dbip, old_bot_name, LOOKUP_QUIET ) ) == DIR_NULL ) {
		Tcl_AppendResult(interp, old_bot_name, " does not exist!!\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( strcmp( old_bot_name, new_bot_name ) ) {

		if( (dp_new=db_lookup( wdbp->dbip, new_bot_name, LOOKUP_QUIET ) ) != DIR_NULL ) {
			Tcl_AppendResult(interp, new_bot_name, " already exists!!\n", (char *)NULL );
			return TCL_ERROR;
		}
	} else {
		dp_new = dp_old;
	}

	if( (id=rt_db_get_internal( &intern, dp_old, wdbp->dbip, NULL, wdbp->wdb_resp ) ) < 0 ) {
		Tcl_AppendResult(interp, "Failed to get internal form of ", old_bot_name, "\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( id != ID_BOT ) {
		Tcl_AppendResult(interp, old_bot_name, " is not a BOT primitive\n", (char *)NULL );
		rt_db_free_internal( &intern, wdbp->wdb_resp );
		return TCL_ERROR;
	}

	old_bot = (struct rt_bot_internal *)intern.idb_ptr;
	RT_BOT_CK_MAGIC( old_bot );

	if( rt_smooth_bot( old_bot, old_bot_name, wdbp->dbip, tolerance_angle*M_PI/180.0 ) ) {
		Tcl_AppendResult(interp, "Failed to smooth ", old_bot_name, "\n", (char *)NULL );
		rt_db_free_internal( &intern, wdbp->wdb_resp );
		return TCL_ERROR;
	}

	if( dp_new == DIR_NULL ) {
		if( (dp_new=db_diradd( wdbp->dbip, new_bot_name, -1L, 0, DIR_SOLID,
				   (genptr_t)&intern.idb_type)) == DIR_NULL ) {
			rt_db_free_internal(&intern, wdbp->wdb_resp);
			Tcl_AppendResult(interp, "Cannot add ", new_bot_name, " to directory\n", (char *)NULL);
			return TCL_ERROR;
		}
	}

	if( rt_db_put_internal( dp_new, wdbp->dbip, &intern, wdbp->wdb_resp ) < 0 ) {
		rt_db_free_internal(&intern, wdbp->wdb_resp);
		Tcl_AppendResult(interp, "Database write error, aborting.\n", (char *)NULL);
		return TCL_ERROR;
	}

	rt_db_free_internal( &intern, wdbp->wdb_resp );

	return TCL_OK;
}

static int
wdb_smooth_bot_tcl(ClientData	clientData,
		 Tcl_Interp	*interp,
		 int		argc,
		 char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_smooth_bot_cmd(wdbp, interp, argc-1, argv+1);
}

int
wdb_binary_cmd(struct rt_wdb	*wdbp,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	int c;
	struct bu_vls	vls;
	unsigned int minor_type=0;
	char *obj_name;
	char *file_name;
	int input_mode=0;
	int output_mode=0;
	struct rt_binunif_internal *bip;
	struct rt_db_internal intern;
	struct directory *dp;
	char *cname;

	/* check that we are using a version 5 database */
	if( wdbp->dbip->dbi_version < 5 ) {
		Tcl_AppendResult(interp, "This is an older database version.\n",
			"It does not support binary objects.\n",
			"Use \"dbupgrade\" to upgrade this database to the current version.\n",
			(char *)NULL );
		return TCL_ERROR;
	}

	bu_optind = 1;		/* re-init bu_getopt() */
	bu_opterr = 0;          /* suppress bu_getopt()'s error message */
	while ((c=bu_getopt(argc, argv, "iou:")) != EOF) {
		switch (c) {
			case 'i':
				input_mode = 1;
				break;
			case 'o':
				output_mode = 1;
				break;
			default:
				bu_vls_init( &vls );
				bu_vls_printf(&vls, "Unrecognized option - %c", c);
				Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
				bu_vls_free(&vls);
				return TCL_ERROR;
				
		}
	}

	cname = argv[0];

	if( input_mode + output_mode != 1 ) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_binary %s", cname);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	argc -= bu_optind;
	argv += bu_optind;

	if ( (input_mode && argc != 4) || (output_mode && argc != 2) ) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_binary %s", cname);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}


	if( input_mode ) {
		if (argv[0][0] == 'u') {

			if (argv[1][1] != '\0') {
				bu_vls_init(&vls);
				bu_vls_printf(&vls, "Unrecognized minor type: %s", argv[1]);
				Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
				bu_vls_free(&vls);
				return TCL_ERROR;
			}

			switch ((int)argv[1][0]) {
			case 'f':
				minor_type = DB5_MINORTYPE_BINU_FLOAT;
				break;
			case 'd':
				minor_type = DB5_MINORTYPE_BINU_DOUBLE;
				break;
			case 'c':
				minor_type = DB5_MINORTYPE_BINU_8BITINT;
				break;
			case 's':
				minor_type = DB5_MINORTYPE_BINU_16BITINT;
				break;
			case 'i':
				minor_type = DB5_MINORTYPE_BINU_32BITINT;
				break;
			case 'l':
				minor_type = DB5_MINORTYPE_BINU_64BITINT;
				break;
			case 'C':
				minor_type = DB5_MINORTYPE_BINU_8BITINT_U;
				break;
			case 'S':
				minor_type = DB5_MINORTYPE_BINU_16BITINT_U;
				break;
			case 'I':
				minor_type = DB5_MINORTYPE_BINU_32BITINT_U;
				break;
			case 'L':
				minor_type = DB5_MINORTYPE_BINU_64BITINT_U;
				break;
			default:
				bu_vls_init(&vls);
				bu_vls_printf(&vls, "Unrecognized minor type: %s", argv[1]);
				Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
				bu_vls_free(&vls);
				return TCL_ERROR;
			}
		} else {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "Unrecognized major type: %s", argv[0]);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		/* skip past major_type and minor_type */
		argc -= 2;
		argv += 2;

		if( minor_type == 0 ) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "helplib_alias wdb_binary %s", cname);
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		obj_name = *argv;
		if( db_lookup( wdbp->dbip, obj_name, LOOKUP_QUIET ) != DIR_NULL ) {
			bu_vls_init( &vls );
			bu_vls_printf( &vls, "Object %s already exists", obj_name );
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free( &vls );
			return TCL_ERROR;
		}

		argc--;
		argv++;

		file_name = *argv;

		if( mk_binunif( wdbp, obj_name, file_name, minor_type ) ) {
			Tcl_AppendResult(interp, "Error creating ", obj_name,
					 (char *)NULL );
			return TCL_ERROR;
		}

		return TCL_OK;

	} else if( output_mode ) {
		FILE *fd;

		file_name = *argv;

		argc--;
		argv++;

		obj_name = *argv;

		if( (dp=db_lookup(wdbp->dbip, obj_name, LOOKUP_NOISY )) == DIR_NULL ) { 
			return TCL_ERROR;
		}
		if( !( dp->d_major_type & DB5_MAJORTYPE_BINARY_MASK) ) {
			Tcl_AppendResult(interp, obj_name, " is not a binary object", (char *)NULL );
			return TCL_ERROR;
		}

		if( dp->d_major_type != DB5_MAJORTYPE_BINARY_UNIF ) {
			Tcl_AppendResult(interp, "source must be a uniform binary object",
					 (char *)NULL );
			return TCL_ERROR;
		}
		
		if( (fd=fopen( file_name, "w+")) == NULL ) {
			Tcl_AppendResult(interp, "Error: cannot open file ", file_name,
					 " for writing", (char *)NULL );
			return TCL_ERROR;
		}

		if( rt_db_get_internal( &intern, dp, wdbp->dbip, NULL,
					 &rt_uniresource ) < 0 ) {
			Tcl_AppendResult(interp, "Error reading ", dp->d_namep,
					 " from database", (char *)NULL );
			fclose( fd );
			return TCL_ERROR;
		}

		RT_CK_DB_INTERNAL( &intern );

		bip = (struct rt_binunif_internal *)intern.idb_ptr;
		if( bip->count < 1 ) {
			Tcl_AppendResult(interp, obj_name, " has no contents", (char *)NULL );
			fclose( fd );
			rt_db_free_internal( &intern, &rt_uniresource );
			return TCL_ERROR;
		}

		if( fwrite( bip->u.int8, bip->count * db5_type_sizeof_h_binu( bip->type ),
			    1, fd) != 1 ) {
			Tcl_AppendResult(interp, "Error writing contents to file",
					 (char *)NULL );
			fclose( fd );
			rt_db_free_internal( &intern, &rt_uniresource );
			return TCL_ERROR;
		}

		fclose( fd );
		rt_db_free_internal( &intern, &rt_uniresource );
		return TCL_OK;
	} else {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_binary %s", cname);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* should never get here */
	/* return TCL_ERROR; */
}

/*
 * Usage:
 *        procname binary args
 */
static int
wdb_binary_tcl(ClientData	clientData,
	       Tcl_Interp	*interp,
	       int		argc,
	       char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_binary_cmd(wdbp, interp, argc-1, argv+1);
}

int wdb_bot_face_sort_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	int i;
	int tris_per_piece=0;
	struct bu_vls vls;
	int warnings=0;

	if( argc < 3 ) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_bot_face_sort %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	tris_per_piece = atoi( argv[1] );
	if( tris_per_piece < 1 ) {
		Tcl_AppendResult(interp, "Illegal value for triangle per piece (",
				 argv[1],
				 ")\n",
				 (char *)NULL );
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_bot_face_sort %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_init( &vls );
	for( i=2 ; i<argc ; i++ ) {
		struct directory *dp;
		struct rt_db_internal intern;
		struct rt_bot_internal *bot;
		int id;

		if( (dp=db_lookup( wdbp->dbip, argv[i], LOOKUP_NOISY ) ) == DIR_NULL ) {
			continue;
		}

		if( (id=rt_db_get_internal( &intern, dp, wdbp->dbip, bn_mat_identity, wdbp->wdb_resp )) < 0 ) {
			bu_vls_printf( &vls,
			   "Failed to get internal form of %s, not sorting this one\n",
			    dp->d_namep ); 
			warnings++;
			continue;
		}

		if( id != ID_BOT ) {
			rt_db_free_internal( &intern, wdbp->wdb_resp );
			bu_vls_printf( &vls,
				       "%s is not a BOT primitive, skipped\n",
				       dp->d_namep );
			warnings++;
			continue;
		}

		bot = (struct rt_bot_internal *)intern.idb_ptr;
		RT_BOT_CK_MAGIC( bot );

		bu_log( "processing %s (%d triangles)\n", dp->d_namep, bot->num_faces );
		while( Tcl_DoOneEvent( TCL_DONT_WAIT | TCL_FILE_EVENTS ) );
		if( rt_bot_sort_faces( bot, tris_per_piece ) ) {
			rt_db_free_internal( &intern, wdbp->wdb_resp );
			bu_vls_printf( &vls,
				       "Face sort failed for %s, this BOT not sorted\n",
				       dp->d_namep );
			warnings++;
			continue;
		}

		if( rt_db_put_internal( dp, wdbp->dbip, &intern, wdbp->wdb_resp ) ) {
			if( warnings ) {
				Tcl_AppendResult(interp, bu_vls_addr( &vls ),
						 (char *)NULL );
			}
			Tcl_AppendResult(interp, "Failed to write sorted BOT (",
					 dp->d_namep,
					 ") to database!!! (This is very bad)\n" );
			rt_db_free_internal( &intern, wdbp->wdb_resp );
			bu_vls_free( &vls );
			return( TCL_ERROR );
		}
	}

	if( warnings ) {
		Tcl_AppendResult(interp, bu_vls_addr( &vls ), (char *)NULL );
	}
	bu_vls_free( &vls );
	return( TCL_OK );
}

/*
 * Usage:
 *        procname 
 */
static int
wdb_bot_face_sort_tcl(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_bot_face_sort_cmd(wdbp, interp, argc-1, argv+1);
}


#if 0
/* skeleton functions for wdb_obj methods */
int
wdb__cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
}

/*
 * Usage:
 *        procname 
 */
static int
wdb__tcl(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb__cmd(wdbp, interp, argc-1, argv+1);
}
#endif

/****************** utility routines ********************/

/*
 *			W D B _ C M P D I R N A M E
 *
 * Given two pointers to pointers to directory entries, do a string compare
 * on the respective names and return that value.
 *  This routine was lifted from mged/columns.c.
 */
int
wdb_cmpdirname(const genptr_t a,
	       const genptr_t b)
{
	register struct directory **dp1, **dp2;

	dp1 = (struct directory **)a;
	dp2 = (struct directory **)b;
	return( strcmp( (*dp1)->d_namep, (*dp2)->d_namep));
}

#define RT_TERMINAL_WIDTH 80
#define RT_COLUMNS ((RT_TERMINAL_WIDTH + RT_NAMESIZE - 1) / RT_NAMESIZE)

/*
 *			V L S _ C O L _ I T E M
 */
void
wdb_vls_col_item(struct bu_vls	*str,
		 register char	*cp,
		 int		*ccp,		/* column count pointer */
		 int		*clp)		/* column length pointer */
{
	/* Output newline if last column printed. */
	if (*ccp >= RT_COLUMNS || (*clp+RT_NAMESIZE-1) >= RT_TERMINAL_WIDTH) {
		/* line now full */
		bu_vls_putc(str, '\n');
		*ccp = 0;
	} else if (*ccp != 0) {
		/* Space over before starting new column */
		do {
			bu_vls_putc(str, ' ');
			++*clp;
		}  while ((*clp % RT_NAMESIZE) != 0);
	}
	/* Output string and save length for next tab. */
	*clp = 0;
	while (*cp != '\0') {
		bu_vls_putc(str, *cp);
		++cp;
		++*clp;
	}
	++*ccp;
}

/*
 */
void
wdb_vls_col_eol(struct bu_vls	*str,
		int		*ccp,
		int		*clp)
{
	if (*ccp != 0)		/* partial line */
		bu_vls_putc(str, '\n');
	*ccp = 0;
	*clp = 0;
}

/*
 *			W D B _ V L S _ C O L _ P R 4 V
 *
 *  Given a pointer to a list of pointers to names and the number of names
 *  in that list, sort and print that list in column order over four columns.
 *  This routine was lifted from mged/columns.c.
 */
void
wdb_vls_col_pr4v(struct bu_vls		*vls,
		 struct directory	**list_of_names,
		 int			num_in_list,
		 int			no_decorate)
{
#if 0
	int lines, i, j, namelen, this_one;

	qsort((genptr_t)list_of_names,
	      (unsigned)num_in_list, (unsigned)sizeof(struct directory *),
	      (int (*)())wdb_cmpdirname);

	/*
	 * For the number of (full and partial) lines that will be needed,
	 * print in vertical format.
	 */
	lines = (num_in_list + 3) / 4;
	for (i=0; i < lines; i++) {
		for (j=0; j < 4; j++) {
			this_one = j * lines + i;
			/* Restrict the print to 16 chars per spec. */
			bu_vls_printf(vls,  "%.16s", list_of_names[this_one]->d_namep);
			namelen = strlen(list_of_names[this_one]->d_namep);
			if (namelen > 16)
				namelen = 16;
			/*
			 * Region and ident checks here....  Since the code
			 * has been modified to push and sort on pointers,
			 * the printing of the region and ident flags must
			 * be delayed until now.  There is no way to make the
			 * decision on where to place them before now.
			 */
			if (list_of_names[this_one]->d_flags & DIR_COMB) {
				bu_vls_putc(vls, '/');
				namelen++;
			}
			if (list_of_names[this_one]->d_flags & DIR_REGION) {
				bu_vls_putc(vls, 'R');
				namelen++;
			}
			/*
			 * Size check (partial lines), and line termination.
			 * Note that this will catch the end of the lines
			 * that are full too.
			 */
			if (this_one + lines >= num_in_list) {
				bu_vls_putc(vls, '\n');
				break;
			} else {
				/*
				 * Pad to next boundary as there will be
				 * another entry to the right of this one. 
				 */
				while (namelen++ < 20)
					bu_vls_putc(vls, ' ');
			}
		}
	}
#else
	int lines, i, j, k, namelen, this_one;
	int	maxnamelen;	/* longest name in list */
	int	cwidth;		/* column width */
	int	numcol;		/* number of columns */

	qsort((genptr_t)list_of_names,
	      (unsigned)num_in_list, (unsigned)sizeof(struct directory *),
	      (int (*)())wdb_cmpdirname);

	/* 
	 * Traverse the list of names, find the longest name and set the
	 * the column width and number of columns accordingly.
	 * If the longest name is greater than 80 characters, the number of columns
	 * will be one.
	 */
	maxnamelen = 0;
	for (k=0; k < num_in_list; k++) {
		namelen = strlen(list_of_names[k]->d_namep);
		if (namelen > maxnamelen)
			maxnamelen = namelen;
	}

	if (maxnamelen <= 16) 
		maxnamelen = 16;
	cwidth = maxnamelen + 4;

	if (cwidth > 80)
		cwidth = 80;
	numcol = RT_TERMINAL_WIDTH / cwidth;
     
	/*
	 * For the number of (full and partial) lines that will be needed,
	 * print in vertical format.
	 */
	lines = (num_in_list + (numcol - 1)) / numcol;
	for (i=0; i < lines; i++) {
		for (j=0; j < numcol; j++) {
			this_one = j * lines + i;
			bu_vls_printf(vls, "%s", list_of_names[this_one]->d_namep);
			namelen = strlen( list_of_names[this_one]->d_namep);

			/*
			 * Region and ident checks here....  Since the code
			 * has been modified to push and sort on pointers,
			 * the printing of the region and ident flags must
			 * be delayed until now.  There is no way to make the
			 * decision on where to place them before now.
			 */
			if ( !no_decorate && list_of_names[this_one]->d_flags & DIR_COMB) {
				bu_vls_putc(vls, '/');
				namelen++;
			}

			if ( !no_decorate && list_of_names[this_one]->d_flags & DIR_REGION) {
				bu_vls_putc(vls, 'R');
				namelen++;
			}

			/*
			 * Size check (partial lines), and line termination.
			 * Note that this will catch the end of the lines
			 * that are full too.
			 */
			if (this_one + lines >= num_in_list) {
				bu_vls_putc(vls, '\n');
				break;
			} else {
				/*
				 * Pad to next boundary as there will be
				 * another entry to the right of this one. 
				 */
				while( namelen++ < cwidth)
					bu_vls_putc(vls, ' ');
			}
		}
	}
#endif
}

void
wdb_vls_long_dpp(struct bu_vls		*vls,
		 struct directory	**list_of_names,
		 int			num_in_list,
		 int			aflag,		/* print all objects */
		 int			cflag,		/* print combinations */
		 int			rflag,		/* print regions */
		 int			sflag)		/* print solids */
{
	int i;
	int isComb=0, isRegion=0;
	int isSolid=0;
	const char *type=NULL;
	int max_nam_len = 0;
	int max_type_len = 0;
	struct directory *dp;

	qsort((genptr_t)list_of_names,
	      (unsigned)num_in_list, (unsigned)sizeof(struct directory *),
	      (int (*)())wdb_cmpdirname);

	for (i=0 ; i < num_in_list ; i++) {
		int len;

		dp = list_of_names[i];
		len = strlen(dp->d_namep);
		if (len > max_nam_len)
			max_nam_len = len;

		if (dp->d_flags & DIR_REGION)
			len = 6;
		else if (dp->d_flags & DIR_COMB)
			len = 4;
		else if( dp->d_flags & DIR_SOLID )
			len = strlen(rt_functab[dp->d_minor_type].ft_label);
		else {
			switch(list_of_names[i]->d_major_type) {
			case DB5_MAJORTYPE_ATTRIBUTE_ONLY:
				len = 6;
				break;
			case DB5_MAJORTYPE_BINARY_MIME:
				len = strlen( "binary (mime)" );
				break;
			case DB5_MAJORTYPE_BINARY_UNIF:
				len = strlen( binu_types[list_of_names[i]->d_minor_type] );
				break;
			case DB5_MAJORTYPE_BINARY_EXPM:
				len = strlen( "binary(expm)" );
				break;
			}
		}

		if (len > max_type_len)
			max_type_len = len;
	}

	/*
	 * i - tracks the list item
	 */
	for (i=0; i < num_in_list; ++i) {
		if (list_of_names[i]->d_flags & DIR_COMB) {
			isComb = 1;
			isSolid = 0;
			type = "comb";

			if (list_of_names[i]->d_flags & DIR_REGION) {
				isRegion = 1;
				type = "region";
			} else
				isRegion = 0;
		} else if( list_of_names[i]->d_flags & DIR_SOLID )  {
			isComb = isRegion = 0;
			isSolid = 1;
			type = rt_functab[list_of_names[i]->d_minor_type].ft_label;
		} else {
			switch(list_of_names[i]->d_major_type) { 
			case DB5_MAJORTYPE_ATTRIBUTE_ONLY:
				isSolid = 0;
				type = "global";
				break;
			case DB5_MAJORTYPE_BINARY_EXPM:
				isSolid = 0;
				isRegion = 0;
				type = "binary(expm)";
				break;
			case DB5_MAJORTYPE_BINARY_MIME:
				isSolid = 0;
				isRegion = 0;
				type = "binary(mime)";
				break;	
			case DB5_MAJORTYPE_BINARY_UNIF:
				isSolid = 0;
				isRegion = 0;
				type = binu_types[list_of_names[i]->d_minor_type];
				break;	
			}
		}

		/* print list item i */
		dp = list_of_names[i];
		if (aflag ||
		    (!cflag && !rflag && !sflag) ||
		    (cflag && isComb) ||
		    (rflag && isRegion) ||
		    (sflag && isSolid)) {
			bu_vls_printf(vls, "%s", dp->d_namep );
			bu_vls_spaces(vls, max_nam_len - strlen( dp->d_namep ) );
			bu_vls_printf(vls, " %s", type );
			bu_vls_spaces(vls, max_type_len - strlen( type ) );
			bu_vls_printf(vls,  " %2d %2d %d\n",
				      dp->d_major_type, dp->d_minor_type, dp->d_len);
		}
	}
}

/*
 *			W D B _ V L S _ L I N E _ D P P
 *
 *  Given a pointer to a list of pointers to names and the number of names
 *  in that list, sort and print that list on the same line.
 *  This routine was lifted from mged/columns.c.
 */
void
wdb_vls_line_dpp(struct bu_vls	*vls,
		 struct directory **list_of_names,
		 int		num_in_list,
		 int		aflag,	/* print all objects */
		 int		cflag,	/* print combinations */
		 int		rflag,	/* print regions */
		 int		sflag)	/* print solids */
{
	int i;
	int isComb, isRegion;
	int isSolid;

	qsort( (genptr_t)list_of_names,
	       (unsigned)num_in_list, (unsigned)sizeof(struct directory *),
	       (int (*)())wdb_cmpdirname);

	/*
	 * i - tracks the list item
	 */
	for (i=0; i < num_in_list; ++i) {
		if (list_of_names[i]->d_flags & DIR_COMB) {
			isComb = 1;
			isSolid = 0;

			if (list_of_names[i]->d_flags & DIR_REGION)
				isRegion = 1;
			else
				isRegion = 0;
		} else {
			isComb = isRegion = 0;
			isSolid = 1;
		}

		/* print list item i */
		if (aflag ||
		    (!cflag && !rflag && !sflag) ||
		    (cflag && isComb) ||
		    (rflag && isRegion) ||
		    (sflag && isSolid)) {
			bu_vls_printf(vls,  "%s ", list_of_names[i]->d_namep);
		}
	}
}

/*
 *			W D B _ G E T S P A C E
 *
 * This routine walks through the directory entry list and mallocs enough
 * space for pointers to hold:
 *  a) all of the entries if called with an argument of 0, or
 *  b) the number of entries specified by the argument if > 0.
 *  This routine was lifted from mged/dir.c.
 */
struct directory **
wdb_getspace(struct db_i	*dbip,
	     register int	num_entries)
{
	register struct directory **dir_basep;

	if (num_entries < 0) {
		bu_log("wdb_getspace: was passed %d, used 0\n",
		       num_entries);
		num_entries = 0;
	}

	if (num_entries == 0)  num_entries = db_get_directory_size(dbip);

	/* Allocate and cast num_entries worth of pointers */
	dir_basep = (struct directory **) bu_malloc((num_entries+1) * sizeof(struct directory *),
						    "wdb_getspace *dir[]" );
	return(dir_basep);
}

/*
 *			W D B _ D O _ L I S T
 */
void
wdb_do_list(struct db_i		*dbip,
	    Tcl_Interp		*interp,
	    struct bu_vls	*outstrp,
	    register struct directory *dp,
	    int			verbose)
{
	int			id;
	struct rt_db_internal	intern;

	RT_CK_DBI(dbip);

	if( dp->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY ) {
		/* this is the _GLOBAL object */
		struct bu_attribute_value_set avs;
		struct bu_attribute_value_pair	*avp;

		bu_vls_strcat( outstrp, dp->d_namep );
		bu_vls_strcat( outstrp, ": global attributes object\n" );
		if( db5_get_attributes( dbip, &avs, dp ) ) {
			Tcl_AppendResult(interp, "Cannot get attributes for ", dp->d_namep,
					 "\n", (char *)NULL );
			return;
		}
		for( BU_AVS_FOR( avp, &avs ) ) {
			if( !strcmp( avp->name, "units" ) ) {
				double conv;
				const char *str;

				conv = atof( avp->value );
				bu_vls_strcat( outstrp, "\tunits: " );
				if( (str=bu_units_string( conv ) ) == NULL ) {
					bu_vls_strcat( outstrp, "Unrecognized units\n" );
				} else {
					bu_vls_strcat( outstrp, str );
					bu_vls_putc( outstrp, '\n' );
				}
			} else {
				bu_vls_putc( outstrp, '\t' );
				bu_vls_strcat( outstrp, avp->name );
				bu_vls_strcat( outstrp, ": " );
				bu_vls_strcat( outstrp, avp->value );
				bu_vls_putc( outstrp, '\n' );
			}
		}
	} else {

		if ((id = rt_db_get_internal(&intern, dp, dbip,
					     (fastf_t *)NULL, &rt_uniresource)) < 0) {
			Tcl_AppendResult(interp, "rt_db_get_internal(", dp->d_namep,
					 ") failure\n", (char *)NULL);
			return;
		}

		bu_vls_printf(outstrp, "%s:  ", dp->d_namep);
		
		if (rt_functab[id].ft_describe(outstrp, &intern,
					       verbose, dbip->dbi_base2local, &rt_uniresource, dbip) < 0)
			Tcl_AppendResult(interp, dp->d_namep, ": describe error\n", (char *)NULL);
		rt_db_free_internal(&intern, &rt_uniresource);
	}
}

/*
 *			W D B _ C O M B A D D
 *
 * Add an instance of object 'objp' to combination 'name'.
 * If the combination does not exist, it is created.
 * region_flag is 1 (region), or 0 (group).
 *
 *  Preserves the GIFT semantics.
 */
struct directory *
wdb_combadd(Tcl_Interp			*interp,
	    struct db_i			*dbip,
	    register struct directory	*objp,
	    char			*combname,
	    int				region_flag,	/* true if adding region */
	    int				relation,	/* = UNION, SUBTRACT, INTERSECT */
	    int				ident,		/* "Region ID" */
	    int				air,		/* Air code */
	    struct rt_wdb		*wdbp)
{
	register struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	union tree *tp;
	struct rt_tree_array *tree_list;
	int node_count;
	int actual_count;

	/*
	 * Check to see if we have to create a new combination
	 */
	if ((dp = db_lookup(dbip,  combname, LOOKUP_QUIET)) == DIR_NULL) {
		int flags;

		if (region_flag)
			flags = DIR_REGION | DIR_COMB;
		else
			flags = DIR_COMB;

		RT_INIT_DB_INTERNAL(&intern);
		intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		intern.idb_type = ID_COMBINATION;
		intern.idb_meth = &rt_functab[ID_COMBINATION];

		/* Update the in-core directory */
		if ((dp = db_diradd(dbip, combname, -1, 0, flags, (genptr_t)&intern.idb_type)) == DIR_NULL)  {
			Tcl_AppendResult(interp, "An error has occured while adding '",
					 combname, "' to the database.\n", (char *)NULL);
			return DIR_NULL;
		}

		BU_GETSTRUCT(comb, rt_comb_internal);
		intern.idb_ptr = (genptr_t)comb;
		comb->magic = RT_COMB_MAGIC;
		bu_vls_init(&comb->shader);
		bu_vls_init(&comb->material);
		comb->region_id = 0;  /* This makes a comb/group by default */
		comb->tree = TREE_NULL;
		
		if (region_flag) {
			struct bu_vls tmp_vls;

			comb->region_flag = 1;
			comb->region_id = ident;
			comb->aircode = air;
			comb->los = wdbp->wdb_los_default;
			comb->GIFTmater = wdbp->wdb_mat_default;
			bu_vls_init(&tmp_vls);
			bu_vls_printf(&tmp_vls,
				      "Creating region id=%d, air=%d, GIFTmaterial=%d, los=%d\n",
				      ident, air, 
					wdbp->wdb_mat_default,
					wdbp->wdb_los_default);
			Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			bu_vls_free(&tmp_vls);
		} else {
			comb->region_flag = 0;
		}
		RT_GET_TREE( tp, &rt_uniresource );
		tp->magic = RT_TREE_MAGIC;
		tp->tr_l.tl_op = OP_DB_LEAF;
		tp->tr_l.tl_name = bu_strdup( objp->d_namep );
		tp->tr_l.tl_mat = (matp_t)NULL;
		comb->tree = tp;

		if (rt_db_put_internal(dp, dbip, &intern, &rt_uniresource) < 0) {
			Tcl_AppendResult(interp, "Failed to write ", dp->d_namep, (char *)NULL );
			return DIR_NULL;
		}
		return dp;
	} else if (!(dp->d_flags & DIR_COMB)) {
		Tcl_AppendResult(interp, combname, " exists, but is not a combination\n", (char *)NULL);
		return DIR_NULL;
	}

	/* combination exists, add a new member */
	if (rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "read error, aborting\n", (char *)NULL);
		return DIR_NULL;
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB(comb);

	if (region_flag && !comb->region_flag) {
		Tcl_AppendResult(interp, combname, ": not a region\n", (char *)NULL);
		return DIR_NULL;
	}

	if (comb->tree && db_ck_v4gift_tree(comb->tree) < 0) {
		db_non_union_push(comb->tree, &rt_uniresource);
		if (db_ck_v4gift_tree(comb->tree) < 0) {
			Tcl_AppendResult(interp, "Cannot flatten tree for editing\n", (char *)NULL);
			rt_db_free_internal(&intern, &rt_uniresource);
			return DIR_NULL;
		}
	}

	/* make space for an extra leaf */
	node_count = db_tree_nleaves( comb->tree ) + 1;
	tree_list = (struct rt_tree_array *)bu_calloc( node_count,
						       sizeof( struct rt_tree_array ), "tree list" );

	/* flatten tree */
	if (comb->tree) {
		actual_count = 1 + (struct rt_tree_array *)db_flatten_tree(
			tree_list, comb->tree, OP_UNION, 1, &rt_uniresource )
			- tree_list;
		BU_ASSERT_LONG( actual_count, ==, node_count );
		comb->tree = TREE_NULL;
	}

	/* insert new member at end */
	switch (relation) {
	case '+':
		tree_list[node_count - 1].tl_op = OP_INTERSECT;
		break;
	case '-':
		tree_list[node_count - 1].tl_op = OP_SUBTRACT;
		break;
	default:
		Tcl_AppendResult(interp, "unrecognized relation (assume UNION)\n",
				 (char *)NULL );
	case 'u':
		tree_list[node_count - 1].tl_op = OP_UNION;
		break;
	}

	/* make new leaf node, and insert at end of list */
	RT_GET_TREE( tp, &rt_uniresource );
	tree_list[node_count-1].tl_tree = tp;
	tp->tr_l.magic = RT_TREE_MAGIC;
	tp->tr_l.tl_op = OP_DB_LEAF;
	tp->tr_l.tl_name = bu_strdup( objp->d_namep );
	tp->tr_l.tl_mat = (matp_t)NULL;

	/* rebuild the tree */
	comb->tree = (union tree *)db_mkgift_tree( tree_list, node_count, &rt_uniresource );

	/* and finally, write it out */
	if (rt_db_put_internal(dp, dbip, &intern, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "Failed to write ", dp->d_namep, (char *)NULL);
		return DIR_NULL;
	}

	bu_free((char *)tree_list, "combadd: tree_list");

	return (dp);
}

static void
wdb_do_identitize(struct db_i		*dbip,
		  struct rt_comb_internal *comb,
		  union tree		*comb_leaf,
		  genptr_t		user_ptr1,
		  genptr_t		user_ptr2,
		  genptr_t		user_ptr3)
{
	struct directory *dp;
	Tcl_Interp *interp = (Tcl_Interp *)user_ptr1;

	RT_CK_DBI(dbip);
	RT_CK_TREE(comb_leaf);

	if (!comb_leaf->tr_l.tl_mat) {
		comb_leaf->tr_l.tl_mat = (matp_t)bu_malloc(sizeof(mat_t), "tl_mat");
	}
	MAT_IDN(comb_leaf->tr_l.tl_mat);
	if ((dp = db_lookup(dbip, comb_leaf->tr_l.tl_name, LOOKUP_NOISY)) == DIR_NULL)
		return;

	wdb_identitize(dp, dbip, interp);
}

/*
 *			W D B _ I D E N T I T I Z E ( ) 
 *
 *	Traverses an objects paths, setting all member matrices == identity
 *
 */
void
wdb_identitize(struct directory	*dp,
	       struct db_i	*dbip,
	       Tcl_Interp	*interp)
{
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;

	if (dp->d_flags & DIR_SOLID)
		return;
	if (rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "Database read error, aborting\n", (char *)NULL);
		return;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	if (comb->tree) {
		db_tree_funcleaf(dbip, comb, comb->tree, wdb_do_identitize,
				 (genptr_t)interp, (genptr_t)NULL, (genptr_t)NULL);
		if (rt_db_put_internal(dp, dbip, &intern, &rt_uniresource) < 0) {
			Tcl_AppendResult(interp, "Cannot write modified combination (", dp->d_namep,
					 ") to database\n", (char *)NULL );
			return;
		}
	}
}

/*
 *  			W D B _ D I R _ S U M M A R Y
 *
 * Summarize the contents of the directory by categories
 * (solid, comb, region).  If flag is != 0, it is interpreted
 * as a request to print all the names in that category (eg, DIR_SOLID).
 */
static void
wdb_dir_summary(struct db_i	*dbip,
		Tcl_Interp	*interp,
		int		flag)
{
	register struct directory *dp;
	register int i;
	static int sol, comb, reg;
	struct directory **dirp;
	struct directory **dirp0 = (struct directory **)NULL;
	struct bu_vls vls;

	bu_vls_init(&vls);

	sol = comb = reg = 0;
	for (i = 0; i < RT_DBNHASH; i++)  {
		for (dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw) {
			if (dp->d_flags & DIR_SOLID)
				sol++;
			if (dp->d_flags & DIR_COMB) {
				if (dp->d_flags & DIR_REGION)
					reg++;
				else
					comb++;
			}
		}
	}

	bu_vls_printf(&vls, "Summary:\n");
	bu_vls_printf(&vls, "  %5d primitives\n", sol);
	bu_vls_printf(&vls, "  %5d region; %d non-region combinations\n", reg, comb);
	bu_vls_printf(&vls, "  %5d total objects\n\n", sol+reg+comb );

	if (flag == 0) {
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
		return;
	}

	/* Print all names matching the flags parameter */
	/* THIS MIGHT WANT TO BE SEPARATED OUT BY CATEGORY */
	
	dirp = wdb_dir_getspace(dbip, 0);
	dirp0 = dirp;
	/*
	 * Walk the directory list adding pointers (to the directory entries
	 * of interest) to the array
	 */
	for (i = 0; i < RT_DBNHASH; i++)
		for(dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
			if (dp->d_flags & flag)
				*dirp++ = dp;

	wdb_vls_col_pr4v(&vls, dirp0, (int)(dirp - dirp0), 0);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
	bu_free((genptr_t)dirp0, "dir_getspace");
}

/*
 *			W D B _ D I R _ G E T S P A C E
 *
 * This routine walks through the directory entry list and mallocs enough
 * space for pointers to hold:
 *  a) all of the entries if called with an argument of 0, or
 *  b) the number of entries specified by the argument if > 0.
 */
static struct directory **
wdb_dir_getspace(struct db_i	*dbip,
		 register int	num_entries)
{
	register struct directory *dp;
	register int i;
	register struct directory **dir_basep;

	if (num_entries < 0) {
		bu_log( "dir_getspace: was passed %d, used 0\n",
			num_entries);
		num_entries = 0;
	}
	if (num_entries == 0) {
		/* Set num_entries to the number of entries */
		for (i = 0; i < RT_DBNHASH; i++)
			for(dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
				num_entries++;
	}

	/* Allocate and cast num_entries worth of pointers */
	dir_basep = (struct directory **) bu_malloc((num_entries+1) * sizeof(struct directory *),
						    "dir_getspace *dir[]");
	return dir_basep;
}

/*
 *			P A T H L I S T _ L E A F _ F U N C
 */
static union tree *
wdb_pathlist_leaf_func(struct db_tree_state	*tsp,
		       struct db_full_path	*pathp,
		       struct rt_db_internal	*ip,
		       genptr_t			client_data)
{
	Tcl_Interp	*interp = (Tcl_Interp *)client_data;
	char		*str;

	RT_CK_FULL_PATH(pathp);
	RT_CK_DB_INTERNAL(ip);

	str = db_path_to_string(pathp);

	Tcl_AppendElement(interp, str);

	bu_free((genptr_t)str, "path string");
	return TREE_NULL;
}

/*
 *			W D B _ B O T _ D E C I M A T E _ C M D
 */

int
wdb_bot_decimate_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	int c;
	struct rt_db_internal intern;
	struct rt_bot_internal *bot;
	struct directory *dp;
	fastf_t max_chord_error=-1.0;
	fastf_t max_normal_error=-1.0;
	fastf_t min_edge_length=-1.0;

	if( argc < 5 || argc > 9 ) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_bot_decimate %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* process args */
	bu_optind = 1;
	bu_opterr = 0;
	while( (c=bu_getopt(argc,argv,"c:n:e:")) != EOF )  {
		switch(c) {
			case 'c':
				max_chord_error = atof( bu_optarg );
				if( max_chord_error < 0.0 ) {
					Tcl_AppendResult(interp,
							 "Maximum chord error cannot be less than zero",
							 (char *)NULL );
					return TCL_ERROR;
				}
				break;
			case 'n':
				max_normal_error = atof( bu_optarg );
				if( max_normal_error < 0.0 ) {
					Tcl_AppendResult(interp,
							 "Maximum normal error cannot be less than zero",
							 (char *)NULL );
					return TCL_ERROR;
				}
				break;
			case 'e':
				min_edge_length = atof( bu_optarg );
				if( min_edge_length < 0.0 ) {
					Tcl_AppendResult(interp,
							 "minumum edge length cannot be less than zero",
							 (char *)NULL );
					return TCL_ERROR;
				}
				break;
			default:
				{
					struct bu_vls vls;

					bu_vls_init(&vls);
					bu_vls_printf(&vls, "helplib_alias wdb_bot_decimate %s",
						      argv[0]);
					Tcl_Eval(interp, bu_vls_addr(&vls));
					bu_vls_free(&vls);
					return TCL_ERROR;
				}
		}
	}

	argc -= bu_optind;
	argv += bu_optind;

	/* make sure new solid does not already exist */
	if( (dp=db_lookup( wdbp->dbip, argv[0], LOOKUP_QUIET ) ) != DIR_NULL ) {
	  Tcl_AppendResult(interp, argv[0], " already exists!!\n", (char *)NULL );
	  return TCL_ERROR;
	}

	/* make sure current solid does exist */
	if( (dp=db_lookup( wdbp->dbip, argv[1], LOOKUP_QUIET ) ) == DIR_NULL ) {
		Tcl_AppendResult(interp, argv[1], " Does not exist\n", (char *)NULL );
		return TCL_ERROR;
	}

	/* import the current solid */
	RT_INIT_DB_INTERNAL( &intern );
	if( rt_db_get_internal( &intern, dp, wdbp->dbip, NULL, wdbp->wdb_resp ) < 0 ) {
		Tcl_AppendResult(interp, "Failed to get internal form of ", argv[1],
				 "\n", (char *)NULL );
		return TCL_ERROR;
	}

	/* make sure this is a BOT solid */
	if( intern.idb_major_type != DB5_MAJORTYPE_BRLCAD ||
	    intern.idb_minor_type != DB5_MINORTYPE_BRLCAD_BOT ) {
		Tcl_AppendResult(interp, argv[1], " is not a BOT solid\n", (char *)NULL );
		rt_db_free_internal( &intern, wdbp->wdb_resp );
		return TCL_ERROR;
	}

	bot = (struct rt_bot_internal *)intern.idb_ptr;

	RT_BOT_CK_MAGIC( bot );

	/* convert maximum error and edge length to mm */
	max_chord_error = max_chord_error * wdbp->dbip->dbi_local2base;
	min_edge_length = min_edge_length * wdbp->dbip->dbi_local2base;

	/* do the decimation */
	if( rt_bot_decimate( bot, max_chord_error, max_normal_error, min_edge_length) < 0 ) {
		Tcl_AppendResult(interp, "Decimation Error\n", (char *)NULL );
		rt_db_free_internal( &intern, wdbp->wdb_resp );
		return TCL_ERROR;
	}

	/* save the result to the database */
	if( wdb_put_internal( wdbp, argv[0], &intern, 1.0 ) < 0 ) {
		Tcl_AppendResult(interp, "Failed to write decimated BOT back to database\n", (char *)NULL );
		return TCL_ERROR;
	}

	return TCL_OK;
}

/*
 * Usage:
 *        procname 
 */
static int
wdb_bot_decimate_tcl(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_bot_decimate_cmd(wdbp, interp, argc-1, argv+1);
}
@


1.184
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/wdb_obj.c,v 1.183 2004/05/10 15:25:27 morrison Exp $ (ARL)";
@


1.183
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.182 2004/04/05 08:48:58 morrison Exp $ (ARL)";
d29 5
a33 1
#include "conf.h"
@


1.182
log
@merge of ansi-6-0-branch into HEAD
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d155 5
d222 1
d332 1
d2293 4
a2296 1
			dgo_eraseobjall_callback(wdbp->dbip, interp, dp);
d2436 1
d2450 3
d2461 3
d2466 1
a2466 1
			    wdbp->wdb_resp, (genptr_t)interp);
d2495 3
a2497 3
		      genptr_t			*ptr)
{
	Tcl_Interp *interp = (Tcl_Interp *)ptr;
d2506 1
a2506 1
	dgo_eraseobjall_callback(interp, dbip, dp);
d4664 14
@


1.181
log
@Rewrote dbconcat command to allow it to handle objects that reference other objects
(like extrusions and DSP's)
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.180 2004/02/02 17:39:29 morrison Exp $ (ARL)";
d159 3
a161 3
extern int rt_tcl_rt();
extern int rt_tcl_import_from_path();
extern void rt_generic_make();
d164 1
a164 1
extern int wdb_comb_std_tcl();
d171 1
a171 1
HIDDEN int db5_scan();
d173 4
a176 4
int wdb_init_obj();
int wdb_get_tcl();
int wdb_attr_tcl();
int wdb_pathsum_cmd();
d178 1
a178 1
static int wdb_open_tcl();
d182 83
a264 2
static int wdb_decode_dbip();
static struct db_i *wdb_prep_dbip();
a265 80
static int wdb_cmd();
static int wdb_match_tcl();
static int wdb_put_tcl();
static int wdb_adjust_tcl();
static int wdb_form_tcl();
static int wdb_tops_tcl();
static int wdb_rt_gettrees_tcl();
static int wdb_shells_tcl();
static int wdb_dump_tcl();
static int wdb_dbip_tcl();
static int wdb_ls_tcl();
static int wdb_list_tcl();
static int wdb_pathsum_tcl();
static int wdb_expand_tcl();
static int wdb_kill_tcl();
static int wdb_killall_tcl();
static int wdb_killtree_tcl();
static void wdb_killtree_callback();
static int wdb_copy_tcl();
static int wdb_move_tcl();
static int wdb_move_all_tcl();
static int wdb_concat_tcl();
static int wdb_copyeval_tcl();
static int wdb_dup_tcl();
static int wdb_group_tcl();
static int wdb_remove_tcl();
static int wdb_region_tcl();
static int wdb_comb_tcl();
static int wdb_find_tcl();
static int wdb_facetize_tcl();
static int wdb_which_tcl();
static int wdb_title_tcl();
static int wdb_tree_tcl();
static int wdb_color_tcl();
static int wdb_prcolor_tcl();
static int wdb_tol_tcl();
static int wdb_push_tcl();
static int wdb_whatid_tcl();
static int wdb_keep_tcl();
static int wdb_cat_tcl();
static int wdb_instance_tcl();
static int wdb_observer_tcl();
static int wdb_reopen_tcl();
static int wdb_make_bb_tcl();
static int wdb_make_name_tcl();
static int wdb_units_tcl();
static int wdb_hide_tcl();
static int wdb_unhide_tcl();
static int wdb_xpush_tcl();
static int wdb_showmats_tcl();
static int wdb_nmg_collapse_tcl();
static int wdb_nmg_simplify_tcl();
static int wdb_summary_tcl();
static int wdb_pathlist_tcl();
static int wdb_lt_tcl();
static int wdb_version_tcl();
static int wdb_binary_tcl();
static int wdb_bot_face_sort_tcl();
static int wdb_bot_decimate_tcl();
static int wdb_smooth_bot_tcl();

static void wdb_deleteProc();
static void wdb_deleteProc_rt();

static void wdb_do_trace();
static void wdb_trace();

int wdb_cmpdirname();
void wdb_vls_col_item();
void wdb_vls_col_eol();
void wdb_vls_col_pr4v();
void wdb_vls_long_dpp();
void wdb_vls_line_dpp();
void wdb_do_list();
struct directory ** wdb_getspace();
struct directory *wdb_combadd();
void wdb_identitize();
static void wdb_dir_summary();
static struct directory ** wdb_dir_getspace();
static union tree *wdb_pathlist_leaf_func();
d352 1
a352 2
Wdb_Init(interp)
     Tcl_Interp *interp;
d370 1
a370 5
wdb_cmd(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d379 1
a379 2
wdb_deleteProc(clientData)
     ClientData clientData;
d564 1
a564 4
wdb_decode_dbip(interp, dbip_string, dbipp)
     Tcl_Interp *interp;
     char *dbip_string;
     struct db_i **dbipp;
d579 1
a579 3
wdb_prep_dbip(interp, filename)
     Tcl_Interp *interp;
     char *filename;
d1883 1
a1883 5
wdb_list_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d2240 1
a2240 5
wdb_expand_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d2764 1
a2764 5
wdb_move_all_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d3297 1
a3297 7
wdb_dir_check(input_dbip, name, laddr, len, flags, ptr)
     register struct db_i	*input_dbip;
     register const char	*name;
     long			laddr;
     int			len;
     int			flags;
     genptr_t			ptr;
d3432 1
a3432 5
wdb_dup_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d3561 1
a3561 5
wdb_remove_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d3666 1
a3666 5
wdb_region_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d3759 1
a3759 5
wdb_comb_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d4103 1
a4103 5
wdb_facetize_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d4116 1
a4116 5
wdb_find_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d4149 1
a4249 6
			if (comb->region_id != 0 && comb->aircode != 0) {
				Tcl_AppendResult(interp, "ERROR: ", dp->d_namep,
						 " has id and aircode!!!\n", (char *)NULL);
				continue;
			}

d4303 1
a4303 5
wdb_which_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d4691 1
a4691 5
wdb_tree_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d4934 1
a4934 5
wdb_prcolor_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d5663 1
a5663 1
static struct directory *Copy_object();
@


1.180
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.179 2003/11/19 21:45:04 jra Exp $ (ARL)";
d2793 5
a2797 49
static void
wdb_do_update(struct db_i		*dbip,
	      struct rt_comb_internal	*comb,
	      union tree		*comb_leaf,
	      genptr_t			user_ptr1,
	      genptr_t			user_ptr2,
	      genptr_t			user_ptr3)
{
	char	*mref;
	char	mref4[RT_NAMESIZE+2];
	struct bu_vls mref5;
	struct bu_vls *prestr;
	int	*ncharadd;

	if(dbip == DBI_NULL)
		return;

	RT_CK_DBI(dbip);
	RT_CK_TREE(comb_leaf);

	ncharadd = (int *)user_ptr1;
	prestr = (struct bu_vls *)user_ptr2;

	if( dbip->dbi_version < 5 ) {
		mref = mref4;
		(void)strncpy(mref, bu_vls_addr( prestr ), *ncharadd);
		(void)strncpy(mref+(*ncharadd),
			      comb_leaf->tr_l.tl_name,
			      RT_NAMESIZE-(*ncharadd) );
	} else {
		bu_vls_init( &mref5 );
		bu_vls_vlscat( &mref5, prestr );
		bu_vls_strcat( &mref5, comb_leaf->tr_l.tl_name );
		mref = bu_vls_addr( &mref5 );
	}
	bu_free(comb_leaf->tr_l.tl_name, "comb_leaf->tr_l.tl_name");
	comb_leaf->tr_l.tl_name = bu_strdup(mref);

	if( dbip->dbi_version >= 5 )
		bu_vls_free( &mref5 );
}

static int wdb_dir_add BU_ARGS((struct db_i *input_dbip, const char
	*name, long laddr, int len, int flags, genptr_t ptr));

struct dir_add_stuff {
	Tcl_Interp	*interp;
	struct db_i	*main_dbip;		/* the main database */
	struct rt_wdb	*wdbp;
a2799 348
/*
 *			W D B _ D I R _ A D D 5
 * V5 version of wdb_dir_add
 */
static void
wdb_dir_add5(struct db_i			*dbip,		/* db_i to add this object to */
	     const struct db5_raw_internal	*rip,
	     long				laddr,
	     genptr_t				client_data)
{
	struct bu_vls 		local5;
	char			*local;
	struct bu_external	ext;
	struct dir_add_stuff	*dasp = (struct dir_add_stuff *)client_data;
	struct db5_raw_internal	raw;
	struct directory	*dp;

	RT_CK_DBI( dbip );

	if( rip->h_dli == DB5HDR_HFLAGS_DLI_HEADER_OBJECT )  return;
	if( rip->h_dli == DB5HDR_HFLAGS_DLI_FREE_STORAGE ) {
		/* Record available free storage */
		rt_memfree( &(dbip->dbi_freep), rip->object_length, laddr );
		return;
	}
	
	/* If somehow it doesn't have a name, ignore it */
	if( rip->name.ext_buf == NULL )  return;

	if(RT_G_DEBUG&DEBUG_DB) {
		bu_log("wdb_dir_add5(dbip=x%x, name='%s', addr=x%x, len=%d)\n",
			dbip, (char *)rip->name.ext_buf, rip->object_length );
	}

	/* add to its own directory first */
	(void)db5_diradd( dbip, rip, laddr, NULL );

	/* do not concat GLOBAL object */
	if( rip->major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY &&
	    rip->minor_type == 0 )
		return;

	/* now add this object to the current database */
	bu_vls_init( &local5 );

	/* Add the prefix, if any */
	if( dasp->wdbp->wdb_ncharadd > 0 ) {
		bu_vls_vlscat( &local5, &dasp->wdbp->wdb_prestr );
		bu_vls_strcat( &local5, rip->name.ext_buf );
	} else {
		bu_vls_strcat( &local5, rip->name.ext_buf );
	}
	local = bu_vls_addr( &local5 );

	if( rip->minor_type != DB5_MINORTYPE_BRLCAD_COMBINATION ) {

		/* export object */
		db5_export_object3( &ext, rip->h_dli, local, 0, &rip->attributes,
			    &rip->body, rip->major_type, rip->minor_type,
			    rip->a_zzz, rip->b_zzz );

		if( db5_get_raw_internal_ptr( &raw, ext.ext_buf ) == NULL ) {
			Tcl_AppendResult(dasp->interp,
					 "db5_get_raw_internal_ptr() failed for ",
					 local,
					 ". This object ignored.\n",
					 (char *)NULL );
			bu_vls_free( &local5 );
			bu_free( ext.ext_buf, "ext.ext_buf" );
			return;
		}

		/* add to the main directory */
		dp = (struct directory *)db5_diradd( dasp->main_dbip, &raw, -1L, NULL );
		dp->d_len = 0;

		/* write to main database */
		if( db_put_external5( &ext, dp, dasp->main_dbip ) ) {
			Tcl_AppendResult(dasp->interp,
					 "db_put_external5() failed for ",
					 rip->name.ext_buf,
					 ". This object ignored.\n",
					 (char *)NULL );
			bu_vls_free( &local5 );
			bu_free( ext.ext_buf, "ext.ext_buf" );
			return;
		}

		Tcl_AppendResult(dasp->interp,
				 "Added ",
				 local,
				 "\n",
				 (char *)NULL );

		bu_vls_free( &local5 );
		bu_free( ext.ext_buf, "ext.ext_buf" );
	} else if( rip->major_type == DB5_MAJORTYPE_BRLCAD &&
		   rip->minor_type == DB5_MINORTYPE_BRLCAD_COMBINATION ) { 
		struct rt_db_internal in;
		struct rt_comb_internal *comb;

		/* export object */
		db5_export_object3( &ext, rip->h_dli, local, 0, &rip->attributes,
			    &rip->body, rip->major_type, rip->minor_type,
			    rip->a_zzz, rip->b_zzz );

		if( db5_get_raw_internal_ptr( &raw, ext.ext_buf ) == NULL ) {
			Tcl_AppendResult(dasp->interp,
					 "db5_get_raw_internal_ptr() failed for ",
					 local,
					 ". This object ignored.\n",
					 (char *)NULL );
			bu_vls_free( &local5 );
			bu_free( ext.ext_buf, "ext.ext_buf" );
			return;
		}

		RT_INIT_DB_INTERNAL( &in );
		if( rip->attributes.ext_nbytes > 0 ) {
			if( db5_import_attributes( &in.idb_avs, &rip->attributes ) < 0 )  {
				Tcl_AppendResult(dasp->interp,
						 "db5_import_attributes() failed for ",
						 local,
						 " (combination), this object will be missing attributes.\n",
						 (char *)NULL );
			}
		} else {
			in.idb_avs.magic = BU_AVS_MAGIC;
			in.idb_avs.count = 0;
			in.idb_avs.max = 0;
		}

		if( rt_comb_import5( &in, &rip->body, NULL, dasp->main_dbip, dasp->wdbp->wdb_resp, 0 ) ) {
			Tcl_AppendResult(dasp->interp,
					 "rt_comb_import5() Failed for ",
					 local,
					 ". Skipping this combination.\n",
					 (char *)NULL );
			bu_vls_free( &local5 );
			bu_free( ext.ext_buf, "ext.ext_buf" );
			return;
		}
		comb = (struct rt_comb_internal *)in.idb_ptr;
		RT_CHECK_COMB( comb );
		if (dasp->wdbp->wdb_ncharadd && comb->tree) {
			db_tree_funcleaf(dasp->main_dbip, comb, comb->tree, wdb_do_update,
			 (genptr_t)&(dasp->wdbp->wdb_ncharadd),
			 (genptr_t)&(dasp->wdbp->wdb_prestr), (genptr_t)NULL);
		}

		/* add to the main directory */
		dp = (struct directory *)db5_diradd( dasp->main_dbip, &raw, -1L, NULL );
		dp->d_len = 0;

		if (rt_db_put_internal(dp, dasp->main_dbip, &in, dasp->wdbp->wdb_resp ) < 0) {
			Tcl_AppendResult(dasp->interp,
				 "Failed writing ",
				 dp->d_namep, " to database\n", (char *)NULL);
			bu_vls_free( &local5 );
			bu_free( ext.ext_buf, "ext.ext_buf" );
			rt_db_free_internal( &in, dasp->wdbp->wdb_resp );
			return;
		}
		Tcl_AppendResult(dasp->interp,
				 "Added combination ",
				 local,
				 "\n",
				 (char *)NULL );
		bu_vls_free( &local5 );
		rt_db_free_internal( &in, dasp->wdbp->wdb_resp );
		bu_free( ext.ext_buf, "ext.ext_buf" );
	} else {
		Tcl_AppendResult(dasp->interp,
				 "Skipping non-BRLCAD object ",
				 local,
				 ", not yet supported\n",
				 (char *)NULL );
			bu_vls_free( &local5 );
			bu_free( ext.ext_buf, "ext.ext_buf" );
			return;
	}
}

/*
 *			W D B _ D I R _ A D D
 *
 *  Add a solid or conbination from an auxillary database
 *  into the primary database.
 */
static int
wdb_dir_add(register struct db_i	*input_dbip,
	    register const char		*name,
	    long			laddr,
	    int				len,
	    int				flags,
	    genptr_t			ptr)
{
	register struct directory *input_dp;
	register struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	struct bu_vls		local5;
	char			*local;
	char			local4[RT_NAMESIZE+2+2];
	unsigned char		type='0';
	struct dir_add_stuff	*dasp = (struct dir_add_stuff *)ptr;

	RT_CK_DBI(input_dbip);

	/* Add the prefix, if any */
	if( dasp->main_dbip->dbi_version < 5 ) {
		local = local4;
		if (dasp->wdbp->wdb_ncharadd > 0) {
			(void)strncpy(local, bu_vls_addr( &dasp->wdbp->wdb_prestr ), dasp->wdbp->wdb_ncharadd);
			(void)strncpy(local+dasp->wdbp->wdb_ncharadd, name, RT_NAMESIZE-dasp->wdbp->wdb_ncharadd);
		} else {
			(void)strncpy(local, name, RT_NAMESIZE);
		}
		local[RT_NAMESIZE] = '\0';
	} else {
		bu_vls_init( &local5 );
		bu_vls_vlscat( &local5, &dasp->wdbp->wdb_prestr );
		bu_vls_strcat( &local5, name );
		local = bu_vls_addr( &local5 );
	}
		
	/* Look up this new name in the existing (main) database */
	if ((dp = db_lookup(dasp->main_dbip, local, LOOKUP_QUIET)) != DIR_NULL) {
		register int	c;
		char		*loc2;
		char		loc2_4[RT_NAMESIZE+2+2];

		/* This object already exists under the (prefixed) name */
		/* Protect the database against duplicate names! */
		/* Change object names, but NOT any references made by combinations. */
		if( dasp->main_dbip->dbi_version < 5 ) {
			loc2 = loc2_4;
			(void)strncpy( loc2, local, RT_NAMESIZE );
			/* Shift name right two characters, and further prefix */
			strncpy(local+2, loc2, RT_NAMESIZE-2);
			local[1] = '_';			/* distinctive separater */
			local[RT_NAMESIZE] = '\0';	/* ensure null termination */

			for (c = 'A'; c <= 'Z'; c++) {
				local[0] = c;
				if ((dp = db_lookup(dasp->main_dbip, local, LOOKUP_QUIET)) == DIR_NULL)
					break;
			}
		} else {
			for( c = 'A' ; c <= 'Z' ; c++ ) {
				bu_vls_trunc( &local5, 0 );
				bu_vls_putc( &local5, c );
				bu_vls_putc( &local5, '_' );
				bu_vls_strncat( &local5, bu_vls_addr( &dasp->wdbp->wdb_prestr ), dasp->wdbp->wdb_ncharadd);
				bu_vls_strcat( &local5, name );
				local = bu_vls_addr( &local5 );
				if ((dp = db_lookup(dasp->main_dbip, local, LOOKUP_QUIET)) == DIR_NULL)
					break;
			}
			loc2 = bu_vls_addr( &local5 ) + 2;
		}
		if (c > 'Z') {
			Tcl_AppendResult(dasp->interp,
					 "wdb_dir_add: Duplicate of name '",
					 local, "', ignored\n", (char *)NULL);
			if( dasp->main_dbip->dbi_version >= 5 )
				bu_vls_free( &local5 );
			return 0;
		}
		Tcl_AppendResult(dasp->interp,
				 "mged_dir_add: Duplicate of '",
				 loc2, "' given new name '",
				 local, "'\nYou should have used the 'dup' command to detect this,\nand then specified a prefix for the 'dbconcat' command.\n", (char *)NULL );
	}

	/* First, register this object in input database */
	/* use bogus type here (since we don't know it) */
	if ((input_dp = db_diradd(input_dbip, name, laddr, len, flags, (genptr_t)&type)) == DIR_NULL) {
		if( dasp->main_dbip->dbi_version >= 5 )
			bu_vls_free( &local5 );
		return(-1);
	}

	if (rt_db_get_internal(&intern, input_dp, input_dbip, (fastf_t *)NULL, &rt_uniresource) < 0) {
		Tcl_AppendResult(dasp->interp, "Database read error, aborting\n", (char *)NULL);
		if (db_delete(dasp->main_dbip, dp) < 0 ||
		    db_dirdelete(dasp->main_dbip, dp) < 0) {
			Tcl_AppendResult(dasp->interp, "Database write error, aborting\n", (char *)NULL);
		}
		if( dasp->main_dbip->dbi_version >= 5 )
			bu_vls_free( &local5 );
	    	/* Abort processing on first error */
		return -1;
	}

	/* Then, register a new object in the main database */
	if ((dp = db_diradd(dasp->main_dbip, local, -1L, 0, flags, (genptr_t)&intern.idb_type)) == DIR_NULL) {
		if( dasp->main_dbip->dbi_version >= 5 )
			bu_vls_free( &local5 );
		return(-1);
	}

	/* Update any references.  Name is already correct. */
	if (flags & DIR_SOLID) {
		Tcl_AppendResult(dasp->interp,
				 "adding solid '",
				 local, "'\n", (char *)NULL);
		if (dasp->main_dbip->dbi_version < 5 && (dasp->wdbp->wdb_ncharadd + strlen(name)) > (unsigned)RT_NAMESIZE)
			Tcl_AppendResult(dasp->interp,
					 "WARNING: solid name \"",
					 bu_vls_addr( &dasp->wdbp->wdb_prestr ), name,
					 "\" truncated to \"",
					 local, "\"\n", (char *)NULL);
	} else if(flags & DIR_COMB) {
		Tcl_AppendResult(dasp->interp,
				 "adding  comb '",
				 local, "'\n", (char *)NULL);

		/* Update all the member records */
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		if (dasp->wdbp->wdb_ncharadd && comb->tree) {
			db_tree_funcleaf(dasp->main_dbip, comb, comb->tree, wdb_do_update,
			 (genptr_t)&(dasp->wdbp->wdb_ncharadd),
			 (genptr_t)&(dasp->wdbp->wdb_prestr), (genptr_t)NULL);
		}
	} else {
		Tcl_AppendResult(dasp->interp,
				 "WARNING: object name \"",
				 bu_vls_addr( &dasp->wdbp->wdb_prestr ), name,
				 "\" is of an unsupported type, not copied.\n",
				 (char *)NULL);
		return -1;
	}

	if (rt_db_put_internal(dp, dasp->main_dbip, &intern, &rt_uniresource) < 0) {
		Tcl_AppendResult(dasp->interp,
				 "Failed writing ",
				 dp->d_namep, " to database\n", (char *)NULL);
		if( dasp->main_dbip->dbi_version >= 5 )
			bu_vls_free( &local5 );
		return( -1 );
	}

	if( dasp->main_dbip->dbi_version >= 5 )
		bu_vls_free( &local5 );
	return 0;
}

d2802 1
d2810 1
a2810 1
	     int unique_mode )
d2827 15
a2841 8
	bu_vls_strcpy( &new_name, name );
	aname = bu_vls_addr( &new_name );
	while(  db_lookup( dbip, aname, LOOKUP_QUIET ) != DIR_NULL ||
		Tcl_FindHashEntry( used_names_tbl, aname ) != NULL ) {
		bu_vls_trunc( &new_name, 0 );
		num++;
		if( unique_mode == ADD_PREFIX ) {
			bu_vls_printf( &new_name, "%d_", num);
d2843 2
d2846 2
a2847 2
		if( unique_mode == ADD_SUFFIX ) {
			bu_vls_printf( &new_name, "_%d", num );
a2848 1
		aname = bu_vls_addr( &new_name );
d2867 1
a2867 1
	     int unique_mode )
d2874 1
a2874 1
						 name_tbl, used_names_tbl, unique_mode );
d2885 1
a2885 1
				      name_tbl, used_names_tbl, unique_mode );
d2887 1
a2887 1
				      name_tbl, used_names_tbl, unique_mode );
d2893 1
a2893 1
				      name_tbl, used_names_tbl, unique_mode );
d2906 1
a2906 1
	int unique_mode )
d2927 1
a2927 1
				adjust_names( interp, comb->tree, curr_dbip, name_tbl, used_names_tbl, unique_mode );
d2933 1
a2933 1
				new_name = get_new_name( extr->sketch_name, curr_dbip, name_tbl, used_names_tbl, unique_mode );
d2946 1
a2946 1
								 name_tbl, used_names_tbl, unique_mode );
d2956 1
a2956 1
	new_name = get_new_name(input_dp->d_namep, curr_dbip, name_tbl, used_names_tbl , unique_mode );
d2984 7
a2990 3
	struct dir_add_stuff	das;
	int			version;
	int			unique_mode=0;
d3004 2
d3007 2
a3008 5
		struct directory *dp;
		Tcl_HashTable name_tbl;
		Tcl_HashTable used_names_tbl;
		Tcl_HashEntry *ptr;
		Tcl_HashSearch search;
d3011 1
a3011 1
			unique_mode = ADD_PREFIX;
d3013 1
a3013 1
			unique_mode = ADD_SUFFIX;
a3022 32

		/* open the input file */
		if ((newdbp = db_open(argv[2], "r")) == DBI_NULL) {
			perror(argv[2]);
			Tcl_AppendResult(interp, "concat: Can't open ",
					 argv[2], (char *)NULL);
			return TCL_ERROR;
		}

		db_dirbuild( newdbp );

		/* visit each directory pointer in the input database */
		Tcl_InitHashTable( &name_tbl, TCL_STRING_KEYS );
		Tcl_InitHashTable( &used_names_tbl, TCL_STRING_KEYS );
		FOR_ALL_DIRECTORY_START( dp, newdbp )
			if( dp->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY ) {
				/* skip GLOBAL object */
				continue;
			}

			copy_object( interp, dp, newdbp, wdbp->dbip, &name_tbl,
				     &used_names_tbl, unique_mode );
		FOR_ALL_DIRECTORY_END;

		/* Free the Hash tables */
		ptr = Tcl_FirstHashEntry( &name_tbl, &search );
		while( ptr ) {
			bu_free( (char *)Tcl_GetHashValue( ptr ), "new name" );
			ptr = Tcl_NextHashEntry( &search );
		}
		Tcl_DeleteHashTable( &name_tbl );
		Tcl_DeleteHashTable( &used_names_tbl );
d3024 2
a3026 1
		bu_vls_trunc( &wdbp->wdb_prestr, 0 );
d3028 1
a3028 1
			(void)bu_vls_strcpy(&wdbp->wdb_prestr, argv[2]);
d3032 2
a3033 3
			if ((wdbp->wdb_ncharadd = bu_vls_strlen(&wdbp->wdb_prestr)) > 12) {
				wdbp->wdb_ncharadd = 12;
				bu_vls_trunc( &wdbp->wdb_prestr, 12 );
a3034 2
		} else {
			wdbp->wdb_ncharadd = bu_vls_strlen(&wdbp->wdb_prestr);
d3036 9
d3046 8
a3053 7
		/* open the input file */
		if ((newdbp = db_open(argv[1], "r")) == DBI_NULL) {
			perror(argv[1]);
			Tcl_AppendResult(interp, "concat: Can't open ",
					 argv[1], (char *)NULL);
			return TCL_ERROR;
		}
d3055 2
a3056 8
		/* Scan new database, adding everything encountered. */
		version = db_get_version( newdbp );
		if( version > 4 && wdbp->dbip->dbi_version < 5 ) {
			Tcl_AppendResult(interp, "concat: databases are incompatible, convert ",
					 wdbp->dbip->dbi_filename, " to version 5 first",
					 (char *)NULL );
			return TCL_ERROR;
		}
d3058 7
a3064 15
		das.interp = interp;
		das.main_dbip = wdbp->dbip;
		das.wdbp = wdbp;
		if (version < 5) {
			if (db_scan(newdbp, wdb_dir_add, 1, (genptr_t)&das) < 0) {
				Tcl_AppendResult(interp, "concat: db_scan failure", (char *)NULL);
				bad = 1;	
				/* Fall through, to close off database */
			}
		} else {
			if (db5_scan(newdbp, wdb_dir_add5, (genptr_t)&das) < 0) {
				Tcl_AppendResult(interp, "concat: db_scan failure", (char *)NULL);
				bad = 1;	
				/* Fall through, to close off database */
			}
a3065 4
		rt_mempurge(&(newdbp->dbi_freep));        /* didn't really build a directory */

		/* Free all the directory entries, and close the input database */
		db_close(newdbp);
d3067 17
a3083 1
		db_sync(wdbp->dbip);	/* force changes to disk */
d3085 2
@


1.179
log
@Mods to allow zero value for constraints (e.g. simplify planar faces)
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 2000 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.178 2003/09/05 14:44:29 jra Exp $ (ARL)";
@


1.178
log
@Reversed order of BOT arguments to "bot_smooth" to agree with other BOT commands
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.177 2003/09/03 00:23:36 jra Exp $ (ARL)";
d9601 6
d9610 6
d9619 6
a9637 12
	}

	if( max_chord_error <= SMALL_FASTF &&
	    max_normal_error <= SMALL_FASTF &&
	    min_edge_length <= SMALL_FASTF ) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_bot_decimate %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
@


1.178.4.1
log
@updates from HEAD, part 1
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.179 2003/11/19 21:45:04 jra Exp $ (ARL)";
a9600 6
				if( max_chord_error < 0.0 ) {
					Tcl_AppendResult(interp,
							 "Maximum chord error cannot be less than zero",
							 (char *)NULL );
					return TCL_ERROR;
				}
a9603 6
				if( max_normal_error < 0.0 ) {
					Tcl_AppendResult(interp,
							 "Maximum normal error cannot be less than zero",
							 (char *)NULL );
					return TCL_ERROR;
				}
a9606 6
				if( min_edge_length < 0.0 ) {
					Tcl_AppendResult(interp,
							 "minumum edge length cannot be less than zero",
							 (char *)NULL );
					return TCL_ERROR;
				}
d9620 12
@


1.178.4.2
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.181 2004/02/03 21:53:01 jra Exp $ (ARL)";
d2793 49
a2841 5
struct concat_data {
	int unique_mode;
	struct db_i *old_dbip;
	struct db_i *new_dbip;
	struct bu_vls prestr;
d2844 348
a3193 1
#define OLD_PREFIX 3
d3201 1
a3201 1
	     struct concat_data *cc_data )
d3218 8
a3225 15
	if( cc_data->unique_mode != OLD_PREFIX ) {
		bu_vls_strcpy( &new_name, name );
		aname = bu_vls_addr( &new_name );
		while(  db_lookup( dbip, aname, LOOKUP_QUIET ) != DIR_NULL ||
			Tcl_FindHashEntry( used_names_tbl, aname ) != NULL ) {
			bu_vls_trunc( &new_name, 0 );
			num++;
			if( cc_data->unique_mode == ADD_PREFIX ) {
				bu_vls_printf( &new_name, "%d_", num);
			}
			bu_vls_strcat( &new_name, name );
			if( cc_data->unique_mode == ADD_SUFFIX ) {
				bu_vls_printf( &new_name, "_%d", num );
			}
			aname = bu_vls_addr( &new_name );
a3226 2
	} else {
		bu_vls_vlscat( &new_name, &cc_data->prestr );
d3228 2
a3229 2
		if( cc_data->old_dbip->dbi_version < 5 ) {
			bu_vls_trunc( &new_name, RT_NAMESIZE );
d3231 1
d3250 1
a3250 1
	     struct concat_data *cc_data )
d3257 1
a3257 1
						 name_tbl, used_names_tbl, cc_data );
d3268 1
a3268 1
				      name_tbl, used_names_tbl, cc_data );
d3270 1
a3270 1
				      name_tbl, used_names_tbl, cc_data );
d3276 1
a3276 1
				      name_tbl, used_names_tbl, cc_data );
d3289 1
a3289 1
	struct concat_data *cc_data )
d3310 1
a3310 1
				adjust_names( interp, comb->tree, curr_dbip, name_tbl, used_names_tbl, cc_data );
d3316 1
a3316 1
				new_name = get_new_name( extr->sketch_name, curr_dbip, name_tbl, used_names_tbl, cc_data );
d3329 1
a3329 1
								 name_tbl, used_names_tbl, cc_data );
d3339 1
a3339 1
	new_name = get_new_name(input_dp->d_namep, curr_dbip, name_tbl, used_names_tbl , cc_data );
d3367 3
a3369 7
	int			file_index;
	struct directory	*dp;
	Tcl_HashTable		name_tbl;
	Tcl_HashTable		used_names_tbl;
	Tcl_HashEntry		*ptr;
	Tcl_HashSearch		search;
	struct concat_data	cc_data;
a3382 2
	bu_vls_init( &cc_data.prestr );

d3384 5
a3388 2

		file_index = 2;
d3391 1
a3391 1
			cc_data.unique_mode = ADD_PREFIX;
d3393 1
a3393 1
			cc_data.unique_mode = ADD_SUFFIX;
d3403 32
a3435 2
		file_index = 1;
		cc_data.unique_mode = OLD_PREFIX;
d3437 1
d3439 1
a3439 1
			(void)bu_vls_strcpy(&cc_data.prestr, argv[2]);
d3443 3
a3445 2
			if ( bu_vls_strlen(&cc_data.prestr) > 12) {
				bu_vls_trunc( &cc_data.prestr, 12 );
d3447 2
a3449 1
	}
d3451 7
a3457 7
	/* open the input file */
	if ((newdbp = db_open(argv[file_index], "r")) == DBI_NULL) {
		perror(argv[file_index]);
		Tcl_AppendResult(interp, "concat: Can't open ",
				 argv[file_index], (char *)NULL);
		return TCL_ERROR;
	}
d3459 8
a3466 6
	if( newdbp->dbi_version > 4 && wdbp->dbip->dbi_version < 5 ) {
		Tcl_AppendResult(interp, "concat: databases are incompatible, convert ",
				 wdbp->dbip->dbi_filename, " to version 5 first",
				 (char *)NULL );
		return TCL_ERROR;
	}
d3468 17
a3484 1
	db_dirbuild( newdbp );
d3486 2
a3487 11
	cc_data.new_dbip = newdbp;
	cc_data.old_dbip = wdbp->dbip;

	/* visit each directory pointer in the input database */
	Tcl_InitHashTable( &name_tbl, TCL_STRING_KEYS );
	Tcl_InitHashTable( &used_names_tbl, TCL_STRING_KEYS );
	FOR_ALL_DIRECTORY_START( dp, newdbp )
		if( dp->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY ) {
			/* skip GLOBAL object */
			continue;
		}
d3489 1
a3489 17
	        copy_object( interp, dp, newdbp, wdbp->dbip, &name_tbl,
				     &used_names_tbl, &cc_data );
	FOR_ALL_DIRECTORY_END;

	bu_vls_free( &cc_data.prestr );
	rt_mempurge(&(newdbp->dbi_freep));

	/* Free all the directory entries, and close the input database */
	db_close(newdbp);

	db_sync(wdbp->dbip);	/* force changes to disk */

	/* Free the Hash tables */
	ptr = Tcl_FirstHashEntry( &name_tbl, &search );
	while( ptr ) {
		bu_free( (char *)Tcl_GetHashValue( ptr ), "new name" );
		ptr = Tcl_NextHashEntry( &search );
a3490 2
	Tcl_DeleteHashTable( &name_tbl );
	Tcl_DeleteHashTable( &used_names_tbl );
@


1.178.4.3
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.178.4.2 2004/02/12 18:37:48 erikg Exp $ (ARL)";
@


1.177
log
@Added "facetize" command
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.176 2003/04/02 15:10:30 jra Exp $ (ARL)";
d8253 1
a8253 1
	if( argc < 2 ) {
d8290 2
a8291 7
	old_bot_name = argv[arg_index++];

	if( arg_index < argc ) {
		new_bot_name = argv[arg_index];
	} else {
		new_bot_name = old_bot_name;
	}
@


1.176
log
@Added a cast to quiet the compiler
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.175 2003/04/01 19:16:18 jra Exp $ (ARL)";
d214 1
d286 1
d4237 270
d4549 13
@


1.175
log
@Added a const to quiet the compiler
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.174 2003/02/24 19:17:52 jra Exp $ (ARL)";
d453 1
a453 1
	(void)Tcl_CreateCommand(interp, oname, wdb_cmd,
@


1.174
log
@Fixed a minor bug in "xpush". If an object was referenced twice with the same transformation,
xpush would make a new object for both ocurences, but only use one. The fix eliminates the
excess objects.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.173 2003/01/31 13:38:22 jra Exp $ (ARL)";
d6986 1
a6986 1
					char *result;
@


1.173
log
@Added wdb_smooth_bot_cmd() and supporting routines
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.172 2002/12/11 21:36:19 jra Exp $ (ARL)";
d5650 1
a5650 3
Free_uses(struct db_i		*dbip,
	  struct directory	*dp,
	  genptr_t		ptr)
d5652 5
a5656 1
	struct object_use *use;
d5658 3
a5660 1
	RT_CK_DIR(dp);
d5662 13
a5674 7
	while (BU_LIST_NON_EMPTY(&dp->d_use_hd)) {
		use = BU_LIST_FIRST(object_use, &dp->d_use_hd);
		if (!use->used) {
			/* never used, so delete directory entry.
			 * This could actually delete the original, buts that's O.K.
			 */
			db_dirdelete(dbip, use->dp);
d5676 1
a5677 3
		BU_LIST_DEQUEUE(&use->l);
		bu_free((genptr_t)use, "Free_uses: use");
	}
d6121 1
a6121 1
		db_functree(wdbp->dbip, old_dp, Free_uses, Free_uses, &rt_uniresource, NULL);
d6127 1
a6127 1
		db_functree(wdbp->dbip, old_dp, Free_uses, Free_uses, &rt_uniresource, NULL);
d6138 1
a6138 1
		db_functree(wdbp->dbip, old_dp, Free_uses, Free_uses, &rt_uniresource, NULL);
d6143 1
a6143 2
	db_functree(wdbp->dbip, old_dp, Free_uses, Free_uses, &rt_uniresource, NULL);

@


1.172
log
@Mod to wdb_repoen_cmd(). It was calling db_dirbuild() after calling wdb_prep_dbip().
wdb_prep_dbip() already calls db_dirbuild()
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.171 2002/12/11 18:49:30 jra Exp $ (ARL)";
d243 1
d318 1
d7936 134
@


1.171
log
@Mod to wdb_node_write() so that the "keep" command will keep binary objects referenced
by DSP primitives.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.170 2002/12/09 20:37:11 jra Exp $ (ARL)";
a698 3

		/* --- Scan geometry database and build in-memory directory --- */
		db_dirbuild(wdbp->dbip);
@


1.170
log
@the "keep" command now keeps sketches referenced by kept extrusions
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.169 2002/12/03 20:01:27 jra Exp $ (ARL)";
d6244 14
@


1.169
log
@wdb_dir_add() was calling Tcl_AppendResult() without a final (char *)NULL
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.168 2002/08/20 17:08:11 jra Exp $ (ARL)";
d6233 13
@


1.168
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.166 2002/07/16 02:15:13 jra Exp $ (ARL)";
d3115 1
a3115 1
				 local, "'\nYou should have used the 'dup' command to detect this,\nand then specified a prefix for the 'dbconcat' command.\n");
@


1.168.4.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/wdb_obj.c,v 1.181 2004/02/03 21:53:01 jra Exp $ (ARL)";
a213 1
static int wdb_facetize_tcl();
a242 1
static int wdb_smooth_bot_tcl();
a283 1
	{"facetize",	wdb_facetize_tcl},
a316 1
	{"smooth_bot",	wdb_smooth_bot_tcl},
d451 1
a451 1
	(void)Tcl_CreateCommand(interp, oname, (Tcl_CmdProc *)wdb_cmd,
d700 3
d2792 49
a2840 5
struct concat_data {
	int unique_mode;
	struct db_i *old_dbip;
	struct db_i *new_dbip;
	struct bu_vls prestr;
d2843 348
a3192 1
#define OLD_PREFIX 3
d3200 1
a3200 1
	     struct concat_data *cc_data )
d3217 8
a3224 15
	if( cc_data->unique_mode != OLD_PREFIX ) {
		bu_vls_strcpy( &new_name, name );
		aname = bu_vls_addr( &new_name );
		while(  db_lookup( dbip, aname, LOOKUP_QUIET ) != DIR_NULL ||
			Tcl_FindHashEntry( used_names_tbl, aname ) != NULL ) {
			bu_vls_trunc( &new_name, 0 );
			num++;
			if( cc_data->unique_mode == ADD_PREFIX ) {
				bu_vls_printf( &new_name, "%d_", num);
			}
			bu_vls_strcat( &new_name, name );
			if( cc_data->unique_mode == ADD_SUFFIX ) {
				bu_vls_printf( &new_name, "_%d", num );
			}
			aname = bu_vls_addr( &new_name );
a3225 2
	} else {
		bu_vls_vlscat( &new_name, &cc_data->prestr );
d3227 2
a3228 2
		if( cc_data->old_dbip->dbi_version < 5 ) {
			bu_vls_trunc( &new_name, RT_NAMESIZE );
d3230 1
d3249 1
a3249 1
	     struct concat_data *cc_data )
d3256 1
a3256 1
						 name_tbl, used_names_tbl, cc_data );
d3267 1
a3267 1
				      name_tbl, used_names_tbl, cc_data );
d3269 1
a3269 1
				      name_tbl, used_names_tbl, cc_data );
d3275 1
a3275 1
				      name_tbl, used_names_tbl, cc_data );
d3288 1
a3288 1
	struct concat_data *cc_data )
d3309 1
a3309 1
				adjust_names( interp, comb->tree, curr_dbip, name_tbl, used_names_tbl, cc_data );
d3315 1
a3315 1
				new_name = get_new_name( extr->sketch_name, curr_dbip, name_tbl, used_names_tbl, cc_data );
d3328 1
a3328 1
								 name_tbl, used_names_tbl, cc_data );
d3338 1
a3338 1
	new_name = get_new_name(input_dp->d_namep, curr_dbip, name_tbl, used_names_tbl , cc_data );
d3366 3
a3368 7
	int			file_index;
	struct directory	*dp;
	Tcl_HashTable		name_tbl;
	Tcl_HashTable		used_names_tbl;
	Tcl_HashEntry		*ptr;
	Tcl_HashSearch		search;
	struct concat_data	cc_data;
a3381 2
	bu_vls_init( &cc_data.prestr );

d3383 5
a3387 2

		file_index = 2;
d3390 1
a3390 1
			cc_data.unique_mode = ADD_PREFIX;
d3392 1
a3392 1
			cc_data.unique_mode = ADD_SUFFIX;
d3402 32
a3434 2
		file_index = 1;
		cc_data.unique_mode = OLD_PREFIX;
d3436 1
d3438 1
a3438 1
			(void)bu_vls_strcpy(&cc_data.prestr, argv[2]);
d3442 3
a3444 2
			if ( bu_vls_strlen(&cc_data.prestr) > 12) {
				bu_vls_trunc( &cc_data.prestr, 12 );
d3446 2
a3448 1
	}
d3450 7
a3456 7
	/* open the input file */
	if ((newdbp = db_open(argv[file_index], "r")) == DBI_NULL) {
		perror(argv[file_index]);
		Tcl_AppendResult(interp, "concat: Can't open ",
				 argv[file_index], (char *)NULL);
		return TCL_ERROR;
	}
d3458 8
a3465 6
	if( newdbp->dbi_version > 4 && wdbp->dbip->dbi_version < 5 ) {
		Tcl_AppendResult(interp, "concat: databases are incompatible, convert ",
				 wdbp->dbip->dbi_filename, " to version 5 first",
				 (char *)NULL );
		return TCL_ERROR;
	}
d3467 15
a3481 12
	db_dirbuild( newdbp );

	cc_data.new_dbip = newdbp;
	cc_data.old_dbip = wdbp->dbip;

	/* visit each directory pointer in the input database */
	Tcl_InitHashTable( &name_tbl, TCL_STRING_KEYS );
	Tcl_InitHashTable( &used_names_tbl, TCL_STRING_KEYS );
	FOR_ALL_DIRECTORY_START( dp, newdbp )
		if( dp->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY ) {
			/* skip GLOBAL object */
			continue;
d3483 1
d3485 2
a3486 6
	        copy_object( interp, dp, newdbp, wdbp->dbip, &name_tbl,
				     &used_names_tbl, &cc_data );
	FOR_ALL_DIRECTORY_END;

	bu_vls_free( &cc_data.prestr );
	rt_mempurge(&(newdbp->dbi_freep));
d3488 1
a3488 10
	/* Free all the directory entries, and close the input database */
	db_close(newdbp);

	db_sync(wdbp->dbip);	/* force changes to disk */

	/* Free the Hash tables */
	ptr = Tcl_FirstHashEntry( &name_tbl, &search );
	while( ptr ) {
		bu_free( (char *)Tcl_GetHashValue( ptr ), "new name" );
		ptr = Tcl_NextHashEntry( &search );
a3489 2
	Tcl_DeleteHashTable( &name_tbl );
	Tcl_DeleteHashTable( &used_names_tbl );
a4235 270
HIDDEN union tree *
facetize_region_end( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
{
	struct bu_list		vhead;
	union tree		**facetize_tree;

	facetize_tree = (union tree **)client_data;
	BU_LIST_INIT( &vhead );

	if( curtree->tr_op == OP_NOP )  return  curtree;

	if( *facetize_tree )  {
		union tree	*tr;
		tr = (union tree *)bu_calloc(1, sizeof(union tree), "union tree");
		tr->magic = RT_TREE_MAGIC;
		tr->tr_op = OP_UNION;
		tr->tr_b.tb_regionp = REGION_NULL;
		tr->tr_b.tb_left = *facetize_tree;
		tr->tr_b.tb_right = curtree;
		*facetize_tree = tr;
	} else {
		*facetize_tree = curtree;
	}

	/* Tree has been saved, and will be freed later */
	return( TREE_NULL );
}

int
wdb_facetize_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	int			i;
	register int		c;
	int			triangulate;
	char			*newname;
	struct rt_db_internal	intern;
	struct directory	*dp;
	int			failed;
	int			nmg_use_tnurbs = 0;
	int			make_bot;
	struct db_tree_state	init_state;
	struct db_i		*dbip;
	union tree		*facetize_tree;
	struct model		*nmg_model;

	if(argc < 3){
		Tcl_AppendResult(interp,
				 "Usage: ",
				 argv[0],
				 " new_object old_object [old_object2 old_object3 ...]\n",
				 (char *)NULL );
	  return TCL_ERROR;
	}

	dbip = wdbp->dbip;
	RT_CHECK_DBI(dbip);

	db_init_db_tree_state( &init_state, dbip, wdbp->wdb_resp );

	/* Establish tolerances */
	init_state.ts_ttol = &wdbp->wdb_ttol;
	init_state.ts_tol = &wdbp->wdb_tol;

	/* Initial vaues for options, must be reset each time */
	triangulate = 0;
	make_bot = 1;

	/* Parse options. */
	bu_optind = 1;		/* re-init bu_getopt() */
	while( (c=bu_getopt(argc,argv,"ntT")) != EOF )  {
		switch(c)  {
		case 'n':
			make_bot = 0;
			break;
		case 'T':
			triangulate = 1;
			break;
		case 't':
			nmg_use_tnurbs = 1;
			break;
		default:
		  {
		    struct bu_vls tmp_vls;

		    bu_vls_init(&tmp_vls);
		    bu_vls_printf(&tmp_vls, "option '%c' unknown\n", c);
		    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls),
				     "Usage: facetize [-ntT] object(s)\n",
				     "\t-n make NMG primitives rather than BOT's\n",
				     "\t-t Perform CSG-to-tNURBS conversion\n",
				     "\t-T enable triangulator\n", (char *)NULL);
		    bu_vls_free(&tmp_vls);
		  }
		  break;
		}
	}
	argc -= bu_optind;
	argv += bu_optind;
	if( argc < 0 ){
	  Tcl_AppendResult(interp, "facetize: missing argument\n", (char *)NULL);
	  return TCL_ERROR;
	}

	newname = argv[0];
	argv++;
	argc--;
	if( argc < 0 ){
	  Tcl_AppendResult(interp, "facetize: missing argument\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( db_lookup( dbip, newname, LOOKUP_QUIET ) != DIR_NULL )  {
	  Tcl_AppendResult(interp, "error: solid '", newname,
			   "' already exists, aborting\n", (char *)NULL);
	  return TCL_ERROR;
	}

	{
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls,
			"facetize:  tessellating primitives with tolerances a=%g, r=%g, n=%g\n",
			wdbp->wdb_ttol.abs, wdbp->wdb_ttol.rel, wdbp->wdb_ttol.norm );
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
	facetize_tree = (union tree *)0;
  	nmg_model = nmg_mm();
	init_state.ts_m = &nmg_model;

	i = db_walk_tree( dbip, argc, (const char **)argv,
		1,
		&init_state,
		0,			/* take all regions */
		facetize_region_end,
  		nmg_use_tnurbs ?
  			nmg_booltree_leaf_tnurb :
			nmg_booltree_leaf_tess,
		(genptr_t)&facetize_tree
		);


	if( i < 0 )  {
	  Tcl_AppendResult(interp, "facetize: error in db_walk_tree()\n", (char *)NULL);
	  /* Destroy NMG */
	  nmg_km( nmg_model );
	  return TCL_ERROR;
	}

	if( facetize_tree )
	{
		/* Now, evaluate the boolean tree into ONE region */
		Tcl_AppendResult(interp, "facetize:  evaluating boolean expressions\n", (char *)NULL);

		if( BU_SETJUMP )
		{
			BU_UNSETJUMP;
			Tcl_AppendResult(interp, "WARNING: facetization failed!!!\n", (char *)NULL );
			if( facetize_tree )
				db_free_tree( facetize_tree, &rt_uniresource );
			facetize_tree = (union tree *)NULL;
			nmg_km( nmg_model );
			nmg_model = (struct model *)NULL;
			return TCL_ERROR;
		}

		failed = nmg_boolean( facetize_tree, nmg_model, &wdbp->wdb_tol, &rt_uniresource );
		BU_UNSETJUMP;
	}
	else
		failed = 1;

	if( failed )  {
	  Tcl_AppendResult(interp, "facetize:  no resulting region, aborting\n", (char *)NULL);
	  if( facetize_tree )
		db_free_tree( facetize_tree, &rt_uniresource );
	  facetize_tree = (union tree *)NULL;
	  nmg_km( nmg_model );
	  nmg_model = (struct model *)NULL;
	  return TCL_ERROR;
	}
	/* New region remains part of this nmg "model" */
	NMG_CK_REGION( facetize_tree->tr_d.td_r );
	Tcl_AppendResult(interp, "facetize:  ", facetize_tree->tr_d.td_name,
			 "\n", (char *)NULL);

	/* Triangulate model, if requested */
	if( triangulate && !make_bot )
	{
		Tcl_AppendResult(interp, "facetize:  triangulating resulting object\n", (char *)NULL);
		if( BU_SETJUMP )
		{
			BU_UNSETJUMP;
			Tcl_AppendResult(interp, "WARNING: triangulation failed!!!\n", (char *)NULL );
			if( facetize_tree )
				db_free_tree( facetize_tree, &rt_uniresource );
			facetize_tree = (union tree *)NULL;
			nmg_km( nmg_model );
			nmg_model = (struct model *)NULL;
			return TCL_ERROR;
		}
		nmg_triangulate_model( nmg_model , &wdbp->wdb_tol );
		BU_UNSETJUMP;
	}

	if( make_bot )
	{
		struct rt_bot_internal *bot;
		struct nmgregion *r;
		struct shell *s;

		Tcl_AppendResult(interp, "facetize:  converting to BOT format\n", (char *)NULL);

		r = BU_LIST_FIRST( nmgregion, &nmg_model->r_hd );
		s = BU_LIST_FIRST( shell, &r->s_hd );
		bot = (struct rt_bot_internal *)nmg_bot( s, &wdbp->wdb_tol );
		nmg_km( nmg_model );
		nmg_model = (struct model *)NULL;

		/* Export BOT as a new solid */
		RT_INIT_DB_INTERNAL(&intern);
		intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		intern.idb_type = ID_BOT;
		intern.idb_meth = &rt_functab[ID_BOT];
		intern.idb_ptr = (genptr_t) bot;
	}
	else
	{

		Tcl_AppendResult(interp, "facetize:  converting NMG to database format\n", (char *)NULL);

		/* Export NMG as a new solid */
		RT_INIT_DB_INTERNAL(&intern);
		intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		intern.idb_type = ID_NMG;
		intern.idb_meth = &rt_functab[ID_NMG];
		intern.idb_ptr = (genptr_t)nmg_model;
		nmg_model = (struct model *)NULL;
	}

	if( (dp=db_diradd( dbip, newname, -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", newname, " to directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		Tcl_AppendResult(interp, "Failed to write ", newname, " to database\n", (char *)NULL );
		rt_db_free_internal( &intern, &rt_uniresource );
		return TCL_ERROR;
	}
	
	facetize_tree->tr_d.td_r = (struct nmgregion *)NULL;

	/* Free boolean tree, and the regions in it */
	db_free_tree( facetize_tree, &rt_uniresource );
    	facetize_tree = (union tree *)NULL;

	return TCL_OK;
}

a4278 13
static int
wdb_facetize_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_facetize_cmd(wdbp, interp, argc-1, argv+1);
}


d5651 3
a5653 1
Free_uses( struct db_i *dbip )
d5655 1
a5655 1
	int i;
d5657 1
a5657 3
	for (i=0 ; i<RT_DBNHASH ; i++) {
		struct directory *dp;
		struct object_use *use;
d5659 8
a5666 3
		for (dp=dbip->dbi_Head[i]; dp!=DIR_NULL; dp=dp->d_forw) {
			if (!(dp->d_flags & (DIR_SOLID | DIR_COMB)))
				continue;
d5668 2
a5669 14
			while (BU_LIST_NON_EMPTY(&dp->d_use_hd)) {
				use = BU_LIST_FIRST(object_use, &dp->d_use_hd);
				if( !use->used ) {
					if( use->dp->d_un.file_offset >= 0 ) {
						/* was written to disk */
						db_delete( dbip, use->dp );
					}
					db_dirdelete(dbip, use->dp);
				}
				BU_LIST_DEQUEUE(&use->l);
				bu_free((genptr_t)use, "Free_uses: use");
			}
			
		}
a5670 1

d6114 1
a6114 1
		Free_uses( wdbp->dbip );
d6120 1
a6120 1
		Free_uses( wdbp->dbip );
d6131 1
a6131 1
		Free_uses( wdbp->dbip );
d6136 2
a6137 1
	Free_uses( wdbp->dbip );
a6233 27
	/* if this is an extrusion, keep the referenced sketch */
	if( dp->d_major_type == DB5_MAJORTYPE_BRLCAD && dp->d_minor_type == DB5_MINORTYPE_BRLCAD_EXTRUDE ) {
		struct rt_extrude_internal *extr;
		struct directory *dp2;

		extr = (struct rt_extrude_internal *)intern.idb_ptr;
		RT_EXTRUDE_CK_MAGIC( extr );

		if( (dp2 = db_lookup( dbip, extr->sketch_name, LOOKUP_QUIET )) != DIR_NULL ) {
			wdb_node_write( dbip, dp2, ptr );
		}
	} else if ( dp->d_major_type == DB5_MAJORTYPE_BRLCAD && dp->d_minor_type == DB5_MINORTYPE_BRLCAD_DSP ) {
		struct rt_dsp_internal *dsp;
		struct directory *dp2;

		/* this is a DSP, if it uses a binary object, keep it also */
		dsp = (struct rt_dsp_internal *)intern.idb_ptr;
		RT_DSP_CK_MAGIC( dsp );

		if( dsp->dsp_datasrc == RT_DSP_SRC_OBJ ) {
			/* need to keep this object */
			if( (dp2 = db_lookup( dbip, bu_vls_addr(&dsp->dsp_name),  LOOKUP_QUIET )) != DIR_NULL ) {
				wdb_node_write( dbip, dp2, ptr );	
			}
		}
	}

d6953 1
a6953 1
					const char *result;
a7912 129
wdb_smooth_bot_cmd(struct rt_wdb	*wdbp,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	char *new_bot_name, *old_bot_name;
	struct directory *dp_old, *dp_new;
	struct rt_bot_internal *old_bot;
	struct rt_db_internal intern;
	fastf_t tolerance_angle=180.0;
	int arg_index=1;
	int id;

	/* check that we are using a version 5 database */
	if( wdbp->dbip->dbi_version < 5 ) {
		Tcl_AppendResult(interp, "This is an older database version.\n",
			"It does not support BOT surface normals.\n",
			"Use \"dbupgrade\" to upgrade this database to the current version.\n",
			(char *)NULL );
		return TCL_ERROR;
	}

	if( argc < 3 ) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_smooth_bot %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	while( *argv[arg_index] == '-' ) {
		/* this is an option */
		if( !strcmp( argv[arg_index], "-t" ) ) {
			arg_index++;
			tolerance_angle = atof( argv[arg_index] );
		} else {
			struct bu_vls vls;

			bu_vls_init(&vls);
			bu_vls_printf(&vls, "helplib_alias wdb_smooth_bot %s", argv[0]);
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}
		arg_index++;
	}

	if( arg_index >= argc ) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_smooth_bot %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	new_bot_name = argv[arg_index++];
	old_bot_name = argv[arg_index];

	if( (dp_old=db_lookup( wdbp->dbip, old_bot_name, LOOKUP_QUIET ) ) == DIR_NULL ) {
		Tcl_AppendResult(interp, old_bot_name, " does not exist!!\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( strcmp( old_bot_name, new_bot_name ) ) {

		if( (dp_new=db_lookup( wdbp->dbip, new_bot_name, LOOKUP_QUIET ) ) != DIR_NULL ) {
			Tcl_AppendResult(interp, new_bot_name, " already exists!!\n", (char *)NULL );
			return TCL_ERROR;
		}
	} else {
		dp_new = dp_old;
	}

	if( (id=rt_db_get_internal( &intern, dp_old, wdbp->dbip, NULL, wdbp->wdb_resp ) ) < 0 ) {
		Tcl_AppendResult(interp, "Failed to get internal form of ", old_bot_name, "\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( id != ID_BOT ) {
		Tcl_AppendResult(interp, old_bot_name, " is not a BOT primitive\n", (char *)NULL );
		rt_db_free_internal( &intern, wdbp->wdb_resp );
		return TCL_ERROR;
	}

	old_bot = (struct rt_bot_internal *)intern.idb_ptr;
	RT_BOT_CK_MAGIC( old_bot );

	if( rt_smooth_bot( old_bot, old_bot_name, wdbp->dbip, tolerance_angle*M_PI/180.0 ) ) {
		Tcl_AppendResult(interp, "Failed to smooth ", old_bot_name, "\n", (char *)NULL );
		rt_db_free_internal( &intern, wdbp->wdb_resp );
		return TCL_ERROR;
	}

	if( dp_new == DIR_NULL ) {
		if( (dp_new=db_diradd( wdbp->dbip, new_bot_name, -1L, 0, DIR_SOLID,
				   (genptr_t)&intern.idb_type)) == DIR_NULL ) {
			rt_db_free_internal(&intern, wdbp->wdb_resp);
			Tcl_AppendResult(interp, "Cannot add ", new_bot_name, " to directory\n", (char *)NULL);
			return TCL_ERROR;
		}
	}

	if( rt_db_put_internal( dp_new, wdbp->dbip, &intern, wdbp->wdb_resp ) < 0 ) {
		rt_db_free_internal(&intern, wdbp->wdb_resp);
		Tcl_AppendResult(interp, "Database write error, aborting.\n", (char *)NULL);
		return TCL_ERROR;
	}

	rt_db_free_internal( &intern, wdbp->wdb_resp );

	return TCL_OK;
}

static int
wdb_smooth_bot_tcl(ClientData	clientData,
		 Tcl_Interp	*interp,
		 int		argc,
		 char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_smooth_bot_cmd(wdbp, interp, argc-1, argv+1);
}

int
a9153 6
				if( max_chord_error < 0.0 ) {
					Tcl_AppendResult(interp,
							 "Maximum chord error cannot be less than zero",
							 (char *)NULL );
					return TCL_ERROR;
				}
a9156 6
				if( max_normal_error < 0.0 ) {
					Tcl_AppendResult(interp,
							 "Maximum normal error cannot be less than zero",
							 (char *)NULL );
					return TCL_ERROR;
				}
a9159 6
				if( min_edge_length < 0.0 ) {
					Tcl_AppendResult(interp,
							 "minumum edge length cannot be less than zero",
							 (char *)NULL );
					return TCL_ERROR;
				}
d9173 12
@


1.168.2.1
log
@Initial ANSIfication
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.168 2002/08/20 17:08:11 jra Exp $ (ARL)";
d159 3
a161 3
extern int rt_tcl_rt(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv);
extern int rt_tcl_import_from_path(Tcl_Interp *interp, struct rt_db_internal *ip, const char *path, struct rt_wdb *wdb);
extern void rt_generic_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter);
d164 1
a164 1
extern int wdb_comb_std_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d171 1
a171 1
HIDDEN int db5_scan(struct db_i *dbip, void (*handler) (struct db_i *, const struct db5_raw_internal *, long int, genptr_t), genptr_t client_data);
d173 4
a176 4
int wdb_init_obj(Tcl_Interp *interp, struct rt_wdb *wdbp, char *oname);
int wdb_get_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int wdb_attr_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int wdb_pathsum_cmd(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv);
d178 1
a178 1
static int wdb_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d182 2
a183 2
static int wdb_decode_dbip(Tcl_Interp *interp, char *dbip_string, struct db_i **dbipp);
static struct db_i *wdb_prep_dbip(Tcl_Interp *interp, char *filename);
d185 78
a262 78
static int wdb_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_match_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_put_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_adjust_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_form_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_tops_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_rt_gettrees_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_shells_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_dump_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_dbip_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_ls_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_list_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_pathsum_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_expand_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_kill_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_killall_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_killtree_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static void wdb_killtree_callback(struct db_i *dbip, register struct directory *dp, genptr_t *ptr);
static int wdb_copy_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_move_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_move_all_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_concat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_copyeval_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_dup_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_group_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_remove_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_region_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_comb_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_find_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_which_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_title_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_tree_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_color_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_prcolor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_tol_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_push_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_whatid_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_keep_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_cat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_instance_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_reopen_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_make_bb_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_make_name_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_units_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_hide_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_unhide_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_xpush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_showmats_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_nmg_collapse_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_nmg_simplify_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_summary_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_pathlist_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_lt_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_version_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_binary_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_bot_face_sort_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_bot_decimate_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

static void wdb_deleteProc(ClientData clientData);
static void wdb_deleteProc_rt(ClientData clientData);

static void wdb_do_trace(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t user_ptr1, genptr_t user_ptr2, genptr_t user_ptr3);
static void wdb_trace(register struct directory *dp, int pathpos, const fastf_t *old_xlate, struct wdb_trace_data *wtdp);

int wdb_cmpdirname(const genptr_t a, const genptr_t b);
void wdb_vls_col_item(struct bu_vls *str, register char *cp, int *ccp, int *clp);
void wdb_vls_col_eol(struct bu_vls *str, int *ccp, int *clp);
void wdb_vls_col_pr4v(struct bu_vls *vls, struct directory **list_of_names, int num_in_list, int no_decorate);
void wdb_vls_long_dpp(struct bu_vls *vls, struct directory **list_of_names, int num_in_list, int aflag, int cflag, int rflag, int sflag);
void wdb_vls_line_dpp(struct bu_vls *vls, struct directory **list_of_names, int num_in_list, int aflag, int cflag, int rflag, int sflag);
void wdb_do_list(struct db_i *dbip, Tcl_Interp *interp, struct bu_vls *outstrp, register struct directory *dp, int verbose);
struct directory ** wdb_getspace(struct db_i *dbip, register int num_entries);
struct directory *wdb_combadd(Tcl_Interp *interp, struct db_i *dbip, register struct directory *objp, char *combname, int region_flag, int relation, int ident, int air, struct rt_wdb *wdbp);
void wdb_identitize(struct directory *dp, struct db_i *dbip, Tcl_Interp *interp);
static void wdb_dir_summary(struct db_i *dbip, Tcl_Interp *interp, int flag);
static struct directory ** wdb_dir_getspace(struct db_i *dbip, register int num_entries);
static union tree *wdb_pathlist_leaf_func(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data);
d347 2
a348 1
Wdb_Init(Tcl_Interp *interp)
d366 5
a370 1
wdb_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d379 2
a380 1
wdb_deleteProc(ClientData clientData)
d565 4
a568 1
wdb_decode_dbip(Tcl_Interp *interp, char *dbip_string, struct db_i **dbipp)
d583 3
a585 1
wdb_prep_dbip(Tcl_Interp *interp, char *filename)
d1892 5
a1896 1
wdb_list_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2253 5
a2257 1
wdb_expand_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2781 5
a2785 1
wdb_move_all_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3722 7
a3728 1
wdb_dir_check(register struct db_i *input_dbip, register const char *name, long int laddr, int len, int flags, genptr_t ptr)
d3863 5
a3867 1
wdb_dup_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3996 5
a4000 1
wdb_remove_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4105 5
a4109 1
wdb_region_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4202 5
a4206 1
wdb_comb_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4284 5
a4288 1
wdb_find_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4480 5
a4484 1
wdb_which_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4872 5
a4876 1
wdb_tree_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d5119 5
a5123 1
wdb_prcolor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d5844 1
a5844 1
static struct directory *Copy_object(struct db_i *dbip, struct directory *dp, fastf_t *xform, Tcl_Interp *interp, struct rt_wdb *wdbp);
@


1.168.2.2
log
@removed an offending section from which[id|air] routine that skipped regions that have both air and regionid set while verbosely complaining
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.168.2.1 2002/09/19 18:01:48 morrison Exp $ (ARL)";
a4271 1
	
d4372 6
@


1.168.2.3
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
a263 1

a283 1
	{"facetize",	wdb_facetize_tcl},
a316 1
	{"smooth_bot",	wdb_smooth_bot_tcl},
d445 1
a445 1
	(void)Tcl_CreateCommand(interp, oname, (Tcl_CmdProc *)wdb_cmd,
d689 3
d2769 49
a2817 5
struct concat_data {
	int unique_mode;
	struct db_i *old_dbip;
	struct db_i *new_dbip;
	struct bu_vls prestr;
d2820 348
a3169 1
#define OLD_PREFIX 3
d3177 1
a3177 1
	     struct concat_data *cc_data )
d3194 8
a3201 15
	if( cc_data->unique_mode != OLD_PREFIX ) {
		bu_vls_strcpy( &new_name, name );
		aname = bu_vls_addr( &new_name );
		while(  db_lookup( dbip, aname, LOOKUP_QUIET ) != DIR_NULL ||
			Tcl_FindHashEntry( used_names_tbl, aname ) != NULL ) {
			bu_vls_trunc( &new_name, 0 );
			num++;
			if( cc_data->unique_mode == ADD_PREFIX ) {
				bu_vls_printf( &new_name, "%d_", num);
			}
			bu_vls_strcat( &new_name, name );
			if( cc_data->unique_mode == ADD_SUFFIX ) {
				bu_vls_printf( &new_name, "_%d", num );
			}
			aname = bu_vls_addr( &new_name );
a3202 2
	} else {
		bu_vls_vlscat( &new_name, &cc_data->prestr );
d3204 2
a3205 2
		if( cc_data->old_dbip->dbi_version < 5 ) {
			bu_vls_trunc( &new_name, RT_NAMESIZE );
d3207 1
d3226 1
a3226 1
	     struct concat_data *cc_data )
d3233 1
a3233 1
						 name_tbl, used_names_tbl, cc_data );
d3244 1
a3244 1
				      name_tbl, used_names_tbl, cc_data );
d3246 1
a3246 1
				      name_tbl, used_names_tbl, cc_data );
d3252 1
a3252 1
				      name_tbl, used_names_tbl, cc_data );
d3265 1
a3265 1
	struct concat_data *cc_data )
d3286 1
a3286 1
				adjust_names( interp, comb->tree, curr_dbip, name_tbl, used_names_tbl, cc_data );
d3292 1
a3292 1
				new_name = get_new_name( extr->sketch_name, curr_dbip, name_tbl, used_names_tbl, cc_data );
d3305 1
a3305 1
								 name_tbl, used_names_tbl, cc_data );
d3315 1
a3315 1
	new_name = get_new_name(input_dp->d_namep, curr_dbip, name_tbl, used_names_tbl , cc_data );
d3343 3
a3345 7
	int			file_index;
	struct directory	*dp;
	Tcl_HashTable		name_tbl;
	Tcl_HashTable		used_names_tbl;
	Tcl_HashEntry		*ptr;
	Tcl_HashSearch		search;
	struct concat_data	cc_data;
a3358 2
	bu_vls_init( &cc_data.prestr );

d3360 5
a3364 2

		file_index = 2;
d3367 1
a3367 1
			cc_data.unique_mode = ADD_PREFIX;
d3369 1
a3369 1
			cc_data.unique_mode = ADD_SUFFIX;
d3379 32
a3411 2
		file_index = 1;
		cc_data.unique_mode = OLD_PREFIX;
d3413 1
d3415 1
a3415 1
			(void)bu_vls_strcpy(&cc_data.prestr, argv[2]);
d3419 3
a3421 2
			if ( bu_vls_strlen(&cc_data.prestr) > 12) {
				bu_vls_trunc( &cc_data.prestr, 12 );
d3423 2
a3425 1
	}
d3427 7
a3433 7
	/* open the input file */
	if ((newdbp = db_open(argv[file_index], "r")) == DBI_NULL) {
		perror(argv[file_index]);
		Tcl_AppendResult(interp, "concat: Can't open ",
				 argv[file_index], (char *)NULL);
		return TCL_ERROR;
	}
d3435 8
a3442 6
	if( newdbp->dbi_version > 4 && wdbp->dbip->dbi_version < 5 ) {
		Tcl_AppendResult(interp, "concat: databases are incompatible, convert ",
				 wdbp->dbip->dbi_filename, " to version 5 first",
				 (char *)NULL );
		return TCL_ERROR;
	}
d3444 15
a3458 12
	db_dirbuild( newdbp );

	cc_data.new_dbip = newdbp;
	cc_data.old_dbip = wdbp->dbip;

	/* visit each directory pointer in the input database */
	Tcl_InitHashTable( &name_tbl, TCL_STRING_KEYS );
	Tcl_InitHashTable( &used_names_tbl, TCL_STRING_KEYS );
	FOR_ALL_DIRECTORY_START( dp, newdbp )
		if( dp->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY ) {
			/* skip GLOBAL object */
			continue;
d3460 1
d3462 2
a3463 11
	        copy_object( interp, dp, newdbp, wdbp->dbip, &name_tbl,
				     &used_names_tbl, &cc_data );
	FOR_ALL_DIRECTORY_END;

	bu_vls_free( &cc_data.prestr );
	rt_mempurge(&(newdbp->dbi_freep));

	/* Free all the directory entries, and close the input database */
	db_close(newdbp);

	db_sync(wdbp->dbip);	/* force changes to disk */
d3465 1
a3465 5
	/* Free the Hash tables */
	ptr = Tcl_FirstHashEntry( &name_tbl, &search );
	while( ptr ) {
		bu_free( (char *)Tcl_GetHashValue( ptr ), "new name" );
		ptr = Tcl_NextHashEntry( &search );
a3466 2
	Tcl_DeleteHashTable( &name_tbl );
	Tcl_DeleteHashTable( &used_names_tbl );
a4190 270
HIDDEN union tree *
facetize_region_end( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
{
	struct bu_list		vhead;
	union tree		**facetize_tree;

	facetize_tree = (union tree **)client_data;
	BU_LIST_INIT( &vhead );

	if( curtree->tr_op == OP_NOP )  return  curtree;

	if( *facetize_tree )  {
		union tree	*tr;
		tr = (union tree *)bu_calloc(1, sizeof(union tree), "union tree");
		tr->magic = RT_TREE_MAGIC;
		tr->tr_op = OP_UNION;
		tr->tr_b.tb_regionp = REGION_NULL;
		tr->tr_b.tb_left = *facetize_tree;
		tr->tr_b.tb_right = curtree;
		*facetize_tree = tr;
	} else {
		*facetize_tree = curtree;
	}

	/* Tree has been saved, and will be freed later */
	return( TREE_NULL );
}

int
wdb_facetize_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	int			i;
	register int		c;
	int			triangulate;
	char			*newname;
	struct rt_db_internal	intern;
	struct directory	*dp;
	int			failed;
	int			nmg_use_tnurbs = 0;
	int			make_bot;
	struct db_tree_state	init_state;
	struct db_i		*dbip;
	union tree		*facetize_tree;
	struct model		*nmg_model;

	if(argc < 3){
		Tcl_AppendResult(interp,
				 "Usage: ",
				 argv[0],
				 " new_object old_object [old_object2 old_object3 ...]\n",
				 (char *)NULL );
	  return TCL_ERROR;
	}

	dbip = wdbp->dbip;
	RT_CHECK_DBI(dbip);

	db_init_db_tree_state( &init_state, dbip, wdbp->wdb_resp );

	/* Establish tolerances */
	init_state.ts_ttol = &wdbp->wdb_ttol;
	init_state.ts_tol = &wdbp->wdb_tol;

	/* Initial vaues for options, must be reset each time */
	triangulate = 0;
	make_bot = 1;

	/* Parse options. */
	bu_optind = 1;		/* re-init bu_getopt() */
	while( (c=bu_getopt(argc,argv,"ntT")) != EOF )  {
		switch(c)  {
		case 'n':
			make_bot = 0;
			break;
		case 'T':
			triangulate = 1;
			break;
		case 't':
			nmg_use_tnurbs = 1;
			break;
		default:
		  {
		    struct bu_vls tmp_vls;

		    bu_vls_init(&tmp_vls);
		    bu_vls_printf(&tmp_vls, "option '%c' unknown\n", c);
		    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls),
				     "Usage: facetize [-ntT] object(s)\n",
				     "\t-n make NMG primitives rather than BOT's\n",
				     "\t-t Perform CSG-to-tNURBS conversion\n",
				     "\t-T enable triangulator\n", (char *)NULL);
		    bu_vls_free(&tmp_vls);
		  }
		  break;
		}
	}
	argc -= bu_optind;
	argv += bu_optind;
	if( argc < 0 ){
	  Tcl_AppendResult(interp, "facetize: missing argument\n", (char *)NULL);
	  return TCL_ERROR;
	}

	newname = argv[0];
	argv++;
	argc--;
	if( argc < 0 ){
	  Tcl_AppendResult(interp, "facetize: missing argument\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( db_lookup( dbip, newname, LOOKUP_QUIET ) != DIR_NULL )  {
	  Tcl_AppendResult(interp, "error: solid '", newname,
			   "' already exists, aborting\n", (char *)NULL);
	  return TCL_ERROR;
	}

	{
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls,
			"facetize:  tessellating primitives with tolerances a=%g, r=%g, n=%g\n",
			wdbp->wdb_ttol.abs, wdbp->wdb_ttol.rel, wdbp->wdb_ttol.norm );
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
	facetize_tree = (union tree *)0;
  	nmg_model = nmg_mm();
	init_state.ts_m = &nmg_model;

	i = db_walk_tree( dbip, argc, (const char **)argv,
		1,
		&init_state,
		0,			/* take all regions */
		facetize_region_end,
  		nmg_use_tnurbs ?
  			nmg_booltree_leaf_tnurb :
			nmg_booltree_leaf_tess,
		(genptr_t)&facetize_tree
		);


	if( i < 0 )  {
	  Tcl_AppendResult(interp, "facetize: error in db_walk_tree()\n", (char *)NULL);
	  /* Destroy NMG */
	  nmg_km( nmg_model );
	  return TCL_ERROR;
	}

	if( facetize_tree )
	{
		/* Now, evaluate the boolean tree into ONE region */
		Tcl_AppendResult(interp, "facetize:  evaluating boolean expressions\n", (char *)NULL);

		if( BU_SETJUMP )
		{
			BU_UNSETJUMP;
			Tcl_AppendResult(interp, "WARNING: facetization failed!!!\n", (char *)NULL );
			if( facetize_tree )
				db_free_tree( facetize_tree, &rt_uniresource );
			facetize_tree = (union tree *)NULL;
			nmg_km( nmg_model );
			nmg_model = (struct model *)NULL;
			return TCL_ERROR;
		}

		failed = nmg_boolean( facetize_tree, nmg_model, &wdbp->wdb_tol, &rt_uniresource );
		BU_UNSETJUMP;
	}
	else
		failed = 1;

	if( failed )  {
	  Tcl_AppendResult(interp, "facetize:  no resulting region, aborting\n", (char *)NULL);
	  if( facetize_tree )
		db_free_tree( facetize_tree, &rt_uniresource );
	  facetize_tree = (union tree *)NULL;
	  nmg_km( nmg_model );
	  nmg_model = (struct model *)NULL;
	  return TCL_ERROR;
	}
	/* New region remains part of this nmg "model" */
	NMG_CK_REGION( facetize_tree->tr_d.td_r );
	Tcl_AppendResult(interp, "facetize:  ", facetize_tree->tr_d.td_name,
			 "\n", (char *)NULL);

	/* Triangulate model, if requested */
	if( triangulate && !make_bot )
	{
		Tcl_AppendResult(interp, "facetize:  triangulating resulting object\n", (char *)NULL);
		if( BU_SETJUMP )
		{
			BU_UNSETJUMP;
			Tcl_AppendResult(interp, "WARNING: triangulation failed!!!\n", (char *)NULL );
			if( facetize_tree )
				db_free_tree( facetize_tree, &rt_uniresource );
			facetize_tree = (union tree *)NULL;
			nmg_km( nmg_model );
			nmg_model = (struct model *)NULL;
			return TCL_ERROR;
		}
		nmg_triangulate_model( nmg_model , &wdbp->wdb_tol );
		BU_UNSETJUMP;
	}

	if( make_bot )
	{
		struct rt_bot_internal *bot;
		struct nmgregion *r;
		struct shell *s;

		Tcl_AppendResult(interp, "facetize:  converting to BOT format\n", (char *)NULL);

		r = BU_LIST_FIRST( nmgregion, &nmg_model->r_hd );
		s = BU_LIST_FIRST( shell, &r->s_hd );
		bot = (struct rt_bot_internal *)nmg_bot( s, &wdbp->wdb_tol );
		nmg_km( nmg_model );
		nmg_model = (struct model *)NULL;

		/* Export BOT as a new solid */
		RT_INIT_DB_INTERNAL(&intern);
		intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		intern.idb_type = ID_BOT;
		intern.idb_meth = &rt_functab[ID_BOT];
		intern.idb_ptr = (genptr_t) bot;
	}
	else
	{

		Tcl_AppendResult(interp, "facetize:  converting NMG to database format\n", (char *)NULL);

		/* Export NMG as a new solid */
		RT_INIT_DB_INTERNAL(&intern);
		intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		intern.idb_type = ID_NMG;
		intern.idb_meth = &rt_functab[ID_NMG];
		intern.idb_ptr = (genptr_t)nmg_model;
		nmg_model = (struct model *)NULL;
	}

	if( (dp=db_diradd( dbip, newname, -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", newname, " to directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		Tcl_AppendResult(interp, "Failed to write ", newname, " to database\n", (char *)NULL );
		rt_db_free_internal( &intern, &rt_uniresource );
		return TCL_ERROR;
	}
	
	facetize_tree->tr_d.td_r = (struct nmgregion *)NULL;

	/* Free boolean tree, and the regions in it */
	db_free_tree( facetize_tree, &rt_uniresource );
    	facetize_tree = (union tree *)NULL;

	return TCL_OK;
}

a4233 13
static int
wdb_facetize_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_facetize_cmd(wdbp, interp, argc-1, argv+1);
}


d5585 3
a5587 1
Free_uses( struct db_i *dbip )
d5589 1
a5589 1
	int i;
d5591 1
a5591 3
	for (i=0 ; i<RT_DBNHASH ; i++) {
		struct directory *dp;
		struct object_use *use;
d5593 8
a5600 3
		for (dp=dbip->dbi_Head[i]; dp!=DIR_NULL; dp=dp->d_forw) {
			if (!(dp->d_flags & (DIR_SOLID | DIR_COMB)))
				continue;
d5602 2
a5603 14
			while (BU_LIST_NON_EMPTY(&dp->d_use_hd)) {
				use = BU_LIST_FIRST(object_use, &dp->d_use_hd);
				if( !use->used ) {
					if( use->dp->d_un.file_offset >= 0 ) {
						/* was written to disk */
						db_delete( dbip, use->dp );
					}
					db_dirdelete(dbip, use->dp);
				}
				BU_LIST_DEQUEUE(&use->l);
				bu_free((genptr_t)use, "Free_uses: use");
			}
			
		}
a5604 1

d6048 1
a6048 1
		Free_uses( wdbp->dbip );
d6054 1
a6054 1
		Free_uses( wdbp->dbip );
d6065 1
a6065 1
		Free_uses( wdbp->dbip );
d6070 2
a6071 1
	Free_uses( wdbp->dbip );
a6167 27
	/* if this is an extrusion, keep the referenced sketch */
	if( dp->d_major_type == DB5_MAJORTYPE_BRLCAD && dp->d_minor_type == DB5_MINORTYPE_BRLCAD_EXTRUDE ) {
		struct rt_extrude_internal *extr;
		struct directory *dp2;

		extr = (struct rt_extrude_internal *)intern.idb_ptr;
		RT_EXTRUDE_CK_MAGIC( extr );

		if( (dp2 = db_lookup( dbip, extr->sketch_name, LOOKUP_QUIET )) != DIR_NULL ) {
			wdb_node_write( dbip, dp2, ptr );
		}
	} else if ( dp->d_major_type == DB5_MAJORTYPE_BRLCAD && dp->d_minor_type == DB5_MINORTYPE_BRLCAD_DSP ) {
		struct rt_dsp_internal *dsp;
		struct directory *dp2;

		/* this is a DSP, if it uses a binary object, keep it also */
		dsp = (struct rt_dsp_internal *)intern.idb_ptr;
		RT_DSP_CK_MAGIC( dsp );

		if( dsp->dsp_datasrc == RT_DSP_SRC_OBJ ) {
			/* need to keep this object */
			if( (dp2 = db_lookup( dbip, bu_vls_addr(&dsp->dsp_name),  LOOKUP_QUIET )) != DIR_NULL ) {
				wdb_node_write( dbip, dp2, ptr );	
			}
		}
	}

d6887 1
a6887 1
					const char *result;
a7846 129
wdb_smooth_bot_cmd(struct rt_wdb	*wdbp,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	char *new_bot_name, *old_bot_name;
	struct directory *dp_old, *dp_new;
	struct rt_bot_internal *old_bot;
	struct rt_db_internal intern;
	fastf_t tolerance_angle=180.0;
	int arg_index=1;
	int id;

	/* check that we are using a version 5 database */
	if( wdbp->dbip->dbi_version < 5 ) {
		Tcl_AppendResult(interp, "This is an older database version.\n",
			"It does not support BOT surface normals.\n",
			"Use \"dbupgrade\" to upgrade this database to the current version.\n",
			(char *)NULL );
		return TCL_ERROR;
	}

	if( argc < 3 ) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_smooth_bot %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	while( *argv[arg_index] == '-' ) {
		/* this is an option */
		if( !strcmp( argv[arg_index], "-t" ) ) {
			arg_index++;
			tolerance_angle = atof( argv[arg_index] );
		} else {
			struct bu_vls vls;

			bu_vls_init(&vls);
			bu_vls_printf(&vls, "helplib_alias wdb_smooth_bot %s", argv[0]);
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}
		arg_index++;
	}

	if( arg_index >= argc ) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_smooth_bot %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	new_bot_name = argv[arg_index++];
	old_bot_name = argv[arg_index];

	if( (dp_old=db_lookup( wdbp->dbip, old_bot_name, LOOKUP_QUIET ) ) == DIR_NULL ) {
		Tcl_AppendResult(interp, old_bot_name, " does not exist!!\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( strcmp( old_bot_name, new_bot_name ) ) {

		if( (dp_new=db_lookup( wdbp->dbip, new_bot_name, LOOKUP_QUIET ) ) != DIR_NULL ) {
			Tcl_AppendResult(interp, new_bot_name, " already exists!!\n", (char *)NULL );
			return TCL_ERROR;
		}
	} else {
		dp_new = dp_old;
	}

	if( (id=rt_db_get_internal( &intern, dp_old, wdbp->dbip, NULL, wdbp->wdb_resp ) ) < 0 ) {
		Tcl_AppendResult(interp, "Failed to get internal form of ", old_bot_name, "\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( id != ID_BOT ) {
		Tcl_AppendResult(interp, old_bot_name, " is not a BOT primitive\n", (char *)NULL );
		rt_db_free_internal( &intern, wdbp->wdb_resp );
		return TCL_ERROR;
	}

	old_bot = (struct rt_bot_internal *)intern.idb_ptr;
	RT_BOT_CK_MAGIC( old_bot );

	if( rt_smooth_bot( old_bot, old_bot_name, wdbp->dbip, tolerance_angle*M_PI/180.0 ) ) {
		Tcl_AppendResult(interp, "Failed to smooth ", old_bot_name, "\n", (char *)NULL );
		rt_db_free_internal( &intern, wdbp->wdb_resp );
		return TCL_ERROR;
	}

	if( dp_new == DIR_NULL ) {
		if( (dp_new=db_diradd( wdbp->dbip, new_bot_name, -1L, 0, DIR_SOLID,
				   (genptr_t)&intern.idb_type)) == DIR_NULL ) {
			rt_db_free_internal(&intern, wdbp->wdb_resp);
			Tcl_AppendResult(interp, "Cannot add ", new_bot_name, " to directory\n", (char *)NULL);
			return TCL_ERROR;
		}
	}

	if( rt_db_put_internal( dp_new, wdbp->dbip, &intern, wdbp->wdb_resp ) < 0 ) {
		rt_db_free_internal(&intern, wdbp->wdb_resp);
		Tcl_AppendResult(interp, "Database write error, aborting.\n", (char *)NULL);
		return TCL_ERROR;
	}

	rt_db_free_internal( &intern, wdbp->wdb_resp );

	return TCL_OK;
}

static int
wdb_smooth_bot_tcl(ClientData	clientData,
		 Tcl_Interp	*interp,
		 int		argc,
		 char		**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_smooth_bot_cmd(wdbp, interp, argc-1, argv+1);
}

int
a9087 6
				if( max_chord_error < 0.0 ) {
					Tcl_AppendResult(interp,
							 "Maximum chord error cannot be less than zero",
							 (char *)NULL );
					return TCL_ERROR;
				}
a9090 6
				if( max_normal_error < 0.0 ) {
					Tcl_AppendResult(interp,
							 "Maximum normal error cannot be less than zero",
							 (char *)NULL );
					return TCL_ERROR;
				}
a9093 6
				if( min_edge_length < 0.0 ) {
					Tcl_AppendResult(interp,
							 "minumum edge length cannot be less than zero",
							 (char *)NULL );
					return TCL_ERROR;
				}
d9107 12
@


1.168.2.4
log
@function prototypes mysteriously missing
@
text
@a212 1
static int wdb_facetize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
a232 1
static int wdb_smooth_bot_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d4101 5
a4105 1
wdb_facetize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


1.167
log
@Converted from K&R to ANSI C - RFH
@
text
@d159 3
a161 3
extern int rt_tcl_rt(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv);
extern int rt_tcl_import_from_path(Tcl_Interp *interp, struct rt_db_internal *ip, const char *path, struct rt_wdb *wdb);
extern void rt_generic_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter);
d164 1
a164 1
extern int wdb_comb_std_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d171 1
a171 1
HIDDEN int db5_scan(struct db_i *dbip, void (*handler) (struct db_i *, const struct db5_raw_internal *, long int, genptr_t), genptr_t client_data);
d173 4
a176 4
int wdb_init_obj(Tcl_Interp *interp, struct rt_wdb *wdbp, char *oname);
int wdb_get_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int wdb_attr_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int wdb_pathsum_cmd(struct rt_wdb *wdbp, Tcl_Interp *interp, int argc, char **argv);
d178 1
a178 1
static int wdb_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d182 2
a183 2
static int wdb_decode_dbip(Tcl_Interp *interp, char *dbip_string, struct db_i **dbipp);
static struct db_i *wdb_prep_dbip(Tcl_Interp *interp, char *filename);
d185 78
a262 78
static int wdb_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_match_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_put_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_adjust_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_form_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_tops_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_rt_gettrees_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_shells_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_dump_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_dbip_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_ls_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_list_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_pathsum_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_expand_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_kill_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_killall_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_killtree_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static void wdb_killtree_callback(struct db_i *dbip, register struct directory *dp, genptr_t *ptr);
static int wdb_copy_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_move_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_move_all_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_concat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_copyeval_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_dup_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_group_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_remove_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_region_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_comb_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_find_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_which_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_title_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_tree_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_color_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_prcolor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_tol_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_push_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_whatid_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_keep_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_cat_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_instance_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_reopen_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_make_bb_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_make_name_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_units_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_hide_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_unhide_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_xpush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_showmats_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_nmg_collapse_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_nmg_simplify_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_summary_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_pathlist_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_lt_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_version_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_binary_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_bot_face_sort_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int wdb_bot_decimate_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

static void wdb_deleteProc(ClientData clientData);
static void wdb_deleteProc_rt(ClientData clientData);

static void wdb_do_trace(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t user_ptr1, genptr_t user_ptr2, genptr_t user_ptr3);
static void wdb_trace(register struct directory *dp, int pathpos, const fastf_t *old_xlate, struct wdb_trace_data *wtdp);

int wdb_cmpdirname(const genptr_t a, const genptr_t b);
void wdb_vls_col_item(struct bu_vls *str, register char *cp, int *ccp, int *clp);
void wdb_vls_col_eol(struct bu_vls *str, int *ccp, int *clp);
void wdb_vls_col_pr4v(struct bu_vls *vls, struct directory **list_of_names, int num_in_list, int no_decorate);
void wdb_vls_long_dpp(struct bu_vls *vls, struct directory **list_of_names, int num_in_list, int aflag, int cflag, int rflag, int sflag);
void wdb_vls_line_dpp(struct bu_vls *vls, struct directory **list_of_names, int num_in_list, int aflag, int cflag, int rflag, int sflag);
void wdb_do_list(struct db_i *dbip, Tcl_Interp *interp, struct bu_vls *outstrp, register struct directory *dp, int verbose);
struct directory ** wdb_getspace(struct db_i *dbip, register int num_entries);
struct directory *wdb_combadd(Tcl_Interp *interp, struct db_i *dbip, register struct directory *objp, char *combname, int region_flag, int relation, int ident, int air, struct rt_wdb *wdbp);
void wdb_identitize(struct directory *dp, struct db_i *dbip, Tcl_Interp *interp);
static void wdb_dir_summary(struct db_i *dbip, Tcl_Interp *interp, int flag);
static struct directory ** wdb_dir_getspace(struct db_i *dbip, register int num_entries);
static union tree *wdb_pathlist_leaf_func(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data);
d347 2
a348 1
Wdb_Init(Tcl_Interp *interp)
d366 5
a370 1
wdb_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d379 2
a380 1
wdb_deleteProc(ClientData clientData)
d565 4
a568 1
wdb_decode_dbip(Tcl_Interp *interp, char *dbip_string, struct db_i **dbipp)
d583 3
a585 1
wdb_prep_dbip(Tcl_Interp *interp, char *filename)
d1892 5
a1896 1
wdb_list_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2253 5
a2257 1
wdb_expand_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2781 5
a2785 1
wdb_move_all_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3722 7
a3728 1
wdb_dir_check(register struct db_i *input_dbip, register const char *name, long int laddr, int len, int flags, genptr_t ptr)
d3863 5
a3867 1
wdb_dup_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3996 5
a4000 1
wdb_remove_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4105 5
a4109 1
wdb_region_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4202 5
a4206 1
wdb_comb_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4284 5
a4288 1
wdb_find_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4480 5
a4484 1
wdb_which_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4872 5
a4876 1
wdb_tree_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d5119 5
a5123 1
wdb_prcolor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d5844 1
a5844 1
static struct directory *Copy_object(struct db_i *dbip, struct directory *dp, fastf_t *xform, Tcl_Interp *interp, struct rt_wdb *wdbp);
@


1.166
log
@lint
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.165 2002/07/13 17:54:40 jra Exp $ (ARL)";
d159 3
a161 3
extern int rt_tcl_rt();
extern int rt_tcl_import_from_path();
extern void rt_generic_make();
d164 1
a164 1
extern int wdb_comb_std_tcl();
d171 1
a171 1
HIDDEN int db5_scan();
d173 4
a176 4
int wdb_init_obj();
int wdb_get_tcl();
int wdb_attr_tcl();
int wdb_pathsum_cmd();
d178 1
a178 1
static int wdb_open_tcl();
d182 2
a183 2
static int wdb_decode_dbip();
static struct db_i *wdb_prep_dbip();
d185 78
a262 78
static int wdb_cmd();
static int wdb_match_tcl();
static int wdb_put_tcl();
static int wdb_adjust_tcl();
static int wdb_form_tcl();
static int wdb_tops_tcl();
static int wdb_rt_gettrees_tcl();
static int wdb_shells_tcl();
static int wdb_dump_tcl();
static int wdb_dbip_tcl();
static int wdb_ls_tcl();
static int wdb_list_tcl();
static int wdb_pathsum_tcl();
static int wdb_expand_tcl();
static int wdb_kill_tcl();
static int wdb_killall_tcl();
static int wdb_killtree_tcl();
static void wdb_killtree_callback();
static int wdb_copy_tcl();
static int wdb_move_tcl();
static int wdb_move_all_tcl();
static int wdb_concat_tcl();
static int wdb_copyeval_tcl();
static int wdb_dup_tcl();
static int wdb_group_tcl();
static int wdb_remove_tcl();
static int wdb_region_tcl();
static int wdb_comb_tcl();
static int wdb_find_tcl();
static int wdb_which_tcl();
static int wdb_title_tcl();
static int wdb_tree_tcl();
static int wdb_color_tcl();
static int wdb_prcolor_tcl();
static int wdb_tol_tcl();
static int wdb_push_tcl();
static int wdb_whatid_tcl();
static int wdb_keep_tcl();
static int wdb_cat_tcl();
static int wdb_instance_tcl();
static int wdb_observer_tcl();
static int wdb_reopen_tcl();
static int wdb_make_bb_tcl();
static int wdb_make_name_tcl();
static int wdb_units_tcl();
static int wdb_hide_tcl();
static int wdb_unhide_tcl();
static int wdb_xpush_tcl();
static int wdb_showmats_tcl();
static int wdb_nmg_collapse_tcl();
static int wdb_nmg_simplify_tcl();
static int wdb_summary_tcl();
static int wdb_pathlist_tcl();
static int wdb_lt_tcl();
static int wdb_version_tcl();
static int wdb_binary_tcl();
static int wdb_bot_face_sort_tcl();
static int wdb_bot_decimate_tcl();

static void wdb_deleteProc();
static void wdb_deleteProc_rt();

static void wdb_do_trace();
static void wdb_trace();

int wdb_cmpdirname();
void wdb_vls_col_item();
void wdb_vls_col_eol();
void wdb_vls_col_pr4v();
void wdb_vls_long_dpp();
void wdb_vls_line_dpp();
void wdb_do_list();
struct directory ** wdb_getspace();
struct directory *wdb_combadd();
void wdb_identitize();
static void wdb_dir_summary();
static struct directory ** wdb_dir_getspace();
static union tree *wdb_pathlist_leaf_func();
d347 1
a347 2
Wdb_Init(interp)
     Tcl_Interp *interp;
d365 1
a365 5
wdb_cmd(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d374 1
a374 2
wdb_deleteProc(clientData)
     ClientData clientData;
d559 1
a559 4
wdb_decode_dbip(interp, dbip_string, dbipp)
     Tcl_Interp *interp;
     char *dbip_string;
     struct db_i **dbipp;
d574 1
a574 3
wdb_prep_dbip(interp, filename)
     Tcl_Interp *interp;
     char *filename;
d1881 1
a1881 5
wdb_list_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d2238 1
a2238 5
wdb_expand_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d2762 1
a2762 5
wdb_move_all_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d3699 1
a3699 7
wdb_dir_check(input_dbip, name, laddr, len, flags, ptr)
     register struct db_i	*input_dbip;
     register const char	*name;
     long			laddr;
     int			len;
     int			flags;
     genptr_t			ptr;
d3834 1
a3834 5
wdb_dup_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d3963 1
a3963 5
wdb_remove_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d4068 1
a4068 5
wdb_region_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d4161 1
a4161 5
wdb_comb_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d4239 1
a4239 5
wdb_find_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d4431 1
a4431 5
wdb_which_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d4819 1
a4819 5
wdb_tree_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d5062 1
a5062 5
wdb_prcolor_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d5783 1
a5783 1
static struct directory *Copy_object();
@


1.165
log
@Added "-s" and "-p" options to the "dbconcat" command to let the software assign
a suffix/prefix only where needed
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.164 2002/06/07 19:57:34 jra Exp $ (ARL)";
a3289 1
	int id;
d3297 1
a3297 1
	if( (id = rt_db_get_internal( &ip, input_dp, input_dbip, NULL, &rt_uniresource)) < 0 ) {
a7919 1
	unsigned int major_type=0;
a7991 1
			major_type=DB5_MAJORTYPE_BINARY_UNIF;
a8073 1
		int id;
d8102 2
a8103 2
		if( (id=rt_db_get_internal( &intern, dp, wdbp->dbip, NULL,
					 &rt_uniresource )) < 0 ) {
@


1.164
log
@Added "n" option to "tops" command (for "no decoration")
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.163 2002/06/05 21:16:57 morrison Exp $ (ARL)";
d3191 168
d3369 1
d3373 1
a3373 1
	if (argc != 3) {
d3383 39
a3421 4
	bu_vls_trunc( &wdbp->wdb_prestr, 0 );
	if (strcmp(argv[2], "/") != 0) {
		(void)bu_vls_strcpy(&wdbp->wdb_prestr, argv[2]);
	}
d3423 9
a3431 4
	if( wdbp->dbip->dbi_version < 5 ) {
		if ((wdbp->wdb_ncharadd = bu_vls_strlen(&wdbp->wdb_prestr)) > 12) {
			wdbp->wdb_ncharadd = 12;
			bu_vls_trunc( &wdbp->wdb_prestr, 12 );
d3433 2
a3435 2
		wdbp->wdb_ncharadd = bu_vls_strlen(&wdbp->wdb_prestr);
	}
d3437 13
a3449 7
	/* open the input file */
	if ((newdbp = db_open(argv[1], "r")) == DBI_NULL) {
		perror(argv[1]);
		Tcl_AppendResult(interp, "concat: Can't open ",
				 argv[1], (char *)NULL);
		return TCL_ERROR;
	}
d3451 7
a3457 8
	/* Scan new database, adding everything encountered. */
	version = db_get_version( newdbp );
	if( version > 4 && wdbp->dbip->dbi_version < 5 ) {
		Tcl_AppendResult(interp, "concat: databases are incompatible, convert ",
				 wdbp->dbip->dbi_filename, " to version 5 first",
				 (char *)NULL );
		return TCL_ERROR;
	}
d3459 7
a3465 8
	das.interp = interp;
	das.main_dbip = wdbp->dbip;
	das.wdbp = wdbp;
	if (version < 5) {
		if (db_scan(newdbp, wdb_dir_add, 1, (genptr_t)&das) < 0) {
			Tcl_AppendResult(interp, "concat: db_scan failure", (char *)NULL);
			bad = 1;	
			/* Fall through, to close off database */
d3467 16
a3482 5
	} else {
		if (db5_scan(newdbp, wdb_dir_add5, (genptr_t)&das) < 0) {
			Tcl_AppendResult(interp, "concat: db_scan failure", (char *)NULL);
			bad = 1;	
			/* Fall through, to close off database */
d3484 1
a3484 2
	}
	rt_mempurge(&(newdbp->dbi_freep));        /* didn't really build a directory */
d3486 2
a3487 2
	/* Free all the directory entries, and close the input database */
	db_close(newdbp);
d3489 2
a3490 1
	db_sync(wdbp->dbip);	/* force changes to disk */
@


1.163
log
@added check when appending the "Parts of: " string that it was not already appended.  found a database that had Parts of: Parts of: Parts of: ...
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.162 2002/05/10 13:00:32 jra Exp $ (ARL)";
d1073 1
d1080 1
a1080 1
	while ((c = bu_getopt(argc, argv, "gu")) != EOF) {
d1088 3
d1130 1
a1130 1
	wdb_vls_col_pr4v(&vls, dirp0, (int)(dirp - dirp0));
d1767 1
a1767 1
		wdb_vls_col_pr4v(&vls, dirp0, (int)(dirp - dirp0));
d3625 1
a3625 1
	wdb_vls_col_pr4v(&vls, dirp0, (int)(dcs.dup_dirp - dirp0));
d8152 2
a8153 1
		 int			num_in_list)
d8257 1
a8257 1
			if (list_of_names[this_one]->d_flags & DIR_COMB) {
d8262 1
a8262 1
			if (list_of_names[this_one]->d_flags & DIR_REGION) {
d8836 1
a8836 1
	wdb_vls_col_pr4v(&vls, dirp0, (int)(dirp - dirp0));
@


1.162
log
@"dbbinary" command no longer requires major and minor types for output
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.161 2002/05/09 19:01:03 jra Exp $ (ARL)";
d6077 3
a6079 1
	bu_vls_strcat(&title, "Parts of: ");
@


1.161
log
@Added tcl adjust abd tclget support for binary objects
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.160 2002/02/25 16:05:14 jra Exp $ (ARL)";
d7744 1
a7744 1
	if (argc != 4) {
d7753 2
a7754 1
	if (argv[0][0] == 'u') {
d7756 7
a7762 7
		if (argv[1][1] != '\0') {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "Unrecognized minor type: %s", argv[1]);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);
			return TCL_ERROR;
		}
d7764 40
a7803 33
		major_type=DB5_MAJORTYPE_BINARY_UNIF;
		switch ((int)argv[1][0]) {
		case 'f':
			minor_type = DB5_MINORTYPE_BINU_FLOAT;
			break;
		case 'd':
			minor_type = DB5_MINORTYPE_BINU_DOUBLE;
			break;
		case 'c':
			minor_type = DB5_MINORTYPE_BINU_8BITINT;
			break;
		case 's':
			minor_type = DB5_MINORTYPE_BINU_16BITINT;
			break;
		case 'i':
			minor_type = DB5_MINORTYPE_BINU_32BITINT;
			break;
		case 'l':
			minor_type = DB5_MINORTYPE_BINU_64BITINT;
			break;
		case 'C':
			minor_type = DB5_MINORTYPE_BINU_8BITINT_U;
			break;
		case 'S':
			minor_type = DB5_MINORTYPE_BINU_16BITINT_U;
			break;
		case 'I':
			minor_type = DB5_MINORTYPE_BINU_32BITINT_U;
			break;
		case 'L':
			minor_type = DB5_MINORTYPE_BINU_64BITINT_U;
			break;
		default:
d7805 1
a7805 1
			bu_vls_printf(&vls, "Unrecognized minor type: %s", argv[1]);
a7809 7
	} else {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "Unrecognized major type: %s", argv[0]);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
d7811 3
a7813 3
	/* skip past major_type and minor_type */
	argc -= 2;
	argv += 2;
a7814 1
	if( input_mode ) {
d7857 10
@


1.160
log
@Changed declaration of a variable from "char" to "int" in wdb_bot_decimate_cmd() to agree with declaration
of bu_getopt()
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.159 2002/02/25 15:23:25 jra Exp $ (ARL)";
d7701 9
@


1.159
log
@Added -A and -o options to the "ls" command
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.158 2002/02/25 13:57:22 jra Exp $ (ARL)";
d8883 1
a8883 1
	char c;
@


1.158
log
@Added minimum edge length to bot_decimate constraints
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.157 2002/02/15 19:04:13 jra Exp $ (ARL)";
d1631 4
d1648 1
a1648 1
	while ((c = bu_getopt(argc, argv, "acrslp")) != EOF) {
d1650 6
d1682 47
a1728 2
	/* create list of objects in database */
	if (argc > 1) {
@


1.157
log
@Mods to make "attr show" work for less than all the attributes
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.156 2002/02/15 18:38:45 jra Exp $ (ARL)";
d168 1
a168 1
extern int rt_bot_decimate( struct rt_bot_internal *bot, fastf_t max_chord_error, fastf_t max_normal_error );
d8828 1
d8832 3
a8834 2
	fastf_t max_chord_error;
	fastf_t max_normal_error=90.0;
d8836 1
a8836 1
	if( argc < 4 || argc > 5 ) {
d8846 46
a8891 3
	/* make sure new solid does no already exist */
	if( (dp=db_lookup( wdbp->dbip, argv[1], LOOKUP_QUIET ) ) != DIR_NULL ) {
	  Tcl_AppendResult(interp, argv[1], " already exists!!\n", (char *)NULL );
d8896 2
a8897 2
	if( (dp=db_lookup( wdbp->dbip, argv[2], LOOKUP_QUIET ) ) == DIR_NULL ) {
		Tcl_AppendResult(interp, argv[2], " Does not exist\n", (char *)NULL );
d8921 3
a8923 18
	/* convert maximum error to mm */
	max_chord_error = atof( argv[3] ) * wdbp->dbip->dbi_local2base;

	if( max_chord_error <= 0.0 ) {
		Tcl_AppendResult(interp, "maximum chord error must be greater than zero\n", (char *)NULL );
		rt_db_free_internal( &intern, wdbp->wdb_resp );
		return TCL_ERROR;
	}

	if( argc == 5 ) {
		max_normal_error = atof( argv[4] );
		if( max_normal_error < 0.0 || max_normal_error > 90.0 ) {
			Tcl_AppendResult(interp, "maximum normal error must be between 0.0 and 90.0\n",
					 (char *)NULL );
			rt_db_free_internal( &intern, wdbp->wdb_resp );
			return TCL_ERROR;
		}
	}
d8926 1
a8926 1
	if( rt_bot_decimate( bot, max_chord_error, max_normal_error) < 0 ) {
d8933 1
a8933 1
	if( wdb_put_internal( wdbp, argv[1], &intern, 1.0 ) < 0 ) {
@


1.156
log
@Added "show" subcommand to "attr" command
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.155 2002/02/05 03:11:09 jra Exp $ (ARL)";
d6841 1
a6841 1
 *	for "get", remaining args are attribute names (or none for all)
d6912 1
a6912 1
			int do_separators=argc-4;
d7052 39
a7090 2
		avpp = avs.avp;
		for( i=0 ; i < avs.count ; i++, avpp++ ) {
d7093 6
a7098 3
			len = strlen( avpp->name );
			if( len > max_attr_name_len ) {
				max_attr_name_len = len;
d7100 5
a7104 8
		}
		tabs1 = 2 + max_attr_name_len/8;
		avpp = avs.avp;
		for( i=0 ; i < avs.count ; i++, avpp++ ) {
			const char *c;
			int tabs2;
			int k;
			int len;
d7106 23
a7128 12
			bu_vls_printf( &vls, "\t%s", avpp->name );
			len = strlen( avpp->name );
			tabs2 = tabs1 - 1 - len/8;
			for( k=0 ; k<tabs2 ; k++ ) {
				bu_vls_putc( &vls, '\t' );
			}
			c = avpp->value;
			while( *c ) {
				bu_vls_putc( &vls, *c );
				if( *c == '\n' ) {
					for( k=0 ; k<tabs1 ; k++ ) {
						bu_vls_putc( &vls, '\t' );
d7130 1
d7132 1
a7132 1
				c++;
a7133 1
			bu_vls_putc( &vls, '\n' );
@


1.155
log
@Mods to "attr" command to create several subcomands
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.154 2002/01/24 14:40:40 jra Exp $ (ARL)";
d7018 71
@


1.154
log
@Fixed bug in bot_decimate (was not setting normal tolerance)
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.153 2002/01/22 19:01:44 jra Exp $ (ARL)";
a175 1
int wdb_attr_rm_tcl();
a266 1
	{"attr_rm",	wdb_attr_rm_tcl},
d6828 23
a6850 58
int wdb_attr_rm_cmd(struct rt_wdb	*wdbp,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv)
{
	int			i;
	struct directory	*dp;
	struct bu_attribute_value_set avs;

	/* this is only valid for v5 databases */
	if( wdbp->dbip->dbi_version < 5 ) {
		Tcl_AppendResult(interp, "Attributes are not available for this database format.\nPlease upgrade your database format using \"dbupgrade\" to enable attributes.", (char *)NULL );
		return TCL_ERROR;
	}

	if (argc < 2 ) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias wdb_attr_rm %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
	/* Verify that this wdb supports lookup operations
	   (non-null dbip) */
	if (wdbp->dbip == 0) {
		Tcl_AppendResult(interp,
				 "db does not support lookup operations",
				 (char *)NULL);
		return TCL_ERROR;
	}

	if( (dp=db_lookup( wdbp->dbip, argv[1], LOOKUP_NOISY)) == DIR_NULL )
		return TCL_ERROR;

	
	if( db5_get_attributes( wdbp->dbip, &avs, dp ) ) {
		Tcl_AppendResult(interp,
				 "Cannot get attributes for object ", dp->d_namep, "\n", (char *)NULL );
		return TCL_ERROR;
	}

	i = 2;
	while( i < argc ) {
		(void)bu_avs_remove( &avs, argv[i] );
		i++;
	}
	if( db5_replace_attributes( dp, &avs, wdbp->dbip ) ) {
		Tcl_AppendResult(interp, "Error: failed to update attributes\n", (char *)NULL );
		bu_avs_free( &avs );
		return TCL_ERROR;
	}

	/* avs is freed by db5_update_attributes() */
	return TCL_OK;
}

d6868 1
a6868 1
	if (argc < 2 ) {
d6887 5
a6891 1
	if( (dp=db_lookup( wdbp->dbip, argv[1], LOOKUP_NOISY)) == DIR_NULL )
d6893 1
d6902 34
a6935 15
	if( argc == 2 ) {
		/* just list all the attributes */
		avpp = avs.avp;
		for( i=0 ; i < avs.count ; i++, avpp++ ) {
			Tcl_AppendResult(interp, avpp->name, " {", avpp->value, "} ", (char *)NULL );
		}
	} else if( argc == 3 ) {
		/* just getting a single attribute */
		const char *val;

		val = bu_avs_get( &avs, argv[2] );
		if( !val ) {
			Tcl_AppendResult(interp, "Object ", dp->d_namep, " does not have a ", argv[2], " attribute\n", (char *)NULL );
			bu_avs_free( &avs );
			return TCL_ERROR;
d6937 5
a6941 2
		Tcl_AppendResult(interp, val, (char *)NULL );
	} else {
d6943 4
a6946 2
		if( argc % 2 ) {
			Tcl_AppendResult(interp, "Error: attribute names and values must be in pairs!!!\n", (char *)NULL );
d6951 1
a6951 1
		i = 2;
d6957 3
a6959 1
			Tcl_AppendResult(interp, "Error: failed to update attributes\n", (char *)NULL );
d6966 65
a7032 2
	bu_avs_free( &avs );
	return TCL_OK;
a7043 11
}

int
wdb_attr_rm_tcl(ClientData	clientData,
	     Tcl_Interp     *interp,
	     int		argc,
	     char	      **argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_attr_rm_cmd(wdbp, interp, argc-1, argv+1);
@


1.153
log
@Added bot_decimate command (and support) to MGED
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.152 2002/01/16 20:29:14 butler Exp $ (ARL)";
d8681 1
a8681 1
	  Tcl_AppendResult(interp, argv[1], "already exists!!\n", (char *)NULL );
d8720 1
a8720 1
	if( argc == 4 ) {
@


1.152
log
@Changes to combination Regular/Plate/Volume disk format in V5 databases.
Removed auto-generated "material" attribute from regions.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.151 2002/01/10 18:12:41 butler Exp $ (ARL)";
d168 1
d243 1
d271 1
d8651 108
@


1.151
log
@Changed word "solids" to indicate "prims" or primitives"
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.150 2002/01/09 19:58:19 jra Exp $ (ARL)";
d8357 1
a8357 1
		comb->region_id = -1;
d8359 1
a8359 1

d8376 2
a8378 1

@


1.150
log
@Undo previous mod (not needed)
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.149 2002/01/08 21:56:53 jra Exp $ (ARL)";
d7285 1
a7285 1
		Tcl_AppendResult(interp, argv[1], " is a combination, only NMG solids are allowed here\n", (char *)NULL );
@


1.149
log
@Corrections to handle long names
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.148 2002/01/08 20:49:00 jra Exp $ (ARL)";
d2490 5
a2494 19
	if( wdbp->dbip->dbi_version < 5 ) {
		if ((dp=db_diradd(wdbp->dbip, argv[2], -1, 0, proto->d_flags, (genptr_t)&proto->d_minor_type)) == DIR_NULL ) {
			Tcl_AppendResult(interp,
					 "An error has occured while adding a new object to the database.",
					 (char *)NULL);
			return TCL_ERROR;
		}
	} else {
		struct bu_attribute_value_set avs;

		bu_avs_init( &avs, 1, "avs" );
		if ((dp = db_diradd5(wdbp->dbip, argv[2], -1L, proto->d_major_type, proto->d_minor_type,
				     (unsigned char)'\0', 0, &avs )) == DIR_NULL)  {
			bu_avs_free( &avs );
			Tcl_AppendResult(interp, "An error has occured while adding '",
					 argv[2], "' to the database.\n", (char *)NULL);
			WDB_TCL_ALLOC_ERR_return;
		}
		bu_avs_free( &avs );
d3328 6
a3333 22
	if( wdbp->dbip->dbi_version < 5 ) {
		if ((dp=db_diradd(wdbp->dbip, argv[1], -1L, 0,
				  wtd.wtd_obj[endpos-1]->d_flags,
				  (genptr_t)&new_int.idb_type)) == DIR_NULL) {
			rt_db_free_internal(&internal, &rt_uniresource);
			rt_db_free_internal(&new_int, &rt_uniresource);
			WDB_TCL_ALLOC_ERR_return;
		}
	} else {
		struct bu_attribute_value_set avs;

		bu_avs_init( &avs, 1, "avs" );
		if ((dp = db_diradd5(wdbp->dbip, argv[1], -1L, new_int.idb_major_type, new_int.idb_type,
				     (unsigned char)'\0', 0, &avs )) == DIR_NULL)  {
			bu_avs_free( &avs );
			rt_db_free_internal(&internal, &rt_uniresource);
			rt_db_free_internal(&new_int, &rt_uniresource);
			Tcl_AppendResult(interp, "An error has occured while adding '",
					 argv[1], "' to the database.\n", (char *)NULL);
			WDB_TCL_ALLOC_ERR_return;
		}
		bu_avs_free( &avs );
d7088 3
a7090 1
		struct rt_arb_internal arb_int;
d7092 2
a7093 2
		if (nmg_to_arb(m, &arb_int)) {
			new_intern.idb_ptr = (genptr_t)(&arb_int);
d7108 2
a7109 2
				if (nmg_to_arb(m, &arb_int)) {
					new_intern.idb_ptr = (genptr_t)(&arb_int);
d7126 1
a7126 1
		struct rt_tgc_internal tgc_int;
d7128 4
a7131 2
		if (nmg_to_tgc(m, &tgc_int, &wdbp->wdb_tol)) {
			new_intern.idb_ptr = (genptr_t)(&tgc_int);
d7146 3
a7148 1
		struct rt_arb_internal arb_int;
d7157 2
a7158 2
			if (nmg_to_arb(m, &arb_int )) {
				new_intern.idb_ptr = (genptr_t)(&arb_int);
a8332 1
		struct bu_attribute_value_set avs;
d8346 4
a8349 15
		if( dbip->dbi_version < 5 ) {
			if ((dp = db_diradd(dbip, combname, -1, 0, flags, (genptr_t)&intern.idb_type)) == DIR_NULL)  {
				Tcl_AppendResult(interp, "An error has occured while adding '",
						 combname, "' to the database.\n", (char *)NULL);
				return DIR_NULL;
			}
		} else {
			bu_avs_init( &avs, 1, "avs" );
			if ((dp = db_diradd5(dbip, combname, -1, intern.idb_major_type, intern.idb_type, (unsigned char)'\0', 0, &avs )) == DIR_NULL)  {
				bu_avs_free( &avs );
				Tcl_AppendResult(interp, "An error has occured while adding '",
						 combname, "' to the database.\n", (char *)NULL);
				return DIR_NULL;
			}
			bu_avs_free( &avs );
@


1.148
log
@Moved a bu_avs_free() to inside the block where it is allocated
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.147 2002/01/08 18:00:24 jra Exp $ (ARL)";
d2490 19
a2508 5
	if ((dp=db_diradd(wdbp->dbip, argv[2], -1, 0, proto->d_flags, (genptr_t)&proto->d_minor_type)) == DIR_NULL ) {
		Tcl_AppendResult(interp,
				 "An error has occured while adding a new object to the database.",
				 (char *)NULL);
		return TCL_ERROR;
d3342 22
a3363 6
	if ((dp=db_diradd(wdbp->dbip, argv[1], -1L, 0,
			  wtd.wtd_obj[endpos-1]->d_flags,
			  (genptr_t)&new_int.idb_type)) == DIR_NULL) {
		rt_db_free_internal(&internal, &rt_uniresource);
		rt_db_free_internal(&new_int, &rt_uniresource);
		WDB_TCL_ALLOC_ERR_return;
@


1.147
log
@summary comman now references primitives, not solids
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.146 2002/01/08 17:52:02 jra Exp $ (ARL)";
d8355 1
a8356 1
		bu_avs_free( &avs );
@


1.146
log
@"summary" command now reports number of primitives rather than number of "solids"
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.145 2002/01/08 15:45:59 jra Exp $ (ARL)";
d7378 1
a7378 1
	case 's':
d7388 1
a7388 1
		Tcl_AppendResult(interp, "summary:  S R or G are only valid parmaters\n",
@


1.145
log
@wdb_combadd() was using old db_diradd() causing object name truncation. Now it checks
dbi_version and calls appropriate add function
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.144 2001/12/13 19:36:21 jra Exp $ (ARL)";
d8568 1
a8568 1
	bu_vls_printf(&vls, "  %5d solids\n", sol);
@


1.144
log
@Added bot_face_sort command
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.143 2001/12/12 18:39:11 bparker Exp $ (ARL)";
d8327 1
d8341 14
a8354 4
		if ((dp = db_diradd(dbip, combname, -1, 0, flags, (genptr_t)&intern.idb_type)) == DIR_NULL)  {
			Tcl_AppendResult(interp, "An error has occured while adding '",
					 combname, "' to the database.\n", (char *)NULL);
			return DIR_NULL;
d8356 1
@


1.143
log
@*- mods to various commands' help
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.142 2001/11/16 16:46:47 bparker Exp $ (ARL)";
d166 3
d241 1
d268 1
d7684 110
@


1.142
log
@*- modified the binary command to not acquire the
   major type as an option
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.141 2001/11/15 22:05:56 bparker Exp $ (ARL)";
d176 1
d178 1
d266 1
d268 1
d619 1
d662 1
d782 6
a787 3
		Tcl_AppendResult(interp,
				 "wrong # args: should be \"", argv[0],
				 " objName ?attr?\"", (char *)NULL);
d845 6
a850 3
		Tcl_AppendResult(interp,
				 "wrong # args: should be db put objName objType attrs",
				 (char *)NULL);
d942 6
a947 3
		Tcl_AppendResult(interp,
				 "wrong # args: should be \"db adjust objName attr value ?attr? ?value?...\"",
				 (char *)NULL);
d1022 6
a1027 2
		Tcl_AppendResult(interp, "wrong # args: should be \"db form objType\"",
				 (char *)NULL);
d1180 6
a1185 4
		Tcl_AppendResult(interp,
				 "rt_gettrees: wrong # args: should be \"",
				 argv[0],
				 " newprocname [-i] [-u] treetops...\"", (char *)NULL );
d1523 6
a1528 3
		Tcl_AppendResult(interp,
				 "dump: wrong # args: should be \"",
				 "dump filename.g", (char *)NULL);
d2115 1
a2115 1
		bu_vls_printf(&vls, "help wdb_expand");
d3243 1
a3243 1
		bu_vls_printf(&vls, "help wdb_copyeval");
d6838 6
a6843 3
		Tcl_AppendResult(interp,
				 "wrong # args: should be \"", argv[0],
				 " objName [attribute] [[attribute] [attribute]...]\"", (char *)NULL);
d6898 6
a6903 3
		Tcl_AppendResult(interp,
				 "wrong # args: should be \"", argv[0],
				 " objName [attribute] [value] [[attribute] [value]...]\"", (char *)NULL);
d7036 6
a7041 3
			Tcl_AppendResult(interp,
					 "Usage: nmg_simplify [arb|ell|tgc|poly] new_solid_name nmg_solid\n",
					 (char *)NULL);
@


1.141
log
@*- import MGED's binary command, modifying it
   to use bu_getopt instead of getopt
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.140 2001/11/14 17:50:45 bparker Exp $ (ARL)";
a7444 42
			case 'u':
				major_type=DB5_MAJORTYPE_BINARY_UNIF;
				switch( *bu_optarg ) {
				case 'f':
					minor_type = DB5_MINORTYPE_BINU_FLOAT;
					break;
				case 'd':
					minor_type = DB5_MINORTYPE_BINU_DOUBLE;
					break;
				case 'c':
					minor_type = DB5_MINORTYPE_BINU_8BITINT;
					break;
				case 's':
					minor_type = DB5_MINORTYPE_BINU_16BITINT;
					break;
				case 'i':
					minor_type = DB5_MINORTYPE_BINU_32BITINT;
					break;
				case 'l':
					minor_type = DB5_MINORTYPE_BINU_64BITINT;
					break;
				case 'C':
					minor_type = DB5_MINORTYPE_BINU_8BITINT_U;
					break;
				case 'S':
					minor_type = DB5_MINORTYPE_BINU_16BITINT_U;
					break;
				case 'I':
					minor_type = DB5_MINORTYPE_BINU_32BITINT_U;
					break;
				case 'L':
					minor_type = DB5_MINORTYPE_BINU_64BITINT_U;
					break;
				default:
					bu_vls_init( &vls );
					bu_vls_printf(&vls, "Unrecognized argument for '-u' option: %s",
						      bu_optarg);
					Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
					bu_vls_free(&vls);
					return TCL_ERROR;
				}
				break;
d7468 1
a7468 1
	if( argc < 2 ) {
d7475 62
@


1.140
log
@*- mods to wdb_tops_cmd
	- added -u and -g options
	- display output in columns
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.139 2001/11/13 22:22:49 jra Exp $ (ARL)";
d235 1
d261 1
d7414 211
@


1.139
log
@Added "-p" option to "ls", and correct binary object listing for "ls" command
using binu_types[] array
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.138 2001/11/08 22:04:01 butler Exp $ (ARL)";
d1038 8
a1045 2
	register struct directory *dp;
	register int i;
d1050 18
d1071 33
a1103 8
	
	for (i = 0; i < RT_DBNHASH; i++)
		for (dp = wdbp->dbip->dbi_Head[i];
		     dp != DIR_NULL;
		     dp = dp->d_forw)  {
			if (dp->d_nref == 0)
				Tcl_AppendElement( interp, dp->d_namep);
		}
@


1.138
log
@Changes to "Keep" to require both databases be in the same format
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.137 2001/11/02 05:04:23 butler Exp $ (ARL)";
d1563 1
a1563 1
	while ((c = bu_getopt(argc, argv, "acrsl")) != EOF) {
d1575 1
d7613 3
a7615 3
	int isComb, isRegion;
	int isSolid;
	const char *type;
d7636 1
a7636 3
		else if (dp->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY)
			len = 6;
		else
d7638 16
d7673 1
a7673 1
		} else {
d7677 22
a7698 5
		}

		if (list_of_names[i]->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY) {
			isSolid = 0;
			type = "global";
@


1.137
log
@Changed wdb_put_internal so that it would not try to make primitives where
the functab ft_make element is rt_nul_make.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.136 2001/11/01 21:38:35 bparker Exp $ (ARL)";
d5903 19
a5921 2
	if ((new_dbip = db_open(argv[1], "w")) !=  DBI_NULL  &&
	    (keepfp = wdb_dbopen(new_dbip, RT_WDB_TYPE_DB_DISK)) != NULL) {
d5927 1
d5929 7
a5935 5
		/* Create a new database */
		if ((keepfp = wdb_fopen(argv[1])) == NULL) {
			perror(argv[1]);
			return TCL_ERROR;
		}
@


1.136
log
@*- added a "struct db_i *" parameter to ft_describe
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.135 2001/10/04 20:04:21 rbowers Exp $ (ARL)";
d868 2
d871 7
a877 1
		ftp->ft_make(ftp, &intern, 0.0);
d879 1
a879 1
		rt_generic_make(ftp, &intern, 0.0);
@


1.135
log
@-* modified to remove a user-visible reference to database version 5.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.134 2001/10/04 19:36:09 rbowers Exp $ (ARL)";
d1717 1
a1717 1
			if (rt_functab[id].ft_describe(&str, &intern, 99, wdbp->dbip->dbi_base2local, &rt_uniresource) < 0)
d1882 1
a1882 1
	if (rt_functab[id].ft_describe(&str, &intern, 1, wtdp->wtd_dbip->dbi_base2local, &rt_uniresource) < 0)
d7799 1
a7799 1
					       verbose, dbip->dbi_base2local, &rt_uniresource) < 0)
@


1.134
log
@-* modified to eliminate user-visible v4 references.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.133 2001/10/02 19:24:31 jra Exp $ (ARL)";
d6729 1
a6729 1
		Tcl_AppendResult(interp, "Attributes are only available in database version 5 and later\n", (char *)NULL );
d6786 1
a6786 1
		Tcl_AppendResult(interp, "Attributes are only available in database version 5 and later\n", (char *)NULL );
@


1.133
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.132 2001/09/28 14:54:53 bparker Exp $ (ARL)";
d6512 3
a6514 2
		Tcl_AppendResult(interp, "The \"hide\" command is only valid for version 5 databases and later\n",
				 (char *)NULL );
d6654 3
a6656 2
		Tcl_AppendResult(interp, "The \"unhide\" command is only valid for version 5 databases and later\n",
				 (char *)NULL );
@


1.132
log
@*- fixed the keep command (i.e. things were broken
   when keeping from a v4 to a v5 database)
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.131 2001/09/17 18:22:29 bparker Exp $ (ARL)";
d1390 1
d6271 1
d6972 1
d6988 1
d7008 1
d7033 1
d7054 1
d7843 1
@


1.131
log
@*- bug fix in wdb_keep_cmd
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.130 2001/09/10 22:08:00 bparker Exp $ (ARL)";
d5850 2
a5851 2
	struct rt_wdb	*keepfp = (struct rt_wdb *)ptr;
	struct bu_external	ext;
d5858 1
a5858 1
	if (db_get_external(&ext, dp, dbip) < 0)
d5860 2
a5861 1
	if (wdb_export_external(keepfp, &ext, dp->d_namep, dp->d_flags, dp->d_minor_type) < 0)
@


1.130
log
@*- add a wdb version command that simply
   returns the database version
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.129 2001/09/07 17:05:59 bparker Exp $ (ARL)";
d5897 3
@


1.129
log
@*- modified wdb_color_cmd to work with
   db5 databases
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.128 2001/09/05 20:36:30 jra Exp $ (ARL)";
d234 1
d312 1
d4294 39
@


1.128
log
@Hack to get copyeval to work
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.127 2001/09/05 19:42:35 jra Exp $ (ARL)";
a4559 7
	if (wdbp->dbip->dbi_version != 4) {
		Tcl_AppendResult(interp,
				 "Database is not version 4!",
				 (char *)NULL);
		return TCL_ERROR;
	}

d4570 58
a4627 26
	/* Delete all color records from the database */
	newp = rt_material_head;
	while (newp != MATER_NULL) {
		next_mater = newp->mt_forw;
		wdb_color_zaprec(newp, interp, wdbp->dbip);
		newp = next_mater;
	}

	/* construct the new color record */
	BU_GETSTRUCT(newp, mater);
	newp->mt_low = atoi(argv[1]);
	newp->mt_high = atoi(argv[2]);
	newp->mt_r = atoi(argv[3]);
	newp->mt_g = atoi(argv[4]);
	newp->mt_b = atoi(argv[5]);
	newp->mt_daddr = MATER_NO_ADDR;		/* not in database yet */

	/* Insert new color record in the in-memory list */
	rt_insert_color(newp);

	/* Write new color records for all colors in the list */
	newp = rt_material_head;
	while (newp != MATER_NULL) {
		next_mater = newp->mt_forw;
		wdb_color_putrec(newp, interp, wdbp->dbip);
		newp = next_mater;
@


1.127
log
@Copy_comb() was not passing the wdb pointer to db_tree_funcleaf()
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.126 2001/08/31 14:38:58 jra Exp $ (ARL)";
d1837 13
a1849 4
	for (i=0; i<=pathpos; i++) {
		if (wtdp->wtd_path[i]->d_addr != wtdp->wtd_obj[i]->d_addr) {
			/* not the desired path */
			return;
@


1.126
log
@the "hide" command now asks for confirmation when hiding geometry.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.125 2001/08/29 13:43:58 jra Exp $ (ARL)";
d5479 1
a5479 1
				 (genptr_t)xform, (genptr_t)interp, (genptr_t)NULL);
@


1.125
log
@wdb_do_list() now handles the _GLOBAL object
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.124 2001/08/29 12:15:29 jra Exp $ (ARL)";
d6442 47
@


1.124
log
@the "tops" command now ignores the "hidden" flag
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.123 2001/08/28 20:20:36 jra Exp $ (ARL)";
d7619 34
a7652 5
	if ((id = rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource)) < 0) {
		Tcl_AppendResult(interp, "rt_db_get_internal(", dp->d_namep,
				 ") failure\n", (char *)NULL);
		return;
	}
d7654 6
a7659 1
	bu_vls_printf(outstrp, "%s:  ", dp->d_namep);
d7661 7
a7667 4
	if (rt_functab[id].ft_describe(outstrp, &intern,
				       verbose, dbip->dbi_base2local, &rt_uniresource) < 0)
		Tcl_AppendResult(interp, dp->d_namep, ": describe error\n", (char *)NULL);
	rt_db_free_internal(&intern, &rt_uniresource);
@


1.123
log
@reinstated the effects of the "hide" command. They seem to have disappeared.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.122 2001/08/28 17:02:03 jra Exp $ (ARL)";
d1042 1
a1042 1
			if (dp->d_nref == 0 && !(dp->d_flags & DIR_HIDDEN))
@


1.122
log
@copyeval command now works, was not checking the last solid in the path!!!
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.121 2001/08/22 15:20:59 jra Exp $ (ARL)";
d1601 3
a1603 1
			for (dp = wdbp->dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
d1605 1
@


1.121
log
@Minor modification to wdb_make_bb_cmd() to eliminate a compiler warning.
Moved a label by one line
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.120 2001/08/14 18:13:50 bparker Exp $ (ARL)";
d1834 1
a1834 1
	for (i=0; i<wtdp->wtd_objpos; i++) {
@


1.120
log
@*- change helplib to helplib_alias
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.119 2001/06/06 16:46:07 bparker Exp $ (ARL)";
d6132 1
a6133 1
found:
@


1.119
log
@*- add wdb_lt_cmd (i.e. lt command which
   returns a tcl list of {op obj} pairs)
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.118 2001/06/01 19:04:11 bparker Exp $ (ARL)";
d692 1
a692 1
	bu_vls_printf(&vls, "helplib wdb_reopen");
d1253 1
a1253 1
		bu_vls_printf(&vls, "helplib wdb_showmats");
d1342 1
a1342 1
		bu_vls_printf(&vls, "helplib wdb_shells");
d1494 1
a1494 1
		bu_vls_printf(&vls, "helplib wdb_dbip");
d1545 1
a1545 1
		bu_vls_printf(&vls, "helplib wdb_ls");
d1657 1
a1657 1
		bu_vls_printf(&vls, "helplib wdb_list");
d1887 1
a1887 1
		bu_vls_printf(&vls, "helplib %s%s", "wdb_", argv[0]);
d2117 1
a2117 1
		bu_vls_printf(&vls, "helplib wdb_kill");
d2188 1
a2188 1
		bu_vls_printf(&vls, "helplib  wdb_killall");
d2286 1
a2286 1
		bu_vls_printf(&vls, "helplib wdb_killtree");
d2367 1
a2367 1
		bu_vls_printf(&vls, "helplib wdb_copy");
d2433 1
a2433 1
		bu_vls_printf(&vls, "helplib wdb_move");
d2504 1
a2504 1
		bu_vls_printf(&vls, "helplib wdb_moveall");
d3044 1
a3044 1
		bu_vls_printf(&vls, "helplib wdb_concat");
d3396 1
a3396 1
		bu_vls_printf(&vls, "helplib wdb_dup");
d3502 1
a3502 1
		bu_vls_printf(&vls, "helplib wdb_group");
d3554 1
a3554 1
		bu_vls_printf(&vls, "helplib wdb_remove");
d3637 1
a3637 1
		bu_vls_printf(&vls, "helplib wdb_region");
d3746 1
a3746 1
		bu_vls_printf(&vls, "helplib wdb_comb");
d3864 1
a3864 1
		bu_vls_printf(&vls, "helplib wdb_find");
d3939 1
a3939 1
		bu_vls_printf(&vls, "helplib wdb_%s", argv[0]);
d3958 1
a3958 1
			bu_vls_printf(&vls, "helplib wdb_%s", argv[-1]);
d4120 1
a4120 1
		bu_vls_printf(&vls, "helplib wdb_title");
d4261 1
a4261 1
	bu_vls_printf(&vls, "helplib wdb_lt");
d4418 1
a4418 1
		bu_vls_printf(&vls, "helplib wdb_tree");
d4559 1
a4559 1
		bu_vls_printf(&vls, "helplib wdb_color");
d4646 1
a4646 1
		bu_vls_printf(&vls, "helplib wdb_prcolor");
d4690 1
a4690 1
		bu_vls_printf(&vls, "helplib wdb_tol");
d5022 1
a5022 1
		bu_vls_printf(&vls, "helplib wdb_push");
d5564 1
a5564 1
		bu_vls_printf(&vls, "helplib wdb_xpush");
d5714 1
a5714 1
		bu_vls_printf(&vls, "helplib wdb_whatid");
d5802 1
a5802 1
		bu_vls_printf(&vls, "helplib wdb_keep");
d5880 1
a5880 1
		bu_vls_printf(&vls, "helplib wdb_cat");
d5930 1
a5930 1
		bu_vls_printf(&vls, "helplib wdb_instance");
d5989 1
a5989 1
		bu_vls_printf(&vls, "helplib wdb_observer");
d6039 1
a6039 1
		bu_vls_printf(&vls, "helplib wdb_make_bb");
d6260 1
a6260 1
			bu_vls_printf(&vls, "helplib wdb_make_name");
d6325 1
a6325 1
		bu_vls_printf(&vls, "helplib wdb_units");
d6416 1
a6416 1
		bu_vls_printf(&vls, "helplib wdb_hide");
d6510 1
a6510 1
		bu_vls_printf(&vls, "helplib wdb_unhide");
d6776 1
a6776 1
		bu_vls_printf(&vls, "helplib wdb_nmg_simplify");
d7001 1
a7001 1
		bu_vls_printf(&vls, "helplib wdb_nmg_collapse");
d7109 1
a7109 1
		bu_vls_printf(&vls, "helplib wdb_summary");
d7167 1
a7167 1
		bu_vls_printf(&vls, "helplib wdb_pathlist");
@


1.118
log
@*- removed leftover variable
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.117 2001/06/01 17:34:14 bparker Exp $ (ARL)";
d233 1
d284 1
d1645 7
a1651 7
	register struct directory *dp;
	register int arg;
	struct bu_vls str;
	int id;
	int recurse = 0;
	char *listeval = "listeval";
	struct rt_db_internal intern;
d4164 118
d4338 1
a4338 1
	if (comb->tree){
@


1.117
log
@*- upgrade wdb_units_cmd from mods made in MGED's units command
*- add pathlist method
*- bug fixes and formatting
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.116 2001/05/30 14:10:30 jra Exp $ (ARL)";
a329 3
/* This could go in struct rt_wdb */
static Tcl_Interp *wdb_obj_interp;

a625 6
	 * Maybe this should go in "struct rt_wdb". For now,
	 * use a global.
	 */
	wdb_obj_interp = interp;

	/*
a6200 1
	fastf_t		sf;
a6231 2

	sf = wdbp->dbip->dbi_base2local;
@


1.116
log
@lint
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.115 2001/05/29 16:36:21 jra Exp $ (ARL)";
d50 1
a51 1
#include "rtgeom.h"
d107 8
d117 1
a117 2
	bu_log("\
An error has occured while adding a new object to the database.\n"); \
d155 3
a162 5
/* from librt/dg_obj.c */
extern void dgo_eraseobjall_callback();	/* called when killing database object's */
extern void dgo_impending_wdb_close();	/* called in wdb_deleteProc */
extern void dgo_zapall();		/* called in wdb_reopen_tcl */

d232 1
d252 1
d292 1
a316 1
	{"pathlist",	wdb_pathlist_tcl},
d375 1
a375 1
	dgo_impending_wdb_close(wdbp, wdb_obj_interp);
d431 1
d1674 2
a1675 2
		argc -= 1;
		argv += 1;
a1696 1
			bzero( (char *)&ts, sizeof( ts ) );
d1698 1
a1698 1

d1700 1
d3145 2
d3518 1
a3518 1
			if (wdb_combadd(interp, wdbp->dbip, dp, argv[2], 0,
d3529 1
a3529 1
 *        procname group groupname object(s)
d5659 1
a5659 1
	       genptr_t			client_data)
d5661 1
d5663 2
a5664 2
	struct wdb_node_data *wndp = (struct wdb_node_data *)client_data;
	
d5669 4
a5672 13
	/* Use db_get_external() and db_fwrite_external().  Faster. */
	if (db_get_external(&ext, dp, dbip) < 0) {
		Tcl_AppendResult(wndp->interp, "Input database read error on ",
				 dp->d_namep, ", aborting", (char *)NULL);
		return;
	}

	if (db_fwrite_external(wndp->fp, dp->d_namep, &ext) < 0) {
		Tcl_AppendResult(wndp->interp,
				 "Output database write error on ",
				 dp->d_namep, ", aborting", (char *)NULL);
	}
	bu_free_external(&ext);
d5681 1
a5681 1
	FILE			*keepfp;
d5685 1
a5685 1
	struct wdb_node_data	wnd;
d5704 2
a5705 1
	if ((keepfp = fopen(argv[1], "r")) != NULL) {
d5708 6
a5713 6
		fclose(keepfp);
	}

	if ((keepfp = fopen(argv[1], "a")) == NULL) {
		perror(argv[1]);
		return TCL_ERROR;
d5716 1
a5716 1
	/* All databases must start with an ident record */
d5721 1
a5721 2
	/* use same editing preference */
	if( db_fwrite_ident( keepfp, bu_vls_addr(&title), wdbp->dbip->dbi_local2base ) )  {
d5723 2
a5724 3
		Tcl_AppendResult(interp, "db_fwrite_ident(", argv[1],
			") failed\n", (char *)NULL);
		fclose(keepfp);
d5728 1
a5728 3

	wnd.fp = keepfp;
	wnd.interp = interp;
d5733 1
a5733 1
		db_functree(wdbp->dbip, dp, wdb_node_write, wdb_node_write, wdbp->wdb_resp, (genptr_t)&wnd);
d5736 1
a5736 3
	fclose(keepfp);
	bu_vls_free(&title);

d5922 2
a6207 1
	int		new_unit = 0;
d6210 1
d6243 2
d6253 6
a6258 18
	/* See if this is a known v4 database unit */
	if ((new_unit = db_v4_get_units_code(bu_units_string(loc2mm))) >= 0) {
		/* One of the recognized db.h units */
		/* change database to remember the new local unit */
		if (wdbp->dbip->dbi_read_only ||
		    db_update_ident(wdbp->dbip, wdbp->dbip->dbi_title, new_unit) < 0)
			Tcl_AppendResult(interp,
					 "Warning: unable to stash working units into database\n",
					 (char *)NULL);
	} else {
		/*
		 *  Can't stash requested units into the database for next session,
		 *  but there is no problem with the user editing in these units.
		 */
		Tcl_AppendResult(interp, "\
Due to a database restriction in the current format of .g files,\n\
this choice of units will not be remembered on your next editing session.\n", (char *)NULL);
	}
d6302 2
d6396 2
d7049 41
a7549 3
	if (dbip == DBI_NULL)
		return DIR_NULL;

d7607 1
a7607 1
			return( DIR_NULL );
d7609 4
a7612 1
		return( dp );
d7844 23
@


1.115
log
@wdb_dir_add5() now sets avsp->max to zero if there are no attributes (needed for correct freeing)
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.114 2001/05/17 20:05:26 morrison Exp $ (ARL)";
a1246 1
	mat_t acc_matrix;
a6491 1
	struct bu_attribute_value_pair	*avpp;
@


1.114
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.113 2001/05/14 01:49:19 jra Exp $ (ARL)";
d2808 1
@


1.113
log
@Added "attr_rm" command
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.112 2001/05/04 14:19:25 bparker Exp $ (ARL)";
d2708 1
a2708 1
	if(rt_g.debug&DEBUG_DB) {
d4811 1
a4811 1
	if (rt_g.debug&DEBUG_TREEWALK) {
d4916 1
a4916 1
	old_debug = rt_g.debug;
@


1.112
log
@*- import more MGED commands into librt
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.111 2001/05/02 17:11:50 bparker Exp $ (ARL)";
d167 1
d250 1
d6484 56
d6636 11
@


1.111
log
@*- import the following commands from mged:
   nmg_simplify, nmg_collapse, xpush, showmats,
   shells, copyeval
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.110 2001/04/27 19:29:51 morrison Exp $ (ARL)";
d225 1
d237 1
d243 2
a244 4

static void wdb_output_catch();
static void wdb_start_catching_output();
static void wdb_stop_catching_output();
d292 1
a309 1
	{"summary",	wdb_summary_tcl},
d1536 1
d1550 1
a1550 1
	while ((c = bu_getopt(argc, argv, "acgrs")) != EOF) {
d1564 3
d1586 1
a1586 2
			if ((dp = db_lookup(wdbp->dbip, argv[i], LOOKUP_NOISY)) ==
			    DIR_NULL)
d1603 4
a1606 1
	if (aflag || cflag || rflag || sflag)
d1614 1
a1614 1
	bu_free( (genptr_t)dirp0, "wdb_getspace dp[]" );
d4348 1
a4348 4
	if (dbip->dbi_read_only)
		return;

	BU_ASSERT_LONG( dbip->dbi_version, ==, 4 );
d4396 2
a4397 3
	BU_ASSERT_LONG( dbip->dbi_version, ==, 4 );

	if (dbip->dbi_read_only || mp->mt_daddr == MATER_NO_ADDR)
d4425 7
d6926 62
d7093 1
d7146 162
d7642 100
@


1.110
log
@missing slash
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.109 2001/04/26 22:07:32 bparker Exp $ (ARL)";
d59 41
d101 1
a101 1
	(void)printf("Database read error, aborting\n"); }
d103 1
a103 1
#define WDB_READ_ERR_return		{ \
d107 10
d118 4
a121 2
#define	WDB_TCL_ERROR_RECOVERY_SUGGESTION\
        Tcl_AppendResult(interp, "\
d124 7
a130 1
you should exit MGED now, and resolve the I/O problem, before continuing.\n", (char *)NULL)
d181 1
d196 1
d221 4
d242 4
d255 1
d279 2
d290 2
d301 1
a305 1
	{"copyeval",	wdb_copyeval_tcl},
d1190 235
d2103 1
a2103 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
d2174 1
a2174 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
d2272 1
a2272 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
d2353 1
a2353 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
d2419 1
a2419 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
d2490 1
a2490 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
d2502 1
a2502 1
	if ((int)strlen(argv[2]) > RT_NAMESIZE) {
d2506 1
a2506 1
		bu_vls_printf(&tmp_vls, "ERROR: name length limited to %d characters", RT_NAMESIZE);
d2539 1
a2539 1
	bu_ptbl_init( &stack, 64, "combination stack for f_mvall" );
d2565 1
a2565 1
					if (!strncmp(comb_leaf->tr_l.tl_name, argv[1], RT_NAMESIZE)) {
d3029 1
a3029 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
d3115 134
d3485 1
a3485 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
d3537 1
a3537 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
d3620 1
a3620 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
d3729 1
a3729 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
a4103 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
d4121 2
d4421 1
a4421 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
d4884 1
a4884 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
d5039 530
d5805 1
a5805 4
	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!", (char *)NULL);
		return TCL_ERROR;
	}
d5953 1
a5953 1
			bu_free((genptr_t)rtip, "wdb_make_bb_tcl: rtip");
d5967 1
a5967 1
				bu_free((genptr_t)rtip, "wdb_make_bb_tcl: rtip");
d5982 1
a5982 1
			bu_free((genptr_t)rtip, "wdb_make_bb_tcl: rtip");
d6018 1
a6018 1
				bu_free((genptr_t)rtip, "wdb_make_bb_tcl: rtip");
d6044 1
a6044 1
					bu_free((genptr_t)rtip, "wdb_make_bb_tcl: rtip");
d6083 1
a6083 1
	bu_free((genptr_t)rtip, "wdb_make_bb_tcl: rtip");
d6139 1
a6139 1
			bu_vls_printf(&vls, "helplib make_name");
d6569 346
@


1.109
log
@*- fixed bug in wdb_open_tcl() that caused
   db_dirbuild to be called twice
*- modified wdb_open_tcl() to accept 3 or
   4 arguments. If only 3 arguments are given,
   then type "db" is assumed. This allows the
   user/programmer to type

	   wdb_open dbobj bob.g

	      instead of

	   wdb_open dbobj db bob.g
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.108 2001/04/20 22:29:57 morrison Exp $ (ARL)";
d417 1
a417 1
       wdb_open newprocname db filename\n
@


1.108
log
@CONST to const
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.107 2001/04/20 21:34:38 bparker Exp $ (ARL)";
d402 1
a402 1
	if (argc != 4) {
d417 2
a418 1
       wdb_open newprocname db filename\n",
d427 15
a441 1
	if (strcmp(argv[2], "file") == 0) {
d446 2
a447 7
		if (strcmp(argv[2], "db") == 0) {
			if ((dbip = wdb_prep_dbip(interp, argv[3])) == DBI_NULL)
				return TCL_ERROR;
			RT_CK_DBI_TCL(interp,dbip);

			/* --- Scan geometry database and build in-memory directory --- */
			db_dirbuild(dbip);
d449 1
d451 10
a460 17
		} else {
			if (wdb_decode_dbip(interp, argv[3], &dbip) != TCL_OK)
				return TCL_ERROR;

			if (strcmp( argv[2], "disk" ) == 0)
				wdbp = wdb_dbopen(dbip, RT_WDB_TYPE_DB_DISK);
			else if (strcmp(argv[2], "disk_append") == 0)
				wdbp = wdb_dbopen(dbip, RT_WDB_TYPE_DB_DISK_APPEND_ONLY);
			else if (strcmp( argv[2], "inmem" ) == 0)
				wdbp = wdb_dbopen(dbip, RT_WDB_TYPE_DB_INMEM);
			else if (strcmp( argv[2], "inmem_append" ) == 0)
				wdbp = wdb_dbopen(dbip, RT_WDB_TYPE_DB_INMEM_APPEND_ONLY);
			else {
				Tcl_AppendResult(interp, "wdb_open ", argv[2],
						 " target type not recognized", NULL);
				return TCL_ERROR;
			}
d482 3
d507 1
d519 4
a522 1
	}
@


1.107
log
@*- mods for handling return value of db5_get_raw_internal_ptr()
   differently. Previous code tested for <0 to indicate
   a failed attempt. However, this routine never returns
   values less than 0. It returns NULL (0) for failure and >0
   for success.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.106 2001/04/20 19:53:54 bparker Exp $ (ARL)";
d738 1
a738 1
	register CONST struct rt_functab	*ftp;
d904 1
a904 1
	CONST struct rt_functab		*ftp;
d1041 1
a1041 1
	if (rt_gettrees(rtip, argc-2, (CONST char **)&argv[2], 1) < 0) {
d2360 1
a2360 1
static int wdb_dir_add BU_ARGS((struct db_i *input_dbip, CONST char
d2559 1
a2559 1
	    register CONST char		*name,
d2817 1
a2817 1
db_i *input_dbip, CONST char *name, long laddr, int len, int flags,
d2893 1
a2893 1
     register CONST char	*name;
d4524 1
a4524 1
	i = db_walk_tree(wdbp->dbip, argc, (CONST char **)argv,
d5057 1
a5057 1
		CONST char *reg_name;
d5260 1
a5260 1
	CONST char	*str;
d5584 1
a5584 1
		CONST char *val;
d5667 2
a5668 2
wdb_cmpdirname(CONST genptr_t a,
	       CONST genptr_t b)
@


1.106
log
@*- some cleanup
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.105 2001/04/20 13:36:32 bparker Exp $ (ARL)";
d5398 1
a5398 1
		if( db5_get_raw_internal_ptr( &raw, ext.ext_buf ) < 0 ) {
d5490 1
a5490 1
		if( db5_get_raw_internal_ptr( &raw, ext.ext_buf ) < 0 ) {
@


1.105
log
@*- break out tcl wrapped functionality into
   C routines that have the following signature:

	wdb_func_cmd(struct rt_wdb  *wdbp,
	             Tcl_Interp     *interp,
                     int            argc,
		     char           **argv)

   The tcl wrappers will get wdbp from their clientData
   and call wdb_func_cmd().
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.104 2001/04/15 02:19:42 jra Exp $ (ARL)";
a3230 1
#if 1
a3273 54
#else
	/*XXX
	 * This is the way MGED used to do it.
	 * However, this creates a dependency on libwdb
	 */
	/* Get operation and solid name for each solid */
	for (i = 2; i < argc; i += 2) {
		if (argv[i][1] != '\0') {
			Tcl_AppendResult(interp, "bad operation: ", argv[i],
					 " skip member: ", argv[i+1], "\n", (char *)NULL);
			continue;
		}
		oper = argv[i][0];
		if ((dp = db_lookup(wdbp->dbip,  argv[i+1], LOOKUP_NOISY )) == DIR_NULL ) {
			Tcl_AppendResult(interp, "skipping ", argv[i+1], "\n", (char *)NULL);
			continue;
		}

		if (oper != WMOP_UNION && oper != WMOP_SUBTRACT && oper != WMOP_INTERSECT) {
			struct bu_vls tmp_vls;

			bu_vls_init(&tmp_vls);
			bu_vls_printf(&tmp_vls, "bad operation: %c skip member: %s\n",
				      oper, dp->d_namep );
			Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			bu_vls_free(&tmp_vls);
			continue;
		}

		/* Adding region to region */
		if (dp->d_flags & DIR_REGION) {
			Tcl_AppendResult(interp, "Note: ", dp->d_namep,
					 " is a region\n", (char *)NULL);
		}

		mk_addmember(argv[i+1], &head, oper);
	}

	if (mk_comb(wdbp, argv[1], &head,
		    1, NULL, NULL, NULL,
		    wdbp->wdb_item_default, wdbp->wdb_air_default,
		    wdbp->wdb_mat_default, wdbp->wdb_los_default,
		    0, 1, 1) < 0) {
		/* failed to create region */
		if (wdbp->wdb_item_default > 1)
			wdbp->wdb_item_default--;

		Tcl_AppendResult(interp,
				 "An error has occured while adding '",
				 argv[1], "' to the database.\n", (char *)NULL);
		WDB_TCL_ERROR_RECOVERY_SUGGESTION;
		return TCL_ERROR;
	}
#endif
d5621 4
a5624 5
wdb_attr_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp     *interp;
     int		argc;
     char	      **argv;
@


1.104
log
@Added "db attr" command
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.103 2001/04/03 14:24:42 jra Exp $ (ARL)";
d105 5
a116 2
int wdb_get_tcl();
int wdb_attr_tcl();
d301 2
a302 4
 * Close a BRLCAD database object.
 *
 * USAGE:
 *	  procname close
d304 4
a307 6
static int
wdb_close_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d309 2
a310 8
	struct bu_vls vls;
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib wdb_close");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
d314 37
a350 5
	/*
	 * Maybe this should go in "struct rt_wdb". For now,
	 * use a global.
	 */
	wdb_obj_interp = interp;
d352 4
a355 6
	/*
	 * Among other things, this will call wdb_deleteProc.
	 * Note - wdb_deleteProc is being passed clientdata.
	 *        It ought to get interp as well.
	 */
	Tcl_DeleteCommand(interp, bu_vls_addr(&wdbp->wdb_name));
d357 3
d387 4
a390 5
wdb_open_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int		argc;
     char		**argv;
a458 47
	if (wdbp == RT_WDB_NULL) {
		Tcl_AppendResult(interp, "wdb_open ", argv[1], " failed", NULL);
		return TCL_ERROR;
	}

	/* initialize rt_wdb */
	bu_vls_init(&wdbp->wdb_name);
	bu_vls_strcpy(&wdbp->wdb_name, argv[1]);

#if 0
	/*XXXX already initialize by wdb_dbopen */
	/* initilize tolerance structures */
	wdbp->wdb_ttol.magic = RT_TESS_TOL_MAGIC;
	wdbp->wdb_ttol.abs = 0.0;		/* disabled */
	wdbp->wdb_ttol.rel = 0.01;
	wdbp->wdb_ttol.norm = 0.0;		/* disabled */

	wdbp->wdb_tol.magic = BN_TOL_MAGIC;
	wdbp->wdb_tol.dist = 0.005;
	wdbp->wdb_tol.dist_sq = wdbp->wdb_tol.dist * wdbp->wdb_tol.dist;
	wdbp->wdb_tol.perp = 1e-6;
	wdbp->wdb_tol.para = 1 - wdbp->wdb_tol.perp;
#endif

	/* initialize tree state */
	wdbp->wdb_initial_tree_state = rt_initial_tree_state;  /* struct copy */
	wdbp->wdb_initial_tree_state.ts_ttol = &wdbp->wdb_ttol;
	wdbp->wdb_initial_tree_state.ts_tol = &wdbp->wdb_tol;

	/* default region ident codes */
	wdbp->wdb_item_default = 1000;
	wdbp->wdb_air_default = 0;
	wdbp->wdb_mat_default = 1;
	wdbp->wdb_los_default = 100;

	/* resource structure */
	wdbp->wdb_resp = &rt_uniresource;

	BU_LIST_INIT(&wdbp->wdb_observers.l);

	/* append to list of rt_wdb's */
	BU_LIST_APPEND(&rt_g.rtg_headwdb.l,&wdbp->l);

	/* Instantiate the newprocname, with clientData of wdbp */
	/* Beware, returns a "token", not TCL_OK. */
	(void)Tcl_CreateCommand(interp, argv[1], wdb_cmd,
				(ClientData)wdbp, wdb_deleteProc);
d460 1
a460 4
	/* Return new function name as result */
	Tcl_AppendResult(interp, argv[1], (char *)NULL);
	
	return TCL_OK;
d517 32
d550 1
d552 2
a553 2
 * Usage:
 *        procname open [filename]
d556 4
a559 5
wdb_reopen_tcl( clientData, interp, argc, argv )
     ClientData	clientData;
     Tcl_Interp     *interp;
     int		argc;
     char	      **argv;
d562 10
d576 1
a576 1
	if (argc == 2) {
d582 2
a583 2
	if (argc == 3) {
		if ((dbip = wdb_prep_dbip(interp, argv[2])) == DBI_NULL) {
a610 1
 *			W D B _ M A T C H _ T C L
d612 2
a613 4
 * Returns (in interp->result) a list (possibly empty) of all matches to
 * the (possibly wildcard-containing) arguments given.
 * Does *NOT* return tokens that do not match anything, unlike the
 * "expand" command.
a614 1

d616 4
a619 5
wdb_match_tcl( clientData, interp, argc, argv )
     ClientData	clientData;
     Tcl_Interp     *interp;
     int		argc;
     char	      **argv;
d622 10
a633 4
	/* skip past procname */
	--argc;
	++argv;

d655 1
a655 1
 *			W D B _ G E T_ T C L
d657 16
a672 9
 **
 ** For use with Tcl, this routine accepts as its first argument the name
 ** of an object in the database.  If only one argument is given, this routine
 ** then fills the result string with the (minimal) attributes of the item.
 ** If a second, optional, argument is provided, this function looks up the
 ** property with that name of the item given, and returns it as the result
 ** string.
 **/
/* NOTE: This is called directly by gdiff/g_diff.c */
d675 4
a678 5
wdb_get_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp     *interp;
     int		argc;
     char	      **argv;
a681 5
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	/* skip past procname */
	--argc;
	++argv;
d708 2
a709 1
 *			W D B _ P U T _ T C L
d711 6
a716 2
 ** Creates an object and stuffs it into the databse.
 ** All arguments must be specified.  Object cannot already exist.
d718 12
d731 5
a735 6
static int
wdb_put_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp     *interp;
     int		argc;
     char	      **argv;
a741 5
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	/* skip past procname */
	--argc;
	++argv;
d801 1
a801 2
 *			W D B _ A D J U S T _ T C L
 *
d803 14
a816 10
 ** For use with Tcl, this routine accepts as its first argument an item in
 ** the database; as its remaining arguments it takes the properties that
 ** need to be changed and their values.
 *
 *  Example of adjust operation on a solid:
 *	.inmem adjust LIGHT V { -46 -13 5 }
 *
 *  Example of adjust operation on a combination:
 *	.inmem adjust light.r rgb { 255 255 255 }
 */
d818 5
a822 6
static int
wdb_adjust_tcl( clientData, interp, argc, argv )
     ClientData	clientData;
     Tcl_Interp     *interp;
     int		argc;
     char	      **argv;
a827 1
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
d829 1
a829 1
	if (argc < 5) {
d835 1
a835 1
	name = argv[2];
d858 1
a858 1
	status = intern.idb_meth->ft_tcladjust(interp, &intern, argc-3, argv+3, &rt_uniresource);
d873 12
a884 1
 *			W D B _ F O R M _ T C L
d886 1
d888 15
a902 5
wdb_form_tcl( clientData, interp, argc, argv )
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
a905 3
	--argc;
	++argv;

d921 1
a921 3
 *			W D B _ T O P S _ T C L
 *
 *  NON-PARALLEL because of rt_uniresource
d924 4
a927 5
wdb_tops_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp     *interp;
     int		argc;
     char	      **argv;
d930 10
d961 16
d982 1
a982 2
wdb_deleteProc_rt(clientData)
     ClientData clientData;
d997 5
a1001 17
/*
 *			W D B _ R T _ G E T T R E E S _ T C L
 *
 *  Given an instance of a database and the name of some treetops,
 *  create a named "ray-tracing" object (proc) which will respond to
 *  subsequent operations.
 *  Returns new proc name as result.
 *
 *  Example:
 *	.inmem rt_gettrees .rt all.g light.r
 */
static int
wdb_rt_gettrees_tcl( clientData, interp, argc, argv )
     ClientData	clientData;
     Tcl_Interp     *interp;
     int		argc;
     char	      **argv;
d1003 1
a1003 2
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
	struct rt_i	*rtip;
d1006 1
a1006 1
	char		*newprocname;
d1011 1
a1011 1
	if (argc < 4) {
d1014 1
a1014 1
				 argv[0], " ", argv[1],
d1020 1
a1020 1
	newprocname = argv[2];
d1025 2
a1026 2
	while (argv[3][0] == '-') {
		if (strcmp( argv[3], "-i") == 0) {
d1032 1
a1032 1
		if (strcmp(argv[3], "-u") == 0) {
d1041 1
a1041 1
	if (rt_gettrees(rtip, argc-3, (CONST char **)&argv[3], 1) < 0) {
d1084 1
a1084 1
 *			W D B _ D U M P _ T C L
d1086 4
a1089 1
 *  Write the current state of a database object out to a file.
d1092 1
a1092 1
 *	.inmem dump "/tmp/foo.g"
d1095 4
a1098 5
wdb_dump_tcl( clientData, interp, argc, argv )
     ClientData	clientData;
     Tcl_Interp     *interp;
     int		argc;
     char	      **argv;
d1101 10
d1117 1
a1117 1
	if (argc != 3) {
d1120 1
a1120 1
				 argv[0], "dump filename.g", (char *)NULL);
d1124 3
a1126 7
	if ((op = wdb_fopen(argv[2])) == RT_WDB_NULL) {
		Tcl_AppendResult(interp,
				 argv[0],
				 " dump:  ",
				 argv[2],
				 ": cannot create",
				 (char *)NULL);
d1129 1
d1132 1
d1134 2
a1135 3
		Tcl_AppendResult(interp,
				 argv[0], " dump ", argv[2], ": db_dump() error",
				 (char *)NULL);
d1143 1
d1145 1
a1145 2
 * Usage:
 *        procname dbip
d1147 2
a1148 1
 * Returns: database objects dbip.
d1151 4
a1154 5
wdb_dbip_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1157 10
d1171 1
a1171 1
	if (argc != 2) {
d1187 1
a1187 1
 *        procname ls [args]
d1189 1
a1189 1
 * Returns: list objects in this database object.
d1192 4
a1195 5
wdb_ls_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1198 10
a1220 4
	/* skip past procname */
	--argc;
	++argv;

d1295 2
a1296 2
 *  Usage:
 *        procname l [-r] arg(s)
d1298 1
a1298 1
 *  List object information, verbose.
d1301 4
a1304 5
wdb_list_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1307 10
d1325 1
a1325 1
	if (argc < 3 || MAXARGS < argc) {
d1335 1
a1335 1
	if (argc > 2 && strcmp(argv[2], "-r") == 0) {
d1344 2
a1345 2
	argc -= 2;
	argv += 2;
d1347 1
a1347 1
	bu_vls_init( &str );
d1351 1
a1351 1
			char *tmp_argv[4];
d1353 3
a1355 4
			tmp_argv[0] = "bogus";
			tmp_argv[1] = listeval;
			tmp_argv[2] = argv[arg];
			tmp_argv[3] = (char *)NULL;
d1357 1
a1357 1
			wdb_pathsum_tcl(clientData, interp, 3, tmp_argv);
d1401 19
d1546 5
a1550 21
/*
 *			W D B _ P A T H S U M _ T C L
 *
 *  Common code for several direct db methods: listeval, paths
 *  Also used as support routine for "l" (list) command.
 *
 *  1.  produces path for purposes of matching
 *  2.  gives all paths matching the input path OR
 *  3.  gives a summary of all paths matching the input path
 *	including the final parameters of the solids at the bottom
 *	of the matching paths
 *
 * Usage:
 *        procname (WDB_LISTEVAL|paths) args(s)
 */
static int
wdb_pathsum_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a1551 1
	struct rt_wdb		*wdbp = (struct rt_wdb *)clientData;
d1555 1
a1555 1
	if (argc < 3 || MAXARGS < argc) {
d1559 1
a1559 1
		bu_vls_printf(&vls, "helplib %s%s", "wdb_", argv[1]);
a1564 3
	--argc;
	++argv;

d1625 27
d1653 2
a1654 3
wdb_scrape_escapes_AppendResult(interp, str)
     Tcl_Interp *interp;
     char *str;
d1673 5
a1677 13
/*
 * Performs wildcard expansion (matched to the database elements)
 * on its given arguments.  The result is returned in interp->result.
 *
 * Usage:
 *        procname expand [args]
 */
static int
wdb_expand_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a1678 1
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
d1684 1
a1684 1
	if (argc < 2 || MAXARGS < argc){
d1696 1
a1696 1
	for (whicharg = 2; whicharg < argc; whicharg++) {
d1754 3
d1758 1
a1758 1
 *        procname kill arg(s)
d1761 1
a1761 1
wdb_kill_tcl(clientData, interp, argc, argv)
d1768 10
d1788 1
a1788 1
	if (argc < 3 || MAXARGS < argc) {
a1797 4
	/* skip past procname */
	argc--;
	argv++;

a1830 2
 * Kill object[s] and remove all references to the object[s].
 *
d1832 1
a1832 1
 *        procname killall arg(s)
d1835 4
a1838 5
wdb_killall_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1842 14
a1855 5
	register int	i,k;
	register struct directory *dp;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	int			ret;
d1862 1
a1862 1
	if(argc < 3 || MAXARGS < argc){
d1889 1
a1889 1
			for (k=2; k<argc; k++) {
d1928 2
a1929 2
	argv[1] = "kill";
	return wdb_kill_tcl(clientData, interp, argc, argv);
d1933 1
a1933 1
 * Kill all paths belonging to an object.
d1936 1
a1936 1
 *        procname killtree arg(s)
d1939 4
a1942 5
wdb_killtree_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d1945 10
d1963 1
a1963 1
	if (argc < 3 || MAXARGS < argc) {
a1972 4
	/* skip past procname */
	argc--;
	argv++;

d1982 2
a1983 2
			wdb_killtree_callback, wdb_killtree_callback, wdbp->wdb_resp,
			(genptr_t)interp );
d1990 17
d2010 3
a2012 4
wdb_killtree_callback(dbip, dp, ptr)
     struct db_i	*dbip;
     register struct directory *dp;
     genptr_t *ptr;
d2032 5
a2036 10
/*
 * Usage:
 *        procname cp from to
 */
static int
wdb_copy_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a2037 1
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
d2047 1
a2047 1
	if (argc != 4) {
d2057 1
a2057 1
	if ((proto = db_lookup(wdbp->dbip,  argv[2], LOOKUP_NOISY)) == DIR_NULL)
d2060 2
a2061 2
	if (db_lookup(wdbp->dbip, argv[3], LOOKUP_QUIET) != DIR_NULL) {
		Tcl_AppendResult(interp, argv[3], ":  already exists", (char *)NULL);
d2070 1
a2070 1
	if ((dp=db_diradd(wdbp->dbip, argv[3], -1, proto->d_len, proto->d_flags, (genptr_t)&proto->d_minor_type)) == DIR_NULL ) {
a2087 2
 * Rename an object.
 *
d2089 1
a2089 1
 *        procname mv from to
d2092 4
a2095 5
wdb_move_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d2098 12
a2109 2
	register struct directory *dp;
	struct rt_db_internal	intern;
d2116 1
a2116 1
	if (argc != 4) {
d2126 1
a2126 1
	if ((dp = db_lookup(wdbp->dbip,  argv[2], LOOKUP_NOISY)) == DIR_NULL)
d2129 2
a2130 2
	if (db_lookup(wdbp->dbip, argv[3], LOOKUP_QUIET) != DIR_NULL) {
		Tcl_AppendResult(interp, argv[3], ":  already exists", (char *)NULL);
d2140 1
a2140 1
	if (db_rename(wdbp->dbip, dp, argv[3]) < 0) {
d2142 1
a2142 1
		Tcl_AppendResult(interp, "error in db_rename to ", argv[3],
d2157 1
a2157 1
 * Rename all occurences of an object
d2160 1
a2160 1
 *        procname mvall from to
d2163 4
a2166 5
wdb_move_all_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d2169 10
d2190 1
a2190 1
	if (argc != 4) {
d2200 1
a2200 1
	if ((int)strlen(argv[3]) > RT_NAMESIZE) {
d2211 1
a2211 1
	if ((dp = db_lookup(wdbp->dbip, argv[2], LOOKUP_NOISY )) == DIR_NULL)
d2214 2
a2215 2
	if (db_lookup(wdbp->dbip, argv[3], LOOKUP_QUIET) != DIR_NULL) {
		Tcl_AppendResult(interp, argv[3], ":  already exists", (char *)NULL);
d2220 2
a2221 2
	if (db_rename(wdbp->dbip, dp, argv[3]) < 0) {
		Tcl_AppendResult(interp, "error in rename to ", argv[3],
d2263 1
a2263 1
					if (!strncmp(comb_leaf->tr_l.tl_name, argv[2], RT_NAMESIZE)) {
d2265 1
a2265 1
						comb_leaf->tr_l.tl_name = bu_strdup(argv[3]);
d2300 18
d2319 6
a2324 5
wdb_do_update(dbip, comb, comb_leaf, user_ptr1, user_ptr2, user_ptr3)
     struct db_i		*dbip;
     struct rt_comb_internal *comb;
     union tree		*comb_leaf;
     genptr_t		user_ptr1, user_ptr2, user_ptr3;
d2374 4
a2377 5
wdb_dir_add5(
	struct db_i		*dbip,		/* db_i to add this object to */
	const struct db5_raw_internal *rip,
	long			laddr,
	genptr_t		client_data )
d2558 6
a2563 7
wdb_dir_add(input_dbip, name, laddr, len, flags, ptr)
     register struct db_i	*input_dbip;
     register CONST char	*name;
     long			laddr;
     int			len;
     int			flags;
     genptr_t			ptr;
d2716 5
a2720 12
/*
 *  Concatenate another GED file into the current file.
 *
 * Usage:
 *        procname concat file.g prefix
 */
static int
wdb_concat_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a2721 1
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
d2723 1
a2723 1
	int bad = 0;
d2725 1
a2725 1
	int version;
d2732 1
a2732 1
	if (argc != 4) {
d2743 2
a2744 2
	if (strcmp(argv[3], "/") != 0) {
		(void)bu_vls_strcpy(&wdbp->wdb_prestr, argv[3]);
d2757 2
a2758 2
	if ((newdbp = db_open(argv[2], "r")) == DBI_NULL) {
		perror(argv[2]);
d2760 1
a2760 1
				 argv[2], (char *)NULL);
d2776 1
a2776 1
	if( version < 5 ) {
d2789 1
a2789 1
	rt_mempurge( &(newdbp->dbi_freep) );        /* didn't really build a directory */
d2799 17
d2829 4
a2832 5
wdb_dir_check5( input_dbip, rip, addr, ptr )
     register struct db_i		*input_dbip;
     const struct db5_raw_internal	*rip;
     long				addr;
     genptr_t				ptr;
d2937 5
a2941 10
/*
 * Usage:
 *        procname dup file.g [prefix]
 */
static int
wdb_dup_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a2942 2
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

d2948 1
a2948 1
	if (argc < 3 || argc > 4) {
d2959 2
a2960 2
	if( argc == 4 )
		(void)bu_vls_strcpy(&wdbp->wdb_prestr, argv[3]);
d2973 3
a2975 3
	if ((newdbp = db_open(argv[2], "r")) == DBI_NULL) {
		perror(argv[2]);
		Tcl_AppendResult(interp, "dup: Can't open ", argv[2], (char *)NULL);
d2981 1
a2981 1
			 "  with ", argv[2], " for duplicate names\n", (char *)NULL);
d2984 1
a2984 1
				 argv[2], " were prefixed with:  ",
d3029 1
a3029 1
 *        procname group groupname object(s)
d3032 1
a3032 1
wdb_group_tcl(clientData, interp, argc, argv)
d3039 10
d3057 1
a3057 1
	if (argc < 4 || MAXARGS < argc) {
d3068 1
a3068 1
	for (i = 3; i < argc; i++) {
a3079 2
 * Remove members from a combination.
 *
d3081 1
a3081 1
 *        procname remove comb object(s)
d3084 4
a3087 5
wdb_remove_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d3090 16
a3105 6
	register struct directory *dp;
	register int	i;
	int		num_deleted;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	int			ret;
d3112 1
a3112 1
	if (argc < 4 || MAXARGS < argc) {
d3122 1
a3122 1
	if ((dp = db_lookup(wdbp->dbip,  argv[2], LOOKUP_NOISY)) == DIR_NULL)
d3142 1
a3142 1
	for (i = 3; i < argc; i++) {
d3165 2
d3168 1
a3168 1
 *        procname r object(s)
d3171 1
a3171 1
wdb_region_tcl(clientData, interp, argc, argv)
d3178 14
a3191 4
	register struct directory *dp;
	int i;
	int ident, air;
	char oper;
a3210 4
	/* skip past procname */
	--argc;
	++argv;
 
d3240 1
a3240 1
		if ((dp = db_lookup(wdbp->dbip,  argv[i+1], LOOKUP_NOISY )) == DIR_NULL ) {
d3276 4
a3279 1
	/*XXX This is the way MGED used to do it. */ 
a3333 3
 * Create or add to the end of a combination, with one or more solids,
 * with explicitly specified operations.
 *
d3335 1
a3335 1
 *        procname comb comb_name opr1 sol1 opr2 sol2 ... oprN solN
d3338 1
a3338 1
wdb_comb_tcl(clientData, interp, argc, argv)
d3345 10
a3364 4
	/* skip past procname */
	--argc;
	++argv;

d3430 26
a3455 8
static void
wdb_find_ref(dbip, comb, comb_leaf, object, comb_name_ptr, user_ptr3)
     struct db_i		*dbip;
     struct rt_comb_internal	*comb;
     union tree		*comb_leaf;
     genptr_t		object;
     genptr_t		comb_name_ptr;
     genptr_t		user_ptr3;
d3472 5
a3476 10
/*
 * Usage:
 *        procname find object(s)
 */
static int
wdb_find_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d3478 4
a3481 5
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
	register int	i,k;
	register struct directory *dp;
	struct rt_db_internal intern;
	register struct rt_comb_internal *comb=(struct rt_comb_internal *)NULL;
d3483 1
a3483 1
	if (argc < 3 || MAXARGS < argc) {
d3505 1
a3505 1
			for (k=2; k<argc; k++)
d3515 16
d3542 5
a3546 10
/*
 * Usage:
 *        procname whichair/whichid [-s] id(s)
 */
static int
wdb_which_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a3547 2
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

d3558 1
a3558 1
	if (argc < 3 || MAXARGS < argc) {
d3562 1
a3562 1
		bu_vls_printf(&vls, "helplib wdb_%s", argv[1]);
d3568 1
a3568 1
	if (!strcmp(argv[1], "whichair"))
d3573 1
a3573 1
	if (strcmp(argv[2], "-s") == 0) {
d3595 1
a3595 1
	for (j=2; j<argc; j++) {
a3711 2
 * Change or return the database title.
 *
d3713 1
a3713 1
 *        procname title [description]
d3716 1
a3716 1
wdb_title_tcl(clientData, interp, argc, argv)
d3722 11
a3732 1
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
d3734 1
a3734 1
	int bad = 0;
d3743 1
a3743 1
	if (argc < 2 || MAXARGS < argc) {
d3753 2
a3754 1
	if (argc < 3) {
d3759 1
d3761 1
a3761 1
	bu_vls_from_argv(&title, argc-2, argv+2);
d3773 17
d3795 6
a3800 7
wdb_print_node(wdbp, interp, dp, pathpos, prefix, cflag)
     struct rt_wdb		*wdbp;
     Tcl_Interp			*interp;
     register struct directory	*dp;
     int			pathpos;
     char			prefix;
     int			cflag;
d3911 5
a3915 10
/*
 * Usage:
 *        procname tree object(s)
 */
static int
wdb_tree_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a3916 1
	struct rt_wdb			*wdbp = (struct rt_wdb *)clientData;
d3921 1
a3921 1
	if (argc < 3 || MAXARGS < argc) {
d3931 1
a3931 1
	if (argv[2][0] == '-' && argv[2][1] == 'c') {
d3937 2
a3938 2
	for (j = 2; j < argc; j++) {
		if (j > 2)
d3949 16
d3971 3
a3973 4
wdb_color_putrec(mp, interp, dbip)
     register struct mater *mp;
     Tcl_Interp *interp;
     struct db_i *dbip;
d4023 3
a4025 4
wdb_color_zaprec(mp, interp, dbip)
     register struct mater *mp;
     Tcl_Interp *interp;
     struct db_i *dbip;
d4049 5
a4053 10
/*
 * Usage:
 *        procname color low high r g b
 */
static int
wdb_color_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a4054 1
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
d4062 1
a4062 1
	if (argc != 7) {
d4082 5
a4086 5
	newp->mt_low = atoi(argv[2]);
	newp->mt_high = atoi(argv[3]);
	newp->mt_r = atoi(argv[4]);
	newp->mt_g = atoi(argv[5]);
	newp->mt_b = atoi(argv[6]);
d4103 15
d4119 4
a4122 5
wdb_pr_mater(mp, interp, ccp, clp)
     register struct mater	*mp;
     Tcl_Interp			*interp;
     int			*ccp;
     int			*clp;
d4139 5
a4143 10
/*
 * Usage:
 *        procname prcolor
 */
static int
wdb_prcolor_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d4149 1
a4149 1
	if (argc != 2) {
d4172 1
a4172 8
 *        procname tol [abs|rel|norm|dist|perp [#]]
 *
 *  abs #	sets absolute tolerance.  # > 0.0
 *  rel #	sets relative tolerance.  0.0 < # < 1.0
 *  norm #	sets normal tolerance, in degrees.
 *  dist #	sets calculational distance tolerance
 *  perp #	sets calculational normal tolerance.
 *
d4175 1
a4175 1
wdb_tol_tcl(clientData, interp, argc, argv)
d4178 2
a4179 2
     int	argc;
     char	**argv;
d4182 10
d4195 1
a4195 1
	if (argc < 2 || 4 < argc){
d4204 1
a4204 1
	if (argc == 2) {
d4259 1
a4259 1
	if (argc == 3) {
d4264 1
a4264 1
		switch (argv[2][0]) {
d4290 1
a4290 1
			bu_vls_printf(&vls, "unrecognized tolerance type - %s", argv[2]);
d4301 1
a4301 1
	if (sscanf(argv[3], "%lf", &f) != 1) {
d4303 1
a4303 1
		bu_vls_printf(&vls, "bad tolerance - %s", argv[3]);
d4310 1
a4310 1
	switch (argv[2][0]) {
d4363 1
a4363 1
		bu_vls_printf(&vls, "unrecognized tolerance type - %s", argv[2]);
d4373 22
d4423 4
a4426 5
wdb_push_leaf(tsp, pathp, ip, client_data)
     struct db_tree_state	*tsp;
     struct db_full_path	*pathp;
     struct rt_db_internal	*ip;
     genptr_t		client_data;
d4498 4
a4501 5
wdb_push_region_end( tsp, pathp, curtree, client_data)
     register struct db_tree_state *tsp;
     struct db_full_path	*pathp;
     union tree		*curtree;
     genptr_t		client_data;
d4506 5
a4510 17
/*
 * The push command is used to move matrices from combinations 
 * down to the solids. At some point, it is worth while thinking
 * about adding a limit to have the push go only N levels down.
 *
 * the -d flag turns on the treewalker debugging output.
 * the -P flag allows for multi-processor tree walking (not useful)
 *
 * Usage:
 *        procname push object(s)
 */
static int
wdb_push_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a4511 1
	struct rt_wdb 		*wdbp = (struct rt_wdb *)clientData;
d4528 1
a4528 1
	if (argc < 3 || MAXARGS < argc) {
d4553 1
a4553 1
	bu_optind = 2;	/* re-init bu_getopt() */
d4660 7
d4668 1
a4668 1
 *        procname whatid object
d4671 4
a4674 5
wdb_whatid_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a4676 4
	struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	struct bu_vls vls;
d4678 15
a4692 1
	if (argc != 3) {
d4700 1
a4700 1
	if ((dp=db_lookup(wdbp->dbip, argv[2], LOOKUP_NOISY )) == DIR_NULL )
d4704 1
a4704 1
		Tcl_AppendResult(interp, argv[2], " is not a region", (char *)NULL );
d4721 15
d4748 3
a4750 4
wdb_node_write(dbip, dp, client_data)
     struct db_i		*dbip;
     register struct directory	*dp;
     genptr_t			client_data;
d4760 1
a4760 1
	if( db_get_external( &ext, dp, dbip ) < 0 )  {
d4762 1
a4762 1
			dp->d_namep, ", aborting", (char *)NULL);
d4766 1
a4766 1
	if( db_fwrite_external( wndp->fp, dp->d_namep, &ext) < 0 )  {
d4769 1
a4769 1
			dp->d_namep, ", aborting", (char *)NULL);
d4774 5
a4778 10
/*
 * Usage:
 *        procname keep file object(s)
 */
static int
wdb_keep_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a4779 1
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
d4786 1
a4786 1
	if (argc < 4 || MAXARGS < argc) {
d4803 2
a4804 2
	if ((keepfp = fopen(argv[2], "r")) != NULL) {
		Tcl_AppendResult(interp, "keep:  appending to '", argv[2],
d4809 2
a4810 2
	if ((keepfp = fopen(argv[2], "a")) == NULL) {
		perror(argv[2]);
d4822 1
a4822 1
		Tcl_AppendResult(interp, "db_fwrite_ident(", argv[2],
d4832 1
a4832 1
	for (i = 3; i < argc; i++) {
d4846 1
a4846 1
 *        procname cat object(s)
d4849 4
a4852 5
wdb_cat_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a4854 3
	register struct directory *dp;
	register int arg;
	struct bu_vls str;
d4856 14
a4869 1
	if (argc < 3 || MAXARGS < argc) {
d4880 1
a4880 1
	for (arg = 2; arg < argc; arg++) {
a4893 2
 * Add instance of obj to comb.
 *
d4895 1
a4895 1
 *        procname i obj comb [op]
d4898 4
a4901 5
wdb_instance_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d4904 12
a4915 2
	register struct directory *dp;
	char oper;
d4922 1
a4922 1
	if (argc < 4 || 5 < argc) {
d4932 1
a4932 1
	if ((dp = db_lookup(wdbp->dbip,  argv[2], LOOKUP_NOISY)) == DIR_NULL)
d4936 2
a4937 2
	if (argc == 5)
		oper = argv[4][0];
d4951 1
a4951 1
	if (wdb_combadd(interp, wdbp->dbip, dp, argv[3], 0, oper, 0, 0, wdbp) == DIR_NULL)
d4958 1
a4958 1
 * Attach/detach observers to/from list.
d4961 1
a4961 2
 *	  procname observer cmd [args]
 *
d4964 4
a4967 5
wdb_observer_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d4971 10
a4980 1
	if (argc < 3) {
d4992 1
a4992 1
		      interp, argc - 2, argv + 2, bu_observer_cmds, 0);
d4996 4
a4999 2
 *	Build an RPP bounding box for the list of objects
 *	and/or paths passed to this routine
a5000 2
 *	Usage:
 *		dbobjname make_bb bbname obj(s)
d5003 15
a5017 5
wdb_make_bb_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
a5027 1
	struct rt_wdb		*wdbp = (struct rt_wdb *)clientData;
d5029 1
a5029 1
	if (argc < 4 || MAXARGS < argc) {
d5040 2
a5041 2
	if (strchr( argv[2], '/')) {
		Tcl_AppendResult(interp, "Do not use '/' in solid names: ", argv[2], "\n", (char *)NULL);
d5045 1
a5045 1
	new_name = argv[2];
d5059 1
a5059 1
	for (i = 3 ; i < argc ; i++) {
d5109 1
a5109 1
	for (i = 3 ; i < argc ; i++) {
d5203 2
d5206 2
a5207 6
 * Generate an identifier that is guaranteed not to be the name
 * of any object currently in the database.
 *
 * Usage:
 *	dbobjname make_name (template | -s [num])
 *
d5210 9
a5218 5
wdb_make_name_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d5220 5
a5229 1
	struct rt_wdb	*wdbp = (struct rt_wdb *)clientData;
d5232 2
a5233 2
	case 3:
		if (strcmp(argv[2], "-s") != 0)
d5239 1
a5239 1
	case 4:
d5243 2
a5244 2
			if ((strcmp(argv[2], "-s") == 0)
			    && (sscanf(argv[3], "%d", &new_i) == 1)) {
d5262 1
a5262 1
	for (cp = argv[2], len = 0; *cp != '\0'; ++cp, ++len) {
d5286 3
a5288 1
 * Set/get the database units. 
d5291 2
a5292 1
 *        dbobjname units [str]
d5295 16
a5310 5
wdb_units_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
a5311 1
	struct rt_wdb	*wdbp = (struct rt_wdb *)clientData;
d5319 1
a5319 1
	if (argc < 2 || 3 < argc) {
d5326 1
a5326 1
	if (argc == 3 && strcmp(argv[2], "-s") == 0) {
d5333 1
a5333 1
	if (argc < 3) {
d5349 2
a5350 2
	if ((loc2mm = bu_mm_value(argv[2]) ) <= 0) {
		Tcl_AppendResult(interp, argv[2], ": unrecognized unit\n",
d5384 301
a5684 1
	return TCL_OK;
d5688 9
d5702 4
a5705 5
wdb__tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d5708 2
d5716 1
a5716 1
 *			D B O _ C M P D I R N A M E
d5723 2
a5724 3
wdb_cmpdirname(a, b)
     CONST genptr_t a;
     CONST genptr_t b;
d5740 4
a5743 5
wdb_vls_col_item(str, cp, ccp, clp)
     struct bu_vls	*str;
     register char	*cp;
     int		*ccp;   /* column count pointer */
     int		*clp;   /* column length pointer */
d5770 3
a5772 4
wdb_vls_col_eol(str, ccp, clp)
     struct bu_vls	*str;
     int		*ccp;
     int		*clp;
d5781 1
a5781 1
 *			D B O _ V L S _ C O L _ P R 4 V
d5788 3
a5790 4
wdb_vls_col_pr4v(vls, list_of_names, num_in_list)
     struct bu_vls *vls;
     struct directory **list_of_names;
     int num_in_list;
d5847 1
a5847 1
 *			D B O _ V L S _ L I N E _ D P P
d5854 7
a5860 8
wdb_vls_line_dpp(vls, list_of_names, num_in_list, aflag, cflag, rflag, sflag)
     struct bu_vls *vls;
     struct directory **list_of_names;
     int num_in_list;
     int aflag;	/* print all objects */
     int cflag;	/* print combinations */
     int rflag;	/* print regions */
     int sflag;	/* print solids */
d5899 1
a5899 1
 *			D B O _ G E T S P A C E
d5908 2
a5909 3
wdb_getspace(dbip, num_entries)
     struct db_i *dbip;
     register int num_entries;
d5931 5
a5935 6
wdb_do_list(dbip, interp, outstrp, dp, verbose)
     struct db_i *dbip;
     Tcl_Interp *interp;
     struct bu_vls *outstrp;
     register struct directory *dp;
     int verbose;
d5957 1
a5957 1
 *			C O M B A D D
d5959 1
a5959 1
 * Add an instance of object 'dp' to combination 'name'.
d5966 9
a5974 10
wdb_combadd(interp, dbip, objp, combname, region_flag, relation, ident, air, wdbp)
     Tcl_Interp *interp;
     struct db_i *dbip;
     register struct directory *objp;
     char *combname;
     int region_flag;			/* true if adding region */
     int relation;			/* = UNION, SUBTRACT, INTERSECT */
     int ident;				/* "Region ID" */
     int air;				/* Air code */
     struct rt_wdb *wdbp;
d6003 1
a6003 1
		if ((dp = db_diradd(dbip, combname, -1, 2, flags, (genptr_t)&intern.idb_type)) == DIR_NULL )  {
d6125 6
a6130 5
wdb_do_identitize(dbip, comb, comb_leaf, user_ptr1, user_ptr2, user_ptr3)
     struct db_i		*dbip;
     struct rt_comb_internal *comb;
     union tree		*comb_leaf;
     genptr_t		user_ptr1, user_ptr2, user_ptr3;
d6155 3
a6157 4
wdb_identitize(dp, dbip, interp)
     struct directory *dp;
     struct db_i *dbip;
     Tcl_Interp *interp;
a6177 260
}

static int
wdb_hide_tcl( clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct rt_wdb			*wdbp = (struct rt_wdb *)clientData;
	struct directory		*dp;
	struct db_i			*dbip;
	struct bu_external		ext;
	struct bu_external		tmp;
	struct db5_raw_internal		raw;
	int				i;

	if( argc < 3 ) {
		struct bu_vls vls;

		bu_vls_init( &vls );
		bu_vls_printf(&vls, "helplib wdb_hide");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	RT_CK_WDB( wdbp );

	dbip = wdbp->dbip;

	RT_CK_DBI( dbip );
	if( dbip->dbi_version < 5 ) {
		Tcl_AppendResult(interp, "The \"hide\" command is only valid for version 5 databases and later\n",
				 (char *)NULL );
		return TCL_ERROR;
	}

	for( i=2 ; i<argc ; i++ ) {
		if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY )) == DIR_NULL ) {
			continue;
		}

		RT_CK_DIR( dp );

		BU_INIT_EXTERNAL(&ext);

		if( db_get_external( &ext, dp, dbip ) < 0 ) {
			Tcl_AppendResult(interp, "db_get_external failed for ",
					 dp->d_namep, " \n", (char *)NULL );
			continue;
		}

		if( db5_get_raw_internal_ptr( &raw, ext.ext_buf ) < 0 ) {
			Tcl_AppendResult(interp, "db5_get_raw_internal_ptr() failed for ",
					 dp->d_namep, " \n", (char *)NULL );
			bu_free_external( &ext );
			continue;
		}

		raw.h_name_hidden = (unsigned char)(0x1);

		BU_INIT_EXTERNAL( &tmp );
		db5_export_object3( &tmp, DB5HDR_HFLAGS_DLI_APPLICATION_DATA_OBJECT,
			dp->d_namep,
			raw.h_name_hidden,
			&raw.attributes,
			&raw.body,
			raw.major_type, raw.minor_type,
			raw.a_zzz, raw.b_zzz );
		bu_free_external( &ext );

		if( db_put_external( &tmp, dp, dbip ) ) {
			Tcl_AppendResult(interp, "db_put_external() failed for ",
					 dp->d_namep, " \n", (char *)NULL );
			bu_free_external( &tmp );
			continue;
		}
		bu_free_external( &tmp );
		dp->d_flags |= DIR_HIDDEN;
	}

	return TCL_OK;
}


static int
wdb_unhide_tcl( clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct rt_wdb			*wdbp = (struct rt_wdb *)clientData;
	struct directory		*dp;
	struct db_i			*dbip;
	struct bu_external		ext;
	struct bu_external		tmp;
	struct db5_raw_internal		raw;
	int				i;

	if( argc < 3 ) {
		struct bu_vls vls;

		bu_vls_init( &vls );
		bu_vls_printf(&vls, "helplib wdb_unhide");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	RT_CK_WDB( wdbp );

	dbip = wdbp->dbip;

	RT_CK_DBI( dbip );
	if( dbip->dbi_version < 5 ) {
		Tcl_AppendResult(interp, "The \"unhide\" command is only valid for version 5 databases and later\n",
				 (char *)NULL );
		return TCL_ERROR;
	}

	for( i=2 ; i<argc ; i++ ) {
		if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY )) == DIR_NULL ) {
			continue;
		}

		RT_CK_DIR( dp );

		BU_INIT_EXTERNAL(&ext);

		if( db_get_external( &ext, dp, dbip ) < 0 ) {
			Tcl_AppendResult(interp, "db_get_external failed for ",
					 dp->d_namep, " \n", (char *)NULL );
			continue;
		}

		if( db5_get_raw_internal_ptr( &raw, ext.ext_buf ) < 0 ) {
			Tcl_AppendResult(interp, "db5_get_raw_internal_ptr() failed for ",
					 dp->d_namep, " \n", (char *)NULL );
			bu_free_external( &ext );
			continue;
		}

		raw.h_name_hidden = (unsigned char)(0x0);

		BU_INIT_EXTERNAL( &tmp );
		db5_export_object3( &tmp, DB5HDR_HFLAGS_DLI_APPLICATION_DATA_OBJECT,
			dp->d_namep,
			raw.h_name_hidden,
			&raw.attributes,
			&raw.body,
			raw.major_type, raw.minor_type,
			raw.a_zzz, raw.b_zzz );
		bu_free_external( &ext );

		if( db_put_external( &tmp, dp, dbip ) ) {
			Tcl_AppendResult(interp, "db_put_external() failed for ",
					 dp->d_namep, " \n", (char *)NULL );
			bu_free_external( &tmp );
			continue;
		}
		bu_free_external( &tmp );
		dp->d_flags &= (~DIR_HIDDEN);
	}

	return TCL_OK;
}

int
wdb_attr_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp     *interp;
     int		argc;
     char	      **argv;
{
	int			i;
	struct directory	*dp;
	struct bu_attribute_value_set avs;
	struct bu_attribute_value_pair	*avpp;
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	/* this is only valid for v5 databases */
	if( wdbp->dbip->dbi_version < 5 ) {
		Tcl_AppendResult(interp, "Attributes are only available in database version 5 and later\n", (char *)NULL );
		return TCL_ERROR;
	}

	/* skip past procname */
	--argc;
	++argv;

	if (argc < 2 ) {
		Tcl_AppendResult(interp,
				 "wrong # args: should be \"", argv[0],
				 " objName [attribute] [value] [[attribute] [value]...]\"", (char *)NULL);
		return TCL_ERROR;
	}

	/* Verify that this wdb supports lookup operations
	   (non-null dbip) */
	if (wdbp->dbip == 0) {
		Tcl_AppendResult(interp,
				 "db does not support lookup operations",
				 (char *)NULL);
		return TCL_ERROR;
	}

	if( (dp=db_lookup( wdbp->dbip, argv[1], LOOKUP_NOISY)) == DIR_NULL )
		return TCL_ERROR;

	
	if( db5_get_attributes( wdbp->dbip, &avs, dp ) ) {
		Tcl_AppendResult(interp,
				 "Cannot get attributes for object ", dp->d_namep, "\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( argc == 2 ) {
		/* just list all the attributes */
		avpp = avs.avp;
		for( i=0 ; i < avs.count ; i++, avpp++ ) {
			Tcl_AppendResult(interp, avpp->name, " {", avpp->value, "} ", (char *)NULL );
		}
	} else if( argc == 3 ) {
		/* just getting a single attribute */
		CONST char *val;

		val = bu_avs_get( &avs, argv[2] );
		if( !val ) {
			Tcl_AppendResult(interp, "Object ", dp->d_namep, " does not have a ", argv[2], " attribute\n", (char *)NULL );
			bu_avs_free( &avs );
			return TCL_ERROR;
		}
		Tcl_AppendResult(interp, val, (char *)NULL );
	} else {
		/* setting attribute/value pairs */
		if( argc % 2 ) {
			Tcl_AppendResult(interp, "Error: attribute names and values must be in pairs!!!\n", (char *)NULL );
			bu_avs_free( &avs );
			return TCL_ERROR;
		}

		i = 2;
		while( i < argc ) {
			(void)bu_avs_add( &avs, argv[i], argv[i+1] );
			i += 2;
		}
		if( db5_update_attributes( dp, &avs, wdbp->dbip ) ) {
			Tcl_AppendResult(interp, "Error: failed to update attributes\n", (char *)NULL );
			bu_avs_free( &avs );
			return TCL_ERROR;
		}

		/* avs is freed by db5_update_attributes() */
		return TCL_OK;
	}

	bu_avs_free( &avs );
	return TCL_OK;
@


1.103
log
@Added help for "hide" and "unhide"
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.102 2001/04/02 21:38:10 morrison Exp $ (ARL)";
d113 1
d176 1
d5697 93
@


1.102
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.101 2001/04/02 20:06:49 jra Exp $ (ARL)";
d5546 10
d5630 10
d5646 1
a5646 1
		Tcl_AppendResult(interp, "The \"hide\" command is only valid for version 5 databases and later\n",
@


1.101
log
@Added "hide" and "unhide" commands
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.100 2001/04/02 13:04:52 jra Exp $ (ARL)";
d1335 1
a1335 1
		bn_mat_copy(new_xlate, old_xlate);
d1402 1
a1402 1
	bn_mat_copy(wtdp->wtd_xform, old_xlate);
d4197 1
a4197 1
	bn_mat_copy(pip->pi_mat, tsp->ts_mat);
@


1.100
log
@Lint
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.99 2001/03/31 01:57:13 morrison Exp $ (ARL)";
d154 2
d190 1
d217 1
d5529 147
@


1.99
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.98 2001/03/30 21:13:50 jra Exp $ (ARL)";
a5347 1
		intern.idb_ptr = (genptr_t)comb;
d5357 1
@


1.98
log
@"tops" now honors the HIDDEN flag
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.97 2001/03/27 23:07:50 bparker Exp $ (ARL)";
d1269 1
a1269 1
			bn_mat_idn(ts.ts_mat);
d1512 1
a1512 1
	bn_mat_idn(wtd.wtd_xform);
d5487 1
a5487 1
	bn_mat_idn(comb_leaf->tr_l.tl_mat);
@


1.97
log
@*- re-import pathsum from MGED
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb_obj.c,v 1.96 2001/03/23 22:05:31 jra Exp $ (ARL)";
d891 1
a891 1
			if (dp->d_nref == 0)
@


1.96
log
@Support for major and minor types in directory structure
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb_obj.c,v 1.95 2001/03/23 21:03:20 bparker Exp $ (ARL)";
d56 1
d59 7
d78 11
a104 1

d158 2
a159 1
static int wdb_trace();
d1304 38
a1341 17
/*
 *			W D B _ T R A C E
 *
 *  Follow a given path.  What happens next depends on setting of 'flag'.
 *
 *  Return -
 *	0	path not found
 *	1	OK
 */
static int
wdb_trace(interp, dbip, old_xlate, flag, wdb_xform, des_path)
     Tcl_Interp			*interp;
     struct db_i		*dbip;
     mat_t old_xlate;
     int flag;
     mat_t wdb_xform;
     CONST struct db_full_path *des_path;
d1343 42
a1384 5
	struct bu_vls str;
	struct db_tree_state ts;
	struct db_full_path accumulated_path;
	struct directory *dp;
	int ret = 0;
d1386 2
a1387 2
	RT_CK_DBI(dbip);
	RT_CK_FULL_PATH(des_path);
d1389 6
a1394 13
	db_full_path_init(&accumulated_path);
	db_init_db_tree_state( &ts, dbip, &rt_uniresource );
	bn_mat_copy( ts.ts_mat, old_xlate );
	if( db_follow_path( &ts, &accumulated_path, des_path, LOOKUP_NOISY, 0 ) < 0 )  {
		ret = 0;
		goto out;
	}
	bn_mat_copy( wdb_xform, ts.ts_mat );

	if (flag == WDB_CPEVAL)  {
		/* all they wanted was the matrix */
		ret = 1;
		goto out;
d1397 7
d1405 2
a1406 1
	db_full_path_appendresult( interp, &accumulated_path );
d1408 5
a1412 3
	if (flag == WDB_LISTPATH) {
		ret = 1;
		goto out;
d1415 12
a1426 6
	BU_ASSERT(flag == WDB_LISTEVAL);
	bu_vls_init( &str );
	dp = DB_FULL_PATH_CUR_DIR(&accumulated_path);
	RT_CK_DIR(dp);
	wdb_do_list(dbip, interp, &str, dp, 1);
	Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
a1427 5
	ret = 1;
out:
	db_free_full_path(&accumulated_path);
	db_free_db_tree_state( &ts );
	return ret;
d1452 3
a1454 4
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
	int flag = WDB_CPEVAL;
	mat_t	wdb_xform;
	struct db_full_path	desired_path;
d1460 1
a1460 1
		bu_vls_printf(&vls, "help %s%s", "wdb_", argv[1]);
d1474 8
d1485 1
a1485 1
		flag = WDB_LISTPATH;
d1487 1
a1487 1
	if (strcmp(argv[0], "WDB_LISTEVAL") == 0) {
d1489 1
a1489 1
		flag = WDB_LISTEVAL;
d1493 9
a1501 2
		if( db_string_to_path( &desired_path, wdbp->dbip, argv[1] ) < 0 )
			goto err;
d1503 7
a1509 2
		if( db_argv_to_path( &desired_path, wdbp->dbip, argc-1, (const char*const*)(argv+1) ) < 0 )
			goto err;
d1512 3
a1514 1
	bn_mat_idn( wdb_xform );
d1516 7
a1522 5
	if( wdb_trace(interp, wdbp->dbip,
	    bn_mat_identity, flag, wdb_xform, &desired_path) != 0
	)  {
		db_free_full_path( &desired_path );
		return TCL_OK;
d1525 1
a1525 8
err:
	/* path not found */
	Tcl_AppendResult(interp, "Path:  ", (char *)NULL);
	db_full_path_appendresult( interp, &desired_path );
	Tcl_AppendResult(interp, "  not found", (char *)NULL);

	db_free_full_path( &desired_path );
    	return TCL_ERROR;
d3074 1
a3074 3
	/*XXX This is the way MGED used to do it. But, unfortunately this
	 * creates a dependency for libwdb.
	 */ 
@


1.95
log
@*- back out update of wdb_region_tcl because
   it created a dependency
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb_obj.c,v 1.94 2001/03/23 15:56:53 bparker Exp $ (ARL)";
d1830 1
a1830 1
	if ((dp=db_diradd(wdbp->dbip, argv[3], -1, proto->d_len, proto->d_flags, NULL)) == DIR_NULL ) {
d2299 1
d2371 2
a2372 8
	if ((input_dp = db_diradd(input_dbip, name, laddr, len, flags, NULL)) == DIR_NULL) {
		if( dasp->main_dbip->dbi_version >= 5 )
			bu_vls_free( &local5 );
		return(-1);
	}

	/* Then, register a new object in the main database */
	if ((dp = db_diradd(dasp->main_dbip, local, -1L, 0, flags, NULL)) == DIR_NULL) {
d2390 7
d4759 1
a4759 1
	if ((dp=db_diradd( wdbp->dbip, new_name, -1L, 0, DIR_SOLID, NULL)) == DIR_NULL) {
d5250 5
d5256 1
a5256 1
		if ((dp = db_diradd(dbip, combname, -1, 2, flags, NULL)) == DIR_NULL )  {
a5267 5

		RT_INIT_DB_INTERNAL(&intern);
		intern.idb_type = ID_COMBINATION;
		intern.idb_meth = &rt_functab[ID_COMBINATION];
		intern.idb_ptr = (genptr_t)comb;
@


1.94
log
@*- updated wdb_region_tcl with MGED's version
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb_obj.c,v 1.93 2001/03/22 21:58:16 bparker Exp $ (ARL)";
d2885 1
a2886 1
	struct bu_list head;
d2903 2
a2904 1
	BU_LIST_INIT(&head);
d2930 48
d3026 1
@


1.93
log
@*- update wdb_push_tcl according to MGED's
   old version of f_push (MGED now uses wdb_push_tcl)
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb_obj.c,v 1.92 2001/03/22 20:24:14 bparker Exp $ (ARL)";
d58 7
a2884 1
	int ident, air;
d2886 1
d2903 1
a2903 2
 	ident = wdbp->wdb_item_default;
 	air = wdbp->wdb_air_default;
d2959 1
a2959 5
		if (wdb_combadd(interp, wdbp->dbip, dp,
				argv[1], 1, oper, ident, air, wdbp) == DIR_NULL) {
			Tcl_AppendResult(interp, "error in combadd", (char *)NULL);
			return TCL_ERROR;
		}
d2962 5
a2966 1
	if (db_lookup(wdbp->dbip, argv[1], LOOKUP_QUIET) == DIR_NULL) {
d2970 5
a4092 1
	int			id;
@


1.92
log
@*- tol stuff already initialized by wdb_dbopen
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb_obj.c,v 1.91 2001/03/22 19:37:39 jra Exp $ (ARL)";
d4077 3
a4079 4
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
	struct wdb_push_data *wpdp;
	struct wdb_push_id *pip;
	struct bu_external	es_ext;
d4081 8
a4088 8
	int	i;
	int	id;
	int	ncpu;
	int	c;
	int	old_debug;
	int	push_error;
	extern 	int bu_optind;
	extern	char *bu_optarg;
d4176 1
a4176 3
		BU_INIT_EXTERNAL(&es_ext);
		RT_INIT_DB_INTERNAL(&es_int);
		if (db_get_external(&es_ext, pip->pi_dir, wdbp->dbip) < 0) {
d4182 3
a4184 2
		id = rt_id_solid(&es_ext);
		if (rt_functab[id].ft_import(&es_int, &es_ext, pip->pi_mat, wdbp->dbip, &rt_uniresource) < 0 ) {
d4186 1
a4186 11
					 "): solid import failure\n", (char *)NULL);
			rt_db_free_internal( &es_int, &rt_uniresource);
			bu_free_external( &es_ext);
			continue;
		}
		RT_CK_DB_INTERNAL(&es_int);
		if (rt_functab[id].ft_export( &es_ext, &es_int, 1.0, wdbp->dbip, &rt_uniresource) < 0 ) {
		  Tcl_AppendResult(interp, "push(", pip->pi_dir->d_namep,
				   "): solid export failure\n", (char *)NULL);
		} else {
			db_put_external(&es_ext, pip->pi_dir, wdbp->dbip);
a4188 1
		bu_free_external(&es_ext);
@


1.91
log
@Added support for hidden flag for database objects
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb_obj.c,v 1.90 2001/03/21 20:07:30 bparker Exp $ (ARL)";
d411 2
d424 1
@


1.90
log
@*- add cflag parameter to wdb_print_node
*- add -c option to wdb_tree_tcl for use by wdb_print_node
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb_obj.c,v 1.89 2001/03/21 15:56:27 bparker Exp $ (ARL)";
d2142 1
a2142 1
		db5_export_object3( &ext, rip->h_dli, local, &rip->attributes,
d2187 1
a2187 1
		db5_export_object3( &ext, rip->h_dli, local, &rip->attributes,
@


1.89
log
@*- add -s flag to wdb_which_tcl
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb_obj.c,v 1.88 2001/03/20 16:09:07 jra Exp $ (ARL)";
d3378 7
a3384 6
wdb_print_node(wdbp, interp, dp, pathpos, prefix)
     struct rt_wdb *wdbp;
     Tcl_Interp *interp;
     register struct directory *dp;
     int pathpos;
     char prefix;
d3386 7
a3392 4
	register int	i;
	register struct directory *nextdp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
d3394 1
a3394 1
	for( i=0; i<pathpos; i++) 
d3487 1
a3487 1
				wdb_print_node(wdbp, interp, nextdp, pathpos+1, op);
d3506 4
a3509 3
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
	register struct directory *dp;
	register int j;
d3521 6
d3532 1
a3532 1
		wdb_print_node(wdbp, interp, dp, 0, 0);
d4275 1
a4275 1
	rt_db_free_internal(&intern, &rt_uniresource);
@


1.88
log
@ft_import5() and ft_export5() now have a const int minor_type argument
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb_obj.c,v 1.87 2001/03/19 22:19:58 butler Exp $ (ARL)";
a193 2

	{"units",	wdb_units_tcl},
d3147 1
a3147 1
 *        procname whichair/whichid id(s)
d3166 1
d3183 19
d3286 1
a3286 1
			rt_db_free_internal(&intern, &rt_uniresource);
d3292 20
a3311 5
		 while (BU_LIST_WHILE(inp,wdb_id_names,&itnp->headName.l)) {
			 Tcl_AppendElement(interp, bu_vls_addr(&inp->name));
			 BU_LIST_DEQUEUE(&inp->l);
			 bu_vls_free(&inp->name);
			 bu_free((genptr_t)inp, "f_which: inp");
d3315 1
a3315 1
		bu_free((genptr_t)itnp, "f_which: itnp");
@


1.87
log
@patches to merge 5.3 into 6.0
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb_obj.c,v 1.86 2001/03/16 19:35:45 jra Exp $ (ARL)";
d2218 1
a2218 1
		if( rt_comb_import5( &in, &rip->body, NULL, dasp->main_dbip, dasp->wdbp->wdb_resp ) ) {
@


1.86
log
@wdb_dir_check5() now uses raw internal 5 object to determine type
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.85 2001/03/16 16:24:49 jra Exp $ (ARL)";
d51 1
d194 1
d4854 2
a4855 2
     int     argc;
     char    **argv;
@


1.85
log
@More mods for "dup" and "dbconcat" for long names
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.84 2001/03/16 14:48:19 jra Exp $ (ARL)";
d2552 2
a2553 2
	if( !rip->h_name_present )
		return;
d2557 2
d2560 2
a2561 1
	if( !strcmp( name, "_GLOBAL" ) )
@


1.84
log
@Mods to get the "dup" and "dbconcat" commands to handle long names
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.83 2001/03/01 22:17:55 butler Exp $ (ARL)";
d2532 57
d2604 1
a2604 1
	char			local[RT_NAMESIZE+2];
d2613 9
a2621 3
	if (dcsp->wdbp->wdb_ncharadd > 0) {
		(void)strncpy( local, bu_vls_addr( &dcsp->wdbp->wdb_prestr ), dcsp->wdbp->wdb_ncharadd );
		(void)strncpy( local+dcsp->wdbp->wdb_ncharadd, name, RT_NAMESIZE-dcsp->wdbp->wdb_ncharadd );
d2623 6
a2628 1
		(void)strncpy( local, name, RT_NAMESIZE );
a2629 1
	local[RT_NAMESIZE] = '\0';
d2632 1
a2632 1
	if ((dupdp = db_lookup(dcsp->main_dbip, local, LOOKUP_QUIET)) != DIR_NULL) {
d2637 1
d2674 7
a2680 3
	if ((wdbp->wdb_ncharadd = bu_vls_strlen(&wdbp->wdb_prestr)) > 12) {
		wdbp->wdb_ncharadd = 12;
		bu_vls_trunc( &wdbp->wdb_prestr, 12 );
d2710 14
a2723 5
	if (db_scan(newdbp, wdb_dir_check, 0, (genptr_t)&dcs) < 0) {
		Tcl_AppendResult(interp, "dup: db_scan failure", (char *)NULL);
		bu_free((genptr_t)dirp0, "wdb_getspace array");
		db_close(newdbp);
		return TCL_ERROR;
@


1.83
log
@db_ident no longer used.  Converted to db_update_ident
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.82 2001/02/27 19:12:41 bparker Exp $ (ARL)";
d2044 1
a2044 1
	char	*prestr;
d2054 1
a2054 1
	prestr = (char *)user_ptr2;
d2058 1
a2058 1
		(void)strncpy(mref, prestr, *ncharadd);
d2064 1
a2064 1
		bu_vls_strncpy( &mref5, prestr, *ncharadd); 
d2131 6
a2136 2
	bu_vls_strncpy( &local5, dasp->wdbp->wdb_prestr, dasp->wdbp->wdb_ncharadd);
	bu_vls_strcat( &local5, rip->name.ext_buf );
d2231 1
a2231 1
			 (genptr_t)dasp->wdbp->wdb_prestr, (genptr_t)NULL);
d2297 1
a2297 1
			(void)strncpy(local, dasp->wdbp->wdb_prestr, dasp->wdbp->wdb_ncharadd);
d2305 1
a2305 1
		bu_vls_strncpy( &local5, dasp->wdbp->wdb_prestr, dasp->wdbp->wdb_ncharadd);
d2337 1
a2337 1
				bu_vls_strncat( &local5, dasp->wdbp->wdb_prestr, dasp->wdbp->wdb_ncharadd);
d2393 1
a2393 1
					 dasp->wdbp->wdb_prestr, name,
d2406 1
a2406 1
			 (genptr_t)dasp->wdbp->wdb_prestr, (genptr_t)NULL);
d2411 1
a2411 1
				 dasp->wdbp->wdb_prestr, name,
d2465 3
a2467 5
	if (strcmp(argv[3], "/") == 0) {
		/* No prefix desired */
		(void)strcpy(wdbp->wdb_prestr, "\0");
	} else {
		(void)strcpy(wdbp->wdb_prestr, argv[3]);
d2470 7
a2476 3
	if ((wdbp->wdb_ncharadd = strlen(wdbp->wdb_prestr)) > 12) {
		wdbp->wdb_ncharadd = 12;
		wdbp->wdb_prestr[12] = '\0';
d2557 1
a2557 1
		(void)strncpy( local, dcsp->wdbp->wdb_prestr, dcsp->wdbp->wdb_ncharadd );
d2601 1
d2603 1
a2603 3
		(void)strcpy(wdbp->wdb_prestr, argv[3]);
	else
		wdbp->wdb_prestr[0] = '\0';
d2606 1
a2606 1
	if ((wdbp->wdb_ncharadd = strlen(wdbp->wdb_prestr)) > 12) {
d2608 1
a2608 1
		wdbp->wdb_prestr[12] = '\0';
d2624 1
a2624 1
				 wdbp->wdb_prestr, "\n", (char *)NULL);
d4648 1
a4648 1
		if (*cp == '@@')
d4653 1
@


1.82
log
@*- add "units" method
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.81 2001/02/18 04:16:03 jra Exp $ (ARL)";
d4727 1
a4727 1
		    db_ident(wdbp->dbip, wdbp->dbip->dbi_title, new_unit) < 0)
@


1.81
log
@Fixed calls to rt_db_put_internal() and rt_db_free_internal() in wdb_make_bb_tcl() to include a resource pointer.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.80 2001/02/16 22:38:47 bparker Exp $ (ARL)";
d127 1
d187 1
d4661 89
@


1.80
log
@*- add make_bb and make_name methods
   to the wdb_obj
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.79 2001/01/29 18:17:15 jra Exp $ (ARL)";
d4575 2
a4576 2
	if (rt_db_put_internal(dp, wdbp->dbip, &new_intern) < 0) {
		rt_db_free_internal(&new_intern);
@


1.79
log
@lint
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.78 2001/01/29 16:17:10 jra Exp $ (ARL)";
d125 2
d149 1
a149 1
	{"comb",		wdb_comb_tcl},
d152 2
a153 2
	{"dbip",		wdb_dbip_tcl},
	{"dump",		wdb_dump_tcl},
d156 2
a157 2
	{"find",		wdb_find_tcl},
	{"form",		wdb_form_tcl},
d161 2
a162 2
	{"keep",		wdb_keep_tcl},
	{"kill",		wdb_kill_tcl},
d168 2
d174 1
a174 1
	{"open",		wdb_reopen_tcl},
d177 1
a177 1
	{"push",		wdb_push_tcl},
d184 2
a185 2
	{"tops",		wdb_tops_tcl},
	{"tree",		wdb_tree_tcl},
d4386 274
@


1.78
log
@dbconcat now works with v5 and v4 databases
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.77 2000/11/02 02:55:39 mike Exp $ (ARL)";
d75 4
d2109 1
a2109 1
		bu_log("db5_diradd_handler(dbip=x%x, name='%s', addr=x%x, len=%d)\n",
@


1.77
log
@
Allowed "db dup" to have optional prefix.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.76 2000/11/02 02:55:39 mike Exp $ (ARL)";
d2031 3
a2033 1
	char	mref[RT_NAMESIZE+2];
d2046 12
a2057 4
	(void)strncpy(mref, prestr, *ncharadd);
	(void)strncpy(mref+(*ncharadd),
		      comb_leaf->tr_l.tl_name,
		      RT_NAMESIZE-(*ncharadd) );
d2060 3
d2075 179
d2272 3
a2274 1
	char			local[RT_NAMESIZE+2+2];
d2280 9
a2288 3
	if (dasp->wdbp->wdb_ncharadd > 0) {
		(void)strncpy(local, dasp->wdbp->wdb_prestr, dasp->wdbp->wdb_ncharadd);
		(void)strncpy(local+dasp->wdbp->wdb_ncharadd, name, RT_NAMESIZE-dasp->wdbp->wdb_ncharadd);
d2290 4
a2293 1
		(void)strncpy(local, name, RT_NAMESIZE);
a2294 1
	local[RT_NAMESIZE] = '\0';
d2299 2
a2300 1
		char		loc2[RT_NAMESIZE+2+2];
d2305 25
a2329 10
		(void)strncpy( loc2, local, RT_NAMESIZE );
		/* Shift name right two characters, and further prefix */
		strncpy(local+2, loc2, RT_NAMESIZE-2);
		local[1] = '_';			/* distinctive separater */
		local[RT_NAMESIZE] = '\0';	/* ensure null termination */

		for (c = 'A'; c <= 'Z'; c++) {
			local[0] = c;
			if ((dp = db_lookup(dasp->main_dbip, local, LOOKUP_QUIET)) == DIR_NULL)
				break;
d2335 2
d2342 1
a2342 1
				 local, "'\nYou should have used the 'dup' command to detect this,\nand then specified a prefix for the 'concat' command.\n");
d2346 3
a2348 1
	if ((input_dp = db_diradd(input_dbip, name, laddr, len, flags, NULL)) == DIR_NULL)
d2350 1
d2353 3
a2355 1
	if ((dp = db_diradd(dasp->main_dbip, local, -1L, 0, flags, NULL)) == DIR_NULL)
d2357 1
d2365 2
d2376 1
a2376 1
		if ((dasp->wdbp->wdb_ncharadd + strlen(name)) > (unsigned)RT_NAMESIZE)
d2407 2
d2412 2
d2434 1
d2472 8
a2479 1
/* XXX Need to use db_dirbuild() or equivalent. */
d2483 12
a2494 4
	if (db_scan(newdbp, wdb_dir_add, 1, (genptr_t)&das) < 0) {
		Tcl_AppendResult(interp, "concat: db_scan failure", (char *)NULL);
		bad = 1;	
		/* Fall through, to close off database */
d2584 1
d2589 1
@


1.76
log
@
After calling db_scan(), be sure to release the on-disk free map,
to prevent rt_memfree(addr=x10e,size=1)  ERROR type=010 messages.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.75 2000/11/02 02:09:43 mike Exp $ (ARL)";
d2311 1
a2311 1
 *        procname dup file.g prefix
d2327 1
a2327 1
	if (argc != 4) {
d2336 4
a2339 2

	(void)strcpy(wdbp->wdb_prestr, argv[3]);
@


1.75
log
@
Changed calls to db_scan(...db_diradd...) to db_dirbuild(),
which can handle both v4 and v5 databases.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.74 2000/11/01 20:37:17 mike Exp $ (ARL)";
d2248 1
d2377 1
@


1.74
log
@
db_create() got version argument
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.73 2000/10/20 20:32:12 jra Exp $ (ARL)";
d370 1
a370 1
			db_scan(dbip, (int (*)())db_diradd, 1, NULL);
d535 1
a535 1
		db_scan(wdbp->dbip, (int (*)())db_diradd, 1, NULL);
@


1.73
log
@open function initializes the wdb_resource field in the rt_wdb structure
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.72 2000/10/19 16:05:21 bparker Exp $ (ARL)";
d480 1
a480 1
		if ((dbip = db_create(filename)) == DBI_NULL) {
@


1.72
log
@Off by one error in wdb_put_tcl().
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.71 2000/10/17 21:30:29 mike Exp $ (ARL)";
d424 3
d1732 1
a1732 1
			wdb_killtree_callback, wdb_killtree_callback,
d3989 1
a3989 1
		db_functree(wdbp->dbip, dp, wdb_node_write, wdb_node_write, (genptr_t)&wnd);
@


1.71
log
@
Noted area of work to be done.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.70 2000/09/09 04:30:48 mike Exp $ (ARL)";
d665 1
a665 1
	if (argc < 2) {
@


1.70
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.69 2000/09/08 05:54:43 mike Exp $ (ARL)";
d2236 1
@


1.69
log
@
Modified tree routines to take resource pointer.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.68 2000/08/31 03:56:50 mike Exp $ (ARL)";
d1244 1
a1244 1
			if (rt_functab[id].ft_describe(&str, &intern, 99, wdbp->dbip->dbi_base2local) < 0)
d1290 1
a1290 1
	db_init_db_tree_state( &ts, dbip );
d4383 1
a4383 1
				       verbose, dbip->dbi_base2local) < 0)
@


1.68
log
@
Silenced lint.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.67 2000/08/24 21:17:12 mike Exp $ (ARL)";
d636 1
a636 1
	rt_db_free_internal(&intern);
d706 2
a707 2
	if (ftp->ft_tcladjust(interp, &intern, argc-3, argv+3) == TCL_ERROR) {
		rt_db_free_internal(&intern);
d714 1
a714 1
		rt_db_free_internal(&intern);
d718 1
a718 1
	rt_db_free_internal( &intern );
d768 1
a768 1
	status = rt_db_get_internal(&intern, dp, wdbp->dbip, (matp_t)NULL);
d779 1
a779 1
	status = intern.idb_meth->ft_tcladjust(interp, &intern, argc-3, argv+3);
d783 1
a783 1
		rt_db_free_internal(&intern);
d824 2
d843 1
a843 1
	db_update_nref(wdbp->dbip);
d848 1
a848 1
		     dp = dp->d_forw)
d851 1
d954 2
a955 2
	rt_init_resource(resp, 0);
	bu_ptbl_ins_unique(&rtip->rti_resources, (long *)resp);
d1234 1
a1234 1
			if ((id = rt_db_get_internal(&intern, dp, wdbp->dbip, ts.ts_mat)) < 0) {
d1247 1
a1247 1
			rt_db_free_internal(&intern);
d1632 1
a1632 1
			if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL) < 0) {
d1644 1
a1644 1
				code = db_tree_del_dbleaf(&(comb->tree), argv[k]);
d1661 1
a1661 1
			if (rt_db_put_internal(dp, wdbp->dbip, &intern) < 0) {
d1864 1
a1864 1
	if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL) < 0) {
d1871 1
a1871 1
		rt_db_free_internal(&intern);
d1878 1
a1878 1
	if (rt_db_put_internal(dp, wdbp->dbip, &intern) < 0) {
d1948 1
a1948 1
	if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL) < 0) {
d1953 1
a1953 1
	if (rt_db_put_internal(dp, wdbp->dbip, &intern) < 0) {
d1970 1
a1970 1
			if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL) < 0)
d2003 1
a2003 1
				if (rt_db_put_internal(dp, wdbp->dbip, &intern)) {
d2005 1
a2005 1
					rt_db_free_internal( &intern );
d2013 1
a2013 1
				rt_db_free_internal(&intern);
d2080 1
a2080 2
	if (input_dbip->dbi_magic != DBI_MAGIC)
		bu_bomb("wdb_dir_add:  bad dbip");
d2127 1
a2127 1
	if ((dp = db_diradd(dasp->main_dbip, local, -1L, len, flags, NULL)) == DIR_NULL)
d2130 1
a2130 1
	if (rt_db_get_internal(&intern, input_dp, input_dbip, (fastf_t *)NULL) < 0) {
d2140 1
a2140 1
	/* Update the name, and any references */
a2150 3

		bu_free((genptr_t)dp->d_namep, "mged_dir_add: dp->d_namep");
		dp->d_namep = bu_strdup(local);
a2154 2
		bu_free((genptr_t)dp->d_namep, "mged_dir_add: dp->d_namep");
		dp->d_namep = bu_strdup(local);
d2167 1
a2167 1
				 "\" is of an supported type\n",
d2172 1
a2172 1
	if (rt_db_put_internal(dp, dasp->main_dbip, &intern) < 0) {
d2471 1
a2471 1
	if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL) < 0) {
d2483 1
a2483 1
		if (db_tree_del_dbleaf( &(comb->tree), argv[i] ) < 0) {
d2496 1
a2496 1
	if (rt_db_put_internal(dp, wdbp->dbip, &intern) < 0) {
d2761 1
a2761 1
			if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL) < 0) {
d2770 1
a2770 1
			rt_db_free_internal(&intern);
d2885 1
a2885 1
			if (rt_db_get_internal( &intern, dp, wdbp->dbip, (fastf_t *)NULL ) < 0) {
d2909 1
a2909 1
			rt_db_free_internal(&intern);
d2982 2
d3027 1
a3027 1
	if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL) < 0) {
d3039 1
a3039 1
			db_non_union_push(comb->tree);
d3049 3
a3051 1
			actual_count = (struct rt_tree_array *)db_flatten_tree( rt_tree_array, comb->tree, OP_UNION, 1 ) - rt_tree_array;
d3092 1
a3092 1
			db_free_tree( rt_tree_array[i].tl_tree );
d3096 1
a3096 1
	rt_db_free_internal(&intern);
d3163 1
a3163 1
	dir.d_namep = "color_putrec";
d3208 1
a3208 1
	dir.d_namep = "color_zaprec";
d3581 1
d3617 1
a3617 1
			BU_GETUNION(curtree, tree);
d3635 1
a3635 1
	BU_GETUNION(curtree, tree);
d3780 1
a3780 1
		if (rt_functab[id].ft_import(&es_int, &es_ext, pip->pi_mat, wdbp->dbip) < 0 ) {
d3783 1
a3783 1
			rt_db_free_internal( &es_int);
d3788 1
a3788 1
		if (rt_functab[id].ft_export( &es_ext, &es_int, 1.0, wdbp->dbip) < 0 ) {
d3794 1
a3794 1
		rt_db_free_internal(&es_int);
d3866 1
a3866 1
	if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL) < 0)
d3872 1
a3872 1
	rt_db_free_internal(&intern);
d4374 1
a4374 1
	if ((id = rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL)) < 0) {
d4385 1
a4385 1
	rt_db_free_internal(&intern);
d4468 1
a4468 1
		BU_GETUNION( tp, tree );
d4475 1
a4475 1
		if (rt_db_put_internal(dp, dbip, &intern) < 0) {
d4483 1
a4483 1
	if (rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL) < 0) {
d4497 1
a4497 1
		db_non_union_push(comb->tree);
d4500 1
a4500 1
			rt_db_free_internal(&intern);
d4512 3
a4514 1
		actual_count = 1 + (struct rt_tree_array *)db_flatten_tree( tree_list, comb->tree, OP_UNION, 1 ) - tree_list;
d4536 1
a4536 1
	BU_GETUNION(tp, tree);
d4544 1
a4544 1
	comb->tree = (union tree *)db_mkgift_tree( tree_list, node_count, (struct db_tree_state *)NULL );
d4547 1
a4547 1
	if (rt_db_put_internal(dp, dbip, &intern) < 0) {
d4597 1
a4597 1
	if (rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL) < 0) {
d4605 1
a4605 1
		if (rt_db_put_internal(dp, dbip, &intern) < 0) {
@


1.67
log
@
lint
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.66 2000/08/22 06:49:25 mike Exp $ (ARL)";
d1346 1
a1346 1
	int flag;
d3053 3
d3093 1
a3093 1
		bu_free((char *)rt_tree_array, "printnode: rt_tree_array");
@


1.66
log
@
db_flatten_tree() got an additional argument, to prevent memory leaks.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.65 2000/08/21 02:02:34 butler Exp $ (ARL)";
d1382 1
a1382 1
		if( db_argv_to_path( &desired_path, wdbp->dbip, argc-1, argv+1 ) < 0 )
@


1.65
log
@Massive compilation warnings eliminated
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.64 2000/08/10 23:57:26 mike Exp $ (ARL)";
d3050 3
a3052 5
			actual_count = (struct rt_tree_array *)db_flatten_tree( rt_tree_array, comb->tree, OP_UNION ) - rt_tree_array;
			if (actual_count > node_count)
				bu_bomb("wdb_print_node() array overflow!");
			if (actual_count < node_count)
				bu_log("WARNING wdb_print_node() array underflow! %d < %d", actual_count, node_count);
d3088 1
d4507 3
a4509 3
		actual_count = 1 + (struct rt_tree_array *)db_flatten_tree( tree_list, comb->tree, OP_UNION ) - tree_list;
		if( actual_count > node_count )  bu_bomb("combadd() array overflow!");
		if( actual_count < node_count )  bu_log("WARNING combadd() array underflow! %d", actual_count, node_count);
@


1.64
log
@
Modified to use wdb_put_internal() over wdb_export().
It simplifies the code, and prevents problems from double-freeing
the internal form of objects.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.63 2000/07/20 14:01:57 jra Exp $ (ARL)";
d30 2
d55 2
d3906 3
a3908 2
	if( db_fwrite_external( wndp->fp, dp->d_namep, &ext, 1.0 ) < 0 )  {
		Tcl_AppendResult(wndp->interp, "Output database write error on ",
@


1.63
log
@removed a "rt_db_free_internal()" call from wdb_adjust_tcl() to eliminate freeing it twice.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.62 2000/07/13 01:39:27 mike Exp $ (ARL)";
d707 2
a708 3
	if (wdb_export(wdbp, name, intern.idb_ptr, intern.idb_type,
			1.0) < 0)  {
		Tcl_AppendResult(interp, "wdb_export(", argv[1],
d776 1
a776 2
	if( status == TCL_OK && wdb_export(wdbp, name, intern.idb_ptr,
					   intern.idb_type, 1.0) < 0)  {
@


1.62
log
@
db_ident is now db_update_ident
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.61 2000/07/11 23:57:45 mike Exp $ (ARL)";
a783 1
	rt_db_free_internal(&intern);
@


1.61
log
@
Added parens
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_obj.c,v 1.60 2000/07/08 02:23:06 mike Exp $ (ARL)";
a2946 1
	int code;
d2948 1
a2948 1
	/* Caution: Not all wdb's have a dbip, some have only an fp */
d2973 1
a2973 2
	code = db_v4_get_units_code(bu_units_string(wdbp->dbip->dbi_base2local));
	if (db_ident(wdbp->dbip, bu_vls_addr(&title), code) < 0) {
@


1.60
log
@
Added const
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d134 43
a176 43
	"adjust",	wdb_adjust_tcl,
	"c",		wdb_comb_std_tcl,
	"cat",		wdb_cat_tcl,
	"close",	wdb_close_tcl,
	"color",	wdb_color_tcl,
	"comb",		wdb_comb_tcl,
	"concat",	wdb_concat_tcl,
	"cp",		wdb_copy_tcl,
	"dbip",		wdb_dbip_tcl,
	"dump",		wdb_dump_tcl,
	"dup",		wdb_dup_tcl,
	"expand",	wdb_expand_tcl,
	"find",		wdb_find_tcl,
	"form",		wdb_form_tcl,
	"g",		wdb_group_tcl,
	"get",		wdb_get_tcl,
	"i",		wdb_instance_tcl,
	"keep",		wdb_keep_tcl,
	"kill",		wdb_kill_tcl,
	"killall",	wdb_killall_tcl,
	"killtree",	wdb_killtree_tcl,
	"l",		wdb_list_tcl,
	"listeval",	wdb_pathsum_tcl,
	"ls",		wdb_ls_tcl,
	"match",	wdb_match_tcl,
	"mv",		wdb_move_tcl,
	"mvall",	wdb_move_all_tcl,
	"observer",	wdb_observer_tcl,
	"open",		wdb_reopen_tcl,
	"paths",	wdb_pathsum_tcl,
	"prcolor",	wdb_prcolor_tcl,
	"push",		wdb_push_tcl,
	"put",		wdb_put_tcl,
	"r",		wdb_region_tcl,
	"rm",		wdb_remove_tcl,
	"rt_gettrees",	wdb_rt_gettrees_tcl,
	"title",	wdb_title_tcl,
	"tol",		wdb_tol_tcl,
	"tops",		wdb_tops_tcl,
	"tree",		wdb_tree_tcl,
	"whatid",	wdb_whatid_tcl,
	"whichair",	wdb_which_tcl,
	"whichid",	wdb_which_tcl,
d179 15
a193 15
	"units",	wdb_units_tcl,
	"comb_color",	wdb_comb_color_tcl,
	"copymat",	wdb_copymat_tcl,
	"copyeval",	wdb_copyeval_tcl,
	"pathlist",	wdb_pathlist_tcl,
	"getmat",	wdb_getmat_tcl,
	"putmat",	wdb_putmat_tcl,
	"summary",	wdb_summary_tcl,
	"which_shader",	wdb_which_shader_tcl,
	"rcodes",	wdb_rcodes_tcl,
	"wcodes",	wdb_wcodes_tcl,
	"rmater",	wdb_rmater_tcl,
	"wmater",	wdb_wmater_tcl,
	"analyze",	wdb_analyze_tcl,
	"inside",	wdb_inside_tcl,
d195 1
a195 1
	(char *)0,	(int (*)())0
d4315 4
a4318 4
		    !cflag && !rflag && !sflag ||
		    cflag && isComb ||
		    rflag && isRegion ||
		    sflag && isSolid) {
@


1.59
log
@
Added check for v4-only code
@
text
@d19 1
a19 1
 *	The BRL-CAD Package" agreement.
d22 1
a22 1
 *	This software is Copyright (C) 1997 by the United States Army
d25 3
@


1.58
log
@
Fixed error message
@
text
@d3197 2
@


1.57
log
@
Don't need to call db_alloc() in most cases.
@
text
@d3050 1
a3050 1
				bu_bomb("rt_comb_v4_export() array overflow!");
d3052 1
a3052 1
				bu_log("WARNING rt_comb_v4_export() array underflow! %d < %d", actual_count, node_count);
@


1.56
log
@
wdb_push_leaf() needed to get new calling sequence.
@
text
@d1800 1
a1800 2
	if ((dp=db_diradd(wdbp->dbip, argv[3], -1, proto->d_len, proto->d_flags, NULL)) == DIR_NULL ||
	    db_alloc(wdbp->dbip, dp, proto->d_len) < 0) {
a2122 2
	if(db_alloc(dasp->main_dbip, dp, len) < 0)
		return(-1);
d2148 1
a2148 1
	} else {
d2162 7
d3148 2
d4423 1
a4423 2
		if ((dp = db_diradd(dbip, combname, -1, 2, flags, NULL)) == DIR_NULL ||
		    db_alloc(dbip, dp, 2) < 0)  {
a4533 6

	/* increase the length of this record */
	if (db_grow(dbip, dp, 1) < 0) {
		Tcl_AppendResult(interp, "db_grow error, aborting\n", (char *)NULL);
		return DIR_NULL;
	}
@


1.55
log
@
Changed from db_free_external() to bu_free_external()
@
text
@d3555 1
a3555 1
wdb_push_leaf(tsp, pathp, ep, id, client_data)
d3558 1
a3558 2
     struct bu_external	*ep;
     int			id;
d3574 2
a3575 1
		Tcl_AppendResult(wpdp->interp, "wdb_push_leaf(", rt_functab[id].ft_name,
@


1.54
log
@
Changed to use rt_db_free_internal()
@
text
@d1809 1
a1809 1
		db_free_external(&external);
d1813 1
a1813 1
	db_free_external(&external);
d3770 1
a3770 1
			db_free_external( &es_ext);
d3781 1
a3781 1
		db_free_external(&es_ext);
d3900 1
a3900 1
	db_free_external(&ext);
@


1.53
log
@*- change to helplib argument
@
text
@d629 1
a629 1
	intern.idb_meth->ft_ifree(&intern);
d1240 1
a1240 1
			rt_functab[id].ft_ifree(&intern);
d1999 1
a1999 1
					rt_comb_ifree( &intern );
d2007 1
a2007 1
				rt_comb_ifree(&intern);
d2765 1
a2765 1
			rt_comb_ifree(&intern);
d2904 1
a2904 1
			rt_comb_ifree(&intern);
d3087 1
a3087 1
	rt_comb_ifree(&intern);
d3769 1
a3769 1
			if (es_int.idb_ptr) rt_functab[id].ft_ifree( &es_int);
d3780 1
a3780 2
		if (es_int.idb_ptr)
			rt_functab[id].ft_ifree(&es_int);
d3858 1
a3858 1
	rt_comb_ifree(&intern);
d4370 1
a4370 1
	rt_functab[id].ft_ifree(&intern);
d4486 1
a4486 1
			rt_comb_ifree(comb);
@


1.53.2.1
log
@Off by one error in wdb_put_tcl().
@
text
@d658 1
a658 1
	if (argc < 3) {
@


1.53.2.2
log
@After calling db_scan(), be sure to release the on-disk free map,
to prevent rt_memfree(addr=x10e,size=1)  ERROR type=010 messages.
@
text
@a2238 1
	rt_mempurge( &(newdbp->dbi_freep) );        /* didn't really build a directory */
a2366 1
	rt_mempurge( &(newdbp->dbi_freep) );        /* didn't really build a directory */
@


1.53.2.3
log
@Add make_bb method.
@
text
@a45 1
#include "rtgeom.h"
a113 1
static int wdb_make_bb_tcl();
a154 1
	"make_bb",	wdb_make_bb_tcl,
a4107 198
}

/*
 *	Build an RPP bounding box for the list of objects
 *	and/or paths passed to this routine
 *
 *	Usage:
 *		dbobjname make_bb bbname obj(s)
 */
static int
wdb_make_bb_tcl(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
{
	struct rt_i		*rtip;
	int			i;
	point_t			rpp_min,rpp_max;
	struct db_full_path	path;
	struct directory	*dp;
	struct rt_arb_internal	*arb;
	struct rt_db_internal	new_intern;
	struct region		*regp;
	char			*new_name;
	struct rt_wdb		*wdbp = (struct rt_wdb *)clientData;

	if (argc < 4 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib wdb_make_bb");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* Since arguments may be paths, make sure first argument isn't */
	if (strchr( argv[2], '/')) {
		Tcl_AppendResult(interp, "Do not use '/' in solid names: ", argv[2], "\n", (char *)NULL);
		return TCL_ERROR;
	}

	new_name = argv[2];
	if (db_lookup(wdbp->dbip, new_name, LOOKUP_QUIET) != DIR_NULL) {
		Tcl_AppendResult(interp, new_name, " already exists\n", (char *)NULL);
		return TCL_ERROR;
	}

	/* Make a new rt_i instance from the existing db_i sructure */
	if ((rtip=rt_new_rti(wdbp->dbip)) == RTI_NULL) {
		Tcl_AppendResult(interp, "rt_new_rti failure for ", wdbp->dbip->dbi_filename,
				 "\n", (char *)NULL);
		return TCL_ERROR;
	}

	/* Get trees for list of objects/paths */
	for (i = 3 ; i < argc ; i++) {
		int gottree;

		/* Get full_path structure for argument */
		db_full_path_init(&path);
		if (db_string_to_path(&path,  rtip->rti_dbip, argv[i])) {
			Tcl_AppendResult(interp, "db_string_to_path failed for ",
					 argv[i], "\n", (char *)NULL );
			rt_clean(rtip);
			bu_free((genptr_t)rtip, "f_make_bb: rtip");
			return TCL_ERROR;
		}

		/* check if we alerady got this tree */
		gottree = 0;
		for (BU_LIST_FOR(regp, region, &(rtip->HeadRegion))) {
			struct db_full_path tmp_path;

			db_full_path_init(&tmp_path);
			if (db_string_to_path(&tmp_path, rtip->rti_dbip, regp->reg_name)) {
				Tcl_AppendResult(interp, "db_string_to_path failed for ",
						 regp->reg_name, "\n", (char *)NULL);
				rt_clean(rtip);
				bu_free((genptr_t)rtip, "f_make_bb: rtip");
				return TCL_ERROR;
			}
			if (path.fp_names[0] == tmp_path.fp_names[0])
				gottree = 1;
			db_free_full_path(&tmp_path);
			if (gottree)
				break;
		}

		/* if we don't already have it, get it */
		if (!gottree && rt_gettree(rtip, path.fp_names[0]->d_namep)) {
			Tcl_AppendResult(interp, "rt_gettree failed for ",
					 argv[i], "\n", (char *)NULL );
			rt_clean(rtip);
			bu_free((genptr_t)rtip, "f_make_bb: rtip");
			return TCL_ERROR;
		}
		db_free_full_path(&path);
	}

	/* prep calculates bounding boxes of solids */
	rt_prep(rtip);

	/* initialize RPP bounds */
	VSETALL(rpp_min, MAX_FASTF);
	VREVERSE(rpp_max, rpp_min);
	for (i = 3 ; i < argc ; i++) {
		vect_t reg_min, reg_max;
		struct region *regp;
		CONST char *reg_name;

		/* check if input name is a region */
		for (BU_LIST_FOR(regp, region, &(rtip->HeadRegion))) {
			reg_name = regp->reg_name;
			if (*argv[i] != '/' && *reg_name == '/')
				reg_name++;

			if (!strcmp( reg_name, argv[i]))
				goto found;
				
		}
		goto not_found;

		if (regp != REGION_NULL) {
found:
			/* input name was a region  */
			if (rt_bound_tree(regp->reg_treetop, reg_min, reg_max)) {
				Tcl_AppendResult(interp, "rt_bound_tree failed for ",
						 regp->reg_name, "\n", (char *)NULL);
				rt_clean(rtip);
				bu_free((genptr_t)rtip, "f_make_bb: rtip");
				return TCL_ERROR;
			}
			VMINMAX(rpp_min, rpp_max, reg_min);
			VMINMAX(rpp_min, rpp_max, reg_max);
		} else {
			int name_len;
not_found:

			/* input name may be a group, need to check all regions under
			 * that group
			 */
			name_len = strlen( argv[i] );
			for (BU_LIST_FOR( regp, region, &(rtip->HeadRegion))) {
				reg_name = regp->reg_name;
				if (*argv[i] != '/' && *reg_name == '/')
					reg_name++;

				if (strncmp(argv[i], reg_name, name_len))
					continue;

				/* This is part of the group */
				if (rt_bound_tree(regp->reg_treetop, reg_min, reg_max)) {
					Tcl_AppendResult(interp, "rt_bound_tree failed for ",
							 regp->reg_name, "\n", (char *)NULL);
					rt_clean(rtip);
					bu_free((genptr_t)rtip, "f_make_bb: rtip");
					return TCL_ERROR;
				}
				VMINMAX(rpp_min, rpp_max, reg_min);
				VMINMAX(rpp_min, rpp_max, reg_max);
			}
		}
	}

	/* build bounding RPP */
	arb = (struct rt_arb_internal *)bu_malloc(sizeof(struct rt_arb_internal), "arb");
	VMOVE(arb->pt[0], rpp_min);
	VSET(arb->pt[1], rpp_min[X], rpp_min[Y], rpp_max[Z]);
	VSET(arb->pt[2], rpp_min[X], rpp_max[Y], rpp_max[Z]);
	VSET(arb->pt[3], rpp_min[X], rpp_max[Y], rpp_min[Z]);
	VSET(arb->pt[4], rpp_max[X], rpp_min[Y], rpp_min[Z]);
	VSET(arb->pt[5], rpp_max[X], rpp_min[Y], rpp_max[Z]);
	VMOVE(arb->pt[6], rpp_max);
	VSET(arb->pt[7], rpp_max[X], rpp_max[Y], rpp_min[Z]);
	arb->magic = RT_ARB_INTERNAL_MAGIC;

	/* set up internal structure */
	RT_INIT_DB_INTERNAL(&new_intern);
	new_intern.idb_type = ID_ARB8;
	new_intern.idb_meth = &rt_functab[ID_ARB8];
	new_intern.idb_ptr = (genptr_t)arb;

	if ((dp=db_diradd( wdbp->dbip, new_name, -1L, 0, DIR_SOLID, NULL)) == DIR_NULL) {
		Tcl_AppendResult(interp, "Cannot add ", new_name, " to directory\n", (char *)NULL);
		return TCL_ERROR;
	}

	if (rt_db_put_internal(dp, wdbp->dbip, &new_intern) < 0) {
		rt_db_free_internal(&new_intern);
		Tcl_AppendResult(interp, "Database write error, aborting.\n", (char *)NULL);
		return TCL_ERROR;
	}

	rt_clean(rtip);
	bu_free((genptr_t)rtip, "f_make_bb: rtip");
	return TCL_OK;
@


1.53.2.4
log
@Add make_name method (imported and modified from MGED).
@
text
@a115 1
static int wdb_make_name_tcl();
a157 1
	"make_name",	wdb_make_name_tcl,
d4177 1
a4177 1
			bu_free((genptr_t)rtip, "wdb_make_bb_tcl: rtip");
d4191 1
a4191 1
				bu_free((genptr_t)rtip, "wdb_make_bb_tcl: rtip");
d4206 1
a4206 1
			bu_free((genptr_t)rtip, "wdb_make_bb_tcl: rtip");
d4242 1
a4242 1
				bu_free((genptr_t)rtip, "wdb_make_bb_tcl: rtip");
d4268 1
a4268 1
					bu_free((genptr_t)rtip, "wdb_make_bb_tcl: rtip");
d4307 1
a4307 77
	bu_free((genptr_t)rtip, "wdb_make_bb_tcl: rtip");
	return TCL_OK;
}

/*
 *
 * Generate an identifier that is guaranteed not to be the name
 * of any object currently in the database.
 *
 * Usage:
 *	dbobjname make_name (template | -s [num])
 *
 */
static int
wdb_make_name_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;

{
	struct bu_vls	obj_name;
	char		*cp, *tp;
	static int	i = 0;
	int		len;
	struct rt_wdb	*wdbp = (struct rt_wdb *)clientData;

	switch (argc) {
	case 3:
		if (strcmp(argv[2], "-s") != 0)
			break;
		else {
			i = 0;
			return TCL_OK;
		}
	case 4:
		{
			int	new_i;

			if ((strcmp(argv[2], "-s") == 0)
			    && (sscanf(argv[3], "%d", &new_i) == 1)) {
				i = new_i;
				return TCL_OK;
			}
		}
	default:
		{
			struct bu_vls	vls;

			bu_vls_init(&vls);
			bu_vls_printf(&vls, "helplib make_name");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}
	}

	bu_vls_init(&obj_name);
	for (cp = argv[2], len = 0; *cp != '\0'; ++cp, ++len) {
		if (*cp == '@@')
			if (*(cp + 1) == '@@')
				++cp;
			else
				break;
		bu_vls_putc(&obj_name, *cp);
	}
	bu_vls_putc(&obj_name, '\0');
	tp = (*cp == '\0') ? "" : cp + 1;

	do {
		bu_vls_trunc(&obj_name, len);
		bu_vls_printf(&obj_name, "%d", i++);
		bu_vls_strcat(&obj_name, tp);
	}
	while (db_lookup(wdbp->dbip, bu_vls_addr(&obj_name), LOOKUP_QUIET) != DIR_NULL);
	Tcl_AppendResult(interp, bu_vls_addr(&obj_name), (char *) NULL);
	bu_vls_free(&obj_name);
d4320 2
a4321 2
     int	argc;
     char	**argv;
@


1.53.2.5
log
@*- add units command
@
text
@a116 1
static int wdb_units_tcl();
a175 1
	"units",	wdb_units_tcl,
d181 1
d4359 1
a4359 1
			bu_vls_printf(&vls, "helplib wdb_make_name");
a4385 89
	return TCL_OK;
}

/*
 * Set/get the database units. 
 *
 * Usage:
 *        dbobjname units [str]
 */
static int
wdb_units_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
{
	struct rt_wdb	*wdbp = (struct rt_wdb *)clientData;
	double		loc2mm;
	int		new_unit = 0;
	struct bu_vls 	vls;
	CONST char	*str;
	int 		sflag = 0;

	bu_vls_init(&vls);
	if (argc < 2 || 3 < argc) {
		bu_vls_printf(&vls, "helplib wdb_units");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (argc == 3 && strcmp(argv[2], "-s") == 0) {
		--argc;
		++argv;

		sflag = 1;
	}

	if (argc < 3) {
		str = bu_units_string(wdbp->dbip->dbi_local2base);
		if (!str) str = "Unknown_unit";

		if (sflag)
			bu_vls_printf(&vls, "%s", str);
		else
			bu_vls_printf(&vls, "You are editing in '%s'.  1 %s = %g mm \n",
				      str, str, wdbp->dbip->dbi_local2base );

		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
		return TCL_OK;
	}

	/* Allow inputs of the form "25cm" or "3ft" */
	if ((loc2mm = bu_mm_value(argv[2]) ) <= 0) {
		Tcl_AppendResult(interp, argv[2], ": unrecognized unit\n",
				 "valid units: <um|mm|cm|m|km|in|ft|yd|mi>\n", (char *)NULL);
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* See if this is a known v4 database unit */
	if ((new_unit = db_v4_get_units_code(bu_units_string(loc2mm))) >= 0) {
		/* One of the recognized db.h units */
		/* change database to remember the new local unit */
		if (wdbp->dbip->dbi_read_only ||
		    db_ident(wdbp->dbip, wdbp->dbip->dbi_title, new_unit) < 0)
			Tcl_AppendResult(interp,
					 "Warning: unable to stash working units into database\n",
					 (char *)NULL);
	} else {
		/*
		 *  Can't stash requested units into the database for next session,
		 *  but there is no problem with the user editing in these units.
		 */
		Tcl_AppendResult(interp, "\
Due to a database restriction in the current format of .g files,\n\
this choice of units will not be remembered on your next editing session.\n", (char *)NULL);
	}
	wdbp->dbip->dbi_local2base = loc2mm;
	wdbp->dbip->dbi_base2local = 1.0 / loc2mm;

	str = bu_units_string(wdbp->dbip->dbi_local2base);
	if (!str) str = "Unknown_unit";
	bu_vls_printf(&vls, "You are now editing in '%s'.  1 %s = %g mm \n",
		      str, str, wdbp->dbip->dbi_local2base );
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

@


1.52
log
@*- alphabetize command list
@
text
@d1909 1
a1909 1
		bu_vls_printf(&vls, "helplib wdb_move_all");
@


1.51
log
@
Init magic number for application struct.
@
text
@a130 3
	"match",	wdb_match_tcl,
	"get",		wdb_get_tcl,
	"put",		wdb_put_tcl,
d132 8
a139 3
	"form",		wdb_form_tcl,
	"tops",		wdb_tops_tcl,
	"rt_gettrees",	wdb_rt_gettrees_tcl,
d141 1
a141 5
	"dbip",		wdb_dbip_tcl,
	"ls",		wdb_ls_tcl,
	"l",		wdb_list_tcl,
	"listeval",	wdb_pathsum_tcl,
	"paths",	wdb_pathsum_tcl,
d143 6
d152 4
a155 1
	"cp",		wdb_copy_tcl,
d158 7
a164 3
	"concat",	wdb_concat_tcl,
	"dup",		wdb_dup_tcl,
	"g",		wdb_group_tcl,
d166 1
a166 6
	"r",		wdb_region_tcl,
	"c",		wdb_comb_std_tcl,
	"comb",		wdb_comb_tcl,
	"find",		wdb_find_tcl,
	"whichair",	wdb_which_tcl,
	"whichid",	wdb_which_tcl,
d168 2
a170 4
	"color",	wdb_color_tcl,
	"prcolor",	wdb_prcolor_tcl,
	"tol",		wdb_tol_tcl,
	"push",		wdb_push_tcl,
d172 2
a173 3
	"keep",		wdb_keep_tcl,
	"cat",		wdb_cat_tcl,
	"i",		wdb_instance_tcl,
a191 3
	"close",	wdb_close_tcl,
	"observer",	wdb_observer_tcl,
	"open",		wdb_reopen_tcl,
@


1.50
log
@
I shouldn't have taken out fcntl.h, Linux needs it.
@
text
@d951 1
@


1.49
log
@
Removed unnecessary UNIX include files
@
text
@d34 1
@


1.48
log
@*- modify wdb_reopen_tcl to return dbi_filename unless
   an error occurs
@
text
@a31 1
#include <fcntl.h>
d33 3
a35 1
#include <sys/errno.h>
d460 1
d465 3
@


1.47
log
@*- add some comments
@
text
@d521 1
@


1.46
log
@*- add method wdb_reopen_tcl
@
text
@d59 3
a61 3
extern void dgo_eraseobjall_callback();
extern void dgo_impending_wdb_close();
extern void dgo_zapall();
@


1.45
log
@*- add observer command
@
text
@d61 1
d111 1
d189 1
d360 3
d454 2
a455 2
	if (((dbip = db_open(filename, "r+w")) == DBI_NULL ) &&
	    ((dbip = db_open(filename, "r"  )) == DBI_NULL )) {
a476 3
	/* --- Scan geometry database and build in-memory directory --- */
	db_scan(dbip, (int (*)())db_diradd, 1, NULL);

d481 50
@


1.44
log
@
Tidy up use of semaphore.
@
text
@d60 1
d109 1
d168 1
d186 1
d190 3
d231 6
d267 11
a277 1
	/* Among other things, this will call wdb_deleteProc. */
d409 2
d721 4
a725 1
	rt_db_free_internal(&intern);
d1342 1
a1342 1
dgo_scrape_escapes_AppendResult(interp, str)
d1415 1
a1415 1
			dgo_scrape_escapes_AppendResult(interp, argv[whicharg]);
d1445 1
a1445 1
			dgo_scrape_escapes_AppendResult(interp, argv[whicharg]);
d1655 5
d4014 31
@


1.43
log
@Eliminnated some unused variables
@
text
@d3495 1
a3495 1
	bu_semaphore_acquire((unsigned int)(RT_SEM_WORKER - BU_SEM_SYSCALL));
d3508 1
a3508 1
			bu_semaphore_release((unsigned int)(RT_SEM_WORKER - BU_SEM_SYSCALL));
d3526 1
a3526 1
	bu_semaphore_release((unsigned int)(RT_SEM_WORKER - BU_SEM_SYSCALL));
@


1.42
log
@
Eliminated dbi_localunit.  This is a v4 database anachronism.
@
text
@d516 1
a516 3
	register struct directory	       *dp;
	register struct bu_structparse	       *sp = NULL;
	int			id, status;
a517 2
	char			objecttype;
	char		       *objname;
a518 3
	Tcl_DString		ds;
	struct bu_vls		str;
	char			*curr_elem;
d564 1
a564 2
	register struct directory	       *dp;
	int					status, ngran, i;
d654 1
a654 2
	register CONST struct bu_structparse	*sp = NULL;
	int				 status, i;
a656 2
	mat_t				 idn;
	char				 objecttype;
a710 1
	CONST struct bu_structparse	*sp = NULL;
d1253 1
a1253 1
	int i, flag;
a1437 2
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
d1800 1
a1800 1
	register int	i,j,k;	
a2057 3
		register int i;
		char	mref[RT_NAMESIZE+2];

a2345 1
	union tree		*tp;
a3207 1
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
@


1.41
log
@
Eliminated "title" method's dependence on dbi_localunit, which is going away.
@
text
@d3880 2
a3881 1
	if (mk_id_editunits(keepfp, bu_vls_addr(&title), wdbp->dbip->dbi_local2base) < 0) {
d3883 2
a3884 1
		Tcl_AppendResult(interp, "mk_id_editunits() failed\n", (char *)NULL);
@


1.40
log
@
Tidied up the 'keep' command.
@
text
@d2864 1
d2866 2
d2891 2
a2892 1
	if (db_ident(wdbp->dbip, bu_vls_addr(&title), wdbp->dbip->dbi_localunit) < 0) {
@


1.39
log
@*- add cat, keep and i commands
Note - the keep command is currently if'ed out
       until a new mk_id_* command gets made
@
text
@d3792 6
a3797 2
#if 0
/*XXX need to modify the Cakefiles so that LIBRT comes before LIBWDB */
d3804 1
a3804 1
	struct rt_db_internal	intern;
d3811 4
a3814 2
	if (rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL) < 0) {
		Tcl_AppendResult(wndp->interp, "Database read error, aborting", (char *)NULL);
d3818 3
a3820 3
	if (mk_export_fwrite(wndp->fp, dp->d_namep, intern.idb_ptr, intern.idb_type)) {
		Tcl_AppendResult(wndp->interp, "Database write error, aborting", (char *)NULL);
		return;
d3822 1
a3823 1
#endif
d3841 1
a3841 1
	struct wdb_node_data *wndp;
a3842 1
#if 0
d3871 1
a3871 1
	/* ident record */
d3876 1
a3876 1
	if (mk_id_units2(keepfp, bu_vls_addr(&title), wdbp->dbip->dbi_localunit) < 0) {
d3878 1
a3878 1
		Tcl_AppendResult(interp, "mk_id_units() failed\n", (char *)NULL);
d3884 2
a3885 3
	GETSTRUCT(wndp,wdb_node_data);
	wndp->fp = keepfp;
	wndp->interp = interp;
d3890 1
a3890 1
		db_functree(wdbp->dbip, dp, wdb_node_write, wdb_node_write, (genptr_t)wndp);
a3892 1
	bu_free(wndp, "wdb_keep: wndp");
d3895 1
a3895 1
#endif
@


1.38
log
@*- add whatid command
*- removed a bunch of unnecessary end-of-line's
@
text
@d105 3
a161 1
#if 0
d164 2
a166 1
	"i",		wdb_instance_tcl,
d1228 1
a1228 1
	BU_ASSERT( flag == WDB_LISTEVAL );
d1230 1
a1230 1
	dp = DB_FULL_PATH_CUR_DIR( &accumulated_path );
d1232 1
a1232 1
	wdb_do_list( dbip, interp, &str, dp, 1 );
d1237 1
a1237 1
	db_free_full_path( &accumulated_path );
a3758 2
		struct bu_vls vls;

d3783 206
@


1.37
log
@*- add push command
@
text
@d104 1
d158 1
a159 1
	"analyze",	wdb_analyze_tcl,
a160 1
	"inside",	wdb_inside_tcl,
a170 1
	"whatid",	wdb_whatid_tcl,
d176 2
d346 1
a346 1
						 " target type not recognized\n", NULL);
d352 1
a352 1
		Tcl_AppendResult(interp, "wdb_open ", argv[1], " failed\n", NULL);
d431 2
a432 1
			Tcl_AppendResult(interp, "wdb_open: failed to create ", filename, "\n",\
d435 2
a436 1
				Tcl_AppendResult(interp, "opendb: no database is currently opened!", \
d627 1
a627 1
				 ") failure\n", (char *)NULL);
d680 1
a680 1
		Tcl_AppendResult(interp, name, ": not found\n",
d688 1
a688 1
				 ") failure\n", (char *)NULL );
d700 1
a700 1
				 ") failure\n", (char *)NULL);
d822 1
a822 1
				 " newprocname [-i] [-u] treetops...\"\n", (char *)NULL );
d850 1
a850 1
				 "rt_gettrees() returned error\n", (char *)NULL);
d914 1
a914 1
				 argv[0], "dump filename.g\n", (char *)NULL);
d920 4
a923 1
				 argv[0], " dump:  ", argv[2], ": cannot create\n",
d931 1
a931 1
				 argv[0], " dump ", argv[2], ": db_dump() error\n",
d1026 1
a1026 1
			bu_vls_printf(&vls, "Unrecognized option - %c\n", c);
d1149 1
a1149 1
						 ") failure\n", (char *)NULL );
d1158 1
a1158 1
				Tcl_AppendResult(interp, dp->d_namep, ": describe error\n", (char *)NULL);
d1315 1
a1315 1
	Tcl_AppendResult(interp, "  not found\n", (char *)NULL);
d1453 1
a1453 1
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
d1494 1
a1494 1
						 argv[i], "\n", (char *)NULL);
d1525 1
a1525 1
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
d1617 1
a1617 1
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
d1690 1
a1690 1
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
d1708 1
a1708 1
		Tcl_AppendResult(interp, argv[3], ":  already exists\n", (char *)NULL);
d1713 1
a1713 1
		Tcl_AppendResult(interp, "Database read error, aborting\n", (char *)NULL);
d1720 1
a1720 1
				 "An error has occured while adding a new object to the database.\n",
d1727 1
a1727 1
		Tcl_AppendResult(interp, "Database write error, aborting\n", (char *)NULL);
d1753 1
a1753 1
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
d1771 1
a1771 1
		Tcl_AppendResult(interp, argv[3], ":  already exists\n", (char *)NULL);
d1776 1
a1776 1
		Tcl_AppendResult(interp, "Database read error, aborting\n", (char *)NULL);
d1784 1
a1784 1
				 ", aborting\n", (char *)NULL);
d1790 1
a1790 1
		Tcl_AppendResult(interp, "Database write error, aborting\n", (char *)NULL);
d1818 1
a1818 1
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
d1836 1
a1836 1
		bu_vls_printf(&tmp_vls, "ERROR: name length limited to %d characters\n", RT_NAMESIZE);
d1847 1
a1847 1
		Tcl_AppendResult(interp, argv[3], ":  already exists\n", (char *)NULL);
d1854 1
a1854 1
				 ", aborting\n", (char *)NULL);
d1860 1
a1860 1
		Tcl_AppendResult(interp, "Database read error, aborting\n", (char *)NULL);
d1865 1
a1865 1
		Tcl_AppendResult(interp, "Database write error, aborting\n", (char *)NULL);
d1918 1
a1918 1
							 "Database write error, aborting\n",
d1992 1
a1992 1
		bu_bomb("wdb_dir_add:  bad dbip\n");
d2116 1
a2116 1
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
d2146 1
a2146 1
				 argv[2], "\n", (char *)NULL);
d2155 1
a2155 1
		Tcl_AppendResult(interp, "concat: db_scan failure\n", (char *)NULL);
d2257 1
a2257 1
		Tcl_AppendResult(interp, "dup: Can't open ", argv[2], "\n", (char *)NULL);
d2282 1
a2282 1
		Tcl_AppendResult(interp, "dup: db_scan failure\n", (char *)NULL);
d2290 1
a2290 1
	bu_vls_printf(&vls, "\n -----  %d duplicate names found  -----\n", wdbp->wdb_num_dups);
d2315 1
a2315 1
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
d2364 1
a2364 1
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
d2383 1
a2383 1
				 " is not a combination\n", (char *)NULL );
d2388 1
a2388 1
		Tcl_AppendResult(interp, "Database read error, aborting\n", (char *)NULL);
d2413 1
a2413 1
		Tcl_AppendResult(interp, "Database write error, aborting\n", (char *)NULL);
d2438 1
a2438 1
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
d2461 1
a2461 1
		Tcl_AppendResult(interp, "error in number of args!\n", (char *)NULL);
d2511 1
a2511 1
			Tcl_AppendResult(interp, "error in combadd\n", (char *)NULL);
d2547 1
a2547 1
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
d2567 1
a2567 1
		Tcl_AppendResult(interp, "error in number of args!\n", (char *)NULL);
d2577 1
a2577 1
					 " is not a combination\n", (char *)0 );
d2606 1
a2606 1
			Tcl_AppendResult(interp, "error in combadd\n", (char *)NULL);
d2613 1
a2613 1
				 " not created\n", (char *)NULL);
d2678 1
a2678 1
				Tcl_AppendResult(interp, "Database read error, aborting\n", (char *)NULL);
d2802 1
a2802 1
				Tcl_AppendResult(interp, "Database read error, aborting\n", (char *)NULL);
d2863 1
a2863 1
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
d2878 1
a2878 1
		Tcl_AppendResult(interp, wdbp->dbip->dbi_title, "\n", (char *)NULL);
d2886 1
a2886 1
		Tcl_AppendResult(interp, "Error: unable to change database title\n");
d2940 1
a2940 1
		Tcl_AppendResult(interp, "Database read error, aborting\n", (char *)NULL);
d2953 1
a2953 1
				Tcl_AppendResult(interp, "Cannot flatten tree for listing\n", (char *)NULL);
d3077 1
a3077 1
					 "Database alloc error, aborting\n",
d3089 1
a3089 1
				 "Database write error, aborting\n",
d3119 1
a3119 1
				 "Database delete error, aborting\n",
d3141 1
a3141 1
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
d3235 1
a3235 1
		Tcl_AppendResult(interp, "none\n", (char *)NULL);
d3321 1
a3321 1
			      "\tdistance = %g mm\n\tperpendicularity = %g (cosine of %g degrees)\n",
d3362 1
a3362 1
			bu_vls_printf(&vls, "unrecognized tolerance type - %s\n", argv[2]);
d3375 1
a3375 1
		bu_vls_printf(&vls, "bad tolerance - %s\n", argv[3]);
d3435 1
a3435 1
		bu_vls_printf(&vls, "unrecognized tolerance type - %s\n", argv[2]);
d3590 1
a3590 1
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
d3666 1
a3666 1
				 "push:\tdb_walk_tree failed or there was a solid moving\n\tin two or more directions\n",
d3738 48
d3887 3
a3889 3
	qsort( (genptr_t)list_of_names,
	       (unsigned)num_in_list, (unsigned)sizeof(struct directory *),
	       (int (*)())wdb_cmpdirname);
d3896 2
a3897 2
	for( i=0; i < lines; i++) {
		for( j=0; j < 4; j++) {
d3901 2
a3902 2
			namelen = strlen( list_of_names[this_one]->d_namep);
			if( namelen > 16)
d3911 1
a3911 1
			if(list_of_names[this_one]->d_flags & DIR_COMB) {
d3915 1
a3915 1
			if(list_of_names[this_one]->d_flags & DIR_REGION) {
d3924 1
a3924 1
			if( this_one + lines >= num_in_list) {
d3932 1
a3932 1
				while( namelen++ < 20)
@


1.36
log
@*- add tol command
@
text
@d103 1
d118 1
d156 1
a158 2
	"push",		wdb_push_tcl,
	"xpush",	wdb_xpush_tcl,
d3439 293
d4170 56
@


1.35
log
@*- added more database object commands: color, prcolor
*- add "analyze" to the list of commands to add
@
text
@d102 1
d153 1
d156 4
d161 2
a165 3
	"i",		wdb_instance_tcl,
	"inside",	wdb_inside_tcl,
	"keep",		wdb_keep_tcl,
a169 1
	"units",	wdb_units_tcl,
a175 2
	"push",		wdb_push_tcl,
	"xpush",	wdb_xpush_tcl,
d358 17
d3234 200
@


1.34
log
@*- added database object command: tree
@
text
@d41 2
d100 2
d109 2
d150 2
d153 1
a154 2
	"color",	wdb_color_tcl,
	"prcolor",	wdb_prcolor_tcl,
d3017 202
d3236 1
d3254 49
@


1.33
log
@*- add database object command: title
@
text
@d97 1
d143 1
a157 1
	"tree",		wdb_tree_tcl,
d2859 149
@


1.32
log
@*- add database object commands: find, whichair, whichid
@
text
@d96 1
d141 1
a152 1
	"push",		wdb_push_tcl,
a155 1
	"title",	wdb_title_tcl,
a159 1
	"xpush",	wdb_xpush_tcl,
d164 2
d2809 49
@


1.31
log
@*- using new rtg_headwdb
@
text
@d94 2
d137 3
a146 1
	"find",		wdb_find_tcl,
a158 2
	"whichair",	wdb_which_tcl,
	"whichid",	wdb_which_tcl,
d2580 225
@


1.30
log
@*- merged "struct wdb_obj" into "struct rt_wdb"
@
text
@a106 3
/* XXX move this to rt_g */
struct rt_wdb HeadWDB;	/* head of BRLCAD database object list */

a171 1
	BU_LIST_INIT(&HeadWDB.l);
d276 1
a276 1
		for (BU_LIST_FOR(wdbp, rt_wdb, &HeadWDB.l))
d352 1
a352 1
	BU_LIST_APPEND(&HeadWDB.l,&wdbp->l);
@


1.29
log
@*- dgo_eraseobjall_callback's signature changed
@
text
@d108 1
a108 1
struct wdb_obj HeadWDBObj;	/* head of BRLCAD database object list */
d175 1
a175 1
	BU_LIST_INIT(&HeadWDBObj.l);
d208 1
a208 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d210 4
a213 7
	bu_vls_free(&wdbop->wdb_name);

	RT_CK_WDB(wdbop->wdb_wp);
	wdb_close(wdbop->wdb_wp);

	BU_LIST_DEQUEUE(&wdbop->l);
	bu_free((genptr_t)wdbop, "wdb_deleteProc: wdbop");
d230 1
a230 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d241 1
a241 1
	Tcl_DeleteCommand(interp, bu_vls_addr(&wdbop->wdb_name));
d253 1
a253 1
 *	when invoked.  clientData of that proc will be wdb_obj pointer
d276 1
a276 2
	struct wdb_obj *wdbop;
	struct rt_wdb	*wdbp;
d280 2
a281 2
		for (BU_LIST_FOR(wdbop, wdb_obj, &HeadWDBObj.l))
			Tcl_AppendResult(interp, bu_vls_addr(&wdbop->wdb_name), " ", (char *)NULL);
d345 3
a347 7
	/* acquire wdb_obj struct */
	BU_GETSTRUCT(wdbop,wdb_obj);

	/* initialize wdb_obj */
	bu_vls_init(&wdbop->wdb_name);
	bu_vls_strcpy(&wdbop->wdb_name, argv[1]);
	wdbop->wdb_wp = wdbp;
d350 4
a353 4
	wdbop->wdb_item_default = 1000;
	wdbop->wdb_air_default = 0;
	wdbop->wdb_mat_default = 1;
	wdbop->wdb_los_default = 100;
d355 2
a356 2
	/* append to list of wdb_obj's */
	BU_LIST_APPEND(&HeadWDBObj.l,&wdbop->l);
d358 1
a358 1
	/* Instantiate the newprocname, with clientData of wdbop */
d361 1
a361 1
				(ClientData)wdbop, wdb_deleteProc);
d436 1
a436 2
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
	struct rt_wdb  *wdb = wdbop->wdb_wp;
d439 1
d443 1
a443 1
	RT_CK_WDB_TCL(interp,wdb);
d447 1
a447 1
	if( wdb->dbip == 0 ) {
d452 8
a459 8
	bu_vls_init( &matches );
	for( ++argv; *argv != NULL; ++argv ) {
		if( db_regexp_match_all( &matches, wdb->dbip, *argv ) > 0 )
			bu_vls_strcat( &matches, " " );
	}
	bu_vls_trimspace( &matches );
	Tcl_AppendResult( interp, bu_vls_addr(&matches), (char *)NULL );
	bu_vls_free( &matches );
d489 1
a489 2
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
	struct rt_wdb  *wdb = wdbop->wdb_wp;
d494 1
d507 1
a507 1
	if (wdb->dbip == 0) {
d514 1
a514 1
	if (rt_tcl_import_from_path(interp, &intern, argv[1], wdb) == TCL_ERROR)
d542 1
a542 2
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
	struct rt_wdb  *wdb = wdbop->wdb_wp;
d544 1
d548 4
a551 4
	if( argc < 2 ) {
		Tcl_AppendResult( interp,
				  "wrong # args: should be db put objName objType attrs",
				  (char *)NULL );
d561 1
a561 1
	if( wdb->dbip && db_lookup(wdb->dbip, argv[1], LOOKUP_QUIET) != DIR_NULL ) {
d569 1
a569 1
	for( i = 0; argv[2][i] != 0 && i < 16; i++ ) {
d575 5
a579 5
	ftp = rt_get_functab_by_label( type );
	if( ftp == NULL ) {
		Tcl_AppendResult( interp, type,
				  " is an unknown object type.",
				  (char *)NULL );
d583 2
a584 2
	if( ftp->ft_make )  {
		ftp->ft_make( ftp, &intern, 0.0 );
d586 1
a586 1
		rt_generic_make( ftp, &intern, 0.0 );
d589 2
a590 2
	if( ftp->ft_tcladjust( interp, &intern, argc-3, argv+3 ) == TCL_ERROR ) {
		rt_db_free_internal( &intern );
d594 5
a598 5
	if( wdb_export( wdb, name, intern.idb_ptr, intern.idb_type,
			1.0 ) < 0 )  {
		Tcl_AppendResult( interp, "wdb_export(", argv[1],
				  ") failure\n", (char *)NULL );
		rt_db_free_internal( &intern );
d635 1
a635 2
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
	struct rt_wdb  *wdb = wdbop->wdb_wp;
d637 4
a640 4
	if( argc < 5 ) {
		Tcl_AppendResult( interp,
				  "wrong # args: should be \"db adjust objName attr value ?attr? ?value?...\"",
				  (char *)NULL );
d646 1
a646 1
	RT_CK_DBI_TCL(interp,wdb->dbip);
d648 4
a651 4
	dp = db_lookup( wdb->dbip, name, LOOKUP_QUIET );
	if( dp == DIR_NULL ) {
		Tcl_AppendResult( interp, name, ": not found\n",
				  (char *)NULL );
d655 4
a658 4
	status = rt_db_get_internal( &intern, dp, wdb->dbip, (matp_t)NULL );
	if( status < 0 ) {
		Tcl_AppendResult( interp, "rt_db_get_internal(", name,
				  ") failure\n", (char *)NULL );
d661 1
a661 1
	RT_CK_DB_INTERNAL( &intern );
d666 6
a671 6
	status = intern.idb_meth->ft_tcladjust( interp, &intern, argc-3, argv+3 );
	if( status == TCL_OK && wdb_export( wdb, name, intern.idb_ptr,
					    intern.idb_type, 1.0 ) < 0 )  {
		Tcl_AppendResult( interp, "wdb_export(", name,
				  ") failure\n", (char *)NULL );
		rt_db_free_internal( &intern );
d675 1
a675 1
	rt_db_free_internal( &intern );
d701 1
a701 1
	if( (ftp = rt_get_functab_by_label(argv[1])) == NULL )  {
d706 1
a706 1
	return ftp->ft_tclform( ftp, interp );
d713 1
a713 1
wdb_tops_tcl( clientData, interp, argc, argv )
d719 1
a719 2
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
	struct rt_wdb  *wdp = wdbop->wdb_wp;
d723 2
a724 2
	RT_CK_WDB_TCL(interp, wdp);
	RT_CK_DBI_TCL(interp, wdp->dbip);
d728 1
a728 1
	db_update_nref( wdp->dbip );
d730 2
a731 2
	for( i = 0; i < RT_DBNHASH; i++ )
		for( dp = wdp->dbip->dbi_Head[i];
d733 3
a735 3
		     dp = dp->d_forw )
			if( dp->d_nref == 0 )
				Tcl_AppendElement( interp, dp->d_namep );
d779 1
a779 2
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
	struct rt_wdb  *wdp = wdbop->wdb_wp;
d785 2
a786 2
	RT_CK_WDB_TCL(interp, wdp);
	RT_CK_DBI_TCL(interp, wdp->dbip);
d788 5
a792 5
	if( argc < 4 )  {
		Tcl_AppendResult( interp,
				  "rt_gettrees: wrong # args: should be \"",
				  argv[0], " ", argv[1],
				  " newprocname [-i] [-u] treetops...\"\n", (char *)NULL );
d796 1
a796 1
	rtip = rt_new_rti(wdp->dbip);
d802 2
a803 2
	while( argv[3][0] == '-' )  {
		if( strcmp( argv[3], "-i" ) == 0 )  {
d809 1
a809 1
		if( strcmp( argv[3], "-u" ) == 0 )  {
d818 4
a821 4
	if( rt_gettrees( rtip, argc-3, (CONST char **)&argv[3], 1 ) < 0 )  {
		Tcl_AppendResult( interp,
				  "rt_gettrees() returned error\n", (char *)NULL );
		rt_free_rti( rtip );
d837 3
a839 3
	BU_GETSTRUCT( resp, resource );
	rt_init_resource( resp, 0 );
	bu_ptbl_ins_unique( &rtip->rti_resources, (long *)resp );
d841 1
a841 1
	BU_GETSTRUCT( ap, application );
d854 1
a854 1
	Tcl_AppendResult( interp, newprocname, (char *)NULL );
a856 1

d874 1
a874 2
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
	struct rt_wdb  *wdp = wdbop->wdb_wp;
d878 2
a879 2
	RT_CK_WDB_TCL(interp, wdp);
	RT_CK_DBI_TCL(interp, wdp->dbip);
d881 4
a884 4
	if( argc != 3 )  {
		Tcl_AppendResult( interp,
				  "dump: wrong # args: should be \"",
				  argv[0], "dump filename.g\n", (char *)NULL );
d888 4
a891 4
	if( (op = wdb_fopen( argv[2] )) == RT_WDB_NULL )  {
		Tcl_AppendResult( interp,
				  argv[0], " dump:  ", argv[2], ": cannot create\n",
				  (char *)NULL );
d894 6
a899 6
	ret = db_dump(op, wdp->dbip);
	wdb_close( op );
	if( ret < 0 )  {
		Tcl_AppendResult( interp,
				  argv[0], " dump ", argv[2], ": db_dump() error\n",
				  (char *)NULL );
d902 1
d920 1
a920 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d932 1
a932 1
	bu_vls_printf(&vls, "%lu", (unsigned long)wdbop->wdb_wp->dbip);
d952 1
a952 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d970 1
a970 1
	if(argc < 1 || MAXARGS < argc){
d1005 1
a1005 1
		dirp = wdb_getspace(wdbop->wdb_wp->dbip, argc-1);
d1011 1
a1011 1
			if ((dp = db_lookup(wdbop->wdb_wp->dbip, argv[i], LOOKUP_NOISY)) ==
d1018 1
a1018 1
		dirp = wdb_getspace(wdbop->wdb_wp->dbip, 0);	/* Enough for all */
d1025 1
a1025 1
			for (dp = wdbop->wdb_wp->dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
d1056 1
a1056 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d1106 1
a1106 1
			ts.ts_dbip = wdbop->wdb_wp->dbip;
d1114 1
a1114 1
			if ((id = rt_db_get_internal(&intern, dp, wdbop->wdb_wp->dbip, ts.ts_mat)) < 0) {
d1124 1
a1124 1
			if (rt_functab[id].ft_describe(&str, &intern, 99, wdbop->wdb_wp->dbip->dbi_base2local) < 0)
d1129 1
a1129 1
			if ((dp = db_lookup(wdbop->wdb_wp->dbip, argv[arg], LOOKUP_NOISY)) == DIR_NULL)
d1132 1
a1132 1
			wdb_do_list(wdbop->wdb_wp->dbip, interp, &str, dp, 99);	/* very verbose */
d1228 1
a1228 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d1262 1
a1262 1
		if( db_string_to_path( &desired_path, wdbop->wdb_wp->dbip, argv[1] ) < 0 )
d1265 1
a1265 1
		if( db_argv_to_path( &desired_path, wdbop->wdb_wp->dbip, argc-1, argv+1 ) < 0 )
d1271 1
a1271 1
	if( wdb_trace(interp, wdbop->wdb_wp->dbip,
d1325 1
a1325 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d1378 1
a1378 1
			for (dp = wdbop->wdb_wp->dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw) {
d1411 1
a1411 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d1419 1
a1419 1
	if (wdbop->wdb_wp->dbip->dbi_read_only) {
d1446 1
a1446 1
		if ((dp = db_lookup(wdbop->wdb_wp->dbip,  argv[i], verbose)) != DIR_NULL) {
d1454 1
a1454 1
			dgo_eraseobjall_callback(wdbop->wdb_wp->dbip, interp, dp);
d1456 2
a1457 2
			if (db_delete(wdbop->wdb_wp->dbip, dp) < 0 ||
			    db_dirdelete(wdbop->wdb_wp->dbip, dp) < 0) {
d1483 1
a1483 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d1491 1
a1491 1
	if (wdbop->wdb_wp->dbip->dbi_read_only) {
d1510 1
a1510 1
		for (dp = wdbop->wdb_wp->dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw) {
d1514 1
a1514 1
			if (rt_db_get_internal(&intern, dp, wdbop->wdb_wp->dbip, (fastf_t *)NULL) < 0) {
d1543 1
a1543 1
			if (rt_db_put_internal(dp, wdbop->wdb_wp->dbip, &intern) < 0) {
d1579 1
a1579 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d1583 1
a1583 1
	if (wdbop->wdb_wp->dbip->dbi_read_only) {
d1603 1
a1603 1
		if ((dp = db_lookup(wdbop->wdb_wp->dbip, argv[i], LOOKUP_NOISY)) == DIR_NULL)
d1605 1
a1605 1
		db_functree(wdbop->wdb_wp->dbip, dp,
d1651 1
a1651 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d1656 1
a1656 1
	if (wdbop->wdb_wp->dbip->dbi_read_only) {
d1671 1
a1671 1
	if ((proto = db_lookup(wdbop->wdb_wp->dbip,  argv[2], LOOKUP_NOISY)) == DIR_NULL)
d1674 1
a1674 1
	if (db_lookup(wdbop->wdb_wp->dbip, argv[3], LOOKUP_QUIET) != DIR_NULL) {
d1679 1
a1679 1
	if (db_get_external(&external , proto , wdbop->wdb_wp->dbip)) {
d1684 2
a1685 2
	if ((dp=db_diradd(wdbop->wdb_wp->dbip, argv[3], -1, proto->d_len, proto->d_flags, NULL)) == DIR_NULL ||
	    db_alloc(wdbop->wdb_wp->dbip, dp, proto->d_len) < 0) {
d1692 1
a1692 1
	if (db_put_external(&external, dp, wdbop->wdb_wp->dbip) < 0) {
d1715 1
a1715 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d1719 1
a1719 1
	if (wdbop->wdb_wp->dbip->dbi_read_only) {
d1734 1
a1734 1
	if ((dp = db_lookup(wdbop->wdb_wp->dbip,  argv[2], LOOKUP_NOISY)) == DIR_NULL)
d1737 1
a1737 1
	if (db_lookup(wdbop->wdb_wp->dbip, argv[3], LOOKUP_QUIET) != DIR_NULL) {
d1742 1
a1742 1
	if (rt_db_get_internal(&intern, dp, wdbop->wdb_wp->dbip, (fastf_t *)NULL) < 0) {
d1748 1
a1748 1
	if (db_rename(wdbop->wdb_wp->dbip, dp, argv[3]) < 0) {
d1756 1
a1756 1
	if (rt_db_put_internal(dp, wdbop->wdb_wp->dbip, &intern) < 0) {
d1777 1
a1777 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d1784 1
a1784 1
	if (wdbop->wdb_wp->dbip->dbi_read_only) {
d1810 1
a1810 1
	if ((dp = db_lookup(wdbop->wdb_wp->dbip, argv[2], LOOKUP_NOISY )) == DIR_NULL)
d1813 1
a1813 1
	if (db_lookup(wdbop->wdb_wp->dbip, argv[3], LOOKUP_QUIET) != DIR_NULL) {
d1819 1
a1819 1
	if (db_rename(wdbop->wdb_wp->dbip, dp, argv[3]) < 0) {
d1826 1
a1826 1
	if (rt_db_get_internal(&intern, dp, wdbop->wdb_wp->dbip, (fastf_t *)NULL) < 0) {
d1831 1
a1831 1
	if (rt_db_put_internal(dp, wdbop->wdb_wp->dbip, &intern) < 0) {
d1840 1
a1840 1
		for (dp = wdbop->wdb_wp->dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw) {
d1848 1
a1848 1
			if (rt_db_get_internal(&intern, dp, wdbop->wdb_wp->dbip, (fastf_t *)NULL) < 0)
d1881 1
a1881 1
				if (rt_db_put_internal(dp, wdbop->wdb_wp->dbip, &intern)) {
d1933 1
a1933 1
	struct wdb_obj	*wdbop;
d1962 3
a1964 3
	if (dasp->wdbop->wdb_ncharadd > 0) {
		(void)strncpy(local, dasp->wdbop->wdb_prestr, dasp->wdbop->wdb_ncharadd);
		(void)strncpy(local+dasp->wdbop->wdb_ncharadd, name, RT_NAMESIZE-dasp->wdbop->wdb_ncharadd);
d2026 1
a2026 1
		if ((dasp->wdbop->wdb_ncharadd + strlen(name)) > (unsigned)RT_NAMESIZE)
d2029 1
a2029 1
					 dasp->wdbop->wdb_prestr, name,
d2047 1
a2047 1
		if (dasp->wdbop->wdb_ncharadd && comb->tree) {
d2049 2
a2050 2
			 (genptr_t)&(dasp->wdbop->wdb_ncharadd),
			 (genptr_t)dasp->wdbop->wdb_prestr, (genptr_t)NULL);
d2077 1
a2077 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d2082 1
a2082 1
	if (wdbop->wdb_wp->dbip->dbi_read_only) {
d2099 1
a2099 1
		(void)strcpy(wdbop->wdb_prestr, "\0");
d2101 1
a2101 1
		(void)strcpy(wdbop->wdb_prestr, argv[3]);
d2104 3
a2106 3
	if ((wdbop->wdb_ncharadd = strlen(wdbop->wdb_prestr)) > 12) {
		wdbop->wdb_ncharadd = 12;
		wdbop->wdb_prestr[12] = '\0';
d2119 2
a2120 2
	das.main_dbip = wdbop->wdb_wp->dbip;
	das.wdbop = wdbop;
d2130 1
a2130 1
	db_sync(wdbop->wdb_wp->dbip);	/* force changes to disk */
d2141 1
a2141 1
	struct wdb_obj	*wdbop;
d2169 3
a2171 3
	if (dcsp->wdbop->wdb_ncharadd > 0) {
		(void)strncpy( local, dcsp->wdbop->wdb_prestr, dcsp->wdbop->wdb_ncharadd );
		(void)strncpy( local+dcsp->wdbop->wdb_ncharadd, name, RT_NAMESIZE-dcsp->wdbop->wdb_ncharadd );
d2180 1
a2180 1
		dcsp->wdbop->wdb_num_dups++;
d2197 1
a2197 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d2214 5
a2218 5
	(void)strcpy(wdbop->wdb_prestr, argv[3]);
	wdbop->wdb_num_dups = 0;
	if ((wdbop->wdb_ncharadd = strlen(wdbop->wdb_prestr)) > 12) {
		wdbop->wdb_ncharadd = 12;
		wdbop->wdb_prestr[12] = '\0';
d2229 1
a2229 1
			wdbop->wdb_wp->dbip->dbi_filename,
d2231 1
a2231 1
	if (wdbop->wdb_ncharadd) {
d2234 1
a2234 1
				 wdbop->wdb_prestr, "\n", (char *)NULL);
d2238 1
a2238 1
	if ((dirp0 = wdb_getspace(wdbop->wdb_wp->dbip, 0)) == (struct directory **) 0) {
d2245 2
a2246 2
	dcs.main_dbip = wdbop->wdb_wp->dbip;
	dcs.wdbop = wdbop;
d2257 1
a2257 1
	bu_vls_printf(&vls, "\n -----  %d duplicate names found  -----\n", wdbop->wdb_num_dups);
d2277 1
a2277 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d2281 1
a2281 1
	if (wdbop->wdb_wp->dbip->dbi_read_only) {
d2298 3
a2300 3
		if ((dp = db_lookup(wdbop->wdb_wp->dbip, argv[i], LOOKUP_NOISY)) != DIR_NULL) {
			if (wdb_combadd(interp, wdbop->wdb_wp->dbip, dp, argv[2], 0,
					WMOP_UNION, 0, 0, wdbop) == DIR_NULL)
d2321 1
a2321 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d2330 1
a2330 1
	if (wdbop->wdb_wp->dbip->dbi_read_only) {
d2345 1
a2345 1
	if ((dp = db_lookup(wdbop->wdb_wp->dbip,  argv[2], LOOKUP_NOISY)) == DIR_NULL)
d2354 1
a2354 1
	if (rt_db_get_internal(&intern, dp, wdbop->wdb_wp->dbip, (fastf_t *)NULL) < 0) {
d2379 1
a2379 1
	if (rt_db_put_internal(dp, wdbop->wdb_wp->dbip, &intern) < 0) {
d2398 1
a2398 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d2404 1
a2404 1
	if (wdbop->wdb_wp->dbip->dbi_read_only) {
d2419 2
a2420 2
 	ident = wdbop->wdb_item_default;
 	air = wdbop->wdb_air_default;
d2432 1
a2432 1
	if (db_lookup(wdbop->wdb_wp->dbip, argv[1], LOOKUP_QUIET) == DIR_NULL) {
d2434 1
a2434 1
		if (wdbop->wdb_item_default) {
d2437 1
a2437 1
			wdbop->wdb_item_default++;
d2440 1
a2440 1
				wdbop->wdb_item_default);
d2454 1
a2454 1
		if ((dp = db_lookup(wdbop->wdb_wp->dbip,  argv[i+1], LOOKUP_NOISY )) == DIR_NULL ) {
d2476 2
a2477 2
		if (wdb_combadd(interp, wdbop->wdb_wp->dbip, dp,
				argv[1], 1, oper, ident, air, wdbop) == DIR_NULL) {
d2483 1
a2483 1
	if (db_lookup(wdbop->wdb_wp->dbip, argv[1], LOOKUP_QUIET) == DIR_NULL) {
d2485 2
a2486 2
		if (wdbop->wdb_item_default > 1)
			wdbop->wdb_item_default--;
d2507 1
a2507 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d2513 1
a2513 1
	if (wdbop->wdb_wp->dbip->dbi_read_only) {
d2540 1
a2540 1
	if ((dp=db_lookup(wdbop->wdb_wp->dbip, comb_name, LOOKUP_QUIET)) != DIR_NULL) {
d2557 1
a2557 1
		if ((dp = db_lookup(wdbop->wdb_wp->dbip,  argv[i+1], LOOKUP_NOISY)) == DIR_NULL) {
d2572 1
a2572 1
		if (wdb_combadd(interp, wdbop->wdb_wp->dbip, dp, comb_name, 0, oper, 0, 0, wdbop) == DIR_NULL) {
d2578 1
a2578 1
	if (db_lookup(wdbop->wdb_wp->dbip, comb_name, LOOKUP_QUIET) == DIR_NULL) {
d2599 1
a2599 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d2813 1
a2813 1
wdb_combadd(interp, dbip, objp, combname, region_flag, relation, ident, air, wdbop)
d2822 1
a2822 1
     struct wdb_obj *wdbop;
d2872 2
a2873 2
			comb->los = wdbop->wdb_los_default;
			comb->GIFTmater = wdbop->wdb_mat_default;
d2878 2
a2879 2
					wdbop->wdb_mat_default,
					wdbop->wdb_los_default);
@


1.28
log
@
Eliminated the evil global variables.
Modified to use existing support routines.
@
text
@d1466 1
a1466 1
			dgo_eraseobjall_callback(interp, wdbop->wdb_wp->dbip, dp);
@


1.27
log
@
More scrubbing.
@
text
@a97 8
struct do_trace_state {
	Tcl_Interp *interp;
	int	pathpos;
	matp_t	old_xlate;
	int	flag;
	CONST struct db_full_path *des_path;
};
static void wdb_do_trace();
a109 6
/* ==== BEGIN evil stuff ==== */

struct db_full_path	wdb_accumulated_path;

/* ==== END evil stuff ==== */

a1154 30
 * This is a callback invoked by db_tree_funcleaf(), which
 * recursively invokes wdb_trace()
 */
static void
wdb_do_trace(dbip, comb, comb_leaf, user_ptr1, user_ptr2, user_ptr3)
     struct db_i		*dbip;
     struct rt_comb_internal *comb;
     union tree		*comb_leaf;
     genptr_t		user_ptr1, user_ptr2, user_ptr3;
{
	mat_t			new_xlate;
	struct directory	*nextdp;
	struct do_trace_state	*dtsp = (struct do_trace_state *)user_ptr1;

	RT_CK_DBI(dbip);
	RT_CK_TREE(comb_leaf);

	if (comb_leaf->tr_l.tl_mat)  {
		bn_mat_mul(new_xlate, dtsp->old_xlate, comb_leaf->tr_l.tl_mat);
	} else {
		bn_mat_copy(new_xlate, dtsp->old_xlate);
	}
	if ((nextdp = db_lookup(dbip, comb_leaf->tr_l.tl_name, LOOKUP_NOISY)) == DIR_NULL)
		return;

	wdb_trace(dtsp->interp, dbip, nextdp, dtsp->pathpos+1,
		new_xlate, dtsp->flag, dtsp->des_path);
}

/*
d1157 1
a1157 1
 *  XXX Why are we not using db_follow_path()?
d1164 1
a1164 1
wdb_trace(interp, dbip, dp, pathpos, old_xlate, flag, wdb_xform, des_path)
a1166 2
     register struct directory *dp;
     int pathpos;	/* subscript to wdb_accumulated_path[] */
a1171 6
	struct directory *nextdp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	mat_t new_xlate;
	int nparts, i, k;
	int id;
d1173 4
a1176 6
	
	if (dp->d_flags & DIR_COMB) {
		if (rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL) < 0) {
			Tcl_AppendResult(interp, "Database read error, aborting\n", (char *)NULL);
			return 0;
		}
d1178 2
a1179 2
		/* XXX Should check to make sure this comb is on desired_path */
		/* otherwise, why bother recursing into it? */
d1181 13
a1193 16
		db_add_node_to_full_path( &wdb_accumulated_path, dp );
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		if (comb->tree)  {
			struct do_trace_state	dts;
			dts.interp = interp;
			dts.pathpos = pathpos;
			dts.old_xlate = old_xlate;
			dts.flag = flag;
			dts.des_path = des_path;
			/* Recursively invoke wdb_trace() via wdb_do_trace () */
			db_tree_funcleaf(dbip, comb, comb->tree, wdb_do_trace,
				(genptr_t)&dts, NULL, NULL );
		}
		rt_comb_ifree(&intern);
		DB_FULL_PATH_POP( &wdb_accumulated_path );
		return 0;
a1195 18
	/* not a combination  -  should have a solid */

	db_add_node_to_full_path( &wdb_accumulated_path, dp );

	/* check for desired path */
	for (k=0; k<des_path->fp_len; k++) {
		if (wdb_accumulated_path.fp_names[k] != des_path->fp_names[k]) {
			/* not the desired path */
			return 0;
		}
	}

	/* have followed the desired path, all they wanted was the matrix. */
	bn_mat_copy(wdb_xform, old_xlate);

	if (flag == WDB_CPEVAL)
		return 1;

d1197 1
a1197 1
	db_full_path_appendresult( interp, &wdb_accumulated_path );
d1200 2
a1201 1
		return 1;
d1206 2
d1211 5
a1215 1
	return 1;
d1219 5
a1283 1
	    desired_path.fp_names[0], 0,
@


1.26
log
@
Changed to use db_sync().
@
text
@d120 1
a120 1
static struct directory *wdb_accumulated_path[WDB_MAX_LEVELS];
a1224 2

	bu_vls_init( &str );
a1225 15
	if (pathpos >= WDB_MAX_LEVELS) {
		struct bu_vls tmp_vls;

		bu_vls_init(&tmp_vls);
		bu_vls_printf(&tmp_vls, "nesting exceeds %d levels\n", WDB_MAX_LEVELS);
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);

		for(i=0; i < WDB_MAX_LEVELS; i++)
			Tcl_AppendResult(interp, "/", wdb_accumulated_path[i]->d_namep, (char *)NULL);

		Tcl_AppendResult(interp, "\n", (char *)NULL);
		return 0;
	}

d1232 4
a1235 1
		wdb_accumulated_path[pathpos] = dp;
d1249 1
d1255 1
a1255 2
	/* last (bottom) position */
	wdb_accumulated_path[pathpos] = dp;
d1259 1
a1259 1
		if (wdb_accumulated_path[k] != des_path->fp_names[k]) {
d1265 1
a1265 1
	/* have the desired path */
d1272 1
a1272 3
	for (k=0; k<pathpos; k++)
		Tcl_AppendResult(interp, "/", wdb_accumulated_path[k]->d_namep, (char *)NULL);
	bu_vls_printf( &str, "/%16s:\n", dp->d_namep );
a1274 2
		Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
		bu_vls_free(&str);
d1278 3
a1280 10
	/* NOTE - only reach here if flag == WDB_LISTEVAL */

	if ((id=rt_db_get_internal(&intern, dp, dbip, wdb_xform)) < 0) {
		Tcl_AppendResult(interp, "rt_db_get_internal(", dp->d_namep,
				 ") failure", (char *)NULL );
		return 0;			/* ERROR */
	}
	if (rt_functab[id].ft_describe(&str, &intern, 1, dbip->dbi_base2local) < 0)
		Tcl_AppendResult(interp, dp->d_namep, ": describe error\n", (char *)NULL);
	rt_functab[id].ft_ifree(&intern);
d2863 1
a2863 2
	if (dbip == DBI_NULL)
		return;
@


1.25
log
@
Eliminated more global variables
@
text
@d2231 1
a2231 1
	sync();		/* just in case... */
d2911 2
@


1.24
log
@
Another step forward in modernizing wdb_trace
@
text
@d103 1
a121 2
static struct db_full_path	wdb_desired_path;

d1195 1
a1195 1
		new_xlate, dtsp->flag);
d1201 2
d1208 1
a1208 1
wdb_trace(interp, dbip, dp, pathpos, old_xlate, flag, wdb_xform)
d1216 1
d1257 1
d1272 2
a1273 2
	for (k=0; k<wdb_desired_path.fp_len; k++) {
		if (wdb_accumulated_path[k] != wdb_desired_path.fp_names[k]) {
d1279 1
a1279 1
	/* have the desired path up to wdb_desired_path_end */
d1331 1
d1362 1
a1362 1
		if( db_string_to_path( &wdb_desired_path, wdbop->wdb_wp->dbip, argv[1] ) < 0 )
d1365 1
a1365 1
		if( db_argv_to_path( &wdb_desired_path, wdbop->wdb_wp->dbip, argc-1, argv+1 ) < 0 )
d1372 4
a1375 2
	    wdb_desired_path.fp_names[0], 0,
	    bn_mat_identity, flag, wdb_xform) != 0 )
d1377 1
d1382 1
a1382 1
	db_full_path_appendresult( interp, &wdb_desired_path );
d1385 1
a1385 1
	db_free_full_path( &wdb_desired_path );
@


1.23
log
@
Improved names
@
text
@a118 3
/* input path */
static struct directory *wdb_desired_path[WDB_MAX_LEVELS];
static int wdb_desired_path_end;
d121 1
a121 1
/* struct db_full_path	xxx; */
d1269 2
a1270 2
	for (k=0; k<wdb_desired_path_end; k++) {
		if (wdb_accumulated_path[k]->d_addr != wdb_desired_path[k]->d_addr) {
d1285 1
a1287 1
		bu_vls_printf( &str, "/%16s:\n", dp->d_namep );
d1294 1
a1294 1
	Tcl_AppendResult(interp, "/", (char *)NULL);
a1299 1
	bu_vls_printf(&str, "%16s:\n", dp->d_namep);
d1326 1
a1326 1
	int i, flag, pos_in;
d1342 1
a1342 2
	/* pos_in = first member of path entered
	 *
a1356 2
	pos_in = 1;

d1358 2
a1359 9
		char *tok;
		wdb_desired_path_end = 0;

		tok = strtok( argv[1], "/" );
		while (tok) {
			if ((wdb_desired_path[wdb_desired_path_end++] = db_lookup(wdbop->wdb_wp->dbip, tok, LOOKUP_NOISY)) == DIR_NULL)
				return TCL_ERROR;
			tok = strtok( (char *)NULL, "/" );
		}
d1361 2
a1362 7
		wdb_desired_path_end = argc-1;

		/* build directory pointer array for desired path */
		for (i=0; i<wdb_desired_path_end; i++) {
			if ((wdb_desired_path[i] = db_lookup(wdbop->wdb_wp->dbip, argv[pos_in+i], LOOKUP_NOISY)) == DIR_NULL)
				return TCL_ERROR;
		}
d1367 4
a1370 6
	if( wdb_trace(interp, wdbop->wdb_wp->dbip, wdb_desired_path[0], 0,
	    bn_mat_identity, flag, wdb_xform) == 0 )  {
		/* path not found */
		Tcl_AppendResult(interp, "PATH:  ", (char *)NULL);
		for (i=0; i<wdb_desired_path_end; i++)
			Tcl_AppendResult(interp, "/", wdb_desired_path[i]->d_namep, (char *)NULL);
d1372 5
a1376 3
		Tcl_AppendResult(interp, "  NOT FOUND\n", (char *)NULL);
	    	return TCL_ERROR;
	}
d1378 2
a1379 1
	return TCL_OK;
d1381 1
@


1.22
log
@
Scrubbed out another global.
@
text
@d120 5
a124 3
static struct directory *wdb_objects[WDB_MAX_LEVELS];
static int wdb_objpos;
static struct directory *wdb_path[WDB_MAX_LEVELS];
d1173 2
d1214 1
a1214 1
     int pathpos;
d1238 1
a1238 1
			Tcl_AppendResult(interp, "/", wdb_path[i]->d_namep, (char *)NULL);
d1250 1
a1250 1
		wdb_path[pathpos] = dp;
d1258 1
d1269 1
a1269 1
	wdb_path[pathpos] = dp;
d1272 2
a1273 2
	for (k=0; k<wdb_objpos; k++) {
		if (wdb_path[k]->d_addr != wdb_objects[k]->d_addr) {
d1279 1
a1279 1
	/* have the desired path up to wdb_objpos */
d1287 1
a1287 1
		Tcl_AppendResult(interp, "/", wdb_path[k]->d_namep, (char *)NULL);
d1366 1
a1366 1
		wdb_objpos = 0;
d1370 1
a1370 1
			if ((wdb_objects[wdb_objpos++] = db_lookup(wdbop->wdb_wp->dbip, tok, LOOKUP_NOISY)) == DIR_NULL)
d1375 1
a1375 1
		wdb_objpos = argc-1;
d1378 2
a1379 2
		for (i=0; i<wdb_objpos; i++) {
			if ((wdb_objects[i] = db_lookup(wdbop->wdb_wp->dbip, argv[pos_in+i], LOOKUP_NOISY)) == DIR_NULL)
d1386 1
a1386 1
	if( wdb_trace(interp, wdbop->wdb_wp->dbip, wdb_objects[0], 0,
d1390 2
a1391 2
		for (i=0; i<wdb_objpos; i++)
			Tcl_AppendResult(interp, "/", wdb_objects[i]->d_namep, (char *)NULL);
@


1.21
log
@
Changed HIDDEN to static
@
text
@d105 1
a105 1
static void wdb_trace();
a123 3
/* print flag */
static int wdb_prflag;

d1199 5
d1205 1
a1205 1
static void
d1237 1
a1237 1
		return;
d1243 1
a1243 1
			return;
d1258 1
a1258 1
		return;
d1270 1
a1270 1
			return;
a1275 1
	wdb_prflag = 1;
d1278 1
a1278 1
		return;
d1288 1
a1288 1
		return;
d1296 1
a1296 1
		return;
d1304 1
a1345 1
	wdb_prflag = 0;
d1381 2
a1382 3
	wdb_trace(interp, wdbop->wdb_wp->dbip, wdb_objects[0], 0, bn_mat_identity, flag, wdb_xform);

	if (wdb_prflag == 0) {
d1389 1
d2033 1
a2033 1
BU_EXTERN(static int wdb_dir_add, ( struct db_i *input_dbip, CONST char
@


1.20
log
@
Added additional fields to wdb_obj struct, to kill global variables.
@
text
@d2032 1
a2032 1
BU_EXTERN(HIDDEN int wdb_dir_add, ( struct db_i *input_dbip, CONST char
@


1.19
log
@
Abstracted out db_get_directory_size()
@
text
@d114 1
d117 1
a117 10
static char wdb_prestr[RT_NAMESIZE];
static int wdb_ncharadd;
static int wdb_num_dups;
static struct directory	**wdb_dup_dirp;

/* default region ident codes */
int wdb_item_default = 1000;	/* GIFT region ID */
int wdb_air_default = 0;
int wdb_mat_default = 1;		/* GIFT material code */
int wdb_los_default = 100;	/* Line-of-sight estimate */
d122 1
d127 1
a127 1
static struct directory *wdb_path[WDB_MAX_LEVELS];
d376 6
d2038 1
d2067 3
a2069 3
	if (wdb_ncharadd > 0) {
		(void)strncpy(local, wdb_prestr, wdb_ncharadd);
		(void)strncpy(local+wdb_ncharadd, name, RT_NAMESIZE-wdb_ncharadd);
d2131 1
a2131 1
		if ((wdb_ncharadd + strlen(name)) > (unsigned)RT_NAMESIZE)
d2134 2
a2135 1
					 wdb_prestr, name, "\" truncated to \"",
d2152 1
a2152 1
		if (wdb_ncharadd && comb->tree) {
d2154 2
a2155 1
					 (genptr_t)&wdb_ncharadd, (genptr_t)wdb_prestr, (genptr_t)NULL);
d2204 1
a2204 1
		(void)strcpy(wdb_prestr, "\0");
d2206 1
a2206 1
		(void)strcpy(wdb_prestr, argv[3]);
d2209 3
a2211 3
	if ((wdb_ncharadd = strlen(wdb_prestr)) > 12) {
		wdb_ncharadd = 12;
		wdb_prestr[12] = '\0';
d2225 1
d2246 2
d2274 3
a2276 3
	if (wdb_ncharadd > 0) {
		(void)strncpy( local, wdb_prestr, wdb_ncharadd );
		(void)strncpy( local+wdb_ncharadd, name, RT_NAMESIZE-wdb_ncharadd );
d2285 2
a2286 2
		wdb_num_dups++;
		*wdb_dup_dirp++ = dupdp;
d2319 5
a2323 5
	(void)strcpy(wdb_prestr, argv[3]);
	wdb_num_dups = 0;
	if ((wdb_ncharadd = strlen(wdb_prestr)) > 12) {
		wdb_ncharadd = 12;
		wdb_prestr[12] = '\0';
d2333 2
a2334 1
	Tcl_AppendResult(interp, "\n*** Comparing ", wdbop->wdb_wp->dbip->dbi_filename,
d2336 1
a2336 1
	if (wdb_ncharadd) {
d2338 2
a2339 1
				 argv[2], " were prefixed with:  ", wdb_prestr, "\n", (char *)NULL);
d2343 1
a2343 1
	if ((wdb_dup_dirp = wdb_getspace(wdbop->wdb_wp->dbip, 0)) == (struct directory **) 0) {
a2347 1
	dirp0 = wdb_dup_dirp;
d2351 2
d2361 2
a2362 2
	wdb_vls_col_pr4v(&vls, dirp0, (int)(wdb_dup_dirp - dirp0));
	bu_vls_printf(&vls, "\n -----  %d duplicate names found  -----\n", wdb_num_dups);
d2405 1
a2405 1
					WMOP_UNION, 0, 0) == DIR_NULL)
d2524 2
a2525 2
 	ident = wdb_item_default;
 	air = wdb_air_default;
d2539 1
a2539 1
		if (wdb_item_default) {
d2542 1
a2542 1
			wdb_item_default++;
d2544 2
a2545 1
			bu_vls_printf(&tmp_vls, "Defaulting item number to %d\n", wdb_item_default);
d2582 1
a2582 1
				argv[1], 1, oper, ident, air) == DIR_NULL) {
d2590 2
a2591 2
		if (wdb_item_default > 1)
			wdb_item_default--;
d2677 1
a2677 1
		if (wdb_combadd(interp, wdbop->wdb_wp->dbip, dp, comb_name, 0, oper, 0, 0) == DIR_NULL) {
d2917 1
a2917 1
wdb_combadd(interp, dbip, objp, combname, region_flag, relation, ident, air)
d2926 1
d2976 2
a2977 2
			comb->los = wdb_los_default;
			comb->GIFTmater = wdb_mat_default;
d2981 3
a2983 1
				      ident, air, wdb_mat_default, wdb_los_default);
@


1.18
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@a2852 2
	register struct directory *dp;
	register int i;
d2861 1
a2861 6
	if (num_entries == 0) {
		/* Set num_entries to the number of entries */
		for (i = 0; i < RT_DBNHASH; i++)
			for (dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
				num_entries++;
	}
@


1.17
log
@*- declare these variables as not static
@
text
@d69 1
a69 1
static int wdb_get_tcl();
a115 2
static Tcl_Interp *curr_interp;		/* current Tcl interpreter */
static struct db_i *curr_dbip;		/* current dbip */
a133 3
/* path transformation matrix ... calculated in trace() */
static mat_t wdb_xform;

d442 1
a442 1
	db_scan(dbip, (int (*)())db_diradd, 1);
d502 1
d504 1
a504 1
static int
d1205 1
a1205 1
wdb_trace(interp, dbip, dp, pathpos, old_xlate, flag)
d1212 1
d1325 1
a1338 1
	curr_interp = interp;
d1381 1
a1381 1
	wdb_trace(interp, wdbop->wdb_wp->dbip, wdb_objects[0], 0, bn_mat_identity, flag);
a1703 2
	curr_interp = interp;

d1790 1
a1790 1
	if ((dp=db_diradd(wdbop->wdb_wp->dbip, argv[3], -1, proto->d_len, proto->d_flags)) == DIR_NULL ||
d2033 8
d2048 1
a2048 1
wdb_dir_add(input_dbip, name, laddr, len, flags)
d2050 1
a2050 1
     register char		*name;
d2054 1
d2061 1
d2076 1
a2076 1
	if ((dp = db_lookup(curr_dbip, local, LOOKUP_QUIET)) != DIR_NULL) {
d2091 1
a2091 1
			if ((dp = db_lookup(curr_dbip, local, LOOKUP_QUIET)) == DIR_NULL)
d2095 1
a2095 1
			Tcl_AppendResult(curr_interp,
d2100 1
a2100 1
		Tcl_AppendResult(curr_interp,
d2107 1
a2107 1
	if ((input_dp = db_diradd(input_dbip, name, laddr, len, flags)) == DIR_NULL)
d2111 1
a2111 1
	if ((dp = db_diradd(curr_dbip, local, -1L, len, flags)) == DIR_NULL)
d2113 1
a2113 1
	if(db_alloc(curr_dbip, dp, len) < 0)
d2117 4
a2120 4
		Tcl_AppendResult(curr_interp, "Database read error, aborting\n", (char *)NULL);
		if (db_delete(curr_dbip, dp) < 0 ||
		    db_dirdelete(curr_dbip, dp) < 0) {
			Tcl_AppendResult(curr_interp, "Database write error, aborting\n", (char *)NULL);
d2128 1
a2128 1
		Tcl_AppendResult(curr_interp,
d2132 1
a2132 1
			Tcl_AppendResult(curr_interp,
d2143 1
a2143 1
		Tcl_AppendResult(curr_interp,
d2152 1
a2152 1
			db_tree_funcleaf(curr_dbip, comb, comb->tree, wdb_do_update,
d2157 2
a2158 2
	if (rt_db_put_internal(dp, curr_dbip, &intern) < 0) {
		Tcl_AppendResult(curr_interp,
d2183 1
a2219 3
	curr_interp = interp;
	curr_dbip = wdbop->wdb_wp->dbip;

d2221 3
a2223 1
	if (db_scan(newdbp, wdb_dir_add, 1) < 0) {
d2237 8
d2251 1
a2251 1
wdb_dir_check(input_dbip, name, laddr, len, flags)
d2253 1
a2253 1
     register char		*name;
d2257 1
d2261 1
d2263 1
a2263 1
	if (curr_dbip == DBI_NULL)
d2266 1
a2266 2
	if (input_dbip->dbi_magic != DBI_MAGIC)
		bu_bomb("mged_dir_check:  bad dbip\n");
d2278 1
a2278 1
	if ((dupdp = db_lookup(curr_dbip, local, LOOKUP_QUIET)) != DIR_NULL) {
d2302 1
a2342 3
	curr_interp = interp;
	curr_dbip = wdbop->wdb_wp->dbip;

d2344 2
a2345 1
	if (db_scan(newdbp, wdb_dir_check, 0) < 0) {
d2477 1
a2477 1
		Tcl_AppendResult(curr_interp, "Database write error, aborting\n", (char *)NULL);
d2948 1
a2948 1
		if ((dp = db_diradd(dbip, combname, -1, 2, flags)) == DIR_NULL ||
@


1.16
log
@*- change HIDDEN to static
*- add database object commands: c, comb
@
text
@d124 4
a127 4
static int wdb_item_default = 1000;	/* GIFT region ID */
static int wdb_air_default = 0;
static int wdb_mat_default = 1;		/* GIFT material code */
static int wdb_los_default = 100;	/* Line-of-sight estimate */
@


1.15
log
@
Changed calling sequence to wdb_do_trace()
@
text
@d59 2
a60 31
HIDDEN int wdb_open_tcl();
HIDDEN int wdb_close_tcl();
HIDDEN int wdb_decode_dbip();
HIDDEN struct db_i *wdb_prep_dbip();

HIDDEN int wdb_cmd();
HIDDEN int wdb_match_tcl();
HIDDEN int wdb_get_tcl();
HIDDEN int wdb_put_tcl();
HIDDEN int wdb_adjust_tcl();
HIDDEN int wdb_form_tcl();
HIDDEN int wdb_tops_tcl();
HIDDEN int wdb_rt_gettrees_tcl();
HIDDEN int wdb_dump_tcl();
HIDDEN int wdb_dbip_tcl();
HIDDEN int wdb_ls_tcl();
HIDDEN int wdb_list_tcl();
HIDDEN int wdb_pathsum_tcl();
HIDDEN int wdb_expand_tcl();
HIDDEN int wdb_kill_tcl();
HIDDEN int wdb_killall_tcl();
HIDDEN int wdb_killtree_tcl();
HIDDEN void wdb_killtree_callback();
HIDDEN int wdb_copy_tcl();
HIDDEN int wdb_move_tcl();
HIDDEN int wdb_move_all_tcl();
HIDDEN int wdb_concat_tcl();
HIDDEN int wdb_dup_tcl();
HIDDEN int wdb_group_tcl();
HIDDEN int wdb_remove_tcl();
HIDDEN int wdb_region_tcl();
d62 35
a96 2
HIDDEN void wdb_deleteProc();
HIDDEN void wdb_deleteProc_rt();
d104 2
a105 2
HIDDEN void wdb_do_trace();
HIDDEN void wdb_trace();
d116 6
a121 6
HIDDEN Tcl_Interp *curr_interp;		/* current Tcl interpreter */
HIDDEN struct db_i *curr_dbip;		/* current dbip */
HIDDEN char wdb_prestr[RT_NAMESIZE];
HIDDEN int wdb_ncharadd;
HIDDEN int wdb_num_dups;
HIDDEN struct directory	**wdb_dup_dirp;
d124 4
a127 4
HIDDEN int wdb_item_default = 1000;	/* GIFT region ID */
HIDDEN int wdb_air_default = 0;
HIDDEN int wdb_mat_default = 1;		/* GIFT material code */
HIDDEN int wdb_los_default = 100;	/* Line-of-sight estimate */
d130 2
a131 2
HIDDEN struct directory *wdb_objects[WDB_MAX_LEVELS];
HIDDEN int wdb_objpos;
d134 1
a134 1
HIDDEN int wdb_prflag;
d137 1
a137 1
HIDDEN mat_t wdb_xform;
d139 1
a139 1
HIDDEN struct directory *wdb_path[WDB_MAX_LEVELS];
d141 1
a141 1
HIDDEN struct bu_cmdtab wdb_cmds[] = {
d167 2
a169 1
	"c",		wdb_comb_std_tcl,
a170 1
	"comb",		wdb_comb_tcl,
d222 1
a222 1
HIDDEN int
d235 1
a235 1
HIDDEN void
d256 1
a256 1
HIDDEN int
d303 1
a303 1
HIDDEN int
d462 1
a462 1
HIDDEN int
d508 1
a508 1
HIDDEN int
d561 1
a561 1
HIDDEN int
d653 1
a653 1
HIDDEN int
d715 1
a715 1
HIDDEN int
d745 1
a745 1
HIDDEN int
d778 1
a778 1
HIDDEN void
d806 1
a806 1
HIDDEN int
d903 1
a903 1
HIDDEN int
d949 1
a949 1
HIDDEN int
d981 1
a981 1
HIDDEN int
d1085 1
a1085 1
HIDDEN int
d1180 1
a1180 1
HIDDEN void
d1208 1
a1208 1
HIDDEN void
d1319 1
a1319 1
HIDDEN int
d1398 1
a1398 1
HIDDEN void
d1427 1
a1427 1
HIDDEN int
d1513 1
a1513 1
HIDDEN int
d1585 1
a1585 1
HIDDEN int
d1681 1
a1681 1
HIDDEN int
d1727 1
a1727 1
HIDDEN void
d1755 1
a1755 1
HIDDEN int
d1819 1
a1819 1
HIDDEN int
d1881 1
a1881 1
HIDDEN int
d2010 1
a2010 1
HIDDEN void
d2044 1
a2044 1
HIDDEN int
d2168 1
a2168 1
HIDDEN int
d2276 1
a2276 1
HIDDEN int
d2354 1
a2354 1
HIDDEN int
d2398 1
a2398 1
HIDDEN int
d2475 1
a2475 1
HIDDEN int
d2576 94
d2675 1
a2675 1
HIDDEN int
@


1.14
log
@
Changed calling sequence to wdb_trace()
@
text
@d94 6
a1182 3
	int			*pathpos;
	int			*flag;
	matp_t			old_xlate;
d1185 1
a1189 4
	pathpos = (int *)user_ptr1;
	old_xlate = (matp_t)user_ptr2;
	flag = (int *)user_ptr3;

d1191 1
a1191 1
		bn_mat_mul(new_xlate, old_xlate, comb_leaf->tr_l.tl_mat);
d1193 1
a1193 1
		bn_mat_copy(new_xlate, old_xlate);
d1198 2
a1199 1
	wdb_trace(curr_interp, dbip, nextdp, (*pathpos)+1, new_xlate, *flag);
d1246 6
a1251 1
		if (comb->tree)
d1253 2
a1254 1
					 (genptr_t)&pathpos, (genptr_t)old_xlate, (genptr_t)&flag);
@


1.13
log
@Added client_data pointer to db_functree() to eliminate use of
global variables.
@
text
@d1198 1
a1198 1
	wdb_trace(dbip, nextdp, (*pathpos)+1, new_xlate, *flag);
d1204 2
a1205 1
wdb_trace(dbip, dp, pathpos, old_xlate, flag)
d1227 1
a1227 1
		Tcl_AppendResult(curr_interp, bu_vls_addr(&tmp_vls), (char *)NULL);
d1231 1
a1231 1
			Tcl_AppendResult(curr_interp, "/", wdb_path[i]->d_namep, (char *)NULL);
d1233 1
a1233 1
		Tcl_AppendResult(curr_interp, "\n", (char *)NULL);
d1239 1
a1239 1
			Tcl_AppendResult(curr_interp, "Database read error, aborting\n", (char *)NULL);
d1274 1
a1274 1
		Tcl_AppendResult(curr_interp, "/", wdb_path[k]->d_namep, (char *)NULL);
d1278 1
a1278 1
		Tcl_AppendResult(curr_interp, bu_vls_addr(&str), (char *)NULL);
d1284 1
a1284 1
	Tcl_AppendResult(curr_interp, "/", (char *)NULL);
d1286 1
a1286 1
		Tcl_AppendResult(curr_interp, "rt_db_get_internal(", dp->d_namep,
d1292 1
a1292 1
		Tcl_AppendResult(curr_interp, dp->d_namep, ": describe error\n", (char *)NULL);
d1294 1
a1294 1
	Tcl_AppendResult(curr_interp, bu_vls_addr(&str), (char *)NULL);
d1373 1
a1373 1
	wdb_trace(wdbop->wdb_wp->dbip, wdb_objects[0], 0, bn_mat_identity, flag);
@


1.12
log
@*- add database object commands: g, rm, r
@
text
@d652 1
a652 1
	int				 id, status, i;
a686 1
	id = intern.idb_type;
d1704 3
a1706 1
		db_functree(wdbop->wdb_wp->dbip, dp, wdb_killtree_callback, wdb_killtree_callback);
d1716 1
a1716 1
wdb_killtree_callback(dbip, dp)
d1719 1
d1721 2
d1726 1
a1726 1
	Tcl_AppendResult(curr_interp, "KILL ", (dp->d_flags & DIR_COMB) ? "COMB" : "Solid",
d1730 1
a1730 1
	dgo_eraseobjall_callback(curr_interp, dbip, dp);
d1733 1
a1733 1
		Tcl_AppendResult(curr_interp,
@


1.11
log
@*- add database object commands: concat, dup
@
text
@d42 1
d87 3
d97 6
a102 5
HIDDEN int wdb_cmpdirname();
HIDDEN void wdb_vls_col_pr4v();
HIDDEN void wdb_vls_line_dpp();
HIDDEN struct directory ** wdb_getspace();
HIDDEN void wdb_do_list();
d113 6
d154 3
a166 1
	"g",		wdb_group_tcl,
a173 2
	"r",		wdb_region_tcl,
	"rm",		wdb_remove_tcl,
d1996 4
a1999 4
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		user_ptr1, user_ptr2, user_ptr3;
d2006 1
a2006 1
	  return;
d2016 2
a2017 2
		comb_leaf->tr_l.tl_name,
		RT_NAMESIZE-(*ncharadd) );
d2132 1
a2132 1
					  (genptr_t)&wdb_ncharadd, (genptr_t)wdb_prestr, (genptr_t)NULL);
d2223 5
a2227 5
register struct db_i	*input_dbip;
register char		*name;
long			laddr;
int			len;
int			flags;
d2334 226
d2603 1
a2603 1
HIDDEN void
d2670 1
a2670 1
HIDDEN void
d2725 1
a2725 1
HIDDEN struct directory **
d2782 169
@


1.10
log
@*- add database object commands: mv and mvall
@
text
@d84 2
d102 5
d141 2
a149 1
	"concat",	wdb_concat_tcl,
a151 1
	"dup",		wdb_dup_tcl,
d1980 340
@


1.9
log
@*- add database object command: cp
@
text
@d82 2
d132 2
a149 2
	"mv",		wdb_move_tcl,
	"mvall",	wdb_move_all_tcl,
d1505 1
a1505 1
	  struct bu_vls vls;
d1507 5
a1511 5
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "helplib wdb_kill");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
d1596 1
a1596 1
					") failure", (char *)NULL );
d1613 2
a1614 2
						dp->d_namep, "/", argv[k],
						"\n", (char *)NULL);
d1618 2
a1619 2
						dp->d_namep, "/", argv[k],
						"\n", (char *)NULL);
d1698 2
a1699 2
struct db_i	*dbip;
register struct directory *dp;
d1742 1
a1742 1
		bu_vls_printf(&vls, "helplib wdb_cp");
d1757 1
a1757 1
		Tcl_AppendResult(interp, "Database read error, aborting\n", (char *)NULL);\
d1765 1
a1765 1
				 (char *)NULL); \
d1771 1
a1771 1
		Tcl_AppendResult(interp, "Database write error, aborting\n", (char *)NULL);\
d1776 197
@


1.8
log
@*- add database object command: killall
@
text
@d81 1
d129 1
a137 1
	"cp",		wdb_copy_tcl,
d1713 62
@


1.7
log
@*- add database object command: killtree
@
text
@d78 1
d126 1
a144 1
	"killall",	wdb_killall_tcl,
d1548 96
d1666 1
a1666 1
	  struct bu_vls vls;
d1668 5
a1672 5
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "helplib wdb_killtree");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
d1686 2
d1698 2
a1699 2
  if (dbip == DBI_NULL)
    return;
d1701 2
a1702 2
  Tcl_AppendResult(curr_interp, "KILL ", (dp->d_flags & DIR_COMB) ? "COMB" : "Solid",
		   ":  ", dp->d_namep, "\n", (char *)NULL);
d1704 2
a1705 1
  dgo_eraseobjall_callback(curr_interp, dbip, dp);
d1707 5
a1711 5
  if (db_delete(dbip, dp) < 0 || db_dirdelete(dbip, dp) < 0) {
    Tcl_AppendResult(curr_interp,
		     "an error occurred while deleting ",
		     dp->d_namep, "\n", (char *)NULL);
  }
@


1.6
log
@*- add kill command to database object
@
text
@d78 2
d125 1
a143 1
	"killtree",	wdb_killtree_tcl,
d1530 1
a1530 1
			dgo_eraseobjall_callback(interp, wdbop, dp);
d1544 68
@


1.5
log
@*- create list of potential commands
@
text
@d55 3
d77 1
d122 1
a139 1
	"kill",		wdb_kill_tcl,
d1473 86
@


1.4
log
@*- add commands to database object: l, listeval, paths and expand
@
text
@d118 42
@


1.3
log
@
Removed dead vars
@
text
@d4 2
a5 2
 * A database object contains the attributes and
 * methods for controlling a BRLCAD database.
d7 1
a7 1
 * Authors -
d26 6
a34 1
#include "conf.h"
d45 5
d56 1
d71 3
a73 1
HIDDEN int wdb_close_tcl();
d78 3
d85 1
d89 14
d114 4
d119 1
a119 1
       (char *)0,	(int (*)())0
d124 1
a124 1
Tcl_Interp *interp;
d126 3
a128 3
  BU_LIST_INIT(&HeadWDBObj.l);
  (void)Tcl_CreateCommand(interp, "wdb_open", wdb_open_tcl,
			  (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
d130 1
a130 1
  return TCL_OK;
d144 4
a147 4
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d149 1
a149 1
  return bu_cmd(clientData, interp, argc, argv, wdb_cmds, 1);
d225 4
a228 4
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char		**argv;
d257 1
a257 1
		NULL);
d275 1
a275 1
			wdbp = wdb_dbopen( dbip, RT_WDB_TYPE_DB_DISK );
d281 1
a281 1
				wdbp = wdb_dbopen( dbip, RT_WDB_TYPE_DB_DISK );
d283 1
a283 1
				wdbp = wdb_dbopen( dbip, RT_WDB_TYPE_DB_DISK_APPEND_ONLY );
d285 1
a285 1
				wdbp = wdb_dbopen( dbip, RT_WDB_TYPE_DB_INMEM );
d287 1
a287 1
				wdbp = wdb_dbopen( dbip, RT_WDB_TYPE_DB_INMEM_APPEND_ONLY );
d317 1
a317 1
	Tcl_AppendResult( interp, argv[1], (char *)NULL );
d384 4
a387 4
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
d430 4
a433 4
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
d483 4
a486 4
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
d502 1
a502 1
 	               "wrong # args: should be db put objName objType attrs",
d523 1
a523 1
			  argv[2][i];
d575 4
a578 4
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
d592 1
a592 1
		"wrong # args: should be \"db adjust objName attr value ?attr? ?value?...\"",
d638 4
a641 4
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d657 1
a657 1
			argv[1], "\".", (char *)NULL);
d668 4
a671 4
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
d701 1
a701 1
ClientData clientData;
d729 4
a732 4
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
d746 3
a748 3
			"rt_gettrees: wrong # args: should be \"",
			argv[0], " ", argv[1],
			" newprocname [-i] [-u] treetops...\"\n", (char *)NULL );
d776 1
a776 1
			"rt_gettrees() returned error\n", (char *)NULL );
d826 4
a829 4
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
d841 2
a842 2
			"dump: wrong # args: should be \"",
			argv[0], "dump filename.g\n", (char *)NULL );
d848 2
a849 2
			argv[0], " dump:  ", argv[2], ": cannot create\n",
			(char *)NULL );
d856 2
a857 2
			argv[0], " dump ", argv[2], ": db_dump() error\n",
			(char *)NULL );
d872 21
a892 21
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
  struct bu_vls vls;

  bu_vls_init(&vls);

  if (argc != 2) {
    bu_vls_printf(&vls, "helplib wdb_dbip");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  bu_vls_printf(&vls, "%lu", (unsigned long)wdbop->wdb_wp->dbip);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);
  return TCL_OK;
a900 1
 * The guts of this routine were lifted from mged/dir.c.
d904 145
a1048 91
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
  struct bu_vls vls;
  register struct directory *dp;
  register int i;
  int c;
  int aflag = 0;		/* print all objects without formatting */
  int cflag = 0;		/* print combinations */
  int rflag = 0;		/* print regions */
  int sflag = 0;		/* print solids */
  struct directory **dirp;
  struct directory **dirp0 = (struct directory **)NULL;

  bu_vls_init(&vls);

  /* skip past procname */
  --argc;
  ++argv;

  if(argc < 1 || MAXARGS < argc){
    bu_vls_printf(&vls, "helplib wdb_ls");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  bu_optind = 1;	/* re-init bu_getopt() */
  while ((c = bu_getopt(argc, argv, "acgrs")) != EOF) {
    switch (c) {
    case 'a':
      aflag = 1;
      break;
    case 'c':
      cflag = 1;
      break;
    case 'r':
      rflag = 1;
      break;
    case 's':
      sflag = 1;
      break;
    default:
      bu_vls_printf(&vls, "Unrecognized option - %c\n", c);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
  }
  argc -= (bu_optind - 1);
  argv += (bu_optind - 1);

  /* create list of objects in database */
  if (argc > 1) {
    /* Just list specified names */
    dirp = wdb_getspace(wdbop->wdb_wp->dbip, argc-1);
    dirp0 = dirp;
    /*
     * Verify the names, and add pointers to them to the array.
     */
    for (i = 1; i < argc; i++) {
      if ((dp = db_lookup(wdbop->wdb_wp->dbip, argv[i], LOOKUP_NOISY)) ==
	  DIR_NULL)
	continue;
      *dirp++ = dp;
    }
  } else {
    /* Full table of contents */
    dirp = wdb_getspace(wdbop->wdb_wp->dbip, 0);	/* Enough for all */
    dirp0 = dirp;
    /*
     * Walk the directory list adding pointers (to the directory
     * entries) to the array.
     */
    for (i = 0; i < RT_DBNHASH; i++)
      for (dp = wdbop->wdb_wp->dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
	*dirp++ = dp;
  }

  if (aflag || cflag || rflag || sflag)
    wdb_vls_line_dpp(&vls, dirp0, (int)(dirp - dirp0),
		 aflag, cflag, rflag, sflag);
  else
    wdb_vls_col_pr4v(&vls, dirp0, (int)(dirp - dirp0));

  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);
  bu_free( (genptr_t)dirp0, "wdb_getspace dp[]" );
d1050 376
a1425 1
  return TCL_OK;
d1438 2
a1439 2
CONST genptr_t a;
CONST genptr_t b;
d1457 10
a1466 47
struct bu_vls *vls;
struct directory **list_of_names;
int num_in_list;
{
  int lines, i, j, namelen, this_one;

  qsort( (genptr_t)list_of_names,
	 (unsigned)num_in_list, (unsigned)sizeof(struct directory *),
	 (int (*)())wdb_cmpdirname);

  /*
   * For the number of (full and partial) lines that will be needed,
   * print in vertical format.
   */
  lines = (num_in_list + 3) / 4;
  for( i=0; i < lines; i++) {
    for( j=0; j < 4; j++) {
      this_one = j * lines + i;
      /* Restrict the print to 16 chars per spec. */
      bu_vls_printf(vls,  "%.16s", list_of_names[this_one]->d_namep);
      namelen = strlen( list_of_names[this_one]->d_namep);
      if( namelen > 16)
	namelen = 16;
      /*
       * Region and ident checks here....  Since the code
       * has been modified to push and sort on pointers,
       * the printing of the region and ident flags must
       * be delayed until now.  There is no way to make the
       * decision on where to place them before now.
       */
      if(list_of_names[this_one]->d_flags & DIR_COMB) {
	bu_vls_putc(vls, '/');
	namelen++;
      }
      if(list_of_names[this_one]->d_flags & DIR_REGION) {
	bu_vls_putc(vls, 'R');
	namelen++;
      }
      /*
       * Size check (partial lines), and line termination.
       * Note that this will catch the end of the lines
       * that are full too.
       */
      if( this_one + lines >= num_in_list) {
	bu_vls_putc(vls, '\n');
	break;
      } else {
d1468 2
a1469 2
	 * Pad to next boundary as there will be
	 * another entry to the right of this one. 
d1471 42
a1512 5
	while( namelen++ < 20)
	  bu_vls_putc(vls, ' ');
      }
    }
  }
d1524 42
a1565 42
struct bu_vls *vls;
struct directory **list_of_names;
int num_in_list;
int aflag;	/* print all objects */
int cflag;	/* print combinations */
int rflag;	/* print regions */
int sflag;	/* print solids */
{
  int i;
  int isComb, isRegion;
  int isSolid;

  qsort( (genptr_t)list_of_names,
	 (unsigned)num_in_list, (unsigned)sizeof(struct directory *),
	 (int (*)())wdb_cmpdirname);

  /*
   * i - tracks the list item
   */
  for (i=0; i < num_in_list; ++i) {
    if (list_of_names[i]->d_flags & DIR_COMB) {
      isComb = 1;
      isSolid = 0;

      if (list_of_names[i]->d_flags & DIR_REGION)
	isRegion = 1;
      else
	isRegion = 0;
    } else {
      isComb = isRegion = 0;
      isSolid = 1;
    }

    /* print list item i */
    if (aflag ||
	!cflag && !rflag && !sflag ||
	cflag && isComb ||
	rflag && isRegion ||
	sflag && isSolid) {
      bu_vls_printf(vls,  "%s ", list_of_names[i]->d_namep);
    }
  }
d1579 36
a1614 2
struct db_i *dbip;
register int num_entries;
d1616 18
a1633 22
  register struct directory *dp;
  register int i;
  register struct directory **dir_basep;

  if (num_entries < 0) {
    bu_log("wdb_getspace: was passed %d, used 0\n",
	   num_entries);
    num_entries = 0;
  }

  if (num_entries == 0) {
    /* Set num_entries to the number of entries */
    for (i = 0; i < RT_DBNHASH; i++)
      for (dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
	num_entries++;
  }

  /* Allocate and cast num_entries worth of pointers */
  dir_basep = (struct directory **) bu_malloc(
	      (num_entries+1) * sizeof(struct directory *),
	      "wdb_getspace *dir[]" );
  return(dir_basep);
@


1.2
log
@*- a little cleaning
@
text
@a196 1
	char		buf[32];
a311 2
		char line[128];

a704 1
	char		buf[64];
@


1.1
log
@*- methods and attributes for implementing database objects
@
text
@d45 1
a45 7
struct wdb_obj {
  struct bu_list	l;
  struct bu_vls		wdb_name;	/* database name */
  struct rt_wdb		*wdb_wp;
};

int wdb_open_tcl();
d70 1
a70 1
HIDDEN struct wdb_obj HeadWDBObj;	/* head of BRLCAD database object list */
d183 4
d188 1
a188 1
int
@

