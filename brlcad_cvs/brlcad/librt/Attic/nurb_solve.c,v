head	11.9;
access;
symbols
	ansi-20040405-merged:11.6.2.1
	postmerge-20040405-ansi:11.7
	premerge-20040404-ansi:11.6
	postmerge-autoconf:11.6
	autoconf-freeze:11.6
	premerge-autoconf:11.6
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.6
	premerge-20040315-windows:11.6
	windows-20040315-freeze:11.6
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.3
	offsite-5-3-pre:11.3
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.9
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.8;

11.8
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.7;

11.7
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.08.07;	author jra;	state Exp;
branches
	11.6.2.1;
next	11.5;

11.5
date	2002.08.15.20.55.20;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2001.04.20.22.29.55;	author morrison;	state Exp;
branches;
next	11.3;

11.3
date	99.06.03.01.39.15;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.07.10.20.15.50;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.53;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	10.4;

10.4
date	94.11.08.01.26.08;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.11.04.05.36.09;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.01.18.20;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.12;	author mike;	state Rel4_0;
branches;
next	1.4;

1.4
date	91.09.20.23.37.00;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.06.23.03.42.21;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.06.14.09.42.22;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	91.05.18.02.35.57;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.6.2.1
date	2002.09.19.18.01.45;	author morrison;	state Exp;
branches;
next	;


desc
@Solver
@


11.9
log
@moved to src/
@
text
@/* 
 * rt_nurb_solve.c - Decompose a matrix into its LU decomposition using pivoting.
 * 
 * Author:	Paul R. Stay
 * 		Computer Science Dept.
 * 		University of Utah
 * Date:	Wed Mar 23 1983
 * Copyright (c) 1983, University of Utah
 * 
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "nurb.h"	

/* These Procedures take a set of matrices of the form Ax = b and
 * alows one to solve the system by various means. The rt_nurb_doolittle
 * routine takes the system and creates a lu decomposition using
 * pivoting  to get the system in a desired form. Forward and backward
 * substitution are then used to solve the system.  All work is done
 * in place.
 */

/* Solve must be passed two matrices that are of the form of pointer
 * to double arrays. mat_1 is the n by n matrix that is to be
 * decomposed and mat_2 is the matrix that contains the left side of
 * the equation.  The variable solution which is double is also to be
 * created by the user and consisting of n elements of which the
 * solution set is passed back.
 *
 *  Arguments mat_1 and mat_2 are modified by this call.
 *  The solution is written into the solution[] array.
 */
void
rt_nurb_solve(fastf_t *mat_1, fastf_t *mat_2, fastf_t *solution, int dim, int coords)
       	       		/* A and b array of the system Ax= b*/
       	       
       	          
   	    		/* dimension of the matrix */
   	       		/* Number of coordsinates for mat_2 and solution */
{
	register int i, k;
	fastf_t *y;
	fastf_t * b;
	fastf_t * s;

	y = (fastf_t *) bu_malloc(sizeof (fastf_t) * dim,
	    "rt_nurb_solve: y");/* Create temp array */

	b = (fastf_t *) bu_malloc(sizeof (fastf_t) * dim,
	    "rt_nurb_solve: b");/* Create temp array */

	s = (fastf_t *) bu_malloc(sizeof (fastf_t) * dim,
	    "rt_nurb_solve: s");/* Create temp array */

	rt_nurb_doolittle (mat_1,mat_2, dim, coords);/* Create LU decomosition */

	for( k =0; k < coords; k++)
	{
		fastf_t * ptr;

		ptr = mat_2 + k;

		for( i = 0; i < dim; i++)
		{
			b[i] = *ptr;
			ptr += coords;
		}

		/* Solve the system Ly =b */
		rt_nurb_forw_solve (mat_1, b, y, dim);

		/* Solve the system Ux = y */
		rt_nurb_back_solve (mat_1, y, s, dim);
		

		ptr = solution + k;
		for( i=0; i < dim; i++)
		{
			*ptr = s[i];
			ptr += coords;
		}
	}

	bu_free ((char *)y,"rt_nurb_solve: y");			/* Free up storage */
	bu_free ((char *)b,"rt_nurb_solve: b");			/* Free up storage */
	bu_free ((char *)s,"rt_nurb_solve: s");			/* Free up storage */
}

/*
 *  Create LU decomosition.
 *  Modifies both mat_1 and mat_2 values.
 */
void
rt_nurb_doolittle(fastf_t *mat_1, fastf_t *mat_2, int row, int coords)
{
	register int i;
	register int j;
	register int k;
	register int x;
	int m;
	register fastf_t *d;		/* Scaling factors */
	register fastf_t *s;		/* vector for swapping if needed */
	register fastf_t *ds;		/* See if swapping is needed */
	fastf_t  maxd;
	fastf_t tmp;

	int     max_pivot;

	d = (fastf_t * ) bu_malloc( sizeof (fastf_t) * row,
	    "rt_nurb_doolittle:d");	/* scale factor */
	s = (fastf_t * ) bu_malloc( sizeof (fastf_t) * row * row,
	    "rt_nurb_doolittle:s");	/* vector to check */
	ds = (fastf_t *) bu_malloc( sizeof (fastf_t) * row,
	    "rt_nurb_doolittle:ds");	/* if rows need to be swaped */

	for ( i = 0; i < row; i++)		/* calculate the scaling factors */
	{
		maxd = 0.0;
		for( j = 0; j < row; j++)
		{
			if( maxd < fabs(mat_1[i * row + j]) )
				maxd = fabs(mat_1[i * row + j]);
		}
		d[i] = 1.0 / maxd;
	}

	for ( k = 0 ; k < row; k++)
	{
		for( i = k; i < row; i++)
		{
			tmp = 0.0;
			for( j = 0; j <= k -1; j ++)
				tmp += mat_1[i * row + j ] * mat_1[j * row + k];
			s[i * row + k] = mat_1[i * row + k] - tmp;
		}

		max_pivot = k;

		for (i = k; i < row; i ++)	/* check to see if rows need */
		{				/* to be swaped */
			ds[i] = d[i] * s[ i * row + k];
			if (ds[max_pivot] < ds[i])
				max_pivot = i;
		}

		if (max_pivot != k )		/* yes swap row k with row max_pivot */
		{
			for( m = 0; m < row; m++)
			{
				tmp = mat_1[k * row + m];
				mat_1[k * row + m] = mat_1[max_pivot * row + m];
				mat_1[max_pivot * row + m] = tmp;
			}

			for( x = 0; x < coords; x++)
			{
				tmp = mat_2[k*coords + x];		/* b matrix also */
				mat_2[k*coords+x] = mat_2[max_pivot*coords+x];
				mat_2[max_pivot*coords+x] = tmp;
			}

			tmp = s[k * row + k];	/* swap s vector  */
			s[k * row + k] = s[max_pivot * row + k];
			s[max_pivot * row + k] = tmp;
		}

		mat_1[ k * row +  k] = s[k * row + k];	/* mat_1[k][k] */

		for (i = k + 1; i < row; i++)	/* lower matrix */
			mat_1[i * row + k] = (float)(s[i* row + k] / s[k* row +k]);

		for (j = k + 1; j < row; j++) {	/* upper matrix */
			tmp = 0;
			for( i = 0; i <= k - 1; i++)
				tmp += mat_1[ k * row + i] * mat_1[ i* row + j];

			mat_1[ k * row + j] -= tmp;
		}

	}
	bu_free( (char *)d,"rt_nurb_doolittle:d");		/* Free up the storage. */
	bu_free( (char *)s,"rt_nurb_doolittle:s");
	bu_free( (char *)ds,"rt_nurb_doolittle:ds" );
}

void
rt_nurb_forw_solve(const fastf_t *lu, const fastf_t *b, fastf_t *y, int n)		/* spl_solve lower trianglular matrix */
                  
                 
           
      
{
	register int i,j;
	fastf_t tmp;

	for(i = 0; i < n; i++)
	{
		tmp = 0.0;
		for(j = 0; j <= i - 1; j++)
			tmp += lu[i*n + j] * y[j];
		y[i] = b[i] - tmp;
	}
}

void
rt_nurb_back_solve(const fastf_t *lu, const fastf_t *y, fastf_t *x, int n)		/* spl_solve upper triangular matrix */
                  
                 
           
      
{
	register int i,j;
	fastf_t tmp;

	for( i = n - 1; i >= 0; i-- )
	{
		tmp = 0.0;
		for( j = i + 1; j < n; j++)
			tmp += lu[i*n + j] * x[j];
		x[i] = ( y[i] - tmp) / lu[i * n + i];
	}

}

void
rt_nurb_p_mat(const fastf_t *mat, int dim)
{
	int i;
	
	for( i = 0; i < dim; i++)
		fprintf(stderr,"%f\n", mat[i]);
	fprintf(stderr,"\n");
}
@


11.8
log
@change conf.h to a wrapped config.h
@
text
@@


11.7
log
@merge of ansi-6-0-branch into HEAD
@
text
@d12 5
a16 1
#include "conf.h"
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d40 6
a45 6
rt_nurb_solve(mat_1, mat_2, solution, dim, coords)
fastf_t	*mat_1;		/* A and b array of the system Ax= b*/
fastf_t	*mat_2;
fastf_t	*solution;
int	dim;		/* dimension of the matrix */
int	coords;		/* Number of coordsinates for mat_2 and solution */
d100 1
a100 4
rt_nurb_doolittle(mat_1, mat_2,row, coords )
fastf_t *mat_1, *mat_2;
int row;
int coords;
d193 5
a197 5
rt_nurb_forw_solve(lu, b, y, n)		/* spl_solve lower trianglular matrix */
const fastf_t *lu;
const fastf_t *b;
fastf_t *y;
int n;
d212 5
a216 5
rt_nurb_back_solve( lu, y, x, n)		/* spl_solve upper triangular matrix */
const fastf_t *lu;
const fastf_t *y;
fastf_t *x;
int n;
d232 1
a232 3
rt_nurb_p_mat(mat, dim)
const fastf_t * mat;
int dim;
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d40 6
a45 6
rt_nurb_solve(fastf_t *mat_1, fastf_t *mat_2, fastf_t *solution, int dim, int coords)
       	       		/* A and b array of the system Ax= b*/
       	       
       	          
   	    		/* dimension of the matrix */
   	       		/* Number of coordsinates for mat_2 and solution */
d100 4
a103 1
rt_nurb_doolittle(fastf_t *mat_1, fastf_t *mat_2, int row, int coords)
d196 5
a200 5
rt_nurb_forw_solve(const fastf_t *lu, const fastf_t *b, fastf_t *y, int n)		/* spl_solve lower trianglular matrix */
                  
                 
           
      
d215 5
a219 5
rt_nurb_back_solve(const fastf_t *lu, const fastf_t *y, fastf_t *x, int n)		/* spl_solve upper triangular matrix */
                  
                 
           
      
d235 3
a237 1
rt_nurb_p_mat(const fastf_t *mat, int dim)
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d40 6
a45 6
rt_nurb_solve(fastf_t *mat_1, fastf_t *mat_2, fastf_t *solution, int dim, int coords)
       	       		/* A and b array of the system Ax= b*/
       	       
       	          
   	    		/* dimension of the matrix */
   	       		/* Number of coordsinates for mat_2 and solution */
d100 4
a103 1
rt_nurb_doolittle(fastf_t *mat_1, fastf_t *mat_2, int row, int coords)
d196 5
a200 5
rt_nurb_forw_solve(const fastf_t *lu, const fastf_t *b, fastf_t *y, int n)		/* spl_solve lower trianglular matrix */
                  
                 
           
      
d215 5
a219 5
rt_nurb_back_solve(const fastf_t *lu, const fastf_t *y, fastf_t *x, int n)		/* spl_solve upper triangular matrix */
                  
                 
           
      
d235 3
a237 1
rt_nurb_p_mat(const fastf_t *mat, int dim)
@


11.4
log
@CONST to const
@
text
@d40 6
a45 6
rt_nurb_solve(mat_1, mat_2, solution, dim, coords)
fastf_t	*mat_1;		/* A and b array of the system Ax= b*/
fastf_t	*mat_2;
fastf_t	*solution;
int	dim;		/* dimension of the matrix */
int	coords;		/* Number of coordsinates for mat_2 and solution */
d100 1
a100 4
rt_nurb_doolittle(mat_1, mat_2,row, coords )
fastf_t *mat_1, *mat_2;
int row;
int coords;
d193 5
a197 5
rt_nurb_forw_solve(lu, b, y, n)		/* spl_solve lower trianglular matrix */
const fastf_t *lu;
const fastf_t *b;
fastf_t *y;
int n;
d212 5
a216 5
rt_nurb_back_solve( lu, y, x, n)		/* spl_solve upper triangular matrix */
const fastf_t *lu;
const fastf_t *y;
fastf_t *x;
int n;
d232 1
a232 3
rt_nurb_p_mat(mat, dim)
const fastf_t * mat;
int dim;
@


11.3
log
@
sed4
@
text
@d197 2
a198 2
CONST fastf_t *lu;
CONST fastf_t *b;
d216 2
a217 2
CONST fastf_t *lu;
CONST fastf_t *y;
d236 1
a236 1
CONST fastf_t * mat;
@


11.2
log
@Fixed declaration problems for IRIX 6.2
@
text
@d52 1
a52 1
	y = (fastf_t *) rt_malloc(sizeof (fastf_t) * dim,
d55 1
a55 1
	b = (fastf_t *) rt_malloc(sizeof (fastf_t) * dim,
d58 1
a58 1
	s = (fastf_t *) rt_malloc(sizeof (fastf_t) * dim,
d90 3
a92 3
	rt_free ((char *)y,"rt_nurb_solve: y");			/* Free up storage */
	rt_free ((char *)b,"rt_nurb_solve: b");			/* Free up storage */
	rt_free ((char *)s,"rt_nurb_solve: s");			/* Free up storage */
d118 1
a118 1
	d = (fastf_t * ) rt_malloc( sizeof (fastf_t) * row,
d120 1
a120 1
	s = (fastf_t * ) rt_malloc( sizeof (fastf_t) * row * row,
d122 1
a122 1
	ds = (fastf_t *) rt_malloc( sizeof (fastf_t) * row,
d190 3
a192 3
	rt_free( (char *)d,"rt_nurb_doolittle:d");		/* Free up the storage. */
	rt_free( (char *)s,"rt_nurb_doolittle:s");
	rt_free( (char *)ds,"rt_nurb_doolittle:ds" );
@


11.1
log
@Release_4.4
@
text
@d234 1
@


11.1.1.1
log
@Release_4.5
@
text
@a233 1
void
@


10.4
log
@Added CONST where appropriate.
Added some comments too.
@
text
@@


10.3
log
@Irix 6
@
text
@d22 2
a23 2
 * alows one to rt_nurb_solve the system by various means. The rt_nurb_doolittle
 * routine take the system and creates a lu decomposition using
d25 1
a25 1
 * substitution are then used to spl_solve the system.  All work is done
d35 3
d41 5
a45 3
fastf_t *mat_1, *mat_2, *solution;	/* A and b array of the system Ax= b*/
int dim;				/* dimension of the matrix */
int coords;		/* Number of coordsinates for mat_2 and solution */
d95 4
d197 3
a199 1
fastf_t *lu, *b, *y;
d216 3
a218 1
fastf_t *lu, *y, *x;
d235 1
a235 1
fastf_t * mat;
@


10.2
log
@Added includes
@
text
@a105 1
	fastf_t * ptr;
@


10.1
log
@Release_4.0
@
text
@d11 3
d18 1
@


1.4
log
@math.h
@
text
@@


1.3
log
@minor lint
@
text
@d12 1
@


1.2
log
@fixed nurb.h
@
text
@a15 4
void	rt_nurb_doolittle();
void	rt_nurb_forw_solve();
void	rt_nurb_back_solve();

@


1.1
log
@Initial revision
@
text
@d14 1
a14 1
#include "./nurb.h"	
@
