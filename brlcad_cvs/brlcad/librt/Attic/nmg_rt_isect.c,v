head	11.54;
access;
symbols
	ansi-20040405-merged:11.50.2.2
	postmerge-20040405-ansi:11.52
	premerge-20040404-ansi:11.51
	postmerge-autoconf:11.51
	autoconf-freeze:11.50.10.2
	premerge-autoconf:11.51
	ansi-20040316-freeze:11.50.2.1
	postmerge-20040315-windows:11.51
	premerge-20040315-windows:11.51
	windows-20040315-freeze:11.50.4.1
	autoconf-20031203:11.50
	autoconf-20031202:11.50
	autoconf-branch:11.50.0.10
	phong-branch:11.50.0.8
	photonmap-branch:11.50.0.6
	rel-6-1-DP:11.50
	windows-branch:11.50.0.4
	rel-6-0-2:11.48
	ansi-branch:11.50.0.2
	rel-6-0-1-branch:11.48.0.2
	hartley-6-0-post:11.49
	hartley-6-0-pre:11.48
	rel-6-0-1:11.48
	rel-6-0:11.48
	rel-5-4:11.42.2.2
	offsite-5-3-pre:11.47
	rel-5-3:11.42.2.2
	rel-5-2:11.42
	rel-5-1-branch:11.42.0.2
	rel-5-1:11.42
	rel-5-0:11.38
	rel-5-0-beta:11.37
	rel-4-5:11.35
	ctj-4-5-post:11.31
	ctj-4-5-pre:11.31
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.54
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.53;

11.53
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.52;

11.52
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.51;

11.51
date	2004.02.02.17.39.25;	author morrison;	state Exp;
branches;
next	11.50;

11.50
date	2002.08.20.17.08.06;	author jra;	state Exp;
branches
	11.50.2.1
	11.50.4.1
	11.50.10.1;
next	11.49;

11.49
date	2002.08.15.20.55.18;	author hartley;	state Exp;
branches;
next	11.48;

11.48
date	2001.04.20.22.29.53;	author morrison;	state Exp;
branches;
next	11.47;

11.47
date	2000.11.14.21.13.21;	author jra;	state Exp;
branches;
next	11.46;

11.46
date	2000.10.18.18.10.35;	author butler;	state Exp;
branches;
next	11.45;

11.45
date	2000.08.29.03.38.25;	author butler;	state Exp;
branches;
next	11.44;

11.44
date	2000.08.21.02.02.33;	author butler;	state Exp;
branches;
next	11.43;

11.43
date	2000.07.10.23.01.45;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	2000.04.12.00.57.42;	author mike;	state Exp;
branches
	11.42.2.1;
next	11.41;

11.41
date	2000.03.28.20.41.04;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	99.12.30.15.39.53;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	99.12.18.00.43.40;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	99.06.03.01.43.37;	author mike;	state Exp;
branches;
next	11.37;

11.37
date	99.05.11.19.11.59;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	98.02.23.16.27.47;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	97.10.06.21.35.36;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	97.09.23.21.02.46;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	97.09.09.14.15.57;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	97.06.13.21.42.51;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	97.01.14.13.37.31;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	97.01.14.13.24.54;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	97.01.09.17.10.58;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	97.01.09.16.15.46;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	97.01.07.22.59.11;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	97.01.07.16.08.21;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	96.12.26.20.52.11;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	96.12.26.20.38.23;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	96.07.12.12.17.41;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	96.05.16.21.51.04;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	96.04.30.20.28.02;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	96.03.28.14.29.44;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	96.03.25.20.43.45;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	96.03.17.23.54.51;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	96.03.12.18.04.45;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	96.03.08.19.50.11;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	96.03.05.21.45.01;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	96.02.19.05.06.37;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	95.06.17.02.59.18;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	95.06.17.02.45.56;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	95.03.01.07.48.21;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	95.02.21.11.16.45;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	95.02.18.00.23.44;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	95.02.17.11.41.34;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	95.02.15.01.47.27;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.02.15.00.18.37;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.01.20.18.42.02;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.09.19.58.18;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.15;	author mike;	state Rel4_4;
branches;
next	1.33;

1.33
date	94.12.20.15.12.35;	author jra;	state Exp;
branches;
next	1.32;

1.32
date	94.12.05.19.00.18;	author butler;	state Exp;
branches;
next	1.31;

1.31
date	94.11.30.08.43.00;	author jra;	state Exp;
branches;
next	1.30;

1.30
date	94.11.30.03.59.25;	author butler;	state Exp;
branches;
next	1.29;

1.29
date	94.11.08.03.33.15;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	94.10.11.19.46.43;	author butler;	state Exp;
branches;
next	1.27;

1.27
date	94.09.21.03.37.46;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	94.09.02.00.14.25;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	94.09.01.23.34.40;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	94.08.24.22.48.51;	author butler;	state Exp;
branches;
next	1.23;

1.23
date	94.08.22.14.52.46;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	94.08.20.05.32.47;	author butler;	state Exp;
branches;
next	1.21;

1.21
date	94.08.20.05.28.14;	author butler;	state Exp;
branches;
next	1.20;

1.20
date	94.08.10.20.29.34;	author gdurf;	state Exp;
branches;
next	1.19;

1.19
date	94.07.01.01.38.34;	author butler;	state Exp;
branches;
next	1.18;

1.18
date	94.06.24.17.33.54;	author butler;	state Exp;
branches;
next	1.17;

1.17
date	94.06.24.00.05.19;	author butler;	state Exp;
branches;
next	1.16;

1.16
date	94.06.22.17.20.46;	author butler;	state Exp;
branches;
next	1.15;

1.15
date	94.06.22.03.09.09;	author butler;	state Exp;
branches;
next	1.14;

1.14
date	94.06.21.18.40.34;	author butler;	state Exp;
branches;
next	1.13;

1.13
date	94.06.15.23.42.17;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	94.06.06.22.12.54;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	94.05.24.16.02.01;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	93.12.27.22.45.40;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	93.12.03.03.35.47;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	93.12.02.20.58.53;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	93.10.01.20.18.08;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	93.10.01.20.15.33;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	93.09.02.16.17.19;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	93.09.01.20.22.30;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	93.09.01.01.26.54;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	93.07.23.15.56.10;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	93.06.04.17.08.11;	author butler;	state Exp;
branches;
next	;

11.42.2.1
date	2000.11.14.21.20.10;	author jra;	state Exp;
branches;
next	11.42.2.2;

11.42.2.2
date	2000.11.14.21.35.29;	author jra;	state Exp;
branches;
next	;

11.50.2.1
date	2002.09.19.18.01.41;	author morrison;	state Exp;
branches;
next	11.50.2.2;

11.50.2.2
date	2004.03.17.21.18.54;	author morrison;	state Exp;
branches;
next	;

11.50.4.1
date	2004.03.11.23.43.43;	author morrison;	state Exp;
branches;
next	;

11.50.10.1
date	2004.02.12.18.37.45;	author erikg;	state Exp;
branches;
next	11.50.10.2;

11.50.10.2
date	2004.03.15.14.07.28;	author erikg;	state Exp;
branches;
next	;


desc
@Code to intersect ray with NMG and build list of hit points
@


11.54
log
@moved to src/
@
text
@/*
 *			N M G _ R T _ I S E C T . C
 *
 *	Support routines for raytracing an NMG.
 *
 *  Author -
 *	Lee A. Butler
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_rt_isect.c,v 11.53 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "plot3.h"

static void 	vertex_neighborhood RT_ARGS((struct ray_data *rd, struct vertexuse *vu_p, struct hitmiss *myhit));

const char *
nmg_rt_inout_str(int code)
{
	switch(code) {
	case HMG_HIT_IN_IN:
		return("IN_IN");
	case HMG_HIT_IN_OUT:
		return("IN_OUT");
	case HMG_HIT_OUT_IN:
		return("OUT_IN");
	case HMG_HIT_OUT_OUT:
		return("OUT_OUT");
	case HMG_HIT_IN_ON:
		return("IN_ON");
	case HMG_HIT_ON_IN:
		return("ON_IN");
	case HMG_HIT_OUT_ON:
		return("OUT_ON");
	case HMG_HIT_ON_OUT:
		return("ON_OUT");
	case HMG_HIT_ANY_ANY:
		return("ANY_ANY");
	}
	return("?_?\n");
}

const char *
nmg_rt_state_str(int code)
{
	switch(code) {
	case NMG_RAY_STATE_INSIDE:
		return "RS_INSIDE";
	case NMG_RAY_STATE_ON:
		return "RS_ON";
	case NMG_RAY_STATE_OUTSIDE:
		return "RS_OUTSIDE";
	case NMG_RAY_STATE_ANY:
		return "RS_ANY";
	}
	return "RS_UNKNOWN";
}

/*
 *				N M G _ C K _ H I T M I S S _ L I S T
 *
 *  Ensure that the ray makes a valid set of state transitions.
 */
void
nmg_ck_hitmiss_list(const struct bu_list *hd)
{
	struct hitmiss	*hmp;
	int		state = NMG_RAY_STATE_OUTSIDE;
	int		istate;
	int		ostate;

	for( BU_LIST_FOR( hmp, hitmiss, hd ) )  {
#ifndef FAST_NMG
		NMG_CK_HITMISS(hmp);	
#endif
		/* Skip hits on non-3-manifolds */
		if( hmp->in_out == HMG_HIT_ANY_ANY )  continue;

		istate = HMG_INBOUND_STATE(hmp);
		ostate = HMG_OUTBOUND_STATE(hmp);
		if( state != istate )  {
			bu_log("ray state was=%s, transition=%s (istate=%s)\n",
				nmg_rt_state_str(state),
				nmg_rt_inout_str(hmp->in_out),
				nmg_rt_state_str(istate) );
			rt_bomb("nmg_ck_hitmiss_list() NMG ray-tracer bad in/out state transition\n");
		}
		state = ostate;
	}
	if( state != NMG_RAY_STATE_OUTSIDE )  {
		bu_log("ray ending state was %s, should have been RS_OUT\n", nmg_rt_state_str(state));
		rt_bomb("nmg_ck_hitmiss_list() NMG ray-tracer bad ending state\n");
	}
}

/* Plot a faceuse and a line between pt and plane_pt */
static int plot_file_number=0;

static void
nmg_rt_isect_plfu(struct faceuse *fu, fastf_t *pt, fastf_t *plane_pt)
{
	FILE *fd;
	char name[25];
	long *b;

	NMG_CK_FACEUSE(fu);
	
	sprintf(name, "ray%02d.pl", plot_file_number++);
	if ((fd=fopen(name, "w")) == (FILE *)NULL) {
		perror(name);
		abort();
	}

	bu_log("overlay %s\n", name);
	b = (long *)bu_calloc( fu->s_p->r_p->m_p->maxindex,
		sizeof(long), "bit vec"),

	pl_erase(fd);
	pd_3space(fd,
		fu->f_p->min_pt[0]-1.0,
		fu->f_p->min_pt[1]-1.0,
		fu->f_p->min_pt[2]-1.0,
		fu->f_p->max_pt[0]+1.0,
		fu->f_p->max_pt[1]+1.0,
		fu->f_p->max_pt[2]+1.0);
	
	nmg_pl_fu(fd, fu, b, 255, 255, 255);

	pl_color(fd, 255, 50, 50);
	pdv_3line(fd, pt, plane_pt);

	bu_free((char *)b, "bit vec");
	fclose(fd);
}

static void
pleu(struct edgeuse *eu, fastf_t *pt, fastf_t *plane_pt)
{
        FILE *fd;
        char name[25];
	long *b;
	point_t min_pt, max_pt;
	int i;
	struct model *m;
        
        sprintf(name, "ray%02d.pl", plot_file_number++);
        if ((fd=fopen(name, "w")) == (FILE *)NULL) {
        	perror(name);
        	abort();
        }

	bu_log("overlay %s\n", name);
	m = nmg_find_model( eu->up.magic_p );
	b = (long *)bu_calloc( m->maxindex, sizeof(long), "bit vec");

	pl_erase(fd);

	VMOVE(min_pt, eu->vu_p->v_p->vg_p->coord);
	
	for (i=0 ; i < 3 ; i++) {
		if (eu->eumate_p->vu_p->v_p->vg_p->coord[i] < min_pt[i]) {
			max_pt[i] = min_pt[i];
			min_pt[i] = eu->eumate_p->vu_p->v_p->vg_p->coord[i];
		} else {
			max_pt[i] = eu->eumate_p->vu_p->v_p->vg_p->coord[i];
		}
	}
	pd_3space(fd,
		min_pt[0]-1.0, min_pt[1]-1.0, min_pt[2]-1.0,
		max_pt[0]+1.0, max_pt[1]+1.0, max_pt[2]+1.0);

	nmg_pl_eu(fd, eu, b, 255, 255, 255);
	pl_color(fd, 255, 50, 50);
	pdv_3line(fd, pt, plane_pt);
	bu_free((char *)b, "bit vec");
	fclose(fd);
}
static void
plvu(struct vertexuse *vu)
{
}

void
nmg_rt_print_hitmiss(struct hitmiss *a_hit)
{
	NMG_CK_HITMISS(a_hit);
	bu_log("   dist:%12g pt=(%f %f %f) %s=x%x\n",
		a_hit->hit.hit_dist,
		a_hit->hit.hit_point[0],
		a_hit->hit.hit_point[1],
		a_hit->hit.hit_point[2],
		bu_identify_magic(*(long *)a_hit->hit.hit_private),
		a_hit->hit.hit_private
	);
	bu_log("\tstate:%s", nmg_rt_inout_str(a_hit->in_out));

	switch (a_hit->start_stop) {
	case NMG_HITMISS_SEG_IN:	bu_log(" SEG_START"); break;
	case NMG_HITMISS_SEG_OUT:	bu_log(" SEG_STOP"); break;
	}

	VPRINT("\n\tin_normal", a_hit->inbound_norm);
	VPRINT("\tout_normal", a_hit->outbound_norm);
}
void
nmg_rt_print_hitlist(struct hitmiss *hl)
{
	struct hitmiss *a_hit;

	bu_log("nmg/ray hit list:\n");

	for (BU_LIST_FOR(a_hit, hitmiss, &(hl->l))) {
		nmg_rt_print_hitmiss(a_hit);
	}
}




/*
 *	H I T _ I N S
 *
 *	insert the new hit point in the correct place in the list of hits
 *	so that the list is always in sorted order
 */
static void
hit_ins(struct ray_data *rd, struct hitmiss *newhit)
{
	struct hitmiss *a_hit;

	BU_LIST_MAGIC_SET(&newhit->l, NMG_RT_HIT_MAGIC);
	newhit->hit.hit_magic = RT_HIT_MAGIC;

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		bu_log("hit_ins()\n  inserting:");
		nmg_rt_print_hitmiss(newhit);
	}

	for (BU_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)) {
		if (newhit->hit.hit_dist < a_hit->hit.hit_dist)
			break;
	}

	/* a_hit now points to the item before which we should insert this
	 * hit in the hit list.
	 */

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		if (BU_LIST_NOT_HEAD(a_hit, &rd->rd_hit)) {
			bu_log("   prior to:");
			nmg_rt_print_hitmiss(a_hit);
		} else {
			bu_log("\tat end of list\n");
		}
	}

	BU_LIST_INSERT(&a_hit->l, &newhit->l);

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		nmg_rt_print_hitlist((struct hitmiss *)&rd->rd_hit);

}


/*
 *  The ray missed this vertex.  Build the appropriate miss structure.
 */
static struct hitmiss *
ray_miss_vertex(struct ray_data *rd, struct vertexuse *vu_p)
{
	struct hitmiss *myhit;

	NMG_CK_VERTEXUSE(vu_p);
	NMG_CK_VERTEX(vu_p->v_p);
	NMG_CK_VERTEX_G(vu_p->v_p->vg_p);

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		bu_log("ray_miss_vertex(%g %g %g)\n",
			vu_p->v_p->vg_p->coord[0],
			vu_p->v_p->vg_p->coord[1],
			vu_p->v_p->vg_p->coord[2]);
	}

	if ( (myhit=NMG_INDEX_GET(rd->hitmiss, vu_p->v_p)) ) {
		/* vertex previously processed */
		if (BU_LIST_MAGIC_OK((struct bu_list *)myhit, NMG_RT_HIT_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("ray_miss_vertex( vertex previously HIT!!!! )\n");
		} else if (BU_LIST_MAGIC_OK((struct bu_list *)myhit, NMG_RT_HIT_SUB_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("ray_miss_vertex( vertex previously HIT_SUB!?!? )\n");
		}
		return(myhit);
	}
	if ( (myhit=NMG_INDEX_GET(rd->hitmiss, vu_p->v_p)) ) {
		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			bu_log("ray_miss_vertex( vertex previously missed )\n");
		return(myhit);
	}

	GET_HITMISS(myhit, rd->ap);
	NMG_INDEX_ASSIGN(rd->hitmiss, vu_p->v_p, myhit);
	myhit->outbound_use = (long *)vu_p;
	myhit->inbound_use = (long *)vu_p;
	myhit->hit.hit_private = (genptr_t)vu_p->v_p;

	/* get build_vertex_miss() to compute this */
	myhit->dist_in_plane = -1.0;

	/* add myhit to the list of misses */
	BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
	BU_LIST_INSERT(&rd->rd_miss, &myhit->l);
#ifndef FAST_NMG
	NMG_CK_HITMISS(myhit);
	NMG_CK_HITMISS_LISTS(myhit, rd);
#endif
 	return myhit;
}

/*
 * Support routine for vertex_neighborhood()
 *
 */
static void
get_pole_dist_to_face(struct ray_data *rd, struct vertexuse *vu, fastf_t *Pole, fastf_t *Pole_prj_pt, double *Pole_dist, fastf_t *Pole_pca, fastf_t *pointA, fastf_t *leftA, fastf_t *pointB, fastf_t *leftB, fastf_t *polar_height_vect, char *Pole_name)
{
	vect_t pca_to_pole_vect;
	vect_t VtoPole_prj;
	point_t pcaA, pcaB;
	double distA, distB;
	int code, status;

/* find the points of closest approach
 *  There are six distinct return values from bn_dist_pt3_lseg3():
 *
 *    Value	Condition
 *    	-----------------------------------------------------------------
 *	0	P is within tolerance of lseg AB.  *dist isn't 0: (SPECIAL!!!)
 *		  *dist = parametric dist = |PCA-A| / |B-A|.  pca=computed.
 *	1	P is within tolerance of point A.  *dist = 0, pca=A.
 *	2	P is within tolerance of point B.  *dist = 0, pca=B.
 *
 *	3	P is to the "left" of point A.  *dist=|P-A|, pca=A.
 *	4	P is to the "right" of point B.  *dist=|P-B|, pca=B.
 *	5	P is "above/below" lseg AB.  *dist=|PCA-P|, pca=computed.
 */
	code = bn_dist_pt3_lseg3( &distA, pcaA, vu->v_p->vg_p->coord, pointA,
			Pole_prj_pt, rd->tol );
	if (code < 3) {
		/* Point is on line */
		*Pole_dist = MAGNITUDE(polar_height_vect);
		VMOVE(Pole_pca, Pole_prj_pt);
		return;
	}

	status = code << 4;
	code = bn_dist_pt3_lseg3( &distB, pcaB, vu->v_p->vg_p->coord, pointB,
			Pole_prj_pt, rd->tol );
	if (code < 3) {
		/* Point is on line */
		*Pole_dist = MAGNITUDE(polar_height_vect);
		VMOVE(Pole_pca, Pole_prj_pt);
		return;
	}

	status |= code;

	/*	  Status
	 *	codeA CodeB
	 *	 3	3	Do the Tanenbaum patch thing
	 *	 3	4	This should not happen.
	 *	 3	5	compute dist from pole to pcaB
	 *	 4	3	This should not happen.
	 *	 4	4	This should not happen.
	 *	 4	5	This should not happen.
	 *	 5	3	compute dist from pole to pcaA
	 *	 5	4	This should not happen.
	 *	 5	5	pick the edge with smallest "dist"
	 *	 		and compute pole-pca distance.
	 */
   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("get_pole_dist_to_face(%s) status from dist_pt_lseg == 0x%02x\n", Pole_name, status);

	switch (status) {
	case 0x35: /* compute dist from pole to pcaB */

		/* if plane point is "inside" edge B, plane point is PCA */
		VSUB2(VtoPole_prj, Pole_prj_pt, vu->v_p->vg_p->coord);
		if (VDOT(leftB, VtoPole_prj) >= 0.0) {
			/* plane point is "inside" edge B */
		   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("\tplane point inside face\n");
			VMOVE(Pole_pca, Pole_prj_pt);
			VSUB2(pca_to_pole_vect, Pole_prj_pt, Pole);
			*Pole_dist = MAGNITUDE(pca_to_pole_vect);
			return;
		}

	   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("\tplane point outside face\n");
		VSUB2(pca_to_pole_vect, pcaB, Pole);
		VMOVE(Pole_pca, pcaB);
		break;
	case 0x53: /* compute dist from pole to pcaA */

		/* if plane point is "inside" edge A, plane point is PCA */
		VSUB2(VtoPole_prj, Pole_prj_pt, vu->v_p->vg_p->coord);
		if (VDOT(leftA, VtoPole_prj) >= 0.0) {
			/* plane point is "inside" edge A */
		   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("\tplane point inside face\n");
			VMOVE(Pole_pca, Pole_prj_pt);
			VSUB2(pca_to_pole_vect, Pole_prj_pt, Pole);
			*Pole_dist = MAGNITUDE(pca_to_pole_vect);
			return;
		}

	   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("\tplane point outside face\n");
		VSUB2(pca_to_pole_vect, pcaA, Pole);
		VMOVE(Pole_pca, pcaA);
		break;
	case 0x55:/* pick the edge with smallest "dist"
		   * and compute pole-pca distance.
		   */
		VSUB2(VtoPole_prj, Pole_prj_pt, vu->v_p->vg_p->coord);

		if (distA < distB) {
			VUNITIZE(VtoPole_prj);
			VUNITIZE(leftA);
			if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
				VPRINT("LeftA", leftA);
				VPRINT("VtoPole_prj", VtoPole_prj);
			}

			if (VDOT(leftA, VtoPole_prj) >= 0.0) {
				/* plane point is "inside" edge A */
			   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
					bu_log("\tplane point inside face\n");
				VSUB2(pca_to_pole_vect, Pole_prj_pt, Pole);
				*Pole_dist = MAGNITUDE(pca_to_pole_vect);
				VMOVE(Pole_pca, Pole_prj_pt);
				return;
			}
		   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
					bu_log("\tplane point outside face\n");
			VSUB2(pca_to_pole_vect, pcaA, Pole);
			VMOVE(Pole_pca, pcaA);
		} else {
			VUNITIZE(VtoPole_prj);
			VUNITIZE(leftB);
			if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
				VPRINT("LeftB", leftB);
				VPRINT("VtoPole_prj", VtoPole_prj);
			}
			if (VDOT(leftB, VtoPole_prj) >= 0.0) {
				/* plane point is "inside" edge B */
			   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
					bu_log("\tplane point inside face\n");
				VMOVE(Pole_pca, Pole_prj_pt);
				VSUB2(pca_to_pole_vect, Pole_prj_pt, Pole);
				*Pole_dist = MAGNITUDE(pca_to_pole_vect);
				return;
			}
		   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
					bu_log("\tplane point outside face\n");
			VSUB2(pca_to_pole_vect, pcaB, Pole);
			VMOVE(Pole_pca, pcaB);
		}
		break;
	case 0x33: {
		/* The point is over the vertex shared by the points,
		 * and not over one edge or the other.  We now need to
		 * figure out which edge to classify this point against.
		 *
		 * Time to do the Tanenbaum algorithm.
		 */
		double dotA;
		double dotB;

	   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			bu_log("\tplane point beyond both edges.... Doing the Tanenbaum algorithm.\n");

		VSUB2(VtoPole_prj, Pole_prj_pt, vu->v_p->vg_p->coord);

		dotA = VDOT(leftA, VtoPole_prj);
		dotB = VDOT(leftB, VtoPole_prj);
		
		if (dotA < dotB) {
			if (dotA >= 0.0) {
				/* Point is "inside" face,
				 * PCA is plane projection point.
				 */
			   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
					bu_log("\tpoint inside face\n");
				VMOVE(Pole_pca, Pole_prj_pt);
				VSUB2(pca_to_pole_vect, Pole, Pole_prj_pt);
			} else {
				/* Point is "outside" face, PCA is at vertex. */
			   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
					bu_log("\tpoint outside face, PCA is vertex\n");

				VSUB2(pca_to_pole_vect, pcaA, Pole);
				VMOVE(Pole_pca, pcaA);
			}
		} else {
			if (dotB >= 0.0) {
				/* Point is "inside" face,
				 * PCA is plane projection point
				 */
			   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
					bu_log("\tpoint is inside face\n");
				VMOVE(Pole_pca, Pole_prj_pt);
				VSUB2(pca_to_pole_vect, Pole, Pole_prj_pt);
			} else {

				/* Point is "outside" face, PCA is at vertex. */
			   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
					bu_log("\tpoint is outside face, PCA is vertex\n");
				VSUB2(pca_to_pole_vect, pcaB, Pole);
				VMOVE(Pole_pca, pcaB);
			}
		}
	   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			VPRINT("\tpca_to_pole_vect", pca_to_pole_vect);
		*Pole_dist = MAGNITUDE(pca_to_pole_vect);
		return;
	}
	case 0x34: /* fallthrough */
	case 0x54: /* fallthrough */
	case 0x43: /* fallthrough */
	case 0x44: /* fallthrough */
	case 0x45: /* fallthrough */
	default:
		bu_log("%s %d: So-called 'Impossible' status codes\n",
			__FILE__, __LINE__);
		rt_bomb("get_pole_dist_to_face() Pretending NOT to bomb\n");
		break;
	}

	*Pole_dist = MAGNITUDE(pca_to_pole_vect);		

	return;
}

static void
plot_neighborhood(fastf_t *North_Pole, fastf_t *North_pl_pt, fastf_t *North_pca, fastf_t *South_Pole, fastf_t *South_pl_pt, fastf_t *South_pca, fastf_t *pointA, fastf_t *pointB, fastf_t *norm, fastf_t *pt, fastf_t *leftA, fastf_t *leftB)
{
	static int plotnum=0;
	FILE *pfd;
	char name[64];
	point_t my_pt;
	vect_t ray;

	sprintf(name, "vert%03d.pl", plotnum++);
	if ((pfd=fopen(name, "w")) == (FILE *)NULL) {
		bu_log("Error opening %s\n", name);
		return;
	} else
		bu_log("overlay %s\n", name);


	/* draw the ray */
	pl_color(pfd, 255, 55, 55);
	pdv_3line(pfd, North_Pole, South_Pole);

	/* draw the area of the face */
	pl_color(pfd, 55, 255, 55);
	pdv_3move(pfd, pt);
	pdv_3cont(pfd, pointA);
	pdv_3cont(pfd, pointB);
	pdv_3cont(pfd, pt);

	/* draw the projections of the pole points */
	pl_color(pfd, 255, 255, 55);
	pdv_3line(pfd, North_Pole, North_pl_pt);
	if ( ! VEQUAL(North_pca, North_pl_pt) ) {
		pdv_3line(pfd, North_Pole, North_pca);
		pdv_3line(pfd, North_pl_pt, North_pca);
	}
	VSUB2(ray, South_Pole, North_Pole);
	VSCALE(ray, ray, -0.125);
	VADD2(my_pt, North_Pole, ray);
	pdv_3move(pfd, my_pt);
	pl_label(pfd, "N");

	pl_color(pfd, 55, 255, 255);
	pdv_3line(pfd, South_Pole, South_pl_pt);
	if ( ! VEQUAL(South_pca, South_pl_pt) ) {
		pdv_3line(pfd, South_Pole, South_pca);
		pdv_3line(pfd, South_pl_pt, South_pca);
	}
	VREVERSE(ray, ray);
	VADD2(my_pt, South_Pole, ray);
	pdv_3move(pfd, my_pt);
	pl_label(pfd, "S");

	pl_color(pfd, 128, 128, 128);
	VADD2(my_pt, pt, norm);
	pdv_3line(pfd, pt, my_pt);

	pl_color(pfd, 192, 192, 192);
	VADD2(my_pt, pointA, leftA);
	pdv_3line(pfd, pointA, my_pt);

	VADD2(my_pt, pointB, leftB);
	pdv_3line(pfd, pointB, my_pt);


	fclose(pfd);
}
				







/*	V E R T E X _ N E I G H B O R H O O D
 *
 *	Examine the vertex neighborhood to classify the ray as IN/ON/OUT of
 *	the NMG both before and after hitting the vertex.
 *
 *
 *	There is a conceptual sphere about the vertex.  For reasons associated
 *	with tolerancing, the sphere has a radius equal to the magnitude of
 *	the maximum dimension of the NMG bounding RPP.
 *
 *	The point where the ray enters this sphere is called the "North Pole"
 *	and the point where it exits the sphere is called the "South Pole"  
 *
 *	For each face which uses this vertex we compute 2 "distance" metrics:
 *
 *	project the "north pole" and "south pole" down onto the plane of the
 *	face:
 *
 *
 *
 *			    		    /
 *				  	   /
 *				     	  /North Pole
 *				     	 / |
 *			Face Normal  ^	/  |
 *			 	     | /   | Projection of North Pole
 *	Plane of face	    	     |/    V to plane
 *  ---------------------------------*-------------------------------
 *     		  Projection of ^   / Vertex		
 *		     South Pole |  /
 *		       to plane | /
 *			    	|/
 *			    	/South Pole
 *			       /
 *			      /
 *			     /
 *			    /
 *			   /
 *			  /
 *			|/_
 *			Ray
 *
 *	If the projected polar point is inside the two edgeuses at this
 *		vertexuse, then
 *		 	the distance to the face is the projection distance.
 *
 *		else
 *			Each of the two edgeuses at this vertexuse 
 *			implies an infinite ray originating at the vertex.
 *			Find the point of closest approach (PCA) of each ray
 *			to the projection point.  For whichever ray passes
 *			closer to the projection point, find the distance
 *			from the original pole point to the PCA.  This is
 *			the "distance to the face" metric for this face from
 *			the given pole point.
 *
 *	We compute this metric for the North and South poles for all faces at
 *	the vertex.  The face with the smallest distance to the north (south)
 * 	pole is used to determine the state of the ray before (after) it hits
 *	the vertex.  
 *
 *	If the north (south) pole is "outside" the plane of the closest face,
 *	then the ray state is "outside" before (after) the ray hits the
 *	vertex.
 */
static void
vertex_neighborhood(struct ray_data *rd, struct vertexuse *vu_p, struct hitmiss *myhit)
{
	struct vertexuse *vu;
	struct faceuse *fu;
	point_t	South_Pole, North_Pole;
	struct faceuse *North_fu = (struct faceuse *)NULL;
	struct faceuse *South_fu = (struct faceuse *)NULL;
	struct vertexuse *North_vu = (struct vertexuse *)NULL;
	struct vertexuse *South_vu = (struct vertexuse *)NULL;
	point_t North_pl_pt, South_pl_pt;
	point_t North_pca, South_pca;
	double North_dist, South_dist;
	double North_min, South_min;
	double cos_angle;
	vect_t VtoPole;
	double scalar_dist;
	double dimen, t;
	point_t min_pt, max_pt;
	int i;
	vect_t norm, anti_norm;
	vect_t polar_height_vect;
	vect_t leftA, leftB;
	point_t pointA, pointB;
	struct edgeuse *eu;
	vect_t edge_vect;
	int found_faces;

	NMG_CK_VERTEXUSE(vu_p);
	NMG_CK_VERTEX(vu_p->v_p);
	NMG_CK_VERTEX_G(vu_p->v_p->vg_p);

   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("vertex_neighborhood\n");

	nmg_model_bb( min_pt, max_pt, nmg_find_model( vu_p->up.magic_p ));
	for (dimen= -MAX_FASTF,i=3 ; i-- ; ) {
		t = max_pt[i]-min_pt[i];
		if (t > dimen) dimen = t;
	}

  	VJOIN1(North_Pole, vu_p->v_p->vg_p->coord, -dimen, rd->rp->r_dir);
	VJOIN1(South_Pole, vu_p->v_p->vg_p->coord, dimen, rd->rp->r_dir);

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		VPRINT("\tNorth Pole", North_Pole);
		VPRINT("\tSouth Pole", South_Pole);
	}

    	/* There is a conceptual sphere around the vertex
	 * The max dimension of the bounding box for the NMG defines the size.
    	 * The point where the ray enters this sphere is
    	 *  called the North Pole, and the point where it
    	 *  exits is called the South Pole.
    	 */

	South_min = North_min = MAX_FASTF;
	found_faces = 0;
	myhit->in_out = 0;

	/* for every use of this vertex */
	for ( BU_LIST_FOR(vu, vertexuse, &vu_p->v_p->vu_hd) ) {
		/* if the parent use is an (edge/loop)use of an 
		 * OT_SAME faceuse that we haven't already processed...
		 */
		NMG_CK_VERTEXUSE(vu);
		NMG_CK_VERTEX(vu->v_p);
		NMG_CK_VERTEX_G(vu->v_p->vg_p);

		fu = nmg_find_fu_of_vu( vu );
		if (fu) {
		  found_faces = 1;
		  if(*vu->up.magic_p == NMG_EDGEUSE_MAGIC &&
		    fu->orientation == OT_SAME ) {

			/* The distance from each "Pole Point" to the faceuse
			 *  is the commodity in which we are interested.
			 *
			 * A pole point is projected
			 * This is either the distance to the plane (if the
			 * projection of the point into the plane lies within
			 * the angle of the two edgeuses at this vertex) or
			 * we take the distance from the pole to the PCA of
			 * the closest edge.
			 */
			NMG_GET_FU_NORMAL( norm, fu );
			VREVERSE(anti_norm, norm);
		
		    	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				VPRINT("\tchecking face", norm);

			/* project the north pole onto the plane */
			VSUB2(polar_height_vect, vu->v_p->vg_p->coord, North_Pole);
			scalar_dist = VDOT(norm, polar_height_vect);
		
			/* project the poles down onto the plane */
			VJOIN1(North_pl_pt, North_Pole, scalar_dist, norm);
			VJOIN1(South_pl_pt, South_Pole, scalar_dist, anti_norm);
		    	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		    		VPRINT("\tNorth Plane Point", North_pl_pt);
		    		VPRINT("\tSouth Plane Point", South_pl_pt);
		    	}
			/* Find points on sphere in direction of edges
			 * (away from vertex along edge)
			 */
			do
				eu = BU_LIST_PNEXT_CIRC(edgeuse, vu->up.eu_p);
			while (eu->vu_p->v_p == vu->v_p);
			nmg_find_eu_leftvec(leftA, vu->up.eu_p);
			VSUB2(edge_vect, eu->vu_p->v_p->vg_p->coord,
				vu->v_p->vg_p->coord);
			VUNITIZE(edge_vect);
			VJOIN1(pointA, vu->v_p->vg_p->coord, dimen, edge_vect)

			do
				eu = BU_LIST_PPREV_CIRC(edgeuse, vu->up.eu_p);
			while (eu->vu_p->v_p == vu->v_p);
			nmg_find_eu_leftvec(leftB, eu);
			VSUB2(edge_vect, eu->vu_p->v_p->vg_p->coord,
				vu->v_p->vg_p->coord);
			VUNITIZE(edge_vect);
			VJOIN1(pointB, vu->v_p->vg_p->coord, dimen, edge_vect)


		    	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		    		VPRINT("\tLeftA", leftA);
		    		VPRINT("\tLeftB", leftB);
		    	}
		    	/* find distance of face to North Pole */
			get_pole_dist_to_face(rd, vu,
				North_Pole, North_pl_pt, &North_dist, North_pca,
				pointA, leftA, pointB, leftB,
				polar_height_vect, "North");

			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("\tDist north pole<=>face %g\n", North_dist);

			if (North_min > North_dist) {
				North_min = North_dist;
				North_fu = fu;
				North_vu = vu;
				if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			    		bu_log("New North Pole Min: %g\n", North_min);
			}


		    	/* find distance of face to South Pole */
			get_pole_dist_to_face(rd, vu,
				South_Pole, South_pl_pt, &South_dist, South_pca,
				pointA, leftA, pointB, leftB,
				polar_height_vect, "South");

			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("\tDist south pole<=>face %g\n", South_dist);

			if (South_min > South_dist) {
				South_min = South_dist;
				South_fu = fu;
				South_vu = vu;
				if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			    		bu_log("New South Pole Min: %g\n", South_min);
			}


			if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
				plot_neighborhood( North_Pole, North_pl_pt, North_pca,
						   South_Pole, South_pl_pt, South_pca,
						   pointA, pointB, norm, 
						   vu_p->v_p->vg_p->coord,
						   leftA, leftB);
			}
		    }
		} else {
			if (!found_faces)
				South_vu = North_vu = vu;
		}
	}

	if (!found_faces) {
		/* we've found a vertex floating in space */
		myhit->outbound_use = myhit->inbound_use = (long *)North_vu;
		myhit->in_out = HMG_HIT_ANY_ANY;
		VREVERSE(myhit->hit.hit_normal, rd->rp->r_dir);
		return;
	}


	NMG_GET_FU_NORMAL( norm, North_fu );
	VMOVE(myhit->inbound_norm, norm);
	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("North Pole Min: %g to %g %g %g\n", North_min,
			norm[0], norm[1],norm[2]);

	/* compute status of ray as it is in-bound on the vertex */
	VSUB2(VtoPole, North_Pole, vu_p->v_p->vg_p->coord);
	cos_angle = VDOT(norm, VtoPole);
	if (BN_VECT_ARE_PERP(cos_angle, rd->tol))
		myhit->in_out |= NMG_RAY_STATE_ON << 4;
	else if (cos_angle > 0.0)
		myhit->in_out |= NMG_RAY_STATE_OUTSIDE << 4;
	else
		myhit->in_out |= NMG_RAY_STATE_INSIDE << 4;


	/* compute status of ray as it is out-bound from the vertex */
	NMG_GET_FU_NORMAL( norm, South_fu );
	VMOVE(myhit->outbound_norm, norm);
	VSUB2(VtoPole, South_Pole, vu_p->v_p->vg_p->coord);
	cos_angle = VDOT(norm, VtoPole);
	if (BN_VECT_ARE_PERP(cos_angle, rd->tol))
		myhit->in_out |= NMG_RAY_STATE_ON;
	else if (cos_angle > 0.0)
		myhit->in_out |= NMG_RAY_STATE_OUTSIDE;
	else
		myhit->in_out |= NMG_RAY_STATE_INSIDE;


	myhit->inbound_use = (long *)North_vu;
	myhit->outbound_use = (long *)South_vu;

	switch (myhit->in_out) {
#if 1
	case HMG_HIT_ON_ON:	/* fallthrough???  -MJM??? */
#endif
	case HMG_HIT_IN_IN:	/* fallthrough */
	case HMG_HIT_OUT_OUT:	/* fallthrough */
	case HMG_HIT_IN_ON:	/* fallthrough */
	case HMG_HIT_ON_IN:	/* two hits */
		myhit->hit.hit_private = (genptr_t)North_vu;
		break;
	case HMG_HIT_IN_OUT:	/* one hit - outbound */
	case HMG_HIT_ON_OUT:	/* one hit - outbound */
		myhit->hit.hit_private = (genptr_t)South_vu;
		break;
	case HMG_HIT_OUT_IN:	/* one hit - inbound */
	case HMG_HIT_OUT_ON:	/* one hit - inbound */
		myhit->hit.hit_private = (genptr_t)North_vu;
		break;
	default:
		bu_log("%s %d: vertex_neighborhood() Bad vertex in_out state = x%x\n",
			__FILE__, __LINE__, myhit->in_out);
		rt_bomb("vertex_neighborhood() bad vertex in_out state\n");
		break;

	}
}






/*
 *  Once it has been decided that the ray hits the vertex, 
 *  this routine takes care of recording that fact.
 */
static void
ray_hit_vertex(struct ray_data *rd, struct vertexuse *vu_p, int status)
{
	struct hitmiss *myhit;
	vect_t v;

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("ray_hit_vertex x%x (%g %g %g)\n",
			vu_p->v_p, V3ARGS( vu_p->v_p->vg_p->coord ));

	if ( (myhit = NMG_INDEX_GET(rd->hitmiss, vu_p->v_p)) ) {
		if (BU_LIST_MAGIC_OK((struct bu_list *)myhit, NMG_RT_HIT_MAGIC))
			return;
		/* oops, we have to change a MISS into a HIT */
		BU_LIST_DEQUEUE(&myhit->l);
	} else {
		GET_HITMISS(myhit, rd->ap);
		NMG_INDEX_ASSIGN(rd->hitmiss, vu_p->v_p, myhit);
		myhit->outbound_use = (long *)vu_p;
		myhit->inbound_use = (long *)vu_p;
	}

	/* v = vector from ray point to hit vertex */
	VSUB2( v, vu_p->v_p->vg_p->coord, rd->rp->r_pt);
	myhit->hit.hit_dist = VDOT( v, rd->rp->r_dir );	/* distance along ray */
	VMOVE(myhit->hit.hit_point, vu_p->v_p->vg_p->coord);
	myhit->hit.hit_private = (genptr_t) vu_p->v_p;

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log( "\tray = ( %g %g %g ), dir=(%g %g %g ), dist=%g\n",
			V3ARGS( rd->rp->r_pt ), V3ARGS( rd->rp->r_dir ), myhit->hit.hit_dist );

	BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_MAGIC);

	/* XXX need to compute neighborhood of vertex so that ray
	 * can be classified as in/on/out before and after the vertex.
	 *
	 */
	vertex_neighborhood(rd, vu_p, myhit);

	/* XXX we re really should temper the results of vertex_neighborhood()
	 * with the knowledge of "status"
	 */

	hit_ins(rd, myhit);
	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		plvu(vu_p);
#ifndef FAST_NMG
	NMG_CK_HITMISS(myhit);
#endif
}


/*	I S E C T _ R A Y _ V E R T E X U S E
 *
 *	Called in one of the following situations:
 *		1)	Zero length edge
 *		2)	Vertexuse child of Loopuse
 *		3)	Vertexuse child of Shell
 *
 *	return:
 *		1 vertex was hit
 *		0 vertex was missed
 */
static int
isect_ray_vertexuse(struct ray_data *rd, struct vertexuse *vu_p)
{
	struct hitmiss *myhit;
	double ray_vu_dist;

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("isect_ray_vertexuse\n");

	NMG_CK_VERTEXUSE(vu_p);
	NMG_CK_VERTEX(vu_p->v_p);
	NMG_CK_VERTEX_G(vu_p->v_p->vg_p);

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("nmg_isect_ray_vertexuse %g %g %g", 
			vu_p->v_p->vg_p->coord[0], 
			vu_p->v_p->vg_p->coord[1], 
			vu_p->v_p->vg_p->coord[2]);

	if ( (myhit = NMG_INDEX_GET(rd->hitmiss, vu_p->v_p)) ) {
		if (BU_LIST_MAGIC_OK((struct bu_list *)myhit, NMG_RT_HIT_MAGIC)) {
			/* we've previously hit this vertex */
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log(" previously hit\n");
			return(1);
		} else {
			/* we've previously missed this vertex */
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log(" previously missed\n");
			return 0;
		}
	}

	/* intersect ray with vertex */
	ray_vu_dist = bn_dist_line3_pt3(rd->rp->r_pt, rd->rp->r_dir,
					 vu_p->v_p->vg_p->coord);

	if (ray_vu_dist > rd->tol->dist) {
		/* ray misses vertex */
		ray_miss_vertex(rd, vu_p);
		return 0;
	}

	/* ray hits vertex */
	ray_hit_vertex(rd, vu_p, NMG_VERT_UNKNOWN);

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		bu_log(" Ray hits vertex, dist %g (priv=x%x, v magic=x%x)\n",
			myhit->hit.hit_dist,
			myhit->hit.hit_private,
			vu_p->v_p->magic);

		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			nmg_rt_print_hitlist(rd->hitmiss[NMG_HIT_LIST]);
	}

	return 1;
}


/*
 * As the name implies, this routine is called when the ray and an edge are
 * colinear.  It handles marking the verticies as hit, remembering that this
 * is a seg_in/seg_out pair, and builds the hit on the edge.
 *
 */
static void
colinear_edge_ray(struct ray_data *rd, struct edgeuse *eu_p)
{
	struct hitmiss *vhit1, *vhit2, *myhit;


	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("\t - colinear_edge_ray\n");

	vhit1 = NMG_INDEX_GET(rd->hitmiss, eu_p->vu_p->v_p);
	vhit2 = NMG_INDEX_GET(rd->hitmiss, eu_p->eumate_p->vu_p->v_p);

	/* record the hit on each vertex, and remember that these two hits
	 * should be kept together.
	 */
	if (vhit1->hit.hit_dist > vhit2->hit.hit_dist) {
		ray_hit_vertex(rd, eu_p->vu_p, NMG_VERT_ENTER);
		vhit1->start_stop = NMG_HITMISS_SEG_OUT;

		ray_hit_vertex(rd, eu_p->eumate_p->vu_p, NMG_VERT_LEAVE);
		vhit2->start_stop = NMG_HITMISS_SEG_IN;
	} else {
		ray_hit_vertex(rd, eu_p->vu_p, NMG_VERT_LEAVE);
		vhit1->start_stop = NMG_HITMISS_SEG_IN;

		ray_hit_vertex(rd, eu_p->eumate_p->vu_p, NMG_VERT_ENTER);
		vhit2->start_stop = NMG_HITMISS_SEG_OUT;
	}
	vhit1->other = vhit2;
	vhit2->other = vhit1;

	GET_HITMISS(myhit, rd->ap);
	NMG_INDEX_ASSIGN(rd->hitmiss, eu_p->e_p, myhit);
	myhit->hit.hit_private = (genptr_t)eu_p->e_p;
	BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_SUB_MAGIC);
	BU_LIST_INSERT(&rd->rd_miss, &myhit->l);
#ifndef FAST_NMG
	NMG_CK_HITMISS(myhit);
	NMG_CK_HITMISS_LISTS(myhit, rd);
#endif
	return;
}

/*
 *  When a vertex at an end of an edge gets hit by the ray, this macro
 *  is used to build the hit structures for the vertex and the edge.
 */
#ifndef FAST_NMG
#define HIT_EDGE_VERTEX(rd, eu_p, vu_p) {\
	if (rt_g.NMG_debug & DEBUG_RT_ISECT) bu_log("hit_edge_vertex\n"); \
	if (*eu_p->up.magic_p == NMG_SHELL_MAGIC || \
	    (*eu_p->up.magic_p == NMG_LOOPUSE_MAGIC && \
	     *eu_p->up.lu_p->up.magic_p == NMG_SHELL_MAGIC)) \
		ray_hit_vertex(rd, vu_p, NMG_VERT_ENTER_LEAVE); \
	else \
		ray_hit_vertex(rd, vu_p, NMG_VERT_UNKNOWN); \
	GET_HITMISS(myhit); \
	NMG_INDEX_ASSIGN(rd->hitmiss, eu_p->e_p, myhit); \
	myhit->hit.hit_private = (genptr_t)eu_p->e_p; \
	BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_SUB_MAGIC); \
	BU_LIST_INSERT(&rd->rd_miss, &myhit->l); \
	NMG_CK_HITMISS(myhit); \
	NMG_CK_HITMISS_LISTS(myhit, rd); }
#else
#define HIT_EDGE_VERTEX(rd, eu_p, vu_p) {\
	if (rt_g.NMG_debug & DEBUG_RT_ISECT) bu_log("hit_edge_vertex\n"); \
	if (*eu_p->up.magic_p == NMG_SHELL_MAGIC || \
	    (*eu_p->up.magic_p == NMG_LOOPUSE_MAGIC && \
	     *eu_p->up.lu_p->up.magic_p == NMG_SHELL_MAGIC)) \
		ray_hit_vertex(rd, vu_p, NMG_VERT_ENTER_LEAVE); \
	else \
		ray_hit_vertex(rd, vu_p, NMG_VERT_UNKNOWN); \
	GET_HITMISS(myhit, rd->ap); \
	NMG_INDEX_ASSIGN(rd->hitmiss, eu_p->e_p, myhit); \
	myhit->hit.hit_private = (genptr_t)eu_p->e_p; \
	BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_SUB_MAGIC); \
	BU_LIST_INSERT(&rd->rd_miss, &myhit->l); }
#endif


/*
 *	Compute the "ray state" before and after the ray encounters a
 *	hit-point on an edge.
 */
static void
edge_hit_ray_state(struct ray_data *rd, struct edgeuse *eu, struct hitmiss *myhit)
{
	double cos_angle;
	double inb_cos_angle = 2.0;
	double outb_cos_angle = -1.0;
	struct shell *s;
	struct faceuse *fu;
	struct faceuse *inb_fu = (struct faceuse *)NULL;
	struct faceuse *outb_fu = (struct faceuse *)NULL;
	struct edgeuse *inb_eu = (struct edgeuse *)NULL;
	struct edgeuse *outb_eu = (struct edgeuse *)NULL;
	struct edgeuse *eu_p;
	struct edgeuse *fu_eu;
	vect_t edge_left;
	vect_t eu_vec;
	vect_t norm;
	int faces_found;

#ifndef FAST_NMG
	NMG_CK_HITMISS_LISTS(a_hit, rd);
#endif
	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		eu_p = BU_LIST_PNEXT_CIRC(edgeuse, eu);
		bu_log("edge_hit_ray_state(%g %g %g -> %g %g %g _vs_ %g %g %g)\n",
			eu->vu_p->v_p->vg_p->coord[0],
			eu->vu_p->v_p->vg_p->coord[1],
			eu->vu_p->v_p->vg_p->coord[2],
			eu_p->vu_p->v_p->vg_p->coord[0],
			eu_p->vu_p->v_p->vg_p->coord[1],
			eu_p->vu_p->v_p->vg_p->coord[2],
			rd->rp->r_dir[0],
			rd->rp->r_dir[1],
			rd->rp->r_dir[2]);
	}

	myhit->in_out = 0;

	s = nmg_find_s_of_eu( eu );

	faces_found = 0;
	eu_p = eu->e_p->eu_p;
	do {
		if ( (fu=nmg_find_fu_of_eu(eu_p)) ) {
			fu_eu = eu_p;
			faces_found = 1;
			if (fu->orientation == OT_OPPOSITE &&
			    fu->fumate_p->orientation == OT_SAME) {
				fu = fu->fumate_p;
			    	fu_eu = eu_p->eumate_p;
			    }
			if (fu->orientation != OT_SAME) {
				bu_log("%s[%d]: I can't seem to find an OT_SAME faceuse\nThis must be a `dangling' face  I'll skip it\n", __FILE__, __LINE__);
				goto next_edgeuse;
			}

			if( fu->s_p != s )
				goto next_edgeuse;

			if (nmg_find_eu_leftvec(edge_left, eu_p)) {
				bu_log("edgeuse not part of faceuse");
				goto next_edgeuse;
			}

			if (! (NMG_3MANIFOLD & 
			       NMG_MANIFOLDS(rd->manifolds, fu->f_p)) ){
				bu_log("This is not a 3-Manifold face.  I'll skip it\n");
				goto next_edgeuse;
			}

			cos_angle = VDOT(edge_left, rd->rp->r_dir);

			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			{
				bu_log("left_vect:(%g %g %g)  cos_angle:%g\n",
					edge_left[0], edge_left[1],
					edge_left[2], cos_angle);
			}

			if (cos_angle < inb_cos_angle) {
				inb_cos_angle = cos_angle;
				inb_fu = fu;
				inb_eu = fu_eu;
				if (rt_g.NMG_debug & DEBUG_RT_ISECT)
					bu_log("New inb cos_angle %g\n", inb_cos_angle);
			}
			if (cos_angle > outb_cos_angle) {
				outb_cos_angle = cos_angle;
				outb_fu = fu;
				outb_eu = fu_eu;
				if (rt_g.NMG_debug & DEBUG_RT_ISECT)
					bu_log("New outb cos_angle %g\n", outb_cos_angle);
			}
		}
next_edgeuse:	eu_p = eu_p->eumate_p->radial_p;
	} while (eu_p != eu->e_p->eu_p);

#ifndef FAST_NMG
	NMG_CK_HITMISS_LISTS(a_hit, rd);
#endif

	if (!faces_found) {
		/* we hit a wire edge */
		myhit->in_out = HMG_HIT_ANY_ANY;
		myhit->hit.hit_private = (genptr_t)eu;
		myhit->inbound_use = myhit->outbound_use = (long *)eu;

		eu_p = BU_LIST_PNEXT_CIRC(edgeuse, eu);
		VSUB2(eu_vec, eu->vu_p->v_p->vg_p->coord,
			eu_p->vu_p->v_p->vg_p->coord);
		VCROSS(edge_left, eu_vec, rd->rp->r_dir);
		VCROSS(myhit->inbound_norm, eu_vec, edge_left);
		if (VDOT(myhit->inbound_norm, rd->rp->r_dir) > 0.0) {
			VREVERSE(myhit->inbound_norm,myhit->inbound_norm);
		}
		VMOVE(myhit->outbound_norm, myhit->inbound_norm);

		return;
	}

	/* inb_fu is closest to ray on outbound side
	 * outb_fu is closest to ray on inbound side
	 */

	/* Compute the ray state on the inbound side */
	NMG_GET_FU_NORMAL(norm, inb_fu);
	VMOVE(myhit->inbound_norm, norm);
	if (MAGSQ(norm) < VDIVIDE_TOL)
		rt_bomb("edge_hit_ray_state() null normal!\n");

	cos_angle = VDOT(norm, rd->rp->r_dir);

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		VPRINT("\ninb face normal", norm);
		bu_log("cos_angle wrt ray direction: %g\n", cos_angle);
	}

	if (BN_VECT_ARE_PERP(cos_angle, rd->tol))
		myhit->in_out |= NMG_RAY_STATE_ON << 4;
	else if (cos_angle < 0.0)
		myhit->in_out |= NMG_RAY_STATE_OUTSIDE << 4;
	else /* (cos_angle > 0.0) */
		myhit->in_out |= NMG_RAY_STATE_INSIDE << 4;


	/* Compute the ray state on the outbound side */
	NMG_GET_FU_NORMAL(norm, outb_fu);
	VMOVE(myhit->outbound_norm, norm);
	cos_angle = VDOT(norm, rd->rp->r_dir);

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		VPRINT("\noutb face normal", norm);
		bu_log("cos_angle wrt ray direction: %g\n", cos_angle);
	}

	if (BN_VECT_ARE_PERP(cos_angle, rd->tol))
		myhit->in_out |= NMG_RAY_STATE_ON;
	else if (cos_angle > 0.0)
		myhit->in_out |= NMG_RAY_STATE_OUTSIDE;
	else /* (cos_angle < 0.0) */
		myhit->in_out |= NMG_RAY_STATE_INSIDE;


	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		bu_log("myhit->in_out: 0x%02x/", myhit->in_out);
		switch(myhit->in_out) {
		case HMG_HIT_IN_IN:
			bu_log("IN_IN\n"); break;
		case HMG_HIT_IN_OUT:
			bu_log("IN_OUT\n"); break;
		case HMG_HIT_OUT_IN:
			bu_log("OUT_IN\n"); break;
		case HMG_HIT_OUT_OUT:
			bu_log("OUT_OUT\n"); break;
		case HMG_HIT_IN_ON:
			bu_log("IN_ON\n"); break;
		case HMG_HIT_ON_IN:
			bu_log("ON_IN\n"); break;
		case HMG_HIT_OUT_ON:
			bu_log("OUT_ON\n"); break;
		case HMG_HIT_ON_OUT:
			bu_log("ON_OUT\n"); break;
		case HMG_HIT_ON_ON:
			bu_log("ON_ON\n"); break;
		default:
			bu_log("?_?\n"); break;
		}
	}


	switch(myhit->in_out) {
	case HMG_HIT_ON_ON:	/* Another fall through?? JRA */
	case HMG_HIT_IN_IN:	/* fallthrough */
	case HMG_HIT_OUT_OUT:	/* fallthrough */
	case HMG_HIT_IN_ON:	/* fallthrough */
	case HMG_HIT_ON_IN:	/* two hits */
		myhit->inbound_use = (long *)inb_eu;
		myhit->outbound_use = (long *)outb_eu;
		myhit->hit.hit_private = (genptr_t)inb_eu;
		break;
	case HMG_HIT_IN_OUT:	/* one hit - outbound */
	case HMG_HIT_ON_OUT:	/* one hit - outbound */
		myhit->inbound_use = (long *)outb_eu;
		myhit->outbound_use = (long *)outb_eu;
		myhit->hit.hit_private = (genptr_t)outb_eu;
		break;
	case HMG_HIT_OUT_IN:	/* one hit - inbound */
	case HMG_HIT_OUT_ON:	/* one hit - inbound */
		myhit->inbound_use = (long *)inb_eu;
		myhit->outbound_use = (long *)inb_eu;
		myhit->hit.hit_private = (genptr_t)inb_eu;
		break;
	default:
		bu_log("%s %d: Bad edge in/out state = x%x\n", __FILE__, __LINE__, myhit->in_out);
		rt_bomb("edge_hit_ray_state() bad edge in_out state\n");
		break;
	}
#ifndef FAST_NMG
	NMG_CK_HITMISS_LISTS(a_hit, rd);
#endif
}

/*
 *
 * record a hit on an edge.
 *
 */
static void
ray_hit_edge(struct ray_data *rd, struct edgeuse *eu_p, double dist_along_ray, fastf_t *pt)
{
	struct hitmiss *myhit;
	ray_miss_vertex(rd, eu_p->vu_p);
	ray_miss_vertex(rd, eu_p->eumate_p->vu_p);
#if DO_NITMISS_CHECKS
	NMG_CK_HITMISS_LISTS(a_hit, rd);
#endif

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) bu_log("\t - HIT edge 0x%08x (edgeuse=x%x)\n", eu_p->e_p, eu_p);

	if ( (myhit = NMG_INDEX_GET(rd->hitmiss, eu_p->e_p)) ) {
		switch (((struct bu_list *)myhit)->magic) {
		case NMG_RT_MISS_MAGIC:
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("\tedge previously missed, changing to hit\n");
			BU_LIST_DEQUEUE(&myhit->l);
#ifndef FAST_NMG
			NMG_CK_HITMISS_LISTS(a_hit, rd);
#endif
			break;
		case NMG_RT_HIT_SUB_MAGIC:
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("\tedge vertex previously hit\n");
			return;
		case NMG_RT_HIT_MAGIC:
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("\tedge previously hit\n");
			return;
		default:
			break;
		}
	} else {
		GET_HITMISS(myhit, rd->ap);
	}

	/* create hit structure for this edge */
	NMG_INDEX_ASSIGN(rd->hitmiss, eu_p->e_p, myhit);
	myhit->outbound_use = (long *)eu_p;
	myhit->inbound_use = (long *)eu_p;

	/* build the hit structure */
	myhit->hit.hit_dist = dist_along_ray;
	VMOVE(myhit->hit.hit_point, pt)
	myhit->hit.hit_private = (genptr_t) eu_p->e_p;

	edge_hit_ray_state(rd, eu_p, myhit);
#ifndef FAST_NMG
	NMG_CK_HITMISS_LISTS(a_hit, rd);
#endif
	hit_ins(rd, myhit);
#ifndef FAST_NMG
	NMG_CK_HITMISS_LISTS(a_hit, rd);
#endif

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		register struct faceuse *fu;
		if ((fu=nmg_find_fu_of_eu( eu_p )))
			nmg_rt_isect_plfu(fu, rd->rp->r_pt, myhit->hit.hit_point);
		else
			pleu(eu_p, rd->rp->r_pt, myhit->hit.hit_point);
	}
#ifndef FAST_NMG
	NMG_CK_HITMISS(myhit);
	NMG_CK_HITMISS_LISTS(a_hit, rd);
#endif
}

void
isect_ray_cnurb(struct ray_data *rd, struct edgeuse *eu_p)
{
}

void
isect_ray_lseg(struct ray_data *rd, struct edgeuse *eu_p)
{
	int status;
	struct hitmiss *myhit;
	int vhit1, vhit2;
	double dist_along_ray;

	status = bn_isect_line_lseg( &dist_along_ray,
			rd->rp->r_pt, rd->rp->r_dir, 
			eu_p->vu_p->v_p->vg_p->coord,
			eu_p->eumate_p->vu_p->v_p->vg_p->coord,
			rd->tol);

	switch (status) {
	case -4 :
		/* Zero length edge.  The routine bn_isect_line_lseg() can't
		 * help us.  Intersect the ray with each vertex.  If either
		 * vertex is hit, then record that the edge has sub-elements
		 * which where hit.  Otherwise, record the edge as being
		 * missed.
		 */

		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			bu_log("\t - Zero length edge\n");

		vhit1 = isect_ray_vertexuse(rd, eu_p->vu_p);
		vhit2 = isect_ray_vertexuse(rd, eu_p->eumate_p->vu_p);

		GET_HITMISS(myhit, rd->ap);
		NMG_INDEX_ASSIGN(rd->hitmiss, eu_p->e_p, myhit);

		myhit->hit.hit_private = (genptr_t)eu_p->e_p;

		if (vhit1 || vhit2) {
			/* we hit the vertex */
			BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_SUB_MAGIC);
		} else {
			/* both vertecies were missed, so edge is missed */
			BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		}
		BU_LIST_INSERT(&rd->rd_miss, &myhit->l);
#ifndef FAST_NMG
		NMG_CK_HITMISS(myhit);
		NMG_CK_HITMISS_LISTS(myhit, rd);
#endif
		break;
	case -3 :	/* fallthrough */
	case -2 :
		/* The ray misses the edge segment, but hits the infinite
		 * line of the edge to one end of the edge segment.  This
		 * is an exercise in tabulating the nature of the miss.
		 */

		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			bu_log("\t - Miss edge, \"hit\" line\n");
		/* record the fact that we missed each vertex */
		(void)ray_miss_vertex(rd, eu_p->vu_p);
		(void)ray_miss_vertex(rd, eu_p->eumate_p->vu_p);

		/* record the fact that we missed the edge */
		GET_HITMISS(myhit, rd->ap);
		NMG_INDEX_ASSIGN(rd->hitmiss, eu_p->e_p, myhit);
		myhit->hit.hit_private = (genptr_t)eu_p->e_p;

		BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		BU_LIST_INSERT(&rd->rd_miss, &myhit->l);
#ifndef FAST_NMG
		NMG_CK_HITMISS(myhit);
		NMG_CK_HITMISS_LISTS(myhit, rd);
#endif
		break;
	case -1 : /* just plain missed the edge/line */
		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			bu_log("\t - Miss edge/line\n");

		ray_miss_vertex(rd, eu_p->vu_p);
		ray_miss_vertex(rd, eu_p->eumate_p->vu_p);

		GET_HITMISS(myhit, rd->ap);
		NMG_INDEX_ASSIGN(rd->hitmiss, eu_p->e_p, myhit);
		myhit->hit.hit_private = (genptr_t)eu_p->e_p;

		BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		BU_LIST_INSERT(&rd->rd_miss, &myhit->l);
#ifndef FAST_NMG
		NMG_CK_HITMISS(myhit);
		NMG_CK_HITMISS_LISTS(myhit, rd);
#endif
		break;
	case 0 :  /* oh joy.  Lines are co-linear */
		HIT_EDGE_VERTEX(rd, eu_p, eu_p->vu_p);
		HIT_EDGE_VERTEX(rd, eu_p, eu_p->eumate_p->vu_p);
		colinear_edge_ray(rd, eu_p);
		break;
	case 1 :
		HIT_EDGE_VERTEX(rd, eu_p, eu_p->vu_p);
		break;
	case 2 :
		HIT_EDGE_VERTEX(rd, eu_p, eu_p->eumate_p->vu_p);
		break;
	case 3 : /* a hit on an edge */
		{
			point_t pt;

			VJOIN1(pt, rd->rp->r_pt, dist_along_ray, rd->rp->r_dir);

			ray_hit_edge(rd, eu_p, dist_along_ray, pt);

			break;
		}
	}
}
/*	I S E C T _ R A Y _ E D G E U S E
 *
 *	Intersect ray with edgeuse.  If they pass within tolerance, a hit
 *	is generated.
 *
 */
static void
isect_ray_edgeuse(struct ray_data *rd, struct edgeuse *eu_p)
{
	struct hitmiss *myhit;

	NMG_CK_EDGEUSE(eu_p);
	NMG_CK_EDGEUSE(eu_p->eumate_p);
	NMG_CK_EDGE(eu_p->e_p);
	NMG_CK_VERTEXUSE(eu_p->vu_p);
	NMG_CK_VERTEXUSE(eu_p->eumate_p->vu_p);
	NMG_CK_VERTEX(eu_p->vu_p->v_p);
	NMG_CK_VERTEX(eu_p->eumate_p->vu_p->v_p);

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		bu_log("isect_ray_edgeuse (%g %g %g) -> (%g %g %g)",
			eu_p->vu_p->v_p->vg_p->coord[0],
			eu_p->vu_p->v_p->vg_p->coord[1],
			eu_p->vu_p->v_p->vg_p->coord[2],
			eu_p->eumate_p->vu_p->v_p->vg_p->coord[0],
			eu_p->eumate_p->vu_p->v_p->vg_p->coord[1],
			eu_p->eumate_p->vu_p->v_p->vg_p->coord[2]);
	}

	if (eu_p->e_p != eu_p->eumate_p->e_p)
		rt_bomb("isect_ray_edgeuse() edgeuse mate has step-father\n");

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("\n\tLooking for previous hit on edge 0x%08x ...\n",
			eu_p->e_p);

	if ( (myhit = NMG_INDEX_GET(rd->hitmiss, eu_p->e_p)) ) {
		if (BU_LIST_MAGIC_OK((struct bu_list *)myhit, NMG_RT_HIT_MAGIC)) {
			/* previously hit vertex or edge */
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("\tedge previously hit\n");
			return;
		} else if (BU_LIST_MAGIC_OK((struct bu_list *)myhit, NMG_RT_HIT_SUB_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("\tvertex of edge previously hit\n");
			return;
		} else if (BU_LIST_MAGIC_OK((struct bu_list *)myhit, NMG_RT_MISS_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("\tedge previously missed\n");
			return;
		} else {
			nmg_rt_bomb(rd, "what happened?\n");
		}
	}

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("\t No previous hit\n");

	if ( !eu_p->g.magic_p )
		isect_ray_lseg(rd, eu_p);
	else
	{
		switch (*eu_p->g.magic_p) {
		case NMG_EDGE_G_LSEG_MAGIC:
			isect_ray_lseg(rd, eu_p);
			break;
		case NMG_EDGE_G_CNURB_MAGIC:
			isect_ray_cnurb(rd, eu_p);
			break;
		}
	}
}






/*	I S E C T _ R A Y _ L O O P U S E
 *
 */
static void
isect_ray_loopuse(struct ray_data *rd, struct loopuse *lu_p)
{
	struct edgeuse *eu_p;

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("isect_ray_loopuse( 0x%08x, loop:0x%08x)\n", rd, lu_p->l_p);

	NMG_CK_LOOPUSE(lu_p);
	NMG_CK_LOOP(lu_p->l_p);
	NMG_CK_LOOP_G(lu_p->l_p->lg_p);

	if (BU_LIST_FIRST_MAGIC(&lu_p->down_hd) == NMG_EDGEUSE_MAGIC) {
		for (BU_LIST_FOR(eu_p, edgeuse, &lu_p->down_hd)) {
			isect_ray_edgeuse(rd, eu_p);
		}
		return;

	} else if (BU_LIST_FIRST_MAGIC(&lu_p->down_hd)!=NMG_VERTEXUSE_MAGIC) {
		bu_log("in %s at %d", __FILE__, __LINE__);
		nmg_rt_bomb(rd, " bad loopuse child magic");
	}

	/* loopuse child is vertexuse */

	(void) isect_ray_vertexuse(rd,
		BU_LIST_FIRST(vertexuse, &lu_p->down_hd));
}



#ifndef FAST_NMG
#define FACE_MISS(rd, f_p) {\
	struct hitmiss *myhit; \
	GET_HITMISS(myhit, rd->ap); \
	NMG_INDEX_ASSIGN(rd->hitmiss, f_p, myhit); \
	myhit->hit.hit_private = (genptr_t)f_p; \
	BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_SUB_MAGIC); \
	BU_LIST_INSERT(&rd->rd_miss, &myhit->l); \
	NMG_CK_HITMISS(myhit); \
	NMG_CK_HITMISS_LISTS(myhit, rd); }
#else
#define FACE_MISS(rd, f_p) {\
	struct hitmiss *myhit; \
	GET_HITMISS(myhit, rd->ap); \
	NMG_INDEX_ASSIGN(rd->hitmiss, f_p, myhit); \
	myhit->hit.hit_private = (genptr_t)f_p; \
	BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_SUB_MAGIC); \
	BU_LIST_INSERT(&rd->rd_miss, &myhit->l); }
#endif


static void
eu_touch_func(struct edgeuse *eu, fastf_t *pt, char *priv)
{
	struct edgeuse *eu_next;
	struct ray_data *rd;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_EDGE(eu->e_p);
	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);

	eu_next = BU_LIST_PNEXT_CIRC(edgeuse, eu);

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("eu_touch(%g %g %g -> %g %g %g\n",
			eu->vu_p->v_p->vg_p->coord[0],
			eu->vu_p->v_p->vg_p->coord[1],
			eu->vu_p->v_p->vg_p->coord[2],
			eu_next->vu_p->v_p->vg_p->coord[0],
			eu_next->vu_p->v_p->vg_p->coord[1],
			eu_next->vu_p->v_p->vg_p->coord[2]);

	rd = (struct ray_data *)priv;
	rd->face_subhit = 1;

#ifndef FAST_NMG
	NMG_CK_HITMISS_LISTS(myhit, rd);
#endif
	ray_hit_edge(rd, eu, rd->ray_dist_to_plane, pt);
#ifndef FAST_NMG
	NMG_CK_HITMISS_LISTS(myhit, rd);
#endif

}


static void
vu_touch_func(struct vertexuse *vu, fastf_t *pt, char *priv)
{
	struct ray_data *rd;

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("vu_touch(%g %g %g)\n",
			vu->v_p->vg_p->coord[0],
			vu->v_p->vg_p->coord[1],
			vu->v_p->vg_p->coord[2]);

	rd = (struct ray_data *)priv;

	rd->face_subhit = 1;
	ray_hit_vertex(rd, vu, NMG_VERT_UNKNOWN);
}

static void
record_face_hit(struct ray_data *rd, struct hitmiss *myhit, fastf_t *plane_pt, double dist, struct faceuse *fu_p, fastf_t *norm, int a_hit)
{
	double cos_angle;

	BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_MAGIC);
	myhit->outbound_use = (long *)fu_p;
	myhit->inbound_use = (long *)fu_p;


	VMOVE(myhit->hit.hit_point, plane_pt);

	/* also rd->ray_dist_to_plane */
	myhit->hit.hit_dist = dist; 
	myhit->hit.hit_private = (genptr_t)fu_p->f_p;


	/* compute what the ray-state is before and after this
	 * encountering this hit point.
	 */
	cos_angle = VDOT(norm, rd->rp->r_dir);
	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		VPRINT("face Normal", norm);
		bu_log("cos_angle wrt ray direction: %g\n", cos_angle);
		bu_log( "fu x%x manifoldness = %d\n", fu_p, NMG_MANIFOLDS(rd->manifolds, fu_p) );
	}


	if ( ! (NMG_MANIFOLDS(rd->manifolds, fu_p) & NMG_3MANIFOLD) ) {
		myhit->in_out = HMG_HIT_ANY_ANY;

		if (cos_angle < rd->tol->perp) {
			VMOVE(myhit->inbound_norm, norm);
			VREVERSE(myhit->outbound_norm, norm);
			myhit->inbound_use = (long *)fu_p;
			myhit->outbound_use = (long *)fu_p->fumate_p;
		} else {
			VREVERSE(myhit->inbound_norm, norm);
			VMOVE(myhit->outbound_norm, norm);
			myhit->inbound_use = (long *)fu_p->fumate_p;
			myhit->outbound_use = (long *)fu_p;
		}

		return;
	}


	switch (fu_p->orientation) {
	case OT_SAME:
		if (BN_VECT_ARE_PERP(cos_angle, rd->tol)) {
			/* perpendicular? */
			bu_log("%s[%d]: Ray is in plane of face?\n",
				__FILE__, __LINE__);
				rt_bomb("record_face_hit() I quit\n");
		} else if (cos_angle > 0.0) {
			myhit->in_out = HMG_HIT_IN_OUT;
			VREVERSE(myhit->outbound_norm, norm);
			myhit->outbound_use = (long *)fu_p;
			myhit->inbound_use = (long *)fu_p;
		} else {
			myhit->in_out = HMG_HIT_OUT_IN;
			VMOVE(myhit->inbound_norm, norm);
			myhit->inbound_use = (long *)fu_p;
			myhit->outbound_use = (long *)fu_p;
		}
		break;
	case OT_OPPOSITE:
		if (BN_VECT_ARE_PERP(cos_angle, rd->tol)) {
			/* perpendicular? */
			bu_log("%s[%d]: Ray is in plane of face?\n",
				__FILE__, __LINE__);
				rt_bomb("record_face_hit() I quit\n");
		} else if (cos_angle > 0.0) {
			myhit->in_out = HMG_HIT_OUT_IN;
			VREVERSE(myhit->inbound_norm, norm);
			myhit->inbound_use = (long *)fu_p;
			myhit->outbound_use = (long *)fu_p;
		} else {
			myhit->in_out = HMG_HIT_IN_OUT;
			VMOVE(myhit->outbound_norm, norm);
			myhit->inbound_use = (long *)fu_p;
			myhit->outbound_use = (long *)fu_p;
		}
		break;
	default:
		bu_log("%s %d:face orientation not SAME/OPPOSITE\n",
			__FILE__, __LINE__);
		rt_bomb("record_face_hit() Crash and burn\n");
	}

	hit_ins(rd, myhit);
	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		nmg_rt_isect_plfu(fu_p, rd->rp->r_pt, myhit->hit.hit_point);

#ifndef FAST_NMG
	NMG_CK_HITMISS(myhit);
#endif

}

/* this is the UV-space tolerance for the NURB intersector, a larger number will
 * improve speed, but too large will produce errors. Perhaps a routine to calculate
 * an appropriate UV_TOL could be constructed.
 */
#define UV_TOL  1.0e-6

void
isect_ray_snurb_face(struct ray_data *rd, struct faceuse *fu, struct face_g_snurb *fg)
{
	plane_t pl, pl1, pl2;
	struct rt_nurb_uv_hit *hp;
	struct bu_list bezier;
	struct bu_list hit_list;
	struct face_g_snurb *srf;
	struct face *f;

	NMG_CK_RD( rd );
	NMG_CK_FACE_G_SNURB( fg );
	NMG_CK_FACEUSE( fu );

	f = fu->f_p;

	/* calculate two orthogonal planes that intersect along ray */
	bn_vec_ortho( pl2, rd->rp->r_dir );
	VCROSS( pl1, pl2, rd->rp->r_dir );
	pl1[3] = VDOT( rd->rp->r_pt, pl1 );
	pl2[3] = VDOT( rd->rp->r_pt, pl2 );

	BU_LIST_INIT( &bezier );
	BU_LIST_INIT( &hit_list );

	rt_nurb_bezier( &bezier, fg, rd->ap->a_resource );

	while( BU_LIST_NON_EMPTY( &bezier ) )
	{
		point_t srf_min, srf_max;
		int planar;
		point_t hit;
		fastf_t dist;

		srf = BU_LIST_FIRST( face_g_snurb,  &bezier );
		BU_LIST_DEQUEUE( &srf->l );

		/* calculate intersection points on NURB surface (in uv space) */
		/* check if NURB surface is a simple planar surface */
		if( srf->order[0] == 2 && srf->order[1] ==2 && srf->s_size[0] ==2 && srf->s_size[1] == 2 )
			planar = 1;
		else
			planar = 0;

		if( planar )
		{
			vect_t u_dir, v_dir;
			point_t ctl_pt[4];
			vect_t hit_dir;
			int i,j;
			int rational;
			int coords;
			fastf_t *pt;
			fastf_t u, v;

			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log( "isect_ray_snurb_face: face is planar\n" );

			rational = RT_NURB_IS_PT_RATIONAL( srf->pt_type );
			coords = RT_NURB_EXTRACT_COORDS( srf->pt_type );

			pt = srf->ctl_points;
			for( i=0 ; i<4 ; i++ )
			{
				for( j=0 ; j<coords ; j++ )
				{
					ctl_pt[i][j] = *pt;
					pt++;
				}
				if( rational )
				{
					for( j=0 ; j<coords-1 ; j++ )
						ctl_pt[i][j] = ctl_pt[i][j]/ctl_pt[i][coords-1];
				}
			}
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			{
				for( i=0 ; i<4 ; i++ )
					bu_log( "\tctl_point[%d] = (%g %g %g)\n", i, V3ARGS( ctl_pt[i] ) );
				bu_log( "uv range (%g %g) <-> (%g %g)\n", srf->u.knots[0], srf->v.knots[0], srf->u.knots[srf->u.k_size-1], srf->v.knots[srf->v.k_size-1] );
			}

			VSUB2( u_dir, ctl_pt[1], ctl_pt[0] );
			VSUB2( v_dir, ctl_pt[2], ctl_pt[0] );
			VCROSS( pl, u_dir, v_dir );
			VUNITIZE( pl );
			pl[3] = VDOT( pl, ctl_pt[0] );
			hp = (struct rt_nurb_uv_hit *)NULL;
			if( bn_isect_line3_plane( &dist,  rd->rp->r_pt,  rd->rp->r_dir, pl, rd->tol ) <= 0 )
			{
				if (rt_g.NMG_debug & DEBUG_RT_ISECT)
					bu_log( "\tNo intersection\n" );

				rt_nurb_free_snurb( srf, rd->ap->a_resource );
				continue;
			}

			VJOIN1( hit, rd->rp->r_pt, dist, rd->rp->r_dir )
			VSUB2( hit_dir, hit, ctl_pt[0] )
			u = srf->u.knots[0] + (srf->u.knots[srf->u.k_size-1] - srf->u.knots[0]) * VDOT( hit_dir, u_dir ) / MAGSQ( u_dir );
			v = srf->v.knots[0] + (srf->v.knots[srf->v.k_size-1] - srf->v.knots[0]) * VDOT( hit_dir, v_dir ) / MAGSQ( v_dir );

			if( u >= srf->u.knots[0] && u <= srf->u.knots[srf->u.k_size-1] &&
			    v >= srf->v.knots[0] && v <= srf->v.knots[srf->v.k_size-1] )
			{
				hp = (struct rt_nurb_uv_hit *)bu_calloc( 1, sizeof( struct rt_nurb_uv_hit ), "struct rt_nurb_uv_hit" );
				hp->next = (struct rt_nurb_uv_hit *)NULL;
				hp->sub = 0;
				hp->u = u;
				hp->v = v;

				if (rt_g.NMG_debug & DEBUG_RT_ISECT)
					bu_log( "\thit at uv=(%g %g), xyz=(%g %g %g)\n", hp->u, hp->v, V3ARGS( hit ) );
			}
		}
		else
		{
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log( "isect_ray_snurb_face: using planes (%g %g %g %g) (%g %g %g %g)\n",
					V4ARGS( pl1 ), V4ARGS( pl2 ) );
			(void)rt_nurb_s_bound( srf, srf_min, srf_max );
			if( !rt_in_rpp( rd->rp, rd->rd_invdir, srf_min, srf_max ) )
			{
				rt_nurb_free_snurb( srf, rd->ap->a_resource );
				continue;
			}
			hp = rt_nurb_intersect( srf, pl1, pl2, UV_TOL, rd->ap->a_resource );
		}

		/* process each hit point */
		while( hp != (struct rt_nurb_uv_hit *)NULL )
		{
			struct rt_nurb_uv_hit *next;
			struct hitmiss *myhit;
			vect_t to_hit;
			fastf_t dot;
			fastf_t homo_hit[4];
			int ot_sames, ot_opps;
			struct loopuse *lu;

			next = hp->next;

			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log( "\tintersect snurb surface at uv=(%g %g)\n", hp->u, hp->v );

			/* check if point is in face (trimming curves) */
			ot_sames = 0;
			ot_opps = 0;

			for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
			{
				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
					continue;

				if( lu->orientation == OT_SAME )
					ot_sames += nmg_uv_in_lu( hp->u, hp->v, lu );
				else if( lu->orientation == OT_OPPOSITE )
					ot_opps += nmg_uv_in_lu( hp->u, hp->v, lu );
				else
				{
					bu_log( "isect_ray_snurb_face: lu orientation = %s!!\n",
						nmg_orientation( lu->orientation ) );
					bu_bomb( "isect_ray_snurb_face: bad lu orientation\n" );
				}
			}

			if( ot_sames == 0 || ot_opps == ot_sames )
			{
				/* not a hit */

				if (rt_g.NMG_debug & DEBUG_RT_ISECT)
					bu_log( "\tNot a hit\n" );

				bu_free( (char *)hp, "hit" );
				hp = next;
				continue;
			}

			GET_HITMISS(myhit, rd->ap);
			NMG_INDEX_ASSIGN(rd->hitmiss, fu->f_p, myhit);
			myhit->hit.hit_private = (genptr_t)fu->f_p;
			myhit->inbound_use = myhit->outbound_use = &fu->l.magic;

			/* calculate actual hit point (x y z) */
			if( planar )
			{
				VMOVE( myhit->hit.hit_point, hit )
				myhit->hit.hit_dist = dist;
				VMOVE( myhit->hit.hit_normal, pl )
			}
			else
			{
				rt_nurb_s_eval( srf, hp->u, hp->v, homo_hit );
				if( RT_NURB_IS_PT_RATIONAL( srf->pt_type ) )
				{
					fastf_t inv_homo;

					inv_homo = 1.0/homo_hit[3];
					VSCALE( myhit->hit.hit_point, homo_hit, inv_homo )
				}
				else
					VMOVE( myhit->hit.hit_point, homo_hit )

				VSUB2( to_hit, myhit->hit.hit_point, rd->rp->r_pt );
				myhit->hit.hit_dist = VDOT( to_hit, rd->rp->r_dir );

				/* get surface normal */
				rt_nurb_s_norm( srf, hp->u, hp->v, myhit->hit.hit_normal );
			}

			/* may need to reverse it */
			if( f->flip )
				VREVERSE( myhit->hit.hit_normal, myhit->hit.hit_normal )

			dot = VDOT( myhit->hit.hit_normal, rd->rp->r_dir );

			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			{
				bu_log( "\thit at dist = %g (%g %g %g), norm = (%g %g %g)\n",
					myhit->hit.hit_dist,
					V3ARGS( myhit->hit.hit_point ),
					V3ARGS( myhit->hit.hit_normal ) );
				if( dot > 0.0 )
					bu_log( "\t\tdot = %g (exit point)\n", dot );
				else
					bu_log( "\t\tdot = %g (entrance point)\n", dot );
			}

			switch (fu->orientation) {
			case OT_SAME:
				if (BN_VECT_ARE_PERP(dot, rd->tol)) {
					/* perpendicular? */
					bu_log("%s[%d]: Ray is in plane of face?\n",
						__FILE__, __LINE__);
						rt_bomb("record_face_hit() I quit\n");
				} else if (dot > 0.0) {
					myhit->in_out = HMG_HIT_IN_OUT;
					VMOVE(myhit->outbound_norm, myhit->hit.hit_normal);
					myhit->outbound_use = (long *)fu;
					myhit->inbound_use = (long *)fu;
				} else {
					myhit->in_out = HMG_HIT_OUT_IN;
					VMOVE(myhit->inbound_norm, myhit->hit.hit_normal);
					myhit->inbound_use = (long *)fu;
					myhit->outbound_use = (long *)fu;
				}
				break;
			case OT_OPPOSITE:
				if (BN_VECT_ARE_PERP(dot, rd->tol)) {
					/* perpendicular? */
					bu_log("%s[%d]: Ray is in plane of face?\n",
						__FILE__, __LINE__);
						rt_bomb("record_face_hit() I quit\n");
				} else if (dot > 0.0) {
					myhit->in_out = HMG_HIT_OUT_IN;
					VREVERSE(myhit->inbound_norm, myhit->hit.hit_normal);
					myhit->inbound_use = (long *)fu;
					myhit->outbound_use = (long *)fu;
				} else {
					myhit->in_out = HMG_HIT_IN_OUT;
					VREVERSE(myhit->outbound_norm, myhit->hit.hit_normal);
					myhit->inbound_use = (long *)fu;
					myhit->outbound_use = (long *)fu;
				}
				break;
			default:
				bu_log("%s %d:face orientation not SAME/OPPOSITE\n",
					__FILE__, __LINE__);
				rt_bomb("record_face_hit() Crash and burn\n");
			}

			hit_ins( rd, myhit );

			bu_free( (char *)hp, "hit" );
			hp = next;
		}
		rt_nurb_free_snurb( srf, rd->ap->a_resource );
	}
}

void
isect_ray_planar_face(struct ray_data *rd, struct faceuse *fu_p, struct face_g_plane *fg_p)
{
	plane_t			norm;
	fastf_t			dist;
	struct hitmiss		*myhit;
	point_t			plane_pt;
	struct loopuse		*lu_p;
	int			pt_class;

	/* the geometric intersection of the ray with the plane 
	 * of the face has already been done by isect_ray_faceuse().
	 */
	NMG_GET_FU_PLANE( norm, fu_p );

	/* ray hits plane:
	 *
	 * Get the ray/plane intersection point.
	 * Then compute whether this point lies within the area of the face.
	 */

	VMOVE(plane_pt, rd->plane_pt )
	dist = rd->ray_dist_to_plane;

	if (DIST_PT_PLANE(plane_pt, norm) > rd->tol->dist) {
		bu_log("%s:%d plane_pt (%g %g %g) @@ dist (%g)out of tolerance\n",
			__FILE__, __LINE__, V3ARGS(plane_pt), dist);
		rt_bomb("isect_ray_planar_face() dist out of tol\n");
	}

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		double new_dist;
		bu_log("\tray (%16.10e %16.10e %16.10e) (-> %16.10e %16.10e %16.10e)\n",
			rd->rp->r_pt[0],
			rd->rp->r_pt[1],
			rd->rp->r_pt[2],
			rd->rp->r_dir[0],
			rd->rp->r_dir[1],
			rd->rp->r_dir[2]);
		bu_log("\tplane/ray intersection point (%16.10e %16.10e %16.10e)\n",
			V3ARGS(plane_pt));
		bu_log("\tdistance along ray to intersection point %16.10e\n", dist);

		new_dist=DIST_PT_PLANE(plane_pt, norm);

		bu_log("\tDIST_PT_PLANE(%16.10e) 0x%08lx 0x%08lx\n", new_dist,
			new_dist);
			
		bn_isect_line3_plane(&new_dist, plane_pt, rd->rp->r_dir,
			norm, rd->tol);

		bu_log("Normal %16.10e %16.10e %16.10e %16.10e)\n",
			V4ARGS(norm));
		bu_log("recalculated plane/pt dist as %16.10e 0x%08lx 0x%08lx\n",
			new_dist, new_dist);
		bu_log("distance tol = %16.10e\n", rd->tol->dist);
	}


	/* determine if the plane point is in or out of the face, and
	 * if it is within tolerance of any of the elements of the faceuse.
	 *
	 * The value of "rd->face_subhit" will be set non-zero if either
	 * eu_touch_func or vu_touch_func is called.  They will be called
	 * when an edge/vertex of the face is within tolerance of plane_pt.
	 */
	rd->face_subhit = 0;
	rd->ray_dist_to_plane = dist;
	if( rd->classifying_ray )
		pt_class = nmg_class_pt_fu_except(plane_pt, fu_p, (struct loopuse *)NULL,
			0, 0, (char *)rd, NMG_FPI_PERGEOM, 1,
			rd->tol);
	else
		pt_class = nmg_class_pt_fu_except(plane_pt, fu_p, (struct loopuse *)NULL,
			eu_touch_func, vu_touch_func, (char *)rd, NMG_FPI_PERGEOM, 0,
			rd->tol);


	GET_HITMISS(myhit, rd->ap);
	NMG_INDEX_ASSIGN(rd->hitmiss, fu_p->f_p, myhit);
	myhit->hit.hit_private = (genptr_t)fu_p->f_p;
	myhit->inbound_use = myhit->outbound_use = &fu_p->l.magic;



	switch (pt_class) {
	case NMG_CLASS_Unknown	:
		bu_log("%s[line:%d] ray/plane intercept point cannot be classified wrt face\n",
			__FILE__, __LINE__);
		rt_bomb("isect_ray_planar_face() class unknown\n");
		break;
	case NMG_CLASS_AinB	:
	case NMG_CLASS_AonBshared :
		/* if a sub-element of the face was within tolerance of the
		 * plane intercept, then a hit has already been recorded for
		 * that element, and we do NOT need to generate one for the
		 * face.
		 */
		if (rd->face_subhit) {
			BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_SUB_MAGIC);
			VMOVE(myhit->hit.hit_point, plane_pt);
			/* also rd->ray_dist_to_plane */
			myhit->hit.hit_dist = dist; 

			myhit->hit.hit_private = (genptr_t)fu_p->f_p;
			BU_LIST_INSERT(&rd->rd_miss, &myhit->l);
#ifndef FAST_NMG
			NMG_CK_HITMISS(myhit);
#endif
		} else {
			/* The plane_pt was NOT within tolerance of a 
			 * sub-element, but it WAS within the area of the 
			 * face.  We need to record a hit on the face
			 */
			record_face_hit(rd, myhit, plane_pt, dist, fu_p, norm, 0);
		}
		break;
	case NMG_CLASS_AoutB	:
		BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		BU_LIST_INSERT(&rd->rd_miss, &myhit->l);
#ifndef FAST_NMG
		NMG_CK_HITMISS(myhit);
#endif

		break;
	default	:
		bu_log("%s[line:%d] BIZZARE ray/plane intercept point classification\n",
			__FILE__, __LINE__);
		rt_bomb("isect_ray_planar_face() Bizz\n");
	}

	/* intersect the ray with the edges/verticies of the face */
	for ( BU_LIST_FOR(lu_p, loopuse, &fu_p->lu_hd) )
		isect_ray_loopuse(rd, lu_p);

}






/*	I S E C T _ R A Y _ F A C E U S E
 *
 *	check to see if ray hits face.
 */
static void
isect_ray_faceuse(struct ray_data *rd, struct faceuse *fu_p)
{

	struct hitmiss		*myhit;
	struct face		*fp;
	struct face_g_plane	*fgp;

	if (fu_p->orientation == OT_OPPOSITE) return;

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("isect_ray_faceuse(0x%08x, faceuse:0x%08x/face:0x%08x)\n",
			rd, fu_p, fu_p->f_p);

	NMG_CK_FACEUSE(fu_p);
	NMG_CK_FACEUSE(fu_p->fumate_p);
	fp = fu_p->f_p;
	NMG_CK_FACE(fp);


	/* if this face already processed, we are done. */
	if ( (myhit = NMG_INDEX_GET(rd->hitmiss, fp)) ) {
		if (BU_LIST_MAGIC_OK((struct bu_list *)myhit,
		    NMG_RT_HIT_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log(" previously hit\n");
		} else if (BU_LIST_MAGIC_OK((struct bu_list *)myhit,
		    NMG_RT_HIT_SUB_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log(" previously hit sub-element\n");
		} else if (BU_LIST_MAGIC_OK((struct bu_list *)myhit,
		    NMG_RT_MISS_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log(" previously missed\n");
		} else {
			bu_log("%s %d:\n\tBad magic %ld (0x%08x) for hitmiss struct for faceuse 0x%08x\n",
				__FILE__, __LINE__,
				myhit->l.magic, myhit->l.magic, fu_p);
			nmg_rt_bomb(rd, "Was I hit or not?\n");
		}
		return;
	}


	/* bounding box intersection */
	if( *fp->g.magic_p == NMG_FACE_G_PLANE_MAGIC )
	{
		int code;
		fastf_t dist;
		point_t hit_pt;

		fgp = fu_p->f_p->g.plane_p;
		NMG_CK_FACE_G_PLANE(fgp);

		code = bn_isect_line3_plane( &dist, rd->rp->r_pt, rd->rp->r_dir, fgp->N, rd->tol );
		if( code < 1 )
		{
			GET_HITMISS(myhit, rd->ap);
			NMG_INDEX_ASSIGN(rd->hitmiss, fu_p->f_p, myhit);
			myhit->hit.hit_private = (genptr_t)fu_p->f_p;
			BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
			BU_LIST_INSERT(&rd->rd_miss, &myhit->l);
#ifndef FAST_NMG
		    	NMG_CK_HITMISS(myhit);
#endif

			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("missed bounding box\n");
			return;
		}
		VJOIN1( hit_pt, rd->rp->r_pt, dist, rd->rp->r_dir )
		if( !V3PT_IN_RPP( hit_pt, fp->min_pt, fp->max_pt ) )
		{
			GET_HITMISS(myhit, rd->ap);
			NMG_INDEX_ASSIGN(rd->hitmiss, fu_p->f_p, myhit);
			myhit->hit.hit_private = (genptr_t)fu_p->f_p;
			BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
			BU_LIST_INSERT(&rd->rd_miss, &myhit->l);
#ifndef FAST_NMG
		    	NMG_CK_HITMISS(myhit);
#endif

			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("hit point not within face bounding box\n");
			return;
		}

		VMOVE( rd->plane_pt, hit_pt )
		rd->ray_dist_to_plane = dist;
	}
	else if (!rt_in_rpp(rd->rp, rd->rd_invdir,
	    fu_p->f_p->min_pt, fu_p->f_p->max_pt) ) {
		GET_HITMISS(myhit, rd->ap);
		NMG_INDEX_ASSIGN(rd->hitmiss, fu_p->f_p, myhit);
		myhit->hit.hit_private = (genptr_t)fu_p->f_p;
		BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		BU_LIST_INSERT(&rd->rd_miss, &myhit->l);
#ifndef FAST_NMG
	    	NMG_CK_HITMISS(myhit);
#endif

		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			bu_log("missed bounding box\n");
		return;
	}

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) bu_log(" hit bounding box \n");


	switch (*fu_p->f_p->g.magic_p) {
	case NMG_FACE_G_PLANE_MAGIC:
		isect_ray_planar_face(rd, fu_p, fu_p->f_p->g.plane_p);
		break;
	case NMG_FACE_G_SNURB_MAGIC:
		isect_ray_snurb_face(rd, fu_p, fu_p->f_p->g.snurb_p);
		break;
	}
}


/*	I S E C T _ R A Y _ S H E L L
 *
 *	Implicit return:
 *		adds hit points to the hit-list "hl"
 */
static void
nmg_isect_ray_shell(struct ray_data *rd, const struct shell *s_p)
{
	struct faceuse *fu_p;
	struct loopuse *lu_p;
	struct edgeuse *eu_p;

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("nmg_isect_ray_shell( 0x%08x, 0x%08x)\n", rd, s_p);

	NMG_CK_SHELL(s_p);
	NMG_CK_SHELL_A(s_p->sa_p);

	/* does ray isect shell rpp ?
	 * if not, we can just return.  there is no need to record the
	 * miss for the shell, as there is only one "use" of a shell.
	 */
	if (!rt_in_rpp(rd->rp, rd->rd_invdir,
	    s_p->sa_p->min_pt, s_p->sa_p->max_pt) ) {
		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			bu_log("nmg_isect_ray_shell( no RPP overlap)\n",
				 rd, s_p);
		return;
	}

	/* ray intersects shell, check sub-objects */

	for (BU_LIST_FOR(fu_p, faceuse, &(s_p->fu_hd)) )
		isect_ray_faceuse(rd, fu_p);

	for (BU_LIST_FOR(lu_p, loopuse, &(s_p->lu_hd)) )
		isect_ray_loopuse(rd, lu_p);

	for (BU_LIST_FOR(eu_p, edgeuse, &(s_p->eu_hd)) )
		isect_ray_edgeuse(rd, eu_p);

	if (s_p->vu_p)
		(void)isect_ray_vertexuse(rd, s_p->vu_p);

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("nmg_isect_ray_shell( done )\n", rd, s_p);
}


/*	N M G _ I S E C T _ R A Y _ M O D E L
 *
 */
void
nmg_isect_ray_model(struct ray_data *rd)
{
	struct nmgregion *r_p;
	struct shell *s_p;


	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log("isect_ray_nmg: Pnt(%g %g %g) Dir(%g %g %g)\n", 
			rd->rp->r_pt[0],
			rd->rp->r_pt[1],
			rd->rp->r_pt[2],
			rd->rp->r_dir[0],
			rd->rp->r_dir[1],
			rd->rp->r_dir[2]);

	NMG_CK_MODEL(rd->rd_m);

	/* Caller has assured us that the ray intersects the nmg model,
	 * check ray for intersecion with rpp's of nmgregion's
	 */
	for ( BU_LIST_FOR(r_p, nmgregion, &rd->rd_m->r_hd) ) {
		NMG_CK_REGION(r_p);
		NMG_CK_REGION_A(r_p->ra_p);

		/* does ray intersect nmgregion rpp? */
		if (! rt_in_rpp(rd->rp, rd->rd_invdir,
		    r_p->ra_p->min_pt, r_p->ra_p->max_pt) )
			continue;

		/* ray intersects region, check shell intersection */
		for (BU_LIST_FOR(s_p, shell, &r_p->s_hd)) {
			nmg_isect_ray_shell(rd, s_p);
		}
	}

#ifndef FAST_NMG
	NMG_CK_HITMISS_LISTS(a_hit, rd);
#endif

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		if (BU_LIST_IS_EMPTY(&rd->rd_hit)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				bu_log("ray missed NMG\n");
		} else {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				nmg_rt_print_hitlist((struct hitmiss*)&rd->rd_hit);
		}
	}
}

/*
 *				N M G _ P L _ H I T M I S S _ L I S T
 */
void
nmg_pl_hitmiss_list(const char *str, int num, const struct bu_list *hd, const struct xray *rp)
{
	FILE		*fp;
	char		buf[128];
	struct hitmiss	*hmp;
	int		count = 0;

	sprintf( buf, "%s%d.pl", str, num );

	if( bu_list_len(hd) <= 0 )  {
		bu_log("nmg_pl_hitmiss_list(): empty list, no %s written\n", buf);
		return;
	}

	if( (fp = fopen(buf, "w")) == (FILE *)NULL )  {
		perror(buf);
		return;
	}

	pl_color( fp, 210, 210, 210 );		/* grey ray */

	for( BU_LIST_FOR( hmp, hitmiss, hd ) )  {
		point_t		pt;
#ifndef FAST_NMG
		NMG_CK_HITMISS(hmp);
#endif
		VJOIN1( pt, rp->r_pt, hmp->hit.hit_dist, rp->r_dir );
		if( count++ )
			pdv_3cont( fp, pt );
		else
			pdv_3move( fp, pt );
	}
	fclose(fp);
	bu_log("overlay %s\n", buf);
}

static int
guess_class_from_hitlist_max(struct ray_data *rd, int *hari_kari, int in_or_out_only)
{
	struct hitmiss *a_hit;
	struct hitmiss *plus_hit = (struct hitmiss *)NULL;
	int pt_class;

	*hari_kari = 0;	

	NMG_CK_RD(rd);
	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
		bu_log("plus guessing\n");

	for (BU_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)) {

#ifndef FAST_NMG
		NMG_CK_HITMISS(a_hit);
#endif
		if( !in_or_out_only )
		{
			/* if we've got a zero distance hit, that clinches it */
			if (a_hit->hit.hit_dist <= rd->tol->dist &&
		    	    a_hit->hit.hit_dist >= -rd->tol->dist) {
				if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
					bu_log("guess_class_from_hitlist_min() returns NMG_CLASS_AonBshared for 0 dist hit\n");
	    	    
		    		return NMG_CLASS_AonBshared;
		    	}

			if (a_hit->hit.hit_dist < -rd->tol->dist)
				continue;
		}
		else if (a_hit->hit.hit_dist < 0.0)
			continue;

		if (a_hit->in_out == HMG_HIT_ANY_ANY)
			continue;

		if (plus_hit == (struct hitmiss *)NULL) {
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
				bu_log("plus hit = %g (%s)\n", a_hit->hit.hit_dist,
					nmg_rt_inout_str(a_hit->in_out));
			plus_hit = a_hit;
			*hari_kari = 0;
		} else if (a_hit->hit.hit_dist < plus_hit->hit.hit_dist) {
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
				bu_log("plus hit = %g (%s)\n", a_hit->hit.hit_dist,
					nmg_rt_inout_str(a_hit->in_out));
			plus_hit = a_hit;
			*hari_kari = 0;
		} else if ( a_hit->hit.hit_dist == plus_hit->hit.hit_dist) {
			*hari_kari = 1;
		}
	}

	/* XXX This needs to be resolved with parity */
	if (*hari_kari) {
		if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
			bu_log("Contemplating Hari Kari\n");
		return NMG_CLASS_Unknown;
	}
	/* figure out what the status is from plus_hit */
	if (plus_hit) {
		switch (plus_hit->in_out) {
		case HMG_HIT_IN_IN:
		case HMG_HIT_IN_OUT:
		case HMG_HIT_IN_ON:
			pt_class = NMG_CLASS_AinB;
			break;
		case HMG_HIT_OUT_IN:
		case HMG_HIT_OUT_OUT:
		case HMG_HIT_OUT_ON:
			pt_class = NMG_CLASS_AoutB;
			break;
		case HMG_HIT_ON_IN:
		case HMG_HIT_ON_ON:
		case HMG_HIT_ON_OUT:
			pt_class = NMG_CLASS_AonBshared;
			break;
		default:
			rt_bomb("guess_class_from_hitlist_max() no-class hitpoint\n");
			pt_class = 0; /* shuts up compiler warning */
			break;
		}
	} else {
		/* since we didn't hit anything in the positive direction,
		 * we've got to be outside, since we don't allow infinite
		 * NMG's
		 */
		if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
			bu_log("Nothing in the plus direction\n");
		pt_class = NMG_CLASS_AoutB;
	}

	return pt_class;
}

static int
guess_class_from_hitlist_min(struct ray_data *rd, int *hari_kari, int in_or_out_only)
{
	struct hitmiss *a_hit;
	struct hitmiss *minus_hit = (struct hitmiss *)NULL;
	int pt_class;

	*hari_kari = 0;
	
	NMG_CK_RD(rd);
	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
		bu_log("minus guessing\n");

	for (BU_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)) {

#ifndef FAST_NMG
		NMG_CK_HITMISS(a_hit);
#endif
		if( !in_or_out_only )
		{
			/* if we've got a zero distance hit, that clinches it */
			if (a_hit->hit.hit_dist <= rd->tol->dist &&
		    	    a_hit->hit.hit_dist >= -rd->tol->dist) {
				if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
					bu_log("guess_class_from_hitlist_min() returns NMG_CLASS_AonBshared for 0 dist hit\n");

		    		return NMG_CLASS_AonBshared;
		    	}

			if (a_hit->hit.hit_dist > rd->tol->dist)
				continue;
		}
		else if (a_hit->hit.hit_dist > 0.0)
			continue;

		if (a_hit->in_out == HMG_HIT_ANY_ANY)
			continue;

		if (minus_hit == (struct hitmiss *)NULL) {
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
				bu_log("minus hit = %g (%s)\n", a_hit->hit.hit_dist,
					nmg_rt_inout_str(a_hit->in_out));
			minus_hit = a_hit;
			*hari_kari = 0;
		} else if (a_hit->hit.hit_dist > minus_hit->hit.hit_dist) {
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
				bu_log("minus hit = %g (%s)\n", a_hit->hit.hit_dist,
					nmg_rt_inout_str(a_hit->in_out));
			minus_hit = a_hit;
			*hari_kari = 0;
		} else if ( a_hit->hit.hit_dist == minus_hit->hit.hit_dist) {
			*hari_kari = 1;
		}
	}

	/* XXX This needs to be resolved with parity */
	if (*hari_kari) {
		if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
			bu_log("Contemplating Hari Kari\n");
		return NMG_CLASS_Unknown;
	}

	/* figure out what the status is from plus_hit */
	if (minus_hit) {
		switch (minus_hit->in_out) {
		case HMG_HIT_IN_IN:
		case HMG_HIT_OUT_IN:
		case HMG_HIT_ON_IN:
			pt_class = NMG_CLASS_AinB;
			break;
		case HMG_HIT_OUT_OUT:
		case HMG_HIT_IN_OUT:
		case HMG_HIT_ON_OUT:
			pt_class = NMG_CLASS_AoutB;
			break;
		case HMG_HIT_ON_ON:
		case HMG_HIT_OUT_ON:
		case HMG_HIT_IN_ON:
			pt_class = NMG_CLASS_AonBshared;
			break;
		default:
			rt_bomb("guess_class_from_hitlist_min() no-class hitpoint\n");
			pt_class = 0; /* shuts up compiler warning */
			break;
		}
	} else {
		/* since we didn't hit anything in this direction,
		 * we've got to be outside, since we don't allow infinite
		 * NMG's
		 */
		if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
			bu_log("Nothing in the minus direction\n");
		pt_class = NMG_CLASS_AoutB;
	}

	return pt_class;
}


/*
 *	N M G _ R A Y _ I S E C T _ S H E L L
 *
 *	Intended as a support routine for nmg_class_pt_s() in nmg_class.c
 *
 *	Intersect a ray with a shell, and return whether the ray start
 *	point is inside or outside or ON the shell.
 *	Count the number of crossings (hit points) along the ray,
 *	both in the negative and positive directions.
 *	If an even number, point is outside, if an odd number point is inside.
 *	If the negative-going and positive-going assessments don't agree,
 *	this is a problem.
 *
 *	If "in_or_out_only" is non-zero, then we will not look for a
 *	classification of "ON" the shell.
 *
 *	The caller must be prepared for a return of NMG_CLASS_Unknown,
 *	in which case it should pick a less difficult ray direction to fire
 *	and try again.
 *
 *  Returns -
 *	NMG_CLASS_Unknown	Can't tell
 *	NMG_CLASS_xxx		Classification of the pt w.r.t. the shell.
 */
int
nmg_class_ray_vs_shell(struct xray *rp, const struct shell *s, const int in_or_out_only, const struct bn_tol *tol)
{
	struct ray_data rd;
	struct application ap;
	struct hitmiss *a_hit;
	int minus_class, plus_class;
	int hari_kari_minus, hari_kari_plus;


	VUNITIZE(rp->r_dir);
	NMG_CK_SHELL(s);
	BN_CK_TOL(tol);

	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT)) {
		bu_log("nmg_class_ray_vs_shell(pt(%g %g %g), dir(%g %g %g))\n",
			V3ARGS(rp->r_pt), V3ARGS(rp->r_dir));
	}

	memset(&ap, 0, sizeof(struct application));

	ap.a_resource = &rt_uniresource;
	rt_uniresource.re_magic = RESOURCE_MAGIC;

	if( BU_LIST_UNINITIALIZED( &rt_uniresource.re_nmgfree ) )
		BU_LIST_INIT( &rt_uniresource.re_nmgfree );

	rd.rd_m = nmg_find_model( &s->l.magic );
	rd.manifolds = nmg_manifolds(rd.rd_m);

	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
	{
		struct faceuse *fu;

		bu_log( "Manifoldness for shell FU's\n" );
		for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
		{
			if( fu->orientation != OT_SAME )
				continue;

			bu_log( "fu x%x: %d\n", fu, NMG_MANIFOLDS( rd.manifolds, fu ) );
		}
	}

	/* Compute the inverse of the direction cosines */
	if( !NEAR_ZERO( rp->r_dir[X], SQRT_SMALL_FASTF ) )  {
		rd.rd_invdir[X]=1.0/rp->r_dir[X];
	} else {
		rd.rd_invdir[X] = INFINITY;
		rp->r_dir[X] = 0.0;
	}
	if( !NEAR_ZERO( rp->r_dir[Y], SQRT_SMALL_FASTF ) )  {
		rd.rd_invdir[Y]=1.0/rp->r_dir[Y];
	} else {
		rd.rd_invdir[Y] = INFINITY;
		rp->r_dir[Y] = 0.0;
	}
	if( !NEAR_ZERO( rp->r_dir[Z], SQRT_SMALL_FASTF ) )  {
		rd.rd_invdir[Z]=1.0/rp->r_dir[Z];
	} else {
		rd.rd_invdir[Z] = INFINITY;
		rp->r_dir[Z] = 0.0;
	}

	rd.rp = rp;
	rd.tol = tol;
	rd.ap = &ap;
	rd.stp = (struct soltab *)NULL;
	rd.seghead = (struct seg *)NULL;
	rd.magic = NMG_RAY_DATA_MAGIC;
	rd.hitmiss = (struct hitmiss **)bu_calloc( rd.rd_m->maxindex,
		sizeof(struct hitmiss *), "nmg geom hit list");
	rd.classifying_ray = 1;

	/* initialize the lists of things that have been hit/missed */
	BU_LIST_INIT(&rd.rd_hit);
	BU_LIST_INIT(&rd.rd_miss);

	nmg_isect_ray_shell( &rd, s);
#ifndef FAST_NMG
	while (BU_LIST_WHILE(a_hit, hitmiss, &rd.rd_miss)) {
		BU_LIST_DEQUEUE( &a_hit->l );
		bu_free( (char *)a_hit, "Miss list hitmiss struct" );
	}
#else
	NMG_FREE_HITLIST( &rd.rd_miss, &ap );
#endif
	/* count the number of hits */
	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT)) {
		bu_log("%s[%d]: shell Hits:\n", __FILE__, __LINE__);
		for( BU_LIST_FOR( a_hit, hitmiss, &rd.rd_hit ) )  {
			if (a_hit->hit.hit_dist >= 0.0)
				bu_log("Positive dist hit\n");
			else
				bu_log("Negative dist hit\n");
			nmg_rt_print_hitmiss(a_hit);
		}
	}

	if( (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT)) &&
	    (rt_g.NMG_debug & (DEBUG_PLOTEM)) )  {
	    	static int	num=0;
		nmg_pl_hitmiss_list( "shell-ray", num++, &rd.rd_hit, rp );
	}

	minus_class = guess_class_from_hitlist_min(&rd, &hari_kari_minus, in_or_out_only);
	plus_class = guess_class_from_hitlist_max(&rd, &hari_kari_plus, in_or_out_only);

	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT)) {
		bu_log("minus_class = (%s)\n", nmg_class_name(minus_class));
		bu_log("plus_class = (%s)\n", nmg_class_name(plus_class));
	}


#if 0
	/* XXX This should be fixed in the guess_* routines
	 * instead of being fudged here.
	 */
	if (hari_kari_minus) {
		if(hari_kari_plus)
			rt_bomb("double hari kari");
		if (plus_class == NMG_CLASS_Unknown) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				nmg_rt_print_hitlist(&rd.rd_hit);
			rt_bomb("minus hari kari & plus unknown");
		}
		minus_class = plus_class;

	} else if (minus_class == NMG_CLASS_Unknown) {
		if (plus_class == NMG_CLASS_Unknown) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				nmg_rt_print_hitlist(&rd.rd_hit);
			rt_bomb("minus unknown & plus unknown");
		}
		minus_class = plus_class;
	} else if (plus_class == NMG_CLASS_Unknown || hari_kari_plus) {
		plus_class = minus_class;
	}


	if (plus_class != minus_class) {
		bu_log("%s:%d plus_class (%s) != minus_class (%s)\n",
			__FILE__, __LINE__,
			nmg_class_name(plus_class),
			nmg_class_name(minus_class) );

		nmg_rt_print_hitlist(&rd.rd_hit);
		rt_bomb("");
	}
#else
	/*
	 *  Rather than blowing up, or guessing, just report that
	 *  it didn't work, and let caller try another direction.
	 */
	if( hari_kari_minus || hari_kari_plus )  {
		if(rt_g.NMG_debug)
			bu_log("hari_kari = %d, %d\n", hari_kari_minus, hari_kari_plus);
		plus_class = NMG_CLASS_Unknown;
		goto out;
	}
	if (plus_class != minus_class || plus_class == NMG_CLASS_Unknown ||
	    minus_class == NMG_CLASS_Unknown ) {
#if 0
		nmg_rt_print_hitlist(&rd.rd_hit);
		bu_log("minus_class = (%s) %d, hari_kari=%d\n", nmg_class_name(minus_class), minus_class, hari_kari_minus);
		bu_log("plus_class = (%s)\n", nmg_class_name(plus_class));
		bu_log("nmg_class_ray_vs_shell() -- can't tell\n");
#endif
		plus_class = NMG_CLASS_Unknown;
	}
out:
#endif

#ifndef FAST_NMG
	while (BU_LIST_WHILE(a_hit, hitmiss, &rd.rd_hit)) {
		BU_LIST_DEQUEUE( &a_hit->l );
		bu_free( (char *)a_hit, "hit list hitmiss struct" );
	}
#else
	NMG_FREE_HITLIST( &rd.rd_hit, &ap );
#endif

	/* free the hitmiss freelist */
	if( !BU_LIST_UNINITIALIZED( &rt_uniresource.re_nmgfree ) )  {
		struct hitmiss *hitp;
		while( BU_LIST_WHILE( hitp, hitmiss, &rt_uniresource.re_nmgfree ) )  {
			NMG_CK_HITMISS(hitp);
			BU_LIST_DEQUEUE( (struct bu_list *)hitp );
			bu_free( (genptr_t)hitp, "struct hitmiss" );
		}
	}

	/* free the hitmiss table */
	bu_free( (char *)rd.hitmiss, "free nmg geom hit list");

	/* free the manifold table */
	bu_free( (char *)rd.manifolds, "free manifolds table" );

	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
		bu_log("nmg_class_ray_vs_shell() returns %s(%d)\n",
			nmg_class_name(plus_class), plus_class);


	return plus_class;
}
@


11.53
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_rt_isect.c,v 11.52 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.52
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d26 5
a30 1
#include "conf.h"
@


11.51
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.50 2002/08/20 17:08:06 jra Exp $ (ARL)";
d43 1
a43 2
nmg_rt_inout_str( code )
int	code;
d69 1
a69 2
nmg_rt_state_str( code )
int	code;
d90 1
a90 2
nmg_ck_hitmiss_list( hd )
const struct bu_list	*hd;
d125 1
a125 4
nmg_rt_isect_plfu( fu, pt, plane_pt )
struct faceuse *fu;
point_t pt;
point_t plane_pt;
d162 1
a162 4
pleu( eu, pt, plane_pt)
struct edgeuse *eu;
point_t pt;
point_t plane_pt;
d204 1
a204 2
plvu(vu)
struct vertexuse *vu;
d209 1
a209 2
nmg_rt_print_hitmiss(a_hit)
struct hitmiss *a_hit;
d231 1
a231 2
nmg_rt_print_hitlist(hl)
struct hitmiss *hl;
d252 1
a252 3
hit_ins(rd, newhit)
struct ray_data *rd;
struct hitmiss *newhit;
d294 1
a294 3
ray_miss_vertex(rd, vu_p)
struct ray_data *rd;
struct vertexuse *vu_p;
d350 1
a350 15
get_pole_dist_to_face(rd, vu,
	Pole, Pole_prj_pt, Pole_dist, Pole_pca,
	pointA, leftA, pointB, leftB, polar_height_vect, Pole_name)
struct ray_data *rd;
struct vertexuse *vu;
point_t Pole;
point_t Pole_prj_pt;
double *Pole_dist;
point_t Pole_pca;
point_t pointA;
vect_t leftA;
point_t pointB;
vect_t leftB;
vect_t polar_height_vect;
char *Pole_name;
d572 1
a572 16
plot_neighborhood( North_Pole, North_pl_pt, North_pca,
		South_Pole, South_pl_pt, South_pca,
		pointA, pointB, norm, 
		pt, leftA, leftB)
point_t North_Pole;
point_t North_pl_pt;
point_t North_pca;
point_t South_Pole;
point_t South_pl_pt;
point_t South_pca;
point_t pointA;
point_t pointB;
vect_t norm;
point_t pt;
vect_t leftA;
vect_t leftB;
d711 1
a711 4
vertex_neighborhood(rd, vu_p, myhit)
struct ray_data *rd;
struct vertexuse *vu_p;
struct hitmiss *myhit;
d967 1
a967 4
ray_hit_vertex(rd, vu_p, status)
struct ray_data *rd;
struct vertexuse *vu_p;
int status;
d1031 1
a1031 3
isect_ray_vertexuse(rd, vu_p)
struct ray_data *rd;
struct vertexuse *vu_p;
d1097 1
a1097 3
colinear_edge_ray(rd, eu_p)
struct ray_data *rd;
struct edgeuse *eu_p;
d1181 1
a1181 4
edge_hit_ray_state(rd, eu, myhit)
struct ray_data *rd;
struct edgeuse *eu;
struct hitmiss *myhit;
d1408 1
a1408 5
ray_hit_edge(rd, eu_p, dist_along_ray, pt)
struct ray_data *rd;
struct edgeuse *eu_p;
double dist_along_ray;
point_t pt;
d1477 1
a1477 3
isect_ray_cnurb(rd, eu_p)
struct ray_data *rd;
struct edgeuse *eu_p;
d1482 1
a1482 3
isect_ray_lseg(rd, eu_p)
struct ray_data *rd;
struct edgeuse *eu_p;
d1601 1
a1601 3
isect_ray_edgeuse(rd, eu_p)
struct ray_data *rd;
struct edgeuse *eu_p;
d1676 1
a1676 3
isect_ray_loopuse(rd, lu_p)
struct ray_data *rd;
struct loopuse *lu_p;
d1728 1
a1728 4
eu_touch_func(eu, pt, priv)
struct edgeuse *eu;
point_t pt;
char *priv;
d1767 1
a1767 4
vu_touch_func(vu, pt, priv)
struct vertexuse *vu;
point_t pt;
char *priv;
d1784 1
a1784 7
record_face_hit(rd, myhit, plane_pt, dist, fu_p, norm, a_hit)
struct ray_data *rd;
struct hitmiss *myhit;
point_t plane_pt;
double dist;
struct faceuse *fu_p;
plane_t norm;
d1890 1
a1890 4
isect_ray_snurb_face(rd, fu, fg)
struct ray_data *rd;
struct faceuse *fu;
struct face_g_snurb *fg;
d2170 1
a2170 4
isect_ray_planar_face(rd, fu_p, fg_p)
struct ray_data *rd;
struct faceuse *fu_p;
struct face_g_plane *fg_p;
d2283 1
a2283 2
			record_face_hit(rd, myhit, plane_pt, dist,
				fu_p, norm);
d2316 1
a2316 3
isect_ray_faceuse(rd, fu_p)
struct ray_data *rd;
struct faceuse *fu_p;
d2441 1
a2441 3
nmg_isect_ray_shell(rd, s_p)
struct ray_data *rd;
struct shell *s_p;
d2488 1
a2488 2
nmg_isect_ray_model(rd)
struct ray_data *rd;
d2542 1
a2542 5
nmg_pl_hitmiss_list( str, num, hd, rp )
const char		*str;
int			num;
const struct bu_list	*hd;
const struct xray	*rp;
d2579 1
a2579 4
guess_class_from_hitlist_max(rd, hari_kari, in_or_out_only)
struct ray_data *rd;
int *hari_kari;
int in_or_out_only;
d2676 1
a2676 4
guess_class_from_hitlist_min(rd, hari_kari, in_or_out_only)
struct ray_data *rd;
int *hari_kari;
int in_or_out_only;
d2799 1
a2799 5
nmg_class_ray_vs_shell(rp, s, in_or_out_only, tol)
struct xray *rp;
const struct shell *s;
const int in_or_out_only;
const struct bn_tol *tol;
@


11.50
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.48 2001/04/20 22:29:53 morrison Exp $ (ARL)";
@


11.50.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.51 2004/02/02 17:39:25 morrison Exp $ (ARL)";
@


11.50.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.51 2004/02/02 17:39:25 morrison Exp $ (ARL)";
@


11.50.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.50.10.1 2004/02/12 18:37:45 erikg Exp $ (ARL)";
@


11.50.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.50 2002/08/20 17:08:06 jra Exp $ (ARL)";
d43 2
a44 1
nmg_rt_inout_str(int code)
d70 2
a71 1
nmg_rt_state_str(int code)
d92 2
a93 1
nmg_ck_hitmiss_list(const struct bu_list *hd)
d128 4
a131 1
nmg_rt_isect_plfu(struct faceuse *fu, fastf_t *pt, fastf_t *plane_pt)
d168 4
a171 1
pleu(struct edgeuse *eu, fastf_t *pt, fastf_t *plane_pt)
d213 2
a214 1
plvu(struct vertexuse *vu)
d219 2
a220 1
nmg_rt_print_hitmiss(struct hitmiss *a_hit)
d242 2
a243 1
nmg_rt_print_hitlist(struct hitmiss *hl)
d264 3
a266 1
hit_ins(struct ray_data *rd, struct hitmiss *newhit)
d308 3
a310 1
ray_miss_vertex(struct ray_data *rd, struct vertexuse *vu_p)
d366 15
a380 1
get_pole_dist_to_face(struct ray_data *rd, struct vertexuse *vu, fastf_t *Pole, fastf_t *Pole_prj_pt, double *Pole_dist, fastf_t *Pole_pca, fastf_t *pointA, fastf_t *leftA, fastf_t *pointB, fastf_t *leftB, fastf_t *polar_height_vect, char *Pole_name)
d602 16
a617 1
plot_neighborhood(fastf_t *North_Pole, fastf_t *North_pl_pt, fastf_t *North_pca, fastf_t *South_Pole, fastf_t *South_pl_pt, fastf_t *South_pca, fastf_t *pointA, fastf_t *pointB, fastf_t *norm, fastf_t *pt, fastf_t *leftA, fastf_t *leftB)
d756 4
a759 1
vertex_neighborhood(struct ray_data *rd, struct vertexuse *vu_p, struct hitmiss *myhit)
d1015 4
a1018 1
ray_hit_vertex(struct ray_data *rd, struct vertexuse *vu_p, int status)
d1082 3
a1084 1
isect_ray_vertexuse(struct ray_data *rd, struct vertexuse *vu_p)
d1150 3
a1152 1
colinear_edge_ray(struct ray_data *rd, struct edgeuse *eu_p)
d1236 4
a1239 1
edge_hit_ray_state(struct ray_data *rd, struct edgeuse *eu, struct hitmiss *myhit)
d1466 5
a1470 1
ray_hit_edge(struct ray_data *rd, struct edgeuse *eu_p, double dist_along_ray, fastf_t *pt)
d1539 3
a1541 1
isect_ray_cnurb(struct ray_data *rd, struct edgeuse *eu_p)
d1546 3
a1548 1
isect_ray_lseg(struct ray_data *rd, struct edgeuse *eu_p)
d1667 3
a1669 1
isect_ray_edgeuse(struct ray_data *rd, struct edgeuse *eu_p)
d1744 3
a1746 1
isect_ray_loopuse(struct ray_data *rd, struct loopuse *lu_p)
d1798 4
a1801 1
eu_touch_func(struct edgeuse *eu, fastf_t *pt, char *priv)
d1840 4
a1843 1
vu_touch_func(struct vertexuse *vu, fastf_t *pt, char *priv)
d1860 7
a1866 1
record_face_hit(struct ray_data *rd, struct hitmiss *myhit, fastf_t *plane_pt, double dist, struct faceuse *fu_p, fastf_t *norm, int a_hit)
d1972 4
a1975 1
isect_ray_snurb_face(struct ray_data *rd, struct faceuse *fu, struct face_g_snurb *fg)
d2255 4
a2258 1
isect_ray_planar_face(struct ray_data *rd, struct faceuse *fu_p, struct face_g_plane *fg_p)
d2371 2
a2372 1
			record_face_hit(rd, myhit, plane_pt, dist, fu_p, norm, 0);
d2405 3
a2407 1
isect_ray_faceuse(struct ray_data *rd, struct faceuse *fu_p)
d2532 3
a2534 1
nmg_isect_ray_shell(struct ray_data *rd, const struct shell *s_p)
d2581 2
a2582 1
nmg_isect_ray_model(struct ray_data *rd)
d2636 5
a2640 1
nmg_pl_hitmiss_list(const char *str, int num, const struct bu_list *hd, const struct xray *rp)
d2677 4
a2680 1
guess_class_from_hitlist_max(struct ray_data *rd, int *hari_kari, int in_or_out_only)
d2777 4
a2780 1
guess_class_from_hitlist_min(struct ray_data *rd, int *hari_kari, int in_or_out_only)
d2903 5
a2907 1
nmg_class_ray_vs_shell(struct xray *rp, const struct shell *s, const int in_or_out_only, const struct bn_tol *tol)
@


11.50.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.49
log
@Converted from K&R to ANSI C - RFH
@
text
@d43 2
a44 1
nmg_rt_inout_str(int code)
d70 2
a71 1
nmg_rt_state_str(int code)
d92 2
a93 1
nmg_ck_hitmiss_list(const struct bu_list *hd)
d128 4
a131 1
nmg_rt_isect_plfu(struct faceuse *fu, fastf_t *pt, fastf_t *plane_pt)
d168 4
a171 1
pleu(struct edgeuse *eu, fastf_t *pt, fastf_t *plane_pt)
d213 2
a214 1
plvu(struct vertexuse *vu)
d219 2
a220 1
nmg_rt_print_hitmiss(struct hitmiss *a_hit)
d242 2
a243 1
nmg_rt_print_hitlist(struct hitmiss *hl)
d264 3
a266 1
hit_ins(struct ray_data *rd, struct hitmiss *newhit)
d308 3
a310 1
ray_miss_vertex(struct ray_data *rd, struct vertexuse *vu_p)
d366 15
a380 1
get_pole_dist_to_face(struct ray_data *rd, struct vertexuse *vu, fastf_t *Pole, fastf_t *Pole_prj_pt, double *Pole_dist, fastf_t *Pole_pca, fastf_t *pointA, fastf_t *leftA, fastf_t *pointB, fastf_t *leftB, fastf_t *polar_height_vect, char *Pole_name)
d602 16
a617 1
plot_neighborhood(fastf_t *North_Pole, fastf_t *North_pl_pt, fastf_t *North_pca, fastf_t *South_Pole, fastf_t *South_pl_pt, fastf_t *South_pca, fastf_t *pointA, fastf_t *pointB, fastf_t *norm, fastf_t *pt, fastf_t *leftA, fastf_t *leftB)
d756 4
a759 1
vertex_neighborhood(struct ray_data *rd, struct vertexuse *vu_p, struct hitmiss *myhit)
d1015 4
a1018 1
ray_hit_vertex(struct ray_data *rd, struct vertexuse *vu_p, int status)
d1082 3
a1084 1
isect_ray_vertexuse(struct ray_data *rd, struct vertexuse *vu_p)
d1150 3
a1152 1
colinear_edge_ray(struct ray_data *rd, struct edgeuse *eu_p)
d1236 4
a1239 1
edge_hit_ray_state(struct ray_data *rd, struct edgeuse *eu, struct hitmiss *myhit)
d1466 5
a1470 1
ray_hit_edge(struct ray_data *rd, struct edgeuse *eu_p, double dist_along_ray, fastf_t *pt)
d1539 3
a1541 1
isect_ray_cnurb(struct ray_data *rd, struct edgeuse *eu_p)
d1546 3
a1548 1
isect_ray_lseg(struct ray_data *rd, struct edgeuse *eu_p)
d1667 3
a1669 1
isect_ray_edgeuse(struct ray_data *rd, struct edgeuse *eu_p)
d1744 3
a1746 1
isect_ray_loopuse(struct ray_data *rd, struct loopuse *lu_p)
d1798 4
a1801 1
eu_touch_func(struct edgeuse *eu, fastf_t *pt, char *priv)
d1840 4
a1843 1
vu_touch_func(struct vertexuse *vu, fastf_t *pt, char *priv)
d1860 7
a1866 1
record_face_hit(struct ray_data *rd, struct hitmiss *myhit, fastf_t *plane_pt, double dist, struct faceuse *fu_p, fastf_t *norm, int a_hit)
d1972 4
a1975 1
isect_ray_snurb_face(struct ray_data *rd, struct faceuse *fu, struct face_g_snurb *fg)
d2255 4
a2258 1
isect_ray_planar_face(struct ray_data *rd, struct faceuse *fu_p, struct face_g_plane *fg_p)
d2371 2
a2372 1
			record_face_hit(rd, myhit, plane_pt, dist, fu_p, norm, 0);
d2405 3
a2407 1
isect_ray_faceuse(struct ray_data *rd, struct faceuse *fu_p)
d2532 3
a2534 1
nmg_isect_ray_shell(struct ray_data *rd, const struct shell *s_p)
d2581 2
a2582 1
nmg_isect_ray_model(struct ray_data *rd)
d2636 5
a2640 1
nmg_pl_hitmiss_list(const char *str, int num, const struct bu_list *hd, const struct xray *rp)
d2677 4
a2680 1
guess_class_from_hitlist_max(struct ray_data *rd, int *hari_kari, int in_or_out_only)
d2777 4
a2780 1
guess_class_from_hitlist_min(struct ray_data *rd, int *hari_kari, int in_or_out_only)
d2903 5
a2907 1
nmg_class_ray_vs_shell(struct xray *rp, const struct shell *s, const int in_or_out_only, const struct bn_tol *tol)
@


11.48
log
@CONST to const
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.47 2000/11/14 21:13:21 jra Exp $ (ARL)";
d43 1
a43 2
nmg_rt_inout_str( code )
int	code;
d69 1
a69 2
nmg_rt_state_str( code )
int	code;
d90 1
a90 2
nmg_ck_hitmiss_list( hd )
const struct bu_list	*hd;
d125 1
a125 4
nmg_rt_isect_plfu( fu, pt, plane_pt )
struct faceuse *fu;
point_t pt;
point_t plane_pt;
d162 1
a162 4
pleu( eu, pt, plane_pt)
struct edgeuse *eu;
point_t pt;
point_t plane_pt;
d204 1
a204 2
plvu(vu)
struct vertexuse *vu;
d209 1
a209 2
nmg_rt_print_hitmiss(a_hit)
struct hitmiss *a_hit;
d231 1
a231 2
nmg_rt_print_hitlist(hl)
struct hitmiss *hl;
d252 1
a252 3
hit_ins(rd, newhit)
struct ray_data *rd;
struct hitmiss *newhit;
d294 1
a294 3
ray_miss_vertex(rd, vu_p)
struct ray_data *rd;
struct vertexuse *vu_p;
d350 1
a350 15
get_pole_dist_to_face(rd, vu,
	Pole, Pole_prj_pt, Pole_dist, Pole_pca,
	pointA, leftA, pointB, leftB, polar_height_vect, Pole_name)
struct ray_data *rd;
struct vertexuse *vu;
point_t Pole;
point_t Pole_prj_pt;
double *Pole_dist;
point_t Pole_pca;
point_t pointA;
vect_t leftA;
point_t pointB;
vect_t leftB;
vect_t polar_height_vect;
char *Pole_name;
d572 1
a572 16
plot_neighborhood( North_Pole, North_pl_pt, North_pca,
		South_Pole, South_pl_pt, South_pca,
		pointA, pointB, norm, 
		pt, leftA, leftB)
point_t North_Pole;
point_t North_pl_pt;
point_t North_pca;
point_t South_Pole;
point_t South_pl_pt;
point_t South_pca;
point_t pointA;
point_t pointB;
vect_t norm;
point_t pt;
vect_t leftA;
vect_t leftB;
d711 1
a711 4
vertex_neighborhood(rd, vu_p, myhit)
struct ray_data *rd;
struct vertexuse *vu_p;
struct hitmiss *myhit;
d967 1
a967 4
ray_hit_vertex(rd, vu_p, status)
struct ray_data *rd;
struct vertexuse *vu_p;
int status;
d1031 1
a1031 3
isect_ray_vertexuse(rd, vu_p)
struct ray_data *rd;
struct vertexuse *vu_p;
d1097 1
a1097 3
colinear_edge_ray(rd, eu_p)
struct ray_data *rd;
struct edgeuse *eu_p;
d1181 1
a1181 4
edge_hit_ray_state(rd, eu, myhit)
struct ray_data *rd;
struct edgeuse *eu;
struct hitmiss *myhit;
d1408 1
a1408 5
ray_hit_edge(rd, eu_p, dist_along_ray, pt)
struct ray_data *rd;
struct edgeuse *eu_p;
double dist_along_ray;
point_t pt;
d1477 1
a1477 3
isect_ray_cnurb(rd, eu_p)
struct ray_data *rd;
struct edgeuse *eu_p;
d1482 1
a1482 3
isect_ray_lseg(rd, eu_p)
struct ray_data *rd;
struct edgeuse *eu_p;
d1601 1
a1601 3
isect_ray_edgeuse(rd, eu_p)
struct ray_data *rd;
struct edgeuse *eu_p;
d1676 1
a1676 3
isect_ray_loopuse(rd, lu_p)
struct ray_data *rd;
struct loopuse *lu_p;
d1728 1
a1728 4
eu_touch_func(eu, pt, priv)
struct edgeuse *eu;
point_t pt;
char *priv;
d1767 1
a1767 4
vu_touch_func(vu, pt, priv)
struct vertexuse *vu;
point_t pt;
char *priv;
d1784 1
a1784 7
record_face_hit(rd, myhit, plane_pt, dist, fu_p, norm, a_hit)
struct ray_data *rd;
struct hitmiss *myhit;
point_t plane_pt;
double dist;
struct faceuse *fu_p;
plane_t norm;
d1890 1
a1890 4
isect_ray_snurb_face(rd, fu, fg)
struct ray_data *rd;
struct faceuse *fu;
struct face_g_snurb *fg;
d2170 1
a2170 4
isect_ray_planar_face(rd, fu_p, fg_p)
struct ray_data *rd;
struct faceuse *fu_p;
struct face_g_plane *fg_p;
d2283 1
a2283 2
			record_face_hit(rd, myhit, plane_pt, dist,
				fu_p, norm);
d2316 1
a2316 3
isect_ray_faceuse(rd, fu_p)
struct ray_data *rd;
struct faceuse *fu_p;
d2441 1
a2441 3
nmg_isect_ray_shell(rd, s_p)
struct ray_data *rd;
struct shell *s_p;
d2488 1
a2488 2
nmg_isect_ray_model(rd)
struct ray_data *rd;
d2542 1
a2542 5
nmg_pl_hitmiss_list( str, num, hd, rp )
const char		*str;
int			num;
const struct bu_list	*hd;
const struct xray	*rp;
d2579 1
a2579 4
guess_class_from_hitlist_max(rd, hari_kari, in_or_out_only)
struct ray_data *rd;
int *hari_kari;
int in_or_out_only;
d2676 1
a2676 4
guess_class_from_hitlist_min(rd, hari_kari, in_or_out_only)
struct ray_data *rd;
int *hari_kari;
int in_or_out_only;
d2799 1
a2799 5
nmg_class_ray_vs_shell(rp, s, in_or_out_only, tol)
struct xray *rp;
const struct shell *s;
const int in_or_out_only;
const struct bn_tol *tol;
@


11.47
log
@Eliminated pmalloc (a failed experiment)
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.46 2000/10/18 18:10:35 butler Exp $ (ARL)";
d42 1
a42 1
CONST char *
d69 1
a69 1
CONST char *
d93 1
a93 1
CONST struct bu_list	*hd;
d2637 1
a2637 1
CONST char		*str;
d2639 2
a2640 2
CONST struct bu_list	*hd;
CONST struct xray	*rp;
@


11.46
log
@Patches for compiling under RedHat 7.0
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.45 2000/08/29 03:38:25 butler Exp $ (ARL)";
d271 1
d2079 1
a2079 1
				hp = (struct rt_nurb_uv_hit *)rt_pmalloc( sizeof( struct rt_nurb_uv_hit ), &rd->ap->a_resource->re_pmem );
d2147 1
a2147 1
				rt_pfree( (char *)hp, &rd->ap->a_resource->re_pmem );
d2247 1
a2247 1
			rt_pfree( (char *)hp, &rd->ap->a_resource->re_pmem );
@


11.45
log
@Fixed compiler warnings
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.44 2000/08/21 02:02:33 butler Exp $ (ARL)";
d29 3
@


11.44
log
@Massive compilation warnings eliminated
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.43 2000/07/10 23:01:45 mike Exp $ (ARL)";
d760 4
a763 2
	struct faceuse *North_fu, *South_fu;
	struct vertexuse *North_vu, *South_vu;
d1242 4
a1245 4
	struct faceuse *inb_fu;
	struct faceuse *outb_fu;
	struct edgeuse *inb_eu;
	struct edgeuse *outb_eu;
d2687 1
d2756 1
d2857 1
@


11.43
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.42 2000/04/12 00:57:42 mike Exp $ (ARL)";
d35 1
d321 1
a321 1
	if (myhit=NMG_INDEX_GET(rd->hitmiss, vu_p->v_p)) {
d332 1
a332 1
	if (myhit=NMG_INDEX_GET(rd->hitmiss, vu_p->v_p)) {
d1021 1
a1021 1
	if (myhit = NMG_INDEX_GET(rd->hitmiss, vu_p->v_p)) {
d1096 1
a1096 1
	if (myhit = NMG_INDEX_GET(rd->hitmiss, vu_p->v_p)) {
d1275 1
a1275 1
		if (fu=nmg_find_fu_of_eu(eu_p)) {
d1475 1
a1475 1
	if (myhit = NMG_INDEX_GET(rd->hitmiss, eu_p->e_p)) {
d1692 1
a1692 1
	if (myhit = NMG_INDEX_GET(rd->hitmiss, eu_p->e_p)) {
d2421 1
a2421 1
	if (myhit = NMG_INDEX_GET(rd->hitmiss, fp)) {
d2896 3
a2898 3
struct shell *s;
int in_or_out_only;
struct bn_tol *tol;
@


11.42
log
@
Removed unnecessary unix-specific include file.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.41 2000/03/28 20:41:04 mike Exp $ (ARL)";
@


11.42.2.1
log
@NMG's were not getting the magic number set in the hit structure
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.42 2000/04/12 00:57:42 mike Exp $ (ARL)";
a266 1
	newhit->hit.hit_magic = RT_HIT_MAGIC;
@


11.42.2.2
log
@Eliminated pmalloc (a failed experiment)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.42.2.1 2000/11/14 21:20:10 jra Exp $ (ARL)";
d2073 1
a2073 1
				hp = (struct rt_nurb_uv_hit *)bu_calloc( 1, sizeof( struct rt_nurb_uv_hit ), "struct rt_nurb_uv_hit" );
d2141 1
a2141 1
				bu_free( (char *)hp, "hit" );
d2241 1
a2241 1
			bu_free( (char *)hp, "hit" );
@


11.41
log
@
Eliminated name conflict
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.40 1999/12/30 15:39:53 jra Exp $ (ARL)";
a29 1
#include <sys/time.h>
@


11.40
log
@Eliminated some unused variables
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.39 1999/12/18 00:43:40 mike Exp $ (ARL)";
d125 1
a125 1
plfu( fu, pt, plane_pt )
d1522 1
a1522 1
			plfu(fu, rd->rp->r_pt, myhit->hit.hit_point);
d1951 1
a1951 1
		plfu(fu_p, rd->rp->r_pt, myhit->hit.hit_point);
@


11.39
log
@
Added definitions from nmg_isect_ray_model.c
Moved definitions to raytrace.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.38 1999/06/03 01:43:37 mike Exp $ (ARL)";
a1249 1
	struct hitmiss *a_hit;
a1466 1
	struct hitmiss *a_hit;
a1664 1
	int status;
a1665 1
	int vhit1, vhit2;
a1798 1
	struct hitmiss *myhit;
a2254 1
	int			code;
a2259 1
	plane_t			tol_norm;
a2449 1
		point_t min,max;
a2579 1
	struct hitmiss *a_hit;
a2902 3
	int hit_count = 0;
	struct hitmiss *minus_hit = (struct hitmiss *)NULL;
	struct hitmiss *plus_hit = (struct hitmiss *)NULL;
@


11.38
log
@
sed4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.37 1999/05/11 19:11:59 mike Exp $ (ARL)";
a37 4
RT_EXTERN(void	nmg_isect_ray_model, (struct ray_data *rd));

/* XXX move to ./nmg_rt.h */
#define NMG_RAY_STATE_ANY	8
@


11.37
log
@Reduced "hari_kari" chatter.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_isect.c,v 11.36 1998/02/23 16:27:47 jra Exp $ (ARL)";
d147 1
a147 1
	b = (long *)rt_calloc( fu->s_p->r_p->m_p->maxindex,
d164 1
a164 1
	rt_free((char *)b, "bit vec");
d189 1
a189 1
	b = (long *)rt_calloc( m->maxindex, sizeof(long), "bit vec");
d210 1
a210 1
	rt_free((char *)b, "bit vec");
d2983 1
a2983 1
	rd.hitmiss = (struct hitmiss **)rt_calloc( rd.rd_m->maxindex,
d2995 1
a2995 1
		rt_free( (char *)a_hit, "Miss list hitmiss struct" );
d3089 1
a3089 1
		rt_free( (char *)a_hit, "hit list hitmiss struct" );
d3106 1
a3106 1
	rt_free( (char *)rd.hitmiss, "free nmg geom hit list");
d3109 1
a3109 1
	rt_free( (char *)rd.manifolds, "free manifolds table" );
@


11.36
log
@isect_ray_edgeuse() now assumes linear edges if there is no edge geometry.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.35 1997/10/06 21:35:36 mike Exp jra $ (ARL)";
d3068 2
a3069 1
		bu_log("hari_kari = %d, %d\n", hari_kari_minus, hari_kari_plus);
d3075 2
a3076 1
/*		nmg_rt_print_hitlist(&rd.rd_hit);
d3079 2
a3080 1
		bu_log("nmg_class_ray_vs_shell() -- can't tell\n"); */
@


11.35
log
@rt_pmalloc
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.34 1997/09/23 21:02:46 jra Exp mike $ (ARL)";
d1722 1
a1722 2
	switch (*eu_p->g.magic_p) {
	case NMG_EDGE_G_LSEG_MAGIC:
d1724 10
a1733 4
		break;
	case NMG_EDGE_G_CNURB_MAGIC:
		isect_ray_cnurb(rd, eu_p);
		break;
d1972 1
a1972 1
#define UV_TOL  1.0e-5
@


11.34
log
@mod to UV_TOL
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.33 1997/09/18 20:32:45 jra Exp jra $ (ARL)";
d2077 1
a2077 1
				hp = (struct rt_nurb_uv_hit *)pmalloc( sizeof( struct rt_nurb_uv_hit ), &rd->ap->a_resource->re_pmem );
d2145 1
a2145 1
				pfree( (char *)hp, &rd->ap->a_resource->re_pmem );
d2245 1
a2245 1
			pfree( (char *)hp, &rd->ap->a_resource->re_pmem );
@


11.33
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.32 1997/09/09 14:15:57 jra Exp jra $ (ARL)";
d1967 1
a1967 1
#define UV_TOL  1.0e-6
a2088 1

@


11.32
log
@Added TNURB raytracing.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.31 1997/06/13 21:42:51 mike Exp jra $ (ARL)";
d1997 1
a1997 1
	rt_nurb_bezier( &bezier, fg );
d2065 1
a2065 1
				rt_nurb_free_snurb( srf );
d2077 1
a2077 1
				hp = (struct rt_nurb_uv_hit *)bu_malloc( sizeof( struct rt_nurb_uv_hit ), "hp" );
d2096 1
a2096 1
				rt_nurb_free_snurb( srf );
d2099 1
a2099 1
			hp = rt_nurb_intersect( srf, pl1, pl2, UV_TOL );
d2146 1
a2146 1
				bu_free( (char *)hp, "nurb_uv_hit" );
d2246 1
a2246 1
			bu_free( (char *)hp, "nurb_uv_hit" );
d2249 1
a2249 1
		rt_nurb_free_snurb( srf );
@


11.31
log
@rt_list_len became bu_list_len
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.30 1997/01/14 13:37:31 jra Exp mike $ (ARL)";
d30 1
d35 1
d1963 6
d1970 1
a1970 1
isect_ray_snurb_face(rd, fu_p, fg_p)
d1972 2
a1973 2
struct faceuse *fu_p;
struct face_g_snurb *fg_p;
d1975 276
a2250 1
	rt_bomb("isect_ray_snurb_face()\n");
@


11.30
log
@Minor fix to tanenbaum algorithm.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.29 1997/01/14 13:24:54 jra Exp jra $ (ARL)";
d2369 1
a2369 1
	if( rt_list_len(hd) <= 0 )  {
@


11.29
log
@Mods to GET_HITMISS and NMG_FREE_HITLIST calls to use resources.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.28 1997/01/09 17:10:58 jra Exp jra $ (ARL)";
d542 1
a542 1
		if (dotA > dotB) {
@


11.28
log
@ifdef'd freeing the hitmiss structs on the freelist.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.27 1997/01/09 16:15:46 jra Exp jra $ (ARL)";
d340 1
a340 1
	GET_HITMISS(myhit);
d812 1
d1029 1
a1029 1
		GET_HITMISS(myhit);
d1178 1
a1178 1
	GET_HITMISS(myhit);
d1219 1
a1219 1
	GET_HITMISS(myhit); \
d1501 1
a1501 1
		GET_HITMISS(myhit);
d1574 1
a1574 1
		GET_HITMISS(myhit);
d1606 1
a1606 1
		GET_HITMISS(myhit);
d1624 1
a1624 1
		GET_HITMISS(myhit);
d1774 1
a1774 1
	GET_HITMISS(myhit); \
d1784 1
a1784 1
	GET_HITMISS(myhit); \
d2053 1
a2053 1
	GET_HITMISS(myhit);
d2182 1
a2182 1
			GET_HITMISS(myhit);
d2198 1
a2198 1
			GET_HITMISS(myhit);
d2217 1
a2217 1
		GET_HITMISS(myhit);
d2650 3
d2710 2
d2801 2
d2804 11
@


11.27
log
@Removed include of nmg_rt.h.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.26 1997/01/07 22:59:11 jra Exp jra $ (ARL)";
d2701 1
a2701 1

d2706 1
a2706 1

d2790 1
d2795 1
a2795 1

@


11.26
log
@Modified isect_ray_faceuse() and isect_ray_planar_face() to do just one bn_isect_line3_plane()
rather than an rt_in_rpp() and a bn_isect_line3_plane().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.25 1997/01/07 16:08:21 jra Exp jra $ (ARL)";
a33 1
#include "./nmg_rt.h"
@


11.25
log
@Changes to speed up NMG raytracing.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.24 1996/12/26 20:52:11 jra Exp jra $ (ARL)";
d1985 2
a1986 2
	/* perform the geometric intersection of the ray with the plane 
	 * of the face.
a1988 41
	code = bn_isect_line3_plane(&dist, rd->rp->r_pt, rd->rp->r_dir,
			norm, rd->tol);


	if (code < 0) {
		/* ray is parallel to halfspace and (-1)inside or (-2)outside
		 * the halfspace.
		 */
		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			bu_log("\tray misses halfspace of plane\n");

		GET_HITMISS(myhit);
		NMG_INDEX_ASSIGN(rd->hitmiss, fu_p->f_p, myhit);
		myhit->hit.hit_private = (genptr_t)fu_p->f_p;
		BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		BU_LIST_INSERT(&rd->rd_miss, &myhit->l);
#ifndef FAST_NMG
		NMG_CK_HITMISS(myhit);
#endif
		return;
	} else if (code == 0) {
		/* XXX gack!  ray lies in plane.  
		 * In leiu of doing 2D intersection we define such rays
		 * as "missing" the face.  We rely on other faces to generate
		 * hit points.
		 */
#if 0
		bu_log("\tWarning:  Ignoring ray in plane of face (NOW A MISS) XXX\n");
#endif
		GET_HITMISS(myhit);
		NMG_INDEX_ASSIGN(rd->hitmiss, fu_p->f_p, myhit);
		myhit->hit.hit_private = (genptr_t)fu_p->f_p;
		BU_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		BU_LIST_INSERT(&rd->rd_miss, &myhit->l);
#ifndef FAST_NMG
		NMG_CK_HITMISS(myhit);
#endif

		return;
	}

d1992 1
a1992 1
	 * Compute the ray/plane intersection point.
d1996 2
a1997 1
	VJOIN1(plane_pt, rd->rp->r_pt, dist, rd->rp->r_dir);
d2129 2
d2140 2
a2141 2
	NMG_CK_FACE(fu_p->f_p);
	NMG_CK_FACE_G_PLANE(fu_p->f_p->g.plane_p);
d2145 1
a2145 1
	if (myhit = NMG_INDEX_GET(rd->hitmiss, fu_p->f_p)) {
d2169 47
a2215 1
	if (!rt_in_rpp(rd->rp, rd->rd_invdir,
@


11.24
log
@ifdef'd out a nuisance bu_log().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.23 1996/12/26 20:38:23 jra Exp jra $ (ARL)";
d101 3
a103 2
		NMG_CK_HITMISS(hmp);

d353 1
d356 1
a356 1

d1060 1
a1060 1

d1062 1
d1183 1
d1186 1
a1186 1

d1194 1
d1210 15
a1224 1

d1254 1
d1256 1
d1332 1
d1334 1
d1452 1
d1454 1
d1473 1
d1475 1
d1485 1
d1487 1
d1515 1
a1515 1

d1517 1
d1519 1
d1521 1
d1530 1
a1530 1

d1533 1
d1587 1
d1590 1
d1612 1
d1615 1
d1630 1
d1633 1
a1633 1

d1771 1
d1781 9
a1789 1

d1824 1
d1826 1
d1828 1
d1830 1
d1955 1
d1957 1
d2005 1
d2007 1
a2007 1

d2023 1
d2025 1
d2121 1
d2123 1
d2136 1
d2138 1
d2214 1
d2216 1
d2329 1
d2331 1
a2331 1

d2375 1
d2377 1
d2405 1
d2407 1
d2504 1
d2506 1
@


11.23
log
@Added an ON_ON case thart seemed to have been overlooked in edge_hit_ray_state().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.22 1996/09/27 08:27:30 mike Exp jra $ (ARL)";
d1961 1
d1963 1
@


11.22
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.21 1996/07/12 12:17:41 jra Exp mike $ (ARL)";
d1403 1
@


11.21
log
@Minor Mods for IRIX 6.2
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.20 1996/05/16 21:51:04 jra Exp jra $ (ARL)";
d93 1
a93 1
CONST struct rt_list	*hd;
d100 1
a100 1
	for( RT_LIST_FOR( hmp, hitmiss, hd ) )  {
d109 1
a109 1
			rt_log("ray state was=%s, transition=%s (istate=%s)\n",
d118 1
a118 1
		rt_log("ray ending state was %s, should have been RS_OUT\n", nmg_rt_state_str(state));
d144 1
a144 1
	rt_log("overlay %s\n", name);
d185 1
a185 1
	rt_log("overlay %s\n", name);
d222 1
a222 1
	rt_log("   dist:%12g pt=(%f %f %f) %s=x%x\n",
d227 1
a227 1
		rt_identify_magic(*(long *)a_hit->hit.hit_private),
d230 1
a230 1
	rt_log("\tstate:%s", nmg_rt_inout_str(a_hit->in_out));
d233 2
a234 2
	case NMG_HITMISS_SEG_IN:	rt_log(" SEG_START"); break;
	case NMG_HITMISS_SEG_OUT:	rt_log(" SEG_STOP"); break;
d246 1
a246 1
	rt_log("nmg/ray hit list:\n");
d248 1
a248 1
	for (RT_LIST_FOR(a_hit, hitmiss, &(hl->l))) {
d269 1
a269 1
	RT_LIST_MAGIC_SET(&newhit->l, NMG_RT_HIT_MAGIC);
d272 1
a272 1
		rt_log("hit_ins()\n  inserting:");
d276 1
a276 1
	for (RT_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)) {
d286 2
a287 2
		if (RT_LIST_NOT_HEAD(a_hit, &rd->rd_hit)) {
			rt_log("   prior to:");
d290 1
a290 1
			rt_log("\tat end of list\n");
d294 1
a294 1
	RT_LIST_INSERT(&a_hit->l, &newhit->l);
d317 1
a317 1
		rt_log("ray_miss_vertex(%g %g %g)\n",
d325 1
a325 1
		if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_MAGIC)) {
d327 2
a328 2
				rt_log("ray_miss_vertex( vertex previously HIT!!!! )\n");
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_SUB_MAGIC)) {
d330 1
a330 1
				rt_log("ray_miss_vertex( vertex previously HIT_SUB!?!? )\n");
d336 1
a336 1
			rt_log("ray_miss_vertex( vertex previously missed )\n");
d350 2
a351 2
	RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
	RT_LIST_INSERT(&rd->rd_miss, &myhit->l);
d386 1
a386 1
 *  There are six distinct return values from rt_dist_pt3_lseg3():
d399 1
a399 1
	code = rt_dist_pt3_lseg3( &distA, pcaA, vu->v_p->vg_p->coord, pointA,
d409 1
a409 1
	code = rt_dist_pt3_lseg3( &distB, pcaB, vu->v_p->vg_p->coord, pointB,
d434 1
a434 1
		rt_log("get_pole_dist_to_face(%s) status from dist_pt_lseg == 0x%02x\n", Pole_name, status);
d444 1
a444 1
				rt_log("\tplane point inside face\n");
d452 1
a452 1
				rt_log("\tplane point outside face\n");
d463 1
a463 1
				rt_log("\tplane point inside face\n");
d471 1
a471 1
				rt_log("\tplane point outside face\n");
d491 1
a491 1
					rt_log("\tplane point inside face\n");
d498 1
a498 1
					rt_log("\tplane point outside face\n");
d511 1
a511 1
					rt_log("\tplane point inside face\n");
d518 1
a518 1
					rt_log("\tplane point outside face\n");
d534 1
a534 1
			rt_log("\tplane point beyond both edges.... Doing the Tanenbaum algorithm.\n");
d547 1
a547 1
					rt_log("\tpoint inside face\n");
d553 1
a553 1
					rt_log("\tpoint outside face, PCA is vertex\n");
d564 1
a564 1
					rt_log("\tpoint is inside face\n");
d571 1
a571 1
					rt_log("\tpoint is outside face, PCA is vertex\n");
d587 1
a587 1
		rt_log("%s %d: So-called 'Impossible' status codes\n",
d624 1
a624 1
		rt_log("Error opening %s\n", name);
d627 1
a627 1
		rt_log("overlay %s\n", name);
d786 1
a786 1
		rt_log("vertex_neighborhood\n");
d813 1
a813 1
	for ( RT_LIST_FOR(vu, vertexuse, &vu_p->v_p->vu_hd) ) {
d858 1
a858 1
				eu = RT_LIST_PNEXT_CIRC(edgeuse, vu->up.eu_p);
d867 1
a867 1
				eu = RT_LIST_PLAST_CIRC(edgeuse, vu->up.eu_p);
d887 1
a887 1
				rt_log("\tDist north pole<=>face %g\n", North_dist);
d894 1
a894 1
			    		rt_log("New North Pole Min: %g\n", North_min);
d905 1
a905 1
				rt_log("\tDist south pole<=>face %g\n", South_dist);
d912 1
a912 1
			    		rt_log("New South Pole Min: %g\n", South_min);
d942 1
a942 1
		rt_log("North Pole Min: %g to %g %g %g\n", North_min,
d948 1
a948 1
	if (RT_VECT_ARE_PERP(cos_angle, rd->tol))
d961 1
a961 1
	if (RT_VECT_ARE_PERP(cos_angle, rd->tol))
d991 1
a991 1
		rt_log("%s %d: vertex_neighborhood() Bad vertex in_out state = x%x\n",
d1018 1
a1018 1
		rt_log("ray_hit_vertex x%x (%g %g %g)\n",
d1022 1
a1022 1
		if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_MAGIC))
d1025 1
a1025 1
		RT_LIST_DEQUEUE(&myhit->l);
d1040 1
a1040 1
		rt_log( "\tray = ( %g %g %g ), dir=(%g %g %g ), dist=%g\n",
d1043 1
a1043 1
	RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_MAGIC);
d1083 1
a1083 1
		rt_log("isect_ray_vertexuse\n");
d1090 1
a1090 1
		rt_log("nmg_isect_ray_vertexuse %g %g %g", 
d1096 1
a1096 1
		if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_MAGIC)) {
d1099 1
a1099 1
				rt_log(" previously hit\n");
d1104 1
a1104 1
				rt_log(" previously missed\n");
d1110 1
a1110 1
	ray_vu_dist = rt_dist_line_point(rd->rp->r_pt, rd->rp->r_dir,
d1123 1
a1123 1
		rt_log(" Ray hits vertex, dist %g (priv=x%x, v magic=x%x)\n",
d1151 1
a1151 1
		rt_log("\t - colinear_edge_ray\n");
d1178 2
a1179 2
	RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_SUB_MAGIC);
	RT_LIST_INSERT(&rd->rd_miss, &myhit->l);
d1191 1
a1191 1
	if (rt_g.NMG_debug & DEBUG_RT_ISECT) rt_log("hit_edge_vertex\n"); \
d1201 2
a1202 2
	RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_SUB_MAGIC); \
	RT_LIST_INSERT(&rd->rd_miss, &myhit->l); \
d1237 2
a1238 2
		eu_p = RT_LIST_PNEXT_CIRC(edgeuse, eu);
		rt_log("edge_hit_ray_state(%g %g %g -> %g %g %g _vs_ %g %g %g)\n",
d1266 1
a1266 1
				rt_log("%s[%d]: I can't seem to find an OT_SAME faceuse\nThis must be a `dangling' face  I'll skip it\n", __FILE__, __LINE__);
d1274 1
a1274 1
				rt_log("edgeuse not part of faceuse");
d1280 1
a1280 1
				rt_log("This is not a 3-Manifold face.  I'll skip it\n");
d1288 1
a1288 1
				rt_log("left_vect:(%g %g %g)  cos_angle:%g\n",
d1298 1
a1298 1
					rt_log("New inb cos_angle %g\n", inb_cos_angle);
d1305 1
a1305 1
					rt_log("New outb cos_angle %g\n", outb_cos_angle);
d1319 1
a1319 1
		eu_p = RT_LIST_PNEXT_CIRC(edgeuse, eu);
d1346 1
a1346 1
		rt_log("cos_angle wrt ray direction: %g\n", cos_angle);
d1349 1
a1349 1
	if (RT_VECT_ARE_PERP(cos_angle, rd->tol))
d1364 1
a1364 1
		rt_log("cos_angle wrt ray direction: %g\n", cos_angle);
d1367 1
a1367 1
	if (RT_VECT_ARE_PERP(cos_angle, rd->tol))
d1376 1
a1376 1
		rt_log("myhit->in_out: 0x%02x/", myhit->in_out);
d1379 1
a1379 1
			rt_log("IN_IN\n"); break;
d1381 1
a1381 1
			rt_log("IN_OUT\n"); break;
d1383 1
a1383 1
			rt_log("OUT_IN\n"); break;
d1385 1
a1385 1
			rt_log("OUT_OUT\n"); break;
d1387 1
a1387 1
			rt_log("IN_ON\n"); break;
d1389 1
a1389 1
			rt_log("ON_IN\n"); break;
d1391 1
a1391 1
			rt_log("OUT_ON\n"); break;
d1393 1
a1393 1
			rt_log("ON_OUT\n"); break;
d1395 1
a1395 1
			rt_log("ON_ON\n"); break;
d1397 1
a1397 1
			rt_log("?_?\n"); break;
d1424 1
a1424 1
		rt_log("%s %d: Bad edge in/out state = x%x\n", __FILE__, __LINE__, myhit->in_out);
d1449 1
a1449 1
	if (rt_g.NMG_debug & DEBUG_RT_ISECT) rt_log("\t - HIT edge 0x%08x (edgeuse=x%x)\n", eu_p->e_p, eu_p);
d1452 1
a1452 1
		switch (((struct rt_list *)myhit)->magic) {
d1455 2
a1456 2
				rt_log("\tedge previously missed, changing to hit\n");
			RT_LIST_DEQUEUE(&myhit->l);
d1461 1
a1461 1
				rt_log("\tedge vertex previously hit\n");
d1465 1
a1465 1
				rt_log("\tedge previously hit\n");
d1519 1
a1519 1
	status = rt_isect_line_lseg( &dist_along_ray,
d1527 1
a1527 1
		/* Zero length edge.  The routine rt_isect_line_lseg() can't
d1535 1
a1535 1
			rt_log("\t - Zero length edge\n");
d1547 1
a1547 1
			RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_SUB_MAGIC);
d1550 1
a1550 1
			RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
d1552 1
a1552 1
		RT_LIST_INSERT(&rd->rd_miss, &myhit->l);
d1564 1
a1564 1
			rt_log("\t - Miss edge, \"hit\" line\n");
d1574 2
a1575 2
		RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		RT_LIST_INSERT(&rd->rd_miss, &myhit->l);
d1581 1
a1581 1
			rt_log("\t - Miss edge/line\n");
d1590 2
a1591 2
		RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		RT_LIST_INSERT(&rd->rd_miss, &myhit->l);
d1643 1
a1643 1
		rt_log("isect_ray_edgeuse (%g %g %g) -> (%g %g %g)",
d1656 1
a1656 1
		rt_log("\n\tLooking for previous hit on edge 0x%08x ...\n",
d1660 1
a1660 1
		if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_MAGIC)) {
d1663 1
a1663 1
				rt_log("\tedge previously hit\n");
d1665 1
a1665 1
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_SUB_MAGIC)) {
d1667 1
a1667 1
				rt_log("\tvertex of edge previously hit\n");
d1669 1
a1669 1
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_MISS_MAGIC)) {
d1671 1
a1671 1
				rt_log("\tedge previously missed\n");
d1679 1
a1679 1
		rt_log("\t No previous hit\n");
d1707 1
a1707 1
		rt_log("isect_ray_loopuse( 0x%08x, loop:0x%08x)\n", rd, lu_p->l_p);
d1713 2
a1714 2
	if (RT_LIST_FIRST_MAGIC(&lu_p->down_hd) == NMG_EDGEUSE_MAGIC) {
		for (RT_LIST_FOR(eu_p, edgeuse, &lu_p->down_hd)) {
d1719 2
a1720 2
	} else if (RT_LIST_FIRST_MAGIC(&lu_p->down_hd)!=NMG_VERTEXUSE_MAGIC) {
		rt_log("in %s at %d", __FILE__, __LINE__);
d1727 1
a1727 1
		RT_LIST_FIRST(vertexuse, &lu_p->down_hd));
d1737 2
a1738 2
	RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_SUB_MAGIC); \
	RT_LIST_INSERT(&rd->rd_miss, &myhit->l); \
d1762 1
a1762 1
	eu_next = RT_LIST_PNEXT_CIRC(edgeuse, eu);
d1765 1
a1765 1
		rt_log("eu_touch(%g %g %g -> %g %g %g\n",
d1792 1
a1792 1
		rt_log("vu_touch(%g %g %g)\n",
d1814 1
a1814 1
	RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_MAGIC);
d1832 2
a1833 2
		rt_log("cos_angle wrt ray direction: %g\n", cos_angle);
		rt_log( "fu x%x manifoldness = %d\n", fu_p, NMG_MANIFOLDS(rd->manifolds, fu_p) );
d1858 1
a1858 1
		if (RT_VECT_ARE_PERP(cos_angle, rd->tol)) {
d1860 1
a1860 1
			rt_log("%s[%d]: Ray is in plane of face?\n",
d1876 1
a1876 1
		if (RT_VECT_ARE_PERP(cos_angle, rd->tol)) {
d1878 1
a1878 1
			rt_log("%s[%d]: Ray is in plane of face?\n",
d1894 1
a1894 1
		rt_log("%s %d:face orientation not SAME/OPPOSITE\n",
d1935 1
a1935 1
	code = rt_isect_line3_plane(&dist, rd->rp->r_pt, rd->rp->r_dir,
d1944 1
a1944 1
			rt_log("\tray misses halfspace of plane\n");
d1949 2
a1950 2
		RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		RT_LIST_INSERT(&rd->rd_miss, &myhit->l);
d1960 1
a1960 1
		rt_log("\tWarning:  Ignoring ray in plane of face (NOW A MISS) XXX\n");
d1964 2
a1965 2
		RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		RT_LIST_INSERT(&rd->rd_miss, &myhit->l);
d1981 1
a1981 1
		rt_log("%s:%d plane_pt (%g %g %g) @@ dist (%g)out of tolerance\n",
d1988 1
a1988 1
		rt_log("\tray (%16.10e %16.10e %16.10e) (-> %16.10e %16.10e %16.10e)\n",
d1995 1
a1995 1
		rt_log("\tplane/ray intersection point (%16.10e %16.10e %16.10e)\n",
d1997 1
a1997 1
		rt_log("\tdistance along ray to intersection point %16.10e\n", dist);
d2001 1
a2001 1
		rt_log("\tDIST_PT_PLANE(%16.10e) 0x%08lx 0x%08lx\n", new_dist,
d2004 1
a2004 1
		rt_isect_line3_plane(&new_dist, plane_pt, rd->rp->r_dir,
d2007 1
a2007 1
		rt_log("Normal %16.10e %16.10e %16.10e %16.10e)\n",
d2009 1
a2009 1
		rt_log("recalculated plane/pt dist as %16.10e 0x%08lx 0x%08lx\n",
d2011 1
a2011 1
		rt_log("distance tol = %16.10e\n", rd->tol->dist);
d2043 1
a2043 1
		rt_log("%s[line:%d] ray/plane intercept point cannot be classified wrt face\n",
d2055 1
a2055 1
			RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_SUB_MAGIC);
d2061 1
a2061 1
			RT_LIST_INSERT(&rd->rd_miss, &myhit->l);
d2073 2
a2074 2
		RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		RT_LIST_INSERT(&rd->rd_miss, &myhit->l);
d2079 1
a2079 1
		rt_log("%s[line:%d] BIZZARE ray/plane intercept point classification\n",
d2085 1
a2085 1
	for ( RT_LIST_FOR(lu_p, loopuse, &fu_p->lu_hd) )
d2110 1
a2110 1
		rt_log("isect_ray_faceuse(0x%08x, faceuse:0x%08x/face:0x%08x)\n",
d2121 1
a2121 1
		if (RT_LIST_MAGIC_OK((struct rt_list *)myhit,
d2124 2
a2125 2
				rt_log(" previously hit\n");
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)myhit,
d2128 2
a2129 2
				rt_log(" previously hit sub-element\n");
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)myhit,
d2132 1
a2132 1
				rt_log(" previously missed\n");
d2134 1
a2134 1
			rt_log("%s %d:\n\tBad magic %ld (0x%08x) for hitmiss struct for faceuse 0x%08x\n",
d2149 2
a2150 2
		RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		RT_LIST_INSERT(&rd->rd_miss, &myhit->l);
d2154 1
a2154 1
			rt_log("missed bounding box\n");
d2158 1
a2158 1
	if (rt_g.NMG_debug & DEBUG_RT_ISECT) rt_log(" hit bounding box \n");
d2187 1
a2187 1
		rt_log("nmg_isect_ray_shell( 0x%08x, 0x%08x)\n", rd, s_p);
d2199 1
a2199 1
			rt_log("nmg_isect_ray_shell( no RPP overlap)\n",
d2206 1
a2206 1
	for (RT_LIST_FOR(fu_p, faceuse, &(s_p->fu_hd)) )
d2209 1
a2209 1
	for (RT_LIST_FOR(lu_p, loopuse, &(s_p->lu_hd)) )
d2212 1
a2212 1
	for (RT_LIST_FOR(eu_p, edgeuse, &(s_p->eu_hd)) )
d2219 1
a2219 1
		rt_log("nmg_isect_ray_shell( done )\n", rd, s_p);
d2236 1
a2236 1
		rt_log("isect_ray_nmg: Pnt(%g %g %g) Dir(%g %g %g)\n", 
d2249 1
a2249 1
	for ( RT_LIST_FOR(r_p, nmgregion, &rd->rd_m->r_hd) ) {
d2259 1
a2259 1
		for (RT_LIST_FOR(s_p, shell, &r_p->s_hd)) {
d2268 1
a2268 1
		if (RT_LIST_IS_EMPTY(&rd->rd_hit)) {
d2270 1
a2270 1
				rt_log("ray missed NMG\n");
d2285 1
a2285 1
CONST struct rt_list	*hd;
d2296 1
a2296 1
		rt_log("nmg_pl_hitmiss_list(): empty list, no %s written\n", buf);
d2307 1
a2307 1
	for( RT_LIST_FOR( hmp, hitmiss, hd ) )  {
d2317 1
a2317 1
	rt_log("overlay %s\n", buf);
d2334 2
a2335 2
		rt_log("plus guessing\n");
	for (RT_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)) {
d2344 1
a2344 1
					rt_log("guess_class_from_hitlist_min() returns NMG_CLASS_AonBshared for 0 dist hit\n");
d2360 1
a2360 1
				rt_log("plus hit = %g (%s)\n", a_hit->hit.hit_dist,
d2366 1
a2366 1
				rt_log("plus hit = %g (%s)\n", a_hit->hit.hit_dist,
d2378 1
a2378 1
			rt_log("Contemplating Hari Kari\n");
d2409 1
a2409 1
			rt_log("Nothing in the plus direction\n");
d2430 1
a2430 1
		rt_log("minus guessing\n");
d2432 1
a2432 1
	for (RT_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)) {
d2441 1
a2441 1
					rt_log("guess_class_from_hitlist_min() returns NMG_CLASS_AonBshared for 0 dist hit\n");
d2457 1
a2457 1
				rt_log("minus hit = %g (%s)\n", a_hit->hit.hit_dist,
d2463 1
a2463 1
				rt_log("minus hit = %g (%s)\n", a_hit->hit.hit_dist,
d2475 1
a2475 1
			rt_log("Contemplating Hari Kari\n");
d2507 1
a2507 1
			rt_log("Nothing in the minus direction\n");
d2544 1
a2544 1
struct rt_tol *tol;
d2558 1
a2558 1
	RT_CK_TOL(tol);
d2561 1
a2561 1
		rt_log("nmg_class_ray_vs_shell(pt(%g %g %g), dir(%g %g %g))\n",
d2577 2
a2578 2
		rt_log( "Manifoldness for shell FU's\n" );
		for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d2583 1
a2583 1
			rt_log( "fu x%x: %d\n", fu, NMG_MANIFOLDS( rd.manifolds, fu ) );
d2618 2
a2619 2
	RT_LIST_INIT(&rd.rd_hit);
	RT_LIST_INIT(&rd.rd_miss);
d2623 2
a2624 2
	while (RT_LIST_WHILE(a_hit, hitmiss, &rd.rd_miss)) {
		RT_LIST_DEQUEUE( &a_hit->l );
d2630 2
a2631 2
		rt_log("%s[%d]: shell Hits:\n", __FILE__, __LINE__);
		for( RT_LIST_FOR( a_hit, hitmiss, &rd.rd_hit ) )  {
d2633 1
a2633 1
				rt_log("Positive dist hit\n");
d2635 1
a2635 1
				rt_log("Negative dist hit\n");
d2650 2
a2651 2
		rt_log("minus_class = (%s)\n", nmg_class_name(minus_class));
		rt_log("plus_class = (%s)\n", nmg_class_name(plus_class));
d2682 1
a2682 1
		rt_log("%s:%d plus_class (%s) != minus_class (%s)\n",
d2696 1
a2696 1
		rt_log("hari_kari = %d, %d\n", hari_kari_minus, hari_kari_plus);
d2703 3
a2705 3
		rt_log("minus_class = (%s) %d, hari_kari=%d\n", nmg_class_name(minus_class), minus_class, hari_kari_minus);
		rt_log("plus_class = (%s)\n", nmg_class_name(plus_class));
		rt_log("nmg_class_ray_vs_shell() -- can't tell\n"); */
d2711 2
a2712 2
	while (RT_LIST_WHILE(a_hit, hitmiss, &rd.rd_hit)) {
		RT_LIST_DEQUEUE( &a_hit->l );
d2723 1
a2723 1
		rt_log("nmg_class_ray_vs_shell() returns %s(%d)\n",
@


11.20
log
@Mods to isect_ray_planar_face() and nmg_class_ray_vs_shell() to use new "classifying_ray"
field in ray_data structure.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.19 1996/04/30 20:28:02 jra Exp jra $ (ARL)";
d1501 2
d1508 2
@


11.19
log
@Fixed memory leak in nmg_class_ray_vs_shell().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.18 1996/03/28 14:29:44 jra Exp jra $ (ARL)";
d2020 8
a2027 3
	pt_class = nmg_class_pt_fu_except(plane_pt, fu_p, (struct loopuse *)NULL,
		eu_touch_func, vu_touch_func, (char *)rd, NMG_FPI_PERGEOM, 0,
		rd->tol);
d2611 1
@


11.18
log
@Mods for new arg to nmg_class_pt_fu_except().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.17 1996/03/25 20:43:45 jra Exp jra $ (ARL)";
d2709 2
@


11.17
log
@ray_hit_vertex() was using MAGNITUDE to get hit dist (signed distance is needed).
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.16 1996/03/17 23:54:51 jra Exp jra $ (ARL)";
d2021 1
a2021 1
		eu_touch_func, vu_touch_func, (char *)rd, NMG_FPI_PERGEOM,
@


11.16
log
@Modified nmg_class_ray_vs_shell() to allow flag for ignoring tolerance distance
in classification.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.15 1996/03/12 18:04:45 jra Exp $ (ARL)";
d1018 2
a1019 1
		rt_log("ray_hit_vertex\n");
d1034 2
a1035 2
	VSUB2( v, rd->rp->r_pt, vu_p->v_p->vg_p->coord);
	myhit->hit.hit_dist = MAGNITUDE(v);	/* distance along ray */
d1038 4
@


11.15
log
@Fixed edge_hit_ray_state() to look only at FU's in current shell.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.14 1996/03/08 19:50:11 jra Exp $ (ARL)";
d222 1
a222 1
	rt_log("   dist:%12g pt=(%g %g %g) %s=x%x\n",
d1444 1
a1444 1
	if (rt_g.NMG_debug & DEBUG_RT_ISECT) rt_log("\t - HIT edge 0x%08x\n", eu_p->e_p);
d2307 1
a2307 1
guess_class_from_hitlist_max(rd, hari_kari)
d2310 1
d2324 7
a2330 5
		/* if we've got a zero distance hit, that clinches it */
		if (a_hit->hit.hit_dist <= rd->tol->dist &&
	    	    a_hit->hit.hit_dist >= -rd->tol->dist) {
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
				rt_log("guess_class_from_hitlist_min() returns NMG_CLASS_AonBshared for 0 dist hit\n");
d2332 2
a2333 2
	    		return NMG_CLASS_AonBshared;
	    	}
d2335 4
a2338 1
		if (a_hit->hit.hit_dist < -rd->tol->dist)
d2403 1
a2403 1
guess_class_from_hitlist_min(rd, hari_kari)
d2406 1
d2421 7
a2427 5
		/* if we've got a zero distance hit, that clinches it */
		if (a_hit->hit.hit_dist <= rd->tol->dist &&
	    	    a_hit->hit.hit_dist >= -rd->tol->dist) {
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT))
				rt_log("guess_class_from_hitlist_min() returns NMG_CLASS_AonBshared for 0 dist hit\n");
d2429 2
a2430 2
	    		return NMG_CLASS_AonBshared;
	    	}
d2432 4
a2435 1
		if (a_hit->hit.hit_dist > rd->tol->dist)
d2514 3
d2526 1
a2526 1
nmg_class_ray_vs_shell(rp, s, tol)
d2529 1
d2631 2
a2632 2
	minus_class = guess_class_from_hitlist_min(&rd, &hari_kari_minus);
	plus_class = guess_class_from_hitlist_max(&rd, &hari_kari_plus);
@


11.14
log
@ removed some debug printing.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.13 1996/03/05 21:45:01 jra Exp $ (ARL)";
d1216 1
d1247 1
d1265 3
d1282 1
d1286 1
d1389 2
@


11.13
log
@ifdef'd a case in vertex_neighborhood() back in.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.12 1996/02/19 05:06:37 jra Exp jra $ (ARL)";
d1815 1
d2534 14
d2662 1
a2662 1
		nmg_rt_print_hitlist(&rd.rd_hit);
d2665 1
a2665 1
		rt_log("nmg_class_ray_vs_shell() -- can't tell\n");
@


11.12
log
@Added two instances of HIT_EDGE_VERTEX macro bfore call to
colinear_edge_ray() in isect_ray_lseg().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.11 1995/06/17 02:59:18 mike Exp jra $ (ARL)";
d973 1
a973 1
#if 0
@


11.11
log
@If no points found in negative direction, return NMG_CLASS_AoutB,
not Unknown.
Also removed compensating code in anti-hari_kari section.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.10 1995/06/17 02:45:56 mike Exp mike $ (ARL)";
d1579 2
@


11.10
log
@Rather than hari-kari, just return NMG_CLASS_Unknown,
and let caller pick an easier ray direction.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.9 1995/03/01 07:48:21 butler Exp mike $ (ARL)";
d2464 1
a2464 1
		/* since we didn't hit anything in the positive direction,
d2470 1
a2470 1
		pt_class = NMG_CLASS_Unknown; /* XXX not AoutB? */
d2643 2
a2644 14
	/*
	 *  If there is no geometry behind (or in front of) the start point,
	 *  the classification in that direction will be NMG_CLASS_Unknown.
	 *  This isn't an error.
	 */
#if 1
	if( minus_class == NMG_CLASS_Unknown && plus_class != NMG_CLASS_Unknown )
		goto out;
#endif
	if( plus_class == NMG_CLASS_Unknown && minus_class != NMG_CLASS_Unknown )  {
		plus_class = minus_class;
		goto out;
	}
	if (plus_class != minus_class) {
@


11.9
log
@checkpoint
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.8 1995/02/21 11:16:45 butler Exp butler $ (ARL)";
d589 1
a589 1
		rt_bomb("Pretending NOT to bomb\n");
d973 3
d991 3
a993 3
		rt_log("%s %d: Bad vertex in/out state?\n",
			__FILE__, __LINE__);
		rt_bomb("bombing\n");
d1328 1
a1328 1
		rt_bomb("null normal!\n");
d1410 2
a1411 2
		rt_log("%s %d: Bad edge in/out state?\n", __FILE__, __LINE__);
		rt_bomb("bombing\n");
d1633 1
a1633 1
		rt_bomb("edgeuse mate has step-father\n");
d1841 1
a1841 1
				rt_bomb("I quit\n");
d1859 1
a1859 1
				rt_bomb("I quit\n");
d1875 1
a1875 1
		rt_bomb("Crash and burn\n");
d1962 1
a1962 1
		rt_bomb("");
d2019 1
a2019 1
		rt_bomb("bombing");
d2055 1
a2055 1
		rt_bomb("bombing");
d2368 1
a2368 1
			rt_bomb("no-class hitpoint\n");
d2460 1
a2460 1
			rt_bomb("no-class hitpoint\n");
d2482 7
a2488 2
 *	Intersect a ray with a shell and return the number of hitpoints with
 *	positive distance values.
d2490 7
d2519 1
a2519 1
		rt_log("nmg_ray_vs_shell(pt(%g %g %g), dir(%g %g %g))\n",
d2598 1
d2616 1
a2616 1
			rt_bomb("minus hari kari & plus unknown");
d2633 32
d2676 1
a2676 1
		rt_log("nmg_ray_vs_shell() returns %s(%d)\n",
a2681 2


@


11.8
log
@checkpoint
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.7 1995/02/18 00:23:44 butler Exp butler $ (ARL)";
d1905 1
d1956 6
d1963 2
a1964 1
		rt_log("\tray (%g %g %g) (-> %g %g %g)\n",
d1971 11
d1983 5
a1987 2
		VPRINT("\tplane/ray intersection point", plane_pt);
		rt_log("\tdistance along ray to intersection point %g\n", dist);
a2581 9
	while (RT_LIST_WHILE(a_hit, hitmiss, &rd.rd_hit)) {
		RT_LIST_DEQUEUE( &a_hit->l );
		rt_free( (char *)a_hit, "hit list hitmiss struct" );
	}

	/* free the hitmiss table */
	rt_free( (char *)rd.hitmiss, "free nmg geom hit list");


d2614 1
a2614 2
		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			nmg_rt_print_hitlist(&rd.rd_hit);
d2618 9
d2630 2
@


11.7
log
@added symbolic constant to nmg_class_pt_fu_except() call
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.6 1995/02/17 11:41:34 butler Exp butler $ (ARL)";
d240 2
a241 1
static void print_hitlist(hl)
a245 3
	if (!(rt_g.NMG_debug & DEBUG_RT_ISECT))
		return;

d296 2
a297 1
	print_hitlist((struct hitmiss *)&rd->rd_hit);
d1120 2
a1121 1
		print_hitlist(rd->hitmiss[NMG_HIT_LIST]);
d1722 1
a1722 1
eu_touch_func(eu, fpi)
d1724 2
a1725 1
struct fu_pt_info *fpi;
d1750 1
a1750 1
	rd = (struct ray_data *)fpi->priv;
d1754 1
a1754 1
	ray_hit_edge(rd, eu, rd->ray_dist_to_plane, fpi->pt);
d1761 1
a1761 1
vu_touch_func(vu, fpi)
d1763 2
a1764 1
struct fu_pt_info *fpi;
d1774 1
a1774 1
	rd = (struct ray_data *)fpi->priv;
a1901 1
	struct fu_pt_info	*fpi;
d1904 1
d1978 1
a1978 1
	fpi = nmg_class_pt_fu_except(plane_pt, fu_p, (struct loopuse *)NULL,
d1990 1
a1990 1
	switch (fpi->pt_class) {
a2032 3



a2036 1
	NMG_FPI_FREE( fpi );
d2038 6
d2056 2
d2221 2
a2222 1
			print_hitlist((struct hitmiss*)&rd->rd_hit);
d2462 1
a2462 1
nmg_ray_vs_shell(rp, s, tol)
d2576 3
a2578 1
		if (plus_class == NMG_CLASS_Unknown)
d2580 1
d2584 3
a2586 1
		if (plus_class == NMG_CLASS_Unknown)
d2588 1
d2600 3
@


11.6
log
@remodeled nmg_ray_vs_shell()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.5 1995/02/15 01:47:27 mike Exp butler $ (ARL)";
d1977 2
a1978 1
		eu_touch_func, vu_touch_func, (char *)rd, 1, rd->tol);
@


11.5
log
@Added nmg_ck_hitmiss_list(), and called it.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.4 95/02/15 00:18:37 mike Exp Locker: mike $ (ARL)";
d2261 183
a2451 2
 * XXX Really should run some kind of parity checking on the rd_hit list,
 * XXX to make sure that the ray does not depart with multiple IN_OUT hits, etc.
d2463 5
d2511 1
a2511 1

d2544 7
a2550 2
	/* After potentially having printed it, now check it */
	nmg_ck_hitmiss_list( &rd.rd_hit );
a2551 2
	/* Count and dequeue the list */
	/* XXX This is an overly simplistic algorithm */
d2554 1
a2554 5
		if ( a_hit->in_out != HMG_HIT_ANY_ANY &&
		     a_hit->hit.hit_dist >= 0.0) {
			hit_count++;
		}
		rt_free( (char *)a_hit, "Hit list hitmiss struct" );
d2560 29
d2590 3
a2592 2
		rt_log("nmg_ray_vs_shell() returns %d\n", hit_count);
	return hit_count;
d2594 2
@


11.4
log
@Added nmg_pl_hitmiss_list()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.3 95/01/20 18:42:02 mike Exp Locker: mike $ (ARL)";
d39 84
a216 27
CONST char *
nmg_rt_inout_str( code )
int	code;
{
	switch(code) {
	case HMG_HIT_IN_IN:
		return("IN_IN");
	case HMG_HIT_IN_OUT:
		return("IN_OUT");
	case HMG_HIT_OUT_IN:
		return("OUT_IN");
	case HMG_HIT_OUT_OUT:
		return("OUT_OUT");
	case HMG_HIT_IN_ON:
		return("IN_ON");
	case HMG_HIT_ON_IN:
		return("ON_IN");
	case HMG_HIT_OUT_ON:
		return("OUT_ON");
	case HMG_HIT_ON_OUT:
		return("ON_OUT");
	case HMG_HIT_ANY_ANY:
		return("ANY_ANY");
	}
	return("?_?\n");
}

d228 1
a228 1
		*(long *)a_hit->hit.hit_private
d2343 7
d2358 5
d2365 2
a2366 1
		if (a_hit->hit.hit_dist >= 0.0) {
a2367 7
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT)) {
				rt_log("Positive direction hit\n");
				nmg_rt_print_hitmiss(a_hit);
			}
		} else if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT)) {
			rt_log("Negative direction hit\n");
			nmg_rt_print_hitmiss(a_hit);
@


11.3
log
@Fixed some subroutine definitions.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d60 1
a60 1
	rt_log("\tplotting %s\n", name);
d101 1
a101 1
	rt_log("\tplotting %s\n", name);
d133 3
a135 3
void
nmg_rt_print_hitmiss(a_hit)
struct hitmiss *a_hit;
d137 1
a137 9
	NMG_CK_HITMISS(a_hit);
	rt_log("   dist:%12g pt(%g %g %g) %s\n\tstate:",
		a_hit->hit.hit_dist,
		a_hit->hit.hit_point[0],
		a_hit->hit.hit_point[1],
		a_hit->hit.hit_point[2],
		rt_identify_magic(*(int*)a_hit->hit.hit_private) );

	switch(a_hit->in_out) {
d139 1
a139 1
		rt_log("IN_IN"); break;
d141 1
a141 1
		rt_log("IN_OUT"); break;
d143 1
a143 1
		rt_log("OUT_IN"); break;
d145 1
a145 1
		rt_log("OUT_OUT"); break;
d147 1
a147 1
		rt_log("IN_ON"); break;
d149 1
a149 1
		rt_log("ON_IN"); break;
d151 1
a151 1
		rt_log("OUT_ON"); break;
d153 1
a153 1
		rt_log("ON_OUT"); break;
d155 1
a155 3
		rt_log("ANY_ANY"); break;
	default:
		rt_log("?_?\n"); break;
d157 2
d160 15
d571 1
a571 1
		rt_log("\t%s\n", name);
d2163 42
d2211 3
d2286 6
@


11.2
log
@made splits for planar/nurb processing
@
text
@d8 1
a8 1
 *  
d11 1
a11 1
 *	Aberdeen Proving Ground, Maryland  21005-5066  USA
d13 5
d19 2
a20 2
 *	This software is Copyright (C) 1993 by the United States Army.
 *	All rights reserved.
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 11.1 1995/01/04 09:58:15 mike Rel4_4 butler $ (BRL)";
d1816 4
a1819 1
isect_ray_snurb_face(fu_p, fg_p)
d1823 1
d1826 1
@


11.1
log
@Release_4.4
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.33 94/12/20 15:12:35 jra Exp $ (BRL)";
d1415 6
a1420 9

/*	I S E C T _ R A Y _ E D G E U S E
 *
 *	Intersect ray with edgeuse.  If they pass within tolerance, a hit
 *	is generated.
 *
 */
static void
isect_ray_edgeuse(rd, eu_p)
d1426 1
a1427 48
	int vhit1, vhit2;

	NMG_CK_EDGEUSE(eu_p);
	NMG_CK_EDGEUSE(eu_p->eumate_p);
	NMG_CK_EDGE(eu_p->e_p);
	NMG_CK_VERTEXUSE(eu_p->vu_p);
	NMG_CK_VERTEXUSE(eu_p->eumate_p->vu_p);
	NMG_CK_VERTEX(eu_p->vu_p->v_p);
	NMG_CK_VERTEX(eu_p->eumate_p->vu_p->v_p);

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		rt_log("isect_ray_edgeuse (%g %g %g) -> (%g %g %g)",
			eu_p->vu_p->v_p->vg_p->coord[0],
			eu_p->vu_p->v_p->vg_p->coord[1],
			eu_p->vu_p->v_p->vg_p->coord[2],
			eu_p->eumate_p->vu_p->v_p->vg_p->coord[0],
			eu_p->eumate_p->vu_p->v_p->vg_p->coord[1],
			eu_p->eumate_p->vu_p->v_p->vg_p->coord[2]);
	}

	if (eu_p->e_p != eu_p->eumate_p->e_p)
		rt_bomb("edgeuse mate has step-father\n");

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		rt_log("\n\tLooking for previous hit on edge 0x%08x ...\n",
			eu_p->e_p);

	if (myhit = NMG_INDEX_GET(rd->hitmiss, eu_p->e_p)) {
		if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_MAGIC)) {
			/* previously hit vertex or edge */
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tedge previously hit\n");
			return;
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_SUB_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tvertex of edge previously hit\n");
			return;
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_MISS_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tedge previously missed\n");
			return;
		} else {
			nmg_rt_bomb(rd, "what happened?\n");
		}
	}

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		rt_log("\t No previous hit\n");
d1527 71
d1811 5
d1817 1
a1817 6
/*	I S E C T _ R A Y _ F A C E U S E
 *
 *	check to see if ray hits face.
 */
static void
isect_ray_faceuse(rd, fu_p)
d1820 1
d1822 2
a1824 2
	struct loopuse		*lu_p;
	point_t			plane_pt;
a1825 2
	int			code;
	plane_t			norm;
d1827 2
a1828 51

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		rt_log("isect_ray_faceuse(0x%08x, faceuse:0x%08x/face:0x%08x)\n",
			rd, fu_p, fu_p->f_p);

	NMG_CK_FACEUSE(fu_p);
	NMG_CK_FACEUSE(fu_p->fumate_p);
	NMG_CK_FACE(fu_p->f_p);
	NMG_CK_FACE_G_PLANE(fu_p->f_p->g.plane_p);


	/* if this face already processed, we are done. */
	if (myhit = NMG_INDEX_GET(rd->hitmiss, fu_p->f_p)) {
		if (RT_LIST_MAGIC_OK((struct rt_list *)myhit,
		    NMG_RT_HIT_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log(" previously hit\n");
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)myhit,
		    NMG_RT_HIT_SUB_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log(" previously hit sub-element\n");
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)myhit,
		    NMG_RT_MISS_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log(" previously missed\n");
		} else {
			rt_log("%s %d:\n\tBad magic %ld (0x%08x) for hitmiss struct for faceuse 0x%08x\n",
				__FILE__, __LINE__,
				myhit->l.magic, myhit->l.magic, fu_p);
			nmg_rt_bomb(rd, "Was I hit or not?\n");
		}
		return;
	}


	/* bounding box intersection */
	if (!rt_in_rpp(rd->rp, rd->rd_invdir,
	    fu_p->f_p->min_pt, fu_p->f_p->max_pt) ) {
		GET_HITMISS(myhit);
		NMG_INDEX_ASSIGN(rd->hitmiss, fu_p->f_p, myhit);
		myhit->hit.hit_private = (genptr_t)fu_p->f_p;
		RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		RT_LIST_INSERT(&rd->rd_miss, &myhit->l);
	    	NMG_CK_HITMISS(myhit);

		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			rt_log("missed bounding box\n");
		return;
	}

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) rt_log(" hit bounding box \n");
d1964 73
@


1.33
log
@Mods for CRAY.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.32 94/12/05 19:00:18 butler Exp $ (BRL)";
@


1.32
log
@unified debugging in nmg_ray_vs_shell()
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.31 94/11/30 08:43:00 jra Exp Locker: butler $ (BRL)";
d229 1
a229 1
	print_hitlist(&rd->rd_hit);
d1497 2
a1498 2
		vhit1 = isect_ray_vertexuse(rd->rp, eu_p->vu_p);
		vhit2 = isect_ray_vertexuse(rd->rp, eu_p->eumate_p->vu_p);
d2096 1
a2096 1
			print_hitlist(&rd->rd_hit);
@


1.31
log
@Fixed call to nmg_isect_ray_shell in nmg_ray_vs_shell (needed pointer, not actual struct).
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.30 94/11/30 03:59:25 butler Exp Locker: jra $ (BRL)";
d2120 9
a2136 1

d2178 1
a2178 1
	if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
d2186 1
a2186 1
			if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
d2190 1
a2190 1
		} else if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
d2200 2
@


1.30
log
@added support routine nmg_ray_vs_shell() for nmg_class.c to call
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.29 94/11/08 03:33:15 mike Exp Locker: butler $ (BRL)";
d2162 1
a2162 1
	nmg_isect_ray_shell(rd, s);
@


1.29
log
@Irix 6
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.28 94/10/11 19:46:43 butler Exp Locker: mike $ (BRL)";
d2099 94
@


1.28
log
@removed some debugging code that has outlived its usefulness.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.27 1994/09/21 03:37:46 mike Exp butler $ (BRL)";
a511 2

		break;
d981 1
a981 1
		plvu(vu_p, rd->rp->r_pt, myhit->hit.hit_point);
d1047 1
a1047 1
		rt_log(" Ray hits vertex, dist %g (%d/%d)\n",
d1049 1
a1049 1
			(int)myhit->hit.hit_private,
@


1.27
log
@deleted "manifolds" from struct model, and moved it to struct ray_data.
Added extra argument to nmg_dangling_face().
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.26 94/09/02 00:14:25 mike Exp Locker: mike $ (BRL)";
a1697 1
struct hitmiss		*a_hit;
a1790 4
	NMG_CK_HITMISS_LISTS(a_hit, rd);



a1805 1
	struct hitmiss		*a_hit;
a1818 3
#ifdef CHECK_HITMISS_LISTS
	NMG_CK_HITMISS_LISTS(a_hit, rd);
#endif
d1972 1
a1972 1
				fu_p, norm, a_hit);
a1992 2

	NMG_CK_HITMISS_LISTS(a_hit, rd);
@


1.26
log
@Changed return code of get_pole_dist_to_face() to VOID, so that
it would compile on VAPOR.  It never returns a value.
Change FACE_G to FACE_G_PLANE
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.25 94/09/01 23:34:40 butler Exp Locker: mike $ (BRL)";
d1199 1
a1199 1
			       NMG_MANIFOLDS(rd->rd_m->manifolds, fu->f_p)) ){
a1699 1
	struct model *m;
a1716 2
	m = nmg_find_model( (long *)fu_p );

d1724 1
a1724 1
	if ( ! (NMG_MANIFOLDS(m->manifolds, fu_p) & NMG_3MANIFOLD) ) {
@


1.25
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.24 94/08/24 22:48:51 butler Exp Locker: butler $ (BRL)";
d294 1
a294 1
static double
d1826 1
a1826 1
	NMG_CK_FACE_G(fu_p->f_p->fg_p);
@


1.24
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.23 94/08/22 14:52:46 butler Exp Locker: butler $ (BRL)";
d465 2
a466 1
		rt_log("\tplane point beyond both edges.... Doing the Tanenbaum algorithm.\n");
d479 1
a479 1
					rt_log("Tanenbaum says the point is inside the face\n");
d481 1
a481 1
				VMOVE(pca_to_pole_vect, polar_height_vect);
d483 1
a483 3
				/* Point is "outside" face,
				 * PCA is at vertex.
				 */
d485 2
a486 1
					rt_log("Tanenbaum says the point is outside the face, PCA is at the vertex\n");
d496 1
a496 1
					rt_log("Tanenbaum says the point is inside the face\n");
d498 1
a498 1
				VMOVE(pca_to_pole_vect, polar_height_vect);
d500 2
a501 3
				/* Point is "outside" face,
				 * PCA is at vertex.
				 */
d503 1
a503 1
					rt_log("Tanenbaum says the point is outside the face, PCA is at the vertex\n");
d508 5
@


1.23
log
@Broke up isect_ray_faceuse in an attempt to make it more readable and
something the optimizer can handle.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.22 94/08/20 05:32:47 butler Exp $ (BRL)";
d274 2
a275 2
	myhit->outbound_use = (long *)NULL;
	myhit->inbound_use = (long *)NULL;
d455 12
a466 1
	case 0x33:/* Do the Tanenbaum algorithm. */
d468 22
a489 5
	   	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tplane point outside face\n");
		if (VDOT(leftA, VtoPole_prj) > VDOT(leftB, VtoPole_prj)) {
			VSUB2(pca_to_pole_vect, pcaA, Pole);
			VMOVE(Pole_pca, pcaA);
d491 17
a507 2
			VSUB2(pca_to_pole_vect, pcaB, Pole);
			VMOVE(Pole_pca, pcaB);
d510 1
d899 3
a906 1
		myhit->inbound_use = (long *)North_vu;
a907 1
		myhit->outbound_use = (long *)South_vu;
a910 1
		myhit->inbound_use = (long *)NULL;
a911 1
		myhit->outbound_use = (long *)South_vu;
a914 1
		myhit->inbound_use = (long *)North_vu;
a915 1
		myhit->outbound_use = (long *)NULL;
d955 2
a956 2
		myhit->outbound_use = (long *)NULL;
		myhit->inbound_use = (long *)NULL;
d1388 2
a1389 2
	myhit->outbound_use = (long *)NULL;
	myhit->inbound_use = (long *)NULL;
d1700 2
a1701 2
	myhit->outbound_use = (long *)NULL;
	myhit->inbound_use = (long *)NULL;
d1824 1
d1826 1
a1850 1
	NMG_CK_HITMISS_LISTS(a_hit, rd);
a1860 1
		NMG_CK_HITMISS_LISTS(a_hit, rd);
a1875 1
	NMG_CK_HITMISS_LISTS(a_hit, rd);
a1889 1
		NMG_CK_HITMISS_LISTS(a_hit, rd);
a1904 1
		NMG_CK_HITMISS_LISTS(a_hit, rd);
a1930 1
	NMG_CK_HITMISS_LISTS(a_hit, rd);
a1940 1
	NMG_CK_HITMISS_LISTS(a_hit, rd);
a1942 1
	NMG_CK_HITMISS_LISTS(a_hit, rd);
d1948 1
a1948 2
	myhit->inbound_use = myhit->outbound_use = (long *)NULL;
	NMG_CK_HITMISS_LISTS(a_hit, rd);
d1951 1
a1973 1
			NMG_CK_HITMISS_LISTS(a_hit, rd);
a1986 1
		NMG_CK_HITMISS_LISTS(a_hit, rd);
a1996 1
	NMG_CK_HITMISS_LISTS(a_hit, rd);
d2003 2
d2101 1
@


1.22
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.21 94/08/20 05:28:14 butler Exp Locker: butler $ (BRL)";
a312 1
	vect_t VtoPt;
a935 2


d1645 12
d1658 3
d1662 94
a1772 2
	double			cos_angle;
	struct model		*m;
d1916 1
a1940 1

d1945 2
a1946 94
			RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_MAGIC);
			myhit->outbound_use = (long *)NULL;
			myhit->inbound_use = (long *)NULL;


			VMOVE(myhit->hit.hit_point, plane_pt);

			/* also rd->ray_dist_to_plane */
			myhit->hit.hit_dist = dist; 
			myhit->hit.hit_private = (genptr_t)fu_p->f_p;


			/* compute what the ray-state is before and after this
			 * encountering this hit point.
			 */
			m = nmg_find_model( (long *)fu_p );

			cos_angle = VDOT(norm, rd->rp->r_dir);
			if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
				VPRINT("face Normal", norm);
				rt_log("cos_angle wrt ray direction: %g\n", cos_angle);
			}


			if ( ! (NMG_MANIFOLDS(m->manifolds, fu_p) & NMG_3MANIFOLD) ) {
				myhit->in_out = HMG_HIT_ANY_ANY;

				if (cos_angle < rd->tol->perp) {
					VMOVE(myhit->inbound_norm, norm);
					VREVERSE(myhit->outbound_norm, norm);
					myhit->inbound_use = (long *)fu_p;
					myhit->outbound_use = (long *)fu_p->fumate_p;
				} else {
					VREVERSE(myhit->inbound_norm, norm);
					VMOVE(myhit->outbound_norm, norm);
					myhit->inbound_use = (long *)fu_p->fumate_p;
					myhit->outbound_use = (long *)fu_p;
				}

				break;
			}


			switch (fu_p->orientation) {
			case OT_SAME:
				if (RT_VECT_ARE_PERP(cos_angle, rd->tol)) {
					/* perpendicular? */
					rt_log("%s[%d]: Ray is in plane of face?\n",
						__FILE__, __LINE__);
						rt_bomb("I quit\n");
				} else if (cos_angle > 0.0) {
					myhit->in_out = HMG_HIT_IN_OUT;
					VREVERSE(myhit->outbound_norm, norm);
					myhit->outbound_use = (long *)fu_p;
					myhit->inbound_use = (long *)fu_p;
				} else {
					myhit->in_out = HMG_HIT_OUT_IN;
					VMOVE(myhit->inbound_norm, norm);
					myhit->inbound_use = (long *)fu_p;
					myhit->outbound_use = (long *)fu_p;
				}
				break;
			case OT_OPPOSITE:
				if (RT_VECT_ARE_PERP(cos_angle, rd->tol)) {
					/* perpendicular? */
					rt_log("%s[%d]: Ray is in plane of face?\n",
						__FILE__, __LINE__);
						rt_bomb("I quit\n");
				} else if (cos_angle > 0.0) {
					myhit->in_out = HMG_HIT_OUT_IN;
					VREVERSE(myhit->inbound_norm, norm);
					myhit->inbound_use = (long *)fu_p;
					myhit->outbound_use = (long *)fu_p;
				} else {
					myhit->in_out = HMG_HIT_IN_OUT;
					VMOVE(myhit->outbound_norm, norm);
					myhit->inbound_use = (long *)fu_p;
					myhit->outbound_use = (long *)fu_p;
				}
				break;
			default:
				rt_log("%s %d:face orientation not SAME/OPPOSITE\n",
					__FILE__, __LINE__);
				rt_bomb("Crash and burn\n");
			}

			hit_ins(rd, myhit);
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				plfu(fu_p, rd->rp->r_pt, myhit->hit.hit_point);

			NMG_CK_HITMISS(myhit);

			NMG_CK_HITMISS_LISTS(a_hit, rd);

d1961 2
@


1.21
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.20 94/08/10 20:29:34 gdurf Exp Locker: butler $ (BRL)";
d416 4
a419 2
			VPRINT("LeftA", leftA);
			VPRINT("VtoPole_prj", VtoPole_prj);
d437 4
a440 2
			VPRINT("LeftB", leftB);
			VPRINT("VtoPole_prj", VtoPole_prj);
@


1.20
log
@Added include of conf.h
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.19 94/07/01 01:38:34 butler Exp Locker: butler $ (BRL)";
d128 1
d133 1
a133 1
	rt_log("   dist:%12g pt(%g %g %g) %s state:",
a166 1
	rt_log("\n");
d168 2
d296 2
a297 2
	Pole, Pole_prj_pt, Pole_dist,
	pointA, leftA, pointB, leftB, polar_height_vect)
d303 1
d309 1
d313 1
d337 1
d347 1
d366 2
d371 15
d387 1
d390 15
d406 1
d411 2
d414 16
d431 1
d433 15
d449 1
d454 2
d458 1
d461 1
d481 23
d505 65
d598 3
a600 3
 *     Projection of South Pole ^   / Vertex		
 *	  	       to plane	|  /
 *			    	| /
d647 1
d668 3
d680 5
d723 3
d731 6
a736 3
			VJOIN1(North_pl_pt, North_Pole, scalar_dist, anti_norm);
			VJOIN1(South_pl_pt, South_Pole, scalar_dist, norm);
		
d743 1
a743 1
			nmg_find_eu_leftvec(leftA, eu);
d759 4
d765 1
a765 1
				North_Pole, North_pl_pt, &North_dist,
d767 1
a767 1
				polar_height_vect);
d769 3
d783 1
a783 1
				South_Pole, South_pl_pt, &South_dist,
d785 1
a785 1
				polar_height_vect);
d787 3
d797 9
d817 1
d823 1
a827 1

d841 1
d1108 1
d1190 11
d1210 4
d1231 1
a1853 7
			if ( ! (NMG_MANIFOLDS(m->manifolds, fu_p) & NMG_3MANIFOLD) ) {
				myhit->in_out = HMG_HIT_ANY_ANY;
				myhit->inbound_use = (long *)fu_p;
				myhit->outbound_use = (long *)fu_p->fumate_p;
				break;
			}

d1860 20
d1889 1
d1894 1
d1907 1
d1912 1
a2055 3



@


1.19
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.18 1994/06/24 17:33:54 butler Exp butler $ (BRL)";
d21 2
d274 1
d282 2
d852 1
d855 3
d875 1
d877 3
a879 1
	RT_LIST_INSERT(&rd->rd_miss, &myhit->l); }
d906 1
d908 1
d978 2
d1077 1
a1077 1

d1093 1
d1096 1
d1105 2
d1135 1
d1137 2
d1148 1
d1238 2
d1248 2
d1267 1
d1271 2
a1272 1

d1283 1
d1287 2
d1358 1
d1360 3
a1362 1
	RT_LIST_INSERT(&rd->rd_miss, &myhit->l); }
a1365 1

d1397 3
a1400 1
	ray_hit_edge(rd, eu, rd->ray_dist_to_plane, fpi->pt);
d1438 1
d1454 2
d1479 1
d1486 1
d1489 3
d1506 2
d1517 1
d1520 3
d1533 1
d1536 3
d1564 1
d1575 1
d1578 1
d1585 1
d1608 2
d1691 1
d1698 3
d1708 2
d1713 2
d1810 2
d1819 2
a1820 8
#if 0
			while (RT_LIST_NON_EMPTY(&rd->rd_hit) ) {
				a_hit = RT_LIST_FIRST(hitmiss, &rd->rd_hit);
				NMG_CK_HITMISS(a_hit);
				RT_LIST_DEQUEUE(&a_hit->l);
				rt_free((char *)a_hit, "dumping hitlist");
			}
#endif
@


1.18
log
@Finished work on vertex_neighborhood() and get_pole_dist_to_face()
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.17 94/06/24 00:05:19 butler Exp Locker: butler $ (BRL)";
d154 2
d270 2
a307 3



d472 1
d488 1
d511 1
d518 4
d523 3
a525 1
		if (fu && *vu->up.magic_p == NMG_EDGEUSE_MAGIC &&
d580 3
d595 3
d599 4
d606 8
d615 7
a621 1
	VSUB2(VtoPole, North_Pole, vu->v_p->vg_p->coord);
d631 1
d633 1
a633 1
	VSUB2(VtoPole, South_Pole, vu->v_p->vg_p->coord);
d642 29
d682 1
a682 1
static struct hitmiss *
d696 1
a696 1
			return(myhit);
d702 2
a730 2

	return myhit;
d875 2
a876 2
static int
edge_hit_ray_state(rd, eu)
d879 1
d882 2
a883 2
	double min_cos_angle = 2.0;
	double max_cos_angle = -1.0;
d885 4
a888 3
	struct faceuse *min_fu;
	struct faceuse *max_fu;
	int in_out = 0;
d890 1
d893 1
d909 4
d916 2
d919 1
a919 1
			    fu->fumate_p->orientation == OT_SAME)
d921 2
a922 1

d946 6
a951 4
			if (cos_angle < min_cos_angle) {
				min_cos_angle = cos_angle;
				min_fu = fu;
				rt_log("New min cos_angle %g\n", min_cos_angle);
d953 6
a958 4
			if (cos_angle > max_cos_angle) {
				max_cos_angle = cos_angle;
				max_fu = fu;
				rt_log("New max cos_angle %g\n", max_cos_angle);
d964 10
a973 2
	/* min_fu is closest to ray on outbound side
	 * max_fu is closest to ray on inbound side
d977 1
a977 1
	NMG_GET_FU_NORMAL(norm, min_fu);
d981 1
a981 1
		VPRINT("\nmin face normal", norm);
d986 1
a986 1
		in_out |= NMG_RAY_STATE_ON << 4;
d988 1
a988 1
		in_out |= NMG_RAY_STATE_OUTSIDE << 4;
d990 1
a990 1
		in_out |= NMG_RAY_STATE_INSIDE << 4;
d994 1
a994 1
	NMG_GET_FU_NORMAL(norm, max_fu);
d998 1
a998 1
		VPRINT("\nmax face normal", norm);
d1003 1
a1003 1
		in_out |= NMG_RAY_STATE_ON;
d1005 1
a1005 1
		in_out |= NMG_RAY_STATE_OUTSIDE;
d1007 1
a1007 1
		in_out |= NMG_RAY_STATE_INSIDE;
d1011 2
a1012 2
		rt_log("in_out: 0x%02x/", in_out);
		switch(in_out) {
d1033 29
a1061 1
	return in_out;
d1082 21
a1103 1
	GET_HITMISS(myhit);
d1105 2
d1113 1
a1113 1
	myhit->in_out = edge_hit_ray_state(rd, eu_p);
d1164 4
a1167 2
	rt_log("\tLooking for previous hit on edge 0x%08x ...\n", eu_p->e_p);
	
d1187 2
a1188 1
	rt_log("\t No previous hit\n");
d1350 8
a1357 7
	rt_log("eu_touch(%g %g %g -> %g %g %g\n",
		eu->vu_p->v_p->vg_p->coord[0],
		eu->vu_p->v_p->vg_p->coord[1],
		eu->vu_p->v_p->vg_p->coord[2],
		eu_next->vu_p->v_p->vg_p->coord[0],
		eu_next->vu_p->v_p->vg_p->coord[1],
		eu_next->vu_p->v_p->vg_p->coord[2]);
a1362 25
	rt_log("\tLooking for previous hit on edge 0x%08x ...\n",
		eu->e_p);

	if (myhit = NMG_INDEX_GET(rd->hitmiss, eu->e_p)) {
		if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_MAGIC)) {
			/* previously hit vertex or edge */
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tedge previously hit\n");
			return;
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_SUB_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tvertex of edge previously hit\n");
			return;
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_MISS_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tedge previously missed\n");
			return;
		} else {
			nmg_rt_bomb(rd, "what happened?\n");
		}
	}

	rt_log("\t No previous hit\n");


d1374 5
a1378 4
	rt_log("vu_touch(%g %g %g)\n",
		vu->v_p->vg_p->coord[0],
		vu->v_p->vg_p->coord[1],
		vu->v_p->vg_p->coord[2]);
d1405 1
d1526 1
d1556 2
d1559 1
d1570 1
d1572 7
d1592 1
a1592 1
				} else if (cos_angle > 0.0)
d1594 3
a1596 1
				else
d1598 3
d1608 1
a1608 1
				} else if (cos_angle > 0.0)
d1610 3
a1612 1
				else
d1614 3
a1711 1
	rt_g.NMG_debug |= DEBUG_RT_ISECT;
d1748 1
d1755 1
@


1.17
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.16 94/06/22 17:20:46 butler Exp Locker: butler $ (BRL)";
a42 1
	char buf[80];
a43 3
	struct loopuse *lu;
	struct edgeuse *eu;
	struct vertexuse *vu;
a82 1
        char buf[80];
a194 2
	struct faceuse *fu;
	struct vertexuse *vu;
d276 1
a276 1
	return myhit;
d279 117
d402 3
a404 3
 *	There is a conceptual sphere about the vertex.  The point where the
 *	ray enters the sphere is called the "North Pole" and the point where
 *	it exits the sphere is called the "South Pole"  
d406 3
d412 1
a412 1
 *	face.
a413 4
 *		XXX If necessary expand the sphere until the projections for
 *			all faces are no longer within tolerance of the
 *			vertex. 
 *		XXX what about rays (nearly) perpendicular to a face?
d415 23
a459 2
 *
 *
d469 7
a475 1
	struct nmg_ptbl ftbl;
d477 1
a477 3
	vect_t north_vect;	/* vector from vertex to North_Pole */
	vect_t norm, anti_norm;
	point_t	North_pl_pt, South_pl_pt, South_Pole, North_Pole;
a478 1
	double dimen, t;
d480 6
d491 5
a495 1
	(void)nmg_tbl( &ftbl, TBL_INIT, (long *)NULL );
d497 2
a505 5
	nmg_model_bb( min_pt, max_pt, nmg_find_model( vu_p->up.magic_p ));
	for (dimen= -MAX_FASTF,i=3 ; i-- ; ) {
		t = max_pt[i]-min_pt[i];
		if (t > dimen) dimen = t;
	}
d507 1
a507 2
	VJOIN1(North_Pole, vu_p->v_p->vg_p->coord, -dimen, rd->rp->r_dir);
	VJOIN1(South_Pole, vu_p->v_p->vg_p->coord, dimen, rd->rp->r_dir);
a508 1

d516 1
a516 2
		    fu->orientation == OT_SAME &&
		    nmg_tbl(&ftbl, TBL_INS_UNIQUE, &fu->l.magic) < 0 ) {
d518 32
a549 8
		    	/* The distance from each "Pole Point" to the faceuse
		    	 *  is the commodity in which we are interested.
		    	 *
		    	 * A pole point is projected
		    	 * This is either the distance to the plane (if the
		    	 * projection of the point into the plane lies within
		    	 * the angle of the two edgeuses at this vertex) or
		    	 */
d551 8
a558 23
/*
 *
 *
 *		    		    /
 *			  	   /
 *			     	  /North Pole
 *			     	 / |
 *		Face Normal  ^	/  |
 *		 	     | /   |
 *		    	     |/    V Projection of North Pole
 *  Projection of    	     *			 to plane
 *  South Pole to plane ^   / Vertex
 *		    	|  /
 *		    	| /
 *		    	|/
 *		    	/South Pole
 *		       /
 *		     |/
 *		      -
 *		    Ray
 *
 *
 */
a559 2
		    	NMG_GET_FU_NORMAL( norm, fu );
		    	VREVERSE(anti_norm, norm);
d561 5
a565 3
		    	/* project the north pole onto the plane */
		    	VSUB2(north_vect, vu->v_p->vg_p->coord, North_Pole);
			scalar_dist = VDOT(norm, north_vect);
d567 4
a570 3
		    	/* project the poles down onto the plane */
			VJOIN1(North_pl_pt, North_Pole, scalar_dist, anti_norm);
			VJOIN1(South_pl_pt, South_Pole, scalar_dist, norm);
d573 10
d585 22
a606 1
	(void)nmg_tbl( &ftbl, TBL_FREE, (long *)NULL );
d650 1
d654 6
a686 1
	vect_t	v;
@


1.16
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.15 94/06/22 03:09:09 butler Exp Locker: butler $ (BRL)";
d33 2
a40 1
	static int file_number=0;
d51 1
a51 1
	sprintf(name, "ray%02d.pl", file_number++);
d79 19
d99 32
d178 2
a179 2
	rt_log("nmg/ray hit list\n\n");
f
d200 2
d203 1
a203 2
	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		rt_log("hit_ins()\n");
d205 5
a212 7
		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			rt_log("\tahit: 0x%08x dist:%g pt:(%g %g %g)\n",
				a_hit,
				a_hit->hit.hit_dist,
				a_hit->hit.hit_point[0],
				a_hit->hit.hit_point[1],
				a_hit->hit.hit_point[2]);
d218 8
a225 22
	 
	if (RT_LIST_NOT_HEAD(a_hit, &rd->rd_hit)) {
		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		    rt_log ("\tinserting newhit 0x%08x dist:%g pt:(%g %g %g)\n\tprior to 0x%08x dist:%g pt:(%g %g %g)\n",
			newhit,
			newhit->hit.hit_dist,
			newhit->hit.hit_point[0],
			newhit->hit.hit_point[1],
			newhit->hit.hit_point[2],
			a_hit,
			a_hit->hit.hit_dist,
			a_hit->hit.hit_point[0],
			a_hit->hit.hit_point[1],
			a_hit->hit.hit_point[2]);
	} else {
		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		    rt_log ("\tinserting newhit 0x%08x dist:%g pt:(%g %g %g)\n\tat end of list\n",
			newhit,
			newhit->hit.hit_dist,
			newhit->hit.hit_point[0],
			newhit->hit.hit_point[1],
			newhit->hit.hit_point[2]);
d227 1
d229 3
a231 1
	RT_LIST_MAGIC_SET(&newhit->l, NMG_RT_HIT_MAGIC);
d286 2
a287 1
/*
a290 9
 *	N       R
 *	^      ^
 *	|     /
 *	|    / |
 *	|   /  | -NdotR (N)
 *	|  /   |
 *	| /    |
 *	|/     V
 *	.----->Q
d292 38
a338 3
	double NdotR;
	point_t q;
	vect_t		n;
d340 7
a346 3
	double cos_angle;
	hvect_t norm;
	point_t	North_plane_pt, South_plane_pt, South_Pole, North_Pole;
d354 17
d376 4
a379 6
		if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC &&
		    *vu->up.eu_p->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    *vu->up.eu_p->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
		    vu->up.eu_p->up.lu_p->up.fu_p->orientation == OT_SAME &&
		    nmg_tbl(&ftbl, TBL_INS_UNIQUE,
		    &vu->up.eu_p->up.lu_p->up.fu_p->l.magic) < 0 ) {
d381 2
a382 4
		    	/* There is a conceptual sphere around the vertex
		    	 * The point where the ray enters this sphere is
		    	 *  called the North Pole, and the point where it
		    	 *  exits is called the South Pole.
d384 1
a384 2
		    	 * The distance from each "Pole Point" to the faceuse
		    	 *  is the commodity in which we are interested.
d387 1
a387 2
		    	 * the faceuse), or the magnitude of the sum of the
		    	 * vectors point->plane and plane_pt->faceuse boundary
d390 23
a413 4
			fu = vu->up.eu_p->up.lu_p->up.fu_p;
			/* check this face */
			NMG_CK_FACE(fu->f_p);
			NMG_CK_FACE_G(fu->f_p->fg_p);
d415 1
d417 3
d421 3
a424 9
		    	/* compute the "north pole" points
		    	 *
		    	 * project the point a unit distance BACK along the
		    	 * ray and then project the point "back down" onto
		    	 * the plane.
		    	 */
			VJOIN1(North_Pole, vu_p->v_p->vg_p->coord,
				-1.0, rd->rp->r_dir);
		    	VJOIN1(North_plane_pt, North_Pole, cos_angle, norm);
a425 11

		    	/* compute the "south pole" points
		    	 *
		    	 * project the point a unit distance FORWARD along the
		    	 * ray, and then project the point down "back up"
		    	 * onto the plane.
		    	 */
			VADD2(South_Pole, vu_p->v_p->vg_p->coord,
				rd->rp->r_dir);
		    	VJOIN1(South_plane_pt, South_Pole, -cos_angle, norm);

d476 2
d795 8
a1061 1
	plfu(fpi->fu_p, rd->rp->r_pt, fpi->pt);
a1079 1
	plfu(fpi->fu_p, rd->rp->r_pt, fpi->pt);
a1257 1

d1266 4
d1271 2
a1272 1
			if (fu_p->orientation == OT_OPPOSITE) {
d1277 1
a1277 1
					rt_bomb("I quit\n");
d1280 1
a1280 1
				else /* (cos_angle < 0.0) */
d1282 2
a1283 2

			} else if (fu_p->orientation == OT_SAME) {
d1288 1
a1288 1
					rt_bomb("I quit\n");
d1293 5
d1300 3
a1303 1
			hit_ins(rd, myhit);
d1305 2
d1385 1
a1385 1
	struct hitmiss *hm;
d1422 1
a1422 1
		} else
d1424 8
@


1.15
log
@added ray state computations for face/edge hits
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.14 94/06/21 18:40:34 butler Exp Locker: butler $ (BRL)";
d79 39
d126 2
a127 2
	rt_log("nmg/ray hit list\n\tRay_hit_dist	(hitpoint)	struct type	state\n");

d129 1
a129 28
		NMG_CK_HITMISS(a_hit);
		rt_log("\t%12g  (%g %g %g) %s ",
			a_hit->hit.hit_dist,
			a_hit->hit.hit_point[0],
			a_hit->hit.hit_point[1],
			a_hit->hit.hit_point[2],
			rt_identify_magic(*(int*)a_hit->hit.hit_private) );

		switch(a_hit->in_out) {
		case HMG_HIT_IN_IN:
			rt_log("IN_IN\n"); break;
		case HMG_HIT_IN_OUT:
			rt_log("IN_OUT\n"); break;
		case HMG_HIT_OUT_IN:
			rt_log("OUT_IN\n"); break;
		case HMG_HIT_OUT_OUT:
			rt_log("OUT_OUT\n"); break;
		case HMG_HIT_IN_ON:
			rt_log("IN_ON\n"); break;
		case HMG_HIT_ON_IN:
			rt_log("ON_IN\n"); break;
		case HMG_HIT_OUT_ON:
			rt_log("OUT_ON\n"); break;
		case HMG_HIT_ON_OUT:
			rt_log("ON_OUT\n"); break;
		default:
			rt_log("?_?\n"); break;
		}
d553 13
a565 11
eu_p = RT_LIST_PNEXT_CIRC(edgeuse, eu);
rt_log("edge_hit_ray_state(%g %g %g -> %g %g %g _vs_ %g %g %g)\n",
	eu->vu_p->v_p->vg_p->coord[0],
	eu->vu_p->v_p->vg_p->coord[1],
	eu->vu_p->v_p->vg_p->coord[2],
	eu_p->vu_p->v_p->vg_p->coord[0],
	eu_p->vu_p->v_p->vg_p->coord[1],
	eu_p->vu_p->v_p->vg_p->coord[2],
	rd->rp->r_dir[0],
	rd->rp->r_dir[1],
	rd->rp->r_dir[2]);
d575 2
a576 2
				rt_log("%s[%d]: I can't seem to find an OT_SAME faceuse\n", __FILE__, __LINE__);
				rt_bomb("I give up\n");
d583 7
d592 4
a595 2
			rt_log("left_vect:(%g %g %g)  cos_angle:%g\n",
				edge_left[0], edge_left[1], edge_left[2], cos_angle);
a617 2
VPRINT("\nmin face normal", norm);
rt_log("cos_angle wrt ray direction: %g\n", cos_angle);
d619 5
d636 4
a639 2
	VPRINT("\nmax face normal", norm);
	rt_log("cos_angle wrt ray direction: %g\n", cos_angle);
d649 22
a670 20
rt_log("in_out: 0x%02x/", in_out);
	switch(in_out) {
	case HMG_HIT_IN_IN:
		rt_log("IN_IN\n"); break;
	case HMG_HIT_IN_OUT:
		rt_log("IN_OUT\n"); break;
	case HMG_HIT_OUT_IN:
		rt_log("OUT_IN\n"); break;
	case HMG_HIT_OUT_OUT:
		rt_log("OUT_OUT\n"); break;
	case HMG_HIT_IN_ON:
		rt_log("IN_ON\n"); break;
	case HMG_HIT_ON_IN:
		rt_log("ON_IN\n"); break;
	case HMG_HIT_OUT_ON:
		rt_log("OUT_ON\n"); break;
	case HMG_HIT_ON_OUT:
		rt_log("ON_OUT\n"); break;
	default:
		rt_log("?_?\n"); break;
a671 1

@


1.14
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.13 94/06/15 23:42:17 butler Exp Locker: butler $ (BRL)";
d87 1
a87 1
	rt_log("nmg/ray hit list\n");
d91 1
a91 1
		rt_log("\tray_hit_distance %g   pt(%g %g %g) struct %s\n",
d97 21
d519 2
d522 125
d652 1
a652 1
ray_hit_edge(rd, eu_p, dist_along_ray)
d656 1
a667 5

	/* XXX Need to compute IN/OUT status for the ray wrt the faces about
	 * the edge and fill in the in_out element in the hitmiss structure.
	 */

d670 1
a670 2
	VJOIN1(myhit->hit.hit_point, 
		rd->rp->r_pt, dist_along_ray, rd->rp->r_dir);
d673 2
d817 9
a825 2
		ray_hit_edge(rd, eu_p, dist_along_ray);
		break;
a909 1
	plfu(fpi->fu_p, rd->rp->r_pt, fpi->pt);
a933 3
	GET_HITMISS(myhit);
	NMG_INDEX_ASSIGN(rd->hitmiss, eu->e_p, myhit);
	rt_log("\tAssigning hit to edge 0x%08x\n", eu->e_p);
d935 1
a935 2
	/* dist along ray */
	myhit->hit.hit_dist = rd->ray_dist_to_plane;
d937 1
a937 6
	VMOVE(myhit->hit.hit_point, fpi->pt);

	myhit->hit.hit_private = eu->e_p;

	hit_ins(rd, myhit);
	NMG_CK_HITMISS(myhit);
d978 1
a1118 2


d1135 31
@


1.13
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.12 94/06/06 22:12:54 butler Exp Locker: butler $ (BRL)";
d513 1
a513 1
	if (rt_g.NMG_debug & DEBUG_RT_ISECT) rt_log("\t - HIT edge\n");
d568 5
d592 1
a724 18
#if 0
/*
 * Determine whether or not we need to generate a hit on the face, given that
 * an edgeuse was the closest item to the ray/plane intercept.
 *
 */
static void
face_closest_is_eu(rd, fu_p, eu)
struct ray_data *rd;
struct faceuse *fu_p;
struct edgeuse *eu;
{
	struct edgeuse *eu_p;
	struct faceuse *nmg_find_fu_of_eu();
	struct hitmiss *myhit;
	int mate_rad = 0;
	vect_t eu_v, left, pt_v;
    	plane_t		norm;
a725 2
	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		rt_log("face_closest_is_eu()\n");
a726 2
	NMG_CK_EDGEUSE(eu);
	NMG_CK_FACEUSE( fu_p );
a727 177
    	NMG_GET_FU_PLANE( norm, fu_p );

	/* if there is a hit on the edge which is "closest" to the plane
	 * intercept point, then we do not add a hit point for the face
	 */
	if (myhit = NMG_INDEX_GET(rd->hitmiss, eu->e_p)) {
		if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tedge hit, no face hit here\n");
			FACE_MISS(rd, fu_p->f_p);
			return;
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_SUB_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tedge vertex hit, no face hit here\n");
			FACE_MISS(rd, fu_p->f_p);
			return;
		}
	}

	/* There is no hit on the closest edge, so we must determine
	 * whether or not the hit point is "inside" or "outside" the surface
	 * area of the face
	 */
	if (fu_p->orientation == OT_OPPOSITE) {
		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			rt_log("switching faceuses\n");
		fu_p = fu_p->fumate_p;
	}

	/* if eu isn't in this faceuse, go find a use of this edge
	 * that *IS* in this faceuse
	 */
	eu_p = eu;
	while (nmg_find_fu_of_eu(eu_p) != fu_p) {

		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			rt_log("face_closest_is_eu( edgeuse 0x%08x wasn't in faceuse )\n", eu_p);

		if (mate_rad) eu_p = eu_p->eumate_p;
		else eu_p = eu_p->radial_p;
		mate_rad = !mate_rad;

		if (eu_p == eu) {
			nmg_rt_bomb(rd, "couldn't find faceuse as parent of edge\n");
		}
	}


	/* XXX  The Paul Tanenbaum "patch"
	 *	If the vertex of the edge is closer to the point than the
	 *	span of the edge, we must pick the edge leaving the vertex
	 *	which has the smallest value of VDOT(eu->left, vp) where vp
	 *	is the normalized vector from V to P and eu->left is the
	 *	normalized "face" vector of the edge.  This handles the case
	 *	diagramed below, where either e1 OR e2 could be the "closest"
	 *	edge based upon edge-point distances.
	 *
	 *
	 *	    \	    /
	 *		     o P
	 *	      \   /
	 *
	 *	      V o
	 *	       /-\
	 *	      /---\
	 *	     /-   -\
	 *	    /-	   -\
	 *	e1 /-	    -\	e2
	 */

	if (rd->plane_dist_type == NMG_PCA_EDGE_VERTEX &&
	    rd->plane_dist != 0.0) {
	    	/* find the appropriate "closest edge" use of this vertex. */
	    	vect_t vp;
	    	vect_t fv;
		double vdot_min = 2.0;
		double newvdot;
	    	struct edgeuse *closest_eu;
	    	struct faceuse *fu;
	    	struct vertexuse *vu;

	    	/* First we form the unit vector PV */
	    	VSUB2(vp, rd->plane_pt, eu_p->vu_p->v_p->vg_p->coord);
	    	VUNITIZE(vp);

	    	/* for each edge in this face about the vertex, determine
	    	 * the angle between PV and the face vector.  Classify the
		 * plane_pt WRT the edge for which VDOT(left, P) with P
	    	 */
	    	for (RT_LIST_FOR(vu, vertexuse, &eu->vu_p->v_p->vu_hd)) {
	    		/* if there is a faceuse ancestor of this vertexuse
	    		 * which is associated with this face, then perform
	    		 * the VDOT and save the results
	    		 */
			if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC &&
			    (nmg_find_fu_of_vu(vu))->f_p == fu_p->f_p) {

				VCROSS(fv, norm, vu->up.eu_p->e_p->eg_p->e_dir)
				/* since eg_p->dir is not unit length, we must
				 * unitize the result
				 */
				VUNITIZE(fv);
				newvdot = VDOT(fv, vp);
			    	/* if the face vector of eu is "more opposed"
			    	 * to the vector vp than the previous edge,
			    	 * remember this edge as the "closest" one
			    	 */
				if (newvdot < vdot_min) {
					closest_eu = vu->up.eu_p;
					vdot_min = newvdot;
				}
			}
	    	}
	    	fu = nmg_find_fu_of_eu(closest_eu);
	    	if (fu == fu_p) {
		    	eu_p = closest_eu;
		} else if (fu == fu_p->fumate_p) {
		    	eu_p = closest_eu->eumate_p;
		} else {
			nmg_rt_bomb(rd, "why can't i find this edge in this face?\n");
		}
	}

	/* if plane intersect is on the face-surface side of the edge then
	 * we need a hit point on the face.
	 */

	/* XXX */

	GET_HITMISS(myhit);
	NMG_INDEX_ASSIGN(rd->hitmiss, fu_p->f_p, myhit);


	VSUB2(eu_v,eu_p->eumate_p->vu_p->v_p->vg_p->coord,
		eu_p->vu_p->v_p->vg_p->coord);

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		VPRINT("\teu", eu_p->vu_p->v_p->vg_p->coord);
		VPRINT("\teumate", eu_p->eumate_p->vu_p->v_p->vg_p->coord);
		VPRINT("\tpt", rd->plane_pt);
		HPRINT("\tN", norm);
		VPRINT("\teu_v", eu_v);
	}
	VCROSS(left, norm, eu_v);
	VSUB2(pt_v, rd->plane_pt, eu_p->vu_p->v_p->vg_p->coord);

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		VPRINT("\tleft", left);
		VPRINT("\tpt_v", pt_v);
	}

	if (VDOT(left, pt_v) < 0.0) {
		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			rt_log("face_closest_is_eu( plane hit outside face )\n");
		RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
		RT_LIST_INSERT(&rd->rd_miss, &myhit->l);
		return;
	}

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		rt_log("face_closest_is_eu( New hit on face )\n");

	myhit->dist_in_plane = 0.0;

	VMOVE(myhit->hit.hit_point, rd->plane_pt);
	myhit->hit.hit_dist = rd->ray_dist_to_plane;
	myhit->hit.hit_private = (genptr_t) fu_p->f_p;

	/* add hit to list of hit points */
	hit_ins(rd, myhit);
	NMG_CK_HITMISS(myhit);
}

/* 
 * The element which was closest to the plane intercept was a vertex(use).
 *
 */
a728 69
face_closest_is_vu(rd, fu_p, vu)
struct ray_data *rd;
struct faceuse *fu_p;
struct vertexuse *vu;
{
	struct vertexuse *vu_p;
	struct faceuse *nmg_find_fu_of_vu();
	struct hitmiss *myhit;
	struct faceuse *fu;

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		rt_log("face_closest_is_vu\n");

	if (myhit = NMG_INDEX_GET(rd->hitmiss, vu->v_p)) {
		if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_MAGIC)) {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tvertex hit, no face hit here\n");
			FACE_MISS(rd, fu_p->f_p);
			return;
		}
	}

	/* if vu isn't in this faceuse, go find a use of this vertex
	 * that *IS* in this faceuse.
	 */
	fu = nmg_find_fu_of_vu(vu);		
	if (fu != fu_p) {
		for (RT_LIST_FOR(vu_p, vertexuse, &vu->v_p->vu_hd)) {
			if (nmg_find_fu_of_vu(vu) == fu_p)
				goto got_fu;
		}
		nmg_rt_bomb(rd, "didn't find faceuse from plane_closest vertex\n");
got_fu:
		vu = vu_p;
	}

	GET_HITMISS(myhit);
	NMG_INDEX_ASSIGN(rd->hitmiss, fu_p->f_p, myhit);

	/* XXX */
	if (*vu->up.magic_p == NMG_LOOPUSE_MAGIC) {
		struct loopuse *lu = vu->up.lu_p;
		if (lu->orientation == OT_OPPOSITE) {
			/* if parent is OT_OPPOSITE loopuse, we've hit face */
		} else if (lu->orientation == OT_SAME) {
			/* if parent is OT_SAME loopuse, we've missed face */
			RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
			RT_LIST_INSERT(&rd->rd_miss, &myhit->l);
		} else {
			rt_log("non-oriented loopuse parent at: %s %d\n",
				__FILE__, __LINE__);
			nmg_rt_bomb(rd, "goodnight\n");
		}
	} else if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC) {
		/* if parent is edgeuse, do left/right computation 
		 * XXX
		 */
	} else {
		rt_log("vertexuse has strange parent at: %s %d\n",
			__FILE__, __LINE__);
		nmg_rt_bomb(rd, "arrivaderchi\n");
	}

}
#endif



static void
d733 1
a733 1
	struct edgeuse *eu_p;
d737 7
a743 1
	eu_p = RT_LIST_PNEXT_CIRC(edgeuse, eu);
d745 2
d751 3
a753 3
		eu_p->vu_p->v_p->vg_p->coord[0],
		eu_p->vu_p->v_p->vg_p->coord[1],
		eu_p->vu_p->v_p->vg_p->coord[2]);
a754 1

d756 1
d760 4
a763 1
	if (myhit = NMG_INDEX_GET(rd->hitmiss, eu_p->e_p)) {
d782 1
d784 2
a785 1
	NMG_INDEX_ASSIGN(rd->hitmiss, eu_p->e_p, myhit);
d792 1
a792 1
	myhit->hit.hit_private = eu;
d814 1
d884 3
a887 1

a916 1
	/* ray hits plane */
d918 6
a923 1
	/* project point into plane of face */
a924 3
	rd->plane_pt = plane_pt;
	rd->plane_dist = MAX_FASTF;
	rd->ray_dist_to_plane = dist;
a925 1

d934 1
a934 1
			
d936 1
a936 3

		rt_log("\tdistance along ray to intersection point %g\n",
			dist);
d942 4
d947 3
a949 1
	fpi = nmg_class_pt_fu_except(rd->plane_pt, fu_p, (struct loopuse *)NULL,
d965 10
a974 1
		RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_MAGIC);
a975 2
		/* This could have used rd->plane_pt */
		VMOVE(myhit->hit.hit_point, plane_pt);
a976 2
		/* also rd->ray_dist_to_plane */
		myhit->hit.hit_dist = dist; 
d978 3
a980 1
		myhit->hit.hit_private = (genptr_t)fu_p->f_p;
d982 16
a997 2
		hit_ins(rd, myhit);
		NMG_CK_HITMISS(myhit);
@


1.12
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.11 1994/05/24 16:02:01 butler Exp butler $ (BRL)";
d32 1
d90 1
d356 2
a518 6
	/* Since this is a ray/edge intersection, we don't consider
	 * this hit in the "nearest hit" calculations for a faceuse
	 * hit.  That comes later with the edge/hitpoint
	 * consideration.
	 */
	myhit->dist_in_plane = 0.0;
a519 1

d531 1
d719 1
d914 1
d986 1
d988 2
d996 2
d1008 37
d1053 2
d1059 5
d1086 2
a1087 2
		rt_log("isect_ray_faceuse(0x%08x, face:0x%08x)\n",
			rd, fu_p->f_p);
d1194 10
a1203 9
	/* find the object which is "closest" to the ray/plane intercept.
	 * If this element was hit, we don't need to generate a hit point on
	 * the surface of the face.  If it was a miss, we may need to generate
	 * a hit on the surface of the face.
	 */
	switch (*fpi->closest) {
	case NMG_VERTEXUSE_MAGIC:
		face_closest_is_vu(rd, fu_p,
			(struct vertexuse *)fpi->closest);
d1205 14
a1218 3
	case NMG_EDGEUSE_MAGIC:
		face_closest_is_eu(rd, fu_p,
			(struct edgeuse *)fpi->closest);
d1220 8
a1227 5
	default:
		rt_log("%s %d Bogus magic (0x%08x/%dfor element closest to plane/face intercept\n",
			__FILE__, __LINE__,
			*rd->plane_closest, *rd->plane_closest);
		nmg_rt_bomb(rd, "Hello.  My $NAME is Indigo Montoya.  You killed my process.  Prepare to vi!\n");
a1229 2
	rd->plane_pt = (pointp_t)NULL;

a1232 2


d1327 8
@


1.11
log
@about to rearrange the world
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.10 1993/12/27 22:45:40 mike Exp butler $ (BRL)";
d22 1
d32 46
a435 2
 * XXX Is there something we could remember for the "closest hit" algorithm?
 *
a540 4
 *	If the edgeuse is part of a face, (plane_pt is set) then we also
 *	compute the distance from the edge to the plane_pt.  If this is
 *	less than the previous "closest" value then record this edgeuse as
 *	the "plane_closest" object.
a676 21
/*
 *	Find the distance from a point (rd->plane_pt) in the plane of a face
 *	to a vertexuse in the plane of the face.  The distance is stored in
 *	rd->plane_dist if it is less than the current value.  If the value
 *	is stored, rd->plane_closest gets vu_p and rd->plane_dist_type is
 *	set to NMG_PCA_VERTEX.
 *
 *	Uses:
 *	CONST	rd->tol
 *	CONST	rd->plane_pt
 *		rd->plane_dist
 *		rd->plane_dist_type
 *		rd->plane_closest
 */
static void
dist_plane_pt_vu(rd, vu_p)
struct ray_data *rd;
struct vertexuse *vu_p;
{
	vect_t v;
	fastf_t dist;
a677 178
	/* Form a vector from the vertexuse to the plane_pt.
	 * Take the magnitude of the vector to find the distance
	 * between the two points.
	 */
    	VSUB2(v, rd->plane_pt, vu_p->v_p->vg_p->coord);	
	dist = MAGNITUDE(v);

#if 0
	/* make sure there is a hit on the vertex */
#endif

	if (dist < rd->plane_dist) {
		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			rt_log("Vertex (%g %g %g) is new closest\n",
				vu_p->v_p->vg_p->coord[0],
				vu_p->v_p->vg_p->coord[1],
				vu_p->v_p->vg_p->coord[2]);
		rd->plane_dist = dist;
		rd->plane_dist_type = NMG_PCA_VERTEX;
		rd->plane_closest = (long *)vu_p->v_p;
	}
}

/*
 *	Find the distance from a point (rd->plane_pt) in the plane of a 
 *	face to an edgeuse in the plane of the face.  Store the distance 
 *	result in rd->plane_dist and eu_p in rd->plane_closest if this
 *	distance is less than rd->plane_dist at the time of calling.
 *
 *	Uses:
 *	CONST	rd->tol
 *	CONST	rd->plane_pt
 *		rd->plane_dist
 *		rd->plane_dist_type
 *		rd->plane_closest
 */
static void
dist_plane_pt_eu(rd, eu_p)
struct ray_data *rd;
struct edgeuse *eu_p;
{
	fastf_t dist;
	point_t pca;
	int status;
	struct edgeuse *eu;

	if (rt_g.NMG_debug & DEBUG_RT_ISECT) {
		rt_log(
		"dist_plane_pt_eu((%g %g %g), 0x%08x(%g %g %g -> %g %g %g)\n",
				rd->plane_pt[0],
				rd->plane_pt[1],
				rd->plane_pt[2],
				eu_p,
				eu_p->vu_p->v_p->vg_p->coord[0],
				eu_p->vu_p->v_p->vg_p->coord[1],
				eu_p->vu_p->v_p->vg_p->coord[2],
				eu_p->eumate_p->vu_p->v_p->vg_p->coord[0],
				eu_p->eumate_p->vu_p->v_p->vg_p->coord[1],
				eu_p->eumate_p->vu_p->v_p->vg_p->coord[2]);
		rt_log("\told plane_dist = %g\n", rd->plane_dist);
		switch(rd->plane_dist_type) {
		case NMG_PCA_EDGE	:
			rt_log("\told plane_dist_type NMG_PCA_EDGE\n"); break;
		case NMG_PCA_EDGE_VERTEX :
			rt_log("\told plane_dist_type NMG_PCA_EDGE_VERTEX\n"); break;
		case NMG_PCA_VERTEX	:
			rt_log("\told plane_dist_type NMG_PCA_VERTEX\n"); break;
		default:
			rt_log("\told plane_dist_type UNDEFINED\n"); break;
		}
	}

	/* Determine if the plane intercept is closer to this edgeuse than
	 * the previously closest edge/vertex
	 */
	dist = 0.0;
	status = rt_dist_pt3_lseg3(&dist, pca,
		eu_p->vu_p->v_p->vg_p->coord,
		eu_p->eumate_p->vu_p->v_p->vg_p->coord, rd->plane_pt,
		rd->tol);

	switch (status) {
	case 0: /* we hit the edge(use) with the plane_pt,
		 * store edgeuse ptr in plane_closest,
		 * set plane_dist = 0.0
		 *
		 * dist is the parametric distance along the edge where
		 * the PCA occurrs!
		 */

		rd->plane_dist = 0.0;
		rd->plane_closest = &eu_p->l.magic;
		rd->plane_dist_type = NMG_PCA_EDGE;
		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
			rt_log(	"\tplane_pt on eu, (new dist: %g)\n",
				rd->plane_dist);
		break;
	case 1:	/* within tolerance of endpoint at eu_p->vu_p.
		   store vertexuse ptr in plane_closest,
		   set plane_dist = 0.0 */
		if (dist < rd->plane_dist) {
			rd->plane_dist = 0.0;
			rd->plane_closest = &eu_p->vu_p->l.magic;
			rd->plane_dist_type = NMG_PCA_EDGE_VERTEX;
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tplane_pt on vu (new dist %g)\n",
					rd->plane_dist);
		} else {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tplane_pt on vu(dist %g) keeping old dist %g)\n",
					dist, rd->plane_dist);
		}
		break;
	case 2:	/* within tolerance of endpoint at eu_p->eumate_p
		   store vertexuse ptr (eu->next) in plane_closest,
		   set plane_dist = 0.0 */
		if (dist < rd->plane_dist) {
			eu = RT_LIST_PNEXT_CIRC(edgeuse, &(eu_p->l));
			rd->plane_dist = 0.0;
			rd->plane_closest = &eu->vu_p->l.magic;
			rd->plane_dist_type = NMG_PCA_EDGE_VERTEX;
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tplane_pt on next(eu_p)->vu (new dist %g)\n",
					rd->plane_dist);
		} else {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tplane_pt on next(eu_p)->vu(dist %g) keeping old dist %g)\n",
					dist, rd->plane_dist);
		}

		break;
	case 3: /* PCA of pt on line is "before" eu_p->vu_p of seg */
		if (dist < rd->plane_dist) {
			rd->plane_dist = dist;
			rd->plane_closest = &eu_p->vu_p->l.magic;
			rd->plane_dist_type = NMG_PCA_EDGE_VERTEX;
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\vu of eu is new \"closest to plane_pt\" (new dist %g)\n", rd->plane_dist);
		} else {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\vu of eu is PCA (dist %g).  keeping old dist %g\n", dist, rd->plane_dist);
		}
		break;
	case 4: /* PCA of pt on line is "after" eu_p->eumate_p->vu_p of seg */
		if (dist < rd->plane_dist) {
			eu = RT_LIST_PNEXT_CIRC(edgeuse, &(eu_p->l));
			rd->plane_dist = dist;
			rd->plane_closest = &eu->vu_p->l.magic;
			rd->plane_dist_type = NMG_PCA_EDGE_VERTEX;
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\tvu of next(eu) is new \"closest to plane_pt\" (new dist %g)\n", rd->plane_dist);
		} else {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\vu of next(eu) is PCA (dist %g).  keeping old dist %g\n", dist, rd->plane_dist);
		}
		break;
	case 5: /* PCA is along length of edge, but point is NOT on edge.
		 *  if edge is closer to plane_pt than any previous item,
		 *  store edgeuse ptr in plane_closest and set plane_dist
		 */
		if (dist < rd->plane_dist) {
			rd->plane_dist = dist;
			rd->plane_closest = &eu_p->l.magic;
			rd->plane_dist_type = NMG_PCA_EDGE;
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\teu is new \"closest to plane_pt\" (new dist %g)\n", rd->plane_dist);
		} else {
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
				rt_log("\teu dist is %g, keeping old dist %g)\n", dist, rd->plane_dist);
		}
		break;
	default :
		nmg_rt_bomb(rd, "Look, there has to be SOMETHING about this edge/plane_pt\n");
		break;
	}
}


d696 2
a697 16
		if (rd->plane_pt) {
			for (RT_LIST_FOR(eu_p, edgeuse, &lu_p->down_hd)) {
				/* first we determine if the ray hits
				 * the edge
				 */
				isect_ray_edgeuse(rd, eu_p);

				/* now we determine if the distance of the
				 * ray-plane intercept to the edge(use)
				 */
				dist_plane_pt_eu(rd, eu_p);
			}
		} else {
			for (RT_LIST_FOR(eu_p, edgeuse, &lu_p->down_hd)) {
				isect_ray_edgeuse(rd, eu_p);
			}
a709 3
	if (rd->plane_pt)
		dist_plane_pt_vu(rd,
			RT_LIST_FIRST(vertexuse, &lu_p->down_hd));
d954 1
a954 1
		got_fu:
d976 3
a978 1
		/* if parent is edgeuse, do left/right computation */
d987 32
d1028 7
a1034 6
	fastf_t dist;
	struct loopuse *lu_p;
	point_t plane_pt;
	struct hitmiss *myhit;
	int code;
	plane_t		norm;
d1122 1
d1139 5
a1143 1
	/* determine if the plane point is in or out of the face */
d1145 1
a1145 18

	/* intersect the ray with the edges/verticies of the face */




	/* check each loopuse in the faceuse to determine hit/miss. */
	for ( RT_LIST_FOR(lu_p, loopuse, &fu_p->lu_hd) )
		isect_ray_loopuse(rd, lu_p);

	/* find the object which is "closest" to the ray/plane intercept. */
#if 0
	class = nmg_class_pt_fu_except(rd->plane_pt, fu,
		(struct loopuse *)NULL,
		&dist, &type, &magic_p rd->tol);
#endif

	/* find the sub-element that was closest to the point of intersection.
d1150 1
a1150 1
	switch (*rd->plane_closest) {
d1153 1
a1153 1
			(struct vertexuse *)rd->plane_closest);
d1157 1
a1157 1
			(struct edgeuse *)rd->plane_closest);
d1167 6
@


1.10
log
@Moved bounding box for faces from struct face_g to struct face.
Necessary because face geometry is now shared by multiple faces
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.9 93/12/03 03:35:47 mike Exp Locker: mike $ (BRL)";
d167 11
a177 12

N       R
^      ^
|     /
|    / |
|   /  | -NdotR (N)
|  /   |
| /    |
|/     V
.----->Q


d191 3
a194 1

d204 1
a204 1
		 * OT_SAME faceuse...
d209 3
a211 1
		    vu->up.eu_p->up.lu_p->up.fu_p->orientation == OT_SAME) {
d213 12
d226 1
a227 7

		    	/* if we've already done this face,
		    	 * skip on to the next
		    	 */
			if (nmg_tbl(&ftbl, TBL_INS_UNIQUE, &fu->l.magic) >= 0)
				continue;

d231 1
a231 1
		    	NMG_GET_FU_NORMAL( n, fu );
a232 3
			NdotR = VDOT(n, rd->rp->r_dir);
			VADD2(q, vu_p->v_p->vg_p->coord, rd->rp->r_dir);
			VJOIN1(q, q, NdotR, n);
d234 22
a255 4
			/* pt "q" should be on plane of the face.
			 * determine if it is in/on/out of the face boundary
			 * XXX
			 */
d261 5
d636 14
a649 1

d657 5
d665 3
a667 3
	if (dist < rd->tol->dist) {
		/* make sure there is a hit on the vertex */
	}
d680 14
d729 1
a753 1
		/* XXX make sure we have a hit on this edge? */
a769 1
		/* XXX make sure we have a hit on the vertex? */
d787 1
a787 1
		/* XXX make sure we have a hit on the vertex? */
d835 1
d896 5
a987 1
	 *
d1029 1
a1029 1
					vdot_min - newvdot;
d1177 2
a1178 1
		rt_log("isect_ray_faceuse(0x%08x, face:0x%08x)", rd, fu_p->f_p);
d1187 2
a1188 1
		if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_MAGIC)) {
d1191 2
a1192 1
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_HIT_SUB_MAGIC)) {
d1195 2
a1196 1
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)myhit, NMG_RT_MISS_MAGIC)) {
d1200 3
d1278 9
a1286 3
	/* check each loopuse in the faceuse to determine hit/miss and
	 * find the object which is "closest" to the ray/plane intercept.
	 */
d1290 6
d1385 1
@


1.9
log
@Access to plane equation / surface normal in face_geometry structure
is now done through macros NMG_GET_FU_PLANE() NMG_GET_FU_NORMAL(),
which honor the f->flip flag.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.8 93/12/02 20:58:53 mike Exp Locker: mike $ (BRL)";
d1139 1
a1139 1
	    fu_p->f_p->fg_p->min_pt, fu_p->f_p->fg_p->max_pt) ) {
@


1.8
log
@Lee added "status" arg to ray_hit_vertex()
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.7 93/10/01 20:18:08 mike Exp Locker: butler $ (BRL)";
d190 1
a190 1
	vectp_t N;
d222 1
a222 1
			N = fu->f_p->fg_p->N;
d224 1
a224 1
			NdotR = VDOT(N, rd->rp->r_dir);
d226 1
a226 1
			VJOIN1(q, q, NdotR, N);
d846 1
d852 1
d854 2
d952 1
a952 1
				VCROSS(fv, fu_p->f_p->fg_p->N, vu->up.eu_p->e_p->eg_p->e_dir)
d995 1
a995 1
		HPRINT("\tN", fu_p->f_p->fg_p->N);
d998 1
a998 1
	VCROSS(left, fu_p->f_p->fg_p->N, eu_v);
d1109 1
d1151 2
d1154 1
a1154 1
			fu_p->f_p->fg_p->N, rd->tol);
@


1.7
log
@Added 2 function declarations, for ANSI compilers.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.6 93/10/01 20:15:33 butler Exp Locker: mike $ (BRL)";
d242 1
a242 1
ray_hit_vertex(rd, vu_p)
d245 1
d340 1
a340 1
	ray_hit_vertex(rd, vu_p);
d370 1
a373 4
	ray_hit_vertex(rd, eu_p->vu_p);
	ray_hit_vertex(rd, eu_p->eumate_p->vu_p);


d377 3
a379 1
	/* let's remember that this should be an in/out segment */
d381 1
d383 2
d387 1
d389 2
d409 6
a414 1
	ray_hit_vertex(rd, vu_p); \
@


1.6
log
@Changed DEBUG_NMGRT to DEBUG_RT_ISECT.
Added code to assess a vertex neighborhood.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.5 1993/09/02 16:17:19 butler Exp butler $ (BRL)";
d28 2
a176 1

@


1.5
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.4 1993/09/01 20:22:30 butler Exp butler $ (BRL)";
d34 1
a34 1
	if (!(rt_g.NMG_debug & DEBUG_NMGRT))
d65 1
a65 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d71 1
a71 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d85 1
a85 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d98 1
a98 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d125 1
a125 1
	if (rt_g.NMG_debug & DEBUG_NMGRT) {
d135 1
a135 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d138 1
a138 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d144 1
a144 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d162 3
d166 9
d176 60
d248 1
a248 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d268 6
d300 1
a300 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d307 1
a307 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d316 1
a316 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d321 1
a321 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
a327 1

d340 1
a340 1
	if (rt_g.NMG_debug & DEBUG_NMGRT) {
d368 1
a368 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d380 2
a381 2
		vhit1->in_out = NMG_HITMISS_SEG_OUT;
		vhit2->in_out = NMG_HITMISS_SEG_IN;
d383 2
a384 2
		vhit1->in_out = NMG_HITMISS_SEG_IN;
		vhit2->in_out = NMG_HITMISS_SEG_OUT;
d398 1
a398 1
 *  is called to build the hit structures for the vertex and the edge.
d401 1
a401 1
	if (rt_g.NMG_debug & DEBUG_NMGRT) rt_log("hit_edge_vertex\n"); \
d408 14
d423 27
d466 1
a467 1
	struct hitmiss *myhit;
d478 1
a478 1
	if (rt_g.NMG_debug & DEBUG_NMGRT) {
d491 1
a491 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d495 1
a495 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d499 1
a499 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d503 1
a503 1
			rt_bomb("what happened?\n");
d523 1
a523 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d548 1
a548 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d563 1
a563 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d586 1
a586 24
		if (rt_g.NMG_debug & DEBUG_NMGRT)
			rt_log("\t - HIT edge\n");

		ray_miss_vertex(rd, eu_p->vu_p);
		ray_miss_vertex(rd, eu_p->eumate_p->vu_p);

		/* create hit structure for this edge */
		GET_HITMISS(myhit);
		NMG_INDEX_ASSIGN(rd->hitmiss, eu_p->e_p, myhit);

		/* Since this is a ray/edge intersection, we don't consider
		 * this hit in the "nearest hit" calculations for a faceuse
		 * hit.  That comes later with the edge/hitpoint
		 * consideration.
		 */
		myhit->dist_in_plane = 0.0;

		/* build the hit structure */
		myhit->hit.hit_dist = dist_along_ray;
		VJOIN1(myhit->hit.hit_point, 
				rd->rp->r_pt, dist_along_ray, rd->rp->r_dir);
		myhit->hit.hit_private = (genptr_t) eu_p->e_p;

		hit_ins(rd, myhit);
d611 1
a611 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d631 1
a631 1
	if (rt_g.NMG_debug & DEBUG_NMGRT) {
d677 1
a677 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d689 1
a689 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d693 1
a693 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d707 1
a707 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d711 1
a711 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d722 1
a722 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d725 1
a725 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d735 1
a735 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d738 1
a738 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d750 1
a750 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d753 1
a753 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d758 1
a758 1
		rt_bomb("Look, there has to be SOMETHING about this edge/plane_pt\n");
d773 1
a773 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d802 1
a802 1
		rt_bomb(" bad loopuse child magic");
d835 1
a835 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d845 1
a845 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d850 1
a850 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d862 1
a862 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d873 1
a873 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d881 1
a881 1
			rt_bomb("couldn't find faceuse as parent of edge\n");
d958 1
a958 1
			rt_bomb("why can't i find this edge in this face?\n");
d975 1
a975 1
	if (rt_g.NMG_debug & DEBUG_NMGRT) {
d985 1
a985 1
	if (rt_g.NMG_debug & DEBUG_NMGRT) {
d991 1
a991 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d998 1
a998 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d1026 1
a1026 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d1031 1
a1031 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d1047 1
a1047 1
		rt_bomb("didn't find faceuse from plane_closest vertex\n");
d1067 1
a1067 1
			rt_bomb("goodnight\n");
d1074 1
a1074 1
		rt_bomb("arrivaderchi\n");
d1094 1
a1094 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d1105 1
a1105 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d1108 1
a1108 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d1111 1
a1111 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d1114 1
a1114 1
			rt_bomb("Was I hit or not?\n");
d1127 1
a1127 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d1132 1
a1132 1
	if (rt_g.NMG_debug & DEBUG_NMGRT) rt_log(" hit bounding box \n");
d1141 1
a1141 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d1171 1
a1171 1
	if (rt_g.NMG_debug & DEBUG_NMGRT) {
d1212 1
a1212 1
		rt_bomb("Hello.  My $NAME is Indigo Montoya.  You killed my process.  Prepare to vi!\n");
d1233 1
a1233 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d1245 1
a1245 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d1265 1
a1265 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d1270 1
a1270 1
/*	N M G _ I S E C T _ R A Y
d1282 1
a1282 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d1307 1
a1307 1
			nmg_isect_ray_shell(&rd, s_p);
@


1.4
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.3 1993/09/01 01:26:54 butler Exp butler $ (BRL)";
d68 1
a68 1
	for (RT_LIST_FOR(a_hit, hitmiss, &rd->rd_hit.l)) {
d84 1
a84 1
	if (RT_LIST_NOT_HEAD(a_hit, &rd->rd_hit.l)) {
d157 1
a157 1
	RT_LIST_INSERT(&rd->rd_miss.l, &myhit->l);
d315 1
a315 1
	RT_LIST_INSERT(&rd->rd_miss.l, &myhit->l);
d329 1
a329 1
	RT_LIST_INSERT(&rd->rd_miss.l, &myhit->l); }
d421 1
a421 1
		RT_LIST_INSERT(&rd->rd_miss.l, &myhit->l);
d441 1
a441 1
		RT_LIST_INSERT(&rd->rd_miss.l, &myhit->l);
d455 1
a455 1
		RT_LIST_INSERT(&rd->rd_miss.l, &myhit->l);
d726 1
a726 1
	RT_LIST_INSERT(&rd->rd_miss.l, &myhit->l); }
d899 1
a899 1
		RT_LIST_INSERT(&rd->rd_miss.l, &myhit->l);
d928 1
a928 1
	struct hitmiss *hit;
d934 2
a935 2
	if (hit = NMG_INDEX_GET(rd->hitmiss, vu->v_p)) {
		if (RT_LIST_MAGIC_OK((struct rt_list *)hit, NMG_RT_HIT_MAGIC)) {
d965 1
a965 1
		} else if lu->orientation == OT_SAME) {
d968 1
a968 1
			RT_LIST_INSERT(&rd->rd_miss.l, &myhit->l);
d974 1
a974 1
	} else if *vu->up.magic_p == NMG_EDGEUSE_MAGIC) {
d1026 1
a1026 1
	if (!rt_in_rpp(rd->rp, rd->invdir,
d1031 1
a1031 1
		RT_LIST_INSERT(&rd->rd_miss.l, &myhit->l);
d1052 1
a1052 1
		RT_LIST_INSERT(&rd->rd_miss.l, &myhit->l);
d1064 1
a1064 1
		RT_LIST_INSERT(&rd->rd_miss.l, &myhit->l);
d1148 1
a1148 1
	if (!rt_in_rpp(rd->rp, rd->invdir,
d1179 1
a1179 1
nmg_isect_ray_model(rd, m)
a1180 1
struct model *m;
d1189 6
a1194 6
			rp->r_pt[0],
			rp->r_pt[1],
			rp->r_pt[2],
			rp->r_dir[0],
			rp->r_dir[1],
			rp->r_dir[2]);
d1196 1
a1196 1
	NMG_CK_MODEL(m);
d1201 1
a1201 1
	for ( RT_LIST_FOR(r_p, nmgregion, &m->r_hd) ) {
d1206 2
a1207 2
		if (! rt_in_rpp(rd->rp, rd->invdir,
		    rd->r_p->ra_p->min_pt, rd->r_p->ra_p->max_pt) )
d1211 1
a1211 1
		for (RT_LIST_FOR(s_p, shell, &rd->r_p->s_hd)) {
a1214 2

	return(hm);
@


1.3
log
@checkpoint
@
text
@d2 1
a2 1
 *			N M G _ R T . C
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.2 1993/07/23 15:56:10 butler Exp butler $ (BRL)";
d68 1
a68 1
	for (RT_LIST_FOR(a_hit, hitmiss, &rd->hitmiss[NMG_HIT_LIST]->l)) {
d84 1
a84 1
	if (RT_LIST_NOT_HEAD(a_hit, &rd->hitmiss[NMG_HIT_LIST]->l)) {
d157 1
a157 1
	RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &myhit->l);
d315 1
a315 1
	RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &myhit->l);
d329 1
a329 1
	RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &myhit->l); }
d399 4
a402 7
		 * help us.  Intersect the ray with a vertex.  If it hits, 
		 * then this edge is a "sub-hit".  If it misses then both 
		 * the vertex and the edge are missed by the ray.
		 *
		 * Note.  There is no need to see if this edge (its verticies
		 * really) was the closest item to the hit point in the face.
		 * That will be handled by isect_ray_vertexuse() in this case.
d421 1
a421 1
		RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &myhit->l);
d441 1
a441 1
		RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &myhit->l);
d455 1
a455 1
		RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &myhit->l);
d726 1
a726 1
	RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &myhit->l); }
d736 1
a736 1
	struct hitmiss *hit;
d748 2
a749 2
	if (hit = NMG_INDEX_GET(rd->hitmiss, eu->e_p)) {
		if (RT_LIST_MAGIC_OK((struct rt_list *)hit, NMG_RT_HIT_MAGIC)) {
d754 1
a754 1
		} else if (RT_LIST_MAGIC_OK((struct rt_list *)hit, NMG_RT_HIT_SUB_MAGIC)) {
d873 2
a874 2
	GET_HITMISS(hit);
	NMG_INDEX_ASSIGN(rd->hitmiss, fu_p->f_p, hit);
d898 2
a899 2
		RT_LIST_MAGIC_SET(&hit->l, NMG_RT_MISS_MAGIC);
		RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &hit->l);
d906 1
a906 1
	hit->dist_in_plane = 0.0;
d908 3
a910 3
	VMOVE(hit->hit.hit_point, rd->plane_pt);
	hit->hit.hit_dist = rd->ray_dist_to_plane;
	hit->hit.hit_private = (genptr_t) fu_p->f_p;
d913 1
a913 1
	hit_ins(rd, hit);
d916 4
d957 3
d961 20
a981 3
	/* if parent is OT_SAME loopuse, we've missed face */
	/* if parent is OT_OPPOSITE loopuse, we've hit face */
	/* if parent is edgeuse, do left/right computation */
d1031 1
a1031 1
		RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &myhit->l);
d1043 3
a1045 1
		/* ray misses halfspace, but intersected bounding box. */
d1052 1
a1052 1
		RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &myhit->l);
d1060 1
a1060 1
		rt_log("\tWarning:  Ignoring ray in plane of face\n");
d1064 1
a1064 1
		RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &myhit->l);
a1089 1
	
d1092 3
a1094 1
	/* check each loopuse in the faceuse to determine hit/miss */
d1098 1
d1178 3
a1180 4
struct ray_data *
nmg_isect_ray_model(rp, invdir, m, tol)
struct xray *rp;
vect_t invdir;
a1181 1
struct rt_tol	*tol;
a1185 1
	struct ray_data rd;
d1187 1
a1198 22
	rd.rp = rp;
	rd.tol = tol;
	VMOVE(rd.invdir, invdir);

	/* create a table to keep track of which elements have been
	 * processed before and which haven't.  Elements in this table
	 * will either be:
	 *		(NULL)		item not previously processed
	 *		hitmiss ptr	item previously processed
	 *
	 * the 0th item in the array is a pointer to the head of the "hit"
	 * list.  The 1th item in the array is a pointer to the head of the
	 * "miss" list.
	 */
	rd.hitmiss = (struct hitmiss **)rt_calloc( m->maxindex, sizeof(struct hitmiss *),
		"nmg geom hit list");

	/* initialize the lists of things that have been hit/missed */
	RT_LIST_INIT(&rd.nmg_hits);
	RT_LIST_INIT(&rd.nmg_misses);


d1207 2
a1208 2
		if (! rt_in_rpp(rd.rp, rd.invdir,
		    r_p->ra_p->min_pt, r_p->ra_p->max_pt) )
d1212 1
a1212 1
		for (RT_LIST_FOR(s_p, shell, &r_p->s_hd)) {
a1215 21

	/* free the list of missed elements */
	while (RT_LIST_WHILE(hm, hitmiss, &rd.hitmiss[NMG_MISS_LIST]->l)) {
		RT_LIST_DEQUEUE( &(hm->l) );
		rt_free((char *)hm, "missed hitmiss structure");
	}

	/* if there weren't any hit points then 
	 *   free the list head and return a NULL pointer
	 */
	hm = rd.hitmiss[NMG_HIT_LIST];
	if (RT_LIST_IS_EMPTY(&hm->l)) {
		if (rt_g.NMG_debug & DEBUG_NMGRT)
			rt_log("isect_ray_nmg: No elements in hitlist\n");

		rt_free((char *)rd.hitmiss[NMG_HIT_LIST],
			"free empty hit list");
		hm = (struct hitmiss *)NULL;
	}

	rt_free((char *)rd.hitmiss, "free nmg geom hit list");
@


1.2
log
@About to make radical change?
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_isect.c,v 1.1 1993/06/04 17:08:11 butler Exp butler $ (BRL)";
a109 12
/*
 *  Once it has been decided that the ray hits the vertex, this routine takes
 *  care of filling in the hitmiss structure and adding it to the list 
 *  of hit points.
 */
static struct hitmiss *
build_vertex_hit(rd, vu_p, myhit)
struct ray_data *rd;
struct vertexuse *vu_p;
struct hitmiss *myhit;
{
	vect_t v;
a110 86
	if (rt_g.NMG_debug & DEBUG_NMGRT)
		rt_log("build_vertex_hit\n");

	if (rd->plane_pt) {
		/* hitting a vertex in a face/plane.  Get the distance
		 * in the plane to the intersection point.
		 */
		if (myhit->dist_in_plane < 0.0) {
			VSUB2(v, rd->plane_pt, vu_p->v_p->vg_p->coord);
			myhit->dist_in_plane = MAGNITUDE(v);
		}


		/* build the hit structure */
		myhit->hit.hit_dist = rd->ray_dist_to_plane;
		VMOVE(myhit->hit.hit_point, vu_p->v_p->vg_p->coord);
		myhit->hit.hit_private = (genptr_t) vu_p->v_p;

		RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_MAGIC);
		hit_ins(rd, myhit);

		if (myhit->dist_in_plane < rd->plane_dist) {
			/* this is the closest element so far */
			if (rt_g.NMG_debug & DEBUG_NMGRT)
				rt_log("build_vertex_hit() found closer approach of %g\n", myhit->dist_in_plane);
			rd->plane_dist = myhit->dist_in_plane;
			rd->plane_closest = (long *)vu_p->v_p;
		}
		return myhit;
	}

	/* v = vector from ray point to hit vertex */
	VSUB2( v, rd->rp->r_pt, vu_p->v_p->vg_p->coord);
	myhit->hit.hit_dist = MAGNITUDE(v);	/* distance along ray */
	VMOVE(myhit->hit.hit_point, vu_p->v_p->vg_p->coord);
	myhit->hit.hit_private = (genptr_t) vu_p->v_p;

	RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_MAGIC);
	hit_ins(rd, myhit);

	return myhit;
}

static struct hitmiss *
build_vertex_miss(rd, vu_p, myhit)
struct ray_data *rd;
struct vertexuse *vu_p;
struct hitmiss *myhit;
{
	vect_t v;

	if (rt_g.NMG_debug & DEBUG_NMGRT)
		rt_log("build_vertex_miss()\n");

	/* build up the hit structures */
	if (rd->plane_pt) {
		if (myhit->dist_in_plane < 0.0) {
		    	VSUB2(v, rd->plane_pt, vu_p->v_p->vg_p->coord);
		    	myhit->dist_in_plane = MAGNITUDE(v);
		}

		if (myhit->dist_in_plane < rd->plane_dist) {
			/* this is the closest hit so far */
			rd->plane_dist = myhit->dist_in_plane;
			rd->plane_closest = (long *)vu_p->v_p;

			if (rt_g.NMG_debug & DEBUG_NMGRT) {
				rt_log("build_vertex_miss() found closer approach of %g\n", myhit->dist_in_plane);
				rt_log("\tvertex %g %g %g is new \"closest to plane_pt\"\n",
					vu_p->v_p->vg_p->coord[0],
					vu_p->v_p->vg_p->coord[1],
					vu_p->v_p->vg_p->coord[2]);
			}
		}
	} else {
		if (rt_g.NMG_debug & DEBUG_NMGRT)
			rt_log("\tno plane point\n");
	}

	/* add myhit to the list of misses */
	RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
	RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &myhit->l);

	return myhit;
}

d112 1
a112 2
 *  The ray missed this vertex.  Build the appropriate miss structure, and
 *  calculate the distance from the ray to the vertex if needed.
d132 12
a143 1
	if (myhit = NMG_INDEX_GET(rd->hitmiss, vu_p->v_p) ) {
d145 1
a145 1
			rt_log("ray_miss_vertex( vertex previously processed )\n");
d155 5
a159 1
	return (build_vertex_miss(rd, vu_p, myhit));
d165 2
a166 2
 *  The ray hits the vertex.  Whether you know it or not, it really did hit
 *  this vertex.
d174 1
d179 2
a180 2
	if (myhit = NMG_INDEX_GET(rd->hitmiss, vu_p->v_p) ) {
		if (RT_LIST_MAGIC_OK(&myhit->l, NMG_RT_HIT_MAGIC))
a181 1

d189 10
a198 2
	/* build up the hit structures */
	return (build_vertex_hit(rd, vu_p, myhit));
d210 2
a211 2
 *		pointer to struct hitlist associated with this vertex
 *
d213 1
a213 1
static struct hitmiss *
d220 1
d235 4
a238 5
	if (myhit = NMG_INDEX_GET(rd->hitmiss, vu_p->v_p) ) {
		/* we've previously processed this vertex */

		if (rt_g.NMG_debug & DEBUG_NMGRT)  {
			if (RT_LIST_MAGIC_OK(&myhit->l, NMG_RT_HIT_MAGIC))
d240 4
a243 1
			else if (RT_LIST_MAGIC_OK(&myhit->l, NMG_RT_MISS_MAGIC))
d245 1
a246 8
		if (rd->plane_pt && myhit->dist_in_plane < rd->plane_dist) {
			/* this is a closer hit than anything else so far */
			if (rt_g.NMG_debug & DEBUG_NMGRT)
				rt_log("isect_ray_vertexuse() found closer approach of %g\n", myhit->dist_in_plane);
			rd->plane_dist = myhit->dist_in_plane;
			rd->plane_closest = (long *)vu_p->v_p;
		}
		return(myhit); /* previously hit vertex */
d249 1
a249 2
	GET_HITMISS(myhit);
	NMG_INDEX_ASSIGN(rd->hitmiss, vu_p->v_p, myhit);
d251 2
a252 12
	if (rd->plane_pt) {
		/* we're intersecting a point in a face/plane */
	    	VSUB2(v, rd->plane_pt, vu_p->v_p->vg_p->coord);
	    	myhit->dist_in_plane = MAGNITUDE(v);
		if (myhit->dist_in_plane > rd->tol->dist ||
		    myhit->dist_in_plane < (0 - rd->tol->dist) ) {
			/* a hit on the vertex */
		    	build_vertex_hit(rd, vu_p, myhit);
		} else {
			/* a miss on the vertex */
			build_vertex_miss(rd, vu_p, myhit);
		}
d254 1
a254 11
		return(myhit);
	}

	/* we're intersecting a lone or wire vertex  */
	if (myhit->dist_in_plane < 0.0)
		myhit->dist_in_plane =
			rt_dist_line_point(rd->rp->r_pt, rd->rp->r_dir,
						vu_p->v_p->vg_p->coord);

	if (myhit->dist_in_plane > rd->tol->dist ||
	    myhit->dist_in_plane < (0-rd->tol->dist) ) {
d256 2
a257 3

	    	build_vertex_miss(rd, vu_p, myhit);
		return(myhit);
d260 2
a261 1
	/* ray hits vertex, build the appropriate hit structure. */
a262 5
	/* signal build_vertex_hit() to fill this in */
	myhit->dist_in_plane = -1.0; 

	build_vertex_hit(rd, vu_p, myhit);

d272 1
a272 1
	return(myhit);
d276 9
a284 3


static struct hitmiss *
a311 1

a313 8

	if (rd->plane_pt) {
		if (vhit1->dist_in_plane > vhit2->dist_in_plane)
			myhit->dist_in_plane = vhit2->dist_in_plane;
		else
			myhit->dist_in_plane = vhit1->dist_in_plane;
	}

d316 1
a316 1
	return(myhit);
d320 1
a320 1
 *  When a vertex at an end of an edge gets hit by the ray, this routine
d323 7
a329 7
static struct hitmiss *
hit_edge_vertex(rd, eu_p, vu_p)
struct ray_data *rd;
struct edgeuse *eu_p;
struct vertexuse *vu_p;
{
	struct hitmiss *vhit, *myhit;
a330 2
	if (rt_g.NMG_debug & DEBUG_NMGRT)
		rt_log("hit_edge_vertex\n");
a331 11
	vhit = ray_hit_vertex(rd, vu_p);

	GET_HITMISS(myhit);
	NMG_INDEX_ASSIGN(rd->hitmiss, eu_p->e_p, myhit);

	RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_SUB_MAGIC);
	RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &myhit->l);
	return(myhit);
}


d349 2
a350 1
	struct hitmiss *myhit, *vhit1, *vhit2;
d361 1
a361 1
		rt_log("isect_ray_edgeuse (%g %g %g) -> (%g %g %g)\n",
a367 5
		rt_log("\tplane_pt (%g %g %g) plane_dist %g\n", 
			rd->plane_pt[0],
			rd->plane_pt[1],
			rd->plane_pt[2],
			rd->plane_dist); 
d370 4
a373 4
	if ( myhit = NMG_INDEX_GET(rd->hitmiss, eu_p->e_p) ) {
		/* previously processed vertex or edge */
		if (rt_g.NMG_debug & DEBUG_NMGRT)
			if (RT_LIST_MAGIC_OK(&myhit->l, NMG_RT_HIT_MAGIC) )
d375 7
a381 1
			else
d383 4
a386 1
		return;
d411 3
a413 1
		/* create hit structure for this edge */
d417 1
a417 11
		vhit1 = isect_ray_vertexuse(rd->rp, eu_p->vu_p);
		vhit2 = isect_ray_vertexuse(rd->rp, eu_p->eumate_p->vu_p);
		if (rd->plane_pt) {
			if (vhit1->dist_in_plane < vhit2->dist_in_plane)
				myhit->dist_in_plane = vhit1->dist_in_plane;
			else
				myhit->dist_in_plane = vhit2->dist_in_plane;
		}

		if (RT_LIST_MAGIC_OK(&vhit1->l, NMG_RT_HIT_MAGIC) ||
		    RT_LIST_MAGIC_OK(&vhit2->l, NMG_RT_HIT_MAGIC) ) {
d447 1
a447 1
	case -1 :
d462 1
a462 1
		myhit = colinear_edge_ray(rd, eu_p);
d465 1
a465 1
		myhit = hit_edge_vertex(rd, eu_p, eu_p->vu_p);
d468 1
a468 1
		myhit = hit_edge_vertex(rd, eu_p, eu_p->eumate_p->vu_p);
d474 3
d499 5
d505 1
a505 1
dist_vu_plane_pt(rd, vu_p)
d525 1
d540 2
a541 1
		rt_log("dist_plane_pt_eu((%g %g %g), 0x%08x(%g %g %g -> %g %g %g)\n",
d552 11
a562 1
		rt_log("\tplane_dist = %g\n", rd->plane_dist);
d567 1
d575 14
a588 9
		  store edgeuse ptr in plane_closest, set plane_dist = 0.0 */
		if (dist < rd->plane_dist) {
			rd->plane_dist = 0.0;
			rd->plane_closest = &eu_p->l.magic;
			if (rt_g.NMG_debug & DEBUG_NMGRT)
				rt_log("\teu is new \"closest to plane_pt\" (new dist: %g)\n",
					dist);
		}
		/* make sure we have a hit on this edge */
d596 1
d598 6
a603 1
				rt_log("\tvu of eu is new \"closest to plane_pt\" (new dist %g)\n", dist);
d605 1
a605 1
		/* make sure we have a hit on the vertex */
d614 1
d616 6
a621 1
				rt_log("\tvu of next(eu) is new \"closest to plane_pt\" (new dist %g)\n", dist);
d623 1
a623 1
		/* make sure we have a hit on the vertex */
d629 1
d631 4
a634 1
				rt_log("\tvu of eu is new \"closest to plane_pt\" (new dist %g)\n", dist);
d642 1
d644 4
a647 1
				rt_log("\tvu of next(eu) is new \"closest to plane_pt\" (new dist %g)\n", dist);
d650 4
a653 2
	case 5: /* if edge is closer to plane_pt than any previous item,
		   store edgeuse ptr in plane_closest and set plane_dist */
d657 1
d659 4
a662 1
				rt_log("\teu is new \"closest to plane_pt\" (new dist %g)\n", dist);
d665 3
d691 3
d695 4
d718 1
a718 1
		dist_vu_plane_pt(rd,
d723 8
d751 13
a763 2
	hit = NMG_INDEX_GET(rd->hitmiss, eu->e_p);
	if (RT_LIST_MAGIC_OK(&hit->l, NMG_RT_HIT_MAGIC)) return;
a764 1

d793 77
d933 8
a940 2
	hit = NMG_INDEX_GET(rd->hitmiss, vu->v_p);
	if (RT_LIST_MAGIC_OK(&hit->l, NMG_RT_HIT_MAGIC)) return;
d987 13
a999 3
	if (myhit = NMG_INDEX_GET(rd->hitmiss, fu_p->f_p) ) {
		if (rt_g.NMG_debug & DEBUG_NMGRT)
			rt_log(" previously processed \n");
d1153 1
a1153 1
struct hitmiss *
d1176 4
d1193 3
a1195 3
	/* allocate the head of the linked lists for hit and miss lists */
	hm = (struct hitmiss *)rt_calloc(2, sizeof(struct hitmiss),
		"hitlist calloc isect ray nmg");
a1196 2
	RT_LIST_INIT(&(hm->l));
	rd.hitmiss[NMG_HIT_LIST] = hm++;
d1198 2
a1199 9
	RT_LIST_INIT(&(hm->l));
	rd.hitmiss[NMG_MISS_LIST] = hm;
	VMOVE(rd.invdir, invdir);
	rd.tol = tol;

	rd.rp = rp;

	/* ray intersects model, check ray for intersecion with rpp's of
	 * nmgregion's
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt.c,v 10.9 1993/05/20 21:07:13 butler Exp butler $ (BRL)";
d24 1
d26 1
a26 2
#include "nmg.h"
#include "nmg_rt.h"
d59 3
a61 2
hit_ins(hl, newhit)
struct hitmiss *newhit, *hl;
d64 5
a68 1
	for (RT_LIST_FOR(a_hit, hitmiss, &hl->l)) {
d71 7
d79 2
a80 1
	/* a_hit now points to the item which should go AFTER the new
d84 22
d122 4
d142 1
a142 1
		hit_ins(rd->hitmiss, myhit);
d145 3
a147 1
			/* this is the closest hit so far */
d149 1
a149 1
			rd->plane_closest = (long *)vu_p;
d161 1
a161 1
	hit_ins(rd->hitmiss, myhit);
d174 3
d187 9
a195 1
			rd->plane_closest = (long *)vu_p;
d197 3
d220 3
a222 1
	if (myhit = NMG_INDEX_GET(rd->hitmiss, vu_p->v_p) ) return(myhit);
d224 13
d259 3
a277 1

d280 5
d297 3
d321 2
d324 1
a324 1
			rd->plane_closest = (long *)vu_p;
a381 12
/*
 *  The ray misses the edge segment, but hits the infinite line of the edge
 *  to one end of the edge segment.  This is an exercise in tabulating the
 *  nature of the miss.
 */
static struct hitmiss *
miss_edge_beyond_vertex(rd, eu_p)
struct ray_data *rd;
struct edgeuse *eu_p;
{
	struct hitmiss *myhit;
	/* record the fact that we missed each vertex */
a382 2
	(void)ray_miss_vertex(rd, eu_p->vu_p);
	(void)ray_miss_vertex(rd, eu_p->eumate_p->vu_p);
a383 23
	/* record the fact that we missed the edge */
	if (myhit = NMG_INDEX_GET(rd->hitmiss, eu_p->e_p) ) return(myhit);
		
	GET_HITMISS(myhit);
	NMG_INDEX_ASSIGN(rd->hitmiss, eu_p->e_p, myhit);

	if (rd->plane_pt) {
		struct hitmiss *vhit1, *vhit2;

		vhit1 = NMG_INDEX_GET(rd->hitmiss, eu_p->vu_p->v_p);
		vhit2 = NMG_INDEX_GET(rd->hitmiss, eu_p->eumate_p->vu_p->v_p);

		if (vhit1->dist_in_plane > vhit2->dist_in_plane)
			myhit->dist_in_plane = vhit2->dist_in_plane;
		else
			myhit->dist_in_plane = vhit1->dist_in_plane;
	}

	RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
	RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &myhit->l);
	return(myhit);
}

a384 59
just_plain_miss_edge(rd, eu_p)
struct ray_data *rd;
struct edgeuse *eu_p;
{
	struct hitmiss *myhit;
	struct hitmiss *vhit1;
	int status;
	point_t pca;

	ray_miss_vertex(rd, eu_p->vu_p);
	ray_miss_vertex(rd, eu_p->eumate_p->vu_p);

	GET_HITMISS(myhit);
	NMG_INDEX_ASSIGN(rd->hitmiss, eu_p->e_p, myhit);

	/* no intersection
	 *
	 * This is a miss condition.  If we are processing a plane
	 * edge we need to compute the distance to the plane
	 * intersection point in case this is the closest edge to that
	 * point.
	 */
	if (rd->plane_pt) {
		/* compute distance to point of closest approach
		 * for ray/lseg.  Used by the faceuse intersection.
		 */
		status = rt_dist_pt3_lseg3( &myhit->dist_in_plane,
			pca, eu_p->vu_p->v_p->vg_p->coord,
			eu_p->eumate_p->vu_p->v_p->vg_p->coord,
			rd->plane_pt, rd->tol);

		switch (status) {
		case 3 :
			vhit1 = NMG_INDEX_GET(rd->hitmiss,eu_p->vu_p->v_p);
			myhit->dist_in_plane = vhit1->dist_in_plane;
			break;
		case 4 : 
			vhit1 = NMG_INDEX_GET(rd->hitmiss,
				eu_p->eumate_p->vu_p->v_p);
			myhit->dist_in_plane = vhit1->dist_in_plane;
			break;
		case 5 :
			if (myhit->dist_in_plane < rd->plane_dist) {
				rd->plane_dist = myhit->dist_in_plane;
				rd->plane_closest = (long *)eu_p;
			}
			break;
		default :
			rt_log("%s %d rt_dist_pt3_lseg3() disagrees with rt_isect_line_lseg()\n",
				__FILE__, __LINE__);
			rt_bomb("Why can't we all agree?\n");
		}
	}
	RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_MISS_MAGIC);
	RT_LIST_INSERT(&rd->hitmiss[NMG_MISS_LIST]->l, &myhit->l);
	return(myhit);
}

static struct hitmiss *
d391 3
d440 3
d456 7
a462 1
 *	Return:
d464 1
a464 1
static struct hitmiss *
d471 1
a471 1
	struct hitmiss *myhit, *vhit1;
a472 3
	if (rt_g.NMG_debug & DEBUG_NMGRT)
		rt_log("isect_ray_edgeuse\n");

d481 15
d497 1
a497 1
		/* previously hit vertex or edge */
d500 1
a500 1
				rt_log("edge previously hit\n");
d502 3
a504 1
				rt_log("edge previously missed\n");
a505 2
		/* XXX calculate distance to intersect point in *THIS* plane.
		 */
a506 9
		/* if the plane distance is less, make a note of that */
		if (rd->plane_pt && myhit->dist_in_plane < rd->plane_dist) {
			/* this is a closer hit than anything else so far */
			rd->plane_dist = myhit->dist_in_plane;
			rd->plane_closest = (long *)eu_p;
		}
		return(myhit);
	}

d520 3
a522 3
		 * Note.  There is no need to see if this edge was the
		 * closest item to the hit point in the face.  That will
		 * be handled by the vertex in this case.
d525 3
d533 1
d535 4
a538 1
			myhit->dist_in_plane = vhit1->dist_in_plane;
d541 2
a542 1
		if (RT_LIST_MAGIC_OK(&vhit1->l, NMG_RT_HIT_MAGIC)) {
a543 5
			/* XXX Have we necessarily hit the second vertex?
			 * it might be outside of tolerance of the ray
			 */
			ray_hit_vertex(rd, eu_p->eumate_p->vu_p);

d546 1
a546 6
			/* vertex was missed, so edge is missed */
			/* XXX should we intersect the ray with the other
			 * vertex here?  They were within tolearance, but
			 * the second one may be within tolerance of the
			 * ray too.
			 */
d551 1
a551 3
	case -3 :
		myhit = miss_edge_beyond_vertex(rd, eu_p);
		break;
d553 18
a570 1
		myhit = miss_edge_beyond_vertex(rd, eu_p);
d573 12
a584 1
		myhit = just_plain_miss_edge(rd, eu_p);
d596 3
d603 4
a606 2
		/* XXX calculate the actual distance from the ray to the edge
		 * instead of just using 0.0?
d616 1
a616 2
		RT_LIST_MAGIC_SET(&myhit->l, NMG_RT_HIT_MAGIC);
		RT_LIST_INSERT(&rd->hitmiss[NMG_HIT_LIST]->l, &myhit->l);
a618 1
	return(myhit);
d621 120
d752 1
a752 1
		rt_log("isect_ray_loopuse\n");
d759 9
a767 2
		for (RT_LIST_FOR(eu_p, edgeuse, &lu_p->down_hd)) {
			isect_ray_edgeuse(rd, eu_p);
d780 3
d796 1
d798 8
a805 1
	NMG_CK_EDGUSE(eu);
d809 11
d823 1
a823 1
	eu_p = eu->eumate_p;
d825 4
d832 1
d841 44
d898 3
d917 3
d940 3
d950 2
a955 2
	if (rt_g.NMG_debug & DEBUG_NMGRT) rt_log("isect_ray_faceuse\n");

d963 2
d968 1
a968 8
	/* XXX if ray is in plane of face, should perform 2D intersection?
	 *
	 *	-- *------------* ---->
	 *	   |		|
	 *	   |		|
	 *
	 *  Should ray hit such a face?  Should it be required to hit edges?
	 */
d975 3
d989 1
a989 1
		rt_log("Warning:  Ignoring ray in plane of face\n");
d1002 1
d1005 17
a1025 3
	rd->plane_pt = (pointp_t)NULL;


d1044 1
a1044 1
		rt_bomb("Hello.  My $name is Indigo Montoya.  You killed my process.  Prepare to vi!\n");
d1046 2
d1066 1
a1066 1
		rt_log("nmg_isect_ray_shell\n");
d1076 4
a1079 1
	    s_p->sa_p->min_pt, s_p->sa_p->max_pt) )
d1081 1
d1096 3
d1105 1
a1105 1
static struct hitmiss *
d1110 1
a1110 1
CONST struct rt_tol	*tol;
d1152 2
@
