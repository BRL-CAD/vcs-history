head	11.42;
access;
symbols
	ansi-20040405-merged:11.36.2.3
	postmerge-20040405-ansi:11.39
	premerge-20040404-ansi:11.38
	postmerge-autoconf:11.38
	autoconf-freeze:11.36.10.2
	premerge-autoconf:11.38
	ansi-20040316-freeze:11.36.2.1
	postmerge-20040315-windows:11.38
	premerge-20040315-windows:11.37
	windows-20040315-freeze:11.36.4.2
	autoconf-20031203:11.36
	autoconf-20031202:11.36
	autoconf-branch:11.36.0.10
	phong-branch:11.36.0.8
	photonmap-branch:11.36.0.6
	rel-6-1-DP:11.36
	windows-branch:11.36.0.4
	rel-6-0-2:11.34
	ansi-branch:11.36.0.2
	rel-6-0-1-branch:11.34.0.2
	hartley-6-0-post:11.35
	hartley-6-0-pre:11.34
	rel-6-0-1:11.34
	rel-6-0:11.34
	rel-5-4:11.30
	offsite-5-3-pre:11.32
	rel-5-3:11.30
	rel-5-2:11.30
	rel-5-1-branch:11.30.0.2
	rel-5-1:11.30
	rel-5-0:11.29
	rel-5-0-beta:11.28
	rel-4-5:11.28
	ctj-4-5-post:11.28
	ctj-4-5-pre:11.28
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.42
date	2004.05.21.18.07.33;	author morrison;	state dead;
branches;
next	11.41;

11.41
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.40;

11.40
date	2004.04.05.12.27.54;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2004.03.16.20.03.10;	author morrison;	state Exp;
branches;
next	11.37;

11.37
date	2004.02.02.17.39.25;	author morrison;	state Exp;
branches;
next	11.36;

11.36
date	2002.08.20.17.08.06;	author jra;	state Exp;
branches
	11.36.2.1
	11.36.4.1
	11.36.10.1;
next	11.35;

11.35
date	2002.08.15.20.55.18;	author hartley;	state Exp;
branches;
next	11.34;

11.34
date	2001.05.17.20.05.25;	author morrison;	state Exp;
branches;
next	11.33;

11.33
date	2001.04.20.22.29.52;	author morrison;	state Exp;
branches;
next	11.32;

11.32
date	2000.08.23.00.35.53;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	2000.08.21.02.02.33;	author butler;	state Exp;
branches;
next	11.30;

11.30
date	99.12.30.15.56.54;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	99.06.03.01.39.15;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	97.01.30.20.00.12;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	97.01.14.13.21.29;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	97.01.13.15.02.56;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	97.01.09.16.15.46;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	96.07.12.12.17.41;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	96.04.22.12.22.06;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	96.03.28.14.30.18;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	96.03.25.20.46.24;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	96.03.18.00.06.51;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	96.03.05.21.39.59;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	95.06.17.06.09.31;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	95.06.17.05.23.00;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	95.05.11.19.11.12;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	95.05.05.20.58.58;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	95.05.01.20.46.06;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	95.03.31.19.48.25;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	95.03.03.23.48.50;	author butler;	state Exp;
branches;
next	11.10;

11.10
date	95.02.28.00.01.16;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	95.02.27.23.37.39;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	95.02.27.22.46.46;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.02.27.22.33.47;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.02.24.07.25.44;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	95.02.21.10.23.05;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	95.02.21.06.24.04;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	95.02.21.00.55.06;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.02.18.00.11.00;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.11;	author mike;	state Rel4_4;
branches;
next	1.15;

1.15
date	94.12.30.11.05.32;	author stay;	state Exp;
branches;
next	1.14;

1.14
date	94.12.27.18.20.38;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	94.12.20.15.51.06;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	94.12.05.12.25.35;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	94.12.05.11.16.24;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	94.11.15.00.24.52;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	94.10.11.19.49.16;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	94.09.02.00.32.44;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	94.09.01.23.34.36;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	94.08.09.19.38.28;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	94.06.28.10.58.57;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	94.06.22.03.08.11;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	94.06.06.22.13.31;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	94.05.24.12.59.00;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	94.05.17.23.03.30;	author butler;	state Exp;
branches;
next	;

11.36.2.1
date	2002.09.19.18.01.41;	author morrison;	state Exp;
branches;
next	11.36.2.2;

11.36.2.2
date	2004.03.17.21.18.54;	author morrison;	state Exp;
branches;
next	11.36.2.3;

11.36.2.3
date	2004.04.01.04.18.58;	author morrison;	state Exp;
branches;
next	;

11.36.4.1
date	2002.09.26.23.04.03;	author morrison;	state Exp;
branches;
next	11.36.4.2;

11.36.4.2
date	2004.03.11.23.43.43;	author morrison;	state Exp;
branches;
next	;

11.36.10.1
date	2004.02.12.18.37.45;	author erikg;	state Exp;
branches;
next	11.36.10.2;

11.36.10.2
date	2004.03.18.18.10.29;	author erikg;	state Exp;
branches;
next	;


desc
@classify pt wrt faceuse
@


11.42
log
@moved to src/
@
text
@/*
 *			N M G _ P T _ F U . C
 *
 *  Routines for classifying a point with respect to a faceuse.
 *
 *  Author -
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "plot3.h"

/* vertex/edge distance 
 * Each loop geometry element (edge/vertex) has one of these computed.
 * We keep track of them for the whole face so that this value is computed
 * only once per geometry element.  This way we get consistent answers
 */
struct ve_dist {
	struct bu_list	l;
	long		*magic_p;/* pointer to edge/vertex structure */
	double		dist;	/* distance squared from point to edge */
	struct vertex	*v1;
	struct vertex	*v2;
	int		status;	/* return code from bn_dist_pt3_lseg3 */
};
#define NMG_VE_DIST_MAGIC	0x102938
#define NMG_CK_VED(_p)	NMG_CKMAG(_p, NMG_VE_DIST_MAGIC, "vertex/edge_dist")

/* The loop builds a list of these things so that it can figure out the point
 * classification based upon the classification of the pt vs each edge of
 * the loop.  This list is sorted in ascending "ved_p->dist" order.
 */
struct edge_info {
	struct bu_list		l;
	struct ve_dist 		*ved_p;	  /* ptr to ve_dist for this item */
	struct edgeuse		*eu_p;	  /* edgeuse pointer */
	int			class;	  /* pt classification WRT this item use */
};
#define NMG_EDGE_INFO_MAGIC 0xe100
#define NMG_CK_EI(_p)	NMG_CKMAG(_p, NMG_EDGE_INFO_MAGIC, "edge_info")

struct fpi {
	long			magic;
	const struct bn_tol	*tol;
	const struct faceuse	*fu_p;
	struct bu_list	ve_dh;		/* ve_dist list head */
	plane_t		norm;		/* surface normal for face(use) */
	point_t		pt;		/* pt in plane of face to classify */
	void		(*eu_func)();	/* call w/eu when pt on edgeuse */
	void		(*vu_func)();	/* call w/vu when pt on vertexuse */
	const char	*priv;		/* caller's private data */
	int		hits;		/* flag PERUSE/PERGEOM */
};
#define NMG_FPI_MAGIC 12345678 /* fpi\0 */
#define NMG_CK_FPI(_fpi) \
	NMG_CKMAG(_fpi, NMG_FPI_MAGIC, "fu_pt_info") ; \
	BN_CK_TOL( _fpi->tol ); \
	BU_CK_LIST_HEAD(&_fpi->ve_dh)

#define NMG_FPI_TOUCHED	27
#define NMG_FPI_MISSED  32768

#ifdef USE_PROTOTYPES
static int	nmg_class_pt_vu(struct fpi *fpi, struct vertexuse *vu);

static struct edge_info *nmg_class_pt_eu(struct fpi *fpi, struct edgeuse *eu, struct edge_info *edge_list, const int in_or_out_only);
static int	compute_loop_class(struct fpi *fpi, const struct loopuse *lu,struct edge_info *edge_list);
static int	nmg_class_pt_lu(struct loopuse *lu, struct fpi *fpi, const int in_or_out_only);
int		nmg_class_pt_fu_except(const point_t pt, const struct faceuse *fu, const struct loopuse *ignore_lu, void (*eu_func)(), void (*vu_func)(), const char *priv, const int call_on_hits, const int in_or_out_only, const struct bn_tol *tol);
#endif

/*
 *			B N _ D I S T S Q _ P T 3 _ L S E G 3 _ J R A
 *
 *  Find the square of the distance from a point P to a line segment described
 *  by the two endpoints A and B.
 *
 *			P
 *		       *
 *		      /.
 *		     / .
 *		    /  .
 *		   /   . (dist)
 *		  /    .
 *		 /     .
 *		*------*--------*
 *		A      PCA	B
 *
 *  There are six distinct cases, with these return codes -
 *	0	P is within tolerance of lseg AB.  *dist =  0.
 *	1	P is within tolerance of point A.  *dist = 0.
 *	2	P is within tolerance of point B.  *dist = 0.
 *	3	PCA is within tolerance of A. *dist = |P-A|**2.
 *	4	PCA is within tolerance of B. *dist = |P-B|**2.
 *	5	P is "above/below" lseg AB.  *dist=|PCA-P|**2.
 *
 * This routine was formerly called bn_dist_pt_lseg().
 * This is a special version that returns the square of the distance
 * and does not actually calculate PCA.
 *
 */
int
bn_distsq_pt3_lseg3(fastf_t *dist, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
{
	vect_t	PtoA;		/* P-A */
	vect_t	PtoB;		/* P-B */
	vect_t	AtoB;		/* B-A */
	fastf_t	P_A_sq;		/* |P-A|**2 */
	fastf_t	P_B_sq;		/* |P-B|**2 */
	fastf_t B_A_sq;		/* |B-A|**2 */
	fastf_t	t;		/* distance squared along ray of projection of P */
	fastf_t	dot;

	BN_CK_TOL(tol);
#if 0
	if( RT_G_DEBUG & DEBUG_MATH )   {
		bu_log("bn_distsq_pt3_lseg3() a=(%g,%g,%g) b=(%g,%g,%g)\n\tp=(%g,%g,%g), tol->dist=%g sq=%g\n",
			V3ARGS(a),
			V3ARGS(b),
			V3ARGS(p),
			tol->dist, tol->dist_sq );
	}
#endif

	/* Check proximity to endpoint A */
	VSUB2(PtoA, p, a);
	if( (P_A_sq = MAGSQ(PtoA)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around A */
		*dist = 0.0;
		return 1;
	}

	/* Check proximity to endpoint B */
	VSUB2(PtoB, p, b);
	if( (P_B_sq = MAGSQ(PtoB)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around B */
		*dist = 0.0;
		return 2;
	}

	VSUB2(AtoB, b, a);
	B_A_sq = MAGSQ(AtoB);

	/* compute distance squared (in actual units) along line to PROJECTION of
	 * point p onto the line: point pca
	 */
	dot = VDOT(PtoA, AtoB);
	t = dot * dot / B_A_sq;

	if( dot < 0.0 && t > tol->dist_sq )  {
		/* P is "left" of A */
		*dist = P_A_sq;
		return 3;
	}
	if( t < B_A_sq - tol->dist_sq )  {
		/* PCA falls between A and B */
		register fastf_t	dsq;

		/* Find distance from PCA to line segment (Pythagorus) */
		if( (dsq = P_A_sq - t ) <= tol->dist_sq )  {
			/* PCA is on lseg */
			*dist = 0.0;
			return 0;
		}

		/* P is above or below lseg */
		*dist = dsq;
		return 5;
	}

	/* P is "right" of B */
	*dist = P_B_sq;
	return 4;
}


/*
 *	N M G _ C L A S S _ P T _ V U 
 *
 *	Classify a point vs a vertex (touching/missed)
 */
static int
nmg_class_pt_vu(struct fpi *fpi, struct vertexuse *vu)
{
	vect_t delta;
	struct ve_dist	*ved;

	NMG_CK_VERTEXUSE(vu);

	/* see if we've classified this vertex WRT the point already */
	for (BU_LIST_FOR(ved, ve_dist, &fpi->ve_dh)){
		NMG_CK_VED(ved);
		if (ved->magic_p == &vu->v_p->magic) {
			goto found;
		}
	}

	/* if we get here, we didn't find the vertex in the list of
	 * previously classified geometry.  Create an entry in the
	 * face's list of processed geometry.
	 */
	VSUB2(delta, vu->v_p->vg_p->coord, fpi->pt);

	ved = (struct ve_dist *) bu_malloc(sizeof(struct ve_dist), "ve_dist structure");
	ved->magic_p = &vu->v_p->magic;
	ved->dist = MAGNITUDE(delta);
	if (ved->dist < fpi->tol->dist_sq ) {
		ved->status = NMG_FPI_TOUCHED;
		if (fpi->hits == NMG_FPI_PERGEOM)
			fpi->vu_func(vu, fpi->pt, fpi->priv);
	}
	else ved->status = NMG_FPI_MISSED;

	ved->v1 = ved->v2 = vu->v_p;

	BU_LIST_MAGIC_SET(&ved->l, NMG_VE_DIST_MAGIC);
	BU_LIST_APPEND(&fpi->ve_dh, &ved->l);
found:

	if (fpi->vu_func  &&
	    ved->status == NMG_FPI_TOUCHED &&
	    fpi->hits == NMG_FPI_PERUSE)
		fpi->vu_func(vu, fpi->pt, fpi->priv);

	return ved->status;
}

#if 0
static void
pl_pt_e(fpi, ei)
struct fpi *fpi;
struct edge_info *ei;
{
	FILE *fd;
	char name[25];
	long *b;
	point_t pca;
	fastf_t dist;
	static int plot_file_number=0;
	struct bn_tol tmp_tol;

	NMG_CK_FPI(fpi);	
	NMG_CK_FACEUSE(fpi->fu_p);
	NMG_CK_EI(ei);
	
	sprintf(name, "pt_e%02d.pl", plot_file_number++);
	if ((fd=fopen(name, "w")) == (FILE *)NULL) {
		perror(name);
		abort();
	}

	bu_log("\toverlay %s\n", name);
	b = (long *)bu_calloc( fpi->fu_p->s_p->r_p->m_p->maxindex,
		sizeof(long), "bit vec"),

	pl_erase(fd);
	pd_3space(fd,
		fpi->fu_p->f_p->min_pt[0]-1.0,
		fpi->fu_p->f_p->min_pt[1]-1.0,
		fpi->fu_p->f_p->min_pt[2]-1.0,
		fpi->fu_p->f_p->max_pt[0]+1.0,
		fpi->fu_p->f_p->max_pt[1]+1.0,
		fpi->fu_p->f_p->max_pt[2]+1.0);
	
	nmg_pl_eu(fd, ei->eu_p, b, 255, 255, 255);

        tmp_tol.magic = BN_TOL_MAGIC;
        tmp_tol.dist = 0.005;
        tmp_tol.dist_sq = tmp_tol.dist * tmp_tol.dist;
        tmp_tol.perp = 1e-6;
        tmp_tol.para = 1 - tmp_tol.perp;

	(void)bn_dist_pt3_lseg3( &dist, pca, ei->eu_p->vu_p->v_p->vg_p->coord,
		ei->eu_p->eumate_p->vu_p->v_p->vg_p->coord, fpi->pt, &tmp_tol );
	pl_color(fd, 255, 255, 50);
	pdv_3line(fd, pca, fpi->pt);

	bu_free((char *)b, "bit vec");
	fclose(fd);
}
#endif
static int
Quadrant(fastf_t x, fastf_t y)
{
	if( x >= 0.0 )
	{
		if( y >= 0.0 )
			return( 1 );
		else
			return( 4 );
	}
	else
	{
		if( y >= 0.0 )
			return( 2 );
		else
			return( 3 );
	}
}

int
nmg_eu_is_part_of_crack(const struct edgeuse *eu)
{
	struct loopuse *lu;
	struct edgeuse *eu_test;

	NMG_CK_EDGEUSE( eu );

	/* must be part of a loop to be a crack */
	if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )
		return( 0 );

	lu = eu->up.lu_p;
	NMG_CK_LOOPUSE( lu );

	for( BU_LIST_FOR( eu_test, edgeuse, &lu->down_hd ) )
	{
		if( eu_test == eu )
			continue;

		if( eu_test->vu_p->v_p == eu->eumate_p->vu_p->v_p &&
		    eu_test->eumate_p->vu_p->v_p == eu->vu_p->v_p )
				return( 1 );
	}

	return( 0 );
}

/*		N M G _ C L A S S _ P T _ E U V U
 *
 *	Classify a point with respect to an EU where the VU is the
 *	closest to the point. The EU and its left vector form an XY
 *	coordinate system in the face, with EU along the X-axis and
 *	its left vector along the Y-axis. Use these to decompose the
 *	direction of the prev_eu into X and Y coordinates (xo,yo) then
 *	do the same for the vector to the point to be classed (xpt,ypt).
 *	If (xpt,ypt) makes a smaller angle with EU than does (xo,yo),
 *	then PT is in the face, otherwise it is out.
 *
 *
 *	It is assumed that eu is from an OT_SAME faceuse, and that
 *	the PCA of PT to EU is at eu->vu_p.
 */

int
nmg_class_pt_euvu(const fastf_t *pt, struct edgeuse *eu_in, const struct bn_tol *tol)
{
	struct loopuse *lu;
	struct edgeuse *prev_eu;
	struct edgeuse *eu;
	struct vertex *v0,*v1,*v2;
	vect_t left;
	vect_t eu_dir;
	vect_t other_eudir;
	vect_t pt_dir;
	fastf_t xo,yo;
	fastf_t xpt,ypt;
	fastf_t len;
	int quado,quadpt;
	int class = NMG_CLASS_Unknown;
	int eu_is_crack=0;
	int prev_eu_is_crack=0;

	NMG_CK_EDGEUSE( eu_in );
	BN_CK_TOL( tol );

	eu = eu_in;

	if(rt_g.NMG_debug & DEBUG_PT_FU )
		bu_log( "nmg_class_pt_euvu( (%g %g %g), eu=x%x )\n", V3ARGS( pt ), eu );

	if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )
	{
		bu_log( "nmg_class_pt_euvu() called with eu (x%x) that isn't part of a loop\n", eu );
		rt_bomb( "nmg_class_pt_euvu() called with eu that isn't part of a loop" );
	}
	lu = eu->up.lu_p;
	NMG_CK_LOOPUSE( lu );

	eu_is_crack = nmg_eu_is_part_of_crack( eu );

	prev_eu = BU_LIST_PPREV_CIRC( edgeuse, &eu->l );

	prev_eu_is_crack = nmg_eu_is_part_of_crack( prev_eu );

	/* if both EU's are cracks, we cannot classify */
	if( eu_is_crack && prev_eu_is_crack )
		return( NMG_CLASS_Unknown );

	if( eu_is_crack )
	{
		struct edgeuse *eu_test;
		int done=0;

		if(rt_g.NMG_debug & DEBUG_PT_FU )
			bu_log( "nmg_class_pt_euvu: eu x%x is a crack\n", eu );

		/* find next eu from this vertex that is not a crack */
		eu_test = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
		while( !done )
		{
			while( eu_test->vu_p->v_p != eu->vu_p->v_p && eu_test != eu )
				eu_test = BU_LIST_PNEXT_CIRC( edgeuse, &eu_test->l );

			if( eu_test == eu )
				done = 1;

			if( !nmg_eu_is_part_of_crack( eu_test ) )
				done = 1;

			if( !done )
				eu_test = BU_LIST_PNEXT_CIRC( edgeuse, &eu_test->l );
		}

		if( eu_test == eu ) /* can't get away from crack */
			return( NMG_CLASS_Unknown );
		else
			eu = eu_test;

		if(rt_g.NMG_debug & DEBUG_PT_FU )
			bu_log( "\tUsing eu x%x instead\n", eu );
	}

	if( prev_eu_is_crack )
	{
		struct edgeuse *eu_test;
		int done=0;

		if(rt_g.NMG_debug & DEBUG_PT_FU )
			bu_log( "nmg_class_pt_euvu: prev_eu (x%x) is a crack\n" );

		/* find previous eu ending at this vertex that is not a crack */
		eu_test = BU_LIST_PPREV_CIRC( edgeuse, &prev_eu->l );
		while( !done )
		{
			while( eu_test->eumate_p->vu_p->v_p != eu->vu_p->v_p && eu_test != prev_eu )
				eu_test = BU_LIST_PPREV_CIRC( edgeuse, &eu_test->l );

			if( eu_test == prev_eu )
				done = 1;

			if( !nmg_eu_is_part_of_crack( eu_test ) )
				done = 1;

			if( !done )
				eu_test = BU_LIST_PPREV_CIRC( edgeuse, &eu_test->l );
		}

		if( eu_test == prev_eu ) /* can't get away from crack */
			return( NMG_CLASS_Unknown );
		else
			prev_eu = eu_test;

		if(rt_g.NMG_debug & DEBUG_PT_FU )
			bu_log( "\tUsing prev_eu x%x instead\n", prev_eu );
	}

	/* left is the Y-axis of our XY-coordinate system */
	if( nmg_find_eu_leftvec( left,  eu ) )
	{
		bu_log( "nmg_class_pt_euvu: nmg_find_eu_leftvec() for eu=x%x failed!\n",eu );
		rt_bomb( "nmg_class_pt_euvu: nmg_find_eu_leftvec() failed!" );
	}

	if(rt_g.NMG_debug & DEBUG_PT_FU )
		bu_log( "\tprev_eu = x%x, left = (%g %g %g)\n", prev_eu, V3ARGS( left ) );

	/* v0 is the origin of the XY-coordinat system */
	v0 = eu->vu_p->v_p;
	NMG_CK_VERTEX( v0 );

	/* v1 is on the X-axis */
	v1 = eu->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX( v1 );

	/* v2 determines angle prev_eu makes with X-axis */
	v2 = prev_eu->vu_p->v_p;
	NMG_CK_VERTEX( v2 );

	if(rt_g.NMG_debug & DEBUG_PT_FU )
		bu_log( "\tv0=x%x, v1=x%x, v2=x%x\n", v0, v1, v2 );

	/*  eu_dir is our X-direction */
	VSUB2( eu_dir, v1->vg_p->coord, v0->vg_p->coord );

	/* other_eudir is direction along the previous EU (from origin) */
	VSUB2( other_eudir, v2->vg_p->coord, v0->vg_p->coord );

	if(rt_g.NMG_debug & DEBUG_PT_FU )
		bu_log( "\teu_dir=(%g %g %g), other_eudir=(%x %x %x)\n",V3ARGS( eu_dir ), V3ARGS( other_eudir ) );

	/* get X and Y components for other_eu */
	xo = VDOT( eu_dir, other_eudir );
	yo = VDOT( left, other_eudir );

	/* which quadrant does this XY point lie in */
	quado = Quadrant( xo, yo );

	if(rt_g.NMG_debug & DEBUG_PT_FU )
		bu_log( "\txo=%g, yo=%g, qudarant=%d\n", xo,yo,quado );

	/* get direction to PT from origin */
	VSUB2( pt_dir, pt, v0->vg_p->coord );

	if(rt_g.NMG_debug & DEBUG_PT_FU )
		bu_log( "\tpt_dir=( %g %g %g )\n", V3ARGS( pt_dir ) );

	/* get X and Y components for PT */
	xpt = VDOT( eu_dir, pt_dir );
	ypt = VDOT( left, pt_dir );

	/* which quadrant does this XY point lie in */
	quadpt = Quadrant( xpt, ypt );

	if(rt_g.NMG_debug & DEBUG_PT_FU )
		bu_log( "\txpt=%g, ypt=%g, qudarant=%d\n", xpt,ypt,quadpt );

	/* do a quadrant comparison first (cheap!!!) */
	if( quadpt < quado )
		return( NMG_CLASS_AinB );

	if( quadpt > quado )
		return( NMG_CLASS_AoutB );

	/* both are in the same quadrant, need to normalize the corrdinates */
	len = sqrt( xo*xo + yo*yo );
	xo = xo/len;
	yo = yo/len;

	len = sqrt( xpt*xpt + ypt*ypt );
	xpt = xpt/len;
	ypt = ypt/len;

	if(rt_g.NMG_debug & DEBUG_PT_FU )
		bu_log( "\tNormalized xo,yo=(%g %g), xpt,ypt=( %g %g )\n", xo,yo,xpt,ypt );

	switch( quadpt )
	{
		case 1:
			if( xpt >= xo && ypt <= yo )
				class = NMG_CLASS_AinB;
			else
				class = NMG_CLASS_AoutB;
			break;
		case 2:
			if( xpt >= xo && ypt >= yo )
				class = NMG_CLASS_AinB;
			else
				class = NMG_CLASS_AoutB;
			break;
		case 3:
			if( xpt <= xo && ypt >= yo )
				class = NMG_CLASS_AinB;
			else
				class = NMG_CLASS_AoutB;
			break;
		case 4:
			if( xpt <= xo && ypt <= yo )
				class = NMG_CLASS_AinB;
			else
				class = NMG_CLASS_AoutB;
			break;
		default:
			bu_log( "This can't happen (illegal quadrant %d)\n", quadpt );
			rt_bomb( "This can't happen (illegal quadrant)\n" );
			break;
	}
	if(rt_g.NMG_debug & DEBUG_PT_FU )
		bu_log( "returning %s\n", nmg_class_name( class ) );

	return( class );
}

/*	N M G _ C L A S S _ P T _ E U
 *
 * If there is no ve_dist structure for this edge, compute one and
 * add it to the list.
 *
 * Sort an edge_info structure into the loops list of edgeuse status
 */
static struct edge_info *
nmg_class_pt_eu(struct fpi *fpi, struct edgeuse *eu, struct edge_info *edge_list, const int in_or_out_only)
{
	struct bn_tol	tmp_tol;
	struct edgeuse	*next_eu;
	struct ve_dist	*ved, *ed;
	struct edge_info	*ei_p;
	struct edge_info	*ei;
	pointp_t		eu_pt;
	vect_t		left;
	vect_t		v_to_pt;
	int		found_data = 0;

	NMG_CK_FPI(fpi);	
	BN_CK_TOL(fpi->tol);

	if (rt_g.NMG_debug & DEBUG_PT_FU) {
		bu_log("pt (%g %g %g) vs_edge (%g %g %g) (%g %g %g) (eu=x%x)\n",
			V3ARGS(fpi->pt),
			V3ARGS(eu->vu_p->v_p->vg_p->coord),
			V3ARGS(eu->eumate_p->vu_p->v_p->vg_p->coord), eu);
	}
#if 0
	/* try to find this edge in the list of ve_dist's */
	for (BU_LIST_FOR(ed, ve_dist, &fpi->ve_dh)) {
		NMG_CK_VED(ed);
		if (ed->magic_p == &eu->e_p->magic) {

			/* found the data for this edge */

			if (rt_g.NMG_debug & DEBUG_PT_FU)
				bu_log ("pt previously classified WRT Edge\n");

			ved = ed;
			found_data = 1;
			goto found;
		}

		if (ed->dist <= fpi->tol->dist_sq &&
		    (ed->magic_p == &eu->vu_p->v_p->magic ||
		     ed->magic_p == &eu->eumate_p->vu_p->v_p->magic) ) {
			/* The point is within tolerance of an endpoint
			 * of the edge.
			 */
			if (rt_g.NMG_debug & DEBUG_PT_FU) {
				register struct vertex *v_p = 
					(struct vertex *)ed->magic_p;
				bu_log ("vertex (%g %g %g) of edge previously touched\n",
					V3ARGS(v_p->vg_p->coord));
			}
			ved = ed;
			found_data = 1;
			goto found;
		}
	}
#endif

	/* we didn't find a ve_dist structure for this edge, so we'll
	 * have to do the calculations.
	 */
	tmp_tol = (*fpi->tol);
	if( in_or_out_only )
	{
		tmp_tol.dist = 0.0;
		tmp_tol.dist_sq = 0.0;
	}

	ved = (struct ve_dist *)bu_malloc(sizeof(struct ve_dist), "ve_dist structure");
	ved->magic_p = &eu->e_p->magic;
	ved->status = bn_distsq_pt3_lseg3(&ved->dist,
					eu->vu_p->v_p->vg_p->coord,
					eu->eumate_p->vu_p->v_p->vg_p->coord,
					fpi->pt,
					&tmp_tol);
	ved->v1 = eu->vu_p->v_p;
	ved->v2 = eu->eumate_p->vu_p->v_p;
	BU_LIST_MAGIC_SET(&ved->l, NMG_VE_DIST_MAGIC);
	BU_LIST_APPEND(&fpi->ve_dh, &ved->l);
	eu_pt = ved->v1->vg_p->coord;

	if (rt_g.NMG_debug & DEBUG_PT_FU )
	{
		bu_log( "nmg_class_pt_eu: status for eu x%x (%g %g %g)<->(%g %g %g) vs pt (%g %g %g) is %d\n",
			eu, V3ARGS( eu->vu_p->v_p->vg_p->coord ),
			V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ),
			V3ARGS( fpi->pt ), ved->status );
		bu_log( "\tdist = %g\n", ved->dist );
	}



	/* Add a struct for this edgeuse to the loop's list of dist-sorted
	 * edgeuses.
	 */
	ei = (struct edge_info *)bu_malloc(sizeof(struct edge_info), "struct edge_info");
	ei->ved_p = ved;
	ei->eu_p = eu;
	BU_LIST_MAGIC_SET(&ei->l, NMG_EDGE_INFO_MAGIC);

	/* compute the status (ei->status) of the point WRT this edge */

	switch (ved->status) {
	case 0: /* pt is on the edge(use) */
		ei->class = NMG_CLASS_AonBshared;
		if (fpi->eu_func &&
		    (fpi->hits == NMG_FPI_PERUSE ||
		     (fpi->hits == NMG_FPI_PERGEOM && !found_data) ) ) {
			fpi->eu_func(eu, fpi->pt, fpi->priv);
		}
		break;
	case 1:	/* within tolerance of endpoint at ved->v1 */
		ei->class = NMG_CLASS_AonBshared;
		/* add an entry for the vertex in the edge list so that
		 * other uses of this vertex will claim the point is within
		 * tolerance without re-computing
		 */
		ed = (struct ve_dist *)bu_malloc(sizeof(struct ve_dist), "ve_dist structure");
		ed->magic_p = &ved->v1->magic;
		ed->status = ved->status;
		ed->v1 = ed->v2 = ved->v1;

		BU_LIST_MAGIC_SET(&ed->l, NMG_VE_DIST_MAGIC);
		BU_LIST_APPEND(&fpi->ve_dh, &ed->l);

		if (fpi->vu_func &&
		    (fpi->hits == NMG_FPI_PERUSE ||
		     (fpi->hits == NMG_FPI_PERGEOM && !found_data) ) ) {
			fpi->vu_func(eu->vu_p, fpi->pt, fpi->priv);
		}

		break;
	case 2:	/* within tolerance of endpoint at ved->v2 */
		ei->class = NMG_CLASS_AonBshared;
		/* add an entry for the vertex in the edge list so that
		 * other uses of this vertex will claim the point is within
		 * tolerance without re-computing
		 */
		ed = (struct ve_dist *)bu_malloc(sizeof(struct ve_dist), "ve_dist structure");
		ed->magic_p = &ved->v2->magic;
		ed->status = ved->status;
		ed->v1 = ed->v2 = ved->v2;

		BU_LIST_MAGIC_SET(&ed->l, NMG_VE_DIST_MAGIC);
		BU_LIST_APPEND(&fpi->ve_dh, &ed->l);
		if (fpi->vu_func &&
		    (fpi->hits == NMG_FPI_PERUSE ||
		     (fpi->hits == NMG_FPI_PERGEOM && !found_data) ) ) {
			fpi->vu_func(eu->eumate_p->vu_p, fpi->pt, fpi->priv);
		}
		break;

	case 3: /* PCA of pt on line is within tolerance of ved->v1 of segment */
		ei->class = nmg_class_pt_euvu( fpi->pt, eu, fpi->tol );
		if( ei->class == NMG_CLASS_Unknown )
			ei->ved_p->dist = MAX_FASTF;
		break;
	case 4: /* PCA of pt on line is within tolerance of ved->v2 of segment */
		next_eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l);
		ei->class = nmg_class_pt_euvu( fpi->pt, next_eu, fpi->tol );
		if( ei->class == NMG_CLASS_Unknown )
			ei->ved_p->dist = MAX_FASTF;
		break;

	case 5: /* PCA is along length of edge, but point is NOT on edge. */
		if (nmg_find_eu_left_non_unit( left, eu ))
			rt_bomb("can't find left vector\n");
		/* take dot product of v->pt vector with left to determine
		 * if pt is inside/left of edge
		 */
		VSUB2(v_to_pt, fpi->pt, eu_pt);
		if (VDOT(v_to_pt, left) >= 0.0)
			ei->class = NMG_CLASS_AinB;
		else
			ei->class = NMG_CLASS_AoutB;
		break;
	default:
		bu_log("%s:%d status = %d\n", __FILE__, __LINE__, ved->status);
		rt_bomb("Why did this happen?");
		break;
	}


	if (rt_g.NMG_debug & DEBUG_PT_FU) {
		bu_log("pt @@ dist %g from edge classed %s vs edge\n",
			ei->ved_p->dist, nmg_class_name(ei->class));
/*		pl_pt_e(fpi, ei); */
	}

	/* now that it's complete, add ei to the edge list */
	for (BU_LIST_FOR(ei_p, edge_info, &edge_list->l)) {
		/* if the distance to this edge is smaller, or
		 * if the distance is the same & the edge is the same
		 *	Insert edge_info struct here in list
		 */
		if (ved->dist < ei_p->ved_p->dist ||
		   (ved->dist == ei_p->ved_p->dist &&
		    ei_p->ved_p->magic_p == ved->magic_p) )
			break;
	}

	BU_LIST_INSERT(&ei_p->l, &ei->l);
	return ei;
}

/*
 * Make a list of all edgeuses which are at the same distance as the
 * first element on the list.  Toss out opposing pairs of edgeuses of the
 * same edge.
 *
 */
HIDDEN void make_near_list( struct edge_info *edge_list, struct bu_list *near1)
{
	struct edge_info *ei;
	struct edge_info *ei_p;
	struct edge_info *tmp;
	double dist;

	BU_CK_LIST_HEAD(&edge_list->l);
	BU_CK_LIST_HEAD(near1);

	/* toss opposing pairs of uses of the same edge from the list */
	ei = BU_LIST_FIRST( edge_info, &edge_list->l);
	while( BU_LIST_NOT_HEAD( &ei->l, &edge_list->l)) {
		NMG_CK_EI(ei);
		ei_p = BU_LIST_FIRST( edge_info, &edge_list->l);
		while( BU_LIST_NOT_HEAD( &ei_p->l, &edge_list->l)) {
			NMG_CK_EI(ei_p);
			NMG_CK_VED(ei_p->ved_p);

			/* if we've found an opposing use of the same
			 *    edge toss the pair of them
			 */
			if (ei_p->ved_p->magic_p == ei->ved_p->magic_p &&
			    ei_p->eu_p->eumate_p->vu_p->v_p == ei->eu_p->vu_p->v_p &&
			    ei_p->eu_p->vu_p->v_p == ei->eu_p->eumate_p->vu_p->v_p ) {
				if (rt_g.NMG_debug & DEBUG_PT_FU ) {
					bu_log("tossing edgeuse pair:\n");
					bu_log("(%g %g %g) -> (%g %g %g)\n",
						V3ARGS(ei->eu_p->vu_p->v_p->vg_p->coord),
						V3ARGS(ei->eu_p->eumate_p->vu_p->v_p->vg_p->coord));
					bu_log("(%g %g %g) -> (%g %g %g)\n",
						V3ARGS(ei_p->eu_p->vu_p->v_p->vg_p->coord),
						V3ARGS(ei_p->eu_p->eumate_p->vu_p->v_p->vg_p->coord));
				}

			    	tmp = ei_p;
			    	ei_p = BU_LIST_PLAST(edge_info, &ei_p->l);
				BU_LIST_DEQUEUE(&tmp->l);
				bu_free((char *)tmp, "edge info struct");
			    	tmp = ei;
			    	ei = BU_LIST_PLAST(edge_info, &ei->l);
				BU_LIST_DEQUEUE(&tmp->l);
				bu_free((char *)tmp, "edge info struct");
			    	break;
			}
			ei_p = BU_LIST_PNEXT( edge_info, &ei_p->l );
		}
		ei = BU_LIST_PNEXT( edge_info, &ei->l );
	}

	if( BU_LIST_IS_EMPTY( &edge_list->l ) )
		return;

	ei = BU_LIST_FIRST(edge_info, &edge_list->l);
	NMG_CK_EI(ei);
	NMG_CK_VED(ei->ved_p);
	dist = ei->ved_p->dist;
	
	/* create "near" list with all ei's at this dist */
	for (BU_LIST_FOR(ei, edge_info, &edge_list->l)) {
		NMG_CK_EI(ei);
		NMG_CK_VED(ei->ved_p);
		if (ei->ved_p->dist == dist) {
			ei_p = BU_LIST_PLAST(edge_info, &ei->l);
			BU_LIST_DEQUEUE(&ei->l);
			BU_LIST_APPEND(near1, &ei->l);
			ei = ei_p;
		}
	}

	if (rt_g.NMG_debug & DEBUG_PT_FU ) {
		bu_log("dist %g near list\n", dist);
		for (BU_LIST_FOR(ei, edge_info, near1)) {
			bu_log("\t(%g %g %g) -> (%g %g %g)\n",
				V3ARGS(ei->eu_p->vu_p->v_p->vg_p->coord),
				V3ARGS(ei->eu_p->eumate_p->vu_p->v_p->vg_p->coord));
			bu_log("\tdist:%g class:%s status:%d\n\t\tv1(%g %g %g) v2(%g %g %g)\n",
			ei->ved_p->dist, nmg_class_name(ei->class),
			ei->ved_p->status,
			V3ARGS(ei->ved_p->v1->vg_p->coord),
			V3ARGS(ei->ved_p->v2->vg_p->coord));
			bu_log( "\tei->ved_p->magic_p=x%x, ei->eu_p->vu_p=x%x, ei->eu_p->eumate_p->vu_p=x%x\n",
				ei->ved_p->magic_p, ei->eu_p->vu_p, ei->eu_p->eumate_p->vu_p );	
		}
	}
}





static void
pl_pt_lu(struct fpi *fpi, struct loopuse *lu, struct edge_info *ei)
{
	FILE *fd;
	char name[25];
	long *b;
	static int plot_file_number=0;
	int i;
	point_t p1, p2;
	point_t pca;
	fastf_t dist;
	struct bn_tol tmp_tol;

	NMG_CK_FPI(fpi);	
	NMG_CK_FACEUSE(fpi->fu_p);
	NMG_CK_LOOPUSE(lu);
	NMG_CK_EI(ei);

	sprintf(name, "pt_lu%02d.pl", plot_file_number++);
	if ((fd=fopen(name, "w")) == (FILE *)NULL) {
		perror(name);
		abort();
	}

	bu_log("\toverlay %s\n", name);
	b = (long *)bu_calloc( fpi->fu_p->s_p->r_p->m_p->maxindex,
		sizeof(long), "bit vec"),

	pl_erase(fd);
	pd_3space(fd,
		fpi->fu_p->f_p->min_pt[0]-1.0,
		fpi->fu_p->f_p->min_pt[1]-1.0,
		fpi->fu_p->f_p->min_pt[2]-1.0,
		fpi->fu_p->f_p->max_pt[0]+1.0,
		fpi->fu_p->f_p->max_pt[1]+1.0,
		fpi->fu_p->f_p->max_pt[2]+1.0);
	
	nmg_pl_lu(fd, lu, b, 255, 255, 255);

        tmp_tol.magic = BN_TOL_MAGIC;
        tmp_tol.dist = 0.005;
        tmp_tol.dist_sq = tmp_tol.dist * tmp_tol.dist;
        tmp_tol.perp = 1e-6;
        tmp_tol.para = 1 - tmp_tol.perp;

	(void)bn_dist_pt3_lseg3( &dist, pca, ei->eu_p->vu_p->v_p->vg_p->coord,
		ei->eu_p->eumate_p->vu_p->v_p->vg_p->coord, fpi->pt, &tmp_tol );

	pl_color(fd, 255, 255, 50);
	pdv_3line(fd, pca, fpi->pt);

	pl_color(fd, 255, 64, 255);

	/* make a nice axis-cross at the point in question */
	for (i=0 ; i < 3 ; i++) {
		VMOVE(p1, fpi->pt);
		p1[i] -= 1.0;
		VMOVE(p2, fpi->pt);
		p2[i] += 1.0;
		pdv_3line(fd, p1, p2);
	}

	bu_free((char *)b, "bit vec");
	fclose(fd);
}




/*	C O M P U T E _ L O O P _ C L A S S
 *
 * Given a list of edge_info structures for the edges of a loop,
 *	determine what the classification for the loop should be.
 *
 *  If passed a "crack" loop, will produce random results.
 */

static int
compute_loop_class(struct fpi *fpi, 
		   const struct loopuse *lu,
		   struct edge_info *edge_list)
{
	struct edge_info *ei;
	struct edge_info *ei_vdot_max;
	struct bu_list	near1;
	int 		lu_class = NMG_CLASS_Unknown;

	if (rt_g.NMG_debug & DEBUG_PT_FU ) {
		bu_log("compute_loop_class()\n");
		for (BU_LIST_FOR(ei, edge_info, &edge_list->l)) {
bu_log("dist:%g class:%s status:%d\n\tv1(%g %g %g) v2(%g %g %g)\n",
				ei->ved_p->dist, nmg_class_name(ei->class),
				ei->ved_p->status,
				V3ARGS(ei->ved_p->v1->vg_p->coord),
				V3ARGS(ei->ved_p->v2->vg_p->coord));
		}
	}

	BU_CK_LIST_HEAD(&edge_list->l);
	BU_LIST_INIT(&near1);

	/* get a list of "closest/useful" edges to use in classifying
	 * the pt WRT the loop
	 */
	while (BU_LIST_IS_EMPTY(&near1) && BU_LIST_NON_EMPTY(&edge_list->l)) {
		make_near_list(edge_list, &near1);
	}
	
	if (BU_LIST_IS_EMPTY(&near1)) {
		/* This was a "crack" or "snake" loop */
		
		if (lu->orientation == OT_SAME) {
			lu_class = NMG_CLASS_AoutB;
		} else if (lu->orientation == OT_OPPOSITE) {
			lu_class = NMG_CLASS_AinB;
		} else
			rt_bomb("bad lu orientation\n");

		if (rt_g.NMG_debug & DEBUG_PT_FU ) {
			bu_log("list was empty, so class is %s\n", 
				nmg_class_name(lu_class));
		}
		goto departure;
	}


	ei_vdot_max = (struct edge_info *)NULL;

	for (BU_LIST_FOR(ei, edge_info, &near1)) {
		NMG_CK_EI(ei);
		NMG_CK_VED(ei->ved_p);
		switch (ei->ved_p->status) {
		case 0: /* pt is on edge */
		case 1: /* pt is on ei->ved_p->v1 */
		case 2:	/* pt is on ei->ved_p->v2 */
			lu_class = NMG_CLASS_AonBshared;
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				pl_pt_lu(fpi, lu, ei);
			goto departure;
		case 3: /* pt pca is v1 */
		case 4: /* pt pca is v2 */
		case 5: /* pt pca between v1 and v2 */
			lu_class = ei->class;
			if (rt_g.NMG_debug & DEBUG_PT_FU ) {
				bu_log("found status 5 edge, loop class is %s\n", 
					nmg_class_name(lu_class));
			}
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				pl_pt_lu(fpi, lu, ei);
			goto departure;
		default:
			bu_log("%s:%d status = %d\n",
				__FILE__, __LINE__, ei->ved_p->status);
			rt_bomb("Why did this happen?");
			break;
		}
	}
	if (ei_vdot_max) {
		if (rt_g.NMG_debug & DEBUG_PT_FU)
			pl_pt_lu(fpi, lu, ei_vdot_max);
	} else {
		bu_log("%s:%d ei_vdot_max not set\n",
			__FILE__, __LINE__);
		rt_bomb("How does this happen?\n");
	}
departure:

	/* the caller will get whatever is left of the edge_list, but
	 * we need to free up the "near" list
	 */
	while (BU_LIST_WHILE(ei, edge_info, &near1)) {
		BU_LIST_DEQUEUE( &ei->l );
		bu_free( (char *)ei, "edge_info struct");
	}
	
	if (rt_g.NMG_debug & DEBUG_PT_FU ) {
		bu_log("compute_loop_class() returns %s\n", 
			nmg_class_name(lu_class));
	}

	return lu_class;
}
/*
 *
 * For each edgeuse, compute an edge_info structure.
 *
 * if min_dist == 0 return ON
 *
 * For dist min -> max
 *	if even # of uses of edge in this loop
 *		"ignore" all uses of this edge since we can't answer the
 *		    "spike" problem:	*---------*
 *					| .	  |
 *					*---*	  |  .
 *					|	  *----*
 *					|	  |
 *					*---------*
 *	else (odd # of uses of edge in this loop)
 *		"ignore" consecutive uses of the same edge to avoid the
 *		    "accordian pleat" problem:	*-------*
 *						|  .	|
 *						*----*	|
 *						*----*	|
 *						*----*	|
 *						*----*--*
 *		classify pt WRT remaining edgeuse
 *
 * The "C-clamp" problem:
 *	*---------------* 
 *	|		|
 *	|  *----*	|
 *	|  |	|   .	|
 *	|  |	*-------*
 *	|  |	|	|
 *	|  *----*	|
 *	|		|
 *	*---------------* 
 *
 */
static int
nmg_class_pt_lu(struct loopuse *lu, struct fpi *fpi, const int in_or_out_only)
{
	int 	lu_class = NMG_CLASS_Unknown;

	NMG_CK_FPI(fpi);
	NMG_CK_LOOPUSE(lu);
	NMG_CK_LOOP(lu->l_p);
	NMG_CK_LOOP_G(lu->l_p->lg_p);


	if (!V3PT_IN_RPP( fpi->pt, lu->l_p->lg_p->min_pt, lu->l_p->lg_p->max_pt)) {
		/* point is not in RPP of loop */

		if (rt_g.NMG_debug & DEBUG_PT_FU )
		{
			bu_log("nmg_class_pt_lu( pt(%g %g %g) outside loop RPP\n",
				V3ARGS(fpi->pt));
			bu_log( "   lu RPP: ( %g %g %g ) <-> ( %g %g %g )\n",
				V3ARGS(lu->l_p->lg_p->min_pt), V3ARGS( lu->l_p->lg_p->max_pt) );
		}

		if (lu->orientation == OT_SAME)
			return NMG_CLASS_AoutB;
		else if (lu->orientation == OT_OPPOSITE)
			return NMG_CLASS_AinB;
		else if (lu->orientation == OT_UNSPEC)
			return NMG_CLASS_Unknown;
			
	}

	if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
		register struct edgeuse	*eu;
		struct edge_info edge_list;
		struct edge_info *ei;
		int		is_crack;

		is_crack = nmg_loop_is_a_crack(lu);
		if( lu->orientation == OT_OPPOSITE && is_crack )  {
			/*  Even if point lies on a crack, if it's an
			 *  OT_OPPOSITE crack loop, it subtracts nothing.
			 *  Just ignore it.
			 */
			lu_class = NMG_CLASS_AinB;
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				bu_log("nmg_class_pt_lu() ignoring OT_OPPOSITE crack loop\n");
			goto out;
		}

		BU_LIST_INIT(&edge_list.l);

		for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
			ei = nmg_class_pt_eu(fpi, eu, &edge_list, in_or_out_only);
			NMG_CK_EI(ei);
			NMG_CK_VED(ei->ved_p);
			if ( !in_or_out_only && ei->ved_p->dist < fpi->tol->dist_sq) {
				lu_class = NMG_CLASS_AinB;
				break;
			}
		}
		/* */
		if (lu_class == NMG_CLASS_Unknown)  {
			/* pt does not touch any edge or vertex */
			if( is_crack )  {
				/* orientation here is OT_SAME */
				lu_class = NMG_CLASS_AoutB;
			} else {
				lu_class = compute_loop_class(fpi, lu, &edge_list);
			}
		} else {
			/* pt touches edge or vertex */
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				bu_log("loop class already known (pt must touch edge)\n");
		}

		/* free up the edge_list elements */
		while ( BU_LIST_WHILE(ei, edge_info, &edge_list.l) ) {
			BU_LIST_DEQUEUE( &ei->l );
			bu_free( (char *)ei, "edge info struct");
		}
	} else if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
		register struct vertexuse *vu;
		int v_class;

		vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
		v_class = nmg_class_pt_vu(fpi, vu);

		switch (lu->orientation) {
		case OT_BOOLPLACE:
		case OT_SAME:
			if (v_class == NMG_FPI_TOUCHED)
				lu_class = NMG_CLASS_AinB;
			else
				lu_class = NMG_CLASS_AoutB;
			break;
		case OT_OPPOSITE:
			/* Why even call nmg_class_pt_vu() here, if return isn't used? */
				lu_class = NMG_CLASS_AinB;
			break;
		case OT_UNSPEC:
				lu_class = NMG_CLASS_Unknown;
			break;
		default:
			bu_log("nmg_class_pt_lu() hit %s loop at vu=x%x\n",
				nmg_orientation(lu->orientation), vu);
			rt_bomb("nmg_class_pt_lu() Loop orientation error\n");
			break;
		}
	} else {
		bu_log("%s:%d bad child of loopuse\n", __FILE__, __LINE__);
		rt_bomb("nmg_class_pt_lu() crash and burn\n");
	}


out:
	if (rt_g.NMG_debug & DEBUG_PT_FU )
		bu_log("nmg_class_pt_lu() pt classed %s vs loop\n", nmg_class_name(lu_class));

	return lu_class;
}


static void
plot_parity_error(struct faceuse *fu, fastf_t *pt)
{
	long *b;
	FILE *fp; 
	point_t p1, p2;
	int i;

	NMG_CK_FACEUSE(fu);

	if (!(fp=fopen("pt_fu_parity_error.pl", "w")) )
		rt_bomb("error opening pt_fu_parity_error.pl\n");


	bu_log("overlay pt_fu_parity_error.pl\n");

	b = (long *)bu_calloc( fu->s_p->r_p->m_p->maxindex,
			      sizeof(long), "bit vec"),


	pl_erase(fp);
	pd_3space(fp,
                fu->f_p->min_pt[0]-1.0,
                fu->f_p->min_pt[1]-1.0,
                fu->f_p->min_pt[2]-1.0,
                fu->f_p->max_pt[0]+1.0,
                fu->f_p->max_pt[1]+1.0,
                fu->f_p->max_pt[2]+1.0);

	nmg_pl_fu(fp, fu, b, 200, 200, 200);


	/* make a nice axis-cross at the point in question */
	for (i=0 ; i < 3 ; i++) {
		VMOVE(p1, pt);
		p1[i] -= 1.0;
		VMOVE(p2, pt);
		p2[i] += 1.0;
		pdv_3line(fp, p1, p2);
	}

	bu_free((char *)b, "plot table");
	fclose(fp);

}

/*
 *
 * Classify a point on a face's plane as being inside/outside the area
 * of the face.
 *
 * For each loopuse, compute IN/ON/OUT
 *
 * if any loop has pt classified as "ON" return "ON" (actually returns "IN" -jra)
 *
 * ignore all OT_SAME loops w/pt classified as "OUT"
 * ignore all OT_OPPOSITE loops w/pt classified as "IN"
 * If (# OT_SAME loops == # OT_OPPOSITE loops)
 *	pt is "OUT"
 * else if (# OT_SAME loops - 1 == # OT_OPPOSITE loops)
 *	pt is "IN"
 * else
 *	Error! panic!
 *
 *
 *  Values for "call_on_hits"
 *	1	find all elements pt touches, call user routine for each geom.
 *	2	find all elements pt touches, call user routine for each use
 *
 *  in_or_out_only:
 *	non-zero	pt is known NOT to be on an EU of FU
 *	   0		pt may be on an EU of FU
 *
 *  Returns -
 *	NMG_CLASS_AonB, etc...
 */
int
nmg_class_pt_fu_except(const fastf_t *pt, const struct faceuse *fu, const struct loopuse *ignore_lu, void (*eu_func) (/* ??? */), void (*vu_func) (/* ??? */), const char *priv, const int call_on_hits, const int in_or_out_only, const struct bn_tol *tol)
                 
                         
                                   
                                        /* func to call when pt on edgeuse */
                                        /* func to call when pt on vertexuse*/
          		                /* private data for [ev]u_func */
         		             
         		               
                             
{
	struct fpi	fpi;
	struct loopuse	*lu;
	int		ot_same_in = 0;
	int		ot_opposite_out = 0;
	int		ot_same[4];
	int		ot_opposite[4];
	int		lu_class;
	int		fu_class = NMG_CLASS_Unknown;
	double		dist;
	struct ve_dist	*ved_p;
	int		i;

	if (rt_g.NMG_debug & DEBUG_PT_FU )
		bu_log("nmg_class_pt_fu_except( pt=(%g %g %g), fu=x%x )\n", V3ARGS(pt), fu);

	if(fu->orientation != OT_SAME) rt_bomb("nmg_class_pt_fu_except() not OT_SAME\n");

	NMG_CK_FACEUSE(fu);
	NMG_CK_FACE(fu->f_p);
	NMG_CK_FACE_G_PLANE(fu->f_p->g.plane_p);
	if(ignore_lu) NMG_CK_LOOPUSE(ignore_lu);
	BN_CK_TOL(tol);

	/* Validate distance from point to plane */
	NMG_GET_FU_PLANE( fpi.norm, fu );
	if( (dist=fabs(DIST_PT_PLANE( pt, fpi.norm ))) > tol->dist )  {
		bu_log("nmg_class_pt_fu_except() ERROR, point (%g,%g,%g)\nnot on face %g %g %g %g,\ndist=%g\n",
			V3ARGS(pt), V4ARGS(fpi.norm), dist );
	}

	if( !V3PT_IN_RPP( pt, fu->f_p->min_pt, fu->f_p->max_pt ) )  {
		/* point is not in RPP of face, so there's NO WAY this point
		 * is anything but OUTSIDE
		 */
		if (rt_g.NMG_debug & DEBUG_PT_FU )
			bu_log("nmg_class_pt_fu_except( (%g %g %g) ouside face RPP\n",
				V3ARGS(pt));

		return NMG_CLASS_AoutB;
	}

	for( i=0; i<4; i++ )  {
		ot_same[i] = ot_opposite[i] = 0;
	}

	fpi.fu_p = fu;
	fpi.tol = tol;
	BU_LIST_INIT(&fpi.ve_dh);
	VMOVE(fpi.pt, pt);
	fpi.eu_func = eu_func;
	fpi.vu_func = vu_func;
	fpi.priv = priv;
	fpi.hits = call_on_hits;
	fpi.magic = NMG_FPI_MAGIC;

	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		if( ignore_lu && (ignore_lu==lu || ignore_lu==lu->lumate_p) )
			continue;

		/* Ignore OT_BOOLPLACE, etc */
		if( lu->orientation != OT_SAME && lu->orientation != OT_OPPOSITE )
			continue;

		lu_class = nmg_class_pt_lu(lu, &fpi, in_or_out_only);
		if (rt_g.NMG_debug & DEBUG_PT_FU )
			bu_log("loop %s says pt is %s\n",
				nmg_orientation(lu->orientation),
				nmg_class_name(lu_class) );

		if( lu_class < 0 || lu_class > 3 )  {
			bu_log("nmg_class_pt_fu_except() lu_class=%s %d\n",
				nmg_class_name(lu_class), lu_class);
			rt_bomb("nmg_class_pt_fu_except() bad lu_class\n");
		}

		if (lu->orientation == OT_OPPOSITE)  {
			ot_opposite[lu_class]++;
			if( lu_class == NMG_CLASS_AoutB )
				ot_opposite_out++;
		} else if (lu->orientation == OT_SAME )  {
			ot_same[lu_class]++;
			if (lu_class == NMG_CLASS_AinB ||
			     lu_class == NMG_CLASS_AonBshared)
				ot_same_in++;
		}
	}

	if (rt_g.NMG_debug & DEBUG_PT_FU )  {
		bu_log("loops ot_same_in:%d ot_opposite_out:%d\n",
			ot_same_in, ot_opposite_out);
		bu_log("loops in/onS/onA/out ot_same=%d/%d/%d/%d ot_opp=%d/%d/%d/%d\n",
			ot_same[0], ot_same[1], ot_same[2], ot_same[3],
			ot_opposite[0], ot_opposite[1], ot_opposite[2], ot_opposite[3] );
	}

	if (ot_same_in == ot_opposite_out)  {
		/* All the holes cancel out the solid loops */
		fu_class = NMG_CLASS_AoutB;
	} else if (ot_same_in > ot_opposite_out) {
		/* XXX How can this difference be > 1 ? */
		fu_class = NMG_CLASS_AinB;
	} else {
		/* Panic time!  How did I get a parity mis-match? */
		bu_log("loops in/onS/onA/out ot_same=%d/%d/%d/%d ot_opp=%d/%d/%d/%d\n",
			ot_same[0], ot_same[1], ot_same[2], ot_same[3],
			ot_opposite[0], ot_opposite[1], ot_opposite[2], ot_opposite[3] );
		bu_log("nmg_class_pt_fu_except(%g %g %g)\nParity error @@ %s:%d ot_same_in:%d ot_opposite_out:%d\n",
			V3ARGS(pt), __FILE__, __LINE__,
			ot_same_in, ot_opposite_out);
		bu_log( "fu=x%x\n",  fu );
		nmg_pr_fu_briefly( fu, "" );

		plot_parity_error(fu, pt);

#if 0
		/* Debug code -- go back and do it again while I'm watching! */
		rt_g.NMG_debug |= DEBUG_PT_FU;
		for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
			if( ignore_lu && (ignore_lu==lu || ignore_lu==lu->lumate_p) )
				continue;

			/* Ignore OT_BOOLPLACE, etc */
			if( lu->orientation != OT_SAME && lu->orientation != OT_OPPOSITE )
				continue;

			lu_class = nmg_class_pt_lu(lu, &fpi, in_or_out_only);
		}
#endif
		rt_bomb("nmg_class_pt_fu_except() loop classification parity error\n");
	}

	while (BU_LIST_WHILE(ved_p, ve_dist, &fpi.ve_dh)) {
		BU_LIST_DEQUEUE( &ved_p->l );
		bu_free( (char *)ved_p, "ve_dist struct");
	}


	if (rt_g.NMG_debug & DEBUG_PT_FU )
		bu_log("nmg_class_pt_fu_except() returns %s\n",
			nmg_class_name(fu_class));

	return fu_class;
}


/*
 *	N M G _ C L A S S _ P T _ L U _ E X C E P T 
 *
 *	Classify a point as being in/on/out of the area bounded by a loop,
 *	ignoring any uses of a particular edge in the loop.
 *
 *	This routine must be called with a face-loop of edges!
 *	It will not work properly on crack loops.
 */
int
nmg_class_pt_lu_except(fastf_t *pt, const struct loopuse *lu, const struct edge *e_p, const struct bn_tol *tol)
{
	register struct edgeuse	*eu;
	struct edge_info edge_list;
	struct edge_info *ei;
	struct fpi	fpi;
	int		lu_class = NMG_CLASS_Unknown;
	struct ve_dist	*ved_p;
	double		dist;

	if (rt_g.NMG_debug & DEBUG_PT_FU ) {
		bu_log("nmg_class_pt_lu_except( (%g %g %g) ", V3ARGS(pt), e_p);
		if (e_p)
			bu_log(" e_p=(%g %g %g) <-> (%g %g %g) )\n",
				V3ARGS(e_p->eu_p->vu_p->v_p->vg_p->coord),
				V3ARGS(e_p->eu_p->eumate_p->vu_p->v_p->vg_p->coord) );
		else
			bu_log(" e_p=(NULL) )\n");
	}

	NMG_CK_LOOPUSE(lu);

	if (e_p) NMG_CK_EDGE(e_p);

	NMG_CK_FACEUSE(lu->up.fu_p);

	/* Validate distance from point to plane */
	NMG_GET_FU_PLANE( fpi.norm, lu->up.fu_p );
	if( (dist=fabs(DIST_PT_PLANE( pt, fpi.norm ))) > tol->dist )  {
		bu_log("nmg_class_pt_lu_except() ERROR, point (%g,%g,%g)\nnot on face %g %g %g %g,\ndist=%g\n",
			V3ARGS(pt), V4ARGS(fpi.norm), dist );
	}


	if (!V3PT_IN_RPP( pt, lu->l_p->lg_p->min_pt, lu->l_p->lg_p->max_pt)) {
		/* point is not in RPP of loop */

		if (rt_g.NMG_debug & DEBUG_PT_FU )
			bu_log("nmg_class_pt_lu_except( pt(%g %g %g) outside loop RPP\n",
				V3ARGS(pt));

		if (lu->orientation == OT_SAME) return NMG_CLASS_AoutB;
		else if (lu->orientation == OT_OPPOSITE) return NMG_CLASS_AinB;
		else {
			bu_log("What kind of loop is this anyway? %s?\n",
				nmg_orientation(lu->orientation) );
			rt_bomb("");
		}
	}

	if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
		bu_log("%s:%d Improper use of nmg_class_pt_lu_except(pt(%g %g %g), vu)\n",
			__FILE__, __LINE__, V3ARGS(pt));
		rt_bomb("giving up\n");
	}

	BU_LIST_INIT(&edge_list.l);
	fpi.fu_p = lu->up.fu_p;

	fpi.tol = tol;
	BU_LIST_INIT(&fpi.ve_dh);
	VMOVE(fpi.pt, pt);
	fpi.eu_func = (void (*)())NULL;
	fpi.vu_func = (void (*)())NULL;
	fpi.priv = (char *)NULL;
	fpi.hits = 0;
	fpi.magic = NMG_FPI_MAGIC;

	for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
		if (eu->e_p == e_p) {
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				bu_log("skipping edguse (%g %g %g) -> (%g %g %g) on \"except\" edge\n",
					V3ARGS(eu->vu_p->v_p->vg_p->coord),
					V3ARGS(eu->eumate_p->vu_p->v_p->vg_p->coord) );

			continue;
		}

		ei = nmg_class_pt_eu(&fpi, eu, &edge_list, 0);
		NMG_CK_EI(ei);
		NMG_CK_VED(ei->ved_p);
		if (ei->ved_p->dist < tol->dist_sq) {
			lu_class = NMG_CLASS_AonBshared;
			break;
		}
	}
	if (lu_class == NMG_CLASS_Unknown)
		lu_class = compute_loop_class(&fpi, lu, &edge_list);
	else if (rt_g.NMG_debug & DEBUG_PT_FU )
		bu_log("loop class already known (pt must touch edge)\n");

	/* free up the edge_list elements */
	while ( BU_LIST_WHILE(ei, edge_info, &edge_list.l) ) {
		BU_LIST_DEQUEUE( &ei->l );
		bu_free( (char *)ei, "edge info struct");
	}

	while (BU_LIST_WHILE(ved_p, ve_dist, &fpi.ve_dh)) {
		BU_LIST_DEQUEUE( &ved_p->l );
		bu_free( (char *)ved_p, "ve_dist struct");
	}

	if (rt_g.NMG_debug & DEBUG_PT_FU )
		bu_log("nmg_class_pt_lu_except() returns %s\n",
			nmg_class_name(lu_class));

	return lu_class;
}
@


11.41
log
@change conf.h to a wrapped config.h
@
text
@@


11.40
log
@make_near_list() was missing its name
@
text
@d22 5
a26 1
#include "conf.h"
@


11.39
log
@merge of ansi-6-0-branch into HEAD
@
text
@d810 1
a810 1
HIDDEN void
@


11.38
log
@merge of windows-6-0-branch into head
@
text
@a31 5
/*
NOTES:
	Changed near to near1 for win32 compatibility 
*/

d122 1
a122 4
bn_distsq_pt3_lseg3( dist, a, b, p, tol )
fastf_t		*dist;
const point_t	a, b, p;
const struct bn_tol *tol;
d202 1
a202 3
nmg_class_pt_vu(fpi, vu)
struct fpi *fpi;
struct vertexuse *vu;
d302 1
a302 2
Quadrant( x, y )
fastf_t x,y;
d321 1
a321 2
nmg_eu_is_part_of_crack( eu )
const struct edgeuse *eu;
d365 1
a365 4
nmg_class_pt_euvu( pt, eu_in, tol )
const point_t pt;
struct edgeuse *eu_in;
const struct bn_tol *tol;
d601 1
a601 5
nmg_class_pt_eu(fpi, eu, edge_list, in_or_out_only)
struct fpi		*fpi;
struct edgeuse		*eu;
struct edge_info	*edge_list;
const int		in_or_out_only;
d810 1
a810 4
static void
make_near_list(edge_list, near1)
struct edge_info *edge_list;
struct bu_list *near1;
d902 1
a902 4
pl_pt_lu(fpi, lu, ei)
struct fpi *fpi;
struct loopuse *lu;
struct edge_info *ei;
d1121 1
a1121 4
nmg_class_pt_lu(lu, fpi, in_or_out_only)
struct loopuse	*lu;
struct fpi	*fpi;
const int	in_or_out_only;
d1243 1
a1243 3
plot_parity_error(fu, pt)
struct faceuse *fu;
point_t pt;
d1319 10
a1328 11
nmg_class_pt_fu_except(pt, fu, ignore_lu,
	eu_func, vu_func, priv, call_on_hits, in_or_out_only, tol)
const point_t pt;
const struct faceuse *fu;
const struct loopuse    *ignore_lu;
void                    (*eu_func)();   /* func to call when pt on edgeuse */
void                    (*vu_func)();   /* func to call when pt on vertexuse*/
const char		*priv;          /* private data for [ev]u_func */
const int		call_on_hits;
const int		in_or_out_only;
const struct bn_tol     *tol;
d1485 1
a1485 5
nmg_class_pt_lu_except(pt, lu, e_p, tol)
point_t		pt;
const struct loopuse	*lu;
const struct edge	*e_p;
const struct bn_tol	*tol;
@


11.37
log
@update copyright to include span through 2003
@
text
@d32 5
d830 1
a830 1
make_near_list(edge_list, near)
d832 1
a832 1
struct bu_list *near;
d840 1
a840 1
	BU_CK_LIST_HEAD(near);
d897 1
a897 1
			BU_LIST_APPEND(near, &ei->l);
d904 1
a904 1
		for (BU_LIST_FOR(ei, edge_info, near)) {
d1010 1
a1010 1
	struct bu_list	near;
d1025 1
a1025 1
	BU_LIST_INIT(&near);
d1030 2
a1031 2
	while (BU_LIST_IS_EMPTY(&near) && BU_LIST_NON_EMPTY(&edge_list->l)) {
		make_near_list(edge_list, &near);
d1034 1
a1034 1
	if (BU_LIST_IS_EMPTY(&near)) {
d1054 1
a1054 1
	for (BU_LIST_FOR(ei, edge_info, &near)) {
d1096 1
a1096 1
	while (BU_LIST_WHILE(ei, edge_info, &near)) {
@


11.36
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994 by the United States Army
@


11.36.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
@


11.36.10.2
log
@merge from head
@
text
@a31 5
/*
NOTES:
	Changed near to near1 for win32 compatibility 
*/

d825 1
a825 1
make_near_list(edge_list, near1)
d827 1
a827 1
struct bu_list *near1;
d835 1
a835 1
	BU_CK_LIST_HEAD(near1);
d892 1
a892 1
			BU_LIST_APPEND(near1, &ei->l);
d899 1
a899 1
		for (BU_LIST_FOR(ei, edge_info, near1)) {
d1005 1
a1005 1
	struct bu_list	near1;
d1020 1
a1020 1
	BU_LIST_INIT(&near1);
d1025 2
a1026 2
	while (BU_LIST_IS_EMPTY(&near1) && BU_LIST_NON_EMPTY(&edge_list->l)) {
		make_near_list(edge_list, &near1);
d1029 1
a1029 1
	if (BU_LIST_IS_EMPTY(&near1)) {
d1049 1
a1049 1
	for (BU_LIST_FOR(ei, edge_info, &near1)) {
d1091 1
a1091 1
	while (BU_LIST_WHILE(ei, edge_info, &near1)) {
@


11.36.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@a31 5
/*
NOTES:
	Changed near to near1 for win32 compatibility 
*/

d825 1
a825 1
make_near_list(edge_list, near1)
d827 1
a827 1
struct bu_list *near1;
d835 1
a835 1
	BU_CK_LIST_HEAD(near1);
d892 1
a892 1
			BU_LIST_APPEND(near1, &ei->l);
d899 1
a899 1
		for (BU_LIST_FOR(ei, edge_info, near1)) {
d1005 1
a1005 1
	struct bu_list	near1;
d1020 1
a1020 1
	BU_LIST_INIT(&near1);
d1025 2
a1026 2
	while (BU_LIST_IS_EMPTY(&near1) && BU_LIST_NON_EMPTY(&edge_list->l)) {
		make_near_list(edge_list, &near1);
d1029 1
a1029 1
	if (BU_LIST_IS_EMPTY(&near1)) {
d1049 1
a1049 1
	for (BU_LIST_FOR(ei, edge_info, &near1)) {
d1091 1
a1091 1
	while (BU_LIST_WHILE(ei, edge_info, &near1)) {
@


11.36.4.2
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
@


11.36.2.1
log
@Initial ANSIfication
@
text
@d122 4
a125 1
bn_distsq_pt3_lseg3(fastf_t *dist, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
d205 3
a207 1
nmg_class_pt_vu(struct fpi *fpi, struct vertexuse *vu)
d307 2
a308 1
Quadrant(fastf_t x, fastf_t y)
d327 2
a328 1
nmg_eu_is_part_of_crack(const struct edgeuse *eu)
d372 4
a375 1
nmg_class_pt_euvu(const fastf_t *pt, struct edgeuse *eu_in, const struct bn_tol *tol)
d611 5
a615 1
nmg_class_pt_eu(struct fpi *fpi, struct edgeuse *eu, struct edge_info *edge_list, const int in_or_out_only)
d825 3
a827 1
make_near_list(struct edge_info *edge_list, struct bu_list *near)
d919 4
a922 1
pl_pt_lu(struct fpi *fpi, struct loopuse *lu, struct edge_info *ei)
d1141 4
a1144 1
nmg_class_pt_lu(struct loopuse *lu, struct fpi *fpi, const int in_or_out_only)
d1266 3
a1268 1
plot_parity_error(struct faceuse *fu, fastf_t *pt)
d1344 11
a1354 10
nmg_class_pt_fu_except(const fastf_t *pt, const struct faceuse *fu, const struct loopuse *ignore_lu, void (*eu_func) (/* ??? */), void (*vu_func) (/* ??? */), const char *priv, const int call_on_hits, const int in_or_out_only, const struct bn_tol *tol)
                 
                         
                                   
                                        /* func to call when pt on edgeuse */
                                        /* func to call when pt on vertexuse*/
          		                /* private data for [ev]u_func */
         		             
         		               
                             
d1511 5
a1515 1
nmg_class_pt_lu_except(fastf_t *pt, const struct loopuse *lu, const struct edge *e_p, const struct bn_tol *tol)
@


11.36.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
a31 5
/*
NOTES:
	Changed near to near1 for win32 compatibility 
*/

d819 1
a819 1
	BU_CK_LIST_HEAD(near1);
d876 1
a876 1
			BU_LIST_APPEND(near1, &ei->l);
d883 1
a883 1
		for (BU_LIST_FOR(ei, edge_info, near1)) {
d986 1
a986 1
	struct bu_list	near1;
d1001 1
a1001 1
	BU_LIST_INIT(&near1);
d1006 2
a1007 2
	while (BU_LIST_IS_EMPTY(&near1) && BU_LIST_NON_EMPTY(&edge_list->l)) {
		make_near_list(edge_list, &near1);
d1010 1
a1010 1
	if (BU_LIST_IS_EMPTY(&near1)) {
d1030 1
a1030 1
	for (BU_LIST_FOR(ei, edge_info, &near1)) {
d1072 1
a1072 1
	while (BU_LIST_WHILE(ei, edge_info, &near1)) {
@


11.36.2.3
log
@clean up head merge into ansi
@
text
@d32 4
d816 1
a816 1
make_near_list(struct edge_info *edge_list, struct bu_list *near1)
@


11.35
log
@Converted from K&R to ANSI C - RFH
@
text
@d122 4
a125 1
bn_distsq_pt3_lseg3(fastf_t *dist, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
d205 3
a207 1
nmg_class_pt_vu(struct fpi *fpi, struct vertexuse *vu)
d307 2
a308 1
Quadrant(fastf_t x, fastf_t y)
d327 2
a328 1
nmg_eu_is_part_of_crack(const struct edgeuse *eu)
d372 4
a375 1
nmg_class_pt_euvu(const fastf_t *pt, struct edgeuse *eu_in, const struct bn_tol *tol)
d611 5
a615 1
nmg_class_pt_eu(struct fpi *fpi, struct edgeuse *eu, struct edge_info *edge_list, const int in_or_out_only)
d825 3
a827 1
make_near_list(struct edge_info *edge_list, struct bu_list *near)
d919 4
a922 1
pl_pt_lu(struct fpi *fpi, struct loopuse *lu, struct edge_info *ei)
d1141 4
a1144 1
nmg_class_pt_lu(struct loopuse *lu, struct fpi *fpi, const int in_or_out_only)
d1266 3
a1268 1
plot_parity_error(struct faceuse *fu, fastf_t *pt)
d1344 11
a1354 10
nmg_class_pt_fu_except(const fastf_t *pt, const struct faceuse *fu, const struct loopuse *ignore_lu, void (*eu_func) (/* ??? */), void (*vu_func) (/* ??? */), const char *priv, const int call_on_hits, const int in_or_out_only, const struct bn_tol *tol)
                 
                         
                                   
                                        /* func to call when pt on edgeuse */
                                        /* func to call when pt on vertexuse*/
          		                /* private data for [ev]u_func */
         		             
         		               
                             
d1511 5
a1515 1
nmg_class_pt_lu_except(fastf_t *pt, const struct loopuse *lu, const struct edge *e_p, const struct bn_tol *tol)
@


11.34
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d122 1
a122 4
bn_distsq_pt3_lseg3( dist, a, b, p, tol )
fastf_t		*dist;
const point_t	a, b, p;
const struct bn_tol *tol;
d202 1
a202 3
nmg_class_pt_vu(fpi, vu)
struct fpi *fpi;
struct vertexuse *vu;
d302 1
a302 2
Quadrant( x, y )
fastf_t x,y;
d321 1
a321 2
nmg_eu_is_part_of_crack( eu )
const struct edgeuse *eu;
d365 1
a365 4
nmg_class_pt_euvu( pt, eu_in, tol )
const point_t pt;
struct edgeuse *eu_in;
const struct bn_tol *tol;
d601 1
a601 5
nmg_class_pt_eu(fpi, eu, edge_list, in_or_out_only)
struct fpi		*fpi;
struct edgeuse		*eu;
struct edge_info	*edge_list;
const int		in_or_out_only;
d811 1
a811 3
make_near_list(edge_list, near)
struct edge_info *edge_list;
struct bu_list *near;
d903 1
a903 4
pl_pt_lu(fpi, lu, ei)
struct fpi *fpi;
struct loopuse *lu;
struct edge_info *ei;
d1122 1
a1122 4
nmg_class_pt_lu(lu, fpi, in_or_out_only)
struct loopuse	*lu;
struct fpi	*fpi;
const int	in_or_out_only;
d1244 1
a1244 3
plot_parity_error(fu, pt)
struct faceuse *fu;
point_t pt;
d1320 10
a1329 11
nmg_class_pt_fu_except(pt, fu, ignore_lu,
	eu_func, vu_func, priv, call_on_hits, in_or_out_only, tol)
const point_t pt;
const struct faceuse *fu;
const struct loopuse    *ignore_lu;
void                    (*eu_func)();   /* func to call when pt on edgeuse */
void                    (*vu_func)();   /* func to call when pt on vertexuse*/
const char		*priv;          /* private data for [ev]u_func */
const int		call_on_hits;
const int		in_or_out_only;
const struct bn_tol     *tol;
d1486 1
a1486 5
nmg_class_pt_lu_except(pt, lu, e_p, tol)
point_t		pt;
const struct loopuse	*lu;
const struct edge	*e_p;
const struct bn_tol	*tol;
@


11.33
log
@CONST to const
@
text
@d138 1
a138 1
	if( rt_g.debug & DEBUG_MATH )   {
@


11.32
log
@
lint
@
text
@d63 2
a64 2
	CONST struct bn_tol	*tol;
	CONST struct faceuse	*fu_p;
d70 1
a70 1
	CONST char	*priv;		/* caller's private data */
d85 1
a85 1
static struct edge_info *nmg_class_pt_eu(struct fpi *fpi, struct edgeuse *eu, struct edge_info *edge_list, CONST int in_or_out_only);
d87 2
a88 2
static int	nmg_class_pt_lu(struct loopuse *lu, struct fpi *fpi, CONST int in_or_out_only);
int		nmg_class_pt_fu_except(CONST point_t pt, CONST struct faceuse *fu, CONST struct loopuse *ignore_lu, void (*eu_func)(), void (*vu_func)(), CONST char *priv, CONST int call_on_hits, CONST int in_or_out_only, CONST struct bn_tol *tol);
d124 2
a125 2
CONST point_t	a, b, p;
CONST struct bn_tol *tol;
d328 1
a328 1
CONST struct edgeuse *eu;
d373 1
a373 1
CONST point_t pt;
d375 1
a375 1
CONST struct bn_tol *tol;
d615 1
a615 1
CONST int		in_or_out_only;
d1144 1
a1144 1
CONST int	in_or_out_only;
d1346 3
a1348 3
CONST point_t pt;
CONST struct faceuse *fu;
CONST struct loopuse    *ignore_lu;
d1351 4
a1354 4
CONST char		*priv;          /* private data for [ev]u_func */
CONST int		call_on_hits;
CONST int		in_or_out_only;
CONST struct bn_tol     *tol;
@


11.31
log
@Massive compilation warnings eliminated
@
text
@d389 1
a389 1
	int class;
@


11.30
log
@Eliminated some unused variables
@
text
@d30 1
a30 1

d84 1
a84 1
static void	pl_pt_e(struct fpi *fpi, struct edge_info *ei);
d86 1
a86 1
static int	compute_loop_class(struct fpi *fpi,struct loopuse *lu,struct edge_info *edge_list);
d252 1
d305 1
a305 1

d703 1
a703 1
found:
d999 3
a1001 4
compute_loop_class(fpi, lu, edge_list)
struct fpi *fpi;
struct loopuse *lu;
struct edge_info *edge_list;
d1513 3
a1515 3
struct loopuse	*lu;
struct edge	*e_p;
struct bn_tol	*tol;
@


11.29
log
@
sed4
@
text
@a179 1
		fastf_t			param_dist;	/* parametric dist */
d210 1
a210 1
	struct ve_dist	*ve_d, *ved;
a622 1
	vect_t		pt_vec;
a1003 1
	struct edge_info *ei_p;
a1004 5
	double		vdot_max;
	double		vdot_val;
	vect_t		v_pt;
	vect_t		left;
	double		dist;
a1046 1
	vdot_max = 0.0;
a1270 1
	char name[80];
@


11.28
log
@fixed a bug in bn_distsq_pt3_lseg3() that was introduced on conversion to using distance squared.
@
text
@d229 1
a229 1
	ved = (struct ve_dist *) rt_malloc(sizeof(struct ve_dist), "ve_dist structure");
d277 1
a277 1
	b = (long *)rt_calloc( fpi->fu_p->s_p->r_p->m_p->maxindex,
d291 1
a291 1
        tmp_tol.magic = RT_TOL_MAGIC;
d302 1
a302 1
	rt_free((char *)b, "bit vec");
d682 1
a682 1
	ved = (struct ve_dist *)rt_malloc(sizeof(struct ve_dist), "ve_dist structure");
d709 1
a709 1
	ei = (struct edge_info *)rt_malloc(sizeof(struct edge_info), "struct edge_info");
d731 1
a731 1
		ed = (struct ve_dist *)rt_malloc(sizeof(struct ve_dist), "ve_dist structure");
d752 1
a752 1
		ed = (struct ve_dist *)rt_malloc(sizeof(struct ve_dist), "ve_dist structure");
d866 1
a866 1
				rt_free((char *)tmp, "edge info struct");
d870 1
a870 1
				rt_free((char *)tmp, "edge info struct");
d947 1
a947 1
	b = (long *)rt_calloc( fpi->fu_p->s_p->r_p->m_p->maxindex,
d961 1
a961 1
        tmp_tol.magic = RT_TOL_MAGIC;
d984 1
a984 1
	rt_free((char *)b, "bit vec");
d1102 1
a1102 1
		rt_free( (char *)ei, "edge_info struct");
d1230 1
a1230 1
			rt_free( (char *)ei, "edge info struct");
d1293 1
a1293 1
	b = (long *)rt_calloc( fu->s_p->r_p->m_p->maxindex,
d1318 1
a1318 1
	rt_free((char *)b, "plot table");
d1499 1
a1499 1
		rt_free( (char *)ved_p, "ve_dist struct");
d1619 1
a1619 1
		rt_free( (char *)ei, "edge info struct");
d1624 1
a1624 1
		rt_free( (char *)ved_p, "ve_dist struct");
@


11.27
log
@Replaced bn_dist_pt3_lseg_jra() with bn_distsq_pt3_lseg3(), changed meaning of "dist" field
in struct "ve_dist" to mean distance squared.
@
text
@d138 1
a138 1
	if( rt_g.debug & DEBUG_MATH )  {
d172 1
a172 1
	if( t <= tol->dist_sq )  {
@


11.26
log
@Used nmg_find_eu_left_non_unit() to speed up NMG raytracing.
@
text
@d40 1
a40 2
	double		dist;	/* distance from point to edge */
	point_t		pca;	/* point of closest approach */
d92 1
a92 1
 *			R T _ D I S T _ P T 3 _ L S E G 3 _ J R A
d94 2
a95 2
 *  Find the distance from a point P to a line segment described
 *  by the two endpoints A and B, and the point of closest approach (PCA).
d109 6
a114 7
 *	0	P is within tolerance of lseg AB.  *dist isn't 0: (SPECIAL!!!)
 *		  *dist = parametric dist = |PCA-A| / |B-A|.  pca=computed.
 *	1	P is within tolerance of point A.  *dist = 0, pca=A.
 *	2	P is within tolerance of point B.  *dist = 0, pca=B.
 *	3	PCA is within tolerance of A. *dist = |P-A|, pca=A.
 *	4	PCA is within tolerance of B. *dist = |P-B|, pca=B.
 *	5	P is "above/below" lseg AB.  *dist=|PCA-P|, pca=computed.
d117 2
a119 2
 * XXX For efficiency, a version of this routine that provides the
 * XXX distance squared would be faster.
d122 1
a122 1
bn_dist_pt3_lseg3_jra( dist, pca, a, b, p, tol )
a123 1
point_t		pca;
d132 3
a134 2
	fastf_t	B_A;		/* |B-A| */
	fastf_t	t;		/* distance along ray of projection of P */
d139 1
a139 1
		bu_log("bn_dist_pt3_lseg3_jra() a=(%g,%g,%g) b=(%g,%g,%g)\n\tp=(%g,%g,%g), tol->dist=%g sq=%g\n",
a150 1
		VMOVE( pca, a );
a158 1
		VMOVE( pca, b );
d164 1
a164 1
	B_A = sqrt( MAGSQ(AtoB) );
d166 1
a166 1
	/* compute distance (in actual units) along line to PROJECTION of
d169 2
a170 1
	t = VDOT(PtoA, AtoB) / B_A;
d172 1
a172 1
	if( t <= tol->dist )  {
d174 1
a174 2
		VMOVE( pca, a );
		*dist = sqrt(P_A_sq);
d177 1
a177 1
	if( t < B_A - tol->dist )  {
a181 4
		/* Find PCA */
		param_dist = t / B_A;		/* Range 0..1 */
		VJOIN1(pca, a, param_dist, AtoB);

d183 3
a185 3
		if( (dsq = P_A_sq - t * t ) <= tol->dist_sq )  {
			/* Distance from PCA to lseg is zero, give param instead */
			*dist = param_dist;	/* special! */
d188 3
a190 1
		*dist = sqrt(dsq);
d195 1
a195 2
	VMOVE(pca, b);
	*dist = sqrt(P_B_sq);
d232 1
a232 1
	if (ved->dist < fpi->tol->dist ) {
d238 1
a238 1
	VMOVE(ved->pca, vu->v_p->vg_p->coord);
d261 2
d264 1
d291 8
d300 1
a300 1
	pdv_3line(fd, ei->ved_p->pca, fpi->pt);
d622 1
d653 1
a653 1
		if (ed->dist <= fpi->tol->dist &&
d684 1
a684 1
	ved->status = bn_dist_pt3_lseg3_jra(&ved->dist, ved->pca,
d693 1
a717 1
		ved->dist = 0.0; /* bn_dist_pt3_lseg3_jra() doesn't set this to dist in this case */
d784 1
a784 1
		VSUB2(v_to_pt, fpi->pt, ved->pca);
d904 1
a904 1
			bu_log("\tdist:%g class:%s status:%d pca(%g %g %g)\n\t\tv1(%g %g %g) v2(%g %g %g)\n",
a906 1
			V3ARGS(ei->ved_p->pca),
d931 3
d961 9
d971 1
a971 1
	pdv_3line(fd, ei->ved_p->pca, fpi->pt);
d1019 1
a1019 1
bu_log("dist:%g class:%s status:%d pca(%g %g %g)\n\tv1(%g %g %g) v2(%g %g %g)\n",
a1021 1
				V3ARGS(ei->ved_p->pca),
d1207 1
a1207 1
			if ( !in_or_out_only && ei->ved_p->dist < fpi->tol->dist) {
d1606 1
a1606 1
		if (ei->ved_p->dist < tol->dist) {
@


11.25
log
@Removed include of nmg_rt.h.
@
text
@d774 1
a774 1
		if (nmg_find_eu_leftvec( left, eu ))
@


11.24
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@a29 1
#include "./nmg_rt.h"
@


11.23
log
@Minor Mods for IRIX 6.2
@
text
@d39 1
a39 1
	struct rt_list	l;
d45 1
a45 1
	int		status;	/* return code from rt_dist_pt3_lseg3 */
d55 1
a55 1
	struct rt_list		l;
d65 1
a65 1
	CONST struct rt_tol	*tol;
d67 1
a67 1
	struct rt_list	ve_dh;		/* ve_dist list head */
d78 2
a79 2
	RT_CK_TOL( _fpi->tol ); \
	RT_CK_LIST_HEAD(&_fpi->ve_dh)
d90 1
a90 1
int		nmg_class_pt_fu_except(CONST point_t pt, CONST struct faceuse *fu, CONST struct loopuse *ignore_lu, void (*eu_func)(), void (*vu_func)(), CONST char *priv, CONST int call_on_hits, CONST int in_or_out_only, CONST struct rt_tol *tol);
d119 1
a119 1
 * This routine was formerly called rt_dist_pt_lseg().
d125 1
a125 1
rt_dist_pt3_lseg3_jra( dist, pca, a, b, p, tol )
d129 1
a129 1
CONST struct rt_tol *tol;
d139 1
a139 1
	RT_CK_TOL(tol);
d142 1
a142 1
		rt_log("rt_dist_pt3_lseg3_jra() a=(%g,%g,%g) b=(%g,%g,%g)\n\tp=(%g,%g,%g), tol->dist=%g sq=%g\n",
d224 1
a224 1
	for (RT_LIST_FOR(ved, ve_dist, &fpi->ve_dh)){
d249 2
a250 2
	RT_LIST_MAGIC_SET(&ved->l, NMG_VE_DIST_MAGIC);
	RT_LIST_APPEND(&fpi->ve_dh, &ved->l);
d281 1
a281 1
	rt_log("\toverlay %s\n", name);
d339 1
a339 1
	for( RT_LIST_FOR( eu_test, edgeuse, &lu->down_hd ) )
d372 1
a372 1
CONST struct rt_tol *tol;
d391 1
a391 1
	RT_CK_TOL( tol );
d396 1
a396 1
		rt_log( "nmg_class_pt_euvu( (%g %g %g), eu=x%x )\n", V3ARGS( pt ), eu );
d400 1
a400 1
		rt_log( "nmg_class_pt_euvu() called with eu (x%x) that isn't part of a loop\n", eu );
d408 1
a408 1
	prev_eu = RT_LIST_PPREV_CIRC( edgeuse, &eu->l );
d422 1
a422 1
			rt_log( "nmg_class_pt_euvu: eu x%x is a crack\n", eu );
d425 1
a425 1
		eu_test = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d429 1
a429 1
				eu_test = RT_LIST_PNEXT_CIRC( edgeuse, &eu_test->l );
d438 1
a438 1
				eu_test = RT_LIST_PNEXT_CIRC( edgeuse, &eu_test->l );
d447 1
a447 1
			rt_log( "\tUsing eu x%x instead\n", eu );
d456 1
a456 1
			rt_log( "nmg_class_pt_euvu: prev_eu (x%x) is a crack\n" );
d459 1
a459 1
		eu_test = RT_LIST_PPREV_CIRC( edgeuse, &prev_eu->l );
d463 1
a463 1
				eu_test = RT_LIST_PPREV_CIRC( edgeuse, &eu_test->l );
d472 1
a472 1
				eu_test = RT_LIST_PPREV_CIRC( edgeuse, &eu_test->l );
d481 1
a481 1
			rt_log( "\tUsing prev_eu x%x instead\n", prev_eu );
d487 1
a487 1
		rt_log( "nmg_class_pt_euvu: nmg_find_eu_leftvec() for eu=x%x failed!\n",eu );
d492 1
a492 1
		rt_log( "\tprev_eu = x%x, left = (%g %g %g)\n", prev_eu, V3ARGS( left ) );
d507 1
a507 1
		rt_log( "\tv0=x%x, v1=x%x, v2=x%x\n", v0, v1, v2 );
d516 1
a516 1
		rt_log( "\teu_dir=(%g %g %g), other_eudir=(%x %x %x)\n",V3ARGS( eu_dir ), V3ARGS( other_eudir ) );
d526 1
a526 1
		rt_log( "\txo=%g, yo=%g, qudarant=%d\n", xo,yo,quado );
d532 1
a532 1
		rt_log( "\tpt_dir=( %g %g %g )\n", V3ARGS( pt_dir ) );
d542 1
a542 1
		rt_log( "\txpt=%g, ypt=%g, qudarant=%d\n", xpt,ypt,quadpt );
d561 1
a561 1
		rt_log( "\tNormalized xo,yo=(%g %g), xpt,ypt=( %g %g )\n", xo,yo,xpt,ypt );
d590 1
a590 1
			rt_log( "This can't happen (illegal quadrant %d)\n", quadpt );
d595 1
a595 1
		rt_log( "returning %s\n", nmg_class_name( class ) );
d614 1
a614 1
	struct rt_tol	tmp_tol;
d625 1
a625 1
	RT_CK_TOL(fpi->tol);
d628 1
a628 1
		rt_log("pt (%g %g %g) vs_edge (%g %g %g) (%g %g %g) (eu=x%x)\n",
d635 1
a635 1
	for (RT_LIST_FOR(ed, ve_dist, &fpi->ve_dh)) {
d642 1
a642 1
				rt_log ("pt previously classified WRT Edge\n");
d658 1
a658 1
				rt_log ("vertex (%g %g %g) of edge previously touched\n",
d680 1
a680 1
	ved->status = rt_dist_pt3_lseg3_jra(&ved->dist, ved->pca,
d687 2
a688 2
	RT_LIST_MAGIC_SET(&ved->l, NMG_VE_DIST_MAGIC);
	RT_LIST_APPEND(&fpi->ve_dh, &ved->l);
d692 1
a692 1
		rt_log( "nmg_class_pt_eu: status for eu x%x (%g %g %g)<->(%g %g %g) vs pt (%g %g %g) is %d\n",
d696 1
a696 1
		rt_log( "\tdist = %g\n", ved->dist );
d707 1
a707 1
	RT_LIST_MAGIC_SET(&ei->l, NMG_EDGE_INFO_MAGIC);
d713 1
a713 1
		ved->dist = 0.0; /* rt_dist_pt3_lseg3_jra() doesn't set this to dist in this case */
d732 2
a733 2
		RT_LIST_MAGIC_SET(&ed->l, NMG_VE_DIST_MAGIC);
		RT_LIST_APPEND(&fpi->ve_dh, &ed->l);
d753 2
a754 2
		RT_LIST_MAGIC_SET(&ed->l, NMG_VE_DIST_MAGIC);
		RT_LIST_APPEND(&fpi->ve_dh, &ed->l);
d768 1
a768 1
		next_eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l);
d787 1
a787 1
		rt_log("%s:%d status = %d\n", __FILE__, __LINE__, ved->status);
d794 1
a794 1
		rt_log("pt @@ dist %g from edge classed %s vs edge\n",
d800 1
a800 1
	for (RT_LIST_FOR(ei_p, edge_info, &edge_list->l)) {
d811 1
a811 1
	RT_LIST_INSERT(&ei_p->l, &ei->l);
d824 1
a824 1
struct rt_list *near;
d831 2
a832 2
	RT_CK_LIST_HEAD(&edge_list->l);
	RT_CK_LIST_HEAD(near);
d835 2
a836 2
	ei = RT_LIST_FIRST( edge_info, &edge_list->l);
	while( RT_LIST_NOT_HEAD( &ei->l, &edge_list->l)) {
d838 2
a839 2
		ei_p = RT_LIST_FIRST( edge_info, &edge_list->l);
		while( RT_LIST_NOT_HEAD( &ei_p->l, &edge_list->l)) {
d850 2
a851 2
					rt_log("tossing edgeuse pair:\n");
					rt_log("(%g %g %g) -> (%g %g %g)\n",
d854 1
a854 1
					rt_log("(%g %g %g) -> (%g %g %g)\n",
d860 2
a861 2
			    	ei_p = RT_LIST_PLAST(edge_info, &ei_p->l);
				RT_LIST_DEQUEUE(&tmp->l);
d864 2
a865 2
			    	ei = RT_LIST_PLAST(edge_info, &ei->l);
				RT_LIST_DEQUEUE(&tmp->l);
d869 1
a869 1
			ei_p = RT_LIST_PNEXT( edge_info, &ei_p->l );
d871 1
a871 1
		ei = RT_LIST_PNEXT( edge_info, &ei->l );
d874 1
a874 1
	if( RT_LIST_IS_EMPTY( &edge_list->l ) )
d877 1
a877 1
	ei = RT_LIST_FIRST(edge_info, &edge_list->l);
d883 1
a883 1
	for (RT_LIST_FOR(ei, edge_info, &edge_list->l)) {
d887 3
a889 3
			ei_p = RT_LIST_PLAST(edge_info, &ei->l);
			RT_LIST_DEQUEUE(&ei->l);
			RT_LIST_APPEND(near, &ei->l);
d895 3
a897 3
		rt_log("dist %g near list\n", dist);
		for (RT_LIST_FOR(ei, edge_info, near)) {
			rt_log("\t(%g %g %g) -> (%g %g %g)\n",
d900 1
a900 1
			rt_log("\tdist:%g class:%s status:%d pca(%g %g %g)\n\t\tv1(%g %g %g) v2(%g %g %g)\n",
d906 1
a906 1
			rt_log( "\tei->ved_p->magic_p=x%x, ei->eu_p->vu_p=x%x, ei->eu_p->eumate_p->vu_p=x%x\n",
d940 1
a940 1
	rt_log("\toverlay %s\n", name);
d998 1
a998 1
	struct rt_list	near;
d1002 3
a1004 3
		rt_log("compute_loop_class()\n");
		for (RT_LIST_FOR(ei, edge_info, &edge_list->l)) {
rt_log("dist:%g class:%s status:%d pca(%g %g %g)\n\tv1(%g %g %g) v2(%g %g %g)\n",
d1013 2
a1014 2
	RT_CK_LIST_HEAD(&edge_list->l);
	RT_LIST_INIT(&near);
d1019 1
a1019 1
	while (RT_LIST_IS_EMPTY(&near) && RT_LIST_NON_EMPTY(&edge_list->l)) {
d1023 1
a1023 1
	if (RT_LIST_IS_EMPTY(&near)) {
d1034 1
a1034 1
			rt_log("list was empty, so class is %s\n", 
d1044 1
a1044 1
	for (RT_LIST_FOR(ei, edge_info, &near)) {
d1060 1
a1060 1
				rt_log("found status 5 edge, loop class is %s\n", 
d1067 1
a1067 1
			rt_log("%s:%d status = %d\n",
d1077 1
a1077 1
		rt_log("%s:%d ei_vdot_max not set\n",
d1086 2
a1087 2
	while (RT_LIST_WHILE(ei, edge_info, &near)) {
		RT_LIST_DEQUEUE( &ei->l );
d1092 1
a1092 1
		rt_log("compute_loop_class() returns %s\n", 
d1154 1
a1154 1
			rt_log("nmg_class_pt_lu( pt(%g %g %g) outside loop RPP\n",
d1156 1
a1156 1
			rt_log( "   lu RPP: ( %g %g %g ) <-> ( %g %g %g )\n",
d1169 1
a1169 1
	if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
d1183 1
a1183 1
				rt_log("nmg_class_pt_lu() ignoring OT_OPPOSITE crack loop\n");
d1187 1
a1187 1
		RT_LIST_INIT(&edge_list.l);
d1189 1
a1189 1
		for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d1210 1
a1210 1
				rt_log("loop class already known (pt must touch edge)\n");
d1214 2
a1215 2
		while ( RT_LIST_WHILE(ei, edge_info, &edge_list.l) ) {
			RT_LIST_DEQUEUE( &ei->l );
d1218 1
a1218 1
	} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
d1222 1
a1222 1
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d1241 1
a1241 1
			rt_log("nmg_class_pt_lu() hit %s loop at vu=x%x\n",
d1247 1
a1247 1
		rt_log("%s:%d bad child of loopuse\n", __FILE__, __LINE__);
d1254 1
a1254 1
		rt_log("nmg_class_pt_lu() pt classed %s vs loop\n", nmg_class_name(lu_class));
d1277 1
a1277 1
	rt_log("overlay pt_fu_parity_error.pl\n");
d1350 1
a1350 1
CONST struct rt_tol     *tol;
d1365 1
a1365 1
		rt_log("nmg_class_pt_fu_except( pt=(%g %g %g), fu=x%x )\n", V3ARGS(pt), fu);
d1373 1
a1373 1
	RT_CK_TOL(tol);
d1378 1
a1378 1
		rt_log("nmg_class_pt_fu_except() ERROR, point (%g,%g,%g)\nnot on face %g %g %g %g,\ndist=%g\n",
d1387 1
a1387 1
			rt_log("nmg_class_pt_fu_except( (%g %g %g) ouside face RPP\n",
d1399 1
a1399 1
	RT_LIST_INIT(&fpi.ve_dh);
d1407 1
a1407 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
d1417 1
a1417 1
			rt_log("loop %s says pt is %s\n",
d1422 1
a1422 1
			rt_log("nmg_class_pt_fu_except() lu_class=%s %d\n",
d1440 1
a1440 1
		rt_log("loops ot_same_in:%d ot_opposite_out:%d\n",
d1442 1
a1442 1
		rt_log("loops in/onS/onA/out ot_same=%d/%d/%d/%d ot_opp=%d/%d/%d/%d\n",
d1455 1
a1455 1
		rt_log("loops in/onS/onA/out ot_same=%d/%d/%d/%d ot_opp=%d/%d/%d/%d\n",
d1458 1
a1458 1
		rt_log("nmg_class_pt_fu_except(%g %g %g)\nParity error @@ %s:%d ot_same_in:%d ot_opposite_out:%d\n",
d1461 1
a1461 1
		rt_log( "fu=x%x\n",  fu );
d1469 1
a1469 1
		for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
d1483 2
a1484 2
	while (RT_LIST_WHILE(ved_p, ve_dist, &fpi.ve_dh)) {
		RT_LIST_DEQUEUE( &ved_p->l );
d1490 1
a1490 1
		rt_log("nmg_class_pt_fu_except() returns %s\n",
d1511 1
a1511 1
struct rt_tol	*tol;
d1522 1
a1522 1
		rt_log("nmg_class_pt_lu_except( (%g %g %g) ", V3ARGS(pt), e_p);
d1524 1
a1524 1
			rt_log(" e_p=(%g %g %g) <-> (%g %g %g) )\n",
d1528 1
a1528 1
			rt_log(" e_p=(NULL) )\n");
d1540 1
a1540 1
		rt_log("nmg_class_pt_lu_except() ERROR, point (%g,%g,%g)\nnot on face %g %g %g %g,\ndist=%g\n",
d1549 1
a1549 1
			rt_log("nmg_class_pt_lu_except( pt(%g %g %g) outside loop RPP\n",
d1555 1
a1555 1
			rt_log("What kind of loop is this anyway? %s?\n",
d1561 2
a1562 2
	if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
		rt_log("%s:%d Improper use of nmg_class_pt_lu_except(pt(%g %g %g), vu)\n",
d1567 1
a1567 1
	RT_LIST_INIT(&edge_list.l);
d1571 1
a1571 1
	RT_LIST_INIT(&fpi.ve_dh);
d1579 1
a1579 1
	for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d1582 1
a1582 1
				rt_log("skipping edguse (%g %g %g) -> (%g %g %g) on \"except\" edge\n",
d1600 1
a1600 1
		rt_log("loop class already known (pt must touch edge)\n");
d1603 2
a1604 2
	while ( RT_LIST_WHILE(ei, edge_info, &edge_list.l) ) {
		RT_LIST_DEQUEUE( &ei->l );
d1608 2
a1609 2
	while (RT_LIST_WHILE(ved_p, ve_dist, &fpi.ve_dh)) {
		RT_LIST_DEQUEUE( &ved_p->l );
d1614 1
a1614 1
		rt_log("nmg_class_pt_lu_except() returns %s\n",
@


11.22
log
@Added check for empty list in make_near_list().
Also addeda couple more debug logs.
@
text
@a226 1
			ved->dist;
a1054 1
			break;
a1065 1
			break;
@


11.21
log
@Added "in_or_out_only" arg to nmg_class_pt_fu_except(), nmg_class_pt_lu(),
and nmg_class_pt_eu().
@
text
@d875 3
d901 1
a901 1
rt_log("\tdist:%g class:%s status:%d pca(%g %g %g)\n\t\tv1(%g %g %g) v2(%g %g %g)\n",
d907 2
a908 2
rt_log( "\tei->ved_p->magic_p=x%x, ei->eu_p->vu_p=x%x, ei->eu_p->eumate_p->vu_p=x%x\n",
		ei->ved_p->magic_p, ei->eu_p->vu_p, ei->eu_p->eumate_p->vu_p );	
a910 2


@


11.20
log
@Added nmg_eu_is_part_of_crack(), modified nmg_class_pt_euvu() to handle cracks.
Fixed bug in nmg_class_pt_eu() (was calling fpi->vu_func for wrong VU).
@
text
@d87 1
a87 1
static struct edge_info *nmg_class_pt_eu(struct fpi *fpi, struct edgeuse *eu, struct edge_info *edge_list);
d89 2
a90 2
static int	nmg_class_pt_lu(struct loopuse *lu, struct fpi *fpi);
int		nmg_class_pt_fu_except(CONST point_t pt, CONST struct faceuse *fu, CONST struct loopuse *ignore_lu, void (*eu_func)(), void (*vu_func)(), CONST char *priv, CONST int call_on_hits, CONST struct rt_tol *tol);
d609 1
a609 1
nmg_class_pt_eu(fpi, eu, edge_list)
d613 1
d615 1
d672 7
d685 1
a685 1
					fpi->tol);
d1138 1
a1138 1
nmg_class_pt_lu(lu, fpi)
d1141 1
d1192 1
a1192 1
			ei = nmg_class_pt_eu(fpi, eu, &edge_list);
d1195 1
a1195 1
			if (ei->ved_p->dist < fpi->tol->dist) {
d1318 1
a1318 1
 * if any loop has pt classified as "ON" return "ON"
d1334 4
d1343 1
a1343 1
	eu_func, vu_func, priv, call_on_hits, tol)
d1351 1
d1417 1
a1417 1
		lu_class = nmg_class_pt_lu(lu, &fpi);
d1479 1
a1479 1
			lu_class = nmg_class_pt_lu(lu, &fpi);
d1591 1
a1591 1
		ei = nmg_class_pt_eu(&fpi, eu, &edge_list);
@


11.19
log
@Fixed typo in nmg_class_pt_lu_except() and added some debug logging.
@
text
@d324 29
d370 1
a370 1
nmg_class_pt_euvu( pt, eu, tol )
d372 1
a372 1
CONST struct edgeuse *eu;
d375 1
d377 1
d388 2
d391 1
a391 1
	NMG_CK_EDGEUSE( eu );
d394 2
d399 86
a490 1
	prev_eu = RT_LIST_PPREV_CIRC( edgeuse, &eu->l );
d682 9
d750 1
a750 1
			fpi->vu_func(eu->vu_p, fpi->pt, fpi->priv);
d756 2
d762 2
@


11.18
log
@Added rt_dist_pt3_lseg3_jra() (a slight variation of the original).
Added nmg_class_pt_euvu() as a support routine for nmg_class_pt_eu().
Modified nmg_class_pt_eu() to use nmg_class_pt_euvu().
Modified make_near_list() to toss opposing EU pairs before selecting nearest EU.
@
text
@d507 1
a507 1
		rt_log("pt (%g %g %g) vs_edge (%g %g %g) (%g %g %g)\n",
d510 1
a510 1
			V3ARGS(eu->eumate_p->vu_p->v_p->vg_p->coord));
d1407 1
a1407 1
		else if (lu->orientation == OT_SAME) return NMG_CLASS_AinB;
@


11.17
log
@compute_loop_class() does not work properly on crack loops!
Be careful not to give it any.
@
text
@d92 116
d304 177
d494 1
d512 1
a512 1

d545 1
d552 1
a552 1
	ved->status = rt_dist_pt3_lseg3(&ved->dist, ved->pca,
d576 1
a576 1
		ved->dist = 0.0; /* rt_dist_pt3_lseg3() doesn't set this to dist in this case */
d625 2
a626 4
	case 3: /* PCA of pt on line is "before" ved->v1 of segment */
		/* fallthrough */
	case 4: /* PCA of pt on line is "before" ved->v2 of segment */
		ei->class = NMG_CLASS_AoutB;
d628 4
d687 1
d693 40
d762 2
a767 33
	/* toss opposing pairs of uses of the same edge from the list */
	for (RT_LIST_FOR(ei, edge_info, near)) {
		NMG_CK_EI(ei);
		for (RT_LIST_FOR(ei_p, edge_info, near)) {
			NMG_CK_EI(ei_p);
			NMG_CK_VED(ei_p->ved_p);

			/* if we've found an opposing use of the same
			 *    edge toss the pair of them
			 */
			if (ei_p->ved_p->magic_p == ei->ved_p->magic_p &&
			    ei_p->eu_p->vu_p != ei->eu_p->vu_p &&
			    ei_p->eu_p->vu_p == ei->eu_p->eumate_p->vu_p ) {
				if (rt_g.NMG_debug & DEBUG_PT_FU ) {
					rt_log("tossing edgeuse pair:\n");
					rt_log("(%g %g %g) -> (%g %g %g)\n",
						V3ARGS(ei->eu_p->vu_p->v_p->vg_p->coord),
						V3ARGS(ei->eu_p->eumate_p->vu_p->v_p->vg_p->coord));
					rt_log("(%g %g %g) -> (%g %g %g)\n",
						V3ARGS(ei_p->eu_p->vu_p->v_p->vg_p->coord),
						V3ARGS(ei_p->eu_p->eumate_p->vu_p->v_p->vg_p->coord));
				}

				RT_LIST_DEQUEUE(&ei_p->l);
				rt_free((char *)ei_p, "edge info struct");
				ei_p = RT_LIST_PLAST(edge_info, &ei->l);
				RT_LIST_DEQUEUE(&ei->l);
				rt_free((char *)ei, "edge info struct");
				ei = ei_p;
			    	break;
			}
		}
	}
a914 5
			if (ei_vdot_max == (struct edge_info *)NULL) {
				VSUB2(v_pt, fpi->pt, ei->ved_p->v1->vg_p->coord);
				ei_vdot_max = ei;
			}
			/* fallthrough */
d916 1
a916 22
			if (ei_vdot_max == (struct edge_info *)NULL) {
				VSUB2(v_pt, fpi->pt, ei->ved_p->v2->vg_p->coord);
				ei_vdot_max = ei;
			}

			nmg_find_eu_leftvec( left, ei->eu_p );

			if (fabs(vdot_val=VDOT(v_pt, left)) > fabs(vdot_max)){
				vdot_max = vdot_val;
				ei_vdot_max = ei;
				if (vdot_max > 0.0)
					lu_class = NMG_CLASS_AinB;
				else /*  vdot_max < 0.0 */
					lu_class = NMG_CLASS_AoutB;
			}

			break;
		case 5:
			/* if there is an edge where the PCA is not 
			 * at a vertex, we can just classify the point with
			 * this edge.
			 */
d1219 1
a1219 1
		rt_log("nmg_class_pt_fu_except( (%g %g %g) )\n", V3ARGS(pt));
d1315 2
d1447 1
a1447 1
			lu_class = NMG_CLASS_AinB;
@


11.16
log
@Added improved diagnostics.
Still hunting the bug in Bradley region "dwr8".
@
text
@d531 2
d751 1
d753 12
d777 13
a789 4
		if (lu_class == NMG_CLASS_Unknown)
			lu_class = compute_loop_class(fpi, lu, &edge_list);
		else if (rt_g.NMG_debug & DEBUG_PT_FU )
			rt_log("loop class already known (pt must touch edge)\n");
d830 1
d1037 14
d1075 1
@


11.15
log
@nmg_class_pt_lu() now returns NMG_CLASS_Unknown for LU of a single VU with OT_UNSPEC orientation.
@
text
@d904 2
d910 1
d915 2
d941 3
d959 4
d969 16
a984 7
		if (lu->orientation == OT_OPPOSITE &&
		    lu_class == NMG_CLASS_AoutB )
			ot_opposite_out++;
		else if (lu->orientation == OT_SAME &&
		    (lu_class == NMG_CLASS_AinB ||
		     lu_class == NMG_CLASS_AonBshared))
			ot_same_in++;
d987 1
a987 1
	if (rt_g.NMG_debug & DEBUG_PT_FU )
d990 4
d995 5
a999 2
	if (ot_same_in == ot_opposite_out) fu_class = NMG_CLASS_AoutB;
	else if (ot_same_in > ot_opposite_out) {
d1003 3
@


11.14
log
@Fixed bug in nmg_class_pt_lu(). Was classifying any pt outside of RPP
as NMG_CLASS_AoutB regardless of lu->orientation.
@
text
@d740 2
d790 3
@


11.13
log
@Needed to set ved->dist = 0.0 for rt_dist_pt3_lseg3() return of 0 in nmg_pt_eu_except().
@
text
@d729 1
d732 3
d738 1
a738 1
		else if (lu->orientation == OT_SAME)
@


11.12
log
@SUN doesn't like labels and variables with same name ("found" in nmg_class_pt_eu() ).
Plus some changes Lee made.
@
text
@d281 1
@


11.11
log
@added nmg_class_pt_lu_except() for Mike's radial edgeuse sorter.
@
text
@d207 1
a207 1
	int		found = 0;
d230 1
a230 1
			found = 1;
d247 1
a247 1
			found = 1;
d284 1
a284 1
		     (fpi->hits == NMG_FPI_PERGEOM && !found) ) ) {
d304 1
a304 1
		     (fpi->hits == NMG_FPI_PERGEOM && !found) ) ) {
d324 1
a324 1
		     (fpi->hits == NMG_FPI_PERGEOM && !found) ) ) {
d357 1
a357 1
		pl_pt_e(fpi, ei);
d510 1
d803 48
d968 3
d1011 10
d1070 8
a1077 1
		if (eu->e_p == e_p) continue;
d1102 4
@


11.10
log
@Improved error messages in nmg_class_pt_lu().
Added handling of OT_BOOLPLACE self-loops.
@
text
@d723 13
d850 3
d866 12
d893 4
d933 102
@


11.9
log
@Set magic number for ve_dist structures.
@
text
@d755 1
d759 1
d767 1
d771 3
a773 1
			rt_bomb("Loop orientation error\n");
d778 1
a778 1
		rt_bomb("crash and burn\n");
d783 1
a783 1
		rt_log("pt classed %s vs loop\n", nmg_class_name(lu_class));
@


11.8
log
@Added real parameter to rt_bomb().
@
text
@d299 1
d320 1
@


11.7
log
@Mods made by Lee Butler:
1)  Added pl_pt_lu().
2)  Changed fpi.pt from pointer to point, to a copy of the point.
@
text
@d805 3
d880 1
a880 1
		rt_bomb("");
@


11.6
log
@CONST for first arg to nmg_class_pt_fu_except()
@
text
@d69 1
a69 1
	pointp_t	pt;		/* pt in plane of face to classify */
d179 1
a179 1
	nmg_pl_fu(fd, fpi->fu_p, b, 255, 255, 255);
d464 12
d477 4
d482 5
d488 3
d492 10
d503 20
d597 2
d635 2
d646 8
a653 1

d843 1
a843 1
	fpi.pt = pt;
@


11.5
log
@Looks like the new algorithm is working now.
@
text
@d90 1
a90 1
int		nmg_class_pt_fu_except(point_t pt, CONST struct faceuse *fu, CONST struct loopuse *ignore_lu, void (*eu_func)(), void (*vu_func)(), CONST char *priv, CONST int call_on_hits, CONST struct rt_tol *tol);
d744 1
a744 1
point_t pt;
@


11.4
log
@checkpoint
@
text
@d805 3
a807 1
	else if (ot_same_in - 1 != ot_opposite_out) {
d809 3
a811 2
		rt_log("nmg_class_pt_fu_except(%g %g %g) Parity error @@ %s:%d\n",
			V3ARGS(pt), __FILE__, __LINE__);
d813 1
a813 2
	} else 
		fu_class = NMG_CLASS_AinB;
@


11.3
log
@checkpoint
@
text
@d141 1
a141 1
		fpi->vu_func(vu, fpi);
d207 1
d227 1
a227 1
				rt_log ("Edge previously classified\n");
d230 1
d240 6
a245 2
			if (rt_g.NMG_debug & DEBUG_PT_FU)
				rt_log ("vertex of edge previously touched\n");
d247 1
d258 4
a261 4
		eu->vu_p->v_p->vg_p->coord,
		eu->eumate_p->vu_p->v_p->vg_p->coord,
		fpi->pt,
		fpi->tol);
a266 6
	/* call the user function for a topo/geometry touch */
	if (fpi->eu_func &&
	    fpi->hits == NMG_FPI_PERGEOM &&
	    ved->dist < fpi->tol->dist )
		fpi->eu_func(eu, fpi->pt, fpi->priv);

a267 5
	if (fpi->eu_func &&
	    fpi->hits == NMG_FPI_PERUSE &&
	    ved->dist < fpi->tol->dist )
		fpi->eu_func(eu, fpi->pt, fpi->priv);

d281 6
a286 1
		ei->class = NMG_CLASS_AinB;
d289 1
a289 1
		ei->class = NMG_CLASS_AinB;
d296 1
a296 1
		ed->status = 1;
d300 7
d309 1
a309 1
		ei->class = NMG_CLASS_AinB;
d316 1
a316 1
		ed->status = 2;
d320 5
d326 1
d346 2
d374 93
d483 6
a488 1
	double dist;
d490 2
a491 2
	int lu_class = NMG_CLASS_Unknown;
	
d507 5
a511 72


	while (RT_LIST_NON_EMPTY(&edge_list->l)) {
		ei = RT_LIST_FIRST(edge_info, &edge_list->l);
		NMG_CK_EI(ei);
		NMG_CK_VED(ei->ved_p);
		dist = ei->ved_p->dist;
	
		/* create "near" list with all ei's at this dist */
		for (RT_LIST_FOR(ei, edge_info, &edge_list->l)) {
			NMG_CK_EI(ei);
			NMG_CK_VED(ei->ved_p);
			if (ei->ved_p->dist == dist) {
				ei_p = RT_LIST_PLAST(edge_info, &ei->l);
				RT_LIST_DEQUEUE(&ei->l);
				RT_LIST_APPEND(&near, &ei->l);
				ei = ei_p;
			}
		}

		if (rt_g.NMG_debug & DEBUG_PT_FU ) {
			rt_log("dist %g near list\n", dist);
			for (RT_LIST_FOR(ei, edge_info, &near)) {
				rt_log("(%g %g %g) -> (%g %g %g)\n",
					V3ARGS(ei->eu_p->vu_p->v_p->vg_p->coord),
					V3ARGS(ei->eu_p->eumate_p->vu_p->v_p->vg_p->coord));
rt_log("dist:%g class:%s status:%d pca(%g %g %g)\n\tv1(%g %g %g) v2(%g %g %g)\n",
				ei->ved_p->dist, nmg_class_name(ei->class),
				ei->ved_p->status,
				V3ARGS(ei->ved_p->pca),
				V3ARGS(ei->ved_p->v1->vg_p->coord),
				V3ARGS(ei->ved_p->v2->vg_p->coord));
			}
		}


		/* toss opposing pairs of uses of the same edge from the list */
		for (RT_LIST_FOR(ei, edge_info, &near)) {
			NMG_CK_EI(ei);
			for (RT_LIST_FOR(ei_p, edge_info, &near)) {
				NMG_CK_EI(ei_p);
				NMG_CK_VED(ei_p->ved_p);

				/* if we've found an opposing use of the same
				 *    edge toss the pair of them
				 */
				if (ei_p->ved_p->magic_p == ei->ved_p->magic_p &&
				    ei_p->eu_p->vu_p != ei->eu_p->vu_p &&
				    ei_p->eu_p->vu_p == ei->eu_p->eumate_p->vu_p ) {

					if (rt_g.NMG_debug & DEBUG_PT_FU ) {
						rt_log("tossing edgeuse pair:\n");
						rt_log("(%g %g %g) -> (%g %g %g)\n",
							V3ARGS(ei->eu_p->vu_p->v_p->vg_p->coord),
							V3ARGS(ei->eu_p->eumate_p->vu_p->v_p->vg_p->coord));
						rt_log("(%g %g %g) -> (%g %g %g)\n",
							V3ARGS(ei_p->eu_p->vu_p->v_p->vg_p->coord),
							V3ARGS(ei_p->eu_p->eumate_p->vu_p->v_p->vg_p->coord));
					}

					RT_LIST_DEQUEUE(&ei_p->l);
					rt_free((char *)ei_p, "edge info struct");
					ei_p = RT_LIST_PLAST(edge_info, &ei->l);
					RT_LIST_DEQUEUE(&ei->l);
					rt_free((char *)ei, "edge info struct");
					ei = ei_p;
				    	break;
				}
			}
		}
		
		if (RT_LIST_NON_EMPTY(&near)) break;
d532 2
a533 7
	if ((ei=RT_LIST_PNEXT(edge_info, &near)) == RT_LIST_PLAST(edge_info, &near)){
		/* just one element */
		if (rt_g.NMG_debug & DEBUG_PT_FU )
			rt_log("just one element\n");
		lu_class = ei->class;
		goto departure;
	}
d538 36
a573 4
		/* if there is an edge where the PCA is not at a vertex,
		 * we can just classify the point with this edge
		 */
		if (ei->ved_p->status == 5) {
d580 6
d589 1
a589 9
	for (RT_LIST_FOR(ei, edge_info, &near)) {
		NMG_CK_EI(ei);
		NMG_CK_VED(ei->ved_p);
		/* find the edgeuse which shares a vertex with the first
		 * one on the list with the max VDOT with the vertex->pt
		 * vector
		 */
		 /* XXX */
	}
a590 1
departure:
d736 4
d795 2
a796 1
		    lu_class == NMG_CLASS_AinB )
@


11.2
log
@checkpoint
@
text
@a21 4
#ifndef lint
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pt_fu.c,v 11.1 95/01/04 09:58:11 mike Rel4_4 Locker: butler $ (ARL)";
#endif

d33 109
d143 2
d147 3
a149 3
nmg_class_pt_eu(fpi, eu)
struct fu_pt_info	*fpi;
struct edgeuse	*eu;
d151 4
a154 4
	fastf_t	dist = -1.0;
	point_t	pca;
	int	status;
	struct edgeuse *eunext;
d156 9
a164 15
	NMG_CK_FPI(fpi);
	RT_CK_TOL(fpi->tol);
	NMG_CK_EDGEUSE(eu);
	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);

	eunext = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);	
	NMG_CK_VERTEXUSE(eunext->vu_p);
	NMG_CK_VERTEX(eunext->vu_p->v_p);
	NMG_CK_VERTEX_G(eunext->vu_p->v_p->vg_p);
d166 3
a168 4
	if (rt_g.NMG_debug & DEBUG_PT_FU )
		rt_log("nmg_class_pt_eu( (%g %g %g)->(%g %g %g) )\n",
			V3ARGS(eu->vu_p->v_p->vg_p->coord),
			V3ARGS(eunext->vu_p->v_p->vg_p->coord));
d170 10
a179 10
	/* if this edgeuse's vertexuse is on a previously processed & touched
	 * vertex:
	 *	if the user wants to get called for each use,
	 *		make the call for this use.
	 *	mark this edgeuse as processed.
	 *	return
	 */
	if (NMG_INDEX_GET(fpi->tbl, eu->vu_p->v_p) == NMG_FPI_TOUCHED) {
		if (fpi->vu_func && fpi->allhits == NMG_FPI_PERUSE)
			fpi->vu_func(eu->vu_p, fpi);
d181 2
a182 3
		NMG_INDEX_ASSIGN(fpi->tbl, eu->e_p, NMG_FPI_TOUCHED);
		if (rt_g.NMG_debug & DEBUG_PT_FU )
			rt_log("\teu->vu->v previously touched\n");
d184 3
a186 2
		return;
	}
d188 19
a206 10
	/* if the next edgeuse's vertexuse is on a previously 
	 * processed & touched vertex:
	 *	if the user wants to get called for each use,
	 *		make the call for this use.
	 *	mark this edgeuse as processed.
	 *	return
	 */
	if (NMG_INDEX_GET(fpi->tbl, eunext->vu_p->v_p) == NMG_FPI_TOUCHED) {
		if (fpi->vu_func && fpi->allhits == NMG_FPI_PERUSE)
			fpi->vu_func(eunext->vu_p, fpi);
d208 2
a209 3
		NMG_INDEX_ASSIGN(fpi->tbl, eu->e_p, NMG_FPI_TOUCHED);
		if (rt_g.NMG_debug & DEBUG_PT_FU )
			rt_log("\teunext->vu->v previously touched\n");
d211 5
a215 1
		return;
d218 4
d223 1
a223 13
	/* The verticies at the ends of this edge were missed or hit
	 * previously processed.
	 */
	switch (NMG_INDEX_GET(fpi->tbl, eu->e_p)) {
	case NMG_FPI_TOUCHED:
		/* The edgeuse has been pre-determined to be touching.
		 * This was a touch on the edge span.
		 *
		 * If the user wants to get called for each use, make the
		 * call for this edgeuse.
		 */
		if (rt_g.NMG_debug & DEBUG_PT_FU )
			rt_log ("\teu previously hit\n");
d225 2
a226 2
		if (fpi->eu_func && fpi->allhits == NMG_FPI_PERUSE)
			fpi->eu_func(eu, fpi);
d228 3
a230 4
		return;
	case NMG_FPI_MISSED:
		if (rt_g.NMG_debug & DEBUG_PT_FU )
			rt_log ("\teu previously missed\n");
d232 11
a242 1
		return;
d245 2
a246 3

	/* The edgeuse was not previously processed, 
	 * so it's time to do it now.
d248 3
a250 6
	if (rt_g.NMG_debug & DEBUG_PT_FU )
		rt_log ("\tprocessing eu (%g %g %g) -> (%g %g %g)\n",
			V3ARGS(eu->vu_p->v_p->vg_p->coord),
			V3ARGS(eunext->vu_p->v_p->vg_p->coord));

	status = rt_dist_pt3_lseg3(&dist, pca,
d255 16
d273 19
a291 7
	switch (status) {
	case 0: /* pt is on the edge(use)
		 * store edgeuse ptr in closest,
		 * set dist_in_plane = 0.0
		 *
		 * dist is the parametric distance along the edge where
		 * the PCA occurrs!
d293 4
d298 1
a298 35
		fpi->dist_in_plane = 0.0;
		VMOVE(fpi->pca, pca);
		fpi->closest = &eu->l.magic;
		fpi->PCA_loc = NMG_PCA_EDGE;
		fpi->pt_class = NMG_CLASS_AonBshared;
		if (rt_g.NMG_debug & DEBUG_PT_FU )
			rt_log(	"\tplane_pt on eu, (new dist: %g)\n",
				fpi->dist_in_plane);
		if (fpi->eu_func)
			fpi->eu_func(eu, fpi);
		NMG_INDEX_ASSIGN(fpi->tbl, eu->vu_p->v_p, NMG_FPI_MISSED);
		NMG_INDEX_ASSIGN(fpi->tbl, eu->e_p, NMG_FPI_TOUCHED);
		break;
	case 1:	/* within tolerance of endpoint at eu->vu_p.
		   store vertexuse ptr in closest,
		   set dist_in_plane = 0.0 */
		if (dist < fpi->dist_in_plane) {
			fpi->dist_in_plane = 0.0;
			VMOVE(fpi->pca, pca);
			fpi->closest = &eu->vu_p->l.magic;
			fpi->PCA_loc = NMG_PCA_EDGE_VERTEX;
			fpi->pt_class = NMG_CLASS_AonBshared;
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				rt_log("\tplane_pt on vu (new dist %g)\n",
					fpi->dist_in_plane);
		} else {
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				rt_log("\tplane_pt on vu(dist %g) keeping old dist %g)\n",
					dist, fpi->dist_in_plane);
		}
		if (fpi->vu_func)
			fpi->vu_func(eu->vu_p, fpi);

		NMG_INDEX_ASSIGN(fpi->tbl, eu->vu_p->v_p, NMG_FPI_TOUCHED);
		NMG_INDEX_ASSIGN(fpi->tbl, eu->e_p, NMG_FPI_TOUCHED);
d300 10
a309 23
	case 2:	/* within tolerance of endpoint at eu->eumate_p
		   store vertexuse ptr (eu->next) in closest,
		   set dist_in_plane = 0.0 */
		if (dist < fpi->dist_in_plane) {
			fpi->dist_in_plane = 0.0;
			VMOVE(fpi->pca, pca);
			fpi->closest = &eunext->vu_p->l.magic;
			fpi->PCA_loc = NMG_PCA_EDGE_VERTEX;
			fpi->pt_class = NMG_CLASS_AonBshared;
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				rt_log("\tplane_pt on next(eu)->vu (new dist %g)\n",
					fpi->dist_in_plane);
		} else {
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				rt_log("\tplane_pt on next(eu)->vu(dist %g) keeping old dist %g)\n",
					dist, fpi->dist_in_plane);
		}
		if (fpi->vu_func)
			fpi->vu_func(eunext->vu_p, fpi);

		NMG_INDEX_ASSIGN(fpi->tbl, eunext->vu_p->v_p, NMG_FPI_TOUCHED);
		NMG_INDEX_ASSIGN(fpi->tbl, eunext->e_p, NMG_FPI_TOUCHED);
		NMG_INDEX_ASSIGN(fpi->tbl, eu->e_p, NMG_FPI_TOUCHED);
d311 1
d313 4
a316 16
	case 3: /* PCA of pt on line is "before" eu->vu_p of seg */
		if (dist < fpi->dist_in_plane) {
			fpi->dist_in_plane = dist;
			VMOVE(fpi->pca, pca);
			fpi->closest = &eu->vu_p->l.magic;
			fpi->PCA_loc = NMG_PCA_EDGE_VERTEX;

			if (rt_g.NMG_debug & DEBUG_PT_FU )
				rt_log("\tvu of eu is new \"closest to plane_pt\" (new dist %g)\n",
					fpi->dist_in_plane);
		} else {
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				rt_log("\tvu of eu is PCA (dist %g).  keeping old dist %g\n",
					dist, fpi->dist_in_plane);
		}
		NMG_INDEX_ASSIGN(fpi->tbl, eu->e_p, NMG_FPI_MISSED);
d318 6
a323 22
	case 4: /* PCA of pt on line is "after" eu->eumate_p->vu_p of seg */
		if (dist < fpi->dist_in_plane) {
			eu = RT_LIST_PNEXT_CIRC(edgeuse, &(eu->l));
			fpi->dist_in_plane = dist;
			VMOVE(fpi->pca, pca);
			fpi->closest = &eu->vu_p->l.magic;
			fpi->PCA_loc = NMG_PCA_EDGE_VERTEX;
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				rt_log("\tvu of next(eu) is new \"closest to plane_pt\" (new dist %g)\n",
					fpi->dist_in_plane);
		} else {
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				rt_log("\tvu of next(eu) is PCA (dist %g).  keeping old dist %g\n",
					dist, fpi->dist_in_plane);
		}
		NMG_INDEX_ASSIGN(fpi->tbl, eu->vu_p->v_p, NMG_FPI_MISSED);
		NMG_INDEX_ASSIGN(fpi->tbl, eunext->vu_p->v_p, NMG_FPI_MISSED);
		NMG_INDEX_ASSIGN(fpi->tbl, eu->e_p, NMG_FPI_MISSED);
		break;
	case 5: /* PCA is along length of edge, but point is NOT on edge.
		 *  if edge is closer to plane_pt than any previous item,
		 *  store edgeuse ptr in closest and set dist_in_plane
d325 5
a329 16
		if (dist < fpi->dist_in_plane) {
			fpi->dist_in_plane = dist;
			VMOVE(fpi->pca, pca);
			fpi->closest = &eu->l.magic;
			fpi->PCA_loc = NMG_PCA_EDGE;
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				rt_log("\teu is new \"closest to plane_pt\" (new dist %g)\n",
					fpi->dist_in_plane);
		} else {
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				rt_log("\teu dist is %g, keeping old dist %g)\n",
					dist, fpi->dist_in_plane);
		}
		NMG_INDEX_ASSIGN(fpi->tbl, eu->vu_p->v_p, NMG_FPI_MISSED);
		NMG_INDEX_ASSIGN(fpi->tbl, eunext->vu_p->v_p, NMG_FPI_MISSED);
		NMG_INDEX_ASSIGN(fpi->tbl, eu->e_p, NMG_FPI_MISSED);
d331 1
a331 4
	default :
		rt_log("Look, there has to be SOMETHING about this edge/plane_pt %s %d\n",
			__FILE__, __LINE__);
		rt_bomb("");
a333 19
}
/*
 *			N M G _ C L A S S _ P T _ L U
 *
 *  Determine if the point fpi->plane_pt is IN, ON, or OUT of the
 *  area enclosed by the loop.
 *
 *  Implicit Return -
 *	Updated "closest" structure if appropriate.
 */
static void
nmg_class_pt_lu(fpi, lu)
struct fu_pt_info	*fpi;
CONST struct loopuse	*lu;
{
	vect_t		delta;
	pointp_t	lu_pt;
	fastf_t		dist;
	struct loop_g	*lg;
a334 5
	NMG_CK_LOOPUSE(lu);
	NMG_CK_LOOP(lu->l_p);
	lg = lu->l_p->lg_p;
	NMG_CK_LOOP_G(lg);
	NMG_CK_FPI(fpi);
d336 4
a339 4
	if (rt_g.NMG_debug & DEBUG_PT_FU ) {
		rt_log(
		    "nmg_class_pt_lu\tPt: (%g %g %g)\n\tinitial class is %s\n",
		    fpi->pt, nmg_class_name(fpi->pt_class));
d342 10
a351 12
	/* if this isn't a loop of a face, or if we've already tested
	 * this loop, we're outta here
	 */
	if (lu->up.fu_p != fpi->fu_p || NMG_INDEX_TEST(fpi->tbl, lu))
		return;
 
	if( !V3PT_IN_RPP_TOL( fpi->pt, lg->min_pt, lg->max_pt, fpi->tol ) )  {
		if (rt_g.NMG_debug & DEBUG_PT_FU )
			rt_log("\tPoint is outside loop RPP\n");
		NMG_INDEX_SET(fpi->tbl, lu);
		NMG_INDEX_SET(fpi->tbl, lu->lumate_p);
		return;
d354 3
a356 5
	if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
		register struct edgeuse	*eu;
		for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
			
			nmg_class_pt_eu(fpi, eu);
a357 7
			/* If point lies ON edge, we might be done */
			if( fpi->allhits == NMG_FPI_FIRST &&
			    fpi->pt_class == NMG_CLASS_AonBshared )
				 break;
		}
	} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
		register struct vertexuse *vu;
a358 1
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d360 5
a364 12
		/* check to see if this vertex was previously processed */
		switch (NMG_INDEX_GET(fpi->tbl, vu->v_p)) {
		case NMG_FPI_TOUCHED:
			if (fpi->vu_func && fpi->allhits == NMG_FPI_PERUSE)
				fpi->vu_func(vu, fpi);
			/* fallthrough */
		case NMG_FPI_MISSED:
			/* if this point were going to be the "closest"
			 * element, it has already been chosen
			 */
			return;
		}
d366 21
a386 32
		lu_pt = vu->v_p->vg_p->coord;
		VSUB2(delta, fpi->pt, lu_pt);
		dist = MAGNITUDE(delta);
		
		if (dist < fpi->tol->dist) {
			/* this is a touch */
			dist = 0.0;
			if (fpi->vu_func)
				fpi->vu_func(vu, fpi);

			NMG_INDEX_ASSIGN(fpi->tbl, vu->v_p, NMG_FPI_TOUCHED);
		} else {
			NMG_INDEX_ASSIGN(fpi->tbl, vu->v_p, NMG_FPI_MISSED);
		}

		if (dist < fpi->dist_in_plane) {
			if (lu->orientation == OT_OPPOSITE) {
				fpi->pt_class = NMG_CLASS_AoutB;
			} else if (lu->orientation == OT_SAME) {
				fpi->pt_class = NMG_CLASS_AonBshared;
			} else {
				nmg_pr_orient(lu->orientation, "\t");
				rt_bomb("nmg_class_pt_lu: bad orientation for face loopuse(vertex)\n");
			}
			if (rt_g.NMG_debug & DEBUG_PT_FU )
				rt_log("\t\t closer to loop pt (%g, %g, %g)\n",
					V3ARGS(lu_pt) );

			fpi->PCA_loc = NMG_PCA_VERTEX;
			fpi->closest = &vu->l.magic;
			fpi->dist_in_plane = dist;
			VMOVE(fpi->pca, vu->v_p->vg_p->coord);
a387 2
	} else {
		rt_bomb("nmg_class_pt_lu() bad child of loopuse\n");
d390 2
a391 2
	NMG_INDEX_SET(fpi->tbl, lu);
	NMG_INDEX_SET(fpi->tbl, lu->lumate_p);
a392 4
	if (rt_g.NMG_debug & DEBUG_PT_FU )
		rt_log("nmg_class_pt_lu\treturning, closest=%g %s\n",
			fpi->dist_in_plane, nmg_class_name(fpi->pt_class) );
}
d395 17
d413 14
a427 27
/*
 *      The Paul Tanenbaum "patch"
 *	If the vertex of the edge is closer to the point than the
 *	span of the edge, we must pick the edge leaving the vertex
 *	which has the smallest value of VDOT(eu->left, vp) where vp
 *	is the normalized vector from V to P and eu->left is the
 *	normalized "face" vector of the edge.  This handles the case
 *	diagramed below, where either e1 OR e2 could be the "closest"
 *	edge based upon edge-point distances.
 *
 *
 *	    \	    /
 *		     o P
 *	      \   /
 *
 *	      V o
 *	       /-\
 *	      /---\
 *	     /-   -\
 *	    /-	   -\
 *	e1 /-	    -\	e2
 */
static void
Tanenbaum_patch(fpi, vu_p)
struct fu_pt_info *fpi;
struct vertexuse *vu_p;
{
d429 32
a460 46
    	/* find the appropriate "closest edge" use of this vertex. */
    	vect_t pv;
    	vect_t left;	/* vector pointing "left" from edgeuse into faceuse */
	double vdot_min = 2.0;
	double newvdot;
    	struct edgeuse *closest_eu;
    	struct faceuse *fu;
    	struct vertexuse *vu;
	struct edgeuse *eu;

	if (rt_g.NMG_debug & DEBUG_PT_FU )
		rt_log("Tanenbaum_patch()\n");


    	/* First we form the unit vector PV */
    	VSUB2(pv, fpi->pt, vu_p->v_p->vg_p->coord);
    	VUNITIZE(pv);

    	/* for each edge in this faceuse about the vertex, determine
    	 * the angle between PV and the "left" vector.  Classify the
	 * plane_pt WRT the edge for which VDOT(left, P) with P
    	 */
    	for (RT_LIST_FOR(vu, vertexuse, &vu_p->v_p->vu_hd)) {
		/* if there is a faceuse ancestor of this vertexuse
		 * which is associated with this face, then perform
    		 * the VDOT and save the results.
    		 */
    		fu = nmg_find_fu_of_vu(vu);
		if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC &&
		    fu == fpi->fu_p || fu->fumate_p == fpi->fu_p) {

		    	if( nmg_find_eu_leftvec(left, eu=vu->up.eu_p ) < 0 ) {
		    		rt_log("%s[line:%d]: bad LEFT vector\n",
		    			__FILE__,__LINE__);
		    		rt_bomb("");
		    	}
		    	VUNITIZE(left);

			newvdot = VDOT(left, pv);
		    	/* if the "left" vector of eu is "more opposed"
		    	 * to the vector pv than the previous edge,
		    	 * remember this edge as the "closest" one
		    	 */
			if (newvdot < vdot_min) {
				closest_eu = eu;
				vdot_min = newvdot;
d463 2
d466 16
a481 9
	fu = nmg_find_fu_of_eu(closest_eu);
	if (fu == fpi->fu_p) {
	    	eu = closest_eu;
	} else if (fu == fpi->fu_p->fumate_p) {
	    	eu = closest_eu->eumate_p;
	} else {
		rt_log("%s[line:%d] Why can't I find this edge in this face?\n",
			__FILE__, __LINE__);
		rt_bomb("");
a483 6
	/* now we know which edgeuse to compare against */
	if (vdot_min < 0.0)
		fpi->pt_class = NMG_CLASS_AoutB;
	else
		fpi->pt_class = NMG_CLASS_AinB;
}
d485 7
d493 15
d509 9
d519 13
d533 37
a569 1
/*	D E D U C E _ P T _ C L A S S
a570 3
 *	For those occasions when the plane_pt is not within tolerance of
 *	any element of the faceuse, we must deduce the pt classification
 *	based upon the "closest" element to the pt.
d572 4
a575 3
static void
deduce_pt_class(fpi)
struct fu_pt_info *fpi;
d577 1
a577 5
	struct edgeuse		*eu;
	struct vertexuse	*vu;
	struct loopuse		*lu;
	vect_t			left;
	vect_t			vupt_v;
d580 3
a583 2
	if (rt_g.NMG_debug & DEBUG_PT_FU )
		rt_log("deduce_pt_class()\n");
d586 4
a589 4
	/* compute in/out based upon closest element */
	if (*fpi->closest == NMG_EDGEUSE_MAGIC) {
		struct faceuse *fu;
		struct edgeuse *eu1;
d591 1
a591 9
		/* PCA along span of edgeuse */
		eu = (struct edgeuse *)fpi->closest;
		fu = nmg_find_fu_of_eu( eu );
		if( !fu )
		{
			rt_log("%s[line:%d]: deduce_pt_class: eu not in a fu\n",
				__FILE__,__LINE__);
			rt_bomb("");
		}
d593 6
a598 40
		/* default is point is outside */
		fpi->pt_class = NMG_CLASS_AoutB;

		/* check all uses of this edge in this fu,
		 * if any say point is "in", then it must be "in"
		 */
		eu1 = eu;
		do
		{
			struct edgeuse *next_eu;

			next_eu = eu1->radial_p->eumate_p;
			/* make sure we stay in this fu */
			if( nmg_find_fu_of_eu( eu1 ) != fu )
			{
				if( nmg_find_fu_of_eu( eu1->eumate_p ) == fu )
					eu1 = eu1->eumate_p;
				else
				{
					eu1 = next_eu;
					continue;
				}
			}
			if( nmg_find_eu_leftvec( left, eu1 ) < 0 ) {
				rt_log("%s[line:%d]: bad LEFT vector\n",
					__FILE__,__LINE__);
				rt_bomb("");
			}
			/* form vector "vupt" from vu to pt, if VDOT(vupt, left)
			 * is less than 0, pt is on "outside" of edge.
			 */
			VSUB2(vupt_v, fpi->pt, eu1->vu_p->v_p->vg_p->coord);
			if (VDOT(vupt_v, left) >= 0.0)
			{
				if (rt_g.NMG_debug & DEBUG_PT_FU )
rt_log("vdot w/eu (%g %g %g)->(%g %g %g) left\n\tsuggests NMG_CLASS_AinB\n",
				V3ARGS(eu1->vu_p->v_p->vg_p->coord),
				V3ARGS(eu1->eumate_p->vu_p->v_p->vg_p->coord));
				
				fpi->pt_class = NMG_CLASS_AinB;
d601 15
d617 1
a617 2
			eu1 = next_eu;
		} while( eu1 != eu && eu1 != eu->eumate_p );
d619 13
a631 29
	} else if (*fpi->closest == NMG_VERTEXUSE_MAGIC) {
		vu = (struct vertexuse *)fpi->closest;
		if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC) {
			/* point is off one end or the other of edge
			 */
			Tanenbaum_patch(fpi, vu);

		} else if (*vu->up.magic_p == NMG_LOOPUSE_MAGIC) {
			lu = (struct loopuse *)vu->up.magic_p;
			if (lu->orientation == OT_OPPOSITE)
				fpi->pt_class = NMG_CLASS_AinB;
			else if (lu->orientation == OT_SAME)
				fpi->pt_class = NMG_CLASS_AoutB;
			else {
				rt_log("%s[line:%d] Bad orientation \"%s\"for loopuse(vertex)\n",
					__FILE__, __LINE__,
					nmg_orientation(lu->orientation));
				rt_bomb("");
			}
		} else if (*vu->up.magic_p == NMG_SHELL_MAGIC) {
			rt_log("%s[line:%d] vertexuse parent is SHELL???\nnmg_class_pt_fu_except(%g %g %g)\n",
				__FILE__, __LINE__,
				V3ARGS(fpi->pt));
			rt_bomb("");
		} else {
			rt_log("%s[line:%d] Bad vertexuse parent?\nnmg_class_pt_fu_except(%g %g %g)\n",
				__FILE__, __LINE__,
				V3ARGS(fpi->pt));
			rt_bomb("");
d633 3
a636 1
}
d639 2
d642 2
a644 19
static void
pl_pt_fu(fpi, fu)
struct fu_pt_info *fpi;
CONST struct faceuse *fu;
{
	FILE *fd;
	char name[25];
	long *b;
	static int plot_file_number=0;

	NMG_CK_FACEUSE(fu);
	NMG_CK_FPI(fpi);

	
	sprintf(name, "pt_fu%02d.pl", plot_file_number++);
	if ((fd=fopen(name, "w")) == (FILE *)NULL) {
		perror(name);
		abort();
	}
a645 21
	rt_log("\tplotting %s\n", name);
	b = (long *)rt_calloc( fu->s_p->r_p->m_p->maxindex,
		sizeof(long), "bit vec"),

	pl_erase(fd);
	pd_3space(fd,
		fu->f_p->min_pt[0]-1.0,
		fu->f_p->min_pt[1]-1.0,
		fu->f_p->min_pt[2]-1.0,
		fu->f_p->max_pt[0]+1.0,
		fu->f_p->max_pt[1]+1.0,
		fu->f_p->max_pt[2]+1.0);
	
	nmg_pl_fu(fd, fu, b, 255, 255, 255);

	pl_color(fd, 255, 255, 50);
	pdv_3line(fd, fpi->pca, fpi->pt);

	rt_free((char *)b, "bit vec");
	fclose(fd);
}
a647 1
 *			N M G _ C L A S S _ P T _ F U
d649 2
a650 4
 *  This is intended as a general user interface routine.
 *  Given the Cartesian coordinates for a point which is known to
 *  lie in the plane of a faceuse, return the classification for that point
 *  with respect to all the loops on that face.
d652 1
a652 2
 *  The algorithm used is to find the edge which the point is closest
 *  to, and classifiy with respect to that.
d654 1
a654 3
 *  "ignore_lu" is optional.  When non-null, it points to a loopuse (and it's
 *  mate) which will not be considered in the assessment of this point.
 *  This is used by nmg_lu_reorient() to work on one lu in the face.
d656 8
a663 1
 *  The point is "A", and the face is "B".
a664 14
 *  Returns -
 *	struct fu_pt_info *	The user is responsible for calling rt_free
 * 				On this storage.
 *
 *	fpi->pt_class has one of the following:
 *	NMG_CLASS_AinB		pt is INSIDE the area of the faceuse.
 *	NMG_CLASS_AonBshared	pt is ON a loop boundary.
 *	NMG_CLASS_AoutB		pt is OUTSIDE the area of the faceuse.
 *
 *
 *  Values for "allhits"
 *	0	return after finding first element pt touches
 *	1	find all elements pt touches, call user routine for each geom.
 *	2	find all elements pt touches, call user routine for each use
d666 11
a676 11
struct fu_pt_info *
nmg_class_pt_fu_except(pt, fu, ignore_lu, 
			eu_func, vu_func, priv, allhits, tol)
point_t			pt;
CONST struct faceuse	*fu;
CONST struct loopuse	*ignore_lu;
void			(*eu_func)();	/* func to call when pt on edgeuse */
void			(*vu_func)();	/* func to call when pt on vertexuse*/
char			*priv;		/* private data for [ev]u_func */
CONST int		allhits;	/* return after finding first hit */
CONST struct rt_tol	*tol;
d678 8
a685 4
	struct loopuse		*lu;
	struct fu_pt_info	*fpi;
	fastf_t			dist;
	struct model		*m;
a692 6

	if (rt_g.NMG_debug & DEBUG_PT_FU )
		rt_log("nmg_class_pt_fu_except()\n");

	fpi = (struct fu_pt_info *)rt_malloc(sizeof(*fpi), "struct fu_pt_info");

d694 2
a695 2
	NMG_GET_FU_PLANE( fpi->norm, fu );
	if( (dist=fabs(DIST_PT_PLANE( pt, fpi->norm ))) > tol->dist )  {
d697 1
a697 1
			V3ARGS(pt), V4ARGS(fpi->norm), dist );
d700 9
a708 16
	m = nmg_find_model((CONST long *)fu);
	fpi->tbl = rt_calloc(m->maxindex, 1, "nmg_class_pt_fu_except() proc tbl");

	fpi->tol = tol;
	fpi->fu_p = fu;
	fpi->pt = pt;
	fpi->pt_class = NMG_CLASS_Unknown;
	fpi->eu_func = eu_func;
	fpi->vu_func = vu_func;
	fpi->allhits = allhits;
	fpi->dist_in_plane = MAX_FASTF;
	VSET(fpi->pca, 0.0, 0.0, 0.0);
	fpi->closest = (long *)NULL;
	fpi->priv = priv;
	fpi->magic = NMG_FPI_MAGIC;

d714 1
a714 1
		nmg_class_pt_lu(fpi, lu);
d716 6
a721 4
		/* If point lies ON loop edge, we are done */
		if( allhits == NMG_FPI_FIRST && 
		    fpi->pt_class != NMG_CLASS_Unknown )
			break;
d724 3
d728 5
a732 8
	if (fpi->pt_class == NMG_CLASS_AinB ||
	    fpi->pt_class == NMG_CLASS_AoutB ||
	    fpi->pt_class == NMG_CLASS_AonBshared)
		goto exit_ramp;

	if (fpi->pt_class != NMG_CLASS_Unknown) {
		rt_log("%s[line:$d]: bad classification \"%s\" for point in face?\n",
			__FILE__, __LINE__, nmg_class_name(fpi->pt_class));
d734 6
a741 7
	if (fpi->closest == (long *)NULL) {
		/* The plane point was never within a bounding RPP of a loop.
		 * Therefore, we are decidedly OUTside the area of the face.
		 */
		fpi->pt_class = NMG_CLASS_AoutB;
	} else
		deduce_pt_class(fpi);
d743 3
a745 6
exit_ramp:
	if (rt_g.NMG_debug & DEBUG_PT_FU ) {
		if (fpi->pt_class != NMG_CLASS_Unknown)
			pl_pt_fu(fpi, fu);
		else
			rt_log("class = unknown, skipping plot\n");
d747 1
a747 4
		rt_log("nmg_class_pt_fu_except(): point is classed %s\n",
			nmg_class_name(fpi->pt_class));
	}
	return fpi;
a748 2


@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pt_fu.c,v 1.15 94/12/30 11:05:32 stay Exp $ (ARL)";
d107 1
a107 1
	/* The verticies at the ends of this edge were missed or not
d308 3
a310 3
		VPRINT("nmg_class_pt_lu\tPt:", fpi->pt);
		rt_log("\tinitial class is %s\n",
			nmg_class_name(fpi->pt_class));
d312 4
d335 1
a335 1
			    fpi->pt_class==NMG_CLASS_AonBshared )
d574 5
d705 1
a705 1
CONST int		allhits;		/* return after finding first hit */
d724 1
d731 1
a733 1

@


1.15
log
@added space for variable initialization
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pt_fu.c,v 1.14 94/12/27 18:20:38 mike Exp Locker: stay $ (ARL)";
@


1.14
log
@Added RCSid
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d44 1
a44 1
	fastf_t	dist=-1.0;
@


1.13
log
@MOds for CRAY.
@
text
@d2 1
d4 1
d6 15
d22 4
d27 1
@


1.12
log
@Modified deduce_pt_class to look at all uses of selected eu.
@
text
@d594 1
a594 1
struct faceuse *fu;
@


1.11
log
@Lee added more debugging and pl_pt_fu.
@
text
@d501 3
d506 4
a509 3

		if( nmg_find_eu_leftvec( left, eu ) < 0 ) {
			rt_log("%s[line:%d]: bad LEFT vector\n",
d513 6
a518 2
		/* form vector "vupt" from vu to pt, if VDOT(vupt, left)
		 * is less than 0, pt is on "outside" of edge.
d520 34
a553 5
		VSUB2(vupt_v, fpi->pt, eu->vu_p->v_p->vg_p->coord);
		if (VDOT(vupt_v, left) >= 0.0)
			fpi->pt_class = NMG_CLASS_AinB;
		else
			fpi->pt_class = NMG_CLASS_AoutB;
@


1.10
log
@Irix 6
@
text
@d15 2
d43 1
a43 1
	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d60 1
a60 1
		if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d78 1
a78 1
		if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d96 1
a96 1
		if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d104 1
a104 1
		if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d114 1
a114 1
	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d136 1
d140 1
a140 1
		if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d153 1
d157 1
a157 1
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d161 1
a161 1
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d176 1
d180 1
a180 1
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d184 1
a184 1
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d199 1
d203 1
a203 1
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d207 1
a207 1
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d217 1
d220 1
a220 1
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d224 1
a224 1
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d238 1
d241 1
a241 1
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d245 1
a245 1
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d285 1
a285 1
	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) ) {
d294 1
a294 1
		if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d354 1
a354 1
			if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d361 1
d370 1
a370 1
	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d416 1
a416 1
	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d495 1
a495 1
	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d554 9
d564 32
d652 1
a652 1
	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d674 1
d696 1
a696 1
		return fpi;
d712 7
a718 1
	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_RT_ISECT) )
d721 1
a721 1

d724 2
@


1.9
log
@Fixed use of uninitialized variable 'eu'
@
text
@a100 1
		break;
a589 2
	struct vertexuse	*vu_p;
	struct edgeuse		*eu;
a592 1
	vect_t			vupt_v;
@


1.8
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@a269 1
	struct edgeuse	*eu;
d295 1
d314 1
a314 1
				fpi->vu_func(eu->vu_p, fpi);
@


1.7
log
@checkpoint
@
text
@d601 1
a601 1
	NMG_CK_FACE_G(fu->f_p->fg_p);
@


1.6
log
@Added GDurf's new "conf.h"
@
text
@d36 5
d42 3
a44 1
		rt_log("nmg_class_pt_eu()\n");
d58 3
d63 1
a63 1
	eunext = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);	
d76 3
d83 1
a83 1
	/* The verticies at the ends of this edge where missed or not
d94 3
d100 5
a104 1
		/* fallthrough */
a105 1
	case NMG_FPI_MISSED:
d113 4
@


1.5
log
@changed conditional on debug print statments
@
text
@d5 1
@


1.4
log
@Fixed some debugging statment typos
@
text
@d35 1
a35 1
	if (rt_g.NMG_debug)
d114 1
a114 1
		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
d130 1
a130 1
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
d134 1
a134 1
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
d152 1
a152 1
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
d156 1
a156 1
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
d173 2
a174 1
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
d178 1
a178 1
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
d190 1
a190 1
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
d194 1
a194 1
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
d210 1
a210 1
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
d214 1
a214 1
			if (rt_g.NMG_debug & DEBUG_RT_ISECT)
d255 1
a255 1
	if (rt_g.NMG_debug) {
d264 1
a264 1
		if (rt_g.NMG_debug )
d323 1
a323 1
			if (rt_g.NMG_debug )
d338 1
a338 1
	if (rt_g.NMG_debug )
d384 1
a384 1
	if (rt_g.NMG_debug)
d463 1
a463 1
	if (rt_g.NMG_debug)
d582 1
a582 1
	if (rt_g.NMG_debug)
d641 1
a641 1
	if (rt_g.NMG_debug)
@


1.3
log
@fixed for the case where point is in the face RPP but outside all loop RPP's
@
text
@d76 1
d82 1
d84 1
d90 4
d174 1
a174 1
				rt_log("\vu of eu is new \"closest to plane_pt\" (new dist %g)\n",
d178 1
a178 1
				rt_log("\vu of eu is PCA (dist %g).  keeping old dist %g\n",
d194 1
a194 1
				rt_log("\vu of next(eu) is PCA (dist %g).  keeping old dist %g\n",
d254 1
a254 1
	if (rt_g.NMG_debug)
d256 3
a258 1

d607 1
d639 4
@


1.2
log
@compiles
@
text
@d6 1
d14 1
d35 3
d247 1
a247 1
	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
d254 1
a254 1
		if (rt_g.NMG_debug & DEBUG_CLASSIFY)
d313 1
a313 1
			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
d328 1
a328 1
	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
d374 2
d377 1
d451 6
d546 2
a547 1
nmg_class_pt_fu_except(pt, fu, ignore_lu, eu_func, vu_func, priv, allhits, tol)
d572 3
d579 2
a580 2
		rt_log("nmg_class_pt_f() ERROR, point (%g,%g,%g) not on face, dist=%g\n",
			V3ARGS(pt), dist );
d602 1
a602 1
		class_pt_lu(fpi, lu);
d622 7
a628 1
	deduce_pt_class(fpi);
@


1.1
log
@Initial revision
@
text
@a11 16
struct fu_pt_info {
	long		magic;
	CONST struct rt_tol	*tol;
	CONST struct faceuse	*fu_p;
	plane_t		norm;		/* surface normal for face(use) */
	pointp_t	pt;		/* pt in plane of face to classify */
	int		pt_class;	/* current point classification */
	void		(*eu_func)();	/* call w/eu when pt on edgeuse */
	void		(*vu_func)();	/* call w/vu when pt on vertexuse */
	int		onehit;		/* return after first "on" condition*/
	fastf_t		dist_in_plane;	/* dist in plane (elem -> plane_pt) */
	long		*closest;	/* ptr to elem w/ min(dist_in_plane)*/
	int		PCA_loc;	/* is PCA at an edge-span,
					 *  edge-vertex, or vertex?
					 */
}
a12 3
#define NMG_FPI_MAGIC 0x66706900 /* fpi\0 */
#define NMG_CK_FPI(_fpi)	NMG_CKMAG(_fpi, NMG_FPI_MAGIC, "fu_pt_info")

d20 1
d33 49
d107 2
d129 2
a135 1
			eu = RT_LIST_PNEXT_CIRC(edgeuse, &(eu->l));
d137 1
a137 1
			fpi->closest = &eu->vu_p->l.magic;
d149 1
a149 1
			fpi->vu_func(eu->vu_p, fpi);
d151 4
d169 1
d185 3
d205 3
d245 1
a245 1
	if (lu->up.fu_p != fpi->fu_p)
d247 1
a247 1

d251 2
d255 1
d261 3
a263 2
			/* If point lies ON edge, we are done */
			if( fpi->onehit && fpi->pt_class==NMG_CLASS_AonBshared )
d270 14
a284 1

d286 7
d294 6
a299 1
		if ( (dist = MAGNITUDE(delta)) < fpi->dist_in_plane) {
d314 1
a314 7
			if (dist < fpi->tol->dist) {
				fpi->dist_in_plane = 0.0;
				if (fpi->vu_func)
					fpi->vu_func(vu, fpi);
			} else
				fpi->dist_in_plane = dist;
				
d319 4
d385 1
a385 1
		    fu == fpi->fu_p || fu->fumate == fpi->fu_p) {
d456 1
a456 1
		VSUB2(vupt_v, pt, eu->vu_p->v_p->vg_p->coord);
d463 2
a464 2
		vu_p = (struct vertexuse *)fpi->closest;
		if (vu_p->up.magic_p == NMG_EDGEUSE_MAGIC) {
a465 1
			 * XXX
d469 3
a471 3
		} else if (vu_p->up.magic_p == NMG_LOOPUSE_MAGIC) {
			lu = (struct loopuse *)vu_p->up.magic_p;
			if (lu->orentation == OT_OPPOSITE)
d473 1
a473 1
			else if (lu->orentation == OT_SAME)
d476 1
a476 1
				rt_log("%s[line:%d] Bad orientation "%s"for loopuse(vertex)\n",
d478 1
a478 1
					nmg_orientation(lu->orentation));
d481 1
a481 1
		} else if (vu_p->up.magic_p == NMG_SHELL_MAGIC) {
d484 1
a484 1
				V3ARGS(pt));
d489 1
a489 1
				V3ARGS(pt));
d524 6
d532 1
a532 1
nmg_class_pt_fu_except(pt, fu, ignore_lu, eu_func, vu_func, onehit, tol)
d536 4
a539 3
void		(*eu_func)();	/* func to call when pt on edgeuse */
void		(*vu_func)();	/* func to call when pt on vertexuse*/
CONST int		onehit;		/* return after finding first hit */
d548 1
d564 2
d574 1
a574 1
	fpi->onehit = onehit;
d577 1
d587 3
a589 1
		if( onehit && fpi->pt_class != NMG_CLASS_Unknown )  break;
d599 1
a599 1
		rt_log("%s[line:$d]: bad classification "%s" for point in face?\n",
@
