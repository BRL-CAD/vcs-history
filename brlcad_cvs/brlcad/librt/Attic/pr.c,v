head	11.41;
access;
symbols
	ansi-20040405-merged:11.37.2.2
	postmerge-20040405-ansi:11.39
	premerge-20040404-ansi:11.38
	postmerge-autoconf:11.38
	autoconf-freeze:11.37.10.2
	premerge-autoconf:11.38
	ansi-20040316-freeze:11.37.2.1
	postmerge-20040315-windows:11.38
	premerge-20040315-windows:11.38
	windows-20040315-freeze:11.37.4.1
	autoconf-20031203:11.37
	autoconf-20031202:11.37
	autoconf-branch:11.37.0.10
	phong-branch:11.37.0.8
	photonmap-branch:11.37.0.6
	rel-6-1-DP:11.37
	windows-branch:11.37.0.4
	rel-6-0-2:11.35
	ansi-branch:11.37.0.2
	rel-6-0-1-branch:11.35.0.2
	hartley-6-0-post:11.36
	hartley-6-0-pre:11.35
	rel-6-0-1:11.35
	rel-6-0:11.35
	rel-5-4:11.28
	offsite-5-3-pre:11.32
	rel-5-3:11.28
	rel-5-2:11.28
	rel-5-1-branch:11.28.0.2
	rel-5-1:11.28
	rel-5-0:11.17
	rel-5-0-beta:11.16
	rel-4-5:11.14
	ctj-4-5-post:11.14
	ctj-4-5-pre:11.13
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.41
date	2004.05.21.18.07.35;	author morrison;	state dead;
branches;
next	11.40;

11.40
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.39;

11.39
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.37;

11.37
date	2002.08.20.17.08.09;	author jra;	state Exp;
branches
	11.37.2.1
	11.37.4.1
	11.37.10.1;
next	11.36;

11.36
date	2002.08.15.20.55.20;	author hartley;	state Exp;
branches;
next	11.35;

11.35
date	2002.01.10.18.12.40;	author butler;	state Exp;
branches;
next	11.34;

11.34
date	2001.11.05.21.20.06;	author morrison;	state Exp;
branches;
next	11.33;

11.33
date	2001.04.20.22.29.55;	author morrison;	state Exp;
branches;
next	11.32;

11.32
date	2000.08.23.01.03.14;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	2000.07.10.23.01.47;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	2000.06.30.15.27.09;	author pjt;	state Exp;
branches;
next	11.29;

11.29
date	2000.06.27.21.59.37;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.06.02.15.17.26;	author butler;	state Exp;
branches;
next	11.27;

11.27
date	2000.05.23.03.42.53;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.02.12.01.38.42;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.01.29.04.15.54;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.01.13.22.00.09;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	99.12.07.02.22.55;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	99.12.06.16.39.46;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	99.11.26.22.39.16;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	99.11.13.05.07.56;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.11.12.20.54.17;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	99.10.30.03.53.44;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	99.06.03.01.43.38;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	99.05.10.21.30.48;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	98.12.17.04.19.10;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	97.08.28.23.04.06;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.04.15.14.27.54;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	96.12.31.01.38.08;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	96.12.04.02.50.27;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	96.10.19.06.17.45;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	96.08.29.06.07.38;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.08.28.10.03.46;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.08.27.02.41.51;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	96.07.12.12.10.21;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.07.02.06.09.44;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.07.02.05.51.52;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.03.29.21.36.55;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.28;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.11.04.06.02.28;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.10.19.40.52;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	93.09.30.20.54.32;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.10.27.17.57.42;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.56;	author mike;	state Rel4_0;
branches;
next	1.14;

1.14
date	91.08.19.21.57.41;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	91.07.23.16.18.11;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	91.07.17.01.27.43;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	91.07.17.01.22.14;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	91.06.29.22.27.21;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	91.06.29.22.14.05;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	91.06.29.15.50.54;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	91.03.13.16.42.28;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	91.01.11.06.55.12;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.01.11.06.05.21;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	90.04.12.04.00.12;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	90.01.05.04.15.43;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.01.04.21.45.05;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.12.31.00.13.25;	author mike;	state Exp;
branches;
next	;

11.37.2.1
date	2002.09.19.18.01.46;	author morrison;	state Exp;
branches;
next	11.37.2.2;

11.37.2.2
date	2004.03.17.21.18.57;	author morrison;	state Exp;
branches;
next	;

11.37.4.1
date	2004.03.11.23.43.45;	author morrison;	state Exp;
branches;
next	;

11.37.10.1
date	2004.02.12.18.37.47;	author erikg;	state Exp;
branches;
next	11.37.10.2;

11.37.10.2
date	2004.03.15.14.07.29;	author erikg;	state Exp;
branches;
next	;


desc
@Printing subroutines for librt
@


11.41
log
@moved to src/
@
text
@/*
 *			P R . C
 * 
 *  Routines to print LIBRT data structures using bu_log()
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/pr.c,v 11.40 2004/05/10 15:30:47 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <string.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "bu.h"
#include "raytrace.h"
#include "./debug.h"


/*
 *			R T _ P R _ S O L T A B
 */
void
rt_pr_soltab(register const struct soltab *stp)
{
	register int	id = stp->st_id;

	if( id <= 0 || id > ID_MAX_SOLID )  {
		bu_log("stp=x%x, id=%d.\n", stp, id);
		rt_bomb("rt_pr_soltab:  bad st_id");
	}
	bu_log("------------ %s (bit %d) %s ------------\n",
		stp->st_dp->d_namep, stp->st_bit,
		rt_functab[id].ft_name );
	VPRINT("Bound Sph CENTER", stp->st_center);
	bu_log("Approx Sph Radius = %g\n", stp->st_aradius);
	bu_log("Bounding Sph Radius = %g\n", stp->st_bradius);
	VPRINT("Bound RPP min", stp->st_min);
	VPRINT("Bound RPP max", stp->st_max);
	bu_pr_ptbl( "st_regions", &stp->st_regions, 1 );
	rt_functab[id].ft_print( stp );
}

/*
 *			R T _ P R _ R E G I O N
 */
void
rt_pr_region(register const struct region *rp)
{
	struct bu_vls	v;

	RT_CK_REGION(rp);

	bu_log("REGION %s (bit %d)\n", rp->reg_name, rp->reg_bit );
	bu_log("instnum=%d, id=%d, air=%d, gift_material=%d, los=%d\n",
		rp->reg_instnum,
		rp->reg_regionid, rp->reg_aircode,
		rp->reg_gmater, rp->reg_los );
	if( rp->reg_is_fastgen != REGION_NON_FASTGEN )  {
		bu_log("reg_is_fastgen = %s mode\n",
			rp->reg_is_fastgen == REGION_FASTGEN_PLATE ?
				"plate" : "volume" );
	}
	if( rp->reg_mater.ma_color_valid )
		bu_log("Color %d %d %d\n",
			(int)rp->reg_mater.ma_color[0]*255.,
			(int)rp->reg_mater.ma_color[1]*255.,
			(int)rp->reg_mater.ma_color[2]*255. );
	if( rp->reg_mater.ma_temperature > 0 )
		bu_log("Temperature %g degrees K\n", rp->reg_mater.ma_temperature );
	if( rp->reg_mater.ma_shader && rp->reg_mater.ma_shader[0] != '\0' )
		bu_log("Shader '%s'\n", rp->reg_mater.ma_shader );

	bu_vls_init(&v);
	rt_pr_tree_vls(&v, rp->reg_treetop);
	bu_log("%s %d %s\n", rp->reg_name,
		rp->reg_instnum, bu_vls_addr(&v) );
	bu_vls_free(&v);
}

/*
 *			R T _ P R _ P A R T I T I O N S
 *
 */
void
rt_pr_partitions(const struct rt_i *rtip, register const struct partition *phead, const char *title)
{
	register const struct partition *pp;
	struct bu_vls		v;

	RT_CHECK_RTI(rtip);

	bu_vls_init( &v );
	bu_log_indent_vls( &v );
	bu_vls_strcat( &v, "------" );
	bu_vls_strcat( &v, title );
	bu_vls_strcat( &v, "\n" );
	bu_log_indent_delta( 2 );

	for( pp = phead->pt_forw; pp != phead; pp = pp->pt_forw ) {
		RT_CHECK_PT(pp);
		rt_pr_pt_vls( &v, rtip, pp );
	}
	bu_log_indent_delta( -2 );
	bu_log_indent_vls( &v );
	bu_vls_strcat( &v, "------\n");

	bu_log("%s", bu_vls_addr( &v ) );
	bu_vls_free( &v );
}

/*
 *			R T _ P R _ P T _ V L S
 */
void
rt_pr_pt_vls(struct bu_vls *v, const struct rt_i *rtip, register const struct partition *pp)
{
	register const struct soltab	*stp;
	register struct seg		**segpp;

	RT_CHECK_RTI(rtip);
	RT_CHECK_PT(pp);
	BU_CK_VLS(v);

	bu_log_indent_vls( v );
	bu_vls_printf( v, "%.8x: PT ", pp );

	stp = pp->pt_inseg->seg_stp;
	bu_vls_printf(v, "%s (%s#%d) ",
		stp->st_dp->d_namep,
		rt_functab[stp->st_id].ft_name+3,
		stp->st_bit );

	stp = pp->pt_outseg->seg_stp;
	bu_vls_printf(v, "%s (%s#%d) ",
		stp->st_dp->d_namep,
		rt_functab[stp->st_id].ft_name+3,
		stp->st_bit );

	bu_vls_printf(v, "(%g,%g)",
		pp->pt_inhit->hit_dist, pp->pt_outhit->hit_dist );
	if( pp->pt_inflip )  bu_vls_strcat( v, " Iflip" );
	if( pp->pt_outflip )  bu_vls_strcat( v, " Oflip" );
	bu_vls_strcat( v, "\n");

	rt_pr_hit_vls( v, "  In", pp->pt_inhit );
	rt_pr_hit_vls( v, " Out", pp->pt_outhit );
	bu_log_indent_vls( v );
	bu_vls_strcat( v, "  Primitives: " );
	for( BU_PTBL_FOR( segpp, (struct seg **), &pp->pt_seglist ) )  {
		stp = (*segpp)->seg_stp;
		RT_CK_SOLTAB(stp);
		bu_vls_strcat( v, stp->st_dp->d_namep );
		bu_vls_strcat( v, ", " );
	}
	bu_vls_strcat( v, "\n" );

	bu_log_indent_vls( v );
	bu_vls_strcat( v, "  Untrimmed Segments spanning this interval:\n" );
	bu_log_indent_delta( 4 );
	for( BU_PTBL_FOR( segpp, (struct seg **), &pp->pt_seglist ) )  {
		RT_CK_SEG(*segpp)
		rt_pr_seg_vls( v, *segpp );
	}
	bu_log_indent_delta( -4 );

	if( pp->pt_regionp )  {
		RT_CK_REGION( pp->pt_regionp );
		bu_log_indent_vls( v );
		bu_vls_printf( v, "  Region: %s\n", pp->pt_regionp->reg_name );
	}
}

/*
 *			R T _ P R _ P T
 */
void
rt_pr_pt(const struct rt_i *rtip, register const struct partition *pp)
{
	struct bu_vls	v;

	RT_CHECK_RTI(rtip);
	RT_CHECK_PT(pp);
	bu_vls_init( &v );
	rt_pr_pt_vls( &v, rtip, pp );
	bu_log("%s", bu_vls_addr( &v ) );
	bu_vls_free( &v );
}

/*
 *			R T _ P R _ S E G _ V L S
 */
void
rt_pr_seg_vls(struct bu_vls *v, register const struct seg *segp)
{
	BU_CK_VLS(v);
	RT_CK_SEG(segp);

	bu_log_indent_vls( v );
	bu_vls_printf(v,
		"%.8x: SEG %s (%g,%g) st_bit=%d xray#=%d\n",
		segp,
		segp->seg_stp->st_dp->d_namep,
		segp->seg_in.hit_dist,
		segp->seg_out.hit_dist,
		segp->seg_stp->st_bit,
		segp->seg_in.hit_rayp->index );
}

/*
 *			R T _ P R _ S E G
 */
void
rt_pr_seg(register const struct seg *segp)
{
	struct bu_vls		v;

	RT_CK_SEG(segp);

	bu_vls_init( &v );
	rt_pr_seg_vls( &v, segp );
	bu_log("%s", bu_vls_addr( &v ) );
	bu_vls_free( &v );
}

/*
 *			R T _ P R _ H I T
 */
void
rt_pr_hit(const char *str, register const struct hit *hitp)
{
	struct bu_vls		v;

	RT_CK_HIT(hitp);

	bu_vls_init( &v );
	rt_pr_hit_vls( &v, str, hitp );
	bu_log("%s", bu_vls_addr( &v ) );
	bu_vls_free( &v );
}

/*
 *			R T _ P R _ H I T _ V L S
 */
void
rt_pr_hit_vls(struct bu_vls *v, const char *str, register const struct hit *hitp)
{
	BU_CK_VLS( v );
	RT_CK_HIT(hitp);

	bu_log_indent_vls( v );
	bu_vls_strcat( v, str );

	bu_vls_printf(v, "HIT dist=%g (surf %d)\n",
		hitp->hit_dist, hitp->hit_surfno );
}

/*
 *			R T _ P R _ H I T A R R A Y _ V L S
 */
void
rt_pr_hitarray_vls(struct bu_vls *v, const char *str, register const struct hit *hitp, int count)
{
	int	i;

	BU_CK_VLS( v );
	RT_CK_HIT(hitp);

	bu_log_indent_vls( v );
	bu_vls_strcat( v, str );

	for( i=0; i<count; i++, hitp++ )  {
		bu_vls_printf(v, "HIT%d dist=%g (surf %d)\n", i,
			hitp->hit_dist, hitp->hit_surfno );
	}
}

/*
 *			R T _ P R _ T R E E
 *
 *  Warning:  This function uses recursion rather than iteration and
 *  a stack, to preserve simplicity.
 *  On machines with limited stack space, such as the Gould,
 *  this subroutine may overwhelm the stack on complex expressions.
 */
void
rt_pr_tree(register const union tree *tp, int lvl)
                              
        			/* recursion level */
{
	register int i;

	RT_CK_TREE(tp);

	bu_log("%.8x ", tp);
	for( i=lvl; i>0; i-- )
		bu_log("  ");

	if( tp == TREE_NULL )  {
		bu_log("Null???\n");
		return;
	}

	switch( tp->tr_op )  {

	case OP_NOP:
		bu_log("NOP\n");
		return;

	case OP_SOLID:
		bu_log("SOLID %s (bit %d)\n",
			tp->tr_a.tu_stp->st_dp->d_namep,
			tp->tr_a.tu_stp->st_bit );
		return;

	case OP_REGION:
		bu_log("REGION ctsp=x%x\n", tp->tr_c.tc_ctsp );
		db_pr_combined_tree_state( tp->tr_c.tc_ctsp );
		return;

	case OP_DB_LEAF:
		bu_log("DB_LEAF %s%s\n",
			tp->tr_l.tl_name,
			tp->tr_l.tl_mat ? " (matrix)" : "" );
		return;

	default:
		bu_log("Unknown op=x%x\n", tp->tr_op );
		return;

	case OP_UNION:
		bu_log("UNION\n");
		break;
	case OP_INTERSECT:
		bu_log("INTERSECT\n");
		break;
	case OP_SUBTRACT:
		bu_log("MINUS\n");
		break;
	case OP_XOR:
		bu_log("XOR\n");
		break;
	case OP_NOT:
		bu_log("NOT\n");
		break;
	}

	switch( tp->tr_op )  {
	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		/* BINARY type */
		rt_pr_tree( tp->tr_b.tb_left, lvl+1 );
		rt_pr_tree( tp->tr_b.tb_right, lvl+1 );
		break;
	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
		/* UNARY tree */
		rt_pr_tree( tp->tr_b.tb_left, lvl+1 );
		break;
	}
}

/*
 *			R T _ P R _ T R E E _ V L S
 *
 *  Produce a compact representation of this tree.
 *  The destination vls must be initialized by the caller.
 *
 *  Operations are responsible for generating white space.
 */
void
rt_pr_tree_vls(struct bu_vls *vls, register const union tree *tp)
{
	char		*str;

	if( tp == TREE_NULL )  {
		bu_vls_strcat( vls, "??NULL_tree??" );
		return;
	}

	switch( tp->tr_op )  {

	case OP_NOP:
		bu_vls_strcat( vls, "NOP");
		return;

	case OP_SOLID:
		bu_vls_strcat( vls, tp->tr_a.tu_stp->st_dp->d_namep );
		return;

	case OP_REGION:
		str = db_path_to_string( &(tp->tr_c.tc_ctsp->cts_p) );
		bu_vls_strcat( vls, str );
		bu_free( str, "path string" );
		return;

	case OP_DB_LEAF:
		bu_vls_strcat( vls, tp->tr_l.tl_name );
		return;

	default:
		bu_log("rt_pr_tree_vls() Unknown op=x%x\n", tp->tr_op );
		return;

	case OP_UNION:
		/* BINARY type */
		bu_vls_strcat( vls, " (" );
		rt_pr_tree_vls( vls, tp->tr_b.tb_left );
		bu_vls_strcat( vls, ") u (" );
		rt_pr_tree_vls( vls, tp->tr_b.tb_right );
		bu_vls_strcat( vls, ") " );
		break;
	case OP_INTERSECT:
		/* BINARY type */
		bu_vls_strcat( vls, " (" );
		rt_pr_tree_vls( vls, tp->tr_b.tb_left );
		bu_vls_strcat( vls, ") + (" );
		rt_pr_tree_vls( vls, tp->tr_b.tb_right );
		bu_vls_strcat( vls, ") " );
		break;
	case OP_SUBTRACT:
		/* BINARY type */
		bu_vls_strcat( vls, " (" );
		rt_pr_tree_vls( vls, tp->tr_b.tb_left );
		bu_vls_strcat( vls, ") - (" );
		rt_pr_tree_vls( vls, tp->tr_b.tb_right );
		bu_vls_strcat( vls, ") " );
		break;
	case OP_XOR:
		/* BINARY type */
		bu_vls_strcat( vls, " (" );
		rt_pr_tree_vls( vls, tp->tr_b.tb_left );
		bu_vls_strcat( vls, ") ^ (" );
		rt_pr_tree_vls( vls, tp->tr_b.tb_right );
		bu_vls_strcat( vls, ") " );
		break;
	case OP_NOT:
		/* UNARY tree */
		bu_vls_strcat( vls, " !(" );
		rt_pr_tree_vls( vls, tp->tr_b.tb_left );
		bu_vls_strcat( vls, ") " );
		break;
	case OP_GUARD:
		/* UNARY tree */
		bu_vls_strcat( vls, " guard(" );
		rt_pr_tree_vls( vls, tp->tr_b.tb_left );
		bu_vls_strcat( vls, ") " );
		break;
	case OP_XNOP:
		/* UNARY tree */
		bu_vls_strcat( vls, " xnop(" );
		rt_pr_tree_vls( vls, tp->tr_b.tb_left );
		bu_vls_strcat( vls, ") " );
		break;
	}
}

/*
 *			R T _ P R _ T R E E _ S T R
 *
 *  JRA's tree pretty-printer.
 *  Formats the tree compactly into a dynamically allocated string.
 *  Uses recursion and lots of malloc/free activity.
 */
char *
rt_pr_tree_str(const union tree *tree)
{
	char *left,*right;
	char *return_str;
	char op = OP_GUARD;
	int return_length;

	if( tree == NULL )
		return bu_strdup("NULL_ptr");
	RT_CK_TREE(tree);
	if( tree->tr_op == OP_UNION || tree->tr_op == OP_SUBTRACT || tree->tr_op == OP_INTERSECT )
	{
		char *blankl,*blankr;

		left = rt_pr_tree_str( tree->tr_b.tb_left );
		right = rt_pr_tree_str( tree->tr_b.tb_right );
		switch( tree->tr_op )
		{
			case OP_UNION:
				op = 'u';
				break;
			case OP_SUBTRACT:
				op = '-';
				break;
			case OP_INTERSECT:
				op = '+';
				break;
		}
		return_length = strlen( left ) + strlen( right ) + 8;
		return_str = (char *)bu_malloc( return_length , "rt_pr_tree_str: return string" );

		blankl = strchr( left , ' ' );
		blankr = strchr( right , ' ' );
		if( blankl && blankr )
			sprintf( return_str , "(%s) %c (%s)" , left , op , right );
		else if( blankl && !blankr )
			sprintf( return_str , "(%s) %c %s" , left , op , right );
		else if( !blankl && blankr )
			sprintf( return_str , "%s %c (%s)" , left , op , right );
		else
			sprintf( return_str , "%s %c %s" , left , op , right );

		if( tree->tr_b.tb_left->tr_op != OP_DB_LEAF )
			bu_free( (genptr_t)left , "rt_pr_tree_str: left string" );
		if( tree->tr_b.tb_right->tr_op != OP_DB_LEAF )
			bu_free( (genptr_t)right , "rt_pr_tree_str: right string" );
		return  return_str;
	}
	else if( tree->tr_op == OP_DB_LEAF )
		return bu_strdup(tree->tr_l.tl_name) ;
	else if( tree->tr_op == OP_REGION )
		return( db_path_to_string( &tree->tr_c.tc_ctsp->cts_p ) );
	else if( tree->tr_op == OP_SOLID )  {
		RT_CK_SOLTAB(tree->tr_a.tu_stp);
		return bu_strdup(tree->tr_a.tu_stp->st_dp->d_namep);
	}
		

	return bu_strdup("Unknown:tr_op");
}

/*
 *  			R T _ P R _ T R E E _ V A L
 *  
 *  Print the actual values of the terms in a boolean expression.
 *
 *  The values for pr_name determine the printing action:
 *	0	bit value
 *	1	name
 *	2	bit number
 */
void
rt_pr_tree_val(register const union tree *tp, const struct partition *partp, int pr_name, int lvl)
                              		/* Tree to print */
                      	       		/* Partition to evaluate */
   			        	/* 1=print name, 0=print value */
   			    		/* Recursion level */
{

	if( lvl == 0 )  {
		switch( pr_name )  {
		default:
			bu_log("tree val: ");
			break;
		case 1:
			bu_log("tree primitives: ");
			break;
		case 2:
			bu_log("tree primitive bits: ");
			break;
		}
	}

	if( tp == TREE_NULL )  {
		bu_log("Null???\n");
		return;
	}

	switch( tp->tr_op )  {
	default:
		bu_log("Unknown_op=x%x", tp->tr_op );
		break;

	case OP_SOLID:
		switch( pr_name )  {
		case 0:
			{
				register struct soltab *seek_stp = tp->tr_a.tu_stp;
				register struct seg **segpp;
				for( BU_PTBL_FOR( segpp, (struct seg **), &partp->pt_seglist ) )  {
					if( (*segpp)->seg_stp == seek_stp )  {
						bu_log("1");
						goto out;
					}
				}
				bu_log("0");
			}
			break;
		case 1:
			bu_log("%s", tp->tr_a.tu_stp->st_dp->d_namep );
			break;
		case 2:
			bu_log("%d", tp->tr_a.tu_stp->st_bit );
			break;
		}
		break;


	case OP_UNION:
		bu_log("(");
		rt_pr_tree_val( tp->tr_b.tb_left,  partp, pr_name, lvl+1 );
		bu_log(" u ");
		rt_pr_tree_val( tp->tr_b.tb_right, partp, pr_name, lvl+1 );
		bu_log(")");
		break;
	case OP_INTERSECT:
		bu_log("(");
		rt_pr_tree_val( tp->tr_b.tb_left,  partp, pr_name, lvl+1 );
		bu_log(" + ");
		rt_pr_tree_val( tp->tr_b.tb_right, partp, pr_name, lvl+1 );
		bu_log(")");
		break;
	case OP_SUBTRACT:
		bu_log("(");
		rt_pr_tree_val( tp->tr_b.tb_left,  partp, pr_name, lvl+1 );
		bu_log(" - ");
		rt_pr_tree_val( tp->tr_b.tb_right, partp, pr_name, lvl+1 );
		bu_log(")");
		break;
	case OP_XOR:
		bu_log("(");
		rt_pr_tree_val( tp->tr_b.tb_left,  partp, pr_name, lvl+1 );
		bu_log(" XOR ");
		rt_pr_tree_val( tp->tr_b.tb_right, partp, pr_name, lvl+1 );
		bu_log(")");
		break;

	case OP_NOT:
		bu_log(" !");
		rt_pr_tree_val( tp->tr_b.tb_left, partp, pr_name, lvl+1 );
		break;
	case OP_GUARD:
		bu_log(" GUARD ");
		rt_pr_tree_val( tp->tr_b.tb_left, partp, pr_name, lvl+1 );
		break;
	}

out:
	if( lvl == 0 )  bu_log("\n");
}

/*
 *			R T _ P R _ F A L L B A C K _ A N G L E
 */
void
rt_pr_fallback_angle(struct bu_vls *str, const char *prefix, const double *angles)
{
	BU_CK_VLS(str);

	bu_vls_printf(str, "%s direction cosines=(%1.f, %1.f, %1.f)\n",
		prefix, angles[0], angles[1], angles[2] );

	bu_vls_printf(str, "%s rotation angle=%1.f, fallback angle=%1.f\n",
		prefix, angles[3], angles[4] );
}

/*
 *			R T _ F I N D _ F A L L B A C K _ A N G L E
 *
 *  In degrees.
 */
void
rt_find_fallback_angle(double *angles, const fastf_t *vec)
{
	register double	f;
	double		asinZ;

	/* convert direction cosines into axis angles */
	if( vec[X] <= -1.0 )  {
		angles[X] = 180.0;
	} else if( vec[X] >= 1.0 )  {
		angles[X] = 0.0;
	} else {
		angles[X] = acos( vec[X] ) * bn_radtodeg;
	}

	if( vec[Y] <= -1.0 )  {
		angles[Y] = 180.0;
	} else if( vec[Y] >= 1.0 )  {
		angles[Y] = 0.0;
	} else {
		angles[Y] = acos( vec[Y] ) * bn_radtodeg;
	}

	if( vec[Z] <= -1.0 )  {
		angles[Z] = 180.0;
	} else if( vec[Z] >= 1.0 )  {
		angles[Z] = 0.0;
	} else {
		angles[Z] = acos( vec[Z] ) * bn_radtodeg;
	}

	/* fallback angle */
	if( vec[Z] <= -1.0 )  {
		/* 270 degrees:  3/2 pi */
		asinZ = bn_halfpi * 3;
	} else if( vec[Z] >= 1.0 )  {
		/* +90 degrees: 1/2 pi */
		asinZ = bn_halfpi;
	} else {
		asinZ = asin(vec[Z]);
	}
	angles[4] = asinZ * bn_radtodeg;

	/* rotation angle */
	/* For the tolerance below, on an SGI 4D/70, cos(asin(1.0)) != 0.0
	 * with an epsilon of +/- 1.0e-17, so the tolerance below was
	 * substituted for the original +/- 1.0e-20.
	 */
	if((f = cos(asinZ)) > 1.0e-16 || f < -1.0e-16 )  {
		f = vec[X]/f;
		if( f <= -1.0 )  {
			angles[3] = 180;
		} else if( f >= 1.0 ) {
			angles[3] = 0;
		} else {
			angles[3] = bn_radtodeg * acos( f );
		}
	}  else  {
		angles[3] = 0.0;
	}
	if( vec[Y] < 0 ) {
		angles[3] = 360.0 - angles[3];
	}
}

/*
 *			R T _ P R _ T O L
 *
 *  Print a tolerance structure.
 */
void
rt_pr_tol(const struct bn_tol *tol)
{
	BN_CK_TOL(tol);

	bu_log("%8.8x TOL %e (sq=%e) perp=%e, para=%e\n",
		tol, tol->dist, tol->dist_sq,
		tol->perp, tol->para );
}

/*
 *			R T _ P R _ U V C O O R D
 */
void
rt_pr_uvcoord(const struct uvcoord *uvp)
{
	bu_log("%8.8x u,v=(%g, %g), du,dv=(%g, %g)\n",
		uvp->uv_u, uvp->uv_v,
		uvp->uv_du, uvp->uv_dv );
}
@


11.40
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/pr.c,v 11.39 2004/04/05 08:48:58 morrison Exp $ (ARL)";
@


11.39
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d26 5
a30 1
#include "conf.h"
@


11.38
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.37 2002/08/20 17:08:09 jra Exp $ (ARL)";
d43 1
a43 2
rt_pr_soltab( stp )
register const struct soltab	*stp;
d67 1
a67 2
rt_pr_region( rp )
register const struct region *rp;
d105 1
a105 4
rt_pr_partitions( rtip, phead, title )
const struct rt_i		*rtip;
register const struct partition	*phead;
const char			*title;
d135 1
a135 4
rt_pr_pt_vls( v, rtip, pp )
struct bu_vls			*v;
const struct rt_i		*rtip;
register const struct partition *pp;
d197 1
a197 3
rt_pr_pt( rtip, pp )
const struct rt_i		*rtip;
register const struct partition *pp;
d213 1
a213 3
rt_pr_seg_vls( v, segp )
struct bu_vls			*v;
register const struct seg	*segp;
d233 1
a233 2
rt_pr_seg(segp)
register const struct seg *segp;
d249 1
a249 3
rt_pr_hit( str, hitp )
const char			*str;
register const struct hit	*hitp;
d265 1
a265 4
rt_pr_hit_vls( v, str, hitp )
struct bu_vls			*v;
const char			*str;
register const struct hit	*hitp;
d281 1
a281 5
rt_pr_hitarray_vls( v, str, hitp, count )
struct bu_vls			*v;
const char			*str;
register const struct hit	*hitp;
int				count;
d306 3
a308 3
rt_pr_tree( tp, lvl )
register const union tree *tp;
int lvl;			/* recursion level */
d394 1
a394 3
rt_pr_tree_vls( vls, tp )
struct bu_vls		*vls;
register const union tree *tp;
d488 1
a488 2
rt_pr_tree_str( tree )
const union tree *tree;
d560 5
a564 5
rt_pr_tree_val( tp, partp, pr_name, lvl )
register const union tree *tp;		/* Tree to print */
const struct partition	*partp;		/* Partition to evaluate */
int			pr_name;	/* 1=print name, 0=print value */
int			lvl;		/* Recursion level */
d663 1
a663 4
rt_pr_fallback_angle( str, prefix, angles )
struct bu_vls	*str;
const char	*prefix;
const double	angles[5];
d680 1
a680 3
rt_find_fallback_angle( angles, vec )
double		angles[5];
const vect_t	vec;
d750 1
a750 2
rt_pr_tol(tol)
const struct bn_tol	*tol;
d763 1
a763 2
rt_pr_uvcoord( uvp )
const struct uvcoord *uvp;
@


11.37
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1993 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.35 2002/01/10 18:12:40 butler Exp $ (ARL)";
@


11.37.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/pr.c,v 11.38 2004/02/02 17:39:28 morrison Exp $ (ARL)";
@


11.37.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.38 2004/02/02 17:39:28 morrison Exp $ (ARL)";
@


11.37.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.37.10.1 2004/02/12 18:37:47 erikg Exp $ (ARL)";
@


11.37.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.37 2002/08/20 17:08:09 jra Exp $ (ARL)";
d43 2
a44 1
rt_pr_soltab(register const struct soltab *stp)
d68 2
a69 1
rt_pr_region(register const struct region *rp)
d107 4
a110 1
rt_pr_partitions(const struct rt_i *rtip, register const struct partition *phead, const char *title)
d140 4
a143 1
rt_pr_pt_vls(struct bu_vls *v, const struct rt_i *rtip, register const struct partition *pp)
d205 3
a207 1
rt_pr_pt(const struct rt_i *rtip, register const struct partition *pp)
d223 3
a225 1
rt_pr_seg_vls(struct bu_vls *v, register const struct seg *segp)
d245 2
a246 1
rt_pr_seg(register const struct seg *segp)
d262 3
a264 1
rt_pr_hit(const char *str, register const struct hit *hitp)
d280 4
a283 1
rt_pr_hit_vls(struct bu_vls *v, const char *str, register const struct hit *hitp)
d299 5
a303 1
rt_pr_hitarray_vls(struct bu_vls *v, const char *str, register const struct hit *hitp, int count)
d328 3
a330 3
rt_pr_tree(register const union tree *tp, int lvl)
                              
        			/* recursion level */
d416 3
a418 1
rt_pr_tree_vls(struct bu_vls *vls, register const union tree *tp)
d512 2
a513 1
rt_pr_tree_str(const union tree *tree)
d585 5
a589 5
rt_pr_tree_val(register const union tree *tp, const struct partition *partp, int pr_name, int lvl)
                              		/* Tree to print */
                      	       		/* Partition to evaluate */
   			        	/* 1=print name, 0=print value */
   			    		/* Recursion level */
d688 4
a691 1
rt_pr_fallback_angle(struct bu_vls *str, const char *prefix, const double *angles)
d708 3
a710 1
rt_find_fallback_angle(double *angles, const fastf_t *vec)
d780 2
a781 1
rt_pr_tol(const struct bn_tol *tol)
d794 2
a795 1
rt_pr_uvcoord(const struct uvcoord *uvp)
@


11.37.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.36
log
@Converted from K&R to ANSI C - RFH
@
text
@d43 2
a44 1
rt_pr_soltab(register const struct soltab *stp)
d68 2
a69 1
rt_pr_region(register const struct region *rp)
d107 4
a110 1
rt_pr_partitions(const struct rt_i *rtip, register const struct partition *phead, const char *title)
d140 4
a143 1
rt_pr_pt_vls(struct bu_vls *v, const struct rt_i *rtip, register const struct partition *pp)
d205 3
a207 1
rt_pr_pt(const struct rt_i *rtip, register const struct partition *pp)
d223 3
a225 1
rt_pr_seg_vls(struct bu_vls *v, register const struct seg *segp)
d245 2
a246 1
rt_pr_seg(register const struct seg *segp)
d262 3
a264 1
rt_pr_hit(const char *str, register const struct hit *hitp)
d280 4
a283 1
rt_pr_hit_vls(struct bu_vls *v, const char *str, register const struct hit *hitp)
d299 5
a303 1
rt_pr_hitarray_vls(struct bu_vls *v, const char *str, register const struct hit *hitp, int count)
d328 3
a330 3
rt_pr_tree(register const union tree *tp, int lvl)
                              
        			/* recursion level */
d416 3
a418 1
rt_pr_tree_vls(struct bu_vls *vls, register const union tree *tp)
d512 2
a513 1
rt_pr_tree_str(const union tree *tree)
d585 5
a589 5
rt_pr_tree_val(register const union tree *tp, const struct partition *partp, int pr_name, int lvl)
                              		/* Tree to print */
                      	       		/* Partition to evaluate */
   			        	/* 1=print name, 0=print value */
   			    		/* Recursion level */
d688 4
a691 1
rt_pr_fallback_angle(struct bu_vls *str, const char *prefix, const double *angles)
d708 3
a710 1
rt_find_fallback_angle(double *angles, const fastf_t *vec)
d780 2
a781 1
rt_pr_tol(const struct bn_tol *tol)
d794 2
a795 1
rt_pr_uvcoord(const struct uvcoord *uvp)
@


11.35
log
@Changed word "solids" to indicate "prims" or primitives"
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.34 2001/11/05 21:20:06 morrison Exp $ (ARL)";
d43 1
a43 2
rt_pr_soltab( stp )
register const struct soltab	*stp;
d67 1
a67 2
rt_pr_region( rp )
register const struct region *rp;
d105 1
a105 4
rt_pr_partitions( rtip, phead, title )
const struct rt_i		*rtip;
register const struct partition	*phead;
const char			*title;
d135 1
a135 4
rt_pr_pt_vls( v, rtip, pp )
struct bu_vls			*v;
const struct rt_i		*rtip;
register const struct partition *pp;
d197 1
a197 3
rt_pr_pt( rtip, pp )
const struct rt_i		*rtip;
register const struct partition *pp;
d213 1
a213 3
rt_pr_seg_vls( v, segp )
struct bu_vls			*v;
register const struct seg	*segp;
d233 1
a233 2
rt_pr_seg(segp)
register const struct seg *segp;
d249 1
a249 3
rt_pr_hit( str, hitp )
const char			*str;
register const struct hit	*hitp;
d265 1
a265 4
rt_pr_hit_vls( v, str, hitp )
struct bu_vls			*v;
const char			*str;
register const struct hit	*hitp;
d281 1
a281 5
rt_pr_hitarray_vls( v, str, hitp, count )
struct bu_vls			*v;
const char			*str;
register const struct hit	*hitp;
int				count;
d306 3
a308 3
rt_pr_tree( tp, lvl )
register const union tree *tp;
int lvl;			/* recursion level */
d394 1
a394 3
rt_pr_tree_vls( vls, tp )
struct bu_vls		*vls;
register const union tree *tp;
d488 1
a488 2
rt_pr_tree_str( tree )
const union tree *tree;
d560 5
a564 5
rt_pr_tree_val( tp, partp, pr_name, lvl )
register const union tree *tp;		/* Tree to print */
const struct partition	*partp;		/* Partition to evaluate */
int			pr_name;	/* 1=print name, 0=print value */
int			lvl;		/* Recursion level */
d663 1
a663 4
rt_pr_fallback_angle( str, prefix, angles )
struct bu_vls	*str;
const char	*prefix;
const double	angles[5];
d680 1
a680 3
rt_find_fallback_angle( angles, vec )
double		angles[5];
const vect_t	vec;
d750 1
a750 2
rt_pr_tol(tol)
const struct bn_tol	*tol;
d763 1
a763 2
rt_pr_uvcoord( uvp )
const struct uvcoord *uvp;
@


11.34
log
@Solid to Primitive naming convention conversions
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.33 2001/04/20 22:29:55 morrison Exp $ (ARL)";
d598 1
a598 1
			bu_log("tree solids: ");
d601 1
a601 1
			bu_log("tree solid bits: ");
@


11.33
log
@CONST to const
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.32 2000/08/23 01:03:14 mike Exp $ (ARL)";
d176 1
a176 1
	bu_vls_strcat( v, "  Solids: " );
@


11.32
log
@
lint
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.31 2000/07/10 23:01:47 mike Exp $ (ARL)";
d44 1
a44 1
register CONST struct soltab	*stp;
d69 1
a69 1
register CONST struct region *rp;
d108 3
a110 3
CONST struct rt_i		*rtip;
register CONST struct partition	*phead;
CONST char			*title;
d112 1
a112 1
	register CONST struct partition *pp;
d142 2
a143 2
CONST struct rt_i		*rtip;
register CONST struct partition *pp;
d145 1
a145 1
	register CONST struct soltab	*stp;
d206 2
a207 2
CONST struct rt_i		*rtip;
register CONST struct partition *pp;
d225 1
a225 1
register CONST struct seg	*segp;
d246 1
a246 1
register CONST struct seg *segp;
d263 2
a264 2
CONST char			*str;
register CONST struct hit	*hitp;
d282 2
a283 2
CONST char			*str;
register CONST struct hit	*hitp;
d301 2
a302 2
CONST char			*str;
register CONST struct hit	*hitp;
d329 1
a329 1
register CONST union tree *tp;
d418 1
a418 1
register CONST union tree *tp;
d513 1
a513 1
CONST union tree *tree;
d586 2
a587 2
register CONST union tree *tp;		/* Tree to print */
CONST struct partition	*partp;		/* Partition to evaluate */
d690 2
a691 2
CONST char	*prefix;
CONST double	angles[5];
d710 1
a710 1
CONST vect_t	vec;
d781 1
a781 1
CONST struct bn_tol	*tol;
d795 1
a795 1
CONST struct uvcoord *uvp;
@


11.31
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.30 2000/06/30 15:27:09 pjt Exp $ (ARL)";
d517 1
a517 1
	char op;
@


11.30
log
@Changed ID_MAXIMUM to ID_MAX_SOLID
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.29 2000/06/27 21:59:37 mike Exp $ (ARL)";
@


11.29
log
@
Add magic number
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.28 2000/06/02 15:17:26 butler Exp $ (ARL)";
d48 1
a48 1
	if( id <= 0 || id > ID_MAXIMUM )  {
@


11.28
log
@Fixed typo for output format in rt_pr_fallback_angle()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.27 2000/05/23 03:42:53 mike Exp $ (ARL)";
d333 2
@


11.27
log
@
Extended rt_pr_region() to know about FASTGEN regions.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.26 2000/02/12 01:38:42 mike Exp $ (ARL)";
d693 1
a693 1
	bu_vls_printf(str, "%s direction cosines=(%.1f, %1.f, %1.f)\n",
@


11.26
log
@
Improved message
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.25 2000/01/29 04:15:54 mike Exp $ (ARL)";
d73 2
d80 5
@


11.25
log
@
Improved pretty-printing of trees in face of NULL pointers, for debugging.
Also handled pretty-printing of OP_SOLID nodes too.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.24 2000/01/13 22:00:09 mike Exp $ (ARL)";
d179 1
a179 1
	bu_vls_strcat( v, "  Untrimmed Segments Contributing:\n" );
@


11.24
log
@
Added rt_pr_uvcoord()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.23 1999/12/07 02:22:55 mike Exp $ (ARL)";
d512 1
a512 1
		return( (char *)NULL );
d556 5
d562 1
a562 1
	return (char *)NULL;
@


11.23
log
@
Failed to increment pointer while printing!
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.22 1999/12/06 16:39:46 mike Exp $ (ARL)";
d774 12
@


11.22
log
@
Added rt_pr_hitarray_vls()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.21 1999/11/26 22:39:16 mike Exp $ (ARL)";
d306 1
a306 1
	for( i=0; i<count; i++ )  {
@


11.21
log
@
lint
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.20 1999/11/13 05:07:56 mike Exp $ (ARL)";
d286 24
@


11.20
log
@
added rt_pr_seg_vls(), improved verbosity of partition debugging.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.19 1999/11/12 20:54:17 mike Exp $ (ARL)";
a37 1
BU_EXTERN(void		rt_pr_seg_vls, (struct bu_vls *, CONST struct seg *));
@


11.19
log
@
Changed from pt_solids_hit to pt_seglist; more general.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.18 1999/10/30 03:53:44 mike Exp $ (ARL)";
d38 2
d116 1
d122 1
d179 9
d214 1
a214 1
 *			R T _ P R _ S E G
d217 3
a219 2
rt_pr_seg(segp)
register CONST struct seg *segp;
d221 6
a226 2
	RT_CHECK_SEG(segp);
	bu_log("%.8x: SEG %s (%g,%g) bit=%d\n",
d231 19
a249 1
		segp->seg_stp->st_bit );
@


11.18
log
@
Added magic numbers for ray, hit, and application structures.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.17 1999/06/03 01:43:38 mike Exp $ (ARL)";
d136 1
a136 1
	register struct soltab		**spp;
d167 2
a168 2
	for( BU_PTBL_FOR( spp, (struct soltab **), &pp->pt_solids_hit ) )  {
		stp = *spp;
d546 9
a554 1
			if( bu_ptbl_locate( &partp->pt_solids_hit, (long *)(tp->tr_a.tu_stp) ) ==  -1 )
d556 1
a556 2
			else
				bu_log("1");
d607 1
@


11.17
log
@
sed4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.16 1999/05/10 21:30:48 mike Exp $ (ARL)";
d226 2
d244 1
@


11.16
log
@Variable name changed from ma_override to ma_color_valid
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.15 1998/12/17 04:19:10 mike Exp $ (ARL)";
d369 1
a369 1
		rt_free( str, "path string" );
@


11.15
log
@Regions now have an associated temperature
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/pr.c,v 11.14 1997/08/28 23:04:06 mike Exp $ (ARL)";
d77 1
a77 1
	if( rp->reg_mater.ma_override == 1 )
@


11.14
log
@When printing out a partition for debugging,
if the partition is owned by a region, print the region's name.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 11.13 1997/04/15 14:27:54 jra Exp mike $ (ARL)";
d82 2
@


11.13
log
@Fixed a bug in rt_pr_tree_str().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 11.12 1996/12/31 01:38:08 mike Exp jra $ (ARL)";
d172 5
@


11.12
log
@Moved John's pretty printer from comb.c to pr.c
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 11.11 1996/12/04 02:50:27 mike Exp mike $ (ARL)";
d446 2
d462 1
a462 3
		return_length = strlen( left ) + strlen( right ) + 4;
		if( op == 'u' )
			return_length += 4;
a463 3
		if( op == 'u' )
		{
			char *blankl,*blankr;
d465 8
a472 11
			blankl = strchr( left , ' ' );
			blankr = strchr( right , ' ' );
			if( blankl && blankr )
				sprintf( return_str , "(%s) %c (%s)" , left , op , right );
			else if( blankl && !blankr )
				sprintf( return_str , "(%s) %c %s" , left , op , right );
			else if( !blankl && blankr )
				sprintf( return_str , "%s %c (%s)" , left , op , right );
			else
				sprintf( return_str , "%s %c %s" , left , op , right );
		}
d475 1
d482 1
a482 1
	else if( tree->tr_op == OP_DB_LEAF ) {
d484 3
a486 1
	}
@


11.11
log
@Combined ma_matname and ma_matparm into a single string, ma_shader.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 11.10 1996/10/19 06:17:45 mike Exp mike $ (ARL)";
d30 1
d32 1
d423 68
@


11.10
log
@Changed to reflect that ma_matparm is now a pointer, not an array.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 11.9 1996/09/27 08:27:30 mike Exp mike $ (ARL)";
d80 2
a81 4
	if( rp->reg_mater.ma_matname && rp->reg_mater.ma_matname[0] != '\0' )
		bu_log("Material '%s' '%s'\n",
			rp->reg_mater.ma_matname,
			rp->reg_mater.ma_matparm ? rp->reg_mater.ma_matparm : "" );
@


11.9
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 11.8 1996/08/29 06:07:38 mike Exp mike $ (ARL)";
d80 1
a80 1
	if( rp->reg_mater.ma_matname[0] != '\0' )
d83 1
a83 1
			rp->reg_mater.ma_matparm );
@


11.8
log
@Expunged old bit vector routines.
pt_solids_hit is now a bu_ptbl, not a bit vector.
Changed to print solid names, rather than numbers, in pr_partition.
@
text
@d4 1
a4 1
 *  Routines to print LIBRT data structures using rt_log()
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 11.7 1996/08/28 10:03:46 mike Exp mike $ (ARL)";
d564 1
a564 1
		angles[X] = acos( vec[X] ) * rt_radtodeg;
d572 1
a572 1
		angles[Y] = acos( vec[Y] ) * rt_radtodeg;
d580 1
a580 1
		angles[Z] = acos( vec[Z] ) * rt_radtodeg;
d586 1
a586 1
		asinZ = rt_halfpi * 3;
d589 1
a589 1
		asinZ = rt_halfpi;
d593 1
a593 1
	angles[4] = asinZ * rt_radtodeg;
d607 1
a607 1
			angles[3] = rt_radtodeg * acos( f );
d624 1
a624 1
CONST struct rt_tol	*tol;
d626 1
a626 1
	RT_CK_TOL(tol);
@


11.7
log
@st_regions is now a bu_ptbl, not a bitvector.
"regionbits" is also a bu_ptbl, not a bitvector.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 11.6 1996/08/27 02:41:51 mike Exp mike $ (ARL)";
d134 1
d165 6
a170 1
	rt_pr_bitv_vls( v, pp->pt_solhit, rtip->nsolids );
a192 50
 *			R T _ P R _ B I T V _ V L S
 *
 *  Print the bits set in a bit vector.
 */
void
rt_pr_bitv_vls( v, bv, len )
struct bu_vls		*v;
register CONST bitv_t	*bv;
register int		len;
{
	register int	i;
	char		buf[128];
	int		seen = 0;

	BU_CK_VLS( v );

	bu_vls_strcat( v, "(" );
	for( i=0; i<len; i++ )  {
		if( BITTEST(bv,i) )  {
			if( seen )  bu_vls_strcat( v, ", " );
			bu_vls_printf( v, "%d", i );
			seen = 1;
		}
	}
	bu_vls_strcat( v, ") " );
}

/*
 *			R T _ P R _ B I T V
 *
 *  Print the bits set in a bit vector.
 *  Use bu_vls stuff, to make only a single call to bu_log().
 */
void
rt_pr_bitv( str, bv, len )
CONST char		*str;
register CONST bitv_t	*bv;
register int		len;
{
	struct bu_vls	v;

	bu_vls_init( &v );
	bu_vls_strcat( &v, str );
	bu_vls_strcat( &v, ": " );
	rt_pr_bitv_vls( &v, bv, len );
	bu_log("%s", bu_vls_addr( &v ) );
	bu_vls_free( &v );
}

/*
d470 4
a473 7
			{
				register int	i;

				i = tp->tr_a.tu_stp->st_bit;
				i = BITTEST( partp->pt_solhit, i );
				bu_log("%d", i);
			}
@


11.6
log
@bu.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 11.5 1996/07/12 12:10:21 jra Exp mike $ (ARL)";
d57 1
a57 2
	rt_pr_bitv( "Referenced by Regions",
		stp->st_regions, stp->st_maxreg );
@


11.5
log
@Minor Mods for IRIX 6.2
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 11.4 1996/07/02 06:09:44 mike Exp jra $ (ARL)";
d32 1
a32 1
#include "rtstring.h"
a36 24
 *			R T _ L O G I N D E N T _ V L S
 *
 *  For multi-line vls generators, honor rtg_logindent like rt_log() does.
 *  Should be called at the front of each new line.
 */
void
rt_logindent_vls( v )
struct rt_vls	*v;
{
	register int	i, todo;
	static CONST char	spaces[65] = "                                                                ";

	RT_VLS_CHECK( v );

	i = rt_g.rtg_logindent;
	while( i > 0 )  {
		todo = i;
		if( todo > 64 )  todo = 64;
		rt_vls_strncat( v, spaces, todo );
		i -= todo;
	}
}

/*
d46 1
a46 1
		rt_log("stp=x%x, id=%d.\n", stp, id);
d49 1
a49 1
	rt_log("------------ %s (bit %d) %s ------------\n",
d53 2
a54 2
	rt_log("Approx Sph Radius = %g\n", stp->st_aradius);
	rt_log("Bounding Sph Radius = %g\n", stp->st_bradius);
d69 1
a69 1
	struct rt_vls	v;
d71 2
a72 2
	rt_log("REGION %s (bit %d)\n", rp->reg_name, rp->reg_bit );
	rt_log("instnum=%d, id=%d, air=%d, gift_material=%d, los=%d\n",
d77 1
a77 1
		rt_log("Color %d %d %d\n",
d82 1
a82 1
		rt_log("Material '%s' '%s'\n",
d86 1
a86 1
	rt_vls_init(&v);
d88 3
a90 3
	rt_log("%s %d %s\n", rp->reg_name,
		rp->reg_instnum, rt_vls_addr(&v) );
	rt_vls_free(&v);
d104 1
a104 1
	struct rt_vls		v;
d108 5
a112 5
	rt_vls_init( &v );
	rt_logindent_vls( &v );
	rt_vls_strcat( &v, "------" );
	rt_vls_strcat( &v, title );
	rt_vls_strcat( &v, "\n" );
d118 2
a119 2
	rt_logindent_vls( &v );
	rt_vls_strcat( &v, "------\n");
d121 2
a122 2
	rt_log("%s", rt_vls_addr( &v ) );
	rt_vls_free( &v );
d130 1
a130 1
struct rt_vls			*v;
a134 1
	char		buf[128];
d138 1
a138 1
	RT_VLS_CHECK(v);
d140 2
a141 3
	rt_logindent_vls( v );
	sprintf(buf, "%.8x: PT ", pp );
	rt_vls_strcat( v, buf );
d144 1
a144 1
	sprintf(buf, "%s (%s#%d) ",
a147 1
	rt_vls_strcat( v, buf );
d150 1
a150 1
	sprintf(buf, "%s (%s#%d) ",
a153 1
	rt_vls_strcat( v, buf );
d155 1
a155 1
	sprintf(buf, "(%g,%g)",
d157 3
a159 4
	rt_vls_strcat( v, buf );
	if( pp->pt_inflip )  rt_vls_strcat( v, " Iflip" );
	if( pp->pt_outflip )  rt_vls_strcat( v, " Oflip" );
	rt_vls_strcat( v, "\n");
d163 2
a164 2
	rt_logindent_vls( v );
	rt_vls_strcat( v, "  Solids: " );
d166 1
a166 1
	rt_vls_strcat( v, "\n" );
d177 1
a177 1
	struct rt_vls	v;
d181 1
a181 1
	rt_vls_init( &v );
d183 2
a184 2
	rt_log("%s", rt_vls_addr( &v ) );
	rt_vls_free( &v );
d194 1
a194 1
struct rt_vls		*v;
d202 1
a202 1
	RT_VLS_CHECK( v );
d204 1
a204 1
	rt_vls_strcat( v, "(" );
d207 2
a208 3
			if( seen )  rt_vls_strcat( v, ", " );
			sprintf( buf, "%d", i );
			rt_vls_strcat( v, buf );
d212 1
a212 1
	rt_vls_strcat( v, ") " );
d219 1
a219 1
 *  Use rt_vls stuff, to make only a single call to rt_log().
d227 1
a227 1
	struct rt_vls	v;
d229 3
a231 3
	rt_vls_init( &v );
	rt_vls_strcat( &v, str );
	rt_vls_strcat( &v, ": " );
d233 2
a234 2
	rt_log("%s", rt_vls_addr( &v ) );
	rt_vls_free( &v );
d245 1
a245 1
	rt_log("%.8x: SEG %s (%g,%g) bit=%d\n",
d261 1
a261 1
	struct rt_vls		v;
d263 1
a263 1
	rt_vls_init( &v );
d265 2
a266 2
	rt_log("%s", rt_vls_addr( &v ) );
	rt_vls_free( &v );
d274 1
a274 1
struct rt_vls			*v;
d278 1
a278 1
	char		buf[128];
d280 2
a281 1
	RT_VLS_CHECK( v );
d283 1
a283 4
	rt_logindent_vls( v );
	rt_vls_strcat( v, str );

	sprintf(buf, "HIT dist=%g (surf %d)\n",
a284 1
	rt_vls_strcat( v, buf );
d302 1
a302 1
	rt_log("%.8x ", tp);
d304 1
a304 1
		rt_log("  ");
d307 1
a307 1
		rt_log("Null???\n");
d314 1
a314 1
		rt_log("NOP\n");
d318 1
a318 1
		rt_log("SOLID %s (bit %d)\n",
d324 1
a324 1
		rt_log("REGION ctsp=x%x\n", tp->tr_c.tc_ctsp );
d329 1
a329 1
		rt_log("DB_LEAF %s%s\n",
d335 1
a335 1
		rt_log("Unknown op=x%x\n", tp->tr_op );
d339 1
a339 1
		rt_log("UNION\n");
d342 1
a342 1
		rt_log("INTERSECT\n");
d345 1
a345 1
		rt_log("MINUS\n");
d348 1
a348 1
		rt_log("XOR\n");
d351 1
a351 1
		rt_log("NOT\n");
d383 1
a383 1
struct rt_vls		*vls;
d389 1
a389 1
		rt_vls_strcat( vls, "??NULL_tree??" );
d396 1
a396 1
		rt_vls_strcat( vls, "NOP");
d400 1
a400 1
		rt_vls_strcat( vls, tp->tr_a.tu_stp->st_dp->d_namep );
d405 1
a405 1
		rt_vls_strcat( vls, str );
d410 1
a410 1
		rt_vls_strcat( vls, tp->tr_l.tl_name );
d414 1
a414 1
		rt_log("rt_pr_tree_vls() Unknown op=x%x\n", tp->tr_op );
d419 1
a419 1
		rt_vls_strcat( vls, " (" );
d421 1
a421 1
		rt_vls_strcat( vls, ") u (" );
d423 1
a423 1
		rt_vls_strcat( vls, ") " );
d427 1
a427 1
		rt_vls_strcat( vls, " (" );
d429 1
a429 1
		rt_vls_strcat( vls, ") + (" );
d431 1
a431 1
		rt_vls_strcat( vls, ") " );
d435 1
a435 1
		rt_vls_strcat( vls, " (" );
d437 1
a437 1
		rt_vls_strcat( vls, ") - (" );
d439 1
a439 1
		rt_vls_strcat( vls, ") " );
d443 1
a443 1
		rt_vls_strcat( vls, " (" );
d445 1
a445 1
		rt_vls_strcat( vls, ") ^ (" );
d447 1
a447 1
		rt_vls_strcat( vls, ") " );
d451 1
a451 1
		rt_vls_strcat( vls, " !(" );
d453 1
a453 1
		rt_vls_strcat( vls, ") " );
d457 1
a457 1
		rt_vls_strcat( vls, " guard(" );
d459 1
a459 1
		rt_vls_strcat( vls, ") " );
d463 1
a463 1
		rt_vls_strcat( vls, " xnop(" );
d465 1
a465 1
		rt_vls_strcat( vls, ") " );
d491 1
a491 1
			rt_log("tree val: ");
d494 1
a494 1
			rt_log("tree solids: ");
d497 1
a497 1
			rt_log("tree solid bits: ");
d503 1
a503 1
		rt_log("Null???\n");
d509 1
a509 1
		rt_log("Unknown_op=x%x", tp->tr_op );
d520 1
a520 1
				rt_log("%d", i);
d524 1
a524 1
			rt_log("%s", tp->tr_a.tu_stp->st_dp->d_namep );
d527 1
a527 1
			rt_log("%d", tp->tr_a.tu_stp->st_bit );
d534 1
a534 1
		rt_log("(");
d536 1
a536 1
		rt_log(" u ");
d538 1
a538 1
		rt_log(")");
d541 1
a541 1
		rt_log("(");
d543 1
a543 1
		rt_log(" + ");
d545 1
a545 1
		rt_log(")");
d548 1
a548 1
		rt_log("(");
d550 1
a550 1
		rt_log(" - ");
d552 1
a552 1
		rt_log(")");
d555 1
a555 1
		rt_log("(");
d557 1
a557 1
		rt_log(" XOR ");
d559 1
a559 1
		rt_log(")");
d563 1
a563 1
		rt_log(" !");
d567 1
a567 1
		rt_log(" GUARD ");
d572 1
a572 1
	if( lvl == 0 )  rt_log("\n");
a575 40
 *			R T _ P R I N T B
 *
 *  Print a value a la the %b format of the kernel's printf
 *
 *    s		title string
 *    v		the integer with the bits in it
 *    bits	a string which starts with the desired base, then followed by
 *		words preceeded with embedded low-value bytes indicating
 *		bit number plus one,
 *		in little-endian order, eg:
 *		"\010\2Bit_one\1BIT_zero"
 */
void
rt_printb(s, v, bits)
CONST char		*s;
register unsigned long	v;
register CONST char	*bits;
{
	register int i, any = 0;
	register char c;

	if (*bits++ == 8)
		rt_log("%s=0%o <", s, v);
	else
		rt_log("%s=x%x <", s, v);
	while (i = *bits++) {
		if (v & (1L << (i-1))) {
			if (any)
				rt_log(",");
			any = 1;
			for (; (c = *bits) > 32; bits++)
				rt_log("%c", c);
		} else
			for (; *bits > 32; bits++)
				;
	}
	rt_log(">");
}

/*
d580 1
a580 1
struct rt_vls	*str;
d584 1
a584 1
	char		buf[256];
d586 1
a586 1
	sprintf(buf, "%s direction cosines=(%.1f, %1.f, %1.f)\n",
a587 1
	rt_vls_strcat( str, buf );
d589 1
a589 1
	sprintf(buf, "%s rotation angle=%1.f, fallback angle=%1.f\n",
a590 1
	rt_vls_strcat( str, buf );
d676 1
a676 1
	rt_log("%8.8x TOL %e (sq=%e) perp=%e, para=%e\n",
@


11.4
log
@Added handling for OP_DB_LEAF
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 11.3 1996/07/02 05:51:52 mike Exp mike $ (ARL)";
d47 1
a47 1
	CONST static char	spaces[65] = "                                                                ";
@


11.3
log
@Added support for OP_DB_LEAF
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 11.2 1996/03/29 21:36:55 mike Exp mike $ (ARL)";
d74 1
a74 1
		stp->st_name, stp->st_bit,
d277 1
a277 1
		segp->seg_stp->st_name,
d352 1
a352 1
			tp->tr_a.tu_stp->st_name,
d433 1
a433 1
		rt_vls_strcat( vls, tp->tr_a.tu_stp->st_name );
d442 4
d557 1
a557 1
			rt_log("%s", tp->tr_a.tu_stp->st_name );
@


11.2
log
@Don't print hit_point and hit_normal in rt_pr_hit().
They are going away.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 11.1 1995/01/04 09:58:28 mike Rel4_4 mike $ (ARL)";
d359 6
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 10.5 94/11/04 06:02:28 mike Exp $ (ARL)";
a317 13

	if( !VNEAR_ZERO( hitp->hit_point, SMALL_FASTF ) )  {
		rt_logindent_vls( v );
		sprintf(buf, "    Point (%g, %g, %g)\n",
			V3ARGS(hitp->hit_point) );
		rt_vls_strcat( v, buf );
	}
	if( !VNEAR_ZERO( hitp->hit_normal, SMALL_FASTF ) )  {
		rt_logindent_vls( v );
		sprintf(buf, "    Normal (%g, %g, %g)\n",
			V3ARGS(hitp->hit_normal) );
		rt_vls_strcat( v, buf );
	}
@


10.5
log
@Irix 6
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 10.4 94/08/10 19:40:52 gdurf Exp Locker: mike $ (ARL)";
@


10.4
log
@Added include of conf.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 10.3 1993/09/30 20:54:32 mike Exp gdurf $ (ARL)";
a206 1
	char		buf[128];
a256 1
	register int	i;
@


10.3
log
@Pulled in rt_pr_tol
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d25 2
@


10.2
log
@Moved declarations to raytrace.h
Made some args CONST.
@
text
@d10 2
a11 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d13 5
d19 2
a20 2
 *	This software is Copyright (C) 1989 by the United States Army.
 *	All rights reserved.
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 10.1 91/10/12 06:40:56 mike Rel4_0 Locker: mike $ (BRL)";
d741 16
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 1.14 91/08/19 21:57:41 mike Exp $ (BRL)";
a29 9
/* XXX Move these to raytrace.h */
RT_EXTERN(void rt_pr_tree_vls, (struct rt_vls *vls, CONST union tree *tp));
RT_EXTERN(void rt_pr_hit_vls, (struct rt_vls *v, CONST char *str,
	CONST struct hit *hitp));
RT_EXTERN(void rt_pr_pt_vls, (struct rt_vls *v, CONST struct rt_i *rtip,
	CONST struct partition *pp));
RT_EXTERN(void rt_pr_bitv_vls, (struct rt_vls *v, CONST bitv_t *bv, int len));
RT_EXTERN(void rt_logindent_vls, (struct rt_vls	*v));

d653 2
a654 2
char		*prefix;
double		angles[5];
d675 1
a675 1
vect_t		vec;
d707 2
a708 1
		vec[Z] = -1.0;
d710 4
a713 1
		vec[Z] = 1.0;
a714 1
	asinZ = asin(vec[Z]);
@


1.14
log
@Slightly neatened partition printing.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 1.13 91/07/23 16:18:11 mike Exp $ (BRL)";
@


1.13
log
@Changed some routines over to vls support,
to reduce the number of calls to rt_log().
This is especially helpful for remote logging, such as in remrt
and xpa.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 1.12 91/07/17 01:27:43 mike Exp $ (BRL)";
d161 1
d171 16
a186 4
	rt_vls_strcat( v, pp->pt_inseg->seg_stp->st_dp->d_namep );
	rt_vls_strcat( v, " " );
	rt_vls_strcat( v, pp->pt_outseg->seg_stp->st_dp->d_namep );
	sprintf(buf, " (%g,%g)",
d193 2
a194 2
	rt_pr_hit_vls( v, " In hit", pp->pt_inhit );
	rt_pr_hit_vls( v, "Out hit", pp->pt_outhit );
d196 1
a196 1
	rt_vls_strcat( v, "Solids present: " );
a317 1
	rt_vls_strcat( v, "HIT " );
d320 1
a320 1
	sprintf(buf, " dist=%g (surf %d)\n",
d326 1
a326 1
		sprintf(buf, "HIT Point (%g, %g, %g)\n",
d332 1
a332 1
		sprintf(buf, "HIT Normal (%g, %g, %g)\n",
@


1.12
log
@Changed rt_pr_region to use rt_pr_tree_vls().
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 1.11 91/07/17 01:22:14 mike Exp $ (BRL)";
d30 1
d32 6
d39 12
d52 11
d131 1
d135 6
a140 1
	rt_log("------%s\n", title);
d143 1
a143 1
		rt_pr_pt(rtip, pp);
d145 5
a149 1
	rt_log("------\n");
d153 36
d196 3
d201 5
d207 27
a233 11
	rt_log("%.8x: PT %s %s (%g,%g)",
		pp,
		pp->pt_inseg->seg_stp->st_name,
		pp->pt_outseg->seg_stp->st_name,
		pp->pt_inhit->hit_dist, pp->pt_outhit->hit_dist );
	rt_log("%s%s\n",
		pp->pt_inflip ? " Iflip" : "",
		pp->pt_outflip ?" Oflip" : "" );
	rt_pr_hit( " In hit", pp->pt_inhit );
	rt_pr_hit( "Out hit", pp->pt_outhit );
	rt_pr_bitv( "Solids present", pp->pt_solhit, rtip->nsolids );
d240 1
d248 9
a256 6
	register int i;
	rt_log("%s: ", str);
	for( i=0; i<len; i++ )
		if( BITTEST(bv,i) )
			rt_log("%d, ", i );
	rt_log("\n");
d283 34
a316 4
	rt_log("HIT %s dist=%g (surf %d)\n",
		str, hitp->hit_dist, hitp->hit_surfno );
	if( !VNEAR_ZERO( hitp->hit_point, SQRT_SMALL_FASTF ) )  {
		VPRINT("HIT Point ", hitp->hit_point );
d318 5
a322 2
	if( !VNEAR_ZERO( hitp->hit_normal, SQRT_SMALL_FASTF ) )  {
		VPRINT("HIT Normal", hitp->hit_normal );
@


1.11
log
@Added  rt_pr_tree_vls
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 1.10 91/06/29 22:27:21 mike Exp $ (BRL)";
d30 1
d32 1
d66 2
d82 6
a87 2
	rt_pr_tree( rp->reg_treetop, 0 );
	rt_log("\n");
@


1.10
log
@Bloody SGI compiler insists on "register" before "const".
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 1.9 91/06/29 22:14:05 mike Exp $ (BRL)";
d26 1
d257 93
@


1.9
log
@ANSI lint
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 1.8 91/06/29 15:50:54 mike Exp $ (BRL)";
d88 2
a89 2
CONST register struct partition *phead;
CONST char *title;
d109 1
a109 1
CONST register struct partition *pp;
@


1.8
log
@Changed rt_pr_tree() to know about new union member.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 1.7 91/03/13 16:42:28 mike Exp $ (BRL)";
d35 1
a35 1
register struct soltab	*stp;
d61 1
a61 1
register struct region *rp;
d87 3
a89 3
struct rt_i		*rtip;
register struct partition *phead;
char *title;
d91 1
a91 1
	register struct partition *pp;
d108 2
a109 2
struct rt_i		*rtip;
register struct partition *pp;
d134 3
a136 3
char *str;
register bitv_t *bv;
register int len;
d151 1
a151 1
register struct seg *segp;
d167 2
a168 2
char *str;
register struct hit *hitp;
d190 1
a190 1
register union tree *tp;
d272 2
a273 2
register union tree	*tp;		/* Tree to print */
struct partition	*partp;		/* Partition to evaluate */
d380 3
a382 3
char *s;
register unsigned long v;
register char *bits;
@


1.7
log
@Modified to print hit points in partition lists.
Changed pr_hit to only print hits & normals when the are non-zero,
i.e., when they have been filled in.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 1.6 91/01/11 06:55:12 mike Exp $ (BRL)";
d217 2
a218 2
		rt_log("REGION 'stp'=x%x\n",
			tp->tr_a.tu_stp );
@


1.6
log
@Fixed long-standing brain failure about acos()
(This code came from mged/edsol.c, bug was introduced in rev 6.2).
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 1.5 91/01/11 06:05:21 mike Exp $ (BRL)";
d122 3
a124 1
	rt_pr_bitv( "Solids", pp->pt_solhit, rtip->nsolids );
d170 8
a177 3
	rt_log("HIT %s dist=%g\n", str, hitp->hit_dist );
	VPRINT("HIT Point ", hitp->hit_point );
	VPRINT("HIT Normal", hitp->hit_normal );
@


1.5
log
@Added fallback angle routines
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/pr.c,v 1.4 90/04/12 04:00:12 mike Exp $ (BRL)";
d23 1
d432 7
a438 3
	if( vec[X] <= -1.0 )  angles[X] = -90.0;
	else if( vec[X] >= 1.0 )  angles[X] = 90.0;
	else angles[X] = acos( vec[X] ) * rt_radtodeg;
d440 7
a446 3
	if( vec[Y] <= -1.0 )  angles[Y] = -90.0;
	else if( vec[Y] >= 1.0 )  angles[Y] = 90.0;
	else angles[Y] = acos( vec[Y] ) * rt_radtodeg;
d448 7
a454 3
	if( vec[Z] <= -1.0 )  angles[Z] = -90.0;
	else if( vec[Z] >= 1.0 )  angles[Z] = 90.0;
	else angles[Z] = acos( vec[Z] ) * rt_radtodeg;
d457 5
a461 2
	if( vec[Z] <= -1.0 )  vec[Z] = -1.0;
	else if( vec[Z] >= 1.0 )  vec[Z] = 1.0;
d472 1
a472 1
		if( f <= -1.0 )
d474 1
a474 1
		else if( f >= 1.0 )
d476 1
a476 1
		else
d478 2
a479 1
	}  else
d481 2
a482 1
	if( vec[Y] < 0 )
d484 1
@


1.4
log
@Changed to accomodate some new tree nodes
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pr.c,v 1.3 90/01/05 04:15:43 mike Locked $ (BRL)";
d395 71
@


1.3
log
@Added rt_pr_tree_val() which can print boolean trees in compact notation,
giving either solid bit number, solid name, or bit values in the
current partition.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pr.c,v 1.2 90/01/04 21:45:05 mike Locked $ (BRL)";
d198 4
d206 1
a206 1
		break;
d208 5
a234 2
	case OP_SOLID:
		break;
d245 1
@


1.2
log
@Eliminated one unnecessary call to rt_log().
Especially important for remrt operation.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: pr.c,v 1.1 89/12/31 00:13:25 mike Locked $ (BRL)";
d174 5
d242 105
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d194 1
a194 1
		rt_log("SOLID %s (bit %d)",
d204 1
a204 1
		rt_log("UNION");
d207 1
a207 1
		rt_log("INTERSECT");
d210 1
a210 1
		rt_log("MINUS");
d213 1
a213 1
		rt_log("XOR");
d216 1
a216 1
		rt_log("NOT");
a218 1
	rt_log("\n");
@
