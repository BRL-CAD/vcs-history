head	11.77;
access;
symbols
	ansi-20040405-merged:11.64.2.2
	postmerge-20040405-ansi:11.75
	premerge-20040404-ansi:11.74
	postmerge-autoconf:11.74
	autoconf-freeze:11.70.2.4
	premerge-autoconf:11.74
	ansi-20040316-freeze:11.64.2.1
	postmerge-20040315-windows:11.74
	premerge-20040315-windows:11.74
	windows-20040315-freeze:11.64.4.1
	autoconf-20031203:11.70.2.1
	autoconf-20031202:11.70
	autoconf-branch:11.70.0.2
	phong-branch:11.67.0.4
	photonmap-branch:11.67.0.2
	rel-6-1-DP:11.65
	windows-branch:11.64.0.4
	rel-6-0-2:11.61
	ansi-branch:11.64.0.2
	rel-6-0-1-branch:11.61.0.2
	hartley-6-0-post:11.62
	hartley-6-0-pre:11.61
	rel-6-0-1:11.61
	rel-6-0:11.61
	rel-5-4:11.54
	offsite-5-3-pre:11.57
	rel-5-3:11.54
	rel-5-2:11.54
	rel-5-1-branch:11.54.0.2
	rel-5-1:11.54
	rel-5-0:11.33
	rel-5-0-beta:11.33
	rel-4-5:11.30
	ctj-4-5-post:11.23
	ctj-4-5-pre:11.19
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.77
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	11.76;

11.76
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.75;

11.75
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.74;

11.74
date	2004.03.03.21.27.19;	author morrison;	state Exp;
branches;
next	11.73;

11.73
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	11.72;

11.72
date	2003.11.16.01.29.19;	author jra;	state Exp;
branches;
next	11.71;

11.71
date	2003.10.29.16.20.41;	author jra;	state Exp;
branches;
next	11.70;

11.70
date	2003.10.07.01.23.49;	author morrison;	state Exp;
branches
	11.70.2.1;
next	11.69;

11.69
date	2003.09.12.14.41.35;	author jra;	state Exp;
branches;
next	11.68;

11.68
date	2003.09.11.15.15.07;	author jra;	state Exp;
branches;
next	11.67;

11.67
date	2003.03.08.04.33.24;	author jra;	state Exp;
branches
	11.67.4.1;
next	11.66;

11.66
date	2003.01.16.16.25.57;	author jra;	state Exp;
branches;
next	11.65;

11.65
date	2002.09.30.14.02.27;	author jra;	state Exp;
branches;
next	11.64;

11.64
date	2002.09.03.16.26.55;	author jra;	state Exp;
branches
	11.64.2.1
	11.64.4.1;
next	11.63;

11.63
date	2002.08.20.17.07.56;	author jra;	state Exp;
branches;
next	11.62;

11.62
date	2002.08.15.20.55.07;	author hartley;	state Exp;
branches;
next	11.61;

11.61
date	2002.01.10.18.12.40;	author butler;	state Exp;
branches;
next	11.60;

11.60
date	2001.12.18.15.44.35;	author jra;	state Exp;
branches;
next	11.59;

11.59
date	2001.05.17.20.05.23;	author morrison;	state Exp;
branches;
next	11.58;

11.58
date	2001.04.05.19.35.33;	author morrison;	state Exp;
branches;
next	11.57;

11.57
date	2000.08.21.02.02.28;	author butler;	state Exp;
branches;
next	11.56;

11.56
date	2000.07.13.02.36.25;	author cjohnson;	state Exp;
branches;
next	11.55;

11.55
date	2000.07.10.23.01.26;	author mike;	state Exp;
branches;
next	11.54;

11.54
date	2000.05.19.05.05.20;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	2000.05.19.04.58.14;	author mike;	state Exp;
branches;
next	11.52;

11.52
date	2000.05.19.04.40.15;	author mike;	state Exp;
branches;
next	11.51;

11.51
date	2000.05.17.04.09.48;	author mike;	state Exp;
branches;
next	11.50;

11.50
date	2000.05.12.19.16.40;	author mike;	state Exp;
branches;
next	11.49;

11.49
date	2000.05.12.19.10.38;	author mike;	state Exp;
branches;
next	11.48;

11.48
date	2000.05.11.21.01.58;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	2000.05.11.03.33.24;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	2000.05.11.03.20.28;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	2000.05.10.19.29.10;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	2000.05.10.19.20.33;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	2000.05.10.02.52.26;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	2000.05.10.02.30.27;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	2000.05.10.01.46.11;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	2000.05.10.01.02.25;	author mike;	state Exp;
branches;
next	11.39;

11.39
date	2000.05.10.00.46.15;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	2000.04.15.02.04.14;	author mike;	state Exp;
branches;
next	11.37;

11.37
date	2000.04.12.02.04.25;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	2000.02.10.05.06.41;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	2000.02.10.05.02.18;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	99.12.22.02.01.50;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	99.05.27.18.53.48;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	98.04.15.04.54.36;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	98.03.19.11.50.51;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	98.01.06.07.17.27;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	97.12.16.00.12.31;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	97.11.30.19.20.27;	author cjohnson;	state Exp;
branches;
next	11.27;

11.27
date	97.11.21.21.00.11;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	97.10.09.02.56.16;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	97.09.10.18.46.54;	author gdurf;	state Exp;
branches;
next	11.24;

11.24
date	97.09.09.21.26.49;	author gdurf;	state Exp;
branches;
next	11.23;

11.23
date	97.09.04.21.22.09;	author gdurf;	state Exp;
branches;
next	11.22;

11.22
date	97.08.29.00.56.39;	author gdurf;	state Exp;
branches;
next	11.21;

11.21
date	97.08.20.19.22.56;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	97.08.20.19.13.16;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	97.07.23.07.09.35;	author gdurf;	state Exp;
branches;
next	11.18;

11.18
date	97.07.22.01.15.12;	author gdurf;	state Exp;
branches;
next	11.17;

11.17
date	97.07.10.18.08.48;	author gdurf;	state Exp;
branches;
next	11.16;

11.16
date	97.06.30.13.34.32;	author gdurf;	state Exp;
branches;
next	11.15;

11.15
date	97.06.13.02.52.30;	author gdurf;	state Exp;
branches;
next	11.14;

11.14
date	97.06.12.17.35.52;	author gdurf;	state Exp;
branches;
next	11.13;

11.13
date	97.06.12.15.22.52;	author gdurf;	state Exp;
branches;
next	11.12;

11.12
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	96.09.24.05.15.13;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	96.08.31.04.20.54;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.08.31.02.19.01;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	96.08.28.10.01.26;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.07.12.18.08.12;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.11.07.20.24.17;	author adam;	state Exp;
branches;
next	11.5;

11.5
date	95.10.31.22.31.25;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.10.31.21.52.39;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.03.18.05.47.00;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.03.18.04.18.52;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.12;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.12.27.18.42.47;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.12.27.16.29.16;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.12.19.15.51.24;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	94.10.31.21.56.25;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.10.18.02.08.27;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.10.15.40.13;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.58;	author mike;	state Rel4_0;
branches;
next	9.24;

9.24
date	91.09.20.22.37.47;	author butler;	state Exp;
branches;
next	9.23;

9.23
date	91.06.30.23.17.56;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.06.30.20.14.02;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	91.06.30.19.07.22;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.06.29.21.40.41;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.06.24.23.44.28;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.06.24.22.58.29;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	90.12.22.02.23.36;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	90.12.19.06.19.29;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	90.12.18.20.42.56;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	90.12.18.05.43.09;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.12.18.00.14.36;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.12.15.04.54.10;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.12.15.03.12.42;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.12.14.20.24.20;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.10.07.21.38.14;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.05.21.14.22.00;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.04.27.02.14.39;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.01.11.07.25.29;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.01.06.01.22.59;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.01.05.19.09.49;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.01.05.18.52.45;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.10.42;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.54.01;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.31.06;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.09.17.07.53.41;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.05.14.00.47.36;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.05.14.00.00.59;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.22.22.12.08;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.33.10;	author mike;	state Rel;
branches;
next	6.3;

6.3
date	87.09.17.07.03.09;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.09.04.18.59.07;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.55.32;	author mike;	state Rel;
branches;
next	5.3;

5.3
date	87.07.02.05.40.55;	author mike;	state Exp;
branches;
next	5.2;

5.2
date	87.06.27.03.40.50;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.11.08;	author mike;	state Rel;
branches;
next	4.5;

4.5
date	87.04.01.04.46.41;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.03.23.23.42.20;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.03.19.04.59.35;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.12.22.11.02;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.44.53;	author mike;	state Rel1;
branches;
next	3.8;

3.8
date	86.12.19.04.09.47;	author mike;	state Exp;
branches;
next	3.7;

3.7
date	86.08.12.04.15.25;	author mike;	state Exp;
branches;
next	3.6;

3.6
date	86.08.03.03.35.09;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.07.30.03.54.46;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.07.22.03.20.24;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.19.04.39.26;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.18.00.21.44;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.11.01.31.49;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.32.53;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	86.06.09.21.50.13;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.09.11.17.49.52;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.06.02.28.37;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.03.49;	author mike;	state Exp;
branches;
next	;

11.64.2.1
date	2002.09.19.18.01.29;	author morrison;	state Exp;
branches;
next	11.64.2.2;

11.64.2.2
date	2004.03.17.21.18.42;	author morrison;	state Exp;
branches;
next	;

11.64.4.1
date	2004.03.11.23.43.35;	author morrison;	state Exp;
branches;
next	;

11.67.4.1
date	2003.09.13.18.02.22;	author butler;	state Exp;
branches;
next	;

11.70.2.1
date	2003.12.03.16.24.06;	author erikg;	state Exp;
branches;
next	11.70.2.2;

11.70.2.2
date	2004.02.12.18.37.38;	author erikg;	state Exp;
branches;
next	11.70.2.3;

11.70.2.3
date	2004.03.10.13.18.35;	author erikg;	state Exp;
branches;
next	11.70.2.4;

11.70.2.4
date	2004.03.15.14.07.16;	author erikg;	state Exp;
branches;
next	;


desc
@Routines for space partitioning.
@


11.77
log
@moved to src/
@
text
@/*
 *  			C U T . C
 *  
 *  Cut space into lots of small boxes (RPPs actually).
 *  
 *  Call tree for default path through the code:
 *	rt_cut_it()
 *		rt_cut_extend() for all solids in model
 *		rt_ct_optim()
 *			rt_ct_old_assess()
 *			rt_ct_box()
 *				rt_ct_populate_box()
 *					rt_ck_overlap()
 *  
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCScut[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/cut.c,v 11.76 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "nmg.h"
#include "plot3.h"
#include "./debug.h"

HIDDEN int		rt_ck_overlap BU_ARGS((const vect_t min,
					       const vect_t max,
					       const struct soltab *stp,
					       const struct rt_i *rtip));
HIDDEN int		rt_ct_box BU_ARGS((struct rt_i *rtip,
					   union cutter *cutp,
					   int axis, double where, int force));
HIDDEN void		rt_ct_optim BU_ARGS((struct rt_i *rtip,
					     union cutter *cutp, int depth));
HIDDEN void		rt_ct_free BU_ARGS((struct rt_i *rtip,
					    union cutter *cutp));
HIDDEN void		rt_ct_release_storage BU_ARGS((union cutter *cutp));

HIDDEN void		rt_ct_measure BU_ARGS((struct rt_i *rtip,
					       union cutter *cutp, int depth));
HIDDEN union cutter	*rt_ct_get BU_ARGS((struct rt_i *rtip));
void		rt_plot_cut BU_ARGS((FILE *fp, struct rt_i *rtip,
					     union cutter *cutp, int lvl));

BU_EXTERN(void		rt_pr_cut_info, (const struct rt_i *rtip,
					const char *str));
HIDDEN int		rt_ct_old_assess(register union cutter *,
					 register int,
					 double *,
					 double *);

#define AXIS(depth)	((depth)%3)	/* cuts: X, Y, Z, repeat */

/*
 *			R T _ C U T _ O N E _ A X I S
 *
 *  As a temporary aid until NUgrid is working, use NUgrid
 *  histogram to perform a preliminary partitioning of space,
 *  along a single axis.
 *  The tree built here is expected to be further refined.
 *  The bu_ptbl "boxes" contains a list of the boxnodes, for convenience.
 *
 *  Each span runs from [min].nu_spos to [max].nu_epos.
 */
union cutter *
rt_cut_one_axis(struct bu_ptbl *boxes, struct rt_i *rtip, int axis, int min, int max, struct nugridnode *nuginfop)
{
	register struct soltab *stp;
	union cutter	*box;
	int	cur;
	int	slice;

	BU_CK_PTBL(boxes);
	RT_CK_RTI(rtip);

	if( min == max )  {
		/* Down to one cell, generate a boxnode */
		slice = min;
		box = (union cutter *)bu_calloc( 1, sizeof(union cutter),
			"union cutter");
		box->bn.bn_type = CUT_BOXNODE;
		box->bn.bn_len = 0;
		box->bn.bn_maxlen = rtip->nsolids;
		box->bn.bn_list = (struct soltab **)bu_malloc(
			box->bn.bn_maxlen * sizeof(struct soltab *),
			"xbox boxnode []" );
		VMOVE( box->bn.bn_min, rtip->mdl_min );
		VMOVE( box->bn.bn_max, rtip->mdl_max );
		box->bn.bn_min[axis] = nuginfop->nu_axis[axis][slice].nu_spos;
		box->bn.bn_max[axis] = nuginfop->nu_axis[axis][slice].nu_epos;
		box->bn.bn_len = 0;

		/* Search all solids for those in this slice */
		RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
			RT_CHECK_SOLTAB(stp);
			if( !rt_ck_overlap( box->bn.bn_min, box->bn.bn_max,
					    stp, rtip ) )
				continue;
			box->bn.bn_list[box->bn.bn_len++] = stp;
		} RT_VISIT_ALL_SOLTABS_END

		bu_ptbl_ins( boxes, (long *)box );
		return box;
	}

	cur = (min + max + 1) / 2;
	/* Recurse on both sides, then build a cutnode */
	box = (union cutter *)bu_calloc( 1, sizeof(union cutter),
		"union cutter");
	box->cn.cn_type = CUT_CUTNODE;
	box->cn.cn_axis = axis;
	box->cn.cn_point = nuginfop->nu_axis[axis][cur].nu_spos;
	box->cn.cn_l = rt_cut_one_axis( boxes, rtip, axis, min, cur-1, nuginfop );
	box->cn.cn_r = rt_cut_one_axis( boxes, rtip, axis, cur, max, nuginfop );
	return box;
}

/*
 *			R T _ C U T _ O P T I M I Z E _ P A R A L L E L
 *
 *  Process all the nodes in the global array rtip->rti_cuts_waiting,
 *  until none remain.
 *  This routine is run in parallel.
 */
void
rt_cut_optimize_parallel(int cpu, genptr_t arg)
{
	struct rt_i	*rtip = (struct rt_i *)arg;
	union cutter	*cp;
	int		i;

	RT_CK_RTI(rtip);
	for(;;)  {

		bu_semaphore_acquire( RT_SEM_WORKER );
		i = rtip->rti_cuts_waiting.end--;	/* get first free index */
		bu_semaphore_release( RT_SEM_WORKER );
		i -= 1;				/* change to last used index */

		if( i < 0 )  break;

		cp = (union cutter *)BU_PTBL_GET( &rtip->rti_cuts_waiting, i );

		rt_ct_optim( rtip, cp, Z );
	}
}

#define CMP(_p1,_p2,_memb,_ind) \
	(*(const struct soltab **)(_p1))->_memb[_ind] < \
	(*(const struct soltab **)(_p2))->_memb[_ind] ? -1 : \
	(*(const struct soltab **)(_p1))->_memb[_ind] > \
	(*(const struct soltab **)(_p2))->_memb[_ind] ? 1 : 0
	
/* Functions for use with qsort */
HIDDEN int rt_projXmin_comp BU_ARGS((const void * p1, const void * p2));
HIDDEN int rt_projXmax_comp BU_ARGS((const void * p1, const void * p2));
HIDDEN int rt_projYmin_comp BU_ARGS((const void * p1, const void * p2));
HIDDEN int rt_projYmax_comp BU_ARGS((const void * p1, const void * p2));
HIDDEN int rt_projZmin_comp BU_ARGS((const void * p1, const void * p2));
HIDDEN int rt_projZmax_comp BU_ARGS((const void * p1, const void * p2));

HIDDEN int
rt_projXmin_comp(const void *p1, const void *p2)
{
	return CMP(p1,p2,st_min,X);
}

HIDDEN int
rt_projXmax_comp(const void *p1, const void *p2)
{
	return CMP(p1,p2,st_max,X);
}

HIDDEN int
rt_projYmin_comp(const void *p1, const void *p2)
{
	return CMP(p1,p2,st_min,Y);
}

HIDDEN int
rt_projYmax_comp(const void *p1, const void *p2)
{
	return CMP(p1,p2,st_max,Y);
}

HIDDEN int
rt_projZmin_comp(const void *p1, const void *p2)
{
	return CMP(p1,p2,st_min,Z);
}

HIDDEN int
rt_projZmax_comp(const void *p1, const void *p2)
{
	return CMP(p1,p2,st_max,Z);
}

HIDDEN struct cmp_pair {
	int (*cmp_min) BU_ARGS((const void *, const void *));
	int (*cmp_max) BU_ARGS((const void *, const void *));
} pairs[] = {
	{ rt_projXmin_comp, rt_projXmax_comp },
	{ rt_projYmin_comp, rt_projYmax_comp },
	{ rt_projZmin_comp, rt_projZmax_comp }
};

/*
 *			R T _ N U G R I D _ C U T
 *
 *   Makes a NUGrid node (CUT_NUGRIDNODE), filling the cells with solids
 *   from the given list.
 */

void
rt_nugrid_cut(register struct nugridnode *nugnp, register struct boxnode *fromp, struct rt_i *rtip, int just_collect_info, int depth)
{
#define USE_HIST 0
#if USE_HIST	
	struct bu_hist start_hist[3];	/* where solid RPPs start */
	struct bu_hist end_hist[3];	/* where solid RPPs end */
#endif	
	register struct soltab **stpp;

	int	nu_ncells;		/* # cells along one axis */
	int	nu_sol_per_cell;	/* avg # solids per cell */
	int	nu_max_ncells;		/* hard limit on nu_ncells */
	int	pseudo_depth;		/* "fake" depth to tell rt_ct_optim */
	register int	i;
	int	xp, yp, zp;
	vect_t	xmin, xmax, ymin, ymax, zmin, zmax;
	struct boxnode nu_xbox, nu_ybox, nu_zbox;

	if( nugnp->nu_type != CUT_NUGRIDNODE )
		rt_bomb( "rt_nugrid_cut: passed non-nugridnode" );

	/*
	 *  Build histograms of solid RPP extent distribution
	 *  when projected onto X, Y, and Z axes.
	 *  First stage in implementing the Gigante NUgrid algorithm.
	 *  (Proc. Ausgraph 1990, pg 157)
	 *  XXX For databases where the model diameter (diagonal through
	 *  XXX the model RPP) is small or huge, a histogram with
	 *  XXX floating-point ranges will be needed.
	 *  XXX Integers should suffice for now.
	 *
	 *  Goal is to keep the average number of solids per cell constant.
	 *  Assuming a uniform distribution, the number of cells along
	 *  each axis will need to be (nsol / desired_avg)**(1/3).
	 *  This is increased by two to err on the generous side,
	 *  resulting in a 3*3*3 grid even for small numbers of solids.
	 *
	 *  Presumably the caller will have set rtip->rti_nu_gfactor to
	 *  RT_NU_GFACTOR_DEFAULT (although it may change it depending on
	 *  the user's wishes or what it feels will be optimal for this
	 *  model.)  The default value was computed in the following fashion:
	 *  Suppose the ratio of the running times of ft_shot and
	 *  rt_advance_to_next_cell is K, i.e.,
	 *
	 *          avg_running_time( ft_shot )
	 *  K := ---------------------------------  
	 *         avg_running_time( rt_advance )
	 *
	 *  Now suppose we divide each axis into G*n^R segments, yielding
	 *  G^3 n^(3R) cells.  We expect each cell to contain
	 *  G^(-3) n^(1-3R) solids, and hence the running time of firing
	 *  a single ray through the model will be proportional to
	 *
	 *  G*n^R * [ 1 + K G^(-3) n^(1-3R) ] = G*n^R + KG^(-2) n^(1-2R).
	 *
	 *  Since we wish for the running time of this algorithm to be low,
	 *  we wish to minimize the degree of this polynomial.  The optimal
	 *  choice for R is 1/3.  So the above equation becomes
	 *
	 *  G*n^(1/3) + KG^(-2) n^(1/3) = [ G + KG^(-2) ] n^(1/3).
	 *
	 *  We now wish to find an optimal value of G in terms of K.
	 *  Using basic calculus we see that
	 *
	 *                 G := (2K)^(1/3).
	 *
	 *  It has been experimentally observed that K ~ 5/3 when the model
	 *  is mostly arb8s.   Hence RT_NU_GFACTOR_DEFAULT := 1.5.
	 *
	 *  XXX More tests should be done for this.
	 */

	if( rtip->rti_nu_gfactor < 0.01 ||
	    rtip->rti_nu_gfactor > 10*RT_NU_GFACTOR_DEFAULT ) {
		rtip->rti_nu_gfactor = RT_NU_GFACTOR_DEFAULT;
		bu_log(
      "rt_nugrid_cut: warning: rtip->rti_nu_gfactor not set, setting to %g\n",
                        RT_NU_GFACTOR_DEFAULT );
	}

	nu_ncells = (int)ceil( 2.0 + rtip->rti_nu_gfactor *
			       pow( (double)fromp->bn_len, 1.0/3.0 ) );
	if( rtip->rti_nugrid_dimlimit > 0 &&
	    nu_ncells > rtip->rti_nugrid_dimlimit )
		nu_ncells = rtip->rti_nugrid_dimlimit;
	nu_sol_per_cell = (fromp->bn_len + nu_ncells - 1) / nu_ncells;
	nu_max_ncells = 2*nu_ncells + 8;
#if 0
	pseudo_depth = depth+(int)log((double)(nu_ncells*nu_ncells*nu_ncells));
#else
	pseudo_depth = depth;
#endif

	if( RT_G_DEBUG&DEBUG_CUT )
		bu_log(
	             "\nnu_ncells=%d, nu_sol_per_cell=%d, nu_max_ncells=%d\n",
		     nu_ncells, nu_sol_per_cell, nu_max_ncells );
	
#if USE_HIST
	for( i=0; i<3; i++ ) {
		bu_hist_init( &start_hist[i],
			      fromp->bn_min[i],
			      fromp->bn_max[i],
			      nu_ncells*100 );
		bu_hist_init( &end_hist[i],
			      fromp->bn_min[i],
			      fromp->bn_max[i],
			      nu_ncells*100 );
	}


	for( i = 0, stpp = fromp->bn_list;
	     i < fromp->bn_len;
	     i++, stpp++ ) {
		register struct soltab *stp = *stpp;
		RT_CK_SOLTAB( stp );
		if( stp->st_aradius <= 0 )  continue;
		if( stp->st_aradius >= INFINITY )  continue;
		for( j=0; j<3; j++ )  {
			BU_HIST_TALLY( &start_hist[j],stp->st_min[j] );
			BU_HIST_TALLY( &end_hist[j],  stp->st_max[j] );
		}
	}
#endif	

	/* Allocate memory for nugrid axis parition. */
		
	for( i=0; i<3; i++ )
		nugnp->nu_axis[i] = (struct nu_axis *)bu_malloc(
			nu_max_ncells*sizeof(struct nu_axis), "NUgrid axis" );

#if USE_HIST
	/*
	 *  Next part of NUgrid algorithm:
	 *  Decide where cell boundaries should be, along each axis.
	 *  Each cell will be an interval across the histogram.
	 *  For each interval, track the number of new solids that
	 *  have *started* in the interval, and the number of existing solids
	 *  that have *ended* in the interval.
	 *  Continue widening the interval another histogram element
	 *  in width, until either the number of starts or endings
	 *  exceeds the goal for the average number of solids per
	 *  cell, nu_sol_per_cell = (nsolids / nu_ncells).
	 */
	
	for( i=0; i<3; i++ )  {
		fastf_t	pos;		/* Current interval start pos */
		int	nstart = 0;
		int	nend = 0;
		struct bu_hist	*shp = &start_hist[i];
		struct bu_hist	*ehp = &end_hist[i];
		int	hindex = 0;
		int	axi = 0;

		if( shp->hg_min != ehp->hg_min )
			rt_bomb("cut_it: hg_min error\n");
		pos = shp->hg_min;
		nugnp->nu_axis[i][axi].nu_spos = pos;
		for( hindex = 0; hindex < shp->hg_nbins; hindex++ )  {
			if( pos > shp->hg_max )  break;
			/* Advance interval one more histogram entry */
			/* NOTE:  Peeks into histogram structures! */
			nstart += shp->hg_bins[hindex];
			nend += ehp->hg_bins[hindex];
			pos += shp->hg_clumpsize;
#if 1		     
			if( nstart < nu_sol_per_cell &&
			    nend < nu_sol_per_cell ) continue;
#else
			if( nstart + nend < 2 * nu_sol_per_cell )
				continue;
#endif
			/* End current interval, start new one */
			nugnp->nu_axis[i][axi].nu_epos = pos;
			nugnp->nu_axis[i][axi].nu_width =
				pos - nugnp->nu_axis[i][axi].nu_spos;
			if( axi >= nu_max_ncells-1 )  {
				bu_log("NUgrid ran off end, axis=%d, axi=%d\n",
					i, axi);
				pos = shp->hg_max+1;
				break;
			}
			nugnp->nu_axis[i][++axi].nu_spos = pos;
			nstart = 0;
			nend = 0;
		}
		/* End final interval */
		nugnp->nu_axis[i][axi].nu_epos = pos;
		nugnp->nu_axis[i][axi].nu_width =
			pos - nugnp->nu_axis[i][axi].nu_spos;
		nugnp->nu_cells_per_axis[i] = axi+1;
	}

	/* Finished with temporary data structures */
	for( i=0; i<3; i++ ) {
		bu_hist_free( &start_hist[i] );
		bu_hist_free( &end_hist[i] );
	}
#else
	{
		struct soltab **list_min, **list_max;
		register struct soltab **l1, **l2;
		register int nstart, nend, axi, len = fromp->bn_len;
		register fastf_t pos;

		list_min = (struct soltab **)bu_malloc( len *
						      sizeof(struct soltab *),
							"min solid list" );
		list_max = (struct soltab **)bu_malloc( len *
						      sizeof(struct soltab *),
							"max solid list" );
		bcopy( fromp->bn_list, list_min, len*sizeof(struct soltab *) );
		bcopy( fromp->bn_list, list_max, len*sizeof(struct soltab *) );
		for( i=0; i<3; i++ ) {
			qsort( (genptr_t)list_min, len,
			       sizeof(struct soltab *), pairs[i].cmp_min );
			qsort( (genptr_t)list_max, len,
			       sizeof(struct soltab *), pairs[i].cmp_max );
			nstart = nend = axi = 0;
			l1 = list_min;
			l2 = list_max;

			pos = fromp->bn_min[i];
			nugnp->nu_axis[i][axi].nu_spos = pos;
			
			while( l1-list_min < len ||
			       l2-list_max < len ) {
				if( l2-list_max >= len ||
				    (l1-list_min < len &&
				     (*l1)->st_min[i] < (*l2)->st_max[i]) ) {
					pos = (*l1++)->st_min[i];
					++nstart;
				} else {
					pos = (*l2++)->st_max[i];
					++nend;
				}

#if 1
				if( nstart < nu_sol_per_cell &&
				    nend < nu_sol_per_cell )
#else
				if( nstart + nend < nu_sol_per_cell )
#endif					
					continue;

				/* Don't make really teeny intervals. */
				if( pos <= nugnp->nu_axis[i][axi].nu_spos
#if 1				    
					   + 1.0
#endif				    
				           + rtip->rti_tol.dist )
					continue;

				/* don't make any more cuts if we've gone
				   past the end. */
				if( pos >= fromp->bn_max[i]
#if 1				    
					   - 1.0
#endif
					   - rtip->rti_tol.dist )
					continue;

				/* End current interval, start new one */
				nugnp->nu_axis[i][axi].nu_epos = pos;
				nugnp->nu_axis[i][axi].nu_width =
					pos - nugnp->nu_axis[i][axi].nu_spos;
				if( axi >= nu_max_ncells-1 )  {
					bu_log(
				      "NUgrid ran off end, axis=%d, axi=%d\n",
					       i, axi);
					rt_bomb( "rt_nugrid_cut: NUgrid ran off end" );
				}
				nugnp->nu_axis[i][++axi].nu_spos = pos;
				nstart = 0;
				nend = 0;
			}
			/* End final interval */
			if( pos < fromp->bn_max[i] ) pos = fromp->bn_max[i]; 
			nugnp->nu_axis[i][axi].nu_epos = pos;
			nugnp->nu_axis[i][axi].nu_width =
				pos - nugnp->nu_axis[i][axi].nu_spos;
			nugnp->nu_cells_per_axis[i] = axi+1;
		}
		bu_free( (genptr_t)list_min, "solid list min sort" );
		bu_free( (genptr_t)list_max, "solid list max sort" );
	}
	
#endif
	
	nugnp->nu_stepsize[X] = 1;
	nugnp->nu_stepsize[Y] = nugnp->nu_cells_per_axis[X] *
					nugnp->nu_stepsize[X];
	nugnp->nu_stepsize[Z] = nugnp->nu_cells_per_axis[Y] *
					nugnp->nu_stepsize[Y];

	/* For debugging */
	if( RT_G_DEBUG&DEBUG_CUT ) for( i=0; i<3; i++ ) {
		register int j;
		bu_log( "NUgrid %c axis:  %d cells\n", "XYZ*"[i],
			nugnp->nu_cells_per_axis[i] );
		for( j=0; j<nugnp->nu_cells_per_axis[i]; j++ ) {
			bu_log( "  %g .. %g, w=%g\n",
				nugnp->nu_axis[i][j].nu_spos,
				nugnp->nu_axis[i][j].nu_epos,
				nugnp->nu_axis[i][j].nu_width );
		}
	}

	/* If we were just asked to collect info, we are done.
	   The binary space partioning algorithm (sometimes) needs just this.*/

	if( just_collect_info ) return;
		
	/* For the moment, re-use "union cutter" */
	nugnp->nu_grid = (union cutter *)bu_malloc(
		nugnp->nu_cells_per_axis[X] *
		nugnp->nu_cells_per_axis[Y] *
		nugnp->nu_cells_per_axis[Z] * sizeof(union cutter),
		"3-D NUgrid union cutter []" );
	nu_xbox.bn_len = 0;
	nu_xbox.bn_maxlen = fromp->bn_len;
	nu_xbox.bn_list = (struct soltab **)bu_malloc(
		nu_xbox.bn_maxlen * sizeof(struct soltab *),
		"xbox boxnode []" );
	nu_ybox.bn_len = 0;
	nu_ybox.bn_maxlen = fromp->bn_len;
	nu_ybox.bn_list = (struct soltab **)bu_malloc(
		nu_ybox.bn_maxlen * sizeof(struct soltab *),
		"ybox boxnode []" );
	nu_zbox.bn_len = 0;
	nu_zbox.bn_maxlen = fromp->bn_len;
	nu_zbox.bn_list = (struct soltab **)bu_malloc(
		nu_zbox.bn_maxlen * sizeof(struct soltab *),
		"zbox boxnode []" );
	/* Build each of the X slices */
	for( xp = 0; xp < nugnp->nu_cells_per_axis[X]; xp++ ) {
		VMOVE( xmin, fromp->bn_min );
		VMOVE( xmax, fromp->bn_max );
		xmin[X] = nugnp->nu_axis[X][xp].nu_spos;
		xmax[X] = nugnp->nu_axis[X][xp].nu_epos;
		VMOVE( nu_xbox.bn_min, xmin );
		VMOVE( nu_xbox.bn_max, xmax );
		nu_xbox.bn_len = 0;

		/* Search all solids for those in this X slice */
		for( i = 0, stpp = fromp->bn_list;
		     i < fromp->bn_len;
		     i++, stpp++ ) {
			if( !rt_ck_overlap( xmin, xmax, *stpp, rtip ) )
				continue;
			nu_xbox.bn_list[nu_xbox.bn_len++] = *stpp;
		}

		/* Build each of the Y slices in this X slice */
		for( yp = 0; yp < nugnp->nu_cells_per_axis[Y]; yp++ ) {
			VMOVE( ymin, xmin );
			VMOVE( ymax, xmax );
			ymin[Y] = nugnp->nu_axis[Y][yp].nu_spos;
			ymax[Y] = nugnp->nu_axis[Y][yp].nu_epos;
			VMOVE( nu_ybox.bn_min, ymin );
			VMOVE( nu_ybox.bn_max, ymax );
			nu_ybox.bn_len = 0;
			/* Search X slice for membs of this Y slice */
			for( i=0; i<nu_xbox.bn_len; i++ )  {
				if( !rt_ck_overlap( ymin, ymax,
						    nu_xbox.bn_list[i],
						    rtip ) )
					continue;
				nu_ybox.bn_list[nu_ybox.bn_len++] =
					nu_xbox.bn_list[i];
			}
			/* Build each of the Z slices in this Y slice*/
			/* Each of these will be a final cell */
			for( zp = 0; zp < nugnp->nu_cells_per_axis[Z]; zp++ ) {
				register union cutter *cutp =
					&nugnp->nu_grid[
						zp*nugnp->nu_stepsize[Z] +
						yp*nugnp->nu_stepsize[Y] +
						xp*nugnp->nu_stepsize[X]];
						
				VMOVE( zmin, ymin );
				VMOVE( zmax, ymax );
				zmin[Z] = nugnp->nu_axis[Z][zp].nu_spos;
				zmax[Z] = nugnp->nu_axis[Z][zp].nu_epos;
				cutp->cut_type = CUT_BOXNODE;
				VMOVE( cutp->bn.bn_min, zmin );
				VMOVE( cutp->bn.bn_max, zmax );
				/* Build up a temporary list in nu_zbox first,
				 * then copy list over to cutp->bn */
				nu_zbox.bn_len = 0;
				/* Search Y slice for members of this Z slice*/
				for( i=0; i<nu_ybox.bn_len; i++ )  {
					if( !rt_ck_overlap( zmin, zmax,
							    nu_ybox.bn_list[i],
							    rtip ) )
						continue;
					nu_zbox.bn_list[nu_zbox.bn_len++] =
						nu_ybox.bn_list[i];
				}

				if( nu_zbox.bn_len <= 0 )  {
					/* Empty cell */
					cutp->bn.bn_list = (struct soltab **)0;
					cutp->bn.bn_len = 0;
					cutp->bn.bn_maxlen = 0;
					continue;
				}
				/* Allocate just enough space for list,
				 * and copy it in */

				cutp->bn.bn_list =
					(struct soltab **)bu_malloc(
						nu_zbox.bn_len *
						sizeof(struct soltab *),
						"NUgrid cell bn_list[]" );
				cutp->bn.bn_len = cutp->bn.bn_maxlen =
					nu_zbox.bn_len;
				bcopy( (char *)nu_zbox.bn_list,
				       (char *)cutp->bn.bn_list,
				       nu_zbox.bn_len *
				       sizeof(struct soltab *) );

				if( rtip->rti_nugrid_dimlimit > 0 ) {
#if 1					
					rt_ct_optim( rtip, cutp, pseudo_depth);
#else
				/* Recurse, but only if we're cutting down on
				   the cellsize. */
					if( cutp->bn.bn_len > 5 &&
				    cutp->bn.bn_len < fromp->bn_len>>1 ) {

					/* Make a little NUGRID node here
					   to clean things up */
					union cutter temp;

					temp = *cutp;  /* union copy */
					cutp->cut_type = CUT_NUGRIDNODE;
					/* recursive call! */
					rt_nugrid_cut( &cutp->nugn,
						       &temp.bn, rtip, 0,
						       depth+1 );
					}
#endif
				}
			}
		}
	}

	bu_free( (genptr_t)nu_zbox.bn_list, "nu_zbox bn_list[]" );
	bu_free( (genptr_t)nu_ybox.bn_list, "nu_ybox bn_list[]" );
	bu_free( (genptr_t)nu_xbox.bn_list, "nu_xbox bn_list[]" );
}	

int
rt_split_mostly_empty_cells( struct rt_i *rtip, union cutter *cutp )
{
	point_t max, min;
	struct soltab *stp;
	struct rt_piecelist pl;
	fastf_t range[3], empty[3], tmp;
	int upper_or_lower[3];
	fastf_t max_empty;
	int max_empty_dir;
	int i;
	int num_splits=0;

	switch( cutp->cut_type ) {
	case CUT_CUTNODE:
		num_splits += rt_split_mostly_empty_cells( rtip, cutp->cn.cn_l );
		num_splits += rt_split_mostly_empty_cells( rtip, cutp->cn.cn_r );
		break;
	case CUT_BOXNODE:
		/* find the actual bounds of stuff in this cell */
		if( cutp->bn.bn_len == 0 && cutp->bn.bn_piecelen == 0 ) {
			break;
		}
		VSETALL( min, MAX_FASTF );
		VREVERSE( max, min );

		for( i=0 ; i<cutp->bn.bn_len ; i++ ) {
			stp = cutp->bn.bn_list[i];
			VMIN( min, stp->st_min );
			VMAX( max, stp->st_max );
		}

		for( i=0 ; i<cutp->bn.bn_piecelen ; i++ ) {
			int j;

			pl = cutp->bn.bn_piecelist[i];
			for( j=0 ; j<pl.npieces ; j++ ) {
				int piecenum;

				piecenum = pl.pieces[j];
				VMIN( min, pl.stp->st_piece_rpps[piecenum].min );
				VMAX( max, pl.stp->st_piece_rpps[piecenum].max );
			}
		}

		/* clip min and max to the bounds of this cell */
		for( i=X ; i<=Z ; i++ ) {
			if( min[i] < cutp->bn.bn_min[i] ) {
				min[i] = cutp->bn.bn_min[i];
			}
			if( max[i] > cutp->bn.bn_max[i] ) {
				max[i] = cutp->bn.bn_max[i];
			}
		}

		/* min and max now have the real bounds of data in this cell */
		VSUB2( range, cutp->bn.bn_max, cutp->bn.bn_min );
		for( i=X ; i<=Z ; i++ ) {
			empty[i] = cutp->bn.bn_max[i] - max[i];
			upper_or_lower[i] = 1; /* upper section is empty */
			tmp = min[i] - cutp->bn.bn_min[i];
			if( tmp > empty[i] ) {
				empty[i] = tmp;
				upper_or_lower[i] = 0;	/* lower section is empty */
			}
		}
		max_empty = empty[X];
		max_empty_dir = X;
		if( empty[Y] > max_empty ) {
			max_empty = empty[Y];
			max_empty_dir = Y;
		}
		if( empty[Z] > max_empty ) {
			max_empty = empty[Z];
			max_empty_dir = Z;
		}
		if( max_empty / range[max_empty_dir] > 0.5 ) {
			/* this cell is over 50% empty in this direction, split it */

			fastf_t where;

			/* select cutting plane, but move it slightly off any geometry */
			if( upper_or_lower[max_empty_dir] ) {
			        where = max[max_empty_dir] + rtip->rti_tol.dist;
				if( where >= cutp->bn.bn_max[max_empty_dir] ) {
				       return( num_splits );
				}
			} else {
				where = min[max_empty_dir] - rtip->rti_tol.dist;
				if( where <= cutp->bn.bn_min[max_empty_dir] ) {
				       return( num_splits );
				}
			}
			if( where - cutp->bn.bn_min[max_empty_dir] < 2.0 ||
			    cutp->bn.bn_max[max_empty_dir] - where < 2.0 ) {
				/* will make a box too small */
				return( num_splits );
			}
			if( rt_ct_box( rtip, cutp, max_empty_dir, where, 1 ) ) {
				num_splits++;
				num_splits += rt_split_mostly_empty_cells( rtip, cutp->cn.cn_l );
				num_splits += rt_split_mostly_empty_cells( rtip, cutp->cn.cn_r );
			}
		}
		break;
	}

	return( num_splits );
}



/*
 *  			R T _ C U T _ I T
 *  
 *  Go through all the solids in the model, given the model mins and maxes,
 *  and generate a cutting tree.  A strategy better than incrementally
 *  cutting each solid is to build a box node which contains everything
 *  in the model, and optimize it.
 *
 *  This is the main entry point into space partitioning from rt_prep().
 */
void
rt_cut_it(register struct rt_i *rtip, int ncpu)
{
	register struct soltab *stp;
	union cutter *finp;	/* holds the finite solids */
	FILE *plotfp;
	int num_splits=0;

	/* Make a list of all solids into one special boxnode, then refine. */
	BU_GETUNION( finp, cutter );
	finp->cut_type = CUT_BOXNODE;
	VMOVE( finp->bn.bn_min, rtip->mdl_min );
	VMOVE( finp->bn.bn_max, rtip->mdl_max );
	finp->bn.bn_len = 0;
	finp->bn.bn_maxlen = rtip->nsolids+1;
	finp->bn.bn_list = (struct soltab **)bu_malloc(
		finp->bn.bn_maxlen * sizeof(struct soltab *),
		"rt_cut_it: initial list alloc" );

	rtip->rti_inf_box.cut_type = CUT_BOXNODE;

	RT_VISIT_ALL_SOLTABS_START( stp, rtip ) {
		/* Ignore "dead" solids in the list.  (They failed prep) */
		if( stp->st_aradius <= 0 )  continue;

		/* Infinite and finite solids all get lumpped together */
		rt_cut_extend( finp, stp, rtip );

		if( stp->st_aradius >= INFINITY )  {
			/* Also add infinite solids to a special BOXNODE */
			rt_cut_extend( &rtip->rti_inf_box, stp, rtip );
		}
	} RT_VISIT_ALL_SOLTABS_END

	/* Dynamic decisions on tree limits.  Note that there will be
	 * (2**rtip->rti_cutdepth)*rtip->rti_cutlen potential leaf slots.
	 * Also note that solids will typically span several leaves.
	 */
	rtip->rti_cutlen = (int)log((double)rtip->nsolids);  /* ln ~= log2 */
	rtip->rti_cutdepth = 2 * rtip->rti_cutlen;
	if( rtip->rti_cutlen < 3 )  rtip->rti_cutlen = 3;
	if( rtip->rti_cutdepth < 12 )  rtip->rti_cutdepth = 12;
	if( rtip->rti_cutdepth > 24 )  rtip->rti_cutdepth = 24;     /* !! */
	if( RT_G_DEBUG&DEBUG_CUT )
		bu_log( "Before Space Partitioning: Max Tree Depth=%d, Cuttoff primitive count=%d\n",
			rtip->rti_cutdepth, rtip->rti_cutlen );

	bu_ptbl_init( &rtip->rti_cuts_waiting, rtip->nsolids,
		      "rti_cuts_waiting ptbl" );

	if( rtip->rti_hasty_prep )  {
		rtip->rti_space_partition = RT_PART_NUBSPT;
		rtip->rti_cutdepth = 6;
	}

	switch( rtip->rti_space_partition ) {
	case RT_PART_NUGRID:
		rtip->rti_CutHead.cut_type = CUT_NUGRIDNODE;
		rt_nugrid_cut( &rtip->rti_CutHead.nugn, &finp->bn, rtip, 0,0 );
		rt_fr_cut( rtip, finp ); /* done with finite solids box */
		break;
	case RT_PART_NUBSPT: {
#ifdef NEW_WAY		
		struct nugridnode nuginfo;

		/* Collect statistics to assist binary space partition tree
		   construction */
		nuginfo.nu_type = CUT_NUGRIDNODE;
		rt_nugrid_cut( &nuginfo, &fin_box, rtip, 1, 0 );
#endif		
		rtip->rti_CutHead = *finp;	/* union copy */
#ifdef NEW_WAY
		if( rtip->nsolids < 50000 )  {
#endif
		/* Old way, non-parallel */
		/* For some reason, this algorithm produces a substantial
		 * performance improvement over the parallel way, below.  The
		 * benchmark tests seem to be very sensitive to how the space
		 * partitioning is laid out.  Until we go to full NUgrid, this
		 * will have to do.  */
			rt_ct_optim( rtip, &rtip->rti_CutHead, 0 );
#ifdef NEW_WAY
		} else {

			XXX This hasnt been tested since massive
			    NUgrid changes were made
			
			/* New way, mostly parallel */
			union cutter	*head;
			int	i;
			
			head = rt_cut_one_axis( &rtip->rti_cuts_waiting, rtip,
			    Y, 0, nuginfo.nu_cells_per_axis[Y]-1, &nuginfo );
			rtip->rti_CutHead = *head;	/* struct copy */
			bu_free( (char *)head, "union cutter" );
			
			if(RT_G_DEBUG&DEBUG_CUTDETAIL)  {
				for( i=0; i<3; i++ )  {
					bu_log("\nNUgrid %c axis:  %d cells\n",
				     "XYZ*"[i], nuginfo.nu_cells_per_axis[i] );
				}
				rt_pr_cut( &rtip->rti_CutHead, 0 );
			}
			
			if( ncpu <= 1 )  {
				rt_cut_optimize_parallel(0, rtip);
			} else {
				bu_parallel( rt_cut_optimize_parallel, ncpu, rtip );
			}
		}
#endif
		/* one more pass to find cells that are mostly empty */
		num_splits = rt_split_mostly_empty_cells( rtip,  &rtip->rti_CutHead );

		if( RT_G_DEBUG&DEBUG_CUT ) {
			bu_log( "rt_split_mostly_empty_cells(): split %d cells\n", num_splits );
		}

		break; }
	default:
		rt_bomb( "rt_cut_it: unknown space partitioning method\n" );
	}

	bu_free( (genptr_t)finp, "finite solid box" );

	/* Measure the depth of tree, find max # of RPPs in a cut node */

	bu_hist_init( &rtip->rti_hist_cellsize, 0.0, 400.0, 400 );
	bu_hist_init( &rtip->rti_hist_cell_pieces, 0.0, 400.0, 400 );
	bu_hist_init( &rtip->rti_hist_cutdepth, 0.0,
		      (fastf_t)rtip->rti_cutdepth+1, rtip->rti_cutdepth+1 );
	bzero( rtip->rti_ncut_by_type, sizeof(rtip->rti_ncut_by_type) );
	rt_ct_measure( rtip, &rtip->rti_CutHead, 0 );
	if( RT_G_DEBUG&DEBUG_CUT )  {
		rt_pr_cut_info( rtip, "Cut" );
	}

	if( RT_G_DEBUG&DEBUG_CUTDETAIL ) {
		/* Produce a voluminous listing of the cut tree */
		rt_pr_cut( &rtip->rti_CutHead, 0 );
	}

	if( RT_G_DEBUG&DEBUG_PLOTBOX ) {
		/* Debugging code to plot cuts */
		if( (plotfp=fopen("rtcut.plot", "w"))!=NULL ) {
			pdv_3space( plotfp, rtip->rti_pmin, rtip->rti_pmax );
				/* Plot all the cutting boxes */
			rt_plot_cut( plotfp, rtip, &rtip->rti_CutHead, 0 );
			(void)fclose(plotfp);
		}
	}
}

/*
 *			R T _ C U T _ E X T E N D
 *
 *  Add a solid into a given boxnode, extending the lists there.
 *  This is used only for building the root node, which will then
 *  be subdivided.
 *
 *  Solids with pieces go onto a special list.
 */
void
rt_cut_extend(register union cutter *cutp, struct soltab *stp, const struct rt_i *rtip)
{
	RT_CK_SOLTAB(stp);
	RT_CK_RTI(rtip);

	BU_ASSERT( cutp->cut_type == CUT_BOXNODE );

	if(RT_G_DEBUG&DEBUG_CUTDETAIL)  {
		bu_log("rt_cut_extend(cutp=x%x) %s npieces=%d\n",
			cutp, stp->st_name, stp->st_npieces);
	}

	if( stp->st_npieces > 0 )  {
		struct rt_piecelist *plp;
		register int i;

		if( cutp->bn.bn_piecelist == NULL )  {
			/* Allocate enough piecelist's to hold all solids */
			BU_ASSERT( rtip->nsolids > 0 );
			cutp->bn.bn_piecelist = (struct rt_piecelist *) bu_malloc(
				sizeof(struct rt_piecelist) * (rtip->nsolids + 2),
				"rt_ct_box bn_piecelist (root node)" );
			cutp->bn.bn_piecelen = 0;	/* sanity */
			cutp->bn.bn_maxpiecelen = rtip->nsolids + 2;
		}
		plp = &cutp->bn.bn_piecelist[cutp->bn.bn_piecelen++];
		plp->magic = RT_PIECELIST_MAGIC;
		plp->stp = stp;

		/* List every index that this solid has */
		plp->npieces = stp->st_npieces;
		plp->pieces = (long *)bu_malloc(
			sizeof(long) * plp->npieces,
			"pieces[]" );
		for( i = stp->st_npieces-1; i >= 0; i-- )
			plp->pieces[i] = i;

		return;
	}

	/* No pieces, list the entire solid on bn_list */
	if( cutp->bn.bn_len >= cutp->bn.bn_maxlen )  {
		/* Need to get more space in list.  */
		if( cutp->bn.bn_maxlen <= 0 )  {
			/* Initial allocation */
			if( rtip->rti_cutlen > rtip->nsolids )
				cutp->bn.bn_maxlen = rtip->rti_cutlen;
			else
				cutp->bn.bn_maxlen = rtip->nsolids + 2;
			cutp->bn.bn_list = (struct soltab **)bu_malloc(
				cutp->bn.bn_maxlen * sizeof(struct soltab *),
				"rt_cut_extend: initial list alloc" );
		} else {
			cutp->bn.bn_maxlen *= 8;
			cutp->bn.bn_list = (struct soltab **) bu_realloc(
				(genptr_t)cutp->bn.bn_list,
				sizeof(struct soltab *) * cutp->bn.bn_maxlen,
				"rt_cut_extend: list extend" );
		}
	}
	cutp->bn.bn_list[cutp->bn.bn_len++] = stp;
}

/*
 *			R T _ C T _ P L A N
 *
 *  Attempt to make an "optimal" cut of the given boxnode.
 *  Consider cuts along all three axis planes, and choose
 *  the one with the smallest "offcenter" metric.
 *
 *  Returns -
 *	-1	No cut is possible
 *	 0	Node has been cut
 */
HIDDEN int
rt_ct_plan(struct rt_i *rtip, union cutter *cutp, int depth)
{
	int	axis;
	int	status[3];
	double	where[3];
	double	offcenter[3];
	int	best;
	double	bestoff;

	RT_CK_RTI(rtip);
	for( axis = X; axis <= Z; axis++ )  {
#if 0
 /* New way */
		status[axis] = rt_ct_assess(
			cutp, axis, &where[axis], &offcenter[axis] );
#else
 /* Old way */
		status[axis] = rt_ct_old_assess(
			cutp, axis, &where[axis], &offcenter[axis] );
#endif
	}

	for(;;)  {
		best = -1;
		bestoff = INFINITY;
		for( axis = X; axis <= Z; axis++ )  {
			if( status[axis] <= 0 )  continue;
			if( offcenter[axis] >= bestoff )  continue;
			/* This one is better than previous ones */
			best = axis;
			bestoff = offcenter[axis];
		}

		if( best < 0 )  return(-1);	/* No cut is possible */

		if( rt_ct_box( rtip, cutp, best, where[best], 0 ) > 0 )
			return(0);		/* OK */

		/*
		 *  This cut failed to reduce complexity on either side.
		 *  Mark this status as bad, and try the next-best
		 *  opportunity, if any.
		 */
		status[best] = 0;
	}
}

/*
 *			R T _ C T _ A S S E S S
 *
 *  Assess the possibility of making a cut along the indicated axis.
 *  
 *  Returns -
 *	0	if a cut along this axis is not possible
 *	1	if a cut along this axis *is* possible, plus:
 *		*where		is proposed cut point, and
 *		*offcenter	is distance from "optimum" cut location.
 */
HIDDEN int
rt_ct_assess(register union cutter *cutp, register int axis, double *where_p, double *offcenter_p)
{
	register int	i;
	register double	val;
	register double	where;
	register double	offcenter;	/* Closest distance from midpoint */
	register double	middle;		/* midpoint */
	register double	left, right;

	if( cutp->bn.bn_len <= 1 )  return(0);		/* Forget it */

	/*
	 *  In absolute terms, each box must be at least 1mm wide after cut,
	 *  so there is no need subdividing anything smaller than twice that.
	 */
	if( (right=cutp->bn.bn_max[axis])-(left=cutp->bn.bn_min[axis]) <= 2.0 )
		return(0);

	/*
	 *  Split distance between min and max in half.
	 *  Find the closest edge of a solid's bounding RPP
	 *  to the mid-point, and split there.
	 *  This should ordinarily guarantee that at least one side of the
	 *  cut has one less item in it.
	 *
	 * XXX This should be much more sophisticated.
	 * XXX Consider making a list of candidate cut points
	 * (max and min of each bn_list[] element) with
	 * the subscript stored.
	 * Eliminaate candidates outside the current range.
	 * Sort the list.
	 * Eliminate duplicate candidates.
	 * The the element in the middle of the candidate list.
	 * Compute offcenter from middle of range as now.
	 */
	middle = (left + right) * 0.5;
	where = offcenter = INFINITY;
	for( i=0; i < cutp->bn.bn_len; i++ )  {
		/* left (min) edge */
		val = cutp->bn.bn_list[i]->st_min[axis];
		if( val > left && val < right )  {
			register double	d;
			if( (d = val - middle) < 0 )  d = (-d);
			if( d < offcenter )  {
				offcenter = d;
				where = val;
			}
		}
		/* right (max) edge */
		val = cutp->bn.bn_list[i]->st_max[axis];
		if( val > left && val < right )  {
			register double	d;
			if( (d = val - middle) < 0 )  d = (-d);
			if( d < offcenter )  {
				offcenter = d;
				where = val;
			}
		}
	}
	if( offcenter >= INFINITY )
		return(0);	/* no candidates? */
	if( where <= left || where >= right )
		return(0);	/* not reasonable */

	if( where - left <= 1.0 || right - where <= 1.0 )
		return(0);	/* cut will be too small */

	*where_p = where;
	*offcenter_p = offcenter;
	return(1);		/* OK */
}

#define PIECE_BLOCK	512

/*
 *			R T _ C T _ P O P U L A T E _ B O X
 *
 *  Given that 'outp' has been given a bounding box smaller than
 *  that of 'inp', copy over everything which still fits in the smaller box.
 *
 *  Returns -
 *	0	if outp has the same number of items as inp
 *	1	if outp has fewer items than inp
 */
HIDDEN int
rt_ct_populate_box(union cutter *outp, const union cutter *inp, struct rt_i *rtip)
{
	register int	i;
	int success = 0;
	const struct bn_tol *tol = &rtip->rti_tol;

	/* Examine the solids */
	outp->bn.bn_len = 0;
	outp->bn.bn_maxlen = inp->bn.bn_len;
	if( outp->bn.bn_maxlen > 0 )  {
		outp->bn.bn_list = (struct soltab **) bu_malloc(
			sizeof(struct soltab *) * outp->bn.bn_maxlen,
			"bn_list" );
		for( i = inp->bn.bn_len-1; i >= 0; i-- )  {
			struct soltab *stp = inp->bn.bn_list[i];
			if( !rt_ck_overlap(outp->bn.bn_min, outp->bn.bn_max,
			    stp, rtip))
				continue;
			outp->bn.bn_list[outp->bn.bn_len++] = stp;
		}
		if( outp->bn.bn_len < inp->bn.bn_len )  success = 1;
	} else {
		outp->bn.bn_list = (struct soltab **)NULL;
	}

	/* Examine the solid pieces */
	outp->bn.bn_piecelen = 0;
	if( inp->bn.bn_piecelen <= 0 )  {
		outp->bn.bn_piecelist = (struct rt_piecelist *)NULL;
		outp->bn.bn_maxpiecelen = 0;
		return success;
	}

	outp->bn.bn_piecelist = (struct rt_piecelist *) bu_malloc(
		sizeof(struct rt_piecelist) * inp->bn.bn_piecelen,
		"rt_piecelist" );
	outp->bn.bn_maxpiecelen = inp->bn.bn_piecelen;
#if 0
	for( i = inp->bn.bn_piecelen-1; i >= 0; i-- )  {
		struct rt_piecelist *plp = &inp->bn.bn_piecelist[i];	/* input */
		struct soltab *stp = plp->stp;
		struct rt_piecelist *olp = &outp->bn.bn_piecelist[outp->bn.bn_piecelen]; /* output */
		int j;

		RT_CK_PIECELIST(plp);
		RT_CK_SOLTAB(stp);
		olp->pieces = (long *)bu_malloc(
			sizeof(long) * plp->npieces,
			"olp->pieces[]" );
		olp->npieces = 0;

		/* Loop for every piece of this solid */
		for( j = plp->npieces-1; j >= 0; j-- )  {
			long indx = plp->pieces[j];
			struct bound_rpp *rpp = &stp->st_piece_rpps[indx];
			if( !V3RPP_OVERLAP_TOL(
			    outp->bn.bn_min, outp->bn.bn_max,
			    rpp->min, rpp->max, tol) )
				continue;
			olp->pieces[olp->npieces++] = indx;
		}
		if( olp->npieces > 0 )  {
			/* This solid contributed pieces to the output box */
			olp->magic = RT_PIECELIST_MAGIC;
			olp->stp = stp;
			outp->bn.bn_piecelen++;
			if( olp->npieces < plp->npieces ) success = 1;
		} else {
			bu_free( (char *)olp->pieces, "olp->pieces[]");
			olp->pieces = NULL;
		}
	}

#else
	for( i = inp->bn.bn_piecelen-1; i >= 0; i-- )  {
		struct rt_piecelist *plp = &inp->bn.bn_piecelist[i];	/* input */
		struct soltab *stp = plp->stp;
		struct rt_piecelist *olp = &outp->bn.bn_piecelist[outp->bn.bn_piecelen]; /* output */
		int j,k;
		long piece_list[PIECE_BLOCK];	/* array of pieces */
		long piece_count=0;		/* count of used slots in above array */
		long *more_pieces=NULL;		/* dynamically allocated array for overflow of above array */
		long more_piece_count=0;	/* number of slots used in dynamic array */
		long more_piece_len=0;		/* allocated length of dynamic array */

		RT_CK_PIECELIST(plp);
		RT_CK_SOLTAB(stp);

		/* Loop for every piece of this solid */
		for( j = plp->npieces-1; j >= 0; j-- )  {
			long indx = plp->pieces[j];
			struct bound_rpp *rpp = &stp->st_piece_rpps[indx];
			if( !V3RPP_OVERLAP_TOL(
			    outp->bn.bn_min, outp->bn.bn_max,
			    rpp->min, rpp->max, tol) )
				continue;
			if( piece_count < PIECE_BLOCK ) {
				piece_list[piece_count++] = indx;
			} else if( more_piece_count >= more_piece_len ) {
				/* this should be an extemely rare occurrence */
				more_piece_len += PIECE_BLOCK;
				more_pieces = (long *)bu_realloc( more_pieces, more_piece_len * sizeof( long ),
								  "more_pieces" );
				more_pieces[more_piece_count++] = indx;
			} else {
				more_pieces[more_piece_count++] = indx;
			}
		}
		olp->npieces = piece_count + more_piece_count;
		if( olp->npieces > 0 )  {
			/* This solid contributed pieces to the output box */
			olp->magic = RT_PIECELIST_MAGIC;
			olp->stp = stp;
			outp->bn.bn_piecelen++;
			olp->pieces = (long *)bu_malloc( sizeof(long) * olp->npieces, "olp->pieces[]" );
			for( j=0 ; j<piece_count ; j++ ) {
				olp->pieces[j] = piece_list[j];
			}
			k = piece_count;
			for( j=0 ; j<more_piece_count ; j++ ) {
				olp->pieces[k++] = more_pieces[j];
			}
			if( more_pieces ) {
				bu_free( (char *)more_pieces, "more_pieces" );
			}
			if( olp->npieces < plp->npieces ) success = 1;
		} else {
			olp->pieces = NULL;
			/*			if( plp->npieces > 0 ) success = 1; */
		}
	}
#endif

	return success;
}

/*
 *			R T _ C T _ B O X
 *
 *  Cut the given box node with a plane along the given axis,
 *  at the specified distance "where".
 *  Convert the caller's box node into a cut node, allocating two
 *  additional box nodes for the new leaves.
 *
 *  If, according to the classifier, both sides have the same number
 *  of solids, then nothing is changed, and an error is returned.
 *
 *  The storage strategy used is to make the maximum length of
 *  each of the two child boxnodes be the current length of the
 *  source node.
 *
 *  Returns -
 *	0	failure
 *	1	success
 */
HIDDEN int
rt_ct_box(struct rt_i *rtip, register union cutter *cutp, register int axis, double where, int force)
{
	register union cutter	*rhs, *lhs;
	int success = 0;

	RT_CK_RTI(rtip);
	if(RT_G_DEBUG&DEBUG_CUTDETAIL)  {
		bu_log("rt_ct_box(x%x, %c) %g .. %g .. %g\n",
			cutp, "XYZ345"[axis],
			cutp->bn.bn_min[axis],
			where,
			cutp->bn.bn_max[axis]);
	}

	/* LEFT side */
	lhs = rt_ct_get(rtip);
	lhs->bn.bn_type = CUT_BOXNODE;
	VMOVE( lhs->bn.bn_min, cutp->bn.bn_min );
	VMOVE( lhs->bn.bn_max, cutp->bn.bn_max );
	lhs->bn.bn_max[axis] = where;

	success = rt_ct_populate_box( lhs, cutp, rtip );

	/* RIGHT side */
	rhs = rt_ct_get(rtip);
	rhs->bn.bn_type = CUT_BOXNODE;
	VMOVE( rhs->bn.bn_min, cutp->bn.bn_min );
	VMOVE( rhs->bn.bn_max, cutp->bn.bn_max );
	rhs->bn.bn_min[axis] = where;

	success += rt_ct_populate_box( rhs, cutp, rtip );

	/* Check to see if complexity didn't decrease */
	if( success == 0 && !force )  {
		/*
		 *  This cut operation did no good, release storage,
		 *  and let caller attempt something else.
		 */
		if(RT_G_DEBUG&DEBUG_CUTDETAIL)  {
			static char axis_str[] = "XYZw";
			bu_log("rt_ct_box:  no luck, len=%d, axis=%c\n",
				cutp->bn.bn_len, axis_str[axis] );
		}
		rt_ct_free( rtip, rhs );
		rt_ct_free( rtip, lhs );
		return(0);		/* fail */
	}

	/* Success, convert callers box node into a cut node */
	rt_ct_release_storage( cutp );

	cutp->cut_type = CUT_CUTNODE;
	cutp->cn.cn_axis = axis;
	cutp->cn.cn_point = where;
	cutp->cn.cn_l = lhs;
	cutp->cn.cn_r = rhs;
	return(1);			/* success */
}

/*
 *			R T _ C K _ O V E R L A P
 *
 *  See if any part of the solid is contained within the bounding box (RPP).
 *
 *  If the solid RPP at least partly overlaps the bounding RPP,
 *  invoke the per-solid "classifier" method to perform a more
 *  rigorous check.
 *
 *  Returns -
 *	!0	if object overlaps box.
 *	0	if no overlap.
 */
HIDDEN int
rt_ck_overlap(register const fastf_t *min, register const fastf_t *max, register const struct soltab *stp, register const struct rt_i *rtip)
{
	RT_CHECK_SOLTAB(stp);
	if( RT_G_DEBUG&DEBUG_BOXING )  {
		bu_log("rt_ck_overlap(%s)\n",stp->st_name);
		VPRINT(" box min", min);
		VPRINT(" sol min", stp->st_min);
		VPRINT(" box max", max);
		VPRINT(" sol max", stp->st_max);
	}
	/* Ignore "dead" solids in the list.  (They failed prep) */
	if( stp->st_aradius <= 0 )  return(0);

	/* Only check RPP on finite solids */
	if( stp->st_aradius < INFINITY )  {
		if( V3RPP_DISJOINT( stp->st_min, stp->st_max, min, max ) )
			goto fail;
	}

	/* RPP overlaps, invoke per-solid method for detailed check */
	if( rt_functab[stp->st_id].ft_classify( stp, min, max,
			  &rtip->rti_tol ) == RT_CLASSIFY_OUTSIDE )  goto fail;

	if( RT_G_DEBUG&DEBUG_BOXING )  bu_log("rt_ck_overlap:  TRUE\n");
	return(1);
fail:
	if( RT_G_DEBUG&DEBUG_BOXING )  bu_log("rt_ck_overlap:  FALSE\n");
	return(0);
}

/*
 *			R T _ C T _ P I E C E C O U N T
 *
 *  Returns the total number of solids and solid "pieces" in a boxnode.
 */
HIDDEN int
rt_ct_piececount(const union cutter *cutp)
{
	int	i;
	int	count;

	BU_ASSERT( cutp->cut_type == CUT_BOXNODE );

	count = cutp->bn.bn_len;

	if( cutp->bn.bn_piecelen <= 0 )  return count;

	for( i = cutp->bn.bn_piecelen-1; i >= 0; i-- )  {
		count += cutp->bn.bn_piecelist[i].npieces;
	}
	return count;
}

/*
 *			R T _ C T _ O P T I M
 *  
 *  Optimize a cut tree.  Work on nodes which are over the pre-set limits,
 *  subdividing until either the limit on tree depth runs out, or until
 *  subdivision no longer gives different results, which could easily be
 *  the case when several solids involved in a CSG operation overlap in
 *  space.
 */
HIDDEN void
rt_ct_optim(struct rt_i *rtip, register union cutter *cutp, int depth)
{
 	int oldlen;

	if( cutp->cut_type == CUT_CUTNODE )  {
		rt_ct_optim( rtip, cutp->cn.cn_l, depth+1 );
		rt_ct_optim( rtip, cutp->cn.cn_r, depth+1 );
		return;
	}
	if( cutp->cut_type != CUT_BOXNODE )  {
		bu_log("rt_ct_optim: bad node x%x\n", cutp->cut_type);
		return;
	}

	oldlen = rt_ct_piececount(cutp);	/* save before rt_ct_box() */
	if( RT_G_DEBUG&DEBUG_CUTDETAIL )  bu_log("rt_ct_optim( cutp=x%x, depth=%d ) piececount=%d\n", cutp, depth, oldlen);

	/*
	 * BOXNODE (leaf)
	 */
	if( oldlen <= 1 )
		return;		/* this box is already optimal */
	if( depth > rtip->rti_cutdepth )  return;		/* too deep */

	/* Attempt to subdivide finer than rtip->rti_cutlen near treetop */
	/**** XXX This test can be improved ****/
	if( depth >= 6 && oldlen <= rtip->rti_cutlen )
		return;				/* Fine enough */
#if NEW_WAY
 /* New way */
	/*
	 *  Attempt to make an optimal cut
	 */
	if( rt_ct_plan( rtip, cutp, depth ) < 0 )  {
		/* Unable to further subdivide this box node */
		return;
	}
#else
 /* Old (Release 3.7) way */
 {
	int did_a_cut;
	int i;
 	int axis;
 	double where, offcenter;
	/*
	 *  In general, keep subdividing until things don't get any better.
	 *  Really we might want to proceed for 2-3 levels.
	 *
	 *  First, make certain this is a worthwhile cut.
	 *  In absolute terms, each box must be at least 1mm wide after cut.
	 */
	axis = AXIS(depth);
#if 1
	did_a_cut = 0;
	for( i=0 ; i<3 ; i++ ) {
		axis += i;
		if( axis > Z ) {
			axis = X;
		}
		if( cutp->bn.bn_max[axis]-cutp->bn.bn_min[axis] < 2.0 ) {
			continue;
		}
		if( rt_ct_old_assess( cutp, axis, &where, &offcenter ) <= 0 ) {
			continue;
		}
		if( rt_ct_box( rtip, cutp, axis, where, 0 ) == 0 )  {
			continue;
		} else {
			did_a_cut = 1;
			break;
		}
	}

	if( !did_a_cut ) {
		return;
	}
#else
	if( cutp->bn.bn_max[axis]-cutp->bn.bn_min[axis] < 2.0 )
		return;
 	if( rt_ct_old_assess( cutp, axis, &where, &offcenter ) <= 0 )
 		return;			/* not practical */
	if( rt_ct_box( rtip, cutp, axis, where, 0 ) == 0 )  {
	 	if( rt_ct_old_assess( cutp, AXIS(depth+1), &where, &offcenter ) <= 0 )
	 		return;			/* not practical */
		if( rt_ct_box( rtip, cutp, AXIS(depth+1), where, 0 ) == 0 )
			return;	/* hopeless */
	}
#endif
	if( rt_ct_piececount(cutp->cn.cn_l) >= oldlen &&
	    rt_ct_piececount(cutp->cn.cn_r) >= oldlen )  {
 		if( RT_G_DEBUG&DEBUG_CUTDETAIL )
	    	bu_log("rt_ct_optim(cutp=x%x, depth=%d) oldlen=%d, lhs=%d, rhs=%d, hopeless\n",
	    		cutp, depth, oldlen,
			rt_ct_piececount(cutp->cn.cn_l),
			rt_ct_piececount(cutp->cn.cn_r) );
		return; /* hopeless */
	}
 }
#endif
	/* Box node is now a cut node, recurse */
	rt_ct_optim( rtip, cutp->cn.cn_l, depth+1 );
	rt_ct_optim( rtip, cutp->cn.cn_r, depth+1 );
}

/*
 *			R T _ C T _ O L D _ A S S E S S
 *
 *  From RCS revision 9.4
 *  NOTE:  Changing from rt_ct_assess() to this seems to result
 *  in a *massive* change in cut tree size.
 *	This version results in nbins=22, maxlen=3, avg=1.09,
 *  while new vewsion results in nbins=42, maxlen=3, avg=1.667 (on moss.g).
 */
HIDDEN int
rt_ct_old_assess(register union cutter *cutp, register int axis, double *where_p, double *offcenter_p)
{
	double		val;
	double		offcenter;		/* Closest distance from midpoint */
	double		where;		/* Point closest to midpoint */
	double		middle;		/* midpoint */
	double		d;
	fastf_t		max, min;
	register int	i;
	register double	left, right;

	if(RT_G_DEBUG&DEBUG_CUTDETAIL)bu_log("rt_ct_old_assess(x%x, %c)\n",cutp,"XYZ345"[axis]);

	/*  In absolute terms, each box must be at least 1mm wide after cut. */
	if( (right=cutp->bn.bn_max[axis])-(left=cutp->bn.bn_min[axis]) < 2.0 )
		return(0);

	/*
	 *  Split distance between min and max in half.
	 *  Find the closest edge of a solid's bounding RPP
	 *  to the mid-point, and split there.
	 *  This should ordinarily guarantee that at least one side of the
	 *  cut has one less item in it.
	 */
	min = MAX_FASTF;
	max = -min;
	where = left;
	middle = (left + right) * 0.5;
	offcenter = middle - where;	/* how far off 'middle', 'where' is */
	for( i=0; i < cutp->bn.bn_len; i++ )  {
		val = cutp->bn.bn_list[i]->st_min[axis];
		if( val < min ) min = val;
		if( val > max ) max = val;
		d = val - middle;
		if( d < 0 )  d = (-d);
		if( d < offcenter )  {
			offcenter = d;
			where = val-0.1;
		}
		val = cutp->bn.bn_list[i]->st_max[axis];
		if( val < min ) min = val;
		if( val > max ) max = val;
		d = val - middle;
		if( d < 0 )  d = (-d);
		if( d < offcenter )  {
			offcenter = d;
			where = val+0.1;
		}
	}

	/* Loop over all the solid pieces */
	for( i = cutp->bn.bn_piecelen-1; i >= 0; i-- )  {
		struct rt_piecelist *plp = &cutp->bn.bn_piecelist[i];
		struct soltab *stp = plp->stp;
		int	j;

		RT_CK_PIECELIST(plp);
		for( j = plp->npieces-1; j >= 0; j-- )  {
			int indx = plp->pieces[j];
			struct bound_rpp *rpp = &stp->st_piece_rpps[indx];

			val = rpp->min[axis];
			if( val < min ) min = val;
			if( val > max ) max = val;
			d = val - middle;
			if( d < 0 )  d = (-d);
			if( d < offcenter )  {
				offcenter = d;
				where = val-0.1;
			}
			val = rpp->max[axis];
			if( val < min ) min = val;
			if( val > max ) max = val;
			d = val - middle;
			if( d < 0 )  d = (-d);
			if( d < offcenter )  {
				offcenter = d;
				where = val+0.1;
			}
		}
	}

	if(RT_G_DEBUG&DEBUG_CUTDETAIL)bu_log("rt_ct_old_assess() left=%g, where=%g, right=%g, offcenter=%g\n",

	      left, where, right, offcenter);

	if( where < min || where > max ) {
		/* this will make an empty cell.
		 * try splitting the range instead
		 */
		where = (max + min) / 2.0;
		offcenter = where - middle;
		if( offcenter < 0 ) {
			offcenter = -offcenter;
		}
	}

	if( where <= left || where >= right )
		return(0);	/* not reasonable */

	if( where - left <= 1.0 || right - where <= 1.0 )
		return(0);	/* cut will be too small */

	/* We are going to cut */
	*where_p = where;
	*offcenter_p = offcenter;
	return(1);
}

/*
 *			R T _ C T _ G E T
 *
 *  This routine must run in parallel
 */
HIDDEN union cutter *
rt_ct_get(struct rt_i *rtip)
{
	register union cutter *cutp;

	RT_CK_RTI(rtip);
	bu_semaphore_acquire(RT_SEM_MODEL);
	if( !rtip->rti_busy_cutter_nodes.l.magic )
		bu_ptbl_init( &rtip->rti_busy_cutter_nodes, 128, "rti_busy_cutter_nodes" );

	if( rtip->rti_CutFree == CUTTER_NULL )  {
		register int bytes;

		bytes = bu_malloc_len_roundup(64*sizeof(union cutter));
		cutp = (union cutter *)bu_malloc(bytes," rt_ct_get");
		/* Remember this allocation for later */
		bu_ptbl_ins( &rtip->rti_busy_cutter_nodes, (long *)cutp );
		/* Now, dice it up */
		while( bytes >= sizeof(union cutter) )  {
			cutp->cut_forw = rtip->rti_CutFree;
			rtip->rti_CutFree = cutp++;
			bytes -= sizeof(union cutter);
		}
	}
	cutp = rtip->rti_CutFree;
	rtip->rti_CutFree = cutp->cut_forw;
	bu_semaphore_release(RT_SEM_MODEL);

	cutp->cut_forw = CUTTER_NULL;
	return(cutp);
}

/*
 *			R T _ C T _ R E L E A S E _ S T O R A G E
 *
 *  Release subordinate storage
 */
HIDDEN void
rt_ct_release_storage(register union cutter *cutp)
{
	int i;

	switch( cutp->cut_type )  {

	case CUT_CUTNODE:
		break;

	case CUT_BOXNODE:
		if( cutp->bn.bn_list )  {
			bu_free( (char *)cutp->bn.bn_list, "bn_list[]");
			cutp->bn.bn_list = (struct soltab **)NULL;
		}
		cutp->bn.bn_len = 0;
		cutp->bn.bn_maxlen = 0;

		if( cutp->bn.bn_piecelist )  {
			for( i=0 ; i<cutp->bn.bn_piecelen ; i++ ) {
				struct rt_piecelist *olp = &cutp->bn.bn_piecelist[i];
				if( olp->pieces ) {
					bu_free( (char *)olp->pieces, "olp->pieces" );
				}
			}
			bu_free( (char *)cutp->bn.bn_piecelist, "bn_piecelist[]" );
			cutp->bn.bn_piecelist = (struct rt_piecelist *)NULL;
		}
		cutp->bn.bn_piecelen = 0;
		cutp->bn.bn_maxpiecelen = 0;
		break;

	case CUT_NUGRIDNODE:
		bu_free( (genptr_t)cutp->nugn.nu_grid, "NUGrid children" );
		cutp->nugn.nu_grid = NULL; /* sanity */

		for( i=0; i<3; i++ ) {
			bu_free( (genptr_t)cutp->nugn.nu_axis[i],
				 "NUGrid axis" );
			cutp->nugn.nu_axis[i] = NULL; /* sanity */
		}
		break;

	default:
		bu_log("rt_ct_release_storage: Unknown type=x%x\n", cutp->cut_type );
		break;
	}
}

/*
 *			R T _ C T _ F R E E
 *
 *  This routine must run in parallel
 */
HIDDEN void
rt_ct_free(struct rt_i *rtip, register union cutter *cutp)
{
	RT_CK_RTI(rtip);

	rt_ct_release_storage( cutp );

	/* Put on global free list */
	bu_semaphore_acquire(RT_SEM_MODEL);
	cutp->cut_forw = rtip->rti_CutFree;
	rtip->rti_CutFree = cutp;
	bu_semaphore_release(RT_SEM_MODEL);
}

/*
 *			R T _ P R _ C U T
 *  
 *  Print out a cut tree.
 */
void
rt_pr_cut(register const union cutter *cutp, int lvl)
                                  
        			/* recursion level */
{
	register int i,j;

	bu_log("%.8x ", cutp);
	for( i=lvl; i>0; i-- )
		bu_log("   ");

	if( cutp == CUTTER_NULL )  {
		bu_log("Null???\n");
		return;
	}

	switch( cutp->cut_type )  {

	case CUT_CUTNODE:
		bu_log("CUT L %c < %f\n",
			"XYZ?"[cutp->cn.cn_axis],
			cutp->cn.cn_point );
		rt_pr_cut( cutp->cn.cn_l, lvl+1 );

		bu_log("%.8x ", cutp);
		for( i=lvl; i>0; i-- )
			bu_log("   ");
		bu_log("CUT R %c >= %f\n",
			"XYZ?"[cutp->cn.cn_axis],
			cutp->cn.cn_point );
		rt_pr_cut( cutp->cn.cn_r, lvl+1 );
		return;

	case CUT_BOXNODE:
		bu_log("BOX Contains %d prims (%d alloc), %d prims with pieces:\n",
			cutp->bn.bn_len, cutp->bn.bn_maxlen,
			cutp->bn.bn_piecelen );
		bu_log("        ");
		for( i=lvl; i>0; i-- )
			bu_log("   ");
		VPRINT(" min", cutp->bn.bn_min);
		bu_log("        ");
		for( i=lvl; i>0; i-- )
			bu_log("   ");
		VPRINT(" max", cutp->bn.bn_max);

		/* Print names of regular solids */
		for( i=0; i < cutp->bn.bn_len; i++ )  {
			bu_log("        ");
			for( j=lvl; j>0; j-- )
				bu_log("   ");
			bu_log("    %s\n",
				cutp->bn.bn_list[i]->st_name);
		}

		/* Print names and piece lists of solids with pieces */
		for( i=0; i < cutp->bn.bn_piecelen; i++ )  {
			struct rt_piecelist *plp = &(cutp->bn.bn_piecelist[i]);
			struct soltab *stp;
			int j;

			RT_CK_PIECELIST(plp);
			stp = plp->stp;
			RT_CK_SOLTAB(stp);

			bu_log("        ");
			for( j=lvl; j>0; j-- )
				bu_log("   ");
			bu_log("    %s, %d pieces: ",
				stp->st_name, plp->npieces);

			/* Loop for every piece of this solid */
			for( j=0; j < plp->npieces; j++ )  {
				long indx = plp->pieces[j];
				bu_log("%ld, ", indx);
			}
			bu_log("\n");
		}
		return;

	case CUT_NUGRIDNODE:
		/* not implemented yet */
	default:
		bu_log("Unknown type=x%x\n", cutp->cut_type );
		break;
	}
	return;
}

/*
 *			R T _ F R _ C U T
 * 
 *  Free a whole cut tree below the indicated node.
 *  The strategy we use here is to free everything BELOW the given
 *  node, so as not to clobber rti_CutHead !
 */
void
rt_fr_cut(struct rt_i *rtip, register union cutter *cutp)
{
	RT_CK_RTI(rtip);
	if( cutp == CUTTER_NULL )  {
		bu_log("rt_fr_cut NULL\n");
		return;
	}

	switch( cutp->cut_type )  {

	case CUT_CUTNODE:
		rt_fr_cut( rtip, cutp->cn.cn_l );
		rt_ct_free( rtip, cutp->cn.cn_l );
		cutp->cn.cn_l = CUTTER_NULL;

		rt_fr_cut( rtip, cutp->cn.cn_r );
		rt_ct_free( rtip, cutp->cn.cn_r );
		cutp->cn.cn_r = CUTTER_NULL;
		return;

	case CUT_BOXNODE:
		rt_ct_release_storage(cutp);
		return;

	case CUT_NUGRIDNODE: {
		register int i;
		int len = cutp->nugn.nu_cells_per_axis[X] *
			cutp->nugn.nu_cells_per_axis[Y] *
			cutp->nugn.nu_cells_per_axis[Z];
		register union cutter *bp = cutp->nugn.nu_grid;

		for( i = len-1; i >= 0; i-- )  {
			rt_fr_cut( rtip, bp );
			bp->cut_type = 7;	/* sanity */
			bp++;
		}

		rt_ct_release_storage(cutp);
		return; }

	default:
		bu_log("rt_fr_cut: Unknown type=x%x\n", cutp->cut_type );
		break;
	}
	return;
}

/*
 *  			R T _ P L O T _ C U T
 */
HIDDEN void
rt_plot_cut(FILE *fp, struct rt_i *rtip, register union cutter *cutp, int lvl)
{
	RT_CK_RTI(rtip);
	switch( cutp->cut_type )  {
	case CUT_NUGRIDNODE: {
		union cutter *bp;
		int i, x, y, z;
		int xmax = cutp->nugn.nu_cells_per_axis[X],
		    ymax = cutp->nugn.nu_cells_per_axis[Y],
		    zmax = cutp->nugn.nu_cells_per_axis[Z];
		if( !cutp->nugn.nu_grid ) return;
		/* Don't draw the boxnodes since that produces far too many
		   segments.  Optimize the output a little by drawing whole
		   line segments (below). */
		for( i=0, bp=cutp->nugn.nu_grid; i < xmax*ymax*zmax; i++, bp++ ) {
			if( bp->cut_type != CUT_BOXNODE )
				rt_plot_cut( fp, rtip, bp, lvl );
		}
		pl_color( fp, 180, 180, 220 );
		--xmax; --ymax; --zmax;
		
		/* XY plane */
		pd_3line( fp,
			  cutp->nugn.nu_axis[X][0].nu_spos,
			  cutp->nugn.nu_axis[Y][0].nu_spos,
			  cutp->nugn.nu_axis[Z][0].nu_spos,
			  cutp->nugn.nu_axis[X][0].nu_spos,
			  cutp->nugn.nu_axis[Y][0].nu_spos,
			  cutp->nugn.nu_axis[Z][zmax].nu_epos);
		for( y=0; y<=ymax; y++ ) {
			pd_3line( fp,
				  cutp->nugn.nu_axis[X][0].nu_spos,
				  cutp->nugn.nu_axis[Y][y].nu_epos,
				  cutp->nugn.nu_axis[Z][0].nu_spos,
				  cutp->nugn.nu_axis[X][0].nu_spos,
				  cutp->nugn.nu_axis[Y][y].nu_epos,
				  cutp->nugn.nu_axis[Z][zmax].nu_epos);
		}
		for( x=0; x<=xmax; x++ ) {
			pd_3line( fp,
				  cutp->nugn.nu_axis[X][x].nu_epos,
				  cutp->nugn.nu_axis[Y][0].nu_spos,
				  cutp->nugn.nu_axis[Z][0].nu_spos,
				  cutp->nugn.nu_axis[X][x].nu_epos,
				  cutp->nugn.nu_axis[Y][0].nu_spos,
				  cutp->nugn.nu_axis[Z][zmax].nu_epos);
			for( y=0; y<=ymax; y++ ) {
				pd_3line( fp,
					  cutp->nugn.nu_axis[X][x].nu_epos,
					  cutp->nugn.nu_axis[Y][y].nu_epos,
					  cutp->nugn.nu_axis[Z][0].nu_spos,
					  cutp->nugn.nu_axis[X][x].nu_epos,
					  cutp->nugn.nu_axis[Y][y].nu_epos,
					  cutp->nugn.nu_axis[Z][zmax].nu_epos);
			}
		}

		/* YZ plane */
		pd_3line( fp,
			  cutp->nugn.nu_axis[X][0].nu_spos,
			  cutp->nugn.nu_axis[Y][0].nu_spos,
			  cutp->nugn.nu_axis[Z][0].nu_spos,
			  cutp->nugn.nu_axis[X][xmax].nu_epos,
			  cutp->nugn.nu_axis[Y][0].nu_spos,
			  cutp->nugn.nu_axis[Z][0].nu_spos);
		for( z=0; z<=zmax; z++ ) {
			pd_3line( fp,
				  cutp->nugn.nu_axis[X][0].nu_spos,
				  cutp->nugn.nu_axis[Y][0].nu_spos,
				  cutp->nugn.nu_axis[Z][z].nu_epos,
				  cutp->nugn.nu_axis[X][zmax].nu_epos,
				  cutp->nugn.nu_axis[Y][0].nu_spos,
				  cutp->nugn.nu_axis[Z][z].nu_epos);
		}
		for( y=0; y<=ymax; y++ ) {
			pd_3line( fp,
				  cutp->nugn.nu_axis[X][0].nu_spos,
				  cutp->nugn.nu_axis[Y][y].nu_epos,
				  cutp->nugn.nu_axis[Z][0].nu_spos,
				  cutp->nugn.nu_axis[X][xmax].nu_epos,
				  cutp->nugn.nu_axis[Y][y].nu_epos,
				  cutp->nugn.nu_axis[Z][0].nu_spos);
			for( z=0; z<=zmax; z++ ) {
				pd_3line( fp,
					  cutp->nugn.nu_axis[X][0].nu_spos,
					  cutp->nugn.nu_axis[Y][y].nu_epos,
					  cutp->nugn.nu_axis[Z][z].nu_epos,
					  cutp->nugn.nu_axis[X][zmax].nu_epos,
					  cutp->nugn.nu_axis[Y][y].nu_epos,
					  cutp->nugn.nu_axis[Z][z].nu_epos);
			}
		}

		/* XZ plane */
		pd_3line( fp,
			  cutp->nugn.nu_axis[X][0].nu_spos,
			  cutp->nugn.nu_axis[Y][0].nu_spos,
			  cutp->nugn.nu_axis[Z][0].nu_spos,
			  cutp->nugn.nu_axis[X][0].nu_spos,
			  cutp->nugn.nu_axis[Y][ymax].nu_epos,
			  cutp->nugn.nu_axis[Z][0].nu_spos);
		for( z=0; z<=zmax; z++ ) {
			pd_3line( fp,
				  cutp->nugn.nu_axis[X][0].nu_spos,
				  cutp->nugn.nu_axis[Y][0].nu_spos,
				  cutp->nugn.nu_axis[Z][z].nu_epos,
				  cutp->nugn.nu_axis[X][0].nu_spos,
				  cutp->nugn.nu_axis[Y][ymax].nu_epos,
				  cutp->nugn.nu_axis[Z][z].nu_epos);
		}
		for( x=0; x<=xmax; x++ ) {
			pd_3line( fp,
				  cutp->nugn.nu_axis[X][x].nu_epos,
				  cutp->nugn.nu_axis[Y][0].nu_spos,
				  cutp->nugn.nu_axis[Z][0].nu_spos,
				  cutp->nugn.nu_axis[X][x].nu_epos,
				  cutp->nugn.nu_axis[Y][ymax].nu_epos,
				  cutp->nugn.nu_axis[Z][0].nu_spos);
			for( z=0; z<=zmax; z++ ) {
				pd_3line( fp,
					  cutp->nugn.nu_axis[X][x].nu_epos,
					  cutp->nugn.nu_axis[Y][0].nu_spos,
					  cutp->nugn.nu_axis[Z][z].nu_epos,
					  cutp->nugn.nu_axis[X][x].nu_epos,
					  cutp->nugn.nu_axis[Y][ymax].nu_epos,
					  cutp->nugn.nu_axis[Z][z].nu_epos);
			}
		}
			
		return; }
	case CUT_CUTNODE:
		rt_plot_cut( fp, rtip, cutp->cn.cn_l, lvl+1 );
		rt_plot_cut( fp, rtip, cutp->cn.cn_r, lvl+1 );
		return;
	case CUT_BOXNODE:
		/* Should choose color based on lvl, need a table */
		pl_color( fp,
			(AXIS(lvl)==0)?255:0,
			(AXIS(lvl)==1)?255:0,
			(AXIS(lvl)==2)?255:0 );
		pdv_3box( fp, cutp->bn.bn_min, cutp->bn.bn_max );
		return;
	}
	return;
}

/*
 *			R T _ C T _ M E A S U R E
 *
 *  Find the maximum number of solids in a leaf node,
 *  and other interesting statistics.
 */
HIDDEN void
rt_ct_measure(register struct rt_i *rtip, register union cutter *cutp, int depth)
{
	register int	len;

	RT_CK_RTI(rtip);
	switch( cutp->cut_type ) {
	case CUT_NUGRIDNODE: {
		register int i;
		register union cutter *bp;
		len = cutp->nugn.nu_cells_per_axis[X] *
			cutp->nugn.nu_cells_per_axis[Y] *
			cutp->nugn.nu_cells_per_axis[Z];
		rtip->rti_ncut_by_type[CUT_NUGRIDNODE]++;
		for( i=0, bp=cutp->nugn.nu_grid; i<len; i++, bp++ )
			rt_ct_measure( rtip, bp, depth+1 );
		return; }
	case CUT_CUTNODE:
		rtip->rti_ncut_by_type[CUT_CUTNODE]++;
		rt_ct_measure( rtip, cutp->cn.cn_l, len = (depth+1) );
		rt_ct_measure( rtip, cutp->cn.cn_r, len );
		return;
	case CUT_BOXNODE:
		rtip->rti_ncut_by_type[CUT_BOXNODE]++;
		rtip->rti_cut_totobj += (len = cutp->bn.bn_len);
		if( rtip->rti_cut_maxlen < len )
			rtip->rti_cut_maxlen = len;
		if( rtip->rti_cut_maxdepth < depth )
			rtip->rti_cut_maxdepth = depth;
		BU_HIST_TALLY( &rtip->rti_hist_cellsize, len );
		len = rt_ct_piececount( cutp ) - len;
		BU_HIST_TALLY( &rtip->rti_hist_cell_pieces, len );
		BU_HIST_TALLY( &rtip->rti_hist_cutdepth, depth );
		if( len == 0 ) {
			rtip->nempty_cells++;
		}
		return;
	default:
		bu_log("rt_ct_measure: bad node x%x\n", cutp->cut_type);
		return;
	}
}

/*
 *			R T _ C U T _ C L E A N
 *
 *  The rtip->rti_CutFree list can not be freed directly
 *  because  is bulk allocated.
 *  Fortunately, we have a list of all the bu_malloc()'ed blocks.
 *  This routine may be called before the first frame is done,
 *  so it must be prepared for uninitialized items.
 */
void
rt_cut_clean(struct rt_i *rtip)
{
	genptr_t	*p;

	RT_CK_RTI(rtip);

	if( rtip->rti_cuts_waiting.l.magic )
		bu_ptbl_free( &rtip->rti_cuts_waiting );

	/* Abandon the linked list of diced-up structures */
	rtip->rti_CutFree = CUTTER_NULL;

	if( BU_LIST_UNINITIALIZED(&rtip->rti_busy_cutter_nodes.l) )
		return;

	/* Release the blocks we got from bu_malloc() */
	for( BU_PTBL_FOR( p, (genptr_t *), &rtip->rti_busy_cutter_nodes ) )  {
		bu_free( *p, "rt_ct_get" );
	}
	bu_ptbl_free( &rtip->rti_busy_cutter_nodes );
}

/*
 *			R T _ P R _ C U T _ I N F O
 */
void
rt_pr_cut_info(const struct rt_i *rtip, const char *str)
{
	const struct nugridnode	*nugnp;
	int			i;

	RT_CK_RTI(rtip);

	bu_log("%s %s: %d nu, %d cut, %d box (%d empty)\n",
		str,
		rtip->rti_space_partition == RT_PART_NUGRID ?
			"NUGrid" : "NUBSP",
		rtip->rti_ncut_by_type[CUT_NUGRIDNODE],
		rtip->rti_ncut_by_type[CUT_CUTNODE],
		rtip->rti_ncut_by_type[CUT_BOXNODE],
		rtip->nempty_cells );
	bu_log( "Cut: maxdepth=%d, nbins=%d, maxlen=%d, avg=%g\n",
		rtip->rti_cut_maxdepth,
		rtip->rti_ncut_by_type[CUT_BOXNODE],
		rtip->rti_cut_maxlen,
		((double)rtip->rti_cut_totobj) /
		rtip->rti_ncut_by_type[CUT_BOXNODE] );
	bu_hist_pr( &rtip->rti_hist_cellsize,
		    "cut_tree: Number of prims per leaf cell");
	bu_hist_pr( &rtip->rti_hist_cell_pieces,
		    "cut_tree: Number of prim pieces per leaf cell");
	bu_hist_pr( &rtip->rti_hist_cutdepth,
		    "cut_tree: Depth (height)");

	switch( rtip->rti_space_partition )  {
	case RT_PART_NUGRID:
		nugnp = &rtip->rti_CutHead.nugn;
		if( nugnp->nu_type != CUT_NUGRIDNODE )
			bu_bomb( "rt_pr_cut_info: passed non-nugridnode" );

		for( i=0; i<3; i++ ) {
			register int j;
			bu_log( "NUgrid %c axis:  %d cells\n", "XYZ*"[i],
				nugnp->nu_cells_per_axis[i] );
			for( j=0; j<nugnp->nu_cells_per_axis[i]; j++ ) {
				bu_log( "  %g .. %g, w=%g\n",
					nugnp->nu_axis[i][j].nu_spos,
					nugnp->nu_axis[i][j].nu_epos,
					nugnp->nu_axis[i][j].nu_width );
			}
		}
		break;
	case RT_PART_NUBSPT:
		/* Anything good to print here? */
		break;
	default:
		bu_bomb("rt_pr_cut_info() bad rti_space_partition\n");
	}
}

void
remove_from_bsp( struct soltab *stp, union cutter *cutp, struct bn_tol *tol )
{
	int index;
	int i;

	switch( cutp->cut_type ) {
	case CUT_BOXNODE:
		if( stp->st_npieces ) {
			int remove_count, new_count;
			struct rt_piecelist *new_piece_list;

			index = 0;
			remove_count = 0;
			for( index=0 ; index<cutp->bn.bn_piecelen ; index++ ) {
				if( cutp->bn.bn_piecelist[index].stp == stp ) {
					remove_count++;
				}
			}

			if( remove_count ) {
				new_count = cutp->bn.bn_piecelen - remove_count;
				if( new_count > 0 ) {
					new_piece_list = (struct rt_piecelist *)bu_calloc(
								    new_count,
								    sizeof( struct rt_piecelist ),
								    "bn_piecelist" );
				
					i = 0;
					for( index=0 ; index<cutp->bn.bn_piecelen ; index++ ) {
						if( cutp->bn.bn_piecelist[index].stp != stp ) {
							new_piece_list[i] = cutp->bn.bn_piecelist[index];
							i++;
						}
					}
				} else {
					new_count = 0;
					new_piece_list = NULL;
				}

				for( index=0 ; index<cutp->bn.bn_piecelen ; index++ ) {
					if( cutp->bn.bn_piecelist[index].stp == stp ) {
						bu_free( cutp->bn.bn_piecelist[index].pieces, "pieces" );
					}
				}
				bu_free( cutp->bn.bn_piecelist, "piecelist" );
				cutp->bn.bn_piecelist = new_piece_list;
				cutp->bn.bn_piecelen = new_count;
				cutp->bn.bn_maxpiecelen = new_count;
			}
		} else {
			for( index=0 ; index < cutp->bn.bn_len ; index++ ) {
				if( cutp->bn.bn_list[index] == stp ) {
					/* found it, now remove it */
					cutp->bn.bn_len--;
					for( i=index ; i < cutp->bn.bn_len ; i++ ) {
						cutp->bn.bn_list[i] = cutp->bn.bn_list[i+1];
					}
					return;
				}
			}
		}
		break;
	case CUT_CUTNODE:
		if( stp->st_min[cutp->cn.cn_axis] > cutp->cn.cn_point + tol->dist ) {
			remove_from_bsp( stp, cutp->cn.cn_r, tol );
		} else if( stp->st_max[cutp->cn.cn_axis] < cutp->cn.cn_point - tol->dist ) {
			remove_from_bsp( stp, cutp->cn.cn_l, tol );
		} else {
			remove_from_bsp( stp, cutp->cn.cn_r, tol );
			remove_from_bsp( stp, cutp->cn.cn_l, tol );
		}
		break;
	default:
		bu_log( "remove_from_bsp(): unrecognized cut type (%d) in BSP!!!\n" );
		bu_bomb( "remove_from_bsp(): unrecognized cut type in BSP!!!\n" );
	}
}

#define PIECE_BLOCK 512

void
insert_in_bsp( struct soltab *stp, union cutter *cutp )
{
	int i,j;

	switch( cutp->cut_type ) {
	case CUT_BOXNODE:
		if( stp->st_npieces == 0 ) {
			/* add the solid in this box */
			if( cutp->bn.bn_len >= cutp->bn.bn_maxlen ) {
				/* need more space */
				if( cutp->bn.bn_maxlen <= 0 )  {
					/* Initial allocation */
					cutp->bn.bn_maxlen = 5;
					cutp->bn.bn_list = (struct soltab **)bu_malloc(
						   cutp->bn.bn_maxlen * sizeof(struct soltab *),
							"insert_in_bsp: initial list alloc" );
				} else {
					cutp->bn.bn_maxlen += 5;
					cutp->bn.bn_list = (struct soltab **) bu_realloc(
								(genptr_t)cutp->bn.bn_list,
								sizeof(struct soltab *) * cutp->bn.bn_maxlen,
								"insert_in_bsp: list extend" );
				}
			}
			cutp->bn.bn_list[cutp->bn.bn_len++] = stp;

		} else {
			/* this solid uses pieces, add the appropriate pieces to this box */
			long pieces[PIECE_BLOCK];
			long *more_pieces=NULL;
			long more_pieces_alloced=0;
			long more_pieces_count=0;
			long piece_count=0;
			struct rt_piecelist *plp;

			for( i=0 ; i<stp->st_npieces ; i++ ) {
				struct bound_rpp *piece_rpp=&stp->st_piece_rpps[i];
				if( V3RPP_OVERLAP( piece_rpp->min, piece_rpp->max, cutp->bn.bn_min, cutp->bn.bn_max ) ) {
					if( piece_count < PIECE_BLOCK ) {
						pieces[piece_count++] = i;
					} else if( more_pieces_alloced == 0 ) {
						more_pieces_alloced = stp->st_npieces - PIECE_BLOCK;
						more_pieces = (long *)bu_malloc( sizeof( long ) * more_pieces_alloced,
										 "more_pieces" );
						more_pieces[more_pieces_count++] = i;
					} else {
						more_pieces[more_pieces_count++] = i;
					}
				}
			}

			if( cutp->bn.bn_piecelen >= cutp->bn.bn_maxpiecelen ) {
				cutp->bn.bn_piecelist = (struct rt_piecelist *)bu_realloc( cutp->bn.bn_piecelist,
								      sizeof( struct rt_piecelist ) * (++cutp->bn.bn_maxpiecelen),
								      "cutp->bn.bn_piecelist" );
			}

			if( !piece_count ) {
				return;
			}

			plp = &cutp->bn.bn_piecelist[cutp->bn.bn_piecelen++];
			plp->magic = RT_PIECELIST_MAGIC;
			plp->stp = stp;
			plp->npieces = piece_count + more_pieces_count;
			plp->pieces = (long *)bu_malloc( plp->npieces * sizeof( long ), "plp->pieces" );
			for( i=0 ; i<piece_count ; i++ ) {
				plp->pieces[i] = pieces[i];
			}
			j = piece_count;
			for( i=0 ; i<more_pieces_count ; i++ ) {
				plp->pieces[j++] = more_pieces[i];
			}

			if( more_pieces ) {
				bu_free( (char *)more_pieces, "more_pieces" );
			}
		}
		break;
	case CUT_CUTNODE:
		if( stp->st_min[cutp->cn.cn_axis] >= cutp->cn.cn_point ) {
			insert_in_bsp( stp, cutp->cn.cn_r );
		} else if( stp->st_max[cutp->cn.cn_axis] < cutp->cn.cn_point ) {
			insert_in_bsp( stp, cutp->cn.cn_l );
		} else {
			insert_in_bsp( stp, cutp->cn.cn_r );
			insert_in_bsp( stp, cutp->cn.cn_l );
		}
		break;
	default:
		bu_log( "insert_in_bsp(): unrecognized cut type (%d) in BSP!!!\n" );
		bu_bomb( "insert_in_bsp(): unrecognized cut type in BSP!!!\n" );
	}

}

void
fill_out_bsp( struct rt_i *rtip, union cutter *cutp, struct resource *resp, fastf_t bb[6] )
{
	fastf_t bb2[6];
	int i, j;

	switch( cutp->cut_type ) {
	case CUT_BOXNODE:
		j = 3;
		for( i=0 ; i<3 ; i++ ) {
			if( bb[i] >= INFINITY ) {
				/* this node is at the edge of the model BB, make it fill the BB */
				cutp->bn.bn_min[i] = rtip->mdl_min[i];
			}
			if( bb[j] <= -INFINITY ) {
				/* this node is at the edge of the model BB, make it fill the BB */
				cutp->bn.bn_max[i] = rtip->mdl_max[i];
			}
			j++;
		}
		break;
	case CUT_CUTNODE:
		VMOVE( bb2, bb );
		VMOVE( &bb2[3], &bb[3] );
		bb[cutp->cn.cn_axis] = cutp->cn.cn_point;
		fill_out_bsp( rtip, cutp->cn.cn_r, resp, bb );
		bb2[cutp->cn.cn_axis + 3] = cutp->cn.cn_point;
		fill_out_bsp( rtip, cutp->cn.cn_l, resp, bb2 );
		break;
	default:
		bu_log( "fill_out_bsp(): unrecognized cut type (%d) in BSP!!!\n" );
		bu_bomb( "fill_out_bsp(): unrecognized cut type in BSP!!!\n" );
	}

}
@


11.76
log
@change conf.h to a wrapped config.h
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /cvs/brlcad/librt/cut.c,v 11.75 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.75
log
@merge of ansi-6-0-branch into HEAD
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header$ (BRL)";
d32 5
a36 1
#include "conf.h"
@


11.74
log
@the function pointer cannot be static, but the struct can
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.73 2004/02/02 17:39:15 morrison Exp $ (BRL)";
d88 1
a88 7
rt_cut_one_axis( boxes, rtip, axis, min, max, nuginfop )
struct bu_ptbl	*boxes;
struct rt_i	*rtip;
int		axis;
int		min;
int		max;
struct nugridnode *nuginfop;
d148 1
a148 3
rt_cut_optimize_parallel( cpu, arg )
int		cpu;
genptr_t	arg;
d185 1
a185 2
rt_projXmin_comp( p1, p2 )
const void * p1, * p2;
d191 1
a191 2
rt_projXmax_comp( p1, p2 )
const void * p1, * p2;
d197 1
a197 2
rt_projYmin_comp( p1, p2 )
const void * p1, * p2;
d203 1
a203 2
rt_projYmax_comp( p1, p2 )
const void * p1, * p2;
d209 1
a209 2
rt_projZmin_comp( p1, p2 )
const void * p1, * p2;
d215 1
a215 2
rt_projZmax_comp( p1, p2 )
const void * p1, * p2;
d237 1
a237 5
rt_nugrid_cut( nugnp, fromp, rtip, just_collect_info, depth )
register struct nugridnode	*nugnp;
register struct boxnode		*fromp;
struct rt_i			*rtip;
int				 just_collect_info, depth;
d813 1
a813 3
rt_cut_it(rtip, ncpu)
register struct rt_i	*rtip;
int			ncpu;
d975 1
a975 4
rt_cut_extend( cutp, stp, rtip )
register union cutter	*cutp;
struct soltab		*stp;
const struct rt_i	*rtip;
d1050 1
a1050 4
rt_ct_plan( rtip, cutp, depth )
struct rt_i	*rtip;
union cutter	*cutp;
int		depth;
d1109 1
a1109 5
rt_ct_assess( cutp, axis, where_p, offcenter_p )
register union cutter *cutp;
register int	axis;
double		*where_p;
double		*offcenter_p;
d1194 1
a1194 4
rt_ct_populate_box( outp, inp, rtip )
union cutter		*outp;
const union cutter	*inp;
struct rt_i		*rtip;
d1350 1
a1350 6
rt_ct_box( rtip, cutp, axis, where, force )
struct rt_i		*rtip;
register union cutter	*cutp;
register int		axis;
double			where;
int			force;
d1423 1
a1423 5
rt_ck_overlap( min, max, stp, rtip )
register const vect_t	min;
register const vect_t	max;
register const struct soltab *stp;
register const struct rt_i *rtip;
d1459 1
a1459 2
rt_ct_piececount( cutp )
const union cutter *cutp;
d1486 1
a1486 4
rt_ct_optim( rtip, cutp, depth )
struct rt_i		*rtip;
register union cutter *cutp;
int	depth;
d1600 1
a1600 5
rt_ct_old_assess( cutp, axis, where_p, offcenter_p )
register union cutter *cutp;
register int axis;
double	*where_p;
double	*offcenter_p;
d1715 1
a1715 2
rt_ct_get(rtip)
struct rt_i	*rtip;
d1752 1
a1752 2
rt_ct_release_storage( cutp )
register union cutter	*cutp;
d1806 1
a1806 3
rt_ct_free( rtip, cutp )
struct rt_i		*rtip;
register union cutter	*cutp;
d1825 3
a1827 3
rt_pr_cut( cutp, lvl )
register const union cutter *cutp;
int lvl;			/* recursion level */
d1921 1
a1921 3
rt_fr_cut( rtip, cutp )
struct rt_i		*rtip;
register union cutter *cutp;
d1971 2
a1972 6
void
rt_plot_cut( fp, rtip, cutp, lvl )
FILE			*fp;
struct rt_i		*rtip;
register union cutter	*cutp;
int			lvl;
d2125 1
a2125 4
rt_ct_measure( rtip, cutp, depth )
register struct rt_i	*rtip;
register union cutter	*cutp;
int			depth;
d2177 1
a2177 2
rt_cut_clean(rtip)
struct rt_i	*rtip;
@


11.73
log
@update copyright to include span through 2003
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.72 2003/11/16 01:29:19 jra Exp $ (BRL)";
d234 3
a236 3
static struct cmp_pair {
	HIDDEN int (*cmp_min) BU_ARGS((const void *, const void *));
	HIDDEN int (*cmp_max) BU_ARGS((const void *, const void *));
@


11.72
log
@Debug print is now back in a debug block
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1990 by the United States Army.
d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.71 2003/10/29 16:20:41 jra Exp $ (BRL)";
@


11.71
log
@Mods to insert_in_bsp() and remove_from_bsp() for dynamic geometry
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.70 2003/10/07 01:23:49 morrison Exp $ (BRL)";
d875 1
a875 1
	/*	if( RT_G_DEBUG&DEBUG_CUT ) */
@


11.70
log
@whitespace
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.69 2003/09/12 14:41:35 jra Exp $ (BRL)";
d2322 1
a2322 1
remove_from_bsp( struct soltab *stp, union cutter *cutp )
d2330 5
d2337 27
a2363 4
					/* found it, now remove it */
					cutp->bn.bn_piecelen--;
					for( i=index ; i<cutp->bn.bn_piecelen ; i++ ) {
						cutp->bn.bn_piecelist[i] = cutp->bn.bn_piecelist[i+1];	/* struct copy */
a2364 1
					return;
d2366 4
d2385 4
a2388 4
		if( stp->st_min[cutp->cn.cn_axis] >= cutp->cn.cn_point ) {
			remove_from_bsp( stp, cutp->cn.cn_r );
		} else if( stp->st_max[cutp->cn.cn_axis] < cutp->cn.cn_point ) {
			remove_from_bsp( stp, cutp->cn.cn_l );
d2390 2
a2391 2
			remove_from_bsp( stp, cutp->cn.cn_r );
			remove_from_bsp( stp, cutp->cn.cn_l );
d2403 1
a2403 1
insert_in_bsp( struct soltab *stp, union cutter *cutp, struct resource *resp, fastf_t bb[6] )
a2408 18
		/* if this solid is bigger than the boxnode and we are at the edge of the model bb
		 * we must enlarge this boxnode and the model RPP
		 */
		for( i=0 ; i<3 ; i++ ) {
			if( bb[i] >= INFINITY && stp->st_min[i] < cutp->bn.bn_min[i] ) {
				cutp->bn.bn_min[i] = stp->st_min[i];
				if( stp->st_min[i] < stp->st_rtip->mdl_min[i] ) {
					stp->st_rtip->mdl_min[i] = stp->st_min[i];
				}
			}
			if( bb[i+3] <= -INFINITY && stp->st_max[i] > cutp->bn.bn_max[i] ) {
				cutp->bn.bn_max[i] = stp->st_max[i];
				if( stp->st_max[i] > stp->st_rtip->mdl_max[i] ) {
					stp->st_rtip->mdl_max[i] = stp->st_max[i];
				}
			}
		}

d2484 1
a2484 2
			bb[cutp->cn.cn_axis] = cutp->cn.cn_point;
			insert_in_bsp( stp, cutp->cn.cn_r, resp, bb );
d2486 1
a2486 2
			bb[cutp->cn.cn_axis + 3] = cutp->cn.cn_point;
			insert_in_bsp( stp, cutp->cn.cn_l, resp, bb );
d2488 2
a2489 8
			fastf_t bb2[6];

			VMOVE( bb2, bb );
			VMOVE( &bb2[3], &bb[3] );
			bb[cutp->cn.cn_axis] = cutp->cn.cn_point;
			insert_in_bsp( stp, cutp->cn.cn_r, resp, bb );
			bb2[cutp->cn.cn_axis + 3] = cutp->cn.cn_point;
			insert_in_bsp( stp, cutp->cn.cn_l, resp, bb2 );
@


11.70.2.1
log
@updates from HEAD, part 1
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.72 2003/11/16 01:29:19 jra Exp $ (BRL)";
d875 1
a875 1
	if( RT_G_DEBUG&DEBUG_CUT )
d2322 1
a2322 1
remove_from_bsp( struct soltab *stp, union cutter *cutp, struct bn_tol *tol )
a2329 5
			int remove_count, new_count;
			struct rt_piecelist *new_piece_list;

			index = 0;
			remove_count = 0;
d2332 4
a2335 27
					remove_count++;
				}
			}

			if( remove_count ) {
				new_count = cutp->bn.bn_piecelen - remove_count;
				if( new_count > 0 ) {
					new_piece_list = (struct rt_piecelist *)bu_calloc(
								    new_count,
								    sizeof( struct rt_piecelist ),
								    "bn_piecelist" );
				
					i = 0;
					for( index=0 ; index<cutp->bn.bn_piecelen ; index++ ) {
						if( cutp->bn.bn_piecelist[index].stp != stp ) {
							new_piece_list[i] = cutp->bn.bn_piecelist[index];
							i++;
						}
					}
				} else {
					new_count = 0;
					new_piece_list = NULL;
				}

				for( index=0 ; index<cutp->bn.bn_piecelen ; index++ ) {
					if( cutp->bn.bn_piecelist[index].stp == stp ) {
						bu_free( cutp->bn.bn_piecelist[index].pieces, "pieces" );
d2337 1
a2338 4
				bu_free( cutp->bn.bn_piecelist, "piecelist" );
				cutp->bn.bn_piecelist = new_piece_list;
				cutp->bn.bn_piecelen = new_count;
				cutp->bn.bn_maxpiecelen = new_count;
d2354 4
a2357 4
		if( stp->st_min[cutp->cn.cn_axis] > cutp->cn.cn_point + tol->dist ) {
			remove_from_bsp( stp, cutp->cn.cn_r, tol );
		} else if( stp->st_max[cutp->cn.cn_axis] < cutp->cn.cn_point - tol->dist ) {
			remove_from_bsp( stp, cutp->cn.cn_l, tol );
d2359 2
a2360 2
			remove_from_bsp( stp, cutp->cn.cn_r, tol );
			remove_from_bsp( stp, cutp->cn.cn_l, tol );
d2372 1
a2372 1
insert_in_bsp( struct soltab *stp, union cutter *cutp )
d2378 18
d2471 2
a2472 1
			insert_in_bsp( stp, cutp->cn.cn_r );
d2474 2
a2475 1
			insert_in_bsp( stp, cutp->cn.cn_l );
d2477 8
a2484 2
			insert_in_bsp( stp, cutp->cn.cn_r );
			insert_in_bsp( stp, cutp->cn.cn_l );
@


11.70.2.2
log
@merge from HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.73 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


11.70.2.3
log
@merge from head
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.74 2004/03/03 21:27:19 morrison Exp $ (BRL)";
d234 3
a236 3
HIDDEN struct cmp_pair {
	int (*cmp_min) BU_ARGS((const void *, const void *));
	int (*cmp_max) BU_ARGS((const void *, const void *));
@


11.70.2.4
log
@merge from head
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.70.2.3 2004/03/10 13:18:35 erikg Exp $ (BRL)";
@


11.69
log
@Forgot to update "offcenter" in rt_ct_old_assess()
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.68 2003/09/11 15:15:07 jra Exp $ (BRL)";
d939 1
a939 1
			bu_parallel( rt_cut_optimize_parallel, ncpu, rtip );
@


11.68
log
@now we look at all three directions before giving up on cutting a cell.
rt_ct_old_assess() now splits the range of filled space in a cell
in half rather than make an empty cell.
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.67 2003/03/08 04:33:24 jra Exp $ (BRL)";
d1741 4
@


11.67
log
@Bug fix in rt_split_mostly_empty_cells() to avoid infinite recursion.
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.66 2003/01/16 16:25:57 jra Exp $ (BRL)";
d54 1
a54 1
					   int axis, double where));
d801 6
a806 1
			if( rt_ct_box( rtip, cutp, max_empty_dir, where ) ) {
d873 1
a873 1
	if( rtip->rti_cutdepth < 9 )  rtip->rti_cutdepth = 9;
d875 2
a876 2
	if( RT_G_DEBUG&DEBUG_CUT )
		bu_log( "Cut: Tree Depth=%d, Leaf Len=%d\n",
d1111 1
a1111 1
		if( rt_ct_box( rtip, cutp, best, where[best] ) > 0 )
d1355 1
d1383 1
a1383 1
rt_ct_box( rtip, cutp, axis, where )
d1388 1
d1421 1
a1421 1
	if( success == 0 )  {
d1572 2
d1584 25
d1613 1
a1613 1
	if( rt_ct_box( rtip, cutp, axis, where ) == 0 )  {
d1616 1
a1616 1
		if( rt_ct_box( rtip, cutp, AXIS(depth+1), where ) == 0 )
d1619 1
d1622 1
a1622 1
/* 		if( RT_G_DEBUG&DEBUG_CUTDETAIL ) */
d1657 1
d1674 2
d1681 2
d1690 2
d1712 2
d1721 2
d1733 9
a1741 1
		left, where, right, offcenter);
d2216 3
@


11.67.4.1
log
@Merged head into branch
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.69 2003/09/12 14:41:35 jra Exp $ (BRL)";
d54 1
a54 1
					   int axis, double where, int force));
d801 1
a801 6
			if( where - cutp->bn.bn_min[max_empty_dir] < 2.0 ||
			    cutp->bn.bn_max[max_empty_dir] - where < 2.0 ) {
				/* will make a box too small */
				return( num_splits );
			}
			if( rt_ct_box( rtip, cutp, max_empty_dir, where, 1 ) ) {
d868 1
a868 1
	if( rtip->rti_cutdepth < 12 )  rtip->rti_cutdepth = 12;
d870 2
a871 2
	/*	if( RT_G_DEBUG&DEBUG_CUT ) */
		bu_log( "Before Space Partitioning: Max Tree Depth=%d, Cuttoff primitive count=%d\n",
d1106 1
a1106 1
		if( rt_ct_box( rtip, cutp, best, where[best], 0 ) > 0 )
a1349 1
			/*			if( plp->npieces > 0 ) success = 1; */
d1377 1
a1377 1
rt_ct_box( rtip, cutp, axis, where, force )
a1381 1
int			force;
d1414 1
a1414 1
	if( success == 0 && !force )  {
a1564 2
	int did_a_cut;
	int i;
a1574 25
#if 1
	did_a_cut = 0;
	for( i=0 ; i<3 ; i++ ) {
		axis += i;
		if( axis > Z ) {
			axis = X;
		}
		if( cutp->bn.bn_max[axis]-cutp->bn.bn_min[axis] < 2.0 ) {
			continue;
		}
		if( rt_ct_old_assess( cutp, axis, &where, &offcenter ) <= 0 ) {
			continue;
		}
		if( rt_ct_box( rtip, cutp, axis, where, 0 ) == 0 )  {
			continue;
		} else {
			did_a_cut = 1;
			break;
		}
	}

	if( !did_a_cut ) {
		return;
	}
#else
d1579 1
a1579 1
	if( rt_ct_box( rtip, cutp, axis, where, 0 ) == 0 )  {
d1582 1
a1582 1
		if( rt_ct_box( rtip, cutp, AXIS(depth+1), where, 0 ) == 0 )
a1584 1
#endif
d1587 1
a1587 1
 		if( RT_G_DEBUG&DEBUG_CUTDETAIL )
a1621 1
	fastf_t		max, min;
a1637 2
	min = MAX_FASTF;
	max = -min;
a1642 2
		if( val < min ) min = val;
		if( val > max ) max = val;
a1649 2
		if( val < min ) min = val;
		if( val > max ) max = val;
a1669 2
			if( val < min ) min = val;
			if( val > max ) max = val;
a1676 2
			if( val < min ) min = val;
			if( val > max ) max = val;
d1687 1
a1687 13

	      left, where, right, offcenter);

	if( where < min || where > max ) {
		/* this will make an empty cell.
		 * try splitting the range instead
		 */
		where = (max + min) / 2.0;
		offcenter = where - middle;
		if( offcenter < 0 ) {
			offcenter = -offcenter;
		}
	}
a2161 3
		if( len == 0 ) {
			rtip->nempty_cells++;
		}
@


11.66
log
@Added rt_split_mostly_empty_cells() to split mostly empty space partitioning cells
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.65 2002/09/30 14:02:27 jra Exp $ (BRL)";
d789 1
d791 4
a794 1
				where = max[max_empty_dir];
d796 4
a799 1
				where = min[max_empty_dir];
@


11.65
log
@Added code to support dynamic geometry
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.64 2002/09/03 16:26:55 jra Exp $ (BRL)";
d708 100
d826 1
d931 7
@


11.64
log
@Mod to rt_ct_populate_box() to minimize memory use
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.63 2002/08/20 17:07:56 jra Exp $ (BRL)";
d64 1
a64 1
HIDDEN void		rt_plot_cut BU_ARGS((FILE *fp, struct rt_i *rtip,
d901 1
d1136 1
d1143 1
d1156 1
a1156 1
			olp->npieces = 0;
d1659 1
d1854 1
a1854 1
HIDDEN void
d2143 209
@


11.64.4.1
log
@sync to HEAD...
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/cut.c,v 11.74 2004/03/03 21:27:19 morrison Exp $ (BRL)";
d54 1
a54 1
					   int axis, double where, int force));
d64 1
a64 1
void		rt_plot_cut BU_ARGS((FILE *fp, struct rt_i *rtip,
d234 3
a236 3
HIDDEN struct cmp_pair {
	int (*cmp_min) BU_ARGS((const void *, const void *));
	int (*cmp_max) BU_ARGS((const void *, const void *));
a707 112
int
rt_split_mostly_empty_cells( struct rt_i *rtip, union cutter *cutp )
{
	point_t max, min;
	struct soltab *stp;
	struct rt_piecelist pl;
	fastf_t range[3], empty[3], tmp;
	int upper_or_lower[3];
	fastf_t max_empty;
	int max_empty_dir;
	int i;
	int num_splits=0;

	switch( cutp->cut_type ) {
	case CUT_CUTNODE:
		num_splits += rt_split_mostly_empty_cells( rtip, cutp->cn.cn_l );
		num_splits += rt_split_mostly_empty_cells( rtip, cutp->cn.cn_r );
		break;
	case CUT_BOXNODE:
		/* find the actual bounds of stuff in this cell */
		if( cutp->bn.bn_len == 0 && cutp->bn.bn_piecelen == 0 ) {
			break;
		}
		VSETALL( min, MAX_FASTF );
		VREVERSE( max, min );

		for( i=0 ; i<cutp->bn.bn_len ; i++ ) {
			stp = cutp->bn.bn_list[i];
			VMIN( min, stp->st_min );
			VMAX( max, stp->st_max );
		}

		for( i=0 ; i<cutp->bn.bn_piecelen ; i++ ) {
			int j;

			pl = cutp->bn.bn_piecelist[i];
			for( j=0 ; j<pl.npieces ; j++ ) {
				int piecenum;

				piecenum = pl.pieces[j];
				VMIN( min, pl.stp->st_piece_rpps[piecenum].min );
				VMAX( max, pl.stp->st_piece_rpps[piecenum].max );
			}
		}

		/* clip min and max to the bounds of this cell */
		for( i=X ; i<=Z ; i++ ) {
			if( min[i] < cutp->bn.bn_min[i] ) {
				min[i] = cutp->bn.bn_min[i];
			}
			if( max[i] > cutp->bn.bn_max[i] ) {
				max[i] = cutp->bn.bn_max[i];
			}
		}

		/* min and max now have the real bounds of data in this cell */
		VSUB2( range, cutp->bn.bn_max, cutp->bn.bn_min );
		for( i=X ; i<=Z ; i++ ) {
			empty[i] = cutp->bn.bn_max[i] - max[i];
			upper_or_lower[i] = 1; /* upper section is empty */
			tmp = min[i] - cutp->bn.bn_min[i];
			if( tmp > empty[i] ) {
				empty[i] = tmp;
				upper_or_lower[i] = 0;	/* lower section is empty */
			}
		}
		max_empty = empty[X];
		max_empty_dir = X;
		if( empty[Y] > max_empty ) {
			max_empty = empty[Y];
			max_empty_dir = Y;
		}
		if( empty[Z] > max_empty ) {
			max_empty = empty[Z];
			max_empty_dir = Z;
		}
		if( max_empty / range[max_empty_dir] > 0.5 ) {
			/* this cell is over 50% empty in this direction, split it */

			fastf_t where;

			/* select cutting plane, but move it slightly off any geometry */
			if( upper_or_lower[max_empty_dir] ) {
			        where = max[max_empty_dir] + rtip->rti_tol.dist;
				if( where >= cutp->bn.bn_max[max_empty_dir] ) {
				       return( num_splits );
				}
			} else {
				where = min[max_empty_dir] - rtip->rti_tol.dist;
				if( where <= cutp->bn.bn_min[max_empty_dir] ) {
				       return( num_splits );
				}
			}
			if( where - cutp->bn.bn_min[max_empty_dir] < 2.0 ||
			    cutp->bn.bn_max[max_empty_dir] - where < 2.0 ) {
				/* will make a box too small */
				return( num_splits );
			}
			if( rt_ct_box( rtip, cutp, max_empty_dir, where, 1 ) ) {
				num_splits++;
				num_splits += rt_split_mostly_empty_cells( rtip, cutp->cn.cn_l );
				num_splits += rt_split_mostly_empty_cells( rtip, cutp->cn.cn_r );
			}
		}
		break;
	}

	return( num_splits );
}



a725 1
	int num_splits=0;
d760 1
a760 1
	if( rtip->rti_cutdepth < 12 )  rtip->rti_cutdepth = 12;
d763 1
a763 1
		bu_log( "Before Space Partitioning: Max Tree Depth=%d, Cuttoff primitive count=%d\n",
d826 1
a826 1
				bu_parallel( rt_cut_optimize_parallel, ncpu, rtip );
a829 7
		/* one more pass to find cells that are mostly empty */
		num_splits = rt_split_mostly_empty_cells( rtip,  &rtip->rti_CutHead );

		if( RT_G_DEBUG&DEBUG_CUT ) {
			bu_log( "rt_split_mostly_empty_cells(): split %d cells\n", num_splits );
		}

a900 1
			cutp->bn.bn_maxpiecelen = rtip->nsolids + 2;
d990 1
a990 1
		if( rt_ct_box( rtip, cutp, best, where[best], 0 ) > 0 )
a1134 1
		outp->bn.bn_maxpiecelen = 0;
a1140 1
	outp->bn.bn_maxpiecelen = inp->bn.bn_piecelen;
d1153 1
a1153 1
		olp->npieces = 0;
a1231 1
			/*			if( plp->npieces > 0 ) success = 1; */
d1259 1
a1259 1
rt_ct_box( rtip, cutp, axis, where, force )
a1263 1
int			force;
d1296 1
a1296 1
	if( success == 0 && !force )  {
a1446 2
	int did_a_cut;
	int i;
a1456 25
#if 1
	did_a_cut = 0;
	for( i=0 ; i<3 ; i++ ) {
		axis += i;
		if( axis > Z ) {
			axis = X;
		}
		if( cutp->bn.bn_max[axis]-cutp->bn.bn_min[axis] < 2.0 ) {
			continue;
		}
		if( rt_ct_old_assess( cutp, axis, &where, &offcenter ) <= 0 ) {
			continue;
		}
		if( rt_ct_box( rtip, cutp, axis, where, 0 ) == 0 )  {
			continue;
		} else {
			did_a_cut = 1;
			break;
		}
	}

	if( !did_a_cut ) {
		return;
	}
#else
d1461 1
a1461 1
	if( rt_ct_box( rtip, cutp, axis, where, 0 ) == 0 )  {
d1464 1
a1464 1
		if( rt_ct_box( rtip, cutp, AXIS(depth+1), where, 0 ) == 0 )
a1466 1
#endif
d1469 1
a1469 1
 		if( RT_G_DEBUG&DEBUG_CUTDETAIL )
a1503 1
	fastf_t		max, min;
a1519 2
	min = MAX_FASTF;
	max = -min;
a1524 2
		if( val < min ) min = val;
		if( val > max ) max = val;
a1531 2
		if( val < min ) min = val;
		if( val > max ) max = val;
a1551 2
			if( val < min ) min = val;
			if( val > max ) max = val;
a1558 2
			if( val < min ) min = val;
			if( val > max ) max = val;
d1569 1
a1569 13

	      left, where, right, offcenter);

	if( where < min || where > max ) {
		/* this will make an empty cell.
		 * try splitting the range instead
		 */
		where = (max + min) / 2.0;
		offcenter = where - middle;
		if( offcenter < 0 ) {
			offcenter = -offcenter;
		}
	}
a1655 1
		cutp->bn.bn_maxpiecelen = 0;
d1850 1
a1850 1
void
a2042 3
		if( len == 0 ) {
			rtip->nempty_cells++;
		}
a2138 214
}

void
remove_from_bsp( struct soltab *stp, union cutter *cutp, struct bn_tol *tol )
{
	int index;
	int i;

	switch( cutp->cut_type ) {
	case CUT_BOXNODE:
		if( stp->st_npieces ) {
			int remove_count, new_count;
			struct rt_piecelist *new_piece_list;

			index = 0;
			remove_count = 0;
			for( index=0 ; index<cutp->bn.bn_piecelen ; index++ ) {
				if( cutp->bn.bn_piecelist[index].stp == stp ) {
					remove_count++;
				}
			}

			if( remove_count ) {
				new_count = cutp->bn.bn_piecelen - remove_count;
				if( new_count > 0 ) {
					new_piece_list = (struct rt_piecelist *)bu_calloc(
								    new_count,
								    sizeof( struct rt_piecelist ),
								    "bn_piecelist" );
				
					i = 0;
					for( index=0 ; index<cutp->bn.bn_piecelen ; index++ ) {
						if( cutp->bn.bn_piecelist[index].stp != stp ) {
							new_piece_list[i] = cutp->bn.bn_piecelist[index];
							i++;
						}
					}
				} else {
					new_count = 0;
					new_piece_list = NULL;
				}

				for( index=0 ; index<cutp->bn.bn_piecelen ; index++ ) {
					if( cutp->bn.bn_piecelist[index].stp == stp ) {
						bu_free( cutp->bn.bn_piecelist[index].pieces, "pieces" );
					}
				}
				bu_free( cutp->bn.bn_piecelist, "piecelist" );
				cutp->bn.bn_piecelist = new_piece_list;
				cutp->bn.bn_piecelen = new_count;
				cutp->bn.bn_maxpiecelen = new_count;
			}
		} else {
			for( index=0 ; index < cutp->bn.bn_len ; index++ ) {
				if( cutp->bn.bn_list[index] == stp ) {
					/* found it, now remove it */
					cutp->bn.bn_len--;
					for( i=index ; i < cutp->bn.bn_len ; i++ ) {
						cutp->bn.bn_list[i] = cutp->bn.bn_list[i+1];
					}
					return;
				}
			}
		}
		break;
	case CUT_CUTNODE:
		if( stp->st_min[cutp->cn.cn_axis] > cutp->cn.cn_point + tol->dist ) {
			remove_from_bsp( stp, cutp->cn.cn_r, tol );
		} else if( stp->st_max[cutp->cn.cn_axis] < cutp->cn.cn_point - tol->dist ) {
			remove_from_bsp( stp, cutp->cn.cn_l, tol );
		} else {
			remove_from_bsp( stp, cutp->cn.cn_r, tol );
			remove_from_bsp( stp, cutp->cn.cn_l, tol );
		}
		break;
	default:
		bu_log( "remove_from_bsp(): unrecognized cut type (%d) in BSP!!!\n" );
		bu_bomb( "remove_from_bsp(): unrecognized cut type in BSP!!!\n" );
	}
}

#define PIECE_BLOCK 512

void
insert_in_bsp( struct soltab *stp, union cutter *cutp )
{
	int i,j;

	switch( cutp->cut_type ) {
	case CUT_BOXNODE:
		if( stp->st_npieces == 0 ) {
			/* add the solid in this box */
			if( cutp->bn.bn_len >= cutp->bn.bn_maxlen ) {
				/* need more space */
				if( cutp->bn.bn_maxlen <= 0 )  {
					/* Initial allocation */
					cutp->bn.bn_maxlen = 5;
					cutp->bn.bn_list = (struct soltab **)bu_malloc(
						   cutp->bn.bn_maxlen * sizeof(struct soltab *),
							"insert_in_bsp: initial list alloc" );
				} else {
					cutp->bn.bn_maxlen += 5;
					cutp->bn.bn_list = (struct soltab **) bu_realloc(
								(genptr_t)cutp->bn.bn_list,
								sizeof(struct soltab *) * cutp->bn.bn_maxlen,
								"insert_in_bsp: list extend" );
				}
			}
			cutp->bn.bn_list[cutp->bn.bn_len++] = stp;

		} else {
			/* this solid uses pieces, add the appropriate pieces to this box */
			long pieces[PIECE_BLOCK];
			long *more_pieces=NULL;
			long more_pieces_alloced=0;
			long more_pieces_count=0;
			long piece_count=0;
			struct rt_piecelist *plp;

			for( i=0 ; i<stp->st_npieces ; i++ ) {
				struct bound_rpp *piece_rpp=&stp->st_piece_rpps[i];
				if( V3RPP_OVERLAP( piece_rpp->min, piece_rpp->max, cutp->bn.bn_min, cutp->bn.bn_max ) ) {
					if( piece_count < PIECE_BLOCK ) {
						pieces[piece_count++] = i;
					} else if( more_pieces_alloced == 0 ) {
						more_pieces_alloced = stp->st_npieces - PIECE_BLOCK;
						more_pieces = (long *)bu_malloc( sizeof( long ) * more_pieces_alloced,
										 "more_pieces" );
						more_pieces[more_pieces_count++] = i;
					} else {
						more_pieces[more_pieces_count++] = i;
					}
				}
			}

			if( cutp->bn.bn_piecelen >= cutp->bn.bn_maxpiecelen ) {
				cutp->bn.bn_piecelist = (struct rt_piecelist *)bu_realloc( cutp->bn.bn_piecelist,
								      sizeof( struct rt_piecelist ) * (++cutp->bn.bn_maxpiecelen),
								      "cutp->bn.bn_piecelist" );
			}

			if( !piece_count ) {
				return;
			}

			plp = &cutp->bn.bn_piecelist[cutp->bn.bn_piecelen++];
			plp->magic = RT_PIECELIST_MAGIC;
			plp->stp = stp;
			plp->npieces = piece_count + more_pieces_count;
			plp->pieces = (long *)bu_malloc( plp->npieces * sizeof( long ), "plp->pieces" );
			for( i=0 ; i<piece_count ; i++ ) {
				plp->pieces[i] = pieces[i];
			}
			j = piece_count;
			for( i=0 ; i<more_pieces_count ; i++ ) {
				plp->pieces[j++] = more_pieces[i];
			}

			if( more_pieces ) {
				bu_free( (char *)more_pieces, "more_pieces" );
			}
		}
		break;
	case CUT_CUTNODE:
		if( stp->st_min[cutp->cn.cn_axis] >= cutp->cn.cn_point ) {
			insert_in_bsp( stp, cutp->cn.cn_r );
		} else if( stp->st_max[cutp->cn.cn_axis] < cutp->cn.cn_point ) {
			insert_in_bsp( stp, cutp->cn.cn_l );
		} else {
			insert_in_bsp( stp, cutp->cn.cn_r );
			insert_in_bsp( stp, cutp->cn.cn_l );
		}
		break;
	default:
		bu_log( "insert_in_bsp(): unrecognized cut type (%d) in BSP!!!\n" );
		bu_bomb( "insert_in_bsp(): unrecognized cut type in BSP!!!\n" );
	}

}

void
fill_out_bsp( struct rt_i *rtip, union cutter *cutp, struct resource *resp, fastf_t bb[6] )
{
	fastf_t bb2[6];
	int i, j;

	switch( cutp->cut_type ) {
	case CUT_BOXNODE:
		j = 3;
		for( i=0 ; i<3 ; i++ ) {
			if( bb[i] >= INFINITY ) {
				/* this node is at the edge of the model BB, make it fill the BB */
				cutp->bn.bn_min[i] = rtip->mdl_min[i];
			}
			if( bb[j] <= -INFINITY ) {
				/* this node is at the edge of the model BB, make it fill the BB */
				cutp->bn.bn_max[i] = rtip->mdl_max[i];
			}
			j++;
		}
		break;
	case CUT_CUTNODE:
		VMOVE( bb2, bb );
		VMOVE( &bb2[3], &bb[3] );
		bb[cutp->cn.cn_axis] = cutp->cn.cn_point;
		fill_out_bsp( rtip, cutp->cn.cn_r, resp, bb );
		bb2[cutp->cn.cn_axis + 3] = cutp->cn.cn_point;
		fill_out_bsp( rtip, cutp->cn.cn_l, resp, bb2 );
		break;
	default:
		bu_log( "fill_out_bsp(): unrecognized cut type (%d) in BSP!!!\n" );
		bu_bomb( "fill_out_bsp(): unrecognized cut type in BSP!!!\n" );
	}

@


11.64.2.1
log
@Initial ANSIfication
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.64 2002/09/03 16:26:55 jra Exp $ (BRL)";
d88 7
a94 1
rt_cut_one_axis(struct bu_ptbl *boxes, struct rt_i *rtip, int axis, int min, int max, struct nugridnode *nuginfop)
d154 3
a156 1
rt_cut_optimize_parallel(int cpu, genptr_t arg)
d193 2
a194 1
rt_projXmin_comp(const void *p1, const void *p2)
d200 2
a201 1
rt_projXmax_comp(const void *p1, const void *p2)
d207 2
a208 1
rt_projYmin_comp(const void *p1, const void *p2)
d214 2
a215 1
rt_projYmax_comp(const void *p1, const void *p2)
d221 2
a222 1
rt_projZmin_comp(const void *p1, const void *p2)
d228 2
a229 1
rt_projZmax_comp(const void *p1, const void *p2)
d251 5
a255 1
rt_nugrid_cut(register struct nugridnode *nugnp, register struct boxnode *fromp, struct rt_i *rtip, int just_collect_info, int depth)
d719 3
a721 1
rt_cut_it(register struct rt_i *rtip, int ncpu)
d875 4
a878 1
rt_cut_extend(register union cutter *cutp, struct soltab *stp, const struct rt_i *rtip)
d952 4
a955 1
rt_ct_plan(struct rt_i *rtip, union cutter *cutp, int depth)
d1014 5
a1018 1
rt_ct_assess(register union cutter *cutp, register int axis, double *where_p, double *offcenter_p)
d1103 4
a1106 1
rt_ct_populate_box(union cutter *outp, const union cutter *inp, struct rt_i *rtip)
d1259 5
a1263 1
rt_ct_box(struct rt_i *rtip, register union cutter *cutp, register int axis, double where)
d1336 5
a1340 1
rt_ck_overlap(register const fastf_t *min, register const fastf_t *max, register const struct soltab *stp, register const struct rt_i *rtip)
d1376 2
a1377 1
rt_ct_piececount(const union cutter *cutp)
d1404 4
a1407 1
rt_ct_optim(struct rt_i *rtip, register union cutter *cutp, int depth)
d1493 5
a1497 1
rt_ct_old_assess(register union cutter *cutp, register int axis, double *where_p, double *offcenter_p)
d1589 2
a1590 1
rt_ct_get(struct rt_i *rtip)
d1627 2
a1628 1
rt_ct_release_storage(register union cutter *cutp)
d1681 3
a1683 1
rt_ct_free(struct rt_i *rtip, register union cutter *cutp)
d1702 3
a1704 3
rt_pr_cut(register const union cutter *cutp, int lvl)
                                  
        			/* recursion level */
d1798 3
a1800 1
rt_fr_cut(struct rt_i *rtip, register union cutter *cutp)
d1851 5
a1855 1
rt_plot_cut(FILE *fp, struct rt_i *rtip, register union cutter *cutp, int lvl)
d2008 4
a2011 1
rt_ct_measure(register struct rt_i *rtip, register union cutter *cutp, int depth)
d2060 2
a2061 1
rt_cut_clean(struct rt_i *rtip)
@


11.64.2.2
log
@sync branch with HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d29 1
a29 1
static const char RCScut[] = "@@(#)$Header$ (BRL)";
d54 1
a54 1
					   int axis, double where, int force));
d64 1
a64 1
void		rt_plot_cut BU_ARGS((FILE *fp, struct rt_i *rtip,
d220 3
a222 3
HIDDEN struct cmp_pair {
	int (*cmp_min) BU_ARGS((const void *, const void *));
	int (*cmp_max) BU_ARGS((const void *, const void *));
a689 112
int
rt_split_mostly_empty_cells( struct rt_i *rtip, union cutter *cutp )
{
	point_t max, min;
	struct soltab *stp;
	struct rt_piecelist pl;
	fastf_t range[3], empty[3], tmp;
	int upper_or_lower[3];
	fastf_t max_empty;
	int max_empty_dir;
	int i;
	int num_splits=0;

	switch( cutp->cut_type ) {
	case CUT_CUTNODE:
		num_splits += rt_split_mostly_empty_cells( rtip, cutp->cn.cn_l );
		num_splits += rt_split_mostly_empty_cells( rtip, cutp->cn.cn_r );
		break;
	case CUT_BOXNODE:
		/* find the actual bounds of stuff in this cell */
		if( cutp->bn.bn_len == 0 && cutp->bn.bn_piecelen == 0 ) {
			break;
		}
		VSETALL( min, MAX_FASTF );
		VREVERSE( max, min );

		for( i=0 ; i<cutp->bn.bn_len ; i++ ) {
			stp = cutp->bn.bn_list[i];
			VMIN( min, stp->st_min );
			VMAX( max, stp->st_max );
		}

		for( i=0 ; i<cutp->bn.bn_piecelen ; i++ ) {
			int j;

			pl = cutp->bn.bn_piecelist[i];
			for( j=0 ; j<pl.npieces ; j++ ) {
				int piecenum;

				piecenum = pl.pieces[j];
				VMIN( min, pl.stp->st_piece_rpps[piecenum].min );
				VMAX( max, pl.stp->st_piece_rpps[piecenum].max );
			}
		}

		/* clip min and max to the bounds of this cell */
		for( i=X ; i<=Z ; i++ ) {
			if( min[i] < cutp->bn.bn_min[i] ) {
				min[i] = cutp->bn.bn_min[i];
			}
			if( max[i] > cutp->bn.bn_max[i] ) {
				max[i] = cutp->bn.bn_max[i];
			}
		}

		/* min and max now have the real bounds of data in this cell */
		VSUB2( range, cutp->bn.bn_max, cutp->bn.bn_min );
		for( i=X ; i<=Z ; i++ ) {
			empty[i] = cutp->bn.bn_max[i] - max[i];
			upper_or_lower[i] = 1; /* upper section is empty */
			tmp = min[i] - cutp->bn.bn_min[i];
			if( tmp > empty[i] ) {
				empty[i] = tmp;
				upper_or_lower[i] = 0;	/* lower section is empty */
			}
		}
		max_empty = empty[X];
		max_empty_dir = X;
		if( empty[Y] > max_empty ) {
			max_empty = empty[Y];
			max_empty_dir = Y;
		}
		if( empty[Z] > max_empty ) {
			max_empty = empty[Z];
			max_empty_dir = Z;
		}
		if( max_empty / range[max_empty_dir] > 0.5 ) {
			/* this cell is over 50% empty in this direction, split it */

			fastf_t where;

			/* select cutting plane, but move it slightly off any geometry */
			if( upper_or_lower[max_empty_dir] ) {
			        where = max[max_empty_dir] + rtip->rti_tol.dist;
				if( where >= cutp->bn.bn_max[max_empty_dir] ) {
				       return( num_splits );
				}
			} else {
				where = min[max_empty_dir] - rtip->rti_tol.dist;
				if( where <= cutp->bn.bn_min[max_empty_dir] ) {
				       return( num_splits );
				}
			}
			if( where - cutp->bn.bn_min[max_empty_dir] < 2.0 ||
			    cutp->bn.bn_max[max_empty_dir] - where < 2.0 ) {
				/* will make a box too small */
				return( num_splits );
			}
			if( rt_ct_box( rtip, cutp, max_empty_dir, where, 1 ) ) {
				num_splits++;
				num_splits += rt_split_mostly_empty_cells( rtip, cutp->cn.cn_l );
				num_splits += rt_split_mostly_empty_cells( rtip, cutp->cn.cn_r );
			}
		}
		break;
	}

	return( num_splits );
}



a705 1
	int num_splits=0;
d740 1
a740 1
	if( rtip->rti_cutdepth < 12 )  rtip->rti_cutdepth = 12;
d743 1
a743 1
		bu_log( "Before Space Partitioning: Max Tree Depth=%d, Cuttoff primitive count=%d\n",
d806 1
a806 1
				bu_parallel( rt_cut_optimize_parallel, ncpu, rtip );
a809 7
		/* one more pass to find cells that are mostly empty */
		num_splits = rt_split_mostly_empty_cells( rtip,  &rtip->rti_CutHead );

		if( RT_G_DEBUG&DEBUG_CUT ) {
			bu_log( "rt_split_mostly_empty_cells(): split %d cells\n", num_splits );
		}

a877 1
			cutp->bn.bn_maxpiecelen = rtip->nsolids + 2;
d964 1
a964 1
		if( rt_ct_box( rtip, cutp, best, where[best], 0 ) > 0 )
a1101 1
		outp->bn.bn_maxpiecelen = 0;
a1107 1
	outp->bn.bn_maxpiecelen = inp->bn.bn_piecelen;
d1120 1
a1120 1
		olp->npieces = 0;
a1198 1
			/*			if( plp->npieces > 0 ) success = 1; */
d1226 1
a1226 1
rt_ct_box(struct rt_i *rtip, register union cutter *cutp, register int axis, double where, int force)
d1259 1
a1259 1
	if( success == 0 && !force )  {
a1401 2
	int did_a_cut;
	int i;
a1411 25
#if 1
	did_a_cut = 0;
	for( i=0 ; i<3 ; i++ ) {
		axis += i;
		if( axis > Z ) {
			axis = X;
		}
		if( cutp->bn.bn_max[axis]-cutp->bn.bn_min[axis] < 2.0 ) {
			continue;
		}
		if( rt_ct_old_assess( cutp, axis, &where, &offcenter ) <= 0 ) {
			continue;
		}
		if( rt_ct_box( rtip, cutp, axis, where, 0 ) == 0 )  {
			continue;
		} else {
			did_a_cut = 1;
			break;
		}
	}

	if( !did_a_cut ) {
		return;
	}
#else
d1416 1
a1416 1
	if( rt_ct_box( rtip, cutp, axis, where, 0 ) == 0 )  {
d1419 1
a1419 1
		if( rt_ct_box( rtip, cutp, AXIS(depth+1), where, 0 ) == 0 )
a1421 1
#endif
d1424 1
a1424 1
 		if( RT_G_DEBUG&DEBUG_CUTDETAIL )
a1454 1
	fastf_t		max, min;
a1470 2
	min = MAX_FASTF;
	max = -min;
a1475 2
		if( val < min ) min = val;
		if( val > max ) max = val;
a1482 2
		if( val < min ) min = val;
		if( val > max ) max = val;
a1502 2
			if( val < min ) min = val;
			if( val > max ) max = val;
a1509 2
			if( val < min ) min = val;
			if( val > max ) max = val;
d1520 1
a1520 13

	      left, where, right, offcenter);

	if( where < min || where > max ) {
		/* this will make an empty cell.
		 * try splitting the range instead
		 */
		where = (max + min) / 2.0;
		offcenter = where - middle;
		if( offcenter < 0 ) {
			offcenter = -offcenter;
		}
	}
a1604 1
		cutp->bn.bn_maxpiecelen = 0;
a1980 3
		if( len == 0 ) {
			rtip->nempty_cells++;
		}
a2075 214
}

void
remove_from_bsp( struct soltab *stp, union cutter *cutp, struct bn_tol *tol )
{
	int index;
	int i;

	switch( cutp->cut_type ) {
	case CUT_BOXNODE:
		if( stp->st_npieces ) {
			int remove_count, new_count;
			struct rt_piecelist *new_piece_list;

			index = 0;
			remove_count = 0;
			for( index=0 ; index<cutp->bn.bn_piecelen ; index++ ) {
				if( cutp->bn.bn_piecelist[index].stp == stp ) {
					remove_count++;
				}
			}

			if( remove_count ) {
				new_count = cutp->bn.bn_piecelen - remove_count;
				if( new_count > 0 ) {
					new_piece_list = (struct rt_piecelist *)bu_calloc(
								    new_count,
								    sizeof( struct rt_piecelist ),
								    "bn_piecelist" );
				
					i = 0;
					for( index=0 ; index<cutp->bn.bn_piecelen ; index++ ) {
						if( cutp->bn.bn_piecelist[index].stp != stp ) {
							new_piece_list[i] = cutp->bn.bn_piecelist[index];
							i++;
						}
					}
				} else {
					new_count = 0;
					new_piece_list = NULL;
				}

				for( index=0 ; index<cutp->bn.bn_piecelen ; index++ ) {
					if( cutp->bn.bn_piecelist[index].stp == stp ) {
						bu_free( cutp->bn.bn_piecelist[index].pieces, "pieces" );
					}
				}
				bu_free( cutp->bn.bn_piecelist, "piecelist" );
				cutp->bn.bn_piecelist = new_piece_list;
				cutp->bn.bn_piecelen = new_count;
				cutp->bn.bn_maxpiecelen = new_count;
			}
		} else {
			for( index=0 ; index < cutp->bn.bn_len ; index++ ) {
				if( cutp->bn.bn_list[index] == stp ) {
					/* found it, now remove it */
					cutp->bn.bn_len--;
					for( i=index ; i < cutp->bn.bn_len ; i++ ) {
						cutp->bn.bn_list[i] = cutp->bn.bn_list[i+1];
					}
					return;
				}
			}
		}
		break;
	case CUT_CUTNODE:
		if( stp->st_min[cutp->cn.cn_axis] > cutp->cn.cn_point + tol->dist ) {
			remove_from_bsp( stp, cutp->cn.cn_r, tol );
		} else if( stp->st_max[cutp->cn.cn_axis] < cutp->cn.cn_point - tol->dist ) {
			remove_from_bsp( stp, cutp->cn.cn_l, tol );
		} else {
			remove_from_bsp( stp, cutp->cn.cn_r, tol );
			remove_from_bsp( stp, cutp->cn.cn_l, tol );
		}
		break;
	default:
		bu_log( "remove_from_bsp(): unrecognized cut type (%d) in BSP!!!\n" );
		bu_bomb( "remove_from_bsp(): unrecognized cut type in BSP!!!\n" );
	}
}

#define PIECE_BLOCK 512

void
insert_in_bsp( struct soltab *stp, union cutter *cutp )
{
	int i,j;

	switch( cutp->cut_type ) {
	case CUT_BOXNODE:
		if( stp->st_npieces == 0 ) {
			/* add the solid in this box */
			if( cutp->bn.bn_len >= cutp->bn.bn_maxlen ) {
				/* need more space */
				if( cutp->bn.bn_maxlen <= 0 )  {
					/* Initial allocation */
					cutp->bn.bn_maxlen = 5;
					cutp->bn.bn_list = (struct soltab **)bu_malloc(
						   cutp->bn.bn_maxlen * sizeof(struct soltab *),
							"insert_in_bsp: initial list alloc" );
				} else {
					cutp->bn.bn_maxlen += 5;
					cutp->bn.bn_list = (struct soltab **) bu_realloc(
								(genptr_t)cutp->bn.bn_list,
								sizeof(struct soltab *) * cutp->bn.bn_maxlen,
								"insert_in_bsp: list extend" );
				}
			}
			cutp->bn.bn_list[cutp->bn.bn_len++] = stp;

		} else {
			/* this solid uses pieces, add the appropriate pieces to this box */
			long pieces[PIECE_BLOCK];
			long *more_pieces=NULL;
			long more_pieces_alloced=0;
			long more_pieces_count=0;
			long piece_count=0;
			struct rt_piecelist *plp;

			for( i=0 ; i<stp->st_npieces ; i++ ) {
				struct bound_rpp *piece_rpp=&stp->st_piece_rpps[i];
				if( V3RPP_OVERLAP( piece_rpp->min, piece_rpp->max, cutp->bn.bn_min, cutp->bn.bn_max ) ) {
					if( piece_count < PIECE_BLOCK ) {
						pieces[piece_count++] = i;
					} else if( more_pieces_alloced == 0 ) {
						more_pieces_alloced = stp->st_npieces - PIECE_BLOCK;
						more_pieces = (long *)bu_malloc( sizeof( long ) * more_pieces_alloced,
										 "more_pieces" );
						more_pieces[more_pieces_count++] = i;
					} else {
						more_pieces[more_pieces_count++] = i;
					}
				}
			}

			if( cutp->bn.bn_piecelen >= cutp->bn.bn_maxpiecelen ) {
				cutp->bn.bn_piecelist = (struct rt_piecelist *)bu_realloc( cutp->bn.bn_piecelist,
								      sizeof( struct rt_piecelist ) * (++cutp->bn.bn_maxpiecelen),
								      "cutp->bn.bn_piecelist" );
			}

			if( !piece_count ) {
				return;
			}

			plp = &cutp->bn.bn_piecelist[cutp->bn.bn_piecelen++];
			plp->magic = RT_PIECELIST_MAGIC;
			plp->stp = stp;
			plp->npieces = piece_count + more_pieces_count;
			plp->pieces = (long *)bu_malloc( plp->npieces * sizeof( long ), "plp->pieces" );
			for( i=0 ; i<piece_count ; i++ ) {
				plp->pieces[i] = pieces[i];
			}
			j = piece_count;
			for( i=0 ; i<more_pieces_count ; i++ ) {
				plp->pieces[j++] = more_pieces[i];
			}

			if( more_pieces ) {
				bu_free( (char *)more_pieces, "more_pieces" );
			}
		}
		break;
	case CUT_CUTNODE:
		if( stp->st_min[cutp->cn.cn_axis] >= cutp->cn.cn_point ) {
			insert_in_bsp( stp, cutp->cn.cn_r );
		} else if( stp->st_max[cutp->cn.cn_axis] < cutp->cn.cn_point ) {
			insert_in_bsp( stp, cutp->cn.cn_l );
		} else {
			insert_in_bsp( stp, cutp->cn.cn_r );
			insert_in_bsp( stp, cutp->cn.cn_l );
		}
		break;
	default:
		bu_log( "insert_in_bsp(): unrecognized cut type (%d) in BSP!!!\n" );
		bu_bomb( "insert_in_bsp(): unrecognized cut type in BSP!!!\n" );
	}

}

void
fill_out_bsp( struct rt_i *rtip, union cutter *cutp, struct resource *resp, fastf_t bb[6] )
{
	fastf_t bb2[6];
	int i, j;

	switch( cutp->cut_type ) {
	case CUT_BOXNODE:
		j = 3;
		for( i=0 ; i<3 ; i++ ) {
			if( bb[i] >= INFINITY ) {
				/* this node is at the edge of the model BB, make it fill the BB */
				cutp->bn.bn_min[i] = rtip->mdl_min[i];
			}
			if( bb[j] <= -INFINITY ) {
				/* this node is at the edge of the model BB, make it fill the BB */
				cutp->bn.bn_max[i] = rtip->mdl_max[i];
			}
			j++;
		}
		break;
	case CUT_CUTNODE:
		VMOVE( bb2, bb );
		VMOVE( &bb2[3], &bb[3] );
		bb[cutp->cn.cn_axis] = cutp->cn.cn_point;
		fill_out_bsp( rtip, cutp->cn.cn_r, resp, bb );
		bb2[cutp->cn.cn_axis + 3] = cutp->cn.cn_point;
		fill_out_bsp( rtip, cutp->cn.cn_l, resp, bb2 );
		break;
	default:
		bu_log( "fill_out_bsp(): unrecognized cut type (%d) in BSP!!!\n" );
		bu_bomb( "fill_out_bsp(): unrecognized cut type in BSP!!!\n" );
	}

@


11.63
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.61 2002/01/10 18:12:40 butler Exp $ (BRL)";
d1090 2
d1141 1
d1176 59
@


11.62
log
@Converted from K&R to ANSI C - RFH
@
text
@d88 7
a94 1
rt_cut_one_axis(struct bu_ptbl *boxes, struct rt_i *rtip, int axis, int min, int max, struct nugridnode *nuginfop)
d154 3
a156 1
rt_cut_optimize_parallel(int cpu, genptr_t arg)
d193 2
a194 1
rt_projXmin_comp(const void *p1, const void *p2)
d200 2
a201 1
rt_projXmax_comp(const void *p1, const void *p2)
d207 2
a208 1
rt_projYmin_comp(const void *p1, const void *p2)
d214 2
a215 1
rt_projYmax_comp(const void *p1, const void *p2)
d221 2
a222 1
rt_projZmin_comp(const void *p1, const void *p2)
d228 2
a229 1
rt_projZmax_comp(const void *p1, const void *p2)
d251 5
a255 1
rt_nugrid_cut(register struct nugridnode *nugnp, register struct boxnode *fromp, struct rt_i *rtip, int just_collect_info, int depth)
d719 3
a721 1
rt_cut_it(register struct rt_i *rtip, int ncpu)
d875 4
a878 1
rt_cut_extend(register union cutter *cutp, struct soltab *stp, const struct rt_i *rtip)
d952 4
a955 1
rt_ct_plan(struct rt_i *rtip, union cutter *cutp, int depth)
d1014 5
a1018 1
rt_ct_assess(register union cutter *cutp, register int axis, double *where_p, double *offcenter_p)
d1101 4
a1104 1
rt_ct_populate_box(union cutter *outp, const union cutter *inp, struct rt_i *rtip)
d1197 5
a1201 1
rt_ct_box(struct rt_i *rtip, register union cutter *cutp, register int axis, double where)
d1274 5
a1278 1
rt_ck_overlap(register const fastf_t *min, register const fastf_t *max, register const struct soltab *stp, register const struct rt_i *rtip)
d1314 2
a1315 1
rt_ct_piececount(const union cutter *cutp)
d1342 4
a1345 1
rt_ct_optim(struct rt_i *rtip, register union cutter *cutp, int depth)
d1431 5
a1435 1
rt_ct_old_assess(register union cutter *cutp, register int axis, double *where_p, double *offcenter_p)
d1527 2
a1528 1
rt_ct_get(struct rt_i *rtip)
d1565 2
a1566 1
rt_ct_release_storage(register union cutter *cutp)
d1619 3
a1621 1
rt_ct_free(struct rt_i *rtip, register union cutter *cutp)
d1640 3
a1642 3
rt_pr_cut(register const union cutter *cutp, int lvl)
                                  
        			/* recursion level */
d1736 3
a1738 1
rt_fr_cut(struct rt_i *rtip, register union cutter *cutp)
d1789 5
a1793 1
rt_plot_cut(FILE *fp, struct rt_i *rtip, register union cutter *cutp, int lvl)
d1946 4
a1949 1
rt_ct_measure(register struct rt_i *rtip, register union cutter *cutp, int depth)
d1998 2
a1999 1
rt_cut_clean(struct rt_i *rtip)
@


11.61
log
@Changed word "solids" to indicate "prims" or primitives"
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.60 2001/12/18 15:44:35 jra Exp $ (BRL)";
d88 1
a88 7
rt_cut_one_axis( boxes, rtip, axis, min, max, nuginfop )
struct bu_ptbl	*boxes;
struct rt_i	*rtip;
int		axis;
int		min;
int		max;
struct nugridnode *nuginfop;
d148 1
a148 3
rt_cut_optimize_parallel( cpu, arg )
int		cpu;
genptr_t	arg;
d185 1
a185 2
rt_projXmin_comp( p1, p2 )
const void * p1, * p2;
d191 1
a191 2
rt_projXmax_comp( p1, p2 )
const void * p1, * p2;
d197 1
a197 2
rt_projYmin_comp( p1, p2 )
const void * p1, * p2;
d203 1
a203 2
rt_projYmax_comp( p1, p2 )
const void * p1, * p2;
d209 1
a209 2
rt_projZmin_comp( p1, p2 )
const void * p1, * p2;
d215 1
a215 2
rt_projZmax_comp( p1, p2 )
const void * p1, * p2;
d237 1
a237 5
rt_nugrid_cut( nugnp, fromp, rtip, just_collect_info, depth )
register struct nugridnode	*nugnp;
register struct boxnode		*fromp;
struct rt_i			*rtip;
int				 just_collect_info, depth;
d701 1
a701 3
rt_cut_it(rtip, ncpu)
register struct rt_i	*rtip;
int			ncpu;
d855 1
a855 4
rt_cut_extend( cutp, stp, rtip )
register union cutter	*cutp;
struct soltab		*stp;
const struct rt_i	*rtip;
d929 1
a929 4
rt_ct_plan( rtip, cutp, depth )
struct rt_i	*rtip;
union cutter	*cutp;
int		depth;
d988 1
a988 5
rt_ct_assess( cutp, axis, where_p, offcenter_p )
register union cutter *cutp;
register int	axis;
double		*where_p;
double		*offcenter_p;
d1071 1
a1071 4
rt_ct_populate_box( outp, inp, rtip )
union cutter		*outp;
const union cutter	*inp;
struct rt_i		*rtip;
d1164 1
a1164 5
rt_ct_box( rtip, cutp, axis, where )
struct rt_i		*rtip;
register union cutter	*cutp;
register int		axis;
double			where;
d1237 1
a1237 5
rt_ck_overlap( min, max, stp, rtip )
register const vect_t	min;
register const vect_t	max;
register const struct soltab *stp;
register const struct rt_i *rtip;
d1273 1
a1273 2
rt_ct_piececount( cutp )
const union cutter *cutp;
d1300 1
a1300 4
rt_ct_optim( rtip, cutp, depth )
struct rt_i		*rtip;
register union cutter *cutp;
int	depth;
d1386 1
a1386 5
rt_ct_old_assess( cutp, axis, where_p, offcenter_p )
register union cutter *cutp;
register int axis;
double	*where_p;
double	*offcenter_p;
d1478 1
a1478 2
rt_ct_get(rtip)
struct rt_i	*rtip;
d1515 1
a1515 2
rt_ct_release_storage( cutp )
register union cutter	*cutp;
d1568 1
a1568 3
rt_ct_free( rtip, cutp )
struct rt_i		*rtip;
register union cutter	*cutp;
d1587 3
a1589 3
rt_pr_cut( cutp, lvl )
register const union cutter *cutp;
int lvl;			/* recursion level */
d1683 1
a1683 3
rt_fr_cut( rtip, cutp )
struct rt_i		*rtip;
register union cutter *cutp;
d1734 1
a1734 5
rt_plot_cut( fp, rtip, cutp, lvl )
FILE			*fp;
struct rt_i		*rtip;
register union cutter	*cutp;
int			lvl;
d1887 1
a1887 4
rt_ct_measure( rtip, cutp, depth )
register struct rt_i	*rtip;
register union cutter	*cutp;
int			depth;
d1936 1
a1936 2
rt_cut_clean(rtip)
struct rt_i	*rtip;
@


11.60
log
@rt_ct_release_storage() was missing some memory to be freed.
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.59 2001/05/17 20:05:23 morrison Exp $ (BRL)";
d1673 1
a1673 1
		bu_log("BOX Contains %d solids (%d alloc), %d solids with pieces:\n",
d2047 1
a2047 1
		    "cut_tree: Number of solids per leaf cell");
d2049 1
a2049 1
		    "cut_tree: Number of solid pieces per leaf cell");
@


11.59
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.58 2001/04/05 19:35:33 morrison Exp $ (BRL)";
d1584 6
@


11.58
log
@updated SIGNED to signed
updated CONST to const
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.57 2000/08/21 02:02:28 butler Exp $ (BRL)";
d348 1
a348 1
	if( rt_g.debug&DEBUG_CUT )
d551 1
a551 1
	if( rt_g.debug&DEBUG_CUT ) for( i=0; i<3; i++ ) {
d762 1
a762 1
	if( rt_g.debug&DEBUG_CUT )
d815 1
a815 1
			if(rt_g.debug&DEBUG_CUTDETAIL)  {
d845 1
a845 1
	if( rt_g.debug&DEBUG_CUT )  {
d849 1
a849 1
	if( rt_g.debug&DEBUG_CUTDETAIL ) {
d854 1
a854 1
	if( rt_g.debug&DEBUG_PLOTBOX ) {
d885 1
a885 1
	if(rt_g.debug&DEBUG_CUTDETAIL)  {
d1207 1
a1207 1
	if(rt_g.debug&DEBUG_CUTDETAIL)  {
d1239 1
a1239 1
		if(rt_g.debug&DEBUG_CUTDETAIL)  {
d1281 1
a1281 1
	if( rt_g.debug&DEBUG_BOXING )  {
d1301 1
a1301 1
	if( rt_g.debug&DEBUG_BOXING )  bu_log("rt_ck_overlap:  TRUE\n");
d1304 1
a1304 1
	if( rt_g.debug&DEBUG_BOXING )  bu_log("rt_ck_overlap:  FALSE\n");
d1360 1
a1360 1
	if( rt_g.debug&DEBUG_CUTDETAIL )  bu_log("rt_ct_optim( cutp=x%x, depth=%d ) piececount=%d\n", cutp, depth, oldlen);
d1407 1
a1407 1
/* 		if( rt_g.debug&DEBUG_CUTDETAIL ) */
d1445 1
a1445 1
	if(rt_g.debug&DEBUG_CUTDETAIL)bu_log("rt_ct_old_assess(x%x, %c)\n",cutp,"XYZ345"[axis]);
d1506 1
a1506 1
	if(rt_g.debug&DEBUG_CUTDETAIL)bu_log("rt_ct_old_assess() left=%g, where=%g, right=%g, offcenter=%g\n",
@


11.57
log
@Massive compilation warnings eliminated
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.56 2000/07/13 02:36:25 cjohnson Exp $ (BRL)";
d48 4
a51 4
HIDDEN int		rt_ck_overlap BU_ARGS((CONST vect_t min,
					       CONST vect_t max,
					       CONST struct soltab *stp,
					       CONST struct rt_i *rtip));
d67 2
a68 2
BU_EXTERN(void		rt_pr_cut_info, (CONST struct rt_i *rtip,
					CONST char *str));
d179 4
a182 4
	(*(CONST struct soltab **)(_p1))->_memb[_ind] < \
	(*(CONST struct soltab **)(_p2))->_memb[_ind] ? -1 : \
	(*(CONST struct soltab **)(_p1))->_memb[_ind] > \
	(*(CONST struct soltab **)(_p2))->_memb[_ind] ? 1 : 0
d185 6
a190 6
HIDDEN int rt_projXmin_comp BU_ARGS((CONST void * p1, CONST void * p2));
HIDDEN int rt_projXmax_comp BU_ARGS((CONST void * p1, CONST void * p2));
HIDDEN int rt_projYmin_comp BU_ARGS((CONST void * p1, CONST void * p2));
HIDDEN int rt_projYmax_comp BU_ARGS((CONST void * p1, CONST void * p2));
HIDDEN int rt_projZmin_comp BU_ARGS((CONST void * p1, CONST void * p2));
HIDDEN int rt_projZmax_comp BU_ARGS((CONST void * p1, CONST void * p2));
d194 1
a194 1
CONST void * p1, * p2;
d201 1
a201 1
CONST void * p1, * p2;
d208 1
a208 1
CONST void * p1, * p2;
d215 1
a215 1
CONST void * p1, * p2;
d222 1
a222 1
CONST void * p1, * p2;
d229 1
a229 1
CONST void * p1, * p2;
d235 2
a236 2
	HIDDEN int (*cmp_min) BU_ARGS((CONST void *, CONST void *));
	HIDDEN int (*cmp_max) BU_ARGS((CONST void *, CONST void *));
d878 1
a878 1
CONST struct rt_i	*rtip;
d1103 1
a1103 1
CONST union cutter	*inp;
d1108 1
a1108 1
	CONST struct bn_tol *tol = &rtip->rti_tol;
d1275 4
a1278 4
register CONST vect_t	min;
register CONST vect_t	max;
register CONST struct soltab *stp;
register CONST struct rt_i *rtip;
d1315 1
a1315 1
CONST union cutter *cutp;
d1635 1
a1635 1
register CONST union cutter *cutp;
d2021 1
a2021 1
	CONST struct nugridnode	*nugnp;
@


11.56
log
@LINT from gcc -Wall
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.55 2000/07/10 23:01:26 mike Exp $ (BRL)";
d2019 1
a2019 3
rt_pr_cut_info( rtip, str )
CONST struct rt_i	*rtip;
CONST char		*str;
@


11.55
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d29 1
a29 1
static const char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.54 2000/05/19 05:05:20 mike Exp $ (BRL)";
d36 5
d45 1
d69 4
a72 1

@


11.54
log
@
Changed to tolerance-based RPP overlap checking.
@
text
@d29 1
a29 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.53 2000/05/19 04:58:14 mike Exp $ (BRL)";
@


11.53
log
@
Restructured to remove a level of indenting.
@
text
@d29 1
a29 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.52 2000/05/19 04:40:15 mike Exp $ (BRL)";
d1099 1
d1147 3
a1149 2
			if( V3RPP_DISJOINT(outp->bn.bn_min, outp->bn.bn_max,
			    rpp->min, rpp->max) )
@


11.52
log
@
Clarified code by creating rt_ct_populate_box().
@
text
@d29 1
a29 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.51 2000/05/17 04:09:48 mike Exp $ (BRL)";
d1121 19
a1139 15
	if( inp->bn.bn_piecelen > 0 )  {
		outp->bn.bn_piecelist = (struct rt_piecelist *) bu_malloc(
			sizeof(struct rt_piecelist) * inp->bn.bn_piecelen,
			"rt_piecelist" );
		for( i = inp->bn.bn_piecelen-1; i >= 0; i-- )  {
			struct rt_piecelist *plp = &inp->bn.bn_piecelist[i];	/* input */
			struct soltab *stp = plp->stp;
			struct rt_piecelist *olp = &outp->bn.bn_piecelist[outp->bn.bn_piecelen]; /* output */
			int j;

			RT_CK_PIECELIST(plp);
			RT_CK_SOLTAB(stp);
			olp->pieces = (long *)bu_malloc(
				sizeof(long) * plp->npieces,
				"olp->pieces[] (left)" );
d1142 18
a1159 18
			/* Loop for every piece of this solid */
			for( j = plp->npieces-1; j >= 0; j-- )  {
				long indx = plp->pieces[j];
				struct bound_rpp *rpp = &stp->st_piece_rpps[indx];
				if( V3RPP_DISJOINT(outp->bn.bn_min, outp->bn.bn_max,
				    rpp->min, rpp->max) )
					continue;
				olp->pieces[olp->npieces++] = indx;
			}
			if( olp->npieces > 0 )  {
				olp->magic = RT_PIECELIST_MAGIC;
				olp->stp = stp;
				outp->bn.bn_piecelen++;
				if( olp->npieces < plp->npieces ) success = 1;
			} else {
				bu_free( (char *)olp->pieces, "olp->pieces (left)");
				olp->pieces = NULL;
			}
a1160 2
	} else {
		outp->bn.bn_piecelist = (struct rt_piecelist *)NULL;
@


11.51
log
@
Eliminated small bugs relating to cells with 0 solids and non-zero
solid pieces.
Added extra histogram.
Consolodated debugging.
Added comments.
@
text
@d12 2
a13 1
 *				rt_ck_overlap()
d29 1
a29 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.50 2000/05/12 19:16:40 mike Exp $ (BRL)";
d1082 83
a1190 1
	register int	i;
d1209 1
a1209 57
	lhs->bn.bn_len = 0;
	lhs->bn.bn_maxlen = cutp->bn.bn_len;
	if( lhs->bn.bn_maxlen > 0 )  {
		lhs->bn.bn_list = (struct soltab **) bu_malloc(
			sizeof(struct soltab *) * lhs->bn.bn_maxlen,
			"rt_ct_box (left list)" );
		for( i = cutp->bn.bn_len-1; i >= 0; i-- )  {
			if( !rt_ck_overlap(lhs->bn.bn_min, lhs->bn.bn_max,
			    cutp->bn.bn_list[i], rtip))
				continue;
			lhs->bn.bn_list[lhs->bn.bn_len++] = cutp->bn.bn_list[i];
		}
		if( lhs->bn.bn_len < cutp->bn.bn_len )  success = 1;
	} else {
		lhs->bn.bn_list = (struct soltab **)NULL;
	}

	lhs->bn.bn_piecelen = 0;
	if( cutp->bn.bn_piecelen > 0 )  {
		lhs->bn.bn_piecelist = (struct rt_piecelist *) bu_malloc(
			sizeof(struct rt_piecelist) * cutp->bn.bn_piecelen,
			"rt_ct_box (left piece list)" );
		for( i = cutp->bn.bn_piecelen-1; i >= 0; i-- )  {
			struct rt_piecelist *plp = &cutp->bn.bn_piecelist[i];	/* input */
			struct soltab *stp = plp->stp;
			struct rt_piecelist *olp = &lhs->bn.bn_piecelist[lhs->bn.bn_piecelen]; /* output */
			int j;

			RT_CK_PIECELIST(plp);
			RT_CK_SOLTAB(stp);
			olp->pieces = (long *)bu_malloc(
				sizeof(long) * plp->npieces,
				"olp->pieces[] (left)" );
			olp->npieces = 0;

			/* Loop for every piece of this solid */
			for( j = plp->npieces-1; j >= 0; j-- )  {
				long indx = plp->pieces[j];
				struct bound_rpp *rpp = &stp->st_piece_rpps[indx];
				if( V3RPP_DISJOINT(lhs->bn.bn_min, lhs->bn.bn_max,
				    rpp->min, rpp->max) )
					continue;
				olp->pieces[olp->npieces++] = indx;
			}
			if( olp->npieces > 0 )  {
				olp->magic = RT_PIECELIST_MAGIC;
				olp->stp = stp;
				lhs->bn.bn_piecelen++;
				if( olp->npieces < plp->npieces ) success = 1;
			} else {
				bu_free( (char *)olp->pieces, "olp->pieces (left)");
				olp->pieces = NULL;
			}
		}
	} else {
		lhs->bn.bn_piecelist = (struct rt_piecelist *)NULL;
	}
d1218 1
a1218 57
	rhs->bn.bn_len = 0;
	rhs->bn.bn_maxlen = cutp->bn.bn_len;
	if( rhs->bn.bn_maxlen > 0 ) {
		rhs->bn.bn_list = (struct soltab **) bu_malloc(
			sizeof(struct soltab *) * rhs->bn.bn_maxlen,
			"rt_ct_box (right list)" );
		for( i = cutp->bn.bn_len-1; i >= 0; i-- )  {
			if( !rt_ck_overlap(rhs->bn.bn_min, rhs->bn.bn_max,
			    cutp->bn.bn_list[i], rtip))
				continue;
			rhs->bn.bn_list[rhs->bn.bn_len++] = cutp->bn.bn_list[i];
		}
		if( rhs->bn.bn_len < cutp->bn.bn_len )  success = 1;
	} else {
		rhs->bn.bn_list = (struct soltab **)NULL;
	}

	rhs->bn.bn_piecelen = 0;
	if( cutp->bn.bn_piecelen > 0 )  {
		rhs->bn.bn_piecelist = (struct rt_piecelist *) bu_malloc(
			sizeof(struct rt_piecelist) * cutp->bn.bn_piecelen,
			"rt_ct_box (left piece list)" );
		for( i = cutp->bn.bn_piecelen-1; i >= 0; i-- )  {
			struct rt_piecelist *plp = &cutp->bn.bn_piecelist[i];	/* input */
			struct soltab *stp = plp->stp;
			struct rt_piecelist *olp = &rhs->bn.bn_piecelist[rhs->bn.bn_piecelen];	/* output */
			int j;

			RT_CK_PIECELIST(plp);
			RT_CK_SOLTAB(stp);
			olp->pieces = (long *)bu_malloc(
				sizeof(long) * plp->npieces,
				"olp->pieces[] (right)" );
			olp->npieces = 0;

			/* Loop for every piece of this solid */
			for( j = plp->npieces-1; j >= 0; j-- )  {
				long indx = plp->pieces[j];
				struct bound_rpp *rpp = &stp->st_piece_rpps[indx];
				if( V3RPP_DISJOINT(rhs->bn.bn_min, rhs->bn.bn_max,
				    rpp->min, rpp->max) )
					continue;
				olp->pieces[olp->npieces++] = indx;
			}
			if( olp->npieces > 0 )  {
				olp->magic = RT_PIECELIST_MAGIC;
				olp->stp = stp;
				rhs->bn.bn_piecelen++;
				if( olp->npieces < plp->npieces ) success = 1;
			} else {
				bu_free( (char *)olp->pieces, "olp->pieces (right)");
				olp->pieces = NULL;
			}
		}
	} else {
		rhs->bn.bn_piecelist = (struct rt_piecelist *)NULL;
	}
@


11.50
log
@
Forgot to init var to 0
@
text
@d6 8
a13 2
 *  Before this can be done, the model max and min must have
 *  been computed -- no incremental cutting.
d28 1
a28 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.49 2000/05/12 19:10:38 mike Exp $ (BRL)";
d60 4
d830 1
d835 2
a836 15
	if( rt_g.debug&DEBUG_CUT ) {
		bu_log( "Cut: maxdepth=%d, nbins=%d, maxlen=%d, avg=%g\n",
			rtip->rti_cut_maxdepth,
			rtip->rti_ncut_by_type[CUT_BOXNODE],
			rtip->rti_cut_maxlen,
			((double)rtip->rti_cut_totobj) /
			rtip->rti_ncut_by_type[CUT_BOXNODE] );
		bu_hist_pr( &rtip->rti_hist_cellsize,
			    "cut_tree: Number of solids per leaf cell");
		bu_hist_pr( &rtip->rti_hist_cutdepth,
			    "cut_tree: Depth (height)");
		bu_log( "Counts: %d nugrid nodes, %d cutnodes, %d boxnodes\n",
			rtip->rti_ncut_by_type[CUT_NUGRIDNODE],
			rtip->rti_ncut_by_type[CUT_CUTNODE],
			rtip->rti_ncut_by_type[CUT_BOXNODE] );
d1138 1
d1149 1
a1149 1
			struct rt_piecelist *plp = &cutp->bn.bn_piecelist[i];
d1151 1
a1151 1
			struct rt_piecelist *olp = &lhs->bn.bn_piecelist[lhs->bn.bn_piecelen];
d1203 1
d1214 1
a1214 1
			struct rt_piecelist *plp = &cutp->bn.bn_piecelist[i];
d1216 1
a1216 1
			struct rt_piecelist *olp = &rhs->bn.bn_piecelist[rhs->bn.bn_piecelen];
d1250 1
a1250 6
	if( rhs->bn.bn_len == cutp->bn.bn_len &&
	    lhs->bn.bn_len == cutp->bn.bn_len &&
	    rhs->bn.bn_piecelen == cutp->bn.bn_piecelen &&
	    lhs->bn.bn_piecelen == cutp->bn.bn_piecelen &&
	    success == 0
	)  {
d1256 3
a1258 2
			bu_log("rt_ct_box:  no luck, len=%d\n",
				cutp->bn.bn_len );
d1340 2
d1363 1
d1375 2
a1376 1
	if( rt_g.debug&DEBUG_CUTDETAIL )  bu_log("rt_ct_optim( cutp=x%x, depth=%d ) piececount=%d\n", cutp, depth, rt_ct_piececount(cutp));
d1381 1
a1381 1
	if( cutp->bn.bn_len <= 1 && cutp->bn.bn_piecelen <= 0 )
d1387 1
a1387 1
	if( depth >= 6 && cutp->bn.bn_len <= rtip->rti_cutlen )
a1401 1
 	int oldlen;
a1412 1
	oldlen = rt_ct_piececount(cutp);	/* save before rt_ct_box() */
d1422 8
a1429 1
	    rt_ct_piececount(cutp->cn.cn_r) >= oldlen )  return; /* hopeless */
d1500 1
d1988 2
d2060 2
@


11.49
log
@
Moved bounding plot-box code from cut.c to prep.c
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.48 2000/05/11 21:01:58 mike Exp $ (BRL)";
d1160 1
d1224 1
@


11.48
log
@
Added rt_ct_piececount().
Pieces are fully propagated into the space partitioning tree now.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.47 2000/05/11 03:33:24 mike Exp $ (BRL)";
a705 21
	
	/* For plotting, compute a slight enlargement of the model RPP,
	 * to allow room for rays clipped to the model RPP to be depicted.
	 * Always do this, because application debugging may use it too.
	 */
	{
		register fastf_t f, diff;

		diff = (rtip->mdl_max[X] - rtip->mdl_min[X]);
		f = (rtip->mdl_max[Y] - rtip->mdl_min[Y]);
		if( f > diff )  diff = f;
		f = (rtip->mdl_max[Z] - rtip->mdl_min[Z]);
		if( f > diff )  diff = f;
		diff *= 0.1;	/* 10% expansion of box */
		rtip->rti_pmin[0] = rtip->mdl_min[0] - diff;
		rtip->rti_pmin[1] = rtip->mdl_min[1] - diff;
		rtip->rti_pmin[2] = rtip->mdl_min[2] - diff;
		rtip->rti_pmax[0] = rtip->mdl_max[0] + diff;
		rtip->rti_pmax[1] = rtip->mdl_max[1] + diff;
		rtip->rti_pmax[2] = rtip->mdl_max[2] + diff;
	}
@


11.47
log
@
Fixed assertion failure.
Marked spot to fix tomorrow.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.46 2000/05/11 03:20:28 mike Exp $ (BRL)";
d1348 22
d1395 1
a1395 1
	if( rt_g.debug&DEBUG_CUTDETAIL )  bu_log("rt_ct_optim( cutp=x%x, depth=%d ) len=%d, piecelen=%d\n", cutp, depth, cutp->bn.bn_len, cutp->bn.bn_piecelen);
d1433 1
a1433 1
	oldlen = cutp->bn.bn_len;	/* save before rt_ct_box() */
d1442 2
a1443 3
/* XXX This isn't sufficient with solid pieces */
	if( cutp->cn.cn_l->bn.bn_len >= oldlen &&
	    cutp->cn.cn_r->bn.bn_len >= oldlen )  return;	/* hopeless */
@


11.46
log
@
Pieces code starting to take shape.
Broke out rt_ct_releas_storage() as separate routine.
Moved rt_isect_lseg_rpp() into libbn/plane.c as bn_isect_lseg_rpp()
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.45 2000/05/10 19:29:10 mike Exp $ (BRL)";
d738 3
d1420 1
@


11.45
log
@
Optimized rt_cut_extend,
Eliminated an unused function.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.44 2000/05/10 19:20:33 mike Exp $ (BRL)";
d35 1
a35 1
HIDDEN int		rt_ck_overlap RT_ARGS((CONST vect_t min,
d39 1
a39 1
HIDDEN int		rt_ct_box RT_ARGS((struct rt_i *rtip,
d42 1
a42 1
HIDDEN void		rt_ct_optim RT_ARGS((struct rt_i *rtip,
d44 1
a44 1
HIDDEN void		rt_ct_free RT_ARGS((struct rt_i *rtip,
d46 3
a48 1
HIDDEN void		rt_ct_measure RT_ARGS((struct rt_i *rtip,
d50 2
a51 2
HIDDEN union cutter	*rt_ct_get RT_ARGS((struct rt_i *rtip));
HIDDEN void		rt_plot_cut RT_ARGS((FILE *fp, struct rt_i *rtip,
d695 2
d751 4
a754 4
	/*  Dynamic decisions on tree limits.  Note that there * will be
	    (2**rtip->rti_cutdepth)*rtip->rti_cutlen leaf slots, but * solids will typically
	    span several leaves.  */
		
d878 1
a878 1
 *  Add a solid into a given boxnode, extending the list there.
d882 1
a882 1
 *  The solid is put onto the main list whether or not it has pieces.
d893 35
d1111 3
a1113 2
 *  XXX should really check & store all the overlaps, & calculate
 *  minimum necessary sizes for each side.
d1128 1
d1145 1
d1148 52
a1199 8
	lhs->bn.bn_list = (struct soltab **) bu_malloc(
		sizeof(struct soltab *) * lhs->bn.bn_maxlen,
		"rt_ct_box (left list)" );
	for( i = cutp->bn.bn_len-1; i >= 0; i-- )  {
		if( !rt_ck_overlap(lhs->bn.bn_min, lhs->bn.bn_max,
		    cutp->bn.bn_list[i], rtip))
			continue;
		lhs->bn.bn_list[lhs->bn.bn_len++] = cutp->bn.bn_list[i];
d1208 1
d1211 12
a1222 8
	rhs->bn.bn_list = (struct soltab **) bu_malloc(
		sizeof(struct soltab *) * rhs->bn.bn_maxlen,
		"rt_ct_box (right list)" );
	for( i = cutp->bn.bn_len-1; i >= 0; i-- )  {
		if( !rt_ck_overlap(rhs->bn.bn_min, rhs->bn.bn_max,
		    cutp->bn.bn_list[i], rtip))
			continue;
		rhs->bn.bn_list[rhs->bn.bn_len++] = cutp->bn.bn_list[i];
d1225 47
a1271 1
	if( rhs->bn.bn_len == cutp->bn.bn_len && lhs->bn.bn_len == cutp->bn.bn_len )  {
a1279 2
		bu_free( (char *)rhs->bn.bn_list, "rt_ct_box, rhs list");
		bu_free( (char *)lhs->bn.bn_list, "rt_ct_box, lhs list");
d1286 1
a1286 2
	bu_free( (char *)cutp->bn.bn_list, "rt_ct_box (old list)" );
	cutp->bn.bn_list = (struct soltab **)0;
d1370 2
d1375 2
a1376 1
	if( cutp->bn.bn_len <= 1 )  return;		/* optimal */
d1427 2
d1465 1
a1465 1
	offcenter = middle - where;
d1482 31
d1564 48
d1622 4
d1671 3
a1673 2
		bu_log("BOX Contains %d solids (%d alloc):\n",
			cutp->bn.bn_len, cutp->bn.bn_maxlen );
d1683 1
d1691 24
d1729 1
a1729 1
 *  Free a whole cut tree.
d1757 1
a1757 2
		if( cutp->bn.bn_maxlen > 0 )
			bu_free( (genptr_t)cutp->bn.bn_list, "cut_box list");
d1761 2
a1762 1
		register int i, len = cutp->nugn.nu_cells_per_axis[X] *
d1765 3
a1767 2
		register union cutter *bp;
		for( i=0, bp=cutp->nugn.nu_grid; i<len; i++, bp++ )
d1769 2
a1770 6
		bu_free( (genptr_t)cutp->nugn.nu_grid, "NUGrid children" );
		cutp->nugn.nu_grid = 0; /* sanity */
		for( i=0; i<3; i++ ) {
			bu_free( (genptr_t)cutp->nugn.nu_axis[i],
				 "NUGrid axis" );
			cutp->nugn.nu_axis[i] = 0; /* sanity */
d1772 2
a1937 79
 *			R T _ I S E C T _ L S E G _ R P P
 *
 *  Intersect a line segment with a rectangular parallelpiped (RPP)
 *  that has faces parallel to the coordinate planes (a clipping RPP).
 *  The RPP is defined by a minimum point and a maximum point.
 *  This is a very close relative to rt_in_rpp() from librt/shoot.c
 *
 *  Returns -
 *	 0  if ray does not hit RPP,
 *	!0  if ray hits RPP.
 *
 *  Implicit Return -
 *	if !0 was returned, "a" and "b" have been clipped to the RPP.
 */
int
rt_isect_lseg_rpp( a, b, min, max )
point_t		a;
point_t		b;
register fastf_t *min, *max;
{
	auto vect_t	diff;
	register fastf_t *pt = &a[0];
	register fastf_t *dir = &diff[0];
	register int i;
	register double sv;
	register double st;
	register double mindist, maxdist;

	mindist = -INFINITY;
	maxdist = INFINITY;
	VSUB2( diff, b, a );

	for( i=0; i < 3; i++, pt++, dir++, max++, min++ )  {
		if( *dir < -SQRT_SMALL_FASTF )  {
			if( (sv = (*min - *pt) / *dir) < 0.0 )
				return(0);	/* MISS */
			if(maxdist > sv)
				maxdist = sv;
			if( mindist < (st = (*max - *pt) / *dir) )
				mindist = st;
		}  else if( *dir > SQRT_SMALL_FASTF )  {
			if( (st = (*max - *pt) / *dir) < 0.0 )
				return(0);	/* MISS */
			if(maxdist > st)
				maxdist = st;
			if( mindist < ((sv = (*min - *pt) / *dir)) )
				mindist = sv;
		}  else  {
			/*
			 *  If direction component along this axis is NEAR 0,
			 *  (ie, this ray is aligned with this axis),
			 *  merely check against the boundaries.
			 */
			if( (*min > *pt) || (*max < *pt) )
				return(0);	/* MISS */;
		}
	}
	if( mindist >= maxdist )
		return(0);	/* MISS */

	if( mindist > 1 || maxdist < 0 )
		return(0);	/* MISS */

	if( mindist >= 0 && maxdist <= 1 )
		return(1);	/* HIT within box, no clipping needed */

	/* Don't grow one end of a contained segment */
	if( mindist < 0 )
		mindist = 0;
	if( maxdist > 1 )
		maxdist = 1;

	/* Compute actual intercept points */
	VJOIN1( b, a, maxdist, diff );		/* b must go first */
	VJOIN1( a, a, mindist, diff );
	return(1);		/* HIT */
}

/*
d2018 1
@


11.44
log
@
Oops, had to put back rti_inf_box.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.43 2000/05/10 02:52:26 mike Exp $ (BRL)";
a41 4
HIDDEN void		rt_ct_add RT_ARGS((union cutter *cutp,
					   struct soltab *stp,
					   vect_t min, vect_t max, int depth,
					   CONST struct rt_i *rtip));
a870 48
		


/*
 *			R T _ C T _ A D D
 *  
 *  Add a solid to the cut tree, extending the tree as necessary,
 *  but without being paranoid about obeying the rtip->rti_cutlen limits,
 *  so as to retain O(depth) performance.
 */
HIDDEN void
rt_ct_add( cutp, stp, min, max, depth, rtip )
register union cutter *cutp;
struct soltab *stp;	/* should be object handle & routine addr */
vect_t min, max;
int depth;
CONST struct rt_i *rtip;
{
	if(rt_g.debug&DEBUG_CUTDETAIL)bu_log("rt_ct_add(x%x, %s, %d)\n",
		cutp, stp->st_name, depth);
	if( cutp->cut_type == CUT_CUTNODE )  {
		vect_t temp;

		/* Cut to the left of point */
		VMOVE( temp, max );
		temp[cutp->cn.cn_axis] = cutp->cn.cn_point;
		if( rt_ck_overlap( min, temp, stp, rtip ) )
			rt_ct_add( cutp->cn.cn_l, stp, min, temp, depth+1,
				   rtip );

		/* Cut to the right of point */
		VMOVE( temp, min );
		temp[cutp->cn.cn_axis] = cutp->cn.cn_point;
		if( rt_ck_overlap( temp, max, stp, rtip ) )
			rt_ct_add( cutp->cn.cn_r, stp, temp, max, depth+1,
				   rtip );
		return;
	}
	if( cutp->cut_type != CUT_BOXNODE )  {
		bu_log("rt_ct_add:  node type =x%x\n",cutp->cut_type);
		return;
	}
	/* BOX NODE */

	/* Just add to list at this box node */
	rt_cut_extend( cutp, stp, rtip );
}

d875 2
d878 1
a878 1
 *  The solid it put onto the main list whether or not it has pieces.
d886 1
d893 1
a893 1
			if( rtip->rti_cutlen > 6 )
d896 1
a896 1
				cutp->bn.bn_maxlen = 6;
d901 4
a904 4
			register char *newlist;

			newlist = bu_malloc(
				sizeof(struct soltab *) * cutp->bn.bn_maxlen * 2,
a905 6
			bcopy( cutp->bn.bn_list, newlist,
				cutp->bn.bn_maxlen * sizeof(struct soltab *));
			cutp->bn.bn_maxlen *= 2;
			bu_free( (char *)cutp->bn.bn_list,
				"rt_cut_extend: list extend (old list)");
			cutp->bn.bn_list = (struct soltab **)newlist;
@


11.43
log
@
Fixed another comment.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.42 2000/05/10 02:30:27 mike Exp $ (BRL)";
d744 5
@


11.42
log
@
Added comments.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.41 2000/05/10 01:46:11 mike Exp $ (BRL)";
d728 1
a728 3
	/* Copy solids into a list for rt_nugrid_cut, and throw infinite
	   solids into a special box. */

@


11.41
log
@
Eliminated the special space-partitioning box for infinite solids.
Eliminated rti_inf_box
Thanks to Glenn's having implemented the per-solid classification method.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.40 2000/05/10 01:02:25 mike Exp $ (BRL)";
d922 4
@


11.40
log
@
Tidy up code for infinite solids.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.39 2000/05/10 00:46:15 mike Exp $ (BRL)";
d743 3
a745 6
		if( stp->st_aradius >= INFINITY )  {
			/* Add to infinite solids list for special handling */
			rt_cut_extend( &rtip->rti_inf_box, stp, rtip );
		} else {
			rt_cut_extend( finp, stp, rtip );
		}
a838 1
	rt_ct_measure( rtip, &rtip->rti_inf_box, 0 );
@


11.39
log
@
Improved comments.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.38 2000/04/15 02:04:14 mike Exp $ (BRL)";
d1237 4
a1240 4
		VPRINT("box min", min);
		VPRINT("sol min", stp->st_min);
		VPRINT("box max", max);
		VPRINT("sol max", stp->st_max);
d1244 4
a1247 3
	if( stp->st_aradius >= INFINITY )  {
		if( rt_functab[stp->st_id].ft_classify( stp, min, max,
				&rtip->rti_tol ) == RT_CLASSIFY_OUTSIDE )
a1248 2
		if( rt_g.debug&DEBUG_BOXING )  bu_log("rt_ck_overlap:  TRUE (inf)\n");
		return(1);
a1249 3
	if( stp->st_min[X] >= max[X]  || stp->st_max[X] <= min[X] )  goto fail;
	if( stp->st_min[Y] >= max[Y]  || stp->st_max[Y] <= min[Y] )  goto fail;
	if( stp->st_min[Z] >= max[Z]  || stp->st_max[Z] <= min[Z] )  goto fail;
d1251 1
@


11.38
log
@
Silenced lint.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.37 2000/04/12 02:04:25 mike Exp $ (BRL)";
d1217 5
a1221 3
 *  See if any part of the object is contained within the box (RPP).
 *  There should be a routine per solid type to further refine
 *  this if the bounding boxes overlap.  Also need hooks for polygons.
@


11.37
log
@
NT port
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.36 2000/02/10 05:06:41 mike Exp $ (BRL)";
d166 8
d176 1
a176 1
CONST genptr_t p1, p2;
d183 1
a183 1
CONST genptr_t p1, p2;
d190 1
a190 1
CONST genptr_t p1, p2;
d197 1
a197 1
CONST genptr_t p1, p2;
d204 1
a204 1
CONST genptr_t p1, p2;
d211 1
a211 1
CONST genptr_t p1, p2;
d217 2
a218 2
	int (*cmp_min) BU_ARGS((CONST void *, CONST void *));
	int (*cmp_max) BU_ARGS((CONST void *, CONST void *));
@


11.36
log
@
Move rt_cutLen into rti_cutlen
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.35 2000/02/10 05:02:18 mike Exp $ (BRL)";
d209 2
a210 2
	int (*cmp_min)();
	int (*cmp_max)();
@


11.35
log
@
Added rt_pr_cut_info()
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.34 1999/12/22 02:01:50 mike Exp $ (BRL)";
a34 3
int rt_cutLen;			/* normal limit on number objs per box node */
int rt_cutDepth;		/* normal limit on depth of cut tree */

d737 1
a737 1
			rt_cut_extend( &rtip->rti_inf_box, stp );
d739 1
a739 1
			rt_cut_extend( finp, stp );
d744 1
a744 1
	    (2**rt_cutDepth)*rt_cutLen leaf slots, but * solids will typically
d747 5
a751 5
	rt_cutLen = (int)log((double)rtip->nsolids);  /* ln ~= log2 */
	rt_cutDepth = 2 * rt_cutLen;
	if( rt_cutLen < 3 )  rt_cutLen = 3;
	if( rt_cutDepth < 9 )  rt_cutDepth = 9;
	if( rt_cutDepth > 24 )  rt_cutDepth = 24;     /* !! */
d754 1
a754 1
			rt_cutDepth, rt_cutLen );
d761 1
a761 1
		rt_cutDepth = 6;
d831 1
a831 1
		      (fastf_t)rt_cutDepth+1, rt_cutDepth+1 );
d875 1
a875 1
 *  but without being paranoid about obeying the rt_cutLen limits,
d913 1
a913 1
	rt_cut_extend( cutp, stp );
d920 4
a923 3
rt_cut_extend( cutp, stp )
register union cutter *cutp;
struct soltab *stp;
d925 2
d931 2
a932 2
			if( rt_cutLen > 6 )
				cutp->bn.bn_maxlen = rt_cutLen;
d1285 1
a1285 1
	if( depth > rt_cutDepth )  return;		/* too deep */
d1287 1
a1287 1
	/* Attempt to subdivide finer than rt_cutLen near treetop */
d1289 1
a1289 1
	if( depth >= 6 && cutp->bn.bn_len <= rt_cutLen )
@


11.34
log
@
Removed unused vars
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.33 1999/05/27 18:53:48 mike Exp $ (BRL)";
d1892 57
@


11.33
log
@
sed4
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /c/CVS/brlcad/librt/cut.c,v 11.32 1998/04/15 04:54:36 mike Exp $ (BRL)";
a83 1
	int	ret;
d245 2
a246 1
	register int	i, j, xp, yp, zp;
@


11.32
log
@Take advantage of bu_parallel()'s ability to pass a user arg now.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.31 1998/03/19 11:50:51 mike Exp mike $ (BRL)";
d93 1
a93 1
		box = (union cutter *)rt_calloc( 1, sizeof(union cutter),
d122 1
a122 1
	box = (union cutter *)rt_calloc( 1, sizeof(union cutter),
d806 1
a806 1
			rt_free( (char *)head, "union cutter" );
d947 1
a947 1
			rt_free( (char *)cutp->bn.bn_list,
d1150 1
a1150 1
	lhs->bn.bn_list = (struct soltab **) rt_malloc(
d1168 1
a1168 1
	rhs->bn.bn_list = (struct soltab **) rt_malloc(
d1187 2
a1188 2
		rt_free( (char *)rhs->bn.bn_list, "rt_ct_box, rhs list");
		rt_free( (char *)lhs->bn.bn_list, "rt_ct_box, lhs list");
d1195 1
a1195 1
	rt_free( (char *)cutp->bn.bn_list, "rt_ct_box (old list)" );
d1420 1
a1420 1
		cutp = (union cutter *)rt_malloc(bytes," rt_ct_get");
@


11.31
log
@Provided support for rti_hasty_prep
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.30 1998/01/06 07:17:27 mike Exp mike $ (BRL)";
a138 2
static struct rt_i	*rt_cut_rtip;	/* Shared across threads */

d140 3
a142 1
rt_cut_optimize_parallel()
d144 1
a144 1
	struct rt_i	*rtip = rt_cut_rtip;
a815 1
			rt_cut_rtip = rtip;
d817 1
a817 1
				rt_cut_optimize_parallel(rtip);
d819 1
a819 1
				bu_parallel( rt_cut_optimize_parallel, ncpu );
@


11.30
log
@Fixed bug introduced by Glenn between revisions 11.15 and 11.19,
whereby he used the 10% larger _plotting_ bounding box for the
cutting tree, rather than the model RPP, as before.
Also put back the code to pre-malloc the required pointer table.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.29 1997/12/16 00:12:31 mike Exp mike $ (BRL)";
d761 5
@


11.29
log
@Converted to bu_semaphore_acquire()
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.28 1997/11/30 19:20:27 cjohnson Exp mike $ (BRL)";
d728 7
a734 3
	VMOVE( finp->bn.bn_min, rtip->rti_pmin );
	VMOVE( finp->bn.bn_max, rtip->rti_pmax );
	finp->bn.bn_maxlen = finp->bn.bn_len = 0;
@


11.28
log
@change void * pointers to genptr_t.  Seems that the K&R compiler on
VGR gets confused over void * pointers.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /vld/cjohnson/cvsroot/brlcad/librt/cut.c,v 11.27 1997/11/21 21:00:11 jra Exp $ (BRL)";
d151 1
a151 1
		RES_ACQUIRE( &rt_g.res_worker );
d153 1
a153 1
		RES_RELEASE( &rt_g.res_worker );
d1404 1
a1404 1
	RES_ACQUIRE(&rt_g.res_model);
d1424 1
a1424 1
	RES_RELEASE(&rt_g.res_model);
d1441 1
a1441 1
	RES_ACQUIRE(&rt_g.res_model);
d1444 1
a1444 1
	RES_RELEASE(&rt_g.res_model);
@


11.27
log
@Minor mod to get it to compile under Sun compiler.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.26 1997/10/09 02:56:16 mike Exp jra $ (BRL)";
d172 1
a172 1
CONST void *p1, *p2;
d179 1
a179 1
CONST void *p1, *p2;
d186 1
a186 1
CONST void *p1, *p2;
d193 1
a193 1
CONST void *p1, *p2;
d200 1
a200 1
CONST void *p1, *p2;
d207 1
a207 1
CONST void *p1, *p2;
d446 1
a446 1
			qsort( (void *)list_min, len,
d448 1
a448 1
			qsort( (void *)list_max, len,
@


11.26
log
@vgr fix
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.25 1997/09/10 18:46:54 gdurf Exp mike $ (BRL)";
d212 9
a431 8
		struct cmp_pair {
			int (*cmp_min)();
			int (*cmp_max)();
		} pairs[] = {
			{ rt_projXmin_comp, rt_projXmax_comp },
			{ rt_projYmin_comp, rt_projYmax_comp },
			{ rt_projZmin_comp, rt_projZmax_comp }
		};
@


11.25
log
@nugrid cleanups
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.24 1997/09/09 21:26:49 gdurf Exp gdurf $ (BRL)";
d164 5
a168 5
#define CMP(p1,p2,memb,ind) \
	(*(CONST struct soltab **)(p1))->memb[ind] < \
	(*(CONST struct soltab **)(p2))->memb[ind] ? -1 : \
	(*(CONST struct soltab **)(p1))->memb[ind] > \
	(*(CONST struct soltab **)(p2))->memb[ind] ? 1 : 0
@


11.24
log
@Added "fake_depth" variable to rt_nugrid_cut().
This fools rt_ct_optim() into thinking that a boxnode in a nugrid cell is
at the bottom of an appropriately deep tree.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.23 1997/09/04 21:22:09 gdurf Exp gdurf $ (BRL)";
d215 2
a216 5
 *   Makes a NUGrid node (CUT_NUGRIDNODE) and fills in the specified
 *   list of solids.
 *
 *   This may possibly recurse if a particular box is
 *   assigned more than RT_MAX_NUGRIDCELL_ENTRIES.
d236 1
a236 1
	int	fake_depth;
d310 2
a311 2
#if 1
	fake_depth = depth+(int)log((double)(nu_ncells*nu_ncells*nu_ncells));
d313 1
a313 1
	fake_depth = depth;
d477 5
a481 3
#if 0
				if( pos <= nugnp->nu_axis[i][axi].nu_spos +
				           rtip->rti_tol.dist )
d483 1
a483 5
#else
				if( pos <= nugnp->nu_axis[i][axi].nu_spos +
				           2.0 )
					continue;
#endif				
d486 5
a490 1
				if( pos >= fromp->bn_max[i] )
d655 1
a655 1
					rt_ct_optim( rtip, cutp, fake_depth );
d1226 3
a1228 1
		/* Need object classification test here */
@


11.23
log
@Changed EXPERIMENT to dim_limit variable
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.22 1997/08/29 00:56:39 gdurf Exp gdurf $ (BRL)";
d313 5
a317 1
	fake_depth = 0;/*depth+(int)log((double)(nu_ncells*nu_ncells*nu_ncells));*/
@


11.22
log
@attempted previous fix fixed
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.21 1997/08/20 19:22:56 jra Exp gdurf $ (BRL)";
d223 1
a223 1
rt_nugrid_cut( nugnp, fromp, rtip, just_collect_info )
d227 1
a227 1
int				 just_collect_info;
d239 1
d308 3
a310 5
#define EXPERIMENT 0
#if EXPERIMENT
	if( nu_ncells > 6 ) nu_ncells = 6;
#endif
		
d313 1
d650 3
a652 3
#if EXPERIMENT
#if 1				
				rt_ct_optim( rtip, cutp, 0 );
d656 1
a656 1
				if( cutp->bn.bn_len > 5 &&
a657 14
#if 1
					/* Make a little NUBSPT node here
					   to clean things up */
					union cutter *firstp;

					BU_GETUNION( firstp, cutter );
					*firstp = *cutp;  /* union copy */

					cutp->cut_type = CUT_NUBSPTNODE;
					VMOVE( cutp->nubn.nu_min,
					       firstp->bn.bn_min );
					VMOVE( cutp->nubn.nu_max,
					       firstp->bn.bn_max );
					cutp->nubn.first_cut = firstp;
a658 2
					rt_ct_optim( rtip, firstp, 0 );
#else
d667 4
a670 2
						       &temp, rtip, 0 );
#endif					
a671 2
#endif
#endif					
d695 1
a695 1
	union cutter *finp;
d751 3
d757 1
a757 1
		rt_nugrid_cut( &rtip->rti_CutHead.nugn, &finp->bn, rtip, 0 );
a758 1
		bu_free( (genptr_t)finp, "finite solid box" );
a762 5
#endif		
		rtip->rti_CutHead.cut_type = CUT_NUBSPTNODE;
		VMOVE( rtip->rti_CutHead.nubn.nu_min, rtip->mdl_min );
		VMOVE( rtip->rti_CutHead.nubn.nu_max, rtip->mdl_max );
		rtip->rti_CutHead.nubn.first_cut = finp;
a763 1
#ifdef NEW_WAY		
d767 1
a767 1
		rt_nugrid_cut( &nuginfo, &fin_box, rtip, 1 );
d769 1
a769 4

		bu_ptbl_init( &rtip->rti_cuts_waiting,
			      rtip->nsolids, "rti_cuts_waiting ptbl" );

d779 1
a779 1
			rt_ct_optim( rtip, finp, 0 );
d782 4
a785 2
			Needs to be updated for the new union cutter elts.
							    
d791 1
a791 1
						Y, 0, nuginfo.nu_cells_per_axis[Y]-1, &nuginfo );
d798 1
a798 1
					       "XYZ*"[i], nuginfo.nu_cells_per_axis[i] );
d816 2
d837 1
a837 2
		bu_log( "Counts: %d nubspt nodes, %d nugrid nodes, %d cutnodes, %d boxnodes\n",
			rtip->rti_ncut_by_type[CUT_NUBSPTNODE],
a1500 1
	case CUT_NUBSPTNODE:
a1528 6
	case CUT_NUBSPTNODE:
		rt_fr_cut( rtip, cutp->nubn.first_cut );
		rt_ct_free( rtip, cutp->nubn.first_cut );
		cutp->nubn.first_cut = CUTTER_NULL;
		return;

a1704 5
	case CUT_NUBSPTNODE:
		pl_color( fp, 0, 255, 255 );
		pdv_3box( fp, cutp->nubn.nu_min, cutp->nubn.nu_max );
		rt_plot_cut( fp, rtip, cutp->nubn.first_cut, lvl );
		return;
a1815 4
	case CUT_NUBSPTNODE:
		rtip->rti_ncut_by_type[CUT_NUBSPTNODE]++;
		rt_ct_measure( rtip, cutp->nubn.first_cut, depth+1 );
		return;
@


11.21
log
@Minor mods for IRIX 6.4.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.20 1997/08/20 19:13:16 jra Exp jra $ (BRL)";
d865 1
a865 1
		rt_pr_cut( rtip->rti_CutHead.nubn.first_cut, 0 );
@


11.20
log
@Mods by Gdurf.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.19 1997/07/23 07:09:35 gdurf Exp gdurf $ (BRL)";
d770 1
a770 1
		rt_nugrid_cut( &rtip->rti_CutHead.nugn, finp, rtip, 0 );
@


11.19
log
@NUgrid improvements
@
text
@a0 1
#define NUgrid 1
d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.18 1997/07/22 01:15:12 gdurf Exp gdurf $ (BRL)";
d309 1
a309 1
	if( nu_ncells > 10 ) nu_ncells = 10;
d476 1
a476 1

d480 5
d650 4
d656 1
a656 2
#if EXPERIMENT
				if( cutp->bn.bn_len > 30 &&
d658 1
a658 1
#if 0
d686 1
@


11.18
log
@More NUGrid changes.
In particular, NUGrid is becoming a first-class "union cutter" citizen.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.17 1997/07/10 18:08:48 gdurf Exp gdurf $ (BRL)";
d39 17
a55 11
HIDDEN int		rt_ck_overlap RT_ARGS((CONST vect_t min, CONST vect_t max,
				CONST struct soltab *stp));
HIDDEN int		rt_ct_box RT_ARGS((struct rt_i *rtip, union cutter *cutp,
				int axis, double where));
HIDDEN void		rt_ct_add RT_ARGS((union cutter *cutp, struct soltab *stp,
				vect_t min, vect_t max, int depth));
HIDDEN void		rt_ct_optim RT_ARGS((struct rt_i *rtip, union cutter *cutp,
				int depth));
HIDDEN void		rt_ct_free RT_ARGS((struct rt_i *rtip, union cutter *cutp));
HIDDEN void		rt_ct_measure RT_ARGS((struct rt_i *rtip, union cutter *cutp,
				int depth));
d58 1
a58 1
				union cutter *cutp, int lvl));
d111 2
a112 1
			if( !rt_ck_overlap( box->bn.bn_min, box->bn.bn_max, stp ) )
d165 48
d230 2
d234 1
a234 2
	struct bu_hist nu_hist_cellsize;
	struct boxnode nu_xbox, nu_ybox, nu_zbox;
d242 1
d308 5
d321 1
a332 7
	if( rt_g.debug&DEBUG_CUT ) {
		struct bu_hist xhist;
		struct bu_hist yhist;
		struct bu_hist zhist;
		char obuf[128];
		
#define	RT_NUGRID_NBINS	120		/* For plotting purposes only */
d334 10
a343 50
		bu_hist_init( &xhist, fromp->bn_min[X], fromp->bn_max[X],
			      RT_NUGRID_NBINS );
		bu_hist_init( &yhist, fromp->bn_min[Y], fromp->bn_max[Y],
			      RT_NUGRID_NBINS );
		bu_hist_init( &zhist, fromp->bn_min[Z], fromp->bn_max[Z],
			      RT_NUGRID_NBINS );
		
		for( i = 0, stpp = fromp->bn_list;
		     i < fromp->bn_len;
		     i++, stpp++ ) {
			register struct soltab *stp = *stpp;

			RT_CK_SOLTAB( stp );
			if( stp->st_aradius <= 0 )  continue;
			if( stp->st_aradius >= INFINITY )  continue;
			bu_hist_range( &xhist, stp->st_min[X],
				       stp->st_max[X] );
			bu_hist_range( &yhist, stp->st_min[Y],
				       stp->st_max[Y] );
			bu_hist_range( &zhist, stp->st_min[Z],
				       stp->st_max[Z] );

			for( j=0; j<3; j++ )  {
				BU_HIST_TALLY( &start_hist[j],stp->st_min[j] );
				BU_HIST_TALLY( &end_hist[j],  stp->st_max[j] );
			}
		}
		
		bu_hist_pr( &xhist,
			    "cut_tree:  solid RPP extent distribution in X" );
		bu_hist_pr( &yhist,
			    "cut_tree:  solid RPP extent distribution in Y" );
		bu_hist_pr( &zhist,
			    "cut_tree:  solid RPP extent distribution in Z" );

		bu_hist_free( &xhist );
		bu_hist_free( &yhist );
		bu_hist_free( &zhist );
	} else {
		for( i = 0, stpp = fromp->bn_list;
		     i < fromp->bn_len;
		     i++, stpp++ ) {
			register struct soltab *stp = *stpp;
			RT_CK_SOLTAB( stp );
			if( stp->st_aradius <= 0 )  continue;
			if( stp->st_aradius >= INFINITY )  continue;
			for( j=0; j<3; j++ )  {
				BU_HIST_TALLY( &start_hist[j],stp->st_min[j] );
				BU_HIST_TALLY( &end_hist[j],  stp->st_max[j] );
			}
d346 1
d351 4
a354 2
		nugnp->nu_axis[i] = (struct nu_axis *)rt_calloc( nu_max_ncells,
				       sizeof(struct nu_axis), "NUgrid axis" );
d421 64
d486 27
d533 1
a533 1
	   The binary space partioning algorithm uses this approach. */
a536 2
	bu_hist_init( &nu_hist_cellsize, 0.0, 400.0, 400 );

d572 1
a572 1
			if( !rt_ck_overlap( xmin, xmax, *stpp ) )
d589 2
a590 1
						    nu_xbox.bn_list[i] ) )
d617 2
a618 15
							nu_ybox.bn_list[i] ) )
						continue;

					if(
	 rt_functab[nu_ybox.bn_list[i]->st_id].ft_classify(nu_ybox.bn_list[i],
					   zmin, zmax, &rtip->rti_tol ) ==
							RT_CLASSIFY_OUTSIDE )
						continue;

					/* XXX for the time being, infinite
					   solids are handled
					   separately */

					if( nu_ybox.bn_list[i]->st_aradius >=
					    INFINITY )
a619 1
						
d623 1
a623 3
				/* Record cell size in histogram */
				BU_HIST_TALLY( &nu_hist_cellsize,
					       nu_zbox.bn_len );
d645 6
a651 1
				if( cutp->bn.bn_len > 8 ) {
d658 1
d667 11
d679 1
a679 1
#endif
a683 7
	if( rt_g.debug&DEBUG_CUT )  {
		bu_hist_pr( &nu_hist_cellsize,
			    "cut_tree: Number of solids per NUgrid cell");
		/* Just for inspection, print out the 0,0,0 cell */
		rt_pr_cut( nugnp->nu_grid, 0 );
	}

a686 2

	bu_hist_free( &nu_hist_cellsize );
d703 1
a703 1
	union cutter fin_box;
d730 5
a734 4
	fin_box.cut_type = CUT_BOXNODE;
	VMOVE( fin_box.bn.bn_min, rtip->mdl_min );
	VMOVE( fin_box.bn.bn_max, rtip->mdl_max );
	fin_box.bn.bn_maxlen = fin_box.bn.bn_len = 0;
d742 1
a742 1
			rt_cut_extend( &fin_box, stp );
d760 1
a760 1
	case RT_PART_NUGRID: {
d762 4
a765 2
		rt_nugrid_cut( &rtip->rti_CutHead.nugn, &fin_box, rtip, 0 );
		break; }
a769 2
		union cutter *first_cut;

d773 1
a773 2
		BU_GETUNION( first_cut, cutter );
		rtip->rti_CutHead.nubn.first_cut = first_cut;
d794 1
a794 21

			
			first_cut->bn.bn_type = CUT_BOXNODE;
			VMOVE( first_cut->bn.bn_min, rtip->mdl_min );
			VMOVE( first_cut->bn.bn_max, rtip->mdl_max );
			first_cut->bn.bn_len = 0;
			first_cut->bn.bn_maxlen = rtip->nsolids+1;
			first_cut->bn.bn_list =
				(struct soltab **)bu_malloc(
					first_cut->bn.bn_maxlen *
					sizeof(struct soltab *),
					"rt_cut_it: root list" );
			RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
				/* Ignore "dead" solids in the list.
				   (They failed prep) */
				if( stp->st_aradius <= 0 )  continue;
				if( stp->st_aradius < INFINITY )  {
					rt_cut_extend( first_cut, stp );
				}
			} RT_VISIT_ALL_SOLTABS_END
			rt_ct_optim( rtip, first_cut, 0 );
a823 21

		/* Measure the depth of tree, find max # of RPPs in a cut node */
		bu_hist_init( &rtip->rti_hist_cellsize, 0.0, 400.0, 400 );
		bu_hist_init( &rtip->rti_hist_cutdepth, 0.0,
			      (fastf_t)rt_cutDepth+1, rt_cutDepth+1 );
		rt_ct_measure( rtip, rtip->rti_CutHead.nubn.first_cut, 0 );
		rt_ct_measure( rtip, &rtip->rti_inf_box, 0 );
		if(rt_g.debug&DEBUG_CUT)  {
			bu_log("Cut: maxdepth=%d, nbins=%d, maxlen=%d, avg=%g\n",
			       rtip->rti_cut_maxdepth,
			       rtip->rti_cut_nbins,
			       rtip->rti_cut_maxlen,
			       ((double)rtip->rti_cut_totobj)/rtip->rti_cut_nbins );
			bu_hist_pr( &rtip->rti_hist_cellsize, "cut_tree: Number of solids per leaf cell");
			bu_hist_pr( &rtip->rti_hist_cutdepth, "cut_tree: Depth (height)"); 
		}

		if(rt_g.debug&DEBUG_CUTDETAIL)  {
			/* Produce a voluminous listing of the cut tree */
			rt_pr_cut( rtip->rti_CutHead.nubn.first_cut, 0 );
		}
d829 32
a860 1
	if( rt_g.debug&DEBUG_PLOTBOX )  {
d862 1
a862 1
		if( (plotfp=fopen("rtcut.plot", "w"))!=NULL) {
a868 2

	bu_free( (char *)fin_box.bn.bn_list, "solid list for rt_nugrid_cut" );
d882 1
a882 1
rt_ct_add( cutp, stp, min, max, depth )
d887 1
d897 3
a899 2
		if( rt_ck_overlap( min, temp, stp ) )
			rt_ct_add( cutp->cn.cn_l, stp, min, temp, depth+1 );
d904 3
a906 2
		if( rt_ck_overlap( temp, max, stp ) )
			rt_ct_add( cutp->cn.cn_r, stp, temp, max, depth+1 );
d1155 1
a1155 1
		    cutp->bn.bn_list[i]))
d1173 1
a1173 1
		    cutp->bn.bn_list[i]))
d1218 1
a1218 1
rt_ck_overlap( min, max, stp )
d1222 1
d1239 7
a1245 4
	if( stp->st_min[X] > max[X]  || stp->st_max[X] < min[X] )  goto fail;
	if( stp->st_min[Y] > max[Y]  || stp->st_max[Y] < min[Y] )  goto fail;
	if( stp->st_min[Z] > max[Z]  || stp->st_max[Z] < min[Z] )  goto fail;
	/* Need more sophistication here, per-object type */
d1289 1
a1289 1
#if 0
d1512 3
d1543 4
a1546 2
		cutp = cutp->nubn.first_cut;
		/* fall through */
d1560 1
a1560 1
			rt_free( (char *)cutp->bn.bn_list, "cut_box list");
d1563 15
a1577 3
	case CUT_NUGRIDNODE:
		/* XXX not implemented yet */
		return;
d1600 121
a1720 8
		int i;
		if( !cutp->nu_grid ) return;
		for( i = 0, bp = cutp->nugn.nu_grid;
		     i < cutp->nugn.nu_cells_per_axis[X]*
			     cutp->nugn.nu_cells_per_axis[Y]*
			     cutp->nugn.nu_cells_per_axis[Z];
		     i++, bp++ ) {
			rt_plot_cut( fp, rtip, bp, lvl );
d1722 1
d1839 17
a1855 1
	if( cutp->cut_type == CUT_CUTNODE )  {
d1859 11
a1869 2
	}
	if( cutp->cut_type != CUT_BOXNODE )  {
a1872 13
	/*
	 * BOXNODE (leaf)
	 */
	rtip->rti_cut_nbins++;
	rtip->rti_cut_totobj += (len = cutp->bn.bn_len);
	if( rtip->rti_cut_maxlen < len )
		rtip->rti_cut_maxlen = len;
	if( rtip->rti_cut_maxdepth < depth )
		rtip->rti_cut_maxdepth = depth;

	BU_HIST_TALLY( &rtip->rti_hist_cellsize, len );
	BU_HIST_TALLY( &rtip->rti_hist_cutdepth, depth ); 

@


11.17
log
@Checking in for safe-keeping.
Lots of NUgrid changes.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.16 1997/06/30 13:34:32 gdurf Exp gdurf $ (BRL)";
d68 1
a68 1
rt_cut_one_axis( boxes, rtip, axis, min, max )
d74 1
d93 1
a93 1
		box->bn.bn_list = (struct soltab **)rt_malloc(
d98 2
a99 2
		box->bn.bn_min[axis] = rtip->rti_sphead.nugn.nu_axis[axis][slice].nu_spos;
		box->bn.bn_max[axis] = rtip->rti_sphead.nugn.nu_axis[axis][slice].nu_epos;
d120 3
a122 3
	box->cn.cn_point = rtip->rti_sphead.nugn.nu_axis[axis][cur].nu_spos;
	box->cn.cn_l = rt_cut_one_axis( boxes, rtip, axis, min, cur-1 );
	box->cn.cn_r = rt_cut_one_axis( boxes, rtip, axis, cur, max );
a157 2
#if 0

d169 3
a171 1
rt_mk_nugrid( rtip, nugnp, st_list, st_len )
d173 1
a173 3
register struct nugridnode	*nugnp;
register struct soltab		*st_list;
register int			 st_len;
a174 3
	struct bu_hist xhist;
	struct bu_hist yhist;
	struct bu_hist zhist;
d179 1
a179 4
	

#endif

a180 23
/*
 *  			R T _ C U T _ I T
 *  
 *  Go through all the solids in the model, given the model mins and maxes,
 *  and generate a cutting tree.  A strategy better than incrementally
 *  cutting each solid is to build a box node which contains everything
 *  in the model, and optimize it.
 */
void
rt_cut_it(rtip, ncpu)
register struct rt_i	*rtip;
int			ncpu;
{
	register struct soltab *stp;
	FILE *plotfp;
	struct bu_hist xhist;
	struct bu_hist yhist;
	struct bu_hist zhist;
	struct bu_hist start_hist[3];	/* where solid RPPs start */
	struct bu_hist end_hist[3];	/* where solid RPPs end */
	struct bu_hist nu_hist_cellsize;
	struct boxnode nu_xbox, nu_ybox, nu_zbox;
	
d184 1
a184 1
	int	i, xp, yp, zp;
d187 2
a188 41
	/* For plotting, compute a slight enlargement of the model RPP,
	 * to allow room for rays clipped to the model RPP to be depicted.
	 * Always do this, because application debugging may use it too.
	 */
	{
		register fastf_t f, diff;

		diff = (rtip->mdl_max[X] - rtip->mdl_min[X]);
		f = (rtip->mdl_max[Y] - rtip->mdl_min[Y]);
		if( f > diff )  diff = f;
		f = (rtip->mdl_max[Z] - rtip->mdl_min[Z]);
		if( f > diff )  diff = f;
		diff *= 0.1;	/* 10% expansion of box */
		rtip->rti_pmin[0] = rtip->mdl_min[0] - diff;
		rtip->rti_pmin[1] = rtip->mdl_min[1] - diff;
		rtip->rti_pmin[2] = rtip->mdl_min[2] - diff;
		rtip->rti_pmax[0] = rtip->mdl_max[0] + diff;
		rtip->rti_pmax[1] = rtip->mdl_max[1] + diff;
		rtip->rti_pmax[2] = rtip->mdl_max[2] + diff;
	}

	/* XXX In the process of changing this.
	       Eventually, cut_type will be whatever the user specified
	       at the upper level.
	       Furthermore, recursive partitioning algorithms may be used,
	       at which point both this and rt_advance_next_cell will have
	       to be recursive. */

	rtip->rti_sphead.cut_type = CUT_NUGRIDNODE;

	/* Add infinite solids to special box XXXXXXXXX WHERE SHOULD THIS
	 GO????? */
	
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		/* Ignore "dead" solids in the list.  (They failed prep) */
		if( stp->st_aradius <= 0 )  continue;
		if( stp->st_aradius >= INFINITY )  {
			/* Add to infinite solids list for special handling */
			rt_cut_extend( &rtip->rti_inf_box, stp );
		}
	} RT_VISIT_ALL_SOLTABS_END
d241 2
a242 1
	if( rtip->rti_nu_gfactor < 0.01 ) {
d244 3
a246 1
		bu_log( "rt_cut_it: rtip->rti_nu_gfactor not set\n" );
d250 10
a259 6
			       pow( (double)(rtip->nsolids), 1.0/3.0 ) );
	nu_sol_per_cell = (rtip->nsolids + nu_ncells - 1) / nu_ncells;
	nu_max_ncells = 8*nu_ncells + 64;

if(rt_g.debug&DEBUG_CUT)  bu_log("\nnu_ncells=%d, nu_sol_per_cell=%d, nu_max_ncells=%d\n", nu_ncells, nu_sol_per_cell, nu_max_ncells );
	for( i=0; i<3; i++ )  {
d261 3
a263 3
			rtip->rti_pmin[i],
			rtip->rti_pmax[i],
			nu_ncells*100 );
d265 3
a267 3
			rtip->rti_pmin[i],
			rtip->rti_pmax[i],
			nu_ncells*100 );
d269 7
d277 27
a303 18
	bu_hist_init( &xhist, rtip->rti_pmin[X], rtip->rti_pmax[X], RT_NUGRID_NBINS );
	bu_hist_init( &yhist, rtip->rti_pmin[Y], rtip->rti_pmax[Y], RT_NUGRID_NBINS );
	bu_hist_init( &zhist, rtip->rti_pmin[Z], rtip->rti_pmax[Z], RT_NUGRID_NBINS );
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		/* Ignore "dead" solids in the list.  (They failed prep) */
		if( stp->st_aradius <= 0 )  continue;
		if( stp->st_aradius >= INFINITY )  continue;
		bu_hist_range( &xhist,
			stp->st_min[X], stp->st_max[X] );
		bu_hist_range( &yhist,
			stp->st_min[Y], stp->st_max[Y] );
		bu_hist_range( &zhist,
			stp->st_min[Z], stp->st_max[Z] );
		for( i=0; i<3; i++ )  {
			BU_HIST_TALLY( &start_hist[i],
				stp->st_min[i] );
			BU_HIST_TALLY( &end_hist[i],
				stp->st_max[i] );
d305 23
a327 13
	} RT_VISIT_ALL_SOLTABS_END
	if(rt_g.debug&DEBUG_CUT)  {
		char	obuf[128];
		bu_hist_pr( &xhist, "cut_tree:  solid RPP extent distribution in X" );
		bu_hist_pr( &yhist, "cut_tree:  solid RPP extent distribution in Y" );
		bu_hist_pr( &zhist, "cut_tree:  solid RPP extent distribution in Z" );
		for( i=0; i<3; i++ )  {
			sprintf(obuf, "cut_tree:  %c axis solid RPP start distribution\n",
				"XYZ*"[i] );
			bu_hist_pr( &start_hist[i], obuf );
			sprintf(obuf, "cut_tree:  %c axis solid RPP end distribution\n",
				"XYZ*"[i] );
			bu_hist_pr( &end_hist[i], obuf );
d331 5
a335 6
	for( i=0; i<3; i++ )  {
		rtip->rti_sphead.nugn.nu_axis[i] =
			(struct nu_axis *)rt_calloc( nu_max_ncells,
				   sizeof(struct nu_axis), "NUgrid axis" );
	}

d348 1
a355 1
/*		int	epos; */
d358 2
a359 1
		if( shp->hg_min != ehp->hg_min )  rt_bomb("cut_it: hg_min error\n");
d361 1
a361 1
		rtip->rti_sphead.nugn.nu_axis[i][axi].nu_spos = pos;
d371 1
a371 1
			    nend < nu_sol_per_cell )  continue;
d377 3
a379 2
			rtip->rti_sphead.nugn.nu_axis[i][axi].nu_epos = pos;
			rtip->rti_sphead.nugn.nu_axis[i][axi].nu_width = pos - rtip->rti_sphead.nugn.nu_axis[i][axi].nu_spos;
d386 1
a386 1
			rtip->rti_sphead.nugn.nu_axis[i][++axi].nu_spos = pos;
d391 4
a394 3
		rtip->rti_sphead.nugn.nu_axis[i][axi].nu_epos = pos;
		rtip->rti_sphead.nugn.nu_axis[i][axi].nu_width = pos - rtip->rti_sphead.nugn.nu_axis[i][axi].nu_spos;
		rtip->rti_sphead.nugn.nu_cells_per_axis[i] = axi+1;
d397 5
a401 5
	rtip->rti_sphead.nugn.nu_stepsize[X] = 1;
	rtip->rti_sphead.nugn.nu_stepsize[Y] = rtip->rti_sphead.nugn.nu_cells_per_axis[X] *
		rtip->rti_sphead.nugn.nu_stepsize[X];
	rtip->rti_sphead.nugn.nu_stepsize[Z] = rtip->rti_sphead.nugn.nu_cells_per_axis[Y] *
		rtip->rti_sphead.nugn.nu_stepsize[Y];
d403 6
d410 1
a410 1
	if(rt_g.debug&DEBUG_CUT)  for( i=0; i<3; i++ )  {
d412 7
a418 7
		bu_log("NUgrid %c axis:  %d cells\n",
			"XYZ*"[i], rtip->rti_sphead.nugn.nu_cells_per_axis[i] );
		for( j=0; j<rtip->rti_sphead.nugn.nu_cells_per_axis[i]; j++ )  {
			bu_log("  %g .. %g, w=%g\n",
				rtip->rti_sphead.nugn.nu_axis[i][j].nu_spos,
				rtip->rti_sphead.nugn.nu_axis[i][j].nu_epos,
				rtip->rti_sphead.nugn.nu_axis[i][j].nu_width );
d422 36
a457 8
	if( rtip->rti_space_partition == RT_PART_NUGRID ) {
		bu_hist_init( &nu_hist_cellsize, -10.0, 400.0, 410 );
		/* For the moment, re-use "union cutter" */
		rtip->rti_sphead.nugn.nu_grid = (union cutter *)rt_malloc(
			rtip->rti_sphead.nugn.nu_cells_per_axis[X] *
			rtip->rti_sphead.nugn.nu_cells_per_axis[Y] *
			rtip->rti_sphead.nugn.nu_cells_per_axis[Z] * sizeof(union cutter),
			"3-D NUgrid union cutter []" );
d459 9
a467 23
		nu_xbox.bn_maxlen = rtip->nsolids;
		nu_xbox.bn_list = (struct soltab **)rt_malloc(
			nu_xbox.bn_maxlen * sizeof(struct soltab *),
			"xbox boxnode []" );
		nu_ybox.bn_len = 0;
		nu_ybox.bn_maxlen = rtip->nsolids;
		nu_ybox.bn_list = (struct soltab **)rt_malloc(
			nu_ybox.bn_maxlen * sizeof(struct soltab *),
			"ybox boxnode []" );
		nu_zbox.bn_len = 0;
		nu_zbox.bn_maxlen = rtip->nsolids;
		nu_zbox.bn_list = (struct soltab **)rt_malloc(
			nu_zbox.bn_maxlen * sizeof(struct soltab *),
			"zbox boxnode []" );
		/* Build each of the X slices */
		for( xp = 0; xp < rtip->rti_sphead.nugn.nu_cells_per_axis[X]; xp++ )  {
			VMOVE( xmin, rtip->mdl_min );
			VMOVE( xmax, rtip->mdl_max );
			xmin[X] = rtip->rti_sphead.nugn.nu_axis[X][xp].nu_spos;
			xmax[X] = rtip->rti_sphead.nugn.nu_axis[X][xp].nu_epos;
			VMOVE( nu_xbox.bn_min, xmin );
			VMOVE( nu_xbox.bn_max, xmax );
			nu_xbox.bn_len = 0;
d469 13
a481 4
			/* Search all solids for those in this X slice */
			RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
				RT_CHECK_SOLTAB(stp);
				if( !rt_ck_overlap( xmin, xmax, stp ) )
d483 11
a493 30
				nu_xbox.bn_list[nu_xbox.bn_len++] = stp;
			} RT_VISIT_ALL_SOLTABS_END

			/* Build each of the Y slices in this X slice */
			for( yp = 0; yp < rtip->rti_sphead.nugn.nu_cells_per_axis[Y]; yp++ )  {
				VMOVE( ymin, xmin );
				VMOVE( ymax, xmax );
				ymin[Y] = rtip->rti_sphead.nugn.nu_axis[Y][yp].nu_spos;
				ymax[Y] = rtip->rti_sphead.nugn.nu_axis[Y][yp].nu_epos;
				VMOVE( nu_ybox.bn_min, ymin );
				VMOVE( nu_ybox.bn_max, ymax );
				nu_ybox.bn_len = 0;
				/* Search X slice for membs of this Y slice */
				for( i=0; i<nu_xbox.bn_len; i++ )  {
					if( !rt_ck_overlap( ymin, ymax,
							 nu_xbox.bn_list[i] ) )
						continue;
					nu_ybox.bn_list[nu_ybox.bn_len++] =
						nu_xbox.bn_list[i];
				}
				/* Build each of the Z slices in this Y slice*/
				/* Each of these will be a final cell */
				for( zp = 0;
				     zp < rtip->rti_sphead.nugn.nu_cells_per_axis[Z];
				     zp++ )  {
					register union cutter *cutp =
						&rtip->rti_sphead.nugn.nu_grid[
						zp*rtip->rti_sphead.nugn.nu_stepsize[Z] +
						yp*rtip->rti_sphead.nugn.nu_stepsize[Y] +
						xp*rtip->rti_sphead.nugn.nu_stepsize[X]];
d495 7
a501 8

					VMOVE( zmin, ymin );
					VMOVE( zmax, ymax );
					zmin[Z] = rtip->rti_sphead.nugn.nu_axis[Z][zp].nu_spos;
					zmax[Z] = rtip->rti_sphead.nugn.nu_axis[Z][zp].nu_epos;
					cutp->cut_type = CUT_BOXNODE;
					VMOVE( cutp->bn.bn_min, zmin );
					VMOVE( cutp->bn.bn_max, zmax );
d504 1
a504 1
					nu_zbox.bn_len = 0;
d506 4
a509 6
					for( i=0; i<nu_ybox.bn_len; i++ )  {
						int classification;
						
						if( !rt_ck_overlap( zmin, zmax,
						       nu_ybox.bn_list[i] ) )
							continue;
d511 5
a515 3
						classification = 
          rt_functab[nu_ybox.bn_list[i]->st_id].ft_classify(nu_ybox.bn_list[i],
							    zmin, zmax );
d517 3
a519 1
						if( classification == RT_CLASSIFY_OUTSIDE )
d521 3
a523 1
							continue;
d525 3
a527 4
						nu_zbox.bn_list[
							nu_zbox.bn_len++] =
							nu_ybox.bn_list[i];
					}
d529 9
a537 10
					BU_HIST_TALLY( &nu_hist_cellsize,
						       nu_zbox.bn_len );
					if( nu_zbox.bn_len <= 0 )  {
						/* Empty cell */
						cutp->bn.bn_list =
							(struct soltab **)0;
						cutp->bn.bn_len = 0;
						cutp->bn.bn_maxlen = 0;
						continue;
					}
d540 28
a567 11
					cutp->bn.bn_list =
						(struct soltab **)rt_malloc(
						    nu_zbox.bn_len *
						    sizeof(struct soltab *),
						    "NUgrid cell bn_list[]" );
					cutp->bn.bn_len = cutp->bn.bn_maxlen =
						nu_zbox.bn_len;
					bcopy( (char *)nu_zbox.bn_list,
					       (char *)cutp->bn.bn_list,
					       nu_zbox.bn_len *
					       sizeof(struct soltab *) );
d569 1
d572 1
d574 2
a575 2
		if( rt_g.debug&DEBUG_CUT )  {
			bu_hist_pr( &nu_hist_cellsize,
d577 64
a640 2
			/* Just for inspection, print out the 0,0,0 cell */
			rt_pr_cut( rtip->rti_sphead.nugn.nu_grid, 0 );
d642 38
a680 9
		/* XXX Make an empty boxnode */
		rtip->rti_CutHead.bn.bn_type = CUT_BOXNODE;
		rtip->rti_CutHead.bn.bn_len = 0;
		rtip->rti_CutHead.bn.bn_maxlen = 0;

		rt_free( (char *)nu_xbox.bn_list, "nu_xbox bn_list[]" );
		rt_free( (char *)nu_ybox.bn_list, "nu_ybox bn_list[]" );
		rt_free( (char *)nu_zbox.bn_list, "nu_zbox bn_list[]" );
	} else if( rtip->rti_space_partition == RT_PART_NUBSPT ) {
d684 1
a684 13
		/*  Dynamic decisions on tree limits.  Note that there
		 *  will be (2**rt_cutDepth)*rt_cutLen leaf slots, but
		 *  solids will typically span several leaves.
		 */
		
		rt_cutLen = (int)log((double)rtip->nsolids);  /* ln ~= log2 */
		rt_cutDepth = 2 * rt_cutLen;
		if( rt_cutLen < 3 )  rt_cutLen = 3;
		if( rt_cutDepth < 9 )  rt_cutDepth = 9;
		if( rt_cutDepth > 24 )  rt_cutDepth = 24;     /* !! */
if(rt_g.debug&DEBUG_CUT) bu_log("Cut: Tree Depth=%d, Leaf Len=%d\n", rt_cutDepth, rt_cutLen );

#if 0
d687 7
a693 6
	/* Old way, non-parallel */
	/* For some reason, this algorithm produces a substantial
	 * performance improvement over the parallel way, below.  The
	 * benchmark tests seem to be very sensitive to how the space
	 * partitioning is laid out.  Until we go to full NUgrid, this
	 * will have to do.  */
d695 10
a704 9
			rtip->rti_CutHead.bn.bn_type = CUT_BOXNODE;
			VMOVE( rtip->rti_CutHead.bn.bn_min, rtip->mdl_min );
			VMOVE( rtip->rti_CutHead.bn.bn_max, rtip->mdl_max );
			rtip->rti_CutHead.bn.bn_len = 0;
			rtip->rti_CutHead.bn.bn_maxlen = rtip->nsolids+1;
			rtip->rti_CutHead.bn.bn_list =
				(struct soltab **)rt_malloc(
				rtip->rti_CutHead.bn.bn_maxlen * sizeof(struct soltab *),
				"rt_cut_it: root list" );
d706 2
a707 1
				/* Ignore "dead" solids in the list.  (They failed prep) */
d710 1
a710 1
					rt_cut_extend( &rtip->rti_CutHead, stp );
d713 2
a714 2
			rt_ct_optim( rtip, &rtip->rti_CutHead, 0 );
#if 0
d716 2
d721 1
a721 1

d723 1
a723 1
						Y, 0, rtip->rti_sphead.nugn.nu_cells_per_axis[Y]-1 );
d726 1
a726 1

d730 1
a730 1
					       "XYZ*"[i], rtip->rti_sphead.nugn.nu_cells_per_axis[i] );
d734 1
a734 1

d748 1
a748 1
		rt_ct_measure( rtip, &rtip->rti_CutHead, 0 );
a759 9
		if( rt_g.debug&DEBUG_PLOTBOX )  {
			/* Debugging code to plot cuts */
			if( (plotfp=fopen("rtcut.plot", "w"))!=NULL) {
				pdv_3space( plotfp, rtip->rti_pmin, rtip->rti_pmax );
				/* Plot all the cutting boxes */
				rt_plot_cut( plotfp, rtip, &rtip->rti_CutHead, 0 );
				(void)fclose(plotfp);
			}
		}
d762 1
a762 1
			rt_pr_cut( &rtip->rti_CutHead, 0 );
d764 3
d769 8
a776 7
	/*  Finished with temporary data structures */
	bu_hist_free( &xhist );
	bu_hist_free( &yhist );
	bu_hist_free( &zhist );
	for( i=0; i<3; i++ )  {
		bu_hist_free( &start_hist[i] );
		bu_hist_free( &end_hist[i] );
d778 2
d782 2
d843 1
a843 1
			cutp->bn.bn_list = (struct soltab **)rt_malloc(
d849 1
a849 1
			newlist = rt_malloc(
d1443 4
d1462 4
d1485 17
@


11.16
log
@NUgrid now has an empty boxnode for a NUBSPT
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.15 1997/06/13 02:52:30 gdurf Exp gdurf $ (BRL)";
a53 1

a56 43
 *			R T _ F I N D _ N U G R I D
 *
 *  Along the given axis, find which NUgrid cell this value lies in.
 *  Use method of binary subdivision.
 */
int
rt_find_nugrid( rtip, axis, val )
struct rt_i *rtip;	
int	axis;
fastf_t	val;
{
	int	min;
	int	max;
	int	lim = rtip->rti_nu_cells_per_axis[axis]-1;
	int	cur;

	if( val < rtip->rti_nu_axis[axis][0].nu_spos ||
	    val > rtip->rti_nu_axis[axis][lim].nu_epos )
		return -1;

	min = 0;
	max = lim;
again:
	cur = (min + max) / 2;

	if( cur <= 0 )  return 0;
	if( cur >= lim )  return lim;

	if( val < rtip->rti_nu_axis[axis][cur].nu_spos )  {
		max = cur;
		goto again;
	}
	if( val > rtip->rti_nu_axis[axis][cur+1].nu_epos )  {
		min = cur+1;
		goto again;
	}
	if( val < rtip->rti_nu_axis[axis][cur].nu_epos )
		return cur;
	else
		return cur+1;
}

/*
d97 2
a98 2
		box->bn.bn_min[axis] = rtip->rti_nu_axis[axis][slice].nu_spos;
		box->bn.bn_max[axis] = rtip->rti_nu_axis[axis][slice].nu_epos;
d119 1
a119 1
	box->cn.cn_point = rtip->rti_nu_axis[axis][cur].nu_spos;
d157 31
d238 9
d274 34
d309 8
a316 2
	nu_ncells = (int)ceil( 2.0 +
		pow( (double)(rtip->nsolids)/3.0, 1.0/3.0 ) );
d318 1
a318 1
	nu_max_ncells = 2*nu_ncells + 8;
d368 1
a368 1
		rtip->rti_nu_axis[i] =
d393 1
a393 1
		int	axi = 0;	/* rtip->rti_nu_axis index */
d397 1
a397 1
		rtip->rti_nu_axis[i][axi].nu_spos = pos;
d405 1
d408 4
d413 2
a414 2
			rtip->rti_nu_axis[i][axi].nu_epos = pos;
			rtip->rti_nu_axis[i][axi].nu_width = pos - rtip->rti_nu_axis[i][axi].nu_spos;
d421 1
a421 1
			rtip->rti_nu_axis[i][++axi].nu_spos = pos;
d426 3
a428 3
		rtip->rti_nu_axis[i][axi].nu_epos = pos;
		rtip->rti_nu_axis[i][axi].nu_width = pos - rtip->rti_nu_axis[i][axi].nu_spos;
		rtip->rti_nu_cells_per_axis[i] = axi+1;
d431 5
a435 5
	rtip->rti_nu_stepsize[X] = 1;
	rtip->rti_nu_stepsize[Y] = rtip->rti_nu_cells_per_axis[X] *
		rtip->rti_nu_stepsize[X];
	rtip->rti_nu_stepsize[Z] = rtip->rti_nu_cells_per_axis[Y] *
		rtip->rti_nu_stepsize[Y];
d441 2
a442 2
			"XYZ*"[i], rtip->rti_nu_cells_per_axis[i] );
		for( j=0; j<rtip->rti_nu_cells_per_axis[i]; j++ )  {
d444 3
a446 3
				rtip->rti_nu_axis[i][j].nu_spos,
				rtip->rti_nu_axis[i][j].nu_epos,
				rtip->rti_nu_axis[i][j].nu_width );
d451 1
a451 1
		bu_hist_init( &nu_hist_cellsize, 0.0, 400.0, 400 );
d453 4
a456 3
		rtip->rti_nu_grid = (union cutter *)rt_malloc(
			rtip->rti_nu_cells_per_axis[X] * rtip->rti_nu_cells_per_axis[Y] *
			rtip->rti_nu_cells_per_axis[Z] * sizeof(union cutter),
d474 1
a474 1
		for( xp = 0; xp < rtip->rti_nu_cells_per_axis[X]; xp++ )  {
d477 2
a478 2
			xmin[X] = rtip->rti_nu_axis[X][xp].nu_spos;
			xmax[X] = rtip->rti_nu_axis[X][xp].nu_epos;
d492 1
a492 1
			for( yp = 0; yp < rtip->rti_nu_cells_per_axis[Y]; yp++ )  {
d495 2
a496 2
				ymin[Y] = rtip->rti_nu_axis[Y][yp].nu_spos;
				ymax[Y] = rtip->rti_nu_axis[Y][yp].nu_epos;
d511 1
a511 1
				     zp < rtip->rti_nu_cells_per_axis[Z];
d514 4
a517 4
						&rtip->rti_nu_grid[
						zp*rtip->rti_nu_stepsize[Z] +
						yp*rtip->rti_nu_stepsize[Y] +
						xp*rtip->rti_nu_stepsize[X]];
d522 2
a523 2
					zmin[Z] = rtip->rti_nu_axis[Z][zp].nu_spos;
					zmax[Z] = rtip->rti_nu_axis[Z][zp].nu_epos;
d532 2
d537 9
d582 1
a582 1
			rt_pr_cut( rtip->rti_nu_grid, 0 );
d643 1
a643 1
						Y, 0, rtip->rti_nu_cells_per_axis[Y]-1 );
d650 1
a650 1
					       "XYZ*"[i], rtip->rti_nu_cells_per_axis[i] );
d665 1
a665 1
		bu_hist_init( &rtip->rti_hist_cellsize, 0.0, 399.0, 400 );
d667 1
a667 1
			      (fastf_t)rt_cutDepth+1, 400 );
@


11.15
log
@Cleaned up NUgrid code.
NUgrid information is now stored on a per-rti basis.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.14 1997/06/12 17:35:52 gdurf Exp gdurf $ (BRL)";
d531 5
@


11.14
log
@Fixed elusive memory leak in rt_cut_it()
Finished NUgrid fixes
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.13 1997/06/12 15:22:52 gdurf Exp gdurf $ (BRL)";
a56 13
/* XXX start temporary NUgrid hack  -- shared with shoot.c */
#define RT_NUGRID_CELL(_array,_x,_y,_z)		(&(_array)[ \
	((((_z)*rt_nu_cells_per_axis[Y])+(_y))*rt_nu_cells_per_axis[X])+(_x) ])
struct nu_axis {
	fastf_t	nu_spos;	/* cell start pos */
	fastf_t	nu_epos;	/* cell end pos */
	fastf_t	nu_width;	/* voxel size */
};
struct nu_axis	*rt_nu_axis[3];
int		rt_nu_cells_per_axis[3];
union cutter	*rt_nu_grid;
/* XXX end NUgrid hack */

d64 2
a65 1
rt_find_nugrid( axis, val )
d71 1
a71 1
	int	lim = rt_nu_cells_per_axis[axis]-1;
d74 4
d86 1
a86 1
	if( val < rt_nu_axis[axis][cur].nu_spos )  {
d90 2
a91 2
	if( val > rt_nu_axis[axis][cur].nu_epos )  {
		min = cur;
d94 4
a97 2
	/* val >= spos && val <= epos */
	return cur;
d141 2
a142 2
		box->bn.bn_min[axis] = rt_nu_axis[axis][slice].nu_spos;
		box->bn.bn_max[axis] = rt_nu_axis[axis][slice].nu_epos;
d163 1
a163 1
	box->cn.cn_point = rt_nu_axis[axis][cur].nu_spos;
d251 12
d283 1
d332 3
a334 2
		rt_nu_axis[i] = (struct nu_axis *)rt_calloc( nu_max_ncells,
			sizeof(struct nu_axis), "NUgrid axis" );
d357 1
a357 1
		int	axi = 0;	/* rt_nu_axis index */
d361 1
a361 1
		rt_nu_axis[i][axi].nu_spos = pos;
d372 2
a373 2
			rt_nu_axis[i][axi].nu_epos = pos;
			rt_nu_axis[i][axi].nu_width = pos - rt_nu_axis[i][axi].nu_spos;
d380 1
a380 1
			rt_nu_axis[i][++axi].nu_spos = pos;
d385 3
a387 3
		rt_nu_axis[i][axi].nu_epos = pos;
		rt_nu_axis[i][axi].nu_width = pos - rt_nu_axis[i][axi].nu_spos;
		rt_nu_cells_per_axis[i] = axi+1;
d390 6
d400 2
a401 2
			"XYZ*"[i], rt_nu_cells_per_axis[i] );
		for( j=0; j<rt_nu_cells_per_axis[i]; j++ )  {
d403 3
a405 3
				rt_nu_axis[i][j].nu_spos,
				rt_nu_axis[i][j].nu_epos,
				rt_nu_axis[i][j].nu_width );
d409 7
a415 30
#if NUgrid
	bu_hist_init( &nu_hist_cellsize, 0.0, 400.0, 400 );
	/* For the moment, re-use "union cutter" */
	rt_nu_grid = (union cutter *)rt_malloc(
		rt_nu_cells_per_axis[X] * rt_nu_cells_per_axis[Y] *
		rt_nu_cells_per_axis[Z] * sizeof(union cutter),
		 "3-D NUgrid union cutter []" );
	nu_xbox.bn_len = 0;
	nu_xbox.bn_maxlen = rtip->nsolids;
	nu_xbox.bn_list = (struct soltab **)rt_malloc(
		nu_xbox.bn_maxlen * sizeof(struct soltab *),
		"xbox boxnode []" );
	nu_ybox.bn_len = 0;
	nu_ybox.bn_maxlen = rtip->nsolids;
	nu_ybox.bn_list = (struct soltab **)rt_malloc(
		nu_ybox.bn_maxlen * sizeof(struct soltab *),
		"ybox boxnode []" );
	nu_zbox.bn_len = 0;
	nu_zbox.bn_maxlen = rtip->nsolids;
	nu_zbox.bn_list = (struct soltab **)rt_malloc(
		nu_zbox.bn_maxlen * sizeof(struct soltab *),
		"zbox boxnode []" );
	/* Build each of the X slices */
	for( xp = 0; xp < rt_nu_cells_per_axis[X]; xp++ )  {
		VMOVE( xmin, rtip->mdl_min );
		VMOVE( xmax, rtip->mdl_max );
		xmin[X] = rt_nu_axis[X][xp].nu_spos;
		xmax[X] = rt_nu_axis[X][xp].nu_epos;
		VMOVE( nu_xbox.bn_min, xmin );
		VMOVE( nu_xbox.bn_max, xmax );
d417 31
d449 36
a484 37
		/* Search all solids for those in this X slice */
		RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
			RT_CHECK_SOLTAB(stp);
			if( !rt_ck_overlap( xmin, xmax, stp ) )
				continue;
			nu_xbox.bn_list[nu_xbox.bn_len++] = stp;
		} RT_VISIT_ALL_SOLTABS_END

		/* Build each of the Y slices in this X slice */
		for( yp = 0; yp < rt_nu_cells_per_axis[Y]; yp++ )  {
			VMOVE( ymin, xmin );
			VMOVE( ymax, xmax );
			ymin[Y] = rt_nu_axis[Y][yp].nu_spos;
			ymax[Y] = rt_nu_axis[Y][yp].nu_epos;
			VMOVE( nu_ybox.bn_min, ymin );
			VMOVE( nu_ybox.bn_max, ymax );
			nu_ybox.bn_len = 0;
			/* Search X slice for members of this Y slice */
			for( i=0; i<nu_xbox.bn_len; i++ )  {
				if( !rt_ck_overlap( ymin, ymax,
				    nu_xbox.bn_list[i] ) )
					continue;
				nu_ybox.bn_list[nu_ybox.bn_len++] =
					nu_xbox.bn_list[i];
			}
			/* Build each of the Z slices in this Y slice. */
			/* Each of these will be a final cell */
			for( zp = 0; zp < rt_nu_cells_per_axis[Z]; zp++ )  {
				register union cutter *cutp =
					RT_NUGRID_CELL(rt_nu_grid, xp, yp, zp);
				VMOVE( zmin, ymin );
				VMOVE( zmax, ymax );
				zmin[Z] = rt_nu_axis[Z][zp].nu_spos;
				zmax[Z] = rt_nu_axis[Z][zp].nu_epos;
				cutp->cut_type = CUT_BOXNODE;
				VMOVE( cutp->bn.bn_min, zmin );
				VMOVE( cutp->bn.bn_max, zmax );
d487 19
a505 5
				nu_zbox.bn_len = 0;
				/* Search Y slice for members of this Z slice */
				for( i=0; i<nu_ybox.bn_len; i++ )  {
					if( !rt_ck_overlap( zmin, zmax,
					    nu_ybox.bn_list[i] ) )
d507 1
a507 13
					nu_zbox.bn_list[nu_zbox.bn_len++] =
						nu_ybox.bn_list[i];
				}
				/* Record cell size in histogram */
				BU_HIST_TALLY( &nu_hist_cellsize,
					nu_zbox.bn_len );
				if( nu_zbox.bn_len <= 0 )  {
					/* Empty cell */
					cutp->bn.bn_list = (struct soltab **)0;
					cutp->bn.bn_len = 0;
					cutp->bn.bn_maxlen = 0;
					continue;
				}
d510 11
a520 16
				cutp->bn.bn_list = (struct soltab **)rt_malloc(
					nu_zbox.bn_len * sizeof(struct soltab *),
					"NUgrid cell bn_list[]" );
				cutp->bn.bn_len = cutp->bn.bn_maxlen =
					nu_zbox.bn_len;
				bcopy( (char *)nu_zbox.bn_list,
					(char *)cutp->bn.bn_list,
					nu_zbox.bn_len * sizeof(struct soltab *) );

				if( rt_g.debug&DEBUG_CUT ) {
					bu_log( "Solids in cell (%d,%d,%d) [in nu%d%d%d rpp %g %g %g %g %g %g]:",
						xp, yp, zp, xp, yp, zp,
						zmin[X], zmax[X],
						zmin[Y], zmax[Y],
						zmin[Z], zmax[Z]);
					rt_pr_cut( cutp, 0 );
a521 1

a523 6
	}
	if(rt_g.debug&DEBUG_CUT)  {
		bu_hist_pr( &nu_hist_cellsize, "cut_tree: Number of solids per NUgrid cell");
		/* Just for inspection, print out the 0,0,0 cell */
		rt_pr_cut( rt_nu_grid, 0 );
	}
d525 5
a529 12
	rt_free( (char *)nu_xbox.bn_list, "nu_xbox bn_list[]" );
	rt_free( (char *)nu_ybox.bn_list, "nu_ybox bn_list[]" );
	rt_free( (char *)nu_zbox.bn_list, "nu_zbox bn_list[]" );
#endif	/* NUgrid */

	/* Add infinite solids to special box */
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		/* Ignore "dead" solids in the list.  (They failed prep) */
		if( stp->st_aradius <= 0 )  continue;
		if( stp->st_aradius >= INFINITY )  {
			/* Add to infinite solids list for special handling */
			rt_cut_extend( &rtip->rti_inf_box, stp );
a530 1
	} RT_VISIT_ALL_SOLTABS_END
d532 18
a549 1
	bu_ptbl_init( &rtip->rti_cuts_waiting, rtip->nsolids, "rti_cuts_waiting ptbl" );
a550 11
	/*  Dynamic decisions on tree limits.
	 *  Note that there will be (2**rt_cutDepth)*rt_cutLen leaf slots,
	 *  but solids will typically span several leaves.
	 */
	rt_cutLen = (int)log((double)rtip->nsolids);	/* ln ~= log2 */
	rt_cutDepth = 2 * rt_cutLen;
	if( rt_cutLen < 3 )  rt_cutLen = 3;
	if( rt_cutDepth < 9 )  rt_cutDepth = 9;
	if( rt_cutDepth > 24 )  rt_cutDepth = 24;		/* !! */
	if(rt_g.debug&DEBUG_CUT) bu_log("Cut: Tree Depth=%d, Leaf Len=%d\n", rt_cutDepth, rt_cutLen );

d552 1
a552 1
	if( rtip->nsolids < 50000 )  {
d554 41
a594 21
		/* Old way, non-parallel */
		/*
		 *  For some reason, this algorithm produces a substantial
		 *  performance improvement over the parallel way, below.
		 *  The benchmark tests seem to be very sensitive to
		 *  how the space partitioning is laid out.
		 *  Until we go to full NUgrid, this will have to do.
		 */
		rtip->rti_CutHead.bn.bn_type = CUT_BOXNODE;
		VMOVE( rtip->rti_CutHead.bn.bn_min, rtip->mdl_min );
		VMOVE( rtip->rti_CutHead.bn.bn_max, rtip->mdl_max );
		rtip->rti_CutHead.bn.bn_len = 0;
		rtip->rti_CutHead.bn.bn_maxlen = rtip->nsolids+1;
		rtip->rti_CutHead.bn.bn_list = (struct soltab **)rt_malloc(
			rtip->rti_CutHead.bn.bn_maxlen * sizeof(struct soltab *),
			"rt_cut_it: root list" );
		RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
			/* Ignore "dead" solids in the list.  (They failed prep) */
			if( stp->st_aradius <= 0 )  continue;
			if( stp->st_aradius < INFINITY )  {
				rt_cut_extend( &rtip->rti_CutHead, stp );
a595 12
		} RT_VISIT_ALL_SOLTABS_END
		rt_ct_optim( rtip, &rtip->rti_CutHead, 0 );
#if 0
	} else {
		/* New way, mostly parallel */
		union cutter	*head;
		int	i;

		head = rt_cut_one_axis( &rtip->rti_cuts_waiting, rtip,
			Y, 0, rt_nu_cells_per_axis[Y]-1 );
		rtip->rti_CutHead = *head;	/* struct copy */
		rt_free( (char *)head, "union cutter" );
d597 5
a601 4
		if(rt_g.debug&DEBUG_CUTDETAIL)  {
			for( i=0; i<3; i++ )  {
				bu_log("\nNUgrid %c axis:  %d cells\n",
					"XYZ*"[i], rt_nu_cells_per_axis[i] );
a602 1
			rt_pr_cut( &rtip->rti_CutHead, 0 );
d604 1
d606 14
a619 5
		rt_cut_rtip = rtip;
		if( ncpu <= 1 )  {
			rt_cut_optimize_parallel(rtip);
		} else {
			bu_parallel( rt_cut_optimize_parallel, ncpu );
a620 2
	}
#endif
d622 12
a633 22
	/* Measure the depth of tree, find max # of RPPs in a cut node */
	bu_hist_init( &rtip->rti_hist_cellsize, 0.0, 399.0, 400 );
	bu_hist_init( &rtip->rti_hist_cutdepth, 0.0, (fastf_t)rt_cutDepth+1, 400 );
	rt_ct_measure( rtip, &rtip->rti_CutHead, 0 );
	rt_ct_measure( rtip, &rtip->rti_inf_box, 0 );
	if(rt_g.debug&DEBUG_CUT)  {
		bu_log("Cut: maxdepth=%d, nbins=%d, maxlen=%d, avg=%g\n",
		rtip->rti_cut_maxdepth,
		rtip->rti_cut_nbins,
		rtip->rti_cut_maxlen,
		((double)rtip->rti_cut_totobj)/rtip->rti_cut_nbins );
		bu_hist_pr( &rtip->rti_hist_cellsize, "cut_tree: Number of solids per leaf cell");
		bu_hist_pr( &rtip->rti_hist_cutdepth, "cut_tree: Depth (height)"); 
	}

	if( rt_g.debug&DEBUG_PLOTBOX )  {
		/* Debugging code to plot cuts */
		if( (plotfp=fopen("rtcut.plot", "w"))!=NULL) {
			pdv_3space( plotfp, rtip->rti_pmin, rtip->rti_pmax );
			/* Plot all the cutting boxes */
			rt_plot_cut( plotfp, rtip, &rtip->rti_CutHead, 0 );
			(void)fclose(plotfp);
a634 4
	}
	if(rt_g.debug&DEBUG_CUTDETAIL)  {
		/* Produce a voluminous listing of the cut tree */
		rt_pr_cut( &rtip->rti_CutHead, 0 );
@


11.13
log
@NUgrid fixes
@
text
@d1 1
a1 1
#define NUgrid 0
d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.12 1996/09/27 08:27:30 mike Exp gdurf $ (BRL)";
d495 10
a528 2
#if !NUgrid		  

a624 1
#endif	
a626 3
	for( i=0; i<3; i++ )  {
		rt_free( (char *)rt_nu_axis[i], "NUgrid axis" );
	}
@


11.12
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.11 1996/09/24 05:15:13 mike Exp mike $ (BRL)";
d227 3
d233 2
a234 1
	int	i;
d342 1
a342 1
		int	pos;		/* Current interval start pos */
d396 1
a396 1
	bu_hist_init( &nu_hist_cellsize, 0.0, 399.0, 400 );
d519 2
d617 1
@


11.11
log
@"clean" command can be given before any frames are actually prepped.
More protection was required.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.10 1996/08/31 04:20:54 mike Exp mike $ (BRL)";
d131 1
a131 1
	NMG_CK_PTBL(boxes);
d201 1
a201 1
		cp = (union cutter *)NMG_TBL_GET( &rtip->rti_cuts_waiting, i );
d222 5
a226 5
	struct histogram xhist;
	struct histogram yhist;
	struct histogram zhist;
	struct histogram start_hist[3];	/* where solid RPPs start */
	struct histogram end_hist[3];	/* where solid RPPs end */
d273 1
a273 1
if(rt_g.debug&DEBUG_CUT)  rt_log("\nnu_ncells=%d, nu_sol_per_cell=%d, nu_max_ncells=%d\n", nu_ncells, nu_sol_per_cell, nu_max_ncells );
d275 1
a275 1
		rt_hist_init( &start_hist[i],
d279 1
a279 1
		rt_hist_init( &end_hist[i],
d285 3
a287 3
	rt_hist_init( &xhist, rtip->rti_pmin[X], rtip->rti_pmax[X], RT_NUGRID_NBINS );
	rt_hist_init( &yhist, rtip->rti_pmin[Y], rtip->rti_pmax[Y], RT_NUGRID_NBINS );
	rt_hist_init( &zhist, rtip->rti_pmin[Z], rtip->rti_pmax[Z], RT_NUGRID_NBINS );
d292 1
a292 1
		rt_hist_range( &xhist,
d294 1
a294 1
		rt_hist_range( &yhist,
d296 1
a296 1
		rt_hist_range( &zhist,
d299 1
a299 1
			RT_HISTOGRAM_TALLY( &start_hist[i],
d301 1
a301 1
			RT_HISTOGRAM_TALLY( &end_hist[i],
d307 3
a309 3
		rt_hist_pr( &xhist, "cut_tree:  solid RPP extent distribution in X" );
		rt_hist_pr( &yhist, "cut_tree:  solid RPP extent distribution in Y" );
		rt_hist_pr( &zhist, "cut_tree:  solid RPP extent distribution in Z" );
d313 1
a313 1
			rt_hist_pr( &start_hist[i], obuf );
d316 1
a316 1
			rt_hist_pr( &end_hist[i], obuf );
d341 2
a342 2
		struct histogram	*shp = &start_hist[i];
		struct histogram	*ehp = &end_hist[i];
d363 1
a363 1
				rt_log("NUgrid ran off end, axis=%d, axi=%d\n",
d381 1
a381 1
		rt_log("NUgrid %c axis:  %d cells\n",
d384 1
a384 1
			rt_log("  %g .. %g, w=%g\n",
d392 1
a392 1
	rt_hist_init( &nu_hist_cellsize, 0.0, 399.0, 400 );
d472 1
a472 1
				RT_HISTOGRAM_TALLY( &nu_hist_cellsize,
d495 1
a495 1
		rt_hist_pr( &nu_hist_cellsize, "cut_tree: Number of solids per NUgrid cell");
d526 1
a526 1
	if(rt_g.debug&DEBUG_CUT) rt_log("Cut: Tree Depth=%d, Leaf Len=%d\n", rt_cutDepth, rt_cutLen );
d568 1
a568 1
				rt_log("\nNUgrid %c axis:  %d cells\n",
d578 1
a578 1
			rt_parallel( rt_cut_optimize_parallel, ncpu );
d584 2
a585 2
	rt_hist_init( &rtip->rti_hist_cellsize, 0.0, 399.0, 400 );
	rt_hist_init( &rtip->rti_hist_cutdepth, 0.0, (fastf_t)rt_cutDepth+1, 400 );
d589 1
a589 1
		rt_log("Cut: maxdepth=%d, nbins=%d, maxlen=%d, avg=%g\n",
d594 2
a595 2
		rt_hist_pr( &rtip->rti_hist_cellsize, "cut_tree: Number of solids per leaf cell");
		rt_hist_pr( &rtip->rti_hist_cutdepth, "cut_tree: Depth (height)"); 
d616 3
a618 3
	rt_hist_free( &xhist );
	rt_hist_free( &yhist );
	rt_hist_free( &zhist );
d620 2
a621 2
		rt_hist_free( &start_hist[i] );
		rt_hist_free( &end_hist[i] );
d640 1
a640 1
	if(rt_g.debug&DEBUG_CUTDETAIL)rt_log("rt_ct_add(x%x, %s, %d)\n",
d659 1
a659 1
		rt_log("rt_ct_add:  node type =x%x\n",cutp->cut_type);
d884 1
a884 1
		rt_log("rt_ct_box(x%x, %c) %g .. %g .. %g\n",
d933 1
a933 1
			rt_log("rt_ct_box:  no luck, len=%d\n",
d974 1
a974 1
		rt_log("rt_ck_overlap(%s)\n",stp->st_name);
d984 1
a984 1
		if( rt_g.debug&DEBUG_BOXING )  rt_log("rt_ck_overlap:  TRUE (inf)\n");
d991 1
a991 1
	if( rt_g.debug&DEBUG_BOXING )  rt_log("rt_ck_overlap:  TRUE\n");
d994 1
a994 1
	if( rt_g.debug&DEBUG_BOXING )  rt_log("rt_ck_overlap:  FALSE\n");
d1020 1
a1020 1
		rt_log("rt_ct_optim: bad node x%x\n", cutp->cut_type);
d1099 1
a1099 1
	if(rt_g.debug&DEBUG_CUTDETAIL)rt_log("rt_ct_old_assess(x%x, %c)\n",cutp,"XYZ345"[axis]);
d1162 1
a1162 1
		bytes = rt_byte_roundup(64*sizeof(union cutter));
d1210 1
a1210 1
	rt_log("%.8x ", cutp);
d1212 1
a1212 1
		rt_log("   ");
d1215 1
a1215 1
		rt_log("Null???\n");
d1222 1
a1222 1
		rt_log("CUT L %c < %f\n",
d1227 1
a1227 1
		rt_log("%.8x ", cutp);
d1229 2
a1230 2
			rt_log("   ");
		rt_log("CUT R %c >= %f\n",
d1237 1
a1237 1
		rt_log("BOX Contains %d solids (%d alloc):\n",
d1239 1
a1239 1
		rt_log("        ");
d1241 1
a1241 1
			rt_log("   ");
d1243 1
a1243 1
		rt_log("        ");
d1245 1
a1245 1
			rt_log("   ");
d1249 1
a1249 1
			rt_log("        ");
d1251 2
a1252 2
				rt_log("   ");
			rt_log("    %s\n",
d1258 1
a1258 1
		rt_log("Unknown type=x%x\n", cutp->cut_type );
d1278 1
a1278 1
		rt_log("rt_fr_cut NULL\n");
d1300 1
a1300 1
		rt_log("rt_fr_cut: Unknown type=x%x\n", cutp->cut_type );
d1434 1
a1434 1
		rt_log("rt_ct_measure: bad node x%x\n", cutp->cut_type);
d1447 2
a1448 2
	RT_HISTOGRAM_TALLY( &rtip->rti_hist_cellsize, len );
	RT_HISTOGRAM_TALLY( &rtip->rti_hist_cutdepth, depth ); 
@


11.10
log
@Changed calling sequence to bu_ptbl_init() to have reason string
for bu_malloc() tracking
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.9 1996/08/31 02:19:01 mike Exp mike $ (BRL)";
d1458 2
d1474 3
@


11.9
log
@Moved CutFree into rt_i structure
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.8 1996/08/28 10:01:26 mike Exp mike $ (BRL)";
d515 1
a515 1
	bu_ptbl_init( &rtip->rti_cuts_waiting, rtip->nsolids );
d1157 1
a1157 1
		bu_ptbl_init( &rtip->rti_busy_cutter_nodes, 128 );
@


11.8
log
@Added code to collect up list of "union cutter" structs in
a bu_ptbl, and then release them at the end.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.7 1996/07/12 18:08:12 jra Exp mike $ (BRL)";
d39 14
a52 4
HIDDEN int	rt_ck_overlap(), rt_ct_box();
HIDDEN void	rt_ct_add(), rt_ct_optim(), rt_ct_free();
HIDDEN void	rt_ct_measure();
HIDDEN union cutter *rt_ct_get();
d54 1
a56 2
HIDDEN void rt_plot_cut();

a69 4
static struct bu_ptbl	rt_waiting_nodes;	/* parallel work queue */

static struct bu_ptbl	rt_busy_cutter_nodes;

d178 1
a178 1
 *  Process all the nodes in the global array rt_waiting_nodes,
d182 2
d187 1
d191 1
d195 1
a195 1
		i = rt_waiting_nodes.end--;	/* get first free index */
d201 1
a201 1
		cp = (union cutter *)NMG_TBL_GET( &rt_waiting_nodes, i );
d203 1
a203 1
		rt_ct_optim( cp, Z );
d515 1
a515 1
	bu_ptbl_init( &rt_waiting_nodes, rtip->nsolids );
d554 1
a554 1
		rt_ct_optim( &rtip->rti_CutHead, 0 );
d561 1
a561 1
		head = rt_cut_one_axis( &rt_waiting_nodes, rtip,
d574 1
d576 1
a576 1
			rt_cut_optimize_parallel();
d716 2
a717 1
rt_ct_plan( cutp, depth )
d728 1
d754 1
a754 1
		if( rt_ct_box( cutp, best, where[best] ) > 0 )
d873 2
a874 1
rt_ct_box( cutp, axis, where )
d882 1
d892 1
a892 1
	lhs = rt_ct_get();
d910 1
a910 1
	rhs = rt_ct_get();
d938 2
a939 2
		rt_ct_free( rhs );
		rt_ct_free( lhs );
d1008 2
a1009 1
rt_ct_optim( cutp, depth )
d1015 2
a1016 2
		rt_ct_optim( cutp->cn.cn_l, depth+1 );
		rt_ct_optim( cutp->cn.cn_r, depth+1 );
d1039 1
a1039 1
	if( rt_ct_plan( cutp, depth ) < 0 )  {
d1062 1
a1062 1
	if( rt_ct_box( cutp, axis, where ) == 0 )  {
d1065 1
a1065 1
		if( rt_ct_box( cutp, AXIS(depth+1), where ) == 0 )
d1073 2
a1074 2
	rt_ct_optim( cutp->cn.cn_l, depth+1 );
	rt_ct_optim( cutp->cn.cn_r, depth+1 );
d1145 2
d1149 2
a1150 1
rt_ct_get()
d1154 4
a1157 2
	if( !rt_busy_cutter_nodes.l.magic )
		bu_ptbl_init( &rt_busy_cutter_nodes, 128 );
d1159 1
a1159 1
	if( rt_g.rtg_CutFree == CUTTER_NULL )  {
d1165 1
a1165 1
		bu_ptbl_ins( &rt_busy_cutter_nodes, (long *)cutp );
d1168 2
a1169 2
			cutp->cut_forw = rt_g.rtg_CutFree;
			rt_g.rtg_CutFree = cutp++;
d1173 4
a1176 2
	cutp = rt_g.rtg_CutFree;
	rt_g.rtg_CutFree = cutp->cut_forw;
d1183 2
d1187 3
a1189 2
rt_ct_free( cutp )
register union cutter *cutp;
d1191 5
a1195 2
	cutp->cut_forw = rt_g.rtg_CutFree;
	rt_g.rtg_CutFree = cutp;
d1272 2
a1273 1
rt_fr_cut( cutp )
d1276 1
a1276 1

d1285 2
a1286 2
		rt_fr_cut( cutp->cn.cn_l );
		rt_ct_free( cutp->cn.cn_l );
d1289 2
a1290 2
		rt_fr_cut( cutp->cn.cn_r );
		rt_ct_free( cutp->cn.cn_r );
d1316 1
d1427 1
d1455 1
a1455 1
 *  The rt_g.rtg_CutFree list can not be freed directly
d1460 2
a1461 1
rt_cut_clean()
d1465 1
a1465 2
	if( rt_waiting_nodes.l.magic )
		bu_ptbl_free( &rt_waiting_nodes );
d1467 3
d1471 1
a1471 1
	rt_g.rtg_CutFree = CUTTER_NULL;
d1474 1
a1474 1
	for( BU_PTBL_FOR( p, (genptr_t *), &rt_busy_cutter_nodes ) )  {
d1477 1
a1477 1
	bu_ptbl_free( &rt_busy_cutter_nodes );
a1478 1

@


11.7
log
@rt_waiting_nodes needed initialization for IRIX 6.2
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.6 1995/11/07 20:24:17 adam Exp $ (BRL)";
d61 1
a61 3
static struct nmg_ptbl	rt_waiting_nodes={
	0,0,0,(long**)0
};	/* parallel work queue */
d63 2
d108 1
a108 1
 *  The nmg_ptbl "boxes" contains a list of the boxnodes, for convenience.
d114 1
a114 1
struct nmg_ptbl	*boxes;
d154 1
a154 1
		nmg_tbl( boxes, TBL_INS, (long *)box );
d506 1
a506 1
	nmg_tbl( &rt_waiting_nodes, TBL_INIT, 0 );
d1136 3
d1144 3
d1424 3
a1426 3
 * rt_g.rtg_CutFree list could be freed, but is bulk allocated, XXX
 * so cutter structures will hang around.  XXX
 *
d1431 13
a1443 2
	if( rt_waiting_nodes.magic )
		nmg_tbl( &rt_waiting_nodes, TBL_FREE, 0 );
@


11.6
log
@Matching malloc and free messages -- rt_ct_box...
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.5 1995/10/31 22:31:25 mike Exp adam $ (BRL)";
d61 3
a63 1
static struct nmg_ptbl	rt_waiting_nodes;	/* parallel work queue */
@


11.5
log
@Don't clobber ptbl if not initialized.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.4 1995/10/31 21:52:39 mike Exp mike $ (BRL)";
d885 1
a885 1
		"rt_ct_box: left list" );
d903 1
a903 1
		"rt_ct_box: right list" );
d928 1
a928 1
	rt_free( (char *)cutp->bn.bn_list, "rt_ct_box:  old list" );
@


11.4
log
@Fixed memory leak reported by Chris Johnson.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.3 1995/03/18 05:47:00 mike Exp mike $ (BRL)";
d1423 2
a1424 1
	nmg_tbl( &rt_waiting_nodes, TBL_FREE, 0 );
@


11.3
log
@The new approach uses too much memory.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.2 95/03/18 04:18:52 mike Exp Locker: mike $ (BRL)";
d1412 14
@


11.2
log
@Added rt_cut_one_axis() and rt_cut_optimize_parallel().
They only get used when there are more than 50,000 solids.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 11.1 95/01/04 09:56:12 mike Rel4_4 $ (BRL)";
d517 1
d519 1
d544 1
d569 1
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 10.7 94/12/27 18:42:47 mike Exp $ (BRL)";
d33 1
d61 2
d64 133
d205 3
a207 2
rt_cut_it(rtip)
register struct rt_i *rtip;
a210 1
/* Begin NUgrid */
a220 19
	rtip->rti_CutHead.bn.bn_type = CUT_BOXNODE;
	VMOVE( rtip->rti_CutHead.bn.bn_min, rtip->mdl_min );
	VMOVE( rtip->rti_CutHead.bn.bn_max, rtip->mdl_max );
	rtip->rti_CutHead.bn.bn_len = 0;
	rtip->rti_CutHead.bn.bn_maxlen = rtip->nsolids+1;
	rtip->rti_CutHead.bn.bn_list = (struct soltab **)rt_malloc(
		rtip->rti_CutHead.bn.bn_maxlen * sizeof(struct soltab *),
		"rt_cut_it: root list" );
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		/* Ignore "dead" solids in the list.  (They failed prep) */
		if( stp->st_aradius <= 0 )  continue;
		if( stp->st_aradius >= INFINITY )  {
			/* Add to infinite solids list for special handling */
			rt_cut_extend( &rtip->rti_inf_box, stp );
		} else {
			rt_cut_extend( &rtip->rti_CutHead, stp );
		}
	} RT_VISIT_ALL_SOLTABS_END

d370 1
a370 1
		rt_log("\nNUgrid %c axis:  %d cells\n",
d494 9
a502 3
	for( i=0; i<3; i++ )  {
		rt_free( (char *)rt_nu_axis[i], "NUgrid axis" );
	}
d504 1
a504 8
	/*  Finished with histogram data structures */
	rt_hist_free( &xhist );
	rt_hist_free( &yhist );
	rt_hist_free( &zhist );
	for( i=0; i<3; i++ )  {
		rt_hist_free( &start_hist[i] );
		rt_hist_free( &end_hist[i] );
	}
a515 1
	rt_ct_optim( &rtip->rti_CutHead, 0 );
d517 50
d594 12
@


10.7
log
@nu_grid to rt_nu_grid
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 10.6 94/12/27 16:29:16 mike Exp Locker: mike $ (BRL)";
@


10.6
log
@added rt_ prefix to NUgrid variables
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 10.5 94/12/19 15:51:24 jra Exp Locker: mike $ (BRL)";
d57 1
a57 1
union cutter	*nu_grid;
d266 1
a266 1
	nu_grid = (union cutter *)rt_malloc(
d324 1
a324 1
					RT_NUGRID_CELL(nu_grid, xp, yp, zp);
d369 1
a369 1
		rt_pr_cut( nu_grid, 0 );
@


10.5
log
@fixed calls to rt_hist_init to satisfy CRAY.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/cut.c,v 10.4 94/10/31 21:56:25 mike Exp Locker: jra $ (BRL)";
d49 1
a49 1
	((((_z)*nu_cells_per_axis[Y])+(_y))*nu_cells_per_axis[X])+(_x) ])
d55 2
a56 2
struct nu_axis	*nu_axis[3];
int		nu_cells_per_axis[3];
d193 1
a193 1
		nu_axis[i] = (struct nu_axis *)rt_calloc( nu_max_ncells,
d217 1
a217 1
		int	axi = 0;	/* nu_axis index */
d221 1
a221 1
		nu_axis[i][axi].nu_spos = pos;
d232 2
a233 2
			nu_axis[i][axi].nu_epos = pos;
			nu_axis[i][axi].nu_width = pos - nu_axis[i][axi].nu_spos;
d240 1
a240 1
			nu_axis[i][++axi].nu_spos = pos;
d245 3
a247 3
		nu_axis[i][axi].nu_epos = pos;
		nu_axis[i][axi].nu_width = pos - nu_axis[i][axi].nu_spos;
		nu_cells_per_axis[i] = axi+1;
d254 2
a255 2
			"XYZ*"[i], nu_cells_per_axis[i] );
		for( j=0; j<nu_cells_per_axis[i]; j++ )  {
d257 3
a259 3
				nu_axis[i][j].nu_spos,
				nu_axis[i][j].nu_epos,
				nu_axis[i][j].nu_width );
d267 2
a268 2
		nu_cells_per_axis[X] * nu_cells_per_axis[Y] *
		nu_cells_per_axis[Z] * sizeof(union cutter),
d286 1
a286 1
	for( xp = 0; xp < nu_cells_per_axis[X]; xp++ )  {
d289 2
a290 2
		xmin[X] = nu_axis[X][xp].nu_spos;
		xmax[X] = nu_axis[X][xp].nu_epos;
d304 1
a304 1
		for( yp = 0; yp < nu_cells_per_axis[Y]; yp++ )  {
d307 2
a308 2
			ymin[Y] = nu_axis[Y][yp].nu_spos;
			ymax[Y] = nu_axis[Y][yp].nu_epos;
d322 1
a322 1
			for( zp = 0; zp < nu_cells_per_axis[Z]; zp++ )  {
d327 2
a328 2
				zmin[Z] = nu_axis[Z][zp].nu_spos;
				zmax[Z] = nu_axis[Z][zp].nu_epos;
d378 1
a378 1
		rt_free( (char *)nu_axis[i], "NUgrid axis" );
@


10.4
log
@Changed hg_min and hg_max from int to fastf_t.
Fixed bug #155.

@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 10.3 94/10/18 02:08:27 mike Exp Locker: mike $ (BRL)";
d264 1
a264 1
	rt_hist_init( &nu_hist_cellsize, 0, 399, 400 );
d403 2
a404 2
	rt_hist_init( &rtip->rti_hist_cellsize, 0, 399, 400 );
	rt_hist_init( &rtip->rti_hist_cutdepth, 0, rt_cutDepth+1, 400 );
@


10.3
log
@Fixed minor memory leak -- needed to free histogram bins and axis arrays.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 10.2 94/08/10 15:40:13 gdurf Exp Locker: mike $ (BRL)";
d148 2
a149 2
			(int)rtip->rti_pmin[i],
			(int)rtip->rti_pmax[i],
d152 2
a153 2
			(int)rtip->rti_pmin[i],
			(int)rtip->rti_pmax[i],
d157 3
a159 3
	rt_hist_init( &xhist, (int)rtip->rti_pmin[X], (int)rtip->rti_pmax[X], RT_NUGRID_NBINS );
	rt_hist_init( &yhist, (int)rtip->rti_pmin[Y], (int)rtip->rti_pmax[Y], RT_NUGRID_NBINS );
	rt_hist_init( &zhist, (int)rtip->rti_pmin[Z], (int)rtip->rti_pmax[Z], RT_NUGRID_NBINS );
d165 1
a165 1
			(int)stp->st_min[X], (int)stp->st_max[X] );
d167 1
a167 1
			(int)stp->st_min[Y], (int)stp->st_max[Y] );
d169 1
a169 1
			(int)stp->st_min[Z], (int)stp->st_max[Z] );
d172 1
a172 1
				(int)stp->st_min[i] );
d174 1
a174 1
				(int)stp->st_max[i] );
@


10.2
log
@Added include of conf.h
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 10.1 1991/10/12 06:39:58 mike Rel4_0 gdurf $ (BRL)";
d372 10
a381 1
	/*  Finished with NUgrid data structures */
a388 4
	rt_free( (char *)nu_xbox.bn_list, "nu_xbox bn_list[]" );
	rt_free( (char *)nu_ybox.bn_list, "nu_ybox bn_list[]" );
	rt_free( (char *)nu_zbox.bn_list, "nu_zbox bn_list[]" );
#endif	/* NUgrid */
@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 9.24 91/09/20 22:37:47 butler Exp $ (BRL)";
d25 2
@


9.24
log
@removing the fuzz with lint
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 9.23 91/06/30 23:17:56 mike Exp $ (BRL)";
@


9.23
log
@Changed from rti_headsolid list for all soltab structures,
to RT_DBNHASH different lists, rti_solidheads[].
This permits much faster searching in the parallel treewalking stage.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 9.22 91/06/30 20:14:02 mike Exp $ (BRL)";
a80 8
	struct boxnode	nu_xbox;
	struct boxnode	nu_ybox;
	struct boxnode	nu_zbox;
	vect_t		xmin, xmax;	/* bounds of x slice */
	vect_t		ymin, ymax;	/* bounds of y slice of x slice */
	vect_t		zmin, zmax;	/* bounds of z slice of y of x */
	struct histogram nu_hist_cellsize;
	int		xp, yp, zp;
d214 1
a214 1
		int	epos;
a525 1
	int	i;
@


9.22
log
@rt_ck_overlap() consumes lots of CPU time.
Minor attempt to improve performance with a CONST declaration.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 9.21 91/06/30 19:07:22 mike Exp $ (BRL)";
d99 1
a99 1
	for( RT_LIST( stp, soltab, &(rtip->rti_headsolid) ) )  {
d108 1
a108 1
	}
d166 1
a166 1
	for( RT_LIST( stp, soltab, &(rtip->rti_headsolid) ) )  {
d182 1
a182 1
	}
d300 1
d302 1
a302 1
		for( RT_LIST( stp, soltab, &(rtip->rti_headsolid) ) )  {
d307 2
a308 1
		}
@


9.21
log
@As a result of changes needed for parallel prepping,
it is now possible to encounter "dead" solids (i.e., those that failed
prepping) in the rti_headsolid list.
They are marked by a negative st_aradius, and are easily skipped.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 9.20 91/06/29 21:40:41 mike Exp $ (BRL)";
d771 3
a773 2
register vect_t min, max;
register struct soltab *stp;
@


9.20
log
@ANSI lint
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 9.19 91/06/24 23:44:28 mike Exp $ (BRL)";
d100 2
d167 2
d782 2
@


9.19
log
@NUgrid turned off.  Newer than Release 3.7 space cutting turned off,
to get back up to Release 3.7 performance.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 9.18 91/06/24 22:58:29 mike Exp $ (BRL)";
d981 1
a981 1
register union cutter *cutp;
@


9.18
log
@NUgrid and other experimental stuff turned off, to revert to
Release 3.7 performance levels.
@
text
@d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 9.17 90/12/22 02:23:36 mike Exp $ (BRL)";
a370 1
#endif
d383 1
@


9.17
log
@Added nu_epos
@
text
@d1 1
d23 1
a23 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 9.16 90/12/19 06:19:29 mike Exp $ (BRL)";
d265 1
a265 1
#if 1
d829 1
a829 1
#if 1
@


9.16
log
@Made NUgrid variables global.
Once it is working, they will move to rt_g.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 9.15 90/12/18 20:42:56 mike Exp $ (BRL)";
d48 2
a49 1
	fastf_t	nu_pos;		/* cell start pos */
d222 1
a222 1
		nu_axis[i][axi].nu_pos = pos;
d233 2
a234 1
			nu_axis[i][axi].nu_width = pos - nu_axis[i][axi].nu_pos;
d241 1
a241 1
			nu_axis[i][++axi].nu_pos = pos;
d246 2
a247 1
		nu_axis[i][axi].nu_width = pos - nu_axis[i][axi].nu_pos;
d257 3
a259 2
			rt_log("  %g, w=%g\n",
				nu_axis[i][j].nu_pos,
d290 2
a291 2
		xmin[X] = nu_axis[X][xp].nu_pos;
		xmax[X] = xmin[X] + nu_axis[X][xp].nu_width;
d306 2
a307 2
			ymin[Y] = nu_axis[Y][yp].nu_pos;
			ymax[Y] = ymin[Y] + nu_axis[Y][yp].nu_width;
d326 2
a327 2
				zmin[Z] = nu_axis[Z][zp].nu_pos;
				zmax[Z] = zmin[Z] + nu_axis[Z][zp].nu_width;
@


9.15
log
@Has all initial NUgrid initialization.
Not packaged usefully yet.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 9.14 90/12/18 05:43:09 mike Exp $ (BRL)";
d44 12
a77 6
	struct nu_axis {
		fastf_t	nu_pos;		/* cell start pos */
		fastf_t	nu_width;	/* voxel size */
	};
	struct nu_axis	*nu_axis[3];
	int	nu_cells_per_axis[3];
a78 1
	union cutter	*nu_grid;
d318 2
a319 4
				register union cutter *cutp = &nu_grid[
					(((zp*nu_cells_per_axis[Z]) +
					   yp*nu_cells_per_axis[Y]) +
					   zp*nu_cells_per_axis[X])];
@


9.14
log
@Beginnings of NUgrid support
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 9.13 90/12/18 00:14:36 mike Exp $ (BRL)";
d58 1
d73 9
d255 4
a258 8
#if 0
	struct boxnode	*nu_grid;
	struct boxnode	nu_xbox;
	struct boxnode	nu_ybox;
	vect_t		xmin, xmax;	/* bounds of x slice */
	vect_t		ymin, ymax;	/* bounds of y slice of x slice */
	/* For the moment, re-use "struct boxnode" */
	nu_grid = (struct boxnode *)rt_malloc(
d260 2
a261 1
		nu_cells_per_axis[Z], "3-D NUgrid array" );
d272 6
d285 1
d288 18
a305 5
			if( stp->st_aradius >= INFINITY )  {
				/* Infinite solid */
				nu_xbox.bn_list[nu_xbox.bn_len++] = stp;
			} else {
				if( !rt_ck_overlap( xmin, xmax, stp ) )
d307 2
a308 1
				nu_xbox.bn_list[nu_xbox.bn_len++] = stp;
d310 46
d358 5
d373 3
d390 2
a391 2
	rt_hist_init( &rtip->rti_hist_cellsize, 0, 99, 100 );
	rt_hist_init( &rtip->rti_hist_cutdepth, 0, rt_cutDepth+1, 100 );
d762 1
d769 5
@


9.13
log
@Change of variables, to make old code look more like new code,
to emphasize actual differences.
Still configured to use old (Rel 3.7 style) space partitioning.
It is unclear which minor variation caused the massive loss of performance.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/cut.c,v 9.12 90/12/15 04:54:10 mike Exp $ (BRL)";
d61 12
d117 10
a126 1
	 *  XXX For small or huge models, needs a floating-point histogram.
d128 16
a143 1
#define	RT_NUGRID_NBINS	120
d149 12
a160 3
		rt_hist_range( &xhist, (int)stp->st_min[X], (int)stp->st_max[X] );
		rt_hist_range( &yhist, (int)stp->st_min[Y], (int)stp->st_max[Y] );
		rt_hist_range( &zhist, (int)stp->st_min[Z], (int)stp->st_max[Z] );
d163 1
d167 8
d176 111
d290 4
@


9.12
log
@Restored (good) behavior achieved in Release 3.7.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/cut.c,v 9.11 90/12/15 03:12:42 mike Exp $ (BRL)";
d272 2
d276 5
d286 1
a286 2
		for( i = X; i <= Z; i++ )  {
			axis = (depth + i) % 3;
d564 1
a564 1
#if 0
d621 7
a627 5
	auto double d_close;		/* Closest distance from midpoint */
	auto double pt_close;		/* Point closest to midpoint */
	auto double middle;		/* midpoint */
	auto double d;
	register int i;
d632 1
a632 1
	if( cutp->bn.bn_max[axis]-cutp->bn.bn_min[axis] < 2.0 )
d642 3
a644 3
	pt_close = cutp->bn.bn_min[axis];
	middle = (pt_close + cutp->bn.bn_max[axis]) * 0.5;
	d_close = middle - pt_close;
d646 2
a647 1
		d = cutp->bn.bn_list[i]->st_min[axis] - middle;
d649 3
a651 3
		if( d < d_close )  {
			d_close = d;
			pt_close = cutp->bn.bn_list[i]->st_min[axis]-0.1;
d653 2
a654 1
		d = cutp->bn.bn_list[i]->st_max[axis] - middle;
d656 3
a658 3
		if( d < d_close )  {
			d_close = d;
			pt_close = cutp->bn.bn_list[i]->st_max[axis]+0.1;
d661 1
a661 2
	if( pt_close <= cutp->bn.bn_min[axis] ||
	    pt_close >= cutp->bn.bn_max[axis] )
d664 1
a664 2
	if( pt_close - cutp->bn.bn_min[axis] <= 1.0 ||
	    cutp->bn.bn_max[axis] - pt_close <= 1.0 )
d668 2
a669 2
	*where_p = pt_close;
	*offcenter_p = d_close;
@


9.11
log
@Added NUgrid style histograms of solid RPP extent distribution
in X, Y, and Z axes.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/cut.c,v 9.10 90/12/14 20:24:20 mike Exp $ (BRL)";
a307 1
 *	1 if box cut and cutp has become a CUT_CUTNODE;
d558 2
d567 29
a595 1

d599 64
@


9.10
log
@removed rti_pconv
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/cut.c,v 9.9 90/10/07 21:38:14 mike Exp $ (BRL)";
d58 3
d78 48
a150 22
	}

	/* For plotting, build slightly enlarged model RPP, to
	 * allow rays clipped to the model RPP to be depicted,
	 * and compute a scale factor for using 4096 units.
	 * Always do this, because application debugging uses it too.
	 */
	{
		register fastf_t f, diff;

		diff = (rtip->mdl_max[X] - rtip->mdl_min[X]);
		f = (rtip->mdl_max[Y] - rtip->mdl_min[Y]);
		if( f > diff )  diff = f;
		f = (rtip->mdl_max[Z] - rtip->mdl_min[Z]);
		if( f > diff )  diff = f;
		diff *= 0.1;	/* 10% expansion of box */
		rtip->rti_pmin[0] = rtip->mdl_min[0] - diff;
		rtip->rti_pmin[1] = rtip->mdl_min[1] - diff;
		rtip->rti_pmin[2] = rtip->mdl_min[2] - diff;
		rtip->rti_pmax[0] = rtip->mdl_max[0] + diff;
		rtip->rti_pmax[1] = rtip->mdl_max[1] + diff;
		rtip->rti_pmax[2] = rtip->mdl_max[2] + diff;
@


9.9
log
@soltab structure changed to use struct rt_list.
HeadSolid became rti_headsolid.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 9.8 90/05/21 14:22:00 mike Exp $ (BRL)";
a121 11

		/* These calcuations no longer needed, kept for compat. */
#define PL_MIN	(-32767L)
#define PL_MAX	 (32767L)
#define PL_DIFF	(PL_MAX-PL_MIN)
		diff = PL_DIFF / (rtip->rti_pmax[X] - rtip->rti_pmin[X]);
		f = PL_DIFF / (rtip->rti_pmax[Y] - rtip->rti_pmin[Y]);
		if( f < diff )  diff = f;
		f = PL_DIFF / (rtip->rti_pmax[Z] - rtip->rti_pmin[Z]);
		if( f < diff )  diff = f;
		rtip->rti_pconv = diff;
@


9.8
log
@lint
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: /m/cad/librt/RCS/cut.c,v 9.7 90/04/27 02:14:39 mike Exp $ (BRL)";
d67 1
a67 1
	for(stp=rtip->HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw)  {
@


9.7
log
@Infinite solids are enlisted in rti_inf_box in rt_cut_it() now,
rather than in the tree walker, where it didn't belong.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: cut.c,v 9.6 90/01/11 07:25:29 mike Locked $ (BRL)";
a302 1
	register struct boxnode *bp;
a303 1
	register double	dist;
d483 1
a483 1
int
d725 1
a725 1
 *			R T _ V C L I P
d727 1
a727 1
 *  Clip a ray against a rectangular parallelpiped (RPP)
d739 4
a742 3
static int
rt_vclip( a, b, min, max )
vect_t a, b;
d745 1
a745 1
	static vect_t diff;
@


9.6
log
@Rotor around preferred plane based on depth.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: cut.c,v 9.5 90/01/06 01:22:59 mike Locked $ (BRL)";
d68 5
a72 6
		if( stp->st_aradius >= INFINITY )
			continue;
		rtip->rti_CutHead.bn.bn_list[rtip->rti_CutHead.bn.bn_len++] = stp;
		if( rtip->rti_CutHead.bn.bn_len > rtip->rti_CutHead.bn.bn_maxlen )  {
			rt_log("rt_cut_it:  rtip->nsolids wrong, dropping solids\n");
			break;
d211 1
a211 1
				"rt_ct_add: initial list alloc" );
d217 1
a217 1
				"rt_ct_add: list extend" );
d222 1
a222 1
				"rt_ct_add: list extend (old list)");
@


9.5
log
@Overhauled rt_ct_box(), splitting it into different functions
to plan, assess, and perform the cut operation.
This now forms a solid groundwork for additional improvements.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: cut.c,v 9.4 90/01/05 19:09:49 mike Locked $ (BRL)";
d242 1
a242 1
rt_ct_plan( cutp )
d244 1
d252 1
d262 2
a263 1
		for( axis = X; axis <= Z; axis++ )  {
d547 1
a547 1
	if( rt_ct_plan( cutp ) < 0 )  {
@


9.4
log
@More reasonable histogram parameters
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: cut.c,v 9.3 90/01/05 18:52:45 mike Locked $ (BRL)";
d89 1
a89 1
	rt_hist_init( &rtip->rti_hist_cellsize, 0, 100, 100 );
d99 2
a100 2
		rt_hist_pr( &rtip->rti_hist_cellsize, "Cut tree leaf cell size");
		rt_hist_pr( &rtip->rti_hist_cutdepth, "Cut tree depth (height)"); 
a102 2
	if(rt_g.debug&DEBUG_CUTDETAIL) rt_pr_cut( &rtip->rti_CutHead, 0 );

d136 8
a143 8
	if( !(rt_g.debug&DEBUG_PLOTBOX) )  return;

	/* Debugging code to plot cuts */
	if( (plotfp=fopen("rtcut.plot", "w"))!=NULL) {
		pdv_3space( plotfp, rtip->rti_pmin, rtip->rti_pmax );
		/* First, all the cutting boxes */
		rt_plot_cut( plotfp, rtip, &rtip->rti_CutHead, 0 );
		(void)fclose(plotfp);
d145 4
d151 1
d231 55
a285 1
 *			R T _ C T _ B O X
d287 6
a292 5
 *  Cut a box node with a plane, generating a cut node and two box nodes.
 *  NOTE that this routine guarantees that each new box node will
 *  be able to hold at least one more item in it's list.
 *  Returns 1 if box cut and cutp has become a CUT_CUTNODE;
 *  returns 0 if this cut didn't help.
d295 1
a295 1
rt_ct_box( cutp, axis )
d297 3
a299 1
register int axis;
d302 7
a308 6
	auto union cutter oldbox;
	auto double d_close;		/* Closest distance from midpoint */
	auto double pt_close;		/* Point closest to midpoint */
	auto double middle;		/* midpoint */
	auto double d;
	register int i;
d310 1
a310 1
	if(rt_g.debug&DEBUG_CUTDETAIL)rt_log("rt_ct_box(x%x, %c)\n",cutp,"XYZ345"[axis]);
d312 5
a316 2
	/*  In absolute terms, each box must be at least 1mm wide after cut. */
	if( cutp->bn.bn_max[axis]-cutp->bn.bn_min[axis] < 2.0 )
a317 1
	oldbox = *cutp;		/* struct copy */
d325 10
d336 12
a347 9
	pt_close = oldbox.bn.bn_min[axis];
	middle = (pt_close + oldbox.bn.bn_max[axis]) * 0.5;
	d_close = middle - pt_close;
	for( i=0; i < oldbox.bn.bn_len; i++ )  {
		d = oldbox.bn.bn_list[i]->st_min[axis] - middle;
		if( d < 0 )  d = (-d);
		if( d < d_close )  {
			d_close = d;
			pt_close = oldbox.bn.bn_list[i]->st_min[axis]-0.1;
d349 9
a357 5
		d = oldbox.bn.bn_list[i]->st_max[axis] - middle;
		if( d < 0 )  d = (-d);
		if( d < d_close )  {
			d_close = d;
			pt_close = oldbox.bn.bn_list[i]->st_max[axis]+0.1;
d360 3
a362 2
	if( pt_close <= oldbox.bn.bn_min[axis] ||
	    pt_close >= oldbox.bn.bn_max[axis] )
d365 1
a365 2
	if( pt_close - oldbox.bn.bn_min[axis] <= 1.0 ||
	    oldbox.bn.bn_max[axis] - pt_close <= 1.0 )
d368 4
a371 7
	/* We are going to cut -- convert caller's node type */
	if(rt_g.debug&DEBUG_CUTDETAIL)rt_log("rt_ct_box(x%x) [%g,%g,%g]\n",
		cutp,
		oldbox.bn.bn_min[axis], pt_close, oldbox.bn.bn_max[axis]);
	cutp->cut_type = CUT_CUTNODE;
	cutp->cn.cn_axis = axis;
	cutp->cn.cn_point = pt_close;
d373 35
d409 9
a417 10
	cutp->cn.cn_l = rt_ct_get();
	bp = &(cutp->cn.cn_l->bn);
	bp->bn_type = CUT_BOXNODE;
	VMOVE( bp->bn_min, oldbox.bn.bn_min );
	VMOVE( bp->bn_max, oldbox.bn.bn_max );
	bp->bn_max[axis] = cutp->cn.cn_point;
	bp->bn_len = 0;
	bp->bn_maxlen = oldbox.bn.bn_len + 1;
	bp->bn_list = (struct soltab **) rt_malloc(
		sizeof(struct soltab *) * bp->bn_maxlen,
d419 3
a421 2
	for( i=0; i < oldbox.bn.bn_len; i++ )  {
		if( !rt_ck_overlap(bp->bn_min, bp->bn_max, oldbox.bn.bn_list[i]))
d423 1
a423 1
		bp->bn_list[bp->bn_len++] = oldbox.bn.bn_list[i];
d427 9
a435 10
	cutp->cn.cn_r = rt_ct_get();
	bp = &(cutp->cn.cn_r->bn);
	bp->bn_type = CUT_BOXNODE;
	VMOVE( bp->bn_min, oldbox.bn.bn_min );
	VMOVE( bp->bn_max, oldbox.bn.bn_max );
	bp->bn_min[axis] = cutp->cn.cn_point;
	bp->bn_len = 0;
	bp->bn_maxlen = oldbox.bn.bn_len + 1;
	bp->bn_list = (struct soltab **) rt_malloc(
		sizeof(struct soltab *) * bp->bn_maxlen,
d437 3
a439 2
	for( i=0; i < oldbox.bn.bn_len; i++ )  {
		if( !rt_ck_overlap(bp->bn_min, bp->bn_max, oldbox.bn.bn_list[i]))
d441 1
a441 1
		bp->bn_list[bp->bn_len++] = oldbox.bn.bn_list[i];
d443 27
a469 3
	rt_free( (char *)oldbox.bn.bn_list, "rt_ct_box:  old list" );
	oldbox.bn.bn_list = (struct soltab **)0;
	return(1);
d518 1
a518 1
int depth;
a519 2
	register int oldlen;
	register int axis;
d530 1
d532 1
a532 1
	 * BOXNODE
d534 1
a534 1
	if( cutp->bn.bn_len <= 1 )  return;	/* optimal */
d536 1
d542 1
a542 5
	 *  In general, keep subdividing until things don't get any better.
	 *  Really we might want to proceed for 2-3 levels.
	 *
	 *  First, make certain this is a worthwhile cut.
	 *  In absolute terms, each box must be at least 1mm wide after cut.
d544 2
a545 2
	axis = AXIS(depth);
	if( cutp->bn.bn_max[axis]-cutp->bn.bn_min[axis] < 2.0 )
a546 4
	oldlen = cutp->bn.bn_len;	/* save before rt_ct_box() */
	if( rt_ct_box( cutp, axis ) == 0 )  {
		if( rt_ct_box( cutp, AXIS(depth+1) ) == 0 )
			return;	/* hopeless */
d548 4
a551 5
	if( cutp->cn.cn_l->bn.bn_len < oldlen ||
	    cutp->cn.cn_r->bn.bn_len < oldlen )  {
		rt_ct_optim( cutp->cn.cn_l, depth+1 );
		rt_ct_optim( cutp->cn.cn_r, depth+1 );
	}
@


9.3
log
@Split DEBUG_CUT by adding DEBUG_CUTDETAIL;  DEBUG_CUT just gives
statistics and histograms.
@
text
@d22 1
a22 1
static char RCScut[] = "@@(#)$Header: cut.c,v 9.2 89/10/10 16:10:42 mike Locked $ (BRL)";
d89 2
a90 2
	rt_hist_init( &rtip->rti_hist_cellsize, 0, rtip->nsolids/4, 50 );
	rt_hist_init( &rtip->rti_hist_cutdepth, 0, rt_cutDepth+10, 50 );
@


9.2
log
@Moved bounding box plotting into prep.c
@
text
@d8 12
d22 1
a22 1
static char RCScut[] = "@@(#)$Header: cut.c,v 9.1 89/05/19 05:54:01 mike Rel3_5 $ (BRL)";
d89 2
d93 2
a94 2
	if(rt_g.debug&DEBUG_CUT) rt_log(
		"Cut: maxdepth=%d, nbins=%d, maxlen=%d, avg=%g\n",
d99 3
d103 1
a103 1
	if(rt_g.debug&DEBUG_CUT) rt_pr_cut( &rtip->rti_CutHead, 0 );
d163 1
a163 1
	if(rt_g.debug&DEBUG_CUT)rt_log("rt_ct_add(x%x, %s, %d)\n",
d249 1
a249 1
	if(rt_g.debug&DEBUG_CUT)rt_log("rt_ct_box(x%x, %c)\n",cutp,"XYZ345"[axis]);
d289 1
a289 1
	if(rt_g.debug&DEBUG_CUT)rt_log("rt_ct_box(x%x) [%g,%g,%g]\n",
d687 1
d690 2
a691 2
		rt_ct_measure( rtip, cutp->cn.cn_l, depth+1 );
		rt_ct_measure( rtip, cutp->cn.cn_r, depth+1 );
d699 1
a699 1
	 * BOXNODE
d702 3
a704 3
	rtip->rti_cut_totobj += cutp->bn.bn_len;
	if( rtip->rti_cut_maxlen < cutp->bn.bn_len )
		rtip->rti_cut_maxlen = cutp->bn.bn_len;
d707 4
@


9.1
log
@Release_3.5
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 8.1 88/10/05 00:31:06 mike Rel3_0 $ (BRL)";
d123 1
a123 1
	/* Debugging code to plot cuts, solid RRPs */
a127 11
		(void)fclose(plotfp);
	}
	if( (plotfp=fopen("rtrpp.plot", "w"))!=NULL) {
		/* Then, all the solid bounding boxes, in white */
		pdv_3space( plotfp, rtip->rti_pmin, rtip->rti_pmax );
		pl_color( plotfp, 255, 255, 255 );
		for(stp=rtip->HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw)  {
			if( stp->st_aradius >= INFINITY )
				continue;
			pdv_3box( plotfp, stp->st_min, stp->st_max );
		}
@


8.1
log
@Release_3.0
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 7.5 88/09/17 07:53:41 mike Exp $ (BRL)";
@


7.5
log
@Added code to measure the depth of the cut tree,
and to find the max # of RPPs in a cut node
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 7.4 88/05/14 00:47:36 mike Locked $ (BRL)";
@


7.4
log
@lint fixes
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 7.3 88/05/14 00:00:59 mike Locked $ (BRL)";
d23 3
a25 2
HIDDEN int rt_ck_overlap(), rt_ct_box();
HIDDEN void rt_ct_add(), rt_ct_optim(), rt_ct_free();
d76 10
d387 1
a387 1
		rt_log("rt_ct_optim: bad node\n");
d396 2
a397 2
/**** THIS STATEMENT MUST GO ****/
	if( depth >= 12 && cutp->bn.bn_len <= rt_cutLen )
d667 33
@


7.3
log
@lint fixes
added zero _uv() routines to some modules
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 7.2 88/01/22 22:12:08 mike Locked $ (BRL)";
d519 1
@


7.2
log
@Increased resolution of UNIX-plot output to +/-32767 (full scale).
Made remaining diagnostic conditional on debug flag.
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 7.1 87/11/02 23:33:10 mike Locked $ (BRL)";
d98 1
d114 1
a114 3
		pl_3space( plotfp,
			PL_MIN, PL_MIN, PL_MIN,
			PL_MAX, PL_MAX, PL_MAX);
d121 1
a121 3
		pl_3space( plotfp,
			PL_MIN, PL_MIN, PL_MIN,
			PL_MAX, PL_MAX, PL_MAX);
d126 1
a126 1
			rt_draw_box( plotfp, rtip, stp->st_min, stp->st_max );
d573 1
a573 1
		rt_draw_box( fp, rtip, cutp->bn.bn_min, cutp->bn.bn_max );
a579 28
 *  			R T _ D R A W _ B O X
 *  
 *  Arrange to efficiently draw the edges of a box (RPP).
 *  Call on UNIX-Plot to do the actual drawing.
 */
void
rt_draw_box( fp, rtip, a, b )
FILE			*fp;
register struct rt_i	*rtip;
register vect_t		a, b;
{
	long ax, ay, az;
	long bx, by, bz;

	ax =	(a[X] - rtip->rti_pmin[X])*rtip->rti_pconv;
	ay =	(a[Y] - rtip->rti_pmin[Y])*rtip->rti_pconv;
	az =	(a[Z] - rtip->rti_pmin[Z])*rtip->rti_pconv;
	bx =	(b[X] - rtip->rti_pmin[X])*rtip->rti_pconv;
	by =	(b[Y] - rtip->rti_pmin[Y])*rtip->rti_pconv;
	bz =	(b[Z] - rtip->rti_pmin[Z])*rtip->rti_pconv;

	pl_3box( fp,
		(int)(ax+PL_MIN), (int)(ay+PL_MIN), (int)(az+PL_MIN),
		(int)(bx+PL_MIN), (int)(by+PL_MIN), (int)(bz+PL_MIN) );
}


/*
a654 32
}

/*
 *  			R T _ D R A W V E C
 *  
 *  Arrange to draw a vector in 3-space using UNIX-plot.
 */
void
rt_drawvec( fp, rtip, aa, bb )
FILE	*fp;
register struct rt_i	*rtip;
register vect_t		aa, bb;
{
	long ax, ay, az;
	long bx, by, bz;
	vect_t	a, b;

	VMOVE( a, aa );		/* Make local copys, for vclip to change */
	VMOVE( b, bb );
	if( rt_vclip( a, b, rtip->rti_pmin, rtip->rti_pmax ) == 0 )
		return;

	ax =	(a[X] - rtip->rti_pmin[X])*rtip->rti_pconv;
	ay =	(a[Y] - rtip->rti_pmin[Y])*rtip->rti_pconv;
	az =	(a[Z] - rtip->rti_pmin[Z])*rtip->rti_pconv;
	bx =	(b[X] - rtip->rti_pmin[X])*rtip->rti_pconv;
	by =	(b[Y] - rtip->rti_pmin[Y])*rtip->rti_pconv;
	bz =	(b[Z] - rtip->rti_pmin[Z])*rtip->rti_pconv;

	pl_3line( fp,
		(int)(ax+PL_MIN), (int)(ay+PL_MIN), (int)(az+PL_MIN),
		(int)(bx+PL_MIN), (int)(by+PL_MIN), (int)(bz+PL_MIN) );
@


7.1
log
@Release 2.3
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 6.3 87/09/17 07:03:09 mike Exp $ (BRL)";
d72 1
a72 1
rt_log("Cut: Tree Depth=%d, Leaf Len=%d\n", rt_cutDepth, rt_cutLen );
d98 5
a102 2
		diff = 4095.0 / (rtip->rti_pmax[X] - rtip->rti_pmin[X]);
		f = 4095.0 / (rtip->rti_pmax[Y] - rtip->rti_pmin[Y]);
d104 1
a104 1
		f = 4095.0 / (rtip->rti_pmax[Z] - rtip->rti_pmin[Z]);
d113 3
a115 1
		pl_3space( plotfp, 0,0,0, 4096, 4096, 4096);
d122 3
a124 1
		pl_3space( plotfp, 0,0,0, 4096, 4096, 4096);
d594 2
a595 2
	int ax, ay, az;
	int bx, by, bz;
d604 3
a606 1
	pl_3box( fp, ax, ay, az, bx, by, bz );
d699 2
a700 2
	int ax, ay, az;
	int bx, by, bz;
d715 3
a717 1
	pl_3line( fp, ax, ay, az, bx, by, bz );
@


6.3
log
@Added code to force boxes to not be made smaller than 1mm.
Changed from 4096 to 4095 to try to prevent overflows.
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 6.2 87/09/04 18:59:07 mike Locked $ (BRL)";
@


6.2
log
@Fixed clipping bug
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 6.1 87/07/11 07:55:32 mike Locked $ (BRL)";
d20 2
a21 2
int rt_cutLen = 3;		/* normal limit on number objs per box node */
int rt_cutDepth = 32;		/* normal limit on depth of cut tree */
d98 2
a99 2
		diff = 4096.0 / (rtip->rti_pmax[X] - rtip->rti_pmin[X]);
		f = 4096.0 / (rtip->rti_pmax[Y] - rtip->rti_pmin[Y]);
d101 1
a101 1
		f = 4096.0 / (rtip->rti_pmax[Z] - rtip->rti_pmin[Z]);
d229 4
d234 1
d261 1
a261 1
		return(0);	/* not worthwhile */
d263 4
d268 1
a268 1
	if(rt_g.debug&DEBUG_CUT)rt_log("rt_ct_box(x%x) %e..%e..%e\n",
a682 1
 *  Scale to +/- 4096 range from model space.
@


6.1
log
@Release 2.0
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 5.3 87/07/02 05:40:55 mike Exp $ (BRL)";
d83 1
a83 1
		FAST fastf_t f, diff;
a612 3
	static double sv;
	static double st;
	static double mindist, maxdist;
d616 3
d655 2
a656 2
	if( mindist <= 0 && maxdist >= 1 )
		return(1);	/* HIT, no clipping needed */
@


5.3
log
@Don't plot infinite objects.
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 5.2 87/06/27 03:40:50 mike Locked $ (BRL)";
@


5.2
log
@Added additional support for plotting.  Made a plot box slightly
larger than the model RPP, to permit drawing rays that interact
with the model RPP and get clipped.
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 5.1 87/06/24 22:11:08 mike Locked $ (BRL)";
d120 2
@


5.1
log
@Release 1.24
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 4.5 87/04/01 04:46:41 mike Exp $ (BRL)";
d77 29
a577 1
	double conv, f;
d579 6
a584 5
	conv = 4096.0 / (rtip->mdl_max[X] - rtip->mdl_min[X]);
	f = 4096.0 / (rtip->mdl_max[Y] - rtip->mdl_min[Y]);
	if( f < conv )  conv = f;
	f = 4096.0 / (rtip->mdl_max[Z] - rtip->mdl_min[Z]);
	if( f < conv )  conv = f;
a585 7
	ax =	(a[X] - rtip->mdl_min[X])*conv;
	ay =	(a[Y] - rtip->mdl_min[Y])*conv;
	az =	(a[Z] - rtip->mdl_min[Z])*conv;
	bx =	(b[X] - rtip->mdl_min[X])*conv;
	by =	(b[Y] - rtip->mdl_min[Y])*conv;
	bz =	(b[Z] - rtip->mdl_min[Z])*conv;

a681 1
	double conv, f;
d686 1
a686 1
	if( rt_vclip( a, b, rtip->mdl_min, rtip->mdl_max ) == 0 )
d689 6
a694 12
	conv = 4096.0 / (rtip->mdl_max[X] - rtip->mdl_min[X]);
	f = 4096.0 / (rtip->mdl_max[Y] - rtip->mdl_min[Y]);
	if( f < conv )  conv = f;
	f = 4096.0 / (rtip->mdl_max[Z] - rtip->mdl_min[Z]);
	if( f < conv )  conv = f;

	ax =	(a[X] - rtip->mdl_min[X])*conv;
	ay =	(a[Y] - rtip->mdl_min[Y])*conv;
	az =	(a[Z] - rtip->mdl_min[Z])*conv;
	bx =	(b[X] - rtip->mdl_min[X])*conv;
	by =	(b[Y] - rtip->mdl_min[Y])*conv;
	bz =	(b[Z] - rtip->mdl_min[Z])*conv;
@


4.5
log
@Changed to use libplot3 pl_*() UNIX-plot routines,
added rt_drawvec() to clip a vector to model RPP, and draw it
using UNIX-plot.
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 4.4 87/03/23 23:42:20 mike Exp $ (BRL)";
@


4.4
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 4.3 87/03/19 04:59:35 mike Exp $ (BRL)";
d20 1
a20 1
int rt_cutLen = 3;			/* normal limit on number objs per box node */
a29 2
static void space3(), plot_color(), move3(), cont3();
static FILE *plotfp;
d44 1
d74 1
d76 6
a81 2
	if(rt_g.debug&DEBUG_PLOTBOX && (plotfp=fopen("rtbox.plot", "w"))!=NULL) {
		space3( 0,0,0, 4096, 4096, 4096);
d83 4
a86 1
		rt_plot_cut( rtip, &rtip->rti_CutHead, 0 );
d88 2
a89 1
		plot_color( 255, 255, 255 );
d91 1
a91 1
			rt_draw_box( rtip, stp->st_min, stp->st_max );
d512 2
a513 1
rt_plot_cut( rtip, cutp, lvl )
d520 2
a521 2
		rt_plot_cut( rtip, cutp->cn.cn_l, lvl+1 );
		rt_plot_cut( rtip, cutp->cn.cn_r, lvl+1 );
d525 2
a526 1
		plot_color( (AXIS(lvl)==0)?255:0,
d529 1
a529 1
		rt_draw_box( rtip, cutp->bn.bn_min, cutp->bn.bn_max );
d539 1
a539 2
 *  Call on UNIX-Plot to do the actual drawing, which
 *  will fall out on plotfp.
d542 2
a543 1
rt_draw_box( rtip, a, b )
d564 2
a565 4
	move3( ax, ay, az );
	cont3( bx, ay, az );
	cont3( bx, by, az );
	cont3( ax, by, az );
a566 4
	move3( bx, ay, az );
	cont3( bx, ay, bz );
	cont3( bx, by, bz );
	cont3( bx, by, az );
d568 27
a594 4
	move3( bx, by, bz );
	cont3( ax, by, bz );
	cont3( ax, ay, bz );
	cont3( bx, ay, bz );
d596 3
a598 5
	move3( ax, by, bz );
	cont3( ax, by, az );
	cont3( ax, ay, az );
	cont3( ax, ay, bz );
}
d600 27
d628 16
a643 15
/*
 *  Generate UNIX Plot in 3-D.
 *  cf. Doug Gwyn's Sys-V-standard (but-only-at-BRL) package,
 *  so we have to include the necessary sources here.
 */
#define putsi(a)	putc(a&0377,plotfp); putc((a>>8)&0377,plotfp)
static void
space3(x0,y0,z0,x1,y1,z1){
	putc('S',plotfp);
	putsi(x0);
	putsi(y0);
	putsi(z0);
	putsi(x1);
	putsi(y1);
	putsi(z1);
d645 1
d647 4
a650 2
 *	plot_color -- deposit color selection in UNIX plot output file
 *	04-Jan-1984	D A Gwyn
d652 5
a656 3
static void
plot_color( r, g, b )
int	r, g, b;		/* color components, 0..255 */
d658 24
a681 18
	putc( 'C', plotfp );
	putc( r, plotfp );
	putc( g, plotfp );
	putc( b, plotfp );
}
static void
move3(xi,yi,zi){
	putc('M',plotfp);
	putsi(xi);
	putsi(yi);
	putsi(zi);
}
static void
cont3(xi,yi,zi){
	putc('N',plotfp);
	putsi(xi);
	putsi(yi);
	putsi(zi);
@


4.3
log
@Added code for rt_clean()
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 4.2 87/02/12 22:11:02 mike Exp $ (BRL)";
d79 1
a79 1
		rt_plot_cut( &rtip->rti_CutHead, 0 );
d83 1
a83 1
			rt_draw_box( stp->st_min, stp->st_max );
d379 1
d465 1
a465 1
 *  node, so as not to clobber rt_i.rti_CutHead !
d471 2
a472 1
	if( cutp == CUTTER_NULL )
d474 1
d481 2
d485 1
d504 4
a507 3
rt_plot_cut( cutp, lvl )
register union cutter *cutp;
int lvl;
d511 2
a512 2
		rt_plot_cut( cutp->cn.cn_l, lvl+1 );
		rt_plot_cut( cutp->cn.cn_r, lvl+1 );
d519 1
a519 1
		rt_draw_box( cutp->bn.bn_min, cutp->bn.bn_max );
d533 3
a535 2
rt_draw_box( a, b )
register vect_t a, b;
d540 3
a542 2
	conv = 4096.0 / (rt_i.mdl_max[X]-rt_i.mdl_min[X]);
	f = 4096.0 / (rt_i.mdl_max[Y]-rt_i.mdl_min[Y]);
d544 1
a544 1
	f = 4096.0 / (rt_i.mdl_max[Z]-rt_i.mdl_min[Z]);
d547 6
a552 6
	ax =	(a[X]-rt_i.mdl_min[X])*conv;
	ay =	(a[Y]-rt_i.mdl_min[Y])*conv;
	az =	(a[Z]-rt_i.mdl_min[Z])*conv;
	bx =	(b[X]-rt_i.mdl_min[X])*conv;
	by =	(b[Y]-rt_i.mdl_min[Y])*conv;
	bz =	(b[Z]-rt_i.mdl_min[Z])*conv;
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 4.1 86/12/29 03:44:53 mike Rel1 $ (BRL)";
d23 3
a25 3
HIDDEN int rt_ck_overlap(), rt_cut_box();
HIDDEN void rt_cut_add(), rt_cut_optim();
HIDDEN union cutter *rt_cut_get();
d74 1
a74 1
	rt_cut_optim( &rtip->rti_CutHead, 0 );
d90 1
a90 1
 *  			C U T _ A D D
d97 1
a97 1
rt_cut_add( cutp, stp, min, max, depth )
d103 1
a103 1
	if(rt_g.debug&DEBUG_CUT)rt_log("rt_cut_add(x%x, %s, %d)\n",
d112 1
a112 1
			rt_cut_add( cutp->cn.cn_l, stp, min, temp, depth+1 );
d118 1
a118 1
			rt_cut_add( cutp->cn.cn_r, stp, temp, max, depth+1 );
d122 1
a122 1
		rt_log("rt_cut_add:  node type =x%x\n",cutp->cut_type);
d149 1
a149 1
				"rt_cut_add: initial list alloc" );
d155 1
a155 1
				"rt_cut_add: list extend" );
d160 1
a160 1
				"rt_cut_add: list extend (old list)");
d168 1
a168 1
 *  			C U T _ B O X
d177 1
a177 1
rt_cut_box( cutp, axis )
d189 1
a189 1
	if(rt_g.debug&DEBUG_CUT)rt_log("rt_cut_box(x%x, %c)\n",cutp,"XYZ345"[axis]);
d220 1
a220 1
	if(rt_g.debug&DEBUG_CUT)rt_log("rt_cut_box(x%x) %e..%e..%e\n",
d228 1
a228 1
	cutp->cn.cn_l = rt_cut_get();
d238 1
a238 1
		"rt_cut_box: left list" );
d246 1
a246 1
	cutp->cn.cn_r = rt_cut_get();
d256 1
a256 1
		"rt_cut_box: right list" );
d262 1
a262 1
	rt_free( (char *)oldbox.bn.bn_list, "rt_cut_box:  old list" );
d268 1
a268 1
 *			C K _ O V E R L A P
d302 1
a302 1
 *  			C U T _ O P T I M
d311 1
a311 1
rt_cut_optim( cutp, depth )
d319 2
a320 2
		rt_cut_optim( cutp->cn.cn_l, depth+1 );
		rt_cut_optim( cutp->cn.cn_r, depth+1 );
d324 1
a324 1
		rt_log("rt_cut_optim: bad node\n");
d346 3
a348 3
	oldlen = cutp->bn.bn_len;	/* save before rt_cut_box() */
	if( rt_cut_box( cutp, axis ) == 0 )  {
		if( rt_cut_box( cutp, AXIS(depth+1) ) == 0 )
d353 2
a354 2
		rt_cut_optim( cutp->cn.cn_l, depth+1 );
		rt_cut_optim( cutp->cn.cn_r, depth+1 );
d359 1
a359 1
 *  			C U T _ G E T
d362 1
a362 1
rt_cut_get()
d370 1
a370 1
		cutp = (union cutter *)rt_malloc(bytes," rt_cut_get");
d383 12
a394 1
 *  			P R _ C U T
d454 35
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 3.8 86/12/19 04:09:47 mike Locked $ (BRL)";
@


3.8
log
@Changed to skip bounding of infinite solids when st_aradius >= INFINITY
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 3.7 86/08/12 04:15:25 mike Exp $ (BRL)";
@


3.7
log
@Changed #include directives for use with CC -I convention
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 3.6 86/08/03 03:35:09 mike Exp $ (BRL)";
d56 2
@


3.6
log
@Prevented stupid cuts.
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 3.5 86/07/30 03:54:46 mike Exp $ (BRL)";
d15 4
a18 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/raytrace.h"
#include "debug.h"
@


3.5
log
@improvements.
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 3.4 86/07/22 03:20:24 mike Exp $ (BRL)";
d213 2
a214 1
	if( pt_close <= oldbox.bn.bn_min[axis] )
@


3.4
log
@Slight additional error checking
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 3.3 86/07/19 04:39:26 mike Exp $ (BRL)";
d23 2
a24 2
HIDDEN int rt_ck_overlap();
HIDDEN void rt_cut_add(), rt_cut_box(), rt_cut_optim();
d27 1
a27 1
#define AXIS(depth)	((depth>>1)%3)	/* cuts: X, X, Y, Y, Z, Z, repeat */
d42 3
a44 1
rt_cut_it()  {
d47 7
a53 7
	rt_i.rti_CutHead.bn.bn_type = CUT_BOXNODE;
	VMOVE( rt_i.rti_CutHead.bn.bn_min, rt_i.mdl_min );
	VMOVE( rt_i.rti_CutHead.bn.bn_max, rt_i.mdl_max );
	rt_i.rti_CutHead.bn.bn_len = 0;
	rt_i.rti_CutHead.bn.bn_maxlen = rt_i.nsolids+1;
	rt_i.rti_CutHead.bn.bn_list = (struct soltab **)rt_malloc(
		rt_i.rti_CutHead.bn.bn_maxlen * sizeof(struct soltab *),
d55 4
a58 4
	for(stp=rt_i.HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw)  {
		rt_i.rti_CutHead.bn.bn_list[rt_i.rti_CutHead.bn.bn_len++] = stp;
		if( rt_i.rti_CutHead.bn.bn_len > rt_i.rti_CutHead.bn.bn_maxlen )  {
			rt_log("rt_cut_it:  rt_i.nsolids wrong, dropping solids\n");
d66 1
a66 1
	rt_cutLen = (int)log((double)rt_i.nsolids);	/* ln ~= log2 */
d72 2
a73 2
	rt_cut_optim( &rt_i.rti_CutHead, 0 );
	if(rt_g.debug&DEBUG_CUT) rt_pr_cut( &rt_i.rti_CutHead, 0 );
d77 1
a77 1
		rt_plot_cut( &rt_i.rti_CutHead, 0 );
d80 1
a80 1
		for(stp=rt_i.HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw)  {
a123 2
	if( cutp->bn.bn_len >= rt_cutLen && depth <= rt_cutDepth )  {
		register struct boxnode *bp;
a124 21
		/*
		 *  Too many objects in box, cut in half.
		 *  Cut box node, converting into a CUTNODE and
		 *  two BOXNODES.  Then, just tack on new object,
		 *  without trying to limit size or doing recursion.
		 */
		rt_cut_box( cutp, AXIS(depth) );
		/* cutp now points to a CUTNODE */

		/* add extra object to left, without recursing */
		bp = &(cutp->cn.cn_l->bn);
		if( rt_ck_overlap( bp->bn_min, bp->bn_max, stp ) )
			bp->bn_list[bp->bn_len++] = stp;

		bp = &(cutp->cn.cn_r->bn);
		/* add extra object to right, without recursing */
		if( rt_ck_overlap( bp->bn_min, bp->bn_max, stp ) )
			bp->bn_list[bp->bn_len++] = stp;
		return;
	}

d171 2
d174 1
a174 1
HIDDEN void
d183 1
a188 2
	cutp->cut_type = CUT_CUTNODE;
	cutp->cn.cn_axis = axis;
a195 2
	cutp->cn.cn_point =
		(oldbox.bn.bn_max[axis]+oldbox.bn.bn_min[axis]) * 0.5;
d197 2
a198 1
	d_close = cutp->cn.cn_point - pt_close;
d200 1
a200 1
		d = oldbox.bn.bn_list[i]->st_min[axis] - cutp->cn.cn_point;
d204 1
a204 2
			pt_close = oldbox.bn.bn_list[i]->st_min[axis]+
				0.0001;
d206 1
a206 1
		d = oldbox.bn.bn_list[i]->st_max[axis] - cutp->cn.cn_point;
d210 1
a210 2
			pt_close = oldbox.bn.bn_list[i]->st_max[axis]+
				0.0001;
d213 2
a214 2
	if( pt_close != oldbox.bn.bn_min[axis] )
		cutp->cn.cn_point = pt_close;
d216 8
d261 1
d330 1
d344 4
a347 1
	rt_cut_box( cutp, axis );
@


3.3
log
@Removed cut.h, switched to rt_i.
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 3.2 86/07/18 00:21:44 mike Exp $ (BRL)";
d327 1
d346 12
a357 4
	/* Keep subdividing until things don't get any better. */
	/* Really we might want to proceed for 2-3 levels, but... */
	oldlen = cutp->bn.bn_len;
	rt_cut_box( cutp, AXIS(depth) );
@


3.2
log
@Bulletproofing.
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header: cut.c,v 3.1 86/07/11 01:31:49 mike Exp $ (BRL)";
a18 1
#include "cut.h"
a22 3
union cutter CutHead;		/* Global head of cutting tree */
union cutter *CutFree;		/* Head of freelist */

d45 7
a51 7
	CutHead.bn.bn_type = CUT_BOXNODE;
	VMOVE( CutHead.bn.bn_min, rt_i.mdl_min );
	VMOVE( CutHead.bn.bn_max, rt_i.mdl_max );
	CutHead.bn.bn_len = 0;
	CutHead.bn.bn_maxlen = rt_i.nsolids+1;
	CutHead.bn.bn_list = (struct soltab **)rt_malloc(
		CutHead.bn.bn_maxlen * sizeof(struct soltab *),
d54 2
a55 2
		CutHead.bn.bn_list[CutHead.bn.bn_len++] = stp;
		if( CutHead.bn.bn_len > CutHead.bn.bn_maxlen )  {
d70 2
a71 2
	rt_cut_optim( &CutHead, 0 );
	if(rt_g.debug&DEBUG_CUT) rt_pr_cut( &CutHead, 0 );
d75 1
a75 1
		rt_plot_cut( &CutHead, 0 );
d147 11
d170 2
a171 1
			char *newlist;
d213 1
a213 1
	 *  This should ordinarily guarantee that each side of the
d275 1
d364 1
a364 1
	if( CutFree == CUTTER_NULL )  {
d370 2
a371 2
			cutp->cut_forw = CutFree;
			CutFree = cutp++;
d375 2
a376 2
	cutp = CutFree;
	CutFree = cutp->cut_forw;
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d10 1
a10 1
static char RCScut[] = "@@(#)$Header:  mike Exp $ (BRL)";
d68 2
a69 1
	rt_cutLen = (int)log((double)rt_i.nsolids);
a70 1
	rt_cutDepth = (int)(2 * log((double)rt_i.nsolids));	/* ln ~= log2 */
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d9 4
d217 2
a218 1
			pt_close = oldbox.bn.bn_list[i]->st_min[axis]+EPSILON;
d224 2
a225 1
			pt_close = oldbox.bn.bn_list[i]->st_max[axis]+EPSILON;
@


2.4
log
@rt and librt separated
@
text
@d17 2
a18 2
int CutLen = 3;			/* normal limit on number objs per box node */
int CutDepth = 32;		/* normal limit on depth of cut tree */
d23 3
a25 4
extern int ck_overlap();
extern void cut_it(), pr_cut();
HIDDEN void cut_add(), cut_box(), cut_optim();
HIDDEN union cutter *cut_get();
d29 1
d34 1
a34 1
 *  			C U T _ I T
d42 1
a42 1
cut_it()  {
d46 2
a47 2
	VMOVE( CutHead.bn.bn_min, mdl_min );
	VMOVE( CutHead.bn.bn_max, mdl_max );
d49 2
a50 2
	CutHead.bn.bn_maxlen = nsolids+1;
	CutHead.bn.bn_list = (struct soltab **)vmalloc(
d52 2
a53 2
		"cut_it: root list" );
	for(stp=HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw)  {
d56 1
a56 1
			rtlog("cut_it:  nsolids wrong, dropping solids\n");
d61 1
a61 1
	 *  Note that there will be (2**CutDepth)*CutLen leaf slots,
d64 9
a72 9
	CutLen = (int)log((double)nsolids);
	if( CutLen < 3 )  CutLen = 3;
	CutDepth = (int)(2 * log((double)nsolids));	/* ln ~= log2 */
	if( CutDepth < 9 )  CutDepth = 9;
	if( CutDepth > 24 )  CutDepth = 24;		/* !! */
rtlog("Cut: Tree Depth=%d, Leaf Len=%d\n", CutDepth, CutLen );
	cut_optim( &CutHead, 0 );
	if(debug&DEBUG_CUT) pr_cut( &CutHead, 0 );
	if(debug&DEBUG_PLOTBOX && (plotfp=fopen("rtbox.plot", "w"))!=NULL) {
d75 1
a75 1
		plot_cut( &CutHead, 0 );
d78 2
a79 2
		for(stp=HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw)  {
			draw_box( stp->st_min, stp->st_max );
d89 1
a89 1
 *  but without being paranoid about obeying the CutLen limits,
d93 1
a93 1
cut_add( cutp, stp, min, max, depth )
d99 1
a99 1
	if(debug&DEBUG_CUT)rtlog("cut_add(x%x, %s, %d)\n",
d107 2
a108 2
		if( ck_overlap( min, temp, stp ) )
			cut_add( cutp->cn.cn_l, stp, min, temp, depth+1 );
d113 2
a114 2
		if( ck_overlap( temp, max, stp ) )
			cut_add( cutp->cn.cn_r, stp, temp, max, depth+1 );
d118 1
a118 1
		rtlog("cut_add:  node type =x%x\n",cutp->cut_type);
d122 1
a122 1
	if( cutp->bn.bn_len >= CutLen && depth <= CutDepth )  {
d131 1
a131 1
		cut_box( cutp, AXIS(depth) );
d136 1
a136 1
		if( ck_overlap( bp->bn_min, bp->bn_max, stp ) )
d141 1
a141 1
		if( ck_overlap( bp->bn_min, bp->bn_max, stp ) )
d151 2
a152 2
			if( CutLen > 6 )
				cutp->bn.bn_maxlen = CutLen;
d155 1
a155 1
			cutp->bn.bn_list = (struct soltab **)vmalloc(
d157 1
a157 1
				"cut_add: initial list alloc" );
d160 1
a160 1
			newlist = vmalloc(
d162 1
a162 1
				"cut_add: list extend" );
d166 2
a167 2
			vfree( (char *)cutp->bn.bn_list,
				"cut_add: list extend (old list)");
d182 1
a182 1
cut_box( cutp, axis )
d193 1
a193 1
	if(debug&DEBUG_CUT)rtlog("cut_box(x%x, %c)\n",cutp,"XYZ345"[axis]);
d226 1
a226 1
	cutp->cn.cn_l = cut_get();
d234 1
a234 1
	bp->bn_list = (struct soltab **) vmalloc(
d236 1
a236 1
		"cut_box: left list" );
d238 1
a238 1
		if( !ck_overlap(bp->bn_min, bp->bn_max, oldbox.bn.bn_list[i]))
d244 1
a244 1
	cutp->cn.cn_r = cut_get();
d252 1
a252 1
	bp->bn_list = (struct soltab **) vmalloc(
d254 1
a254 1
		"cut_box: right list" );
d256 1
a256 1
		if( !ck_overlap(bp->bn_min, bp->bn_max, oldbox.bn.bn_list[i]))
d260 1
a260 1
	vfree( (char *)oldbox.bn.bn_list, "cut_box:  old list" );
d275 1
a275 1
ck_overlap( min, max, stp )
d279 2
a280 2
	if( debug&DEBUG_BOXING )  {
		rtlog("ck_overlap(%s)\n",stp->st_name);
d290 1
a290 1
	if( debug&DEBUG_BOXING )  rtlog("ck_overlap:  TRUE\n");
d293 1
a293 1
	if( debug&DEBUG_BOXING )  rtlog("ck_overlap:  FALSE\n");
d307 1
a307 1
cut_optim( cutp, depth )
d314 2
a315 2
		cut_optim( cutp->cn.cn_l, depth+1 );
		cut_optim( cutp->cn.cn_r, depth+1 );
d319 1
a319 1
		rtlog("cut_optim: bad node\n");
d326 3
a328 3
	if( depth > CutDepth )  return;		/* too deep */
	/* Attempt to subdivide finer than CutLen near treetop */
	if( depth >= 12 && cutp->bn.bn_len <= CutLen )
d333 1
a333 1
	cut_box( cutp, AXIS(depth) );
d336 2
a337 2
		cut_optim( cutp->cn.cn_l, depth+1 );
		cut_optim( cutp->cn.cn_r, depth+1 );
d345 1
a345 1
cut_get()
d352 2
a353 2
		bytes = byte_roundup(64*sizeof(union cutter));
		cutp = (union cutter *)vmalloc(bytes," cut_get");
d371 1
a371 1
pr_cut( cutp, lvl )
d377 1
a377 1
	rtlog("%.8x ", cutp);
d379 1
a379 1
		rtlog("   ");
d382 1
a382 1
		rtlog("Null???\n");
d389 1
a389 1
		rtlog("CUT L %c < %f\n",
d392 1
a392 1
		pr_cut( cutp->cn.cn_l, lvl+1 );
d394 1
a394 1
		rtlog("%.8x ", cutp);
d396 2
a397 2
			rtlog("   ");
		rtlog("CUT R %c >= %f\n",
d400 1
a400 1
		pr_cut( cutp->cn.cn_r, lvl+1 );
d404 1
a404 1
		rtlog("BOX Contains %d solids (%d alloc):\n",
d406 1
a406 1
		rtlog("        ");
d408 1
a408 1
			rtlog("   ");
d410 1
a410 1
		rtlog("        ");
d412 1
a412 1
			rtlog("   ");
d416 1
a416 1
			rtlog("        ");
d418 2
a419 2
				rtlog("   ");
			rtlog("    %s\n",
d425 1
a425 1
		rtlog("Unknown type=x%x\n", cutp->cut_type );
d432 1
a432 1
 *  			P L O T _ C U T
d434 2
a435 1
plot_cut( cutp, lvl )
d441 2
a442 2
		plot_cut( cutp->cn.cn_l, lvl+1 );
		plot_cut( cutp->cn.cn_r, lvl+1 );
d449 1
a449 1
		draw_box( cutp->bn.bn_min, cutp->bn.bn_max );
d456 1
a456 1
 *  			D R A W _ B O X
d462 2
a463 1
draw_box( a, b )
d469 2
a470 2
	conv = 4096.0 / (mdl_max[X]-mdl_min[X]);
	f = 4096.0 / (mdl_max[Y]-mdl_min[Y]);
d472 1
a472 1
	f = 4096.0 / (mdl_max[Z]-mdl_min[Z]);
d475 6
a480 6
	ax =	(a[X]-mdl_min[X])*conv;
	ay =	(a[Y]-mdl_min[Y])*conv;
	az =	(a[Z]-mdl_min[Z])*conv;
	bx =	(b[X]-mdl_min[X])*conv;
	by =	(b[Y]-mdl_min[Y])*conv;
	bz =	(b[Z]-mdl_min[Z])*conv;
@


2.3
log
@Made 3-D UNIX plot routines static, to not interfere with other's use.
@
text
@d13 1
a13 1
#include "raytrace.h"
@


2.2
log
@Changed to allocate nodes in large chunks.
@
text
@d30 1
d508 1
d522 1
d531 1
d538 1
@


2.1
log
@Version 2 of RT
@
text
@d21 1
d26 1
d65 1
a65 1
	CutDepth = (int)(3 * log((double)nsolids));	/* ln ~= log2 */
d67 1
a67 1
	if( CutDepth > 48 )  CutDepth = 48;		/* !! */
d225 1
a225 2
	cutp->cn.cn_l = (union cutter *)vmalloc( sizeof(union cutter),
		"cut_box:  left node");
d243 1
a243 2
	cutp->cn.cn_r = (union cutter *)vmalloc( sizeof(union cutter),
		"cut_box:  right node");
d341 24
d430 3
@
