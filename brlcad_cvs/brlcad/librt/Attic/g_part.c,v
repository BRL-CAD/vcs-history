head	11.43;
access;
symbols
	ansi-20040405-merged:11.36.2.2
	postmerge-20040405-ansi:11.41
	premerge-20040404-ansi:11.40
	postmerge-autoconf:11.40
	autoconf-freeze:11.37.6.3
	premerge-autoconf:11.40
	ansi-20040316-freeze:11.36.2.1
	postmerge-20040315-windows:11.40
	premerge-20040315-windows:11.40
	windows-20040315-freeze:11.36.4.1
	autoconf-20031203:11.37.6.1
	autoconf-20031202:11.37
	autoconf-branch:11.37.0.6
	phong-branch:11.37.0.4
	photonmap-branch:11.37.0.2
	rel-6-1-DP:11.36
	windows-branch:11.36.0.4
	rel-6-0-2:11.34
	ansi-branch:11.36.0.2
	rel-6-0-1-branch:11.34.0.2
	hartley-6-0-post:11.35
	hartley-6-0-pre:11.34
	rel-6-0-1:11.34
	rel-6-0:11.34
	rel-5-4:11.24
	offsite-5-3-pre:11.31
	rel-5-3:11.24
	rel-5-2:11.24
	rel-5-1-branch:11.24.0.2
	rel-5-1:11.24
	rel-5-0:11.9
	rel-5-0-beta:11.7
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.43
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.42;

11.42
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.41;

11.41
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.40;

11.40
date	2004.02.02.17.39.21;	author morrison;	state Exp;
branches;
next	11.39;

11.39
date	2003.11.04.19.24.00;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2003.11.03.19.43.14;	author morrison;	state Exp;
branches;
next	11.37;

11.37
date	2003.01.10.18.50.46;	author morrison;	state Exp;
branches
	11.37.6.1;
next	11.36;

11.36
date	2002.08.20.17.08.00;	author jra;	state Exp;
branches
	11.36.2.1
	11.36.4.1;
next	11.35;

11.35
date	2002.08.15.20.55.12;	author hartley;	state Exp;
branches;
next	11.34;

11.34
date	2001.10.02.19.24.29;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	2001.04.05.19.35.34;	author morrison;	state Exp;
branches;
next	11.32;

11.32
date	2001.03.31.01.57.08;	author morrison;	state Exp;
branches;
next	11.31;

11.31
date	2000.10.18.18.10.34;	author butler;	state Exp;
branches;
next	11.30;

11.30
date	2000.08.21.02.02.30;	author butler;	state Exp;
branches;
next	11.29;

11.29
date	2000.07.10.23.01.33;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.06.30.15.38.03;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.06.30.15.31.15;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.06.27.15.33.31;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	2000.06.27.14.34.48;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	2000.04.12.02.34.34;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.01.13.22.03.06;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	99.12.22.02.24.05;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	99.12.17.04.15.35;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	99.12.07.02.22.33;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.12.07.02.18.27;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	99.12.06.17.04.02;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	99.12.06.16.58.35;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	99.12.06.16.22.42;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.12.01.23.58.23;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	99.11.26.21.46.47;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	99.11.24.23.12.08;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	99.11.24.21.39.49;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.11.17.02.42.00;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.10.30.03.53.27;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.07.02.22.47.22;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.07.02.22.19.23;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.05.27.19.10.40;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.05.11.15.16.47;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.05.08.05.40.15;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.01.13.21.54.04;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.06.17.19.29.31;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.03.11.03.14.44;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.51;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.11.04.05.45.10;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.09.30.16.24.50;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.10.18.37.00;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.20;	author mike;	state Rel4_0;
branches;
next	1.23;

1.23
date	91.09.20.23.16.18;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	91.06.30.00.10.54;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	91.06.22.22.30.28;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	91.05.18.03.01.03;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	91.01.28.23.53.13;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	91.01.26.03.14.51;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	91.01.25.21.52.11;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	91.01.25.21.19.09;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	91.01.25.20.35.48;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	91.01.15.23.42.13;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	91.01.15.01.34.43;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	91.01.11.07.11.37;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	91.01.11.04.02.37;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	91.01.09.02.17.40;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	90.10.15.16.56.26;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	90.10.15.15.36.46;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	90.10.15.12.00.58;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	90.10.13.00.23.47;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	90.10.12.23.53.25;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	90.10.12.23.42.45;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	90.10.12.21.33.14;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.10.12.09.18.48;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.10.11.07.45.59;	author mike;	state Exp;
branches;
next	;

11.36.2.1
date	2002.09.19.18.01.34;	author morrison;	state Exp;
branches;
next	11.36.2.2;

11.36.2.2
date	2004.03.17.21.18.47;	author morrison;	state Exp;
branches;
next	;

11.36.4.1
date	2004.03.11.23.43.38;	author morrison;	state Exp;
branches;
next	;

11.37.6.1
date	2003.12.03.16.24.07;	author erikg;	state Exp;
branches;
next	11.37.6.2;

11.37.6.2
date	2004.02.12.18.37.41;	author erikg;	state Exp;
branches;
next	11.37.6.3;

11.37.6.3
date	2004.03.15.14.07.19;	author erikg;	state Exp;
branches;
next	;


desc
@Geometry module for Particles:  Spherical, Cylindrical (Lozenge),
and Conical.
@


11.43
log
@moved to src/
@
text
@/*
 *			G _ P A R T . C
 *
 *  Purpose -
 *	Intersect a ray with a "particle" solid, which can have
 *	three main forms:  sphere, hemisphere-tipped cylinder (lozenge),
 *	and hemisphere-tipped cone.
 *	This code draws on the examples of g_rec (Davisson) & g_sph (Dykstra).
 *
 *  Authors -
 *	Michael John Muuss
 *	Paul Tanenbaum
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 *
 *  Algorithm for the hemisphere-tipped cylinder and cone cases -
 *  
 *  Given V, H, vrad, and hrad, there is a set of points on this cylinder
 *  
 *  { (x,y,z) | (x,y,z) is on cylinder }
 *  
 *  Through a series of Affine Transformations, this set of points will be
 *  transformed into a set of points on a unit cylinder (or cone)
 *  with the transformed base (V') located at the origin
 *  with a transformed radius of 1 (vrad').
 *  The height of the cylinder (or cone) along the +Z axis is +1
 *  (ie, H' = (0,0,1) ), with a transformed radius of hrad/vrad.
 *  
 *  
 *  { (x',y',z') | (x',y',z') is on cylinder at origin }
 *  
 *  The transformation from X to X' is accomplished by:
 *
 *  finding two unit vectors A and B mutually perpendicular, and perp. to H.
 *
 *  X' = S(R( X - V ))
 *
 *  where R(X) rotates H to the +Z axis, and S(X) scales vrad' to 1
 *  and |H'| to 1.
 *
 *  where R(X) =  ( A/(|A|) )
 *  		 (  B/(|B|)  ) . X
 *  		  ( H/(|H|) )
 *  
 *  and S(X) =	 (  1/|A|   0     0   )
 *  		(    0    1/|B|   0    ) . X
 *  		 (   0      0   1/|H| )
 *  
 *  To find the intersection of a line with the surface of the cylinder,
 *  consider the parametric line L:
 *  
 *  	L : { P(n) | P + t(n) . D }
 *  
 *  Call W the actual point of intersection between L and the cylinder.
 *  Let W' be the point of intersection between L' and the unit cylinder.
 *  
 *  	L' : { P'(n) | P' + t(n) . D' }
 *  
 *  W = invR( invS( W' ) ) + V
 *  
 *  Where W' = k D' + P'.
 *  
 *  If Dx' and Dy' are both 0, then there is no hit on the cylinder;
 *  but the end spheres need checking.
 *
 *  The equation for the unit cylinder ranging along Z is
 *
 *	x**2 + y**2 - r**2 = 0
 *
 *  and the equation for a unit cone ranging along Z is
 *
 *	x**2 + y**2 - f(z)**2 = 0
 *
 *  where in this case f(z) linearly interpolates the radius of the
 *  cylinder from vrad (r1) to hrad (r2) as z ranges from 0 to 1, i.e.:
 *
 *	f(z) = (r2-r1)/1 * z + r1
 *
 *  let m = (r2-r1)/1, and substitute:
 *
 *	x**2 + y**2 - (m*z+r1)**2 = 0 .
 *
 *  For the cylinder case, r1 == r2, so m == 0, and everything simplifies.
 *
 *  The parametric formulation for line L' is P' + t * D', or
 *
 *	x = Px' + t * Dx'
 *	y = Py' + t * Dy'
 *	z = Pz' + t * Dz' .
 *
 *  Substituting these definitions into the formula for the unit cone gives
 *
 *	(Px'+t*Dx')**2 + (Py'+t*Dy')**2 + (m*(Pz'+t*Dz')+r1)**2 = 0
 *
 *  Expanding and regrouping terms gives a quadratic in "t"
 *  which has the form
 *
 *	a * t**2 + b * t + c = 0
 *
 *  where
 *
 *	a = Dx'**2 + Dy'**2 - m**2 * Dz'**2
 *	b = 2 * (Px'*Dx' + Py'*Dy' - m**2 * Pz'*Dz' - m*r1*Dz')
 *	c = Px'**2 + Py'**2 - m**2 * Pz'**2 - 2*m*r1*Pz' - r1**2
 *
 *  Line L' hits the infinitely tall unit cone at point(s) W'
 *  which correspond to the roots of the quadratic.
 *  The quadratic formula yields values for "t"
 *
 *	t = [ -b +/- sqrt( b** - 4 * a * c ) ] / ( 2 * a )
 *
 *  This parameter "t" can be substituted into the formulas for either
 *  L' or L, because affine transformations preserve distances along lines.
 *  
 *  Now, D' = S( R( D ) )
 *  and  P' = S( R( P - V ) )
 *  
 *  Substituting,
 *  
 *  W = V + invR( invS[ k *( S( R( D ) ) ) + S( R( P - V ) ) ] )
 *    = V + invR( ( k * R( D ) ) + R( P - V ) )
 *    = V + k * D + P - V
 *    = k * D + P
 *  
 *  Note that ``t'' is constant, and is the same in the formulations
 *  for both W and W'.
 *
 *  The hit at ``t'' is a hit on the height=1 unit cylinder IFF
 *  0 <= Wz' <= 1.
 *  
 *  NORMALS.  Given the point W on the surface of the cylinder,
 *  what is the vector normal to the tangent plane at that point?
 *  
 *  Map W onto the unit cylinder, ie:  W' = S( R( W - V ) ).
 *  
 *  Plane on unit cylinder at W' has a normal vector N' of the same value
 *  as W' in x and y, with z set to zero, ie, (Wx', Wy', 0)
 *  
 *  The plane transforms back to the tangent plane at W, and this
 *  new plane (on the original cylinder) has a normal vector of N, viz:
 *  
 *  N = inverse[ transpose(invR o invS) ] ( N' )
 *    = inverse[ transpose(invS) o transpose(invR) ] ( N' )
 *    = inverse[ inverse(S) o R ] ( N' )
 *    = invR o S ( N' )
 *
 *  Note that the normal vector produced above will not have unit length.
 *
 *  THE HEMISPHERES.
 *
 *  THE "EQUIVALENT CONE":
 *
 *  In order to have exact matching of the surface normals at the join
 *  between the conical body of the particle and the hemispherical end,
 *  it is necessary to alter the cone to form an "equivalent cone",
 *  where the end caps of the cone are both shifted away from the
 *  large hemisphere and towards the smaller one.
 *  This makes the cone end where it is tangent to the hemisphere.
 *  The calculation for theta come from a diagram drawn by PJT on 18-Nov-99.
 */
#ifndef lint
static const char RCSpart[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_part.c,v 11.42 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "raytrace.h"
#include "nmg.h"
#include "rtgeom.h"
#include "./debug.h"

struct part_specific {
	struct rt_part_internal	part_int;
	mat_t			part_SoR;	/* Scale(Rot(vect)) */
	mat_t			part_invRoS;	/* invRot(Scale(vect)) */
	fastf_t			part_vrad_prime;
	fastf_t			part_hrad_prime;
	/* For the "equivalent cone" */
	fastf_t			part_v_hdist;	/* dist of base plate on unit cone */
	fastf_t			part_h_hdist;
	fastf_t			part_v_erad;	/* radius of equiv. particle */
	fastf_t			part_h_erad;
};

/* hit_surfno flags for which end was hit */
#define RT_PARTICLE_SURF_VSPHERE	1
#define RT_PARTICLE_SURF_BODY		2
#define RT_PARTICLE_SURF_HSPHERE	3

const struct bu_structparse rt_part_parse[] = {
    { "%f", 3, "V",  offsetof(struct rt_part_internal, part_V[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "H",  offsetof(struct rt_part_internal, part_H[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_v",offsetof(struct rt_part_internal, part_vrad), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_h",offsetof(struct rt_part_internal, part_hrad), BU_STRUCTPARSE_FUNC_NULL },
    { {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
 };
	    
RT_EXTERN( void rt_part_ifree, (struct rt_db_internal *ip) );

/*
 *  			R T _ P A R T _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid particle, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	particle is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct part_specific is created, and it's address is stored in
 *  	stp->st_specific for use by part_shot().
 */
int
rt_part_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	register struct part_specific *part;
	struct rt_part_internal	*pip;
	vect_t		Hunit;
	vect_t		a, b;
	mat_t		R, Rinv;
	mat_t		S;
	vect_t		max, min;
	vect_t		tip;
	fastf_t		inv_hlen;
	fastf_t		hlen;
	fastf_t		hlen_sq;
	fastf_t		r_diff;
	fastf_t		r_diff_sq;
	fastf_t		sin_theta;
	fastf_t		cos_theta;

	RT_CK_DB_INTERNAL( ip );
	pip = (struct rt_part_internal *)ip->idb_ptr;
	RT_PART_CK_MAGIC(pip);

	BU_GETSTRUCT( part, part_specific );
	stp->st_specific = (genptr_t)part;
	part->part_int = *pip;			/* struct copy */
	pip = &part->part_int;

	if( pip->part_type == RT_PARTICLE_TYPE_SPHERE )  {
		/* XXX Ought to hand off to rt_sph_prep() here */
		/* Compute bounding sphere and RPP */
		VMOVE( stp->st_center, pip->part_V );
		stp->st_aradius = stp->st_bradius = pip->part_vrad;
		stp->st_min[X] = pip->part_V[X] - pip->part_vrad;
		stp->st_max[X] = pip->part_V[X] + pip->part_vrad;
		stp->st_min[Y] = pip->part_V[Y] - pip->part_vrad;
		stp->st_max[Y] = pip->part_V[Y] + pip->part_vrad;
		stp->st_min[Z] = pip->part_V[Z] - pip->part_vrad;
		stp->st_max[Z] = pip->part_V[Z] + pip->part_vrad;
		return(0);		/* OK */
	}

	/* Compute some essential terms */
	hlen_sq = MAGSQ(pip->part_H );
	if( hlen_sq < SMALL )  {
		bu_log("part(%s): 0-length H vector\n", stp->st_dp->d_namep);
		return 1;		/* BAD */
	}
	hlen = sqrt(hlen_sq);
	inv_hlen = 1/hlen;
	VSCALE( Hunit, pip->part_H, inv_hlen );
	bn_vec_ortho( a, Hunit );
	VCROSS( b, Hunit, a );

	/*
	 *  Compute parameters for the "equivalent cone"
	 */

	/* Calculate changes in terms of the "unit particle" */
	if( pip->part_vrad >= pip->part_hrad )  {
		/* V end is larger, H end is smaller */
		r_diff = (pip->part_vrad - pip->part_hrad) * inv_hlen;
		r_diff_sq = r_diff * r_diff;
		if( r_diff_sq > 1 )  {
			/* No "equivalent cone" is possible, theta=90deg */
			sin_theta = 1;
			cos_theta = 0;
		} else {
			sin_theta = sqrt( 1 - r_diff_sq );
			cos_theta = fabs( r_diff );
		}

		part->part_v_erad = pip->part_vrad / sin_theta;
		part->part_h_erad = pip->part_hrad / sin_theta;

		/* Move both plates towards H hemisphere */
		part->part_v_hdist = cos_theta * pip->part_vrad * inv_hlen;
		part->part_h_hdist = 1 + cos_theta * pip->part_hrad * inv_hlen;
	} else {
		/* H end is larger, V end is smaller */
		r_diff = (pip->part_hrad - pip->part_vrad) * inv_hlen;
		r_diff_sq = r_diff * r_diff;
		if( r_diff_sq > 1 )  {
			/* No "equivalent cone" is possible, theta=90deg */
			sin_theta = 1;
			cos_theta = 0;
		} else {
			sin_theta = sqrt( 1 - r_diff_sq );
			cos_theta = fabs( r_diff );
		}

		part->part_v_erad = pip->part_vrad / sin_theta;
		part->part_h_erad = pip->part_hrad / sin_theta;

		/* Move both plates towards V hemisphere */
		part->part_v_hdist = -cos_theta * pip->part_vrad * inv_hlen;
		part->part_h_hdist = 1 - cos_theta * pip->part_hrad * inv_hlen;
	}
	/* Thanks to matrix S, vrad_prime is always 1 */
/*#define VRAD_PRIME	1 */
/*#define HRAD_PRIME	(part->part_int.part_hrad / part->part_int.part_vrad) */
	part->part_vrad_prime = 1;
	part->part_hrad_prime = part->part_h_erad / part->part_v_erad;

	/* Compute R and Rinv */
	MAT_IDN( R );
	VMOVE( &R[0], a );		/* has unit length */
	VMOVE( &R[4], b );		/* has unit length */
	VMOVE( &R[8], Hunit );
	bn_mat_trn( Rinv, R );

	/* Compute scale matrix S, where |A| = |B| = equiv_Vradius */ 
	MAT_IDN( S );
	S[ 0] = 1.0 / part->part_v_erad;
	S[ 5] = S[0];
	S[10] = inv_hlen;

	bn_mat_mul( part->part_SoR, S, R );
	bn_mat_mul( part->part_invRoS, Rinv, S );

	/* RPP and bounding sphere */
	VJOIN1( stp->st_center, pip->part_V, 0.5, pip->part_H );

	stp->st_aradius = stp->st_bradius = pip->part_vrad;

	stp->st_min[X] = pip->part_V[X] - pip->part_vrad;
	stp->st_max[X] = pip->part_V[X] + pip->part_vrad;
	stp->st_min[Y] = pip->part_V[Y] - pip->part_vrad;
	stp->st_max[Y] = pip->part_V[Y] + pip->part_vrad;
	stp->st_min[Z] = pip->part_V[Z] - pip->part_vrad;
	stp->st_max[Z] = pip->part_V[Z] + pip->part_vrad;

	VADD2( tip, pip->part_V, pip->part_H );
	min[X] = tip[X] - pip->part_hrad;
	max[X] = tip[X] + pip->part_hrad;
	min[Y] = tip[Y] - pip->part_hrad;
	max[Y] = tip[Y] + pip->part_hrad;
	min[Z] = tip[Z] - pip->part_hrad;
	max[Z] = tip[Z] + pip->part_hrad;
	VMINMAX( stp->st_min, stp->st_max, min );
	VMINMAX( stp->st_min, stp->st_max, max );

	/* Determine bounding sphere from the RPP */
	{
		register fastf_t	f;
		vect_t			work;
		VSUB2SCALE( work, stp->st_max, stp->st_min, 0.5 );	/* radius */
		f = work[X];
		if( work[Y] > f )  f = work[Y];
		if( work[Z] > f )  f = work[Z];
		stp->st_aradius = f;
		stp->st_bradius = MAGNITUDE(work);
	}
	return(0);			/* OK */
}

/*
 *			R T _ P A R T _ P R I N T
 */
void
rt_part_print(register const struct soltab *stp)
{
	register const struct part_specific *part =
		(struct part_specific *)stp->st_specific;

	VPRINT("part_V", part->part_int.part_V );
	VPRINT("part_H", part->part_int.part_H );
	bu_log("part_vrad=%g\n", part->part_int.part_vrad );
	bu_log("part_hrad=%g\n", part->part_int.part_hrad );

	switch( part->part_int.part_type )  {
	case RT_PARTICLE_TYPE_SPHERE:
		bu_log("part_type = SPHERE\n");
		break;
	case RT_PARTICLE_TYPE_CYLINDER:
		bu_log("part_type = CYLINDER\n");
		bn_mat_print("part_SoR", part->part_SoR );
		bn_mat_print("part_invRoS", part->part_invRoS );
		break;
	case RT_PARTICLE_TYPE_CONE:
		bu_log("part_type = CONE\n");
		bn_mat_print("part_SoR", part->part_SoR );
		bn_mat_print("part_invRoS", part->part_invRoS );
		break;
	default:
		bu_log("part_type = %d ???\n", part->part_int.part_type );
		break;
	}
}

/*
 *  			R T _ P A R T _ S H O T
 *  
 *  Intersect a ray with a part.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_part_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct part_specific *part =
		(struct part_specific *)stp->st_specific;
	register struct seg *segp;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL point_t	pprime;		/* P' */
	LOCAL point_t	xlated;		/* translated ray start point */
	LOCAL fastf_t	t1, t2;		/* distance constants of solution */
	LOCAL fastf_t	f;
	LOCAL struct hit hits[4];	/* 4 potential hit points */
	register struct hit *hitp = &hits[0];
	int		check_v, check_h;

	if( part->part_int.part_type == RT_PARTICLE_TYPE_SPHERE )  {
		LOCAL vect_t	ov;		/* ray orgin to center (V - P) */
		FAST fastf_t	vrad_sq;
		FAST fastf_t	magsq_ov;	/* length squared of ov */
		FAST fastf_t	b;		/* second term of quadratic eqn */
		FAST fastf_t	root;		/* root of radical */

		VSUB2( ov, part->part_int.part_V, rp->r_pt );
		b = VDOT( rp->r_dir, ov );
		magsq_ov = MAGSQ(ov);

		if( magsq_ov >= (vrad_sq = part->part_int.part_vrad *
		    part->part_int.part_vrad) ) {
			/* ray origin is outside of sphere */
			if( b < 0 ) {
				/* ray direction is away from sphere */
				return(0);		/* No hit */
			}
			root = b*b - magsq_ov + vrad_sq;
			if( root <= 0 ) {
				/* no real roots */
				return(0);		/* No hit */
			}
		} else {
			root = b*b - magsq_ov + vrad_sq;
		}
		root = sqrt(root);

		RT_GET_SEG(segp, ap->a_resource);
		segp->seg_stp = stp;

		/* we know root is positive, so we know the smaller t */
		segp->seg_in.hit_magic = RT_HIT_MAGIC;
		segp->seg_in.hit_dist = b - root;
		segp->seg_in.hit_surfno = RT_PARTICLE_SURF_VSPHERE;
		segp->seg_out.hit_magic = RT_HIT_MAGIC;
		segp->seg_out.hit_dist = b + root;
		segp->seg_out.hit_surfno = RT_PARTICLE_SURF_VSPHERE;
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		return(2);			/* HIT */
	}

	/* Transform ray to coordinate system of unit cone at origin */
	MAT4X3VEC( dprime, part->part_SoR, rp->r_dir );
	VSUB2( xlated, rp->r_pt, part->part_int.part_V );
	MAT4X3VEC( pprime, part->part_SoR, xlated );

	if( NEAR_ZERO(dprime[X], SMALL) && NEAR_ZERO(dprime[Y], SMALL) )  {
		check_v = check_h = 1;
		goto check_hemispheres;
	}
	check_v = check_h = 0;

	/* Find roots of the equation, using forumla for quadratic */
	/* Note that vrad' = 1 and hrad' = hrad/vrad */
	if( part->part_int.part_type == RT_PARTICLE_TYPE_CYLINDER )  {
		/* Cylinder case, hrad == vrad, m = 0 */
		FAST fastf_t	a, b, c;
		FAST fastf_t	root;		/* root of radical */

		a = dprime[X]*dprime[X] + dprime[Y]*dprime[Y];
		b = dprime[X]*pprime[X] + dprime[Y]*pprime[Y];
		c = pprime[X]*pprime[X] + pprime[Y]*pprime[Y] - 1;
		if( (root = b*b - a * c) <= 0 )
			goto check_hemispheres;
		root = sqrt(root);
		t1 = (root-b) / a;
		t2 = -(root+b) / a;
	} else {
		/* Cone case */
		FAST fastf_t	a, b, c;
		FAST fastf_t	root;		/* root of radical */
		FAST fastf_t	m, msq;

		m = part->part_hrad_prime - part->part_vrad_prime;

		/* This quadratic has had a factor of 2 divided out of "b"
		 * throughout.  More efficient, but the same answers.
		 */
		a = dprime[X]*dprime[X] + dprime[Y]*dprime[Y] -
			(msq = m*m) * dprime[Z]*dprime[Z];
		b = dprime[X]*pprime[X] + dprime[Y]*pprime[Y] -
			msq * dprime[Z]*pprime[Z] -
			m * dprime[Z];		/* * part->part_vrad_prime */
		c = pprime[X]*pprime[X] + pprime[Y]*pprime[Y] -
			msq * pprime[Z]*pprime[Z] -
			2 * m * pprime[Z] - 1;
			/* was: ... -2m * vrad' * Pz' - vrad'**2 */

		if( (root = b*b - a * c) <= 0 )
			goto check_hemispheres;
		root = sqrt(root);

		t1 = (root-b) / a;
		t2 = -(root+b) / a;
	}

	/*
	 *  t1 and t2 are potential solutions to intersection with side.
	 *  Find hit' point, see if Z values fall in range.
	 */
	if( (f = pprime[Z] + t1 * dprime[Z]) >= part->part_v_hdist )  {
		check_h = 1;		/* may also hit off end */
		if( f <= part->part_h_hdist )  {
			hitp->hit_magic = RT_HIT_MAGIC;
			/** VJOIN1( hitp->hit_vpriv, pprime, t1, dprime ); **/
			hitp->hit_vpriv[X] = pprime[X] + t1 * dprime[X];
			hitp->hit_vpriv[Y] = pprime[Y] + t1 * dprime[Y];
			hitp->hit_vpriv[Z] = f;
			hitp->hit_dist = t1;
			hitp->hit_surfno = RT_PARTICLE_SURF_BODY;
			hitp++;
		}
	} else {
		check_v = 1;
	}

	if( (f = pprime[Z] + t2 * dprime[Z]) >= part->part_v_hdist )  {
		check_h = 1;		/* may also hit off end */
		if( f <= part->part_h_hdist )  {
			hitp->hit_magic = RT_HIT_MAGIC;
			/** VJOIN1( hitp->hit_vpriv, pprime, t2, dprime ); **/
			hitp->hit_vpriv[X] = pprime[X] + t2 * dprime[X];
			hitp->hit_vpriv[Y] = pprime[Y] + t2 * dprime[Y];
			hitp->hit_vpriv[Z] = f;
			hitp->hit_dist = t2;
			hitp->hit_surfno = RT_PARTICLE_SURF_BODY;
			hitp++;
		}
	} else {
		check_v = 1;
	}

	/*
	 *  Check for hitting the end hemispheres.
	 */
check_hemispheres:
	if( check_v )  {
		LOCAL vect_t	ov;		/* ray orgin to center (V - P) */
		FAST fastf_t	rad_sq;
		FAST fastf_t	magsq_ov;	/* length squared of ov */
		FAST fastf_t	b;
		FAST fastf_t	root;		/* root of radical */

		/*
		 *  First, consider a hit on V hemisphere.
		 */
		VSUB2( ov, part->part_int.part_V, rp->r_pt );
		b = VDOT( rp->r_dir, ov );
		magsq_ov = MAGSQ(ov);
		if( magsq_ov >= (rad_sq = part->part_int.part_vrad *
		    part->part_int.part_vrad) ) {
			/* ray origin is outside of sphere */
			if( b < 0 ) {
				/* ray direction is away from sphere */
				goto do_check_h;
			}
			root = b*b - magsq_ov + rad_sq;
			if( root <= 0 ) {
				/* no real roots */
				goto do_check_h;
			}
		} else {
			root = b*b - magsq_ov + rad_sq;
		}
		root = sqrt(root);
		t1 = b - root;
		/* see if hit'[Z] is below V end of cylinder */
		if( pprime[Z] + t1 * dprime[Z] <= part->part_v_hdist )  {
			hitp->hit_magic = RT_HIT_MAGIC;
			hitp->hit_dist = t1;
			hitp->hit_surfno = RT_PARTICLE_SURF_VSPHERE;
			hitp++;
		}
		t2 = b + root;
		if( pprime[Z] + t2 * dprime[Z] <= part->part_v_hdist )  {
			hitp->hit_magic = RT_HIT_MAGIC;
			hitp->hit_dist = t2;
			hitp->hit_surfno = RT_PARTICLE_SURF_VSPHERE;
			hitp++;
		}
	}

do_check_h:
	if( check_h )  {
		LOCAL vect_t	ov;		/* ray orgin to center (V - P) */
		FAST fastf_t	rad_sq;
		FAST fastf_t	magsq_ov;	/* length squared of ov */
		FAST fastf_t	b;		/* second term of quadratic eqn */
		FAST fastf_t	root;		/* root of radical */

		/*
		 *  Next, consider a hit on H hemisphere
		 */
		VADD2( ov, part->part_int.part_V, part->part_int.part_H );
		VSUB2( ov, ov, rp->r_pt );
		b = VDOT( rp->r_dir, ov );
		magsq_ov = MAGSQ(ov);
		if( magsq_ov >= (rad_sq = part->part_int.part_hrad *
		    part->part_int.part_hrad) ) {
			/* ray origin is outside of sphere */
			if( b < 0 ) {
				/* ray direction is away from sphere */
				goto out;
			}
			root = b*b - magsq_ov + rad_sq;
			if( root <= 0 ) {
				/* no real roots */
				goto out;
			}
		} else {
			root = b*b - magsq_ov + rad_sq;
		}
		root = sqrt(root);
		t1 = b - root;
		/* see if hit'[Z] is above H end of cylinder */
		if( pprime[Z] + t1 * dprime[Z] >= part->part_h_hdist )  {
			hitp->hit_magic = RT_HIT_MAGIC;
			hitp->hit_dist = t1;
			hitp->hit_surfno = RT_PARTICLE_SURF_HSPHERE;
			hitp++;
		}
		t2 = b + root;
		if( pprime[Z] + t2 * dprime[Z] >= part->part_h_hdist )  {
			hitp->hit_magic = RT_HIT_MAGIC;
			hitp->hit_dist = t2;
			hitp->hit_surfno = RT_PARTICLE_SURF_HSPHERE;
			hitp++;
		}
	}
out:
	if( hitp == &hits[0] )
		return(0);	/* MISS */
	if( hitp == &hits[1] )  {
		/* Only one hit, make it a 0-thickness segment */
		hits[1] = hits[0];		/* struct copy */
		hitp++;
	} else if( hitp > &hits[2] )  {
		/*
		 *  More than two intersections found.
		 *  This can happen when a ray grazes down along a tangent
		 *  line; the intersection interval from the hemisphere
		 *  may not quite join up with the interval from the cone.
		 *  Since particles are convex, all we need to do is to
		 *  return the maximum extent of the ray.
		 *  Do this by sorting the intersections,
		 *  and using the minimum and maximum values.
		 */
		rt_hitsort( hits, hitp - &hits[0] );

		/* [0] is minimum, make [1] be maximum (hitp is +1 off end) */
		hits[1] = hitp[-1];	/* struct copy */
	}

	if( hits[0].hit_dist < hits[1].hit_dist )  {
		/* entry is [0], exit is [1] */
		register struct seg *segp;

		RT_GET_SEG(segp, ap->a_resource);
		segp->seg_stp = stp;
		segp->seg_in = hits[0];		/* struct copy */
		segp->seg_out = hits[1];	/* struct copy */
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	} else {
		/* entry is [1], exit is [0] */
		register struct seg *segp;

		RT_GET_SEG(segp, ap->a_resource);
		segp->seg_stp = stp;
		segp->seg_in = hits[1];		/* struct copy */
		segp->seg_out = hits[0];	/* struct copy */
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	}
	return(2);			/* HIT */
}

#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	

/*
 *			R T _ P A R T _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_part_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	rt_vstub( stp, rp, segp, n, ap ); 
}

/*
 *  			R T _ P A R T _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_part_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct part_specific *part =
		(struct part_specific *)stp->st_specific;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	switch( hitp->hit_surfno )  {
	case RT_PARTICLE_SURF_VSPHERE:
		VSUB2( hitp->hit_normal, hitp->hit_point, part->part_int.part_V );
		VUNITIZE( hitp->hit_normal );
		break;
	case RT_PARTICLE_SURF_HSPHERE:
		VSUB3( hitp->hit_normal, hitp->hit_point,
			part->part_int.part_V, part->part_int.part_H );
		VUNITIZE( hitp->hit_normal );
		break;
	case RT_PARTICLE_SURF_BODY:
		/* compute it */
		if( part->part_int.part_type == RT_PARTICLE_TYPE_CYLINDER )  {
			/* The X' and Y' components of hit' are N' */
			hitp->hit_vpriv[Z] = 0;
			MAT4X3VEC( hitp->hit_normal, part->part_invRoS,
				hitp->hit_vpriv );
			VUNITIZE( hitp->hit_normal );
		} else {
			/* The cone case */
			FAST fastf_t	s, m;
			vect_t unorm;
			/* vpriv[Z] ranges from 0 to 1 (roughly) */
			/* Rescale X' and Y' into unit circle */
			m = part->part_hrad_prime - part->part_vrad_prime;
			s = 1/(part->part_vrad_prime + m * hitp->hit_vpriv[Z]);
			unorm[X] = hitp->hit_vpriv[X] * s;
			unorm[Y] = hitp->hit_vpriv[Y] * s;
			/* Z' is constant, from slope of cylinder wall*/
			unorm[Z] = -m / sqrt(m*m+1);
			MAT4X3VEC( hitp->hit_normal, part->part_invRoS, unorm );
			VUNITIZE( hitp->hit_normal );
		}
		break;
	}
}

/*
 *			R T _ P A R T _ C U R V E
 *
 *  Return the curvature of the particle.
 *  There are two cases:  hitting a hemisphere, and hitting the cylinder.
 */
void
rt_part_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	register struct part_specific *part =
		(struct part_specific *)stp->st_specific;
	point_t	hit_local;	/* hit_point, with V as origin */
	point_t	hit_unit;	/* hit_poit in unit coords, +Z along H */

	switch( hitp->hit_surfno )  {
	case RT_PARTICLE_SURF_VSPHERE:
	 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
	 	cvp->crv_c1 = cvp->crv_c2 = -part->part_int.part_vrad;
		break;
	case RT_PARTICLE_SURF_HSPHERE:
	 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
	 	cvp->crv_c1 = cvp->crv_c2 = -part->part_int.part_hrad;
		break;
	case RT_PARTICLE_SURF_BODY:
		/* Curvature in only one direction, around H */
		VCROSS( cvp->crv_pdir, hitp->hit_normal, part->part_int.part_H );
		VUNITIZE( cvp->crv_pdir );
		/* Interpolate radius between vrad and hrad */
		VSUB2( hit_local, hitp->hit_point, part->part_int.part_V );
		MAT4X3VEC( hit_unit, part->part_SoR, hit_local );
		/* hit_unit[Z] ranges from 0 at V to 1 at H, interpolate */
	 	cvp->crv_c1 = -(
			part->part_v_erad * hit_unit[Z] +
			part->part_h_erad * (1 - hit_unit[Z]) );
		cvp->crv_c2 = 0;
		break;
	}
}

/*
 *  			R T _ P A R T _ U V
 *  
 *  For a hit on the surface of a particle, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation along H
 *
 *  The 'u' coordinate wraps around the particle, once.
 *  The 'v' coordinate covers the 'height' of the particle,
 *  from V-r1 to (V+H)+r2.
 *
 *  hit_point has already been computed.
 */
void
rt_part_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register const struct part_specific *part =
		(struct part_specific *)stp->st_specific;
	point_t	hit_local;	/* hit_point, with V as origin */
	point_t	hit_unit;	/* hit_poit in unit coords, +Z along H */
	fastf_t hsize;
	fastf_t	hmag_inv;
	fastf_t vrad_unit;
	fastf_t	r;
	fastf_t minrad;

	RT_PART_CK_MAGIC(&part->part_int.part_magic);

	hmag_inv = 1.0/MAGNITUDE(part->part_int.part_H);
	hsize = 1 + (vrad_unit = part->part_v_erad*hmag_inv) +
		part->part_h_erad*hmag_inv;

	/* Transform hit point into unit particle coords */
	VSUB2( hit_local, hitp->hit_point, part->part_int.part_V );
	MAT4X3VEC( hit_unit, part->part_SoR, hit_local );
	/* normalize 0..1 */
	uvp->uv_v = (hit_unit[Z] + vrad_unit) / hsize;

	/* U is azimuth, atan() range: -pi to +pi */
	uvp->uv_u = bn_atan2( hit_unit[Y], hit_unit[X] ) * bn_inv2pi;
	if( uvp->uv_u < 0 )
		uvp->uv_u += 1.0;

	/* approximation: beam_r / (solid_circumference = 2 * pi * radius) */
	minrad = part->part_v_erad;
	V_MIN(minrad, part->part_h_erad);
	r = ap->a_rbeam + ap->a_diverge * hitp->hit_dist;
	uvp->uv_du = uvp->uv_dv =
		bn_inv2pi * r / minrad;
}

/*
 *		R T _ P A R T _ F R E E
 */
void
rt_part_free(register struct soltab *stp)
{
	register struct part_specific *part =
		(struct part_specific *)stp->st_specific;

	bu_free( (char *)part, "part_specific" );
	stp->st_specific = GENPTR_NULL;
}

/*
 *			R T _ P A R T _ C L A S S
 */
int
rt_part_class(void)
{
	return(0);
}

/*
 *			R T _ P A R T _ H E M I S P H E R E 8
 *
 *  Produce a crude approximation to a hemisphere,
 *  8 points around the rim [0]..[7],
 *  4 points around a midway latitude [8]..[11], and
 *  1 point at the pole [12].
 *
 *  For the dome, connect up:
 *	0 8 12 10 4
 *	2 9 12 11 6
 */
HIDDEN void
rt_part_hemisphere(register point_t (*ov), register fastf_t *v, fastf_t *a, fastf_t *b, fastf_t *h)
{
	register float cos45 = 0.707107;

	/* This is the top of the dome */
	VADD2( ov[12], v, h );

	VADD2( ov[0], v, a );
	VJOIN2( ov[1], v, cos45, a, cos45, b );
	VADD2( ov[2], v, b );
	VJOIN2( ov[3], v, -cos45, a, cos45, b );
	VSUB2( ov[4], v, a );
	VJOIN2( ov[5], v, -cos45, a, -cos45, b );
	VSUB2( ov[6], v, b );
	VJOIN2( ov[7], v, cos45, a, -cos45, b );

	VJOIN2( ov[8], v, cos45, a, cos45, h );
	VJOIN2( ov[10], v, -cos45, a, cos45, h );

	VJOIN2( ov[9], v, cos45, b, cos45, h );
	VJOIN2( ov[11], v, -cos45, b, cos45, h );
	/* Obviously, this could be optimized quite a lot more */
}

/*
 *			R T _ P A R T _ P L O T
 */
int
rt_part_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct rt_part_internal	*pip;
	point_t		tail;
	point_t		sphere_rim[16];
	point_t		vhemi[13];
	point_t		hhemi[13];
	vect_t		a, b, c;		/* defines coord sys of part */
	vect_t		as, bs, hs;		/* scaled by radius */
	vect_t		Hunit;
	register int	i;

	RT_CK_DB_INTERNAL(ip);
	pip = (struct rt_part_internal *)ip->idb_ptr;
	RT_PART_CK_MAGIC(pip);

	if( pip->part_type == RT_PARTICLE_TYPE_SPHERE )  {
		/* For the sphere, 3 rings of 16 points */
		VSET( a, pip->part_vrad, 0, 0 );
		VSET( b, 0, pip->part_vrad, 0 );
		VSET( c, 0, 0, pip->part_vrad );

		rt_ell_16pts( &sphere_rim[0][X], pip->part_V, a, b );
		RT_ADD_VLIST( vhead, sphere_rim[15], BN_VLIST_LINE_MOVE );
		for( i=0; i<16; i++ )  {
			RT_ADD_VLIST( vhead, sphere_rim[i], BN_VLIST_LINE_DRAW );
		}

		rt_ell_16pts( &sphere_rim[0][X], pip->part_V, b, c );
		RT_ADD_VLIST( vhead, sphere_rim[15], BN_VLIST_LINE_MOVE );
		for( i=0; i<16; i++ )  {
			RT_ADD_VLIST( vhead, sphere_rim[i], BN_VLIST_LINE_DRAW );
		}

		rt_ell_16pts( &sphere_rim[0][X], pip->part_V, a, c );
		RT_ADD_VLIST( vhead, sphere_rim[15], BN_VLIST_LINE_MOVE );
		for( i=0; i<16; i++ )  {
			RT_ADD_VLIST( vhead, sphere_rim[i], BN_VLIST_LINE_DRAW );
		}
		return(0);		/* OK */
	}

	VMOVE( Hunit, pip->part_H );
	VUNITIZE( Hunit );
	bn_vec_perp( a, Hunit );
	VUNITIZE(a);
	VCROSS( b, Hunit, a );
	VUNITIZE(b);

	VSCALE( as, a, pip->part_vrad );
	VSCALE( bs, b, pip->part_vrad );
	VSCALE( hs, Hunit, -pip->part_vrad );
	rt_part_hemisphere( vhemi, pip->part_V, as, bs, hs );

	VADD2( tail, pip->part_V, pip->part_H );
	VSCALE( as, a, pip->part_hrad );
	VSCALE( bs, b, pip->part_hrad );
	VSCALE( hs, Hunit, pip->part_hrad );
	rt_part_hemisphere( hhemi, tail, as, bs, hs );

	/* Draw V end hemisphere */
	RT_ADD_VLIST( vhead, vhemi[0], BN_VLIST_LINE_MOVE );
	for( i=7; i >= 0; i-- )  {
		RT_ADD_VLIST( vhead, vhemi[i], BN_VLIST_LINE_DRAW );
	}
	RT_ADD_VLIST( vhead, vhemi[8], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[12], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[10], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[4], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[2], BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, vhemi[9], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[12], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[11], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[6], BN_VLIST_LINE_DRAW );

	/* Draw H end hemisphere */
	RT_ADD_VLIST( vhead, hhemi[0], BN_VLIST_LINE_MOVE );
	for( i=7; i >= 0; i-- )  {
		RT_ADD_VLIST( vhead, hhemi[i], BN_VLIST_LINE_DRAW );
	}
	RT_ADD_VLIST( vhead, hhemi[8], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, hhemi[12], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, hhemi[10], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, hhemi[4], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, hhemi[2], BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, hhemi[9], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, hhemi[12], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, hhemi[11], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, hhemi[6], BN_VLIST_LINE_DRAW );

	/* Draw 4 connecting lines */
	RT_ADD_VLIST( vhead, vhemi[0], BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, hhemi[0], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[2], BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, hhemi[2], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[4], BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, hhemi[4], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[6], BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, hhemi[6], BN_VLIST_LINE_DRAW );

	return(0);
}

struct part_state {
	struct shell	*s;
	mat_t		upper_invRinvS;
	mat_t		upper_invRoS;
	mat_t		lower_invRinvS;
	mat_t		lower_invRoS;
	fastf_t		theta_tol;
};

struct part_vert_strip {
	int		nverts_per_strip;
	int		nverts;
	struct vertex	**vp;
	vect_t		*norms;
	int		nfaces;
	struct faceuse	**fu;
};

/*
 *			R T _ P A R T _ T E S S
 *
 *  Based upon the tesselator for the ellipsoid.
 *
 *  Break the particle into three parts:
 *	Upper hemisphere	0..nsegs			H	North
 *	middle cylinder		nsegs..nsegs+1
 *	lower hemisphere	nsegs+1..nstrips-1		V	South
 */
int
rt_part_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct rt_part_internal	*pip;
	LOCAL mat_t	R;
	LOCAL mat_t	S;
	LOCAL mat_t	invR;
	LOCAL mat_t	invS;
	LOCAL vect_t	zz;
	LOCAL vect_t	hcenter;
	struct part_state	state;
	register int		i;
	fastf_t		radius;
	int		nsegs;
	int		nstrips;
	struct part_vert_strip	*strips;
	int		j;
	struct vertex		**vertp[5];
	int	faceno;
	int	stripno;
	int	boff;		/* base offset */
	int	toff;		/* top offset */
	int	blim;		/* base subscript limit */
	int	tlim;		/* top subscrpit limit */
	fastf_t	rel;		/* Absolutized relative tolerance */

	RT_CK_DB_INTERNAL(ip);
	pip = (struct rt_part_internal *)ip->idb_ptr;
	RT_PART_CK_MAGIC(pip);

	if( pip->part_type == RT_PARTICLE_TYPE_SPHERE )
		return(-1);
	/* For now, concentrate on the most important kind. */

	VADD2( hcenter, pip->part_V, pip->part_H );

	/* Compute R and Rinv matrices */
	/* R is the same for both upper and lower hemispheres */
	/* R is rotation from model coords to unit sphere */
	/* For rotation of the particle, +H (model) becomes +Z (unit sph) */
	VSET( zz, 0, 0, 1 );
	bn_mat_fromto( R, pip->part_H, zz );
	bn_mat_trn( invR, R );			/* inv of rot mat is trn */

	/*** Upper (H) ***/

	/* Compute S and invS matrices */
	/* invS is just 1/diagonal elements */
	MAT_IDN( S );
	S[ 0] = S[ 5] = S[10] = 1/pip->part_hrad;
	bn_mat_inv( invS, S );

	/* invRinvS, for converting points from unit sphere to model */
	bn_mat_mul( state.upper_invRinvS, invR, invS );

	/* invRoS, for converting normals from unit sphere to model */
	bn_mat_mul( state.upper_invRoS, invR, S );

	/*** Lower (V) ***/

	/* Compute S and invS matrices */
	/* invS is just 1/diagonal elements */
	MAT_IDN( S );
	S[ 0] = S[ 5] = S[10] = 1/pip->part_vrad;
	bn_mat_inv( invS, S );

	/* invRinvS, for converting points from unit sphere to model */
	bn_mat_mul( state.lower_invRinvS, invR, invS );

	/* invRoS, for converting normals from unit sphere to model */
	bn_mat_mul( state.lower_invRoS, invR, S );

	/* Find the larger of two hemispheres */
	radius = pip->part_vrad;
	if( pip->part_hrad > radius )
		radius = pip->part_hrad;

	/*
	 *  Establish tolerances
	 */
	if( ttol->rel <= 0.0 || ttol->rel >= 1.0 )  {
		rel = 0.0;		/* none */
	} else {
		/* Convert rel to absolute by scaling by radius */
		rel = ttol->rel * radius;
	}
	if( ttol->abs <= 0.0 )  {
		if( rel <= 0.0 )  {
			/* No tolerance given, use a default */
			rel = 0.10 * radius;	/* 10% */
		} else {
			/* Use absolute-ized relative tolerance */
		}
	} else {
		/* Absolute tolerance was given, pick smaller */
		if( ttol->rel <= 0.0 || rel > ttol->abs )
		{
			rel = ttol->abs;
			if( rel > radius )
				rel = radius;
		}
	}

	/*
	 *  Converte distance tolerance into a maximum permissible
	 *  angle tolerance.  'radius' is largest radius.
	 */
	state.theta_tol = 2 * acos( 1.0 - rel / radius );

	/* To ensure normal tolerance, remain below this angle */
	if( ttol->norm > 0.0 && ttol->norm < state.theta_tol )  {
		state.theta_tol = ttol->norm;
	}

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	state.s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	/* Find the number of segments to divide 90 degrees worth into */
	nsegs = bn_halfpi / state.theta_tol + 0.999;
	if( nsegs < 2 )  nsegs = 2;

	/*  Find total number of strips of vertices that will be needed.
	 *  nsegs for each hemisphere, plus one equator each.
	 *  The two equators will be stitched together to make the cylinder.
	 *  Note that faces are listed in the the stripe ABOVE, ie, toward
	 *  the poles.  Thus, strips[0] will have 4 faces.
	 */
	nstrips = 2 * nsegs + 2;
	strips = (struct part_vert_strip *)bu_calloc( nstrips,
		sizeof(struct part_vert_strip), "strips[]" );

	/* North pole (Upper hemisphere, H end) */
	strips[0].nverts = 1;
	strips[0].nverts_per_strip = 0;
	strips[0].nfaces = 4;
	/* South pole (Lower hemispehre, V end) */
	strips[nstrips-1].nverts = 1;
	strips[nstrips-1].nverts_per_strip = 0;
	strips[nstrips-1].nfaces = 4;
	/* upper equator (has faces) */
	strips[nsegs].nverts = nsegs * 4;
	strips[nsegs].nverts_per_strip = nsegs;
	strips[nsegs].nfaces = nsegs * 4;
	/* lower equator (no faces) */
	strips[nsegs+1].nverts = nsegs * 4;
	strips[nsegs+1].nverts_per_strip = nsegs;
	strips[nsegs+1].nfaces = 0;

	for( i=1; i<nsegs; i++ )  {
		strips[i].nverts_per_strip =
			strips[nstrips-1-i].nverts_per_strip = i;
		strips[i].nverts =
			strips[nstrips-1-i].nverts = i * 4;
		strips[i].nfaces =
			strips[nstrips-1-i].nfaces = (2 * i + 1)*4;
	}
	/* All strips have vertices and normals */
	for( i=0; i<nstrips; i++ )  {
		strips[i].vp = (struct vertex **)bu_calloc( strips[i].nverts,
			sizeof(struct vertex *), "strip vertex[]" );
		strips[i].norms = (vect_t *)bu_calloc( strips[i].nverts,
			sizeof( vect_t ), "strip normals[]" );
	}
	/* All strips have faces, except for the one (marked) equator */
	for( i=0; i < nstrips; i++ )  {
		if( strips[i].nfaces <= 0 )  {
			strips[i].fu = (struct faceuse **)NULL;
			continue;
		}
		strips[i].fu = (struct faceuse **)bu_calloc( strips[i].nfaces,
			sizeof(struct faceuse *), "strip faceuse[]" );
	}

	/* First, build the triangular mesh topology */
	/* Do the top. "toff" in i-1 is UP, towards +B */
	for( i = 1; i <= nsegs; i++ )  {
		faceno = 0;
		tlim = strips[i-1].nverts;
		blim = strips[i].nverts;
		for( stripno=0; stripno<4; stripno++ )  {
			toff = stripno * strips[i-1].nverts_per_strip;
			boff = stripno * strips[i].nverts_per_strip;

			/* Connect this quarter strip */
			for( j = 0; j < strips[i].nverts_per_strip; j++ )  {

				/* "Right-side-up" triangle */
				vertp[0] = &(strips[i].vp[j+boff]);
				vertp[1] = &(strips[i].vp[(j+1+boff)%blim]);
				vertp[2] = &(strips[i-1].vp[(j+toff)%tlim]);
				if( (strips[i-1].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
					bu_log("rt_part_tess() nmg_cmface failure\n");
					goto fail;
				}
				if( j+1 >= strips[i].nverts_per_strip )  break;

				/* Follow with interior "Up-side-down" triangle */
				vertp[0] = &(strips[i].vp[(j+1+boff)%blim]);
				vertp[1] = &(strips[i-1].vp[(j+1+toff)%tlim]);
				vertp[2] = &(strips[i-1].vp[(j+toff)%tlim]);
				if( (strips[i-1].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
					bu_log("rt_part_tess() nmg_cmface failure\n");
					goto fail;
				}
			}
		}
	}

	/* Connect the two equators with rectangular (4-point) faces */
	i = nsegs+1;
	{
		faceno = 0;
		tlim = strips[i-1].nverts;
		blim = strips[i].nverts;
		{
			/* Connect this whole strip */
			for( j = 0; j < strips[i].nverts; j++ )  {

				/* "Right-side-up" rectangle */
				vertp[3] = &(strips[i].vp[(j)%blim]);
				vertp[2] = &(strips[i-1].vp[(j)%tlim]);
				vertp[1] = &(strips[i-1].vp[(j+1)%tlim]);
				vertp[0] = &(strips[i].vp[(j+1)%blim]);
				if( (strips[i-1].fu[faceno++] = nmg_cmface(state.s, vertp, 4 )) == 0 )  {
					bu_log("rt_part_tess() nmg_cmface failure\n");
					goto fail;
				}
			}
		}
	}

	/* Do the bottom.  Everything is upside down. "toff" in i+1 is DOWN */
	for( i = nsegs+1; i < nstrips; i++ )  {
		faceno = 0;
		tlim = strips[i+1].nverts;
		blim = strips[i].nverts;
		for( stripno=0; stripno<4; stripno++ )  {
			toff = stripno * strips[i+1].nverts_per_strip;
			boff = stripno * strips[i].nverts_per_strip;

			/* Connect this quarter strip */
			for( j = 0; j < strips[i].nverts_per_strip; j++ )  {

				/* "Right-side-up" triangle */
				vertp[0] = &(strips[i].vp[j+boff]);
				vertp[1] = &(strips[i+1].vp[(j+toff)%tlim]);
				vertp[2] = &(strips[i].vp[(j+1+boff)%blim]);
				if( (strips[i+1].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
					bu_log("rt_part_tess() nmg_cmface failure\n");
					goto fail;
				}
				if( j+1 >= strips[i].nverts_per_strip )  break;

				/* Follow with interior "Up-side-down" triangle */
				vertp[0] = &(strips[i].vp[(j+1+boff)%blim]);
				vertp[1] = &(strips[i+1].vp[(j+toff)%tlim]);
				vertp[2] = &(strips[i+1].vp[(j+1+toff)%tlim]);
				if( (strips[i+1].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
					bu_log("rt_part_tess() nmg_cmface failure\n");
					goto fail;
				}
			}
		}
	}

	/*  Compute the geometry of each vertex.
	 *  Start with the location in the unit sphere, and project back.
	 *  i=0 is "straight up" along +H.
	 */
	for( i=0; i < nstrips; i++ )  {
		double	alpha;		/* decline down from B to A */
		double	beta;		/* angle around equator (azimuth) */
		fastf_t		cos_alpha, sin_alpha;
		fastf_t		cos_beta, sin_beta;
		point_t		sphere_pt;
		point_t		model_pt;

		/* Compensate for extra equator */
		if( i <= nsegs )
			alpha = (((double)i) / (nstrips-1-1));
		else
			alpha = (((double)i-1) / (nstrips-1-1));
		cos_alpha = cos(alpha*bn_pi);
		sin_alpha = sin(alpha*bn_pi);
		for( j=0; j < strips[i].nverts; j++ )  {

			beta = ((double)j) / strips[i].nverts;
			cos_beta = cos(beta*bn_twopi);
			sin_beta = sin(beta*bn_twopi);
			VSET( sphere_pt,
				cos_beta * sin_alpha,
				sin_beta * sin_alpha,
				cos_alpha );
			/* Convert from ideal sphere coordinates */
			if( i <= nsegs )  {
				MAT4X3PNT( model_pt, state.upper_invRinvS, sphere_pt );
				VADD2( model_pt, model_pt, hcenter );
				/* Convert sphere normal to ellipsoid normal */
				MAT4X3VEC( strips[i].norms[j], state.upper_invRoS, sphere_pt );
			} else {
				MAT4X3PNT( model_pt, state.lower_invRinvS, sphere_pt );
				VADD2( model_pt, model_pt, pip->part_V );
				/* Convert sphere normal to ellipsoid normal */
				MAT4X3VEC( strips[i].norms[j], state.lower_invRoS, sphere_pt );
			}

			/* May not be unit length anymore */
			VUNITIZE( strips[i].norms[j] );
			/* Associate vertex geometry */
			nmg_vertex_gv( strips[i].vp[j], model_pt );
		}
	}

	/* Associate face geometry.  lower Equator has no faces */
	for( i=0; i < nstrips; i++ )  {
		for( j=0; j < strips[i].nfaces; j++ )  {
			if( nmg_fu_planeeqn( strips[i].fu[j], tol ) < 0 )
				goto fail;
		}
	}

	/* Associate normals with vertexuses */
	for( i=0; i < nstrips; i++ )
	{
		for( j=0; j < strips[i].nverts; j++ )
		{
			struct faceuse *fu;
			struct vertexuse *vu;
			vect_t norm_opp;

			NMG_CK_VERTEX( strips[i].vp[j] );
			VREVERSE( norm_opp , strips[i].norms[j] )

			for( BU_LIST_FOR( vu , vertexuse , &strips[i].vp[j]->vu_hd ) )
			{
				fu = nmg_find_fu_of_vu( vu );
				NMG_CK_FACEUSE( fu );
				/* get correct direction of normals depending on
				 * faceuse orientation
				 */
				if( fu->orientation == OT_SAME )
					nmg_vertexuse_nv( vu , strips[i].norms[j] );
				else if( fu->orientation == OT_OPPOSITE )
					nmg_vertexuse_nv( vu , norm_opp );
			}
		}
	}

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

	/* Release memory */
	/* All strips have vertices and normals */
	for( i=0; i<nstrips; i++ )  {
		bu_free( (char *)strips[i].vp, "strip vertex[]" );
		bu_free( (char *)strips[i].norms, "strip norms[]" );
	}
	/* All strips have faces, except for equator */
	for( i=0; i < nstrips; i++ )  {
		if( strips[i].fu == (struct faceuse **)0 )  continue;
		bu_free( (char *)strips[i].fu, "strip faceuse[]" );
	}
	bu_free( (char *)strips, "strips[]" );
	return(0);
fail:
	/* Release memory */
	/* All strips have vertices and normals */
	for( i=0; i<nstrips; i++ )  {
		bu_free( (char *)strips[i].vp, "strip vertex[]" );
		bu_free( (char *)strips[i].norms, "strip norms[]" );
	}
	/* All strips have faces, except for equator */
	for( i=0; i < nstrips; i++ )  {
		if( strips[i].fu == (struct faceuse **)0 )  continue;
		bu_free( (char *)strips[i].fu, "strip faceuse[]" );
	}
	bu_free( (char *)strips, "strips[]" );
	return(-1);
}

/*
 *			R T _ P A R T _ I M P O R T
 */
int
rt_part_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	point_t		v;
	vect_t		h;
	double		vrad;
	double		hrad;
	fastf_t		maxrad, minrad;
	union record	*rp;
	struct rt_part_internal	*part;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != DBID_PARTICLE )  {
		bu_log("rt_part_import: defective record\n");
		return(-1);
	}

	/* Convert from database to internal format */
	ntohd( (unsigned char *)v, rp->part.p_v, 3 );
	ntohd( (unsigned char *)h, rp->part.p_h, 3 );
	ntohd( (unsigned char *)&vrad, rp->part.p_vrad, 1 );
	ntohd( (unsigned char *)&hrad, rp->part.p_hrad, 1 );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_PARTICLE;
	ip->idb_meth = &rt_functab[ID_PARTICLE];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_part_internal), "rt_part_internal");
	part = (struct rt_part_internal *)ip->idb_ptr;
	part->part_magic = RT_PART_INTERNAL_MAGIC;

	/* Apply modeling transformations */
	MAT4X3PNT( part->part_V, mat, v );
	MAT4X3VEC( part->part_H, mat, h );
	if( (part->part_vrad = vrad / mat[15]) < 0 )  {
	  bu_log("unable to import particle, negative v radius\n");
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  return(-2);
	}
	if( (part->part_hrad = hrad / mat[15]) < 0 )  {
	  bu_log("unable to import particle, negative h radius\n");
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  return(-3);
	}

	if( part->part_vrad > part->part_hrad )  {
		maxrad = part->part_vrad;
		minrad = part->part_hrad;
	} else {
		maxrad = part->part_hrad;
		minrad = part->part_vrad;
	}
	if( maxrad <= 0 )  {
	  bu_log("unable to import particle, negative radius\n");
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  return(-4);
	}

	if( MAGSQ( part->part_H ) * 1000000 < maxrad * maxrad )  {
		/* Height vector is insignificant, particle is a sphere */
		part->part_vrad = part->part_hrad = maxrad;
		VSETALL( part->part_H, 0 );		/* sanity */
		part->part_type = RT_PARTICLE_TYPE_SPHERE;
		return(0);		/* OK */
	}

	if( (maxrad - minrad) / maxrad < 0.001 )  {
		/* radii are nearly equal, particle is a cylinder (lozenge) */
		part->part_vrad = part->part_hrad = maxrad;
		part->part_type = RT_PARTICLE_TYPE_CYLINDER;
		return(0);		/* OK */
	}

	part->part_type = RT_PARTICLE_TYPE_CONE;
	return(0);		/* OK */
}

/*
 *			R T _ P A R T _ E X P O R T
 */
int
rt_part_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_part_internal	*pip;
	union record		*rec;
	point_t		vert;
	vect_t		hi;
	fastf_t		vrad;
	fastf_t		hrad;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_PARTICLE )  return(-1);
	pip = (struct rt_part_internal *)ip->idb_ptr;
	RT_PART_CK_MAGIC(pip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "part external");
	rec = (union record *)ep->ext_buf;

	/* Convert from user units to mm */
	VSCALE( vert, pip->part_V, local2mm );
	VSCALE( hi, pip->part_H, local2mm );
	vrad = pip->part_vrad * local2mm;
	hrad = pip->part_hrad * local2mm;
	/* pip->part_type is not converted -- internal only */

	rec->part.p_id = DBID_PARTICLE;
	htond( rec->part.p_v, (unsigned char *)vert, 3 );
	htond( rec->part.p_h, (unsigned char *)hi, 3 );
	htond( rec->part.p_vrad, (unsigned char *)&vrad, 1 );
	htond( rec->part.p_hrad, (unsigned char *)&hrad, 1 );

	return(0);
}


/*
 *			R T _ P A R T _ I M P O R T 5
 */
int
rt_part_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	fastf_t			maxrad, minrad;
	struct rt_part_internal	*part;
	fastf_t			vec[8];

	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 8 );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_PARTICLE;
	ip->idb_meth = &rt_functab[ID_PARTICLE];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_part_internal), "rt_part_internal");

	part = (struct rt_part_internal *)ip->idb_ptr;
	part->part_magic = RT_PART_INTERNAL_MAGIC;
	
	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)vec, ep->ext_buf, 8 );
	
	/* Apply modeling transformations */
	MAT4X3PNT( part->part_V, mat, &vec[0*3] );
	MAT4X3VEC( part->part_H, mat, &vec[1*3] );
	if( (part->part_vrad = vec[2*3] / mat[15]) < 0 )  {
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  bu_log("unable to import particle, negative v radius\n");
	  return(-2);
	}
	if( (part->part_hrad = vec[2*3+1] / mat[15]) < 0 )  {
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  bu_log("unable to import particle, negative h radius\n");
	  return(-3);
	}

	if( part->part_vrad > part->part_hrad )  {
		maxrad = part->part_vrad;
		minrad = part->part_hrad;
	} else {
		maxrad = part->part_hrad;
		minrad = part->part_vrad;
	}
	if( maxrad <= 0 )  {
	  bu_free( ip->idb_ptr, "rt_part_internal" ); 
	  ip->idb_ptr=NULL;
	  bu_log("unable to import particle, negative radius\n");
	  return(-4);
	}

	if( MAGSQ( part->part_H ) * 1000000 < maxrad * maxrad )  {
		/* Height vector is insignificant, particle is a sphere */
		part->part_vrad = part->part_hrad = maxrad;
		VSETALL( part->part_H, 0 );		/* sanity */
		part->part_type = RT_PARTICLE_TYPE_SPHERE;
		return(0);		/* OK */
	}

	if( (maxrad - minrad) / maxrad < 0.001 )  {
		/* radii are nearly equal, particle is a cylinder (lozenge) */
		part->part_vrad = part->part_hrad = maxrad;
		part->part_type = RT_PARTICLE_TYPE_CYLINDER;
		return(0);		/* OK */
	}

	part->part_type = RT_PARTICLE_TYPE_CONE;
	return(0);		/* OK */
}

/*
 *			R T _ P A R T _ E X P O R T 5
 */
int
rt_part_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_part_internal	*pip;
	fastf_t			vec[8];

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_PARTICLE )  return(-1);
	pip = (struct rt_part_internal *)ip->idb_ptr;
	RT_PART_CK_MAGIC(pip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 8;
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "part external");

	/* scale 'em into local buffer */
	VSCALE( &vec[0*3], pip->part_V, local2mm );
	VSCALE( &vec[1*3], pip->part_H, local2mm );
	vec[2*3] = pip->part_vrad * local2mm;
	vec[2*3+1] = pip->part_hrad * local2mm;

	/* !!! should make sure the values are proper (no negative radius) */

	/* Convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, 8 );

	return(0);
}

/*
 *			R T _ P A R T _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_part_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_part_internal	*pip =
		(struct rt_part_internal *)ip->idb_ptr;
	char	buf[256];

	RT_PART_CK_MAGIC(pip);
	switch( pip->part_type )  {
	case RT_PARTICLE_TYPE_SPHERE:
		bu_vls_strcat( str, "spherical particle\n");
		sprintf(buf, "\tV (%g, %g, %g)\n",
			pip->part_V[X] * mm2local,
			pip->part_V[Y] * mm2local,
			pip->part_V[Z] * mm2local );
		bu_vls_strcat( str, buf );
		sprintf(buf, "\tradius = %g\n",
			pip->part_vrad * mm2local );
		bu_vls_strcat( str, buf );
		break;
	case RT_PARTICLE_TYPE_CYLINDER:
		bu_vls_strcat( str, "cylindrical particle (lozenge)\n");
		sprintf(buf, "\tV (%g, %g, %g)\n",
			pip->part_V[X] * mm2local,
			pip->part_V[Y] * mm2local,
			pip->part_V[Z] * mm2local );
		bu_vls_strcat( str, buf );
		sprintf(buf, "\tH (%g, %g, %g)\n",
			pip->part_H[X] * mm2local,
			pip->part_H[Y] * mm2local,
			pip->part_H[Z] * mm2local );
		bu_vls_strcat( str, buf );
		sprintf(buf, "\tradius = %g\n",
			pip->part_vrad * mm2local );
		bu_vls_strcat( str, buf );
		break;
	case RT_PARTICLE_TYPE_CONE:
		bu_vls_strcat( str, "conical particle\n");
		sprintf(buf, "\tV (%g, %g, %g)\n",
			pip->part_V[X] * mm2local,
			pip->part_V[Y] * mm2local,
			pip->part_V[Z] * mm2local );
		bu_vls_strcat( str, buf );
		sprintf(buf, "\tH (%g, %g, %g)\n",
			pip->part_H[X] * mm2local,
			pip->part_H[Y] * mm2local,
			pip->part_H[Z] * mm2local );
		bu_vls_strcat( str, buf );
		sprintf(buf, "\tv end radius = %g\n",
			pip->part_vrad * mm2local );
		bu_vls_strcat( str, buf );
		sprintf(buf, "\th end radius = %g\n",
			pip->part_hrad * mm2local );
		bu_vls_strcat( str, buf );
		break;
	default:
		bu_vls_strcat( str, "Unknown particle type\n");
		return(-1);
	}
	return(0);
}

/*
 *			R T _ P A R T _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_part_ifree(struct rt_db_internal *ip)
{
	RT_CK_DB_INTERNAL(ip);
	bu_free( ip->idb_ptr, "particle ifree" );
	ip->idb_ptr = GENPTR_NULL;
}
@


11.42
log
@change conf.h to a wrapped config.h
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /cvs/brlcad/librt/g_part.c,v 11.41 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.41
log
@merge of ansi-6-0-branch into HEAD
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header$ (BRL)";
d172 5
a176 1
#include "conf.h"
@


11.40
log
@update copyright to include span through 2003
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.39 2003/11/04 19:24:00 morrison Exp $ (BRL)";
d231 1
a231 4
rt_part_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d390 1
a390 2
rt_part_print( stp )
register const struct soltab *stp;
d432 1
a432 5
rt_part_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d730 6
a735 6
rt_part_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d746 1
a746 4
rt_part_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d796 1
a796 4
rt_part_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d843 1
a843 5
rt_part_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d884 1
a884 2
rt_part_free( stp )
register struct soltab *stp;
d897 1
a897 1
rt_part_class()
d915 1
a915 6
rt_part_hemisphere( ov, v, a, b, h )
register point_t ov[];
register point_t v;
vect_t		a;
vect_t		b;
vect_t		h;
d943 1
a943 5
rt_part_plot( vhead, ip, ttol, tol )
struct bu_list	*vhead;
struct rt_db_internal *ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1075 1
a1075 6
rt_part_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1458 1
a1458 5
rt_part_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1543 1
a1543 5
rt_part_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1583 1
a1583 5
rt_part_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1658 1
a1658 5
rt_part_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1694 1
a1694 5
rt_part_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1761 1
a1761 2
rt_part_ifree( ip )
struct rt_db_internal	*ip;
@


11.39
log
@fixed typo
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1990 by the United States Army.
d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.38 2003/11/03 19:43:14 morrison Exp $ (BRL)";
@


11.38
log
@cleaned up error checking for particle import
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.37 2003/01/10 18:50:46 morrison Exp $ (BRL)";
d1533 1
a1533 1
	  ip->idb->ptr=NULL;
d1539 1
a1539 1
	  ip->idb->ptr=NULL;
d1553 1
a1553 1
	  ip->idb->ptr=NULL;
a1609 2
	/* !!! should make sure the values are proper (no negative radius) */

d1618 1
@


11.37
log
@fixed a double-free bug in the particle primitive where a locally malloced pointer is freed after detecting an invalid value, the calling function then also tries to free the same memory.  the pointer needed to be set to null so that it is no longer accessible, I also added commenting to identify the different kinds of errors encountered during runtime.
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.36 2002/08/20 17:08:00 jra Exp $ (BRL)";
d909 1
d1531 4
a1534 2
		bu_free( ip->idb_ptr, "rt_part_internal" );
		return(-2);
d1537 4
a1540 2
		bu_free( ip->idb_ptr, "rt_part_internal" );
		return(-3);
d1551 4
a1554 2
		bu_free( ip->idb_ptr, "rt_part_internal" );
		return(-4);
d1610 2
d1727 2
@


11.37.6.1
log
@updates from HEAD, part 1
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.39 2003/11/04 19:24:00 morrison Exp $ (BRL)";
a908 1
	stp->st_specific = GENPTR_NULL;
d1530 2
a1531 4
	  bu_log("unable to import particle, negative v radius\n");
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  return(-2);
d1534 2
a1535 4
	  bu_log("unable to import particle, negative h radius\n");
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  return(-3);
d1546 2
a1547 4
	  bu_log("unable to import particle, negative radius\n");
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  return(-4);
a1611 1

a1717 2

	/* !!! should make sure the values are proper (no negative radius) */
@


11.37.6.2
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.40 2004/02/02 17:39:21 morrison Exp $ (BRL)";
@


11.37.6.3
log
@merge from head
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.37.6.2 2004/02/12 18:37:41 erikg Exp $ (BRL)";
@


11.36
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.34 2001/10/02 19:24:29 jra Exp $ (BRL)";
d1638 1
a1638 1

d1641 1
a1641 1

d1646 4
a1649 2
		bu_free( ip->idb_ptr, "rt_part_internal" );
		return(-2);
d1652 4
a1655 2
		bu_free( ip->idb_ptr, "rt_part_internal" );
		return(-3);
d1666 4
a1669 2
		bu_free( ip->idb_ptr, "rt_part_internal" );
		return(-4);
@


11.36.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_part.c,v 11.40 2004/02/02 17:39:21 morrison Exp $ (BRL)";
a908 1
	stp->st_specific = GENPTR_NULL;
d1530 2
a1531 4
	  bu_log("unable to import particle, negative v radius\n");
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  return(-2);
d1534 2
a1535 4
	  bu_log("unable to import particle, negative h radius\n");
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  return(-3);
d1546 2
a1547 4
	  bu_log("unable to import particle, negative radius\n");
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  return(-4);
a1611 1

d1638 1
a1638 1
	
d1641 1
a1641 1
	
d1646 2
a1647 4
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  bu_log("unable to import particle, negative v radius\n");
	  return(-2);
d1650 2
a1651 4
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  bu_log("unable to import particle, negative h radius\n");
	  return(-3);
d1662 2
a1663 4
	  bu_free( ip->idb_ptr, "rt_part_internal" ); 
	  ip->idb_ptr=NULL;
	  bu_log("unable to import particle, negative radius\n");
	  return(-4);
a1711 2

	/* !!! should make sure the values are proper (no negative radius) */
@


11.36.2.1
log
@Initial ANSIfication
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.36 2002/08/20 17:08:00 jra Exp $ (BRL)";
d231 4
a234 1
rt_part_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d393 2
a394 1
rt_part_print(register const struct soltab *stp)
d436 5
a440 1
rt_part_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d738 6
a743 6
rt_part_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d754 4
a757 1
rt_part_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d807 4
a810 1
rt_part_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d857 5
a861 1
rt_part_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d902 2
a903 1
rt_part_free(register struct soltab *stp)
d915 1
a915 1
rt_part_class(void)
d933 6
a938 1
rt_part_hemisphere(register point_t (*ov), register fastf_t *v, fastf_t *a, fastf_t *b, fastf_t *h)
d966 5
a970 1
rt_part_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1102 6
a1107 1
rt_part_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1490 5
a1494 1
rt_part_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1573 5
a1577 1
rt_part_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1616 5
a1620 1
rt_part_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1689 5
a1693 1
rt_part_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1727 5
a1731 1
rt_part_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1798 2
a1799 1
rt_part_ifree(struct rt_db_internal *ip)
@


11.36.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header$ (BRL)";
a889 1
	stp->st_specific = GENPTR_NULL;
d1493 2
a1494 4
	  bu_log("unable to import particle, negative v radius\n");
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  return(-2);
d1497 2
a1498 4
	  bu_log("unable to import particle, negative h radius\n");
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  return(-3);
d1509 2
a1510 4
	  bu_log("unable to import particle, negative radius\n");
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  return(-4);
a1570 1

d1593 1
a1593 1
	
d1596 1
a1596 1
	
d1601 2
a1602 4
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  bu_log("unable to import particle, negative v radius\n");
	  return(-2);
d1605 2
a1606 4
	  bu_free( ip->idb_ptr, "rt_part_internal" );
	  ip->idb_ptr=NULL;
	  bu_log("unable to import particle, negative h radius\n");
	  return(-3);
d1617 2
a1618 4
	  bu_free( ip->idb_ptr, "rt_part_internal" ); 
	  ip->idb_ptr=NULL;
	  bu_log("unable to import particle, negative radius\n");
	  return(-4);
a1662 2

	/* !!! should make sure the values are proper (no negative radius) */
@


11.35
log
@Converted from K&R to ANSI C - RFH
@
text
@d231 4
a234 1
rt_part_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d393 2
a394 1
rt_part_print(register const struct soltab *stp)
d436 5
a440 1
rt_part_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d738 6
a743 6
rt_part_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d754 4
a757 1
rt_part_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d807 4
a810 1
rt_part_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d857 5
a861 1
rt_part_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d902 2
a903 1
rt_part_free(register struct soltab *stp)
d915 1
a915 1
rt_part_class(void)
d933 6
a938 1
rt_part_hemisphere(register point_t (*ov), register fastf_t *v, fastf_t *a, fastf_t *b, fastf_t *h)
d966 5
a970 1
rt_part_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1102 6
a1107 1
rt_part_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1490 5
a1494 1
rt_part_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1573 5
a1577 1
rt_part_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1616 5
a1620 1
rt_part_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1689 5
a1693 1
rt_part_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1727 5
a1731 1
rt_part_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1798 2
a1799 1
rt_part_ifree(struct rt_db_internal *ip)
@


11.34
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.33 2001/04/05 19:35:34 morrison Exp $ (BRL)";
d231 1
a231 4
rt_part_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d390 1
a390 2
rt_part_print( stp )
register const struct soltab *stp;
d432 1
a432 5
rt_part_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d730 6
a735 6
rt_part_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d746 1
a746 4
rt_part_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d796 1
a796 4
rt_part_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d843 1
a843 5
rt_part_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d884 1
a884 2
rt_part_free( stp )
register struct soltab *stp;
d896 1
a896 1
rt_part_class()
d914 1
a914 6
rt_part_hemisphere( ov, v, a, b, h )
register point_t ov[];
register point_t v;
vect_t		a;
vect_t		b;
vect_t		h;
d942 1
a942 5
rt_part_plot( vhead, ip, ttol, tol )
struct bu_list	*vhead;
struct rt_db_internal *ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1074 1
a1074 6
rt_part_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1457 1
a1457 5
rt_part_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1536 1
a1536 5
rt_part_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1575 1
a1575 5
rt_part_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1644 1
a1644 5
rt_part_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1678 1
a1678 5
rt_part_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1745 1
a1745 2
rt_part_ifree( ip )
struct rt_db_internal	*ip;
@


11.33
log
@updated SIGNED to signed
updated CONST to const
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.32 2001/03/31 01:57:08 morrison Exp $ (BRL)";
d1519 1
d1631 1
@


11.32
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.31 2000/10/18 18:10:34 butler Exp $ (BRL)";
d205 1
a205 1
CONST struct bu_structparse rt_part_parse[] = {
d394 1
a394 1
register CONST struct soltab *stp;
d396 1
a396 1
	register CONST struct part_specific *part =
d863 1
a863 1
	register CONST struct part_specific *part =
d969 2
a970 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d1106 2
a1107 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d1492 3
a1494 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1574 1
a1574 1
CONST struct rt_db_internal	*ip;
d1576 1
a1576 1
CONST struct db_i		*dbip;
d1617 3
a1619 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1689 1
a1689 1
CONST struct rt_db_internal	*ip;
d1691 1
a1691 1
CONST struct db_i		*dbip;
d1727 1
a1727 1
CONST struct rt_db_internal	*ip;
@


11.31
log
@Patches for compiling under RedHat 7.0
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.30 2000/08/21 02:02:30 butler Exp $ (BRL)";
d338 1
a338 1
	bn_mat_idn( R );
d345 1
a345 1
	bn_mat_idn( S );
d1154 1
a1154 1
	bn_mat_idn( S );
d1168 1
a1168 1
	bn_mat_idn( S );
@


11.30
log
@Massive compilation warnings eliminated
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.29 2000/07/10 23:01:33 mike Exp $ (BRL)";
d175 3
@


11.29
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d169 1
a169 1
static const char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.28 2000/06/30 15:38:03 mike Exp $ (BRL)";
d207 2
a208 1
    {0} };
@


11.28
log
@
export methods should not init the external structure, just check them.
@
text
@d169 1
a169 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.27 2000/06/30 15:31:15 mike Exp $ (BRL)";
@


11.27
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d169 1
a169 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.26 2000/06/27 15:33:31 bparker Exp $ (BRL)";
d1586 1
a1586 1
	BU_INIT_EXTERNAL(ep);
d1697 1
a1697 1
	BU_INIT_EXTERNAL(ep);
@


11.26
log
@Call BU_ASSERT_LONG.
@
text
@d169 1
a169 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.25 2000/06/27 14:34:48 bparker Exp $ (BRL)";
d1514 1
a1514 1
	RT_INIT_DB_INTERNAL( ip );
d1625 1
a1625 1
	RT_INIT_DB_INTERNAL( ip );
@


11.25
log
@Add rt_part_import5 and rt_part_export5 routines.
@
text
@d169 1
a169 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.24 2000/04/12 02:34:34 mike Exp $ (BRL)";
d1622 2
@


11.24
log
@
NT port, non-compat4
@
text
@d169 1
a169 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.23 2000/01/13 22:03:06 mike Exp $ (BRL)";
d1603 104
@


11.23
log
@
Lee discovered that really extreme particles don't have
"equivalent cones" at all.
Added code to check for this case, and not make NaN's.
@
text
@d169 1
a169 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.22 1999/12/22 02:24:05 mike Exp $ (BRL)";
d280 1
a280 1
	vec_ortho( a, Hunit );
d815 1
a815 1
	 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
d819 1
a819 1
	 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
d1010 1
a1010 1
	vec_perp( a, Hunit );
@


11.22
log
@
Removed dead vars
@
text
@d169 1
a169 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.21 1999/12/17 04:15:35 mike Exp $ (BRL)";
d244 1
d273 4
a285 7
	r_diff = (pip->part_vrad - pip->part_hrad) * inv_hlen;
	sin_theta = sqrt( 1 - r_diff * r_diff );
	cos_theta = fabs( r_diff );

	/* This makes them larger */
	part->part_v_erad = pip->part_vrad / sin_theta;
	part->part_h_erad = pip->part_hrad / sin_theta;
d288 16
a303 1
	if( pip->part_vrad > pip->part_hrad )  {
d308 15
d396 1
a396 1
	VPRINT("part_H", part->part_int.part_V );
d850 1
a850 1
 *  hit_point and hit_normal have already been computed.
d868 2
@


11.21
log
@
The "equivalent cone" version, which has the tangent matching between
the cylinder and the hemisphere.
@
text
@d169 1
a169 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.20 1999/12/07 02:22:33 mike Exp $ (BRL)";
a1081 1
	LOCAL fastf_t	f;
@


11.20
log
@
Quiet, working version of 4-hit resolution heuristic.
@
text
@d10 1
a10 1
 *  Author -
d12 1
d158 9
d169 1
a169 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.19 1999/12/07 02:18:27 mike Exp $ (BRL)";
d188 7
d240 6
d270 5
a274 2
	VMOVE( Hunit, pip->part_H );
	VUNITIZE( Hunit );
d278 27
d312 1
a312 1
	/* Compute scale matrix S */
d314 1
a314 1
	S[ 0] = 1.0 / pip->part_vrad;	/* |A| = |B| */
d316 1
a316 1
	S[10] = 1.0 / MAGNITUDE( pip->part_H );
d496 1
a496 3
#define VRAD_PRIME	1
#define HRAD_PRIME	(part->part_int.part_hrad / part->part_int.part_vrad)
		m = HRAD_PRIME - VRAD_PRIME;
d505 1
a505 1
			m * dprime[Z];		/* * VRAD_PRIME */
d523 1
a523 1
	if( (f = pprime[Z] + t1 * dprime[Z]) >= 0.0 )  {
d525 1
a525 1
		if( f <= 1.0 )  {
d539 1
a539 1
	if( (f = pprime[Z] + t2 * dprime[Z]) >= 0.0 )  {
d541 1
a541 1
		if( f <= 1.0 )  {
d590 1
a590 1
		if( pprime[Z] + t1 * dprime[Z] <= 0.0 )  {
d597 1
a597 1
		if( pprime[Z] + t2 * dprime[Z] <= 0.0 )  {
d638 1
a638 1
		if( pprime[Z] + t1 * dprime[Z] >= 1.0 )  {
d645 1
a645 1
		if( pprime[Z] + t2 * dprime[Z] >= 1.0 )  {
d752 2
d755 4
a758 4
			s = 1 / ( VRAD_PRIME + (m = HRAD_PRIME-VRAD_PRIME) *
				hitp->hit_vpriv[Z] );
			hitp->hit_vpriv[X] *= s;
			hitp->hit_vpriv[Y] *= s;
d760 2
a761 3
			hitp->hit_vpriv[Z] = -m / sqrt(m*m+1);
			MAT4X3VEC( hitp->hit_normal, part->part_invRoS,
				hitp->hit_vpriv );
d803 2
a804 2
			part->part_int.part_vrad * hit_unit[Z] +
			part->part_int.part_hrad * (1 - hit_unit[Z]) );
d842 2
a843 2
	hsize = 1 + (vrad_unit = part->part_int.part_vrad*hmag_inv) +
		part->part_int.part_hrad*hmag_inv;
d857 2
a858 2
	minrad = part->part_int.part_vrad;
	V_MIN(minrad, part->part_int.part_hrad);
@


11.19
log
@
This version with extensive debugging,
to prove that the recovery heuristic is doing the right thing.
@
text
@d159 1
a159 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.18 1999/12/06 17:04:02 mike Exp $ (BRL)";
d615 3
a617 1
		 *  return the maximum extent of the ray..
a618 10
		/* XXX Remove printing after testing is complete */
		struct bu_vls	str;
		bu_vls_init(&str);
		bu_vls_printf(&str, "rt_part_shot(%s): %d hits\n",
			stp->st_name, hitp - &hits[0] );
bu_vls_printf(&str, "x=%d, y=%d, pt=(%g, %g, %g), dir=(%g, %g, %g)\n",
ap->a_x, ap->a_y, V3ARGS(rp->r_pt), V3ARGS(rp->r_dir) );
		rt_pr_hitarray_vls( &str, "unsorted particle:\n", hits, hitp - &hits[0] );

		/* Sort, take max and min values */
a619 16
		rt_pr_hitarray_vls( &str, "sorted particle:\n", hits, hitp - &hits[0] );
if( hitp - &hits[0] == 4 ) {
	FILE	*fp = fopen("part.pl", "w");
	point_t	a, b;
	VJOIN1( a, rp->r_pt, hits[0].hit_dist, rp->r_dir );
	VJOIN1( b, rp->r_pt, hits[1].hit_dist, rp->r_dir );
	pdv_3line( fp, a, b );
	VJOIN1( a, rp->r_pt, hits[2].hit_dist, rp->r_dir );
	VJOIN1( b, rp->r_pt, hits[3].hit_dist, rp->r_dir );
	pdv_3line( fp, a, b );
	fclose(fp);
	bu_vls_printf(&str,"Wrote part.pl\n");
}

		bu_log("%s", bu_vls_addr(&str));
		bu_vls_free(&str);
d621 1
a621 1
		/* [0] is minimum, make [1] be maximum */
@


11.18
log
@
Oops, typo
@
text
@d159 1
a159 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.17 1999/12/06 16:58:35 mike Exp $ (BRL)";
d538 1
a538 1
		/* see if hit'[Z] is below end of cylinder */
d586 1
d609 8
a616 1
		/* Particle is convex, take maximum extent. */
d622 3
a624 1
		rt_pr_hitarray_vls( &str, "unsorted particle", hits, hitp - &hits[0] );
d628 13
a640 1
		rt_pr_hitarray_vls( &str, "sorted particle", hits, hitp - &hits[0] );
@


11.17
log
@Added better handling of case where particle gets 3 or 4 hits, by taking
maximum extent.
@
text
@d159 1
a159 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.16 1999/12/06 16:22:42 mike Exp $ (BRL)";
d612 1
a612 1
		bu_vps_printf(&str, "rt_part_shot(%s): %d hits\n",
@


11.16
log
@
Added curvature routine
@
text
@d155 1
a155 1
 *  THE END PLATES.
a156 11
 *  If Dz' == 0, line L' is parallel to the end plates, so there is no hit.
 *
 *  Otherwise, the line L' hits the bottom plate with k = (0 - Pz') / Dz',
 *  and hits the top plate with k = (1 - Pz') / Dz'.
 *
 *  The solution W' is within the end plate IFF
 *
 *	Wx'**2 + Wy'**2 <= 1.0
 *
 *  The normal for a hit on the bottom plate is -Hunit, and
 *  the normal for a hit on the top plate is +Hunit.
d159 1
a159 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.15 1999/12/01 23:58:23 mike Exp $ (BRL)";
d608 17
a624 3
		bu_log("rt_part_shot(%s): %d hits? surf0=%d\n",
			stp->st_name, hitp - &hits[0],
			hits[0].hit_surfno );
@


11.15
log
@
Added UV map for the particle.
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.14 1999/11/26 21:46:47 mike Exp $ (BRL)";
d718 2
a719 1
 *  Return the curvature of the part.
d727 4
a730 1
 	cvp->crv_c1 = cvp->crv_c2 = 0;
d732 23
a754 2
	/* any tangent direction */
 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.14
log
@
Lint cleanups
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.13 1999/11/24 23:12:08 mike Exp $ (BRL)";
d735 1
a735 1
 *  For a hit on the surface of an part, return the (u,v) coordinates
d738 1
a738 1
 *  v = elevation
d753 1
a753 1
	register struct part_specific *part =
d755 29
@


11.13
log
@
Made structparse tables CONST
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.12 1999/11/24 21:39:49 mike Exp $ (BRL)";
d829 1
a829 1
struct bn_tol		*tol;
d851 1
a851 1
		rt_ell_16pts( sphere_rim, pip->part_V, a, b );
d857 1
a857 1
		rt_ell_16pts( sphere_rim, pip->part_V, b, c );
d863 1
a863 1
		rt_ell_16pts( sphere_rim, pip->part_V, a, c );
d941 1
a941 1
struct vert_strip {
d966 1
a966 1
struct bn_tol		*tol;
d981 1
a981 1
	struct vert_strip	*strips;
d1094 2
a1095 2
	strips = (struct vert_strip *)bu_calloc( nstrips,
		sizeof(struct vert_strip), "strips[]" );
d1350 1
a1350 1
rt_part_import( ip, ep, mat )
d1354 1
d1432 1
a1432 1
rt_part_export( ep, ip, local2mm )
d1436 1
d1481 1
a1481 1
struct rt_db_internal	*ip;
@


11.12
log
@
Added comment
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.11 1999/11/17 02:42:00 mike Exp $ (BRL)";
d196 1
a196 1
struct bu_structparse rt_part_parse[] = {
@


11.11
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.10 1999/10/30 03:53:27 mike Exp $ (BRL)";
d739 6
d753 2
a754 2
/*	register struct part_specific *part =
		(struct part_specific *)stp->st_specific; */
@


11.10
log
@
Added magic numbers for ray, hit, and application structures.
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.9 1999/07/02 22:47:22 mike Exp $ (BRL)";
d1373 1
@


11.9
log
@
Fixed script-induced typos
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.8 1999/07/02 22:19:23 mike Exp $ (BRL)";
d412 1
d415 1
d486 1
d502 1
d551 1
d558 1
d598 1
d605 1
@


11.8
log
@
Removed dependence on compat4.h
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.7 1999/05/27 19:10:40 mike Exp $ (BRL)";
d747 1
a747 1
rt_pabu_free( stp )
@


11.7
log
@
sed4
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.6 1999/05/11 15:16:47 mike Exp $ (BRL)";
d747 1
a747 1
rt_part_free( stp )
d838 1
a838 1
		RT_ADD_VLIST( vhead, sphere_rim[15], RT_VLIST_LINE_MOVE );
d840 1
a840 1
			RT_ADD_VLIST( vhead, sphere_rim[i], RT_VLIST_LINE_DRAW );
d844 1
a844 1
		RT_ADD_VLIST( vhead, sphere_rim[15], RT_VLIST_LINE_MOVE );
d846 1
a846 1
			RT_ADD_VLIST( vhead, sphere_rim[i], RT_VLIST_LINE_DRAW );
d850 1
a850 1
		RT_ADD_VLIST( vhead, sphere_rim[15], RT_VLIST_LINE_MOVE );
d852 1
a852 1
			RT_ADD_VLIST( vhead, sphere_rim[i], RT_VLIST_LINE_DRAW );
d876 1
a876 1
	RT_ADD_VLIST( vhead, vhemi[0], RT_VLIST_LINE_MOVE );
d878 1
a878 1
		RT_ADD_VLIST( vhead, vhemi[i], RT_VLIST_LINE_DRAW );
d880 9
a888 9
	RT_ADD_VLIST( vhead, vhemi[8], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[12], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[10], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[4], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[2], RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, vhemi[9], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[12], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[11], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[6], RT_VLIST_LINE_DRAW );
d891 1
a891 1
	RT_ADD_VLIST( vhead, hhemi[0], RT_VLIST_LINE_MOVE );
d893 1
a893 1
		RT_ADD_VLIST( vhead, hhemi[i], RT_VLIST_LINE_DRAW );
d895 9
a903 9
	RT_ADD_VLIST( vhead, hhemi[8], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, hhemi[12], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, hhemi[10], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, hhemi[4], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, hhemi[2], RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, hhemi[9], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, hhemi[12], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, hhemi[11], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, hhemi[6], RT_VLIST_LINE_DRAW );
d906 8
a913 8
	RT_ADD_VLIST( vhead, vhemi[0], RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, hhemi[0], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[2], RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, hhemi[2], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[4], RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, hhemi[4], RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, vhemi[6], RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, hhemi[6], RT_VLIST_LINE_DRAW );
@


11.6
log
@Polygon drawing order was backwards for hemispheres,
according to visualization as seen in mged "ev" command.
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.5 1999/05/08 05:40:15 mike Exp $ (BRL)";
d239 1
a239 1
	GETSTRUCT( part, part_specific );
d264 1
a264 1
	mat_idn( R );
d268 1
a268 1
	mat_trn( Rinv, R );
d271 1
a271 1
	mat_idn( S );
d276 2
a277 2
	mat_mul( part->part_SoR, S, R );
	mat_mul( part->part_invRoS, Rinv, S );
d327 2
a328 2
	rt_log("part_vrad=%g\n", part->part_int.part_vrad );
	rt_log("part_hrad=%g\n", part->part_int.part_hrad );
d332 1
a332 1
		rt_log("part_type = SPHERE\n");
d335 3
a337 3
		rt_log("part_type = CYLINDER\n");
		mat_print("part_SoR", part->part_SoR );
		mat_print("part_invRoS", part->part_invRoS );
d340 3
a342 3
		rt_log("part_type = CONE\n");
		mat_print("part_SoR", part->part_SoR );
		mat_print("part_invRoS", part->part_invRoS );
d345 1
a345 1
		rt_log("part_type = %d ???\n", part->part_int.part_type );
d416 1
a416 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d611 1
a611 1
		rt_log("rt_part_shot(%s): %d hits? surf0=%d\n",
d624 1
a624 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d633 1
a633 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d753 1
a753 1
	rt_free( (char *)part, "part_specific" );
d812 1
a812 1
struct rt_list	*vhead;
d815 1
a815 1
struct rt_tol		*tol;
d952 1
a952 1
struct rt_tol		*tol;
d994 1
a994 1
	mat_trn( invR, R );			/* inv of rot mat is trn */
d1000 1
a1000 1
	mat_idn( S );
d1002 1
a1002 1
	mat_inv( invS, S );
d1005 1
a1005 1
	mat_mul( state.upper_invRinvS, invR, invS );
d1008 1
a1008 1
	mat_mul( state.upper_invRoS, invR, S );
d1014 1
a1014 1
	mat_idn( S );
d1016 1
a1016 1
	mat_inv( invS, S );
d1019 1
a1019 1
	mat_mul( state.lower_invRinvS, invR, invS );
d1022 1
a1022 1
	mat_mul( state.lower_invRoS, invR, S );
d1067 1
a1067 1
	state.s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d1070 1
a1070 1
	nsegs = rt_halfpi / state.theta_tol + 0.999;
d1080 1
a1080 1
	strips = (struct vert_strip *)rt_calloc( nstrips,
d1110 1
a1110 1
		strips[i].vp = (struct vertex **)rt_calloc( strips[i].nverts,
d1112 1
a1112 1
		strips[i].norms = (vect_t *)rt_calloc( strips[i].nverts,
d1121 1
a1121 1
		strips[i].fu = (struct faceuse **)rt_calloc( strips[i].nfaces,
d1143 1
a1143 1
					rt_log("rt_part_tess() nmg_cmface failure\n");
d1153 1
a1153 1
					rt_log("rt_part_tess() nmg_cmface failure\n");
d1176 1
a1176 1
					rt_log("rt_part_tess() nmg_cmface failure\n");
d1200 1
a1200 1
					rt_log("rt_part_tess() nmg_cmface failure\n");
d1210 1
a1210 1
					rt_log("rt_part_tess() nmg_cmface failure\n");
d1234 2
a1235 2
		cos_alpha = cos(alpha*rt_pi);
		sin_alpha = sin(alpha*rt_pi);
d1239 2
a1240 2
			cos_beta = cos(beta*rt_twopi);
			sin_beta = sin(beta*rt_twopi);
d1285 1
a1285 1
			for( RT_LIST_FOR( vu , vertexuse , &strips[i].vp[j]->vu_hd ) )
d1306 2
a1307 2
		rt_free( (char *)strips[i].vp, "strip vertex[]" );
		rt_free( (char *)strips[i].norms, "strip norms[]" );
d1312 1
a1312 1
		rt_free( (char *)strips[i].fu, "strip faceuse[]" );
d1314 1
a1314 1
	rt_free( (char *)strips, "strips[]" );
d1320 2
a1321 2
		rt_free( (char *)strips[i].vp, "strip vertex[]" );
		rt_free( (char *)strips[i].norms, "strip norms[]" );
d1326 1
a1326 1
		rt_free( (char *)strips[i].fu, "strip faceuse[]" );
d1328 1
a1328 1
	rt_free( (char *)strips, "strips[]" );
d1338 1
a1338 1
CONST struct rt_external	*ep;
d1349 1
a1349 1
	RT_CK_EXTERNAL( ep );
d1353 1
a1353 1
		rt_log("rt_part_import: defective record\n");
d1365 1
a1365 1
	ip->idb_ptr = rt_malloc( sizeof(struct rt_part_internal), "rt_part_internal");
d1373 1
a1373 1
		rt_free( ip->idb_ptr, "rt_part_internal" );
d1377 1
a1377 1
		rt_free( ip->idb_ptr, "rt_part_internal" );
d1389 1
a1389 1
		rt_free( ip->idb_ptr, "rt_part_internal" );
d1417 1
a1417 1
struct rt_external		*ep;
d1433 1
a1433 1
	RT_INIT_EXTERNAL(ep);
d1435 1
a1435 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "part external");
d1463 1
a1463 1
struct rt_vls		*str;
d1475 1
a1475 1
		rt_vls_strcat( str, "spherical particle\n");
d1480 1
a1480 1
		rt_vls_strcat( str, buf );
d1483 1
a1483 1
		rt_vls_strcat( str, buf );
d1486 1
a1486 1
		rt_vls_strcat( str, "cylindrical particle (lozenge)\n");
d1491 1
a1491 1
		rt_vls_strcat( str, buf );
d1496 1
a1496 1
		rt_vls_strcat( str, buf );
d1499 1
a1499 1
		rt_vls_strcat( str, buf );
d1502 1
a1502 1
		rt_vls_strcat( str, "conical particle\n");
d1507 1
a1507 1
		rt_vls_strcat( str, buf );
d1512 1
a1512 1
		rt_vls_strcat( str, buf );
d1515 1
a1515 1
		rt_vls_strcat( str, buf );
d1518 1
a1518 1
		rt_vls_strcat( str, buf );
d1521 1
a1521 1
		rt_vls_strcat( str, "Unknown particle type\n");
d1537 1
a1537 1
	rt_free( ip->idb_ptr, "particle ifree" );
@


11.5
log
@Implemented tessellation for the particle solid.
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.4 1999/01/13 21:54:04 mike Exp $ (BRL)";
d1140 2
a1141 2
				vertp[1] = &(strips[i-1].vp[(j+toff)%tlim]);
				vertp[2] = &(strips[i].vp[(j+1+boff)%blim]);
d1150 2
a1151 2
				vertp[1] = &(strips[i-1].vp[(j+toff)%tlim]);
				vertp[2] = &(strips[i-1].vp[(j+1+toff)%tlim]);
d1197 2
a1198 2
				vertp[1] = &(strips[i].vp[(j+1+boff)%blim]);
				vertp[2] = &(strips[i+1].vp[(j+toff)%tlim]);
d1207 2
a1208 2
				vertp[1] = &(strips[i+1].vp[(j+1+toff)%tlim]);
				vertp[2] = &(strips[i+1].vp[(j+toff)%tlim]);
@


11.4
log
@Fixed htond() arg types
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_part.c,v 11.3 1997/06/17 19:29:31 gdurf Exp $ (BRL)";
d245 1
d918 18
d938 7
d954 375
@


11.3
log
@Added bu_structparse (from tcl.c)
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 11.2 1995/03/11 03:14:44 mike Exp gdurf $ (BRL)";
d957 4
a960 4
	ntohd( v, rp->part.p_v, 3 );
	ntohd( h, rp->part.p_h, 3 );
	ntohd( &vrad, rp->part.p_vrad, 1 );
	ntohd( &hrad, rp->part.p_hrad, 1 );
d1045 4
a1048 4
	htond( rec->part.p_v, vert, 3 );
	htond( rec->part.p_h, hi, 3 );
	htond( rec->part.p_vrad, &vrad, 1 );
	htond( rec->part.p_hrad, &hrad, 1 );
@


11.2
log
@Increased hits[] to [4].  I've seen one ray with 4 hits!!.
In case of 1 hit, make it a 0-thickness segment.
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 11.1 1995/01/04 09:56:51 mike Rel4_4 mike $ (BRL)";
d196 7
@


11.1
log
@Release_4.4
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 10.4 94/11/04 05:45:10 mike Exp $ (BRL)";
d368 1
a368 1
	LOCAL struct hit hits[3];	/* 4 potential hit points */
d596 7
a602 1
	if( (hitp - &hits[0]) & 1 )  {
a606 2
	if( hitp != &hits[2] )
		return(0);	/* MISS */
@


10.4
log
@Irix 6
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 10.3 94/09/30 16:24:50 mike Exp Locker: mike $ (BRL)";
@


10.3
log
@Null out ip->idb_ptr after freeing memory in rt_*_ifree()
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 10.2 94/08/10 18:37:00 gdurf Exp Locker: mike $ (BRL)";
a705 3
	register struct part_specific *part =
		(struct part_specific *)stp->st_specific;

@


10.2
log
@Added include of conf.h
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 10.1 1991/10/12 06:40:20 mike Rel4_0 gdurf $ (BRL)";
d1129 1
@


10.1
log
@Release_4.0
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.23 91/09/20 23:16:18 butler Exp $ (BRL)";
d172 2
@


1.23
log
@removing fuzz with lint
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.22 91/06/30 00:10:54 mike Exp $ (BRL)";
@


1.22
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.21 91/06/22 22:30:28 mike Exp $ (BRL)";
a218 1
	int			i;
d728 2
a729 2
	register struct part_specific *part =
		(struct part_specific *)stp->st_specific;
@


1.21
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.20 91/05/18 03:01:03 mike Exp $ (BRL)";
d311 1
a311 1
register struct soltab *stp;
d313 1
a313 1
	register struct part_specific *part =
d927 3
a929 3
struct rt_db_internal	*ip;
struct rt_external	*ep;
register mat_t		mat;
d1007 3
a1009 3
struct rt_external	*ep;
struct rt_db_internal	*ip;
double			local2mm;
@


1.20
log
@Converted to new tolerance interface
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.19 91/01/28 23:53:13 mike Exp $ (BRL)";
d212 1
a212 1
rt_part_prep( stp, ip, rtip, tol )
a215 1
CONST struct rt_tol	*tol;
d353 1
a353 1
rt_part_shot( stp, rp, ap, seghead, tol )
a357 1
CONST struct rt_tol	*tol;
d633 1
a633 1
rt_part_vshot( stp, rp, segp, n, resp, tol )
d638 1
a638 2
struct resource         *resp; /* pointer to a list of free segs */
CONST struct rt_tol	*tol;
d640 1
a640 1
	rt_vstub( stp, rp, segp, n, resp, tol );
@


1.19
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.18 91/01/26 03:14:51 mike Exp $ (BRL)";
d212 1
a212 1
rt_part_prep( stp, ip, rtip )
d216 1
d354 1
a354 1
rt_part_shot( stp, rp, ap, seghead )
d359 1
d635 1
a635 1
rt_part_vshot( stp, rp, segp, n, resp)
d641 1
d643 1
a643 1
	rt_vstub( stp, rp, segp, n, resp );
d804 1
a804 1
rt_part_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
d807 2
a808 3
double		abs_tol;
double		rel_tol;
double		norm_tol;
d915 1
a915 1
rt_part_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d919 2
a920 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
@


1.18
log
@Eliminated mat parameter on ft_plot and ft_tess
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.17 91/01/25 21:52:11 mike Exp $ (BRL)";
d802 1
a802 1
struct vlhead	*vhead;
d829 1
a829 1
		ADD_VL( vhead, sphere_rim[15], 0 );
d831 1
a831 1
			ADD_VL( vhead, sphere_rim[i], 1 );
d835 1
a835 1
		ADD_VL( vhead, sphere_rim[15], 0 );
d837 1
a837 1
			ADD_VL( vhead, sphere_rim[i], 1 );
d841 1
a841 1
		ADD_VL( vhead, sphere_rim[15], 0 );
d843 1
a843 1
			ADD_VL( vhead, sphere_rim[i], 1 );
d867 1
a867 1
	ADD_VL( vhead, vhemi[0], 0 );
d869 1
a869 1
		ADD_VL( vhead, vhemi[i], 1 );
d871 9
a879 9
	ADD_VL( vhead, vhemi[8], 1 );
	ADD_VL( vhead, vhemi[12], 1 );
	ADD_VL( vhead, vhemi[10], 1 );
	ADD_VL( vhead, vhemi[4], 1 );
	ADD_VL( vhead, vhemi[2], 0 );
	ADD_VL( vhead, vhemi[9], 1 );
	ADD_VL( vhead, vhemi[12], 1 );
	ADD_VL( vhead, vhemi[11], 1 );
	ADD_VL( vhead, vhemi[6], 1 );
d882 1
a882 1
	ADD_VL( vhead, hhemi[0], 0 );
d884 1
a884 1
		ADD_VL( vhead, hhemi[i], 1 );
d886 9
a894 9
	ADD_VL( vhead, hhemi[8], 1 );
	ADD_VL( vhead, hhemi[12], 1 );
	ADD_VL( vhead, hhemi[10], 1 );
	ADD_VL( vhead, hhemi[4], 1 );
	ADD_VL( vhead, hhemi[2], 0 );
	ADD_VL( vhead, hhemi[9], 1 );
	ADD_VL( vhead, hhemi[12], 1 );
	ADD_VL( vhead, hhemi[11], 1 );
	ADD_VL( vhead, hhemi[6], 1 );
d897 8
a904 8
	ADD_VL( vhead, vhemi[0], 0 );
	ADD_VL( vhead, hhemi[0], 1 );
	ADD_VL( vhead, vhemi[2], 0 );
	ADD_VL( vhead, hhemi[2], 1 );
	ADD_VL( vhead, vhemi[4], 0 );
	ADD_VL( vhead, hhemi[4], 1 );
	ADD_VL( vhead, vhemi[6], 0 );
	ADD_VL( vhead, hhemi[6], 1 );
@


1.17
log
@lint
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.16 91/01/25 21:19:09 mike Exp $ (BRL)";
d801 1
a801 1
rt_part_plot( vhead, mat, ip, abs_tol, rel_tol, norm_tol )
a802 1
mat_t		mat;
d913 1
a913 1
rt_part_tess( r, m, ip, mat, abs_tol, rel_tol, norm_tol )
a916 1
mat_t			mat;
@


1.16
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.15 91/01/25 20:35:48 mike Exp $ (BRL)";
d914 1
a914 1
rt_part_tess( r, m, rp, mat, dp, abs_tol, rel_tol, norm_tol )
d917 1
a917 1
union record		*rp;
a918 1
struct directory	*dp;
@


1.15
log
@Added rt_ prefix to _internal structure
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.14 91/01/15 23:42:13 mike Exp $ (BRL)";
a210 2
#if NEW_IF
/* new way */
a216 11
#else
/* old interface */
int
rt_part_prep( stp, rec, rtip )
struct soltab		*stp;
union record		*rec;
struct rt_i		*rtip;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a226 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rec;
	ep->ext_nbytes = stp->st_dp->d_len*sizeof(union record);
	ip = &intern;
	i = rt_part_import( ip, ep, stp->st_pathmat );
	if( i < 0 )  {
		rt_log("rt_part_setup(%s): db import failure\n", stp->st_name);
		return(-1);		/* BAD */
	}
#endif
a799 1
#if NEW_IF
a808 14
#else
int
rt_part_plot( rp, mat, vhead, dp, abs_tol, rel_tol, norm_tol )
union record	*rp;
mat_t		mat;
struct vlhead	*vhead;
struct directory *dp;
double		abs_tol;
double		rel_tol;
double		norm_tol;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a818 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_part_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_part_plot(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
@


1.14
log
@Moved pipe_internal structure to rtgeom.h
Changed name to rt_ell_16pts
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.13 91/01/15 01:34:43 mike Exp $ (BRL)";
d184 1
a184 1
	struct part_internal	part_int;
d231 1
a231 1
	struct part_internal	*pip;
d255 1
a255 1
	pip = (struct part_internal *)ip->idb_ptr;
d851 1
a851 1
	struct part_internal	*pip;
d876 1
a876 1
	pip = (struct part_internal *)ip->idb_ptr;
d998 1
a998 1
	struct part_internal	*part;
d1016 2
a1017 2
	ip->idb_ptr = rt_malloc( sizeof(struct part_internal), "part_internal");
	part = (struct part_internal *)ip->idb_ptr;
d1024 1
a1024 1
		rt_free( ip->idb_ptr, "part_internal" );
d1028 1
a1028 1
		rt_free( ip->idb_ptr, "part_internal" );
d1040 1
a1040 1
		rt_free( ip->idb_ptr, "part_internal" );
d1072 1
a1072 1
	struct part_internal	*pip;
d1081 1
a1081 1
	pip = (struct part_internal *)ip->idb_ptr;
d1119 2
a1120 2
	register struct part_internal	*pip =
		(struct part_internal *)ip->idb_ptr;
@


1.13
log
@Added magic, added export routine, added units conversion
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.12 91/01/11 07:11:37 mike Exp $ (BRL)";
d179 2
a182 15
struct part_internal {
	long	part_magic;
	point_t	part_V;
	vect_t	part_H;
	fastf_t	part_vrad;
	fastf_t	part_hrad;
	int	part_type;		/* sphere, cylinder, cone */
};
#define RT_PART_INTERNAL_MAGIC	0xaaccee87
#define RT_PART_CK_MAGIC(_p)	RT_CKMAG(_p,RT_PART_INTERNAL_MAGIC,"part_internal")

#define RT_PARTICLE_TYPE_SPHERE		1
#define RT_PARTICLE_TYPE_CYLINDER	2
#define RT_PARTICLE_TYPE_CONE		3

d885 1
a885 1
		ell_16pts( sphere_rim, pip->part_V, a, b );
d891 1
a891 1
		ell_16pts( sphere_rim, pip->part_V, b, c );
d897 1
a897 1
		ell_16pts( sphere_rim, pip->part_V, a, c );
@


1.12
log
@Changed to have new style import/export routines, and ft_describe
routine.
@
text
@d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.11 91/01/11 04:02:37 mike Exp $ (BRL)";
d182 1
d189 3
d268 2
d273 1
a273 1
	part->part_int = *((struct part_internal *)ip->idb_ptr);	/* struct copy */
d890 1
d1031 1
d1080 1
a1080 1
rt_part_export( ep, ip )
d1083 1
d1085 31
a1115 1
	return(-1);
d1126 1
a1126 1
rt_part_describe( str, ip, verbose )
d1130 1
d1136 1
d1140 4
a1143 1
		sprintf(buf, "\tV (%g, %g, %g)\n", V3ARGS(pip->part_V) );
d1145 2
a1146 1
		sprintf(buf, "\tradius = %g\n", pip->part_vrad );
d1151 4
a1154 1
		sprintf(buf, "\tV (%g, %g, %g)\n", V3ARGS(pip->part_V) );
d1156 4
a1159 1
		sprintf(buf, "\tH (%g, %g, %g)\n", V3ARGS(pip->part_H) );
d1161 2
a1162 1
		sprintf(buf, "\tradius = %g\n", pip->part_vrad );
d1167 4
a1170 1
		sprintf(buf, "\tV (%g, %g, %g)\n", V3ARGS(pip->part_V) );
d1172 4
a1175 1
		sprintf(buf, "\tH (%g, %g, %g)\n", V3ARGS(pip->part_H) );
d1177 2
a1178 1
		sprintf(buf, "\tv end radius = %g\n", pip->part_vrad );
d1180 2
a1181 1
		sprintf(buf, "\th end radius = %g\n", pip->part_hrad );
d1192 2
a1194 1
 *  XXX The suffix of this name is temporary.
@


1.11
log
@Freed internal form.
@
text
@a0 1
#define NEW_IF	0
d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.10 91/01/09 02:17:40 mike Exp $ (BRL)";
d223 1
a223 1
rt_part_prep( stp, ep, rtip )
d225 1
a225 1
struct rt_external	*ep;
d237 1
a239 1
	struct rt_db_internal	intern;
d256 2
a257 2
#endif
	i = rt_part_import( &intern, ep, stp->st_pathmat );
d262 2
a263 1
	RT_CK_DB_INTERNAL( &intern );
d267 1
a267 1
	part->part_int = *((struct part_internal *)intern.idb_ptr);	/* struct copy */
a268 1
	intern.idb_ptr = GENPTR_NULL;	/* sanity */
a279 1
		rt_part_ifree( &intern );
a336 1
	rt_part_ifree( &intern );
@


1.10
log
@Started conversion to new rt_external / rt_db_internal style of interface.
@
text
@d171 1
a171 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.9 90/10/15 16:56:26 mike Exp $ (BRL)";
d204 2
a267 1
	/* XXX need to free intern.idb_ptr */
d281 1
d339 1
@


1.9
log
@Some optimizations
@
text
@d1 1
d171 1
a171 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.8 90/10/15 15:36:46 mike Exp $ (BRL)";
d219 2
d222 8
d235 2
d238 2
a239 1
	struct part_internal	pi;
d248 9
a256 7
	if( rec == (union record *)0 )  {
		rec = db_getmrec( rtip->rti_dbip, stp->st_dp );
		i = rt_part_import( &pi, rec, stp->st_pathmat );
		rt_free( (char *)rec, "part record" );
	} else {
		i = rt_part_import( &pi, rec, stp->st_pathmat );
	}
d261 1
d265 4
a268 1
	part->part_int = pi;		/* struct copy */
d270 1
a270 1
	if( pi.part_type == RT_PARTICLE_TYPE_SPHERE )  {
d272 8
a279 8
		VMOVE( stp->st_center, pi.part_V );
		stp->st_aradius = stp->st_bradius = pi.part_vrad;
		stp->st_min[X] = pi.part_V[X] - pi.part_vrad;
		stp->st_max[X] = pi.part_V[X] + pi.part_vrad;
		stp->st_min[Y] = pi.part_V[Y] - pi.part_vrad;
		stp->st_max[Y] = pi.part_V[Y] + pi.part_vrad;
		stp->st_min[Z] = pi.part_V[Z] - pi.part_vrad;
		stp->st_max[Z] = pi.part_V[Z] + pi.part_vrad;
d283 1
a283 1
	VMOVE( Hunit, pi.part_H );
d297 1
a297 1
	S[ 0] = 1.0 / pi.part_vrad;	/* |A| = |B| */
d299 1
a299 1
	S[10] = 1.0 / MAGNITUDE( pi.part_H );
d305 1
a305 1
	VJOIN1( stp->st_center, pi.part_V, 0.5, pi.part_H );
d307 1
a307 1
	stp->st_aradius = stp->st_bradius = pi.part_vrad;
d309 6
a314 6
	stp->st_min[X] = pi.part_V[X] - pi.part_vrad;
	stp->st_max[X] = pi.part_V[X] + pi.part_vrad;
	stp->st_min[Y] = pi.part_V[Y] - pi.part_vrad;
	stp->st_max[Y] = pi.part_V[Y] + pi.part_vrad;
	stp->st_min[Z] = pi.part_V[Z] - pi.part_vrad;
	stp->st_max[Z] = pi.part_V[Z] + pi.part_vrad;
d316 7
a322 7
	VADD2( tip, pi.part_V, pi.part_H );
	min[X] = tip[X] - pi.part_hrad;
	max[X] = tip[X] + pi.part_hrad;
	min[Y] = tip[Y] - pi.part_hrad;
	max[Y] = tip[Y] + pi.part_hrad;
	min[Z] = tip[Z] - pi.part_hrad;
	max[Z] = tip[Z] + pi.part_hrad;
d834 1
d836 10
d855 4
a858 1
	struct part_internal	pi;
d868 11
a878 3
	if( rt_part_import( &pi, rp, mat ) < 0 )  {
		rt_log("rt_part_plot(%s): db import failure\n", dp->d_namep);
		return(-1);
d880 4
d885 1
a885 1
	if( pi.part_type == RT_PARTICLE_TYPE_SPHERE )  {
d887 3
a889 3
		VSET( a, pi.part_vrad, 0, 0 );
		VSET( b, 0, pi.part_vrad, 0 );
		VSET( c, 0, 0, pi.part_vrad );
d891 1
a891 1
		ell_16pts( sphere_rim, pi.part_V, a, b );
d897 1
a897 1
		ell_16pts( sphere_rim, pi.part_V, b, c );
d903 1
a903 1
		ell_16pts( sphere_rim, pi.part_V, a, c );
d911 1
a911 1
	VMOVE( Hunit, pi.part_H );
d918 4
a921 4
	VSCALE( as, a, pi.part_vrad );
	VSCALE( bs, b, pi.part_vrad );
	VSCALE( hs, Hunit, -pi.part_vrad );
	rt_part_hemisphere( vhemi, pi.part_V, as, bs, hs );
d923 4
a926 4
	VADD2( tail, pi.part_V, pi.part_H );
	VSCALE( as, a, pi.part_hrad );
	VSCALE( bs, b, pi.part_hrad );
	VSCALE( hs, Hunit, pi.part_hrad );
d993 3
a995 3
rt_part_import( part, rp, mat )
struct part_internal	*part;
union record		*rp;
d1003 2
d1006 2
d1020 5
d1028 2
a1029 1
	if( (part->part_vrad = vrad / mat[15]) < 0 )
d1031 3
a1033 1
	if( (part->part_hrad = hrad / mat[15]) < 0 )
d1035 1
d1044 2
a1045 1
	if( maxrad <= 0 )
d1047 1
d1066 1
d1068 73
@


1.8
log
@Efficiency improvements
@
text
@d83 1
a83 1
 *	f(z) = (r2-r1) * z + r1
d85 1
a85 1
 *  let m = r2-r1, and substitute:
d89 2
d170 1
a170 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.7 90/10/15 12:00:58 mike Exp $ (BRL)";
d383 1
d430 2
a431 1
	if( NEAR_ZERO(dprime[X], SMALL) && NEAR_ZERO(dprime[Y], SMALL) )
d433 2
d438 2
a439 1
	{
d442 13
d486 13
a498 8
	if( (f = pprime[Z] + t1 * dprime[Z]) >= 0.0 && f <= 1.0 )  {
		/** VJOIN1( hitp->hit_vpriv, pprime, t1, dprime ); **/
		hitp->hit_vpriv[X] = pprime[X] + t1 * dprime[X];
		hitp->hit_vpriv[Y] = pprime[Y] + t1 * dprime[Y];
		hitp->hit_vpriv[Z] = f;
		hitp->hit_dist = t1;
		hitp->hit_surfno = RT_PARTICLE_SURF_BODY;
		hitp++;
d501 13
a513 8
	if( (f = pprime[Z] + t2 * dprime[Z]) >= 0.0 && f <= 1.0 )  {
		/** VJOIN1( hitp->hit_vpriv, pprime, t2, dprime ); **/
		hitp->hit_vpriv[X] = pprime[X] + t2 * dprime[X];
		hitp->hit_vpriv[Y] = pprime[Y] + t2 * dprime[Y];
		hitp->hit_vpriv[Z] = f;
		hitp->hit_dist = t2;
		hitp->hit_surfno = RT_PARTICLE_SURF_BODY;
		hitp++;
d517 1
a517 2
	 *  Check for hitting the end hemispheres, if there
	 *  have been fewer than 2 hits so far.
d520 1
a520 1
	if( hitp < &hits[2] )  {
d538 1
a538 1
				goto check_h;
d543 1
a543 1
				goto check_h;
d564 2
a565 2
check_h:
	if( hitp < &hits[2] )  {
d609 5
d690 13
a702 1
			break;
a703 4
		/* The cone case */
		MAT4X3VEC( hitp->hit_normal, part->part_invRoS,
			hitp->hit_vpriv );
		VUNITIZE( hitp->hit_normal );
@


1.7
log
@Changed from using hit_private to hit_surfno for surface indicator
@
text
@d168 1
a168 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.6 90/10/13 00:23:47 mike Exp $ (BRL)";
d377 2
a378 1
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
d448 1
a448 1
			m * VRAD_PRIME * dprime[Z];
d451 2
a452 2
			2 * m * VRAD_PRIME * pprime[Z] -
			VRAD_PRIME * VRAD_PRIME;
d458 2
a459 2
		k1 = (root-b) / a;
		k2 = -(root+b) / a;
d463 2
a464 2
	 *  k1 and k2 are potential solutions to intersection with side.
	 *  See if they fall in range.
d466 6
a471 3
	VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );		/* hit' */
	if( hitp->hit_vpriv[Z] >= 0.0 && hitp->hit_vpriv[Z] <= 1.0 ) {
		hitp->hit_dist = k1;
d476 6
a481 3
	VJOIN1( hitp->hit_vpriv, pprime, k2, dprime );		/* hit' */
	if( hitp->hit_vpriv[Z] >= 0.0 && hitp->hit_vpriv[Z] <= 1.0 )  {
		hitp->hit_dist = k2;
d487 2
a488 1
	 * Check for hitting the end hemispheres.
a496 2
		FAST fastf_t	t;
		/* 0 or 1 hits so far, this is worthwhile */
d520 1
a520 1
		t = b - root;
d522 2
a523 2
		if( pprime[Z] + t * dprime[Z] <= 0.0 )  {
			hitp->hit_dist = t;
d527 3
a529 3
		t = b + root;
		if( pprime[Z] + t * dprime[Z] <= 0.0 )  {
			hitp->hit_dist = t;
a541 1
		FAST fastf_t	t;
d566 3
a568 3
		t = b - root;
		if( pprime[Z] + t * dprime[Z] >= 1.0 )  {
			hitp->hit_dist = t;
d572 3
a574 3
		t = b + root;
		if( pprime[Z] + t * dprime[Z] >= 1.0 )  {
			hitp->hit_dist = t;
d650 9
a661 1
		/* XXX probably wrong for cone case */
@


1.6
log
@Additional cleanup.
@
text
@d168 1
a168 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.5 90/10/12 23:53:25 mike Exp $ (BRL)";
d196 1
a196 1
/* hit_private flags for which end was hit */
d414 1
a414 1
		segp->seg_in.hit_private = (genptr_t)RT_PARTICLE_SURF_VSPHERE;
d416 1
a416 1
		segp->seg_out.hit_private = (genptr_t)RT_PARTICLE_SURF_VSPHERE;
d468 1
a468 1
		hitp->hit_private = (genptr_t)RT_PARTICLE_SURF_BODY;
d475 1
a475 1
		hitp->hit_private = (genptr_t)RT_PARTICLE_SURF_BODY;
d518 1
a518 1
			hitp->hit_private = (genptr_t)RT_PARTICLE_SURF_VSPHERE;
d524 1
a524 1
			hitp->hit_private = (genptr_t)RT_PARTICLE_SURF_VSPHERE;
d564 1
a564 1
			hitp->hit_private = (genptr_t)RT_PARTICLE_SURF_HSPHERE;
d570 1
a570 1
			hitp->hit_private = (genptr_t)RT_PARTICLE_SURF_HSPHERE;
d633 1
a633 1
	switch( (int)hitp->hit_private )  {
@


1.5
log
@Slightly more efficient version.
@
text
@d168 1
a168 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.4 90/10/12 23:42:45 mike Exp $ (BRL)";
d487 1
a487 1
		FAST fastf_t	a,b,c;
@


1.4
log
@The beginnings of a working version.
Surface normals are not right yet.
@
text
@d168 1
a168 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.3 90/10/12 21:33:14 mike Exp $ (BRL)";
d440 3
d445 1
a445 1
		b = 2 * (dprime[X]*pprime[X] + dprime[Y]*pprime[Y] -
d447 1
a447 1
			m * VRAD_PRIME * dprime[Z] );
d453 1
a453 1
		if( (root = b*b - 4 * a * c) <= 0 )
d457 2
a458 2
		k1 = (root-b) * 0.5 / a;
		k2 = (root+b) * (-0.5 / a);
d515 2
a516 3
		/* Check for intersect in desired part of sphere */
		VJOIN1( hitp->hit_vpriv, pprime, t, dprime );	/* hit' */
		if( hitp->hit_vpriv[Z] <= 0.0 )  {
d522 1
a522 2
		VJOIN1( hitp->hit_vpriv, pprime, t, dprime );	/* hit' */
		if( hitp->hit_vpriv[Z] <= 0.0 )  {
d562 1
a562 2
		VJOIN1( hitp->hit_vpriv, pprime, t, dprime );	/* hit' */
		if( hitp->hit_vpriv[Z] >= 1.0 )  {
d568 1
a568 2
		VJOIN1( hitp->hit_vpriv, pprime, t, dprime );	/* hit' */
		if( hitp->hit_vpriv[Z] >= 1.0 )  {
@


1.3
log
@The cylindrical part now works.
@
text
@d168 1
a168 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.2 90/10/12 09:18:48 mike Exp $ (BRL)";
d480 7
a486 1
	if( hitp < &hits[2]  &&  !NEAR_ZERO(dprime[Z], SMALL) )  {
a487 3
/* XXXX */
		k1 = -pprime[Z] / dprime[Z];		/* bottom plate */
		k2 = (1.0 - pprime[Z]) / dprime[Z];	/* top plate */
d489 27
a515 4
		VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );	/* hit' */
		if( hitp->hit_vpriv[X] * hitp->hit_vpriv[X] +
		    hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y] <= 1.0 )  {
			hitp->hit_dist = k1;
d519 8
d528 36
a563 4
		VJOIN1( hitp->hit_vpriv, pprime, k2, dprime );	/* hit' */
		if( hitp->hit_vpriv[X] * hitp->hit_vpriv[X] +
		    hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y] <= 1.0 )  {
			hitp->hit_dist = k2;
d567 7
d575 1
d640 2
a641 1
		VSUB2( hitp->hit_normal, hitp->hit_point, part->part_int.part_H );
a645 1
		hitp->hit_vpriv[Z] = 0.0;
d649 1
@


1.2
log
@Lots more comments, partway through doing the code.
@
text
@d168 1
a168 1
static char RCSpart[] = "@@(#)$Header: /m/cad/librt/RCS/g_part.c,v 1.1 90/10/06 02:05:30 mike Exp $ (BRL)";
d193 1
d230 1
d277 1
a277 1
	S[10] = MAGNITUDE( pi.part_H );
d280 1
d294 9
a302 8
	min[X] = pi.part_V[X] - pi.part_hrad;
	max[X] = pi.part_V[X] + pi.part_hrad;
	min[Y] = pi.part_V[Y] - pi.part_hrad;
	max[Y] = pi.part_V[Y] + pi.part_hrad;
	min[Z] = pi.part_V[Z] - pi.part_hrad;
	max[Z] = pi.part_V[Z] + pi.part_hrad;
	VMIN( stp->st_min, min );
	VMAX( stp->st_max, max );
d327 24
d430 1
d436 3
a438 1
		m = part->part_int.part_hrad - part->part_int.part_vrad;
a439 1

d444 1
a444 1
			m * part->part_int.part_vrad * dprime[Z] );
d447 2
a448 2
			2 * m * part->part_int.part_vrad * pprime[Z] -
			part->part_int.part_vrad * part->part_int.part_vrad;
d570 5
a574 2
		/* XXX unfinished */
		VSET( hitp->hit_normal, 1, 0, 0 );
@


1.1
log
@Initial revision
@
text
@d5 4
a8 1
 *	Intersect a ray with a "particle" solid.
d21 145
d191 2
a192 1
	vect_t	part_V;
d195 5
d224 5
d242 70
a311 1
	return(-1);	/* unfinished */
d346 6
d353 141
d530 14
@
