head	11.12;
access;
symbols
	ansi-20040405-merged:11.8.2.2
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.8.10.1
	premerge-autoconf:11.9
	ansi-20040316-freeze:11.8.2.1
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.8.4.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.10
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.5
	offsite-5-3-pre:11.5
	rel-5-3:11.5
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.5
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.12
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.11;

11.11
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.10;

11.10
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2002.08.20.17.08.06;	author jra;	state Exp;
branches
	11.8.2.1
	11.8.4.1
	11.8.10.1;
next	11.7;

11.7
date	2002.08.15.20.55.19;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2001.04.20.22.29.54;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	99.06.03.01.39.15;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.12.31.01.09.27;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.12.01.02.49.33;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.11.30.17.50.54;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.46;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	10.9;

10.9
date	94.12.27.14.59.16;	author stay;	state Exp;
branches;
next	10.8;

10.8
date	94.12.27.14.46.24;	author stay;	state Exp;
branches;
next	10.7;

10.7
date	94.08.11.01.11.18;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	92.06.02.22.51.59;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.05.29.01.20.02;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.05.29.00.52.22;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.05.28.22.12.07;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.27.16.57.53;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.07;	author mike;	state Rel4_0;
branches;
next	1.3;

1.3
date	91.06.23.03.42.19;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.06.14.09.42.13;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	91.05.18.02.35.23;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.8.2.1
date	2002.09.19.18.01.42;	author morrison;	state Exp;
branches;
next	11.8.2.2;

11.8.2.2
date	2004.03.17.21.18.55;	author morrison;	state Exp;
branches;
next	;

11.8.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.8.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	;


desc
@Evaluation
@


11.12
log
@moved to src/
@
text
@/*	N U R B  _ E V A L . C
 *
 *  Function -
 *	Evaluate a Non Uniform Rational B-spline curve or at the 
 *	given (u,v) values.
 *  Author -
 *	Paul Randal Stay
 * 
 *  Source -
 * 	SECAD/VLD Computing Consortium, Bldg 394
 *	The U.S. Army Ballistic Research Laboratory
 * 	Aberdeen Proving Ground, Maryland 21005
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"

/* Algorithm -
 *
 * The algorithm uses the traditional COX-deBoor approach 
 * found in the book "Pratical Guide to Splines" Carl de Boor, pg 147 
 * to evaluate a parametric value on a curve. This is expanded to the surface.
 */

void
rt_nurb_s_eval(const struct face_g_snurb *srf, fastf_t u, fastf_t v, fastf_t *final_value)
{
	fastf_t * mesh_ptr = srf->ctl_points;
	fastf_t * curves;
	int	i, j, k;
	int	row_size = srf->s_size[RT_NURB_SPLIT_ROW];
	int	col_size = srf->s_size[RT_NURB_SPLIT_COL];
	fastf_t * c_ptr;
	fastf_t * diff_curve, *ev_pt;
	int	k_index;
	int	coords = RT_NURB_EXTRACT_COORDS(srf->pt_type);

	NMG_CK_SNURB(srf);

	/* Because the algorithm is destructive in nature, the
	 * rows of the control mesh are copied. The evaluation
	 * is then done on each row curve and then evaluation
	 * is then performed on the resulting curve.
	 */

	diff_curve = (fastf_t * )
	bu_malloc(row_size * sizeof(fastf_t) * coords,
	    "rt_nurb_s__eval: diff_curve");

	c_ptr = diff_curve;

	k_index = rt_nurb_knot_index( &srf->u, u, srf->order[RT_NURB_SPLIT_ROW] );
	if( k_index < 0 )
	{
		bu_log( "rt_nurb_s_eval: u value outside parameter range\n");
		bu_log( "\tUV = (%g %g )\n", u,v );
		rt_nurb_s_print( "", srf );
		rt_bomb( "rt_nurb_s_eval: u value outside parameter range\n");
	}

	curves = (fastf_t * ) bu_malloc( col_size * sizeof(fastf_t) * coords,
	    "rt_nurb_s_eval:crv_ptr");

	for ( i = 0; i < row_size; i++) {
		fastf_t * rtr_pt;
		fastf_t * crv_ptr;

		crv_ptr = curves;

		for ( j = 0; j < (col_size * coords ); j++) {
			*crv_ptr++ = *mesh_ptr++;
		}

		rtr_pt =  (fastf_t * ) rt_nurb_eval_crv( curves, srf->order[RT_NURB_SPLIT_ROW], u, 
		    &srf->u, k_index, coords );

		for (k = 0; k < coords; k++)
			c_ptr[k] = rtr_pt[k];
		c_ptr += coords;
	}

	bu_free( (char *)curves, "rt_nurb_s_eval: curves" );

	k_index = rt_nurb_knot_index( &srf->v, v, srf->order[RT_NURB_SPLIT_COL] );

	ev_pt = (fastf_t * ) rt_nurb_eval_crv( diff_curve, srf->order[RT_NURB_SPLIT_COL], 
		v, &srf->v, k_index, coords);

	for ( k = 0; k < coords; k++)
		final_value[k] = ev_pt[k];

	bu_free ( (char *)diff_curve, "rt_nurb_s_eval: diff curve" );
}


void
rt_nurb_c_eval(const struct edge_g_cnurb *crv, fastf_t param, fastf_t *final_value)
{
	fastf_t * pnts;
	fastf_t * ev_pt;
	int	coords;
	int	i, k_index;

	NMG_CK_CNURB(crv);

	coords = RT_NURB_EXTRACT_COORDS( crv->pt_type);

	k_index = rt_nurb_knot_index( &crv->k, param, crv->order);

	pnts = (fastf_t * ) bu_malloc( coords * sizeof( fastf_t) * 
	    crv->c_size, "diff: rt_nurb_c_eval");

	for ( i = 0; i < coords * crv->c_size; i++)
		pnts[i] = crv->ctl_points[i];

	ev_pt = (fastf_t * ) rt_nurb_eval_crv(
	    pnts, crv->order, param, &crv->k, k_index, coords);

	for ( i = 0; i < coords; i++)
		final_value[i] = ev_pt[i];

	bu_free( (char *) pnts, "rt_nurb_c_eval");
}


fastf_t *
rt_nurb_eval_crv(register fastf_t *crv, int order, fastf_t param, const struct knot_vector *k_vec, int k_index, int coords)
{
	int	i, j;

	if ( order <= 1 ) 
		return
		    (crv + ((k_index) * coords));

	j = k_index;

	while ( j > (k_index - order + 1)) {
		register fastf_t  k1, k2;

		k1 =  k_vec->knots[ (j + order - 1)];

		k2 =  k_vec->knots[ ( j ) ];

		if ((k1 - k2) != 0.0 ) { 		
			for ( i= 0; i < coords; i++) 
			{
 				*((crv + ((j) * coords)) + i) =
					((k1 - param) *
					*((crv + ((j - 1) * coords)) + i) 
					+ (param - k2 ) * *((crv + ((j) * 
					coords)) + i)) / (k1 - k2);
 			} 		
		} 		
		j--;
	} 	
	return rt_nurb_eval_crv( crv, order - 1, param, k_vec, 
		k_index, coords ); 
}


void
rt_nurb_pr_crv(fastf_t *crv, int c_size, int coords)
{
	int	i;

	fprintf(stderr, "\n");
	if (coords == 3)
		for (i = 0; i < c_size; i++)
			fprintf(stderr, "p%d   %f   %f   %f\n", i, *((crv + ((i) * coords))),
			    *((crv + ((i) * coords)) + 1),
			    *((crv + ((i) * coords)) + 2));

	else if (coords == 4)
		for (i = 0; i < c_size; i++)
			fprintf(stderr, "p%d   %f   %f   %f   %f\n", i,
			    *((crv + ((i) * coords))),
			    *((crv + ((i) * coords)) + 1),
			    *((crv + ((i) * coords)) + 2),
			    *((crv + ((i) * coords)) + 3));
}
@


11.11
log
@change conf.h to a wrapped config.h
@
text
@@


11.10
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 5
a23 1
#include "conf.h"
@


11.9
log
@update copyright to include span through 2003
@
text
@d37 1
a37 5
rt_nurb_s_eval( srf, u, v, final_value )
const struct face_g_snurb *srf;
fastf_t	u;
fastf_t v;
fastf_t * final_value;
d108 1
a108 4
rt_nurb_c_eval( crv, param, final_value)
const struct edge_g_cnurb *crv;
fastf_t param;
fastf_t * final_value;
d138 1
a138 7
rt_nurb_eval_crv( crv, order, param, k_vec, k_index, coords )
register fastf_t *crv;
int	order;
fastf_t	param;
const struct knot_vector *k_vec;
int	k_index;
int	coords;
d173 1
a173 4
rt_nurb_pr_crv( crv, c_size, coords )
fastf_t *crv;
int	c_size;
int	coords;
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1990 by the United States Army.
@


11.8.4.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.8.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d37 5
a41 1
rt_nurb_s_eval(const struct face_g_snurb *srf, fastf_t u, fastf_t v, fastf_t *final_value)
d112 4
a115 1
rt_nurb_c_eval(const struct edge_g_cnurb *crv, fastf_t param, fastf_t *final_value)
d145 7
a151 1
rt_nurb_eval_crv(register fastf_t *crv, int order, fastf_t param, const struct knot_vector *k_vec, int k_index, int coords)
d186 4
a189 1
rt_nurb_pr_crv(fastf_t *crv, int c_size, int coords)
@


11.8.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d37 5
a41 1
rt_nurb_s_eval(const struct face_g_snurb *srf, fastf_t u, fastf_t v, fastf_t *final_value)
d112 4
a115 1
rt_nurb_c_eval(const struct edge_g_cnurb *crv, fastf_t param, fastf_t *final_value)
d145 7
a151 1
rt_nurb_eval_crv(register fastf_t *crv, int order, fastf_t param, const struct knot_vector *k_vec, int k_index, int coords)
d186 4
a189 1
rt_nurb_pr_crv(fastf_t *crv, int c_size, int coords)
@


11.6
log
@CONST to const
@
text
@d37 1
a37 5
rt_nurb_s_eval( srf, u, v, final_value )
const struct face_g_snurb *srf;
fastf_t	u;
fastf_t v;
fastf_t * final_value;
d108 1
a108 4
rt_nurb_c_eval( crv, param, final_value)
const struct edge_g_cnurb *crv;
fastf_t param;
fastf_t * final_value;
d138 1
a138 7
rt_nurb_eval_crv( crv, order, param, k_vec, k_index, coords )
register fastf_t *crv;
int	order;
fastf_t	param;
const struct knot_vector *k_vec;
int	k_index;
int	coords;
d173 1
a173 4
rt_nurb_pr_crv( crv, c_size, coords )
fastf_t *crv;
int	c_size;
int	coords;
@


11.5
log
@
sed4
@
text
@d38 1
a38 1
CONST struct face_g_snurb *srf;
d113 1
a113 1
CONST struct edge_g_cnurb *crv;
d149 1
a149 1
CONST struct knot_vector *k_vec;
@


11.4
log
@libbu
@
text
@d62 1
a62 1
	rt_malloc(row_size * sizeof(fastf_t) * coords,
d76 1
a76 1
	curves = (fastf_t * ) rt_malloc( col_size * sizeof(fastf_t) * coords,
d97 1
a97 1
	rt_free( (char *)curves, "rt_nurb_s_eval: curves" );
d107 1
a107 1
	rt_free ( (char *)diff_curve, "rt_nurb_s_eval: diff curve" );
d128 1
a128 1
	pnts = (fastf_t * ) rt_malloc( coords * sizeof( fastf_t) * 
d140 1
a140 1
	rt_free( (char *) pnts, "rt_nurb_c_eval");
@


11.3
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d70 2
a71 2
		rt_log( "rt_nurb_s_eval: u value outside parameter range\n");
		rt_log( "\tUV = (%g %g )\n", u,v );
@


11.2
log
@Added some error checking.
@
text
@d38 1
a38 1
CONST struct snurb *srf;
d67 1
a67 1
	k_index = rt_nurb_knot_index( &srf->u_knots, u, srf->order[RT_NURB_SPLIT_ROW] );
d90 1
a90 1
		    &srf->u_knots, k_index, coords );
d99 1
a99 8
	k_index = rt_nurb_knot_index( &srf->v_knots, v, srf->order[RT_NURB_SPLIT_COL] );
	if( k_index < 0 )
	{
		rt_log( "rt_nurb_s_eval: v value outside parameter range\n");
		rt_log( "\tUV = (%g %g )\n", u,v );
		rt_nurb_s_print( "", srf );
		rt_bomb( "rt_nurb_s_eval: v value outside parameter range\n");
	}
d102 1
a102 1
		v, &srf->v_knots, k_index, coords);
d113 1
a113 1
CONST struct cnurb *crv;
d126 1
a126 1
	k_index = rt_nurb_knot_index( &crv->knot, param, crv->order);
d135 1
a135 1
	    pnts, crv->order, param, &crv->knot, k_index, coords);
@


11.1
log
@Release_4.4
@
text
@d68 7
d100 7
@


11.1.1.1
log
@Release_4.5
@
text
@d38 1
a38 1
CONST struct face_g_snurb *srf;
d67 1
a67 8
	k_index = rt_nurb_knot_index( &srf->u, u, srf->order[RT_NURB_SPLIT_ROW] );
	if( k_index < 0 )
	{
		bu_log( "rt_nurb_s_eval: u value outside parameter range\n");
		bu_log( "\tUV = (%g %g )\n", u,v );
		rt_nurb_s_print( "", srf );
		rt_bomb( "rt_nurb_s_eval: u value outside parameter range\n");
	}
d83 1
a83 1
		    &srf->u, k_index, coords );
d92 1
a92 1
	k_index = rt_nurb_knot_index( &srf->v, v, srf->order[RT_NURB_SPLIT_COL] );
d95 1
a95 1
		v, &srf->v, k_index, coords);
d106 1
a106 1
CONST struct edge_g_cnurb *crv;
d119 1
a119 1
	k_index = rt_nurb_knot_index( &crv->k, param, crv->order);
d128 1
a128 1
	    pnts, crv->order, param, &crv->k, k_index, coords);
@


10.9
log
@fixed up some more arguments
@
text
@@


10.8
log
@added parameter for the evaluation point to make rt_nurb*eval more
efficient.
@
text
@d36 1
a36 1
fastf_t *
a54 4
	final_value = (fastf_t * ) rt_malloc( 
	    sizeof (fastf_t) * coords,
	    "rt_nurb_s_eval: final value" );

d104 1
a104 1
fastf_t *
a110 1
	fastf_t * final_value;
a117 3

	final_value = (fastf_t * ) rt_malloc( coords * sizeof(fastf_t),
	    "diff: rt_nurb_c_eval");
@


10.7
log
@Added include of conf.h
@
text
@d37 1
a37 1
rt_nurb_s_eval( srf, u, v )
d41 1
a49 1
	fastf_t * final_value;
a104 2

	return final_value;
d109 1
a109 1
rt_nurb_c_eval( crv, param)
d112 1
a141 2

	return final_value;
@


10.6
log
@Changed lists to use rt_list structures
Made some args CONST where appropriate
Switched to GET_CNURB() macros
Added calls to NMG_CK_SNURB()
@
text
@d19 2
@


10.5
log
@Control polygon/mesh is now just part of the cnurb/snurb structures,
rather than being a separate structure of their own.
@
text
@d23 2
d36 1
a36 1
struct snurb *srf;
a48 1

d51 2
d110 1
a110 1
struct cnurb *crv;
a112 1

d119 2
d151 1
a151 1
struct knot_vector *k_vec;
@


10.4
log
@Modifications due to data structure revisions:  mesh and knots are no
longer pointers, but in-place structures.
@
text
@d38 1
a38 1
	fastf_t * mesh_ptr = srf->mesh.ctl_points;
d41 2
a42 2
	int	row_size = srf->mesh.s_size[RT_NURB_SPLIT_ROW];
	int	col_size = srf->mesh.s_size[RT_NURB_SPLIT_COL];
d48 1
a48 1
	int	coords = RT_NURB_EXTRACT_COORDS(srf->mesh.pt_type);
d117 1
a117 1
	coords = RT_NURB_EXTRACT_COORDS( crv->mesh.pt_type);
d125 1
a125 1
	    crv->mesh.c_size, "diff: rt_nurb_c_eval");
d127 2
a128 2
	for ( i = 0; i < coords * crv->mesh.c_size; i++)
		pnts[i] = crv->mesh.ctl_points[i];
@


10.3
log
@Expanded names of manifest constants
@
text
@d38 1
a38 1
	fastf_t * mesh_ptr = srf->mesh->ctl_points;
d41 2
a42 2
	int	row_size = srf->mesh->s_size[RT_NURB_SPLIT_ROW];
	int	col_size = srf->mesh->s_size[RT_NURB_SPLIT_COL];
d48 1
a48 1
	int	coords = RT_NURB_EXTRACT_COORDS(srf->mesh->pt_type);
d66 1
a66 1
	k_index = rt_nurb_knot_index( srf->u_knots, u, srf->order[RT_NURB_SPLIT_ROW] );
d82 1
a82 1
		    srf->u_knots, k_index, coords );
d91 1
a91 1
	k_index = rt_nurb_knot_index( srf->v_knots, v, srf->order[RT_NURB_SPLIT_COL] );
d94 1
a94 1
		v, srf->v_knots, k_index, coords);
d117 1
a117 1
	coords = RT_NURB_EXTRACT_COORDS( crv->mesh->pt_type);
d122 1
a122 1
	k_index = rt_nurb_knot_index( crv->knot, param, crv->order);
d125 1
a125 1
	    crv->mesh->c_size, "diff: rt_nurb_c_eval");
d127 2
a128 2
	for ( i = 0; i < coords * crv->mesh->c_size; i++)
		pnts[i] = crv->mesh->ctl_points[i];
d131 1
a131 1
	    pnts, crv->order, param, crv->knot, k_index, coords);
@


10.2
log
@rt_nurb_ prefix put on "internal" routines.
SPL_INFINIT changed to INFINITY
@
text
@d41 2
a42 2
	int	row_size = srf->mesh->s_size[ROW];
	int	col_size = srf->mesh->s_size[COL];
d48 1
a48 1
	int	coords = EXTRACT_COORDS(srf->mesh->pt_type);
d66 1
a66 1
	k_index = rt_nurb_knot_index( srf->u_knots, u, srf->order[ROW] );
d81 1
a81 1
		rtr_pt =  (fastf_t * ) rt_nurb_eval_crv( curves, srf->order[ROW], u, 
d91 1
a91 1
	k_index = rt_nurb_knot_index( srf->v_knots, v, srf->order[COL] );
d93 1
a93 1
	ev_pt = (fastf_t * ) rt_nurb_eval_crv( diff_curve, srf->order[COL], 
d117 1
a117 1
	coords = EXTRACT_COORDS( crv->mesh->pt_type);
@


10.1
log
@Release_4.0
@
text
@d81 1
a81 1
		rtr_pt =  (fastf_t * ) internal_eval_crv( curves, srf->order[ROW], u, 
d93 1
a93 1
	ev_pt = (fastf_t * ) internal_eval_crv( diff_curve, srf->order[COL], 
d130 1
a130 1
	ev_pt = (fastf_t * ) internal_eval_crv(
d143 1
a143 1
internal_eval_crv( crv, order, param, k_vec, k_index, coords )
d178 1
a178 1
	return internal_eval_crv( crv, order - 1, param, k_vec, 
d184 1
a184 1
internal_pr_crv( crv, c_size, coords )
a205 2


@


1.3
log
@minor lint
@
text
@@


1.2
log
@fixed nurb.h
@
text
@a24 2
fastf_t *internal_eval_crv();

d35 2
a36 1
fastf_t	u, v;
d146 1
a146 1
float	param;
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
#include "./nurb.h"
@
