head	11.38;
access;
symbols
	ansi-20040405-merged:11.34.2.3
	postmerge-20040405-ansi:11.36
	premerge-20040404-ansi:11.35
	postmerge-autoconf:11.35
	autoconf-freeze:11.34.10.2
	premerge-autoconf:11.35
	ansi-20040316-freeze:11.34.2.2
	postmerge-20040315-windows:11.35
	premerge-20040315-windows:11.35
	windows-20040315-freeze:11.34.4.1
	autoconf-20031203:11.34
	autoconf-20031202:11.34
	autoconf-branch:11.34.0.10
	phong-branch:11.34.0.8
	photonmap-branch:11.34.0.6
	rel-6-1-DP:11.34
	windows-branch:11.34.0.4
	rel-6-0-2:11.32
	ansi-branch:11.34.0.2
	rel-6-0-1-branch:11.32.0.2
	hartley-6-0-post:11.33
	hartley-6-0-pre:11.32
	rel-6-0-1:11.32
	rel-6-0:11.32
	rel-5-4:11.14
	offsite-5-3-pre:11.25
	rel-5-3:11.14
	rel-5-2:11.14
	rel-5-1-branch:11.14.0.2
	rel-5-1:11.14
	rel-5-0:11.11
	rel-5-0-beta:11.10
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.38
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.37;

11.37
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.36;

11.36
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.35;

11.35
date	2004.02.02.17.39.22;	author morrison;	state Exp;
branches;
next	11.34;

11.34
date	2002.08.20.17.08.02;	author jra;	state Exp;
branches
	11.34.2.1
	11.34.4.1
	11.34.10.1;
next	11.33;

11.33
date	2002.08.15.20.55.13;	author hartley;	state Exp;
branches;
next	11.32;

11.32
date	2002.03.05.18.04.27;	author morrison;	state Exp;
branches;
next	11.31;

11.31
date	2002.03.01.19.42.16;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	2002.02.28.01.03.36;	author butler;	state Exp;
branches;
next	11.29;

11.29
date	2001.10.02.19.24.30;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	2001.04.20.22.29.48;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2001.04.02.21.38.09;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2001.03.31.01.57.10;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2000.10.18.18.10.35;	author butler;	state Exp;
branches;
next	11.24;

11.24
date	2000.08.25.21.04.00;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.08.21.02.02.31;	author butler;	state Exp;
branches;
next	11.22;

11.22
date	2000.07.10.23.01.36;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.06.30.15.38.04;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.06.30.15.31.15;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.06.27.17.30.43;	author cjohnson;	state Exp;
branches;
next	11.18;

11.18
date	2000.06.27.15.07.03;	author cjohnson;	state Exp;
branches;
next	11.17;

11.17
date	2000.06.27.13.58.41;	author cjohnson;	state Exp;
branches;
next	11.16;

11.16
date	2000.06.27.03.53.46;	author cjohnson;	state Exp;
branches;
next	11.15;

11.15
date	2000.06.26.21.25.43;	author cjohnson;	state Exp;
branches;
next	11.14;

11.14
date	99.11.26.21.46.49;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	99.11.24.23.12.09;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	99.11.17.02.42.03;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.07.02.22.19.24;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.05.27.19.10.43;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	98.03.26.07.53.50;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	98.03.26.07.51.58;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	98.03.24.04.49.58;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.06.17.19.22.35;	author gdurf;	state Exp;
branches;
next	11.5;

11.5
date	97.02.27.21.28.03;	author pjt;	state Exp;
branches;
next	11.4;

11.4
date	97.02.26.21.26.33;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	96.08.31.10.51.55;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.11.07.19.36.42;	author adam;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.06;	author mike;	state Rel4_4;
branches;
next	10.10;

10.10
date	94.12.27.17.14.42;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.12.27.11.33.03;	author jra;	state Exp;
branches;
next	10.8;

10.8
date	94.09.16.08.46.39;	author jra;	state Exp;
branches;
next	10.7;

10.7
date	94.09.13.15.59.05;	author jra;	state Exp;
branches;
next	10.6;

10.6
date	94.09.10.04.35.50;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.09.09.16.09.24;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	94.09.09.14.22.41;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	94.08.10.18.39.45;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.11.18.01.44.13;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.27;	author mike;	state Rel4_0;
branches;
next	9.33;

9.33
date	91.09.24.00.40.23;	author butler;	state Exp;
branches;
next	9.32;

9.32
date	91.09.20.23.31.30;	author butler;	state Exp;
branches;
next	9.31;

9.31
date	91.06.30.00.11.00;	author mike;	state Exp;
branches;
next	9.30;

9.30
date	91.06.22.22.30.41;	author mike;	state Exp;
branches;
next	9.29;

9.29
date	91.06.13.05.34.46;	author mike;	state Exp;
branches;
next	9.28;

9.28
date	91.06.13.01.58.11;	author mike;	state Exp;
branches;
next	9.27;

9.27
date	91.06.12.20.57.48;	author mike;	state Exp;
branches;
next	9.26;

9.26
date	91.06.01.21.41.29;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	91.05.18.03.01.41;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	91.04.01.19.59.43;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	91.03.13.16.43.45;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.02.27.21.16.30;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	91.02.07.20.32.26;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.01.28.23.53.23;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.01.26.03.15.02;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.01.25.21.19.21;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.01.25.20.36.14;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.01.15.23.42.53;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.01.15.20.15.09;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	90.10.06.02.05.26;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.06.13.06.51.19;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.05.18.07.25.47;	author butler;	state Exp;
branches;
next	9.11;

9.11
date	90.05.04.08.13.23;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.05.04.06.22.57;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.05.02.01.11.06;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.05.01.02.39.00;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.04.26.02.11.54;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.04.26.01.43.13;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.04.24.05.43.49;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.04.24.04.05.57;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.03.16.01.02.12;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.03.14.15.06.08;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.37;	author mike;	state Rel3_5;
branches;
next	8.6;

8.6
date	89.04.17.17.19.59;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.04.14.02.31.49;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.11.12.20.19;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	89.04.08.05.59.38;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.02.50;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.32.02;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.07.15.19.45.14;	author phil;	state Exp;
branches;
next	7.2;

7.2
date	88.05.14.00.01.45;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.34.54;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.57.09;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.13.10;	author mike;	state Rel;
branches;
next	4.9;

4.9
date	87.05.30.06.10.27;	author phil;	state Exp;
branches;
next	4.8;

4.8
date	87.04.28.00.28.12;	author phil;	state Exp;
branches;
next	4.7;

4.7
date	87.04.02.00.51.27;	author phil;	state Exp;
branches;
next	4.6;

4.6
date	87.04.01.23.59.35;	author phil;	state Exp;
branches;
next	4.5;

4.5
date	87.03.23.23.41.01;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.03.18.00.03.13;	author phil;	state Exp;
branches;
next	4.3;

4.3
date	87.03.10.23.43.22;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.12.22.12.27;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.46.36;	author mike;	state Rel1;
branches;
next	3.6;

3.6
date	86.12.24.08.06.37;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.12.14.13.39.52;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.10.11.03.08.06;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.08.12.04.17.01;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.24.06.11.00;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.11.01.33.23;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.34.27;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	86.06.09.21.52.26;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.07.48;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	85.07.30.05.56.16;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	85.07.30.02.16.43;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	85.05.01.16.43.40;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	85.03.25.11.47.33;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	85.02.09.01.31.46;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	85.02.08.02.41.23;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	85.02.08.01.59.09;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	85.02.07.22.08.55;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	85.02.07.19.38.31;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	85.01.31.20.44.21;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	85.01.31.17.02.45;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	84.12.17.15.45.19;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	84.11.24.03.00.47;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	84.11.23.20.56.39;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	84.11.20.20.15.09;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	84.11.16.06.29.58;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	84.11.16.00.41.04;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.11.15.21.48.51;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.10.19.01.39.27;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.09.06.03.59.38;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.08.22.03.19.31;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.08.21.01.19.51;	author mike;	state Exp;
branches;
next	;

11.34.2.1
date	2002.09.19.18.01.37;	author morrison;	state Exp;
branches;
next	11.34.2.2;

11.34.2.2
date	2003.02.11.00.05.44;	author morrison;	state Exp;
branches;
next	11.34.2.3;

11.34.2.3
date	2004.03.17.21.18.48;	author morrison;	state Exp;
branches;
next	;

11.34.4.1
date	2004.03.11.23.43.39;	author morrison;	state Exp;
branches;
next	;

11.34.10.1
date	2004.02.12.18.37.42;	author erikg;	state Exp;
branches;
next	11.34.10.2;

11.34.10.2
date	2004.03.15.14.07.22;	author erikg;	state Exp;
branches;
next	;


desc
@Support for shooting at a Torus.
@


11.38
log
@moved to src/
@
text
@/*
 *			G _ T O R U S . C
 *
 * Purpose -
 *	Intersect a ray with a Torus
 *
 * Authors -
 *	Edwin O. Davisson	(Analysis)
 *	Jeff Hanes		(Programming)
 *	Michael John Muuss	(RT adaptation)
 *	Gary S. Moss		(Improvement)
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCStorus[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_torus.c,v 11.37 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"

/*
 * The TORUS has the following input fields:
 *	V	V from origin to center
 *	H	Radius Vector, Normal to plane of torus.  |H| = R2
 *	A,B	perpindicular, to CENTER of torus.  |A|==|B|==R1
 *	F5,F6	perpindicular, for inner edge (unused)
 *	F7,F8	perpindicular, for outer edge (unused)
 *
 */

const struct bu_structparse rt_tor_parse[] = {
    { "%f", 3, "V",   offsetof(struct rt_tor_internal, v[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "H",   offsetof(struct rt_tor_internal, h[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_a", offsetof(struct rt_tor_internal, r_a),  BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_h", offsetof(struct rt_tor_internal, r_h),  BU_STRUCTPARSE_FUNC_NULL },
    { {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
    };

/*
 *  Algorithm:
 *  
 *  Given V, H, A, and B, there is a set of points on this torus
 *  
 *  { (x,y,z) | (x,y,z) is on torus defined by V, H, A, B }
 *  
 *  Through a series of  Transformations, this set will be
 *  transformed into a set of points on a unit torus (R1==1)
 *  centered at the origin
 *  which lies on the X-Y plane (ie, H is on the Z axis).
 *  
 *  { (x',y',z') | (x',y',z') is on unit torus at origin }
 *  
 *  The transformation from X to X' is accomplished by:
 *  
 *  X' = S(R( X - V ))
 *  
 *  where R(X) =  ( A/(|A|) )
 *  		 (  B/(|B|)  ) . X
 *  		  ( H/(|H|) )
 *
 *  and S(X) =	 (  1/|A|   0     0   )
 *  		(    0    1/|A|   0    ) . X
 *  		 (   0      0   1/|A| )
 *  where |A| = R1
 *
 *  To find the intersection of a line with the torus, consider
 *  the parametric line L:
 *  
 *  	L : { P(n) | P + t(n) . D }
 *  
 *  Call W the actual point of intersection between L and the torus.
 *  Let W' be the point of intersection between L' and the unit torus.
 *  
 *  	L' : { P'(n) | P' + t(n) . D' }
 *  
 *  W = invR( invS( W' ) ) + V
 *  
 *  Where W' = k D' + P'.
 *  
 *
 *  Given a line and a ratio, alpha, finds the equation of the
 *  unit torus in terms of the variable 't'.
 *
 *  The equation for the torus is:
 *
 *      [ X**2 + Y**2 + Z**2 + (1 - alpha**2) ]**2 - 4*( X**2 + Y**2 )  =  0
 *
 *  First, find X, Y, and Z in terms of 't' for this line, then
 *  substitute them into the equation above.
 *
 *  	Wx = Dx*t + Px
 *
 *  	Wx**2 = Dx**2 * t**2  +  2 * Dx * Px  +  Px**2
 *
 *  The real roots of the equation in 't' are the intersect points
 *  along the parameteric line.
 *  
 *  NORMALS.  Given the point W on the torus, what is the vector
 *  normal to the tangent plane at that point?
 *  
 *  Map W onto the unit torus, ie:  W' = S( R( W - V ) ).
 *  In this case, we find W' by solving the parameteric line given k.
 *  
 *  The gradient of the torus at W' is in fact the
 *  normal vector.
 *
 *  Given that the equation for the unit torus is:
 *
 *	[ X**2 + Y**2 + Z**2 + (1 - alpha**2) ]**2 - 4*( X**2 + Y**2 )  =  0
 *
 *  let w = X**2 + Y**2 + Z**2 + (1 - alpha**2), then the equation becomes:
 *
 *	w**2 - 4*( X**2 + Y**2 )  =  0
 *
 *  For f(x,y,z) = 0, the gradient of f() is ( df/dx, df/dy, df/dz ).
 *
 *	df/dx = 2 * w * 2 * x - 8 * x	= (4 * w - 8) * x
 *	df/dy = 2 * w * 2 * y - 8 * y	= (4 * w - 8) * y
 *	df/dz = 2 * w * 2 * z		= 4 * w * z
 *
 *  Note that the normal vector produced above will not have unit length.
 *  Also, to make this useful for the original torus, it will have
 *  to be rotated back to the orientation of the original torus.
 */

struct tor_specific {
	fastf_t	tor_alpha;	/* 0 < (R2/R1) <= 1 */
	fastf_t	tor_r1;		/* for inverse scaling of k values. */
	fastf_t	tor_r2;		/* for curvature */
	vect_t	tor_V;		/* Vector to center of torus */
	vect_t	tor_N;		/* unit normal to plane of torus */
	mat_t	tor_SoR;	/* Scale(Rot(vect)) */
	mat_t	tor_invR;	/* invRot(vect') */
};

/*
 *  			R T _ T O R _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid torus, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	TOR is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct tor_specific is created, and it's address is stored in
 *  	stp->st_specific for use by rt_tor_shot().
 */
int
rt_tor_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	register struct tor_specific *tor;
	LOCAL mat_t	R;
	LOCAL vect_t	P, w1;	/* for RPP calculation */
	FAST fastf_t	f;
	struct rt_tor_internal	*tip;

	tip = (struct rt_tor_internal *)ip->idb_ptr;
	RT_TOR_CK_MAGIC(tip);

	/* Validate that |A| == |B| (for now) */
	if( rt_fdiff( tip->r_a, tip->r_b ) != 0 ) {
		bu_log("tor(%s):  (|A|=%f) != (|B|=%f) \n",
			stp->st_name, tip->r_a, tip->r_b );
		return(1);		/* BAD */
	}

	/* Validate that A.B == 0, B.H == 0, A.H == 0 */
	f = VDOT( tip->a, tip->b )/(tip->r_a*tip->r_b);

	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
		bu_log("tor(%s):  A not perpendicular to B, f=%f\n",
			stp->st_name, f);
		return(1);		/* BAD */
	}
	f = VDOT( tip->b, tip->h )/(tip->r_b);
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
		bu_log("tor(%s):  B not perpendicular to H, f=%f\n",
			stp->st_name, f);
		return(1);		/* BAD */
	}
	f = VDOT( tip->a, tip->h )/(tip->r_a);
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
		bu_log("tor(%s):  A not perpendicular to H, f=%f\n",
			stp->st_name, f);
		return(1);		/* BAD */
	}

	/* Validate that 0 < r2 <= r1 for alpha computation */
	if( 0.0 >= tip->r_h  || tip->r_h > tip->r_a )  {
		bu_log("r1 = %f, r2 = %f\n", tip->r_a, tip->r_h );
		bu_log("tor(%s):  0 < r2 <= r1 is not true\n", stp->st_name);
		return(1);		/* BAD */
	}

	/* Solid is OK, compute constant terms now */
	BU_GETSTRUCT( tor, tor_specific );
	stp->st_specific = (genptr_t)tor;

	tor->tor_r1 = tip->r_a;
	tor->tor_r2 = tip->r_h;

	VMOVE( tor->tor_V, tip->v );
	tor->tor_alpha = tip->r_h/tor->tor_r1;

	/* Compute R and invR matrices */
	VMOVE( tor->tor_N, tip->h );

	MAT_IDN( R );
	VSCALE( &R[0], tip->a, 1.0/tip->r_a );
	VSCALE( &R[4], tip->b, 1.0/tip->r_b );
	VMOVE( &R[8], tor->tor_N );
	bn_mat_inv( tor->tor_invR, R );

	/* Compute SoR.  Here, S = I / r1 */
	MAT_COPY( tor->tor_SoR, R );
	tor->tor_SoR[15] *= tor->tor_r1;

	VMOVE( stp->st_center, tor->tor_V );
	stp->st_aradius = stp->st_bradius = tor->tor_r1 + tip->r_h;

	/*
	 *  Compute the bounding RPP planes for a circular torus.
	 *
	 *  Given a circular torus with vertex V, vector N, and
	 *  radii r1 and r2.  A bounding plane with direction
	 *  vector P will touch the surface of the torus at the
	 *  points:  V +/- [r2 + r1 * |N x P|] P
	 */
	/* X */
	VSET( P, 1.0, 0, 0 );		/* bounding plane normal */
	VCROSS( w1, tor->tor_N, P );	/* for sin(angle N P) */
	f = tor->tor_r2 + tor->tor_r1 * MAGNITUDE(w1);
	VSCALE( w1, P, f );
	f = fabs( w1[X] );
	stp->st_min[X] = tor->tor_V[X] - f;
	stp->st_max[X] = tor->tor_V[X] + f;

	/* Y */
	VSET( P, 0, 1.0, 0 );		/* bounding plane normal */
	VCROSS( w1, tor->tor_N, P );	/* for sin(angle N P) */
	f = tor->tor_r2 + tor->tor_r1 * MAGNITUDE(w1);
	VSCALE( w1, P, f );
	f = fabs( w1[Y] );
	stp->st_min[Y] = tor->tor_V[Y] - f;
	stp->st_max[Y] = tor->tor_V[Y] + f;

	/* Z */
	VSET( P, 0, 0, 1.0 );		/* bounding plane normal */
	VCROSS( w1, tor->tor_N, P );	/* for sin(angle N P) */
	f = tor->tor_r2 + tor->tor_r1 * MAGNITUDE(w1);
	VSCALE( w1, P, f );
	f = fabs( w1[Z] );
	stp->st_min[Z] = tor->tor_V[Z] - f;
	stp->st_max[Z] = tor->tor_V[Z] + f;

	return(0);			/* OK */
}

/*
 *			R T _ T O R _ P R I N T
 */
void
rt_tor_print(register const struct soltab *stp)
{
	register const struct tor_specific *tor =
		(struct tor_specific *)stp->st_specific;

	bu_log("r2/r1 (alpha) = %f\n", tor->tor_alpha);
	bu_log("r1 = %f\n", tor->tor_r1);
	bu_log("r2 = %f\n", tor->tor_r2);
	VPRINT("V", tor->tor_V);
	VPRINT("N", tor->tor_N);
	bn_mat_print("S o R", tor->tor_SoR );
	bn_mat_print("invR", tor->tor_invR );
}

/*
 *  			R T _ T O R _ S H O T
 *  
 *  Intersect a ray with an torus, where all constant terms have
 *  been precomputed by rt_tor_prep().  If an intersection occurs,
 *  one or two struct seg(s) will be acquired and filled in.
 *
 *  NOTE:  All lines in this function are represented parametrically
 *  by a point,  P( x0, y0, z0 ) and a direction normal,
 *  D = ax + by + cz.  Any point on a line can be expressed
 *  by one variable 't', where
 *
 *	X = a*t + x0,	eg,  X = Dx*t + Px
 *	Y = b*t + y0,
 *	Z = c*t + z0.
 *
 *  First, convert the line to the coordinate system of a "stan-
 *  dard" torus.  This is a torus which lies in the X-Y plane,
 *  circles the origin, and whose primary radius is one.  The
 *  secondary radius is  alpha = ( R2/R1 )  of the original torus
 *  where  ( 0 < alpha <= 1 ).
 *
 *  Then find the equation of that line and the standard torus,
 *  which turns out to be a quartic equation in 't'.  Solve the
 *  equation using a general polynomial root finder.  Use those
 *  values of 't' to compute the points of intersection in the
 *  original coordinate system.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_tor_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct tor_specific *tor =
		(struct tor_specific *)stp->st_specific;
	register struct seg *segp;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL vect_t	work;		/* temporary vector */
	LOCAL bn_poly_t	C;		/* The final equation */
	LOCAL bn_complex_t val[4];		/* The complex roots */
	LOCAL double	k[4];		/* The real roots */
	register int	i;
	LOCAL int	j;
	LOCAL bn_poly_t	A, Asqr;
	LOCAL bn_poly_t	X2_Y2;		/* X**2 + Y**2 */
	LOCAL vect_t	cor_pprime;	/* new ray origin */
	LOCAL fastf_t	cor_proj;

	/* Convert vector into the space of the unit torus */
	MAT4X3VEC( dprime, tor->tor_SoR, rp->r_dir );
	VUNITIZE( dprime );

	VSUB2( work, rp->r_pt, tor->tor_V );
	MAT4X3VEC( pprime, tor->tor_SoR, work );

	/* normalize distance from torus.  substitute
	 * corrected pprime which contains a translation along ray
	 * direction to closest approach to vertex of torus.
	 * Translating ray origin along direction of ray to closest pt. to
	 * origin of solid's coordinate system, new ray origin is
	 * 'cor_pprime'.
	 */
	cor_proj = VDOT( pprime, dprime );
	VSCALE( cor_pprime, dprime, cor_proj );
	VSUB2( cor_pprime, pprime, cor_pprime );

	/*
	 *  Given a line and a ratio, alpha, finds the equation of the
	 *  unit torus in terms of the variable 't'.
	 *
	 *  The equation for the torus is:
	 *
	 * [ X**2 + Y**2 + Z**2 + (1 - alpha**2) ]**2 - 4*( X**2 + Y**2 ) = 0
	 *
	 *  First, find X, Y, and Z in terms of 't' for this line, then
	 *  substitute them into the equation above.
	 *
	 *  	Wx = Dx*t + Px
	 *
	 *  	Wx**2 = Dx**2 * t**2  +  2 * Dx * Px  +  Px**2
	 *  		[0]                [1]           [2]    dgr=2
	 */
	X2_Y2.dgr = 2;
	X2_Y2.cf[0] = dprime[X] * dprime[X] + dprime[Y] * dprime[Y];
	X2_Y2.cf[1] = 2.0 * (dprime[X] * cor_pprime[X] +
			     dprime[Y] * cor_pprime[Y]);
	X2_Y2.cf[2] = cor_pprime[X] * cor_pprime[X] +
		      cor_pprime[Y] * cor_pprime[Y];

	/* A = X2_Y2 + Z2 */
	A.dgr = 2;
	A.cf[0] = X2_Y2.cf[0] + dprime[Z] * dprime[Z];
	A.cf[1] = X2_Y2.cf[1] + 2.0 * dprime[Z] * cor_pprime[Z];
	A.cf[2] = X2_Y2.cf[2] + cor_pprime[Z] * cor_pprime[Z] +
		  1.0 - tor->tor_alpha * tor->tor_alpha;

	/* Inline expansion of (void) rt_poly_mul( &A, &A, &Asqr ) */
	/* Both polys have degree two */
	Asqr.dgr = 4;
	Asqr.cf[0] = A.cf[0] * A.cf[0];
	Asqr.cf[1] = A.cf[0] * A.cf[1] + A.cf[1] * A.cf[0];
	Asqr.cf[2] = A.cf[0] * A.cf[2] + A.cf[1] * A.cf[1] + A.cf[2] * A.cf[0];
	Asqr.cf[3] = A.cf[1] * A.cf[2] + A.cf[2] * A.cf[1];
	Asqr.cf[4] = A.cf[2] * A.cf[2];

	/* Inline expansion of bn_poly_scale( &X2_Y2, 4.0 ) and
	 * rt_poly_sub( &Asqr, &X2_Y2, &C ).
	 */
	C.dgr   = 4;
	C.cf[0] = Asqr.cf[0];
	C.cf[1] = Asqr.cf[1];
	C.cf[2] = Asqr.cf[2] - X2_Y2.cf[0] * 4.0;
	C.cf[3] = Asqr.cf[3] - X2_Y2.cf[1] * 4.0;
	C.cf[4] = Asqr.cf[4] - X2_Y2.cf[2] * 4.0;

	/*  It is known that the equation is 4th order.  Therefore,
	 *  if the root finder returns other than 4 roots, error.
	 */
	if ( (i = rt_poly_roots( &C, val )) != 4 ){
		if( i != 0 )  {
			bu_log("tor:  rt_poly_roots() 4!=%d\n", i);
			bn_pr_roots( stp->st_name, val, i );
		}
		return(0);		/* MISS */
	}

	/*  Only real roots indicate an intersection in real space.
	 *
	 *  Look at each root returned; if the imaginary part is zero
	 *  or sufficiently close, then use the real part as one value
	 *  of 't' for the intersections
	 */
	for ( j=0, i=0; j < 4; j++ ){
		if( NEAR_ZERO( val[j].im, ap->a_rt_i->rti_tol.dist ) )
			k[i++] = val[j].re;
	}

	/* reverse above translation by adding distance to all 'k' values. */
	for( j = 0; j < i; ++j )
		k[j] -= cor_proj;

	/* Here, 'i' is number of points found */
	switch( i )  {
	case 0:
		return(0);		/* No hit */

	default:
		bu_log("rt_tor_shot: reduced 4 to %d roots\n",i);
		bn_pr_roots( stp->st_name, val, 4 );
		return(0);		/* No hit */

	case 2:
		{
			/* Sort most distant to least distant. */
			FAST fastf_t	u;
			if( (u=k[0]) < k[1] )  {
				/* bubble larger towards [0] */
				k[0] = k[1];
				k[1] = u;
			}
		}
		break;
	case 4:
		{
			register short	n;
			register short	lim;

			/*  Inline rt_pt_sort().  Sorts k[] into descending order. */
			for( lim = i-1; lim > 0; lim-- )  {
				for( n = 0; n < lim; n++ )  {
					FAST fastf_t	u;
					if( (u=k[n]) < k[n+1] )  {
						/* bubble larger towards [0] */
						k[n] = k[n+1];
						k[n+1] = u;
					}
				}
			}
		}
		break;
	}

	/* Now, t[0] > t[npts-1] */
	/* k[1] is entry point, and k[0] is farthest exit point */
	RT_GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;
	segp->seg_in.hit_dist = k[1]*tor->tor_r1;
	segp->seg_out.hit_dist = k[0]*tor->tor_r1;
	segp->seg_in.hit_surfno = segp->seg_out.hit_surfno = 0;
	/* Set aside vector for rt_tor_norm() later */
	VJOIN1( segp->seg_in.hit_vpriv, pprime, k[1], dprime );
	VJOIN1( segp->seg_out.hit_vpriv, pprime, k[0], dprime );
	BU_LIST_INSERT( &(seghead->l), &(segp->l) );

	if( i == 2 )
		return(2);			/* HIT */
				
	/* 4 points */
	/* k[3] is entry point, and k[2] is exit point */
	RT_GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;
	segp->seg_in.hit_dist = k[3]*tor->tor_r1;
	segp->seg_out.hit_dist = k[2]*tor->tor_r1;
	segp->seg_in.hit_surfno = segp->seg_out.hit_surfno = 1;
	VJOIN1( segp->seg_in.hit_vpriv, pprime, k[3], dprime );
	VJOIN1( segp->seg_out.hit_vpriv, pprime, k[2], dprime );
	BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	return(4);			/* HIT */
}

#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	
/*
 *			R T _ T O R _ V S H O T
 *
 *  This is the Becker vector version
 */
void
rt_tor_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	register int    i;
	register struct tor_specific *tor;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL vect_t	work;		/* temporary vector */
	LOCAL bn_poly_t	*C;		/* The final equation */
	LOCAL bn_complex_t (*val)[4];	/* The complex roots */
	LOCAL int	num_roots;
	LOCAL int	num_zero;
	LOCAL bn_poly_t	A, Asqr;
	LOCAL bn_poly_t	X2_Y2;		/* X**2 + Y**2 */
	LOCAL vect_t	cor_pprime;	/* new ray origin */
	LOCAL fastf_t	*cor_proj;

	/* Allocate space for polys and roots */
        C = (bn_poly_t *)bu_malloc(n * sizeof(bn_poly_t), "tor bn_poly_t");
	val = (bn_complex_t (*)[4])bu_malloc(n * sizeof(bn_complex_t) * 4,
		"tor bn_complex_t");
	cor_proj = (fastf_t *)bu_malloc(n * sizeof(fastf_t), "tor proj");

	/* Initialize seg_stp to assume hit (zero will then flag miss) */
#	include "noalias.h"
	for(i = 0; i < n; i++) segp[i].seg_stp = stp[i];

	/* for each ray/torus pair */
#	include "noalias.h"
	for(i = 0; i < n; i++){
		if( segp[i].seg_stp == 0) continue;	/* Skip */
		tor = (struct tor_specific *)stp[i]->st_specific;

		/* Convert vector into the space of the unit torus */
		MAT4X3VEC( dprime, tor->tor_SoR, rp[i]->r_dir );
		VUNITIZE( dprime );

		/* Use segp[i].seg_in.hit_normal as tmp to hold dprime */
		VMOVE( segp[i].seg_in.hit_normal, dprime );

		VSUB2( work, rp[i]->r_pt, tor->tor_V );
		MAT4X3VEC( pprime, tor->tor_SoR, work );

		/* Use segp[i].seg_out.hit_normal as tmp to hold pprime */
		VMOVE( segp[i].seg_out.hit_normal, pprime );

		/* normalize distance from torus.  substitute
		 * corrected pprime which contains a translation along ray
		 * direction to closest approach to vertex of torus.
		 * Translating ray origin along direction of ray to closest
		 * pt. to origin of solid's coordinate system, new ray origin is
		 * 'cor_pprime'.
		 */
		cor_proj[i] = VDOT( pprime, dprime );
		VSCALE( cor_pprime, dprime, cor_proj[i] );
		VSUB2( cor_pprime, pprime, cor_pprime );

		/*
		 *  Given a line and a ratio, alpha, finds the equation of the
		 *  unit torus in terms of the variable 't'.
		 *
		 *  The equation for the torus is:
		 *
		 * [X**2 + Y**2 + Z**2 + (1 - alpha**2)]**2 - 4*(X**2 + Y**2) =0
		 *
		 *  First, find X, Y, and Z in terms of 't' for this line, then
		 *  substitute them into the equation above.
		 *
		 *  	Wx = Dx*t + Px
		 *
		 *  	Wx**2 = Dx**2 * t**2  +  2 * Dx * Px  +  Px**2
		 *  		[0]                [1]           [2]    dgr=2
		 */
		X2_Y2.dgr = 2;
		X2_Y2.cf[0] = dprime[X] * dprime[X] + dprime[Y] * dprime[Y];
		X2_Y2.cf[1] = 2.0 * (dprime[X] * cor_pprime[X] +
				     dprime[Y] * cor_pprime[Y]);
		X2_Y2.cf[2] = cor_pprime[X] * cor_pprime[X] +
			      cor_pprime[Y] * cor_pprime[Y];
	
		/* A = X2_Y2 + Z2 */
		A.dgr = 2;
		A.cf[0] = X2_Y2.cf[0] + dprime[Z] * dprime[Z];
		A.cf[1] = X2_Y2.cf[1] + 2.0 * dprime[Z] * cor_pprime[Z];
		A.cf[2] = X2_Y2.cf[2] + cor_pprime[Z] * cor_pprime[Z] +
			  1.0 - tor->tor_alpha * tor->tor_alpha;

		/* Inline expansion of (void) rt_poly_mul( &A, &A, &Asqr ) */
		/* Both polys have degree two */
		Asqr.dgr = 4;
		Asqr.cf[0] = A.cf[0] * A.cf[0];
		Asqr.cf[1] = A.cf[0] * A.cf[1] +
				 A.cf[1] * A.cf[0];
		Asqr.cf[2] = A.cf[0] * A.cf[2] +
				 A.cf[1] * A.cf[1] +
				 A.cf[2] * A.cf[0];
		Asqr.cf[3] = A.cf[1] * A.cf[2] +
				 A.cf[2] * A.cf[1];
		Asqr.cf[4] = A.cf[2] * A.cf[2];

		/* Inline expansion of (void) bn_poly_scale( &X2_Y2, 4.0 ) */
		X2_Y2.cf[0] *= 4.0;
		X2_Y2.cf[1] *= 4.0;
		X2_Y2.cf[2] *= 4.0;

		/* Inline expansion of (void) rt_poly_sub( &Asqr, &X2_Y2, &C ) */
		/* offset is know to be 2 */
		C[i].dgr	= 4;
		C[i].cf[0] = Asqr.cf[0];
		C[i].cf[1] = Asqr.cf[1];
		C[i].cf[2] = Asqr.cf[2] - X2_Y2.cf[0];
		C[i].cf[3] = Asqr.cf[3] - X2_Y2.cf[1];
		C[i].cf[4] = Asqr.cf[4] - X2_Y2.cf[2];
	}

	/* Unfortunately finding the 4th order roots are too ugly to inline */
	for(i = 0; i < n; i++){
		if( segp[i].seg_stp == 0) continue;	/* Skip */

		/*  It is known that the equation is 4th order.  Therefore,
	 	*  if the root finder returns other than 4 roots, error.
	 	*/
		if ( (num_roots = rt_poly_roots( &(C[i]), &(val[i][0]) )) != 4 ){
			if( num_roots != 0 )  {
				bu_log("tor:  rt_poly_roots() 4!=%d\n", num_roots);
				bn_pr_roots( "tor", val[i], num_roots );
			}
			SEG_MISS(segp[i]);		/* MISS */
		}
	}

	/* for each ray/torus pair */
#	include "noalias.h"
	for(i = 0; i < n; i++){
		if( segp[i].seg_stp == 0) continue; /* Skip */

		/*  Only real roots indicate an intersection in real space.
	 	 *
	 	 *  Look at each root returned; if the imaginary part is zero
	 	 *  or sufficiently close, then use the real part as one value
	 	 *  of 't' for the intersections
	 	 */
	        /* Also reverse translation by adding distance to all 'k' values. */
		/* Reuse C to hold k values */
		num_zero = 0;
		if( NEAR_ZERO( val[i][0].im, ap->a_rt_i->rti_tol.dist ) )
			C[i].cf[num_zero++] = val[i][0].re - cor_proj[i];
		if( NEAR_ZERO( val[i][1].im, ap->a_rt_i->rti_tol.dist ) ) {
			C[i].cf[num_zero++] = val[i][1].re - cor_proj[i];
		}
		if( NEAR_ZERO( val[i][2].im, ap->a_rt_i->rti_tol.dist ) ) {
			C[i].cf[num_zero++] = val[i][2].re - cor_proj[i];
		}
		if( NEAR_ZERO( val[i][3].im, ap->a_rt_i->rti_tol.dist ) ) {
			C[i].cf[num_zero++] = val[i][3].re - cor_proj[i];
		}
		C[i].dgr   = num_zero;

		/* Here, 'i' is number of points found */
		if( num_zero == 0 ) {
			SEG_MISS(segp[i]);		/* MISS */
		}
		else if( num_zero != 2 && num_zero != 4 ) {
#if 0
			bu_log("rt_tor_shot: reduced 4 to %d roots\n",i);
			bn_pr_roots( stp->st_name, val, 4 );
#endif
			SEG_MISS(segp[i]);		/* MISS */
		}
	}

	/* Process each one segment hit */
#	include "noalias.h"
	for(i = 0; i < n; i++){
		if( segp[i].seg_stp == 0) continue; /* Skip */
		if( C[i].dgr != 2 )  continue;  /* Not one segment */

		tor = (struct tor_specific *)stp[i]->st_specific;

		/* segp[i].seg_in.hit_normal holds dprime */
		/* segp[i].seg_out.hit_normal holds pprime */
		if (C[i].cf[1] < C[i].cf[0]) {
			/* C[i].cf[1] is entry point */
			segp[i].seg_in.hit_dist = C[i].cf[1]*tor->tor_r1;
			segp[i].seg_out.hit_dist = C[i].cf[0]*tor->tor_r1;
			/* Set aside vector for rt_tor_norm() later */
			VJOIN1( segp[i].seg_in.hit_vpriv,
				segp[i].seg_out.hit_normal,
				C[i].cf[1], segp[i].seg_in.hit_normal );
			VJOIN1( segp[i].seg_out.hit_vpriv,
				segp[i].seg_out.hit_normal,
				C[i].cf[0], segp[i].seg_in.hit_normal );
		} else {
			/* C[i].cf[0] is entry point */
			segp[i].seg_in.hit_dist = C[i].cf[0]*tor->tor_r1;
			segp[i].seg_out.hit_dist = C[i].cf[1]*tor->tor_r1;
			/* Set aside vector for rt_tor_norm() later */
			VJOIN1( segp[i].seg_in.hit_vpriv,
				segp[i].seg_out.hit_normal,
				C[i].cf[0], segp[i].seg_in.hit_normal );
			VJOIN1( segp[i].seg_out.hit_vpriv,
				segp[i].seg_out.hit_normal,
				C[i].cf[1], segp[i].seg_in.hit_normal );
		}
	}

	/* Process each two segment hit */
	for(i = 0; i < n; i++){

		if( segp[i].seg_stp == 0) continue;	/* Skip */
		if( C[i].dgr != 4 )  continue;  /* Not two segment */

		tor = (struct tor_specific *)stp[i]->st_specific;

		/* Sort most distant to least distant. */
		rt_pt_sort( C[i].cf, 4 );
		/* Now, t[0] > t[npts-1] */

		/* segp[i].seg_in.hit_normal holds dprime */
		VMOVE( dprime, segp[i].seg_in.hit_normal );
		/* segp[i].seg_out.hit_normal holds pprime */
		VMOVE( pprime, segp[i].seg_out.hit_normal );

		/* C[i].cf[1] is entry point */
		segp[i].seg_in.hit_dist =  C[i].cf[1]*tor->tor_r1;
		segp[i].seg_out.hit_dist = C[i].cf[0]*tor->tor_r1;
		/* Set aside vector for rt_tor_norm() later */
		VJOIN1(segp[i].seg_in.hit_vpriv, pprime, C[i].cf[1], dprime );
		VJOIN1(segp[i].seg_out.hit_vpriv, pprime, C[i].cf[0], dprime);

#if 0
		/* C[i].cf[3] is entry point */
		/* Attach second hit to segment chain */
		/* XXXX need convention for vectorizing doubly linked list! */
		GET_SEG(seg2p, resp);
		segp[i].seg_next = seg2p;
		seg2p->seg_stp = stp[i];
		seg2p->seg_in.hit_dist =  C[i].cf[3]*tor->tor_r1;
		seg2p->seg_out.hit_dist = C[i].cf[2]*tor->tor_r1;
		VJOIN1( seg2p->seg_in.hit_vpriv, pprime, C[i].cf[3], dprime );
		VJOIN1(seg2p->seg_out.hit_vpriv, pprime, C[i].cf[2], dprime );
#endif
	}

	/* Free tmp space used */
	bu_free( (char *)C, "tor C");
	bu_free( (char *)val, "tor val");
	bu_free( (char *)cor_proj, "tor cor_proj");
}

/*
 *			R T _ T O R _ N O R M
 *
 *  Compute the normal to the torus,
 *  given a point on the UNIT TORUS centered at the origin on the X-Y plane.
 *  The gradient of the torus at that point is in fact the
 *  normal vector, which will have to be given unit length.
 *  To make this useful for the original torus, it will have
 *  to be rotated back to the orientation of the original torus.
 *
 *  Given that the equation for the unit torus is:
 *
 *	[ X**2 + Y**2 + Z**2 + (1 - alpha**2) ]**2 - 4*( X**2 + Y**2 )  =  0
 *
 *  let w = X**2 + Y**2 + Z**2 + (1 - alpha**2), then the equation becomes:
 *
 *	w**2 - 4*( X**2 + Y**2 )  =  0
 *
 *  For f(x,y,z) = 0, the gradient of f() is ( df/dx, df/dy, df/dz ).
 *
 *	df/dx = 2 * w * 2 * x - 8 * x	= (4 * w - 8) * x
 *	df/dy = 2 * w * 2 * y - 8 * y	= (4 * w - 8) * y
 *	df/dz = 2 * w * 2 * z		= 4 * w * z
 *
 *  Since we rescale the gradient (normal) to unity, we divide the
 *  above equations by four here.
 */
void
rt_tor_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct tor_specific *tor =
		(struct tor_specific *)stp->st_specific;
	FAST fastf_t w;
	LOCAL vect_t work;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	w = hitp->hit_vpriv[X]*hitp->hit_vpriv[X] +
	    hitp->hit_vpriv[Y]*hitp->hit_vpriv[Y] +
	    hitp->hit_vpriv[Z]*hitp->hit_vpriv[Z] +
	    1.0 - tor->tor_alpha*tor->tor_alpha;
	VSET( work,
		( w - 2.0 ) * hitp->hit_vpriv[X],
		( w - 2.0 ) * hitp->hit_vpriv[Y],
		  w * hitp->hit_vpriv[Z] );
	VUNITIZE( work );

	MAT3X3VEC( hitp->hit_normal, tor->tor_invR, work );
}

/*
 *			R T _ T O R _ C U R V E
 *
 *  Return the curvature of the torus.
 */
void
rt_tor_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	register struct tor_specific *tor =
		(struct tor_specific *)stp->st_specific;
	vect_t	w4, w5;
	fastf_t	nx, ny, nz, x1, y1, z1;
	fastf_t d;

	nx = tor->tor_N[X];
	ny = tor->tor_N[Y];
	nz = tor->tor_N[Z];

	/* vector from V to hit point */
	VSUB2( w4, hitp->hit_point, tor->tor_V );

	if( !NEAR_ZERO(nz, 0.00001) ) {
		z1 = w4[Z]*nx*nx + w4[Z]*ny*ny - w4[X]*nx*nz - w4[Y]*ny*nz;
		x1 = (nx*(z1-w4[Z])/nz) + w4[X];
		y1 = (ny*(z1-w4[Z])/nz) + w4[Y];
	} else if( !NEAR_ZERO(ny, 0.00001) ) {
		y1 = w4[Y]*nx*nx + w4[Y]*nz*nz - w4[X]*nx*ny - w4[Z]*ny*nz;
		x1 = (nx*(y1-w4[Y])/ny) + w4[X];
		z1 = (nz*(y1-w4[Y])/ny) + w4[Z];
	} else {
		x1 = w4[X]*ny*ny + w4[X]*nz*nz - w4[Y]*nx*ny - w4[Z]*nz*nx;
		y1 = (ny*(x1-w4[X])/nx) + w4[Y];
		z1 = (nz*(x1-w4[X])/nx) + w4[Z];
	}
	d = sqrt(x1*x1 + y1*y1 + z1*z1);

	cvp->crv_c1 = (tor->tor_r1 - d) / (d * tor->tor_r2);
	cvp->crv_c2 = -1.0 / tor->tor_r2;

	w4[X] = x1 / d;
	w4[Y] = y1 / d;
	w4[Z] = z1 / d;
	VCROSS( w5, tor->tor_N, w4 );
	VCROSS( cvp->crv_pdir, w5, hitp->hit_normal );
	VUNITIZE( cvp->crv_pdir );
}

/*
 *			R T _ T O R _ U V
 */
void
rt_tor_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct tor_specific	*tor =
			(struct tor_specific *) stp -> st_specific;
	LOCAL vect_t			work;
	LOCAL vect_t			pprime;
	LOCAL vect_t			pprime2;
	LOCAL fastf_t			costheta;

	VSUB2(work, hitp -> hit_point, tor -> tor_V);
	MAT4X3VEC(pprime, tor -> tor_SoR, work);
	/*
	 * -pi/2 <= atan2(x,y) <= pi/2
	 */
	uvp -> uv_u = atan2(pprime[Y], pprime[X]) * bn_inv2pi + 0.5;

	VSET(work, pprime[X], pprime[Y], 0.0);
	VUNITIZE(work);
	VSUB2(pprime2, pprime, work);
	VUNITIZE(pprime2);
	costheta = VDOT(pprime2, work);
	uvp -> uv_v = atan2(pprime2[Z], costheta) * bn_inv2pi + 0.5;
}

/*
 *			R T _ T O R _ F R E E
 */
void
rt_tor_free(struct soltab *stp)
{
	register struct tor_specific *tor =
		(struct tor_specific *)stp->st_specific;

	bu_free( (char *)tor, "tor_specific");
}

int
rt_tor_class(void)
{
	return(0);
}

/* 
 *			R T _ N U M _ C I R C U L A R _ S E G M E N T S
 *
 *  Given a circle with a specified radius, determine the minimum number
 *  of straight line segments that the circle can be approximated with,
 *  while still meeting the given maximum permissible error distance.
 *  Form a chord (straight line) by
 *  connecting the start and end points found when
 *  sweeping a 'radius' arc through angle 'theta'.
 *
 *  The error distance is the distance between where a radius line
 *  at angle theta/2 hits the chord, and where it hits the circle
 *  (at 'radius' distance).
 *
 *	error_distance = radius * ( 1 - cos( theta/2 ) )
 *
 *  or
 *
 *	theta = 2 * acos( 1 - error_distance / radius )
 *
 *  Returns -
 *	number of segments.  Always at least 6.
 */
int
rt_num_circular_segments(double	maxerr, double	radius)
{
	register fastf_t	cos_half_theta;
	register fastf_t	half_theta;
	int			n;

	if( radius <= 0.0 || maxerr <= 0.0 || maxerr >= radius )  {
		/* Return a default number of segments */
		return(6);
	}
	cos_half_theta = 1.0 - maxerr / radius;
	/* There does not seem to be any reasonable way to express the
	 * acos in terms of an atan2(), so extra checking is done.
	 */
	if( cos_half_theta <= 0.0 || cos_half_theta >= 1.0 )  {
		/* Return a default number of segments */
		return(6);
	}
	half_theta = acos( cos_half_theta );
	if( half_theta < SMALL )  {
		/* A very large number of segments will be needed.
		 * Impose an upper bound here
		 */
		return( 360*10 );
	}
	n = bn_pi / half_theta + 0.99;

	/* Impose the limits again */
	if( n <= 6 )  return(6);
	if( n >= 360*10 )  return( 360*10 );
	return(n);
}
/*
 *			R T _ T O R _ P L O T
 *
 * The TORUS has the following input fields:
 *	ti.v	V from origin to center
 *	ti.h	Radius Vector, Normal to plane of torus
 *	ti.a,ti.b	perpindicular, to CENTER of torus (for top, bottom)
 *
 */
int
rt_tor_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	fastf_t		alpha;
	fastf_t		beta;
	fastf_t		cos_alpha, sin_alpha;
	fastf_t		cos_beta, sin_beta;
	fastf_t		dist_to_rim;
	struct rt_tor_internal	*tip;
	int		w;
	int		nw = 8;
	int		len;
	int		nlen = 16;
	fastf_t		*pts;
	vect_t		G;
	vect_t		radius;
	vect_t		edge;
	fastf_t		rel;

	RT_CK_DB_INTERNAL(ip);
	tip = (struct rt_tor_internal *)ip->idb_ptr;
	RT_TOR_CK_MAGIC(tip);

	if( ttol->rel <= 0.0 || ttol->rel >= 1.0 )  {
		rel = 0.0;		/* none */
	} else {
		/* Convert relative tolerance to absolute tolerance
		 * by scaling w.r.t. the torus diameter.
		 */
		rel = ttol->rel * 2 * (tip->r_a+tip->r_h);
	}
	/* Take tighter of two (absolute) tolerances */
	if( ttol->abs <= 0.0 )  {
		/* No absolute tolerance given */
		if( rel <= 0.0 )  {
			/* User has no tolerance for this kind of drink! */
			nw = 8;
			nlen = 16;
		} else {
			/* Use the absolute-ized relative tolerance */
			nlen = rt_num_circular_segments( rel, tip->r_a );
			nw = rt_num_circular_segments( rel, tip->r_h );
		}
	} else {
		/* Absolute tolerance was given */
		if( rel <= 0.0 || rel > ttol->abs)
			rel = ttol->abs;
		nlen = rt_num_circular_segments( rel, tip->r_a );
		nw = rt_num_circular_segments( rel, tip->r_h );
	}

	/*
	 *  Implement surface-normal tolerance, if given
	 *	nseg = (2 * pi) / (2 * tol)
	 *  For a facet which subtends angle theta, surface normal
	 *  is exact in the center, and off by theta/2 at the edges.
	 *  Note:  1 degree tolerance requires 180*180 tessellation!
	 */
	if( ttol->norm > 0.0 )  {
		register int	nseg;
		nseg = (bn_pi / ttol->norm) + 0.99;
		if( nseg > nlen ) nlen = nseg;
		if( nseg > nw ) nw = nseg;
	}

	/* Compute the points on the surface of the torus */
	dist_to_rim = tip->r_h/tip->r_a;
	pts = (fastf_t *)bu_malloc( nw * nlen * sizeof(point_t),
		"rt_tor_plot pts[]" );

#define TOR_PT(www,lll)	((((www)%nw)*nlen)+((lll)%nlen))
#define TOR_PTA(ww,ll)	(&pts[TOR_PT(ww,ll)*3])
#define TOR_NORM_A(ww,ll)	(&norms[TOR_PT(ww,ll)*3])

	for( len = 0; len < nlen; len++ )  {
		beta = bn_twopi * len / nlen;
		cos_beta = cos(beta);
		sin_beta = sin(beta);
		/* G always points out to rim, along radius vector */
		VCOMB2( radius, cos_beta, tip->a, sin_beta, tip->b );
		/* We assume that |radius| = |A|.  Circular */
		VSCALE( G, radius, dist_to_rim );
		for( w = 0; w < nw; w++ )  {
			alpha = bn_twopi * w / nw;
			cos_alpha = cos(alpha);
			sin_alpha = sin(alpha);
			VCOMB2( edge, cos_alpha, G, sin_alpha*tip->r_h, tip->h );
			VADD3( TOR_PTA(w,len), tip->v, edge, radius );
		}
	}

	/* Draw lengthwise (around outside rim) */
	for( w = 0; w < nw; w++ )  {
		len = nlen-1;
		RT_ADD_VLIST( vhead, TOR_PTA(w,len), BN_VLIST_LINE_MOVE );
		for( len = 0; len < nlen; len++ )  {
			RT_ADD_VLIST( vhead, TOR_PTA(w,len), BN_VLIST_LINE_DRAW );
		}
	}
	/* Draw around the "width" (1 cross section) */
	for( len = 0; len < nlen; len++ )  {
		w = nw-1;
		RT_ADD_VLIST( vhead, TOR_PTA(w,len), BN_VLIST_LINE_MOVE );
		for( w = 0; w < nw; w++ )  {
			RT_ADD_VLIST( vhead, TOR_PTA(w,len), BN_VLIST_LINE_DRAW );
		}
	}

	bu_free( (char *)pts, "rt_tor_plot pts[]" );
	return(0);
}

/*
 *			R T _ T O R _ T E S S
 */
int
rt_tor_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	fastf_t		alpha;
	fastf_t		beta;
	fastf_t		cos_alpha, sin_alpha;
	fastf_t		cos_beta, sin_beta;
	fastf_t		dist_to_rim;
	struct rt_tor_internal	*tip;
	int		w;
	int		nw = 6;
	int		len;
	int		nlen = 6;
	fastf_t		*pts;
	vect_t		G;
	vect_t		radius;
	vect_t		edge;
	struct shell	*s;
	struct vertex	**verts;
	struct faceuse	**faces;
	fastf_t		*norms;
	struct vertex	**vertp[4];
	int		nfaces;
	int		i;
	fastf_t		rel;

	RT_CK_DB_INTERNAL(ip);
	tip = (struct rt_tor_internal *)ip->idb_ptr;
	RT_TOR_CK_MAGIC(tip);

	if( ttol->rel <= 0.0 || ttol->rel >= 1.0 )  {
		rel = 0.0;		/* none */
	} else {
		/* Convert relative tolerance to absolute tolerance
		 * by scaling w.r.t. the torus diameter.
		 */
		rel = ttol->rel * 2 * (tip->r_a+tip->r_h);
	}
	/* Take tighter of two (absolute) tolerances */
	if( ttol->abs <= 0.0 )  {
		/* No absolute tolerance given */
		if( rel <= 0.0 )  {
			/* User has no tolerance for this kind of drink! */
			nw = 8;
			nlen = 16;
		} else {
			/* Use the absolute-ized relative tolerance */
			nlen = rt_num_circular_segments( rel, tip->r_a );
			nw = rt_num_circular_segments( rel, tip->r_h );
		}
	} else {
		/* Absolute tolerance was given */
		if( rel <= 0.0 || rel > ttol->abs)
			rel = ttol->abs;
		nlen = rt_num_circular_segments( rel, tip->r_a );
		nw = rt_num_circular_segments( rel, tip->r_h );
	}

	/*
	 *  Implement surface-normal tolerance, if given
	 *	nseg = (2 * pi) / (2 * tol)
	 *  For a facet which subtends angle theta, surface normal
	 *  is exact in the center, and off by theta/2 at the edges.
	 *  Note:  1 degree tolerance requires 180*180 tessellation!
	 */
	if( ttol->norm > 0.0 )  {
		register int	nseg;
		nseg = (bn_pi / ttol->norm) + 0.99;
		if( nseg > nlen ) nlen = nseg;
		if( nseg > nw ) nw = nseg;
	}

	/* Compute the points on the surface of the torus */
	dist_to_rim = tip->r_h/tip->r_a;
	pts = (fastf_t *)bu_malloc( nw * nlen * sizeof(point_t),
		"rt_tor_tess pts[]" );
	norms = (fastf_t *)bu_malloc( nw * nlen * sizeof( vect_t ) , "rt_tor_tess: norms[]" );

	for( len = 0; len < nlen; len++ )  {
		beta = bn_twopi * len / nlen;
		cos_beta = cos(beta);
		sin_beta = sin(beta);
		/* G always points out to rim, along radius vector */
		VCOMB2( radius, cos_beta, tip->a, sin_beta, tip->b );
		/* We assume that |radius| = |A|.  Circular */
		VSCALE( G, radius, dist_to_rim );
		for( w = 0; w < nw; w++ )  {
			alpha = bn_twopi * w / nw;
			cos_alpha = cos(alpha);
			sin_alpha = sin(alpha);
			VCOMB2( edge, cos_alpha, G, sin_alpha*tip->r_h, tip->h );
			VADD3( TOR_PTA(w,len), tip->v, edge, radius );

			VMOVE( TOR_NORM_A(w,len) , edge );
			VUNITIZE( TOR_NORM_A(w,len) );
		}
	}

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	verts = (struct vertex **)bu_calloc( nw*nlen, sizeof(struct vertex *),
		"rt_tor_tess *verts[]" );
	faces = (struct faceuse **)bu_calloc( nw*nlen, sizeof(struct faceuse *),
		"rt_tor_tess *faces[]" );

	/* Build the topology of the torus */
	/* Note that increasing 'w' goes to the left (alpha goes ccw) */
	nfaces = 0;
	for( w = 0; w < nw; w++ )  {
		for( len = 0; len < nlen; len++ )  {
			vertp[0] = &verts[ TOR_PT(w+0,len+0) ];
			vertp[1] = &verts[ TOR_PT(w+0,len+1) ];
			vertp[2] = &verts[ TOR_PT(w+1,len+1) ];
			vertp[3] = &verts[ TOR_PT(w+1,len+0) ];
			if( (faces[nfaces++] = nmg_cmface( s, vertp, 4 )) == (struct faceuse *)0 )  {
				bu_log("rt_tor_tess() nmg_cmface failed, w=%d/%d, len=%d/%d\n",
					w, nw, len, nlen );
				nfaces--;
			}
		}
	}

	/* Associate vertex geometry */
	for( w = 0; w < nw; w++ )  {
		for( len = 0; len < nlen; len++ )  {
			nmg_vertex_gv( verts[TOR_PT(w,len)], TOR_PTA(w,len) );
		}
	}

	/* Associate face geometry */
	for( i=0; i < nfaces; i++ )  {
		if( nmg_fu_planeeqn( faces[i], tol ) < 0 )
			return -1;		/* FAIL */
	}

	/* Associate vertexuse normals */
	for( w=0 ; w<nw ; w++ )
	{
		for( len=0 ; len<nlen ; len++ )
		{
			struct vertexuse *vu;
			vect_t rev_norm;

			VREVERSE( rev_norm , TOR_NORM_A(w,len) );

			for( BU_LIST_FOR( vu , vertexuse , &verts[TOR_PT(w,len)]->vu_hd ) )
			{
				struct faceuse *fu;

				NMG_CK_VERTEXUSE( vu );

				fu = nmg_find_fu_of_vu( vu );
				NMG_CK_FACEUSE( fu );

				if( fu->orientation == OT_SAME )
					nmg_vertexuse_nv( vu , TOR_NORM_A(w,len) );
				else if( fu->orientation == OT_OPPOSITE )
					nmg_vertexuse_nv( vu , rev_norm );
			}
		}
	}

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

	bu_free( (char *)pts, "rt_tor_tess pts[]" );
	bu_free( (char *)verts, "rt_tor_tess *verts[]" );
	bu_free( (char *)faces, "rt_tor_tess *faces[]" );
	bu_free( (char *)norms , "rt_tor_tess norms[]" );
	return(0);
}


/*
 *			R T _ T O R _ I M P O R T
 *
 *  Import a torus from the database format to the internal format.
 *  Apply modeling transformations at the same time.
 */
int
rt_tor_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_tor_internal	*tip;
	union record		*rp;
	LOCAL fastf_t		vec[3*4];
	vect_t			axb;
	register fastf_t	f;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_tor_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_TOR;
	ip->idb_meth = &rt_functab[ID_TOR];
	ip->idb_ptr = bu_malloc(sizeof(struct rt_tor_internal), "rt_tor_internal");
	tip = (struct rt_tor_internal *)ip->idb_ptr;
	tip->magic = RT_TOR_INTERNAL_MAGIC;

	/* Convert from database to internal format */
	rt_fastf_float( vec, rp->s.s_values, 4 );

	/* Apply modeling transformations */
	MAT4X3PNT( tip->v, mat, &vec[0*3] );
	MAT4X3VEC( tip->h, mat, &vec[1*3] );
	MAT4X3VEC( tip->a, mat, &vec[2*3] );
	MAT4X3VEC( tip->b, mat, &vec[3*3] );

	/* Make the vectors unit length */
	tip->r_a = MAGNITUDE(tip->a);
	tip->r_b = MAGNITUDE(tip->b);
	tip->r_h = MAGNITUDE(tip->h);
	if( tip->r_a < SMALL || tip->r_b < SMALL || tip->r_h < SMALL )  {
		bu_log("rt_tor_import:  zero length A, B, or H vector\n");
		return(-1);
	}
	/* In memory, the H vector is unit length */
	f = 1.0/tip->r_h;
	VSCALE( tip->h, tip->h, f );

	/* If H does not point in the direction of A cross B, reverse H. */
	/* Somehow, database records have been written with this problem. */
	VCROSS( axb, tip->a, tip->b );
	if( VDOT( axb, tip->h ) < 0 )  {
		VREVERSE( tip->h, tip->h );
	}

	return(0);		/* OK */
}

/*
 *			R T _ T O R _ E X P O R T 5
 */
int
rt_tor_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	double			vec[2*3+2];
	struct rt_tor_internal	*tip;

	RT_CK_DB_INTERNAL( ip );
	if (ip->idb_type != ID_TOR) return -1;
	tip = (struct rt_tor_internal *)ip->idb_ptr;
	RT_TOR_CK_MAGIC(tip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * (2*3+2);
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "tor external");

	/* scale values into local buffer */
	VSCALE( &vec[0*3], tip->v, local2mm );
	VMOVE(  &vec[1*3], tip->h);		/* UNIT vector, not scaled */
	vec[2*3+0] = tip->r_a*local2mm;		/* r1 */
	vec[2*3+1] = tip->r_h*local2mm;		/* r2 */

	/* convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, 2*3+2);

	return 0;
}
/*
 *			R T _ T O R _ E X P O R T
 *
 *  The name will be added by the caller.
 */
int
rt_tor_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_tor_internal	*tip;
	union record		*rec;
	vect_t			norm;
	vect_t			cross1, cross2;
	fastf_t			r1, r2;
	fastf_t			r3, r4;
	double			m2;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_TOR )  return(-1);
	tip = (struct rt_tor_internal *)ip->idb_ptr;
	RT_TOR_CK_MAGIC(tip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "tor external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->s.s_type = TOR;

	r1 = tip->r_a;
	r2 = tip->r_h;

	/* Validate that 0 < r2 <= r1 */
	if( r2 <= 0.0 )  {
		bu_log("rt_tor_export:  illegal r2=%.12e <= 0\n", r2);
		return(-1);
	}
	if( r2 > r1 )  {
		bu_log("rt_tor_export:  illegal r2=%.12e > r1=%.12e\n",
			r2, r1);
		return(-1);
	}

	r1 *= local2mm;
	r2 *= local2mm;
	VSCALE( &rec->s.s_values[0*3], tip->v, local2mm );

	VMOVE( norm, tip->h );
	m2 = MAGNITUDE( norm );		/* F2 is NORMAL to torus */
	if( m2 <= SQRT_SMALL_FASTF )  {
		bu_log("rt_tor_export: normal magnitude is zero!\n");
		return(-1);		/* failure */
	}
	m2 = 1.0/m2;
	VSCALE( norm, norm, m2 );	/* Give normal unit length */
	VSCALE( &rec->s.s_values[1*3], norm, r2 ); /* F2: normal radius len */

	/* Create two mutually perpendicular vectors, perpendicular to Norm */
	/* Ensure that AxB points in direction of N */
	bn_vec_ortho( cross1, norm );
	VCROSS( cross2, norm, cross1 );
	VUNITIZE( cross2 );

	/* F3, F4 are perpendicular, goto center of solid part */
	VSCALE( &rec->s.s_values[2*3], cross1, r1 );
	VSCALE( &rec->s.s_values[3*3], cross2, r1 );

	/*
	 * The rest of these provide no real extra information,
	 * and exist for compatability with old versions of MGED.
	 */
	r3=r1-r2;	/* Radius to inner circular edge */
	r4=r1+r2;	/* Radius to outer circular edge */

	/* F5, F6 are perpendicular, goto inner edge of ellipse */
	VSCALE( &rec->s.s_values[4*3], cross1, r3 );
	VSCALE( &rec->s.s_values[5*3], cross2, r3 );

	/* F7, F8 are perpendicular, goto outer edge of ellipse */
	VSCALE( &rec->s.s_values[6*3], cross1, r4 );
	VSCALE( &rec->s.s_values[7*3], cross2, r4 );

	return(0);
}

/*
 *			R T _ T O R _ I M P O R T 5
 *
 *	Taken from the database record:
 *		v	vertex (point) of center of torus.
 *		h	unit vector in the normal direction of the torus
 *		major	radius of ring from 'v' to center of ring
 *		minor	radius of the ring
 *
 *	Calculate:
 *		2nd radius of ring (==1st radius)
 *		ring unit vector 1
 *		ring unit vector 2
 */
int
rt_tor_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_tor_internal	*tip;
	LOCAL struct rec {
		double	v[3];
		double	h[3];
		double	ra;	/* r1 */
		double	rh;	/* r2 */
	} rec;


	BU_CK_EXTERNAL( ep );
	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * (2*3+2) );

	RT_CK_DB_INTERNAL( ip );

	if (bn_mat_is_non_unif(mat)) {
		bu_log("------------------ WARNING ----------------\nNon-uniform matrix transform on torus.  Ignored\n");
	}


	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_TOR;
	ip->idb_meth = &rt_functab[ID_TOR];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_tor_internal), "rt_tor_internal");
	tip = (struct rt_tor_internal *)ip->idb_ptr;

	tip->magic = RT_TOR_INTERNAL_MAGIC;

	ntohd( (unsigned char *)&rec, ep->ext_buf, 2*3+2);

	/* Apply modeling transformations */
	MAT4X3PNT( tip->v, mat, rec.v );
	MAT4X3VEC( tip->h, mat, rec.h );
	VUNITIZE( tip->h );			/* just to be sure */

	tip->r_a = rec.ra / mat[15];
	tip->r_h = rec.rh / mat[15];

	/* Prepare the extra information */
	tip->r_b = tip->r_a;

	/* Calculate two mutually perpendicular vectors, perpendicular to N */
	bn_vec_ortho( tip->a, tip->h );		/* a has unit length */
	VCROSS( tip->b, tip->h, tip->a);	/* |A| = |H| = 1, so |B|=1 */

	VSCALE(tip->a, tip->a, tip->r_a);
	VSCALE(tip->b, tip->b, tip->r_b);
	return 0;
}
/*
 *			R T _ T O R _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_tor_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_tor_internal	*tip =
		(struct rt_tor_internal *)ip->idb_ptr;
	double				r3, r4;

	RT_TOR_CK_MAGIC(tip);
	bu_vls_strcat( str, "torus (TOR)\n");

	bu_vls_printf( str, "\tV (%g, %g, %g), r1=%g (A), r2=%g (H)\n",
		tip->v[X] * mm2local,
		tip->v[Y] * mm2local,
		tip->v[Z] * mm2local,
		tip->r_a * mm2local, tip->r_h * mm2local );

	bu_vls_printf( str, "\tN=(%g, %g, %g)\n",
		tip->h[X] * mm2local,
		tip->h[Y] * mm2local,
		tip->h[Z] * mm2local );

	if( !verbose )  return(0);

	bu_vls_printf( str, "\tA=(%g, %g, %g)\n",
		tip->a[X] * mm2local / tip->r_a,
		tip->a[Y] * mm2local / tip->r_a,
		tip->a[Z] * mm2local / tip->r_a );

	bu_vls_printf( str, "\tB=(%g, %g, %g)\n",
		tip->b[X] * mm2local / tip->r_b,
		tip->b[Y] * mm2local / tip->r_b,
		tip->b[Z] * mm2local / tip->r_b );

	r3 = tip->r_a - tip->r_h;
	bu_vls_printf( str, "\tvector to inner edge = (%g, %g, %g)\n",
		tip->a[X] * mm2local / tip->r_a * r3,
		tip->a[Y] * mm2local / tip->r_a * r3,
		tip->a[Z] * mm2local / tip->r_a * r3 );

	r4 = tip->r_a + tip->r_h;
	bu_vls_printf( str, "\tvector to outer edge = (%g, %g, %g)\n",
		tip->a[X] * mm2local / tip->r_a * r4,
		tip->a[Y] * mm2local / tip->r_a * r4,
		tip->a[Z] * mm2local / tip->r_a * r4 );

	return(0);
}

/*
 *			R T _ T O R _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_tor_ifree(struct rt_db_internal *ip)
{
	register struct rt_tor_internal	*tip;

	RT_CK_DB_INTERNAL(ip);
	tip = (struct rt_tor_internal *)ip->idb_ptr;
	RT_TOR_CK_MAGIC(tip);

	bu_free( (char *)tip, "rt_tor_internal" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}
@


11.37
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /cvs/brlcad/librt/g_torus.c,v 11.36 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.36
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header$ (BRL)";
d26 5
a30 1
#include "conf.h"
@


11.35
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.34 2002/08/20 17:08:02 jra Exp $ (BRL)";
d172 1
a172 4
rt_tor_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d193 1
a193 1
	if( ! NEAR_ZERO(f, 0.0001) )  {
d199 1
a199 1
	if( ! NEAR_ZERO(f, 0.0001) )  {
d205 1
a205 1
	if( ! NEAR_ZERO(f, 0.0001) )  {
d286 1
a286 2
rt_tor_print( stp )
register const struct soltab *stp;
d333 1
a333 5
rt_tor_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d436 1
a436 1
		if( NEAR_ZERO( val[j].im, 0.0001 ) )
d520 6
a525 6
rt_tor_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d669 1
a669 1
		if( NEAR_ZERO( val[i][0].im, 0.0001 ) )
d671 1
a671 1
		if( NEAR_ZERO( val[i][1].im, 0.0001 ) ) {
d674 1
a674 1
		if( NEAR_ZERO( val[i][2].im, 0.0001 ) ) {
d677 1
a677 1
		if( NEAR_ZERO( val[i][3].im, 0.0001 ) ) {
d802 1
a802 4
rt_tor_norm( hitp, stp, rp)
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d819 1
d829 1
a829 4
rt_tor_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d844 1
a844 1
	if( !NEAR_ZERO(nz, 0.0001) ) {
d848 1
a848 1
	} else if( !NEAR_ZERO(ny, 0.0001) ) {
d874 1
a874 5
rt_tor_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d902 1
a902 2
rt_tor_free( stp )
struct soltab *stp;
d911 1
a911 1
rt_tor_class()
d982 1
a982 5
rt_tor_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d1097 1
a1097 6
rt_tor_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d1277 1
a1277 5
rt_tor_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1336 1
a1336 5
rt_tor_export5( ep , ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1367 1
a1367 5
rt_tor_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1461 1
a1461 5
rt_tor_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1519 1
a1519 5
rt_tor_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1572 1
a1572 2
rt_tor_ifree( ip )
struct rt_db_internal	*ip;
@


11.34
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985 by the United States Army.
d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.32 2002/03/05 18:04:27 morrison Exp $ (BRL)";
@


11.34.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_torus.c,v 11.35 2004/02/02 17:39:22 morrison Exp $ (BRL)";
@


11.34.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.35 2004/02/02 17:39:22 morrison Exp $ (BRL)";
@


11.34.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.34.10.1 2004/02/12 18:37:42 erikg Exp $ (BRL)";
@


11.34.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.34 2002/08/20 17:08:02 jra Exp $ (BRL)";
d172 4
a175 1
rt_tor_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d289 2
a290 1
rt_tor_print(register const struct soltab *stp)
d337 5
a341 1
rt_tor_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d528 6
a533 6
rt_tor_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d810 4
a813 1
rt_tor_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d839 4
a842 1
rt_tor_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d887 5
a891 1
rt_tor_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d919 2
a920 1
rt_tor_free(struct soltab *stp)
d929 1
a929 1
rt_tor_class(void)
d1000 5
a1004 1
rt_tor_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1119 6
a1124 1
rt_tor_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1304 5
a1308 1
rt_tor_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1367 5
a1371 1
rt_tor_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1402 5
a1406 1
rt_tor_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1500 5
a1504 1
rt_tor_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1562 5
a1566 1
rt_tor_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1619 2
a1620 1
rt_tor_ifree(struct rt_db_internal *ip)
@


11.34.2.2
log
@updated hard-coded tolerances to use the run-time ray-trace instance pointer tolerance
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.34.2.1 2002/09/19 18:01:37 morrison Exp $ (BRL)";
d193 1
a193 1
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
d199 1
a199 1
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
d205 1
a205 1
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
d436 1
a436 1
		if( NEAR_ZERO( val[j].im, ap->a_rt_i->rti_tol.dist ) )
d669 1
a669 1
		if( NEAR_ZERO( val[i][0].im, ap->a_rt_i->rti_tol.dist ) )
d671 1
a671 1
		if( NEAR_ZERO( val[i][1].im, ap->a_rt_i->rti_tol.dist ) ) {
d674 1
a674 1
		if( NEAR_ZERO( val[i][2].im, ap->a_rt_i->rti_tol.dist ) ) {
d677 1
a677 1
		if( NEAR_ZERO( val[i][3].im, ap->a_rt_i->rti_tol.dist ) ) {
a818 1

d843 1
a843 1
	if( !NEAR_ZERO(nz, 0.00001) ) {
d847 1
a847 1
	} else if( !NEAR_ZERO(ny, 0.00001) ) {
@


11.34.2.3
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header$ (BRL)";
@


11.33
log
@Converted from K&R to ANSI C - RFH
@
text
@d172 4
a175 1
rt_tor_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d289 2
a290 1
rt_tor_print(register const struct soltab *stp)
d337 5
a341 1
rt_tor_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d528 6
a533 6
rt_tor_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d810 4
a813 1
rt_tor_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d839 4
a842 1
rt_tor_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d887 5
a891 1
rt_tor_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d919 2
a920 1
rt_tor_free(struct soltab *stp)
d929 1
a929 1
rt_tor_class(void)
d1000 5
a1004 1
rt_tor_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1119 6
a1124 1
rt_tor_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1304 5
a1308 1
rt_tor_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1367 5
a1371 1
rt_tor_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1402 5
a1406 1
rt_tor_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1500 5
a1504 1
rt_tor_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1562 5
a1566 1
rt_tor_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1619 2
a1620 1
rt_tor_ifree(struct rt_db_internal *ip)
@


11.32
log
@whitespace
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.31 2002/03/01 19:42:16 jra Exp $ (BRL)";
d172 1
a172 4
rt_tor_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d286 1
a286 2
rt_tor_print( stp )
register const struct soltab *stp;
d333 1
a333 5
rt_tor_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d520 6
a525 6
rt_tor_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d802 1
a802 4
rt_tor_norm( hitp, stp, rp)
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d828 1
a828 4
rt_tor_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d873 1
a873 5
rt_tor_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d901 1
a901 2
rt_tor_free( stp )
struct soltab *stp;
d910 1
a910 1
rt_tor_class()
d981 1
a981 5
rt_tor_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d1096 1
a1096 6
rt_tor_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d1276 1
a1276 5
rt_tor_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1335 1
a1335 5
rt_tor_export5( ep , ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1366 1
a1366 5
rt_tor_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1460 1
a1460 5
rt_tor_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1518 1
a1518 5
rt_tor_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1571 1
a1571 2
rt_tor_ifree( ip )
struct rt_db_internal	*ip;
@


11.31
log
@import5 was not scaling radii!!!!
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.30 2002/02/28 01:03:36 butler Exp $ (BRL)";
d1521 1
a1521 2
	    bu_log("------------------ WARNING ----------------\n\
     Non-uniform matrix transform on torus.  Ignored\n");
@


11.30
log
@added call to bn_mat_is_non_unif() to check for (and warn about) non-uniform scaling
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.29 2001/10/02 19:24:30 jra Exp $ (BRL)";
d1541 2
a1542 2
	tip->r_a = rec.ra;
	tip->r_h = rec.rh;
d1545 1
a1545 1
	tip->r_b = rec.ra;
@


11.29
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.28 2001/04/20 22:29:48 morrison Exp $ (BRL)";
d1514 1
d1519 6
@


11.28
log
@CONST to const
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.27 2001/04/02 21:38:09 morrison Exp $ (BRL)";
d1325 1
d1519 1
@


11.27
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.26 2001/03/31 01:57:10 morrison Exp $ (BRL)";
d51 1
a51 1
CONST struct bu_structparse rt_tor_parse[] = {
d290 1
a290 1
register CONST struct soltab *stp;
d292 1
a292 1
	register CONST struct tor_specific *tor =
d1003 2
a1004 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d1123 2
a1124 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d1306 3
a1308 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1368 1
a1368 1
CONST struct rt_db_internal	*ip;
d1370 1
a1370 1
CONST struct db_i		*dbip;
d1403 1
a1403 1
CONST struct rt_db_internal	*ip;
d1405 1
a1405 1
CONST struct db_i		*dbip;
d1501 3
a1503 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1556 1
a1556 1
CONST struct rt_db_internal	*ip;
@


11.26
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.25 2000/10/18 18:10:35 butler Exp $ (BRL)";
d241 1
a241 1
	bn_mat_copy( tor->tor_SoR, R );
@


11.25
log
@Patches for compiling under RedHat 7.0
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.24 2000/08/25 21:04:00 mike Exp $ (BRL)";
d234 1
a234 1
	bn_mat_idn( R );
@


11.24
log
@
Converted describe method to use bu_vls_printf().
Clarified the import5 routine.
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.23 2000/08/21 02:02:31 butler Exp $ (BRL)";
d29 3
@


11.23
log
@Massive compilation warnings eliminated
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.22 2000/07/10 23:01:36 mike Exp $ (BRL)";
d1369 1
a1369 1
	fastf_t			vec[2*3+2];
d1384 2
a1385 2
	vec[2*3+0] = tip->r_a*local2mm;
	vec[2*3+1] = tip->r_h*local2mm;
d1484 1
a1484 1
 *	rec:
d1503 6
a1508 1
	LOCAL fastf_t		vec[2*3+2];
d1522 1
a1522 1
	ntohd( (unsigned char *)vec, ep->ext_buf, 2*3+2);
d1525 6
a1530 2
	MAT4X3PNT( tip->v, mat, &vec[0*3] );
	MAT4X3VEC( tip->h, mat, &vec[1*3] );
d1532 2
a1533 2
	tip->r_a = tip->r_b = vec[2*3];
	tip->r_h = vec[2*3+1];
d1536 3
a1538 7
	bn_vec_ortho( tip->a, tip->h );
	VCROSS( tip->b, tip->h, tip->a);
	VUNITIZE( tip->b );
	/*
	 * XXX - This is not normally allowed in vmath macros, having source
	 * and destination being the same.
	 */
a1558 1
	char				buf[256];
d1564 1
a1564 1
	sprintf(buf, "\tV (%g, %g, %g), r1=%g (A), r2=%g (H)\n",
a1568 1
	bu_vls_strcat( str, buf );
d1570 1
a1570 1
	sprintf(buf, "\tN=(%g, %g, %g)\n",
a1573 1
	bu_vls_strcat( str, buf );
d1577 1
a1577 1
	sprintf(buf, "\tA=(%g, %g, %g)\n",
a1580 1
	bu_vls_strcat( str, buf );
d1582 1
a1582 1
	sprintf(buf, "\tB=(%g, %g, %g)\n",
a1585 1
	bu_vls_strcat( str, buf );
d1588 1
a1588 1
	sprintf(buf, "\tvector to inner edge = (%g, %g, %g)\n",
a1591 1
	bu_vls_strcat( str, buf );
d1594 1
a1594 1
	sprintf(buf, "\tvector to outer edge = (%g, %g, %g)\n",
a1597 1
	bu_vls_strcat( str, buf );
@


11.22
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d23 1
a23 1
static const char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.21 2000/06/30 15:38:04 mike Exp $ (BRL)";
d53 2
a54 1
    {0} };
d931 56
a1292 58
/* 
 *			R T _ N U M _ C I R C U L A R _ S E G M E N T S
 *
 *  Given a circle with a specified radius, determine the minimum number
 *  of straight line segments that the circle can be approximated with,
 *  while still meeting the given maximum permissible error distance.
 *  Form a chord (straight line) by
 *  connecting the start and end points found when
 *  sweeping a 'radius' arc through angle 'theta'.
 *
 *  The error distance is the distance between where a radius line
 *  at angle theta/2 hits the chord, and where it hits the circle
 *  (at 'radius' distance).
 *
 *	error_distance = radius * ( 1 - cos( theta/2 ) )
 *
 *  or
 *
 *	theta = 2 * acos( 1 - error_distance / radius )
 *
 *  Returns -
 *	number of segments.  Always at least 6.
 */
int
rt_num_circular_segments( maxerr, radius )
double	maxerr;
double	radius;
{
	register fastf_t	cos_half_theta;
	register fastf_t	half_theta;
	int			n;

	if( radius <= 0.0 || maxerr <= 0.0 || maxerr >= radius )  {
		/* Return a default number of segments */
		return(6);
	}
	cos_half_theta = 1.0 - maxerr / radius;
	/* There does not seem to be any reasonable way to express the
	 * acos in terms of an atan2(), so extra checking is done.
	 */
	if( cos_half_theta <= 0.0 || cos_half_theta >= 1.0 )  {
		/* Return a default number of segments */
		return(6);
	}
	half_theta = acos( cos_half_theta );
	if( half_theta < SMALL )  {
		/* A very large number of segments will be needed.
		 * Impose an upper bound here
		 */
		return( 360*10 );
	}
	n = bn_pi / half_theta + 0.99;

	/* Impose the limits again */
	if( n <= 6 )  return(6);
	if( n >= 360*10 )  return( 360*10 );
	return(n);
}
@


11.21
log
@
export methods should not init the external structure, just check them.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.20 2000/06/30 15:31:15 mike Exp $ (BRL)";
@


11.20
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.19 2000/06/27 17:30:43 cjohnson Exp $ (BRL)";
d1378 1
a1378 1
	BU_INIT_EXTERNAL(ep);
d1418 1
a1418 1
	BU_INIT_EXTERNAL(ep);
@


11.19
log
@Vectors in ring must contain the scale factors of r_a and r_b
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.18 2000/06/27 15:07:03 cjohnson Exp $ (BRL)";
d1322 1
a1322 1
	RT_INIT_DB_INTERNAL( ip );
d1509 1
a1509 1
	RT_INIT_DB_INTERNAL( ip );
@


11.18
log
@Check input length to make sure it matches expected lengths.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.17 2000/06/27 13:58:41 cjohnson Exp $ (BRL)";
d1531 6
@


11.17
log
@Idiot strike.  VMOVE not VCOPY
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.16 2000/06/27 03:53:46 cjohnson Exp $ (BRL)";
d1507 1
@


11.16
log
@Add import/export routines for the DB5 database format.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.15 2000/06/26 21:25:43 cjohnson Exp $ (BRL)";
d1384 1
a1384 1
	VCOPY(  &vec[1*3], tip->h);		/* UNIT vector, not scaled */
@


11.15
log
@Partial commitment so that work can continue at home.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.14 1999/11/26 21:46:49 mike Exp $ (BRL)";
d1361 33
d1484 11
d1505 26
@


11.14
log
@
Lint cleanups
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.13 1999/11/24 23:12:09 mike Exp $ (BRL)";
d1449 13
@


11.13
log
@
Made structparse tables CONST
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.12 1999/11/17 02:42:03 mike Exp $ (BRL)";
d1013 3
a1015 3
#define PT(www,lll)	((((www)%nw)*nlen)+((lll)%nlen))
#define PTA(ww,ll)	(&pts[PT(ww,ll)*3])
#define NORM_A(ww,ll)	(&norms[PT(ww,ll)*3])
d1030 1
a1030 1
			VADD3( PTA(w,len), tip->v, edge, radius );
d1037 1
a1037 1
		RT_ADD_VLIST( vhead, PTA(w,len), BN_VLIST_LINE_MOVE );
d1039 1
a1039 1
			RT_ADD_VLIST( vhead, PTA(w,len), BN_VLIST_LINE_DRAW );
d1045 1
a1045 1
		RT_ADD_VLIST( vhead, PTA(w,len), BN_VLIST_LINE_MOVE );
d1047 1
a1047 1
			RT_ADD_VLIST( vhead, PTA(w,len), BN_VLIST_LINE_DRAW );
d1154 1
a1154 1
			VADD3( PTA(w,len), tip->v, edge, radius );
d1156 2
a1157 2
			VMOVE( NORM_A(w,len) , edge );
			VUNITIZE( NORM_A(w,len) );
d1174 4
a1177 4
			vertp[0] = &verts[ PT(w+0,len+0) ];
			vertp[1] = &verts[ PT(w+0,len+1) ];
			vertp[2] = &verts[ PT(w+1,len+1) ];
			vertp[3] = &verts[ PT(w+1,len+0) ];
d1189 1
a1189 1
			nmg_vertex_gv( verts[PT(w,len)], PTA(w,len) );
d1207 1
a1207 1
			VREVERSE( rev_norm , NORM_A(w,len) );
d1209 1
a1209 1
			for( BU_LIST_FOR( vu , vertexuse , &verts[PT(w,len)]->vu_hd ) )
d1219 1
a1219 1
					nmg_vertexuse_nv( vu , NORM_A(w,len) );
d1302 1
a1302 1
rt_tor_import( ip, ep, mat )
d1306 1
d1366 1
a1366 1
rt_tor_export( ep, ip, local2mm )
d1370 1
@


11.12
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.11 1999/07/02 22:19:24 mike Exp $ (BRL)";
d48 1
a48 1
struct bu_structparse rt_tor_parse[] = {
@


11.11
log
@
Removed dependence on compat4.h
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.10 1999/05/27 19:10:43 mike Exp $ (BRL)";
d1323 1
@


11.10
log
@
sed4
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_torus.c,v 11.9 1998/03/26 07:53:50 mike Exp $ (BRL)";
a36 2
#include "./complex.h"
#include "./polyno.h"
d345 1
a345 1
	LOCAL poly	C;		/* The final equation */
d350 2
a351 2
	LOCAL poly	A, Asqr;
	LOCAL poly	X2_Y2;		/* X**2 + Y**2 */
d536 1
a536 1
	LOCAL poly	*C;		/* The final equation */
d540 2
a541 2
	LOCAL poly	A, Asqr;
	LOCAL poly	X2_Y2;		/* X**2 + Y**2 */
d546 3
a548 3
        C = (poly *)bu_malloc(n * sizeof(poly), "tor poly");
	val = (complex (*)[4])bu_malloc(n * sizeof(complex) * 4,
		"tor complex");
d1037 1
a1037 1
		RT_ADD_VLIST( vhead, PTA(w,len), RT_VLIST_LINE_MOVE );
d1039 1
a1039 1
			RT_ADD_VLIST( vhead, PTA(w,len), RT_VLIST_LINE_DRAW );
d1045 1
a1045 1
		RT_ADD_VLIST( vhead, PTA(w,len), RT_VLIST_LINE_MOVE );
d1047 1
a1047 1
			RT_ADD_VLIST( vhead, PTA(w,len), RT_VLIST_LINE_DRAW );
@


11.9
log
@Another CONST
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 11.8 1998/03/26 07:51:58 mike Exp mike $ (BRL)";
d186 1
a186 1
		rt_log("tor(%s):  (|A|=%f) != (|B|=%f) \n",
d195 1
a195 1
		rt_log("tor(%s):  A not perpendicular to B, f=%f\n",
d201 1
a201 1
		rt_log("tor(%s):  B not perpendicular to H, f=%f\n",
d207 1
a207 1
		rt_log("tor(%s):  A not perpendicular to H, f=%f\n",
d214 2
a215 2
		rt_log("r1 = %f, r2 = %f\n", tip->r_a, tip->r_h );
		rt_log("tor(%s):  0 < r2 <= r1 is not true\n", stp->st_name);
d220 1
a220 1
	GETSTRUCT( tor, tor_specific );
d232 1
a232 1
	mat_idn( R );
d236 1
a236 1
	mat_inv( tor->tor_invR, R );
d239 1
a239 1
	mat_copy( tor->tor_SoR, R );
d293 3
a295 3
	rt_log("r2/r1 (alpha) = %f\n", tor->tor_alpha);
	rt_log("r1 = %f\n", tor->tor_r1);
	rt_log("r2 = %f\n", tor->tor_r2);
d298 2
a299 2
	mat_print("S o R", tor->tor_SoR );
	mat_print("invR", tor->tor_invR );
d414 1
a414 1
	/* Inline expansion of rt_poly_scale( &X2_Y2, 4.0 ) and
d429 2
a430 2
			rt_log("tor:  rt_poly_roots() 4!=%d\n", i);
			rt_pr_roots( stp->st_name, val, i );
d456 2
a457 2
		rt_log("rt_tor_shot: reduced 4 to %d roots\n",i);
		rt_pr_roots( stp->st_name, val, 4 );
d501 1
a501 1
	RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d515 1
a515 1
	RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d548 2
a549 2
        C = (poly *)rt_malloc(n * sizeof(poly), "tor poly");
	val = (complex (*)[4])rt_malloc(n * sizeof(complex) * 4,
d551 1
a551 1
	cor_proj = (fastf_t *)rt_malloc(n * sizeof(fastf_t), "tor proj");
d630 1
a630 1
		/* Inline expansion of (void) rt_poly_scale( &X2_Y2, 4.0 ) */
d654 2
a655 2
				rt_log("tor:  rt_poly_roots() 4!=%d\n", num_roots);
				rt_pr_roots( "tor", val[i], num_roots );
d694 2
a695 2
			rt_log("rt_tor_shot: reduced 4 to %d roots\n",i);
			rt_pr_roots( stp->st_name, val, 4 );
d775 3
a777 3
	rt_free( (char *)C, "tor C");
	rt_free( (char *)val, "tor val");
	rt_free( (char *)cor_proj, "tor cor_proj");
d903 1
a903 1
	uvp -> uv_u = atan2(pprime[Y], pprime[X]) * rt_inv2pi + 0.5;
d910 1
a910 1
	uvp -> uv_v = atan2(pprime2[Z], costheta) * rt_inv2pi + 0.5;
d923 1
a923 1
	rt_free( (char *)tor, "tor_specific");
d943 1
a943 1
struct rt_list		*vhead;
d946 1
a946 1
CONST struct rt_tol	*tol;
d1005 1
a1005 1
		nseg = (rt_pi / ttol->norm) + 0.99;
d1012 1
a1012 1
	pts = (fastf_t *)rt_malloc( nw * nlen * sizeof(point_t),
d1020 1
a1020 1
		beta = rt_twopi * len / nlen;
d1028 1
a1028 1
			alpha = rt_twopi * w / nw;
d1053 1
a1053 1
	rt_free( (char *)pts, "rt_tor_plot pts[]" );
d1066 1
a1066 1
CONST struct rt_tol	*tol;
d1132 1
a1132 1
		nseg = (rt_pi / ttol->norm) + 0.99;
d1139 1
a1139 1
	pts = (fastf_t *)rt_malloc( nw * nlen * sizeof(point_t),
d1141 1
a1141 1
	norms = (fastf_t *)rt_malloc( nw * nlen * sizeof( vect_t ) , "rt_tor_tess: norms[]" );
d1144 1
a1144 1
		beta = rt_twopi * len / nlen;
d1152 1
a1152 1
			alpha = rt_twopi * w / nw;
d1164 1
a1164 1
	s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d1166 1
a1166 1
	verts = (struct vertex **)rt_calloc( nw*nlen, sizeof(struct vertex *),
d1168 1
a1168 1
	faces = (struct faceuse **)rt_calloc( nw*nlen, sizeof(struct faceuse *),
d1181 1
a1181 1
				rt_log("rt_tor_tess() nmg_cmface failed, w=%d/%d, len=%d/%d\n",
d1211 1
a1211 1
			for( RT_LIST_FOR( vu , vertexuse , &verts[PT(w,len)]->vu_hd ) )
d1231 4
a1234 4
	rt_free( (char *)pts, "rt_tor_tess pts[]" );
	rt_free( (char *)verts, "rt_tor_tess *verts[]" );
	rt_free( (char *)faces, "rt_tor_tess *faces[]" );
	rt_free( (char *)norms , "rt_tor_tess norms[]" );
d1289 1
a1289 1
	n = rt_pi / half_theta + 0.99;
d1306 1
a1306 1
CONST struct rt_external	*ep;
d1315 1
a1315 1
	RT_CK_EXTERNAL( ep );
d1319 1
a1319 1
		rt_log("rt_tor_import: defective record\n");
d1325 1
a1325 1
	ip->idb_ptr = rt_malloc(sizeof(struct rt_tor_internal), "rt_tor_internal");
d1343 1
a1343 1
		rt_log("rt_tor_import:  zero length A, B, or H vector\n");
d1367 1
a1367 1
struct rt_external		*ep;
d1384 1
a1384 1
	RT_INIT_EXTERNAL(ep);
d1386 1
a1386 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "tor external");
d1397 1
a1397 1
		rt_log("rt_tor_export:  illegal r2=%.12e <= 0\n", r2);
d1401 1
a1401 1
		rt_log("rt_tor_export:  illegal r2=%.12e > r1=%.12e\n",
d1413 1
a1413 1
		rt_log("rt_tor_export: normal magnitude is zero!\n");
d1422 1
a1422 1
	mat_vec_ortho( cross1, norm );
d1457 1
a1457 1
struct rt_vls		*str;
d1468 1
a1468 1
	rt_vls_strcat( str, "torus (TOR)\n");
d1475 1
a1475 1
	rt_vls_strcat( str, buf );
d1481 1
a1481 1
	rt_vls_strcat( str, buf );
d1489 1
a1489 1
	rt_vls_strcat( str, buf );
d1495 1
a1495 1
	rt_vls_strcat( str, buf );
d1502 1
a1502 1
	rt_vls_strcat( str, buf );
d1509 1
a1509 1
	rt_vls_strcat( str, buf );
d1529 1
a1529 1
	rt_free( (char *)tip, "rt_tor_internal" );
@


11.8
log
@CONST rt_tol
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 11.7 1998/03/24 04:49:58 mike Exp mike $ (BRL)";
d1066 1
a1066 1
struct rt_tol		*tol;
d1458 1
a1458 1
struct rt_db_internal	*ip;
@


11.7
log
@Set hit_surfno, since these values are user-visible now.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 11.6 1997/06/17 19:22:35 gdurf Exp mike $ (BRL)";
d946 1
a946 1
struct rt_tol		*tol;
@


11.6
log
@Moved rt_tor_parse into this file (and out of tcl.c)
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 11.5 1997/02/27 21:28:03 pjt Exp gdurf $ (BRL)";
d497 1
d512 1
@


11.5
log
@rt_tor_uv() works now
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 11.4 1997/02/26 21:26:33 pjt Exp pjt $ (BRL)";
d49 7
@


11.4
log
@Began adding a real rt_tor_uv()
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 11.3 1996/08/31 10:51:55 mike Exp $ (BRL)";
a881 6
#if 0
	/* Do nothing.  Really, should do something like what REC does,
	 * ie, angle around center & angle around rim */
	uvp->uv_u = uvp->uv_v = 0;
	uvp->uv_du = uvp->uv_dv = 0;
#else
d891 4
a894 1
	uvp -> uv_u = atan2(pprime[Y], pprime[X]) * rt_inv2pi;
d901 1
a901 2
	uvp -> uv_v = atan2(costheta, pprime2[Z]) * rt_inv2pi;
#endif
@


11.3
log
@bn.h
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 11.2 1995/11/07 19:36:42 adam Exp mike $ (BRL)";
d882 1
d887 19
@


11.2
log
@Matching malloc and free messages -- rt_tor_internal
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 11.1 1995/01/04 09:57:06 mike Rel4_4 adam $ (BRL)";
d341 1
a341 1
	LOCAL complex	val[MAXP];	/* The complex roots */
d530 1
a530 1
	LOCAL complex	(*val)[MAXP];	/* The complex roots */
d540 1
a540 1
	val = (complex (*)[MAXP])rt_malloc(n * sizeof(complex) * MAXP,
d646 1
a646 1
				rt_pr_roots( "tor", val, num_roots );
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 10.10 94/12/27 17:14:42 mike Exp $ (BRL)";
d1504 1
a1504 1
	rt_free( (char *)tip, "tor ifree" );
@


10.10
log
@Fix to bug #247
Added rt_prefix and regularized names like polyRoots into rt_poly_roots.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 10.9 94/12/27 11:33:03 jra Exp Locker: mike $ (BRL)";
@


10.9
log
@Improved vertexuse normal calculation.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/g_torus.c,v 10.8 94/09/16 08:46:39 jra Exp Locker: jra $ (BRL)";
d398 1
a398 1
	/* Inline expansion of (void) polyMul( &A, &A, &Asqr ) */
d407 2
a408 2
	/* Inline expansion of polyScal( &X2_Y2, 4.0 ) and
	 * polySub( &Asqr, &X2_Y2, &C ).
d420 1
a420 1
	if ( (i = polyRoots( &C, val )) != 4 ){
d422 1
a422 1
			rt_log("tor:  polyRoots() 4!=%d\n", i);
d608 1
a608 1
		/* Inline expansion of (void) polyMul( &A, &A, &Asqr ) */
d621 1
a621 1
		/* Inline expansion of (void) polyScal( &X2_Y2, 4.0 ) */
d626 1
a626 1
		/* Inline expansion of (void) polySub( &Asqr, &X2_Y2, &C ) */
d643 1
a643 1
		if ( (num_roots = polyRoots( &(C[i]), &(val[i][0]) )) != 4 ){
d645 1
a645 1
				rt_log("tor:  polyRoots() 4!=%d\n", num_roots);
@


10.8
log
@Fixed bnug in vertexuse normal calculation.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 10.7 94/09/13 15:59:05 jra Exp Locker: jra $ (BRL)";
d1133 2
a1134 1
			VCOMB2( NORM_A(w,len), cos_alpha/tip->r_h , radius , sin_alpha , tip->h );
@


10.7
log
@removed call to nmg_mark_edges_real.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 10.6 94/09/10 04:35:50 mike Exp Locker: jra $ (BRL)";
d1133 1
a1133 1
			VCOMB2( NORM_A(w,len), cos_alpha , radius , sin_alpha , tip->h );
@


10.6
log
@Reduced lots of mallocs for normal vectors to a single call.
This also caused it to stop core dumping.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 10.5 94/09/09 16:09:24 jra Exp Locker: mike $ (BRL)";
a1200 3

	/* Mark edges as real */
	nmg_mark_edges_real( &s->l );
@


10.5
log
@Free'd some memory (forgotten in previous mod).
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 10.4 94/09/09 14:22:41 jra Exp Locker: jra $ (BRL)";
d992 1
d1060 1
a1060 1
	vect_t		**norms;
d1116 1
a1116 3
	norms = (vect_t **)rt_calloc( nlen , sizeof( vect_t *) , "rt_tor_tess: norms" );
	for( len=0 ; len<nlen ; len++ )
		norms[len] = (vect_t *)rt_calloc( nw , sizeof( vect_t ) , "rt_tor_tess: norms[len]" );
d1133 1
a1133 1
			VCOMB2( norms[len][w] , cos_alpha , radius , sin_alpha , tip->h );
d1183 1
a1183 1
			VREVERSE( rev_norm , norms[len][w] );
d1195 1
a1195 1
					nmg_vertexuse_nv( vu , norms[len][w] );
d1211 1
a1211 3
	for( len=0 ; len<nlen ; len++ )
		rt_free( (char *)norms[i] , "rt_tor_tess norms[]" );
	rt_free( (char *)norms , "rt_tor_tess norms" );
@


10.4
log
@Added vertexuse normals and set edge is_real flags in tesselator
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 10.3 94/08/10 18:39:45 gdurf Exp Locker: jra $ (BRL)";
d1212 3
@


10.3
log
@Added include of conf.h
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 10.2 1993/11/18 01:44:13 mike Exp gdurf $ (BRL)";
d1059 1
d1115 3
d1133 2
d1175 30
@


10.2
log
@Added tol arg to bounding box routines
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 10.1 91/10/12 06:40:27 mike Rel4_0 $ (BRL)";
d25 2
@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.33 91/09/24 00:40:23 butler Exp $ (BRL)";
d1169 1
a1169 1
	nmg_region_a( *r );
@


9.33
log
@removed statement "register struct seg;" from line 727
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/g_torus.c,v 9.32 91/09/20 23:31:30 butler Exp $ (BRL)";
@


9.32
log
@removing fuzz with lint
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.31 91/06/30 00:11:00 mike Exp $ (BRL)";
a726 1
		register struct seg;
@


9.31
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.30 91/06/22 22:30:41 mike Exp $ (BRL)";
d727 1
a727 1
		register struct seg *seg2p;
a1401 1
	register int			j;
a1404 1
	int				i;
@


9.30
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.29 91/06/13 05:34:46 mike Exp $ (BRL)";
d279 1
a279 1
register struct soltab *stp;
d281 1
a281 1
	register struct tor_specific *tor =
d1245 3
a1247 3
struct rt_db_internal	*ip;
struct rt_external	*ep;
register mat_t		mat;
d1307 3
a1309 3
struct rt_external	*ep;
struct rt_db_internal	*ip;
double			local2mm;
@


9.29
log
@Force things so that AxB points in direction of N
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.28 91/06/13 01:58:11 mike Exp $ (BRL)";
d161 1
a161 1
rt_tor_prep( stp, ip, rtip, tol )
a164 1
CONST struct rt_tol	*tol;
d326 1
a326 1
rt_tor_shot( stp, rp, ap, seghead, tol )
a330 1
CONST struct rt_tol	*tol;
d515 1
a515 1
rt_tor_vshot( stp, rp, segp, n, resp, tol )
d520 1
a520 2
struct resource         *resp; /* pointer to a list of free segs */
CONST struct rt_tol	*tol;
@


9.28
log
@Changed rt_tor_internal so that H is unit length.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.27 91/06/12 20:57:48 mike Exp $ (BRL)";
d1364 1
d1366 1
a1366 1
	VCROSS( cross2, cross1, norm );
@


9.27
log
@nmg.h must come before raytrace.h
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.26 91/06/01 21:41:29 mike Exp $ (BRL)";
d191 1
a191 1
	f = VDOT( tip->b, tip->h )/(tip->r_b*tip->r_h);
d197 1
a197 1
	f = VDOT( tip->a, tip->h )/(tip->r_a*tip->r_h);
d222 1
a222 1
	VSCALE( tor->tor_N, tip->h, 1.0/tip->r_h );
d1007 1
a1007 1
			VCOMB2( edge, cos_alpha, G, sin_alpha, tip->h );
d1129 1
a1129 1
			VCOMB2( edge, cos_alpha, G, sin_alpha, tip->h );
d1289 3
d1364 1
a1364 1
	vec_ortho( cross1, norm );
d1414 1
a1414 1
	sprintf(buf, "\tV (%g, %g, %g), r1=|A|=%g, r2=|H|=%g\n",
d1422 3
a1424 3
		tip->h[X] * mm2local / tip->r_h,
		tip->h[Y] * mm2local / tip->r_h,
		tip->h[Z] * mm2local / tip->r_h );
a1452 6
	rt_vls_strcat( str, buf );

	sprintf(buf, "\tH = (%g, %g, %g)\n",
		tip->h[X] * mm2local,
		tip->h[Y] * mm2local,
		tip->h[Z] * mm2local );
@


9.26
log
@Improved description message
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.25 91/05/18 03:01:41 mike Exp $ (BRL)";
d31 1
a32 1
#include "nmg.h"
@


9.25
log
@Converted to new tolerance interface
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.24 91/04/01 19:59:43 mike Exp $ (BRL)";
d1411 1
a1411 1
	sprintf(buf, "\tV (%g, %g, %g), |A|=r1=%g, |H|=r2=%g\n",
d1418 1
a1418 1
	sprintf(buf, "\t|H|=(%g, %g, %g)\n",
d1425 12
@


9.24
log
@Edges of loops now travel in a counter-clockwise (CCW) direction
around the face normal.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.23 91/03/13 16:43:45 mike Exp $ (BRL)";
d161 1
a161 1
rt_tor_prep( stp, ip, rtip )
d165 1
d327 1
a327 1
rt_tor_shot( stp, rp, ap, seghead )
d332 1
d517 1
a517 1
rt_tor_vshot( stp, rp, segp, n, resp)
d523 1
d919 1
a919 1
rt_tor_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
d922 2
a923 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
d939 1
d945 2
a946 2
	if( rel_tol <= 0.0 || rel_tol >= 1.0 )  {
		rel_tol = 0.0;		/* none */
d951 1
a951 1
		rel_tol *= 2*(tip->r_a+tip->r_h);
d954 1
a954 1
	if( abs_tol <= 0.0 )  {
d956 1
a956 1
		if( rel_tol <= 0.0 )  {
d962 2
a963 2
			nlen = rt_num_circular_segments( rel_tol, tip->r_a );
			nw = rt_num_circular_segments( rel_tol, tip->r_h );
d967 4
a970 4
		if( rel_tol > 0.0 && rel_tol < abs_tol )
			abs_tol = rel_tol;
		nlen = rt_num_circular_segments( abs_tol, tip->r_a );
		nw = rt_num_circular_segments( abs_tol, tip->r_h );
d980 1
a980 1
	if( norm_tol > 0.0 )  {
d982 1
a982 1
		nseg = (rt_pi / norm_tol) + 0.99;
d1037 1
a1037 1
rt_tor_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d1041 2
a1042 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
d1064 1
d1070 2
a1071 2
	if( rel_tol <= 0.0 || rel_tol >= 1.0 )  {
		rel_tol = 0.0;		/* none */
d1076 1
a1076 1
		rel_tol *= 2*(tip->r_a+tip->r_h);
d1079 1
a1079 1
	if( abs_tol <= 0.0 )  {
d1081 1
a1081 1
		if( rel_tol <= 0.0 )  {
d1087 2
a1088 2
			nlen = rt_num_circular_segments( rel_tol, tip->r_a );
			nw = rt_num_circular_segments( rel_tol, tip->r_h );
d1092 4
a1095 4
		if( rel_tol > 0.0 && rel_tol < abs_tol )
			abs_tol = rel_tol;
		nlen = rt_num_circular_segments( abs_tol, tip->r_a );
		nw = rt_num_circular_segments( abs_tol, tip->r_h );
d1105 1
a1105 1
	if( norm_tol > 0.0 )  {
d1107 1
a1107 1
		nseg = (rt_pi / norm_tol) + 0.99;
d1168 1
a1168 1
		if( nmg_fu_planeeqn( faces[i] ) < 0 )
@


9.23
log
@Changed to use new calling sequence to rt_pr_roots
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.22 91/02/27 21:16:30 mike Exp $ (BRL)";
d1145 1
a1145 1
			vertp[1] = &verts[ PT(w+1,len+0) ];
d1147 1
a1147 1
			vertp[3] = &verts[ PT(w+0,len+1) ];
d1165 2
a1166 1
		rt_mk_nmg_planeeqn( faces[i] );
@


9.22
log
@lint
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.21 91/02/07 20:32:26 mike Exp $ (BRL)";
d421 1
a421 1
			rt_pr_roots( i, val );
d448 1
a448 1
		rt_pr_roots( 4, val );
d644 1
a644 1
				rt_pr_roots( num_roots, val );
d684 1
a684 1
			rt_pr_roots( 4, val );
@


9.21
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.20 91/01/28 23:53:23 mike Exp $ (BRL)";
d1420 1
a1420 1
	if( !verbose )  return;
@


9.20
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.19 91/01/26 03:15:02 mike Exp $ (BRL)";
d1132 1
a1132 1
	s = NMG_LIST_FIRST(shell, &(*r)->s_hd);
@


9.19
log
@Eliminated mat parameter on ft_plot and ft_tess
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.18 91/01/25 21:19:21 mike Exp $ (BRL)";
d917 1
a917 1
struct vlhead		*vhead;
d1012 1
a1012 1
		ADD_VL( vhead, PTA(w,len), 0 );
d1014 1
a1014 1
			ADD_VL( vhead, PTA(w,len), 1 );
d1020 1
a1020 1
		ADD_VL( vhead, PTA(w,len), 0 );
d1022 1
a1022 1
			ADD_VL( vhead, PTA(w,len), 1 );
@


9.18
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.17 91/01/25 20:36:14 mike Exp $ (BRL)";
d916 6
a921 7
rt_tor_plot( vhead, mat, ip, abs_tol, rel_tol, norm_tol )
struct vlhead	*vhead;
mat_t		mat;
struct rt_db_internal *ip;
double		abs_tol;
double		rel_tol;
double		norm_tol;
d1034 1
a1034 1
rt_tor_tess( r, m, ip, mat, abs_tol, rel_tol, norm_tol )
d1038 3
a1040 4
register mat_t		mat;
double		abs_tol;
double		rel_tol;
double		norm_tol;
@


9.17
log
@Added rt_ prefix to _internal structure
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.16 91/01/15 23:42:53 mike Exp $ (BRL)";
a159 1
#if NEW_IF
a165 10
#else
int
rt_tor_prep( stp, rec, rtip )
struct soltab		*stp;
union record		*rec;
struct rt_i		*rtip;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a171 12
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rec;
	ep->ext_nbytes = stp->st_dp->d_len*sizeof(union record);
	ip = &intern;
	if( rt_tor_import( ip, ep, stp->st_pathmat ) < 0 )
		return(-1);		/* BAD */
	RT_CK_DB_INTERNAL( ip );
#endif
a914 1
#if NEW_IF
a923 14
#else
int
rt_tor_plot( rp, mat, vhead, dp, abs_tol, rel_tol, norm_tol )
union record		*rp;
register mat_t		mat;
struct vlhead		*vhead;
struct directory	 *dp;
double			abs_tol;
double			rel_tol;
double			norm_tol;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a938 13
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	if( rt_tor_import( &intern, ep, mat ) < 0 )  {
		rt_log("rt_tor_plot(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
a1033 1
#if NEW_IF
a1043 15
#else
int
rt_tor_tess( r, m, rp, mat, dp, abs_tol, rel_tol, norm_tol )
struct nmgregion	**r;
struct model		*m;
register union record	*rp;
register mat_t		mat;
struct directory	*dp;
double			abs_tol;
double			rel_tol;
double			norm_tol;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a1064 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_tor_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_tor_tess(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
@


9.16
log
@Moved tor_internal structure to rtgeom.h
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.15 91/01/15 20:15:09 mike Exp $ (BRL)";
d181 1
a181 1
	struct tor_internal	*tip;
d195 1
a195 1
	tip = (struct tor_internal *)ip->idb_ptr;
d967 1
a967 1
	struct tor_internal	*tip;
d991 1
a991 1
	tip = (struct tor_internal *)ip->idb_ptr;
d1116 1
a1116 1
	struct tor_internal	*tip;
d1147 1
a1147 1
	tip = (struct tor_internal *)ip->idb_ptr;
d1331 1
a1331 1
	struct tor_internal	*tip;
d1347 2
a1348 2
	ip->idb_ptr = rt_malloc(sizeof(struct tor_internal), "tor_internal");
	tip = (struct tor_internal *)ip->idb_ptr;
d1390 1
a1390 1
	struct tor_internal	*tip;
d1400 1
a1400 1
	tip = (struct tor_internal *)ip->idb_ptr;
d1481 2
a1482 2
	register struct tor_internal	*tip =
		(struct tor_internal *)ip->idb_ptr;
d1537 1
a1537 1
	register struct tor_internal	*tip;
d1540 1
a1540 1
	tip = (struct tor_internal *)ip->idb_ptr;
@


9.15
log
@Changed to new import/export interface.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.14 90/10/06 02:05:26 mike Exp $ (BRL)";
d33 1
a143 13

struct tor_internal {
	long	magic;
	point_t	v;
	vect_t	h;		/* r_h length */
	vect_t	a;		/* r_a length */
	vect_t	b;		/* r_b length */
	fastf_t	r_h;		/* radius in H direction */
	fastf_t	r_a;		/* radius in A direction */
	fastf_t	r_b;		/* radius in B direction (typ == r_a) */
};
#define RT_TOR_INTERNAL_MAGIC	0x9bffed887
#define RT_TOR_CK_MAGIC(_p)	RT_CKMAG(_p,RT_TOR_INTERNAL_MAGIC,"tor_internal")
@


9.14
log
@Converted seg structures to use doubly linked lists.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.13 90/06/13 06:51:19 mike Exp $ (BRL)";
d145 1
d147 6
a152 3
	vect_t	h;
	vect_t	a;
	vect_t	b;
d154 2
a157 40
 *			R T _ T O R _ I M P O R T
 *
 *  Import a torus from the database format to the internal format.
 *  Apply modeling transformations at the same time.
 */
int
rt_tor_import( tip, rp, mat )
struct tor_internal	*tip;
union record		*rp;
register mat_t		mat;
{
	LOCAL fastf_t	vec[3*4];
	vect_t		axb;

	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		rt_log("rt_tor_import: defective record\n");
		return(-1);
	}

	/* Convert from database to internal format */
	rt_fastf_float( vec, rp->s.s_values, 4 );

	/* Apply modeling transformations */
	MAT4X3PNT( tip->v, mat, &vec[0*3] );
	MAT4X3VEC( tip->h, mat, &vec[1*3] );
	MAT4X3VEC( tip->a, mat, &vec[2*3] );
	MAT4X3VEC( tip->b, mat, &vec[3*3] );

	/* If H does not point in the direction of A cross B, reverse H. */
	/* Somehow, database records have been written with this problem. */
	VCROSS( axb, tip->a, tip->b );
	if( VDOT( axb, tip->h ) < 0 )  {
		VREVERSE( tip->h, tip->h );
	}

	return(0);		/* OK */
}

/*
d172 1
d174 7
d186 3
a189 1
	LOCAL fastf_t	magsq_a, magsq_b, magsq_h;
d193 1
a193 3
	LOCAL fastf_t	r1, r2;	/* primary and secondary radius */
	LOCAL fastf_t	mag_b;
	struct tor_internal	ti;
d195 9
a203 1
	if( rt_tor_import( &ti, rec, stp->st_pathmat ) < 0 )
d205 4
a209 16
	magsq_a = MAGSQ( ti.a );
	magsq_b = MAGSQ( ti.b );
	magsq_h = MAGSQ( ti.h );
	r1 = sqrt(magsq_a);
	r2 = sqrt(magsq_h);
	mag_b = sqrt(magsq_b);

	/* Validate that |A| > 0, |B| > 0, |H| > 0 */
	if( NEAR_ZERO(magsq_a, 0.0001) ||
	    NEAR_ZERO(magsq_b, 0.0001) ||
	    NEAR_ZERO(magsq_h, 0.0001) ) {
		rt_log("tor(%s):  zero length A, B, or H vector\n",
			stp->st_name );
		return(1);		/* BAD */
	}

d211 1
a211 1
	if( rt_fdiff( r1, mag_b ) != 0 ) {
d213 1
a213 1
			stp->st_name, r1, mag_b );
d218 1
a218 1
	f = VDOT( ti.a, ti.b )/(r1*mag_b);
d225 1
a225 1
	f = VDOT( ti.b, ti.h )/(mag_b*r2);
d231 1
a231 1
	f = VDOT( ti.a, ti.h )/(r1*r2);
d239 2
a240 2
	if( 0.0 >= r2  || r2 > r1 )  {
		rt_log("r1 = %f, r2 = %f\n", r1, r2 );
d249 2
a250 2
	tor->tor_r1 = r1;
	tor->tor_r2 = r2;
d252 2
a253 2
	VMOVE( tor->tor_V, ti.v );
	tor->tor_alpha = r2/tor->tor_r1;
d256 1
a256 2
	VUNITIZE( ti.h );
	VMOVE( tor->tor_N, ti.h );
d259 3
a261 5
	VMOVE( &R[0], ti.a );
	VUNITIZE( &R[0] );
	VMOVE( &R[4], ti.b );
	VUNITIZE( &R[4] );
	VMOVE( &R[8], ti.h );
d269 1
a269 1
	stp->st_aradius = stp->st_bradius = tor->tor_r1 + r2;
d950 1
d952 10
d971 3
d979 1
a979 1
	struct tor_internal	ti;
a987 2
	fastf_t		r1;		/* |A| */
	fastf_t		r2;		/* |H| */
d989 9
a997 1
	if( rt_tor_import( &ti, rp, mat ) < 0 )
d999 6
a1005 3
	r1 = MAGNITUDE(ti.a);
	r2 = MAGNITUDE(ti.h);

d1012 1
a1012 1
		rel_tol *= 2*(r1+r2);
d1023 2
a1024 2
			nlen = rt_num_circular_segments( rel_tol, r1 );
			nw = rt_num_circular_segments( rel_tol, r2 );
d1030 2
a1031 2
		nlen = rt_num_circular_segments( abs_tol, r1 );
		nw = rt_num_circular_segments( abs_tol, r2 );
d1049 1
a1049 1
	dist_to_rim = r2/r1;
d1061 1
a1061 1
		VCOMB2( radius, cos_beta, ti.a, sin_beta, ti.b );
d1068 2
a1069 2
			VCOMB2( edge, cos_alpha, G, sin_alpha, ti.h );
			VADD3( PTA(w,len), ti.v, edge, radius );
d1097 1
d1099 11
d1120 3
d1128 1
a1128 1
	struct tor_internal	ti;
a1142 2
	fastf_t		r1;		/* |A| */
	fastf_t		r2;		/* |H| */
d1144 10
a1153 1
	if( rt_tor_import( &ti, rp, mat ) < 0 )
d1155 6
a1161 3
	r1 = MAGNITUDE(ti.a);
	r2 = MAGNITUDE(ti.h);

d1168 1
a1168 1
		rel_tol *= 2*(r1+r2);
d1179 2
a1180 2
			nlen = rt_num_circular_segments( rel_tol, r1 );
			nw = rt_num_circular_segments( rel_tol, r2 );
d1186 2
a1187 2
		nlen = rt_num_circular_segments( abs_tol, r1 );
		nw = rt_num_circular_segments( abs_tol, r2 );
d1205 1
a1205 1
	dist_to_rim = r2/r1;
d1214 1
a1214 1
		VCOMB2( radius, cos_beta, ti.a, sin_beta, ti.b );
d1221 2
a1222 2
			VCOMB2( edge, cos_alpha, G, sin_alpha, ti.h );
			VADD3( PTA(w,len), ti.v, edge, radius );
d1329 228
@


9.13
log
@Added rounding up of number of segments.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.12 90/05/18 07:25:47 butler Exp $ (BRL)";
d391 1
a391 1
 *  	segp	HIT
d393 2
a394 2
struct seg *
rt_tor_shot( stp, rp, ap )
d398 1
d491 1
a491 1
		return(SEG_NULL);		/* MISS */
d512 1
a512 1
		return(SEG_NULL);		/* No hit */
d517 1
a517 1
		return(SEG_NULL);		/* No hit */
d552 1
a552 1
	GET_SEG(segp, ap->a_resource);
d559 1
d562 1
a562 1
		return(segp);			/* HIT */
d566 1
a566 7
	{
		register struct seg *seg2p;		/* XXX */
		/* Attach last hit (above) to segment chain */
		GET_SEG(seg2p, ap->a_resource);
		seg2p->seg_next = segp;
		segp = seg2p;
	}
d572 2
a573 1
	return(segp);			/* HIT */
a764 1
		segp[i].seg_next = SEG_NULL;
d818 1
d821 1
d829 1
@


9.12
log
@Halfway converted to new double-linked-list structures ;-)
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /m/cad/librt/RCS/g_torus.c,v 9.11 90/05/04 08:13:23 mike Exp $ (BRL)";
d1309 1
a1309 1
	n = rt_pi / half_theta;
@


9.11
log
@Expanded various code inline, for a modest performance improvement.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: g_torus.c,v 9.10 90/05/04 06:22:57 mike Locked $ (BRL)";
d1213 2
a1214 1
	s = m->r_p->s_p;
@


9.10
log
@Fix direction of H vector.  Some database records have it pointing
the wrong way.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: g_torus.c,v 9.9 90/05/02 01:11:06 mike Locked $ (BRL)";
a164 1
	fastf_t		dot;
d184 1
a184 7
	dot = VDOT( axb, tip->h );
	rt_log("tor: dot=%g, a=(%g,%g,%g),  b=(%g,%g,%g),  h=(%g,%g,%g)\n",
		dot,
		tip->a[0], tip->a[1], tip->a[2],
		tip->b[0], tip->b[1], tip->b[2],
		tip->h[0], tip->h[1], tip->h[2] );
	if( dot < 0 )  {
d463 8
a470 3
	(void) polyMul( &A, &A, &Asqr );
	(void) polyScal( &X2_Y2, 4.0 );
	(void) polySub( &Asqr, &X2_Y2, &C );
d472 10
d509 2
a510 1
	if( i == 0 )
d512 2
a513 1
	if( i != 2 && i != 4 )  {
d517 30
a547 3

	/* Sort most distant to least distant. */
	rt_pt_sort( k, i );
@


9.9
log
@Moved VJOIN4 to vmath.h
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: g_torus.c,v 9.8 90/05/01 02:39:00 mike Locked $ (BRL)";
d164 2
d182 13
d1183 1
d1188 1
a1188 1
			vertp[1] = &verts[ PT(w+0,len+1) ];
d1190 1
a1190 1
			vertp[3] = &verts[ PT(w+1,len+0) ];
@


9.8
log
@Added surface-normal tolerance to plot and tess routines.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: g_torus.c,v 9.7 90/04/26 02:11:54 mike Locked $ (BRL)";
a1010 5

#define VJOIN4(a,b,c,d,e,f,g,h,i,j)	\
	(a)[X] = (b)[X] + (c)*(d)[X] + (e)*(f)[X] + (g)*(h)[X] + (i)*(j)[X];\
	(a)[Y] = (b)[Y] + (c)*(d)[Y] + (e)*(f)[Y] + (g)*(h)[Y] + (i)*(j)[Y];\
	(a)[Z] = (b)[Z] + (c)*(d)[Z] + (e)*(f)[Z] + (g)*(h)[Z] + (i)*(j)[Z]
@


9.7
log
@Added tolerance support on ft_plot as well.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: g_torus.c,v 9.6 90/04/26 01:43:13 mike Locked $ (BRL)";
d933 1
a933 1
rt_tor_plot( rp, mat, vhead, dp, abs_tol, rel_tol )
d940 1
d993 14
d1062 1
a1062 1
rt_tor_tess( r, m, rp, mat, dp, abs_tol, rel_tol )
d1070 1
d1127 14
@


9.6
log
@Added tolerance-based tessellation
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: g_torus.c,v 9.5 90/04/24 05:43:49 mike Locked $ (BRL)";
d933 7
a939 5
rt_tor_plot( rp, mat, vhead, dp )
union record	*rp;
register mat_t	mat;
struct vlhead	*vhead;
struct directory *dp;
d955 2
d961 2
a962 1
	dist_to_rim = MAGNITUDE(ti.h)/MAGNITUDE(ti.a);
d964 30
a1084 1
rt_log("tor abs=%g, rel=%g\n", abs_tol, rel_tol );
a1111 2
rt_log("tor abs=%g, abs_rel=%g\n", abs_tol, rel_tol );
rt_log("tor nlen=%d, nw=%d\n", nlen, nw);
@


9.5
log
@New plotting routine
Added tessellation
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: g_torus.c,v 9.4 90/04/24 04:05:57 mike Locked $ (BRL)";
d1012 1
a1012 1
rt_tor_tess( r, m, rp, mat, dp )
d1018 2
d1028 1
a1028 1
	int		nw = 16;
d1030 1
a1030 1
	int		nlen = 32;
d1041 2
d1047 34
d1082 1
a1082 1
	dist_to_rim = MAGNITUDE(ti.h)/MAGNITUDE(ti.a);
d1110 2
a1111 2
	/* Construct the faces and vertices */
	/* Increasing indices go ccw */
d1118 5
a1122 1
			faces[nfaces++] = nmg_cmface( s, vertp, 4 );
d1145 59
@


9.4
log
@New version of tor_plot
@
text
@d2 1
a2 1
 *			T O R U S . C
d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: g_torus.c,v 9.3 90/03/16 01:02:12 mike Locked $ (BRL)";
d32 1
d152 1
a152 1
 *			T O R _ I M P O R T
d158 1
a158 1
tor_import( tip, rp, mat )
d167 1
a167 1
		rt_log("tor_import: defective record\n");
d184 1
a184 1
 *  			T O R _ P R E P
d196 1
a196 1
 *  	stp->st_specific for use by tor_shot().
d199 1
a199 1
tor_prep( stp, rec, rtip )
d213 1
a213 1
	if( tor_import( &ti, rec, stp->st_pathmat ) < 0 )
d335 1
a335 1
 *			T O R _ P R I N T
d338 1
a338 1
tor_print( stp )
d354 1
a354 1
 *  			T O R _ S H O T
d357 1
a357 1
 *  been precomputed by tor_prep().  If an intersection occurs,
d386 1
a386 1
tor_shot( stp, rp, ap )
d489 1
a489 1
		rt_log("tor_shot: reduced 4 to %d roots\n",i);
d503 1
a503 1
	/* Set aside vector for tor_norm() later */
d529 1
a529 1
 *			T O R _ V S H O T
d534 1
a534 1
tor_vshot( stp, rp, segp, n, resp)
d702 1
a702 1
			rt_log("tor_shot: reduced 4 to %d roots\n",i);
d724 1
a724 1
			/* Set aside vector for tor_norm() later */
d735 1
a735 1
			/* Set aside vector for tor_norm() later */
d766 1
a766 1
		/* Set aside vector for tor_norm() later */
d788 1
a788 1
 *			T O R _ N O R M
d815 1
a815 1
tor_norm( hitp, stp, rp)
d839 1
a839 1
 *			T O R _ C U R V E
d844 1
a844 1
tor_curve( cvp, hitp, stp )
d889 1
a889 1
 *			T O R _ U V
d892 1
a892 1
tor_uv( ap, stp, hitp, uvp )
d905 1
a905 1
 *			T O R _ F R E E
d908 1
a908 1
tor_free( stp )
d918 1
a918 1
tor_class()
d924 1
a924 1
 *			T O R _ P L O T
d933 1
a933 1
tor_plot( rp, matp, vhead, dp )
d935 1
a935 1
register matp_t matp;
d954 1
a954 1
	if( tor_import( &ti, rp, matp ) < 0 )
d960 1
a960 1
		"tor_plot pts[]" );
d967 2
a968 1
#define PTA(ww,ll)	(&pts[ (((ww)*nlen) + (ll)) * 3])
d1004 1
a1004 1
	rt_free( (char *)pts, "tor_plot pts[]" );
d1009 1
a1009 1
 *			T O R _ T E S S
d1012 1
a1012 1
tor_tess( r, m, rp, mat, dp )
d1019 20
d1040 63
@


9.3
log
@Added tor_import() routine, upgraded tor_plot().
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: g_torus.c,v 9.2 90/03/14 15:06:08 mike Exp $ (BRL)";
a929 7
 * The inner and outer edge need to be constructed as well.
 *
 * The following ellipses have to be constructed:
 *	C1	top ellipse
 *	C2	bottom ellipse
 *	C3	inner ellipse
 *	C4	outer ellipse
d938 5
a942 10
	register int		i;
	fastf_t		C1[16*3];
	fastf_t 	C2[16*3];
	fastf_t		C3[16*3];
	fastf_t		C4[16*3];
	point_t		top_center;
	point_t		bottom_center;
	vect_t		newA, newB;
	fastf_t		magH, magA, magB;
	fastf_t		f;
d944 8
d956 1
a956 2
	VADD2(top_center,ti.v,ti.h);		/* center point of TOP */
	ell_16pts(C1,top_center,ti.a,ti.b);	/* top */
d958 2
a959 6
	VSUB2(bottom_center,ti.v,ti.h);
	ell_16pts(C4,bottom_center,ti.a,ti.b);	/* bottom */
 
	magH = MAGNITUDE(ti.h);
	magA = MAGNITUDE(ti.a);
	magB = MAGNITUDE(ti.b);
d961 4
a964 5
	f = (magA - magH) / magA;
	VSCALE( newA, ti.a, f );
	f = (magB - magH) / magB;
	VSCALE( newB, ti.b, f );
	ell_16pts(C2, ti.v, newA, newB);	/* inner */
d966 1
a966 10
	f = (magA + magH) / magA;
	VSCALE( newA, ti.a, f );
	f = (magB + magH) / magB;
	VSCALE( newB, ti.b, f );
	ell_16pts(C3, ti.v, newA, newB);	/* outer */
 
	ADD_VL( vhead, &C1[15*ELEMENTS_PER_VECT], 0 );
	for( i=0; i<16; i++ )  {
		ADD_VL( vhead, &C1[i*ELEMENTS_PER_VECT], 1 );
	}
d968 15
a982 3
	ADD_VL( vhead, &C2[15*ELEMENTS_PER_VECT], 0 );
	for( i=0; i<16; i++ )  {
		ADD_VL( vhead, &C2[i*ELEMENTS_PER_VECT], 1 );
d985 7
a991 3
	ADD_VL( vhead, &C3[15*ELEMENTS_PER_VECT], 0 );
	for( i=0; i<16; i++ )  {
		ADD_VL( vhead, &C3[i*ELEMENTS_PER_VECT], 1 );
d993 7
a999 4

	ADD_VL( vhead, &C4[15*ELEMENTS_PER_VECT], 0 );
	for( i=0; i<16; i++ )  {
		ADD_VL( vhead, &C4[i*ELEMENTS_PER_VECT], 1 );
d1002 1
a1002 23
	ADD_VL( vhead, &C1[0*3], 0);
	ADD_VL( vhead, &C2[0*3], 1);
	ADD_VL( vhead, &C4[0*3], 1);
	ADD_VL( vhead, &C3[0*3], 1);
	ADD_VL( vhead, &C1[0*3], 1);
 
	ADD_VL( vhead, &C1[4*3], 0);
	ADD_VL( vhead, &C2[4*3], 1);
	ADD_VL( vhead, &C4[4*3], 1);
	ADD_VL( vhead, &C3[4*3], 1);
	ADD_VL( vhead, &C1[4*3], 1);

	ADD_VL( vhead, &C1[8*3], 0);
	ADD_VL( vhead, &C2[8*3], 1);
	ADD_VL( vhead, &C4[8*3], 1);
	ADD_VL( vhead, &C3[8*3], 1);
	ADD_VL( vhead, &C1[8*3], 1);
 
	ADD_VL( vhead, &C1[12*3], 0);
	ADD_VL( vhead, &C2[12*3], 1);
	ADD_VL( vhead, &C4[12*3], 1);
	ADD_VL( vhead, &C3[12*3], 1);
	ADD_VL( vhead, &C1[12*3], 1);
d1007 1
d1010 6
a1015 1
tor_tess()
d1017 1
@


9.2
log
@Changed type of st_specific to genptr_t
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: g_torus.c,v 9.1 89/05/19 05:56:37 mike Locked $ (BRL)";
d143 7
d151 32
a205 1
	LOCAL vect_t	A, B, Hv;
d210 1
a210 1
	fastf_t		vec[3*4];
d212 2
a213 1
	rt_fastf_float( vec, rec->s.s_values, 4 );
d215 3
a217 15
#define TOR_V	&vec[0*ELEMENTS_PER_VECT]
#define TOR_H	&vec[1*ELEMENTS_PER_VECT]
#define TOR_A	&vec[2*ELEMENTS_PER_VECT]
#define TOR_B	&vec[3*ELEMENTS_PER_VECT]

	/*
	 * Apply 3x3 rotation mat only to A,B,H
	 */
	MAT4X3VEC( A, stp->st_pathmat, TOR_A );
	MAT4X3VEC( B, stp->st_pathmat, TOR_B );
	MAT4X3VEC( Hv, stp->st_pathmat, TOR_H );

	magsq_a = MAGSQ( A );
	magsq_b = MAGSQ( B );
	magsq_h = MAGSQ( Hv );
d239 1
a239 1
	f = VDOT( A, B )/(r1*mag_b);
d246 1
a246 1
	f = VDOT( B, Hv )/(mag_b*r2);
d252 1
a252 1
	f = VDOT( A, Hv )/(r1*r2);
d273 1
a273 1
	MAT4X3PNT( tor->tor_V, stp->st_pathmat, TOR_V );
d277 2
a278 2
	VUNITIZE( Hv );
	VMOVE( tor->tor_N, Hv );
d281 1
a281 1
	VMOVE( &R[0], A );
d283 1
a283 1
	VMOVE( &R[4], B );
d285 1
a285 1
	VMOVE( &R[8], Hv );
d333 3
d887 3
a921 10
/* Names for TORUS fields */
#define F1 	&points[0]
#define F2	&points[3]
#define F3	&points[6]
#define F4	&points[9]
#define F5	&points[12]
#define F6	&points[15]
#define F7	&points[18]
#define F8	&points[21]

d926 3
a928 5
 *	F1	V from origin to center
 *	F2	Radius Vector, Normal to plane of torus
 *	F3,F4	perpindicular, to CENTER of torus (for top, bottom)
 *	F5,F6	perpindicular, for inner edge
 *	F7,F8	perpindicular, for outer edge
d930 2
d938 1
a938 1
void
a945 2
	register fastf_t	*op;
	register dbfloat_t	*ip;
d950 6
a955 2
	static vect_t	tempv;		/* Torus vector addition area */
	fastf_t		points[3*8];
d957 2
a958 5
	/*
	 * Rotate, translate, and scale the V point.
	 * All other vectors are merely scaled and translated.
	 */
	MAT4X3PNT( &points[0], matp, &rp[0].s.s_values[0] );
d960 2
a961 7
	ip = &rp[0].s.s_values[1*3];
	op = &points[1*3];
	for(i=1; i<8; i++)  {
		MAT4X3VEC( op, matp, ip );
		op += 3;
		ip += 3;
	}
d963 6
a968 2
	VADD2(tempv,F1,F2);	/* center point of TOP */
	ell_16pts(C1,tempv,F3,F4);	/* top */
d970 11
a980 2
	VSUB2(tempv,F1,F2);
	ell_16pts(C4,tempv,F3,F4);	/* bottom */
a981 3
	ell_16pts(C2,F1,F5,F6);	/* inner */
	ell_16pts(C3,F1,F7,F8);	/* outer */
 
d1025 8
@


9.1
log
@Release_3.5
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: g_torus.c,v 8.6 89/04/17 17:19:59 mike Exp $ (BRL)";
d241 1
a241 1
	stp->st_specific = (int *)tor;
@


8.6
log
@Calling sequence to xxx_prep() shortened from 6 to 3 args.
Database conversion moved into prep routines.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: g_torus.c,v 8.5 89/04/14 02:31:49 mike Locked $ (BRL)";
@


8.5
log
@This version seems to work on scalar computers
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 8.4 89/04/11 12:20:19 mike Locked $ (BRL)";
d159 1
a159 2
tor_prep( vec, stp, mat, rtip )
register fastf_t	*vec;
d161 1
a161 1
matp_t			mat;
d172 1
d174 2
d184 3
a186 3
	MAT4X3VEC( A, mat, TOR_A );
	MAT4X3VEC( B, mat, TOR_B );
	MAT4X3VEC( Hv, mat, TOR_H );
d246 1
a246 1
	MAT4X3PNT( tor->tor_V, mat, TOR_V );
@


8.4
log
@rt_malloc instead of malloc, removed some unused variables
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 8.3 89/04/08 05:59:38 phil Locked $ (BRL)";
d464 1
a464 4
	/* Now, t[0] > t[npts-1].  See if this is an easy out. */
	if( k[0] <= 0.0 )
		return(SEG_NULL);		/* No hit out front. */

d524 2
a525 1
	val = (complex (*)[MAXP])rt_malloc(n * sizeof(complex (*)[MAXP]), "tor complex");
d535 1
a535 3
#if !CRAY	/* currently prevents vectorization on cray */
	 	if (stp[i] == 0) continue; /* stp[i] == 0 signals skip ray */
#endif
d615 3
a617 7
		C[i].cf[2] = Asqr.cf[2];
		C[i].cf[3] = Asqr.cf[3];
		C[i].cf[4] = Asqr.cf[4];
		C[i].cf[2] -= X2_Y2.cf[0];
		C[i].cf[3] -= X2_Y2.cf[1];
		C[i].cf[4] -= X2_Y2.cf[2];

d622 1
a622 1
		if (stp[i] != 0) continue; /* stp[i] == 0 signals skip ray */
d627 1
a627 1
		if ( (num_roots = polyRoots( &C[i], val[i] )) != 4 ){
d639 1
a639 1
		if (stp[i] == 0 || segp[i].seg_stp == 0) continue; /* Skip */
d676 1
a676 1
	/* Process each two segment hit */
d679 1
a679 2
		if (stp[i] == 0 || segp[i].seg_stp == 0) continue; /* Skip */

d682 2
a683 6
		if (C[i].cf[0] <= 0.0 && C[i].cf[1] <= 0.0) {
			SEG_MISS(segp[i]);		/* MISS */
		}
		else {
			segp[i].seg_next = SEG_NULL;
			segp[i].seg_stp = stp[i];
d685 3
d689 20
a708 25
			/* segp[r].seg_in.hit_normal holds dprime */
			/* segp[r].seg_out.hit_normal holds pprime */
			if (C[i].cf[1] < C[i].cf[0]) {
				segp[i].seg_in.hit_dist = C[i].cf[1]*tor->tor_r1;
				segp[i].seg_out.hit_dist = C[i].cf[0]*tor->tor_r1;
				/* Set aside vector for tor_norm() later */
				VJOIN1( segp[i].seg_in.hit_vpriv,
					segp[i].seg_out.hit_normal,
					C[i].cf[1], segp[i].seg_in.hit_normal );
				VJOIN1( segp[i].seg_out.hit_vpriv,
					segp[i].seg_out.hit_normal,
					C[i].cf[0], segp[i].seg_in.hit_normal );

			} else { /* C[i].cf[0] is entry point */
				segp[i].seg_in.hit_dist = C[i].cf[0]*tor->tor_r1;
				segp[i].seg_out.hit_dist = C[i].cf[1]*tor->tor_r1;
				/* Set aside vector for tor_norm() later */
				VJOIN1( segp[i].seg_in.hit_vpriv,
					segp[i].seg_out.hit_normal,
					C[i].cf[0], segp[i].seg_in.hit_normal );
				VJOIN1( segp[i].seg_out.hit_vpriv,
					segp[i].seg_out.hit_normal,
					C[i].cf[1], segp[i].seg_in.hit_normal );

			}
d714 1
a714 1
		if (stp[i] == 0 || segp[i].seg_stp == 0) continue; /* Skip */
d716 1
d719 2
d723 1
d725 4
a728 6
		/* Now, t[0] > t[npts-1].  See if this is an easy out. */
		if( C[i].cf[0] <= 0.0 ) {
			SEG_MISS(segp[C[i].dgr]);		/* MISS */
		} else {
			register int r;
			register struct seg *seg2p;		/* XXX */
d730 6
a735 1
			r = C[i].dgr; /* holds the ray/torus pair number */
d737 9
a745 27
			/* Attach second hit to segment chain */
			GET_SEG(seg2p, resp);
			segp[r].seg_next = seg2p;

			/* segp[r].seg_in.hit_normal holds dprime */
			VMOVE( dprime, segp[r].seg_in.hit_normal );

			/* segp[r].seg_out.hit_normal holds pprime */
			VMOVE( pprime, segp[r].seg_out.hit_normal );

			segp[r].seg_next = SEG_NULL;
			segp[r].seg_stp = stp[r];

			/* C[i].cf[1] is entry point */
			segp[r].seg_in.hit_dist = C[i].cf[1]*tor->tor_r1;
			segp[r].seg_out.hit_dist = C[i].cf[0]*tor->tor_r1;
			/* Set aside vector for tor_norm() later */
			VJOIN1(segp[r].seg_in.hit_vpriv, pprime, C[i].cf[1], dprime );
			VJOIN1(segp[r].seg_out.hit_vpriv, pprime, C[i].cf[0], dprime);

			/* C[i].cf[2] is entry point */
			seg2p->seg_stp = stp[r];
			seg2p->seg_in.hit_dist = C[i].cf[3]*tor->tor_r1;
			seg2p->seg_out.hit_dist = C[i].cf[2]*tor->tor_r1;
			VJOIN1( seg2p->seg_in.hit_vpriv, pprime, C[i].cf[3], dprime );
			VJOIN1(seg2p->seg_out.hit_vpriv, pprime, C[i].cf[2], dprime );
		}
d749 3
a751 3
	free(C);
	free(val);
	free(cor_proj);
@


8.3
log
@This Becker vectorized version has not been tested.
Owing to it's complexity, it may not work.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 8.2 88/12/06 00:02:50 mike Locked $ (BRL)";
a517 2
	LOCAL double	k[4];		/* The real roots */
	LOCAL int	j;
a523 1
	LOCAL poly      tmp;
d528 1
a528 1
	cor_proj = (fastf_t *)malloc(n * sizeof(fastf_t), "tor proj");
@


8.2
log
@Added _plot() routines, and db_*() interfaces.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: /cad/d/mike/cad/librt/RCS/torus.c,v 1.2 88/11/03 12:35:43 mike Exp $ (BRL)";
d495 286
@


8.1
log
@Release_3.0
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 7.3 88/07/15 19:45:14 phil Exp $ (BRL)";
d630 26
d657 5
a661 1
tor_plot()
d663 76
@


7.3
log
@New bounding plane code - exact for circular tori
Note that the old code can handle A != B, but for now
we can't handle that case anywhere else either.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 7.2 88/05/14 00:01:45 phil Locked $ (BRL)";
@


7.2
log
@lint fixes
added zero _uv() routines to some modules
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 7.1 87/11/02 23:34:54 mike Locked $ (BRL)";
d170 1
a170 1
	FAST fastf_t	f, tmp, a2, b2;
d267 6
a272 5
	 * Compute bounding RPP
	 *  We are fitting an RPP to a "hockey-puck" which surrounds
	 *  the torus.  This is an REC in the XY plane with the
	 *  end planes at Z = +/- r2.
	 *  These equations were derived via Lagrange multipliers.
a273 3
	a2 = (r1 + r2) * (r1 + r2);		/* r1 = mag_a */
	b2 = (mag_b + r2) * (mag_b + r2);

d276 5
a280 6
	MAT3X3VEC( w1, R, P );		/* map plane into local coord syst */
	f = fabs( w1[Z] * r2 );		/* Z part */
	tmp = a2 * w1[X] * w1[X] + b2 * w1[Y] * w1[Y];
	if( tmp > 1.0e-8 )
		f += tmp/sqrt(tmp);	/* XY part */
	stp->st_min[X] = tor->tor_V[X] - f;	/* V.P +/- f */
d285 5
a289 6
	MAT3X3VEC( w1, R, P );		/* map plane into local coord syst */
	f = fabs( w1[Z] * r2 );		/* Z part */
	tmp = a2 * w1[X] * w1[X] + b2 * w1[Y] * w1[Y];
	if( tmp > 1.0e-8 )
		f += tmp/sqrt(tmp);	/* XY part */
	stp->st_min[Y] = tor->tor_V[Y] - f;	/* V.P +/- f */
d294 5
a298 6
	MAT3X3VEC( w1, R, P );		/* map plane into local coord syst */
	f = fabs( w1[Z] * r2 );		/* Z part */
	tmp = a2 * w1[X] * w1[X] + b2 * w1[Y] * w1[Y];
	if( tmp > 1.0e-8 )
		f += tmp/sqrt(tmp);	/* XY part */
	stp->st_min[Z] = tor->tor_V[Z] - f;	/* V.P +/- f */
@


7.1
log
@Release 2.3
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 6.1 87/07/11 07:57:09 mike Rel $ (BRL)";
d158 1
d309 1
d529 1
d558 1
d603 6
a608 1
tor_uv()
d610 4
d619 1
d629 1
d632 1
d635 1
@


6.1
log
@Release 2.0
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 5.1 87/06/24 22:13:10 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 4.9 87/05/30 06:10:27 phil Exp $ (BRL)";
@


4.9
log
@vmath.h name change
trivial normal simplification
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 4.8 87/04/28 00:28:12 phil Exp $ (BRL)";
@


4.8
log
@changed curve convention
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 4.7 87/04/02 00:51:27 phil Locked $ (BRL)";
d277 1
a277 1
	MAT3XVEC( w1, R, P );		/* map plane into local coord syst */
d287 1
a287 1
	MAT3XVEC( w1, R, P );		/* map plane into local coord syst */
d297 1
a297 1
	MAT3XVEC( w1, R, P );		/* map plane into local coord syst */
d523 3
d538 4
a541 4
	w = (hitp->hit_vpriv[X]*hitp->hit_vpriv[X] +
	     hitp->hit_vpriv[Y]*hitp->hit_vpriv[Y] +
	     hitp->hit_vpriv[Z]*hitp->hit_vpriv[Z] +
	     1.0 - tor->tor_alpha*tor->tor_alpha) * 4.0;
d543 2
a544 2
		( w - 8.0 ) * hitp->hit_vpriv[X],
		( w - 8.0 ) * hitp->hit_vpriv[Y],
d547 1
a547 1
	MAT3XVEC( hitp->hit_normal, tor->tor_invR, work );
@


4.7
log
@generalized RPP code for elliptical A != B
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 4.6 87/04/01 23:59:35 phil Locked $ (BRL)";
d552 1
a552 1
tor_curve( cvp, hitp, stp, rp )
a555 1
struct xray *rp;
d585 2
a586 2
	cvp->crv_c1 = (d - tor->tor_r1) / (d * tor->tor_r2);
	cvp->crv_c2 = 1.0 / tor->tor_r2;
a593 6

	if( VDOT( hitp->hit_normal, rp->r_dir ) > 0 )  {
		/* ray strikes surface from inside; make curv negative */
		cvp->crv_c1 = - cvp->crv_c1;
		cvp->crv_c2 = - cvp->crv_c2;
	}
@


4.6
log
@new "hockey-puck" RPP code
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 4.5 87/03/23 23:41:01 phil Locked $ (BRL)";
d169 1
a169 1
	FAST fastf_t	f, tmp;
d268 3
a270 5
	 *  the torus.  This is a unit radius RCC in the XY plane
	 *  with the end planes at +/- alpha.
	 *  These formulas were derived via Lagrange multipliers.
	 *  If the torus is not circular, the scaling will have
	 *  to be changed.
d272 2
d278 2
a279 2
	f = fabs( w1[Z]*tor->tor_alpha ) * tor->tor_r1;		/* Z part */
	tmp = w1[X] * w1[X] + w1[Y] * w1[Y];
d281 1
a281 1
		f += tmp/sqrt(tmp) * (tor->tor_r1 + r2);	/* XY part */
d288 2
a289 2
	f = fabs( w1[Z]*tor->tor_alpha ) * tor->tor_r1;		/* Z part */
	tmp = w1[X] * w1[X] + w1[Y] * w1[Y];
d291 1
a291 1
		f += tmp/sqrt(tmp) * (tor->tor_r1 + r2);	/* XY part */
d298 2
a299 2
	f = fabs( w1[Z]*tor->tor_alpha ) * tor->tor_r1;		/* Z part */
	tmp = w1[X] * w1[X] + w1[Y] * w1[Y];
d301 1
a301 1
		f += tmp/sqrt(tmp) * (tor->tor_r1 + r2);	/* XY part */
@


4.5
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 4.4 87/03/18 00:03:13 phil Exp $ (BRL)";
d168 2
a169 2
	LOCAL vect_t	work, temp;
	FAST fastf_t	f;
d265 9
a273 2
	/* Compute bounding RPP */
#define TOR_MM(v)	VMINMAX( stp->st_min, stp->st_max, v );
d275 9
a283 7
	/* Exterior radius is r1+r2;  rescale A and B here */
	f = tor->tor_r1+r2;
	VUNITIZE( A );
	VSCALE( A, A, f );
	VUNITIZE( B );
	VSCALE( B, B, f );
	VSCALE( Hv, Hv, r2 );
d285 9
a293 4
	/* There are 8 corners to the enclosing RPP;  find max and min */
	VADD3( temp, tor->tor_V, B, Hv );
	VADD2( work, temp, A ); TOR_MM( work );	/* V + A + B + Hv */
	VSUB2( work, temp, A ); TOR_MM( work );	/* V - A + B + Hv */
d295 9
a303 13
	VSUB2( temp, tor->tor_V, B );
	VADD2( temp, temp, Hv );
	VADD2( work, temp, A ); TOR_MM( work );	/* V + A - B + Hv */
	VSUB2( work, temp, A ); TOR_MM( work );	/* V - A - B + Hv */
	
	VSUB2( temp, tor->tor_V, Hv );
	VADD2( temp, temp, B );
	VADD2( work, temp, A ); TOR_MM( work );	/* V + A + B - Hv */
	VSUB2( work, temp, A ); TOR_MM( work );	/* V - A + B - Hv */

	VSUB3( temp, tor->tor_V, B, Hv );
	VADD2( work, temp, A ); TOR_MM( work );	/* V + A - B - Hv */
	VSUB2( work, temp, A ); TOR_MM( work );	/* V - A - B - Hv */
@


4.4
log
@added curvature code
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 4.3 87/03/10 23:43:22 phil Locked $ (BRL)";
d158 5
a162 4
tor_prep( vec, stp, mat )
register fastf_t *vec;
struct soltab *stp;
matp_t mat;			/* Homogenous 4x4, with translation, [15]=1 */
d594 20
@


4.3
log
@For Stay, switched 3rd arg to ft_shoot() from resource pointer
(member of application struct) to application struct pointer.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 4.2 87/02/12 22:12:27 mike Locked $ (BRL)";
d136 1
d138 1
d240 1
d247 1
d305 1
d307 1
d534 56
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 4.1 86/12/29 03:46:36 mike Rel1 $ (BRL)";
d339 1
a339 1
tor_shot( stp, rp, res )
d342 1
a342 1
struct resource		*res;
d455 1
a455 1
	GET_SEG(segp, res);
d471 1
a471 1
		GET_SEG(seg2p, res);
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 3.6 86/12/24 08:06:37 mike Locked $ (BRL)";
@


3.6
log
@Revised for resource structure.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 3.5 86/12/14 13:39:52 mike Locked $ (BRL)";
@


3.5
log
@Reduced chatter.
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 3.4 86/10/11 03:08:06 mike Locked $ (BRL)";
d339 4
a342 3
tor_shot( stp, rp )
struct soltab *stp;
register struct xray *rp;
d455 1
a455 1
	GET_SEG(segp);
d471 1
a471 1
		GET_SEG(seg2p);
@


3.4
log
@Changed to use rt_pt_sort().
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 3.3 86/08/12 04:17:01 mike Exp $ (BRL)";
d415 4
a418 2
		rt_log("tor:  polyRoots() 4!=%d\n", i);
		rt_pr_roots( i, val );
@


3.3
log
@Changed #include directives for use with CC -I convention
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 3.2 86/07/24 06:11:00 mike Exp $ (BRL)";
a35 2
static void	TorPtSort();

d445 1
a445 1
	TorPtSort( k, i );
a524 34
}

/*	>>>  s o r t ( )  <<<
 *
 *  Sorts the values of 't' in descending order.
 *  When done, t[0] > t[npts-1]
 *  The sort is simplified to deal with only 4 values.
 */
static void
TorPtSort( t, npts )
register double	t[];
{
	LOCAL double	u;
	register int	n;

#define TOR_XCH(a,b)	{u=a; a=b; b=u;}
	if( npts == 2 )  {
		if ( t[0] < t[1] )  {
			TOR_XCH( t[0], t[1] );
		}
		return;
	}

	for ( n=0; n < 2; ++n ){
		if ( t[n] < t[n+2] ){
			TOR_XCH( t[n], t[n+2] );
		}
	}
	for ( n=0; n < 3; ++n ){
		if ( t[n] < t[n+1] ){
			TOR_XCH( t[n], t[n+1] );
		}
	}
	return;
@


3.2
log
@Added uvcoord support
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 3.1 86/07/11 01:33:23 mike Exp $ (BRL)";
d28 7
a34 7
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/db.h"
#include "../h/raytrace.h"
#include "debug.h"
#include "polyno.h"
#include "complex.h"
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d23 1
a23 1
static char RCStorus[] = "@@(#)$Header: torus.c,v 3.0 86/06/10 01:34:27 mike Exp $ (BRL)";
d263 1
a263 7
#define TOR_MINMAX(a,b,c)	{ FAST fastf_t ftemp;\
			if( (ftemp = (c)) < (a) )  a = ftemp;\
			if( ftemp > (b) )  b = ftemp; }

#define TOR_MM(v)	TOR_MINMAX( stp->st_min[X], stp->st_max[X], v[X] ); \
		TOR_MINMAX( stp->st_min[Y], stp->st_max[Y], v[Y] ); \
		TOR_MINMAX( stp->st_min[Z], stp->st_max[Z], v[Z] )
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: torus.c,v 2.2 86/06/09 21:52:26 mike Exp $ (BRL)";
d33 2
a35 3
#include "./polyno.h"
#include "./complex.h"

d172 4
a175 4
#define SP_V	&vec[0*ELEMENTS_PER_VECT]
#define SP_H	&vec[1*ELEMENTS_PER_VECT]
#define SP_A	&vec[2*ELEMENTS_PER_VECT]
#define SP_B	&vec[3*ELEMENTS_PER_VECT]
d180 3
a182 3
	MAT4X3VEC( A, mat, SP_A );
	MAT4X3VEC( B, mat, SP_B );
	MAT4X3VEC( Hv, mat, SP_H );
d192 3
a194 1
	if( NEAR_ZERO(magsq_a) || NEAR_ZERO(magsq_b) || NEAR_ZERO(magsq_h) ) {
d210 1
a210 1
	if( ! NEAR_ZERO(f) )  {
d216 1
a216 1
	if( ! NEAR_ZERO(f) )  {
d222 1
a222 1
	if( ! NEAR_ZERO(f) )  {
d241 1
a241 1
	MAT4X3PNT( tor->tor_V, mat, SP_V );
d263 1
a263 1
#define MINMAX(a,b,c)	{ FAST fastf_t ftemp;\
d267 3
a269 3
#define MM(v)	MINMAX( stp->st_min[X], stp->st_max[X], v[X] ); \
		MINMAX( stp->st_min[Y], stp->st_max[Y], v[Y] ); \
		MINMAX( stp->st_min[Z], stp->st_max[Z], v[Z] )
d281 2
a282 2
	VADD2( work, temp, A ); MM( work );	/* V + A + B + Hv */
	VSUB2( work, temp, A ); MM( work );	/* V - A + B + Hv */
d286 2
a287 2
	VADD2( work, temp, A ); MM( work );	/* V + A - B + Hv */
	VSUB2( work, temp, A ); MM( work );	/* V - A - B + Hv */
d291 2
a292 2
	VADD2( work, temp, A ); MM( work );	/* V + A + B - Hv */
	VSUB2( work, temp, A ); MM( work );	/* V - A + B - Hv */
d295 2
a296 2
	VADD2( work, temp, A ); MM( work );	/* V + A - B - Hv */
	VSUB2( work, temp, A ); MM( work );	/* V - A - B - Hv */
d435 1
a435 1
		if( NEAR_ZERO( val[j].im ) )
d548 1
a548 1
#define XCH(a,b)	{u=a; a=b; b=u;}
d551 1
a551 1
			XCH( t[0], t[1] );
d558 1
a558 1
			XCH( t[n], t[n+2] );
d563 1
a563 1
			XCH( t[n], t[n+1] );
@


2.2
log
@rt and librt separated
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: torus.c,v 2.1 85/08/31 06:07:48 mike Exp $ (BRL)";
d194 1
a194 1
		rtlog("tor(%s):  zero length A, B, or H vector\n",
d200 2
a201 2
	if( fdiff( r1, mag_b ) != 0 ) {
		rtlog("tor(%s):  (|A|=%f) != (|B|=%f) \n",
d210 1
a210 1
		rtlog("tor(%s):  A not perpendicular to B, f=%f\n",
d216 1
a216 1
		rtlog("tor(%s):  B not perpendicular to H, f=%f\n",
d222 1
a222 1
		rtlog("tor(%s):  A not perpendicular to H, f=%f\n",
d229 2
a230 2
		rtlog("r1 = %f, r2 = %f\n", r1, r2 );
		rtlog("tor(%s):  0 < r2 <= r1 is not true\n", stp->st_name);
d306 2
a307 2
	rtlog("r2/r1 (alpha) = %f\n", tor->tor_alpha);
	rtlog("r1 = %f\n", tor->tor_r1);
d422 2
a423 2
		rtlog("tor:  polyRoots() 4!=%d\n", i);
		pr_roots( i, val );
d446 2
a447 2
		rtlog("tor_shot: reduced 4 to %d roots\n",i);
		pr_roots( 4, val );
@


2.1
log
@Version 2 of RT
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.22 85/07/30 05:56:16 mike Exp $ (BRL)";
d31 1
a31 1
#include "raytrace.h"
@


1.22
log
@Changes for merged GED & RT vmath.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.21 85/07/30 02:16:43 mike Exp $ (BRL)";
d27 1
d194 1
a194 1
		fprintf(stderr,"tor(%s):  zero length A, B, or H vector\n",
d201 1
a201 1
		fprintf(stderr,"tor(%s):  (|A|=%f) != (|B|=%f) \n",
d210 1
a210 2
		fprintf(stderr,
			"tor(%s):  A not perpendicular to B, f=%f\n",
d216 1
a216 2
		fprintf(stderr,
			"tor(%s):  B not perpendicular to H, f=%f\n",
d222 1
a222 2
		fprintf(stderr,
			"tor(%s):  A not perpendicular to H, f=%f\n",
d229 2
a230 2
		fprintf(stderr,"r1 = %f, r2 = %f\n", r1, r2 );
		fprintf(stderr,"tor(%s):  0 < r2 <= r1 is not true\n", stp->st_name);
a257 1
	/* Compute bounding sphere */
d259 1
a259 2
	f = tor->tor_r1 + r2;
	stp->st_radsq = f * f;
d306 2
a307 2
	fprintf(stderr,"r2/r1 (alpha) = %f\n", tor->tor_alpha);
	fprintf(stderr,"r1 = %f\n", tor->tor_r1);
d422 1
a422 1
		fprintf(stderr,"tor:  polyRoots() 4!=%d\n", i);
d446 1
a446 1
		fprintf(stderr,"tor_shot: reduced 4 to %d roots\n",i);
a460 1

d463 3
a465 1
	segp->seg_flag = SEG_IN | SEG_OUT;
a466 10
	/* Intersection point, entering */
	VJOIN1( segp->seg_in.hit_point, rp->r_pt, k[1]*tor->tor_r1, rp->r_dir );
	VJOIN1( work, pprime, k[1], dprime );
	tornormal( segp->seg_in.hit_normal, work, tor );

	/* Intersection point, exiting */
	VJOIN1( segp->seg_out.hit_point, rp->r_pt, k[0]*tor->tor_r1, rp->r_dir );
	VJOIN1( work, pprime, k[0], dprime );
	tornormal( segp->seg_out.hit_normal, work, tor );

d482 2
a483 12
	segp->seg_flag = SEG_IN | SEG_OUT;

	/* Intersection point, entering */
	VJOIN1( segp->seg_in.hit_point, rp->r_pt, k[3]*tor->tor_r1, rp->r_dir );
	VJOIN1( work, pprime, k[3], dprime );
	tornormal( segp->seg_in.hit_normal, work, tor );

	/* Intersection point, exiting */
	VJOIN1( segp->seg_out.hit_point, rp->r_pt, k[2]*tor->tor_r1, rp->r_dir );
	VJOIN1( work, pprime, k[2], dprime );
	tornormal( segp->seg_out.hit_normal, work, tor );

a486 3
#define X	0
#define Y	1
#define Z	2
d488 1
a488 1
 *			T O R N O R M A L
d511 4
a514 3
tornormal( norm, hit, tor )
register vectp_t norm, hit;
register struct tor_specific *tor;
d516 2
d521 5
a525 2
	w = hit[X]*hit[X] + hit[Y]*hit[Y] + hit[Z]*hit[Z] +
	    1.0 - tor->tor_alpha*tor->tor_alpha;
d527 3
a529 3
		(4.0 * w - 8.0 ) * hit[X],
		(4.0 * w - 8.0 ) * hit[Y],
		4.0 * w * hit[Z] );
d531 1
a531 1
	MAT3XVEC( norm, tor->tor_invR, work );
d566 4
@


1.21
log
@Added Gary Moss's tolerance checking improvements.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.21 85/07/30 02:02:52 mike Exp $ (BRL)";
d27 2
a29 1
#include "vmath.h"
@


1.20
log
@Code from Moss & Davisson to translate ray origin near to the
coordinate system of the torus before computing intersection,
to lessen the burden on the root finder.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.19 85/03/25 11:47:33 mike Exp $ (BRL)";
d169 1
d188 1
d198 1
a198 2
	f = r1 - sqrt(magsq_b);
	if( ! NEAR_ZERO(f) )  {
d200 1
a200 1
			stp->st_name, r1, sqrt(magsq_b) );
d205 6
a210 4
	f = VDOT( A, B );
	if( !NEAR_ZERO(f) )  {
		/* perhaps something with reldiff() might be better? */
		fprintf(stderr,"tor(%s):  A not perpendicular to B, f=%f\n",stp->st_name, f);
d213 5
a217 3
	f = VDOT( B, Hv );
	if( !NEAR_ZERO(f) )  {
		fprintf(stderr,"tor(%s):  B not perpendicular to H, f=%f\n",stp->st_name, f);
d220 5
a224 3
	f = VDOT( A, Hv );
	if( !NEAR_ZERO(f) )  {
		fprintf(stderr,"tor(%s):  A not perpendicular to H, f=%f\n",stp->st_name, f);
@


1.19
log
@Housekeeping
@
text
@d11 1
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.18 85/02/09 01:31:46 mike Exp $ (BRL)";
d27 1
a29 1
#include "../h/db.h"
d68 6
a73 5
 *  
 *  and S(X) =	 (  1/|H|   0     0   )
 *  		(    0    1/|H|   0    ) . X
 *  		 (   0      0   1/|H| )
 *  
d136 1
d232 2
d235 1
a235 1
	tor->tor_alpha = r2/r1;
d250 1
a250 1
	tor->tor_SoR[15] *= r1;
d254 1
a254 1
	f = r1 + r2;
d267 1
a267 1
	f = r1+r2;
d303 1
d359 2
d364 2
d369 11
d398 4
a401 2
	X2_Y2.cf[1] = 2.0 * (dprime[X] * pprime[X] + dprime[Y] * pprime[Y]);
	X2_Y2.cf[2] = pprime[X] * pprime[X] + pprime[Y] * pprime[Y];
d406 2
a407 2
	A.cf[1] = X2_Y2.cf[1] + 2.0 * dprime[Z] * pprime[Z];
	A.cf[2] = X2_Y2.cf[2] + pprime[Z] * pprime[Z] +
d433 5
d458 2
a459 2
	segp->seg_in.hit_dist = k[1];
	segp->seg_out.hit_dist = k[0];
d463 1
a463 1
	VJOIN1( segp->seg_in.hit_point, rp->r_pt, k[1], rp->r_dir );
d468 1
a468 1
	VJOIN1( segp->seg_out.hit_point, rp->r_pt, k[0], rp->r_dir );
d485 2
a486 2
	segp->seg_in.hit_dist = k[3];
	segp->seg_out.hit_dist = k[2];
d490 1
a490 1
	VJOIN1( segp->seg_in.hit_point, rp->r_pt, k[3], rp->r_dir );
d495 1
a495 1
	VJOIN1( segp->seg_out.hit_point, rp->r_pt, k[2], rp->r_dir );
@


1.18
log
@Minor efficiency improvement:
if ray ends at negative K, return SEG_NULL
@
text
@d12 8
a19 4
 * U. S. Army Ballistic Research Laboratory
 * August, 1984
 *
 * $Revision: 1.17 $
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.17 85/02/08 02:41:23 mike Exp $ (BRL)";
d28 1
a28 1
#include "db.h"
@


1.17
log
@Fixed stupid typo dprime/pprime.
Rescaled Hv for accurate bounding RPP.
@
text
@d15 1
a15 1
 * $Revision: 1.16 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.16 85/02/08 01:59:09 mike Exp $ (BRL)";
d30 1
a30 2
HIDDEN int	stdTorus();
static void	PtSort();
d391 1
a391 1
		fprintf(stderr,"stdTorus:  polyRoots() 4!=%d\n", i);
d415 2
a416 2
	/* Most distant to least distant */
	PtSort( k, i );
d418 5
a422 1
	/* k[1] is entry point, and k[0] is exit point */
d516 3
a518 3
 *  Sorts the values of 't' in descending order.  The sort is
 *  simplified to deal with only 4 values.  Returns the address
 *  of the first 't' in the array.
d521 1
a521 1
PtSort( t, npts )
@


1.16
log
@Moved stdTorus() inline, and made various optimizations.
@
text
@d15 1
a15 1
 * $Revision: 1.15 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.15 85/02/07 22:08:55 mike Exp $ (BRL)";
d373 2
a374 2
	X2_Y2.cf[0] = pprime[X] * pprime[X] + pprime[Y] * pprime[Y];
	X2_Y2.cf[1] = 2.0 * (pprime[X] * pprime[X] + pprime[Y] * pprime[Y]);
d379 2
a380 2
	A.cf[0] = X2_Y2.cf[0] + pprime[Z] * pprime[Z];
	A.cf[1] = X2_Y2.cf[1] + 2.0 * pprime[Z] * pprime[Z];
@


1.15
log
@Fixed JeffH coding error which discarded additional roots
when trimming off complex roots.
@
text
@d15 1
a15 1
 * $Revision: 1.14 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.14 85/02/07 19:38:31 mike Exp $ (BRL)";
d264 1
d343 7
a349 2
	LOCAL double	k[4];		/* possible intersections */
	LOCAL int	npts;		/* # intersection points */
d351 1
a351 1
	/* out, Mat, vect */
d356 53
a408 2
	npts = stdTorus( pprime, dprime, tor->tor_alpha, k);
	if( npts != 2 && npts != 4 )
d410 5
d417 1
a417 1
	PtSort( k, npts );
a418 1
	/* Will be either 2 or 4 hit points */
a422 1
	/* ASSERT that MAGNITUDE(rp->r_dir) == 1 */
d437 1
a437 1
	if( npts == 2 )
a508 82
}

/*
 *	>>>  s t d T o r u s ( )  <<<
 *
 *  Given a line and a ratio, alpha, finds the roots of the
 *  equation for that unit torus and line.
 *  Returns the number of real roots found.
 *
 *  Given a line and a ratio, alpha, finds the equation of the
 *  unit torus in terms of the variable 't'.
 *
 *  The equation for the torus is:
 *
 *      [ X**2 + Y**2 + Z**2 + (1 - alpha**2) ]**2 - 4*( X**2 + Y**2 )  =  0
 *
 *  First, find X, Y, and Z in terms of 't' for this line, then
 *  substitute them into the equation above.
 *
 *  	Wx = Dx*t + Px
 *
 *  	Wx**2 = Dx**2 * t**2  +  2 * Dx * Px  +  Px**2
 *  		[0]                [1]           [2]    dgr=2
 */
HIDDEN int
stdTorus(Point,Direc,alpha,t)
vect_t	Point, Direc;
double	alpha, t[];
{
	LOCAL poly	C;
	LOCAL complex	val[MAXP];
	register int	i, l, npts;
	LOCAL poly	tfun, tsqr[3];
	LOCAL poly	A, Asqr;
	LOCAL poly	X2_Y2;		/* X**2 + Y**2 */
	LOCAL int	m;

	/*  Express each variable (X, Y, and Z) as a linear equation
	 *  in 't'.  Then square each of those.
	 */
	for ( m=0; m < 3; ++m ){
		tfun.dgr = 1;
		tfun.cf[0] = Direc[m];
		tfun.cf[1] = Point[m];
		(void) polyMul(&tfun,&tfun,&tsqr[m]);
	}

	/*  Substitute the resulting binomials into the torus equation	*/
	(void) polyAdd( &tsqr[0], &tsqr[1], &X2_Y2 );
	(void) polyAdd( &X2_Y2, &tsqr[2], &A );
	A.cf[2] += 1.0 - alpha * alpha;		/* pow(alpha,2.0) */
	(void) polyMul( &A, &A, &Asqr );
	(void) polyScal( &X2_Y2, 4.0 );
	(void) polySub( &Asqr, &X2_Y2, &C );

	/*  It is known that the equation is 4th order.  Therefore,
	 *  if the root finder returns other than 4 roots, there must
	 *  be a problem somewhere, so return an error value.
	 */
	if ( (npts = polyRoots( &C, val )) != 4 ){
		fprintf(stderr,"stdTorus:  polyRoots() 4!=%d\n", npts);
		pr_poly( &C );
		pr_roots( npts, val );
		return(-1);		/* BAD */
	}

	/*  Only real roots indicate an intersection in real space.
	 *
	 *  Look at each root returned; if the imaginary part is zero
	 *  or sufficiently close, then use the real part as one value
	 *  of 't' for the intersections
	 */
	for ( l=0, i=0; l < npts; l++ ){
		if( NEAR_ZERO( val[l].im ) )
			t[i++] = val[l].re;
	}
	/* Here, 'i' is number of points being returned */
	if( i != 0 && i != 2 && i != 4 )  {
		fprintf(stderr,"stdTorus reduced 4 to %d roots != {2,4}\n",i);
		pr_roots( npts, val );
	}
	return i;
@


1.14
log
@Made |A| == |B| test more reasonable.
@
text
@d15 1
a15 1
 * $Revision: 1.13 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.13 85/01/31 20:44:21 mike Exp $ (BRL)";
d30 1
a30 1
static int	stdTorus();
a175 1
	/* Validate that |A| > 0, |B| > 0, |H| > 0 */
d179 4
d190 1
a190 1
	f = sqrt(magsq_a) - sqrt(magsq_b);
d193 1
a193 1
			stp->st_name, sqrt(magsq_a), sqrt(magsq_b) );
d199 2
a200 1
	if( ! NEAR_ZERO(f) )  {
d205 1
a205 1
	if( ! NEAR_ZERO(f) )  {
d210 1
a210 1
	if( ! NEAR_ZERO(f) )  {
a215 2
	r1 = sqrt(magsq_a);
	r2 = sqrt(magsq_h);
d351 1
a351 1
	if( npts <= 0 )
a353 5
	if( npts != 2 && npts != 4 )  {
		fprintf(stderr,"tor(%s):  %d intersects != {2,4}\n", stp->st_name, npts );
		return(SEG_NULL);		/* No hit */
	}

d473 1
a473 1
static int
d509 4
a512 2
		fprintf(stderr,"stdTorus:  polyRoots() returned %d?\n", npts);
		return(-1);
d519 1
a519 2
	 *  of 't' for the intersections, otherwise reduce the number
	 *  of points returned.
d521 2
a522 3
#define	TOLER		.00001
	for ( l=0, i=0; i < npts; ++l ){
		if ( Abs( val[l].im ) <= TOLER )
a523 2
		else
			npts--;
d525 6
a530 1
	return npts;
@


1.13
log
@Fixed bounding RPP;  previously was too small.
@
text
@d15 1
a15 1
 * $Revision: 1.12 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.12 85/01/31 17:02:45 mike Exp $ (BRL)";
d187 1
a187 1
	f = magsq_a - magsq_b;
d189 2
a190 1
		fprintf(stderr,"tor(%s):  |A| != |B|\n", stp->st_name);
@


1.12
log
@Added more information on not-perpendicular messages (dot product).
@
text
@d15 1
a15 1
 * $Revision: 1.11 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.11 84/12/17 15:45:19 mike Exp $ (BRL)";
d254 7
@


1.11
log
@Fixed scaling bug.
@
text
@d15 1
a15 1
 * $Revision: 1.10 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.10 84/11/24 03:00:47 mike Exp $ (BRL)";
d196 1
a196 1
		fprintf(stderr,"tor(%s):  A not perpendicular to B\n",stp->st_name);
d201 1
a201 1
		fprintf(stderr,"tor(%s):  B not perpendicular to H\n",stp->st_name);
d206 1
a206 1
		fprintf(stderr,"tor(%s):  A not perpendicular to H\n",stp->st_name);
@


1.10
log
@Rewrote code to compute bounding RPPs correctly,
although perhaps slightly too large.
@
text
@d15 1
a15 1
 * $Revision: 1.9 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.9 84/11/23 20:56:39 mike Exp $ (BRL)";
d239 1
a239 4
	f = 1.0 / r1;
	tor->tor_SoR[0] *= f;
	tor->tor_SoR[5] *= f;
	tor->tor_SoR[10] *= f;
d336 1
a336 1
	MAT3XVEC( dprime, tor->tor_SoR, rp->r_dir );
d338 1
a338 1
	MAT3XVEC( pprime, tor->tor_SoR, work );
@


1.9
log
@Added LOCAL, fastf_t declarations.
Made shootray() recursive.
@
text
@d15 1
a15 1
 * $Revision: 1.8 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.8 84/11/20 20:15:09 mike Exp $ (BRL)";
a249 5

	/* init maxima and minima */
	stp->st_max[X] = stp->st_max[Y] = stp->st_max[Z] = -INFINITY;
	stp->st_min[X] = stp->st_min[Y] = stp->st_min[Z] =  INFINITY;

d258 4
a261 3
	VADD2( work, tor->tor_V, A );
	VADD2( temp, work, Hv ); MM( work );
	VSUB2( temp, work, Hv ); MM( work );
d263 9
a271 3
	VSUB2( work, tor->tor_V, A );
	VADD2( temp, work, Hv ); MM( work );
	VSUB2( temp, work, Hv ); MM( work );
d273 3
a275 3
	VADD2( work, tor->tor_V, B );
	VADD2( temp, work, Hv ); MM( work );
	VSUB2( temp, work, Hv ); MM( work );
a276 16
	VSUB2( work, tor->tor_V, B );
	VADD2( temp, work, Hv ); MM( work );
	VSUB2( temp, work, Hv ); MM( work );

	/*  In the case of A and B being 45 degrees off an axis,
	 *  the above code is not good enough, and sqrt(2)*radius
	 *  error will creep in, so compensate for this.
	 *  We +/- one half of the correction factor.
	 */
	f *= sqrt(2.0) / 2.0;
	stp->st_min[X] -= f;
	stp->st_min[Y] -= f;
	stp->st_min[Z] -= f;
	stp->st_max[X] += f;
	stp->st_max[X] += f;
	stp->st_max[X] += f;
@


1.8
log
@General cleanup
@
text
@d15 1
a15 1
 * $Revision: 1.7 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.7 84/11/16 06:29:58 mike Exp $ (BRL)";
d157 4
a160 4
	static fastf_t	magsq_a, magsq_b, magsq_h;
	static mat_t	R;
	static vect_t	A, B, Hv;
	static vect_t	work, temp;
d162 1
a162 1
	static fastf_t	r1, r2;	/* primary and secondary radius */
d346 5
a350 5
	static vect_t	dprime;		/* D' */
	static vect_t	pprime;		/* P' */
	static vect_t	work;		/* temporary vector */
	static double	k[4];		/* possible intersections */
	static int	npts;		/* # intersection points */
d451 1
a451 1
	static vect_t work;
d490 2
a491 2
	static poly	C;
	static complex	val[MAXP];
d493 4
a496 4
	static poly	tfun, tsqr[3];
	static poly	A, Asqr;
	static poly	X2_Y2;		/* X**2 + Y**2 */
	static int	m;
d552 1
a552 1
	static double	u;
@


1.7
log
@struct ray --> struct xray
Bounding RPP
@
text
@d15 1
a15 1
 * $Revision: 1.6 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.6 84/11/16 00:41:04 mike Exp $ (BRL)";
d181 1
a181 1
		printf("tor(%s):  zero length A, B, or H vector\n",
d189 1
a189 1
		printf("tor(%s):  |A| != |B|\n", stp->st_name);
d196 1
a196 1
		printf("tor(%s):  A not perpendicular to B\n",stp->st_name);
d201 1
a201 1
		printf("tor(%s):  B not perpendicular to H\n",stp->st_name);
d206 1
a206 1
		printf("tor(%s):  A not perpendicular to H\n",stp->st_name);
d214 2
a215 2
		printf("r1 = %f, r2 = %f\n", r1, r2 );
		printf("tor(%s):  0 < r2 <= r1 is not true\n", stp->st_name);
d300 1
a300 1
	printf("r2/r1 (alpha) = %f\n", tor->tor_alpha);
d362 1
a362 1
		printf("tor(%s):  %d intersects != {2,4}\n", stp->st_name, npts );
d521 1
a521 1
		printf("stdTorus:  polyRoots() returned %d?\n", npts);
@


1.6
log
@Fixed construction of rotation matrix R for building Z-axis aligned
"standard" torus.
@
text
@d15 1
a15 1
 * $Revision: 1.5 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.5 84/11/15 21:48:51 mike Exp $ (BRL)";
d23 1
a23 1
#include "ray.h"
d160 1
d249 42
d341 1
a341 1
register struct ray *rp;
@


1.5
log
@Matrix fix.
@
text
@d15 1
a15 1
 * $Revision: 1.4 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.4 84/10/19 01:39:27 mike Exp $ (BRL)";
d31 1
a31 1
static void	PtSort(), alignZ(), Zrotat(), Yrotat();
d61 1
a61 1
 *  where R(X) =  ( A/(|A|) )		WRONG!!
d171 3
a173 3
	MAT3XVEC( A, mat, SP_A );
	MAT3XVEC( B, mat, SP_B );
	MAT3XVEC( Hv, mat, SP_H );
d227 7
a233 1
	alignZ( R, Hv );
a530 49
}

/*
 *			A L I G N z
 *
 *  Find the rotation matrix to the Z axis using the components
 *  of the vector normal to the plane of the torus.
 */
static void
alignZ( rot, Norm )
matp_t 		rot;
register vectp_t Norm;
{
	mat_t		rotZ, rotY;
	double		h;

	h = sqrt(Norm[X]*Norm[X] + Norm[Y]*Norm[Y]);

	mat_idn( rot );
	if ( NEAR_ZERO(h) )
		return;		/* No rotation required */

	Zrotat( rotZ, Norm[X]/h, Norm[Y]/h );
	Yrotat( rotY, Norm[Z], h );
	mat_mul( rot, rotZ, rotY );
}

/* Here, theta == Azimuth, like in mat_ae() */
static void
Zrotat(mat, cs_theta, sn_theta )
matp_t	mat;
double	cs_theta, sn_theta;
{
	mat_idn( mat );

	mat[0] =  mat[5] = cs_theta;
	mat[1] = -(mat[4] = sn_theta);
}

/* phi here is like elevation in mat_ae(). */
static void
Yrotat( mat, cs_phi, sn_phi )
matp_t	mat;
double	cs_phi, sn_phi;
{
	mat_idn( mat );

	mat[0] =  mat[10] = cs_phi;
	mat[8] = -(mat[2] = sn_phi);
@


1.4
log
@Lint corrections
@
text
@d15 1
a15 1
 * $Revision: 1.3 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.3 84/09/06 03:59:38 mike Exp $ (BRL)";
d222 1
a222 2
	MAT4X3VEC( tor->tor_V, mat, SP_V );

@


1.3
log
@Fixed conflict with symbol "H"
@
text
@d15 1
a15 1
 * $Revision: 1.2 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.2 84/08/22 03:19:31 mike Exp $ (BRL)";
a159 1
	static vect_t	work;
d222 1
a222 5
	/* Apply full 4x4mat to V */
	VMOVE( work, SP_V );
	work[3] = 1;
	matXvec( tor->tor_V, mat, work );
	htov_move( tor->tor_V, tor->tor_V );
d332 2
a333 2
	VCOMPOSE1( segp->seg_in.hit_point, rp->r_pt, k[1], rp->r_dir );
	VCOMPOSE1( work, pprime, k[1], dprime );
d337 2
a338 2
	VCOMPOSE1( segp->seg_out.hit_point, rp->r_pt, k[0], rp->r_dir );
	VCOMPOSE1( work, pprime, k[0], dprime );
d359 2
a360 2
	VCOMPOSE1( segp->seg_in.hit_point, rp->r_pt, k[3], rp->r_dir );
	VCOMPOSE1( work, pprime, k[3], dprime );
d364 2
a365 2
	VCOMPOSE1( segp->seg_out.hit_point, rp->r_pt, k[2], rp->r_dir );
	VCOMPOSE1( work, pprime, k[2], dprime );
@


1.2
log
@Fixed serious Normal vector problem, neatened the code up.
@
text
@d15 1
a15 1
 * $Revision: 1.1 $
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: torus.c,v 1.1 84/08/21 01:19:51 mike Exp $ (BRL)";
a29 2
#define	Abs( a )	((a) >= 0 ? (a) : -(a))

d159 1
a159 1
	static vect_t	A, B, H;
d174 1
a174 1
	MAT3XVEC( H, mat, SP_H );
d179 1
a179 1
	magsq_h = MAGSQ( H );
d199 1
a199 1
	f = VDOT( B, H );
d204 1
a204 1
	f = VDOT( A, H );
d232 2
a233 2
	VUNITIZE( H );
	alignZ( R, H );
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
 * $Revision$
d18 1
a18 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d33 1
a33 1
static void	PtSort();
d39 1
a39 1
 *	A,B	perpindicular, to CENTER of torus (for top, bottom) |A|==|B|==R1
d63 1
a63 1
 *  where R(X) =  ( A/(|A|) )
d85 17
a101 4
----- cut here.
 *  Let dp = D' dot P'
 *  Let dd = D' dot D'
 *  Let pp = P' dot P'
a102 16
 *  and k = [ -dp +/- sqrt( dp*dp - dd * (pp - 1) ) ] / dd
 *  which is constant.
 *  
 *  Now, D' = S( R( D ) )
 *  and  P' = S( R( P - V ) )
 *  
 *  Substituting,
 *  
 *  W = V + invR( invS[ k *( S( R( D ) ) ) + S( R( P - V ) ) ] )
 *    = V + invR( ( k * R( D ) ) + R( P - V ) )
 *    = V + k * D + P - V
 *    = k * D + P
 *  
 *  Note that ``k'' is constant, and is the same in the formulations
 *  for both W and W'.
 *  
d106 2
a107 1
 *  Map W onto the unit sphere, ie:  W' = S( R( W - V ) ).
d109 2
a110 10
 *  Plane on unit sphere at W' has a normal vector of the same value(!).
 *  
 *  The plane transforms back to the tangent plane at W, and this
 *  new plane (on the torus) has a normal vector of N, viz:
 *  
 *  N = inverse[ transpose(invR o invS) ] ( W' )
 *    = inverse[ transpose(invS) o transpose(invR) ] ( W' )
 *    = inverse[ inverse(S) o R ] ( W' )
 *    = invR o S ( W' )
 *    = invR( S( S( R( W - V ) ) ) )
d112 14
d127 2
a161 1
	static vect_t	inv;	/* [ 1/(|A|), 1/(|B|), 1/(|H|) ] */
d225 1
a225 1
	/* Apply full 4x4mat to V.  No need for htov_vec, as [15]==1. */
d229 1
d234 3
a236 8
	mat_zero( R );
	inv[0] = 1.0/sqrt(magsq_a);
	VSCALE( &R[0], A, inv[0] );
	inv[1] = 1.0/sqrt(magsq_b);
	VSCALE( &R[4], B, inv[1] );
	inv[2] = 1.0/sqrt(magsq_h);
	VSCALE( &R[8], H, inv[2] );
	mat_trn( tor->tor_invR, R );		/* inv of rot mat is trn */
d243 1
a243 1
	tor->tor_SoR[14] *= f;
d248 1
a248 1
	stp->st_radsq = f * f * 1.1;	/* debug */
d272 4
a275 4
 *	NOTE:	All lines in this function are represented parametrically
 *		by a point,  P( x0, y0, z0 ) and a direction normal,
 *		D = ax + by + cz.  Any point on a line can be expressed
 *		by one variable 't', where
d277 3
a279 3
 *				X = a*t + x0,	X = Dx*t + Px
 *				Y = b*t + y0,
 *				Z = c*t + z0.
d281 5
a285 5
 *	First, convert the line to the coordinate system of a "stan-
 *	dard" torus.  This is a torus which lies in the X-Y plane,
 *	circles the origin, and whose primary radius is one.  The
 *	secondary radius is  alpha = ( R2/R1 )  of the original torus
 *	where  ( 0 < alpha <= 1 ).
d287 5
a291 5
 *	Then find the equation of that line and the standard torus,
 *	which turns out to be a quartic equation in 't'.  Solve the
 *	equation using a general polynomial root finder.  Use those
 *	values of 't' to compute the points of intersection in the
 *	original coordinate system.
d307 1
a307 1
	static vect_t	xlated;		/* translated vector */
d309 1
a309 2
	int		npts;		/* # intersection points */
	FAST fastf_t	w;
d313 2
a314 2
	VSUB2( xlated, rp->r_pt, tor->tor_V );
	MAT3XVEC( pprime, tor->tor_SoR, xlated );
a327 8
if(debug&DEBUG_TESTING)  {
	register int i;
	printf("npts=%d\n", npts);
	for(i=0; i<npts; i++)
		printf("k=%f, ", k[i]);
	printf("\n");
}

d338 1
a338 1
	/* Intersection point, exiting */
d340 2
d343 4
a346 13
	/* Normal at that point, pointing out */
#define hp	segp->seg_in.hit_point
#define X	0
#define Y	1
#define Z	2
	w = hp[X]*hp[X] + hp[Y]*hp[Y] + hp[Z]*hp[Z] +
	    1.0 - tor->tor_alpha*tor->tor_alpha;
	VSET( xlated,
		4.0 * hp[X] * w - 8.0 * hp[X],
		4.0 * hp[Y] * w - 8.0 * hp[Y],
		4.0 * hp[Z] * w );
	VUNITIZE( xlated );
	MAT3XVEC( segp->seg_in.hit_normal, tor->tor_invR, xlated );
a347 10
	/* Intersection point, entering */
	VCOMPOSE1( segp->seg_out.hit_point, rp->r_pt, k[0], rp->r_dir );
	w = hp[X]*hp[X] + hp[Y]*hp[Y] + hp[Z]*hp[Z] +
	    1.0 - tor->tor_alpha*tor->tor_alpha;
	VSET( xlated,
		4.0 * hp[X] * w - 8.0 * hp[X],
		4.0 * hp[Y] * w - 8.0 * hp[Y],
		4.0 * hp[Z] * w );
	VUNITIZE( xlated );
	MAT3XVEC( segp->seg_in.hit_normal, tor->tor_invR, xlated );
d350 1
a350 1

d354 1
a354 1
		struct seg *seg2p;		/* XXX */
d365 1
a365 1
	/* Intersection point, exiting */
d367 2
d370 1
a370 11
	/* Normal at that point, pointing out */
	w = hp[X]*hp[X] + hp[Y]*hp[Y] + hp[Z]*hp[Z] +
	    1.0 - tor->tor_alpha*tor->tor_alpha;
	VSET( xlated,
		4.0 * hp[X] * w - 8.0 * hp[X],
		4.0 * hp[Y] * w - 8.0 * hp[Y],
		4.0 * hp[Z] * w );
	VUNITIZE( xlated );
	MAT3XVEC( segp->seg_in.hit_normal, tor->tor_invR, xlated );

	/* Intersection point, entering */
d372 2
a373 8
	w = hp[X]*hp[X] + hp[Y]*hp[Y] + hp[Z]*hp[Z] +
	    1.0 - tor->tor_alpha*tor->tor_alpha;
	VSET( xlated,
		4.0 * hp[X] * w - 8.0 * hp[X],
		4.0 * hp[Y] * w - 8.0 * hp[Y],
		4.0 * hp[Z] * w );
	VUNITIZE( xlated );
	MAT3XVEC( segp->seg_in.hit_normal, tor->tor_invR, xlated );
d378 33
d412 9
d422 2
a423 4
/*	>>>  s t d T o r u s ( )  <<<
 *	Given a line and a ratio, alpha, finds the roots of the
 *	equation for that torus and line.
 *	Returns the number of real roots found.
d425 3
a427 3
 *	Given a line and a ratio, alpha, finds the equation of the
 *	torus in terms of the variable 't'.  Returns a pointer to
 *	the polynomial.  The equation for the torus is
d429 2
a430 1
 *	    0 = [ X^2 + Y^2 + Z^2 + (1 - alpha^2) ]^2 - 4*( X^2 + Y^2 ).
d432 1
a432 2
 *	First, find X, Y, and Z in terms of 't' for this line, then
 *	substitute them into the equation above.
d434 1
a434 1
 *		Wx = Dx*t + Px
d436 7
a442 2
 *		Wx**2 = Dx**2 * t**2  +  2 * Dx * Px  +  Px**2
 *			[0]                [1]           [2]    dgr=2
d454 1
a454 1
	static poly	X2_Y2;		/* X^2 + Y^2 */
a500 2


d502 4
a505 3
 *	Sorts the values of 't' in descending order.  The sort is
 *	simplified to deal with only 4 values.  Returns the address
 *	of the first 't' in the array.
d533 49
@
