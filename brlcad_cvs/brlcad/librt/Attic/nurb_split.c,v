head	11.14;
access;
symbols
	ansi-20040405-merged:11.10.2.2
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.10.10.1
	premerge-autoconf:11.11
	ansi-20040316-freeze:11.10.2.1
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.10.4.1
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.10
	phong-branch:11.10.0.8
	photonmap-branch:11.10.0.6
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.6.2.1
	offsite-5-3-pre:11.7
	rel-5-3:11.6.2.1
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.6
	rel-5-0-beta:11.5
	rel-4-5:11.5
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.14
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.13;

11.13
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.12;

11.12
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2004.03.05.22.30.08;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2002.08.20.17.08.07;	author jra;	state Exp;
branches
	11.10.2.1
	11.10.4.1
	11.10.10.1;
next	11.9;

11.9
date	2002.08.15.20.55.20;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2001.04.20.22.29.55;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2000.11.14.21.13.21;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	99.06.03.01.39.15;	author mike;	state Exp;
branches
	11.6.2.1;
next	11.5;

11.5
date	97.10.06.21.35.36;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	96.12.31.01.09.27;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.12.01.02.49.33;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.53;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	10.8;

10.8
date	95.01.04.07.42.05;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.08.11.01.18.40;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	92.06.02.22.52.07;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.05.29.08.09.50;	author stay;	state Exp;
branches;
next	10.4;

10.4
date	92.05.29.01.20.10;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.05.29.00.52.29;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.28.22.12.15;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.13;	author mike;	state Rel4_0;
branches;
next	1.3;

1.3
date	91.06.14.09.42.23;	author stay;	state Exp;
branches;
next	1.2;

1.2
date	91.05.18.02.42.26;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	91.05.18.02.36.02;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.6.2.1
date	2000.11.14.21.35.30;	author jra;	state Exp;
branches;
next	;

11.10.2.1
date	2002.09.19.18.01.45;	author morrison;	state Exp;
branches;
next	11.10.2.2;

11.10.2.2
date	2004.03.17.21.18.56;	author morrison;	state Exp;
branches;
next	;

11.10.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.10.10.1
date	2004.03.10.14.00.50;	author erikg;	state Exp;
branches;
next	;


desc
@Splitter
@


11.14
log
@moved to src/
@
text
@/*
 *			N U R B _ S P L I T . C
 *
 * Function -
 * 	Subdivide a nurb surface by inserting a multiple knot of
 * 	of the surface order in a given direction and return the 
 *	resulting surfaces.
 *
 * Author-
 *	Paul Randal Stay
 *
 * Source
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The US Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland 21005
 *
 *
 * Copyright Notice -
 * 	This software if Copyright (C) 1990-2004 by the United States Army.
 *	All Rights Reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"

/* Algorithm
 *
 * 	Given a parametric direction (u or v) look at the direction 
 * knot vector and insert a multiple knot of parametric direction surface
 * order.  If internal knot values exist than pick the one closest to the
 * middle and add additional knots to split at that value, otherwise
 * add multiple knots at the mid point of the knot vector. Use the new
 * knot vector to pass to the oslo refinement process and split the surface.
 * Separate the surface and return the two resulting surface.
 *
 *  The original surface is undisturbed by this operation.
 */
void
rt_nurb_s_split(struct bu_list *split_hd, const struct face_g_snurb *srf, int dir, struct resource *res)
{
	struct knot_vector new_kv;
	fastf_t value;
	struct oslo_mat * oslo;
	int i;
	int k_index = 0;
	struct face_g_snurb * srf1, * srf2;

	NMG_CK_SNURB(srf);

	if ( dir == RT_NURB_SPLIT_ROW )
	{
		value = srf->u.knots[(srf->u.k_size -1)/2];
		
		for( i = 0; i < srf->u.k_size; i++)
			if( value == srf->u.knots[i] )
			{
				k_index = i;
				break;
			}
		if ( k_index == 0)
		{
			value = ( value + 
				srf->u.knots[ srf->u.k_size -1])
				/2.0;
			k_index = srf->order[0];
		}

		rt_nurb_kvmult( &new_kv, &srf->u, srf->order[0], value, res);

		oslo = ( struct oslo_mat *) 
			rt_nurb_calc_oslo( srf->order[RT_NURB_SPLIT_ROW], &srf->u, &new_kv, res);

		GET_SNURB( srf1 );
		srf1->order[0]  = srf->order[0];
		srf1->order[1]  = srf->order[1];
		srf1->dir = RT_NURB_SPLIT_ROW;
		rt_nurb_kvextract(&srf1->u, &new_kv, 0, k_index + srf1->order[0], res);
		rt_nurb_kvcopy(&srf1->v, &srf->v, res);
		
		srf1->pt_type = srf->pt_type;
		srf1->s_size[0] = srf1->v.k_size - 
			srf1->order[1];
		srf1->s_size[1] = srf1->u.k_size - 
			srf1->order[0];

		srf1->ctl_points = (fastf_t *)
			bu_malloc( sizeof(fastf_t) * srf1->s_size[0] *
				srf1->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->pt_type),
				"rt_nurb_s_split: srf1 row mesh control points");

		GET_SNURB( srf2 );
		srf2->order[0]  = srf->order[0];
		srf2->order[1]  = srf->order[1];
		srf2->dir = RT_NURB_SPLIT_ROW;
		rt_nurb_kvextract(&srf2->u, &new_kv, k_index, new_kv.k_size, res);
		rt_nurb_kvcopy(&srf2->v, &srf->v, res);
		
		srf2->pt_type = srf->pt_type;
		srf2->s_size[0] = srf2->v.k_size - 
			srf2->order[1];
		srf2->s_size[1] = srf2->u.k_size - 
			srf2->order[0];

		srf2->ctl_points = (fastf_t *)
			bu_malloc( sizeof(fastf_t) * srf2->s_size[0] *
				srf2->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf2->pt_type),
				"rt_nurb_s_split: srf2 row mesh control points");

		for( i = 0; i < srf->s_size[0]; i++)
		{
			fastf_t * old_mesh_ptr;
			fastf_t * new_mesh_ptr;

			old_mesh_ptr = &srf->ctl_points[
				i * srf->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf->pt_type)];
			new_mesh_ptr = &srf1->ctl_points[
				i * srf1->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->pt_type)];
			rt_nurb_map_oslo( oslo, old_mesh_ptr, new_mesh_ptr,
				RT_NURB_EXTRACT_COORDS( srf->pt_type ),
				RT_NURB_EXTRACT_COORDS( srf1->pt_type ),
				0, k_index, srf1->pt_type);
			new_mesh_ptr = &srf2->ctl_points[
				i * srf2->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf2->pt_type)];
			rt_nurb_map_oslo( oslo, old_mesh_ptr, new_mesh_ptr,
				RT_NURB_EXTRACT_COORDS( srf->pt_type ),
				RT_NURB_EXTRACT_COORDS( srf2->pt_type ),
				k_index, new_kv.k_size - srf2->order[0], 
				srf2->pt_type);
		}
	}
	else 
	{
		value = srf->v.knots[(srf->v.k_size -1)/2];
		
		for( i = 0; i < srf->v.k_size; i++)
			if( value == srf->v.knots[i] )
			{
				k_index = i;
				break;
			}
		if ( k_index == 0)
		{
			value = ( value + 
				srf->v.knots[ srf->v.k_size -1])
				/2.0;
			k_index = srf->order[1];
		}

		rt_nurb_kvmult(&new_kv, &srf->v, srf->order[RT_NURB_SPLIT_COL], value, res);

		oslo = ( struct oslo_mat *) 
			rt_nurb_calc_oslo( srf->order[RT_NURB_SPLIT_COL], &srf->v, &new_kv, res);

		GET_SNURB( srf1 );
		srf1->order[0]  = srf->order[0];
		srf1->order[1]  = srf->order[1];
		srf1->dir = RT_NURB_SPLIT_COL;
		rt_nurb_kvextract(&srf1->v, &new_kv, 0, k_index + srf1->order[RT_NURB_SPLIT_COL], res);
		rt_nurb_kvcopy(&srf1->u, &srf->u, res);
		
		srf1->pt_type = srf->pt_type;
		srf1->s_size[0] = srf1->v.k_size - 
			srf1->order[1];
		srf1->s_size[1] = srf1->u.k_size - 
			srf1->order[0];

		srf1->ctl_points = (fastf_t *)
			bu_malloc( sizeof(fastf_t) * srf1->s_size[0] *
				srf1->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->pt_type),
				"rt_nurb_s_split: srf1 col mesh control points");

		GET_SNURB( srf2 );
		srf2->order[0]  = srf->order[0];
		srf2->order[1]  = srf->order[1];
		srf2->dir = RT_NURB_SPLIT_COL;
		rt_nurb_kvextract(&srf2->v, &new_kv, k_index, new_kv.k_size, res);
		rt_nurb_kvcopy(&srf2->u, &srf->u, res);

		srf2->pt_type = srf->pt_type;
		srf2->s_size[0] = srf2->v.k_size - 
			srf2->order[1];
		srf2->s_size[1] = srf2->u.k_size - 
			srf2->order[0];

		srf2->ctl_points = (fastf_t *)
			bu_malloc( sizeof(fastf_t) * srf2->s_size[0] *
				srf2->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf2->pt_type),
				"rt_nurb_s_split: srf2 col mesh control points");

		for( i = 0; i < srf->s_size[1]; i++)
		{
			fastf_t * old_mesh_ptr;
			fastf_t * new_mesh_ptr;

			old_mesh_ptr = &srf->ctl_points[
				i * RT_NURB_EXTRACT_COORDS( srf->pt_type)];
			new_mesh_ptr = &srf1->ctl_points[
				i * RT_NURB_EXTRACT_COORDS( srf1->pt_type)];
			rt_nurb_map_oslo( oslo, old_mesh_ptr, new_mesh_ptr,
				srf->s_size[1] *
				RT_NURB_EXTRACT_COORDS( srf->pt_type ),
				srf1->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->pt_type ),
				0, k_index, srf1->pt_type);
			new_mesh_ptr = &srf2->ctl_points[
				i * RT_NURB_EXTRACT_COORDS( srf2->pt_type)];
			rt_nurb_map_oslo( oslo, old_mesh_ptr, new_mesh_ptr,
				srf->s_size[1] *
				RT_NURB_EXTRACT_COORDS( srf->pt_type ),
				srf2->s_size[1] *
				RT_NURB_EXTRACT_COORDS( srf2->pt_type ),
				k_index, new_kv.k_size - srf2->order[1], 
				srf2->pt_type);
		}
	}
	
	/* Arrangement will be:  head, srf1, srf2 */
	BU_LIST_APPEND( split_hd, &srf2->l );
	BU_LIST_APPEND( split_hd, &srf1->l );

	rt_nurb_free_oslo(oslo, res);
	bu_free( (char *)new_kv.knots, "rt_nurb_s_split: new kv knots");

}

/*
 *			R T _ N U R B _ C _ S P L I T
 *
 * Split a NURB curve by inserting a multiple knot and return
 * the result of the two curves.
 *
 * Algorithm
 *
 * Insert a multiple knot of the curve 
 * order.  If internal knot values exist than pick the one closest to the
 * middle and add additional knots to split at that value, otherwise
 * add multiple knots at the mid point of the knot vector. Use the new
 * knot vector to pass to the oslo refinement process and split the curve.
 * Separate the curve and return the two resulting curves.
 *
 *  The original curve is undisturbed by this operation.
 */
void
rt_nurb_c_split(struct bu_list *split_hd, const struct edge_g_cnurb *crv)
{
	struct knot_vector new_kv;
	fastf_t value;
	struct oslo_mat * oslo;
	int i;
	int k_index = 0;
	struct edge_g_cnurb * crv1, * crv2;
	int coords;

	NMG_CK_CNURB(crv);

	coords = RT_NURB_EXTRACT_COORDS( crv->pt_type ),

	value = crv->k.knots[(crv->k.k_size -1)/2];
		
	for( i = 0; i < crv->k.k_size; i++)
		if( value == crv->k.knots[i] )
		{
			k_index = i;
			break;
		}
	if ( k_index == 0)
	{
		value = ( value + 
			crv->k.knots[ crv->k.k_size -1])
			/2.0;
		k_index = crv->order;
	}

	rt_nurb_kvmult(&new_kv, &crv->k, crv->order, value, (struct resource *)NULL);

	oslo = ( struct oslo_mat *) 
		rt_nurb_calc_oslo( crv->order, &crv->k, &new_kv, (struct resource *)NULL);

	GET_CNURB( crv1 );
	crv1->order  = crv->order;
	rt_nurb_kvextract(&crv1->k, &new_kv, 0, k_index + crv->order, (struct resource *)NULL);
	crv1->pt_type = crv->pt_type;
	crv1->c_size = crv1->k.k_size - crv1->order;
	crv1->ctl_points = (fastf_t *)
		bu_malloc( sizeof(fastf_t) * crv1->c_size *
			RT_NURB_EXTRACT_COORDS( crv1->pt_type),
			"rt_nurb_c_split: crv1 control points");

	GET_CNURB( crv2 );
	crv2->order  = crv->order;
	rt_nurb_kvextract(&crv2->k, &new_kv, k_index, new_kv.k_size, (struct resource *)NULL);
	crv2->pt_type = crv->pt_type;
	crv2->c_size = crv2->k.k_size - crv2->order;
	crv2->ctl_points = (fastf_t *)
		bu_malloc( sizeof(fastf_t) * crv2->c_size *
			RT_NURB_EXTRACT_COORDS( crv2->pt_type),
			"rt_nurb_s_split: crv2 mesh control points");

	rt_nurb_map_oslo( oslo, crv->ctl_points, crv1->ctl_points,
		coords, coords, 0, k_index, crv->pt_type );

	rt_nurb_map_oslo( oslo, crv->ctl_points, crv2->ctl_points,
		coords, coords, k_index, new_kv.k_size - crv2->order, 
		crv2->pt_type );

	rt_nurb_free_oslo( oslo, (struct resource *)NULL );

	bu_free( (char *) new_kv.knots, "rt_nurb_c_split; new_kv.knots" );

	/* Arrangement will be:  head, crv1, crv2 */
	BU_LIST_APPEND( split_hd, &crv2->l );
	BU_LIST_APPEND( split_hd, &crv1->l );
}
@


11.13
log
@change conf.h to a wrapped config.h
@
text
@@


11.12
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 5
a27 1
#include "conf.h"
@


11.11
log
@copyright
@
text
@d45 1
a45 5
rt_nurb_s_split( split_hd, srf, dir, res )
struct bu_list	*split_hd;
const struct face_g_snurb 	*srf;
int		dir;
struct resource *res;
d257 1
a257 3
rt_nurb_c_split( split_hd, crv )
struct bu_list		*split_hd;
const struct edge_g_cnurb	*crv;
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 * 	This software if Copyright (C) 1990 by the United States Arym.
@


11.10.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 * 	This software if Copyright (C) 1990-2004 by the United States Army.
@


11.10.10.1
log
@merge from head
@
text
@d19 1
a19 1
 * 	This software if Copyright (C) 1990-2004 by the United States Army.
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d45 5
a49 1
rt_nurb_s_split(struct bu_list *split_hd, const struct face_g_snurb *srf, int dir, struct resource *res)
d261 3
a263 1
rt_nurb_c_split(struct bu_list *split_hd, const struct edge_g_cnurb *crv)
@


11.10.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 * 	This software if Copyright (C) 1990-2004 by the United States Army.
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d45 5
a49 1
rt_nurb_s_split(struct bu_list *split_hd, const struct face_g_snurb *srf, int dir, struct resource *res)
d261 3
a263 1
rt_nurb_c_split(struct bu_list *split_hd, const struct edge_g_cnurb *crv)
@


11.8
log
@CONST to const
@
text
@d45 1
a45 5
rt_nurb_s_split( split_hd, srf, dir, res )
struct bu_list	*split_hd;
const struct face_g_snurb 	*srf;
int		dir;
struct resource *res;
d257 1
a257 3
rt_nurb_c_split( split_hd, crv )
struct bu_list		*split_hd;
const struct edge_g_cnurb	*crv;
@


11.7
log
@Eliminated pmalloc (a failed experiment)
@
text
@d47 1
a47 1
CONST struct face_g_snurb 	*srf;
d263 1
a263 1
CONST struct edge_g_cnurb	*crv;
@


11.6
log
@
sed4
@
text
@d96 1
a96 8
		if( res )
			srf1->ctl_points = (fastf_t *)
			rt_pmalloc( sizeof(fastf_t) * srf1->s_size[0] *
				srf1->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->pt_type),
				&res->re_pmem);
		else
			srf1->ctl_points = (fastf_t *)
d115 1
a115 8
		if( res )
			srf2->ctl_points = (fastf_t *)
			rt_pmalloc( sizeof(fastf_t) * srf2->s_size[0] *
				srf2->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf2->pt_type),
				&res->re_pmem);
		else
			srf2->ctl_points = (fastf_t *)
d182 1
a182 8
		if( res )
			srf1->ctl_points = (fastf_t *)
			rt_pmalloc( sizeof(fastf_t) * srf1->s_size[0] *
				srf1->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->pt_type),
				&res->re_pmem);
		else
			srf1->ctl_points = (fastf_t *)
d201 1
a201 8
		if( res )
			srf2->ctl_points = (fastf_t *)
			rt_pmalloc( sizeof(fastf_t) * srf2->s_size[0] *
				srf2->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf2->pt_type),
				&res->re_pmem);
		else
			srf2->ctl_points = (fastf_t *)
d239 1
a239 4
	if( res )
		rt_pfree( (char *)new_kv.knots, &res->re_pmem);
	else
		bu_free( (char *)new_kv.knots, "rt_nurb_s_split: new kv knots");
@


11.6.2.1
log
@Eliminated pmalloc (a failed experiment)
@
text
@d96 8
a103 1
		srf1->ctl_points = (fastf_t *)
d122 8
a129 1
		srf2->ctl_points = (fastf_t *)
d196 8
a203 1
		srf1->ctl_points = (fastf_t *)
d222 8
a229 1
		srf2->ctl_points = (fastf_t *)
d267 4
a270 1
	bu_free( (char *)new_kv.knots, "rt_nurb_s_split: new kv knots");
@


11.5
log
@rt_pmalloc
@
text
@d104 1
a104 1
			rt_malloc( sizeof(fastf_t) * srf1->s_size[0] *
d130 1
a130 1
			rt_malloc( sizeof(fastf_t) * srf2->s_size[0] *
d204 1
a204 1
			rt_malloc( sizeof(fastf_t) * srf1->s_size[0] *
d230 1
a230 1
			rt_malloc( sizeof(fastf_t) * srf2->s_size[0] *
d270 1
a270 1
		rt_free( (char *)new_kv.knots, "rt_nurb_s_split: new kv knots");
d335 1
a335 1
		rt_malloc( sizeof(fastf_t) * crv1->c_size *
d345 1
a345 1
		rt_malloc( sizeof(fastf_t) * crv2->c_size *
d358 1
a358 1
	rt_free( (char *) new_kv.knots, "rt_nurb_c_split; new_kv.knots" );
@


11.4
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d98 1
a98 1
			pmalloc( sizeof(fastf_t) * srf1->s_size[0] *
d124 1
a124 1
			pmalloc( sizeof(fastf_t) * srf2->s_size[0] *
d198 1
a198 1
			pmalloc( sizeof(fastf_t) * srf1->s_size[0] *
d224 1
a224 1
			pmalloc( sizeof(fastf_t) * srf2->s_size[0] *
d268 1
a268 1
		pfree( (char *)new_kv.knots, &res->re_pmem);
@


11.3
log
@libbu
@
text
@d45 1
a45 1
rt_nurb_s_split( split_hd, srf, dir )
d49 1
d78 1
a78 1
		rt_nurb_kvmult( &new_kv, &srf->u, srf->order[0], value);
d81 1
a81 1
			rt_nurb_calc_oslo( srf->order[RT_NURB_SPLIT_ROW], &srf->u, &new_kv);
d87 2
a88 2
		rt_nurb_kvextract(&srf1->u, &new_kv, 0, k_index + srf1->order[0]);
		rt_nurb_kvcopy(&srf1->v, &srf->v);
d96 8
a103 1
		srf1->ctl_points = (fastf_t *)
d113 2
a114 2
		rt_nurb_kvextract(&srf2->u, &new_kv, k_index, new_kv.k_size);
		rt_nurb_kvcopy(&srf2->v, &srf->v);
d122 8
a129 1
		srf2->ctl_points = (fastf_t *)
d178 1
a178 1
		rt_nurb_kvmult(&new_kv, &srf->v, srf->order[RT_NURB_SPLIT_COL], value);
d181 1
a181 1
			rt_nurb_calc_oslo( srf->order[RT_NURB_SPLIT_COL], &srf->v, &new_kv);
d187 2
a188 2
		rt_nurb_kvextract(&srf1->v, &new_kv, 0, k_index + srf1->order[RT_NURB_SPLIT_COL]);
		rt_nurb_kvcopy(&srf1->u, &srf->u);
d196 8
a203 1
		srf1->ctl_points = (fastf_t *)
d213 2
a214 2
		rt_nurb_kvextract(&srf2->v, &new_kv, k_index, new_kv.k_size);
		rt_nurb_kvcopy(&srf2->u, &srf->u);
d222 8
a229 1
		srf2->ctl_points = (fastf_t *)
d266 6
a271 2
	rt_nurb_free_oslo(oslo);
	rt_free( (char *)new_kv.knots, "rt_nurb_s_split: new kv knots");
d324 1
a324 1
	rt_nurb_kvmult(&new_kv, &crv->k, crv->order, value);
d327 1
a327 1
		rt_nurb_calc_oslo( crv->order, &crv->k, &new_kv);
d331 1
a331 1
	rt_nurb_kvextract(&crv1->k, &new_kv, 0, k_index + crv->order);
d341 1
a341 1
	rt_nurb_kvextract(&crv2->k, &new_kv, k_index, new_kv.k_size);
d356 1
a356 1
	rt_nurb_free_oslo( oslo );
@


11.2
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d46 1
a46 1
struct rt_list	*split_hd;
d234 2
a235 2
	RT_LIST_APPEND( split_hd, &srf2->l );
	RT_LIST_APPEND( split_hd, &srf1->l );
d260 1
a260 1
struct rt_list		*split_hd;
d328 2
a329 2
	RT_LIST_APPEND( split_hd, &crv2->l );
	RT_LIST_APPEND( split_hd, &crv1->l );
@


11.1
log
@Release_4.4
@
text
@d47 1
a47 1
CONST struct snurb 	*srf;
d55 1
a55 1
	struct snurb * srf1, * srf2;
d61 1
a61 1
		value = srf->u_knots.knots[(srf->u_knots.k_size -1)/2];
d63 2
a64 2
		for( i = 0; i < srf->u_knots.k_size; i++)
			if( value == srf->u_knots.knots[i] )
d72 1
a72 1
				srf->u_knots.knots[ srf->u_knots.k_size -1])
d77 1
a77 1
		rt_nurb_kvmult( &new_kv, &srf->u_knots, srf->order[0], value);
d80 1
a80 1
			rt_nurb_calc_oslo( srf->order[RT_NURB_SPLIT_ROW], &srf->u_knots, &new_kv);
d86 2
a87 2
		rt_nurb_kvextract(&srf1->u_knots, &new_kv, 0, k_index + srf1->order[0]);
		rt_nurb_kvcopy(&srf1->v_knots, &srf->v_knots);
d90 1
a90 1
		srf1->s_size[0] = srf1->v_knots.k_size - 
d92 1
a92 1
		srf1->s_size[1] = srf1->u_knots.k_size - 
d105 2
a106 2
		rt_nurb_kvextract(&srf2->u_knots, &new_kv, k_index, new_kv.k_size);
		rt_nurb_kvcopy(&srf2->v_knots, &srf->v_knots);
d109 1
a109 1
		srf2->s_size[0] = srf2->v_knots.k_size - 
d111 1
a111 1
		srf2->s_size[1] = srf2->u_knots.k_size - 
d147 1
a147 1
		value = srf->v_knots.knots[(srf->v_knots.k_size -1)/2];
d149 2
a150 2
		for( i = 0; i < srf->v_knots.k_size; i++)
			if( value == srf->v_knots.knots[i] )
d158 1
a158 1
				srf->v_knots.knots[ srf->v_knots.k_size -1])
d163 1
a163 1
		rt_nurb_kvmult(&new_kv, &srf->v_knots, srf->order[RT_NURB_SPLIT_COL], value);
d166 1
a166 1
			rt_nurb_calc_oslo( srf->order[RT_NURB_SPLIT_COL], &srf->v_knots, &new_kv);
d172 2
a173 2
		rt_nurb_kvextract(&srf1->v_knots, &new_kv, 0, k_index + srf1->order[RT_NURB_SPLIT_COL]);
		rt_nurb_kvcopy(&srf1->u_knots, &srf->u_knots);
d176 1
a176 1
		srf1->s_size[0] = srf1->v_knots.k_size - 
d178 1
a178 1
		srf1->s_size[1] = srf1->u_knots.k_size - 
d191 2
a192 2
		rt_nurb_kvextract(&srf2->v_knots, &new_kv, k_index, new_kv.k_size);
		rt_nurb_kvcopy(&srf2->u_knots, &srf->u_knots);
d195 1
a195 1
		srf2->s_size[0] = srf2->v_knots.k_size - 
d197 1
a197 1
		srf2->s_size[1] = srf2->u_knots.k_size - 
d261 1
a261 1
CONST struct cnurb	*crv;
d268 1
a268 1
	struct cnurb * crv1, * crv2;
d275 1
a275 1
	value = crv->knot.knots[(crv->knot.k_size -1)/2];
d277 2
a278 2
	for( i = 0; i < crv->knot.k_size; i++)
		if( value == crv->knot.knots[i] )
d286 1
a286 1
			crv->knot.knots[ crv->knot.k_size -1])
d291 1
a291 1
	rt_nurb_kvmult(&new_kv, &crv->knot, crv->order, value);
d294 1
a294 1
		rt_nurb_calc_oslo( crv->order, &crv->knot, &new_kv);
d298 1
a298 1
	rt_nurb_kvextract(&crv1->knot, &new_kv, 0, k_index + crv->order);
d300 1
a300 1
	crv1->c_size = crv1->knot.k_size - crv1->order;
d308 1
a308 1
	rt_nurb_kvextract(&crv2->knot, &new_kv, k_index, new_kv.k_size);
d310 1
a310 1
	crv2->c_size = crv2->knot.k_size - crv2->order;
@


11.1.1.1
log
@Release_4.5
@
text
@d45 3
a47 3
rt_nurb_s_split( split_hd, srf, dir, res )
struct bu_list	*split_hd;
CONST struct face_g_snurb 	*srf;
a48 1
struct resource *res;
d55 1
a55 1
	struct face_g_snurb * srf1, * srf2;
d61 1
a61 1
		value = srf->u.knots[(srf->u.k_size -1)/2];
d63 2
a64 2
		for( i = 0; i < srf->u.k_size; i++)
			if( value == srf->u.knots[i] )
d72 1
a72 1
				srf->u.knots[ srf->u.k_size -1])
d77 1
a77 1
		rt_nurb_kvmult( &new_kv, &srf->u, srf->order[0], value, res);
d80 1
a80 1
			rt_nurb_calc_oslo( srf->order[RT_NURB_SPLIT_ROW], &srf->u, &new_kv, res);
d86 2
a87 2
		rt_nurb_kvextract(&srf1->u, &new_kv, 0, k_index + srf1->order[0], res);
		rt_nurb_kvcopy(&srf1->v, &srf->v, res);
d90 1
a90 1
		srf1->s_size[0] = srf1->v.k_size - 
d92 1
a92 1
		srf1->s_size[1] = srf1->u.k_size - 
d95 1
a95 8
		if( res )
			srf1->ctl_points = (fastf_t *)
			rt_pmalloc( sizeof(fastf_t) * srf1->s_size[0] *
				srf1->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->pt_type),
				&res->re_pmem);
		else
			srf1->ctl_points = (fastf_t *)
d105 2
a106 2
		rt_nurb_kvextract(&srf2->u, &new_kv, k_index, new_kv.k_size, res);
		rt_nurb_kvcopy(&srf2->v, &srf->v, res);
d109 1
a109 1
		srf2->s_size[0] = srf2->v.k_size - 
d111 1
a111 1
		srf2->s_size[1] = srf2->u.k_size - 
d114 1
a114 8
		if( res )
			srf2->ctl_points = (fastf_t *)
			rt_pmalloc( sizeof(fastf_t) * srf2->s_size[0] *
				srf2->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf2->pt_type),
				&res->re_pmem);
		else
			srf2->ctl_points = (fastf_t *)
d147 1
a147 1
		value = srf->v.knots[(srf->v.k_size -1)/2];
d149 2
a150 2
		for( i = 0; i < srf->v.k_size; i++)
			if( value == srf->v.knots[i] )
d158 1
a158 1
				srf->v.knots[ srf->v.k_size -1])
d163 1
a163 1
		rt_nurb_kvmult(&new_kv, &srf->v, srf->order[RT_NURB_SPLIT_COL], value, res);
d166 1
a166 1
			rt_nurb_calc_oslo( srf->order[RT_NURB_SPLIT_COL], &srf->v, &new_kv, res);
d172 2
a173 2
		rt_nurb_kvextract(&srf1->v, &new_kv, 0, k_index + srf1->order[RT_NURB_SPLIT_COL], res);
		rt_nurb_kvcopy(&srf1->u, &srf->u, res);
d176 1
a176 1
		srf1->s_size[0] = srf1->v.k_size - 
d178 1
a178 1
		srf1->s_size[1] = srf1->u.k_size - 
d181 1
a181 8
		if( res )
			srf1->ctl_points = (fastf_t *)
			rt_pmalloc( sizeof(fastf_t) * srf1->s_size[0] *
				srf1->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->pt_type),
				&res->re_pmem);
		else
			srf1->ctl_points = (fastf_t *)
d191 2
a192 2
		rt_nurb_kvextract(&srf2->v, &new_kv, k_index, new_kv.k_size, res);
		rt_nurb_kvcopy(&srf2->u, &srf->u, res);
d195 1
a195 1
		srf2->s_size[0] = srf2->v.k_size - 
d197 1
a197 1
		srf2->s_size[1] = srf2->u.k_size - 
d200 1
a200 8
		if( res )
			srf2->ctl_points = (fastf_t *)
			rt_pmalloc( sizeof(fastf_t) * srf2->s_size[0] *
				srf2->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf2->pt_type),
				&res->re_pmem);
		else
			srf2->ctl_points = (fastf_t *)
d234 2
a235 8
	BU_LIST_APPEND( split_hd, &srf2->l );
	BU_LIST_APPEND( split_hd, &srf1->l );

	rt_nurb_free_oslo(oslo, res);
	if( res )
		rt_pfree( (char *)new_kv.knots, &res->re_pmem);
	else
		rt_free( (char *)new_kv.knots, "rt_nurb_s_split: new kv knots");
d237 2
d260 2
a261 2
struct bu_list		*split_hd;
CONST struct edge_g_cnurb	*crv;
d268 1
a268 1
	struct edge_g_cnurb * crv1, * crv2;
d275 1
a275 1
	value = crv->k.knots[(crv->k.k_size -1)/2];
d277 2
a278 2
	for( i = 0; i < crv->k.k_size; i++)
		if( value == crv->k.knots[i] )
d286 1
a286 1
			crv->k.knots[ crv->k.k_size -1])
d291 1
a291 1
	rt_nurb_kvmult(&new_kv, &crv->k, crv->order, value, (struct resource *)NULL);
d294 1
a294 1
		rt_nurb_calc_oslo( crv->order, &crv->k, &new_kv, (struct resource *)NULL);
d298 1
a298 1
	rt_nurb_kvextract(&crv1->k, &new_kv, 0, k_index + crv->order, (struct resource *)NULL);
d300 1
a300 1
	crv1->c_size = crv1->k.k_size - crv1->order;
d308 1
a308 1
	rt_nurb_kvextract(&crv2->k, &new_kv, k_index, new_kv.k_size, (struct resource *)NULL);
d310 1
a310 1
	crv2->c_size = crv2->k.k_size - crv2->order;
d323 1
a323 1
	rt_nurb_free_oslo( oslo, (struct resource *)NULL );
d328 2
a329 2
	BU_LIST_APPEND( split_hd, &crv2->l );
	BU_LIST_APPEND( split_hd, &crv1->l );
@


10.8
log
@Variable uninitialized.
@
text
@@


10.7
log
@Added include of conf.h
@
text
@d54 1
a54 1
	int k_index;
d267 1
a267 1
	int k_index;
@


10.6
log
@Changed lists to use rt_list structures
Made some args CONST where appropriate
Switched to GET_CNURB() macros
Added calls to NMG_CK_SNURB()
@
text
@d23 2
@


10.5
log
@fixed memory leadk that was pointed out by mike
@
text
@d1 2
a2 1
/*	 	N U R B _ S P L I T . C
d26 2
d39 2
d42 5
a46 5

struct snurb *
rt_nurb_s_split( srf, dir)
struct snurb * srf;
int dir;
d55 2
d80 1
a80 2
		srf1 = (struct snurb *) rt_malloc( sizeof( struct snurb),
			"rt_nurb_s_split: row snurb struct");
d99 1
a99 2
		srf2 = (struct snurb *) rt_malloc( sizeof( struct snurb),
			"rt_nurb_s_split: row snurb struct");
d166 1
a166 2
		srf1 = (struct snurb *) rt_malloc( sizeof( struct snurb),
			"rt_nurb_s_split: col snurb struct");
d185 1
a185 2
		srf2 = (struct snurb *) rt_malloc( sizeof( struct snurb),
			"rt_nurb_s_split: col snurb struct");
d231 3
a233 2
	srf1->next = srf2;
	srf2->next = (struct snurb *)0;
a236 2

	return (struct snurb *) srf1;
d239 3
a241 1
/* rt_nurb_c_split()
d253 2
d256 4
a259 4

struct cnurb *
rt_nurb_c_split( crv)
struct cnurb * crv;
d269 2
d294 1
a294 3
	crv1 = (struct cnurb *) rt_malloc( sizeof( struct cnurb),
		"rt_nurb_c_split: cnurb struct");

d304 1
a304 3
	crv2 = (struct cnurb *) rt_malloc( sizeof( struct cnurb),
		"rt_nurb_c_split: crv2 cnurb struct");

d325 3
a327 2
	crv1->next = crv2;
	return (struct cnurb *) crv1;
@


10.4
log
@Control polygon/mesh is now just part of the cnurb/snurb structures,
rather than being a separate structure of their own.
@
text
@d319 1
a319 1
	/* XXX Who frees new_kv.knots */
@


10.3
log
@Modifications due to data structure revisions:  mesh and knots are no
longer pointers, but in-place structures.
@
text
@d81 2
a82 2
		srf1->mesh.pt_type = srf->mesh.pt_type;
		srf1->mesh.s_size[0] = srf1->v_knots.k_size - 
d84 1
a84 1
		srf1->mesh.s_size[1] = srf1->u_knots.k_size - 
d87 4
a90 4
		srf1->mesh.ctl_points = (fastf_t *)
			rt_malloc( sizeof(fastf_t) * srf1->mesh.s_size[0] *
				srf1->mesh.s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->mesh.pt_type),
d101 2
a102 2
		srf2->mesh.pt_type = srf->mesh.pt_type;
		srf2->mesh.s_size[0] = srf2->v_knots.k_size - 
d104 1
a104 1
		srf2->mesh.s_size[1] = srf2->u_knots.k_size - 
d107 4
a110 4
		srf2->mesh.ctl_points = (fastf_t *)
			rt_malloc( sizeof(fastf_t) * srf2->mesh.s_size[0] *
				srf2->mesh.s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf2->mesh.pt_type),
d113 1
a113 1
		for( i = 0; i < srf->mesh.s_size[0]; i++)
d118 6
a123 6
			old_mesh_ptr = &srf->mesh.ctl_points[
				i * srf->mesh.s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf->mesh.pt_type)];
			new_mesh_ptr = &srf1->mesh.ctl_points[
				i * srf1->mesh.s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->mesh.pt_type)];
d125 6
a130 6
				RT_NURB_EXTRACT_COORDS( srf->mesh.pt_type ),
				RT_NURB_EXTRACT_COORDS( srf1->mesh.pt_type ),
				0, k_index, srf1->mesh.pt_type);
			new_mesh_ptr = &srf2->mesh.ctl_points[
				i * srf2->mesh.s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf2->mesh.pt_type)];
d132 2
a133 2
				RT_NURB_EXTRACT_COORDS( srf->mesh.pt_type ),
				RT_NURB_EXTRACT_COORDS( srf2->mesh.pt_type ),
d135 1
a135 1
				srf2->mesh.pt_type);
d169 2
a170 2
		srf1->mesh.pt_type = srf->mesh.pt_type;
		srf1->mesh.s_size[0] = srf1->v_knots.k_size - 
d172 1
a172 1
		srf1->mesh.s_size[1] = srf1->u_knots.k_size - 
d175 4
a178 4
		srf1->mesh.ctl_points = (fastf_t *)
			rt_malloc( sizeof(fastf_t) * srf1->mesh.s_size[0] *
				srf1->mesh.s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->mesh.pt_type),
d189 2
a190 2
		srf2->mesh.pt_type = srf->mesh.pt_type;
		srf2->mesh.s_size[0] = srf2->v_knots.k_size - 
d192 1
a192 1
		srf2->mesh.s_size[1] = srf2->u_knots.k_size - 
d195 4
a198 4
		srf2->mesh.ctl_points = (fastf_t *)
			rt_malloc( sizeof(fastf_t) * srf2->mesh.s_size[0] *
				srf2->mesh.s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf2->mesh.pt_type),
d201 1
a201 1
		for( i = 0; i < srf->mesh.s_size[1]; i++)
d206 4
a209 4
			old_mesh_ptr = &srf->mesh.ctl_points[
				i * RT_NURB_EXTRACT_COORDS( srf->mesh.pt_type)];
			new_mesh_ptr = &srf1->mesh.ctl_points[
				i * RT_NURB_EXTRACT_COORDS( srf1->mesh.pt_type)];
d211 7
a217 7
				srf->mesh.s_size[1] *
				RT_NURB_EXTRACT_COORDS( srf->mesh.pt_type ),
				srf1->mesh.s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->mesh.pt_type ),
				0, k_index, srf1->mesh.pt_type);
			new_mesh_ptr = &srf2->mesh.ctl_points[
				i * RT_NURB_EXTRACT_COORDS( srf2->mesh.pt_type)];
d219 4
a222 4
				srf->mesh.s_size[1] *
				RT_NURB_EXTRACT_COORDS( srf->mesh.pt_type ),
				srf2->mesh.s_size[1] *
				RT_NURB_EXTRACT_COORDS( srf2->mesh.pt_type ),
d224 1
a224 1
				srf2->mesh.pt_type);
d263 1
a263 1
	coords = RT_NURB_EXTRACT_COORDS( crv->mesh.pt_type ),
d291 5
a295 5
	crv1->mesh.pt_type = crv->mesh.pt_type;
	crv1->mesh.c_size = crv1->knot.k_size - crv1->order;
	crv1->mesh.ctl_points = (fastf_t *)
		rt_malloc( sizeof(fastf_t) * crv1->mesh.c_size *
			RT_NURB_EXTRACT_COORDS( crv1->mesh.pt_type),
d303 5
a307 5
	crv2->mesh.pt_type = crv->mesh.pt_type;
	crv2->mesh.c_size = crv2->knot.k_size - crv2->order;
	crv2->mesh.ctl_points = (fastf_t *)
		rt_malloc( sizeof(fastf_t) * crv2->mesh.c_size *
			RT_NURB_EXTRACT_COORDS( crv2->mesh.pt_type),
d310 2
a311 2
	rt_nurb_map_oslo( oslo, crv->mesh.ctl_points, crv1->mesh.ctl_points,
		coords, coords, 0, k_index, crv->mesh.pt_type );
d313 1
a313 1
	rt_nurb_map_oslo( oslo, crv->mesh.ctl_points, crv2->mesh.ctl_points,
d315 1
a315 1
		crv2->mesh.pt_type );
d319 1
a319 1
	/* XXX Who frees new_kv */
@


10.2
log
@Expanded names of manifest constants
@
text
@d43 1
a43 1
	struct knot_vector *new_kv;
d52 1
a52 1
		value = srf->u_knots->knots[(srf->u_knots->k_size -1)/2];
d54 2
a55 2
		for( i = 0; i < srf->u_knots->k_size; i++)
			if( value == srf->u_knots->knots[i] )
d63 1
a63 1
				srf->u_knots->knots[ srf->u_knots->k_size -1])
d68 1
a68 2
		new_kv = (struct knot_vector *) 
			rt_nurb_kvmult(srf->u_knots, srf->order[0], value);
d71 1
a71 1
			rt_nurb_calc_oslo( srf->order[RT_NURB_SPLIT_ROW], srf->u_knots, new_kv);
d78 2
a79 4
		srf1->u_knots = (struct knot_vector *) 
			rt_nurb_kvextract(new_kv, 0, k_index + srf1->order[0]);
		srf1->v_knots = (struct knot_vector *) 
			rt_nurb_kvcopy(srf->v_knots);
d81 2
a82 5
		srf1->mesh = (struct s_mesh *) rt_malloc( sizeof( struct s_mesh),
			"rt_nurb_s_split: srf1 s_mesh");

		srf1->mesh->pt_type = srf->mesh->pt_type;
		srf1->mesh->s_size[0] = srf1->v_knots->k_size - 
d84 1
a84 1
		srf1->mesh->s_size[1] = srf1->u_knots->k_size - 
d87 4
a90 4
		srf1->mesh->ctl_points = (fastf_t *)
			rt_malloc( sizeof(fastf_t) * srf1->mesh->s_size[0] *
				srf1->mesh->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->mesh->pt_type),
d98 2
a99 4
		srf2->u_knots = (struct knot_vector *) 
			rt_nurb_kvextract(new_kv, k_index, new_kv->k_size);
		srf2->v_knots = (struct knot_vector *) 
			rt_nurb_kvcopy(srf->v_knots);
d101 2
a102 5
		srf2->mesh = (struct s_mesh *) rt_malloc( sizeof( struct s_mesh),
			"rt_nurb_s_split: srf2 s_mesh");

		srf2->mesh->pt_type = srf->mesh->pt_type;
		srf2->mesh->s_size[0] = srf2->v_knots->k_size - 
d104 1
a104 1
		srf2->mesh->s_size[1] = srf2->u_knots->k_size - 
d107 4
a110 4
		srf2->mesh->ctl_points = (fastf_t *)
			rt_malloc( sizeof(fastf_t) * srf2->mesh->s_size[0] *
				srf2->mesh->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf2->mesh->pt_type),
d113 1
a113 1
		for( i = 0; i < srf->mesh->s_size[0]; i++)
d118 6
a123 6
			old_mesh_ptr = &srf->mesh->ctl_points[
				i * srf->mesh->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf->mesh->pt_type)];
			new_mesh_ptr = &srf1->mesh->ctl_points[
				i * srf1->mesh->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->mesh->pt_type)];
d125 6
a130 6
				RT_NURB_EXTRACT_COORDS( srf->mesh->pt_type ),
				RT_NURB_EXTRACT_COORDS( srf1->mesh->pt_type ),
				0, k_index, srf1->mesh->pt_type);
			new_mesh_ptr = &srf2->mesh->ctl_points[
				i * srf2->mesh->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf2->mesh->pt_type)];
d132 4
a135 4
				RT_NURB_EXTRACT_COORDS( srf->mesh->pt_type ),
				RT_NURB_EXTRACT_COORDS( srf2->mesh->pt_type ),
				k_index, new_kv->k_size - srf2->order[0], 
				srf2->mesh->pt_type);
d140 1
a140 1
		value = srf->v_knots->knots[(srf->v_knots->k_size -1)/2];
d142 2
a143 2
		for( i = 0; i < srf->v_knots->k_size; i++)
			if( value == srf->v_knots->knots[i] )
d151 1
a151 1
				srf->v_knots->knots[ srf->v_knots->k_size -1])
d156 1
a156 2
		new_kv = (struct knot_vector *) 
			rt_nurb_kvmult(srf->v_knots, srf->order[RT_NURB_SPLIT_COL], value);
d159 1
a159 1
			rt_nurb_calc_oslo( srf->order[RT_NURB_SPLIT_COL], srf->v_knots, new_kv);
d166 2
a167 3
		srf1->v_knots = (struct knot_vector *) 
			rt_nurb_kvextract(new_kv, 0, k_index + srf1->order[RT_NURB_SPLIT_COL]);
		srf1->u_knots = (struct knot_vector *) rt_nurb_kvcopy(srf->u_knots);
d169 2
a170 6
		srf1->mesh = (struct s_mesh *) 
			rt_malloc( sizeof( struct s_mesh),
			"rt_nurb_s_split: srf1 col s_mesh");

		srf1->mesh->pt_type = srf->mesh->pt_type;
		srf1->mesh->s_size[0] = srf1->v_knots->k_size - 
d172 1
a172 1
		srf1->mesh->s_size[1] = srf1->u_knots->k_size - 
d175 4
a178 4
		srf1->mesh->ctl_points = (fastf_t *)
			rt_malloc( sizeof(fastf_t) * srf1->mesh->s_size[0] *
				srf1->mesh->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->mesh->pt_type),
d186 2
a187 7
		srf2->v_knots = (struct knot_vector *) 
			rt_nurb_kvextract(new_kv, k_index, new_kv->k_size);
		srf2->u_knots = (struct knot_vector *) rt_nurb_kvcopy(srf->u_knots);
		
		srf2->mesh = (struct s_mesh *) 
			rt_malloc( sizeof( struct s_mesh),
			"rt_nurb_s_split: col srf2 s_mesh");
d189 2
a190 2
		srf2->mesh->pt_type = srf->mesh->pt_type;
		srf2->mesh->s_size[0] = srf2->v_knots->k_size - 
d192 1
a192 1
		srf2->mesh->s_size[1] = srf2->u_knots->k_size - 
d195 4
a198 4
		srf2->mesh->ctl_points = (fastf_t *)
			rt_malloc( sizeof(fastf_t) * srf2->mesh->s_size[0] *
				srf2->mesh->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf2->mesh->pt_type),
d201 1
a201 1
		for( i = 0; i < srf->mesh->s_size[1]; i++)
d206 4
a209 4
			old_mesh_ptr = &srf->mesh->ctl_points[
				i * RT_NURB_EXTRACT_COORDS( srf->mesh->pt_type)];
			new_mesh_ptr = &srf1->mesh->ctl_points[
				i * RT_NURB_EXTRACT_COORDS( srf1->mesh->pt_type)];
d211 7
a217 7
				srf->mesh->s_size[1] *
				RT_NURB_EXTRACT_COORDS( srf->mesh->pt_type ),
				srf1->mesh->s_size[1] * 
				RT_NURB_EXTRACT_COORDS( srf1->mesh->pt_type ),
				0, k_index, srf1->mesh->pt_type);
			new_mesh_ptr = &srf2->mesh->ctl_points[
				i * RT_NURB_EXTRACT_COORDS( srf2->mesh->pt_type)];
d219 6
a224 6
				srf->mesh->s_size[1] *
				RT_NURB_EXTRACT_COORDS( srf->mesh->pt_type ),
				srf2->mesh->s_size[1] *
				RT_NURB_EXTRACT_COORDS( srf2->mesh->pt_type ),
				k_index, new_kv->k_size - srf2->order[1], 
				srf2->mesh->pt_type);
d232 1
a232 2
	rt_free( (char *)new_kv->knots, "rt_nurb_s_split: new kv knots");
	rt_free( (char *)new_kv, "rt_nurb_s_split: new kv knot struct");
d255 1
a255 1
	struct knot_vector *new_kv;
d263 1
a263 1
	coords = RT_NURB_EXTRACT_COORDS( crv->mesh->pt_type ),
d265 1
a265 1
	value = crv->knot->knots[(crv->knot->k_size -1)/2];
d267 2
a268 2
	for( i = 0; i < crv->knot->k_size; i++)
		if( value == crv->knot->knots[i] )
d276 1
a276 1
			crv->knot->knots[ crv->knot->k_size -1])
d281 1
a281 2
	new_kv = (struct knot_vector *) 
		rt_nurb_kvmult(crv->knot, crv->order, value);
d284 1
a284 1
		rt_nurb_calc_oslo( crv->order, crv->knot, new_kv);
d290 6
a295 9
	crv1->knot = (struct knot_vector *) 
		rt_nurb_kvextract(new_kv, 0, k_index + crv->order);
	crv1->mesh = (struct c_mesh *) rt_malloc( sizeof( struct c_mesh),
		"rt_nurb_c_split: crv1 c_mesh");
	crv1->mesh->pt_type = crv->mesh->pt_type;
	crv1->mesh->c_size = crv1->knot->k_size - crv1->order;
	crv1->mesh->ctl_points = (fastf_t *)
		rt_malloc( sizeof(fastf_t) * crv1->mesh->c_size *
			RT_NURB_EXTRACT_COORDS( crv1->mesh->pt_type),
d302 6
a307 9
	crv2->knot = (struct knot_vector *) 
		rt_nurb_kvextract(new_kv, k_index, new_kv->k_size);
	crv2->mesh = (struct c_mesh *) rt_malloc( sizeof( struct c_mesh),
		"rt_nurb_split: crv2 s_mesh");
	crv2->mesh->pt_type = crv->mesh->pt_type;
	crv2->mesh->c_size = crv2->knot->k_size - crv2->order;
	crv2->mesh->ctl_points = (fastf_t *)
		rt_malloc( sizeof(fastf_t) * crv2->mesh->c_size *
			RT_NURB_EXTRACT_COORDS( crv2->mesh->pt_type),
d310 2
a311 2
	rt_nurb_map_oslo( oslo, crv->mesh->ctl_points, crv1->mesh->ctl_points,
		coords, coords, 0, k_index, crv->mesh->pt_type );
d313 3
a315 3
	rt_nurb_map_oslo( oslo, crv->mesh->ctl_points, crv2->mesh->ctl_points,
		coords, coords, k_index, new_kv->k_size - crv2->order, 
		crv2->mesh->pt_type );
d318 2
@


10.1
log
@Release_4.0
@
text
@d50 1
a50 1
	if ( dir == ROW )
d72 1
a72 1
			rt_nurb_calc_oslo( srf->order[ROW], srf->u_knots, new_kv);
d78 1
a78 1
		srf1->dir = ROW;
d96 1
a96 1
				EXTRACT_COORDS( srf1->mesh->pt_type),
d103 1
a103 1
		srf2->dir = ROW;
d121 1
a121 1
				EXTRACT_COORDS( srf2->mesh->pt_type),
d131 1
a131 1
				EXTRACT_COORDS( srf->mesh->pt_type)];
d134 1
a134 1
				EXTRACT_COORDS( srf1->mesh->pt_type)];
d136 2
a137 2
				EXTRACT_COORDS( srf->mesh->pt_type ),
				EXTRACT_COORDS( srf1->mesh->pt_type ),
d141 1
a141 1
				EXTRACT_COORDS( srf2->mesh->pt_type)];
d143 2
a144 2
				EXTRACT_COORDS( srf->mesh->pt_type ),
				EXTRACT_COORDS( srf2->mesh->pt_type ),
d168 1
a168 1
			rt_nurb_kvmult(srf->v_knots, srf->order[COL], value);
d171 1
a171 1
			rt_nurb_calc_oslo( srf->order[COL], srf->v_knots, new_kv);
d177 1
a177 1
		srf1->dir = COL;
d179 1
a179 1
			rt_nurb_kvextract(new_kv, 0, k_index + srf1->order[COL]);
d195 1
a195 1
				EXTRACT_COORDS( srf1->mesh->pt_type),
d202 1
a202 1
		srf2->dir = COL;
d220 1
a220 1
				EXTRACT_COORDS( srf2->mesh->pt_type),
d229 1
a229 1
				i * EXTRACT_COORDS( srf->mesh->pt_type)];
d231 1
a231 1
				i * EXTRACT_COORDS( srf1->mesh->pt_type)];
d234 1
a234 1
				EXTRACT_COORDS( srf->mesh->pt_type ),
d236 1
a236 1
				EXTRACT_COORDS( srf1->mesh->pt_type ),
d239 1
a239 1
				i * EXTRACT_COORDS( srf2->mesh->pt_type)];
d242 1
a242 1
				EXTRACT_COORDS( srf->mesh->pt_type ),
d244 1
a244 1
				EXTRACT_COORDS( srf2->mesh->pt_type ),
d286 1
a286 1
	coords = EXTRACT_COORDS( crv->mesh->pt_type ),
d322 1
a322 1
			EXTRACT_COORDS( crv1->mesh->pt_type),
d337 1
a337 1
			EXTRACT_COORDS( crv2->mesh->pt_type),
@


1.3
log
@fixed nurb.h
@
text
@@


1.2
log
@Minor lint
@
text
@d25 1
a25 1
#include "./nurb.h"
@


1.1
log
@Initial revision
@
text
@d254 2
a255 3
	rt_free(new_kv->knots, "rt_nurb_s_split: new kv knots");
	rt_free(new_kv, "rt_nurb_s_split: new kv knot struct");
	
@
