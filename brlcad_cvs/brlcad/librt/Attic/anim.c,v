head	11.3;
access;
symbols
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:9.2
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1;
locks; strict;
comment	@ * @;


11.3
date	99.05.27.18.51.20;	author mike;	state dead;
branches;
next	11.2;

11.2
date	95.06.03.03.03.46;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.06;	author mike;	state Rel4_4;
branches;
next	9.2;

9.2
date	89.12.31.01.24.11;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.53.45;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	88.12.30.02.34.24;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.30.53;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.05.14.00.47.28;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.32.35;	author mike;	state Rel;
branches;
next	6.4;

6.4
date	87.10.14.21.19.59;	author mike;	state Exp;
branches;
next	6.3;

6.3
date	87.10.14.21.10.17;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.09.26.07.50.25;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.55.07;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.10.38;	author mike;	state Rel;
branches;
next	1.4;

1.4
date	87.03.23.23.42.45;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	87.03.19.05.05.25;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	87.03.19.03.02.33;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.03.11.01.30.15;	author mike;	state Exp;
branches;
next	;


desc
@Animation Control routines, used before and durring the database tree walk.
@


11.3
log
@
No longer used.
@
text
@/*
 *			A N I M
 *
 *  Ray Tracing program, routines to apply animation directives.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1987 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/anim.c,v 11.2 1995/06/03 03:03:46 mike Exp $ (BRL)";
#endif

#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "raytrace.h"
#include "./debug.h"

/*
 *			R T _ F R _ A N I M
 *
 *  Release chain of animation structures
 *
 * XXX This routine is no longer used.
 * XXX Look in db_anim.c for the new versions.
 */
void
rt_fr_anim( rtip )
register struct rt_i *rtip;
{
	register struct animate *anp;
	register struct directory *dp;
	register int		i;

	/* Rooted animations */
	for( anp = rtip->rti_anroot; anp != ANIM_NULL; )  {
		register struct animate *nextanp = anp->an_forw;

		rt_free( (char *)anp->an_path, "animation path[]");
		rt_free( (char *)anp, "struct animate");
		anp = nextanp;
	}
	rtip->rti_anroot = ANIM_NULL;

	/* Node animations */
	for( i=0; i < RT_DBNHASH; i++ )  {
		dp = rtip->rti_dbip->dbi_Head[i];
		for( ; dp != DIR_NULL; dp = dp->d_forw )  {
			for( anp = dp->d_animate; anp != ANIM_NULL; )  {
				register struct animate *nextanp = anp->an_forw;

				rt_free( (char *)anp->an_path, "animation path[]");
				rt_free( (char *)anp, "struct animate");
				anp = nextanp;
			}
			dp->d_animate = ANIM_NULL;
		}
	}
}
@


11.2
log
@Removed dead code
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/anim.c,v 11.1 1995/01/04 09:56:06 mike Rel4_4 mike $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/anim.c,v 9.2 89/12/31 01:24:11 mike Exp $ (BRL)";
a29 1

a30 116
 *			R T _ A D D _ A N I M
 *
 *  Add a user-supplied animate structure to the end of the chain of such
 *  structures hanging from the directory structure of the last node of
 *  the path specifier.  When 'root' is non-zero, this matrix is
 *  located at the root of the tree itself, rather than an arc, and is
 *  stored differently.
 *
 *  In the future, might want to check to make sure that callers directory
 *  references are in the right model (rtip).
 */
int
rt_add_anim( rtip, anp, root )
struct rt_i *rtip;
register struct animate *anp;
int	root;
{
	register struct animate **headp;
	register int i;

	/* Could validate an_type here */

	for( i=0; i < anp->an_pathlen; i++ )
		if( anp->an_path[i] == DIR_NULL )
			return(-1);	/* BAD */

	anp->an_forw = ANIM_NULL;
	if( root )  {
		if( rt_g.debug&DEBUG_ANIM )
			rt_log("rt_add_anim(x%x) root\n", anp);
		headp = &(rtip->rti_anroot);
	} else {
		if( rt_g.debug&DEBUG_ANIM )
			rt_log("rt_add_anim(x%x) arc %s\n", anp,
				anp->an_path[anp->an_pathlen-1]->d_namep);
		headp = &(anp->an_path[anp->an_pathlen-1]->d_animate);
	}

	/* Append to list */
	while( *headp != ANIM_NULL )
		headp = &((*headp)->an_forw);
	*headp = anp;
	return(0);			/* OK */
}

/*
 *			R T _ D O _ A N I M
 *
 *  Perform the one animation operation.
 *  Leave results in form that additional operations can be cascaded.
 */
int
rt_do_anim( anp, stack, arc, materp )
register struct animate *anp;
mat_t	stack;
mat_t	arc;
struct mater_info	*materp;
{
	mat_t	temp;

	if( rt_g.debug&DEBUG_ANIM )
		rt_log("rt_do_anim(x%x) ", anp);
	switch( anp->an_type )  {
	case AN_MATRIX:
		if( rt_g.debug&DEBUG_ANIM )  {
			rt_log("matrix, op=%d\n", anp->an_u.anu_m.anm_op);
#if 0
			mat_print("on original arc", arc);
			mat_print("on original stack", stack);
#endif
		}
		switch( anp->an_u.anu_m.anm_op )  {
		case ANM_RSTACK:
			mat_copy( stack, anp->an_u.anu_m.anm_mat );
			break;
		case ANM_RARC:
			mat_copy( arc, anp->an_u.anu_m.anm_mat );
			break;
		case ANM_RBOTH:
			mat_copy( stack, anp->an_u.anu_m.anm_mat );
			mat_idn( arc );
			break;
		case ANM_LMUL:
			/* arc = DELTA * arc */
			mat_mul( temp, anp->an_u.anu_m.anm_mat, arc );
			mat_copy( arc, temp );
			break;
		case ANM_RMUL:
			/* arc = arc * DELTA */
			mat_mul( temp, arc, anp->an_u.anu_m.anm_mat );
			mat_copy( arc, temp );
			break;
		default:
			return(-1);		/* BAD */
		}
#if 0
		if( rt_g.debug&DEBUG_ANIM )  {
			mat_print("arc result", arc);
			mat_print("stack result", stack);
		}
#endif
		break;
	case AN_PROPERTY:
		if( rt_g.debug&DEBUG_ANIM )
			rt_log("property\n");
		break;
	default:
		if( rt_g.debug&DEBUG_ANIM )
			rt_log("unknown op\n");
		/* Print something here? */
		return(-1);			/* BAD */
	}
	return(0);				/* OK */
}

/*
d34 3
@


9.2
log
@Added some compile-time debugging, for stuborn errors.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 9.1 89/05/19 05:53:45 mike Locked $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 8.2 88/12/30 02:34:24 mike Exp $ (BRL)";
d96 1
a96 1
		if( rt_g.debug&DEBUG_ANIM )
d98 5
d127 6
@


8.2
log
@Fixed animation free stuff to match new in-core directory structure.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 8.1 88/10/05 00:30:53 mike Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 7.2 88/05/14 00:47:28 mike Exp $ (BRL)";
d147 1
d160 5
a164 3
	for( dp = rtip->rti_DirHead; dp != DIR_NULL; dp = dp->d_forw )  {
		for( anp = dp->d_animate; anp != ANIM_NULL; )  {
			register struct animate *nextanp = anp->an_forw;
d166 5
a170 3
			rt_free( (char *)anp->an_path, "animation path[]");
			rt_free( (char *)anp, "struct animate");
			anp = nextanp;
a171 1
		dp->d_animate = ANIM_NULL;
@


7.2
log
@lint fixes
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 7.1 87/11/02 23:32:35 mike Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 6.4 87/10/14 21:19:59 mike Exp $ (BRL)";
d141 1
@


6.4
log
@Added "at_root" arg to rt_add_anim
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 6.3 87/10/14 21:10:17 mike Locked $ (BRL)";
@


6.3
log
@re-fixed rooted specification.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 6.2 87/09/26 07:50:25 mike Locked $ (BRL)";
d36 2
a37 2
 *  the path specifier.  A pathlen of 0 indicates that this change is
 *  to affect the root of the tree itself, rather than an arc, and is
d44 1
a44 1
rt_add_anim( rtip, anp )
d47 1
d59 1
a59 1
	if( anp->an_pathlen <= 0 )  {
d61 1
a61 1
			rt_log("rt_add_anim(x%x) ROOT\n", anp);
d65 1
a65 1
			rt_log("rt_add_anim(x%x) leaf %s\n", anp,
@


6.2
log
@Added debugging, and corrected ROOT node case.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 6.1 87/07/11 07:55:07 mike Locked $ (BRL)";
d36 1
a36 1
 *  the path specifier.  A pathlen of 1 indicates that this change is
d58 1
a58 1
	if( anp->an_pathlen <= 1 )  {
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 5.1 87/06/24 22:10:38 mike Rel $ (BRL)";
d36 1
a36 1
 *  the path specifier.  A pathlen of 0 indicates that this change is
d58 3
a60 1
	if( anp->an_pathlen < 1 )
d62 4
a65 1
	else
d67 1
d91 2
d95 2
a96 1
/*rt_log("rt_do_anim(x%x), matrix, op=%d\n", anp, anp->an_u.anu_m.anm_op);*/
d123 2
d127 2
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 1.4 87/03/23 23:42:45 mike Exp $ (BRL)";
@


1.4
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 1.3 87/03/19 05:05:25 mike Exp $ (BRL)";
@


1.3
log
@Added code for rt_clean
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 1.2 87/03/19 03:02:33 mike Exp $ (BRL)";
d87 1
d131 1
d133 1
d142 12
@


1.2
log
@Removed debug prints
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 1.1 87/03/11 01:30:15 mike Locked $ (BRL)";
d119 20
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header$ (BRL)";
a52 2
rt_log("rt_add_anim(x%x) x%x, len=%d\n", anp, anp->an_path[0], anp->an_pathlen);
rt_log("lvl 0 = %s\n", anp->an_path[0]->d_namep);
a84 1
rt_log("rt_do_anim(x%x) type=%d\n", anp, anp->an_type);
@
