head	11.15;
access;
symbols
	ansi-20040405-merged:11.11.2.2
	postmerge-20040405-ansi:11.13
	premerge-20040404-ansi:11.12
	postmerge-autoconf:11.12
	autoconf-freeze:11.11.10.2
	premerge-autoconf:11.12
	ansi-20040316-freeze:11.11.2.1
	postmerge-20040315-windows:11.12
	premerge-20040315-windows:11.12
	windows-20040315-freeze:11.11.4.1
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.10
	phong-branch:11.11.0.8
	photonmap-branch:11.11.0.6
	rel-6-1-DP:11.11
	windows-branch:11.11.0.4
	rel-6-0-2:11.9
	ansi-branch:11.11.0.2
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.6
	offsite-5-3-pre:11.8
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.6
	rel-5-0-beta:11.5
	rel-4-5:11.4
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.15
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.14;

11.14
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.13;

11.13
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2002.08.20.17.08.07;	author jra;	state Exp;
branches
	11.11.2.1
	11.11.4.1
	11.11.10.1;
next	11.10;

11.10
date	2002.08.15.20.55.19;	author hartley;	state Exp;
branches;
next	11.9;

11.9
date	2001.04.20.22.29.54;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2000.08.21.02.02.34;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.10.23.01.46;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.06.03.01.39.15;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	98.06.25.07.46.30;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.12.01.02.49.33;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.09.20.13.01.33;	author stay;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.47;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	1.8;

1.8
date	94.11.08.03.19.03;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	94.11.08.00.02.38;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	94.11.08.00.01.39;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	94.11.05.00.25.09;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	94.08.11.01.12.38;	author gdurf;	state Exp;
branches;
next	1.3;

1.3
date	93.05.17.15.33.46;	author stay;	state Exp;
branches;
next	1.2;

1.2
date	93.05.17.13.02.27;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	93.05.17.13.01.38;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.11.2.1
date	2002.09.19.18.01.44;	author morrison;	state Exp;
branches;
next	11.11.2.2;

11.11.2.2
date	2004.03.17.21.18.55;	author morrison;	state Exp;
branches;
next	;

11.11.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.11.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	11.11.10.2;

11.11.10.2
date	2004.03.15.14.07.28;	author erikg;	state Exp;
branches;
next	;


desc
@Interpolate a set of points with a Nurb Curve
@


11.15
log
@moved to src/
@
text
@/*
 *			N U R B  _  I N T E R P . C
 *
 * nurb_interp.c - Interpolatopn routines for fitting NURB curves and
 * and surfaces to existing data.
 *			
 *
 * Author:  Paul R. Stay
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nurb_interp.c,v 11.14 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <string.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "nurb.h"


void
rt_nurb_nodes(fastf_t *nodes, const struct knot_vector *knots, int order)
{
	int i, j;
	fastf_t sum;

	for( i = 0; i < knots->k_size -order; i++)
	{

		sum = 0.0;
		
		for( j = 1; j <= order -1; j++)
		{
			sum += knots->knots[i+j];
		}
		nodes[i] = sum/(order -1);
	}
}

void
rt_nurb_interp_mat(fastf_t *imat, struct knot_vector *knots, fastf_t *nodes, int order, int dim)
{
	int i,j;
	int ptr;
	
	ptr = 0;

	for( i = 0; i < dim; i++)
	for( j = 0; j < dim; j++)
	{
		imat[ptr] = rt_nurb_basis_eval( knots, j, order, nodes[i]);
		ptr++;
	}

	imat[ptr-1] = 1.0;	
}


/*
 *			R T _ N U R B _ C I N T E R P
 *
 * main routine for interpolation of curves
 */
void
rt_nurb_cinterp(struct edge_g_cnurb *crv, int order, const fastf_t *data, int n)
{
	fastf_t * interp_mat;
	fastf_t * nodes;
	fastf_t	*local_data;

	/* Create Data memory and fill in curve structs */

	interp_mat = (fastf_t *) bu_malloc( n * n * sizeof(fastf_t),
		"rt_nurb_interp: interp_mat");

	nodes = (fastf_t *) bu_malloc( n * sizeof(fastf_t),"rt_nurb_interp:nodes");
	local_data = (fastf_t *)bu_malloc( n * 3 * sizeof(fastf_t), "rt_nurb_interp() local_data[]");

	crv->ctl_points = (fastf_t *) bu_malloc( n * 3 * sizeof(fastf_t),
		"solution");

	crv->order = order;
	crv->c_size = n;
	crv->pt_type = RT_NURB_MAKE_PT_TYPE( 3, RT_NURB_PT_XYZ, 0);

	/* First set up Curve data structs */
	/* For now we will assume that all paramerizations are uniform */

	rt_nurb_kvknot( &crv->k, order, 0.0, 1.0, (n - order), (struct resource *)NULL);
	
	/* Calculate Nodes at which the data points will be
	 * evaluated in the curve
	 */

	rt_nurb_nodes( nodes, &crv->k, order);

	/* use the node values to create the interpolation matrix
    	 * which is a diagonal matrix
	 */
	
	rt_nurb_interp_mat( interp_mat, &crv->k, nodes, order, n);

	/* Solve the system of equations to get the control points
	 * Because rt_nurb_solve needs to modify the data as it works,
	 * and it wouldn't be polite to trash our caller's data,
	 * make a local copy.
	 * This creates the final ctl_points[] array.
	 */
	bcopy( (char *)data, (char *)local_data, n * 3 * sizeof(fastf_t) );
	rt_nurb_solve( interp_mat, local_data, crv->ctl_points, n, 3);

	/* Free up node and interp_mat storage */	

	bu_free( (char *) interp_mat, "rt_nurb_cinterp: interp_mat");
	bu_free( (char *) nodes, "rt_nurb_cinterp: nodes");
	bu_free( (char *) local_data, "rt_nurb_cinterp() local_data[]");

	/* All done, The resulting crv now interpolates the data */
}

/*
 *			R T _ N U R B _ S I N T E R P
 *
 *  Interpolate the 2-D grid of data values and fit a B-spline surface to it.
 *
 *  This is done in two steps:
 *	1)  Fit a curve to the data in each row.
 *	2)  Fit a curve to the control points from step 1 in each column.
 *  The result is a mesh of control points which defines the surface.
 *
 *  Input data is assumed to be a 3-tuple of (X,Y,Z) where Z is the
 *  independent variable being interpolated to make the surface.
 */
void
rt_nurb_sinterp(struct face_g_snurb *srf, int order, const fastf_t *data, int ymax, int xmax)
                   	     
   		      
             	      		/* data[x,y] */
   		     		/* nrow = max Y */
   		     		/* ncol = max X */
{
	int	x;
	int	y;
	struct edge_g_cnurb	*crv;	/* array of cnurbs */
	fastf_t		*tmp;
	fastf_t		*cpt;	/* surface control point pointer */

	/* Build the resultant surface structure */
	srf->order[0] = srf->order[1] = order;
	srf->dir = 0;
	srf->s_size[0] = xmax;
	srf->s_size[1] = ymax;
	srf->l.magic = RT_SNURB_MAGIC;
	srf->pt_type = RT_NURB_MAKE_PT_TYPE(3,RT_NURB_PT_XYZ,RT_NURB_PT_NONRAT);

	/* the U knot vector replates to the points in a row
	 * therefore you want to determin how many cols there are
	 * similar for the V knot vector
	 */

	rt_nurb_kvknot(&srf->u, order, 0.0, 1.0, ymax - order, (struct resource *)NULL);
	rt_nurb_kvknot(&srf->v, order, 0.0, 1.0, xmax - order, (struct resource *)NULL);

	srf->ctl_points = (fastf_t *) bu_malloc(
		sizeof(fastf_t) * xmax * ymax * 3,
		"rt_nurb_sinterp() surface ctl_points[]");
	cpt = &srf->ctl_points[0];

/* _col is X, _row is Y */
#define NVAL(_col,_row)	data[((_row)*xmax+(_col))*3]

	crv = (struct edge_g_cnurb *)bu_calloc( sizeof(struct edge_g_cnurb), ymax,
		"rt_nurb_sinterp() crv[]");

	/* Interpolate the data across the rows, fitting a curve to each. */
	for( y = 0; y < ymax; y++)  {
		crv[y].l.magic = RT_CNURB_MAGIC;
		/* Build curve from from (0,y) to (xmax-1, y) */
		rt_nurb_cinterp( &crv[y], order, &NVAL(0,y), xmax );
	}
#undef NVAL

	tmp = (fastf_t *)bu_malloc( sizeof(fastf_t)*3 * ymax,
		"rt_nurb_sinterp() tmp[]");
	for( x = 0; x < xmax; x++)  {
		struct edge_g_cnurb	ncrv;

		/* copy the curve ctl points into col major format */
		for( y = 0; y < ymax; y++)  {
			VMOVE( &tmp[y*3], &crv[y].ctl_points[x*3] );
		}

		/* Interpolate the curve interpolates, giving rows of a surface */
		ncrv.l.magic = RT_CNURB_MAGIC;
		rt_nurb_cinterp( &ncrv, order, tmp, ymax);

		/* Move new curve interpolations into snurb ctl_points[] */
		for( y = 0; y < ymax*3; y++)  {
			*cpt++ = ncrv.ctl_points[y];
		}
		rt_nurb_clean_cnurb( &ncrv );
	}
	for( y = 0; y < ymax; y++)  {
		rt_nurb_clean_cnurb( &crv[y] );
	}
	bu_free( (char *)crv, "crv[]");
	bu_free( (char *)tmp, "tmp[]");
}
@


11.14
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nurb_interp.c,v 11.13 2004/04/05 08:48:58 morrison Exp $ (ARL)";
@


11.13
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d27 5
a31 1
#include "conf.h"
@


11.12
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_interp.c,v 11.11 2002/08/20 17:08:07 jra Exp $ (ARL)";
d39 1
a39 4
rt_nurb_nodes( nodes, knots, order)
fastf_t * nodes;
const struct knot_vector * knots;
int order;
d58 1
a58 6
rt_nurb_interp_mat( imat, knots, nodes, order, dim)
fastf_t * imat;
struct knot_vector * knots;
fastf_t * nodes;
int order;
int dim;
d82 1
a82 5
rt_nurb_cinterp( crv, order, data, n)
struct edge_g_cnurb	* crv;
int		order;
const fastf_t	* data;
int		n;
d152 6
a157 6
rt_nurb_sinterp( srf, order, data, ymax, xmax)
struct face_g_snurb	*srf;
int		order;
const fastf_t	*data;		/* data[x,y] */
int		ymax;		/* nrow = max Y */
int		xmax;		/* ncol = max X */
@


11.11
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1994 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_interp.c,v 11.9 2001/04/20 22:29:54 morrison Exp $ (ARL)";
@


11.11.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nurb_interp.c,v 11.12 2004/02/02 17:39:28 morrison Exp $ (ARL)";
@


11.11.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_interp.c,v 11.12 2004/02/02 17:39:28 morrison Exp $ (ARL)";
@


11.11.10.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_interp.c,v 11.11.10.1 2004/02/12 18:37:46 erikg Exp $ (ARL)";
@


11.11.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_interp.c,v 11.11 2002/08/20 17:08:07 jra Exp $ (ARL)";
d39 4
a42 1
rt_nurb_nodes(fastf_t *nodes, const struct knot_vector *knots, int order)
d61 6
a66 1
rt_nurb_interp_mat(fastf_t *imat, struct knot_vector *knots, fastf_t *nodes, int order, int dim)
d90 5
a94 1
rt_nurb_cinterp(struct edge_g_cnurb *crv, int order, const fastf_t *data, int n)
d164 6
a169 6
rt_nurb_sinterp(struct face_g_snurb *srf, int order, const fastf_t *data, int ymax, int xmax)
                   	     
   		      
             	      		/* data[x,y] */
   		     		/* nrow = max Y */
   		     		/* ncol = max X */
@


11.11.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.10
log
@Converted from K&R to ANSI C - RFH
@
text
@d39 4
a42 1
rt_nurb_nodes(fastf_t *nodes, const struct knot_vector *knots, int order)
d61 6
a66 1
rt_nurb_interp_mat(fastf_t *imat, struct knot_vector *knots, fastf_t *nodes, int order, int dim)
d90 5
a94 1
rt_nurb_cinterp(struct edge_g_cnurb *crv, int order, const fastf_t *data, int n)
d164 6
a169 6
rt_nurb_sinterp(struct face_g_snurb *srf, int order, const fastf_t *data, int ymax, int xmax)
                   	     
   		      
             	      		/* data[x,y] */
   		     		/* nrow = max Y */
   		     		/* ncol = max X */
@


11.9
log
@CONST to const
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_interp.c,v 11.8 2000/08/21 02:02:34 butler Exp $ (ARL)";
d39 1
a39 4
rt_nurb_nodes( nodes, knots, order)
fastf_t * nodes;
const struct knot_vector * knots;
int order;
d58 1
a58 6
rt_nurb_interp_mat( imat, knots, nodes, order, dim)
fastf_t * imat;
struct knot_vector * knots;
fastf_t * nodes;
int order;
int dim;
d82 1
a82 5
rt_nurb_cinterp( crv, order, data, n)
struct edge_g_cnurb	* crv;
int		order;
const fastf_t	* data;
int		n;
d152 6
a157 6
rt_nurb_sinterp( srf, order, data, ymax, xmax)
struct face_g_snurb	*srf;
int		order;
const fastf_t	*data;		/* data[x,y] */
int		ymax;		/* nrow = max Y */
int		xmax;		/* ncol = max X */
@


11.8
log
@Massive compilation warnings eliminated
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_interp.c,v 11.7 2000/07/10 23:01:46 mike Exp $ (ARL)";
d41 1
a41 1
CONST struct knot_vector * knots;
d93 1
a93 1
CONST fastf_t	* data;
d167 1
a167 1
CONST fastf_t	*data;		/* data[x,y] */
@


11.7
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_interp.c,v 11.6 1999/06/03 01:39:15 mike Exp $ (ARL)";
d30 1
@


11.6
log
@
sed4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_interp.c,v 11.5 1998/06/25 07:46:30 mike Exp $ (ARL)";
@


11.5
log
@Port to sun4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_interp.c,v 11.4 1997/09/18 20:32:45 jra Exp $ (ARL)";
d101 1
a101 1
	interp_mat = (fastf_t *) rt_malloc( n * n * sizeof(fastf_t),
d104 2
a105 2
	nodes = (fastf_t *) rt_malloc( n * sizeof(fastf_t),"rt_nurb_interp:nodes");
	local_data = (fastf_t *)rt_malloc( n * 3 * sizeof(fastf_t), "rt_nurb_interp() local_data[]");
d107 1
a107 1
	crv->ctl_points = (fastf_t *) rt_malloc( n * 3 * sizeof(fastf_t),
d142 3
a144 3
	rt_free( (char *) interp_mat, "rt_nurb_cinterp: interp_mat");
	rt_free( (char *) nodes, "rt_nurb_cinterp: nodes");
	rt_free( (char *) local_data, "rt_nurb_cinterp() local_data[]");
d192 1
a192 1
	srf->ctl_points = (fastf_t *) rt_malloc(
d200 1
a200 1
	crv = (struct edge_g_cnurb *)rt_calloc( sizeof(struct edge_g_cnurb), ymax,
d211 1
a211 1
	tmp = (fastf_t *)rt_malloc( sizeof(fastf_t)*3 * ymax,
d234 2
a235 2
	rt_free( (char *)crv, "crv[]");
	rt_free( (char *)tmp, "tmp[]");
@


11.4
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nurb_interp.c,v 11.3 1995/12/01 02:49:33 mike Exp jra $ (ARL)";
d198 1
a198 1
#define VAL(_col,_row)	data[((_row)*xmax+(_col))*3]
d207 1
a207 1
		rt_nurb_cinterp( &crv[y], order, &VAL(0,y), xmax );
d209 1
@


11.3
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/libnurb/RCS/nurb_interp.c,v 11.2 1995/09/20 13:01:33 stay Exp $ (ARL)";
d117 1
a117 1
	rt_nurb_kvknot( &crv->k, order, 0.0, 1.0, (n - order));
d189 2
a190 2
	rt_nurb_kvknot(&srf->u, order, 0.0, 1.0, ymax - order);
	rt_nurb_kvknot(&srf->v, order, 0.0, 1.0, xmax - order);
@


11.2
log
@fixed a swap problem with the u knots and v knots so that
the u knots relate to the points in a row, and the v knots
relate to the points in a col.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/libnurb/RCS/nurb_interp.c,v 11.1 1995/01/04 09:53:47 mike Rel4_4 stay $ (ARL)";
d90 1
a90 1
struct cnurb	* crv;
d117 1
a117 1
	rt_nurb_kvknot( &crv->knot, order, 0.0, 1.0, (n - order));
d123 1
a123 1
	rt_nurb_nodes( nodes, &crv->knot, order);
d129 1
a129 1
	rt_nurb_interp_mat( interp_mat, &crv->knot, nodes, order, n);
d164 1
a164 1
struct snurb	*srf;
d172 1
a172 1
	struct cnurb	*crv;	/* array of cnurbs */
d189 2
a190 2
	rt_nurb_kvknot(&srf->u_knots, order, 0.0, 1.0, ymax - order);
	rt_nurb_kvknot(&srf->v_knots, order, 0.0, 1.0, xmax - order);
d200 1
a200 1
	crv = (struct cnurb *)rt_calloc( sizeof(struct cnurb), ymax,
d213 1
a213 1
		struct cnurb	ncrv;
@


11.1
log
@Release_4.4
@
text
@d2 1
a2 1
 *			N U R B  _ C I N T E R P . C
d4 2
a5 2
 * nurb_interp.c - Interpolatopn routines for fitting NURB curves to
 *				existing data.
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/libnurb/RCS/nurb_interp.c,v 1.8 94/11/08 03:19:03 mike Exp $ (ARL)";
d184 7
a190 2
	rt_nurb_kvknot(&srf->u_knots, order, 0.0, 1.0, xmax - order);
	rt_nurb_kvknot(&srf->v_knots, order, 0.0, 1.0, ymax - order);
@


11.1.1.1
log
@Release_4.5
@
text
@d2 1
a2 1
 *			N U R B  _  I N T E R P . C
d4 2
a5 2
 * nurb_interp.c - Interpolatopn routines for fitting NURB curves and
 * and surfaces to existing data.
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad4.5/RCS/nurb_interp.c,v 11.4 1997/09/18 20:32:45 jra Exp $ (ARL)";
d90 1
a90 1
struct edge_g_cnurb	* crv;
d117 1
a117 1
	rt_nurb_kvknot( &crv->k, order, 0.0, 1.0, (n - order), (struct resource *)NULL);
d123 1
a123 1
	rt_nurb_nodes( nodes, &crv->k, order);
d129 1
a129 1
	rt_nurb_interp_mat( interp_mat, &crv->k, nodes, order, n);
d164 1
a164 1
struct face_g_snurb	*srf;
d172 1
a172 1
	struct edge_g_cnurb	*crv;	/* array of cnurbs */
d184 2
a185 7
	/* the U knot vector replates to the points in a row
	 * therefore you want to determin how many cols there are
	 * similar for the V knot vector
	 */

	rt_nurb_kvknot(&srf->u, order, 0.0, 1.0, ymax - order, (struct resource *)NULL);
	rt_nurb_kvknot(&srf->v, order, 0.0, 1.0, xmax - order, (struct resource *)NULL);
d195 1
a195 1
	crv = (struct edge_g_cnurb *)rt_calloc( sizeof(struct edge_g_cnurb), ymax,
d208 1
a208 1
		struct edge_g_cnurb	ncrv;
@


1.8
log
@Added rt_nurb_sinterp(), to fit a surface to data points.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/libnurb/RCS/nurb_interp.c,v 1.7 94/11/08 00:02:38 mike Exp Locker: mike $ (ARL)";
@


1.7
log
@Added a CONST
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/libnurb/RCS/nurb_interp.c,v 1.6 94/11/08 00:01:39 mike Exp Locker: mike $ (ARL)";
d83 5
a87 1
/* main routine for interpolation for curves */
d92 1
a92 1
fastf_t		* data;
a94 1

d97 1
a97 1
	struct knot_vector * kv;
d105 1
a114 3

	kv = &crv->knot;

d117 1
a117 1
	rt_nurb_kvknot( kv, order, 0.0, 1.0, (n - order));
d119 1
a119 1
	/* Calcualte Nodes at which the data points will be
d123 1
a123 1
	rt_nurb_nodes( nodes, kv, order);
d129 1
a129 1
	rt_nurb_interp_mat( interp_mat, kv, nodes, order, n);
d131 8
a138 1
	/* Solve the system of equations to get the control points */
a139 2
	rt_nurb_solve( interp_mat, data, crv->ctl_points, n, 3);

d144 1
d147 83
@


1.6
log
@Bug #160, added formal declaration for argument 'order'.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d40 1
a40 1
struct knot_vector * knots;
@


1.5
log
@Irix 6
@
text
@d1 2
a2 1
/* 	N U R B  _ C I N T E R P . C
d9 13
a21 11
 * Source
 * 	VLD  Bldg 247
 * 	The US Army Ballistic Research Laboratory
 * 	Aberdeen Proving Ground, Maryland 21005
 * 
 * Date: Fri. May 14, 1993
 * 
 * Copyright Notice - 
 * 	This software is Copyright (C) 1992 by the United States Army.
 * 	All rights reserved.
 * 
d23 3
d37 46
d84 1
a84 1

d86 4
a89 3
struct cnurb * crv;
fastf_t * data;
int n;
a139 43
}

rt_nurb_nodes( nodes, knots, order)
fastf_t * nodes;
struct knot_vector * knots;
int order;
{
	int i, j;
	fastf_t sum;

	for( i = 0; i < knots->k_size -order; i++)
	{

		sum = 0.0;
		
		for( j = 1; j <= order -1; j++)
		{
			sum += knots->knots[i+j];
		}
		nodes[i] = sum/(order -1);
	}
}

rt_nurb_interp_mat( imat, knots, nodes, order, dim)
fastf_t * imat;
struct knot_vector * knots;
fastf_t * nodes;
int order;
int dim;
{
	int i,j;
	int ptr;
	
	ptr = 0;

	for( i = 0; i < dim; i++)
	for( j = 0; j < dim; j++)
	{
		imat[ptr] = rt_nurb_basis_eval( knots, j, order, nodes[i]);
		ptr++;
	}

	imat[ptr-1] = 1.0;	
@


1.4
log
@Added inlcudes
@
text
@a41 1
	int i,j;
@


1.3
log
@changed rt_nurb_nodes so that division is only done once.
@
text
@d21 4
d27 1
@


1.2
log
@*** empty log message ***
@
text
@d100 1
a100 1
			sum += knots->knots[i+j]/(order-1);
d102 1
a102 1
		nodes[i] = sum;
@


1.1
log
@Initial revision
@
text
@@
