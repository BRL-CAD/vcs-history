head	11.21;
access;
symbols
	ansi-20040405-merged:11.17.2.2
	postmerge-20040405-ansi:11.19
	premerge-20040404-ansi:11.18
	postmerge-autoconf:11.18
	autoconf-freeze:11.17.10.2
	premerge-autoconf:11.18
	ansi-20040316-freeze:11.17.2.1
	postmerge-20040315-windows:11.18
	premerge-20040315-windows:11.18
	windows-20040315-freeze:11.17.4.1
	autoconf-20031203:11.17
	autoconf-20031202:11.17
	autoconf-branch:11.17.0.10
	phong-branch:11.17.0.8
	photonmap-branch:11.17.0.6
	rel-6-1-DP:11.17
	windows-branch:11.17.0.4
	rel-6-0-2:11.15
	ansi-branch:11.17.0.2
	rel-6-0-1-branch:11.15.0.2
	hartley-6-0-post:11.16
	hartley-6-0-pre:11.15
	rel-6-0-1:11.15
	rel-6-0:11.15
	rel-5-4:11.13
	offsite-5-3-pre:11.14
	rel-5-3:11.13
	rel-5-2:11.13
	rel-5-1-branch:11.13.0.2
	rel-5-1:11.13
	rel-5-0:11.9
	rel-5-0-beta:11.8
	rel-4-5:11.8
	ctj-4-5-post:11.8
	ctj-4-5-pre:11.8
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.21
date	2004.05.21.18.07.32;	author morrison;	state dead;
branches;
next	11.20;

11.20
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.19;

11.19
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2004.02.02.17.39.22;	author morrison;	state Exp;
branches;
next	11.17;

11.17
date	2002.08.20.17.08.03;	author jra;	state Exp;
branches
	11.17.2.1
	11.17.4.1
	11.17.10.1;
next	11.16;

11.16
date	2002.08.15.20.55.14;	author hartley;	state Exp;
branches;
next	11.15;

11.15
date	2001.04.20.22.29.49;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2000.07.10.23.01.39;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.04.01.02.04.51;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.03.29.02.54.05;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.03.29.02.42.41;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.11.24.21.44.30;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.06.03.01.39.14;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	97.04.16.20.19.50;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	97.04.10.19.53.46;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.10.21.19.12.16;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.08.27.03.03.05;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.07.12.12.17.41;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.03.01.13.19.45;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.29;	author mike;	state Rel4_4;
branches;
next	1.20;

1.20
date	94.12.27.15.15.29;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	94.11.28.13.28.18;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	94.11.21.16.25.53;	author jra;	state Exp;
branches;
next	1.17;

1.17
date	94.11.08.03.55.34;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	94.10.19.13.45.45;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	94.09.20.17.42.51;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	94.09.10.04.36.36;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	94.09.02.00.31.52;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	94.08.13.09.18.38;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	94.06.27.10.35.06;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	94.06.23.17.41.29;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	94.04.12.11.35.24;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	94.04.08.16.32.26;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	94.04.07.12.48.44;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	93.12.03.03.35.21;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	93.11.18.02.09.09;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	93.07.20.22.46.35;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	93.07.20.21.27.49;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	93.07.20.15.31.59;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	93.07.20.15.30.30;	author jra;	state Exp;
branches;
next	;

11.17.2.1
date	2002.09.19.18.01.38;	author morrison;	state Exp;
branches;
next	11.17.2.2;

11.17.2.2
date	2004.03.17.21.18.52;	author morrison;	state Exp;
branches;
next	;

11.17.4.1
date	2004.03.11.23.43.40;	author morrison;	state Exp;
branches;
next	;

11.17.10.1
date	2004.02.12.18.37.43;	author erikg;	state Exp;
branches;
next	11.17.10.2;

11.17.10.2
date	2004.03.15.14.07.24;	author erikg;	state Exp;
branches;
next	;


desc
@Routines for extruding nmg's
@


11.21
log
@moved to src/
@
text
@/*		N M G _ E X T R U D E . C
 *
 *	Routines for extruding nmg's.
 *
 *  Authors -
 *	Michael Markowski
 *	John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_extrude.c,v 11.20 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <math.h>
#include <string.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"


/*
 *	V e r t s _ i n _ N M G _ L o o p
 *
 *	Count number of vertices in an NMG loop.
 */
static int
verts_in_nmg_loop(struct loopuse *lu)
{
	int		cnt;
	struct edgeuse	*eu;
	struct vertex	*v;

	/* Count number of vertices in loop. */
	cnt = 0;
	NMG_CK_LOOPUSE(lu);
	if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
		for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
			NMG_CK_EDGEUSE(eu);
			NMG_CK_EDGE(eu->e_p);
			NMG_CK_VERTEXUSE(eu->vu_p);
			NMG_CK_VERTEX(eu->vu_p->v_p);
			cnt++;
		}
	} else if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
		v = BU_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
		NMG_CK_VERTEX(v);
		cnt++;
	} else
		rt_bomb("verts_in_nmg_loop: bad loopuse\n");
	return(cnt);
}

/*
 *	V e r t s _ i n _ N M G _ F a c e
 *
 *	Count number of vertices in an NMG face.
 */
static int
verts_in_nmg_face(struct faceuse *fu)
{
	int		cnt;
	struct loopuse	*lu;

	cnt = 0;
	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
		cnt += verts_in_nmg_loop(lu);
	return(cnt);
}

/*
 *	T r a n s l a t e _ N M G _ F a c e
 *
 *	Translate a face using a vector's magnitude and direction.
 */
void
nmg_translate_face(struct faceuse *fu, const fastf_t *Vec, const struct bn_tol *tol)
{
	int		cnt,		/* Number of vertices in face. */
			cur,
			i,
			in_there;
	struct vertex	**verts;	/* List of verts in face. */
	struct edgeuse	*eu;
	struct loopuse	*lu;
	struct vertex	*v;
	struct faceuse	*fu_tmp;
	plane_t pl;
	struct bu_ptbl	edge_g_tbl;

	bu_ptbl_init( &edge_g_tbl , 64, " &edge_g_tbl ");

	cur = 0;
	cnt = verts_in_nmg_face(fu);
	verts = (struct vertex **)
		bu_malloc(cnt * sizeof(struct vertex *), "verts");
	for (i = 0; i < cnt; i++)
		verts[i] = NULL;

	/* Go through each loop and translate it. */
	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		NMG_CK_LOOPUSE(lu);
		if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
			for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				in_there = 0;
				for (i = 0; i < cur && !in_there; i++)
					if (verts[i] == eu->vu_p->v_p)
						in_there = 1;
				if (!in_there) {
					verts[cur++] = eu->vu_p->v_p;
					VADD2(eu->vu_p->v_p->vg_p->coord,
						eu->vu_p->v_p->vg_p->coord,
						Vec);
				}
			}
		} else if (BU_LIST_FIRST_MAGIC(&lu->down_hd)
			== NMG_VERTEXUSE_MAGIC) {
			v = BU_LIST_FIRST(vertexuse, &lu->down_hd)->v_p;
			NMG_CK_VERTEX(v);
			VADD2(v->vg_p->coord, v->vg_p->coord, Vec);
		} else
			rt_bomb("nmg_translate_face: bad loopuse\n");
	}

	fu_tmp = fu;
	if( fu_tmp->orientation != OT_SAME )
		fu_tmp = fu_tmp->fumate_p;

	/* Move edge geometry */
	nmg_edge_g_tabulate( &edge_g_tbl , &fu->l.magic );
	for( i=0 ; i<BU_PTBL_END( &edge_g_tbl ) ; i++ )
	{
		long *ep;
		struct edge_g_lseg *eg;

		ep = BU_PTBL_GET( &edge_g_tbl , i );
		switch( *ep )
		{
			case NMG_EDGE_G_LSEG_MAGIC:
				eg = (struct edge_g_lseg *)ep;
				NMG_CK_EDGE_G_LSEG( eg );
				VADD2( eg->e_pt , eg->e_pt , Vec );
				break;
			case NMG_EDGE_G_CNURB_MAGIC:
				/* XXX Move cnurb edge geometry??? */
				break;
		}
	}

	bu_ptbl_free( &edge_g_tbl );

	if(nmg_loop_plane_area( BU_LIST_FIRST( loopuse , &fu_tmp->lu_hd ) , pl ) < 0.0 )
	{
		rt_bomb( "nmg_translate_face: Cannot calculate plane equation for face\n" );
	}
	nmg_face_g( fu_tmp , pl );
	bu_free((char *)verts, "verts");
}

/*
 *	N M G _ E x t r u d e _ F a c e
 *
 *	Duplicate a given NMG face, move it by specified vector,
 *	and create a solid bounded by these faces.
 */
int
nmg_extrude_face(struct faceuse *fu, const fastf_t *Vec, const struct bn_tol *tol)
              	    	/* Face to extrude. */
            		    	/* Magnitude and direction of extrusion. */
                   	     	/* NMG tolerances. */
{
	fastf_t		cosang;
	int		nfaces;
	struct faceuse	*fu2, *nmg_dup_face(struct faceuse *fu, struct shell *s), **outfaces;
	int		face_count=2;
	struct loopuse	*lu, *lu2;
	plane_t		n;

#define MIKE_TOL 0.0001

	NMG_CK_FACEUSE( fu );
	BN_CK_TOL( tol );

	/* Duplicate and reverse face. */
	fu2 = nmg_dup_face(fu, fu->s_p);
	nmg_reverse_face( fu2 );
	if( fu2->orientation != OT_OPPOSITE )
		fu2 = fu2->fumate_p;

	/* Figure out which face to translate. */
	NMG_GET_FU_PLANE( n, fu );
	cosang = VDOT(Vec, n);
	if (NEAR_ZERO(cosang, MIKE_TOL))
		rt_bomb("extrude_nmg_face: extrusion cannot be parallel to face\n");
	if (cosang > 0.)
		nmg_translate_face(fu, Vec, tol);
	else if (cosang < 0.)
		nmg_translate_face(fu2->fumate_p, Vec, tol);

	nfaces = verts_in_nmg_face( fu );
	outfaces = (struct faceuse **)bu_calloc( nfaces+2 , sizeof( struct faceuse *) ,
		"nmg_extrude_face: outfaces" );

	outfaces[0] = fu;
	outfaces[1] = fu2->fumate_p;

	for( BU_LIST_FOR2(lu , lu2 , loopuse , &fu->lu_hd , &fu2->lu_hd ) )
	{
		struct edgeuse *eu,*eu2;

		NMG_CK_LOOPUSE( lu );
		NMG_CK_LOOPUSE( lu2 );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;
		if( BU_LIST_FIRST_MAGIC( &lu2->down_hd ) != NMG_EDGEUSE_MAGIC )
		{
			bu_log( "nmg_extrude_face: Original face and dup face don't match up!!\n" );
			return( -1 );
		}
		for( BU_LIST_FOR2( eu , eu2 , edgeuse , &lu->down_hd , &lu2->down_hd ) )
		{
			struct vertex	*vertlist[4];

			NMG_CK_EDGEUSE( eu );
			NMG_CK_EDGEUSE( eu2 );

			vertlist[0] = eu->vu_p->v_p;
			vertlist[1] = eu2->vu_p->v_p;
			vertlist[2] = eu2->eumate_p->vu_p->v_p;
			vertlist[3] = eu->eumate_p->vu_p->v_p;
			outfaces[face_count] = nmg_cface( fu->s_p , vertlist , 4 );
			if( nmg_calc_face_g( outfaces[face_count] ) )
			{
				bu_log( "nmg_extrude_face: failed to calculate plane eqn\n" );
				return( -1 );
			}
			face_count++;
		}

	}

	nmg_gluefaces( outfaces , face_count, tol );

	bu_free( (char *)outfaces , "nmg_extrude_face: outfaces" );

	return( 0 );
}

/*	N M G _ F I N D _ V E R T E X _ I N _ L U
 *
 * find a use of vertex v in loopuse lu
 */

struct vertexuse *
nmg_find_vertex_in_lu(const struct vertex *v, const struct loopuse *lu)
{
	struct edgeuse *eu;
	struct vertexuse *ret_vu;

	NMG_CK_VERTEX( v );
	NMG_CK_LOOPUSE( lu );

	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
	{
		struct vertexuse *vu;

		vu = BU_LIST_FIRST( vertexuse , &lu->down_hd );
		NMG_CK_VERTEXUSE( vu );

		if( vu->v_p == v )
			return( vu );
		else
			return( (struct vertexuse *)NULL );
	}

	ret_vu = (struct vertexuse *)NULL;
	for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
	{
		NMG_CK_EDGEUSE( eu );

		if( eu->vu_p->v_p == v )
		{
			ret_vu = eu->vu_p;
			break;
		}
	}

	return( ret_vu );
}

/*	N M G _ S T A R T _ N E W _ L O O P
 *
 * recursive routine to build tables of edgeuse that may be used
 * to create new loopuses. lu1 and lu2 are overlapping edgeuses
 * from the same faceuse. This is a support routine for nmg_fix_overlapping loops
 */
static void
nmg_start_new_loop(struct edgeuse *start_eu, struct loopuse *lu1, struct loopuse *lu2, struct bu_ptbl *loops)
{
	struct bu_ptbl *new_lu_tab;
	struct loopuse *this_lu;
	struct loopuse *other_lu;
	struct edgeuse *eu;
	int edges=0;
	int done=0;

	NMG_CK_EDGEUSE( start_eu );
	NMG_CK_LOOPUSE( lu1 );
	NMG_CK_LOOPUSE( lu2 );

	/* create a table to hold eu pointers for a new loop */
	new_lu_tab = (struct bu_ptbl *)bu_malloc( sizeof( struct bu_ptbl ) , "nmg_start_new_loop: new_lu_tab" );
	bu_ptbl_init( new_lu_tab , 64, " new_lu_tab ");

	/* add this table to the list of loops */
	bu_ptbl_ins( loops , (long *)new_lu_tab );

	/* put edgeuses from lu1 into new_lu_tab until a vertex shared by lu1 and lu2 is encountered
	 * or until start_eu is encountered
	 */

	this_lu = lu1;
	other_lu = lu2;
	eu = start_eu;
	while( !done )
	{
		struct edgeuse *next_eu;
		struct vertexuse *vu2;

		next_eu = BU_LIST_PNEXT_CIRC( edgeuse , &eu->l );

		/* skip this checking until we get by the first edgeuse */
		if( edges )
		{
			/* Are we back to the begining? */
			if( (eu->vu_p->v_p == start_eu->vu_p->v_p ) )
			{
				/* done with this loop */
				done = 1;
				break;
			}

			/* Are we at an intersect point? */
			vu2 = nmg_find_vertex_in_lu( eu->vu_p->v_p , other_lu );
			if( vu2 )
			{
				/* Yes, we may need to start another loop */
				struct edgeuse *eu2;
				struct loopuse *lu_tmp;
				int loop_started=0;
				int i;

				eu2 = vu2->up.eu_p;

				/* check if a loop has already been started here */
				for( i=0 ; i<BU_PTBL_END( loops ) ; i++ )
				{
					struct bu_ptbl *loop_tab;
					struct edgeuse *loop_start_eu;

					loop_tab = (struct bu_ptbl *)BU_PTBL_GET( loops , i );
					loop_start_eu = (struct edgeuse *)BU_PTBL_GET( loop_tab , 0 );
					if( loop_start_eu == eu )
					{
						loop_started = 1;
						break;
					}
				}

				/* if a loop has not already been started here
				 * start one with the current edgeuse
				 */
				if( !loop_started )
					nmg_start_new_loop( eu , this_lu , other_lu , loops );

				/* continue this loop by switching to the other loopuse */
				eu = eu2;
				next_eu = BU_LIST_PNEXT_CIRC( edgeuse , &eu->l );
				lu_tmp = this_lu;
				this_lu = other_lu;
				other_lu = lu_tmp;
			}
		}

		/* add this edgeuse to the current list */
		bu_ptbl_ins( new_lu_tab , (long *)eu );

		edges++;

		/* go to the next edgeuse */
		eu = next_eu;
	}

}

/*	N M G _ F I X _ O V E R L A P P I N G _ L O O P S
 *
 * Looks at each faceuse in the shell and checks if loopuses in that
 * faceuse overlap each other. This code can only handle faceuses that
 * have at most one OT_SAME loopuse and one OT_OPPOSITE loopuse, so
 * nmg_split_loops_into_faces is called to simplify the faceuses.
 *
 * Overlapping OT_SAME and OT_OPPOSITE loops are broken into some
 * number of OT_SAME loopuses. An edgeuse (from the OT_SAME loopuse)
 * departing from a point where the loops intersect and outside the
 * OT_OPPOSITE loopuse is found as a starting point. Edgeuses from this
 * loopuse are moved to a new loopuse until another intersect point is
 * encountered. At that point, another loop is started using the next edgeuse
 * and the current loopuse is continued by following the other loopuse.
 * this is continued until the original edgeuse is encountered.
 *
 * If overlapping loops are found, new loopsuses are created and the
 * original loopuses are killed
 */
void
nmg_fix_overlapping_loops(struct shell *s, const struct bn_tol *tol)
{
	struct faceuse *fu;
	struct edgeuse *start_eu;
	struct bu_ptbl loops;
	int i;

	NMG_CK_SHELL( s );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_fix_overlapping_loops: s = x%x\n" , s );

	/* this routine needs simple faceuses */
	nmg_split_loops_into_faces( &s->l.magic , tol );

	/* This table will contain a list of bu_ptbl's when we are
	 * finished. Each of those bu_ptbl's will be a list of
	 * edgeuses that comprise a new loop
	 */
	bu_ptbl_init( &loops , 64, " &loops ");

	/* process all faceuses in the shell */
	for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		struct loopuse *lu1,*lu2;
		struct edgeuse *eu1;
		struct edgeuse *eu;
		int inside=0;
		int outside=0;

		NMG_CK_FACEUSE( fu );

		/* don't process the same face twice */
		if( fu->orientation != OT_SAME )
			continue;

		/* This is pretty simple-minded right now, assuming that
		 * there are only two loopuses
		 */
		lu1 = BU_LIST_FIRST( loopuse , &fu->lu_hd );
		NMG_CK_LOOPUSE( lu1 );

		lu2 = BU_LIST_PNEXT( loopuse , &lu1->l );

		/* if there is only one loopuse, nothing to do */
		if( BU_LIST_IS_HEAD( lu2 , &fu->lu_hd ) )
			continue;

		NMG_CK_LOOPUSE( lu2 );


		/* if the loopuses aren't both loops af edges, nothing to do */
		if( BU_LIST_FIRST_MAGIC( &lu1->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		if( BU_LIST_FIRST_MAGIC( &lu2->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		/* if both loopuses are the same orientation, something is wrong */
		if( lu1->orientation == lu2->orientation )
		{
			bu_log( "nmg_fix_overlapping_loops: Cannot handle loops of same orientation\n" );
			nmg_pr_fu_briefly( fu , (char *)NULL );
			continue;
		}

		/* At this point we have an OT_SAME and an OT_OPPOSITE loopuses
		 * for simplicity, force lu1 to be the OT_SAME loopuse */
		if( lu1->orientation == OT_OPPOSITE && lu2->orientation == OT_SAME )
		{
			struct loopuse *lu_tmp;

			lu_tmp = lu1;
			lu1 = lu2;
			lu2 = lu_tmp;
		}
		else if( lu2->orientation != OT_OPPOSITE || lu1->orientation != OT_SAME )
		{
			bu_log( "nmg_fix_overlapping_loops: bad loop orientations %s and %s\n",
				nmg_orientation( lu1->orientation ),
				nmg_orientation( lu2->orientation ) );
			continue;
		}

		/* lu1 is OT_SAME and lu2 is OT_OPPOSITE, check for overlap */

		/* count how many vertices in lu2 are inside lu1 and outside lu1 */
		for( BU_LIST_FOR( eu , edgeuse , &lu2->down_hd ) )
		{
			struct vertexuse *vu;

			NMG_CK_EDGEUSE( eu );

			vu = eu->vu_p;

			/* ignore vertices that are shared between the loops */
			if( !nmg_find_vertex_in_lu( vu->v_p , lu1 ) )
			{
				int class;

				class = nmg_classify_pt_loop( vu->v_p->vg_p->coord , lu1 , tol );
				if( class == NMG_CLASS_AoutB )
					outside++;
				else if( class == NMG_CLASS_AinB )
					inside++;
			}
		}

		/* if we don't have vertices both inside and outside lu1,
		 * then there is no overlap
		 */
		if( !inside || !outside ) /* no overlap */
			continue;

		/* the loops overlap, now fix it */

		/* first, split the edges where the two loops cross each other */
		for( BU_LIST_FOR( eu1 , edgeuse , &lu1->down_hd ) )
		{
			vect_t v1;
			struct edgeuse *eu2;

			VSUB2( v1 , eu1->eumate_p->vu_p->v_p->vg_p->coord , eu1->vu_p->v_p->vg_p->coord );
			for( BU_LIST_FOR( eu2 , edgeuse , &lu2->down_hd ) )
			{
				vect_t v2;
				fastf_t dist[2];
				struct vertex *v=(struct vertex *)NULL;

				VSUB2( v2 , eu2->eumate_p->vu_p->v_p->vg_p->coord ,
						eu2->vu_p->v_p->vg_p->coord );

				if( bn_isect_lseg3_lseg3( dist , eu1->vu_p->v_p->vg_p->coord , v1 ,
					eu2->vu_p->v_p->vg_p->coord , v2 , tol ) >= 0 )
				{
					struct edgeuse *new_eu;

					if( dist[0]>0.0 && dist[0]<1.0 &&
					    dist[1]>=0.0 && dist[1]<=1.0 )
					{
						point_t pt;

						if( dist[1] == 0.0 )
							v = eu2->vu_p->v_p;
						else if( dist[1] == 1.0 )
							v = eu2->eumate_p->vu_p->v_p;
						else
						{
							VJOIN1( pt , eu1->vu_p->v_p->vg_p->coord , dist[0] , v1 );
							new_eu = nmg_esplit( v , eu1, 0 );
							v = new_eu->vu_p->v_p;
							if( !v->vg_p )
								nmg_vertex_gv( v , pt );
						}

						VSUB2( v1 , eu1->eumate_p->vu_p->v_p->vg_p->coord ,
								eu1->vu_p->v_p->vg_p->coord );
					}
					if( dist[1]>0.0 && dist[1]<1.0 && dist[0]>=0.0 && dist[0]<=1.0 )
					{
						point_t pt;

						if( dist[0] == 0.0 )
							v = eu1->vu_p->v_p;
						else if( dist[0] == 1.0 )
							v = eu2->eumate_p->vu_p->v_p;
						else
						{
							VJOIN1( pt , eu2->vu_p->v_p->vg_p->coord , dist[1] , v2 );
							new_eu = nmg_esplit( v , eu2, 0 );
							v = new_eu->vu_p->v_p;
							if( !v->vg_p )
								nmg_vertex_gv( v , pt );
						}

						VSUB2( v2 , eu2->eumate_p->vu_p->v_p->vg_p->coord ,
								eu2->vu_p->v_p->vg_p->coord );
					}
				}
			}
		}

		/* find a vertex that lu1 and lu2 share, where eu1 is outside lu2
		 * this will be a starting edgeuse for a new loopuse
		 */
		start_eu = (struct edgeuse *)NULL;
		for( BU_LIST_FOR( eu1 , edgeuse , &lu1->down_hd ) )
		{
			struct vertex *v1,*v2;
			point_t mid_pt;

			/* must be a shared vertex */
			if( !nmg_find_vertex_in_lu( eu1->vu_p->v_p , lu2 ) )
				continue;

			v1 = eu1->vu_p->v_p;
			NMG_CK_VERTEX( v1 );
			v2 = eu1->eumate_p->vu_p->v_p;
			NMG_CK_VERTEX( v2 );

			/* use midpoint to determine if edgeuse is in or out of lu2 */
			VBLEND2( mid_pt , 0.5 , v1->vg_p->coord , 0.5 , v2->vg_p->coord )

			if( nmg_classify_pt_loop( mid_pt , lu2 , tol ) == NMG_CLASS_AoutB )
			{
				start_eu = eu1;
				break;
			}
		}

		if( !start_eu )
		{
			bu_log( "nmg_fix_overlapping_loops: cannot find start point for new loops\n" );
			bu_log( "lu1=x%x, lu2=x%x\n" , lu1 , lu2 );
			nmg_pr_fu_briefly( fu , (char *)NULL );
			continue;;
		}

		bu_ptbl_reset( &loops );

		/* start new loop
		 * this routine will recurse, building as many tables as needed
		 */
		nmg_start_new_loop( start_eu , lu1 , lu2 , &loops );

		/* use loops table to create the new loops */
		for( i=0 ; i<BU_PTBL_END( &loops ) ; i++ )
		{
			struct loopuse *new_lu;
			struct loopuse *new_lu_mate;
			struct bu_ptbl *loop_tab;
			int eu_no;

			/* each table represents a new loopuse to be constructed */
			loop_tab = (struct bu_ptbl *)BU_PTBL_GET( &loops , i );

			/* if there are some entries in this table, make a new loopuse */
			if( BU_PTBL_END( loop_tab ) )
			{
				/* create new loop */
				new_lu = nmg_mlv( &fu->l.magic , (struct vertex *)NULL , OT_SAME );
				new_lu_mate = new_lu->lumate_p;

				/* get rid of vertex just created */
				nmg_kvu( BU_LIST_FIRST( vertexuse , &new_lu->down_hd ) );
				nmg_kvu( BU_LIST_FIRST( vertexuse , &new_lu_mate->down_hd ) );

				/* move edgeuses to new loops */
				for( eu_no=0 ; eu_no<BU_PTBL_END( loop_tab ) ; eu_no++ )
				{
					struct edgeuse *mv_eu;

					/* get edgeuse to be moved */
					mv_eu = (struct edgeuse *)BU_PTBL_GET( loop_tab , eu_no );
					NMG_CK_EDGEUSE( mv_eu );

					/* move it to new loopuse */
					BU_LIST_DEQUEUE( &mv_eu->l );
					BU_LIST_INSERT( &new_lu->down_hd , &mv_eu->l );
					mv_eu->up.lu_p = new_lu;

					/* move edgeuse mate to loopuse mate */
					BU_LIST_DEQUEUE( &mv_eu->eumate_p->l );
					BU_LIST_APPEND( &new_lu_mate->down_hd , &mv_eu->eumate_p->l );
					mv_eu->eumate_p->up.lu_p = new_lu_mate;
				}

				bu_ptbl_free( loop_tab );
				bu_free( (char *)loop_tab , "nmg_fix_overlapping_loops: loop_tab" );
			}
		}

		/* kill empty loopuses left in faceuse */
		lu1 = BU_LIST_FIRST( loopuse , &fu->lu_hd );
		while( BU_LIST_NOT_HEAD( lu1 , &fu->lu_hd ) )
		{
			struct loopuse *next_lu;

			next_lu = BU_LIST_PNEXT( loopuse , &lu1->l );

			if( BU_LIST_IS_EMPTY( &lu1->down_hd ) )
			{
				if( nmg_klu( lu1 ) )
					rt_bomb( "nmg_fix_overlapping_loops: Emptied faceuse!!\n" );
			}
			lu1 = next_lu;
		}
	}
	bu_ptbl_free( &loops );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_fix_overlapping_loops: done\n" );
}

/*	N M G _ B R E A K _ C R O S S E D _ L O O P S
 *
 *	Extrusion may create crossed loops within a face.
 *	This routine intersects each edge within a loop with every other edge
 *	in the loop
 */
void
nmg_break_crossed_loops(struct shell *is, const struct bn_tol *tol)
{
	struct faceuse *fu;

	NMG_CK_SHELL( is );
	BN_CK_TOL( tol );

	for( BU_LIST_FOR( fu , faceuse , &is->fu_hd ) )
	{
		struct loopuse *lu;

		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;

		for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			struct edgeuse *eu1,*eu2;
			vect_t v1,v2;

			NMG_CK_LOOPUSE( lu );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu1 , edgeuse , &lu->down_hd ) )
			{
				VSUB2( v1 , eu1->eumate_p->vu_p->v_p->vg_p->coord ,
						eu1->vu_p->v_p->vg_p->coord );

				eu2 = BU_LIST_PNEXT( edgeuse , eu1 );
				while( BU_LIST_NOT_HEAD( eu2 , &lu->down_hd ) )
				{
					fastf_t dist[2];

					VSUB2( v2 , eu2->eumate_p->vu_p->v_p->vg_p->coord ,
							eu2->vu_p->v_p->vg_p->coord );

					if( bn_isect_lseg3_lseg3( dist , eu1->vu_p->v_p->vg_p->coord , v1 ,
						eu2->vu_p->v_p->vg_p->coord , v2 , tol ) >= 0 )
					{
						point_t pt;
						struct edgeuse *new_eu;
						struct vertex *v=(struct vertex *)NULL;

						if( dist[0]>0.0 && dist[0]<1.0 &&
							dist[1]>=0.0 && dist[1]<=1.0 )
						{
							if( dist[1] == 0.0 )
								v = eu2->vu_p->v_p;
							else if( dist[1] == 1.0 )
								v = eu2->eumate_p->vu_p->v_p;
							else
							{
								VJOIN1( pt , eu1->vu_p->v_p->vg_p->coord ,
									dist[0] , v1 );
								v = nmg_find_pt_in_shell( is , pt , tol );
							}

							new_eu = nmg_esplit( v , eu1, 0 );
							v = new_eu->vu_p->v_p;
							if( !v->vg_p )
								nmg_vertex_gv( v , pt );

							VSUB2( v1 , eu1->eumate_p->vu_p->v_p->vg_p->coord ,
								eu1->vu_p->v_p->vg_p->coord );
						}
						if( dist[1] > 0.0 && dist[1] < 1.0 &&
							dist[0]>=0.0 && dist[0]<=1.0 )
						{
							if( dist[0] == 0.0 )
								v = eu1->vu_p->v_p;
							else if( dist[0] == 1.0 )
								v = eu1->eumate_p->vu_p->v_p;
							else
							{
								VJOIN1( pt , eu2->vu_p->v_p->vg_p->coord , dist[1] , v2 );
								v = nmg_find_pt_in_shell( is , pt , tol );
							}

							new_eu = nmg_esplit( v , eu2, 0 );
							v = new_eu->vu_p->v_p;
							if( !v->vg_p )
								nmg_vertex_gv( v , pt );
						}
					}
					eu2 = BU_LIST_PNEXT( edgeuse , eu2 );
				}
			}
		}
	}
}

/*
 *	N M G _ E X T R U D E _ C L E A N U P
 *
 *	Clean up after nmg_extrude_shell.
 *	intersects each face with every other face in the shell and
 *	makes new face boundaries at the intersections.
 *	decomposes the result into seperate shells.
 *	where faces have intersected, new shells will be created.
 *	These shells are detected and killed
 */
struct shell *
nmg_extrude_cleanup(struct shell *is, const int is_void, const struct bn_tol *tol)
{
	struct model *m;
	struct nmgregion *new_r;
	struct faceuse *fu;
	struct loopuse *lu;
	struct vertexuse *vu;
	struct nmgregion *old_r;
	struct shell *s_tmp;

	NMG_CK_SHELL( is );
	BN_CK_TOL( tol );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_extrude_cleanup( is=x%x )\n" , is );

	m = nmg_find_model( &is->l.magic );

	/* intersect each face in the shell with every other face in the same shell */
	nmg_isect_shell_self( is , tol );

	/* Extrusion may create loops that overlap */
	nmg_fix_overlapping_loops( is , tol );

	/* look for self-touching loops */
	for( BU_LIST_FOR( fu , faceuse , &is->fu_hd ) )
	{
		if( fu->orientation != OT_SAME )
			continue;

		lu = BU_LIST_LAST( loopuse , &fu->lu_hd );
		while( BU_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
		{
			struct loopuse *new_lu;
			int orientation;

			/* check this loopuse */
			while( (vu=(struct vertexuse *)nmg_loop_touches_self( lu ) ) != (struct vertexuse *)NULL )
			{
				/* Split this touching loop, but give both resulting loops
				 * the same orientation as the original. This will result
				 * in the part of the loop that needs to be discarded having
				 * an incorrect orientation with respect to the face.
				 * This incorrect orientation will be discovered later by
				 * "nmg_bad_face_normals" and will result in the undesirable
				 * portion's demise
				 */

				orientation = lu->orientation;
				new_lu = nmg_split_lu_at_vu( lu , vu );
				new_lu->orientation = orientation;
				lu->orientation = orientation;
				new_lu->lumate_p->orientation = orientation;
				lu->lumate_p->orientation = orientation;
			}

			lu = BU_LIST_PLAST( loopuse , &lu->l );
		}
	}

	nmg_rebound( m , tol );

	/* remember the nmgregion where "is" came from */
	old_r = is->r_p;

	/* make a new nmgregion , shell, and vertex */
	new_r = nmg_mrsv( m );

	/* s_tmp is the shell just created */
	s_tmp = BU_LIST_FIRST( shell , &new_r->s_hd );

	/* move our shell (is) to the new nmgregion
	 * in preparaion for nmg_decompose_shell.
	 * don't want to confuse pieces of this shell
	 * with other shells in "old_r"
	 */
	(void)nmg_mv_shell_to_region( is , new_r );

	/* kill the unused, newly created shell */
	if( nmg_ks( s_tmp ) )
		rt_bomb( "nmg_extrude_shell: Nothing got moved to new region\n" );

	/* now decompose our shell, count number of inside shells */
	if( (nmg_decompose_shell( is , tol )) < 2 )
	{
		/*  we still have only one shell */
		if( nmg_bad_face_normals( is , tol ) )
		{
			(void)nmg_ks( is );
			is = (struct shell *)NULL;
		}
		else if( is_void != -1 && nmg_shell_is_void( is ) != is_void )
		{
			(void)nmg_ks( is );
			is = (struct shell *)NULL;
		}
		else
			(void)nmg_mv_shell_to_region( is , old_r );

		nmg_kr( new_r );
		new_r = NULL;
	}
	else
	{
		/* look at each shell in "new_r" */
		s_tmp = BU_LIST_FIRST( shell , &new_r->s_hd );
		while( BU_LIST_NOT_HEAD( s_tmp , &new_r->s_hd ) )
		{
			struct shell *next_s;
			int kill_it=0;

			next_s = BU_LIST_PNEXT( shell , &s_tmp->l );

			if( nmg_bad_face_normals( s_tmp , tol ) )
				kill_it = 1;

			if( !kill_it )
			{
				if( is_void != -1 && nmg_shell_is_void( s_tmp ) != is_void )
					kill_it = 1;
			}

			if( kill_it )
			{
				/* Bad shell, kill it */
				if( nmg_ks( s_tmp ) )
				{
					nmg_kr( new_r );
					new_r = (struct nmgregion *)NULL;
					is = (struct shell *)NULL;
					break;
				}
			}
			s_tmp = next_s;
		}
	}

	if( new_r )
	{
		/* merge remaining shells in "new_r" */
		is = BU_LIST_FIRST( shell , &new_r->s_hd );

		s_tmp = BU_LIST_PNEXT( shell , &is->l );
		while( BU_LIST_NOT_HEAD( s_tmp , &new_r->s_hd ) )
		{
			struct shell *next_s;

			next_s = BU_LIST_PNEXT( shell , &s_tmp->l );

			if( s_tmp == is )
			{
				s_tmp = next_s;
				continue;
			}

			nmg_js( is , s_tmp , tol );
			s_tmp = next_s;
		}

		/* move it all back into the original nmgregion */
		if( is )
			(void)nmg_mv_shell_to_region( is , old_r );

		/* kill the temporary nmgregion */
		if( BU_LIST_NON_EMPTY( &new_r->s_hd ) )
			bu_log( "nmg_extrude_cleanup: temporary nmgregion not empty!!\n" );

		(void)nmg_kr( new_r );
	}
	return( is );
}

/*
 *	N M G _ H O L L O W _ S H E L L
 *
 *	Hollows out a shell producing a wall thickness of thickness "thick"
 *	by creating a new "inner" shell and combining the two shells.
 *
 *	If the original shell is closed, the new shell is simply
 *	merged with the original shell.  If the original shell is open, then faces
 *	are constructed along the free edges of the two shells to make a closed shell.
 *
 *	if approximate is non-zero, new vertex geometry at vertices where more than
 *	three faces intersect may be approximated by a point of minimum distance from
 *	the intersecting faces.
 *
 */
void
nmg_hollow_shell(struct shell *s, const fastf_t thick, const int approximate, const struct bn_tol *tol)
{
	struct nmgregion *new_r,*old_r;
	struct vertexuse *vu;
	struct edgeuse *eu;
	struct loopuse *lu;
	struct faceuse *fu;
	struct face_g_plane *fg_p;
	struct model *m;
	struct shell *is;	/* inside shell */
	struct shell *s_tmp;
	struct bu_ptbl shells;
	long *flags;
	long **copy_tbl;
	int shell_no;
	int is_void;
	int s_tmp_is_closed;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_extrude_shell( s=x%x , thick=%f)\n" , s , thick );

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	if( thick < 0.0 )
	{
		bu_log( "nmg_extrude_shell: thickness less than zero not allowed" );
		return;
	}

	if( thick < tol->dist )
	{
		bu_log( "nmg_extrude_shell: thickness less than tolerance not allowed" );
		return;
	}

	m = nmg_find_model( (long *)s );

	/* remember region where this shell came from */
	old_r = s->r_p;
	NMG_CK_REGION( old_r );

	/* move this shell to another region */
	new_r = nmg_mrsv( m );
	s_tmp = BU_LIST_FIRST( shell , &new_r->s_hd );
	(void)nmg_mv_shell_to_region( s , new_r );

	/* decompose this shell */
	(void)nmg_decompose_shell( s , tol );

	/* kill the extra shell created by nmg_mrsv above */
	(void)nmg_ks( s_tmp );

	/* recompute the bounding boxes */
	nmg_region_a( new_r , tol );

	/* make a list of all the shells in the new region */
	bu_ptbl_init( &shells , 64, " &shells ");
	for( BU_LIST_FOR( s_tmp , shell , &new_r->s_hd ) )
		bu_ptbl_ins( &shells , (long *)s_tmp );

	/* extrude a copy of each shell, one at a time */
	for( shell_no=0 ; shell_no<BU_PTBL_END( &shells ) ; shell_no ++ )
	{
		s_tmp = (struct shell *)BU_PTBL_GET( &shells , shell_no );

		/* first make a copy of this shell */
		is = nmg_dup_shell( s_tmp , &copy_tbl, tol );

		/* make a translation table for this model */
		flags = (long *)bu_calloc( m->maxindex , sizeof( long ) , "nmg_extrude_shell flags" );

		/* now adjust all the planes, first move them inward by distance "thick" */
		for( BU_LIST_FOR( fu , faceuse , &is->fu_hd ) )
		{
			NMG_CK_FACEUSE( fu );
			NMG_CK_FACE( fu->f_p );
			fg_p = fu->f_p->g.plane_p;
			NMG_CK_FACE_G_PLANE( fg_p );

			/* move the faces by the distance "thick" */
			if( NMG_INDEX_TEST_AND_SET( flags , fg_p ) )
			{
				if( fu->f_p->flip )
					fg_p->N[3] += thick;
				else
					fg_p->N[3] -= thick;
			}
		}

		/* Reverse the normals of all the faces */
		nmg_invert_shell( is , tol );

		is_void = nmg_shell_is_void( is );

		/* now start adjusting the vertices
		 * Use the original shell so that we can pass the original vertex to nmg_inside_vert
		 */
		for( BU_LIST_FOR( fu , faceuse , &s_tmp->fu_hd ) )
		{
			if( fu->orientation != OT_SAME )
				continue;

			for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
			{
				NMG_CK_LOOPUSE( lu );
				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
				{
					/* the vertex in a loop of one vertex
					 * must show up in an edgeuse somewhere,
					 * so don't mess with it here */
					continue;
				}
				else
				{
					for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					{
						struct vertex *new_v;

						NMG_CK_EDGEUSE( eu );
						vu = eu->vu_p;
						NMG_CK_VERTEXUSE( vu );
						new_v = NMG_INDEX_GETP( vertex , copy_tbl , vu->v_p );
						NMG_CK_VERTEX( new_v )
						if( NMG_INDEX_TEST_AND_SET( flags , new_v ) )
						{
							/* move this vertex */
							if( nmg_in_vert( new_v , approximate , tol ) )
								rt_bomb( "Failed to get a new point from nmg_inside_vert\n" );
						}
					}
				}
			}
		}

		/* recompute the bounding boxes */
		nmg_region_a( is->r_p , tol );

		nmg_vmodel( m );

		s_tmp_is_closed = !nmg_check_closed_shell( s_tmp , tol );
		if( s_tmp_is_closed )
			is = nmg_extrude_cleanup( is , is_void , tol );

		/* Inside shell is done */
		if( is )
		{
			if( s_tmp_is_closed )
			{
				if( nmg_check_closed_shell( is , tol ) )
				{
					bu_log( "nmg_extrude_shell: inside shell is not closed, calling nmg_close_shell\n" );
					nmg_close_shell( is, tol );
				}

				nmg_shell_coplanar_face_merge( is , tol , 0 );
				nmg_simplify_shell( is );

				/* now merge the inside and outside shells */
				nmg_js( s_tmp , is , tol );
			}
			else
			{
				if( !nmg_check_closed_shell( is , tol ) )
				{
					bu_log( "nmg_extrude_shell: inside shell is closed, outer isn't!!\n" );
					nmg_shell_coplanar_face_merge( is , tol , 0 );
					nmg_simplify_shell( is );
					nmg_js( s_tmp , is , tol );
				}
				else
				{
					/* connect the boundaries of the two open shells */
					nmg_open_shells_connect( s_tmp , is ,
						(const long **)copy_tbl , tol );
				}
			}
		}

		/* recompute the bounding boxes */
		nmg_region_a( s_tmp->r_p , tol );

		/* free memory */
		bu_free( (char *)flags , "nmg_extrude_shell: flags" );
		bu_free( (char *)copy_tbl , "nmg_extrude_shell: copy_tbl" );
	}

	/* put it all back together */
	for( shell_no=0 ; shell_no<BU_PTBL_END( &shells ) ; shell_no++ )
	{
		struct shell *s2;

		s2 = (struct shell *)BU_PTBL_GET( &shells , shell_no );
		if( s2 != s )
			nmg_js( s , s2 , tol );
	}

	bu_ptbl_free( &shells );

	(void)nmg_mv_shell_to_region( s , old_r );
	nmg_kr( new_r );
}

/*	N M G _ E X T R U D E _ S H E L L
 *
 * Extrudes a shell (s) by a distance (dist) in the direction
 * of the face normals if normal_ward, or the opposite direction
 * if !normal_ward.  The shell (s) is modified by adjusting the
 * plane equations for each face and calculating new vertex geometry.
 * if approximate is non-zero, new vertex geometry, for vertices
 * where more than three faces intersect, will be approximated
 * by a point with minimum distance from the intersecting faces.
 * if approximate is zero, additional faces and/or edges may be added to the shell.
 *
 * returns:
 *	a pointer to the modified shell on success
 *	NULL on failure
 */
struct shell *
nmg_extrude_shell(struct shell *s, const fastf_t dist, const int normal_ward, const int approximate, const struct bn_tol *tol)
{
	fastf_t thick;
	int along_normal;
	struct model *m;
	struct nmgregion *new_r,*old_r;
	struct shell *s_tmp,*s2;
	struct bu_ptbl shells;
	struct bu_ptbl verts;
	int shell_no;
	int failed=0;

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	if( NEAR_ZERO( dist , tol->dist ) )
	{
		bu_log( "nmg_extrude_shell: Cannot extrude a distance less than tolerance distance\n" );
		return( s );
	}

	along_normal = normal_ward;
	if( dist < 0.0 )
	{
		thick = (-dist);
		along_normal = (!normal_ward);
	}
	else
		thick = dist;

	m = nmg_find_model( &s->l.magic );
	NMG_CK_MODEL( m );

	old_r = s->r_p;
	NMG_CK_REGION( old_r );

	/* decompose this shell and extrude each piece seperately */
	new_r = nmg_mrsv( m );
	s_tmp = BU_LIST_FIRST( shell , &new_r->s_hd );
	(void)nmg_mv_shell_to_region( s , new_r );
	(void)nmg_decompose_shell( s , tol );

	/* kill the not-needed shell created by nmg_mrsv() */
	(void)nmg_ks( s_tmp );

	/* recompute the bounding boxes */
	nmg_region_a( new_r , tol );

	/* make a list of all the shells to be extruded */
	bu_ptbl_init( &shells , 64, " &shells ");
	for( BU_LIST_FOR( s_tmp , shell , &new_r->s_hd ) )
		bu_ptbl_ins( &shells , (long *)s_tmp );

	bu_ptbl_init( &verts , 64, " &verts ");

	/* extrude each shell */
	for( shell_no=0 ; shell_no < BU_PTBL_END( &shells ) ; shell_no++ )
	{
		int vert_no;
		int is_void;
		long *flags;
		struct faceuse *fu;

		s_tmp = (struct shell *)BU_PTBL_GET( &shells , shell_no );
		NMG_CK_SHELL( s_tmp );

		is_void = nmg_shell_is_void( s_tmp );

		/* make a translation table for this model */
		flags = (long *)bu_calloc( m->maxindex , sizeof( long ) , "nmg_extrude_shell flags" );

		/* now adjust all the planes, first move them by distance "thick" */
		for( BU_LIST_FOR( fu , faceuse , &s_tmp->fu_hd ) )
		{
			struct face_g_plane *fg_p;

			NMG_CK_FACEUSE( fu );
			NMG_CK_FACE( fu->f_p );
			fg_p = fu->f_p->g.plane_p;
			NMG_CK_FACE_G_PLANE( fg_p );

			/* move the faces by the distance "thick" */
			if( NMG_INDEX_TEST_AND_SET( flags , fg_p ) )
			{
				if( along_normal ^ fu->f_p->flip )
					fg_p->N[3] += thick;
				else
					fg_p->N[3] -= thick;
			}
		}

		bu_free( (char *)flags , "nmg_extrude_shell flags" );

		/* get table of vertices in this shell */
		nmg_vertex_tabulate( &verts , &s_tmp->l.magic );

		/* now move all the vertices */
		for( vert_no = 0 ; vert_no < BU_PTBL_END( &verts ) ; vert_no++ )
		{
			struct vertex *new_v;

			new_v = (struct vertex *)BU_PTBL_GET( &verts , vert_no );
			NMG_CK_VERTEX( new_v );

			if( nmg_in_vert( new_v , approximate , tol ) )
			{
				bu_log( "nmg_extrude_shell: Failed to calculate new vertex at v=x%x was ( %f %f %f )\n",
					new_v , V3ARGS( new_v->vg_p->coord ) );
				failed = 1;
				goto out;
			}
		}

		bu_ptbl_free( &verts );

		if( approximate )	/* need to recalculate plane eqns */
		{
			for( BU_LIST_FOR( fu , faceuse , &s_tmp->fu_hd ) )
			{
				struct loopuse *lu;
				int got_plane=0;

				if( fu->orientation != OT_SAME )
					continue;

				for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
				{
					fastf_t area;
					plane_t pl;

					if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
						continue;

					if( lu->orientation != OT_SAME )
						continue;

					area = nmg_loop_plane_area( lu , pl );

					if( area > 0.0 )
					{
						nmg_face_g( fu , pl );
						got_plane = 1;
						break;
					}
				}
				if( !got_plane )
				{
					bu_log( "nmg_extrude_shell: Cannot recalculate plane for face:\n" );
					nmg_pr_fu_briefly( fu , (char *)NULL );
					failed = 1;
					goto out;
				}
			}
		}

		/* recompute the bounding boxes */
		nmg_region_a( s_tmp->r_p , tol );

		(void)nmg_extrude_cleanup( s_tmp , is_void , tol );
	}

out:
	bu_ptbl_free( &shells );

	/* put it all back together */
	if( BU_LIST_NON_EMPTY( &new_r->s_hd ) )
	{
		s_tmp = BU_LIST_FIRST( shell , &new_r->s_hd );
		s2 = BU_LIST_PNEXT( shell , &s_tmp->l );
		while( BU_LIST_NOT_HEAD( s2 , &new_r->s_hd ) )
		{
			struct shell *next_s;

			next_s = BU_LIST_PNEXT( shell , &s2->l );
			nmg_js( s_tmp , s2 , tol );

			s2 = next_s;
		}
	}
	else
		s_tmp = (struct shell *)NULL;

	if( s_tmp )
		(void)nmg_mv_shell_to_region( s_tmp , old_r );

	nmg_kr( new_r );

	if( failed )
		return( (struct shell *)NULL );
	else
		return( s_tmp );
}
@


11.20
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_extrude.c,v 11.19 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.19
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d26 5
a30 1
#include "conf.h"
@


11.18
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_extrude.c,v 11.17 2002/08/20 17:08:03 jra Exp $ (ARL)";
d45 1
a45 2
verts_in_nmg_loop(lu)
struct loopuse	*lu;
d77 1
a77 2
verts_in_nmg_face(fu)
struct faceuse	*fu;
d94 1
a94 4
nmg_translate_face(fu, Vec, tol)
struct faceuse	*fu;
const vect_t		Vec;
const struct bn_tol	*tol;
d184 4
a187 4
nmg_extrude_face(fu, Vec, tol)
struct faceuse	*fu;	/* Face to extrude. */
const vect_t		Vec;	/* Magnitude and direction of extrusion. */
const struct bn_tol	*tol;	/* NMG tolerances. */
d191 1
a191 1
	struct faceuse	*fu2, *nmg_dup_face(), **outfaces;
d273 1
a273 3
nmg_find_vertex_in_lu( v , lu )
const struct vertex *v;
const struct loopuse *lu;
d316 1
a316 5
nmg_start_new_loop( start_eu , lu1 , lu2 , loops )
struct edgeuse *start_eu;
struct loopuse *lu1;
struct loopuse *lu2;
struct bu_ptbl *loops;
d434 1
a434 3
nmg_fix_overlapping_loops( s , tol )
struct shell *s;
const struct bn_tol *tol;
d735 1
a735 3
nmg_break_crossed_loops( is , tol )
struct shell *is;
const struct bn_tol *tol;
d840 1
a840 4
nmg_extrude_cleanup( is , is_void , tol )
struct shell *is;
const int is_void;
const struct bn_tol *tol;
d1028 1
a1028 5
nmg_hollow_shell( s , thick , approximate , tol )
struct shell *s;
const fastf_t thick;
const int approximate;
const struct bn_tol *tol;
d1247 1
a1247 6
nmg_extrude_shell( s , dist , normal_ward , approximate , tol )
struct shell *s;
const fastf_t dist;
const int normal_ward;
const int approximate;
const struct bn_tol *tol;
@


11.17
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_extrude.c,v 11.15 2001/04/20 22:29:49 morrison Exp $ (ARL)";
@


11.17.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_extrude.c,v 11.18 2004/02/02 17:39:22 morrison Exp $ (ARL)";
@


11.17.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_extrude.c,v 11.18 2004/02/02 17:39:22 morrison Exp $ (ARL)";
@


11.17.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_extrude.c,v 11.17.10.1 2004/02/12 18:37:43 erikg Exp $ (ARL)";
@


11.17.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_extrude.c,v 11.17 2002/08/20 17:08:03 jra Exp $ (ARL)";
d45 2
a46 1
verts_in_nmg_loop(struct loopuse *lu)
d78 2
a79 1
verts_in_nmg_face(struct faceuse *fu)
d96 4
a99 1
nmg_translate_face(struct faceuse *fu, const fastf_t *Vec, const struct bn_tol *tol)
d189 4
a192 4
nmg_extrude_face(struct faceuse *fu, const fastf_t *Vec, const struct bn_tol *tol)
              	    	/* Face to extrude. */
            		    	/* Magnitude and direction of extrusion. */
                   	     	/* NMG tolerances. */
d196 1
a196 1
	struct faceuse	*fu2, *nmg_dup_face(struct faceuse *fu, struct shell *s), **outfaces;
d278 3
a280 1
nmg_find_vertex_in_lu(const struct vertex *v, const struct loopuse *lu)
d323 5
a327 1
nmg_start_new_loop(struct edgeuse *start_eu, struct loopuse *lu1, struct loopuse *lu2, struct bu_ptbl *loops)
d445 3
a447 1
nmg_fix_overlapping_loops(struct shell *s, const struct bn_tol *tol)
d748 3
a750 1
nmg_break_crossed_loops(struct shell *is, const struct bn_tol *tol)
d855 4
a858 1
nmg_extrude_cleanup(struct shell *is, const int is_void, const struct bn_tol *tol)
d1046 5
a1050 1
nmg_hollow_shell(struct shell *s, const fastf_t thick, const int approximate, const struct bn_tol *tol)
d1269 6
a1274 1
nmg_extrude_shell(struct shell *s, const fastf_t dist, const int normal_ward, const int approximate, const struct bn_tol *tol)
@


11.17.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.16
log
@Converted from K&R to ANSI C - RFH
@
text
@d45 2
a46 1
verts_in_nmg_loop(struct loopuse *lu)
d78 2
a79 1
verts_in_nmg_face(struct faceuse *fu)
d96 4
a99 1
nmg_translate_face(struct faceuse *fu, const fastf_t *Vec, const struct bn_tol *tol)
d189 4
a192 4
nmg_extrude_face(struct faceuse *fu, const fastf_t *Vec, const struct bn_tol *tol)
              	    	/* Face to extrude. */
            		    	/* Magnitude and direction of extrusion. */
                   	     	/* NMG tolerances. */
d196 1
a196 1
	struct faceuse	*fu2, *nmg_dup_face(struct faceuse *fu, struct shell *s), **outfaces;
d278 3
a280 1
nmg_find_vertex_in_lu(const struct vertex *v, const struct loopuse *lu)
d323 5
a327 1
nmg_start_new_loop(struct edgeuse *start_eu, struct loopuse *lu1, struct loopuse *lu2, struct bu_ptbl *loops)
d445 3
a447 1
nmg_fix_overlapping_loops(struct shell *s, const struct bn_tol *tol)
d748 3
a750 1
nmg_break_crossed_loops(struct shell *is, const struct bn_tol *tol)
d855 4
a858 1
nmg_extrude_cleanup(struct shell *is, const int is_void, const struct bn_tol *tol)
d1046 5
a1050 1
nmg_hollow_shell(struct shell *s, const fastf_t thick, const int approximate, const struct bn_tol *tol)
d1269 6
a1274 1
nmg_extrude_shell(struct shell *s, const fastf_t dist, const int normal_ward, const int approximate, const struct bn_tol *tol)
@


11.15
log
@CONST to const
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_extrude.c,v 11.14 2000/07/10 23:01:39 mike Exp $ (ARL)";
d45 1
a45 2
verts_in_nmg_loop(lu)
struct loopuse	*lu;
d77 1
a77 2
verts_in_nmg_face(fu)
struct faceuse	*fu;
d94 1
a94 4
nmg_translate_face(fu, Vec, tol)
struct faceuse	*fu;
const vect_t		Vec;
const struct bn_tol	*tol;
d184 4
a187 4
nmg_extrude_face(fu, Vec, tol)
struct faceuse	*fu;	/* Face to extrude. */
const vect_t		Vec;	/* Magnitude and direction of extrusion. */
const struct bn_tol	*tol;	/* NMG tolerances. */
d191 1
a191 1
	struct faceuse	*fu2, *nmg_dup_face(), **outfaces;
d273 1
a273 3
nmg_find_vertex_in_lu( v , lu )
const struct vertex *v;
const struct loopuse *lu;
d316 1
a316 5
nmg_start_new_loop( start_eu , lu1 , lu2 , loops )
struct edgeuse *start_eu;
struct loopuse *lu1;
struct loopuse *lu2;
struct bu_ptbl *loops;
d434 1
a434 3
nmg_fix_overlapping_loops( s , tol )
struct shell *s;
const struct bn_tol *tol;
d735 1
a735 3
nmg_break_crossed_loops( is , tol )
struct shell *is;
const struct bn_tol *tol;
d840 1
a840 4
nmg_extrude_cleanup( is , is_void , tol )
struct shell *is;
const int is_void;
const struct bn_tol *tol;
d1028 1
a1028 5
nmg_hollow_shell( s , thick , approximate , tol )
struct shell *s;
const fastf_t thick;
const int approximate;
const struct bn_tol *tol;
d1247 1
a1247 6
nmg_extrude_shell( s , dist , normal_ward , approximate , tol )
struct shell *s;
const fastf_t dist;
const int normal_ward;
const int approximate;
const struct bn_tol *tol;
@


11.14
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_extrude.c,v 11.13 2000/04/01 02:04:51 mike Exp $ (ARL)";
d98 2
a99 2
CONST vect_t		Vec;
CONST struct bn_tol	*tol;
d191 2
a192 2
CONST vect_t		Vec;	/* Magnitude and direction of extrusion. */
CONST struct bn_tol	*tol;	/* NMG tolerances. */
d279 2
a280 2
CONST struct vertex *v;
CONST struct loopuse *lu;
d447 1
a447 1
CONST struct bn_tol *tol;
d750 1
a750 1
CONST struct bn_tol *tol;
d857 2
a858 2
CONST int is_void;
CONST struct bn_tol *tol;
d1048 3
a1050 3
CONST fastf_t thick;
CONST int approximate;
CONST struct bn_tol *tol;
d1224 1
a1224 1
						(CONST long **)copy_tbl , tol );
d1271 4
a1274 4
CONST fastf_t dist;
CONST int normal_ward;
CONST int approximate;
CONST struct bn_tol *tol;
@


11.13
log
@
Added missing arg
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_extrude.c,v 11.12 2000/03/29 02:54:05 mike Exp $ (ARL)";
@


11.12
log
@
const and extern for nmg_extrude.c
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_extrude.c,v 11.11 2000/03/29 02:42:41 mike Exp $ (ARL)";
d1448 1
a1448 1
			nmg_js( s_tmp , s2 );
@


11.11
log
@
Moved externs to raytrace.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_extrude.c,v 11.10 1999/11/24 21:44:30 mike Exp $ (ARL)";
d98 2
a99 2
vect_t		Vec;
struct bn_tol	*tol;
d191 1
a191 1
vect_t		Vec;	/* Magnitude and direction of extrusion. */
d1202 1
a1202 1
					nmg_close_shell( is );
d1223 2
a1224 1
					nmg_open_shells_connect( s_tmp , is , copy_tbl , tol );
@


11.10
log
@
Removed includes of compat header files rtstring.h and rtlist.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_extrude.c,v 11.9 1999/06/03 01:39:14 mike Exp $ (ARL)";
a37 3
RT_EXTERN( struct shell *nmg_dup_shell , ( struct shell *s , long ***copy_tbl, CONST struct bn_tol *tol ) );
RT_EXTERN( void nmg_isect_shell_self , ( struct shell *s , CONST struct bn_tol *tol ) );
RT_EXTERN( fastf_t nmg_loop_plane_area , ( struct loopuse *lu , plane_t pl ) );
@


11.9
log
@
sed4
@
text
@d2 1
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_extrude.c,v 11.8 1997/04/16 20:19:50 jra Exp $ (ARL)";
a35 1
#include "rtlist.h"
@


11.8
log
@fixed bug in nmg_hollow_shell().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_extrude.c,v 11.7 1997/04/10 19:53:46 jra Exp $ (ARL)";
d121 1
a121 1
		rt_malloc(cnt * sizeof(struct vertex *), "verts");
d182 1
a182 1
	rt_free((char *)verts, "verts");
d226 1
a226 1
	outfaces = (struct faceuse **)rt_calloc( nfaces+2 , sizeof( struct faceuse *) ,
d270 1
a270 1
	rt_free( (char *)outfaces , "nmg_extrude_face: outfaces" );
d344 1
a344 1
	new_lu_tab = (struct bu_ptbl *)rt_malloc( sizeof( struct bu_ptbl ) , "nmg_start_new_loop: new_lu_tab" );
d718 1
a718 1
				rt_free( (char *)loop_tab , "nmg_fix_overlapping_loops: loop_tab" );
d1123 1
a1123 1
		flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "nmg_extrude_shell flags" );
d1235 2
a1236 2
		rt_free( (char *)flags , "nmg_extrude_shell: flags" );
		rt_free( (char *)copy_tbl , "nmg_extrude_shell: copy_tbl" );
d1345 1
a1345 1
		flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "nmg_extrude_shell flags" );
d1367 1
a1367 1
		rt_free( (char *)flags , "nmg_extrude_shell flags" );
@


11.7
log
@fixed nmg_extrude_cleanup() to be a little freer with non-closed shells.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_extrude.c,v 11.6 1996/10/21 19:12:16 jra Exp jra $ (ARL)";
d1193 1
a1193 1
		s_tmp_is_closed = nmg_check_closed_shell( s_tmp , tol );
d1202 1
a1202 1
				if( !nmg_check_closed_shell( is , tol ) )
d1216 1
a1216 1
				if( nmg_check_closed_shell( is , tol ) )
@


11.6
log
@Mod to nmg_gluefaces() call.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_extrude.c,v 11.5 1996/09/27 08:27:30 mike Exp jra $ (ARL)";
d952 1
a952 1
		else if( nmg_shell_is_void( is ) != is_void )
d979 1
a979 1
				if( nmg_shell_is_void( s_tmp ) != is_void )
d1069 1
d1193 3
a1195 1
		is = nmg_extrude_cleanup( is , is_void , tol );
d1200 1
a1200 1
			if( nmg_ck_closed_surf( s_tmp , tol ) )
d1202 1
a1202 1
				if( !nmg_ck_closed_surf( is , tol ) )
d1216 1
a1216 1
				if( nmg_ck_closed_surf( is , tol ) )
@


11.5
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_extrude.c,v 11.4 1996/08/27 03:03:05 mike Exp mike $ (ARL)";
d38 1
a38 1
RT_EXTERN( struct shell *nmg_dup_shell , ( struct shell *s , long ***copy_tbl ) );
d195 1
a195 1
struct bn_tol	*tol;	/* NMG tolerances. */
d268 1
a268 1
	nmg_gluefaces( outfaces , face_count );
d1119 1
a1119 1
		is = nmg_dup_shell( s_tmp , &copy_tbl );
@


11.4
log
@Eliminated confusing "else" statements after rt_bomb().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_extrude.c,v 11.3 1996/07/12 12:17:41 jra Exp mike $ (ARL)";
d39 1
a39 1
RT_EXTERN( void nmg_isect_shell_self , ( struct shell *s , CONST struct rt_tol *tol ) );
d58 2
a59 2
	if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
		for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d66 2
a67 2
	} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
		v = RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
d88 1
a88 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))
d102 1
a102 1
struct rt_tol	*tol;
d114 1
a114 1
	struct nmg_ptbl	edge_g_tbl;
d116 1
a116 1
	nmg_tbl( &edge_g_tbl , TBL_INIT , (long *)NULL );
d126 1
a126 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
d128 2
a129 2
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d141 1
a141 1
		} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
d143 1
a143 1
			v = RT_LIST_FIRST(vertexuse, &lu->down_hd)->v_p;
d156 1
a156 1
	for( i=0 ; i<NMG_TBL_END( &edge_g_tbl ) ; i++ )
d161 1
a161 1
		ep = NMG_TBL_GET( &edge_g_tbl , i );
d175 1
a175 1
	nmg_tbl( &edge_g_tbl , TBL_FREE , (long *)NULL );
d177 1
a177 1
	if(nmg_loop_plane_area( RT_LIST_FIRST( loopuse , &fu_tmp->lu_hd ) , pl ) < 0.0 )
d195 1
a195 1
struct rt_tol	*tol;	/* NMG tolerances. */
d207 1
a207 1
	RT_CK_TOL( tol );
d232 1
a232 1
	for( RT_LIST_FOR2(lu , lu2 , loopuse , &fu->lu_hd , &fu2->lu_hd ) )
d239 1
a239 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d241 1
a241 1
		if( RT_LIST_FIRST_MAGIC( &lu2->down_hd ) != NMG_EDGEUSE_MAGIC )
d243 1
a243 1
			rt_log( "nmg_extrude_face: Original face and dup face don't match up!!\n" );
d246 1
a246 1
		for( RT_LIST_FOR2( eu , eu2 , edgeuse , &lu->down_hd , &lu2->down_hd ) )
d260 1
a260 1
				rt_log( "nmg_extrude_face: failed to calculate plane eqn\n" );
d291 1
a291 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
d295 1
a295 1
		vu = RT_LIST_FIRST( vertexuse , &lu->down_hd );
d305 1
a305 1
	for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d330 1
a330 1
struct nmg_ptbl *loops;
d332 1
a332 1
	struct nmg_ptbl *new_lu_tab;
d344 2
a345 2
	new_lu_tab = (struct nmg_ptbl *)rt_malloc( sizeof( struct nmg_ptbl ) , "nmg_start_new_loop: new_lu_tab" );
	nmg_tbl( new_lu_tab , TBL_INIT , (long *)NULL );
d348 1
a348 1
	nmg_tbl( loops , TBL_INS , (long *)new_lu_tab );
d362 1
a362 1
		next_eu = RT_LIST_PNEXT_CIRC( edgeuse , &eu->l );
d388 1
a388 1
				for( i=0 ; i<NMG_TBL_END( loops ) ; i++ )
d390 1
a390 1
					struct nmg_ptbl *loop_tab;
d393 2
a394 2
					loop_tab = (struct nmg_ptbl *)NMG_TBL_GET( loops , i );
					loop_start_eu = (struct edgeuse *)NMG_TBL_GET( loop_tab , 0 );
d410 1
a410 1
				next_eu = RT_LIST_PNEXT_CIRC( edgeuse , &eu->l );
d418 1
a418 1
		nmg_tbl( new_lu_tab , TBL_INS , (long *)eu );
d450 1
a450 1
CONST struct rt_tol *tol;
d454 1
a454 1
	struct nmg_ptbl loops;
d460 1
a460 1
		rt_log( "nmg_fix_overlapping_loops: s = x%x\n" , s );
d465 2
a466 2
	/* This table will contain a list of nmg_ptbl's when we are
	 * finished. Each of those nmg_ptbl's will be a list of
d469 1
a469 1
	nmg_tbl( &loops , TBL_INIT , (long *)NULL );
d472 1
a472 1
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d489 1
a489 1
		lu1 = RT_LIST_FIRST( loopuse , &fu->lu_hd );
d492 1
a492 1
		lu2 = RT_LIST_PNEXT( loopuse , &lu1->l );
d495 1
a495 1
		if( RT_LIST_IS_HEAD( lu2 , &fu->lu_hd ) )
d502 1
a502 1
		if( RT_LIST_FIRST_MAGIC( &lu1->down_hd ) != NMG_EDGEUSE_MAGIC )
d505 1
a505 1
		if( RT_LIST_FIRST_MAGIC( &lu2->down_hd ) != NMG_EDGEUSE_MAGIC )
d511 1
a511 1
			rt_log( "nmg_fix_overlapping_loops: Cannot handle loops of same orientation\n" );
d528 1
a528 1
			rt_log( "nmg_fix_overlapping_loops: bad loop orientations %s and %s\n",
d537 1
a537 1
		for( RT_LIST_FOR( eu , edgeuse , &lu2->down_hd ) )
d567 1
a567 1
		for( RT_LIST_FOR( eu1 , edgeuse , &lu1->down_hd ) )
d573 1
a573 1
			for( RT_LIST_FOR( eu2 , edgeuse , &lu2->down_hd ) )
d582 1
a582 1
				if( rt_isect_lseg3_lseg3( dist , eu1->vu_p->v_p->vg_p->coord , v1 ,
d636 1
a636 1
		for( RT_LIST_FOR( eu1 , edgeuse , &lu1->down_hd ) )
d662 2
a663 2
			rt_log( "nmg_fix_overlapping_loops: cannot find start point for new loops\n" );
			rt_log( "lu1=x%x, lu2=x%x\n" , lu1 , lu2 );
d668 1
a668 1
		nmg_tbl( &loops , TBL_RST , (long *)NULL );
d676 1
a676 1
		for( i=0 ; i<NMG_TBL_END( &loops ) ; i++ )
d680 1
a680 1
			struct nmg_ptbl *loop_tab;
d684 1
a684 1
			loop_tab = (struct nmg_ptbl *)NMG_TBL_GET( &loops , i );
d687 1
a687 1
			if( NMG_TBL_END( loop_tab ) )
d694 2
a695 2
				nmg_kvu( RT_LIST_FIRST( vertexuse , &new_lu->down_hd ) );
				nmg_kvu( RT_LIST_FIRST( vertexuse , &new_lu_mate->down_hd ) );
d698 1
a698 1
				for( eu_no=0 ; eu_no<NMG_TBL_END( loop_tab ) ; eu_no++ )
d703 1
a703 1
					mv_eu = (struct edgeuse *)NMG_TBL_GET( loop_tab , eu_no );
d707 2
a708 2
					RT_LIST_DEQUEUE( &mv_eu->l );
					RT_LIST_INSERT( &new_lu->down_hd , &mv_eu->l );
d712 2
a713 2
					RT_LIST_DEQUEUE( &mv_eu->eumate_p->l );
					RT_LIST_APPEND( &new_lu_mate->down_hd , &mv_eu->eumate_p->l );
d717 1
a717 1
				nmg_tbl( loop_tab , TBL_FREE , (long *)NULL );
d723 2
a724 2
		lu1 = RT_LIST_FIRST( loopuse , &fu->lu_hd );
		while( RT_LIST_NOT_HEAD( lu1 , &fu->lu_hd ) )
d728 1
a728 1
			next_lu = RT_LIST_PNEXT( loopuse , &lu1->l );
d730 1
a730 1
			if( RT_LIST_IS_EMPTY( &lu1->down_hd ) )
d738 1
a738 1
	nmg_tbl( &loops , TBL_FREE , (long *)NULL );
d741 1
a741 1
		rt_log( "nmg_fix_overlapping_loops: done\n" );
d753 1
a753 1
CONST struct rt_tol *tol;
d758 1
a758 1
	RT_CK_TOL( tol );
d760 1
a760 1
	for( RT_LIST_FOR( fu , faceuse , &is->fu_hd ) )
d769 1
a769 1
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d776 1
a776 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d779 1
a779 1
			for( RT_LIST_FOR( eu1 , edgeuse , &lu->down_hd ) )
d784 2
a785 2
				eu2 = RT_LIST_PNEXT( edgeuse , eu1 );
				while( RT_LIST_NOT_HEAD( eu2 , &lu->down_hd ) )
d792 1
a792 1
					if( rt_isect_lseg3_lseg3( dist , eu1->vu_p->v_p->vg_p->coord , v1 ,
d840 1
a840 1
					eu2 = RT_LIST_PNEXT( edgeuse , eu2 );
d861 1
a861 1
CONST struct rt_tol *tol;
d872 1
a872 1
	RT_CK_TOL( tol );
d875 1
a875 1
		rt_log( "nmg_extrude_cleanup( is=x%x )\n" , is );
d886 1
a886 1
	for( RT_LIST_FOR( fu , faceuse , &is->fu_hd ) )
d891 2
a892 2
		lu = RT_LIST_LAST( loopuse , &fu->lu_hd );
		while( RT_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
d917 1
a917 1
			lu = RT_LIST_PLAST( loopuse , &lu->l );
d930 1
a930 1
	s_tmp = RT_LIST_FIRST( shell , &new_r->s_hd );
d966 2
a967 2
		s_tmp = RT_LIST_FIRST( shell , &new_r->s_hd );
		while( RT_LIST_NOT_HEAD( s_tmp , &new_r->s_hd ) )
d972 1
a972 1
			next_s = RT_LIST_PNEXT( shell , &s_tmp->l );
d1001 1
a1001 1
		is = RT_LIST_FIRST( shell , &new_r->s_hd );
d1003 2
a1004 2
		s_tmp = RT_LIST_PNEXT( shell , &is->l );
		while( RT_LIST_NOT_HEAD( s_tmp , &new_r->s_hd ) )
d1008 1
a1008 1
			next_s = RT_LIST_PNEXT( shell , &s_tmp->l );
d1025 2
a1026 2
		if( RT_LIST_NON_EMPTY( &new_r->s_hd ) )
			rt_log( "nmg_extrude_cleanup: temporary nmgregion not empty!!\n" );
d1053 1
a1053 1
CONST struct rt_tol *tol;
d1064 1
a1064 1
	struct nmg_ptbl shells;
d1071 1
a1071 1
		rt_log( "nmg_extrude_shell( s=x%x , thick=%f)\n" , s , thick );
d1074 1
a1074 1
	RT_CK_TOL( tol );
d1078 1
a1078 1
		rt_log( "nmg_extrude_shell: thickness less than zero not allowed" );
d1084 1
a1084 1
		rt_log( "nmg_extrude_shell: thickness less than tolerance not allowed" );
d1096 1
a1096 1
	s_tmp = RT_LIST_FIRST( shell , &new_r->s_hd );
d1109 3
a1111 3
	nmg_tbl( &shells , TBL_INIT , (long *)NULL );
	for( RT_LIST_FOR( s_tmp , shell , &new_r->s_hd ) )
		nmg_tbl( &shells , TBL_INS , (long *)s_tmp );
d1114 1
a1114 1
	for( shell_no=0 ; shell_no<NMG_TBL_END( &shells ) ; shell_no ++ )
d1116 1
a1116 1
		s_tmp = (struct shell *)NMG_TBL_GET( &shells , shell_no );
d1125 1
a1125 1
		for( RT_LIST_FOR( fu , faceuse , &is->fu_hd ) )
d1150 1
a1150 1
		for( RT_LIST_FOR( fu , faceuse , &s_tmp->fu_hd ) )
d1155 1
a1155 1
			for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d1158 1
a1158 1
				if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
d1167 1
a1167 1
					for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d1201 1
a1201 1
					rt_log( "nmg_extrude_shell: inside shell is not closed, calling nmg_close_shell\n" );
d1215 1
a1215 1
					rt_log( "nmg_extrude_shell: inside shell is closed, outer isn't!!\n" );
d1237 1
a1237 1
	for( shell_no=0 ; shell_no<NMG_TBL_END( &shells ) ; shell_no++ )
d1241 1
a1241 1
		s2 = (struct shell *)NMG_TBL_GET( &shells , shell_no );
d1246 1
a1246 1
	nmg_tbl( &shells , TBL_FREE , (long *)NULL );
d1273 1
a1273 1
CONST struct rt_tol *tol;
d1280 2
a1281 2
	struct nmg_ptbl shells;
	struct nmg_ptbl verts;
d1286 1
a1286 1
	RT_CK_TOL( tol );
d1290 1
a1290 1
		rt_log( "nmg_extrude_shell: Cannot extrude a distance less than tolerance distance\n" );
d1311 1
a1311 1
	s_tmp = RT_LIST_FIRST( shell , &new_r->s_hd );
d1322 3
a1324 3
	nmg_tbl( &shells , TBL_INIT , (long *)NULL );
	for( RT_LIST_FOR( s_tmp , shell , &new_r->s_hd ) )
		nmg_tbl( &shells , TBL_INS , (long *)s_tmp );
d1326 1
a1326 1
	nmg_tbl( &verts , TBL_INIT , (long *)NULL );
d1329 1
a1329 1
	for( shell_no=0 ; shell_no < NMG_TBL_END( &shells ) ; shell_no++ )
d1336 1
a1336 1
		s_tmp = (struct shell *)NMG_TBL_GET( &shells , shell_no );
d1345 1
a1345 1
		for( RT_LIST_FOR( fu , faceuse , &s_tmp->fu_hd ) )
d1370 1
a1370 1
		for( vert_no = 0 ; vert_no < NMG_TBL_END( &verts ) ; vert_no++ )
d1374 1
a1374 1
			new_v = (struct vertex *)NMG_TBL_GET( &verts , vert_no );
d1379 1
a1379 1
				rt_log( "nmg_extrude_shell: Failed to calculate new vertex at v=x%x was ( %f %f %f )\n",
d1386 1
a1386 1
		nmg_tbl( &verts , TBL_FREE , (long *)NULL );
d1390 1
a1390 1
			for( RT_LIST_FOR( fu , faceuse , &s_tmp->fu_hd ) )
d1398 1
a1398 1
				for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d1403 1
a1403 1
					if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d1420 1
a1420 1
					rt_log( "nmg_extrude_shell: Cannot recalculate plane for face:\n" );
d1435 1
a1435 1
	nmg_tbl( &shells , TBL_FREE , (long *)NULL );
d1438 1
a1438 1
	if( RT_LIST_NON_EMPTY( &new_r->s_hd ) )
d1440 3
a1442 3
		s_tmp = RT_LIST_FIRST( shell , &new_r->s_hd );
		s2 = RT_LIST_PNEXT( shell , &s_tmp->l );
		while( RT_LIST_NOT_HEAD( s2 , &new_r->s_hd ) )
d1446 1
a1446 1
			next_s = RT_LIST_PNEXT( shell , &s2->l );
@


11.3
log
@Minor Mods for IRIX 6.2
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_extrude.c,v 11.2 1995/03/01 13:19:45 jra Exp jra $ (ARL)";
d220 1
a220 1
	else if (cosang > 0.)
@


11.2
log
@Replaced call to nmg_fu_planeeqn with call to nmg_calc_face_g().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_extrude.c,v 11.1 95/01/04 09:57:29 mike Rel4_4 Locker: jra $ (ARL)";
d98 1
d191 1
d271 2
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_extrude.c,v 1.20 94/12/27 15:15:29 jra Exp $ (ARL)";
d256 1
a256 1
			if( nmg_fu_planeeqn( outfaces[face_count] , tol ) < 0 )
@


1.20
log
@Made "verts_in_nmg_face" and "verts_in_nmg_loop" static, and changed
translate_nmg_face to nmg_translate_face.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_extrude.c,v 1.19 94/11/28 13:28:18 jra Exp Locker: jra $ (ARL)";
@


1.19
log
@Added code to move edge geometry in translate_nmg_face.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_extrude.c,v 1.18 94/11/21 16:25:53 jra Exp Locker: jra $ (ARL)";
a42 87
 *	E x t r u d e _ N M G _ F a c e
 *
 *	Duplicate a given NMG face, move it by specified vector,
 *	and create a solid bounded by these faces.
 */
nmg_extrude_face(fu, Vec, tol)
struct faceuse	*fu;	/* Face to extrude. */
vect_t		Vec;	/* Magnitude and direction of extrusion. */
struct rt_tol	*tol;	/* NMG tolerances. */
{
	fastf_t		cosang;
	int		nfaces;
	struct faceuse	*fu2, *nmg_dup_face(), **outfaces;
	int		face_count=2;
	struct loopuse	*lu, *lu2;
	plane_t		n;

#define MIKE_TOL 0.0001

	NMG_CK_FACEUSE( fu );
	RT_CK_TOL( tol );

	/* Duplicate and reverse face. */
	fu2 = nmg_dup_face(fu, fu->s_p);
	nmg_reverse_face( fu2 );
	if( fu2->orientation != OT_OPPOSITE )
		fu2 = fu2->fumate_p;

	/* Figure out which face to translate. */
	NMG_GET_FU_PLANE( n, fu );
	cosang = VDOT(Vec, n);
	if (NEAR_ZERO(cosang, MIKE_TOL))
		rt_bomb("extrude_nmg_face: extrusion cannot be parallel to face\n");
	else if (cosang > 0.)
		translate_nmg_face(fu, Vec, tol);
	else if (cosang < 0.)
		translate_nmg_face(fu2->fumate_p, Vec, tol);

	nfaces = verts_in_nmg_face( fu );
	outfaces = (struct faceuse **)rt_calloc( nfaces+2 , sizeof( struct faceuse *) ,
		"nmg_extrude_face: outfaces" );

	outfaces[0] = fu;
	outfaces[1] = fu2->fumate_p;

	for( RT_LIST_FOR2(lu , lu2 , loopuse , &fu->lu_hd , &fu2->lu_hd ) )
	{
		struct edgeuse *eu,*eu2;

		NMG_CK_LOOPUSE( lu );
		NMG_CK_LOOPUSE( lu2 );

		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;
		if( RT_LIST_FIRST_MAGIC( &lu2->down_hd ) != NMG_EDGEUSE_MAGIC )
		{
			rt_log( "nmg_extrude_face: Original face and dup face don't match up!!\n" );
			return( -1 );
		}
		for( RT_LIST_FOR2( eu , eu2 , edgeuse , &lu->down_hd , &lu2->down_hd ) )
		{
			struct vertex	*vertlist[4];

			NMG_CK_EDGEUSE( eu );
			NMG_CK_EDGEUSE( eu2 );

			vertlist[0] = eu->vu_p->v_p;
			vertlist[1] = eu2->vu_p->v_p;
			vertlist[2] = eu2->eumate_p->vu_p->v_p;
			vertlist[3] = eu->eumate_p->vu_p->v_p;
			outfaces[face_count] = nmg_cface( fu->s_p , vertlist , 4 );
			if( nmg_fu_planeeqn( outfaces[face_count] , tol ) < 0 )
			{
				rt_log( "nmg_extrude_face: failed to calculate plane eqn\n" );
				return( -1 );
			}
			face_count++;
		}

	}

	nmg_gluefaces( outfaces , face_count );

	rt_free( (char *)outfaces , "nmg_extrude_face: outfaces" );
}

/*
d47 1
a47 1
int
d80 1
a80 1
int
d98 1
a98 1
translate_nmg_face(fu, Vec, tol)
d146 1
a146 1
			rt_bomb("translate_nmg_face: bad loopuse\n");
d178 1
a178 1
		rt_bomb( "translate_nmg_face: Cannot calculate plane equation for face\n" );
d182 87
@


1.18
log
@Modified nmg_translate_face to use nmg_loop_plane_area rather than nmg_fu_planeeqn.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_extrude.c,v 1.17 94/11/08 03:55:34 mike Exp Locker: jra $ (ARL)";
d200 1
d202 2
d239 23
@


1.17
log
@Irix 6
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d198 2
d233 9
a241 1
	nmg_fu_planeeqn(fu, tol);
@


1.16
log
@nmg_extrude_face was not allocating enuf memory for outfaces list.
@
text
@d9 7
a15 2
 *      The US Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5066
d18 2
a19 2
 *	This software is Copyright (C) 1993 by the United States Army.
 *	All rights reserved.
d21 4
a54 1
	struct edgeuse	*eu;
d547 2
a548 1
					if( dist[0]>0.0 && dist[0]<1.0 && dist[1]>=0.0 && dist[2]<=1.0 )
a826 1
	struct edgeuse *eu;
a829 2
	int inside_shells;
	int i,j;
a847 3
		struct loopuse *lu1;
		plane_t plane;

a850 2
		NMG_GET_FU_PLANE( plane , fu );

a854 1
			struct faceuse *new_fu;
d903 2
a904 2
	/* now decompose our shell */
	if( (inside_shells=nmg_decompose_shell( is , tol )) < 2 )
a1015 1
	struct vertex *v;
a1023 1
	struct nmg_ptbl vertex_uses,faces;
a1028 1
	int i,j;
@


1.15
log
@Modified nmg_extrude_face.
@
text
@d74 1
a74 1
	outfaces = (struct faceuse **)rt_calloc( nfaces , sizeof( struct faceuse *) ,
d117 2
@


1.14
log
@Converted NMG data structures to have edge_g pointer in edgeuse, not edge.
@
text
@d45 1
a45 1
	int		cnt, i, j, nfaces;
d47 2
a48 1
	struct faceuse	*back, *front, *fu2, *nmg_dup_face(), **outfaceuses;
a49 2
	struct shell	*s;
	struct vertex	*v, *vertlist[4], **verts, **verts2;
d54 2
a55 1
	j = 0;
d57 1
a57 1
	/* Duplicate face. */
d59 3
d63 1
a63 1
	/* Figure out which face to flip. */
d66 1
a66 3
	front = fu;
	back = fu2;
	if (NEAR_ZERO(cosang, MIKE_TOL)) {
d68 4
a71 7
	} else if (cosang > 0.) {
		flip_nmg_face(back, tol);
		translate_nmg_face(front, Vec, tol);
	} else if (cosang < 0.) {
		flip_nmg_face(back, tol);
		translate_nmg_face(back, Vec, tol);
	}
d73 3
a75 5
	lu = (struct loopuse *)((&front->lu_hd)->forw);
	lu2 = (struct loopuse *)((&back->lu_hd)->forw);
	nfaces = verts_in_nmg_face(front);
	outfaceuses = (struct faceuse **)
		rt_malloc((nfaces+2) * sizeof(struct faceuse *), "faces");
d77 2
a78 8
	do {
		cnt = verts_in_nmg_loop(lu);
		if (cnt < 3)
			rt_bomb("extrude_nmg_face: need at least 3 points\n");
		verts = (struct vertex **)
			rt_malloc((cnt+1)*sizeof(struct vertex *), "verts");
		verts2 = (struct vertex **)
			rt_malloc((cnt+1)*sizeof(struct vertex *), "verts");
d80 3
a82 9
		/* Collect vertex structures from 1st face. */
		i = 0;
		NMG_CK_LOOPUSE(lu);
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				verts[i++] = eu->vu_p->v_p;
			}
		} else
			rt_bomb("extrude_nmg_face: bad loopuse (1)\n");
d84 2
a85 10
		/* Collect vertex structures from 2nd face. */
		i = 0;
		NMG_CK_LOOPUSE(lu2);
		if (RT_LIST_FIRST_MAGIC(&lu2->down_hd) == NMG_EDGEUSE_MAGIC) {
			for (RT_LIST_FOR(eu, edgeuse, &lu2->down_hd)) {
				verts2[cnt-i-1] = eu->vu_p->v_p;
				i++;
			}
		} else
			rt_bomb("extrude_nmg_face: bad loopuse (2)\n");
d87 6
a92 10
		verts[cnt] = verts[0];
		verts2[cnt] = verts2[0];

		for (i = 0; i < cnt; i++) {
			/* Generate connecting faces. */
			vertlist[0] = verts[i];
			vertlist[1] = verts2[i];
			vertlist[2] = verts2[i+1];
			vertlist[3] = verts[i+1];
			outfaceuses[2+i+j] = nmg_cface(fu->s_p, vertlist, 4);
d94 3
a96 1
		j += cnt;
d98 2
a99 3
		/* Free memory. */
		rt_free((char *)verts, "verts");
		rt_free((char *)verts2, "verts");
d101 9
a109 54
		/* On to next loopuse. */
		lu = (struct loopuse *)((struct rt_list *)(lu))->forw;
		lu2 = (struct loopuse *)((struct rt_list *)(lu2))->forw;

	} while (lu != (struct loopuse *)(&fu->lu_hd));

	outfaceuses[0] = fu;
	outfaceuses[1] = fu2;

	/* Associate the face geometry. */
	for (i = 0; i < nfaces+2; i++) {
		if (nmg_fu_planeeqn(outfaceuses[i], tol) < 0)
			return(-1);	/* FAIL */
	}

	/* Glue the edges of different outward pointing face uses together. */
	nmg_gluefaces(outfaceuses, nfaces+2);

	/* Compute geometry for region and shell. */
	nmg_region_a(fu->s_p->r_p, tol);

	/* Free memory. */
	rt_free((char *)outfaceuses, "faces");
}

/*
 *	F l i p _ N M G _ F a c e
 *
 *	Given a pointer to a faceuse, flip the face by reversing the
 *	order of vertex pointers in each loopuse.
 */
flip_nmg_face(fu, tol)
struct faceuse	*fu;
struct rt_tol	*tol;
{
	int		cnt,		/* Number of vertices in face. */
			i;
	struct vertex	**verts;	/* List of verts in face. */
	struct edgeuse	*eu;
	struct loopuse	*lu, *lu2;
	struct vertex	*v;

	/* Go through each loop and flip it. */
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		cnt = verts_in_nmg_loop(lu);	/* # of vertices in loop. */
		verts = (struct vertex **)
			rt_malloc(cnt * sizeof(struct vertex *), "verts");

		/* Collect vertex structure pointers from current loop. */
		i = 0;
		NMG_CK_LOOPUSE(lu);
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				verts[i++] = eu->vu_p->v_p;
d111 2
a112 6
		} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
			== NMG_VERTEXUSE_MAGIC) {
			v = RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
			verts[i++] = v;
		} else
			rt_bomb("extrude_nmg_face: loopuse mess up!\n");
a113 17
		/* Reverse order of vertex structures in current loop. */
		i = 0;
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
			== NMG_EDGEUSE_MAGIC) {
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				eu->vu_p->v_p = verts[cnt-i-1];
				i++;
			}
		} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd)
			== NMG_VERTEXUSE_MAGIC) {
			RT_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p
				= verts[cnt-i-1];
			i++;
		} else
			rt_bomb("extrude_nmg_face: loopuse mess up!\n");

		rt_free((char *)verts, "verts");
d116 1
a116 1
	nmg_fu_planeeqn(fu, tol);
d1198 1
a1198 2
	s_tmp = (struct shell *)NMG_TBL_GET( &shells , 0 );
	for( shell_no=1 ; shell_no<NMG_TBL_END( &shells ) ; shell_no++ )
d1203 2
a1204 1
		nmg_js( s_tmp , s2 , tol );
d1209 1
a1209 1
	(void)nmg_mv_shell_to_region( s_tmp , old_r );
@


1.13
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@d641 1
a641 1
							new_eu = nmg_esplit( v , eu1 );
d661 1
a661 1
							new_eu = nmg_esplit( v , eu2 );
d855 1
a855 1
							new_eu = nmg_esplit( v , eu1 );
d876 1
a876 1
							new_eu = nmg_esplit( v , eu2 );
@


1.12
log
@Modified nmg_extrude_shell to recalculate plane eqn's if using approximate method.
@
text
@d1112 1
a1112 1
	struct face_g *fg_p;
d1183 2
a1184 2
			fg_p = fu->f_p->fg_p;
			NMG_CK_FACE_G( fg_p );
d1401 1
a1401 1
			struct face_g *fg_p;
d1405 2
a1406 2
			fg_p = fu->f_p->fg_p;
			NMG_CK_FACE_G( fg_p );
@


1.11
log
@Modified nmg_break_crossed_loops and nmg_extrude_cleanup
@
text
@d16 1
d31 1
a929 3
	/* Or loops that cross themselves */
	nmg_break_crossed_loops( is , tol );

d1144 1
d1148 1
d1152 2
d1155 2
d1162 1
d1167 1
d1441 40
@


1.10
log
@Added nmg_break_crossed_loops and added "approximate" arg to extrude routines.
@
text
@a579 1
			struct edgeuse *eu1;
d607 65
d703 2
d821 2
a822 1
				VSUB2( v1 , eu1->eumate_p->vu_p->v_p->vg_p->coord , eu1->vu_p->v_p->vg_p->coord );
d829 2
a830 1
					VSUB2( v2 , eu2->eumate_p->vu_p->v_p->vg_p->coord , eu2->vu_p->v_p->vg_p->coord );
d839 2
a840 1
						if( dist[0] > 0.0 && dist[0] < 1.0 )
d842 11
a852 2
							VJOIN1( pt , eu1->vu_p->v_p->vg_p->coord , dist[0] , v1 );
							v = nmg_find_pt_in_shell( is , pt , tol );
d857 3
a859 1
							VSUB2( v1 , eu1->eumate_p->vu_p->v_p->vg_p->coord , eu1->vu_p->v_p->vg_p->coord );
d861 2
a862 1
						if( dist[1] > 0.0 && dist[1] < 1.0 )
d864 10
a873 2
							VJOIN1( pt , eu2->vu_p->v_p->vg_p->coord , dist[1] , v2 );
							v = nmg_find_pt_in_shell( is , pt , tol );
@


1.9
log
@Modified nmg_extrude_cleanup to use nmg_isect_shell_self
@
text
@d2 1
a2 2
 *	Routines for extruding nmg's. Currently, just a single
 *	face extruder into an nmg solid.
d718 80
d839 3
d871 1
d1006 4
d1012 1
a1012 1
nmg_hollow_shell( s , thick , tol )
d1015 1
d1137 1
a1137 1
							if( nmg_in_vert( new_v , tol ) )
d1216 4
a1219 1
 * additional faces and/or edges may be added to the shell.
d1226 1
a1226 1
nmg_extrude_shell( s , dist , normal_ward , tol )
d1230 1
d1335 1
a1335 1
			if( nmg_in_vert( new_v , tol ) )
@


1.8
log
@fixed bug in nmg_extrude_cleanup
@
text
@d30 1
d317 5
d361 6
d406 1
d409 1
d417 1
d421 1
d444 3
d450 1
d459 1
d464 1
d470 19
d504 1
d507 4
d513 1
a521 1

d524 1
d528 3
d535 2
d539 1
d542 2
d550 1
d558 2
d578 1
d588 1
d601 3
d609 3
a611 1
		/* find a vertex that lu1 and lu2 share, where eu1 is outside lu2 */
d618 1
d627 1
d645 3
a647 1
		/* start new loop */
d658 1
d661 1
d677 1
d681 1
d685 2
d697 1
d736 1
a736 1
	struct nmgregion *new_r,*r;
d741 3
a743 2
	struct nmg_ptbl fus;
	struct shell *s_fu;	/* Shell to temporarily hold fu2 */
a744 1
	int fu_no,fu2_no;
a752 1
	NMG_CK_MODEL( m );
d754 2
a755 1
	nmg_vmodel( m );
a756 78
	r = is->r_p;
	NMG_CK_REGION( r );

	s_fu = nmg_msv( r );
	NMG_CK_SHELL( s_fu );

	nmg_tbl( &fus , TBL_INIT , (long *)NULL );

	for( RT_LIST_FOR( fu , faceuse , &is->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );

		if( fu->orientation == OT_SAME )
			nmg_tbl( &fus , TBL_INS , (long *)fu );
	}

	/* intersect each face with every other face in the shell */
	for( fu_no=0 ; fu_no < NMG_TBL_END( &fus ) ; fu_no ++ )
	{
		struct faceuse *fu2;
		struct faceuse *next_fu;

		fu = (struct faceuse *)NMG_TBL_GET( &fus , fu_no );

		NMG_CK_FACEUSE( fu );

		if( rt_g.NMG_debug & DEBUG_BASIC )
			rt_log( "nmg_extrude_cleanup: fu=x%x\n" );

		/* move fu to another shell to avoid radial edge problems */
		nmg_mv_fu_between_shells( s_fu, is, fu );

		/* consider intersection this faceuse with all the faceuses
		 * after it in the list
		 */
		for( fu2_no=fu_no+1 ; fu2_no < NMG_TBL_END( &fus ) ; fu2_no++ )
		{
			struct face *f,*f2;

			fu2 = (struct faceuse *)NMG_TBL_GET( &fus , fu2_no );

			if( rt_g.NMG_debug & DEBUG_BASIC )
				rt_log( "nmg_extrude_cleanup: fu=x%x, fu2=x%x\n" , fu , fu2 );

			/* skip faceuses radial to fu or not OT_SAME */
			if( fu2->orientation != OT_SAME || nmg_faces_are_radial( fu , fu2 ) )
				continue;

			f = fu->f_p;
			f2 = fu2->f_p;

			/* skip faceuse pairs that don't have overlapping BB's */
			if( !V3RPP_OVERLAP( f->min_pt , f->max_pt , f2->min_pt , f2->max_pt ) )
				continue;

			if( rt_g.NMG_debug & DEBUG_BASIC )
				rt_log( "nmg_extrude_cleanup: calling nmg_isect_two_generic_faces( fu=x%x , fu2=x%x )\n" , fu , fu2 );

			nmg_isect_two_generic_faces( fu , fu2 , tol );
		}
		/* move fu back where it belongs */
		while( RT_LIST_NON_EMPTY( &s_fu->fu_hd ) )
		{
			struct faceuse *fu_tmp;

			fu_tmp = RT_LIST_FIRST( faceuse , &s_fu->fu_hd );
			NMG_CK_FACEUSE( fu_tmp );

			if( rt_g.NMG_debug & DEBUG_BASIC )
				rt_log( "nmg_extrude_cleanup: moving fu x%x back\n" , fu_tmp );

			nmg_mv_fu_between_shells( is, s_fu, fu_tmp );
		}
	}

	/* get rid of the temporary shell */
	nmg_ks( s_fu );

d801 1
a801 4
	{
		struct nmgregion *old_r;
		struct shell *s_tmp;
		int inside_shells;
d803 2
a804 1
		nmg_rebound( m , tol );
d806 2
a807 2
		/* remember the nmgregion where "is" came from */
		old_r = is->r_p;
d809 2
a810 2
		/* make a new nmgregion , shell, and vertex */
		new_r = nmg_mrsv( m );
d812 6
a817 2
		/* s_tmp is the shell just created */
		s_tmp = RT_LIST_FIRST( shell , &new_r->s_hd );
d819 3
a821 6
		/* move our shell (is) to the new nmgregion
		 * in preparaion for nmg_decompose_shell.
		 * don't want to confuse pieces of this shell
		 * with other shells in "old_r"
		 */
		(void)nmg_mv_shell_to_region( is , new_r );
d823 5
a827 6
		/* kill the unused, newly created shell */
		if( nmg_ks( s_tmp ) )
			rt_bomb( "nmg_extrude_shell: Nothing got moved to new region\n" );

		/* now decompose our shell */
		if( (inside_shells=nmg_decompose_shell( is , tol )) < 2 )
d829 2
a830 16
			/*  we still have only one shell */
			if( nmg_bad_face_normals( is , tol ) )
			{
				(void)nmg_ks( is );
				is = (struct shell *)NULL;
			}
			else if( nmg_shell_is_void( is ) != is_void )
			{
				(void)nmg_ks( is );
				is = (struct shell *)NULL;
			}
			else
				(void)nmg_mv_shell_to_region( is , old_r );

			nmg_kr( new_r );
			new_r = NULL;
d832 5
d838 10
d849 2
a850 6
			/* look at each shell in "new_r" */
			s_tmp = RT_LIST_FIRST( shell , &new_r->s_hd );
			while( RT_LIST_NOT_HEAD( s_tmp , &new_r->s_hd ) )
			{
				struct shell *next_s;
				int kill_it=0;
d852 1
a852 1
				next_s = RT_LIST_PNEXT( shell , &s_tmp->l );
d854 6
a859 1
				if( nmg_bad_face_normals( s_tmp , tol ) )
d861 1
d863 4
a866 1
				if( !kill_it )
d868 4
a871 2
					if( nmg_shell_is_void( s_tmp ) != is_void )
						kill_it = 1;
a872 13

				if( kill_it )
				{
					/* Bad shell, kill it */
					if( nmg_ks( s_tmp ) )
					{
						nmg_kr( new_r );
						new_r = NULL;
						is = NULL;
						break;
					}
				}
				s_tmp = next_s;
d874 1
d876 1
d878 7
a884 1
		if( new_r )
d886 1
a886 2
			/* merge remaining shells in "new_r" */
			is = RT_LIST_FIRST( shell , &new_r->s_hd );
d888 3
a890 2
			s_tmp = RT_LIST_PNEXT( shell , &is->l );
			while( RT_LIST_NOT_HEAD( s_tmp , &new_r->s_hd ) )
a891 11
				struct shell *next_s;

				next_s = RT_LIST_PNEXT( shell , &s_tmp->l );

				if( s_tmp == is )
				{
					s_tmp = next_s;
					continue;
				}

				nmg_js( is , s_tmp , tol );
d893 1
d896 3
a898 3
			/* move it all back into the original nmgregion */
			if( is )
				(void)nmg_mv_shell_to_region( is , old_r );
d900 3
a902 3
			/* kill the temporary nmgregion */
			if( RT_LIST_NON_EMPTY( &new_r->s_hd ) )
				rt_log( "nmg_extrude_cleanup: temporary nmgregion not empty!!\n" );
d904 5
a908 2
			(void)nmg_kr( new_r );
		}
@


1.7
log
@Working version of NMG extruder
@
text
@d460 3
d638 3
d665 1
d668 1
d687 10
d698 1
a698 2
	fu = RT_LIST_FIRST( faceuse , &is->fu_hd );
	while( RT_LIST_NOT_HEAD( fu , &is->fu_hd ) )
d703 2
d707 2
a708 6
		/* only look at OT_SAME faceuses */
		if( fu->orientation != OT_SAME )
		{
			fu = RT_LIST_PNEXT( faceuse , &fu->l );
			continue;
		}
d710 2
a711 3
		next_fu = RT_LIST_PNEXT( faceuse , &fu->l );
		if( next_fu == fu->fumate_p && RT_LIST_NOT_HEAD( fu , &is->fu_hd ) )
			 next_fu = RT_LIST_PNEXT( faceuse , &next_fu->l );
d716 1
a716 8
		fu2 = RT_LIST_PNEXT( faceuse , &fu->l );
		if( RT_LIST_IS_HEAD( fu2 , &is->fu_hd ) )
			break;

		/* move fu to another shell to avoid radial edge problems */
		nmg_mv_fu_between_shells( s_fu, is, fu );

		while( RT_LIST_NOT_HEAD( fu2 , &is->fu_hd ) )
d720 5
a726 2
			{
				fu2 = RT_LIST_PNEXT( faceuse , &fu2->l );
a727 1
			}
a733 2
			{
				fu2 = RT_LIST_PNEXT( faceuse , &fu2->l );
a734 1
			}
d736 3
a739 2

			fu2 = RT_LIST_PNEXT( faceuse , &fu2->l );
d748 4
a753 2

		fu = next_fu;
@


1.6
log
@Access to plane equation / surface normal in face_geometry structure
is now done through macros NMG_GET_FU_PLANE() NMG_GET_FU_NORMAL(),
which honor the f->flip flag.
@
text
@d7 1
d29 2
d314 975
@


1.5
log
@Bounding box routines now all take a tol arg.
@
text
@d46 1
d56 2
a57 1
	cosang = VDOT(Vec, fu->f_p->fg_p->N);
@


1.4
log
@Pointer was not being initialized.
@
text
@d140 1
a140 1
	nmg_region_a(fu->s_p->r_p);
@


1.3
log
@relative path for debug.h
@
text
@d300 2
@


1.2
log
@Changed name to nmg_extrude_face
@
text
@d26 1
a26 1
#include "/m/cad/librt/debug.h"
@


1.1
log
@Initial revision
@
text
@d34 1
a34 1
extrude_nmg_face(fu, Vec, tol)
@
