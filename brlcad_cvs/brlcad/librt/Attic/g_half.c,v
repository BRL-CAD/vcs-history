head	11.35;
access;
symbols
	ansi-20040405-merged:11.31.2.2
	postmerge-20040405-ansi:11.33
	premerge-20040404-ansi:11.32
	postmerge-autoconf:11.32
	autoconf-freeze:11.31.10.2
	premerge-autoconf:11.32
	ansi-20040316-freeze:11.31.2.1
	postmerge-20040315-windows:11.32
	premerge-20040315-windows:11.32
	windows-20040315-freeze:11.31.4.1
	autoconf-20031203:11.31
	autoconf-20031202:11.31
	autoconf-branch:11.31.0.10
	phong-branch:11.31.0.8
	photonmap-branch:11.31.0.6
	rel-6-1-DP:11.31
	windows-branch:11.31.0.4
	rel-6-0-2:11.29
	ansi-branch:11.31.0.2
	rel-6-0-1-branch:11.29.0.2
	hartley-6-0-post:11.30
	hartley-6-0-pre:11.29
	rel-6-0-1:11.29
	rel-6-0:11.29
	rel-5-4:11.14
	offsite-5-3-pre:11.26
	rel-5-3:11.14
	rel-5-2:11.14
	rel-5-1-branch:11.14.0.2
	rel-5-1:11.14
	rel-5-0:11.6
	rel-5-0-beta:11.5
	rel-4-5:11.4
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.35
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.34;

11.34
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.33;

11.33
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.32;

11.32
date	2004.02.02.17.39.20;	author morrison;	state Exp;
branches;
next	11.31;

11.31
date	2002.08.20.17.07.59;	author jra;	state Exp;
branches
	11.31.2.1
	11.31.4.1
	11.31.10.1;
next	11.30;

11.30
date	2002.08.15.20.55.12;	author hartley;	state Exp;
branches;
next	11.29;

11.29
date	2001.10.02.19.24.29;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	2001.05.17.20.05.24;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2001.04.20.22.29.45;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2000.09.08.05.54.41;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.08.21.02.02.30;	author butler;	state Exp;
branches;
next	11.24;

11.24
date	2000.07.13.11.55.54;	author pjt;	state Exp;
branches;
next	11.23;

11.23
date	2000.07.13.02.36.26;	author cjohnson;	state Exp;
branches;
next	11.22;

11.22
date	2000.07.10.23.01.32;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.07.08.01.46.52;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	2000.06.30.15.38.03;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.06.30.15.31.14;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.06.29.18.27.00;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.06.29.14.56.23;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.06.29.14.44.09;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	2000.06.28.18.22.20;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	2000.05.10.00.55.54;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.04.12.02.34.33;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.03.28.21.59.05;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.12.18.02.21.02;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.11.26.21.46.47;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.11.24.23.12.08;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.11.17.04.39.20;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.11.17.02.41.59;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.07.02.22.19.23;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.05.27.19.10.38;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.07.23.06.53.39;	author gdurf;	state Exp;
branches;
next	11.3;

11.3
date	97.07.15.13.18.08;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	97.06.17.19.26.47;	author gdurf;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.42;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.09.30.16.24.41;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.08.23.17.27.39;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.05.05.21.40.13;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	93.11.10.04.05.20;	author cjohnson;	state Exp;
branches;
next	10.3;

10.3
date	93.07.20.15.34.18;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.05.28.11.14.13;	author jra;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.16;	author mike;	state Rel4_0;
branches;
next	9.20;

9.20
date	91.09.20.23.07.49;	author butler;	state Exp;
branches;
next	9.19;

9.19
date	91.08.29.22.15.16;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.07.16.00.31.20;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.06.30.00.10.50;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.06.22.22.30.23;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.05.18.03.00.56;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.01.28.23.53.11;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.01.26.03.14.48;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.01.25.21.52.10;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.01.25.21.18.51;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.01.25.20.35.37;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.01.15.23.42.42;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.01.15.01.34.16;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.01.14.23.40.40;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.01.12.08.36.59;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.10.06.02.05.13;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.05.04.08.13.10;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.03.14.15.05.52;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.12.08.21.32.56;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.15;	author mike;	state Rel3_5;
branches;
next	8.6;

8.6
date	89.04.17.17.19.42;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.04.11.12.05.14;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.04.08.02.48.15;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.07.01.59.40;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.02.39;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.31.17;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.05.14.00.01.06;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.06.05.25.54;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.33.32;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.55.50;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.11.32;	author mike;	state Rel;
branches;
next	4.8;

4.8
date	87.05.28.21.25.47;	author mike;	state Exp;
branches;
next	4.7;

4.7
date	87.04.28.00.27.43;	author phil;	state Exp;
branches;
next	4.6;

4.6
date	87.03.23.23.41.51;	author mike;	state Exp;
branches;
next	4.5;

4.5
date	87.03.17.15.51.34;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.03.10.23.42.52;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.12.22.11.18;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.28.21.00.15;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.45.16;	author mike;	state Rel1;
branches;
next	1.7;

1.7
date	86.12.24.08.05.47;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.12.18.15.05.02;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.11.07.05.44.38;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.08.12.04.15.42;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.07.24.06.10.13;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.07.22.03.45.23;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.07.19.04.41.34;	author mike;	state Exp;
branches;
next	;

11.31.2.1
date	2002.09.19.18.01.34;	author morrison;	state Exp;
branches;
next	11.31.2.2;

11.31.2.2
date	2004.03.17.21.18.46;	author morrison;	state Exp;
branches;
next	;

11.31.4.1
date	2004.03.11.23.43.38;	author morrison;	state Exp;
branches;
next	;

11.31.10.1
date	2004.02.12.18.37.41;	author erikg;	state Exp;
branches;
next	11.31.10.2;

11.31.10.2
date	2004.03.15.14.07.19;	author erikg;	state Exp;
branches;
next	;


desc
@Intersect a ray with a halfspace
@


11.35
log
@moved to src/
@
text
@/*
 *			G _ H A L F . C
 *  
 *  Function -
 *  	Intersect a ray with a Halfspace
 *
 *
 *  A HALFSPACE is defined by an outward pointing normal vector,
 *  and the distance from the origin to the plane, which is defined
 *  by N and d.
 *
 *  With outward pointing normal vectors,
 *  the ray enters the half-space defined by a plane when D dot N < 0,
 *  is parallel to the plane when D dot N = 0, and exits otherwise.
 *
 *  The inside of the halfspace bounded by the plane
 *  consists of all points P such that
 *	VDOT(P,N) - N[3] <= 0,
 *
 *  where N[3] stores the value d.
 *  See the remarks in h/vmath.h for more details.
 *  
 *  Authors -
 *	Michael John Muuss
 *	Dave Becker		(Vectorization)
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCShalf[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_half.c,v 11.34 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "nmg.h"
#include "db.h"
#include "rtgeom.h"
#include "./debug.h"

struct half_specific  {
	plane_t	half_eqn;		/* Plane equation, outward normal */
	vect_t	half_Xbase;		/* "X" basis direction */
	vect_t	half_Ybase;		/* "Y" basis direction */
};
#define HALF_NULL	((struct half_specific *)0)

const struct bu_structparse rt_hlf_parse[] = {
    { "%f", 3, "N", offsetof(struct rt_half_internal, eqn[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "d", offsetof(struct rt_half_internal, eqn[3]), BU_STRUCTPARSE_FUNC_NULL },
    { {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
};
/*
 *  			R T _ H L F _ P R E P
 */
int
rt_hlf_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_half_internal	*hip;
	register struct half_specific *halfp;

	hip = (struct rt_half_internal *)ip->idb_ptr;
	RT_HALF_CK_MAGIC(hip);

	/*
	 * Process a HALFSPACE, which is represented as a 
	 * normal vector, and a distance.
	 */
	BU_GETSTRUCT( halfp, half_specific );
	stp->st_specific = (genptr_t)halfp;

	VMOVE( halfp->half_eqn, hip->eqn );
	halfp->half_eqn[3] = hip->eqn[3];

	/* Select one point on the halfspace as the "center" */
	VSCALE( stp->st_center, halfp->half_eqn, halfp->half_eqn[3] );

	/* X and Y basis for uv map */
	bn_vec_perp( halfp->half_Xbase, halfp->half_eqn );
	VCROSS( halfp->half_Ybase, halfp->half_Xbase, halfp->half_eqn );
	VUNITIZE( halfp->half_Xbase );
	VUNITIZE( halfp->half_Ybase );

	/* No bounding sphere or bounding RPP is possible */
	VSETALL( stp->st_min, -INFINITY);
	VSETALL( stp->st_max,  INFINITY);

	stp->st_aradius = INFINITY;
	stp->st_bradius = INFINITY;
	return(0);		/* OK */
}

/*
 *  			R T _ H L F _ P R I N T
 */
void
rt_hlf_print(register const struct soltab *stp)
{
	register const struct half_specific *halfp =
		(struct half_specific *)stp->st_specific;

	if( halfp == HALF_NULL )  {
		bu_log("half(%s):  no data?\n", stp->st_name);
		return;
	}
	VPRINT( "Normal", halfp->half_eqn );
	bu_log( "d = %f\n", halfp->half_eqn[3] );
	VPRINT( "Xbase", halfp->half_Xbase );
	VPRINT( "Ybase", halfp->half_Ybase );
}

/*
 *			R T _ H L F _ S H O T
 *  
 * Function -
 *	Shoot a ray at a HALFSPACE
 *
 * Algorithm -
 * 	The intersection distance is computed.
 *  
 * Returns -
 *	0	MISS
 *	>0	HIT
 */
int
rt_hlf_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct half_specific *halfp =
		(struct half_specific *)stp->st_specific;
	LOCAL fastf_t	in, out;	/* ray in/out distances */

	in = -INFINITY;
	out = INFINITY;

	{
		FAST fastf_t	slant_factor;	/* Direction dot Normal */
		FAST fastf_t	norm_dist;

		norm_dist = VDOT( halfp->half_eqn, rp->r_pt ) - halfp->half_eqn[3];
		if( (slant_factor = -VDOT( halfp->half_eqn, rp->r_dir )) < -1.0e-10 )  {
			/* exit point, when dir.N < 0.  out = min(out,s) */
			out = norm_dist/slant_factor;
			if( !NEAR_ZERO(out, INFINITY) )
				return(0);	/* MISS */
		} else if ( slant_factor > 1.0e-10 )  {
			/* entry point, when dir.N > 0.  in = max(in,s) */
			in = norm_dist/slant_factor;
			if( !NEAR_ZERO(in, INFINITY) )
				return(0);	/* MISS */
		}  else  {
			/* ray is parallel to plane when dir.N == 0.
			 * If it is outside the solid, stop now */
			if( norm_dist > 0.0 )
				return(0);	/* MISS */
		}
	}
	if( RT_G_DEBUG & DEBUG_ARB8 )
		bu_log("half: in=%f, out=%f\n", in, out);

	{
		register struct seg *segp;

		RT_GET_SEG( segp, ap->a_resource );
		segp->seg_stp = stp;
		segp->seg_in.hit_dist = in;
		segp->seg_out.hit_dist = out;
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	}
	return(2);			/* HIT */
}

#define RT_HALF_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ H L F _ V S H O T
 *
 *  This is the Becker vector version
 */
void
rt_hlf_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	register int    i;
	register struct half_specific *halfp;
	LOCAL fastf_t	in, out;	/* ray in/out distances */
	FAST fastf_t	slant_factor;	/* Direction dot Normal */
	FAST fastf_t	norm_dist;

	/* for each ray/halfspace pair */
#	include "noalias.h"
	for(i = 0; i < n; i++){
		if (stp[i] == 0) continue; /* indicates "skip this pair" */

		halfp = (struct half_specific *)stp[i]->st_specific;

		in = -INFINITY;
		out = INFINITY;

		norm_dist = VDOT(halfp->half_eqn, rp[i]->r_pt) - halfp->half_eqn[3];

		if((slant_factor = -VDOT(halfp->half_eqn, rp[i]->r_dir)) <
								-1.0e-10) {
			/* exit point, when dir.N < 0.  out = min(out,s) */
			out = norm_dist/slant_factor;
		} else if ( slant_factor > 1.0e-10 )  {
			/* entry point, when dir.N > 0.  in = max(in,s) */
			in = norm_dist/slant_factor;
		}  else  {
			/* ray is parallel to plane when dir.N == 0.
			 * If it is outside the solid, stop now */
			if( norm_dist > 0.0 ) {
				RT_HALF_SEG_MISS(segp[i]);	/* No hit */
			        continue;
			}
		}

		/* HIT */
		segp[i].seg_stp = stp[i];
		segp[i].seg_in.hit_dist = in;
		segp[i].seg_out.hit_dist = out;
	}
}

/*
 *  			R T _ H L F _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 *  The normal is already filled in.
 */
void
rt_hlf_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct half_specific *halfp =
		(struct half_specific *)stp->st_specific;
	FAST fastf_t f;

	RT_CK_SOLTAB(stp);
	RT_CK_RAY(rp);

	/*
	 * At most one normal is really defined, but whichever one
	 * it is, it has value half_eqn.
	 */
	VMOVE( hitp->hit_normal, halfp->half_eqn );

	/* We are expected to compute hit_point here.  May be infinite. */
	f = hitp->hit_dist;
	if( f <= -INFINITY )  {
		bu_log("rt_hlf_norm:  hit_dist = -INFINITY, unable to compute pt.\n");
		VSETALL( hitp->hit_point, -INFINITY );
	} else if( f >= INFINITY )  {
		bu_log("rt_hlf_norm:  hit_dist = +INFINITY, unable to compute pt.\n");
		VSETALL( hitp->hit_point, INFINITY );
	} else {
		VJOIN1( hitp->hit_point, rp->r_pt, f, rp->r_dir );
	}
}

/*
 *			R T _ H L F _ C U R V E
 *
 *  Return the "curvature" of the halfspace.
 *  Pick a principle direction orthogonal to normal, and 
 *  indicate no curvature.
 */
void
rt_hlf_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	register struct half_specific *halfp =
		(struct half_specific *)stp->st_specific;

	bn_vec_ortho( cvp->crv_pdir, halfp->half_eqn );
	cvp->crv_c1 = cvp->crv_c2 = 0;
}

/*
 *  			R T _ H L F _ U V
 *  
 *  For a hit on a face of an HALF, return the (u,v) coordinates
 *  of the hit point.  0 <= u,v <= 1.
 *  u extends along the Xbase direction
 *  v extends along the "Ybase" direction
 *  Note that a "toroidal" map is established, varying each from
 *  0 up to 1 and then back down to 0 again.
 */
void
rt_hlf_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct half_specific *halfp =
		(struct half_specific *)stp->st_specific;
	LOCAL vect_t P_A;
	FAST fastf_t f;
	auto double ival;

	f = hitp->hit_dist;
	if( f <= -INFINITY || f >= INFINITY )  {
		bu_log("rt_hlf_uv:  infinite dist\n");
		rt_pr_hit( "rt_hlf_uv", hitp );
		uvp->uv_u = uvp->uv_v = 0;
		uvp->uv_du = uvp->uv_dv = 0;
		return;
	}
	VSUB2( P_A, hitp->hit_point, stp->st_center );

	f = VDOT( P_A, halfp->half_Xbase )/10000;
	if( f <= -INFINITY || f >= INFINITY )  {
		bu_log("rt_hlf_uv:  bad X vdot\n");
		VPRINT("Xbase", halfp->half_Xbase);
		rt_pr_hit( "rt_hlf_uv", hitp );
		VPRINT("st_center", stp->st_center );
		f = 0;
	}
	if( f < 0 )  f = -f;
	f = modf( f, &ival );
	if( f < 0.5 )
		uvp->uv_u = 2 * f;		/* 0..1 */
	else
		uvp->uv_u = 2 * (1 - f);	/* 1..0 */

	f = VDOT( P_A, halfp->half_Ybase )/10000;
	if( f <= -INFINITY || f >= INFINITY )  {
		bu_log("rt_hlf_uv:  bad Y vdot\n");
		VPRINT("Xbase", halfp->half_Ybase);
		rt_pr_hit( "rt_hlf_uv", hitp );
		VPRINT("st_center", stp->st_center );
		f = 0;
	}
	if( f < 0 )  f = -f;
	f = modf( f, &ival );
	if( f < 0.5 )
		uvp->uv_v = 2 * f;		/* 0..1 */
	else
		uvp->uv_v = 2 * (1 - f);	/* 1..0 */

	if( uvp->uv_u < 0 || uvp->uv_v < 0 )  {
		if( RT_G_DEBUG )
			bu_log("half_uv: bad uv=%f,%f\n", uvp->uv_u, uvp->uv_v);
		/* Fix it up */
		if( uvp->uv_u < 0 )  uvp->uv_u = (-uvp->uv_u);
		if( uvp->uv_v < 0 )  uvp->uv_v = (-uvp->uv_v);
	}
	
	uvp->uv_du = uvp->uv_dv =
		(ap->a_rbeam + ap->a_diverge * hitp->hit_dist) / (10000/2);
	if( uvp->uv_du < 0 || uvp->uv_dv < 0 )  {
		rt_pr_hit( "rt_hlf_uv", hitp );
		uvp->uv_du = uvp->uv_dv = 0;
	}
}

/*
 *			R T _ H L F _ F R E E
 */
void
rt_hlf_free(struct soltab *stp)
{
	register struct half_specific *halfp =
		(struct half_specific *)stp->st_specific;

	bu_free( (char *)halfp, "half_specific");
}

/*
 *			R T _ H L F _ C L A S S
 *
 *  Classify this halfspace against a bounding RPP.
 *  Since this is an infinite solid, it is very important that this
 *  function properly.
 *
 *  Returns -
 *	BN_CLASSIFY_INSIDE
 *	BN_CLASSIFY_OVERLAPPING
 *	BN_CLASSIFY_OUTSIDE
 */
int
rt_hlf_class(register const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
{
	register const struct half_specific *halfp =
		(struct half_specific *)stp->st_specific;

	if( halfp == HALF_NULL ) {
		bu_log( "half(%s):  no data?\n", stp->st_name );
		return 0;
	}

	return bn_hlf_class( halfp->half_eqn, min, max, tol );
}

/*
 *			R T _ H L F _ P L O T
 *
 *  The representation of a halfspace is an OUTWARD pointing
 *  normal vector, and the distance of the plane from the origin.
 *
 *  Drawing a halfspace is difficult when using a finite display.
 *  Drawing the boundary plane is hard enough.
 *  We just make a cross in the plane, with the outward normal
 *  drawn shorter.
 */
int
rt_hlf_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct rt_half_internal	*hip;
	vect_t cent;		/* some point on the plane */
	vect_t xbase, ybase;	/* perpendiculars to normal */
	vect_t x1, x2;
	vect_t y1, y2;
	vect_t tip;

	RT_CK_DB_INTERNAL(ip);
	hip = (struct rt_half_internal *)ip->idb_ptr;
	RT_HALF_CK_MAGIC(hip);

	/* Invent a "center" point on the plane -- point closets to origin */
	VSCALE( cent, hip->eqn, hip->eqn[3] );

	/* The use of "x" and "y" here is not related to the axis */
	bn_vec_perp( xbase, &hip->eqn[0] );
	VCROSS( ybase, xbase, hip->eqn );

	/* Arrange for the cross to be 2 meters across */
	VUNITIZE( xbase );
	VUNITIZE( ybase);
	VSCALE( xbase, xbase, 1000 );
	VSCALE( ybase, ybase, 1000 );

	VADD2( x1, cent, xbase );
	VSUB2( x2, cent, xbase );
	VADD2( y1, cent, ybase );
	VSUB2( y2, cent, ybase );

	RT_ADD_VLIST( vhead, x1, BN_VLIST_LINE_MOVE );	/* the cross */
	RT_ADD_VLIST( vhead, x2, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, y1, BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, y2, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, x2, BN_VLIST_LINE_DRAW );	/* the box */
	RT_ADD_VLIST( vhead, y1, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, x1, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, y2, BN_VLIST_LINE_DRAW );

	VSCALE( tip, hip->eqn, 500 );
	VADD2( tip, cent, tip );
	RT_ADD_VLIST( vhead, cent, BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, tip, BN_VLIST_LINE_DRAW );
	return(0);
}
/*
 *			H A L F _ X F O R M
 *
 *  Returns -
 *	-1	failure
 *	 0	success
 */
int
rt_hlf_xform(
	struct rt_db_internal	*op,
	const mat_t		mat,
	struct rt_db_internal *ip,
	int		free,
	struct db_i	*dbip,
	struct resource	*resp)
{
	struct rt_half_internal *hip, *hop;
	point_t			orig_pt, pt;
	register double		f,t;

	RT_CK_DB_INTERNAL( ip );
	hip = (struct rt_half_internal *)ip->idb_ptr;
	RT_HALF_CK_MAGIC(hip);
	RT_CK_DB_INTERNAL( op );
	hop = (struct rt_half_internal *)op->idb_ptr;
	RT_HALF_CK_MAGIC(hop);

	/* Pick a point on the original halfspace */
	VSCALE( orig_pt, hip->eqn, hip->eqn[1*ELEMENTS_PER_VECT] );

	/* Transform the picked point and the normal */
	MAT4X3VEC( hop->eqn, mat, hip->eqn);
	MAT4X3PNT( pt, mat, orig_pt);

	/*
	 * We are done with the input solid so free it if required.
	 */
	if (free && ip != op)
		rt_db_free_internal( ip, resp );

	/*
	 * The transformed normal is all that is required.
	 * The new distance is found from the transforemd point on the plane.
	 */
	hop->eqn[3] = VDOT( pt, hop->eqn );

	/* Now some safety.  Verify that the normal has unit length */
	f = MAGNITUDE( hop->eqn);
	if ( f < SMALL ) {
		bu_log("rt_half_xform: bad normal, len = %g\n", f);
		return(-1);
	}
	t = f - 1.0;
	if ( !NEAR_ZERO( t, 0.001 ) ) {
		/* Restore normal to unit length */
		f = 1/f;
		VSCALE( hop->eqn, hop->eqn, f );
		hip->eqn[3] *= f;
	}
	return 0;
}
/*
 *			H A L F _ I M P O R T
 *
 *  Returns -
 *	-1	failure
 *	 0	success
 */
int
rt_hlf_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_half_internal	*hip;
	union record	*rp;
	point_t		orig_pt;
	point_t		pt;
	fastf_t		orig_eqn[3*2];
	register double	f,t;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_hlf_import: defective record, id=x%x\n", rp->u_id);
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_HALF;
	ip->idb_meth = &rt_functab[ID_HALF];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_half_internal), "rt_half_internal");
	hip = (struct rt_half_internal *)ip->idb_ptr;
	hip->magic = RT_HALF_INTERNAL_MAGIC;

	rt_fastf_float( orig_eqn, rp->s.s_values, 2 );	/* 2 floats too many */

	/* Pick a point on the original halfspace */
	VSCALE( orig_pt, orig_eqn, orig_eqn[1*ELEMENTS_PER_VECT] );

	/* Transform the point, and the normal */
	MAT4X3VEC( hip->eqn, mat, orig_eqn );
	MAT4X3PNT( pt, mat, orig_pt );

	/*
	 *  The transformed normal is all that is required.
	 *  The new distance is found from the transformed point on the plane.
	 */
	hip->eqn[3] = VDOT( pt, hip->eqn );

	/* Verify that normal has unit length */
	f = MAGNITUDE( hip->eqn );
	if( f < SMALL )  {
		bu_log("rt_hlf_import:  bad normal, len=%g\n", f );
		return(-1);		/* BAD */
	}
	t = f - 1.0;
	if( !NEAR_ZERO( t, 0.001 ) )  {
		/* Restore normal to unit length */
		f = 1/f;
		VSCALE( hip->eqn, hip->eqn, f );
		hip->eqn[3] *= f;
	}
	return(0);			/* OK */
}

/*
 *			R T _ H L F _ E X P O R T
 */
int
rt_hlf_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_half_internal	*hip;
	union record		*rec;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_HALF )  return(-1);
	hip = (struct rt_half_internal *)ip->idb_ptr;
	RT_HALF_CK_MAGIC(hip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "half external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->s.s_type = HALFSPACE;
	VMOVE( rec->s.s_values, hip->eqn );
	rec->s.s_values[3] = hip->eqn[3] * local2mm;

	return(0);
}

/*
 *			R T _ H L F _ I M P O R T 5
 */
int
rt_hlf_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_half_internal	*hip;
	point_t			tmp_pt, new_pt;
	plane_t			tmp_plane;
	register double		f,t;

	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 4 );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_HALF;
	ip->idb_meth = &rt_functab[ID_HALF];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_half_internal), "rt_half_internal");

	hip = (struct rt_half_internal *)ip->idb_ptr;
	hip->magic = RT_HALF_INTERNAL_MAGIC;

	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)tmp_plane, ep->ext_buf, 4 );

	/* to apply modeling transformations, create a temporary
	 * normal vector and point on the plane
	 */
	VSCALE( tmp_pt, tmp_plane, tmp_plane[3] );

	/* transform both the point and the vector */
	MAT4X3VEC( hip->eqn, mat, tmp_plane );
	MAT4X3PNT( new_pt, mat, tmp_pt );

	/* and calculate the new distance */
	hip->eqn[3] = VDOT( hip->eqn, new_pt );

	/* Verify that normal has unit length */
	f = MAGNITUDE( hip->eqn );
	if( f < SMALL )  {
		bu_log("rt_hlf_import:  bad normal, len=%g\n", f );
		return(-1);		/* BAD */
	}
	t = f - 1.0;
	if( !NEAR_ZERO( t, 0.001 ) )  {
		/* Restore normal to unit length */
		f = 1/f;
		VSCALE( hip->eqn, hip->eqn, f );
		hip->eqn[3] *= f;
	}
	return(0);			/* OK */
}

/*
 *		R T _ H A L F _ E X P O R T 5
 */
int
rt_hlf_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_half_internal		*hip;
	fastf_t				scaled_dist;

	RT_CK_DB_INTERNAL( ip );
	if( ip->idb_type != ID_HALF ) return -1;
	hip = (struct rt_half_internal *)ip->idb_ptr;
	RT_HALF_CK_MAGIC( hip );

	BU_CK_EXTERNAL( ep );
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 4;
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "half external" );

	/* only the distance needs to be scaled */
	scaled_dist = hip->eqn[3] * local2mm;

	/* Convert from internal (host) to database (network) format */
	/* the normal */
	htond( (unsigned char *)ep->ext_buf, (unsigned char *)hip->eqn, 3 );
	/* the distance */
	htond( ((unsigned char *)(ep->ext_buf)) + SIZEOF_NETWORK_DOUBLE*3,
		(unsigned char *)&scaled_dist, 1);

	return 0;
}

/*
 *			R T _ H L F _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_hlf_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_half_internal	*hip =
		(struct rt_half_internal *)ip->idb_ptr;
	char	buf[256];

	RT_HALF_CK_MAGIC(hip);
	bu_vls_strcat( str, "halfspace\n");

	sprintf(buf, "\tN (%g, %g, %g) d=%g\n",
		V3ARGS(hip->eqn),		/* should have unit length */
		hip->eqn[3] * mm2local );
	bu_vls_strcat( str, buf );

	return(0);
}

/*
 *			R T _ H L F _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_hlf_ifree(struct rt_db_internal *ip)
{
	RT_CK_DB_INTERNAL(ip);
	bu_free( ip->idb_ptr, "hlf ifree" );
	ip->idb_ptr = GENPTR_NULL;
}

/*
 *			R T _ H L F _ T E S S
 */
int
rt_hlf_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct rt_half_internal	*vip;
#if 0
	register int	i;
	struct shell	*s;
	struct vertex	**verts;	/* dynamic array of pointers */
	struct vertex	***vertp;	/* dynam array of ptrs to pointers */
	struct faceuse	*fu;
#endif

	RT_CK_DB_INTERNAL(ip);
	vip = (struct rt_half_internal *)ip->idb_ptr;
	RT_HALF_CK_MAGIC(vip);

	/* XXX tess routine needed */
	return(-1);
}
@


11.34
log
@change conf.h to a wrapped config.h
@
text
@d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header: /cvs/brlcad/librt/g_half.c,v 11.33 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.33
log
@merge of ansi-6-0-branch into HEAD
@
text
@d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header$ (BRL)";
d40 5
a44 1
#include "conf.h"
@


11.32
log
@update copyright to include span through 2003
@
text
@d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.31 2002/08/20 17:07:59 jra Exp $ (BRL)";
d69 1
a69 4
rt_hlf_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d109 1
a109 2
rt_hlf_print( stp )
register const struct soltab *stp;
d138 1
a138 5
rt_hlf_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d192 6
a197 6
rt_hlf_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d247 1
a247 4
rt_hlf_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d283 1
a283 4
rt_hlf_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d303 1
a303 5
rt_hlf_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d371 1
a371 2
rt_hlf_free( stp )
struct soltab *stp;
d392 1
a392 4
rt_hlf_class( stp, min, max, tol )
register const struct soltab	*stp;
const vect_t			 min, max;
const struct bn_tol		*tol;
d417 1
a417 5
rt_hlf_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal 	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d532 1
a532 5
rt_hlf_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d591 1
a591 5
rt_hlf_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d618 1
a618 5
rt_hlf_import5( ip, ep, mat, dbip )
struct rt_db_internal           *ip;
const struct bu_external        *ep;
register const mat_t            mat;
const struct db_i               *dbip;
d673 1
a673 5
rt_hlf_export5( ep, ip, local2mm, dbip )
struct bu_external              *ep;
const struct rt_db_internal     *ip;
double                          local2mm;
const struct db_i               *dbip;
d708 1
a708 5
rt_hlf_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d731 1
a731 2
rt_hlf_ifree( ip )
struct rt_db_internal	*ip;
d742 1
a742 6
rt_hlf_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
@


11.31
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d33 1
a33 1
 *	This software is Copyright (C) 1985 by the United States Army.
d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.29 2001/10/02 19:24:29 jra Exp $ (BRL)";
@


11.31.4.1
log
@sync to HEAD...
@
text
@d33 1
a33 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_half.c,v 11.32 2004/02/02 17:39:20 morrison Exp $ (BRL)";
@


11.31.10.1
log
@merge from HEAD
@
text
@d33 1
a33 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.32 2004/02/02 17:39:20 morrison Exp $ (BRL)";
@


11.31.10.2
log
@merge from head
@
text
@d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.31.10.1 2004/02/12 18:37:41 erikg Exp $ (BRL)";
@


11.31.2.1
log
@Initial ANSIfication
@
text
@d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.31 2002/08/20 17:07:59 jra Exp $ (BRL)";
d69 4
a72 1
rt_hlf_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d112 2
a113 1
rt_hlf_print(register const struct soltab *stp)
d142 5
a146 1
rt_hlf_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d200 6
a205 6
rt_hlf_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d255 4
a258 1
rt_hlf_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d294 4
a297 1
rt_hlf_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d317 5
a321 1
rt_hlf_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d389 2
a390 1
rt_hlf_free(struct soltab *stp)
d411 4
a414 1
rt_hlf_class(register const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
d439 5
a443 1
rt_hlf_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d558 5
a562 1
rt_hlf_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d621 5
a625 1
rt_hlf_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d652 5
a656 1
rt_hlf_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d711 5
a715 1
rt_hlf_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d750 5
a754 1
rt_hlf_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d777 2
a778 1
rt_hlf_ifree(struct rt_db_internal *ip)
d789 6
a794 1
rt_hlf_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
@


11.31.2.2
log
@sync branch with HEAD
@
text
@d33 1
a33 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header$ (BRL)";
@


11.30
log
@Converted from K&R to ANSI C - RFH
@
text
@d69 4
a72 1
rt_hlf_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d112 2
a113 1
rt_hlf_print(register const struct soltab *stp)
d142 5
a146 1
rt_hlf_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d200 6
a205 6
rt_hlf_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d255 4
a258 1
rt_hlf_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d294 4
a297 1
rt_hlf_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d317 5
a321 1
rt_hlf_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d389 2
a390 1
rt_hlf_free(struct soltab *stp)
d411 4
a414 1
rt_hlf_class(register const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
d439 5
a443 1
rt_hlf_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d558 5
a562 1
rt_hlf_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d621 5
a625 1
rt_hlf_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d652 5
a656 1
rt_hlf_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d711 5
a715 1
rt_hlf_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d750 5
a754 1
rt_hlf_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d777 2
a778 1
rt_hlf_ifree(struct rt_db_internal *ip)
d789 6
a794 1
rt_hlf_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
@


11.29
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.28 2001/05/17 20:05:24 morrison Exp $ (BRL)";
d69 1
a69 4
rt_hlf_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d109 1
a109 2
rt_hlf_print( stp )
register const struct soltab *stp;
d138 1
a138 5
rt_hlf_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d192 6
a197 6
rt_hlf_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d247 1
a247 4
rt_hlf_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d283 1
a283 4
rt_hlf_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d303 1
a303 5
rt_hlf_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d371 1
a371 2
rt_hlf_free( stp )
struct soltab *stp;
d392 1
a392 4
rt_hlf_class( stp, min, max, tol )
register const struct soltab	*stp;
const vect_t			 min, max;
const struct bn_tol		*tol;
d417 1
a417 5
rt_hlf_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal 	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d532 1
a532 5
rt_hlf_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d591 1
a591 5
rt_hlf_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d618 1
a618 5
rt_hlf_import5( ip, ep, mat, dbip )
struct rt_db_internal           *ip;
const struct bu_external        *ep;
register const mat_t            mat;
const struct db_i               *dbip;
d673 1
a673 5
rt_hlf_export5( ep, ip, local2mm, dbip )
struct bu_external              *ep;
const struct rt_db_internal     *ip;
double                          local2mm;
const struct db_i               *dbip;
d708 1
a708 5
rt_hlf_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d731 1
a731 2
rt_hlf_ifree( ip )
struct rt_db_internal	*ip;
d742 1
a742 6
rt_hlf_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
@


11.28
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.27 2001/04/20 22:29:45 morrison Exp $ (BRL)";
d579 1
d668 1
@


11.27
log
@CONST to const
@
text
@d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.26 2000/09/08 05:54:41 mike Exp $ (BRL)";
d177 1
a177 1
	if( rt_g.debug & DEBUG_ARB8 )
d370 1
a370 1
		if( rt_g.debug )
@


11.26
log
@
Modified tree routines to take resource pointer.
@
text
@d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.25 2000/08/21 02:02:30 butler Exp $ (BRL)";
d60 1
a60 1
CONST struct bu_structparse rt_hlf_parse[] = {
d113 1
a113 1
register CONST struct soltab *stp;
d115 1
a115 1
	register CONST struct half_specific *halfp =
d412 3
a414 3
register CONST struct soltab	*stp;
CONST vect_t			 min, max;
CONST struct bn_tol		*tol;
d416 1
a416 1
	register CONST struct half_specific *halfp =
d442 2
a443 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d499 1
a499 1
	CONST mat_t		mat,
d560 3
a562 3
CONST struct bu_external	*ep;
CONST mat_t			mat;
CONST struct db_i		*dbip;
d622 1
a622 1
CONST struct rt_db_internal	*ip;
d624 1
a624 1
CONST struct db_i		*dbip;
d653 3
a655 3
CONST struct bu_external        *ep;
register CONST mat_t            mat;
CONST struct db_i               *dbip;
d711 1
a711 1
CONST struct rt_db_internal     *ip;
d713 1
a713 1
CONST struct db_i               *dbip;
d750 1
a750 1
CONST struct rt_db_internal	*ip;
d791 2
a792 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
@


11.25
log
@Massive compilation warnings eliminated
@
text
@d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.24 2000/07/13 11:55:54 pjt Exp $ (BRL)";
d497 7
a503 6
rt_hlf_xform(op, mat, ip, free, dbip)
struct rt_db_internal	*op;
CONST mat_t		mat;
struct rt_db_internal *ip;
int	free;
struct db_i	*dbip;
d527 1
a527 1
		rt_db_free_internal( ip );
@


11.24
log
@added a scrap of clarification to one comment.
@
text
@d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.23 2000/07/13 02:36:26 cjohnson Exp $ (BRL)";
d63 2
a64 1
    {0,0,0,0,0} };
@


11.23
log
@LINT from gcc -Wall
@
text
@d18 1
a18 1
 *	VDOT(P,N) - N[3] <= 0
d20 1
d37 1
a37 1
static const char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.22 2000/07/10 23:01:32 mike Exp $ (BRL)";
@


11.22
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d36 1
a36 1
static const char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.20 2000/06/30 15:38:03 mike Exp $ (BRL)";
d62 1
a62 1
    {0} };
a656 1
	fastf_t			tmp_dist;
@


11.21
log
@Corrected errord in computation of "xbase" that have been here since veriosn 1.1
in plot and uv routines
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.20 2000/06/30 15:38:03 mike Exp $ (BRL)";
@


11.20
log
@
export methods should not init the external structure, just check them.
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.19 2000/06/30 15:31:14 mike Exp $ (BRL)";
d92 1
a92 1
	bn_vec_perp( halfp->half_Xbase, stp->st_center );
d458 1
a458 1
	bn_vec_perp( xbase, cent );
@


11.19
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.18 2000/06/29 18:27:00 mike Exp $ (BRL)";
d631 1
a631 1
	BU_INIT_EXTERNAL(ep);
d721 1
a721 1
	BU_INIT_EXTERNAL( ep );
@


11.18
log
@
lint
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.17 2000/06/29 14:56:23 mike Exp $ (BRL)";
d575 1
a575 1
	RT_INIT_DB_INTERNAL( ip );
d664 1
a664 1
	RT_INIT_DB_INTERNAL( ip );
@


11.17
log
@
rt_db_free_internal
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.16 2000/06/29 14:44:09 jra Exp $ (BRL)";
d730 1
a730 1
	htond( ep->ext_buf, (unsigned char *)hip->eqn, 3 );
d732 2
a733 1
	htond( (unsigned char *)(ep->ext_buf + SIZEOF_NETWORK_DOUBLE*3), (unsigned char *)&scaled_dist, 1);
@


11.16
log
@Added a cast for the SGI compiler
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.15 2000/06/28 18:22:20 jra Exp $ (BRL)";
d523 3
a525 4
	if (free && ip != op) {
		rt_functab[ip->idb_type].ft_ifree( ip );
		ip->idb_ptr = (genptr_t) 0;
	}
@


11.15
log
@Added some v5 database suport
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.14 2000/05/10 00:55:54 mike Exp $ (BRL)";
d733 1
a733 1
	htond( ep->ext_buf + SIZEOF_NETWORK_DOUBLE*3, (unsigned char *)&scaled_dist, 1);
@


11.14
log
@
Added comment to classifier.
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.13 2000/04/12 02:34:33 mike Exp $ (BRL)";
d643 93
@


11.13
log
@
NT port, non-compat4
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.12 2000/03/28 21:59:05 mike Exp $ (BRL)";
d396 12
@


11.12
log
@
Fixed arguments
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.11 1999/12/18 02:21:02 mike Exp $ (BRL)";
d92 1
a92 1
	vec_perp( halfp->half_Xbase, stp->st_center );
d300 1
a300 1
	vec_ortho( cvp->crv_pdir, halfp->half_eqn );
d446 1
a446 1
	vec_perp( xbase, cent );
d487 1
a487 1
CONST int	free;
@


11.11
log
@
Added some parameter checking
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.10 1999/11/26 21:46:47 mike Exp $ (BRL)";
d483 1
a483 1
rt_hlf_xform(op, mat, ip, free)
d488 1
@


11.10
log
@
Lint cleanups
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.9 1999/11/24 23:12:08 mike Exp $ (BRL)";
d261 3
@


11.9
log
@
Made structparse tables CONST
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.8 1999/11/17 04:39:20 mike Exp $ (BRL)";
d426 1
a426 1
struct bn_tol		*tol;
d540 1
a540 1
rt_hlf_import( ip, ep, mat )
d544 1
d602 1
a602 1
rt_hlf_export( ep, ip, local2mm )
d606 1
d639 1
a639 1
struct rt_db_internal	*ip;
d681 1
a681 1
struct bn_tol		*tol;
@


11.8
log
@
Added 3 new fields to rt_functab, in order to better support the TCL
interface to db get and db put.
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.7 1999/11/17 02:41:59 mike Exp $ (BRL)";
d59 1
a59 1
struct bu_structparse rt_hlf_parse[] = {
@


11.7
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.6 1999/07/02 22:19:23 mike Exp $ (BRL)";
d59 1
a59 1
struct bu_structparse rt_half_parse[] = {
@


11.6
log
@
Removed dependence on compat4.h
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.5 1999/05/27 19:10:38 mike Exp $ (BRL)";
d561 1
@


11.5
log
@
sed4
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_half.c,v 11.4 1997/07/23 06:53:39 gdurf Exp $ (BRL)";
d457 8
a464 8
	RT_ADD_VLIST( vhead, x1, RT_VLIST_LINE_MOVE );	/* the cross */
	RT_ADD_VLIST( vhead, x2, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, y1, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, y2, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, x2, RT_VLIST_LINE_DRAW );	/* the box */
	RT_ADD_VLIST( vhead, y1, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, x1, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, y2, RT_VLIST_LINE_DRAW );
d468 2
a469 2
	RT_ADD_VLIST( vhead, cent, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, tip, RT_VLIST_LINE_DRAW );
@


11.4
log
@rt_hlf_class now calls bn_hlf_class with the appropriate plane eqn.
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 11.3 1997/07/15 13:18:08 gdurf Exp gdurf $ (BRL)";
d82 1
a82 1
	GETSTRUCT( halfp, half_specific );
d117 1
a117 1
		rt_log("half(%s):  no data?\n", stp->st_name);
d121 1
a121 1
	rt_log( "d = %f\n", halfp->half_eqn[3] );
d176 1
a176 1
		rt_log("half: in=%f, out=%f\n", in, out);
d185 1
a185 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d271 1
a271 1
		rt_log("rt_hlf_norm:  hit_dist = -INFINITY, unable to compute pt.\n");
d274 1
a274 1
		rt_log("rt_hlf_norm:  hit_dist = +INFINITY, unable to compute pt.\n");
d326 1
a326 1
		rt_log("rt_hlf_uv:  infinite dist\n");
d336 1
a336 1
		rt_log("rt_hlf_uv:  bad X vdot\n");
d351 1
a351 1
		rt_log("rt_hlf_uv:  bad Y vdot\n");
d366 1
a366 1
			rt_log("half_uv: bad uv=%f,%f\n", uvp->uv_u, uvp->uv_v);
d390 1
a390 1
	rt_free( (char *)halfp, "half_specific");
d403 1
a403 1
		rt_log( "half(%s):  no data?\n", stp->st_name );
d423 1
a423 1
struct rt_list		*vhead;
d426 1
a426 1
struct rt_tol		*tol;
d520 1
a520 1
		rt_log("rt_half_xform: bad normal, len = %g\n", f);
d542 1
a542 1
CONST struct rt_external	*ep;
d552 1
a552 1
	RT_CK_EXTERNAL( ep );
d555 1
a555 1
		rt_log("rt_hlf_import: defective record, id=x%x\n", rp->u_id);
d561 1
a561 1
	ip->idb_ptr = rt_malloc( sizeof(struct rt_half_internal), "rt_half_internal");
d583 1
a583 1
		rt_log("rt_hlf_import:  bad normal, len=%g\n", f );
d601 1
a601 1
struct rt_external		*ep;
d613 1
a613 1
	RT_INIT_EXTERNAL(ep);
d615 1
a615 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "half external");
d635 1
a635 1
struct rt_vls		*str;
d645 1
a645 1
	rt_vls_strcat( str, "halfspace\n");
d650 1
a650 1
	rt_vls_strcat( str, buf );
d665 1
a665 1
	rt_free( ip->idb_ptr, "hlf ifree" );
d678 1
a678 1
struct rt_tol		*tol;
@


11.3
log
@Added classify routine
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 11.2 1997/06/17 19:26:47 gdurf Exp gdurf $ (BRL)";
a400 2
	int class;
	fastf_t d;
d407 1
a407 29
#define CHECK_PT( x, y, z ) \
	d = (x)*halfp->half_eqn[0] + (y)*halfp->half_eqn[1] + (z)*halfp->half_eqn[2] - halfp->half_eqn[3]; \
	if( d < -tol->dist ) { \
		if( class == RT_CLASSIFY_OUTSIDE ) \
			return RT_CLASSIFY_OVERLAPPING; \
		else class = RT_CLASSIFY_INSIDE; \
	} else if( d > tol->dist ) { \
		if( class == RT_CLASSIFY_INSIDE ) \
			return RT_CLASSIFY_OVERLAPPING; \
		else class = RT_CLASSIFY_OUTSIDE; \
	} else return RT_CLASSIFY_OVERLAPPING

	class = 0;
	CHECK_PT( min[X], min[Y], min[Z] );
	CHECK_PT( min[X], min[Y], max[Z] );
	CHECK_PT( min[X], max[Y], min[Z] );
	CHECK_PT( min[X], max[Y], max[Z] );
	CHECK_PT( max[X], min[Y], min[Z] );
	CHECK_PT( max[X], min[Y], max[Z] );
	CHECK_PT( max[X], max[Y], min[Z] );
	CHECK_PT( max[X], max[Y], max[Z] );

	if( class == 0 )
		bu_log( "rt_hlf_class: error in implementation\
min = (%g, %g, %g), max = (%g, %g, %g), half_eqn = (%d, %d, %d, %d)\n",
			V3ARGS(min), V3ARGS(max), V3ARGS(halfp->half_eqn),
			halfp->half_eqn[3]);
	
	return class;
@


11.2
log
@Added bu_structparse (from tcl.c)
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 11.1 1995/01/04 09:56:42 mike Rel4_4 gdurf $ (BRL)";
d394 4
a397 1
rt_hlf_class()
d399 39
a437 1
	return(0);
@


11.1
log
@Release_4.4
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 10.7 94/09/30 16:24:41 mike Exp $ (BRL)";
d59 4
@


10.7
log
@Null out ip->idb_ptr after freeing memory in rt_*_ifree()
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 10.6 94/08/23 17:27:39 gdurf Exp Locker: mike $ (BRL)";
@


10.6
log
@Factored ifdefs, added include of conf.h
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 10.5 94/05/05 21:40:13 mike Exp $ (BRL)";
d651 1
@


10.5
log
@Prevent returning illegal (>INFINITY) distances.
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 10.4 93/11/10 04:05:20 cjohnson Exp Locker: mike $ (BRL)";
d39 2
d44 1
a50 4

#if defined(alliant) && !defined(__STDC__)
extern double   modf();
#endif
@


10.4
log
@Added first try on rt_hlf_xform().  The code does not work
due to a NULL pointer being passed in.  Currently the code
is by passed in table.c
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 10.3 1993/07/20 15:34:18 mike Exp cjohnson $ (BRL)";
d158 2
d163 2
@


10.3
log
@Comment in comment.
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 10.2 93/05/28 11:14:13 jra Exp Locker: mike $ (BRL)";
d454 44
d499 15
@


10.2
log
@Corrected magic number check for tessellate routine
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 10.1 91/10/12 06:40:16 mike Rel4_0 Locker: jra $ (BRL)";
d603 7
a609 5
/*	register int	i;		*/
/*	struct shell	*s;		*/
/*	struct vertex	**verts;	/* dynamic array of pointers */
/*	struct vertex	***vertp;	/* dynam array of ptrs to pointers */
/*	struct faceuse	*fu;		*/
@


10.1
log
@Release_4.0
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.20 91/09/20 23:07:49 butler Exp $ (BRL)";
d611 1
a611 1
	RT_VOL_CK_MAGIC(vip);
@


9.20
log
@removing fuzz with lint
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.19 91/08/29 22:15:16 mike Exp $ (BRL)";
@


9.19
log
@Needs nmg.h
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.18 91/07/16 00:31:20 mike Exp $ (BRL)";
d603 5
a607 5
	register int	i;
	struct shell	*s;
	struct vertex	**verts;	/* dynamic array of pointers */
	struct vertex	***vertp;	/* dynam array of ptrs to pointers */
	struct faceuse	*fu;
@


9.18
log
@Added better error message to normal subroutine
for case when distance is infinite.
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.17 91/06/30 00:10:50 mike Exp $ (BRL)";
d44 1
@


9.17
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.16 91/06/22 22:30:23 mike Exp $ (BRL)";
d262 5
a266 2
	if( f <= -INFINITY || f >= INFINITY )  {
		rt_log("rt_hlf_norm:  dist=INFINITY, pt=?\n");
@


9.16
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.15 91/05/18 03:00:56 mike Exp $ (BRL)";
d107 1
a107 1
register struct soltab *stp;
d109 1
a109 1
	register struct half_specific *halfp =
d460 3
a462 3
struct rt_db_internal	*ip;
struct rt_external	*ep;
mat_t			mat;
d520 3
a522 3
struct rt_external	*ep;
struct rt_db_internal	*ip;
double			local2mm;
@


9.15
log
@Converted to new tolerance interface
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.14 91/01/28 23:53:11 mike Exp $ (BRL)";
d63 1
a63 1
rt_hlf_prep( stp, ip, rtip, tol )
a66 1
CONST struct rt_tol	*tol;
d136 1
a136 1
rt_hlf_shot( stp, rp, ap, seghead, tol )
a140 1
CONST struct rt_tol	*tol;
d190 1
a190 1
rt_hlf_vshot( stp, rp, segp, n, resp, tol )
d195 1
a195 2
struct resource         *resp; /* pointer to a list of free segs */
CONST struct rt_tol	*tol;
@


9.14
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.13 91/01/26 03:14:48 mike Exp $ (BRL)";
d63 1
a63 1
rt_hlf_prep( stp, ip, rtip )
d67 1
d137 1
a137 1
rt_hlf_shot( stp, rp, ap, seghead )
d142 1
d192 1
a192 1
rt_hlf_vshot( stp, rp, segp, n, resp)
d198 1
d403 5
a407 6
rt_hlf_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
struct rt_list	*vhead;
struct rt_db_internal *ip;
double		abs_tol;
double		rel_tol;
double		norm_tol;
d594 1
a594 1
rt_hlf_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d598 2
a599 3
double		abs_tol;
double		rel_tol;
double		norm_tol;
@


9.13
log
@Eliminated mat parameter on ft_plot and ft_tess
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.12 91/01/25 21:52:10 mike Exp $ (BRL)";
d401 1
a401 1
struct vlhead	*vhead;
d436 8
a443 8
	ADD_VL( vhead, x1, 0 );		/* the cross */
	ADD_VL( vhead, x2, 1 );
	ADD_VL( vhead, y1, 0 );
	ADD_VL( vhead, y2, 1 );
	ADD_VL( vhead, x2, 1 );		/* the box */
	ADD_VL( vhead, y1, 1 );
	ADD_VL( vhead, x1, 1 );
	ADD_VL( vhead, y2, 1 );
d447 2
a448 2
	ADD_VL( vhead, cent, 0 );
	ADD_VL( vhead, tip, 1 );
@


9.12
log
@lint
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.11 91/01/25 21:18:51 mike Exp $ (BRL)";
d400 1
a400 1
rt_hlf_plot( vhead, mat, ip, abs_tol, rel_tol, norm_tol )
a401 1
mat_t		mat;
d592 1
a592 1
rt_hlf_tess( r, m, ip, mat, abs_tol, rel_tol, norm_tol )
a595 1
register mat_t		mat;
@


9.11
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.10 91/01/25 20:35:37 mike Exp $ (BRL)";
d182 2
a183 1
#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	
d226 1
a226 1
				SEG_MISS(segp[i]);		/* No hit */
d593 8
a600 1
rt_hlf_tess()
d602 12
@


9.10
log
@Added rt_ prefix to _internal structure
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.9 91/01/15 23:42:42 mike Exp $ (BRL)";
a61 1
#if NEW_IF
a67 10
#else
int
rt_hlf_prep( stp, rec, rtip )
struct soltab	*stp;
union record	*rec;
struct rt_i	*rtip;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a70 12
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rec;
	ep->ext_nbytes = stp->st_dp->d_len*sizeof(union record);
	ip = &intern;
	if( rt_hlf_import( ip, ep, stp->st_pathmat ) < 0 )
		return(-1);		/* BAD */
	RT_CK_DB_INTERNAL( ip );
#endif
a397 1
#if NEW_IF
a406 11
#else
int
rt_hlf_plot( rp, mat, vhead, dp )
union record	*rp;
mat_t		mat;
struct vlhead	*vhead;
struct directory *dp;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a413 13
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	if( rt_hlf_import( &intern, ep, mat ) < 0 )  {
		rt_log("rt_hlf_plot(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
@


9.9
log
@Moved half_internal structure to rtgeom.h
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.8 91/01/15 01:34:16 mike Exp $ (BRL)";
d79 1
a79 1
	struct half_internal	*hip;
d94 1
a94 1
	hip = (struct half_internal *)ip->idb_ptr;
d442 1
a442 1
	struct half_internal	*hip;
d463 1
a463 1
	hip = (struct half_internal *)ip->idb_ptr;
d513 1
a513 1
	struct half_internal	*hip;
d529 2
a530 2
	ip->idb_ptr = rt_malloc( sizeof(struct half_internal), "half_internal");
	hip = (struct half_internal *)ip->idb_ptr;
d573 1
a573 1
	struct half_internal	*hip;
d578 1
a578 1
	hip = (struct half_internal *)ip->idb_ptr;
d608 2
a609 2
	register struct half_internal	*hip =
		(struct half_internal *)ip->idb_ptr;
@


9.8
log
@Fixed magic
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.7 91/01/14 23:40:40 mike Exp $ (BRL)";
d45 1
a50 7

struct half_internal  {
	long	magic;
	plane_t	eqn;
};
#define RT_HALF_INTERNAL_MAGIC	0xaabbdd87
#define RT_HALF_CK_MAGIC(_p)	RT_CKMAG(_p,RT_HALF_INTERNAL_MAGIC,"half_internal")
@


9.7
log
@Added magic number, export routine, units conversion
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.6 91/01/12 08:36:59 mike Exp $ (BRL)";
d537 1
@


9.6
log
@New import/export interface
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.5 90/10/06 02:05:13 mike Exp $ (BRL)";
d52 1
d55 2
d101 1
d470 1
d573 1
a573 1
rt_hlf_export( ep, ip )
d576 1
d578 19
a596 1
	return(-1);
d607 1
a607 1
rt_hlf_describe( str, ip, verbose )
d611 1
d617 1
d621 2
a622 1
		V3ARGS(hip->eqn), hip->eqn[3] );
d629 2
a631 1
 *  XXX The suffix of this name is temporary.
@


9.5
log
@Converted seg structures to use doubly linked lists.
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: /m/cad/librt/RCS/g_half.c,v 9.4 90/05/04 08:13:10 mike Exp $ (BRL)";
d51 4
d65 1
d67 7
d79 4
d85 14
d106 2
a107 5
	if( rt_hlf_import( halfp->half_eqn, rec, stp->st_pathmat ) < 0 )  {
		rt_log("rt_hlf_prep(%s): db import failure\n", stp->st_name);
		rt_free( (char *)halfp, "half_specific" );
		return(1);	/* BAD */
	}
d109 1
d423 1
d425 10
d441 4
a444 1
	plane_t	eqn;
d451 10
a460 3
	if( rt_hlf_import( eqn, rp, mat ) < 0 )  {
		rt_log("rt_hlf_plot(%s): db import failure\n", dp->d_namep);
		return(-1);
d462 4
d468 1
a468 1
	VSCALE( cent, eqn, eqn[3] );
d472 1
a472 1
	VCROSS( ybase, xbase, eqn );
d494 1
a494 1
	VSCALE( tip, eqn, 500 );
d509 4
a512 4
rt_hlf_import( eqn, rp, mat )
plane_t		eqn;
union record	*rp;
mat_t		mat;
d514 2
d521 2
d528 5
d539 1
a539 1
	MAT4X3VEC( eqn, mat, orig_eqn );
d546 1
a546 1
	eqn[3] = VDOT( pt, eqn );
d549 1
a549 1
	f = MAGNITUDE( eqn );
d558 2
a559 2
		VSCALE( eqn, eqn, f );
		eqn[3] *= f;
d562 49
@


9.4
log
@Routines all got rt_ prefixes
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: g_half.c,v 9.3 90/03/14 15:05:52 mike Locked $ (BRL)";
d130 1
a130 1
 *  	segp	HIT
d132 2
a133 2
struct seg *
rt_hlf_shot( stp, rp, ap )
d137 1
d161 1
a161 1
				return( SEG_NULL );	/* MISS */
d170 1
a170 1
		GET_SEG( segp, ap->a_resource );
d174 1
a174 1
		return(segp);			/* HIT */
d176 1
a176 1
	/* NOTREACHED */
a227 1
		segp[i].seg_next = SEG_NULL;
@


9.3
log
@Changed type of st_specific to genptr_t
@
text
@d2 1
a2 1
 *  			H A L F . C
d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: g_half.c,v 9.2 89/12/08 21:32:56 mike Locked $ (BRL)";
d59 1
a59 1
 *  			H L F _ P R E P
d62 1
a62 1
hlf_prep( stp, rec, rtip )
d76 2
a77 2
	if( hlf_import( halfp->half_eqn, rec, stp->st_pathmat ) < 0 )  {
		rt_log("hlf_prep(%s): db import failure\n", stp->st_name);
d100 1
a100 1
 *  			H L F _ P R I N T
d103 1
a103 1
hlf_print( stp )
d120 1
a120 1
 *			H L F _ S H O T
d133 1
a133 1
hlf_shot( stp, rp, ap )
d180 1
a180 1
 *			H L F _ V S H O T
d185 1
a185 1
hlf_vshot( stp, rp, segp, n, resp)
d235 1
a235 1
 *  			H L F _ N O R M
d241 1
a241 1
hlf_norm( hitp, stp, rp )
d259 1
a259 1
		rt_log("hlf_norm:  dist=INFINITY, pt=?\n");
d267 1
a267 1
 *			H L F _ C U R V E
d274 1
a274 1
hlf_curve( cvp, hitp, stp )
d287 1
a287 1
 *  			H L F _ U V
d297 1
a297 1
hlf_uv( ap, stp, hitp, uvp )
d311 2
a312 2
		rt_log("hlf_uv:  infinite dist\n");
		rt_pr_hit( "hlf_uv", hitp );
d321 1
a321 1
		rt_log("hlf_uv:  bad X vdot\n");
d323 1
a323 1
		rt_pr_hit( "hlf_uv", hitp );
d336 1
a336 1
		rt_log("hlf_uv:  bad Y vdot\n");
d338 1
a338 1
		rt_pr_hit( "hlf_uv", hitp );
d360 1
a360 1
		rt_pr_hit( "hlf_uv", hitp );
d366 1
a366 1
 *			H L F _ F R E E
d369 1
a369 1
hlf_free( stp )
d379 1
a379 1
hlf_class()
d385 1
a385 1
 *			H L F _ P L O T
d395 2
a396 2
void
hlf_plot( rp, mat, vhead, dp )
d409 3
a411 3
	if( hlf_import( eqn, rp, mat ) < 0 )  {
		rt_log("hlf_plot(%s): db import failure\n", dp->d_namep);
		return;
d445 1
d456 1
a456 1
hlf_import( eqn, rp, mat )
d467 1
a467 1
		rt_log("hlf_import: defective record, id=x%x\n", rp->u_id);
d489 1
a489 1
		rt_log("hlf_import:  bad normal, len=%g\n", f );
d500 9
@


9.2
log
@When a halfspace is transformed, it now works right.
@
text
@d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: g_half.c,v 9.1 89/05/19 05:56:15 mike Locked $ (BRL)";
d74 1
a74 1
	stp->st_specific = (int *)halfp;
@


9.1
log
@Release_3.5
@
text
@d6 15
d36 1
a36 1
static char RCShalf[] = "@@(#)$Header: g_half.c,v 8.6 89/04/17 17:19:42 mike Exp $ (BRL)";
a50 12
/*
 *			Ray/HALF Intersection
 *
 *  A HALFSPACE is defined by an outward pointing normal vector,
 *  and the distance from the origin to the plane, which is defined
 *  by N and d.
 *
 *  With outward pointing normal vectors,
 *  note that the ray enters the half-space defined by a plane when D cdot N <
 *  0, is parallel to the plane when D cdot N = 0, and exits otherwise.
 */

d52 1
a52 2
	fastf_t	half_d;			/* dist from origin along N */
	vect_t	half_N;			/* Unit-length Normal (outward) */
a67 2
	FAST fastf_t f;
	fastf_t	vec[3*2];
a68 2
	rt_fastf_float( vec, rec->s.s_values, 2 );	/* 2 floats too many */

d76 3
a78 4
	MAT4X3VEC( halfp->half_N, stp->st_pathmat, &vec[0] );
	f = MAGSQ( halfp->half_N );
	if( f < 0.001 )  {
		rt_log("half(%s):  bad normal\n", stp->st_name );
a80 7
	f -= 1.0;
	if( !NEAR_ZERO( f, 0.001 ) )  {
		rt_log("half(%s):  normal not unit length\n", stp->st_name );
		VUNITIZE( halfp->half_N );
	}
	halfp->half_d = vec[1*ELEMENTS_PER_VECT];
	VSCALE( stp->st_center, halfp->half_N, halfp->half_d );
d82 2
d86 1
a86 1
	VCROSS( halfp->half_Ybase, halfp->half_Xbase, halfp->half_N );
d113 2
a114 2
	VPRINT( "Normal", halfp->half_N );
	rt_log( "d = %f\n", halfp->half_d );
d149 2
a150 2
		norm_dist = VDOT( halfp->half_N, rp->r_pt ) - halfp->half_d;
		if( (slant_factor = -VDOT( halfp->half_N, rp->r_dir )) < -1.0e-10 )  {
d208 1
a208 1
		norm_dist = VDOT(halfp->half_N, rp[i]->r_pt) - halfp->half_d;
d210 1
a210 1
		if((slant_factor = -VDOT(halfp->half_N, rp[i]->r_dir)) <
d252 1
a252 1
	 * it is, it has value half_N.
d254 1
a254 1
	VMOVE( hitp->hit_normal, halfp->half_N );
d282 1
a282 1
	vec_ortho( cvp->crv_pdir, halfp->half_N );
d402 1
d407 1
a407 1
	vect_t tip;	
d409 8
a416 2
	/* "center" point on the plane */
	VSCALE( cent, &(rp[0].s.s_half_N), rp[0].s.s_half_d );
d419 2
a420 1
	VCROSS( ybase, xbase, &(rp[0].s.s_half_N) );
d441 1
a441 1
	VSCALE( tip, &(rp[0].s.s_half_N), 500 );
d445 54
@


8.6
log
@Calling sequence to xxx_prep() shortened from 6 to 3 args.
Database conversion moved into prep routines.
@
text
@d21 1
a21 1
static char RCShalf[] = "@@(#)$Header: g_half.c,v 8.5 89/04/11 12:05:14 mike Locked $ (BRL)";
@


8.5
log
@removed some unused variables
@
text
@d21 1
a21 1
static char RCShalf[] = "@@(#)$Header: half.c,v 8.4 89/04/08 02:48:15 phil Locked $ (BRL)";
d60 1
a60 2
hlf_prep( vec, stp, mat, rtip )
fastf_t		*vec;
d62 1
a62 1
matp_t		mat;
d67 1
d69 2
d78 1
a78 1
	VMOVE( halfp->half_N, &vec[0] );
@


8.4
log
@Includes Dave Becker's vectorized version
@
text
@d21 1
a21 1
static char RCShalf[] = "@@(#)$Header: half.c,v 8.3 89/01/07 01:59:40 mike Locked $ (BRL)";
a113 1
	register int i;
a407 1
	register int i, j;
@


8.3
log
@Alliant fix
@
text
@d7 1
a7 1
 *  Author -
d9 1
d21 1
a21 1
static char RCShalf[] = "@@(#)$Header: half.c,v 8.2 88/12/06 00:02:39 mike Locked $ (BRL)";
d183 56
@


8.2
log
@Added _plot() routines, and db_*() interfaces.
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: /cad/d/mike/cad/librt/RCS/half.c,v 1.3 88/11/27 19:06:56 mike Exp $ (BRL)";
d31 3
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 7.3 88/05/14 00:01:06 mike Exp $ (BRL)";
d28 1
d149 2
a150 2
		FAST fastf_t	dn;		/* Direction dot Normal */
		FAST fastf_t	dxbdn;
d152 2
a153 2
		dxbdn = VDOT( halfp->half_N, rp->r_pt ) - halfp->half_d;
		if( (dn = -VDOT( halfp->half_N, rp->r_dir )) < -1.0e-10 )  {
d155 2
a156 2
			out = dxbdn/dn;
		} else if ( dn > 1.0e-10 )  {
d158 1
a158 1
			in = dxbdn/dn;
d162 1
a162 1
			if( dxbdn > 0.0 )
d331 11
d343 5
a347 1
hlf_plot()
d349 36
@


7.3
log
@lint fixes
added zero _uv() routines to some modules
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 7.2 88/02/06 05:25:54 mike Locked $ (BRL)";
@


7.2
log
@Moved rt_orthovec to vec_ortho.
Moved rt_make_perp to vec_perp.
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 7.1 87/11/02 23:33:32 mike Locked $ (BRL)";
d54 1
d103 1
d186 1
d219 1
d242 1
d314 1
d324 1
d327 1
d330 1
@


7.1
log
@Release 2.3
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 6.1 87/07/11 07:55:50 mike Rel $ (BRL)";
a51 74
 *			R T _ M A K E _ P E R P
 *
 *  Given a vector, create another vector which is perpendicular to it,
 *  but may not have unit length.
 */
void
rt_make_perp( new, old )
vect_t new, old;
{
	register int i;
	LOCAL vect_t another;	/* Another vector, different */

	i = X;
	if( fabs(old[Y])<fabs(old[i]) )  i=Y;
	if( fabs(old[Z])<fabs(old[i]) )  i=Z;
	VSETALL( another, 0 );
	another[i] = 1.0;
	if( old[X] == 0 && old[Y] == 0 && old[Z] == 0 )  {
		VMOVE( new, another );
	} else {
		VCROSS( new, another, old );
	}
}

/*
 *			R T _ O R T H O V E C
 *
 *  Given a vector, create another vector which is perpendicular to it,
 *  and with unit length.  This algorithm taken from Gift's arvec.f;
 *  a faster algorithm may be possible.
 */
rt_orthovec( out, in )
register fastf_t *out, *in;
{
	register int j, k;
	FAST fastf_t	f;
	register int i;

	if( NEAR_ZERO(in[X], 0.0001) && NEAR_ZERO(in[Y], 0.0001) &&
	    NEAR_ZERO(in[Z], 0.0001) )  {
		VSETALL( out, 0 );
		VPRINT("rt_orthovec: zero-length input", in);
		return;
	}

	/* Find component closest to zero */
	f = fabs(in[X]);
	i = X;
	j = Y;
	k = Z;
	if( fabs(in[Y]) < f )  {
		f = fabs(in[Y]);
		i = Y;
		j = Z;
		k = X;
	}
	if( fabs(in[Z]) < f )  {
		i = Z;
		j = X;
		k = Y;
	}
	f = hypot( in[j], in[k] );
	if( NEAR_ZERO( f, SMALL ) ) {
		VPRINT("rt_orthovec: zero hypot on", in);
		VSETALL( out, 0 );
		return;
	}
	f = 1.0/f;
	out[i] = 0.0;
	out[j] = -in[k]*f;
	out[k] =  in[j]*f;
}

/*
d85 1
a85 1
	rt_make_perp( halfp->half_Xbase, stp->st_center );
d224 1
a224 1
	rt_orthovec( cvp->crv_pdir, halfp->half_N );
@


6.1
log
@Release 2.0
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 5.1 87/06/24 22:11:32 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 4.8 87/05/28 21:25:47 mike Exp $ (BRL)";
@


4.8
log
@Fixed rt_orthovec
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 4.7 87/04/28 00:27:43 phil Exp $ (BRL)";
@


4.7
log
@changed curve convention
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 4.6 87/03/23 23:41:51 phil Locked $ (BRL)";
d88 1
d99 1
d104 1
d109 1
d120 3
a122 1
	VSET( out, 0, -in[k]*f, in[j]*f );
@


4.6
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 4.5 87/03/17 15:51:34 mike Exp $ (BRL)";
d284 1
a284 1
hlf_curve( cvp, hitp, stp, rp )
a287 1
struct xray *rp;
@


4.5
log
@Fixed minor stupidity in hlf_norm() w.r.t. INFINITY
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 4.4 87/03/10 23:42:52 mike Locked $ (BRL)";
d122 5
a126 4
hlf_prep( vec, stp, mat )
fastf_t *vec;
struct soltab *stp;
matp_t mat;
d373 20
@


4.4
log
@For Stay, switched 3rd arg to ft_shoot() from resource pointer
(member of application struct) to application struct pointer.
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 4.3 87/02/12 22:11:18 mike Locked $ (BRL)";
a268 2
		VJOIN1( hitp->hit_point, rp->r_pt, f, rp->r_dir );
	} else {
d271 2
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 4.2 87/01/28 21:00:15 mike Exp $ (BRL)";
d200 1
a200 1
hlf_shot( stp, rp, res )
d203 1
a203 1
struct resource		*res;
d236 1
a236 1
		GET_SEG( segp, res );
@


4.2
log
@Release 1.16:  added curvature
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 4.1 86/12/29 03:45:16 mike Locked $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 1.7 86/12/24 08:05:47 mike Locked $ (BRL)";
d52 1
a52 1
 *			M A K E _ P E R P
d54 2
a55 1
 *  Given a vector, create another vector which is perpendicular to it.
d58 1
a58 1
make_perp( new, old )
d77 43
d152 1
a152 1
	make_perp( halfp->half_Xbase, stp->st_center );
d274 20
@


1.7
log
@Revised for resource structure.
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 1.6 86/12/18 15:05:02 mike Locked $ (BRL)";
@


1.6
log
@Cleanups and a bug fix.
Inspired by Cray
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 1.5 86/11/07 05:44:38 mike Locked $ (BRL)";
d156 4
a159 3
hlf_shot( stp, rp )
struct soltab *stp;
register struct xray *rp;
d192 1
a192 1
		GET_SEG( segp );
@


1.5
log
@Reworked the normals.
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 1.4 86/08/12 04:15:42 mike Exp $ (BRL)";
d185 1
a185 1
	if( rt_g.debug & DEBUG_TESTING )
a192 3
		/* At most one normal is really defined, but whichever one
		 * it is, it has value half_N.  Set them both and forget it.
		 */
a193 2
		VMOVE( segp->seg_in.hit_normal, halfp->half_N );

a194 1
		VMOVE( segp->seg_out.hit_normal, halfp->half_N );
d211 3
a213 3
	/* We are expected to compute hit_point here */
	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
}
d215 5
a219 9
/*
 *  This is a pretty shabby replacement for the
 *  not always available fmod() routine.
 */
double
ffmod(x,y)
double x,y;
{
	register long i;
d221 8
a228 2
	i = (long)x/y;
	return( x - i * y );
d248 1
a248 1
		(struct half_specific *)hitp->hit_private;
d251 1
d253 8
d264 7
d272 1
a272 1
	f = ffmod( f, 1.0 );
d279 7
d287 1
a287 1
	f = ffmod( f, 1.0 );
@


1.4
log
@Changed #include directives for use with CC -I convention
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 1.3 86/07/24 06:10:13 mike Exp $ (BRL)";
a161 3
	LOCAL struct half_specific *iplane, *oplane;
	FAST fastf_t	dn;		/* Direction dot Normal */
	FAST fastf_t	dxbdn;
a165 1
	iplane = oplane = HALF_NULL;
d167 17
a183 14
	dxbdn = VDOT( halfp->half_N, rp->r_pt ) - halfp->half_d;
	if( (dn = -VDOT( halfp->half_N, rp->r_dir )) < -1.0e-10 )  {
		/* exit point, when dir.N < 0.  out = min(out,s) */
		out = dxbdn/dn;
		oplane = halfp;
	} else if ( dn > 1.0e-10 )  {
		/* entry point, when dir.N > 0.  in = max(in,s) */
		in = dxbdn/dn;
		iplane = halfp;
	}  else  {
		/* ray is parallel to plane when dir.N == 0.
		 * If it is outside the solid, stop now */
		if( dxbdn > 0.0 )
			return( SEG_NULL );	/* MISS */
d193 3
d197 1
a197 1
		segp->seg_in.hit_private = (char *)iplane;
d200 1
a200 1
		segp->seg_out.hit_private = (char *)oplane;
d210 1
d217 1
a217 3
	register struct half_specific *halfp =
		(struct half_specific *)hitp->hit_private;

a218 5
	if( hitp->hit_private == (char *)0 )  {
		VREVERSE( hitp->hit_normal, halfp->half_N );	/* "exit" */
	}  else  {
		VMOVE( hitp->hit_normal, halfp->half_N );
	}
@


1.3
log
@Added uvcoord support
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 1.2 86/07/22 03:45:23 mike Exp $ (BRL)";
d25 4
a28 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/raytrace.h"
#include "debug.h"
@


1.2
log
@Names shorted to "hlf_*" for non-FLEXNAMES systems.
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 1.1 86/07/19 04:41:34 mike Exp $ (BRL)";
d66 1
a66 1
	VSET( another, 0, 0, 0 );
d114 2
a115 2
	VSET( stp->st_min, -INFINITY,-INFINITY,-INFINITY);
	VSET( stp->st_max,  INFINITY, INFINITY, INFINITY);
d249 2
a250 1
hlf_uv( stp, hitp, uvp )
d253 1
a253 1
register fastf_t *uvp;
d266 1
a266 1
		uvp[0] = 2 * f;		/* 0..1 */
d268 1
a268 1
		uvp[0] = 2 * (1 - f);	/* 1..0 */
d274 1
a274 1
		uvp[1] = 2 * f;		/* 0..1 */
d276 1
a276 1
		uvp[1] = 2 * (1 - f);	/* 1..0 */
d278 1
a278 1
	if( uvp[0] < 0 || uvp[1] < 0 )  {
d280 1
a280 1
			rt_log("half_uv: bad uv=%f,%f\n", uvp[0], uvp[1]);
d282 9
a290 2
		if( uvp[0] < 0 )  uvp[0] = (-uvp[0]);
		if( uvp[1] < 0 )  uvp[1] = (-uvp[1]);
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCShalf[] = "@@(#)$Header: half.c,v 3.1 86/07/11 01:31:21 mike Exp $ (BRL)";
d76 1
a76 1
 *  			H A L F _ P R E P
d78 1
a78 1
half_prep( vec, stp, mat )
d123 1
a123 1
 *  			H A L F _ P R I N T
d125 1
a125 1
half_print( stp )
d143 1
a143 1
 *			H A L F _ S H O T
d156 1
a156 1
half_shot( stp, rp )
d205 1
a205 1
 *  			H A L F _ N O R M
d209 1
a209 1
half_norm( hitp, stp, rp )
d240 1
a240 1
 *  			H A L F _ U V
d249 1
a249 1
half_uv( stp, hitp, uvp )
@
