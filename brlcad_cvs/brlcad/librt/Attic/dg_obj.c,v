head	1.78;
access;
symbols
	ansi-20040405-merged:1.68.2.2
	postmerge-20040405-ansi:1.74
	premerge-20040404-ansi:1.73
	postmerge-autoconf:1.73
	autoconf-freeze:1.71.6.2
	premerge-autoconf:1.73
	ansi-20040316-freeze:1.68.2.1
	postmerge-20040315-windows:1.73
	premerge-20040315-windows:1.72
	windows-20040315-freeze:1.68.4.4
	autoconf-20031203:1.71
	autoconf-20031202:1.71
	autoconf-branch:1.71.0.6
	phong-branch:1.71.0.4
	photonmap-branch:1.71.0.2
	rel-6-1-DP:1.68
	windows-branch:1.68.0.4
	rel-6-0-2:1.65
	ansi-branch:1.68.0.2
	rel-6-0-1-branch:1.65.0.2
	hartley-6-0-post:1.66
	hartley-6-0-pre:1.65
	rel-6-0-1:1.65
	rel-6-0:1.61
	rel-5-4:1.30.2.5
	offsite-5-3-pre:1.43
	rel-5-3:1.30.2.5
	rel-5-2:1.30.2.1
	rel-5-1-branch:1.30.0.2
	rel-5-1:1.30;
locks; strict;
comment	@ * @;


1.78
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	1.77;

1.77
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	1.76;

1.76
date	2004.05.10.15.25.27;	author morrison;	state Exp;
branches;
next	1.75;

1.75
date	2004.05.05.14.20.27;	author morrison;	state Exp;
branches;
next	1.74;

1.74
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	1.73;

1.73
date	2004.03.16.20.03.08;	author morrison;	state Exp;
branches;
next	1.72;

1.72
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	1.71;

1.71
date	2003.04.02.15.17.38;	author jra;	state Exp;
branches
	1.71.6.1;
next	1.70;

1.70
date	2003.04.01.19.19.13;	author jra;	state Exp;
branches;
next	1.69;

1.69
date	2002.12.21.05.19.04;	author jra;	state Exp;
branches;
next	1.68;

1.68
date	2002.08.23.12.18.58;	author morrison;	state Exp;
branches
	1.68.2.1
	1.68.4.1;
next	1.67;

1.67
date	2002.08.20.17.07.58;	author jra;	state Exp;
branches;
next	1.66;

1.66
date	2002.08.15.20.55.10;	author hartley;	state Exp;
branches;
next	1.65;

1.65
date	2002.07.11.14.16.48;	author rbowers;	state Exp;
branches;
next	1.64;

1.64
date	2002.07.10.18.07.52;	author rbowers;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.19.20.09.06;	author butler;	state Exp;
branches;
next	1.62;

1.62
date	2002.05.12.03.48.06;	author jra;	state Exp;
branches;
next	1.61;

1.61
date	2001.12.12.18.36.40;	author bparker;	state Exp;
branches;
next	1.60;

1.60
date	2001.11.27.17.54.03;	author bparker;	state Exp;
branches;
next	1.59;

1.59
date	2001.11.09.20.40.02;	author bparker;	state Exp;
branches;
next	1.58;

1.58
date	2001.10.29.21.50.42;	author bparker;	state Exp;
branches;
next	1.57;

1.57
date	2001.09.19.15.34.42;	author bparker;	state Exp;
branches;
next	1.56;

1.56
date	2001.09.07.21.08.24;	author bparker;	state Exp;
branches;
next	1.55;

1.55
date	2001.08.14.18.22.56;	author bparker;	state Exp;
branches;
next	1.54;

1.54
date	2001.07.19.15.33.33;	author bparker;	state Exp;
branches;
next	1.53;

1.53
date	2001.06.01.19.08.51;	author bparker;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.01.17.12.13;	author bparker;	state Exp;
branches;
next	1.51;

1.51
date	2001.05.17.20.05.24;	author morrison;	state Exp;
branches;
next	1.50;

1.50
date	2001.05.02.22.27.06;	author bparker;	state Exp;
branches;
next	1.49;

1.49
date	2001.05.02.14.06.16;	author bparker;	state Exp;
branches;
next	1.48;

1.48
date	2001.04.20.22.29.42;	author morrison;	state Exp;
branches;
next	1.47;

1.47
date	2001.03.23.22.05.30;	author jra;	state Exp;
branches;
next	1.46;

1.46
date	2001.03.22.18.09.12;	author bparker;	state Exp;
branches;
next	1.45;

1.45
date	2001.03.21.20.05.00;	author bparker;	state Exp;
branches;
next	1.44;

1.44
date	2001.03.19.22.19.57;	author butler;	state Exp;
branches;
next	1.43;

1.43
date	2001.03.09.15.23.28;	author bparker;	state Exp;
branches;
next	1.42;

1.42
date	2001.01.16.21.18.06;	author cjohnson;	state Exp;
branches;
next	1.41;

1.41
date	2000.11.17.06.01.56;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	2000.11.08.18.15.59;	author bparker;	state Exp;
branches;
next	1.39;

1.39
date	2000.10.20.05.09.32;	author mike;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.20.05.05.02;	author mike;	state Exp;
branches;
next	1.37;

1.37
date	2000.10.18.18.10.34;	author butler;	state Exp;
branches;
next	1.36;

1.36
date	2000.10.13.20.19.26;	author bparker;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.08.05.54.41;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	2000.08.23.01.09.17;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	2000.08.09.21.56.06;	author bparker;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.29.20.55.59;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.29.14.38.33;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	2000.05.26.20.06.02;	author bparker;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2000.05.26.19.02.55;	author bparker;	state Exp;
branches;
next	1.28;

1.28
date	2000.05.19.18.51.07;	author bparker;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.13.20.35.15;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.12.01.11.49;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.07.18.30.04;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	2000.02.22.21.41.58;	author bparker;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.18.21.08.40;	author bparker;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.01.20.21.55;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.01.15.47.06;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.31.15.01.28;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.28.16.11.07;	author bparker;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.06.16.17.05;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.04.22.10.51;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.04.17.58.20;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.04.15.34.37;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.03.22.40.54;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.03.22.35.59;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.03.22.31.05;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.03.21.50.38;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.03.21.42.49;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.03.19.23.27;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.03.15.28.48;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	99.12.29.23.23.10;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	99.12.29.21.49.06;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	99.12.29.20.50.44;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	99.12.28.18.58.46;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	99.12.28.18.13.14;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	99.12.28.15.42.22;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	99.12.27.20.49.24;	author bparker;	state Exp;
branches;
next	;

1.30.2.1
date	2000.08.30.17.26.15;	author bparker;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2000.10.11.16.07.57;	author bparker;	state Exp;
branches;
next	1.30.2.3;

1.30.2.3
date	2000.11.08.15.40.47;	author bparker;	state Exp;
branches;
next	1.30.2.4;

1.30.2.4
date	2000.11.08.18.09.39;	author bparker;	state Exp;
branches;
next	1.30.2.5;

1.30.2.5
date	2001.01.11.23.22.13;	author bparker;	state Exp;
branches;
next	;

1.68.2.1
date	2002.09.19.18.01.32;	author morrison;	state Exp;
branches;
next	1.68.2.2;

1.68.2.2
date	2004.03.17.21.18.44;	author morrison;	state Exp;
branches;
next	;

1.68.4.1
date	2002.09.26.23.04.01;	author morrison;	state Exp;
branches;
next	1.68.4.2;

1.68.4.2
date	2003.08.14.08.07.26;	author morrison;	state Exp;
branches;
next	1.68.4.3;

1.68.4.3
date	2004.03.11.23.43.36;	author morrison;	state Exp;
branches;
next	1.68.4.4;

1.68.4.4
date	2004.03.12.15.04.01;	author morrison;	state Exp;
branches;
next	;

1.71.6.1
date	2004.02.12.18.37.39;	author erikg;	state Exp;
branches;
next	1.71.6.2;

1.71.6.2
date	2004.03.18.18.10.29;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.78
log
@moved to src/
@
text
@/*
 *				D G _ O B J . C
 *
 * A drawable geometry object contains methods and attributes
 * for preparing geometry that is ready (i.e. vlists) for
 * display. Much of this code was extracted from MGED and modified
 * to work herein.
 * 
 * Source -
 *	SLAD CAD Team
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 * Authors -
 *	Robert G. Parker
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <fcntl.h>
#include <math.h>
#include <signal.h>
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include "tcl.h"
#include "machine.h"
#include "externs.h"
#include "cmd.h"			/* includes bu.h */
#include "vmath.h"
#include "bn.h"
#include "mater.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "solid.h"

struct dg_client_data {
	struct dg_obj		*dgop;
	Tcl_Interp		*interp;
	int			wireframe_color_override;
	int			wireframe_color[3];
	int			draw_nmg_only;
	int			nmg_triangulate;
	int			draw_wireframes;
	int			draw_normals;
	int			draw_solid_lines_only;
	int			draw_no_surfaces;
	int			shade_per_vertex_normals;
	int			draw_edge_uses;
	int			fastpath_count;			/* statistics */
	int			do_not_draw_nmg_solids_during_debugging;
	struct bn_vlblock	*draw_edge_uses_vbp;
	int			shaded_mode_override;
	fastf_t			transparency;
        int                     dmode;
};

#define DGO_WIREFRAME 0
#define DGO_SHADED_MODE_BOTS 1
#define DGO_SHADED_MODE_ALL 2
#define DGO_BOOL_EVAL 3
static union tree *dgo_bot_check_region_end();
static union tree *dgo_bot_check_leaf();

int dgo_shaded_mode_cmd();
static int dgo_how_tcl();
static int dgo_set_transparency_tcl();
static int dgo_shaded_mode_tcl();

/* XXX this should be done else where? */
int rt_pg_plot(struct bu_list *, struct rt_db_internal *,
	       const struct rt_tess_tol *, const struct bn_tol *);
int rt_pg_plot_poly(struct bu_list *, struct rt_db_internal *,
		    const struct rt_tess_tol *, const struct bn_tol *);
int rt_bot_plot(struct bu_list *, struct rt_db_internal *,
		    const struct rt_tess_tol *, const struct bn_tol *);
int rt_bot_plot_poly(struct bu_list *, struct rt_db_internal *,
		    const struct rt_tess_tol *, const struct bn_tol *);

#include "./debug.h"

#define DGO_CHECK_WDBP_NULL(_dgop,_interp) \
	if (_dgop->dgo_wdbp == RT_WDB_NULL) \
	{ \
		Tcl_AppendResult(_interp, "Not associated with a database!\n", (char *)NULL); \
		return TCL_ERROR; \
	}	

/*
 *  It is expected that entries on this mater list will be sorted
 *  in strictly ascending order, with no overlaps (ie, monotonicly
 *  increasing).
 */
extern struct mater *rt_material_head;	/* now defined in librt/mater.c */

/* declared in vdraw.c */
extern struct bu_cmdtab vdraw_cmds[];

/* declared in qray.c */
extern int	dgo_qray_cmd(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv);
extern void	dgo_init_qray(struct dg_obj *dgop);
extern void	dgo_free_qray(struct dg_obj *dgop);

/* declared in nirt.c */
extern int	dgo_nirt_cmd(struct dg_obj *dgop, struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv);
extern int	dgo_vnirt_cmd(struct dg_obj *dgop, struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv);

static int dgo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
#if 0
static int dgo_close_tcl();
#endif
static int dgo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_headSolid_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_illum_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_label_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_draw_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_ev_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_erase_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_erase_all_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_who_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_rt_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_rtabort_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_vdraw_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_overlay_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_get_autoview_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_get_eyemodel_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_zap_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_blast_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_assoc_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
#if 0
static int dgo_tol_tcl();
#endif
static int dgo_rtcheck_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_report_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
extern int dgo_E_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_autoview_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_qray_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_nirt_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_vnirt_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

static union tree *dgo_wireframe_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data);
static union tree *dgo_wireframe_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data);
static int dgo_drawtrees(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv, int kind, struct dg_client_data *_dgcdp);
int dgo_invent_solid(struct dg_obj *dgop, Tcl_Interp *interp, char *name, struct bu_list *vhead, long int rgb, int copy);
static void dgo_bound_solid(Tcl_Interp *interp, register struct solid *sp);
void dgo_drawH_part2(int dashflag, struct bu_list *vhead, struct db_full_path *pathp, struct db_tree_state *tsp, struct solid *existing_sp, struct dg_client_data *dgcdp);
void dgo_eraseobjpath(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv, int noisy, int all);
static void dgo_eraseobjall(struct dg_obj *dgop, Tcl_Interp *interp, register struct directory **dpp);
void dgo_eraseobjall_callback(struct db_i *dbip, Tcl_Interp *interp, struct directory *dp);
static void dgo_eraseobj(struct dg_obj *dgop, Tcl_Interp *interp, register struct directory **dpp);
void dgo_color_soltab(struct solid *hsp);
static int dgo_run_rt(struct dg_obj *dgop, struct view_obj *vop);
static void dgo_rt_write(struct dg_obj *dgop, struct view_obj *vop, FILE *fp, fastf_t *eye_model);
static void dgo_rt_set_eye_model(struct dg_obj *dgop, struct view_obj *vop, fastf_t *eye_model);
void dgo_cvt_vlblock_to_solids(struct dg_obj *dgop, Tcl_Interp *interp, struct bn_vlblock *vbp, char *name, int copy);
int dgo_build_tops(Tcl_Interp *interp, struct solid *hsp, char **start, register char **end);
void dgo_pr_wait_status(Tcl_Interp *interp, int status);

void dgo_notify(struct dg_obj *dgop, Tcl_Interp *interp);
static void dgo_print_schain(struct dg_obj *dgop, Tcl_Interp *interp, int lvl);
static void dgo_print_schain_vlcmds(struct dg_obj *dgop, Tcl_Interp *interp);

struct dg_obj HeadDGObj;		/* head of drawable geometry object list */
static struct solid FreeSolid;		/* head of free solid list */


static struct bu_cmdtab dgo_cmds[] = {
	{"assoc",		dgo_assoc_tcl},
	{"autoview",		dgo_autoview_tcl},
	{"blast",		dgo_blast_tcl},
	{"clear",		dgo_zap_tcl},
#if 0
	{"close",		dgo_close_tcl},
#endif
	{"draw",		dgo_draw_tcl},
	{"E",			dgo_E_tcl},
	{"erase",		dgo_erase_tcl},
	{"erase_all",		dgo_erase_all_tcl},
	{"ev",			dgo_ev_tcl},
	{"get_autoview",	dgo_get_autoview_tcl},
	{"get_eyemodel",	dgo_get_eyemodel_tcl},
	{"headSolid",		dgo_headSolid_tcl},
	{"how",			dgo_how_tcl},
	{"illum",		dgo_illum_tcl},
	{"label",		dgo_label_tcl},
	{"nirt",		dgo_nirt_tcl},
	{"observer",		dgo_observer_tcl},
	{"overlay",		dgo_overlay_tcl},
	{"qray",		dgo_qray_tcl},
	{"report",		dgo_report_tcl},
	{"rt",			dgo_rt_tcl},
	{"rtabort",		dgo_rtabort_tcl},
	{"rtcheck",		dgo_rtcheck_tcl},
	{"rtedge",		dgo_rt_tcl},
	{"set_transparency",	dgo_set_transparency_tcl},
	{"shaded_mode",		dgo_shaded_mode_tcl},
#if 0
	{"tol",			dgo_tol_tcl},
#endif
	{"vdraw",		dgo_vdraw_tcl},
	{"vnirt",		dgo_vnirt_tcl},
	{"who",			dgo_who_tcl},
	{"zap",			dgo_zap_tcl},
	{(char *)0,		(int (*)())0}
};

#ifdef WIN32
Tcl_Channel chan1;
#endif


/*
 *			D G O _ C M D
 *
 * Generic interface for drawable geometry objects.
 * Usage:
 *        procname cmd ?args?
 *
 * Returns: result of dbo command.
 */
static int
dgo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	return bu_cmd(clientData, interp, argc, argv, dgo_cmds, 1);
}

int
Dgo_Init(Tcl_Interp *interp)
{
	BU_LIST_INIT(&HeadDGObj.l);
	BU_LIST_INIT(&FreeSolid.l);

	(void)Tcl_CreateCommand(interp, "dg_open", (Tcl_CmdProc *)dgo_open_tcl, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

	return TCL_OK;
}

/*
 * Called by Tcl when the object is destroyed.
 */
static void
dgo_deleteProc(ClientData clientData)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;

	/* free observers */
	bu_observer_free(&dgop->dgo_observers);

	/*
	 * XXX Do something for the case where the drawable geometry
	 * XXX object is deleted and the object has forked rt processes.
	 * XXX This will create a memory leak.
	 */


	bu_vls_free(&dgop->dgo_name);
	dgo_free_qray(dgop);

	BU_LIST_DEQUEUE(&dgop->l);
	bu_free((genptr_t)dgop, "dgo_deleteProc: dgop");
}

#if 0
/*
 * Close a drawable geometry object.
 *
 * USAGE:
 *	  procname close
 */
static int
dgo_close_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct bu_vls vls;
	struct dg_obj *dgop = (struct dg_obj *)clientData;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib dgo_close");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* Among other things, this will call dgo_deleteProc. */
	Tcl_DeleteCommand(interp, bu_vls_addr(&dgop->dgo_name));

	return TCL_OK;
}
#endif

/*
 * Create an command/object named "oname" in "interp".
 */
struct dg_obj *
dgo_open_cmd(char		*oname,
	     struct rt_wdb	*wdbp)
{
	struct dg_obj *dgop;

	BU_GETSTRUCT(dgop,dg_obj);

	/* initialize dg_obj */
	bu_vls_init(&dgop->dgo_name);
	bu_vls_strcpy(&dgop->dgo_name, oname);
	dgop->dgo_wdbp = wdbp;
	BU_LIST_INIT(&dgop->dgo_headSolid);
	BU_LIST_INIT(&dgop->dgo_headVDraw);
	BU_LIST_INIT(&dgop->dgo_observers.l);
	BU_LIST_INIT(&dgop->dgo_headRunRt.l);

	dgo_init_qray(dgop);

	/* append to list of dg_obj's */
	BU_LIST_APPEND(&HeadDGObj.l,&dgop->l);

	return dgop;
}

/*
 * Open/create a drawable geometry object that's associated with the
 * database object "rt_wdb".
 *
 * USAGE:
 *	  dgo_open [name rt_wdb]
 */
static int
dgo_open_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct dg_obj *dgop;
	struct rt_wdb *wdbp;
	struct bu_vls vls;

	if (argc == 1) {
		/* get list of drawable geometry objects */
		for (BU_LIST_FOR(dgop, dg_obj, &HeadDGObj.l))
			Tcl_AppendResult(interp, bu_vls_addr(&dgop->dgo_name), " ", (char *)NULL);

		return TCL_OK;
	}

	if (argc != 3) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib dgo_open");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* search for database object */
	for (BU_LIST_FOR(wdbp, rt_wdb, &rt_g.rtg_headwdb.l)) {
		if (strcmp(bu_vls_addr(&wdbp->wdb_name), argv[2]) == 0)
			break;
	}

	if (BU_LIST_IS_HEAD(wdbp, &rt_g.rtg_headwdb.l))
		wdbp = RT_WDB_NULL;

	/* first, delete any commands by this name */
	(void)Tcl_DeleteCommand(interp, argv[1]);

	dgop = dgo_open_cmd(argv[1], wdbp);
	(void)Tcl_CreateCommand(interp,
				bu_vls_addr(&dgop->dgo_name),
				(Tcl_CmdProc *)dgo_cmd,
				(ClientData)dgop,
				dgo_deleteProc);

	/* Return new function name as result */
	Tcl_ResetResult(interp);
	Tcl_AppendResult(interp, bu_vls_addr(&dgop->dgo_name), (char *)NULL);

	return TCL_OK;
}

/****************** Drawable Geometry Object Methods ********************/

#if 0
/* skeleton functions for dg_obj methods */
int
dgo__cmd(struct dg_obj	*dgop,
	 Tcl_Interp	*interp,
	 int		argc,
	 char 		**argv)
{
}

/*
 * Usage:
 *        procname 
 */
static int
dgo__tcl(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;

	return dgo__cmd(dgop, interp, argc-1, argv+1);
}
#endif

/*
 *
 * Usage:
 *        procname headSolid
 *
 * Returns: database object's headSolid.
 */
static int
dgo_headSolid_tcl(ClientData	clientData,
		  Tcl_Interp	*interp,
		  int     	argc,
		  char    	**argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct bu_vls vls;

	bu_vls_init(&vls);

	if (argc != 2) {
		bu_vls_printf(&vls, "helplib_alias dgo_headSolid %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_printf(&vls, "%lu", (unsigned long)&dgop->dgo_headSolid);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
	return TCL_OK;
}

int
dgo_illum_cmd(struct dg_obj	*dgop,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{
	register struct solid *sp;
	struct bu_vls vls;
	int found = 0;
	int illum = 1;

	if (argc == 3) {
		if (argv[1][0] == '-' && argv[1][1] == 'n')
			illum = 0;
		else
			goto bad;

		--argc;
		++argv;
	}

	if (argc != 2)
		goto bad;

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		register int i;

		for (i = 0; i < sp->s_fullpath.fp_len; ++i) {
			if (*argv[1] == *DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_namep &&
			    strcmp(argv[1], DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_namep) == 0) {
				found = 1;
				if (illum)
					sp->s_iflag = UP;
				else
					sp->s_iflag = DOWN;
			}
		}
	}

	if (!found) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "illum: %s not found", argv[1]);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	return TCL_OK;

bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dgo_illum %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 * Illuminate/highlight database object
 *
 * Usage:
 *        procname illum [-n] obj
 *
 */
static int
dgo_illum_tcl(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;
	int		ret;

	DGO_CHECK_WDBP_NULL(dgop,interp);

	if ((ret = dgo_illum_cmd(dgop, interp, argc-1, argv+1)) == TCL_OK)
		dgo_notify(dgop, interp);

	return ret;
}

int
dgo_label_cmd(struct dg_obj	*dgop,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{
	/* not yet implemented */

	return TCL_OK;
}

/*
 * Label database objects.
 *
 * Usage:
 *        procname label [-n] obj
 *
 */
static int
dgo_label_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;

	DGO_CHECK_WDBP_NULL(dgop,interp);

	return dgo_label_cmd(dgop, interp, argc-1, argv+1);
}

int
dgo_draw_cmd(struct dg_obj	*dgop,
	     Tcl_Interp		*interp,
	     int		argc,
	     char 		**argv,
	     int		kind)
{
	if (argc < 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);

		switch (kind) {
		default:
		case 1:
			bu_vls_printf(&vls, "helplib_alias dgo_draw %s", argv[0]);
			break;
		case 2:
			bu_vls_printf(&vls, "helplib_alias dgo_E %s", argv[0]);
			break;
		case 3:
			bu_vls_printf(&vls, "helplib_alias dgo_ev %s", argv[0]);
			break;
		}

		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	/* skip past cmd */
	--argc;
	++argv;

	/*  First, delete any mention of these objects.
	 *  Silently skip any leading options (which start with minus signs).
	 */
	dgo_eraseobjpath(dgop, interp, argc, argv, LOOKUP_QUIET, 0);

 	dgo_drawtrees(dgop, interp, argc, argv, kind, (struct dg_client_data *)0);

	dgo_color_soltab((struct solid *)&dgop->dgo_headSolid);

	return TCL_OK;
}

/*
 * Prepare database objects for drawing.
 *
 * Usage:
 *        procname draw|ev [args]
 *
 */
static int
dgo_draw_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;
	int		ret;

	DGO_CHECK_WDBP_NULL(dgop,interp);

	if ((ret = dgo_draw_cmd(dgop, interp, argc-1, argv+1, 1)) == TCL_OK)
		dgo_notify(dgop, interp);

	return ret;
}

/*
 * Prepare database objects for drawing.
 *
 * Usage:
 *        procname ev [args]
 *
 */
static int
dgo_ev_tcl(ClientData	clientData,
	   Tcl_Interp	*interp,
	   int     	argc,
	   char    	**argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;
	int		ret;

	DGO_CHECK_WDBP_NULL(dgop,interp);

	if ((ret = dgo_draw_cmd(dgop, interp, argc-1, argv+1, 3)) == TCL_OK)
		dgo_notify(dgop, interp);

	return ret;
}

int
dgo_erase_cmd(struct dg_obj	*dgop,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{

	if (argc < 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_erase %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	dgo_eraseobjpath(dgop, interp, argc-1, argv+1, LOOKUP_NOISY, 0);

	return TCL_OK;
}

/*
 * Erase database objects.
 *
 * Usage:
 *        procname erase object(s)
 *
 */
static int
dgo_erase_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;
	int		ret;

	DGO_CHECK_WDBP_NULL(dgop,interp);

	if ((ret = dgo_erase_cmd(dgop, interp, argc-1, argv+1)) == TCL_OK)
		dgo_notify(dgop, interp);

	return ret;
}

int
dgo_erase_all_cmd(struct dg_obj	*dgop,
		  Tcl_Interp	*interp,
		  int		argc,
		  char 		**argv)
{
	if (argc < 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_erase_all %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	dgo_eraseobjpath(dgop, interp, argc-1, argv+1, LOOKUP_NOISY, 1);

	return TCL_OK;
}

/*
 * Usage:
 *        procname erase_all object(s)
 */
static int
dgo_erase_all_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;
	int		ret;

	DGO_CHECK_WDBP_NULL(dgop,interp);

	if ((ret = dgo_erase_all_cmd(dgop, interp, argc-1, argv+1)) == TCL_OK)
		dgo_notify(dgop, interp);

	return ret;
}

struct directory **
dgo_build_dpp(struct dg_obj	*dgop,
	      Tcl_Interp        *interp,
	      char              *path) {
	register struct directory *dp;
	struct directory **dpp;
	int i;
	char *begin;
	char *end;
	char *newstr;
	char *list;
	int ac;
	const char **av;
	const char **av_orig = NULL;
	struct bu_vls vls;

	bu_vls_init(&vls);

	/*
	 * First, build an array of the object's path components.
	 * We store the list in av_orig below.
	 */
	newstr = strdup(path);
	begin = newstr;
	while ((end = strchr(begin, '/')) != NULL) {
	  *end = '\0';
	  bu_vls_printf(&vls, "%s ", begin);
	  begin = end + 1;
	}
	bu_vls_printf(&vls, "%s ", begin);
	free((void *)newstr);

	list = bu_vls_addr(&vls);

	if (Tcl_SplitList((Tcl_Interp *)interp, list, &ac, &av_orig) != TCL_OK) {
	  Tcl_AppendResult(interp, "-1", (char *)NULL);
	  bu_vls_free(&vls);
	  return (struct directory **)NULL;
	}

	/* skip first element if empty */
	av = av_orig;
	if (*av[0] == '\0') {
	  --ac;
	  ++av;
	}

	/* ignore last element if empty */
	if (*av[ac-1] == '\0')
	  --ac;

	/*
	 * Next, we build an array of directory pointers that
	 * correspond to the object's path.
	 */
	dpp = bu_calloc(ac+1, sizeof(struct directory *), "dgo_build_dpp: directory pointers");
	for (i = 0; i < ac; ++i) {
	  if ((dp = db_lookup(dgop->dgo_wdbp->dbip, av[i], 0)) != DIR_NULL)
	    dpp[i] = dp;
	  else {
	    /* object is not currently being displayed */
	    Tcl_AppendResult(interp, "-1", (char *)NULL);

	    bu_free((genptr_t)dpp, "dgo_how_cmd: directory pointers");
	    Tcl_Free((char *)av_orig);
	    bu_vls_free(&vls);
	    return (struct directory **)NULL;
	  }
	}

	dpp[i] = DIR_NULL;

	Tcl_Free((char *)av_orig);
	bu_vls_free(&vls);
	return dpp;
}

int
dgo_how_cmd(struct dg_obj	*dgop,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv)
{
	register struct solid *sp;
	struct bu_vls vls;
	int i;
	struct directory **dpp;
	register struct directory **tmp_dpp;

	bu_vls_init(&vls);

	if (argc != 2) {
		bu_vls_printf(&vls, "helplib_alias dgo_how %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if ((dpp = dgo_build_dpp(dgop, interp, argv[1])) == NULL)
	  goto good;

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
	  for (i = 0, tmp_dpp = dpp;
	       i <= sp->s_fullpath.fp_len && *tmp_dpp != DIR_NULL;
	       ++i, ++tmp_dpp) {
	    if (sp->s_fullpath.fp_names[i] != *tmp_dpp)
	      break;
	  }

	  if (*tmp_dpp != DIR_NULL)
	    continue;

	  /* found a match */
	  bu_vls_printf(&vls, "%d", sp->s_dmode);
	  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	  goto good;
	}

	/* match NOT found */
	Tcl_AppendResult(interp, "-1", (char *)NULL);

 good:
	if (dpp != (struct directory **)NULL)
	  bu_free((genptr_t)dpp, "dgo_how_cmd: directory pointers");
	bu_vls_free(&vls);

	return TCL_OK;
}

/*
 * Returns "how" an object is being displayed.
 *
 * Usage:
 *        procname how obj
 */
static int
dgo_how_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;

	DGO_CHECK_WDBP_NULL(dgop,interp);
	return dgo_how_cmd(dgop, interp, argc-1, argv+1);
}

int
dgo_who_cmd(struct dg_obj	*dgop,
	    Tcl_Interp		*interp,
	    int			argc,
	    char 		**argv)
{
	register struct solid *sp;
	int skip_real, skip_phony;

	if (argc < 1 || 2 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_who %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	skip_real = 0;
	skip_phony = 1;
	if (argc == 2) {
		switch (argv[1][0]) {
		case 'b':
			skip_real = 0;
			skip_phony = 0;
			break;
		case 'p':
			skip_real = 1;
			skip_phony = 0;
			break;
		case 'r':
			skip_real = 0;
			skip_phony = 1;
			break;
		default:
			Tcl_AppendResult(interp, "dgo_who: argument not understood\n", (char *)NULL);
			return TCL_ERROR;
		}
	}
		

	/* Find all unique top-level entries.
	 *  Mark ones already done with s_flag == UP
	 */
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_flag = DOWN;
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		register struct solid *forw;	/* XXX */

		if (sp->s_flag == UP)
			continue;
		if (FIRST_SOLID(sp)->d_addr == RT_DIR_PHONY_ADDR) {
			if (skip_phony) continue;
		} else {
			if (skip_real) continue;
		}
		Tcl_AppendResult(interp, FIRST_SOLID(sp)->d_namep, " ", (char *)NULL);
		sp->s_flag = UP;
		FOR_REST_OF_SOLIDS(forw, sp, &dgop->dgo_headSolid){
			if (FIRST_SOLID(forw) == FIRST_SOLID(sp))
				forw->s_flag = UP;
		}
	}
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_flag = DOWN;

	return TCL_OK;
}

/*
 * List the objects currently being drawn.
 *
 * Usage:
 *        procname who [r(eal)|p(hony)|b(oth)]
 */
static int
dgo_who_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;

	DGO_CHECK_WDBP_NULL(dgop,interp);
	return dgo_who_cmd(dgop, interp, argc-1, argv+1);
}

static void
dgo_overlay(struct dg_obj *dgop, Tcl_Interp *interp, FILE *fp, char *name, double char_size)
{
	int ret;
	struct rt_vlblock *vbp;

	vbp = rt_vlblock_init();
	ret = rt_uplot_to_vlist(vbp, fp, char_size);
	fclose(fp);

	if (ret < 0) {
		rt_vlblock_free(vbp);
		return;
	}

	dgo_cvt_vlblock_to_solids(dgop, interp, vbp, name, 0);
	rt_vlblock_free(vbp);
}

int
dgo_overlay_cmd(struct dg_obj	*dgop,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	FILE	*fp;
	double	char_size;
	char	*name;

	if (argc < 3 || 4 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_overlay %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	if (sscanf(argv[2], "%lf", &char_size) != 1) {
		Tcl_AppendResult(interp, "dgo_overlay: bad character size - ",
				 argv[2], "\n", (char *)NULL);
		return TCL_ERROR;
	}

	if (argc == 3)
		name = "_PLOT_OVERLAY_";
	else
		name = argv[3];

	if ((fp = fopen(argv[1], "r")) == NULL) {
		Tcl_AppendResult(interp, "dgo_overlay: failed to open file - ",
				 argv[1], "\n", (char *)NULL);

		return TCL_ERROR;
	}

	dgo_overlay(dgop, interp, fp, name, char_size);
	return TCL_OK;
}

/*
 * Usage:
 *        procname overlay file.plot char_size [name]
 */
static int
dgo_overlay_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;
	int		ret;

	DGO_CHECK_WDBP_NULL(dgop,interp);

	if ((ret = dgo_overlay_cmd(dgop, interp, argc-1, argv+1)) == TCL_OK)
		dgo_notify(dgop, interp);

	return ret;
}

void
dgo_autoview(struct dg_obj	*dgop,
	     struct view_obj	*vop,
	     Tcl_Interp		*interp)
{
	register struct solid	*sp;
	vect_t		min, max;
	vect_t		minus, plus;
	vect_t		center;
	vect_t		radial;

	VSETALL(min,  INFINITY);
	VSETALL(max, -INFINITY);

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		minus[X] = sp->s_center[X] - sp->s_size;
		minus[Y] = sp->s_center[Y] - sp->s_size;
		minus[Z] = sp->s_center[Z] - sp->s_size;
		VMIN(min, minus);
		plus[X] = sp->s_center[X] + sp->s_size;
		plus[Y] = sp->s_center[Y] + sp->s_size;
		plus[Z] = sp->s_center[Z] + sp->s_size;
		VMAX(max, plus);
	}

	if (BU_LIST_IS_EMPTY(&dgop->dgo_headSolid)) {
		/* Nothing is in view */
		VSETALL(center, 0.0);
		VSETALL(radial, 1000.0);	/* 1 meter */
	} else {
		VADD2SCALE(center, max, min, 0.5);
		VSUB2(radial, max, center);
	}

	if (VNEAR_ZERO(radial , SQRT_SMALL_FASTF))
		VSETALL(radial , 1.0);

	MAT_IDN(vop->vo_center);
	MAT_DELTAS(vop->vo_center, -center[X], -center[Y], -center[Z]);
	vop->vo_scale = radial[X];
	V_MAX(vop->vo_scale, radial[Y]);
	V_MAX(vop->vo_scale, radial[Z]);

	vop->vo_size = 2.0 * vop->vo_scale;
 	vop->vo_invSize = 1.0 / vop->vo_size;
	vo_update(vop, interp, 1);
}

int
dgo_autoview_cmd(struct dg_obj		*dgop,
		 struct view_obj	*vop,
		 Tcl_Interp		*interp,
		 int			argc,
		 char			**argv)
{
	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_autoview %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	DGO_CHECK_WDBP_NULL(dgop,interp);
	dgo_autoview(dgop, vop, interp);

	return TCL_OK;
}

/*
 * Usage:
 *        procname autoview view_obj
 */
static int
dgo_autoview_tcl(ClientData	clientData,
		 Tcl_Interp	*interp,
		 int		argc,
		 char		**argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct view_obj	*vop;

	if (argc != 3) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_autoview %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

#if 0
	DGO_CHECK_WDBP_NULL(dgop,interp);
#endif

	/* search for view object */
	for (BU_LIST_FOR(vop, view_obj, &HeadViewObj.l)) {
		if (strcmp(bu_vls_addr(&vop->vo_name), argv[2]) == 0)
			break;
	}

	if (BU_LIST_IS_HEAD(vop, &HeadViewObj.l)) {
		Tcl_AppendResult(interp, "dgo_autoview: bad view object - ", argv[2],
				 "\n", (char *)NULL);
		return TCL_ERROR;
	}

	return dgo_autoview_cmd(dgop, vop, interp, argc-1, argv+1);
}

int
dgo_get_autoview_cmd(struct dg_obj	*dgop,
		     Tcl_Interp		*interp,
		     int		argc,
		     char		**argv)
{
	struct bu_vls vls;
	register struct solid	*sp;
	vect_t		min, max;
	vect_t		minus, plus;
	vect_t		center;
	vect_t		radial;

	if (argc != 1) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_get_autoview %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	DGO_CHECK_WDBP_NULL(dgop,interp);

	VSETALL(min,  INFINITY);
	VSETALL(max, -INFINITY);

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		minus[X] = sp->s_center[X] - sp->s_size;
		minus[Y] = sp->s_center[Y] - sp->s_size;
		minus[Z] = sp->s_center[Z] - sp->s_size;
		VMIN(min, minus);
		plus[X] = sp->s_center[X] + sp->s_size;
		plus[Y] = sp->s_center[Y] + sp->s_size;
		plus[Z] = sp->s_center[Z] + sp->s_size;
		VMAX(max, plus);
	}

	if (BU_LIST_IS_EMPTY(&dgop->dgo_headSolid)) {
		/* Nothing is in view */
		VSETALL(center, 0.0);
		VSETALL(radial, 1000.0);	/* 1 meter */
	} else {
		VADD2SCALE(center, max, min, 0.5);
		VSUB2(radial, max, center);
	}

	if (VNEAR_ZERO(radial , SQRT_SMALL_FASTF))
		VSETALL(radial , 1.0);

	VSCALE(center, center, dgop->dgo_wdbp->dbip->dbi_base2local);
	radial[X] *= dgop->dgo_wdbp->dbip->dbi_base2local;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "center {%g %g %g} size %g", V3ARGS(center), radial[X] * 2.0);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;
}

/*
 * Usage:
 *        procname get_autoview
 */
static int
dgo_get_autoview_tcl(ClientData	clientData,
		     Tcl_Interp *interp,
		     int	argc,
		     char	**argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;

	return dgo_get_autoview_cmd(dgop, interp, argc-1, argv+1);
}

/*
 * support for get_eyemodel
 *
 *
 */
int
dgo_get_eyemodel_cmd(struct dg_obj	*dgop,
		     Tcl_Interp		*interp,
		     int		argc,
		     char		**argv)
{
  struct bu_vls vls;
  struct view_obj * vop;
  quat_t		quat;
  vect_t		eye_model;
  
  if (argc != 2) {
    struct bu_vls vls;
    
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helplib_alias dgo_get_eyemodel %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
  
  /*
   * Retrieve the view object
   */
  for (BU_LIST_FOR(vop, view_obj, &HeadViewObj.l)) {
    if (strcmp(bu_vls_addr(&vop->vo_name), argv[1]) == 0)
      break;
  }
  
  if (BU_LIST_IS_HEAD(vop, &HeadViewObj.l)) {
    Tcl_AppendResult(interp, 
		     "dgo_get_eyemodel: bad view object - ", 
		     argv[2],
		     "\n", (char *)NULL);
    return TCL_ERROR;
  }
  
  dgo_rt_set_eye_model(dgop, vop, eye_model);
  
  bu_vls_init(&vls);
  
  quat_mat2quat(quat, vop->vo_rotation );
  
  bu_vls_printf(&vls, "viewsize %.15e;\n", vop->vo_size);
  bu_vls_printf(&vls, "orientation %.15e %.15e %.15e %.15e;\n", 
		V4ARGS(quat));
  bu_vls_printf(&vls, "eye_pt %.15e %.15e %.15e;\n",
		eye_model[X], eye_model[Y], eye_model[Z] );
  Tcl_AppendResult(interp, bu_vls_addr(&vls), NULL);
  bu_vls_free(&vls);
  return TCL_OK;
}

/*
 * Usage:
 *        procname get_eyemodel
 */
static int
dgo_get_eyemodel_tcl(ClientData	clientData,
		     Tcl_Interp *interp,
		     int	argc,
		     char	**argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	return dgo_get_eyemodel_cmd(dgop, interp, argc-1, argv+1);
}

int
dgo_rt_cmd(struct dg_obj	*dgop,
	   struct view_obj	*vop,
	   Tcl_Interp		*interp,
	   int			argc,
	   char 		**argv)
{
	register char **vp;
	register int i;
	char	pstring[32];

	if (argc < 1 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_%s %s", argv[0], argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	vp = &dgop->dgo_rt_cmd[0];
#if 1
	*vp++ = argv[0];
#else
	*vp++ = "rt";
#endif
	*vp++ = "-s512";
	*vp++ = "-M";

	if (vop->vo_perspective > 0) {
		(void)sprintf(pstring, "-p%g", vop->vo_perspective);
		*vp++ = pstring;
	}

	for (i=1; i < argc; i++) {
		if (argv[i][0] == '-' && argv[i][1] == '-' &&
		    argv[i][2] == '\0') {
			++i;
			break;
		}
		*vp++ = argv[i];
	}
	*vp++ = dgop->dgo_wdbp->dbip->dbi_filename;

	/*
	 * Now that we've grabbed all the options, if no args remain,
	 * append the names of all stuff currently displayed.
	 * Otherwise, simply append the remaining args.
	 */
	if (i == argc) {
		dgop->dgo_rt_cmd_len = vp - dgop->dgo_rt_cmd;
		dgop->dgo_rt_cmd_len += dgo_build_tops(interp,
						       (struct solid *)&dgop->dgo_headSolid,
						       vp,
						       &dgop->dgo_rt_cmd[MAXARGS]);
	} else {
		while (i < argc)
			*vp++ = argv[i++];
		*vp = 0;
		vp = &dgop->dgo_rt_cmd[0];
		while (*vp)
			Tcl_AppendResult(interp, *vp++, " ", (char *)NULL);

		Tcl_AppendResult(interp, "\n", (char *)NULL);
	}
	(void)dgo_run_rt(dgop, vop);

	return TCL_OK;
}

/*
 * Usage:
 *        procname rt view_obj arg(s)
 */
static int
dgo_rt_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;
	struct view_obj	*vop;

	if (argc < 3 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_%s %s", argv[0], argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	DGO_CHECK_WDBP_NULL(dgop,interp);

	/* search for view object */
	for (BU_LIST_FOR(vop, view_obj, &HeadViewObj.l)) {
		if (strcmp(bu_vls_addr(&vop->vo_name), argv[2]) == 0)
			break;
	}

	if (BU_LIST_IS_HEAD(vop, &HeadViewObj.l)) {
		Tcl_AppendResult(interp, "dgo_rt: bad view object - ", argv[2],
				 "\n", (char *)NULL);
		return TCL_ERROR;
	}

	/* copy command name into argv[2], could be rt or rtedge  */
	argv[2] = argv[1];
	return dgo_rt_cmd(dgop, vop, interp, argc-2, argv+2);
}

int
dgo_vdraw_cmd(struct dg_obj	*dgop,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{
	return bu_cmd((ClientData)dgop, interp, argc-1, argv+1, vdraw_cmds, 0);
}

/*
 * Usage:
 *        procname vdraw cmd arg(s)
 */
static int
dgo_vdraw_tcl(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;

	DGO_CHECK_WDBP_NULL(dgop,interp);

	return dgo_vdraw_cmd(dgop, interp, argc-1, argv+1);
}

void
dgo_zap_cmd(struct dg_obj	*dgop,
	    Tcl_Interp		*interp)
{
	register struct solid *sp;
	register struct solid *nsp;
	struct directory *dp;

	sp = BU_LIST_NEXT(solid, &dgop->dgo_headSolid);
	while (BU_LIST_NOT_HEAD(sp, &dgop->dgo_headSolid)) {
		dp = FIRST_SOLID(sp);
		RT_CK_DIR(dp);
		if (dp->d_addr == RT_DIR_PHONY_ADDR) {
			if (db_dirdelete(dgop->dgo_wdbp->dbip, dp) < 0) {
			  Tcl_AppendResult(interp, "dgo_zap: db_dirdelete failed\n", (char *)NULL);
			}
		}

		nsp = BU_LIST_PNEXT(solid, sp);
		BU_LIST_DEQUEUE(&sp->l);
		FREE_SOLID(sp,&FreeSolid.l);
		sp = nsp;
	}
}

/*
 * Usage:
 *        procname clear|zap
 */
static int
dgo_zap_tcl(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;

	DGO_CHECK_WDBP_NULL(dgop,interp);

	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_%s %s", argv[1], argv[1]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	dgo_zap_cmd(dgop, interp);
	dgo_notify(dgop, interp);

	return TCL_OK;
}

int
dgo_blast_cmd(struct dg_obj	*dgop,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{
	/* First, clear the screen. */
	dgo_zap_cmd(dgop, interp);

	/* Now, draw the new object(s). */
	return dgo_draw_cmd(dgop, interp, argc, argv, 1);
}

/*
 * Usage:
 *        procname blast object(s)
 */
static int
dgo_blast_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;
	int		ret;

	DGO_CHECK_WDBP_NULL(dgop,interp);

	if (argc < 3) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_blast %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	if ((ret = dgo_blast_cmd(dgop, interp, argc-1, argv+1)) == TCL_OK)
		dgo_notify(dgop, interp);

	return ret;
}

#if 0
/*
 * Usage:
 *        procname tol [abs|rel|norm|dist|perp [#]]
 *
 *  abs #	sets absolute tolerance.  # > 0.0
 *  rel #	sets relative tolerance.  0.0 < # < 1.0
 *  norm #	sets normal tolerance, in degrees.
 *  dist #	sets calculational distance tolerance
 *  perp #	sets calculational normal tolerance.
 *
 */
static int
dgo_tol_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct bu_vls vls;
	double	f;

	DGO_CHECK_WDBP_NULL(dgop,interp);

	if (argc < 2 || 4 < argc){
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_tol %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* print all tolerance settings */
	if (argc == 2) {
		Tcl_AppendResult(interp, "Current tolerance settings are:\n", (char *)NULL);
		Tcl_AppendResult(interp, "Tesselation tolerances:\n", (char *)NULL );

		if (dgop->dgo_ttol.abs > 0.0) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "\tabs %g mm\n", dgop->dgo_ttol.abs);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);
		} else {
			Tcl_AppendResult(interp, "\tabs None\n", (char *)NULL);
		}

		if (dgop->dgo_ttol.rel > 0.0) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "\trel %g (%g%%)\n",
				      dgop->dgo_ttol.rel, dgop->dgo_ttol.rel * 100.0 );
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);
		} else {
			Tcl_AppendResult(interp, "\trel None\n", (char *)NULL);
		}

		if (dgop->dgo_ttol.norm > 0.0) {
			int	deg, min;
			double	sec;

			bu_vls_init(&vls);
			sec = dgop->dgo_ttol.norm * bn_radtodeg;
			deg = (int)(sec);
			sec = (sec - (double)deg) * 60;
			min = (int)(sec);
			sec = (sec - (double)min) * 60;

			bu_vls_printf(&vls, "\tnorm %g degrees (%d deg %d min %g sec)\n",
				      dgop->dgo_ttol.norm * bn_radtodeg, deg, min, sec);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);
		} else {
			Tcl_AppendResult(interp, "\tnorm None\n", (char *)NULL);
		}

		bu_vls_init(&vls);
		bu_vls_printf(&vls,"Calculational tolerances:\n");
		bu_vls_printf(&vls,
			      "\tdistance = %g mm\n\tperpendicularity = %g (cosine of %g degrees)\n",
			      dgop->dgo_tol.dist, dgop->dgo_tol.perp,
			      acos(dgop->dgo_tol.perp)*bn_radtodeg);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	/* get the specified tolerance */
	if (argc == 3) {
		int status = TCL_OK;

		bu_vls_init(&vls);

		switch (argv[2][0]) {
		case 'a':
			if (dgop->dgo_ttol.abs > 0.0)
				bu_vls_printf(&vls, "%g", dgop->dgo_ttol.abs);
			else
				bu_vls_printf(&vls, "None");
			break;
		case 'r':
			if (dgop->dgo_ttol.rel > 0.0)
				bu_vls_printf(&vls, "%g", dgop->dgo_ttol.rel);
			else
				bu_vls_printf(&vls, "None");
			break;
		case 'n':
			if (dgop->dgo_ttol.norm > 0.0)
				bu_vls_printf(&vls, "%g", dgop->dgo_ttol.norm);
			else
				bu_vls_printf(&vls, "None");
			break;
		case 'd':
			bu_vls_printf(&vls, "%g", dgop->dgo_tol.dist);
			break;
		case 'p':
			bu_vls_printf(&vls, "%g", dgop->dgo_tol.perp);
			break;
		default:
			bu_vls_printf(&vls, "unrecognized tolerance type - %s\n", argv[2]);
			status = TCL_ERROR;
			break;
		}

		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
		return status;
	}

	/* set the specified tolerance */
	if (sscanf(argv[3], "%lf", &f) != 1) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "bad tolerance - %s\n", argv[3]);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	switch (argv[2][0]) {
	case 'a':
		/* Absolute tol */
		if (f <= 0.0)
			dgop->dgo_ttol.abs = 0.0;
		else
			dgop->dgo_ttol.abs = f;
		break;
	case 'r':
		if (f < 0.0 || f >= 1.0) {
			   Tcl_AppendResult(interp,
					    "relative tolerance must be between 0 and 1, not changed\n",
					    (char *)NULL);
			   return TCL_ERROR;
		}
		/* Note that a value of 0.0 will disable relative tolerance */
		dgop->dgo_ttol.rel = f;
		break;
	case 'n':
		/* Normal tolerance, in degrees */
		if (f < 0.0 || f > 90.0) {
			Tcl_AppendResult(interp,
					 "Normal tolerance must be in positive degrees, < 90.0\n",
					 (char *)NULL);
			return TCL_ERROR;
		}
		/* Note that a value of 0.0 or 360.0 will disable this tol */
		dgop->dgo_ttol.norm = f * bn_degtorad;
		break;
	case 'd':
		/* Calculational distance tolerance */
		if (f < 0.0) {
			Tcl_AppendResult(interp,
					 "Calculational distance tolerance must be positive\n",
					 (char *)NULL);
			return TCL_ERROR;
		}
		dgop->dgo_tol.dist = f;
		dgop->dgo_tol.dist_sq = dgop->dgo_tol.dist * dgop->dgo_tol.dist;
		break;
	case 'p':
		/* Calculational perpendicularity tolerance */
		if (f < 0.0 || f > 1.0) {
			Tcl_AppendResult(interp,
					 "Calculational perpendicular tolerance must be from 0 to 1\n",
					 (char *)NULL);
			return TCL_ERROR;
		}
		dgop->dgo_tol.perp = f;
		dgop->dgo_tol.para = 1.0 - f;
		break;
	default:
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "unrecognized tolerance type - %s\n", argv[2]);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	return TCL_OK;
}
#endif

struct rtcheck {
#ifdef WIN32
	HANDLE			fd;
	HANDLE			hProcess;
	DWORD			pid;
#ifdef TCL_OK
	Tcl_Channel		chan;
#else
	genptr_t chan;
#endif
#else
	int			fd;
	int			pid;
#endif
	FILE			*fp;
	struct bn_vlblock	*vbp;
	struct bu_list		*vhead;
	double			csize;  
	struct dg_obj		*dgop;
	Tcl_Interp		*interp;
};

/*
 *			D G O _ W A I T _ S T A T U S
 *
 *  Interpret the status return of a wait() system call,
 *  for the edification of the watching luser.
 *  Warning:  This may be somewhat system specific, most especially
 *  on non-UNIX machines.
 */
static void
dgo_wait_status(Tcl_Interp *interp, int status)
{
	int	sig = status & 0x7f;
	int	core = status & 0x80;
	int	ret = status >> 8;
	struct bu_vls tmp_vls;

	if (status == 0) {
		Tcl_AppendResult(interp, "Normal exit\n", (char *)NULL);
		return;
	}

	bu_vls_init(&tmp_vls);
	bu_vls_printf(&tmp_vls, "Abnormal exit x%x", status);

	if (core)
		bu_vls_printf(&tmp_vls, ", core dumped");

	if (sig)
		bu_vls_printf(&tmp_vls, ", terminating signal = %d", sig);
	else
		bu_vls_printf(&tmp_vls, ", return (exit) code = %d", ret);

	Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), "\n", (char *)NULL);
	bu_vls_free(&tmp_vls);
}

#ifndef WIN32
static void
dgo_rtcheck_vector_handler(ClientData clientData, int mask)
{
	int value;
	struct solid *sp;
	struct rtcheck *rtcp = (struct rtcheck *)clientData;

	/* Get vector output from rtcheck */
	if ((value = getc(rtcp->fp)) == EOF) {
		int retcode;
		int rpid;

		Tcl_DeleteFileHandler(rtcp->fd);
		fclose(rtcp->fp);

		FOR_ALL_SOLIDS(sp, &rtcp->dgop->dgo_headSolid)
			sp->s_flag = DOWN;

		/* Add overlay */
		dgo_cvt_vlblock_to_solids(rtcp->dgop, rtcp->interp, rtcp->vbp, "OVERLAPS", 0);
		rt_vlblock_free(rtcp->vbp);

		/* wait for the forked process */
		while ((rpid = wait(&retcode)) != rtcp->pid && rpid != -1)
			dgo_wait_status(rtcp->interp, retcode);

		dgo_notify(rtcp->dgop, rtcp->interp);

		/* free rtcp */
		bu_free((genptr_t)rtcp, "dgo_rtcheck_vector_handler: rtcp");

		return;
	}

	(void)rt_process_uplot_value(&rtcp->vhead,
				     rtcp->vbp,
				     rtcp->fp,
				     value,
				     rtcp->csize);
}

static void
dgo_rtcheck_output_handler(ClientData clientData, int mask)
{
	int count;
	char line[RT_MAXLINE];
	int fd = (int)((long)clientData & 0xFFFF);	/* fd's will be small */

	/* Get textual output from rtcheck */
	if((count = read((int)fd, line, RT_MAXLINE)) == 0){
		Tcl_DeleteFileHandler(fd);
		close(fd);

		return;
	}

	line[count] = '\0';
	bu_log("%s", line);
}

#else

void
dgo_rtcheck_vector_handler(ClientData clientData, int mask)
{
	int value;
	struct solid *sp;
	struct rtcheck *rtcp = (struct rtcheck *)clientData;

	/* Get vector output from rtcheck */
	if ((value = getc(rtcp->fp)) == EOF) {

		Tcl_DeleteChannelHandler(rtcp->chan,dgo_rtcheck_vector_handler,(ClientData)rtcp);
		CloseHandle(rtcp->fd);
		fclose(rtcp->fp);

		FOR_ALL_SOLIDS(sp, &rtcp->dgop->dgo_headSolid)
			sp->s_flag = DOWN;

		/* Add overlay */
		dgo_cvt_vlblock_to_solids(rtcp->dgop, rtcp->interp, rtcp->vbp, "OVERLAPS", 0);
		rt_vlblock_free(rtcp->vbp);

		/* wait for the forked process */
		WaitForSingleObject( rtcp->hProcess, INFINITE );

/*		while ((rpid = wait(&retcode)) != rtcp->pid && rpid != -1)
			dgo_wait_status(rtcp->interp, retcode);*/

		dgo_notify(rtcp->dgop, rtcp->interp);

		/* free rtcp */
		bu_free((genptr_t)rtcp, "dgo_rtcheck_vector_handler: rtcp");

		return;
	}

	(void)rt_process_uplot_value(&rtcp->vhead,
				     rtcp->vbp,
				     rtcp->fp,
				     value,
				     rtcp->csize);
}

void
dgo_rtcheck_output_handler(ClientData clientData, int mask)
{
	int count;
	char line[RT_MAXLINE];
	HANDLE fd = (HANDLE)clientData;

	/* Get textual output from rtcheck */
	if((!ReadFile(fd, line, RT_MAXLINE,&count,0))){

	Tcl_DeleteChannelHandler(chan1,dgo_rtcheck_output_handler,(ClientData)fd);
	CloseHandle(fd);

		return;
	}

	line[count] = '\0';
	bu_log("%s", line);
}

#endif

int
dgo_rtcheck_cmd(struct dg_obj	*dgop,
		struct view_obj	*vop,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	register char **vp;
	register int i;
	int	pid; 	 
#ifndef WIN32
	int	i_pipe[2];	/* object reads results for building vectors */
	int	o_pipe[2];	/* object writes view parameters */
	int	e_pipe[2];	/* object reads textual results */
#else
	HANDLE	i_pipe[2],hSavei,pipe_iDup;	/* MGED reads results for building vectors */
	HANDLE	o_pipe[2],hSaveo,pipe_oDup;	/* MGED writes view parameters */
	HANDLE	e_pipe[2],hSavee,pipe_eDup;	/* MGED reads textual results */
	STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    SECURITY_ATTRIBUTES sa          = {0};
    char line[2048];
    char name[256];
#endif
	FILE	*fp;
	struct rtcheck *rtcp;
	vect_t temp;
	vect_t eye_model;

#ifndef WIN32
	vp = &dgop->dgo_rt_cmd[0];
	*vp++ = "rtcheck";
	*vp++ = "-s50";
	*vp++ = "-M";
	for (i=1; i < argc; i++)
		*vp++ = argv[i];
	*vp++ = dgop->dgo_wdbp->dbip->dbi_filename;

	/*
	 * Now that we've grabbed all the options, if no args remain,
	 * append the names of all stuff currently displayed.
	 * Otherwise, simply append the remaining args.
	 */
	if (i == argc) {
		dgop->dgo_rt_cmd_len = vp - dgop->dgo_rt_cmd;
		dgop->dgo_rt_cmd_len += dgo_build_tops(interp,
						       (struct solid *)&dgop->dgo_headSolid,
						       vp,
						       &dgop->dgo_rt_cmd[MAXARGS]);
	} else {
		while (i < argc)
			*vp++ = argv[i++];
		*vp = 0;
		vp = &dgop->dgo_rt_cmd[0];
		while (*vp)
			Tcl_AppendResult(interp, *vp++, " ", (char *)NULL);

		Tcl_AppendResult(interp, "\n", (char *)NULL);
	}

	(void)pipe(i_pipe);
	(void)pipe(o_pipe);
	(void)pipe(e_pipe);

	if ((pid = fork()) == 0) {
		/* Redirect stdin, stdout and stderr */
		(void)close(0);
		(void)dup(o_pipe[0]);
		(void)close(1);
		(void)dup(i_pipe[1]);
		(void)close(2);
		(void)dup(e_pipe[1]);

		/* close pipes */
		(void)close(i_pipe[0]);
		(void)close(i_pipe[1]);
		(void)close(o_pipe[0]);
		(void)close(o_pipe[1]);
		(void)close(e_pipe[0]);
		(void)close(e_pipe[1]);

		for (i=3; i < 20; i++)
			(void)close(i);

		(void)execvp(dgop->dgo_rt_cmd[0], dgop->dgo_rt_cmd);
		perror(dgop->dgo_rt_cmd[0]);
		exit(16);
	}

	/* As parent, send view information down pipe */
	(void)close(o_pipe[0]);
	fp = fdopen(o_pipe[1], "w"); 
#if 1
	VSET(temp, 0.0, 0.0, 1.0);
	MAT4X3PNT(eye_model, vop->vo_view2model, temp);
#else
	dgo_rt_set_eye_model(dgop, vop, eye_model);
#endif
	dgo_rt_write(dgop, vop, fp, eye_model);

	(void)fclose(fp);

	/* close write end of pipes */
	(void)close(i_pipe[1]);
	(void)close(e_pipe[1]);

	BU_GETSTRUCT(rtcp, rtcheck);

	/* initialize the rtcheck struct */
	rtcp->fd = i_pipe[0];
	rtcp->fp = fdopen(i_pipe[0], "r");
	rtcp->pid = pid;
	rtcp->vbp = rt_vlblock_init();
	rtcp->vhead = rt_vlblock_find(rtcp->vbp, 0xFF, 0xFF, 0x00);
	rtcp->csize = vop->vo_scale * 0.01;
	rtcp->dgop = dgop;
	rtcp->interp = interp;

	/* register file handlers */
	Tcl_CreateFileHandler(i_pipe[0], TCL_READABLE,
			      dgo_rtcheck_vector_handler, (ClientData)rtcp);
	Tcl_CreateFileHandler(e_pipe[0], TCL_READABLE,
			      dgo_rtcheck_output_handler, (ClientData)e_pipe[0]);

	return TCL_OK;
#else

	vp = &dgop->dgo_rt_cmd[0];
	*vp++ = "rtcheck";
	*vp++ = "-s50";
	*vp++ = "-M";
	for (i=1; i < argc; i++)
		*vp++ = argv[i];
	*vp++ = dgop->dgo_wdbp->dbip->dbi_filename;

	/*
	 * Now that we've grabbed all the options, if no args remain,
	 * append the names of all stuff currently displayed.
	 * Otherwise, simply append the remaining args.
	 */
	if (i == argc) {
		dgop->dgo_rt_cmd_len = vp - dgop->dgo_rt_cmd;
		dgop->dgo_rt_cmd_len += dgo_build_tops(interp,
						       (struct solid *)&dgop->dgo_headSolid,
						       vp,
						       &dgop->dgo_rt_cmd[MAXARGS]);
	} else {
		while (i < argc)
			*vp++ = argv[i++];
		*vp = 0;
		vp = &dgop->dgo_rt_cmd[0];
		while (*vp)
			Tcl_AppendResult(interp, *vp++, " ", (char *)NULL);

		Tcl_AppendResult(interp, "\n", (char *)NULL);
	}

    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDERR.  
	hSavee = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDERR.  
	CreatePipe( &e_pipe[0], &e_pipe[1], &sa, 0);

	// Set a write handle to the pipe to be STDERR.  
	SetStdHandle(STD_ERROR_HANDLE, e_pipe[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), e_pipe[0],
        GetCurrentProcess(),  &pipe_eDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( e_pipe[0]);



	// Save the handle to the current STDOUT.  
	hSaveo = GetStdHandle(STD_OUTPUT_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &o_pipe[0], &o_pipe[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_OUTPUT_HANDLE, o_pipe[0]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), o_pipe[1],
        GetCurrentProcess(),  &pipe_oDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( o_pipe[1]);
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSavei = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&i_pipe[0], &i_pipe[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, i_pipe[1]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), i_pipe[0], 
		GetCurrentProcess(), &pipe_iDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(i_pipe[0]);

   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
 /*  si.hStdInput   = i_pipe[0];
   si.hStdOutput  = o_pipe[1];
   si.hStdError   = e_pipe[1];*/

   
   si.hStdInput   = i_pipe[1];
   si.hStdOutput  = o_pipe[0];
   si.hStdError   = e_pipe[1];

     sprintf(line,"%s ",dgop->dgo_rt_cmd[0]);
   for(i=1;i<dgop->dgo_rt_cmd_len;i++) {
	   sprintf(name,"%s ",dgop->dgo_rt_cmd[i]);
	   strcat(line,name); }

    if(CreateProcess(NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSavei);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveo);
	SetStdHandle(STD_ERROR_HANDLE, hSavee);
}


	/* As parent, send view information down pipe */
	CloseHandle(o_pipe[0]);
	fp = _fdopen( _open_osfhandle((HFILE)pipe_oDup,_O_TEXT), "w" );
#if 1
	VSET(temp, 0.0, 0.0, 1.0);
	MAT4X3PNT(eye_model, vop->vo_view2model, temp);
#else
	dgo_rt_set_eye_model(dgop, vop, eye_model);
#endif
	dgo_rt_write(dgop, vop, fp, eye_model);

	(void)fclose(fp);

	/* close write end of pipes */
	(void)CloseHandle(i_pipe[1]);
	(void)CloseHandle(e_pipe[1]);

	BU_GETSTRUCT(rtcp, rtcheck);

	/* initialize the rtcheck struct */
	rtcp->fd = pipe_iDup;
	rtcp->fp = _fdopen( _open_osfhandle((HFILE)pipe_iDup,_O_TEXT), "r" );
	rtcp->hProcess = pi.hProcess;
	rtcp->pid = pi.dwProcessId;
	rtcp->vbp = rt_vlblock_init();
	rtcp->vhead = rt_vlblock_find(rtcp->vbp, 0xFF, 0xFF, 0x00);
	rtcp->csize = vop->vo_scale * 0.01;
	rtcp->dgop = dgop;
	rtcp->interp = interp;

	rtcp->chan = Tcl_MakeFileChannel(rtcp->fd,TCL_READABLE);
	Tcl_CreateChannelHandler(rtcp->chan,TCL_READABLE,
			      dgo_rtcheck_vector_handler, (ClientData)rtcp);

	chan1 = Tcl_MakeFileChannel(pipe_eDup,TCL_READABLE);
	Tcl_CreateChannelHandler(chan1,TCL_READABLE,
			      dgo_rtcheck_output_handler,pipe_eDup);

	return TCL_OK;


#endif
}

/*
 * Usage:
 *        procname rtcheck view_obj [args]
 */
static int
dgo_rtcheck_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct view_obj *vop;

	DGO_CHECK_WDBP_NULL(dgop,interp);

	if (argc < 3 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_rtcheck %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	/* search for view object */
	for (BU_LIST_FOR(vop, view_obj, &HeadViewObj.l)) {
		if (strcmp(bu_vls_addr(&vop->vo_name), argv[2]) == 0)
			break;
	}

	if (BU_LIST_IS_HEAD(vop, &HeadViewObj.l)) {
		Tcl_AppendResult(interp, "dgo_rtcheck: bad view object - ", argv[2],
				 "\n", (char *)NULL);
		return TCL_ERROR;
	}

	return dgo_rtcheck_cmd(dgop, vop, interp, argc-2, argv+2);
}

/*
 * Associate this drawable geometry object with a database object.
 *
 * Usage:
 *        procname assoc [wdb_obj]
 */
static int
dgo_assoc_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct rt_wdb *wdbp;
	struct bu_vls vls;

	/* Get associated database object */
	if (argc == 2) {
		if (dgop->dgo_wdbp == RT_WDB_NULL)
			Tcl_AppendResult(interp, (char *)NULL);
		else
			Tcl_AppendResult(interp, bu_vls_addr(&dgop->dgo_wdbp->wdb_name), (char *)NULL);
		return TCL_OK;
	}

	/* Set associated database object */
	if (argc == 3) {
		/* search for database object */
		for (BU_LIST_FOR(wdbp, rt_wdb, &rt_g.rtg_headwdb.l)) {
			if (strcmp(bu_vls_addr(&wdbp->wdb_name), argv[2]) == 0)
				break;
		}

		if (BU_LIST_IS_HEAD(wdbp, &rt_g.rtg_headwdb.l))
			wdbp = RT_WDB_NULL;

		if (dgop->dgo_wdbp != RT_WDB_NULL)
			dgo_zap_cmd(dgop, interp);

		dgop->dgo_wdbp = wdbp;
		dgo_notify(dgop, interp);

		return TCL_OK;
	}

	/* return help message */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dgo_assoc %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Attach/detach observers to/from list.
 *
 * Usage:
 *	  procname observer cmd [args]
 *
 */
static int
dgo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;

	if (argc < 3) {
		struct bu_vls vls;

		/* return help message */
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_observer %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	return bu_cmd((ClientData)&dgop->dgo_observers,
		      interp, argc - 2, argv + 2, bu_observer_cmds, 0);
}

int
dgo_report_cmd(struct dg_obj	*dgop,
	       Tcl_Interp	*interp,
	       int		argc,
	       char 		**argv)
{
	int		lvl = 0;

	if (argc < 1 || 2 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_report %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (argc == 2)
		lvl = atoi(argv[1]);

	if (lvl <= 3)
		dgo_print_schain(dgop, interp, lvl);
	else
		dgo_print_schain_vlcmds(dgop, interp);

	return TCL_OK;
}

/*
 *  Report information about solid table, and per-solid VLS
 */
static int
dgo_report_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;

	DGO_CHECK_WDBP_NULL(dgop,interp);

	return dgo_report_cmd(dgop, interp, argc-1, argv+1);
}


#ifndef WIN32
int
dgo_rtabort_cmd(struct dg_obj	*dgop,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	struct run_rt	*rrp;

	for (BU_LIST_FOR(rrp, run_rt, &dgop->dgo_headRunRt.l)) {
		kill(rrp->pid, SIGKILL);
		rrp->aborted = 1;
	}

	return TCL_OK;
}
#else
int
dgo_rtabort_cmd(struct dg_obj	*dgop,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	struct run_rt *rrp;
	HANDLE hProcess;      

	for (BU_LIST_FOR(rrp, run_rt, &dgop->dgo_headRunRt.l)) {
		hProcess= OpenProcess(PROCESS_ALL_ACCESS, TRUE,rrp->pid);
		if(hProcess != NULL)
			TerminateProcess(hProcess, 0);
		rrp->aborted = 1;
	}

	return TCL_OK;
}
#endif

static int
dgo_rtabort_tcl(ClientData clientData,
		 Tcl_Interp *interp,
		 int argc,
		 char **argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;

	return dgo_rtabort_cmd(dgop, interp, argc-1, argv+1);
}

static int
dgo_qray_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	
	DGO_CHECK_WDBP_NULL(dgop,interp);
	return dgo_qray_cmd(dgop, interp, argc-1, argv+1);
}

static int
dgo_nirt_tcl(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;
	struct view_obj	*vop;
	
	if (argc < 3 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_nirt %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	DGO_CHECK_WDBP_NULL(dgop,interp);

	/* search for view object */
	for (BU_LIST_FOR(vop, view_obj, &HeadViewObj.l)) {
		if (strcmp(bu_vls_addr(&vop->vo_name), argv[2]) == 0)
			break;
	}

	if (BU_LIST_IS_HEAD(vop, &HeadViewObj.l)) {
		Tcl_AppendResult(interp, "dgo_nirt: bad view object - ", argv[2],
				 "\n", (char *)NULL);
		return TCL_ERROR;
	}

	return dgo_nirt_cmd(dgop, vop, interp, argc-2, argv+2);
}

static int
dgo_vnirt_tcl(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;
	struct view_obj	*vop;
	
	if (argc < 5 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_vnirt %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	DGO_CHECK_WDBP_NULL(dgop,interp);

	/* search for view object */
	for (BU_LIST_FOR(vop, view_obj, &HeadViewObj.l)) {
		if (strcmp(bu_vls_addr(&vop->vo_name), argv[2]) == 0)
			break;
	}

	if (BU_LIST_IS_HEAD(vop, &HeadViewObj.l)) {
		Tcl_AppendResult(interp, "dgo_vnirt: bad view object - ", argv[2],
				 "\n", (char *)NULL);
		return TCL_ERROR;
	}

	return dgo_vnirt_cmd(dgop, vop, interp, argc-2, argv+2);
}

int
dgo_set_transparency_cmd(struct dg_obj	*dgop,
			 Tcl_Interp	*interp,
			 int		argc,
			 char 		**argv)
{
	register struct solid *sp;
	int i;
	struct directory **dpp;
	register struct directory **tmp_dpp;
	fastf_t transparency;


	if (argc != 3) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_set_transparency %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	if (sscanf(argv[2], "%lf", &transparency) != 1) {
		Tcl_AppendResult(interp, "dgo_set_transparency: bad transparency - ",
				 argv[2], "\n", (char *)NULL);
		return TCL_ERROR;
	}

	if ((dpp = dgo_build_dpp(dgop, interp, argv[1])) == NULL) {
	  return TCL_OK;
	}

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
	  for (i = 0, tmp_dpp = dpp;
	       i <= sp->s_fullpath.fp_len && *tmp_dpp != DIR_NULL;
	       ++i, ++tmp_dpp) {
	    if (sp->s_fullpath.fp_names[i] != *tmp_dpp)
	      break;
	  }

	  if (*tmp_dpp != DIR_NULL)
	    continue;

	  /* found a match */
	  sp->s_transparency = transparency;
	}

	if (dpp != (struct directory **)NULL)
	  bu_free((genptr_t)dpp, "dgo_how_cmd: directory pointers");

	return TCL_OK;
}

/*
 * Sets the transparency of obj.
 *
 * Usage:
 *        procname set_transparency obj t
 */
static int
dgo_set_transparency_tcl(ClientData	clientData,
			 Tcl_Interp	*interp,
			 int		argc,
			 char	        **argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	int ret;

	if ((ret = dgo_set_transparency_cmd(dgop, interp, argc-1, argv+1)) == TCL_OK)
		dgo_notify(dgop, interp);

	return ret;
}

int
dgo_shaded_mode_cmd(struct dg_obj	*dgop,
		    Tcl_Interp		*interp,
		    int			argc,
		    char 		**argv)
{
  struct bu_vls vls;

  /* get shaded mode */
  if (argc == 1) {
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%d", dgop->dgo_shaded_mode);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)0);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  /* set shaded mode */
  if (argc == 2) {
    int shaded_mode;

    if (sscanf(argv[1], "%d", &shaded_mode) != 1)
      goto bad;

    if (shaded_mode < 0 || 2 < shaded_mode)
      goto bad;

    dgop->dgo_shaded_mode = shaded_mode;
    return TCL_OK;
  }

 bad:
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "helplib_alias dgo_shaded_mode %s", argv[0]);
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  return TCL_ERROR;
}

/*
 * Usage:
 *        procname shaded_mode [m]
 */
static int
dgo_shaded_mode_tcl(ClientData	clientData,
		    Tcl_Interp	*interp,
		    int		argc,
		    char	**argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;

	return dgo_shaded_mode_cmd(dgop, interp, argc-1, argv+1);
}

#if 0
/* skeleton functions for dg_obj methods */
int
dgo__cmd(struct dg_obj	*dgop,
	 Tcl_Interp	*interp,
	 int		argc,
	 char 		**argv)
{
}

/*
 * Usage:
 *        procname 
 */
static int
dgo__tcl(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;

	return dgo__cmd(dgop, interp, argc-1, argv+1);
}
#endif

/****************** Utility Routines ********************/

static union tree *
dgo_wireframe_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	return (curtree);
}

/*
 *			D G O _ W I R E F R A M E _ L E A F
 *
 *  This routine must be prepared to run in parallel.
 */
static union tree *
dgo_wireframe_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
{
	union tree	*curtree;
	int		dashflag;		/* draw with dashed lines */
	struct bu_list	vhead;
	struct dg_client_data *dgcdp = (struct dg_client_data *)client_data;

	RT_CK_TESS_TOL(tsp->ts_ttol);
	BN_CK_TOL(tsp->ts_tol);
	RT_CK_RESOURCE(tsp->ts_resp);

	BU_LIST_INIT(&vhead);

	if (RT_G_DEBUG&DEBUG_TREEWALK) {
		char	*sofar = db_path_to_string(pathp);

		Tcl_AppendResult(dgcdp->interp, "dgo_wireframe_leaf(",
				 ip->idb_meth->ft_name,
				 ") path='", sofar, "'\n", (char *)NULL);
		bu_free((genptr_t)sofar, "path string");
	}

	if (dgcdp->draw_solid_lines_only)
		dashflag = 0;
	else
		dashflag = (tsp->ts_sofar & (TS_SOFAR_MINUS|TS_SOFAR_INTER));

	RT_CK_DB_INTERNAL(ip);

	if (ip->idb_meth->ft_plot(&vhead, ip,
				   tsp->ts_ttol,
				   tsp->ts_tol) < 0) {
		Tcl_AppendResult(dgcdp->interp, DB_FULL_PATH_CUR_DIR(pathp)->d_namep,
				 ": plot failure\n", (char *)NULL);
		return (TREE_NULL);		/* ERROR */
	}

	/*
	 * XXX HACK CTJ - dgo_drawH_part2 sets the default color of a
	 * solid by looking in tps->ts_mater.ma_color, for pseudo
	 * solids, this needs to be something different and drawH
	 * has no idea or need to know what type of solid this is.
	 */
	if (ip->idb_type == ID_GRIP) {
		int r,g,b;
		r= tsp->ts_mater.ma_color[0];
		g= tsp->ts_mater.ma_color[1];
		b= tsp->ts_mater.ma_color[2];
		tsp->ts_mater.ma_color[0] = 0;
		tsp->ts_mater.ma_color[1] = 128;
		tsp->ts_mater.ma_color[2] = 128;
		dgo_drawH_part2(dashflag, &vhead, pathp, tsp, SOLID_NULL, dgcdp);
		tsp->ts_mater.ma_color[0] = r;
		tsp->ts_mater.ma_color[1] = g;
		tsp->ts_mater.ma_color[2] = b;
	} else {
		dgo_drawH_part2(dashflag, &vhead, pathp, tsp, SOLID_NULL, dgcdp);
	}

	/* Indicate success by returning something other than TREE_NULL */
	RT_GET_TREE(curtree, tsp->ts_resp);
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;

	return (curtree);
}

/*
 *			D G O _ N M G _ R E G I O N _ S T A R T
 *
 *  When performing "ev" on a region, consider whether to process
 *  the whole subtree recursively.
 *  Normally, say "yes" to all regions by returning 0.
 *
 *  Check for special case:  a region of one solid, which can be
 *  directly drawn as polygons without going through NMGs.
 *  If we draw it here, then return -1 to signal caller to ignore
 *  further processing of this region.
 *  A hack to view polygonal models (converted from FASTGEN) more rapidly.
 */
static int
dgo_nmg_region_start(struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
{
	union tree		*tp;
	struct directory	*dp;
	struct rt_db_internal	intern;
	mat_t			xform;
	matp_t			matp;
	struct bu_list		vhead;
	struct dg_client_data *dgcdp = (struct dg_client_data *)client_data;

	if (RT_G_DEBUG&DEBUG_TREEWALK) {
		char	*sofar = db_path_to_string(pathp);
		bu_log("dgo_nmg_region_start(%s)\n", sofar);
		bu_free((genptr_t)sofar, "path string");
		rt_pr_tree( combp->tree, 1 );
		db_pr_tree_state(tsp);
	}

	RT_CK_DBI(tsp->ts_dbip);
	RT_CK_RESOURCE(tsp->ts_resp);

	BU_LIST_INIT(&vhead);

	RT_CK_COMB(combp);
	tp = combp->tree;
	if (!tp)
		return( -1 );
	RT_CK_TREE(tp);
	if (tp->tr_l.tl_op != OP_DB_LEAF)
		return 0;	/* proceed as usual */

	/* The subtree is a single node.  It may be a combination, though */

	/* Fetch by name, check to see if it's an easy type */
	dp = db_lookup( tsp->ts_dbip, tp->tr_l.tl_name, LOOKUP_NOISY );
	if (!dp)
		return 0;	/* proceed as usual */
	if (tsp->ts_mat) {
		if (tp->tr_l.tl_mat) {
			matp = xform;
			bn_mat_mul(xform, tsp->ts_mat, tp->tr_l.tl_mat);
		} else {
			matp = tsp->ts_mat;
		}
	} else {
		if (tp->tr_l.tl_mat) {
			matp = tp->tr_l.tl_mat;
		} else {
			matp = (matp_t)NULL;
		}
	}
	if (rt_db_get_internal(&intern, dp, tsp->ts_dbip, matp, &rt_uniresource) < 0)
		return 0;	/* proceed as usual */

	switch (intern.idb_type) {
	case ID_POLY:
		{
			if (RT_G_DEBUG&DEBUG_TREEWALK) {
				bu_log("fastpath draw ID_POLY %s\n", dp->d_namep);
			}
			if (dgcdp->draw_wireframes) {
				(void)rt_pg_plot( &vhead, &intern, tsp->ts_ttol, tsp->ts_tol );
			} else {
				(void)rt_pg_plot_poly( &vhead, &intern, tsp->ts_ttol, tsp->ts_tol );
			}
		}
		goto out;
	case ID_BOT:
		{
			if (RT_G_DEBUG&DEBUG_TREEWALK) {
				bu_log("fastpath draw ID_BOT %s\n", dp->d_namep);
			}
			if (dgcdp->draw_wireframes) {
				(void)rt_bot_plot( &vhead, &intern, tsp->ts_ttol, tsp->ts_tol );
			} else {
				(void)rt_bot_plot_poly( &vhead, &intern, tsp->ts_ttol, tsp->ts_tol );
			}
		}
		goto out;
	case ID_COMBINATION:
	default:
		break;
	}
	rt_db_free_internal(&intern, tsp->ts_resp);
	return 0;

out:
	/* Successful fastpath drawing of this solid */
	db_add_node_to_full_path(pathp, dp);
	dgo_drawH_part2(0, &vhead, pathp, tsp, SOLID_NULL, dgcdp);
	DB_FULL_PATH_POP(pathp);
	rt_db_free_internal(&intern, tsp->ts_resp);
	dgcdp->fastpath_count++;
	return -1;	/* SKIP THIS REGION */
}

/*
 *			D G O _ N M G _ R E G I O N _ E N D
 *
 *  This routine must be prepared to run in parallel.
 */
static union tree *
dgo_nmg_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	struct nmgregion	*r;
	struct bu_list		vhead;
	int			failed;
	struct dg_client_data *dgcdp = (struct dg_client_data *)client_data;

	RT_CK_TESS_TOL(tsp->ts_ttol);
	BN_CK_TOL(tsp->ts_tol);
	NMG_CK_MODEL(*tsp->ts_m);
	RT_CK_RESOURCE(tsp->ts_resp);

	BU_LIST_INIT( &vhead );

	if(RT_G_DEBUG&DEBUG_TREEWALK)  {
	  char	*sofar = db_path_to_string(pathp);

	  Tcl_AppendResult(dgcdp->interp, "dgo_nmg_region_end() path='", sofar,
			   "'\n", (char *)NULL);
	  bu_free((genptr_t)sofar, "path string");
	} else {
	  char	*sofar = db_path_to_string(pathp);

	  bu_log( "%s:\n", sofar );
	  bu_free((genptr_t)sofar, "path string");
	}

	if( curtree->tr_op == OP_NOP )  return  curtree;

	if ( !dgcdp->draw_nmg_only ) {
		if( BU_SETJUMP )
		{
			char  *sofar = db_path_to_string(pathp);

			BU_UNSETJUMP;

			Tcl_AppendResult(dgcdp->interp, "WARNING: Boolean evaluation of ", sofar,
				" failed!!!\n", (char *)NULL );
			bu_free((genptr_t)sofar, "path string");
			if( curtree )
				db_free_tree( curtree, tsp->ts_resp );
			return (union tree *)NULL;
		}
		failed = nmg_boolean( curtree, *tsp->ts_m, tsp->ts_tol, tsp->ts_resp );
		BU_UNSETJUMP;
		if( failed )  {
			db_free_tree( curtree, tsp->ts_resp );
			return (union tree *)NULL;
		}
	}
	else if( curtree->tr_op != OP_NMG_TESS )
	{
	  Tcl_AppendResult(dgcdp->interp, "Cannot use '-d' option when Boolean evaluation is required\n", (char *)NULL);
	  db_free_tree( curtree, tsp->ts_resp );
	  return (union tree *)NULL;
	}
	r = curtree->tr_d.td_r;
	NMG_CK_REGION(r);

	if( dgcdp->do_not_draw_nmg_solids_during_debugging && r )  {
		db_free_tree( curtree, tsp->ts_resp );
		return (union tree *)NULL;
	}

	if (dgcdp->nmg_triangulate) {
		if (BU_SETJUMP) {
			char  *sofar = db_path_to_string(pathp);

			BU_UNSETJUMP;

			Tcl_AppendResult(dgcdp->interp, "WARNING: Triangulation of ", sofar,
				" failed!!!\n", (char *)NULL );
			bu_free((genptr_t)sofar, "path string");
			if( curtree )
				db_free_tree( curtree, tsp->ts_resp );
			return (union tree *)NULL;
		}
		nmg_triangulate_model(*tsp->ts_m, tsp->ts_tol);
		BU_UNSETJUMP;
	}

	if( r != 0 )  {
		int	style;
		/* Convert NMG to vlist */
		NMG_CK_REGION(r);

		if (dgcdp->draw_wireframes) {
			/* Draw in vector form */
			style = NMG_VLIST_STYLE_VECTOR;
		} else {
			/* Default -- draw polygons */
			style = NMG_VLIST_STYLE_POLYGON;
		}
		if (dgcdp->draw_normals) {
			style |= NMG_VLIST_STYLE_VISUALIZE_NORMALS;
		}
		if (dgcdp->shade_per_vertex_normals) {
			style |= NMG_VLIST_STYLE_USE_VU_NORMALS;
		}
		if (dgcdp->draw_no_surfaces) {
			style |= NMG_VLIST_STYLE_NO_SURFACES;
		}
		nmg_r_to_vlist(&vhead, r, style);

		dgo_drawH_part2(0, &vhead, pathp, tsp, SOLID_NULL, dgcdp);

		if (dgcdp->draw_edge_uses) {
			nmg_vlblock_r(dgcdp->draw_edge_uses_vbp, r, 1);
		}
		/* NMG region is no longer necessary, only vlist remains */
		db_free_tree( curtree, tsp->ts_resp );
		return (union tree *)NULL;
	}

	/* Return tree -- it needs to be freed (by caller) */
	return curtree;
}

/*
 *			D G O _ D R A W T R E E S
 *
 *  This routine is the drawable geometry object's analog of rt_gettrees().
 *  Add a set of tree hierarchies to the active set.
 *  Note that argv[0] should be ignored, it has the command name in it.
 *
 *  Kind =
 *	1	regular wireframes
 *	2	big-E
 *	3	NMG polygons
 *  
 *  Returns -
 *  	0	Ordinarily
 *	-1	On major error
 */
static int
dgo_drawtrees(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv, int kind, struct dg_client_data *_dgcdp)
{
  int		ret = 0;
  register int	c;
  int		ncpu = 1;
  int		dgo_nmg_use_tnurbs = 0;
  int		dgo_enable_fastpath = 0;
  struct model	*dgo_nmg_model;
  struct dg_client_data *dgcdp;
  RT_CHECK_DBI(dgop->dgo_wdbp->dbip);

  if (argc <= 0)
    return(-1);	/* FAIL */

  /* options are already parsed into _dgcdp */
  if (_dgcdp != (struct dg_client_data *)0) {
    BU_GETSTRUCT(dgcdp, dg_client_data);
    *dgcdp = *_dgcdp;            /* struct copy */
  } else {

    BU_GETSTRUCT(dgcdp, dg_client_data);
    dgcdp->dgop = dgop;
    dgcdp->interp = interp;

    /* Initial values for options, must be reset each time */
    dgcdp->draw_nmg_only = 0;	/* no booleans */
    dgcdp->nmg_triangulate = 1;
    dgcdp->draw_wireframes = 0;
    dgcdp->draw_normals = 0;
    dgcdp->draw_solid_lines_only = 0;
    dgcdp->draw_no_surfaces = 0;
    dgcdp->shade_per_vertex_normals = 0;
    dgcdp->draw_edge_uses = 0;
    dgcdp->wireframe_color_override = 0;
    dgcdp->fastpath_count = 0;

    /* default color - red */
    dgcdp->wireframe_color[0] = 255;
    dgcdp->wireframe_color[1] = 0;
    dgcdp->wireframe_color[2] = 0;

    /* default transparency - opaque */
    dgcdp->transparency = 1.0;

    /* -1 indicates flag not set */
    dgcdp->shaded_mode_override = -1;

    dgo_enable_fastpath = 0;

    /* Parse options. */
    bu_optind = 0;		/* re-init bu_getopt() */
    while ((c = bu_getopt(argc,argv,"dfm:nqstuvwx:C:STP:")) != EOF) {
      switch (c) {
	case 'u':
	  dgcdp->draw_edge_uses = 1;
	  break;
	case 's':
	  dgcdp->draw_solid_lines_only = 1;
	  break;
	case 't':
	  dgo_nmg_use_tnurbs = 1;
	  break;
	case 'v':
	  dgcdp->shade_per_vertex_normals = 1;
	  break;
	case 'w':
	  dgcdp->draw_wireframes = 1;
	  break;
	case 'S':
	  dgcdp->draw_no_surfaces = 1;
	  break;
	case 'T':
	  dgcdp->nmg_triangulate = 0;
	  break;
	case 'n':
	  dgcdp->draw_normals = 1;
	  break;
	case 'P':
	  ncpu = atoi(bu_optarg);
	  break;
	case 'q':
	  dgcdp->do_not_draw_nmg_solids_during_debugging = 1;
	  break;
	case 'd':
	  dgcdp->draw_nmg_only = 1;
	  break;
	case 'f':
	  dgo_enable_fastpath = 1;
	  break;
	case 'C':
	  {
	    int		r,g,b;
	    register char	*cp = bu_optarg;

	    r = atoi(cp);
	    while( (*cp >= '0' && *cp <= '9') )  cp++;
	    while( *cp && (*cp < '0' || *cp > '9') ) cp++;
	    g = atoi(cp);
	    while( (*cp >= '0' && *cp <= '9') )  cp++;
	    while( *cp && (*cp < '0' || *cp > '9') ) cp++;
	    b = atoi(cp);

	    if( r < 0 || r > 255 )  r = 255;
	    if( g < 0 || g > 255 )  g = 255;
	    if( b < 0 || b > 255 )  b = 255;

	    dgcdp->wireframe_color_override = 1;
	    dgcdp->wireframe_color[0] = r;
	    dgcdp->wireframe_color[1] = g;
	    dgcdp->wireframe_color[2] = b;
	  }
	  break;
	case 'm':
	  /* clamp it to [-infinity,2] */
	  dgcdp->shaded_mode_override = atoi(bu_optarg);
	  if (2 < dgcdp->shaded_mode_override)
	    dgcdp->shaded_mode_override = 2;

	  break;
	case 'x':
	  dgcdp->transparency = atof(bu_optarg);

	  /* clamp it to [0,1] */
	  if (dgcdp->transparency < 0.0)
	    dgcdp->transparency = 0.0;

	  if (1.0 < dgcdp->transparency)
	    dgcdp->transparency = 1.0;

	  break;
	default:
	  {
	    struct bu_vls vls;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "helplib %s", argv[0]);
	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	    bu_free((genptr_t)dgcdp, "dgo_drawtrees: dgcdp");

	    return TCL_ERROR;
	  }
      }
    }
    argc -= bu_optind;
    argv += bu_optind;
	
    switch (kind) {
      case 1:
	if (dgop->dgo_shaded_mode && dgcdp->shaded_mode_override < 0) {
	  dgcdp->dmode = dgop->dgo_shaded_mode;
	} else if (0 <= dgcdp->shaded_mode_override)
	  dgcdp->dmode = dgcdp->shaded_mode_override;
	else
	  dgcdp->dmode = DGO_WIREFRAME;

	break;
      case 2:
      case 3:
	dgcdp->dmode = DGO_BOOL_EVAL;
	break;
    }

  }

  switch (kind) {
    default:
      Tcl_AppendResult(interp, "ERROR, bad kind\n", (char *)NULL);
      bu_free((genptr_t)dgcdp, "dgo_drawtrees: dgcdp");
      return(-1);
    case 1:		/* Wireframes */
      /*
       * If asking for wireframe and in shaded_mode and no shaded mode override,
       * or asking for wireframe and shaded mode is being overridden with a value
       * greater than 0, then draw shaded polygons for each object's primitives if possible.
       *
       * Note -
       * If shaded_mode is DGO_SHADED_MODE_BOTS, only BOTS and polysolids
       * will be shaded. The rest is drawn as wireframe.
       * If shaded_mode is DGO_SHADED_MODE_ALL, everything except pipe solids
       * are drawn as shaded polygons.
       */
      if (DGO_SHADED_MODE_BOTS <= dgcdp->dmode && dgcdp->dmode <= DGO_SHADED_MODE_ALL) {
	int  i;
	int  ac = 1;
	char *av[2];
#if 0
	struct directory *dp;
#endif

	av[1] = (char *)0;

	for (i = 0; i < argc; ++i) {
#if 0
	  if ((dp = db_lookup(dgop->dgo_wdbp->dbip, argv[i], LOOKUP_NOISY)) == DIR_NULL)
	    continue;
#endif

	  av[0] = argv[i];

	  ret = db_walk_tree(dgop->dgo_wdbp->dbip,
			     ac,
			     (const char **)av,
			     ncpu,
			     &dgop->dgo_wdbp->wdb_initial_tree_state,
			     0,
			     dgo_bot_check_region_end,
			     dgo_bot_check_leaf,
			     (genptr_t)dgcdp);
	}
      } else
	ret = db_walk_tree(dgop->dgo_wdbp->dbip,
			   argc,
			   (const char **)argv,
			   ncpu,
			   &dgop->dgo_wdbp->wdb_initial_tree_state,
			   0,			/* take all regions */
			   dgo_wireframe_region_end,
			   dgo_wireframe_leaf,
			   (genptr_t)dgcdp);
      break;
    case 2:		/* Big-E */
      Tcl_AppendResult(interp, "drawtrees:  can't do big-E here\n", (char *)NULL);
      bu_free((genptr_t)dgcdp, "dgo_drawtrees: dgcdp");
      return (-1);
    case 3:
      {
	/* NMG */
	dgo_nmg_model = nmg_mm();
	dgop->dgo_wdbp->wdb_initial_tree_state.ts_m = &dgo_nmg_model;
	if (dgcdp->draw_edge_uses) {
	  Tcl_AppendResult(interp, "Doing the edgeuse thang (-u)\n", (char *)NULL);
	  dgcdp->draw_edge_uses_vbp = rt_vlblock_init();
	}

	ret = db_walk_tree(dgop->dgo_wdbp->dbip, argc, (const char **)argv,
			   ncpu,
			   &dgop->dgo_wdbp->wdb_initial_tree_state,
			   dgo_enable_fastpath ? dgo_nmg_region_start : 0,
			   dgo_nmg_region_end,
			   dgo_nmg_use_tnurbs ? nmg_booltree_leaf_tnurb : nmg_booltree_leaf_tess,
			   (genptr_t)dgcdp);

	if (dgcdp->draw_edge_uses) {
	  dgo_cvt_vlblock_to_solids(dgop, interp, dgcdp->draw_edge_uses_vbp, "_EDGEUSES_", 0);
	  rt_vlblock_free(dgcdp->draw_edge_uses_vbp);
	  dgcdp->draw_edge_uses_vbp = (struct bn_vlblock *)NULL;
	}

	/* Destroy NMG */
	nmg_km(dgo_nmg_model);
	break;
      }
  }
  if (dgcdp->fastpath_count) {
    bu_log("%d region%s rendered through polygon fastpath\n",
	   dgcdp->fastpath_count, dgcdp->fastpath_count==1?"":"s");
  }

  bu_free((genptr_t)dgcdp, "dgo_drawtrees: dgcdp");

  if (ret < 0)
    return (-1);

  return (0);	/* OK */
}


/*
 *			C V T _ V L B L O C K _ T O _ S O L I D S
 */
void
dgo_cvt_vlblock_to_solids(struct dg_obj *dgop, Tcl_Interp *interp, struct bn_vlblock *vbp, char *name, int copy)
{
	int		i;
	char		shortname[32];
	char		namebuf[64];

	strncpy(shortname, name, 16-6);
	shortname[16-6] = '\0';

	for( i=0; i < vbp->nused; i++ )  {
		if (BU_LIST_IS_EMPTY(&(vbp->head[i])))
			continue;

		sprintf(namebuf, "%s%lx",
			shortname, vbp->rgb[i]);
		dgo_invent_solid(dgop, interp, namebuf, &vbp->head[i], vbp->rgb[i], copy);
	}
}

/*
 *			I N V E N T _ S O L I D
 *
 *  Invent a solid by adding a fake entry in the database table,
 *  adding an entry to the solid table, and populating it with
 *  the given vector list.
 *
 *  This parallels much of the code in dodraw.c
 */
int
dgo_invent_solid(struct dg_obj *dgop, Tcl_Interp *interp, char *name, struct bu_list *vhead, long int rgb, int copy)
{
	register struct directory	*dp;
	struct directory		*dpp[2] = {DIR_NULL, DIR_NULL};
	register struct solid		*sp;
	unsigned char			type='0';

	if (dgop->dgo_wdbp->dbip == DBI_NULL)
		return 0;

	if ((dp = db_lookup(dgop->dgo_wdbp->dbip, name, LOOKUP_QUIET)) != DIR_NULL) {
		if (dp->d_addr != RT_DIR_PHONY_ADDR) {
			Tcl_AppendResult(interp, "dgo_invent_solid(", name,
					 ") would clobber existing database entry, ignored\n", (char *)NULL);
			return (-1);
		}

		/*
		 * Name exists from some other overlay,
		 * zap any associated solids
		 */
		dpp[0] = dp;
		dgo_eraseobjall(dgop, interp, dpp);
	}
	/* Need to enter phony name in directory structure */
	dp = db_diradd(dgop->dgo_wdbp->dbip,  name, RT_DIR_PHONY_ADDR, 0, DIR_SOLID, (genptr_t)&type);

	/* Obtain a fresh solid structure, and fill it in */
	GET_SOLID(sp,&FreeSolid.l);

	if (copy) {
		BU_LIST_INIT( &(sp->s_vlist) );
		rt_vlist_copy( &(sp->s_vlist), vhead );
	} else {
		/* For efficiency, just swipe the vlist */
		BU_LIST_APPEND_LIST( &(sp->s_vlist), vhead );
		BU_LIST_INIT(vhead);
	}
	dgo_bound_solid(interp, sp);

	/* set path information -- this is a top level node */
	db_add_node_to_full_path( &sp->s_fullpath, dp );

	sp->s_iflag = DOWN;
	sp->s_soldash = 0;
	sp->s_Eflag = 1;		/* Can't be solid edited! */
	sp->s_color[0] = sp->s_basecolor[0] = (rgb>>16) & 0xFF;
	sp->s_color[1] = sp->s_basecolor[1] = (rgb>> 8) & 0xFF;
	sp->s_color[2] = sp->s_basecolor[2] = (rgb    ) & 0xFF;
	sp->s_regionid = 0;
	sp->s_dlist = BU_LIST_LAST(solid, &dgop->dgo_headSolid)->s_dlist + 1;

	sp->s_uflag = 0;
	sp->s_dflag = 0;
	sp->s_cflag = 0;
	sp->s_wflag = 0;

	/* Solid successfully drawn, add to linked list of solid structs */
	BU_LIST_APPEND(dgop->dgo_headSolid.back, &sp->l);

	return (0);		/* OK */
}

/*
 *  Compute the min, max, and center points of the solid.
 *  Also finds s_vlen;
 * XXX Should split out a separate bn_vlist_rpp() routine, for librt/vlist.c
 */
static void
dgo_bound_solid(Tcl_Interp *interp, register struct solid *sp)
{
	register struct bn_vlist	*vp;
	register double			xmax, ymax, zmax;
	register double			xmin, ymin, zmin;

	xmax = ymax = zmax = -INFINITY;
	xmin = ymin = zmin =  INFINITY;
	sp->s_vlen = 0;
	for (BU_LIST_FOR(vp, bn_vlist, &(sp->s_vlist))) {
		register int	j;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for (j = 0; j < nused; j++,cmd++,pt++) {
			switch (*cmd) {
			case BN_VLIST_POLY_START:
			case BN_VLIST_POLY_VERTNORM:
				/* Has normal vector, not location */
				break;
			case BN_VLIST_LINE_MOVE:
			case BN_VLIST_LINE_DRAW:
			case BN_VLIST_POLY_MOVE:
			case BN_VLIST_POLY_DRAW:
			case BN_VLIST_POLY_END:
				V_MIN(xmin, (*pt)[X]);
				V_MAX(xmax, (*pt)[X]);
				V_MIN(ymin, (*pt)[Y]);
				V_MAX(ymax, (*pt)[Y]);
				V_MIN(zmin, (*pt)[Z]);
				V_MAX(zmax, (*pt)[Z]);
				break;
			default:
				{
					struct bu_vls tmp_vls;

					bu_vls_init(&tmp_vls);
					bu_vls_printf(&tmp_vls, "unknown vlist op %d\n", *cmd);
					Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
					bu_vls_free(&tmp_vls);
				}
			}
		}
		sp->s_vlen += nused;
	}

	sp->s_center[X] = (xmin + xmax) * 0.5;
	sp->s_center[Y] = (ymin + ymax) * 0.5;
	sp->s_center[Z] = (zmin + zmax) * 0.5;

	sp->s_size = xmax - xmin;
	V_MAX( sp->s_size, ymax - ymin );
	V_MAX( sp->s_size, zmax - zmin );
}

/*
 *			D M O _ D R A W h _ P A R T 2
 *
 *  Once the vlist has been created, perform the common tasks
 *  in handling the drawn solid.
 *
 *  This routine must be prepared to run in parallel.
 */
void
dgo_drawH_part2(int dashflag, struct bu_list *vhead, struct db_full_path *pathp, struct db_tree_state *tsp, struct solid *existing_sp, struct dg_client_data *dgcdp)
{
	register struct solid *sp;

	if (!existing_sp) {
		/* Handling a new solid */
		GET_SOLID(sp, &FreeSolid.l);
		/* NOTICE:  The structure is dirty & not initialized for you! */

		sp->s_dlist = BU_LIST_LAST(solid, &dgcdp->dgop->dgo_headSolid)->s_dlist + 1;
	} else {
		/* Just updating an existing solid.
		 *  'tsp' and 'pathpos' will not be used
		 */
		sp = existing_sp;
	}


	/*
	 * Compute the min, max, and center points.
	 */
	BU_LIST_APPEND_LIST(&(sp->s_vlist), vhead);
	dgo_bound_solid(dgcdp->interp, sp);

	/*
	 *  If this solid is new, fill in it's information.
	 *  Otherwise, don't touch what is already there.
	 */
	if (!existing_sp) {
		/* Take note of the base color */
		if (dgcdp->wireframe_color_override) {
		        /* a user specified the color, so arrange to use it */
			sp->s_uflag = 1;
			sp->s_dflag = 0;
			sp->s_basecolor[0] = dgcdp->wireframe_color[0];
			sp->s_basecolor[1] = dgcdp->wireframe_color[1];
			sp->s_basecolor[2] = dgcdp->wireframe_color[2];
		} else {
			sp->s_uflag = 0;
			if (tsp) {
				if (tsp->ts_mater.ma_color_valid) {
					sp->s_dflag = 0;	/* color specified in db */
					sp->s_basecolor[0] = tsp->ts_mater.ma_color[0] * 255.;
					sp->s_basecolor[1] = tsp->ts_mater.ma_color[1] * 255.;
					sp->s_basecolor[2] = tsp->ts_mater.ma_color[2] * 255.;
				} else {
					sp->s_dflag = 1;	/* default color */
					sp->s_basecolor[0] = 255;
					sp->s_basecolor[1] = 0;
					sp->s_basecolor[2] = 0;
				}
			}
		}
		sp->s_cflag = 0;
		sp->s_flag = DOWN;
		sp->s_iflag = DOWN;
		sp->s_soldash = dashflag;
		sp->s_Eflag = 0;	/* This is a solid */
		db_dup_full_path( &sp->s_fullpath, pathp );
		sp->s_regionid = tsp->ts_regionid;
		sp->s_transparency = dgcdp->transparency;
		sp->s_dmode = dgcdp->dmode;

		/* Add to linked list of solid structs */
		bu_semaphore_acquire(RT_SEM_MODEL);
		BU_LIST_APPEND(dgcdp->dgop->dgo_headSolid.back, &sp->l);
		bu_semaphore_release(RT_SEM_MODEL);
	}

#if 0
	/* Solid is successfully drawn */
	if (!existing_sp) {
		/* Add to linked list of solid structs */
		bu_semaphore_acquire(RT_SEM_MODEL);
		BU_LIST_APPEND(dgcdp->dgop->dgo_headSolid.back, &sp->l);
		bu_semaphore_release(RT_SEM_MODEL);
	} else {
		/* replacing existing solid -- struct already linked in */
		sp->s_flag = UP;
	}
#endif
}

/*
 * This looks for a drawable geometry object that has a matching "dbip"
 * and deletes the solids corresponding to "dp" from the solid list.
 * At the moment this is being called from wdb_obj.c/wdb_kill_tcl() if the
 * object is not phony.
 */
void
dgo_eraseobjall_callback(struct db_i *dbip, Tcl_Interp *interp, struct directory *dp)
{
	struct dg_obj		*dgop;
	struct directory	*dpp[2] = {DIR_NULL, DIR_NULL};

	dpp[0] = dp;
	for (BU_LIST_FOR(dgop, dg_obj, &HeadDGObj.l))
		/* drawable geometry objects associated database matches */
		if (dgop->dgo_wdbp->dbip == dbip) {
			dgo_eraseobjall(dgop, interp, dpp);
			dgo_notify(dgop, interp);
		}
}

/*
 * Builds an array of directory pointers from argv and calls
 * either dgo_eraseobj or dgo_eraseobjall.
 */
void
dgo_eraseobjpath(struct dg_obj	*dgop,
		 Tcl_Interp	*interp,
		 int		argc,
		 char		**argv,
		 int		noisy,
		 int		all)
{
	register struct directory *dp;
	register int i;
	struct bu_vls vls;
#if 0
	Tcl_Obj *save_result;

	save_result = Tcl_GetObjResult(interp);
	Tcl_IncrRefCount(save_result);
#endif

		bu_vls_init(&vls);
	for (i = 0; i < argc; i++) {
		int j;
		char *list;
		int ac;
		char **av, **av_orig;
		struct directory **dpp = (struct directory **)0;

#if 0
		bu_vls_trunc(&vls, 0);
		bu_vls_printf(&vls, "split %s /", argv[i]);
		if (Tcl_Eval(interp, bu_vls_addr(&vls)) != TCL_OK) {
			continue;
		}
		list = Tcl_GetStringResult(interp);
#else
		{
			char *begin;
			char *end;
			char *newstr = strdup(argv[i]);

			begin = newstr;
			bu_vls_trunc(&vls, 0);

			while ((end = strchr(begin, '/')) != NULL) {
				*end = '\0';
				bu_vls_printf(&vls, "%s ", begin);
				begin = end + 1;
			}
			bu_vls_printf(&vls, "%s ", begin);
			free((void *)newstr);
		}
		list = bu_vls_addr(&vls);
#endif
		if (Tcl_SplitList(interp, list, &ac, (const char ***)&av_orig) != TCL_OK)
			continue;

		/* make sure we will not dereference null */
		if ( ( ac == 0 ) || (av_orig == 0) || ( *av_orig == 0 ) ) {
			bu_log("WARNING: Asked to look up a null-named database object\n");
			goto end;
		}

		/* skip first element if empty */
		av = av_orig;

		if (*av[0] == '\0') {
			--ac;
			++av;
		}
		
		/* ignore last element if empty */
		if (*av[ac-1] == '\0')
			--ac;
		
		dpp = bu_calloc(ac+1, sizeof(struct directory *), "eraseobjpath: directory pointers");
		for (j = 0; j < ac; ++j)
			if ((dp = db_lookup(dgop->dgo_wdbp->dbip, av[j], noisy)) != DIR_NULL)
				dpp[j] = dp;
			else
				goto end;

		dpp[j] = DIR_NULL;

		if (all)
			dgo_eraseobjall(dgop, interp, dpp);
		else
			dgo_eraseobj(dgop, interp, dpp);

	end:
		bu_free((genptr_t)dpp, "eraseobjpath: directory pointers");
		Tcl_Free((char *)av_orig);
	}
	bu_vls_free(&vls);

#if 0
	Tcl_SetObjResult(interp, save_result);
	Tcl_DecrRefCount(save_result);
#endif
}

/*
 *			E R A S E O B J A L L
 *
 * This routine goes through the solid table and deletes all solids
 * from the solid list which contain the specified object anywhere in their 'path'
 */
static void
dgo_eraseobjall(struct dg_obj			*dgop,
		Tcl_Interp			*interp,
		register struct directory	**dpp)
{
	register struct directory **tmp_dpp;
	register struct solid *sp;
	register struct solid *nsp;
	struct db_full_path	subpath;

	if(dgop->dgo_wdbp->dbip == DBI_NULL)
		return;

	if (*dpp == DIR_NULL)
		return;

	db_full_path_init(&subpath);
	for (tmp_dpp = dpp; *tmp_dpp != DIR_NULL; ++tmp_dpp)  {
		RT_CK_DIR(*tmp_dpp);
		db_add_node_to_full_path(&subpath, *tmp_dpp);
	}

	sp = BU_LIST_NEXT(solid, &dgop->dgo_headSolid);
	while (BU_LIST_NOT_HEAD(sp, &dgop->dgo_headSolid)) {
		nsp = BU_LIST_PNEXT(solid, sp);
		if( db_full_path_subset( &sp->s_fullpath, &subpath ) )  {
			BU_LIST_DEQUEUE(&sp->l);
			FREE_SOLID(sp, &FreeSolid.l);
		}
		sp = nsp;
	}

	if ((*dpp)->d_addr == RT_DIR_PHONY_ADDR) {
		if (db_dirdelete(dgop->dgo_wdbp->dbip, *dpp) < 0) {
			Tcl_AppendResult(interp, "dgo_eraseobjall: db_dirdelete failed\n", (char *)NULL);
		}
	}
	db_free_full_path(&subpath);
}

/*
 *			E R A S E O B J
 *
 * This routine goes through the solid table and deletes all solids
 * from the solid list which contain the specified object at the
 * beginning of their 'path'
 */
static void
dgo_eraseobj(struct dg_obj		*dgop,
	     Tcl_Interp			*interp,
	     register struct directory	**dpp)
{
#if 1
	/*XXX
	 * Temporarily put back the old behavior (as seen in Brlcad5.3),
	 * as the behavior after the #else is identical to dgo_eraseobjall.
	 */
	register struct directory **tmp_dpp;
	register struct solid *sp;
	register struct solid *nsp;
	register int i;

	if(dgop->dgo_wdbp->dbip == DBI_NULL)
		return;

	if (*dpp == DIR_NULL)
		return;

	for (tmp_dpp = dpp; *tmp_dpp != DIR_NULL; ++tmp_dpp)
		RT_CK_DIR(*tmp_dpp);

	sp = BU_LIST_FIRST(solid, &dgop->dgo_headSolid);
	while (BU_LIST_NOT_HEAD(sp, &dgop->dgo_headSolid)) {
		nsp = BU_LIST_PNEXT(solid, sp);
		for (i = 0, tmp_dpp = dpp;
		     i <= sp->s_fullpath.fp_len && *tmp_dpp != DIR_NULL;
		     ++i, ++tmp_dpp)
			if (sp->s_fullpath.fp_names[i] != *tmp_dpp)
				goto end;

		if (*tmp_dpp != DIR_NULL)
			goto end;

		BU_LIST_DEQUEUE(&sp->l);
		FREE_SOLID(sp, &FreeSolid.l);
	end:
		sp = nsp;
	}

	if ((*dpp)->d_addr == RT_DIR_PHONY_ADDR ) {
		if (db_dirdelete(dgop->dgo_wdbp->dbip, *dpp) < 0) {
			Tcl_AppendResult(interp, "dgo_eraseobj: db_dirdelete failed\n", (char *)NULL);
		}
	}
#else
	register struct directory **tmp_dpp;
	register struct solid *sp;
	register struct solid *nsp;
	struct db_full_path	subpath;

	if(dgop->dgo_wdbp->dbip == DBI_NULL)
		return;

	if (*dpp == DIR_NULL)
		return;

	db_full_path_init(&subpath);
	for (tmp_dpp = dpp; *tmp_dpp != DIR_NULL; ++tmp_dpp)  {
		RT_CK_DIR(*tmp_dpp);
		db_add_node_to_full_path(&subpath, *tmp_dpp);
	}

	sp = BU_LIST_FIRST(solid, &dgop->dgo_headSolid);
	while (BU_LIST_NOT_HEAD(sp, &dgop->dgo_headSolid)) {
		nsp = BU_LIST_PNEXT(solid, sp);
		if( db_full_path_subset( &sp->s_fullpath, &subpath ) )  {
			BU_LIST_DEQUEUE(&sp->l);
			FREE_SOLID(sp, &FreeSolid.l);
		}
		sp = nsp;
	}

	if ((*dpp)->d_addr == RT_DIR_PHONY_ADDR ) {
		if (db_dirdelete(dgop->dgo_wdbp->dbip, *dpp) < 0) {
			Tcl_AppendResult(interp, "dgo_eraseobj: db_dirdelete failed\n", (char *)NULL);
		}
	}
	db_free_full_path(&subpath);
#endif
}

/*
 *  			C O L O R _ S O L T A B
 *
 *  Pass through the solid table and set pointer to appropriate
 *  mater structure.
 */
void
dgo_color_soltab(struct solid *hsp)
{
	register struct solid *sp;
	register struct mater *mp;

	FOR_ALL_SOLIDS(sp, &hsp->l) {
		sp->s_cflag = 0;

	        /* the user specified the color, so use it */
		if (sp->s_uflag) {
			sp->s_color[0] = sp->s_basecolor[0];
			sp->s_color[1] = sp->s_basecolor[1];
			sp->s_color[2] = sp->s_basecolor[2];
			continue;
		}

		for (mp = rt_material_head; mp != MATER_NULL; mp = mp->mt_forw) {
			if (sp->s_regionid <= mp->mt_high &&
			    sp->s_regionid >= mp->mt_low) {
			    	sp->s_color[0] = mp->mt_r;
			    	sp->s_color[1] = mp->mt_g;
			    	sp->s_color[2] = mp->mt_b;
				goto done;
			}
		}

		/*
		 *  There is no region-id-based coloring entry in the
		 *  table, so use the combination-record ("mater"
		 *  command) based color if one was provided. Otherwise,
		 *  use the default wireframe color.
		 *  This is the "new way" of coloring things.
		 */

		/* use wireframe_default_color */
		if (sp->s_dflag)
		  sp->s_cflag = 1;
		/* Be conservative and copy color anyway, to avoid black */
		sp->s_color[0] = sp->s_basecolor[0];
		sp->s_color[1] = sp->s_basecolor[1];
		sp->s_color[2] = sp->s_basecolor[2];
done: ;
	}
}

/*
 *                    D G O _ B U I L D _ T O P S
 *
 *  Build a command line vector of the tops of all objects in view.
 */
int
dgo_build_tops(Tcl_Interp	*interp,
	       struct solid	*hsp,
	       char		**start,
	       register char	**end)
{
	register char **vp = start;
	register struct solid *sp;

	/*
	 * Find all unique top-level entries.
	 *  Mark ones already done with s_flag == UP
	 */
	FOR_ALL_SOLIDS(sp, &hsp->l)
		sp->s_flag = DOWN;
	FOR_ALL_SOLIDS(sp, &hsp->l)  {
		register struct solid *forw;
		struct directory *dp = FIRST_SOLID(sp);

		if (sp->s_flag == UP)
			continue;
		if (dp->d_addr == RT_DIR_PHONY_ADDR)
			continue;	/* Ignore overlays, predictor, etc */
		if (vp < end)
			*vp++ = dp->d_namep;
		else  {
		  Tcl_AppendResult(interp, "mged: ran out of comand vector space at ",
				   dp->d_namep, "\n", (char *)NULL);
		  break;
		}
		sp->s_flag = UP;
		for (BU_LIST_PFOR(forw, sp, solid, &hsp->l)) {
			if (FIRST_SOLID(forw) == dp)
				forw->s_flag = UP;
		}
	}
	*vp = (char *) 0;
	return vp-start;
}


/*
 *  			D G O _ R T _ W R I T E
 *  
 *  Write out the information that RT's -M option needs to show current view.
 *  Note that the model-space location of the eye is a parameter,
 *  as it can be computed in different ways.
 */
static void
dgo_rt_write(struct dg_obj	*dgop,
	     struct view_obj	*vop,
	     FILE		*fp,
	     vect_t		eye_model)
{
	register int	i;
	quat_t		quat;
	register struct solid *sp;

	(void)fprintf(fp, "viewsize %.15e;\n", vop->vo_size);
	quat_mat2quat(quat, vop->vo_rotation );
	(void)fprintf(fp, "orientation %.15e %.15e %.15e %.15e;\n", V4ARGS(quat));
	(void)fprintf(fp, "eye_pt %.15e %.15e %.15e;\n",
		      eye_model[X], eye_model[Y], eye_model[Z] );

	(void)fprintf(fp, "start 0; clean;\n");
	FOR_ALL_SOLIDS (sp, &dgop->dgo_headSolid) {
		for (i=0;i<sp->s_fullpath.fp_len;i++) {
			DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_flags &= ~DIR_USED;
		}
	}
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		for (i=0; i<sp->s_fullpath.fp_len; i++ ) {
			if (!(DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_flags & DIR_USED)) {
				register struct animate *anp;
				for (anp = DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_animate; anp;
				    anp=anp->an_forw) {
					db_write_anim(fp, anp);
				}
				DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_flags |= DIR_USED;
			}
		}
	}

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		for (i=0;i< sp->s_fullpath.fp_len;i++) {
			DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_flags &= ~DIR_USED;
		}
	}
	(void)fprintf(fp, "end;\n");
}

#ifndef WIN32
static void
dgo_rt_output_handler(ClientData	clientData,
		      int		mask)
{
	struct run_rt *run_rtp = (struct run_rt *)clientData;
	int count;
	char line[RT_MAXLINE+1];

	/* Get data from rt */
	if ((count = read((int)run_rtp->fd, line, RT_MAXLINE)) == 0) {
		int retcode;
		int rpid;
		int aborted;

		Tcl_DeleteFileHandler(run_rtp->fd);
		close(run_rtp->fd);

		/* wait for the forked process */
		while ((rpid = wait(&retcode)) != run_rtp->pid && rpid != -1);

		aborted = run_rtp->aborted;

		/* free run_rtp */
 		BU_LIST_DEQUEUE(&run_rtp->l);
		bu_free((genptr_t)run_rtp, "dgo_rt_output_handler: run_rtp");

		if (aborted)
			bu_log("Raytrace aborted.\n");
		else
			bu_log("Raytrace complete.\n");
		return;
	}

	line[count] = '\0';

	/*XXX For now just blather to stderr */
	bu_log("%s", line);
}

#else
static void
dgo_rt_output_handler(ClientData	clientData,
		      int		mask)
{
	struct run_rt *run_rtp = (struct run_rt *)clientData;
	int count;
	char line[10240+1];

	/* Get data from rt */
	if (Tcl_Eof(run_rtp->chan) || (!ReadFile(run_rtp->fd, line, 10240,&count,0))) {
		int aborted;

		Tcl_DeleteChannelHandler(run_rtp->chan,dgo_rt_output_handler,(ClientData)run_rtp);
		CloseHandle(run_rtp->fd);

		/* wait for the forked process 
		 * either EOF has been sent or there was a read error.
		 * there is no need to block indefinately
		 */
		WaitForSingleObject( run_rtp->hProcess, 120 );
		/* !!! need to observer implications of being non-infinate
		 *	WaitForSingleObject( run_rtp->hProcess, INFINITE ); 
		 */
		
		if(GetLastError() == ERROR_PROCESS_ABORTED)
		{
			run_rtp->aborted = 1; 
		}

		aborted = run_rtp->aborted;

		/* free run_rtp */
 		BU_LIST_DEQUEUE(&run_rtp->l);
		bu_free((genptr_t)run_rtp, "dgo_rt_output_handler: run_rtp");

		if (aborted)
			bu_log("Raytrace aborted.\n");
		else
			bu_log("Raytrace complete.\n");
		return;
	}

	line[count] = '\0';

	/*XXX For now just blather to stderr */
	bu_log("%s", line);
}

#endif

static void
dgo_rt_set_eye_model(struct dg_obj *dgop,
		     struct view_obj *vop,
		     vect_t eye_model)
{
	if (vop->vo_zclip || vop->vo_perspective > 0) {
		vect_t temp;

		VSET(temp, 0.0, 0.0, 1.0);
		MAT4X3PNT(eye_model, vop->vo_view2model, temp);
	} else {
		/* not doing zclipping, so back out of geometry */
		register struct solid *sp;
		register int i;
		double  t;
		double  t_in;
		vect_t  direction;
		vect_t  extremum[2];
		vect_t  minus, plus;    /* vers of this solid's bounding box */

		VSET(eye_model, -vop->vo_center[MDX],
		     -vop->vo_center[MDY], -vop->vo_center[MDZ]);

		for (i = 0; i < 3; ++i) {
			extremum[0][i] = INFINITY;
			extremum[1][i] = -INFINITY;
		}

		FOR_ALL_SOLIDS (sp, &dgop->dgo_headSolid) {
			minus[X] = sp->s_center[X] - sp->s_size;
			minus[Y] = sp->s_center[Y] - sp->s_size;
			minus[Z] = sp->s_center[Z] - sp->s_size;
			VMIN( extremum[0], minus );
			plus[X] = sp->s_center[X] + sp->s_size;
			plus[Y] = sp->s_center[Y] + sp->s_size;
			plus[Z] = sp->s_center[Z] + sp->s_size;
			VMAX( extremum[1], plus );
		}
		VMOVEN(direction, vop->vo_rotation + 8, 3);
		VSCALE(direction, direction, -1.0);
		for (i = 0; i < 3; ++i)
			if (NEAR_ZERO(direction[i], 1e-10))
				direction[i] = 0.0;
		if ((eye_model[X] >= extremum[0][X]) &&
		    (eye_model[X] <= extremum[1][X]) &&
		    (eye_model[Y] >= extremum[0][Y]) &&
		    (eye_model[Y] <= extremum[1][Y]) &&
		    (eye_model[Z] >= extremum[0][Z]) &&
		    (eye_model[Z] <= extremum[1][Z])) {
			t_in = -INFINITY;
			for (i = 0; i < 6; ++i) {
				if (direction[i%3] == 0)
					continue;
				t = (extremum[i/3][i%3] - eye_model[i%3]) /
					direction[i%3];
				if ((t < 0) && (t > t_in))
					t_in = t;
			}
			VJOIN1(eye_model, eye_model, t_in, direction);
		}
	}
}

/*
 *                  D G O _ R U N _ R T
 */
static int
dgo_run_rt(struct dg_obj *dgop,
	   struct view_obj *vop) 
{
	register int	i;
	FILE		*fp_in;
#ifndef WIN32
	int		pipe_in[2];
	int		pipe_err[2];
#else
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    SECURITY_ATTRIBUTES sa          = {0};
    char line[2048];
    char name[256];
#endif
	vect_t		eye_model;
	int		pid; 	 
	struct run_rt	*run_rtp;

#ifndef WIN32
	(void)pipe(pipe_in);
	(void)pipe(pipe_err);

	if ((pid = fork()) == 0) {
		/* make this a process group leader */
		setpgid(0, 0);

		/* Redirect stdin and stderr */
		(void)close(0);
		(void)dup(pipe_in[0]);
		(void)close(2);
		(void)dup(pipe_err[1]);

		/* close pipes */
		(void)close(pipe_in[0]);
		(void)close(pipe_in[1]);
		(void)close(pipe_err[0]);
		(void)close(pipe_err[1]);

		for (i=3; i < 20; i++)
			(void)close(i);

		(void)execvp(dgop->dgo_rt_cmd[0], dgop->dgo_rt_cmd);
		perror(dgop->dgo_rt_cmd[0]);
		exit(16);
	}

	/* As parent, send view information down pipe */
	(void)close(pipe_in[0]);
	fp_in = fdopen(pipe_in[1], "w");

	(void)close(pipe_err[1]);

	dgo_rt_set_eye_model(dgop, vop, eye_model);
	dgo_rt_write(dgop, vop, fp_in, eye_model);
	(void)fclose(fp_in);

	BU_GETSTRUCT(run_rtp, run_rt);
	BU_LIST_APPEND(&dgop->dgo_headRunRt.l, &run_rtp->l);
	run_rtp->fd = pipe_err[0];
	run_rtp->pid = pid;

	Tcl_CreateFileHandler(run_rtp->fd, TCL_READABLE,
			      dgo_rt_output_handler, (ClientData)run_rtp);

	return 0;

#else
	sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_err[1];
   si.hStdError   = pipe_err[1];

   sprintf(line,"%s ",dgop->dgo_rt_cmd[0]);
   for(i=1;i<dgop->dgo_rt_cmd_len;i++) {
	   sprintf(name,"%s ",dgop->dgo_rt_cmd[i]);
	   strcat(line,name); }
	   

   if(CreateProcess( NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStderr);
}


   	/* As parent, send view information down pipe */
	CloseHandle(pipe_in[0]);
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	CloseHandle(pipe_err[1]);

	dgo_rt_set_eye_model(dgop, vop, eye_model);
	dgo_rt_write(dgop, vop, fp_in, eye_model);
	(void)fclose(fp_in);

	BU_GETSTRUCT(run_rtp, run_rt);
	BU_LIST_APPEND(&dgop->dgo_headRunRt.l, &run_rtp->l);

	run_rtp->fd = pipe_errDup;
	run_rtp->hProcess = pi.hProcess;
	run_rtp->pid = pi.dwProcessId;
	run_rtp->aborted=0;

	run_rtp->chan = Tcl_MakeFileChannel(run_rtp->fd,TCL_READABLE);
	Tcl_CreateChannelHandler(run_rtp->chan,TCL_READABLE,
			      dgo_rt_output_handler, (ClientData)run_rtp);

	return 0;

#endif

}

void
dgo_notify(struct dg_obj	*dgop,
	   Tcl_Interp		*interp)
{
	bu_observer_notify(interp, &dgop->dgo_observers, bu_vls_addr(&dgop->dgo_name));
}

void
dgo_impending_wdb_close(struct rt_wdb	*wdbp,
			Tcl_Interp	*interp)
{
	struct dg_obj *dgop;

	for (BU_LIST_FOR(dgop, dg_obj, &HeadDGObj.l))
		if (dgop->dgo_wdbp == wdbp) {
			dgo_zap_cmd(dgop, interp);
			dgop->dgo_wdbp = RT_WDB_NULL;
			dgo_notify(dgop, interp);
		}
}

void
dgo_zapall(struct rt_wdb *wdbp, Tcl_Interp *interp)
{
	struct dg_obj *dgop;

	for (BU_LIST_FOR(dgop, dg_obj, &HeadDGObj.l))
		if (dgop->dgo_wdbp == wdbp) {
			dgo_zap_cmd(dgop, interp);
			dgo_notify(dgop, interp);
		}
}

/*
 *			D G O _ P R _ S C H A I N
 *
 *  Given a pointer to a member of the circularly linked list of solids
 *  (typically the head), chase the list and print out the information
 *  about each solid structure.
 */
static void
dgo_print_schain(struct dg_obj *dgop, Tcl_Interp *interp, int lvl)
                  	      
               		        
        		    			/* debug level */
{
	register struct solid		*sp;
	register struct bn_vlist	*vp;
	int				nvlist;
	int				npts;
	struct bu_vls 		vls;

	if (dgop->dgo_wdbp->dbip == DBI_NULL)
		return;

	bu_vls_init(&vls);

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		if (lvl <= -2) {
			/* print only leaves */
			bu_vls_printf(&vls, "%s ", LAST_SOLID(sp)->d_namep);
			continue;
		}

		db_path_to_vls(&vls, &sp->s_fullpath);

		if ((lvl != -1) && (sp->s_iflag == UP))
			bu_vls_printf(&vls, " ILLUM");

		bu_vls_printf(&vls, "\n");

		if (lvl <= 0)
			continue;

		/* convert to the local unit for printing */
		bu_vls_printf(&vls, "  cent=(%.3f,%.3f,%.3f) sz=%g ",
			      sp->s_center[X]*dgop->dgo_wdbp->dbip->dbi_base2local,
			      sp->s_center[Y]*dgop->dgo_wdbp->dbip->dbi_base2local,
			      sp->s_center[Z]*dgop->dgo_wdbp->dbip->dbi_base2local,
			      sp->s_size*dgop->dgo_wdbp->dbip->dbi_base2local);
		bu_vls_printf(&vls, "reg=%d\n",sp->s_regionid);
		bu_vls_printf(&vls, "  basecolor=(%d,%d,%d) color=(%d,%d,%d)%s%s%s\n",
			      sp->s_basecolor[0],
			      sp->s_basecolor[1],
			      sp->s_basecolor[2],
			      sp->s_color[0],
			      sp->s_color[1],
			      sp->s_color[2],
			      sp->s_uflag?" U":"",
			      sp->s_dflag?" D":"",
			      sp->s_cflag?" C":"");

		if (lvl <= 1)
			continue;

		/* Print the actual vector list */
		nvlist = 0;
		npts = 0;
		for (BU_LIST_FOR(vp, bn_vlist, &(sp->s_vlist))) {
			register int	i;
			register int	nused = vp->nused;
			register int	*cmd = vp->cmd;
			register point_t *pt = vp->pt;

			BN_CK_VLIST(vp);
			nvlist++;
			npts += nused;

			if (lvl <= 2)
				continue;

			for (i = 0; i < nused; i++,cmd++,pt++) {
				bu_vls_printf(&vls, "  %s (%g, %g, %g)\n",
					      rt_vlist_cmd_descriptions[*cmd],
					      V3ARGS(*pt));
			}
		}

		bu_vls_printf(&vls, "  %d vlist structures, %d pts\n", nvlist, npts);
		bu_vls_printf(&vls, "  %d pts (via rt_ck_vlist)\n", rt_ck_vlist(&(sp->s_vlist)));
	}

	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
}

/*
 *			D G O _ P R _ S C H A I N _ V L C M D S
 *
 *  Given a pointer to a member of the circularly linked list of solids
 *  (typically the head), chase the list and print out the vlist cmds
 *  for each structure.
 */
static void
dgo_print_schain_vlcmds(struct dg_obj *dgop, Tcl_Interp *interp)
{
	register struct solid		*sp;
	register struct bn_vlist	*vp;
	struct bu_vls 		vls;

	if (dgop->dgo_wdbp->dbip == DBI_NULL)
		return;

	bu_vls_init(&vls);

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		bu_vls_printf(&vls, "-1 %d %d %d\n",
			      sp->s_color[0],
			      sp->s_color[1],
			      sp->s_color[2]);

		/* Print the actual vector list */
		for (BU_LIST_FOR(vp, bn_vlist, &(sp->s_vlist))) {
			register int	i;
			register int	nused = vp->nused;
			register int	*cmd = vp->cmd;
			register point_t *pt = vp->pt;

			BN_CK_VLIST(vp);

			for (i = 0; i < nused; i++, cmd++, pt++)
				bu_vls_printf(&vls, "%d %g %g %g\n", *cmd, V3ARGS(*pt));
		}
	}

	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
}

/*
 *			P R _ W A I T _ S T A T U S
 *
 *  Interpret the status return of a wait() system call,
 *  for the edification of the watching luser.
 *  Warning:  This may be somewhat system specific, most especially
 *  on non-UNIX machines.
 */
void
dgo_pr_wait_status(Tcl_Interp	*interp,
		   int		status)
{
	int	sig = status & 0x7f;
	int	core = status & 0x80;
	int	ret = status >> 8;
	struct bu_vls tmp_vls;

	if (status == 0) {
		Tcl_AppendResult(interp, "Normal exit\n", (char *)NULL);
		return;
	}

	bu_vls_init(&tmp_vls);
	bu_vls_printf(&tmp_vls, "Abnormal exit x%x", status);

	if (core)
		bu_vls_printf(&tmp_vls, ", core dumped");

	if (sig)
		bu_vls_printf(&tmp_vls, ", terminating signal = %d", sig);
	else
		bu_vls_printf(&tmp_vls, ", return (exit) code = %d", ret);

	Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), "\n", (char *)NULL);
	bu_vls_free(&tmp_vls);
}

static union tree *
dgo_bot_check_region_end(register struct db_tree_state	*tsp,
			 struct db_full_path		*pathp,
			 union tree			*curtree,
			 genptr_t			client_data)
{
  return curtree;
}

static union tree *
dgo_bot_check_leaf(struct db_tree_state		*tsp,
		   struct db_full_path		*pathp,
		   struct rt_db_internal	*ip,
		   genptr_t			client_data)
{
  union tree *curtree;
  int  ac = 1;
  char *av[2];
  struct dg_client_data *dgcdp = (struct dg_client_data *)client_data;

  av[0] = db_path_to_string(pathp);
  av[1] = (char *)0;

  /* Indicate success by returning something other than TREE_NULL */
  RT_GET_TREE(curtree, tsp->ts_resp);
  curtree->magic = RT_TREE_MAGIC;
  curtree->tr_op = OP_NOP;

  /*
   * Use dgop->dgo_shaded_mode if set and not being overridden. Otherwise use dgcdp->shaded_mode_override.
   */
#if 1
  switch (dgcdp->dmode) {
#else
  switch (dgcdp->dgop->dgo_shaded_mode && dgcdp->shaded_mode_override < 0
	  ? dgcdp->dgop->dgo_shaded_mode : dgcdp->shaded_mode_override) {
#endif
  case DGO_SHADED_MODE_BOTS:
    if (ip->idb_major_type == DB5_MAJORTYPE_BRLCAD &&
	(ip->idb_minor_type == DB5_MINORTYPE_BRLCAD_BOT ||
	 ip->idb_minor_type == DB5_MINORTYPE_BRLCAD_POLY))
      dgo_drawtrees(dgcdp->dgop, dgcdp->interp, ac, av, 3, client_data);
    else {
      /* save shaded mode states */
      int save_dgo_shaded_mode = dgcdp->dgop->dgo_shaded_mode;
      int save_shaded_mode_override = dgcdp->shaded_mode_override;
      int save_dmode = dgcdp->dmode;

      /* turn shaded mode off for this non-bot/non-poly object */
      dgcdp->dgop->dgo_shaded_mode = 0;
      dgcdp->shaded_mode_override = -1;
      dgcdp->dmode = DGO_WIREFRAME;

      dgo_drawtrees(dgcdp->dgop, dgcdp->interp, ac, av, 1, client_data);

      /* restore shaded mode states */
      dgcdp->dgop->dgo_shaded_mode = save_dgo_shaded_mode;
      dgcdp->shaded_mode_override = save_shaded_mode_override;
      dgcdp->dmode = save_dmode;
    }

    break;
  case DGO_SHADED_MODE_ALL:
    if (ip->idb_major_type == DB5_MAJORTYPE_BRLCAD &&
	ip->idb_minor_type != DB5_MINORTYPE_BRLCAD_PIPE)
	 dgo_drawtrees(dgcdp->dgop, dgcdp->interp, ac, av, 3, client_data);
    else {
      /* save shaded mode states */
      int save_dgo_shaded_mode = dgcdp->dgop->dgo_shaded_mode;
      int save_shaded_mode_override = dgcdp->shaded_mode_override;
      int save_dmode = dgcdp->dmode;

      /* turn shaded mode off for this pipe object */
      dgcdp->dgop->dgo_shaded_mode = 0;
      dgcdp->shaded_mode_override = -1;
      dgcdp->dmode = DGO_WIREFRAME;

      dgo_drawtrees(dgcdp->dgop, dgcdp->interp, ac, av, 1, client_data);

      /* restore shaded mode states */
      dgcdp->dgop->dgo_shaded_mode = save_dgo_shaded_mode;
      dgcdp->shaded_mode_override = save_shaded_mode_override;
      dgcdp->dmode = save_dmode;
    }

    break;
  }

  bu_free((genptr_t)av[0], "dgo_bot_check_leaf: av[0]");

  return curtree;
}
@


1.77
log
@change conf.h to a wrapped config.h
@
text
@@


1.76
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d30 5
a34 1
#include "conf.h"
d45 5
a49 1
#include "conf.h"
@


1.75
log
@make the USE_SURVICE_MODS not compile-time-optional.  so that means the #if sections go bye bye.
@
text
@d70 3
d75 1
d78 1
a81 5
struct dgo_bot_check_data {
  struct dg_obj *dgop;
  Tcl_Interp *interp;
};

d83 2
d123 1
d157 1
d161 1
a161 1
static int dgo_drawtrees(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv, int kind);
d184 1
d201 1
d213 1
d219 1
d251 1
a251 2
	(void)Tcl_CreateCommand(interp, "dg_open", dgo_open_tcl,
				(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
d608 1
a608 40
	/*
	 * If asking for wireframe and in shaded_mode,
	 * draw shaded polygons for each object's primitives if possible.
	 *
	 * Note -
	 * If shaded_mode is DGO_SHADED_MODE_BOTS, only BOTS and polysolids
	 * will be shaded. The rest is drawn as wireframe.
	 * If shaded_mode is DGO_SHADED_MODE_ALL, everything except pipe solids
	 * are drawn as shaded polygons.
	 */
	if (kind == 1 && dgop->dgo_shaded_mode) {
	  int  i;
	  int  ac = 1;
	  char *av[2];
	  struct directory *dp;
	  struct dgo_bot_check_data bcd;

	  bcd.dgop = dgop;
	  bcd.interp = interp;
	  av[1] = (char *)0;

	  for (i = 0; i < argc; ++i) {
	    if ((dp = db_lookup(dgop->dgo_wdbp->dbip, argv[i], LOOKUP_NOISY)) == DIR_NULL)
	      continue;

	    av[0] = argv[i];

	    db_walk_tree(dgop->dgo_wdbp->dbip,
			 ac,
			 (const char **)av,
			 1,
			 &dgop->dgo_wdbp->wdb_initial_tree_state,
			 0,
			 dgo_bot_check_region_end,
			 dgo_bot_check_leaf,
			 (genptr_t)&bcd);
	  }
	} else {
	  dgo_drawtrees(dgop, interp, argc, argv, kind);
	}
d610 1
a610 1
	dgo_color_soltab(&dgop->dgo_headSolid);
d742 148
d926 1
a926 1
			Tcl_AppendResult(interp,"dgo_who: argument not understood\n", (char *)NULL);
d1219 3
d1370 1
a1370 1
						       &dgop->dgo_headSolid,
d1985 1
a1985 1
						       &dgop->dgo_headSolid,
d2082 1
a2082 1
						       &dgop->dgo_headSolid,
d2493 112
d2646 1
a2646 1
 *        procname 
d3017 1
a3017 1
dgo_drawtrees(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv, int kind)
d3019 126
a3144 102
	int		ret = 0;
	register int	c;
	int		ncpu = 1;
	int		dgo_nmg_use_tnurbs = 0;
	int		dgo_enable_fastpath = 0;
	struct model	*dgo_nmg_model;
	struct dg_client_data *dgcdp;

	RT_CHECK_DBI(dgop->dgo_wdbp->dbip);

	if (argc <= 0)
		return(-1);	/* FAIL */

	BU_GETSTRUCT(dgcdp, dg_client_data);
	dgcdp->dgop = dgop;
	dgcdp->interp = interp;

	/* Initial values for options, must be reset each time */
	dgcdp->draw_nmg_only = 0;	/* no booleans */
	dgcdp->nmg_triangulate = 1;
	dgcdp->draw_wireframes = 0;
	dgcdp->draw_normals = 0;
	dgcdp->draw_solid_lines_only = 0;
	dgcdp->draw_no_surfaces = 0;
	dgcdp->shade_per_vertex_normals = 0;
	dgcdp->draw_edge_uses = 0;
	dgcdp->wireframe_color_override = 0;
	dgcdp->fastpath_count = 0;

	/* default color - red */
	dgcdp->wireframe_color[0] = 255;
	dgcdp->wireframe_color[1] = 0;
	dgcdp->wireframe_color[2] = 0;

	dgo_enable_fastpath = 0;

	/* Parse options. */
	bu_optind = 0;		/* re-init bu_getopt() */
	while ((c = bu_getopt(argc,argv,"dfnqstuvwSTP:C:")) != EOF) {
		switch (c) {
		case 'u':
			dgcdp->draw_edge_uses = 1;
			break;
		case 's':
			dgcdp->draw_solid_lines_only = 1;
			break;
		case 't':
			dgo_nmg_use_tnurbs = 1;
			break;
		case 'v':
			dgcdp->shade_per_vertex_normals = 1;
			break;
		case 'w':
			dgcdp->draw_wireframes = 1;
			break;
		case 'S':
			dgcdp->draw_no_surfaces = 1;
			break;
		case 'T':
			dgcdp->nmg_triangulate = 0;
			break;
		case 'n':
			dgcdp->draw_normals = 1;
			break;
		case 'P':
			ncpu = atoi(bu_optarg);
			break;
		case 'q':
			dgcdp->do_not_draw_nmg_solids_during_debugging = 1;
			break;
		case 'd':
			dgcdp->draw_nmg_only = 1;
			break;
		case 'f':
			dgo_enable_fastpath = 1;
			break;
		case 'C':
			{
				int		r,g,b;
				register char	*cp = bu_optarg;

				r = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				g = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				b = atoi(cp);

				if( r < 0 || r > 255 )  r = 255;
				if( g < 0 || g > 255 )  g = 255;
				if( b < 0 || b > 255 )  b = 255;

				dgcdp->wireframe_color_override = 1;
				dgcdp->wireframe_color[0] = r;
				dgcdp->wireframe_color[1] = g;
				dgcdp->wireframe_color[2] = b;
			}
			break;
		default:
			{
				struct bu_vls vls;
d3146 4
a3149 5
				bu_vls_init(&vls);
 				bu_vls_printf(&vls, "helplib %s", argv[0]);
				Tcl_Eval(interp, bu_vls_addr(&vls));
				bu_vls_free(&vls);
				bu_free((genptr_t)dgcdp, "dgo_drawtrees: dgcdp");
d3151 5
a3155 6
				return TCL_ERROR;
			}
		}
	}
	argc -= bu_optind;
	argv += bu_optind;
d3157 1
a3157 45
	switch (kind) {
	default:
	  Tcl_AppendResult(interp, "ERROR, bad kind\n", (char *)NULL);
	  bu_free((genptr_t)dgcdp, "dgo_drawtrees: dgcdp");
	  return(-1);
	case 1:		/* Wireframes */
		ret = db_walk_tree(dgop->dgo_wdbp->dbip, argc, (const char **)argv,
			ncpu,
			&dgop->dgo_wdbp->wdb_initial_tree_state,
			0,			/* take all regions */
			dgo_wireframe_region_end,
			dgo_wireframe_leaf, (genptr_t)dgcdp);
		break;
	case 2:		/* Big-E */
		Tcl_AppendResult(interp, "drawtrees:  can't do big-E here\n", (char *)NULL);
		bu_free((genptr_t)dgcdp, "dgo_drawtrees: dgcdp");
		return (-1);
	case 3:
		{
		/* NMG */
	  	dgo_nmg_model = nmg_mm();
		dgop->dgo_wdbp->wdb_initial_tree_state.ts_m = &dgo_nmg_model;
	  	if (dgcdp->draw_edge_uses) {
			Tcl_AppendResult(interp, "Doing the edgeuse thang (-u)\n", (char *)NULL);
			dgcdp->draw_edge_uses_vbp = rt_vlblock_init();
	  	}

		ret = db_walk_tree(dgop->dgo_wdbp->dbip, argc, (const char **)argv,
				   ncpu,
				   &dgop->dgo_wdbp->wdb_initial_tree_state,
				   dgo_enable_fastpath ? dgo_nmg_region_start : 0,
				   dgo_nmg_region_end,
				   dgo_nmg_use_tnurbs ? nmg_booltree_leaf_tnurb : nmg_booltree_leaf_tess,
				   (genptr_t)dgcdp);

	  	if (dgcdp->draw_edge_uses) {
	  		dgo_cvt_vlblock_to_solids(dgop->dgo_wdbp->dbip, interp,
						  dgcdp->draw_edge_uses_vbp, "_EDGEUSES_", 0);
	  		rt_vlblock_free(dgcdp->draw_edge_uses_vbp);
			dgcdp->draw_edge_uses_vbp = (struct bn_vlblock *)NULL;
 	  	}

		/* Destroy NMG */
		nmg_km(dgo_nmg_model);
	  	break;
d3159 116
a3274 5
	}
	if (dgcdp->fastpath_count) {
		bu_log("%d region%s rendered through polygon fastpath\n",
		       dgcdp->fastpath_count, dgcdp->fastpath_count==1?"":"s");
	}
d3276 1
a3276 1
	bu_free((genptr_t)dgcdp, "dgo_drawtrees: dgcdp");
d3278 2
a3279 2
	if (ret < 0)
		return (-1);
d3281 1
a3281 1
	return (0);	/* OK */
d3511 2
d4497 1
a4497 1
  struct dgo_bot_check_data *bcdp = (struct dgo_bot_check_data *)client_data;
d4507 9
a4515 1
  switch (bcdp->dgop->dgo_shaded_mode) {
d4520 19
a4538 3
      dgo_drawtrees(bcdp->dgop, bcdp->interp, ac, av, 3);
    else
      dgo_drawtrees(bcdp->dgop, bcdp->interp, ac, av, 1);
d4544 19
a4562 3
	 dgo_drawtrees(bcdp->dgop, bcdp->interp, ac, av, 3);
    else
      dgo_drawtrees(bcdp->dgop, bcdp->interp, ac, av, 1);
d4566 2
@


1.74
log
@merge of ansi-6-0-branch into HEAD
@
text
@a71 1
#if USE_SURVICE_MODS
a83 1
#endif
a206 1
#if USE_SURVICE_MODS
a207 1
#endif
a600 1
#if USE_SURVICE_MODS
d638 1
a638 1
	} else
d640 2
a641 3
#else
	dgo_drawtrees(dgop, interp, argc, argv, kind);
#endif
a2373 1
#if USE_SURVICE_MODS
a2426 1
#endif
a4156 1
#if USE_SURVICE_MODS
a4206 1
#endif
@


1.73
log
@merge of windows-6-0-branch into head
@
text
@d54 18
d117 3
a119 3
extern int	dgo_qray_cmd();
extern void	dgo_init_qray();
extern void	dgo_free_qray();
d122 1
a122 1
extern int	dgo_nirt_cmd();
d124 1
a124 1
static int dgo_open_tcl();
d128 18
a145 18
static int dgo_cmd();
static int dgo_headSolid_tcl();
static int dgo_illum_tcl();
static int dgo_label_tcl();
static int dgo_draw_tcl();
static int dgo_ev_tcl();
static int dgo_erase_tcl();
static int dgo_erase_all_tcl();
static int dgo_who_tcl();
static int dgo_rt_tcl();
static int dgo_rtabort_tcl();
static int dgo_vdraw_tcl();
static int dgo_overlay_tcl();
static int dgo_get_autoview_tcl();
static int dgo_get_eyemodel_tcl();
static int dgo_zap_tcl();
static int dgo_blast_tcl();
static int dgo_assoc_tcl();
d149 29
a177 29
static int dgo_rtcheck_tcl();
static int dgo_observer_tcl();
static int dgo_report_tcl();
extern int dgo_E_tcl();
static int dgo_autoview_tcl();
static int dgo_qray_tcl();
static int dgo_nirt_tcl();

static union tree *dgo_wireframe_region_end();
static union tree *dgo_wireframe_leaf();
static int dgo_drawtrees();
int dgo_invent_solid();
static void dgo_bound_solid();
void dgo_drawH_part2();
void dgo_eraseobjpath();
static void dgo_eraseobjall();
void dgo_eraseobjall_callback();
static void dgo_eraseobj();
void dgo_color_soltab();
static int dgo_run_rt();
static void dgo_rt_write();
static void dgo_rt_set_eye_model();
void dgo_cvt_vlblock_to_solids();
int dgo_build_tops();
void dgo_pr_wait_status();

void dgo_notify();
static void dgo_print_schain();
static void dgo_print_schain_vlcmds();
d236 1
a236 5
dgo_cmd(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d242 1
a242 2
Dgo_Init(interp)
     Tcl_Interp *interp;
d257 1
a257 2
dgo_deleteProc(clientData)
     ClientData clientData;
d556 1
a556 5
dgo_label_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d661 1
a661 5
dgo_draw_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d728 1
a728 5
dgo_erase_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d767 1
a767 5
dgo_erase_all_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d857 1
a857 5
dgo_who_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d866 1
a866 6
dgo_overlay(dgop, interp, fp, name, char_size)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
     FILE *fp;
     char *name;
     double char_size;
d932 1
a932 5
dgo_overlay_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1280 1
a1280 5
dgo_rt_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1413 1
a1413 5
dgo_blast_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d1672 1
a1672 3
dgo_wait_status(interp, status)
     Tcl_Interp *interp;
     int	status;
d1701 1
a1701 3
dgo_rtcheck_vector_handler(clientData, mask)
     ClientData clientData;
     int mask;
d1742 1
a1742 3
dgo_rtcheck_output_handler(clientData, mask)
     ClientData clientData;
     int mask;
d2130 1
a2130 5
dgo_rtcheck_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d2170 1
a2170 5
dgo_assoc_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d2222 1
a2222 5
dgo_observer_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d2274 1
a2274 5
dgo_report_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
a2463 18
struct dg_client_data {
	struct dg_obj		*dgop;
	Tcl_Interp		*interp;
	int			wireframe_color_override;
	int			wireframe_color[3];
	int			draw_nmg_only;
	int			nmg_triangulate;
	int			draw_wireframes;
	int			draw_normals;
	int			draw_solid_lines_only;
	int			draw_no_surfaces;
	int			shade_per_vertex_normals;
	int			draw_edge_uses;
	int			fastpath_count;			/* statistics */
	int			do_not_draw_nmg_solids_during_debugging;
	struct bn_vlblock	*draw_edge_uses_vbp;
};

d2465 1
a2465 5
dgo_wireframe_region_end(tsp, pathp, curtree, client_data)
     register struct db_tree_state	*tsp;
     struct db_full_path		*pathp;
     union tree				*curtree;
     genptr_t				client_data;
d2476 1
a2476 5
dgo_wireframe_leaf(tsp, pathp, ip, client_data)
     struct db_tree_state	*tsp;
     struct db_full_path	*pathp;
     struct rt_db_internal	*ip;
     genptr_t			client_data;
d2557 1
a2557 5
dgo_nmg_region_start(tsp, pathp, combp, client_data)
     struct db_tree_state		*tsp;
     struct db_full_path		*pathp;
     const struct rt_comb_internal	*combp;
     genptr_t				client_data;
d2659 1
a2659 5
dgo_nmg_region_end(tsp, pathp, curtree, client_data)
     register struct db_tree_state	*tsp;
     struct db_full_path		*pathp;
     union tree				*curtree;
     genptr_t				client_data;
d2794 1
a2794 6
dgo_drawtrees(dgop, interp, argc, argv, kind)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
     int	kind;
d2977 1
a2977 6
dgo_cvt_vlblock_to_solids(dgop, interp, vbp, name, copy)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
     struct bn_vlblock *vbp;
     char *name;
     int copy;
d3006 1
a3006 7
dgo_invent_solid(dgop, interp, name, vhead, rgb, copy)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
     char		*name;
     struct bu_list	*vhead;
     long		rgb;
     int		copy;
d3075 1
a3075 3
dgo_bound_solid(interp, sp)
     Tcl_Interp *interp;
     register struct solid *sp;
d3139 1
a3139 7
dgo_drawH_part2(dashflag, vhead, pathp, tsp, existing_sp, dgcdp)
     int			 dashflag;
     struct bu_list		 *vhead;
     struct db_full_path	 *pathp;
     struct db_tree_state	 *tsp;
     struct solid		 *existing_sp;
     struct dg_client_data	 *dgcdp; 
d3227 1
a3227 4
dgo_eraseobjall_callback(dbip, interp, dp)
     struct db_i *dbip;
     Tcl_Interp *interp;
     struct directory *dp;
d3981 1
a3981 3
dgo_zapall(wdbp, interp)
     struct rt_wdb *wdbp;
     Tcl_Interp *interp;
d4000 4
a4003 4
dgo_print_schain(dgop, interp, lvl)
     struct dg_obj	*dgop;
     Tcl_Interp		*interp;
     int		lvl;			/* debug level */
d4093 1
a4093 3
dgo_print_schain_vlcmds(dgop, interp)
     struct dg_obj	*dgop;
     Tcl_Interp		*interp;
@


1.72
log
@update copyright to include span through 2003
@
text
@d203 5
d1667 10
d1678 2
a1680 1
	int			pid;
d1726 1
a1779 1
#if 0
a1780 3
#else
	if((count = read((int)fd, line, 5120)) == 0){
#endif
d1791 66
d1867 1
d1871 10
d1886 1
d1982 172
d2331 1
d2347 20
d3737 1
d3744 1
a3744 7
#if 0
	char line[10240+1];

	/* Get data from rt */
	if ((count = read((int)run_rtp->fd, line, 10240)) == 0) {
#else
	char line[5120+1];
d3747 1
a3747 2
	if ((count = read((int)run_rtp->fd, line, 5120)) == 0) {
#endif
d3777 51
d3900 1
d3903 9
d3916 1
d3963 102
@


1.71
log
@Added a cast to quiet the compiler
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1997 by the United States Army
@


1.71.6.1
log
@merge from HEAD
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
@


1.71.6.2
log
@merge from head
@
text
@a202 5
#ifdef WIN32
Tcl_Channel chan1;
#endif


a1661 10
#ifdef WIN32
	HANDLE			fd;
	HANDLE			hProcess;
	DWORD			pid;
#ifdef TCL_OK
	Tcl_Channel		chan;
#else
	genptr_t chan;
#endif
#else
d1663 1
a1664 2
#endif
	FILE			*fp;
a1709 1
#ifndef WIN32
d1763 1
d1765 3
a1777 66
#else

void
dgo_rtcheck_vector_handler(ClientData clientData, int mask)
{
	int value;
	struct solid *sp;
	struct rtcheck *rtcp = (struct rtcheck *)clientData;

	/* Get vector output from rtcheck */
	if ((value = getc(rtcp->fp)) == EOF) {

		Tcl_DeleteChannelHandler(rtcp->chan,dgo_rtcheck_vector_handler,(ClientData)rtcp);
		CloseHandle(rtcp->fd);
		fclose(rtcp->fp);

		FOR_ALL_SOLIDS(sp, &rtcp->dgop->dgo_headSolid)
			sp->s_flag = DOWN;

		/* Add overlay */
		dgo_cvt_vlblock_to_solids(rtcp->dgop, rtcp->interp, rtcp->vbp, "OVERLAPS", 0);
		rt_vlblock_free(rtcp->vbp);

		/* wait for the forked process */
		WaitForSingleObject( rtcp->hProcess, INFINITE );

/*		while ((rpid = wait(&retcode)) != rtcp->pid && rpid != -1)
			dgo_wait_status(rtcp->interp, retcode);*/

		dgo_notify(rtcp->dgop, rtcp->interp);

		/* free rtcp */
		bu_free((genptr_t)rtcp, "dgo_rtcheck_vector_handler: rtcp");

		return;
	}

	(void)rt_process_uplot_value(&rtcp->vhead,
				     rtcp->vbp,
				     rtcp->fp,
				     value,
				     rtcp->csize);
}

void
dgo_rtcheck_output_handler(ClientData clientData, int mask)
{
	int count;
	char line[RT_MAXLINE];
	HANDLE fd = (HANDLE)clientData;

	/* Get textual output from rtcheck */
	if((!ReadFile(fd, line, RT_MAXLINE,&count,0))){

	Tcl_DeleteChannelHandler(chan1,dgo_rtcheck_output_handler,(ClientData)fd);
	CloseHandle(fd);

		return;
	}

	line[count] = '\0';
	bu_log("%s", line);
}

#endif

a1787 1
#ifndef WIN32
a1790 10
#else
	HANDLE	i_pipe[2],hSavei,pipe_iDup;	/* MGED reads results for building vectors */
	HANDLE	o_pipe[2],hSaveo,pipe_oDup;	/* MGED writes view parameters */
	HANDLE	e_pipe[2],hSavee,pipe_eDup;	/* MGED reads textual results */
	STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    SECURITY_ATTRIBUTES sa          = {0};
    char line[2048];
    char name[256];
#endif
a1795 1
#ifndef WIN32
a1890 172
#else

	vp = &dgop->dgo_rt_cmd[0];
	*vp++ = "rtcheck";
	*vp++ = "-s50";
	*vp++ = "-M";
	for (i=1; i < argc; i++)
		*vp++ = argv[i];
	*vp++ = dgop->dgo_wdbp->dbip->dbi_filename;

	/*
	 * Now that we've grabbed all the options, if no args remain,
	 * append the names of all stuff currently displayed.
	 * Otherwise, simply append the remaining args.
	 */
	if (i == argc) {
		dgop->dgo_rt_cmd_len = vp - dgop->dgo_rt_cmd;
		dgop->dgo_rt_cmd_len += dgo_build_tops(interp,
						       &dgop->dgo_headSolid,
						       vp,
						       &dgop->dgo_rt_cmd[MAXARGS]);
	} else {
		while (i < argc)
			*vp++ = argv[i++];
		*vp = 0;
		vp = &dgop->dgo_rt_cmd[0];
		while (*vp)
			Tcl_AppendResult(interp, *vp++, " ", (char *)NULL);

		Tcl_AppendResult(interp, "\n", (char *)NULL);
	}

    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDERR.  
	hSavee = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDERR.  
	CreatePipe( &e_pipe[0], &e_pipe[1], &sa, 0);

	// Set a write handle to the pipe to be STDERR.  
	SetStdHandle(STD_ERROR_HANDLE, e_pipe[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), e_pipe[0],
        GetCurrentProcess(),  &pipe_eDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( e_pipe[0]);



	// Save the handle to the current STDOUT.  
	hSaveo = GetStdHandle(STD_OUTPUT_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &o_pipe[0], &o_pipe[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_OUTPUT_HANDLE, o_pipe[0]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), o_pipe[1],
        GetCurrentProcess(),  &pipe_oDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( o_pipe[1]);
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSavei = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&i_pipe[0], &i_pipe[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, i_pipe[1]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), i_pipe[0], 
		GetCurrentProcess(), &pipe_iDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(i_pipe[0]);

   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
 /*  si.hStdInput   = i_pipe[0];
   si.hStdOutput  = o_pipe[1];
   si.hStdError   = e_pipe[1];*/

   
   si.hStdInput   = i_pipe[1];
   si.hStdOutput  = o_pipe[0];
   si.hStdError   = e_pipe[1];

     sprintf(line,"%s ",dgop->dgo_rt_cmd[0]);
   for(i=1;i<dgop->dgo_rt_cmd_len;i++) {
	   sprintf(name,"%s ",dgop->dgo_rt_cmd[i]);
	   strcat(line,name); }

    if(CreateProcess(NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSavei);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveo);
	SetStdHandle(STD_ERROR_HANDLE, hSavee);
}


	/* As parent, send view information down pipe */
	CloseHandle(o_pipe[0]);
	fp = _fdopen( _open_osfhandle((HFILE)pipe_oDup,_O_TEXT), "w" );
#if 1
	VSET(temp, 0.0, 0.0, 1.0);
	MAT4X3PNT(eye_model, vop->vo_view2model, temp);
#else
	dgo_rt_set_eye_model(dgop, vop, eye_model);
#endif
	dgo_rt_write(dgop, vop, fp, eye_model);

	(void)fclose(fp);

	/* close write end of pipes */
	(void)CloseHandle(i_pipe[1]);
	(void)CloseHandle(e_pipe[1]);

	BU_GETSTRUCT(rtcp, rtcheck);

	/* initialize the rtcheck struct */
	rtcp->fd = pipe_iDup;
	rtcp->fp = _fdopen( _open_osfhandle((HFILE)pipe_iDup,_O_TEXT), "r" );
	rtcp->hProcess = pi.hProcess;
	rtcp->pid = pi.dwProcessId;
	rtcp->vbp = rt_vlblock_init();
	rtcp->vhead = rt_vlblock_find(rtcp->vbp, 0xFF, 0xFF, 0x00);
	rtcp->csize = vop->vo_scale * 0.01;
	rtcp->dgop = dgop;
	rtcp->interp = interp;

	rtcp->chan = Tcl_MakeFileChannel(rtcp->fd,TCL_READABLE);
	Tcl_CreateChannelHandler(rtcp->chan,TCL_READABLE,
			      dgo_rtcheck_vector_handler, (ClientData)rtcp);

	chan1 = Tcl_MakeFileChannel(pipe_eDup,TCL_READABLE);
	Tcl_CreateChannelHandler(chan1,TCL_READABLE,
			      dgo_rtcheck_output_handler,pipe_eDup);

	return TCL_OK;


#endif
a2067 1
#ifndef WIN32
a2082 20
#else
int
dgo_rtabort_cmd(struct dg_obj	*dgop,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	struct run_rt *rrp;
	HANDLE hProcess;      

	for (BU_LIST_FOR(rrp, run_rt, &dgop->dgo_headRunRt.l)) {
		hProcess= OpenProcess(PROCESS_ALL_ACCESS, TRUE,rrp->pid);
		if(hProcess != NULL)
			TerminateProcess(hProcess, 0);
		rrp->aborted = 1;
	}

	return TCL_OK;
}
#endif
a3452 1
#ifndef WIN32
d3459 7
a3465 1
	char line[RT_MAXLINE+1];
d3468 2
a3469 1
	if ((count = read((int)run_rtp->fd, line, RT_MAXLINE)) == 0) {
a3498 51
#else
static void
dgo_rt_output_handler(ClientData	clientData,
		      int		mask)
{
	struct run_rt *run_rtp = (struct run_rt *)clientData;
	int count;
	char line[10240+1];

	/* Get data from rt */
	if (Tcl_Eof(run_rtp->chan) || (!ReadFile(run_rtp->fd, line, 10240,&count,0))) {
		int aborted;

		Tcl_DeleteChannelHandler(run_rtp->chan,dgo_rt_output_handler,(ClientData)run_rtp);
		CloseHandle(run_rtp->fd);

		/* wait for the forked process 
		 * either EOF has been sent or there was a read error.
		 * there is no need to block indefinately
		 */
		WaitForSingleObject( run_rtp->hProcess, 120 );
		/* !!! need to observer implications of being non-infinate
		 *	WaitForSingleObject( run_rtp->hProcess, INFINITE ); 
		 */
		
		if(GetLastError() == ERROR_PROCESS_ABORTED)
		{
			run_rtp->aborted = 1; 
		}

		aborted = run_rtp->aborted;

		/* free run_rtp */
 		BU_LIST_DEQUEUE(&run_rtp->l);
		bu_free((genptr_t)run_rtp, "dgo_rt_output_handler: run_rtp");

		if (aborted)
			bu_log("Raytrace aborted.\n");
		else
			bu_log("Raytrace complete.\n");
		return;
	}

	line[count] = '\0';

	/*XXX For now just blather to stderr */
	bu_log("%s", line);
}

#endif

a3570 1
#ifndef WIN32
a3572 9
#else
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    SECURITY_ATTRIBUTES sa          = {0};
    char line[2048];
    char name[256];
#endif
a3576 1
#ifndef WIN32
a3622 102

#else
	sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_err[1];
   si.hStdError   = pipe_err[1];

   sprintf(line,"%s ",dgop->dgo_rt_cmd[0]);
   for(i=1;i<dgop->dgo_rt_cmd_len;i++) {
	   sprintf(name,"%s ",dgop->dgo_rt_cmd[i]);
	   strcat(line,name); }
	   

   if(CreateProcess( NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStderr);
}


   	/* As parent, send view information down pipe */
	CloseHandle(pipe_in[0]);
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	CloseHandle(pipe_err[1]);

	dgo_rt_set_eye_model(dgop, vop, eye_model);
	dgo_rt_write(dgop, vop, fp_in, eye_model);
	(void)fclose(fp_in);

	BU_GETSTRUCT(run_rtp, run_rt);
	BU_LIST_APPEND(&dgop->dgo_headRunRt.l, &run_rtp->l);

	run_rtp->fd = pipe_errDup;
	run_rtp->hProcess = pi.hProcess;
	run_rtp->pid = pi.dwProcessId;
	run_rtp->aborted=0;

	run_rtp->chan = Tcl_MakeFileChannel(run_rtp->fd,TCL_READABLE);
	Tcl_CreateChannelHandler(run_rtp->chan,TCL_READABLE,
			      dgo_rt_output_handler, (ClientData)run_rtp);

	return 0;

#endif

@


1.70
log
@Added a "const" to quiet the compiler
@
text
@d369 1
a369 1
				dgo_cmd,
@


1.69
log
@dgo_nmg_region_end() now log the name of the current region it is working on
@
text
@d3121 1
a3121 1
		if (Tcl_SplitList(interp, list, &ac, &av_orig) != TCL_OK)
@


1.68
log
@fixed potential null dereference (that was occuring) on a tcl argv array..
@
text
@d2476 5
@


1.68.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@a202 5
#ifdef WIN32
Tcl_Channel chan1;
#endif


a1661 10
#ifdef WIN32
	HANDLE			fd;
	HANDLE			hProcess;
	DWORD			pid;
#ifdef TCL_OK
	Tcl_Channel		chan;
#else
	genptr_t chan;
#endif
#else
d1663 1
a1664 2
#endif
	FILE			*fp;
a1709 1
#ifndef WIN32
a1777 70
#else

void
dgo_rtcheck_vector_handler(ClientData clientData, int mask)
{
	int value;
	struct solid *sp;
	struct rtcheck *rtcp = (struct rtcheck *)clientData;

	/* Get vector output from rtcheck */
	if ((value = getc(rtcp->fp)) == EOF) {

		Tcl_DeleteChannelHandler(rtcp->chan,dgo_rtcheck_vector_handler,(ClientData)rtcp);
		CloseHandle(rtcp->fd);
		fclose(rtcp->fp);

		FOR_ALL_SOLIDS(sp, &rtcp->dgop->dgo_headSolid)
			sp->s_flag = DOWN;

		/* Add overlay */
		dgo_cvt_vlblock_to_solids(rtcp->dgop, rtcp->interp, rtcp->vbp, "OVERLAPS", 0);
		rt_vlblock_free(rtcp->vbp);

		/* wait for the forked process */
		WaitForSingleObject( rtcp->hProcess, INFINITE );

/*		while ((rpid = wait(&retcode)) != rtcp->pid && rpid != -1)
			dgo_wait_status(rtcp->interp, retcode);*/

		dgo_notify(rtcp->dgop, rtcp->interp);

		/* free rtcp */
		bu_free((genptr_t)rtcp, "dgo_rtcheck_vector_handler: rtcp");

		return;
	}

	(void)rt_process_uplot_value(&rtcp->vhead,
				     rtcp->vbp,
				     rtcp->fp,
				     value,
				     rtcp->csize);
}

void
dgo_rtcheck_output_handler(ClientData clientData, int mask)
{
	int count;
	char line[RT_MAXLINE];
	HANDLE fd = (HANDLE)clientData;

	/* Get textual output from rtcheck */
#if 0
	if((!ReadFile(fd, line, RT_MAXLINE,&count,0))){
#else
	if((!ReadFile(fd, line, 5120,&count,0))){
#endif

	Tcl_DeleteChannelHandler(chan1,dgo_rtcheck_output_handler,(ClientData)fd);
	CloseHandle(fd);

		return;
	}

	line[count] = '\0';
	bu_log("%s", line);
}

#endif

d1787 1
a1787 1
#ifndef WIN32
a1790 10
#else
	HANDLE	i_pipe[2],hSavei,pipe_iDup;	/* MGED reads results for building vectors */
	HANDLE	o_pipe[2],hSaveo,pipe_oDup;	/* MGED writes view parameters */
	HANDLE	e_pipe[2],hSavee,pipe_eDup;	/* MGED reads textual results */
	STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    SECURITY_ATTRIBUTES sa          = {0};
    char line[2048];
    char name[256];
#endif
a1795 1
#ifndef WIN32
a1890 172
#else

	vp = &dgop->dgo_rt_cmd[0];
	*vp++ = "rtcheck";
	*vp++ = "-s50";
	*vp++ = "-M";
	for (i=1; i < argc; i++)
		*vp++ = argv[i];
	*vp++ = dgop->dgo_wdbp->dbip->dbi_filename;

	/*
	 * Now that we've grabbed all the options, if no args remain,
	 * append the names of all stuff currently displayed.
	 * Otherwise, simply append the remaining args.
	 */
	if (i == argc) {
		dgop->dgo_rt_cmd_len = vp - dgop->dgo_rt_cmd;
		dgop->dgo_rt_cmd_len += dgo_build_tops(interp,
						       &dgop->dgo_headSolid,
						       vp,
						       &dgop->dgo_rt_cmd[MAXARGS]);
	} else {
		while (i < argc)
			*vp++ = argv[i++];
		*vp = 0;
		vp = &dgop->dgo_rt_cmd[0];
		while (*vp)
			Tcl_AppendResult(interp, *vp++, " ", (char *)NULL);

		Tcl_AppendResult(interp, "\n", (char *)NULL);
	}

    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDERR.  
	hSavee = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDERR.  
	CreatePipe( &e_pipe[0], &e_pipe[1], &sa, 0);

	// Set a write handle to the pipe to be STDERR.  
	SetStdHandle(STD_ERROR_HANDLE, e_pipe[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), e_pipe[0],
        GetCurrentProcess(),  &pipe_eDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( e_pipe[0]);



	// Save the handle to the current STDOUT.  
	hSaveo = GetStdHandle(STD_OUTPUT_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &o_pipe[0], &o_pipe[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_OUTPUT_HANDLE, o_pipe[0]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), o_pipe[1],
        GetCurrentProcess(),  &pipe_oDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( o_pipe[1]);
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSavei = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&i_pipe[0], &i_pipe[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, i_pipe[1]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), i_pipe[0], 
		GetCurrentProcess(), &pipe_iDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(i_pipe[0]);

   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
 /*  si.hStdInput   = i_pipe[0];
   si.hStdOutput  = o_pipe[1];
   si.hStdError   = e_pipe[1];*/

   
   si.hStdInput   = i_pipe[1];
   si.hStdOutput  = o_pipe[0];
   si.hStdError   = e_pipe[1];

     sprintf(line,"%s ",dgop->dgo_rt_cmd[0]);
   for(i=1;i<dgop->dgo_rt_cmd_len;i++) {
	   sprintf(name,"%s ",dgop->dgo_rt_cmd[i]);
	   strcat(line,name); }

    if(CreateProcess(NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSavei);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveo);
	SetStdHandle(STD_ERROR_HANDLE, hSavee);
}


	/* As parent, send view information down pipe */
	CloseHandle(o_pipe[0]);
	fp = _fdopen( _open_osfhandle((HFILE)pipe_oDup,_O_TEXT), "w" );
#if 1
	VSET(temp, 0.0, 0.0, 1.0);
	MAT4X3PNT(eye_model, vop->vo_view2model, temp);
#else
	dgo_rt_set_eye_model(dgop, vop, eye_model);
#endif
	dgo_rt_write(dgop, vop, fp, eye_model);

	(void)fclose(fp);

	/* close write end of pipes */
	(void)CloseHandle(i_pipe[1]);
	(void)CloseHandle(e_pipe[1]);

	BU_GETSTRUCT(rtcp, rtcheck);

	/* initialize the rtcheck struct */
	rtcp->fd = pipe_iDup;
	rtcp->fp = _fdopen( _open_osfhandle((HFILE)pipe_iDup,_O_TEXT), "r" );
	rtcp->hProcess = pi.hProcess;
	rtcp->pid = pi.dwProcessId;
	rtcp->vbp = rt_vlblock_init();
	rtcp->vhead = rt_vlblock_find(rtcp->vbp, 0xFF, 0xFF, 0x00);
	rtcp->csize = vop->vo_scale * 0.01;
	rtcp->dgop = dgop;
	rtcp->interp = interp;

	rtcp->chan = Tcl_MakeFileChannel(rtcp->fd,TCL_READABLE);
	Tcl_CreateChannelHandler(rtcp->chan,TCL_READABLE,
			      dgo_rtcheck_vector_handler, (ClientData)rtcp);

	chan1 = Tcl_MakeFileChannel(pipe_eDup,TCL_READABLE);
	Tcl_CreateChannelHandler(chan1,TCL_READABLE,
			      dgo_rtcheck_output_handler,pipe_eDup);

	return TCL_OK;


#endif
a2067 1
#ifndef WIN32
a2082 20
#else
int
dgo_rtabort_cmd(struct dg_obj	*dgop,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	struct run_rt *rrp;
	HANDLE hProcess;      

	for (BU_LIST_FOR(rrp, run_rt, &dgop->dgo_headRunRt.l)) {
		hProcess= OpenProcess(PROCESS_ALL_ACCESS, TRUE,rrp->pid);
		if(hProcess != NULL)
			TerminateProcess(hProcess, 0);
		rrp->aborted = 1;
	}

	return TCL_OK;
}
#endif
a3447 1
#ifndef WIN32
a3493 52
#else
static void
dgo_rt_output_handler(ClientData	clientData,
		      int		mask)
{
	struct run_rt *run_rtp = (struct run_rt *)clientData;
	int count;
#if 0
	char line[10240+1];

	/* Get data from rt */
	if((!ReadFile(run_rtp->fd, line, 10240,&count,0)){
#else
	char line[5120+1];

	/* Get data from rt */
	if ((!ReadFile(run_rtp->fd, line, 5120,&count,0))) {
#endif
		int aborted;

		Tcl_DeleteChannelHandler(run_rtp->chan,dgo_rt_output_handler,(ClientData)run_rtp);
		CloseHandle(run_rtp->fd);

		/* wait for the forked process */
		WaitForSingleObject( run_rtp->hProcess, INFINITE );
		
		if(GetLastError() == ERROR_PROCESS_ABORTED)
		{
			run_rtp->aborted = 1; 
		}

		aborted = run_rtp->aborted;

		/* free run_rtp */
 		BU_LIST_DEQUEUE(&run_rtp->l);
		bu_free((genptr_t)run_rtp, "dgo_rt_output_handler: run_rtp");

		if (aborted)
			bu_log("Raytrace aborted.\n");
		else
			bu_log("Raytrace complete.\n");
		return;
	}

	line[count] = '\0';

	/*XXX For now just blather to stderr */
	bu_log("%s", line);
}

#endif

a3565 1
#ifndef WIN32
a3567 9
#else
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    SECURITY_ATTRIBUTES sa          = {0};
    char line[2048];
    char name[256];
#endif
d3569 1
a3571 1
#ifndef WIN32
a3617 102

#else
	sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_err[1];
   si.hStdError   = pipe_err[1];

   sprintf(line,"%s ",dgop->dgo_rt_cmd[0]);
   for(i=1;i<dgop->dgo_rt_cmd_len;i++) {
	   sprintf(name,"%s ",dgop->dgo_rt_cmd[i]);
	   strcat(line,name); }
	   

   if(CreateProcess( NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStderr);
}


   	/* As parent, send view information down pipe */
	CloseHandle(pipe_in[0]);
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	CloseHandle(pipe_err[1]);

	dgo_rt_set_eye_model(dgop, vop, eye_model);
	dgo_rt_write(dgop, vop, fp_in, eye_model);
	(void)fclose(fp_in);

	BU_GETSTRUCT(run_rtp, run_rt);
	BU_LIST_APPEND(&dgop->dgo_headRunRt.l, &run_rtp->l);

	run_rtp->fd = pipe_errDup;
	run_rtp->hProcess = pi.hProcess;
	run_rtp->pid = pi.dwProcessId;
	run_rtp->aborted=0;

	run_rtp->chan = Tcl_MakeFileChannel(run_rtp->fd,TCL_READABLE);
	Tcl_CreateChannelHandler(run_rtp->chan,TCL_READABLE,
			      dgo_rt_output_handler, (ClientData)run_rtp);

	return 0;

#endif

@


1.68.4.2
log
@Survice Engineering patch to clean up the build environment and several runtime issues
@
text
@d3802 1
a3802 2
#if _WIN32
  if (Tcl_Eof(run_rtp->chan) || (!ReadFile(run_rtp->fd, line, 5120,&count,0))) {
d3809 2
a3810 8
		/* wait for the forked process 
		 * either EOF has been sent or there was a read error.
		 * there is no need to block indefinately
		 */
		WaitForSingleObject( run_rtp->hProcess, 120 );
		/* !!! need to observer implications of being non-infinate
		 *	WaitForSingleObject( run_rtp->hProcess, INFINITE ); 
		 */
@


1.68.4.3
log
@sync to HEAD...
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d374 1
a374 1
				(Tcl_CmdProc *)dgo_cmd,
a2766 5
	} else {
	  char	*sofar = db_path_to_string(pathp);

	  bu_log( "%s:\n", sofar );
	  bu_free((genptr_t)sofar, "path string");
d3407 1
a3407 1
		if (Tcl_SplitList(interp, list, &ac, (const char ***)&av_orig) != TCL_OK)
@


1.68.4.4
log
@fix merge bug and revert back to using RT_MAXLINE instead of hard-coded constants
@
text
@d1780 1
d1782 3
d1847 1
d1849 3
a1873 1
	int	pid; 	 
d3751 2
a3752 1
	char line[RT_MAXLINE+1];
d3755 7
a3761 1
	if ((count = read((int)run_rtp->fd, line, RT_MAXLINE)) == 0) {
d3798 1
d3802 8
a3809 1
	if (Tcl_Eof(run_rtp->chan) || (!ReadFile(run_rtp->fd, line, 10240,&count,0))) {
a3934 1
	int		pid; 	 
@


1.68.2.1
log
@Initial ANSIfication
@
text
@a53 18
struct dg_client_data {
	struct dg_obj		*dgop;
	Tcl_Interp		*interp;
	int			wireframe_color_override;
	int			wireframe_color[3];
	int			draw_nmg_only;
	int			nmg_triangulate;
	int			draw_wireframes;
	int			draw_normals;
	int			draw_solid_lines_only;
	int			draw_no_surfaces;
	int			shade_per_vertex_normals;
	int			draw_edge_uses;
	int			fastpath_count;			/* statistics */
	int			do_not_draw_nmg_solids_during_debugging;
	struct bn_vlblock	*draw_edge_uses_vbp;
};

d99 3
a101 3
extern int	dgo_qray_cmd(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv);
extern void	dgo_init_qray(struct dg_obj *dgop);
extern void	dgo_free_qray(struct dg_obj *dgop);
d104 1
a104 1
extern int	dgo_nirt_cmd(struct dg_obj *dgop, struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv);
d106 1
a106 1
static int dgo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d110 18
a127 18
static int dgo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_headSolid_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_illum_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_label_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_draw_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_ev_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_erase_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_erase_all_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_who_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_rt_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_rtabort_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_vdraw_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_overlay_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_get_autoview_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_get_eyemodel_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_zap_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_blast_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_assoc_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d131 29
a159 29
static int dgo_rtcheck_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_report_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
extern int dgo_E_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_autoview_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_qray_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_nirt_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

static union tree *dgo_wireframe_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data);
static union tree *dgo_wireframe_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data);
static int dgo_drawtrees(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv, int kind);
int dgo_invent_solid(struct dg_obj *dgop, Tcl_Interp *interp, char *name, struct bu_list *vhead, long int rgb, int copy);
static void dgo_bound_solid(Tcl_Interp *interp, register struct solid *sp);
void dgo_drawH_part2(int dashflag, struct bu_list *vhead, struct db_full_path *pathp, struct db_tree_state *tsp, struct solid *existing_sp, struct dg_client_data *dgcdp);
void dgo_eraseobjpath(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv, int noisy, int all);
static void dgo_eraseobjall(struct dg_obj *dgop, Tcl_Interp *interp, register struct directory **dpp);
void dgo_eraseobjall_callback(struct db_i *dbip, Tcl_Interp *interp, struct directory *dp);
static void dgo_eraseobj(struct dg_obj *dgop, Tcl_Interp *interp, register struct directory **dpp);
void dgo_color_soltab(struct solid *hsp);
static int dgo_run_rt(struct dg_obj *dgop, struct view_obj *vop);
static void dgo_rt_write(struct dg_obj *dgop, struct view_obj *vop, FILE *fp, fastf_t *eye_model);
static void dgo_rt_set_eye_model(struct dg_obj *dgop, struct view_obj *vop, fastf_t *eye_model);
void dgo_cvt_vlblock_to_solids(struct dg_obj *dgop, Tcl_Interp *interp, struct bn_vlblock *vbp, char *name, int copy);
int dgo_build_tops(Tcl_Interp *interp, struct solid *hsp, char **start, register char **end);
void dgo_pr_wait_status(Tcl_Interp *interp, int status);

void dgo_notify(struct dg_obj *dgop, Tcl_Interp *interp);
static void dgo_print_schain(struct dg_obj *dgop, Tcl_Interp *interp, int lvl);
static void dgo_print_schain_vlcmds(struct dg_obj *dgop, Tcl_Interp *interp);
d213 5
a217 1
dgo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d223 2
a224 1
Dgo_Init(Tcl_Interp *interp)
d239 2
a240 1
dgo_deleteProc(ClientData clientData)
d539 5
a543 1
dgo_label_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d648 5
a652 1
dgo_draw_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d719 5
a723 1
dgo_erase_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d762 5
a766 1
dgo_erase_all_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d856 5
a860 1
dgo_who_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d869 6
a874 1
dgo_overlay(struct dg_obj *dgop, Tcl_Interp *interp, FILE *fp, char *name, double char_size)
d940 5
a944 1
dgo_overlay_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1292 5
a1296 1
dgo_rt_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1429 5
a1433 1
dgo_blast_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1681 3
a1683 1
dgo_wait_status(Tcl_Interp *interp, int status)
d1711 3
a1713 1
dgo_rtcheck_vector_handler(ClientData clientData, int mask)
d1754 3
a1756 1
dgo_rtcheck_output_handler(ClientData clientData, int mask)
d1898 5
a1902 1
dgo_rtcheck_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1942 5
a1946 1
dgo_assoc_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1998 5
a2002 1
dgo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2054 5
a2058 1
dgo_report_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2227 18
d2246 5
a2250 1
dgo_wireframe_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d2261 5
a2265 1
dgo_wireframe_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d2346 5
a2350 1
dgo_nmg_region_start(struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d2452 5
a2456 1
dgo_nmg_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d2586 6
a2591 1
dgo_drawtrees(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv, int kind)
d2774 6
a2779 1
dgo_cvt_vlblock_to_solids(struct dg_obj *dgop, Tcl_Interp *interp, struct bn_vlblock *vbp, char *name, int copy)
d2808 7
a2814 1
dgo_invent_solid(struct dg_obj *dgop, Tcl_Interp *interp, char *name, struct bu_list *vhead, long int rgb, int copy)
d2883 3
a2885 1
dgo_bound_solid(Tcl_Interp *interp, register struct solid *sp)
d2949 7
a2955 1
dgo_drawH_part2(int dashflag, struct bu_list *vhead, struct db_full_path *pathp, struct db_tree_state *tsp, struct solid *existing_sp, struct dg_client_data *dgcdp)
d3043 4
a3046 1
dgo_eraseobjall_callback(struct db_i *dbip, Tcl_Interp *interp, struct directory *dp)
d3642 3
a3644 1
dgo_zapall(struct rt_wdb *wdbp, Tcl_Interp *interp)
d3663 4
a3666 4
dgo_print_schain(struct dg_obj *dgop, Tcl_Interp *interp, int lvl)
                  	      
               		        
        		    			/* debug level */
d3756 3
a3758 1
dgo_print_schain_vlcmds(struct dg_obj *dgop, Tcl_Interp *interp)
@


1.68.2.2
log
@sync branch with HEAD
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
a220 5
#ifdef WIN32
Tcl_Channel chan1;
#endif


d381 1
a381 1
				(Tcl_CmdProc *)dgo_cmd,
a1636 10
#ifdef WIN32
	HANDLE			fd;
	HANDLE			hProcess;
	DWORD			pid;
#ifdef TCL_OK
	Tcl_Channel		chan;
#else
	genptr_t chan;
#endif
#else
d1638 1
a1639 2
#endif
	FILE			*fp;
a1682 1
#ifndef WIN32
d1732 1
d1734 3
a1746 66
#else

void
dgo_rtcheck_vector_handler(ClientData clientData, int mask)
{
	int value;
	struct solid *sp;
	struct rtcheck *rtcp = (struct rtcheck *)clientData;

	/* Get vector output from rtcheck */
	if ((value = getc(rtcp->fp)) == EOF) {

		Tcl_DeleteChannelHandler(rtcp->chan,dgo_rtcheck_vector_handler,(ClientData)rtcp);
		CloseHandle(rtcp->fd);
		fclose(rtcp->fp);

		FOR_ALL_SOLIDS(sp, &rtcp->dgop->dgo_headSolid)
			sp->s_flag = DOWN;

		/* Add overlay */
		dgo_cvt_vlblock_to_solids(rtcp->dgop, rtcp->interp, rtcp->vbp, "OVERLAPS", 0);
		rt_vlblock_free(rtcp->vbp);

		/* wait for the forked process */
		WaitForSingleObject( rtcp->hProcess, INFINITE );

/*		while ((rpid = wait(&retcode)) != rtcp->pid && rpid != -1)
			dgo_wait_status(rtcp->interp, retcode);*/

		dgo_notify(rtcp->dgop, rtcp->interp);

		/* free rtcp */
		bu_free((genptr_t)rtcp, "dgo_rtcheck_vector_handler: rtcp");

		return;
	}

	(void)rt_process_uplot_value(&rtcp->vhead,
				     rtcp->vbp,
				     rtcp->fp,
				     value,
				     rtcp->csize);
}

void
dgo_rtcheck_output_handler(ClientData clientData, int mask)
{
	int count;
	char line[RT_MAXLINE];
	HANDLE fd = (HANDLE)clientData;

	/* Get textual output from rtcheck */
	if((!ReadFile(fd, line, RT_MAXLINE,&count,0))){

	Tcl_DeleteChannelHandler(chan1,dgo_rtcheck_output_handler,(ClientData)fd);
	CloseHandle(fd);

		return;
	}

	line[count] = '\0';
	bu_log("%s", line);
}

#endif

a1756 1
#ifndef WIN32
a1759 10
#else
	HANDLE	i_pipe[2],hSavei,pipe_iDup;	/* MGED reads results for building vectors */
	HANDLE	o_pipe[2],hSaveo,pipe_oDup;	/* MGED writes view parameters */
	HANDLE	e_pipe[2],hSavee,pipe_eDup;	/* MGED reads textual results */
	STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    SECURITY_ATTRIBUTES sa          = {0};
    char line[2048];
    char name[256];
#endif
a1764 1
#ifndef WIN32
a1859 172
#else

	vp = &dgop->dgo_rt_cmd[0];
	*vp++ = "rtcheck";
	*vp++ = "-s50";
	*vp++ = "-M";
	for (i=1; i < argc; i++)
		*vp++ = argv[i];
	*vp++ = dgop->dgo_wdbp->dbip->dbi_filename;

	/*
	 * Now that we've grabbed all the options, if no args remain,
	 * append the names of all stuff currently displayed.
	 * Otherwise, simply append the remaining args.
	 */
	if (i == argc) {
		dgop->dgo_rt_cmd_len = vp - dgop->dgo_rt_cmd;
		dgop->dgo_rt_cmd_len += dgo_build_tops(interp,
						       &dgop->dgo_headSolid,
						       vp,
						       &dgop->dgo_rt_cmd[MAXARGS]);
	} else {
		while (i < argc)
			*vp++ = argv[i++];
		*vp = 0;
		vp = &dgop->dgo_rt_cmd[0];
		while (*vp)
			Tcl_AppendResult(interp, *vp++, " ", (char *)NULL);

		Tcl_AppendResult(interp, "\n", (char *)NULL);
	}

    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDERR.  
	hSavee = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDERR.  
	CreatePipe( &e_pipe[0], &e_pipe[1], &sa, 0);

	// Set a write handle to the pipe to be STDERR.  
	SetStdHandle(STD_ERROR_HANDLE, e_pipe[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), e_pipe[0],
        GetCurrentProcess(),  &pipe_eDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( e_pipe[0]);



	// Save the handle to the current STDOUT.  
	hSaveo = GetStdHandle(STD_OUTPUT_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &o_pipe[0], &o_pipe[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_OUTPUT_HANDLE, o_pipe[0]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), o_pipe[1],
        GetCurrentProcess(),  &pipe_oDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( o_pipe[1]);
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSavei = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&i_pipe[0], &i_pipe[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, i_pipe[1]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), i_pipe[0], 
		GetCurrentProcess(), &pipe_iDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(i_pipe[0]);

   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
 /*  si.hStdInput   = i_pipe[0];
   si.hStdOutput  = o_pipe[1];
   si.hStdError   = e_pipe[1];*/

   
   si.hStdInput   = i_pipe[1];
   si.hStdOutput  = o_pipe[0];
   si.hStdError   = e_pipe[1];

     sprintf(line,"%s ",dgop->dgo_rt_cmd[0]);
   for(i=1;i<dgop->dgo_rt_cmd_len;i++) {
	   sprintf(name,"%s ",dgop->dgo_rt_cmd[i]);
	   strcat(line,name); }

    if(CreateProcess(NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSavei);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveo);
	SetStdHandle(STD_ERROR_HANDLE, hSavee);
}


	/* As parent, send view information down pipe */
	CloseHandle(o_pipe[0]);
	fp = _fdopen( _open_osfhandle((HFILE)pipe_oDup,_O_TEXT), "w" );
#if 1
	VSET(temp, 0.0, 0.0, 1.0);
	MAT4X3PNT(eye_model, vop->vo_view2model, temp);
#else
	dgo_rt_set_eye_model(dgop, vop, eye_model);
#endif
	dgo_rt_write(dgop, vop, fp, eye_model);

	(void)fclose(fp);

	/* close write end of pipes */
	(void)CloseHandle(i_pipe[1]);
	(void)CloseHandle(e_pipe[1]);

	BU_GETSTRUCT(rtcp, rtcheck);

	/* initialize the rtcheck struct */
	rtcp->fd = pipe_iDup;
	rtcp->fp = _fdopen( _open_osfhandle((HFILE)pipe_iDup,_O_TEXT), "r" );
	rtcp->hProcess = pi.hProcess;
	rtcp->pid = pi.dwProcessId;
	rtcp->vbp = rt_vlblock_init();
	rtcp->vhead = rt_vlblock_find(rtcp->vbp, 0xFF, 0xFF, 0x00);
	rtcp->csize = vop->vo_scale * 0.01;
	rtcp->dgop = dgop;
	rtcp->interp = interp;

	rtcp->chan = Tcl_MakeFileChannel(rtcp->fd,TCL_READABLE);
	Tcl_CreateChannelHandler(rtcp->chan,TCL_READABLE,
			      dgo_rtcheck_vector_handler, (ClientData)rtcp);

	chan1 = Tcl_MakeFileChannel(pipe_eDup,TCL_READABLE);
	Tcl_CreateChannelHandler(chan1,TCL_READABLE,
			      dgo_rtcheck_output_handler,pipe_eDup);

	return TCL_OK;


#endif
a2020 1
#ifndef WIN32
a2035 20
#else
int
dgo_rtabort_cmd(struct dg_obj	*dgop,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	struct run_rt *rrp;
	HANDLE hProcess;      

	for (BU_LIST_FOR(rrp, run_rt, &dgop->dgo_headRunRt.l)) {
		hProcess= OpenProcess(PROCESS_ALL_ACCESS, TRUE,rrp->pid);
		if(hProcess != NULL)
			TerminateProcess(hProcess, 0);
		rrp->aborted = 1;
	}

	return TCL_OK;
}
#endif
a2394 5
	} else {
	  char	*sofar = db_path_to_string(pathp);

	  bu_log( "%s:\n", sofar );
	  bu_free((genptr_t)sofar, "path string");
d3008 1
a3008 1
		if (Tcl_SplitList(interp, list, &ac, (const char ***)&av_orig) != TCL_OK)
a3339 1
#ifndef WIN32
d3346 7
a3352 1
	char line[RT_MAXLINE+1];
d3355 2
a3356 1
	if ((count = read((int)run_rtp->fd, line, RT_MAXLINE)) == 0) {
a3385 51
#else
static void
dgo_rt_output_handler(ClientData	clientData,
		      int		mask)
{
	struct run_rt *run_rtp = (struct run_rt *)clientData;
	int count;
	char line[10240+1];

	/* Get data from rt */
	if (Tcl_Eof(run_rtp->chan) || (!ReadFile(run_rtp->fd, line, 10240,&count,0))) {
		int aborted;

		Tcl_DeleteChannelHandler(run_rtp->chan,dgo_rt_output_handler,(ClientData)run_rtp);
		CloseHandle(run_rtp->fd);

		/* wait for the forked process 
		 * either EOF has been sent or there was a read error.
		 * there is no need to block indefinately
		 */
		WaitForSingleObject( run_rtp->hProcess, 120 );
		/* !!! need to observer implications of being non-infinate
		 *	WaitForSingleObject( run_rtp->hProcess, INFINITE ); 
		 */
		
		if(GetLastError() == ERROR_PROCESS_ABORTED)
		{
			run_rtp->aborted = 1; 
		}

		aborted = run_rtp->aborted;

		/* free run_rtp */
 		BU_LIST_DEQUEUE(&run_rtp->l);
		bu_free((genptr_t)run_rtp, "dgo_rt_output_handler: run_rtp");

		if (aborted)
			bu_log("Raytrace aborted.\n");
		else
			bu_log("Raytrace complete.\n");
		return;
	}

	line[count] = '\0';

	/*XXX For now just blather to stderr */
	bu_log("%s", line);
}

#endif

a3457 1
#ifndef WIN32
a3459 9
#else
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    SECURITY_ATTRIBUTES sa          = {0};
    char line[2048];
    char name[256];
#endif
a3463 1
#ifndef WIN32
a3509 102

#else
	sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_err[1];
   si.hStdError   = pipe_err[1];

   sprintf(line,"%s ",dgop->dgo_rt_cmd[0]);
   for(i=1;i<dgop->dgo_rt_cmd_len;i++) {
	   sprintf(name,"%s ",dgop->dgo_rt_cmd[i]);
	   strcat(line,name); }
	   

   if(CreateProcess( NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStderr);
}


   	/* As parent, send view information down pipe */
	CloseHandle(pipe_in[0]);
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	CloseHandle(pipe_err[1]);

	dgo_rt_set_eye_model(dgop, vop, eye_model);
	dgo_rt_write(dgop, vop, fp_in, eye_model);
	(void)fclose(fp_in);

	BU_GETSTRUCT(run_rtp, run_rt);
	BU_LIST_APPEND(&dgop->dgo_headRunRt.l, &run_rtp->l);

	run_rtp->fd = pipe_errDup;
	run_rtp->hProcess = pi.hProcess;
	run_rtp->pid = pi.dwProcessId;
	run_rtp->aborted=0;

	run_rtp->chan = Tcl_MakeFileChannel(run_rtp->fd,TCL_READABLE);
	Tcl_CreateChannelHandler(run_rtp->chan,TCL_READABLE,
			      dgo_rt_output_handler, (ClientData)run_rtp);

	return 0;

#endif

@


1.67
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d591 1
d3082 1
a3082 1
	bu_vls_init(&vls);
d3088 1
a3088 1
		struct directory **dpp;
d3119 6
d3127 1
d3132 1
a3132 1

d3136 1
a3136 1

@


1.66
log
@Converted from K&R to ANSI C - RFH
@
text
@a53 18
struct dg_client_data {
	struct dg_obj		*dgop;
	Tcl_Interp		*interp;
	int			wireframe_color_override;
	int			wireframe_color[3];
	int			draw_nmg_only;
	int			nmg_triangulate;
	int			draw_wireframes;
	int			draw_normals;
	int			draw_solid_lines_only;
	int			draw_no_surfaces;
	int			shade_per_vertex_normals;
	int			draw_edge_uses;
	int			fastpath_count;			/* statistics */
	int			do_not_draw_nmg_solids_during_debugging;
	struct bn_vlblock	*draw_edge_uses_vbp;
};

d99 3
a101 3
extern int	dgo_qray_cmd(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv);
extern void	dgo_init_qray(struct dg_obj *dgop);
extern void	dgo_free_qray(struct dg_obj *dgop);
d104 1
a104 1
extern int	dgo_nirt_cmd(struct dg_obj *dgop, struct view_obj *vop, Tcl_Interp *interp, int argc, char **argv);
d106 1
a106 1
static int dgo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d110 18
a127 18
static int dgo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_headSolid_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_illum_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_label_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_draw_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_ev_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_erase_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_erase_all_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_who_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_rt_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_rtabort_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_vdraw_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_overlay_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_get_autoview_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_get_eyemodel_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_zap_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_blast_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_assoc_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d131 29
a159 29
static int dgo_rtcheck_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_report_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
extern int dgo_E_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_autoview_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_qray_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int dgo_nirt_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

static union tree *dgo_wireframe_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data);
static union tree *dgo_wireframe_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data);
static int dgo_drawtrees(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv, int kind);
int dgo_invent_solid(struct dg_obj *dgop, Tcl_Interp *interp, char *name, struct bu_list *vhead, long int rgb, int copy);
static void dgo_bound_solid(Tcl_Interp *interp, register struct solid *sp);
void dgo_drawH_part2(int dashflag, struct bu_list *vhead, struct db_full_path *pathp, struct db_tree_state *tsp, struct solid *existing_sp, struct dg_client_data *dgcdp);
void dgo_eraseobjpath(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv, int noisy, int all);
static void dgo_eraseobjall(struct dg_obj *dgop, Tcl_Interp *interp, register struct directory **dpp);
void dgo_eraseobjall_callback(struct db_i *dbip, Tcl_Interp *interp, struct directory *dp);
static void dgo_eraseobj(struct dg_obj *dgop, Tcl_Interp *interp, register struct directory **dpp);
void dgo_color_soltab(struct solid *hsp);
static int dgo_run_rt(struct dg_obj *dgop, struct view_obj *vop);
static void dgo_rt_write(struct dg_obj *dgop, struct view_obj *vop, FILE *fp, fastf_t *eye_model);
static void dgo_rt_set_eye_model(struct dg_obj *dgop, struct view_obj *vop, fastf_t *eye_model);
void dgo_cvt_vlblock_to_solids(struct dg_obj *dgop, Tcl_Interp *interp, struct bn_vlblock *vbp, char *name, int copy);
int dgo_build_tops(Tcl_Interp *interp, struct solid *hsp, char **start, register char **end);
void dgo_pr_wait_status(Tcl_Interp *interp, int status);

void dgo_notify(struct dg_obj *dgop, Tcl_Interp *interp);
static void dgo_print_schain(struct dg_obj *dgop, Tcl_Interp *interp, int lvl);
static void dgo_print_schain_vlcmds(struct dg_obj *dgop, Tcl_Interp *interp);
d213 5
a217 1
dgo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d223 2
a224 1
Dgo_Init(Tcl_Interp *interp)
d239 2
a240 1
dgo_deleteProc(ClientData clientData)
d539 5
a543 1
dgo_label_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d647 5
a651 1
dgo_draw_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d718 5
a722 1
dgo_erase_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d761 5
a765 1
dgo_erase_all_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d855 5
a859 1
dgo_who_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d868 6
a873 1
dgo_overlay(struct dg_obj *dgop, Tcl_Interp *interp, FILE *fp, char *name, double char_size)
d939 5
a943 1
dgo_overlay_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1291 5
a1295 1
dgo_rt_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1428 5
a1432 1
dgo_blast_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1680 3
a1682 1
dgo_wait_status(Tcl_Interp *interp, int status)
d1710 3
a1712 1
dgo_rtcheck_vector_handler(ClientData clientData, int mask)
d1753 3
a1755 1
dgo_rtcheck_output_handler(ClientData clientData, int mask)
d1897 5
a1901 1
dgo_rtcheck_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1941 5
a1945 1
dgo_assoc_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1997 5
a2001 1
dgo_observer_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2053 5
a2057 1
dgo_report_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2226 18
d2245 5
a2249 1
dgo_wireframe_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d2260 5
a2264 1
dgo_wireframe_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d2345 5
a2349 1
dgo_nmg_region_start(struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d2451 5
a2455 1
dgo_nmg_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d2585 6
a2590 1
dgo_drawtrees(struct dg_obj *dgop, Tcl_Interp *interp, int argc, char **argv, int kind)
d2773 6
a2778 1
dgo_cvt_vlblock_to_solids(struct dg_obj *dgop, Tcl_Interp *interp, struct bn_vlblock *vbp, char *name, int copy)
d2807 7
a2813 1
dgo_invent_solid(struct dg_obj *dgop, Tcl_Interp *interp, char *name, struct bu_list *vhead, long int rgb, int copy)
d2882 3
a2884 1
dgo_bound_solid(Tcl_Interp *interp, register struct solid *sp)
d2948 7
a2954 1
dgo_drawH_part2(int dashflag, struct bu_list *vhead, struct db_full_path *pathp, struct db_tree_state *tsp, struct solid *existing_sp, struct dg_client_data *dgcdp)
d3042 4
a3045 1
dgo_eraseobjall_callback(struct db_i *dbip, Tcl_Interp *interp, struct directory *dp)
d3634 3
a3636 1
dgo_zapall(struct rt_wdb *wdbp, Tcl_Interp *interp)
d3655 4
a3658 4
dgo_print_schain(struct dg_obj *dgop, Tcl_Interp *interp, int lvl)
                  	      
               		        
        		    			/* debug level */
d3748 3
a3750 1
dgo_print_schain_vlcmds(struct dg_obj *dgop, Tcl_Interp *interp)
@


1.65
log
@-* removed debugging printfs
@
text
@d54 18
d117 3
a119 3
extern int	dgo_qray_cmd();
extern void	dgo_init_qray();
extern void	dgo_free_qray();
d122 1
a122 1
extern int	dgo_nirt_cmd();
d124 1
a124 1
static int dgo_open_tcl();
d128 18
a145 18
static int dgo_cmd();
static int dgo_headSolid_tcl();
static int dgo_illum_tcl();
static int dgo_label_tcl();
static int dgo_draw_tcl();
static int dgo_ev_tcl();
static int dgo_erase_tcl();
static int dgo_erase_all_tcl();
static int dgo_who_tcl();
static int dgo_rt_tcl();
static int dgo_rtabort_tcl();
static int dgo_vdraw_tcl();
static int dgo_overlay_tcl();
static int dgo_get_autoview_tcl();
static int dgo_get_eyemodel_tcl();
static int dgo_zap_tcl();
static int dgo_blast_tcl();
static int dgo_assoc_tcl();
d149 29
a177 29
static int dgo_rtcheck_tcl();
static int dgo_observer_tcl();
static int dgo_report_tcl();
extern int dgo_E_tcl();
static int dgo_autoview_tcl();
static int dgo_qray_tcl();
static int dgo_nirt_tcl();

static union tree *dgo_wireframe_region_end();
static union tree *dgo_wireframe_leaf();
static int dgo_drawtrees();
int dgo_invent_solid();
static void dgo_bound_solid();
void dgo_drawH_part2();
void dgo_eraseobjpath();
static void dgo_eraseobjall();
void dgo_eraseobjall_callback();
static void dgo_eraseobj();
void dgo_color_soltab();
static int dgo_run_rt();
static void dgo_rt_write();
static void dgo_rt_set_eye_model();
void dgo_cvt_vlblock_to_solids();
int dgo_build_tops();
void dgo_pr_wait_status();

void dgo_notify();
static void dgo_print_schain();
static void dgo_print_schain_vlcmds();
d231 1
a231 5
dgo_cmd(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d237 1
a237 2
Dgo_Init(interp)
     Tcl_Interp *interp;
d252 1
a252 2
dgo_deleteProc(clientData)
     ClientData clientData;
d551 1
a551 5
dgo_label_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d655 1
a655 5
dgo_draw_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d722 1
a722 5
dgo_erase_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d761 1
a761 5
dgo_erase_all_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d851 1
a851 5
dgo_who_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d860 1
a860 6
dgo_overlay(dgop, interp, fp, name, char_size)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
     FILE *fp;
     char *name;
     double char_size;
d926 1
a926 5
dgo_overlay_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1274 1
a1274 5
dgo_rt_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1407 1
a1407 5
dgo_blast_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d1655 1
a1655 3
dgo_wait_status(interp, status)
     Tcl_Interp *interp;
     int	status;
d1683 1
a1683 3
dgo_rtcheck_vector_handler(clientData, mask)
     ClientData clientData;
     int mask;
d1724 1
a1724 3
dgo_rtcheck_output_handler(clientData, mask)
     ClientData clientData;
     int mask;
d1866 1
a1866 5
dgo_rtcheck_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d1906 1
a1906 5
dgo_assoc_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d1958 1
a1958 5
dgo_observer_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d2010 1
a2010 5
dgo_report_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
a2178 18
struct dg_client_data {
	struct dg_obj		*dgop;
	Tcl_Interp		*interp;
	int			wireframe_color_override;
	int			wireframe_color[3];
	int			draw_nmg_only;
	int			nmg_triangulate;
	int			draw_wireframes;
	int			draw_normals;
	int			draw_solid_lines_only;
	int			draw_no_surfaces;
	int			shade_per_vertex_normals;
	int			draw_edge_uses;
	int			fastpath_count;			/* statistics */
	int			do_not_draw_nmg_solids_during_debugging;
	struct bn_vlblock	*draw_edge_uses_vbp;
};

d2180 1
a2180 5
dgo_wireframe_region_end(tsp, pathp, curtree, client_data)
     register struct db_tree_state	*tsp;
     struct db_full_path		*pathp;
     union tree				*curtree;
     genptr_t				client_data;
d2191 1
a2191 5
dgo_wireframe_leaf(tsp, pathp, ip, client_data)
     struct db_tree_state	*tsp;
     struct db_full_path	*pathp;
     struct rt_db_internal	*ip;
     genptr_t			client_data;
d2272 1
a2272 5
dgo_nmg_region_start(tsp, pathp, combp, client_data)
     struct db_tree_state		*tsp;
     struct db_full_path		*pathp;
     const struct rt_comb_internal	*combp;
     genptr_t				client_data;
d2374 1
a2374 5
dgo_nmg_region_end(tsp, pathp, curtree, client_data)
     register struct db_tree_state	*tsp;
     struct db_full_path		*pathp;
     union tree				*curtree;
     genptr_t				client_data;
d2504 1
a2504 6
dgo_drawtrees(dgop, interp, argc, argv, kind)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
     int	kind;
d2687 1
a2687 6
dgo_cvt_vlblock_to_solids(dgop, interp, vbp, name, copy)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
     struct bn_vlblock *vbp;
     char *name;
     int copy;
d2716 1
a2716 7
dgo_invent_solid(dgop, interp, name, vhead, rgb, copy)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
     char		*name;
     struct bu_list	*vhead;
     long		rgb;
     int		copy;
d2785 1
a2785 3
dgo_bound_solid(interp, sp)
     Tcl_Interp *interp;
     register struct solid *sp;
d2849 1
a2849 7
dgo_drawH_part2(dashflag, vhead, pathp, tsp, existing_sp, dgcdp)
     int			 dashflag;
     struct bu_list		 *vhead;
     struct db_full_path	 *pathp;
     struct db_tree_state	 *tsp;
     struct solid		 *existing_sp;
     struct dg_client_data	 *dgcdp; 
d2937 1
a2937 4
dgo_eraseobjall_callback(dbip, interp, dp)
     struct db_i *dbip;
     Tcl_Interp *interp;
     struct directory *dp;
d3526 1
a3526 3
dgo_zapall(wdbp, interp)
     struct rt_wdb *wdbp;
     Tcl_Interp *interp;
d3545 4
a3548 4
dgo_print_schain(dgop, interp, lvl)
     struct dg_obj	*dgop;
     Tcl_Interp		*interp;
     int		lvl;			/* debug level */
d3638 1
a3638 3
dgo_print_schain_vlcmds(dgop, interp)
     struct dg_obj	*dgop;
     Tcl_Interp		*interp;
@


1.64
log
@-* added support for get_eyemodel
@
text
@a1211 6

	fprintf(stderr, "dgo_get_eyemodel_tcl: entered\n");
	fprintf(stderr, "argv 0 = %s\n", argv[0]);
	fprintf(stderr, "argv 1 = %s\n", argv[1]);
	fprintf(stderr, "argv 2 = %s\n", argv[2]);
	  
@


1.63
log
@SURVICE mods
@
text
@d124 1
d178 1
d1141 78
@


1.62
log
@"ev" command now notes region it is working on as it goes
@
text
@d53 16
d189 3
d589 41
d631 1
d2068 56
a2400 4
	} else {
	  char	*sofar = db_path_to_string(pathp);
	  bu_log( "region: %s\n", sofar );
	  bu_free((genptr_t)sofar, "path string");
d3747 53
@


1.61
log
@*- mods to dgo_erase_cmd and dgo_erase_all_cmd
   to call helplib_alias
@
text
@d2284 4
@


1.60
log
@*- add qray and nirt commands to the drawable
   geometry object
@
text
@d505 2
d682 1
a682 1
		bu_vls_printf(&vls, "helplib_alias dgo_erase %s", argv[0]);
@


1.59
log
@*- added get_autoview command. This command returns
   the view center and size necessary to see all geometry.
   Currently, only mouse_shoot_ray uses this.
@
text
@d82 8
a116 1
#if 1
a117 1
#endif
d119 2
a124 1
static void dgo_cvt_vlblock_to_solids();
a133 1
static int dgo_build_tops();
d136 3
a155 1
#if 1
a156 1
#endif
d164 1
d167 1
d234 1
d292 2
d1930 75
d2503 1
a2503 1
				bu_vls_printf(&vls, "helplib %s", argv[0]);
d2579 1
a2579 1
static void
d3156 1
a3156 1
static int
a3246 27
int
dgo_rtabort_cmd(struct dg_obj	*dgop,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	struct run_rt	*rrp;

	for (BU_LIST_FOR(rrp, run_rt, &dgop->dgo_headRunRt.l)) {
		kill(rrp->pid, SIGKILL);
		rrp->aborted = 1;
	}

	return TCL_OK;
}

static int
dgo_rtabort_tcl(ClientData clientData,
		 Tcl_Interp *interp,
		 int argc,
		 char **argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;

	return dgo_rtabort_cmd(dgop, interp, argc-1, argv+1);
}

d3590 37
@


1.58
log
@*- set default raytrace size to 512
@
text
@d934 1
a934 1
	if (argc != 1) {
d989 1
a989 1
	return dgo_autoview_cmd(dgop, vop, interp, argc-2, argv+2);
d992 5
a996 9
/*
 * Usage:
 *        procname get_autoview
 */
static int
dgo_get_autoview_tcl(ClientData	clientData,
		     Tcl_Interp *interp,
		     int	argc,
		     char	**argv)
a997 1
	struct dg_obj *dgop = (struct dg_obj *)clientData;
d1005 10
d1049 15
@


1.57
log
@*- add more error checking to dgo_report_tcl
@
text
@d1073 1
a1073 1
	*vp++ = "-s50";
@


1.56
log
@*- mods to dgo_overlay_cmd (call helplib_alias)
@
text
@d1892 2
@


1.55
log
@*- change helplib to helplib_alias
*- mods to dgo_rt_set_eye_model to use perspective
   and zclip from the view object
*- mods to dgo_rt_cmd to use perspective
   from the view object
@
text
@d828 1
a828 1
		bu_vls_printf(&vls, "help dgo_overlay");
@


1.54
log
@*- initialize flags in "struct solid" after
   call to GET_SOLID
@
text
@d394 1
a394 1
		bu_vls_printf(&vls, "helplib dgo_headSolid");
d457 1
a457 1
	bu_vls_strcpy(&vls, "helplib dgo_illum");
d532 1
a532 1
			bu_vls_printf(&vls, "helplib dgo_draw");
d535 1
a535 1
			bu_vls_printf(&vls, "helplib dgo_E");
d538 1
a538 1
			bu_vls_printf(&vls, "helplib dgo_ev");
d622 1
a622 1
		bu_vls_printf(&vls, "helplib dgo_erase");
d668 1
a668 1
		bu_vls_printf(&vls, "helplib dgo_erase");
d714 1
a714 1
		bu_vls_printf(&vls, "helplib dgo_who");
d938 1
a938 1
		bu_vls_printf(&vls, "helplib dgo_autoview");
d967 1
a967 1
		bu_vls_printf(&vls, "helplib dgo_autoview");
d1055 1
d1061 1
a1061 1
		bu_vls_printf(&vls, "helplib dgo_%s", argv[0]);
d1075 3
a1077 3
#if 0
	if (mged_variables->mv_perspective > 0) {
		(void)sprintf(pstring, "-p%g", mged_variables->mv_perspective);
d1080 1
a1080 1
#endif
d1135 1
a1135 1
		bu_vls_printf(&vls, "helplib dgo_%s", argv[0]);
d1229 1
a1229 1
		bu_vls_printf(&vls, "helplib dgo_%s", argv[1]);
d1274 1
a1274 1
		bu_vls_printf(&vls, "helplib dgo_blast");
d1314 1
a1314 1
		bu_vls_printf(&vls, "helplib dgo_tol");
d1743 1
a1743 1
		bu_vls_printf(&vls, "helplib dgo_rtcheck");
d1813 1
a1813 1
	bu_vls_printf(&vls, "helplib dgo_assoc");
d1841 1
a1841 1
		bu_vls_printf(&vls, "helplib dgo_observer");
d1863 1
a1863 1
		bu_vls_printf(&vls, "helplib dgo_report");
d3216 1
a3216 2
#if 0
	if (dmp->dm_zclip || mged_variables->mv_perspective_mode) {
d3219 51
a3269 50
		VSET( temp, 0.0, 0.0, 1.0 );
		MAT4X3PNT( eye_model, view_state->vs_view2model, temp );
	}
#endif
	/* not doing zclipping, so back out of geometry */
	register struct solid *sp;
	register int i;
	double  t;
	double  t_in;
	vect_t  direction;
	vect_t  extremum[2];
	vect_t  minus, plus;    /* vers of this solid's bounding box */

	VSET(eye_model, -vop->vo_center[MDX],
	     -vop->vo_center[MDY], -vop->vo_center[MDZ]);

	for (i = 0; i < 3; ++i) {
		extremum[0][i] = INFINITY;
		extremum[1][i] = -INFINITY;
	}

	FOR_ALL_SOLIDS (sp, &dgop->dgo_headSolid) {
		minus[X] = sp->s_center[X] - sp->s_size;
		minus[Y] = sp->s_center[Y] - sp->s_size;
		minus[Z] = sp->s_center[Z] - sp->s_size;
		VMIN( extremum[0], minus );
		plus[X] = sp->s_center[X] + sp->s_size;
		plus[Y] = sp->s_center[Y] + sp->s_size;
		plus[Z] = sp->s_center[Z] + sp->s_size;
		VMAX( extremum[1], plus );
	}
	VMOVEN(direction, vop->vo_rotation + 8, 3);
	VSCALE(direction, direction, -1.0);
	for (i = 0; i < 3; ++i)
		if (NEAR_ZERO(direction[i], 1e-10))
			direction[i] = 0.0;
	if ((eye_model[X] >= extremum[0][X]) &&
	    (eye_model[X] <= extremum[1][X]) &&
	    (eye_model[Y] >= extremum[0][Y]) &&
	    (eye_model[Y] <= extremum[1][Y]) &&
	    (eye_model[Z] >= extremum[0][Z]) &&
	    (eye_model[Z] <= extremum[1][Z])) {
		t_in = -INFINITY;
		for (i = 0; i < 6; ++i) {
			if (direction[i%3] == 0)
				continue;
			t = (extremum[i/3][i%3] - eye_model[i%3]) /
				direction[i%3];
			if ((t < 0) && (t > t_in))
				t_in = t;
a3270 1
		VJOIN1(eye_model, eye_model, t_in, direction);
@


1.53
log
@*- mods to dgo_rt_tcl to pass dgo_rt_cmd
   the name of the command. At the moment,
   it could be rt or rtedge.
@
text
@d2562 5
@


1.52
log
@*- added autoview, E and rtedge methods
*- formatting
@
text
@d1154 2
@


1.51
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d91 1
d109 4
d120 2
a121 2
static void dgo_drawH_part2();
static void dgo_eraseobjpath();
d125 1
a125 1
static void dgo_color_soltab();
d140 1
d147 3
d152 1
a152 1
	{"ev",			dgo_draw_tcl},
d163 1
d266 1
a266 2
dgo_open_cmd(Tcl_Interp		*interp,
	     char		*oname,
a281 19
#if 0
	/* initilize tolerance structures */
	dgop->dgo_ttol.magic = RT_TESS_TOL_MAGIC;
	dgop->dgo_ttol.abs = 0.0;		/* disabled */
	dgop->dgo_ttol.rel = 0.01;
	dgop->dgo_ttol.norm = 0.0;		/* disabled */

	dgop->dgo_tol.magic = BN_TOL_MAGIC;
	dgop->dgo_tol.dist = 0.005;
	dgop->dgo_tol.dist_sq = dgop->dgo_tol.dist * dgop->dgo_tol.dist;
	dgop->dgo_tol.perp = 1e-6;
	dgop->dgo_tol.para = 1 - dgop->dgo_tol.perp;

	/* initialize tree state */
	dgop->dgo_initial_tree_state = rt_initial_tree_state;  /* struct copy */
	dgop->dgo_initial_tree_state.ts_ttol = &dgop->dgo_ttol;
	dgop->dgo_initial_tree_state.ts_tol = &dgop->dgo_tol;
#endif

d333 1
a333 1
	dgop = dgo_open_cmd(interp, argv[1], wdbp);
d349 26
d383 4
a386 5
dgo_headSolid_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d406 5
a410 13
/*
 * Illuminate/highlight database object
 *
 * Usage:
 *        procname illum [-n] obj
 *
 */
static int
dgo_illum_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a411 1
	struct dg_obj *dgop = (struct dg_obj *)clientData;
d417 2
a418 4
	DGO_CHECK_WDBP_NULL(dgop,interp);

	if (argc == 4) {
		if (argv[2][0] == '-' && argv[2][1] == 'n')
d427 1
a427 1
	if (argc != 3)
d434 2
a435 2
			if (*argv[2] == *DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_namep &&
			    strcmp(argv[2], DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_namep) == 0) {
d447 1
a447 1
		bu_vls_printf(&vls, "illum: %s not found", argv[2]);
a452 1
	dgo_notify(dgop, interp);
d464 33
d510 1
a510 1
	struct dg_obj *dgop = (struct dg_obj *)clientData;
d514 1
a514 1
	return TCL_OK;
d517 6
a522 7
static void
dgo_draw(dgop, interp, argc, argv, kind)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
     int kind;
d524 2
d527 24
a550 3
	/* skip past procname and cmd */
	argc -= 2;
	argv += 2;
d558 2
d576 26
a601 2
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	int kind;
d605 14
a618 1
	if (argc < 3) {
d622 1
a622 1
		bu_vls_printf(&vls, "helplib dgo_draw");
a624 1

d628 1
a628 7
	if (argv[1][0] == 'e' && argv[1][1] == 'v')
		kind = 3;
	else
		kind = 1;

	dgo_draw(dgop, interp, argc, argv, kind);
	dgo_notify(dgop, interp);
d647 2
a648 2
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct bu_vls vls;
d652 15
a666 1
	if (argc < 3) {
d674 1
a674 2
	dgo_eraseobjpath(dgop, interp, argc-2, argv+2, LOOKUP_NOISY, 0);
	dgo_notify(dgop, interp);
d690 2
a691 2
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct bu_vls vls;
d695 2
a696 10
	if (argc < 3) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib dgo_erase");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	dgo_eraseobjpath(dgop, interp, argc-2, argv+2, LOOKUP_NOISY, 1);
	dgo_notify(dgop, interp);
d698 1
a698 1
	return TCL_OK;
d701 5
a705 12
/*
 * List the objects currently being drawn.
 *
 * Usage:
 *        procname who [r(eal)|p(hony)|b(oth)]
 */
static int
dgo_who_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a706 1
	struct dg_obj *dgop = (struct dg_obj *)clientData;
d710 1
a710 3
	DGO_CHECK_WDBP_NULL(dgop,interp);

	if (argc < 2 || 3 < argc) {
d722 2
a723 2
	if (argc > 2) {
		switch (argv[2][0]) {
d771 19
d814 5
a818 10
/*
 * Usage:
 *        procname overlay file.plot char_size [name]
 */
static int
dgo_overlay_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d820 3
a822 6
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	FILE		*fp;
	double char_size;
	char		*name;

	DGO_CHECK_WDBP_NULL(dgop,interp);
d824 1
a824 1
	if (argc < 4 || 5 < argc) {
d835 1
a835 1
	if (sscanf(argv[3], "%lf", &char_size) != 1) {
d837 1
a837 1
				 argv[3], "\n", (char *)NULL);
d841 1
a841 1
	if (argc == 4)
d844 1
a844 1
		name = argv[4];
d846 1
a846 1
	if ((fp = fopen(argv[2], "r")) == NULL) {
d848 1
a848 1
				 argv[2], "\n", (char *)NULL);
a853 2
	dgo_notify(dgop, interp);

d859 1
a859 1
 *        procname get_autoview
d862 1
a862 1
dgo_get_autoview_tcl(clientData, interp, argc, argv)
d868 16
a883 2
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct bu_vls vls;
a889 2
	DGO_CHECK_WDBP_NULL(dgop,interp);

d916 30
a945 4
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "center {%g %g %g} size %g", V3ARGS(center), radial[X] * 2.0);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
d952 1
a952 1
 *        procname rt view_obj arg(s)
d955 4
a958 5
dgo_rt_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d961 1
a961 3
	struct view_obj *vop;
	register char **vp;
	register int i;
d963 2
a964 1
	DGO_CHECK_WDBP_NULL(dgop,interp);
d966 6
a971 2
	if (argc < 3 || MAXARGS < argc) {
	  struct bu_vls vls;
d973 3
a975 6
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "helplib dgo_rt");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}
d984 1
a984 1
		Tcl_AppendResult(interp, "dgo_rt: bad view object - ", argv[2],
d989 77
d1067 3
d1071 1
d1080 1
a1080 1
	for (i=3; i < argc; i++) {
d1106 41
a1146 2
		while (*vp)
			Tcl_AppendResult(interp, *vp++, " ", (char *)NULL);
d1148 4
a1151 1
		Tcl_AppendResult(interp, "\n", (char *)NULL);
a1152 1
	(void)dgo_run_rt(dgop, vop);
d1154 10
a1163 1
	return TCL_OK;
d1171 4
a1174 5
dgo_vdraw_tcl(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1180 1
a1180 1
	return bu_cmd(clientData, interp, argc, argv, vdraw_cmds, 2);
d1183 3
a1185 4
static void
dgo_zap(dgop, interp)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
d1213 4
a1216 5
dgo_zap_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d1218 1
a1218 1
	struct dg_obj *dgop = (struct dg_obj *)clientData;
d1223 1
a1223 1
	  struct bu_vls vls;
d1225 5
a1229 5
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "helplib dgo_%s", argv[1]);
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
d1232 1
a1232 1
	dgo_zap(dgop, interp);
d1238 13
d1262 2
a1263 1
	struct dg_obj *dgop = (struct dg_obj *)clientData;
d1278 2
a1279 6
	/* First, clear the screen. */
	dgo_zap(dgop, interp);

	/* Now, draw the new object(s). */
	dgo_draw(dgop, interp, argc, argv, 1);
	dgo_notify(dgop, interp);
d1281 1
a1281 1
	return TCL_OK;
d1605 6
a1610 10
/*
 * Usage:
 *        procname rtcheck view_obj [args]
 */
static int
dgo_rtcheck_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
a1611 2
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct view_obj *vop;
a1622 25
	DGO_CHECK_WDBP_NULL(dgop,interp);

	if (argc < 3 || MAXARGS < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib dgo_rtcheck");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	/* search for view object */
	for (BU_LIST_FOR(vop, view_obj, &HeadViewObj.l)) {
		if (strcmp(bu_vls_addr(&vop->vo_name), argv[2]) == 0)
			break;
	}

	if (BU_LIST_IS_HEAD(vop, &HeadViewObj.l)) {
		Tcl_AppendResult(interp, "dgo_rtcheck: bad view object - ", argv[2],
				 "\n", (char *)NULL);
		return TCL_ERROR;
	}

d1627 1
a1627 1
	for (i=3; i < argc; i++)
d1721 42
d1800 1
a1800 1
			dgo_zap(dgop, interp);
d1848 5
a1852 9
/*
 *  Report information about solid table, and per-solid VLS
 */
static int
dgo_report_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
a1854 1
	struct dg_obj	*dgop = (struct dg_obj *)clientData;
d1856 1
a1856 1
	if (argc < 2 || 3 < argc) {
d1866 2
a1867 2
	if (argc == 3)
		lvl = atoi(argv[2]);
d1877 43
a1919 1
/****************** utility routines ********************/
d1924 2
a1933 2
	int			wireframe_color_override;
	int			wireframe_color[3];
d2039 1
a2039 1
int
d2637 1
a2637 1
static void
d2753 7
a2759 8
static void
dgo_eraseobjpath(dgop, interp, argc, argv, noisy, all)
     struct dg_obj *dgop;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
     int	noisy;	
     int	all;
d2764 1
d2769 1
d2838 2
d2842 1
d2852 3
a2854 4
dgo_eraseobjall(dgop, interp, dpp)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
     register struct directory **dpp;
d2864 3
d2899 3
a2901 4
dgo_eraseobj(dgop, interp, dpp)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
     register struct directory **dpp;
d2903 43
d2979 1
d2988 2
a2989 3
static void
dgo_color_soltab(hsp)
     struct solid *hsp;
d3040 4
a3043 5
dgo_build_tops(interp, hsp, start, end)
     Tcl_Interp *interp;
     struct solid *hsp;
     char **start;
     register char **end;
d3088 4
a3091 5
dgo_rt_write(dgop, vop, fp, eye_model)
     struct dg_obj *dgop;
     struct view_obj *vop;
     FILE *fp;
     vect_t eye_model;
d3130 5
a3134 5
static int
dgo_rtabort_tcl(ClientData clientData,
		 Tcl_Interp *interp,
		 int argc,
		 char **argv)
a3135 1
	struct dg_obj	*dgop = (struct dg_obj *)clientData;
d3146 11
d3158 2
a3159 3
dgo_rt_output_handler(clientData, mask)
     ClientData clientData;
     int mask;
d3204 3
a3206 4
dgo_rt_set_eye_model(dgop, vop, eye_model)
     struct dg_obj *dgop;
     struct view_obj *vop;
     vect_t eye_model;
d3271 2
a3272 3
dgo_run_rt(dgop, vop)
     struct dg_obj *dgop;
     struct view_obj *vop; 
d3331 2
a3332 3
dgo_notify(dgop, interp)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
d3338 2
a3339 3
dgo_impending_wdb_close(wdbp, interp)
     struct rt_wdb *wdbp;
     Tcl_Interp *interp;
d3345 1
a3345 1
			dgo_zap(dgop, interp);
d3360 1
a3360 1
			dgo_zap(dgop, interp);
@


1.50
log
@*- hide the close command, I believe it's not necessary
@
text
@d1655 1
a1655 1
	if (rt_g.debug&DEBUG_TREEWALK) {
d1737 1
a1737 1
	if (rt_g.debug&DEBUG_TREEWALK) {
d1784 1
a1784 1
			if (rt_g.debug&DEBUG_TREEWALK) {
d1796 1
a1796 1
			if (rt_g.debug&DEBUG_TREEWALK) {
d1847 1
a1847 1
	if(rt_g.debug&DEBUG_TREEWALK)  {
@


1.49
log
@*- create new function dgo_open_cmd that
   returns a "struct db_obj *"
@
text
@d83 1
d85 1
d137 1
d139 1
d220 1
d250 1
@


1.48
log
@CONST to const
@
text
@d5 1
a5 1
 * for creating/destroying geometry that is ready (i.e. vlists) for
d247 46
d300 4
a303 5
dgo_open_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
d331 1
a331 6
	if (BU_LIST_IS_HEAD(wdbp, &rt_g.rtg_headwdb.l)) {
#if 0
		Tcl_AppendResult(interp, "dgo_open: bad database object - ", argv[2],
				 "\n", (char *)NULL);
		return TCL_ERROR;
#else
a332 33
#endif
	}

	/* acquire dg_obj struct */
	BU_GETSTRUCT(dgop,dg_obj);

	/* initialize dg_obj */
	bu_vls_init(&dgop->dgo_name);
	bu_vls_strcpy(&dgop->dgo_name,argv[1]);
	dgop->dgo_wdbp = wdbp;
	BU_LIST_INIT(&dgop->dgo_headSolid);
	BU_LIST_INIT(&dgop->dgo_headVDraw);
	BU_LIST_INIT(&dgop->dgo_observers.l);
	BU_LIST_INIT(&dgop->dgo_headRunRt.l);

#if 0
	/* initilize tolerance structures */
	dgop->dgo_ttol.magic = RT_TESS_TOL_MAGIC;
	dgop->dgo_ttol.abs = 0.0;		/* disabled */
	dgop->dgo_ttol.rel = 0.01;
	dgop->dgo_ttol.norm = 0.0;		/* disabled */

	dgop->dgo_tol.magic = BN_TOL_MAGIC;
	dgop->dgo_tol.dist = 0.005;
	dgop->dgo_tol.dist_sq = dgop->dgo_tol.dist * dgop->dgo_tol.dist;
	dgop->dgo_tol.perp = 1e-6;
	dgop->dgo_tol.para = 1 - dgop->dgo_tol.perp;

	/* initialize tree state */
	dgop->dgo_initial_tree_state = rt_initial_tree_state;  /* struct copy */
	dgop->dgo_initial_tree_state.ts_ttol = &dgop->dgo_ttol;
	dgop->dgo_initial_tree_state.ts_tol = &dgop->dgo_tol;
#endif
d334 2
a335 2
	/* append to list of dg_obj's */
	BU_LIST_APPEND(&HeadDGObj.l,&dgop->l);
d337 1
d347 1
@


1.47
log
@Support for major and minor types in directory structure
@
text
@d55 1
a55 1
	       CONST struct rt_tess_tol *, CONST struct bn_tol *);
d57 1
a57 1
		    CONST struct rt_tess_tol *, CONST struct bn_tol *);
d59 1
a59 1
		    CONST struct rt_tess_tol *, CONST struct bn_tol *);
d61 1
a61 1
		    CONST struct rt_tess_tol *, CONST struct bn_tol *);
d1711 1
a1711 1
     CONST struct rt_comb_internal	*combp;
d2077 1
a2077 1
		ret = db_walk_tree(dgop->dgo_wdbp->dbip, argc, (CONST char **)argv,
d2098 1
a2098 1
		ret = db_walk_tree(dgop->dgo_wdbp->dbip, argc, (CONST char **)argv,
@


1.46
log
@*- delete unused variable
@
text
@d2181 1
d2201 1
a2201 1
	dp = db_diradd(dgop->dgo_wdbp->dbip,  name, RT_DIR_PHONY_ADDR, 0, DIR_SOLID, NULL);
@


1.45
log
@*- fixed two places not using helplib
@
text
@a3086 1
	register int			i;
@


1.44
log
@patches to merge 5.3 into 6.0
@
text
@d614 1
a614 1
		bu_vls_printf(&vls, "help dgo_who");
d825 1
a825 1
	  bu_vls_printf(&vls, "help dgo_rt");
d2059 1
a2059 1
				bu_vls_printf(&vls, "help %s", argv[0]);
@


1.43
log
@*- remove unnecessary include statement
@
text
@d40 2
d93 1
d148 1
d203 7
d306 1
d2751 17
d2773 1
a2773 1
	int fd = (int)((long)clientData & 0xFFFF);	/* fd's will be small */
d2776 4
a2779 1
	char line[10240];
d2781 4
a2784 1
	char line[5120];
d2786 6
d2793 8
a2800 5
	/* Get data from rt */
	/* if ((count = read((int)fd, line, 10240)) == 0) { */
	if ((count = read((int)fd, line, 5120)) == 0) {
		Tcl_DeleteFileHandler(fd);
		close(fd);
d2802 4
d2888 7
a2894 5
	register int i;
	FILE *fp_in;
	int pipe_in[2];
	int pipe_err[2];
	vect_t eye_model;
d2899 1
a2899 1
	if ((fork()) == 0) {
d2933 7
a2939 2
	Tcl_CreateFileHandler(pipe_err[0], TCL_READABLE,
			      dgo_rt_output_handler, (ClientData)pipe_err[0]);
d3087 1
@


1.42
log
@Fix some lint by declaring a Function before it is used.
@
text
@a32 4
#ifdef HAVE_STRING_H
#include <string.h>
#endif

@


1.41
log
@
Modified MGED's "fast path" through the "ev" command for drawing polygonal
objects to (a) use the g_xxx.c plot routine rather than duplicating the
code, and (b) added methods for drawing the polygonal version.
Extended fast path to work for Bots.
Also included fixes in new DGO stuff.
@
text
@d55 9
@


1.40
log
@Use C code to split the input string instead
of Tcl's split. The use of Tcl_Eval here
introduces a security hole if the input string
is untrusted.
@
text
@a1751 4
			struct rt_pg_internal	*pgp;
			register int	i;
			int		p;

d1753 1
a1753 1
				bu_log("fastpath draw ID_POLY\n", dp->d_namep);
a1754 3
			pgp = (struct rt_pg_internal *)intern.idb_ptr;
			RT_PG_CK_MAGIC(pgp);

d1756 1
a1756 11
				for (p = 0; p < pgp->npoly; p++) {
					register struct rt_pg_face_internal	*pp;

					pp = &pgp->poly[p];
					RT_ADD_VLIST( &vhead, &pp->verts[3*(pp->npts-1)],
						BN_VLIST_LINE_MOVE );
					for (i=0; i < pp->npts; i++) {
						RT_ADD_VLIST(&vhead, &pp->verts[3*i],
							      BN_VLIST_LINE_DRAW);
					}
				}
d1758 13
a1770 23
				for (p = 0; p < pgp->npoly; p++) {
					register struct rt_pg_face_internal	*pp;
					vect_t aa, bb, norm;

					pp = &pgp->poly[p];
					if (pp->npts < 3)
						continue;
					VSUB2( aa, &pp->verts[3*(0)], &pp->verts[3*(1)] );
					VSUB2( bb, &pp->verts[3*(0)], &pp->verts[3*(2)] );
					VCROSS( norm, aa, bb );
					VUNITIZE(norm);
					RT_ADD_VLIST(&vhead, norm,
						     BN_VLIST_POLY_START);

					RT_ADD_VLIST(&vhead, &pp->verts[3*(pp->npts-1)],
						     BN_VLIST_POLY_MOVE);
					for (i=0; i < pp->npts-1; i++) {
						RT_ADD_VLIST(&vhead, &pp->verts[3*i],
							     BN_VLIST_POLY_DRAW);
					}
					RT_ADD_VLIST(&vhead, &pp->verts[3*(pp->npts-1)],
						     BN_VLIST_POLY_END);
				}
@


1.39
log
@
DIR_USED was moved into raytrace.h
@
text
@d2455 1
d2462 21
a2482 1
		Tcl_SplitList(interp, list, &ac, &av_orig);
@


1.38
log
@
s_path array has been replaced by a s_fullpath "struct db_full_path".
This has eliminated the MAX_PATH restriction in MGED.
member s_last is gone too.
@
text
@a2712 1
#define DIR_USED	0x80	/* XXX move to raytrace.h */
a2736 1
#undef DIR_USED
@


1.37
log
@Patches for compiling under RedHat 7.0
@
text
@d397 3
a399 3
		for (i = 0; i <= sp->s_last; ++i) {
			if (*argv[2] == *sp->s_path[i]->d_namep &&
			    strcmp(argv[2], sp->s_path[i]->d_namep) == 0) {
d636 1
a636 1
		if (sp->s_path[0]->d_addr == RT_DIR_PHONY_ADDR) {
d641 1
a641 1
		Tcl_AppendResult(interp, sp->s_path[0]->d_namep, " ", (char *)NULL);
d644 1
a644 1
			if (forw->s_path[0] == sp->s_path[0])
d901 1
a901 1
		dp = sp->s_path[0];
d2226 1
a2226 2
	sp->s_last = 0;
	sp->s_path[0] = dp;
a2323 1
	register int	i;
a2325 8
		if (pathp->fp_len > MAX_PATH) {
		  char *cp = db_path_to_string(pathp);

		  Tcl_AppendResult(dgcdp->interp, "drawH_part2: path too long, solid ignored.\n\t",
				   cp, "\n", (char *)NULL);
		  bu_free((genptr_t)cp, "Path string");
		  return;
		}
d2379 1
a2379 6
		sp->s_last = pathp->fp_len-1;

		/* Copy path information */
		for (i=0; i<=sp->s_last; i++) {
			sp->s_path[i] = pathp->fp_names[i];
		}
d2512 1
a2512 1
	register int i;
d2517 2
a2518 1
	for (tmp_dpp = dpp; *tmp_dpp != DIR_NULL; ++tmp_dpp)
d2520 2
d2526 1
a2526 15
		for (i=0; i <= sp->s_last; i++) {
			/* look for first path element */
			if (sp->s_path[i] != *dpp)
				continue;

			/* look for rest of path */
			for (++i, tmp_dpp = dpp+1;
			     i <= sp->s_last && *tmp_dpp != DIR_NULL;
			     ++i, ++tmp_dpp)
				if (sp->s_path[i] != *tmp_dpp)
					goto end;

			if (*tmp_dpp != DIR_NULL)
				goto end;

a2528 2

			break;
a2529 1
	end:
d2538 1
d2557 1
a2557 1
	register int i;
d2565 2
a2566 1
	for (tmp_dpp = dpp; *tmp_dpp != DIR_NULL; ++tmp_dpp)
d2568 2
d2574 4
a2577 12
		for (i = 0, tmp_dpp = dpp;
		     i <= sp->s_last && *tmp_dpp != DIR_NULL;
		     ++i, ++tmp_dpp)
			if (sp->s_path[i] != *tmp_dpp)
				goto end;

		if (*tmp_dpp != DIR_NULL)
			goto end;

		BU_LIST_DEQUEUE(&sp->l);
		FREE_SOLID(sp, &FreeSolid.l);
	end:
d2586 1
d2665 1
d2669 1
a2669 1
		if (sp->s_path[0]->d_addr == RT_DIR_PHONY_ADDR)
d2672 1
a2672 1
			*vp++ = sp->s_path[0]->d_namep;
d2675 1
a2675 1
				   sp->s_path[0]->d_namep, "\n", (char *)NULL);
d2680 1
a2680 1
			if (forw->s_path[0] == sp->s_path[0])
d2716 2
a2717 2
		for (i=0;i<=sp->s_last;i++) {
			sp->s_path[i]->d_flags &= ~DIR_USED;
d2721 2
a2722 2
		for (i=0; i<=sp->s_last; i++ ) {
			if (!(sp->s_path[i]->d_flags & DIR_USED)) {
d2724 1
a2724 1
				for (anp = sp->s_path[i]->d_animate; anp;
d2728 1
a2728 1
				sp->s_path[i]->d_flags |= DIR_USED;
d2734 2
a2735 2
		for (i=0;i<=sp->s_last;i++) {
			sp->s_path[i]->d_flags &= ~DIR_USED;
a2942 1
	register int			i;
d2956 1
a2956 1
			bu_vls_printf(&vls, "%s ", sp->s_path[(int)(sp->s_last)]->d_namep);
d2960 1
a2960 2
		for (i=0; i <= sp->s_last; i++)
			bu_vls_printf(&vls, "/%s", sp->s_path[i]->d_namep);
a3034 1
	register int			i;
@


1.36
log
@Added dgo_print_schain_vlcmds(). This is
called by dgo_report_tcl() to print only
vlist commands.
@
text
@d33 4
@


1.35
log
@
Modified tree routines to take resource pointer.
@
text
@d114 1
d1557 5
a1561 1
	dgo_print_schain(dgop, interp, lvl);
d3045 46
@


1.34
log
@
lint
@
text
@d1610 1
d1661 1
a1661 1
	BU_GETUNION(curtree, tree);
d1704 3
d1737 1
a1737 1
	if (rt_db_get_internal(&intern, dp, tsp->ts_dbip, matp) < 0)
d1796 1
a1796 1
	rt_db_free_internal(&intern);
d1804 1
a1804 1
	rt_db_free_internal(&intern);
d1829 1
d1854 1
a1854 1
				db_free_tree( curtree );
d1857 1
a1857 1
		failed = nmg_boolean( curtree, *tsp->ts_m, tsp->ts_tol );
d1860 1
a1860 1
			db_free_tree( curtree );
d1867 1
a1867 1
	  db_free_tree( curtree );
d1874 1
a1874 1
		db_free_tree( curtree );
d1888 1
a1888 1
				db_free_tree( curtree );
d1924 1
a1924 1
		db_free_tree( curtree );
@


1.33
log
@Call dgo_notify in dgo_rtcheck_vector_handler.
@
text
@d30 1
d32 6
d40 1
a40 1
#include "conf.h"
d119 17
a135 17
	"assoc",		dgo_assoc_tcl,
	"blast",		dgo_blast_tcl,
	"clear",		dgo_zap_tcl,
	"close",		dgo_close_tcl,
	"draw",			dgo_draw_tcl,
	"erase",		dgo_erase_tcl,
	"erase_all",		dgo_erase_all_tcl,
	"ev",			dgo_draw_tcl,
	"get_autoview",		dgo_get_autoview_tcl,
	"headSolid",		dgo_headSolid_tcl,
	"illum",		dgo_illum_tcl,
	"label",		dgo_label_tcl,
	"observer",		dgo_observer_tcl,
	"overlay",		dgo_overlay_tcl,
	"report",		dgo_report_tcl,
	"rt",			dgo_rt_tcl,
	"rtcheck",		dgo_rtcheck_tcl,
d137 1
a137 1
	"tol",			dgo_tol_tcl,
d139 4
a142 4
	"vdraw",		dgo_vdraw_tcl,
	"who",			dgo_who_tcl,
	"zap",			dgo_zap_tcl,
	(char *)0,		(int (*)())0
a389 1
		register struct solid *forw;
a451 2
	register struct directory *dp;
	register int i;
d2974 1
a2974 1
			bu_vls_printf(&vls, "%s ", sp->s_path[sp->s_last]->d_namep);
@


1.32
log
@
db_walk_tree leaf callback arg change.
@
text
@d105 1
a105 1
static void dgo_notify();
d1255 2
d2905 1
a2905 1
static void
@


1.31
log
@
rt_db_free_internal
@
text
@d1591 1
a1591 1
dgo_wireframe_leaf(tsp, pathp, ep, id, client_data)
d1594 1
a1594 2
     struct bu_external		*ep;
     int			id;
a1596 1
	struct rt_db_internal	intern;
d1610 2
a1611 1
		Tcl_AppendResult(dgcdp->interp, "dgo_wireframe_leaf(", rt_functab[id].ft_name,
d1621 1
a1621 9
	RT_INIT_DB_INTERNAL(&intern);
	if (rt_functab[id].ft_import(&intern, ep, tsp->ts_mat, dgcdp->dgop->dgo_wdbp->dbip) < 0) {
		Tcl_AppendResult(dgcdp->interp, DB_FULL_PATH_CUR_DIR(pathp)->d_namep,
				 ":  solid import failure\n", (char *)NULL);

		rt_db_free_internal( &intern );
		return (TREE_NULL);		/* ERROR */
	}
	RT_CK_DB_INTERNAL(&intern);
d1623 1
a1623 2
	if (rt_functab[id].ft_plot(&vhead,
				   &intern,
a1627 1
		rt_db_free_internal(&intern);
d1637 1
a1637 1
	if (intern.idb_type == ID_GRIP) {
a1651 1
	rt_db_free_internal(&intern);
@


1.30
log
@*- fix off by one errors in dgo_report_tcl
*- change helplib commands for open, observer and report
@
text
@d1627 1
a1627 2
		if (intern.idb_ptr)
			rt_functab[id].ft_ifree( &intern );
d1638 1
a1638 1
		rt_functab[id].ft_ifree(&intern);
d1663 1
a1663 1
	rt_functab[id].ft_ifree(&intern);
@


1.30.2.1
log
@Remove static specifier from dgo_notify declaration.
@
text
@d105 1
a105 1
void dgo_notify();
d2916 1
a2916 1
void
@


1.30.2.2
log
@New function - dgo_print_schain_vlcmds()
@
text
@a106 1
static void dgo_print_schain_vlcmds();
d1550 1
a1550 5

	if (lvl <= 3) 
		dgo_print_schain(dgop, interp, lvl);
	else
		dgo_print_schain_vlcmds(dgop, interp);
a3041 46
	}

	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
}

/*
 *			D G O _ P R _ S C H A I N _ V L C M D S
 *
 *  Given a pointer to a member of the circularly linked list of solids
 *  (typically the head), chase the list and print out the vlist cmds
 *  for each structure.
 */
static void
dgo_print_schain_vlcmds(dgop, interp)
     struct dg_obj	*dgop;
     Tcl_Interp		*interp;
{
	register struct solid		*sp;
	register int			i;
	register struct bn_vlist	*vp;
	struct bu_vls 		vls;

	if (dgop->dgo_wdbp->dbip == DBI_NULL)
		return;

	bu_vls_init(&vls);

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		bu_vls_printf(&vls, "-1 %d %d %d\n",
			      sp->s_color[0],
			      sp->s_color[1],
			      sp->s_color[2]);

		/* Print the actual vector list */
		for (BU_LIST_FOR(vp, bn_vlist, &(sp->s_vlist))) {
			register int	i;
			register int	nused = vp->nused;
			register int	*cmd = vp->cmd;
			register point_t *pt = vp->pt;

			BN_CK_VLIST(vp);

			for (i = 0; i < nused; i++, cmd++, pt++)
				bu_vls_printf(&vls, "%d %g %g %g\n", *cmd, V3ARGS(*pt));
		}
@


1.30.2.3
log
@Split the string with C code. Using the
Tcl_Eval here can introduce a security
hole if this routine is ever passed untrusted
strings.
@
text
@a33 5
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
a2467 1
#if 0
a2473 19
#else
		{
			char *begin;
			char *end;
			char *newstr = strdup(argv[i]);

			begin = newstr;
			bu_vls_trunc(&vls, 0);

			while ((end = strchr(begin, '/')) != NULL) {
				*end = '\0';
				bu_vls_printf(&vls, "%s ", begin);
				begin = end + 1;
			}
			bu_vls_printf(&vls, "%s ", begin);
			free((void *)newstr);
		}
		list = bu_vls_addr(&vls);
#endif
@


1.30.2.4
log
@Check return value of Tcl_SplitList
@
text
@d2499 1
a2499 2
		if (Tcl_SplitList(interp, list, &ac, &av_orig) != TCL_OK)
			continue;
@


1.30.2.5
log
@*- add rtabort code
@
text
@a32 1
#include <signal.h>
a79 1
static int dgo_rtabort_tcl();
a133 1
	"rtabort",		dgo_rtabort_tcl,
a187 7
	/*
	 * XXX Do something for the case where the drawable geometry
	 * XXX object is deleted and the object has forked rt processes.
	 * XXX This will create a memory leak.
	 */


a283 1
	BU_LIST_INIT(&dgop->dgo_headRunRt.l);
a2796 17
static int
dgo_rtabort_tcl(ClientData clientData,
		 Tcl_Interp *interp,
		 int argc,
		 char **argv)
{
	struct dg_obj	*dgop = (struct dg_obj *)clientData;
	struct run_rt	*rrp;

	for (BU_LIST_FOR(rrp, run_rt, &dgop->dgo_headRunRt.l)) {
		kill(rrp->pid, SIGKILL);
		rrp->aborted = 1;
	}

	return TCL_OK;
}

d2802 1
a2802 1
	struct run_rt *run_rtp = (struct run_rt *)clientData;
d2805 1
a2805 4
	char line[10240+1];

	/* Get data from rt */
	if ((count = read((int)run_rtp->fd, line, 10240)) == 0) {
d2807 2
a2808 1
	char line[5120+1];
d2811 4
a2814 11
	if ((count = read((int)run_rtp->fd, line, 5120)) == 0) {
#endif
		int retcode;
		int rpid;
		int aborted;

		Tcl_DeleteFileHandler(run_rtp->fd);
		close(run_rtp->fd);

		/* wait for the forked process */
		while ((rpid = wait(&retcode)) != run_rtp->pid && rpid != -1);
a2815 10
		aborted = run_rtp->aborted;

		/* free run_rtp */
 		BU_LIST_DEQUEUE(&run_rtp->l);
		bu_free((genptr_t)run_rtp, "dgo_rt_output_handler: run_rtp");

		if (aborted)
			bu_log("Raytrace aborted.\n");
		else
			bu_log("Raytrace complete.\n");
d2898 5
a2902 7
	register int	i;
	FILE		*fp_in;
	int		pipe_in[2];
	int		pipe_err[2];
	vect_t		eye_model;
	int		pid; 	 
	struct run_rt	*run_rtp;
d2907 1
a2907 1
	if ((pid = fork()) == 0) {
d2941 2
a2942 7
	BU_GETSTRUCT(run_rtp, run_rt);
	BU_LIST_APPEND(&dgop->dgo_headRunRt.l, &run_rtp->l);
	run_rtp->fd = pipe_err[0];
	run_rtp->pid = pid;

	Tcl_CreateFileHandler(run_rtp->fd, TCL_READABLE,
			      dgo_rt_output_handler, (ClientData)run_rtp);
@


1.29
log
@*- added new method: report - same as MGED's x
*- mods to dgo_eraseobj and dgo_eraseobjall
   to work on an array of directory pointers
*- new procedure, dgo_eraseobjpath, to build
   an array of directory pointers from it's argv
@
text
@d246 1
a246 1
		bu_vls_printf(&vls, "helplib dg_open");
d1515 1
a1515 1
		bu_vls_printf(&vls, "helplib dg_observer");
d1538 1
a1538 1
	if (argc < 1 || 2 < argc) {
d1542 1
a1542 1
		bu_vls_printf(&vls, "helplib dg_report");
d1548 2
a1549 2
	if (argc > 1)
		lvl = atoi(argv[1]);
@


1.28
log
@*- alphabetize command list
@
text
@d86 1
d95 1
d106 1
d126 1
a385 20
#if 0
		if (*argv[2] == *sp->s_path[0]->d_namep &&
		    strcmp(argv[2], sp->s_path[0]->d_namep) == 0) {
			found = 1;
			if (illum)
				sp->s_iflag = UP;
			else
				sp->s_iflag = DOWN;
			FOR_REST_OF_SOLIDS(forw, sp, &dgop->dgo_headSolid){
				if (forw->s_path[0] == sp->s_path[0]) {
					if (illum)
						forw->s_iflag = UP;
					else
						forw->s_iflag = DOWN;
				}
			}

			break;
		}
#else
a393 14
#if 0
				if (i < sp->s_last) {
					FOR_REST_OF_SOLIDS(forw, sp, &dgop->dgo_headSolid){
						if (forw->s_path[i] == sp->s_path[i]) {
							if (illum)
								forw->s_iflag = UP;
							else
								forw->s_iflag = DOWN;
						}
					}
				}

				break;
#endif
a395 1
#endif
d456 1
a456 6
	for (i = 0; i < argc; i++) {
		if ((dp = db_lookup(dgop->dgo_wdbp->dbip,  argv[i], LOOKUP_QUIET)) != DIR_NULL) {
			dgo_eraseobj(dgop, interp, dp);
		}
	}

a501 16
static void
dgo_erase(dgop, interp, argc, argv)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	register struct directory *dp;
	register int i;

	for (i = 0; i < argc; i++) {
		if ((dp = db_lookup(dgop->dgo_wdbp->dbip,  argv[i], LOOKUP_NOISY)) != DIR_NULL)
			dgo_eraseobj(dgop, interp, dp);
	}
}

d529 1
a529 1
	dgo_erase(dgop, interp, argc-2, argv+2);
a534 16
static void
dgo_erase_all(dgop, interp, argc, argv)
     struct dg_obj *dgop;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
{
	register struct directory *dp;
	register int i;

	for (i = 0; i < argc; i++) {
		if ((dp = db_lookup(dgop->dgo_wdbp->dbip,  argv[i], LOOKUP_NOISY)) != DIR_NULL)
			dgo_eraseobjall(dgop, interp, dp);
	}
}

d559 1
a559 1
	dgo_erase_all(dgop, interp, argc-2, argv+2);
d1525 30
d2182 1
d2199 2
a2200 1
		dgo_eraseobjall(dgop, interp, dp);
d2422 2
a2423 1
	struct dg_obj *dgop;
d2425 1
d2429 1
a2429 1
			dgo_eraseobjall(dgop, interp, dp);
d2435 71
d2508 2
a2509 2
 * This routine goes through the solid table and deletes all displays
 * which contain the specified object in their 'path'
d2512 1
a2512 1
dgo_eraseobjall(dgop, interp, dp)
d2515 1
a2515 1
     register struct directory *dp;
d2517 7
a2523 14
  register struct solid *sp;
  static struct solid *nsp;
  register int i;

  if(dgop->dgo_wdbp->dbip == DBI_NULL)
    return;

  RT_CK_DIR(dp);
  sp = BU_LIST_NEXT(solid, &dgop->dgo_headSolid);
  while (BU_LIST_NOT_HEAD(sp, &dgop->dgo_headSolid)) {
	  nsp = BU_LIST_PNEXT(solid, sp);
	  for (i=0; i<=sp->s_last; i++) {
		  if (sp->s_path[i] != dp)
			  continue;
d2525 2
a2526 2
		  BU_LIST_DEQUEUE(&sp->l);
		  FREE_SOLID(sp, &FreeSolid.l);
d2528 26
a2553 4
		  break;
	  }
	  sp = nsp;
  }
d2555 5
a2559 5
  if (dp->d_addr == RT_DIR_PHONY_ADDR) {
    if (db_dirdelete(dgop->dgo_wdbp->dbip, dp) < 0) {
	    Tcl_AppendResult(interp, "dgo_eraseobjall: db_dirdelete failed\n", (char *)NULL);
    }
  }
d2562 7
d2570 1
a2570 1
dgo_eraseobj(dgop, interp, dp)
d2573 1
a2573 1
     register struct directory *dp;
d2575 1
d2578 1
d2583 5
a2587 1
	RT_CK_DIR(dp);
d2592 8
a2599 4
		if (*sp->s_path != dp) {
			sp = nsp;
			continue;
		}
d2603 1
d2607 2
a2608 2
	if (dp->d_addr == RT_DIR_PHONY_ADDR ) {
		if (db_dirdelete(dgop->dgo_wdbp->dbip, dp) < 0)  {
d2951 95
@


1.27
log
@
raytrace.h shouldn't always include MGED's solid.h header!!!
Changed the dgo struct so it doesn't need to.
@
text
@a113 1
	"ev",			dgo_draw_tcl,
d116 1
d121 1
a130 1
	"observer",		dgo_observer_tcl,
d838 1
a838 1
	bu_vls_printf(&vls, "center {%g %g %g} scale %g", V3ARGS(center), radial[X]);
@


1.26
log
@
Removed unnecessary UNIX include files
@
text
@d271 1
a271 1
	BU_LIST_INIT(&dgop->dgo_headSolid.l);
d378 1
a378 1
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid.l) {
d390 1
a390 1
			FOR_REST_OF_SOLIDS(forw, sp, &dgop->dgo_headSolid.l){
d412 1
a412 1
					FOR_REST_OF_SOLIDS(forw, sp, &dgop->dgo_headSolid.l){
d465 2
d688 1
a688 1
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid.l)
d690 1
a690 1
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid.l) {
d702 1
a702 1
		FOR_REST_OF_SOLIDS(forw, sp, &dgop->dgo_headSolid.l){
d707 1
a707 1
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid.l)
d814 1
a814 1
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid.l) {
d825 1
a825 1
	if (BU_LIST_IS_EMPTY(&dgop->dgo_headSolid.l)) {
d958 2
a959 2
	sp = BU_LIST_NEXT(solid, &dgop->dgo_headSolid.l);
	while (BU_LIST_NOT_HEAD(sp, &dgop->dgo_headSolid.l)) {
d1312 1
a1312 1
		FOR_ALL_SOLIDS(sp, &rtcp->dgop->dgo_headSolid.l)
d2265 1
a2265 1
	sp->s_dlist = BU_LIST_LAST(solid, &dgop->dgo_headSolid.l)->s_dlist + 1;
d2268 1
a2268 1
	BU_LIST_APPEND(dgop->dgo_headSolid.l.back, &sp->l);
d2369 1
a2369 1
		sp->s_dlist = BU_LIST_LAST(solid, &dgcdp->dgop->dgo_headSolid.l)->s_dlist + 1;
d2428 1
a2428 1
		BU_LIST_APPEND(dgcdp->dgop->dgo_headSolid.l.back, &sp->l);
d2437 1
a2437 1
		BU_LIST_APPEND(dgcdp->dgop->dgo_headSolid.l.back, &sp->l);
d2488 2
a2489 2
  sp = BU_LIST_NEXT(solid, &dgop->dgo_headSolid.l);
  while (BU_LIST_NOT_HEAD(sp, &dgop->dgo_headSolid.l)) {
d2524 2
a2525 2
	sp = BU_LIST_FIRST(solid, &dgop->dgo_headSolid.l);
	while (BU_LIST_NOT_HEAD(sp, &dgop->dgo_headSolid.l)) {
d2669 1
a2669 1
	FOR_ALL_SOLIDS (sp, &dgop->dgo_headSolid.l) {
d2674 1
a2674 1
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid.l) {
d2687 1
a2687 1
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid.l) {
d2755 1
a2755 1
	FOR_ALL_SOLIDS (sp, &dgop->dgo_headSolid.l) {
@


1.25
log
@*- new method: illum
*- stub for new method: label
*- remove illegal uses of s_iflag
@
text
@a32 1
#include <sys/errno.h>
@


1.24
log
@*- add dgo_zapall
@
text
@d69 2
d120 2
d317 1
a317 1
 * Returns: database objects headSolid.
d344 124
d651 2
a652 2
	if(argc < 2 || 3 < argc){
	  struct bu_vls vls;
d654 5
a658 5
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help dgo_who");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
d685 1
a685 1
	 *  Mark ones already done with s_iflag == UP
d688 17
a704 17
	  sp->s_iflag = DOWN;
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid.l)  {
	  register struct solid *forw;	/* XXX */

	  if( sp->s_iflag == UP )
	    continue;
	  if (sp->s_path[0]->d_addr == RT_DIR_PHONY_ADDR){
	    if (skip_phony) continue;
	  } else {
	    if (skip_real) continue;
	  }
	  Tcl_AppendResult(interp, sp->s_path[0]->d_namep, " ", (char *)NULL);
	  sp->s_iflag = UP;
	  FOR_REST_OF_SOLIDS(forw, sp, &dgop->dgo_headSolid.l){
	    if( forw->s_path[0] == sp->s_path[0] )
	      forw->s_iflag = UP;
	  }
d707 1
a707 1
		sp->s_iflag = DOWN;
d1312 1
a1312 1
			sp->s_iflag = DOWN;
d2024 5
d2399 11
a2409 9
			  if (tsp->ts_mater.ma_color_valid) {
			    sp->s_dflag = 0;	/* color specified in db */
			  } else {
			    sp->s_dflag = 1;	/* default color */
			  }
			  /* Copy into basecolor anyway, to prevent black */
			  sp->s_basecolor[0] = tsp->ts_mater.ma_color[0] * 255.;
			  sp->s_basecolor[1] = tsp->ts_mater.ma_color[1] * 255.;
			  sp->s_basecolor[2] = tsp->ts_mater.ma_color[2] * 255.;
d2413 1
d2424 5
d2431 1
d2440 1
a2440 1
		sp->s_iflag = UP;
d2442 1
d2613 1
a2613 1
	 *  Mark ones already done with s_iflag == UP
d2616 1
a2616 1
		sp->s_iflag = DOWN;
d2620 1
a2620 1
		if (sp->s_iflag == UP)
d2631 1
a2631 1
		sp->s_iflag = UP;
d2634 1
a2634 1
				forw->s_iflag = UP;
@


1.23
log
@*- Add commands:
	observer, assoc
*- mods to allow a drawable geometry object that's not
   associated with a database
@
text
@d1397 4
a1400 1
		Tcl_AppendResult(interp, bu_vls_addr(&dgop->dgo_wdbp->wdb_name), (char *)NULL);
d1412 1
a1412 6
		if (BU_LIST_IS_HEAD(wdbp, &rt_g.rtg_headwdb.l)) {
#if 0
			Tcl_AppendResult(interp, "dgo_open: bad database object - ", argv[2],
					 "\n", (char *)NULL);
			return TCL_ERROR;
#else
a1413 2
#endif
		}
d2721 14
@


1.22
log
@
Fixed warning messages
@
text
@d48 7
d79 1
d84 1
d102 1
a102 1
static void dgo_callback();
d108 1
d127 1
d172 3
d252 1
d256 3
d270 1
d385 2
d404 1
a404 1
	dgo_callback(dgop, interp);
d442 2
d453 1
a453 1
	dgo_callback(dgop, interp);
d488 2
d499 1
a499 1
	dgo_callback(dgop, interp);
d521 2
d624 2
d656 1
a656 1
	dgo_callback(dgop, interp);
d680 2
d732 2
d813 4
d859 2
d872 1
a872 1
	dgo_callback(dgop, interp);
d890 2
d908 1
a908 1
	dgo_callback(dgop, interp);
d936 2
d1256 2
d1378 90
d2322 1
a2322 1
		if (dgop->dgo_wdbp->dbip == dbip)
d2324 2
d2707 1
a2707 1
dgo_callback(dgop, interp)
d2711 9
a2719 1
	struct bu_vls vls;
d2721 6
a2726 5
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "catch {dgo_callback %s}", bu_vls_addr(&dgop->dgo_name));
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	Tcl_ResetResult(interp);
@


1.21
log
@*- catch the callback
@
text
@d1171 1
a1171 1
	int fd = (int)clientData;
d2424 1
a2424 1
	int fd = (int)clientData;
@


1.20
log
@Eliminnated some unused variables
@
text
@d2577 1
a2577 1
	bu_vls_printf(&vls, "dgo_callback %s", bu_vls_addr(&dgop->dgo_name));
@


1.19
log
@*- added callback
@
text
@a328 1
	struct rt_wdb *wdbp;
a699 4
	int retcode;
	char *dm;
	char	pstring[32];
	struct bu_vls cmd;
d764 1
a764 1
	retcode = dgo_run_rt(dgop, vop);
a779 2
	struct dg_obj *dgop = (struct dg_obj *)clientData;

a789 1
	register struct dm_list *dmlp;
a849 1
	int kind = 1;	    /* wireframe */
a1204 1
	int	retcode;
a1808 1
				char		buf[128];
a1921 1
	char		*av[2];
a1955 2
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
a2089 2
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
a2468 1
	vect_t  unit_H, unit_V;
a2519 1
	register struct solid *sp;
a2520 2
	int pid, rpid;
	int retcode;
a2523 2
	char line[RT_MAXLINE];
	struct bu_vls vls;
d2529 1
a2529 1
	if ((pid = fork()) == 0) {
@


1.18
log
@*- moved tol command to the database object
@
text
@d93 2
d384 1
d431 1
d475 1
d628 1
d841 1
d876 1
d2589 14
@


1.17
log
@*- got rid of global variables
@
text
@d72 1
d74 1
d109 1
d111 1
d251 1
d268 1
d873 1
d1073 1
d1858 1
a1858 1
			&dgop->dgo_initial_tree_state,
d1871 1
a1871 1
		dgop->dgo_initial_tree_state.ts_m = &dgo_nmg_model;
d1879 1
a1879 1
				   &dgop->dgo_initial_tree_state,
@


1.16
log
@*- add client_data to db_walk_tree
@
text
@a54 5
/* found in librt/nmg_plot.c */
extern void (*nmg_plot_anim_upcall)();
extern void (*nmg_vlblock_anim_upcall)();
extern void (*nmg_mged_debug_display_hack)();

a74 3
static void dgo_plot_anim_upcall_handler();
static void dgo_vlblock_anim_upcall_handler();
static void dgo_nmg_debug_display_hack();
a90 18
/*XXXXXXXXXXXXX possibly need to get rid of these globals */
static int dgo_draw_nmg_only;
static int dgo_nmg_triangulate;
static int dgo_draw_wireframes;
static int dgo_draw_normals;
static int dgo_draw_solid_lines_only=0;
static int dgo_draw_no_surfaces = 0;
static int dgo_shade_per_vertex_normals=0;
static int dgo_wireframe_color_override;
static int dgo_wireframe_color[3];
static struct model	*dgo_nmg_model;

static int dgo_do_not_draw_nmg_solids_during_debugging = 0;
static int dgo_draw_edge_uses=0;
static int dgo_enable_fastpath = 0;
static int dgo_fastpath_count=0;	/* statistics */
static struct bn_vlblock	*dgo_draw_edge_uses_vbp;

a91 4
static struct dg_obj *curr_dgop;	/* current drawable geometry object */
static Tcl_Interp *curr_interp;		/* current Tcl interpreter */
static struct db_i *curr_dbip;		/* current database instance pointer */
static struct solid *curr_hsp;		/* current head solid pointer */
a324 5
	curr_dgop = dgop;
	curr_interp = interp;
	curr_dbip = dgop->dgo_wdbp->dbip;
	curr_hsp = &dgop->dgo_headSolid;

d333 1
a333 1
		if ((dp = db_lookup(curr_dbip,  argv[i], LOOKUP_QUIET)) != DIR_NULL) {
d338 1
a338 1
	dgo_drawtrees(argc, argv, kind);
a615 4
	curr_dgop = dgop;
	curr_interp = interp;
	curr_dbip = dgop->dgo_wdbp->dbip;
	curr_hsp = &dgop->dgo_headSolid;
a774 5
	curr_dgop = dgop;
	curr_interp = interp;
	curr_dbip = dgop->dgo_wdbp->dbip;
	curr_hsp = &dgop->dgo_headSolid;

d1329 17
a1345 35
/*
 */
static void
dgo_plot_anim_upcall_handler(file, us)
     char *file;
     long us;		/* microseconds of extra delay */
{
	char *av[3];

#if 0
	/* Overlay plot file */
	av[0] = "overlay";
	av[1] = file;
	av[2] = NULL;
	(void)dgo_overlay((ClientData)NULL, interp, 2, av);
#endif
}

/*
 */
static void
dgo_vlblock_anim_upcall_handler(vbp, us, copy)
     struct bn_vlblock *vbp;
     long us; /* microseconds of extra delay */
     int copy;
{
	dgo_cvt_vlblock_to_solids(curr_dgop, curr_interp, vbp, "_PLOT_OVERLAY_", copy);
}

/*
 */
static void
dgo_nmg_debug_display_hack()
{
}
d1350 3
a1352 3
     struct db_full_path	*pathp;
     union tree		*curtree;
     genptr_t			client_data;
d1374 1
d1384 1
a1384 1
		Tcl_AppendResult(curr_interp, "dgo_wireframe_leaf(", rt_functab[id].ft_name,
d1389 1
a1389 1
	if (dgo_draw_solid_lines_only)
d1395 2
a1396 2
	if (rt_functab[id].ft_import(&intern, ep, tsp->ts_mat, curr_dbip) < 0) {
		Tcl_AppendResult(curr_interp, DB_FULL_PATH_CUR_DIR(pathp)->d_namep,
d1409 1
a1409 1
		Tcl_AppendResult(curr_interp, DB_FULL_PATH_CUR_DIR(pathp)->d_namep,
d1429 1
a1429 1
		dgo_drawH_part2(dashflag, &vhead, pathp, tsp, SOLID_NULL);
d1434 1
a1434 1
		dgo_drawH_part2(dashflag, &vhead, pathp, tsp, SOLID_NULL);
d1461 4
a1464 4
     struct db_tree_state	*tsp;
     struct db_full_path	*pathp;
     CONST struct rt_comb_internal *combp;
     genptr_t			client_data;
d1472 1
d1528 1
a1528 1
			if (dgo_draw_wireframes) {
d1577 1
a1577 1
	dgo_drawH_part2(0, &vhead, pathp, tsp, SOLID_NULL);
d1580 1
a1580 1
	dgo_fastpath_count++;
d1590 1
a1590 1
dgo_nmg_region_end( tsp, pathp, curtree, client_data )
d1592 3
a1594 3
     struct db_full_path	*pathp;
     union tree		*curtree;
     genptr_t			client_data;
d1599 1
d1610 1
a1610 1
	  Tcl_AppendResult(curr_interp, "dgo_nmg_region_end() path='", sofar,
d1617 1
a1617 1
	if ( !dgo_draw_nmg_only ) {
d1624 1
a1624 1
			Tcl_AppendResult(curr_interp, "WARNING: Boolean evaluation of ", sofar,
d1640 1
a1640 1
	  Tcl_AppendResult(curr_interp, "Cannot use '-d' option when Boolean evaluation is required\n", (char *)NULL);
d1647 1
a1647 1
	if( dgo_do_not_draw_nmg_solids_during_debugging && r )  {
d1652 2
a1653 3
	if (dgo_nmg_triangulate) {
		if( BU_SETJUMP )
		{
d1658 1
a1658 1
			Tcl_AppendResult(curr_interp, "WARNING: Triangulation of ", sofar,
d1674 1
a1674 1
		if( dgo_draw_wireframes )  {
d1681 1
a1681 1
		if( dgo_draw_normals )  {
d1684 1
a1684 1
		if( dgo_shade_per_vertex_normals )  {
d1687 1
a1687 1
		if( dgo_draw_no_surfaces )  {
d1690 1
a1690 1
		nmg_r_to_vlist( &vhead, r, style );
d1692 1
a1692 1
		dgo_drawH_part2(0, &vhead, pathp, tsp, SOLID_NULL );
d1694 2
a1695 2
		if( dgo_draw_edge_uses )  {
			nmg_vlblock_r(dgo_draw_edge_uses_vbp, r, 1);
d1723 3
a1725 1
dgo_drawtrees(argc, argv, kind)
d1732 1
a1732 1
	int		ncpu;
d1734 3
d1738 1
a1738 4
	if (curr_dbip == DBI_NULL)
		return 0;

	RT_CHECK_DBI(curr_dbip);
d1743 4
d1748 11
a1758 11
	ncpu = 1;
	dgo_draw_nmg_only = 0;	/* no booleans */
	dgo_nmg_triangulate = 1;
	dgo_draw_wireframes = 0;
	dgo_draw_normals = 0;
	dgo_draw_edge_uses = 0;
	dgo_draw_solid_lines_only = 0;
	dgo_shade_per_vertex_normals = 0;
	dgo_draw_no_surfaces = 0;
	dgo_wireframe_color_override = 0;
	dgo_fastpath_count = 0;
d1766 1
a1766 1
			dgo_draw_edge_uses = 1;
d1769 1
a1769 1
			dgo_draw_solid_lines_only = 1;
d1775 1
a1775 1
			dgo_shade_per_vertex_normals = 1;
d1778 1
a1778 1
			dgo_draw_wireframes = 1;
d1781 1
a1781 1
			dgo_draw_no_surfaces = 1;
d1784 1
a1784 1
			dgo_nmg_triangulate = 0;
d1787 1
a1787 1
			dgo_draw_normals = 1;
d1793 1
a1793 1
			dgo_do_not_draw_nmg_solids_during_debugging = 1;
d1796 1
a1796 1
			dgo_draw_nmg_only = 1;
d1819 4
a1822 4
				dgo_wireframe_color_override = 1;
				dgo_wireframe_color[0] = r;
				dgo_wireframe_color[1] = g;
				dgo_wireframe_color[2] = b;
d1831 1
a1831 1
				Tcl_Eval(curr_interp, bu_vls_addr(&vls));
d1833 1
a1841 5
	/* Establish upcall interfaces for use by bottom of NMG library */
	nmg_plot_anim_upcall = dgo_plot_anim_upcall_handler;
	nmg_vlblock_anim_upcall = dgo_vlblock_anim_upcall_handler;
	nmg_mged_debug_display_hack = dgo_nmg_debug_display_hack;

d1844 2
a1845 1
	  Tcl_AppendResult(curr_interp, "ERROR, bad kind\n", (char *)NULL);
d1848 1
a1848 1
		ret = db_walk_tree(curr_dbip, argc, (CONST char **)argv,
d1850 1
a1850 1
			&curr_dgop->dgo_initial_tree_state,
d1853 1
a1853 1
			dgo_wireframe_leaf, (genptr_t)NULL);
d1856 2
a1857 1
		Tcl_AppendResult(curr_interp, "drawtrees:  can't do big-E here\n", (char *)NULL);
d1863 4
a1866 4
		curr_dgop->dgo_initial_tree_state.ts_m = &dgo_nmg_model;
	  	if (dgo_draw_edge_uses) {
		  Tcl_AppendResult(curr_interp, "Doing the edgeuse thang (-u)\n", (char *)NULL);
		  dgo_draw_edge_uses_vbp = rt_vlblock_init();
d1869 1
a1869 1
		ret = db_walk_tree(curr_dbip, argc, (CONST char **)argv,
d1871 1
a1871 1
				   &curr_dgop->dgo_initial_tree_state,
d1875 1
a1875 1
				   (genptr_t)NULL);
d1877 5
a1881 5
	  	if (dgo_draw_edge_uses) {
	  		dgo_cvt_vlblock_to_solids(curr_dbip, curr_interp,
						  dgo_draw_edge_uses_vbp, "_EDGEUSES_", 0);
	  		rt_vlblock_free(dgo_draw_edge_uses_vbp);
			dgo_draw_edge_uses_vbp = (struct bn_vlblock *)NULL;
d1889 1
a1889 1
	if (dgo_fastpath_count) {
d1891 1
a1891 1
		       dgo_fastpath_count, dgo_fastpath_count==1?"":"s");
d1894 2
a1921 7
#if 0
	/* Remove any residue colors from a previous overlay w/same name */
	av[0] = shortname;
	av[1] = NULL;
	dgo_erase(dgop, interp, 1, av);
#endif

d1985 1
a1985 1
	dgo_bound_solid(sp);
d2012 2
a2013 1
dgo_bound_solid(sp)
d2052 1
a2052 1
					Tcl_AppendResult(curr_interp, bu_vls_addr(&tmp_vls), (char *)NULL);
d2078 7
a2084 6
dgo_drawH_part2(dashflag, vhead, pathp, tsp, existing_sp)
int			dashflag;
struct bu_list		*vhead;
struct db_full_path	*pathp;
struct db_tree_state	*tsp;
struct solid		*existing_sp;
d2095 1
a2095 1
		  Tcl_AppendResult(curr_interp, "drawH_part2: path too long, solid ignored.\n\t",
d2104 1
a2104 1
		sp->s_dlist = BU_LIST_LAST(solid, &curr_hsp->l)->s_dlist + 1;
d2117 1
a2117 1
	dgo_bound_solid(sp);
d2125 1
a2125 1
		if (dgo_wireframe_color_override) {
d2129 3
a2131 3
			sp->s_basecolor[0] = dgo_wireframe_color[0];
			sp->s_basecolor[1] = dgo_wireframe_color[1];
			sp->s_basecolor[2] = dgo_wireframe_color[2];
d2163 1
a2163 1
		BU_LIST_APPEND(curr_hsp->l.back, &sp->l);
@


1.15
log
@*- using new rtg_headwdb
@
text
@d1410 1
a1410 1
dgo_wireframe_region_end(tsp, pathp, curtree)
d1414 1
d1425 1
a1425 1
dgo_wireframe_leaf(tsp, pathp, ep, id)
d1428 1
a1428 1
     struct bu_external	*ep;
d1430 1
d1521 5
a1525 4
dgo_nmg_region_start(tsp, pathp, combp)
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
CONST struct rt_comb_internal *combp;
d1650 5
a1654 4
dgo_nmg_region_end( tsp, pathp, curtree )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
d1910 1
a1910 1
			dgo_wireframe_leaf);
d1926 6
a1931 8
			ncpu,
			&curr_dgop->dgo_initial_tree_state,
			dgo_enable_fastpath ? dgo_nmg_region_start : 0,
			dgo_nmg_region_end,
	  		dgo_nmg_use_tnurbs ?
	  			nmg_booltree_leaf_tnurb :
				nmg_booltree_leaf_tess
			);
@


1.14
log
@change interp to rtcp->interp
@
text
@d256 1
a256 1
	for (BU_LIST_FOR(wdbp, rt_wdb, &HeadWDB.l)) {
d261 1
a261 1
	if (BU_LIST_IS_HEAD(wdbp, &HeadWDB.l)) {
@


1.13
log
@*- missing parameter in call to dgo_wait_status
@
text
@d1186 1
a1186 1
			dgo_wait_status(interp, retcode);
@


1.12
log
@*- cleaning
@
text
@d1186 1
a1186 1
			dgo_wait_status(retcode);
@


1.11
log
@*- just cleaning
@
text
@d99 1
d127 1
a140 1
	"close",		dgo_close_tcl,
@


1.10
log
@*- merged "struct wdb_obj" into "struct rt_wdb"
@
text
@a373 1

d906 2
@


1.9
log
@*- add drawable geometry object command: rtcheck
*- change getview to get_autoview
@
text
@d222 1
a222 1
 * database object "wdb_obj".
d225 1
a225 1
 *	  dgo_open [name wdb_obj]
d235 1
a235 1
	struct wdb_obj *wdbop;
d255 2
a256 2
	for (BU_LIST_FOR(wdbop, wdb_obj, &HeadWDBObj.l)) {
		if (strcmp(bu_vls_addr(&wdbop->wdb_name), argv[2]) == 0)
d260 1
a260 1
	if (BU_LIST_IS_HEAD(wdbop, &HeadWDBObj.l)) {
d272 1
a272 1
	dgop->dgo_wdbop = wdbop;
d350 1
a350 1
	struct wdb_obj *wdbop;
d356 1
a356 1
	curr_dbip = dgop->dgo_wdbop->wdb_wp->dbip;
d426 1
a426 1
		if ((dp = db_lookup(dgop->dgo_wdbop->wdb_wp->dbip,  argv[i], LOOKUP_NOISY)) != DIR_NULL)
d472 1
a472 1
		if ((dp = db_lookup(dgop->dgo_wdbop->wdb_wp->dbip,  argv[i], LOOKUP_NOISY)) != DIR_NULL)
d653 1
a653 1
	curr_dbip = dgop->dgo_wdbop->wdb_wp->dbip;
d773 1
a773 1
	*vp++ = dgop->dgo_wdbop->wdb_wp->dbip->dbi_filename;
d816 1
a816 1
	curr_dbip = dgop->dgo_wdbop->wdb_wp->dbip;
d837 1
a837 1
			if (db_dirdelete(dgop->dgo_wdbop->wdb_wp->dbip, dp) < 0) {
d1278 1
a1278 1
	*vp++ = dgop->dgo_wdbop->wdb_wp->dbip->dbi_filename;
d2012 1
a2012 1
	if (dgop->dgo_wdbop->wdb_wp->dbip == DBI_NULL)
d2015 1
a2015 1
	if ((dp = db_lookup(dgop->dgo_wdbop->wdb_wp->dbip, name, LOOKUP_QUIET)) != DIR_NULL) {
d2029 1
a2029 1
	dp = db_diradd(dgop->dgo_wdbop->wdb_wp->dbip,  name, RT_DIR_PHONY_ADDR, 0, DIR_SOLID, NULL);
d2242 1
a2242 1
		if (dgop->dgo_wdbop->wdb_wp->dbip == dbip)
d2262 1
a2262 1
  if(dgop->dgo_wdbop->wdb_wp->dbip == DBI_NULL)
d2282 1
a2282 1
    if (db_dirdelete(dgop->dgo_wdbop->wdb_wp->dbip, dp) < 0) {
d2297 1
a2297 1
	if(dgop->dgo_wdbop->wdb_wp->dbip == DBI_NULL)
d2316 1
a2316 1
		if (db_dirdelete(dgop->dgo_wdbop->wdb_wp->dbip, dp) < 0)  {
@


1.8
log
@*- add drawable geometry object commands: clear/zap, tol, blast
*- started the rtcheck command
@
text
@d74 1
a74 1
static int dgo_getview_tcl();
a77 1
#if 0
a78 1
#endif
d96 2
d130 1
a130 1
	"getview",		dgo_getview_tcl,
a133 1
#if 0
a134 1
#endif
d583 3
a585 1
dgo_overlay(fp, name, char_size)
d602 1
a602 1
	dgo_cvt_vlblock_to_solids(vbp, name, 0);
d655 1
a655 1
	dgo_overlay(fp, name, char_size);
d662 1
a662 1
 *        procname getview
d665 1
a665 1
dgo_getview_tcl(clientData, interp, argc, argv)
d777 1
a777 1
	 * have setup_rt() append the names of all stuff currently displayed.
d1109 100
d1210 14
d1246 2
d1276 1
a1276 1
	for( i=1; i < argc; i++ )
d1280 21
a1300 1
	setup_rt( vp, 1 );
d1309 1
a1309 1
		(void)dup( o_pipe[0] );
d1311 1
a1311 1
		(void)dup( i_pipe[1] );
d1313 1
a1313 1
		(void)dup( e_pipe[1] );
d1326 1
a1326 1
		(void)execvp( rt_cmd_vec[0], rt_cmd_vec );
d1333 8
a1340 4
	fp = fdopen(o_pipe[1], "w");
	{
		vect_t temp;
		vect_t eye_model;
a1341 4
		VSET( temp, 0.0, 0.0, 1.0 );
		MAT4X3PNT( eye_model, view_state->vs_view2model, temp );
		rt_write(fp, eye_model );
	}
d1355 4
a1358 2
	rtcp->vhead = rt_vlblock_find( rtcp->vbp, 0xFF, 0xFF, 0x00 );
	rtcp->csize = view_state->vs_Viewscale * 0.01;
d1362 1
a1362 1
			      rtcheck_vector_handler, (ClientData)rtcp);
d1364 1
a1364 1
			      rtcheck_output_handler, (ClientData)e_pipe[0]);
a1367 1
#endif
d1397 1
a1397 1
	dgo_cvt_vlblock_to_solids(vbp, "_PLOT_OVERLAY_", copy);
d1930 2
a1931 1
	  		dgo_cvt_vlblock_to_solids(dgo_draw_edge_uses_vbp, "_EDGEUSES_", 0);
d1957 6
a1962 4
dgo_cvt_vlblock_to_solids(vbp, name, copy)
struct bn_vlblock	*vbp;
char			*name;
int			copy;
d1971 2
d1976 2
a1977 1
	dgo_erase(curr_dgop, curr_interp, 1, av);
d1985 1
a1985 1
		dgo_invent_solid(namebuf, &vbp->head[i], vbp->rgb[i], copy);
d1999 3
a2001 1
dgo_invent_solid(name, vhead, rgb, copy)
d2012 1
a2012 1
	if (curr_dbip == DBI_NULL)
d2015 1
a2015 1
	if ((dp = db_lookup(curr_dbip, name, LOOKUP_QUIET)) != DIR_NULL) {
d2017 1
a2017 1
			Tcl_AppendResult(curr_interp, "dgo_invent_solid(", name,
d2026 1
a2026 1
		dgo_eraseobjall(curr_dgop, curr_interp, dp);
d2029 1
a2029 1
	dp = db_diradd(curr_dbip,  name, RT_DIR_PHONY_ADDR, 0, DIR_SOLID, NULL);
d2055 1
a2055 1
	sp->s_dlist = BU_LIST_LAST(solid, &curr_hsp->l)->s_dlist + 1;
d2058 1
a2058 1
	BU_LIST_APPEND(curr_hsp->l.back, &sp->l);
d2289 1
a2289 1
dgo_eraseobj(interp, dgop, dp)
a2622 5

#if 0
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid.l)
		sp->s_iflag = DOWN;
#endif
@


1.7
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d69 1
d75 6
a108 3
static struct db_tree_state	dgo_initial_tree_state;
static struct rt_tess_tol	dgo_ttol;
static struct bn_tol		dgo_tol;
d124 2
a125 1
	"headSolid",		dgo_headSolid_tcl,
d129 3
a132 2
	"getview",		dgo_getview_tcl,
	"who",			dgo_who_tcl,
a133 1
	"vdraw",		dgo_vdraw_tcl,
a134 3
	"B",			dgo_blast_tcl,
	"Z",			dgo_zap_tcl,
	"erase_all",		dgo_erase_all_tcl,
d136 1
d138 3
a140 1
#endif
a170 17
	/* initilize tolerance structures */
	dgo_ttol.magic = RT_TESS_TOL_MAGIC;
	dgo_ttol.abs = 0.0;		/* disabled */
	dgo_ttol.rel = 0.01;
	dgo_ttol.norm = 0.0;		/* disabled */

	dgo_tol.magic = BN_TOL_MAGIC;
	dgo_tol.dist = 0.005;
	dgo_tol.dist_sq = dgo_tol.dist * dgo_tol.dist;
	dgo_tol.perp = 1e-6;
	dgo_tol.para = 1 - dgo_tol.perp;

	/* initialize tree state */
	dgo_initial_tree_state = rt_initial_tree_state;  /* struct copy */
	dgo_initial_tree_state.ts_ttol = &dgo_ttol;
	dgo_initial_tree_state.ts_tol = &dgo_tol;

d278 17
d344 35
a393 5
	struct wdb_obj *wdbop;
	register struct directory *dp;
	register int i;
	struct bu_vls vls;
	int ret;
d397 2
d403 1
d412 1
a412 19
	curr_dgop = dgop;
	curr_interp = interp;
	curr_dbip = dgop->dgo_wdbop->wdb_wp->dbip;
	curr_hsp = &dgop->dgo_headSolid;

	argc -= 2;
	argv += 2;

	/*  First, delete any mention of these objects.
	 *  Silently skip any leading options (which start with minus signs).
	 */
	for (i = 0; i < argc; i++) {
		if ((dp = db_lookup(curr_dbip,  argv[i], LOOKUP_QUIET)) != DIR_NULL) {
			dgo_eraseobj(interp, dgop, dp);
		}
	}

	dgo_drawtrees(argc, argv, kind);
	dgo_color_soltab(&dgop->dgo_headSolid);
d429 1
a429 1
			dgo_eraseobj(interp, dgop, dp);
d447 1
d449 41
d491 1
d501 1
a501 1
	dgo_erase(dgop, interp, argc-2, argv+2);
d822 410
d1764 1
a1764 1
			&dgo_initial_tree_state,
d1776 1
a1776 1
		dgo_initial_tree_state.ts_m = &dgo_nmg_model;
d1784 1
a1784 1
			&dgo_initial_tree_state,
d1881 1
a1881 1
		dgo_eraseobjall(curr_interp, curr_dgop, dp);
d2088 2
a2089 1
dgo_eraseobjall_callback(interp, dbip, dp)
a2090 1
     struct db_i *dbip;
d2098 1
a2098 1
			dgo_eraseobjall(interp, dgop, dp);
d2108 2
a2109 1
dgo_eraseobjall(interp, dgop, dp)
a2110 1
     struct dg_obj *dgop;
d2145 1
a2146 1
     struct dg_obj *dgop;
@


1.6
log
@*- dgo_invent_solid no longer static
@
text
@d1411 1
a1411 1
	dp = db_diradd(curr_dbip,  name, RT_DIR_PHONY_ADDR, 0, DIR_SOLID);
@


1.5
log
@*- use static instead of HIDDEN
@
text
@d82 1
a82 1
static int dgo_invent_solid();
d89 2
a90 1
static dgo_run_rt();
d92 9
a100 9
static int		dgo_draw_nmg_only;
static int		dgo_nmg_triangulate;
static int		dgo_draw_wireframes;
static int		dgo_draw_normals;
static int		dgo_draw_solid_lines_only=0;
static int		dgo_draw_no_surfaces = 0;
static int		dgo_shade_per_vertex_normals=0;
static int		dgo_wireframe_color_override;
static int		dgo_wireframe_color[3];
d1382 1
a1382 1
static int
d1762 1
a1762 1
int
@


1.4
log
@*- change signature of dgo_eraseobjall_callback
*- add comments to dgo_eraseobjall_callback
@
text
@d63 23
a85 23
HIDDEN int dgo_open_tcl();
HIDDEN int dgo_close_tcl();
HIDDEN int dgo_cmd();
HIDDEN int dgo_headSolid_tcl();
HIDDEN int dgo_draw_tcl();
HIDDEN int dgo_erase_tcl();
HIDDEN int dgo_who_tcl();
HIDDEN int dgo_rt_tcl();
HIDDEN int dgo_vdraw_tcl();
HIDDEN int dgo_overlay_tcl();
HIDDEN int dgo_getview_tcl();

HIDDEN void dgo_plot_anim_upcall_handler();
HIDDEN void dgo_vlblock_anim_upcall_handler();
HIDDEN void dgo_nmg_debug_display_hack();
HIDDEN union tree *dgo_wireframe_region_end();
HIDDEN union tree *dgo_wireframe_leaf();
HIDDEN int dgo_drawtrees();
HIDDEN void dgo_cvt_vlblock_to_solids();
HIDDEN int dgo_invent_solid();
HIDDEN void dgo_bound_solid();
HIDDEN void dgo_drawH_part2();
HIDDEN void dgo_eraseobjall();
d87 23
a109 22
HIDDEN void dgo_eraseobj();
HIDDEN void dgo_color_soltab();

HIDDEN int		dgo_draw_nmg_only;
HIDDEN int		dgo_nmg_triangulate;
HIDDEN int		dgo_draw_wireframes;
HIDDEN int		dgo_draw_normals;
HIDDEN int		dgo_draw_solid_lines_only=0;
HIDDEN int		dgo_draw_no_surfaces = 0;
HIDDEN int		dgo_shade_per_vertex_normals=0;
HIDDEN int		dgo_wireframe_color_override;
HIDDEN int		dgo_wireframe_color[3];
HIDDEN struct model	*dgo_nmg_model;
HIDDEN struct db_tree_state	dgo_initial_tree_state;
HIDDEN struct rt_tess_tol	dgo_ttol;
HIDDEN struct bn_tol		dgo_tol;

HIDDEN int dgo_do_not_draw_nmg_solids_during_debugging = 0;
HIDDEN int dgo_draw_edge_uses=0;
HIDDEN int dgo_enable_fastpath = 0;
HIDDEN int dgo_fastpath_count=0;	/* statistics */
HIDDEN struct bn_vlblock	*dgo_draw_edge_uses_vbp;
d112 5
a116 5
HIDDEN struct dg_obj *curr_dgop;	/* current drawable geometry object */
HIDDEN Tcl_Interp *curr_interp;		/* current Tcl interpreter */
HIDDEN struct db_i *curr_dbip;		/* current database instance pointer */
HIDDEN struct solid *curr_hsp;		/* current head solid pointer */
HIDDEN struct solid FreeSolid;		/* head of free solid list */
d118 1
a118 1
HIDDEN struct bu_cmdtab dgo_cmds[] = {
d148 1
a148 1
HIDDEN int
d191 1
a191 1
HIDDEN void
d209 1
a209 1
HIDDEN int
d240 1
a240 1
HIDDEN int
d313 1
a313 1
HIDDEN int
d345 1
a345 1
HIDDEN int
d396 1
a396 1
HIDDEN void
d419 1
a419 1
HIDDEN int
d448 1
a448 1
HIDDEN int
d520 1
a520 1
HIDDEN void
d546 1
a546 1
HIDDEN int
d600 1
a600 1
HIDDEN int
d653 1
a653 1
HIDDEN int
d741 1
a741 1
HIDDEN int
d762 1
a762 1
HIDDEN void
d780 1
a780 1
HIDDEN void
d791 1
a791 1
HIDDEN void
d796 1
a796 1
HIDDEN union tree *
d810 1
a810 1
HIDDEN union tree *
d1033 1
a1033 1
HIDDEN union tree *
d1165 1
a1165 1
HIDDEN int
d1344 1
a1344 1
HIDDEN void
d1381 1
a1381 1
HIDDEN int
d1449 1
a1449 1
HIDDEN void
d1514 1
a1514 1
HIDDEN void
d1633 1
a1633 1
HIDDEN void
d1669 1
a1669 1
HIDDEN void
d1709 1
a1709 1
HIDDEN void
d1809 1
a1809 1
HIDDEN void
d1855 1
a1855 1
HIDDEN void
d1883 1
a1883 1
HIDDEN void
d1952 1
a1952 1
HIDDEN int
@


1.3
log
@*- added dgo_eraseobjall_callback
@
text
@d1607 2
d1613 1
a1613 1
dgo_eraseobjall_callback(interp, wdbop, dp)
d1615 1
a1615 1
     struct wdb_obj *wdbop;
d1621 2
a1622 1
		if (dgop->dgo_wdbop == wdbop)
@


1.2
log
@*- create list of potential commands
@
text
@d86 1
d1607 17
d1629 1
a1629 1
void
d1693 1
a1693 1
		if( db_dirdelete(dgop->dgo_wdbop->wdb_wp->dbip, dp) < 0 ){
@


1.1
log
@Drawable Geometry Object
@
text
@d126 7
@

