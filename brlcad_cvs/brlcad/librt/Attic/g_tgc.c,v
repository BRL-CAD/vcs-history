head	11.45;
access;
symbols
	ansi-20040405-merged:11.38.2.2
	postmerge-20040405-ansi:11.43
	premerge-20040404-ansi:11.42
	postmerge-autoconf:11.42
	autoconf-freeze:11.41.6.2
	premerge-autoconf:11.42
	ansi-20040316-freeze:11.38.2.1
	postmerge-20040315-windows:11.42
	premerge-20040315-windows:11.42
	windows-20040315-freeze:11.38.4.1
	autoconf-20031203:11.41
	autoconf-20031202:11.41
	autoconf-branch:11.41.0.6
	phong-branch:11.41.0.4
	photonmap-branch:11.41.0.2
	rel-6-1-DP:11.38
	windows-branch:11.38.0.4
	rel-6-0-2:11.36
	ansi-branch:11.38.0.2
	rel-6-0-1-branch:11.36.0.2
	hartley-6-0-post:11.37
	hartley-6-0-pre:11.36
	rel-6-0-1:11.36
	rel-6-0:11.36
	rel-5-4:11.22.2.1
	offsite-5-3-pre:11.31
	rel-5-3:11.22.2.1
	rel-5-2:11.22
	rel-5-1-branch:11.22.0.2
	rel-5-1:11.22
	rel-5-0:11.16
	rel-5-0-beta:11.14
	rel-4-5:11.13
	ctj-4-5-post:11.13
	ctj-4-5-pre:11.13
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.45
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.44;

11.44
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.43;

11.43
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.42;

11.42
date	2004.02.02.17.39.21;	author morrison;	state Exp;
branches;
next	11.41;

11.41
date	2003.04.11.13.28.49;	author jra;	state Exp;
branches
	11.41.6.1;
next	11.40;

11.40
date	2003.04.10.13.57.08;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	2002.12.19.15.33.16;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	2002.08.20.17.08.01;	author jra;	state Exp;
branches
	11.38.2.1
	11.38.4.1;
next	11.37;

11.37
date	2002.08.15.20.55.13;	author hartley;	state Exp;
branches;
next	11.36;

11.36
date	2002.03.13.21.45.44;	author morrison;	state Exp;
branches;
next	11.35;

11.35
date	2001.10.02.19.24.30;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	2001.09.18.15.27.56;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	2001.04.20.22.29.47;	author morrison;	state Exp;
branches;
next	11.32;

11.32
date	2001.03.31.01.57.09;	author morrison;	state Exp;
branches;
next	11.31;

11.31
date	2000.10.19.16.08.39;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	2000.10.18.18.10.35;	author butler;	state Exp;
branches;
next	11.29;

11.29
date	2000.08.22.20.36.56;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.08.21.02.02.31;	author butler;	state Exp;
branches;
next	11.27;

11.27
date	2000.07.10.23.01.36;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.06.30.15.38.04;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.06.30.15.31.15;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.06.27.15.33.31;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	2000.06.26.19.45.27;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	2000.04.12.02.34.36;	author mike;	state Exp;
branches
	11.22.2.1;
next	11.21;

11.21
date	99.12.22.02.18.00;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	99.11.26.21.46.49;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.11.24.23.12.09;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	99.11.17.02.42.03;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	99.11.11.00.54.29;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	99.07.23.21.01.14;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	99.07.02.22.19.24;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	99.05.27.19.10.43;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.06.17.19.23.46;	author gdurf;	state Exp;
branches;
next	11.12;

11.12
date	96.10.21.19.11.33;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	96.09.30.16.02.24;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	96.08.31.10.52.55;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.08.27.06.34.07;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	96.07.12.12.10.21;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	96.05.16.21.47.54;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.12.04.21.12.08;	author stay;	state Exp;
branches;
next	11.5;

11.5
date	95.12.02.03.20.39;	author stay;	state Exp;
branches;
next	11.4;

11.4
date	95.12.01.02.47.38;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.11.30.23.01.02;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.11.30.04.07.38;	author stay;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.03;	author mike;	state Rel4_4;
branches;
next	10.11;

10.11
date	94.12.27.17.14.40;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.09.30.16.25.02;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.09.13.15.58.11;	author jra;	state Exp;
branches;
next	10.8;

10.8
date	94.09.12.10.49.44;	author jra;	state Exp;
branches;
next	10.7;

10.7
date	94.09.10.23.05.22;	author jra;	state Exp;
branches;
next	10.6;

10.6
date	94.09.09.16.49.47;	author jra;	state Exp;
branches;
next	10.5;

10.5
date	94.08.10.18.39.32;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.05.06.03.34.26;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.04.21.07.15.58;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.11.18.01.44.11;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.24;	author mike;	state Rel4_0;
branches;
next	9.39;

9.39
date	91.09.20.23.29.03;	author butler;	state Exp;
branches;
next	9.38;

9.38
date	91.07.11.15.36.19;	author jehunt;	state Exp;
branches;
next	9.37;

9.37
date	91.06.30.00.10.59;	author mike;	state Exp;
branches;
next	9.36;

9.36
date	91.06.22.22.30.40;	author mike;	state Exp;
branches;
next	9.35;

9.35
date	91.06.12.20.57.46;	author mike;	state Exp;
branches;
next	9.34;

9.34
date	91.05.18.03.01.34;	author mike;	state Exp;
branches;
next	9.33;

9.33
date	91.04.01.19.59.40;	author mike;	state Exp;
branches;
next	9.32;

9.32
date	91.03.13.16.43.15;	author mike;	state Exp;
branches;
next	9.31;

9.31
date	91.03.13.16.18.19;	author mike;	state Exp;
branches;
next	9.30;

9.30
date	91.03.11.23.09.14;	author mike;	state Exp;
branches;
next	9.29;

9.29
date	91.02.07.20.32.24;	author mike;	state Exp;
branches;
next	9.28;

9.28
date	91.01.28.23.53.20;	author mike;	state Exp;
branches;
next	9.27;

9.27
date	91.01.26.03.15.00;	author mike;	state Exp;
branches;
next	9.26;

9.26
date	91.01.26.02.01.35;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	91.01.25.21.52.15;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	91.01.25.21.19.19;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	91.01.25.20.36.11;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.01.15.23.44.14;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	91.01.15.21.02.34;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.01.15.01.34.03;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.01.14.23.47.37;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.01.14.23.27.58;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.01.11.07.12.11;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	90.12.07.00.43.57;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	90.11.01.06.55.40;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	90.10.15.12.01.04;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.10.06.02.05.24;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.05.18.07.25.43;	author butler;	state Exp;
branches;
next	9.11;

9.11
date	90.05.04.08.12.56;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.04.28.02.08.55;	author butler;	state Exp;
branches;
next	9.9;

9.9
date	90.03.15.01.58.42;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.03.14.22.37.03;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.03.14.21.20.56;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.03.14.15.06.03;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.03.05.23.57.49;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.02.28.01.53.25;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.02.27.23.30.07;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.20.00;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.32;	author mike;	state Rel3_5;
branches;
next	8.9;

8.9
date	89.04.17.17.19.56;	author mike;	state Exp;
branches;
next	8.8;

8.8
date	89.04.14.03.06.57;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.04.13.21.57.13;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.04.11.13.00.15;	author phil;	state Exp;
branches;
next	8.5;

8.5
date	89.04.11.12.15.36;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	88.12.15.01.26.04;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	88.12.14.01.46.58;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.02.45;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.31.51;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.05.14.00.01.22;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.06.05.37.06;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.34.29;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.56.46;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.12.42;	author mike;	state Rel;
branches;
next	4.7;

4.7
date	87.05.30.06.42.30;	author phil;	state Exp;
branches;
next	4.6;

4.6
date	87.04.28.00.28.00;	author phil;	state Exp;
branches;
next	4.5;

4.5
date	87.04.07.22.05.37;	author phil;	state Exp;
branches;
next	4.4;

4.4
date	87.03.23.23.41.09;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.03.10.23.43.13;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.12.22.12.06;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.46.10;	author mike;	state Rel1;
branches;
next	3.7;

3.7
date	86.12.24.08.06.21;	author mike;	state Exp;
branches;
next	3.6;

3.6
date	86.11.24.23.24.23;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.10.11.03.07.32;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.08.12.04.16.42;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.24.06.10.47;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.17.23.15.16;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.11.01.32.59;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.34.03;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	86.06.09.21.51.15;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.11.19.21.18.50;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.10.02.00.16.49;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.10.01.14.59;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.07.11;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	85.07.30.05.55.47;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	85.06.19.18.41.16;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	85.06.03.17.29.50;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	85.05.01.16.26.49;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	85.04.23.15.42.21;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	85.03.25.11.47.02;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	85.02.11.11.19.00;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	85.02.09.05.08.44;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	85.02.09.01.32.25;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	85.02.08.02.00.12;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	85.02.07.22.08.18;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	85.01.31.17.03.21;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	84.12.06.16.54.58;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	84.11.24.03.00.38;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	84.11.23.20.54.37;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	84.11.20.20.14.53;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	84.11.16.06.29.27;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	84.11.15.21.48.11;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	84.11.13.17.51.42;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	84.11.13.13.32.54;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	84.10.19.01.39.17;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	84.09.06.03.59.02;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.05.04.09.15.33;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.05.03.06.55.24;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.05.02.05.10.18;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.05.01.06.39.59;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.04.28.02.42.21;	author mike;	state Exp;
branches;
next	;

11.22.2.1
date	2000.10.19.16.08.01;	author bparker;	state Exp;
branches;
next	;

11.38.2.1
date	2002.09.19.18.01.37;	author morrison;	state Exp;
branches;
next	11.38.2.2;

11.38.2.2
date	2004.03.17.21.18.48;	author morrison;	state Exp;
branches;
next	;

11.38.4.1
date	2004.03.11.23.43.39;	author morrison;	state Exp;
branches;
next	;

11.41.6.1
date	2004.02.12.18.37.42;	author erikg;	state Exp;
branches;
next	11.41.6.2;

11.41.6.2
date	2004.03.15.14.07.22;	author erikg;	state Exp;
branches;
next	;


desc
@Shoot rays at Truncated General Cones
@


11.45
log
@moved to src/
@
text
@/*
 *			G _ T G C . C
 *
 * Purpose -
 *	Intersect a ray with a Truncated General Cone.
 *
 * Method -
 *	TGC:  solve quartic equation of cone and line
 *
 * Authors -
 *	Edwin O. Davisson	(Analysis)
 *	Jeff Hanes		(Programming)
 *	Gary Moss		(Improvement)
 *	Mike Muuss		(Optimization)
 *	Peter F. Stiller	(Curvature)
 *	Phillip Dykstra		(Curvature)
 *	Bill Homer		(Vectorization)
 *	Paul Stay		(Convert to tnurbs)
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCStgc[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_tgc.c,v 11.44 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"
#include "nurb.h" 
RT_EXTERN(int rt_rec_prep, (struct soltab *stp, struct rt_db_internal *ip,
struct rt_i *rtip));

struct  tgc_specific {
	vect_t	tgc_V;		/*  Vector to center of base of TGC	*/
	fastf_t	tgc_sH;		/*  magnitude of sheared H vector	*/
	fastf_t	tgc_A;		/*  magnitude of A vector		*/
	fastf_t	tgc_B;		/*  magnitude of B vector		*/
	fastf_t	tgc_C;		/*  magnitude of C vector		*/
	fastf_t	tgc_D;		/*  magnitude of D vector		*/
	fastf_t	tgc_CdAm1;	/*  (C/A - 1)				*/
	fastf_t tgc_DdBm1;	/*  (D/B - 1)				*/
	fastf_t	tgc_AAdCC;	/*  (|A|**2)/(|C|**2)			*/
	fastf_t	tgc_BBdDD;	/*  (|B|**2)/(|D|**2)			*/
	vect_t	tgc_N;		/*  normal at 'top' of cone		*/
	mat_t	tgc_ScShR;	/*  Scale( Shear( Rot( vect )))		*/
	mat_t	tgc_invRtShSc;	/*  invRot( trnShear( Scale( vect )))	*/
	char	tgc_AD_CB;	/*  boolean:  A*D == C*B  */
};


static void rt_tgc_rotate(fastf_t *A, fastf_t *B, fastf_t *Hv, fastf_t *Rot, fastf_t *Inv, struct tgc_specific *tgc);
static void rt_tgc_shear(const fastf_t *vect, int axis, fastf_t *Shr, fastf_t *Trn, fastf_t *Inv);
static void rt_tgc_scale(fastf_t a, fastf_t b, fastf_t h, fastf_t *Scl, fastf_t *Inv);
static void nmg_tgc_disk(struct faceuse *fu, fastf_t *rmat, fastf_t height, int flip);
static void nmg_tgc_nurb_cyl(struct faceuse *fu, fastf_t *top_mat, fastf_t *bot_mat);
void rt_pt_sort(register fastf_t *t, int npts);

#define VLARGE		1000000.0
#define	ALPHA(x,y,c,d)	( (x)*(x)*(c) + (y)*(y)*(d) )

const struct bu_structparse rt_tgc_parse[] = {
    { "%f", 3, "V", offsetof(struct rt_tgc_internal, v[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "H", offsetof(struct rt_tgc_internal, h[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "A", offsetof(struct rt_tgc_internal, a[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "B", offsetof(struct rt_tgc_internal, b[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "C", offsetof(struct rt_tgc_internal, c[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "D", offsetof(struct rt_tgc_internal, d[X]), BU_STRUCTPARSE_FUNC_NULL },
    { {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
};

/*
 *			R T _ T G C _ P R E P
 *
 *  Given the parameters (in vector form) of a truncated general cone,
 *  compute the constant terms and a transformation matrix needed for
 *  solving the intersection of a ray with the cone.
 *
 *  Also compute the return transformation for normals in the transformed
 *  space to the original space.  This NOT the inverse of the transformation
 *  matrix (if you really want to know why, talk to Ed Davisson).
 */
int
rt_tgc_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_tgc_internal	*tip;
	register struct tgc_specific *tgc;
	register fastf_t	f;
	LOCAL fastf_t	prod_ab, prod_cd;
	LOCAL fastf_t	magsq_a, magsq_b, magsq_c, magsq_d;
	LOCAL fastf_t	mag_h, mag_a, mag_b, mag_c, mag_d;
	LOCAL mat_t	Rot, Shr, Scl;
	LOCAL mat_t	iRot, tShr, iShr, iScl;
	LOCAL mat_t	tmp;
	LOCAL vect_t	nH;
	LOCAL vect_t	work;

	tip = (struct rt_tgc_internal *)ip->idb_ptr;
	RT_TGC_CK_MAGIC(tip);

	/*
	 *  For a fast way out, hand this solid off to the REC routine.
	 *  If it takes it, then there is nothing to do, otherwise
	 *  the solid is a TGC.
	 */
	if( rt_rec_prep( stp, ip, rtip ) == 0 )
		return(0);		/* OK */

	/* Validate that |H| > 0, compute |A| |B| |C| |D|		*/
	mag_h = sqrt( MAGSQ( tip->h ) );
	mag_a = sqrt( magsq_a = MAGSQ( tip->a ) );
	mag_b = sqrt( magsq_b = MAGSQ( tip->b ) );
	mag_c = sqrt( magsq_c = MAGSQ( tip->c ) );
	mag_d = sqrt( magsq_d = MAGSQ( tip->d ) );
	prod_ab = mag_a * mag_b;
	prod_cd = mag_c * mag_d;

	if( NEAR_ZERO( mag_h, RT_LEN_TOL ) ) {
		bu_log("tgc(%s):  zero length H vector\n", stp->st_name );
		return(1);		/* BAD */
	}

	/* Validate that figure is not two-dimensional			*/
	if( NEAR_ZERO( mag_a, RT_LEN_TOL ) &&
	    NEAR_ZERO( mag_c, RT_LEN_TOL ) ) {
		bu_log("tgc(%s):  vectors A, C zero length\n", stp->st_name );
		return (1);
	}
	if( NEAR_ZERO( mag_b, RT_LEN_TOL ) &&
	    NEAR_ZERO( mag_d, RT_LEN_TOL ) ) {
		bu_log("tgc(%s):  vectors B, D zero length\n", stp->st_name );
		return (1);
	}

	/* Validate that both ends are not degenerate */
	if( prod_ab <= SMALL )  {
		/* AB end is degenerate */
		if( prod_cd <= SMALL )  {
			bu_log("tgc(%s):  Both ends degenerate\n", stp->st_name);
			return(1);		/* BAD */
		}
		/* Exchange ends, so that in solids with one degenerate end,
		 * the CD end always is always the degenerate one
		 */
		VADD2( tip->v, tip->v, tip->h );
		VREVERSE( tip->h, tip->h );
#define VEXCHANGE( a, b, tmp )	{ VMOVE(tmp,a); VMOVE(a,b); VMOVE(b,tmp); }
		VEXCHANGE( tip->a, tip->c, work );
		VEXCHANGE( tip->b, tip->d, work );
		bu_log("NOTE: tgc(%s): degenerate end exchanged\n", stp->st_name);
	}

	/* Ascertain whether H lies in A-B plane 			*/
	VCROSS( work, tip->a, tip->b );
	f = VDOT( tip->h, work ) / ( prod_ab*mag_h );
	if ( NEAR_ZERO(f, RT_DOT_TOL) ) {
		bu_log("tgc(%s):  H lies in A-B plane\n",stp->st_name);
		return(1);		/* BAD */
	}

	if( prod_ab > SMALL )  {
		/* Validate that A.B == 0 */
		f = VDOT( tip->a, tip->b ) / prod_ab;
		if( ! NEAR_ZERO(f, RT_DOT_TOL) ) {
			bu_log("tgc(%s):  A not perpendicular to B, f=%g\n",
			    stp->st_name, f);
			bu_log("tgc: dot=%g / a*b=%g\n",
			    VDOT( tip->a, tip->b ),  prod_ab );
			return(1);		/* BAD */
		}
	}
	if( prod_cd > SMALL )  {
		/* Validate that C.D == 0 */
		f = VDOT( tip->c, tip->d ) / prod_cd;
		if( ! NEAR_ZERO(f, RT_DOT_TOL) ) {
			bu_log("tgc(%s):  C not perpendicular to D, f=%g\n",
			    stp->st_name, f);
			bu_log("tgc: dot=%g / c*d=%g\n",
			    VDOT( tip->c, tip->d ), prod_cd );
			return(1);		/* BAD */
		}
	}

	if( mag_a * mag_c > SMALL )  {
		/* Validate that  A || C */
		f = 1.0 - VDOT( tip->a, tip->c ) / (mag_a * mag_c);
		if( ! NEAR_ZERO(f, RT_DOT_TOL) ) {
			bu_log("tgc(%s):  A not parallel to C, f=%g\n",
			    stp->st_name, f);
			return(1);		/* BAD */
		}
	}

	if( mag_b * mag_d > SMALL )  {
		/* Validate that  B || D, for parallel planes	*/
		f = 1.0 - VDOT( tip->b, tip->d ) / (mag_b * mag_d);
		if( ! NEAR_ZERO(f, RT_DOT_TOL) ) {
			bu_log("tgc(%s):  B not parallel to D, f=%g\n",
			    stp->st_name, f);
			return(1);		/* BAD */
		}
	}

	/* solid is OK, compute constant terms, etc. */
	BU_GETSTRUCT( tgc, tgc_specific );
	stp->st_specific = (genptr_t)tgc;

	VMOVE( tgc->tgc_V, tip->v );
	tgc->tgc_A = mag_a;
	tgc->tgc_B = mag_b;
	tgc->tgc_C = mag_c;
	tgc->tgc_D = mag_d;

	/* Part of computing ALPHA() */
	if( NEAR_ZERO(magsq_c, SMALL) )
		tgc->tgc_AAdCC = VLARGE;
	else
		tgc->tgc_AAdCC = magsq_a / magsq_c;
	if( NEAR_ZERO(magsq_d, SMALL) )
		tgc->tgc_BBdDD = VLARGE;
	else
		tgc->tgc_BBdDD = magsq_b / magsq_d;

	/*  If the eccentricities of the two ellipses are the same,
	 *  then the cone equation reduces to a much simpler quadratic
	 *  form.  Otherwise it is a (gah!) quartic equation.
	 */
	f = rt_reldiff( (tgc->tgc_A*tgc->tgc_D), (tgc->tgc_C*tgc->tgc_B) );
	tgc->tgc_AD_CB = (f < 0.0001);		/* A*D == C*B */
	rt_tgc_rotate( tip->a, tip->b, tip->h, Rot, iRot, tgc );
	MAT4X3VEC( nH, Rot, tip->h );
	tgc->tgc_sH = nH[Z];

	tgc->tgc_CdAm1 = tgc->tgc_C/tgc->tgc_A - 1.0;
	tgc->tgc_DdBm1 = tgc->tgc_D/tgc->tgc_B - 1.0;
	if( NEAR_ZERO( tgc->tgc_CdAm1, SMALL ) )
		tgc->tgc_CdAm1 = 0.0;
	if( NEAR_ZERO( tgc->tgc_DdBm1, SMALL ) )
		tgc->tgc_DdBm1 = 0.0;

	/*
	 *	Added iShr parameter to tgc_shear().
	 *	Changed inverse transformation of normal vectors of std.
	 *		solid intersection to include shear inverse
	 *		(tgc_invRtShSc).
	 *	Fold in scaling transformation into the transformation to std.
	 *		space from target space (tgc_ScShR).
	 */
	rt_tgc_shear( nH, Z, Shr, tShr, iShr );
	rt_tgc_scale( tgc->tgc_A, tgc->tgc_B, tgc->tgc_sH, Scl, iScl );

	bn_mat_mul( tmp, Shr, Rot );
	bn_mat_mul( tgc->tgc_ScShR, Scl, tmp );

	bn_mat_mul( tmp, tShr, Scl );
	bn_mat_mul( tgc->tgc_invRtShSc, iRot, tmp );

	/* Compute bounding sphere and RPP */
	{
		LOCAL fastf_t dx, dy, dz;	/* For bounding sphere */
		LOCAL vect_t temp;

		/* There are 8 corners to the bounding RPP */
		/* This may not be minimal, but does fully contain the TGC */
		VADD2( temp, tgc->tgc_V, tip->a );
		VADD2( work, temp, tip->b );
#define TGC_MM(v)	VMINMAX( stp->st_min, stp->st_max, v );
		TGC_MM( work );	/* V + A + B */
		VSUB2( work, temp, tip->b );
		TGC_MM( work );	/* V + A - B */

		VSUB2( temp, tgc->tgc_V, tip->a );
		VADD2( work, temp, tip->b );
		TGC_MM( work );	/* V - A + B */
		VSUB2( work, temp, tip->b );
		TGC_MM( work );	/* V - A - B */

		VADD3( temp, tgc->tgc_V, tip->h, tip->c );
		VADD2( work, temp, tip->d );
		TGC_MM( work );	/* V + H + C + D */
		VSUB2( work, temp, tip->d );
		TGC_MM( work );	/* V + H + C - D */

		VADD2( temp, tgc->tgc_V, tip->h );
		VSUB2( temp, temp, tip->c );
		VADD2( work, temp, tip->d );
		TGC_MM( work );	/* V + H - C + D */
		VSUB2( work, temp, tip->d );
		TGC_MM( work );	/* V + H - C - D */

		VSET( stp->st_center,
		    (stp->st_max[X] + stp->st_min[X])/2,
		    (stp->st_max[Y] + stp->st_min[Y])/2,
		    (stp->st_max[Z] + stp->st_min[Z])/2 );

		dx = (stp->st_max[X] - stp->st_min[X])/2;
		f = dx;
		dy = (stp->st_max[Y] - stp->st_min[Y])/2;
		if( dy > f )  f = dy;
		dz = (stp->st_max[Z] - stp->st_min[Z])/2;
		if( dz > f )  f = dz;
		stp->st_aradius = f;
		stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);
	}
	return (0);
}


/*
 *			R T _ T G C _ R O T A T E
 *
 *  To rotate vectors  A  and  B  ( where  A  is perpendicular to  B )
 *  to the X and Y axes respectively, create a rotation matrix
 *
 *	    | A' |
 *	R = | B' |
 *	    | C' |
 *
 *  where  A',  B'  and  C'  are vectors such that
 *
 *	A' = A/|A|	B' = B/|B|	C' = C/|C|
 *
 *  where    C = H - ( H.A' )A' - ( H.B' )B'
 *
 *  The last operation ( Gram Schmidt method ) finds the component
 *  of the vector  H  perpendicular  A  and to  B.  This is, therefore
 *  the normal for the planar sections of the truncated cone.
 */
static void
rt_tgc_rotate(fastf_t *A, fastf_t *B, fastf_t *Hv, fastf_t *Rot, fastf_t *Inv, struct tgc_specific *tgc)
{
	LOCAL vect_t	uA, uB, uC;	/*  unit vectors		*/
	LOCAL fastf_t	mag_ha,		/*  magnitude of H in the	*/
	mag_hb;		/*    A and B directions	*/

	/* copy A and B, then 'unitize' the results			*/
	VMOVE( uA, A );
	VUNITIZE( uA );
	VMOVE( uB, B );
	VUNITIZE( uB );

	/*  Find component of H in the A direction			*/
	mag_ha = VDOT( Hv, uA );
	/*  Find component of H in the B direction			*/
	mag_hb = VDOT( Hv, uB );

	/*  Subtract the A and B components of H to find the component
	 *  perpendicular to both, then 'unitize' the result.
	 */
	VJOIN2( uC, Hv, -mag_ha, uA, -mag_hb, uB );
	VUNITIZE( uC );
	VMOVE( tgc->tgc_N, uC );

	MAT_IDN( Rot );
	MAT_IDN( Inv );

	Rot[0] = Inv[0] = uA[X];
	Rot[1] = Inv[4] = uA[Y];
	Rot[2] = Inv[8] = uA[Z];

	Rot[4] = Inv[1] = uB[X];
	Rot[5] = Inv[5] = uB[Y];
	Rot[6] = Inv[9] = uB[Z];

	Rot[8]  = Inv[2]  = uC[X];
	Rot[9]  = Inv[6]  = uC[Y];
	Rot[10] = Inv[10] = uC[Z];
}

/*
 *			R T _ T G C _ S H E A R
 *
 *  To shear the H vector to the Z axis, every point must be shifted
 *  in the X direction by  -(Hx/Hz)*z , and in the Y direction by
 *  -(Hy/Hz)*z .  This operation makes the equation for the standard
 *  cone much easier to work with.
 *
 *  NOTE:  This computes the TRANSPOSE of the shear matrix rather than
 *  the inverse.
 *
 * Begin changes GSM, EOD -- Added INVERSE (Inv) calculation.
 */
static void
rt_tgc_shear(const fastf_t *vect, int axis, fastf_t *Shr, fastf_t *Trn, fastf_t *Inv)
{
	MAT_IDN( Shr );
	MAT_IDN( Trn );
	MAT_IDN( Inv );

	if( NEAR_ZERO( vect[axis], SMALL_FASTF ) )
		rt_bomb("rt_tgc_shear() divide by zero\n");

	if ( axis == X ){
		Inv[4] = -(Shr[4] = Trn[1] = -vect[Y]/vect[X]);
		Inv[8] = -(Shr[8] = Trn[2] = -vect[Z]/vect[X]);
	} else if ( axis == Y ){
		Inv[1] = -(Shr[1] = Trn[4] = -vect[X]/vect[Y]);
		Inv[9] = -(Shr[9] = Trn[6] = -vect[Z]/vect[Y]);
	} else if ( axis == Z ){
		Inv[2] = -(Shr[2] = Trn[8] = -vect[X]/vect[Z]);
		Inv[6] = -(Shr[6] = Trn[9] = -vect[Y]/vect[Z]);
	}
}

/*
 *			R T _ T G C _ S C A L E
 */
static void
rt_tgc_scale(fastf_t a, fastf_t b, fastf_t h, fastf_t *Scl, fastf_t *Inv)
{
	MAT_IDN( Scl );
	MAT_IDN( Inv );
	Scl[0]  /= a;
	Scl[5]  /= b;
	Scl[10] /= h;
	Inv[0]  = a;
	Inv[5]  = b;
	Inv[10] = h;
	return;
}

/*
 *  			R T _ T G C _ P R I N T
 */
void
rt_tgc_print(register const struct soltab *stp)
{
	register const struct tgc_specific	*tgc =
	(struct tgc_specific *)stp->st_specific;

	VPRINT( "V", tgc->tgc_V );
	bu_log( "mag sheared H = %f\n", tgc->tgc_sH );
	bu_log( "mag A = %f\n", tgc->tgc_A );
	bu_log( "mag B = %f\n", tgc->tgc_B );
	bu_log( "mag C = %f\n", tgc->tgc_C );
	bu_log( "mag D = %f\n", tgc->tgc_D );
	VPRINT( "Top normal", tgc->tgc_N );

	bn_mat_print( "Sc o Sh o R", tgc->tgc_ScShR );
	bn_mat_print( "invR o trnSh o Sc", tgc->tgc_invRtShSc );

	if( tgc->tgc_AD_CB )  {
		bu_log( "A*D == C*B.  Equal eccentricities gives quadratic equation.\n");
	} else {
		bu_log( "A*D != C*B.  Quartic equation.\n");
	}
	bu_log( "(C/A - 1) = %f\n", tgc->tgc_CdAm1 );
	bu_log( "(D/B - 1) = %f\n", tgc->tgc_DdBm1 );
	bu_log( "(|A|**2)/(|C|**2) = %f\n", tgc->tgc_AAdCC );
	bu_log( "(|B|**2)/(|D|**2) = %f\n", tgc->tgc_BBdDD );
}

/* hit_surfno is set to one of these */
#define	TGC_NORM_BODY	(1)		/* compute normal */
#define	TGC_NORM_TOP	(2)		/* copy tgc_N */
#define	TGC_NORM_BOT	(3)		/* copy reverse tgc_N */

/*
 *			R T _ T G C _ S H O T
 *
 *  Intersect a ray with a truncated general cone, where all constant
 *  terms have been computed by rt_tgc_prep().
 *
 *  NOTE:  All lines in this function are represented parametrically
 *  by a point,  P( Px, Py, Pz ) and a unit direction vector,
 *  D = iDx + jDy + kDz.  Any point on a line can be expressed
 *  by one variable 't', where
 *
 *        X = Dx*t + Px,
 *        Y = Dy*t + Py,
 *        Z = Dz*t + Pz.
 *
 *  First, convert the line to the coordinate system of a "stan-
 *  dard" cone.  This is a cone whose base lies in the X-Y plane,
 *  and whose H (now H') vector is lined up with the Z axis.  
 *
 *  Then find the equation of that line and the standard cone
 *  as an equation in 't'.  Solve the equation using a general
 *  polynomial root finder.  Use those values of 't' to compute
 *  the points of intersection in the original coordinate system.
 */
int
rt_tgc_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register const struct tgc_specific	*tgc =
	(struct tgc_specific *)stp->st_specific;
	register struct seg	*segp;
	LOCAL vect_t		pprime;
	LOCAL vect_t		dprime;
	LOCAL vect_t		work;
	LOCAL fastf_t		k[6];
	LOCAL int		hit_type[6];
	LOCAL fastf_t		t, b, zval, dir;
	LOCAL fastf_t		t_scale;
	LOCAL fastf_t		alf1, alf2;
	LOCAL int		npts;
	LOCAL int		intersect;
	LOCAL vect_t		cor_pprime;	/* corrected P prime */
	LOCAL fastf_t		cor_proj = 0;	/* corrected projected dist */
	LOCAL int		i;
	LOCAL bn_poly_t		C;	/*  final equation	*/
	LOCAL bn_poly_t		Xsqr, Ysqr;
	LOCAL bn_poly_t		R, Rsqr;

	/* find rotated point and direction */
	MAT4X3VEC( dprime, tgc->tgc_ScShR, rp->r_dir );

	/*
	 *  A vector of unit length in model space (r_dir) changes length in
	 *  the special unit-tgc space.  This scale factor will restore
	 *  proper length after hit points are found.
	 */
	t_scale = MAGNITUDE(dprime);
	if( NEAR_ZERO( t_scale, SMALL_FASTF ) )  {
		bu_log("tgc(%s) dprime=(%g,%g,%g), t_scale=%e, miss.\n",
		    V3ARGS(dprime), t_scale);
		return 0;
	}
	t_scale = 1/t_scale;
	VSCALE( dprime, dprime, t_scale );	/* VUNITIZE( dprime ); */

	if( NEAR_ZERO( dprime[Z], RT_PCOEF_TOL ) )  {
		dprime[Z] = 0.0;	/* prevent rootfinder heartburn */
	}

	VSUB2( work, rp->r_pt, tgc->tgc_V );
	MAT4X3VEC( pprime, tgc->tgc_ScShR, work );

	/* Translating ray origin along direction of ray to closest
	 * pt. to origin of solids coordinate system, new ray origin
	 * is 'cor_pprime'.
	 */
	cor_proj = -VDOT( pprime, dprime );
	VJOIN1( cor_pprime, pprime, cor_proj, dprime );

	/*
	 * The TGC is defined in "unit" space, so the parametric distance
	 * from one side of the TGC to the other is on the order of 2.
	 * Therefore, any vector/point coordinates that are very small
	 * here may be considered to be zero,
	 * since double precision only has 18 digits of significance.
	 * If these tiny values were left in, then as they get
	 * squared (below) they will cause difficulties.
	 */
	for( i=0; i<3; i++ )  {
		/* Direction cosines */
		if( NEAR_ZERO( dprime[i], 1e-10 ) )  dprime[i] = 0;
		/* Position in -1..+1 coordinates */
		if( NEAR_ZERO( cor_pprime[i], 1e-20 ) )  cor_pprime[i] = 0;
	}

	/*
	 *  Given a line and the parameters for a standard cone, finds
	 *  the roots of the equation for that cone and line.
	 *  Returns the number of real roots found.
	 * 
	 *  Given a line and the cone parameters, finds the equation
	 *  of the cone in terms of the variable 't'.
	 *
	 *  The equation for the cone is:
	 *
	 *      X**2 * Q**2  +  Y**2 * R**2  -  R**2 * Q**2 = 0
	 *
	 *  where	R = a + ((c - a)/|H'|)*Z 
	 *		Q = b + ((d - b)/|H'|)*Z
	 *
	 *  First, find X, Y, and Z in terms of 't' for this line, then
	 *  substitute them into the equation above.
	 *
	 *  Express each variable (X, Y, and Z) as a linear equation
	 *  in 'k', eg, (dprime[X] * k) + cor_pprime[X], and
	 *  substitute into the cone equation.
	 */
	Xsqr.dgr = 2;
	Xsqr.cf[0] = dprime[X] * dprime[X];
	Xsqr.cf[1] = 2.0 * dprime[X] * cor_pprime[X];
	Xsqr.cf[2] = cor_pprime[X] * cor_pprime[X];

	Ysqr.dgr = 2;
	Ysqr.cf[0] = dprime[Y] * dprime[Y];
	Ysqr.cf[1] = 2.0 * dprime[Y] * cor_pprime[Y];
	Ysqr.cf[2] = cor_pprime[Y] * cor_pprime[Y];

	R.dgr = 1;
	R.cf[0] = dprime[Z] * tgc->tgc_CdAm1;
	/* A vector is unitized (tgc->tgc_A == 1.0) */
	R.cf[1] = (cor_pprime[Z] * tgc->tgc_CdAm1) + 1.0;

	/* (void) rt_poly_mul( &R, &R, &Rsqr ); */
	Rsqr.dgr = 2;
	Rsqr.cf[0] = R.cf[0] * R.cf[0];
	Rsqr.cf[1] = R.cf[0] * R.cf[1] * 2;
	Rsqr.cf[2] = R.cf[1] * R.cf[1];

	/*
	 *  If the eccentricities of the two ellipses are the same,
	 *  then the cone equation reduces to a much simpler quadratic
	 *  form.  Otherwise it is a (gah!) quartic equation.
	 *
	 *  this can only be done when C.cf[0] is not too small!!!! (JRA)
	 */
	C.cf[0] = Xsqr.cf[0] + Ysqr.cf[0] - Rsqr.cf[0];
	if( tgc->tgc_AD_CB && !NEAR_ZERO( C.cf[0], 1.0e-10 )  ) {
		FAST fastf_t roots;

		/*
		 *  (void) rt_poly_add( &Xsqr, &Ysqr, &sum );
		 *  (void) rt_poly_sub( &sum, &Rsqr, &C );
		 */
		C.dgr = 2;
		C.cf[1] = Xsqr.cf[1] + Ysqr.cf[1] - Rsqr.cf[1];
		C.cf[2] = Xsqr.cf[2] + Ysqr.cf[2] - Rsqr.cf[2];

		/* Find the real roots the easy way.  C.dgr==2 */
		if( (roots = C.cf[1]*C.cf[1] - 4 * C.cf[0] * C.cf[2]) < 0 ) {
			npts = 0;	/* no real roots */
		} else {
			register fastf_t	f;
			roots = sqrt(roots);
			k[0] = (roots - C.cf[1]) * (f = 0.5 / C.cf[0]);
			hit_type[0] = TGC_NORM_BODY;
			k[1] = (roots + C.cf[1]) * -f;
			hit_type[1] = TGC_NORM_BODY;
			npts = 2;
		}
	} else {
		LOCAL bn_poly_t	Q, Qsqr;
		LOCAL bn_complex_t	val[4];	/* roots of final equation */
		register int	l;
		register int nroots;

		Q.dgr = 1;
		Q.cf[0] = dprime[Z] * tgc->tgc_DdBm1;
		/* B vector is unitized (tgc->tgc_B == 1.0) */
		Q.cf[1] = (cor_pprime[Z] * tgc->tgc_DdBm1) + 1.0;

		/* (void) rt_poly_mul( &Q, &Q, &Qsqr ); */
		Qsqr.dgr = 2;
		Qsqr.cf[0] = Q.cf[0] * Q.cf[0];
		Qsqr.cf[1] = Q.cf[0] * Q.cf[1] * 2;
		Qsqr.cf[2] = Q.cf[1] * Q.cf[1];

		/*
		 * (void) rt_poly_mul( &Qsqr, &Xsqr, &T1 );
		 * (void) rt_poly_mul( &Rsqr, &Ysqr, &T2 );
		 * (void) rt_poly_mul( &Rsqr, &Qsqr, &T3 );
		 * (void) rt_poly_add( &T1, &T2, &sum );
		 * (void) rt_poly_sub( &sum, &T3, &C );
		 */
		C.dgr = 4;
		C.cf[0] = Qsqr.cf[0] * Xsqr.cf[0] +
		    Rsqr.cf[0] * Ysqr.cf[0] -
		    (Rsqr.cf[0] * Qsqr.cf[0]);
		C.cf[1] = Qsqr.cf[0] * Xsqr.cf[1] + Qsqr.cf[1] * Xsqr.cf[0] +
		    Rsqr.cf[0] * Ysqr.cf[1] + Rsqr.cf[1] * Ysqr.cf[0] -
		    (Rsqr.cf[0] * Qsqr.cf[1] + Rsqr.cf[1] * Qsqr.cf[0]);
		C.cf[2] = Qsqr.cf[0] * Xsqr.cf[2] + Qsqr.cf[1] * Xsqr.cf[1] +
		    Qsqr.cf[2] * Xsqr.cf[0] +
		    Rsqr.cf[0] * Ysqr.cf[2] + Rsqr.cf[1] * Ysqr.cf[1] +
		    Rsqr.cf[2] * Ysqr.cf[0] -
		    (Rsqr.cf[0] * Qsqr.cf[2] + Rsqr.cf[1] * Qsqr.cf[1] +
		    Rsqr.cf[2] * Qsqr.cf[0]);
		C.cf[3] = Qsqr.cf[1] * Xsqr.cf[2] + Qsqr.cf[2] * Xsqr.cf[1] +
		    Rsqr.cf[1] * Ysqr.cf[2] + Rsqr.cf[2] * Ysqr.cf[1] -
		    (Rsqr.cf[1] * Qsqr.cf[2] + Rsqr.cf[2] * Qsqr.cf[1]);
		C.cf[4] = Qsqr.cf[2] * Xsqr.cf[2] +
		    Rsqr.cf[2] * Ysqr.cf[2] -
		    (Rsqr.cf[2] * Qsqr.cf[2]);

		/*  The equation is 4th order, so we expect 0 to 4 roots */
		nroots = rt_poly_roots( &C , val );

		/*  Only real roots indicate an intersection in real space.
		 *
		 *  Look at each root returned; if the imaginary part is zero
		 *  or sufficiently close, then use the real part as one value
		 *  of 't' for the intersections
		 */
		for ( l=0, npts=0; l < nroots; l++ ){
			if ( NEAR_ZERO( val[l].im, 1e-10 ) ) {
				hit_type[npts] = TGC_NORM_BODY;
				k[npts++] = val[l].re;
			}
		}
		/* Here, 'npts' is number of points being returned */
		if ( npts != 0 && npts != 2 && npts != 4 ){
			bu_log("tgc:  reduced %d to %d roots\n",nroots,npts);
			bn_pr_roots( stp->st_name, val, nroots );
		}
	}

	/*
	 * Reverse above translation by adding distance to all 'k' values.
	 */
	for( i = 0; i < npts; ++i )  {
		k[i] += cor_proj;
	}

	/*
	 * Eliminate hits beyond the end planes
	 */
	i = 0;
	while( i < npts ) {
		zval = k[i]*dprime[Z] + pprime[Z];
		/* Height vector is unitized (tgc->tgc_sH == 1.0) */
		if ( zval >= 1.0 || zval <= 0.0 ){
			int j;
			/* drop this hit */
			npts--;
			for( j=i ; j<npts ; j++ ) {
				hit_type[j] = hit_type[j+1];
				k[j] = k[j+1];
			}
		} else {
			i++;
		}
	}

	/*
	 * Consider intersections with the end ellipses
	 */
	dir = VDOT( tgc->tgc_N, rp->r_dir );
	if( !NEAR_ZERO( dprime[Z], SMALL_FASTF ) && !NEAR_ZERO( dir, RT_DOT_TOL ) )  {
		b = ( -pprime[Z] )/dprime[Z];
		/*  Height vector is unitized (tgc->tgc_sH == 1.0) */
		t = ( 1.0 - pprime[Z] )/dprime[Z];

		VJOIN1( work, pprime, b, dprime );
		/* A and B vectors are unitized (tgc->tgc_A == _B == 1.0) */
		/* alf1 = ALPHA(work[X], work[Y], 1.0, 1.0 ) */
		alf1 = work[X]*work[X] + work[Y]*work[Y];

		VJOIN1( work, pprime, t, dprime );

		/* Must scale C and D vectors */
		alf2 = ALPHA(work[X], work[Y], tgc->tgc_AAdCC,tgc->tgc_BBdDD);

		if ( alf1 <= 1.0 ){
			hit_type[npts] = TGC_NORM_BOT;
			k[npts++] = b;
		}
		if ( alf2 <= 1.0 ){
			hit_type[npts] = TGC_NORM_TOP;
			k[npts++] = t;
		}
	}


	/* Sort Most distant to least distant: rt_pt_sort( k, npts ) */
	{
		register fastf_t	u;
		register short		lim, n;
		register int		type;

		for( lim = npts-1; lim > 0; lim-- )  {
			for( n = 0; n < lim; n++ )  {
				if( (u=k[n]) < k[n+1] )  {
					/* bubble larger towards [0] */
					type = hit_type[n];
					hit_type[n] = hit_type[n+1];
					hit_type[n+1] = type;
					k[n] = k[n+1];
					k[n+1] = u;
				}
			}
		}
	}
	/* Now, k[0] > k[npts-1] */

	if( npts%2 ) {
		/* odd number of hits!!!
		 * perhaps we got two hits on an edge
		 * check for duplicate hit distances
		 */

		for( i=npts-1 ; i>0 ; i-- ) {
			fastf_t diff;

			diff = k[i-1] - k[i];	/* non-negative due to sorting */
			if( diff < ap->a_rt_i->rti_tol.dist ) {
				/* remove this duplicate hit */
				int j;

				npts--;
				for( j=i ; j<npts ; j++ ) {
					hit_type[j] = hit_type[j+1];
					k[j] = k[j+1];
				}

				/* now have even number of hits */
				break;
			}
		}
	}

	if ( npts != 0 && npts != 2 && npts != 4 ){
		bu_log("tgc(%s):  %d intersects != {0,2,4}\n",
		    stp->st_name, npts );
		bu_log( "\tray: pt = (%g %g %g), dir = (%g %g %g)\n",
			V3ARGS( ap->a_ray.r_pt ),
			V3ARGS( ap->a_ray.r_dir ) );
		for( i=0 ; i<npts ; i++ ) {
			bu_log( "\t%g", k[i]*t_scale );
		}
		bu_log( "\n" );
		return(0);			/* No hit */
	}

	intersect = 0;
	for( i=npts-1 ; i>0 ; i -= 2 ) {
		RT_GET_SEG( segp, ap->a_resource );
		segp->seg_stp = stp;

		segp->seg_in.hit_dist = k[i] * t_scale;
		segp->seg_in.hit_surfno = hit_type[i];
		if( segp->seg_in.hit_surfno == TGC_NORM_BODY ) {
			VJOIN1( segp->seg_in.hit_vpriv, pprime, k[i], dprime );
		} else {
			if( dir > 0.0 ) {
				segp->seg_in.hit_surfno = TGC_NORM_BOT;
			} else {
				segp->seg_in.hit_surfno = TGC_NORM_TOP;
			}
		}

		segp->seg_out.hit_dist = k[i-1] * t_scale;
		segp->seg_out.hit_surfno = hit_type[i-1];
		if( segp->seg_out.hit_surfno == TGC_NORM_BODY ) {
			VJOIN1( segp->seg_out.hit_vpriv, pprime, k[i-1], dprime );
		} else {
			if( dir > 0.0 ) {
				segp->seg_out.hit_surfno = TGC_NORM_TOP;
			} else {
				segp->seg_out.hit_surfno = TGC_NORM_BOT;
			}
		}
		intersect++;
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	}

	return( intersect );
}

#define RT_TGC_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ T G C _ V S H O T
 *
 *  The Homer vectorized version.
 */
void
rt_tgc_vshot(struct soltab **stp, register struct xray **rp, struct seg *segp, int n, struct application *ap)
             		       
                    	      
                               /* array of segs (results returned) */
                               /* Number of ray/object pairs */
                  	    
{
	register struct tgc_specific	*tgc;
	register int		ix;
	LOCAL vect_t		pprime;
	LOCAL vect_t		dprime;
	LOCAL vect_t		work;
	LOCAL fastf_t		k[4], pt[2];
	LOCAL fastf_t		t, b, zval, dir;
	LOCAL fastf_t		t_scale = 0;
	LOCAL fastf_t		alf1, alf2;
	LOCAL int		npts;
	LOCAL int		intersect;
	LOCAL vect_t		cor_pprime;	/* corrected P prime */
	LOCAL fastf_t		cor_proj = 0;	/* corrected projected dist */
	LOCAL int		i;
	LOCAL bn_poly_t		*C;	/*  final equation	*/
	LOCAL bn_poly_t		Xsqr, Ysqr;
	LOCAL bn_poly_t		R, Rsqr;

	/* Allocate space for polys and roots */
	C = (bn_poly_t *)bu_malloc(n * sizeof(bn_poly_t), "tor bn_poly_t");

	/* Initialize seg_stp to assume hit (zero will then flag miss) */
#       include "noalias.h"
	for(ix = 0; ix < n; ix++) segp[ix].seg_stp = stp[ix];

	/* for each ray/cone pair */
#   include "noalias.h"
	for(ix = 0; ix < n; ix++) {

#if !CRAY       /* XXX currently prevents vectorization on cray */
		if (segp[ix].seg_stp == 0) continue; /* == 0 signals skip ray */
#endif

		tgc = (struct tgc_specific *)stp[ix]->st_specific;

		/* find rotated point and direction */
		MAT4X3VEC( dprime, tgc->tgc_ScShR, rp[ix]->r_dir );

		/*
	 *  A vector of unit length in model space (r_dir) changes length in
	 *  the special unit-tgc space.  This scale factor will restore
	 *  proper length after hit points are found.
	 */
		t_scale = 1/MAGNITUDE( dprime );
		VSCALE( dprime, dprime, t_scale );	/* VUNITIZE( dprime ); */

		if( NEAR_ZERO( dprime[Z], RT_PCOEF_TOL ) )
			dprime[Z] = 0.0;	/* prevent rootfinder heartburn */

		/* Use segp[ix].seg_in.hit_normal as tmp to hold dprime */
		VMOVE( segp[ix].seg_in.hit_normal, dprime );

		VSUB2( work, rp[ix]->r_pt, tgc->tgc_V );
		MAT4X3VEC( pprime, tgc->tgc_ScShR, work );

		/* Use segp[ix].seg_out.hit_normal as tmp to hold pprime */
		VMOVE( segp[ix].seg_out.hit_normal, pprime );

		/* Translating ray origin along direction of ray to closest
	 * pt. to origin of solids coordinate system, new ray origin
	 * is 'cor_pprime'.
	 */
		cor_proj = VDOT( pprime, dprime );
		VSCALE( cor_pprime, dprime, cor_proj );
		VSUB2( cor_pprime, pprime, cor_pprime );

		/*
	 *  Given a line and the parameters for a standard cone, finds
	 *  the roots of the equation for that cone and line.
	 *  Returns the number of real roots found.
	 * 
	 *  Given a line and the cone parameters, finds the equation
	 *  of the cone in terms of the variable 't'.
	 *
	 *  The equation for the cone is:
	 *
	 *      X**2 * Q**2  +  Y**2 * R**2  -  R**2 * Q**2 = 0
	 *
	 *  where	R = a + ((c - a)/|H'|)*Z 
	 *		Q = b + ((d - b)/|H'|)*Z
	 *
	 *  First, find X, Y, and Z in terms of 't' for this line, then
	 *  substitute them into the equation above.
	 *
	 *  Express each variable (X, Y, and Z) as a linear equation
	 *  in 'k', eg, (dprime[X] * k) + cor_pprime[X], and
	 *  substitute into the cone equation.
	 */
		Xsqr.dgr = 2;
		Xsqr.cf[0] = dprime[X] * dprime[X];
		Xsqr.cf[1] = 2.0 * dprime[X] * cor_pprime[X];
		Xsqr.cf[2] = cor_pprime[X] * cor_pprime[X];

		Ysqr.dgr = 2;
		Ysqr.cf[0] = dprime[Y] * dprime[Y];
		Ysqr.cf[1] = 2.0 * dprime[Y] * cor_pprime[Y];
		Ysqr.cf[2] = cor_pprime[Y] * cor_pprime[Y];

		R.dgr = 1;
		R.cf[0] = dprime[Z] * tgc->tgc_CdAm1;
		/* A vector is unitized (tgc->tgc_A == 1.0) */
		R.cf[1] = (cor_pprime[Z] * tgc->tgc_CdAm1) + 1.0;

		/* (void) rt_poly_mul( &R, &R, &Rsqr ); inline expands to: */
		Rsqr.dgr = 2;
		Rsqr.cf[0] = R.cf[0] * R.cf[0];
		Rsqr.cf[1] = R.cf[0] * R.cf[1] * 2;
		Rsqr.cf[2] = R.cf[1] * R.cf[1];

		/*
	 *  If the eccentricities of the two ellipses are the same,
	 *  then the cone equation reduces to a much simpler quadratic
	 *  form.  Otherwise it is a (gah!) quartic equation.
	 */
		if ( tgc->tgc_AD_CB ){
			/* (void) rt_poly_add( &Xsqr, &Ysqr, &sum ); and */
			/* (void) rt_poly_sub( &sum, &Rsqr, &C ); inline expand to */
			C[ix].dgr = 2;
			C[ix].cf[0] = Xsqr.cf[0] + Ysqr.cf[0] - Rsqr.cf[0];
			C[ix].cf[1] = Xsqr.cf[1] + Ysqr.cf[1] - Rsqr.cf[1];
			C[ix].cf[2] = Xsqr.cf[2] + Ysqr.cf[2] - Rsqr.cf[2];
		} else {
			LOCAL bn_poly_t	Q, Qsqr;

			Q.dgr = 1;
			Q.cf[0] = dprime[Z] * tgc->tgc_DdBm1;
			/* B vector is unitized (tgc->tgc_B == 1.0) */
			Q.cf[1] = (cor_pprime[Z] * tgc->tgc_DdBm1) + 1.0;

			/* (void) rt_poly_mul( &Q, &Q, &Qsqr ); inline expands to */
			Qsqr.dgr = 2;
			Qsqr.cf[0] = Q.cf[0] * Q.cf[0];
			Qsqr.cf[1] = Q.cf[0] * Q.cf[1] * 2;
			Qsqr.cf[2] = Q.cf[1] * Q.cf[1];

			/* (void) rt_poly_mul( &Qsqr, &Xsqr, &T1 ); inline expands to */
			C[ix].dgr = 4;
			C[ix].cf[0] = Qsqr.cf[0] * Xsqr.cf[0];
			C[ix].cf[1] = Qsqr.cf[0] * Xsqr.cf[1] +
			    Qsqr.cf[1] * Xsqr.cf[0];
			C[ix].cf[2] = Qsqr.cf[0] * Xsqr.cf[2] +
			    Qsqr.cf[1] * Xsqr.cf[1] +
			    Qsqr.cf[2] * Xsqr.cf[0];
			C[ix].cf[3] = Qsqr.cf[1] * Xsqr.cf[2] +
			    Qsqr.cf[2] * Xsqr.cf[1];
			C[ix].cf[4] = Qsqr.cf[2] * Xsqr.cf[2];

			/* (void) rt_poly_mul( &Rsqr, &Ysqr, &T2 ); and */
			/* (void) rt_poly_add( &T1, &T2, &sum ); inline expand to */
			C[ix].cf[0] += Rsqr.cf[0] * Ysqr.cf[0];
			C[ix].cf[1] += Rsqr.cf[0] * Ysqr.cf[1] +
			    Rsqr.cf[1] * Ysqr.cf[0];
			C[ix].cf[2] += Rsqr.cf[0] * Ysqr.cf[2] +
			    Rsqr.cf[1] * Ysqr.cf[1] +
			    Rsqr.cf[2] * Ysqr.cf[0];
			C[ix].cf[3] += Rsqr.cf[1] * Ysqr.cf[2] +
			    Rsqr.cf[2] * Ysqr.cf[1];
			C[ix].cf[4] += Rsqr.cf[2] * Ysqr.cf[2];

			/* (void) rt_poly_mul( &Rsqr, &Qsqr, &T3 ); and */
			/* (void) rt_poly_sub( &sum, &T3, &C ); inline expand to */
			C[ix].cf[0] -= Rsqr.cf[0] * Qsqr.cf[0];
			C[ix].cf[1] -= Rsqr.cf[0] * Qsqr.cf[1] +
			    Rsqr.cf[1] * Qsqr.cf[0];
			C[ix].cf[2] -= Rsqr.cf[0] * Qsqr.cf[2] +
			    Rsqr.cf[1] * Qsqr.cf[1] +
			    Rsqr.cf[2] * Qsqr.cf[0];
			C[ix].cf[3] -= Rsqr.cf[1] * Qsqr.cf[2] +
			    Rsqr.cf[2] * Qsqr.cf[1];
			C[ix].cf[4] -= Rsqr.cf[2] * Qsqr.cf[2];
		}

	}

	/* It seems impractical to try to vectorize finding and sorting roots. */
	for(ix = 0; ix < n; ix++){
		if (segp[ix].seg_stp == 0) continue; /* == 0 signals skip ray */

		/* Again, check for the equal eccentricities case. */
		if ( C[ix].dgr == 2 ){
			FAST fastf_t roots;

			/* Find the real roots the easy way. */
			if( (roots = C[ix].cf[1]*C[ix].cf[1]-4*C[ix].cf[0]*C[ix].cf[2]
			    ) < 0 ) {
				npts = 0;	/* no real roots */
			} else {
				roots = sqrt(roots);
				k[0] = (roots - C[ix].cf[1]) * 0.5 / C[ix].cf[0];
				k[1] = (roots + C[ix].cf[1]) * (-0.5) / C[ix].cf[0];
				npts = 2;
			}
		} else {
			LOCAL bn_complex_t	val[4];	/* roots of final equation */
			register int	l;
			register int nroots;

			/*  The equation is 4th order, so we expect 0 to 4 roots */
			nroots = rt_poly_roots( &C[ix] , val );

			/*  Only real roots indicate an intersection in real space.
		 *
		 *  Look at each root returned; if the imaginary part is zero
		 *  or sufficiently close, then use the real part as one value
		 *  of 't' for the intersections
		 */
			for ( l=0, npts=0; l < nroots; l++ ){
				if ( NEAR_ZERO( val[l].im, 0.0001 ) )
					k[npts++] = val[l].re;
			}
			/* Here, 'npts' is number of points being returned */
			if ( npts != 0 && npts != 2 && npts != 4 ){
				bu_log("tgc:  reduced %d to %d roots\n",nroots,npts);
				bn_pr_roots( "tgc", val, nroots );
			}
		}

		/*
	 * Reverse above translation by adding distance to all 'k' values.
	 */
		for( i = 0; i < npts; ++i )
			k[i] -= cor_proj;

		if ( npts != 0 && npts != 2 && npts != 4 ){
			bu_log("tgc(%s):  %d intersects != {0,2,4}\n",
			    stp[ix]->st_name, npts );
			RT_TGC_SEG_MISS(segp[ix]);		/* No hit	*/
			continue;
		}

		/* Most distant to least distant	*/
		rt_pt_sort( k, npts );

		/* Now, k[0] > k[npts-1] */

		/* General Cone may have 4 intersections, but	*
	 * Truncated Cone may only have 2.		*/

#define OUT		0
#define	IN		1

		/*		Truncation Procedure
	 *
	 *  Determine whether any of the intersections found are
	 *  between the planes truncating the cone.
	 */
		intersect = 0;
		tgc = (struct tgc_specific *)stp[ix]->st_specific;
		for ( i=0; i < npts; i++ ){
			/* segp[ix].seg_in.hit_normal holds dprime */
			/* segp[ix].seg_out.hit_normal holds pprime */
			zval = k[i]*segp[ix].seg_in.hit_normal[Z] +
			    segp[ix].seg_out.hit_normal[Z];
			/* Height vector is unitized (tgc->tgc_sH == 1.0) */
			if ( zval < 1.0 && zval > 0.0 ){
				if ( ++intersect == 2 )  {
					pt[IN] = k[i];
				}  else
					pt[OUT] = k[i];
			}
		}
		/* Reuse C to hold values of intersect and k. */
		C[ix].dgr = intersect;
		C[ix].cf[OUT] = pt[OUT];
		C[ix].cf[IN]  = pt[IN];
	}

	/* for each ray/cone pair */
#   include "noalias.h"
	for(ix = 0; ix < n; ix++) {
		if (segp[ix].seg_stp == 0) continue; /* Skip */

		tgc = (struct tgc_specific *)stp[ix]->st_specific;
		intersect = C[ix].dgr;
		pt[OUT] = C[ix].cf[OUT];
		pt[IN]  = C[ix].cf[IN];
		/* segp[ix].seg_out.hit_normal holds pprime */
		VMOVE( pprime, segp[ix].seg_out.hit_normal );
		/* segp[ix].seg_in.hit_normal holds dprime */
		VMOVE( dprime, segp[ix].seg_in.hit_normal );

		if ( intersect == 2 ){
			/*  If two between-plane intersections exist, they are
		 *  the hit points for the ray.
		 */
			segp[ix].seg_in.hit_dist = pt[IN] * t_scale;
			segp[ix].seg_in.hit_surfno = TGC_NORM_BODY;	/* compute N */
			VJOIN1( segp[ix].seg_in.hit_vpriv, pprime, pt[IN], dprime );

			segp[ix].seg_out.hit_dist = pt[OUT] * t_scale;
			segp[ix].seg_out.hit_surfno = TGC_NORM_BODY;	/* compute N */
			VJOIN1( segp[ix].seg_out.hit_vpriv, pprime, pt[OUT], dprime );
		} else if ( intersect == 1 ) {
			int	nflag;
			/*
		 *  If only one between-plane intersection exists (pt[OUT]),
		 *  then the other intersection must be on
		 *  one of the planar surfaces (pt[IN]).
		 *
		 *  Find which surface it lies on by calculating the 
		 *  X and Y values of the line as it intersects each
		 *  plane (in the standard coordinate system), and test
		 *  whether this lies within the governing ellipse.
		 */
			if( dprime[Z] == 0.0 )  {
#if 0
				bu_log("tgc: dprime[Z] = 0!\n" );
#endif
				RT_TGC_SEG_MISS(segp[ix]);
				continue;
			}
			b = ( -pprime[Z] )/dprime[Z];
			/*  Height vector is unitized (tgc->tgc_sH == 1.0) */
			t = ( 1.0 - pprime[Z] )/dprime[Z];

			VJOIN1( work, pprime, b, dprime );
			/* A and B vectors are unitized (tgc->tgc_A == _B == 1.0) */
			/* alf1 = ALPHA(work[X], work[Y], 1.0, 1.0 ) */
			alf1 = work[X]*work[X] + work[Y]*work[Y];

			VJOIN1( work, pprime, t, dprime );
			/* Must scale C and D vectors */
			alf2 = ALPHA(work[X], work[Y], tgc->tgc_AAdCC,tgc->tgc_BBdDD);

			if ( alf1 <= 1.0 ){
				pt[IN] = b;
				nflag = TGC_NORM_BOT; /* copy reverse normal */
			} else if ( alf2 <= 1.0 ){
				pt[IN] = t;
				nflag = TGC_NORM_TOP;	/* copy normal */
			} else {
				/* intersection apparently invalid  */
#if 0
				bu_log("tgc(%s):  only 1 intersect\n", stp[ix]->st_name);
#endif
				RT_TGC_SEG_MISS(segp[ix]);
				continue;
			}

			/* pt[OUT] on skin, pt[IN] on end */
			if ( pt[OUT] >= pt[IN] )  {
				segp[ix].seg_in.hit_dist = pt[IN] * t_scale;
				segp[ix].seg_in.hit_surfno = nflag;

				segp[ix].seg_out.hit_dist = pt[OUT] * t_scale;
				segp[ix].seg_out.hit_surfno = TGC_NORM_BODY;	/* compute N */
				/* transform-space vector needed for normal */
				VJOIN1( segp[ix].seg_out.hit_vpriv, pprime, pt[OUT], dprime );
			} else {
				segp[ix].seg_in.hit_dist = pt[OUT] * t_scale;
				/* transform-space vector needed for normal */
				segp[ix].seg_in.hit_surfno = TGC_NORM_BODY;	/* compute N */
				VJOIN1( segp[ix].seg_in.hit_vpriv, pprime, pt[OUT], dprime );

				segp[ix].seg_out.hit_dist = pt[IN] * t_scale;
				segp[ix].seg_out.hit_surfno = nflag;
			}
		} else {

			/*  If all conic interections lie outside the plane,
	 *  then check to see whether there are two planar
	 *  intersections inside the governing ellipses.
	 *
	 *  But first, if the direction is parallel (or nearly
	 *  so) to the planes, it (obviously) won't intersect
	 *  either of them.
	 */
			if( dprime[Z] == 0.0 ) {
				RT_TGC_SEG_MISS(segp[ix]);
				continue;
			}

			dir = VDOT( tgc->tgc_N, rp[ix]->r_dir );	/* direc */
			if ( NEAR_ZERO( dir, RT_DOT_TOL ) ) {
				RT_TGC_SEG_MISS(segp[ix]);
				continue;
			}

			b = ( -pprime[Z] )/dprime[Z];
			/* Height vector is unitized (tgc->tgc_sH == 1.0) */
			t = ( 1.0 - pprime[Z] )/dprime[Z];

			VJOIN1( work, pprime, b, dprime );
			/* A and B vectors are unitized (tgc->tgc_A == _B == 1.0) */
			/* alpf = ALPHA(work[0], work[1], 1.0, 1.0 ) */
			alf1 = work[X]*work[X] + work[Y]*work[Y];

			VJOIN1( work, pprime, t, dprime );
			/* Must scale C and D vectors. */
			alf2 = ALPHA(work[X], work[Y], tgc->tgc_AAdCC,tgc->tgc_BBdDD);

			/*  It should not be possible for one planar intersection
	 *  to be outside its ellipse while the other is inside ...
	 *  but I wouldn't take any chances.
	 */
			if ( alf1 > 1.0 || alf2 > 1.0 ) {
				RT_TGC_SEG_MISS(segp[ix]);
				continue;
			}

			/*  Use the dot product (found earlier) of the plane
	 *  normal with the direction vector to determine the
	 *  orientation of the intersections.
	 */
			if ( dir > 0.0 ){
				segp[ix].seg_in.hit_dist = b * t_scale;
				segp[ix].seg_in.hit_surfno = TGC_NORM_BOT;	/* reverse normal */

				segp[ix].seg_out.hit_dist = t * t_scale;
				segp[ix].seg_out.hit_surfno = TGC_NORM_TOP;	/* normal */
			} else {
				segp[ix].seg_in.hit_dist = t * t_scale;
				segp[ix].seg_in.hit_surfno = TGC_NORM_TOP;	/* normal */

				segp[ix].seg_out.hit_dist = b * t_scale;
				segp[ix].seg_out.hit_surfno = TGC_NORM_BOT;	/* reverse normal */
			}
		}
	} /* end for each ray/cone pair */
	bu_free( (char *)C, "tor bn_poly_t" );
}

/*
 *			R T _ P T _ S O R T
 *
 *  Sorts the values in t[] in descending order.
 */
void
rt_pt_sort(register fastf_t t[], int npts)
{
	FAST fastf_t	u;
	register short	lim, n;

	for( lim = npts-1; lim > 0; lim-- )  {
		for( n = 0; n < lim; n++ )  {
			if( (u=t[n]) < t[n+1] )  {
				/* bubble larger towards [0] */
				t[n] = t[n+1];
				t[n+1] = u;
			}
		}
	}
}


/*
 *			R T _ T G C _ N O R M
 *
 *  Compute the normal to the cone, given a point on the STANDARD
 *  CONE centered at the origin of the X-Y plane.
 *
 *  The gradient of the cone at that point is the normal vector in
 *  the standard space.  This vector will need to be transformed
 *  back to the coordinate system of the original cone in order
 *  to be useful.  Then the transformed vector must be 'unitized.'
 *
 *  NOTE:  The transformation required is NOT the inverse of the of
 *	   the rotation to the standard cone, due to the shear involved
 *	   in the mapping.  The inverse maps points back to points,
 *	   but it is the transpose which maps normals back to normals.
 *	   If you really want to know why, talk to Ed Davisson or
 *	   Peter Stiller.
 *
 *  The equation for the standard cone *without* scaling is:
 *  (rotated the sheared)
 *
 *	f(X,Y,Z) =  X**2 * Q**2  +  Y**2 * R**2  -  R**2 * Q**2 = 0
 *
 *  where,
 *		R = a + ((c - a)/|H'|)*Z 
 *		Q = b + ((d - b)/|H'|)*Z
 *
 *  When the equation is scaled so the A, B, and the sheared H are
 *  unit length, as is done here, the equation can be coerced back
 *  into this same form with R and Q now being:
 *
 *		R = 1 + (c/a - 1)*Z
 *		Q = 1 + (d/b - 1)*Z
 *
 *  The gradient of f(x,y,z) = 0 is:
 *
 *	df/dx = 2 * x * Q**2
 *	df/dy = 2 * y * R**2
 *	df/dz = x**2 * 2 * Q * dQ/dz + y**2 * 2 * R * dR/dz
 *	      - R**2 * 2 * Q * dQ/dz - Q**2 * 2 * R * dR/dz
 *	      = 2 [(x**2 - R**2) * Q * dQ/dz + (y**2 - Q**2) * R * dR/dz]
 *
 *  where,
 *		dR/dz = (c/a - 1)
 *		dQ/dz = (d/b - 1)
 *
 *  [in the *unscaled* case these would be (c - a)/|H'| and (d - b)/|H'|]
 *  Since the gradient (normal) needs to be rescaled to unit length
 *  after mapping back to absolute coordinates, we divide the 2 out of
 *  the above expressions.
 */
void
rt_tgc_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct tgc_specific	*tgc =
	(struct tgc_specific *)stp->st_specific;
	FAST fastf_t	Q;
	FAST fastf_t	R;
	LOCAL vect_t	stdnorm;

	/* Hit point */
	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );

	/* Hits on the end plates are easy */
	switch( hitp->hit_surfno )  {
	case TGC_NORM_TOP:
		VMOVE( hitp->hit_normal, tgc->tgc_N );
		break;
	case TGC_NORM_BOT:
		VREVERSE( hitp->hit_normal, tgc->tgc_N );
		break;
	case TGC_NORM_BODY:
		/* Compute normal, given hit point on standard (unit) cone */
		R = 1 + tgc->tgc_CdAm1 * hitp->hit_vpriv[Z];
		Q = 1 + tgc->tgc_DdBm1 * hitp->hit_vpriv[Z];
		stdnorm[X] = hitp->hit_vpriv[X] * Q * Q;
		stdnorm[Y] = hitp->hit_vpriv[Y] * R * R;
		stdnorm[Z] = (hitp->hit_vpriv[X]*hitp->hit_vpriv[X] - R*R)
		    * Q * tgc->tgc_DdBm1
		    + (hitp->hit_vpriv[Y]*hitp->hit_vpriv[Y] - Q*Q)
		    * R * tgc->tgc_CdAm1;
		MAT4X3VEC( hitp->hit_normal, tgc->tgc_invRtShSc, stdnorm );
		/*XXX - save scale */
		VUNITIZE( hitp->hit_normal );
		break;
	default:
		bu_log("rt_tgc_norm: bad surfno=%d\n", hitp->hit_surfno);
		break;
	}
}

/*
 *			R T _ T G C _ U V
 */
void
rt_tgc_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct tgc_specific	*tgc =
	(struct tgc_specific *)stp->st_specific;
	LOCAL vect_t work;
	LOCAL vect_t pprime;
	FAST fastf_t len;

	/* hit_point is on surface;  project back to unit cylinder,
	 * creating a vector from vertex to hit point.
	 */
	VSUB2( work, hitp->hit_point, tgc->tgc_V );
	MAT4X3VEC( pprime, tgc->tgc_ScShR, work );

	switch( hitp->hit_surfno )  {
	case TGC_NORM_BODY:
		/* scale coords to unit circle (they are already scaled by bottom plate radii) */
		pprime[X] *= tgc->tgc_A / (tgc->tgc_A*( 1.0 - pprime[Z]) + tgc->tgc_C*pprime[Z]);
		pprime[Y] *= tgc->tgc_B / (tgc->tgc_B*( 1.0 - pprime[Z]) + tgc->tgc_D*pprime[Z]);
		uvp->uv_u = atan2( pprime[Y], pprime[X] ) / bn_twopi + 0.5;
		uvp->uv_v = pprime[Z];		/* height */
		break;
	case TGC_NORM_TOP:
		/* top plate */
		/* scale coords to unit circle (they are already scaled by bottom plate radii) */
		pprime[X] *= tgc->tgc_A / tgc->tgc_C;
		pprime[Y] *= tgc->tgc_B / tgc->tgc_D;
		uvp->uv_u = atan2( pprime[Y], pprime[X] ) / bn_twopi + 0.5;
		len = sqrt(pprime[X]*pprime[X]+pprime[Y]*pprime[Y]);
		uvp->uv_v = len;		/* rim v = 1 */
		break;
	case TGC_NORM_BOT:
		/* bottom plate */
		len = sqrt(pprime[X]*pprime[X]+pprime[Y]*pprime[Y]);
		uvp->uv_u = atan2( pprime[Y], pprime[X] ) / bn_twopi + 0.5;
		uvp->uv_v = 1 - len;	/* rim v = 0 */
		break;
	}

	if( uvp->uv_u < 0.0 )
		uvp->uv_u = 0.0;
	else if( uvp->uv_u > 1.0 )
		uvp->uv_u = 1.0;
	if( uvp->uv_v < 0.0 )
		uvp->uv_v = 0.0;
	else if( uvp->uv_v > 1.0 )
		uvp->uv_v = 1.0;

	/* uv_du should be relative to rotation, uv_dv relative to height */
	uvp->uv_du = uvp->uv_dv = 0;
}


/*
 *			R T _ T G C _ F R E E
 */
void
rt_tgc_free(struct soltab *stp)
{
	register struct tgc_specific	*tgc =
	(struct tgc_specific *)stp->st_specific;

	bu_free( (char *)tgc, "tgc_specific");
}

int
rt_tgc_class(void)
{
	return(0);
}


/*
 *			R T _ T G C _ I M P O R T
 *
 *  Import a TGC from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_tgc_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_tgc_internal	*tip;
	union record		*rp;
	LOCAL fastf_t	vec[3*6];

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_tgc_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_TGC;
	ip->idb_meth = &rt_functab[ID_TGC];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_tgc_internal), "rt_tgc_internal");
	tip = (struct rt_tgc_internal *)ip->idb_ptr;
	tip->magic = RT_TGC_INTERNAL_MAGIC;

	/* Convert from database to internal format */
	rt_fastf_float( vec, rp->s.s_values, 6 );

	/* Apply modeling transformations */
	MAT4X3PNT( tip->v, mat, &vec[0*3] );
	MAT4X3VEC( tip->h, mat, &vec[1*3] );
	MAT4X3VEC( tip->a, mat, &vec[2*3] );
	MAT4X3VEC( tip->b, mat, &vec[3*3] );
	MAT4X3VEC( tip->c, mat, &vec[4*3] );
	MAT4X3VEC( tip->d, mat, &vec[5*3] );

	return(0);		/* OK */
}

/*
 *			R T _ T G C _ E X P O R T
 */
int
rt_tgc_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_tgc_internal	*tip;
	union record		*rec;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_TGC && ip->idb_type != ID_REC )  return(-1);
	tip = (struct rt_tgc_internal *)ip->idb_ptr;
	RT_TGC_CK_MAGIC(tip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "tgc external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->s.s_type = GENTGC;

	/* NOTE: This also converts to dbfloat_t */
	VSCALE( &rec->s.s_values[0], tip->v, local2mm );
	VSCALE( &rec->s.s_values[3], tip->h, local2mm );
	VSCALE( &rec->s.s_values[6], tip->a, local2mm );
	VSCALE( &rec->s.s_values[9], tip->b, local2mm );
	VSCALE( &rec->s.s_values[12], tip->c, local2mm );
	VSCALE( &rec->s.s_values[15], tip->d, local2mm );

	return(0);
}

/*
 *			R T _ T G C _ I M P O R T 5
 *
 *  Import a TGC from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_tgc_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_tgc_internal	*tip;
	fastf_t			vec[3*6];

	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 3*6 );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_TGC;
	ip->idb_meth = &rt_functab[ID_TGC];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_tgc_internal), "rt_tgc_internal");

	tip = (struct rt_tgc_internal *)ip->idb_ptr;
	tip->magic = RT_TGC_INTERNAL_MAGIC;

	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)vec, ep->ext_buf, 3*6 );

	/* Apply modeling transformations */
	MAT4X3PNT( tip->v, mat, &vec[0*3] );
	MAT4X3VEC( tip->h, mat, &vec[1*3] );
	MAT4X3VEC( tip->a, mat, &vec[2*3] );
	MAT4X3VEC( tip->b, mat, &vec[3*3] );
	MAT4X3VEC( tip->c, mat, &vec[4*3] );
	MAT4X3VEC( tip->d, mat, &vec[5*3] );

	return(0);		/* OK */
}

/*
 *			R T _ T G C _ E X P O R T 5
 */
int
rt_tgc_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_tgc_internal	*tip;
	fastf_t			vec[3*6];

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_TGC && ip->idb_type != ID_REC )  return(-1);
	tip = (struct rt_tgc_internal *)ip->idb_ptr;
	RT_TGC_CK_MAGIC(tip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 3*6;
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "tgc external");

	/* scale 'em into local buffer */
	VSCALE( &vec[0*3], tip->v, local2mm );
	VSCALE( &vec[1*3], tip->h, local2mm );
	VSCALE( &vec[2*3], tip->a, local2mm );
	VSCALE( &vec[3*3], tip->b, local2mm );
	VSCALE( &vec[4*3], tip->c, local2mm );
	VSCALE( &vec[5*3], tip->d, local2mm );

	/* Convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, 3*6 );

	return(0);
}

/*
 *			R T _ T G C _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_tgc_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_tgc_internal	*tip =
	(struct rt_tgc_internal *)ip->idb_ptr;
	char	buf[256];
	double	angles[5];
	vect_t	unitv;
	fastf_t	Hmag;

	RT_TGC_CK_MAGIC(tip);
	bu_vls_strcat( str, "truncated general cone (TGC)\n");

	sprintf(buf, "\tV (%g, %g, %g)\n",
	    tip->v[X] * mm2local,
	    tip->v[Y] * mm2local,
	    tip->v[Z] * mm2local );
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tTop (%g, %g, %g)\n",
	    (tip->v[X] + tip->h[X]) * mm2local,
	    (tip->v[Y] + tip->h[Y]) * mm2local,
	    (tip->v[Z] + tip->h[Z]) * mm2local );
	bu_vls_strcat( str, buf );

	Hmag = MAGNITUDE(tip->h);
	sprintf(buf, "\tH (%g, %g, %g) mag=%g\n",
	    tip->h[X] * mm2local,
	    tip->h[Y] * mm2local,
	    tip->h[Z] * mm2local,
	    Hmag * mm2local);
	bu_vls_strcat( str, buf );
	if( Hmag < VDIVIDE_TOL )  {
		bu_vls_strcat( str, "H vector is zero!\n");
	} else {
		register double	f = 1/Hmag;
		VSCALE( unitv, tip->h, f );
		rt_find_fallback_angle( angles, unitv );
		rt_pr_fallback_angle( str, "\tH", angles );
	}

	sprintf(buf, "\tA (%g, %g, %g) mag=%g\n",
	    tip->a[X] * mm2local,
	    tip->a[Y] * mm2local,
	    tip->a[Z] * mm2local,
	    MAGNITUDE(tip->a) * mm2local);
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tB (%g, %g, %g) mag=%g\n",
	    tip->b[X] * mm2local,
	    tip->b[Y] * mm2local,
	    tip->b[Z] * mm2local,
	    MAGNITUDE(tip->b) * mm2local);
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tC (%g, %g, %g) mag=%g\n",
	    tip->c[X] * mm2local,
	    tip->c[Y] * mm2local,
	    tip->c[Z] * mm2local,
	    MAGNITUDE(tip->c) * mm2local);
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tD (%g, %g, %g) mag=%g\n",
	    tip->d[X] * mm2local,
	    tip->d[Y] * mm2local,
	    tip->d[Z] * mm2local,
	    MAGNITUDE(tip->d) * mm2local);
	bu_vls_strcat( str, buf );

	VCROSS( unitv, tip->c, tip->d );
	VUNITIZE( unitv );
	rt_find_fallback_angle( angles, unitv );
	rt_pr_fallback_angle( str, "\tAxB", angles );

	return(0);
}

/*
 *			R T _ T G C _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_tgc_ifree(struct rt_db_internal *ip)
{
	RT_CK_DB_INTERNAL(ip);
	bu_free( ip->idb_ptr, "tgc ifree" );
	ip->idb_ptr = GENPTR_NULL;
}

/*
 *			R T _ T G C _ P L O T
 */
int
rt_tgc_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct rt_tgc_internal	*tip;
	register int		i;
	LOCAL fastf_t		top[16*3];
	LOCAL fastf_t		bottom[16*3];
	LOCAL vect_t		work;		/* Vec addition work area */

	RT_CK_DB_INTERNAL(ip);
	tip = (struct rt_tgc_internal *)ip->idb_ptr;
	RT_TGC_CK_MAGIC(tip);

	rt_ell_16pts( bottom, tip->v, tip->a, tip->b );
	VADD2( work, tip->v, tip->h );
	rt_ell_16pts( top, work, tip->c, tip->d );

	/* Draw the top */
	RT_ADD_VLIST( vhead, &top[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ )  {
		RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	/* Draw the bottom */
	RT_ADD_VLIST( vhead, &bottom[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ )  {
		RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	/* Draw connections */
	for( i=0; i<16; i += 4 )  {
		RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}
	return(0);
}

/*
 *			R T _ T G C _ C U R V E
 *
 *  Return the curvature of the TGC.
 */
void
rt_tgc_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	register struct tgc_specific *tgc =
	(struct tgc_specific *)stp->st_specific;
	fastf_t	R, Q, R2, Q2;
	mat_t	M, dN, mtmp;
	vect_t	gradf, tmp, u, v;
	fastf_t	a, b, c, scale;
	vect_t	vec1, vec2;

	if( hitp->hit_surfno != TGC_NORM_BODY ) {
		/* We hit an end plate.  Choose any tangent vector. */
		bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
		cvp->crv_c1 = cvp->crv_c2 = 0;
		return;
	}

	R = 1 + tgc->tgc_CdAm1 * hitp->hit_vpriv[Z];
	Q = 1 + tgc->tgc_DdBm1 * hitp->hit_vpriv[Z];
	R2 = R*R;
	Q2 = Q*Q;

	/*
	 * Compute derivatives of the gradient (normal) field
	 * in ideal coords.  This is a symmetric matrix with
	 * the columns (dNx, dNy, dNz).
	 */
	MAT_IDN( dN );
	dN[0] = Q2;
	dN[2] = dN[8] = 2.0*Q*tgc->tgc_DdBm1 * hitp->hit_vpriv[X];
	dN[5] = R2;
	dN[6] = dN[9] = 2.0*R*tgc->tgc_CdAm1 * hitp->hit_vpriv[Y];
	dN[10] = tgc->tgc_DdBm1*tgc->tgc_DdBm1 * hitp->hit_vpriv[X]*hitp->hit_vpriv[X]
	    + tgc->tgc_CdAm1*tgc->tgc_CdAm1 * hitp->hit_vpriv[Y]*hitp->hit_vpriv[Y]
	    - tgc->tgc_DdBm1*tgc->tgc_DdBm1 * R2
	    - tgc->tgc_CdAm1*tgc->tgc_CdAm1 * Q2
	    - 4.0*tgc->tgc_CdAm1*tgc->tgc_DdBm1 * R*Q;

	/* M = At * dN * A */
	bn_mat_mul( mtmp, dN, tgc->tgc_ScShR );
	bn_mat_mul( M, tgc->tgc_invRtShSc, mtmp );

	/* XXX - determine the scaling */
	gradf[X] = Q2 * hitp->hit_vpriv[X];
	gradf[Y] = R2 * hitp->hit_vpriv[Y];
	gradf[Z] = (hitp->hit_vpriv[X]*hitp->hit_vpriv[X] - R2) * Q * tgc->tgc_DdBm1 +
	    (hitp->hit_vpriv[Y]*hitp->hit_vpriv[Y] - Q2) * R * tgc->tgc_CdAm1;
	MAT4X3VEC( tmp, tgc->tgc_invRtShSc, gradf );
	scale = -1.0 / MAGNITUDE(tmp);
	/* XXX */

	/*
	 * choose a tangent plane coordinate system
	 *  (u, v, normal) form a right-handed triple
	 */
	bn_vec_ortho( u, hitp->hit_normal );
	VCROSS( v, hitp->hit_normal, u );

	/* find the second fundamental form */
	MAT4X3VEC( tmp, M, u );
	a = VDOT(u, tmp) * scale;
	b = VDOT(v, tmp) * scale;
	MAT4X3VEC( tmp, M, v );
	c = VDOT(v, tmp) * scale;

	bn_eigen2x2( &cvp->crv_c1, &cvp->crv_c2, vec1, vec2, a, b, c );
	VCOMB2( cvp->crv_pdir, vec1[X], u, vec1[Y], v );
	VUNITIZE( cvp->crv_pdir );
}

/*
 *			R T _ T G C _ T E S S
 *
 *  Tesselation of the TGC.
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */

struct tgc_pts
{
	point_t		pt;
	vect_t		tan_axb;
	struct vertex	*v;
	char		dont_use;
};

#define	MAX_RATIO	10.0	/* maximum allowed height-to-width ration for triangles */

/* version using tolerances */
int
rt_tgc_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct shell		*s;		/* shell to hold facetted TGC */
	struct faceuse		*fu,*fu_top,*fu_base;
	struct rt_tgc_internal	*tip;
	fastf_t			radius;		/* bounding sphere radius */
	fastf_t			max_radius,min_radius; /* max/min of a,b,c,d */
	fastf_t			h,a,b,c,d;	/* lengths of TGC vectors */
	fastf_t			inv_length;	/* 1.0/length of a vector */
	vect_t			unit_a,unit_b,unit_c,unit_d; /* units vectors in a,b,c,d directions */
	fastf_t			rel,abs,norm;	/* interpreted tolerances */
	fastf_t			alpha_tol;	/* final tolerance for ellipse parameter */
	int			nells;		/* total number of ellipses */
	int			nsegs;		/* number of vertices/ellipse */
	vect_t			*A;		/* array of A vectors for ellipses */
	vect_t			*B;		/* array of B vectors for ellipses */
	fastf_t			*factors;	/* array of ellipse locations along height vector */
	vect_t			vtmp;
	vect_t			normal;		/* normal vector */
	vect_t			rev_norm;	/* reverse normal */
	struct tgc_pts		**pts;		/* array of points (pts[ellipse#][seg#]) */
	struct bu_ptbl		verts;		/* table of vertices used for top and bottom faces */
	struct bu_ptbl		faces;		/* table of faceuses for nmg_gluefaces */
	struct vertex		**v[3];		/* array for making triangular faces */
	int			i;

	RT_CK_DB_INTERNAL(ip);
	tip = (struct rt_tgc_internal *)ip->idb_ptr;
	RT_TGC_CK_MAGIC(tip);

	if( ttol->abs > 0.0 && ttol->abs < tol->dist )
	{
		bu_log( "tesselation tolerance is %fmm while calculational tolerance is %fmm\n",
			ttol->abs , tol->dist );
		bu_log( "Cannot tesselate a TGC to finer tolerance than the calculational tolerance\n" );
		return( -1 );
	}

	h = MAGNITUDE( tip->h );
	a = MAGNITUDE( tip->a );
	if( 2.0*a <= tol->dist )
		a = 0.0;
	b = MAGNITUDE( tip->b );
	if( 2.0*b <= tol->dist )
		b = 0.0;
	c = MAGNITUDE( tip->c );
	if( 2.0*c <= tol->dist )
		c = 0.0;
	d = MAGNITUDE( tip->d );
	if( 2.0*d <= tol->dist )
		d = 0.0;

	if( a == 0.0 && b == 0.0 && (c == 0.0 || d == 0.0) )
	{
		bu_log( "Illegal TGC a, b, and c or d less than tolerance\n" );
		return( -1);
	}
	else if( c == 0.0 && d == 0.0 && (a == 0.0 || b == 0.0 ) )
	{
		bu_log( "Illegal TGC c, d, and a or b less than tolerance\n" );
		return( -1 );
	}

	if( a > 0.0 )
	{
		inv_length = 1.0/a;
		VSCALE( unit_a, tip->a, inv_length );
	}
	if( b > 0.0 )
	{
		inv_length = 1.0/b;
		VSCALE( unit_b, tip->b, inv_length );
	}
	if( c > 0.0 )
	{
		inv_length = 1.0/c;
		VSCALE( unit_c, tip->c, inv_length );
	}
	if( d > 0.0 )
	{
		inv_length = 1.0/d;
		VSCALE( unit_d, tip->d, inv_length );
	}

	/* get bounding sphere radius for relative tolerance */
	radius = h/2.0;
	max_radius = 0.0;
	if( a > max_radius )
		max_radius = a;
	if( b > max_radius )
		max_radius = b;
	if( c > max_radius )
		max_radius = c;
	if( d > max_radius )
		max_radius = d;

	if( max_radius > radius )
		radius = max_radius;

	min_radius = MAX_FASTF;
	if( a < min_radius && a > 0.0 )
		min_radius = a;
	if( b < min_radius && b > 0.0 )
		min_radius = b;
	if( c < min_radius && c > 0.0 )
		min_radius = c;
	if( d < min_radius && d > 0.0 )
		min_radius = d;

	if( ttol->abs <= 0.0 && ttol->rel <= 0.0 && ttol->norm <= 0.0 )
	{
		/* no tolerances specified, use 10% relative tolerance */
		if( (radius * 0.2) < max_radius )
			alpha_tol = 2.0 * acos( 1.0 - 2.0 * radius * 0.1 / max_radius );
		else
			alpha_tol = bn_halfpi;
	}
	else
	{
		if( ttol->abs > 0.0 )
			abs = 2.0 * acos( 1.0 - ttol->abs/max_radius );
		else
			abs = bn_halfpi;

		if( ttol->rel > 0.0 )
		{
			if( ttol->rel * 2.0 * radius < max_radius )
				rel = 2.0 * acos( 1.0 - ttol->rel * 2.0 * radius/max_radius );
			else
				rel = bn_halfpi;
		}
		else
			rel = bn_halfpi;

		if( ttol->norm > 0.0 )
		{
			fastf_t norm_top,norm_bot;

			if( a<b )
				norm_bot = 2.0 * atan( tan( ttol->norm ) * (a/b) );
			else
				norm_bot = 2.0 * atan( tan( ttol->norm ) * (b/a) );

			if( c<d )
				norm_top = 2.0 * atan( tan( ttol->norm ) * (c/d) );
			else
				norm_top = 2.0 * atan( tan( ttol->norm ) * (d/c) );

			if( norm_bot < norm_top )
				norm = norm_bot;
			else
				norm = norm_top;
		}
		else
			norm = bn_halfpi;

		if( abs < rel )
			alpha_tol = abs;
		else
			alpha_tol = rel;
		if( norm < alpha_tol )
			alpha_tol = norm;
	}

	/* get number of segments per quadrant */
	nsegs = (int)(bn_halfpi / alpha_tol + 0.9999);
	if( nsegs < 2 )
		nsegs = 2;

	/* and for complete ellipse */
	nsegs *= 4;

	/* get nunber and placement of intermediate ellipses */
	{
		fastf_t ratios[4],max_ratio;
		fastf_t new_ratio = 0;
		int which_ratio;
		fastf_t len_ha,len_hb;
		vect_t ha,hb;
		fastf_t ang;
		fastf_t sin_ang,cos_ang,cos_m_1_sq, sin_sq;
		fastf_t len_A, len_B, len_C, len_D;
		int bot_ell=0, top_ell=1;
		int reversed=0;

		nells = 2;

		max_ratio = MAX_RATIO + 1.0;

		factors = (fastf_t *)bu_malloc( nells*sizeof( fastf_t ), "factors" );
		A = (vect_t *)bu_malloc( nells*sizeof( vect_t ), "A vectors" );
		B = (vect_t *)bu_malloc( nells*sizeof( vect_t ), "B vectors" );

		factors[bot_ell] = 0.0;
		factors[top_ell] = 1.0;
		VMOVE( A[bot_ell], tip->a );
		VMOVE( A[top_ell], tip->c );
		VMOVE( B[bot_ell], tip->b );
		VMOVE( B[top_ell], tip->d );

		/* make sure that AxB points in the general direction of H */
		VCROSS( vtmp , A[0] , B[0] );
		if( VDOT( vtmp , tip->h ) < 0.0 )
		{
			VMOVE( A[bot_ell], tip->b );
			VMOVE( A[top_ell], tip->d );
			VMOVE( B[bot_ell], tip->a );
			VMOVE( B[top_ell], tip->c );
			reversed = 1;
		}
		ang = 2.0*bn_pi/((double)nsegs);
		sin_ang = sin( ang );
		cos_ang = cos( ang );
		cos_m_1_sq = (cos_ang - 1.0)*(cos_ang - 1.0);
		sin_sq = sin_ang*sin_ang;

		VJOIN2( ha, tip->h, 1.0, tip->c, -1.0, tip->a )
		VJOIN2( hb, tip->h, 1.0, tip->d, -1.0, tip->b )
		len_ha = MAGNITUDE( ha );
		len_hb = MAGNITUDE( hb );

		while( max_ratio > MAX_RATIO )
		{
			fastf_t tri_width;

			len_A = MAGNITUDE( A[bot_ell] );
			if( 2.0*len_A <= tol->dist )
				len_A = 0.0;
			len_B = MAGNITUDE( B[bot_ell] );
			if( 2.0*len_B <= tol->dist )
				len_B = 0.0;
			len_C = MAGNITUDE( A[top_ell] );
			if( 2.0*len_C <= tol->dist )
				len_C = 0.0;
			len_D = MAGNITUDE( B[top_ell] );
			if( 2.0*len_D <= tol->dist )
				len_D = 0.0;

			if( (len_B > 0.0 && len_D > 0.0) ||
				(len_B > 0.0 && (len_D == 0.0 && len_C == 0.0 )) )
			{
				tri_width = sqrt( cos_m_1_sq*len_A*len_A + sin_sq*len_B*len_B );
				ratios[0] = (factors[top_ell] - factors[bot_ell])*len_ha
						/tri_width;
			}
			else
				ratios[0] = 0.0;

			if( (len_A > 0.0 && len_C > 0.0) ||
				( len_A > 0.0 && (len_C == 0.0 && len_D == 0.0)) )
			{
				tri_width = sqrt( sin_sq*len_A*len_A + cos_m_1_sq*len_B*len_B );
				ratios[1] = (factors[top_ell] - factors[bot_ell])*len_hb
						/tri_width;
			}
			else
				ratios[1] = 0.0;

			if( (len_D > 0.0 && len_B > 0.0) ||
				(len_D > 0.0 && (len_A == 0.0 && len_B == 0.0)) )
			{
				tri_width = sqrt( cos_m_1_sq*len_C*len_C + sin_sq*len_D*len_D );
				ratios[2] = (factors[top_ell] - factors[bot_ell])*len_ha
						/tri_width;
			}
			else
				ratios[2] = 0.0;

			if( (len_C > 0.0 && len_A > 0.0) ||
				(len_C > 0.0 && (len_A == 0.0 && len_B == 0.0)) )
			{
				tri_width = sqrt( sin_sq*len_C*len_C + cos_m_1_sq*len_D*len_D );
				ratios[3] = (factors[top_ell] - factors[bot_ell])*len_hb
						/tri_width;
			}
			else
				ratios[3] = 0.0;

			which_ratio = -1;
			max_ratio = 0.0;

			for( i=0 ; i<4 ; i++ )
			{
				if( ratios[i] > max_ratio )
				{
					max_ratio = ratios[i];
					which_ratio = i;
				}
			}

			if( len_A == 0.0 && len_B == 0.0 && len_C == 0.0 && len_D == 0.0 )
			{
				if( top_ell == nells - 1 )
				{
					VMOVE( A[top_ell-1], A[top_ell] )
					VMOVE( B[top_ell-1], A[top_ell] )
					factors[top_ell-1] = factors[top_ell];
				}
				else if( bot_ell == 0 )
				{
					for( i=0 ; i<nells-1 ; i++ )
					{
						VMOVE( A[i], A[i+1] )
						VMOVE( B[i], B[i+1] )
						factors[i] = factors[i+1];
					}
				}

				nells -= 1;
				break;
			}

			if( max_ratio <= MAX_RATIO )
				break;

			if( which_ratio == 0 || which_ratio == 1 )
			{
				new_ratio = MAX_RATIO/max_ratio;
				if( bot_ell == 0 && new_ratio > 0.5 )
					new_ratio = 0.5;
			}
			else if( which_ratio == 2 || which_ratio == 3 )
			{
				new_ratio = 1.0 - MAX_RATIO/max_ratio;
				if( top_ell == nells - 1 && new_ratio < 0.5 )
					new_ratio = 0.5;
			}
			else	/* no MAX??? */
			{
				bu_log( "rt_tgc_tess: Should never get here!!\n" );
				rt_bomb( "rt_tgc_tess: Should never get here!!\n" );
			}

			nells++;
			factors = (fastf_t *)bu_realloc( factors, nells*sizeof( fastf_t ), "factors" );
			A = (vect_t *)bu_realloc( A, nells*sizeof( vect_t ), "A vectors" );
			B = (vect_t *)bu_realloc( B, nells*sizeof( vect_t ), "B vectors" );

			for( i=nells-1 ; i>top_ell ; i-- )
			{
				factors[i] = factors[i-1];
				VMOVE( A[i], A[i-1] )
				VMOVE( B[i], B[i-1] )
			}

			factors[top_ell] = factors[bot_ell] +
				new_ratio*(factors[top_ell+1] - factors[bot_ell]);

			if( reversed )
			{
				VBLEND2( A[top_ell], (1.0-factors[top_ell]), tip->b, factors[top_ell], tip->d )
				VBLEND2( B[top_ell], (1.0-factors[top_ell]), tip->a, factors[top_ell], tip->c )
			}
			else
			{
				VBLEND2( A[top_ell], (1.0-factors[top_ell]), tip->a, factors[top_ell], tip->c )
				VBLEND2( B[top_ell], (1.0-factors[top_ell]), tip->b, factors[top_ell], tip->d )
			}

			if( which_ratio == 0 || which_ratio == 1 )
			{
				top_ell++;
				bot_ell++;
			}

		}

	}

	/* get memory for points */
	pts = (struct tgc_pts **)bu_calloc( nells , sizeof( struct tgc_pts *) , "rt_tgc_tess: pts" );
	for( i=0 ; i<nells ; i++ )
		pts[i] = (struct tgc_pts *)bu_calloc( nsegs , sizeof( struct tgc_pts ) , "rt_tgc_tess: pts" );

	/* calculate geometry for points */
	for( i=0 ; i<nells ; i++ )
	{
		fastf_t h_factor;
		int j;

		h_factor = factors[i];
		for( j=0 ; j<nsegs ; j++ )
		{
			double alpha;
			double sin_alpha,cos_alpha;

			alpha = bn_twopi * (double)(2*j+1)/(double)(2*nsegs);
			sin_alpha = sin( alpha );
			cos_alpha = cos( alpha );

			/* vertex geometry */
			if( i == 0 && a == 0.0 && b == 0.0 )
				VMOVE( pts[i][j].pt , tip->v )
			else if( i == nells-1 && c == 0.0 && d == 0.0 )
				VADD2( pts[i][j].pt, tip->v, tip->h )
			else
				VJOIN3( pts[i][j].pt , tip->v , h_factor , tip->h , cos_alpha , A[i] , sin_alpha , B[i] )

			/* Storing the tangent here while sines and cosines are available */
			if( i == 0 && a == 0.0 && b == 0.0 )
				VCOMB2( pts[0][j].tan_axb, -sin_alpha, unit_c, cos_alpha, unit_d )
			else if( i == nells-1 && c == 0.0 && d == 0.0 )
				VCOMB2( pts[i][j].tan_axb, -sin_alpha, unit_a, cos_alpha, unit_b )
			else
				VCOMB2( pts[i][j].tan_axb , -sin_alpha , A[i] , cos_alpha , B[i] )
		}
	}

	/* make sure no edges will be created with length < tol->dist */
	for( i=0 ; i<nells ; i++ )
	{
		int j;
		point_t curr_pt;
		vect_t edge_vect;

		if( i == 0 && (a == 0.0 || b == 0.0) )
			continue;
		else if( i == nells-1 && (c == 0.0 || d == 0.0) )
			continue;

		VMOVE( curr_pt, pts[i][0].pt )
		for( j=1 ; j<nsegs ; j++ )
		{
			fastf_t edge_len_sq;

			VSUB2( edge_vect, curr_pt, pts[i][j].pt )
			edge_len_sq = MAGSQ( edge_vect );
			if(edge_len_sq > tol->dist_sq )
				VMOVE( curr_pt, pts[i][j].pt )
			else
			{
				/* don't use this point, it will create a too short edge */
				pts[i][j].dont_use = 'n';
			}
		}
	}

	/* make region, shell, vertex */
	*r = nmg_mrsv( m );
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	bu_ptbl_init( &verts , 64, " &verts ");
	bu_ptbl_init( &faces , 64, " &faces ");
	/* Make bottom face */
	if( a > 0.0 && b > 0.0 )
	{
		for( i=nsegs-1 ; i>=0 ; i-- ) /* reverse order to get outward normal */
		{
			if( !pts[0][i].dont_use )
				bu_ptbl_ins( &verts , (long *)&pts[0][i].v );
		}

		if( BU_PTBL_END( &verts ) > 2 )
		{
			fu_base = nmg_cmface( s , (struct vertex ***)BU_PTBL_BASEADDR( &verts ), BU_PTBL_END( &verts ) );
			bu_ptbl_ins( &faces , (long *)fu_base );
		}
		else
			fu_base = (struct faceuse *)NULL;
	}
	else
		fu_base = (struct faceuse *)NULL;
	

	/* Make top face */
	if( c > 0.0 && d > 0.0 )
	{
		bu_ptbl_reset( &verts );
		for( i=0 ; i<nsegs ; i++ )
		{
			if( !pts[nells-1][i].dont_use )
				bu_ptbl_ins( &verts , (long *)&pts[nells-1][i].v );
		}

		if( BU_PTBL_END( &verts ) > 2 )
		{
			fu_top = nmg_cmface( s , (struct vertex ***)BU_PTBL_BASEADDR( &verts ), BU_PTBL_END( &verts ) );
			bu_ptbl_ins( &faces , (long *)fu_top );
		}
		else
			fu_top = (struct faceuse *)NULL;
	}
	else
		fu_top = (struct faceuse *)NULL;

	/* Free table of vertices */
	bu_ptbl_free( &verts );

	/* Make triangular faces */
	for( i=0 ; i<nells-1 ; i++ )
	{
		int j;
		struct vertex **curr_top;
		struct vertex **curr_bot;

		curr_bot = &pts[i][0].v;
		curr_top = &pts[i+1][0].v;
		for( j=0 ; j<nsegs ; j++ )
		{
			int k;

			k = j+1;
			if( k == nsegs )
				k = 0;
			if( i != 0 || a > 0.0 || b > 0.0 )
			{
				if( !pts[i][k].dont_use )
				{
					v[0] = curr_bot;
					v[1] = &pts[i][k].v;
					if( i+1 == nells-1 && c == 0.0 && d == 0.0 )
						v[2] = &pts[i+1][0].v;
					else
						v[2] = curr_top;
					fu = nmg_cmface( s , v , 3 );
					bu_ptbl_ins( &faces , (long *)fu );
					curr_bot = &pts[i][k].v;
				}
			}

			if( i != nells-2 || c > 0.0 || d > 0.0 )
			{
				if( !pts[i+1][k].dont_use )
				{
					v[0] = &pts[i+1][k].v;
					v[1] = curr_top;
					if( i == 0 && a == 0.0 && b == 0.0 )
						v[2] = &pts[i][0].v;
					else
						v[2] = curr_bot;
					fu = nmg_cmface( s , v , 3 );
					bu_ptbl_ins( &faces , (long *)fu );
					curr_top = &pts[i+1][k].v;
				}
			}
		}
	}

	/* Assign geometry */
	for( i=0 ; i<nells ; i++ )
	{
		int j;

		for( j=0 ; j<nsegs ; j++ )
		{
			point_t pt_geom;
			double alpha;
			double sin_alpha,cos_alpha;

			alpha = bn_twopi * (double)(2*j+1)/(double)(2*nsegs);
			sin_alpha = sin( alpha );
			cos_alpha = cos( alpha );

			/* vertex geometry */
			if( i == 0 && a == 0.0 && b == 0.0 )
			{
				if( j == 0 )
					nmg_vertex_gv( pts[0][0].v, tip->v );
			}
			else if( i == nells-1 && c == 0.0 && d == 0.0 )
			{
				if( j == 0 )
				{
					VADD2( pt_geom, tip->v, tip->h );
					nmg_vertex_gv( pts[i][0].v , pt_geom );
				}
			}
			else if( pts[i][j].v )
				nmg_vertex_gv( pts[i][j].v , pts[i][j].pt );

			/* Storing the tangent here while sines and cosines are available */
			if( i == 0 && a == 0.0 && b == 0.0 )
				VCOMB2( pts[0][j].tan_axb, -sin_alpha, unit_c, cos_alpha, unit_d )
			else if( i == nells-1 && c == 0.0 && d == 0.0 )
				VCOMB2( pts[i][j].tan_axb, -sin_alpha, unit_a, cos_alpha, unit_b )
			else
				VCOMB2( pts[i][j].tan_axb , -sin_alpha , A[i] , cos_alpha , B[i] )
		}
	}

	/* Associate face plane equations */
	for( i=0 ; i<BU_PTBL_END( &faces ) ; i++ )
	{
		fu = (struct faceuse *)BU_PTBL_GET( &faces , i );
		NMG_CK_FACEUSE( fu );

		if( nmg_calc_face_g( fu ) )
		{
			bu_log( "rt_tess_tgc: failed to calculate plane equation\n" );
			nmg_pr_fu_briefly( fu, "" );
			return( -1 );
		}
	}


	/* Calculate vertexuse normals */
	for( i=0 ; i<nells ; i++ )
	{
		int j,k;

		k = i + 1;
		if( k == nells )
			k = i - 1;

		for( j=0 ; j<nsegs ; j++ )
		{
			vect_t tan_h;		/* vector tangent from one ellipse to next */
			struct vertexuse *vu;

			/* normal at vertex */
			if( i == nells - 1 )
			{
				if( c == 0.0 && d == 0.0 )
					VSUB2( tan_h , pts[i][0].pt , pts[k][j].pt )
				else if( k == 0 && c == 0.0 && d == 0.0 )
					VSUB2( tan_h , pts[i][j].pt , pts[k][0].pt )
				else
					VSUB2( tan_h , pts[i][j].pt , pts[k][j].pt )
			}
			else if( i == 0 )
			{
				if( a == 0.0 && b == 0.0 )
					VSUB2( tan_h , pts[k][j].pt , pts[i][0].pt )
				else if( k == nells-1 && c == 0.0 && d == 0.0 )
					VSUB2( tan_h , pts[k][0].pt , pts[i][j].pt )
				else
					VSUB2( tan_h , pts[k][j].pt , pts[i][j].pt )
			}
			else if( k == 0 && a == 0.0 && b == 0.0 )
				VSUB2( tan_h , pts[k][0].pt , pts[i][j].pt )
			else if( k == nells-1 && c == 0.0 && d == 0.0 )
				VSUB2( tan_h , pts[k][0].pt , pts[i][j].pt )
			else
				VSUB2( tan_h , pts[k][j].pt , pts[i][j].pt )

			VCROSS( normal , pts[i][j].tan_axb , tan_h );
			VUNITIZE( normal );
			VREVERSE( rev_norm , normal );

			if( !(i == 0 && a == 0.0 && b == 0.0) &&
			    !(i == nells-1 && c == 0.0 && d == 0.0 ) &&
			      pts[i][j].v )
			{
				for( BU_LIST_FOR( vu , vertexuse , &pts[i][j].v->vu_hd ) )
				{
					NMG_CK_VERTEXUSE( vu );

					fu = nmg_find_fu_of_vu( vu );
					NMG_CK_FACEUSE( fu );

					/* don't need vertexuse normals for faces that are really flat */
					if( fu == fu_base || fu->fumate_p == fu_base ||
					    fu == fu_top  || fu->fumate_p == fu_top )
						continue;

					if( fu->orientation == OT_SAME )
						nmg_vertexuse_nv( vu , normal );
					else if( fu->orientation == OT_OPPOSITE )
						nmg_vertexuse_nv( vu , rev_norm );
				}
			}
		}
	}

	/* Finished with storage, so free it */
	bu_free( (char *)factors, "rt_tgc_tess: factors" );
	bu_free( (char *)A , "rt_tgc_tess: A" );
	bu_free( (char *)B , "rt_tgc_tess: B" );
	for( i=0 ; i<nells ; i++ )
		bu_free( (char *)pts[i] , "rt_tgc_tess: pts[i]" );
	bu_free( (char *)pts , "rt_tgc_tess: pts" );

	/* mark real edges for top and bottom faces */
	for( i=0 ; i<2 ; i++ )
	{
		struct loopuse *lu;

		if( i == 0 )
			fu = fu_base;
		else
			fu = fu_top;

		if( fu == (struct faceuse *)NULL )
			continue;

		NMG_CK_FACEUSE( fu );

		for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			NMG_CK_LOOPUSE( lu );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				struct edge *e;

				NMG_CK_EDGEUSE( eu );
				e = eu->e_p;
				NMG_CK_EDGE( e );
				e->is_real = 1;
			}
		}
	}

	nmg_region_a( *r , tol );

	/* glue faces together */
	nmg_gluefaces( (struct faceuse **)BU_PTBL_BASEADDR( &faces) , BU_PTBL_END( &faces ), tol );
	bu_ptbl_free( &faces );

	return( 0 );
}

/*	R T _ T G C _ T N U R B
 *
 *  "Tessellate an TGC into a trimmed-NURB-NMG data structure.
 *  Computing NRUB surfaces and trimming curves to interpolate
 *  the parameters of the TGC
 *
 *  The process is to create the nmg  topology of the TGC fill it
 *  in with a unit cylinder geometry (i.e. unitcircle at the top (0,0,1)
 *  unit cylinder of radius 1, and unitcirlce at the bottom), and then 
 *  scale it with a perspective matrix derived from the parameters of the
 *  tgc. The result is three trimmed nub surfaces which interpolate the 
 *  parameters of  the original TGC.
 * 
 *  Returns -
 *	-1 	failure
 *	0	OK. *r points to nmgregion that holds this tesselation
 */

int
rt_tgc_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
{
	LOCAL struct rt_tgc_internal	*tip;

	struct shell			*s;
	struct vertex			*verts[2];
	struct vertex			**vertp[4];
	struct faceuse			* top_fu;
	struct faceuse			* cyl_fu;
	struct faceuse			* bot_fu;
	vect_t				uvw;
	struct loopuse			*lu;
	struct edgeuse			*eu;
	struct edgeuse			*top_eu;
	struct edgeuse			*bot_eu;

	mat_t 				mat;
	mat_t 				imat, omat, top_mat, bot_mat;
	vect_t 				anorm;
	vect_t 				bnorm;
	vect_t 				cnorm;


	/* Get the internal representation of the tgc */

	RT_CK_DB_INTERNAL(ip);
	tip = (struct rt_tgc_internal *) ip->idb_ptr;
	RT_TGC_CK_MAGIC(tip);

	/* Create the NMG Topology */

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST( shell, &(*r)->s_hd);


	/* Create transformation matrix  for the top cap surface*/

	MAT_IDN( omat );
	MAT_IDN( mat);
	
	omat[0] = MAGNITUDE(tip->c);
	omat[5] = MAGNITUDE(tip->d);
	omat[3] = tip->v[0] + tip->h[0];
	omat[7] = tip->v[1] + tip->h[1];
	omat[11] = tip->v[2] + tip->h[2];

	bn_mat_mul(imat, mat, omat);

        VMOVE(anorm, tip->c);
        VMOVE(bnorm, tip->d);
        VCROSS(cnorm, tip->c, tip->d);
        VUNITIZE(anorm);
        VUNITIZE(bnorm);
        VUNITIZE(cnorm);

        MAT_IDN( omat );

        VMOVE( &omat[0], anorm);
        VMOVE( &omat[4], bnorm);
        VMOVE( &omat[8], cnorm);


	bn_mat_mul(top_mat, omat, imat);

	/* Create topology for top cap surface */

	verts[0] = verts[1] = NULL;
	vertp[0] = &verts[0];
	top_fu = nmg_cmface(s, vertp, 1);

	lu = BU_LIST_FIRST( loopuse, &top_fu->lu_hd);
	NMG_CK_LOOPUSE(lu);
	eu= BU_LIST_FIRST( edgeuse, &lu->down_hd);
	NMG_CK_EDGEUSE(eu);
	top_eu = eu;

	VSET( uvw, 0,0,0);
	nmg_vertexuse_a_cnurb( eu->vu_p, uvw);
	VSET( uvw, 1, 0, 0);
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, uvw );
	eu = BU_LIST_NEXT( edgeuse, &eu->l);

	/* Top cap surface */
	nmg_tgc_disk( top_fu, top_mat, 0.0, 0 );

	/* Create transformation matrix  for the bottom cap surface*/

	MAT_IDN( omat );
	MAT_IDN( mat);
	
	omat[0] = MAGNITUDE(tip->a);
	omat[5] = MAGNITUDE(tip->b);
        omat[3] = tip->v[0];
        omat[7] = tip->v[1];
        omat[11] = tip->v[2];

        bn_mat_mul(imat, mat, omat);

        VMOVE(anorm, tip->a);
        VMOVE(bnorm, tip->b);
        VCROSS(cnorm, tip->a, tip->b);
        VUNITIZE(anorm);
        VUNITIZE(bnorm);
        VUNITIZE(cnorm);

        MAT_IDN( omat );

        VMOVE( &omat[0], anorm);
        VMOVE( &omat[4], bnorm);
        VMOVE( &omat[8], cnorm);

        bn_mat_mul(bot_mat, omat, imat);

	/* Create topology for bottom cap surface */

	vertp[0] = &verts[1];
	bot_fu = nmg_cmface(s, vertp, 1);

	lu = BU_LIST_FIRST( loopuse, &bot_fu->lu_hd);
	NMG_CK_LOOPUSE(lu);
	eu= BU_LIST_FIRST( edgeuse, &lu->down_hd);
	NMG_CK_EDGEUSE(eu);
	bot_eu = eu;

	VSET( uvw, 0,0,0);
	nmg_vertexuse_a_cnurb( eu->vu_p, uvw);
	VSET( uvw, 1, 0, 0);
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, uvw );


	nmg_tgc_disk( bot_fu, bot_mat, 0.0, 1 );

	/* Create topology for cylinder surface  */

	vertp[0] = &verts[0];
	vertp[1] = &verts[0];
	vertp[2] = &verts[1];
	vertp[3] = &verts[1];
	cyl_fu = nmg_cmface(s, vertp, 4);

	nmg_tgc_nurb_cyl( cyl_fu, top_mat, bot_mat);

	/* fuse top cylinder edge to matching edge on body of cylinder */
	lu = BU_LIST_FIRST( loopuse, &cyl_fu->lu_hd);

	eu= BU_LIST_FIRST( edgeuse, &lu->down_hd);

	nmg_je( top_eu, eu );

	eu= BU_LIST_LAST( edgeuse, &lu->down_hd);
	eu= BU_LIST_LAST( edgeuse, &eu->l);

	nmg_je( bot_eu, eu );
	nmg_region_a( *r,tol);

	return( 0 );
}


#define RAT  .707107

fastf_t nmg_tgc_unitcircle[36] = {
	1.0, 0.0, 0.0, 1.0,
	RAT, -RAT, 0.0, RAT,
	0.0, -1.0, 0.0, 1.0,
	-RAT, -RAT, 0.0, RAT,
	-1.0, 0.0, 0.0, 1.0,
	-RAT, RAT, 0.0, RAT,
	0.0, 1.0, 0.0, 1.0,
	RAT, RAT, 0.0, RAT,
	1.0, 0.0, 0.0, 1.0
};

fastf_t nmg_uv_unitcircle[27] = {
	1.0,   .5,  1.0,
	RAT,  RAT,  RAT,
	.5,   1.0,  1.0, 
	0.0,  RAT,  RAT,
	0.0,   .5,  1.0,
	0.0,  0.0,  RAT,
	.5,   0.0,  1.0, 
	RAT,  0.0,  RAT,
	1.0,   .5,  1.0
};

static void
nmg_tgc_disk(struct faceuse *fu, fastf_t *rmat, fastf_t height, int flip)
{
	struct face_g_snurb 	* fg;
	struct loopuse		* lu;
	struct edgeuse		* eu;
	struct edge_g_cnurb	* eg;
	fastf_t	*mptr;
	int i;
	vect_t	vect;
	point_t	point;

	nmg_face_g_snurb( fu,
		2, 2,  			/* u,v order */
		4, 4,			/* number of knots */
		NULL, NULL, 		/* initial knot vectors */
		2, 2, 			/* n_rows, n_cols */
		RT_NURB_MAKE_PT_TYPE(3, 2, 0),
		NULL );			/* Initial mesh */

	fg = fu->f_p->g.snurb_p;


	fg->u.knots[0] = 0.0;
	fg->u.knots[1] = 0.0;
	fg->u.knots[2] = 1.0;
	fg->u.knots[3] = 1.0;

	fg->v.knots[0] = 0.0;
	fg->v.knots[1] = 0.0;
	fg->v.knots[2] = 1.0;
	fg->v.knots[3] = 1.0;

	if(flip)
	{
		fg->ctl_points[0] = 1.;
		fg->ctl_points[1] = -1.;
		fg->ctl_points[2] = height;

		fg->ctl_points[3] = -1;
		fg->ctl_points[4] = -1.;
		fg->ctl_points[5] = height;

		fg->ctl_points[6] = 1.;
		fg->ctl_points[7] = 1.;
		fg->ctl_points[8] = height;

		fg->ctl_points[9] = -1.;
		fg->ctl_points[10] = 1.;
		fg->ctl_points[11] = height;
	} else
	{

		fg->ctl_points[0] = -1.;
		fg->ctl_points[1] = -1.;
		fg->ctl_points[2] = height;

		fg->ctl_points[3] = 1;
		fg->ctl_points[4] = -1.;
		fg->ctl_points[5] = height;

		fg->ctl_points[6] = -1.;
		fg->ctl_points[7] = 1.;
		fg->ctl_points[8] = height;

		fg->ctl_points[9] = 1.;
		fg->ctl_points[10] = 1.;
		fg->ctl_points[11] = height;
	}

	/* multiple the matrix to get orientation and scaling that we want */
	mptr = fg->ctl_points;

	i = fg->s_size[0] * fg->s_size[1];

        for( ; i> 0; i--)
        {
		MAT4X3PNT(vect,rmat,mptr);
                mptr[0] = vect[0];
                mptr[1] = vect[1];
                mptr[2] = vect[2];
                mptr += 3;
        }

	lu = BU_LIST_FIRST( loopuse, &fu->lu_hd);
	NMG_CK_LOOPUSE(lu);
	eu= BU_LIST_FIRST( edgeuse, &lu->down_hd);
	NMG_CK_EDGEUSE(eu);

	
	if(!flip)
	{
		rt_nurb_s_eval( fu->f_p->g.snurb_p, 
			nmg_uv_unitcircle[0], nmg_uv_unitcircle[1], point );
		nmg_vertex_gv( eu->vu_p->v_p, point );
	} else
	{
		rt_nurb_s_eval( fu->f_p->g.snurb_p, 
			nmg_uv_unitcircle[12], nmg_uv_unitcircle[13], point );
		nmg_vertex_gv( eu->vu_p->v_p, point );
	}

	nmg_edge_g_cnurb(eu, 3, 12, NULL, 9, RT_NURB_MAKE_PT_TYPE(3,3,1),
		NULL);

	eg = eu->g.cnurb_p;
	eg->order = 3;

	eg->k.knots[0] = 0.0;
	eg->k.knots[1] = 0.0;
	eg->k.knots[2] = 0.0;
	eg->k.knots[3] = .25;
	eg->k.knots[4] = .25;
	eg->k.knots[5] = .5;
	eg->k.knots[6] = .5;
	eg->k.knots[7] = .75;
	eg->k.knots[8] = .75;
	eg->k.knots[9] = 1.0;
	eg->k.knots[10] = 1.0;
	eg->k.knots[11] = 1.0;

	if( !flip ) 
	{
		for( i = 0; i < 27; i++)
			eg->ctl_points[i] = nmg_uv_unitcircle[i];
	}
	else 
	{

		VSET(&eg->ctl_points[0], 0.0, .5, 1.0);
		VSET(&eg->ctl_points[3], 0.0, 0.0, RAT);
		VSET(&eg->ctl_points[6], 0.5, 0.0, 1.0);
		VSET(&eg->ctl_points[9], RAT, 0.0, RAT);
		VSET(&eg->ctl_points[12], 1.0, .5, 1.0);
		VSET(&eg->ctl_points[15], RAT,RAT, RAT);
		VSET(&eg->ctl_points[18], .5, 1.0, 1.0);
		VSET(&eg->ctl_points[21], 0.0, RAT, RAT);
		VSET(&eg->ctl_points[24], 0.0, .5, 1.0);
	}
}
	
/* Create a cylinder with a top surface and a bottom surfce 
 * defined by the ellipsods at the top and bottom of the
 * cylinder, the top_mat, and bot_mat are applied to a unit circle
 * for the top row of the surface and the bot row of the surface
 * respectively.
 */
static void
nmg_tgc_nurb_cyl(struct faceuse *fu, fastf_t *top_mat, fastf_t *bot_mat)
{
	struct face_g_snurb 	* fg;
	struct loopuse		* lu;
	struct edgeuse		* eu;
	fastf_t		* mptr;
	int		i;
	hvect_t		vect;
	point_t		uvw;
	point_t		point;
	hvect_t		hvect;

	nmg_face_g_snurb( fu, 
		3, 2,
		12, 4,
		NULL, NULL,
		2, 9,
		RT_NURB_MAKE_PT_TYPE(4,3,1),
		NULL );

	fg = fu->f_p->g.snurb_p;

	fg->v.knots[0] = 0.0;
	fg->v.knots[1] = 0.0;
	fg->v.knots[2] = 1.0;
	fg->v.knots[3] = 1.0;

	fg->u.knots[0] = 0.0;
	fg->u.knots[1] = 0.0;
	fg->u.knots[2] = 0.0;
	fg->u.knots[3] = .25;
	fg->u.knots[4] = .25;
	fg->u.knots[5] = .5;
	fg->u.knots[6] = .5;
	fg->u.knots[7] = .75;
	fg->u.knots[8] = .75;
	fg->u.knots[9] = 1.0;
	fg->u.knots[10] = 1.0;
	fg->u.knots[11] = 1.0;

	mptr = fg->ctl_points;

	for(i = 0; i < 9; i++)
	{
		MAT4X4PNT(vect, top_mat, &nmg_tgc_unitcircle[i*4]);
		mptr[0] = vect[0];
		mptr[1] = vect[1];
		mptr[2] = vect[2];
		mptr[3] = vect[3];
		mptr += 4;
	}

	for(i = 0; i < 9; i++)
	{
		MAT4X4PNT(vect, bot_mat, &nmg_tgc_unitcircle[i*4]);
		mptr[0] = vect[0];
		mptr[1] = vect[1];
		mptr[2] = vect[2];
		mptr[3] = vect[3];
		mptr += 4;
	}

	/* Assign edgeuse parameters & vertex geometry */

	lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
	NMG_CK_LOOPUSE(lu);
	eu = BU_LIST_FIRST( edgeuse, &lu->down_hd);
	NMG_CK_EDGEUSE(eu);
	
	/* March around the fu's loop assigning uv parameter values */

	rt_nurb_s_eval( fg, 0.0, 0.0, hvect);
	HDIVIDE( point, hvect );
	nmg_vertex_gv( eu->vu_p->v_p, point );	/* 0,0 vertex */

	VSET( uvw, 0, 0, 0);
	nmg_vertexuse_a_cnurb( eu->vu_p, uvw );
	VSET( uvw, 1, 0, 0);
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, uvw );
	eu = BU_LIST_NEXT( edgeuse, &eu->l);

	VSET( uvw, 1, 0, 0);
	nmg_vertexuse_a_cnurb( eu->vu_p, uvw );
	VSET( uvw, 1, 1, 0);
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, uvw );
	eu = BU_LIST_NEXT( edgeuse, &eu->l);

	VSET( uvw, 1, 1, 0);
	nmg_vertexuse_a_cnurb( eu->vu_p, uvw );
	VSET( uvw, 0, 1, 0);
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, uvw );

	rt_nurb_s_eval( fg, 1., 1., hvect);
	HDIVIDE( point, hvect);
	nmg_vertex_gv( eu->vu_p->v_p, point );		/* 4,1 vertex */

	eu = BU_LIST_NEXT( edgeuse, &eu->l);

	VSET( uvw, 0, 1, 0);
	nmg_vertexuse_a_cnurb( eu->vu_p, uvw );
	VSET( uvw, 0, 0, 0);
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, uvw );
	eu = BU_LIST_NEXT( edgeuse, &eu->l);

	/* Create the edge loop geometry */

	lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
	NMG_CK_LOOPUSE(lu);
	eu = BU_LIST_FIRST( edgeuse, &lu->down_hd);
	NMG_CK_EDGEUSE(eu);

	for( i = 0; i < 4; i++)
	{
		nmg_edge_g_cnurb_plinear(eu);
		eu = BU_LIST_NEXT(edgeuse, &eu->l);
	}
}
@


11.44
log
@change conf.h to a wrapped config.h
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /cvs/brlcad/librt/g_tgc.c,v 11.43 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.43
log
@merge of ansi-6-0-branch into HEAD
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header$ (BRL)";
d33 5
a37 1
#include "conf.h"
@


11.42
log
@update copyright to include span through 2003
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.41 2003/04/11 13:28:49 jra Exp $ (BRL)";
a50 4
static void	rt_tgc_rotate(), rt_tgc_shear();
static void	rt_tgc_scale(),  nmg_tgc_disk(), nmg_tgc_nurb_cyl();
void rt_pt_sort();

d68 8
d101 1
a101 4
rt_tgc_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d347 1
a347 4
rt_tgc_rotate( A, B, Hv, Rot, Inv, tgc )
vect_t		A, B, Hv;
mat_t		Rot, Inv;
struct tgc_specific	*tgc;
d401 1
a401 4
rt_tgc_shear( vect, axis, Shr, Trn, Inv )
const vect_t	vect;
int		axis;
mat_t		Shr, Trn, Inv;
d426 1
a426 3
rt_tgc_scale( a, b, h, Scl, Inv )
fastf_t	a, b, h;
mat_t	Scl, Inv;
d443 1
a443 2
rt_tgc_print( stp )
register const struct soltab	*stp;
d500 1
a500 5
rt_tgc_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d869 6
a874 6
rt_tgc_vshot( stp, rp, segp, n, ap )
struct soltab		*stp[];
register struct xray	*rp[];
struct  seg            segp[]; /* array of segs (results returned) */
int                         n; /* Number of ray/object pairs */
struct application	*ap;
d1373 1
a1373 4
rt_tgc_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d1416 1
a1416 5
rt_tgc_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d1473 1
a1473 2
rt_tgc_free( stp )
struct soltab *stp;
d1482 1
a1482 1
rt_tgc_class()
d1495 1
a1495 5
rt_tgc_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1535 1
a1535 5
rt_tgc_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1571 1
a1571 5
rt_tgc_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1607 1
a1607 5
rt_tgc_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1643 1
a1643 5
rt_tgc_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1725 1
a1725 2
rt_tgc_ifree( ip )
struct rt_db_internal	*ip;
d1736 1
a1736 5
rt_tgc_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1778 1
a1778 4
rt_tgc_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d1870 1
a1870 6
rt_tgc_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d2606 1
a2606 5
rt_tgc_tnurb( r, m, ip, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct bn_tol		*tol;
d2792 1
a2792 5
nmg_tgc_disk(fu, rmat, height, flip)
struct faceuse	* fu;
mat_t 	rmat;
fastf_t height;
int	flip;
d2939 1
a2939 4
nmg_tgc_nurb_cyl(fu, top_mat, bot_mat)
struct faceuse *fu;
mat_t	top_mat;
mat_t	bot_mat;
@


11.41
log
@Modified rt_shot_tgc(). It had been assuming that only one segment can result from
intersecting a ray with a tgc. In some cases, this is a wrong assumption.
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1985 by the United States Army.
d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.40 2003/04/10 13:57:08 jra Exp $ (BRL)";
@


11.41.6.1
log
@merge from HEAD
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.42 2004/02/02 17:39:21 morrison Exp $ (BRL)";
@


11.41.6.2
log
@merge from head
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.41.6.1 2004/02/12 18:37:42 erikg Exp $ (BRL)";
@


11.40
log
@A shortcut in rt_shot_tgc() was being used where it should not have been.
It was trying to reduce the equation to solve to quadratic form
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.39 2002/12/19 15:33:16 jra Exp $ (BRL)";
d520 2
a521 1
	LOCAL fastf_t		k[4], pt[2];
d650 1
d652 1
d709 2
a710 1
			if ( NEAR_ZERO( val[l].im, 1e-10 ) )
d712 1
d728 47
a774 4
	if ( npts != 0 && npts != 2 && npts != 4 ){
		bu_log("tgc(%s):  %d intersects != {0,2,4}\n",
		    stp->st_name, npts );
		return(0);			/* No hit */
d777 1
d782 1
d788 3
d799 8
a806 2
	/* General Cone may have 4 intersections, but	*
	 * Truncated Cone may only have 2.		*/
d808 10
a817 2
#define OUT		0
#define	IN		1
d819 2
a820 14
	/*		Truncation Procedure
	 *
	 *  Determine whether any of the intersections found are
	 *  between the planes truncating the cone.
	 */
	intersect = 0;
	for ( i=0; i < npts; i++ ){
		zval = k[i]*dprime[Z] + pprime[Z];
		/* Height vector is unitized (tgc->tgc_sH == 1.0) */
		if ( zval < 1.0 && zval > 0.0 ){
			if ( ++intersect == 2 )  {
				pt[IN] = k[i];
			}  else {
				pt[OUT] = k[i];
a823 6
	if ( intersect == 2 ){
		/*  If two between-plane intersections exist, they are
		 *  the hit points for the ray.
		 */
		RT_GET_SEG( segp, ap->a_resource );
		segp->seg_stp = stp;
d825 11
a835 10
		segp->seg_in.hit_dist = pt[IN] * t_scale;
		segp->seg_in.hit_surfno = TGC_NORM_BODY;	/* compute N */
		VJOIN1( segp->seg_in.hit_vpriv, pprime, pt[IN], dprime );

		segp->seg_out.hit_dist = pt[OUT] * t_scale;
		segp->seg_out.hit_surfno = TGC_NORM_BODY;	/* compute N */
		VJOIN1( segp->seg_out.hit_vpriv, pprime, pt[OUT], dprime );

		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		return(2);
a836 19
	if ( intersect == 1 )  {
		int	nflag;
		/*
		 *  If only one between-plane intersection exists (pt[OUT]),
		 *  then the other intersection must be on
		 *  one of the planar surfaces (pt[IN]).
		 *
		 *  Find which surface it lies on by calculating the 
		 *  X and Y values of the line as it intersects each
		 *  plane (in the standard coordinate system), and test
		 *  whether this lies within the governing ellipse.
		 */
		if( NEAR_ZERO( dprime[Z], SMALL_FASTF ) )  {
			bu_log("tgc: dprime[Z] = 0!\n" );
			return(0);
		}
		b = ( -pprime[Z] )/dprime[Z];
		/*  Height vector is unitized (tgc->tgc_sH == 1.0) */
		t = ( 1.0 - pprime[Z] )/dprime[Z];
d838 4
a841 8
		VJOIN1( work, pprime, b, dprime );
		/* A and B vectors are unitized (tgc->tgc_A == _B == 1.0) */
		/* alf1 = ALPHA(work[X], work[Y], 1.0, 1.0 ) */
		alf1 = work[X]*work[X] + work[Y]*work[Y];

		VJOIN1( work, pprime, t, dprime );
		/* Must scale C and D vectors */
		alf2 = ALPHA(work[X], work[Y], tgc->tgc_AAdCC,tgc->tgc_BBdDD);
d843 4
a846 6
		if ( alf1 <= 1.0 ){
			pt[IN] = b;
			nflag = TGC_NORM_BOT; /* copy reverse normal */
		} else if ( alf2 <= 1.0 ){
			pt[IN] = t;
			nflag = TGC_NORM_TOP;	/* copy normal */
d848 5
a852 7
			/* intersection apparently invalid  */
			bu_log("tgc(%s):  only 1 intersect\n", stp->st_name);
			bu_log( "\t (%d %d): ray pt = (%g %g %g), dir = (%g %g %g)\n",
				ap->a_x, ap->a_y,
				V3ARGS( ap->a_ray.r_pt ),
				V3ARGS( ap->a_ray.r_dir ) );
			return(0);
d855 4
a858 11
		RT_GET_SEG( segp, ap->a_resource );
		segp->seg_stp = stp;
		/* pt[OUT] on skin, pt[IN] on end */
		if ( pt[OUT] >= pt[IN] )  {
			segp->seg_in.hit_dist = pt[IN] * t_scale;
			segp->seg_in.hit_surfno = nflag;

			segp->seg_out.hit_dist = pt[OUT] * t_scale;
			segp->seg_out.hit_surfno = TGC_NORM_BODY;	/* compute N */
			/* transform-space vector needed for normal */
			VJOIN1( segp->seg_out.hit_vpriv, pprime, pt[OUT], dprime );
d860 5
a864 7
			segp->seg_in.hit_dist = pt[OUT] * t_scale;
			/* transform-space vector needed for normal */
			segp->seg_in.hit_surfno = TGC_NORM_BODY;	/* compute N */
			VJOIN1( segp->seg_in.hit_vpriv, pprime, pt[OUT], dprime );

			segp->seg_out.hit_dist = pt[IN] * t_scale;
			segp->seg_out.hit_surfno = nflag;
d866 1
a866 1

a867 1
		return(2);
d870 1
a870 57
	/*  If all conic interections lie outside the plane,
	 *  then check to see whether there are two planar
	 *  intersections inside the governing ellipses.
	 *
	 *  But first, if the direction is parallel (or nearly
	 *  so) to the planes, it (obviously) won't intersect
	 *  either of them.
	 */
	if( NEAR_ZERO( dprime[Z], SMALL_FASTF ) )
		return(0);

	dir = VDOT( tgc->tgc_N, rp->r_dir );	/* direc */
	if ( NEAR_ZERO( dir, RT_DOT_TOL ) )
		return(0);

	b = ( -pprime[Z] )/dprime[Z];
	/* Height vector is unitized (tgc->tgc_sH == 1.0) */
	t = ( 1.0 - pprime[Z] )/dprime[Z];

	VJOIN1( work, pprime, b, dprime );
	/* A and B vectors are unitized (tgc->tgc_A == _B == 1.0) */
	/* alpf = ALPHA(work[0], work[1], 1.0, 1.0 ) */
	alf1 = work[X]*work[X] + work[Y]*work[Y];

	VJOIN1( work, pprime, t, dprime );
	/* Must scale C and D vectors. */
	alf2 = ALPHA(work[X], work[Y], tgc->tgc_AAdCC,tgc->tgc_BBdDD);

	/*  It should not be possible for one planar intersection
	 *  to be outside its ellipse while the other is inside ...
	 *  but I wouldn't take any chances.
	 */
	if ( alf1 > 1.0 || alf2 > 1.0 )
		return(0);

	RT_GET_SEG( segp, ap->a_resource );
	segp->seg_stp = stp;

	/*  Use the dot product (found earlier) of the plane
	 *  normal with the direction vector to determine the
	 *  orientation of the intersections.
	 */
	if ( dir > 0.0 ){
		segp->seg_in.hit_dist = b * t_scale;
		segp->seg_in.hit_surfno = TGC_NORM_BOT;	/* reverse normal */

		segp->seg_out.hit_dist = t * t_scale;
		segp->seg_out.hit_surfno = TGC_NORM_TOP;	/* normal */
	} else {
		segp->seg_in.hit_dist = t * t_scale;
		segp->seg_in.hit_surfno = TGC_NORM_TOP;	/* normal */

		segp->seg_out.hit_dist = b * t_scale;
		segp->seg_out.hit_surfno = TGC_NORM_BOT;	/* reverse normal */
	}
	BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	return(2);
@


11.39
log
@rt_tgc_uv() was not correctly calculating uv parameters. It appears that incorrect
assumptions about the scaling was being made. Note that the scaling transforms the
bottom plate into a unit circle, not so for the rest of the TGC.
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.38 2002/08/20 17:08:01 jra Exp $ (BRL)";
d627 2
d630 2
a631 1
	if ( tgc->tgc_AD_CB ){
a638 1
		C.cf[0] = Xsqr.cf[0] + Ysqr.cf[0] - Rsqr.cf[0];
d825 4
@


11.38
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.36 2002/03/13 21:45:44 morrison Exp $ (BRL)";
d1488 4
a1491 6
		/* Skin.  x,y coordinates define rotation.  radius = 1 */
		if( pprime[Y] > 1.0 )
			pprime[Y] = 1.0;
		if( pprime[Y] < -1.0 )
			pprime[Y] = -1.0;
		uvp->uv_u = acos(pprime[Y]) * bn_inv2pi;
d1496 4
a1500 1
		uvp->uv_u = acos(pprime[Y]/len) * bn_inv2pi;
d1506 1
a1506 1
		uvp->uv_u = acos(pprime[Y]/len) * bn_inv2pi;
a1509 3
	/* Handle other half of acos() domain */
	if( pprime[X] < 0 )
		uvp->uv_u = 1.0 - uvp->uv_u;
@


11.38.4.1
log
@sync to HEAD...
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_tgc.c,v 11.42 2004/02/02 17:39:21 morrison Exp $ (BRL)";
d520 1
a520 2
	LOCAL fastf_t		k[6];
	LOCAL int		hit_type[6];
a626 2
	 *
	 *  this can only be done when C.cf[0] is not too small!!!! (JRA)
d628 1
a628 2
	C.cf[0] = Xsqr.cf[0] + Ysqr.cf[0] - Rsqr.cf[0];
	if( tgc->tgc_AD_CB && !NEAR_ZERO( C.cf[0], 1.0e-10 )  ) {
d636 1
a646 1
			hit_type[0] = TGC_NORM_BODY;
a647 1
			hit_type[1] = TGC_NORM_BODY;
d704 1
a704 2
			if ( NEAR_ZERO( val[l].im, 1e-10 ) ) {
				hit_type[npts] = TGC_NORM_BODY;
a705 1
			}
d721 4
a724 47
	/*
	 * Eliminate hits beyond the end planes
	 */
	i = 0;
	while( i < npts ) {
		zval = k[i]*dprime[Z] + pprime[Z];
		/* Height vector is unitized (tgc->tgc_sH == 1.0) */
		if ( zval >= 1.0 || zval <= 0.0 ){
			int j;
			/* drop this hit */
			npts--;
			for( j=i ; j<npts ; j++ ) {
				hit_type[j] = hit_type[j+1];
				k[j] = k[j+1];
			}
		} else {
			i++;
		}
	}

	/*
	 * Consider intersections with the end ellipses
	 */
	dir = VDOT( tgc->tgc_N, rp->r_dir );
	if( !NEAR_ZERO( dprime[Z], SMALL_FASTF ) && !NEAR_ZERO( dir, RT_DOT_TOL ) )  {
		b = ( -pprime[Z] )/dprime[Z];
		/*  Height vector is unitized (tgc->tgc_sH == 1.0) */
		t = ( 1.0 - pprime[Z] )/dprime[Z];

		VJOIN1( work, pprime, b, dprime );
		/* A and B vectors are unitized (tgc->tgc_A == _B == 1.0) */
		/* alf1 = ALPHA(work[X], work[Y], 1.0, 1.0 ) */
		alf1 = work[X]*work[X] + work[Y]*work[Y];

		VJOIN1( work, pprime, t, dprime );

		/* Must scale C and D vectors */
		alf2 = ALPHA(work[X], work[Y], tgc->tgc_AAdCC,tgc->tgc_BBdDD);

		if ( alf1 <= 1.0 ){
			hit_type[npts] = TGC_NORM_BOT;
			k[npts++] = b;
		}
		if ( alf2 <= 1.0 ){
			hit_type[npts] = TGC_NORM_TOP;
			k[npts++] = t;
		}
a726 1

a730 1
		register int		type;
a735 3
					type = hit_type[n];
					hit_type[n] = hit_type[n+1];
					hit_type[n+1] = type;
d744 2
a745 5
	if( npts%2 ) {
		/* odd number of hits!!!
		 * perhaps we got two hits on an edge
		 * check for duplicate hit distances
		 */
d747 2
a748 2
		for( i=npts-1 ; i>0 ; i-- ) {
			fastf_t diff;
d750 14
a763 13
			diff = k[i-1] - k[i];	/* non-negative due to sorting */
			if( diff < ap->a_rt_i->rti_tol.dist ) {
				/* remove this duplicate hit */
				int j;

				npts--;
				for( j=i ; j<npts ; j++ ) {
					hit_type[j] = hit_type[j+1];
					k[j] = k[j+1];
				}

				/* now have even number of hits */
				break;
d767 6
d774 26
a799 8
	if ( npts != 0 && npts != 2 && npts != 4 ){
		bu_log("tgc(%s):  %d intersects != {0,2,4}\n",
		    stp->st_name, npts );
		bu_log( "\tray: pt = (%g %g %g), dir = (%g %g %g)\n",
			V3ARGS( ap->a_ray.r_pt ),
			V3ARGS( ap->a_ray.r_dir ) );
		for( i=0 ; i<npts ; i++ ) {
			bu_log( "\t%g", k[i]*t_scale );
d801 8
a808 3
		bu_log( "\n" );
		return(0);			/* No hit */
	}
d810 3
a812 4
	intersect = 0;
	for( i=npts-1 ; i>0 ; i -= 2 ) {
		RT_GET_SEG( segp, ap->a_resource );
		segp->seg_stp = stp;
d814 6
a819 4
		segp->seg_in.hit_dist = k[i] * t_scale;
		segp->seg_in.hit_surfno = hit_type[i];
		if( segp->seg_in.hit_surfno == TGC_NORM_BODY ) {
			VJOIN1( segp->seg_in.hit_vpriv, pprime, k[i], dprime );
d821 3
a823 5
			if( dir > 0.0 ) {
				segp->seg_in.hit_surfno = TGC_NORM_BOT;
			} else {
				segp->seg_in.hit_surfno = TGC_NORM_TOP;
			}
d826 11
a836 4
		segp->seg_out.hit_dist = k[i-1] * t_scale;
		segp->seg_out.hit_surfno = hit_type[i-1];
		if( segp->seg_out.hit_surfno == TGC_NORM_BODY ) {
			VJOIN1( segp->seg_out.hit_vpriv, pprime, k[i-1], dprime );
d838 7
a844 5
			if( dir > 0.0 ) {
				segp->seg_out.hit_surfno = TGC_NORM_TOP;
			} else {
				segp->seg_out.hit_surfno = TGC_NORM_BOT;
			}
d846 1
a846 1
		intersect++;
d848 1
d851 57
a907 1
	return( intersect );
d1488 6
a1493 4
		/* scale coords to unit circle (they are already scaled by bottom plate radii) */
		pprime[X] *= tgc->tgc_A / (tgc->tgc_A*( 1.0 - pprime[Z]) + tgc->tgc_C*pprime[Z]);
		pprime[Y] *= tgc->tgc_B / (tgc->tgc_B*( 1.0 - pprime[Z]) + tgc->tgc_D*pprime[Z]);
		uvp->uv_u = atan2( pprime[Y], pprime[X] ) / bn_twopi + 0.5;
a1497 4
		/* scale coords to unit circle (they are already scaled by bottom plate radii) */
		pprime[X] *= tgc->tgc_A / tgc->tgc_C;
		pprime[Y] *= tgc->tgc_B / tgc->tgc_D;
		uvp->uv_u = atan2( pprime[Y], pprime[X] ) / bn_twopi + 0.5;
d1499 1
d1505 1
a1505 1
		uvp->uv_u = atan2( pprime[Y], pprime[X] ) / bn_twopi + 0.5;
d1509 3
@


11.38.2.1
log
@Initial ANSIfication
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.38 2002/08/20 17:08:01 jra Exp $ (BRL)";
d51 4
a71 8

static void rt_tgc_rotate(fastf_t *A, fastf_t *B, fastf_t *Hv, fastf_t *Rot, fastf_t *Inv, struct tgc_specific *tgc);
static void rt_tgc_shear(const fastf_t *vect, int axis, fastf_t *Shr, fastf_t *Trn, fastf_t *Inv);
static void rt_tgc_scale(fastf_t a, fastf_t b, fastf_t h, fastf_t *Scl, fastf_t *Inv);
static void nmg_tgc_disk(struct faceuse *fu, fastf_t *rmat, fastf_t height, int flip);
static void nmg_tgc_nurb_cyl(struct faceuse *fu, fastf_t *top_mat, fastf_t *bot_mat);
void rt_pt_sort(register fastf_t *t, int npts);

d97 4
a100 1
rt_tgc_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d346 4
a349 1
rt_tgc_rotate(fastf_t *A, fastf_t *B, fastf_t *Hv, fastf_t *Rot, fastf_t *Inv, struct tgc_specific *tgc)
d403 4
a406 1
rt_tgc_shear(const fastf_t *vect, int axis, fastf_t *Shr, fastf_t *Trn, fastf_t *Inv)
d431 3
a433 1
rt_tgc_scale(fastf_t a, fastf_t b, fastf_t h, fastf_t *Scl, fastf_t *Inv)
d450 2
a451 1
rt_tgc_print(register const struct soltab *stp)
d508 5
a512 1
rt_tgc_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d918 6
a923 6
rt_tgc_vshot(struct soltab **stp, register struct xray **rp, struct seg *segp, int n, struct application *ap)
             		       
                    	      
                               /* array of segs (results returned) */
                               /* Number of ray/object pairs */
                  	    
d1422 4
a1425 1
rt_tgc_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d1468 5
a1472 1
rt_tgc_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d1531 2
a1532 1
rt_tgc_free(struct soltab *stp)
d1541 1
a1541 1
rt_tgc_class(void)
d1554 5
a1558 1
rt_tgc_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1598 5
a1602 1
rt_tgc_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1638 5
a1642 1
rt_tgc_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1678 5
a1682 1
rt_tgc_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1718 5
a1722 1
rt_tgc_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1804 2
a1805 1
rt_tgc_ifree(struct rt_db_internal *ip)
d1816 5
a1820 1
rt_tgc_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1862 4
a1865 1
rt_tgc_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d1957 6
a1962 1
rt_tgc_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d2698 5
a2702 1
rt_tgc_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
d2888 5
a2892 1
nmg_tgc_disk(struct faceuse *fu, fastf_t *rmat, fastf_t height, int flip)
d3039 4
a3042 1
nmg_tgc_nurb_cyl(struct faceuse *fu, fastf_t *top_mat, fastf_t *bot_mat)
@


11.38.2.2
log
@sync branch with HEAD
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header$ (BRL)";
d508 1
a508 2
	LOCAL fastf_t		k[6];
	LOCAL int		hit_type[6];
a614 2
	 *
	 *  this can only be done when C.cf[0] is not too small!!!! (JRA)
d616 1
a616 2
	C.cf[0] = Xsqr.cf[0] + Ysqr.cf[0] - Rsqr.cf[0];
	if( tgc->tgc_AD_CB && !NEAR_ZERO( C.cf[0], 1.0e-10 )  ) {
d624 1
a634 1
			hit_type[0] = TGC_NORM_BODY;
a635 1
			hit_type[1] = TGC_NORM_BODY;
d692 1
a692 2
			if ( NEAR_ZERO( val[l].im, 1e-10 ) ) {
				hit_type[npts] = TGC_NORM_BODY;
a693 1
			}
d709 4
a712 47
	/*
	 * Eliminate hits beyond the end planes
	 */
	i = 0;
	while( i < npts ) {
		zval = k[i]*dprime[Z] + pprime[Z];
		/* Height vector is unitized (tgc->tgc_sH == 1.0) */
		if ( zval >= 1.0 || zval <= 0.0 ){
			int j;
			/* drop this hit */
			npts--;
			for( j=i ; j<npts ; j++ ) {
				hit_type[j] = hit_type[j+1];
				k[j] = k[j+1];
			}
		} else {
			i++;
		}
	}

	/*
	 * Consider intersections with the end ellipses
	 */
	dir = VDOT( tgc->tgc_N, rp->r_dir );
	if( !NEAR_ZERO( dprime[Z], SMALL_FASTF ) && !NEAR_ZERO( dir, RT_DOT_TOL ) )  {
		b = ( -pprime[Z] )/dprime[Z];
		/*  Height vector is unitized (tgc->tgc_sH == 1.0) */
		t = ( 1.0 - pprime[Z] )/dprime[Z];

		VJOIN1( work, pprime, b, dprime );
		/* A and B vectors are unitized (tgc->tgc_A == _B == 1.0) */
		/* alf1 = ALPHA(work[X], work[Y], 1.0, 1.0 ) */
		alf1 = work[X]*work[X] + work[Y]*work[Y];

		VJOIN1( work, pprime, t, dprime );

		/* Must scale C and D vectors */
		alf2 = ALPHA(work[X], work[Y], tgc->tgc_AAdCC,tgc->tgc_BBdDD);

		if ( alf1 <= 1.0 ){
			hit_type[npts] = TGC_NORM_BOT;
			k[npts++] = b;
		}
		if ( alf2 <= 1.0 ){
			hit_type[npts] = TGC_NORM_TOP;
			k[npts++] = t;
		}
a714 1

a718 1
		register int		type;
a723 3
					type = hit_type[n];
					hit_type[n] = hit_type[n+1];
					hit_type[n+1] = type;
d732 2
a733 5
	if( npts%2 ) {
		/* odd number of hits!!!
		 * perhaps we got two hits on an edge
		 * check for duplicate hit distances
		 */
d735 2
a736 2
		for( i=npts-1 ; i>0 ; i-- ) {
			fastf_t diff;
d738 14
a751 13
			diff = k[i-1] - k[i];	/* non-negative due to sorting */
			if( diff < ap->a_rt_i->rti_tol.dist ) {
				/* remove this duplicate hit */
				int j;

				npts--;
				for( j=i ; j<npts ; j++ ) {
					hit_type[j] = hit_type[j+1];
					k[j] = k[j+1];
				}

				/* now have even number of hits */
				break;
d755 6
d762 26
a787 8
	if ( npts != 0 && npts != 2 && npts != 4 ){
		bu_log("tgc(%s):  %d intersects != {0,2,4}\n",
		    stp->st_name, npts );
		bu_log( "\tray: pt = (%g %g %g), dir = (%g %g %g)\n",
			V3ARGS( ap->a_ray.r_pt ),
			V3ARGS( ap->a_ray.r_dir ) );
		for( i=0 ; i<npts ; i++ ) {
			bu_log( "\t%g", k[i]*t_scale );
d789 8
a796 3
		bu_log( "\n" );
		return(0);			/* No hit */
	}
d798 3
a800 4
	intersect = 0;
	for( i=npts-1 ; i>0 ; i -= 2 ) {
		RT_GET_SEG( segp, ap->a_resource );
		segp->seg_stp = stp;
d802 6
a807 4
		segp->seg_in.hit_dist = k[i] * t_scale;
		segp->seg_in.hit_surfno = hit_type[i];
		if( segp->seg_in.hit_surfno == TGC_NORM_BODY ) {
			VJOIN1( segp->seg_in.hit_vpriv, pprime, k[i], dprime );
d809 3
a811 5
			if( dir > 0.0 ) {
				segp->seg_in.hit_surfno = TGC_NORM_BOT;
			} else {
				segp->seg_in.hit_surfno = TGC_NORM_TOP;
			}
d814 11
a824 4
		segp->seg_out.hit_dist = k[i-1] * t_scale;
		segp->seg_out.hit_surfno = hit_type[i-1];
		if( segp->seg_out.hit_surfno == TGC_NORM_BODY ) {
			VJOIN1( segp->seg_out.hit_vpriv, pprime, k[i-1], dprime );
d826 7
a832 5
			if( dir > 0.0 ) {
				segp->seg_out.hit_surfno = TGC_NORM_TOP;
			} else {
				segp->seg_out.hit_surfno = TGC_NORM_BOT;
			}
d834 1
a834 1
		intersect++;
d836 1
d839 57
a895 1
	return( intersect );
d1469 6
a1474 4
		/* scale coords to unit circle (they are already scaled by bottom plate radii) */
		pprime[X] *= tgc->tgc_A / (tgc->tgc_A*( 1.0 - pprime[Z]) + tgc->tgc_C*pprime[Z]);
		pprime[Y] *= tgc->tgc_B / (tgc->tgc_B*( 1.0 - pprime[Z]) + tgc->tgc_D*pprime[Z]);
		uvp->uv_u = atan2( pprime[Y], pprime[X] ) / bn_twopi + 0.5;
a1478 4
		/* scale coords to unit circle (they are already scaled by bottom plate radii) */
		pprime[X] *= tgc->tgc_A / tgc->tgc_C;
		pprime[Y] *= tgc->tgc_B / tgc->tgc_D;
		uvp->uv_u = atan2( pprime[Y], pprime[X] ) / bn_twopi + 0.5;
d1480 1
d1486 1
a1486 1
		uvp->uv_u = atan2( pprime[Y], pprime[X] ) / bn_twopi + 0.5;
d1490 3
@


11.37
log
@Converted from K&R to ANSI C - RFH
@
text
@d51 4
a71 8

static void rt_tgc_rotate(fastf_t *A, fastf_t *B, fastf_t *Hv, fastf_t *Rot, fastf_t *Inv, struct tgc_specific *tgc);
static void rt_tgc_shear(const fastf_t *vect, int axis, fastf_t *Shr, fastf_t *Trn, fastf_t *Inv);
static void rt_tgc_scale(fastf_t a, fastf_t b, fastf_t h, fastf_t *Scl, fastf_t *Inv);
static void nmg_tgc_disk(struct faceuse *fu, fastf_t *rmat, fastf_t height, int flip);
static void nmg_tgc_nurb_cyl(struct faceuse *fu, fastf_t *top_mat, fastf_t *bot_mat);
void rt_pt_sort(register fastf_t *t, int npts);

d97 4
a100 1
rt_tgc_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d346 4
a349 1
rt_tgc_rotate(fastf_t *A, fastf_t *B, fastf_t *Hv, fastf_t *Rot, fastf_t *Inv, struct tgc_specific *tgc)
d403 4
a406 1
rt_tgc_shear(const fastf_t *vect, int axis, fastf_t *Shr, fastf_t *Trn, fastf_t *Inv)
d431 3
a433 1
rt_tgc_scale(fastf_t a, fastf_t b, fastf_t h, fastf_t *Scl, fastf_t *Inv)
d450 2
a451 1
rt_tgc_print(register const struct soltab *stp)
d508 5
a512 1
rt_tgc_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d918 6
a923 6
rt_tgc_vshot(struct soltab **stp, register struct xray **rp, struct seg *segp, int n, struct application *ap)
             		       
                    	      
                               /* array of segs (results returned) */
                               /* Number of ray/object pairs */
                  	    
d1422 4
a1425 1
rt_tgc_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d1468 5
a1472 1
rt_tgc_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d1531 2
a1532 1
rt_tgc_free(struct soltab *stp)
d1541 1
a1541 1
rt_tgc_class(void)
d1554 5
a1558 1
rt_tgc_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1598 5
a1602 1
rt_tgc_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1638 5
a1642 1
rt_tgc_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1678 5
a1682 1
rt_tgc_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1718 5
a1722 1
rt_tgc_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1804 2
a1805 1
rt_tgc_ifree(struct rt_db_internal *ip)
d1816 5
a1820 1
rt_tgc_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1862 4
a1865 1
rt_tgc_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d1957 6
a1962 1
rt_tgc_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d2698 5
a2702 1
rt_tgc_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
d2888 5
a2892 1
nmg_tgc_disk(struct faceuse *fu, fastf_t *rmat, fastf_t height, int flip)
d3039 4
a3042 1
nmg_tgc_nurb_cyl(struct faceuse *fu, fastf_t *top_mat, fastf_t *bot_mat)
@


11.36
log
@Added top-vector to list of values described (position+height)
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.35 2001/10/02 19:24:30 jra Exp $ (BRL)";
a50 4
static void	rt_tgc_rotate(), rt_tgc_shear();
static void	rt_tgc_scale(),  nmg_tgc_disk(), nmg_tgc_nurb_cyl();
void rt_pt_sort();

d68 8
d101 1
a101 4
rt_tgc_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d347 1
a347 4
rt_tgc_rotate( A, B, Hv, Rot, Inv, tgc )
vect_t		A, B, Hv;
mat_t		Rot, Inv;
struct tgc_specific	*tgc;
d401 1
a401 4
rt_tgc_shear( vect, axis, Shr, Trn, Inv )
const vect_t	vect;
int		axis;
mat_t		Shr, Trn, Inv;
d426 1
a426 3
rt_tgc_scale( a, b, h, Scl, Inv )
fastf_t	a, b, h;
mat_t	Scl, Inv;
d443 1
a443 2
rt_tgc_print( stp )
register const struct soltab	*stp;
d500 1
a500 5
rt_tgc_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d906 6
a911 6
rt_tgc_vshot( stp, rp, segp, n, ap )
struct soltab		*stp[];
register struct xray	*rp[];
struct  seg            segp[]; /* array of segs (results returned) */
int                         n; /* Number of ray/object pairs */
struct application	*ap;
d1410 1
a1410 4
rt_tgc_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d1453 1
a1453 5
rt_tgc_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d1512 1
a1512 2
rt_tgc_free( stp )
struct soltab *stp;
d1521 1
a1521 1
rt_tgc_class()
d1534 1
a1534 5
rt_tgc_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1574 1
a1574 5
rt_tgc_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1610 1
a1610 5
rt_tgc_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1646 1
a1646 5
rt_tgc_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1682 1
a1682 5
rt_tgc_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1764 1
a1764 2
rt_tgc_ifree( ip )
struct rt_db_internal	*ip;
d1775 1
a1775 5
rt_tgc_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1817 1
a1817 4
rt_tgc_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d1909 1
a1909 6
rt_tgc_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d2645 1
a2645 5
rt_tgc_tnurb( r, m, ip, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct bn_tol		*tol;
d2831 1
a2831 5
nmg_tgc_disk(fu, rmat, height, flip)
struct faceuse	* fu;
mat_t 	rmat;
fastf_t height;
int	flip;
d2978 1
a2978 4
nmg_tgc_nurb_cyl(fu, top_mat, bot_mat)
struct faceuse *fu;
mat_t	top_mat;
mat_t	bot_mat;
@


11.35
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.34 2001/09/18 15:27:56 bparker Exp $ (BRL)";
d1738 6
@


11.34
log
@*- mods to rt_tgc_export5 to consider ID_REC.
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.33 2001/04/20 22:29:47 morrison Exp $ (BRL)";
d1573 1
d1652 1
@


11.33
log
@CONST to const
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.32 2001/03/31 01:57:09 morrison Exp $ (BRL)";
d1686 1
a1686 1
	if( ip->idb_type != ID_TGC )  return(-1);
@


11.32
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.31 2000/10/19 16:08:39 bparker Exp $ (BRL)";
d75 1
a75 1
CONST struct bu_structparse rt_tgc_parse[] = {
d404 1
a404 1
CONST vect_t	vect;
d451 1
a451 1
register CONST struct soltab	*stp;
d453 1
a453 1
	register CONST struct tgc_specific	*tgc =
d514 1
a514 1
	register CONST struct tgc_specific	*tgc =
d1556 3
a1558 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1599 1
a1599 1
CONST struct rt_db_internal	*ip;
d1601 1
a1601 1
CONST struct db_i		*dbip;
d1639 3
a1641 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1678 1
a1678 1
CONST struct rt_db_internal	*ip;
d1680 1
a1680 1
CONST struct db_i		*dbip;
d1718 1
a1718 1
CONST struct rt_db_internal	*ip;
d1811 2
a1812 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d1953 2
a1954 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d2694 1
a2694 1
CONST struct bn_tol		*tol;
@


11.31
log
@Mods to export routine to recognize other
solids that share the routine.
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.30 2000/10/18 18:10:35 butler Exp $ (BRL)";
d373 2
a374 2
	bn_mat_idn( Rot );
	bn_mat_idn( Inv );
d408 3
a410 3
	bn_mat_idn( Shr );
	bn_mat_idn( Trn );
	bn_mat_idn( Inv );
d435 2
a436 2
	bn_mat_idn( Scl );
	bn_mat_idn( Inv );
d1884 1
a1884 1
	bn_mat_idn( dN );
d2731 2
a2732 2
	bn_mat_idn( omat );
	bn_mat_idn( mat);
d2749 1
a2749 1
        bn_mat_idn( omat );
d2781 2
a2782 2
	bn_mat_idn( omat );
	bn_mat_idn( mat);
d2799 1
a2799 1
        bn_mat_idn( omat );
@


11.30
log
@Patches for compiling under RedHat 7.0
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.29 2000/08/22 20:36:56 mike Exp $ (BRL)";
d1607 1
a1607 1
	if( ip->idb_type != ID_TGC )  return(-1);
@


11.29
log
@
lint
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.28 2000/08/21 02:02:31 butler Exp $ (BRL)";
d36 3
@


11.28
log
@Massive compilation warnings eliminated
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.27 2000/07/10 23:01:36 mike Exp $ (BRL)";
d2125 2
a2126 1
		fastf_t ratios[4],max_ratio,new_ratio;
@


11.27
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d30 1
a30 1
static const char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.26 2000/06/30 15:38:04 mike Exp $ (BRL)";
d79 2
a80 1
    {0} };
d1350 1
a1350 3
rt_pt_sort( t, npts )
register fastf_t t[];
int npts;
@


11.26
log
@
export methods should not init the external structure, just check them.
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.25 2000/06/30 15:31:15 mike Exp $ (BRL)";
@


11.25
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.24 2000/06/27 15:33:31 bparker Exp $ (BRL)";
d1609 1
a1609 1
	BU_INIT_EXTERNAL(ep);
d1688 1
a1688 1
	BU_INIT_EXTERNAL(ep);
@


11.24
log
@Call BU_ASSERT_LONG.
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.23 2000/06/26 19:45:27 bparker Exp $ (BRL)";
d1570 1
a1570 1
	RT_INIT_DB_INTERNAL( ip );
d1648 1
a1648 1
	RT_INIT_DB_INTERNAL( ip );
@


11.23
log
@Add import5/export5 routines.
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.22 2000/04/12 02:34:36 mike Exp $ (BRL)";
d1645 2
@


11.22
log
@
NT port, non-compat4
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.21 1999/12/22 02:18:00 mike Exp $ (BRL)";
d1624 76
@


11.22.2.1
log
@Mods to export routine to recognize other
solids that share the routine.
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.22 2000/04/12 02:34:36 mike Exp $ (BRL)";
d1605 1
a1605 1
	if( ip->idb_type != ID_TGC && ip->idb_type != ID_REC )  return(-1);
@


11.21
log
@
Eliminated dead vars
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.20 1999/11/26 21:46:49 mike Exp $ (BRL)";
d1789 1
a1789 1
		vec_ortho( cvp->crv_pdir, hitp->hit_normal );
d1832 1
a1832 1
	vec_ortho( u, hitp->hit_normal );
d1842 1
a1842 1
	eigen2x2( &cvp->crv_c1, &cvp->crv_c2, vec1, vec2, a, b, c );
d2039 1
a2039 1
	nsegs = bn_halfpi / alpha_tol + 0.9999;
d2207 3
a2209 3
			factors = (fastf_t *)rt_realloc( factors, nells*sizeof( fastf_t ), "factors" );
			A = (vect_t *)rt_realloc( A, nells*sizeof( vect_t ), "A vectors" );
			B = (vect_t *)rt_realloc( B, nells*sizeof( vect_t ), "B vectors" );
@


11.20
log
@
Lint cleanups
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.19 1999/11/24 23:12:09 mike Exp $ (BRL)";
a1880 1
	fastf_t			min_tri;	/* minimum width of triangle */
a1885 3
	fastf_t			ratio;		/* L/D for narrowest triangle */
	fastf_t			narrow;		/* width of narrowest triangle */
	int			nsplits;	/* number of intermediate ellipse to avoid large L/D faces */
a2413 1
		fastf_t h_factor;
a2415 1
		h_factor = factors[i];
d2471 1
a2471 1
		int j,k,l,m;
a2625 2
	struct snurb 			*top_srf;
	struct cnurb			*top_cnurb;
a2628 6
	struct snurb 			*bot_srf;
	struct cnurb			*bot_cnurb;
	
	struct snurb			* cyl_srf;

	int				i;
a2630 1
	int 				coords;
a2633 2
	fastf_t 			* mptr;
	fastf_t 			Height;
a2809 1
	int coords;
a2873 1
	coords = RT_NURB_EXTRACT_COORDS(fg->pt_type);
@


11.19
log
@
Made structparse tables CONST
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.18 1999/11/17 02:42:03 mike Exp $ (BRL)";
d1552 1
a1552 1
rt_tgc_import( ip, ep, mat )
d1556 1
d1595 1
a1595 1
rt_tgc_export( ep, ip, local2mm )
d1599 1
d1638 1
a1638 1
struct rt_db_internal	*ip;
d1732 1
a1732 1
struct bn_tol		*tol;
d2619 1
a2619 1
struct bn_tol		*tol;
@


11.18
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.17 1999/11/11 00:54:29 mike Exp $ (BRL)";
d72 1
a72 1
struct bu_structparse rt_tgc_parse[] = {
@


11.17
log
@
No need for this compat file any longer.
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.16 1999/07/23 21:01:14 jra Exp $ (BRL)";
d1571 1
@


11.16
log
@rt_tgc_uv() was dumping core. Clamped some values to keep them in allowable range.
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.15 1999/07/02 22:19:24 mike Exp $ (BRL)";
a43 1
#include "./complex.h"
@


11.15
log
@
Removed dependence on compat4.h
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.14 1999/05/27 19:10:43 mike Exp $ (BRL)";
d1488 4
d1511 9
@


11.14
log
@
sed4
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_tgc.c,v 11.13 1997/06/17 19:23:46 gdurf Exp $ (BRL)";
a44 1
#include "./polyno.h"
d526 3
a528 3
	LOCAL poly		C;	/*  final equation	*/
	LOCAL poly		Xsqr, Ysqr;
	LOCAL poly		R, Rsqr;
d648 1
a648 1
		LOCAL poly	Q, Qsqr;
d936 3
a938 3
	LOCAL poly		*C;	/*  final equation	*/
	LOCAL poly		Xsqr, Ysqr;
	LOCAL poly		R, Rsqr;
d941 1
a941 1
	C = (poly *)bu_malloc(n * sizeof(poly), "tor poly");
d1044 1
a1044 1
			LOCAL poly	Q, Qsqr;
d1341 1
a1341 1
	bu_free( (char *)C, "tor poly" );
d1734 1
a1734 1
	RT_ADD_VLIST( vhead, &top[15*ELEMENTS_PER_VECT], RT_VLIST_LINE_MOVE );
d1736 1
a1736 1
		RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], RT_VLIST_LINE_DRAW );
d1740 1
a1740 1
	RT_ADD_VLIST( vhead, &bottom[15*ELEMENTS_PER_VECT], RT_VLIST_LINE_MOVE );
d1742 1
a1742 1
		RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], RT_VLIST_LINE_DRAW );
d1747 2
a1748 2
		RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], RT_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], RT_VLIST_LINE_DRAW );
@


11.13
log
@Imported bu_structparse from tcl.c
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 11.12 1996/10/21 19:11:33 jra Exp gdurf $ (BRL)";
d133 1
a133 1
		rt_log("tgc(%s):  zero length H vector\n", stp->st_name );
d140 1
a140 1
		rt_log("tgc(%s):  vectors A, C zero length\n", stp->st_name );
d145 1
a145 1
		rt_log("tgc(%s):  vectors B, D zero length\n", stp->st_name );
d153 1
a153 1
			rt_log("tgc(%s):  Both ends degenerate\n", stp->st_name);
d164 1
a164 1
		rt_log("NOTE: tgc(%s): degenerate end exchanged\n", stp->st_name);
d171 1
a171 1
		rt_log("tgc(%s):  H lies in A-B plane\n",stp->st_name);
d179 1
a179 1
			rt_log("tgc(%s):  A not perpendicular to B, f=%g\n",
d181 1
a181 1
			rt_log("tgc: dot=%g / a*b=%g\n",
d190 1
a190 1
			rt_log("tgc(%s):  C not perpendicular to D, f=%g\n",
d192 1
a192 1
			rt_log("tgc: dot=%g / c*d=%g\n",
d202 1
a202 1
			rt_log("tgc(%s):  A not parallel to C, f=%g\n",
d212 1
a212 1
			rt_log("tgc(%s):  B not parallel to D, f=%g\n",
d219 1
a219 1
	GETSTRUCT( tgc, tgc_specific );
d266 2
a267 2
	mat_mul( tmp, Shr, Rot );
	mat_mul( tgc->tgc_ScShR, Scl, tmp );
d269 2
a270 2
	mat_mul( tmp, tShr, Scl );
	mat_mul( tgc->tgc_invRtShSc, iRot, tmp );
d371 2
a372 2
	mat_idn( Rot );
	mat_idn( Inv );
d406 3
a408 3
	mat_idn( Shr );
	mat_idn( Trn );
	mat_idn( Inv );
d433 2
a434 2
	mat_idn( Scl );
	mat_idn( Inv );
d455 5
a459 5
	rt_log( "mag sheared H = %f\n", tgc->tgc_sH );
	rt_log( "mag A = %f\n", tgc->tgc_A );
	rt_log( "mag B = %f\n", tgc->tgc_B );
	rt_log( "mag C = %f\n", tgc->tgc_C );
	rt_log( "mag D = %f\n", tgc->tgc_D );
d462 2
a463 2
	mat_print( "Sc o Sh o R", tgc->tgc_ScShR );
	mat_print( "invR o trnSh o Sc", tgc->tgc_invRtShSc );
d466 1
a466 1
		rt_log( "A*D == C*B.  Equal eccentricities gives quadratic equation.\n");
d468 1
a468 1
		rt_log( "A*D != C*B.  Quartic equation.\n");
d470 4
a473 4
	rt_log( "(C/A - 1) = %f\n", tgc->tgc_CdAm1 );
	rt_log( "(D/B - 1) = %f\n", tgc->tgc_DdBm1 );
	rt_log( "(|A|**2)/(|C|**2) = %f\n", tgc->tgc_AAdCC );
	rt_log( "(|B|**2)/(|D|**2) = %f\n", tgc->tgc_BBdDD );
d541 1
a541 1
		rt_log("tgc(%s) dprime=(%g,%g,%g), t_scale=%e, miss.\n",
d650 1
a650 1
		LOCAL complex	val[4];	/* roots of final equation */
d707 2
a708 2
			rt_log("tgc:  reduced %d to %d roots\n",nroots,npts);
			rt_pr_roots( stp->st_name, val, nroots );
d720 1
a720 1
		rt_log("tgc(%s):  %d intersects != {0,2,4}\n",
d780 1
a780 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d796 1
a796 1
			rt_log("tgc: dprime[Z] = 0!\n" );
d820 1
a820 1
			rt_log("tgc(%s):  only 1 intersect\n", stp->st_name);
d845 1
a845 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d904 1
a904 1
	RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d942 1
a942 1
	C = (poly *)rt_malloc(n * sizeof(poly), "tor poly");
d1116 1
a1116 1
			LOCAL complex	val[4];	/* roots of final equation */
d1135 2
a1136 2
				rt_log("tgc:  reduced %d to %d roots\n",nroots,npts);
				rt_pr_roots( "tgc", val, nroots );
d1147 1
a1147 1
			rt_log("tgc(%s):  %d intersects != {0,2,4}\n",
d1229 1
a1229 1
				rt_log("tgc: dprime[Z] = 0!\n" );
d1256 1
a1256 1
				rt_log("tgc(%s):  only 1 intersect\n", stp[ix]->st_name);
d1342 1
a1342 1
	rt_free( (char *)C, "tor poly" );
d1459 1
a1459 1
		rt_log("rt_tgc_norm: bad surfno=%d\n", hitp->hit_surfno);
d1489 1
a1489 1
		uvp->uv_u = acos(pprime[Y]) * rt_inv2pi;
d1495 1
a1495 1
		uvp->uv_u = acos(pprime[Y]/len) * rt_inv2pi;
d1501 1
a1501 1
		uvp->uv_u = acos(pprime[Y]/len) * rt_inv2pi;
d1524 1
a1524 1
	rt_free( (char *)tgc, "tgc_specific");
d1543 1
a1543 1
CONST struct rt_external	*ep;
d1550 1
a1550 1
	RT_CK_EXTERNAL( ep );
d1554 1
a1554 1
		rt_log("rt_tgc_import: defective record\n");
d1560 1
a1560 1
	ip->idb_ptr = rt_malloc( sizeof(struct rt_tgc_internal), "rt_tgc_internal");
d1583 1
a1583 1
struct rt_external		*ep;
d1595 1
a1595 1
	RT_INIT_EXTERNAL(ep);
d1597 1
a1597 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "tgc external");
d1623 1
a1623 1
struct rt_vls		*str;
d1636 1
a1636 1
	rt_vls_strcat( str, "truncated general cone (TGC)\n");
d1642 1
a1642 1
	rt_vls_strcat( str, buf );
d1650 1
a1650 1
	rt_vls_strcat( str, buf );
d1652 1
a1652 1
		rt_vls_strcat( str, "H vector is zero!\n");
d1665 1
a1665 1
	rt_vls_strcat( str, buf );
d1672 1
a1672 1
	rt_vls_strcat( str, buf );
d1679 1
a1679 1
	rt_vls_strcat( str, buf );
d1686 1
a1686 1
	rt_vls_strcat( str, buf );
d1706 1
a1706 1
	rt_free( ip->idb_ptr, "tgc ifree" );
d1715 1
a1715 1
struct rt_list		*vhead;
d1718 1
a1718 1
struct rt_tol		*tol;
d1790 1
a1790 1
	mat_idn( dN );
d1802 2
a1803 2
	mat_mul( mtmp, dN, tgc->tgc_ScShR );
	mat_mul( M, tgc->tgc_invRtShSc, mtmp );
d1860 1
a1860 1
CONST struct rt_tol	*tol;
d1885 2
a1886 2
	struct nmg_ptbl		verts;		/* table of vertices used for top and bottom faces */
	struct nmg_ptbl		faces;		/* table of faceuses for nmg_gluefaces */
d1896 1
a1896 1
		rt_log( "tesselation tolerance is %fmm while calculational tolerance is %fmm\n",
d1898 1
a1898 1
		rt_log( "Cannot tesselate a TGC to finer tolerance than the calculational tolerance\n" );
d1918 1
a1918 1
		rt_log( "Illegal TGC a, b, and c or d less than tolerance\n" );
d1923 1
a1923 1
		rt_log( "Illegal TGC c, d, and a or b less than tolerance\n" );
d1979 1
a1979 1
			alpha_tol = rt_halfpi;
d1986 1
a1986 1
			abs = rt_halfpi;
d1993 1
a1993 1
				rel = rt_halfpi;
d1996 1
a1996 1
			rel = rt_halfpi;
d2018 1
a2018 1
			norm = rt_halfpi;
d2029 1
a2029 1
	nsegs = rt_halfpi / alpha_tol + 0.9999;
d2052 3
a2054 3
		factors = (fastf_t *)rt_malloc( nells*sizeof( fastf_t ), "factors" );
		A = (vect_t *)rt_malloc( nells*sizeof( vect_t ), "A vectors" );
		B = (vect_t *)rt_malloc( nells*sizeof( vect_t ), "B vectors" );
d2073 1
a2073 1
		ang = 2.0*rt_pi/((double)nsegs);
d2192 1
a2192 1
				rt_log( "rt_tgc_tess: Should never get here!!\n" );
d2233 1
a2233 1
	pts = (struct tgc_pts **)rt_calloc( nells , sizeof( struct tgc_pts *) , "rt_tgc_tess: pts" );
d2235 1
a2235 1
		pts[i] = (struct tgc_pts *)rt_calloc( nsegs , sizeof( struct tgc_pts ) , "rt_tgc_tess: pts" );
d2249 1
a2249 1
			alpha = rt_twopi * (double)(2*j+1)/(double)(2*nsegs);
d2302 1
a2302 1
	s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d2304 2
a2305 2
	nmg_tbl( &verts , TBL_INIT , (long *)NULL );
	nmg_tbl( &faces , TBL_INIT , (long *)NULL );
d2312 1
a2312 1
				nmg_tbl( &verts , TBL_INS , (long *)&pts[0][i].v );
d2315 1
a2315 1
		if( NMG_TBL_END( &verts ) > 2 )
d2317 2
a2318 2
			fu_base = nmg_cmface( s , (struct vertex ***)NMG_TBL_BASEADDR( &verts ), NMG_TBL_END( &verts ) );
			nmg_tbl( &faces , TBL_INS , (long *)fu_base );
d2330 1
a2330 1
		nmg_tbl( &verts , TBL_RST , (long *)NULL );
d2334 1
a2334 1
				nmg_tbl( &verts , TBL_INS , (long *)&pts[nells-1][i].v );
d2337 1
a2337 1
		if( NMG_TBL_END( &verts ) > 2 )
d2339 2
a2340 2
			fu_top = nmg_cmface( s , (struct vertex ***)NMG_TBL_BASEADDR( &verts ), NMG_TBL_END( &verts ) );
			nmg_tbl( &faces , TBL_INS , (long *)fu_top );
d2349 1
a2349 1
	nmg_tbl( &verts , TBL_FREE , (long *)NULL );
d2378 1
a2378 1
					nmg_tbl( &faces , TBL_INS , (long *)fu );
d2394 1
a2394 1
					nmg_tbl( &faces , TBL_INS , (long *)fu );
d2414 1
a2414 1
			alpha = rt_twopi * (double)(2*j+1)/(double)(2*nsegs);
d2446 1
a2446 1
	for( i=0 ; i<NMG_TBL_END( &faces ) ; i++ )
d2448 1
a2448 1
		fu = (struct faceuse *)NMG_TBL_GET( &faces , i );
d2453 1
a2453 1
			rt_log( "rt_tess_tgc: failed to calculate plane equation\n" );
d2508 1
a2508 1
				for( RT_LIST_FOR( vu , vertexuse , &pts[i][j].v->vu_hd ) )
d2530 3
a2532 3
	rt_free( (char *)factors, "rt_tgc_tess: factors" );
	rt_free( (char *)A , "rt_tgc_tess: A" );
	rt_free( (char *)B , "rt_tgc_tess: B" );
d2534 2
a2535 2
		rt_free( (char *)pts[i] , "rt_tgc_tess: pts[i]" );
	rt_free( (char *)pts , "rt_tgc_tess: pts" );
d2552 1
a2552 1
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d2558 1
a2558 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d2561 1
a2561 1
			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d2576 2
a2577 2
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ), tol );
	nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d2605 1
a2605 1
struct rt_tol		*tol;
d2648 1
a2648 1
	s = RT_LIST_FIRST( shell, &(*r)->s_hd);
d2653 2
a2654 2
	mat_idn( omat );
	mat_idn( mat);
d2662 1
a2662 1
	mat_mul(imat, mat, omat);
d2671 1
a2671 1
        mat_idn( omat );
d2678 1
a2678 1
	mat_mul(top_mat, omat, imat);
d2686 1
a2686 1
	lu = RT_LIST_FIRST( loopuse, &top_fu->lu_hd);
d2688 1
a2688 1
	eu= RT_LIST_FIRST( edgeuse, &lu->down_hd);
d2696 1
a2696 1
	eu = RT_LIST_NEXT( edgeuse, &eu->l);
d2703 2
a2704 2
	mat_idn( omat );
	mat_idn( mat);
d2712 1
a2712 1
        mat_mul(imat, mat, omat);
d2721 1
a2721 1
        mat_idn( omat );
d2727 1
a2727 1
        mat_mul(bot_mat, omat, imat);
d2734 1
a2734 1
	lu = RT_LIST_FIRST( loopuse, &bot_fu->lu_hd);
d2736 1
a2736 1
	eu= RT_LIST_FIRST( edgeuse, &lu->down_hd);
d2759 1
a2759 1
	lu = RT_LIST_FIRST( loopuse, &cyl_fu->lu_hd);
d2761 1
a2761 1
	eu= RT_LIST_FIRST( edgeuse, &lu->down_hd);
d2765 2
a2766 2
	eu= RT_LIST_LAST( edgeuse, &lu->down_hd);
	eu= RT_LIST_LAST( edgeuse, &eu->l);
d2891 1
a2891 1
	lu = RT_LIST_FIRST( loopuse, &fu->lu_hd);
d2893 1
a2893 1
	eu= RT_LIST_FIRST( edgeuse, &lu->down_hd);
d3022 1
a3022 1
	lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
d3024 1
a3024 1
	eu = RT_LIST_FIRST( edgeuse, &lu->down_hd);
d3037 1
a3037 1
	eu = RT_LIST_NEXT( edgeuse, &eu->l);
d3043 1
a3043 1
	eu = RT_LIST_NEXT( edgeuse, &eu->l);
d3054 1
a3054 1
	eu = RT_LIST_NEXT( edgeuse, &eu->l);
d3060 1
a3060 1
	eu = RT_LIST_NEXT( edgeuse, &eu->l);
d3064 1
a3064 1
	lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
d3066 1
a3066 1
	eu = RT_LIST_FIRST( edgeuse, &lu->down_hd);
d3072 1
a3072 1
		eu = RT_LIST_NEXT(edgeuse, &eu->l);
@


11.12
log
@Mod to nmg_gluefaces() call.
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 11.11 1996/09/30 16:02:24 jra Exp jra $ (BRL)";
d73 9
@


11.11
log
@Mods to rt_tgc_tess() to handle TGCs with small radii.
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 11.10 1996/08/31 10:52:55 mike Exp jra $ (BRL)";
d1851 1
a1851 1
struct rt_tol		*tol;
d2567 1
a2567 1
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
@


11.10
log
@bn.h
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 11.9 1996/08/27 06:34:07 mike Exp mike $ (BRL)";
d1836 4
a1839 2
	vect_t tan_axb;
	struct vertex *v;
d1842 2
d1858 1
d1860 2
d1871 1
d1885 7
d1895 2
d1898 2
d1901 2
d1904 34
d1955 1
a1955 1
	if( a < min_radius )
d1957 1
a1957 1
	if( b < min_radius )
d1959 1
a1959 1
	if( c < min_radius )
d1961 1
a1961 1
	if( d < min_radius )
d2027 159
a2185 10
	/* check for long skinny triangles.
	 * narrowest will be: */
	narrow = 2.0 * min_radius * sin( alpha_tol );
	/* use h for height of triangle,
	 * (note that this may not be true for AxB !|| CxD */
	ratio = h/narrow;
	if( ratio > 10.0 )
		nsplits = ratio/10.0;
	else
		nsplits = 0;
d2187 4
a2190 1
	nells = nsplits + 2;
d2192 6
a2197 6
	/* construct a list of ellipses from the bottom to
	 * the top of the tgc, with intermediate ellipses interpolated
	 * from top and bottom
	 */
	A = (vect_t *)rt_calloc( nells , sizeof( vect_t ) , "rt_tgc_tess: A" );
	B = (vect_t *)rt_calloc( nells , sizeof( vect_t ) , "rt_tgc_tess: B" );
d2199 2
a2200 5
	/* set top and bottom ellipses */
	VMOVE( A[0] , tip->a );
	VMOVE( B[0] , tip->b );
	VMOVE( A[nells-1] , tip->c );
	VMOVE( B[nells-1] , tip->d );
d2202 10
a2211 9
	/* make sure that AxB points in the general direction of H */
	VCROSS( vtmp , A[0] , B[0] );
	if( VDOT( vtmp , tip->h ) < 0.0 )
	{
		/* exchange A's and B's */
		VMOVE( B[0] , tip->a );
		VMOVE( A[0] , tip->b );
		VMOVE( B[nells-1] , tip->c );
		VMOVE( A[nells-1] , tip->d );
d2213 5
a2217 1
	}
d2219 1
a2219 4
	/* set intermediate ellipses */
	for( i=1 ; i<nells-1 ; i++ )
	{
		fastf_t factor;
a2220 3
		factor = (double)i/(double)(nells-1);
		VCOMB2( A[i] , factor , A[nells-1] , (1.0-factor) , A[0] );
		VCOMB2( B[i] , factor , B[nells-1] , (1.0-factor) , B[0] );
d2228 63
a2294 1
	/* Make bottom face */
d2297 8
a2304 2
	for( i=nsegs-1 ; i>=0 ; i-- ) /* reverse order to get outward normal */
		nmg_tbl( &verts , TBL_INS , (long *)&pts[0][i].v );
d2306 11
a2316 2
	fu_base = nmg_cmface( s , (struct vertex ***)NMG_TBL_BASEADDR( &verts ), nsegs );
	nmg_tbl( &faces , TBL_INS , (long *)fu_base );
d2319 8
a2326 3
	nmg_tbl( &verts , TBL_RST , (long *)NULL );
	for( i=0 ; i<nsegs ; i++ )
		nmg_tbl( &verts , TBL_INS , (long *)&pts[nells-1][i].v );
d2328 10
a2337 2
	fu_top = nmg_cmface( s , (struct vertex ***)NMG_TBL_BASEADDR( &verts ), nsegs );
	nmg_tbl( &faces , TBL_INS , (long *)fu_top );
d2346 2
d2349 2
d2358 31
a2388 11
			v[0] = &pts[i][j].v;
			v[1] = &pts[i][k].v;
			v[2] = &pts[i+1][j].v;
			fu = nmg_cmface( s , v , 3 );
			nmg_tbl( &faces , TBL_INS , (long *)fu );

			v[0] = &pts[i+1][k].v;
			v[1] = &pts[i+1][j].v;
			v[2] = &pts[i][k].v;
			fu = nmg_cmface( s , v , 3 );
			nmg_tbl( &faces , TBL_INS , (long *)fu );
d2398 1
a2398 1
		h_factor = (double)i/(double)(nells-1);
d2401 1
a2403 1
			point_t pt_geom;
d2410 15
a2424 2
			VJOIN3( pt_geom , tip->v , h_factor , tip->h , cos_alpha , A[i] , sin_alpha , B[i] );
			nmg_vertex_gv( pts[i][j].v , pt_geom );
d2427 6
a2432 1
			VCOMB2( pts[i][j].tan_axb , -sin_alpha , A[i] , cos_alpha , B[i] );
d2445 1
d2454 1
a2454 1
		int j,k;
d2467 23
a2489 3
				VSUB2( tan_h , pts[i][j].v->vg_p->coord , pts[k][j].v->vg_p->coord )
			    else
				VSUB2( tan_h , pts[k][j].v->vg_p->coord , pts[i][j].v->vg_p->coord )
d2491 1
a2491 1
				    VCROSS( normal , pts[i][j].tan_axb , tan_h );
d2495 3
a2497 1
			for( RT_LIST_FOR( vu , vertexuse , &pts[i][j].v->vu_hd ) )
d2499 17
a2515 14
				NMG_CK_VERTEXUSE( vu );

				fu = nmg_find_fu_of_vu( vu );
				NMG_CK_FACEUSE( fu );

				/* don't need vertexuse normals for faces that are really flat */
				if( fu == fu_base || fu == fu_base->fumate_p ||
				    fu == fu_top  || fu == fu_top->fumate_p )
					continue;

				if( fu->orientation == OT_SAME )
					nmg_vertexuse_nv( vu , normal );
				else if( fu->orientation == OT_OPPOSITE )
					nmg_vertexuse_nv( vu , rev_norm );
d2521 1
d2537 3
@


11.9
log
@Fixed minor declaration and syntax errors.
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 11.8 1996/07/12 12:10:21 jra Exp mike $ (BRL)";
d641 1
a641 1
		LOCAL complex	val[MAXP];	/* roots of final equation */
d1107 1
a1107 1
			LOCAL complex	val[MAXP];	/* roots of final equation */
@


11.8
log
@Minor Mods for IRIX 6.2
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 11.7 1996/05/16 21:47:54 jra Exp jra $ (BRL)";
d2319 1
a2319 1
	nmg_vertexuse_a_cnurb( eu->vu_p, &uvw);
d2321 1
a2321 1
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &uvw );
d2367 1
a2367 1
	nmg_vertexuse_a_cnurb( eu->vu_p, &uvw);
d2369 1
a2369 1
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &uvw );
d2427 1
a2427 1
void
d2580 1
a2580 1
void
d2660 1
a2660 1
	nmg_vertexuse_a_cnurb( eu->vu_p, &uvw );
d2662 1
a2662 1
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &uvw );
d2666 1
a2666 1
	nmg_vertexuse_a_cnurb( eu->vu_p, &uvw );
d2668 1
a2668 1
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &uvw );
d2672 1
a2672 1
	nmg_vertexuse_a_cnurb( eu->vu_p, &uvw );
d2674 1
a2674 1
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &uvw );
d2683 1
a2683 1
	nmg_vertexuse_a_cnurb( eu->vu_p, &uvw );
d2685 1
a2685 1
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &uvw );
@


11.7
log
@Replaced a call to nmg_fu_planeeqn() with nmg_calc_face_g().
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 11.6 1995/12/04 21:12:08 stay Exp jra $ (BRL)";
d51 1
a51 1
static void	rt_tgc_scale();
d2397 1
d2427 1
d2580 1
a2580 1

@


11.6
log
@fixed trimming curves, for proper orientation of tiling
proceedure.
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 11.5 1995/12/02 03:20:39 stay Exp stay $ (BRL)";
d2107 1
a2107 1
		if( nmg_fu_planeeqn( fu , tol ) )
@


11.5
log
@tnurb version that stil lneeds work. Geometry is correct but the
trimming curves may be wrong.
@
text
@d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 11.1 95/01/04 09:57:03 mike Rel4_4 $ (BRL)";
a2326 4
rt_log("after top cap surf\n");
nmg_region_a( *r,tol);
nmg_vmodel( m );

a2373 5
rt_log("disk\n");
nmg_region_a( *r,tol);
nmg_vmodel( m );
rt_log("after disk\n");

a2383 5
rt_log("before fuse\n");
nmg_region_a( *r,tol);
nmg_vmodel( m );
rt_log("after fuse\n");

a2394 1

a2396 2
rt_log("end fuse\n");
nmg_vmodel( m );
a2586 1
	struct edge_g_cnurb	* eg;
d2592 1
d2650 2
d2653 2
a2654 2
	/* March around the fu's loop assigning uv parameter values */
	HDIVIDE( point, fg->ctl_points );
d2657 1
a2657 1
	VSET( uvw, 0,0,0);
d2663 1
d2669 1
a2669 3
	HDIVIDE( point, &fg->ctl_points[(2*9-1)*4] );
	nmg_vertex_gv( eu->vu_p->v_p, point );		/* 4,1 vertex */

d2673 5
d2680 1
a2692 1

a2698 1

@


11.4
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@a2275 41
	/* Create topology for top cap surface */

	verts[0] = verts[1] = NULL;
	vertp[0] = &verts[0];
	top_fu = nmg_cmface(s, vertp, 1);

	lu = RT_LIST_FIRST( loopuse, &top_fu->lu_hd);
	NMG_CK_LOOPUSE(lu);
	eu= RT_LIST_FIRST( edgeuse, &lu->down_hd);
	NMG_CK_EDGEUSE(eu);
	top_eu = eu;

	VSET( uvw, 0,0,0);
	nmg_vertexuse_a_cnurb( eu->vu_p, &uvw);
	VSET( uvw, 1, 0, 0);
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &uvw );
	eu = RT_LIST_NEXT( edgeuse, &eu->l);

	/* Create topology for cylinder surface  */

	vertp[0] = &verts[0];
	vertp[1] = &verts[0];
	vertp[2] = &verts[1];
	vertp[3] = &verts[1];
	cyl_fu = nmg_cmface(s, vertp, 4);

	/* Create topology for bottom cap surface */

	vertp[0] = &verts[1];
	bot_fu = nmg_cmface(s, vertp, 1);

	lu = RT_LIST_FIRST( loopuse, &bot_fu->lu_hd);
	NMG_CK_LOOPUSE(lu);
	eu= RT_LIST_FIRST( edgeuse, &lu->down_hd);
	NMG_CK_EDGEUSE(eu);
	bot_eu = eu;

	VSET( uvw, 0,0,0);
	nmg_vertexuse_a_cnurb( eu->vu_p, &uvw);
	VSET( uvw, 1, 0, 0);
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &uvw );
d2306 18
d2327 4
d2359 17
d2378 13
d2393 5
d2400 1
a2400 2
{
	int i;
a2401 6
	for(i=0; i<4; i++ )  {
		rt_log(" %d  eu=x%x, e=x%x, v=x%x\n", i,
			eu, eu->e_p, eu->vu_p->v_p);
		eu = RT_LIST_NEXT( edgeuse, &eu->l);
	}
}
a2402 2
	eu= RT_LIST_FIRST( edgeuse, &lu->down_hd);
rt_log("je x%x e=(x%x) x%x e=(x%x)\n", top_eu, top_eu->e_p, eu, eu->e_p);
a2403 1
nmg_pr_eg( (CONST long *) top_eu->g.cnurb_p, 0 );
d2407 1
a2407 1
rt_log("je x%x e=(x%x) x%x e=(x%x)\n", bot_eu, bot_eu->e_p, eu, eu->e_p);
a2409 2
nmg_pr_eg( (CONST long *) bot_eu->g.cnurb_p, 0 );
		
d2411 3
d2486 2
a2487 2
		fg->ctl_points[3] = 1;
		fg->ctl_points[4] = 1.;
d2490 2
a2491 2
		fg->ctl_points[6] = -1.;
		fg->ctl_points[7] = -1.;
d2537 12
a2548 2
	rt_nurb_s_eval( fu->f_p->g.snurb_p, nmg_uv_unitcircle[0], nmg_uv_unitcircle[1], point );
	nmg_vertex_gv( eu->vu_p->v_p, point );
d2559 9
a2567 9
	eg->k.knots[3] = 1.0;
	eg->k.knots[4] = 1.0;
	eg->k.knots[5] = 2.0;
	eg->k.knots[6] = 2.0;
	eg->k.knots[7] = 3.0;
	eg->k.knots[8] = 3.0;
	eg->k.knots[9] = 4.0;
	eg->k.knots[10] = 4.0;
	eg->k.knots[11] = 4.0;
d2569 1
a2569 1
	for( i = 0; i < 27; i++)
d2571 2
a2572 1
		eg->ctl_points[i] = nmg_uv_unitcircle[i];
d2574 2
d2577 10
d2604 1
d2629 9
a2637 9
	fg->u.knots[3] = 1.0;
	fg->u.knots[4] = 1.0;
	fg->u.knots[5] = 2.0;
	fg->u.knots[6] = 2.0;
	fg->u.knots[7] = 3.0;
	fg->u.knots[8] = 3.0;
	fg->u.knots[9] = 4.0;
	fg->u.knots[10] = 4.0;
	fg->u.knots[11] = 4.0;
d2684 1
a2684 1
	nmg_vertex_gv( eu->vu_p->v_p, point );	/* 1,1 vertex */
d2692 1
a2692 1
	VSET( uvw, 0,0, 0);
d2703 1
a2709 1

@


11.3
log
@Mostly working tile/tess routine for TGC.
Cyl body normal is reversed.
@
text
@d2414 6
a2420 6
	0.0, 1.0, 0.0, 1.0,
	-RAT, RAT, 0.0, RAT,
	-1.0, 0.0, 0.0, 1.0,
	-RAT, -RAT, 0.0, RAT,
	0.0, -1.0, 0.0, 1.0,
	RAT, -RAT, 0.0, RAT,
a2446 1
	struct snurb	s;	/* XXX hack, don't free! */
d2479 2
a2480 2
		fg->ctl_points[3] = -1;
		fg->ctl_points[4] = -1.;
d2483 2
a2484 2
		fg->ctl_points[6] = 1.;
		fg->ctl_points[7] = 1.;
d2530 1
a2530 2
	nmg_hack_snurb( &s, fu->f_p->g.snurb_p );
	rt_nurb_s_eval( &s, nmg_uv_unitcircle[0], nmg_uv_unitcircle[1], point );
d2637 1
a2637 1
	/* March around the fu's loop assignin uv parameter values */
@


11.2
log
@initial version of tiling for generalized truncated cone
to nurbs representation. Still need toadd to nmg data structures
but the geometry seem s to be right.
@
text
@a73 5
struct snurb * tgc_disk();
struct snurb * tgc_nurb_cyl();
struct cnurb * tgc_unitcircle();


d2246 2
d2278 1
d2286 1
a2293 4
	nmg_vertexuse_a_cnurb( eu->vu_p, &uvw );
	VSET( uvw, 0, 0, 0);
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &uvw );

a2301 27
	lu = RT_LIST_FIRST( loopuse, &cyl_fu->lu_hd );
	NMG_CK_LOOPUSE(lu);
	eu = RT_LIST_FIRST( edgeuse, &lu->down_hd);
	NMG_CK_EDGEUSE(eu);

	/* March around the fu's loop assignin uv parameter values */
	VSET( uvw, 0,0,0);
	nmg_vertexuse_a_cnurb( eu->vu_p, &uvw );
	VSET( uvw, 1, 0, 0);
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &uvw );
	eu = RT_LIST_NEXT( edgeuse, &eu->l);

	nmg_vertexuse_a_cnurb( eu->vu_p, &uvw );
	VSET( uvw, 1, 1, 0);
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &uvw );
	eu = RT_LIST_NEXT( edgeuse, &eu->l);

	nmg_vertexuse_a_cnurb( eu->vu_p, &uvw );
	VSET( uvw, 0, 1, 0);
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &uvw );
	eu = RT_LIST_NEXT( edgeuse, &eu->l);

	nmg_vertexuse_a_cnurb( eu->vu_p, &uvw );
	VSET( uvw, 0,0, 0);
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &uvw );
	eu = RT_LIST_NEXT( edgeuse, &eu->l);

d2307 1
a2307 1
	lu = RT_LIST_FIRST( loopuse, &top_fu->lu_hd);
d2311 1
a2316 5
	eu = RT_LIST_NEXT( edgeuse, &eu->l);

	nmg_vertexuse_a_cnurb( eu->vu_p, &uvw );
	VSET( uvw, 0, 0, 0);
	nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &uvw );
d2348 1
a2348 2
	top_srf = (struct snurb *) tgc_disk( top_mat, 0.0, 0 );
	top_cnurb = (struct cnurb *) tgc_unitcircle();
d2378 1
a2378 2
	bot_srf = (struct snurb*) tgc_disk( bot_mat, 1.0, 0 );
	bot_cnurb = (struct cnurb*) tgc_unitcircle();
d2380 1
a2380 1
	cyl_srf = (struct snurb *) tgc_nurb_cyl(top_mat, bot_mat);
d2382 25
d2409 29
a2437 2
struct snurb *
tgc_disk(rmat, height, flip)
d2442 4
a2445 1
	struct snurb * srf;
d2447 1
d2451 1
d2453 20
a2472 2
	srf = (struct snurb *) rt_nurb_new_snurb(
	    2, 2, 4, 4, 2, 2, RT_NURB_MAKE_PT_TYPE(3,2,0));
a2473 9
	srf->u_knots.knots[0] = 0.0;
	srf->u_knots.knots[1] = 0.0;
	srf->u_knots.knots[2] = 1.0;
	srf->u_knots.knots[3] = 1.0;

	srf->v_knots.knots[0] = 0.0;
	srf->v_knots.knots[1] = 0.0;
	srf->v_knots.knots[2] = 1.0;
	srf->v_knots.knots[3] = 1.0;
d2476 15
a2490 15
		srf->ctl_points[0] = 1.;
		srf->ctl_points[1] = -1.;
		srf->ctl_points[2] = height;

		srf->ctl_points[3] = -1;
		srf->ctl_points[4] = -1.;
		srf->ctl_points[5] = height;

		srf->ctl_points[6] = 1.;
		srf->ctl_points[7] = 1.;
		srf->ctl_points[8] = height;

		srf->ctl_points[9] = -1.;
		srf->ctl_points[10] = 1.;
		srf->ctl_points[11] = height;
d2494 15
a2508 15
		srf->ctl_points[0] = -1.;
		srf->ctl_points[1] = -1.;
		srf->ctl_points[2] = height;

		srf->ctl_points[3] = 1;
		srf->ctl_points[4] = -1.;
		srf->ctl_points[5] = height;

		srf->ctl_points[6] = -1.;
		srf->ctl_points[7] = 1.;
		srf->ctl_points[8] = height;

		srf->ctl_points[9] = 1.;
		srf->ctl_points[10] = 1.;
		srf->ctl_points[11] = height;
d2512 2
a2513 2
	mptr = srf->ctl_points;
	coords = RT_NURB_EXTRACT_COORDS(srf->pt_type);
d2515 1
a2515 1
	i = srf->s_size[0] * srf->s_size[1];
d2526 4
a2529 2
	return srf;
}
d2531 22
a2552 3
struct cnurb *
tgc_unitcircle()
{
d2554 4
a2557 67
	struct cnurb * cir;
	fastf_t rat = .707107;

	cir = (struct cnurb * )
		rt_nurb_new_cnurb( 3, 12,9, RT_NURB_MAKE_PT_TYPE(4,3,1));

	cir->knot.k_size = 12;

	cir->knot.knots[0] = 0.0;
	cir->knot.knots[1] = 0.0;
	cir->knot.knots[2] = 0.0;
	cir->knot.knots[3] = 1.0;
	cir->knot.knots[4] = 1.0;
	cir->knot.knots[5] = 2.0;
	cir->knot.knots[6] = 2.0;
	cir->knot.knots[7] = 3.0;
	cir->knot.knots[8] = 3.0;
	cir->knot.knots[9] = 4.0;
	cir->knot.knots[10] = 4.0;
	cir->knot.knots[11] = 4.0;

	cir->c_size = 9;

        cir->ctl_points[0] = 1.0;               /* point 1 */
        cir->ctl_points[1] = 0.0;
        cir->ctl_points[2] = 0.0;
        cir->ctl_points[3] = 1.0;

        cir->ctl_points[4] = rat;               /* point 2*/
        cir->ctl_points[5] = rat;
        cir->ctl_points[6] = 0.0;
        cir->ctl_points[7] = rat;

        cir->ctl_points[8] = 0;                 /* point 3 */
        cir->ctl_points[9] = 1.0;
        cir->ctl_points[10] = 0.0;
        cir->ctl_points[11] = 1.0;

        cir->ctl_points[12] = -rat;             /* point 4 */
        cir->ctl_points[13] = rat;
        cir->ctl_points[14] = 0.0;
        cir->ctl_points[15] = rat;

        cir->ctl_points[16] = -1.0;             /* point 5 */
        cir->ctl_points[17] = 0.0;
        cir->ctl_points[18] = 0.0;
        cir->ctl_points[19] = 1.0;

        cir->ctl_points[20] = -rat;             /* point 6 */
        cir->ctl_points[21] = -rat;
        cir->ctl_points[22] = 0.0;
        cir->ctl_points[23] = rat;

        cir->ctl_points[24] = 0;                /* point 7 */
        cir->ctl_points[25] = -1.0;
        cir->ctl_points[26] = 0.0;
        cir->ctl_points[27] = 1.0;

        cir->ctl_points[28] = rat;              /* point 8 */
        cir->ctl_points[29] = -rat;
        cir->ctl_points[30] = 0.0;
        cir->ctl_points[31] = rat;

        cir->ctl_points[32] = 1.0;              /* point 9 */
        cir->ctl_points[33] = 0.0;
        cir->ctl_points[34] = 0.0;
        cir->ctl_points[35] = 1.0;
a2558 1
	return cir;
d2560 1
a2560 1

d2568 2
a2569 2
struct snurb *
tgc_nurb_cyl(top_mat, bot_mat)
d2573 3
a2575 4
	
	struct cnurb 	* top_crv;
	struct cnurb 	* bot_crv;
	struct snurb 	* srf;
d2579 2
a2580 3

	top_crv = tgc_unitcircle();
	bot_crv = tgc_unitcircle();
d2582 27
a2608 1
	mptr = top_crv->ctl_points;
d2610 1
a2610 1
	i = top_crv->c_size;
d2612 1
a2612 1
	for( ; i > 0; i--)
d2614 1
a2614 1
		MAT4X4PNT(vect, top_mat, mptr);
d2622 1
a2622 5
	mptr = bot_crv->ctl_points;

	i = bot_crv->c_size;

	for( ; i > 0; i--)
d2624 1
a2624 1
		MAT4X4PNT(vect, bot_mat, mptr);
d2632 29
a2660 8
	srf = rt_nurb_new_snurb(2, top_crv->order, 
		4, top_crv->knot.k_size, 
		2, top_crv->c_size, top_crv->pt_type);

	srf->u_knots.knots[0] = 0.0;
	srf->u_knots.knots[1] = 0.0;
	srf->u_knots.knots[2] = 1.0;
	srf->u_knots.knots[3] = 1.0;
d2662 4
a2665 4
	for(i = 0; i < top_crv->knot.k_size; i++)
	{
		srf->v_knots.knots[i] = top_crv->knot.knots[i];
	}
d2667 1
a2667 1
	mptr = srf->ctl_points;
d2669 4
a2672 4
	for(i = 0; i < top_crv->c_size * 4; i++)
	{
		*mptr++ = top_crv->ctl_points[i];
	}
d2674 1
a2674 1
	for(i = 0; i < bot_crv->c_size * 4; i++)
d2676 2
a2677 1
		*mptr++ = bot_crv->ctl_points[i];
a2678 1
	return srf;
d2680 1
@


11.1
log
@Release_4.4
@
text
@d18 1
d30 1
a30 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 10.11 94/12/27 17:14:40 mike Exp $ (BRL)";
d46 1
a46 1

d48 1
a48 1
	struct rt_i *rtip));
d74 5
d135 1
a135 1
	     NEAR_ZERO( mag_c, RT_LEN_TOL ) ) {
d176 1
a176 1
				stp->st_name, f);
d178 1
a178 1
				VDOT( tip->a, tip->b ),  prod_ab );
d187 1
a187 1
				stp->st_name, f);
d189 1
a189 1
				VDOT( tip->c, tip->d ), prod_cd );
d199 1
a199 1
				stp->st_name, f);
d209 1
a209 1
				stp->st_name, f);
d302 3
a304 3
			(stp->st_max[X] + stp->st_min[X])/2,
			(stp->st_max[Y] + stp->st_min[Y])/2,
			(stp->st_max[Z] + stp->st_min[Z])/2 );
d347 1
a347 1
			mag_hb;		/*    A and B directions	*/
d448 1
a448 1
		(struct tgc_specific *)stp->st_specific;
d509 1
a509 1
		(struct tgc_specific *)stp->st_specific;
d538 1
a538 1
			V3ARGS(dprime), t_scale);
d670 2
a671 2
			  Rsqr.cf[0] * Ysqr.cf[0] -
			  (Rsqr.cf[0] * Qsqr.cf[0]);
d673 2
a674 2
			  Rsqr.cf[0] * Ysqr.cf[1] + Rsqr.cf[1] * Ysqr.cf[0] -
			  (Rsqr.cf[0] * Qsqr.cf[1] + Rsqr.cf[1] * Qsqr.cf[0]);
d676 5
a680 5
				 Qsqr.cf[2] * Xsqr.cf[0] +
			  Rsqr.cf[0] * Ysqr.cf[2] + Rsqr.cf[1] * Ysqr.cf[1] +
				 Rsqr.cf[2] * Ysqr.cf[0] -
			  (Rsqr.cf[0] * Qsqr.cf[2] + Rsqr.cf[1] * Qsqr.cf[1] +
				 Rsqr.cf[2] * Qsqr.cf[0]);
d682 2
a683 2
			  Rsqr.cf[1] * Ysqr.cf[2] + Rsqr.cf[2] * Ysqr.cf[1] -
			  (Rsqr.cf[1] * Qsqr.cf[2] + Rsqr.cf[2] * Qsqr.cf[1]);
d685 2
a686 2
			  Rsqr.cf[2] * Ysqr.cf[2] -
			  (Rsqr.cf[2] * Qsqr.cf[2]);
d717 1
a717 1
			stp->st_name, npts );
d756 1
a756 1
			}  else  {
d937 4
a940 4
        /* Allocate space for polys and roots */
        C = (poly *)rt_malloc(n * sizeof(poly), "tor poly");
 
        /* Initialize seg_stp to assume hit (zero will then flag miss) */
d942 1
a942 1
        for(ix = 0; ix < n; ix++) segp[ix].seg_stp = stp[ix];
d944 1
a944 1
    /* for each ray/cone pair */
d946 1
a946 1
    for(ix = 0; ix < n; ix++) {
d949 1
a949 1
	if (segp[ix].seg_stp == 0) continue; /* == 0 signals skip ray */
d952 1
a952 1
	tgc = (struct tgc_specific *)stp[ix]->st_specific;
d954 2
a955 2
	/* find rotated point and direction */
	MAT4X3VEC( dprime, tgc->tgc_ScShR, rp[ix]->r_dir );
d957 1
a957 1
	/*
d962 5
a966 2
	t_scale = 1/MAGNITUDE( dprime );
	VSCALE( dprime, dprime, t_scale );	/* VUNITIZE( dprime ); */
d968 2
a969 2
	if( NEAR_ZERO( dprime[Z], RT_PCOEF_TOL ) )
		dprime[Z] = 0.0;	/* prevent rootfinder heartburn */
d971 2
a972 5
	/* Use segp[ix].seg_in.hit_normal as tmp to hold dprime */
	VMOVE( segp[ix].seg_in.hit_normal, dprime );
 
	VSUB2( work, rp[ix]->r_pt, tgc->tgc_V );
	MAT4X3VEC( pprime, tgc->tgc_ScShR, work );
d974 2
a975 2
	/* Use segp[ix].seg_out.hit_normal as tmp to hold pprime */
	VMOVE( segp[ix].seg_out.hit_normal, pprime );
d977 1
a977 1
	/* Translating ray origin along direction of ray to closest
d981 3
a983 3
	cor_proj = VDOT( pprime, dprime );
	VSCALE( cor_pprime, dprime, cor_proj );
	VSUB2( cor_pprime, pprime, cor_pprime );
d985 1
a985 1
	/*
d1007 20
a1026 4
	Xsqr.dgr = 2;
	Xsqr.cf[0] = dprime[X] * dprime[X];
	Xsqr.cf[1] = 2.0 * dprime[X] * cor_pprime[X];
	Xsqr.cf[2] = cor_pprime[X] * cor_pprime[X];
d1028 1
a1028 17
	Ysqr.dgr = 2;
	Ysqr.cf[0] = dprime[Y] * dprime[Y];
	Ysqr.cf[1] = 2.0 * dprime[Y] * cor_pprime[Y];
	Ysqr.cf[2] = cor_pprime[Y] * cor_pprime[Y];

	R.dgr = 1;
	R.cf[0] = dprime[Z] * tgc->tgc_CdAm1;
	/* A vector is unitized (tgc->tgc_A == 1.0) */
	R.cf[1] = (cor_pprime[Z] * tgc->tgc_CdAm1) + 1.0;

	/* (void) rt_poly_mul( &R, &R, &Rsqr ); inline expands to: */
                Rsqr.dgr = 2;
                Rsqr.cf[0] = R.cf[0] * R.cf[0];
                Rsqr.cf[1] = R.cf[0] * R.cf[1] * 2;
                Rsqr.cf[2] = R.cf[1] * R.cf[1];

	/*
d1033 9
a1041 9
	if ( tgc->tgc_AD_CB ){
		/* (void) rt_poly_add( &Xsqr, &Ysqr, &sum ); and */
		/* (void) rt_poly_sub( &sum, &Rsqr, &C ); inline expand to */
		C[ix].dgr = 2;
		C[ix].cf[0] = Xsqr.cf[0] + Ysqr.cf[0] - Rsqr.cf[0];
		C[ix].cf[1] = Xsqr.cf[1] + Ysqr.cf[1] - Rsqr.cf[1];
		C[ix].cf[2] = Xsqr.cf[2] + Ysqr.cf[2] - Rsqr.cf[2];
	} else {
		LOCAL poly	Q, Qsqr;
d1043 4
a1046 4
		Q.dgr = 1;
		Q.cf[0] = dprime[Z] * tgc->tgc_DdBm1;
		/* B vector is unitized (tgc->tgc_B == 1.0) */
		Q.cf[1] = (cor_pprime[Z] * tgc->tgc_DdBm1) + 1.0;
d1048 1
a1048 1
		/* (void) rt_poly_mul( &Q, &Q, &Qsqr ); inline expands to */
d1054 1
a1054 1
		/* (void) rt_poly_mul( &Qsqr, &Xsqr, &T1 ); inline expands to */
d1058 1
a1058 1
					 Qsqr.cf[1] * Xsqr.cf[0];
d1060 2
a1061 2
					 Qsqr.cf[1] * Xsqr.cf[1] +
					 Qsqr.cf[2] * Xsqr.cf[0];
d1063 1
a1063 1
					 Qsqr.cf[2] * Xsqr.cf[1];
d1066 2
a1067 2
		/* (void) rt_poly_mul( &Rsqr, &Ysqr, &T2 ); and */
		/* (void) rt_poly_add( &T1, &T2, &sum ); inline expand to */
d1070 1
a1070 1
					 Rsqr.cf[1] * Ysqr.cf[0];
d1072 2
a1073 2
					 Rsqr.cf[1] * Ysqr.cf[1] +
					 Rsqr.cf[2] * Ysqr.cf[0];
d1075 1
a1075 1
					 Rsqr.cf[2] * Ysqr.cf[1];
d1078 2
a1079 2
		/* (void) rt_poly_mul( &Rsqr, &Qsqr, &T3 ); and */
		/* (void) rt_poly_sub( &sum, &T3, &C ); inline expand to */
d1082 1
a1082 1
					 Rsqr.cf[1] * Qsqr.cf[0];
d1084 2
a1085 2
					 Rsqr.cf[1] * Qsqr.cf[1] +
					 Rsqr.cf[2] * Qsqr.cf[0];
d1087 1
a1087 1
					 Rsqr.cf[2] * Qsqr.cf[1];
d1093 18
a1110 12
    /* It seems impractical to try to vectorize finding and sorting roots. */
    for(ix = 0; ix < n; ix++){
	if (segp[ix].seg_stp == 0) continue; /* == 0 signals skip ray */

	/* Again, check for the equal eccentricities case. */
	if ( C[ix].dgr == 2 ){
		FAST fastf_t roots;

		/* Find the real roots the easy way. */
		if( (roots = C[ix].cf[1]*C[ix].cf[1]-4*C[ix].cf[0]*C[ix].cf[2]
		    ) < 0 ) {
			npts = 0;	/* no real roots */
d1112 3
a1114 9
			roots = sqrt(roots);
			k[0] = (roots - C[ix].cf[1]) * 0.5 / C[ix].cf[0];
			k[1] = (roots + C[ix].cf[1]) * (-0.5) / C[ix].cf[0];
			npts = 2;
		}
	} else {
		LOCAL complex	val[MAXP];	/* roots of final equation */
		register int	l;
		register int nroots;
d1116 2
a1117 2
		/*  The equation is 4th order, so we expect 0 to 4 roots */
		nroots = rt_poly_roots( &C[ix] , val );
d1119 1
a1119 1
		/*  Only real roots indicate an intersection in real space.
d1125 9
a1133 8
		for ( l=0, npts=0; l < nroots; l++ ){
			if ( NEAR_ZERO( val[l].im, 0.0001 ) )
				k[npts++] = val[l].re;
		}
		/* Here, 'npts' is number of points being returned */
		if ( npts != 0 && npts != 2 && npts != 4 ){
			rt_log("tgc:  reduced %d to %d roots\n",nroots,npts);
			rt_pr_roots( "tgc", val, nroots );
a1134 1
	}
d1136 1
a1136 1
	/*
d1139 2
a1140 2
	for( i = 0; i < npts; ++i )
		k[i] -= cor_proj;
d1142 6
a1147 6
	if ( npts != 0 && npts != 2 && npts != 4 ){
		rt_log("tgc(%s):  %d intersects != {0,2,4}\n",
			stp[ix]->st_name, npts );
		RT_TGC_SEG_MISS(segp[ix]);		/* No hit	*/
		continue;
	}
d1149 2
a1150 2
	/* Most distant to least distant	*/
	rt_pt_sort( k, npts );
d1152 1
a1152 1
	/* Now, k[0] > k[npts-1] */
d1154 1
a1154 1
	/* General Cone may have 4 intersections, but	*
d1160 1
a1160 1
	/*		Truncation Procedure
d1165 14
a1178 13
	intersect = 0;
	tgc = (struct tgc_specific *)stp[ix]->st_specific;
	for ( i=0; i < npts; i++ ){
		/* segp[ix].seg_in.hit_normal holds dprime */
		/* segp[ix].seg_out.hit_normal holds pprime */
		zval = k[i]*segp[ix].seg_in.hit_normal[Z] +
			segp[ix].seg_out.hit_normal[Z];
		/* Height vector is unitized (tgc->tgc_sH == 1.0) */
		if ( zval < 1.0 && zval > 0.0 ){
			if ( ++intersect == 2 )  {
				pt[IN] = k[i];
			}  else
				pt[OUT] = k[i];
d1180 4
a1184 5
	/* Reuse C to hold values of intersect and k. */
	C[ix].dgr = intersect;
	C[ix].cf[OUT] = pt[OUT];
	C[ix].cf[IN]  = pt[IN];
    }
d1186 1
a1186 1
    /* for each ray/cone pair */
d1188 2
a1189 2
    for(ix = 0; ix < n; ix++) {
	if (segp[ix].seg_stp == 0) continue; /* Skip */
d1191 8
a1198 8
	tgc = (struct tgc_specific *)stp[ix]->st_specific;
	intersect = C[ix].dgr;
	pt[OUT] = C[ix].cf[OUT];
	pt[IN]  = C[ix].cf[IN];
	/* segp[ix].seg_out.hit_normal holds pprime */
	VMOVE( pprime, segp[ix].seg_out.hit_normal );
	/* segp[ix].seg_in.hit_normal holds dprime */
	VMOVE( dprime, segp[ix].seg_in.hit_normal );
d1200 2
a1201 2
	if ( intersect == 2 ){
		/*  If two between-plane intersections exist, they are
d1204 10
a1213 10
		segp[ix].seg_in.hit_dist = pt[IN] * t_scale;
		segp[ix].seg_in.hit_surfno = TGC_NORM_BODY;	/* compute N */
		VJOIN1( segp[ix].seg_in.hit_vpriv, pprime, pt[IN], dprime );

		segp[ix].seg_out.hit_dist = pt[OUT] * t_scale;
		segp[ix].seg_out.hit_surfno = TGC_NORM_BODY;	/* compute N */
		VJOIN1( segp[ix].seg_out.hit_vpriv, pprime, pt[OUT], dprime );
	} else if ( intersect == 1 ) {
		int	nflag;
		/*
d1223 1
a1223 1
		if( dprime[Z] == 0.0 )  {
d1225 1
a1225 1
			rt_log("tgc: dprime[Z] = 0!\n" );
d1227 24
a1250 24
			RT_TGC_SEG_MISS(segp[ix]);
			continue;
		}
		b = ( -pprime[Z] )/dprime[Z];
		/*  Height vector is unitized (tgc->tgc_sH == 1.0) */
		t = ( 1.0 - pprime[Z] )/dprime[Z];

		VJOIN1( work, pprime, b, dprime );
		/* A and B vectors are unitized (tgc->tgc_A == _B == 1.0) */
		/* alf1 = ALPHA(work[X], work[Y], 1.0, 1.0 ) */
		alf1 = work[X]*work[X] + work[Y]*work[Y];

		VJOIN1( work, pprime, t, dprime );
		/* Must scale C and D vectors */
		alf2 = ALPHA(work[X], work[Y], tgc->tgc_AAdCC,tgc->tgc_BBdDD);

		if ( alf1 <= 1.0 ){
			pt[IN] = b;
			nflag = TGC_NORM_BOT; /* copy reverse normal */
		} else if ( alf2 <= 1.0 ){
			pt[IN] = t;
			nflag = TGC_NORM_TOP;	/* copy normal */
		} else {
			/* intersection apparently invalid  */
d1252 1
a1252 1
			rt_log("tgc(%s):  only 1 intersect\n", stp[ix]->st_name);
d1254 3
a1256 3
			RT_TGC_SEG_MISS(segp[ix]);
			continue;
		}
d1258 14
a1271 4
		/* pt[OUT] on skin, pt[IN] on end */
		if ( pt[OUT] >= pt[IN] )  {
			segp[ix].seg_in.hit_dist = pt[IN] * t_scale;
			segp[ix].seg_in.hit_surfno = nflag;
d1273 3
a1275 4
			segp[ix].seg_out.hit_dist = pt[OUT] * t_scale;
			segp[ix].seg_out.hit_surfno = TGC_NORM_BODY;	/* compute N */
			/* transform-space vector needed for normal */
			VJOIN1( segp[ix].seg_out.hit_vpriv, pprime, pt[OUT], dprime );
a1276 4
			segp[ix].seg_in.hit_dist = pt[OUT] * t_scale;
			/* transform-space vector needed for normal */
			segp[ix].seg_in.hit_surfno = TGC_NORM_BODY;	/* compute N */
			VJOIN1( segp[ix].seg_in.hit_vpriv, pprime, pt[OUT], dprime );
d1278 1
a1278 6
			segp[ix].seg_out.hit_dist = pt[IN] * t_scale;
			segp[ix].seg_out.hit_surfno = nflag;
		}
	} else {

	/*  If all conic interections lie outside the plane,
d1286 4
a1289 4
	if( dprime[Z] == 0.0 ) {
		RT_TGC_SEG_MISS(segp[ix]);
		continue;
	}
d1291 5
a1295 14
	dir = VDOT( tgc->tgc_N, rp[ix]->r_dir );	/* direc */
	if ( NEAR_ZERO( dir, RT_DOT_TOL ) ) {
		RT_TGC_SEG_MISS(segp[ix]);
		continue;
	}

	b = ( -pprime[Z] )/dprime[Z];
	/* Height vector is unitized (tgc->tgc_sH == 1.0) */
	t = ( 1.0 - pprime[Z] )/dprime[Z];

	VJOIN1( work, pprime, b, dprime );
	/* A and B vectors are unitized (tgc->tgc_A == _B == 1.0) */
	/* alpf = ALPHA(work[0], work[1], 1.0, 1.0 ) */
	alf1 = work[X]*work[X] + work[Y]*work[Y];
d1297 12
a1308 3
	VJOIN1( work, pprime, t, dprime );
	/* Must scale C and D vectors. */
	alf2 = ALPHA(work[X], work[Y], tgc->tgc_AAdCC,tgc->tgc_BBdDD);
d1310 1
a1310 1
	/*  It should not be possible for one planar intersection
d1314 4
a1317 4
	if ( alf1 > 1.0 || alf2 > 1.0 ) {
		RT_TGC_SEG_MISS(segp[ix]);
		continue;
	}
d1319 1
a1319 1
	/*  Use the dot product (found earlier) of the plane
d1323 9
a1331 3
	if ( dir > 0.0 ){
		segp[ix].seg_in.hit_dist = b * t_scale;
		segp[ix].seg_in.hit_surfno = TGC_NORM_BOT;	/* reverse normal */
d1333 6
a1338 12
		segp[ix].seg_out.hit_dist = t * t_scale;
		segp[ix].seg_out.hit_surfno = TGC_NORM_TOP;	/* normal */
	} else {
		segp[ix].seg_in.hit_dist = t * t_scale;
		segp[ix].seg_in.hit_surfno = TGC_NORM_TOP;	/* normal */

		segp[ix].seg_out.hit_dist = b * t_scale;
		segp[ix].seg_out.hit_surfno = TGC_NORM_BOT;	/* reverse normal */
	}
	}
    } /* end for each ray/cone pair */
    rt_free( (char *)C, "tor poly" );
d1424 1
a1424 1
		(struct tgc_specific *)stp->st_specific;
d1447 3
a1449 3
			     * Q * tgc->tgc_DdBm1
			   + (hitp->hit_vpriv[Y]*hitp->hit_vpriv[Y] - Q*Q)
			     * R * tgc->tgc_CdAm1;
d1451 1
a1451 1
/*XXX - save scale */
d1471 1
a1471 1
		(struct tgc_specific *)stp->st_specific;
d1518 1
a1518 1
		(struct tgc_specific *)stp->st_specific;
d1625 1
a1625 1
		(struct rt_tgc_internal *)ip->idb_ptr;
d1635 3
a1637 3
		tip->v[X] * mm2local,
		tip->v[Y] * mm2local,
		tip->v[Z] * mm2local );
d1642 4
a1645 4
		tip->h[X] * mm2local,
		tip->h[Y] * mm2local,
		tip->h[Z] * mm2local,
		Hmag * mm2local);
d1657 4
a1660 4
		tip->a[X] * mm2local,
		tip->a[Y] * mm2local,
		tip->a[Z] * mm2local,
		MAGNITUDE(tip->a) * mm2local);
d1664 4
a1667 4
		tip->b[X] * mm2local,
		tip->b[Y] * mm2local,
		tip->b[Z] * mm2local,
		MAGNITUDE(tip->b) * mm2local);
d1671 4
a1674 4
		tip->c[X] * mm2local,
		tip->c[Y] * mm2local,
		tip->c[Z] * mm2local,
		MAGNITUDE(tip->c) * mm2local);
d1678 4
a1681 4
		tip->d[X] * mm2local,
		tip->d[Y] * mm2local,
		tip->d[Z] * mm2local,
		MAGNITUDE(tip->d) * mm2local);
d1762 1
a1762 1
		(struct tgc_specific *)stp->st_specific;
d1792 4
a1795 4
	       + tgc->tgc_CdAm1*tgc->tgc_CdAm1 * hitp->hit_vpriv[Y]*hitp->hit_vpriv[Y]
	       - tgc->tgc_DdBm1*tgc->tgc_DdBm1 * R2
	       - tgc->tgc_CdAm1*tgc->tgc_CdAm1 * Q2
	       - 4.0*tgc->tgc_CdAm1*tgc->tgc_DdBm1 * R*Q;
d1805 1
a1805 1
		   (hitp->hit_vpriv[Y]*hitp->hit_vpriv[Y] - Q2) * R * tgc->tgc_CdAm1;
d2012 1
a2012 1
		
d2137 1
a2137 1
			else
d2140 1
a2140 1
			VCROSS( normal , pts[i][j].tan_axb , tan_h );
d2154 1
a2154 1
						continue;
d2212 443
@


10.11
log
@Fix to bug #247
Added rt_prefix and regularized names like polyRoots into rt_poly_roots.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 10.10 94/09/30 16:25:02 mike Exp Locker: mike $ (BRL)";
@


10.10
log
@Null out ip->idb_ptr after freeing memory in rt_*_ifree()
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 10.9 94/09/13 15:58:11 jra Exp Locker: mike $ (BRL)";
d605 1
a605 1
	/* (void) polyMul( &R, &R, &Rsqr ); */
d620 2
a621 2
		 *  (void) polyAdd( &Xsqr, &Ysqr, &sum );
		 *  (void) polySub( &sum, &Rsqr, &C );
d649 1
a649 1
		/* (void) polyMul( &Q, &Q, &Qsqr ); */
d656 5
a660 5
		 * (void) polyMul( &Qsqr, &Xsqr, &T1 );
		 * (void) polyMul( &Rsqr, &Ysqr, &T2 );
		 * (void) polyMul( &Rsqr, &Qsqr, &T3 );
		 * (void) polyAdd( &T1, &T2, &sum );
		 * (void) polySub( &sum, &T3, &C );
d683 1
a683 1
		nroots = polyRoots( &C , val );
d1016 1
a1016 1
	/* (void) polyMul( &R, &R, &Rsqr ); inline expands to: */
d1028 2
a1029 2
		/* (void) polyAdd( &Xsqr, &Ysqr, &sum ); and */
		/* (void) polySub( &sum, &Rsqr, &C ); inline expand to */
d1042 1
a1042 1
		/* (void) polyMul( &Q, &Q, &Qsqr ); inline expands to */
d1048 1
a1048 1
		/* (void) polyMul( &Qsqr, &Xsqr, &T1 ); inline expands to */
d1060 2
a1061 2
		/* (void) polyMul( &Rsqr, &Ysqr, &T2 ); and */
		/* (void) polyAdd( &T1, &T2, &sum ); inline expand to */
d1072 2
a1073 2
		/* (void) polyMul( &Rsqr, &Qsqr, &T3 ); and */
		/* (void) polySub( &sum, &T3, &C ); inline expand to */
d1111 1
a1111 1
		nroots = polyRoots( &C[ix] , val );
@


10.9
log
@removed vertexuse normals in tessalator for top and bottom faces.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 10.8 94/09/12 10:49:44 jra Exp Locker: jra $ (BRL)";
d1697 1
@


10.8
log
@Tesselator: moved nmg_fu_planeeqn before vertex normal assignment.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 10.7 94/09/10 23:05:22 jra Exp Locker: jra $ (BRL)";
d2144 5
d2164 1
a2164 1
	/* Normals for vertexuses in base and top faces are wrong, fix them here */
d2167 1
a2167 2
		struct loopuse		*lu;
		struct edgeuse		*eu;
d2170 2
a2172 2
		else
			fu = fu_base;
d2176 1
a2176 6
		NMG_GET_FU_NORMAL( normal , fu );
		VREVERSE( rev_norm , normal );
		lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
		NMG_CK_LOOPUSE( lu );

		for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d2178 1
a2178 1
			struct vertexuse *vu;
d2180 1
a2180 1
			NMG_CK_EDGEUSE( eu );
d2182 2
a2183 2
			vu = eu->vu_p;
			NMG_CK_VERTEXUSE( vu );
d2185 3
a2187 2
			/* OT_SAME vertexuse gets same normal as OT_SAME faceuse */
			nmg_vertexuse_nv( vu , normal );
d2189 5
a2193 5
			vu = eu->eumate_p->vu_p;
			NMG_CK_VERTEXUSE( vu );

			/* OT_OPPOSITE use gets reversed normal */
			nmg_vertexuse_nv( vu , rev_norm );
@


10.7
log
@New tessellator for TGC's.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 10.6 94/09/09 16:49:47 jra Exp Locker: jra $ (BRL)";
d1910 4
a1913 1
		alpha_tol = 2.0 * acos( 1.0 - 2.0 * min_radius * 0.1 / radius );
d1918 1
a1918 1
			abs = 2.0 * acos( 1.0 - ttol->abs/radius );
d1923 6
a1928 1
			rel = 2.0 * acos( 1.0 - ttol->rel * 2.0 * min_radius/radius );
d1936 1
a1936 1
			if( a>b )
d1941 1
a1941 1
			if( c>d )
d2099 14
a2157 13

	/* Associate face plane equations */
	for( i=0 ; i<NMG_TBL_END( &faces ) ; i++ )
	{
		fu = (struct faceuse *)NMG_TBL_GET( &faces , i );
		NMG_CK_FACEUSE( fu );

		if( nmg_fu_planeeqn( fu , tol ) )
		{
			rt_log( "rt_tess_tgc: failed to calculate plane equation\n" );
			return( -1 );
		}
	}
@


10.6
log
@Checkpoint (new tessellator).
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 10.5 94/08/10 18:39:32 gdurf Exp Locker: jra $ (BRL)";
d1825 1
a1825 1
 *  Preliminary tesselation of the TGC, same algorithm as vector list.
a1831 2
#if 0

d1834 1
a1834 2
	point_t pt;
	vect_t norm;
d1847 2
a1848 1
	struct faceuse		*fu;
d1856 1
d1859 1
d1862 3
d1867 1
d1907 1
a1907 1
	if( ttol.abs <= 0.0 && ttol.rel <= 0.0 && ttol.norm <= 0.0 )
d1910 1
a1910 1
		alpha_tol = 2.0 * acos( 0.8 ); /* 2.0 * acos( 1.0 - (2.0*radius*.1)/radius) */
d1914 2
a1915 2
		if( ttol.abs > 0.0 )
			abs = 2.0 * acos( 1.0 - ttol.abs/radius );
d1919 2
a1920 2
		if( ttol.rel > 0.0 )
			rel = 2.0 * acos( 1.0 - ttol.rel * 2.0 );
d1924 1
a1924 1
		if( ttol.norm > 0.0 )
d1929 1
a1929 1
				norm_bot = 2.0 * atan( tan( ttol.norm ) * (a/b) );
d1931 1
a1931 1
				norm_bot = 2.0 * atan( tan( ttol.norm ) * (b/a) );
d1934 1
a1934 1
				norm_top = 2.0 * atan( tan( ttol.norm ) * (c/d) );
d1936 1
a1936 1
				norm_top = 2.0 * atan( tan( ttol.norm ) * (d/c) );
d1988 12
d2022 1
a2022 1
	for( i=0 ; i<nsegs ; i++ )
d2025 2
a2026 2
	fu = nmg_cmface( s , (struct vertex ***)NMG_TBL_BASEADDR( &verts ), nsegs );
	nmg_tbl( &faces , TBL_INS , (long *)fu );
d2029 1
d2033 2
a2034 2
	fu = nmg_cmface( s , (struct vertex ***)NMG_TBL_BASEADDR( &verts ), nsegs );
	nmg_tbl( &faces , TBL_INS , (long *)fu );
d2036 3
d2040 1
a2040 1
	for i=0 ; i<nells-1 ; i++ )
d2069 1
d2074 3
a2076 1
			fastf_t alpha;
d2079 2
d2083 2
a2084 1
			VJOIN3( pts[i][j].pt , tip->v , h_factor , tip->h , cos( alpha ) , A[i] , sin( alpha ) , B[i] );
d2086 2
a2087 1
			/* normal at vertex */
a2089 1
}
d2091 4
a2094 1
#else
d2096 3
a2098 21
int
rt_tgc_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
CONST struct rt_tess_tol *ttol;
struct rt_tol		*tol;
{
	struct shell		*s;
	register int		i;
	LOCAL fastf_t		top[16*3];
	struct vertex		*vtop[16+1];
	LOCAL fastf_t		bottom[16*3];
	struct vertex		*vbottom[16+1];
	struct vertex		*vtemp[16+1];
	LOCAL vect_t		work;		/* Vec addition work area */
	LOCAL struct rt_tgc_internal	*tip;
	struct faceuse		*outfaceuses[2*16+2];
	struct vertex		*vertlist[4];
	vect_t			aXb;
	vect_t			cXd;
d2100 4
a2103 3
	RT_CK_DB_INTERNAL(ip);
	tip = (struct rt_tgc_internal *)ip->idb_ptr;
	RT_TGC_CK_MAGIC(tip);
d2105 5
a2109 10
	/* Create two 16 point ellipses
	 *  Note that in both cases the points need to go
	 *  counterclockwise (CCW) around the H vector.
	 */
	VCROSS( aXb, tip->a, tip->b );
	VCROSS( cXd, tip->c, tip->d );
	if( VDOT( tip->h, aXb ) < 0 )
		VREVERSE(tip->a, tip->a );
	if( VDOT( tip->h, cXd ) < 0 )
		VREVERSE(tip->c, tip->c );
d2111 3
a2113 3
	VADD2( work, tip->v, tip->h );
	rt_ell_16pts( bottom, tip->v, tip->a, tip->b );
	rt_ell_16pts( top, work, tip->c, tip->d );
d2115 3
a2117 2
	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d2119 9
a2127 2
	for( i=0; i<16; i++ )  {
		vtop[i] = vtemp[i] = (struct vertex *)0;
d2130 6
a2135 2
	/* Top face topology.  Verts are considered to go CCW */
	outfaceuses[0] = nmg_cface(s, vtop, 16);
d2137 5
a2141 3
	/* Bottom face topology.  Verts must go in opposite dir (CW) */
	outfaceuses[1] = nmg_cface(s, vtemp, 16);
	for( i=0; i<16; i++ )  vbottom[i] = vtemp[16-1-i];
d2143 6
a2148 3
	/* Duplicate [0] as [16] to handle loop end condition, below */
	vtop[16] = vtop[0];
	vbottom[16] = vbottom[0];
d2150 5
a2154 9
	/* Build topology for all the triangular side faces (2*16 of them)
	 * hanging down from the top face to the bottom face.
	 * increasing indices go towards counter-clockwise (CCW).
	 */
	for( i=0; i<16; i++ )  {
		vertlist[0] = vtop[i];		/* from top, */
		vertlist[1] = vbottom[i];	/* straight down, */
		vertlist[2] = vbottom[i+1];	/* to left & back to top */
		outfaceuses[2+2*i] = nmg_cface(s, vertlist, 3);
d2156 4
a2159 5
		vertlist[0] = vtop[i];		/* from top, */
		vertlist[1] = vbottom[i+1];	/* down to left, */
		vertlist[2] = vtop[i+1];	/* straight up & to right */
		outfaceuses[2+2*i+1] = nmg_cface(s, vertlist, 3);
	}
d2161 1
a2161 4
	for( i=0; i<16; i++ )  {
		NMG_CK_VERTEX(vtop[i]);
		NMG_CK_VERTEX(vbottom[i]);
	}
d2163 4
a2166 7
	/* Associate the vertex geometry, CCW */
	for( i=0; i<16; i++ )  {
		nmg_vertex_gv( vtop[i], &top[3*(i)] );
	}
	for( i=0; i<16; i++ )  {
		nmg_vertex_gv( vbottom[i], &bottom[3*(i)] );
	}
d2168 18
a2185 4
	/* Associate the face geometry */
	for (i=0 ; i < 2*16+2 ; ++i) {
		if( nmg_fu_planeeqn( outfaceuses[i], tol ) < 0 )
			return -1;		/* FAIL */
d2188 1
a2188 2
	/* Glue the edges of different outward pointing face uses together */
	nmg_gluefaces( outfaceuses, 2*16+2 );
d2190 3
a2192 2
	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );
d2194 1
a2194 4
	/* XXX just for testing, to make up for loads of triangles ... */
	nmg_shell_coplanar_face_merge( s, tol, 1 );

	return(0);
a2195 1
#endif
@


10.5
log
@Added include of conf.h
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 10.4 1994/05/06 03:34:26 mike Exp gdurf $ (BRL)";
d1831 11
d1850 225
d2172 1
@


10.4
log
@Improved divide by zero checking.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 10.3 94/04/21 07:15:58 mike Exp Locker: mike $ (BRL)";
d31 2
@


10.3
log
@Fix the problem with the tessellator where Test18.r has
inside-out cylinders!
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 10.2 93/11/18 01:44:11 mike Exp Locker: mike $ (BRL)";
d390 3
a392 3
vect_t	vect;
int	axis;
mat_t	Shr, Trn, Inv;
d398 3
d500 1
a500 1
	register struct tgc_specific	*tgc =
d527 7
a533 1
	t_scale = 1/MAGNITUDE( dprime );
d783 1
a783 1
		if( dprime[Z] == 0.0 )  {
d832 1
d845 1
a845 1
	if( dprime[Z] == 0.0 )
@


10.2
log
@Added tol arg to bounding box routines
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 10.1 91/10/12 06:40:24 mike Rel4_0 $ (BRL)";
d1838 2
d1846 2
a1847 1
	 *  Note that in both cases the points go counterclockwise (CCW).
d1849 8
a1857 1
	VADD2( work, tip->v, tip->h );
@


10.1
log
@Release_4.0
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.39 91/09/20 23:29:03 butler Exp $ (BRL)";
d1907 1
a1907 1
	nmg_region_a( *r );
@


9.39
log
@removing fuzz with lint
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.38 91/07/11 15:36:19 jehunt Exp $ (BRL)";
@


9.38
log
@Added unit conversion to the magnitude values for the H,A,B,C,D vectors
in rt_tgc_describe()
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.37 91/06/30 00:10:59 mike Exp $ (BRL)";
d92 1
a92 1
	LOCAL fastf_t	magsq_h, magsq_a, magsq_b, magsq_c, magsq_d;
d112 1
a112 1
	mag_h = sqrt( magsq_h = MAGSQ( tip->h ) );
a514 1
	LOCAL poly		sum;
a628 1
		LOCAL poly	T1, T2, T3;
a1701 1
	LOCAL fastf_t		points[3*8];
a1834 1
	LOCAL fastf_t		points[3*8];
a1837 3
	struct edgeuse		*eu, *eu2;
	int			face;
	plane_t			plane;
@


9.37
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.36 91/06/22 22:30:40 mike Exp $ (BRL)";
d1629 1
a1629 1
		Hmag );
d1644 1
a1644 1
		MAGNITUDE(tip->a) );
d1651 1
a1651 1
		MAGNITUDE(tip->b) );
d1658 1
a1658 1
		MAGNITUDE(tip->c) );
d1665 1
a1665 1
		MAGNITUDE(tip->d) );
@


9.36
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.35 91/06/12 20:57:46 mike Exp $ (BRL)";
d434 1
a434 1
register struct soltab	*stp;
d436 1
a436 1
	register struct tgc_specific	*tgc =
d1522 3
a1524 3
struct rt_db_internal	*ip;
struct rt_external	*ep;
register mat_t		mat;
d1563 3
a1565 3
struct rt_external	*ep;
struct rt_db_internal	*ip;
double			local2mm;
@


9.35
log
@nmg.h must come before raytrace.h
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.34 91/05/18 03:01:34 mike Exp $ (BRL)";
d45 1
a45 1
	struct rt_i *rtip, CONST struct rt_tol *tol));
d83 1
a83 1
rt_tgc_prep( stp, ip, rtip, tol )
a86 1
CONST struct rt_tol	*tol;
d108 1
a108 1
	if( rt_rec_prep( stp, ip, rtip, tol ) == 0 )
d491 1
a491 1
rt_tgc_shot( stp, rp, ap, seghead, tol )
a495 1
CONST struct rt_tol	*tol;
d896 1
a896 1
rt_tgc_vshot( stp, rp, segp, n, resp, tol )
d901 1
a901 2
struct resource         *resp; /* pointer to a list of free segs */
CONST struct rt_tol	*tol;
@


9.34
log
@Converted to new tolerance interface
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.33 91/04/01 19:59:40 mike Exp $ (BRL)";
d37 1
a38 1
#include "nmg.h"
d1918 3
@


9.33
log
@Edges of loops now travel in a counter-clockwise (CCW) direction
around the face normal.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.32 91/03/13 16:43:15 mike Exp $ (BRL)";
d45 1
a45 1
	struct rt_i *rtip));
d83 1
a83 1
rt_tgc_prep( stp, ip, rtip )
d87 1
d109 1
a109 1
	if( rt_rec_prep( stp, ip, rtip ) == 0 )
d492 1
a492 1
rt_tgc_shot( stp, rp, ap, seghead )
d497 1
d898 1
a898 1
rt_tgc_vshot( stp, rp, segp, n, resp )
d904 1
d1696 1
a1696 1
rt_tgc_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
d1699 2
a1700 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
d1826 1
a1826 1
rt_tgc_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d1830 2
a1831 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
d1909 1
a1909 1
		if( nmg_fu_planeeqn( outfaceuses[i] ) < 0 )
@


9.32
log
@Expanded many polynomial calls inline, to save subroutine call overhead.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.31 91/03/13 16:18:19 mike Exp $ (BRL)";
d1853 1
a1853 1
	 *  Note that in both cases the points go counterclockwise.
d1866 1
a1866 1
	/* Top face topology.  Verts are considered to go clockwise */
d1869 1
a1869 1
	/* Bottom face topology.  Verts must go in opposite dir (ccw) */
d1879 1
a1879 1
	 * increasing indices go towards clockwise.
d1898 1
a1898 1
	/* Associate the vertex geometry */
d1900 1
a1900 1
		nmg_vertex_gv( vtop[i], &top[3*(16-1-i)] );
d1903 1
a1903 1
		nmg_vertex_gv( vbottom[i], &bottom[3*(16-1-i)] );
d1908 2
a1909 1
		rt_mk_nmg_planeeqn( outfaceuses[i] );
@


9.31
log
@Modified to handle some near-to-zero cases, although
testing has indicated that this is no longer necessary,
owing to concurrently developed improvements in the root finder.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.30 91/03/11 23:09:14 mike Exp $ (BRL)";
a593 1
	(void) polyMul( &R, &R, &Rsqr );
d595 6
d609 8
a616 2
		(void) polyAdd( &Xsqr, &Ysqr, &sum );
		(void) polySub( &sum, &Rsqr, &C );
d622 1
d624 2
a625 2
			k[0] = (roots - C.cf[1]) * 0.5 / C.cf[0];
			k[1] = (roots + C.cf[1]) * (-0.5) / C.cf[0];
a638 1
		(void) polyMul( &Q, &Q, &Qsqr );
d640 5
a644 5
		(void) polyMul( &Qsqr, &Xsqr, &T1 );
		(void) polyMul( &Rsqr, &Ysqr, &T2 );
		(void) polyMul( &Rsqr, &Qsqr, &T3 );
		(void) polyAdd( &T1, &T2, &sum );
		(void) polySub( &sum, &T3, &C );
d646 27
d1009 1
a1009 2
                Rsqr.cf[1] = R.cf[0] * R.cf[1] +
                                 R.cf[1] * R.cf[0];
d1035 1
a1035 2
			Qsqr.cf[1] = Q.cf[0] * Q.cf[1] +
					 Q.cf[1] * Q.cf[0];
@


9.30
log
@Brought rt_pt_sort inline
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.29 91/02/07 20:32:24 mike Exp $ (BRL)";
d528 1
a528 1
	if( NEAR_ZERO( dprime[Z], RT_PCOEF_TOL ) )
d530 1
d539 2
a540 3
	cor_proj = VDOT( pprime, dprime );
	VSCALE( cor_pprime, dprime, cor_proj );
	VSUB2( cor_pprime, pprime, cor_pprime );
d543 16
d645 1
a645 1
			if ( NEAR_ZERO( val[l].im, 0.0001 ) )
d651 1
a651 1
			rt_pr_roots( nroots, val );
d658 3
a660 2
	for( i = 0; i < npts; ++i )
		k[i] -= cor_proj;
d703 1
a703 1
			}  else
d705 1
d1080 1
a1080 1
			rt_pr_roots( nroots, val );
@


9.29
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.28 91/01/28 23:53:20 mike Exp $ (BRL)";
d651 4
a654 2
	/* Most distant to least distant	*/
	rt_pt_sort( k, npts );
d656 10
@


9.28
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.27 91/01/26 03:15:00 mike Exp $ (BRL)";
d1794 1
a1794 1
	s = NMG_LIST_FIRST(shell, &(*r)->s_hd);
@


9.27
log
@Eliminated mat parameter on ft_plot and ft_tess
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.26 91/01/26 02:01:35 mike Exp $ (BRL)";
d1628 1
a1628 1
struct vlhead		*vhead;
d1650 1
a1650 1
	ADD_VL( vhead, &top[15*ELEMENTS_PER_VECT], 0 );
d1652 1
a1652 1
		ADD_VL( vhead, &top[i*ELEMENTS_PER_VECT], 1 );
d1656 1
a1656 1
	ADD_VL( vhead, &bottom[15*ELEMENTS_PER_VECT], 0 );
d1658 1
a1658 1
		ADD_VL( vhead, &bottom[i*ELEMENTS_PER_VECT], 1 );
d1663 2
a1664 2
		ADD_VL( vhead, &top[i*ELEMENTS_PER_VECT], 0 );
		ADD_VL( vhead, &bottom[i*ELEMENTS_PER_VECT], 1 );
@


9.26
log
@Fixed incomplete change of macro name
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.25 91/01/25 21:52:15 mike Exp $ (BRL)";
d1627 6
a1632 7
rt_tgc_plot( vhead, mat, ip, abs_tol, rel_tol, norm_tol )
struct vlhead	*vhead;
mat_t		mat;
struct rt_db_internal *ip;
double		abs_tol;
double		rel_tol;
double		norm_tol;
d1758 1
a1758 1
rt_tgc_tess( r, m, ip, mat, abs_tol, rel_tol, norm_tol )
d1762 3
a1764 4
register mat_t		mat;
double		abs_tol;
double		rel_tol;
double		norm_tol;
@


9.25
log
@lint
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.24 91/01/25 21:19:19 mike Exp $ (BRL)";
d1145 1
a1145 1
			SEG_MISS(segp[ix]);
d1172 1
a1172 1
			SEG_MISS(segp[ix]);
d1205 1
a1205 1
		SEG_MISS(segp[ix]);
d1211 1
a1211 1
		SEG_MISS(segp[ix]);
d1233 1
a1233 1
		SEG_MISS(segp[ix]);
@


9.24
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.23 91/01/25 20:36:11 mike Exp $ (BRL)";
d44 2
a45 1
extern int	rt_rec_prep();
d820 1
a821 1
#define SEG_MISS(SEG)           (SEG).seg_stp=(struct soltab *) 0;
d1063 1
a1063 1
		SEG_MISS(segp[ix]);			/* No hit	*/
@


9.23
log
@Added rt_ prefix to _internal structure
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.22 91/01/15 23:44:14 mike Exp $ (BRL)";
a80 1
#if NEW_IF
a86 10
#else
int
rt_tgc_prep( stp, rec, rtip )
struct soltab		*stp;
union record		*rec;
struct rt_i		*rtip;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a98 12
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rec;
	ep->ext_nbytes = stp->st_dp->d_len*sizeof(union record);
	ip = &intern;
	if( rt_tgc_import( ip, ep, stp->st_pathmat ) < 0 )
		return(-1);		/* BAD */
	RT_CK_DB_INTERNAL( ip );
#endif
a1624 1
#if NEW_IF
a1633 11
#else
int
rt_tgc_plot( rp, mat, vhead, dp )
union record	*rp;
register mat_t	mat;
struct vlhead	*vhead;
struct directory *dp;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a1640 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_tgc_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_tgc_plot(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
a1756 1
#if NEW_IF
a1766 12
#else
int
rt_tgc_tess( r, m, rp, mat, dp )
struct nmgregion	**r;
struct model		*m;
union record	*rp;
register mat_t	mat;
struct directory *dp;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a1782 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_tgc_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_tgc_tess(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
@


9.22
log
@Changed name to rt_ell_16pts
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.21 91/01/15 21:02:34 mike Exp $ (BRL)";
d98 1
a98 1
	struct tgc_internal	*tip;
d122 1
a122 1
	tip = (struct tgc_internal *)ip->idb_ptr;
d1482 1
a1482 1
	struct tgc_internal	*tip;
d1496 2
a1497 2
	ip->idb_ptr = rt_malloc( sizeof(struct tgc_internal), "tgc_internal");
	tip = (struct tgc_internal *)ip->idb_ptr;
d1523 1
a1523 1
	struct tgc_internal	*tip;
d1528 1
a1528 1
	tip = (struct tgc_internal *)ip->idb_ptr;
d1564 2
a1565 2
	register struct tgc_internal	*tip =
		(struct tgc_internal *)ip->idb_ptr;
d1669 1
a1669 1
	LOCAL struct tgc_internal	*tip;
d1691 1
a1691 1
	tip = (struct tgc_internal *)ip->idb_ptr;
d1838 1
a1838 1
	LOCAL struct tgc_internal	*tip;
d1860 1
a1860 1
	tip = (struct tgc_internal *)ip->idb_ptr;
@


9.21
log
@Moved internal structure to rtgeom.h,
made interface to g_rec always the new way.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.20 91/01/15 01:34:03 mike Exp $ (BRL)";
d1694 1
a1694 1
	ell_16pts( bottom, tip->v, tip->a, tip->b );
d1696 1
a1696 1
	ell_16pts( top, work, tip->c, tip->d );
d1866 1
a1866 1
	ell_16pts( bottom, tip->v, tip->a, tip->b );
d1868 1
a1868 1
	ell_16pts( top, work, tip->c, tip->d );
@


9.20
log
@Fixed magic
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.19 91/01/14 23:47:37 mike Exp $ (BRL)";
d39 1
a66 12
struct tgc_internal {
	long	magic;
	vect_t	v;
	vect_t	h;
	vect_t	a;
	vect_t	b;
	vect_t	c;
	vect_t	d;
};
#define RT_TGC_INTERNAL_MAGIC	0xaabbdd87
#define RT_TGC_CK_MAGIC(_p)	RT_CKMAG(_p,RT_TGC_INTERNAL_MAGIC,"tgc_internal")

a69 1

a109 5
	/*
	 *  For a fast way out, hand this solid off to the REC routine.
	 *  If it takes it, then there is nothing to do, otherwise
	 *  the solid is a TGC.
	 */
a110 8
	if( rt_rec_prep( stp, ep, rtip ) == 0 )
		return(0);		/* OK */
#else
	if( rt_rec_prep( stp, rec, rtip ) == 0 )
		return(0);		/* OK */
#endif

#if NEW_IF
d124 8
@


9.19
log
@Added magic numbers, export routine
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.18 91/01/14 23:27:58 mike Exp $ (BRL)";
d1515 1
a1515 1
	RT_TGC_CK_MAGIC(tip);
@


9.18
log
@Added local units conversion
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.17 91/01/11 07:12:11 mike Exp $ (BRL)";
d67 1
d75 2
d148 1
d1515 1
d1540 25
a1564 1
	return(-1);
d1588 1
d1650 2
a1652 1
 *  XXX The suffix of this name is temporary.
d1709 1
d1878 1
@


9.17
log
@Changed to have new style import/export routines, and ft_describe
routine.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.16 90/12/07 00:43:57 mike Exp $ (BRL)";
d1530 1
a1530 1
rt_tgc_export( ep, ip )
d1533 1
d1546 1
a1546 1
rt_tgc_describe( str, ip, verbose )
d1550 1
d1561 4
a1564 1
	sprintf(buf, "\tV (%g, %g, %g)\n", V3ARGS(tip->v) );
d1569 4
a1572 1
		V3ARGS(tip->h), Hmag );
d1584 4
a1587 1
		V3ARGS(tip->a), MAGNITUDE(tip->a) );
d1591 4
a1594 1
		V3ARGS(tip->b), MAGNITUDE(tip->b) );
d1598 4
a1601 1
		V3ARGS(tip->c), MAGNITUDE(tip->c) );
d1605 4
a1608 1
		V3ARGS(tip->d), MAGNITUDE(tip->d) );
a1828 1

@


9.16
log
@lint
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.15 90/11/01 06:55:40 mike Exp $ (BRL)";
d90 1
d92 7
d104 4
a117 1
	LOCAL struct tgc_internal	ti;
d124 4
d130 1
d132 9
a140 1
	if( rt_tgc_import( &ti, rec, stp->st_pathmat ) < 0 )
d142 3
d147 5
a151 5
	mag_h = sqrt( magsq_h = MAGSQ( ti.h ) );
	mag_a = sqrt( magsq_a = MAGSQ( ti.a ) );
	mag_b = sqrt( magsq_b = MAGSQ( ti.b ) );
	mag_c = sqrt( magsq_c = MAGSQ( ti.c ) );
	mag_d = sqrt( magsq_d = MAGSQ( ti.d ) );
d182 2
a183 2
		VADD2( ti.v, ti.v, ti.h );
		VREVERSE( ti.h, ti.h );
d185 2
a186 2
		VEXCHANGE( ti.a, ti.c, work );
		VEXCHANGE( ti.b, ti.d, work );
d191 2
a192 2
	VCROSS( work, ti.a, ti.b );
	f = VDOT( ti.h, work ) / ( prod_ab*mag_h );
d200 1
a200 1
		f = VDOT( ti.a, ti.b ) / prod_ab;
d205 1
a205 1
				VDOT( ti.a, ti.b ),  prod_ab );
d211 1
a211 1
		f = VDOT( ti.c, ti.d ) / prod_cd;
d216 1
a216 1
				VDOT( ti.c, ti.d ), prod_cd );
d223 1
a223 1
		f = 1.0 - VDOT( ti.a, ti.c ) / (mag_a * mag_c);
d233 1
a233 1
		f = 1.0 - VDOT( ti.b, ti.d ) / (mag_b * mag_d);
d245 1
a245 1
	VMOVE( tgc->tgc_V, ti.v );
d267 2
a268 2
	rt_tgc_rotate( ti.a, ti.b, ti.h, Rot, iRot, tgc );
	MAT4X3VEC( nH, Rot, ti.h );
d302 2
a303 2
		VADD2( temp, tgc->tgc_V, ti.a );
		VADD2( work, temp, ti.b );
d306 1
a306 1
		VSUB2( work, temp, ti.b );
d309 2
a310 2
		VSUB2( temp, tgc->tgc_V, ti.a );
		VADD2( work, temp, ti.b );
d312 1
a312 1
		VSUB2( work, temp, ti.b );
d315 2
a316 2
		VADD3( temp, tgc->tgc_V, ti.h, ti.c );
		VADD2( work, temp, ti.d );
d318 1
a318 1
		VSUB2( work, temp, ti.d );
d321 3
a323 3
		VADD2( temp, tgc->tgc_V, ti.h );
		VSUB2( temp, temp, ti.c );
		VADD2( work, temp, ti.d );
d325 1
a325 1
		VSUB2( work, temp, ti.d );
d1490 3
a1492 3
rt_tgc_import( tip, rp, mat )
struct tgc_internal	*tip;
union record		*rp;
d1495 2
d1499 2
d1507 5
d1527 85
d1614 1
d1616 10
d1632 4
a1640 1
	LOCAL struct tgc_internal	ti;
d1642 16
a1657 1
	if( rt_tgc_import( &ti, rp, mat ) < 0 )  return(-1);
d1659 3
a1661 3
	ell_16pts( bottom, ti.v, ti.a, ti.b );
	VADD2( work, ti.v, ti.h );
	ell_16pts( top, work, ti.c, ti.d );
d1771 1
d1773 11
d1791 3
d1803 1
a1803 1
	LOCAL struct tgc_internal	ti;
d1810 12
a1821 3
	if( rt_tgc_import( &ti, rp, mat ) < 0 )  {
		rt_log("rt_tgc_tess(%s): import failure\n", dp->d_namep);
		return(-1);
d1823 4
d1831 3
a1833 3
	ell_16pts( bottom, ti.v, ti.a, ti.b );
	VADD2( work, ti.v, ti.h );
	ell_16pts( top, work, ti.c, ti.d );
@


9.15
log
@Fixed oversight in case statement
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.14 90/10/15 12:01:04 mike Exp $ (BRL)";
d513 2
a514 1
	LOCAL fastf_t		t_scale, alf1, alf2;
d518 1
a518 1
	LOCAL fastf_t		cor_proj;	/* corrected projected dist */
d850 2
a851 1
	LOCAL fastf_t		t_scale, alf1, alf2;
d855 1
a855 1
	LOCAL fastf_t		cor_proj;	/* corrected projected dist */
@


9.14
log
@Changed from using hit_private to hit_surfno for surface indicator
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.13 90/10/06 02:05:24 mike Exp $ (BRL)";
d1358 1
a1358 1
	case 1:	/* TGC_NORM_TOP */
d1361 1
a1361 1
	case 2:	/* TGC_NORM_BOT */
d1364 1
a1364 1
	case 0:	/* TGC_NORM_BODY */
d1407 1
a1407 1
	case 0:	/* TGC_NORM_BODY */
d1412 1
a1412 1
	case 1:	/* TGC_NORM_TOP */
d1418 1
a1418 1
	case 2:	/* TGC_NORM_BOT */
@


9.13
log
@Converted seg structures to use doubly linked lists.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /m/cad/librt/RCS/g_tgc.c,v 9.12 90/05/18 07:25:43 butler Exp $ (BRL)";
d469 4
a472 4
/* To be clean, hit_private (a genptr_t), is set to one of these */
#define	TGC_NORM_BODY	((genptr_t)0)
#define	TGC_NORM_TOP	((genptr_t)1)	/* copy tgc_N */
#define	TGC_NORM_BOT	((genptr_t)2)	/* copy reverse tgc_N */
d693 1
a693 1
		segp->seg_in.hit_private = TGC_NORM_BODY;	/* compute N */
d697 1
a697 1
		segp->seg_out.hit_private = TGC_NORM_BODY;	/* compute N */
d704 1
a704 1
		genptr_t	nflag;
d749 1
a749 1
			segp->seg_in.hit_private = nflag;
d752 1
a752 1
			segp->seg_out.hit_private = TGC_NORM_BODY;	/* compute N */
d758 1
a758 1
			segp->seg_in.hit_private = TGC_NORM_BODY;	/* compute N */
d762 1
a762 1
			segp->seg_out.hit_private = nflag;
d812 1
a812 1
		segp->seg_in.hit_private = TGC_NORM_BOT;	/* reverse normal */
d815 1
a815 1
		segp->seg_out.hit_private = TGC_NORM_TOP;	/* normal */
d818 1
a818 1
		segp->seg_in.hit_private = TGC_NORM_TOP;	/* normal */
d821 1
a821 1
		segp->seg_out.hit_private = TGC_NORM_BOT;	/* reverse normal */
d1129 1
a1129 1
		segp[ix].seg_in.hit_private = TGC_NORM_BODY;	/* compute N */
d1133 1
a1133 1
		segp[ix].seg_out.hit_private = TGC_NORM_BODY;	/* compute N */
d1136 1
a1136 1
		genptr_t	nflag;
d1185 1
a1185 1
			segp[ix].seg_in.hit_private = nflag;
d1188 1
a1188 1
			segp[ix].seg_out.hit_private = TGC_NORM_BODY;	/* compute N */
d1194 1
a1194 1
			segp[ix].seg_in.hit_private = TGC_NORM_BODY;	/* compute N */
d1198 1
a1198 1
			segp[ix].seg_out.hit_private = nflag;
d1249 1
a1249 1
		segp[ix].seg_in.hit_private = TGC_NORM_BOT;	/* reverse normal */
d1252 1
a1252 1
		segp[ix].seg_out.hit_private = TGC_NORM_TOP;	/* normal */
d1255 1
a1255 1
		segp[ix].seg_in.hit_private = TGC_NORM_TOP;	/* normal */
d1258 1
a1258 1
		segp[ix].seg_out.hit_private = TGC_NORM_BOT;	/* reverse normal */
d1357 1
a1357 1
	switch( (int)(hitp->hit_private) )  {
d1379 1
a1379 1
		rt_log("rt_tgc_norm: bad flag x%x\n", (int)hitp->hit_private);
d1406 1
a1406 1
	switch( (int)(hitp->hit_private) )  {
d1550 1
a1550 1
	if( hitp->hit_private != TGC_NORM_BODY ) {
@


9.12
log
@Halfway converted to new double-linked-list structures ;-)
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: g_tgc.c,v 9.11 90/05/04 08:12:56 mike Exp $ (BRL)";
d498 2
a499 2
struct seg *
rt_tgc_shot( stp, rp, ap )
d503 1
d655 1
a655 1
		return( SEG_NULL );			/* No hit	*/
d689 1
a689 1
		GET_SEG( segp, ap->a_resource );
d700 2
a701 1
		return( segp );
d717 1
a717 1
			return(SEG_NULL);
d741 1
a741 1
			return( SEG_NULL );
d744 1
a744 1
		GET_SEG( segp, ap->a_resource );
d764 2
a765 1
		return( segp );
d777 1
a777 1
		return(SEG_NULL);
d781 1
a781 1
		return( SEG_NULL );
d801 1
a801 1
		return( SEG_NULL );
d803 1
a803 1
	GET_SEG( segp, ap->a_resource );
d823 2
a824 1
	return( segp );
@


9.11
log
@Routines all got rt_ prefixes
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: g_tgc.c,v 9.10 90/04/28 02:08:55 mike Locked $ (BRL)";
d1652 1
a1652 1
	s = m->r_p->s_p;
@


9.10
log
@removed calls to nmg_ck_closed_surf from geometry module tesselators
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: g_tgc.c,v 9.9 90/03/15 01:58:42 butler Locked $ (BRL)";
d43 1
a43 1
extern int	rec_prep();
d45 2
a46 2
static void	tgc_rotate(), tgc_shear();
static void	tgc_scale();
d80 1
a80 1
 *			T G C _ P R E P
d91 1
a91 1
tgc_prep( stp, rec, rtip )
d113 1
a113 1
	if( rec_prep( stp, rec, rtip ) == 0 )
d116 1
a116 1
	if( tgc_import( &ti, rec, stp->st_pathmat ) < 0 )
d157 3
a159 3
#define VXCH( a, b, tmp )	{ VMOVE(tmp,a); VMOVE(a,b); VMOVE(b,tmp); }
		VXCH( ti.a, ti.c, work );
		VXCH( ti.b, ti.d, work );
d240 1
a240 1
	tgc_rotate( ti.a, ti.b, ti.h, Rot, iRot, tgc );
d259 2
a260 2
	tgc_shear( nH, Z, Shr, tShr, iShr );
	tgc_scale( tgc->tgc_A, tgc->tgc_B, tgc->tgc_sH, Scl, iScl );
d320 1
a320 1
 *		>>>  r o t a t e ( )  <<<
d340 1
a340 1
tgc_rotate( A, B, Hv, Rot, Inv, tgc )
d384 1
a384 1
 *		>>>  s h e a r ( )  <<<
d397 1
a397 1
tgc_shear( vect, axis, Shr, Trn, Inv )
d418 2
a419 1
/*	s c a l e ( )
d422 1
a422 1
tgc_scale( a, b, h, Scl, Inv )
d438 1
a438 1
 *  			T G C _ P R I N T
d441 1
a441 1
tgc_print( stp )
d469 4
a472 2
/* To be clean, hit_private (a char *), is set to one of these */
static char tgc_compute[4];
d475 1
a475 1
 *			T G C _ S H O T
d478 1
a478 1
 *  terms have been computed by tgc_prep().
d499 1
a499 1
tgc_shot( stp, rp, ap )
d692 1
a692 1
		segp->seg_in.hit_private = &tgc_compute[0];	/* compute N */
d696 1
a696 1
		segp->seg_out.hit_private = &tgc_compute[0];	/* compute N */
d702 1
a702 1
		char *nflag;	/* tgc_compute[1] = normal, [2] = reverse normal */
d732 1
a732 1
			nflag = &tgc_compute[2]; /* copy reverse normal */
d735 1
a735 1
			nflag = &tgc_compute[1];	/* copy normal */
d750 1
a750 1
			segp->seg_out.hit_private = &tgc_compute[0];	/* compute N */
d756 1
a756 1
			segp->seg_in.hit_private = &tgc_compute[0];	/* compute N */
d809 1
a809 1
		segp->seg_in.hit_private = &tgc_compute[2];	/* reverse normal */
d812 1
a812 1
		segp->seg_out.hit_private = &tgc_compute[1];	/* normal */
d815 1
a815 1
		segp->seg_in.hit_private = &tgc_compute[1];	/* normal */
d818 1
a818 1
		segp->seg_out.hit_private = &tgc_compute[2];	/* reverse normal */
d826 1
a826 1
 *			T G C _ V S H O T
d831 1
a831 1
tgc_vshot( stp, rp, segp, n, resp )
d1125 1
a1125 1
		segp[ix].seg_in.hit_private = &tgc_compute[0];	/* compute N */
d1129 1
a1129 1
		segp[ix].seg_out.hit_private = &tgc_compute[0];	/* compute N */
d1132 1
a1132 1
		char *nflag;	/* tgc_compute[1] = normal, [2] = reverse normal */
d1165 1
a1165 1
			nflag = &tgc_compute[2]; /* copy reverse normal */
d1168 1
a1168 1
			nflag = &tgc_compute[1];	/* copy normal */
d1184 1
a1184 1
			segp[ix].seg_out.hit_private = &tgc_compute[0];	/* compute N */
d1190 1
a1190 1
			segp[ix].seg_in.hit_private = &tgc_compute[0];	/* compute N */
d1245 1
a1245 1
		segp[ix].seg_in.hit_private = &tgc_compute[2];	/* reverse normal */
d1248 1
a1248 1
		segp[ix].seg_out.hit_private = &tgc_compute[1];	/* normal */
d1251 1
a1251 1
		segp[ix].seg_in.hit_private = &tgc_compute[1];	/* normal */
d1254 1
a1254 1
		segp[ix].seg_out.hit_private = &tgc_compute[2];	/* reverse normal */
d1287 1
a1287 1
 *			T G C _ N O R M
d1338 1
a1338 1
tgc_norm( hitp, stp, rp )
d1353 2
a1354 2
	switch( hitp->hit_private-tgc_compute )  {
	case 1:
d1357 1
a1357 1
	case 2:
d1360 1
a1360 1
	case 0:
d1375 1
a1375 1
		rt_log("tgc_norm: bad flag x%x\n", (int)hitp->hit_private);
d1380 3
d1384 1
a1384 1
tgc_uv( ap, stp, hitp, uvp )
d1390 36
a1425 2
	/* Do nothing.  Really, should do what REC does. */
	uvp->uv_u = uvp->uv_v = 0;
d1431 1
a1431 1
 *			T G C _ F R E E
d1434 1
a1434 1
tgc_free( stp )
d1444 1
a1444 1
tgc_class()
d1451 1
a1451 1
 *			T G C _ I M P O R T
d1457 1
a1457 1
tgc_import( tip, rp, mat )
d1466 1
a1466 1
		rt_log("tgc_import: defective record\n");
d1485 1
a1485 1
 *			T G C _ P L O T
d1488 1
a1488 1
tgc_plot( rp, mat, vhead, dp )
d1501 1
a1501 1
	if( tgc_import( &ti, rp, mat ) < 0 )  return(-1);
d1528 1
a1528 1
 *			T G C _ C U R V E
d1533 1
a1533 1
tgc_curve( cvp, hitp, stp )
d1546 1
a1546 1
	if( hitp->hit_private > tgc_compute ) {
d1607 1
a1607 1
 *			T G C _ T E S S
d1616 1
a1616 1
tgc_tess( r, m, rp, mat, dp )
d1639 2
a1640 2
	if( tgc_import( &ti, rp, mat ) < 0 )  {
		rt_log("tgc_tess(%s): import failure\n", dp->d_namep);
@


9.9
log
@This version makes a decent solid with good normals.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: g_tgc.c,v 9.8 90/03/14 22:37:03 mike Locked $ (BRL)";
a1667 2

	nmg_ck_closed_surf(s);		/* debug */
@


9.8
log
@Added nmg_region_a() call
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: g_tgc.c,v 9.7 90/03/14 21:20:56 mike Locked $ (BRL)";
d1604 3
a1606 1
	/* Create two 16 point ellipses */
d1618 1
a1618 1
	/* Create the top face topology.  Verts must go clockwise */
d1621 1
a1621 1
	/* Create the bottom face topology.  Verts must go ccw */
d1630 2
a1631 2
	 * hanging down from the top face to the bottom face
	 * XXX which way around?
d1634 3
a1636 3
		vertlist[0] = vtop[i];
		vertlist[1] = vbottom[i];
		vertlist[2] = vbottom[i+1];
d1639 3
a1641 3
		vertlist[0] = vtop[i];
		vertlist[1] = vbottom[i+1];
		vertlist[2] = vtop[i+1];
a1644 1
	/* Associate the vertex geometry */
d1647 1
a1647 1
		nmg_vertex_gv( vtop[i], &top[3*i] );
d1649 2
d1652 1
a1652 2
		NMG_CK_VERTEX(vbottom[i]);
		nmg_vertex_gv( vbottom[i], &bottom[3*i] );
d1654 3
d1660 1
a1660 13
		eu = outfaceuses[i]->lu_p->down.eu_p;
		if (rt_mk_plane_3pts(plane, eu->vu_p->v_p->vg_p->coord,
					eu->next->vu_p->v_p->vg_p->coord,
					eu->last->vu_p->v_p->vg_p->coord)) {
			rt_log("At %d in %s\n", __LINE__, __FILE__);
			rt_bomb("cannot make plane equation\n");
		}
		else if (plane[0] == 0.0 && plane[1] == 0.0 && plane[2] == 0.0) {
			rt_log("Bad plane equation from rt_mk_plane_3pts at %d in %s\n",
					__LINE__, __FILE__);
			rt_bomb("BAD Plane Equation");
		}
		else nmg_face_g(outfaceuses[i], plane);
d1668 2
@


9.7
log
@Changed calling sequence to tessellation routines.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: g_tgc.c,v 9.6 90/03/14 15:06:03 mike Locked $ (BRL)";
d1484 1
a1484 1
	return(-1);
d1672 3
@


9.6
log
@Changed type of st_specific to genptr_t
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: g_tgc.c,v 9.5 90/03/05 23:57:49 mike Locked $ (BRL)";
d1447 1
a1447 1
void
d1461 1
a1461 1
	if( tgc_import( &ti, rp, mat ) < 0 )  return;
d1484 1
d1570 4
d1575 4
a1578 3
void
tgc_tess( s, rp, mat, dp )
struct shell	*s;
d1583 1
d1599 4
a1602 1
	if( tgc_import( &ti, rp, mat ) < 0 )  return;
d1609 3
d1673 1
a1673 1
	return;
@


9.5
log
@A neater way of making the top and bottom faces
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: g_tgc.c,v 9.4 90/02/28 01:53:25 mike Locked $ (BRL)";
d216 1
a216 1
	stp->st_specific = (int *)tgc;
@


9.4
log
@Converted to new NMG library
@
text
@d2 1
a2 1
 *			T G C . C
d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: /n/spark/m/cad/librt/RCS/g_tgc.c,v 9.3 90/02/27 23:30:07 mike Exp $ (BRL)";
d1582 1
d1600 1
a1600 1
		vbottom[i] = (struct vertex *)0;
d1604 1
a1604 4
	outfaceuses[0] = nmg_cface(s, (struct vertex **)NULL, 16);
	for (eu = outfaceuses[0]->lu_p->down.eu_p->next, i = 0 ;
	    i < 16 ; ++i, eu = eu->next)
		vtop[i] = eu->vu_p->v_p;
d1607 2
a1608 4
	outfaceuses[1] = nmg_cface(s, (struct vertex **)NULL, 16);
	for (eu = outfaceuses[1]->lu_p->down.eu_p->next, i = 16-1 ;
	    i >= 0 ; --i, eu = eu->next)
		vbottom[i] = eu->vu_p->v_p;
d1610 1
a1610 1
	/* Duplicate [0] as [16] to handle end condition, below */
@


9.3
log
@Changed some matrix pointers, #ifdef out nmg stuff
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: g_tgc.c,v 9.2 89/10/10 16:20:00 mike Locked $ (BRL)";
a1576 1
#if 0
d1585 5
d1602 5
a1606 3
	/* Create the top face topology */
	if( nmg_mkface1(s) )  goto fail;
	vtop[0] = s->downptr.fu_p->lu_p->eu_p->vu_p->v_p;
d1608 5
a1612 4
	for( i=1; i<16; i++ )  {
		if( nmg_newfacev(s->downptr.fu_p->lu_p->eu_p) ) goto fail;
		vtop[i] = s->downptr.fu_p->lu_p->eu_p->vu_p->v_p;
	}
d1614 1
a1614 1
	/* Duplicate [0] as [16] */
d1616 6
a1621 1
	/* Build topology for 16 side faces hanging down from the top one */
d1623 4
a1626 1
		if( nmg_mkfaceN(s, vtop[i] ) )  goto fail;
d1628 4
a1631 19
		/* Move down */
		if( vbottom[i] )  {
			if( nmg_insfacev( vbottom[i], s->downptr.fu_p->lu_p->eu_p ) ) goto fail;
		} else {
			if( nmg_newfacev(s->downptr.fu_p->lu_p->eu_p) ) goto fail;
			vbottom[i] = s->downptr.fu_p->lu_p->eu_p->vu_p->v_p;
		}
		if( i==0 )  vbottom[16] = vbottom[0];

		/* Move left */
		if( vbottom[i+1] )  {
			if( nmg_insfacev( vbottom[i+1], s->downptr.fu_p->lu_p->eu_p ) ) goto fail;
		} else {
			if( nmg_newfacev(s->downptr.fu_p->lu_p->eu_p) ) goto fail;
			vbottom[i+1] = s->downptr.fu_p->lu_p->eu_p->vu_p->v_p;
		}

		/* Return to the top */
		if( nmg_insfacev( vtop[i+1], s->downptr.fu_p->lu_p->eu_p ) ) goto fail;
d1634 1
a1634 7
	/* Build topology for bottom plate.  Go in reverse direction */
	if( nmg_mkfaceN(s, vbottom[15]) )  goto fail;
	for( i=15-1; i>=0; i-- )  {
		if( nmg_insfacev( vbottom[i], s->downptr.fu_p->lu_p->eu_p ) ) goto fail;
	}

	/* Supply the top geometry */
d1637 1
a1637 1
		if( nmg_vertex_gv( vtop[i], &top[3*i] ) )  goto fail;
a1638 2

	/* Supply the bottom geometry */
d1641 1
a1641 1
		if( nmg_vertex_gv( vbottom[i], &bottom[3*i] ) )  goto fail;
d1644 20
a1664 5
fail:
	rt_log("tgc_tess: failure\n");
#else
	nul_tess( s, rp, mat, dp );
#endif
@


9.2
log
@This version has explicit import() and tessellate() routines.
Note that the tessellation is not correct for all cases.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: g_tgc.c,v 9.1 89/05/19 05:56:32 mike Rel3_5 $ (BRL)";
d1417 1
a1417 1
tgc_import( tip, rp, matp )
d1420 1
a1420 1
register matp_t		matp;
d1434 6
a1439 6
	MAT4X3PNT( tip->v, matp, &vec[0*3] );
	MAT4X3VEC( tip->h, matp, &vec[1*3] );
	MAT4X3VEC( tip->a, matp, &vec[2*3] );
	MAT4X3VEC( tip->b, matp, &vec[3*3] );
	MAT4X3VEC( tip->c, matp, &vec[4*3] );
	MAT4X3VEC( tip->d, matp, &vec[5*3] );
d1448 1
a1448 1
tgc_plot( rp, matp, vhead, dp )
d1450 1
a1450 1
register matp_t matp;
d1461 1
a1461 1
	if( tgc_import( &ti, rp, matp ) < 0 )  return;
d1571 1
a1571 1
tgc_tess( s, rp, matp, dp )
d1574 1
a1574 1
register matp_t matp;
d1577 1
d1587 1
a1587 1
	if( tgc_import( &ti, rp, matp ) < 0 )  return;
d1655 3
@


9.1
log
@Release_3.5
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: g_tgc.c,v 8.9 89/04/17 17:19:56 mike Exp $ (BRL)";
d38 1
d66 8
a103 1
	LOCAL vect_t	V, Hv, A, B, C, D;
d106 1
a106 1
	fastf_t		vec[3*6];
d116 2
a117 1
	rt_fastf_float( vec, rec->s.s_values, 6 );
a118 17
#define TGC_V	&vec[0*ELEMENTS_PER_VECT]
#define TGC_H	&vec[1*ELEMENTS_PER_VECT]
#define TGC_A	&vec[2*ELEMENTS_PER_VECT]
#define TGC_B	&vec[3*ELEMENTS_PER_VECT]
#define TGC_C	&vec[4*ELEMENTS_PER_VECT]
#define TGC_D	&vec[5*ELEMENTS_PER_VECT]

	/* Apply full 4X4mat to V */
	MAT4X3PNT( V, stp->st_pathmat, TGC_V );

	/* Apply rotation to Hv, A,B,C,D */
	MAT4X3VEC( Hv, stp->st_pathmat, TGC_H );
	MAT4X3VEC( A, stp->st_pathmat, TGC_A );
	MAT4X3VEC( B, stp->st_pathmat, TGC_B );
	MAT4X3VEC( C, stp->st_pathmat, TGC_C );
	MAT4X3VEC( D, stp->st_pathmat, TGC_D );

d120 5
a124 5
	mag_h = sqrt( magsq_h = MAGSQ( Hv ) );
	mag_a = sqrt( magsq_a = MAGSQ( A ) );
	mag_b = sqrt( magsq_b = MAGSQ( B ) );
	mag_c = sqrt( magsq_c = MAGSQ( C ) );
	mag_d = sqrt( magsq_d = MAGSQ( D ) );
d155 2
a156 2
		VADD2( V, V, Hv );
		VREVERSE( Hv, Hv );
d158 2
a159 2
		VXCH( A, C, work );
		VXCH( B, D, work );
d164 2
a165 2
	VCROSS( work, A, B );
	f = VDOT( Hv, work ) / ( prod_ab*mag_h );
d173 1
a173 1
		f = VDOT( A, B ) / prod_ab;
d178 1
a178 1
				VDOT( A, B ),  prod_ab );
d184 1
a184 1
		f = VDOT( C, D ) / prod_cd;
d189 1
a189 1
				VDOT( C, D ), prod_cd );
d196 1
a196 1
		f = 1.0 - VDOT( A, C ) / (mag_a * mag_c);
d206 1
a206 1
		f = 1.0 - VDOT( B, D ) / (mag_b * mag_d);
d218 1
a218 1
	VMOVE( tgc->tgc_V, V );
d240 2
a241 2
	tgc_rotate( A, B, Hv, Rot, iRot, tgc );
	MAT4X3VEC( nH, Rot, Hv );
d275 2
a276 2
		VADD2( temp, tgc->tgc_V, A );
		VADD2( work, temp, B );
d279 1
a279 1
		VSUB2( work, temp, B );
d282 2
a283 2
		VSUB2( temp, tgc->tgc_V, A );
		VADD2( work, temp, B );
d285 1
a285 1
		VSUB2( work, temp, B );
d288 2
a289 2
		VADD3( temp, tgc->tgc_V, Hv, C );
		VADD2( work, temp, D );
d291 1
a291 1
		VSUB2( work, temp, D );
d294 3
a296 3
		VADD2( temp, tgc->tgc_V, Hv );
		VSUB2( temp, temp, C );
		VADD2( work, temp, D );
d298 1
a298 1
		VSUB2( work, temp, D );
a1408 7
/* Names for TGC fields */
#define VVAL	&points[0]
#define HVAL	&points[3]
#define AVAL	&points[6]
#define BVAL	&points[9]
#define CVAL	&points[12]
#define DVAL	&points[15]
d1411 34
d1455 5
a1459 6
	register fastf_t	*op;
	register dbfloat_t	*ip;
	fastf_t			top[16*3];
	fastf_t			bottom[16*3];
	static vect_t		work;		/* Vec addition work area */
	static fastf_t		points[3*8];
d1461 1
a1461 1
	MAT4X3PNT( &points[0], matp, &rp[0].s.s_values[0] );
d1463 3
a1465 7
	ip = &rp[0].s.s_values[1*3];
	op = &points[1*3];
	for( i=1; i<6; i++ )  {
		MAT4X3VEC( op, matp, ip );
		op += ELEMENTS_PER_VECT;
		ip += 3;
	}
a1466 4
	ell_16pts( bottom, VVAL, AVAL, BVAL );
	VADD2( work, VVAL, HVAL );
	ell_16pts( top, work, CVAL, DVAL );

d1563 91
@


8.9
log
@Calling sequence to xxx_prep() shortened from 6 to 3 args.
Database conversion moved into prep routines.
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: g_tgc.c,v 8.8 89/04/14 03:06:57 mike Locked $ (BRL)";
@


8.8
log
@Fixed indexing problem,
added rt_free
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 8.7 89/04/13 21:57:13 mike Locked $ (BRL)";
d82 1
a82 2
tgc_prep( vec, stp, mat, rtip )
register fastf_t	*vec;
d84 1
a84 1
matp_t			mat;
d98 1
d105 1
a105 1
	if( rec_prep( vec, stp, mat, rtip ) == 0 )
d108 2
d118 1
a118 1
	MAT4X3PNT( V, mat, TGC_V );
d121 5
a125 5
	MAT4X3VEC( Hv, mat, TGC_H );
	MAT4X3VEC( A, mat, TGC_A );
	MAT4X3VEC( B, mat, TGC_B );
	MAT4X3VEC( C, mat, TGC_C );
	MAT4X3VEC( D, mat, TGC_D );
@


8.7
log
@Initial vectorized version
@
text
@d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 8.6 89/04/11 13:00:15 phil Exp $ (BRL)";
d889 2
a890 2
	/* Use segp[i].seg_in.hit_normal as tmp to hold dprime */
	VMOVE( segp[i].seg_in.hit_normal, dprime );
d895 2
a896 2
	/* Use segp[i].seg_out.hit_normal as tmp to hold pprime */
	VMOVE( segp[i].seg_out.hit_normal, pprime );
d1175 1
a1175 1
			rt_log("tgc(%s):  only 1 intersect\n", stp->st_name);
d1214 1
a1214 1
	dir = VDOT( tgc->tgc_N, rp[i]->r_dir );	/* direc */
d1261 1
@


8.6
log
@missing parameter on rec_prep() call
@
text
@d17 1
d29 1
a29 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 8.5 89/04/11 12:15:36 phil Locked $ (BRL)";
d826 436
@


8.5
log
@lint
@
text
@d28 1
a28 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 8.4 88/12/15 01:26:04 phil Locked $ (BRL)";
d104 1
a104 1
	if( rec_prep( vec, stp, mat ) == 0 )
@


8.4
log
@moved tolerances out into raytrace.h
@
text
@d28 1
a28 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 8.3 88/12/14 01:46:58 phil Locked $ (BRL)";
d41 2
d834 1
@


8.3
log
@Addressed AB degenerate end problem.
Rationalized tolerancing.
@
text
@d28 1
a28 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 8.2 88/12/06 00:02:45 mike Locked $ (BRL)";
d131 1
a131 21
	/*
	 *  Unfortunately, to prevent divide-by-zero, some tolerancing
	 *  needs to be introduced.
	 *  TGC_LEN_TOL is the shortest length, in mm, that can be stood.
	 *  Can probably become at least SMALL.
	 *  Dot products smaller than TGC_DOT_TOL are considered to have
	 *  a dot product of zero, ie, the angle is effectively zero.
	 *  asin(0.1   ) = 5.73917 degrees
	 *  asin(0.01  ) = 0.572967
	 *  asin(0.001 ) = 0.0572958 degrees
	 *  asin(0.0001) = 0.00572958 degrees
	 *
	 *  sin(0.01 degrees) = sin(0.000174 radians) = 0.000174533
	 *
	 *  Many TGCs will fail if DOT_TOL is much smaller than 0.001,
	 *  which establishes a 1/20th degree tolerance.
	 *  The intent is to eliminate grossly bad TGCs, not pick nits.
	 */
#define TGC_LEN_TOL	(1.0e-8)
#define TGC_DOT_TOL	(0.001)
	if( NEAR_ZERO( magsq_h, TGC_LEN_TOL ) ) {
d137 2
a138 2
	if( NEAR_ZERO( magsq_a, TGC_LEN_TOL ) &&
	     NEAR_ZERO( magsq_c, TGC_LEN_TOL ) ) {
d142 2
a143 2
	if( NEAR_ZERO( magsq_b, TGC_LEN_TOL ) &&
	    NEAR_ZERO( magsq_d, TGC_LEN_TOL ) ) {
d149 1
a149 1
	if( prod_ab <= TGC_LEN_TOL )  {
d151 1
a151 1
		if( prod_cd <= TGC_LEN_TOL )  {
d169 1
a169 1
	if ( NEAR_ZERO(f, TGC_DOT_TOL) ) {
d177 1
a177 1
		if( ! NEAR_ZERO(f, TGC_DOT_TOL) ) {
d188 1
a188 1
		if( ! NEAR_ZERO(f, TGC_DOT_TOL) ) {
d200 1
a200 1
		if( ! NEAR_ZERO(f, TGC_DOT_TOL) ) {
d210 1
a210 1
		if( ! NEAR_ZERO(f, TGC_DOT_TOL) ) {
d534 1
a534 1
	if( NEAR_ZERO( dprime[Z], 1.0e-10 ) )
d777 1
a777 1
	if ( NEAR_ZERO( dir, TGC_DOT_TOL ) )
@


8.2
log
@Added _plot() routines, and db_*() interfaces.
@
text
@d28 1
a28 1
static char RCStgc[] = "@@(#)$Header: /cad/d/mike/cad/librt/RCS/tgc.c,v 1.2 88/11/03 12:35:40 mike Exp $ (BRL)";
d86 2
d93 1
a93 1
	LOCAL vect_t	Hv, A, B, C, D;
a95 1
	FAST fastf_t	f;
d112 3
d128 2
d131 21
a151 1
	if( NEAR_ZERO( magsq_h, 0.0001 ) ) {
a155 8
	/* Ascertain whether H lies in A-B plane 			*/
	VCROSS( work, A, B );
	f = VDOT( Hv, work )/ ( mag_a*mag_b*mag_h );
	if ( NEAR_ZERO(f, 0.0001) ) {
		rt_log("tgc(%s):  H lies in A-B plane\n",stp->st_name);
		return(1);		/* BAD */
	}

d157 2
a158 1
	if ( NEAR_ZERO( magsq_a, 0.0001 ) && NEAR_ZERO( magsq_c, 0.0001 ) ) {
d162 2
a163 1
	if ( NEAR_ZERO( magsq_b, 0.0001 ) && NEAR_ZERO( magsq_d, 0.0001 ) ) {
d169 22
a190 2
	if( mag_a * mag_b <= 0.001 && mag_c*mag_d <= 0.001 )  {
		rt_log("tgc(%s):  Both ends degenerate\n", stp->st_name);
d194 1
a194 1
	if( mag_a * mag_b > 0.001 )  {
d196 6
a201 3
		f = VDOT( A, B ) / (mag_a * mag_b);
		if( ! NEAR_ZERO(f, 0.0001) ) {
			rt_log("tgc(%s):  A not perpendicular to B\n",stp->st_name);
d205 1
a205 1
	if( mag_c * mag_d > 0.001 )  {
d207 6
a212 3
		f = VDOT( C, D ) / (mag_c * mag_d);
		if( ! NEAR_ZERO(f, 0.0001) ) {
			rt_log("tgc(%s):  C not perpendicular to D\n",stp->st_name);
d217 1
a217 1
	if( mag_a * mag_c > 0.001 )  {
d220 3
a222 2
		if( ! NEAR_ZERO(f, 0.0001) ) {
			rt_log("tgc(%s):  A not parallel to C\n",stp->st_name);
d227 1
a227 1
	if( mag_b * mag_d > 0.001 )  {
d230 3
a232 2
		if( ! NEAR_ZERO(f, 0.0001) ) {
			rt_log("tgc(%s):  B not parallel to D\n",stp->st_name);
d241 1
a241 6
	/* Apply full 4X4mat to V */
	{
		register fastf_t *p = TGC_V;
		MAT4X3PNT( tgc->tgc_V, mat, p );
	}

d248 1
a248 1
	if( NEAR_ZERO(magsq_c, 0.0001) )
d252 1
a252 1
	if( NEAR_ZERO(magsq_d, 0.0001) )
d269 1
a269 1
	if( NEAR_ZERO( tgc->tgc_CdAm1, 0.0001 ) )
d271 1
a271 1
	if( NEAR_ZERO( tgc->tgc_DdBm1, 0.0001 ) )
d554 1
a554 1
	if( NEAR_ZERO( dprime[Z], 0.0001 ) )
d797 1
a797 1
	if ( NEAR_ZERO( dir, 0.0001 ) )
@


8.1
log
@Release_3.0
@
text
@d28 1
a28 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 7.3 88/05/14 00:01:22 mike Exp $ (BRL)";
d951 11
d963 5
a967 1
tgc_plot()
d969 39
@


7.3
log
@lint fixes
added zero _uv() routines to some modules
@
text
@d28 1
a28 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 7.2 88/02/06 05:37:06 mike Locked $ (BRL)";
@


7.2
log
@rt_orthovec to vec_ortho
@
text
@d28 1
a28 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 7.1 87/11/02 23:34:29 mike Locked $ (BRL)";
d78 1
d419 1
d876 1
d919 6
a924 1
tgc_uv()
d926 3
d931 1
d935 1
d945 1
d948 1
d951 1
d961 1
@


7.1
log
@Release 2.3
@
text
@d28 1
a28 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 6.1 87/07/11 07:56:46 mike Rel $ (BRL)";
d960 1
a960 1
		rt_orthovec( cvp->crv_pdir, hitp->hit_normal );
d1003 1
a1003 1
	rt_orthovec( u, hitp->hit_normal );
@


6.1
log
@Release 2.0
@
text
@d28 1
a28 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 5.1 87/06/24 22:12:42 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d28 1
a28 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 4.7 87/05/30 06:42:30 phil Exp $ (BRL)";
@


4.7
log
@new curvature code
code documentation cleanup
@
text
@d28 1
a28 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 4.6 87/04/28 00:28:00 phil Exp $ (BRL)";
@


4.6
log
@changed curve convention
@
text
@d15 2
d28 1
a28 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 4.5 87/04/07 22:05:37 phil Locked $ (BRL)";
d52 4
a55 4
	fastf_t	tgc_CA_H;	/*  (C-A)/H  X_of_Z */
	fastf_t tgc_DB_H;	/*  (D-B)/H  Y_of_Z */
	fastf_t	tgc_AAdCC;	/*  (|A|**2)/(|C|**2) */
	fastf_t	tgc_BBdDD;	/*  (|B|**2)/(|D|**2) */
d223 6
a228 6
	tgc->tgc_CA_H = tgc->tgc_C/tgc->tgc_A - 1.0;
	tgc->tgc_DB_H = tgc->tgc_D/tgc->tgc_B - 1.0;
	if( NEAR_ZERO( tgc->tgc_CA_H, 0.0001 ) )
		tgc->tgc_CA_H = 0.0;
	if( NEAR_ZERO( tgc->tgc_DB_H, 0.0001 ) )
		tgc->tgc_DB_H = 0.0;
d240 1
d386 2
a387 2
		Inv[4] = -1.0 * (Shr[4] = Trn[1] = -vect[Y]/vect[X]);
		Inv[8] = -1.0 * (Shr[8] = Trn[2] = -vect[Z]/vect[X]);
d389 2
a390 2
		Inv[1] = -1.0 * (Shr[1] = Trn[4] = Inv[1] = -vect[X]/vect[Y]);
		Inv[9] = -1.0 * (Shr[9] = Trn[6] = Inv[9] = -vect[Z]/vect[Y]);
d392 2
a393 2
		Inv[2] = -1.0 * (Shr[2] = Trn[8] = -vect[X]/vect[Z]);
		Inv[6] = -1.0 * (Shr[6] = Trn[9] = -vect[Y]/vect[Z]);
d440 2
a441 2
	rt_log( "(C-A)/H = %f\n", tgc->tgc_CA_H );
	rt_log( "(D-B)/H = %f\n", tgc->tgc_DB_H );
d556 1
a556 1
	R.cf[0] = dprime[Z] * tgc->tgc_CA_H;
d558 1
a558 1
	R.cf[1] = (cor_pprime[Z] * tgc->tgc_CA_H) + 1.0;
d589 1
a589 1
		Q.cf[0] = dprime[Z] * tgc->tgc_DB_H;
d591 1
a591 1
		Q.cf[1] = (cor_pprime[Z] * tgc->tgc_DB_H) + 1.0;
d829 2
a830 2
 *  The gradient of the cone at that point is the normal vector
 *  in the standard space.  This vector will need to be rotated
d832 1
a832 1
 *  to be useful.  Then the rotated vector must be 'unitized.'
d834 6
a839 4
 *  NOTE:  The rotation required is NOT the inverse of the of the
 *	   rotation to the standard cone.  If you really want to 
 *	   know why, talk to Ed Davisson or to me (only if you're
 *	   truly desperate would I advise this).
d841 2
a842 1
 *  The equation for the standard cone is:
d844 1
a844 1
 *	   X**2 * Q**2  +  Y**2 * R**2  -  R**2 * Q**2 = 0
d850 3
a852 1
 *  Therefore, the gradient of f(x,y,z) = 0 is:
d854 5
d861 3
a863 2
 *	df/dz = x**2 * 2 * Q * dQ/dz + y**2 * 2 * R * dR/dz +
 *		R**2 * 2 * Q * dQ/dz + 2 * R * dR/dz * Q**2
d866 7
a872 2
 *		dQ/dz = (c - a)/|H'|
 *		dR/dz = (d - b)/|H'|
d898 8
a905 8
		R = 1 + tgc->tgc_CA_H * hitp->hit_vpriv[Z];
		Q = 1 + tgc->tgc_DB_H * hitp->hit_vpriv[Z];
		stdnorm[X] = 2 * hitp->hit_vpriv[X] * Q * Q;
		stdnorm[Y] = 2 * hitp->hit_vpriv[Y] * R * R;
		stdnorm[Z] = 2 * ( Q * tgc->tgc_DB_H *
				(hitp->hit_vpriv[X]*hitp->hit_vpriv[X] - R*R)
			     + R * tgc->tgc_CA_H *
				(hitp->hit_vpriv[Y]*hitp->hit_vpriv[Y] - Q*Q) );
d907 1
d940 5
a949 1
	static int count = 0;
d952 5
d958 2
a959 11
	if( count++ == 0 )
		rt_log("WARNING: tgc_curve is not fully implemented\n");

	switch( hitp->hit_private-tgc_compute )  {
	case 0:
		rt_orthovec( cvp->crv_pdir, hitp->hit_normal );	/* XXX - random guess */
		cvp->crv_c1 = 0;
		cvp->crv_c2 = 0;			/* XXX - to do */
		break;
	case 1:
	case 2:
d962 1
a962 4
		break;
	default:
		rt_log("tgc_curve: bad flag x%x\n", (int)hitp->hit_private);
		break;
d964 52
@


4.5
log
@added a simple curvature routine (until a real one is done).
@
text
@d26 1
a26 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 4.4 87/03/23 23:41:09 phil Locked $ (BRL)";
d920 1
a920 1
tgc_curve( cvp, hitp, stp, rp )
a923 1
struct xray *rp;
a936 5

		if( VDOT( hitp->hit_normal, rp->r_dir ) > 0 )  {
			/* ray strikes surface from inside; make curv negative */
			cvp->crv_c2 = - cvp->crv_c2;
		}
@


4.4
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d26 1
a26 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 4.3 87/03/10 23:43:13 mike Exp $ (BRL)";
d920 5
a924 1
tgc_curve()
d926 27
a952 1
	rt_log("tgc_curve?\n");
@


4.3
log
@For Stay, switched 3rd arg to ft_shoot() from resource pointer
(member of application struct) to application struct pointer.
@
text
@d26 1
a26 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 4.2 87/02/12 22:12:06 mike Locked $ (BRL)";
d76 5
a80 4
tgc_prep( vec, stp, mat )
register fastf_t *vec;
struct soltab *stp;
matp_t mat;			/* Homogenous 4x4, with translation, [15]=1 */
d898 25
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d26 1
a26 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 4.1 86/12/29 03:46:10 mike Rel1 $ (BRL)";
d470 1
a470 1
tgc_shot( stp, rp, res )
d473 1
a473 1
struct resource		*res;
d659 1
a659 1
		GET_SEG( segp, res );
d713 1
a713 1
		GET_SEG( segp, res );
d771 1
a771 1
	GET_SEG( segp, res );
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d26 1
a26 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 3.7 86/12/24 08:06:21 mike Locked $ (BRL)";
@


3.7
log
@Revised for resource structure.
@
text
@d26 1
a26 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 3.6 86/11/24 23:24:23 mike Locked $ (BRL)";
@


3.6
log
@Squeeky clean with hit_private, for the Cray.
@
text
@d26 1
a26 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 3.5 86/10/11 03:07:32 mike Locked $ (BRL)";
d470 1
a470 1
tgc_shot( stp, rp )
d473 1
d659 1
a659 1
		GET_SEG( segp );
d713 1
a713 1
		GET_SEG( segp );
d771 1
a771 1
	GET_SEG( segp );
@


3.5
log
@New routine, rt_pt_sort(), with better algorithm.
@
text
@d26 1
a26 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 3.4 86/08/12 04:16:42 mike Exp $ (BRL)";
d442 3
d662 1
a662 1
		segp->seg_in.hit_private = (char *)0;	/* flag: compute */
d666 1
a666 1
		segp->seg_out.hit_private = (char *)0;	/* flag: compute */
d672 1
a672 1
		int nflag;		/* 1 = normal, 2 = reverse normal */
d702 1
a702 1
			nflag = 2;		/* copy reverse normal */
d705 1
a705 1
			nflag = 1;		/* copy normal */
d717 1
a717 1
			segp->seg_in.hit_private = (char *)nflag;
d720 1
a720 1
			segp->seg_out.hit_private = (char *)0;	/* compute */
d726 1
a726 1
			segp->seg_in.hit_private = (char *)0;	/* compute */
d730 1
a730 1
			segp->seg_out.hit_private = (char *)nflag;
d779 1
a779 1
		segp->seg_in.hit_private = (char *)2;	/* reverse normal */
d782 1
a782 1
		segp->seg_out.hit_private = (char *)1;	/* normal */
d785 1
a785 1
		segp->seg_in.hit_private = (char *)1;	/* normal */
d788 1
a788 1
		segp->seg_out.hit_private = (char *)2;	/* reverse normal */
d868 2
a869 1
	if( ((int)hitp->hit_private) == 1 )  {
d871 2
a872 2
		return;
	} else if ( ((int)hitp->hit_private) == 2 )  {
d874 17
a890 1
		return;
a891 11
	/* Compute normal, given hit point on standard (unit) cone */
	R = 1 + tgc->tgc_CA_H * hitp->hit_vpriv[Z];
	Q = 1 + tgc->tgc_DB_H * hitp->hit_vpriv[Z];
	stdnorm[X] = 2 * hitp->hit_vpriv[X] * Q * Q;
	stdnorm[Y] = 2 * hitp->hit_vpriv[Y] * R * R;
	stdnorm[Z] = 2 * ( Q * tgc->tgc_DB_H *
			(hitp->hit_vpriv[X]*hitp->hit_vpriv[X] - R*R)
		     + R * tgc->tgc_CA_H *
			(hitp->hit_vpriv[Y]*hitp->hit_vpriv[Y] - Q*Q) );
	MAT4X3VEC( hitp->hit_normal, tgc->tgc_invRtShSc, stdnorm );
	VUNITIZE( hitp->hit_normal );
@


3.4
log
@Changed #include directives for use with CC -I convention
@
text
@d26 1
a26 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 3.3 86/07/24 06:10:47 mike Exp $ (BRL)";
d39 1
a39 1
static void	tgc_rotate(), tgc_shear(), tgc_sort();
d41 1
d625 1
a625 1
	tgc_sort( k, npts );
d792 1
a792 1
 *			T G C _ S O R T
d794 1
a794 3
 *  Sorts the values of 't' in descending order.  The sort is
 *  simplified to deal with only 2 or 4 values.  Returns the
 *  address of the first 't' in the array.
d796 2
a797 2
static void
tgc_sort( t, npts )
d801 1
a801 1
	register int	n;
d803 7
a809 16
#define TGC_XCH(a,b)	{ u=a; a=b; b=u; }
	if ( npts == 2 ){
		if ( t[0] < t[1] ){
			TGC_XCH( t[0], t[1] );
		}
		return;
	}

	for ( n=0; n < 2; ++n ){
		if ( t[n] < t[n+2] ){
			TGC_XCH( t[n], t[n+2] );
		}
	}
	for ( n=0; n < 3; ++n ){
		if ( t[n] < t[n+1] ){
			TGC_XCH( t[n], t[n+1] );
@


3.3
log
@Added uvcoord support
@
text
@d26 1
a26 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 3.2 86/07/17 23:15:16 mike Exp $ (BRL)";
a29 7
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/db.h"
#include "../h/raytrace.h"
#include "debug.h"
#include "polyno.h"
#include "complex.h"
d31 7
@


3.2
log
@Extra error checking.
@
text
@d26 1
a26 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 3.1 86/07/11 01:32:59 mike Exp $ (BRL)";
a40 1
static void	tgc_minmax();
d251 2
a252 1
		tgc_minmax( stp, work );	/* V + A + B */
d254 1
a254 1
		tgc_minmax( stp, work );	/* V + A - B */
d258 1
a258 1
		tgc_minmax( stp, work );	/* V - A + B */
d260 1
a260 1
		tgc_minmax( stp, work );	/* V - A - B */
d264 1
a264 1
		tgc_minmax( stp, work );	/* V + H + C + D */
d266 1
a266 1
		tgc_minmax( stp, work );	/* V + H + C - D */
d271 1
a271 1
		tgc_minmax( stp, work );	/* V + H - C + D */
d273 1
a273 1
		tgc_minmax( stp, work );	/* V + H - C - D */
a892 15
}

#define TGC_MINMAX(a,b,c)	{if( (ftemp = (c)) < (a) )  a = ftemp;\
			if( ftemp > (b) )  b = ftemp; }

static void
tgc_minmax(stp, v)
register struct soltab *stp;
vectp_t v;
{
	FAST fastf_t ftemp;

	TGC_MINMAX( stp->st_min[X], stp->st_max[X], v[X] );
	TGC_MINMAX( stp->st_min[Y], stp->st_max[Y], v[Y] );
	TGC_MINMAX( stp->st_min[Z], stp->st_max[Z], v[Z] );
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d26 1
a26 1
static char RCStgc[] = "@@(#)$Header: tgc.c,v 3.0 86/06/10 01:34:03 mike Exp $ (BRL)";
d144 3
a146 4
	/* Validate that A.B == 0, C.D == 0				*/
	f = VDOT( A, B ) / (mag_a * mag_b);
	if( ! NEAR_ZERO(f, 0.0001) ) {
		rt_log("tgc(%s):  A not perpendicular to B\n",stp->st_name);
d149 8
a156 4
	f = VDOT( C, D ) / (mag_c * mag_d);
	if( ! NEAR_ZERO(f, 0.0001) ) {
		rt_log("tgc(%s):  C not perpendicular to D\n",stp->st_name);
		return(1);		/* BAD */
d158 8
d167 7
a173 5
	/* Validate that  A || C  and  B || D, for parallel planes	*/
	f = 1.0 - VDOT( A, C ) / (mag_a * mag_c);
	if( ! NEAR_ZERO(f, 0.0001) ) {
		rt_log("tgc(%s):  A not parallel to C\n",stp->st_name);
		return(1);		/* BAD */
d175 8
a182 4
	f = 1.0 - VDOT( B, D ) / (mag_b * mag_d);
	if( ! NEAR_ZERO(f, 0.0001) ) {
		rt_log("tgc(%s):  B not parallel to D\n",stp->st_name);
		return(1);		/* BAD */
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 2.5 86/06/09 21:51:15 mike Exp $ (BRL)";
d35 2
a36 3

#include "./polyno.h"
#include "./complex.h"
d66 1
a66 1
 *		>>>  t g c _ p r e p ( )  <<<
d100 6
a105 6
#define SP_V	&vec[0*ELEMENTS_PER_VECT]
#define SP_H	&vec[1*ELEMENTS_PER_VECT]
#define SP_A	&vec[2*ELEMENTS_PER_VECT]
#define SP_B	&vec[3*ELEMENTS_PER_VECT]
#define SP_C	&vec[4*ELEMENTS_PER_VECT]
#define SP_D	&vec[5*ELEMENTS_PER_VECT]
d108 5
a112 5
	MAT4X3VEC( Hv, mat, SP_H );
	MAT4X3VEC( A, mat, SP_A );
	MAT4X3VEC( B, mat, SP_B );
	MAT4X3VEC( C, mat, SP_C );
	MAT4X3VEC( D, mat, SP_D );
d121 1
a121 1
	if( NEAR_ZERO( magsq_h ) ) {
d129 1
a129 1
	if ( NEAR_ZERO(f) ) {
d135 1
a135 1
	if ( NEAR_ZERO( magsq_a ) && NEAR_ZERO( magsq_c ) ) {
d139 1
a139 1
	if ( NEAR_ZERO( magsq_b ) && NEAR_ZERO( magsq_d ) ) {
d146 1
a146 1
	if( ! NEAR_ZERO(f) ) {
d151 1
a151 1
	if( ! NEAR_ZERO(f) ) {
d158 1
a158 1
	if( ! NEAR_ZERO(f) ) {
d163 1
a163 1
	if( ! NEAR_ZERO(f) ) {
d174 1
a174 1
		register fastf_t *p = SP_V;
d184 1
a184 1
	if( NEAR_ZERO(magsq_c) )
d188 1
a188 1
	if( NEAR_ZERO(magsq_d) )
d198 1
a198 1
	tgc->tgc_AD_CB = (f < EPSILON);		/* A*D == C*B */
d205 1
a205 1
	if( NEAR_ZERO( tgc->tgc_CA_H ) )
d207 1
a207 1
	if( NEAR_ZERO( tgc->tgc_DB_H ) )
d425 1
a425 1
 *		>>>  t g c _ s h o t ( )  <<<
d472 1
a472 1
	/* find rotated point and direction				*/
d474 1
d483 1
a483 1
	if( NEAR_ZERO( dprime[Z] ) )
d535 2
a536 1
	/*  If the eccentricities of the two ellipses are the same,
d545 1
d584 1
a584 1
			if ( NEAR_ZERO( val[l].im ) )
d726 1
a726 1
	if ( NEAR_ZERO( dir ) )
d787 1
a787 1
#define XCH(a,b)	{ u=a; a=b; b=u; }
d790 1
a790 1
			XCH( t[0], t[1] );
d797 1
a797 1
			XCH( t[n], t[n+2] );
d802 1
a802 1
			XCH( t[n], t[n+1] );
d878 1
a878 1
#define MINMAX(a,b,c)	{if( (ftemp = (c)) < (a) )  a = ftemp;\
d888 3
a890 3
	MINMAX( stp->st_min[X], stp->st_max[X], v[X] );
	MINMAX( stp->st_min[Y], stp->st_max[Y], v[Y] );
	MINMAX( stp->st_min[Z], stp->st_max[Z], v[Z] );
@


2.5
log
@rt and librt separated
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 2.4 85/11/19 21:18:50 mike Exp $ (BRL)";
a39 1
HIDDEN int	stdCone();
d123 1
a123 1
		rtlog("tgc(%s):  zero length H vector\n", stp->st_name );
d131 1
a131 1
		rtlog("tgc(%s):  H lies in A-B plane\n",stp->st_name);
d137 1
a137 1
		rtlog("tgc(%s):  vectors A, C zero length\n", stp->st_name );
d141 1
a141 1
		rtlog("tgc(%s):  vectors B, D zero length\n", stp->st_name );
d148 1
a148 1
		rtlog("tgc(%s):  A not perpendicular to B\n",stp->st_name);
d153 1
a153 1
		rtlog("tgc(%s):  C not perpendicular to D\n",stp->st_name);
d160 1
a160 1
		rtlog("tgc(%s):  A not parallel to C\n",stp->st_name);
d165 1
a165 1
		rtlog("tgc(%s):  B not parallel to D\n",stp->st_name);
d198 1
a198 1
	f = reldiff( (tgc->tgc_A*tgc->tgc_D), (tgc->tgc_C*tgc->tgc_B) );
d404 5
a408 5
	rtlog( "mag sheared H = %f\n", tgc->tgc_sH );
	rtlog( "mag A = %f\n", tgc->tgc_A );
	rtlog( "mag B = %f\n", tgc->tgc_B );
	rtlog( "mag C = %f\n", tgc->tgc_C );
	rtlog( "mag D = %f\n", tgc->tgc_D );
d415 1
a415 1
		rtlog( "A*D == C*B.  Equal eccentricities gives quadratic equation.\n");
d417 1
a417 1
		rtlog( "A*D != C*B.  Quartic equation.\n");
d419 4
a422 4
	rtlog( "(C-A)/H = %f\n", tgc->tgc_CA_H );
	rtlog( "(D-B)/H = %f\n", tgc->tgc_DB_H );
	rtlog( "(|A|**2)/(|C|**2) = %f\n", tgc->tgc_AAdCC );
	rtlog( "(|B|**2)/(|D|**2) = %f\n", tgc->tgc_BBdDD );
d468 4
d497 26
a522 1
	npts = stdCone( cor_pprime, dprime, tgc, k );
d524 68
d599 1
a599 1
		rtlog("tgc(%s):  %d intersects != {0,2,4}\n",
d607 1
a607 3
	/* Now, t[0] > t[npts-1].  See if this is an easy out. */
	if( npts > 0 && k[0] <= 0.0 )
		return(SEG_NULL);		/* No hit out front. */
d661 1
a661 1
			rtlog("tgc: dprime[Z] = 0!\n" );
d685 1
a685 1
			rtlog("tgc(%s):  only 1 intersect\n", stp->st_name);
d772 1
a772 112
 *		>>>  s t d C o n e ( )  <<<
 *
 *  Given a line and the parameters for a standard cone, finds
 *  the roots of the equation for that cone and line.
 *  Returns the number of real roots found.
 * 
 *  Given a line and the cone parameters, finds the equation
 *  of the cone in terms of the variable 't'.
 *
 *  The equation for the cone is:
 *
 *      X**2 * Q**2  +  Y**2 * R**2  -  R**2 * Q**2 = 0
 *
 *  where	R = a + ((c - a)/|H'|)*Z 
 *		Q = b + ((d - b)/|H'|)*Z
 *
 *  First, find X, Y, and Z in terms of 't' for this line, then
 *  substitute them into the equation above.
 */
HIDDEN int
stdCone( pprime, dprime, tgc, t )
vect_t		pprime;
vect_t		dprime;
struct tgc_specific	*tgc;
fastf_t		t[];
{
	LOCAL poly	C;	/*  final equation	*/
	LOCAL poly	Xsqr, Ysqr;
	LOCAL poly	R, Rsqr;
	LOCAL poly	sum;

	/*  Express each variable (X, Y, and Z) as a linear equation
	 *  in 't', eg, (dprime[X] * t) + pprime[X], and
	 *  substitute into the cone equation.
	 */
	Xsqr.dgr = 2;
	Xsqr.cf[0] = dprime[X] * dprime[X];
	Xsqr.cf[1] = 2.0 * dprime[X] * pprime[X];
	Xsqr.cf[2] = pprime[X] * pprime[X];

	Ysqr.dgr = 2;
	Ysqr.cf[0] = dprime[Y] * dprime[Y];
	Ysqr.cf[1] = 2.0 * dprime[Y] * pprime[Y];
	Ysqr.cf[2] = pprime[Y] * pprime[Y];

	R.dgr = 1;
	R.cf[0] = dprime[Z] * tgc->tgc_CA_H;
	/* A vector is unitized (tgc->tgc_A == 1.0) */
	R.cf[1] = (pprime[Z] * tgc->tgc_CA_H) + 1.0;
	(void) polyMul( &R, &R, &Rsqr );

	/*  If the eccentricities of the two ellipses are the same,
	 *  then the cone equation reduces to a much simpler quadratic
	 *  form.  Otherwise it is a (gah!) quartic equation.
	 */
	if ( tgc->tgc_AD_CB ){
		FAST fastf_t roots;

		(void) polyAdd( &Xsqr, &Ysqr, &sum );
		(void) polySub( &sum, &Rsqr, &C );
		/* Find the real roots the easy way.  C.dgr==2 */
		if( (roots = C.cf[1]*C.cf[1] - 4 * C.cf[0] * C.cf[2]) < 0 )
			return(0);	/* no real roots */
		roots = sqrt(roots);
		t[0] = (roots - C.cf[1]) * 0.5 / C.cf[0];
		t[1] = (roots + C.cf[1]) * (-0.5) / C.cf[0];
		return(2);
	} else {
		LOCAL poly	Q, Qsqr;
		LOCAL poly	T1, T2, T3;
		LOCAL complex	val[MAXP];	/* roots of final equation */
		register int	i, l;
		register int	npts;

		Q.dgr = 1;
		Q.cf[0] = dprime[Z] * tgc->tgc_DB_H;
		/* B vector is unitized (tgc->tgc_B == 1.0) */
		Q.cf[1] = (pprime[Z] * tgc->tgc_DB_H) + 1.0;
		(void) polyMul( &Q, &Q, &Qsqr );

		(void) polyMul( &Qsqr, &Xsqr, &T1 );
		(void) polyMul( &Rsqr, &Ysqr, &T2 );
		(void) polyMul( &Rsqr, &Qsqr, &T3 );
		(void) polyAdd( &T1, &T2, &sum );
		(void) polySub( &sum, &T3, &C );

		/*  The equation is 4th order, so we expect 0 to 4 roots */
		npts = polyRoots( &C , val );

		/*  Only real roots indicate an intersection in real space.
		 *
		 *  Look at each root returned; if the imaginary part is zero
		 *  or sufficiently close, then use the real part as one value
		 *  of 't' for the intersections
		 */
		for ( l=0, i=0; l < npts; l++ ){
			if ( NEAR_ZERO( val[l].im ) )
				t[i++] = val[l].re;
		}
		/* Here, 'i' is number of points being returned */
		if ( i != 0 && i != 2 && i != 4 ){
			rtlog("stdCone:  reduced %d to %d roots\n",npts,i);
			pr_roots( npts, val );
		}
		return(i);
	}
	/* NOTREACHED */
}


/*
 *		>>>  P t S o r t ( )  <<<
@


2.4
log
@Fix from Moss, Hays, and Davisson to handle TGC with equal
eccentricities of the ellipses.
Plus some optimizations.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 2.2 85/09/10 01:14:59 mike Exp $ (BRL)";
d33 1
a33 1
#include "raytrace.h"
@


2.3
log
@Fixed minor error with normals.
@
text
@a51 1
	fastf_t	tgc_ABsq;	/*  (A/B)**2 or (C/D)**2  */
a57 1
	mat_t	tgc_inv_ScShR;	/*  invRot( invShear( invScale( vect )))*/
a200 14
	if ( tgc->tgc_AD_CB )  {
		if ( !NEAR_ZERO( tgc->tgc_B ) )  {
			tgc->tgc_ABsq = tgc->tgc_A/tgc->tgc_B;
			tgc->tgc_ABsq *= tgc->tgc_ABsq;		/* (A/B)**2 */
		} else if( !NEAR_ZERO( tgc->tgc_D ) )  {
			tgc->tgc_ABsq = tgc->tgc_C/tgc->tgc_D;
			tgc->tgc_ABsq *= tgc->tgc_ABsq;		/* (A/B)**2 */
		} else {
			rtlog("tgc: (A/B)**2 is enormous\n");
			tgc->tgc_ABsq = VLARGE;
		}
	} else
		tgc->tgc_ABsq = 0;			/* safety */

a213 3
	 *	Added a matrix to tgc_specific for inverse transformation
	 *		of std. solid intersection points (tgc_inv_ScShR)
	 *		which includes a the inverse of a scaling transform.
a227 3
	mat_mul( tmp, iShr, iScl );
	mat_mul( tgc->tgc_inv_ScShR, iRot, tmp );

a416 1
		rtlog( "(A/B)**2 = %f\n", tgc->tgc_ABsq );
a536 1

d735 1
a735 1
		(void) polyScal( &Ysqr, tgc->tgc_ABsq );
@


2.2
log
@Removed distracting message.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 2.1 85/08/31 06:07:11 mike Exp $ (BRL)";
d689 1
a689 1
		segp->seg_in.hit_private = (char *)1;	/* normal */
@


2.1
log
@Version 2 of RT
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 1.27 85/07/30 05:55:47 mike Exp $ (BRL)";
d591 1
a591 1
			rtlog("tgc: A dprime[Z] = 0!\n" );
d650 3
a656 4
	if( dprime[Z] == 0.0 )  {
		rtlog("tgc: B dprime[Z] = 0!\n" );
		return(SEG_NULL);
	}
@


1.27
log
@Changes for merged GED & RT vmath.h
@
text
@d14 1
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 1.26 85/06/19 18:41:16 mike Exp $ (BRL)";
a40 1
HIDDEN void	tgcnormal();
d55 3
a57 1
	vect_t	tgc_norm;	/*  normal at 'top' of cone		*/
d66 1
a67 2
#define	Alpha(x,y,c,d)     (( NEAR_ZERO(c) || NEAR_ZERO(d) ) ? VLARGE :\
			( (x)*(x)/((c)*(c)) + (y)*(y)/((d)*(d))) )
a68 1

d96 8
d126 1
a126 1
		fprintf(stderr,"tgc(%s):  zero length H vector\n", stp->st_name );
d134 1
a134 1
		fprintf(stderr,"tgc(%s):  H lies in A-B plane\n",stp->st_name);
d140 1
a140 1
		fprintf(stderr,"tgc(%s):  vectors A, C zero length\n", stp->st_name );
d144 1
a144 1
		fprintf(stderr,"tgc(%s):  vectors B, D zero length\n", stp->st_name );
d151 1
a151 1
		fprintf(stderr,"tgc(%s):  A not perpendicular to B\n",stp->st_name);
d156 1
a156 1
		fprintf(stderr,"tgc(%s):  C not perpendicular to D\n",stp->st_name);
d163 1
a163 1
		fprintf(stderr,"tgc(%s):  A not parallel to C\n",stp->st_name);
d168 1
a168 1
		fprintf(stderr,"tgc(%s):  B not parallel to D\n",stp->st_name);
d187 10
d211 1
a211 1
			fprintf(stderr,"tgc: (A/B)**2 is enormous\n");
d288 1
d290 1
d292 3
a294 1
		stp->st_radsq = dx*dx + dy*dy + dz*dz;
d346 1
a346 1
	VMOVE( tgc->tgc_norm, uC );
d417 3
d427 6
a432 6
	fprintf(stderr, "mag sheared H = %f\n", tgc->tgc_sH );
	fprintf(stderr, "mag A = %f\n", tgc->tgc_A );
	fprintf(stderr, "mag B = %f\n", tgc->tgc_B );
	fprintf(stderr, "mag C = %f\n", tgc->tgc_C );
	fprintf(stderr, "mag D = %f\n", tgc->tgc_D );
	VPRINT( "Top normal", tgc->tgc_norm );
d438 2
a439 2
		fprintf(stderr, "A*D == C*B.  Equal eccentricities gives quadratic equation.\n");
		fprintf(stderr, "(A/B)**2 = %f\n", tgc->tgc_ABsq );
d441 1
a441 1
		fprintf(stderr, "A*D != C*B.  Quatric equation.\n");
d443 4
a446 2
	fprintf(stderr, "(C-A)/H = %f\n", tgc->tgc_CA_H );
	fprintf(stderr, "(D-B)/H = %f\n", tgc->tgc_DB_H );
d480 9
a488 11
	LOCAL struct seg	*segp;
	LOCAL vect_t		pprime,
				dprime,
				norm,
				work;
	LOCAL vect_t		more_work;

	LOCAL fastf_t		k[4], pt[2],
				t, b, zval, dir,
				alf1, alf2;
	LOCAL int		npts, n, intersect;
d495 7
a501 1
	VUNITIZE( dprime );
d503 3
d526 1
a526 1
		fprintf(stderr,"tgc(%s):  %d intersects != {0,2,4}\n",
d550 2
a551 2
	for ( n=0; n < npts; ++n ){
		zval = k[n]*dprime[Z] + pprime[Z];
d554 4
a557 5
			/* Why keep going after intersect == 2 ??? */
			if ( ++intersect == 2 )
				pt[IN] = k[n];
			else
				pt[OUT] = k[n];
d568 3
a570 4
		/* IN hit point back to target coord. system.		*/
		VJOIN1( work, pprime, pt[IN], dprime );
		MAT4X3VEC( more_work, tgc->tgc_inv_ScShR, work );
		VADD2( segp->seg_in.hit_point, more_work, tgc->tgc_V );
d572 3
a574 1
		tgcnormal( segp->seg_in.hit_normal, work, tgc );
a575 15
		/* Compute IN hit distance.				*/
		VSUB2( work, segp->seg_in.hit_point, rp->r_pt );
		segp->seg_in.hit_dist = VDOT( work, rp->r_dir );

		/* OUT hit point back to target coord. system.		*/
		VJOIN1( work, pprime, pt[OUT], dprime );
		MAT4X3VEC( more_work, tgc->tgc_inv_ScShR, work );
		VADD2( segp->seg_out.hit_point, more_work, tgc->tgc_V );

		tgcnormal( segp->seg_out.hit_normal, work, tgc );

		/* Compute OUT hit distance.				*/
		VSUB2( work, segp->seg_out.hit_point, rp->r_pt );
		segp->seg_out.hit_dist = VDOT( work, rp->r_dir );

d579 5
a583 2
		/*  If only one such intersection exists, the other
		 *  intersection must be on one of the planar surfaces.
d590 4
d600 2
a601 2
		/* alf1 = Alpha(work[0], work[1], 1.0, 1.0 ) */
		alf1 = work[0]*work[0] + work[1]*work[1];
d605 1
a605 1
		alf2 = Alpha(work[0],work[1],tgc->tgc_C/tgc->tgc_A,tgc->tgc_D/tgc->tgc_B);
d609 1
a609 1
			VREVERSE( norm, tgc->tgc_norm );
d612 1
a612 1
			VMOVE( norm, tgc->tgc_norm );
d615 1
a615 1
			fprintf(stderr,"tgc(%s):  only 1 intersect\n", stp->st_name);
d621 4
a624 5
		if ( pt[OUT] == Max( pt[OUT], pt[IN] ) ){
			/* IN hit point back to target coord. system.	*/
			VJOIN1( work, pprime, pt[IN], dprime );
			MAT4X3VEC( more_work, tgc->tgc_inv_ScShR, work );
			VADD2( segp->seg_in.hit_point, more_work, tgc->tgc_V );
d626 4
a629 16
			VMOVE( segp->seg_in.hit_normal, norm );

			/* Compute IN hit distance.			*/
			VSUB2( work, segp->seg_in.hit_point, rp->r_pt );
			segp->seg_in.hit_dist = VDOT( work, rp->r_dir );

			/* OUT hit point back to target coord. system.		*/
			VJOIN1( work, pprime, pt[OUT], dprime );
			MAT4X3VEC( more_work, tgc->tgc_inv_ScShR, work );
			VADD2( segp->seg_out.hit_point, more_work, tgc->tgc_V );

			tgcnormal( segp->seg_out.hit_normal, work, tgc );

			/* Compute OUT hit distance.				*/
			VSUB2( work, segp->seg_out.hit_point, rp->r_pt );
			segp->seg_out.hit_dist = VDOT( work, rp->r_dir );
d631 4
a634 4
			/* IN hit point back to target coord. system.	*/
			VJOIN1( work, pprime, pt[OUT], dprime );
			MAT4X3VEC( more_work, tgc->tgc_inv_ScShR, work );
			VADD2( segp->seg_in.hit_point, more_work, tgc->tgc_V );
d636 2
a637 16
			tgcnormal( segp->seg_in.hit_normal, work, tgc );

			/* Compute IN hit distance.			*/
			VSUB2( work, segp->seg_in.hit_point, rp->r_pt );
			segp->seg_in.hit_dist = VDOT( work, rp->r_dir );

			/* OUT hit point back to target coord. system.	*/
			VJOIN1( work, pprime, pt[IN], dprime );
			MAT4X3VEC( more_work, tgc->tgc_inv_ScShR, work );
			VADD2( segp->seg_out.hit_point, more_work, tgc->tgc_V );

			VMOVE( segp->seg_out.hit_normal, norm );

			/* Compute OUT hit distance.			*/
			VSUB2( work, segp->seg_out.hit_point, rp->r_pt );
			segp->seg_out.hit_dist = VDOT( work, rp->r_dir );
d650 1
a650 1
	dir = VDOT( tgc->tgc_norm, rp->r_dir );	/* direc */
d654 4
d664 2
a665 2
	/* alpf = Alpha(work[0], work[1], 1.0, 1.0 ) */
	alf1 = work[0]*work[0] + work[1]*work[1];
d669 1
a669 1
	alf2 = Alpha(work[0],work[1],tgc->tgc_C/tgc->tgc_A,tgc->tgc_D/tgc->tgc_B);
d686 2
a687 4
		/* IN hit point back to target coord. system.		*/
		VJOIN1( work, pprime, b, dprime );
		MAT4X3VEC( more_work, tgc->tgc_inv_ScShR, work );
		VADD2( segp->seg_in.hit_point, more_work, tgc->tgc_V );
d689 2
a690 16
		VREVERSE( segp->seg_in.hit_normal, tgc->tgc_norm );

		/* Compute IN hit distance.				*/
		VSUB2( work, segp->seg_in.hit_point, rp->r_pt );
		segp->seg_in.hit_dist = VDOT( work, rp->r_dir );

		/* OUT hit point back to target coord. system.		*/
		VJOIN1( work, pprime, t, dprime );
		MAT4X3VEC( more_work, tgc->tgc_inv_ScShR, work );
		VADD2( segp->seg_out.hit_point, more_work, tgc->tgc_V );

		VMOVE( segp->seg_out.hit_normal, tgc->tgc_norm );

		/* Compute OUT hit distance.				*/
		VSUB2( work, segp->seg_out.hit_point, rp->r_pt );
		segp->seg_out.hit_dist = VDOT( work, rp->r_dir );
d692 2
a693 4
		/* IN hit point back to target coord. system.		*/
		VJOIN1( work, pprime, t, dprime );
		MAT4X3VEC( more_work, tgc->tgc_inv_ScShR, work );
		VADD2( segp->seg_in.hit_point, more_work, tgc->tgc_V );
d695 2
a696 16
		VMOVE( segp->seg_in.hit_normal, tgc->tgc_norm );

		/* Compute IN hit distance.				*/
		VSUB2( work, segp->seg_in.hit_point, rp->r_pt );
		segp->seg_in.hit_dist = VDOT( work, rp->r_dir );

		/* OUT hit point back to target coord. system.		*/
		VJOIN1( work, pprime, b, dprime );
		MAT4X3VEC( more_work, tgc->tgc_inv_ScShR, work );
		VADD2( segp->seg_out.hit_point, more_work, tgc->tgc_V );

		VREVERSE( segp->seg_out.hit_normal, tgc->tgc_norm );

		/* Compute OUT hit distance.				*/
		VSUB2( work, segp->seg_out.hit_point, rp->r_pt );
		segp->seg_out.hit_dist = VDOT( work, rp->r_dir );
d724 2
a725 1
vect_t		pprime, dprime;
d727 1
a727 1
double		t[];
a730 1
	LOCAL poly	Q, Qsqr;
d732 1
a732 3
	LOCAL poly	T1, T2, T3, sum;
	LOCAL complex	val[MAXP];	/* roots of final equation */
	register int	i, l, npts;
a751 1

d759 1
d763 7
d771 6
a787 4
	}
	if( C.dgr != 0 && C.dgr != 2 && C.dgr != 4 )  {
		fprintf(stderr, "stdCone:  equation is degree %d!\n", C.dgr);
	}
d789 2
a790 8
	/*  Since the equation must be either 2nd or 4th order, the root
	 *  finder should return 2 or 4 roots.  Any other result indicates
	 *  a problem, so return an error value.
	 *
	 *  Oops! The equations can take the form  a = 0, which obviously
	 *  has no solution, so 0 is a valid result.
	 */
	npts = polyRoots( &C , val );
d792 16
a807 9
	/*  Only real roots indicate an intersection in real space.
	 *
	 *  Look at each root returned; if the imaginary part is zero
	 *  or sufficiently close, then use the real part as one value
	 *  of 't' for the intersections
	 */
	for ( l=0, i=0; l < npts; l++ ){
		if ( NEAR_ZERO( val[l].im ) )
			t[i++] = val[l].re;
d809 1
a809 6
	/* Here, 'i' is number of points being returned */
	if ( i != 0 && i != 2 && i != 4 ){
		fprintf(stderr,"stdCone:  reduced %d to %d roots\n",npts,i);
		pr_roots( npts, val );
	}
	return i;
d822 1
a822 2
register double	t[];

d824 1
a824 1
	LOCAL fastf_t	u;
d849 1
a849 1
 *		>>>  t g c n o r m a l ( )  <<<
d883 4
a886 4
HIDDEN void
tgcnormal( norm, hit, tgc )
register vectp_t		norm, hit;
register struct tgc_specific	*tgc;
d888 4
a891 1
	LOCAL fastf_t	Q, parQ, R, parR;
d894 2
a895 2
	R      = 1.0 + tgc->tgc_CA_H * hit[Z];
	parR   = 2.0 * R * tgc->tgc_CA_H;
d897 19
a915 10
	Q      = 1.0 + tgc->tgc_DB_H * hit[Z];
	parQ   = 2.0 * Q * tgc->tgc_DB_H;

	stdnorm[X] = 2.0 * hit[X] * Q * Q;
	stdnorm[Y] = 2.0 * hit[Y] * R * R;
	stdnorm[Z] =  parQ * hit[X] * hit[X] + parR * hit[Y] * hit[Y]
			- R * R * parQ - parR * Q * Q;

	MAT4X3VEC( norm, tgc->tgc_invRtShSc, stdnorm );
	VUNITIZE( norm );
d931 4
@


1.26
log
@Two fixes from Jeff Hanes and Gary Moss.
1)  if A&B or C&D vectors are very close in magnitude,
    CA_H or DB_H values will be very small (e-9), causing first
    coefficient of the 2nd degree poly to be small (e-18),
    which will be discarded by rootfinder, leaving 1 root.
2)  Test for positive K values is only done if there is at least 1 root.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 1.25 85/06/03 17:29:50 mike Exp $ (BRL)";
d29 2
a31 1
#include "vmath.h"
@


1.25
log
@Cleanups to allow compilation on SGI IRIS 2400.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 1.24 85/05/01 16:26:49 mike Exp $ (BRL)";
d115 1
d204 4
d500 1
a500 1
	if( k[0] <= 0.0 )
d782 1
@


1.24
log
@Minor variable shuffling
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 1.23 85/04/23 15:42:21 mike Exp $ (BRL)";
d40 3
a42 2
static void	rotate(), shear(), TgcPtSort();
static void	scale();
a62 2
#define	Alpha(a,x,y,c,d)     {if ( NEAR_ZERO(c) || NEAR_ZERO(d) ) a = VLARGE;\
			else  a = (x)*(x)/((c)*(c)) + (y)*(y)/((d)*(d));}
d64 2
d67 1
d167 4
a170 1
	MAT4X3PNT( tgc->tgc_V, mat, SP_V );
d197 1
a197 1
	rotate( A, B, Hv, Rot, iRot, tgc );
d205 9
a213 9
		Added iShr parameter to shear().
		Added a matrix to tgc_specific for inverse transformation
			of std. solid intersection points (tgc_inv_ScShR)
			which includes a the inverse of a scaling transform.
		Changed inverse transformation of normal vectors of std.
			solid intersection to include shear inverse
			(tgc_invRtShSc).
		Fold in scaling transformation into the transformation to std.
			space from target space (tgc_ScShR).
d215 2
a216 2
	shear( nH, Z, Shr, tShr, iShr );
	scale( tgc->tgc_A, tgc->tgc_B, tgc->tgc_sH, Scl, iScl );
a230 8
#define MINMAX(a,b,c)	{ FAST fastf_t ftemp;\
			if( (ftemp = (c)) < (a) )  a = ftemp;\
			if( ftemp > (b) )  b = ftemp; }

#define MM(v)	MINMAX( stp->st_min[X], stp->st_max[X], v[X] ); \
		MINMAX( stp->st_min[Y], stp->st_max[Y], v[Y] ); \
		MINMAX( stp->st_min[Z], stp->st_max[Z], v[Z] )

d234 4
a237 2
		VADD2( work, temp, B ); MM( work );	/* V + A + B */
		VSUB2( work, temp, B ); MM( work );	/* V + A - B */
d240 4
a243 2
		VADD2( work, temp, B ); MM( work );	/* V - A + B */
		VSUB2( work, temp, B ); MM( work );	/* V - A - B */
d246 4
a249 2
		VADD2( work, temp, D ); MM( work );	/* V + H + C + D */
		VSUB2( work, temp, D ); MM( work );	/* V + H + C - D */
d253 4
a256 2
		VADD2( work, temp, D ); MM( work );	/* V + H - C + D */
		VSUB2( work, temp, D ); MM( work );	/* V + H - C - D */
d293 1
a293 1
rotate( A, B, Hv, Rot, Inv, tgc )
d350 1
a350 1
shear( vect, axis, Shr, Trn, Inv )
d374 1
a374 1
scale( a, b, h, Scl, Inv )
d492 1
a492 1
	TgcPtSort( k, npts );
d568 2
a569 1
		Alpha( alf1, work[0], work[1], 1.0, 1.0 );
d573 1
a573 6
		Alpha(	alf2,
			work[0],
			work[1],
			tgc->tgc_C/tgc->tgc_A,
			tgc->tgc_D/tgc->tgc_B
			);
d655 2
a656 1
	Alpha( alf1, work[0], work[1], 1.0, 1.0 );
d660 1
a660 6
	Alpha(	alf2,
		work[0],
		work[1],
		tgc->tgc_C/tgc->tgc_A,
		tgc->tgc_D/tgc->tgc_B
		);
d840 1
a840 1
TgcPtSort( t, npts )
d924 15
@


1.23
log
@Moss & Davisson version to translate ray to solid coordinate system
before computing intersection, to ease job of rootfinder.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 1.23 85/04/23 15:37:34 mike Exp $ (BRL)";
d442 1
a442 1
	struct seg		*segp;
d453 3
d464 7
a470 11
	/*  start code to normalize distance from tgc. */
	{
		static fastf_t	cor_pprime[3], cor_proj;
		register int		i;
		/* Translating ray origin along direction of ray to closest
		 * pt. to origin of solids coordinate system, new ray origin
		 * is 'cor_pprime'.
		 */
		cor_proj = VDOT( pprime, dprime );
		VSCALE( cor_pprime, dprime, cor_proj );
		VSUB2( cor_pprime, pprime, cor_pprime );
d472 7
a478 7
		npts = stdCone( cor_pprime, dprime, tgc, k );
		/* We must reverse the above translation by adding
		 * the distance to all 'k' values.
		 */
		for( i = 0; i < npts; ++i )
			k[i] -= cor_proj;
	}
@


1.22
log
@Housekeeping
@
text
@d13 1
d25 1
a25 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d29 1
a31 1
#include "../h/db.h"
d41 1
d54 3
a56 2
	mat_t	tgc_ShoR;	/*  Shear( Rot( vect ))			*/
	mat_t	tgc_invRoSh;	/*  invRot( trnShear( vect ))		*/
d85 3
a87 2
	LOCAL mat_t	Rot, Shr;
	LOCAL mat_t	iRot, tShr;
d196 2
a197 2
	tgc->tgc_CA_H = (tgc->tgc_C - tgc->tgc_A) / tgc->tgc_sH;
	tgc->tgc_DB_H = (tgc->tgc_D - tgc->tgc_B) / tgc->tgc_sH;
d199 15
a213 2
	shear( nH, Z, Shr, tShr );
	mat_mul( tgc->tgc_ShoR, Shr, Rot );
d215 2
a216 1
	mat_mul( tgc->tgc_invRoSh, iRot, tShr );
d218 3
d341 2
d345 1
a345 1
shear( vect, axis, Shr, Trn )
d348 1
a348 1
mat_t	Shr, Trn;
d352 1
d355 2
a356 2
		Shr[4] = Trn[1] = -vect[Y]/ vect[X];
		Shr[8] = Trn[2] = -vect[Z]/ vect[X];
d358 2
a359 2
		Shr[1] = Trn[4] = -vect[X]/ vect[Y];
		Shr[9] = Trn[6] = -vect[Z]/ vect[Y];
d361 2
a362 2
		Shr[2] = Trn[8] = -vect[X]/ vect[Z];
		Shr[6] = Trn[9] = -vect[Y]/ vect[Z];
d366 18
d397 4
a400 2
	mat_print( "Sh o R", tgc->tgc_ShoR );
	mat_print( "invR o trnSh", tgc->tgc_invRoSh );
d447 2
d455 1
a455 1
	MAT4X3VEC( dprime, tgc->tgc_ShoR, rp->r_dir );
d459 1
a459 1
	MAT4X3VEC( pprime, tgc->tgc_ShoR, work );
d461 11
a471 1
	npts = stdCone( pprime, dprime, tgc, k );
d473 8
d508 3
a510 1
		if ( zval < tgc->tgc_sH && zval > 0.0 ){
d524 2
a525 2
		VJOIN1(	segp->seg_in.hit_point,
			rp->r_pt, pt[IN], rp->r_dir );
d527 3
a530 1
		segp->seg_in.hit_dist = pt[IN];
d532 5
a536 2
		VJOIN1(	segp->seg_out.hit_point,
			rp->r_pt, pt[OUT], rp->r_dir );
d538 3
d542 5
a546 1
		segp->seg_out.hit_dist = pt[OUT];
d559 2
a560 1
		t = ( tgc->tgc_sH - pprime[Z] )/dprime[Z];
d563 2
a564 1
		Alpha( alf1, work[0], work[1], tgc->tgc_A, tgc->tgc_B );
d567 7
a573 1
		Alpha( alf2, work[0], work[1], tgc->tgc_C, tgc->tgc_D );
d590 4
a593 4
			VJOIN1(	segp->seg_in.hit_point,
				rp->r_pt, pt[IN], rp->r_dir );
			VMOVE(	segp->seg_in.hit_normal, norm );
			segp->seg_in.hit_dist = pt[IN];
d595 7
a601 2
			VJOIN1(	segp->seg_out.hit_point,
				rp->r_pt, pt[OUT], rp->r_dir );
d603 3
d607 4
a610 1
			segp->seg_out.hit_dist = pt[OUT];
d612 1
a612 2
			VJOIN1(	segp->seg_in.hit_point,
				rp->r_pt, pt[OUT], rp->r_dir );
d614 3
a617 1
			segp->seg_in.hit_dist = pt[OUT];
d619 14
a632 4
			VJOIN1(	segp->seg_out.hit_point,
				rp->r_pt, pt[IN], rp->r_dir );
			VMOVE(	segp->seg_out.hit_normal, norm );
			segp->seg_out.hit_dist = pt[IN];
d650 2
a651 1
	t = ( tgc->tgc_sH - pprime[Z] )/dprime[Z];
d654 2
a655 1
	Alpha( alf1, work[0], work[1], tgc->tgc_A, tgc->tgc_B );
d658 7
a664 1
	Alpha( alf2, work[0], work[1], tgc->tgc_C, tgc->tgc_D );
d681 5
a685 1
		VJOIN1(	segp->seg_in.hit_point, rp->r_pt, b, rp->r_dir );
a686 1
		segp->seg_in.hit_dist = b;
d688 9
a696 1
		VJOIN1(	segp->seg_out.hit_point, rp->r_pt, t, rp->r_dir );
d698 4
a701 1
		segp->seg_out.hit_dist = t;
d703 5
a707 1
		VJOIN1(	segp->seg_in.hit_point, rp->r_pt, t, rp->r_dir );
a708 1
		segp->seg_in.hit_dist = t;
d710 9
a718 1
		VJOIN1(	segp->seg_out.hit_point, rp->r_pt, b, rp->r_dir );
d720 4
a723 1
		segp->seg_out.hit_dist = b;
d779 2
a780 1
	R.cf[1] = (pprime[Z] * tgc->tgc_CA_H) + tgc->tgc_A;
d794 2
a795 1
		Q.cf[1] = (pprime[Z] * tgc->tgc_DB_H) + tgc->tgc_B;
d915 1
a915 1
	R      = tgc->tgc_A + tgc->tgc_CA_H * hit[Z];
d918 1
a918 1
	Q      = tgc->tgc_B + tgc->tgc_DB_H * hit[Z];
d926 1
a926 1
	MAT4X3VEC( norm, tgc->tgc_invRoSh, stdnorm );
@


1.21
log
@Fixed incorrect type on tgcnormal().
@
text
@d14 8
a21 3
 * U. S. Army Ballistic Research Laboratory
 * November, 1984
 *
d23 4
d30 1
a30 1
#include "db.h"
@


1.20
log
@Minor efficiency improvements.
@
text
@d29 2
a30 1
static void	rotate(), shear(), TgcPtSort(), tgcnormal();
d752 1
a752 1
LOCAL void
@


1.19
log
@Minor efficiency improvement:
if ray ends at negative K, return SEG_NULL
@
text
@d39 2
d48 5
d153 4
a156 11
	/* If the values of the magnitudes are less than SMALL, they
	 *  may cause glitches in the output (I minimized those as much
	 *  as I could, but was unable to completely remove them).
	 *  To aleviate this, I changed  Mag <= SMALL  to  10*SMALL.
	 *  This will look about the same as 0 and won't produce
	 *  glitches.
	 */
	tgc->tgc_A = NEAR_ZERO( mag_a ) ? 10*SMALL : mag_a;
	tgc->tgc_B = NEAR_ZERO( mag_b ) ? 10*SMALL : mag_b;
	tgc->tgc_C = NEAR_ZERO( mag_c ) ? 10*SMALL : mag_c;
	tgc->tgc_D = NEAR_ZERO( mag_d ) ? 10*SMALL : mag_d;
d165 1
a165 1
		if ( !NEAR_ZERO( tgc->tgc_A ) && !NEAR_ZERO( tgc->tgc_B ) ){
d167 4
d172 2
a173 1
			tgc->tgc_ABsq = tgc->tgc_C/tgc->tgc_D;
a174 1
		tgc->tgc_ABsq *= tgc->tgc_ABsq;		/* (A/B)**2 */
d182 3
d353 2
a425 12
#define	Alpha(a,x,y,c,d)	( a = (x)*(x)/((c)*(c)) + (y)*(y)/((d)*(d)) )

/***	older, safeguarded version of Alpha.  Hopefully, as a
	result of changes to tgc_prep, the safeguards will not
	be needed.  But I'm not throwing this one out yet.

#define VLARGE		1000000.0
#define	Alpha(a,x,y,c,d)     if ( NEAR_ZERO(c) && NEAR_ZERO(d) ) a = VLARGE; \
			else if NEAR_ZERO(c)  a = (y)*(y)/((d)*(d)); \
			else if NEAR_ZERO(d)  a = (x)*(x)/((c)*(c)); \
			else  a = (x)*(x)/((c)*(c)) + (y)*(y)/((d)*(d));
 ***/
d433 1
a433 1
		zval = k[n]*dprime[2] + pprime[2];
d470 2
a471 2
		b = ( -pprime[2] )/dprime[2];
		t = ( tgc->tgc_sH - pprime[2] )/dprime[2];
d531 2
a532 2
	b = ( -pprime[2] )/dprime[2];
	t = ( tgc->tgc_sH - pprime[2] )/dprime[2];
d624 2
a625 5
	R.cf[0] = dprime[Z];
	R.cf[1] = pprime[Z];

	(void) polyScal( &R, ((tgc->tgc_C - tgc->tgc_A)/tgc->tgc_sH) );
	R.cf[1] += tgc->tgc_A;
d638 2
a639 4
		Q.cf[0] = dprime[Z];
		Q.cf[1] = pprime[Z];
		(void)polyScal( &Q, ((tgc->tgc_D - tgc->tgc_B)/tgc->tgc_sH) );
		Q.cf[1] += tgc->tgc_B;
a754 1

a756 1
	LOCAL fastf_t	X_of_Z, Y_of_Z;
d759 2
a760 3
	X_of_Z = (tgc->tgc_C - tgc->tgc_A)/ tgc->tgc_sH;
	R      = tgc->tgc_A + X_of_Z*hit[Z];
	parR   = 2.0*R*X_of_Z;
d762 2
a763 3
	Y_of_Z = (tgc->tgc_D - tgc->tgc_B)/ tgc->tgc_sH;
	Q      = tgc->tgc_B + Y_of_Z*hit[Z];
	parQ   = 2.0*Q*Y_of_Z;
d765 4
a768 4
	stdnorm[X] = 2.0*hit[X]*Q*Q;
	stdnorm[Y] = 2.0*hit[Y]*R*R;
	stdnorm[Z] =  parQ*hit[X]*hit[X] + parR*hit[Y]*hit[Y]
			- R*R*parQ - parR*Q*Q;
@


1.18
log
@Moved some computation into _prep routine;
made various optimizations.
@
text
@d29 1
a29 1
static void	rotate(), shear(), PtSort(), tgcnormal();
d405 1
a405 1
	PtSort( k, npts );
d407 4
d696 1
a696 1
PtSort( t, npts )
@


1.17
log
@Fixed JeffH coding error which discarded additional roots
when trimming off complex roots.
@
text
@d28 1
a28 1
static int	stdCone();
d38 1
d42 1
d158 16
d340 6
d594 1
a594 1
static int
a598 1

d600 7
a606 8
	LOCAL poly		C;	/*  final equation	*/
			/* space to store intermediate polynomials	*/
	LOCAL poly		tfun[3], Xsqr, Ysqr;
	LOCAL poly		Q, Qsqr, R, Rsqr;
	LOCAL poly		T1, T2, T3, sum;
	LOCAL complex		val[MAXP];	/* roots of final equation */
	LOCAL fastf_t		A_B;	/*  eccentricity of bottom ellipse */
	register int		i, l, npts;
d609 2
a610 1
	 *  in 't'.
d612 4
a615 5
	for ( l=0; l < 3; ++l ){
		tfun[l].dgr = 1;
		tfun[l].cf[0] = dprime[l];
		tfun[l].cf[1] = pprime[l];
	}
d617 4
a620 5
	/*  Substitute the resulting linear equations into the cone
	 *  equation.
	 */
	(void) polyMul( &tfun[0], &tfun[0], &Xsqr );
	(void) polyMul( &tfun[1], &tfun[1], &Ysqr );
d622 4
a625 1
	R = tfun[2];
d634 2
a635 7
	if ( ( tgc->tgc_A*tgc->tgc_D ) == ( tgc->tgc_C*tgc->tgc_B ) ){
		if ( !NEAR_ZERO( tgc->tgc_A ) && !NEAR_ZERO( tgc->tgc_B ) ){
			A_B = tgc->tgc_A/tgc->tgc_B;
		} else {
			A_B = tgc->tgc_C/tgc->tgc_D;
		}
		(void) polyScal( &Ysqr, ( A_B*A_B ) );
d639 4
a642 2
		Q = tfun[2];
		(void) polyScal( &Q, ((tgc->tgc_D - tgc->tgc_B)/tgc->tgc_sH) );
d649 2
a650 1
		(void) polySub( polyAdd( &T1, &T2, &sum ), &T3, &C );
d652 3
a677 1
		pr_poly( &C );
@


1.16
log
@Changed MAT3 to MAT4
@
text
@d644 1
a644 2
	 *  of 't' for the intersections, otherwise reduce the number
	 *  of points returned.
d646 1
a646 1
	for ( l=0, i=0; i < npts; ++l ){
a648 2
		else
			--npts;
d650 5
a654 2
	if ( npts != 0 && npts != 2 && npts != 4 ){
		fprintf(stderr,"stdCone:  polyRoots() returned %d real roots\n", npts);
d656 1
a656 1
	return npts;
@


1.15
log
@Minor correction.
@
text
@d77 6
a82 6
	/* Apply 3x3 rotation portion of mat to Hv, A,B,C,D		*/
	MAT3XVEC( Hv, mat, SP_H );
	MAT3XVEC( A, mat, SP_A );
	MAT3XVEC( B, mat, SP_B );
	MAT3XVEC( C, mat, SP_C );
	MAT3XVEC( D, mat, SP_D );
d157 1
a157 1
	MAT3XVEC( nH, Rot, Hv );
d366 1
a366 1
	MAT3XVEC( dprime, tgc->tgc_ShoR, rp->r_dir );
d370 1
a370 1
	MAT3XVEC( pprime, tgc->tgc_ShoR, work );
d754 1
a754 1
	MAT3XVEC( norm, tgc->tgc_invRoSh, stdnorm );
@


1.14
log
@Rewrote code to compute bounding RPPs correctly,
although perhaps slightly too large.
@
text
@a638 4
	if ( npts != 0 && npts != 2 && npts != 4 ){
		fprintf(stderr,"stdCone:  polyRoots() returned %d?\n", npts);
		return (-1);
	}
d652 3
@


1.13
log
@Added LOCAL, fastf_t declarations.
Made shootray() recursive.
@
text
@d165 1
a165 1
	/* Compute bounding sphere */
a169 4
		/* init maxima and minima */
		stp->st_max[X] = stp->st_max[Y] = stp->st_max[Z] = -INFINITY;
		stp->st_min[X] = stp->st_min[Y] = stp->st_min[Z] =  INFINITY;

d178 5
a182 4
		VADD2( work, tgc->tgc_V, A ); MM( work );
		VSUB2( work, tgc->tgc_V, A ); MM( work );
		VADD2( work, tgc->tgc_V, B ); MM( work );
		VSUB2( work, tgc->tgc_V, B ); MM( work );
d184 8
d193 3
a195 4
		VADD2( work, temp, C );  MM( work );
		VSUB2( work, temp, C );  MM( work );
		VADD2( work, temp, D );  MM( work );
		VSUB2( work, temp, D );  MM( work );
@


1.12
log
@General cleanup
@
text
@d61 7
a67 7
	static fastf_t	magsq_h, magsq_a, magsq_b, magsq_c, magsq_d;
	static fastf_t	mag_h, mag_a, mag_b, mag_c, mag_d;
	static mat_t	Rot, Shr;
	static mat_t	iRot, tShr;
	static vect_t	Hv, A, B, C, D;
	static vect_t	nH;
	static vect_t	work;
d167 2
a168 2
		static fastf_t dx, dy, dz;	/* For bounding sphere */
		static vect_t temp;
d233 2
a234 2
	static vect_t	uA, uB, uC;	/*  unit vectors		*/
	static double	mag_ha,		/*  magnitude of H in the	*/
d352 1
a352 1
	static vect_t		pprime,
d356 1
a356 1
	static double		k[4], pt[2],
d359 1
a359 1
	static int		npts, n, intersect;
d573 1
a573 1
	static poly		C;	/*  final equation	*/
d575 5
a579 5
	static poly		tfun[3], Xsqr, Ysqr;
	static poly		Q, Qsqr, R, Rsqr;
	static poly		T1, T2, T3, sum;
	static complex		val[MAXP];	/* roots of final equation */
	static double		A_B;	/*  eccentricity of bottom ellipse */
d669 1
a669 1
	static double	u;
d728 1
a728 1
static void
d734 3
a736 3
	static double	Q, parQ, R, parR;
	static double	X_of_Z, Y_of_Z;
	static vect_t	stdnorm;
@


1.11
log
@struct ray --> struct xray
Bounding RPP
@
text
@d91 1
a91 1
		printf("tgc(%s):  zero length H vector\n", stp->st_name );
d99 1
a99 1
		printf("tgc(%s):  H lies in A-B plane\n",stp->st_name);
d105 1
a105 1
		printf("tgc(%s):  vectors A, C zero length\n", stp->st_name );
d109 1
a109 1
		printf("tgc(%s):  vectors B, D zero length\n", stp->st_name );
d116 1
a116 1
		printf("tgc(%s):  A not perpendicular to B\n",stp->st_name);
d121 1
a121 1
		printf("tgc(%s):  C not perpendicular to D\n",stp->st_name);
d128 1
a128 1
		printf("tgc(%s):  A not parallel to C\n",stp->st_name);
d133 1
a133 1
		printf("tgc(%s):  B not parallel to D\n",stp->st_name);
d310 5
a314 5
	printf( "mag sheared H = %f\n", tgc->tgc_sH );
	printf( "mag A = %f\n", tgc->tgc_A );
	printf( "mag B = %f\n", tgc->tgc_B );
	printf( "mag C = %f\n", tgc->tgc_C );
	printf( "mag D = %f\n", tgc->tgc_D );
d371 1
a371 1
		printf("tgc(%s):  %d intersects != {0,2,4}\n",
d458 1
a458 1
			printf("tgc(%s):  only 1 intersect\n", stp->st_name);
d636 1
a636 1
		printf("stdCone:  polyRoots() returned %d?\n", npts);
@


1.10
log
@Working version from JeffH.
@
text
@d20 1
a20 1
#include "ray.h"
d22 1
a166 2
		static fastf_t xmax, ymax, zmax;/* For bounding sphere */
		static fastf_t xmin, ymin, zmin;/* For bounding sphere */
d171 2
a172 2
		xmax = ymax = zmax = -INFINITY;
		xmin = ymin = zmin =  INFINITY;
d178 3
a180 3
#define MM(v)	MINMAX( xmin, xmax, v[X] ); \
		MINMAX( ymin, ymax, v[Y] ); \
		MINMAX( zmin, zmax, v[Z] )
d194 3
a196 1
			(xmax + xmin)/2, (ymax + ymin)/2, (zmax + zmin)/2 );
d198 3
a200 3
		dx = (xmax - xmin)/2;
		dy = (ymax - ymin)/2;
		dz = (zmax - zmin)/2;
d347 1
a347 1
register struct ray	*rp;
a380 2
	GET_SEG( segp );
	segp->seg_stp = stp;
d417 2
d430 3
a432 1
	} else if ( intersect == 1 ){
d462 2
d487 2
a488 12
	} else {
		/*  If all conic interections lie outside the plane,
		 *  then check to see whether there are two planar
		 *  intersections inside the governing ellipses.
		 *
		 *  But first, if the direction is parallel (or nearly
		 *  so) to the planes, it (obviously) won't intersect
		 *  either of them.
		 */
		dir = VDOT( tgc->tgc_norm, rp->r_dir );	/* direc */
		if ( NEAR_ZERO( dir ) )
			return( SEG_NULL );
d490 11
a500 2
		b = ( -pprime[2] )/dprime[2];
		t = ( tgc->tgc_sH - pprime[2] )/dprime[2];
d502 2
a503 2
		VJOIN1( work, pprime, b, dprime );
		Alpha( alf1, work[0], work[1], tgc->tgc_A, tgc->tgc_B );
d505 2
a506 2
		VJOIN1( work, pprime, t, dprime );
		Alpha( alf2, work[0], work[1], tgc->tgc_C, tgc->tgc_D );
d508 2
a509 6
		/*  It should not be possible for one planar intersection
		 *  to be outside its ellipse while the other is inside ...
		 *  but I wouldn't take any chances.
		 */
		if ( alf1 > 1.0 || alf2 > 1.0 )
			return( SEG_NULL );
d511 6
a516 9
		/*  Use the dot product (found earlier) of the plane
		 *  normal with the direction vector to determine the
		 *  orientation of the intersections.
		 */
		if ( dir > 0.0 ){
			VJOIN1(	segp->seg_in.hit_point,
				rp->r_pt, b, rp->r_dir );
			VREVERSE( segp->seg_in.hit_normal, tgc->tgc_norm );
			segp->seg_in.hit_dist = b;
d518 2
a519 9
			VJOIN1(	segp->seg_out.hit_point,
				rp->r_pt, t, rp->r_dir );
			VMOVE( segp->seg_out.hit_normal, tgc->tgc_norm );
			segp->seg_out.hit_dist = t;
		} else {
			VJOIN1(	segp->seg_in.hit_point,
				rp->r_pt, t, rp->r_dir );
			VMOVE( segp->seg_in.hit_normal, tgc->tgc_norm );
			segp->seg_in.hit_dist = t;
d521 20
a540 5
			VJOIN1(	segp->seg_out.hit_point,
				rp->r_pt, b, rp->r_dir );
			VREVERSE( segp->seg_out.hit_normal, tgc->tgc_norm );
			segp->seg_out.hit_dist = b;
		}
@


1.9
log
@This version has a problem with clipping of the ends,
but basicly works.
@
text
@d362 2
d369 3
a371 1
	if ( npts <= 0)
a372 4

	if ( npts != 2 && npts != 4 ){
		printf("tgc(%s):  %d intersects != {2,4}\n", stp->st_name, npts );
		return( SEG_NULL );			/* No hit	*/
d438 1
a438 1
		b = ( pprime[2] )/dprime[2];
d447 1
a447 1
		if ( alf1 <=  1.0 ){
d455 1
d495 1
a495 1
		b = ( pprime[2] )/dprime[2];
@


1.8
log
@Latest version of TGC from Jeff H.
@
text
@d30 1
a30 1
struct  tgc_specific{
d64 1
a64 1
	static vect_t	H, A, B, C, D;
d77 1
a77 1
	MAT3XVEC( H, mat, SP_H );
d84 1
a84 1
	mag_h = sqrt( magsq_h = MAGSQ( H ) );
d96 1
a96 1
	f = VDOT( H, work )/ ( mag_a*mag_b*mag_h );
d136 2
a137 2
	/* solid is OK, compute constant terms, etc.			*/
	GETSRUCT( tgc, tgc_specific );
d140 2
a141 4
	/* Apply full 4X4mat to V					*/
	VMOVE( work, SP_V );
	work[3] = 1;
	matXvec( tgc->tgc_V, mat, work );
d155 2
a156 2
	rotate( A, B, H, Rot, iRot, tgc );
	MAT3XVEC( nH, Rot, H );
d163 39
d227 3
a229 3
rotate( A, B, H, Rot, Inv, tgc )
vect_t		A, B, H;
mat_t		*Rot, *Inv;
a230 1

d237 1
a237 1
	uA = A;
d239 1
a239 1
	uB = B;
d243 1
a243 1
	mag_ha = VDOT( H, uA );
d245 1
a245 1
	mag_hb = VDOT( H, uB );
d250 1
a250 1
	VJOIN2( uC, H, -mag_ha, uA, -mag_hb, uB );
d283 1
a283 1
vect_t	*vect;
d285 1
a285 2
mat_t	*Shr, *Trn;

d316 1
a316 1
	mat_print( "invR o trnSh", tgc->invRoSh );
d350 1
d490 1
a490 1
		dir = VDOT( tgc->tgc_norm, direc );
@


1.7
log
@Lint corrections
@
text
@d8 1
a8 2
 *	TGC:  unknown
 *	REC:  a (common) special case, much easier.
d12 1
a12 1
 *	Michael John Muuss	(Programming)
d15 1
a15 1
 * April 26, 1984
a16 1
 * $Revision: 1.6 $
a17 4
#ifndef lint
static char RCSid[] = "@@(#)$Header: tgc.c,v 1.6 84/09/06 03:59:02 mike Exp $ (BRL)";
#endif

d23 3
a25 4
/* Define vector elements */
#define X	0
#define Y	1
#define Z	2
d27 2
a28 6
struct rec_specific {
	vect_t	rec_V;		/* Vector to center of base of cylinder  */
	vect_t	rec_Hunit;	/* Unit H vector */
	mat_t	rec_SoR;	/* Scale(Rot(vect)) */
	mat_t	rec_invRoS;	/* invRot(Scale(vect)) */
};
d30 10
a39 5
struct tgc_specific {
	/* Entirely unknown */
	vect_t	tgc_V;		/* Vector to center of base of TGC */
	mat_t	tgc_SoR;	/* Scale(Rot(vect)) */
	mat_t	tgc_invRSSR;	/* invRot(Scale(Scale(Rot(vect)))) */
a41 6
#define SP_V	&vec[0*ELEMENTS_PER_VECT]
#define SP_H	&vec[1*ELEMENTS_PER_VECT]
#define SP_A	&vec[2*ELEMENTS_PER_VECT]
#define SP_B	&vec[3*ELEMENTS_PER_VECT]
#define SP_C	&vec[4*ELEMENTS_PER_VECT]
#define SP_D	&vec[5*ELEMENTS_PER_VECT]
a42 4
#define MINMAX(a,b,c)	{ FAST fastf_t ftemp;\
			if( (ftemp = (c)) < (a) )  a = ftemp;\
			if( ftemp > (b) )  b = ftemp; }

d44 9
a52 15
 *  			T G C _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid TGC, or perhaps the simpler REC,
 *  and if so, precompute various terms of the formulas.
 *  
 *  Returns -
 *  	0	TGC is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct rec_specific or tgc_specific is created,
 *	and it's address is stored in
 *  	stp->st_specific for use by rec_shot() or tgc_shot().
 *	If the TGC is really an REC, stp->st_id is modified to ID_REC.
d59 7
a65 8
	register struct rec_specific *rec;
	static double	magsq_h, magsq_a, magsq_b, magsq_c, magsq_d;
	static double	mag_h, mag_a, mag_b, mag_c, mag_d;
	static mat_t	R;
	static mat_t	Rinv;
	static mat_t	S;
	static vect_t	Hv, A, B, C, D;
	static vect_t	invsq;	/* [ 1/(|A|**2), 1/(|B|**2), 1/(|Hv|**2) ] */
d67 1
a67 2
	static vect_t	temp;
	static fastf_t	f;
d69 9
a77 2
	/* Apply 3x3 rotation portion of mat to Hv, A,B,C,D */
	MAT3XVEC( Hv, mat, SP_H );
d83 2
a84 2
	/* Validate that |H| > 0, compute |A| |B| |C| |D| */
	mag_h = sqrt( magsq_h = MAGSQ( Hv ) );
d89 1
a89 1
	if( NEAR_ZERO(magsq_h) )  {
d94 19
a112 1
	/* Validate that A.B == 0, C.D == 0 */
d114 1
a114 1
	if( ! NEAR_ZERO(f) )  {
d119 1
a119 1
	if( ! NEAR_ZERO(f) )  {
d124 11
a134 4
	/*
	 *  See if this TGC is an REC.  If so, much simpler formulas can
	 *  be used, so we will treat it as a separate case.
	 */
d136 3
a138 7
	/* Check for H.A == 0 and H.B == 0 */
	f = VDOT( Hv, A ) / (mag_h * mag_a);
	if( ! NEAR_ZERO(f) )
		goto hard;
	f = VDOT( Hv, B ) / (mag_h * mag_b);
	if( ! NEAR_ZERO(f) )
		goto hard;
d140 4
a143 3
	/* Check for |A| > 0, |B| > 0 */
	if( NEAR_ZERO(mag_a) || NEAR_ZERO(mag_b) )
		goto hard;
d145 6
a150 12
	/* Make sure that A == C, B == D */
	VSUB2( work, A, C );
	f = MAGSQ( work );
	if( ! NEAR_ZERO(f) )
		goto hard;
	VSUB2( work, B, D );
	f = MAGSQ( work );
	if( ! NEAR_ZERO(f) )
		goto hard;

	/*
	 *  This TGC is really an REC;  use simpler formulas.
d152 4
a155 1
	stp->st_id = ID_REC;		/* "fix" soltab ID */
d157 3
a159 2
	GETSTRUCT( rec, rec_specific );
	stp->st_specific = (int *)rec;
d161 2
a162 2
	VMOVE( rec->rec_Hunit, Hv );
	VUNITIZE( rec->rec_Hunit );
d164 3
a166 1
	MAT4X3VEC( rec->rec_V, mat, SP_V );
a167 1
	VSET( invsq, 1.0/magsq_a, 1.0/magsq_b, 1.0/magsq_h );
d169 25
a193 9
	/* Compute R and Rinv matrices */
	mat_zero( R );
	f = 1.0/mag_a;
	VSCALE( &R[0], A, f );
	f = 1.0/mag_b;
	VSCALE( &R[4], B, f );
	f = 1.0/mag_h;
	VSCALE( &R[8], Hv, f );
	mat_trn( Rinv, R );			/* inv of rot mat is trn */
d195 4
a198 5
	/* Compute S.  Uses 3x3 of the 4x4 matrix */
	mat_zero( S );
	S[ 0] = sqrt( invsq[0] );
	S[ 5] = sqrt( invsq[1] );
	S[10] = sqrt( invsq[2] );
d200 5
a204 2
	/* Compute invRoS */
	mat_mul( rec->rec_invRoS, Rinv, S );
d206 4
a209 5
	/* Compute SoR */
	mat_zero( rec->rec_SoR );
	VSCALE( &rec->rec_SoR[0], A, invsq[0] );
	VSCALE( &rec->rec_SoR[4], B, invsq[1] );
	VSCALE( &rec->rec_SoR[8], Hv, invsq[2] );
d211 6
a216 4
	{
		static fastf_t xmax, ymax, zmax;/* For bounding sphere */
		static fastf_t xmin, ymin, zmin;/* For bounding sphere */
		static fastf_t dx, dy, dz;	/* For bounding sphere */
d218 2
a219 3
		/* init maxima and minima */
		xmax = ymax = zmax = -INFINITY;
		xmin = ymin = zmin =  INFINITY;
d221 3
a223 4
		/* Compute bounding sphere */
#define MM(v)	MINMAX( xmin, xmax, v[X] ); \
		MINMAX( ymin, ymax, v[Y] ); \
		MINMAX( zmin, zmax, v[Z] )
d225 3
a227 4
		VADD2( work, rec->rec_V, A ); MM( work );
		VSUB2( work, rec->rec_V, A ); MM( work );
		VADD2( work, rec->rec_V, B ); MM( work );
		VSUB2( work, rec->rec_V, B ); MM( work );
d229 4
a232 5
		VADD2( temp, rec->rec_V, Hv );
		VADD2( work, temp, A );  MM( work );
		VSUB2( work, temp, A );  MM( work );
		VADD2( work, temp, B );  MM( work );
		VSUB2( work, temp, B );  MM( work );
d234 16
a249 2
		VSET( stp->st_center,
			(xmax + xmin)/2, (ymax + ymin)/2, (zmax + zmin)/2 );
d251 13
a263 4
		dx = (xmax - xmin)/2;
		dy = (ymax - ymin)/2;
		dz = (zmax - zmin)/2;
		stp->st_radsq = dx*dx + dy*dy + dz*dz;
a264 14
	return(0);			/* OK */

	/*
	 *  This TGC is not an REC;  use completely general forumlas.
	 */
hard:
	printf("tgc(%s):  too hard\n", stp->st_name );
	return(1);		/* BAD */

#ifdef later
	/* Solid is OK, compute constant terms now */
	GETSTRUCT( tgc, tgc_specific );
	stp->st_specific = (int *)tgc;
#endif
a266 3
/*
 *  			T G C _ P R I N T
 */
d268 1
a268 1
register struct soltab *stp;
d270 1
a270 1
	register struct tgc_specific *tgc =
d273 9
a281 2
	VPRINT("V", tgc->tgc_V);
	mat_print("S o R", tgc->tgc_SoR );
d285 22
a306 9
 *  			T G C _ S H O T
 *  
 *  Intersect a ray with an ellipsoid, where all constant terms have
 *  been precomputed by tgc_prep().  If an intersection occurs,
 *  a struct seg will be acquired and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *  	segp	HIT
d310 2
a311 2
struct soltab *stp;
register struct ray *rp;
d313 1
a313 1
	register struct tgc_specific *tgc =
d315 8
a322 1
	register struct seg *segp;
d324 177
a500 2
	printf("tgc_shot(%s):  unimplemented\n", stp->st_name );
	return( SEG_NULL );
d505 1
a505 1
 *			Right Eliptical Cylinder
d507 6
a512 40
 * Algorithm:
 *  
 *  Given V, H, A, and B, there is a set of points on this cylinder
 *  
 *  { (x,y,z) | (x,y,z) is on cylinder }
 *  
 *  Through a series of Affine Transformations, this set of points will be
 *  transformed into a set of points on a unit cylinder located at the origin
 *  with a radius of 1, and a height of +1 along the +Z axis.
 *  
 *  { (x',y',z') | (x',y',z') is on cylinder at origin }
 *  
 *  The transformation from X to X' is accomplished by:
 *  
 *  X' = S(R( X - V ))
 *  
 *  where R(X) =  ( A/(|A|) )
 *  		 (  B/(|B|)  ) . X
 *  		  ( H/(|H|) )
 *  
 *  and S(X) =	 (  1/|A|   0     0   )
 *  		(    0    1/|B|   0    ) . X
 *  		 (   0      0   1/|H| )
 *  
 *  To find the intersection of a line with the surface of the cylinder,
 *  consider the parametric line L:
 *  
 *  	L : { P(n) | P + t(n) . D }
 *  
 *  Call W the actual point of intersection between L and the cylinder.
 *  Let W' be the point of intersection between L' and the unit cylinder.
 *  
 *  	L' : { P'(n) | P' + t(n) . D' }
 *  
 *  W = invR( invS( W' ) ) + V
 *  
 *  Where W' = k D' + P'.
 *  
 *  If Dx' and Dy' are both 0, then there is no hit on the cylinder;
 *  but the end plates need checking.
d514 1
a514 1
 *  Line L' hits the infinitely tall unit cylinder at W' when
d516 1
a516 1
 *	k**2 + b * k + c = 0
d518 2
a519 1
 *  where
d521 2
a522 55
 *  b = 2 * ( Dx' * Px' + Dy' * Py' ) / ( Dx'**2 + Dy'**2 )
 *  c = ( ( Px'**2 + Py'**2 ) - r**2 ) / ( Dx'**2 + Dy'**2 )
 *  r = 1.0
 *  
 *  The qudratic formula yields k (which is constant):
 *
 *  k = [ -b +/- sqrt( b**2 - 4 * c ] / 2.0
 *  
 *  Now, D' = S( R( D ) )
 *  and  P' = S( R( P - V ) )
 *  
 *  Substituting,
 *  
 *  W = V + invR( invS[ k *( S( R( D ) ) ) + S( R( P - V ) ) ] )
 *    = V + invR( ( k * R( D ) ) + R( P - V ) )
 *    = V + k * D + P - V
 *    = k * D + P
 *  
 *  Note that ``k'' is constant, and is the same in the formulations
 *  for both W and W'.
 *
 *  The hit at ``k'' is a hit on the height=1 unit cylinder IFF
 *  0 <= Wz' <= 1.
 *  
 *  NORMALS.  Given the point W on the surface of the cylinder,
 *  what is the vector normal to the tangent plane at that point?
 *  
 *  Map W onto the unit cylinder, ie:  W' = S( R( W - V ) ).
 *  
 *  Plane on unit cylinder at W' has a normal vector N' of the same value
 *  as W' in x and y, with z set to zero, ie, (Wx', Wy', 0)
 *  
 *  The plane transforms back to the tangent plane at W, and this
 *  new plane (on the original cylinder) has a normal vector of N, viz:
 *  
 *  N = inverse[ transpose(invR o invS) ] ( N' )
 *    = inverse[ transpose(invS) o transpose(invR) ] ( N' )
 *    = inverse[ inverse(S) o R ] ( N' )
 *    = invR o S ( N' )
 *
 *  Note that the normal vector produced above will not have unit length.
 *
 *  THE END PLATES.
 *
 *  If Dz' == 0, line L' is parallel to the end plates, so there is no hit.
 *
 *  Otherwise, the line L' hits the bottom plate with k = (0 - Pz') / Dz',
 *  and hits the top plate with k = (1 - Pz') / Dz'.
 *
 *  The solution W' is within the end plate IFF
 *
 *	Wx'**2 + Wy'**2 <= 1.0
 *
 *  The normal for a hit on the bottom plate is -Hunit, and
 *  the normal for a hit on the top plate is +Hunit.
d524 5
a529 5
/*
 *  			R E C _ P R I N T
 */
rec_print( stp )
register struct soltab *stp;
d531 8
a538 2
	register struct rec_specific *rec =
		(struct rec_specific *)stp->st_specific;
d540 8
a547 5
	VPRINT("V", rec->rec_V);
	VPRINT("Hunit", rec->rec_Hunit);
	mat_print("S o R", rec->rec_SoR );
	mat_print("invR o S", rec->rec_invRoS );
}
d549 5
a553 30
/*
 *  			R E C _ S H O T
 *  
 *  Intersect a ray with a right elliptical cylinder,
 *  where all constant terms have
 *  been precomputed by rec_prep().  If an intersection occurs,
 *  a struct seg will be acquired and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *  	segp	HIT
 */
struct seg *
rec_shot( stp, rp )
struct soltab *stp;
register struct ray *rp;
{
	register struct rec_specific *rec =
		(struct rec_specific *)stp->st_specific;
	register struct seg *segp;
	static vect_t	dprime;		/* D' */
	static vect_t	pprime;		/* P' */
	static fastf_t	dx2dy2;		/* 1/(D'[x]**2 + D'[y]**2) */
	static fastf_t	b, c;		/* coeff of polynomial */
	static fastf_t	root;		/* root of radical */
	static fastf_t	k1, k2;		/* distance constants of solution */
	static vect_t	xlated;		/* translated vector */
	static point_t	point;		/* hit point */
	static struct hit hits[4];	/* 4 potential hit points */
	register struct hit *hitp;	/* pointer to hit point */
d555 4
a558 2
	hitp = &hits[0];
	/* ASSERT that MAGNITUDE(rp->r_dir) == 1 */
d560 18
a577 4
	/* out, Mat, vect */
	MAT3XVEC( dprime, rec->rec_SoR, rp->r_dir );
	VSUB2( xlated, rp->r_pt, rec->rec_V );
	MAT3XVEC( pprime, rec->rec_SoR, xlated );
d579 5
a583 2
	if( NEAR_ZERO(dprime[X]) && NEAR_ZERO(dprime[Y]) )
		goto check_plates;
d585 6
a590 16
	dx2dy2 = 1.0 / (dprime[X] * dprime[X] + dprime[Y] * dprime[Y]);
	b = 2 * ( dprime[X] * pprime[X] + dprime[Y] * pprime[Y] ) * dx2dy2;
	c = ( (pprime[X] * pprime[X] + pprime[Y] * pprime[Y]) - 1.0) * dx2dy2;

	root = b*b - ( 4 * c );			/* a == 1 */
	if( root < 0 )
		goto check_plates;
	root = sqrt(root);

	k1 = (-b + root) * 0.5;
	k2 = (-b - root) * 0.5;

	/*
	 * k1 and k2 are potential solutions to intersection with
	 * side, in no particular order.
	 *  Compute exact intersection points, and surface normal.
d592 4
a595 7
	VJOIN1( point, pprime, k1, dprime );		/* hit' */
	if( point[Z] >= 0.0 && point[Z] <= 1.0 ) {
		hitp->hit_dist = k1;
		VJOIN1( hitp->hit_point, rp->r_pt, k1, rp->r_dir );
		MAT3XVEC( hitp->hit_normal, rec->rec_invRoS, point );
		VUNITIZE( hitp->hit_normal );
		hitp++;
d598 12
a609 7
	VJOIN1( point, pprime, k2, dprime );		/* hit' */
	if( point[Z] >= 0.0 && point[Z] <= 1.0 )  {
		hitp->hit_dist = k2;
		VJOIN1( hitp->hit_point, rp->r_pt, k2, rp->r_dir );
		MAT3XVEC( hitp->hit_normal, rec->rec_invRoS, point );
		VUNITIZE( hitp->hit_normal );
		hitp++;
d611 2
a613 8
	/*
	 * Check for hitting the end plates.
	 */
check_plates:
	if( hitp < &hits[2]  &&  !NEAR_ZERO(dprime[Z]) )  {
		/* 0 or 1 hits so far, this is worthwhile */
		k1 = -pprime[Z] / dprime[Z];		/* bottom plate */
		k2 = (1.0 - pprime[Z]) / dprime[Z];	/* top plate */
d615 10
a624 7
		VJOIN1( point, pprime, k1, dprime );		/* hit' */
		if( point[X] * point[X] + point[Y] * point[Y] <= 1.0 )  {
			hitp->hit_dist = k1;
			VJOIN1( hitp->hit_point, rp->r_pt, k1, rp->r_dir );
			VREVERSE( hitp->hit_normal, rec->rec_Hunit ); /* -H */
			hitp++;
		}
d626 8
a633 6
		VJOIN1( point, pprime, k2, dprime );		/* hit' */
		if( point[X] * point[X] + point[Y] * point[Y] <= 1.0 )  {
			hitp->hit_dist = k2;
			VJOIN1( hitp->hit_point, rp->r_pt, k2, rp->r_dir );
			VMOVE( hitp->hit_normal, rec->rec_Hunit ); /* H */
			hitp++;
d635 1
a636 2
	if( hitp == &hits[0] )
		return(SEG_NULL);	/* MISS */
d638 4
a641 7
	if( hitp != &hits[2] )  {
		static struct hit *hp;	/* XXX */
		printf("ERROR: rec(%s):  %d hits??\n", stp->st_name,
			(&hits[0] - hitp) / sizeof(struct hit)   );
		for( hp = &hits[0]; hp < hitp; hp++ )
			hit_print( "?hit?", hp );
		return(SEG_NULL);	/* MISS */
d643 4
a646 11
	GET_SEG(segp);
	segp->seg_stp = stp;
	segp->seg_flag = SEG_IN|SEG_OUT;
	if( hits[0].hit_dist < hits[1].hit_dist )  {
		/* entry is [0], exit is [1] */
		segp->seg_in = hits[0];		/* struct copy */
		segp->seg_out = hits[1];	/* struct copy */
	} else {
		/* entry is [1], exit is [0] */
		segp->seg_in = hits[1];		/* struct copy */
		segp->seg_out = hits[0];	/* struct copy */
d648 63
a710 1
	return(segp);			/* HIT */
@


1.6
log
@Fixed conflict with symbol "H"
@
text
@d18 1
a18 1
 * $Revision: 1.5 $
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 1.5 84/05/04 09:15:33 mike Exp $ (BRL)";
d161 1
a161 4
	/* Apply full 4x4mat to V. */
	VMOVE( work, SP_V );
	work[3] = 1;
	matXvec( rec->rec_V, mat, work );
d458 1
a458 1
	VCOMPOSE1( point, pprime, k1, dprime );		/* hit' */
d461 1
a461 1
		VCOMPOSE1( hitp->hit_point, rp->r_pt, k1, rp->r_dir );
d467 1
a467 1
	VCOMPOSE1( point, pprime, k2, dprime );		/* hit' */
d470 1
a470 1
		VCOMPOSE1( hitp->hit_point, rp->r_pt, k2, rp->r_dir );
d485 1
a485 1
		VCOMPOSE1( point, pprime, k1, dprime );		/* hit' */
d488 1
a488 1
			VCOMPOSE1( hitp->hit_point, rp->r_pt, k1, rp->r_dir );
d493 1
a493 1
		VCOMPOSE1( point, pprime, k2, dprime );		/* hit' */
d496 1
a496 1
			VCOMPOSE1( hitp->hit_point, rp->r_pt, k2, rp->r_dir );
@


1.5
log
@Minor hacks
@
text
@d18 1
a18 1
 * $Revision: 1.4 $
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 1.4 84/05/03 06:55:24 mike Exp $ (BRL)";
d87 2
a88 2
	static vect_t	H, A, B, C, D;
	static vect_t	invsq;	/* [ 1/(|A|**2), 1/(|B|**2), 1/(|H|**2) ] */
d93 2
a94 2
	/* Apply 3x3 rotation portion of mat to H, A,B,C,D */
	MAT3XVEC( H, mat, SP_H );
d101 1
a101 1
	mag_h = sqrt( magsq_h = MAGSQ( H ) );
d129 1
a129 1
	f = VDOT( H, A ) / (mag_h * mag_a);
d132 1
a132 1
	f = VDOT( H, B ) / (mag_h * mag_b);
d158 1
a158 1
	VMOVE( rec->rec_Hunit, H );
d175 1
a175 1
	VSCALE( &R[8], H, f );
d191 1
a191 1
	VSCALE( &rec->rec_SoR[8], H, invsq[2] );
d212 1
a212 1
		VADD2( temp, rec->rec_V, H );
@


1.4
log
@Performance enhancements, ARS fixes.
@
text
@d18 1
a18 1
 * $Revision: 1.3 $
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 1.3 84/05/02 05:10:18 mike Exp $ (BRL)";
d170 1
a170 1
	f = 1.0/sqrt(magsq_a);
d172 1
a172 1
	f = 1.0/sqrt(magsq_b);
d174 1
a174 1
	f = 1.0/sqrt(magsq_h);
@


1.3
log
@More ARS support, fixes of all kinds.
@
text
@d18 1
a18 1
 * $Revision: 1.2 $
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 1.2 84/05/01 06:39:59 mike Exp $ (BRL)";
d83 1
d101 5
a105 5
	magsq_h = MAGSQ( H );
	magsq_a = MAGSQ( A );
	magsq_b = MAGSQ( B );
	magsq_c = MAGSQ( C );
	magsq_d = MAGSQ( D );
d112 1
a112 1
	f = VDOT( A, B );
d117 1
a117 1
	f = VDOT( C, D );
d129 1
a129 1
	f = VDOT( H, A );
d132 1
a132 1
	f = VDOT( H, B );
d137 1
a137 1
	if( NEAR_ZERO(magsq_a) || NEAR_ZERO(magsq_b) )
@


1.2
log
@Modifications for ARS, code unified to use fastf_t
@
text
@d18 1
a18 1
 * $Revision: 1.1 $
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tgc.c,v 1.1 84/04/28 02:42:21 mike Exp $ (BRL)";
d160 1
a160 1
	/* Apply full 4x4mat to V.  No need for htov_vec, as [15]==0. */
d162 1
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
 * $Revision$
d21 1
a21 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d48 6
a53 6
#define SP_V	&sp->s_values[0]
#define SP_H	&sp->s_values[3]
#define SP_A	&sp->s_values[6]
#define SP_B	&sp->s_values[9]
#define SP_C	&sp->s_values[12]
#define SP_D	&sp->s_values[15]
d55 1
a55 1
#define MINMAX(a,b,c)	{ static float ftemp;\
d76 2
a77 2
tgc_prep( sp, stp, mat )
register struct solidrec *sp;
d86 1
a86 1
	static vect_t	H, V, A, B, C, D;
d90 1
a90 1
	static double	f;
d161 1
a161 1
	VMOVE( work, SP_V );		/* float to fastf_t */
d205 4
a208 4
		VADD2( work, V, A ); MM( work );
		VSUB2( work, V, A ); MM( work );
		VADD2( work, V, B ); MM( work );
		VSUB2( work, V, B ); MM( work );
d210 1
a210 1
		VADD2( temp, V, H );
@
