head	11.31;
access;
symbols
	ansi-20040405-merged:11.26.2.2
	postmerge-20040405-ansi:11.29
	premerge-20040404-ansi:11.28
	postmerge-autoconf:11.28
	autoconf-freeze:11.26.10.3
	premerge-autoconf:11.28
	ansi-20040316-freeze:11.26.2.1
	postmerge-20040315-windows:11.28
	premerge-20040315-windows:11.27
	windows-20040315-freeze:11.26.4.2
	autoconf-20031203:11.26
	autoconf-20031202:11.26
	autoconf-branch:11.26.0.10
	phong-branch:11.26.0.8
	photonmap-branch:11.26.0.6
	rel-6-1-DP:11.26
	windows-branch:11.26.0.4
	rel-6-0-2:11.24
	ansi-branch:11.26.0.2
	rel-6-0-1-branch:11.24.0.2
	hartley-6-0-post:11.25
	hartley-6-0-pre:11.24
	rel-6-0-1:11.24
	rel-6-0:11.24
	rel-5-4:11.13
	offsite-5-3-pre:11.18
	rel-5-3:11.13
	rel-5-2:11.13
	rel-5-1-branch:11.13.0.2
	rel-5-1:11.13
	rel-5-0:11.8
	rel-5-0-beta:11.7
	rel-4-5:11.6
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.31
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.30;

11.30
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.29;

11.29
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2004.03.16.20.03.09;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2004.02.02.17.39.22;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2002.08.20.17.08.02;	author jra;	state Exp;
branches
	11.26.2.1
	11.26.4.1
	11.26.10.1;
next	11.25;

11.25
date	2002.08.15.20.55.13;	author hartley;	state Exp;
branches;
next	11.24;

11.24
date	2001.10.02.19.24.30;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	2001.05.17.20.05.25;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2001.04.30.19.23.00;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	2001.04.20.22.29.48;	author morrison;	state Exp;
branches;
next	11.20;

11.20
date	2001.04.02.21.38.09;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2001.03.31.01.57.10;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2000.08.21.02.02.31;	author butler;	state Exp;
branches;
next	11.17;

11.17
date	2000.07.10.23.01.37;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.06.30.20.03.46;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	2000.06.30.15.38.04;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.06.30.15.31.15;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.04.12.02.34.37;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	99.11.26.21.46.50;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.11.24.23.12.10;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.11.24.21.44.29;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.11.17.02.42.03;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.07.02.22.19.24;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.05.27.19.10.43;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.12.16.00.13.37;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	96.12.19.14.03.00;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.12.17.19.05.26;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	96.08.31.11.04.24;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.08.29.22.51.38;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.09;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.10.11.08.19.30;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	94.09.23.15.49.26;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	94.08.10.18.41.37;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.07.20.15.35.10;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.28;	author mike;	state Rel4_0;
branches;
next	1.23;

1.23
date	91.09.20.23.35.45;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	91.08.29.22.20.40;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	91.07.05.23.40.22;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	91.06.30.00.09.00;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	91.06.22.22.30.43;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	91.06.14.06.48.35;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	91.05.18.03.01.46;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	91.02.17.20.05.01;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	91.01.28.23.53.24;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	91.01.26.03.15.04;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	91.01.25.21.19.23;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	91.01.25.20.23.24;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	91.01.05.03.08.38;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	90.12.21.21.00.46;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	90.12.21.14.38.16;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	90.12.18.00.20.33;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	90.12.05.20.30.03;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	90.10.15.12.01.07;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	90.10.06.02.05.28;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	90.03.14.15.06.12;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.12.29.21.30.54;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.12.29.21.23.09;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.10.13.20.36.22;	author mike;	state Exp;
branches;
next	;

11.26.2.1
date	2002.09.19.18.01.37;	author morrison;	state Exp;
branches;
next	11.26.2.2;

11.26.2.2
date	2004.03.17.21.18.48;	author morrison;	state Exp;
branches;
next	;

11.26.4.1
date	2002.09.26.23.04.02;	author morrison;	state Exp;
branches;
next	11.26.4.2;

11.26.4.2
date	2004.03.11.23.43.39;	author morrison;	state Exp;
branches;
next	;

11.26.10.1
date	2004.02.12.18.37.42;	author erikg;	state Exp;
branches;
next	11.26.10.2;

11.26.10.2
date	2004.03.15.14.07.23;	author erikg;	state Exp;
branches;
next	11.26.10.3;

11.26.10.3
date	2004.03.18.18.10.29;	author erikg;	state Exp;
branches;
next	;


desc
@LIBRT Geometry module for ray-tracing 3-D volumes.
@


11.31
log
@moved to src/
@
text
@/*
 *			G _ V O L . C
 *
 *  Purpose -
 *	Intersect a ray with a 3-D volume.
 *	The volume is described as a concatenation of
 *	bw(5) files.
 *
 *  Authors -
 *	Michael John Muuss
 *	Phil Dykstra
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSvol[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_vol.c,v 11.30 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <string.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "./debug.h"
#include "./fixpt.h"

/*
NOTES:
	Changed small to small1 for win32 compatibility 
*/


struct rt_vol_specific {
	struct rt_vol_internal vol_i;
	vect_t		vol_xnorm;	/* local +X norm in model coords */
	vect_t		vol_ynorm;
	vect_t		vol_znorm;
	mat_t		vol_mat;	/* model to ideal space */
	vect_t		vol_origin;	/* local coords of grid origin (0,0,0) for now */
	vect_t		vol_large;	/* local coords of XYZ max */
};
#define VOL_NULL	((struct rt_vol_specific *)0)

#define VOL_O(m)	offsetof(struct rt_vol_internal, m)

const struct bu_structparse rt_vol_parse[] = {
#if CRAY && !__STDC__
	{"%s",	RT_VOL_NAME_LEN, "file",	1,		BU_STRUCTPARSE_FUNC_NULL },
#else
	{"%s",	RT_VOL_NAME_LEN, "file",	bu_offsetofarray(struct rt_vol_internal, file), BU_STRUCTPARSE_FUNC_NULL },
#endif
	{"%d",	1, "w",		VOL_O(xdim),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "n",		VOL_O(ydim),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "d",		VOL_O(zdim),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "lo",	VOL_O(lo),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "hi",	VOL_O(hi),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	ELEMENTS_PER_VECT, "size",bu_offsetofarray(struct rt_vol_internal, cellsize), BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	16, "mat", bu_offsetofarray(struct rt_vol_internal,mat), BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
};

RT_EXTERN(void rt_vol_plate,(point_t a, point_t b, point_t c, point_t d,
	mat_t mat, struct bu_list *vhead, struct rt_vol_internal *vip));

/*
 *  Codes to represent surface normals.
 *  In a bitmap, there are only 4 possible normals.
 *  With this code, reverse the sign to reverse the direction.
 *  As always, the normal is expected to point outwards.
 */
#define NORM_ZPOS	3
#define NORM_YPOS	2
#define NORM_XPOS	1
#define NORM_XNEG	(-1)
#define NORM_YNEG	(-2)
#define NORM_ZNEG	(-3)

/*
 *  Regular bit addressing is used:  (0..W-1, 0..N-1),
 *  but the bitmap is stored with two cells of zeros all around,
 *  so permissible subscripts run (-2..W+1, -2..N+1).
 *  This eliminates special-case code for the boundary conditions.
 */
#define	VOL_XWIDEN	2
#define	VOL_YWIDEN	2
#define	VOL_ZWIDEN	2
#define VOL(_vip,_xx,_yy,_zz)	(_vip)->map[ \
	(((_zz)+VOL_ZWIDEN) * ((_vip)->ydim + VOL_YWIDEN*2)+ \
	 ((_yy)+VOL_YWIDEN))* ((_vip)->xdim + VOL_XWIDEN*2)+ \
	  (_xx)+VOL_XWIDEN ]

#define OK(_vip,_v)	( (int)(_v) >= (_vip)->lo && (int)(_v) <= (_vip)->hi )

static int rt_vol_normtab[3] = { NORM_XPOS, NORM_YPOS, NORM_ZPOS };


/*
 *			R T _ V O L _ S H O T
 *
 *  Transform the ray into local coordinates of the volume ("ideal space").
 *  Step through the 3-D array, in local coordinates.
 *  Return intersection segments.
 *
 */
int
rt_vol_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct rt_vol_specific *volp =
		(struct rt_vol_specific *)stp->st_specific;
	vect_t	invdir;
	double	t0;	/* in point of cell */
	double	t1;	/* out point of cell */
	double	tmax;	/* out point of entire grid */
	vect_t	t;	/* next t value for XYZ cell plane intersect */
	vect_t	delta;	/* spacing of XYZ cell planes along ray */
	int	igrid[3];/* Grid cell coordinates of cell (integerized) */
	vect_t	P;	/* hit point */
	int	inside;	/* inside/outside a solid flag */
	int	in_axis;
	int	out_axis;
	int	j;
	struct xray	ideal_ray;

	/* Transform actual ray into ideal space at origin in X-Y plane */
	MAT4X3PNT( ideal_ray.r_pt, volp->vol_mat, rp->r_pt );
	MAT4X3VEC( ideal_ray.r_dir, volp->vol_mat, rp->r_dir );
	rp = &ideal_ray;	/* XXX */

	/* Compute the inverse of the direction cosines */
	if( !NEAR_ZERO( rp->r_dir[X], SQRT_SMALL_FASTF ) )  {
		invdir[X]=1.0/rp->r_dir[X];
	} else {
		invdir[X] = INFINITY;
		rp->r_dir[X] = 0.0;
	}
	if( !NEAR_ZERO( rp->r_dir[Y], SQRT_SMALL_FASTF ) )  {
		invdir[Y]=1.0/rp->r_dir[Y];
	} else {
		invdir[Y] = INFINITY;
		rp->r_dir[Y] = 0.0;
	}
	if( !NEAR_ZERO( rp->r_dir[Z], SQRT_SMALL_FASTF ) )  {
		invdir[Z]=1.0/rp->r_dir[Z];
	} else {
		invdir[Z] = INFINITY;
		rp->r_dir[Z] = 0.0;
	}

	/* intersect ray with ideal grid rpp */
	VSETALL( P, 0 );
	if( ! rt_in_rpp(rp, invdir, P, volp->vol_large ) )
		return	0;	/* MISS */
	VJOIN1( P, rp->r_pt, rp->r_min, rp->r_dir );	/* P is hit point */
if(RT_G_DEBUG&DEBUG_VOL)VPRINT("vol_large", volp->vol_large);
if(RT_G_DEBUG&DEBUG_VOL)VPRINT("vol_origin", volp->vol_origin);
if(RT_G_DEBUG&DEBUG_VOL)VPRINT("r_pt", rp->r_pt);
if(RT_G_DEBUG&DEBUG_VOL)VPRINT("P", P);
if(RT_G_DEBUG&DEBUG_VOL)VPRINT("cellsize", volp->vol_i.cellsize);
	t0 = rp->r_min;
	tmax = rp->r_max;
if(RT_G_DEBUG&DEBUG_VOL)bu_log("[shoot: r_min=%g, r_max=%g]\n", rp->r_min, rp->r_max);

	/* find grid cell where ray first hits ideal space bounding RPP */
	igrid[X] = (P[X] - volp->vol_origin[X]) / volp->vol_i.cellsize[X];
	igrid[Y] = (P[Y] - volp->vol_origin[Y]) / volp->vol_i.cellsize[Y];
	igrid[Z] = (P[Z] - volp->vol_origin[Z]) / volp->vol_i.cellsize[Z];
	if( igrid[X] < 0 )  {
		igrid[X] = 0;
	} else if( igrid[X] >= volp->vol_i.xdim ) {
		igrid[X] = volp->vol_i.xdim-1;
	}
	if( igrid[Y] < 0 )  {
		igrid[Y] = 0;
	} else if( igrid[Y] >= volp->vol_i.ydim ) {
		igrid[Y] = volp->vol_i.ydim-1;
	}
	if( igrid[Z] < 0 )  {
		igrid[Z] = 0;
	} else if( igrid[Z] >= volp->vol_i.zdim ) {
		igrid[Z] = volp->vol_i.zdim-1;
	}
if(RT_G_DEBUG&DEBUG_VOL)bu_log("igrid=(%d, %d, %d)\n", igrid[X], igrid[Y], igrid[Z]);

	/* X setup */
	if( rp->r_dir[X] == 0.0 )  {
		t[X] = INFINITY;
		delta[X] = 0;
	} else {
		j = igrid[X];
		if( rp->r_dir[X] < 0 ) j++;
		t[X] = (volp->vol_origin[X] + j*volp->vol_i.cellsize[X] -
			rp->r_pt[X]) * invdir[X];
		delta[X] = volp->vol_i.cellsize[X] * fabs(invdir[X]);
	}
	/* Y setup */
	if( rp->r_dir[Y] == 0.0 )  {
		t[Y] = INFINITY;
		delta[Y] = 0;
	} else {
		j = igrid[Y];
		if( rp->r_dir[Y] < 0 ) j++;
		t[Y] = (volp->vol_origin[Y] + j*volp->vol_i.cellsize[Y] -
			rp->r_pt[Y]) * invdir[Y];
		delta[Y] = volp->vol_i.cellsize[Y] * fabs(invdir[Y]);
	}
	/* Z setup */
	if( rp->r_dir[Z] == 0.0 )  {
		t[Z] = INFINITY;
		delta[Z] = 0;
	} else {
		j = igrid[Z];
		if( rp->r_dir[Z] < 0 ) j++;
		t[Z] = (volp->vol_origin[Z] + j*volp->vol_i.cellsize[Z] -
			rp->r_pt[Z]) * invdir[Z];
		delta[Z] = volp->vol_i.cellsize[Z] * fabs(invdir[Z]);
	}

	/* The delta[] elements *must* be positive, as t must increase */
if(RT_G_DEBUG&DEBUG_VOL)bu_log("t[X] = %g, delta[X] = %g\n", t[X], delta[X] );
if(RT_G_DEBUG&DEBUG_VOL)bu_log("t[Y] = %g, delta[Y] = %g\n", t[Y], delta[Y] );
if(RT_G_DEBUG&DEBUG_VOL)bu_log("t[Z] = %g, delta[Z] = %g\n", t[Z], delta[Z] );

	/* Find face of entry into first cell -- max initial t value */
	if( t[X] >= t[Y] )  {
		in_axis = X;
		t0 = t[X];
	} else {
		in_axis = Y;
		t0 = t[Y];
	}
	if( t[Z] > t0 )  {
		in_axis = Z;
		t0 = t[Z];
	}
if(RT_G_DEBUG&DEBUG_VOL)bu_log("Entry axis is %s, t0=%g\n", in_axis==X ? "X" : (in_axis==Y?"Y":"Z"), t0);

	/* Advance to next exits */
	t[X] += delta[X];
	t[Y] += delta[Y];
	t[Z] += delta[Z];

	/* Ensure that next exit is after first entrance */
	if( t[X] < t0 )  {
		bu_log("*** advancing t[X]\n");
		t[X] += delta[X];
	}
	if( t[Y] < t0 )  {
		bu_log("*** advancing t[Y]\n");
		t[Y] += delta[Y];
	}
	if( t[Z] < t0 )  {
		bu_log("*** advancing t[Z]\n");
		t[Z] += delta[Z];
	}
if(RT_G_DEBUG&DEBUG_VOL) VPRINT("Exit t[]", t);

	inside = 0;

	while( t0 < tmax ) {
		int	val;
		struct seg	*segp;

		/* find minimum exit t value */
		if( t[X] < t[Y] )  {
			if( t[Z] < t[X] )  {
				out_axis = Z;
				t1 = t[Z];
			} else {
				out_axis = X;
				t1 = t[X];
			}
		} else {
			if( t[Z] < t[Y] )  {
				out_axis = Z;
				t1 = t[Z];
			} else {
				out_axis = Y;
				t1 = t[Y];
			}
		}

		/* Ray passes through cell igrid[XY] from t0 to t1 */
		val = VOL( &volp->vol_i, igrid[X], igrid[Y], igrid[Z] );
if(RT_G_DEBUG&DEBUG_VOL)bu_log("igrid [%d %d %d] from %g to %g, val=%d\n",
			igrid[X], igrid[Y], igrid[Z],
			t0, t1, val );
if(RT_G_DEBUG&DEBUG_VOL)bu_log("Exit axis is %s, t[]=(%g, %g, %g)\n",
			out_axis==X ? "X" : (out_axis==Y?"Y":"Z"),
			t[X], t[Y], t[Z] );

		if( t1 <= t0 )  bu_log("ERROR vol t1=%g < t0=%g\n", t1, t0 );
		if( !inside )  {
			if( OK( &volp->vol_i, val ) )  {
				/* Handle the transition from vacuum to solid */
				/* Start of segment (entering a full voxel) */
				inside = 1;

				RT_GET_SEG(segp, ap->a_resource);
				segp->seg_stp = stp;
				segp->seg_in.hit_dist = t0;

				/* Compute entry normal */
				if( rp->r_dir[in_axis] < 0 )  {
					/* Go left, entry norm goes right */
					segp->seg_in.hit_surfno =
						rt_vol_normtab[in_axis];
				}  else  {
					/* go right, entry norm goes left */
					segp->seg_in.hit_surfno =
						(-rt_vol_normtab[in_axis]);
				}
				BU_LIST_INSERT( &(seghead->l), &(segp->l) );
				if(RT_G_DEBUG&DEBUG_VOL) bu_log("START t=%g, surfno=%d\n",
					t0, segp->seg_in.hit_surfno);
			} else {
				/* Do nothing, marching through void */
			}
		} else {
			if( OK( &volp->vol_i, val ) )  {
				/* Do nothing, marching through solid */
			} else {
				register struct seg	*tail;
				/* End of segment (now in an empty voxel) */
				/* Handle transition from solid to vacuum */
				inside = 0;

				tail = BU_LIST_LAST( seg, &(seghead->l) );
				tail->seg_out.hit_dist = t0;

				/* Compute exit normal */
				if( rp->r_dir[in_axis] < 0 )  {
					/* Go left, exit normal goes left */
					tail->seg_out.hit_surfno =
						(-rt_vol_normtab[in_axis]);
				}  else  {
					/* go right, exit norm goes right */
					tail->seg_out.hit_surfno =
						rt_vol_normtab[in_axis];
				}
				if(RT_G_DEBUG&DEBUG_VOL) bu_log("END t=%g, surfno=%d\n",
					t0, tail->seg_out.hit_surfno );
			}
		}

		/* Take next step */
		t0 = t1;
		in_axis = out_axis;
		t[out_axis] += delta[out_axis];
		if( rp->r_dir[out_axis] > 0 ) {
			igrid[out_axis]++;
		} else {
			igrid[out_axis]--;
		}
	}

	if( inside )  {
		register struct seg	*tail;

		/* Close off the final segment */
		tail = BU_LIST_LAST( seg, &(seghead->l) );
		tail->seg_out.hit_dist = tmax;

		/* Compute exit normal.  Previous out_axis is now in_axis */
		if( rp->r_dir[in_axis] < 0 )  {
			/* Go left, exit normal goes left */
			tail->seg_out.hit_surfno = (-rt_vol_normtab[in_axis]);
		}  else  {
			/* go right, exit norm goes right */
			tail->seg_out.hit_surfno = rt_vol_normtab[in_axis];
		}
		if(RT_G_DEBUG&DEBUG_VOL) bu_log("closed END t=%g, surfno=%d\n",
			tmax, tail->seg_out.hit_surfno );
	}

	if( BU_LIST_IS_EMPTY( &(seghead->l) ) )
		return(0);
	return(2);
}

/*
 *			R T _ V O L _ I M P O R T
 *
 *  Read in the information from the string solid record.
 *  Then, as a service to the application, read in the bitmap
 *  and set up some of the associated internal variables.
 */
int
rt_vol_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	union record	*rp;
	register struct rt_vol_internal *vip;
	struct bu_vls	str;
	FILE		*fp;
	int		nbytes;
	register int	y;
	register int	z;
	mat_t		tmat;
	int		ret;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	if( rp->u_id != DBID_STRSOL )  {
		bu_log("rt_ebm_import: defective strsol record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_VOL;
	ip->idb_meth = &rt_functab[ID_VOL];
	ip->idb_ptr = bu_calloc(1, sizeof(struct rt_vol_internal), "rt_vol_internal");
	vip = (struct rt_vol_internal *)ip->idb_ptr;
	vip->magic = RT_VOL_INTERNAL_MAGIC;

	/* Establish defaults */
	MAT_IDN( vip->mat );
	vip->lo = 0;
	vip->hi = 255;

	/* Default VOL cell size in ideal coordinates is one unit/cell */
	VSETALL( vip->cellsize, 1 );

	bu_vls_init( &str );
	bu_vls_strcpy( &str, rp->ss.ss_args );
	if( bu_struct_parse( &str, rt_vol_parse, (char *)vip ) < 0 )  {
		bu_vls_free( &str );
		return -2;
	}
	bu_vls_free( &str );

	/* Check for reasonable values */
	if( vip->file[0] == '\0' || vip->xdim < 1 ||
	    vip->ydim < 1 || vip->zdim < 1 || vip->mat[15] <= 0.0 ||
	    vip->lo < 0 || vip->hi > 255 )  {
	    	bu_struct_print("Unreasonable VOL parameters", rt_vol_parse,
			(char *)vip );
	    	return(-1);
	}

	/* Apply any modeling transforms to get final matrix */
	bn_mat_mul( tmat, mat, vip->mat );
	MAT_COPY( vip->mat, tmat );

	/* Get bit map from .bw(5) file */
	nbytes = (vip->xdim+VOL_XWIDEN*2)*
		(vip->ydim+VOL_YWIDEN*2)*
		(vip->zdim+VOL_ZWIDEN*2);
	vip->map = (unsigned char *)bu_calloc( 1, nbytes, "vol_import bitmap" );

	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	if( (fp = fopen(vip->file, "r")) == NULL )  {
		perror(vip->file);
		bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
		return(-1);
	}
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */

	/* Because of in-memory padding, read each scanline separately */
	for( z=0; z < vip->zdim; z++ )  {
		for( y=0; y < vip->ydim; y++ )  {
			bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
			ret = fread( &VOL(vip, 0, y, z), vip->xdim, 1, fp ); /* res_syscall */
			bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
			if( ret < 1 )  {
				bu_log("rt_vol_import(%s): Unable to read whole VOL, y=%d, z=%d\n",
					vip->file, y, z);
				bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
				fclose(fp);
				bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
				return -1;
			}
		}
	}
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	fclose(fp);
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
	return( 0 );
}

/*
 *			R T _ V O L _ E X P O R T
 *
 *  The name will be added by the caller.
 */
int
rt_vol_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_vol_internal	*vip;
	struct rt_vol_internal	vol;	/* scaled version */
	union record		*rec;
	struct bu_vls		str;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_VOL )  return(-1);
	vip = (struct rt_vol_internal *)ip->idb_ptr;
	RT_VOL_CK_MAGIC(vip);
	vol = *vip;			/* struct copy */

	/* Apply scale factor */
	vol.mat[15] /= local2mm;

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record)*DB_SS_NGRAN;
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "vol external");
	rec = (union record *)ep->ext_buf;

	bu_vls_init( &str );
	bu_vls_struct_print( &str, rt_vol_parse, (char *)&vol );

	rec->ss.ss_id = DBID_STRSOL;
	strncpy( rec->ss.ss_keyword, "vol", NAMESIZE-1 );
	strncpy( rec->ss.ss_args, bu_vls_addr(&str), DB_SS_LEN-1 );
	bu_vls_free( &str );

	return(0);
}

/*
 *			R T _ V O L _ I M P O R T 5
 *
 *  Read in the information from the string solid record.
 *  Then, as a service to the application, read in the bitmap
 *  and set up some of the associated internal variables.
 */
int
rt_vol_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	register struct rt_vol_internal *vip;
	struct bu_vls	str;
	FILE		*fp;
	int		nbytes;
	register int	y;
	register int	z;
	mat_t		tmat;
	int		ret;

	BU_CK_EXTERNAL( ep );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_VOL;
	ip->idb_meth = &rt_functab[ID_VOL];
	ip->idb_ptr = bu_calloc(1, sizeof(struct rt_vol_internal), "rt_vol_internal");
	vip = (struct rt_vol_internal *)ip->idb_ptr;
	vip->magic = RT_VOL_INTERNAL_MAGIC;

	/* Establish defaults */
	MAT_IDN( vip->mat );
	vip->lo = 0;
	vip->hi = 255;

	/* Default VOL cell size in ideal coordinates is one unit/cell */
	VSETALL( vip->cellsize, 1 );

	bu_vls_init( &str );
	bu_vls_strncpy( &str, ep->ext_buf, ep->ext_nbytes );
	if( bu_struct_parse( &str, rt_vol_parse, (char *)vip ) < 0 )  {
		bu_vls_free( &str );
		return -2;
	}
	bu_vls_free( &str );

	/* Check for reasonable values */
	if( vip->file[0] == '\0' || vip->xdim < 1 ||
	    vip->ydim < 1 || vip->zdim < 1 || vip->mat[15] <= 0.0 ||
	    vip->lo < 0 || vip->hi > 255 )  {
	    	bu_struct_print("Unreasonable VOL parameters", rt_vol_parse,
			(char *)vip );
	    	return(-1);
	}

	/* Apply any modeling transforms to get final matrix */
	bn_mat_mul( tmat, mat, vip->mat );
	MAT_COPY( vip->mat, tmat );

	/* Get bit map from .bw(5) file */
	nbytes = (vip->xdim+VOL_XWIDEN*2)*
		(vip->ydim+VOL_YWIDEN*2)*
		(vip->zdim+VOL_ZWIDEN*2);
	vip->map = (unsigned char *)bu_calloc( 1, nbytes, "vol_import bitmap" );

	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	if( (fp = fopen(vip->file, "r")) == NULL )  {
		perror(vip->file);
		bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
		return(-1);
	}
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */

	/* Because of in-memory padding, read each scanline separately */
	for( z=0; z < vip->zdim; z++ )  {
		for( y=0; y < vip->ydim; y++ )  {
			bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
			ret = fread( &VOL(vip, 0, y, z), vip->xdim, 1, fp ); /* res_syscall */
			bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
			if( ret < 1 )  {
				bu_log("rt_vol_import(%s): Unable to read whole VOL, y=%d, z=%d\n",
					vip->file, y, z);
				bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
				fclose(fp);
				bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
				return -1;
			}
		}
	}
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	fclose(fp);
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
	return( 0 );
}

/*
 *			R T _ V O L _ E X P O R T 5
 *
 *  The name will be added by the caller.
 */
int
rt_vol_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_vol_internal	*vip;
	struct rt_vol_internal	vol;	/* scaled version */
	struct bu_vls		str;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_VOL )  return(-1);
	vip = (struct rt_vol_internal *)ip->idb_ptr;
	RT_VOL_CK_MAGIC(vip);
	vol = *vip;			/* struct copy */

	/* Apply scale factor */
	vol.mat[15] /= local2mm;

	BU_CK_EXTERNAL(ep);

	bu_vls_init( &str );
	bu_vls_struct_print( &str, rt_vol_parse, (char *)&vol );
	ep->ext_nbytes = bu_vls_strlen( &str );
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "vol external");

	strcpy( ep->ext_buf, bu_vls_addr(&str) );
	bu_vls_free( &str );

	return(0);
}

/*
 *			R T _ V O L _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_vol_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_vol_internal	*vip =
		(struct rt_vol_internal *)ip->idb_ptr;
	register int i;
	struct bu_vls substr;
	vect_t local;

	RT_VOL_CK_MAGIC(vip);

	VSCALE( local, vip->cellsize, mm2local )
	bu_vls_strcat( str, "thresholded volumetric solid (VOL)\n\t");

/*	bu_vls_struct_print( str, rt_vol_parse, (char *)vip );
	bu_vls_strcat( str, "\n" ); */

	bu_vls_init( &substr );
	bu_vls_printf( &substr, "  file=\"%s\" w=%d n=%d d=%d lo=%d hi=%d size=%g %g %g\n   mat=",
		vip->file, vip->xdim, vip->ydim, vip->zdim, vip->lo, vip->hi,
		V3ARGS( local ) );
	bu_vls_vlscat( str, &substr );
	for( i=0 ; i<15 ; i++ )
	{
		bu_vls_trunc2( &substr, 0 );
		bu_vls_printf( &substr, "%g,", vip->mat[i] );
		bu_vls_vlscat( str, &substr );
	}
	bu_vls_trunc2( &substr, 0 );
	bu_vls_printf( &substr, "%g\n", vip->mat[i] );
	bu_vls_vlscat( str, &substr );

	bu_vls_free( &substr );

	return(0);
}

/*
 *			R T _ V O L _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_vol_ifree(struct rt_db_internal *ip)
{
	register struct rt_vol_internal	*vip;

	RT_CK_DB_INTERNAL(ip);
	vip = (struct rt_vol_internal *)ip->idb_ptr;
	RT_VOL_CK_MAGIC(vip);

	if( vip->map) bu_free( (char *)vip->map, "vol bitmap" );

	vip->magic = 0;			/* sanity */
	vip->map = (unsigned char *)0;
	bu_free( (char *)vip, "vol ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

/*
 *			R T _ V O L _ P R E P
 *
 *  Returns -
 *	0	OK
 *	!0	Failure
 *
 *  Implicit return -
 *	A struct rt_vol_specific is created, and it's address is stored
 *	in stp->st_specific for use by rt_vol_shot().
 */
int
rt_vol_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_vol_internal	*vip;
	register struct rt_vol_specific *volp;
	vect_t	norm;
	vect_t	radvec;
	vect_t	diam;
	vect_t	small1;


	vip = (struct rt_vol_internal *)ip->idb_ptr;
	RT_VOL_CK_MAGIC(vip);

	BU_GETSTRUCT( volp, rt_vol_specific );
	volp->vol_i = *vip;		/* struct copy */
	vip->map = (unsigned char *)0;	/* "steal" the bitmap storage */

	/* build Xform matrix from model(world) to ideal(local) space */
	bn_mat_inv( volp->vol_mat, vip->mat );

	/* Pre-compute the necessary normals.  Rotate only. */
	VSET( norm, 1, 0 , 0 );
	MAT3X3VEC( volp->vol_xnorm, vip->mat, norm );
	VSET( norm, 0, 1, 0 );
	MAT3X3VEC( volp->vol_ynorm, vip->mat, norm );
	VSET( norm, 0, 0, 1 );
	MAT3X3VEC( volp->vol_znorm, vip->mat, norm );

	stp->st_specific = (genptr_t)volp;

	/* Find bounding RPP of rotated local RPP */
	VSETALL( small1, 0 );
	VSET( volp->vol_large,
		volp->vol_i.xdim*vip->cellsize[0], volp->vol_i.ydim*vip->cellsize[1], volp->vol_i.zdim*vip->cellsize[2] );/* type conversion */
	bn_rotate_bbox( stp->st_min, stp->st_max, vip->mat,
		small1, volp->vol_large );

	/* for now, VOL origin in ideal coordinates is at origin */
	VSETALL( volp->vol_origin, 0 );
	VADD2( volp->vol_large, volp->vol_large, volp->vol_origin );

	VSUB2( diam, stp->st_max, stp->st_min );
	VADD2SCALE( stp->st_center, stp->st_min, stp->st_max, 0.5 );
	VSCALE( radvec, diam, 0.5 );
	stp->st_aradius = stp->st_bradius = MAGNITUDE( radvec );

	return(0);		/* OK */
}

/*
 *			R T _ V O L _ P R I N T
 */
void
rt_vol_print(register const struct soltab *stp)
{
	register const struct rt_vol_specific *volp =
		(struct rt_vol_specific *)stp->st_specific;

	bu_log("vol file = %s\n", volp->vol_i.file );
	bu_log("dimensions = (%d, %d, %d)\n",
		volp->vol_i.xdim, volp->vol_i.ydim,
		volp->vol_i.zdim );
	VPRINT("model cellsize", volp->vol_i.cellsize);
	VPRINT("model grid origin", volp->vol_origin);
}

/*
 *			R T _ V O L _ N O R M
 *
 *  Given one ray distance, return the normal and
 *  entry/exit point.
 *  This is mostly a matter of translating the stored
 *  code into the proper normal.
 */
void
rt_vol_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct rt_vol_specific *volp =
		(struct rt_vol_specific *)stp->st_specific;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );

	switch( hitp->hit_surfno )  {
	case NORM_XPOS:
		VMOVE( hitp->hit_normal, volp->vol_xnorm );
		break;
	case NORM_XNEG:
		VREVERSE( hitp->hit_normal, volp->vol_xnorm );
		break;

	case NORM_YPOS:
		VMOVE( hitp->hit_normal, volp->vol_ynorm );
		break;
	case NORM_YNEG:
		VREVERSE( hitp->hit_normal, volp->vol_ynorm );
		break;

	case NORM_ZPOS:
		VMOVE( hitp->hit_normal, volp->vol_znorm );
		break;
	case NORM_ZNEG:
		VREVERSE( hitp->hit_normal, volp->vol_znorm );
		break;

	default:
		bu_log("rt_vol_norm(%s): surfno=%d bad\n",
			stp->st_name, hitp->hit_surfno );
		VSETALL( hitp->hit_normal, 0 );
		break;
	}
}

/*
 *			R T _ V O L _ C U R V E
 *
 *  Everything has sharp edges.  This makes things easy.
 */
void
rt_vol_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
/*	register struct rt_vol_specific *volp =
		(struct rt_vol_specific *)stp->st_specific; */

	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
	cvp->crv_c1 = cvp->crv_c2 = 0;
}

/*
 *			R T _ V O L _ U V
 *
 *  Map the hit point in 2-D into the range 0..1
 *  untransformed X becomes U, and Y becomes V.
 */
void
rt_vol_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
/*	register struct rt_vol_specific *volp =
		(struct rt_vol_specific *)stp->st_specific;*/

	/* XXX uv should be xy in ideal space */
}

/*
 * 			R T _ V O L _ F R E E
 */
void
rt_vol_free(struct soltab *stp)
{
	register struct rt_vol_specific *volp =
		(struct rt_vol_specific *)stp->st_specific;

	bu_free( (char *)volp->vol_i.map, "vol_map" );
	bu_free( (char *)volp, "rt_vol_specific" );
}

int
rt_vol_class(void)
{
	return(0);
}

/*
 *			R T _ V O L _ P L O T
 */
int
rt_vol_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register struct rt_vol_internal *vip;
	register short	x,y,z;
	register short	v1,v2;
	point_t		a,b,c,d;

	RT_CK_DB_INTERNAL(ip);
	vip = (struct rt_vol_internal *)ip->idb_ptr;
	RT_VOL_CK_MAGIC(vip);

	/*
	 *  Scan across in Z & X.  For each X position, scan down Y,
	 *  looking for the longest run of edge.
	 */
	for( z=-1; z<=vip->zdim; z++ )  {
		for( x=-1; x<=vip->xdim; x++ )  {
			for( y=-1; y<=vip->ydim; y++ )  {
				v1 = VOL(vip, x,y,z);
				v2 = VOL(vip, x+1,y,z);
				if( OK(vip, v1) == OK(vip, v2) )  continue;
				/* Note start point, continue scan */
				VSET( a, x+0.5, y-0.5, z-0.5 );
				VSET( b, x+0.5, y-0.5, z+0.5 );
				for( ++y; y<=vip->ydim; y++ )  {
					v1 = VOL(vip, x,y,z);
					v2 = VOL(vip, x+1,y,z);
					if( OK(vip, v1) == OK(vip, v2) )
						break;
				}
				/* End of run of edge.  One cell beyond. */
				VSET( c, x+0.5, y-0.5, z+0.5 );
				VSET( d, x+0.5, y-0.5, z-0.5 );
				rt_vol_plate( a,b,c,d, vip->mat, vhead, vip );
			}
		}
	}

	/*
	 *  Scan up in Z & Y.  For each Y position, scan across X
	 */
	for( z=-1; z<=vip->zdim; z++ )  {
		for( y=-1; y<=vip->ydim; y++ )  {
			for( x=-1; x<=vip->xdim; x++ )  {
				v1 = VOL(vip, x,y,z);
				v2 = VOL(vip, x,y+1,z);
				if( OK(vip, v1) == OK(vip, v2) )  continue;
				/* Note start point, continue scan */
				VSET( a, x-0.5, y+0.5, z-0.5 );
				VSET( b, x-0.5, y+0.5, z+0.5 );
				for( ++x; x<=vip->xdim; x++ )  {
					v1 = VOL(vip, x,y,z);
					v2 = VOL(vip, x,y+1,z);
					if( OK(vip, v1) == OK(vip, v2) )
						break;
				}
				/* End of run of edge.  One cell beyond */
				VSET( c, (x-0.5), (y+0.5), (z+0.5) );
				VSET( d, (x-0.5), (y+0.5), (z-0.5) );
				rt_vol_plate( a,b,c,d, vip->mat, vhead, vip );
			}
		}
	}

	/*
	 * Scan across in Y & X.  For each X position pair edge, scan up Z.
	 */
	for( x=-1; x<=vip->xdim; x++ )  {
		for( z=-1; z<=vip->zdim; z++ )  {
			for( y=-1; y<=vip->ydim; y++ )  {
				v1 = VOL(vip, x,y,z);
				v2 = VOL(vip, x,y,z+1);
				if( OK(vip, v1) == OK(vip, v2) )  continue;
				/* Note start point, continue scan */
				VSET( a, (x-0.5), (y-0.5), (z+0.5) );
				VSET( b, (x+0.5), (y-0.5), (z+0.5) );
				for( ++y; y<=vip->ydim; y++ )  {
					v1 = VOL(vip, x,y,z);
					v2 = VOL(vip, x,y,z+1);
					if( OK(vip, v1) == OK(vip, v2) )
						break;
				}
				/* End of run of edge.  One cell beyond */
				VSET( c, (x+0.5), (y-0.5), (z+0.5) );
				VSET( d, (x-0.5), (y-0.5), (z+0.5) );
				rt_vol_plate( a,b,c,d, vip->mat, vhead, vip );
			}
		}
	}
	return(0);
}

/*
 *			R T _ V O L _ P L A T E
 */
void
rt_vol_plate(fastf_t *a, fastf_t *b, fastf_t *c, fastf_t *d, register fastf_t *mat, register struct bu_list *vhead, register struct rt_vol_internal *vip)
{
	LOCAL point_t	s;		/* scaled original point */
	LOCAL point_t	arot, prot;

	VELMUL( s, vip->cellsize, a );
	MAT4X3PNT( arot, mat, s );
	RT_ADD_VLIST( vhead, arot, BN_VLIST_LINE_MOVE );

	VELMUL( s, vip->cellsize, b );
	MAT4X3PNT( prot, mat, s );
	RT_ADD_VLIST( vhead, prot, BN_VLIST_LINE_DRAW );

	VELMUL( s, vip->cellsize, c );
	MAT4X3PNT( prot, mat, s );
	RT_ADD_VLIST( vhead, prot, BN_VLIST_LINE_DRAW );

	VELMUL( s, vip->cellsize, d );
	MAT4X3PNT( prot, mat, s );
	RT_ADD_VLIST( vhead, prot, BN_VLIST_LINE_DRAW );

	RT_ADD_VLIST( vhead, arot, BN_VLIST_LINE_DRAW );
}

/*
 *			R T _ V O L _ T E S S
 */
int
rt_vol_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct rt_vol_internal	*vip;
	register int	x,y,z;
	int		i;
	struct shell	*s;
	struct vertex	*verts[4];
	struct faceuse	*fu;
	struct model	*m_tmp;
	struct nmgregion *r_tmp;

	NMG_CK_MODEL( m );
	BN_CK_TOL( tol );
	RT_CK_TESS_TOL( ttol );

	RT_CK_DB_INTERNAL(ip);
	vip = (struct rt_vol_internal *)ip->idb_ptr;
	RT_VOL_CK_MAGIC(vip);

	/* make region, shell, vertex */
	m_tmp = nmg_mm();
	r_tmp = nmg_mrsv( m_tmp );
	s = BU_LIST_FIRST(shell, &r_tmp->s_hd);

	for( x=0 ; x<vip->xdim ; x++ )
	{
		for( y=0 ; y<vip->ydim ; y++ )
		{
			for( z=0 ; z<vip->zdim ; z++ )
			{
				point_t pt,pt1;

				/* skip empty cells */
				if( !OK( vip , VOL( vip , x , y , z ) ) )
					continue;

				/* check neighboring cells, make a face where needed */

				/* check z+1 */
				if( !OK( vip , VOL( vip , x , y , z+1 ) ) )
				{
					for( i=0 ; i<4 ; i++ )
						verts[i] = (struct vertex *)NULL;

					fu = nmg_cface( s , verts , 4 );

					VSET( pt , x+.5 , y-.5 , z+.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[0] , pt );
					VSET( pt , x+.5 , y+.5 , z+.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[1] , pt );
					VSET( pt , x-.5 , y+.5 , z+.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[2] , pt );
					VSET( pt , x-.5 , y-.5 , z+.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[3] , pt );

					if( nmg_fu_planeeqn( fu , tol ) )
						goto fail;
				}

				/* check z-1 */
				if( !OK( vip , VOL( vip , x , y , z-1 ) ) )
				{
					for( i=0 ; i<4 ; i++ )
						verts[i] = (struct vertex *)NULL;

					fu = nmg_cface( s , verts , 4 );

					VSET( pt , x+.5 , y-.5 , z-.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[3] , pt );
					VSET( pt , x+.5 , y+.5 , z-.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[2] , pt );
					VSET( pt , x-.5 , y+.5 , z-.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[1] , pt );
					VSET( pt , x-.5 , y-.5 , z-.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[0] , pt );

					if( nmg_fu_planeeqn( fu , tol ) )
						goto fail;
				}

				/* check y+1 */
				if( !OK( vip , VOL( vip , x , y+1 , z ) ) )
				{
					for( i=0 ; i<4 ; i++ )
						verts[i] = (struct vertex *)NULL;

					fu = nmg_cface( s , verts , 4 );

					VSET( pt , x+.5 , y+.5 , z+.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[0] , pt );
					VSET( pt , x+.5 , y+.5 , z-.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[1] , pt );
					VSET( pt , x-.5 , y+.5 , z-.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[2] , pt );
					VSET( pt , x-.5 , y+.5 , z+.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[3] , pt );

					if( nmg_fu_planeeqn( fu , tol ) )
						goto fail;
				}

				/* check y-1 */
				if( !OK( vip , VOL( vip , x , y-1 , z ) ) )
				{
					for( i=0 ; i<4 ; i++ )
						verts[i] = (struct vertex *)NULL;

					fu = nmg_cface( s , verts , 4 );

					VSET( pt , x+.5 , y-.5 , z+.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[3] , pt );
					VSET( pt , x+.5 , y-.5 , z-.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[2] , pt );
					VSET( pt , x-.5 , y-.5 , z-.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[1] , pt );
					VSET( pt , x-.5 , y-.5 , z+.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[0] , pt );

					if( nmg_fu_planeeqn( fu , tol ) )
						goto fail;
				}

				/* check x+1 */
				if( !OK( vip , VOL( vip , x+1 , y , z ) ) )
				{
					for( i=0 ; i<4 ; i++ )
						verts[i] = (struct vertex *)NULL;

					fu = nmg_cface( s , verts , 4 );

					VSET( pt , x+.5 , y-.5 , z-.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[0] , pt );
					VSET( pt , x+.5 , y+.5 , z-.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[1] , pt );
					VSET( pt , x+.5 , y+.5 , z+.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[2] , pt );
					VSET( pt , x+.5 , y-.5 , z+.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[3] , pt );

					if( nmg_fu_planeeqn( fu , tol ) )
						goto fail;
				}

				/* check x-1 */
				if( !OK( vip , VOL( vip , x-1 , y , z ) ) )
				{
					for( i=0 ; i<4 ; i++ )
						verts[i] = (struct vertex *)NULL;

					fu = nmg_cface( s , verts , 4 );

					VSET( pt , x-.5 , y-.5 , z-.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[3] , pt );
					VSET( pt , x-.5 , y+.5 , z-.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[2] , pt );
					VSET( pt , x-.5 , y+.5 , z+.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[1] , pt );
					VSET( pt , x-.5 , y-.5 , z+.5 );
					VELMUL( pt1 , vip->cellsize , pt );
					MAT4X3PNT( pt , vip->mat , pt1 );
					nmg_vertex_gv( verts[0] , pt );

					if( nmg_fu_planeeqn( fu , tol ) )
						goto fail;
				}
			}
		}
	}

	nmg_region_a( r_tmp , tol );

	/* fuse model */
	nmg_model_fuse( m_tmp , tol );

	/* simplify shell */
	nmg_shell_coplanar_face_merge( s, tol, 1 );

	/* kill snakes */
	for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		struct loopuse *lu;

		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;
		
		for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
			(void)nmg_kill_snakes( lu );
	}

	(void)nmg_unbreak_region_edges( (long *)(&s->l) );

	(void)nmg_mark_edges_real( (long *)&s->l );

	nmg_merge_models( m , m_tmp );
	*r = r_tmp;

	return( 0 );

fail:
	nmg_km( m_tmp );
	*r = (struct nmgregion *)NULL;

	return( -1 );
}
@


11.30
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /cvs/brlcad/librt/g_vol.c,v 11.29 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.29
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header$ (BRL)";
d26 5
a30 1
#include "conf.h"
@


11.28
log
@merge of windows-6-0-branch into head
@
text
@d120 1
a120 5
rt_vol_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d402 1
a402 5
rt_vol_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d500 1
a500 5
rt_vol_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d540 1
a540 5
rt_vol_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d632 1
a632 5
rt_vol_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d668 1
a668 5
rt_vol_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d710 1
a710 2
rt_vol_ifree( ip )
struct rt_db_internal	*ip;
d738 1
a738 4
rt_vol_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d791 1
a791 2
rt_vol_print( stp )
register const struct soltab	*stp;
d813 1
a813 4
rt_vol_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d856 1
a856 4
rt_vol_curve( cvp, hitp, stp )
register struct curvature	*cvp;
register struct hit		*hitp;
struct soltab			*stp;
d872 1
a872 5
rt_vol_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d884 1
a884 2
rt_vol_free( stp )
struct soltab	*stp;
d894 1
a894 1
rt_vol_class()
d903 1
a903 5
rt_vol_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d999 1
a999 5
rt_vol_plate( a,b,c,d, mat, vhead, vip )
point_t			a,b,c,d;
register mat_t		mat;
register struct bu_list	*vhead;
register struct rt_vol_internal	*vip;
d1027 1
a1027 6
rt_vol_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
@


11.27
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.26 2002/08/20 17:08:02 jra Exp $ (BRL)";
d41 6
d773 2
a774 1
	vect_t	small;
d797 1
a797 1
	VSETALL( small, 0 );
d801 1
a801 1
		small, volp->vol_large );
@


11.26
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989 by the United States Army.
d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.24 2001/10/02 19:24:30 jra Exp $ (BRL)";
@


11.26.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.27 2004/02/02 17:39:22 morrison Exp $ (BRL)";
@


11.26.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.26.10.1 2004/02/12 18:37:42 erikg Exp $ (BRL)";
@


11.26.10.3
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header$ (BRL)";
a40 6
/*
NOTES:
	Changed small to small1 for win32 compatibility 
*/


d767 1
a767 2
	vect_t	small1;

d790 1
a790 1
	VSETALL( small1, 0 );
d794 1
a794 1
		small1, volp->vol_large );
@


11.26.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.26 2002/08/20 17:08:02 jra Exp $ (BRL)";
a40 6
/*
NOTES:
	Changed small to small1 for win32 compatibility 
*/


d767 1
a767 2
	vect_t	small1;

d790 1
a790 1
	VSETALL( small1, 0 );
d794 1
a794 1
		small1, volp->vol_large );
@


11.26.4.2
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_vol.c,v 11.26.4.1 2002/09/26 23:04:02 morrison Exp $ (BRL)";
@


11.26.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.26 2002/08/20 17:08:02 jra Exp $ (BRL)";
d114 5
a118 1
rt_vol_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d400 5
a404 1
rt_vol_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d502 5
a506 1
rt_vol_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d546 5
a550 1
rt_vol_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d642 5
a646 1
rt_vol_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d682 5
a686 1
rt_vol_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d728 2
a729 1
rt_vol_ifree(struct rt_db_internal *ip)
d757 4
a760 1
rt_vol_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d812 2
a813 1
rt_vol_print(register const struct soltab *stp)
d835 4
a838 1
rt_vol_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d881 4
a884 1
rt_vol_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d900 5
a904 1
rt_vol_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d916 2
a917 1
rt_vol_free(struct soltab *stp)
d927 1
a927 1
rt_vol_class(void)
d936 5
a940 1
rt_vol_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1036 5
a1040 1
rt_vol_plate(fastf_t *a, fastf_t *b, fastf_t *c, fastf_t *d, register fastf_t *mat, register struct bu_list *vhead, register struct rt_vol_internal *vip)
d1068 6
a1073 1
rt_vol_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
@


11.26.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header$ (BRL)";
a40 6
/*
NOTES:
	Changed small to small1 for win32 compatibility 
*/


d739 1
a739 2
	vect_t	small1;

d762 1
a762 1
	VSETALL( small1, 0 );
d766 1
a766 1
		small1, volp->vol_large );
@


11.25
log
@Converted from K&R to ANSI C - RFH
@
text
@d114 5
a118 1
rt_vol_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d400 5
a404 1
rt_vol_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d502 5
a506 1
rt_vol_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d546 5
a550 1
rt_vol_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d642 5
a646 1
rt_vol_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d682 5
a686 1
rt_vol_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d728 2
a729 1
rt_vol_ifree(struct rt_db_internal *ip)
d757 4
a760 1
rt_vol_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d812 2
a813 1
rt_vol_print(register const struct soltab *stp)
d835 4
a838 1
rt_vol_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d881 4
a884 1
rt_vol_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d900 5
a904 1
rt_vol_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d916 2
a917 1
rt_vol_free(struct soltab *stp)
d927 1
a927 1
rt_vol_class(void)
d936 5
a940 1
rt_vol_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1036 5
a1040 1
rt_vol_plate(fastf_t *a, fastf_t *b, fastf_t *c, fastf_t *d, register fastf_t *mat, register struct bu_list *vhead, register struct rt_vol_internal *vip)
d1068 6
a1073 1
rt_vol_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
@


11.24
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.23 2001/05/17 20:05:25 morrison Exp $ (BRL)";
d114 1
a114 5
rt_vol_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d396 1
a396 5
rt_vol_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d494 1
a494 5
rt_vol_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d534 1
a534 5
rt_vol_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d626 1
a626 5
rt_vol_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d662 1
a662 5
rt_vol_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d704 1
a704 2
rt_vol_ifree( ip )
struct rt_db_internal	*ip;
d732 1
a732 4
rt_vol_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d784 1
a784 2
rt_vol_print( stp )
register const struct soltab	*stp;
d806 1
a806 4
rt_vol_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d849 1
a849 4
rt_vol_curve( cvp, hitp, stp )
register struct curvature	*cvp;
register struct hit		*hitp;
struct soltab			*stp;
d865 1
a865 5
rt_vol_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d877 1
a877 2
rt_vol_free( stp )
struct soltab	*stp;
d887 1
a887 1
rt_vol_class()
d896 1
a896 5
rt_vol_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d992 1
a992 5
rt_vol_plate( a,b,c,d, mat, vhead, vip )
point_t			a,b,c,d;
register mat_t		mat;
register struct bu_list	*vhead;
register struct rt_vol_internal	*vip;
d1020 1
a1020 6
rt_vol_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
@


11.23
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.22 2001/04/30 19:23:00 jra Exp $ (BRL)";
d424 1
d564 1
@


11.22
log
@rt_vol_import5() was not null terminating its copy of the parameter string
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.21 2001/04/20 22:29:48 morrison Exp $ (BRL)";
d166 5
a170 5
if(rt_g.debug&DEBUG_VOL)VPRINT("vol_large", volp->vol_large);
if(rt_g.debug&DEBUG_VOL)VPRINT("vol_origin", volp->vol_origin);
if(rt_g.debug&DEBUG_VOL)VPRINT("r_pt", rp->r_pt);
if(rt_g.debug&DEBUG_VOL)VPRINT("P", P);
if(rt_g.debug&DEBUG_VOL)VPRINT("cellsize", volp->vol_i.cellsize);
d173 1
a173 1
if(rt_g.debug&DEBUG_VOL)bu_log("[shoot: r_min=%g, r_max=%g]\n", rp->r_min, rp->r_max);
d194 1
a194 1
if(rt_g.debug&DEBUG_VOL)bu_log("igrid=(%d, %d, %d)\n", igrid[X], igrid[Y], igrid[Z]);
d231 3
a233 3
if(rt_g.debug&DEBUG_VOL)bu_log("t[X] = %g, delta[X] = %g\n", t[X], delta[X] );
if(rt_g.debug&DEBUG_VOL)bu_log("t[Y] = %g, delta[Y] = %g\n", t[Y], delta[Y] );
if(rt_g.debug&DEBUG_VOL)bu_log("t[Z] = %g, delta[Z] = %g\n", t[Z], delta[Z] );
d247 1
a247 1
if(rt_g.debug&DEBUG_VOL)bu_log("Entry axis is %s, t0=%g\n", in_axis==X ? "X" : (in_axis==Y?"Y":"Z"), t0);
d267 1
a267 1
if(rt_g.debug&DEBUG_VOL) VPRINT("Exit t[]", t);
d296 1
a296 1
if(rt_g.debug&DEBUG_VOL)bu_log("igrid [%d %d %d] from %g to %g, val=%d\n",
d299 1
a299 1
if(rt_g.debug&DEBUG_VOL)bu_log("Exit axis is %s, t[]=(%g, %g, %g)\n",
d325 1
a325 1
				if(rt_g.debug&DEBUG_VOL) bu_log("START t=%g, surfno=%d\n",
d352 1
a352 1
				if(rt_g.debug&DEBUG_VOL) bu_log("END t=%g, surfno=%d\n",
d383 1
a383 1
		if(rt_g.debug&DEBUG_VOL) bu_log("closed END t=%g, surfno=%d\n",
@


11.21
log
@CONST to const
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.20 2001/04/02 21:38:09 morrison Exp $ (BRL)";
d578 1
a578 1
	bu_vls_strcpy( &str, ep->ext_buf );
@


11.20
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.19 2001/03/31 01:57:10 morrison Exp $ (BRL)";
d54 1
a54 1
CONST struct bu_structparse rt_vol_parse[] = {
d402 3
a404 3
CONST struct bu_external	*ep;
CONST mat_t			mat;
CONST struct db_i		*dbip;
d503 1
a503 1
CONST struct rt_db_internal	*ip;
d505 1
a505 1
CONST struct db_i		*dbip;
d547 3
a549 3
CONST struct bu_external	*ep;
CONST mat_t			mat;
CONST struct db_i		*dbip;
d642 1
a642 1
CONST struct rt_db_internal	*ip;
d644 1
a644 1
CONST struct db_i		*dbip;
d682 1
a682 1
CONST struct rt_db_internal	*ip;
d811 1
a811 1
register CONST struct soltab	*stp;
d813 1
a813 1
	register CONST struct rt_vol_specific *volp =
d937 2
a938 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d1070 2
a1071 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
@


11.19
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.18 2000/08/21 02:02:31 butler Exp $ (BRL)";
d457 1
a457 1
	bn_mat_copy( vip->mat, tmat );
d596 1
a596 1
	bn_mat_copy( vip->mat, tmat );
@


11.18
log
@Massive compilation warnings eliminated
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.17 2000/07/10 23:01:37 mike Exp $ (BRL)";
d431 1
a431 1
	bn_mat_idn( vip->mat );
d570 1
a570 1
	bn_mat_idn( vip->mat );
@


11.17
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d23 1
a23 1
static const char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.16 2000/06/30 20:03:46 jra Exp $ (BRL)";
d31 1
@


11.16
log
@Added database v5 support
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.15 2000/06/30 15:38:04 mike Exp $ (BRL)";
@


11.15
log
@
export methods should not init the external structure, just check them.
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.14 2000/06/30 15:31:15 mike Exp $ (BRL)";
d531 135
@


11.14
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.13 2000/04/12 02:34:37 mike Exp $ (BRL)";
d520 1
a520 1
	BU_INIT_EXTERNAL(ep);
@


11.13
log
@
NT port, non-compat4
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.12 1999/11/26 21:46:50 mike Exp $ (BRL)";
d422 1
a422 1
	RT_INIT_DB_INTERNAL( ip );
@


11.12
log
@
Lint cleanups
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.11 1999/11/24 23:12:10 mike Exp $ (BRL)";
d751 1
a751 1
	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.11
log
@
Made structparse tables CONST
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.10 1999/11/24 21:44:29 mike Exp $ (BRL)";
d399 1
a399 1
rt_vol_import( ip, ep, mat )
d403 1
d500 1
a500 1
rt_vol_export( ep, ip, local2mm )
d504 1
d546 1
a546 1
struct rt_db_internal	*ip;
d802 1
a802 1
struct bn_tol		*tol;
d935 1
a935 1
struct bn_tol		*tol;
@


11.10
log
@
Removed includes of compat header files rtstring.h and rtlist.h
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.9 1999/11/17 02:42:03 mike Exp $ (BRL)";
d53 1
a53 1
struct bu_structparse rt_vol_parse[] = {
@


11.9
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.8 1999/07/02 22:19:24 mike Exp $ (BRL)";
a33 2
#include "rtlist.h"
#include "rtstring.h"
@


11.8
log
@
Removed dependence on compat4.h
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.7 1999/05/27 19:10:43 mike Exp $ (BRL)";
d425 1
@


11.7
log
@
sed4
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_vol.c,v 11.6 1997/12/16 00:13:37 mike Exp $ (BRL)";
d57 1
a57 1
	{"%s",	RT_VOL_NAME_LEN, "file",	1,		FUNC_NULL },
d61 5
a65 5
	{"%d",	1, "w",		VOL_O(xdim),	FUNC_NULL },
	{"%d",	1, "n",		VOL_O(ydim),	FUNC_NULL },
	{"%d",	1, "d",		VOL_O(zdim),	FUNC_NULL },
	{"%d",	1, "lo",	VOL_O(lo),		FUNC_NULL },
	{"%d",	1, "hi",	VOL_O(hi),		FUNC_NULL },
d68 1
a68 1
	{"",	0, (char *)0,	0,			FUNC_NULL }
d908 1
a908 1
	RT_ADD_VLIST( vhead, arot, RT_VLIST_LINE_MOVE );
d912 1
a912 1
	RT_ADD_VLIST( vhead, prot, RT_VLIST_LINE_DRAW );
d916 1
a916 1
	RT_ADD_VLIST( vhead, prot, RT_VLIST_LINE_DRAW );
d920 1
a920 1
	RT_ADD_VLIST( vhead, prot, RT_VLIST_LINE_DRAW );
d922 1
a922 1
	RT_ADD_VLIST( vhead, arot, RT_VLIST_LINE_DRAW );
@


11.6
log
@Converted to bu_semaphore_acquire()
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 11.5 1996/12/19 14:03:00 jra Exp mike $ (BRL)";
d59 1
a59 1
	{"%s",	RT_VOL_NAME_LEN, "file",	offsetofarray(struct rt_vol_internal, file), FUNC_NULL },
d66 2
a67 2
	{"%f",	ELEMENTS_PER_VECT, "size",offsetofarray(struct rt_vol_internal, cellsize), FUNC_NULL },
	{"%f",	16, "mat", offsetofarray(struct rt_vol_internal,mat), FUNC_NULL },
d72 1
a72 1
	mat_t mat, struct rt_list *vhead, struct rt_vol_internal *vip));
d174 1
a174 1
if(rt_g.debug&DEBUG_VOL)rt_log("[shoot: r_min=%g, r_max=%g]\n", rp->r_min, rp->r_max);
d195 1
a195 1
if(rt_g.debug&DEBUG_VOL)rt_log("igrid=(%d, %d, %d)\n", igrid[X], igrid[Y], igrid[Z]);
d232 3
a234 3
if(rt_g.debug&DEBUG_VOL)rt_log("t[X] = %g, delta[X] = %g\n", t[X], delta[X] );
if(rt_g.debug&DEBUG_VOL)rt_log("t[Y] = %g, delta[Y] = %g\n", t[Y], delta[Y] );
if(rt_g.debug&DEBUG_VOL)rt_log("t[Z] = %g, delta[Z] = %g\n", t[Z], delta[Z] );
d248 1
a248 1
if(rt_g.debug&DEBUG_VOL)rt_log("Entry axis is %s, t0=%g\n", in_axis==X ? "X" : (in_axis==Y?"Y":"Z"), t0);
d257 1
a257 1
		rt_log("*** advancing t[X]\n");
d261 1
a261 1
		rt_log("*** advancing t[Y]\n");
d265 1
a265 1
		rt_log("*** advancing t[Z]\n");
d297 1
a297 1
if(rt_g.debug&DEBUG_VOL)rt_log("igrid [%d %d %d] from %g to %g, val=%d\n",
d300 1
a300 1
if(rt_g.debug&DEBUG_VOL)rt_log("Exit axis is %s, t[]=(%g, %g, %g)\n",
d304 1
a304 1
		if( t1 <= t0 )  rt_log("ERROR vol t1=%g < t0=%g\n", t1, t0 );
d325 2
a326 2
				RT_LIST_INSERT( &(seghead->l), &(segp->l) );
				if(rt_g.debug&DEBUG_VOL) rt_log("START t=%g, surfno=%d\n",
d340 1
a340 1
				tail = RT_LIST_LAST( seg, &(seghead->l) );
d353 1
a353 1
				if(rt_g.debug&DEBUG_VOL) rt_log("END t=%g, surfno=%d\n",
d373 1
a373 1
		tail = RT_LIST_LAST( seg, &(seghead->l) );
d384 1
a384 1
		if(rt_g.debug&DEBUG_VOL) rt_log("closed END t=%g, surfno=%d\n",
d388 1
a388 1
	if( RT_LIST_IS_EMPTY( &(seghead->l) ) )
d403 1
a403 1
CONST struct rt_external	*ep;
d416 1
a416 1
	RT_CK_EXTERNAL( ep );
d419 1
a419 1
		rt_log("rt_ebm_import: defective strsol record\n");
d425 1
a425 1
	ip->idb_ptr = rt_calloc(1, sizeof(struct rt_vol_internal), "rt_vol_internal");
d430 1
a430 1
	mat_idn( vip->mat );
d455 2
a456 2
	mat_mul( tmat, mat, vip->mat );
	mat_copy( vip->mat, tmat );
d462 1
a462 1
	vip->map = (unsigned char *)rt_calloc( 1, nbytes, "vol_import bitmap" );
d479 1
a479 1
				rt_log("rt_vol_import(%s): Unable to read whole VOL, y=%d, z=%d\n",
d501 1
a501 1
struct rt_external		*ep;
d519 1
a519 1
	RT_INIT_EXTERNAL(ep);
d521 1
a521 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "vol external");
d598 1
a598 1
	if( vip->map) rt_free( (char *)vip->map, "vol bitmap" );
d602 1
a602 1
	rt_free( (char *)vip, "vol ifree" );
d633 1
a633 1
	GETSTRUCT( volp, rt_vol_specific );
d638 1
a638 1
	mat_inv( volp->vol_mat, vip->mat );
d654 1
a654 1
	rt_rotate_bbox( stp->st_min, stp->st_max, vip->mat,
d679 2
a680 2
	rt_log("vol file = %s\n", volp->vol_i.file );
	rt_log("dimensions = (%d, %d, %d)\n",
d729 1
a729 1
		rt_log("rt_vol_norm(%s): surfno=%d bad\n",
d783 2
a784 2
	rt_free( (char *)volp->vol_i.map, "vol_map" );
	rt_free( (char *)volp, "rt_vol_specific" );
d798 1
a798 1
struct rt_list		*vhead;
d801 1
a801 1
struct rt_tol		*tol;
d900 1
a900 1
register struct rt_list	*vhead;
d934 1
a934 1
struct rt_tol		*tol;
d946 1
a946 1
	RT_CK_TOL( tol );
d956 1
a956 1
	s = RT_LIST_FIRST(shell, &r_tmp->s_hd);
d1158 1
a1158 1
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d1167 1
a1167 1
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
@


11.5
log
@Modified describe function to use local units.
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 11.4 1996/12/17 19:05:26 jra Exp jra $ (BRL)";
d464 1
a464 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d467 1
a467 1
		RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d470 1
a470 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d475 1
a475 1
			RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d477 1
a477 1
			RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d481 1
a481 1
				RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d483 1
a483 1
				RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d488 1
a488 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d490 1
a490 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
@


11.4
log
@Fixed many problems, matrix was ignored in plot routine, bounding rpp ignored
cellsize, plot routine calculated edges in yz plane twice, but ignored xy plane.
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 11.3 1996/08/31 11:04:24 mike Exp jra $ (BRL)";
d551 3
d556 2
d560 19
a578 2
	bu_vls_struct_print( str, rt_vol_parse, (char *)vip );
	bu_vls_strcat( str, "\n" );
@


11.3
log
@bn.h
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 11.2 1996/08/29 22:51:38 butler Exp mike $ (BRL)";
d167 1
d631 1
a631 1
		volp->vol_i.xdim, volp->vol_i.ydim, volp->vol_i.zdim );/* type conversion */
a784 1
	mat_t		mat;
a785 2
	mat_idn(mat);	/* XXX hack */

d794 3
a796 3
	for( z=0; z<vip->zdim; z++ )  {
		for( x=0; x<vip->xdim; x++ )  {
			for( y=0; y<vip->ydim; y++ )  {
d803 1
a803 1
				for( ++y; y<vip->ydim; y++ )  {
d812 1
a812 1
				rt_vol_plate( a,b,c,d, mat, vhead, vip );
d820 3
a822 3
	for( z=0; z<vip->zdim; z++ )  {
		for( y=0; y<vip->ydim; y++ )  {
			for( x=0; x<vip->xdim; x++ )  {
d829 1
a829 1
				for( ++x; x<vip->xdim; x++ )  {
d838 1
a838 1
				rt_vol_plate( a,b,c,d, mat, vhead, vip );
d846 3
a848 3
	for( y=0; y<vip->ydim; y++ )  {
		for( x=0; x<vip->xdim; x++ )  {
			for( z=0; z<vip->zdim; z++ )  {
d850 1
a850 1
				v2 = VOL(vip, x+1,y,z);
d853 3
a855 3
				VSET( a, (x+0.5), (y-0.5), (z-0.5) );
				VSET( b, (x+0.5), (y+0.5), (z-0.5) );
				for( ++z; z<vip->zdim; z++ )  {
d857 1
a857 1
					v2 = VOL(vip, x+1,y,z);
d862 3
a864 3
				VSET( c, (x+0.5), (y+0.5), (z-0.5) );
				VSET( d, (x+0.5), (y-0.5), (z-0.5) );
				rt_vol_plate( a,b,c,d, mat, vhead, vip );
@


11.2
log
@structparse moved to libbu
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 11.1 1995/01/04 09:57:09 mike Rel4_4 butler $ (BRL)";
d407 1
a407 1
	struct rt_vls	str;
d436 4
a439 4
	rt_vls_init( &str );
	rt_vls_strcpy( &str, rp->ss.ss_args );
	if( bu_structparse( &str, rt_vol_parse, (char *)vip ) < 0 )  {
		rt_vls_free( &str );
d442 1
a442 1
	rt_vls_free( &str );
d448 1
a448 1
	    	bu_structprint("Unreasonable VOL parameters", rt_vol_parse,
d507 1
a507 1
	struct rt_vls		str;
d523 2
a524 2
	RT_VLS_INIT( &str );
	bu_vls_structprint( &str, rt_vol_parse, (char *)&vol );
d528 2
a529 2
	strncpy( rec->ss.ss_args, rt_vls_addr(&str), DB_SS_LEN-1 );
	rt_vls_free( &str );
d543 1
a543 1
struct rt_vls		*str;
d552 1
a552 1
	rt_vls_strcat( str, "thresholded volumetric solid (VOL)\n\t");
d554 2
a555 2
	bu_vls_structprint( str, rt_vol_parse, (char *)vip );
	rt_vls_strcat( str, "\n" );
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 10.5 94/10/11 08:19:30 jra Exp $ (BRL)";
d55 1
a55 1
struct structparse rt_vol_parse[] = {
d438 1
a438 1
	if( rt_structparse( &str, rt_vol_parse, (char *)vip ) < 0 )  {
d448 1
a448 1
	    	rt_structprint("Unreasonable VOL parameters", rt_vol_parse,
d524 1
a524 1
	rt_vls_structprint( &str, rt_vol_parse, (char *)&vol );
d554 1
a554 1
	rt_vls_structprint( str, rt_vol_parse, (char *)vip );
@


10.5
log
@Added (int) casts to definition of VOL as suggested by Timothy G Smith in a bug report.
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/g_vol.c,v 10.4 94/09/23 15:49:26 jra Exp Locker: jra $ (BRL)";
@


10.4
log
@Added tessellator.
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 10.3 94/08/10 18:41:37 gdurf Exp Locker: jra $ (BRL)";
d101 1
a101 1
#define OK(_vip,_v)	( (_v) >= (_vip)->lo && (_v) <= (_vip)->hi )
@


10.3
log
@Added include of conf.h.
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 10.2 1993/07/20 15:35:10 mike Exp gdurf $ (BRL)";
d36 1
a38 1
#include "nmg.h"
d917 2
a918 2
#if 0
	register int	i;
d920 1
a920 2
	struct vertex	**verts;	/* dynamic array of pointers */
	struct vertex	***vertp;	/* dynam array of ptrs to pointers */
d922 2
a923 1
#endif
d925 4
d933 232
a1164 2
	/* XXX tess routine needed */
	return(-1);
@


10.2
log
@comment in comment.
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 10.1 91/10/12 06:40:28 mike Rel4_0 Locker: mike $ (BRL)";
d25 2
@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.23 91/09/20 23:35:45 butler Exp $ (BRL)";
d915 7
a921 5
/*	register int	i; */
/*	struct shell	*s; */
/*	struct vertex	**verts;	/* dynamic array of pointers */
/*	struct vertex	***vertp;	/* dynam array of ptrs to pointers */
/*	struct faceuse	*fu; */
@


1.23
log
@removing fuzz with lint
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.22 91/08/29 22:20:40 mike Exp $ (BRL)";
@


1.22
log
@Needed nmg.h
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.21 91/07/05 23:40:22 mike Exp $ (BRL)";
a504 1
	register int		i;
a545 1
	register int			j;
a547 2
	char				buf[256];
	int				i;
a567 1
	register int			i;
d722 2
a723 2
	register struct rt_vol_specific *volp =
		(struct rt_vol_specific *)stp->st_specific;
d742 2
a743 2
	register struct rt_vol_specific *volp =
		(struct rt_vol_specific *)stp->st_specific;
a781 1
	int		i;
d915 5
a919 5
	register int	i;
	struct shell	*s;
	struct vertex	**verts;	/* dynamic array of pointers */
	struct vertex	***vertp;	/* dynam array of ptrs to pointers */
	struct faceuse	*fu;
@


1.21
log
@ANSI structure initialization
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.20 91/06/30 00:09:00 mike Exp $ (BRL)";
d36 1
@


1.20
log
@Some args are now CONST.
Protected all STDIO fread stuff with RES_ACQUIRE( res_syscall ).
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.19 91/06/22 22:30:43 mike Exp $ (BRL)";
d54 1
a54 1
	"%s",	RT_VOL_NAME_LEN, "file",	1,		FUNC_NULL,
d56 1
a56 1
	"%s",	RT_VOL_NAME_LEN, "file",	offsetofarray(struct rt_vol_internal, file), FUNC_NULL,
d58 8
a65 8
	"%d",	1, "w",		VOL_O(xdim),	FUNC_NULL,
	"%d",	1, "n",		VOL_O(ydim),	FUNC_NULL,
	"%d",	1, "d",		VOL_O(zdim),	FUNC_NULL,
	"%d",	1, "lo",	VOL_O(lo),		FUNC_NULL,
	"%d",	1, "hi",	VOL_O(hi),		FUNC_NULL,
	"%f",	ELEMENTS_PER_VECT, "size",offsetofarray(struct rt_vol_internal, cellsize), FUNC_NULL,
	"%f",	16, "mat", offsetofarray(struct rt_vol_internal,mat), FUNC_NULL,
	"",	0, (char *)0,	0,			FUNC_NULL
@


1.19
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.18 91/06/14 06:48:35 mike Exp $ (BRL)";
d398 3
a400 3
struct rt_db_internal	*ip;
struct rt_external	*ep;
mat_t			mat;
d410 1
d460 1
d463 1
a463 1
err:
d466 1
d471 7
a477 3
			if( fread( &VOL(vip, 0, y, z), vip->xdim, 1, fp ) < 1 )  {
				rt_log("Unable to read whole VOL, y=%d, z=%d\n",
					y, z);
d479 2
a480 1
				goto err;
d484 1
d486 1
d497 3
a499 3
struct rt_external	*ep;
struct rt_db_internal	*ip;
double			local2mm;
d653 1
a653 1
register struct soltab	*stp;
d655 1
a655 1
	register struct rt_vol_specific *volp =
@


1.18
log
@Modified to use new string solid database record.
Can now be rotated, xlated, and scaled.
Eliminated use of st_pathmat
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.17 91/05/18 03:01:46 mike Exp $ (BRL)";
d112 1
a112 1
rt_vol_shot( stp, rp, ap, seghead, tol )
a116 1
CONST struct rt_tol	*tol;
d587 1
a587 1
rt_vol_prep( stp, ip, rtip, tol )
a590 1
CONST struct rt_tol	*tol;
@


1.17
log
@Converted to new tolerance interface
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.16 91/02/17 20:05:01 mike Exp $ (BRL)";
d64 1
a64 1
	/* XXX might have option for vol_origin */
a395 2
 *
 *  XXX no way to deal with mat !!!
d410 1
a410 1
	char		*cp;
a424 5
	cp = rp->ss.ss_str;
	while( *cp && !isspace(*cp) )  cp++;
	/* Skip all white space */
	while( *cp && isspace(*cp) )  cp++;

d426 1
d434 1
a434 1
	rt_vls_strcpy( &str, cp);
d443 1
a443 1
	    vip->ydim < 1 || vip->zdim < 1 ||
d445 2
a446 2
	    	rt_log("Unreasonable VOL parameters\n");
	    	rt_structprint("unreasonable", rt_vol_parse, (char *)vip );
d450 4
a484 2
 *  Generally, only libwdb will set conv2mm != 1.0
 *  XXX no way to deal with local2mm !!
d493 1
d502 1
d504 3
d508 1
a508 1
	ep->ext_nbytes = sizeof(union record);
d513 1
a513 1
	rt_vls_structprint( &str, rt_vol_parse, (char *)vip );
d516 3
a518 1
	(void)sprintf( rec->ss.ss_str, "vol %s", rt_vls_addr( & str ) );
a519 1
	rt_vls_free( &str );
d609 1
a609 1
	mat_inv( volp->vol_mat, stp->st_pathmat );
d611 1
a611 1
	/* Pre-compute the necessary normals */
d613 1
a613 1
	MAT4X3VEC( volp->vol_xnorm, stp->st_pathmat, norm );
d615 1
a615 1
	MAT4X3VEC( volp->vol_ynorm, stp->st_pathmat, norm );
d617 1
a617 1
	MAT4X3VEC( volp->vol_znorm, stp->st_pathmat, norm );
d625 1
a625 1
	rt_rot_bound_rpp( stp->st_min, stp->st_max, stp->st_pathmat,
@


1.16
log
@Check return code from structparse
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.15 91/01/28 23:53:24 mike Exp $ (BRL)";
d112 1
a112 1
rt_vol_shot( stp, rp, ap, seghead )
d117 1
d586 1
a586 1
rt_vol_prep( stp, ip, rtip )
d590 1
d766 1
a766 1
rt_vol_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
d769 2
a770 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
d902 1
a902 1
rt_vol_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d906 2
a907 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
@


1.15
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.14 91/01/26 03:15:04 mike Exp $ (BRL)";
d440 4
a443 1
	rt_structparse( &str, rt_vol_parse, (char *)vip );
@


1.14
log
@Eliminated mat parameter on ft_plot and ft_tess
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.13 91/01/25 21:19:23 mike Exp $ (BRL)";
d69 1
a69 1
	mat_t mat, struct vlhead *vhead, struct rt_vol_internal *vip));
d762 1
a762 1
struct vlhead		*vhead;
d869 1
a869 1
register struct vlhead	*vhead;
d877 1
a877 1
	ADD_VL( vhead, arot, 0 );
d881 1
a881 1
	ADD_VL( vhead, prot, 1 );
d885 1
a885 1
	ADD_VL( vhead, prot, 1 );
d889 1
a889 1
	ADD_VL( vhead, prot, 1 );
d891 1
a891 1
	ADD_VL( vhead, arot, 1 );
@


1.13
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.12 91/01/25 20:23:24 mike Exp $ (BRL)";
d761 6
a766 7
rt_vol_plot( vhead, mat, ip, abs_tol, rel_tol, norm_tol )
struct vlhead	*vhead;
mat_t		mat;
struct rt_db_internal *ip;
double		abs_tol;
double		rel_tol;
double		norm_tol;
d773 1
d775 2
d898 1
a898 1
rt_vol_tess( r, m, ip, mat, abs_tol, rel_tol, norm_tol )
d902 3
a904 4
register mat_t		mat;
double		abs_tol;
double		rel_tol;
double		norm_tol;
@


1.12
log
@Converted to new import/export interface
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.11 91/01/05 03:08:38 mike Exp $ (BRL)";
a580 1
#if NEW_IF
a586 10
#else
int
rt_vol_prep( stp, rec, rtip )
struct soltab	*stp;
union record	*rec;
struct rt_i	*rtip;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a593 12
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rec;
	ep->ext_nbytes = stp->st_dp->d_len*sizeof(union record);
	ip = &intern;
	if( rt_vol_import( ip, ep, stp->st_pathmat ) < 0 )
		return(-1);		/* BAD */
	RT_CK_DB_INTERNAL( ip );
#endif
a759 1
#if NEW_IF
a768 11
#else
int
rt_vol_plot( rp, mat, vhead, dp )
union record	*rp;
mat_t		mat;
struct vlhead	*vhead;
struct directory *dp;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a774 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_vol_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_vol_plot(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
a894 1
#if NEW_IF
a904 14
#else
int
rt_vol_tess( r, m, rp, mat, dp, abs_tol, rel_tol )
struct nmgregion	**r;
struct model		*m;
register union record	*rp;
register mat_t		mat;
struct directory	*dp;
double			abs_tol;
double			rel_tol;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a911 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_vol_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_vol_tess(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
@


1.11
log
@Converted to new format for fmt entry in structparse
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/g_vol.c,v 1.10 90/12/21 21:00:46 mike Exp $ (BRL)";
d32 3
d39 2
a40 7
#define VOL_NAME_LEN 128
struct vol_specific {
	char		vol_file[VOL_NAME_LEN];
	unsigned char	*vol_map;
	int		vol_xdim;	/* X dimension */
	int		vol_ydim;	/* Y dimension */
	int		vol_zdim;	/* Z dimension */
a43 1
	vect_t		vol_cellsize;	/* ideal coords: size of each cell */
a46 2
	int		vol_lo;		/* Low threshold */
	int		vol_hi;		/* High threshold */
d48 1
a48 2
#define VOL_NULL	((struct vol_specific *)0)
#define VOL_O(m)	offsetof(struct vol_specific, m)
d50 2
d54 1
a54 1
	"%s",	VOL_NAME_LEN, "file",	0,		FUNC_NULL,
d56 1
a56 1
	"%s",	VOL_NAME_LEN, "file",	offsetofarray(struct vol_specific, vol_file), FUNC_NULL,
d58 6
a63 6
	"%d",	1, "w",		VOL_O(vol_xdim),	FUNC_NULL,
	"%d",	1, "n",		VOL_O(vol_ydim),	FUNC_NULL,
	"%d",	1, "d",		VOL_O(vol_zdim),	FUNC_NULL,
	"%d",	1, "lo",	VOL_O(vol_lo),		FUNC_NULL,
	"%d",	1, "hi",	VOL_O(vol_hi),		FUNC_NULL,
	"%f",	ELEMENTS_PER_VECT, "size",offsetofarray(struct vol_specific, vol_cellsize), FUNC_NULL,
d69 1
a69 2
	mat_t mat, struct vlhead *vhead, struct vol_specific *volp));
RT_EXTERN(struct vol_specific *rt_vol_import, (union record *rp));
d93 4
a96 4
#define VOL(xx,yy,zz)	volp->vol_map[ \
	(((zz)+VOL_ZWIDEN) * (volp->vol_ydim + VOL_YWIDEN*2)+ \
	 ((yy)+VOL_YWIDEN))* (volp->vol_xdim + VOL_XWIDEN*2)+ \
	  (xx)+VOL_XWIDEN ]
d98 1
a98 1
#define OK(v)	( (v) >= volp->vol_lo && (v) <= volp->vol_hi )
d118 2
a119 2
	register struct vol_specific *volp =
		(struct vol_specific *)stp->st_specific;
d167 1
a167 1
if(rt_g.debug&DEBUG_VOL)VPRINT("cellsize", volp->vol_cellsize);
d173 3
a175 3
	igrid[X] = (P[X] - volp->vol_origin[X]) / volp->vol_cellsize[X];
	igrid[Y] = (P[Y] - volp->vol_origin[Y]) / volp->vol_cellsize[Y];
	igrid[Z] = (P[Z] - volp->vol_origin[Z]) / volp->vol_cellsize[Z];
d178 2
a179 2
	} else if( igrid[X] >= volp->vol_xdim ) {
		igrid[X] = volp->vol_xdim-1;
d183 2
a184 2
	} else if( igrid[Y] >= volp->vol_ydim ) {
		igrid[Y] = volp->vol_ydim-1;
d188 2
a189 2
	} else if( igrid[Z] >= volp->vol_zdim ) {
		igrid[Z] = volp->vol_zdim-1;
d200 1
a200 1
		t[X] = (volp->vol_origin[X] + j*volp->vol_cellsize[X] -
d202 1
a202 1
		delta[X] = volp->vol_cellsize[X] * fabs(invdir[X]);
d211 1
a211 1
		t[Y] = (volp->vol_origin[Y] + j*volp->vol_cellsize[Y] -
d213 1
a213 1
		delta[Y] = volp->vol_cellsize[Y] * fabs(invdir[Y]);
d222 1
a222 1
		t[Z] = (volp->vol_origin[Z] + j*volp->vol_cellsize[Z] -
d224 1
a224 1
		delta[Z] = volp->vol_cellsize[Z] * fabs(invdir[Z]);
d292 1
a292 1
		val = VOL( igrid[X], igrid[Y], igrid[Z] );
d302 1
a302 1
			if( OK( val ) )  {
d328 1
a328 1
			if( OK( val ) )  {
d391 6
d398 5
a402 3
HIDDEN struct vol_specific *
rt_vol_import( rp )
union record	*rp;
d404 5
a408 3
	register struct vol_specific *volp;
	FILE	*fp;
	int	nbytes;
d411 1
a411 3
	char	*str;
	char	*cp;
	struct rt_vls vls;
d413 6
a418 1
	GETSTRUCT( volp, vol_specific );
d420 5
a424 1
	rt_vls_init( &vls );
d432 2
a433 2
	volp->vol_lo = 0;
	volp->vol_hi = 255;
d436 1
a436 1
	VSETALL( volp->vol_cellsize, 1 );
d438 4
a441 3
	rt_vls_strcpy( &vls, cp);
	rt_structparse( &vls, rt_vol_parse, (char *)volp );
	rt_vls_free( &vls );
d444 3
a446 3
	if( volp->vol_file[0] == '\0' || volp->vol_xdim < 1 ||
	    volp->vol_ydim < 1 || volp->vol_zdim < 1 ||
	    volp->vol_lo < 0 || volp->vol_hi > 255 )  {
d448 2
a449 3
	    	rt_structprint("unreasonable", rt_vol_parse, (char *)volp );
		rt_free( (char *)volp, "vol_specific" );
		return( VOL_NULL );
d453 7
a459 11
	nbytes = (volp->vol_xdim+VOL_XWIDEN*2)*
		(volp->vol_ydim+VOL_YWIDEN*2)*
		(volp->vol_zdim+VOL_ZWIDEN*2);
	volp->vol_map = (unsigned char *)rt_malloc( nbytes, "vol_import bitmap" );
#ifdef SYSV
	memset( volp->vol_map, 0, nbytes );
#else
	bzero( volp->vol_map, nbytes );
#endif
	if( (fp = fopen(volp->vol_file, "r")) == NULL )  {
		perror(volp->vol_file);
d461 1
a461 3
		rt_free( (char *)volp->vol_map, "vol_map" );
		rt_free( (char *)volp, "vol_specific" );
		return( VOL_NULL );
d465 5
a469 4
	for( z=0; z < volp->vol_zdim; z++ )  {
		for( y=0; y < volp->vol_ydim; y++ )  {
			if( fread( &VOL(0, y, z), volp->vol_xdim, 1, fp ) < 1 )  {
				rt_log("Unable to read whole VOL\n");
d476 1
a476 1
	return( volp );
d480 91
d578 1
a578 1
 *	A struct vol_specific is created, and it's address is stored
d581 1
d583 8
a590 1
rt_vol_prep( stp, rp, rtip )
d592 1
a592 1
union record	*rp;
d595 5
a599 1
	register struct vol_specific *volp;
d605 14
a618 2
	if( (volp = rt_vol_import( rp )) == VOL_NULL )
		return(-1);	/* ERROR */
d620 4
d640 1
a640 1
		volp->vol_xdim, volp->vol_ydim, volp->vol_zdim );/* type conversion */
d663 2
a664 2
	register struct vol_specific *volp =
		(struct vol_specific *)stp->st_specific;
d666 1
a666 1
	rt_log("vol file = %s\n", volp->vol_file );
d668 3
a670 3
		volp->vol_xdim, volp->vol_ydim,
		volp->vol_zdim );
	VPRINT("model cellsize", volp->vol_cellsize);
d688 2
a689 2
	register struct vol_specific *volp =
		(struct vol_specific *)stp->st_specific;
d734 2
a735 2
	register struct vol_specific *volp =
		(struct vol_specific *)stp->st_specific;
d754 2
a755 2
	register struct vol_specific *volp =
		(struct vol_specific *)stp->st_specific;
d767 2
a768 2
	register struct vol_specific *volp =
		(struct vol_specific *)stp->st_specific;
d770 2
a771 2
	rt_free( (char *)volp->vol_map, "vol_map" );
	rt_free( (char *)volp, "vol_specific" );
d783 1
d785 11
a795 1
rt_vol_plot( rp, matp, vhead, dp )
d797 1
a797 1
mat_t		matp;
d801 4
a804 1
	register struct vol_specific *volp;
d808 1
d810 17
a826 2
	if( (volp = rt_vol_import( rp )) == VOL_NULL )
		return(-1);
d832 6
a837 6
	for( z=0; z<volp->vol_zdim; z++ )  {
		for( x=0; x<volp->vol_xdim; x++ )  {
			for( y=0; y<volp->vol_ydim; y++ )  {
				v1 = VOL(x,y,z);
				v2 = VOL(x+1,y,z);
				if( OK(v1) == OK(v2) )  continue;
d841 4
a844 4
				for( ++y; y<volp->vol_ydim; y++ )  {
					v1 = VOL(x,y,z);
					v2 = VOL(x+1,y,z);
					if( OK(v1) == OK(v2) )
d850 1
a850 1
				rt_vol_plate( a,b,c,d, matp, vhead, volp );
d858 6
a863 6
	for( z=0; z<volp->vol_zdim; z++ )  {
		for( y=0; y<volp->vol_ydim; y++ )  {
			for( x=0; x<volp->vol_xdim; x++ )  {
				v1 = VOL(x,y,z);
				v2 = VOL(x,y+1,z);
				if( OK(v1) == OK(v2) )  continue;
d867 4
a870 4
				for( ++x; x<volp->vol_xdim; x++ )  {
					v1 = VOL(x,y,z);
					v2 = VOL(x,y+1,z);
					if( OK(v1) == OK(v2) )
d876 1
a876 1
				rt_vol_plate( a,b,c,d, matp, vhead, volp );
d884 6
a889 6
	for( y=0; y<volp->vol_ydim; y++ )  {
		for( x=0; x<volp->vol_xdim; x++ )  {
			for( z=0; z<volp->vol_zdim; z++ )  {
				v1 = VOL(x,y,z);
				v2 = VOL(x+1,y,z);
				if( OK(v1) == OK(v2) )  continue;
d893 4
a896 4
				for( ++z; z<volp->vol_zdim; z++ )  {
					v1 = VOL(x,y,z);
					v2 = VOL(x+1,y,z);
					if( OK(v1) == OK(v2) )
d902 1
a902 1
				rt_vol_plate( a,b,c,d, matp, vhead, volp );
d913 1
a913 1
rt_vol_plate( a,b,c,d, mat, vhead, volp )
d917 1
a917 1
register struct vol_specific	*volp;
d922 1
a922 1
	VELMUL( s, volp->vol_cellsize, a );
d926 1
a926 1
	VELMUL( s, volp->vol_cellsize, b );
d930 1
a930 1
	VELMUL( s, volp->vol_cellsize, c );
d934 1
a934 1
	VELMUL( s, volp->vol_cellsize, d );
d939 57
@


1.10
log
@Changed word "index" to "axis", to be more descriptive
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.9 90/12/21 14:38:16 mike Exp $ (BRL)";
d69 1
a69 1
	(char *)0, 0, (char *)0,	0,		FUNC_NULL
@


1.9
log
@Added rt_ prefix to all routines
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.8 90/12/18 00:20:33 butler Exp $ (BRL)";
d134 2
a135 2
	int	in_index;
	int	out_index;
d239 1
a239 1
		in_index = X;
d242 1
a242 1
		in_index = Y;
d246 1
a246 1
		in_index = Z;
d249 1
a249 1
if(rt_g.debug&DEBUG_VOL)rt_log("Entry index is %s, t0=%g\n", in_index==X ? "X" : (in_index==Y?"Y":"Z"), t0);
d280 1
a280 1
				out_index = Z;
d283 1
a283 1
				out_index = X;
d288 1
a288 1
				out_index = Z;
d291 1
a291 1
				out_index = Y;
d301 2
a302 2
if(rt_g.debug&DEBUG_VOL)rt_log("Exit index is %s, t[]=(%g, %g, %g)\n",
			out_index==X ? "X" : (out_index==Y?"Y":"Z"),
d317 1
a317 1
				if( rp->r_dir[in_index] < 0 )  {
d320 1
a320 1
						rt_vol_normtab[in_index];
d324 1
a324 1
						(-rt_vol_normtab[in_index]);
d345 1
a345 1
				if( rp->r_dir[in_index] < 0 )  {
d348 1
a348 1
						(-rt_vol_normtab[in_index]);
d352 1
a352 1
						rt_vol_normtab[in_index];
d361 4
a364 4
		in_index = out_index;
		t[out_index] += delta[out_index];
		if( rp->r_dir[out_index] > 0 ) {
			igrid[out_index]++;
d366 1
a366 1
			igrid[out_index]--;
d377 2
a378 2
		/* Compute exit normal.  Previous out_index is now in_index */
		if( rp->r_dir[in_index] < 0 )  {
d380 1
a380 1
			tail->seg_out.hit_surfno = (-rt_vol_normtab[in_index]);
d383 1
a383 1
			tail->seg_out.hit_surfno = rt_vol_normtab[in_index];
@


1.8
log
@Converted to new structparse, with vls strings
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.7 90/12/05 20:30:03 mike Exp $ (BRL)";
d56 1
a56 1
struct structparse vol_parse[] = {
d72 3
a74 1
struct vol_specific	*vol_import();
d105 1
a105 1
static int vol_normtab[3] = { NORM_XPOS, NORM_YPOS, NORM_ZPOS };
d109 1
a109 1
 *			V O L _ S H O T
d117 1
a117 1
vol_shot( stp, rp, ap, seghead )
d320 1
a320 1
						vol_normtab[in_index];
d324 1
a324 1
						(-vol_normtab[in_index]);
d348 1
a348 1
						(-vol_normtab[in_index]);
d352 1
a352 1
						vol_normtab[in_index];
d380 1
a380 1
			tail->seg_out.hit_surfno = (-vol_normtab[in_index]);
d383 1
a383 1
			tail->seg_out.hit_surfno = vol_normtab[in_index];
d395 1
a395 1
 *			V O L _ I M P O R T
d398 1
a398 1
vol_import( rp )
d427 1
a427 1
	rt_structparse( &vls, vol_parse, (char *)volp );
d435 1
a435 1
	    	rt_structprint("unreasonable", vol_parse, (char *)volp );
d473 1
a473 1
 *			V O L _ P R E P
d481 1
a481 1
 *	in stp->st_specific for use by vol_shot().
d484 1
a484 1
vol_prep( stp, rp, rtip )
d495 1
a495 1
	if( (volp = vol_import( rp )) == VOL_NULL )
d531 1
a531 1
 *			V O L _ P R I N T
d534 1
a534 1
vol_print( stp )
d549 1
a549 1
 *			V O L _ N O R M
d557 1
a557 1
vol_norm( hitp, stp, rp )
d590 1
a590 1
		rt_log("vol_norm(%s): surfno=%d bad\n",
d598 1
a598 1
 *			V O L _ C U R V E
d603 1
a603 1
vol_curve( cvp, hitp, stp )
d616 1
a616 1
 *			V O L _ U V
d622 1
a622 1
vol_uv( ap, stp, hitp, uvp )
d635 1
a635 1
 * 			V O L _ F R E E
d638 1
a638 1
vol_free( stp )
d649 1
a649 1
vol_class()
d655 1
a655 1
 *			V O L _ P L O T
d658 1
a658 1
vol_plot( rp, matp, vhead, dp )
d669 1
a669 1
	if( (volp = vol_import( rp )) == VOL_NULL )
d694 1
a694 1
				vol_plate( a,b,c,d, matp, vhead, volp );
d720 1
a720 1
				vol_plate( a,b,c,d, matp, vhead, volp );
d746 1
a746 1
				vol_plate( a,b,c,d, matp, vhead, volp );
d753 5
a757 1
vol_plate( a,b,c,d, mat, vhead, volp )
@


1.7
log
@Fixed return codes on _plot()
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.6 90/10/15 12:01:07 mike Exp $ (BRL)";
d36 1
d38 1
a38 1
	char		vol_file[128];
d58 1
a58 1
	"%s",	"file",		0,			FUNC_NULL,
d60 1
a60 1
	"%s",	"file",	offsetofarray(struct vol_specific, vol_file),	FUNC_NULL,
d62 6
a67 6
	"%d",	"w",		VOL_O(vol_xdim),	FUNC_NULL,
	"%d",	"n",		VOL_O(vol_ydim),	FUNC_NULL,
	"%d",	"d",		VOL_O(vol_zdim),	FUNC_NULL,
	"%d",	"lo",		VOL_O(vol_lo),		FUNC_NULL,
	"%d",	"hi",		VOL_O(vol_hi),		FUNC_NULL,
	"%V",	"size",	offsetofarray(struct vol_specific, vol_cellsize), FUNC_NULL,
d69 1
a69 1
	(char *)0,(char *)0,	0,			FUNC_NULL
d406 1
d410 3
a412 3
	str = rt_strdup( rp->ss.ss_str );
	/* First word is name of solid type (eg, "vol") -- skip over it */
	cp = str;
d424 3
a426 2
	rt_structparse( cp, vol_parse, (char *)volp );
	rt_free( str, "ss_str" );
@


1.6
log
@Changed from using hit_private to hit_surfno for surface indicator
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.5 90/10/06 02:05:28 mike Exp $ (BRL)";
d652 1
a652 1
void
d665 1
a665 1
		return;
d745 1
@


1.5
log
@Converted seg structures to use doubly linked lists.
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: /m/cad/librt/RCS/g_vol.c,v 1.4 90/03/14 15:06:12 mike Exp $ (BRL)";
d316 1
a316 1
					segp->seg_in.hit_private = (char *)
d320 1
a320 1
					segp->seg_in.hit_private = (char *)
d324 2
a325 2
				if(rt_g.debug&DEBUG_VOL) rt_log("START t=%g, n=%d\n",
					t0, segp->seg_in.hit_private);
d344 1
a344 1
					tail->seg_out.hit_private = (char *)
d348 1
a348 1
					tail->seg_out.hit_private = (char *)
d351 2
a352 2
				if(rt_g.debug&DEBUG_VOL) rt_log("END t=%g, n=%d\n",
					t0, tail->seg_out.hit_private );
d377 1
a377 2
			tail->seg_out.hit_private = (char *)
				(-vol_normtab[in_index]);
d380 1
a380 2
			tail->seg_out.hit_private = (char *)
				vol_normtab[in_index];
d382 2
a383 2
		if(rt_g.debug&DEBUG_VOL) rt_log("closed END t=%g, n=%d\n",
			tmax, tail->seg_out.hit_private );
d562 1
a562 1
	switch( (int) hitp->hit_private )  {
d585 2
a586 2
		rt_log("vol_norm(%s): norm code %d bad\n",
			stp->st_name, hitp->hit_private );
@


1.4
log
@Changed type of st_specific to genptr_t
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: g_vol.c,v 1.3 89/12/29 21:30:54 mike Locked $ (BRL)";
d113 2
a114 2
struct seg *
vol_shot( stp, rp, ap )
d118 1
a130 2
	struct seg	*head;
	struct seg	*tail;
a140 2
	head = tail = SEG_NULL;

d309 1
a309 1
				GET_SEG(segp, ap->a_resource);
d323 1
a323 12
				segp->seg_next = SEG_NULL;
				if( head == SEG_NULL ||
				    tail == SEG_NULL )  {
					/* Install as beginning of list */
					tail = segp;
					head = segp;
				} else {
					/* Append to list */
					tail->seg_next = segp;
					tail = segp;
				}

d333 1
d338 1
d368 2
d371 1
d388 3
a390 1
	return(head);
@


1.3
log
@offsetof() can't be given an array argument.
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: g_vol.c,v 1.2 89/12/29 21:23:09 mike Locked $ (BRL)";
d513 1
a513 1
	stp->st_specific = (int *)volp;
@


1.2
log
@Fixed minor subscripting error
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: g_vol.c,v 1.1 89/10/13 20:36:22 mike Locked $ (BRL)";
d39 3
a41 1
	int		vol_dim[3];
d61 3
a63 3
	"%d",	"w",		VOL_O(vol_dim[0]),	FUNC_NULL,
	"%d",	"n",		VOL_O(vol_dim[1]),	FUNC_NULL,
	"%d",	"d",		VOL_O(vol_dim[2]),	FUNC_NULL,
d66 1
a66 1
	"%V",	"size",		VOL_O(vol_cellsize[0]),	FUNC_NULL,
d96 2
a97 2
	(((zz)+VOL_ZWIDEN) * (volp->vol_dim[Y] + VOL_YWIDEN*2)+ \
	 ((yy)+VOL_YWIDEN))* (volp->vol_dim[X] + VOL_XWIDEN*2)+ \
d183 2
a184 2
	} else if( igrid[X] >= volp->vol_dim[X] ) {
		igrid[X] = volp->vol_dim[X]-1;
d188 2
a189 2
	} else if( igrid[Y] >= volp->vol_dim[Y] ) {
		igrid[Y] = volp->vol_dim[Y]-1;
d193 2
a194 2
	} else if( igrid[Z] >= volp->vol_dim[Z] ) {
		igrid[Z] = volp->vol_dim[Z]-1;
d435 2
a436 2
	if( volp->vol_file[0] == '\0' || volp->vol_dim[X] < 1 ||
	    volp->vol_dim[Y] < 1 || volp->vol_dim[Z] < 1 ||
d445 3
a447 3
	nbytes = (volp->vol_dim[X]+VOL_XWIDEN*2)*
		(volp->vol_dim[Y]+VOL_YWIDEN*2)*
		(volp->vol_dim[Z]+VOL_ZWIDEN*2);
d463 3
a465 3
	for( z=0; z < volp->vol_dim[Z]; z++ )  {
		for( y=0; y < volp->vol_dim[Y]; y++ )  {
			if( fread( &VOL(0, y, z), volp->vol_dim[X], 1, fp ) < 1 )  {
d517 2
a518 1
	VMOVE( volp->vol_large, volp->vol_dim );	/* type conversion */
d546 2
a547 2
		volp->vol_dim[X], volp->vol_dim[Y],
		volp->vol_dim[Z] );
d680 3
a682 3
	for( z=0; z<volp->vol_dim[Z]; z++ )  {
		for( x=0; x<volp->vol_dim[X]; x++ )  {
			for( y=0; y<volp->vol_dim[Y]; y++ )  {
d689 1
a689 1
				for( ++y; y<volp->vol_dim[Y]; y++ )  {
d706 3
a708 3
	for( z=0; z<volp->vol_dim[Z]; z++ )  {
		for( y=0; y<volp->vol_dim[Y]; y++ )  {
			for( x=0; x<volp->vol_dim[X]; x++ )  {
d715 1
a715 1
				for( ++x; x<volp->vol_dim[X]; x++ )  {
d732 3
a734 3
	for( y=0; y<volp->vol_dim[Y]; y++ )  {
		for( x=0; x<volp->vol_dim[X]; x++ )  {
			for( z=0; z<volp->vol_dim[Z]; z++ )  {
d741 1
a741 1
				for( ++z; z<volp->vol_dim[Z]; z++ )  {
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
static char RCSvol[] = "@@(#)$Header: g_vol.c,v 9.2 89/10/10 16:16:53 mike Locked $ (BRL)";
d94 3
a96 3
	((zz)+VOL_ZWIDEN)*(volp->vol_dim[Y] + VOL_YWIDEN*2)+ \
	((yy)+VOL_YWIDEN)*(volp->vol_dim[X] + VOL_XWIDEN*2)+ \
	(xx)+VOL_XWIDEN ]
@
