head	11.37;
access;
symbols
	ansi-20040405-merged:11.33.2.2
	postmerge-20040405-ansi:11.35
	premerge-20040404-ansi:11.34
	postmerge-autoconf:11.34
	autoconf-freeze:11.33.10.2
	premerge-autoconf:11.34
	ansi-20040316-freeze:11.33.2.1
	postmerge-20040315-windows:11.34
	premerge-20040315-windows:11.34
	windows-20040315-freeze:11.33.4.1
	autoconf-20031203:11.33
	autoconf-20031202:11.33
	autoconf-branch:11.33.0.10
	phong-branch:11.33.0.8
	photonmap-branch:11.33.0.6
	rel-6-1-DP:11.33
	windows-branch:11.33.0.4
	rel-6-0-2:11.31
	ansi-branch:11.33.0.2
	rel-6-0-1-branch:11.31.0.2
	hartley-6-0-post:11.32
	hartley-6-0-pre:11.31
	rel-6-0-1:11.31
	rel-6-0:11.31
	rel-5-4:11.27
	offsite-5-3-pre:11.30
	rel-5-3:11.27
	rel-5-2:11.27
	rel-5-1-branch:11.27.0.2
	rel-5-1:11.27
	rel-5-0:11.24
	rel-5-0-beta:11.22
	rel-4-5:11.22
	ctj-4-5-post:11.20
	ctj-4-5-pre:11.19
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.37
date	2004.05.21.18.07.33;	author morrison;	state dead;
branches;
next	11.36;

11.36
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.35;

11.35
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.34;

11.34
date	2004.02.02.17.39.24;	author morrison;	state Exp;
branches;
next	11.33;

11.33
date	2002.08.20.17.08.05;	author jra;	state Exp;
branches
	11.33.2.1
	11.33.4.1
	11.33.10.1;
next	11.32;

11.32
date	2002.08.15.20.55.17;	author hartley;	state Exp;
branches;
next	11.31;

11.31
date	2001.04.20.22.29.51;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2000.08.22.21.27.08;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.08.21.02.02.33;	author butler;	state Exp;
branches;
next	11.28;

11.28
date	2000.07.10.23.01.44;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	99.12.29.21.15.40;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	99.12.22.02.24.06;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	99.12.07.03.32.12;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	99.07.02.22.19.25;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	99.06.03.01.39.14;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	97.09.09.13.51.20;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	97.08.15.19.22.43;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	97.06.10.12.31.41;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	96.05.24.15.03.18;	author stay;	state Exp;
branches;
next	11.16;

11.16
date	96.04.22.12.18.05;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	96.03.25.20.51.36;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	96.03.05.21.33.17;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	95.12.02.03.09.46;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	95.12.01.02.53.58;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	95.11.30.22.43.16;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	95.11.30.19.04.33;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	95.11.29.23.52.40;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	95.09.06.14.57.45;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	95.04.03.19.56.28;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.03.05.17.29.10;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.02.21.02.45.22;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.02.07.03.51.25;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.02.06.23.10.42;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.18.13.32.16;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.02;	author mike;	state Rel4_4;
branches;
next	10.60;

10.60
date	94.11.28.16.08.13;	author jra;	state Exp;
branches;
next	10.59;

10.59
date	94.11.18.16.21.54;	author jra;	state Exp;
branches;
next	10.58;

10.58
date	94.11.17.17.00.26;	author jra;	state Exp;
branches;
next	10.57;

10.57
date	94.11.16.17.02.37;	author jra;	state Exp;
branches;
next	10.56;

10.56
date	94.11.10.15.36.09;	author jra;	state Exp;
branches;
next	10.55;

10.55
date	94.11.04.06.10.02;	author mike;	state Exp;
branches;
next	10.54;

10.54
date	94.09.21.03.50.10;	author mike;	state Exp;
branches;
next	10.53;

10.53
date	94.09.21.03.11.59;	author mike;	state Exp;
branches;
next	10.52;

10.52
date	94.09.16.21.58.51;	author mike;	state Exp;
branches;
next	10.51;

10.51
date	94.09.16.21.39.30;	author mike;	state Exp;
branches;
next	10.50;

10.50
date	94.09.16.20.45.57;	author mike;	state Exp;
branches;
next	10.49;

10.49
date	94.09.16.04.05.21;	author mike;	state Exp;
branches;
next	10.48;

10.48
date	94.09.15.23.47.08;	author mike;	state Exp;
branches;
next	10.47;

10.47
date	94.09.15.13.42.43;	author mike;	state Exp;
branches;
next	10.46;

10.46
date	94.09.14.16.57.11;	author jra;	state Exp;
branches;
next	10.45;

10.45
date	94.09.14.15.59.03;	author mike;	state Exp;
branches;
next	10.44;

10.44
date	94.09.13.21.02.03;	author mike;	state Exp;
branches;
next	10.43;

10.43
date	94.09.13.20.57.16;	author mike;	state Exp;
branches;
next	10.42;

10.42
date	94.09.10.05.13.40;	author mike;	state Exp;
branches;
next	10.41;

10.41
date	94.09.10.04.37.08;	author mike;	state Exp;
branches;
next	10.40;

10.40
date	94.09.03.03.00.37;	author mike;	state Exp;
branches;
next	10.39;

10.39
date	94.09.02.19.07.49;	author mike;	state Exp;
branches;
next	10.38;

10.38
date	94.09.02.17.58.45;	author mike;	state Exp;
branches;
next	10.37;

10.37
date	94.09.02.00.53.26;	author mike;	state Exp;
branches;
next	10.36;

10.36
date	94.09.02.00.32.30;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	94.08.09.19.38.14;	author mike;	state Exp;
branches;
next	10.34;

10.34
date	94.07.03.20.17.44;	author mike;	state Exp;
branches;
next	10.33;

10.33
date	94.03.09.18.37.02;	author mike;	state Exp;
branches;
next	10.32;

10.32
date	94.03.09.16.35.14;	author jra;	state Exp;
branches;
next	10.31;

10.31
date	94.01.24.09.27.53;	author jra;	state Exp;
branches;
next	10.30;

10.30
date	94.01.22.05.23.46;	author mike;	state Exp;
branches;
next	10.29;

10.29
date	93.12.27.22.45.34;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	93.12.03.03.35.36;	author mike;	state Exp;
branches;
next	10.27;

10.27
date	93.11.18.02.08.30;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	93.10.22.22.28.11;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	93.10.20.09.30.20;	author jra;	state Exp;
branches;
next	10.24;

10.24
date	93.10.01.06.03.00;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	93.04.09.05.49.50;	author cjohnson;	state Exp;
branches;
next	10.22;

10.22
date	93.04.09.05.37.23;	author cjohnson;	state Exp;
branches;
next	10.21;

10.21
date	93.04.07.05.54.33;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	93.04.07.00.54.05;	author cjohnson;	state Exp;
branches;
next	10.19;

10.19
date	93.04.05.20.28.03;	author cjohnson;	state Exp;
branches;
next	10.18;

10.18
date	93.04.03.04.20.39;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	93.04.03.01.58.20;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	93.04.02.23.46.31;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	93.04.02.23.26.13;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	93.04.02.02.27.50;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	93.03.25.23.17.49;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	93.03.23.22.18.13;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	93.03.19.01.02.33;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	93.03.18.23.20.53;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	93.03.18.15.58.17;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	93.03.10.22.25.48;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	93.02.23.22.54.01;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.02.23.05.51.59;	author butler;	state Exp;
branches;
next	10.5;

10.5
date	92.07.22.21.36.43;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.03.06.05.43.14;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.02.25.00.07.11;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.02.21.01.31.22;	author butler;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.47;	author mike;	state Rel4_0;
branches;
next	2.5;

2.5
date	91.06.18.21.38.18;	author butler;	state Exp;
branches;
next	2.4;

2.4
date	91.06.17.20.42.14;	author butler;	state Exp;
branches;
next	2.3;

2.3
date	91.06.13.05.42.58;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	91.05.22.23.23.50;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	91.04.01.15.57.43;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	91.03.26.00.51.41;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	91.02.27.18.37.53;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	91.02.08.02.49.37;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	91.02.07.20.32.40;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	90.12.08.02.53.43;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	90.12.08.02.48.42;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	90.05.24.23.22.57;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	90.05.24.20.47.17;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	90.05.24.19.49.54;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	90.05.24.19.01.55;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	90.05.24.18.36.48;	author butler;	state Exp;
branches;
next	1.25;

1.25
date	90.05.23.22.06.45;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	90.05.22.21.16.13;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	90.05.22.21.05.37;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	90.05.21.23.42.44;	author butler;	state Exp;
branches;
next	1.21;

1.21
date	90.05.21.13.01.31;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	90.05.21.12.43.47;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	90.05.21.11.50.53;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	90.05.18.11.56.59;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	90.05.18.10.32.26;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	90.05.18.07.26.08;	author butler;	state Exp;
branches;
next	1.15;

1.15
date	90.05.12.10.19.42;	author butler;	state Exp;
branches;
next	1.14;

1.14
date	90.05.12.07.13.46;	author butler;	state Exp;
branches;
next	1.13;

1.13
date	90.05.09.01.07.24;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	90.03.15.01.47.21;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	90.03.15.01.44.17;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	90.03.14.22.37.08;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	90.03.14.21.19.30;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	90.03.14.20.45.14;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	90.03.08.04.41.06;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	90.02.28.01.54.57;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	90.02.27.21.02.30;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	90.01.03.14.28.08;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	89.12.29.21.44.29;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.12.22.03.16.40;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	89.12.09.02.32.45;	author mike;	state Exp;
branches;
next	;

11.33.2.1
date	2002.09.19.18.01.40;	author morrison;	state Exp;
branches;
next	11.33.2.2;

11.33.2.2
date	2004.03.17.21.18.54;	author morrison;	state Exp;
branches;
next	;

11.33.4.1
date	2004.03.11.23.43.42;	author morrison;	state Exp;
branches;
next	;

11.33.10.1
date	2004.02.12.18.37.45;	author erikg;	state Exp;
branches;
next	11.33.10.2;

11.33.10.2
date	2004.03.15.14.07.27;	author erikg;	state Exp;
branches;
next	;


desc
@The NMG library proper
@


11.37
log
@moved to src/
@
text
@/*
 *			N M G _ M K . C
 *
 *	Support routines for n-Manifold Geometry
 *
 *	Naming convention
 *		nmg_m* routines "make" NMG structures.
 *		nmg_k* routines "kill" (delete) NMG structures.
 *
 *	in each of the above cases the letters or words following are an 
 *	attempt at a mnemonic representation for what is manipulated
 *
 *	m	Model
 *	r	Region
 *	s	shell
 *	f	face
 *	fu	faceuse
 *	l	loop
 *	lu	loopuse
 *	e	edge
 *	eu	edgeuse
 *	v	vertex
 *	vu	vertexuse
 *
 *
 *	Rules:
 *
 * XXX - What does "overlap" mean? ctj
 *	edges of loops of the same face must not overlap
 *	the "magic" member of each struct is the first item.
 *
 *	All routines which create and destroy the NMG data structures
 *	are contained in this module.
 *
 *
 *  Authors -
 *	Lee A. Butler
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_mk.c,v 11.36 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <string.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"

static struct vertexuse *nmg_mvu RT_ARGS( (struct vertex *v, long *upptr,
					 struct model *m) );
static struct vertexuse *nmg_mvvu RT_ARGS( (long *upptr, struct model *m) );


/************************************************************************
 *									*
 *			"Make" Routines					*
 *									*
 *  The subroutines create new topological entities and return a	*
 *  pointer to the new entity.						*
 *									*
 ************************************************************************/

/*
 *  The nmg_m*() routines are used to create a topology-only object
 *  which at first has no geometry associated with it at all.
 *  A topology-only object can be used to answer questions like:
 *	is this vertex ON this shell?
 *	is this vertex ON this face?
 *	is this vertex ON this edge?
 *	Is this face ON this shell?
 * and many more.
 *
 *  After the topology has been built, most applications will proceed to
 *  associate geometry with the topology, primarily by supplying
 *  Cartesian coordinates for each struct vertex, and by supplying
 *  or computing face normals for the planar faces.  (Linear edge geometry
 *  is optional, as it is implicit from the vertex geometry).
 *
 *  Objects which have been fully populated with geometry can be used to
 *  answer questions about where things are located and how large they are.
 *
 * The abstract objects are:
 *	model, nmgregion, shell, face, loop, edge and vertex.
 * The uses of those objects are:
 * 	faceuse, loopuse, edgeuse and vertexuse.
 * Geometry can optionally be associated with the abstract objects:
 *	face_g		(plane equation, bounding box)
 *	loop_g		(just a bounding box, for planar faces)
 *	edge_g		(to track edge subdivision heritage, for linear edges)
 *	vertex_g	(Cartesian coordinates)
 * The uses of those objects can optionally have attributes:
 *	nmgregion_a	(region bounding box)	[nmgregions have no uses]
 *	shell_a		(shell bounding box)	[shells have no uses]
 *	vertexuse_a	(special surface normal, for normal interpolation)
 *
 * Consider for example a simple cube.
 *
 * As a topology-only object, it would have the following structures:
 *
 *	1 model structure
 *		This is the handle which everything else hangs on.
 *		The model structure r_hd references 1 region structure.
 *	1 nmgregion structure.
 *		The region structure s_hd references 1 shell structure.
 *		Also, m_p references the model.
 *	1 shell structure.
 *		The shell structure fu_hd references 12 faceuse structures.
 *		One for each side of each of the 6 faces of the cube.
 *		Also, r_p references the nmgregion.
 *	12 faceuse structures.
 *		Each faceuse structure lu_hd references 1 loopuse structure.
 *		Also, 1 face structure and 1 faceuse structure (its mate),
 *		plus s_p references the shell.
 *	6 face structures.
 *		Each face structure fu_p references a random choice of 1 of
 *		the two parent faceuse structures sharing this face, and is
 *		in turn referenced by that faceuse and it's mate.
 *	12 loopuse structures
 *		Each loopuse structure down_hd references 4 edgeuse structures.
 *		Also, 1 loop structure, and 1 loopuse structure (its mate).
 *		The four edgeuse structures define the perimeter of the
 *		surface area that comprises this face.
 *		Because their orientation is OT_SAME, each loopuse "claims"
 *		all the surface area inside it for the face.
 *		(OT_OPPOSITE makes a hole, claiming surface area outside).
 *		Plus, "up" references the parent object (faceuse, here).
 *	6 loop structures
 *		Each loop structure references a random choice of 1 of it's
 *		parent loopuse structures and is in turn referenced by that
 *		loopuse and it's mate.
 *	48 edgeuse structures
 *		Each edgeuse structure references 1 vertexuse structure,
 *		1 edge structure, and 2 other edgeuse structures (it's mate
 *		and the next edgeuse radial to this edgeuse).
 *		(if this edge was NOT used in another face, then the
 *		radial pointer and mate pointer would point to the SAME
 *		edgeuse)
 *		To find all edgeuses around a given edge, follow radial to
 *		mate to radial to mate until you are back to the original
 *		edgeuse.
 *		Plus, "up" references the parent object (loopuse, here).
 *	12 edge structures
 *		Each edge structure references a random choice of one of
 *		it's parent edgeuse structures and is in turn referenced
 *		by that edgeuse, the mate of that edgeuse, the radial of
 *		that edgeuse and the mate of the radial. (In this simple
 *		case of the cube, there are 4 edgeuses per edge).
 *	48 vertexuse structures.
 *		Each vertexuse structure references one vertex structure
 *		and is in turn enroled as a member of the linked list
 *		headed by that vertex structure.
 *		Each vertexuse is cited by exactly one edgeuse.
 *		Also, "up" references the parent object (edgeuse, here).
 *	8 vertex structures
 *		Each vertex structure references 6 vertexuse structures
 *		via it's linked list. (In the case of the cube,
 *		there are three faces meeting at each vertex, and each of
 *		those faces has two faceuse structs of one loopuse each. Each
 *		loopuse will cite the vertex via one edgeuse, so 3*2 = 6).
 *
 * As well as each "use" pointing down to what it uses, the "use" points
 * up to the structure that uses it.  So working up from any abstract object
 * or it's use, the top of the tree (struct model) can be found.
 * Working down from the struct model, all elements of the object can be
 * visited.
 *
 * The object just described contains no geometry.  There is no way to tell
 * where in space the object lies or how big it is.
 *
 * To add geometry, the following structures are needed:
 *	8 vertex_g structures
 *		each vertex_g structure contains a point in space (point_t)
 *		and is referenced by 1 vertex structure.
 *	12 edge_g structures (completely optional)
 *		each edge_g structure contains the parametric definition of
 *		the line which contains the line segment which is the edge,
 *		given as a point in space and a direction vector.  It is
 *		referenced by 1 edge structure. (In general, it is referenced
 *		by all edges sharing that line).
 *		In a simple case the point would be the same as one of
 *		the vertex_g points and the direction would be the normalized
 *		(unit) vector of the difference between the two vertex_g points.
 *	6 loop_g structures
 *		Each loop_g structure contains a bounding box for the loop.
 *		It is referenced by 1 loop structure.
 *	6 face_g_plane structures
 *		Each face_g_plane structure contains a plane equation and
 *		a bounding box.  It is referenced by one face structure.
 *		The plane equation is calculated from the vertex_g data
 *		by nmg_fu_planeeqn().
 *		See h/vmath.h for the definition of a plane equation.
 *	1 shell_a structure
 *		Each shell_a structure contains the bounding box for the
 *		shell.  It is referenced by 1 shell structure.
 *	1 nmgregion_a structure
 *		Each nmgregion_a structure contains the bounding box for the
 *		region.  It is referenced by 1 region structure.
 *
 */

/*
 *			N M G _ M M
 *
 *	Make Model
 *	Create a new model.  The region list is empty.
 *	Creates a new model structure.  The model region structure list
 *	is empty.
 *
 *  Returns -
 *	(struct model *)
 *
 *  Method:
 *	Use NMG_BU_GETSTRUCT to allocate memory and then set all components.
 *	NMG_BU_GETSTRUCT is used instead of the standard GET_name because
 *	all of the GET_name macros expect a model pointer to get the
 *	maxindex from.  So here we use NMG_BU_GETSTRUCT so that we can
 *	set the maxindex and index by hand.
 *
 *  N.B.:
 *	"maxindex" is a misnomer.  It is the value of the NEXT index
 *	assigned.  This allows "ptab"s to be allocated easly using
 *	maxindex and the index value of the structures to be the actual
 *	index into the "ptab".
 */
struct model *
nmg_mm(void)
{
	struct model *m;

	BU_GETSTRUCT( m, model );

	BU_LIST_INIT( &m->r_hd );
	m->index = 0;
	m->maxindex = 1;
	m->magic = NMG_MODEL_MAGIC;	/* Model Structure is GOOD */

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_mm() returns model x%x\n", m );
	}

	return(m);
}

/*
 *			N M G _ M M R
 *
 *	Make Model and Region
 *	Create a new model, and an "empty" region to go with it.  Essentially
 *	this creates a minimal model system.
 *
 *  Returns -
 *	(struct model *)
 *
 *  Implicit Return -
 *	The new region is found with BU_LIST_FIRST( nmgregion, &m->r_hd );
 */
struct model *
nmg_mmr(void)
{
	struct model *m;
	struct nmgregion *r;

	m = nmg_mm();
	GET_REGION(r, m);

	r->m_p = m;

	r->ra_p = (struct nmgregion_a *)NULL;
	BU_LIST_INIT( &r->s_hd );
	r->l.magic = NMG_REGION_MAGIC;	/* Region Structure is GOOD */

	BU_LIST_APPEND( &m->r_hd, &r->l );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_mmr() returns model x%x with region x%x\n", m , r );
	}

	return(m);
}

/*
 *			N M G _ M R S V
 *
 *	Make new region, shell, vertex in model as well as the
 *	required "uses".
 *	Create a new region in model consisting of a minimal shell.
 *
 *  Returns -
 *	(struct nmgregion *)
 *
 *  Implicit Returns -
 *	Region is also found with r=BU_LIST_FIRST( nmgregion, &m->r_hd );
 *	The new shell is found with s=BU_LIST_FIRST( shell, &r->s_hd );
 *	The new vertexuse is s->vu_p;
 */
struct nmgregion *
nmg_mrsv(struct model *m)
{
	struct nmgregion *r;

	NMG_CK_MODEL(m);

	GET_REGION(r, m);
	r->m_p = m;
	r->ra_p = (struct nmgregion_a *) NULL;

	BU_LIST_INIT( &r->s_hd );
	r->l.magic = NMG_REGION_MAGIC;	/* Region struct is GOOD */

	(void)nmg_msv(r);

	/* new region goes at "head" of list of regions in model */
	BU_LIST_APPEND( &m->r_hd, &r->l );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_mrsv(m=x%x) returns r=x%x\n" , m , r );
	}

	return(r);
}

/*
 *			N M G _ M S V
 *
 *	Make Shell, Vertex Use, Vertex
 *	Create a new shell in a specified region.  The shell will consist
 *	of a single vertexuse and vertex (which are also created).
 *
 *  Returns -
 *	(struct shell *)
 *
 *  Implicit Returns -
 *	The new shell is also found with s=BU_LIST_FIRST( shell, &r->s_hd );
 *	The new vertexuse is s->vu_p;
 */
struct shell *
nmg_msv(struct nmgregion *r)
{
	struct shell 		*s;
	struct vertexuse	*vu;

	NMG_CK_REGION(r);

	/* set up shell */
	GET_SHELL(s, r->m_p);

	s->r_p = r;
	BU_LIST_APPEND( &r->s_hd, &s->l );

	s->sa_p = (struct shell_a *)NULL;
	BU_LIST_INIT( &s->fu_hd );
	BU_LIST_INIT( &s->lu_hd );
	BU_LIST_INIT( &s->eu_hd );
	s->vu_p = (struct vertexuse *) NULL;
	s->l.magic = NMG_SHELL_MAGIC;	/* Shell Struct is GOOD */

	vu = nmg_mvvu(&s->l.magic, r->m_p);
	s->vu_p = vu;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_msv(r=x%x) returns s=x%x, vu=x%x\n" , r , s , s->vu_p );
	}

	return(s);
}

/*
 *			N M G _ M F
 *
 *	Make Face from a wire loop.
 *	make a face from a pair of loopuses.  The loopuses must be direct
 *	children of a shell.  The new face will be a child of the same shell.
 *
 * Given a wire loop (by definition, a loop attached to a shell), create
 * a new face, faceuse (and mate) and move the wire loop from the shell
 * to the new faceuse (and mate).
 *
 *  Implicit Returns -
 *	The first faceuse is fu1=BU_LIST_FIRST( faceuse, &s->fu_hd );
 *	The second faceuse follows:  fu2=BU_LIST_NEXT( faceuse, &fu1->l.magic );
 */
struct faceuse *
nmg_mf(struct loopuse *lu1)
{
	struct face *f;
	struct faceuse *fu1, *fu2;
	struct loopuse *lu2;
	struct shell	*s;
	struct model	*m;

	NMG_CK_LOOPUSE(lu1);
	if (*lu1->up.magic_p != NMG_SHELL_MAGIC) {
		rt_bomb("nmg_mf() loop must be child of shell for making face\n");
	}
	lu2 = lu1->lumate_p;
	NMG_CK_LOOPUSE(lu2);
	if (lu2->up.magic_p != lu1->up.magic_p) {
		rt_bomb("nmg_mf() loopuse mate does not have same parent\n");
	}

	s = lu1->up.s_p;
	NMG_CK_SHELL(s);

	m = nmg_find_model( &s->l.magic );
	GET_FACE(f, m);
	GET_FACEUSE(fu1, m);
	GET_FACEUSE(fu2, m);

	f->fu_p = fu1;
	f->g.plane_p = (struct face_g_plane *)NULL;
	f->flip = 0;
	BU_LIST_INIT(&f->l);
	f->l.magic = NMG_FACE_MAGIC;	/* Face struct is GOOD */

	BU_LIST_INIT(&fu1->lu_hd);
	BU_LIST_INIT(&fu2->lu_hd);
	fu1->s_p = fu2->s_p = s;
	fu1->fumate_p = fu2;
	fu2->fumate_p = fu1;
	fu1->orientation = fu2->orientation = OT_UNSPEC;
	fu1->f_p = fu2->f_p = f;
	fu1->l.magic = 
	    fu2->l.magic = NMG_FACEUSE_MAGIC; /* Faceuse structs are GOOD */

	/* move the loopuses from the shell to the faceuses */
	BU_LIST_DEQUEUE( &lu1->l );
	BU_LIST_DEQUEUE( &lu2->l );
	BU_LIST_APPEND( &fu1->lu_hd, &lu1->l );
	BU_LIST_APPEND( &fu2->lu_hd, &lu2->l );

	lu1->up.fu_p = fu1;
	lu1->orientation = OT_SAME;
	lu2->up.fu_p = fu2;
	lu2->orientation = OT_SAME;

	/* connect the faces to the parent shell:  head, fu1, fu2... */
	BU_LIST_APPEND( &s->fu_hd, &fu1->l );
	BU_LIST_APPEND( &fu1->l, &fu2->l );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_mf(lu1=x%x) returns fu=x%x\n" , lu1 , fu1 );
	}

	return(fu1);
}

/*
 *			N M G _ M L V
 *
 * XXX - vertex or vertexuse? or both? ctj 
 *	Make a new loop (with specified orientation) and vertex,
 *	in a shell or face.
 *	If the vertex 'v' is NULL, the shell's lone vertex is used,
 *	or a new vertex is created.
 *
 *  "magic" must point to the magic number of a faceuse or shell.
 *
 *  If the shell has a lone vertex in it, that lone vertex *will*
 *  be used.  If a non-NULL 'v' is provided, the lone vertex and
 *  'v' will be fused together.  XXX Why is this good?
 *
 *  If a convenient shell does not exist, use s=nmg_msv() to make
 *  the shell and vertex, then call lu=nmg_mlv(s,s->vu_p->v_p,OT_SAME),
 *  followed by nmg_kvu(s->vu_p).
 * 
 *  Implicit returns -
 *	The new vertexuse can be had by:
 *		BU_LIST_FIRST(vertexuse, &lu->down_hd);
 *
 *	In case the returned loopuse isn't retained, the new loopuse was
 *	inserted at the +head+ of the appropriate list, e.g.:
 *		lu = BU_LIST_FIRST(loopuse, &fu->lu_hd);
 *	or
 *		lu = BU_LIST_FIRST(loopuse, &s->lu_hd);
 *
 * N.B.  This function is made more complex than warrented by using
 * the "hack" of stealing a vertexuse structure from the shell if
 * at all possible.  A future enhancement to this function would be
 * to remove the vertexuse steal and have the caller pass in the
 * vertex from the shell followed by a call to nmg_kvu(s->vu_p).
 * The v==NULL convention is used only in nmg_mod.c.
 */
struct loopuse *
nmg_mlv(long int *magic, struct vertex *v, int orientation)
{
	struct loop	*l;
	struct loopuse	*lu1, *lu2;
	struct vertexuse *vu1 = NULL;
	struct vertexuse *vu2;
	struct model	*m;
	/* XXX - why the new union? ctj */
	union {
		struct shell *s;
		struct faceuse *fu;
		long *magic_p;
	} p;

	p.magic_p = magic;

	if (v) {
		NMG_CK_VERTEX(v);
	}

	m = nmg_find_model( magic );
	GET_LOOP(l, m);
	GET_LOOPUSE(lu1, m);
	GET_LOOPUSE(lu2, m);

	l->lg_p = (struct loop_g *)NULL;
	l->lu_p = lu1;
	l->magic = NMG_LOOP_MAGIC;	/* Loop struct is GOOD */

	BU_LIST_INIT( &lu1->down_hd );
	BU_LIST_INIT( &lu2->down_hd );
	lu1->l_p = lu2->l_p = l;
	lu1->orientation = lu2->orientation = orientation;

	lu1->lumate_p = lu2;
	lu2->lumate_p = lu1;

	/* The only thing left to do to make the loopuses good is to */
	/* set the "up" pointer and "l.magic". */
	if (*p.magic_p == NMG_SHELL_MAGIC) {
		struct shell	*s = p.s;

		/* First, finish setting up the loopuses */
		lu1->up.s_p = lu2->up.s_p = s;

		lu1->l.magic = lu2->l.magic =
		    NMG_LOOPUSE_MAGIC;	/* Loopuse structs are GOOD */

		BU_LIST_INSERT( &s->lu_hd, &lu1->l );
		BU_LIST_INSERT( &lu1->l, &lu2->l );

		/* Second, build the vertices */
		/* This "if" degenerates to the "else" clause if no stealing */
		if ( (vu1 = s->vu_p) ) {
			/* Use shell's lone vertex */
			s->vu_p = (struct vertexuse *)NULL;
			vu1->up.lu_p = lu1;
			if (v) nmg_movevu(vu1, v);
		} else {
			if (v) vu1 = nmg_mvu(v, &lu1->l.magic, m);
			else vu1 = nmg_mvvu(&lu1->l.magic, m);
		}
		NMG_CK_VERTEXUSE(vu1);
		RT_LIST_SET_DOWN_TO_VERT(&lu1->down_hd, vu1);
		/* vu1->up.lu_p = lu1; done by nmg_mvu/nmg_mvvu */

		vu2 = nmg_mvu(vu1->v_p, &lu2->l.magic, m);
		NMG_CK_VERTEXUSE(vu2);
		RT_LIST_SET_DOWN_TO_VERT(&lu2->down_hd, vu2);
		/* vu2->up.lu_p = lu2; done by nmg_mvu() */
	} else if (*p.magic_p == NMG_FACEUSE_MAGIC) {
		/* First, finish setting up the loopuses */
		lu1->up.fu_p = p.fu;
		lu2->up.fu_p = p.fu->fumate_p;
		lu1->l.magic = lu2->l.magic =
		    NMG_LOOPUSE_MAGIC;	/* Loopuse structs are GOOD */

		BU_LIST_INSERT( &p.fu->fumate_p->lu_hd, &lu2->l );
		BU_LIST_INSERT( &p.fu->lu_hd, &lu1->l );

		/* Second, build the vertices */
		if (v) vu1 = nmg_mvu(v, &lu1->l.magic, m);
		else vu1 = nmg_mvvu(&lu1->l.magic, m);
		RT_LIST_SET_DOWN_TO_VERT(&lu1->down_hd, vu1);
		/* vu1->up.lu_p = lu1; done by nmg_mvu/nmg_mvvu */

		vu2 = nmg_mvu(vu1->v_p, &lu2->l.magic, m);
		RT_LIST_SET_DOWN_TO_VERT(&lu2->down_hd, vu2);
		/* vu2->up.lu_p = lu2; done by nmg_mvu() */
	} else {
		rt_bomb("nmg_mlv() unknown parent for loopuse!\n");
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_mlv(up=x%x, v=x%x, %s) returns lu=x%x on vu=x%x\n",
			magic, v, nmg_orientation(orientation),
			lu1, vu1 );
	}
	return(lu1);
}

/*			N M G _ M V U
 *
 *	Make Vertexuse on existing vertex
 *
 *  This is a support routine for this module, and is not intended for
 *  general use, as it requires lots of cooperation from the caller.
 *  (Like setting the parent's down pointer appropriately).
 *
 *  This means that a vu is created but is not attached to the parent
 *  structure.  This is "bad" and requires the caller to fix.
 */
static struct vertexuse *
nmg_mvu(struct vertex *v, long int *upptr, struct model *m)
             	   
    		       		/* pointer to parent struct */
            	   
{
	struct vertexuse *vu;

	NMG_CK_VERTEX(v);
	NMG_CK_MODEL(m);

	if (*upptr != NMG_SHELL_MAGIC &&
	    *upptr != NMG_LOOPUSE_MAGIC &&
	    *upptr != NMG_EDGEUSE_MAGIC) {
		bu_log("nmg_mvu() in %s at %d magic not shell, loop, or edge.  Was x%x (%s)\n",
		    __FILE__, __LINE__,
		    *upptr, bu_identify_magic(*upptr) );
		rt_bomb("nmg_mvu() Cannot build vertexuse without parent\n");
	}

	GET_VERTEXUSE(vu, m);

	vu->v_p = v;
	vu->a.plane_p = (struct vertexuse_a_plane *)NULL;
	BU_LIST_APPEND( &v->vu_hd, &vu->l );
	vu->up.magic_p = upptr;
	vu->l.magic = NMG_VERTEXUSE_MAGIC;	/* Vertexuse struct is GOOD */

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_mvu(v=x%x, up=x%x) returns vu=x%x\n",
			v, upptr, vu);
	}
	return(vu);
}

/*			N M G _ M V V U
 *
 *	Make Vertex, Vertexuse
 *
 *  This is a support routine for this module, and is not intended for
 *  general use, as it requires lots of cooperation from the caller.
 *  (Like setting the parent's down pointer appropriately).
 *
 *  This means that a vu is created but is not attached to the parent
 *  structure.  This is "bad" and requires the caller to fix.
 */
static struct vertexuse *
nmg_mvvu(long int *upptr, struct model *m)
{
	struct vertex	*v;
	struct vertexuse *ret_vu;

	NMG_CK_MODEL(m);
	GET_VERTEX(v, m);
	BU_LIST_INIT( &v->vu_hd );
	v->vg_p = (struct vertex_g *)NULL;
	v->magic = NMG_VERTEX_MAGIC;	/* Vertex struct is GOOD */
	ret_vu = nmg_mvu(v, upptr, m);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_mvvu(upptr=x%x,m=x%x) returns vu=x%x\n" , upptr , m , ret_vu );
	}

	return( ret_vu );
}


/*
 *			N M G _ M E
 *
 *	Make wire edge
 *	Make a new edge between a pair of vertices in a shell.
 *
 *	A new vertex will be made for any NULL vertex pointer parameters.
 *	If we need to make a new vertex and the shell still has its vertexuse
 *	we re-use that vertex rather than freeing and re-allocating.
 *
 *	If both vertices were specified, and the shell also had a
 *	vertexuse pointer, the vertexuse in the shell is killed.
 *	XXX Why?
 *
 *  Explicit Return -
 *	An edgeuse in shell "s" whose vertexuse refers to vertex v1.
 *	The edgeuse mate's vertexuse refers to vertex v2
 *
 *  Implicit Returns -
 *	1)  If the shell had a lone vertex in vu_p, it is destroyed,
 *	even if both vertices were specified.
 *	2)  The returned edgeuse is the first item on the shell's
 *	eu_hd list, followed immediately by the mate.
 */
struct edgeuse *
nmg_me(struct vertex *v1, struct vertex *v2, struct shell *s)
{
	struct edge		*e;
	struct edgeuse		*eu1;
	struct edgeuse		*eu2;
	struct vertexuse	*vu;
	struct model		*m;

	if (v1) NMG_CK_VERTEX(v1);
	if (v2) NMG_CK_VERTEX(v2);
	NMG_CK_SHELL(s);

	m = nmg_find_model( &s->l.magic );
	GET_EDGE(e, m);
	GET_EDGEUSE(eu1, m);
	GET_EDGEUSE(eu2, m);

	BU_LIST_INIT( &eu1->l2 );
	BU_LIST_INIT( &eu2->l2 );
	eu1->l2.magic = eu2->l2.magic = NMG_EDGEUSE2_MAGIC;

	e->eu_p = eu1;
	/* e->is_real = XXX; */
	e->magic = NMG_EDGE_MAGIC;	/* Edge struct is GOOD */

	eu1->radial_p = eu1->eumate_p = eu2;
	eu2->radial_p = eu2->eumate_p = eu1;

	eu1->e_p = eu2->e_p = e;
	eu1->orientation = eu2->orientation = OT_NONE;
	/* XXX - why not OT_UNSPEC? ctj */
	eu1->vu_p = eu2->vu_p = (struct vertexuse *) NULL;

	eu1->l.magic = eu2->l.magic = 
	    NMG_EDGEUSE_MAGIC;	/* Edgeuse structs are GOOD */
	/* Not really, edgeuses require vertexuses, but we've got to */
	/* call nmg_mvvu() or nmg_mvu() before we can set vu_p so we */
	/* NULL out vu_p now. */

	/* link the edgeuses to the parent shell */
	eu1->up.s_p = eu2->up.s_p = s;

	if (v1)  {
		eu1->vu_p = nmg_mvu(v1, &eu1->l.magic, m);
	} else if (s->vu_p)  {
		/* This clause of the if statment dies when no vertex stealing */
		/* steal the vertex from the shell */
		vu = s->vu_p;
		s->vu_p = (struct vertexuse *)NULL;
		eu1->vu_p = vu;
		vu->up.eu_p = eu1;
	} else {
		eu1->vu_p = nmg_mvvu(&eu1->l.magic, m);
	}

	if (v2)  {
		eu2->vu_p = nmg_mvu(v2, &eu2->l.magic, m);
	} else if (s->vu_p)  {
		/* This clause of the if statment dies when no vertex stealing */
		/* steal the vertex from the shell */
		vu = s->vu_p;
		s->vu_p = (struct vertexuse *)NULL;
		eu2->vu_p = vu;
		vu->up.eu_p = eu2;
	} else {
		eu2->vu_p = nmg_mvvu(&eu2->l.magic, m);
	}

	/* This if statment dies when no vertex stealing */
	if( s->vu_p )  {
		/* Ensure shell no longer has any stored vertexuse */
		(void)nmg_kvu( s->vu_p );
		s->vu_p = (struct vertexuse *)NULL;
	}

	/* shell's eu_head, eu1, eu2, ... */
	BU_LIST_APPEND( &s->eu_hd, &eu1->l );
	BU_LIST_APPEND( &eu1->l, &eu2->l );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_me(v1=x%x, v2=x%x, s=x%x) returns eu=x%x\n" , v1 , v2 , s , eu1 );
	}

	return(eu1);
}

/*
 *			N M G _ M E o n V U
 *
 *  Make an edge on vertexuse.
 *  The new edge runs from and to that vertex.
 *
 *  If the vertexuse was the shell's sole vertexuse, then the new edge
 *  is a wire edge in the shell's eu_hd list.
 *
 *  If the vertexuse was part of a loop-of-a-single-vertex, either
 *  as a loop in a face or as a wire-loop in the shell, the
 *  loop becomes a regular loop with one edge that runs from and to
 *  the original vertex.
 */
struct edgeuse *
nmg_meonvu(struct vertexuse *vu)
{
	struct edge *e;
	struct edgeuse *eu1, *eu2;
	struct model	*m;

	NMG_CK_VERTEXUSE(vu);

	m = nmg_find_model( vu->up.magic_p );
	GET_EDGE(e, m);
	GET_EDGEUSE(eu1, m);
	GET_EDGEUSE(eu2, m);

	BU_LIST_INIT( &eu1->l2 );
	BU_LIST_INIT( &eu2->l2 );
	eu1->l2.magic = eu2->l2.magic = NMG_EDGEUSE2_MAGIC;

	e->eu_p = eu1;
	e->is_real = 0;
	e->magic = NMG_EDGE_MAGIC;

	eu1->radial_p = eu1->eumate_p = eu2;
	eu2->radial_p = eu2->eumate_p = eu1;
	eu1->e_p = eu2->e_p = e;
	eu1->orientation = eu2->orientation = OT_NONE;
	/* XXX Why not OT_UNSPEC? */
	eu1->vu_p = vu;
	/* vu->up needs to be set but we can't do that until we recover */
	/* the shell or loopuse from the up pointer. */

	eu2->vu_p = (struct vertexuse *) NULL;

	/* link edgeuses to parent */
	if (*vu->up.magic_p == NMG_SHELL_MAGIC) {
		struct shell	*s;

		s = eu2->up.s_p = eu1->up.s_p = vu->up.s_p;
		eu1->l.magic = eu2->l.magic =
		    NMG_EDGEUSE_MAGIC;	/* Edgeuse structs are GOOD */
		/* eu2 is fake good till it has a real vu */

		vu->up.eu_p = eu1;	/* vu is good again */

		if( s->vu_p != vu )
			rt_bomb("nmg_meonvu() vetexuse parent shell disowns vertexuse!\n");
		s->vu_p = (struct vertexuse *)NULL;	/* remove from shell */

		eu2->vu_p = nmg_mvu(vu->v_p, &eu2->l.magic, m);
		BU_LIST_APPEND( &s->eu_hd, &eu2->l );
		BU_LIST_APPEND( &s->eu_hd, &eu1->l );
	} else if (*vu->up.magic_p == NMG_LOOPUSE_MAGIC) {
		struct loopuse		*lu;
		struct loopuse		*lumate;
		struct vertexuse	*vumate;

		lu = vu->up.lu_p;
		NMG_CK_LOOPUSE(lu);
		lumate = lu->lumate_p;
		NMG_CK_LOOPUSE(lumate);

		/* do a little consistency checking */
		if( lu == lumate )  rt_bomb("nmg_meonvu() lu mate is lu\n");
		if( BU_LIST_FIRST_MAGIC(&lumate->down_hd) != NMG_VERTEXUSE_MAGIC )
			rt_bomb("nmg_meonvu() mate of vertex-loop is not vertex-loop!\n");
		vumate = BU_LIST_FIRST(vertexuse, &lumate->down_hd);
		NMG_CK_VERTEXUSE(vumate);
		if( vu == vumate )  rt_bomb("nmg_meonvu() vu mate is vu\n");
		NMG_CK_VERTEX(vu->v_p);
		NMG_CK_VERTEX(vumate->v_p);

		/* edgeuses point at vertexuses */
		eu2->vu_p = vumate;

		/* edgeuses point at parent loopuses */
		eu1->up.lu_p = lu;
		eu2->up.lu_p = lumate;

		eu1->l.magic = eu2->l.magic =
		    NMG_EDGEUSE_MAGIC;	/* Edgeuse structs are GOOD */

		/* Fix forw & back pointers after "abuse", above */
		/*
		 * The down_hd can be a POINTER to a vertexuse or
		 * the head of a linked list.  In this case we are
		 * changing from a pointer to a linked list so we
		 * initialize the linked list head then add the loopuses
		 * to that list.
		 */
		BU_LIST_INIT( &lu->down_hd );
		BU_LIST_INIT( &lumate->down_hd );
		/* Add edgeuses to loopuses linked lists */
		BU_LIST_APPEND( &lumate->down_hd, &eu2->l );
		BU_LIST_APPEND( &lu->down_hd, &eu1->l );

		/* vertexuses point up at edgeuses */
		vu->up.eu_p = eu1;
		vumate->up.eu_p = eu2;
	} else {
		rt_bomb("nmg_meonvu() cannot make edge, vertexuse not sole element of object\n");
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_meonvu(vu=x%x) returns eu=x%x\n" , vu , eu1 );
	}

	return(eu1);
}

/*			N M G _ M L
 *
 *	Make wire loop from wire edgeuse list
 *
 *	Passed a pointer to a shell.  The wire edgeuse child of the shell
 *	is taken as the head of a list of edge(use)s which will form
 *	the new loop.  The loop is created from the first N contiguous
 *	edges.  Thus the end of the new loop is 
 *	delineated by the "next" edge(use)being:
 * 
 * 	A) the first object in the list (no other edgeuses in
 * 		shell list)
 *	B) non-contiguous with the previous edge
 * 
 *	A loop is created from this list of edges.  The edges must
 *	form a true circuit, or we dump core on your disk.  If we
 *	succeed, then the edgeuses are moved from the shell edgeuse list
 *	to the loop, and the two loopuses are inserted into the shell.
 */
struct loopuse *
nmg_ml(struct shell *s)
{
	struct loop *l;
	struct loopuse *lu1, *lu2;
	struct edgeuse	*p1;
	struct edgeuse	*p2;
	struct edgeuse	*feu;
	struct model	*m;

	NMG_CK_SHELL(s);
	/* If loop on single vertex */
	if( BU_LIST_IS_EMPTY( &s->eu_hd ) && s->vu_p )  {
		NMG_CK_VERTEXUSE(s->vu_p);
		NMG_CK_VERTEX(s->vu_p->v_p);
		lu1 = nmg_mlv(&s->l.magic, s->vu_p->v_p, OT_UNSPEC);
		/* (void) nmg_kvu(s->vu_p); */

		if (rt_g.NMG_debug & DEBUG_BASIC)  {
			bu_log("nmg_ml(s=x%x) returns lu of single vertex=x%x\n" , s , lu1 );
		}

		return lu1;
	}

	m = nmg_find_model( &s->l.magic );
	GET_LOOP(l, m);
	GET_LOOPUSE(lu1, m);
	GET_LOOPUSE(lu2, m);

	l->lg_p = (struct loop_g *)NULL;
	l->lu_p = lu1;
	l->magic = NMG_LOOP_MAGIC;	/* loop struct is GOOD */

	BU_LIST_INIT( &lu1->down_hd );
	BU_LIST_INIT( &lu2->down_hd );
	lu1->l_p = lu2->l_p = l;
	lu1->orientation = lu2->orientation = OT_UNSPEC;
	lu1->lumate_p = lu2;
	lu2->lumate_p = lu1;
	lu1->up.s_p = lu2->up.s_p = s;
	lu1->l.magic = lu2->l.magic =
	    NMG_LOOPUSE_MAGIC;	/* Loopuse structs are GOOD */

	/* Save the first edgeuse so we can tell if the loop closes */
	feu = BU_LIST_FIRST( edgeuse, &s->eu_hd );
	if (feu){
		NMG_CK_EDGEUSE(feu);
		NMG_CK_VERTEXUSE(feu->vu_p);
		NMG_CK_VERTEX(feu->vu_p->v_p);
	}

	/* Safety catch in case eu_hd is empty */
	p2 = (struct edgeuse *)NULL;
	while( BU_LIST_NON_EMPTY( &s->eu_hd ) )  {
		p1 = BU_LIST_FIRST( edgeuse, &s->eu_hd );
		NMG_CK_EDGEUSE(p1);
		p2 = p1->eumate_p;
		NMG_CK_EDGEUSE(p2);

		/* bogosity check */
		if (p1->up.s_p != s || p2->up.s_p != s)
			rt_bomb("nmg_ml() edgeuse mates don't have proper parent!\n");

		/* dequeue the first edgeuse */
		BU_LIST_DEQUEUE( &p1->l );
		if( BU_LIST_IS_EMPTY( &s->eu_hd ) )  {
			bu_log("nmg_ml() in %s at %d edgeuse mate not in this shell\n",
			    __FILE__, __LINE__);
			rt_bomb("nmg_ml\n");
		}

		/* dequeue the edgeuse's mate */
		BU_LIST_DEQUEUE( &p2->l );

		/*  Insert the next new edgeuse(s) at tail of the loop's list
		 *  (ie, insert just before the head).
		 *  head, .....,p2, p1, (tail)
		 */
		BU_LIST_INSERT( &lu1->down_hd, &p1->l );
		BU_LIST_INSERT( &lu2->down_hd, &p2->l );

		p1->up.lu_p = lu1;
		p2->up.lu_p = lu2;

		/* If p2's vertex does not match next one comming, quit */
		if( BU_LIST_IS_EMPTY( &s->eu_hd ) )  break;
		p1 = BU_LIST_FIRST( edgeuse, &s->eu_hd );
		NMG_CK_EDGEUSE(p1);
		NMG_CK_VERTEXUSE(p1->vu_p);
		NMG_CK_VERTEX(p1->vu_p->v_p);
		NMG_CK_VERTEXUSE(p2->vu_p);
		NMG_CK_VERTEX(p2->vu_p->v_p);
		if( p1->vu_p->v_p != p2->vu_p->v_p )  {
			break;
		}
	}

	if (p2) {
		NMG_CK_EDGEUSE(p2);
		NMG_CK_VERTEXUSE(p2->vu_p);
		NMG_CK_VERTEX(p2->vu_p->v_p);
	}
	if( p2 && p2->vu_p->v_p != feu->vu_p->v_p) {
		bu_log("nmg_ml() Edge(use)s do not form proper loop!\n");
		nmg_pr_s(s, (char *)NULL);
		bu_log("nmg_ml() Edge(use)s do not form proper loop!\n");
		rt_bomb("nmg_ml\n");
	}

	/* Head, lu1, lu2, ... */
	BU_LIST_APPEND( &s->lu_hd, &lu2->l );
	BU_LIST_APPEND( &s->lu_hd, &lu1->l );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_ml(s=x%x) returns lu=x%x\n" , s , lu1 );
	}

	return(lu1);
}

/************************************************************************
 *									*
 *				"Kill" Routines				*
 *									*
 *  These subroutines delete (kill) a topological entity,		*
 *  eliminating any related subordinate entities where appropriate.	*
 *									*
 *  If the superior entity becomes empty as a result of a "kill"	*
 *  operation, and that superior entity isn't allowed to *be* empty,	*
 *  then a TRUE (1) return code is given, indicating that the		*
 *  caller needs to immediately delete the superior entity before	*
 *  performing any other NMG operations.				*
 *									*
 *  During this interval, the superior entity is in an "illegal"	*
 *  state that the verify routines (nmg_vshell, etc.) and subsequent	*
 *  NMG processing routines will not accept, so that code which fails	*
 *  to honor the return codes will "blow up" downstream.		*
 *  Unfortunately, in some cases the problem won't be detected for	*
 *  quite a while, but this is better than having subsequent code	*
 *  encountering entities that *look* valid, but shouldn't be.		*
 *									*
 ************************************************************************/

/*			N M G _ K V U
 *
 *	Kill vertexuse, and null out parent's vu_p.
 *
 *  This routine is not intented for general use by applications,
 *  because it requires cooperation on the part of the caller
 *  to properly dispose of or fix the now *quite* illegal parent.
 *  (Illegal because the parent's vu_p is NULL).
 *  It exists primarily as a support routine for "mopping up" after
 *  nmg_klu(), nmg_keu(), nmg_ks(), and nmg_mv_vu_between_shells().
 *
 *  It is also used in a particularly ugly way in 
 *  nmg_cut_loop() and nmg_split_lu_at_vu()
 *  as part of their method for obtaining an "empty" loopuse/loop set.
 *
 *  It is worth noting that all these callers ignore the return code,
 *  because they *all* exist to intentionally empty out the parent, but
 *  the return code is provided anyway, in the name of [CTJ] symmetry.
 *
 *  Returns -
 *	0	If all is well in the parent
 *	1	If parent is empty, and is thus "illegal"
 */
int
nmg_kvu(register struct vertexuse *vu)
{
	struct vertex	*v;
	int		ret = 0;

	NMG_CK_VERTEXUSE(vu);

	if (vu->a.magic_p)  {
		NMG_CK_VERTEXUSE_A_EITHER(vu->a.magic_p);
		switch(*vu->a.magic_p)  {
		case NMG_VERTEXUSE_A_PLANE_MAGIC:
			FREE_VERTEXUSE_A_PLANE(vu->a.plane_p);
			break;
		case NMG_VERTEXUSE_A_CNURB_MAGIC:
			FREE_VERTEXUSE_A_CNURB(vu->a.cnurb_p);
			break;
		}
	}

	v = vu->v_p;
	NMG_CK_VERTEX(v);

	BU_LIST_DEQUEUE( &vu->l );
	if( BU_LIST_IS_EMPTY( &v->vu_hd ) )  {
		/* last vertexuse on vertex */
		if (v->vg_p) FREE_VERTEX_G(v->vg_p);
		FREE_VERTEX(v);
	}

	/* erase existence of this vertexuse from parent */
	if (*vu->up.magic_p == NMG_SHELL_MAGIC)  {
		vu->up.s_p->vu_p = (struct vertexuse *)NULL;
		ret = nmg_shell_is_empty(vu->up.s_p);
	} else if (*vu->up.magic_p == NMG_LOOPUSE_MAGIC) {
		/* Reset the hack */
		BU_LIST_INIT( &vu->up.lu_p->down_hd );
		ret = 1;
	} else if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC)  {
		vu->up.eu_p->vu_p = (struct vertexuse *)NULL;
		ret = 1;
	} else
		rt_bomb("nmg_kvu() killing vertexuse of unknown parent?\n");

	FREE_VERTEXUSE(vu);
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_kvu(vu=x%x) ret=%d\n", vu, ret);
	}
	return ret;
}


/*
 *			N M G _ K F G
 *
 *  Internal routine to release face geometry when no more faces use it.
 */
static void
nmg_kfg(long int *magic_p)
{
	switch( *magic_p ) {
	case NMG_FACE_G_PLANE_MAGIC:
		/* If face_g is not referred to by any other face, free it */
		{
			struct face_g_plane	*pp;
			pp = (struct face_g_plane *)magic_p;
			if( BU_LIST_NON_EMPTY( &(pp->f_hd) ) )  return;
			FREE_FACE_G_PLANE(pp);
		}
		break;
	case NMG_FACE_G_SNURB_MAGIC:
		/* If face_g is not referred to by any other face, free it */
		{
			struct face_g_snurb *sp;
			sp = (struct face_g_snurb *)magic_p;
			if( BU_LIST_NON_EMPTY( &(sp->f_hd) ) )  return;
			bu_free( (char *)sp->u.knots, "nmg_kfg snurb u knots[]");
			bu_free( (char *)sp->v.knots, "nmg_kfg snurb v knots[]");
			bu_free( (char *)sp->ctl_points, "nmg_kfg snurb ctl_points[]");
			FREE_FACE_G_SNURB(sp);
		}
		break;
	default:
		rt_bomb("nmg_kfg() bad magic\n");
	}
}

/*			N M G _ K F U
 *
 *	Kill Faceuse
 *
 *	delete a faceuse and its mate from the parent shell.
 *	Any children found are brutally murdered as well.
 *	The faceuses are dequeued from the parent shell's list here.
 *
 *  Returns -
 *	0	If all is well
 *	1	If parent shell is now empty, and is thus "illegal"
 */
int
nmg_kfu(struct faceuse *fu1)
{
	struct faceuse *fu2;
	struct face	*f1;
	struct face	*f2;
	struct shell	*s;
	int		ret;

	NMG_CK_FACEUSE(fu1);
	fu2 = fu1->fumate_p;
	NMG_CK_FACEUSE(fu2);
	f1 = fu1->f_p;
	f2 = fu2->f_p;
	NMG_CK_FACE(f1);
	NMG_CK_FACE(f2);
	if( f1 != f2 )
		rt_bomb("nmg_kfu() faceuse mates do not share face!\n");
	s = fu1->s_p;
	NMG_CK_SHELL(s);

	/* kill off the children (infanticide?)*/
	while( BU_LIST_NON_EMPTY( &fu1->lu_hd ) )  {
		(void)nmg_klu( BU_LIST_FIRST( loopuse, &fu1->lu_hd ) );
	}

	/* Release the face geometry */
	if (f1->g.magic_p) {
		/* Disassociate this face from face_g */
		BU_LIST_DEQUEUE( &f1->l );
		nmg_kfg( f1->g.magic_p );
	}
	FREE_FACE(f1);
	fu1->f_p = fu2->f_p = (struct face *)NULL;

	/* remove ourselves from the parent list */
	BU_LIST_DEQUEUE( &fu1->l );
	if( BU_LIST_IS_EMPTY( &s->fu_hd ) )
		rt_bomb("nmg_kfu() faceuse mate not in parent shell?\n");
	BU_LIST_DEQUEUE( &fu2->l );

	FREE_FACEUSE(fu1);
	FREE_FACEUSE(fu2);
	ret = nmg_shell_is_empty(s);
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_kfu(fu1=x%x) fu2=x%x ret=%d\n", fu1, fu2, ret);
	}
	return ret;
}

/*			N M G _ K L U
 *
 *	Kill loopuse, loopuse mate, and loop.
 *
 *	if the loop contains any edgeuses or vertexuses they are killed
 *	before the loop is deleted.
 *
 *	We support the concept of killing a loop with no children to
 *	support the routine "nmg_demote_lu"
 *
 *  Returns -
 *	0	If all is well
 *	1	If parent is empty, and is thus "illegal"
 */
int
nmg_klu(struct loopuse *lu1)
{
	struct loopuse *lu2;
	long	magic1;
	int	ret = 0;

	NMG_CK_LOOPUSE(lu1);
	lu2 = lu1->lumate_p;
	NMG_CK_LOOPUSE(lu2);

	if (lu1->l_p != lu2->l_p)
		rt_bomb("nmg_klu() loopmates do not share loop!\n");

	if (*lu1->up.magic_p != *lu2->up.magic_p)
		rt_bomb("nmg_klu() loopuses do not have same type of parent!\n");

	/* deal with the children */
	magic1 = BU_LIST_FIRST_MAGIC( &lu1->down_hd );
	if( magic1 != BU_LIST_FIRST_MAGIC( &lu2->down_hd ) )
		rt_bomb("nmg_klu() loopuses do not have same type of child!\n");

	if( magic1 == NMG_VERTEXUSE_MAGIC )  {
		/* Follow the vertex-loop hack downward,
		 * nmg_kvu() will clean up */
		(void)nmg_kvu( BU_LIST_FIRST(vertexuse, &lu1->down_hd) );
		(void)nmg_kvu( BU_LIST_FIRST(vertexuse, &lu2->down_hd) );
	} else if ( magic1 == NMG_EDGEUSE_MAGIC) {
		/* delete all edgeuse in the loopuse (&mate) */
		while( BU_LIST_NON_EMPTY( &lu1->down_hd ) )  {
			(void)nmg_keu(BU_LIST_FIRST(edgeuse, &lu1->down_hd) );
		}
	} else if ( magic1 == BU_LIST_HEAD_MAGIC )  {
		/* down_hd list is empty, no problem */
	} else {
		bu_log("nmg_klu(x%x) magic=%s\n", lu1, bu_identify_magic(magic1) );
		rt_bomb("nmg_klu: unknown type for loopuse child\n");
	}

	/* disconnect from parent's list */
	if (*lu1->up.magic_p == NMG_SHELL_MAGIC) {
		BU_LIST_DEQUEUE( &lu1->l );
		BU_LIST_DEQUEUE( &lu2->l );
		ret = nmg_shell_is_empty( lu1->up.s_p );
	} else if (*lu1->up.magic_p == NMG_FACEUSE_MAGIC) {
		BU_LIST_DEQUEUE( &lu1->l );
		BU_LIST_DEQUEUE( &lu2->l );
		ret = BU_LIST_IS_EMPTY( &lu1->up.fu_p->lu_hd );
	} else {
		rt_bomb("nmg_klu() unknown parent for loopuse\n");
	}

	NMG_CK_LOOP(lu1->l_p);
	if (lu1->l_p->lg_p) {
		NMG_CK_LOOP_G(lu1->l_p->lg_p);
		FREE_LOOP_G(lu1->l_p->lg_p);
	}
	FREE_LOOP(lu1->l_p);
	FREE_LOOPUSE(lu1);
	FREE_LOOPUSE(lu2);
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_klu(lu1=x%x) lu2=x%x ret=%d\n", lu1, lu2, ret);
	}
	return ret;
}

/*
 *			N M G _ K E G
 *
 *  Internal routine to kill an edge geometry structure (of either type),
 *  if all the edgeuses on it's list have vanished.
 *  Regardless, the edgeuse's geometry pointer is cleared.
 *
 *  This routine does only a single edgeuse.
 *  If the edgeuse mate has geometry to be killed, make a second call.
 *  Sometimes only one of the two needs to release the geometry.
 *
 *  Returns -
 *	0	If the old edge geometry (eu->g.magic_p) has other uses.
 *	1	If the old edge geometry has been destroyed. Caller beware!
 *
 *  NOT INTENDED FOR GENERAL USE!
 *  However, nmg_mod.c needs it for nmg_eusplit().  (Drat!)
 */
/**static**/ int
nmg_keg(struct edgeuse *eu)
{
	NMG_CK_EDGEUSE(eu);

	if( !eu->g.magic_p )  return 0;	/* ??? what to return here */

	switch( *eu->g.magic_p )  {
	case NMG_EDGE_G_LSEG_MAGIC:
		{
			struct edge_g_lseg	*lp;
			lp = eu->g.lseg_p;
			eu->g.magic_p = (long *)NULL;
			if( BU_LIST_NON_EMPTY( &lp->eu_hd2 ) )  return 0;
			FREE_EDGE_G_LSEG(lp);
		}
		break;
	case NMG_EDGE_G_CNURB_MAGIC:
		{
			struct edge_g_cnurb	*eg;
			eg = eu->g.cnurb_p;
			eu->g.magic_p = (long *)NULL;
			if( BU_LIST_NON_EMPTY( &eg->eu_hd2 ) )  return 0;
			if( eg->order != 0 )  {
				bu_free( (char *)eg->k.knots, "nmg_keg cnurb knots[]");
				bu_free( (char *)eg->ctl_points, "nmg_keg cnurb ctl_points[]");
			}
			FREE_EDGE_G_CNURB(eg);
		}
		break;
	}
	return 1;		/* edge geometry has been destroyed */
}

/*
 *			N M G _ K E U
 *
 *	Delete an edgeuse & it's mate from a shell or loop.
 *
 *  Returns -
 *	0	If all is well
 *	1	If the parent now has no edgeuses, and is thus "illegal"
 *		and in need of being deleted.  (The lu / shell deletion
 *		can't be handled at this level, but must be done by the caller).
 */
int
nmg_keu(register struct edgeuse *eu1)
{
	register struct edgeuse *eu2;
	struct edge		*e;
	int			ret = 0;

	NMG_CK_EDGEUSE(eu1);
	e = eu1->e_p;
	NMG_CK_EDGE(e);

	eu2 = eu1->eumate_p;
	NMG_CK_EDGEUSE(eu2);
	NMG_CK_EDGE(eu2->e_p);

	if (e != eu2->e_p) {
		rt_bomb("nmg_keu() edgeuse pair does not share edge\n");
	}

	/* unlink from radial linkages (if any) */
	if (eu1->radial_p != eu2) {
		NMG_CK_EDGEUSE(eu1->radial_p);
		NMG_CK_EDGEUSE(eu2->radial_p);

		eu1->radial_p->radial_p = eu2->radial_p;
		eu2->radial_p->radial_p = eu1->radial_p;

		NMG_CK_EDGEUSE(eu1->radial_p);
		NMG_CK_EDGEUSE(eu2->radial_p);

		/* since there is a use of this edge left, make sure the edge
		 * structure points to a remaining edgeuse
		 */
		if (e->eu_p == eu1 || e->eu_p == eu2)
			e->eu_p = eu1->radial_p;
		NMG_CK_EDGEUSE( e->eu_p );
	} else {
		/* since these two edgeuses are the only use of this edge,
		 * we need to free the edge (since all uses are about 
		 * to disappear).
		 */
		FREE_EDGE(e);
		e = (struct edge *)NULL;
		eu1->e_p = e;	/* sanity */
		eu2->e_p = e;
	}

	/* handle geometry, if any */
	if( eu1->g.magic_p )
	{
		/* Dequeue edgeuse from geometry's list of users */
		BU_LIST_DEQUEUE( &eu1->l2 );

		/* Release the edgeuse's geometry pointer */
		nmg_keg( eu1 );
	}

	if( eu2->g.magic_p )
	{
		/* Dequeue edgeuse from geometry's list of users */
		BU_LIST_DEQUEUE( &eu2->l2 );

		/* Release the edgeuse's geometry pointer */
		nmg_keg( eu2 );
	}

	/* remove the edgeuses from their parents */
	if (*eu1->up.magic_p == NMG_LOOPUSE_MAGIC) {
		struct loopuse	*lu1, *lu2;
		lu1 = eu1->up.lu_p;
		lu2 = eu2->up.lu_p;
		NMG_CK_LOOPUSE(lu1);
		NMG_CK_LOOPUSE(lu2);

		if( lu1 == lu2 )  rt_bomb("nmg_keu() edgeuses on same loopuse\n");
		if (lu1->lumate_p != lu2 || lu1 != lu2->lumate_p ) {
			bu_log("nmg_keu() lu1=x%x, mate=x%x\n", lu1, lu1->lumate_p);
			bu_log("nmg_keu() lu2=x%x, mate=x%x\n", lu2, lu2->lumate_p);
		    	rt_bomb("nmg_keu() edgeuse mates don't belong to loopuse mates\n");
		}

		/* remove the edgeuses from their parents */
		BU_LIST_DEQUEUE( &eu1->l );
		BU_LIST_DEQUEUE( &eu2->l );

		/* If loopuse list is empty, caller needs to delete it. */
		if( BU_LIST_IS_EMPTY( &lu1->down_hd ) )  ret = 1;
	} else if (*eu1->up.magic_p == NMG_SHELL_MAGIC) {
		if (eu1->up.s_p != eu2->up.s_p) {
			rt_bomb("nmg_keu() edguses don't share parent shell\n");
		}

		/* unlink edgeuses from the parent shell */
		BU_LIST_DEQUEUE( &eu1->l );
		BU_LIST_DEQUEUE( &eu2->l );
		ret = nmg_shell_is_empty( eu1->up.s_p );
	} else {
		rt_bomb("nmg_keu() bad up pointer\n");
	}

	/* kill the vertexuses associated with these edgeuses */
	if (eu1->vu_p) {
		(void)nmg_kvu(eu1->vu_p);
	}
	if (eu2->vu_p) {
		(void)nmg_kvu(eu2->vu_p);
	}

	FREE_EDGEUSE(eu1);
	FREE_EDGEUSE(eu2);

	if( e )
	{
		NMG_CK_EDGE( e );
		NMG_CK_EDGEUSE( e->eu_p );
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_keu(eu1=x%x) eu2=x%x ret=%d\n", eu1, eu2, ret);
	}
	return ret;
}

/*			N M G _ K S
 *
 *	Kill a shell and all children
 *
 *  Returns -
 *	0	If all is well
 *	1	If parent nmgregion is now empty.  While not "illegal",
 *		an empty region is probably worthy of note.
 */
int
nmg_ks(struct shell *s)
{
	struct nmgregion	*r;

	NMG_CK_SHELL(s);
	r = s->r_p;
	NMG_CK_REGION(r);

	while( BU_LIST_NON_EMPTY( &s->fu_hd ) )
		(void)nmg_kfu( BU_LIST_FIRST(faceuse, &s->fu_hd) );
	while( BU_LIST_NON_EMPTY( &s->lu_hd ) )
		(void)nmg_klu( BU_LIST_FIRST(loopuse, &s->lu_hd) );
	while( BU_LIST_NON_EMPTY( &s->eu_hd ) )
		(void)nmg_keu( BU_LIST_FIRST(edgeuse, &s->eu_hd) );
	if( s->vu_p )
		nmg_kvu( s->vu_p );

	BU_LIST_DEQUEUE( &s->l );

	if (s->sa_p) {
		FREE_SHELL_A(s->sa_p);
	}

	FREE_SHELL(s);
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_ks(s=x%x)\n", s);
	}
	if( BU_LIST_IS_EMPTY( &r->s_hd ) )  return 1;
	return 0;
}

/*			N M G _ K R
 *
 *	Kill a region and all shells in it
 *
 *  Returns -
 *	0	If all is well
 *	1	If model is now empty.  While not "illegal",
 *		an empty model is probably worthy of note.
 */
int
nmg_kr(struct nmgregion *r)
{
	struct model	*m;

	NMG_CK_REGION(r);
	m = r->m_p;
	NMG_CK_MODEL(m);

	while( BU_LIST_NON_EMPTY( &r->s_hd ) )
		(void)nmg_ks( BU_LIST_FIRST( shell, &r->s_hd ) );

	BU_LIST_DEQUEUE( &r->l );

	if (r->ra_p) {
		FREE_REGION_A(r->ra_p);
	}
	FREE_REGION(r);
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_kr(r=x%x)\n", r);
	}

	if( BU_LIST_IS_EMPTY( &m->r_hd ) ) {
		m->maxindex = 1;	/* Reset when last region is killed */
		return 1;
	}
	return 0;
}

/*			N M G _ K M
 *
 *	Kill an entire model.  Nothing is left.
 */
void
nmg_km(struct model *m)
{
	NMG_CK_MODEL(m);

	while( BU_LIST_NON_EMPTY( &m->r_hd ) )
		(void)nmg_kr( BU_LIST_FIRST( nmgregion, &m->r_hd ) );

	FREE_MODEL(m);
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_km(m=x%x)\n", m);
	}
}

/************************************************************************
 *									*
 *			"Geometry" and "Attribute" Routines		*
 *									*
 ************************************************************************/

/*			N M G _ V E R T E X _ G V
 *
 *	Associate point_t ("vector") coordinates with a vertex
 */
void
nmg_vertex_gv(struct vertex *v, const fastf_t *pt)
{
	struct vertex_g *vg;
	struct model	*m;

	NMG_CK_VERTEX(v);

	if ( (vg = v->vg_p) ) {
		NMG_CK_VERTEX_G(v->vg_p);
	}
	else {
		m = nmg_find_model(
			&BU_LIST_NEXT(vertexuse, &v->vu_hd)->l.magic );
		GET_VERTEX_G(vg, m);

		vg->magic = NMG_VERTEX_G_MAGIC;
		v->vg_p = vg;
	}
	VMOVE( vg->coord, pt );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_vertex_gv(v=x%x, pt=(%g %g %g))\n", v , V3ARGS( pt ));
	}
}

/*
 *			N M G _ V E R T E X _ G
 *
 *	a version that can take x, y, z coords and doesn't need a point 
 *	array.  Mostly useful for quick and dirty programs.
 */
void
nmg_vertex_g(register struct vertex *v, fastf_t x, fastf_t y, fastf_t z)
{
	point_t pt;
	
	pt[0] = x;
	pt[1] = y;
	pt[2] = z;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_vertex_g(v=x%x, pt=(%g %g %g))\n", v , x , y , z );
	}

	nmg_vertex_gv(v, pt);
}

/* 			N M G _ V E R T E X U S E _ N V
 *
 *	Assign a normal vector to a vertexuse
 */
void
nmg_vertexuse_nv(struct vertexuse *vu, const fastf_t *norm)
{
	struct model *m;

	NMG_CK_VERTEXUSE( vu );

	if( !vu->a.magic_p )  {
		struct vertexuse_a_plane *vua;
		m = nmg_find_model( &vu->l.magic );
		GET_VERTEXUSE_A_PLANE( vua , m );
		vua->magic = NMG_VERTEXUSE_A_PLANE_MAGIC;
		vu->a.plane_p = vua;
	}  else if( *vu->a.magic_p == NMG_VERTEXUSE_A_CNURB_MAGIC )  {
		/* Assigning a normal vector to a cnurb vua is illegal */
		rt_bomb("nmg_vertexuse_nv() Illegal assignment of normal vector to edge_g_cnurb vertexuse\n");
	}  else  {
		NMG_CK_VERTEXUSE_A_PLANE( vu->a.plane_p );
	}

	VMOVE( vu->a.plane_p->N , norm );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_vertexuse_nv(vu=x%x, norm=(%g %g %g))\n", vu , V3ARGS( norm ));
	}
}

/*
 * 			N M G _ V E R T E X U S E _ A _ C N U R B
 *
 *  Given a vertex with associated geometry in model space
 *  which lies on a face_g_snurb surface, it will have
 *  a corresponding set of (u,v) or (u,v,w) parameters on that surface.
 *  Build the association here.
 *
 *  Note that all vertexuses of a single vertex which are all used
 *  by the same face_g_snurb will have the same "param" value, but
 *  will have individual vertexuse_a_cnurb structures.
 */
void
nmg_vertexuse_a_cnurb(struct vertexuse *vu, const fastf_t *uvw)
{
	struct vertexuse_a_cnurb	*vua;
	struct model	*m;

	NMG_CK_VERTEXUSE( vu );

	if( vu->a.magic_p )  rt_bomb("nmg_vertexuse_a_cnurb() vu has attribute already\n");
	NMG_CK_EDGEUSE( vu->up.eu_p );
	if( vu->up.eu_p->g.magic_p) NMG_CK_EDGE_G_CNURB( vu->up.eu_p->g.cnurb_p );

	m = nmg_find_model( &vu->l.magic );
	GET_VERTEXUSE_A_CNURB( vua , m );
	VMOVE( vua->param, uvw );
	vua->magic = NMG_VERTEXUSE_A_CNURB_MAGIC;

	vu->a.cnurb_p = vua;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_vertexuse_a_cnurb(vu=x%x, param=(%g %g %g)) vua=x%x\n",
			vu , V3ARGS( uvw ), vua);
	}
}

/*
 *			N M G _ E D G E _ G
 *
 *	Compute the equation of the line formed by the endpoints of the edge.
 *
 *  XXX This isn't the best name.  nmg_edge_g_lseg() ?
 */
void
nmg_edge_g(struct edgeuse *eu)
{
	struct model *m;	
	struct edge_g_lseg *eg_p = (struct edge_g_lseg *)NULL;
	struct edge	*e;
	struct edgeuse	*eu2;
	pointp_t	pt;
	int		found_eg=0;

	NMG_CK_EDGEUSE(eu);
	e = eu->e_p;
	NMG_CK_EDGE(e);
	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);

	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);

	if(eu->vu_p->v_p == eu->eumate_p->vu_p->v_p )
		rt_bomb("nmg_edge_g(): Warning - edge runs from+to same vertex, 0 len!\n");

	if ( (eg_p = eu->g.lseg_p) ) {
		NMG_CK_EDGE_G_LSEG(eg_p);
		rt_bomb("nmg_edge_g() geometry already assigned\n");
	}

	/* Search all other uses of this edge for an existing edge_g_lseg */
	eu2 = eu->eumate_p->radial_p;
	while( eu2 != eu )  {
		if( eu2->g.magic_p && *eu2->g.magic_p == NMG_EDGE_G_LSEG_MAGIC )  {
			eg_p = eu2->g.lseg_p;
			found_eg = 1;
			break;
		}
		eu2 = eu2->eumate_p->radial_p;
	}

	if( !eg_p )  {
		/* Make new edge_g structure */
		m = nmg_find_model(&eu->l.magic);
		GET_EDGE_G_LSEG(eg_p, m);
		BU_LIST_INIT( &eg_p->eu_hd2 );
		eg_p->l.magic = NMG_EDGE_G_LSEG_MAGIC;

		/* copy the point from the vertex of one of our edgeuses */
		pt = eu->vu_p->v_p->vg_p->coord;
		VMOVE(eg_p->e_pt, pt);

		/* compute the direction from the endpoints of the edgeuse(s) */
		pt = eu->eumate_p->vu_p->v_p->vg_p->coord;
		VSUB2(eg_p->e_dir, eg_p->e_pt, pt);	

		/* If the edge vector is essentially 0 magnitude we're in trouble.
		 * Warn the user and create an arbitrary vector we can use.
		 */
		if (VNEAR_ZERO(eg_p->e_dir, SMALL_FASTF)) {
			pointp_t pt2 = eu->vu_p->v_p->vg_p->coord;
			VPRINT("nmg_edge_g(): e_dir too small", eg_p->e_dir);
			bu_log("nmg_edge_g(): (%g %g %g) -> (%g %g %g)",
					pt[X],  pt[Y],  pt[Z],
					pt2[X], pt2[Y], pt2[Z]);

			VSET(eg_p->e_dir, 1.0, 0.0, 0.0);
			VPRINT("nmg_edge_g(): Forcing e_dir to", eg_p->e_dir);
			rt_bomb("nmg_edge_g():  0 length edge\n");
		}
	}

	/* Dequeue edgeuses from their current list (should point to themselves), add to new list */
	BU_LIST_DEQUEUE( &eu->l2 );
	BU_LIST_DEQUEUE( &eu->eumate_p->l2 );

	/* Associate edgeuse with this geometry */
	BU_LIST_INSERT( &eg_p->eu_hd2, &eu->l2 );
	BU_LIST_INSERT( &eg_p->eu_hd2, &eu->eumate_p->l2 );
	eu->g.lseg_p = eg_p;
	eu->eumate_p->g.lseg_p = eg_p;

	if( !found_eg )
	{
		/* No uses of this edge have geometry, get them all */
		eu2 = eu->eumate_p->radial_p;
		while( eu2 != eu )
		{
			eu2->g.lseg_p = eg_p;
			BU_LIST_INSERT( &eg_p->eu_hd2, &eu2->l2 );
			eu2->eumate_p->g.lseg_p = eg_p;
			BU_LIST_INSERT( &eg_p->eu_hd2, &eu2->eumate_p->l2 );

			eu2 = eu2->eumate_p->radial_p;
		}
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_edge_g(eu=x%x) eg=x%x\n", eu, eg_p );
	}
}

/*
 *			N M G _ E D G E _ G _ C N U R B
 *
 *  For an edgeuse associated with a face_g_snurb surface,
 *  create a spline curve in the parameter space of the snurb
 *  which describes the path from the start vertex to the end vertex.
 *
 *  The parameters of the end points are taken from the vertexuse attributes
 *  at either end of the edgeuse.
 */
void
nmg_edge_g_cnurb(struct edgeuse *eu, int order, int n_knots, fastf_t *kv, int n_pts, int pt_type, fastf_t *points)
{
	struct model	*m;
	struct edge_g_cnurb *eg;
	struct edge	*e;
	struct faceuse	*fu;

	NMG_CK_EDGEUSE(eu);
	e = eu->e_p;
	NMG_CK_EDGE(e);
	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);

	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);

#if 0
	if(eu->vu_p->v_p == eu->eumate_p->vu_p->v_p )
		rt_bomb("nmg_edge_g_cnurb(): edge runs from+to same vertex, 0 len!\n");
#endif

	if (eu->g.cnurb_p) {
		rt_bomb("nmg_edge_g_cnurb() geometry already assigned\n");
	}
	fu = nmg_find_fu_of_eu(eu);
	NMG_CK_FACEUSE(fu);
	NMG_CK_FACE_G_SNURB( fu->f_p->g.snurb_p );

	/* Make new edge_g structure */
	m = nmg_find_model(&eu->l.magic);
	GET_EDGE_G_CNURB(eg, m);
	BU_LIST_INIT( &eg->eu_hd2 );

	eg->order = order;
	if( n_knots > 0 && kv )  {
		eg->k.k_size = n_knots;
		eg->k.knots = kv;
	} else {
		/* Give a default curve, no interior knots */
		rt_nurb_kvknot( &eg->k, order, 0.0, 1.0, n_knots - (2 * order), (struct resource *)NULL );
	}

	if( n_pts < 2 )  rt_bomb("nmg_edge_g_cnurb() n_pts < 2\n");
	eg->c_size = n_pts;
	eg->pt_type = pt_type;
	if( points )  {
		eg->ctl_points = points;
	} else {
		int	ncoord = RT_NURB_EXTRACT_COORDS(pt_type);

		eg->ctl_points = (fastf_t *)bu_calloc(
			ncoord * n_pts,
			sizeof(fastf_t),
			"cnurb ctl_points[]" );

		/*
		 * As a courtesy, set first and last point to 
		 * the PARAMETER values of the edge's vertices.
		 */
		NMG_CK_VERTEXUSE_A_CNURB( eu->vu_p->a.cnurb_p );
		NMG_CK_VERTEXUSE_A_CNURB( eu->eumate_p->vu_p->a.cnurb_p );
		switch( ncoord )  {
		case 4:
			eg->ctl_points[3] = 1;
			eg->ctl_points[ (n_pts-1)*ncoord + 3] = 1;
			/* fall through... */
		case 3:
			VMOVE( eg->ctl_points, eu->vu_p->a.cnurb_p->param );
			VMOVE( &eg->ctl_points[ (n_pts-1)*ncoord ],
				eu->eumate_p->vu_p->a.cnurb_p->param );
			break;
		case 2:
			V2MOVE( eg->ctl_points, eu->vu_p->a.cnurb_p->param );
			V2MOVE( &eg->ctl_points[ (n_pts-1)*ncoord ],
				eu->eumate_p->vu_p->a.cnurb_p->param );
			break;
		default:
			rt_bomb("nmg_edge_g_cnurb() bad ncoord?\n");
		}
	}

	/* Dequeue edgeuses from their current list (should point to themselves), add to new list */
	BU_LIST_DEQUEUE( &eu->l2 );
	BU_LIST_DEQUEUE( &eu->eumate_p->l2 );

	/* Associate edgeuse with this geometry */
	BU_LIST_INSERT( &eg->eu_hd2, &eu->l2 );
	BU_LIST_INSERT( &eg->eu_hd2, &eu->eumate_p->l2 );
	eu->g.cnurb_p = eg;
	eu->eumate_p->g.cnurb_p = eg;

	eg->l.magic = NMG_EDGE_G_CNURB_MAGIC;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_edge_g_cnurb(eu=x%x, order=%d, n_knots=%d, kv=x%x, n_pts=%d, pt_type=x%x, points=x%x) eg=x%x\n",
			eu, order, n_knots, eg->k.knots,
			n_pts, pt_type, eg->ctl_points, eg );
	}
}

/*
 *			N M G _ E D G E _ G _ C N U R B _ P L I N E A R
 *
 *  For an edgeuse associated with a face_g_snurb surface,
 *  create a spline "curve" in the parameter space of the snurb
 *  which describes a STRAIGHT LINE in parameter space
 *  from the u,v parameters of the start vertex to the end vertex.
 *
 *  The parameters of the end points are found in the vertexuse attributes
 *  at either end of the edgeuse, which should have already been established.
 *
 *  This is a special case of nmg_edge_g_cnurb(), and should be used when
 *  the path through parameter space is known to be a line segment.
 *  This permits the savings of a lot of memory, both in core and on disk,
 *  by eliminating a knot vector (typ. 64 bytes or more) and a
 *  ctl_point[] array (typ. 16 bytes or more).
 *
 *  This special condition is indicated by order == 0.  See nmg.h for details.
 */
void
nmg_edge_g_cnurb_plinear(struct edgeuse *eu)
{
	struct model	*m;
	struct edge_g_cnurb *eg;
	struct edge	*e;
	struct faceuse	*fu;

	NMG_CK_EDGEUSE(eu);
	e = eu->e_p;
	NMG_CK_EDGE(e);
	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);

	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);

	NMG_CK_VERTEXUSE_A_CNURB( eu->vu_p->a.cnurb_p );
	NMG_CK_VERTEXUSE_A_CNURB( eu->eumate_p->vu_p->a.cnurb_p );

#if 0
	if(eu->vu_p->v_p == eu->eumate_p->vu_p->v_p )
		rt_bomb("nmg_edge_g_cnurb_plinear(): edge runs from+to same vertex, 0 len!\n");
#endif

	if (eu->g.cnurb_p) {
		rt_bomb("nmg_edge_g_cnurb_plinear() geometry already assigned\n");
	}
	fu = nmg_find_fu_of_eu(eu);
	NMG_CK_FACEUSE(fu);
	NMG_CK_FACE_G_SNURB( fu->f_p->g.snurb_p );

	/* Make new edge_g structure */
	m = nmg_find_model(&eu->l.magic);
	GET_EDGE_G_CNURB(eg, m);
	BU_LIST_INIT( &eg->eu_hd2 );

	eg->order = 0;		/* SPECIAL FLAG */

	/* Dequeue edgeuses from their current list (should point to themselves), add to new list */
	BU_LIST_DEQUEUE( &eu->l2 );
	BU_LIST_DEQUEUE( &eu->eumate_p->l2 );

	/* Associate edgeuse with this geometry */
	BU_LIST_INSERT( &eg->eu_hd2, &eu->l2 );
	BU_LIST_INSERT( &eg->eu_hd2, &eu->eumate_p->l2 );
	eu->g.cnurb_p = eg;
	eu->eumate_p->g.cnurb_p = eg;

	eg->l.magic = NMG_EDGE_G_CNURB_MAGIC;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_edge_g_cnurb_plinear(eu=x%x) order=0, eg=x%x\n",
			eu, eg );
	}
}

/*
 *			N M G _ U S E _ E D G E _ G
 *
 *  Associate edgeuse 'eu' with the edge_g_X structure given as 'magic_p'.
 *  If the edgeuse is already associated with some geometry, release
 *  that first.  Note that, to start with, the two edgeuses may be
 *  using different original geometries.
 *
 *  Also do the edgeuse mate.
 *
 *  Returns -
 *	0	If the old edge geometry (eu->g.magic_p) has other uses.
 *	1	If the old edge geometry has been destroyed. Caller beware!
 */
int
nmg_use_edge_g(struct edgeuse *eu, long int *magic_p)
{
	struct edge_g_lseg	*old;
	/* eg->eu_hd2 is a pun for eu_hd2 in either _lseg or _cnurb */
	struct edge_g_lseg	*eg = (struct edge_g_lseg *)magic_p;
	int			ndead = 0;

	if( !magic_p )  return 0;	/* Don't use a null new geom */

	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGE_G_LSEG(eg);
	if( eu == eu->eumate_p )  rt_bomb("nmg_use_edge_g() eu == eumate_p!\n");

	old = eu->g.lseg_p;	/* This may be NULL.  For printing only. */

	/* Sanity check */
	if( old && eg )  {
#if 0
		vect_t		dir_src;
		vect_t		dir_dest;
		fastf_t		deg;
		double		cos_ang;

		VMOVE( dir_src, old->e_dir );
		VUNITIZE( dir_src );
		VMOVE( dir_dest, eg->e_dir );
		VUNITIZE( dir_dest );
		cos_ang = fabs(VDOT( dir_src, dir_dest ));
		if( cos_ang > 1.0 )
			cos_ang = 1.0;
		deg = acos( cos_ang ) * bn_radtodeg;
		if( fabs(deg) > 2 )  {
			VPRINT( "dir_src ", dir_src );
			VPRINT( "dir_dest", dir_dest );
			bu_log("nmg_use_edge_g() NOTICE Angle between old=x%x & new=x%x lines was %g deg.\n",
				old, eg, deg );
			rt_bomb("nmg_use_edge_g() angle between old & new lines is excessive\n");
		}
#endif
	}

	/* Handle edgeuse */
	if( eu->g.lseg_p != eg && eu->g.lseg_p )  {

		NMG_CK_EDGE_G_LSEG(eu->g.lseg_p);

		BU_LIST_DEQUEUE( &eu->l2 );
		ndead += nmg_keg( eu );
		eu->g.magic_p = (long *)NULL;
	}
	if( eu->g.lseg_p != eg )  {
		BU_LIST_INSERT( &eg->eu_hd2, &(eu->l2) );
		eu->g.magic_p = magic_p;
	}

	/* Handle edgeuse mate separately */
	if( eu->eumate_p->g.lseg_p != eg && eu->eumate_p->g.lseg_p )  {
		struct edgeuse	*mate = eu->eumate_p;

		NMG_CK_EDGEUSE(mate);
		NMG_CK_EDGE_G_LSEG(mate->g.lseg_p);

		BU_LIST_DEQUEUE( &mate->l2 );
		ndead += nmg_keg( mate );
		mate->g.magic_p = (long *)NULL;
	}

	if( eu->eumate_p->g.lseg_p != eg )  {
		BU_LIST_INSERT( &eg->eu_hd2, &(eu->eumate_p->l2) );
		eu->eumate_p->g.magic_p = magic_p;
	}
	if( eu->g.magic_p != eu->eumate_p->g.magic_p )  rt_bomb("nmg_use_edge_g() eu and mate not using same geometry?\n");

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_use_edge_g(eu=x%x, magic_p=x%x) old_eg=x%x, ret=%d\n",
			eu, magic_p, old, ndead);
	}
	return ndead;
}

/*			N M G _ L O O P _ G
 *
 *	Build the bounding box for a loop
 *	The bounding box is guaranteed never to have zero thickness.
 * XXX This really isn't loop geometry, this is a loop attribute.
 * XXX This routine really should be called nmg_loop_bb(), unless
 * XXX it gets something more to do.
 */
void
nmg_loop_g(struct loop *l, const struct bn_tol *tol)
{
	struct edgeuse	*eu;
	struct vertex_g	*vg;
	struct loop_g	*lg;
	struct loopuse	*lu;
	struct model	*m;
	long		magic1;
	FAST fastf_t	thickening;

	NMG_CK_LOOP(l);
	BN_CK_TOL(tol);
	lu = l->lu_p;
	NMG_CK_LOOPUSE(lu);

	if ( (lg = l->lg_p) ) {
		NMG_CK_LOOP_G(lg);
	} else {
		m = nmg_find_model( lu->up.magic_p );
		GET_LOOP_G(l->lg_p, m);
		lg = l->lg_p;
		lg->magic = NMG_LOOP_G_MAGIC;
	}
	VSETALL( lg->max_pt, -INFINITY );
	VSETALL( lg->min_pt,  INFINITY );

	magic1 = BU_LIST_FIRST_MAGIC( &lu->down_hd );
	if (magic1 == NMG_EDGEUSE_MAGIC) {
		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			vg = eu->vu_p->v_p->vg_p;
			NMG_CK_VERTEX_G(vg);
			VMINMAX(lg->min_pt, lg->max_pt, vg->coord);
			if( !eu->g.magic_p && eu->vu_p->v_p != eu->eumate_p->vu_p->v_p )
				nmg_edge_g(eu);
		}
	} else if (magic1 == NMG_VERTEXUSE_MAGIC) {
		struct vertexuse	*vu;
		vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
		NMG_CK_VERTEXUSE(vu);
		NMG_CK_VERTEX(vu->v_p);
		vg = vu->v_p->vg_p;
		NMG_CK_VERTEX_G(vg);
		VMOVE(lg->min_pt, vg->coord);
		VMOVE(lg->max_pt, vg->coord);
	} else {
		bu_log("nmg_loop_g() loopuse down is %s (x%x)\n",
			bu_identify_magic(magic1), magic1 );
		rt_bomb("nmg_loop_g() loopuse has bad child\n");
	}

	/*
	 *  For the case of an axis-aligned loop, ensure that a 0-thickness
	 *  face is not missed, e.g. by rt_in_rpp(). Thicken the bounding
	 *  RPP so that it is 10*dist_tol thicker than the MINMAX
	 *  calculations above report.
	 *  This ensures enough "surface area" on the thin side of the RPP
	 *  that a ray won't miss it.
	 */
	thickening = 5 * tol->dist;
	lg->min_pt[X] -= thickening;
	lg->min_pt[Y] -= thickening;
	lg->min_pt[Z] -= thickening;
	lg->max_pt[X] += thickening;
	lg->max_pt[Y] += thickening;
	lg->max_pt[Z] += thickening;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_loop_g(l=x%x, tol=x%x)\n", l , tol);
	}

}

/*			N M G _ F A C E _ G
 *
 *	Assign plane equation to face.
 * XXX Should probably be called nmg_face_g_plane()
 *
 *  In the interest of modularity this no longer calls nmg_face_bb().
 */
void
nmg_face_g(struct faceuse *fu, const fastf_t *p)
{
	int i;
	struct face_g_plane	*fg;
	struct face	*f;
	struct model	*m;

	NMG_CK_FACEUSE(fu);
	f = fu->f_p;
	NMG_CK_FACE(f);

	fu->orientation = OT_SAME;
	fu->fumate_p->orientation = OT_OPPOSITE;

	fg = f->g.plane_p;
	if (fg) {
		/* Face already has face_g_plane associated with it */
		NMG_CK_FACE_G_PLANE(fg);
	} else {
		m = nmg_find_model( &fu->l.magic );
		GET_FACE_G_PLANE(f->g.plane_p, m);
		f->flip = 0;
		fg = f->g.plane_p;
		fg->magic = NMG_FACE_G_PLANE_MAGIC;
		BU_LIST_INIT(&fg->f_hd);
		BU_LIST_APPEND( &fg->f_hd, &f->l );
	}

	if( f->flip )  {
		for (i=0 ; i < ELEMENTS_PER_PLANE ; i++)
			fg->N[i] = -p[i];
	} else {
		HMOVE( fg->N, p );
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_face_g(fu=x%x, p=(%g %g %g %g))\n", fu , V4ARGS( p ));
	}
}


/*		N M G _ F A C E _ N E W _ P L A N E
 *
 *	Assign plane equation to this face. If other faces use current
 *	geometry for this face, then make a new geometry for this face.
 */
void
nmg_face_new_g(struct faceuse *fu, const fastf_t *pl)
{
	struct face *f;
	struct face *f_tmp;
	struct face_g_plane *fg;
	struct model *m;
	int use_count=0;

	NMG_CK_FACEUSE( fu );
	f = fu->f_p;
	NMG_CK_FACE( f );
	fg = f->g.plane_p;

	/* if this face has no geometry, just call nmg_face_g() */
	if( !fg )
	{
		nmg_face_g( fu, pl );
		return;
	}

	/* count uses of this face geometry */
	for( BU_LIST_FOR( f_tmp, face, &fg->f_hd ) )
		use_count++;

	/* if this is the only use, just call nmg_face_g() */
	if( use_count < 2 )
	{
		nmg_face_g( fu, pl );
		return;
	}

	/* There is at least one other use of this face geometry */

	fu->orientation = OT_SAME;
	fu->fumate_p->orientation = OT_OPPOSITE;

	/* dequeue this face from fg's face list */
	BU_LIST_DEQUEUE( &f->l );

	/* get a new geometry sructure */
	m = nmg_find_model( &fu->l.magic );
	GET_FACE_G_PLANE(f->g.plane_p, m);
	f->flip = 0;
	fg = f->g.plane_p;
	fg->magic = NMG_FACE_G_PLANE_MAGIC;
	BU_LIST_INIT(&fg->f_hd);
	BU_LIST_APPEND( &fg->f_hd, &f->l );

	HMOVE( fg->N, pl );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_face_new_g(fu=x%x, pl=(%g %g %g %g))\n", fu , V4ARGS( pl ));
	}
}

/*
 *			N M G _ F A C E _ G _ S N U R B
 *
 *  Create a new NURBS surface to be the geometry for an NMG face.
 *
 *  If either of the knot vector arrays or the ctl_points arrays are
 *  given as non-null, then simply swipe the caller's arrays.
 *  The caller must have allocated them with bu_malloc() or malloc().
 *  If the pointers are NULL, then the necessary storage is allocated here.
 *
 *  This is the NMG parallel to rt_nurb_new_snurb().
 */
void
nmg_face_g_snurb(struct faceuse *fu, int u_order, int v_order, int n_u_knots, int n_v_knots, fastf_t *ukv, fastf_t *vkv, int n_rows, int n_cols, int pt_type, fastf_t *mesh)
{
	struct face_g_snurb	*fg;
	struct face	*f;
	struct model	*m;

	NMG_CK_FACEUSE(fu);
	f = fu->f_p;
	NMG_CK_FACE(f);

	fu->orientation = OT_SAME;
	fu->fumate_p->orientation = OT_OPPOSITE;

	fg = f->g.snurb_p;
	if (fg) {
		/* Face already has geometry associated with it */
		rt_bomb("nmg_face_g_snurb() face already has geometry\n");
	}

	m = nmg_find_model( &fu->l.magic );
	GET_FACE_G_SNURB(f->g.snurb_p, m);
	fg = f->g.snurb_p;

	fg->order[0] = u_order;
	fg->order[1] = v_order;
	fg->u.magic = NMG_KNOT_VECTOR_MAGIC;
	fg->v.magic = NMG_KNOT_VECTOR_MAGIC;
	fg->u.k_size = n_u_knots;
	fg->v.k_size = n_v_knots;

	if( ukv )  {
		fg->u.knots = ukv;
	} else {
		fg->u.knots = (fastf_t *)bu_calloc(
			n_u_knots, sizeof(fastf_t), "u.knots[]" );
	}
	if( vkv )  {
		fg->v.knots = vkv;
	} else {
		fg->v.knots = (fastf_t *)bu_calloc(
			n_v_knots, sizeof(fastf_t), "v.knots[]" );
	}

	fg->s_size[0] = n_rows;
	fg->s_size[1] = n_cols;
	fg->pt_type = pt_type;

	if( mesh )  {
		fg->ctl_points = mesh;
	} else {
		int	nwords;
		nwords = n_rows * n_cols * RT_NURB_EXTRACT_COORDS(pt_type);
		fg->ctl_points = (fastf_t *)bu_calloc(
			nwords, sizeof(fastf_t), "snurb ctl_points[]" );
	}

	f->flip = 0;
	BU_LIST_INIT(&fg->f_hd);
	BU_LIST_APPEND( &fg->f_hd, &f->l );
	fg->l.magic = NMG_FACE_G_SNURB_MAGIC;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_face_g_snurb(fu=x%x, u_order=%d, v_order=%d, n_u_knots=%d, n_v_knots=%d, ukv=x%x, vkv=x%x, n_rows=%d, n_cols=%d, pt_type=x%x, mesh=x%x) fg=x%x\n",
			fu, u_order, v_order, n_u_knots, n_v_knots,
			fg->u.knots, fg->v.knots,
			n_rows, n_cols, pt_type, fg->ctl_points, fg );
	}
}

/*			N M G _ F A C E _ B B
 *
 *	Build the bounding box for a face
 *
 */
void
nmg_face_bb(struct face *f, const struct bn_tol *tol)
{
	struct loopuse	*lu;
	struct faceuse	*fu;

	BN_CK_TOL(tol);
	NMG_CK_FACE(f);
	fu = f->fu_p;
	NMG_CK_FACEUSE(fu);

	f->max_pt[X] = f->max_pt[Y] = f->max_pt[Z] = -MAX_FASTF;
	f->min_pt[X] = f->min_pt[Y] = f->min_pt[Z] = MAX_FASTF;

	/* compute the extent of the face by looking at the extent of
	 * each of the loop children.
	 */
	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		nmg_loop_g(lu->l_p, tol);

		if (lu->orientation != OT_BOOLPLACE) {
			VMIN(f->min_pt, lu->l_p->lg_p->min_pt);
			VMAX(f->max_pt, lu->l_p->lg_p->max_pt);
		}
	}

	/* Note, calculating the bounding box for face_g_snurbs
	 * from the extents of the the loop does not work
	 * since the loops are most likely in parametric space
 	 * thus we need to calcualte the bounding box for the
	 * face_g_snurb here instead.  There may be a more efficient
	 * way, and one may need some time to take a good look at
	 * this
	 */

	if( *fu->f_p->g.magic_p == NMG_FACE_G_SNURB_MAGIC )
	{
		rt_nurb_s_bound( fu->f_p->g.snurb_p, fu->f_p->g.snurb_p->min_pt,
			fu->f_p->g.snurb_p->max_pt);
		VMIN(f->min_pt, fu->f_p->g.snurb_p->min_pt );
		VMAX(f->max_pt, fu->f_p->g.snurb_p->max_pt );
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_face_bb(f=x%x, tol=x%x)\n", f , tol);
	}
}

/*			N M G _ S H E L L _ A
 *
 *	Build the bounding box for a shell
 *
 */
void
nmg_shell_a(struct shell *s, const struct bn_tol *tol)
{
	struct shell_a *sa;
	struct vertex_g *vg;
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct model	*m;

	NMG_CK_SHELL(s);
	BN_CK_TOL(tol);

	if (s->sa_p) {
		NMG_CK_SHELL_A(s->sa_p);
	} else {
		m = nmg_find_model( &s->l.magic );
		GET_SHELL_A(s->sa_p, m);
		s->sa_p->magic = NMG_SHELL_A_MAGIC;
	}
	sa = s->sa_p;

	VSETALL( sa->max_pt , -MAX_FASTF);
	VSETALL( sa->min_pt , MAX_FASTF);

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		struct face	*f;

		f = fu->f_p;
		NMG_CK_FACE(f);
		nmg_face_bb(f, tol);

		VMIN(sa->min_pt, f->min_pt);
		VMAX(sa->max_pt, f->max_pt);

		/* If next faceuse shares this face, skip it */
		if( BU_LIST_NOT_HEAD(fu, &fu->l) &&
		    ( BU_LIST_NEXT(faceuse, &fu->l)->f_p == f ) )  {
			fu = BU_LIST_PNEXT(faceuse,fu);
		}
	}
	for( BU_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
		nmg_loop_g(lu->l_p, tol);

		VMIN(sa->min_pt, lu->l_p->lg_p->min_pt);
		VMAX(sa->max_pt, lu->l_p->lg_p->max_pt);
	}
	for( BU_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGE(eu->e_p);
		vg = eu->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G(vg);
		VMINMAX(sa->min_pt, sa->max_pt, vg->coord);
	}
	if (s->vu_p) {
		NMG_CK_VERTEXUSE(s->vu_p);
		NMG_CK_VERTEX(s->vu_p->v_p);
		if( s->vu_p->v_p->vg_p )
		{
			NMG_CK_VERTEX_G(s->vu_p->v_p->vg_p);
			vg = s->vu_p->v_p->vg_p;
			VMINMAX(sa->min_pt, sa->max_pt, vg->coord);
		}
	}


	if( BU_LIST_IS_EMPTY( &s->fu_hd ) &&
	    BU_LIST_IS_EMPTY( &s->lu_hd ) &&
	    BU_LIST_IS_EMPTY( &s->eu_hd ) && !s->vu_p )  {
		bu_log("nmg_shell_a() at %d in %s. Shell has no children\n",
		    __LINE__, __FILE__);
		rt_bomb("nmg_shell_a\n");
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_shell_a(s=x%x, tol=x%x)\n", s , tol);
	}
}

/*			N M G _ R E G I O N _ A
 *
 *	build attributes/extents for all shells in a region
 *
 */
void
nmg_region_a(struct nmgregion *r, const struct bn_tol *tol)
{
	register struct shell	*s;
	struct nmgregion_a	*ra;

	NMG_CK_REGION(r);
	BN_CK_TOL(tol);
	if( r->ra_p )  {
		ra = r->ra_p;
		NMG_CK_REGION_A(ra);
	} else {
		GET_REGION_A(ra, r->m_p);
		r->ra_p = ra;
	}

	ra->magic = NMG_REGION_A_MAGIC;

	VSETALL(ra->max_pt, -MAX_FASTF);
	VSETALL(ra->min_pt, MAX_FASTF);

	for( BU_LIST_FOR( s, shell, &r->s_hd ) )  {
		nmg_shell_a(s, tol);
		NMG_CK_SHELL_A(s->sa_p);
		VMIN(ra->min_pt, s->sa_p->min_pt);
		VMAX(ra->max_pt, s->sa_p->max_pt);
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_region_a(r=x%x, tol=x%x)\n", r , tol);
	}
}

/************************************************************************
 *									*
 *				"Demote" Routines			*
 *									*
 *  As part of the boolean operations, sometimes it is desirable	*
 *  to "demote" entities down the "chain of being".  The sequence is:	*
 *									*
 *	face --> wire loop --> wire edge (line segment) --> vertex	*
 *									*
 ************************************************************************/


/*
 *			N M G _ D E M O T E _ L U
 *
 *	Demote a loopuse of edgeuses to a bunch of wire edges in the shell.
 *
 *  Returns -
 *	0	If all is well (edges moved to shell, loopuse deleted).
 *	1	If parent is empty, and is thus "illegal".  Still successful.
 */
int
nmg_demote_lu(struct loopuse *lu1)
{
	struct edgeuse *eu1;
	struct shell *s;
	int ret_val;

	NMG_CK_LOOPUSE(lu1);

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		bu_log("nmg_demote_lu(x%x)\n", lu1);

	if (BU_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_VERTEXUSE_MAGIC) {
		rt_bomb("nmg_demote_lu() demoting loopuse of a single vertex\n");
	}

	if (BU_LIST_FIRST_MAGIC(&lu1->down_hd) != NMG_EDGEUSE_MAGIC)
		rt_bomb("nmg_demote_lu: bad loopuse child\n");

	/* get the parent shell */
	s = nmg_find_s_of_lu(lu1);
	NMG_CK_SHELL(s);

	/* move all edgeuses (&mates) to shell
	 */
	while ( BU_LIST_NON_EMPTY(&lu1->down_hd) ) {

		eu1 = BU_LIST_FIRST(edgeuse, &lu1->down_hd);
		NMG_CK_EDGEUSE(eu1);
		NMG_CK_EDGE(eu1->e_p);
		NMG_CK_EDGEUSE(eu1->eumate_p);
		NMG_CK_EDGE(eu1->eumate_p->e_p);

		BU_LIST_DEQUEUE(&eu1->eumate_p->l);
		BU_LIST_APPEND(&s->eu_hd, &eu1->eumate_p->l);

		BU_LIST_DEQUEUE(&eu1->l);
		BU_LIST_APPEND(&s->eu_hd, &eu1->l);

		eu1->up.s_p = eu1->eumate_p->up.s_p = s;
	}
	/* lu1 is in an illegal state here, with a null edge list */

	if (BU_LIST_NON_EMPTY(&lu1->lumate_p->down_hd))
		rt_bomb("nmg_demote_lu: loopuse mates don't have same # of edges\n");

	ret_val = nmg_klu(lu1);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_demote_lu(lu=x%x) returns %d\n", lu1 , ret_val);
	}

	return( ret_val );
}

/*			N M G _ D E M O T E _ E U
 *
 *	Demote a wire edge into a pair of self-loop verticies
 *
 *
 *  Returns -
 *	0	If all is well
 *	1	If shell is empty, and is thus "illegal".
 */
int
nmg_demote_eu(struct edgeuse *eu)
{
	struct shell	*s;
	struct vertex	*v;
	int		ret_val;

	if (*eu->up.magic_p != NMG_SHELL_MAGIC)
		rt_bomb("nmg_demote_eu() up is not shell\n");
	s = eu->up.s_p;
	NMG_CK_SHELL(s);

	NMG_CK_EDGEUSE(eu);
	v = eu->vu_p->v_p;
	if( !nmg_is_vertex_a_selfloop_in_shell(v, s) )
		(void)nmg_mlv(&s->l.magic, v, OT_SAME);

	NMG_CK_EDGEUSE(eu->eumate_p);
	v = eu->eumate_p->vu_p->v_p;
	if( !nmg_is_vertex_a_selfloop_in_shell(v, s) )
		(void)nmg_mlv(&s->l.magic, v, OT_SAME);

	(void)nmg_keu(eu);

	ret_val = nmg_shell_is_empty(s);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_demote_eu(eu=x%x) returns %d\n", eu , ret_val);
	}

	return( ret_val );
}

/************************************************************************
 *									*
 *				"Modify" Routines			*
 *									*
 *  These routines would go in nmg_mod.c, except that they create	*
 *  or delete fundamental entities directly as part of their operation.	*
 *  Thus, they are part of the make/kill purpose of this module.	*
 *									*
 ************************************************************************/

/*			N M G _ M O V E V U
 *
 *	Move a vertexuse from an old vertex to a new vertex.
 *	If this was the last use, the old vertex is destroyed.
 *
 * XXX nmg_jvu() as a better name?
 */
void
nmg_movevu(struct vertexuse *vu, struct vertex *v)
{
	struct vertex	*oldv;

	NMG_CK_VERTEXUSE(vu);
	NMG_CK_VERTEX(v);

	oldv = vu->v_p;
	NMG_CK_VERTEX(oldv);

	BU_LIST_DEQUEUE( &vu->l );
	if( BU_LIST_IS_EMPTY( &oldv->vu_hd ) )  {
		/* last vertexuse on vertex */
		if (oldv->vg_p) FREE_VERTEX_G(oldv->vg_p);
		FREE_VERTEX(oldv);
	}
	BU_LIST_APPEND( &v->vu_hd, &vu->l );
	vu->v_p = v;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_movevu(vu=x%x, v=x%x)\n", vu , v);
	}
}

/*
 *			N M G _ J E
 *
 *	Move a pair of edgeuses onto a single edge (glue edgeuse).
 *	The edgeuse eusrc and its mate are moved to the edge
 *	used by eudst.  eusrc is made to be immediately radial to eudst.
 *	if eusrc does not share the same vertices as eudst, we bomb.
 *
 *	The edgeuse geometry pointers are not changed by this operation.
 *
 *	This routine was formerly called nmg_moveeu().
 */
void
nmg_je(struct edgeuse *eudst, struct edgeuse *eusrc)
{
	struct edgeuse	*eudst_mate;
	struct edgeuse	*eusrc_mate;
	struct edge	*e;

	NMG_CK_EDGEUSE(eudst);
	NMG_CK_EDGEUSE(eusrc);
	eudst_mate = eudst->eumate_p;
	eusrc_mate = eusrc->eumate_p;
	NMG_CK_EDGEUSE(eudst_mate);
	NMG_CK_EDGEUSE(eusrc_mate);

	/* protect the morons from themselves.  Don't let them
	 * move an edgeuse to itself or it's mate
	 */
	if (eusrc == eudst || eusrc_mate == eudst)  {
		bu_log("nmg_je() moving edgeuse to itself\n");
		return;
	}

	if (eusrc->e_p == eudst->e_p &&
	    (eusrc->radial_p == eudst || eudst->radial_p == eusrc))  {
	    	bu_log("nmg_je() edgeuses already share edge\n");
		return;
	}

	/* make sure vertices are shared */
	if ( ! ( (eudst_mate->vu_p->v_p == eusrc->vu_p->v_p &&
	    eudst->vu_p->v_p == eusrc_mate->vu_p->v_p) ||
	    (eudst->vu_p->v_p == eusrc->vu_p->v_p &&
	    eudst_mate->vu_p->v_p == eusrc_mate->vu_p->v_p) ) ) {
		/* edgeuses do NOT share verticies. */
	    	bu_log( "eusrc (v=x%x) (%g %g %g)\n", eusrc->vu_p->v_p, V3ARGS( eusrc->vu_p->v_p->vg_p->coord ) );
	    	bu_log( "eusrc_mate (v=x%x) (%g %g %g)\n", eusrc_mate->vu_p->v_p, V3ARGS( eusrc_mate->vu_p->v_p->vg_p->coord ) );
	    	bu_log( "eudst (v=x%x) (%g %g %g)\n", eudst->vu_p->v_p, V3ARGS( eudst->vu_p->v_p->vg_p->coord ) );
	    	bu_log( "eudst_mate (v=x%x) (%g %g %g)\n", eudst_mate->vu_p->v_p, V3ARGS( eudst_mate->vu_p->v_p->vg_p->coord ) );
	    	rt_bomb("nmg_je() edgeuses do not share vertices, cannot share edge\n");
	}

	e = eusrc->e_p;
	eusrc_mate->e_p = eusrc->e_p = eudst->e_p;

	/* if we're not deleting the edge, make sure it will be able
	 * to reference the remaining uses, otherwise, take care of disposing
	 * of the (now unused) edge
	 */
	if (eusrc->radial_p != eusrc_mate) {
		/* this is NOT the only use of the eusrc edge! */
		if (e->eu_p == eusrc || e->eu_p == eusrc_mate)
			e->eu_p = eusrc->radial_p;

		/* disconnect from the list of uses of this edge */
		eusrc->radial_p->radial_p = eusrc_mate->radial_p;
		eusrc_mate->radial_p->radial_p = eusrc->radial_p;
	} else {
		/* this is the only use of the eusrc edge.  Kill edge. */
		FREE_EDGE(e);
	}

	eusrc->radial_p = eudst;
	eusrc_mate->radial_p = eudst->radial_p;

	eudst->radial_p->radial_p = eusrc_mate;
	eudst->radial_p = eusrc;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_je(eudst=x%x, eusrc=x%x)\n", eudst , eusrc);
	}
}

/*
 *			N M G _ U N G L U E E D G E
 *
 *	If edgeuse is part of a shared edge (more than one pair of edgeuses
 *	on the edge), it and its mate are "unglued" from the edge, and 
 *	associated with a new edge structure.
 *
 *	Primarily a support routine for nmg_eusplit()
 *
 *  If the original edge had edge geometry, that is *not* duplicated here,
 *  because it is not easy (or appropriate) for nmg_eusplit() to know
 *  whether the new vertex lies on the previous edge geometry or not.
 *  Hence having the nmg_ebreak() interface, which preserves the ege
 *  geometry across a split, and nmg_esplit() which does not.
 */
void
nmg_unglueedge(struct edgeuse *eu)
{
	struct edge	*old_e;
	struct edge	*new_e;
	struct model	*m;

	NMG_CK_EDGEUSE(eu);
	old_e = eu->e_p;
	NMG_CK_EDGE(old_e);

	/* if we're already a single edge, just return */
	if (eu->radial_p == eu->eumate_p)
	{
		if (rt_g.NMG_debug & DEBUG_BASIC)  {
			bu_log("nmg_unglueedge(eu=x%x) (nothing unglued)\n", eu);
		}
		return;
	}

	m = nmg_find_model( &eu->l.magic );
	GET_EDGE(new_e, m);		/* create new edge */

	new_e->magic = NMG_EDGE_MAGIC;
	new_e->eu_p = eu;

	/* make sure the old edge isn't pointing at this edgeuse */
	if (old_e->eu_p == eu || old_e->eu_p == eu->eumate_p ) {
		old_e->eu_p = old_e->eu_p->radial_p;
	}

	/* unlink edgeuses from old edge */
	eu->radial_p->radial_p = eu->eumate_p->radial_p;
	eu->eumate_p->radial_p->radial_p = eu->radial_p;
	eu->eumate_p->radial_p = eu;
	eu->radial_p = eu->eumate_p;

	/* Associate edgeuse and mate with new edge */
	eu->eumate_p->e_p = eu->e_p = new_e;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_unglueedge(eu=x%x)\n", eu);
	}
}

/*
 *			N M G _ J V
 *
 *	Join two vertexes into one.
 *	v1 inherits all the vertexuses presently pointing to v2,
 *	and v2 is then destroyed.
 */
void
nmg_jv(register struct vertex *v1, register struct vertex *v2)
{
	register struct vertexuse	*vu;

	NMG_CK_VERTEX(v1);
	NMG_CK_VERTEX(v2);

	if (v1 == v2) return;

	/*
	 *  Walk the v2 list, unlinking vertexuse structs,
	 *  and adding them to the *end* of the v1 list
	 *  (which preserves relative ordering).
	 */
	vu = BU_LIST_FIRST(vertexuse, &v2->vu_hd );
	while( BU_LIST_NOT_HEAD( vu, &v2->vu_hd ) )  {
		register struct vertexuse	*vunext;

		NMG_CK_VERTEXUSE(vu);
		vunext = BU_LIST_PNEXT(vertexuse, vu);
		BU_LIST_DEQUEUE( &vu->l );
		BU_LIST_INSERT( &v1->vu_hd, &vu->l );
		vu->v_p = v1;		/* "up" to new vertex */
		vu = vunext;
	}

	/* Kill vertex v2 */
	if (v2->vg_p) {
		if( !v1->vg_p )  {
			v1->vg_p = v2->vg_p;
		} else {
			FREE_VERTEX_G(v2->vg_p);
		}
	}
	FREE_VERTEX(v2);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_jv(v1=x%x, v2=x%x)\n", v1 , v2);
	}
}

/*
 *			N M G _ J F G
 *
 *  Join two faces, so that they share one underlying face geometry.
 *  The loops of the two faces remains unchanged.
 *
 *  If one of the faces does not have any geometry, then it
 *  is made to share the geometry of the other.
 */
void
nmg_jfg(struct face *f1, struct face *f2)
{
	struct face_g_plane	*fg1;
	struct face_g_plane	*fg2;
	struct face	*f;

	NMG_CK_FACE(f1);
	NMG_CK_FACE(f2);
	fg1 = f1->g.plane_p;
	fg2 = f2->g.plane_p;
	if( fg2 && !fg1 )  {
		/* Make f1 share existing geometry of f2 */
		NMG_CK_FACE_G_PLANE(fg1);
		f1->g.plane_p = fg2;
		f1->flip = f2->flip;
		BU_LIST_INSERT( &fg2->f_hd, &f1->l );

		if (rt_g.NMG_debug & DEBUG_BASIC)  {
			bu_log("nmg_jfg(f1=x%x, f2=x%x)\n", f1 , f2);
		}
		return;
	}
	if( fg1 && !fg2 )  {
		/* Make f2 share existing geometry of f1 */
		NMG_CK_FACE_G_PLANE(fg1);
		f2->g.plane_p = fg1;
		f2->flip = f1->flip;
		BU_LIST_INSERT( &fg1->f_hd, &f2->l );

		if (rt_g.NMG_debug & DEBUG_BASIC)  {
			bu_log("nmg_jfg(f1=x%x, f2=x%x)\n", f1 , f2);
		}
		return;
	}

	NMG_CK_FACE_G_PLANE(fg1);
	NMG_CK_FACE_G_PLANE(fg2);

	if( fg1 == fg2 )
	{
		if (rt_g.NMG_debug & DEBUG_BASIC)  {
			bu_log("nmg_jfg(f1=x%x, f2=x%x)\n", f1 , f2);
		}
		return;
	}

	/* Unhook all the faces on fg2 list, and add to fg1 list */
	while( BU_LIST_NON_EMPTY( &fg2->f_hd ) )  {
		f = BU_LIST_FIRST( face, &fg2->f_hd );
		BU_LIST_DEQUEUE( &f->l );
		NMG_CK_FACE(f);
		f->g.plane_p = fg1;
		/* flip flag is left unchanged here, on purpose */
		BU_LIST_INSERT( &fg1->f_hd, &f->l );
	}

	/* fg2 list is now empty, release that face geometry */
	FREE_FACE_G_PLANE(fg2);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_jfg(f1=x%x, f2=x%x)\n", f1 , f2);
	}
}

/*
 *			N M G _ J E G
 *
 *  Join two edge geometries.
 *  For all edges in the model which refer to 'src_eg',
 *  change them to refer to 'dest_eg'.  The source is destroyed.
 *
 *  It is the responsibility of the caller to make certain that the
 *  'dest_eg' is the best one for these edges.
 *  Outrageously wrong requests will cause this routine to abort.
 *
 *  This algorithm does not make sense if dest_eg is an edge_g_cnurb;
 *  those only make sense in the parameter space of their associated face.
 */
void
nmg_jeg(struct edge_g_lseg *dest_eg, struct edge_g_lseg *src_eg)
{
	register struct edgeuse		*eu;

	NMG_CK_EDGE_G_LSEG(src_eg);
	NMG_CK_EDGE_G_LSEG(dest_eg);
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_jeg( src_eg=x%x, dest_eg=x%x )\n",
			src_eg, dest_eg );
	}

#if 0
	/* Sanity check */
	VMOVE( dir_src, src_eg->e_dir );
	VUNITIZE( dir_src );
	VMOVE( dir_dest, dest_eg->e_dir );
	VUNITIZE( dir_dest );
	cos_ang = fabs(VDOT( dir_src, dir_dest ));
	if( cos_ang > 1.0 )
		cos_ang = 1.0;
	deg = acos( cos_ang ) * bn_radtodeg;
	if( fabs(deg) > 2 )  {
		VPRINT( "dir_src ", dir_src );
		VPRINT( "dir_dest", dir_dest );
		bu_log("Angle between lines is %g degrees\n", deg );
		/* This can happen while fixing mistakes, don't bomb. */
	}
#endif
	while( BU_LIST_NON_EMPTY( &src_eg->eu_hd2 ) )  {
		struct bu_list	*midway;	/* &eu->l2, midway into edgeuse */

		NMG_CK_EDGE_G_LSEG(src_eg);

		/* Obtain an eu from src_eg */
		midway = BU_LIST_FIRST(bu_list, &src_eg->eu_hd2 );
		NMG_CKMAG(midway, NMG_EDGEUSE2_MAGIC, "edgeuse2 [l2]");
		eu = BU_LIST_MAIN_PTR( edgeuse, midway, l2 );
		NMG_CK_EDGEUSE(eu);

		if( eu->g.lseg_p != src_eg )  {
			bu_log("nmg_jeg() eu=x%x, eu->g=x%x != src_eg=x%x??  dest_eg=x%x\n",
				eu, eu->g.lseg_p, src_eg, dest_eg );
			rt_bomb("nmg_jeg() edge geometry fumble\n");
		}

		/* Associate eu and mate with dest_eg. src_eg freed when unused. */
		if( nmg_use_edge_g( eu, &dest_eg->l.magic ) )
			break;		/* src_eg destroyed */
	}
}
@


11.36
log
@change conf.h to a wrapped config.h
@
text
@d54 1
a54 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_mk.c,v 11.35 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.35
log
@merge of ansi-6-0-branch into HEAD
@
text
@d54 1
a54 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d57 5
a61 1
#include "conf.h"
@


11.34
log
@update copyright to include span through 2003
@
text
@d54 1
a54 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mk.c,v 11.33 2002/08/20 17:08:05 jra Exp $ (ARL)";
d245 1
a245 1
nmg_mm()
d277 1
a277 1
nmg_mmr()
d316 1
a316 2
nmg_mrsv(m)
struct model *m;
d356 1
a356 2
nmg_msv(r)
struct nmgregion	*r;
d402 1
a402 2
nmg_mf(lu1)
struct loopuse *lu1;
d503 1
a503 4
nmg_mlv(magic, v, orientation)
long		*magic;
struct vertex	*v;
int		orientation;
d616 4
a619 4
nmg_mvu(v, upptr, m)
struct vertex	*v;
long		*upptr;		/* pointer to parent struct */
struct model	*m;
d662 1
a662 3
nmg_mvvu(upptr, m)
long		*upptr;
struct model	*m;
d707 1
a707 3
nmg_me(v1, v2, s)
struct vertex *v1, *v2;
struct shell *s;
d808 1
a808 2
nmg_meonvu(vu)
struct vertexuse *vu;
d936 1
a936 2
nmg_ml(s)
struct shell *s;
d1103 1
a1103 2
nmg_kvu(vu)
register struct vertexuse *vu;
d1160 1
a1160 2
nmg_kfg( magic_p )
long	*magic_p;
d1202 1
a1202 2
nmg_kfu(fu1)
struct faceuse *fu1;
d1266 1
a1266 2
nmg_klu(lu1)
struct loopuse *lu1;
d1350 1
a1350 2
nmg_keg( eu )
struct edgeuse	*eu;
d1395 1
a1395 2
nmg_keu(eu1)
register struct edgeuse *eu1;
d1527 1
a1527 2
nmg_ks(s)
struct shell *s;
d1568 1
a1568 2
nmg_kr(r)
struct nmgregion *r;
d1601 1
a1601 2
nmg_km(m)
struct model *m;
d1625 1
a1625 3
nmg_vertex_gv(v, pt)
struct vertex	*v;
const point_t	pt;
d1657 1
a1657 3
nmg_vertex_g(v, x, y, z)
register struct vertex *v;
fastf_t x, y, z;
d1677 1
a1677 3
nmg_vertexuse_nv( vu , norm )
struct vertexuse *vu;
const vect_t norm;
d1716 1
a1716 3
nmg_vertexuse_a_cnurb( vu, uvw )
struct vertexuse	*vu;
const fastf_t		*uvw;
d1748 1
a1748 2
nmg_edge_g(eu)
struct edgeuse *eu;
d1860 1
a1860 8
nmg_edge_g_cnurb(eu, order, n_knots, kv, n_pts, pt_type, points)
struct edgeuse	*eu;
int		order;
int		n_knots;
fastf_t		*kv;
int		n_pts;
int		pt_type;
fastf_t		*points;
d1983 1
a1983 2
nmg_edge_g_cnurb_plinear(eu)
struct edgeuse	*eu;
d2057 1
a2057 3
nmg_use_edge_g( eu, magic_p )
struct edgeuse	*eu;
long		*magic_p;
d2146 1
a2146 3
nmg_loop_g(l, tol)
struct loop		*l;
const struct bn_tol	*tol;
d2226 1
a2226 3
nmg_face_g(fu, p)
struct faceuse *fu;
const plane_t p;
d2273 1
a2273 3
nmg_face_new_g( fu, pl )
struct faceuse *fu;
const plane_t pl;
d2341 1
a2341 12
nmg_face_g_snurb(fu, u_order, v_order, n_u_knots, n_v_knots, ukv, vkv, n_rows, n_cols, pt_type, mesh)
struct faceuse	*fu;
int		u_order;
int		v_order;
int		n_u_knots;
int		n_v_knots;
fastf_t		*ukv;
fastf_t		*vkv;
int		n_rows;
int		n_cols;
int		pt_type;
fastf_t		*mesh;
d2416 1
a2416 3
nmg_face_bb(f, tol)
struct face		*f;
const struct bn_tol	*tol;
d2469 1
a2469 3
nmg_shell_a(s, tol)
struct shell		*s;
const struct bn_tol	*tol;
d2553 1
a2553 3
nmg_region_a(r, tol)
struct nmgregion	*r;
const struct bn_tol	*tol;
d2607 1
a2607 2
nmg_demote_lu(lu1)
struct loopuse *lu1;
d2671 1
a2671 2
nmg_demote_eu(eu)
struct edgeuse *eu;
d2721 1
a2721 3
nmg_movevu(vu, v)
struct vertexuse *vu;
struct vertex *v;
d2758 1
a2758 2
nmg_je(eudst, eusrc)
struct edgeuse *eudst, *eusrc;
d2845 1
a2845 2
nmg_unglueedge(eu)
struct edgeuse *eu;
d2897 1
a2897 3
nmg_jv(v1, v2)
register struct vertex	*v1;
register struct vertex	*v2;
d2948 1
a2948 3
nmg_jfg( f1, f2 )
struct face	*f1;
struct face	*f2;
d3027 1
a3027 3
nmg_jeg( dest_eg, src_eg )
struct edge_g_lseg	*dest_eg;
struct edge_g_lseg	*src_eg;
@


11.33
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d50 1
a50 1
 *	This software is Copyright (C) 1994 by the United States Army
d54 1
a54 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mk.c,v 11.31 2001/04/20 22:29:51 morrison Exp $ (ARL)";
@


11.33.4.1
log
@sync to HEAD...
@
text
@d50 1
a50 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d54 1
a54 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_mk.c,v 11.34 2004/02/02 17:39:24 morrison Exp $ (ARL)";
@


11.33.10.1
log
@merge from HEAD
@
text
@d50 1
a50 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d54 1
a54 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mk.c,v 11.34 2004/02/02 17:39:24 morrison Exp $ (ARL)";
@


11.33.10.2
log
@merge from head
@
text
@d54 1
a54 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mk.c,v 11.33.10.1 2004/02/12 18:37:45 erikg Exp $ (ARL)";
@


11.33.2.1
log
@Initial ANSIfication
@
text
@d54 1
a54 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mk.c,v 11.33 2002/08/20 17:08:05 jra Exp $ (ARL)";
d245 1
a245 1
nmg_mm(void)
d277 1
a277 1
nmg_mmr(void)
d316 2
a317 1
nmg_mrsv(struct model *m)
d357 2
a358 1
nmg_msv(struct nmgregion *r)
d404 2
a405 1
nmg_mf(struct loopuse *lu1)
d506 4
a509 1
nmg_mlv(long int *magic, struct vertex *v, int orientation)
d622 4
a625 4
nmg_mvu(struct vertex *v, long int *upptr, struct model *m)
             	   
    		       		/* pointer to parent struct */
            	   
d668 3
a670 1
nmg_mvvu(long int *upptr, struct model *m)
d715 3
a717 1
nmg_me(struct vertex *v1, struct vertex *v2, struct shell *s)
d818 2
a819 1
nmg_meonvu(struct vertexuse *vu)
d947 2
a948 1
nmg_ml(struct shell *s)
d1115 2
a1116 1
nmg_kvu(register struct vertexuse *vu)
d1173 2
a1174 1
nmg_kfg(long int *magic_p)
d1216 2
a1217 1
nmg_kfu(struct faceuse *fu1)
d1281 2
a1282 1
nmg_klu(struct loopuse *lu1)
d1366 2
a1367 1
nmg_keg(struct edgeuse *eu)
d1412 2
a1413 1
nmg_keu(register struct edgeuse *eu1)
d1545 2
a1546 1
nmg_ks(struct shell *s)
d1587 2
a1588 1
nmg_kr(struct nmgregion *r)
d1621 2
a1622 1
nmg_km(struct model *m)
d1646 3
a1648 1
nmg_vertex_gv(struct vertex *v, const fastf_t *pt)
d1680 3
a1682 1
nmg_vertex_g(register struct vertex *v, fastf_t x, fastf_t y, fastf_t z)
d1702 3
a1704 1
nmg_vertexuse_nv(struct vertexuse *vu, const fastf_t *norm)
d1743 3
a1745 1
nmg_vertexuse_a_cnurb(struct vertexuse *vu, const fastf_t *uvw)
d1777 2
a1778 1
nmg_edge_g(struct edgeuse *eu)
d1890 8
a1897 1
nmg_edge_g_cnurb(struct edgeuse *eu, int order, int n_knots, fastf_t *kv, int n_pts, int pt_type, fastf_t *points)
d2020 2
a2021 1
nmg_edge_g_cnurb_plinear(struct edgeuse *eu)
d2095 3
a2097 1
nmg_use_edge_g(struct edgeuse *eu, long int *magic_p)
d2186 3
a2188 1
nmg_loop_g(struct loop *l, const struct bn_tol *tol)
d2268 3
a2270 1
nmg_face_g(struct faceuse *fu, const fastf_t *p)
d2317 3
a2319 1
nmg_face_new_g(struct faceuse *fu, const fastf_t *pl)
d2387 12
a2398 1
nmg_face_g_snurb(struct faceuse *fu, int u_order, int v_order, int n_u_knots, int n_v_knots, fastf_t *ukv, fastf_t *vkv, int n_rows, int n_cols, int pt_type, fastf_t *mesh)
d2473 3
a2475 1
nmg_face_bb(struct face *f, const struct bn_tol *tol)
d2528 3
a2530 1
nmg_shell_a(struct shell *s, const struct bn_tol *tol)
d2614 3
a2616 1
nmg_region_a(struct nmgregion *r, const struct bn_tol *tol)
d2670 2
a2671 1
nmg_demote_lu(struct loopuse *lu1)
d2735 2
a2736 1
nmg_demote_eu(struct edgeuse *eu)
d2786 3
a2788 1
nmg_movevu(struct vertexuse *vu, struct vertex *v)
d2825 2
a2826 1
nmg_je(struct edgeuse *eudst, struct edgeuse *eusrc)
d2913 2
a2914 1
nmg_unglueedge(struct edgeuse *eu)
d2966 3
a2968 1
nmg_jv(register struct vertex *v1, register struct vertex *v2)
d3019 3
a3021 1
nmg_jfg(struct face *f1, struct face *f2)
d3100 3
a3102 1
nmg_jeg(struct edge_g_lseg *dest_eg, struct edge_g_lseg *src_eg)
@


11.33.2.2
log
@sync branch with HEAD
@
text
@d50 1
a50 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d54 1
a54 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.32
log
@Converted from K&R to ANSI C - RFH
@
text
@d245 1
a245 1
nmg_mm(void)
d277 1
a277 1
nmg_mmr(void)
d316 2
a317 1
nmg_mrsv(struct model *m)
d357 2
a358 1
nmg_msv(struct nmgregion *r)
d404 2
a405 1
nmg_mf(struct loopuse *lu1)
d506 4
a509 1
nmg_mlv(long int *magic, struct vertex *v, int orientation)
d622 4
a625 4
nmg_mvu(struct vertex *v, long int *upptr, struct model *m)
             	   
    		       		/* pointer to parent struct */
            	   
d668 3
a670 1
nmg_mvvu(long int *upptr, struct model *m)
d715 3
a717 1
nmg_me(struct vertex *v1, struct vertex *v2, struct shell *s)
d818 2
a819 1
nmg_meonvu(struct vertexuse *vu)
d947 2
a948 1
nmg_ml(struct shell *s)
d1115 2
a1116 1
nmg_kvu(register struct vertexuse *vu)
d1173 2
a1174 1
nmg_kfg(long int *magic_p)
d1216 2
a1217 1
nmg_kfu(struct faceuse *fu1)
d1281 2
a1282 1
nmg_klu(struct loopuse *lu1)
d1366 2
a1367 1
nmg_keg(struct edgeuse *eu)
d1412 2
a1413 1
nmg_keu(register struct edgeuse *eu1)
d1545 2
a1546 1
nmg_ks(struct shell *s)
d1587 2
a1588 1
nmg_kr(struct nmgregion *r)
d1621 2
a1622 1
nmg_km(struct model *m)
d1646 3
a1648 1
nmg_vertex_gv(struct vertex *v, const fastf_t *pt)
d1680 3
a1682 1
nmg_vertex_g(register struct vertex *v, fastf_t x, fastf_t y, fastf_t z)
d1702 3
a1704 1
nmg_vertexuse_nv(struct vertexuse *vu, const fastf_t *norm)
d1743 3
a1745 1
nmg_vertexuse_a_cnurb(struct vertexuse *vu, const fastf_t *uvw)
d1777 2
a1778 1
nmg_edge_g(struct edgeuse *eu)
d1890 8
a1897 1
nmg_edge_g_cnurb(struct edgeuse *eu, int order, int n_knots, fastf_t *kv, int n_pts, int pt_type, fastf_t *points)
d2020 2
a2021 1
nmg_edge_g_cnurb_plinear(struct edgeuse *eu)
d2095 3
a2097 1
nmg_use_edge_g(struct edgeuse *eu, long int *magic_p)
d2186 3
a2188 1
nmg_loop_g(struct loop *l, const struct bn_tol *tol)
d2268 3
a2270 1
nmg_face_g(struct faceuse *fu, const fastf_t *p)
d2317 3
a2319 1
nmg_face_new_g(struct faceuse *fu, const fastf_t *pl)
d2387 12
a2398 1
nmg_face_g_snurb(struct faceuse *fu, int u_order, int v_order, int n_u_knots, int n_v_knots, fastf_t *ukv, fastf_t *vkv, int n_rows, int n_cols, int pt_type, fastf_t *mesh)
d2473 3
a2475 1
nmg_face_bb(struct face *f, const struct bn_tol *tol)
d2528 3
a2530 1
nmg_shell_a(struct shell *s, const struct bn_tol *tol)
d2614 3
a2616 1
nmg_region_a(struct nmgregion *r, const struct bn_tol *tol)
d2670 2
a2671 1
nmg_demote_lu(struct loopuse *lu1)
d2735 2
a2736 1
nmg_demote_eu(struct edgeuse *eu)
d2786 3
a2788 1
nmg_movevu(struct vertexuse *vu, struct vertex *v)
d2825 2
a2826 1
nmg_je(struct edgeuse *eudst, struct edgeuse *eusrc)
d2913 2
a2914 1
nmg_unglueedge(struct edgeuse *eu)
d2966 3
a2968 1
nmg_jv(register struct vertex *v1, register struct vertex *v2)
d3019 3
a3021 1
nmg_jfg(struct face *f1, struct face *f2)
d3100 3
a3102 1
nmg_jeg(struct edge_g_lseg *dest_eg, struct edge_g_lseg *src_eg)
@


11.31
log
@CONST to const
@
text
@d54 1
a54 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mk.c,v 11.30 2000/08/22 21:27:08 mike Exp $ (ARL)";
d245 1
a245 1
nmg_mm()
d277 1
a277 1
nmg_mmr()
d316 1
a316 2
nmg_mrsv(m)
struct model *m;
d356 1
a356 2
nmg_msv(r)
struct nmgregion	*r;
d402 1
a402 2
nmg_mf(lu1)
struct loopuse *lu1;
d503 1
a503 4
nmg_mlv(magic, v, orientation)
long		*magic;
struct vertex	*v;
int		orientation;
d616 4
a619 4
nmg_mvu(v, upptr, m)
struct vertex	*v;
long		*upptr;		/* pointer to parent struct */
struct model	*m;
d662 1
a662 3
nmg_mvvu(upptr, m)
long		*upptr;
struct model	*m;
d707 1
a707 3
nmg_me(v1, v2, s)
struct vertex *v1, *v2;
struct shell *s;
d808 1
a808 2
nmg_meonvu(vu)
struct vertexuse *vu;
d936 1
a936 2
nmg_ml(s)
struct shell *s;
d1103 1
a1103 2
nmg_kvu(vu)
register struct vertexuse *vu;
d1160 1
a1160 2
nmg_kfg( magic_p )
long	*magic_p;
d1202 1
a1202 2
nmg_kfu(fu1)
struct faceuse *fu1;
d1266 1
a1266 2
nmg_klu(lu1)
struct loopuse *lu1;
d1350 1
a1350 2
nmg_keg( eu )
struct edgeuse	*eu;
d1395 1
a1395 2
nmg_keu(eu1)
register struct edgeuse *eu1;
d1527 1
a1527 2
nmg_ks(s)
struct shell *s;
d1568 1
a1568 2
nmg_kr(r)
struct nmgregion *r;
d1601 1
a1601 2
nmg_km(m)
struct model *m;
d1625 1
a1625 3
nmg_vertex_gv(v, pt)
struct vertex	*v;
const point_t	pt;
d1657 1
a1657 3
nmg_vertex_g(v, x, y, z)
register struct vertex *v;
fastf_t x, y, z;
d1677 1
a1677 3
nmg_vertexuse_nv( vu , norm )
struct vertexuse *vu;
const vect_t norm;
d1716 1
a1716 3
nmg_vertexuse_a_cnurb( vu, uvw )
struct vertexuse	*vu;
const fastf_t		*uvw;
d1748 1
a1748 2
nmg_edge_g(eu)
struct edgeuse *eu;
d1860 1
a1860 8
nmg_edge_g_cnurb(eu, order, n_knots, kv, n_pts, pt_type, points)
struct edgeuse	*eu;
int		order;
int		n_knots;
fastf_t		*kv;
int		n_pts;
int		pt_type;
fastf_t		*points;
d1983 1
a1983 2
nmg_edge_g_cnurb_plinear(eu)
struct edgeuse	*eu;
d2057 1
a2057 3
nmg_use_edge_g( eu, magic_p )
struct edgeuse	*eu;
long		*magic_p;
d2146 1
a2146 3
nmg_loop_g(l, tol)
struct loop		*l;
const struct bn_tol	*tol;
d2226 1
a2226 3
nmg_face_g(fu, p)
struct faceuse *fu;
const plane_t p;
d2273 1
a2273 3
nmg_face_new_g( fu, pl )
struct faceuse *fu;
const plane_t pl;
d2341 1
a2341 12
nmg_face_g_snurb(fu, u_order, v_order, n_u_knots, n_v_knots, ukv, vkv, n_rows, n_cols, pt_type, mesh)
struct faceuse	*fu;
int		u_order;
int		v_order;
int		n_u_knots;
int		n_v_knots;
fastf_t		*ukv;
fastf_t		*vkv;
int		n_rows;
int		n_cols;
int		pt_type;
fastf_t		*mesh;
d2416 1
a2416 3
nmg_face_bb(f, tol)
struct face		*f;
const struct bn_tol	*tol;
d2469 1
a2469 3
nmg_shell_a(s, tol)
struct shell		*s;
const struct bn_tol	*tol;
d2553 1
a2553 3
nmg_region_a(r, tol)
struct nmgregion	*r;
const struct bn_tol	*tol;
d2607 1
a2607 2
nmg_demote_lu(lu1)
struct loopuse *lu1;
d2671 1
a2671 2
nmg_demote_eu(eu)
struct edgeuse *eu;
d2721 1
a2721 3
nmg_movevu(vu, v)
struct vertexuse *vu;
struct vertex *v;
d2758 1
a2758 2
nmg_je(eudst, eusrc)
struct edgeuse *eudst, *eusrc;
d2845 1
a2845 2
nmg_unglueedge(eu)
struct edgeuse *eu;
d2897 1
a2897 3
nmg_jv(v1, v2)
register struct vertex	*v1;
register struct vertex	*v2;
d2948 1
a2948 3
nmg_jfg( f1, f2 )
struct face	*f1;
struct face	*f2;
d3027 1
a3027 3
nmg_jeg( dest_eg, src_eg )
struct edge_g_lseg	*dest_eg;
struct edge_g_lseg	*src_eg;
@


11.30
log
@
lint
@
text
@d54 1
a54 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mk.c,v 11.29 2000/08/21 02:02:33 butler Exp $ (ARL)";
d1648 1
a1648 1
CONST point_t	pt;
d1704 1
a1704 1
CONST vect_t norm;
d1745 1
a1745 1
CONST fastf_t		*uvw;
d2188 1
a2188 1
CONST struct bn_tol	*tol;
d2270 1
a2270 1
CONST plane_t p;
d2319 1
a2319 1
CONST plane_t pl;
d2475 1
a2475 1
CONST struct bn_tol	*tol;
d2530 1
a2530 1
CONST struct bn_tol	*tol;
d2616 1
a2616 1
CONST struct bn_tol	*tol;
@


11.29
log
@Massive compilation warnings eliminated
@
text
@d54 1
a54 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mk.c,v 11.28 2000/07/10 23:01:44 mike Exp $ (ARL)";
d513 2
a514 1
	struct vertexuse *vu1, *vu2;
@


11.28
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d54 1
a54 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mk.c,v 11.27 1999/12/29 21:15:40 jra Exp $ (ARL)";
d61 1
d561 1
a561 1
		if ( vu1 = s->vu_p ) {
d1654 1
a1654 1
	if (vg = v->vg_p) {
d1801 1
a1801 1
	if (eg_p = eu->g.lseg_p) {
d2202 1
a2202 1
	if (lg = l->lg_p) {
@


11.27
log
@Eliminated some unused variables
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mk.c,v 11.26 1999/12/22 02:24:06 mike Exp $ (ARL)";
@


11.26
log
@
Removed dead vars
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mk.c,v 11.25 1999/12/07 03:32:12 mike Exp $ (ARL)";
a3102 3
	vect_t				dir_src;
	vect_t				dir_dest;
	fastf_t				deg;
@


11.25
log
@
Fixed arg type.
Fixed arg type.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mk.c,v 11.24 1999/07/02 22:19:25 mike Exp $ (ARL)";
d2112 1
a2117 1
#if 0
@


11.24
log
@
Removed dependence on compat4.h
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mk.c,v 11.23 1999/06/03 01:39:14 mike Exp $ (ARL)";
d1743 1
a1743 1
CONST vect_t		uvw;
@


11.23
log
@
sed4
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mk.c,v 11.22 1997/09/18 20:32:45 jra Exp $ (ARL)";
d3137 1
a3137 1
		midway = BU_LIST_FIRST(rt_list, &src_eg->eu_hd2 );
@


11.22
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.21 1997/09/09 13:51:20 jra Exp jra $ (ARL)";
d231 2
a232 2
 *	Use NMG_GETSTRUCT to allocate memory and then set all components.
 *	NMG_GETSTRUCT is used instead of the standard GET_name because
d1190 3
a1192 3
			rt_free( (char *)sp->u.knots, "nmg_kfg snurb u knots[]");
			rt_free( (char *)sp->v.knots, "nmg_kfg snurb v knots[]");
			rt_free( (char *)sp->ctl_points, "nmg_kfg snurb ctl_points[]");
d1388 2
a1389 2
				rt_free( (char *)eg->k.knots, "nmg_keg cnurb knots[]");
				rt_free( (char *)eg->ctl_points, "nmg_keg cnurb ctl_points[]");
d1948 1
a1948 1
		eg->ctl_points = (fastf_t *)rt_calloc(
d2379 1
a2379 1
 *  The caller must have allocated them with rt_malloc() or malloc().
d2429 1
a2429 1
		fg->u.knots = (fastf_t *)rt_calloc(
d2435 1
a2435 1
		fg->v.knots = (fastf_t *)rt_calloc(
d2448 1
a2448 1
		fg->ctl_points = (fastf_t *)rt_calloc(
@


11.21
log
@Fixed a bug in nmg_face_bb() (was incorrectly calculating bounding box for TNURB faces).
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.20 1997/08/15 19:22:43 jra Exp jra $ (ARL)";
d1937 1
a1937 1
		rt_nurb_kvknot( &eg->k, order, 0.0, 1.0, n_knots - (2 * order) );
@


11.20
log
@Ifdef'd out some logging messages from nmg_jeg().
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.19 1997/06/10 12:31:41 jra Exp jra $ (ARL)";
d2512 1
a2512 1
		VMIN(f->max_pt, fu->f_p->g.snurb_p->max_pt );
@


11.19
log
@Added some additional error logging to nmg_je().
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.18 1996/09/27 08:27:30 mike Exp jra $ (ARL)";
a3105 1
	double				cos_ang;
d3114 1
d3130 1
a3130 1

@


11.18
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.17 1996/05/24 15:03:18 stay Exp mike $ (ARL)";
d2857 4
a2860 4
	    	VPRINT("eusrc", eusrc->vu_p->v_p->vg_p->coord);
	    	VPRINT("eusrc_mate", eusrc_mate->vu_p->v_p->vg_p->coord);
	    	VPRINT("eudst", eudst->vu_p->v_p->vg_p->coord);
	    	VPRINT("eudst_mate", eudst_mate->vu_p->v_p->vg_p->coord);
@


11.17
log
@needed a different way to calculate
the bounding box for face_g_snurbs, as the loop bounding box extents
do not give a bounding box for the possible trimmed surface area.
for used the bb for the whole surface
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.16 1996/04/22 12:18:05 jra Exp stay $ (ARL)";
d234 1
a234 1
 *	maxindex from.  So here we use NMG_GETSTRUCT so that we can
d248 1
a248 1
	NMG_GETSTRUCT( m, model );
d250 1
a250 1
	RT_LIST_INIT( &m->r_hd );
d256 1
a256 1
		rt_log("nmg_mm() returns model x%x\n", m );
d273 1
a273 1
 *	The new region is found with RT_LIST_FIRST( nmgregion, &m->r_hd );
d287 1
a287 1
	RT_LIST_INIT( &r->s_hd );
d290 1
a290 1
	RT_LIST_APPEND( &m->r_hd, &r->l );
d293 1
a293 1
		rt_log("nmg_mmr() returns model x%x with region x%x\n", m , r );
d310 2
a311 2
 *	Region is also found with r=RT_LIST_FIRST( nmgregion, &m->r_hd );
 *	The new shell is found with s=RT_LIST_FIRST( shell, &r->s_hd );
d326 1
a326 1
	RT_LIST_INIT( &r->s_hd );
d332 1
a332 1
	RT_LIST_APPEND( &m->r_hd, &r->l );
d335 1
a335 1
		rt_log("nmg_mrsv(m=x%x) returns r=x%x\n" , m , r );
d352 1
a352 1
 *	The new shell is also found with s=RT_LIST_FIRST( shell, &r->s_hd );
d368 1
a368 1
	RT_LIST_APPEND( &r->s_hd, &s->l );
d371 3
a373 3
	RT_LIST_INIT( &s->fu_hd );
	RT_LIST_INIT( &s->lu_hd );
	RT_LIST_INIT( &s->eu_hd );
d381 1
a381 1
		rt_log("nmg_msv(r=x%x) returns s=x%x, vu=x%x\n" , r , s , s->vu_p );
d399 2
a400 2
 *	The first faceuse is fu1=RT_LIST_FIRST( faceuse, &s->fu_hd );
 *	The second faceuse follows:  fu2=RT_LIST_NEXT( faceuse, &fu1->l.magic );
d433 1
a433 1
	RT_LIST_INIT(&f->l);
d436 2
a437 2
	RT_LIST_INIT(&fu1->lu_hd);
	RT_LIST_INIT(&fu2->lu_hd);
d447 4
a450 4
	RT_LIST_DEQUEUE( &lu1->l );
	RT_LIST_DEQUEUE( &lu2->l );
	RT_LIST_APPEND( &fu1->lu_hd, &lu1->l );
	RT_LIST_APPEND( &fu2->lu_hd, &lu2->l );
d458 2
a459 2
	RT_LIST_APPEND( &s->fu_hd, &fu1->l );
	RT_LIST_APPEND( &fu1->l, &fu2->l );
d462 1
a462 1
		rt_log("nmg_mf(lu1=x%x) returns fu=x%x\n" , lu1 , fu1 );
d489 1
a489 1
 *		RT_LIST_FIRST(vertexuse, &lu->down_hd);
d493 1
a493 1
 *		lu = RT_LIST_FIRST(loopuse, &fu->lu_hd);
d495 1
a495 1
 *		lu = RT_LIST_FIRST(loopuse, &s->lu_hd);
d536 2
a537 2
	RT_LIST_INIT( &lu1->down_hd );
	RT_LIST_INIT( &lu2->down_hd );
d555 2
a556 2
		RT_LIST_INSERT( &s->lu_hd, &lu1->l );
		RT_LIST_INSERT( &lu1->l, &lu2->l );
d584 2
a585 2
		RT_LIST_INSERT( &p.fu->fumate_p->lu_hd, &lu2->l );
		RT_LIST_INSERT( &p.fu->lu_hd, &lu1->l );
d601 1
a601 1
		rt_log("nmg_mlv(up=x%x, v=x%x, %s) returns lu=x%x on vu=x%x\n",
d633 1
a633 1
		rt_log("nmg_mvu() in %s at %d magic not shell, loop, or edge.  Was x%x (%s)\n",
d635 1
a635 1
		    *upptr, rt_identify_magic(*upptr) );
d643 1
a643 1
	RT_LIST_APPEND( &v->vu_hd, &vu->l );
d648 1
a648 1
		rt_log("nmg_mvu(v=x%x, up=x%x) returns vu=x%x\n",
d675 1
a675 1
	RT_LIST_INIT( &v->vu_hd );
d681 1
a681 1
		rt_log("nmg_mvvu(upptr=x%x,m=x%x) returns vu=x%x\n" , upptr , m , ret_vu );
d732 2
a733 2
	RT_LIST_INIT( &eu1->l2 );
	RT_LIST_INIT( &eu2->l2 );
d791 2
a792 2
	RT_LIST_APPEND( &s->eu_hd, &eu1->l );
	RT_LIST_APPEND( &eu1->l, &eu2->l );
d795 1
a795 1
		rt_log("nmg_me(v1=x%x, v2=x%x, s=x%x) returns eu=x%x\n" , v1 , v2 , s , eu1 );
d830 2
a831 2
	RT_LIST_INIT( &eu1->l2 );
	RT_LIST_INIT( &eu2->l2 );
d865 2
a866 2
		RT_LIST_APPEND( &s->eu_hd, &eu2->l );
		RT_LIST_APPEND( &s->eu_hd, &eu1->l );
d879 1
a879 1
		if( RT_LIST_FIRST_MAGIC(&lumate->down_hd) != NMG_VERTEXUSE_MAGIC )
d881 1
a881 1
		vumate = RT_LIST_FIRST(vertexuse, &lumate->down_hd);
d905 2
a906 2
		RT_LIST_INIT( &lu->down_hd );
		RT_LIST_INIT( &lumate->down_hd );
d908 2
a909 2
		RT_LIST_APPEND( &lumate->down_hd, &eu2->l );
		RT_LIST_APPEND( &lu->down_hd, &eu1->l );
d919 1
a919 1
		rt_log("nmg_meonvu(vu=x%x) returns eu=x%x\n" , vu , eu1 );
d957 1
a957 1
	if( RT_LIST_IS_EMPTY( &s->eu_hd ) && s->vu_p )  {
d964 1
a964 1
			rt_log("nmg_ml(s=x%x) returns lu of single vertex=x%x\n" , s , lu1 );
d979 2
a980 2
	RT_LIST_INIT( &lu1->down_hd );
	RT_LIST_INIT( &lu2->down_hd );
d990 1
a990 1
	feu = RT_LIST_FIRST( edgeuse, &s->eu_hd );
d999 2
a1000 2
	while( RT_LIST_NON_EMPTY( &s->eu_hd ) )  {
		p1 = RT_LIST_FIRST( edgeuse, &s->eu_hd );
d1010 3
a1012 3
		RT_LIST_DEQUEUE( &p1->l );
		if( RT_LIST_IS_EMPTY( &s->eu_hd ) )  {
			rt_log("nmg_ml() in %s at %d edgeuse mate not in this shell\n",
d1018 1
a1018 1
		RT_LIST_DEQUEUE( &p2->l );
d1024 2
a1025 2
		RT_LIST_INSERT( &lu1->down_hd, &p1->l );
		RT_LIST_INSERT( &lu2->down_hd, &p2->l );
d1031 2
a1032 2
		if( RT_LIST_IS_EMPTY( &s->eu_hd ) )  break;
		p1 = RT_LIST_FIRST( edgeuse, &s->eu_hd );
d1049 1
a1049 1
		rt_log("nmg_ml() Edge(use)s do not form proper loop!\n");
d1051 1
a1051 1
		rt_log("nmg_ml() Edge(use)s do not form proper loop!\n");
d1056 2
a1057 2
	RT_LIST_APPEND( &s->lu_hd, &lu2->l );
	RT_LIST_APPEND( &s->lu_hd, &lu1->l );
d1060 1
a1060 1
		rt_log("nmg_ml(s=x%x) returns lu=x%x\n" , s , lu1 );
d1136 2
a1137 2
	RT_LIST_DEQUEUE( &vu->l );
	if( RT_LIST_IS_EMPTY( &v->vu_hd ) )  {
d1149 1
a1149 1
		RT_LIST_INIT( &vu->up.lu_p->down_hd );
d1159 1
a1159 1
		rt_log("nmg_kvu(vu=x%x) ret=%d\n", vu, ret);
d1180 1
a1180 1
			if( RT_LIST_NON_EMPTY( &(pp->f_hd) ) )  return;
d1189 1
a1189 1
			if( RT_LIST_NON_EMPTY( &(sp->f_hd) ) )  return;
d1236 2
a1237 2
	while( RT_LIST_NON_EMPTY( &fu1->lu_hd ) )  {
		(void)nmg_klu( RT_LIST_FIRST( loopuse, &fu1->lu_hd ) );
d1243 1
a1243 1
		RT_LIST_DEQUEUE( &f1->l );
d1250 2
a1251 2
	RT_LIST_DEQUEUE( &fu1->l );
	if( RT_LIST_IS_EMPTY( &s->fu_hd ) )
d1253 1
a1253 1
	RT_LIST_DEQUEUE( &fu2->l );
d1259 1
a1259 1
		rt_log("nmg_kfu(fu1=x%x) fu2=x%x ret=%d\n", fu1, fu2, ret);
d1297 2
a1298 2
	magic1 = RT_LIST_FIRST_MAGIC( &lu1->down_hd );
	if( magic1 != RT_LIST_FIRST_MAGIC( &lu2->down_hd ) )
d1304 2
a1305 2
		(void)nmg_kvu( RT_LIST_FIRST(vertexuse, &lu1->down_hd) );
		(void)nmg_kvu( RT_LIST_FIRST(vertexuse, &lu2->down_hd) );
d1308 2
a1309 2
		while( RT_LIST_NON_EMPTY( &lu1->down_hd ) )  {
			(void)nmg_keu(RT_LIST_FIRST(edgeuse, &lu1->down_hd) );
d1311 1
a1311 1
	} else if ( magic1 == RT_LIST_HEAD_MAGIC )  {
d1314 1
a1314 1
		rt_log("nmg_klu(x%x) magic=%s\n", lu1, rt_identify_magic(magic1) );
d1320 2
a1321 2
		RT_LIST_DEQUEUE( &lu1->l );
		RT_LIST_DEQUEUE( &lu2->l );
d1324 3
a1326 3
		RT_LIST_DEQUEUE( &lu1->l );
		RT_LIST_DEQUEUE( &lu2->l );
		ret = RT_LIST_IS_EMPTY( &lu1->up.fu_p->lu_hd );
d1340 1
a1340 1
		rt_log("nmg_klu(lu1=x%x) lu2=x%x ret=%d\n", lu1, lu2, ret);
d1377 1
a1377 1
			if( RT_LIST_NON_EMPTY( &lp->eu_hd2 ) )  return 0;
d1386 1
a1386 1
			if( RT_LIST_NON_EMPTY( &eg->eu_hd2 ) )  return 0;
d1461 1
a1461 1
		RT_LIST_DEQUEUE( &eu1->l2 );
d1470 1
a1470 1
		RT_LIST_DEQUEUE( &eu2->l2 );
d1486 2
a1487 2
			rt_log("nmg_keu() lu1=x%x, mate=x%x\n", lu1, lu1->lumate_p);
			rt_log("nmg_keu() lu2=x%x, mate=x%x\n", lu2, lu2->lumate_p);
d1492 2
a1493 2
		RT_LIST_DEQUEUE( &eu1->l );
		RT_LIST_DEQUEUE( &eu2->l );
d1496 1
a1496 1
		if( RT_LIST_IS_EMPTY( &lu1->down_hd ) )  ret = 1;
d1503 2
a1504 2
		RT_LIST_DEQUEUE( &eu1->l );
		RT_LIST_DEQUEUE( &eu2->l );
d1528 1
a1528 1
		rt_log("nmg_keu(eu1=x%x) eu2=x%x ret=%d\n", eu1, eu2, ret);
d1552 6
a1557 6
	while( RT_LIST_NON_EMPTY( &s->fu_hd ) )
		(void)nmg_kfu( RT_LIST_FIRST(faceuse, &s->fu_hd) );
	while( RT_LIST_NON_EMPTY( &s->lu_hd ) )
		(void)nmg_klu( RT_LIST_FIRST(loopuse, &s->lu_hd) );
	while( RT_LIST_NON_EMPTY( &s->eu_hd ) )
		(void)nmg_keu( RT_LIST_FIRST(edgeuse, &s->eu_hd) );
d1561 1
a1561 1
	RT_LIST_DEQUEUE( &s->l );
d1569 1
a1569 1
		rt_log("nmg_ks(s=x%x)\n", s);
d1571 1
a1571 1
	if( RT_LIST_IS_EMPTY( &r->s_hd ) )  return 1;
d1594 2
a1595 2
	while( RT_LIST_NON_EMPTY( &r->s_hd ) )
		(void)nmg_ks( RT_LIST_FIRST( shell, &r->s_hd ) );
d1597 1
a1597 1
	RT_LIST_DEQUEUE( &r->l );
d1604 1
a1604 1
		rt_log("nmg_kr(r=x%x)\n", r);
d1607 1
a1607 1
	if( RT_LIST_IS_EMPTY( &m->r_hd ) ) {
d1624 2
a1625 2
	while( RT_LIST_NON_EMPTY( &m->r_hd ) )
		(void)nmg_kr( RT_LIST_FIRST( nmgregion, &m->r_hd ) );
d1629 1
a1629 1
		rt_log("nmg_km(m=x%x)\n", m);
d1658 1
a1658 1
			&RT_LIST_NEXT(vertexuse, &v->vu_hd)->l.magic );
d1667 1
a1667 1
		rt_log("nmg_vertex_gv(v=x%x, pt=(%g %g %g))\n", v , V3ARGS( pt ));
d1689 1
a1689 1
		rt_log("nmg_vertex_g(v=x%x, pt=(%g %g %g))\n", v , x , y , z );
d1724 1
a1724 1
		rt_log("nmg_vertexuse_nv(vu=x%x, norm=(%g %g %g))\n", vu , V3ARGS( norm ));
d1762 1
a1762 1
		rt_log("nmg_vertexuse_a_cnurb(vu=x%x, param=(%g %g %g)) vua=x%x\n",
d1820 1
a1820 1
		RT_LIST_INIT( &eg_p->eu_hd2 );
d1837 1
a1837 1
			rt_log("nmg_edge_g(): (%g %g %g) -> (%g %g %g)",
d1848 2
a1849 2
	RT_LIST_DEQUEUE( &eu->l2 );
	RT_LIST_DEQUEUE( &eu->eumate_p->l2 );
d1852 2
a1853 2
	RT_LIST_INSERT( &eg_p->eu_hd2, &eu->l2 );
	RT_LIST_INSERT( &eg_p->eu_hd2, &eu->eumate_p->l2 );
d1864 1
a1864 1
			RT_LIST_INSERT( &eg_p->eu_hd2, &eu2->l2 );
d1866 1
a1866 1
			RT_LIST_INSERT( &eg_p->eu_hd2, &eu2->eumate_p->l2 );
d1873 1
a1873 1
		rt_log("nmg_edge_g(eu=x%x) eg=x%x\n", eu, eg_p );
d1929 1
a1929 1
	RT_LIST_INIT( &eg->eu_hd2 );
d1980 2
a1981 2
	RT_LIST_DEQUEUE( &eu->l2 );
	RT_LIST_DEQUEUE( &eu->eumate_p->l2 );
d1984 2
a1985 2
	RT_LIST_INSERT( &eg->eu_hd2, &eu->l2 );
	RT_LIST_INSERT( &eg->eu_hd2, &eu->eumate_p->l2 );
d1992 1
a1992 1
		rt_log("nmg_edge_g_cnurb(eu=x%x, order=%d, n_knots=%d, kv=x%x, n_pts=%d, pt_type=x%x, points=x%x) eg=x%x\n",
d2056 1
a2056 1
	RT_LIST_INIT( &eg->eu_hd2 );
d2061 2
a2062 2
	RT_LIST_DEQUEUE( &eu->l2 );
	RT_LIST_DEQUEUE( &eu->eumate_p->l2 );
d2065 2
a2066 2
	RT_LIST_INSERT( &eg->eu_hd2, &eu->l2 );
	RT_LIST_INSERT( &eg->eu_hd2, &eu->eumate_p->l2 );
d2073 1
a2073 1
		rt_log("nmg_edge_g_cnurb_plinear(eu=x%x) order=0, eg=x%x\n",
d2125 1
a2125 1
		deg = acos( cos_ang ) * rt_radtodeg;
d2129 1
a2129 1
			rt_log("nmg_use_edge_g() NOTICE Angle between old=x%x & new=x%x lines was %g deg.\n",
d2141 1
a2141 1
		RT_LIST_DEQUEUE( &eu->l2 );
d2146 1
a2146 1
		RT_LIST_INSERT( &eg->eu_hd2, &(eu->l2) );
d2157 1
a2157 1
		RT_LIST_DEQUEUE( &mate->l2 );
d2163 1
a2163 1
		RT_LIST_INSERT( &eg->eu_hd2, &(eu->eumate_p->l2) );
d2169 1
a2169 1
		rt_log("nmg_use_edge_g(eu=x%x, magic_p=x%x) old_eg=x%x, ret=%d\n",
d2186 1
a2186 1
CONST struct rt_tol	*tol;
d2197 1
a2197 1
	RT_CK_TOL(tol);
d2212 1
a2212 1
	magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
d2214 1
a2214 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d2223 1
a2223 1
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d2231 2
a2232 2
		rt_log("nmg_loop_g() loopuse down is %s (x%x)\n",
			rt_identify_magic(magic1), magic1 );
d2253 1
a2253 1
		rt_log("nmg_loop_g(l=x%x, tol=x%x)\n", l , tol);
d2292 2
a2293 2
		RT_LIST_INIT(&fg->f_hd);
		RT_LIST_APPEND( &fg->f_hd, &f->l );
d2304 1
a2304 1
		rt_log("nmg_face_g(fu=x%x, p=(%g %g %g %g))\n", fu , V4ARGS( p ));
d2338 1
a2338 1
	for( RT_LIST_FOR( f_tmp, face, &fg->f_hd ) )
d2354 1
a2354 1
	RT_LIST_DEQUEUE( &f->l );
d2362 2
a2363 2
	RT_LIST_INIT(&fg->f_hd);
	RT_LIST_APPEND( &fg->f_hd, &f->l );
d2368 1
a2368 1
		rt_log("nmg_face_new_g(fu=x%x, pl=(%g %g %g %g))\n", fu , V4ARGS( pl ));
d2453 2
a2454 2
	RT_LIST_INIT(&fg->f_hd);
	RT_LIST_APPEND( &fg->f_hd, &f->l );
d2458 1
a2458 1
		rt_log("nmg_face_g_snurb(fu=x%x, u_order=%d, v_order=%d, n_u_knots=%d, n_v_knots=%d, ukv=x%x, vkv=x%x, n_rows=%d, n_cols=%d, pt_type=x%x, mesh=x%x) fg=x%x\n",
d2473 1
a2473 1
CONST struct rt_tol	*tol;
d2478 1
a2478 1
	RT_CK_TOL(tol);
d2489 1
a2489 1
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d2516 1
a2516 1
		rt_log("nmg_face_bb(f=x%x, tol=x%x)\n", f , tol);
d2528 1
a2528 1
CONST struct rt_tol	*tol;
d2538 1
a2538 1
	RT_CK_TOL(tol);
d2552 1
a2552 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
d2563 3
a2565 3
		if( RT_LIST_NOT_HEAD(fu, &fu->l) &&
		    ( RT_LIST_NEXT(faceuse, &fu->l)->f_p == f ) )  {
			fu = RT_LIST_PNEXT(faceuse,fu);
d2568 1
a2568 1
	for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
d2574 1
a2574 1
	for( RT_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
d2593 4
a2596 4
	if( RT_LIST_IS_EMPTY( &s->fu_hd ) &&
	    RT_LIST_IS_EMPTY( &s->lu_hd ) &&
	    RT_LIST_IS_EMPTY( &s->eu_hd ) && !s->vu_p )  {
		rt_log("nmg_shell_a() at %d in %s. Shell has no children\n",
d2602 1
a2602 1
		rt_log("nmg_shell_a(s=x%x, tol=x%x)\n", s , tol);
d2614 1
a2614 1
CONST struct rt_tol	*tol;
d2620 1
a2620 1
	RT_CK_TOL(tol);
d2634 1
a2634 1
	for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
d2642 1
a2642 1
		rt_log("nmg_region_a(r=x%x, tol=x%x)\n", r , tol);
d2678 1
a2678 1
		rt_log("nmg_demote_lu(x%x)\n", lu1);
d2680 1
a2680 1
	if (RT_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_VERTEXUSE_MAGIC) {
d2684 1
a2684 1
	if (RT_LIST_FIRST_MAGIC(&lu1->down_hd) != NMG_EDGEUSE_MAGIC)
d2693 1
a2693 1
	while ( RT_LIST_NON_EMPTY(&lu1->down_hd) ) {
d2695 1
a2695 1
		eu1 = RT_LIST_FIRST(edgeuse, &lu1->down_hd);
d2701 2
a2702 2
		RT_LIST_DEQUEUE(&eu1->eumate_p->l);
		RT_LIST_APPEND(&s->eu_hd, &eu1->eumate_p->l);
d2704 2
a2705 2
		RT_LIST_DEQUEUE(&eu1->l);
		RT_LIST_APPEND(&s->eu_hd, &eu1->l);
d2711 1
a2711 1
	if (RT_LIST_NON_EMPTY(&lu1->lumate_p->down_hd))
d2717 1
a2717 1
		rt_log("nmg_demote_lu(lu=x%x) returns %d\n", lu1 , ret_val);
d2760 1
a2760 1
		rt_log("nmg_demote_eu(eu=x%x) returns %d\n", eu , ret_val);
d2796 2
a2797 2
	RT_LIST_DEQUEUE( &vu->l );
	if( RT_LIST_IS_EMPTY( &oldv->vu_hd ) )  {
d2802 1
a2802 1
	RT_LIST_APPEND( &v->vu_hd, &vu->l );
d2806 1
a2806 1
		rt_log("nmg_movevu(vu=x%x, v=x%x)\n", vu , v);
d2841 1
a2841 1
		rt_log("nmg_je() moving edgeuse to itself\n");
d2847 1
a2847 1
	    	rt_log("nmg_je() edgeuses already share edge\n");
d2891 1
a2891 1
		rt_log("nmg_je(eudst=x%x, eusrc=x%x)\n", eudst , eusrc);
d2926 1
a2926 1
			rt_log("nmg_unglueedge(eu=x%x) (nothing unglued)\n", eu);
d2952 1
a2952 1
		rt_log("nmg_unglueedge(eu=x%x)\n", eu);
d2980 2
a2981 2
	vu = RT_LIST_FIRST(vertexuse, &v2->vu_hd );
	while( RT_LIST_NOT_HEAD( vu, &v2->vu_hd ) )  {
d2985 3
a2987 3
		vunext = RT_LIST_PNEXT(vertexuse, vu);
		RT_LIST_DEQUEUE( &vu->l );
		RT_LIST_INSERT( &v1->vu_hd, &vu->l );
d3003 1
a3003 1
		rt_log("nmg_jv(v1=x%x, v2=x%x)\n", v1 , v2);
d3034 1
a3034 1
		RT_LIST_INSERT( &fg2->f_hd, &f1->l );
d3037 1
a3037 1
			rt_log("nmg_jfg(f1=x%x, f2=x%x)\n", f1 , f2);
d3046 1
a3046 1
		RT_LIST_INSERT( &fg1->f_hd, &f2->l );
d3049 1
a3049 1
			rt_log("nmg_jfg(f1=x%x, f2=x%x)\n", f1 , f2);
d3060 1
a3060 1
			rt_log("nmg_jfg(f1=x%x, f2=x%x)\n", f1 , f2);
d3066 3
a3068 3
	while( RT_LIST_NON_EMPTY( &fg2->f_hd ) )  {
		f = RT_LIST_FIRST( face, &fg2->f_hd );
		RT_LIST_DEQUEUE( &f->l );
d3072 1
a3072 1
		RT_LIST_INSERT( &fg1->f_hd, &f->l );
d3079 1
a3079 1
		rt_log("nmg_jfg(f1=x%x, f2=x%x)\n", f1 , f2);
d3111 1
a3111 1
		rt_log("nmg_jeg( src_eg=x%x, dest_eg=x%x )\n",
d3123 1
a3123 1
	deg = acos( cos_ang ) * rt_radtodeg;
d3127 1
a3127 1
		rt_log("Angle between lines is %g degrees\n", deg );
d3131 2
a3132 2
	while( RT_LIST_NON_EMPTY( &src_eg->eu_hd2 ) )  {
		struct rt_list	*midway;	/* &eu->l2, midway into edgeuse */
d3137 1
a3137 1
		midway = RT_LIST_FIRST(rt_list, &src_eg->eu_hd2 );
d3139 1
a3139 1
		eu = RT_LIST_MAIN_PTR( edgeuse, midway, l2 );
d3143 1
a3143 1
			rt_log("nmg_jeg() eu=x%x, eu->g=x%x != src_eg=x%x??  dest_eg=x%x\n",
@


11.16
log
@Added nmg_face_new_g().
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.15 1996/03/25 20:51:36 jra Exp jra $ (ARL)";
d2496 17
@


11.15
log
@ifdef'd out angle check in nmg_use_edge_g().
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.14 1996/03/05 21:33:17 jra Exp jra $ (ARL)";
d2305 64
@


11.14
log
@Mods to nmg_use_edge_g() to ensure arg to acos() is within domain.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.13 1995/12/02 03:09:46 mike Exp $ (ARL)";
d2117 1
a2130 1
#if 0
d2132 1
a2133 1
		}
@


11.13
log
@edge_g_lseg got an rt_list structure, for symmetry with edge_g_cnurb.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.8 1995/09/06 14:57:45 jra Exp $ (ARL)";
d2115 1
d2121 4
a2124 1
		deg = acos(fabs(VDOT( dir_src, dir_dest ))) * rt_radtodeg;
d3025 1
d3039 4
a3042 1
	deg = acos(fabs(VDOT( dir_src, dir_dest ))) * rt_radtodeg;
@


11.12
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d1821 1
a1821 1
		eg_p->magic = NMG_EDGE_G_LSEG_MAGIC;
d3060 1
a3060 1
		if( nmg_use_edge_g( eu, &dest_eg->magic ) )
@


11.11
log
@Knot vector wasn't big enough
@
text
@d1989 1
a1989 1
	eg->magic = NMG_EDGE_G_CNURB_MAGIC;
d2070 1
a2070 1
	eg->magic = NMG_EDGE_G_CNURB_MAGIC;
d2387 1
a2387 1
	fg->magic = NMG_FACE_G_SNURB_MAGIC;
@


11.10
log
@#ifdef'ed out unnecessary check.
@
text
@d1937 1
a1937 1
		rt_nurb_kvknot( &eg->k, order, 0.0, 1.0, 0 );
@


11.9
log
@Allow curves to start and end at the same point, at least for now.
@
text
@d1914 1
d1917 1
@


11.8
log
@Aded a newline to an rt_log message in nmg_use_edge_g().
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.7 1995/04/03 19:56:28 jra Exp jra $ (ARL)";
d2039 1
d2042 1
@


11.7
log
@Mod to nmg_shell_a to not bomb when shell's vu has no geometry.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.6 1995/03/05 17:29:10 mike Exp jra $ (ARL)";
d2120 1
a2120 1
			rt_log("nmg_use_edge_g() NOTICE Angle between old=x%x & new=x%x lines was %g deg.",
@


11.6
log
@removed irritating rt_bomb.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.5 95/02/21 02:45:22 mike Exp Locker: mike $ (ARL)";
d2495 6
a2500 3
		NMG_CK_VERTEX_G(s->vu_p->v_p->vg_p);
		vg = s->vu_p->v_p->vg_p;
		VMINMAX(sa->min_pt, sa->max_pt, vg->coord);
@


11.5
log
@Clarified scary-looking message.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.4 95/02/07 03:51:25 mike Exp Locker: mike $ (ARL)";
d3032 1
a3032 1
		rt_bomb("nmg_jeg() angle between lines is excessive\n");
@


11.4
log
@nmg_je() no longer meddles with the edge geometry.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.3 95/02/06 23:10:42 mike Exp Locker: mike $ (ARL)";
d2120 2
a2121 1
			rt_log("WARNING Angle between old & new lines is %g degrees\n", deg );
@


11.3
log
@Added sanity checking code to nmg_use_edge_g() and nmg_jeg(),
to ensure that the angle between lines being joined isn't excessive.
If it is, that signals a bad problem.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.2 95/01/18 13:32:16 jra Exp Locker: mike $ (ARL)";
d2120 4
a2123 2
			rt_log("Angle between lines is %g degrees\n", deg );
			rt_bomb("nmg_use_edge_g() angle between 2 existing lines is excessive\n");
a2725 1
 *	(For compat, if both are linear, geometries are fused here)
a2796 8
	/* If linear, make eusrc use geometry of eudst */
	if( eusrc->g.magic_p != eudst->g.magic_p &&
	    eudst->g.magic_p && *eudst->g.magic_p == NMG_EDGE_G_LSEG_MAGIC &&
	    eusrc->g.magic_p && *eusrc->g.magic_p == NMG_EDGE_G_LSEG_MAGIC
	)  {
		nmg_use_edge_g( eusrc, eudst->g.magic_p );
	}

d2996 4
@


11.2
log
@nmg_shell_a wasn't initializing min and max points.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 11.1 95/01/04 09:58:02 mike Rel4_4 Locker: jra $ (ARL)";
d58 1
d60 1
d2106 19
d3013 3
d3022 13
@


11.1
log
@Release_4.4
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.60 94/11/28 16:08:13 jra Exp $ (ARL)";
d2435 3
@


10.60
log
@Fixed typo in nmg_keu that caused it to DEQUEUE an edgeuse from the
l2 list, but not DEQUEUE its mate.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.59 94/11/18 16:21:54 jra Exp Locker: jra $ (ARL)";
@


10.59
log
@Modified nmg_loop_g to not call nmg_edge_g for edgeuses to/from same vertex.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.58 94/11/17 17:00:26 jra Exp Locker: jra $ (ARL)";
d1465 1
a1465 1
	if( eu1->g.magic_p )
@


10.58
log
@Fixed nmg_edge_g to ignore edges from+to same vertex.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.57 94/11/16 17:02:37 jra Exp Locker: jra $ (ARL)";
d1796 1
a1796 4
	{
		rt_log("nmg_edge_g(): Warning - edge runs from+to same vertex, 0 len!\n");
		return;
	}
d2186 2
a2187 1
			if( !eu->g.magic_p )  nmg_edge_g(eu);
@


10.57
log
@Modified nmg_keu to allw killing eu's without geometry.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.56 94/11/10 15:36:09 jra Exp Locker: jra $ (ARL)";
d1796 4
a1799 1
		rt_bomb("nmg_edge_g(): edge runs from+to same vertex, 0 len!\n");
@


10.56
log
@Fixed nmg_edge_g to assign new edge_g to all uses of an edge if a new eg_p is created.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_mk.c,v 10.55 1994/11/04 06:10:02 mike Exp $ (ARL)";
d1455 5
a1459 3
	/* Dequeue edgeuse from geometry's list of users */
	RT_LIST_DEQUEUE( &eu1->l2 );
	RT_LIST_DEQUEUE( &eu2->l2 );
d1461 12
a1472 3
	/* Release the edgeuse's geometry pointer */
	nmg_keg( eu1 );
	nmg_keg( eu2 );
@


10.55
log
@Irix 6
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d1770 1
d1797 1
d1843 15
@


10.54
log
@Eliminated model_a structure
@
text
@d41 2
a42 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d44 5
d50 2
a51 2
 *	This software is Copyright (C) 1989 by the United States Army.
 *	All rights reserved.
d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.53 94/09/21 03:11:59 mike Exp Locker: mike $ (BRL)";
a1217 1
	struct face_g_plane	*fg;
a2272 1
	int i;
a2959 1
	register struct edge		*e;
@


10.53
log
@Changed checking for vertexuse attributes in nmg_kvu() to give better
error messages on bad magic numbers.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.52 94/09/16 21:58:51 mike Exp Locker: mike $ (BRL)";
a103 1
 *	model_a		(not used)
a105 3
 *	faceuse_a	(not used)
 *	loopuse_a	(not used)
 *	edgeuse_a	(not used)
a243 1
	m->ma_p = (struct model_a *)NULL;
a1610 3
	if (m->ma_p) {
		FREE_MODEL_A(m->ma_p);
	}
@


10.52
log
@Added cnurb order==0 handling to nmg_keg().
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.51 94/09/16 21:39:30 mike Exp Locker: mike $ (BRL)";
d1120 10
a1129 9
	if (vu->a.magic_p) switch(*vu->a.magic_p)  {
	case NMG_VERTEXUSE_A_PLANE_MAGIC:
		FREE_VERTEXUSE_A_PLANE(vu->a.plane_p);
		break;
	case NMG_VERTEXUSE_A_CNURB_MAGIC:
		FREE_VERTEXUSE_A_CNURB(vu->a.cnurb_p);
		break;
	default:
		rt_bomb("nmg_kvu() illegal vua\n");
@


10.51
log
@Added nmg_edge_g_cnurb_plinear()
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.50 94/09/16 20:45:57 mike Exp Locker: mike $ (BRL)";
d1382 2
a1383 2
			struct edge_g_cnurb	*cp;
			cp = eu->g.cnurb_p;
d1385 6
a1390 4
			if( RT_LIST_NON_EMPTY( &cp->eu_hd2 ) )  return 0;
			rt_free( (char *)cp->k.knots, "nmg_keg cnurb knots[]");
			rt_free( (char *)cp->ctl_points, "nmg_keg cnurb ctl_points[]");
			FREE_EDGE_G_CNURB(cp);
@


10.50
log
@nmg_move_eg() became nmg_jeg().
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.49 94/09/16 04:05:21 mike Exp Locker: mike $ (BRL)";
d1856 2
a1857 3
 *  The vertexuses at each end of the curve are given vertexuse attributes
 *  with parameter values of 0.0 and 1.0 automaticly.
 *  If this is not correct, it can be altered with nmg_xxxx()
d1901 1
d1906 2
a1907 2
		/* Give a default curve of order 4, no interior knots */
		rt_nurb_kvknot( &eg->k, 4, 0.0, 1.0, 0 );
d1965 78
@


10.49
log
@Filled in missing parts of nmg_keg() and nmg_kfg().
@
text
@a0 4
/* XXX move to vmath.h */
#define V2MOVE(a,b)	{ \
			(a)[X] = (b)[X];\
			(a)[Y] = (b)[Y]; }
d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.48 94/09/15 23:47:08 mike Exp Locker: mike $ (BRL)";
d1359 2
a1360 1
 *  NOT INTENDED FOR GENERAL USE!  However, nmg_mod.c needs it.  (Drat!)
d2557 2
d2866 48
@


10.48
log
@nmg_edge_g_cnurb() was setting the wrong magic number.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.47 94/09/15 13:42:43 mike Exp Locker: mike $ (BRL)";
d1192 3
a1194 1
			/* XXX */ rt_bomb("nmg_kfg() free snurb insides??\n");
d1198 2
d1389 2
a1390 1
			/* XXX */ rt_bomb("nmg_keg() cnurb internals?\n");
@


10.47
log
@Fixed 2d move
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.46 94/09/14 16:57:11 jra Exp Locker: mike $ (BRL)";
d1957 1
a1957 1
	eg->magic = NMG_EDGE_G_LSEG_MAGIC;
@


10.46
log
@Fixed a couple minor bugs in nmg_edge_g_cnurb.
@
text
@d1 4
d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_mk.c,v 10.45 94/09/14 15:59:03 mike Exp Locker: jra $ (BRL)";
d1938 2
a1939 2
			VMOVE( eg->ctl_points, eu->vu_p->a.cnurb_p->param );
			VMOVE( &eg->ctl_points[ (n_pts-1)*ncoord ],
@


10.45
log
@Added 3 t-NURB NMG support routines,
nmg_vertexuse_a_cnurb(), nmg_edge_g_cnurb(), and nmg_face_g_snurb().
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.44 94/09/13 21:02:03 mike Exp Locker: mike $ (BRL)";
d59 1
d1901 1
a1901 1
		rt_nurb_kvknot( &eg->k.knots, 4, 0.0, 1.0, 0 );
d1913 1
a1914 1
			ncoord * n_pts,
@


10.44
log
@Removed all the debugging stuff for nmg_use_edge_g().
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.43 94/09/13 20:57:16 mike Exp Locker: mike $ (BRL)";
d1711 39
d1843 119
d1985 1
a1985 1
	if( !magic_p )  return;	/* Don't use a null new geom */
d2117 1
d2161 94
@


10.43
log
@Improved version of nmg_use_edge_g() which actually works properly.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.42 94/09/10 05:13:40 mike Exp Locker: mike $ (BRL)";
a1832 2
	nmg_ck_list( &eg->eu_hd2, "nmg_use_edge_g() eg->eu_hd2 A" );

d1835 1
d1837 1
a1838 1
nmg_ck_list( &eu->g.lseg_p->eu_hd2, "nmg_use_edge_g() old->eu_hd2 A" );
a1840 2
nmg_ck_list( &eg->eu_hd2, "nmg_use_edge_g() eg->eu_hd2 B" );
nmg_ck_list( &eu->g.lseg_p->eu_hd2, "nmg_use_edge_g() old->eu_hd2 C" );
a1842 1
nmg_ck_list( &eg->eu_hd2, "nmg_use_edge_g() eg->eu_hd2 D" );
a1844 1
nmg_ck_list( &eg->eu_hd2, "nmg_use_edge_g() eg->eu_hd2 E" );
a1845 1
nmg_ck_list( &eg->eu_hd2, "nmg_use_edge_g() eg->eu_hd2 F" );
d1849 1
d1852 1
a1853 1

a1854 1
nmg_ck_list( &mate->g.lseg_p->eu_hd2, "nmg_use_edge_g() old->eu_hd2 P" );
a1856 2
nmg_ck_list( &eg->eu_hd2, "nmg_use_edge_g() eg->eu_hd2 Q" );
nmg_ck_list( &mate->g.lseg_p->eu_hd2, "nmg_use_edge_g() old->eu_hd2 R" );
a1858 1
nmg_ck_list( &eg->eu_hd2, "nmg_use_edge_g() eg->eu_hd2 S" );
a1861 1
nmg_ck_list( &eg->eu_hd2, "nmg_use_edge_g() eg->eu_hd2 T" );
a1862 1
nmg_ck_list( &eg->eu_hd2, "nmg_use_edge_g() eg->eu_hd2 U" );
@


10.42
log
@nmg_edge_g() forgot to set edgeuse geometry pointer!  Oops.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.41 94/09/10 04:37:08 mike Exp Locker: mike $ (BRL)";
d1350 4
d1356 1
a1356 1
/**static**/ void
d1362 1
a1362 1
	if( !eu->g.magic_p )  return;
d1370 1
a1370 1
			if( RT_LIST_NON_EMPTY( &lp->eu_hd2 ) )  return;
d1379 1
a1379 1
			if( RT_LIST_NON_EMPTY( &cp->eu_hd2 ) )  return;
d1385 1
d1808 3
a1810 1
 *  that first.
d1812 4
d1817 1
a1817 1
void
d1822 1
a1822 1
	long	*old;
d1825 1
d1831 1
d1833 1
a1833 1
	old = eu->g.magic_p;
d1835 1
a1835 4
	RT_LIST_DEQUEUE( &eu->l2 );
	RT_LIST_DEQUEUE( &eu->eumate_p->l2 );
	nmg_keg( eu );
	nmg_keg( eu->eumate_p );
d1837 3
a1839 2
	eu->g.magic_p = magic_p;
	eu->eumate_p->g.magic_p = magic_p;
d1841 13
a1853 2
	RT_LIST_INSERT( &eg->eu_hd2, &(eu->l2) );
	RT_LIST_INSERT( &eg->eu_hd2, &(eu->eumate_p->l2) );
d1855 23
d1879 2
a1880 2
		rt_log("nmg_use_egde_g(eu=x%x, magic_p=x%x) old_eg=x%x\n",
			eu, magic_p, old);
d1882 1
@


10.41
log
@Converted NMG data structures to have edge_g pointer in edgeuse, not edge.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.40 94/09/03 03:00:37 mike Exp Locker: mike $ (BRL)";
d1786 2
d1790 2
d1794 1
a1794 1
		rt_log("nmg_edge_g(e=x%x) eg=x%x\n", e, eg_p );
@


10.40
log
@Snapshot of non-working intermediate stage in edge_g evolution.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.39 94/09/02 19:07:49 mike Exp Locker: mike $ (BRL)";
d732 1
a733 1
	e->eg_p = (struct edge_g *)NULL;
d830 1
a831 1
	e->eg_p = (struct edge_g *)NULL;
d833 1
a833 1
	/* e->is_real = XXX; */
d1124 1
a1124 1
		FREE_VERTEXUSE_A_CNURN(vu->a.cnurb_p);
d1344 1
d1346 4
d1353 2
a1354 2
nmg_keg( magic_p )
long	*magic_p;
d1356 5
a1360 1
	switch( *magic_p )  {
d1364 2
a1365 1
			lp = (struct edge_g_lseg *)magic_p;
d1373 2
a1374 1
			cp = (struct edge_g_cnurb *)magic_p;
a1435 8
	/* XXX temp */
	/* Dequeue edgeuse from geometry's list of users */
	RT_LIST_DEQUEUE( &eu1->l2 );
	RT_LIST_DEQUEUE( &eu2->l2 );
	RT_LIST_INIT( &eu1->l2 );
	RT_LIST_INIT( &eu2->l2 );
	if (e->eg_p) nmg_keg( &e->eg_p->magic );

a1441 1
#if 0
d1446 3
a1448 4
	/* Release the edgeuse's geometry, if all uses are finished. */
	if( eu1->g.magic_p )  nmg_keg( eu1->g.magic_p );
	if( eu2->g.magic_p )  nmg_keg( eu2->g.magic_p );
#endif
d1709 2
a1711 1
/* XXX Need to change this to take an edgeuse! */
d1713 2
a1714 2
nmg_edge_g(e)
struct edge *e;
d1718 2
a1719 1
	struct edgeuse	*eu;
d1722 2
a1724 2
	NMG_CK_EDGEUSE(e->eu_p);
	eu = e->eu_p;
d1737 1
a1737 2
	/* make sure we've got a valid edge_g structure */
	if (eg_p = e->eg_p) {
d1739 15
a1753 1
	} else {
d1759 3
a1761 7
		e->eg_p = eg_p;
		/* Dequeue edgeuses from current list, add to our list */
		RT_LIST_DEQUEUE( &eu->l2 );
		RT_LIST_DEQUEUE( &eu->eumate_p->l2 );
		RT_LIST_INSERT( &eg_p->eu_hd2, &eu->l2 );
		RT_LIST_INSERT( &eg_p->eu_hd2, &eu->eumate_p->l2 );
	}
d1763 3
a1765 3
	/* copy the point from the vertex of one of our edgeuses */
	pt = eu->vu_p->v_p->vg_p->coord;
	VMOVE(eg_p->e_pt, pt);
d1767 9
a1775 3
	/* compute the direction from the endpoints of the edgeuse(s) */
	pt = eu->eumate_p->vu_p->v_p->vg_p->coord;
	VSUB2(eg_p->e_dir, eg_p->e_pt, pt);	
d1777 5
d1783 5
a1787 9
	/* If the edge vector is essentially 0 magnitude we're in trouble.
	 * We warn the user and create an arbitrary vector we can use.
	 */
	if (VNEAR_ZERO(eg_p->e_dir, SMALL_FASTF)) {
		pointp_t pt2 = eu->vu_p->v_p->vg_p->coord;
		VPRINT("nmg_edge_g(): e_dir too small", eg_p->e_dir);
		rt_log("nmg_edge_g(): (%g %g %g) -> (%g %g %g)",
				pt[X],  pt[Y],  pt[Z],
				pt2[X], pt2[Y], pt2[Z]);
a1788 5
		VSET(eg_p->e_dir, 1.0, 0.0, 0.0);
		VPRINT("nmg_edge_g(): Forcing e_dir to", eg_p->e_dir);
		rt_bomb("nmg_edge_g():  0 length edge\n");
	}

d1790 1
a1790 1
		rt_log("nmg_edge_g(e=x%x) eg=x%x\n", e, e->eg_p );
d1800 1
a1800 3
 *
 *  Make a use of the edge geometry structure "eg" in edge "e",
 *  releasing the use of any previous edge geometry by "e".
a1801 1
/* XXX Need to change to take an edgeuse, and a magic_p */
d1803 3
a1805 3
nmg_use_edge_g( e, eg )
struct edge	*e;
struct edge_g_lseg	*eg;
d1807 3
a1809 1
	struct edge_g_lseg	*old;
d1811 3
a1813 1
	NMG_CK_EDGE(e);
d1816 1
a1816 10
	if( old = e->eg_p )  {
		/* XXX For all the edgeuses around e, disconnect from old edge_g_lseg */
		struct edgeuse	*start = e->eu_p;
		struct edgeuse	*cur = e->eu_p->radial_p;
		do {
			/* Process cur, then cur->eumate_p */
			RT_LIST_DEQUEUE( &cur->l2 );
			RT_LIST_DEQUEUE( &cur->eumate_p->l2 );
			cur = cur->eumate_p->radial_p;
		} while( cur != start->radial_p );
d1818 4
a1821 15
		/* If this was last use, kill the old edge_g */
		nmg_keg( (long *)old );
	}
	e->eg_p = eg;
	/* XXX For all the edgeuses around e, connect to new edge_g_lseg */
	{
		struct edgeuse	*start = e->eu_p;
		struct edgeuse	*cur = e->eu_p->radial_p;
		do {
			/* Process cur, then cur->eumate_p */
			RT_LIST_INSERT( &eg->eu_hd2, &cur->l2 );
			RT_LIST_INSERT( &eg->eu_hd2, &cur->eumate_p->l2 );
			cur = cur->eumate_p->radial_p;
		} while( cur != start->radial_p );
	}
d1823 6
d1830 2
a1831 2
		rt_log("nmg_use_egde_g(e=x%x, new_eg=x%x) old_eg=x%x\n",
			e , eg, old);
d1878 1
a1878 1
			if( !eu->e_p->eg_p )  nmg_edge_g(eu->e_p);
d2287 1
a2287 1
 *			N M G _ M O V E E U
d2289 2
a2290 2
 *	Move a pair of edgeuses onto a new edge (glue edgeuse).
 *	the edgeuse eusrc and its mate are moved to the edge
d2293 5
d2300 1
a2300 1
nmg_moveeu(eudst, eusrc)
d2318 1
a2318 1
		rt_log("nmg_moveeu() moving edgeuse to itself\n");
d2324 1
a2324 1
	    	rt_log("nmg_moveeu() edgeuses already share edge\n");
d2338 1
a2338 1
	    	rt_bomb("nmg_moveeu() edgeuses do not share vertices, cannot share edge\n");
a2340 6
	/* Dequeue edgeuse from geometry's list of users */
	RT_LIST_DEQUEUE( &eusrc->l2 );
	RT_LIST_DEQUEUE( &eusrc_mate->l2 );
	RT_LIST_INIT( &eusrc->l2 );
	RT_LIST_INIT( &eusrc_mate->l2 );

a2343 3
	/* If this was last use of eusrc edge, kill old edge_g */
	if( e->eg_p )  nmg_keg( (long *)e->eg_p );

d2367 6
a2372 5
	/* XXX Make eusrc use geometry of eudst */
	if( eudst->e_p->eg_p )  {
		struct edge_g_lseg	*eg = eudst->e_p->eg_p;
		RT_LIST_INSERT( &eg->eu_hd2, &eusrc->l2 );
		RT_LIST_INSERT( &eg->eu_hd2, &eusrc_mate->l2 );
d2376 1
a2376 1
		rt_log("nmg_moveeu(eudst=x%x, eusrc=x%x)\n", eudst , eusrc);
a2420 1
	new_e->eg_p = (struct edge_g *)NULL;
@


10.39
log
@vertexuse_a is now vertexuse_a_plane and vertexuse_a_cnurb
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.38 94/09/02 17:58:45 mike Exp Locker: mike $ (BRL)";
d730 3
d827 4
d1340 33
d1425 8
a1432 1
		if (e->eg_p) FREE_EDGE_G(e->eg_p);
d1439 10
d1709 1
d1715 2
a1716 1
	struct edge_g *eg_p = (struct edge_g *)NULL;
d1721 4
a1724 3
	NMG_CK_VERTEXUSE(e->eu_p->vu_p);
	NMG_CK_VERTEX(e->eu_p->vu_p->v_p);
	NMG_CK_VERTEX_G(e->eu_p->vu_p->v_p->vg_p);
d1726 4
a1729 4
	NMG_CK_EDGEUSE(e->eu_p->eumate_p);
	NMG_CK_VERTEXUSE(e->eu_p->eumate_p->vu_p);
	NMG_CK_VERTEX(e->eu_p->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(e->eu_p->eumate_p->vu_p->v_p->vg_p);
d1731 1
a1731 1
	if(e->eu_p->vu_p->v_p == e->eu_p->eumate_p->vu_p->v_p )
d1736 1
a1736 1
		NMG_CK_EDGE_G(eg_p);
d1738 5
a1742 3
		m = nmg_find_model(&e->eu_p->l.magic);
		GET_EDGE_G(eg_p, m);	/* sets usage=1 */
		eg_p->magic = NMG_EDGE_G_MAGIC;
d1744 5
d1752 1
a1752 1
	pt = e->eu_p->vu_p->v_p->vg_p->coord;
d1756 1
a1756 1
	pt = e->eu_p->eumate_p->vu_p->v_p->vg_p->coord;
d1764 1
a1764 1
		pointp_t pt2 = e->eu_p->vu_p->v_p->vg_p->coord;
d1783 4
d1790 1
d1794 1
a1794 1
struct edge_g	*eg;
d1796 1
a1796 1
	struct edge_g	*old;
d1799 1
a1799 1
	NMG_CK_EDGE_G(eg);
d1802 12
a1813 2
		/* Macro releases previous edge geom, if usage hits zero */
		FREE_EDGE_G(e->eg_p);
d1816 11
a1826 1
	eg->usage++;
d2335 6
d2344 3
a2360 1
		if (e->eg_p) FREE_EDGE_G(e->eg_p);
d2369 7
@


10.38
log
@faceuse_a, loopuse_a, and edgeuse_a have been eliminated.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.37 94/09/02 00:53:26 mike Exp Locker: mike $ (BRL)";
d640 1
a640 1
	vu->vua_p = (struct vertexuse_a *)NULL;
d1112 10
a1121 1
	if (vu->vua_p) FREE_VERTEXUSE_A(vu->vua_p);
a1622 1
	struct vertexuse_a *vua_p;
d1627 2
a1628 2
	if( !vu->vua_p )
	{
d1630 6
a1635 3
		GET_VERTEXUSE_A( vua_p , m );
		vua_p->magic = NMG_VERTEXUSE_A_MAGIC;
		vu->vua_p = vua_p;
d1637 1
a1637 1
		NMG_CK_VERTEXUSE_A( vu->vua_p );
d1640 1
a1640 1
	VMOVE( vu->vua_p->N , norm );
@


10.37
log
@Broke out nmg_kfg()
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.36 94/09/02 00:32:30 mike Exp Locker: mike $ (BRL)";
a440 1
	fu1->fua_p = fu2->fua_p = (struct faceuse_a *)NULL;
a535 1
	lu1->lua_p = lu2->lua_p = (struct loopuse_a *)NULL;
a738 1
	eu1->eua_p = eu2->eua_p = (struct edgeuse_a *)NULL;
a831 1
	eu1->eua_p = eu2->eua_p = (struct edgeuse_a *)NULL;
a971 1
	lu1->lua_p = lu2->lua_p = (struct loopuse_a *)NULL;
a1226 10
	/* kill the attributes */
	if (fu1->fua_p) {
		NMG_CK_FACEUSE_A(fu1->fua_p);
		FREE_FACEUSE_A(fu1->fua_p);
	}
	if (fu2->fua_p) {
		NMG_CK_FACEUSE_A(fu2->fua_p);
		FREE_FACEUSE_A(fu2->fua_p);
	}

a1308 9
	if (lu1->lua_p) {
		NMG_CK_LOOPUSE_A(lu1->lua_p);
		FREE_LOOPUSE_A(lu1->lua_p);
	}
	if (lu2->lua_p) {
		NMG_CK_LOOPUSE_A(lu2->lua_p);
		FREE_LOOPUSE_A(lu2->lua_p);
	}

a1416 13
	/* get rid of any attributes */
	if (eu1->eua_p) {
		if (eu1->eua_p == eu2->eua_p) {
			FREE_EDGEUSE_A(eu1->eua_p);
		} else {
			FREE_EDGEUSE_A(eu1->eua_p);
		}
	}
	if (eu2->eua_p) {
		FREE_EDGEUSE_A(eu2->eua_p);
	}


d1625 2
a1627 2
	else
		NMG_CK_VERTEXUSE_A( vu->vua_p );
@


10.36
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.35 94/08/09 19:38:14 mike Exp Locker: mike $ (BRL)";
d1151 32
d1223 3
a1225 5
	/* Release the geometry */
	if (fg = f1->g.plane_p) {
		NMG_CK_FACE_G_PLANE(fg);

		/* Disassociate this face from face_g_plane */
d1227 1
a1227 5

		/* If face_g_plane is not referred to by any other face, free it */
		if( RT_LIST_IS_EMPTY( &fg->f_hd ) )  {
			FREE_FACE_G_PLANE(fg);
		}
@


10.35
log
@Added GDurf's new "conf.h"
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.34 94/07/03 20:17:44 mike Exp Locker: mike $ (BRL)";
d201 2
a202 2
 *	6 face_g structures
 *		Each face_g structure contains a plane equation and
d429 1
a429 1
	f->fg_p = (struct face_g *)NULL;
d1170 1
a1170 1
	struct face_g	*fg;
d1192 4
a1195 2
	if (fg = f1->fg_p) {
		/* Disassociate this face from face_g */
d1198 1
a1198 1
		/* If face_g is not referred to by any other face, free it */
d1200 1
a1200 2
			NMG_CK_FACE_G(fg);
			FREE_FACE_G(fg);
d1836 1
a1836 1
	struct face_g	*fg;
d1847 1
a1847 1
	fg = f->fg_p;
d1849 2
a1850 2
		/* Face already has face_g associated with it */
		NMG_CK_FACE_G(fg);
d1853 1
a1853 1
		GET_FACE_G(f->fg_p, m);
d1855 2
a1856 2
		fg = f->fg_p;
		fg->magic = NMG_FACE_G_MAGIC;
d2402 2
a2403 2
	struct face_g	*fg1;
	struct face_g	*fg2;
d2408 2
a2409 2
	fg1 = f1->fg_p;
	fg2 = f2->fg_p;
d2412 2
a2413 2
		NMG_CK_FACE_G(fg1);
		f1->fg_p = fg2;
d2424 2
a2425 2
		NMG_CK_FACE_G(fg1);
		f2->fg_p = fg1;
d2435 2
a2436 2
	NMG_CK_FACE_G(fg1);
	NMG_CK_FACE_G(fg2);
d2451 1
a2451 1
		f->fg_p = fg1;
d2457 1
a2457 1
	FREE_FACE_G(fg2);
@


10.34
log
@Added debug prints.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.33 94/03/09 18:37:02 mike Exp Locker: mike $ (BRL)";
d53 1
@


10.33
log
@Pointer sanity.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.32 94/03/09 16:35:14 jra Exp Locker: mike $ (BRL)";
d1707 1
a1707 1
		rt_log("nmg_edge_g(e=x%x)\n", e );
d1722 2
d1727 1
a1727 1
	if( e->eg_p )  {
d1735 2
a1736 1
		rt_log("nmg_use_egde_g(e=x%x, eg=x%x)\n", e , eg);
@


10.32
log
@Added more checking to nmg_keu
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.31 94/01/24 09:27:53 jra Exp Locker: jra $ (BRL)";
d1375 2
@


10.31
log
@Added a few DEBUG_BASIC prints that were missed the first time through
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.30 94/01/22 05:23:46 mike Exp Locker: jra $ (BRL)";
d1358 3
d1366 1
d1374 1
d1434 7
@


10.30
log
@For each routine, added a 1-line debugging print that shows what the
calling sequence was, and what the return code was.
Conditional on DEBUG_BASIC.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.29 93/12/27 22:45:34 mike Exp Locker: mike $ (BRL)";
d252 4
d289 4
d331 4
d376 5
d458 5
d670 1
d677 7
a683 1
	return(nmg_mvu(v, upptr, m));
d791 4
d911 5
d956 5
d1054 4
d1570 4
d1593 4
d1625 4
d1691 4
d1717 4
d1798 5
d1848 4
d1886 4
d1966 4
d2006 4
d2039 1
d2080 1
a2080 1
	if( nmg_klu(lu1) )  return 1;	/* fu went empty */
d2082 5
a2086 1
	return(0);
d2104 1
d2122 8
a2129 1
	return nmg_shell_is_empty(s);
d2168 4
d2250 4
d2285 4
d2290 1
d2312 4
d2363 4
d2397 4
d2409 4
d2419 7
a2425 1
	if( fg1 == fg2 )  return;
d2439 4
@


10.29
log
@Moved bounding box for faces from struct face_g to struct face.
Necessary because face geometry is now shared by multiple faces
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.28 93/12/03 03:35:36 mike Exp Locker: mike $ (BRL)";
d460 2
a461 1
 *  the shell and vertex, then call lu=nmg_mlv(s,NULL,).
d477 2
a478 1
 * vertex from the shell followed by a call to nmg_kvu(s->v_p).
d488 1
d524 1
a524 2
		struct shell		*s;
		struct vertexuse	*vu1, *vu2;
a525 2
		s = p.s;

a554 2
		struct vertexuse	*vu1, *vu2;

d577 5
d624 4
d1096 3
d1124 1
d1175 5
a1179 1
	return nmg_shell_is_empty(s);
d1266 3
d1382 3
d1423 3
d1458 3
d1486 3
@


10.28
log
@Access to plane equation / surface normal in face_geometry structure
is now done through macros NMG_GET_FU_PLANE() NMG_GET_FU_NORMAL(),
which honor the f->flip flag.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.27 93/11/18 02:08:30 mike Exp Locker: mike $ (BRL)";
d1705 1
a1705 1
 *	Assign plane equation to face and compute bounding box
a1757 1
	struct face_g	*fg;
d1766 2
a1767 6
	if ( fg = f->fg_p ) {
		NMG_CK_FACE_G(fg);
	} else {
		/* We have no idea what surface normal to use here */
		rt_bomb("nmg_face_bb() called on face with no face geometry\n");
	}
a1768 3
	fg->max_pt[X] = fg->max_pt[Y] = fg->max_pt[Z] = -MAX_FASTF;
	fg->min_pt[X] = fg->min_pt[Y] = fg->min_pt[Z] = MAX_FASTF;

d1776 2
a1777 2
			VMIN(fg->min_pt, lu->l_p->lg_p->min_pt);
			VMAX(fg->max_pt, lu->l_p->lg_p->max_pt);
d1812 1
a1812 1
		struct face_g *fg;
d1814 3
a1816 1
		nmg_face_bb(fu->f_p, tol);
d1818 2
a1819 4
		fg = fu->f_p->fg_p;
		NMG_CK_FACE_G(fg);
		VMIN(sa->min_pt, fg->min_pt);
		VMAX(sa->max_pt, fg->max_pt);
d1823 1
a1823 1
		    ( RT_LIST_NEXT(faceuse, &fu->l)->f_p == fu->f_p ) )  {
@


10.27
log
@Modifications for face_g having a list of faces sharing that geometry.
Bounding box routines now all take a tol arg.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.26 93/10/22 22:28:11 mike Exp $ (BRL)";
d1733 1
d2230 3
d2247 17
d2275 1
@


10.26
log
@nmg_eups() and nmg_lups() eliminated, in favor of
nmg_find_s_of_lu() and nmg_find_s_of_eu().

@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.25 93/10/20 09:30:20 jra Exp Locker: mike $ (BRL)";
d412 3
a414 1
	f->magic = NMG_FACE_MAGIC;	/* Face struct is GOOD */
d1112 1
d1132 10
a1141 4
	/* kill the geometry */
	if (f1->fg_p) {
		NMG_CK_FACE_G(f1->fg_p);
		FREE_FACE_G(f1->fg_p);
d1629 4
a1632 4
 * XXX Should take tol struct.  Should enlarge bounding box by 1*tol->dist,
 * XXX perhaps as much as 10*tol->dist.
 * XXX This might be the only place it actually has to be changed,
 * XXX but this is the bottom of the call stack.
d1635 3
a1637 2
nmg_loop_g(l)
struct loop *l;
d1645 1
d1648 1
d1685 16
d1706 2
d1712 1
a1712 1
plane_t p;
d1728 2
a1729 1
		NMG_CK_FACE_G(f->fg_p);
d1735 2
d1739 6
a1744 4
	for (i=0 ; i < ELEMENTS_PER_PLANE ; i++)
		fg->N[i] = p[i];

	nmg_face_bb(f);
a1750 2
 * XXX Should take tol struct.  Should enlarge bounding box by 1*tol->dist,
 * XXX perhaps as much as 10*tol->dist.
d1753 3
a1755 2
nmg_face_bb(f)
struct face *f;
a1759 1
	struct model	*m;
d1761 1
d1768 3
a1771 6
	else {
		m = nmg_find_model( &fu->l.magic );
		GET_FACE_G(fg, m);
		fg->magic = NMG_FACE_G_MAGIC;
		f->fg_p = fg;
	}
d1776 1
a1776 1
	/* we compute the extent of the face by looking at the extent of
d1780 1
a1780 1
		nmg_loop_g(lu->l_p);
a1792 2
 * XXX Should take tol struct.  Should enlarge bounding box by 1*tol->dist,
 * XXX perhaps as much as 10*tol->dist.
d1795 3
a1797 2
nmg_shell_a(s)
struct shell *s;
a1800 1
	struct face_g *fg;
d1807 1
a1817 1
	/* */
d1819 1
a1819 1
		nmg_face_bb(fu->f_p);
d1821 2
d1824 1
d1835 1
a1835 1
		nmg_loop_g(lu->l_p);
a1868 2
 * XXX Should take tol struct.  Should enlarge bounding box by 1*tol->dist,
 * XXX perhaps as much as 10*tol->dist.
d1871 3
a1873 2
nmg_region_a(r)
struct nmgregion *r;
d1879 1
d1894 1
a1894 1
		nmg_shell_a(s);
d2222 37
@


10.25
log
@Added nmg_vertexuse_nv to assign a normal vector to a vertexuse
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.24 93/10/01 06:03:00 mike Exp Locker: jra $ (BRL)";
d1910 1
a1910 1
	s = nmg_lups(lu1);
@


10.24
log
@Added some XXX markers for later.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.23 93/04/09 05:49:50 cjohnson Exp Locker: mike $ (BRL)";
d1504 27
@


10.23
log
@Fix stupid and dangerous typo.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.22 1993/04/09 05:37:23 cjohnson Exp cjohnson $ (BRL)";
d1593 4
d1688 3
d1734 3
d1809 3
@


10.22
log
@Completed moving the set magic number in structure to where the
structure was actually "good".  Reordered many of the structure
initializations to follow structure definitions (or inverse) and to
help keep the initializations localized.  Added general comments.
Started to prepare for removal of vertex(use) stealing.  Made special
case of vertex in shell call to nmg_ml become a call to nmg_mlv().
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.21 1993/04/07 05:54:33 mike Exp cjohnson $ (BRL)";
d796 1
a796 1
	/* vu->up needs to be set but we can't do that until we recovered *
@


10.21
log
@Return code from demote_lu and demote_eu have changed,
they now mean that the parent has gone empty.
Same semantics as with the "kill" routines
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.20 93/04/07 00:54:05 cjohnson Exp Locker: mike $ (BRL)";
d220 2
d225 13
d250 1
a250 1
	m->magic = NMG_MODEL_MAGIC;	/* Model Structure is Good */
d291 2
a292 1
 *	Make new region, shell, vertex in model.
d374 4
d469 6
a499 2
	l->lg_p = (struct loop_g *)NULL;

a500 3
	lu1->l.magic = NMG_LOOPUSE_MAGIC;
	RT_LIST_INIT( &lu1->down_hd );

a501 2
	lu2->l.magic = NMG_LOOPUSE_MAGIC;
	RT_LIST_INIT( &lu2->down_hd );
d503 1
d507 3
d511 7
a517 1
	lu1->lua_p = lu2->lua_p = (struct loopuse_a *)NULL;
d527 2
a528 2
		lu1->lumate_p = lu2;
		lu2->lumate_p = lu1;
d534 1
d540 1
a540 2
		}
		else {
d558 2
a560 3
		lu1->lumate_p = lu2;
		lu2->lumate_p = lu1;

a575 1
	lu1->orientation = lu2->orientation = orientation;
d587 3
a611 1
	vu->l.magic = NMG_VERTEXUSE_MAGIC;
d617 1
d629 3
a641 1
	v->magic = NMG_VERTEX_MAGIC;
d644 1
a689 3
	e->magic = NMG_EDGE_MAGIC;
	e->eg_p = (struct edge_g *)NULL;

a691 1
	eu1->l.magic = eu2->l.magic = NMG_EDGEUSE_MAGIC;
d693 1
d695 2
d703 9
d719 1
d732 1
d742 1
a781 3
	e->magic = NMG_EDGE_MAGIC;
	e->eg_p = (struct edge_g *)NULL;

d784 1
a784 2
	eu1->l.magic = eu2->l.magic = NMG_EDGEUSE_MAGIC;

d786 2
a790 1

d793 5
d799 2
a804 2
		eu1->vu_p = vu;
		eu2->vu_p = nmg_mvu(vu->v_p, &eu2->l.magic, m);
d806 6
d815 2
a816 1
		vu->up.eu_p = eu1;
a839 1
		eu1->vu_p = vu;
d846 3
d850 7
d859 1
a859 1
		/* loopuses now point down at edgeuses */
d903 8
a913 3
	l->magic = NMG_LOOP_MAGIC;
	l->lg_p = (struct loop_g *)NULL;

a914 3
	lu1->l.magic = NMG_LOOPUSE_MAGIC;
	RT_LIST_INIT( &lu1->down_hd );

a915 2
	lu2->l.magic = NMG_LOOPUSE_MAGIC;
	RT_LIST_INIT( &lu2->down_hd );
d917 1
d919 1
d921 3
a923 1
	lu1->up.s_p = lu2->up.s_p = s;
a924 1
	lu1->lua_p = lu2->lua_p = (struct loopuse_a *)NULL;
a925 1

d928 3
d932 6
a937 19
	/* make loop on single vertex */
	if( RT_LIST_IS_EMPTY( &s->eu_hd ) && s->vu_p )  {
		struct vertexuse	*vu1;
		struct vertexuse	*vu2;

		vu1 = s->vu_p;		/* take vertex from shell */
		s->vu_p = (struct vertexuse *)NULL;

		RT_LIST_SET_DOWN_TO_VERT( &lu1->down_hd, vu1 );
		vu1->up.lu_p = lu1;

		vu2 = nmg_mvu(vu1->v_p, &lu2->l.magic, m);
		/* vu2->up.lu_p = lu2; done by nmg_mvu() */
		RT_LIST_SET_DOWN_TO_VERT( &lu2->down_hd, vu2 );

		/* head, lu1, lu2, ... */
		RT_LIST_APPEND( &s->lu_hd, &lu1->l );
		RT_LIST_APPEND( &lu1->l, &lu2->l );
		return(lu1);
d940 1
a940 2
	feu = RT_LIST_FIRST( edgeuse, &s->eu_hd );

d944 1
a945 1
		NMG_CK_EDGEUSE(p1);
d965 1
a965 1
		 *  ... p1, head.
d976 5
d986 5
@


10.20
log
@Add a large comment describing the nmg structures used in nmg_m*
by enumerating a cube with comments.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.19 93/04/05 20:28:03 cjohnson Exp Locker: cjohnson $ (BRL)";
d1778 2
a1779 1
/*			N M G _ D E M O T E _ L U
d1783 3
a1785 3
 *	Explicit Return
 *		1	Loopuse was on a single vertex.  Nothing done
 *		0	Loopse edges moved to shell, loopuse deleted.
d1800 1
a1800 9
		if (rt_g.NMG_debug) {
			register struct vertexuse *vu;
			vu = RT_LIST_FIRST(vertexuse, &lu1->down_hd);
			rt_log("trying to demote a loopuse of a single vertex\n");
			if (vu->v_p->vg_p) {
				VPRINT("Vertex: ", vu->v_p->vg_p->coord);
			}
		}
		return(1);
d1833 1
a1833 2
	/* XXX What to do if fu went empty? */
	if( nmg_klu(lu1) )  rt_log("nmg_demote_lu: fu went empty\n");
d1842 4
a1845 3
 *	Explicit Retruns
 *		1	Edge was not a wire edge.  Nothing done.
 *		0	edge decomposed into verticies.
d1854 2
a1855 2
	if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC)
		return(1);
d1870 1
a1870 1
	return(0);
@


10.19
log
@Started moving MAGIC assigns to where structures are good.
Started commenting as to where comments are needed.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.18 93/04/03 04:20:39 mike Exp $ (BRL)";
d72 142
@


10.18
log
@Make it explicit that nmg_klu() can kill lu's with empty eu lists.
@
text
@d28 1
d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.17 93/04/03 01:58:20 mike Exp Locker: mike $ (BRL)";
a88 1
	m->magic = NMG_MODEL_MAGIC;
d93 1
a118 1
	r->l.magic = NMG_REGION_MAGIC;
d124 1
a153 1
	r->l.magic = NMG_REGION_MAGIC;
d155 1
d158 2
a192 1
	s->l.magic = NMG_SHELL_MAGIC;
d201 2
d250 1
a250 1
	f->magic = NMG_FACE_MAGIC;
a251 1
	fu1->l.magic = fu2->l.magic = NMG_FACEUSE_MAGIC;
d260 2
d283 1
d317 1
a331 1
	l->magic = NMG_LOOP_MAGIC;
d343 1
@


10.17
log
@nmg_mvu() and nmg_mvvu() have become static -- they are not
suitable for general applications to use.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.16 93/04/02 23:46:31 mike Exp Locker: mike $ (BRL)";
d863 1
a863 1
		ret = nmg_is_shell_empty(vu->up.s_p);
d993 2
@


10.16
log
@unglue edge must NOT duplicate edge geometry.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.15 93/04/02 23:26:13 mike Exp Locker: mike $ (BRL)";
d58 3
d62 1
d76 4
a79 1
 *	Create a new model.
d104 3
d133 10
a142 3
 *	Make new region, shell, vertex in model
 *	Create a new (2nd, 3rd, ...) region in model consisting of a minimal
 *	shell.
d171 7
d180 2
a181 2
nmg_msv(r_p)
struct nmgregion	*r_p;
d186 1
a186 1
	NMG_CK_REGION(r_p);
d189 1
a189 1
	GET_SHELL(s, r_p->m_p);
d192 2
a193 2
	s->r_p = r_p;
	RT_LIST_APPEND( &r_p->s_hd, &s->l );
d200 1
a200 1
	vu = nmg_mvvu(&s->l.magic);
d211 4
d282 9
d292 9
a300 2
 *  Implicit return -
 *	The loopuse is inserted at the head of the appropriate list.
d363 2
a364 2
			if (v) vu1 = nmg_mvu(v, &lu1->l.magic);
			else vu1 = nmg_mvvu(&lu1->l.magic);
d370 1
a370 1
		vu2 = nmg_mvu(vu1->v_p, &lu2->l.magic);
d388 2
a389 2
		if (v) vu1 = nmg_mvu(v, &lu1->l.magic);
		else vu1 = nmg_mvvu(&lu1->l.magic);
d393 1
a393 1
		vu2 = nmg_mvu(vu1->v_p, &lu2->l.magic);
d407 4
d412 5
a416 4
struct vertexuse *
nmg_mvu(v, upptr)
struct vertex *v;
long *upptr;		/* pointer to parent struct */
a418 1
	struct model	*m;
d421 1
a431 1
	m = nmg_find_model( upptr );
d446 4
d451 4
a454 3
struct vertexuse *
nmg_mvvu(upptr)
long *upptr;
a456 1
	struct model	*m;
d458 1
a458 1
	m = nmg_find_model( upptr );
d463 1
a463 1
	return(nmg_mvu(v, upptr));
d470 1
a470 1
 *	Make edge
d526 3
a528 3
	if (v1)
		eu1->vu_p = nmg_mvu(v1, &eu1->l.magic);
	else if (s->vu_p)  {
d534 2
a536 2
	else
		eu1->vu_p = nmg_mvvu(&eu1->l.magic);
d538 3
a540 4

	if (v2)
		eu2->vu_p = nmg_mvu(v2, &eu2->l.magic);
	else if (s->vu_p)  {
d546 2
a548 2
	else
		eu2->vu_p = nmg_mvvu(&eu2->l.magic);
d566 10
a575 2
 * Make edge on vertexuse.
 * Vertexuse must be sole element of either a shell or a loopuse.
a585 6
	if (*vu->up.magic_p != NMG_SHELL_MAGIC &&
	    *vu->up.magic_p != NMG_LOOPUSE_MAGIC) {
		rt_log("nmg_meonvu() Error in %s at %d vertexuse not for shell/loop\n", 
		    __FILE__, __LINE__);
		rt_bomb("nmg_meonvu() cannot make edge, vertexuse not sole element of object\n");
	}
d609 1
a609 1
		eu2->vu_p = nmg_mvu(vu->v_p, &eu2->l.magic);
d617 1
a617 2
	}
	else if (*vu->up.magic_p == NMG_LOOPUSE_MAGIC) {
d655 2
d675 4
a678 4
 * A loop is created from this list of edges.  The edges must
 * form a true circuit, or we dump core on your disk.  If we
 * succeed, then the edgeuses are moved from the shell edgeuse list
 * to the loop, and the two loopuses are inserted into the shell.
d727 1
a727 1
		vu2 = nmg_mvu(vu1->v_p, &lu2->l.magic);
d1845 2
a1846 1
/*			N M G _ U N G L U E E D G E
@


10.15
log
@nmg_ensure_vertex() has been eliminated, in favor of using
nmg_is_vertex_a_selfloop_in_shell() and nmg_mlv().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.14 93/04/02 02:27:50 mike Exp Locker: mike $ (BRL)";
d1798 6
a1825 2

	/* If old_e had edge_g, duplicate reference here */
a1826 1
	if( old_e->eg_p )  nmg_use_edge_g( new_e, old_e->eg_p );
@


10.14
log
@Reorganized along functional lines.
Changed so that most kill routines return a code
indicating whether their parent entity went empty and also needs killing.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.13 93/03/25 23:17:49 mike Exp Locker: mike $ (BRL)";
d427 1
d429 3
a431 2
 *	Explicit Return:
 *		edgeuse whose vertex use is v1, whose eumate has vertex v2
d501 1
a501 1
		nmg_kvu( s->vu_p );
d764 20
a783 1
 *	Kill vertexuse
d785 1
a785 1
void
d790 1
a793 1
	/* ditch any attributes */
d809 1
d813 1
d816 1
d821 1
d932 2
a933 2
		nmg_kvu( RT_LIST_FIRST(vertexuse, &lu1->down_hd) );
		nmg_kvu( RT_LIST_FIRST(vertexuse, &lu2->down_hd) );
d1079 1
a1079 1
		nmg_kvu(eu1->vu_p);
d1082 1
a1082 1
		nmg_kvu(eu2->vu_p);
d1636 1
a1636 1
	nmg_klu(lu1);
d1643 1
a1643 1
 *	Demote a wire edge into a pair of verticies
d1654 1
d1662 3
a1664 1
	nmg_ensure_vertex(eu->vu_p->v_p, s);
d1667 3
a1669 1
	nmg_ensure_vertex(eu->eumate_p->vu_p->v_p, s);
a1788 33
}

/*
 *			N M G _ E N S U R E _ V E R T E X
 *
 *	Ensure that this shell contains a single-vertex loop
 *	on the given vertex.
 *	If it does not, then one is created.
 */
void
nmg_ensure_vertex(v, s)
struct vertex	*v;
struct shell	*s;
{
	struct vertexuse *vu;
	struct loopuse	*lu;

	NMG_CK_VERTEX(v);
	NMG_CK_SHELL(s);

	/* try to find the vertex in a loopuse of this shell */
	for (RT_LIST_FOR(vu, vertexuse, &v->vu_hd)) {
		NMG_CK_VERTEXUSE(vu);
		if (*vu->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
		lu = vu->up.lu_p;
		NMG_CK_LOOPUSE(lu);
		if( *lu->up.magic_p != NMG_SHELL_MAGIC )  continue;
		NMG_CK_SHELL(lu->up.s_p);
		if( lu->up.s_p == s)
			return;
	}

	(void)nmg_mlv(&s->l.magic, v, OT_SAME);
@


10.13
log
@Calling sequence to nmg_keu() changed.  It now returns an int
indicating when the parent is a loopuse, and that loopuse needs
to be killed because it just became empty.
@
text
@d8 1
a8 2
 *		nmg_m* routines "kill" (delete) NMG structures.
 *		nmg_c* routines "create" things using NMG structures.
d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.12 93/03/23 22:18:13 mike Exp Locker: mike $ (BRL)";
a57 14
/*
 *			N M G _ F I N D _ M O D E L
 *
 *  Given a pointer to the magic number in any NMG data structure,
 *  return a pointer to the model structure that contains that NMG item.
 *
 *  The reason for the register variable is to leave the argument variable
 *  unmodified;  this may aid debugging in event of a core dump.
 */
struct model *
nmg_find_model( magic_p_arg )
long	*magic_p_arg;
{
	register long	*magic_p = magic_p_arg;
d59 8
a66 7
top:
	if( magic_p == (long *)0 )  {
		rt_log("nmg_find_model(x%x) enountered null pointer\n",
			magic_p_arg );
		rt_bomb("nmg_find_model() null pointer\n");
		/* NOTREACHED */
	}
a67 41
	switch( *magic_p )  {
	case NMG_MODEL_MAGIC:
		return( (struct model *)magic_p );
	case NMG_REGION_MAGIC:
		return( ((struct nmgregion *)magic_p)->m_p );
	case NMG_SHELL_MAGIC:
		return( ((struct shell *)magic_p)->r_p->m_p );
	case NMG_FACEUSE_MAGIC:
		magic_p = &((struct faceuse *)magic_p)->s_p->l.magic;
		goto top;
	case NMG_FACE_MAGIC:
		magic_p = &((struct face *)magic_p)->fu_p->l.magic;
		goto top;
	case NMG_LOOP_MAGIC:
		magic_p = ((struct loop *)magic_p)->lu_p->up.magic_p;
		goto top;
	case NMG_LOOPUSE_MAGIC:
		magic_p = ((struct loopuse *)magic_p)->up.magic_p;
		goto top;
	case NMG_EDGE_MAGIC:
		magic_p = ((struct edge *)magic_p)->eu_p->up.magic_p;
		goto top;
	case NMG_EDGEUSE_MAGIC:
		magic_p = ((struct edgeuse *)magic_p)->up.magic_p;
		goto top;
	case NMG_VERTEX_MAGIC:
		magic_p = &(RT_LIST_FIRST(vertexuse,
			&((struct vertex *)magic_p)->vu_hd)->l.magic);
		goto top;
	case NMG_VERTEXUSE_MAGIC:
		magic_p = ((struct vertexuse *)magic_p)->up.magic_p;
		goto top;

	default:
		rt_log("nmg_find_model() can't get model for magic=x%x (%s)\n",
			*magic_p, rt_identify_magic( *magic_p ) );
		rt_bomb("nmg_find_model() failure\n");
	}
	return( (struct model *)NULL );
}

d96 3
d181 179
d607 1
a607 1
 *	Make Loop from edgeuse list
d609 1
a609 1
 *	Pass a pointer to a shell.  The edgeuse child of the shell
d621 2
a622 2
 * succeed, then the edgeuses are moved from the parameter list
 * to the loop, and the loops are inserted into the shell
a722 2
	/*	printf("p2v %x feu %x\n", p2->vu_p->v_p, feu->vu_p->v_p); */

d737 22
a758 10
/*			N M G _ M O V E V U
 *
 *	Move a vertexuse to a new vertex
 */
void
nmg_movevu(vu, v)
struct vertexuse *vu;
struct vertex *v;
{
	struct vertex	*oldv;
a759 16
	NMG_CK_VERTEXUSE(vu);
	NMG_CK_VERTEX(v);

	oldv = vu->v_p;
	NMG_CK_VERTEX(oldv);

	RT_LIST_DEQUEUE( &vu->l );
	if( RT_LIST_IS_EMPTY( &oldv->vu_hd ) )  {
		/* last vertexuse on vertex */
		if (oldv->vg_p) FREE_VERTEX_G(oldv->vg_p);
		FREE_VERTEX(oldv);
	}
	RT_LIST_APPEND( &v->vu_hd, &vu->l );
	vu->v_p = v;
}

d807 4
d812 1
a812 1
void
d819 1
d830 2
d835 1
a835 1
		nmg_klu( RT_LIST_FIRST( loopuse, &fu1->lu_hd ) );
d858 2
a859 2
	if( RT_LIST_IS_EMPTY( &fu1->s_p->fu_hd ) )
		rt_bomb("nmg_kfu() faceuse mate not in parent?\n");
d864 1
a866 1

d869 1
a869 1
 *	Kill loopuse
d876 4
d881 1
a881 1
void
d886 2
d899 4
a902 6
	if( RT_LIST_NON_EMPTY( &lu1->down_hd ) )  {
		long	magic1;
		/* deal with the children */
		magic1 = RT_LIST_FIRST_MAGIC( &lu1->down_hd );
		if( magic1 != RT_LIST_FIRST_MAGIC( &lu2->down_hd ) )
			rt_bomb("nmg_klu() loopuses do not have same type of child!\n");
d904 9
a912 5
		if( magic1 == NMG_VERTEXUSE_MAGIC )  {
			/* Follow the vertex-loop hack downward,
			 * nmg_kvu() will clean up */
			nmg_kvu( RT_LIST_FIRST(vertexuse, &lu1->down_hd) );
			nmg_kvu( RT_LIST_FIRST(vertexuse, &lu2->down_hd) );
d914 3
a916 10
		else if ( magic1 == NMG_EDGEUSE_MAGIC) {
			/* delete all edgeuse in the loopuse (&mate) */
			while( RT_LIST_NON_EMPTY( &lu1->down_hd ) )  {
				(void)nmg_keu(RT_LIST_FIRST(edgeuse, &lu1->down_hd) );
			}
		}
		else {
			rt_log("nmg_klu(x%x) magic=%s\n", lu1, rt_identify_magic(magic1) );
			rt_bomb("nmg_klu: unknown type for loopuse child\n");
		}
a918 1

d923 2
a924 2
	}
	else if (*lu1->up.magic_p == NMG_FACEUSE_MAGIC) {
d927 3
a930 5
	else {
		rt_log("nmg_klu() in %s at %d Unknown parent for loopuse\n", __FILE__,
		    __LINE__);
		rt_bomb("nmg_klu\n");
	}
a946 2
	lu1->l_p = lu2->l_p = (struct loop *)NULL;

d949 1
a952 66
 *			N M G _ M F
 *
 *	Make Face from loop
 *	make a face from a pair of loopuses.  The loopuses must be direct
 *	children of a shell.  The new face will be a child of the same shell.
 */
struct faceuse *
nmg_mf(lu1)
struct loopuse *lu1;
{
	struct face *f;
	struct faceuse *fu1, *fu2;
	struct loopuse *lu2;
	struct shell	*s;
	struct model	*m;

	NMG_CK_LOOPUSE(lu1);
	if (*lu1->up.magic_p != NMG_SHELL_MAGIC) {
		rt_bomb("nmg_mf() loop must be child of shell for making face\n");
	}
	lu2 = lu1->lumate_p;
	NMG_CK_LOOPUSE(lu2);
	if (lu2->up.magic_p != lu1->up.magic_p) {
		rt_bomb("nmg_mf() loopuse mate does not have same parent\n");
	}

	s = lu1->up.s_p;
	NMG_CK_SHELL(s);

	m = nmg_find_model( &s->l.magic );
	GET_FACE(f, m);
	GET_FACEUSE(fu1, m);
	GET_FACEUSE(fu2, m);

	f->fu_p = fu1;
	f->fg_p = (struct face_g *)NULL;
	f->magic = NMG_FACE_MAGIC;

	fu1->l.magic = fu2->l.magic = NMG_FACEUSE_MAGIC;
	RT_LIST_INIT(&fu1->lu_hd);
	RT_LIST_INIT(&fu2->lu_hd);
	fu1->s_p = fu2->s_p = s;
	fu1->fumate_p = fu2;
	fu2->fumate_p = fu1;
	fu1->orientation = fu2->orientation = OT_UNSPEC;
	fu1->f_p = fu2->f_p = f;
	fu1->fua_p = fu2->fua_p = (struct faceuse_a *)NULL;

	/* move the loopuses from the shell to the faceuses */
	RT_LIST_DEQUEUE( &lu1->l );
	RT_LIST_DEQUEUE( &lu2->l );
	RT_LIST_APPEND( &fu1->lu_hd, &lu1->l );
	RT_LIST_APPEND( &fu2->lu_hd, &lu2->l );

	lu1->up.fu_p = fu1;
	lu1->orientation = OT_SAME;
	lu2->up.fu_p = fu2;
	lu2->orientation = OT_SAME;

	/* connect the faces to the parent shell:  head, fu1, fu2... */
	RT_LIST_APPEND( &s->fu_hd, &fu1->l );
	RT_LIST_APPEND( &fu1->l, &fu2->l );
	return(fu1);
}

/*
d955 1
a955 1
 *	Delete an edgeuse & it's mate on a shell/loop.
d959 3
a961 3
 *	1	If the loopuse now has no edgeuses, and is thus "illegal"
 *		and in need of being deleted.  (The lu deletion can't be
 *		handled at this level, but must be done by the caller).
a1025 12

#if 0
		/* XXX If deleting this edge would cause parent loop to become
		 * non-contiguous
		 * we must kill the parent loopuses.  (or demote it)
		 * XXX This test isn't right
		 */
		else if (eu2->vu_p->v_p != eu1->vu_p->v_p )  {
			rt_log("nmg_keu() WARNING: possible discontinuous loop?\n");
			/** ret = 1; **/
		}
#endif
d1034 1
d1043 1
a1043 3
			eu1->eua_p = eu2->eua_p = (struct edgeuse_a *)NULL;
		}
		else {
a1044 1
			eu1->eua_p = (struct edgeuse_a *)NULL;
a1048 1
		eu2->eua_p = (struct edgeuse_a *)NULL;
a1054 1
		eu1->vu_p = (struct vertexuse  *)NULL;
a1057 1
		eu2->vu_p = (struct vertexuse  *)NULL;
d1068 5
d1074 1
a1074 1
void
d1078 1
d1081 2
d1085 1
a1085 1
		nmg_kfu( RT_LIST_FIRST(faceuse, &s->fu_hd) );
d1087 1
a1087 1
		nmg_klu( RT_LIST_FIRST(loopuse, &s->lu_hd) );
d1100 2
d1107 5
d1113 1
a1113 1
void
d1124 1
a1124 1
		nmg_ks( RT_LIST_FIRST( shell, &r->s_hd ) );
d1133 1
a1133 1
	if( RT_LIST_IS_EMPTY( &m->r_hd ) )
d1135 3
d1142 1
a1142 1
 *	Kill an entire model
d1151 1
a1151 1
		nmg_kr( RT_LIST_FIRST( nmgregion, &m->r_hd ) );
d1159 5
d1167 1
a1167 1
 *	Associate some coordinates with a vertex
d1171 2
a1172 2
struct vertex *v;
pointp_t	pt;
d1193 2
a1194 1
/*	N M G _ V E R T E X _ G
d1213 2
a1214 1
/*	N M G _ E D G E _ G
d1216 1
a1216 1
 *	Compute the equation of the line formed by the edge.
d1536 10
a1545 25
/*
 *			N M G _ M L V
 *
 *	Make a new loop (with specified orientation) and vertex,
 *	in a shell or face.
 *	If the vertex 'v' is NULL, the shell's lone vertex is used,
 *	or a new vertex is created.
 * 
 *  Implicit return -
 *	The loopuse is inserted at the head of the appropriate list.
 */
struct loopuse *
nmg_mlv(magic, v, orientation)
long		*magic;
struct vertex	*v;
int		orientation;
{
	struct loop	*l;
	struct loopuse	*lu1, *lu2;
	struct model	*m;
	union {
		struct shell *s;
		struct faceuse *fu;
		long *magic_p;
	} p;
a1546 1
	p.magic_p = magic;
a1547 86
	if (v) {
		NMG_CK_VERTEX(v);
	}

	m = nmg_find_model( magic );
	GET_LOOP(l, m);
	l->magic = NMG_LOOP_MAGIC;
	l->lg_p = (struct loop_g *)NULL;

	GET_LOOPUSE(lu1, m);
	lu1->l.magic = NMG_LOOPUSE_MAGIC;
	RT_LIST_INIT( &lu1->down_hd );

	GET_LOOPUSE(lu2, m);
	lu2->l.magic = NMG_LOOPUSE_MAGIC;
	RT_LIST_INIT( &lu2->down_hd );

	l->lu_p = lu1;

	lu1->l_p = lu2->l_p = l;
	lu1->lua_p = lu2->lua_p = (struct loopuse_a *)NULL;
	if (*p.magic_p == NMG_SHELL_MAGIC) {
		struct shell		*s;
		struct vertexuse	*vu1, *vu2;

		s = p.s;

		/* First, finish setting up the loopuses */
		lu1->up.s_p = lu2->up.s_p = s;

		lu1->lumate_p = lu2;
		lu2->lumate_p = lu1;

		RT_LIST_INSERT( &s->lu_hd, &lu1->l );
		RT_LIST_INSERT( &lu1->l, &lu2->l );

		/* Second, build the vertices */
		if ( vu1 = s->vu_p ) {
			/* Use shell's lone vertex */
			s->vu_p = (struct vertexuse *)NULL;
			vu1->up.lu_p = lu1;
			if (v) nmg_movevu(vu1, v);
		}
		else {
			if (v) vu1 = nmg_mvu(v, &lu1->l.magic);
			else vu1 = nmg_mvvu(&lu1->l.magic);
		}
		NMG_CK_VERTEXUSE(vu1);
		RT_LIST_SET_DOWN_TO_VERT(&lu1->down_hd, vu1);
		/* vu1->up.lu_p = lu1; done by nmg_mvu/nmg_mvvu */

		vu2 = nmg_mvu(vu1->v_p, &lu2->l.magic);
		NMG_CK_VERTEXUSE(vu2);
		RT_LIST_SET_DOWN_TO_VERT(&lu2->down_hd, vu2);
		/* vu2->up.lu_p = lu2; done by nmg_mvu() */
	} else if (*p.magic_p == NMG_FACEUSE_MAGIC) {
		struct vertexuse	*vu1, *vu2;

		/* First, finish setting up the loopuses */
		lu1->up.fu_p = p.fu;
		lu2->up.fu_p = p.fu->fumate_p;

		lu1->lumate_p = lu2;
		lu2->lumate_p = lu1;

		RT_LIST_INSERT( &p.fu->fumate_p->lu_hd, &lu2->l );
		RT_LIST_INSERT( &p.fu->lu_hd, &lu1->l );

		/* Second, build the vertices */
		if (v) vu1 = nmg_mvu(v, &lu1->l.magic);
		else vu1 = nmg_mvvu(&lu1->l.magic);
		RT_LIST_SET_DOWN_TO_VERT(&lu1->down_hd, vu1);
		/* vu1->up.lu_p = lu1; done by nmg_mvu/nmg_mvvu */

		vu2 = nmg_mvu(vu1->v_p, &lu2->l.magic);
		RT_LIST_SET_DOWN_TO_VERT(&lu2->down_hd, vu2);
		/* vu2->up.lu_p = lu2; done by nmg_mvu() */
	} else {
		rt_bomb("nmg_mlv() unknown parent for loopuse!\n");
	}
	lu1->orientation = lu2->orientation = orientation;

	return(lu1);
}


d1610 1
a1615 33
/*
 *			N M G _ E N S U R E _ V E R T E X
 *
 *	Ensure that this shell contains a single-vertex loop
 *	on the given vertex.
 *	If it does not, then one is created.
 */
void
nmg_ensure_vertex(v, s)
struct vertex	*v;
struct shell	*s;
{
	struct vertexuse *vu;
	struct loopuse	*lu;

	NMG_CK_VERTEX(v);
	NMG_CK_SHELL(s);

	/* try to find the vertex in a loopuse of this shell */
	for (RT_LIST_FOR(vu, vertexuse, &v->vu_hd)) {
		NMG_CK_VERTEXUSE(vu);
		if (*vu->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
		lu = vu->up.lu_p;
		NMG_CK_LOOPUSE(lu);
		if( *lu->up.magic_p != NMG_SHELL_MAGIC )  continue;
		NMG_CK_SHELL(lu->up.s_p);
		if( lu->up.s_p == s)
			return;
	}

	(void)nmg_mlv(&s->l.magic, v, OT_SAME);
}

d1645 38
d1761 33
a1821 2
	/* XXX If old_e had edge_g, should duplicate reference here */
	new_e->eg_p = (struct edge_g *)NULL;
d1824 5
a1828 1
	/* make sure the edge isn't pointing at this edgeuse */
d1880 7
a1886 1
	if (v2->vg_p) FREE_VERTEX_G(v2->vg_p);
@


10.12
log
@Added an explanatory note to nmg_demote_lu
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.11 93/03/19 01:02:33 mike Exp Locker: mike $ (BRL)";
d781 1
a781 1
				nmg_keu(RT_LIST_FIRST(edgeuse, &lu1->down_hd) );
d897 6
d904 1
a904 1
void
d910 1
a911 1
	/* prevent mishaps */
d954 1
a954 1
		if( lu1 == lu2 )  rt_bomb("nmg_keu() edgeuses on same loop\n");
d965 6
a970 2
		/* if deleting this edge would cause parent loop to become
		 * non-contiguous or if there are no more edges left in loop,
d972 1
a972 4
		 *
		 *if (eu2->vu_p->v_p != eu1->vu_p->v_p || 
		 *    !lu1->down.eu_p)
		 *	nmg_klu(lu1);
d974 5
d987 2
a990 1

d1020 1
d1039 1
a1039 1
		nmg_keu( RT_LIST_FIRST(edgeuse, &s->eu_hd) );
d1708 1
a1708 1
	nmg_keu(eu);
@


10.11
log
@Added newlines to rt_bomb() calls.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.10 93/03/18 23:20:53 mike Exp Locker: mike $ (BRL)";
d1626 1
@


10.10
log
@Made 0 length edges for nmg_edge_g() be rt_bomb(), to isolate their cause.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.9 93/03/18 15:58:17 mike Exp Locker: mike $ (BRL)";
d253 1
a253 1
		rt_bomb("nmg_mvu() Cannot build vertexuse without parent");
d402 1
a402 1
		rt_bomb("nmg_meonvu() cannot make edge, vertexuse not sole element of object");
d565 1
a565 1
			rt_bomb("nmg_ml() edgeuse mates don't have proper parent!");
d572 1
a572 1
			rt_bomb("nmg_ml");
d803 1
a803 1
		rt_bomb("nmg_klu");
d846 1
a846 1
		rt_bomb("nmg_mf() loop must be child of shell for making face");
@


10.9
log
@Reset m->maxindex when last region (but not model) is killed.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.8 93/03/10 22:25:48 mike Exp Locker: mike $ (BRL)";
d1156 3
d1190 1
@


10.8
log
@moved nmg_unglueedge(), nmg_moveeu(),
and nmg_jv() from nmg_mod.c to nmg_mk.c
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.8 93/03/02 22:14:14 mike Exp Locker: mike $ (BRL)";
d127 1
a127 2
 *	Create a new model Essentially
 *	this creates a minimal model system.
d250 3
a252 2
		rt_log("nmg_mvu() in %s at %d magic not shell, loop, or edge (%d)\n",
		    __FILE__, __LINE__, *upptr);
d1046 1
d1049 2
d1061 3
@


10.7
log
@Added routine names to all printing rt_log, rt_bomb.
@
text
@d32 2
d35 2
a36 1
 *  Author -
d38 1
d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.6 93/02/23 05:51:59 butler Exp Locker: mike $ (BRL)";
d1685 166
@


10.6
log
@removed some triple-X comments and made nmg_edge_g() create a non-zero
edge vector (with warning msg) when eg_p->e_dir is too small.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.5 1992/07/22 21:36:43 mike Exp butler $ (BRL)";
d112 1
a112 1
		rt_log("can't get model for magic=x%x (%s)\n",
d247 1
a247 1
		rt_log("in %s at %d magic not shell, loop, or edge (%d)\n",
d396 1
a396 1
		rt_log("Error in %s at %d vertexuse not for shell/loop\n", 
d566 1
a566 1
			rt_log("in %s at %d edgeuse mate not in this shell\n",
d595 1
a595 1
		rt_log("Edge(use)s do not form proper loop!\n");
d597 1
a597 1
		rt_log("Edge(use)s do not form proper loop!\n");
d797 1
a797 1
		rt_log("in %s at %d Unknown parent for loopuse\n", __FILE__,
d946 2
a947 2
			rt_log("lu1=x%x, mate=x%x\n", lu1, lu1->lumate_p);
			rt_log("lu2=x%x, mate=x%x\n", lu2, lu2->lumate_p);
d1402 1
a1402 1
		rt_log("At %d in %s shell has no children\n",
d1573 1
a1573 1
		rt_log("demoting loop\n");
d1614 1
a1614 1
		rt_bomb("loopuse mates don't have same # of edges\n");
@


10.5
log
@Improved error message.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.4 92/03/06 05:43:14 mike Exp Locker: mike $ (BRL)";
d811 4
a814 9
	/* XXX when would this not be set? */
/**	if (lu1->l_p) **/ {
		NMG_CK_LOOP(lu1->l_p);
		if (lu1->l_p->lg_p) {
			NMG_CK_LOOP_G(lu1->l_p->lg_p);
			FREE_LOOP_G(lu1->l_p->lg_p);
		}
		FREE_LOOP(lu1->l_p);
		lu1->l_p = lu2->l_p = (struct loop *)NULL;
d816 3
d943 1
a943 1
		/* XXX This may be OK for wire edges / wire loops */
d1163 4
a1166 2
	/* XXX What happens if e_dir has zero length,
	 * XXX such as when eumate_p->vu_p == eu_p->vu_p
d1168 10
@


10.4
log
@in nmg_ensure_vertex(), note that loop may be contained in a face,
as well as being a wire loop in a shell.  Needed extra check.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.3 92/02/25 00:07:11 mike Exp Locker: mike $ (BRL)";
d1239 3
a1241 1
	} else
d1243 1
@


10.3
log
@Fixed bug in nmg_edge_g(), added nmg_use_edge_g().
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 10.2 92/02/21 01:31:22 butler Exp Locker: mike $ (BRL)";
d1621 1
d1630 5
a1634 3
		NMG_CK_LOOPUSE(vu->up.lu_p);
		NMG_CK_SHELL(vu->up.lu_p->up.s_p);
		if( vu->up.lu_p->up.s_p == s)
@


10.2
log
@added nmg_edge.g to compute edge geometry from vertices
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_mk.c,v 10.1 91/10/12 06:40:47 mike Rel4_0 Locker: butler $ (BRL)";
d1149 2
a1150 2
	if (e->eg_p) {
		NMG_CK_EDGE_G(e->eg_p);
d1153 1
a1153 1
		GET_EDGE_G(eg_p, m);
d1155 1
d1165 3
d1170 13
d1184 8
d1228 1
d1352 1
a1352 2
		if (!fu->f_p->fg_p)
			nmg_face_bb(fu->f_p);
d1365 1
a1365 2
		if (!lu->l_p->lg_p)
			nmg_loop_g(lu->l_p);
@


10.1
log
@Release_4.0
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_mk.c,v 2.5 91/06/18 21:38:18 butler Exp $ (BRL)";
d1124 42
@


2.5
log
@added nmg_vertex_g() to support "hack" programs
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_mk.c,v 2.4 91/06/17 20:42:14 butler Exp $ (BRL)";
@


2.4
log
@changed function declarations so that all global functions have their
"nmg_" at the begining of the line.  Static functions have their function
names on the same line as the "static" modifier.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 2.3 91/06/13 05:42:58 mike Exp $ (BRL)";
d1077 1
d1104 19
@


2.3
log
@Order of #include
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 2.2 91/05/22 23:23:50 mike Exp $ (BRL)";
d64 2
a65 1
struct model *nmg_find_model( magic_p_arg )
d126 2
a127 1
struct model *nmg_mm()
d149 2
a150 1
struct model *nmg_mmr()
d176 2
a177 1
struct nmgregion *nmg_mrsv(m)
d204 2
a205 1
struct shell *nmg_msv(r_p)
d234 2
a235 1
struct vertexuse *nmg_mvu(v, upptr)
d268 2
a269 1
struct vertexuse *nmg_mvvu(upptr)
d306 2
a307 1
struct edgeuse *nmg_me(v1, v2, s)
d385 2
a386 1
struct edgeuse *nmg_meonvu(vu)
d493 2
a494 1
struct loopuse *nmg_ml(s)
d612 2
a613 1
void nmg_movevu(vu, v)
d639 2
a640 1
void nmg_kvu(vu)
d683 2
a684 1
void nmg_kfu(fu1)
d745 2
a746 1
void nmg_klu(lu1)
d832 2
a833 1
struct faceuse *nmg_mf(lu1)
d896 2
a897 1
void nmg_keu(eu1)
d1011 2
a1012 1
void nmg_ks(s)
d1040 2
a1041 1
void nmg_kr(r)
d1062 2
a1063 1
void nmg_km(m)
d1081 2
a1082 1
void nmg_vertex_gv(v, pt)
d1109 2
a1110 1
void nmg_loop_g(l)
d1159 2
a1160 1
void nmg_face_g(fu, p)
d1196 2
a1197 1
void nmg_face_bb(f)
d1239 2
a1240 1
void nmg_shell_a(s)
d1313 2
a1314 1
void nmg_region_a(r)
d1353 2
a1354 1
struct loopuse *nmg_mlv(magic, v, orientation)
d1464 2
a1465 1
int nmg_demote_lu(lu1)
d1529 2
a1530 1
void nmg_ensure_vertex(v, s)
d1560 2
a1561 1
int nmg_demote_eu(eu)
@


2.2
log
@Moved in nmg_ensure_vertex()
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 2.1 91/04/01 15:57:43 mike Exp $ (BRL)";
d52 1
a53 1
#include "nmg.h"
@


2.1
log
@Moved geometry modification routines from nmg_mk.c to nmg_mod.c
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.36 91/03/26 00:51:41 mike Exp $ (BRL)";
d1493 29
@


1.36
log
@Added more subroutines
@
text
@d2 1
a2 1
 *		N M G _ M K . C
d4 1
a4 1
 *	Support routines for Non-Manifold Geometry
d30 1
a30 4
 *	the "magic" member of each struct is the first item.  In this
 *		way, we can have routines work with diferent kinds of
 *		structs (by passing around pointers to the magic number)
 *		and still keep lint happy
d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.35 91/02/27 18:37:53 mike Exp $ (BRL)";
d225 2
a226 1
/*	N M G _ M V U
d258 2
a259 1
/*	N M G _ M V V U
a371 36
 *			N M G _ C K _ L I S T
 *
 *  Generic list checker.
 */
void
nmg_ck_list( hd, str )
struct rt_list	*hd;
char		*str;
{
	struct rt_list	*cur;
	int	head_count = 0;

	cur = hd;
	do  {
		if( cur->magic == RT_LIST_HEAD_MAGIC )  head_count++;
		if( cur->forw->back != cur )  {
			rt_log("nmg_ck_list(%s) cur=x%x, cur->forw=x%x, cur->forw->back=x%x\n",
				str, cur, cur->forw, cur->forw->back );
			rt_bomb("nmg_ck_list() forw\n");
		}
		if( cur->back->forw != cur )  {
			rt_log("nmg_ck_list(%s) cur=x%x, cur->back=x%x, cur->back->forw=x%x\n",
				str, cur, cur->back, cur->back->forw );
			rt_bomb("nmg_ck_list() back\n");
		}
		cur = cur->forw;
	} while( cur != hd );

	if( head_count != 1 )  {
		rt_log("nmg_ck_list(%s) head_count = %d\n", head_count);
		rt_bomb("headless!\n");
	}
}


/*
d465 1
a465 1
/*	N M G _ M L
d598 2
a599 1
/*	N M G _ M O V E V U
d624 2
a625 1
/*	N M G _ K V U
d663 2
a664 1
/*	N M G _ K F U
d722 2
a723 1
/*	N M G _ K L U
d991 1
a991 1
/*	N M G _ K S
d1019 2
a1020 1
/*	N M G _ K R
d1040 2
a1041 1
/*	N M G _ K M
d1058 2
a1059 1
/*	N M G _ V E R T E X _ G V
d1085 2
a1086 1
/*	N M G _ L O O P _ G
d1134 2
a1135 1
/*	N M G _ F A C E _ G
d1170 2
a1171 1
/*	N M G _ F A C E _ B B
d1212 2
a1213 1
/*	N M G _ S H E L L _ A
d1285 1
a1285 1
/*	N M G _ R E G I O N _ A
a1317 405
 *			N M G _ E U S P L I T
 *
 *	Split an edgeuse by inserting a vertex into middle of the edgeuse.
 *
 *	Make a new edge, and a vertex.  If v is non-null it is taken as a
 *	pointer to an existing vertex to use as the start of the new edge.
 *	If v is null, then a new vertex is created for the begining of the
 *	new edge.
 *
 *	In either case, the new edge will exist as the "next" edge after
 *	the edge passed as a parameter.
 *
 *  List on entry -
 *
 *		       oldeu
 *		  .------------->
 *		 /
 *		A =============== B (edge)
 *				 /
 *		  <-------------.
 *		      oldeumate
 *
 *  List on return -
 *
 *		     oldeu(cw)    eu1
 *		    .------->   .----->
 *		   /           /
 *	   (edge) A ========= V ~~~~~~~ B (new edge)
 *			     /         /
 *		    <-------.   <-----.
 *		       mate	 mate
 */
struct edgeuse *nmg_eusplit(v, oldeu)
struct vertex *v;
struct edgeuse *oldeu;
{
	struct edgeuse	*eu1,
			*eu2,
			*oldeumate;
	struct shell *s;
	struct loopuse	*lu;

	NMG_CK_EDGEUSE(oldeu);
	if (v) {
		NMG_CK_VERTEX(v);
	}
	oldeumate = oldeu->eumate_p;
	NMG_CK_EDGEUSE( oldeumate );

	/* if this edge has uses other than this edge and its mate, we must
	 * separate these two edgeuses from the existing edge, and create
	 * a new edge for them.  Then we can insert a new vertex in this
	 * new edge without fear of damaging some other object.
	 */
	if (oldeu->radial_p != oldeumate)
		nmg_unglueedge(oldeu);

	if (*oldeu->up.magic_p == NMG_SHELL_MAGIC) {
		s = oldeu->up.s_p;
		NMG_CK_SHELL(s);

		/*
		 *  Make an edge from the new vertex ("V") to vertex at
		 *  other end of the edge given ("B").
		 *  The new vertex "V" may be NULL, which will cause the
		 *  shell's lone vertex to be used, or a new one obtained.
		 *  New edges will be placed at head of shell's edge list.
		 */
		eu1 = nmg_me(v, oldeumate->vu_p->v_p, s);
		eu2 = eu1->eumate_p;

		/*
		 *  The situation is now:
		 *
		 *      eu1			       oldeu
		 *  .----------->		  .------------->
		 * /				 /
		 *V ~~~~~~~~~~~~~ B (new edge)	A =============== B (edge)
		 *		 /				 /
		 *  <-----------.		  <-------------.
		 *      eu2			      oldeumate
		 */

		/* Make oldeumate start at "V", not "B" */
		nmg_movevu(oldeumate->vu_p, eu1->vu_p->v_p);

		/*
		 *  Enforce rigid ordering in shell's edge list:
		 *	oldeu, oldeumate, eu1, eu2
		 *  This is to keep edges & mates "close to each other".
		 */
		if( RT_LIST_PNEXT(edgeuse, oldeu) != oldeumate )  {
			RT_LIST_DEQUEUE( &oldeumate->l );
			RT_LIST_APPEND( &oldeu->l, &oldeumate->l );
		}
		RT_LIST_DEQUEUE( &eu1->l );
		RT_LIST_DEQUEUE( &eu2->l );
		RT_LIST_APPEND( &oldeumate->l, &eu1->l );
		RT_LIST_APPEND( &eu1->l, &eu2->l );

		/*
		 *	     oldeu(cw)    eu1
		 *	    .------->   .----->
		 *	   /           /
		 * (edge) A ========= V ~~~~~~~ B (new edge)
		 *		     /         /
		 *	    <-------.   <-----.
		 *	    oldeumate     eu2
		 */
		return(eu1);
	}
	else if (*oldeu->up.magic_p != NMG_LOOPUSE_MAGIC) {
		rt_log("in %s at %d invalid edgeuse parent\n",
			__FILE__, __LINE__);
		rt_bomb("nmg_eusplit");
	}

	/* now we know we are in a loop */

	lu = oldeu->up.lu_p;
	NMG_CK_LOOPUSE(lu);

	/* get a parent shell pointer so we can make a new edge */
	if (*lu->up.magic_p == NMG_SHELL_MAGIC)
		s = lu->up.s_p;
	else if (*lu->up.magic_p == NMG_FACEUSE_MAGIC)
		s = lu->up.fu_p->s_p;
	else
		rt_bomb("nmg_eusplit() bad lu->up\n");
	NMG_CK_SHELL(s);

	nmg_ck_list( &s->eu_hd, "eusplit A" );
	nmg_ck_list( &s->lu_hd, "eusplit lu A" );

	/* make a new edge on the vertex */
	if (v) {
		/* An edge on the single vertex "V" */
		eu1 = nmg_me(v, v, s);
		eu2 = eu1->eumate_p;
	} else {
		/* An edge between two new vertices */
		nmg_ck_list( &s->eu_hd, "eusplit B" );
		nmg_ck_list( &s->lu_hd, "eusplit lu B" );
		eu1 = nmg_me((struct vertex *)NULL, (struct vertex *)NULL, s);
		eu2 = eu1->eumate_p;
		/* Make both ends of edge use same vertex.
		 * The second vertex is freed automaticly.
		 */
		nmg_movevu(eu2->vu_p, eu1->vu_p->v_p);
	}

	/*
	 *  The current situation is now:
	 *
	 *	      eu1			       oldeu
	 *	  .------------->		  .------------->
	 *	 /				 /
	 *	V ~~~~~~~~~~~~~~~ V (new edge)	A =============== B (edge)
	 *			 /				 /
	 *	  <-------------.		  <-------------.
	 *	      eu2			      oldeumate
	 *
	 *  Goals:
	 *  eu1 will become the mate to oldeumate on the existing edge.
	 *  eu2 will become the mate of oldeu on the new edge.
	 */
	RT_LIST_DEQUEUE( &eu1->l );
	RT_LIST_DEQUEUE( &eu2->l );
	RT_LIST_APPEND( &oldeu->l, &eu1->l );
	RT_LIST_APPEND( &oldeumate->l, &eu2->l );

	/*
	 *  The situation is now:
	 *
	 *		       oldeu      eu1			>>>loop>>>
	 *		    .------->   .----->
	 *		   /           /
	 *	   (edge) A ========= V ~~~~~~~ B (new edge)
	 *			     /         /
	 *		    <-------.   <-----.	
	 *		       eu2      oldeumate		<<<loop<<<
	 */

	/* Copy parentage (loop affiliation) and orientation */
	eu1->up.magic_p = oldeu->up.magic_p;
	eu1->orientation = oldeu->orientation;
	eu1->eua_p = (struct edgeuse_a *)NULL;

	eu2->up.magic_p = oldeumate->up.magic_p;
	eu2->orientation = oldeumate->orientation;
	eu2->eua_p = (struct edgeuse_a *)NULL;

	/* Build mate relationship */
	eu1->eumate_p = oldeumate;
	oldeumate->eumate_p = eu1;
	eu2->eumate_p = oldeu;
	oldeu->eumate_p = eu2;

	/* Build radial relationship */
	eu1->radial_p = oldeumate;
	oldeumate->radial_p = eu1;
	eu2->radial_p = oldeu;
	oldeu->radial_p = eu2;

	/* Associate oldeumate with new edge, and eu2 with old edge. */
	oldeumate->e_p = eu1->e_p;
	eu2->e_p = oldeu->e_p;

	return(eu1);
}

/*
 *			N M G _ M O V E E U
 *
 *	Move a pair of edgeuses onto a new edge (glue edgeuse).
 *	the edgeuse eusrc and its mate are moved to the edge
 *	used by eudst.  eusrc is made to be immediately radial to eudst.
 *	if eusrc does not share the same vertices as eudst, we bomb.
 */
void nmg_moveeu(eudst, eusrc)
struct edgeuse *eudst, *eusrc;
{
	struct edgeuse	*eudst_mate;
	struct edgeuse	*eusrc_mate;
	struct edge	*e;

	NMG_CK_EDGEUSE(eudst);
	NMG_CK_EDGEUSE(eusrc);
	eudst_mate = eudst->eumate_p;
	eusrc_mate = eusrc->eumate_p;
	NMG_CK_EDGEUSE(eudst_mate);
	NMG_CK_EDGEUSE(eusrc_mate);

	/* protect the morons from themselves.  Don't let them
	 * move an edgeuse to itself or it's mate
	 */
	if (eusrc == eudst || eusrc_mate == eudst)  {
		rt_log("nmg_moveeu() moving edgeuse to itself\n");
		return;
	}

	if (eusrc->e_p == eudst->e_p &&
	    (eusrc->radial_p == eudst || eudst->radial_p == eusrc))  {
	    	rt_log("nmg_moveeu() edgeuses already share edge\n");
		return;
	}

	/* make sure vertices are shared */
	if ( ! ( (eudst_mate->vu_p->v_p == eusrc->vu_p->v_p &&
	    eudst->vu_p->v_p == eusrc_mate->vu_p->v_p) ||
	    (eudst->vu_p->v_p == eusrc->vu_p->v_p &&
	    eudst_mate->vu_p->v_p == eusrc_mate->vu_p->v_p) ) ) {
		/* edgeuses do NOT share verticies. */
	    	VPRINT("eusrc", eusrc->vu_p->v_p->vg_p->coord);
	    	VPRINT("eusrc_mate", eusrc_mate->vu_p->v_p->vg_p->coord);
	    	VPRINT("eudst", eudst->vu_p->v_p->vg_p->coord);
	    	VPRINT("eudst_mate", eudst_mate->vu_p->v_p->vg_p->coord);
	    	rt_bomb("nmg_moveeu() edgeuses do not share vertices, cannot share edge\n");
	}

	e = eusrc->e_p;
	eusrc_mate->e_p = eusrc->e_p = eudst->e_p;

	/* if we're not deleting the edge, make sure it will be able
	 * to reference the remaining uses, otherwise, take care of disposing
	 * of the (now unused) edge
	 */
	if (eusrc->radial_p != eusrc_mate) {
		/* this is NOT the only use of the eusrc edge! */
		if (e->eu_p == eusrc || e->eu_p == eusrc_mate)
			e->eu_p = eusrc->radial_p;

		/* disconnect from the list of uses of this edge */
		eusrc->radial_p->radial_p = eusrc_mate->radial_p;
		eusrc_mate->radial_p->radial_p = eusrc->radial_p;
	} else {
		/* this is the only use of the eusrc edge */
		if (e->eg_p) FREE_EDGE_G(e->eg_p);
		FREE_EDGE(e);
	}

	eusrc->radial_p = eudst;
	eusrc_mate->radial_p = eudst->radial_p;

	eudst->radial_p->radial_p = eusrc_mate;
	eudst->radial_p = eusrc;
}

/*			N M G _ U N G L U E E D G E
 *
 *	If edgeuse is part of a shared edge (more than one pair of edgeuses
 *	on the edge), it and its mate are "unglued" from the edge, and 
 *	associated with a new edge structure.
 */
void nmg_unglueedge(eu)
struct edgeuse *eu;
{
#if UNGLUE_MAKES_VERTICES
	struct vertex *v1, *v2;
	struct vertex_g *vg1, *vg2;
#endif
	struct edge	*e;
	struct model	*m;

	NMG_CK_EDGEUSE(eu);

	/* if we're already a single edge, just return */
	if (eu->radial_p == eu->eumate_p)
		return;

	m = nmg_find_model( &eu->l.magic );
	GET_EDGE(e, m);

	e->magic = NMG_EDGE_MAGIC;
	e->eg_p = (struct edge_g *)NULL;
	e->eu_p = eu;
#if UNGLUE_MAKES_VERTICES
	GET_VERTEX(v1, m);
	GET_VERTEX(v2, m);
	GET_VERTEX_G(vg1, m);
	GET_VERTEX_G(vg2, m);

	/* we want a pair of new vertices that are identical to the old
	 * ones for the newly separated edge.
	 */
	v1->vu_p = v2->vu_p = (struct vertexuse *)NULL;
	v1->magic = v2->magic = NMG_VERTEX_MAGIC;

	/* if there was vertex geometry, copy it */
	if (eu->vu_p->v_p->vg_p) {
		*vg1 = *(eu->vu_p->v_p->vg_p);	/* struct copy */
		v1->vg_p = vg1;
	} else {
		v1->vg_p = (struct vertex_g *)NULL;
		FREE_VERTEX_G(vg1);
	}

	if (eu->eumate_p->vu_p->v_p->vg_p) {
		*vg2 = *(eu->eumate_p->vu_p->v_p->vg_p);	/* struct copy */
		v2->vg_p = vg2;
	} else {
		v2->vg_p = (struct vertex_g *)NULL;
		FREE_VERTEX_G(vg2);
	}

	/* now move the vertexuses to the new (but identical) verteces. */
	nmg_movevu(eu->vu_p, v1);
	nmg_movevu(eu->eumate_p->vu_p, v1);
#endif

	/* make sure the edge isn't pointing at this edgeuse */
	if (eu->e_p->eu_p == eu || eu->e_p->eu_p == eu->eumate_p ) {
		eu->e_p->eu_p = eu->e_p->eu_p->radial_p;
	}

	/* unlink edgeuses from old edge */
	eu->radial_p->radial_p = eu->eumate_p->radial_p;
	eu->eumate_p->radial_p->radial_p = eu->radial_p;
	eu->eumate_p->radial_p = eu;
	eu->radial_p = eu->eumate_p;

	eu->eumate_p->e_p = eu->e_p = e;

}

/*
 *			N M G _ J V
 *
 *	Join two vertexes into one.
 *	v1 inherits all the vertexuses presently pointing to v2,
 *	and v2 is then destroyed.
 */
void nmg_jv(v1, v2)
register struct vertex	*v1;
register struct vertex	*v2;
{
	register struct vertexuse	*vu;

	NMG_CK_VERTEX(v1);
	NMG_CK_VERTEX(v2);

	if (v1 == v2) return;

	/*
	 *  Walk the v2 list, unlinking vertexuse structs,
	 *  and adding them to the *end* of the v1 list
	 *  (which preserves relative ordering).
	 */
	vu = RT_LIST_FIRST(vertexuse, &v2->vu_hd );
	while( RT_LIST_NOT_HEAD( vu, &v2->vu_hd ) )  {
		register struct vertexuse	*vunext;

		NMG_CK_VERTEXUSE(vu);
		vunext = RT_LIST_PNEXT(vertexuse, vu);
		RT_LIST_DEQUEUE( &vu->l );
		RT_LIST_INSERT( &v1->vu_hd, &vu->l );
		vu->v_p = v1;		/* "up" to new vertex */
		vu = vunext;
	}

	if (v2->vg_p) FREE_VERTEX_G(v2->vg_p);
	FREE_VERTEX(v2);
}

/*
a1428 10
/*
 *			N M G _ M O V E L T O F
 *
 *	move first pair of shell loopuses to an existing face
 */
void nmg_moveltof(fu, s)
struct faceuse *fu;
struct shell *s;
{
	struct loopuse	*lu1, *lu2;
d1430 1
a1430 20
	NMG_CK_SHELL(s);
	NMG_CK_FACEUSE(fu);
	if (fu->s_p != s) {
		rt_log("in %s at %d Cannot move loop to face in another shell\n",
		    __FILE__, __LINE__);
	}
	lu1 = RT_LIST_FIRST(loopuse, &s->lu_hd);
	NMG_CK_LOOPUSE(lu1);
	RT_LIST_DEQUEUE( &lu1->l );

	lu2 = RT_LIST_FIRST(loopuse, &s->lu_hd);
	NMG_CK_LOOPUSE(lu2);
	RT_LIST_DEQUEUE( &lu2->l );

	RT_LIST_APPEND( &fu->lu_hd, &lu1->l );
	RT_LIST_APPEND( &fu->fumate_p->lu_hd, &lu2->l );
}

/*
 *			N M G _ C F A C E
a1431 833
 *	Create a face from a list of vertices
 *
 *	"verts" is an array of "n" pointers to (struct vertex).  "s" is the
 *	parent shell for the new face.  The face will consist of a single loop
 *	made from edges between the n vertices.
 *
 *	If verts is a null pointer (no vertex list), all vertices of the face
 *	will be new points.  Otherwise, verts is a pointer to a list of
 *	vertices to use in creating the face/loop.  Null entries within the
 *	list will cause a new vertex to be created for that point.  Such new
 *	vertices will be inserted into the list for return to the caller.
 *
 *	The vertices should be listed in "clockwise" order if this is
 *	an ordinary face, and in "counterclockwise" order if this is
 *	an interior ("hole" or "subtracted") face.
 *	See the comments in nmg_cmface() for more details.
 *
 *	Note that this routine inserts new vertices (by edge use splitting)
 *	at the head of the loop, which reverses the order.
 *	Therefore, the callers vertices are inserted in reverse order,
 *	to effect the proper vertex order in the final face loop.
 */
struct faceuse *nmg_cface(s, verts, n)
struct shell *s;
struct vertex *verts[];
int n;
{
	struct faceuse *fu;
	struct edgeuse *eu;
	struct loopuse	*lu;
	struct vertexuse *vu;
	int i;

	NMG_CK_SHELL(s);
	if (n < 1) {
		rt_log("nmg_cface(s=x%x, verts=x%x, n=%d.)\n",
			s, verts, n );
		rt_bomb("nmg_cface() trying to make bogus face\n");
	}

	if (verts) {
		lu = nmg_mlv(&s->l.magic, verts[n-1], OT_SAME);
		fu = nmg_mf(lu);
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
		eu = nmg_meonvu(vu);

		if (!verts[n-1])
			verts[n-1] = eu->vu_p->v_p;

		for (i = n-2 ; i >= 0 ; i--) {
			eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
			eu = nmg_eusplit(verts[i], eu);
			if (!verts[i])
				verts[i] = eu->vu_p->v_p;
		}

	} else {
		lu = nmg_mlv(&s->l.magic, (struct vertex *)NULL, OT_SAME);
		fu = nmg_mf(lu);
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
		eu = nmg_meonvu(vu);
		while (--n) {
			(void)nmg_eusplit((struct vertex *)NULL, eu);
		}
	}
	return (fu);
}

/*
 *			N M G _ E S P L I T
 *
 *	Split an edge.
 *
 *	Actually, we split each edgeuse pair of the given edge, and combine
 *	the new edgeuses together onto new edges.  
 *
 *	Explicit return:
 *		pointer to the new edge which took the place of the parameter
 *	edge.
 */
struct edge *nmg_esplit(v, e)
struct vertex *v;
struct edge *e;
{
	struct edgeuse	*eu,	/* placeholder edgeuse */
			*eur,	/* radial edgeuse of placeholder */
			*eu2,	/* new edgeuse (next of eur) */
			*neu1, *neu2; /* new (split) edgeuses */
	int 		notdone=1;
	struct vertex	*v1, *v2;

	eu = e->eu_p;
	neu1 = neu2 = (struct edgeuse *)NULL;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEX(eu->vu_p->v_p);
	v1 = eu->vu_p->v_p;

	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
	v2 = eu->eumate_p->vu_p->v_p;

	/* one at a time, we peel out & split an edgeuse pair of this edge.
	 * when we split an edge that didn't need to be peeled out, we know
	 * we've split the last edge
	 */
	do {
		eur = eu->radial_p;
		eu2 = nmg_eusplit(v, eur);
		NMG_CK_EDGEUSE(eur);
		NMG_CK_EDGEUSE(eu2);
		NMG_TEST_EDGEUSE(eur);
		NMG_TEST_EDGEUSE(eu2);
		
		if (!v) v = eu2->vu_p->v_p;

		if (eu2->e_p == e || eur->e_p == e) notdone = 0;

		
		if (eur->vu_p->v_p == v1) {
			if (neu1) {
				nmg_moveeu(neu1, eur);
				nmg_moveeu(neu2, eu2);
			}
			neu1 = eur->eumate_p;
			neu2 = eu2->eumate_p;
		} else if (eur->vu_p->v_p == v2) {
			if (neu1) {
				nmg_moveeu(neu2, eur);
				nmg_moveeu(neu1, eu2);
			}
			neu2 = eur->eumate_p;
			neu1 = eu2->eumate_p;
		} else {
			rt_log("in %s at %d ", __FILE__, __LINE__);
			rt_bomb("nmg_esplit() Something's awry\n");
		}
	} while (notdone);

	eu = neu1;
	do {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGEUSE(eu->eumate_p);
		NMG_TEST_EDGEUSE(eu);
		NMG_TEST_EDGEUSE(eu->eumate_p);

		eu = eu->radial_p->eumate_p;
	} while (eu != neu1);
	eu = neu2;
	do {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGEUSE(eu->eumate_p);
		NMG_TEST_EDGEUSE(eu);
		NMG_TEST_EDGEUSE(eu->eumate_p);

		eu = eu->radial_p->eumate_p;
	} while (eu != neu2);


	return(eu->e_p);
}

/*
 *				N M G _ E I N S
 *
 *	Insert a new (zero length) edge at the begining of (ie, before)
 *	an existing edgeuse
 *	Perhaps this is what nmg_esplit and nmg_eusplit should have been like?
 *
 *	Before:
 *	.--A--> .--eu-->
 *		 \
 *		  >.
 *		 /
 *	  <-A'--. <-eu'-.
 *
 *
 *	After:
 *
 *               eu1     eu
 *	.--A--> .---> .--eu-->
 *		 \   /
 *		  >.<
 *		 /   \
 *	  <-A'--. <---. <-eu'--.
 *	          eu2     eumate
 */
struct edgeuse *nmg_eins(eu)
struct edgeuse *eu;
{
	struct edgeuse	*eumate;
	struct edgeuse	*eu1, *eu2;
	struct shell	*s;

	NMG_CK_EDGEUSE(eu);
	eumate = eu->eumate_p;
	NMG_CK_EDGEUSE(eumate);

	if (*eu->up.magic_p == NMG_SHELL_MAGIC) {
		s = eu->up.s_p;
		NMG_CK_SHELL(s);
	}
	else {
		struct loopuse *lu;
		
		lu = eu->up.lu_p;
		NMG_CK_LOOPUSE(lu);
		if (*lu->up.magic_p == NMG_SHELL_MAGIC) {
			s = lu->up.s_p;
			NMG_CK_SHELL(s);
		} else {
			struct faceuse *fu;
			fu = lu->up.fu_p;
			NMG_CK_FACEUSE(fu);
			s = fu->s_p;
			NMG_CK_SHELL(s);
		}
	}

	eu1 = nmg_me(eu->vu_p->v_p, eu->vu_p->v_p, s);
	eu2 = eu1->eumate_p;

	if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC) {
		RT_LIST_DEQUEUE( &eu1->l );
		RT_LIST_DEQUEUE( &eu2->l );

		RT_LIST_INSERT( &eu->l, &eu1->l );
		RT_LIST_APPEND( &eumate->l, &eu2->l );

		eu1->up.lu_p = eu->up.lu_p;
		eu2->up.lu_p = eumate->up.lu_p;
	}
	else {
		rt_bomb("nmg_eins() Cannot yet insert null edge in shell\n");
	}
	return(eu1);
}

/*
 *			F I N D _ V U _ I N _ F A C E
 *
 *	try to find a vertex(use) in a face wich appoximately matches the
 *	coordinates given.  
 *	
 */
struct vertexuse *nmg_find_vu_in_face(pt, fu, tol)
point_t		pt;
struct faceuse	*fu;
fastf_t		tol;
{
	register struct loopuse	*lu;
	struct edgeuse		*eu;
	vect_t			delta;
	register pointp_t	pp;
	int			magic1;

	NMG_CK_FACEUSE(fu);

	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
		if (magic1 == NMG_VERTEXUSE_MAGIC) {
			struct vertexuse	*vu;
			vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
			pp = vu->v_p->vg_p->coord;
			VSUB2(delta, pp, pt);
			if ( MAGSQ(delta) < tol)
				return(vu);
		}
		else if (magic1 == NMG_EDGEUSE_MAGIC) {
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
				pp = eu->vu_p->v_p->vg_p->coord;
				VSUB2(delta, pp, pt);
				if ( MAGSQ(delta) < tol)
					return(eu->vu_p);
			}
		} else
			rt_bomb("nmg_find_vu_in_face() Bogus child of loop\n");
	}
	return ((struct vertexuse *)NULL);
}

/*
 *			N M G _ G L U E F A C E S
 *
 *	given a shell containing "n" faces whose outward oriented faceuses are
 *	enumerated in "fulist", glue the edges of the faces together
 *
 */
void
nmg_gluefaces(fulist, n)
struct faceuse *fulist[];
int n;
{
	struct shell	*s;
	struct loopuse	*lu;
	struct edgeuse	*eu;
	int		i;
	int		f_no;		/* Face number */
	
	NMG_CK_FACEUSE(fulist[0]);
	s = fulist[0]->s_p;
	NMG_CK_SHELL(s);

	/* First, perform some checks */
	for (i = 0 ; i < n ; ++i) {
		register struct faceuse	*fu;

		fu = fulist[i];
		NMG_CK_FACEUSE(fu);
		if (fu->s_p != s) {
			rt_log("in %s at %d faceuses don't share parent\n",
				__FILE__, __LINE__);
			rt_bomb("nmg_gluefaces\n");
		}
		lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
		NMG_CK_LOOPUSE(lu);
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC) {
			/* Not an edgeuse, probably a vertexuse */
			rt_bomb("nmg_cluefaces() Cannot glue edges of face on vertex\n");
		} else {
			eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
			NMG_CK_EDGEUSE(eu);
		}
	}

	for (i=0 ; i < n ; ++i) {
		lu = RT_LIST_FIRST( loopuse, &fulist[i]->lu_hd );
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			for( f_no = i+1; f_no < n; f_no++ )  {
				struct loopuse		*lu2;
				register struct edgeuse	*eu2;

				if( eu->radial_p != eu->eumate_p )  break;

				lu2 = RT_LIST_FIRST(loopuse,
					&fulist[f_no]->lu_hd);
				for( RT_LIST_FOR( eu2, edgeuse, &lu2->down_hd ) )  {
					if (EDGESADJ(eu, eu2))
					    	nmg_moveeu(eu, eu2);
				}
			}
		}
	}
}


/*
 *			N M G _ F I N D E U
 *
 *	find an edgeuse in a shell between a pair of verticies
 */
struct edgeuse *nmg_findeu(v1, v2, s, eup)
struct vertex *v1, *v2;
struct shell *s;
struct edgeuse *eup;
{
	register struct vertexuse	*vu;
	register struct edgeuse		*eu;

	NMG_CK_VERTEX(v1);
	NMG_CK_VERTEX(v2);
	NMG_CK_SHELL(s);

	if (rt_g.NMG_debug & DEBUG_FINDEU)
		rt_log("looking for edge between %8x and %8x other than %8x/%8x\n",
		v1, v2, eup, eup->eumate_p);

	for( RT_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);
		if (!vu->up.magic_p) {
			rt_log("in %s at %d vertexuse has null parent\n",
				__FILE__, __LINE__);
			rt_bomb("nmg_findeu");
		}

		if (*vu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;

		if (rt_g.NMG_debug & DEBUG_FINDEU )  {
			rt_log("checking edgeuse %8x vertex pair (%8x, %8x)\n",
				vu->up.eu_p, vu->up.eu_p->vu_p->v_p,
				vu->up.eu_p->eumate_p->vu_p->v_p);
		}

		/* look for an edgeuse pair (other than the one we have)
		 * on the vertices we want
		 * the edgeuse pair should be a dangling edge
		 */
		eu = vu->up.eu_p;
		if( eu != eup && eu->eumate_p != eup &&
		    eu->eumate_p->vu_p->v_p == v2  &&
		    eu->eumate_p == eu->radial_p) {

		    	/* if the edgeuse we have found is a part of a face
		    	 * in the proper shell, we've found what we're looking
		    	 * for.
		    	 */
			if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
			    *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
			    eu->up.lu_p->up.fu_p->s_p == s) {

			    	if (rt_g.NMG_debug & DEBUG_FINDEU)
				    	rt_log("Found %8x/%8x\n",
				    		eu, eu->eumate_p);

			    	if (eup->up.lu_p->up.fu_p->orientation ==
			    	    eu->up.lu_p->up.fu_p->orientation)
				    	return(eu);
			    	else
			    		return(eu->eumate_p);
			    }
		    	else
		    		if (rt_g.NMG_debug & DEBUG_FINDEU)
		    		rt_log("ignoring an edge because it has wrong parent\n");

		}
	}

	if (rt_g.NMG_debug & DEBUG_FINDEU)
	    	rt_log("nmg_findeu search failed\n");

	return((struct edgeuse *)NULL);
}

/*
 *			N M G _ C M F A C E
 *
 *	Create a face for a manifold shell from a list of vertices
 *
 *	"verts" is an array of "n" pointers to pointers to (struct vertex).
 *	"s" is the parent shell for the new face.
 *	The face will consist of a single loop
 *	made from edges between the n vertices.  Before an edge is created
 *	between a pair of verticies, we check to see if there is already an
 *	edge with a single use-pair (in this shell) between the two verticies.
 *	If such an edge can be found, the newly created edge will "use-share"
 *	the existing edge.  This greatly facilitates the construction of
 *	manifold shells from a series of points/faces.
 *
 *	If a pointer in verts is a pointer to a null vertex pointer, a new
 *	vertex is created.  In this way, new verticies can be created
 *	conveniently within a user's list of known verticies
 *
 *	verts		pointers to struct vertex	    vertex structs
 *
 *	-------		--------
 *   0	|  +--|-------->|   +--|--------------------------> (struct vertex)
 *	-------		--------	---------
 *   1	|  +--|------------------------>|   +---|---------> (struct vertex)
 *	-------		--------	---------
 *   2	|  +--|-------->|   +--|--------------------------> (struct vertex)
 *	-------		--------
 *  ...
 *	-------				---------
 *   n	|  +--|------------------------>|   +---|---------> (struct vertex)
 *	-------				---------
 *
 *
 *	The vertices should be listed in "clockwise" order if this is
 *	an ordinary face, and in "counterclockwise" order if this is
 *	an interior ("hole" or "subtracted") face.
 *	Note that while this routine makes only topology, without
 *	reference to geometry, by following the clockwise rule,
 *	finding the surface normal
 *	of ordinary faces can be done using the following procedure.
 *
 *
 *			C                   D
 *	                *-------------------*
 *	                |                   |
 *	                |   ^...........>   |
 *	   ^     N      |   .           .   |
 *	   |      \     |   .           .   |
 *	   |       \    |   . clockwise .   |
 *	   |C-B     \   |   .           .   |
 *	   |         \  |   .           v   |
 *	   |          \ |   <............   |
 *	               \|                   |
 *	                *-------------------*
 *	                B                   A
 *			       ----->
 *				A-B
 *
 *	If the points are given in the order A B C D (eg, clockwise),
 *	then the outward pointing surface normal N = (A-B) x (C-B).
 *	This is the "right hand rule".
 *
 *	Note that this routine inserts new vertices (by edge use splitting)
 *	at the head of the loop, which reverses the order.
 *	Therefore, the callers vertices are inserted in reverse order,
 *	to effect the proper vertex order in the final face loop.
 */
struct faceuse *nmg_cmface(s, verts, n)
struct shell	*s;
struct vertex	**verts[];
int		n;
{
	struct faceuse *fu;
	struct edgeuse *eu, *eur, *euold;
	struct loopuse	*lu;
	struct vertexuse	*vu;
	int i;

	NMG_CK_SHELL(s);

	if (n < 1) {
		rt_log("nmg_cmface(s=x%x, verts=x%x, n=%d.)\n",
			s, verts, n );
		rt_bomb("nmg_cmface() trying to make bogus face\n");
	}

	/* make sure verts points to some real storage */
	if (!verts) {
		rt_log("nmg_cmface(s=x%x, verts=x%x, n=%d.) null pointer to array start\n",
			s, verts, n );
		rt_bomb("nmg_cmface\n");
	}

	/* validate each of the pointers in verts */
	for (i=0 ; i < n ; ++i) {
		if (verts[i]) {
			if (*verts[i]) {
				/* validate the vertex pointer */
				NMG_CK_VERTEX(*verts[i]);
			}
		} else {
			rt_log("nmg_cmface(s=x%x, verts=x%x, n=%d.) verts[%d]=NULL\n",
				s, verts, n, i );
			rt_bomb("nmg_cmface\n");
		}
	}

	lu = nmg_mlv(&s->l.magic, *verts[n-1], OT_SAME);
	fu = nmg_mf(lu);
	fu->orientation = OT_SAME;
	fu->fumate_p->orientation = OT_OPPOSITE;
	vu = RT_LIST_FIRST( vertexuse, &lu->down_hd);
	NMG_CK_VERTEXUSE(vu);
	eu = nmg_meonvu(vu);
	NMG_CK_EDGEUSE(eu);

	if (!(*verts[n-1]))  {
		NMG_CK_VERTEXUSE(eu->vu_p);
		NMG_CK_VERTEX(eu->vu_p->v_p);
		*verts[n-1] = eu->vu_p->v_p;
	}

	for (i = n-2 ; i >= 0 ; i--) {
		lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
		NMG_CK_LOOPUSE(lu);
		euold = RT_LIST_FIRST( edgeuse, &lu->down_hd );
		NMG_CK_EDGEUSE(euold);

		if (rt_g.NMG_debug & DEBUG_CMFACE)
			rt_log("euold: %8x\n", euold);

		/* look for pre-existing edge between these
		 * verticies
		 */
		if (*verts[i]) {
			/* look for an existing edge to share */
			eur = nmg_findeu(*verts[i+1], *verts[i], s, euold);
			eu = nmg_eusplit(*verts[i], euold);
			if (eur) {
				nmg_moveeu(eur, eu);

				if (rt_g.NMG_debug & DEBUG_CMFACE)
				rt_log("found another edgeuse (%8x) between %8x and %8x\n",
					eur, *verts[i+1], *verts[i]);
			}
			else {
				if (rt_g.NMG_debug & DEBUG_CMFACE)
				    rt_log("didn't find edge from verts[%d]%8x to verts[%d]%8x\n",
					i+1, *verts[i+1], i, *verts[i]);
			}
		} else {
			if (rt_g.NMG_debug & DEBUG_CMFACE)
				rt_log("*verts[%d] is null\t", i);

			eu = nmg_eusplit(*verts[i], euold);
			*verts[i] = eu->vu_p->v_p;

			if (rt_g.NMG_debug & DEBUG_CMFACE)
			rt_log("*verts[%d] is now %8x\n", i, *verts[i]);
		}
	}

	if (eur = nmg_findeu(*verts[n-1], *verts[0], s, euold))
		nmg_moveeu(eur, euold);
	else 
	    if (rt_g.NMG_debug & DEBUG_CMFACE)
		rt_log("didn't find edge from verts[%d]%8x to verts[%d]%8x\n",
			n-1, *verts[n-1], 0, *verts[0]);

	return (fu);
}


/*	N M G _ J L
 *
 *	Join two loops together which share a common edge
 *
 */
void nmg_jl(lu, eu)
struct loopuse *lu;
struct edgeuse *eu;
{
	struct edgeuse *eu_r, *nexteu;
	NMG_CK_LOOPUSE(lu);

	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_EDGEUSE(eu->radial_p);
	NMG_CK_EDGEUSE(eu->radial_p->eumate_p);

	if (eu->up.lu_p != lu)
		rt_bomb("nmg_jl: edgeuse is not child of loopuse?\n");

	eu_r = eu->radial_p;
	if (*eu_r->up.magic_p != NMG_LOOPUSE_MAGIC)
		rt_bomb("nmg_jl: radial edgeuse not part of loopuse\n");

	if (eu_r->up.lu_p == lu)
		rt_bomb("nmg_jl: some moron trying to join a loop to itself\n");

	if (lu->up.magic_p != eu_r->up.lu_p->up.magic_p)
		rt_bomb("nmg_jl: loopuses do not share parent\n");

	if (eu_r->up.lu_p->orientation != lu->orientation)
		rt_bomb("nmg_jl: can't join loops of different orientation!\n");

	if (eu->radial_p->eumate_p->radial_p->eumate_p != eu ||
	    eu->eumate_p->radial_p->eumate_p->radial_p != eu)
	    	rt_bomb("nmg_jl: edgeuses must be sole uses of edge to join loops\n");


	/* remove all the edgeuses "ahead" of our radial and insert them
	 * "behind" the current edgeuse.
	 */
	nexteu = RT_LIST_PNEXT_CIRC(edgeuse, eu_r);
	while (nexteu != eu_r) {
		RT_LIST_DEQUEUE(&nexteu->l);
		RT_LIST_INSERT(&eu->l, &nexteu->l);
		nexteu->up.lu_p = eu->up.lu_p;

		RT_LIST_DEQUEUE(&nexteu->eumate_p->l);
		RT_LIST_APPEND(&eu->eumate_p->l, &nexteu->eumate_p->l);
		nexteu->eumate_p->up.lu_p = eu->eumate_p->up.lu_p;

		nexteu = RT_LIST_PNEXT_CIRC(edgeuse, eu_r);
	}

	/* at this point, the other loop just has the one edgeuse/edge in
	 * it.  we can delete the other loop.
	 */
	nmg_klu(eu_r->up.lu_p);

	/* we pop out the one remaining use of the "shared" edge and
	 * voila! we should have one contiguous loop.
	 */
	nmg_keu(eu);
}


/*	N M G _ S I M P L I F Y _ L O O P
 *
 *	combine adjacent loops within the same parent
 */
void nmg_simplify_loop(lu)
struct loopuse *lu;
{
	struct edgeuse *eu, *eu_r, *tmpeu;

	NMG_CK_LOOPUSE(lu);
	if (RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC)
		return;

	eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
	while (RT_LIST_NOT_HEAD(eu, &lu->down_hd) ) {

		NMG_CK_EDGEUSE(eu);

		eu_r = eu->radial_p;
		NMG_CK_EDGEUSE(eu_r);

		/* if the radial edge is part of a loop, and the loop of
		 * the other edge is a part of the same object (face)
		 * as the loop containing the current edge, and my
		 * edgeuse mate is radial to my radial`s edgeuse
		 * mate, and the radial edge is a part of a loop other
		 * than the one "eu" is a part of 
		 * then this is a "worthless" edge between these two loops.
		 */
		if (*eu_r->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    eu_r->up.lu_p->up.magic_p == lu->up.magic_p &&
		    eu->eumate_p->radial_p == eu->radial_p->eumate_p &&
		    eu_r->up.lu_p != lu) {

		    	/* save a pointer to where we've already been
		    	 * so that when eu becomes an invalid pointer, we
		    	 * still know where to pick up from.
		    	 */
		    	tmpeu = RT_LIST_PLAST(edgeuse, eu);

			nmg_jl(lu, eu);

		    	/* Since all the new edges will have been appended
		    	 * after tmpeu, we can pick up processing with the
		    	 * edgeuse immediately after tmpeu
		    	 */
		    	eu = tmpeu;

		    	if (rt_g.NMG_debug &(DEBUG_PLOTEM|DEBUG_PL_ANIM) &&
			    *lu->up.magic_p == NMG_FACEUSE_MAGIC ) {
		    	    	static int fno=0;

				nmg_pl_2fu("After_joinloop%d.pl", fno++,
				    lu->up.fu_p, lu->up.fu_p->fumate_p, 0);
					
		    	}
		}
		eu = RT_LIST_PNEXT(edgeuse, eu);
	}
}


/*	K I L L _ S N A K E S
 *
 */
static void kill_snakes(lu)
struct loopuse *lu;
{
	struct edgeuse *eu, *eu_r;
	struct vertexuse *vu;
	struct vertex *v;

	NMG_CK_LOOPUSE(lu);
	if (RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC)
		return;

	eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
	while (RT_LIST_NOT_HEAD(eu, &lu->down_hd) ) {

		NMG_CK_EDGEUSE(eu);

		eu_r = eu->radial_p;
		NMG_CK_EDGEUSE(eu_r);

		/* if the radial edge is a part of the same loop, and
		 * this edge is not used by anyplace else, and the radial edge
		 * is also the next edge, this MAY be the tail of a snake!
		 */

		if (*eu_r->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    eu_r->up.lu_p == eu->up.lu_p &&
		    eu->eumate_p->radial_p == eu->radial_p->eumate_p &&
		    RT_LIST_PNEXT_CIRC(edgeuse, eu) == eu_r) {

		    	/* if there are no other uses of the vertex
		    	 * between these two edgeuses, then this is
		    	 * indeed the tail of a snake
		    	 */
			v = eu->eumate_p->vu_p->v_p;
			vu = RT_LIST_FIRST(vertexuse, &v->vu_hd);
			while (RT_LIST_NOT_HEAD(vu, &v->vu_hd) &&
			      (vu->up.eu_p == eu->eumate_p ||
			       vu->up.eu_p == eu_r) )
				vu = RT_LIST_PNEXT(vertexuse, vu);

			if (! RT_LIST_NOT_HEAD(vu, &v->vu_hd) ) {
				/* this is the tail of a snake! */
				nmg_keu(eu_r);
				nmg_keu(eu);
				eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);

			    	if (rt_g.NMG_debug &(DEBUG_PLOTEM|DEBUG_PL_ANIM) &&
				    *lu->up.magic_p == NMG_FACEUSE_MAGIC ) {
			    	    	static int fno=0;

					nmg_pl_2fu("After_joinloop%d.pl", fno++,
					    lu->up.fu_p, lu->up.fu_p->fumate_p, 0);

			    	}


			} else
				eu = RT_LIST_PNEXT(edgeuse, eu);
		} else
			eu = RT_LIST_PNEXT(edgeuse, eu);
	}
}


/*	N M G _ S I M P L I F Y _ F A C E
 *
 *
 *	combine adjacent loops within a face which serve no apparent purpose
 *	by remaining separate and distinct.  Kill "wire-snakes" in face.
 */
void nmg_simplify_face(fu)
struct faceuse *fu;
{
	struct loopuse *lu;

	NMG_CK_FACEUSE(fu);

	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))
		nmg_simplify_loop(lu);

	
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))
		kill_snakes(lu);
}


/*
 *			N M G _ S I M P L I F Y _ S H E L L
 */
void nmg_simplify_shell(s)
struct shell *s;
{
	struct faceuse *fu;
	NMG_CK_SHELL(s);

	for (RT_LIST_FOR(fu, faceuse, &s->fu_hd)) {
		nmg_simplify_face(fu);
	}
}


/*	N M G _ D E M O T E _ L U
 *
d1495 1
a1495 1
/*	N M G _ D E M O T E _ E U
a1521 405

/*
 *			N M G _ C K _ L U E U
 *
 *	check all the edgeuses of a loopuse to make sure these children
 *	know who thier parent really is.
 */
void nmg_ck_lueu(cklu, s)
struct loopuse *cklu;
char *s;
{
	struct edgeuse *eu;

	if (RT_LIST_FIRST_MAGIC(&cklu->down_hd) == NMG_VERTEXUSE_MAGIC)
		rt_bomb("NMG nmg_ck_lueu.  I got a vertex loop!\n");

	eu = RT_LIST_FIRST(edgeuse, &cklu->down_hd);
	if (eu->l.back != &cklu->down_hd) {
		rt_bomb("nmg_ck_lueu first element in list doesn't point back to head\n");
	}

	for (RT_LIST_FOR(eu, edgeuse, &cklu->down_hd)) {
		NMG_CK_EDGEUSE(eu);
		if (eu->up.lu_p != cklu) {
			rt_log("edgeuse of %s (going next) has lost proper parent\n", s);
			rt_bomb("nmg_ck_lueu");
		}
		if ((struct edgeuse *)eu->l.forw->back != eu) {
			rt_log("%s next edge (%8x) doesn't point back to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
		if ((struct edgeuse *)eu->l.back->forw != eu) {
			rt_log("%s last edge (%8x) doesn't point forward to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
	}

	cklu = cklu->lumate_p;

	eu = RT_LIST_FIRST(edgeuse, &cklu->down_hd);
	if (eu->l.back != &cklu->down_hd) {
		rt_bomb("nmg_ck_lueu first element in lumate list doesn't point back to head\n");
	}

	for (RT_LIST_FOR(eu, edgeuse, &cklu->down_hd)) {
		NMG_CK_EDGEUSE(eu);
		if (eu->up.lu_p != cklu) {
			rt_log("edgeuse of %s (lumate going next) has lost proper parent\n", s);
			rt_bomb("nmg_ck_lueu");
		}
		if ((struct edgeuse *)eu->l.forw->back != eu) {
			rt_log("%s next edge (%8x) doesn't point back to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
		if ((struct edgeuse *)eu->l.back->forw != eu) {
			rt_log("%s (lumate) back edge (%8x) doesn't point forward to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
	}
}


/*			N M G _ C U T _ L O O P
 *
 *	Divide a loop of edges between two vertexuses
 *
 *	we make a new loop between the two vertexes, and split it and
 *	the loop of the parametric vertexuses at the same time.
 *
 *	Old Loop      New loop	Resulting loops
 *
 *	    v1		v1	    v1
 *	    |	        |	    |\
 *	    V	        V	    V V
 *	*---*---*	*	*---* *---*
 *	|	|	|	|   | |   |
 *	|	|	|	|   | |   |
 *	*---*---*	*	*---* *---*
 *	    ^		^	    ^ ^
 *	    |	        |	    |/
 *	   v2		v2	    v2
 *
 */
void nmg_cut_loop(vu1, vu2)
struct vertexuse *vu1, *vu2;
{
	struct loopuse *lu, *oldlu;
	struct edgeuse *eu1, *eu2, *eunext, *neweu, *eu;
	struct model	*m;
	FILE		*fd;
	char		name[32];
	static int	i=0;

	NMG_CK_VERTEXUSE(vu1);
	NMG_CK_VERTEXUSE(vu2);

	eu1 = vu1->up.eu_p;
	eu2 = vu2->up.eu_p;
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);
	oldlu = eu1->up.lu_p;
	NMG_CK_LOOPUSE(oldlu);
	if (eu2->up.lu_p != oldlu) {
		rt_log("at %d in %s vertices should be decendants of same loop\n",
			__LINE__, __FILE__);
		rt_bomb("subroutine nmg_cut_loop");
	}
	NMG_CK_FACEUSE(oldlu->up.fu_p);
	m = oldlu->up.fu_p->s_p->r_p->m_p;
	NMG_CK_MODEL(m);

	if (rt_g.NMG_debug & DEBUG_CUTLOOP) {
		rt_log("\tnmg_cut_loop\n");
		if (rt_g.NMG_debug & DEBUG_PLOTEM) {
			long		*tab;
			tab = (long *)rt_calloc( m->maxindex, sizeof(long),
				"nmg_cut_loop flag[] 1" );

			(void)sprintf(name, "Before_cutloop%d.pl", ++i);
			rt_log("plotting %s\n", name);
			if ((fd = fopen(name, "w")) == (FILE *)NULL) {
				(void)perror(name);
				exit(-1);
			}

			nmg_pl_fu(fd, oldlu->up.fu_p, tab, 100, 100, 100);
			nmg_pl_fu(fd, oldlu->up.fu_p->fumate_p, tab, 100, 100, 100);
			(void)fclose(fd);
			rt_free( (char *)tab, "nmg_cut_loop flag[] 1" );
		}
	}

	nmg_ck_lueu(oldlu, "oldlu (fresh)");

	/* make a new loop structure for the new loop & throw away
	 * the vertexuse we don't need
	 */
	lu = nmg_mlv(oldlu->up.magic_p, (struct vertex *)NULL,
		oldlu->orientation);

	nmg_kvu(RT_LIST_FIRST(vertexuse, &lu->down_hd));
	nmg_kvu(RT_LIST_FIRST(vertexuse, &lu->lumate_p->down_hd));
	/* nmg_kvu() does RT_LIST_INIT() on down_hd */

	/* move the edges into one of the uses of the new loop */
	for (eu = eu2 ; eu != eu1 ; eu = eunext) {
		eunext = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);

		RT_LIST_DEQUEUE(&eu->l);
		RT_LIST_INSERT(&lu->down_hd, &eu->l);
		RT_LIST_DEQUEUE(&eu->eumate_p->l);
		RT_LIST_APPEND(&lu->lumate_p->down_hd, &eu->eumate_p->l);
		eu->up.lu_p = lu;
		eu->eumate_p->up.lu_p = lu->lumate_p;
	}
	nmg_ck_lueu(lu, "lu check1");	/*LABLABLAB*/

	/* make an edge to "cap off" the new loop */
	neweu = nmg_me(eu1->vu_p->v_p, eu2->vu_p->v_p, nmg_eups(eu1));

	/* move the new edgeuse into the new loopuse */
	RT_LIST_DEQUEUE(&neweu->l);
	RT_LIST_INSERT(&lu->down_hd, &neweu->l);
	neweu->up.lu_p = lu;

	/* move the new edgeuse mate into the new loopuse mate */
	RT_LIST_DEQUEUE(&neweu->eumate_p->l);
	RT_LIST_APPEND(&lu->lumate_p->down_hd, &neweu->eumate_p->l);
	neweu->eumate_p->up.lu_p = lu->lumate_p;

	nmg_ck_lueu(lu, "lu check2");	/*LABLABLAB*/


	/* now we go back and close up the loop we just ripped open */
	eunext = nmg_me(eu2->vu_p->v_p, eu1->vu_p->v_p, nmg_eups(eu1));

	RT_LIST_DEQUEUE(&eunext->l);
	RT_LIST_INSERT(&eu1->l, &eunext->l);
	RT_LIST_DEQUEUE(&eunext->eumate_p->l);
	RT_LIST_APPEND(&eu1->eumate_p->l, &eunext->eumate_p->l);
	eunext->up.lu_p = eu1->up.lu_p;
	eunext->eumate_p->up.lu_p = eu1->eumate_p->up.lu_p;


	/* make sure new edgeuses are radial to each other */
	nmg_moveeu(neweu, eunext);

	nmg_ck_lueu(oldlu, "oldlu");
	nmg_ck_lueu(lu, "lu");	/*LABLABLAB*/


	if (rt_g.NMG_debug & DEBUG_CUTLOOP && rt_g.NMG_debug & DEBUG_PLOTEM) {
		long		*tab;
		tab = (long *)rt_calloc( m->maxindex, sizeof(long),
			"nmg_cut_loop flag[] 2" );

		(void)sprintf(name, "After_cutloop%d.pl", i);
		rt_log("plotting %s\n", name);
		if ((fd = fopen(name, "w")) == (FILE *)NULL) {
			(void)perror(name);
			exit(-1);
		}

		nmg_pl_fu(fd, oldlu->up.fu_p, tab, 100, 100, 100);
		nmg_pl_fu(fd, oldlu->up.fu_p->fumate_p, tab, 100, 100, 100);
		(void)fclose(fd);
		rt_free( (char *)tab, "nmg_cut_loop flag[] 2" );
	}

	nmg_loop_g(oldlu->l_p);
	nmg_loop_g(lu->l_p);
}

/*
 *			N M G _ S P L I T _ L U _ A T _ V U
 *
 *  In a loop which has at least two distinct uses of a vertex,
 *  split off the edges from "split_vu" to the second occurance of
 *  the vertex into a new loop.
 *  The bounding boxes of both old and new loops will be updated.
 *
 *  Intended primarily for use by nmg_split_touchingloops().
 *
 *  Returns -
 *	NULL	Error
 *	*lu	Loopuse of new loop, on success.
 */
struct loopuse *
nmg_split_lu_at_vu( lu, split_vu )
struct loopuse		*lu;
struct vertexuse	*split_vu;
{
	struct edgeuse		*eu;
	struct vertexuse	*vu;
	struct loopuse		*newlu;
	struct loopuse		*newlumate;
	struct vertex		*split_v;

	split_v = split_vu->v_p;
	NMG_CK_VERTEX(split_v);

	/*
	 *  The vertexuse will appear exactly once in the loop, so
	 *  find the edgeuse which has the indicated vertexuse.
	 */
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return (struct loopuse *)0;	/* FAIL */

	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		if( vu == split_vu )  goto begin;
	}
	/* Could not find indicated vertex */
	return (struct loopuse *)0;		/* FAIL */

begin:
	/* Make a new loop in the same face */
	newlu = nmg_mlv( lu->up.magic_p, (struct vertex *)NULL, lu->orientation);
	NMG_CK_LOOPUSE(newlu);
	newlumate = newlu->lumate_p;
	NMG_CK_LOOPUSE(newlumate);

	/* Throw away unneeded lone vertexuse */
	nmg_kvu(RT_LIST_FIRST(vertexuse, &newlu->down_hd));
	nmg_kvu(RT_LIST_FIRST(vertexuse, &newlumate->down_hd));
	/* nmg_kvu() does RT_LIST_INIT() on down_hd */

	/* Move edges & mates into new loop until vertex is repeated */
	for( ;; )  {
		struct edgeuse	*eunext;
		eunext = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);

		RT_LIST_DEQUEUE(&eu->l);
		RT_LIST_INSERT(&newlu->down_hd, &eu->l);
		RT_LIST_DEQUEUE(&eu->eumate_p->l);
		RT_LIST_APPEND(&newlumate->down_hd, &eu->eumate_p->l);

		/* Change edgeuse & mate up pointers */
		eu->up.lu_p = newlu;
		eu->eumate_p->up.lu_p = newlumate;

		/* Advance to next edgeuse */
		eu = eunext;

		/* When split_vertex is encountered, stop */
		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		if( vu->v_p == split_v )  break;
	}

	/* Create new bounding boxes for both old & new loops */
	nmg_loop_g(lu->l_p);
	nmg_loop_g(newlu->l_p);

	return newlu;
}

/*
 *			N M G _ S P L I T _ T O U C H I N G L O O P S
 *
 *  Search through all the vertices in a loop.
 *  Whenever there are two distinct uses of one vertex in the loop,
 *  split off all the edges between them into a new loop.
 */
void
nmg_split_touchingloops( lu )
struct loopuse	*lu;
{
	struct edgeuse		*eu;
	struct vertexuse	*vu;
	struct vertex		*v;

top:
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return;

	/* For each edgeuse, get vertexuse and vertex */
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		struct vertexuse	*tvu;

		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		v = vu->v_p;
		NMG_CK_VERTEX(v);

		/*
		 *  For each vertexuse on vertex list,
		 *  check to see if it points up to the this loop.
		 *  If so, then there is a duplicated vertex.
		 *  Ordinarily, the vertex list will be *very* short,
		 *  so this strategy is likely to be faster than
		 *  a table-based approach, for most cases.
		 */
		for( RT_LIST_FOR( tvu, vertexuse, &v->vu_hd ) )  {
			struct edgeuse		*teu;
			struct loopuse		*tlu;
			struct loopuse		*newlu;

			if( tvu == vu )  continue;
			if( *tvu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
			teu = tvu->up.eu_p;
			NMG_CK_EDGEUSE(teu);
			if( *teu->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
			tlu = teu->up.lu_p;
			NMG_CK_LOOPUSE(tlu);
			if( tlu != lu )  continue;
			/*
			 *  Repeated vertex exists,
			 *  Split loop into two loops
			 */
			newlu = nmg_split_lu_at_vu( lu, vu );
			NMG_CK_LOOPUSE(newlu);

			/* Ensure there are no duplications in new loop */
			nmg_split_touchingloops(newlu);

			/* There is no telling where we will be in the
			 * remainder of original loop, check 'em all.
			 */
			goto top;
		}
	}
}

#if 0


/*	N M G _ E U _ S Q
 *
 *	squeeze an edgeuse out of a list
 *
 *	All uses of the edge being "Squeezed" must be followed by
 *	the same "next" edge
 *
 */
nmg_eu_sq(eu)
struct edgeuse *eu;
{
	struct edgeuse *matenext;
	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGEUSE(eu->eumate_p);

	/* foreach use of this edge, there must be exactly one use of the
	 * previous edge.  There may not be any "extra" uses of the
	 * previous edge
	 */



	matenext = RT_LIST_PNEXT_CIRC(eu->eumate_p);
	NMG_CK_EDGEUSE(matenext);

	RT_LIST_DEQUEUE(eu);
	RT_LIST_DEQUEUE(matenext);

}


/* ToDo:
 * esqueeze
 * Convenience Routines:
 * make edge,loop (close an open edgelist to make loop)
 */
#endif
@


1.35
log
@Replaced two calls to bcopy() with struct copy operations.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.34 91/02/08 02:49:37 mike Exp $ (BRL)";
d2816 11
d2828 2
d2831 4
d2836 343
@


1.34
log
@nmg_identify_magic to rt_identify_magic
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.33 91/02/07 20:32:40 mike Exp $ (BRL)";
d1674 1
a1674 2
		bcopy((char *)eu->vu_p->v_p->vg_p, (char *)vg1,
		    sizeof(struct vertex_g));
d1682 1
a1682 2
		bcopy((char *)eu->eumate_p->vu_p->v_p->vg_p, (char *)vg2,
		    sizeof(struct vertex_g));
@


1.33
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.32 90/12/08 02:53:43 mike Exp $ (BRL)";
d115 1
a115 1
			*magic_p, nmg_identify_magic( *magic_p ) );
d800 1
a800 1
			rt_log("nmg_klu(x%x) magic=%s\n", lu1, nmg_identify_magic(magic1) );
@


1.32
log
@oops, lint caught a small boo-boo in nmg_vertex_gv
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.31 90/12/08 02:48:42 mike Exp $ (BRL)";
d106 1
a106 1
		magic_p = &(NMG_LIST_FIRST(vertexuse,
d136 1
a136 1
	NMG_LIST_INIT( &m->r_hd );
d162 1
a162 1
	NMG_LIST_INIT( &r->s_hd );
d164 1
a164 1
	NMG_LIST_APPEND( &m->r_hd, &r->l );
d187 1
a187 1
	NMG_LIST_INIT( &r->s_hd );
d191 1
a191 1
	NMG_LIST_APPEND( &m->r_hd, &r->l );
d216 1
a216 1
	NMG_LIST_APPEND( &r_p->s_hd, &s->l );
d219 3
a221 3
	NMG_LIST_INIT( &s->fu_hd );
	NMG_LIST_INIT( &s->lu_hd );
	NMG_LIST_INIT( &s->eu_hd );
d254 1
a254 1
	NMG_LIST_APPEND( &v->vu_hd, &vu->l );
d272 1
a272 1
	NMG_LIST_INIT( &v->vu_hd );
d366 2
a367 2
	NMG_LIST_APPEND( &s->eu_hd, &eu1->l );
	NMG_LIST_APPEND( &eu1->l, &eu2->l );
d379 1
a379 1
struct nmg_list	*hd;
d382 1
a382 1
	struct nmg_list	*cur;
d387 1
a387 1
		if( cur->magic == NMG_LIST_MAGIC )  head_count++;
d457 2
a458 2
		NMG_LIST_APPEND( &s->eu_hd, &eu2->l );
		NMG_LIST_APPEND( &s->eu_hd, &eu1->l );
d472 1
a472 1
		if( NMG_LIST_FIRST_MAGIC(&lumate->down_hd) != NMG_VERTEXUSE_MAGIC )
d474 1
a474 1
		vumate = NMG_LIST_FIRST(vertexuse, &lumate->down_hd);
d489 2
a490 2
		NMG_LIST_INIT( &lu->down_hd );
		NMG_LIST_INIT( &lumate->down_hd );
d492 2
a493 2
		NMG_LIST_APPEND( &lumate->down_hd, &eu2->l );
		NMG_LIST_APPEND( &lu->down_hd, &eu1->l );
d540 1
a540 1
	NMG_LIST_INIT( &lu1->down_hd );
d544 1
a544 1
	NMG_LIST_INIT( &lu2->down_hd );
d557 1
a557 1
	if( NMG_LIST_IS_EMPTY( &s->eu_hd ) && s->vu_p )  {
d564 1
a564 1
		NMG_LIST_SET_DOWN_TO_VERT( &lu1->down_hd, vu1 );
d569 1
a569 1
		NMG_LIST_SET_DOWN_TO_VERT( &lu2->down_hd, vu2 );
d572 2
a573 2
		NMG_LIST_APPEND( &s->lu_hd, &lu1->l );
		NMG_LIST_APPEND( &lu1->l, &lu2->l );
d577 1
a577 1
	feu = NMG_LIST_FIRST( edgeuse, &s->eu_hd );
d580 2
a581 2
	while( NMG_LIST_NON_EMPTY( &s->eu_hd ) )  {
		p1 = NMG_LIST_FIRST( edgeuse, &s->eu_hd );
d591 2
a592 2
		NMG_LIST_DEQUEUE( &p1->l );
		if( NMG_LIST_IS_EMPTY( &s->eu_hd ) )  {
d599 1
a599 1
		NMG_LIST_DEQUEUE( &p2->l );
d605 2
a606 2
		NMG_LIST_INSERT( &lu1->down_hd, &p1->l );
		NMG_LIST_INSERT( &lu2->down_hd, &p2->l );
d612 2
a613 2
		if( NMG_LIST_IS_EMPTY( &s->eu_hd ) )  break;
		p1 = NMG_LIST_FIRST( edgeuse, &s->eu_hd );
d629 2
a630 2
	NMG_LIST_APPEND( &s->lu_hd, &lu2->l );
	NMG_LIST_APPEND( &s->lu_hd, &lu1->l );
d650 2
a651 2
	NMG_LIST_DEQUEUE( &vu->l );
	if( NMG_LIST_IS_EMPTY( &oldv->vu_hd ) )  {
d656 1
a656 1
	NMG_LIST_APPEND( &v->vu_hd, &vu->l );
d676 2
a677 2
	NMG_LIST_DEQUEUE( &vu->l );
	if( NMG_LIST_IS_EMPTY( &v->vu_hd ) )  {
d688 1
a688 1
		NMG_LIST_INIT( &vu->up.lu_p->down_hd );
d723 2
a724 2
	while( NMG_LIST_NON_EMPTY( &fu1->lu_hd ) )  {
		nmg_klu( NMG_LIST_FIRST( loopuse, &fu1->lu_hd ) );
d746 2
a747 2
	NMG_LIST_DEQUEUE( &fu1->l );
	if( NMG_LIST_IS_EMPTY( &fu1->s_p->fu_hd ) )
d749 1
a749 1
	NMG_LIST_DEQUEUE( &fu2->l );
d780 1
a780 1
	if( NMG_LIST_NON_EMPTY( &lu1->down_hd ) )  {
d783 2
a784 2
		magic1 = NMG_LIST_FIRST_MAGIC( &lu1->down_hd );
		if( magic1 != NMG_LIST_FIRST_MAGIC( &lu2->down_hd ) )
d790 2
a791 2
			nmg_kvu( NMG_LIST_FIRST(vertexuse, &lu1->down_hd) );
			nmg_kvu( NMG_LIST_FIRST(vertexuse, &lu2->down_hd) );
d795 2
a796 2
			while( NMG_LIST_NON_EMPTY( &lu1->down_hd ) )  {
				nmg_keu(NMG_LIST_FIRST(edgeuse, &lu1->down_hd) );
d808 2
a809 2
		NMG_LIST_DEQUEUE( &lu1->l );
		NMG_LIST_DEQUEUE( &lu2->l );
d812 2
a813 2
		NMG_LIST_DEQUEUE( &lu1->l );
		NMG_LIST_DEQUEUE( &lu2->l );
d883 2
a884 2
	NMG_LIST_INIT(&fu1->lu_hd);
	NMG_LIST_INIT(&fu2->lu_hd);
d893 4
a896 4
	NMG_LIST_DEQUEUE( &lu1->l );
	NMG_LIST_DEQUEUE( &lu2->l );
	NMG_LIST_APPEND( &fu1->lu_hd, &lu1->l );
	NMG_LIST_APPEND( &fu2->lu_hd, &lu2->l );
d904 2
a905 2
	NMG_LIST_APPEND( &s->fu_hd, &fu1->l );
	NMG_LIST_APPEND( &fu1->l, &fu2->l );
d971 2
a972 2
		NMG_LIST_DEQUEUE( &eu1->l );
		NMG_LIST_DEQUEUE( &eu2->l );
d988 2
a989 2
		NMG_LIST_DEQUEUE( &eu1->l );
		NMG_LIST_DEQUEUE( &eu2->l );
d1034 6
a1039 6
	while( NMG_LIST_NON_EMPTY( &s->fu_hd ) )
		nmg_kfu( NMG_LIST_FIRST(faceuse, &s->fu_hd) );
	while( NMG_LIST_NON_EMPTY( &s->lu_hd ) )
		nmg_klu( NMG_LIST_FIRST(loopuse, &s->lu_hd) );
	while( NMG_LIST_NON_EMPTY( &s->eu_hd ) )
		nmg_keu( NMG_LIST_FIRST(edgeuse, &s->eu_hd) );
d1043 1
a1043 1
	NMG_LIST_DEQUEUE( &s->l );
d1061 2
a1062 2
	while( NMG_LIST_NON_EMPTY( &r->s_hd ) )
		nmg_ks( NMG_LIST_FIRST( shell, &r->s_hd ) );
d1064 1
a1064 1
	NMG_LIST_DEQUEUE( &r->l );
d1080 2
a1081 2
	while( NMG_LIST_NON_EMPTY( &m->r_hd ) )
		nmg_kr( NMG_LIST_FIRST( nmgregion, &m->r_hd ) );
d1106 1
a1106 1
			&NMG_LIST_NEXT(vertexuse, &v->vu_hd)->l.magic );
d1143 1
a1143 1
	magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
d1145 1
a1145 1
		for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d1152 1
a1152 1
		vu = NMG_LIST_FIRST(vertexuse, &lu->down_hd);
d1229 1
a1229 1
	for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
d1265 1
a1265 1
	for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
d1274 3
a1276 3
		if( NMG_LIST_MORE(fu, faceuse, &fu->l) &&
		    ( NMG_LIST_NEXT(faceuse, &fu->l)->f_p == fu->f_p ) )  {
			fu = NMG_LIST_PNEXT(faceuse,fu);
d1279 1
a1279 1
	for( NMG_LIST( lu, loopuse, &s->lu_hd ) )  {
d1286 1
a1286 1
	for( NMG_LIST( eu, edgeuse, &s->eu_hd ) )  {
d1302 3
a1304 3
	if( NMG_LIST_IS_EMPTY( &s->fu_hd ) &&
	    NMG_LIST_IS_EMPTY( &s->lu_hd ) &&
	    NMG_LIST_IS_EMPTY( &s->eu_hd ) && !s->vu_p )  {
d1335 1
a1335 1
	for( NMG_LIST( s, shell, &r->s_hd ) )  {
d1435 3
a1437 3
		if( NMG_LIST_PNEXT(edgeuse, oldeu) != oldeumate )  {
			NMG_LIST_DEQUEUE( &oldeumate->l );
			NMG_LIST_APPEND( &oldeu->l, &oldeumate->l );
d1439 4
a1442 4
		NMG_LIST_DEQUEUE( &eu1->l );
		NMG_LIST_DEQUEUE( &eu2->l );
		NMG_LIST_APPEND( &oldeumate->l, &eu1->l );
		NMG_LIST_APPEND( &eu1->l, &eu2->l );
d1510 4
a1513 4
	NMG_LIST_DEQUEUE( &eu1->l );
	NMG_LIST_DEQUEUE( &eu2->l );
	NMG_LIST_APPEND( &oldeu->l, &eu1->l );
	NMG_LIST_APPEND( &oldeumate->l, &eu2->l );
d1734 2
a1735 2
	vu = NMG_LIST_FIRST(vertexuse, &v2->vu_hd );
	while( NMG_LIST_MORE( vu, vertexuse, &v2->vu_hd ) )  {
d1739 3
a1741 3
		vunext = NMG_LIST_PNEXT(vertexuse, vu);
		NMG_LIST_DEQUEUE( &vu->l );
		NMG_LIST_INSERT( &v1->vu_hd, &vu->l );
d1788 1
a1788 1
	NMG_LIST_INIT( &lu1->down_hd );
d1792 1
a1792 1
	NMG_LIST_INIT( &lu2->down_hd );
d1810 2
a1811 2
		NMG_LIST_INSERT( &s->lu_hd, &lu1->l );
		NMG_LIST_INSERT( &lu1->l, &lu2->l );
d1825 1
a1825 1
		NMG_LIST_SET_DOWN_TO_VERT(&lu1->down_hd, vu1);
d1830 1
a1830 1
		NMG_LIST_SET_DOWN_TO_VERT(&lu2->down_hd, vu2);
d1842 2
a1843 2
		NMG_LIST_INSERT( &p.fu->fumate_p->lu_hd, &lu2->l );
		NMG_LIST_INSERT( &p.fu->lu_hd, &lu1->l );
d1848 1
a1848 1
		NMG_LIST_SET_DOWN_TO_VERT(&lu1->down_hd, vu1);
d1852 1
a1852 1
		NMG_LIST_SET_DOWN_TO_VERT(&lu2->down_hd, vu2);
d1879 1
a1879 1
	lu1 = NMG_LIST_FIRST(loopuse, &s->lu_hd);
d1881 1
a1881 1
	NMG_LIST_DEQUEUE( &lu1->l );
d1883 1
a1883 1
	lu2 = NMG_LIST_FIRST(loopuse, &s->lu_hd);
d1885 1
a1885 1
	NMG_LIST_DEQUEUE( &lu2->l );
d1887 2
a1888 2
	NMG_LIST_APPEND( &fu->lu_hd, &lu1->l );
	NMG_LIST_APPEND( &fu->fumate_p->lu_hd, &lu2->l );
d1937 1
a1937 1
		vu = NMG_LIST_FIRST(vertexuse, &lu->down_hd);
d1944 1
a1944 1
			eu = NMG_LIST_FIRST(edgeuse, &lu->down_hd);
d1953 1
a1953 1
		vu = NMG_LIST_FIRST(vertexuse, &lu->down_hd);
d2118 2
a2119 2
		NMG_LIST_DEQUEUE( &eu1->l );
		NMG_LIST_DEQUEUE( &eu2->l );
d2121 2
a2122 2
		NMG_LIST_INSERT( &eu->l, &eu1->l );
		NMG_LIST_APPEND( &eumate->l, &eu2->l );
d2153 1
a2153 1
	for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
d2155 1
a2155 1
		magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
d2158 1
a2158 1
			vu = NMG_LIST_FIRST(vertexuse, &lu->down_hd);
d2165 1
a2165 1
			for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d2210 1
a2210 1
		lu = NMG_LIST_FIRST( loopuse, &fu->lu_hd );
d2212 1
a2212 1
		if( NMG_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC) {
d2216 1
a2216 1
			eu = NMG_LIST_FIRST( edgeuse, &lu->down_hd );
d2222 2
a2223 2
		lu = NMG_LIST_FIRST( loopuse, &fulist[i]->lu_hd );
		for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d2230 1
a2230 1
				lu2 = NMG_LIST_FIRST(loopuse,
d2232 1
a2232 1
				for( NMG_LIST( eu2, edgeuse, &lu2->down_hd ) )  {
d2263 1
a2263 1
	for( NMG_LIST( vu, vertexuse, &v1->vu_hd ) )  {
d2431 1
a2431 1
	vu = NMG_LIST_FIRST( vertexuse, &lu->down_hd);
d2443 1
a2443 1
		lu = NMG_LIST_FIRST( loopuse, &fu->lu_hd );
d2445 1
a2445 1
		euold = NMG_LIST_FIRST( edgeuse, &lu->down_hd );
d2534 1
a2534 1
	nexteu = NMG_LIST_PNEXT_CIRC(edgeuse, eu_r);
d2536 2
a2537 2
		NMG_LIST_DEQUEUE(&nexteu->l);
		NMG_LIST_INSERT(&eu->l, &nexteu->l);
d2540 2
a2541 2
		NMG_LIST_DEQUEUE(&nexteu->eumate_p->l);
		NMG_LIST_APPEND(&eu->eumate_p->l, &nexteu->eumate_p->l);
d2544 1
a2544 1
		nexteu = NMG_LIST_PNEXT_CIRC(edgeuse, eu_r);
d2569 1
a2569 1
	if (NMG_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC)
d2572 2
a2573 2
	eu = NMG_LIST_FIRST(edgeuse, &lu->down_hd);
	while (NMG_LIST_MORE(eu, edgeuse, &lu->down_hd) ) {
d2597 1
a2597 1
		    	tmpeu = NMG_LIST_PLAST(edgeuse, eu);
d2616 1
a2616 1
		eu = NMG_LIST_PNEXT(edgeuse, eu);
d2632 1
a2632 1
	if (NMG_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC)
d2635 2
a2636 2
	eu = NMG_LIST_FIRST(edgeuse, &lu->down_hd);
	while (NMG_LIST_MORE(eu, edgeuse, &lu->down_hd) ) {
d2651 1
a2651 1
		    NMG_LIST_PNEXT_CIRC(edgeuse, eu) == eu_r) {
d2658 2
a2659 2
			vu = NMG_LIST_FIRST(vertexuse, &v->vu_hd);
			while (NMG_LIST_MORE(vu, vertexuse, &v->vu_hd) &&
d2662 1
a2662 1
				vu = NMG_LIST_PNEXT(vertexuse, vu);
d2664 1
a2664 1
			if (! NMG_LIST_MORE(vu, vertexuse, &v->vu_hd) ) {
d2668 1
a2668 1
				eu = NMG_LIST_FIRST(edgeuse, &lu->down_hd);
d2681 1
a2681 1
				eu = NMG_LIST_PNEXT(edgeuse, eu);
d2683 1
a2683 1
			eu = NMG_LIST_PNEXT(edgeuse, eu);
d2701 1
a2701 1
	for (NMG_LIST(lu, loopuse, &fu->lu_hd))
d2705 1
a2705 1
	for (NMG_LIST(lu, loopuse, &fu->lu_hd))
d2719 1
a2719 1
	for (NMG_LIST(fu, faceuse, &s->fu_hd)) {
d2744 1
a2744 1
	if (NMG_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_VERTEXUSE_MAGIC) {
d2747 1
a2747 1
			vu = NMG_LIST_FIRST(vertexuse, &lu1->down_hd);
d2756 1
a2756 1
	if (NMG_LIST_FIRST_MAGIC(&lu1->down_hd) != NMG_EDGEUSE_MAGIC)
d2765 1
a2765 1
	while ( NMG_LIST_NON_EMPTY(&lu1->down_hd) ) {
d2767 1
a2767 1
		eu1 = NMG_LIST_FIRST(edgeuse, &lu1->down_hd);
d2773 2
a2774 2
		NMG_LIST_DEQUEUE(&eu1->eumate_p->l);
		NMG_LIST_APPEND(&s->eu_hd, &eu1->eumate_p->l);
d2776 2
a2777 2
		NMG_LIST_DEQUEUE(&eu1->l);
		NMG_LIST_APPEND(&s->eu_hd, &eu1->l);
d2782 1
a2782 1
	if (NMG_LIST_NON_EMPTY(&lu1->lumate_p->down_hd))
d2847 1
a2847 1
	matenext = NMG_LIST_PNEXT_CIRC(eu->eumate_p);
d2850 2
a2851 2
	NMG_LIST_DEQUEUE(eu);
	NMG_LIST_DEQUEUE(matenext);
@


1.31
log
@Moved nmg_demote_lu and nmg_demote_eu
from nmg_bool to nmg_mk
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_mk.c,v 1.30 90/05/24 23:22:57 mike Exp $ (BRL)";
d1101 1
a1101 1
	if (v->vg_p) {
@


1.30
log
@GET_xxx() macros now require struct model pointers.
Added index numbers to all structs.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.29 90/05/24 20:47:17 mike Exp $ (BRL)";
d377 1
d1632 1
a1632 1
/*	N M G _ U N G L U E 
d2184 1
d2692 1
a2692 1
 *	by remaining separate and distinct.
d2710 3
d2723 99
@


1.29
log
@Moved validators to nmg_ck.c
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.28 90/05/24 19:49:54 mike Exp $ (BRL)";
d58 2
a59 1
/*	N M G _ M M
d61 63
d132 1
a132 1
	GET_MODEL(m);
d137 2
d142 3
a144 1
/*	N M G _ M M R
d146 1
a146 1
 *	Make Model, Region
d156 1
a156 1
	GET_REGION(r);
d183 1
a183 1
	GET_REGION(r);
d212 1
a212 1
	GET_SHELL(s);
d236 1
d248 2
a249 1
	GET_VERTEXUSE(vu);
d266 2
a267 1
	struct vertex *v;
d269 2
a270 1
	GET_VERTEX(v);
d304 3
a306 2
	struct edge *e;
	struct edgeuse *eu1, *eu2;
d308 1
d314 2
a315 1
	GET_EDGE(e);
d319 2
a320 2
	GET_EDGEUSE(eu1);
	GET_EDGEUSE(eu2);
d331 3
a364 3
	/* link the edgeuses to the parent shell */
	eu1->up.s_p = eu2->up.s_p = s;

d418 1
d428 2
a429 1
	GET_EDGE(e);
d433 2
a434 2
	GET_EDGEUSE(eu1);
	GET_EDGEUSE(eu2);
d528 1
d532 2
a533 1
	GET_LOOP(l);
d537 1
a537 1
	GET_LOOPUSE(lu1);
d541 1
a541 1
	GET_LOOPUSE(lu2);
d856 2
a857 1
	struct shell *s;
d872 4
a875 3
	GET_FACE(f);
	GET_FACEUSE(fu1);
	GET_FACEUSE(fu2);
d1096 1
d1104 3
a1106 1
		GET_VERTEX_G(vg);
d1123 2
d1127 3
a1129 1
	NMG_CK_LOOPUSE(l->lu_p);
d1134 2
a1135 1
		GET_LOOP_G(l->lg_p);
d1142 1
a1142 1
	magic1 = NMG_LIST_FIRST_MAGIC( &l->lu_p->down_hd );
d1144 1
a1144 1
		for( NMG_LIST( eu, edgeuse, &l->lu_p->down_hd ) )  {
d1151 1
a1151 1
		vu = NMG_LIST_FIRST(vertexuse, &l->lu_p->down_hd);
d1170 3
a1172 1
	struct face_g *fg;
d1175 2
a1176 1
	NMG_CK_FACE(fu->f_p);
d1181 1
a1181 1
	fg = fu->f_p->fg_p;
d1183 1
a1183 1
		NMG_CK_FACE_G(fu->f_p->fg_p);
d1185 3
a1187 2
		GET_FACE_G(fu->f_p->fg_p);
		fg = fu->f_p->fg_p;
d1194 1
a1194 1
	nmg_face_bb(fu->f_p);
d1206 1
d1209 2
d1212 2
a1213 2
	if (f->fg_p ) {
		NMG_CK_FACE_G(f->fg_p);
d1216 4
a1219 2
		GET_FACE_G(f->fg_p);
		f->fg_p->magic = NMG_FACE_G_MAGIC;
a1221 1
	fg = f->fg_p;
a1227 1
	fu = f->fu_p;
d1250 2
d1257 2
a1258 1
		GET_SHELL_A(s->sa_p);
d1325 1
a1325 1
		GET_REGION_A(ra);
d1644 2
a1645 1
	struct edge *e;
d1653 2
a1654 1
	GET_EDGE(e);
d1660 4
a1663 4
	GET_VERTEX(v1);
	GET_VERTEX(v2);
	GET_VERTEX_G(vg1);
	GET_VERTEX_G(vg2);
d1765 3
a1767 2
	struct loop *l;
	struct loopuse *lu1, *lu2;
d1780 2
a1781 1
	GET_LOOP(l);
d1785 1
a1785 1
	GET_LOOPUSE(lu1);
d1789 1
a1789 1
	GET_LOOPUSE(lu2);
d1802 11
d1825 1
d1830 3
a1832 1
		lu1->up.s_p = lu2->up.s_p = s;
d1834 4
d1841 2
a1842 4
		NMG_LIST_INSERT( &s->lu_hd, &lu1->l );
		NMG_LIST_INSERT( &lu1->l, &lu2->l );
	} else if (*p.magic_p == NMG_FACEUSE_MAGIC) {
		struct vertexuse	*vu1, *vu2;
d1844 1
a1852 9

		lu1->up.fu_p = p.fu;
		lu2->up.fu_p = p.fu->fumate_p;

		lu1->lumate_p = lu2;
		lu2->lumate_p = lu1;

		NMG_LIST_INSERT( &p.fu->fumate_p->lu_hd, &lu2->l );
		NMG_LIST_INSERT( &p.fu->lu_hd, &lu1->l );
@


1.28
log
@Added TBL_INS_UNIQUE
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.27 90/05/24 19:01:55 mike Exp $ (BRL)";
a57 64
/*
 *			N M G _ I D E N T I F Y _ M A G I C
 *
 *  Given a number which has been found in the magic number field of
 *  a structure (which is typically the first entry),
 *  determine what kind of structure this magic number pertains to.
 *  This is called by the macro NMG_CK_MAGIC() to provide a "hint"
 *  as to what sort of pointer error might have been made.
 */
char *nmg_identify_magic( magic )
long	magic;
{
	switch(magic)  {
	default:
		return("Unknown");
	case NMG_MODEL_MAGIC:
		return("model");
	case NMG_MODEL_A_MAGIC:
		return("model_a");
	case NMG_REGION_MAGIC:
		return("region");
	case NMG_REGION_A_MAGIC:
		return("region_a");
	case NMG_SHELL_MAGIC:
		return("shell");
	case NMG_SHELL_A_MAGIC:
		return("shell_a");
	case NMG_FACE_MAGIC:
		return("face");
	case NMG_FACE_G_MAGIC:
		return("face_g");
	case NMG_FACEUSE_MAGIC:
		return("faceuse");
	case NMG_FACEUSE_A_MAGIC:
		return("faceuse_a");
	case NMG_LOOP_MAGIC:
		return("loop");
	case NMG_LOOP_G_MAGIC:
		return("loop_g");
	case NMG_LOOPUSE_MAGIC:
		return("loopuse");
	case NMG_LOOPUSE_A_MAGIC:
		return("loopuse_a");
	case NMG_EDGE_MAGIC:
		return("edge");
	case NMG_EDGE_G_MAGIC:
		return("edge_g");
	case NMG_EDGEUSE_MAGIC:
		return("edgeuse");
	case NMG_EDGEUSE_A_MAGIC:
		return("edgeuse_a");
	case NMG_VERTEX_MAGIC:
		return("vertex");
	case NMG_VERTEX_G_MAGIC:
		return("vertex_g");
	case NMG_VERTEXUSE_MAGIC:
		return("vertexuse");
	case NMG_VERTEXUSE_A_MAGIC:
		return("vertexuse_a");
	case NMG_LIST_MAGIC:
		return("nmg_list");
	}
}

a1647 123
/*	N M G _ T B L
 *	maintain a table of pointers (to magic numbers/structs)
 */
int nmg_tbl(b, func, p)
struct nmg_ptbl *b;
int func;
long *p;
{
	if (func == TBL_INIT) {
		b->buffer = (long **)rt_calloc(b->blen=64,
						sizeof(p), "pointer table");
		b->end = 0;
		return(0);
	} else if (func == TBL_RST) {
		b->end = 0;
		return(0);
	} else if (func == TBL_INS) {
		register int i;
		union {
			struct loopuse *lu;
			struct edgeuse *eu;
			struct vertexuse *vu;
			long *l;
		} pp;

		if (rt_g.NMG_debug & DEBUG_INS)
			rt_log("nmg_tbl Inserting %8x\n", p);

		pp.l = p;

		if (b->blen == 0) (void)nmg_tbl(b, TBL_INIT, p);
		if (b->end >= b->blen)
			b->buffer = (long **)rt_realloc( (char *)b->buffer,
			    sizeof(p)*(b->blen *= 4),
			    "pointer table" );

		b->buffer[i=b->end++] = p;
		return(i);
	} else if (func == TBL_LOC) {
		/* we do this a great deal, so make it go as fast as possible.
		 * this is the biggest argument I can make for changing to an
		 * ordered list.  Someday....
		 */
		register int	k;
		register long	**pp = b->buffer;

#		include "noalias.h"
		for( k = b->end-1; k >= 0; k-- )
			if (pp[k] == p) return(k);

		return(-1);
	} else if (func == TBL_INS_UNIQUE) {
		/* we do this a great deal, so make it go as fast as possible.
		 * this is the biggest argument I can make for changing to an
		 * ordered list.  Someday....
		 */
		register int	k;
		register long	**pp = b->buffer;

#		include "noalias.h"
		for( k = b->end-1; k >= 0; k-- )
			if (pp[k] == p) return(k);

		if (b->blen <= 0 || b->end >= b->blen)  {
			/* Table needs to grow */
			return( nmg_tbl( b, TBL_INS, p ) );
		}
		b->buffer[k=b->end++] = p;
		return(-1);		/* To signal that it was added */
	} else if (func == TBL_RM) {
		/* we go backwards down the list looking for occurrences
		 * of p to delete.  We do it backwards to reduce the amount
		 * of data moved when there is more than one occurrence of p
		 * in the list.  A pittance savings, unless you're doing a
		 * lot of it.
		 */
		register int end = b->end, j, k, l;
		register long **pp = b->buffer;

		for (l = b->end-1 ; l >= 0 ; --l)
			if (pp[l] == p){
				/* delete occurrence(s) of p */

				j=l+1;
				while (pp[l-1] == p) --l;

				end -= j - l;
#				include "noalias.h"
				for(k=l ; j < end ;)
					b->buffer[k++] = b->buffer[j++];
			}

		b->end = end;
		return(0);
	} else if (func == TBL_CAT) {
		union {
			long *l;
			struct nmg_ptbl *t;
		} d;

		d.l = p;

		if ((b->blen - b->end) < d.t->end) {
			
			b->buffer = (long **)rt_realloc( (char *)b->buffer,
				sizeof(p)*(b->blen += d.t->blen),
				"pointer table (CAT)");
		}
		bcopy(d.t->buffer, &b->buffer[b->end], d.t->end*sizeof(p));
		return(0);
	} else if (func == TBL_FREE) {
		bzero((char *)b->buffer, b->blen * sizeof(p));
		rt_free((char *)b->buffer, "pointer table");
		bzero(b, sizeof(struct nmg_ptbl));
		return (0);
	} else {
		rt_log("Unknown table function %d\n", func);
		rt_bomb("nmg_tbl");
	}
	return(-1);/* this is here to keep lint happy */
}


d2130 1
a2130 1
 *			F I N D E U
d2134 1
a2134 1
static struct edgeuse *findeu(v1, v2, s, eup)
d2155 1
a2155 1
			rt_bomb("findeu");
d2201 1
a2201 1
	    	rt_log("findeu search failed\n");
d2343 1
a2343 1
			eur = findeu(*verts[i+1], *verts[i], s, euold);
d2369 1
a2369 1
	if (eur = findeu(*verts[n-1], *verts[0], s, euold))
a2376 516
}

/*
 *			N M G _ V V G
 *
 *  Verify vertex geometry
 */
void nmg_vvg(vg)
struct vertex_g *vg;
{
	NMG_CK_VERTEX_G(vg);
}

/*
 *			N M G _ V V E R T E X
 *
 *  Verify a vertex
 */
void nmg_vvertex(v, vup)
struct vertex *v;
struct vertexuse *vup;
{
	struct vertexuse *vu;

	NMG_CK_VERTEX(v);

	for( NMG_LIST( vu, vertexuse, &v->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);
		if (vu->v_p != v)
			rt_bomb("nmg_vvertex() a vertexuse in my list doesn't share my vertex\n");
	}
	if (v->vg_p) nmg_vvg(v->vg_p);
}

/* Verify vertex attributes */
void nmg_vvua(vua)
struct vertexuse_a *vua;
{
	NMG_CK_VERTEXUSE_A(vua);
}

/*
 *			N M G _ V V U
 *
 *  Verify vertexuse
 */
void nmg_vvu(vu, up_magic_p)
struct vertexuse *vu;
long		*up_magic_p;
{
	NMG_CK_VERTEXUSE(vu);
	if (vu->up.magic_p != up_magic_p)
		rt_bomb("nmg_vvu() vertexuse denies parent\n");

	if (!vu->l.forw)
		rt_bomb("nmg_vvu() vertexuse has null forw pointer\n");

	if( NMG_LIST_FIRST_MAGIC( &vu->l ) != NMG_VERTEXUSE_MAGIC)
		rt_bomb("vertexuse forw is bad vertexuse\n");

	if (NMG_LIST_PNEXT_PLAST(vertexuse,vu) != vu )
		rt_bomb("vertexuse not back of next vertexuse\n");

	nmg_vvertex(vu->v_p, vu);

	if (vu->vua_p) nmg_vvua(vu->vua_p);
}

/* Verify edgeuse attributes */
void nmg_veua(eua)
struct edgeuse_a *eua;
{
	NMG_CK_EDGEUSE_A(eua);
}

/* Verify edge geometry */
void nmg_veg(eg)
struct edge_g *eg;
{
	NMG_CK_EDGE_G(eg);
}

/*
 *			N M G _ V E D G E
 *
 *  Verify edge
 */
void nmg_vedge(e, eup)
struct edge *e;
struct edgeuse *eup;
{
	struct edgeuse *eu;
	int is_use = 0;		/* flag: eup is in edge's use list */

	NMG_CK_EDGE(e);
	NMG_CK_EDGEUSE(eup);
	NMG_CK_VERTEXUSE(eup->vu_p);
	NMG_CK_VERTEX(eup->vu_p->v_p);
	NMG_CK_EDGEUSE(eup->eumate_p);
	NMG_CK_VERTEXUSE(eup->eumate_p->vu_p);
	NMG_CK_VERTEX(eup->eumate_p->vu_p->v_p);

	if (!e->eu_p) rt_bomb("edge has null edgeuse pointer\n");

	eu = eup;
	do {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGEUSE(eu->eumate_p);
		if (eu == eup || eu->eumate_p == eup)
			is_use = 1;

		NMG_CK_VERTEXUSE(eu->vu_p);
		NMG_CK_VERTEX(eu->vu_p->v_p);
		if (eu->vu_p->v_p == eup->vu_p->v_p) {
			if (eu->eumate_p->vu_p->v_p != eup->eumate_p->vu_p->v_p)
				rt_bomb("edgeuse mate does not have correct vertex\n");
		} else if (eu->vu_p->v_p == eup->eumate_p->vu_p->v_p) {
			if (eu->eumate_p->vu_p->v_p != eup->vu_p->v_p)
				rt_bomb("edgeuse does not have correct vertex\n");
		} else
			rt_bomb("edgeuse does not share vertex endpoint\n");

		eu = eu->eumate_p->radial_p;
	} while (eu != eup);

	if (!is_use)
		rt_bomb("Cannot get from edge to parent edgeuse\n");

	if (e->eg_p) nmg_veg(e->eg_p);
}

/*
 *			N M G _ V E U
 *
 *  Verify edgeuse
 */
void nmg_veu(hp, up_magic_p)
struct nmg_list	*hp;
long	*up_magic_p;
{
	struct edgeuse	*eu;
	struct edgeuse	*eunext;
	
	for( NMG_LIST( eu, edgeuse, hp ) )  {
		NMG_CK_EDGEUSE(eu);

		if (eu->up.magic_p != up_magic_p)
			rt_bomb("edgeuse denies parentage\n");

		if (!eu->l.forw)
			rt_bomb("edgeuse has Null \"forw\" pointer\n");
		eunext = NMG_LIST_PNEXT_CIRC( edgeuse, eu );
		if (eunext->l.magic != NMG_EDGEUSE_MAGIC)
			rt_bomb("edgeuse forw is bad edgeuse\n");
		if (NMG_LIST_PLAST_CIRC(edgeuse,eunext) != eu )  {
		    if (eunext->l.back)
			rt_bomb("next edgeuse has back that points elsewhere\n");
		    else
			rt_bomb("next edgeuse has NULL back\n");
		}
		if (eu->eumate_p->l.magic != NMG_EDGEUSE_MAGIC)
			rt_bomb("edgeuse mate is bad edgeuse\n");
		else if (eu->eumate_p->eumate_p != eu)
			rt_bomb("edgeuse mate spurns edgeuse\n");

		if (eu->radial_p->l.magic != NMG_EDGEUSE_MAGIC)
			rt_bomb("edgeuse radial is bad edgeuse\n");
		else if (eu->radial_p->radial_p != eu)
			rt_bomb("edgeuse radial denies knowing edgeuse\n");

		nmg_vedge(eu->e_p, eu);
		
		if (eu->eua_p) nmg_veua(eu->eua_p);

		switch (eu->orientation) {
		case OT_NONE	: break;
		case OT_SAME	: break;
		case OT_OPPOSITE: break;
		case OT_UNSPEC	: break;
		default		: rt_bomb("unknown loopuse orintation\n");
					break;
		}

		nmg_vvu(eu->vu_p, eu);
	}
}

/*
 *			N M G _ V L G
 *
 *  Verify loop geometry
 */
void nmg_vlg(lg)
struct loop_g *lg;
{
	int i;
	
	NMG_CK_LOOP_G(lg);

	for (i=0 ; i < ELEMENTS_PER_PT ; ++i)
		if (lg->min_pt[i] > lg->max_pt[i])
			rt_bomb("loop geom min_pt greater than max_pt\n");
}

/*
 *			N M G _ V L O O P
 *
 *  Verify loop
 */
void nmg_vloop(l, lup)
struct loop *l;
struct loopuse *lup;
{
	struct loopuse *lu;

	NMG_CK_LOOP(l);
	NMG_CK_LOOPUSE(lup);

	if (!l->lu_p) rt_bomb("loop has null loopuse pointer\n");

#if 0
	for (lu=lup ; lu && lu != l->lu_p && lu->next != lup ; lu = lu->next);
	
	if (l->lu_p != lu)
		for (lu=lup->lumate_p ; lu && lu != l->lu_p && lu->next != lup->lumate_p ; lu = lu->next);

	if (l->lu_p != lu) rt_bomb("can't get to parent loopuse from loop\n");
#endif

	if (l->lg_p) nmg_vlg(l->lg_p);
}

/* Verify loop attributes */
void nmg_vlua(lua)
struct loopuse_a *lua;
{
	NMG_CK_LOOPUSE_A(lua);
}

/*
 *			N M G _ V L U
 *
 *  Verify loopuse
 */
void nmg_vlu(hp, up)
struct nmg_list	*hp;
{
	struct loopuse *lu;

	for( NMG_LIST( lu, loopuse, hp ) )  {
		NMG_CK_LOOPUSE(lu);

		if (*lu->up.magic_p != hp->magic)
			rt_bomb("loopuse denies parentage\n");

		if (!lu->l.forw)
			rt_bomb("loopuse has null forw pointer\n");
		else if (NMG_LIST_PNEXT_PLAST(loopuse,lu) != lu )
			rt_bomb("forw loopuse has back pointing somewhere else\n");

		if (!lu->lumate_p)
			rt_bomb("loopuse has null mate pointer\n");

		if (lu->lumate_p->l.magic != NMG_LOOPUSE_MAGIC)
			rt_bomb("loopuse mate is bad loopuse\n");

		if (lu->lumate_p->lumate_p != lu)
			rt_bomb("lumate spurns loopuse\n");

		switch (lu->orientation) {
		case OT_NONE	: break;
		case OT_SAME	: break;
		case OT_OPPOSITE	: break;
		case OT_UNSPEC	: break;
		default		: rt_bomb("unknown loopuse orintation\n");
					break;
		}
		if (lu->lumate_p->orientation != lu->orientation)
			rt_bomb("loopuse and mate have different orientation\n");

		if (!lu->l_p)
			rt_bomb("loopuse has Null loop pointer\n");
		else {
			nmg_vloop(lu->l_p, lu);
		}

		if (lu->lua_p) nmg_vlua(lu->lua_p);

		if( NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC)
			nmg_veu( &lu->down_hd, lu);
		else if (NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)
			nmg_vvu(NMG_LIST_FIRST(vertexuse,&lu->down_hd), lu);
		else
			rt_bomb("nmg_vlu bad magic\n");
	}
}

/*
 *			N M G _ V F G
 *
 *  Verify face geometry
 */
void nmg_vfg(fg)
struct face_g *fg;
{
	int i;

	NMG_CK_FACE_G(fg);

	for (i=0 ; i < ELEMENTS_PER_PT ; ++i)
		if (fg->min_pt[i] > fg->max_pt[i])
			rt_bomb("face geom min_pt greater than max_pt\n");

	if (fg->N[X]==0.0 && fg->N[Y]==0.0 && fg->N[Z]==0.0 &&
	    fg->N[H]!=0.0) {
		rt_log("bad NMG plane equation %fX + %fY + %fZ = %f\n",
			fg->N[X], fg->N[Y], fg->N[Z], fg->N[H]);
		rt_bomb("Bad NMG geometry\n");
	}
}

/*
 *			N M G _ V F A C E
 *
 *  Verify face
 */
void nmg_vface(f, fup)
struct face *f;
struct faceuse *fup;
{
	struct faceuse *fu;

	NMG_CK_FACE(f);
	NMG_CK_FACEUSE(fup);

	/* make sure we can get back to the parent faceuse from the face */
	if (!f->fu_p) rt_bomb("face has null faceuse pointer\n");

#if 0
	for (fu = fup; fu && fu != f->fu_p && fu->forw != fup; fu = fu->forw);

	if (f->fu_p != fu) rt_bomb("can't get to parent faceuse from face\n");
#endif
	
	if (f->fg_p) nmg_vfg(f->fg_p);
}

/* Verify faceuse attributes */
void nmg_vfua(fua)
struct faceuse_a *fua;
{
	NMG_CK_FACEUSE_A(fua);
}

/*	N M G _ V F U
 *
 *	Validate a list of faceuses
 */
void nmg_vfu(hp, s)
struct nmg_list	*hp;
struct shell *s;
{
	struct faceuse *fu;

	for( NMG_LIST( fu, faceuse, hp ) )  {
		NMG_CK_FACEUSE(fu);
		if (fu->s_p != s) {
			rt_log("faceuse claims shell parent (%8x) instead of (%8x)\n",
				fu->s_p, s);
			rt_bomb("nmg_vfu\n");
		}

		if (!fu->l.forw) {
			rt_bomb("faceuse forw is NULL\n");
		} else if (fu->l.forw->back != (struct nmg_list *)fu) {
			rt_bomb("faceuse->forw->back != faceuse\n");
		}

		if (!fu->fumate_p)
			rt_bomb("null faceuse fumate_p pointer\n");

		if (fu->fumate_p->l.magic != NMG_FACEUSE_MAGIC)
			rt_bomb("faceuse mate is bad faceuse ptr\n");

		if (fu->fumate_p->fumate_p != fu)
			rt_bomb("faceuse mate spurns faceuse!\n");

		switch (fu->orientation) {
		case OT_NONE	: break;
		case OT_SAME	: if (fu->fumate_p->orientation != OT_OPPOSITE)
					rt_bomb("faceuse of \"SAME\" orientation has mate that is not \"OPPOSITE\" orientation");
				break;
		case OT_OPPOSITE:  if (fu->fumate_p->orientation != OT_SAME)
					rt_bomb("faceuse of \"OPPOSITE\" orientation has mate that is not \"SAME\" orientation");
				break;
		case OT_UNSPEC	: break;
		default		: rt_bomb("unknown faceuse orintation\n"); break;
		}

		if (fu->fua_p) nmg_vfua(fu->fua_p);
		
		NMG_CK_FACE(fu->f_p);
		nmg_vface(fu->f_p, fu);
		
		nmg_vlu( &fu->lu_hd, fu);
	}
}


/*	N M G _ S H E L L
 *
 *	validate a list of shells and all elements under them
 */
void nmg_vshell(hp, r)
struct nmg_list	*hp;
struct nmgregion *r;
{
	struct shell *s;
	pointp_t lpt, hpt;

	for( NMG_LIST( s, shell, hp ) )  {
		NMG_CK_SHELL(s);
		if (s->r_p != r) {
			rt_log("shell's r_p (%8x) doesn't point to parent (%8x)\n",
				s->r_p, r);
			rt_bomb("nmg_vshell");
		}

		if (!s->l.forw) {
			rt_bomb("nmg_vshell: Shell's forw ptr is null\n");
		} else if (s->l.forw->back != (struct nmg_list *)s) {
			rt_log("forw shell's back(%8x) is not me (%8x)\n",
				s->l.forw->back, s);
			rt_bomb("nmg_vshell\n");
		}

		if (s->sa_p) {
			NMG_CK_SHELL_A(s->sa_p);
			/* we make sure that all values of min_pt
			 * are less than or equal to the values of max_pt
			 */
			lpt = s->sa_p->min_pt;
			hpt = s->sa_p->max_pt;
			if (lpt[0] > hpt[0] || lpt[1] > hpt[1] ||
			    lpt[2] > hpt[2]) {
				rt_log("Bad min_pt/max_pt for shell(%8x)'s extent\n");
				rt_log("Min_pt %g %g %g\n", lpt[0], lpt[1],
					lpt[2]);
				rt_log("Max_pt %g %g %g\n", hpt[0], hpt[1],
					hpt[2]);
			}
		}

		/* now we check out the "children"
		 */

		if (s->vu_p) {
			if( NMG_LIST_NON_EMPTY( &s->fu_hd ) ||
			    NMG_LIST_NON_EMPTY( &s->lu_hd ) ||
			    NMG_LIST_NON_EMPTY( &s->eu_hd ) )  {
				rt_log("shell (%8x) with vertexuse (%8x) has other children\n",
					s, s->vu_p);
				rt_bomb("");
			}
		}

		nmg_vfu( &s->fu_hd, s);
		nmg_vlu( &s->lu_hd, s);
		nmg_veu( &s->eu_hd, s);
	}
}



/*
 *			N M G _ V R E G I O N
 *
 *	validate a list of nmgregions and all elements under them
 */
void nmg_vregion(hp, m)
struct nmg_list	*hp;
struct model *m;
{
	struct nmgregion *r;

	for( NMG_LIST( r, nmgregion, hp ) )  {
		NMG_CK_REGION(r);
		if (r->m_p != m) {
			rt_log("nmgregion pointer m_p %8x should be %8x\n",
				r->m_p, m);
			rt_bomb("nmg_vregion\n");
		}
		if (r->ra_p) {
			NMG_CK_REGION_A(r->ra_p);
		}

		nmg_vshell( &r->s_hd, r);

		if( NMG_LIST_PNEXT_PLAST(nmgregion, r) != r )  {
			rt_bomb("forw nmgregion's back is not me\n");
		}
	}
}

/*	N M G _ V M O D E L
 *
 *	validate an NMG model and all elements in it.
 */
void nmg_vmodel(m)
struct model *m;
{
	NMG_CK_MODEL(m);
	if (m->ma_p) {
		NMG_CK_MODEL_A(m->ma_p);
	}
	nmg_vregion( &m->r_hd, m);
@


1.27
log
@Changed arg from char to int.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.26 90/05/24 18:36:48 butler Exp $ (BRL)";
d1745 1
a1745 1
			    sizeof(p)*(b->blen += 64),
d1755 2
a1756 2
		register int k= -1, end = b->end;
		register long **pp = b->buffer;
d1758 2
a1759 1
		while (++k < end)
d1763 18
d1799 1
@


1.26
log
@Added kill_snakes().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.25 90/05/23 22:06:45 butler Exp $ (BRL)";
d1827 3
a1829 3
long *magic;
struct vertex *v;
char orientation;
@


1.25
log
@Added nmg_simplify routines & call them after boolean evaluation is complete
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.24 90/05/22 21:16:13 mike Exp $ (BRL)";
d3128 1
d3150 1
a3150 2
		/* if the radial edge is part of a loop, but not the
		 * loop containing the current edge, and the loop of
d3154 3
a3156 2
		 * mate, then this is a "worthless" edge between
		 * these two loops.
a3158 1
		    eu_r->up.lu_p != lu &&
d3160 3
a3162 2
		    eu->eumate_p->radial_p == eu->radial_p->eumate_p) {
		    	
d3191 67
d3271 1
a3271 1
	for (NMG_LIST(lu, loopuse, &fu->lu_hd)) {
d3273 4
a3276 1
	}
@


1.24
log
@Switched to using VL_CMD_* defines for vlist operations
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.23 90/05/22 21:05:37 mike Exp $ (BRL)";
a2294 11
/*
 *			N M G _ V U _ T O _ V L I S T
 *
 *  Plot a single vertexuse
 */
nmg_vu_to_vlist( vhead, vu )
struct vlhead		*vhead;
struct vertexuse	*vu;
{
	struct vertex	*v;
	register struct vertex_g *vg;
a2295 12
	NMG_CK_VERTEXUSE(vu);
	v = vu->v_p;
	NMG_CK_VERTEX(v);
	vg = v->vg_p;
	if( vg )  {
		/* Only thing in this shell is a point */
		NMG_CK_VERTEX_G(vg);
		ADD_VL( vhead, vg->coord, VL_CMD_LINE_MOVE );
		ADD_VL( vhead, vg->coord, VL_CMD_LINE_DRAW );
	}
}

a2296 204
 *			N M G _ E U _ T O _ V L I S T
 *
 *  Plot a list of edgeuses.  The last edge is joined back to the first.
 */
nmg_eu_to_vlist( vhead, eu_hd )
struct vlhead	*vhead;
struct nmg_list	*eu_hd;
{
	struct edgeuse		*eu;
	struct edgeuse		*eumate;
	struct vertexuse	*vu;
	struct vertexuse	*vumate;
	register struct vertex_g *vg;
	register struct vertex_g *vgmate;

	/* Consider all the edges in the wire edge list */
	for( NMG_LIST( eu, edgeuse, eu_hd ) )  {
		/* This wire edge runs from vertex to mate's vertex */
		NMG_CK_EDGEUSE(eu);
		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		NMG_CK_VERTEX(vu->v_p);
		vg = vu->v_p->vg_p;

		eumate = eu->eumate_p;
		NMG_CK_EDGEUSE(eumate);
		vumate = eumate->vu_p;
		NMG_CK_VERTEXUSE(vumate);
		NMG_CK_VERTEX(vumate->v_p);
		vgmate = vumate->v_p->vg_p;

		if( !vg || !vgmate ) {
			rt_log("nmg_eu_to_vlist() no vg or mate?\n");
			continue;
		}
		NMG_CK_VERTEX_G(vg);
		NMG_CK_VERTEX_G(vgmate);

		ADD_VL( vhead, vg->coord, VL_CMD_LINE_MOVE );
		ADD_VL( vhead, vgmate->coord, VL_CMD_LINE_DRAW );
	}
}

/*
 *			N M G _ L U _ T O _ V L I S T
 *
 *  Plot a list of loopuses.
 */
nmg_lu_to_vlist( vhead, lu_hd, poly_markers, normal )
struct vlhead	*vhead;
struct nmg_list	*lu_hd;
int		poly_markers;
vectp_t		normal;
{
	struct loopuse	*lu;
	struct edgeuse	*eu;
	struct vertexuse *vu;
	struct vertex	*v;
	register struct vertex_g *vg;

	for( NMG_LIST( lu, loopuse, lu_hd ) )  {
		int		isfirst;
		struct vertex_g	*first_vg;
		point_t		centroid;
		int		npoints;

		/* Consider this loop */
		NMG_CK_LOOPUSE(lu);
		if( NMG_LIST_FIRST_MAGIC(&lu->down_hd)==NMG_VERTEXUSE_MAGIC )  {
			/* loop of a single vertex */
			vu = NMG_LIST_FIRST(vertexuse, &lu->down_hd);
			nmg_vu_to_vlist( vhead, vu );
			continue;
		}
		/* Consider all the edges in the loop */
		isfirst = 1;
		first_vg = (struct vertex_g *)0;
		npoints = 0;
		VSETALL( centroid, 0 );
		for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
			/* Consider this edge */
			NMG_CK_EDGEUSE(eu);
			vu = eu->vu_p;
			NMG_CK_VERTEXUSE(vu);
			v = vu->v_p;
			NMG_CK_VERTEX(v);
			vg = v->vg_p;
			if( !vg ) {
				continue;
			}
			NMG_CK_VERTEX_G(vg);
			VADD2( centroid, centroid, vg->coord );
			npoints++;
			if (isfirst) {
				if( poly_markers) {
					/* Insert a "start polygon, normal" marker */
					ADD_VL( vhead, normal, VL_CMD_POLY_START );
					ADD_VL( vhead, vg->coord, VL_CMD_POLY_MOVE );
				} else {
					/* move */
					ADD_VL( vhead, vg->coord, VL_CMD_LINE_MOVE );
				}
				isfirst = 0;
				first_vg = vg;
			} else {
				if( poly_markers) {
					ADD_VL( vhead, vg->coord, VL_CMD_POLY_DRAW );
				} else {
					/* Draw */
					ADD_VL( vhead, vg->coord, VL_CMD_LINE_DRAW );
				}
			}
		}

		/* Draw back to the first vertex used */
		if( !isfirst && first_vg )  {
			if( poly_markers )  {
				/* Draw, end polygon */
				ADD_VL( vhead, first_vg->coord, VL_CMD_POLY_END );
			} else {
				/* Draw */
				ADD_VL( vhead, first_vg->coord, VL_CMD_LINE_DRAW );
			}
		}
		if( poly_markers > 1 && npoints > 2 )  {
			/* Draw surface normal as a little vector */
			double	f;
			vect_t	tocent;
			f = 1.0 / npoints;
			VSCALE( centroid, centroid, f );
			ADD_VL( vhead, centroid, VL_CMD_LINE_MOVE );
			VSUB2( tocent, first_vg->coord, centroid );
			f = MAGNITUDE( tocent ) * 0.5;
			VSCALE( tocent, normal, f );
			VADD2( centroid, centroid, tocent );
			ADD_VL( vhead, centroid, VL_CMD_LINE_DRAW );
		}
	}
}

/*
 *			N M G _ S _ T O _ V L I S T
 *
 *  Plot the entire contents of a shell.
 *
 *  poly_markers =
 *	0 for vectors
 *	1 for polygons
 *	2 for polygons and surface normals drawn with vectors
 */
void
nmg_s_to_vlist( vhead, s, poly_markers )
struct vlhead	*vhead;
struct shell	*s;
int		poly_markers;
{
	struct faceuse	*fu;
	struct face_g	*fg;
	vect_t		normal;

	NMG_CK_SHELL(s);

	/* faces */
	for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
		/* Consider this face */
		NMG_CK_FACEUSE(fu);
		NMG_CK_FACE(fu->f_p);
		fg = fu->f_p->fg_p;
		NMG_CK_FACE_G(fg);
		if (fu->orientation != OT_SAME)  continue;
	   	nmg_lu_to_vlist( vhead, &fu->lu_hd, poly_markers, fg->N );
	}

	/* wire loops.  poly_markers=0 so wires are always drawn as vectors */
	VSETALL(normal, 0);
	nmg_lu_to_vlist( vhead, &s->lu_hd, 0, normal );

	/* wire edges */
	nmg_eu_to_vlist( vhead, &s->eu_hd );

	/* single vertices */
	if (s->vu_p)  {
		nmg_vu_to_vlist( vhead, s->vu_p );
	}
}

/*
 *			N M G _ R _ T O _ V L I S T
 */
void
nmg_r_to_vlist( vhead, r, poly_markers )
struct vlhead	*vhead;
struct nmgregion	*r;
int		poly_markers;
{
	register struct shell	*s;

	NMG_CK_REGION( r );
	for( NMG_LIST( s, shell, &r->s_hd ) )  {
		nmg_s_to_vlist( vhead, s, poly_markers );
	}
}

/*
d3061 158
d3220 32
@


1.23
log
@Fixed nmg_eu_to_vlist
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.22 90/05/21 23:42:44 butler Exp $ (BRL)";
d2314 2
a2315 2
		ADD_VL( vhead, vg->coord, 0 );
		ADD_VL( vhead, vg->coord, 1 );
d2358 2
a2359 2
		ADD_VL( vhead, vg->coord, 0 );		/* move */
		ADD_VL( vhead, vgmate->coord, 1 );	/* draw */
d2416 2
a2417 2
					ADD_VL( vhead, normal, 2 );
					ADD_VL( vhead, vg->coord, 3 );	/* move */
d2420 1
a2420 1
					ADD_VL( vhead, vg->coord, 0 );
d2426 1
a2426 1
					ADD_VL( vhead, vg->coord, 4 );
d2429 1
a2429 1
					ADD_VL( vhead, vg->coord, 1 );
d2438 1
a2438 1
				ADD_VL( vhead, first_vg->coord, 5 );
d2441 1
a2441 1
				ADD_VL( vhead, first_vg->coord, 1 );
d2450 1
a2450 1
			ADD_VL( vhead, centroid, 0 );	/* move */
d2455 1
a2455 1
			ADD_VL( vhead, centroid, 1 );	/* draw */
@


1.22
log
@Fixed bug in nmg_klu().
Added some extra sanity checking.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.21 90/05/21 13:01:31 mike Exp $ (BRL)";
d2328 4
a2331 3
	struct edgeuse	*eu;
	struct vertexuse *vu;
	struct vertex	*v;
d2333 1
a2333 1
	struct vertex_g	*first_vg;
a2335 1
	first_vg = (struct vertex_g *)0;
d2337 1
a2337 1
		/* Consider this edge */
d2341 12
a2352 4
		v = vu->v_p;
		NMG_CK_VERTEX(v);
		vg = v->vg_p;
		if( !vg ) {
d2356 4
a2359 12
		if( !first_vg )  {
			/* move */
			ADD_VL( vhead, vg->coord, 0 );
			first_vg = vg;
		} else {
			/* Draw */
			ADD_VL( vhead, vg->coord, 1 );
		}
	}
	if( first_vg )  {
		/* Draw back to first vertex used */
		ADD_VL( vhead, first_vg->coord, 1 );	/* draw */
@


1.21
log
@Fixed bug in nmg_gluefaces
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.20 90/05/21 12:43:47 mike Exp $ (BRL)";
d361 11
d373 15
d389 7
d764 1
a764 1
	if( NMG_LIST_FIRST_MAGIC( &lu1->down_hd ) != 0 )  {
d783 2
a784 1
		else
d786 1
d1348 1
d1427 3
d1431 4
a1434 2
	if (*oldeu->up.lu_p->up.magic_p == NMG_SHELL_MAGIC)
		s = oldeu->up.lu_p->up.s_p;
d1436 1
a1436 1
		s = oldeu->up.lu_p->up.fu_p->s_p;
d1439 3
d1449 2
@


1.20
log
@Fixed problem with region attribute structures.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.19 90/05/21 11:50:53 mike Exp $ (BRL)";
d2233 1
d2238 3
a2240 2
				lu = NMG_LIST_FIRST(loopuse, &fulist[f_no]->lu_hd);
				for( NMG_LIST( eu2, edgeuse, &lu->down_hd ) )  {
@


1.19
log
@Minor lint
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_mk.c,v 1.18 90/05/18 11:56:59 mike Exp $ (BRL)";
d1251 7
a1257 1
	GET_REGION_A(ra);
@


1.18
log
@Lee fixed bug in nmg_mlv -- lu2, not lu1
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_mk.c,v 1.17 90/05/18 10:32:26 mike Exp $ (BRL)";
d1692 1
a1692 1
			b->buffer = (long **)rt_realloc(b->buffer,
d1744 1
a1744 1
			b->buffer = (long **)rt_realloc(b->buffer,
d2763 1
a2763 1
void nmg_vvu(vu, up)
d2765 1
a2765 6
union {
	struct shell	*s;
	struct loopuse	*lu;
	struct edgeuse	*eu;
	long		*magic_p;
} up;
d2768 1
a2768 1
	if (vu->up.magic_p != up.magic_p)
d2853 1
a2853 1
void nmg_veu(hp, up)
d2855 1
a2855 5
union {
	struct shell	*s;
	struct loopuse	*lu;
	long 		*magic_p;
} up;
d2863 1
a2863 1
		if (eu->up.magic_p != up.magic_p)
@


1.17
log
@Fixed bug in nmg_eins().
Also neatened some pointers.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.16 90/05/18 07:26:08 butler Exp $ (BRL)";
d1843 1
d1846 2
a1847 1
		NMG_LIST_SET_DOWN_TO_VERT(&lu1->down_hd, vu2);
@


1.16
log
@Halfway converted to new double-linked-list structures ;-)
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.15 90/05/12 10:19:42 butler Exp $ (BRL)";
a1442 2
	eu1->eumate_p = eu1->radial_p = oldeumate;
	oldeumate->radial_p = oldeumate->eumate_p = eu1;
a1446 2
	eu2->eumate_p = eu2->radial_p = oldeu;
	oldeu->radial_p = oldeu->eumate_p = eu2;
d1448 12
d1478 3
a1480 1
	struct edge *e;
d1484 4
d1492 2
a1493 1
	if (eusrc == eudst || eusrc->eumate_p == eudst)
d1495 1
d1498 2
a1499 1
	    (eusrc->radial_p == eudst || eudst->radial_p == eusrc))
d1501 1
a1502 1

d1504 2
a1505 2
	if ( ! ( (eudst->eumate_p->vu_p->v_p == eusrc->vu_p->v_p &&
	    eudst->vu_p->v_p == eusrc->eumate_p->vu_p->v_p) ||
d1507 1
a1507 1
	    eudst->eumate_p->vu_p->v_p == eusrc->eumate_p->vu_p->v_p) ) ) {
d1509 4
d1517 1
a1517 1
	eusrc->eumate_p->e_p = eusrc->e_p = eudst->e_p;
d1523 1
a1523 1
	if (eusrc->radial_p != eusrc->eumate_p) {
d1525 1
a1525 1
		if (e->eu_p == eusrc || e->eu_p == eusrc->eumate_p)
d1529 2
a1530 2
		eusrc->radial_p->radial_p = eusrc->eumate_p->radial_p;
		eusrc->eumate_p->radial_p->radial_p = eusrc->radial_p;
d1538 1
a1538 1
	eusrc->eumate_p->radial_p = eudst->radial_p;
d1540 1
a1540 1
	eudst->radial_p->radial_p = eusrc->eumate_p;
d2061 2
a2062 1
 *	Insert a new (zero length) edge at the begining of an existing edge
d2074 2
d2081 1
d2086 3
a2088 2
	struct edgeuse *eu1, *eu2;
	struct shell *s;
d2091 2
a2118 2
		struct edgeuse	*eumate_pred;	/* predecessor to eumate */

d2122 2
a2123 3
		NMG_LIST_APPEND( &eu->l, &eu1->l );
		eumate_pred = NMG_LIST_NEXT( edgeuse, &eu->eumate_p->l );
		NMG_LIST_APPEND( &eumate_pred->l, &eu2->l );
d2126 1
a2126 1
		eu2->up.lu_p = eu->eumate_p->up.lu_p;
@


1.15
log
@new classifier, nmg_manifold_face.  Tentative release.  There is a
problem with nmg_demote_lu and the boolean code somewhere
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.14 90/05/12 07:13:46 butler Exp $ (BRL)";
d117 2
a134 1
	m->r_p = (struct nmgregion *)NULL;
d136 1
d151 1
a151 1
	GET_MODEL(m);
d153 1
d155 1
a155 3
	m->magic = NMG_MODEL_MAGIC;
	m->r_p = r;
	m->ma_p = (struct model_a *)NULL;
a156 3
	r->magic = NMG_REGION_MAGIC;
	r->m_p = m;
	r->next = r->last = r;
d158 1
a158 1
	r->s_p = (struct shell *)NULL;
d160 2
d165 3
a167 1
/*	N M G _ M R
d180 2
d183 1
a183 2
	r->magic = NMG_REGION_MAGIC;
	r->s_p = (struct shell *)NULL;
d186 2
a187 1
	r->m_p = m;
a188 3
	/* new region goes at "head" of list of regions */
	DLLINS(m->r_p, r);

d191 4
a194 1
/*	N M G _ M S V
d202 2
a203 1
	struct shell *s;
d207 1
d209 1
a210 2
	/* set up shell */
	s->magic = NMG_SHELL_MAGIC;
d212 1
a212 1
	DLLINS(r_p->s_p, s);
d215 3
a217 4
	s->vu_p = nmg_mvvu(&s->magic);
	s->fu_p = (struct faceuse *)NULL;
	s->lu_p = (struct loopuse *)NULL;
	s->eu_p = (struct edgeuse *)NULL;
d219 2
d233 2
d240 1
a240 1
		rt_bomb("Cannot build vertexuse without parent");
d244 1
a245 1
	vu->magic = NMG_VERTEXUSE_MAGIC;
d248 1
a248 1
	DLLINS(v->vu_p, vu);
a262 1

d264 1
d270 3
a272 1
/*	N M G _ M E
d275 1
d280 3
d285 6
d298 1
d305 3
d310 1
a311 1
	e->magic = NMG_EDGE_MAGIC;
a312 1
	e->eg_p = (struct edge_g *)NULL;
a313 2
	eu1->magic = eu2->magic = NMG_EDGEUSE_MAGIC;

d321 2
a322 2
		eu1->vu_p = nmg_mvu(v1, &eu1->magic);
	else if (s->vu_p) {
d324 1
a324 2
		eu1->vu_p = s->vu_p;
		s->vu_p->up.eu_p = eu1;
d326 2
d330 1
a330 1
		eu1->vu_p = nmg_mvvu(&eu1->magic);
d334 2
a335 2
		eu2->vu_p = nmg_mvu(v2, &eu2->magic);
	else if (s->vu_p) {
d337 1
a337 2
		eu2->vu_p = s->vu_p;
		s->vu_p->up.eu_p = eu2;
d339 2
d343 1
a343 1
		eu2->vu_p = nmg_mvvu(&eu2->magic);
d345 5
a349 2
	if (s->vu_p)
		nmg_kvu(s->vu_p);
d354 3
a356 2
	if (s->vu_p)
		nmg_kvu(s->vu_p);
a357 3
	DLLINS(eu2->up.s_p->eu_p, eu2);
	DLLINS(eu1->up.s_p->eu_p, eu1);

d363 3
a365 1
/*	N M G _ M E o n V U
d380 1
a380 1
		rt_bomb("cannot make edge vertexuse not sole element of object");
d384 3
d389 1
a390 1
	e->magic = NMG_EDGE_MAGIC;
a391 1
	e->eg_p = (struct edge_g *)NULL;
a392 2
	eu1->magic = eu2->magic = NMG_EDGEUSE_MAGIC;

a398 1

d401 2
d404 5
a408 5
		eu2->vu_p = nmg_mvu(vu->v_p, &eu2->magic);
		eu2->up.s_p = eu1->up.s_p = vu->up.s_p;
		if (vu->up.s_p->vu_p != vu)
			rt_bomb("vetexuse parent shell disowns vertexuse!\n");
		vu->up.s_p->vu_p = (struct vertexuse *)NULL;
d410 2
a411 2
		DLLINS(eu2->up.s_p->eu_p, eu2);
		DLLINS(eu1->up.s_p->eu_p, eu1);
d414 9
d424 8
a431 4
		if (vu->up.lu_p->lumate_p->magic != NMG_LOOPUSE_MAGIC ||
		    *vu->up.lu_p->lumate_p->down.magic_p != 
		    NMG_VERTEXUSE_MAGIC)
			rt_bomb("mate of vertex-loop is not vertex-loop!\n");
d435 1
a435 1
		eu2->vu_p = vu->up.lu_p->lumate_p->down.vu_p;
d438 2
a439 2
		eu1->up.lu_p = eu1->vu_p->up.lu_p;
		eu2->up.lu_p = eu2->vu_p->up.lu_p;
d441 6
a446 5
		/* loopuses point at edgeuses */
		vu->up.lu_p->lumate_p->down.eu_p = (struct edgeuse *)NULL;
		vu->up.lu_p->down.eu_p = (struct edgeuse *)NULL;
		DLLINS(vu->up.lu_p->lumate_p->down.eu_p, eu2);
		DLLINS(vu->up.lu_p->down.eu_p, eu1);
d448 3
a450 4

		/* vertexuses point at edgeusees */
		eu1->vu_p->up.eu_p = eu1;
		eu2->vu_p->up.eu_p = eu2;
a451 1

d479 3
a481 1
	struct edgeuse *p1, *p2, *feu;
d486 3
d490 3
d494 2
a496 1
	l->magic = NMG_LOOP_MAGIC;
a497 1
	l->lg_p = (struct loop_g *)NULL;
a498 1
	lu1->magic = lu2->magic = NMG_LOOPUSE_MAGIC;
a501 1
	lu1->down.magic_p = lu2->down.magic_p = (long *)NULL;
d508 5
a512 4
	if (!s->eu_p && s->vu_p) {
		lu1->down.vu_p = s->vu_p;
		s->vu_p->up.lu_p = lu1;
		lu2->down.vu_p = nmg_mvu(s->vu_p->v_p, &lu2->magic);
d514 11
a524 2
		DLLINS(s->lu_p, lu2);
		DLLINS(s->lu_p, lu1);
d528 1
a528 1
	feu = s->eu_p;
d530 7
a536 1
	do {
d538 2
a539 2
		if (s->eu_p->up.s_p != s || s->eu_p->eumate_p->up.s_p != s)
			rt_bomb("edgeuse mates don't have proper parent!");
d541 3
a543 3
		/* get the first edgeuse */
		DLLRM(s->eu_p, p1);
		if (s->eu_p == p1) {
d546 1
a546 1
			rt_bomb("");
d549 2
a550 8
		/* pick out its mate */
		if (s->eu_p == p1->eumate_p) {
			DLLRM(s->eu_p, p2);
			if (s->eu_p == p2) s->eu_p = (struct edgeuse *)NULL;
		} else {
			DLLRM(p1->eumate_p, p2);
			p1->eumate_p = p2;
		}
d552 3
a554 5
		DLLINS(lu1->down.eu_p, p1);
		DLLINS(lu2->down.eu_p, p2);

		/* we want to insert the next new edgeuse(s) in the tail of
		 * the list, not the head.
d556 2
a557 2
		lu1->down.eu_p = lu1->down.eu_p->next;
		lu2->down.eu_p = lu2->down.eu_p->next;
d562 7
a568 1
	} while (s->eu_p && s->eu_p->vu_p->v_p == p2->vu_p->v_p);
d572 1
a572 1
	if (p2->vu_p->v_p != feu->vu_p->v_p) {
d576 1
a576 16
		rt_bomb("Bye\n");
		/* re-link edgeuses back to shell */
		do {
			DLLRM(lu1->down.eu_p, p1);
			if (lu1->down.eu_p == p1)
				lu1->down.eu_p = (struct edgeuse *)NULL;
			DLLINS(s->eu_p, p1);
		} while (lu1->down.eu_p);
		do {
			DLLRM(lu2->down.eu_p, p2);
			if (lu2->down.eu_p == p2)
				lu2->down.eu_p = (struct edgeuse *)NULL;
			DLLINS(s->eu_p, p2);
		} while (lu2->down.eu_p);

		return((struct loopuse *)NULL);
d579 3
a581 2
	DLLINS(s->lu_p, lu2);
	DLLINS(s->lu_p, lu1);
d593 2
d598 5
a602 1
	if (vu->next == vu->last && vu->next == vu) {
d604 2
a605 11
		if (vu->v_p) {
			if (vu->v_p->vg_p) FREE_VERTEX_G(vu->v_p->vg_p);
			FREE_VERTEX(vu->v_p);
		}
	} else {
		vu->next->last = vu->last;
		vu->last->next = vu->next;

		/* make sure vertex isn't pointing at this vu */
		if (vu->v_p->vu_p == vu)
			vu->v_p->vu_p = vu->next;
d607 1
a607 1

a608 1
	DLLINS(v->vu_p, vu);
d617 1
d624 5
a628 1
	if (vu->next == vu->last && vu->next == vu) {
d630 2
a631 11
		if (vu->v_p) {
			if (vu->v_p->vg_p) FREE_VERTEX_G(vu->v_p->vg_p);
			FREE_VERTEX(vu->v_p);
		}
	} else {
		vu->next->last = vu->last;
		vu->last->next = vu->next;

		/* make sure vertex isn't pointing at this vu */
		if (vu->v_p->vu_p == vu)
			vu->v_p->vu_p = vu->next;
d635 1
a635 1
	if (*vu->up.magic_p == NMG_SHELL_MAGIC)
d637 4
a640 3
	else if (*vu->up.magic_p == NMG_LOOPUSE_MAGIC)
		vu->up.lu_p->down.vu_p = (struct vertexuse *)NULL;
	else if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC)
d642 2
a643 2
	else
		rt_bomb("killing vertexuse of unknown parent?\n");
d651 4
a654 3
 *	delete a faceuse and its mate from the parent shell.  Any children
 *	found are brutally murdered as well.  If this is the last child of
 *	a shell, we null-out the shell's downward pointer
d659 4
a662 1
	struct faceuse *fu2, *p;
d666 6
a672 1

d674 3
a676 2
	while (fu1->lu_p)
		nmg_klu(fu1->lu_p);
d679 3
a681 9
	if (fu1->f_p != fu2->f_p)
		rt_bomb("faceuse mates do not share face!\n");
	if (fu1->f_p) {
		if (fu1->f_p->fg_p) {
			NMG_CK_FACE_G(fu1->f_p->fg_p);
			FREE_FACE_G(fu1->f_p->fg_p);
		}
		FREE_FACE(fu1->f_p);
		fu1->f_p = fu2->f_p = (struct face *)NULL;
d683 2
d697 4
a700 4
	fu1->s_p->fu_p = fu1;
	DLLRM(fu1->s_p->fu_p, p);
	if (p == fu1->s_p->fu_p)
		rt_bomb("faceuse mate not in parent?\n");
a701 5
	fu2->s_p->fu_p = fu2;
	DLLRM(fu2->s_p->fu_p, p);
	if (p == fu2->s_p->fu_p)
		fu2->s_p->fu_p = (struct faceuse *)NULL;

d719 1
a719 6
	struct loopuse *lu2, *p;
#if 0
	struct edgeuse *eu1, *eu2;
#endif
	struct faceuse *fu;
	struct shell *s;
d725 2
d729 1
a729 1
		rt_bomb("loopuses do not have same type of parent!\n");
d731 6
a736 2
	if (lu1->down.magic_p && *lu1->down.magic_p != *lu2->down.magic_p)
		rt_bomb("loopuses do not have same type of child!\n");
d738 5
a742 5
	/* deal with the children */
	if (lu1->down.magic_p) {
		if (*lu1->down.magic_p == NMG_VERTEXUSE_MAGIC) {
			nmg_kvu(lu1->down.vu_p);
			nmg_kvu(lu2->down.vu_p);
d744 1
a744 1
		else if (*lu1->down.magic_p == NMG_EDGEUSE_MAGIC) {
d746 3
a748 2
			while (lu1->down.eu_p)
				nmg_keu(lu1->down.eu_p);
d757 2
a758 8
		s = lu1->up.s_p;
		s->lu_p = lu1;
		DLLRM(s->lu_p, p);
		if (s->lu_p == p) s->lu_p = (struct loopuse *)NULL;

		s->lu_p = lu2;
		DLLRM(s->lu_p, p);
		if (s->lu_p == p) s->lu_p = (struct loopuse *)NULL;
d761 2
a762 9
		fu = lu1->up.fu_p;
		fu->lu_p = lu1;
 		DLLRM(fu->lu_p, p);
		if (fu->lu_p == p) fu->lu_p = (struct loopuse *)NULL;

		fu = lu2->up.fu_p;
		fu->lu_p = lu2;
		DLLRM(fu->lu_p, p);
		if (fu->lu_p == p) fu->lu_p = (struct loopuse *)NULL;
d767 1
a767 1
		rt_bomb("bye");
d779 2
a780 4
	if (lu1->l_p != lu2->l_p)
		rt_bomb("loopmates do not share loop!\n");

	if (lu1->l_p) {
d793 3
a795 2

/*	N M G _ M F
d810 1
a810 1
		rt_bomb("loop must be child of shell for making face");
d815 1
a815 1
		rt_bomb("loopuse mate does not have same parent\n");
d819 1
d829 3
a831 1
	fu1->magic = fu2->magic = NMG_FACEUSE_MAGIC;
d839 5
a844 5
	/* move the loopuses from the shell to the faceuses */
	s->lu_p = lu1;
	DLLRM(s->lu_p, fu1->lu_p);
	if (s->lu_p == fu1->lu_p)
		rt_bomb("loopuses don't have same parent?\n");
a846 5

	s->lu_p = lu2;
	DLLRM(s->lu_p, fu2->lu_p)
	    if (s->lu_p == fu2->lu_p)
		s->lu_p = (struct loopuse *)NULL;
d850 3
a852 4
	/* connect the faces to the parent shell */
	DLLINS(s->fu_p, fu2);
	DLLINS(s->fu_p, fu1);

d856 3
a858 2

/*	N M G _ K E U
a859 4
 *
 *	This routine DOES null-out the
 *	parent's edgeuse pointer when the last edgeuse is being
 *	deleted.
d864 2
a865 1
	register struct edgeuse *eu2, *tmpeu;
d869 2
d874 1
d876 2
a877 4
	if (eu1->e_p != eu2->e_p) {
		rt_log("In %s at %d Edgeuse pair does not share edge\n",
		    __FILE__, __LINE__);
		rt_bomb("Dying in nmg_keu");
a878 1
	NMG_CK_EDGE(eu1->e_p);
d880 1
a880 2
	/* unlink from radial linkages (if any)
	 */
d891 2
a892 2
		if (eu1->e_p->eu_p == eu1 || eu1->e_p->eu_p == eu2)
			eu1->e_p->eu_p = eu1->radial_p;
d898 2
a899 2
		if (eu1->e_p->eg_p) FREE_EDGE_G(eu1->e_p->eg_p);
		FREE_EDGE(eu1->e_p);
d904 11
a914 6

		if (eu1->up.lu_p->lumate_p != eu2->up.lu_p ||
		    eu1->up.lu_p != eu2->up.lu_p->lumate_p ) {
			rt_log("In %s at %d %s\n", __FILE__, __LINE__,
			    "edgeuse mates don't belong to loopuse mates");
			rt_bomb("bye");
d918 2
a919 4
		eu1->up.lu_p->down.eu_p = eu1;
		DLLRM(eu1->up.lu_p->down.eu_p, tmpeu);
		if (tmpeu == eu1->up.lu_p->down.eu_p)
			eu1->up.lu_p->down.eu_p = (struct edgeuse *)NULL;
a920 5
		eu2->up.lu_p->down.eu_p = eu2;
		DLLRM(eu2->up.lu_p->down.eu_p, tmpeu);
		if (tmpeu == eu2->up.lu_p->down.eu_p)
			eu2->up.lu_p->down.eu_p = (struct edgeuse *)NULL;

d923 1
a923 1
		 * we must kill the parent loopuses.
d926 2
a927 2
		 *    !eu1->up.lu_p->down.eu_p)
		 *	nmg_klu(eu1->up.lu_p);
a928 1

a929 1

d931 1
a931 3
			rt_log("in %s at %d edguses don't share parent\n",
			    __FILE__, __LINE__);
			rt_bomb("bye");
d935 2
a936 7
		eu1->up.s_p->eu_p = eu1;
		DLLRM(eu1->up.s_p->eu_p, tmpeu);
		eu2->up.s_p->eu_p = eu2;
		DLLRM(eu2->up.s_p->eu_p, tmpeu);
		if (eu2->up.s_p->eu_p == tmpeu) {
			eu2->up.s_p->eu_p = (struct edgeuse *)NULL;
		}
d948 1
a948 2
			FREE_EDGEUSE_A(eu2->eua_p);
			eu1->eua_p = eu2->eua_p = (struct edgeuse_a *)NULL;
d950 2
a951 1
	} else if (eu2->eua_p) {
d970 1
a977 1
	struct shell *tmps;
d981 8
a988 8
	while (s->fu_p)
		nmg_kfu(s->fu_p);
	while (s->lu_p)
		nmg_klu(s->lu_p);
	while (s->eu_p)
		nmg_keu(s->eu_p);
	while (s->vu_p)
		nmg_kvu(s->vu_p);
d990 1
a990 4
	s->r_p->s_p = s;
	DLLRM(s->r_p->s_p, tmps);
	if (s->r_p->s_p == tmps)
		s->r_p->s_p = (struct shell *)NULL;
d998 1
a1004 1
	struct nmgregion *tmpr;
d1008 2
a1009 2
	while (r->s_p)
		nmg_ks(r->s_p);
d1011 1
a1011 4
	r->m_p->r_p = r;
	DLLRM(r->m_p->r_p, tmpr);
	if (r->m_p->r_p == tmpr)
		r->m_p->r_p = (struct nmgregion *)NULL;
d1027 2
a1028 2
	while (m->r_p)
		nmg_kr(m->r_p);
d1065 4
a1068 2
	struct edgeuse *eu;
	struct vertex_g *vg;
d1070 4
a1073 2
	if (l->lg_p) {
		NMG_CK_LOOP_G(l->lg_p);
d1076 2
a1077 1
		l->lg_p->magic = NMG_LOOP_G_MAGIC;
d1079 2
d1082 3
a1084 9
	l->lg_p->max_pt[X] = l->lg_p->max_pt[Y] = 
	    l->lg_p->max_pt[Z] = -MAX_FASTF;
	l->lg_p->min_pt[X] = l->lg_p->min_pt[Y] = 
	    l->lg_p->min_pt[Z] = MAX_FASTF;

	NMG_CK_LOOPUSE(l->lu_p);
	if (*l->lu_p->down.magic_p == NMG_EDGEUSE_MAGIC) {
		eu = l->lu_p->down.eu_p;
		do {
d1087 8
a1094 8

			VMINMAX(l->lg_p->min_pt, l->lg_p->max_pt, vg->coord);

			eu = eu->next;
		} while (eu != l->lu_p->down.eu_p);
	} else if (*l->lu_p->down.magic_p == NMG_VERTEXUSE_MAGIC) {
		NMG_CK_VERTEX(l->lu_p->down.vu_p->v_p);
		vg = l->lu_p->down.vu_p->v_p->vg_p;
d1096 2
a1097 2
		VMOVE(l->lg_p->min_pt, vg->coord);
		VMOVE(l->lg_p->max_pt, vg->coord);
d1099 1
a1099 1
		rt_bomb("in nmg_loop_g, loopuse has bad child\n");
d1132 1
d1139 3
a1141 2
	struct face_g *fg;
	struct loopuse *lu;
d1160 2
a1161 3

	lu = f->fu_p->lu_p;
	do {
d1168 1
a1168 3

		lu = lu->next;
	} while (lu != f->fu_p->lu_p);
d1194 3
a1196 5
	if (s->fu_p) {
		fu = s->fu_p;
		do {
			if (!fu->f_p->fg_p)
				nmg_face_bb(fu->f_p);
d1198 3
a1200 3
			fg = fu->f_p->fg_p;
			VMIN(sa->min_pt, fg->min_pt);
			VMAX(sa->max_pt, fg->max_pt);
d1202 5
a1206 6
			if (fu->next != s->fu_p &&
			    fu->next->f_p == fu->f_p)
				fu = fu->next->next;
			else
				fu = fu->next;
		} while (fu != s->fu_p);
d1208 3
a1210 5
	if (s->lu_p) {
		lu = s->fu_p->lu_p;
		do {
			if (!lu->l_p->lg_p)
				nmg_loop_g(lu->l_p);
d1212 2
a1213 6
			VMIN(sa->min_pt, lu->l_p->lg_p->min_pt);
			VMAX(sa->max_pt, lu->l_p->lg_p->max_pt);

			lu = lu->next;
		} while (lu != s->fu_p->lu_p);

d1215 6
a1220 13
	if (s->eu_p) {
		eu = s->eu_p;
		do {
			NMG_CK_EDGEUSE(eu);
			NMG_CK_EDGE(eu->e_p);

			vg = eu->vu_p->v_p->vg_p;
			NMG_CK_VERTEX_G(vg);

			VMINMAX(sa->min_pt, sa->max_pt, vg->coord);

			eu = eu->next;
		} while (eu != s->eu_p);
a1226 1

d1231 3
a1233 1
	if (!s->fu_p && !s->lu_p && !s->eu_p && !s->vu_p) {
d1236 1
a1236 1
		rt_bomb("exiting\n");
a1237 1

d1247 3
a1249 2
	struct shell *s;
	struct nmgregion_a *ra;
d1258 1
a1258 2
	s = r->s_p;
	do {
d1260 5
d1266 5
a1270 8
		VMIN(ra->min_pt, r->s_p->sa_p->min_pt);
		VMAX(ra->max_pt, r->s_p->sa_p->max_pt);

		s = s->next;
	} while (s != r->s_p);
}
/*	N M G _ E U S P L I T
 *	Split an edgeuse
d1279 1
a1279 3
 *	Before:
 *		oldeu
 *		.------------->
d1281 5
a1285 2
 *		 =============== (edge)
 *
d1287 1
a1287 1
 *		   oldeu->eumate
d1289 1
a1289 3
 *	After:
 *		oldeu(cw)   eu1
 *		.-------> .----->
d1291 7
a1297 4
 *	   (edge)========= ~~~~~~~(new edge)
 *
 *		  <-------. <-----.
 *		 oldeumate  eu1mate
d1312 2
d1320 1
a1320 1
	if (oldeu->radial_p != oldeu->eumate_p)
d1323 3
d1327 6
a1332 3
	if (*oldeu->up.magic_p == NMG_SHELL_MAGIC) {
		/* set the shell's edge pointer so that a "make edge" 
		 * operation will insert a new edge in the "appropriate" place
d1334 2
a1335 4
		if (oldeu->next != oldeu->eumate_p)
			oldeu->up.s_p->eu_p = oldeu->next;
		else
			oldeu->up.s_p->eu_p = oldeu->next->next;
d1337 10
a1346 2
		/* we make an edge from the new vertex to the vertex at the
		 * other end of the edge given
a1347 6
		if (v)
			eu1 = nmg_me(v,
			    oldeu->eumate_p->vu_p->v_p, oldeu->up.s_p);
		else
			eu1 = nmg_me((struct vertex *)NULL,
			    oldeu->eumate_p->vu_p->v_p, oldeu->up.s_p);
d1349 26
a1374 2
		/* now move the end of the old edge over to the new vertex */
		nmg_movevu(oldeu->eumate_p->vu_p, eu1->vu_p->v_p);
d1380 1
a1380 1
		rt_bomb("routine nmg_eusplit");
d1388 1
a1388 1
	else {
d1390 1
a1390 2
		NMG_CK_SHELL(s);
	}
d1394 1
d1398 1
d1401 3
d1407 19
a1425 5
	/* pick out the edge from the shell */
	DLLRM(s->eu_p, eu1);
	DLLRM(s->eu_p, eu2);
	if (s->eu_p == eu2)
		s->eu_p = (struct edgeuse *)NULL;
d1427 11
a1437 1
	oldeumate = oldeu->eumate_p;
d1439 1
a1439 9
	/* insert the new edge(uses) in the loop
	 * eu1 will become the mate to oldeumate on the existing edge.
	 * eu2 will become the mate of oldeu on the new edge.
	 * orientation and parentage are copied copied.
	 */
	eu1->last = oldeu;
	eu1->next = oldeu->next;
	eu1->next->last = eu1;
	oldeu->next = eu1;
a1445 4
	eu2->next = oldeumate->next;
	eu2->last = oldeumate;
	eu2->next->last = eu2;
	oldeumate->next = eu2;
d1452 1
a1452 4
	/* straighten out ownership of the edge.
	 * oldeu keeps the edge it had (and shares with eu2).
	 * oldeumate and eu1 share the new edge.
	 */
d1459 3
a1461 1
/*	N M G _ M O V E E U
d1492 1
a1492 1
	    	rt_bomb("edgeuses do not share vertices, cannot share edge\n");
a1522 3



d1524 1
d1599 7
a1605 2
/*	N M G _ J V
 *	Join two vertexes into one
d1608 2
a1609 1
struct vertex *v1, *v2;
d1611 1
a1611 1
	struct vertexuse *vu1, *vu2;
d1618 8
a1625 6
	/* tell all the vertexuses about their new vertex */
	vu1 = vu2 = v2->vu_p;
	do {
		vu2->v_p = v1;
		vu2 = vu2->next;
	} while (vu2 != vu1);
d1627 7
a1633 2
	/* link vertexuse list for v2 to v1's vertexuse list */
	vu1 = v1->vu_p;
a1634 5
	vu1->last->next = vu2->next;
	vu2->next->last = vu1->last;
	vu2->next = vu1;
	vu1->last = vu2;

d1736 1
a1736 1
		rt_bomb("bye");
d1742 10
a1751 3
/*	N M G _ M L V
 *	Make a new loop (with specified orientation) and
 *	vertex in shell or face.
a1767 3
	GET_LOOP(l);
	GET_LOOPUSE(lu1);
	GET_LOOPUSE(lu2);
d1772 1
a1773 1
	l->lu_p = lu1;
d1776 3
a1778 1
	lu1->magic = lu2->magic = NMG_LOOPUSE_MAGIC;
d1780 6
d1789 9
a1797 5
		if (p.s->vu_p) {
			lu1->down.vu_p = p.s->vu_p;
			p.s->vu_p->up.lu_p = lu1;
			p.s->vu_p = (struct vertexuse *)NULL;
			if (v) nmg_movevu(lu1->down.vu_p, v);
d1800 2
a1801 2
			if (v) lu1->down.vu_p = nmg_mvu(v, &lu1->magic);
			else lu1->down.vu_p = nmg_mvvu(&lu1->magic);
d1803 2
a1804 2
		lu2->down.vu_p = nmg_mvu(lu1->down.vu_p->v_p, &lu2->magic);
		lu1->up.magic_p = lu2->up.magic_p = magic;
d1806 5
d1814 2
a1815 2
		DLLINS(p.s->lu_p, lu2);
		DLLINS(p.s->lu_p, lu1);
d1817 1
a1817 2
		if (v) lu1->down.vu_p = nmg_mvu(v, &lu1->magic);
		else lu1->down.vu_p = nmg_mvvu(&lu1->magic);
d1819 7
a1825 1
		lu2->down.vu_p = nmg_mvu(lu1->down.vu_p->v_p, &lu2->magic);
d1832 2
a1833 2
		DLLINS(p.fu->fumate_p->lu_p, lu2);
		DLLINS(p.fu->lu_p, lu1);
d1835 1
a1835 1
		rt_bomb("unknown parent for loopuse!\n");
d1842 4
a1845 2
/*	N M G _ M O V E L T O F
 *	move first shell loopuse to an existing face
d1851 1
a1851 1
	struct loopuse *lu;
d1859 3
a1861 1
	NMG_CK_LOOPUSE(s->lu_p);
d1863 3
a1865 4
	DLLRM(s->lu_p, lu);
	if (s->lu_p == lu) {
		rt_bomb("Loopuses don't share parent shell!\n");
	}
d1867 2
a1868 8
	DLLINS(fu->lu_p, lu);

	DLLRM(s->lu_p, lu);
	if (s->lu_p == lu)
		s->lu_p = (struct loopuse *)NULL;

	fu = fu->fumate_p;
	DLLINS(fu->lu_p, lu);
d1871 3
a1873 1
/*	N M G _ C F A C E
d1903 2
d1909 3
a1911 1
		rt_bomb("trying to make bogus face\n");
d1915 4
a1918 2
		fu = nmg_mf(nmg_mlv(&s->magic, verts[n-1], OT_SAME));
		eu = nmg_meonvu(fu->lu_p->down.vu_p);
d1924 2
a1925 1
			eu = nmg_eusplit(verts[i], fu->lu_p->down.eu_p);
d1931 4
a1934 4
		fu = nmg_mf(nmg_mlv(&s->magic, (struct vertex *)NULL, OT_SAME));
		(void)nmg_meonvu(fu->lu_p->down.vu_p);

		eu = fu->lu_p->down.eu_p;
d1942 3
a1944 1
/*	N M G _ E S P L I T
d1946 1
d1964 1
d2010 1
a2010 1
			rt_bomb("Something's awry in nmg_esplit\n");
a2013 1

d2037 4
a2040 2
/*	N M G _ E I N S
 *	insert a new (zero length) edge at the begining of an existing edge
d2061 1
a2061 1
	struct edgeuse *eu1, *eu2, *eulist;
d2088 1
d2091 1
a2091 4
		DLLRM(s->eu_p, eu1);
		DLLRM(s->eu_p, eu2);
		if (s->eu_p == eu2)
			s->eu_p = (struct edgeuse *)NULL;
d2093 7
a2099 4
		eulist = eu;
		DLLINS(eulist, eu1);
		eulist = eu->eumate_p->next;
		DLLINS(eulist, eu2);
d2104 1
a2104 1
		rt_bomb("Cannot yet insert null edge in shell\n");
d2109 2
a2110 1
/*	F I N D _ V U _ I N _ F A C E
d2117 3
a2119 3
point_t pt;
struct faceuse *fu;
fastf_t tol;
d2121 5
a2125 3
	struct loopuse *lu;
	struct edgeuse *eu;
	vect_t		delta;
d2128 2
a2129 2
	lu = fu->lu_p;
	do {
d2131 6
a2136 2
		if (*lu->down.magic_p == NMG_VERTEXUSE_MAGIC) {
			VSUB2(delta, lu->down.vu_p->v_p->vg_p->coord, pt);
d2138 1
a2138 1
				return(lu->down.vu_p);
d2140 4
a2143 4
		else if (*lu->down.magic_p == NMG_EDGEUSE_MAGIC) {
			eu = lu->down.eu_p;
			do {
				VSUB2(delta, eu->vu_p->v_p->vg_p->coord, pt);
d2146 1
a2146 2
				eu = eu->next;
			} while (eu != lu->down.eu_p);
d2148 2
a2149 4
			rt_bomb("Bogus child of loop\n");

		lu = lu->next;
	} while (lu != fu->lu_p);
d2153 2
a2154 1
/*	N M G _ G L U E F A C E S
a2158 2
 *
 *
d2165 1
d2173 2
d2176 5
a2180 2
		NMG_CK_FACEUSE(fulist[i]);
		if (fulist[i]->s_p != s) {
d2185 5
a2189 3
		NMG_CK_LOOPUSE(fulist[i]->lu_p);
		if (*fulist[i]->lu_p->down.magic_p != NMG_EDGEUSE_MAGIC) {
			rt_bomb("Cannot glue edges of face on vertex\n");
d2191 2
a2192 1
			NMG_CK_EDGEUSE(fulist[i]->lu_p->down.eu_p);
d2197 4
a2200 2
	    eu = fulist[i]->lu_p->down.eu_p;
	    do {
d2202 1
a2202 3
		for (f_no=i+1 ; eu->radial_p == eu->eumate_p && f_no < n ;
		    ++f_no) {
			register struct edgeuse	*eu2;
d2204 6
a2209 7
			eu2 = fulist[f_no]->lu_p->down.eu_p;
			do {
			    if (EDGESADJ(eu, eu2))
			    	nmg_moveeu(eu, eu2);

			    eu2 = eu2->next;
			} while (eu2 != fulist[f_no]->lu_p->down.eu_p);
d2211 2
d2214 21
a2234 2
		eu = eu->next;
	    } while (eu != fulist[i]->lu_p->down.eu_p);
d2239 1
a2239 1
 *			N M G _ S _ T O _ V L I S T
d2241 1
a2241 4
 *  poly_markers =
 *	0 for vectors
 *	1 for polygons
 *	2 for polygons and surface normals drawn with vectors
d2243 1
a2243 1
nmg_s_to_vlist( vhead, s, poly_markers )
d2245 1
a2245 2
struct shell	*s;
int		poly_markers;
a2246 3
	struct faceuse	*fu;
	struct face_g	*fg;
	struct loopuse	*lu;
d2251 1
d2253 6
a2258 6
	NMG_CK_SHELL(s);
	if (s->vu_p)  {
		if (s->fu_p || s->lu_p || s->eu_p) {
			rt_bomb("nmg_s_to_vlist:  shell with vu also has other pointers\n");
		}
		vu = s->vu_p;
d2263 6
a2268 3
		if( vg )  {
			/* Only thing in this shell is a point */
			NMG_CK_VERTEX_G(vg);
d2270 3
a2274 1
		return;
d2276 3
a2278 3
	if( !(s->fu_p) )  {
		rt_log("nmg_s_to_vlist: shell with no faces?\n");
		return;
d2280 1
a2280 3
	if (s->lu_p || s->eu_p || s->vu_p) {
		rt_bomb("nmg_s_to_vlist:  shell with fu also has other pointers\n");
	}
d2282 16
a2297 14
	fu = s->fu_p;
	do {
	    /* Consider this face */
	    NMG_CK_FACEUSE(fu);
	    NMG_CK_FACE(fu->f_p);
	    fg = fu->f_p->fg_p;
	    NMG_CK_FACE_G(fg);
	    if (fu->orientation == OT_SAME) {
		lu = fu->lu_p;
		do {
			int		isfirst;
			struct vertex_g	*first_vg;
			point_t		centroid;
			int		npoints;
d2299 21
a2319 3
			/* Consider this loop */
			NMG_CK_LOOPUSE(lu);
			eu = lu->down.eu_p;
d2321 16
a2336 29
			isfirst = 1;
			first_vg = (struct vertex_g *)0;
			npoints = 0;
			VSETALL( centroid, 0 );
			do  {
				/* Consider this edge */
				vu = eu->vu_p;
				NMG_CK_VERTEXUSE(vu);
				v = vu->v_p;
				NMG_CK_VERTEX(v);
				vg = v->vg_p;
				if( !vg ) {
					eu = eu->next;
					continue;
				}
				NMG_CK_VERTEX_G(vg);
				VADD2( centroid, centroid, vg->coord );
				npoints++;
				if (isfirst) {
					if( poly_markers) {
						/* Insert a "start polygon, normal" marker */
						ADD_VL( vhead, fg->N, 2 );
						ADD_VL( vhead, vg->coord, 3 );	/* move */
					} else {
						/* move */
						ADD_VL( vhead, vg->coord, 0 );
					}
					isfirst = 0;
					first_vg = vg;
d2338 2
a2339 6
					if( poly_markers) {
						ADD_VL( vhead, vg->coord, 4 );
					} else {
						/* Draw */
						ADD_VL( vhead, vg->coord, 1 );
					}
d2341 5
a2345 8
				eu = eu->next;
			} while(eu != lu->down.eu_p);

			/* Draw back to the first vertex used */
			if( !isfirst && first_vg )  {
				if( poly_markers )  {
					/* Draw, end polygon */
					ADD_VL( vhead, first_vg->coord, 5 );
d2348 1
a2348 1
					ADD_VL( vhead, first_vg->coord, 1 );
d2351 10
a2360 12
			if( poly_markers > 1 && npoints > 2 )  {
				/* Draw surface normal as a little vector */
				double	f;
				vect_t	tocent;
				f = 1.0 / npoints;
				VSCALE( centroid, centroid, f );
				ADD_VL( vhead, centroid, 0 );	/* move */
				VSUB2( tocent, first_vg->coord, centroid );
				f = MAGNITUDE( tocent ) * 0.5;
				VSCALE( tocent, fg->N, f );
				VADD2( centroid, centroid, tocent );
				ADD_VL( vhead, centroid, 1 );	/* draw */
d2362 16
d2379 44
a2422 5
			lu = lu->next;
		}while (lu != fu->lu_p);
	    }
	    fu = fu->next;
	} while (fu != s->fu_p);
d2425 19
a2443 1
/*	F I N D E U
d2452 2
a2453 2
	struct vertexuse *vu;
	struct edgeuse *eu;
a2458 1

d2463 1
a2463 2
	vu = v1->vu_p;
	do {
d2471 3
a2473 2
		if (rt_g.NMG_debug & DEBUG_FINDEU &&
		    *vu->up.magic_p == NMG_EDGEUSE_MAGIC) {
d2483 4
a2486 4
		if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC && 
		    vu->up.eu_p != eup && vu->up.eu_p->eumate_p != eup &&
		    vu->up.eu_p->eumate_p->vu_p->v_p == v2  &&
		    vu->up.eu_p->eumate_p == vu->up.eu_p->radial_p) {
a2491 1
			eu = vu->up.eu_p;
d2511 1
a2511 2
		vu = vu->next;
	} while (vu != v1->vu_p);
a2512 1

d2519 3
a2521 3


/*	N M G _ C M F A C E
d2588 3
a2590 3
struct shell *s;
struct vertex **verts[];
int n;
d2594 2
d2601 3
a2603 1
		rt_bomb("trying to make bogus face\n");
d2608 3
a2610 3
		rt_log("in %s at %d, null pointer to array start\n",
			__FILE__, __LINE__);
		rt_bomb("nmg_cmface\n");
d2621 3
a2623 3
			rt_log("in %s at %d, null ptr to ptr to struct vertex\n",
				__FILE__, __LINE__);
			rt_bomb("nmg_cmface\n");
d2627 2
a2628 2

	fu = nmg_mf(nmg_mlv(&s->magic, *verts[n-1], OT_SAME));
d2631 4
a2634 1
	eu = nmg_meonvu(fu->lu_p->down.vu_p);
d2636 3
a2638 1
	if (!(*verts[n-1]))
d2640 1
d2643 4
a2647 2
		euold = fu->lu_p->down.eu_p;

a2663 1

d2665 1
a2665 1
			else 
d2669 1
a2670 1

a2678 1

d2692 5
a2696 1

d2703 5
d2716 1
a2716 2
	vu = vup;
	do {
d2719 2
a2720 4
			rt_bomb("a vertexuse in my list doesn't share my vertex\n");
		vu = vu->next;
	} while (vu != vup);

d2724 1
d2730 6
d2747 1
a2747 1
		rt_bomb("vertexuse denies parent\n");
d2749 2
a2750 2
	if (!vu->next)
		rt_bomb("vertexuse has null next pointer\n");
d2752 2
a2753 2
	if (vu->next->magic != NMG_VERTEXUSE_MAGIC)
		rt_bomb("vertexuse next is bad vertexuse\n");
d2755 2
a2756 2
	if (vu->next->last != vu)
		rt_bomb("vertexuse not last of next vertexuse\n");
d2763 1
a2763 2


d2770 1
d2777 5
d2791 5
d2801 2
d2806 2
d2826 7
a2832 2
void nmg_veu(eup, up)
struct edgeuse *eup;
d2839 2
a2840 1
	struct edgeuse *eu;
d2842 1
a2842 2
	eu = eup;
	do {
d2848 8
a2855 7
		if (!eu->next)
			rt_bomb("edgeuse has Null \"next\" pointer\n");
		if (eu->next->magic != NMG_EDGEUSE_MAGIC)
			rt_bomb("edgeuse next is bad edgeuse\n");
		if (eu->next->last != eu)
		    if (eu->next->last)
			rt_bomb("next edgeuse has last that points elsewhere\n");
d2857 3
a2859 3
			rt_bomb("next edgeuse has NULL last\n");

		if (eu->eumate_p->magic != NMG_EDGEUSE_MAGIC)
d2864 1
a2864 1
		if (eu->radial_p->magic != NMG_EDGEUSE_MAGIC)
d2883 2
d2886 5
a2890 3
		eu = eu->next;
	} while (eu != eup);
}
d2902 6
d2919 1
d2926 1
d2931 1
d2938 7
a2944 7
void nmg_vlu(lulist, up)
struct loopuse *lulist;
union {
	struct shell	*s;
	struct faceuse	*fu;
	long		*magic_p;
} up;
d2947 2
a2948 3
	
	lu = lulist;
	do {
d2951 1
a2951 1
		if (lu->up.magic_p != up.magic_p)
d2954 4
a2957 4
		if (!lu->next)
			rt_bomb("loopuse has null next pointer\n");
		else if (lu->next->last != lu)
			rt_bomb("next loopuse has last pointing somewhere else\n");
d2962 1
a2962 1
		if (lu->lumate_p->magic != NMG_LOOPUSE_MAGIC)
d2987 8
a2994 4
		if (*lu->down.magic_p == NMG_EDGEUSE_MAGIC)
			nmg_veu(lu->down.eu_p, lu);
		else if (*lu->down.magic_p == NMG_VERTEXUSE_MAGIC)
			nmg_vvu(lu->down.vu_p, lu);
d2996 5
a3000 3
		lu = lu->next;
	} while (lu != lulist);
}
d3020 5
a3024 1

d3037 2
a3038 1
	for (fu = fup; fu && fu != f->fu_p && fu->next != fup; fu = fu->next);
d3041 1
d3046 1
a3046 1

d3057 2
a3058 2
void nmg_vfu(fulist, s)
struct faceuse *fulist;
d3062 2
a3063 3
	
	fu = fulist;
	do {
d3071 4
a3074 4
		if (!fu->next) {
			rt_bomb("faceuse next is NULL\n");
		} else if (fu->next->last != fu) {
			rt_bomb("faceuse->next->last != faceuse\n");
d3080 1
a3080 1
		if (fu->fumate_p->magic != NMG_FACEUSE_MAGIC)
d3103 2
a3104 5
		NMG_CK_LOOPUSE(fu->lu_p);
		nmg_vlu(fu->lu_p, fu);
		
		fu = fu->next;
	} while (fu != fulist);
d3112 2
a3113 2
void nmg_vshell(sp, r)
struct shell *sp;
d3119 1
a3119 2
	s = sp;
	do {
d3127 5
a3131 5
		if (!s->next) {
			rt_bomb("nmg_vshell: Shell's next ptr is null\n");
		} else if (s->next->last != s) {
			rt_log("next shell's last(%8x) is not me (%8x)\n",
				s->next->last, s);
d3156 3
a3158 1
			if (s->fu_p || s->lu_p || s->eu_p) {
d3165 4
a3168 19
		if (s->fu_p) {
			NMG_CK_FACEUSE(s->fu_p);
			nmg_vfu(s->fu_p, s);
		}

		if (s->lu_p) {
			NMG_CK_LOOPUSE(s->lu_p);
			nmg_vlu(s->lu_p, s);
		}

		if (s->eu_p) {
			NMG_CK_EDGEUSE(s->eu_p);
			nmg_veu(s->eu_p, s);
		}



		s = s->next;
	} while (s != sp);
d3173 2
a3174 1
/*	N M G _ V R E G I O N
d3178 2
a3179 2
void nmg_vregion(rp, m)
struct nmgregion *rp;
d3183 2
a3184 2
	r = rp;
	do {
d3195 1
a3195 4
		if (r->s_p) {
			NMG_CK_SHELL(r->s_p);
			nmg_vshell(r->s_p, r);
		}
d3197 2
a3198 2
		if (r->next->last != r) {
			rt_bomb("next nmgregion's last is not me\n");
d3200 1
a3200 2
		r = r->next;
	} while (r != rp);
d3214 1
a3214 2
	NMG_CK_REGION(m->r_p);
	nmg_vregion(m->r_p, m);
@


1.14
log
@modified nmg_klu to support nmg_demote_lu.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.13 90/05/09 01:07:24 butler Exp $ (BRL)";
d699 12
a710 3
	if (lu1->down.magic_p && *lu1->down.magic_p == NMG_VERTEXUSE_MAGIC) {
		nmg_kvu(lu1->down.vu_p);
		nmg_kvu(lu2->down.vu_p);
a711 7
	else if (lu1->down.magic_p && *lu1->down.magic_p == NMG_EDGEUSE_MAGIC) {
		/* delete all edgeuse in the loopuse (&mate) */
		while (lu1->down.eu_p)
			nmg_keu(lu1->down.eu_p);
	}
	else
		rt_bomb("unknown type for loopuse child\n");
@


1.13
log
@support changes for nmg_bool.c
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: nmg_mk.c,v 1.12 90/03/15 01:47:21 mike Exp $ (BRL)";
d670 2
a671 1
 *	if the loop contains any edgeuses they are placed in the parent shell
d673 3
d695 1
a695 1
	if (*lu1->down.magic_p != *lu2->down.magic_p)
d699 1
a699 1
	if (*lu1->down.magic_p == NMG_VERTEXUSE_MAGIC) {
d703 1
a703 38
	else if (*lu1->down.magic_p == NMG_EDGEUSE_MAGIC) {
#if 0
		/* get the parent shell */
		if (*lu1->up.magic_p == NMG_SHELL_MAGIC)
			s = lu1->up.s_p;
		else if (*lu1->up.magic_p == NMG_FACEUSE_MAGIC) {
			if (lu1->up.fu_p->s_p->magic != NMG_SHELL_MAGIC)
				rt_bomb("faceuse of loopuse does't have shell for parent\n");
			else
				s = lu1->up.fu_p->s_p;
		} else {
			rt_bomb("Cannot identify parent\n");
		}

		/* move all edgeuses (&mates) to shell (in order so that we
		 * can )
		 */
		while (lu1->down.eu_p) {
			/* move edgeuse & mate to parent shell */
			DLLRM(lu1->down.eu_p, eu1);
			if (lu1->down.eu_p == eu1)
				lu1->down.eu_p = (struct edgeuse *)NULL;

			if (eu1->eumate_p->up.lu_p != lu2)
				rt_bomb("edgeuse mates don't share loop\n");

			lu2->down.eu_p = eu1->eumate_p;
			DLLRM(lu2->down.eu_p, eu2);
			if (lu2->down.eu_p == eu2)
				lu2->down.eu_p = (struct edgeuse *)NULL;

			eu1->up.s_p = eu2->up.s_p = s;
			DLLINS(s->eu_p, eu2);
			DLLINS(s->eu_p, eu1);
		}
		if (lu2->down.eu_p)
			rt_bomb("loopuse mates don't have same # of edges\n");
#else
a706 1
#endif
d726 1
a726 1
		DLLRM(fu->lu_p, p);
@


1.12
log
@Modified to use opcodes of 2/3/4/5 for vlists.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: nmg_mk.c,v 1.11 90/03/15 01:44:17 mike Locked $ (BRL)";
d1108 6
a1113 4
	eu = l->lu_p->down.eu_p;
	do {
		vg = eu->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G(vg);
d1115 1
a1115 1
		VMINMAX(l->lg_p->min_pt, l->lg_p->max_pt, vg->coord);
d1117 10
a1126 2
		eu = eu->next;
	} while (eu != l->lu_p->down.eu_p);
a1187 1
		/*		if (!lu->l_p->lg_p) */
d1190 4
a1193 2
		VMIN(fg->min_pt, lu->l_p->lg_p->min_pt);
		VMAX(fg->max_pt, lu->l_p->lg_p->max_pt);
d1468 4
a1471 1
	if (eusrc->e_p == eudst->e_p && eusrc->radial_p == eudst)
d1474 3
d1478 1
d1650 4
a1653 4
/* #define DEBUG_INS */
#ifdef DEBUG_INS
		rt_log("nmg_tbl Inserting %8x\n", p);
#endif
a2056 7
#if 0
struct vertex *nmg_find_v_in_face(pt, fu)
point_t pt;
struct faceuse *fu;
{
	struct loopuse *lu;
	struct edgeuse *eu;
a2057 26
	NMG_CK_FACEUSE(fu);
	lu = fu->lu_p;
	do {
		NMG_CK_LOOPUSE(lu);
		if (*lu->down.magic_p == NMG_VERTEXUSE_MAGIC) {
			if (VAPPROXEQUAL(pt, lu->down.vu_p->v_p->vg_p->coord,
			    VDIVIDE_TOL))
				return(lu->down.vu_p->v_p);
		}
		else if (*lu->down.magic_p == NMG_EDGEUSE_MAGIC) {
			eu = lu->down.eu_p;
			do {
				if (VAPPROXEQUAL(pt, eu->vu_p->v_p->vg_p->coord,
				    VDIVIDE_TOL))
					return(eu->vu_p->v_p);
				eu = eu->next;
			} while (eu != lu->down.eu_p);
		} else
			rt_bomb("Bogus child of loop\n");

		lu = lu->next;
	} while (lu != fu->lu_p);
	return ((struct vertex *)NULL);
}
#endif

d2061 2
a2062 1
 *	coordinates given
d2064 1
a2064 1
struct vertexuse *nmg_find_vu_in_face(pt, fu)
d2067 1
d2071 1
d2078 2
a2079 2
			if (VAPPROXEQUAL(pt, lu->down.vu_p->v_p->vg_p->coord,
			    VDIVIDE_TOL))
d2085 2
a2086 2
				if (VAPPROXEQUAL(pt,
				    eu->vu_p->v_p->vg_p->coord, VDIVIDE_TOL))
d2296 1
a2296 1
static struct edgeuse *findeu(v1, v2, s)
d2299 1
d2308 5
d2315 16
a2330 1
		/* look for an edgeuse pair on the vertices we want
d2334 1
d2345 12
a2356 3
			    eu->up.lu_p->up.fu_p->s_p == s)
			    	return(eu);
#if 1
d2358 1
d2360 1
a2360 1
#endif
d2365 4
d2478 2
d2489 3
d2497 1
a2497 1
			eur = findeu(*verts[i+1], *verts[i], s);
d2499 12
a2510 1
			if (eur) nmg_moveeu(eur, eu);
d2512 4
d2518 4
d2524 8
@


1.11
log
@debugging
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /n/spark/m/cad/librt/RCS/nmg_mk.c,v 1.10 90/03/14 22:37:08 butler Exp $ (BRL)";
d2170 4
a2173 1
 *  poly_markers = 0 for vectors, 1 for polygon markers
a2186 2
	int		isfirst;
	struct vertex_g	*first_vg;
d2224 5
d2235 3
a2237 1
			do {
d2244 14
a2257 7
				if( vg ) {
					NMG_CK_VERTEX_G(vg);
					if (isfirst) {
						if( poly_markers) {
							/* Insert a "start polygon, normal" marker */
							ADD_VL( vhead, fg->N, 2 );
						}
d2259 6
a2264 2
						isfirst = 0;
						first_vg = vg;
d2266 1
d2275 7
a2281 1
				ADD_VL( vhead, first_vg->coord, 1 );
d2283 13
a2302 1

@


1.10
log
@nmg_mm, clockwise ordering of nmg_cmface/cface verticies
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /n/spark/m/cad/librt/RCS/nmg_mk.c,v 1.9 90/03/14 21:19:30 mike Exp $ (BRL)";
d2283 3
d2289 5
d2299 4
@


1.9
log
@Established clockwise rule for nmg_cface() and mkg_cmface().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: nmg_mk.c,v 1.8 90/03/14 20:45:14 mike Locked $ (BRL)";
d1273 11
d1285 15
d1843 1
a1843 1
unsigned n;
d1847 1
a1847 1
	unsigned i;
d1855 1
a1855 1
		fu = nmg_mf(nmg_mlv(&s->magic, verts[0], OT_SAME));
a2285 4

			VPRINT("checking ", vu->v_p->vg_p->coord);
			VPRINT("and ", vu->up.eu_p->eumate_p->vu_p->v_p->vg_p->coord);

d2369 1
a2369 1
unsigned n;
d2373 1
a2373 1
	unsigned i;
d2392 1
a2392 1
				/* validate the structure pointers */
a2393 1
				NMG_CK_VERTEX_G((*verts[i])->vg_p);
d2403 1
a2403 1
	fu = nmg_mf(nmg_mlv(&s->magic, *verts[0], OT_SAME));
@


1.8
log
@Added nmg_mm().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: nmg_mk.c,v 1.7 90/03/08 04:41:06 butler Locked $ (BRL)";
d1803 10
d1832 2
a1833 2
		if (!verts[0])
			verts[0] = eu->vu_p->v_p;
d1835 1
a1835 1
		for (i = 1 ; i < n ; ++i) {
d2282 2
a2283 2
 *	"s" is the
 *	parent shell for the new face.  The face will consist of a single loop
d2309 34
d2385 2
a2386 2
	if (!(*verts[0]))
		*verts[0] = eu->vu_p->v_p;
d2388 1
a2388 1
	for (i = 1 ; i < n ; ++i) {
d2397 1
a2397 1
			eur = findeu(*verts[i-1], *verts[i], s);
@


1.7
log
@added nmg_cmface
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: nmg_mk.c,v 1.6 90/02/28 01:54:57 butler Locked $ (BRL)";
d120 18
@


1.6
log
@Added nmg_gluefaces() and nmg_s_to_vlist().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: nmg_mk.c,v 1.5 90/02/27 21:02:30 butler Locked $ (BRL)";
d659 1
d661 1
d2161 6
a2166 5
		/* Consider this face */
		NMG_CK_FACEUSE(fu);
		NMG_CK_FACE(fu->f_p);
		fg = fu->f_p->fg_p;
		NMG_CK_FACE_G(fg);
d2206 2
a2207 1
		fu = fu->next;
d2212 623
@


1.5
log
@preliminary boolean operations (Debug release)
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /usr/people/butler/nmg2/RCS/nmg_mk.c,v 1.6 89/12/15 17:09:13 butler Exp $ (BRL)";
d55 1
d2053 155
@


1.4
log
@Added more comments and #include <stdio.h> required now by nmg.h
@
text
@d30 4
a35 4
 *
 *
 *
 *
d249 3
d289 1
a289 1
		eu1->vu_p = nmg_mvvu(&eu2->magic);
d438 1
a442 1

a453 1

d679 1
d688 2
d692 3
a694 1
		/* move all edgeuses (&mates) to shell (in order!) */
d715 5
d745 1
a745 3
		if (fu->lu_p == p) {
			fu->lu_p = (struct loopuse *)NULL;
		}
d827 1
d834 1
d886 1
a886 1
		 * to disappear.
d1266 3
d1275 3
a1284 2
	struct vertexuse *vu1, *vu2;
	struct edge	*e;
d1286 3
a1288 2
	*eu2,
	*tmpeu;
d1327 4
a1330 7

	if (!v) {
		/* create a new vertex */
		GET_VERTEX(v);
		v->magic = NMG_VERTEX_MAGIC;
		v->vu_p = (struct vertexuse *)NULL;
		v->vg_p = (struct vertex_g *)NULL;
d1333 1
a1333 5
	GET_VERTEXUSE(vu1);
	GET_VERTEXUSE(vu2);
	GET_EDGE(e);
	GET_EDGEUSE(eu1);
	GET_EDGEUSE(eu2);
d1335 7
a1341 1
	tmpeu = oldeu->eumate_p;
d1343 9
a1351 5
	vu1->magic = NMG_VERTEXUSE_MAGIC;
	vu2->magic = NMG_VERTEXUSE_MAGIC;
	e->magic = NMG_EDGE_MAGIC;
	eu1->magic = NMG_EDGEUSE_MAGIC;
	eu2->magic = NMG_EDGEUSE_MAGIC;
d1353 5
a1357 4
	/* set up first vertexuse */
	vu1->v_p = v;
	vu1->vua_p = (struct vertexuse_a *)NULL;
	vu1->up.eu_p = eu1;
d1359 1
a1359 4
	/* set up second vertexuse */
	vu2->v_p = v;
	vu2->vua_p = (struct vertexuse_a *)NULL;
	vu2->up.eu_p = eu2;
d1361 6
a1366 5
	/* link vertexuses into front of vertex's vertexuse list */
	DLLINS(v->vu_p, vu2);
	DLLINS(v->vu_p, vu1);

	/* insert edges into loops */
d1368 1
a1368 1
	eu1->last = oldeu;
a1369 22
	eu1->next->last = eu1;

	eu2->next = tmpeu->next;
	eu2->last = tmpeu;
	tmpeu->next = eu2;
	eu2->next->last = eu2;


	e->magic = NMG_EDGE_MAGIC;
	e->eu_p = eu1;
	e->eg_p = (struct edge_g *)NULL;

	/* re-arrange edge pointers (insert new, transfer old) */
	eu2->e_p = oldeu->e_p;
	eu1->e_p = tmpeu->e_p = e;

	oldeu->radial_p = oldeu->eumate_p = eu2;
	tmpeu->radial_p = tmpeu->eumate_p = eu1;

	eu1->radial_p = eu1->eumate_p = tmpeu;
	eu2->radial_p = eu2->eumate_p = oldeu;

a1370 2
	eu2->up.magic_p = tmpeu->up.magic_p;

d1372 3
a1374 1
	eu2->orientation = tmpeu->orientation;
d1376 6
a1381 1
	eu1->eua_p = (struct edgeuse_a *)NULL;
d1383 2
d1386 6
a1391 2
	eu1->vu_p = vu1;
	eu2->vu_p = vu2;
a1392 10
	/* make parent point to NEW edgeuse */
	if (*oldeu->up.magic_p == NMG_LOOPUSE_MAGIC) {
		oldeu->up.lu_p->down.eu_p = eu1;
		tmpeu->up.lu_p->down.eu_p = eu2;
	} else if (*oldeu->up.magic_p == NMG_SHELL_MAGIC)
		oldeu->up.s_p->eu_p = eu1;
	else {
		rt_log("in %s at %d edge has unknown parent\n", __FILE__,
		    __LINE__);
	}
d1399 2
a1400 5
 *	used by eudst.  eusrc is made to be immediately radial to eudst
 *	if eusrc does not share the same vertices as eudst, the vertexuses
 *	are moved to the vertices used by eudst and it's mate (eusrc will use
 *	the same vertex as eudst).  Perhaps this is not the way things should
 *	be done? BUG?
d1419 2
a1420 5
		/* edgeuses do NOT share verticies.  We will force the
	    	 * issue.  This may not be correct behavior. BUG?
	    	 */
		nmg_movevu(eusrc->vu_p, eudst->vu_p->v_p);
		nmg_movevu(eusrc->eumate_p->vu_p, eudst->eumate_p->vu_p->v_p);
d1446 1
a1568 2
	register int i;

d1570 3
a1572 2
		b->buffer = (long **)rt_calloc(b->blen=64, sizeof(p), "pointer table");
		b->next = 0;
d1574 3
d1578 13
d1592 1
a1592 1
		if (b->next >= b->blen)
d1597 1
a1597 1
		b->buffer[i=b->next++] = p;
d1600 10
a1609 2
		for (i=0 ; i < b->next ; ++i)
			if (b->buffer[i] == p) return(i);
d1611 40
d1665 2
a1666 1
 *	Make a new loop, vertex in shell or face
d1668 1
a1668 1
struct loopuse *nmg_mlv(magic, v)
d1671 1
d1711 1
d1730 2
d1733 2
d1772 1
d1774 8
a1781 3
 *	parent shell for the new face.  the face will consist of a single loop
 *	made from edges between the n vertices.  If an entry in the array is
 *	null, a new vertex will be created for that point.
d1798 2
a1799 2
		fu = nmg_mf(nmg_mlv(&s->magic, verts[0]));
		nmg_meonvu(fu->lu_p->down.vu_p);
d1801 2
a1802 2
		for (i = 1 ; i < n ; ++i)
			nmg_eusplit(verts[i], fu->lu_p->down.eu_p);
d1804 6
d1811 2
a1812 2
		fu = nmg_mf(nmg_mlv(&s->magic, (struct vertex *)NULL));
		nmg_meonvu(fu->lu_p->down.vu_p);
d1816 1
a1816 1
			nmg_eusplit((struct vertex *)NULL, eu);
d1827 3
a1829 1
 *	I'm not yet sure that radial relationships are preserved by this. BUG
d1835 8
a1842 4
	struct edgeuse *eu1, *eu2;
	struct edge *ne1, *ne2;
	struct vertex *v1;
	int breakloop = 0;
d1844 4
a1847 4
	NMG_CK_EDGE(e);
	if (v) {
		NMG_CK_VERTEX(v);
	}
d1849 3
a1851 5
	eu1 = e->eu_p;
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_VERTEXUSE(eu1->vu_p);
	NMG_CK_VERTEX(eu1->vu_p->v_p);
	v1 = eu1->vu_p->v_p;
d1853 13
a1865 3
	eu2 = nmg_eusplit(v, eu1);
	ne1 = eu1->e_p;
	ne2 = eu2->e_p;
d1867 1
a1867 1
	if (!v) v = eu2->vu_p->v_p;
d1869 5
a1873 13
	while (!breakloop && eu1->e_p != e) {
		eu1 = e->eu_p;
		NMG_CK_EDGEUSE(eu1);
		NMG_CK_VERTEXUSE(eu1->vu_p);
		NMG_CK_VERTEX(eu1->vu_p->v_p);
		if (eu1->vu_p->v_p != v1) {
			eu1 = eu1->eumate_p;
			NMG_CK_EDGEUSE(eu1);
			NMG_CK_VERTEXUSE(eu1->vu_p);
			NMG_CK_VERTEX(eu1->vu_p->v_p);
			if (eu1->vu_p->v_p != v1) {
				rt_log("Not all uses of edge share vertices\n");
				rt_bomb("Bad NMG structure\n");
d1875 12
d1888 1
a1888 1
		eu2 = nmg_eusplit(v, eu1);
a1889 2
		/* did we just split the last edgeuse pair? */
		if (eu1->e_p == e) breakloop = 1;
d1891 6
a1896 5
		nmg_moveeu(ne1->eu_p, eu1);
		nmg_moveeu(ne2->eu_p, eu2);
	}
	return(ne1);
}
d1898 8
d1907 2
d1911 3
d1982 2
a1983 6
/*	F I N D _ V _ I N _ F A C E
 *
 *	try to find a vertex in a face wich appoximately matches the
 *	coordinates given
 */
struct vertex *find_v_in_face(pt, fu)
d1995 2
a1996 1
			if (VAPPROXEQUAL(pt, lu->down.vu_p->v_p->vg_p->coord, VDIVIDE_TOL))
d2002 2
a2003 1
				if (VAPPROXEQUAL(pt, eu->vu_p->v_p->vg_p->coord, VDIVIDE_TOL))
d2014 1
d2016 1
a2016 2
/*	P O L Y S E C T
 *	intersect two polygons and split them along intersection
d2018 2
d2021 3
a2023 3
static void polysect(b1, b2, fu1, fu2)
struct nmg_ptbl *b1, *b2;	/* table of vertexuses on intercept line */
struct faceuse *fu1, *fu2;
d2025 2
a2026 6
	struct loopuse *lu_start, *lu, *plu;
	struct edgeuse *eu_start, *eu;
	struct vertex *v;
	point_t pt;
	vect_t vect, delta;
	fastf_t mag, dist;
d2028 2
a2029 14
#define DEBUG_POLYSECT 1
#ifdef DEBUG_POLYSECT
	int status;
	struct vertex_g *vg1, *vg2;
	plane_t plane;
	VMOVEN(plane, fu2->f_p->fg_p->N, 4);
	rt_log("\nPlane: %fx + %fy + %fz = %f\n",plane[X], plane[Y], plane[Z],
		plane[H]);
#endif
	NMG_CK_FACE_G(fu2->f_p->fg_p);
	NMG_CK_FACE_G(fu1->f_p->fg_p);

	/* process each loop in face 1 */
	lu_start = lu = fu1->lu_p;
d2031 1
a2031 2

		/* loop overlaps intersection face? */
d2033 6
a2038 14
			/* this is most likely a loop inserted when we split
			 * up fu2 wrt fu1 (we're now splitting fu1 wrt fu2)
			 */
			VMOVE(pt, lu->down.vu_p->v_p->vg_p->coord);
			mag = NMG_DIST_PT_PLANE(pt, fu2->f_p->fg_p->N);
			if (NEAR_ZERO(mag, VDIVIDE_TOL) &&
			    nmg_tbl(b1, TBL_LOC, &lu->down.vu_p->magic) < 0) {
				nmg_tbl(b1, TBL_INS, &lu->down.vu_p->magic);
			    	rt_log("I actually copied a vertex loop to another face!*************\n");
			    }
		} else {

			/* process each edge in loop of face 1 */
			eu_start = eu = lu->down.eu_p;
d2040 7
a2046 6
				NMG_CK_EDGEUSE(eu);
				/* we check to see if each edge crosses the 
				 * plane of face 2.
				 */
				VMOVE(pt, eu->eumate_p->vu_p->v_p->vg_p->coord);
				VSUB2(vect, pt, eu->vu_p->v_p->vg_p->coord);
a2047 96
#ifdef DEBUG_POLYSECT
	vg1 = eu->vu_p->v_p->vg_p;
	vg2 = eu->eumate_p->vu_p->v_p->vg_p;
	rt_log("Testing %f %f %f -> %f %f %f\n",
		vg1->coord[X], vg1->coord[Y], vg1->coord[Z],
		vg2->coord[X], vg2->coord[Y], vg2->coord[Z]);

				if ((status=rt_isect_ray_plane(&dist,
					eu->vu_p->v_p->vg_p->coord, vect,
					fu2->f_p->fg_p->N)) >= 0){

	rt_log("\tStatus of rt_isect_ray_plane: %d dist: %f\n", status, dist);
#else
                                if (rt_isect_ray_plane(&dist,
                                	eu->vu_p->v_p->vg_p->coord, vect,
                                	fu2->f_p->fg_p->N) >= 0){
#endif
					/* the ray defined by the edgeuse
					 * intersects the plane f2.  Check to
		                         * see if the distance to intersection
					 * is between limits of the endpoints
					 * of this edge(use).
					 */
					VSCALE(delta, vect, dist);
					mag = MAGNITUDE(delta);
					if (fabs(mag) < SQRT_SMALL_FASTF) {
						/* vertex is on intersect plane/line */
						if (nmg_tbl(b1, TBL_LOC, &eu->vu_p->magic) < 0)
							nmg_tbl(b1, TBL_INS, &eu->vu_p->magic);

						/* insert vertex into other shell */
						plu = nmg_mlv(&fu2->magic, eu->vu_p->v_p);
						/* make sure this vertex is in other face's list of
						 * points to deal with
						 */
						nmg_tbl(b2, TBL_INS, &plu->down.vu_p->magic);
					}
					else if (dist < 1.0) {
						/* the line segment defined by this edge 
						 * crosses the other plane.  We insert a new
						 * vertex at the point of intersection.
						 */
#ifdef DEBUG_POLYSECT
	rt_log("Splitting %f,%f,%f <-> %f,%f,%f\n",
		vg1->coord[X], vg1->coord[Y], vg1->coord[Z],
		vg2->coord[X], vg2->coord[Y], vg2->coord[Z]);
#endif
						
						/* if we can't find the appropriate vertex in the
						 * other face, we'll build a new vertex.  Otherwise
						 * we re-use an old one.
						 */
						VMOVE(pt, eu->vu_p->v_p->vg_p->coord);
						VADD2(pt, pt, delta);
						v=find_v_in_face(pt, fu2);
						nmg_esplit(v, eu->e_p);
						if (!v) {

							nmg_vertex_gv(eu->eumate_p->vu_p->v_p, pt);
							/* stick this vertex in the other shell
							 * and make sure it is in the other shell's
							 * list of vertices on the instersect line
							 */
							plu = nmg_mlv(&fu2->magic, eu->eumate_p->vu_p->v_p);
							nmg_tbl(b2, TBL_INS, &plu->down.vu_p->magic);
						}
#ifdef DEBUG_POLYSECT
	vg1 = eu->vu_p->v_p->vg_p;
	vg2 = eu->eumate_p->vu_p->v_p->vg_p;
	rt_log("\tNow %f,%f,%f <-> %f,%f,%f\n",
		vg1->coord[X], vg1->coord[Y],vg1->coord[Z],
		vg2->coord[X], vg2->coord[Y], vg2->coord[Z]);
	vg1 = eu->next->vu_p->v_p->vg_p;
	vg2 = eu->next->eumate_p->vu_p->v_p->vg_p;
	rt_log("\tand %f,%f,%f <-> %f,%f,%f\n\n",
		vg1->coord[X], vg1->coord[Y],vg1->coord[Z],
		vg2->coord[X], vg2->coord[Y], vg2->coord[Z]);
#endif


						/* no need to reprocess the edge starting at the new point,
						 * we already know it is on the plane, so we insert it into
						 * the list now, and arrange to skip the new edge in processing.
						 */
						eu = eu->next;
						nmg_tbl(b1, TBL_INS, &eu->vu_p->magic);

					}
#ifdef DEBUG_POLYSECT
				} else {
					rt_log("\tBoring Status of rt_isect_ray_plane: %d dist: %f\n", status, dist);
#endif
				}	/* if isect ray plane */
				eu = eu->next;
			} while (eu != eu_start);
		} /* if loopuse child is vertexuse */
d2049 2
a2050 2
	} while (lu != lu_start);

d2052 1
a2053 512

/*	T B L _ V S O R T
 *	sort list of vertices in fu1 on plane of fu2 
 *
 *	W A R N I N G:
 *		This function makes gross assumptions about the contents and structure of 
 *	an nmg_ptbl list!
 */
static void tbl_vsort(b, fu1, fu2)
struct nmg_ptbl *b;		/* table of edgeuses/loopuses (vertexuses really) on intercept line */
struct faceuse *fu1, *fu2;
{
	point_t pt, min_pt;
	vect_t	dir, vect;
	union {
		struct vertexuse **vu;
		long **magic_p;
	} p;
	struct vertexuse *tvu;
	fastf_t *mag, tmag;
	int i, j;

	VMOVE(min_pt, fu1->f_p->fg_p->min_pt);
	VMIN(min_pt, fu2->f_p->fg_p->min_pt);
	rt_isect_2planes(pt, dir, fu1->f_p->fg_p->N, fu2->f_p->fg_p->N, min_pt);
	mag = (fastf_t *)rt_calloc(b->next, sizeof(fastf_t), "vectort magnitudes for sort");

	p.magic_p = b->buffer;
	/* check vertexuses and compute distance from start of line */
	for(i = 0 ; i < b->next ; ++i) {
		NMG_CK_VERTEXUSE(p.vu[i]);

		VSUB2(vect, pt, p.vu[i]->v_p->vg_p->coord);
		mag[i] = MAGNITUDE(vect);
	}

	/* a trashy bubble-head sort, because I hope this list is never
	 * very long.
	 */
	for(i=0 ; i < b->next - 1 ; ++i) {
		for (j=i+1; j < b->next ; ++j) {
			if (mag[i] > mag[j]) {
				tvu = p.vu[i];
				p.vu[i] = p.vu[j];
				p.vu[j] = tvu;

				tmag = mag[i];
				mag[i] = mag[j];
				mag[j] = tmag;
			}
		}
	}
	/*
	 * We should do something here to "properly"
	 * order vertexuses which share a vertex
	 * or whose coordinats are equal.
	 *
	 * Just what should be done & how is not
	 * clear to me at this hour of the night.
	 */
	rt_free((char *)mag, "vector magnitudes");
}

/*	C U T _ L O O P
 *	Divide a loop of edges between two vertexuses
 *
 *	we make a new loop between the two vertexes, and split it and
 *	the parametric loop at the same time.
 */
static void cut_loop(vu1, vu2)
struct vertexuse *vu1, *vu2;
{
	struct loopuse *lu;
	struct edgeuse *eu1, *eu2, *oldeu1, *oldeu2;

	NMG_CK_VERTEXUSE(vu1);
	NMG_CK_VERTEXUSE(vu2);

	oldeu1 = vu1->up.eu_p;
	oldeu2 = vu2->up.eu_p;

	NMG_CK_EDGEUSE(oldeu1);
	NMG_CK_EDGEUSE(oldeu2);
	NMG_CK_LOOPUSE(oldeu1->up.lu_p);
	NMG_CK_LOOPUSE(oldeu2->up.lu_p);
	NMG_CK_FACEUSE(oldeu1->up.lu_p->up.fu_p);
	NMG_CK_FACEUSE(oldeu2->up.lu_p->up.fu_p);

	lu = nmg_mlv(oldeu2->up.lu_p->up.magic_p, vu2->v_p);

	eu1 = nmg_meonvu(lu->down.vu_p);
	nmg_eusplit(vu1->v_p, eu1);

	eu2 = eu1->next;
	/* make the edgeuses share the edge between them so that the
	 * face/shell will remain "closed."
	 */
	nmg_moveeu(eu1, eu2);	

	/* insert an edge from v2 to v1 in front of the edge at vu1.
	 * this is some pretty gross mucking about in the loopuse
	 * and edgeuse structures!
	 *
	 * First we make sure everyone is pointing to the right
	 * neighbor edgeuse
	 */
	eu1->last = oldeu2->last;
	eu1->next = oldeu1;
	eu2->last = oldeu1->last;
	eu2->next = oldeu2;

	oldeu1->last->next = eu2;	
	oldeu2->last->next = eu1;
	
	eu1->next->last = eu1;
	eu2->next->last = eu2;

	eu1->up.magic_p = oldeu1->up.magic_p;
	/* make sure parent loop is pointing to the half
	 * of the loop that it gets to keep
	 */
	eu1->up.lu_p->down.eu_p = eu1;

	/* switch over and take care of the mates */
	eu1 = eu1->eumate_p;
	eu2 = eu2->eumate_p;
	oldeu1 = oldeu1->eumate_p;
	oldeu2 = oldeu2->eumate_p;

	eu1->last = oldeu1;
	eu1->next = oldeu2->next;
	eu2->last = oldeu2;
	eu2->next = oldeu1->next;

	oldeu1->next = eu1;
	oldeu2->next = eu2;
	
	eu1->next->last = eu1;
	eu2->next->last = eu2;

	eu1->up.magic_p = oldeu1->up.magic_p;
	/* make sure parent loop is pointing to the half
	 * of the loop that it gets to keep
	 */
	eu1->up.lu_p->down.eu_p = eu1;


	/* Migrate some edgeuses to their new home */
	for (eu1 = eu2->next; eu1 != eu2 ; eu1 = eu1->next)
		eu1->up.lu_p = eu2->up.lu_p;

	eu2 = eu2->eumate_p;
	for (eu1=eu2->next ; eu1 != eu2 ; eu1 = eu1->next)
		eu1->up.lu_p = eu2->up.lu_p;
}


/*	C O M B I N E
 * collapse loops,vertices within face fu1 (relative to fu2)
 */
static void combine(b, fu1, fu2)
struct nmg_ptbl *b;		/* table of edgeuses/loopuses (vertexuses really) on intercept line */
struct faceuse *fu1, *fu2;
{
	int i, j;
	struct edgeuse *eu;
	union {
		struct vertexuse **vu;
		long **magic_p;
	} p;

	p.magic_p = b->buffer;

#define DEBUG_COMBINE 1
#ifdef DEBUG_COMBINE
	rt_log("\nCombine\n");
#endif
	for (i=0 ; i < b->next ; ++i) {
		NMG_CK_VERTEXUSE(p.vu[i]);
		NMG_CK_VERTEX(p.vu[i]->v_p);
		NMG_CK_VERTEX_G(p.vu[i]->v_p->vg_p);
#ifdef DEBUG_COMBINE
		rt_log("%d %f,%f,%f\n", i, p.vu[i]->v_p->vg_p->coord[X],
		p.vu[i]->v_p->vg_p->coord[Y], p.vu[i]->v_p->vg_p->coord[Z]);
#endif
	}

	for (i=0 ; i < b->next ; ) {
		/* We don't want to start an edge on a loop of one vertex becuase
		 * such a vertex will lie outside of the face.  Thus we go looking
		 * for the first vertex which is part of and edge-loop
		 */
		for (; i < b->next ; ++i)
			if (*p.vu[i]->up.magic_p == NMG_LOOPUSE_MAGIC ) {

#ifdef DEBUG_COMBINE
	rt_log("\tSkipping a loop-only point(%d) %f %f %f\n", i,
		p.vu[i]->v_p->vg_p->coord[X],
		p.vu[i]->v_p->vg_p->coord[Y],
		p.vu[i]->v_p->vg_p->coord[Z]);
#endif
				nmg_klu(p.vu[i]->up.lu_p);
				continue;
			}else if (*p.vu[i]->up.magic_p == NMG_SHELL_MAGIC) {
				rt_log("in %s at %d splitting edge of shell??\n",
					__FILE__, __LINE__);
				rt_bomb("BAD NMG pointer");
			} else if (*p.vu[i]->up.magic_p == NMG_EDGEUSE_MAGIC)
				break;
			else
				rt_bomb("Bogus vertexuse parent");

#ifdef DEBUG_COMBINE
	if (i < b->next)
	rt_log("\tFound a likely starting point(%d) %f %f %f\n", i,
		p.vu[i]->v_p->vg_p->coord[X],
		p.vu[i]->v_p->vg_p->coord[Y],
		p.vu[i]->v_p->vg_p->coord[Z]);
#endif
		/* At this point we have a plausible first vertex from which
		 * to work.  Now we determine wheter that
		 * vertex needs only to be inserted in an existing edge,
		 * or if we need to make a new edge and what that edge
		 * connects.
		 */
		for ( ; i < b->next-1 ; ++i) {
			j = i + 1;
#ifdef DEBUG_COMBINE
	rt_log("checking (%d) %f %f %f <-> (%d) %f %f %f\n", i,
		p.vu[i]->v_p->vg_p->coord[X],
		p.vu[i]->v_p->vg_p->coord[Y],
		p.vu[i]->v_p->vg_p->coord[Z], j,
		p.vu[j]->v_p->vg_p->coord[X],
		p.vu[j]->v_p->vg_p->coord[Y],
		p.vu[j]->v_p->vg_p->coord[Z]);
#endif
			if (*p.vu[j]->up.magic_p == NMG_LOOPUSE_MAGIC) {
				/* if point is along edge from p.vu[i] we
				 * split that edge with the point
				 * else we insert a "jaunt" to that point
				 * either way, the next point to be processed is 
				 * the new, resulting point.
				 */
#ifdef DEBUG_COMBINE
	rt_log("\tLinking in a Loopuse-only point\n");
#endif
				if (nmg_tbl(b, TBL_LOC, &p.vu[i]->up.eu_p->next->vu_p->magic) >= i) {
					nmg_esplit(p.vu[j]->v_p, p.vu[i]->up.eu_p->e_p);
					/* replace the loop vertex in the list with the one we
					 * just created 
					 */
					nmg_klu(p.vu[j]->up.lu_p);
					p.vu[j] = p.vu[i]->up.eu_p->next->vu_p;
				} else if (nmg_tbl(b, TBL_LOC, &p.vu[i]->up.eu_p->last->vu_p->magic) >= i) {
					nmg_esplit(p.vu[j]->v_p, p.vu[i]->up.eu_p->last->e_p);
					/* replace the loop vertex in the list with the one we
					 * just created 
					 */
					nmg_klu(p.vu[j]->up.lu_p);
					p.vu[j] = p.vu[i]->up.eu_p->last->vu_p;
				} else {
					eu = nmg_eins(p.vu[i]->up.eu_p);
					eu = nmg_eusplit(p.vu[j]->v_p, eu);
					nmg_moveeu(eu, eu->last);
					nmg_klu(p.vu[j]->up.lu_p);
					p.vu[j] = eu->vu_p;
				}
			} else if (*p.vu[j]->up.eu_p->up.magic_p == *p.vu[i]->up.eu_p->up.magic_p) {
				/* both vertices are a part of the same loop */
				if (p.vu[j] == p.vu[i]->up.eu_p->next->vu_p ||
				    p.vu[j] == p.vu[i]->up.eu_p->last->vu_p ||
				    p.vu[j] == p.vu[i]->up.eu_p->eumate_p->vu_p ||
				    p.vu[j] == p.vu[i]->up.eu_p->last->eumate_p->vu_p) {
					/* both vertices are a part of the same edge
					 * just move forward on the edge.
					 */
#ifdef DEBUG_COMBINE
	rt_log("Sliding along edge\n");
#endif
					continue;
				} else {
					/* classify this loop intersect as
					 * either grazing or cutting accross
					 *
					 * classify next of p.vu[i]
					 */
					point_t pt;
					plane_t pl;
					fastf_t last_class, next_class;

					eu = p.vu[i]->up.eu_p->next;
#ifdef DEBUG_COMBINE
	rt_log("Classifying around (%d) %f,%f,%f\n", i,
	p.vu[i]->v_p->vg_p->coord[X], p.vu[i]->v_p->vg_p->coord[Y],
	p.vu[i]->v_p->vg_p->coord[Z]);
#endif
					VMOVEN(pl, fu2->f_p->fg_p->N, 4);
					/* while next is on plane of
					 * intersection
					 * 	classify further next
					 */
					do {
						VMOVE(pt, eu->vu_p->v_p->vg_p->coord);
						next_class = NMG_DIST_PT_PLANE(pt, pl);
						eu = eu->next;
					} while (NEAR_ZERO(next_class, VDIVIDE_TOL) && eu != p.vu[i]->up.eu_p);
#ifdef DEBUG_COMBINE
	if (!NEAR_ZERO(next_class, VDIVIDE_TOL)) {
		eu = eu->last;
		rt_log("\tnext_class %f, %f,%f,%f\n", next_class, 
		eu->vu_p->v_p->vg_p->coord[X],
		eu->vu_p->v_p->vg_p->coord[Y],
		eu->vu_p->v_p->vg_p->coord[Z]);
	}
#endif
					/* classify last of p.vu[i] */
					eu = p.vu[i]->up.eu_p->last;
					/* while last is on plane of intersection
					 * 	classify further last
					 */
					do {
						VMOVE(pt, eu->vu_p->v_p->vg_p->coord);
						last_class = NMG_DIST_PT_PLANE(pt, pl);
						eu = eu->last;
					} while (NEAR_ZERO(last_class, VDIVIDE_TOL) && eu != p.vu[i]->up.eu_p);
#ifdef DEBUG_COMBINE
	if (!NEAR_ZERO(last_class, VDIVIDE_TOL)) {
		eu = eu->next;
		rt_log("\tlast_class %f, %f,%f,%f\n", last_class, 
		eu->vu_p->v_p->vg_p->coord[X],
		eu->vu_p->v_p->vg_p->coord[Y],
		eu->vu_p->v_p->vg_p->coord[Z]);
	}
#endif
					if (last_class <= 0.0 && next_class <= 0.0 ||
					    last_class >= 0.0 && next_class >= 0.0) {
					    	/* We're just grazing this loop.
					    	 * so we skip to next point
					    	 */
#ifdef DEBUG_COMBINE
	rt_log("Grazing\n");
#endif
					    	 i = j;
					} else {
						/* We're cutting accross this loop
						 * we must divide it in twain
						 * from p.vu[i] to p.vu[j]
						 */
#ifdef DEBUG_COMBINE
	rt_log("Cutting (%d)%f,%f,%f -> (%d)%f,%f,%f\n",
		i, p.vu[i]->v_p->vg_p->coord[X],
			p.vu[i]->v_p->vg_p->coord[Y],
			p.vu[i]->v_p->vg_p->coord[Z],
		j, p.vu[j]->v_p->vg_p->coord[X],
			p.vu[j]->v_p->vg_p->coord[Y],
			p.vu[j]->v_p->vg_p->coord[Z]);
#endif
						cut_loop(p.vu[i], p.vu[j]);
						i = j;
					}
				}
			} else {
				/* we're joining 2 different loops together */
				rt_bomb("Join of 2 separate loops is unimplemented at this time!\n");
				/* if ( We are cutting accross both loops )
				 *	join loops at intersection points
				 *	start next line at j+1
			    	 * else ( cutting first and tangenting second)
				 *	1) join loops, start next line at j
				 *	2) insert vertex, start next line at that new vertex
		    		 *
				 */

			}
		} /* for ( ; i < b->next-1 ; ++i) */
	} /* for all vertices in the list */
	nmg_face_bb(fu1->f_p);
}


/*	C R A C K S H E L L S
 *
 *	split the faces of two shells in preparation for performing boolean
 *	operations with them.
 */
static void crackshells(s1, s2)
struct shell *s1, *s2;
{
	struct faceuse *fu1, *fu2;
	struct nmg_ptbl verts1, verts2, faces;

	NMG_CK_SHELL(s2);
	NMG_CK_SHELL_A(s2->sa_p);
	NMG_CK_SHELL(s1);
	NMG_CK_SHELL_A(s1->sa_p);

	if (!s1->fu_p || !s2->fu_p)
		rt_bomb("ERROR:shells must contain faces for boolean operations.");

	nmg_tbl(&faces, TBL_INIT, (long *)NULL);

	if (NMG_EXTENT_OVERLAP(s1->sa_p->min_pt, s1->sa_p->max_pt,
	    s2->sa_p->min_pt, s2->sa_p->max_pt) ) {

		/* shells overlap */
		fu1 = s1->fu_p;
		do {/* check each of the faces in shell 1 to see
		     * if they overlap the extent of shell 2
		     */
			if (nmg_tbl(&faces, TBL_LOC, &fu1->f_p->magic) < 0 &&
			    NMG_EXTENT_OVERLAP(s2->sa_p->min_pt, s2->sa_p->max_pt, 
			    fu1->f_p->fg_p->min_pt, fu1->f_p->fg_p->max_pt) ) {

				/* poly1 overlaps shell2 */
/* #define DEBUG_CRACK */
#ifdef DEBUG_CRACK
	rt_log("Cracking\n");
#endif
				fu2 = s2->fu_p;
				do {/* now we check the face of shell 1 against each of the
				     * faces of shell 2.  Faces which overlap are
		                     * subdivided.
                		     */

					if (NMG_EXTENT_OVERLAP(fu2->f_p->fg_p->min_pt,
					    fu2->f_p->fg_p->max_pt,
					    fu1->f_p->fg_p->min_pt,fu1->f_p->fg_p->max_pt) ) {

						/* poly1 overlaps poly2 */
					    	nmg_tbl(&verts1, TBL_INIT, (long *)NULL);
					    	nmg_tbl(&verts2, TBL_INIT, (long *)NULL);
#ifdef DEBUG_CRACK
rt_log("Intersecting these faces\n");
nmg_pr_fu(fu1, (char *)NULL);
nmg_pr_fu(fu2, (char *)NULL);
#endif
						polysect(&verts1, &verts2, fu1, fu2);
						polysect(&verts2, &verts1, fu2, fu1);

#ifdef DEBUG_CRACK
nmg_pr_fu(fu1, (char *)NULL);
nmg_pr_fu(fu1->fumate_p, (char *)NULL);
#endif
						tbl_vsort(&verts1, fu1, fu2);
						combine(&verts1, fu1, fu2);

						tbl_vsort(&verts2, fu2, fu1);
						combine(&verts2, fu2, fu1);

						/* When two faces are intersected
						 * with each other, they should share the
						 * same edge(s) of intersection.
					    	 * This needs to be implemented
						 */

					    	nmg_tbl(&verts1, TBL_FREE, (long *)NULL);
					    	nmg_tbl(&verts2, TBL_FREE, (long *)NULL);
					}

					if (fu2->next != s2->fu_p && fu2->next->f_p == fu2->f_p)
						fu2 = fu2->next->next;
					else
						fu2 = fu2->next;

				} while (fu2 != s2->fu_p);
			    	nmg_tbl(&faces, TBL_INS, &fu1->f_p->magic);
			    }

			/* try not to process redundant faceuses */
			if (fu1->next != s1->fu_p && fu1->next->f_p == fu1->f_p)
				fu1 = fu1->next->next;
			else
				fu1 = fu1->next;

		} while (fu1 != s1->fu_p);
	}

}
/*	N M G _ D O _ B O O L
 *	Perform boolean operations on a pair of shells (someday?)
 */
struct shell *nmg_do_bool(s1, s2, oper)
struct shell *s1, *s2;
int oper;
{
	NMG_CK_SHELL(s1);
	NMG_CK_SHELL(s2);

	crackshells(s1, s2);

	/* if oper == union
	 *	make shell from all face-loops in s1 outside s2 and
	 *	all face-loops in s2 outside s1
	 */

	/* if oper == intersection
	 *	make shell from all face-loops in s1 inside s2 and
	 *	all face-loops in s2 inside s1
	 */

	/* if oper == subtraction
	 *	make shell from all face-loops in s1 outside s2 and
	 *	all face-loops in s2 inside s1
	 */

	/* now we should go back and combine loops
	 * of faces back together wherever possible
	 * to reduce the loop/edge count.
	 */
}

#if 0
@


1.3
log
@Added #include <stdio.h>
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: nmg_mk.c,v 1.2 89/12/22 03:16:40 mike Locked $ (BRL)";
d2104 3
a2106 1
	/* a trashy bubble-head sort */
d2120 8
a2127 1

d2331 1
d2431 1
a2431 1
				rt_bomb("Unimplemented!");
d2516 7
d2571 5
@


1.2
log
@Rudimentary face/loop partitioning (for future boolean use)
accomplished.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /usr/people/butler/nmg2/RCS/nmg_mk.c,v 1.6 89/12/15 17:09:13 butler Exp $ (BRL)";
d52 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 *		N M G _ M A K E . C
d6 30
d49 1
a49 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d65 1
a65 2
char *
nmg_identify_magic( magic )
d69 46
a114 23
	default:			return("Unknown");
	case NMG_MODEL_MAGIC:		return("model");
	case NMG_MODEL_A_MAGIC:		return("model_a");
	case NMG_REGION_MAGIC:		return("region");
	case NMG_REGION_A_MAGIC:	return("region_a");
	case NMG_SHELL_MAGIC:		return("shell");
	case NMG_SHELL_A_MAGIC:		return("shell_a");
	case NMG_FACE_MAGIC:		return("face");
	case NMG_FACE_G_MAGIC:		return("face_a");
	case NMG_FACEUSE_MAGIC:		return("faceuse");
	case NMG_FACEUSE_A_MAGIC:	return("faceuse_a");
	case NMG_LOOP_MAGIC:		return("loop");
	case NMG_LOOP_G_MAGIC:		return("loop_g");
	case NMG_LOOPUSE_MAGIC:		return("loopuse");
	case NMG_LOOPUSE_A_MAGIC:	return("loopuse_a");
	case NMG_EDGE_MAGIC:		return("edge");
	case NMG_EDGE_G_MAGIC:		return("edge_g");
	case NMG_EDGEUSE_MAGIC:		return("edgeuse");
	case NMG_EDGEUSE_A_MAGIC:	return("edgeuse_a");
	case NMG_VERTEX_MAGIC:		return("vertex");
	case NMG_VERTEX_G_MAGIC:	return("vertex_g");
	case NMG_VERTEXUSE_MAGIC:	return("vertexuse");
	case NMG_VERTEXUSE_A_MAGIC:	return("vertexuse_a");
d131 1
a131 1
	
d170 2
a171 1
/*	Make Shell, Vertex Use, Vertex
d198 2
a199 1
/*	Make Vertexuse on existing vertex
d210 3
a212 3
	    	rt_log("in %s at %d magic not shell, loop, or edge (%d)\n",
			__FILE__, __LINE__, *upptr);
	    	rt_bomb("Cannot build vertexuse without parent");
d226 2
a227 1
/*	Make Vertex, Vertexuse
d242 2
a243 1
/*	Make edge
d259 1
a259 1
	
d267 1
a267 1
	
d287 1
a287 1
	
d316 2
a317 1
/* Make edge on vertexuse.
d325 1
a325 1
	
d329 3
a331 3
	    rt_log("Error in %s at %d vertexuse not for shell/loop\n", 
	    	__FILE__, __LINE__);
	    rt_bomb("cannot make edge vertexuse not sole element of object");
d333 1
a333 1
	
d341 1
a341 1
	
d393 1
a393 1
/*	Make Loop from edgeuse list
d395 2
d428 1
a428 1
	
d435 2
a436 2
	lu1->lumate_p = lu2; 
	lu2->lumate_p = lu1;
d462 1
a462 1
				__FILE__, __LINE__);
d489 1
a489 1
/*	printf("p2v %x feu %x\n", p2->vu_p->v_p, feu->vu_p->v_p); */
d519 2
a520 1
/*	Move a vertexuse to a new vertex
d548 1
a548 1
/*
d574 1
a574 1
	
d584 1
a584 1
	
d589 2
a590 1
/*	Kill Faceuse
d603 1
a603 1
	
d646 2
a647 1
/*	Kill loopuse
d658 1
a658 1
	
d669 1
a669 1
	
d738 1
a738 1
			__LINE__);
d741 1
a741 1
	
d768 2
a769 1
/*	Make Face from loop
d779 1
d791 2
d800 1
a800 1
	
d802 1
a802 1
	fu1->s_p = fu2->s_p = lu1->up.s_p;
d811 3
a813 3
	lu1->up.s_p->lu_p = lu1;
	DLLRM(lu1->up.s_p->lu_p, fu1->lu_p);
	if (lu1->up.s_p->lu_p == fu1->lu_p)
d816 5
a820 5
	
	lu2->up.s_p->lu_p = lu2;
	DLLRM(lu2->up.s_p->lu_p, fu2->lu_p)
	if (lu2->up.s_p->lu_p == fu2->lu_p)
		lu2->up.s_p->lu_p = (struct loopuse *)NULL;
d824 2
a825 2
	DLLINS(fu2->s_p->fu_p, fu2);
	DLLINS(fu1->s_p->fu_p, fu1);
d831 1
a831 1
/*
d851 1
a851 1
			__FILE__, __LINE__);
d882 1
a882 1
	    	if (eu1->up.lu_p->lumate_p != eu2->up.lu_p ||
d884 1
a884 1
	    		rt_log("In %s at %d %s\n", __FILE__, __LINE__,
d886 2
a887 2
	    		rt_bomb("bye");
	    	}
d913 1
a913 1
			__FILE__, __LINE__);
d958 4
d989 3
a991 1

d1013 3
d1030 1
a1030 1
/*
d1053 1
a1053 1
/*
d1085 9
d1095 22
a1116 2
/*
 *	Build the bounding box and set the plane equation for a face
d1118 1
a1118 1
void nmg_face_g(f, plane)
a1119 1
plane_t *plane;
a1122 1
	int i;
d1144 2
a1145 2
		if (!lu->l_p->lg_p)
			nmg_loop_g(lu->l_p);
a1151 5

	if (plane)
		for (i=ELEMENTS_PER_PLANE ; i ; --i)
			fg->N[i] = (*plane)[i];

d1154 1
a1154 1
/*
d1181 1
a1181 1
				nmg_face_g(fu->f_p, (plane_t *)NULL);
d1189 1
a1189 1
			    	fu = fu->next->next;
d1226 1
a1226 1
		
d1233 1
a1233 1
			__LINE__, __FILE__);
d1240 2
a1241 2
/*
 *	Split an edge
d1251 1
a1251 1
 *		oldeu(cw)
d1253 2
d1257 4
a1260 3
 *		oldeu(cw)  eu1
 *		.-------->.--->
 *
d1262 1
a1262 1
struct edgeuse *nmg_esplit(v, oldeu)
d1269 2
a1270 2
			*eu2,
			*tmpeu;
d1300 1
a1300 1
				oldeu->eumate_p->vu_p->v_p, oldeu->up.s_p);
d1303 1
a1303 1
				oldeu->eumate_p->vu_p->v_p, oldeu->up.s_p);
a1317 9

	/* I refuse to create zero length edges in an existing face!
	 * besides, this condition allows us to conveniently search for
	 * an edge we can copy.
	 */
	if (oldeu->vu_p->v_p == v || oldeu->eumate_p->vu_p->v_p == v) {
		rt_bomb("Attempt to create zero length edge in existing face");
	}

d1347 1
a1347 1
 	eu1->next = oldeu->next;
d1351 2
a1352 2
	
 	eu2->next = tmpeu->next;
d1384 1
d1392 1
a1392 1
			__LINE__);
d1397 8
a1404 3
/**********************************************************************/
/*	Merge a pair of edges. e2 is killed and its uses moved to e1. 
 *	vertexes must be equal?
d1406 2
a1407 2
void nmg_glueedge(e1, e2)
struct edge *e1, *e2;
d1409 1
a1409 1
	struct edgeuse *eu1, *eu2;
d1411 2
a1412 1
	if (e1 == e2) return;
d1414 2
a1415 2
	NMG_CK_EDGE(e1);
	NMG_CK_EDGE(e2);
a1416 10
	/* when we transfer the edgeuses to the new edge, we also assure 
	 * that all edges utilize the same pair of verteces.
	 */
	eu2 = e2->eu_p;
	eu1 = e1->eu_p;
	do {
		if ( !(eu2->vu_p->v_p == eu1->vu_p->v_p &&
		    eu2->eumate_p->vu_p->v_p == eu1->eumate_p->vu_p->v_p ||
		    eu2->vu_p->v_p == eu1->eumate_p->vu_p->v_p &&
		    eu2->eumate_p->vu_p->v_p == eu1->vu_p->v_p) ) {
d1418 11
a1428 7
			/* edge(uses) have different vertecies */
			/* we should do some heuristics to determine which
			 * direction the edge is going for our vertexuse move.
			 * For now I'm punting this. BUG
			 */
			nmg_movevu(eu2->vu_p, eu1->vu_p->v_p);
			nmg_movevu(eu2->eumate_p->vu_p, eu1->eumate_p->vu_p->v_p);
d1430 2
a1431 1
		}
d1433 3
a1435 13
		/* edges already use same vetecies */
		eu2->eumate_p->e_p = eu2->e_p = e1;

		eu2 = eu2->eumate_p->radial_p;
	} while (eu2 != e2->eu_p);

	/* we currently have two separate radial edge use lists on e1.  It is
	 * time to merge the two lists.
	 *
	 * This should be done with some fancy
	 * algorithm to make sure that appropriate radial position is 
	 * preserved.  At the moment, we simply join the two lists. 
	 * This is a BUG.
d1437 4
d1442 8
a1449 4
	eu2->radial_p->radial_p = eu1->radial_p;
	eu1->radial_p->radial_p = eu2->radial_p;
	eu2->radial_p = eu1;
	eu1->radial_p = eu2;
d1451 4
a1454 3
	/* now that all uses of edge e2 are transfered, we can delete it */
	if (e2->eg_p) FREE_EDGE_G(e2->eg_p);
	FREE_EDGE(e2);
d1468 1
d1471 1
d1480 1
a1480 2
	GET_EDGE(e); GET_VERTEX(v1); GET_VERTEX(v2);
	GET_VERTEX_G(vg1); GET_VERTEX_G(vg2);
d1485 5
d1491 1
a1491 1
	/* we want a pair of new verteces that are identical to the old
d1500 1
a1500 1
			sizeof(struct vertex_g));
d1509 1
a1509 1
			sizeof(struct vertex_g));
d1516 5
a1533 3
	/* now move the vertexuses to the new (but identical) verteces. */
	nmg_movevu(eu->vu_p, v1);
	nmg_movevu(eu->eumate_p->vu_p, v1);
d1535 1
a1535 1
/*
d1562 1
a1562 1
	
d1567 1
a1567 1
/*
d1585 2
a1586 2
					sizeof(p)*(b->blen += 64),
					"pointer table" );
d1595 1
a1595 1
		bzero(b->buffer, b->blen * sizeof(p));
d1606 3
a1608 2
/*
 *	Make a new loop, vertex in shell
d1610 3
a1612 2
struct loopuse *nmg_mlv(s)
struct shell *s;
d1616 8
a1623 1
	
d1627 3
d1634 1
a1634 1
	
d1636 1
a1636 1
	lu1->up.s_p = lu2->up.s_p = s;
d1639 15
a1653 2
	lu1->down.vu_p = nmg_mvvu(&lu1->magic);
	lu2->down.vu_p = nmg_mvu(lu1->down.vu_p->v_p, &lu2->magic);
d1655 5
a1659 2
	lu1->lumate_p = lu2; 
	lu2->lumate_p = lu1;
d1661 10
a1670 2
	DLLINS(s->lu_p, lu2);
	DLLINS(s->lu_p, lu1);
d1674 1
a1674 1
/*
d1687 1
a1687 1
		__FILE__, __LINE__);
d1705 851
a2556 1

a2558 3
 * facesplit
 * loopsplit
 * move loop to face
a2559 1
 * make face, loop on vertexuse
@
