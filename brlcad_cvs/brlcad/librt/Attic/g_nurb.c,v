head	11.32;
access;
symbols
	ansi-20040405-merged:11.27.2.2
	postmerge-20040405-ansi:11.30
	premerge-20040404-ansi:11.29
	postmerge-autoconf:11.29
	autoconf-freeze:11.28.2.2
	premerge-autoconf:11.29
	ansi-20040316-freeze:11.27.2.1
	postmerge-20040315-windows:11.29
	premerge-20040315-windows:11.29
	windows-20040315-freeze:11.27.4.1
	autoconf-20031203:11.28
	autoconf-20031202:11.28
	autoconf-branch:11.28.0.2
	phong-branch:11.27.0.8
	photonmap-branch:11.27.0.6
	rel-6-1-DP:11.27
	windows-branch:11.27.0.4
	rel-6-0-2:11.25
	ansi-branch:11.27.0.2
	rel-6-0-1-branch:11.25.0.2
	hartley-6-0-post:11.26
	hartley-6-0-pre:11.25
	rel-6-0-1:11.25
	rel-6-0:11.25
	rel-5-4:11.12.2.1
	offsite-5-3-pre:11.20
	rel-5-3:11.12.2.1
	rel-5-2:11.12
	rel-5-1-branch:11.12.0.2
	rel-5-1:11.12
	rel-5-0:11.9
	rel-5-0-beta:11.8
	rel-4-5:11.7
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.32
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.31;

11.31
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.30;

11.30
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.29;

11.29
date	2004.02.02.17.39.21;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2003.09.27.00.45.44;	author morrison;	state Exp;
branches
	11.28.2.1;
next	11.27;

11.27
date	2002.08.20.17.08.00;	author jra;	state Exp;
branches
	11.27.2.1
	11.27.4.1;
next	11.26;

11.26
date	2002.08.15.20.55.12;	author hartley;	state Exp;
branches;
next	11.25;

11.25
date	2001.10.02.19.24.29;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	2001.10.01.20.12.08;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	2001.05.17.20.05.24;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2001.04.20.22.29.45;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2001.03.19.22.19.58;	author butler;	state Exp;
branches;
next	11.20;

11.20
date	2001.01.24.13.39.23;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	2000.08.21.02.02.30;	author butler;	state Exp;
branches;
next	11.18;

11.18
date	2000.07.10.23.01.32;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.07.08.01.30.36;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.06.30.17.45.40;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	2000.06.30.17.41.04;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	2000.06.30.15.38.03;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.06.30.15.31.15;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.04.12.02.34.34;	author mike;	state Exp;
branches
	11.12.2.1;
next	11.11;

11.11
date	99.11.26.21.46.47;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.11.17.02.42.00;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.07.02.22.19.23;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.05.27.19.10.40;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	98.02.05.14.31.52;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.12.01.02.47.38;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.09.20.10.59.46;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.05.05.14.18.36;	author stay;	state Exp;
branches;
next	11.2;

11.2
date	95.01.24.19.06.14;	author stay;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.49;	author mike;	state Rel4_4;
branches;
next	10.18;

10.18
date	94.12.27.15.21.33;	author stay;	state Exp;
branches;
next	10.17;

10.17
date	94.10.18.02.01.42;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	94.08.27.02.04.16;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	94.08.10.18.36.35;	author gdurf;	state Exp;
branches;
next	10.14;

10.14
date	94.08.09.17.23.42;	author stay;	state Exp;
branches;
next	10.13;

10.13
date	93.10.01.21.00.00;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	93.09.25.11.51.01;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	92.06.12.23.52.16;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	92.06.11.23.56.13;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	92.06.03.23.23.49;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.06.02.23.26.01;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.06.02.22.45.48;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.06.02.22.08.58;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.06.02.16.43.29;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.05.29.01.12.28;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.05.28.22.10.29;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.04.13.09.58.55;	author stay;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.19;	author mike;	state Rel4_0;
branches;
next	1.14;

1.14
date	91.09.20.23.14.02;	author butler;	state Exp;
branches;
next	1.13;

1.13
date	91.08.29.22.19.39;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	91.08.16.16.18.07;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	91.07.08.22.16.35;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	91.07.06.00.21.26;	author stay;	state Exp;
branches;
next	1.9;

1.9
date	91.06.30.00.10.53;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	91.06.29.21.04.33;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	91.06.22.22.30.27;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	91.06.14.09.43.05;	author stay;	state Exp;
branches;
next	1.5;

1.5
date	91.05.18.03.01.00;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.05.17.20.06.06;	author stay;	state Exp;
branches;
next	1.3;

1.3
date	91.01.28.23.53.12;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.01.26.03.14.49;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.01.25.21.18.54;	author mike;	state Exp;
branches;
next	;

11.12.2.1
date	2001.01.24.14.46.30;	author jra;	state Exp;
branches;
next	;

11.27.2.1
date	2002.09.19.18.01.34;	author morrison;	state Exp;
branches;
next	11.27.2.2;

11.27.2.2
date	2004.03.17.21.18.47;	author morrison;	state Exp;
branches;
next	;

11.27.4.1
date	2004.03.11.23.43.38;	author morrison;	state Exp;
branches;
next	;

11.28.2.1
date	2004.02.12.18.37.41;	author erikg;	state Exp;
branches;
next	11.28.2.2;

11.28.2.2
date	2004.03.15.14.07.19;	author erikg;	state Exp;
branches;
next	;


desc
@New NURB geometry module for Release 4.0
@


11.32
log
@moved to src/
@
text
@/*
 *			G _ N U R B . C
 *
 *  Purpose -
 *	Intersect a ray with a Non Uniform Rational B-Spline
 *
 *  Authors -
 *	Paul R. Stay
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1991-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSnurb[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_nurb.c,v 11.31 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "raytrace.h"
#include "nurb.h"		/* before nmg.h */
#include "nmg.h"
#include "rtgeom.h"
#include "./debug.h"

#ifndef M_SQRT1_2
#	define M_SQRT1_2       0.70710678118654752440
#endif /* M_SQRT1_2 */

struct nurb_specific {
	struct nurb_specific *  next;	/* next surface in the the solid */
	struct face_g_snurb *	srf;	/* Original surface description */
	struct bu_list		bez_hd;	/* List of Bezier face_g_snurbs */
};

struct nurb_hit {
	struct nurb_hit * next;
	struct nurb_hit * prev;
	fastf_t		hit_dist;	/* Distance from the r_pt to surface */
	point_t		hit_point;	/* intersection point */
	vect_t		hit_normal;	/* Surface normal */
	fastf_t		hit_uv[2];	/* Surface parametric u,v */
	char *		hit_private;	/* Store current nurb root */
};

#define NULL_HIT  (struct nurb_hit *)0

RT_EXTERN(int rt_nurb_grans, (struct face_g_snurb * srf));
RT_EXTERN(struct nurb_hit *rt_conv_uv, (struct nurb_specific *n,
	struct xray *r, struct rt_nurb_uv_hit *h));
RT_EXTERN(struct nurb_hit *rt_return_nurb_hit, (struct nurb_hit * head));
RT_EXTERN(void		rt_nurb_add_hit, (struct nurb_hit *head,
			struct nurb_hit * hit, const struct bn_tol *tol));


/*
 *  			R T _ N U R B _ P R E P
 *  
 *  Given a pointer of a GED database record, and a transformation matrix,
 *  determine if this is a valid NURB, and if so, prepare the surface
 *  so the intersections will work.
 */

int
rt_nurb_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_nurb_internal	*sip;
	struct nurb_specific 	*nurbs;
	int 			i;

	nurbs = (struct nurb_specific *) 0;

	sip = (struct rt_nurb_internal *) ip->idb_ptr;
	RT_NURB_CK_MAGIC(sip);

	for( i = 0; i < sip->nsrf; i++)
	{
		struct face_g_snurb * s;
		struct nurb_specific * n;

		BU_GETSTRUCT( n, nurb_specific);

		/* Store off the original face_g_snurb */
		s = rt_nurb_scopy (sip->srfs[i], (struct resource *)NULL);
		NMG_CK_SNURB(s);
		rt_nurb_s_bound(s, s->min_pt, s->max_pt);

		n->srf = s;
		BU_LIST_INIT( &n->bez_hd );

		/* Grind up the original surf into a list of Bezier face_g_snurbs */
		(void)rt_nurb_bezier( &n->bez_hd, sip->srfs[i], (struct resource *)NULL );
		
		/* Compute bounds of each Bezier face_g_snurb */
		for( BU_LIST_FOR( s, face_g_snurb, &n->bez_hd ) )  {
			NMG_CK_SNURB(s);
			rt_nurb_s_bound( s, s->min_pt, s->max_pt );
			VMINMAX( stp->st_min, stp->st_max, s->min_pt);
			VMINMAX( stp->st_min, stp->st_max, s->max_pt);
		}

		n->next = nurbs;
		nurbs = n;
	}

	stp->st_specific = (genptr_t)nurbs;

	VADD2SCALE( stp->st_center, stp->st_max, stp->st_min, 0.5 );
	{
		fastf_t f, dx, dy, dz;
		dx = (stp->st_max[0] - stp->st_min[0])/2;
		f = dx;
		dy = (stp->st_max[1] - stp->st_min[1])/2;
		if( dy > f )  f = dy;
		dz = (stp->st_max[2] - stp->st_min[2])/2;
		if( dz > f )  f = dz;
		stp->st_aradius = f;
		stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);
	}

	return 0;
}

/*
 *			R T _ N U R B _ P R I N T
 */
void
rt_nurb_print(register const struct soltab *stp)
{
	register struct nurb_specific *nurb =
		(struct nurb_specific *)stp->st_specific;

	if( nurb == (struct nurb_specific *)0)
	{
		bu_log("rt_nurb_print: no surfaces\n");
		return;
	}

	for( ; nurb != (struct nurb_specific *)0; nurb = nurb->next)
	{
		/* XXX There is a linked list of Bezier surfaces to print here too */
		rt_nurb_s_print("NURB", nurb->srf);
	}
}

/*
 *  			R T _ N U R B _ S H O T
 *  
 *  Intersect a ray with a nurb.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */

int
rt_nurb_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct nurb_specific * nurb =
		(struct nurb_specific *)stp->st_specific;
	register struct seg *segp;
	const struct bn_tol	*tol = &ap->a_rt_i->rti_tol;
	point_t p1, p2, p3, p4;
	vect_t dir1, dir2;
	plane_t	plane1, plane2;
	struct nurb_hit * hit;
	struct nurb_hit hit_list;
	vect_t invdir;
	int hit_num;

	invdir[0] = invdir[1] = invdir[2] = INFINITY;
	if(!NEAR_ZERO(rp->r_dir[0], SQRT_SMALL_FASTF)) 
		invdir[0] = 1.0 / rp->r_dir[0];
	if(!NEAR_ZERO(rp->r_dir[1], SQRT_SMALL_FASTF)) 
		invdir[1] = 1.0 / rp->r_dir[1];
	if(!NEAR_ZERO(rp->r_dir[2], SQRT_SMALL_FASTF)) 
		invdir[2] = 1.0 / rp->r_dir[2];

	/* Create two orthogonal Planes their intersection contains the ray
	 * so we can project the surface into a 2 dimensional problem
	 */

	bn_vec_ortho(dir1, rp->r_dir);
	VCROSS( dir2, rp->r_dir, dir1);

	VMOVE(p1, rp->r_pt);
	VADD2(p2, rp->r_pt, rp->r_dir);
	VADD2(p3, rp->r_pt, dir1);
	VADD2(p4, rp->r_pt, dir2);

	/* Note: the equation of the plane in BRLCAD is
	 * Ax + By + Cz = D represented by [A B C D]
	 */
	bn_mk_plane_3pts( plane1, p1, p3, p2, tol );
	bn_mk_plane_3pts( plane2, p1, p2, p4, tol );
	
	/* make sure that the hit_list is zero */

	hit_list.next = (struct nurb_hit *)0;
	hit_list.prev = (struct nurb_hit *)0;
	hit_list.hit_dist = 0;
	VSET(hit_list.hit_point, 0.0, 0.0, 0.0);
	VSET(hit_list.hit_normal, 0.0, 0.0, 0.0);
	hit_list.hit_uv[0] = 	hit_list.hit_uv[1] = 0.0;
	hit_list.hit_private = (char *)0;

	while( nurb != (struct nurb_specific *) 0 )
	{
		struct face_g_snurb * s;
		struct rt_nurb_uv_hit *hp;

		for( BU_LIST_FOR( s, face_g_snurb, &nurb->bez_hd ) )  {
			if( !rt_in_rpp( rp, invdir, s->min_pt, s->max_pt))
				continue;

#define UV_TOL	1.0e-6	/* Paper says 1.0e-4 is reasonable for 1k images, not close up */
			hp = rt_nurb_intersect(
				s, plane1, plane2, UV_TOL, (struct resource *)ap->a_resource );
			while( hp != (struct rt_nurb_uv_hit *)0)
			{
				struct rt_nurb_uv_hit * o;

				if( RT_G_DEBUG & DEBUG_SPLINE )
					bu_log("hit at %d %d sub = %d u = %f v = %f\n",
						ap->a_x, ap->a_y, hp->sub, hp->u, hp->v);

				hit = (struct nurb_hit *) 
					rt_conv_uv(nurb, rp, hp);

				o = hp;
				hp = hp->next;
				bu_free( (char *)o,
					"rt_nurb_shot:rt_nurb_uv_hit structure");

				rt_nurb_add_hit( &hit_list, hit, tol );
			}
		}
		nurb = nurb->next;
		/* Insert Trimming routines here */
	}

	/* Convert hits to segments for rt */

	hit_num = 0;

	while( hit_list.next != NULL_HIT )
	{
		struct nurb_hit * h1, * h2;

		RT_GET_SEG( segp, ap->a_resource);

		h1 = (struct nurb_hit *) rt_return_nurb_hit( &hit_list );
		h2 = (struct nurb_hit *) rt_return_nurb_hit( &hit_list );

		segp->seg_stp = stp;
		segp->seg_in.hit_dist = h1->hit_dist;
		VMOVE(segp->seg_in.hit_point, h1->hit_point);
		segp->seg_in.hit_vpriv[0] = h1->hit_uv[0];
		segp->seg_in.hit_vpriv[1] = h1->hit_uv[1];
		segp->seg_in.hit_private = h1->hit_private;
		segp->seg_in.hit_vpriv[2] = 0;
		hit_num++;


		if( h2 != NULL_HIT)
		{
			segp->seg_out.hit_dist = h2->hit_dist;
			VMOVE(segp->seg_out.hit_point, h2->hit_point);
			segp->seg_out.hit_vpriv[0] = h2->hit_uv[0];
			segp->seg_out.hit_vpriv[1] = h2->hit_uv[1];
			segp->seg_out.hit_private = h2->hit_private;
			bu_free( (char *)h2,"rt_nurb_shot: nurb hit");
			hit_num++;
		} 
		else
		{
			segp->seg_out.hit_dist = h1->hit_dist + .01;
			VJOIN1(segp->seg_out.hit_point,
				rp->r_pt, segp->seg_out.hit_dist, rp->r_dir);
			segp->seg_out.hit_vpriv[0] = h1->hit_uv[0];
			segp->seg_out.hit_vpriv[1] = h1->hit_uv[1];
			segp->seg_out.hit_vpriv[2] = 1;
			segp->seg_out.hit_private = h1->hit_private;
		}

		bu_free( (char *)h1, "rt_nurb_shot:nurb hit");
		
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	}

	return(hit_num);	/* not hit */
}

#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	

/*
 *			R T _ N U R B _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_nurb_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	rt_vstub( stp, rp, segp, n, ap );
}

/*
 *  			R T _ N U R B _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_nurb_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
/*	register struct nurb_specific *nurb =
		(struct nurb_specific *)stp->st_specific; */

	struct face_g_snurb * n  = (struct face_g_snurb *) hitp->hit_private;
	fastf_t u = hitp->hit_vpriv[0];
	fastf_t v = hitp->hit_vpriv[1];
	fastf_t norm[4];

	rt_nurb_s_norm( n, u, v, norm);
	
	VMOVE( hitp->hit_normal, norm);
	
	if ( hitp->hit_vpriv[2] == 1)
	{
		VREVERSE( hitp->hit_normal, norm );
	}
	
	return;
}

/*
 *			R T _ N U R B _ C U R V E
 *
 *  Return the curvature of the nurb.
 */
void
rt_nurb_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
/*	register struct nurb_specific *nurb =
		(struct nurb_specific *)stp->st_specific; */
	struct face_g_snurb * srf = (struct face_g_snurb *) hitp->hit_private;
        fastf_t         u, v;

	if( srf->order[0] <= 2 && srf->order[1] <= 2)
	{
	 	cvp->crv_c1 = cvp->crv_c2 = 0;

		/* any tangent direction */
	 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
		return;
	}
	
	u = hitp->hit_vpriv[0];
	v = hitp->hit_vpriv[1];
	
	rt_nurb_curvature( cvp, srf, u, v );
}

/*
 *  			R T _ N U R B _ U V
 *  
 *  For a hit on the surface of an nurb, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_nurb_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
/*	register struct nurb_specific *nurb =
		(struct nurb_specific *)stp->st_specific; */
	uvp->uv_u = hitp->hit_vpriv[0];
	uvp->uv_v = hitp->hit_vpriv[1];
	return;
}

/*
 *		R T _ N U R B _ F R E E
 */
void
rt_nurb_free(register struct soltab *stp)
{
	register struct nurb_specific *nurb =
		(struct nurb_specific *)stp->st_specific;
	register struct nurb_specific *next;

	if( nurb == (struct nurb_specific *)0)
		rt_bomb("rt_nurb_free: no surfaces\n");

	for( ; nurb != (struct nurb_specific *)0; nurb = next)  {
		register struct face_g_snurb	*s;

		next = nurb->next;

		/* There is a linked list of surfaces to free for each nurb */
		while( BU_LIST_WHILE( s, face_g_snurb, &nurb->bez_hd ) )  {
			NMG_CK_SNURB( s );
			BU_LIST_DEQUEUE( &(s->l) );
			rt_nurb_free_snurb( s, (struct resource *)NULL );
		}
		rt_nurb_free_snurb( nurb->srf, (struct resource *)NULL );	/* original surf */
		bu_free( (char *)nurb, "nurb_specific" );
	}
}

/*
 *			R T _ N U R B _ C L A S S
 */
int
rt_nurb_class(void)
{
	return(0);
}

/*
 *			R T _ N U R B _ P L O T
 */
int
rt_nurb_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct rt_nurb_internal *sip;
	register int		i;
	register int		j;
	register fastf_t	* vp;
	int			s;

	
	RT_CK_DB_INTERNAL(ip);
	sip = (struct rt_nurb_internal *) ip->idb_ptr;
	RT_NURB_CK_MAGIC(sip);
	
	for( s=0; s < sip->nsrf; s++)
	{
		struct face_g_snurb 	* n, *r, *c;
		int 		coords;
		fastf_t 	bound;
		point_t		tmp_pt;
		fastf_t 	rel;
		struct knot_vector 	tkv1,
					tkv2;
		fastf_t		tess;
		int		num_knots;
		fastf_t		rt_nurb_par_edge(const struct face_g_snurb *srf, fastf_t epsilon);

		n = (struct face_g_snurb *) sip->srfs[s];

                VSUB2(tmp_pt, n->min_pt, n->max_pt);
                bound =         MAGNITUDE( tmp_pt)/ 2.0;
                /*
                 *  Establish tolerances
                 */
                if( ttol->rel <= 0.0 || ttol->rel >= 1.0 )  {
                        rel = 0.0;              /* none */
                } else {
                        /* Convert rel to absolute by scaling by diameter */
                        rel = ttol->rel * 2 * bound;
                }
                if( ttol->abs <= 0.0 )  {
                        if( rel <= 0.0 )  {
                                /* No tolerance given, use a default */
                                rel = 2 * 0.10 * bound;        /* 10% */
                        } else {
                                /* Use absolute-ized relative tolerance */
                        }
                } else {
                        /* Absolute tolerance was given, pick smaller */
                        if( ttol->rel <= 0.0 || rel > ttol->abs )
                                rel = ttol->abs;
                }

		if( n->order[0] < 3 || n->order[1] < 3 ) {
			/* cannot use rt_nurb_par_edge() in this case */
			tess = 0.25; /* hack for now */
		} else
	                tess = (fastf_t) rt_nurb_par_edge(n, rel);

                num_knots = (int)floor(1.0/((M_SQRT1_2 / 2.0) * tess));

                if( num_knots < 2) num_knots = 2;

                rt_nurb_kvknot( &tkv1, n->order[0],
                        n->u.knots[0],
                        n->u.knots[n->u.k_size-1], num_knots, (struct resource *)NULL);

                rt_nurb_kvknot( &tkv2, n->order[1],
                        n->v.knots[0],
                        n->v.knots[n->v.k_size-1], num_knots, (struct resource *)NULL);


		r = (struct face_g_snurb *) rt_nurb_s_refine( n, RT_NURB_SPLIT_COL, &tkv2, (struct resource *)NULL);
		c = (struct face_g_snurb *) rt_nurb_s_refine( r, RT_NURB_SPLIT_ROW, &tkv1, (struct resource *)NULL);

		coords = RT_NURB_EXTRACT_COORDS(n->pt_type);
	
		if( RT_NURB_IS_PT_RATIONAL(n->pt_type))
		{
			vp = c->ctl_points;
			for(i= 0; 
				i < c->s_size[0] * c->s_size[1]; 
				i++)
			{
				vp[0] /= vp[3];
				vp[1] /= vp[3];
				vp[2] /= vp[3];
				vp[3] /= vp[3];
				vp += coords;
			}
		}

		
		vp = c->ctl_points;
		for( i = 0; i < c->s_size[0]; i++)
		{
			RT_ADD_VLIST( vhead, vp, BN_VLIST_LINE_MOVE );
			vp += coords;
			for( j = 1; j < c->s_size[1]; j++)
			{
				RT_ADD_VLIST( vhead, vp, BN_VLIST_LINE_DRAW );
				vp += coords;
			}
		}
		
		for( j = 0; j < c->s_size[1]; j++)
		{
			int stride;
			
			stride = c->s_size[1] * coords;
			vp = &c->ctl_points[j * coords];
			RT_ADD_VLIST( vhead, vp, BN_VLIST_LINE_MOVE );
			for( i = 0; i < c->s_size[0]; i++)
			{
				RT_ADD_VLIST( vhead, vp, BN_VLIST_LINE_DRAW );
				vp += stride;
			}
		}
		rt_nurb_free_snurb(c, (struct resource *)NULL);
		rt_nurb_free_snurb(r, (struct resource *)NULL);

		bu_free( (char *) tkv1.knots, "rt_nurb_plot:tkv1>knots");
		bu_free( (char *) tkv2.knots, "rt_nurb_plot:tkv2.knots");
	}
	return(0);
}

/*
 *			R T _ N U R B _ T E S S
 */
int
rt_nurb_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	return(-1);
}

/*
 *			R T _ N U R B _ I M P O R T
 */
int
rt_nurb_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{

	struct rt_nurb_internal * sip;
	union record 		*rp;
	register int		i;
	int			s;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	if( rp->u_id != ID_BSOLID ) 
	{
		bu_log("rt_nurb_import: defective header record");
		return (-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_BSPLINE;
	ip->idb_meth = &rt_functab[ID_BSPLINE];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_nurb_internal), "rt_nurb_internal");
	sip = (struct rt_nurb_internal *)ip->idb_ptr;
	sip->magic = RT_NURB_INTERNAL_MAGIC;


	sip->nsrf = rp->B.B_nsurf;
	sip->srfs = (struct face_g_snurb **) bu_malloc(
		sip->nsrf * sizeof( struct face_g_snurb), "nurb srfs[]");
	rp++;

	for( s = 0; s < sip->nsrf; s++)
	{
		register fastf_t 	* m;
		int			coords;
		register dbfloat_t	*vp;
		int			pt_type;
		
		if( rp->d.d_id != ID_BSURF )  {
			bu_log("rt_nurb_import() surf %d bad ID\n", s);
			return -1;
		}

		if( rp->d.d_geom_type == 3)
			pt_type = RT_NURB_MAKE_PT_TYPE(3,RT_NURB_PT_XYZ,RT_NURB_PT_NONRAT);
		else
			pt_type = RT_NURB_MAKE_PT_TYPE(4,RT_NURB_PT_XYZ,RT_NURB_PT_RATIONAL);

		sip->srfs[s] = (struct face_g_snurb *) rt_nurb_new_snurb(
			rp->d.d_order[0],rp->d.d_order[1],
			rp->d.d_kv_size[0],rp->d.d_kv_size[1],
			rp->d.d_ctl_size[0],rp->d.d_ctl_size[1],
			pt_type, (struct resource *)NULL);

		vp = (dbfloat_t *) &rp[1];
		
		for( i = 0; i < rp->d.d_kv_size[0]; i++)
			sip->srfs[s]->u.knots[i] = (fastf_t) *vp++;

		for( i = 0; i < rp->d.d_kv_size[1]; i++)
			sip->srfs[s]->v.knots[i] = (fastf_t) *vp++;

		rt_nurb_kvnorm( &sip->srfs[s]->u);
		rt_nurb_kvnorm( &sip->srfs[s]->v);

		vp = (dbfloat_t *) &rp[rp->d.d_nknots+1];
		m = sip->srfs[s]->ctl_points;
		coords = rp->d.d_geom_type;
		i = (rp->d.d_ctl_size[0] *rp->d.d_ctl_size[1]);
		if( coords == 3)
		{
			for( ; i> 0; i--)
			{
				MAT4X3PNT( m, mat, vp);
				m += 3;
				vp += 3;
			}
		} else if( coords == 4)
		{
			for( ; i> 0; i--)
			{
				MAT4X4PNT( m, mat, vp);
				m += 4;
				vp += 4;
			}
		} else {
			bu_log("rt_nurb_internal: %d invalid elements per vect\n", rp->d.d_geom_type);
			return (-1);
		}
		
		/* bound the surface for tolerancing and other bounding box tests */
                rt_nurb_s_bound( sip->srfs[s], sip->srfs[s]->min_pt,
                        sip->srfs[s]->max_pt);

		rp += 1 + rp->d.d_nknots + rp->d.d_nctls;
	}
	return (0);
}

struct nurb_hit *
rt_conv_uv(struct nurb_specific *n, struct xray *r, struct rt_nurb_uv_hit *h)
{
	struct nurb_hit * hit;
	fastf_t pt[4];
	point_t vecsub;

	hit = (struct nurb_hit *) bu_malloc( sizeof (struct nurb_hit),
		"rt_conv_uv:nurb hit");
	
	hit->prev = hit->next = (struct nurb_hit *)0;
	VSET(hit->hit_normal, 0.0, 0.0, 0.0);
	
	rt_nurb_s_eval(n->srf, h->u, h->v, pt);

	if( RT_NURB_IS_PT_RATIONAL(n->srf->pt_type) )
	{
		hit->hit_point[0] = pt[0] / pt[3];
		hit->hit_point[1] = pt[1] / pt[3];
		hit->hit_point[2] = pt[2] / pt[3];
	} else
	{
		hit->hit_point[0] = pt[0];
		hit->hit_point[1] = pt[1];
		hit->hit_point[2] = pt[2];
	}

	VSUB2( vecsub, hit->hit_point, r->r_pt);
	hit->hit_dist = VDOT( vecsub, r->r_dir);
	hit->hit_uv[0] = h->u;
	hit->hit_uv[1] = h->v;
	hit->hit_private = (char *) n->srf;
	
	return (struct nurb_hit *) hit;
}

void
rt_nurb_add_hit(struct nurb_hit *head, struct nurb_hit *hit, const struct bn_tol *tol)
{
	register struct nurb_hit * h_ptr;

	BN_CK_TOL(tol);
#if 0
	/* Shouldn't be discarded, because shootray moves start pt around */
	if( hit->hit_dist < .001)
	{

		bu_free( (char *) hit, "internal_add_hit: hit");
		return;
	}
#endif
	
	/* If this is the only one, nothing to check against */
	if( head->next == (struct nurb_hit *) 0)
	{
		head->next = hit;
		hit->prev = head;
		return;
	}

	/* Check for duplicates */
	for( h_ptr = head->next; h_ptr != (struct nurb_hit *)0; h_ptr = h_ptr->next)
	{
		register fastf_t	f;

		/* This test a distance in model units (mm) */
		f = hit->hit_dist - h_ptr->hit_dist;
		if( NEAR_ZERO( f, tol->dist ) )  goto duplicate;

		/* These tests are in parameter space, 0..1 */
		f = hit->hit_uv[0] - h_ptr->hit_uv[0];
		if( NEAR_ZERO( f, 0.0001 ) )  goto duplicate;
		f = hit->hit_uv[1] - h_ptr->hit_uv[1];
		if( NEAR_ZERO( f, 0.0001 ) )  goto duplicate;
	}

	hit->prev = head;
	hit->next = head->next;
	hit->next->prev = hit;
	head->next = hit;
	return;
duplicate:
	bu_free( (char *) hit, "add hit: hit");
	return;
}

struct nurb_hit *
rt_return_nurb_hit(struct nurb_hit *head)
{

	register struct nurb_hit * h, * ret;
	fastf_t dist;

	if( head->next == NULL_HIT)
		return NULL_HIT;

	dist = INFINITY;
	ret = NULL_HIT;

	for( h = head->next; h != NULL_HIT; h = h->next)
	{
		if( h->hit_dist < dist )
		{
			ret = h;
			dist = ret->hit_dist;
		}
	}
	
	if( ret != NULL_HIT)
	{
		if( ret->prev != NULL_HIT) ret->prev->next = ret->next;
		if( ret->next != NULL_HIT) ret->next->prev = ret->prev;
		ret->next = ret->prev = NULL_HIT;
	}
	return (struct nurb_hit *) ret;
}

/*
 *			R T _ N U R B _ E X P O R T
 */
int
rt_nurb_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	register int		rec_ptr;
	struct rt_nurb_internal	* sip;
	union record		* rec;
	int			s;
	int			grans;
	int			total_grans;
	dbfloat_t		* vp;
	int			n;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_BSPLINE) return(-1);
	sip = (struct rt_nurb_internal *) ip->idb_ptr;
	RT_NURB_CK_MAGIC(sip);

	/* Figure out how many recs to buffer by
	 * walking through the surfaces and
	 * calculating the number of granuels
	 * needed for storage and add it to the total
	 */
	total_grans = 1;	/* First gran for BSOLID record */
	for( s = 0; s < sip->nsrf; s++)
	{
		total_grans += rt_nurb_grans(sip->srfs[s]);
	}

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = total_grans * sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc(1,ep->ext_nbytes,"nurb external");
	rec = (union record *)ep->ext_buf;

	rec[0].B.B_id = ID_BSOLID;
	rec[0].B.B_nsurf = sip->nsrf;
	
	rec_ptr = 1;

	for( s = 0; s < sip->nsrf; s++)
	{
		register struct face_g_snurb	*srf = sip->srfs[s];
		NMG_CK_SNURB(srf);

		grans = rt_nurb_grans( srf);

		rec[rec_ptr].d.d_id = ID_BSURF;
		rec[rec_ptr].d.d_nknots = (((srf->u.k_size + srf->v.k_size) 
			* sizeof(dbfloat_t)) + sizeof(union record)-1)/ sizeof(union record);
		rec[rec_ptr].d.d_nctls = ((
			RT_NURB_EXTRACT_COORDS(srf->pt_type)
			* (srf->s_size[0] * srf->s_size[1])
			* sizeof(dbfloat_t)) + sizeof(union record)-1 )
			/ sizeof(union record);

		rec[rec_ptr].d.d_order[0] = srf->order[0];
		rec[rec_ptr].d.d_order[1] = srf->order[1];
		rec[rec_ptr].d.d_kv_size[0] = srf->u.k_size;
		rec[rec_ptr].d.d_kv_size[1] = srf->v.k_size;
		rec[rec_ptr].d.d_ctl_size[0] = 	srf->s_size[0];
		rec[rec_ptr].d.d_ctl_size[1] = 	srf->s_size[1];
		rec[rec_ptr].d.d_geom_type = 
			RT_NURB_EXTRACT_COORDS(srf->pt_type);

		vp = (dbfloat_t *) &rec[rec_ptr +1];
		for(n = 0; n < rec[rec_ptr].d.d_kv_size[0]; n++)
		{
			*vp++ = srf->u.knots[n];
		}

		for(n = 0; n < rec[rec_ptr].d.d_kv_size[1]; n++)
		{
			*vp++ = srf->v.knots[n];
		}
		
		vp = (dbfloat_t *) &rec[rec_ptr + 1 +
			rec[rec_ptr].d.d_nknots];

		for( n = 0; n < (srf->s_size[0] * srf->s_size[1]) * 
			rec[rec_ptr].d.d_geom_type; n++)
			*vp++ = srf->ctl_points[n];

		rec_ptr += grans;
		total_grans -= grans;
	}
	return(0);
}

int
rt_nurb_bytes(struct face_g_snurb *srf)
{
	int	total_bytes=0;

	total_bytes = 3 * SIZEOF_NETWORK_LONG		/* num_coords and order */
		+ 2 * SIZEOF_NETWORK_LONG		/* k_size in both knot vectors */
		+ srf->u.k_size * SIZEOF_NETWORK_DOUBLE	/* u knot vector knots */
		+ srf->v.k_size * SIZEOF_NETWORK_DOUBLE	/* v knot vector knots */
		+ 2 * SIZEOF_NETWORK_LONG		/* mesh size */
		+ RT_NURB_EXTRACT_COORDS(srf->pt_type) *
			(srf->s_size[0] * srf->s_size[1]) * SIZEOF_NETWORK_DOUBLE;	/* control point mesh */

	return total_bytes;
}

/*
 *			R T _ N U R B _ E X P O R T 5
 */
int
rt_nurb_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_nurb_internal	* sip;
	int			s;
	unsigned char		*cp;
	int			coords;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_BSPLINE) return(-1);
	sip = (struct rt_nurb_internal *) ip->idb_ptr;
	RT_NURB_CK_MAGIC(sip);

	/* Figure out how many bytes are needed by
	 * walking through the surfaces and
	 * calculating the number of bytes
	 * needed for storage and add it to the total
	 */
	BU_INIT_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_LONG;	/* number of surfaces */
	for( s = 0; s < sip->nsrf; s++)
	{
		ep->ext_nbytes += rt_nurb_bytes(sip->srfs[s]);
	}

	ep->ext_buf = (genptr_t)bu_malloc(ep->ext_nbytes,"nurb external");
	cp = (unsigned char *)ep->ext_buf;

	(void)bu_plong( cp, sip->nsrf );
	cp += SIZEOF_NETWORK_LONG;
	
	for( s = 0; s < sip->nsrf; s++)
	{
		register struct face_g_snurb	*srf = sip->srfs[s];

		NMG_CK_SNURB(srf);

		coords = RT_NURB_EXTRACT_COORDS(srf->pt_type);
		(void)bu_plong( cp, coords );
		cp += SIZEOF_NETWORK_LONG;
		(void)bu_plong( cp, srf->order[0] );
		cp += SIZEOF_NETWORK_LONG;
		(void)bu_plong( cp, srf->order[1] );
		cp += SIZEOF_NETWORK_LONG;
		(void)bu_plong( cp, srf->u.k_size );
		cp += SIZEOF_NETWORK_LONG;
		(void)bu_plong( cp, srf->v.k_size );
		cp += SIZEOF_NETWORK_LONG;
		(void)bu_plong( cp, srf->s_size[0] );
		cp += SIZEOF_NETWORK_LONG;
		(void)bu_plong( cp, srf->s_size[1] );
		cp += SIZEOF_NETWORK_LONG;
		htond( cp, (unsigned char *)srf->u.knots, srf->u.k_size );
		cp += srf->u.k_size * SIZEOF_NETWORK_DOUBLE;
		htond( cp, (unsigned char *)srf->v.knots, srf->v.k_size );
		cp += srf->v.k_size * SIZEOF_NETWORK_DOUBLE;

		htond( cp, (unsigned char *)srf->ctl_points,
			coords * srf->s_size[0] * srf->s_size[1] );
		cp += coords * srf->s_size[0] * srf->s_size[1] * SIZEOF_NETWORK_DOUBLE;
	}

	return(0);
}


/*
 *			R T _ N U R B _ I M P O R T 5
 */
int
rt_nurb_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{

	struct rt_nurb_internal * sip;
	register int		i;
	int			s;
	unsigned char		*cp;
	fastf_t			tmp_vec[4];

	BU_CK_EXTERNAL( ep );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_BSPLINE;
	ip->idb_meth = &rt_functab[ID_BSPLINE];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_nurb_internal), "rt_nurb_internal");
	sip = (struct rt_nurb_internal *)ip->idb_ptr;
	sip->magic = RT_NURB_INTERNAL_MAGIC;

	cp = ep->ext_buf;
	
	sip->nsrf = bu_glong( cp );
	cp += SIZEOF_NETWORK_LONG;
	sip->srfs = (struct face_g_snurb **) bu_calloc(
		sip->nsrf, sizeof( struct face_g_snurb *), "nurb srfs[]");

	for( s = 0; s < sip->nsrf; s++)
	{
		register struct face_g_snurb	*srf;
		int			coords;
		int			pt_type;
		int			order[2], u_size, v_size;
		int			s_size[2];

		pt_type = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;
		order[0] = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;
		order[1] = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;
		u_size = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;
		v_size = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;
		s_size[0] = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;
		s_size[1] = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;
		if( pt_type == 3)
			pt_type = RT_NURB_MAKE_PT_TYPE(3,RT_NURB_PT_XYZ,RT_NURB_PT_NONRAT);
		else
			pt_type = RT_NURB_MAKE_PT_TYPE(4,RT_NURB_PT_XYZ,RT_NURB_PT_RATIONAL);

		sip->srfs[s] = (struct face_g_snurb *) rt_nurb_new_snurb(
			order[0],order[1],
			u_size,v_size,
			s_size[0],s_size[1],
			pt_type, (struct resource *)NULL);

		srf = sip->srfs[s];
		coords = RT_NURB_EXTRACT_COORDS(srf->pt_type);

		ntohd( (unsigned char *)srf->u.knots, cp, srf->u.k_size );
		cp += srf->u.k_size * SIZEOF_NETWORK_DOUBLE;
		ntohd( (unsigned char *)srf->v.knots, cp, srf->v.k_size );
		cp += srf->v.k_size * SIZEOF_NETWORK_DOUBLE;

		rt_nurb_kvnorm( &srf->u);
		rt_nurb_kvnorm( &srf->v);

		ntohd( (unsigned char *)srf->ctl_points, cp,
			coords * srf->s_size[0] * srf->s_size[1] );

		cp += coords * srf->s_size[0] * srf->s_size[1] * SIZEOF_NETWORK_DOUBLE;

		for( i=0 ; i<srf->s_size[0] * srf->s_size[1] ; i++ )
		{
			if( coords == 3 )
			{
				VMOVE( tmp_vec, &srf->ctl_points[i*coords] );
				MAT4X3PNT( &srf->ctl_points[i*coords], mat, tmp_vec );
			}
			else if( coords == 4 )
			{
				HMOVE( tmp_vec, &srf->ctl_points[i*coords] );
				MAT4X4PNT( &srf->ctl_points[i*coords], mat, tmp_vec );
			}
			else
			{
				bu_log("rt_nurb_internal: %d invalid elements per vect\n", coords);
				return (-1);
			}
		}

		/* bound the surface for tolerancing and other bounding box tests */
                rt_nurb_s_bound( sip->srfs[s], sip->srfs[s]->min_pt,
                        sip->srfs[s]->max_pt);
	}
	return (0);
}


int 
rt_nurb_grans(struct face_g_snurb *srf)
{
	int total_knots, total_points;
	int	k_gran;
	int	p_gran;

	total_knots = srf->u.k_size + srf->v.k_size;
	k_gran = ((total_knots * sizeof(dbfloat_t)) + sizeof(union record)-1)
		/ sizeof(union record);

	total_points = RT_NURB_EXTRACT_COORDS(srf->pt_type) *
		(srf->s_size[0] * srf->s_size[1]);
	p_gran = ((total_points * sizeof(dbfloat_t)) + sizeof(union record)-1)
		/ sizeof(union record);

	return 1 + k_gran + p_gran;
}

/*
 *			R T _ N U R B _ I F R E E
 */
void
rt_nurb_ifree(struct rt_db_internal *ip)
{
	register struct rt_nurb_internal * sip;
	register int			 i;

	RT_CK_DB_INTERNAL(ip);
	sip = ( struct rt_nurb_internal *) ip->idb_ptr;
	RT_NURB_CK_MAGIC(sip);

	/* Free up storage for the nurb surfaces */
	for( i = 0; i < sip->nsrf; i++)
	{
		rt_nurb_free_snurb( sip->srfs[i], (struct resource *)NULL );
	}
	bu_free( (char *)sip->srfs, "nurb surfs[]" );
	sip->magic = 0;
	sip->nsrf = 0;
	bu_free( (char *)sip, "sip ifree");
	ip->idb_ptr = GENPTR_NULL;
}

/*
 *			R T _ N U R B _ D E S C R I B E
 */
int
rt_nurb_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register int		j;
	register struct rt_nurb_internal * sip =
		(struct rt_nurb_internal *) ip->idb_ptr;
	int			i;
	int			surf;

	RT_NURB_CK_MAGIC(sip);
	bu_vls_strcat( str, "Non Uniform Rational B-Spline solid (NURB)\n");
	
	bu_vls_printf( str, "\t%d surfaces\n", sip->nsrf);
	if( verbose < 2 )  return 0;

	for( surf = 0; surf < sip->nsrf; surf++)
	{
		register struct face_g_snurb 	* np;
		register fastf_t 	* mp;
		int			ncoord;

		np = sip->srfs[surf];
		NMG_CK_SNURB(np);
		mp = np->ctl_points;
		ncoord = RT_NURB_EXTRACT_COORDS(np->pt_type);

		bu_vls_printf( str,
			"\tSurface %d: order %d x %d, mesh %d x %d\n",
			surf, np->order[0], np->order[1],
			np->s_size[0], np->s_size[1]);

		bu_vls_printf( str, "\t\tVert (%g, %g, %g)\n",
			mp[X] * mm2local, 
			mp[Y] * mm2local, 
			mp[Z] * mm2local);

		if( verbose < 3 ) continue;

		/* Print out the knot vectors */
		bu_vls_printf( str, "\tU: ");
		for( i=0; i < np->u.k_size; i++ )
			bu_vls_printf( str, "%g, ", np->u.knots[i] );
		bu_vls_printf( str, "\n\tV: ");
		for( i=0; i < np->v.k_size; i++ )
			bu_vls_printf( str, "%g, ", np->v.knots[i] );
		bu_vls_printf( str, "\n");
		
		/* print out all the points */
		for(i=0; i < np->s_size[0]; i++)
		{
			bu_vls_printf( str, "\tRow %d:\n", i);
			for( j = 0; j < np->s_size[1]; j++)
			{
				if( ncoord == 3 ) {
					bu_vls_printf( str, "\t\t(%g, %g, %g)\n",
						mp[X] * mm2local, 
						mp[Y] * mm2local, 
						mp[Z] * mm2local);
				} else {
					bu_vls_printf( str, "\t\t(%g, %g, %g, %g)\n",
						mp[X] * mm2local, 
						mp[Y] * mm2local, 
						mp[Z] * mm2local,
						mp[W] );
				}
				mp += ncoord;
			}
		}
	}
	return 0;
}


int
rt_nurb_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
	struct rt_nurb_internal *nurb=(struct rt_nurb_internal *)intern->idb_ptr;
	Tcl_DString		ds;
	struct bu_vls		vls;
	struct face_g_snurb	*srf;
	int			i, j, k;
	int			coords;
	int			status;

	RT_NURB_CK_MAGIC( nurb );

	Tcl_DStringInit( &ds );
	bu_vls_init( &vls );

	if( attr == (char *)NULL ) {
		bu_vls_strcpy( &vls, "bspline" );
		bu_vls_printf( &vls, " N %d S {", nurb->nsrf );
		for( i=0 ; i<nurb->nsrf ; i++ ) {
			srf = nurb->srfs[i];
			bu_vls_printf( &vls, " { O {%d %d} s {%d %d} T %d u {",
				       srf->order[0], srf->order[1],
				       srf->s_size[0], srf->s_size[1],
				       srf->pt_type, srf->u.k_size );
			for( j=0 ; j<srf->u.k_size ; j++ ) {
				bu_vls_printf( &vls, " %.25G", srf->u.knots[j] );
			}
			bu_vls_printf( &vls, "} v {", srf->v.k_size );
			for( j=0 ; j<srf->v.k_size ; j++ ) {
				bu_vls_printf( &vls, " %.25G", srf->v.knots[j] );
			}
			bu_vls_strcat( &vls, "} P {" );
			
			coords = RT_NURB_EXTRACT_COORDS( srf->pt_type );
			for( j=0 ; j<srf->s_size[0]*srf->s_size[1] ; j++ ) {
				for( k=0 ; k<coords ; k++ ) {
					bu_vls_printf( &vls, " %.25G",
						       srf->ctl_points[j*coords + k] );
				}
			}
			bu_vls_strcat( &vls, " } }" );
		}
		bu_vls_printf( &vls, " }" );
		status = TCL_OK;
	} else {
		bu_vls_printf( &vls, "Nurb has no attribute '%s'", attr );
		status = TCL_ERROR;
	}

	Tcl_DStringAppend( &ds, bu_vls_addr( &vls ), -1 );
	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );
	bu_vls_free( &vls );

	return( status );
}

int
rt_nurb_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
{
	struct rt_nurb_internal *nurb;
	int srf_no;
	Tcl_Obj *obj, *list, **srf_array, **srf_param_array;
	struct face_g_snurb *srf;
	int i;
	char *key;
	int len;

	RT_CK_DB_INTERNAL( intern );
	nurb = (struct rt_nurb_internal *)intern->idb_ptr;
	RT_NURB_CK_MAGIC( nurb );

	while( argc >= 2 ) {
		obj = Tcl_NewStringObj( argv[1], -1 );
		list = Tcl_NewListObj( 0, NULL );
		if( Tcl_ListObjAppendList( interp, list, obj ) != TCL_OK ) {
			return( TCL_ERROR );
		}

		if( !strcmp( argv[0], "N" ) ) {
			if( nurb->srfs ) {
				for( i=0 ; i<nurb->nsrf ; i++ )
					rt_nurb_free_snurb( nurb->srfs[i], NULL );
				bu_free( (char *)nurb->srfs, "nurb surfaces" );
			}
			nurb->nsrf = atoi( argv[1] );
			nurb->srfs = (struct face_g_snurb **) bu_calloc(
				nurb->nsrf, sizeof( struct face_g_snurb *), "nurb srfs[]");
		} else if( !strcmp( argv[0], "S" ) ) {
			(void)Tcl_ListObjGetElements( interp, list, &len, &srf_array );
			for( srf_no=0 ; srf_no < nurb->nsrf ; srf_no++ ) {
				int n_params=0;
				int *order=NULL, *s_size=NULL, u_size=0, v_size=0, pt_type=0;
				fastf_t *u_pts=NULL, *v_pts=NULL;

				(void)Tcl_ListObjGetElements( interp, srf_array[srf_no], &n_params,
							      &srf_param_array );
				
				for( i=0 ; i<n_params ; i+= 2 ) {
					int tmp_len;

					key = Tcl_GetStringFromObj( srf_param_array[i], NULL );
					if( !strcmp( key, "O" ) ) {
						tmp_len = 0;
						if( tcl_obj_to_int_array( interp, srf_param_array[i+1],
							      &order, &tmp_len ) != 2 ) {
							Tcl_SetResult( interp,
							      "ERROR: unable to parse surface\n",
							       TCL_STATIC );
							return( TCL_ERROR );
						}
					} else if( !strcmp( key, "s" ) ) {
						tmp_len = 0;
						if( tcl_obj_to_int_array( interp, srf_param_array[i+1],
							      &s_size, &tmp_len ) != 2 ) {
							Tcl_SetResult( interp,
							      "ERROR: unable to parse surface\n",
							       TCL_STATIC );
							return( TCL_ERROR );
						}
					} else if( !strcmp( key, "T" ) ) {
						pt_type = atoi( Tcl_GetStringFromObj(
								     srf_param_array[i+1], NULL ) );
					} else if( !strcmp( key, "u" ) ) {
						tcl_obj_to_fastf_array( interp, srf_param_array[i+1], &u_pts,
									&u_size );
					} else if( !strcmp( key, "v" ) ) {
						tcl_obj_to_fastf_array( interp, srf_param_array[i+1], &v_pts,
									&v_size );
					} else if( !strcmp( key, "P" ) ) {
						int tmp2;

						if( !order || !s_size || !u_pts || !v_pts ||
						    u_size == 0 || v_size == 0 || pt_type == 0 ) {
							Tcl_SetResult( interp,
							    "ERROR: Need all other details set before ctl points\n",
							    TCL_STATIC );
							return( TCL_ERROR );
						}
						nurb->srfs[srf_no] = (struct face_g_snurb *) rt_nurb_new_snurb(
						      order[0],order[1],
						      u_size,v_size,
						      s_size[0],s_size[1],
						      pt_type, (struct resource *)NULL);
						srf = nurb->srfs[srf_no];
						bu_free( (char *)order, "order" );
						bu_free( (char *)s_size, "s_size" );
						(void)memcpy( srf->u.knots, u_pts,
							      srf->u.k_size * sizeof( fastf_t ) );
						(void)memcpy( srf->v.knots, v_pts,
							      srf->v.k_size * sizeof( fastf_t ) );
						bu_free( (char *)u_pts, "u_pts" );
						bu_free( (char *)v_pts, "v_pts" );
						tmp_len = srf->s_size[0] * srf->s_size[1] * 
							RT_NURB_EXTRACT_COORDS(srf->pt_type );
						tmp2 = tmp_len;
						if( tcl_obj_to_fastf_array( interp, srf_param_array[i+1],
							   &srf->ctl_points, &tmp_len ) != tmp2 ) {
							Tcl_SetResult( interp,
							      "ERROR: unable to parse surface\n",
							       TCL_STATIC );
							return( TCL_ERROR );
						}
					}
				}
			}
		}

		Tcl_DecrRefCount( list );

		argc -= 2;
		argv += 2;
	}

	return( TCL_OK );
}
@


11.31
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /cvs/brlcad/librt/g_nurb.c,v 11.30 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.30
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.29
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.28 2003/09/27 00:45:44 morrison Exp $ (BRL)";
d80 1
a80 4
rt_nurb_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal 	*ip;
struct rt_i		*rtip;
d143 1
a143 2
rt_nurb_print( stp )
register const struct soltab *stp;
d174 1
a174 5
rt_nurb_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d319 6
a324 6
rt_nurb_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d335 1
a335 4
rt_nurb_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d363 1
a363 4
rt_nurb_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d394 1
a394 5
rt_nurb_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d407 1
a407 2
rt_nurb_free( stp )
register struct soltab *stp;
d436 1
a436 1
rt_nurb_class()
d445 1
a445 5
rt_nurb_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d469 1
a469 1
		fastf_t		rt_nurb_par_edge();
d575 1
a575 6
rt_nurb_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d584 1
a584 5
rt_nurb_import( ip, ep, mat, dbip )
struct rt_db_internal	*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d683 1
a683 4
rt_conv_uv( n, r, h)
struct nurb_specific * n;
struct xray * r;
struct rt_nurb_uv_hit * h;
d719 1
a719 4
rt_nurb_add_hit( head, hit, tol )
struct nurb_hit		* head;
struct nurb_hit		* hit;
const struct bn_tol	*tol;
d769 1
a769 2
rt_return_nurb_hit( head )
struct nurb_hit * head;
d803 1
a803 5
rt_nurb_export( ep, ip, local2mm, dbip)
struct bu_external	 	* ep;
const struct rt_db_internal	* ip;
double				local2mm;
const struct db_i		*dbip;
d890 1
a890 2
rt_nurb_bytes( srf )
struct face_g_snurb * srf;
d909 1
a909 5
rt_nurb_export5( ep, ip, local2mm, dbip)
struct bu_external	 	* ep;
const struct rt_db_internal	* ip;
double				local2mm;
const struct db_i		*dbip;
d978 1
a978 5
rt_nurb_import5( ip, ep, mat, dbip )
struct rt_db_internal	*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1081 1
a1081 2
rt_nurb_grans( srf )
struct face_g_snurb * srf;
d1103 1
a1103 2
rt_nurb_ifree( ip )
struct rt_db_internal 	*ip;
d1128 1
a1128 5
rt_nurb_describe(str, ip, verbose, mm2local )
struct bu_vls		* str;
const struct rt_db_internal	* ip;
int			verbose;
double			mm2local;
d1201 1
a1201 4
rt_nurb_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d1259 1
a1259 5
rt_nurb_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
@


11.28
log
@make sure M_SQRT1_2 is not already defined before defining it
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1991 by the United States Army.
d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.27 2002/08/20 17:08:00 jra Exp $ (BRL)";
@


11.28.2.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1991-2004 by the United States Army.
d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.29 2004/02/02 17:39:21 morrison Exp $ (BRL)";
@


11.28.2.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.28.2.1 2004/02/12 18:37:41 erikg Exp $ (BRL)";
@


11.27
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.25 2001/10/02 19:24:29 jra Exp $ (BRL)";
d41 3
a43 1
#define M_SQRT1_2       0.70710678118654752440
@


11.27.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1991-2004 by the United States Army.
d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_nurb.c,v 11.29 2004/02/02 17:39:21 morrison Exp $ (BRL)";
d41 1
a41 3
#ifndef M_SQRT1_2
#	define M_SQRT1_2       0.70710678118654752440
#endif /* M_SQRT1_2 */
@


11.27.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.27 2002/08/20 17:08:00 jra Exp $ (BRL)";
d78 4
a81 1
rt_nurb_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d144 2
a145 1
rt_nurb_print(register const struct soltab *stp)
d176 5
a180 1
rt_nurb_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d325 6
a330 6
rt_nurb_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d341 4
a344 1
rt_nurb_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d372 4
a375 1
rt_nurb_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d406 5
a410 1
rt_nurb_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d423 2
a424 1
rt_nurb_free(register struct soltab *stp)
d453 1
a453 1
rt_nurb_class(void)
d462 5
a466 1
rt_nurb_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d490 1
a490 1
		fastf_t		rt_nurb_par_edge(const struct face_g_snurb *srf, fastf_t epsilon);
d596 6
a601 1
rt_nurb_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d610 5
a614 1
rt_nurb_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d713 4
a716 1
rt_conv_uv(struct nurb_specific *n, struct xray *r, struct rt_nurb_uv_hit *h)
d752 4
a755 1
rt_nurb_add_hit(struct nurb_hit *head, struct nurb_hit *hit, const struct bn_tol *tol)
d805 2
a806 1
rt_return_nurb_hit(struct nurb_hit *head)
d840 5
a844 1
rt_nurb_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d931 2
a932 1
rt_nurb_bytes(struct face_g_snurb *srf)
d951 5
a955 1
rt_nurb_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1024 5
a1028 1
rt_nurb_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1131 2
a1132 1
rt_nurb_grans(struct face_g_snurb *srf)
d1154 2
a1155 1
rt_nurb_ifree(struct rt_db_internal *ip)
d1180 5
a1184 1
rt_nurb_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1257 4
a1260 1
rt_nurb_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d1318 5
a1322 1
rt_nurb_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


11.27.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1991-2004 by the United States Army.
d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header$ (BRL)";
d41 1
a41 3
#ifndef M_SQRT1_2
#	define M_SQRT1_2       0.70710678118654752440
#endif /* M_SQRT1_2 */
@


11.26
log
@Converted from K&R to ANSI C - RFH
@
text
@d78 4
a81 1
rt_nurb_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d144 2
a145 1
rt_nurb_print(register const struct soltab *stp)
d176 5
a180 1
rt_nurb_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d325 6
a330 6
rt_nurb_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d341 4
a344 1
rt_nurb_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d372 4
a375 1
rt_nurb_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d406 5
a410 1
rt_nurb_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d423 2
a424 1
rt_nurb_free(register struct soltab *stp)
d453 1
a453 1
rt_nurb_class(void)
d462 5
a466 1
rt_nurb_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d490 1
a490 1
		fastf_t		rt_nurb_par_edge(const struct face_g_snurb *srf, fastf_t epsilon);
d596 6
a601 1
rt_nurb_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d610 5
a614 1
rt_nurb_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d713 4
a716 1
rt_conv_uv(struct nurb_specific *n, struct xray *r, struct rt_nurb_uv_hit *h)
d752 4
a755 1
rt_nurb_add_hit(struct nurb_hit *head, struct nurb_hit *hit, const struct bn_tol *tol)
d805 2
a806 1
rt_return_nurb_hit(struct nurb_hit *head)
d840 5
a844 1
rt_nurb_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d931 2
a932 1
rt_nurb_bytes(struct face_g_snurb *srf)
d951 5
a955 1
rt_nurb_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1024 5
a1028 1
rt_nurb_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1131 2
a1132 1
rt_nurb_grans(struct face_g_snurb *srf)
d1154 2
a1155 1
rt_nurb_ifree(struct rt_db_internal *ip)
d1180 5
a1184 1
rt_nurb_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1257 4
a1260 1
rt_nurb_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d1318 5
a1322 1
rt_nurb_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


11.25
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.24 2001/10/01 20:12:08 jra Exp $ (BRL)";
d78 1
a78 4
rt_nurb_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal 	*ip;
struct rt_i		*rtip;
d141 1
a141 2
rt_nurb_print( stp )
register const struct soltab *stp;
d172 1
a172 5
rt_nurb_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d317 6
a322 6
rt_nurb_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d333 1
a333 4
rt_nurb_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d361 1
a361 4
rt_nurb_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d392 1
a392 5
rt_nurb_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d405 1
a405 2
rt_nurb_free( stp )
register struct soltab *stp;
d434 1
a434 1
rt_nurb_class()
d443 1
a443 5
rt_nurb_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d467 1
a467 1
		fastf_t		rt_nurb_par_edge();
d573 1
a573 6
rt_nurb_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d582 1
a582 5
rt_nurb_import( ip, ep, mat, dbip )
struct rt_db_internal	*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d681 1
a681 4
rt_conv_uv( n, r, h)
struct nurb_specific * n;
struct xray * r;
struct rt_nurb_uv_hit * h;
d717 1
a717 4
rt_nurb_add_hit( head, hit, tol )
struct nurb_hit		* head;
struct nurb_hit		* hit;
const struct bn_tol	*tol;
d767 1
a767 2
rt_return_nurb_hit( head )
struct nurb_hit * head;
d801 1
a801 5
rt_nurb_export( ep, ip, local2mm, dbip)
struct bu_external	 	* ep;
const struct rt_db_internal	* ip;
double				local2mm;
const struct db_i		*dbip;
d888 1
a888 2
rt_nurb_bytes( srf )
struct face_g_snurb * srf;
d907 1
a907 5
rt_nurb_export5( ep, ip, local2mm, dbip)
struct bu_external	 	* ep;
const struct rt_db_internal	* ip;
double				local2mm;
const struct db_i		*dbip;
d976 1
a976 5
rt_nurb_import5( ip, ep, mat, dbip )
struct rt_db_internal	*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1079 1
a1079 2
rt_nurb_grans( srf )
struct face_g_snurb * srf;
d1101 1
a1101 2
rt_nurb_ifree( ip )
struct rt_db_internal 	*ip;
d1126 1
a1126 5
rt_nurb_describe(str, ip, verbose, mm2local )
struct bu_vls		* str;
const struct rt_db_internal	* ip;
int			verbose;
double			mm2local;
d1199 1
a1199 4
rt_nurb_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d1257 1
a1257 5
rt_nurb_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
@


11.24
log
@Added minimal tcl support for nurb solid (BSPLINE)
@
text
@d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.23 2001/05/17 20:05:24 morrison Exp $ (BRL)";
d631 1
d1040 1
@


11.23
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.22 2001/04/20 22:29:45 morrison Exp $ (BRL)";
d26 5
d1253 185
@


11.22
log
@CONST to const
@
text
@d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.21 2001/03/19 22:19:58 butler Exp $ (BRL)";
d241 1
a241 1
				if( rt_g.debug & DEBUG_SPLINE )
@


11.21
log
@patches to merge 5.3 into 6.0
@
text
@d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /d/CVS/brlcad/librt/g_nurb.c,v 11.20 2001/01/24 13:39:23 jra Exp $ (BRL)";
d61 1
a61 1
			struct nurb_hit * hit, CONST struct bn_tol *tol));
d140 1
a140 1
register CONST struct soltab *stp;
d180 1
a180 1
	CONST struct bn_tol	*tol = &ap->a_rt_i->rti_tol;
d460 2
a461 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d595 2
a596 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d607 3
a609 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d749 1
a749 1
CONST struct bn_tol	*tol;
d836 1
a836 1
CONST struct rt_db_internal	* ip;
d838 1
a838 1
CONST struct db_i		*dbip;
d947 1
a947 1
CONST struct rt_db_internal	* ip;
d949 1
a949 1
CONST struct db_i		*dbip;
d1020 3
a1022 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1175 1
a1175 1
CONST struct rt_db_internal	* ip;
@


11.20
log
@Hack to get nurbs with order < 3 to plot
@
text
@d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.19 2000/08/21 02:02:30 butler Exp $ (BRL)";
a511 1

@


11.19
log
@Massive compilation warnings eliminated
@
text
@d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.18 2000/07/10 23:01:32 mike Exp $ (BRL)";
d514 5
a518 1
                tess = (fastf_t) rt_nurb_par_edge(n, rel);
@


11.18
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d20 1
a20 1
static const char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.17 2000/07/08 01:30:36 mike Exp $ (BRL)";
d921 16
a947 1
	register int		rec_ptr;
a949 3
	int			grans;
	dbfloat_t		* vp;
	int			n;
a1118 16
int
rt_nurb_bytes( srf )
struct face_g_snurb * srf;
{
	int	total_bytes=0;

	total_bytes = 3 * SIZEOF_NETWORK_LONG		/* num_coords and order */
		+ 2 * SIZEOF_NETWORK_LONG		/* k_size in both knot vectors */
		+ srf->u.k_size * SIZEOF_NETWORK_DOUBLE	/* u knot vector knots */
		+ srf->v.k_size * SIZEOF_NETWORK_DOUBLE	/* v knot vector knots */
		+ 2 * SIZEOF_NETWORK_LONG		/* mesh size */
		+ RT_NURB_EXTRACT_COORDS(srf->pt_type) *
			(srf->s_size[0] * srf->s_size[1]) * SIZEOF_NETWORK_DOUBLE;	/* control point mesh */

	return total_bytes;
}
@


11.17
log
@
Fixed lint
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.16 2000/06/30 17:45:40 jra Exp $ (BRL)";
@


11.16
log
@Fixed an ancient typo referring to "rt_spl_import"
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.15 2000/06/30 17:41:04 jra Exp $ (BRL)";
d1013 1
a1013 1
	char			*cp;
@


11.15
log
@Added support for database v5
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.14 2000/06/30 15:38:03 mike Exp $ (BRL)";
d618 1
a618 1
		bu_log("rt_spl_import: defective header record");
@


11.14
log
@
export methods should not init the external structure, just check them.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.13 2000/06/30 15:31:15 mike Exp $ (BRL)";
d919 203
@


11.13
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.12 2000/04/12 02:34:34 mike Exp $ (BRL)";
d862 1
a862 1
	BU_INIT_EXTERNAL(ep);
@


11.12
log
@
NT port, non-compat4
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.11 1999/11/26 21:46:47 mike Exp $ (BRL)";
d622 1
a622 1
	RT_INIT_DB_INTERNAL( ip );
@


11.12.2.1
log
@Hack to get nurbs with order less than 3 to plot
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.12 2000/04/12 02:34:34 mike Exp $ (BRL)";
d513 2
a514 5
		if( n->order[0] < 3 || n->order[1] < 3 ) {
			/* Cannot use rt_nurb_par_edge() in this case */
			tess = 0.25;	/* just a hack for now */
		} else
	                tess = (fastf_t) rt_nurb_par_edge(n, rel);
@


11.11
log
@
Lint cleanups
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.10 1999/11/17 02:42:00 mike Exp $ (BRL)";
d201 1
a201 1
	vec_ortho(dir1, rp->r_dir);
d483 2
a484 1
		fastf_t		tess, num_knots;
d516 1
a516 1
                num_knots = floor(1.0/((M_SQRT1_2 / 2.0) * tess));
d518 1
a518 1
                if( num_knots < 2.0) num_knots = 2.0;
@


11.10
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.9 1999/07/02 22:19:23 mike Exp $ (BRL)";
d461 1
a461 1
struct bn_tol		*tol;
d592 1
a592 1
struct bn_tol		*tol;
d601 1
a601 1
rt_nurb_import( ip, ep, mat )
d605 1
d830 1
a830 1
rt_nurb_export( ep, ip, local2mm)
d834 1
d972 1
a972 1
struct rt_db_internal	* ip;
@


11.9
log
@
Removed dependence on compat4.h
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.8 1999/05/27 19:10:40 mike Exp $ (BRL)";
d622 1
@


11.8
log
@
sed4
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_nurb.c,v 11.7 1998/02/05 14:31:52 jra Exp $ (BRL)";
d552 1
a552 1
			RT_ADD_VLIST( vhead, vp, RT_VLIST_LINE_MOVE );
d556 1
a556 1
				RT_ADD_VLIST( vhead, vp, RT_VLIST_LINE_DRAW );
d567 1
a567 1
			RT_ADD_VLIST( vhead, vp, RT_VLIST_LINE_MOVE );
d570 1
a570 1
				RT_ADD_VLIST( vhead, vp, RT_VLIST_LINE_DRAW );
@


11.7
log
@Added a missing argument to rt_pmalloc.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 11.6 1997/09/18 20:32:45 jra Exp jra $ (BRL)";
d41 1
a41 1
	struct rt_list		bez_hd;	/* List of Bezier face_g_snurbs */
d61 1
a61 1
			struct nurb_hit * hit, CONST struct rt_tol *tol));
d92 1
a92 1
		GETSTRUCT( n, nurb_specific);
d100 1
a100 1
		RT_LIST_INIT( &n->bez_hd );
d106 1
a106 1
		for( RT_LIST_FOR( s, face_g_snurb, &n->bez_hd ) )  {
d147 1
a147 1
		rt_log("rt_nurb_print: no surfaces\n");
d180 1
a180 1
	CONST struct rt_tol	*tol = &ap->a_rt_i->rti_tol;
d212 2
a213 2
	rt_mk_plane_3pts( plane1, p1, p3, p2, tol );
	rt_mk_plane_3pts( plane2, p1, p2, p4, tol );
d230 1
a230 1
		for( RT_LIST_FOR( s, face_g_snurb, &nurb->bez_hd ) )  {
d242 1
a242 1
					rt_log("hit at %d %d sub = %d u = %f v = %f\n",
d250 1
a250 1
				rt_free( (char *)o,
d290 1
a290 1
			rt_free( (char *)h2,"rt_nurb_shot: nurb hit");
d304 1
a304 1
		rt_free( (char *)h1, "rt_nurb_shot:nurb hit");
d306 1
a306 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d382 1
a382 1
	 	mat_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
d434 1
a434 1
		while( RT_LIST_WHILE( s, face_g_snurb, &nurb->bez_hd ) )  {
d436 1
a436 1
			RT_LIST_DEQUEUE( &(s->l) );
d440 1
a440 1
		rt_free( (char *)nurb, "nurb_specific" );
d458 1
a458 1
struct rt_list		*vhead;
d461 1
a461 1
struct rt_tol		*tol;
d577 2
a578 2
		rt_free( (char *) tkv1.knots, "rt_nurb_plot:tkv1>knots");
		rt_free( (char *) tkv2.knots, "rt_nurb_plot:tkv2.knots");
d592 1
a592 1
struct rt_tol		*tol;
d603 1
a603 1
CONST struct rt_external	*ep;
d612 1
a612 1
	RT_CK_EXTERNAL( ep );
d616 1
a616 1
		rt_log("rt_spl_import: defective header record");
d622 1
a622 1
	ip->idb_ptr = rt_malloc( sizeof(struct rt_nurb_internal), "rt_nurb_internal");
d628 1
a628 1
	sip->srfs = (struct face_g_snurb **) rt_malloc(
d640 1
a640 1
			rt_log("rt_nurb_import() surf %d bad ID\n", s);
d687 1
a687 1
			rt_log("rt_nurb_internal: %d invalid elements per vect\n", rp->d.d_geom_type);
d710 1
a710 1
	hit = (struct nurb_hit *) rt_malloc( sizeof (struct nurb_hit),
d743 1
a743 1
CONST struct rt_tol	*tol;
d747 1
a747 1
	RT_CK_TOL(tol);
d753 1
a753 1
		rt_free( (char *) hit, "internal_add_hit: hit");
d788 1
a788 1
	rt_free( (char *) hit, "add hit: hit");
d829 1
a829 1
struct rt_external	 	* ep;
d858 1
a858 1
	RT_INIT_EXTERNAL(ep);
d860 1
a860 1
	ep->ext_buf = (genptr_t)rt_calloc(1,ep->ext_nbytes,"nurb external");
d956 1
a956 1
	rt_free( (char *)sip->srfs, "nurb surfs[]" );
d959 1
a959 1
	rt_free( (char *)sip, "sip ifree");
d968 1
a968 1
struct rt_vls		* str;
d980 1
a980 1
	rt_vls_strcat( str, "Non Uniform Rational B-Spline solid (NURB)\n");
d982 1
a982 1
	rt_vls_printf( str, "\t%d surfaces\n", sip->nsrf);
d996 1
a996 1
		rt_vls_printf( str,
d1001 1
a1001 1
		rt_vls_printf( str, "\t\tVert (%g, %g, %g)\n",
d1009 1
a1009 1
		rt_vls_printf( str, "\tU: ");
d1011 2
a1012 2
			rt_vls_printf( str, "%g, ", np->u.knots[i] );
		rt_vls_printf( str, "\n\tV: ");
d1014 2
a1015 2
			rt_vls_printf( str, "%g, ", np->v.knots[i] );
		rt_vls_printf( str, "\n");
d1020 1
a1020 1
			rt_vls_printf( str, "\tRow %d:\n", i);
d1024 1
a1024 1
					rt_vls_printf( str, "\t\t(%g, %g, %g)\n",
d1029 1
a1029 1
					rt_vls_printf( str, "\t\t(%g, %g, %g, %g)\n",
@


11.6
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 11.5 1995/12/01 02:47:38 mike Exp jra $ (BRL)";
d236 1
a236 1
				s, plane1, plane2, UV_TOL, (struct resource *)NULL );
@


11.5
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 11.4 1995/09/20 10:59:46 jra Exp $ (BRL)";
d95 1
a95 1
		s = rt_nurb_scopy (sip->srfs[i]);
d103 1
a103 1
		(void)rt_nurb_bezier( &n->bez_hd, sip->srfs[i] );
d236 1
a236 1
				s, plane1, plane2, UV_TOL );
d437 1
a437 1
			rt_nurb_free_snurb( s );
d439 1
a439 1
		rt_nurb_free_snurb( nurb->srf );	/* original surf */
d521 1
a521 1
                        n->u.knots[n->u.k_size-1], num_knots);
d525 1
a525 1
                        n->v.knots[n->v.k_size-1], num_knots);
d528 2
a529 2
		r = (struct face_g_snurb *) rt_nurb_s_refine( n, RT_NURB_SPLIT_COL, &tkv2);
		c = (struct face_g_snurb *) rt_nurb_s_refine( r, RT_NURB_SPLIT_ROW, &tkv1);
d574 2
a575 2
		rt_nurb_free_snurb(c);
		rt_nurb_free_snurb(r);
d653 1
a653 1
			pt_type);
d954 1
a954 1
		rt_nurb_free_snurb( sip->srfs[i] );
@


11.4
log
@Added definition of M_SQRT1_2 since sgi's math.h skips it for POSIX.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/g_nurb.c,v 11.3 95/05/05 14:18:36 stay Exp Locker: jra $ (BRL)";
d40 2
a41 2
	struct snurb *		srf;	/* Original surface description */
	struct rt_list		bez_hd;	/* List of Bezier snurbs */
d56 1
a56 1
RT_EXTERN(int rt_nurb_grans, (struct snurb * srf));
d89 1
a89 1
		struct snurb * s;
d94 1
a94 1
		/* Store off the original snurb */
d102 1
a102 1
		/* Grind up the original surf into a list of Bezier snurbs */
d105 2
a106 2
		/* Compute bounds of each Bezier snurb */
		for( RT_LIST_FOR( s, snurb, &n->bez_hd ) )  {
d227 1
a227 1
		struct snurb * s;
d230 1
a230 1
		for( RT_LIST_FOR( s, snurb, &nurb->bez_hd ) )  {
d344 1
a344 1
	struct snurb * n  = (struct snurb *) hitp->hit_private;
d374 1
a374 1
	struct snurb * srf = (struct snurb *) hitp->hit_private;
d429 1
a429 1
		register struct snurb	*s;
d434 1
a434 1
		while( RT_LIST_WHILE( s, snurb, &nurb->bez_hd ) )  {
d476 1
a476 1
		struct snurb 	* n, *r, *c;
d486 1
a486 1
		n = (struct snurb *) sip->srfs[s];
d520 2
a521 2
                        n->u_knots.knots[0],
                        n->u_knots.knots[n->u_knots.k_size-1], num_knots);
d524 2
a525 2
                        n->v_knots.knots[0],
                        n->v_knots.knots[n->v_knots.k_size-1], num_knots);
d528 2
a529 2
		r = (struct snurb *) rt_nurb_s_refine( n, RT_NURB_SPLIT_COL, &tkv2);
		c = (struct snurb *) rt_nurb_s_refine( r, RT_NURB_SPLIT_ROW, &tkv1);
d628 2
a629 2
	sip->srfs = (struct snurb **) rt_malloc(
		sip->nsrf * sizeof( struct snurb), "nurb srfs[]");
d649 1
a649 1
		sip->srfs[s] = (struct snurb *) rt_nurb_new_snurb(
d658 1
a658 1
			sip->srfs[s]->u_knots.knots[i] = (fastf_t) *vp++;
d661 1
a661 1
			sip->srfs[s]->v_knots.knots[i] = (fastf_t) *vp++;
d663 2
a664 2
		rt_nurb_kvnorm( &sip->srfs[s]->u_knots);
		rt_nurb_kvnorm( &sip->srfs[s]->v_knots);
d870 1
a870 1
		register struct snurb	*srf = sip->srfs[s];
d876 1
a876 1
		rec[rec_ptr].d.d_nknots = (((srf->u_knots.k_size + srf->v_knots.k_size) 
d886 2
a887 2
		rec[rec_ptr].d.d_kv_size[0] = srf->u_knots.k_size;
		rec[rec_ptr].d.d_kv_size[1] = srf->v_knots.k_size;
d896 1
a896 1
			*vp++ = srf->u_knots.knots[n];
d901 1
a901 1
			*vp++ = srf->v_knots.knots[n];
d919 1
a919 1
struct snurb * srf;
d925 1
a925 1
	total_knots = srf->u_knots.k_size + srf->v_knots.k_size;
d987 1
a987 1
		register struct snurb 	* np;
d1010 2
a1011 2
		for( i=0; i < np->u_knots.k_size; i++ )
			rt_vls_printf( str, "%g, ", np->u_knots.knots[i] );
d1013 2
a1014 2
		for( i=0; i < np->v_knots.k_size; i++ )
			rt_vls_printf( str, "%g, ", np->v_knots.knots[i] );
@


11.3
log
@added adaptive tessleation for plotting, (mged)
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/g_nurb.c,v 11.2 1995/01/24 19:06:14 stay Exp stay $ (BRL)";
d35 2
@


11.2
log
@deleted a rt_free to a unallocated variable.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 11.1 1995/01/04 09:56:49 mike Rel4_4 stay $ (BRL)";
d466 1
a466 4
	struct knot_vector 	tkv1,
				tkv2,
				tau1,
				tau2;
d476 7
d486 39
a524 10
		rt_nurb_kvgen( &tkv1,
			n->u_knots.knots[0],
			n->u_knots.knots[n->u_knots.k_size-1], 10);

		rt_nurb_kvgen( &tkv2,
			n->v_knots.knots[0],
			n->v_knots.knots[n->v_knots.k_size-1], 10);
		
		rt_nurb_kvmerge(&tau1, &tkv1, &n->u_knots);
		rt_nurb_kvmerge(&tau2, &tkv2, &n->v_knots);
d526 2
a527 2
		r = (struct snurb *) rt_nurb_s_refine( n, RT_NURB_SPLIT_COL, &tau2);
		c = (struct snurb *) rt_nurb_s_refine( r, RT_NURB_SPLIT_ROW, &tau1);
a574 2
		rt_free( (char *) tau1.knots, "rt_nurb_plot:tau1.knots");
		rt_free( (char *) tau2.knots, "rt_nurb_plot:tau2.knots");
d689 4
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.18 94/12/27 15:21:33 stay Exp $ (BRL)";
a692 2
	rt_free( (char *) pt, "point");
	
d715 1
@


10.18
log
@fixed call to rt_nurb_s_norm to pass the normal.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/g_nurb.c,v 10.17 1994/10/18 02:01:42 mike Exp stay $ (BRL)";
@


10.17
log
@Fixed two memory leaks.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.16 94/08/27 02:04:16 mike Exp Locker: mike $ (BRL)";
d345 1
a345 1
	fastf_t * norm;
d347 1
a347 1
	norm = (fastf_t *) rt_nurb_s_norm( n, u, v);
a355 2
	rt_free((char *) norm, "rt_nurb_norm: norm");
	
d670 1
a670 1
	fastf_t * pt;
d679 1
a679 1
	pt = (fastf_t *) rt_nurb_s_eval(n->srf, h->u, h->v);
@


10.16
log
@nurb.h must come before nmg.h
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.15 94/08/10 18:36:35 gdurf Exp Locker: mike $ (BRL)";
d151 1
d423 1
d425 17
a441 1
	rt_free( (char *)nurb, "nurb_specific" );
d903 3
d922 1
@


10.15
log
@Added include of conf.h.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.14 1994/08/09 17:23:42 stay Exp gdurf $ (BRL)";
d31 1
a32 1
#include "nurb.h"
@


10.14
log
@removed rt_nurb_pbound and added it to the libnurb package.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.13 1993/10/01 21:00:00 mike Exp stay $ (BRL)";
d22 2
@


10.13
log
@ANSI lint
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.12 93/09/25 11:51:01 mike Exp Locker: mike $ (BRL)";
a983 27
rt_nurb_pbound( srf, vmin, vmax)
struct snurb * srf;
point_t vmin, vmax;
{
	register fastf_t * ptr;
	register int coords;
	int i;
	
 	vmin[0] = vmin[1] = vmin[2] = INFINITY;
	vmax[0] = vmax[1] = vmax[2] = -INFINITY;

	ptr = srf->ctl_points;

	coords = RT_NURB_EXTRACT_COORDS(srf->pt_type);

	for( i = (srf->s_size[RT_NURB_SPLIT_ROW] * 
	    srf->s_size[RT_NURB_SPLIT_COL] ); i > 0; i--)
	{
		V_MIN( (vmin[0]), (ptr[0]));
		V_MAX( (vmax[0]), (ptr[0]));

		V_MIN( (vmin[1]), (ptr[1]));
		V_MAX( (vmax[1]), (ptr[1]));
		
		ptr += coords;
	}
}
@


10.12
log
@Made rt_nurb_add_hit() a void function.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.11 92/06/12 23:52:16 mike Exp Locker: mike $ (BRL)";
d56 2
d688 3
a690 3
struct nurb_hit * head;
struct nurb_hit * hit;
struct rt_tol	*tol;
d694 1
d908 1
d925 1
a925 1
	if( verbose < 2 )  return;
@


10.11
log
@Moved rt_nurb_internal to rtgeom.h
Added _describe support to print knot vectors
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.10 92/06/11 23:56:13 mike Exp Locker: mike $ (BRL)";
d684 1
@


10.10
log
@Fixed rt_nurb_export(), changed rt_nurb_describe() to rt_vls_printf()
@
text
@d8 1
a8 1
	Paul R. Stay
d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.9 92/06/03 23:23:49 mike Exp Locker: mike $ (BRL)";
d31 1
a33 9
struct rt_nurb_internal {
	long	magic;
	int 	nsrf;	/* number of surfaces */
	struct snurb ** srfs;
};

#define RT_NURB_INTERNAL_MAGIC	0x002b2bdd
#define RT_NURB_CK_MAGIC( _p) RT_CKMAG(_p,RT_NURB_INTERNAL_MAGIC,"rt_nurb_internal");

d920 1
d938 1
a938 1
		rt_vls_printf( str, "\t\tV (%g, %g, %g)\n",
d943 10
a952 1
		if( !verbose ) continue;
@


10.9
log
@Eliminated nurb_b_list structure, changed to using rt_list's.
snurb bounding box is now in min_pt and max_pt elements of snurb.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.8 92/06/02 23:26:01 mike Exp Locker: mike $ (BRL)";
d594 5
d774 3
d789 1
a789 1
	double			* vp;
d793 1
a793 1
	if( ip->idb_type != ID_BSOLID) return(-1);
d820 2
a821 1
		grans = rt_nurb_grans( sip->srfs[s]);
d823 2
d826 14
a839 6
		rec[rec_ptr].d.d_order[0] = sip->srfs[s]->order[0];
		rec[rec_ptr].d.d_order[1] = sip->srfs[s]->order[1];
		rec[rec_ptr].d.d_kv_size[0] = sip->srfs[s]->u_knots.k_size;
		rec[rec_ptr].d.d_kv_size[1] = sip->srfs[s]->v_knots.k_size;
		rec[rec_ptr].d.d_ctl_size[0] = 	sip->srfs[s]->s_size[0];
		rec[rec_ptr].d.d_ctl_size[1] = 	sip->srfs[s]->s_size[1];
d841 1
a841 1
			RT_NURB_EXTRACT_COORDS(sip->srfs[s]->pt_type);
d843 1
a843 1
		vp = (double *) &rec[rec_ptr +1];
d846 1
a846 1
			*vp++ = sip->srfs[s]->u_knots.knots[n];
d851 1
a851 1
			*vp++ = sip->srfs[s]->v_knots.knots[n];
d854 2
a855 2
		vp = (double *) &rec[(rec[rec_ptr].d.d_kv_size[0] + 
			rec[rec_ptr].d.d_kv_size[0] + 7) /8];
d857 1
a857 2
		for( n = 0; n < (rec[rec_ptr].d.d_ctl_size[0] + 
			rec[rec_ptr].d.d_ctl_size[1]) * 
d859 1
a859 1
			*vp++ = sip->srfs[s]->ctl_points[n];
a870 1
	int grans = 0;
d872 2
d875 3
a877 4
	grans++;
	total_knots = srf->u_knots.k_size +
		srf->v_knots.k_size;
	grans += (total_knots+7)/8;
d880 3
a882 2
		(srf->s_size[0] +
		srf->s_size[1]);
d884 1
a884 3
	grans += (total_points + 7)/8;

	return grans;
d909 3
a920 1
	char 			buf[256];
d925 1
a925 1
	rt_vls_strcat( str, "Non Uniform Rational B-SPline solid (nurb)\n");
d927 1
a927 2
	sprintf( buf, "\t%d surfaces\n", sip->nsrf);
	rt_vls_strcat( str, buf );
d933 1
d936 1
d938 1
d940 2
a941 1
		sprintf( buf, "\tSurface %d: order %d x %d, mesh %d x %d\n",
a943 1
		rt_vls_strcat( str, buf);
d945 1
a945 1
		sprintf( buf, "\t\tV (%g, %g, %g)\n",
a949 2
		rt_vls_strcat( str, buf);
		
d955 1
a955 2
			sprintf( buf,"\tRT_NURB_SPLIT_ROW %d:\n", i);
			rt_vls_strcat( str, buf );
d958 13
a970 6
				sprintf( buf, "\t\t(%g, %g, %g)\n",
					mp[X] * mm2local, 
					mp[Y] * mm2local, 
					mp[Z] * mm2local);
				rt_vls_strcat( str, buf);
				mp += RT_NURB_EXTRACT_COORDS(np->pt_type);
@


10.8
log
@Changed to using rt_nurb_curvature, rather than using inline code.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.7 92/06/02 22:45:48 mike Exp Locker: mike $ (BRL)";
a41 7
struct nurb_b_list {
	struct nurb_b_list *	next;
	point_t 		min,	/* bounding box */
				max;
	struct snurb * 		srf;	/* bezier form of surface */
};

d44 2
a45 4
	point_t		        min,	/* Bounding box of surface */
			        max;
	struct snurb *		srf;	/* Surface description */
	struct nurb_b_list *	b_list; /* Converted into bezier form */
a92 1
		struct rt_list	bezier;
d97 3
a99 3
		n->srf = rt_nurb_scopy (sip->srfs[i]);
		NMG_CK_SNURB(n->srf);
		rt_nurb_s_bound(n->srf, n->min, n->max);
d101 5
a105 1
		n->b_list = (struct nurb_b_list *)0;
d107 2
a108 7
		RT_LIST_INIT( &bezier );
		(void)rt_nurb_bezier( &bezier, sip->srfs[i] );
		
		/* Pull off each Bezier snurb, and wrap with nurb_b_list */
		while( RT_LIST_WHILE( s, snurb, &bezier ) )  {
			struct nurb_b_list *b;

d110 3
a112 11
			RT_LIST_DEQUEUE( &s->l );
			b = (struct nurb_b_list *) rt_malloc( 
				sizeof(struct nurb_b_list ),
				"rt_nurb_prep:nurb_b_list");
			b->srf = s;
			rt_nurb_s_bound( s, b->min, b->max);
			
			VMINMAX( stp->st_min, stp->st_max, b->min);
			VMINMAX( stp->st_min, stp->st_max, b->max);
			b->next = n->b_list;
			n->b_list = b;
d228 1
a228 1
		struct nurb_b_list * n;
d231 2
a232 6
		n = nurb->b_list;
		while( n != (struct nurb_b_list *)0)
		{
			if( !rt_in_rpp( rp, invdir, n->min, n->max))
			{
				n = n -> next;
a233 1
			}
d237 1
a237 1
				n->srf, plane1, plane2, UV_TOL );
a255 1
			n = n->next;  
@


10.7
log
@Changed to rt_list structs
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.5 92/06/02 16:43:29 mike Exp Locker: mike $ (BRL)";
d278 1
a278 1
				rt_nurb_add_hit( &hit_list, hit);
a402 2
	struct snurb * us, *vs, * uus, * vvs, *uvs;
	fastf_t *ue, *ve, *uue, *vve, *uve, *se;
a403 8
        fastf_t         E, F, G;                /* First Fundamental Form */
        fastf_t         L, M, N;                /* Second Fundamental form */
        fastf_t         denom;
        fastf_t         wein[4];                /*Weingarten matrix */
        fastf_t         evec[3];
        fastf_t         mean, gauss, discrim;
        vect_t          norm;
	int 		i;
a406 1

d410 1
a410 1
	 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
d417 2
a418 105
	us = (struct snurb *) rt_nurb_s_diff(srf, RT_NURB_SPLIT_ROW);
	vs = (struct snurb *) rt_nurb_s_diff(srf, RT_NURB_SPLIT_COL);
	uus = (struct snurb *) rt_nurb_s_diff(us, RT_NURB_SPLIT_ROW);
	vvs = (struct snurb *) rt_nurb_s_diff(vs, RT_NURB_SPLIT_COL);
	uvs = (struct snurb *) rt_nurb_s_diff(vs, RT_NURB_SPLIT_ROW);
	
	se = (fastf_t *) rt_nurb_s_eval(srf, u, v);
	ue = (fastf_t *) rt_nurb_s_eval(us, u,v);
	ve = (fastf_t *) rt_nurb_s_eval(vs, u,v);
	uue = (fastf_t *) rt_nurb_s_eval(uus, u,v);
	vve = (fastf_t *) rt_nurb_s_eval(vvs, u,v);
	uve = (fastf_t *) rt_nurb_s_eval(uvs, u,v);

	rt_nurb_free_snurb( us);
	rt_nurb_free_snurb( vs);
	rt_nurb_free_snurb( uus);
	rt_nurb_free_snurb( vvs);
	rt_nurb_free_snurb( uvs);

	if( RT_NURB_IS_PT_RATIONAL( srf->pt_type ))
	{
		for( i = 0; i < 3; i++)
		{
			ue[i] = (1.0 / se[3] * ue[i]) -
				(ue[3]/se[3]) * se[0]/se[3];
			ve[i] = (1.0 / se[3] * ve[i]) -
				(ve[3]/se[3]) * se[0]/se[3];
		}
		VCROSS(norm, ue, ve);
		VUNITIZE(norm);
		E = VDOT( ue, ue);
		F = VDOT( ue, ve);
		G = VDOT( ve, ve);
		
		for( i = 0; i < 3; i++)
		{
			uue[i] = (1.0 / se[3] * uue[i]) -
				2 * (uue[3]/se[3]) * uue[i] -
				uue[3]/se[3] * (se[i]/se[3]);

			vve[i] = (1.0 / se[3] * vve[i]) -
				2 * (vve[3]/se[3]) * vve[i] -
				vve[3]/se[3] * (se[i]/se[3]);

			 uve[i] = 1.0 / se[3] * uve[i] +
	                        (-1.0 / (se[3] * se[3])) *
        	                (ve[3] * ue[i] + ue[3] * ve[i] +
                	         uve[3] * se[i]) + 
				(-2.0 / (se[3] * se[3] * se[3])) *
	                        (ve[3] * ue[3] * se[i]);
		}

		L = VDOT( norm, uue);
		M = VDOT( norm, uve);
		N = VDOT( norm, vve);
		
	} else
	{
		VCROSS( norm, ue, ve);
		VUNITIZE( norm );
		E = VDOT( ue, ue);
		F = VDOT( ue, ve);
		G = VDOT( ve, ve);
		
		L = VDOT( norm, uue);
		M = VDOT( norm, uve);
		N = VDOT( norm, vve);
	}

	denom = ( (E*G) - (F*F) );
	gauss = (L * N - M *M)/denom;
	mean = (G * L + E * N - 2 * F * M) / (2 * denom);
	discrim = sqrt( mean * mean - gauss);
	
	cvp->crv_c1 = mean - discrim;
	cvp->crv_c2 = mean + discrim;

	if( APX_EQ( ( E*G - F*F), 0.0 ))
	{
		rt_log("first fundamental form is singular E = %g F= %g G = %g\n",
			E,F,G);
		goto cleanup;
	}


        wein[0] = ( (G * L) - (F * M))/ (denom);
        wein[1] = ( (G * M) - (F * N))/ (denom);
        wein[2] = ( (E * M) - (F * L))/ (denom);
        wein[3] = ( (E * N) - (F * M))/ (denom);


        if ( APX_EQ( wein[1] , 0.0 ) && APX_EQ( wein[3] - cvp->crv_c1, 0.0) )
        {
                evec[0] = 0.0; evec[1] = 1.0;
        } else
        {
                evec[0] = 1.0;
                if( fabs( wein[1] ) > fabs( wein[3] - cvp->crv_c1) )
                {
                        evec[1] = (cvp->crv_c1 - wein[0]) / wein[1];
                } else
                {
                        evec[1] = wein[2] / ( cvp->crv_c1 - wein[3] );
                }
        }
a419 15
        VSET( cvp->crv_pdir, 0.0, 0.0, 0.0 );
	cvp->crv_pdir[0] = evec[0] * ue[0] + evec[1] * ve[0];
        cvp->crv_pdir[1] = evec[0] * ue[1] + evec[1] * ve[1];
        cvp->crv_pdir[2] = evec[0] * ue[2] + evec[1] * ve[2];
	VUNITIZE( cvp->crv_pdir);

cleanup:
	rt_free( (char *) se, "rt_nurb_curv:se");
	rt_free( (char *) ue, "rt_nurb_curv:ue");
	rt_free( (char *) ve, "rt_nurb_curv:ve");
	rt_free( (char *) uue, "rt_nurb_curv:uue");
	rt_free( (char *) vve, "rt_nurb_curv:vve");
	rt_free( (char *) uve, "rt_nurb_curv:uve");
}

d712 1
a712 3
#define EQ_HIT(a,b) ( fabs((a) - (b)) < EPSILON)

rt_nurb_add_hit( head, hit )
d715 1
d728 1
d739 11
a749 7
		if( EQ_HIT(hit->hit_dist,h_ptr->hit_dist) &&
			EQ_HIT(hit->hit_uv[0], h_ptr->hit_uv[0]) &&
			EQ_HIT(hit->hit_uv[1], h_ptr->hit_uv[1]) )
		{
			rt_free( (char *) hit, "add hit: hit");
			return;
		}
d756 4
@


10.6
log
@Changed name of uv_hit,
moved rt_nurb_intersect to libnurb/nurb_ray.c
@
text
@d102 1
d106 4
a109 1
		n->srf = (struct snurb *) rt_nurb_scopy (sip->srfs[i]);
a111 2

		rt_nurb_s_bound(n->srf, n->min, n->max);
d113 2
a114 1
		s = (struct snurb *) rt_nurb_bezier(n->srf);
d116 2
a117 2
		while( s != (struct snurb *)0 )
		{
d120 2
a129 2
			s = s->next;
			b->srf->next = (struct snurb *)0;
@


10.5
log
@Modified for new data structures
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.4 92/05/29 01:12:28 mike Exp Locker: mike $ (BRL)";
a68 6
struct uv_hit {
	struct uv_hit * next;
	int sub;
	fastf_t u, v;
};

d71 1
a71 3
	struct xray *r, struct uv_hit *h));
RT_EXTERN(struct uv_hit *rt_nurb_intersect, (struct snurb * srf,
	plane_t plane1, plane_t plane2));
d245 1
a245 1
		struct uv_hit *hp;
d256 4
a259 3
			hp = (struct uv_hit *) rt_nurb_intersect(
				n->srf, plane1, plane2);
			while( hp != (struct uv_hit *)0)
d261 1
a261 1
				struct uv_hit * o;
d273 1
a273 1
					"rt_nurb_shot:uv_hit structure");
a796 150
struct uv_hit *
rt_nurb_intersect( srf, plane1, plane2)
struct snurb * srf;
plane_t plane1;
plane_t plane2;
{
	struct uv_hit * h;
	struct snurb 	* psrf,
			* s_list,
			* osrf;
	int 		dir,
			sub;

	point_t 	vmin,
			vmax;
	fastf_t 	u[2],
			v[2];


	h = (struct uv_hit *) 0;
	/* project the surface to a 2 dimensional problem */
	s_list = (struct snurb * ) rt_nurb_project_srf(
		srf, plane2, plane1);

	if( rt_g.debug & DEBUG_SPLINE )
		rt_nurb_s_print("srf", s_list);


	s_list->dir = 1;

	while ( s_list != ( struct snurb *)0)
	{
		int flat;
		
		psrf = s_list;
		s_list = s_list->next;

		sub = 0;
		flat = 0;
		dir = psrf->dir;
		
		while(!flat)
		{
			fastf_t smin, smax;

			sub++;
			dir = (dir == 0)?1:0;	/* change direction */
			
			if( rt_g.debug & DEBUG_SPLINE )
				rt_nurb_s_print("psrf", psrf);

			rt_nurb_pbound( psrf, vmin, vmax);

			/* Check for origin to be included in the bounding box */
			if( !(vmin[0] <= 0.0 && vmin[1] <= 0.0 &&
				vmax[0] >= 0.0 && vmax[1] >= 0.0 ))
			{
				flat = 1;
				rt_nurb_free_snurb( psrf );
				continue;
			}

			rt_nurb_clip_srf( psrf, dir, &smin, &smax);

			if( (smax - smin) > .8)
			{
				struct snurb * s;

				s = (struct snurb *) rt_nurb_s_split(
					psrf, dir );
				s->dir = dir;
				s->next->dir = dir;
				s->next->next = s_list;
				s_list = s->next;
				
				rt_nurb_free_snurb( psrf );

				psrf = s;
				psrf->next = (struct snurb *) 0;
				continue;
			}
			if( smin > 1.0 || smax < 0.0 )
			{
				flat = 1;
				rt_nurb_free_snurb( psrf );
				
				continue;
			}
			if ( dir == RT_NURB_SPLIT_ROW)
			{
		                smin = (1.0 - smin) * psrf->u_knots.knots[0] +
                		        smin * psrf->u_knots.knots[
		                        psrf->u_knots.k_size -1];
		                smax = (1.0 - smax) * psrf->u_knots.knots[0] +
		                        smax * psrf->u_knots.knots[
                		        psrf->u_knots.k_size -1];
			} else
			{
	                        smin = (1.0 - smin) * psrf->v_knots.knots[0] +
        	                        smin * psrf->v_knots.knots[
                	                psrf->v_knots.k_size -1];
                        	smax = (1.0 - smax) * psrf->v_knots.knots[0] +
                                	smax * psrf->v_knots.knots[
	                                psrf->v_knots.k_size -1];
			}

			osrf = psrf;
			psrf = (struct snurb *)	rt_nurb_region_from_srf(
				osrf, dir, smin, smax);

			psrf->dir = dir;
			rt_nurb_free_snurb(osrf);

			u[0] = psrf->u_knots.knots[0];
			u[1] = psrf->u_knots.knots[psrf->u_knots.k_size -1];

			v[0] = psrf->v_knots.knots[0];
			v[1] = psrf->v_knots.knots[psrf->v_knots.k_size -1];
			
#define UV_TOL	1.0e-6	/* Paper says 1.0e-4 is reasonable for 1k images, not close up */
                        if( (u[1] - u[0]) < UV_TOL && (v[1] - v[0]) < UV_TOL)
                        {
				struct uv_hit * hit;
                        	hit = (struct uv_hit *) rt_malloc(
                        		sizeof( struct uv_hit), 
                        		"rt_nurb_intersect:uv_hit structure");
                        	hit->next = (struct uv_hit *)0;
                        	hit->sub = sub;
                        	hit->u = (u[0] + u[1])/2.0;
                        	hit->v = (v[0] + v[1])/2.0;
                        	
                        	if( h == (struct uv_hit *)0)
                        		h = hit;
                        	else
                        	{
                        		hit->next = h;
                        		h = hit;
                        	}
                        	flat = 1;
                        	rt_nurb_free_snurb( psrf );
                        }
			if( (u[1] - u[0]) > (v[1] - v[0]) )
				dir = 1;
			else dir = 0;
		}
	}

	return (struct uv_hit *)h;
}

d801 1
a801 1
struct uv_hit * h;
@


10.4
log
@First set of datastructure changes
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.3 92/05/28 22:10:29 mike Exp Locker: mike $ (BRL)";
d451 1
a451 1
	if( RT_NURB_IS_PT_RATIONAL( srf->mesh.pt_type ))
d642 1
a642 1
		coords = RT_NURB_EXTRACT_COORDS(n->mesh.pt_type);
d644 1
a644 1
		if( RT_NURB_IS_PT_RATIONAL(n->mesh.pt_type))
d646 1
a646 1
			vp = c->mesh.ctl_points;
d648 1
a648 1
				i < c->mesh.s_size[0] * c->mesh.s_size[1]; 
d660 2
a661 2
		vp = c->mesh.ctl_points;
		for( i = 0; i < c->mesh.s_size[0]; i++)
d665 1
a665 1
			for( j = 1; j < c->mesh.s_size[1]; j++)
d672 1
a672 1
		for( j = 0; j < c->mesh.s_size[1]; j++)
d676 2
a677 2
			stride = c->mesh.s_size[1] * coords;
			vp = &c->mesh.ctl_points[j * coords];
d679 1
a679 1
			for( i = 0; i < c->mesh.s_size[0]; i++)
d775 1
a775 1
		m = sip->srfs[s]->mesh.ctl_points;
d972 1
a972 1
	if( RT_NURB_IS_PT_RATIONAL(n->srf->mesh.pt_type) )
d1119 2
a1120 2
		rec[rec_ptr].d.d_ctl_size[0] = 	sip->srfs[s]->mesh.s_size[0];
		rec[rec_ptr].d.d_ctl_size[1] = 	sip->srfs[s]->mesh.s_size[1];
d1122 1
a1122 1
			RT_NURB_EXTRACT_COORDS(sip->srfs[s]->mesh.pt_type);
d1141 1
a1141 1
			*vp++ = sip->srfs[s]->mesh.ctl_points[n];
d1161 3
a1163 3
	total_points = RT_NURB_EXTRACT_COORDS(srf->mesh.pt_type) *
		(srf->mesh.s_size[0] +
		srf->mesh.s_size[1]);
d1217 1
a1217 1
		mp = np->mesh.ctl_points;
d1221 1
a1221 1
			np->mesh.s_size[0], np->mesh.s_size[1]);
d1234 1
a1234 1
		for(i=0; i < np->mesh.s_size[0]; i++)
d1238 1
a1238 1
			for( j = 0; j < np->mesh.s_size[1]; j++)
d1245 1
a1245 1
				mp += RT_NURB_EXTRACT_COORDS(np->mesh.pt_type);
d1263 1
a1263 1
	ptr = srf->mesh.ctl_points;
d1265 1
a1265 1
	coords = RT_NURB_EXTRACT_COORDS(srf->mesh.pt_type);
d1267 2
a1268 2
	for( i = (srf->mesh.s_size[RT_NURB_SPLIT_ROW] * 
	    srf->mesh.s_size[RT_NURB_SPLIT_COL] ); i > 0; i--)
@


10.3
log
@Expanded names of manifest constants.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.2 92/04/13 09:58:55 stay Exp Locker: mike $ (BRL)";
d451 1
a451 1
	if( RT_NURB_IS_PT_RATIONAL( srf->mesh->pt_type ))
d612 4
a615 4
	struct knot_vector 	* tkv1,
				* tkv2,
				* tau1,
				* tau2;
d628 3
a630 3
		tkv1 = (struct knot_vector *) rt_nurb_kvgen(
			n->u_knots->knots[0],
			n->u_knots->knots[n->u_knots->k_size-1], 10);
d632 3
a634 3
		tkv2 = (struct knot_vector *) rt_nurb_kvgen(
			n->v_knots->knots[0],
			n->v_knots->knots[n->v_knots->k_size-1], 10);
d636 2
a637 2
		tau1 = (struct knot_vector *) rt_nurb_kvmerge(tkv1, n->u_knots);
		tau2 = (struct knot_vector *) rt_nurb_kvmerge(tkv2, n->v_knots);
d639 2
a640 2
		r = (struct snurb *) rt_nurb_s_refine( n, RT_NURB_SPLIT_COL, tau2);
		c = (struct snurb *) rt_nurb_s_refine( r, RT_NURB_SPLIT_ROW, tau1);
d642 1
a642 1
		coords = RT_NURB_EXTRACT_COORDS(n->mesh->pt_type);
d644 1
a644 1
		if( RT_NURB_IS_PT_RATIONAL(n->mesh->pt_type))
d646 1
a646 1
			vp = c->mesh->ctl_points;
d648 1
a648 1
				i < c->mesh->s_size[0] * c->mesh->s_size[1]; 
d660 2
a661 2
		vp = c->mesh->ctl_points;
		for( i = 0; i < c->mesh->s_size[0]; i++)
d665 1
a665 1
			for( j = 1; j < c->mesh->s_size[1]; j++)
d672 1
a672 1
		for( j = 0; j < c->mesh->s_size[1]; j++)
d676 2
a677 2
			stride = c->mesh->s_size[1] * coords;
			vp = &c->mesh->ctl_points[j * coords];
d679 1
a679 1
			for( i = 0; i < c->mesh->s_size[0]; i++)
a686 2
		rt_free( (char *) tau1->knots, "rt_nurb_plot:tau1->knots");
		rt_free( (char *) tau1, "rt_nurb_plot:tau1");
d688 4
a691 8
		rt_free( (char *) tau2->knots, "rt_nurb_plot:tau2->knots");
		rt_free( (char *) tau2, "rt_nurb_plot:tau2");

		rt_free( (char *) tkv1->knots, "rt_nurb_plot:tkv1>knots");
		rt_free( (char *) tkv1, "rt_nurb_plot:tkv1");

		rt_free( (char *) tkv2->knots, "rt_nurb_plot:tkv2->knots");
		rt_free( (char *) tkv2, "rt_nurb_plot:tkv2");
d753 1
a753 1
			pt_type = RT_NURB_MAKE_PT_TYPE(3,RT_NURB_RT_NURB_PT_XYZ,0);
d755 1
a755 1
			pt_type = RT_NURB_MAKE_PT_TYPE(4,RT_NURB_RT_NURB_PT_XYZ,1);
d766 1
a766 1
			sip->srfs[s]->u_knots->knots[i] = (fastf_t) *vp++;
d769 1
a769 1
			sip->srfs[s]->v_knots->knots[i] = (fastf_t) *vp++;
d771 2
a772 2
		rt_nurb_kvnorm( sip->srfs[s]->u_knots);
		rt_nurb_kvnorm( sip->srfs[s]->v_knots);
d775 1
a775 1
		m = sip->srfs[s]->mesh->ctl_points;
d894 6
a899 6
		                smin = (1.0 - smin) * psrf->u_knots->knots[0] +
                		        smin * psrf->u_knots->knots[
		                        psrf->u_knots->k_size -1];
		                smax = (1.0 - smax) * psrf->u_knots->knots[0] +
		                        smax * psrf->u_knots->knots[
                		        psrf->u_knots->k_size -1];
d902 6
a907 6
	                        smin = (1.0 - smin) * psrf->v_knots->knots[0] +
        	                        smin * psrf->v_knots->knots[
                	                psrf->v_knots->k_size -1];
                        	smax = (1.0 - smax) * psrf->v_knots->knots[0] +
                                	smax * psrf->v_knots->knots[
	                                psrf->v_knots->k_size -1];
d917 2
a918 2
			u[0] = psrf->u_knots->knots[0];
			u[1] = psrf->u_knots->knots[psrf->u_knots->k_size -1];
d920 2
a921 2
			v[0] = psrf->v_knots->knots[0];
			v[1] = psrf->v_knots->knots[psrf->v_knots->k_size -1];
d972 1
a972 1
	if( RT_NURB_IS_PT_RATIONAL(n->srf->mesh->pt_type) )
d1117 4
a1120 4
		rec[rec_ptr].d.d_kv_size[0] = sip->srfs[s]->u_knots->k_size;
		rec[rec_ptr].d.d_kv_size[1] = sip->srfs[s]->v_knots->k_size;
		rec[rec_ptr].d.d_ctl_size[0] = 	sip->srfs[s]->mesh->s_size[0];
		rec[rec_ptr].d.d_ctl_size[1] = 	sip->srfs[s]->mesh->s_size[1];
d1122 1
a1122 1
			RT_NURB_EXTRACT_COORDS(sip->srfs[s]->mesh->pt_type);
d1127 1
a1127 1
			*vp++ = sip->srfs[s]->u_knots->knots[n];
d1132 1
a1132 1
			*vp++ = sip->srfs[s]->v_knots->knots[n];
d1141 1
a1141 1
			*vp++ = sip->srfs[s]->mesh->ctl_points[n];
d1157 2
a1158 2
	total_knots = srf->u_knots->k_size +
		srf->v_knots->k_size;
d1161 3
a1163 3
	total_points = RT_NURB_EXTRACT_COORDS(srf->mesh->pt_type) *
		(srf->mesh->s_size[0] +
		srf->mesh->s_size[1]);
d1217 1
a1217 1
		mp = np->mesh->ctl_points;
d1221 1
a1221 1
			np->mesh->s_size[0], np->mesh->s_size[1]);
d1234 1
a1234 1
		for(i=0; i < np->mesh->s_size[0]; i++)
d1238 1
a1238 1
			for( j = 0; j < np->mesh->s_size[1]; j++)
d1245 1
a1245 1
				mp += RT_NURB_EXTRACT_COORDS(np->mesh->pt_type);
d1263 1
a1263 1
	ptr = srf->mesh->ctl_points;
d1265 1
a1265 1
	coords = RT_NURB_EXTRACT_COORDS(srf->mesh->pt_type);
d1267 2
a1268 2
	for( i = (srf->mesh->s_size[RT_NURB_SPLIT_ROW] * 
	    srf->mesh->s_size[RT_NURB_SPLIT_COL] ); i > 0; i--)
@


10.2
log
@wrong subscript in rt_nurb_curve routine
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 10.1 91/10/12 06:40:19 mike Rel4_0 Locker: stay $ (BRL)";
d432 5
a436 5
	us = (struct snurb *) rt_nurb_s_diff(srf, ROW);
	vs = (struct snurb *) rt_nurb_s_diff(srf, COL);
	uus = (struct snurb *) rt_nurb_s_diff(us, ROW);
	vvs = (struct snurb *) rt_nurb_s_diff(vs, COL);
	uvs = (struct snurb *) rt_nurb_s_diff(vs, ROW);
d451 1
a451 1
	if( EXTRACT_RAT( srf->mesh->pt_type ))
d639 2
a640 2
		r = (struct snurb *) rt_nurb_s_refine( n, COL, tau2);
		c = (struct snurb *) rt_nurb_s_refine( r, ROW, tau1);
d642 1
a642 1
		coords = EXTRACT_COORDS(n->mesh->pt_type);
d644 1
a644 1
		if( EXTRACT_RAT(n->mesh->pt_type))
d759 1
a759 1
			pt_type = MAKE_PT_TYPE(3,PT_XYZ,0);
d761 1
a761 1
			pt_type = MAKE_PT_TYPE(4,PT_XYZ,1);
d898 1
a898 1
			if ( dir == ROW)
d978 1
a978 1
	if( EXTRACT_RAT(n->srf->mesh->pt_type) )
d1128 1
a1128 1
			EXTRACT_COORDS(sip->srfs[s]->mesh->pt_type);
d1167 1
a1167 1
	total_points = EXTRACT_COORDS(srf->mesh->pt_type) *
d1242 1
a1242 1
			sprintf( buf,"\tROW %d:\n", i);
d1251 1
a1251 1
				mp += EXTRACT_COORDS(np->mesh->pt_type);
d1271 1
a1271 1
	coords = EXTRACT_COORDS(srf->mesh->pt_type);
d1273 2
a1274 2
	for( i = (srf->mesh->s_size[ROW] * 
	    srf->mesh->s_size[COL] ); i > 0; i--)
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 1.14 91/09/20 23:14:02 butler Exp $ (BRL)";
d419 1
a419 1
	if( srf->order[1] <= 2 && srf->order[1] <= 2)
@


1.14
log
@removing fuzz with lint
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 1.13 91/08/29 22:19:39 mike Exp $ (BRL)";
@


1.13
log
@Needed nmg.h
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 1.12 91/08/16 16:18:07 mike Exp $ (BRL)";
a109 1
		struct snurb * stmp;
a296 1
		struct seg * seg2p;
d371 2
a372 2
	register struct nurb_specific *nurb =
		(struct nurb_specific *)stp->st_specific;
d404 2
a405 2
	register struct nurb_specific *nurb =
		(struct nurb_specific *)stp->st_specific;
d568 2
a569 2
	register struct nurb_specific *nurb =
		(struct nurb_specific *)stp->st_specific;
d728 1
a728 3
	register int		i,j;
	LOCAL vect_t		base_vect;
	int 			currec;
d821 1
a821 2
			sub,
			origin;
a968 1
	fastf_t dist;
a1083 1
	point_t			base_pt;
@


1.12
log
@A tighter UV_TOL is necessary for doing the teapot.
Also, don't discard negative hit points, as shootray wants to
know about them (due to moving ray start point around).
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 1.11 91/07/08 22:16:35 mike Exp $ (BRL)";
d29 1
@


1.11
log
@Fixed minor typo, and some minor lint
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 1.10 91/07/06 00:21:26 stay Exp $ (BRL)";
d933 2
a934 1
                        if( (u[1] - u[0]) < 1.0e-4 && (v[1] - v[0]) < 1.0e-4)
d1014 2
d1021 1
@


1.10
log
@Added nurb export routine
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 1.9 91/06/30 00:10:53 mike Exp $ (BRL)";
d74 6
a79 3
struct nurb_hit * rt_conv_uv();
struct uv_hit * rt_nurb_intersect();
struct nurb_hit * rt_return_nurb_hit();
d81 1
d816 2
a817 1
plane_t plane1, plane2;
a1088 1
	int			rt_nurb_grans();
d1102 1
a1102 1

d1109 1
a1109 1
	ep->ext_nbytes = (1 + grans ) * sizeof(union record);
d1155 1
a1156 1
}
@


1.9
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 1.8 91/06/29 21:04:33 mike Exp $ (BRL)";
d1077 95
a1171 1
	return -1;		/* XXXXX */
@


1.8
log
@lint
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 1.7 91/06/22 22:30:27 mike Exp $ (BRL)";
d162 1
a162 1
register struct soltab *stp;
d719 2
a720 2
struct rt_external	*ep;
register mat_t		mat;
d1073 3
a1075 3
struct rt_external 	* ep;
struct rt_db_internal	* ip;
double			local2mm;
d1077 1
a1077 2


@


1.7
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 1.6 91/06/14 09:43:05 stay Exp $ (BRL)";
d1051 1
@


1.6
log
@fixed location of nurb.h which moved to the h directory
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 1.5 91/05/18 03:01:00 mike Exp $ (BRL)";
d87 1
a87 1
rt_nurb_prep( stp, ip, rtip, tol )
a90 1
CONST struct rt_tol	*tol;
d192 1
a192 1
rt_nurb_shot( stp, rp, ap, seghead, tol )
a196 1
CONST struct rt_tol	*tol;
d201 1
d347 1
a347 1
rt_nurb_vshot( stp, rp, segp, n, resp, tol )
d352 1
a352 2
struct resource         *resp; /* pointer to a list of free segs */
CONST struct rt_tol	*tol;
d354 1
a354 1
	rt_vstub( stp, rp, segp, n, resp, tol );
d703 1
a703 1
rt_nurb_tess( r, m, rp, dp, ttol, tol )
d706 1
a706 2
union record		*rp;
struct directory	*dp;
@


1.5
log
@Converted to new tolerance interface
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 1.4 91/05/17 20:06:06 stay Exp $ (BRL)";
d29 1
a29 1
#include "../libnurb/nurb.h"
@


1.4
log
@This version works
@
text
@d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/g_nurb.c,v 1.3 91/01/28 23:53:12 mike Exp $ (BRL)";
d87 1
a87 1
rt_nurb_prep( stp, ip, rtip )
d91 1
d193 1
a193 1
rt_nurb_shot( stp, rp, ap, seghead )
d198 1
d234 2
a235 3

	rt_mk_plane_3pts( plane1, p1, p3, p2, 0.005);
	rt_mk_plane_3pts( plane2, p1, p2, p4, 0.005);
d348 1
a348 1
rt_nurb_vshot( stp, rp, segp, n, resp)
d354 1
d356 1
a356 1
	rt_vstub( stp, rp, segp, n, resp );
d600 1
a600 1
rt_nurb_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
d603 2
a604 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
d705 1
a705 1
rt_nurb_tess( r, m, rp, dp, abs_tol, rel_tol, norm_tol )
d710 2
a711 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
@


1.3
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d5 1
a5 1
 *	Intersect a ray with a 
d8 1
d16 1
a16 1
 *	This software is Copyright (C) 1990 by the United States Army.
d20 1
a20 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 1.2 91/01/26 03:14:49 mike Exp $ (BRL)";
d29 1
a29 1
#include "nurb.h"
d32 4
a35 5
struct nurb_tree {
	point_t min, max;		/* Min and Max RPP of sub surface */
	struct snurb	 * root;	/* Null if Non leaf node */
	strcut nurb_tree * left,
			 * right;
d38 13
a50 3
struct nurb_internal {
	struct nurb_internal *  next;	/* next surface in the the solid */
	point_t		        min,	/* Bounding box of surface
d52 2
a53 3
	struct snurb *		root;	/* Null if non leaf node */
	struct nurb_tree 	* left, /* pointer to left sub tree */
				* right;/* Pointer to right sub tree */
d57 2
a63 2
	struct nurb_hit * next;
	struct nurb_hit * prev;
a65 1
#define NULL_TREE (struct nurb_tree *)0
d68 10
d81 3
a83 11
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid XXX, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	XXX is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct nurb_specific is created, and it's address is stored in
 *  	stp->st_specific for use by nurb_shot().
d85 1
d87 1
a87 1
rt_nurb_prep( stp, rec, rtip )
d89 1
a89 1
union record		*rec;
d92 3
a94 2
	register struct nurb_specific *nurb;
	struct nurb_specific * n;
d96 6
a101 3
	rt_nurb_import( nurb, rec, stp->st_pathmat );
	
	for( n = nurb; n != (struct nurb_internal *)0; n = n->next)
d103 34
a136 2
		VMINMAX( stp->st_min, stp->st_max, n->root->min);
		VMINMAX( stp->st_max, stp->st_max, n->root->min);
d138 4
a141 6
	
	stp->st_specific = (genptr) nurb;
	VSET(stp->st_center, 
		(stp->st_max[0] + stp->st_min[0])/2.0,
		(stp->st_max[1] + stp->st_min[1])/2.0,
		(stp->st_max[2] + stp->st_min[2])/2.0);
d144 1
a144 2
		
		dx = (stp->st_max[0] - stp->st_min[0])/2.;
d146 4
a149 5
		dy = (stp->st_max[1] - stp->st_min[1])/2.;
		if( dy > f) f = dy;
		dx = (stp->st_max[2] - stp->st_min[2])/2.;
		if( dz > f ) f = dz;

d151 1
a151 1
		stp->st_bradius = sqrt(dx*dx + dy*dy* dz*dz);
d153 1
d164 2
a165 2
	register struct nurb_internal *nurb =
		(struct nurb_internal *)stp->st_specific;
d167 1
a167 1
	if( nurb == (struct snurb *)0)
d173 1
a173 1
	for( ; nurb != (struct nurb_internal *)0; nurb = nurb->next)
d175 1
a175 1
		nurb_s_print("NURB", nurb->root);
d190 1
d198 1
a198 1
	register struct nurb_specific *nurb =
d201 7
d209 128
a336 1
	return(2);			/* HIT */
d371 17
a387 1
	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
d403 12
d416 2
a417 1
 	cvp->crv_c1 = cvp->crv_c2 = 0;
d419 115
a533 3
	/* any tangent direction */
 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
}
d535 15
d567 3
d598 6
a603 7
rt_nurb_plot( rp, vhead, dp, abs_tol, rel_tol, norm_tol )
union record	*rp;
struct rt_list	*vhead;
struct directory *dp;
double		abs_tol;
double		rel_tol;
double		norm_tol;
d605 93
a697 1
	return(-1);
d720 3
a722 3
rt_nurb_import( nurb, rp, mat )
struct nurb_internal	*nurb;
union record		*rp;
a724 2
	int surf_num;
	int currec;
d726 6
a731 2
	surf_num = rp[0].B.B_nsurf;
	currec = 1;
d733 3
a735 1
	while ( surf_num--)
d737 22
a758 3
		struct nurb_internal * n_tree;
		struct snurb		* srf;
		struct snurb		* srf_split;
d760 27
a786 1
		if( (srf = (struct snurb *) rt_nurb_readin( &rp[currec], mat)) == (struct snurb *)0)
d788 16
a803 1
			rt_log("rt_nurb_import srf: database read error\n");
d807 4
a810 2
		currec += 1 + rp[currec].d.d_nknots +
			rp[currec].d.d_nctls;
d812 33
a844 3
		GETSTRUCT( n_tree, nurb_internal);
		GETSTRUCT( nurb_internal->left, nurb_tree);
		GETSTRUCT( nurb_internal->right, nurb_tree);
d846 2
a847 2
		n_tree->next = nurb;
		nurb = n_tree;
d849 7
a855 4
		srf_split =(struct snurb *) nurb_s_split( srf, ROW);
		n_tree->left->root = srf_split;
		n_tree->right->root = srf_split->next;
		srf_split->next = (struct snurb *)0;
d857 5
a861 4
		n_tree->left->left = NULL_TREE;
		n_tree->left->right = NULL_TREE;
		n_tree->right->left = NULL_TREE;
		n_tree->right->right = NULL_TREE;
d863 93
a955 7
		n_tree->root = srf;
		
		nurb_s_bound(n_tree->root, n_tree->min, n_tree->max);
		nurb_s_bound(n_tree->left->root, n_tree->left->min,
			n_tree->left->max);
		nurb_s_bound(n_tree->right->root, n_tree->right->min,
			n_tree->right->max);
d958 1
a958 1
	return(0);			/* OK */
d961 5
a965 4
struct snurb *
rt_nurb_readin(drec, mat)
union record *drec;
matp_t mat;
d967 4
d972 7
a978 7
	register int i;
	register fastf_t * mesh_ptr;
	register dbfloat_t	*vp;
	struct snurb * srf;
	int coords;
	int rational;
	int pt_type;
d980 1
a980 1
	if( drec[0].u_id != ID_BSURF ) 
d982 8
a989 2
		rt_log("rt_nurb_readin: bad record 0 %o\n", drec[0].u_id);
		return (struct snurb * )0;
d992 10
a1001 1
	coords = drec[0].d.d_geom_type;
d1003 1
a1003 1
	if( coords == 4) rational = TRUE;
d1005 5
a1009 1
	pt_type = MAKE_PT_TYPE(coords, PT_XYZ, rational);
d1011 12
d1024 11
a1034 6
	/* Allocate memory for a new nurb surface */
	srf = nurb_new_snurb( 
		drec[0].d.d_order[0], drec[0].d.d_order[1],  
		drec[0].d.d_kv_size[0],drec[0].d.d_kv_size[1],
		drec[0].d.d_ctl_size[0],drec[0].d.d_ctl_size[1],
		pt_type);
d1036 5
a1040 5
	/* Read in the knot vectors */
	vp = ( dbfloat_t *) &drec[1];
	
	for( i = 0; i < drec[0].d.d_kv_size[0]; i++)
		srf->u_knots->knots[i] = (fastf_t) * vp++;
d1042 4
a1045 2
	for( i = 0; i < drec[0].d.d_kv_size[1]; i++)
		srf->v_knots->knots[i] = (fastf_t) * vp++;
d1047 2
a1048 2
	nurb_kvnorm( srf->u_knots);
	nurb_kvnorm( srf->v_knots);
d1050 13
a1062 3
	vp = (dbfloat_t *) &drec[drec[0].d.d_nknots+1];
	mesh_ptr = srf->mesh->ctl_points;
	i = ( drec[0].d.d_ctl_size[0] * drec[0].d.d_ctl_size[1]);
d1064 8
d1073 23
a1095 1
	if( coords > 4)
d1097 1
a1097 2
		rt_log("rt_nurb_readin: %d invalid # of coords\n",coords);
		return (struct snurb *)0;
d1099 5
d1105 20
a1124 1
	if( rational )
d1126 22
a1147 1
		for( i > 0 ; i--)
d1149 11
a1159 3
			MAT4X3PNT( mesh_ptr, mat, vp);
			mesh_ptr += coords;
			vp += coords;
d1161 21
a1181 1
	} else
d1183 7
a1189 6
		for( ; i> 0; i--)
		{
			MAT4X4PNT( mesh_ptr, mat, vp);
			mesh_ptr += coords;
			vp += coords;
		}
a1190 1
	return srf;
@


1.2
log
@Eliminated mat parameter on ft_plot and ft_tess
@
text
@d19 1
a19 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 1.1 91/01/25 21:18:54 mike Exp $ (BRL)";
d262 1
a262 1
struct vlhead	*vhead;
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSnurb[] = "@@(#)$Header: /m/cad/librt/RCS/g_nurb.c,v 1.2 90/10/11 02:37:41 mike Exp $ (BRL)";
d260 1
a260 1
rt_nurb_plot( rp, mat, vhead, dp, abs_tol, rel_tol, norm_tol )
a261 1
mat_t		mat;
d275 1
a275 1
rt_nurb_tess( r, m, rp, mat, dp, abs_tol, rel_tol, norm_tol )
a278 1
mat_t			mat;
@
