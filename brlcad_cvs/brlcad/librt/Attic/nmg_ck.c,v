head	11.29;
access;
symbols
	ansi-20040405-merged:11.25.2.2
	postmerge-20040405-ansi:11.27
	premerge-20040404-ansi:11.26
	postmerge-autoconf:11.26
	autoconf-freeze:11.25.10.2
	premerge-autoconf:11.26
	ansi-20040316-freeze:11.25.2.1
	postmerge-20040315-windows:11.26
	premerge-20040315-windows:11.26
	windows-20040315-freeze:11.25.4.1
	autoconf-20031203:11.25
	autoconf-20031202:11.25
	autoconf-branch:11.25.0.10
	phong-branch:11.25.0.8
	photonmap-branch:11.25.0.6
	rel-6-1-DP:11.25
	windows-branch:11.25.0.4
	rel-6-0-2:11.23
	ansi-branch:11.25.0.2
	rel-6-0-1-branch:11.23.0.2
	hartley-6-0-post:11.24
	hartley-6-0-pre:11.23
	rel-6-0-1:11.23
	rel-6-0:11.23
	rel-5-4:11.20
	offsite-5-3-pre:11.22
	rel-5-3:11.20
	rel-5-2:11.20
	rel-5-1-branch:11.20.0.2
	rel-5-1:11.20
	rel-5-0:11.16
	rel-5-0-beta:11.15
	rel-4-5:11.13
	ctj-4-5-post:11.13
	ctj-4-5-pre:11.12
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.29
date	2004.05.21.18.07.32;	author morrison;	state dead;
branches;
next	11.28;

11.28
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.27;

11.27
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2004.02.02.17.39.22;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2002.08.20.17.08.03;	author jra;	state Exp;
branches
	11.25.2.1
	11.25.4.1
	11.25.10.1;
next	11.24;

11.24
date	2002.08.15.20.55.14;	author hartley;	state Exp;
branches;
next	11.23;

11.23
date	2001.04.05.19.35.34;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2000.08.21.02.02.31;	author butler;	state Exp;
branches;
next	11.21;

11.21
date	2000.07.10.23.01.38;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.05.02.00.25.50;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.03.29.01.42.59;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.03.29.01.37.00;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	99.12.30.15.29.39;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	99.06.03.01.01.26;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	98.09.14.15.59.17;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	98.03.26.06.59.59;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.08.29.17.22.37;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	97.06.04.15.15.36;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	96.08.27.03.01.36;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.07.12.12.17.41;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	95.12.02.03.19.51;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.03.03.23.40.33;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.02.25.01.58.10;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.02.23.06.08.03;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.02.23.05.57.38;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.02.13.16.50.22;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.01.31.04.22.18;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.24;	author mike;	state Rel4_4;
branches;
next	10.55;

10.55
date	94.12.05.16.10.05;	author mike;	state Exp;
branches;
next	10.54;

10.54
date	94.11.28.13.27.39;	author jra;	state Exp;
branches;
next	10.53;

10.53
date	94.11.18.16.18.22;	author jra;	state Exp;
branches;
next	10.52;

10.52
date	94.11.17.16.58.47;	author jra;	state Exp;
branches;
next	10.51;

10.51
date	94.11.05.00.27.35;	author mike;	state Exp;
branches;
next	10.50;

10.50
date	94.10.12.03.35.28;	author butler;	state Exp;
branches;
next	10.49;

10.49
date	94.10.04.17.46.26;	author jra;	state Exp;
branches;
next	10.48;

10.48
date	94.09.23.20.06.10;	author mike;	state Exp;
branches;
next	10.47;

10.47
date	94.09.23.16.32.09;	author mike;	state Exp;
branches;
next	10.46;

10.46
date	94.09.21.03.50.03;	author mike;	state Exp;
branches;
next	10.45;

10.45
date	94.09.21.03.11.31;	author mike;	state Exp;
branches;
next	10.44;

10.44
date	94.09.12.22.29.52;	author mike;	state Exp;
branches;
next	10.43;

10.43
date	94.09.10.04.36.31;	author mike;	state Exp;
branches;
next	10.42;

10.42
date	94.09.03.03.01.18;	author mike;	state Exp;
branches;
next	10.41;

10.41
date	94.09.02.19.07.54;	author mike;	state Exp;
branches;
next	10.40;

10.40
date	94.09.02.17.58.32;	author mike;	state Exp;
branches;
next	10.39;

10.39
date	94.09.02.00.31.23;	author mike;	state Exp;
branches;
next	10.38;

10.38
date	94.08.10.18.47.50;	author gdurf;	state Exp;
branches;
next	10.37;

10.37
date	94.08.09.19.37.20;	author mike;	state Exp;
branches;
next	10.36;

10.36
date	94.05.06.02.23.54;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	94.04.25.00.36.52;	author butler;	state Exp;
branches;
next	10.34;

10.34
date	94.04.25.00.30.43;	author butler;	state Exp;
branches;
next	10.33;

10.33
date	94.03.02.12.55.12;	author jra;	state Exp;
branches;
next	10.32;

10.32
date	94.01.25.15.13.33;	author mike;	state Exp;
branches;
next	10.31;

10.31
date	94.01.25.09.43.28;	author mike;	state Exp;
branches;
next	10.30;

10.30
date	94.01.25.08.33.07;	author mike;	state Exp;
branches;
next	10.29;

10.29
date	94.01.23.05.29.53;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	94.01.13.23.05.59;	author mike;	state Exp;
branches;
next	10.27;

10.27
date	93.12.27.22.44.54;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	93.12.24.00.43.57;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	93.12.22.06.07.40;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	93.12.03.03.34.33;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	93.11.12.23.40.22;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	93.10.29.04.16.16;	author mike;	state Exp;
branches;
next	10.21;

10.21
date	93.10.01.20.22.44;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	93.09.30.20.55.24;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	93.09.24.15.45.39;	author jra;	state Exp;
branches;
next	10.18;

10.18
date	93.09.24.15.17.55;	author jra;	state Exp;
branches;
next	10.17;

10.17
date	93.09.24.12.06.03;	author jra;	state Exp;
branches;
next	10.16;

10.16
date	93.08.19.00.10.20;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	93.08.13.15.23.16;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	93.08.12.22.51.15;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	93.07.24.02.17.00;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	93.07.24.00.59.19;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	93.07.23.17.03.20;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	93.07.20.21.17.30;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	93.05.14.04.24.07;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	93.03.26.23.00.47;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	93.03.23.22.16.33;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.03.19.01.00.29;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	93.03.09.01.31.33;	author butler;	state Exp;
branches;
next	10.4;

10.4
date	93.03.08.20.50.24;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.02.24.00.59.27;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.07.22.04.26.02;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.40;	author mike;	state Rel4_0;
branches;
next	1.4;

1.4
date	91.06.17.20.41.52;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	91.02.07.20.32.31;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.05.31.00.09.48;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	90.05.24.20.50.50;	author mike;	state Exp;
branches;
next	;

11.25.2.1
date	2002.09.19.18.01.38;	author morrison;	state Exp;
branches;
next	11.25.2.2;

11.25.2.2
date	2004.03.17.21.18.51;	author morrison;	state Exp;
branches;
next	;

11.25.4.1
date	2004.03.11.23.43.40;	author morrison;	state Exp;
branches;
next	;

11.25.10.1
date	2004.02.12.18.37.43;	author erikg;	state Exp;
branches;
next	11.25.10.2;

11.25.10.2
date	2004.03.15.14.07.23;	author erikg;	state Exp;
branches;
next	;


desc
@Validators and consistency checkers for NMG data structures
@


11.29
log
@moved to src/
@
text
@/*
 *			N M G _ C K . C
 *
 *  Validators and consistency checkers for NMG data structures
 *
 *  Authors -
 *	Lee A. Butler
 *	Michael John Muuss
 *	John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_ck.c,v 11.28 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"


/************************************************************************
 *									*
 *			Validator Routines				*
 *									*
 ************************************************************************/

/*
 *			N M G _ V V G
 *
 *  Verify vertex geometry
 */
void
nmg_vvg(const struct vertex_g *vg)
{
	NMG_CK_VERTEX_G(vg);
}

/*
 *			N M G _ V V E R T E X
 *
 *  Verify a vertex
 */
void
nmg_vvertex(const struct vertex *v, const struct vertexuse *vup)
{
	struct vertexuse *vu;
	int vup_is_in_list = 0;

	NMG_CK_VERTEX(v);

	for( BU_LIST_FOR( vu, vertexuse, &v->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);
		if (vu->v_p != v)
			rt_bomb("nmg_vvertex() a vertexuse in my list doesn't share my vertex\n");
		if (vu == vup)
			vup_is_in_list = 1;
	}
	if (v->vg_p) nmg_vvg(v->vg_p);
	if ( ! vup_is_in_list )
		rt_bomb("nmg_vvertex() vup not found in list of vertexuses\n");
}

/* Verify vertex attributes */
void
nmg_vvua(const long int *vua)
{
	NMG_CK_VERTEXUSE_A_EITHER(vua);
}

/*
 *			N M G _ V V U
 *
 *  Verify vertexuse
 */
void
nmg_vvu(const struct vertexuse *vu, const long int *up_magic_p)
{
	long	magic;

	NMG_CK_VERTEXUSE(vu);
	if (vu->up.magic_p != up_magic_p)  {
		bu_log("nmg_vvu() up is %s, s/b %s\n",
			bu_identify_magic( *vu->up.magic_p ),
			bu_identify_magic( *up_magic_p ) );
		rt_bomb("nmg_vvu() vertexuse denies parent\n");
	}

	if (!vu->l.forw)
		rt_bomb("nmg_vvu() vertexuse has null forw pointer\n");

	magic = BU_LIST_FIRST_MAGIC( &vu->l );
	if( magic != NMG_VERTEXUSE_MAGIC && magic != BU_LIST_HEAD_MAGIC )
		rt_bomb("nmg_vvu() vertexuse forw is bad vertexuse\n");

	if (BU_LIST_PNEXT_PLAST(vertexuse,vu) != vu )
		rt_bomb("nmg_vvu() vertexuse not back of next vertexuse\n");

	nmg_vvertex(vu->v_p, vu);

	if (vu->a.magic_p) nmg_vvua(vu->a.magic_p);
}

/* Verify edge geometry */
void
nmg_veg(const long int *eg)
{
	struct bu_list	*eu2;

	NMG_CK_EDGE_G_EITHER(eg);
	switch( *eg )  {
	case NMG_EDGE_G_LSEG_MAGIC:
		bu_ck_list_magic( &((struct edge_g_lseg *)eg)->eu_hd2,
			"nmg_veg() edge_g_lseg eu_hd2 list",
			NMG_EDGEUSE2_MAGIC );
		break;
	case NMG_EDGE_G_CNURB_MAGIC:
		bu_ck_list_magic( &((struct edge_g_cnurb *)eg)->eu_hd2,
			"nmg_veg() edge_g_cnurb eu_hd2 list",
			NMG_EDGEUSE2_MAGIC );
		break;
	}

	/* Ensure that all edgeuses on the edge_g_* list point to me */
	for( BU_LIST_FOR( eu2, bu_list, &((struct edge_g_lseg *)eg)->eu_hd2 ) )  {
		struct edgeuse	*eu;

		if( eu2 == NULL)
		{
			 rt_bomb("nmg_veg null eu2\n");
		}
		eu = BU_LIST_MAIN_PTR( edgeuse, eu2, l2 );
		NMG_CK_EDGEUSE(eu);
		if( eu->g.magic_p == eg )  continue;
		bu_log("eg=x%x, eu=x%x, eu->g=x%x\n", eg, eu, eu->g.magic_p);
		bu_log("nmg_veg() edgeuse is on wrong eu_hd2 list for eu->g\n");
	}
}

/*
 *			N M G _ V E D G E
 *
 *  Verify edge
 */
void
nmg_vedge(const struct edge *e, const struct edgeuse *eup)
{
	const struct edgeuse *eu;
	int is_use = 0;		/* flag: eup is in edge's use list */

	NMG_CK_EDGE(e);
	NMG_CK_EDGEUSE(eup);
	NMG_CK_VERTEXUSE(eup->vu_p);
	NMG_CK_VERTEX(eup->vu_p->v_p);
	NMG_CK_EDGEUSE(eup->eumate_p);
	NMG_CK_VERTEXUSE(eup->eumate_p->vu_p);
	NMG_CK_VERTEX(eup->eumate_p->vu_p->v_p);

	if (!e->eu_p) rt_bomb("nmg_vedge() edge has null edgeuse pointer\n");

	NMG_CK_EDGEUSE( e->eu_p );

	eu = eup;
	do {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGEUSE(eu->eumate_p);
		if (eu == eup || eu->eumate_p == eup)
			is_use = 1;

		NMG_CK_VERTEXUSE(eu->vu_p);
		NMG_CK_VERTEX(eu->vu_p->v_p);
		if (eu->vu_p->v_p == eup->vu_p->v_p) {
			if (eu->eumate_p->vu_p->v_p != eup->eumate_p->vu_p->v_p)
			{
				bu_log("nmg_vedge() edgeuse mate does not have correct vertex\n");
				bu_log( "(eu=x%x, eu->vu_p->v_p=x%x, eu->eumate_p->vu_p->v_p=x%x)\n",
					eu, eu->vu_p->v_p, eu->eumate_p->vu_p->v_p);
				bu_log( "(eup=x%x, eup->vu_p->v_p=x%x, eup->eumate_p->vu_p->v_p=x%x)\n",
					eup, eup->vu_p->v_p, eup->eumate_p->vu_p->v_p);
				rt_bomb("nmg_vedge() edgeuse mate does not have correct vertex\n");
			}
		} else if (eu->vu_p->v_p == eup->eumate_p->vu_p->v_p) {
			if (eu->eumate_p->vu_p->v_p != eup->vu_p->v_p)
			{
				bu_log("nmg_vedge() edgeuse does not have correct vertex\n" );
				bu_log( "(eu=x%x, eu->vu_p->v_p=x%x, eu->eumate_p->vu_p->v_p=x%x)\n",
					eu, eu->vu_p->v_p, eu->eumate_p->vu_p->v_p);
				bu_log( "(eup=x%x, eup->vu_p->v_p=x%x, eup->eumate_p->vu_p->v_p=x%x)\n",
					eup, eup->vu_p->v_p, eup->eumate_p->vu_p->v_p);
				rt_bomb("nmg_vedge() edgeuse does not have correct vertex\n");
			}
		} else
		{
			bu_log("nmg_vedge() edgeuse does not share vertex endpoint\n" );
			bu_log( "(eu=x%x, eu->vu_p->v_p=x%x, eu->eumate_p->vu_p->v_p=x%x)\n",
				eu, eu->vu_p->v_p, eu->eumate_p->vu_p->v_p);
			bu_log( "(eup=x%x, eup->vu_p->v_p=x%x, eup->eumate_p->vu_p->v_p=x%x)\n",
				eup, eup->vu_p->v_p, eup->eumate_p->vu_p->v_p);
			rt_bomb("nmg_vedge() edgeuse does not share vertex endpoint\n");
		}

		eu = eu->eumate_p->radial_p;
	} while (eu != eup);

	if (!is_use)
		rt_bomb("nmg_vedge() Cannot get from edge to parent edgeuse\n");
}

/*
 *			N M G _ V E U
 *
 *  Verify edgeuse list.
 */
void
nmg_veu(const struct bu_list *hp, const long int *up_magic_p)
{
	struct edgeuse	*eu;
	struct edgeuse	*eunext;
	struct edgeuse	*eulast;
	long		up_magic;

	bu_ck_list_magic( hp, "nmg_veu() edegeuse list head", NMG_EDGEUSE_MAGIC );

	up_magic = *up_magic_p;
	switch( up_magic )  {
	case NMG_SHELL_MAGIC:
	case NMG_LOOPUSE_MAGIC:
		break;
	default:
		rt_bomb("nmg_veu() bad up_magic_p\n");
	}
	for( BU_LIST_FOR( eu, edgeuse, hp ) )  {
		NMG_CK_EDGEUSE(eu);

		if (eu->up.magic_p != up_magic_p)
			rt_bomb("nmg_veu() edgeuse denies parentage\n");

		if (!eu->l.forw)
			rt_bomb("nmg_veu() edgeuse has Null \"forw\" pointer\n");
		eunext = BU_LIST_PNEXT_CIRC( edgeuse, eu );
		eulast = BU_LIST_PPREV_CIRC(edgeuse, &eu->l);
		if (eunext->l.magic != NMG_EDGEUSE_MAGIC)
			rt_bomb("nmg_veu() edgeuse forw is bad edgeuse\n");
		if (eulast->l.magic != NMG_EDGEUSE_MAGIC)
			rt_bomb("nmg_veu() edgeuse back is bad edgeuse\n");
		NMG_CK_EDGEUSE(eunext);
		NMG_CK_EDGEUSE(eulast);

		/* Check that forw->back is us */
		if (BU_LIST_PPREV_CIRC(edgeuse,eunext) != eu )  {
		    if (eunext->l.back)
			rt_bomb("nmg_veu() next edgeuse has back that points elsewhere\n");
		    rt_bomb("nmg_veu() next edgeuse has NULL back\n");
		}

		/*
		 *  For edgeuses in loops, ensure that vertices are shared.
		 *  This does not apply to wire edgeuses in the shell.
		 */
		if ( up_magic == NMG_LOOPUSE_MAGIC &&
		     eu->vu_p->v_p != eulast->eumate_p->vu_p->v_p) {
		     	bu_log("eu=x%x, e=x%x\n", eu, eu->e_p );
		     	bu_log("eulast=x%x, e=x%x\n", eulast, eulast->e_p);
		     	bu_log("	    eu: (%g, %g, %g) <--> (%g, %g, %g)\n",
		     		V3ARGS(eu->vu_p->v_p->vg_p->coord),
		     		V3ARGS(eu->eumate_p->vu_p->v_p->vg_p->coord) );
		     	bu_log("	eulast: (%g, %g, %g) <--> (%g, %g, %g)\n",
		     		V3ARGS(eulast->vu_p->v_p->vg_p->coord),
		     		V3ARGS(eulast->eumate_p->vu_p->v_p->vg_p->coord) );
			bu_log("unshared vertex (mine) v=x%x: (%g, %g, %g)\n",
				eu->vu_p->v_p,
				V3ARGS(eu->vu_p->v_p->vg_p->coord) );
			bu_log("\t\t (last->eumate_p) v=x%x: (%g, %g, %g)\n",
				eulast->eumate_p->vu_p->v_p,
				V3ARGS(eulast->eumate_p->vu_p->v_p->vg_p->coord) );
		     	nmg_pr_lu_briefly(eu->up.lu_p, (char *)NULL);
		     	nmg_pr_lu_briefly(eu->up.lu_p->lumate_p, (char *)NULL);
			rt_bomb("nmg_veu() discontinuous edgeloop mine/last\n");
		}
		if ( up_magic == NMG_LOOPUSE_MAGIC &&
		     eunext->vu_p->v_p != eu->eumate_p->vu_p->v_p) {
		     	bu_log("eu=x%x, e=x%x\n", eu, eu->e_p );
		     	bu_log("eunext=x%x, e=x%x\n", eunext, eunext->e_p);
		     	bu_log("	    eu: (%g, %g, %g) <--> (%g, %g, %g)\n",
		     		V3ARGS(eu->vu_p->v_p->vg_p->coord),
		     		V3ARGS(eu->eumate_p->vu_p->v_p->vg_p->coord) );
		     	bu_log("	eunext: (%g, %g, %g) <--> (%g, %g, %g)\n",
		     		V3ARGS(eunext->vu_p->v_p->vg_p->coord),
		     		V3ARGS(eunext->eumate_p->vu_p->v_p->vg_p->coord) );
			bu_log("unshared vertex (mate) v=x%x: (%g, %g, %g)\n",
				eu->eumate_p->vu_p->v_p,
				V3ARGS(eu->eumate_p->vu_p->v_p->vg_p->coord) );
			bu_log("\t\t (next) v=x%x: (%g, %g, %g)\n",
				eunext->vu_p->v_p,
				V3ARGS(eunext->vu_p->v_p->vg_p->coord) );
		     	nmg_pr_lu_briefly(eu->up.lu_p, (char *)NULL);
		     	nmg_pr_lu_briefly(eu->up.lu_p->lumate_p, (char *)NULL);
			rt_bomb("nmg_veu() discontinuous edgeloop next/mate\n");
		}

		/* Check mate and radial */
		if (eu->eumate_p->l.magic != NMG_EDGEUSE_MAGIC)
			rt_bomb("nmg_veu() edgeuse mate is bad edgeuse\n");
		if (eu->eumate_p->eumate_p != eu)
			rt_bomb("nmg_veu() edgeuse mate spurns edgeuse\n");

		if (eu->radial_p->l.magic != NMG_EDGEUSE_MAGIC)
			rt_bomb("nmg_veu() edgeuse radial is bad edgeuse\n");
		if (eu->radial_p->radial_p != eu)
			rt_bomb("nmg_veu() edgeuse radial denies knowing edgeuse\n");

		nmg_vedge(eu->e_p, eu);

		if( eu->vu_p->v_p != eu->eumate_p->vu_p->v_p )
		{
			if( !eu->l2.forw )
				rt_bomb("nmg_veu() l2.forw is NULL\n");
			if( !eu->l2.back )
				rt_bomb("nmg_veu() l2.back is NULL\n");

			if( eu->g.magic_p != eu->eumate_p->g.magic_p )
				rt_bomb("nmg_veu() edgeuse and mate don't share geometry\n");
			if(eu->g.magic_p) nmg_veg(eu->g.magic_p);
		}
		
		switch (eu->orientation) {
		case OT_NONE	: break;
		case OT_SAME	: break;
		case OT_OPPOSITE: break;
		case OT_UNSPEC	: break;
		default		: rt_bomb("nmg_veu() unknown loopuse orintation\n");
					break;
		}

		nmg_vvu(eu->vu_p, &eu->l.magic);
	}
}

/*
 *			N M G _ V L G
 *
 *  Verify loop geometry
 */
void
nmg_vlg(const struct loop_g *lg)
{
	int i;
	
	NMG_CK_LOOP_G(lg);

	for (i=0 ; i < ELEMENTS_PER_PT ; ++i)
		if (lg->min_pt[i] > lg->max_pt[i])
			rt_bomb("nmg_vlg() loop geom min_pt greater than max_pt\n");
}

/*
 *			N M G _ V L O O P
 *
 *  Verify loop
 */
void
nmg_vloop(const struct loop *l, const struct loopuse *lup)
{

	NMG_CK_LOOP(l);
	NMG_CK_LOOPUSE(lup);

	if (!l->lu_p) rt_bomb("nmg_vloop() null loopuse pointer\n");

#if 0
	{
	struct loopuse *lu;
	for (lu=lup ; lu && lu != l->lu_p && lu->next != lup ; lu = lu->next);
	
	if (l->lu_p != lu)
		for (lu=lup->lumate_p ; lu && lu != l->lu_p && lu->next != lup->lumate_p ; lu = lu->next);

	if (l->lu_p != lu) rt_bomb("nmg_vloop() can't get to parent loopuse from loop\n");
	}
#endif

	if (l->lg_p) nmg_vlg(l->lg_p);
}

/*
 *			N M G _ V L U
 *
 *  Verify loopuse
 */
void
nmg_vlu(const struct bu_list *hp, const long int *up)
{
	struct loopuse *lu;

	for( BU_LIST_FOR( lu, loopuse, hp ) )  {
		NMG_CK_LOOPUSE(lu);

		if (lu->up.magic_p != up)  {
			bu_log("nmg_vlu() up is x%x, s/b x%x\n",
				lu->up.magic_p, up );
			rt_bomb("nmg_vlu() loopuse denies parentage\n");
		}

		if (!lu->l.forw)
			rt_bomb("nmg_vlu() loopuse has null forw pointer\n");
		if (BU_LIST_PNEXT_PLAST(loopuse,lu) != lu )
			rt_bomb("nmg_vlu() forw loopuse has back pointing somewhere else\n");

		if (!lu->lumate_p)
			rt_bomb("nmg_vlu() loopuse has null mate pointer\n");

		if (lu->lumate_p->l.magic != NMG_LOOPUSE_MAGIC)
			rt_bomb("nmg_vlu() loopuse mate is bad loopuse\n");

		if (lu->lumate_p->lumate_p != lu)
			rt_bomb("nmg_vlu() lumate spurns loopuse\n");

		switch (lu->orientation) {
		case OT_NONE	: break;
		case OT_SAME	: break;
		case OT_OPPOSITE	: break;
		case OT_UNSPEC	: break;
		case OT_BOOLPLACE:	break;
		default:
			bu_log("lu=x%x, orientation=%d\n", lu, lu->orientation);
			rt_bomb("nmg_vlu() unknown loopuse orintation\n");
			break;
		}
		if (lu->lumate_p->orientation != lu->orientation)
			rt_bomb("nmg_vlu() loopuse and mate have different orientation\n");

		if (!lu->l_p)
			rt_bomb("nmg_vlu() loopuse has Null loop pointer\n");
		nmg_vloop(lu->l_p, lu);

		if( BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC)
			nmg_veu( &lu->down_hd, &lu->l.magic);
		else if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)
			nmg_vvu(BU_LIST_FIRST(vertexuse,&lu->down_hd), &lu->l.magic);
		else
			rt_bomb("nmg_vlu() bad down_hd magic\n");
	}
}

/*
 *			N M G _ V F G
 *
 *  Verify face geometry
 */
void
nmg_vfg(const struct face_g_plane *fg)
{
	NMG_CK_FACE_G_EITHER(fg);

	if( fg->magic == NMG_FACE_G_PLANE_MAGIC )
	{
		if (fg->N[X]==0.0 && fg->N[Y]==0.0 && fg->N[Z]==0.0 &&
		    fg->N[H]!=0.0) {
			bu_log("bad NMG plane equation %fX + %fY + %fZ = %f\n",
				fg->N[X], fg->N[Y], fg->N[Z], fg->N[H]);
			rt_bomb("nmg_vfg() Bad NMG geometry\n");
		    }
	}
	if( fg->magic == NMG_FACE_G_SNURB_MAGIC )
	{
		/* XXX Should the face's NURB be checked somehow?? */
	}
}

/*
 *			N M G _ V F A C E
 *
 *  Verify face
 */
void
nmg_vface(const struct face *f, const struct faceuse *fup)
{
	int		i;

	NMG_CK_FACE(f);
	NMG_CK_FACEUSE(fup);

	/* make sure we can get back to the parent faceuse from the face */
	if (!f->fu_p) rt_bomb("nmg_vface() null faceuse pointer\n");

#if 0
	for (fu = fup; fu && fu != f->fu_p && fu->forw != fup; fu = fu->forw);

	if (f->fu_p != fu) rt_bomb("nmg_vface() can't get to parent faceuse from face\n");
#endif

	for (i=0 ; i < ELEMENTS_PER_PT ; ++i)
		if (f->min_pt[i] >= f->max_pt[i]) {
			bu_log("nmg_vface() face min_pt[%d]:%g greater than max_pt[%d]:%g\n",
				i, f->min_pt[i], i, f->max_pt[i]);
			bu_log("min_pt(%g %g %g)  ", V3ARGS(f->min_pt));
			bu_log("max_pt(%g %g %g)\n", V3ARGS(f->max_pt));
			rt_bomb("Invalid NMG\n");
		}
	if (f->g.plane_p) nmg_vfg(f->g.plane_p);
}

/*
 *			N M G _ V F U
 *
 *	Validate a list of faceuses
 */
void
nmg_vfu(const struct bu_list *hp, const struct shell *s)
{
	struct faceuse *fu;

	NMG_CK_SHELL(s);

	for( BU_LIST_FOR( fu, faceuse, hp ) )  {
		NMG_CK_FACEUSE(fu);
		if (fu->s_p != s) {
			bu_log("faceuse claims shell parent (%8x) instead of (%8x)\n",
				fu->s_p, s);
			rt_bomb("nmg_vfu()\n");
		}

		if (!fu->l.forw) {
			rt_bomb("nmg_vfu() faceuse forw is NULL\n");
		} else if (fu->l.forw->back != (struct bu_list *)fu) {
			rt_bomb("nmg_vfu() faceuse->forw->back != faceuse\n");
		}

		if (!fu->fumate_p)
			rt_bomb("nmg_vfu() null faceuse fumate_p pointer\n");

		if (fu->fumate_p->l.magic != NMG_FACEUSE_MAGIC)
			rt_bomb("nmg_vfu() faceuse mate is bad faceuse ptr\n");

		if (fu->fumate_p->fumate_p != fu)
			rt_bomb("nmg_vfu() faceuse mate spurns faceuse!\n");

		switch (fu->orientation) {
		case OT_NONE	: break;
		case OT_SAME	: if (fu->fumate_p->orientation != OT_OPPOSITE)
					rt_bomb("nmg_vfu() faceuse of \"SAME\" orientation has mate that is not \"OPPOSITE\" orientation\n");
				break;
		case OT_OPPOSITE:  if (fu->fumate_p->orientation != OT_SAME)
					rt_bomb("nmg_vfu() faceuse of \"OPPOSITE\" orientation has mate that is not \"SAME\" orientation\n");
				break;
		case OT_UNSPEC	: break;
		default		: rt_bomb("nmg_vfu() unknown faceuse orintation\n"); break;
		}

		NMG_CK_FACE(fu->f_p);
		nmg_vface(fu->f_p, fu);
		
		nmg_vlu( &fu->lu_hd, &fu->l.magic);
	}
}


/*
 *			N M G _ V S H E L L
 *
 *	validate a list of shells and all elements under them
 */
void
nmg_vshell(const struct bu_list *hp, const struct nmgregion *r)
{
	struct shell *s;
	pointp_t lpt, hpt;

	NMG_CK_REGION(r);

	for( BU_LIST_FOR( s, shell, hp ) )  {
		NMG_CK_SHELL(s);
		if (s->r_p != r) {
			bu_log("shell's r_p (%8x) doesn't point to parent (%8x)\n",
				s->r_p, r);
			rt_bomb("nmg_vshell()\n");
		}

		if (!s->l.forw) {
			rt_bomb("nmg_vshell(): Shell's forw ptr is null\n");
		} else if (s->l.forw->back != (struct bu_list *)s) {
			bu_log("forw shell's back(%8x) is not me (%8x)\n",
				s->l.forw->back, s);
			rt_bomb("nmg_vshell()\n");
		}

		if (s->sa_p) {
			NMG_CK_SHELL_A(s->sa_p);
			/* we make sure that all values of min_pt
			 * are less than or equal to the values of max_pt
			 */
			lpt = s->sa_p->min_pt;
			hpt = s->sa_p->max_pt;
			if (lpt[0] > hpt[0] || lpt[1] > hpt[1] ||
			    lpt[2] > hpt[2]) {
				bu_log("Bnmg_vshell() ad min_pt/max_pt for shell(%8x)'s extent\n");
				bu_log("Min_pt %g %g %g\n", lpt[0], lpt[1],
					lpt[2]);
				bu_log("Max_pt %g %g %g\n", hpt[0], hpt[1],
					hpt[2]);
			}
		}

		/* now we check out the "children"
		 */

		if (s->vu_p) {
			if( BU_LIST_NON_EMPTY( &s->fu_hd ) ||
			    BU_LIST_NON_EMPTY( &s->lu_hd ) ||
			    BU_LIST_NON_EMPTY( &s->eu_hd ) )  {
				bu_log("shell (%8x) with vertexuse (%8x) has other children\n",
					s, s->vu_p);
				rt_bomb("nmg_vshell()\n");
			}
		}

		nmg_vfu( &s->fu_hd, s);
		nmg_vlu( &s->lu_hd, &s->l.magic);
		nmg_veu( &s->eu_hd, &s->l.magic);
	}
}



/*
 *			N M G _ V R E G I O N
 *
 *	validate a list of nmgregions and all elements under them
 */
void
nmg_vregion(const struct bu_list *hp, const struct model *m)
{
	struct nmgregion *r;

	for( BU_LIST_FOR( r, nmgregion, hp ) )  {
		NMG_CK_REGION(r);
		if (r->m_p != m) {
			bu_log("nmgregion pointer m_p %8x should be %8x\n",
				r->m_p, m);
			rt_bomb("nmg_vregion()\n");
		}
		if (r->ra_p) {
			NMG_CK_REGION_A(r->ra_p);
		}

		nmg_vshell( &r->s_hd, r);

		if( BU_LIST_PNEXT_PLAST(nmgregion, r) != r )  {
			rt_bomb("nmg_vregion() forw nmgregion's back is not me\n");
		}
	}
}

/*
 *			N M G _ V M O D E L
 *
 *	validate an NMG model and all elements in it.
 */
void
nmg_vmodel(const struct model *m)
{
	NMG_CK_MODEL(m);
	nmg_vregion( &m->r_hd, m);
}


/************************************************************************
 *									*
 *			Checking Routines				*
 *									*
 ************************************************************************/

/*
 *			N M G _ C K _ E
 */
void
nmg_ck_e(const struct edgeuse *eu, const struct edge *e, const char *str)
{
	char *errstr;
	struct edgeuse *eparent;
	errstr = bu_calloc(strlen(str)+128, 1, "nmg_ck_e error str");
	(void)sprintf(errstr, "%sedge %8lx\n", str, (unsigned long)e);
	
	NMG_CK_EDGE(e);
	NMG_CK_EDGEUSE(eu);

	eparent = e->eu_p;

	NMG_CK_EDGEUSE(eparent);
	NMG_CK_EDGEUSE(eparent->eumate_p);
	do {
		if (eparent == eu || eparent->eumate_p == eu) break;

		eparent = eparent->radial_p->eumate_p;
	} while (eparent != e->eu_p);

	if (eparent != eu && eparent->eumate_p != eu) rt_bomb(
		strcat(errstr, "nmg_ck_e() Edge denies edgeuse parentage\n"));

	bu_free(errstr, "nmg_ck_e error str");
}

/*
 *			N M G _ C K _ V U
 */
void
nmg_ck_vu(const long int *parent, const struct vertexuse *vu, const char *str)
{
	char *errstr;

	errstr = bu_calloc(strlen(str)+128, 1, "nmg_ck_vu error str");
	(void)sprintf(errstr, "%svertexuse %8lx\n", str, (unsigned long)vu);
	
	if (vu->up.magic_p != parent) rt_bomb(
		strcat(errstr, "nmg_ck_vu() Vertexuse denies parentage\n"));

	bu_free(errstr, "nmg_ck_vu error str");
}

/*
 *			N M G _ C K _ E U
 */
void
nmg_ck_eu(const long int *parent, const struct edgeuse *eu, const char *str)
{
	char *errstr;
	struct edgeuse *eur, *eu_next, *eu_last;	

	errstr = bu_calloc(strlen(str)+128, 1, "nmg_ck_eu error str");
	(void)sprintf(errstr, "%sedgeuse %8lx\n", str, (unsigned long)eu);

	NMG_CK_EDGEUSE(eu);

	if (eu->up.magic_p != parent) rt_bomb(
		strcat(errstr, "nmg_ck_eu() Edgeuse child denies parentage\n"));

	if (*eu->eumate_p->up.magic_p != *eu->up.magic_p) rt_bomb(
		strcat(errstr, "nmg_ck_eu() eumate has differnt kind of parent\n"));
	if (*eu->up.magic_p == NMG_SHELL_MAGIC) {
		if (eu->eumate_p->up.s_p != eu->up.s_p) rt_bomb(
			strcat(errstr, "nmg_ck_eu() eumate in different shell\n"));

		eur = eu->radial_p;
		while (eur && eur != eu && eur != eu->eumate_p)
			eur = eur->eumate_p->radial_p;

		if (!eur) rt_bomb(strcat(errstr,
			"nmg_ck_eu() Radial trip from eu ended in null pointer\n"));


	} else if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC) {
		if (eu->eumate_p->up.lu_p != eu->up.lu_p->lumate_p) rt_bomb(
			strcat(errstr, "nmg_ck_eu() eumate not in same loop\n"));

		eur = eu->radial_p;
		while (eur && eur != eu->eumate_p && eur != eu)
			eur = eur->eumate_p->radial_p;

		if (!eur) rt_bomb(
			strcat(errstr, "nmg_ck_eu() radial path leads to null ptr\n"));
		if (eur == eu) rt_bomb(
			strcat(errstr, "nmg_ck_eu() Never saw eumate\n"));

		eu_next = BU_LIST_PNEXT_CIRC(edgeuse, eu);
		if (eu_next->vu_p->v_p != eu->eumate_p->vu_p->v_p)
			rt_bomb("nmg_ck_eu: next and mate don't share vertex\n");

		eu_last = BU_LIST_PPREV_CIRC(edgeuse, eu);
		if (eu_last->eumate_p->vu_p->v_p != eu->vu_p->v_p)
			rt_bomb("nmg_ck_eu: edge and last-mate don't share vertex\n");

	} else {
		rt_bomb(strcat(errstr, "nmg_ck_eu() Bad edgeuse parent\n"));
	}

	NMG_CK_EDGE(eu->e_p);
	nmg_ck_e(eu, eu->e_p, errstr);

	NMG_CK_VERTEXUSE(eu->vu_p);
	nmg_ck_vu(&eu->l.magic, eu->vu_p, errstr);

	bu_free(errstr, "nmg_ck_eu error str");
}

/*
 *			N M G _ C K _ L G
 */
void
nmg_ck_lg(const struct loop *l, const struct loop_g *lg, const char *str)
{
	char *errstr;
	errstr = bu_calloc(strlen(str)+128, 1, "nmg_ck_lg error str");
	(void)sprintf(errstr, "%sloop_g %8lx\n", str, (unsigned long)lg);

	NMG_CK_LOOP_G(lg);
	NMG_CK_LOOP(l);

	bu_free(errstr, "nmg_ck_lg error str");
}

/*
 *			N M G _ C K _ L
 */
void
nmg_ck_l(const struct loopuse *lu, const struct loop *l, const char *str)
{
	char *errstr;
	errstr = bu_calloc(strlen(str)+128, 1, "nmg_ck_l error str");
	(void)sprintf(errstr, "%sloop %8lx\n", str, (unsigned long)l);

	NMG_CK_LOOP(l);
	NMG_CK_LOOPUSE(lu);

	if (l->lu_p != lu && l->lu_p->lumate_p != lu) rt_bomb(
		strcat(errstr, "nmg_ck_l() Cannot get from loop to loopuse\n"));

	if (l->lg_p) nmg_ck_lg(l, l->lg_p, errstr);

	bu_free(errstr, "");
}

/*
 *			N M G _ C K _ L U
 */
void
nmg_ck_lu(const long int *parent, const struct loopuse *lu, const char *str)
{
	struct edgeuse *eu;
	struct vertexuse *vu;
	char *errstr;
	int l;
	int edgeuse_num=0;
	long	magic1;

	errstr = bu_calloc(strlen(str)+128, 1, "nmg_ck_lu error str");
	(void)sprintf(errstr, "%sloopuse %8lx\n", str, (unsigned long)lu);
	
	NMG_CK_LOOPUSE(lu);

	if (lu->up.magic_p != parent) rt_bomb(
		strcat(errstr, "nmg_ck_lu() loopuse child denies parentage\n") );

	/* check the parent of lu and lumate WRT each other */
	NMG_CK_LOOPUSE(lu->lumate_p);
	if (*lu->lumate_p->up.magic_p != *lu->up.magic_p) rt_bomb(
		strcat(errstr,"nmg_ck_lu() loopuse mate has different kind of parent\n"));

	if (*lu->up.magic_p == NMG_SHELL_MAGIC) {
		if (lu->lumate_p->up.s_p != lu->up.s_p) rt_bomb(
			strcat(errstr, "nmg_ck_lu() Lumate not in same shell\n") );
	} else if (*lu->up.magic_p == NMG_FACEUSE_MAGIC) {
		if (lu->lumate_p->up.fu_p != lu->up.fu_p->fumate_p) rt_bomb(
			strcat(errstr, "nmg_ck_lu() lumate part of different face\n"));
	} else {
		rt_bomb(strcat(errstr, "nmg_ck_lu() Bad loopuse parent type\n"));
	}

	NMG_CK_LOOP(lu->l_p);
	nmg_ck_l(lu, lu->l_p, errstr);

	/* check the children of the loopuse */
	magic1 = BU_LIST_FIRST_MAGIC( &lu->down_hd );
	if (magic1 == NMG_VERTEXUSE_MAGIC) {
		vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
		NMG_CK_VERTEXUSE(vu);
		nmg_ck_vu(&lu->l.magic, vu, errstr);
	} else if (magic1 == NMG_EDGEUSE_MAGIC) {
		l = strlen(errstr);
		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			NMG_CK_EDGEUSE(eu);
			(void)sprintf(&errstr[l], "%sedgeuse #%d (%8lx)\n",
				errstr, edgeuse_num++, (unsigned long)eu);
			nmg_ck_eu(&lu->l.magic, eu, errstr);
		}
	} else {
		rt_bomb(strcat(errstr, "nmg_ck_lu() Bad loopuse down pointer\n") );
	}
	bu_free(errstr, "nmg_ck_lu error str");
}

/*
 *			N M G _ C K _ F G
 */
void
nmg_ck_fg(const struct face *f, const struct face_g_plane *fg, const char *str)
{
	char *errstr;
	errstr = bu_calloc(strlen(str)+128, 1, "nmg_ck_fg error str");
	(void)sprintf(errstr, "%sFace_g %8lx\n", str, (unsigned long)f);

	NMG_CK_FACE_G_PLANE(fg);
	if (fg->N[X]==0.0 && fg->N[Y]==0.0 && fg->N[Z]==0.0 && fg->N[H]!=0.0){
		(void)sprintf(&errstr[strlen(errstr)],
			"nmg_ck_fg() bad NMG plane equation %fX + %fY + %fZ = %f\n",
			fg->N[X], fg->N[Y], fg->N[Z], fg->N[H]);
	        rt_bomb(errstr);
	}

	bu_free(errstr, "nmg_ck_fg error str");
}

/* 
 *			N M G _ C K _ F
 */
void
nmg_ck_f(const struct faceuse *fu, const struct face *f, const char *str)
{
	char *errstr;
	errstr = bu_calloc(strlen(str)+128, 1, "nmg_ck_f error str");
	(void)sprintf(errstr, "%sFace %8lx\n", str, (unsigned long)f);

	NMG_CK_FACE(f);
	NMG_CK_FACEUSE(fu);
	NMG_CK_FACE_G_PLANE(f->g.plane_p);
	if (f->fu_p != fu && f->fu_p->fumate_p != fu) rt_bomb(
		strcat(errstr,"nmg_ck_f() Cannot get from face to \"parent faceuse\"\n"));

	if (f->g.plane_p) nmg_ck_fg(f, f->g.plane_p, errstr);

	bu_free(errstr, "nmg_ck_f error str");
}

/*
 *			N M G _ C K _ F U
 */
void
nmg_ck_fu(const struct shell *s, const struct faceuse *fu, const char *str)
{
	char *errstr;
	int l;
	int loop_number = 0;
	struct loopuse *lu;

	NMG_CK_FACEUSE(fu);
	NMG_CK_SHELL(s);

	errstr = bu_calloc(strlen(str)+128, 1, "nmg_ck_fu error str");
	(void)sprintf(errstr, "%sFaceuse %8lx\n", str, (unsigned long)fu);

	if (fu->s_p != s) rt_bomb(
		strcat(errstr, "nmg_ck_fu() faceuse child denies shell parentage\n") );

	if( BU_LIST_PNEXT_PLAST( faceuse, fu ) )
		rt_bomb( strcat(errstr, "nmg_ck_fu() Faceuse not lastward of next faceuse\n") );

	if( BU_LIST_PLAST_PNEXT( faceuse, fu ) )
		rt_bomb( strcat(errstr, "nmg_ck_fu() Faceuse not nextward from last faceuse\n") );

	NMG_CK_FACEUSE(fu->fumate_p);
	if (fu->fumate_p->fumate_p != fu) rt_bomb(
		strcat(errstr, "nmg_ck_fu() Faceuse not fumate of fumate\n") );

	if (fu->fumate_p->s_p != s) rt_bomb(
		strcat(errstr, "nmg_ck_fu() faceuse mates not in same shell\n") );

	nmg_ck_f(fu, fu->f_p, errstr);

	l = strlen(errstr);
	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		(void)sprintf(&errstr[l] , "%sloopuse #%d (%8lx)\n", 
			errstr, loop_number++, (unsigned long)lu);
		nmg_ck_lu(&fu->l.magic, lu, errstr);
	}
	bu_free(errstr, "nmg_ck_fu error str");
}

/*	N M G _ C K _ E G _ V E R T S
 *
 * Check if vertices from edgeuses using this edge geometry
 * actually lie on the edge geomatry.
 *
 * "eg" must be LSEG
 * returns number of vertices not on edge line
 */

int
nmg_ck_eg_verts(const struct edge_g_lseg *eg, const struct bn_tol *tol)
{
	struct bu_list *eu2;
	vect_t e_dir;
	int count=0;

	NMG_CK_EDGE_G_LSEG( eg );
	BN_CK_TOL( tol );

	VMOVE( e_dir , eg->e_dir );
	VUNITIZE( e_dir );

	for( BU_LIST_FOR( eu2 , bu_list , &eg->eu_hd2 ) )
	{
		struct edgeuse *eu;
		struct vertex *v1,*v2;
		struct vertex_g *vg1,*vg2;
		vect_t pt_to_vert;
		vect_t eg_to_vert;

		eu = BU_LIST_MAIN_PTR( edgeuse, eu2, l2 );

		NMG_CK_EDGEUSE( eu );

		v1 = eu->vu_p->v_p;
		NMG_CK_VERTEX( v1 );
		vg1 = v1->vg_p;
		NMG_CK_VERTEX_G( vg1 );

		v2 = eu->eumate_p->vu_p->v_p;
		NMG_CK_VERTEX( v2 );
		vg2 = v2->vg_p;
		NMG_CK_VERTEX_G( vg2 );

		VSUB2( pt_to_vert , vg1->coord , eg->e_pt );
		VJOIN1( eg_to_vert , pt_to_vert , -VDOT( e_dir , pt_to_vert ) , e_dir );
		if( MAGSQ( eg_to_vert ) > tol->dist_sq )
		{
			count++;
			bu_log( "vertex ( %g %g %g ) on eu to ( %g %g %g )\n", V3ARGS( vg1->coord ),
					V3ARGS( vg2->coord ) );
			bu_log( "\tnot on edge geometry: pt=( %g %g %g ), dir=( %g %g %g )\n",
					V3ARGS( eg->e_pt ), V3ARGS( eg->e_dir ) );
		}
	}

	return( count );
}

/*	N M G _ C K _ G E O M E T R Y
 *
 * Check that vertices actually lie on geometry for
 * faces and edges
 *
 * returns number of vertices that do not lie on geometry
 */
int
nmg_ck_geometry(const struct model *m, const struct bn_tol *tol)
{
	struct bu_ptbl g_tbl;
	int i;
	int count=0;

	NMG_CK_MODEL( m );
	BN_CK_TOL( tol );

	bu_ptbl_init( &g_tbl , 64, " &g_tbl ");

	nmg_edge_g_tabulate( &g_tbl , &m->magic );

	for( i=0 ; i<BU_PTBL_END( &g_tbl ) ; i++ )
	{
		long *ep;
		struct edge_g_lseg *eg;

		ep = BU_PTBL_GET( &g_tbl , i );
		switch( *ep )
		{
			case NMG_EDGE_G_LSEG_MAGIC:
				eg = (struct edge_g_lseg *)ep;
				NMG_CK_EDGE_G_LSEG( eg );
				count += nmg_ck_eg_verts( eg , tol );
				break;
			case NMG_EDGE_G_CNURB_MAGIC:
				/* XXX any checking for vertices on CNURB geometry?? */
				break;
		}
	}

	bu_ptbl_reset( &g_tbl );

	nmg_face_tabulate( &g_tbl , &m->magic );

	for( i=0 ; i<BU_PTBL_END( &g_tbl ) ; i++ )
	{
		struct face *f;

		f = (struct face *)BU_PTBL_GET( &g_tbl , i );
		NMG_CK_FACE( f );

		count += nmg_ck_fg_verts( f->fu_p , f , tol );
	}

	bu_ptbl_free( &g_tbl );

	return( count );
}

/*
 *			N M G _ C K _ F A C E _ W O R T H L E S S _ E D G E S
 *
 *  Search for null ("worthless") edges in a face.
 *  Such edges are legitimate to have, but can be troublesome
 *  for the boolean routines.
 *
 *  Often used to see if breaking an edge at a given
 *  vertex results in a null edge being created.
 */
int
nmg_ck_face_worthless_edges(const struct faceuse *fu)
{
	const struct loopuse	*lu;

	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		struct edgeuse	*eu;

		NMG_CK_LOOPUSE(lu);
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
			continue;
		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			struct edgeuse		*neu;
			neu = BU_LIST_PNEXT_CIRC( edgeuse, eu );
			if( eu == neu )
				rt_bomb("nmg_ck_face_worthless_edges() lu has only one edge?\n");
			if( eu->vu_p == neu->vu_p )
				rt_bomb("nmg_ck_face_worthless_edges() edge runs between two copies of vu??\n");
			if( eu->vu_p->v_p == neu->vu_p->v_p )  {
#if 0
				nmg_pr_eu( eu, NULL );
				nmg_pr_eu( neu, NULL );
#endif
				bu_log("eu=x%x, neu=x%x, v=x%x\n", eu, neu, eu->vu_p->v_p);
				bu_log("eu=x%x, neu=x%x, v=x%x\n", eu->eumate_p, neu->eumate_p, eu->eumate_p->vu_p->v_p);
				rt_bomb("nmg_ck_face_worthless_edges() edge runs from&to same vertex\n");
				return 1;
			}
		}
	}
	return 0;

}



/*
 *			N M G _ C K _ L U E U
 *
 *	check all the edgeuses of a loopuse to make sure these children
 *	know who thier parent really is.
 */
void nmg_ck_lueu(const struct loopuse *cklu, const char *s)
{
	struct edgeuse *eu;

	if (BU_LIST_FIRST_MAGIC(&cklu->down_hd) == NMG_VERTEXUSE_MAGIC)
		rt_bomb("NMG nmg_ck_lueu.  I got a vertex loop!\n");

	eu = BU_LIST_FIRST(edgeuse, &cklu->down_hd);
	if (eu->l.back != &cklu->down_hd) {
		rt_bomb("nmg_ck_lueu first element in list doesn't point back to head\n");
	}

	for (BU_LIST_FOR(eu, edgeuse, &cklu->down_hd)) {
		NMG_CK_EDGEUSE(eu);
		if (eu->up.lu_p != cklu) {
			bu_log("nmg_cl_lueu() edgeuse of %s (going next) has lost proper parent\n", s);
			rt_bomb("nmg_ck_lueu\n");
		}
		if ((struct edgeuse *)eu->l.forw->back != eu) {
			bu_log("nmg_cl_lueu() %s next edge (%8x) doesn't point back to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
		if ((struct edgeuse *)eu->l.back->forw != eu) {
			bu_log("nmg_cl_lueu() %s last edge (%8x) doesn't point forward to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
	}

	cklu = cklu->lumate_p;

	eu = BU_LIST_FIRST(edgeuse, &cklu->down_hd);
	if (eu->l.back != &cklu->down_hd) {
		rt_bomb("nmg_ck_lueu first element in lumate list doesn't point back to head\n");
	}

	for (BU_LIST_FOR(eu, edgeuse, &cklu->down_hd)) {
		NMG_CK_EDGEUSE(eu);
		if (eu->up.lu_p != cklu) {
			bu_log("nmg_cl_lueu() edgeuse of %s (lumate going next) has lost proper parent\n", s);
			rt_bomb("nmg_ck_lueu\n");
		}
		if ((struct edgeuse *)eu->l.forw->back != eu) {
			bu_log("nmg_cl_lueu() %s next edge (%8x) doesn't point back to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
		if ((struct edgeuse *)eu->l.back->forw != eu) {
			bu_log("nmg_cl_lueu() %s (lumate) back edge (%8x) doesn't point forward to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
	}
}

/*
 *			N M G _ C H E C K _ R A D I A L
 *
 *	check to see if all radial uses of an edge (within a shell) are
 *	properly oriented with respect to each other.
 *	NOTE that ONLY edgeuses belonging to the shell of eu are checked.
 *
 *	Can't check faceuse orientation parity for
 *	things from more than one shell;  parity is conserved
 *	only within faces from a single shell.
 *
 *  XXX Added code to skip dangling faces (needs to be checked a little more) - JRA
 *
 *  XXX I think that if dangling faces are to be processed correctly,
 *  XXX the caller should pass in a table of dangling faces.  -Mike
 *  XXX I've #if'ed that check out, for now.
 *
 *	Return
 *	0	OK
 *	1	bad edgeuse mate
 *	2	unclosed space
 */
int
nmg_check_radial(const struct edgeuse *eu, const struct bn_tol *tol)
{
	const struct shell	*s;

	NMG_CK_EDGEUSE(eu);
	BN_CK_TOL(tol);
	s = nmg_find_s_of_eu(eu);
	NMG_CK_SHELL(s);

#if 1
	/* Just use the new checker */
	return nmg_eu_radial_check( eu, s, tol );
#else
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_check_radial(eu=x%x, tol)\n", eu);
	}

	eu_orig = eu;
	eu1 = eu;

	/* If this eu is a wire, advance to first non-wire (skipping dangling faces). */
	while( (fu = nmg_find_fu_of_eu(eu)) == (struct faceuse *)NULL ||
		nmg_find_s_of_eu((struct edgeuse *)eu) != s
#if BO_DANGLE
		|| nmg_dangling_face( fu, (char *)NULL )
#endif
	)  {
		eu = eu->radial_p->eumate_p;
		if( eu == eu1 )  return 0;	/* wires all around */
	}

	curr_orient = fu->orientation;
	eur = eu->radial_p;
	eurstart = eur;
	eu1 = eu;				/* virtual radial to eur */

	NMG_CK_EDGEUSE(eur);
	do {
		/*
		 *  Search until another edgeuse in this shell is found.
		 *  Continue search if it is a wire edge or dangling face.
		 */
		while( nmg_find_s_of_eu((struct edgeuse *)eur) != s  ||
		       (fu = nmg_find_fu_of_eu(eur)) == (struct faceuse *)NULL
#if BO_DANGLE
			|| nmg_dangling_face( fu, (char *)NULL )
#endif
		)  {
			/* Advance to next eur */
			NMG_CK_EDGEUSE(eur->eumate_p);
			if (eur->eumate_p->eumate_p != eur) {
				rt_bomb("nmg_check_radial: bad edgeuse mate\n");
			}
			eur = eur->eumate_p->radial_p;
			NMG_CK_EDGEUSE(eur);
			if( eur == eurstart )  return 0;
		}

		/* if that radial edgeuse doesn't have the
		 * correct orientation, print & bomb
		 * If radial (eur) is my (virtual, this-shell) mate (eu1),
		 * then it's ok, a mis-match is to be expected.
		 */
		NMG_CK_LOOPUSE(eur->up.lu_p);
		fu = eur->up.lu_p->up.fu_p;
		NMG_CK_FACEUSE(fu);
		if (fu->orientation != curr_orient &&
		    eur != eu1->eumate_p ) {
		    	char file[128];
		    	char buf[128];
		    	static int num=0;

			p = eu1->vu_p->v_p->vg_p->coord;
			q = eu1->eumate_p->vu_p->v_p->vg_p->coord;
			bu_log("nmg_check_radial(): Radial orientation problem\n  edge: %g %g %g -> %g %g %g\n",
				p[0], p[1], p[2], q[0], q[1], q[2]);
			bu_log("  eu_orig=%8x, eur=%8x, s=x%x, eurstart=x%x, curr_orient=%s\n",
				eu_orig, eur, s, eurstart,
				nmg_orientation(curr_orient) );

			/* Plot the edge in yellow, & the loops */
			rt_g.NMG_debug |= DEBUG_PLOTEM;
			nmg_face_lu_plot( eu1->up.lu_p, eu1->vu_p,
				eu1->eumate_p->vu_p );
			nmg_face_lu_plot( eur->up.lu_p, eur->vu_p,
				eur->eumate_p->vu_p );

		    	sprintf(buf, "%g %g %g -> %g %g %g\n",
				p[0], p[1], p[2], q[0], q[1], q[2]);
		    	
		    	sprintf(file, "radial%d.g", num++);
		    	nmg_stash_model_to_file( file, 
		    		nmg_find_model(&(fu->l.magic)), buf);

			nmg_pr_fu_around_eu( eu_orig, tol );

			bu_log("nmg_check_radial: unclosed space\n");
			return(2);
		}

		eu1 = eur->eumate_p;
		NMG_CK_LOOPUSE(eu1->up.lu_p);
		NMG_CK_FACEUSE(eu1->up.lu_p->up.fu_p);
		curr_orient = eu1->up.lu_p->up.fu_p->orientation;
		eur = eu1->radial_p;
	} while (eur != eurstart);
	return(0);
#endif
}

/*
 *			N M G _ E U _ 2 S _ O R I E N T _ B A D
 *
 *  Given an edgeuse, check that the proper orientation "parity" of
 *  same/opposite/opposite/same is preserved, for all non-wire edgeuses
 *  within shell s1.
 *  If s2 is non-null, then ensure that the parity of all edgeuses in
 *  BOTH s1 and s2 are correct, and mutually compatible.
 *
 *  This routine does not care if a face is "dangling" or not.
 *
 *  If the edgeuse specified is a wire edgeuse, skip forward to a non-wire.
 *
 *  Returns -
 *	0	OK
 *	!0	Bad orientation parity.
 */
int
nmg_eu_2s_orient_bad(const struct edgeuse *eu, const struct shell *s1, const struct shell *s2, const struct bn_tol *tol)
{
	char			curr_orient;
	const struct edgeuse	*eu_orig;
	const struct edgeuse	*eur;
	const struct edgeuse	*eu1;
	const struct edgeuse	*eurstart;
	const struct faceuse	*fu;
	const struct shell	*s;
	int			ret = 0;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_SHELL(s1);
	if(s2) NMG_CK_SHELL(s2);	/* s2 may be NULL */
	BN_CK_TOL(tol);

	eu_orig = eu;			/* for printing */
	eu1 = eu;			/* remember, for loop termination */

	/*
	 *  If this eu is not in s1, or it is a wire,
	 *  advance to first non-wire.
	 */
	for(;;)  {
		fu = nmg_find_fu_of_eu(eu);
		if( !fu ) goto next_a;		/* it's a wire */
		s = fu->s_p;
		NMG_CK_SHELL(s);
		if( s != s1 )  goto next_a;
		break;
next_a:
		eu = eu->radial_p->eumate_p;
		if( eu == eu1 )  goto out;	/* wires all around */
	}

	curr_orient = fu->orientation;
	eur = eu->radial_p;
	eurstart = eur;
	eu1 = eu;				/* virtual radial to eur */

	NMG_CK_EDGEUSE(eur);
	do {
		/*
		 *  Search until another edgeuse in shell s1 or s2 is found.
		 *  Continue search if it is a wire edge or dangling face.
		 */
		for(;;)  {
			fu = nmg_find_fu_of_eu(eur);
			if( !fu ) goto next_eu;		/* it's a wire */
			NMG_CK_FACEUSE(fu);
			s = fu->s_p;
			NMG_CK_SHELL(s);
			if( s != s1 )  {
				if( !s2 )  goto next_eu;
				if( s != s2 )  goto next_eu;
			}
			break;
next_eu:
			/* Advance to next eur */
			NMG_CK_EDGEUSE(eur->eumate_p);
			if (eur->eumate_p->eumate_p != eur)
				rt_bomb("nmg_eu_2s_orient_bad: bad edgeuse mate\n");

			eur = eur->eumate_p->radial_p;
			NMG_CK_EDGEUSE(eur);
			if( eur == eurstart )  goto out;
		}

		/*
		 *  eur is mate's radial of last eu.
		 *  If the orientation does not match, this is an error.
		 *  If radial (eur) is my (virtual, this-shell) mate (eu1),
		 *  then it's OK, a mis-match is to be expected when there
		 *  is only one edgeuse&mate from this shell on this edge.
		 */
		if (fu->orientation != curr_orient &&
		    eur != eu1->eumate_p ) {
			nmg_pr_fu_around_eu( eu_orig, tol );
			bu_log("nmg_eu_2s_orient_bad(eu=x%x, s1=x%x, s2=x%x) bad radial parity eu1=x%x, eur=x%x, eurstart=x%x\n",
				eu_orig, s1, s2, eu1, eur, eurstart);
		    	ret = 1;
		    	goto out;
		}

		/* If eu belongs to a face, eumate had better, also! */
		eu1 = eur->eumate_p;
		NMG_CK_LOOPUSE(eu1->up.lu_p);
		fu = eu1->up.lu_p->up.fu_p;
		NMG_CK_FACEUSE(fu);
		curr_orient = fu->orientation;
		eur = eu1->radial_p;
	} while (eur != eurstart);
	/* All is well, the whole way 'round */
out:
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_eu_2s_orient_bad(eu=x%x, s1=x%x, s2=x%x) ret=%d\n",
			eu_orig, s1, s2, ret);
	}
	return ret;
}

/*
 *		 	N M G _ C K _ C L O S E D _ S U R F
 *
 *  Verify that shell is closed.
 *  Do this by verifying that it is not possible to get from outside
 *  to inside the solid by crossing any face edge.
 *
 *  Returns -
 *	 0	OK
 *	!0	Problem.
 */
int
nmg_ck_closed_surf(const struct shell *s, const struct bn_tol *tol)
{
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	int		status = 0;
	long		magic1;

	NMG_CK_SHELL(s);
	BN_CK_TOL(tol);
	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
			NMG_CK_LOOPUSE(lu);
			magic1 = BU_LIST_FIRST_MAGIC( &lu->down_hd );
			if (magic1 == NMG_EDGEUSE_MAGIC) {
				/* Check status on all the edgeuses before quitting */
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
					if (nmg_check_radial(eu, tol))
						status = 1;
				}
				if( status )  {
					bu_log("nmg_ck_closed_surf(x%x), problem with loopuse x%x\n", s, lu);
					return 1;
				}
			} else if (magic1 == NMG_VERTEXUSE_MAGIC) {
				register struct vertexuse	*vu;
				vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
				NMG_CK_VERTEXUSE(vu);
				NMG_CK_VERTEX(vu->v_p);
			}
		}
	}
	return(0);
}

/*
 *			N M G _ C K _ C L O S E D _ R E G I O N
 *
 *  Check all the shells in a region for being closed.
 *
 *  Returns -
 *	 0	OK
 *	!0	status code from nmg_check_radial()
 */
int
nmg_ck_closed_region(const struct nmgregion *r, const struct bn_tol *tol)
{
	const struct shell	*s;
	int		ret;

	NMG_CK_REGION(r);
	BN_CK_TOL(tol);
	for( BU_LIST_FOR( s, shell, &r->s_hd ) )  {
		ret = nmg_ck_closed_surf( s, tol );
		if( ret != 0 )  return(ret);
	}
	return(0);
}

/*	N M G _ C K _ V _ I N _ 2 F U S
 *
 *	accepts a vertex pointer, two faceuses, and a tolerance.
 *	Checks if the vertex is in both faceuses (topologically
 *	and geometrically within tolerance of plane).
 *
 *	Calls rt_bomb if vertex is not in the faceuses topology or
 *	out of tolerance of either face.
 *
 */

void
nmg_ck_v_in_2fus(const struct vertex *vp, const struct faceuse *fu1, const struct faceuse *fu2, const struct bn_tol *tol)
{
	struct bu_vls str;
	struct faceuse *fu;
	struct vertexuse *vu;
	fastf_t dist1,dist2;
	int found1=0,found2=0;
	plane_t	n1, n2;

	NMG_CK_VERTEX( vp );
	NMG_CK_FACEUSE( fu1 );
	NMG_CK_FACEUSE( fu2 );
	BN_CK_TOL( tol );

	/* topology check */
	for( BU_LIST_FOR( vu , vertexuse , &vp->vu_hd ) )
	{
		fu = nmg_find_fu_of_vu( vu );
		if( fu == fu1 )
			found1 = 1;
		if( fu == fu2 )
			found2 = 1;
		if( found1 && found2 )
			break;
	}

	if( !found1 || !found2 )
	{
		bu_vls_init( &str );
		bu_vls_printf( &str , "nmg_ck_v_in_2fus: vertex x%x not used in" , vp );
		if( !found1 )
			bu_vls_printf( &str , " faceuse x%x" , fu1 );
		if( !found2 )
			bu_vls_printf( &str , " faceuse x%x" , fu2 );
		rt_bomb( bu_vls_addr( &str ) );
	}

	/* geometry check */
	NMG_GET_FU_PLANE(n1, fu1);
	NMG_GET_FU_PLANE(n2, fu2);
	dist1 = DIST_PT_PLANE( vp->vg_p->coord , n1 );
	dist2 = DIST_PT_PLANE( vp->vg_p->coord , n2 );

	if( !NEAR_ZERO( dist1 , tol->dist ) || !NEAR_ZERO( dist2 , tol->dist ) )
	{
		bu_vls_init( &str );
		bu_vls_printf( &str , "nmg_ck_v_in_2fus: vertex x%x ( %g %g %g ) not in plane of" ,
				vp , V3ARGS( vp->vg_p->coord ) );
		if( !NEAR_ZERO( dist1 , tol->dist ) )
			bu_vls_printf( &str , " faceuse x%x (off by %g)" , fu1 , dist1 );
		if( !NEAR_ZERO( dist2 , tol->dist ) )
			bu_vls_printf( &str , " faceuse x%x (off by %g)" , fu2 , dist2 );
		rt_bomb( bu_vls_addr( &str ) );
	}

}
/*	N M G _ C K _ V S _ I N _ R E G I O N
 *
 *	Visits every vertex in the region and checks if the
 *	vertex coordinates are within tolerance of every face
 *	it is supposed to be in (according to the topology).
 *
 */

struct v_ck_state {
        char            *visited;
        struct bu_ptbl *tabl;
	struct bn_tol	*tol;
};

static void
nmg_ck_v_in_fus(long int *vp, genptr_t state, int first)
{
        register struct v_ck_state *sp = (struct v_ck_state *)state;
        register struct vertex  *v = (struct vertex *)vp;

        NMG_CK_VERTEX(v);
        /* If this vertex has been processed before, do nothing more */
        if( NMG_INDEX_FIRST_TIME(sp->visited, v) )
	{
		struct vertexuse *vu;
		struct faceuse *fu;

		for( BU_LIST_FOR( vu , vertexuse , &v->vu_hd ) )
		{
			fastf_t dist;

			fu = nmg_find_fu_of_vu( vu );
			if( fu )
			{
				plane_t		n;

				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					continue;
				if( !fu->f_p->g.magic_p )
					bu_log( "ERROR - nmg_ck_vs_in_region: fu (x%x) has no geometry\n", fu );
				else if( *fu->f_p->g.magic_p == NMG_FACE_G_PLANE_MAGIC )
				{
					NMG_GET_FU_PLANE( n, fu );
					dist = DIST_PT_PLANE( v->vg_p->coord , n );
					if( !NEAR_ZERO( dist , sp->tol->dist ) )
					{
						bu_log( "ERROR - nmg_ck_vs_in_region: vertex x%x ( %g %g %g ) is %g from faceuse x%x\n" , 
							v , V3ARGS( v->vg_p->coord ) , dist , fu );
					}
				}
				/* else if( *fu->f_p->g.magic_p == NMG_FACE_G_SNURB_MAGIC ) XXXX */
			}
		}
	}
}

void
nmg_ck_vs_in_region(const struct nmgregion *r, const struct bn_tol *tol)
{
	struct model			*m;
	struct v_ck_state		st;
	struct nmg_visit_handlers       handlers;
	struct bu_ptbl			tab;

        NMG_CK_REGION(r);
	BN_CK_TOL( tol );
        m = r->m_p;
        NMG_CK_MODEL(m);

        st.visited = (char *)bu_calloc(m->maxindex+1, sizeof(char), "visited[]");
        st.tabl = &tab;
	st.tol = (struct bn_tol *)tol;

        (void)bu_ptbl_init( &tab, 64, " &tab");

        handlers = nmg_visit_handlers_null;             /* struct copy */
        handlers.vis_vertex = nmg_ck_v_in_fus;
        nmg_visit( &r->l.magic, &handlers, (genptr_t)&st );

	bu_ptbl_free( &tab );

        bu_free( (char *)st.visited, "visited[]");
}
@


11.28
log
@change conf.h to a wrapped config.h
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_ck.c,v 11.27 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.27
log
@merge of ansi-6-0-branch into HEAD
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d28 5
a32 1
#include "conf.h"
@


11.26
log
@update copyright to include span through 2003
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_ck.c,v 11.25 2002/08/20 17:08:03 jra Exp $ (ARL)";
d54 1
a54 2
nmg_vvg(vg)
const struct vertex_g *vg;
d65 1
a65 3
nmg_vvertex(v, vup)
const struct vertex *v;
const struct vertexuse *vup;
d86 1
a86 2
nmg_vvua(vua)
const long *vua;
d97 1
a97 3
nmg_vvu(vu, up_magic_p)
const struct vertexuse *vu;
const long		*up_magic_p;
d126 1
a126 2
nmg_veg(eg)
const long *eg;
d166 1
a166 3
nmg_vedge(e, eup)
const struct edge *e;
const struct edgeuse *eup;
d235 1
a235 3
nmg_veu(hp, up_magic_p)
const struct bu_list	*hp;
const long	*up_magic_p;
d365 1
a365 2
nmg_vlg(lg)
const struct loop_g *lg;
d382 1
a382 3
nmg_vloop(l, lup)
const struct loop *l;
const struct loopuse *lup;
d411 1
a411 3
nmg_vlu(hp, up)
const struct bu_list	*hp;
const long		*up;
d471 1
a471 2
nmg_vfg(fg)
const struct face_g_plane *fg;
d496 1
a496 3
nmg_vface(f, fup)
const struct face *f;
const struct faceuse *fup;
d529 1
a529 3
nmg_vfu(hp, s)
const struct bu_list	*hp;
const struct shell *s;
d584 1
a584 3
nmg_vshell(hp, r)
const struct bu_list	*hp;
const struct nmgregion *r;
d651 1
a651 3
nmg_vregion(hp, m)
const struct bu_list	*hp;
const struct model *m;
d680 1
a680 2
nmg_vmodel(m)
const struct model *m;
d697 1
a697 4
nmg_ck_e(eu, e, str)
const struct edgeuse *eu;
const struct edge *e;
const char *str;
d727 1
a727 4
nmg_ck_vu(parent, vu, str)
const long *parent;
const struct vertexuse *vu;
const char *str;
d744 1
a744 4
nmg_ck_eu(parent, eu, str)
const long *parent;
const struct edgeuse *eu;
const char *str;
d809 1
a809 4
nmg_ck_lg(l, lg, str)
const struct loop *l;
const struct loop_g *lg;
const char *str;
d825 1
a825 4
nmg_ck_l(lu, l, str)
const struct loopuse *lu;
const struct loop *l;
const char *str;
d846 1
a846 4
nmg_ck_lu(parent, lu, str)
const long *parent;
const struct loopuse *lu;
const char *str;
d905 1
a905 4
nmg_ck_fg(f, fg, str)
const struct face *f;
const struct face_g_plane *fg;
const char *str;
d926 1
a926 4
nmg_ck_f(fu, f, str)
const struct faceuse *fu;
const struct face *f;
const char *str;
d947 1
a947 4
nmg_ck_fu(s, fu, str)
const struct shell *s;
const struct faceuse *fu;
const char *str;
d998 1
a998 3
nmg_ck_eg_verts( eg , tol )
const struct edge_g_lseg *eg;
const struct bn_tol *tol;
d1055 1
a1055 3
nmg_ck_geometry( m , tol )
const struct model *m;
const struct bn_tol *tol;
d1117 1
a1117 2
nmg_ck_face_worthless_edges( fu )
const struct faceuse	*fu;
d1158 1
a1158 3
void nmg_ck_lueu(cklu, s)
const struct loopuse *cklu;
const char *s;
d1233 1
a1233 3
nmg_check_radial(eu, tol)
const struct edgeuse	*eu;
const struct bn_tol	*tol;
d1361 1
a1361 5
nmg_eu_2s_orient_bad(eu, s1, s2, tol)
const struct edgeuse	*eu;
const struct shell	*s1;
const struct shell	*s2;
const struct bn_tol	*tol;
d1474 1
a1474 3
nmg_ck_closed_surf(s, tol)
const struct shell	*s;
const struct bn_tol	*tol;
d1520 1
a1520 3
nmg_ck_closed_region(r, tol)
const struct nmgregion	*r;
const struct bn_tol	*tol;
d1546 1
a1546 5
nmg_ck_v_in_2fus( vp , fu1 , fu2 , tol )
const struct vertex *vp;
const struct faceuse *fu1;
const struct faceuse *fu2;
const struct bn_tol *tol;
d1617 1
a1617 4
nmg_ck_v_in_fus( vp , state , first )
long			*vp;
genptr_t	        state;
int			first;
d1660 1
a1660 3
nmg_ck_vs_in_region( r , tol )
const struct nmgregion *r;
const struct bn_tol *tol;
@


11.25
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1993 by the United States Army
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_ck.c,v 11.23 2001/04/05 19:35:34 morrison Exp $ (ARL)";
@


11.25.4.1
log
@sync to HEAD...
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_ck.c,v 11.26 2004/02/02 17:39:22 morrison Exp $ (ARL)";
@


11.25.10.1
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_ck.c,v 11.26 2004/02/02 17:39:22 morrison Exp $ (ARL)";
@


11.25.10.2
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_ck.c,v 11.25.10.1 2004/02/12 18:37:43 erikg Exp $ (ARL)";
@


11.25.2.1
log
@Initial ANSIfication
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_ck.c,v 11.25 2002/08/20 17:08:03 jra Exp $ (ARL)";
d54 2
a55 1
nmg_vvg(const struct vertex_g *vg)
d66 3
a68 1
nmg_vvertex(const struct vertex *v, const struct vertexuse *vup)
d89 2
a90 1
nmg_vvua(const long int *vua)
d101 3
a103 1
nmg_vvu(const struct vertexuse *vu, const long int *up_magic_p)
d132 2
a133 1
nmg_veg(const long int *eg)
d173 3
a175 1
nmg_vedge(const struct edge *e, const struct edgeuse *eup)
d244 3
a246 1
nmg_veu(const struct bu_list *hp, const long int *up_magic_p)
d376 2
a377 1
nmg_vlg(const struct loop_g *lg)
d394 3
a396 1
nmg_vloop(const struct loop *l, const struct loopuse *lup)
d425 3
a427 1
nmg_vlu(const struct bu_list *hp, const long int *up)
d487 2
a488 1
nmg_vfg(const struct face_g_plane *fg)
d513 3
a515 1
nmg_vface(const struct face *f, const struct faceuse *fup)
d548 3
a550 1
nmg_vfu(const struct bu_list *hp, const struct shell *s)
d605 3
a607 1
nmg_vshell(const struct bu_list *hp, const struct nmgregion *r)
d674 3
a676 1
nmg_vregion(const struct bu_list *hp, const struct model *m)
d705 2
a706 1
nmg_vmodel(const struct model *m)
d723 4
a726 1
nmg_ck_e(const struct edgeuse *eu, const struct edge *e, const char *str)
d756 4
a759 1
nmg_ck_vu(const long int *parent, const struct vertexuse *vu, const char *str)
d776 4
a779 1
nmg_ck_eu(const long int *parent, const struct edgeuse *eu, const char *str)
d844 4
a847 1
nmg_ck_lg(const struct loop *l, const struct loop_g *lg, const char *str)
d863 4
a866 1
nmg_ck_l(const struct loopuse *lu, const struct loop *l, const char *str)
d887 4
a890 1
nmg_ck_lu(const long int *parent, const struct loopuse *lu, const char *str)
d949 4
a952 1
nmg_ck_fg(const struct face *f, const struct face_g_plane *fg, const char *str)
d973 4
a976 1
nmg_ck_f(const struct faceuse *fu, const struct face *f, const char *str)
d997 4
a1000 1
nmg_ck_fu(const struct shell *s, const struct faceuse *fu, const char *str)
d1051 3
a1053 1
nmg_ck_eg_verts(const struct edge_g_lseg *eg, const struct bn_tol *tol)
d1110 3
a1112 1
nmg_ck_geometry(const struct model *m, const struct bn_tol *tol)
d1174 2
a1175 1
nmg_ck_face_worthless_edges(const struct faceuse *fu)
d1216 3
a1218 1
void nmg_ck_lueu(const struct loopuse *cklu, const char *s)
d1293 3
a1295 1
nmg_check_radial(const struct edgeuse *eu, const struct bn_tol *tol)
d1423 5
a1427 1
nmg_eu_2s_orient_bad(const struct edgeuse *eu, const struct shell *s1, const struct shell *s2, const struct bn_tol *tol)
d1540 3
a1542 1
nmg_ck_closed_surf(const struct shell *s, const struct bn_tol *tol)
d1588 3
a1590 1
nmg_ck_closed_region(const struct nmgregion *r, const struct bn_tol *tol)
d1616 5
a1620 1
nmg_ck_v_in_2fus(const struct vertex *vp, const struct faceuse *fu1, const struct faceuse *fu2, const struct bn_tol *tol)
d1691 4
a1694 1
nmg_ck_v_in_fus(long int *vp, genptr_t state, int first)
d1737 3
a1739 1
nmg_ck_vs_in_region(const struct nmgregion *r, const struct bn_tol *tol)
@


11.25.2.2
log
@sync branch with HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.24
log
@Converted from K&R to ANSI C - RFH
@
text
@d54 2
a55 1
nmg_vvg(const struct vertex_g *vg)
d66 3
a68 1
nmg_vvertex(const struct vertex *v, const struct vertexuse *vup)
d89 2
a90 1
nmg_vvua(const long int *vua)
d101 3
a103 1
nmg_vvu(const struct vertexuse *vu, const long int *up_magic_p)
d132 2
a133 1
nmg_veg(const long int *eg)
d173 3
a175 1
nmg_vedge(const struct edge *e, const struct edgeuse *eup)
d244 3
a246 1
nmg_veu(const struct bu_list *hp, const long int *up_magic_p)
d376 2
a377 1
nmg_vlg(const struct loop_g *lg)
d394 3
a396 1
nmg_vloop(const struct loop *l, const struct loopuse *lup)
d425 3
a427 1
nmg_vlu(const struct bu_list *hp, const long int *up)
d487 2
a488 1
nmg_vfg(const struct face_g_plane *fg)
d513 3
a515 1
nmg_vface(const struct face *f, const struct faceuse *fup)
d548 3
a550 1
nmg_vfu(const struct bu_list *hp, const struct shell *s)
d605 3
a607 1
nmg_vshell(const struct bu_list *hp, const struct nmgregion *r)
d674 3
a676 1
nmg_vregion(const struct bu_list *hp, const struct model *m)
d705 2
a706 1
nmg_vmodel(const struct model *m)
d723 4
a726 1
nmg_ck_e(const struct edgeuse *eu, const struct edge *e, const char *str)
d756 4
a759 1
nmg_ck_vu(const long int *parent, const struct vertexuse *vu, const char *str)
d776 4
a779 1
nmg_ck_eu(const long int *parent, const struct edgeuse *eu, const char *str)
d844 4
a847 1
nmg_ck_lg(const struct loop *l, const struct loop_g *lg, const char *str)
d863 4
a866 1
nmg_ck_l(const struct loopuse *lu, const struct loop *l, const char *str)
d887 4
a890 1
nmg_ck_lu(const long int *parent, const struct loopuse *lu, const char *str)
d949 4
a952 1
nmg_ck_fg(const struct face *f, const struct face_g_plane *fg, const char *str)
d973 4
a976 1
nmg_ck_f(const struct faceuse *fu, const struct face *f, const char *str)
d997 4
a1000 1
nmg_ck_fu(const struct shell *s, const struct faceuse *fu, const char *str)
d1051 3
a1053 1
nmg_ck_eg_verts(const struct edge_g_lseg *eg, const struct bn_tol *tol)
d1110 3
a1112 1
nmg_ck_geometry(const struct model *m, const struct bn_tol *tol)
d1174 2
a1175 1
nmg_ck_face_worthless_edges(const struct faceuse *fu)
d1216 3
a1218 1
void nmg_ck_lueu(const struct loopuse *cklu, const char *s)
d1293 3
a1295 1
nmg_check_radial(const struct edgeuse *eu, const struct bn_tol *tol)
d1423 5
a1427 1
nmg_eu_2s_orient_bad(const struct edgeuse *eu, const struct shell *s1, const struct shell *s2, const struct bn_tol *tol)
d1540 3
a1542 1
nmg_ck_closed_surf(const struct shell *s, const struct bn_tol *tol)
d1588 3
a1590 1
nmg_ck_closed_region(const struct nmgregion *r, const struct bn_tol *tol)
d1616 5
a1620 1
nmg_ck_v_in_2fus(const struct vertex *vp, const struct faceuse *fu1, const struct faceuse *fu2, const struct bn_tol *tol)
d1691 4
a1694 1
nmg_ck_v_in_fus(long int *vp, genptr_t state, int first)
d1737 3
a1739 1
nmg_ck_vs_in_region(const struct nmgregion *r, const struct bn_tol *tol)
@


11.23
log
@updated SIGNED to signed
updated CONST to const
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_ck.c,v 11.22 2000/08/21 02:02:31 butler Exp $ (ARL)";
d54 1
a54 2
nmg_vvg(vg)
const struct vertex_g *vg;
d65 1
a65 3
nmg_vvertex(v, vup)
const struct vertex *v;
const struct vertexuse *vup;
d86 1
a86 2
nmg_vvua(vua)
const long *vua;
d97 1
a97 3
nmg_vvu(vu, up_magic_p)
const struct vertexuse *vu;
const long		*up_magic_p;
d126 1
a126 2
nmg_veg(eg)
const long *eg;
d166 1
a166 3
nmg_vedge(e, eup)
const struct edge *e;
const struct edgeuse *eup;
d235 1
a235 3
nmg_veu(hp, up_magic_p)
const struct bu_list	*hp;
const long	*up_magic_p;
d365 1
a365 2
nmg_vlg(lg)
const struct loop_g *lg;
d382 1
a382 3
nmg_vloop(l, lup)
const struct loop *l;
const struct loopuse *lup;
d411 1
a411 3
nmg_vlu(hp, up)
const struct bu_list	*hp;
const long		*up;
d471 1
a471 2
nmg_vfg(fg)
const struct face_g_plane *fg;
d496 1
a496 3
nmg_vface(f, fup)
const struct face *f;
const struct faceuse *fup;
d529 1
a529 3
nmg_vfu(hp, s)
const struct bu_list	*hp;
const struct shell *s;
d584 1
a584 3
nmg_vshell(hp, r)
const struct bu_list	*hp;
const struct nmgregion *r;
d651 1
a651 3
nmg_vregion(hp, m)
const struct bu_list	*hp;
const struct model *m;
d680 1
a680 2
nmg_vmodel(m)
const struct model *m;
d697 1
a697 4
nmg_ck_e(eu, e, str)
const struct edgeuse *eu;
const struct edge *e;
const char *str;
d727 1
a727 4
nmg_ck_vu(parent, vu, str)
const long *parent;
const struct vertexuse *vu;
const char *str;
d744 1
a744 4
nmg_ck_eu(parent, eu, str)
const long *parent;
const struct edgeuse *eu;
const char *str;
d809 1
a809 4
nmg_ck_lg(l, lg, str)
const struct loop *l;
const struct loop_g *lg;
const char *str;
d825 1
a825 4
nmg_ck_l(lu, l, str)
const struct loopuse *lu;
const struct loop *l;
const char *str;
d846 1
a846 4
nmg_ck_lu(parent, lu, str)
const long *parent;
const struct loopuse *lu;
const char *str;
d905 1
a905 4
nmg_ck_fg(f, fg, str)
const struct face *f;
const struct face_g_plane *fg;
const char *str;
d926 1
a926 4
nmg_ck_f(fu, f, str)
const struct faceuse *fu;
const struct face *f;
const char *str;
d947 1
a947 4
nmg_ck_fu(s, fu, str)
const struct shell *s;
const struct faceuse *fu;
const char *str;
d998 1
a998 3
nmg_ck_eg_verts( eg , tol )
const struct edge_g_lseg *eg;
const struct bn_tol *tol;
d1055 1
a1055 3
nmg_ck_geometry( m , tol )
const struct model *m;
const struct bn_tol *tol;
d1117 1
a1117 2
nmg_ck_face_worthless_edges( fu )
const struct faceuse	*fu;
d1158 1
a1158 3
void nmg_ck_lueu(cklu, s)
const struct loopuse *cklu;
const char *s;
d1233 1
a1233 3
nmg_check_radial(eu, tol)
const struct edgeuse	*eu;
const struct bn_tol	*tol;
d1361 1
a1361 5
nmg_eu_2s_orient_bad(eu, s1, s2, tol)
const struct edgeuse	*eu;
const struct shell	*s1;
const struct shell	*s2;
const struct bn_tol	*tol;
d1474 1
a1474 3
nmg_ck_closed_surf(s, tol)
const struct shell	*s;
const struct bn_tol	*tol;
d1520 1
a1520 3
nmg_ck_closed_region(r, tol)
const struct nmgregion	*r;
const struct bn_tol	*tol;
d1546 1
a1546 5
nmg_ck_v_in_2fus( vp , fu1 , fu2 , tol )
const struct vertex *vp;
const struct faceuse *fu1;
const struct faceuse *fu2;
const struct bn_tol *tol;
d1617 1
a1617 4
nmg_ck_v_in_fus( vp , state , first )
long			*vp;
genptr_t	        state;
int			first;
d1660 1
a1660 3
nmg_ck_vs_in_region( r , tol )
const struct nmgregion *r;
const struct bn_tol *tol;
@


11.22
log
@Massive compilation warnings eliminated
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_ck.c,v 11.21 2000/07/10 23:01:38 mike Exp $ (ARL)";
d55 1
a55 1
CONST struct vertex_g *vg;
d67 2
a68 2
CONST struct vertex *v;
CONST struct vertexuse *vup;
d90 1
a90 1
CONST long *vua;
d102 2
a103 2
CONST struct vertexuse *vu;
CONST long		*up_magic_p;
d133 1
a133 1
CONST long *eg;
d174 2
a175 2
CONST struct edge *e;
CONST struct edgeuse *eup;
d177 1
a177 1
	CONST struct edgeuse *eu;
d245 2
a246 2
CONST struct bu_list	*hp;
CONST long	*up_magic_p;
d377 1
a377 1
CONST struct loop_g *lg;
d395 2
a396 2
CONST struct loop *l;
CONST struct loopuse *lup;
d426 2
a427 2
CONST struct bu_list	*hp;
CONST long		*up;
d488 1
a488 1
CONST struct face_g_plane *fg;
d514 2
a515 2
CONST struct face *f;
CONST struct faceuse *fup;
d549 2
a550 2
CONST struct bu_list	*hp;
CONST struct shell *s;
d606 2
a607 2
CONST struct bu_list	*hp;
CONST struct nmgregion *r;
d675 2
a676 2
CONST struct bu_list	*hp;
CONST struct model *m;
d706 1
a706 1
CONST struct model *m;
d724 3
a726 3
CONST struct edgeuse *eu;
CONST struct edge *e;
CONST char *str;
d757 3
a759 3
CONST long *parent;
CONST struct vertexuse *vu;
CONST char *str;
d777 3
a779 3
CONST long *parent;
CONST struct edgeuse *eu;
CONST char *str;
d845 3
a847 3
CONST struct loop *l;
CONST struct loop_g *lg;
CONST char *str;
d864 3
a866 3
CONST struct loopuse *lu;
CONST struct loop *l;
CONST char *str;
d888 3
a890 3
CONST long *parent;
CONST struct loopuse *lu;
CONST char *str;
d950 3
a952 3
CONST struct face *f;
CONST struct face_g_plane *fg;
CONST char *str;
d974 3
a976 3
CONST struct faceuse *fu;
CONST struct face *f;
CONST char *str;
d998 3
a1000 3
CONST struct shell *s;
CONST struct faceuse *fu;
CONST char *str;
d1052 2
a1053 2
CONST struct edge_g_lseg *eg;
CONST struct bn_tol *tol;
d1111 2
a1112 2
CONST struct model *m;
CONST struct bn_tol *tol;
d1175 1
a1175 1
CONST struct faceuse	*fu;
d1177 1
a1177 1
	CONST struct loopuse	*lu;
d1217 2
a1218 2
CONST struct loopuse *cklu;
CONST char *s;
d1294 2
a1295 2
CONST struct edgeuse	*eu;
CONST struct bn_tol	*tol;
d1297 1
a1297 1
	CONST struct shell	*s;
d1424 4
a1427 4
CONST struct edgeuse	*eu;
CONST struct shell	*s1;
CONST struct shell	*s2;
CONST struct bn_tol	*tol;
d1430 6
a1435 6
	CONST struct edgeuse	*eu_orig;
	CONST struct edgeuse	*eur;
	CONST struct edgeuse	*eu1;
	CONST struct edgeuse	*eurstart;
	CONST struct faceuse	*fu;
	CONST struct shell	*s;
d1541 2
a1542 2
CONST struct shell	*s;
CONST struct bn_tol	*tol;
d1589 2
a1590 2
CONST struct nmgregion	*r;
CONST struct bn_tol	*tol;
d1592 1
a1592 1
	CONST struct shell	*s;
d1617 4
a1620 4
CONST struct vertex *vp;
CONST struct faceuse *fu1;
CONST struct faceuse *fu2;
CONST struct bn_tol *tol;
d1738 2
a1739 2
CONST struct nmgregion *r;
CONST struct bn_tol *tol;
@


11.21
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_ck.c,v 11.20 2000/05/02 00:25:50 mike Exp $ (ARL)";
d731 1
a731 1
	(void)sprintf(errstr, "%sedge %8lx\n", str, e);
d764 1
a764 1
	(void)sprintf(errstr, "%svertexuse %8lx\n", str, vu);
d785 1
a785 1
	(void)sprintf(errstr, "%sedgeuse %8lx\n", str, eu);
d851 1
a851 1
	(void)sprintf(errstr, "%sloop_g %8lx\n", str, lg);
d870 1
a870 1
	(void)sprintf(errstr, "%sloop %8lx\n", str, l);
d900 1
a900 1
	(void)sprintf(errstr, "%sloopuse %8lx\n", str, lu);
d936 1
a936 1
				errstr, edgeuse_num++, eu);
d956 1
a956 1
	(void)sprintf(errstr, "%sFace_g %8lx\n", str, f);
d980 1
a980 1
	(void)sprintf(errstr, "%sFace %8lx\n", str, f);
d1011 1
a1011 1
	(void)sprintf(errstr, "%sFaceuse %8lx\n", str, fu);
d1035 1
a1035 1
			errstr, loop_number++, lu);
@


11.20
log
@
stray "rt_list" should be bu_list
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_ck.c,v 11.19 2000/03/29 01:42:59 mike Exp $ (ARL)";
@


11.19
log
@
Moved nmg_ck_list* to bu_ck_list*
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_ck.c,v 11.18 2000/03/29 01:37:00 mike Exp $ (ARL)";
d152 1
a152 1
	for( BU_LIST_FOR( eu2, rt_list, &((struct edge_g_lseg *)eg)->eu_hd2 ) )  {
d1065 1
a1065 1
	for( BU_LIST_FOR( eu2 , rt_list , &eg->eu_hd2 ) )
@


11.18
log
@
Added externs, tidied up CONST args
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_ck.c,v 11.17 1999/12/30 15:29:39 jra Exp $ (ARL)";
d140 1
a140 1
		nmg_ck_list_magic( &((struct edge_g_lseg *)eg)->eu_hd2,
d145 1
a145 1
		nmg_ck_list_magic( &((struct edge_g_cnurb *)eg)->eu_hd2,
d253 1
a253 1
	nmg_ck_list_magic( hp, "nmg_veu() edegeuse list head", NMG_EDGEUSE_MAGIC );
a1204 42
}

/*
 *			N M G _ C K _ L I S T
 *
 *  Generic bu_list doubly-linked list checker.
 *
 *  XXX Probably should be called bu_ck_list().
 */
void
nmg_ck_list( hd, str )
struct bu_list		*hd;
CONST char		*str;
{
	register struct bu_list	*cur;
	int	head_count = 0;

	cur = hd;
	do  {
		if( cur->magic == BU_LIST_HEAD_MAGIC )  head_count++;
		if( !cur->forw )  {
			bu_log("nmg_ck_list(%s) cur=x%x, cur->forw=x%x, hd=x%x\n",
				str, cur, cur->forw, hd );
			rt_bomb("nmg_ck_list() forw\n");
		}
		if( cur->forw->back != cur )  {
			bu_log("nmg_ck_list(%s) cur=x%x, cur->forw=x%x, cur->forw->back=x%x, hd=x%x\n",
				str, cur, cur->forw, cur->forw->back, hd );
			rt_bomb("nmg_ck_list() forw->back\n");
		}
		if( !cur->back )  {
			bu_log("nmg_ck_list(%s) cur=x%x, cur->back=x%x, hd=x%x\n",
				str, cur, cur->back, hd );
			rt_bomb("nmg_ck_list() back\n");
		}
		if( cur->back->forw != cur )  {
			bu_log("nmg_ck_list(%s) cur=x%x, cur->back=x%x, cur->back->forw=x%x, hd=x%x\n",
				str, cur, cur->back, cur->back->forw, hd );
			rt_bomb("nmg_ck_list() back->forw\n");
		}
		cur = cur->forw;
	} while( cur != hd );
a1205 68
	if( head_count != 1 )  {
		bu_log("nmg_ck_list(%s) head_count = %d, hd=x%x\n", str, head_count, hd);
		rt_bomb("nmg_ck_list() headless!\n");
	}
}




/*
 *			N M G _ C K _ L I S T _ M A G I C
 *
 *  rt_list doubly-linked list checker which checks the magic number for
 *	all elements in the linked list
 *  XXX Probably should be called bu_ck_list_magic().
 */
void
nmg_ck_list_magic( hd, str, magic )
CONST struct bu_list	*hd;
CONST char		*str;
CONST long		magic;
{
	register CONST struct bu_list	*cur;
	int	head_count = 0;

	cur = hd;
	do  {
		if( cur->magic == BU_LIST_HEAD_MAGIC )  {
			head_count++;
		} else if( cur->magic != magic ) {
			bu_log("nmg_ck_list(%s) cur magic=(%s)x%x, cur->forw magic=(%s)x%x, hd magic=(%s)x%x\n",
				str, bu_identify_magic(cur->magic), cur->magic,
				bu_identify_magic(cur->forw->magic), cur->forw->magic,
				bu_identify_magic(hd->magic), hd->magic);
			rt_bomb("nmg_ck_list_magic() cur->magic\n");
		}

		if( !cur->forw )  {
			bu_log("nmg_ck_list_magic(%s) cur=x%x, cur->forw=x%x, hd=x%x\n",
				str, cur, cur->forw, hd );
			rt_bomb("nmg_ck_list_magic() forw\n");
		}
		if( cur->forw->back != cur )  {
			bu_log("nmg_ck_list_magic(%s) cur=x%x, cur->forw=x%x, cur->forw->back=x%x, hd=x%x\n",
				str, cur, cur->forw, cur->forw->back, hd );
			bu_log(" cur=%s, cur->forw=%s, cur->forw->back=%s\n",
				bu_identify_magic(cur->magic),
				bu_identify_magic(cur->forw->magic),
				bu_identify_magic(cur->forw->back->magic) );
			rt_bomb("nmg_ck_list_magic() forw->back\n");
		}
		if( !cur->back )  {
			bu_log("nmg_ck_list_magic(%s) cur=x%x, cur->back=x%x, hd=x%x\n",
				str, cur, cur->back, hd );
			rt_bomb("nmg_ck_list_magic() back\n");
		}
		if( cur->back->forw != cur )  {
			bu_log("nmg_ck_list_magic(%s) cur=x%x, cur->back=x%x, cur->back->forw=x%x, hd=x%x\n",
				str, cur, cur->back, cur->back->forw, hd );
			rt_bomb("nmg_ck_list_magic() back->forw\n");
		}
		cur = cur->forw;
	} while( cur != hd );

	if( head_count != 1 )  {
		bu_log("nmg_ck_list_magic(%s) head_count = %d, hd=x%x\n", str, head_count, hd);
		rt_bomb("nmg_ck_list_magic() headless!\n");
	}
a1206 3



@


11.17
log
@Eliminated some unused variables
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_ck.c,v 11.16 1999/06/03 01:01:26 mike Exp $ (ARL)";
d55 1
a55 1
struct vertex_g *vg;
d67 2
a68 2
struct vertex *v;
struct vertexuse *vup;
d90 1
a90 1
long *vua;
d102 2
a103 2
struct vertexuse *vu;
long		*up_magic_p;
d133 1
a133 1
long *eg;
d174 2
a175 2
struct edge *e;
struct edgeuse *eup;
d177 1
a177 1
	struct edgeuse *eu;
d245 2
a246 2
struct bu_list	*hp;
long	*up_magic_p;
d377 1
a377 1
struct loop_g *lg;
d395 2
a396 2
struct loop *l;
struct loopuse *lup;
d426 2
a427 2
struct bu_list	*hp;
long		*up;
d488 1
a488 1
struct face_g_plane *fg;
d514 2
a515 2
struct face *f;
struct faceuse *fup;
d549 2
a550 2
struct bu_list	*hp;
struct shell *s;
d606 2
a607 2
struct bu_list	*hp;
struct nmgregion *r;
d675 2
a676 2
struct bu_list	*hp;
struct model *m;
d706 1
a706 1
struct model *m;
d724 3
a726 3
struct edgeuse *eu;
struct edge *e;
char *str;
d757 3
a759 3
long *parent;
struct vertexuse *vu;
char *str;
d777 3
a779 3
long *parent;
struct edgeuse *eu;
char *str;
d845 3
a847 3
struct loop *l;
struct loop_g *lg;
char *str;
d864 3
a866 3
struct loopuse *lu;
struct loop *l;
char *str;
d888 3
a890 3
long *parent;
struct loopuse *lu;
char *str;
d950 3
a952 3
struct face *f;
struct face_g_plane *fg;
char *str;
d974 3
a976 3
struct faceuse *fu;
struct face *f;
char *str;
d998 3
a1000 3
struct shell *s;
struct faceuse *fu;
char *str;
d1210 1
a1210 1
 *  Generic rt_list doubly-linked list checker.
d1212 1
a1212 1
 *  XXX Probably should be called rt_ck_list().
d1262 1
a1262 1
 *  XXX Probably should be called rt_ck_list_magic().
d1330 2
a1331 2
struct loopuse *cklu;
char *s;
@


11.16
log
@
sed4
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_ck.c,v 11.15 1998/09/14 15:59:17 bparker Exp $ (ARL)";
a1409 6
	char curr_orient;
	CONST struct edgeuse	*eu_orig;
	CONST struct edgeuse	*eur;
	CONST struct edgeuse	*eu1;
	CONST struct edgeuse	*eurstart;
	CONST struct faceuse	*fu;
a1410 1
	pointp_t p, q;
@


11.15
log
@*- fix typos
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_ck.c,v 11.14 1998/03/26 06:59:59 mike Exp $ (ARL)";
d204 2
a205 2
				rt_log("nmg_vedge() edgeuse mate does not have correct vertex\n");
				rt_log( "(eu=x%x, eu->vu_p->v_p=x%x, eu->eumate_p->vu_p->v_p=x%x)\n",
d207 1
a207 1
				rt_log( "(eup=x%x, eup->vu_p->v_p=x%x, eup->eumate_p->vu_p->v_p=x%x)\n",
d214 2
a215 2
				rt_log("nmg_vedge() edgeuse does not have correct vertex\n" );
				rt_log( "(eu=x%x, eu->vu_p->v_p=x%x, eu->eumate_p->vu_p->v_p=x%x)\n",
d217 1
a217 1
				rt_log( "(eup=x%x, eup->vu_p->v_p=x%x, eup->eumate_p->vu_p->v_p=x%x)\n",
d223 2
a224 2
			rt_log("nmg_vedge() edgeuse does not share vertex endpoint\n" );
			rt_log( "(eu=x%x, eu->vu_p->v_p=x%x, eu->eumate_p->vu_p->v_p=x%x)\n",
d226 1
a226 1
			rt_log( "(eup=x%x, eup->vu_p->v_p=x%x, eup->eumate_p->vu_p->v_p=x%x)\n",
d730 1
a730 1
	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_e error str");
d749 1
a749 1
	rt_free(errstr, "nmg_ck_e error str");
d763 1
a763 1
	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_vu error str");
d769 1
a769 1
	rt_free(errstr, "nmg_ck_vu error str");
d784 1
a784 1
	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_eu error str");
d837 1
a837 1
	rt_free(errstr, "nmg_ck_eu error str");
d850 1
a850 1
	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_lg error str");
d856 1
a856 1
	rt_free(errstr, "nmg_ck_lg error str");
d869 1
a869 1
	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_l error str");
d880 1
a880 1
	rt_free(errstr, "");
d899 1
a899 1
	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_lu error str");
d942 1
a942 1
	rt_free(errstr, "nmg_ck_lu error str");
d955 1
a955 1
	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_fg error str");
d966 1
a966 1
	rt_free(errstr, "nmg_ck_fg error str");
d979 1
a979 1
	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_f error str");
d990 1
a990 1
	rt_free(errstr, "nmg_ck_f error str");
d1010 1
a1010 1
	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_fu error str");
d1038 1
a1038 1
	rt_free(errstr, "nmg_ck_fu error str");
d1871 1
a1871 1
        st.visited = (char *)rt_calloc(m->maxindex+1, sizeof(char), "visited[]");
d1883 1
a1883 1
        rt_free( (char *)st.visited, "visited[]");
@


11.14
log
@EXTERN moved to raytrace.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 11.13 1997/08/29 17:22:37 jra Exp mike $ (ARL)";
d731 1
a731 1
	(void)sprintf(errstr, "%sedge %8x\n", str, e);
d764 1
a764 1
	(void)sprintf(errstr, "%svertexuse %8x\n", str, vu);
d785 1
a785 1
	(void)sprintf(errstr, "%sedgeuse %8x\n", str, eu);
d851 1
a851 1
	(void)sprintf(errstr, "%sloop_g %8x\n", str, lg);
d870 1
a870 1
	(void)sprintf(errstr, "%sloop %8x\n", str, l);
d900 1
a900 1
	(void)sprintf(errstr, "%sloopuse %8x\n", str, lu);
d935 1
a935 1
			(void)sprintf(&errstr[l], "%sedgeuse #%d (%8x)\n",
d956 1
a956 1
	(void)sprintf(errstr, "%sFace_g %8x\n", str, f);
d980 1
a980 1
	(void)sprintf(errstr, "%sFace %8x\n", str, f);
d1011 1
a1011 1
	(void)sprintf(errstr, "%sFaceuse %8x\n", str, fu);
d1034 1
a1034 1
		(void)sprintf(&errstr[l] , "%sloopuse #%d (%8x)\n", 
@


11.13
log
@Mod to get nmg_ck_v_in_fus() to skip TNURB faces.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 11.12 1997/06/04 15:15:36 jra Exp jra $ (ARL)";
a40 3
/* XXX Move to raytrace.h */
RT_EXTERN(void		nmg_ck_list_magic, (CONST struct bu_list *hd,
			CONST char *str, CONST long magic) );
@


11.12
log
@Added more output to nmg_vedge().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 11.11 1996/09/27 08:27:30 mike Exp jra $ (ARL)";
d1841 3
a1843 3
				NMG_GET_FU_PLANE( n, fu );
				dist = DIST_PT_PLANE( v->vg_p->coord , n );
				if( !NEAR_ZERO( dist , sp->tol->dist ) )
d1845 7
a1851 2
					bu_log( "ERROR - nmg_ck_vs_in_region: vertex x%x ( %g %g %g ) is %g from faceuse x%x\n" , 
						v , V3ARGS( v->vg_p->coord ) , dist , fu );
d1853 1
@


11.11
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 11.10 1996/08/27 03:01:36 mike Exp mike $ (ARL)";
d206 6
d213 1
d216 6
d223 1
d225 6
d232 1
@


11.10
log
@Eliminated confusing "else" statements after rt_bomb().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 11.9 1996/07/12 12:17:41 jra Exp mike $ (ARL)";
d42 1
a42 1
RT_EXTERN(void		nmg_ck_list_magic, (CONST struct rt_list *hd,
d78 1
a78 1
	for( RT_LIST_FOR( vu, vertexuse, &v->vu_hd ) )  {
d112 3
a114 3
		rt_log("nmg_vvu() up is %s, s/b %s\n",
			rt_identify_magic( *vu->up.magic_p ),
			rt_identify_magic( *up_magic_p ) );
d121 2
a122 2
	magic = RT_LIST_FIRST_MAGIC( &vu->l );
	if( magic != NMG_VERTEXUSE_MAGIC && magic != RT_LIST_HEAD_MAGIC )
d125 1
a125 1
	if (RT_LIST_PNEXT_PLAST(vertexuse,vu) != vu )
d138 1
a138 1
	struct rt_list	*eu2;
d155 1
a155 1
	for( RT_LIST_FOR( eu2, rt_list, &((struct edge_g_lseg *)eg)->eu_hd2 ) )  {
d162 1
a162 1
		eu = RT_LIST_MAIN_PTR( edgeuse, eu2, l2 );
d165 2
a166 2
		rt_log("eg=x%x, eu=x%x, eu->g=x%x\n", eg, eu, eu->g.magic_p);
		rt_log("nmg_veg() edgeuse is on wrong eu_hd2 list for eu->g\n");
d227 1
a227 1
struct rt_list	*hp;
d245 1
a245 1
	for( RT_LIST_FOR( eu, edgeuse, hp ) )  {
d253 2
a254 2
		eunext = RT_LIST_PNEXT_CIRC( edgeuse, eu );
		eulast = RT_LIST_PPREV_CIRC(edgeuse, &eu->l);
d263 1
a263 1
		if (RT_LIST_PPREV_CIRC(edgeuse,eunext) != eu )  {
d275 3
a277 3
		     	rt_log("eu=x%x, e=x%x\n", eu, eu->e_p );
		     	rt_log("eulast=x%x, e=x%x\n", eulast, eulast->e_p);
		     	rt_log("	    eu: (%g, %g, %g) <--> (%g, %g, %g)\n",
d280 1
a280 1
		     	rt_log("	eulast: (%g, %g, %g) <--> (%g, %g, %g)\n",
d283 1
a283 1
			rt_log("unshared vertex (mine) v=x%x: (%g, %g, %g)\n",
d286 1
a286 1
			rt_log("\t\t (last->eumate_p) v=x%x: (%g, %g, %g)\n",
d295 3
a297 3
		     	rt_log("eu=x%x, e=x%x\n", eu, eu->e_p );
		     	rt_log("eunext=x%x, e=x%x\n", eunext, eunext->e_p);
		     	rt_log("	    eu: (%g, %g, %g) <--> (%g, %g, %g)\n",
d300 1
a300 1
		     	rt_log("	eunext: (%g, %g, %g) <--> (%g, %g, %g)\n",
d303 1
a303 1
			rt_log("unshared vertex (mate) v=x%x: (%g, %g, %g)\n",
d306 1
a306 1
			rt_log("\t\t (next) v=x%x: (%g, %g, %g)\n",
d408 1
a408 1
struct rt_list	*hp;
d413 1
a413 1
	for( RT_LIST_FOR( lu, loopuse, hp ) )  {
d417 1
a417 1
			rt_log("nmg_vlu() up is x%x, s/b x%x\n",
d424 1
a424 1
		if (RT_LIST_PNEXT_PLAST(loopuse,lu) != lu )
d443 1
a443 1
			rt_log("lu=x%x, orientation=%d\n", lu, lu->orientation);
d454 1
a454 1
		if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC)
d456 2
a457 2
		else if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)
			nmg_vvu(RT_LIST_FIRST(vertexuse,&lu->down_hd), &lu->l.magic);
d478 1
a478 1
			rt_log("bad NMG plane equation %fX + %fY + %fZ = %f\n",
d515 1
a515 1
			rt_log("nmg_vface() face min_pt[%d]:%g greater than max_pt[%d]:%g\n",
d517 2
a518 2
			rt_log("min_pt(%g %g %g)  ", V3ARGS(f->min_pt));
			rt_log("max_pt(%g %g %g)\n", V3ARGS(f->max_pt));
d531 1
a531 1
struct rt_list	*hp;
d538 1
a538 1
	for( RT_LIST_FOR( fu, faceuse, hp ) )  {
d541 1
a541 1
			rt_log("faceuse claims shell parent (%8x) instead of (%8x)\n",
d548 1
a548 1
		} else if (fu->l.forw->back != (struct rt_list *)fu) {
d588 1
a588 1
struct rt_list	*hp;
d596 1
a596 1
	for( RT_LIST_FOR( s, shell, hp ) )  {
d599 1
a599 1
			rt_log("shell's r_p (%8x) doesn't point to parent (%8x)\n",
d606 2
a607 2
		} else if (s->l.forw->back != (struct rt_list *)s) {
			rt_log("forw shell's back(%8x) is not me (%8x)\n",
d621 2
a622 2
				rt_log("Bnmg_vshell() ad min_pt/max_pt for shell(%8x)'s extent\n");
				rt_log("Min_pt %g %g %g\n", lpt[0], lpt[1],
d624 1
a624 1
				rt_log("Max_pt %g %g %g\n", hpt[0], hpt[1],
d633 4
a636 4
			if( RT_LIST_NON_EMPTY( &s->fu_hd ) ||
			    RT_LIST_NON_EMPTY( &s->lu_hd ) ||
			    RT_LIST_NON_EMPTY( &s->eu_hd ) )  {
				rt_log("shell (%8x) with vertexuse (%8x) has other children\n",
d657 1
a657 1
struct rt_list	*hp;
d662 1
a662 1
	for( RT_LIST_FOR( r, nmgregion, hp ) )  {
d665 1
a665 1
			rt_log("nmgregion pointer m_p %8x should be %8x\n",
d675 1
a675 1
		if( RT_LIST_PNEXT_PLAST(nmgregion, r) != r )  {
d801 1
a801 1
		eu_next = RT_LIST_PNEXT_CIRC(edgeuse, eu);
d805 1
a805 1
		eu_last = RT_LIST_PLAST_CIRC(edgeuse, eu);
d908 1
a908 1
	magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
d910 1
a910 1
		vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d915 1
a915 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d998 1
a998 1
	if( RT_LIST_PNEXT_PLAST( faceuse, fu ) )
d1001 1
a1001 1
	if( RT_LIST_PLAST_PNEXT( faceuse, fu ) )
d1014 1
a1014 1
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d1035 1
a1035 1
CONST struct rt_tol *tol;
d1037 1
a1037 1
	struct rt_list *eu2;
d1042 1
a1042 1
	RT_CK_TOL( tol );
d1047 1
a1047 1
	for( RT_LIST_FOR( eu2 , rt_list , &eg->eu_hd2 ) )
d1055 1
a1055 1
		eu = RT_LIST_MAIN_PTR( edgeuse, eu2, l2 );
d1074 1
a1074 1
			rt_log( "vertex ( %g %g %g ) on eu to ( %g %g %g )\n", V3ARGS( vg1->coord ),
d1076 1
a1076 1
			rt_log( "\tnot on edge geometry: pt=( %g %g %g ), dir=( %g %g %g )\n",
d1094 1
a1094 1
CONST struct rt_tol *tol;
d1096 1
a1096 1
	struct nmg_ptbl g_tbl;
d1101 1
a1101 1
	RT_CK_TOL( tol );
d1103 1
a1103 1
	nmg_tbl( &g_tbl , TBL_INIT , (long *)NULL );
d1107 1
a1107 1
	for( i=0 ; i<NMG_TBL_END( &g_tbl ) ; i++ )
d1112 1
a1112 1
		ep = NMG_TBL_GET( &g_tbl , i );
d1126 1
a1126 1
	nmg_tbl( &g_tbl , TBL_RST , (long *)NULL );
d1130 1
a1130 1
	for( i=0 ; i<NMG_TBL_END( &g_tbl ) ; i++ )
d1134 1
a1134 1
		f = (struct face *)NMG_TBL_GET( &g_tbl , i );
d1140 1
a1140 1
	nmg_tbl( &g_tbl , TBL_FREE , (long *)NULL );
d1161 1
a1161 1
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d1165 1
a1165 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
d1167 1
a1167 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d1169 1
a1169 1
			neu = RT_LIST_PNEXT_CIRC( edgeuse, eu );
d1179 2
a1180 2
				rt_log("eu=x%x, neu=x%x, v=x%x\n", eu, neu, eu->vu_p->v_p);
				rt_log("eu=x%x, neu=x%x, v=x%x\n", eu->eumate_p, neu->eumate_p, eu->eumate_p->vu_p->v_p);
d1198 1
a1198 1
struct rt_list		*hd;
d1201 1
a1201 1
	register struct rt_list	*cur;
d1206 1
a1206 1
		if( cur->magic == RT_LIST_HEAD_MAGIC )  head_count++;
d1208 1
a1208 1
			rt_log("nmg_ck_list(%s) cur=x%x, cur->forw=x%x, hd=x%x\n",
d1213 1
a1213 1
			rt_log("nmg_ck_list(%s) cur=x%x, cur->forw=x%x, cur->forw->back=x%x, hd=x%x\n",
d1218 1
a1218 1
			rt_log("nmg_ck_list(%s) cur=x%x, cur->back=x%x, hd=x%x\n",
d1223 1
a1223 1
			rt_log("nmg_ck_list(%s) cur=x%x, cur->back=x%x, cur->back->forw=x%x, hd=x%x\n",
d1231 1
a1231 1
		rt_log("nmg_ck_list(%s) head_count = %d, hd=x%x\n", str, head_count, hd);
d1248 1
a1248 1
CONST struct rt_list	*hd;
d1252 1
a1252 1
	register CONST struct rt_list	*cur;
d1257 1
a1257 1
		if( cur->magic == RT_LIST_HEAD_MAGIC )  {
d1260 4
a1263 4
			rt_log("nmg_ck_list(%s) cur magic=(%s)x%x, cur->forw magic=(%s)x%x, hd magic=(%s)x%x\n",
				str, rt_identify_magic(cur->magic), cur->magic,
				rt_identify_magic(cur->forw->magic), cur->forw->magic,
				rt_identify_magic(hd->magic), hd->magic);
d1268 1
a1268 1
			rt_log("nmg_ck_list_magic(%s) cur=x%x, cur->forw=x%x, hd=x%x\n",
d1273 1
a1273 1
			rt_log("nmg_ck_list_magic(%s) cur=x%x, cur->forw=x%x, cur->forw->back=x%x, hd=x%x\n",
d1275 4
a1278 4
			rt_log(" cur=%s, cur->forw=%s, cur->forw->back=%s\n",
				rt_identify_magic(cur->magic),
				rt_identify_magic(cur->forw->magic),
				rt_identify_magic(cur->forw->back->magic) );
d1282 1
a1282 1
			rt_log("nmg_ck_list_magic(%s) cur=x%x, cur->back=x%x, hd=x%x\n",
d1287 1
a1287 1
			rt_log("nmg_ck_list_magic(%s) cur=x%x, cur->back=x%x, cur->back->forw=x%x, hd=x%x\n",
d1295 1
a1295 1
		rt_log("nmg_ck_list_magic(%s) head_count = %d, hd=x%x\n", str, head_count, hd);
d1317 1
a1317 1
	if (RT_LIST_FIRST_MAGIC(&cklu->down_hd) == NMG_VERTEXUSE_MAGIC)
d1320 1
a1320 1
	eu = RT_LIST_FIRST(edgeuse, &cklu->down_hd);
d1325 1
a1325 1
	for (RT_LIST_FOR(eu, edgeuse, &cklu->down_hd)) {
d1328 1
a1328 1
			rt_log("nmg_cl_lueu() edgeuse of %s (going next) has lost proper parent\n", s);
d1332 1
a1332 1
			rt_log("nmg_cl_lueu() %s next edge (%8x) doesn't point back to me (%8x)!\n", s, eu->l.forw, eu);
d1336 1
a1336 1
			rt_log("nmg_cl_lueu() %s last edge (%8x) doesn't point forward to me (%8x)!\n", s, eu->l.forw, eu);
d1343 1
a1343 1
	eu = RT_LIST_FIRST(edgeuse, &cklu->down_hd);
d1348 1
a1348 1
	for (RT_LIST_FOR(eu, edgeuse, &cklu->down_hd)) {
d1351 1
a1351 1
			rt_log("nmg_cl_lueu() edgeuse of %s (lumate going next) has lost proper parent\n", s);
d1355 1
a1355 1
			rt_log("nmg_cl_lueu() %s next edge (%8x) doesn't point back to me (%8x)!\n", s, eu->l.forw, eu);
d1359 1
a1359 1
			rt_log("nmg_cl_lueu() %s (lumate) back edge (%8x) doesn't point forward to me (%8x)!\n", s, eu->l.forw, eu);
d1390 1
a1390 1
CONST struct rt_tol	*tol;
d1402 1
a1402 1
	RT_CK_TOL(tol);
d1411 1
a1411 1
		rt_log("nmg_check_radial(eu=x%x, tol)\n", eu);
d1471 1
a1471 1
			rt_log("nmg_check_radial(): Radial orientation problem\n  edge: %g %g %g -> %g %g %g\n",
d1473 1
a1473 1
			rt_log("  eu_orig=%8x, eur=%8x, s=x%x, eurstart=x%x, curr_orient=%s\n",
d1493 1
a1493 1
			rt_log("nmg_check_radial: unclosed space\n");
d1529 1
a1529 1
CONST struct rt_tol	*tol;
d1543 1
a1543 1
	RT_CK_TOL(tol);
d1607 1
a1607 1
			rt_log("nmg_eu_2s_orient_bad(eu=x%x, s1=x%x, s2=x%x) bad radial parity eu1=x%x, eur=x%x, eurstart=x%x\n",
d1624 1
a1624 1
		rt_log("nmg_eu_2s_orient_bad(eu=x%x, s1=x%x, s2=x%x) ret=%d\n",
d1644 1
a1644 1
CONST struct rt_tol	*tol;
d1653 2
a1654 2
	RT_CK_TOL(tol);
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
d1656 1
a1656 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d1658 1
a1658 1
			magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
d1661 1
a1661 1
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d1666 1
a1666 1
					rt_log("nmg_ck_closed_surf(x%x), problem with loopuse x%x\n", s, lu);
d1671 1
a1671 1
				vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d1692 1
a1692 1
CONST struct rt_tol	*tol;
d1698 2
a1699 2
	RT_CK_TOL(tol);
	for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
d1722 1
a1722 1
CONST struct rt_tol *tol;
d1724 1
a1724 1
	struct rt_vls str;
d1734 1
a1734 1
	RT_CK_TOL( tol );
d1737 1
a1737 1
	for( RT_LIST_FOR( vu , vertexuse , &vp->vu_hd ) )
d1750 2
a1751 2
		rt_vls_init( &str );
		rt_vls_printf( &str , "nmg_ck_v_in_2fus: vertex x%x not used in" , vp );
d1753 1
a1753 1
			rt_vls_printf( &str , " faceuse x%x" , fu1 );
d1755 2
a1756 2
			rt_vls_printf( &str , " faceuse x%x" , fu2 );
		rt_bomb( rt_vls_addr( &str ) );
d1767 2
a1768 2
		rt_vls_init( &str );
		rt_vls_printf( &str , "nmg_ck_v_in_2fus: vertex x%x ( %g %g %g ) not in plane of" ,
d1771 1
a1771 1
			rt_vls_printf( &str , " faceuse x%x (off by %g)" , fu1 , dist1 );
d1773 2
a1774 2
			rt_vls_printf( &str , " faceuse x%x (off by %g)" , fu2 , dist2 );
		rt_bomb( rt_vls_addr( &str ) );
d1788 2
a1789 2
        struct nmg_ptbl *tabl;
	struct rt_tol	*tol;
d1808 1
a1808 1
		for( RT_LIST_FOR( vu , vertexuse , &v->vu_hd ) )
d1824 1
a1824 1
					rt_log( "ERROR - nmg_ck_vs_in_region: vertex x%x ( %g %g %g ) is %g from faceuse x%x\n" , 
d1835 1
a1835 1
CONST struct rt_tol *tol;
d1840 1
a1840 1
	struct nmg_ptbl			tab;
d1843 1
a1843 1
	RT_CK_TOL( tol );
d1849 1
a1849 1
	st.tol = (struct rt_tol *)tol;
d1851 1
a1851 1
        (void)nmg_tbl( &tab, TBL_INIT, 0 );
d1857 1
a1857 1
	nmg_tbl( &tab , TBL_FREE , 0 );
@


11.9
log
@Minor Mods for IRIX 6.2
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 11.8 1995/12/02 03:19:51 mike Exp jra $ (ARL)";
d266 1
a266 2
		    else
			rt_bomb("nmg_veu() next edgeuse has NULL back\n");
d317 1
a317 1
		else if (eu->eumate_p->eumate_p != eu)
d322 1
a322 1
		else if (eu->radial_p->radial_p != eu)
d424 1
a424 1
		else if (RT_LIST_PNEXT_PLAST(loopuse,lu) != lu )
d452 1
a452 3
		else {
			nmg_vloop(lu->l_p, lu);
		}
d798 1
a798 1
		else if (eur == eu) rt_bomb(
@


11.8
log
@Extra error check
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 11.7 95/03/03 23:40:33 mike Exp $ (ARL)";
d1412 1
a1412 1
#endif
d1507 1
@


11.7
log
@Just use the new checker.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 11.6 95/02/25 01:58:10 mike Exp Locker: mike $ (ARL)";
d157 5
@


11.6
log
@Turned off dangling face checking in nmg_check_radial().
Also improved error messages
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 11.5 95/02/23 06:08:03 mike Exp Locker: mike $ (ARL)";
d1404 4
@


11.5
log
@Oops, left an rt_bomb() in.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 11.4 95/02/23 05:57:38 mike Exp Locker: mike $ (ARL)";
d1376 4
d1413 5
a1417 2
		nmg_find_s_of_eu((struct edgeuse *)eu) != s ||
		nmg_dangling_face( fu, (char *)NULL ) )  {
d1434 4
a1437 2
		       (fu = nmg_find_fu_of_eu(eur)) == (struct faceuse *)NULL ||
			nmg_dangling_face( fu, (char *)NULL )
d1459 3
a1461 1
		    	char buf[80];
d1465 1
a1465 1
			rt_log("nmg_check_radial(): Radial orientation problem at edge %g %g %g -> %g %g %g\n",
d1467 1
a1467 1
			rt_log("Problem Edgeuses: eu_orig=%8x, eur=%8x, s=x%x, eurstart=x%x, curr_orient=%s\n",
d1478 1
a1478 1
		    	sprintf(buf, "Orientation problem %g %g %g -> %g %g %g\n",
d1480 3
a1482 2

		    	nmg_stash_model_to_file("radial.g", 
@


11.4
log
@Added nmg_eu_2s_orient_bad(), clarified nmg_check_radial().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 11.3 95/02/13 16:50:22 jra Exp Locker: mike $ (ARL)";
a1475 1
rt_bomb("aborting");
@


11.3
log
@Added code to skip dangling faces in nmg_check_radial.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 11.2 95/01/31 04:22:18 mike Exp Locker: jra $ (ARL)";
d1368 1
d1370 4
d1387 1
d1404 1
d1409 1
d1418 1
a1419 7
	/* skip the wire edges and dangling faces in the radial direction from eu. */
	while( (fu = nmg_find_fu_of_eu(eur)) == (struct faceuse *)NULL ||
		nmg_dangling_face( fu, (char *)NULL ) )  {
		eur = eur->eumate_p->radial_p;
		if( eur == eurstart )  return 0;
	}

a1432 6
				p = eur->vu_p->v_p->vg_p->coord;
				q = eur->eumate_p->vu_p->v_p->vg_p->coord;
				rt_log("edgeuse mate has different mate %g %g %g -> %g %g %g\n",
					p[0], p[1], p[2], q[0], q[1], q[2]);
				nmg_pr_lu(eu->up.lu_p, (char *)NULL);
				nmg_pr_lu(eu->eumate_p->up.lu_p, (char *)NULL);
a1433 1
				/*return(1);*/
a1437 5

			/* Can't check faceuse orientation parity for
			 * things from another shell;  parity is conserved
			 * only within faces from a single shell.
			 */
d1456 3
a1458 1
			rt_log("Problem Edgeuses: eu1=%8x, eur=%8x\n", eu1, eur);
d1473 1
a1473 1
			nmg_pr_fu_around_eu( eu1, tol );
d1476 1
d1487 123
@


11.2
log
@Improved debugging prints.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 11.1 95/01/04 09:57:24 mike Rel4_4 Locker: mike $ (ARL)";
d1369 1
a1369 2
 *  XXX Note that this routine will not work properly if there are
 *  XXX dangling faces present.  It will report an erroneous error.
d1400 3
a1402 2
	/* If this eu is a wire, advance to first non-wire. */
	while( (fu = nmg_find_fu_of_eu(eu)) == (struct faceuse *)NULL )  {
d1411 3
a1413 2
	/* skip the wire edges in the radial direction from eu. */
	while( (fu = nmg_find_fu_of_eu(eur)) == (struct faceuse *)NULL )  {
d1422 1
a1422 1
		 *  Continue search if it is a wire edge.
d1425 2
a1426 1
		       (fu = nmg_find_fu_of_eu(eur)) == (struct faceuse *)NULL
@


11.1
log
@Release_4.4
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.55 94/12/05 16:10:05 mike Exp $ (ARL)";
d233 7
d266 1
a266 1
		 *  Ensure that vertices are shared.
d269 1
a269 1
		if ( up_magic != NMG_SHELL_MAGIC &&
d271 8
d285 2
d289 1
a289 1
		if ( up_magic != NMG_SHELL_MAGIC &&
d291 8
d305 2
@


10.55
log
@Don't verify edge geometry if it isn't there!
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.54 94/11/28 13:27:39 jra Exp Locker: mike $ (ARL)";
@


10.54
log
@Added nmg_ck_geometry and nmg_ck_eg_verts.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_ck.c,v 10.53 94/11/18 16:18:22 jra Exp Locker: jra $ (ARL)";
d305 1
a305 1
			nmg_veg(eu->g.magic_p);
@


10.53
log
@Modified nmg_veu to not complain about edgeuses to/from same vertex.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.52 94/11/17 16:58:47 jra Exp Locker: jra $ (ARL)";
d992 122
@


10.52
log
@changed bombs to warnings for esgeuse with no geometry.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.51 94/11/05 00:27:35 mike Exp Locker: jra $ (ARL)";
d296 1
a296 1
		if( eu->g.magic_p )
a306 2
		else
			rt_log( "Warning: nmg_veu() edgeuse has no geometry\n" );
@


10.51
log
@Irix 6
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.50 94/10/12 03:35:28 butler Exp Locker: mike $ (ARL)";
d296 6
a301 4
		if( !eu->l2.forw )
			rt_bomb("nmg_veu() l2.forw is NULL\n");
		if( !eu->l2.back )
			rt_bomb("nmg_veu() l2.back is NULL\n");
d303 6
a308 3
		if( eu->g.magic_p != eu->eumate_p->g.magic_p )
			rt_bomb("nmg_veu() edgeuse and mate don't share geometry\n");
		if (eu->g.magic_p) nmg_veg(eu->g.magic_p);
@


10.50
log
@made the output of nmg_vface() a little more verbose, and therefore actually
informational.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.49 1994/10/04 17:46:26 jra Exp butler $ (ARL)";
a345 1
	struct loopuse *lu;
d353 2
d361 1
a466 1
	struct faceuse *fu;
a1008 1
		struct vertexuse *vu2;
a1099 1
	int	in_head;
a1102 1
		in_head = 0;
a1104 1
			in_head = 1;
@


10.49
log
@Modified nmg_vfg to use NMG_CK_FACE_G_EITHER.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_ck.c,v 10.48 94/09/23 20:06:10 mike Exp Locker: jra $ (ARL)";
d481 7
a487 3
		if (f->min_pt[i] >= f->max_pt[i])
			rt_bomb("nmg_vface() face min_pt greater than max_pt\n");
	
@


10.48
log
@Lee wrote nmg_ck_list_magic().
nmg_veg() expanded to cross-check geometry pointers on eu_hd2 list.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_ck.c,v 10.47 94/09/23 16:32:09 mike Exp Locker: butler $ (ARL)";
d438 1
a438 1
	NMG_CK_FACE_G_PLANE(fg);
d440 12
a451 5
	if (fg->N[X]==0.0 && fg->N[Y]==0.0 && fg->N[Z]==0.0 &&
	    fg->N[H]!=0.0) {
		rt_log("bad NMG plane equation %fX + %fY + %fZ = %f\n",
			fg->N[X], fg->N[Y], fg->N[Z], fg->N[H]);
		rt_bomb("nmg_vfg() Bad NMG geometry\n");
@


10.47
log
@Added checking.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.46 94/09/21 03:50:03 mike Exp Locker: mike $ (ARL)";
d41 4
d138 2
d143 3
a145 1
		nmg_ck_list( &((struct edge_g_lseg *)eg)->eu_hd2, "nmg_veg() edge_g_lseg eu_hd2 list" );
d148 3
a150 1
		nmg_ck_list( &((struct edge_g_cnurb *)eg)->eu_hd2, "nmg_veg() edge_g_cnurb eu_hd2 list" );
d153 10
d230 1
a230 1
	nmg_ck_list( hp, "nmg_veu() edegeuse list head" );
d1050 1
a1050 1
			rt_bomb("nmg_ck_list() forw\n");
d1060 1
a1060 1
			rt_bomb("nmg_ck_list() back\n");
d1070 72
@


10.46
log
@Eliminated model_a structure
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.45 94/09/21 03:11:31 mike Exp Locker: mike $ (ARL)";
d134 1
a134 1
	if( !eg )  rt_bomb("nmg_veg() null eg\n");
d137 2
a138 1
		return;
d140 2
a141 1
		return;
a142 1
	rt_bomb("nmg_veg() bad magic\n");
d210 2
d275 5
@


10.45
log
@Added support for vertexuse attributes of either type 
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.44 94/09/12 22:29:52 mike Exp Locker: mike $ (ARL)";
a618 3
	if (m->ma_p) {
		NMG_CK_MODEL_A(m->ma_p);
	}
@


10.44
log
@Made nmg_ck_list() more robust in the face of null pointers.
Added extre printing too.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.43 94/09/10 04:36:31 mike Exp Locker: mike $ (ARL)";
d89 1
a89 1
struct vertexuse_a_plane *vua;
d91 1
a91 1
	NMG_CK_VERTEXUSE_A_PLANE(vua);
d126 1
a126 1
	if (vu->a.plane_p) nmg_vvua(vu->a.plane_p);
@


10.43
log
@Converted NMG data structures to have edge_g pointer in edgeuse, not edge.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.42 94/09/03 03:01:18 mike Exp $ (ARL)";
d1003 2
d1017 5
d1023 2
a1024 2
			rt_log("nmg_ck_list(%s) cur=x%x, cur->forw=x%x, cur->forw->back=x%x\n",
				str, cur, cur->forw, cur->forw->back );
d1027 5
d1033 2
a1034 2
			rt_log("nmg_ck_list(%s) cur=x%x, cur->back=x%x, cur->back->forw=x%x\n",
				str, cur, cur->back, cur->back->forw );
d1041 1
a1041 1
		rt_log("nmg_ck_list(%s) head_count = %d\n", str, head_count);
@


10.42
log
@Snapshot of non-working intermediate stage in edge_g evolution.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.41 94/09/02 19:07:54 mike Exp Locker: mike $ (ARL)";
a191 2

	if (e->eg_p) nmg_veg(e->eg_p);
d272 4
@


10.41
log
@vertexuse_a is now vertexuse_a_plane and vertexuse_a_cnurb
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.40 94/09/02 17:58:32 mike Exp Locker: mike $ (ARL)";
d132 1
a132 1
struct edge_g *eg;
d134 8
a141 1
	NMG_CK_EDGE_G(eg);
@


10.40
log
@faceuse_a, loopuse_a, and edgeuse_a have been eliminated.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.39 94/09/02 00:31:23 mike Exp Locker: mike $ (ARL)";
d89 1
a89 1
struct vertexuse_a *vua;
d91 1
a91 1
	NMG_CK_VERTEXUSE_A(vua);
d126 1
a126 1
	if (vu->vua_p) nmg_vvua(vu->vua_p);
@


10.39
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.38 94/08/10 18:47:50 gdurf Exp Locker: mike $ (ARL)";
a128 8
/* Verify edgeuse attributes */
void
nmg_veua(eua)
struct edgeuse_a *eua;
{
	NMG_CK_EDGEUSE_A(eua);
}

a267 2
		if (eu->eua_p) nmg_veua(eu->eua_p);

a327 8
/* Verify loop attributes */
void
nmg_vlua(lua)
struct loopuse_a *lua;
{
	NMG_CK_LOOPUSE_A(lua);
}

a382 2
		if (lu->lua_p) nmg_vlua(lu->lua_p);

a442 8
/* Verify faceuse attributes */
void
nmg_vfua(fua)
struct faceuse_a *fua;
{
	NMG_CK_FACEUSE_A(fua);
}

a491 2
		if (fu->fua_p) nmg_vfua(fu->fua_p);
		
@


10.38
log
@Factored ifdefs
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.37 1994/08/09 19:37:20 mike Exp gdurf $ (ARL)";
d419 1
a419 1
struct face_g *fg;
d421 1
a421 1
	NMG_CK_FACE_G(fg);
d460 1
a460 1
	if (f->fg_p) nmg_vfg(f->fg_p);
d885 1
a885 1
struct face_g *fg;
d892 1
a892 1
	NMG_CK_FACE_G(fg);
d918 1
a918 1
	NMG_CK_FACE_G(f->fg_p);
d922 1
a922 1
	if (f->fg_p) nmg_ck_fg(f, f->fg_p, errstr);
@


10.37
log
@Added GDurf's new "conf.h"
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.36 94/05/06 02:23:54 mike Exp Locker: mike $ (ARL)";
d30 3
a32 1
#ifdef BSD
a33 2
#else
#include <string.h>
@


10.36
log
@Fixed nmg_ck_list.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.35 94/04/25 00:36:52 butler Exp Locker: mike $ (ARL)";
d28 1
@


10.35
log
@fixed typos in nmg_check_radials()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.34 94/04/25 00:30:43 butler Exp Locker: butler $ (ARL)";
d1049 1
a1049 1
		rt_log("nmg_ck_list(%s) head_count = %d\n", head_count);
@


10.34
log
@added call to nmg_stash_model_to_file() when unclosed space is detected
in nmg_check_radial()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.33 94/03/02 12:55:12 jra Exp Locker: butler $ (ARL)";
d1224 1
a1224 1
		    	sprintf(buf, "Orientation problem %g %g %g -> %g %g %g\n"
d1227 2
a1228 1
		    	nmg_stash_model_to_file("radial.g", m, buf);
@


10.33
log
@Added NMG_CK_EDGEUSE( e->eu_p ) to nmg_vedge.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.32 94/01/25 15:13:33 mike Exp Locker: jra $ (ARL)";
d1209 2
d1223 5
@


10.32
log
@Upgraded nmg_check_radial() to handle wire edgeuses.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.31 94/01/25 09:43:28 mike Exp Locker: mike $ (ARL)";
d166 2
@


10.31
log
@Added handling of wire edgeuses to nmg_check_radial().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.30 94/01/25 08:33:07 mike Exp Locker: mike $ (ARL)";
d1144 4
d1158 1
d1163 1
a1165 2
	eurstart = eur;

d1189 1
a1230 5
		/* Skip wires */
		while( nmg_find_fu_of_eu(eur) == (struct faceuse *)NULL )  {
			eur = eur->eumate_p->radial_p;
		}

@


10.30
log
@Moved nmg_pr_fu_around_eu() et.al. from nmg_ck.c to nmg_pr.c
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.29 94/01/23 05:29:53 mike Exp Locker: mike $ (ARL)";
d1135 1
d1141 1
a1141 4

	NMG_CK_LOOPUSE(eu->up.lu_p);
	NMG_CK_FACEUSE(eu->up.lu_p->up.fu_p);
	s = eu->up.lu_p->up.fu_p->s_p;
d1144 9
a1152 1
	curr_orient = eu->up.lu_p->up.fu_p->orientation;
d1155 2
a1156 2
	/* skip the wire edges */
	while (*eur->up.magic_p == NMG_SHELL_MAGIC) {
a1161 1
	eu1 = eu;
d1169 1
a1169 1
			*eur->up.magic_p == NMG_SHELL_MAGIC
d1171 1
d1198 3
a1200 2
		NMG_CK_FACEUSE(eur->up.lu_p->up.fu_p);
		if (eur->up.lu_p->up.fu_p->orientation != curr_orient &&
d1226 2
a1227 1
		while (*eur->up.magic_p == NMG_SHELL_MAGIC) {
@


10.29
log
@Broke out nmg_pr_one_eu_vecs()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.28 94/01/13 23:05:59 mike Exp Locker: mike $ (ARL)";
a1109 121
}

/* 
 *			N M G _ P R _ O N E _ E U _ V E C S
 *
 *  Common formatting code for edgeuses and edgeuse mates.
 *  Does not mind wire edges.
 */
nmg_pr_one_eu_vecs( eu, xvec, yvec, zvec, tol )
CONST struct edgeuse	*eu;
CONST vect_t		xvec;
CONST vect_t		yvec;
CONST vect_t		zvec;
CONST struct rt_tol	*tol;
{
	CONST struct loopuse	*lu;
	CONST struct faceuse	*fu;
	CONST struct face	*f;
	CONST struct shell	*s;
	char			*lu_orient;
	char			*fu_orient;

	NMG_CK_EDGEUSE(eu);
	lu = (struct loopuse *)NULL;
	lu_orient = "X";
	fu = (struct faceuse *)NULL;
	fu_orient = "X";
	f = (struct face *)NULL;
	if( *eu->up.magic_p == NMG_LOOPUSE_MAGIC )  {
		lu = eu->up.lu_p;
		NMG_CK_LOOPUSE(lu);
		lu_orient = lu->orientation == OT_SAME ? "S" : "O";
		if( *lu->up.magic_p == NMG_FACEUSE_MAGIC )  {
			fu = lu->up.fu_p;
			NMG_CK_FACEUSE(fu);
			fu_orient = fu->orientation == OT_SAME ? "S" : "O";
			f = fu->f_p;
			s = fu->s_p;
		} else {
			s = lu->up.s_p;
		}
	} else {
		s = eu->up.s_p;
	}
	NMG_CK_SHELL(s);
	rt_log(" %8.8x, lu=%8.8x=%s, f=%8.8x, fu=%8.8x=%s, s=%8.8x %g deg\n",
		eu,
		lu, lu_orient,
		f,
		fu, fu_orient,
		s,
		nmg_measure_fu_angle(eu, xvec, yvec, zvec) * rt_radtodeg );
}

/*
 *			N M G _ P R _ F U _ A R O U N D _ E U _ V E C S
 */
void
nmg_pr_fu_around_eu_vecs( eu, xvec, yvec, zvec, tol )
CONST struct edgeuse	*eu;
CONST vect_t		xvec;
CONST vect_t		yvec;
CONST vect_t		zvec;
CONST struct rt_tol	*tol;
{
	CONST struct edgeuse	*eu1;
	CONST struct loopuse	*lu;
	CONST struct faceuse	*fu;
	CONST struct face	*f;
	int			lu_orient;
	int			fu_orient;

	NMG_CK_EDGEUSE(eu);
	RT_CK_TOL(tol);
	rt_log("nmg_pr_fu_around_eu_vecs(eu=x%x) e=x%x\n", eu, eu->e_p);

	/* To go correct way around, start with arg's mate,
	 * so that arg, then radial, will follow.
	 */
	eu = eu->eumate_p;

	eu1 = eu;
	do {
		/* First, the edgeuse mate */
		nmg_pr_one_eu_vecs( eu1, xvec, yvec, zvec, tol );

		/* Second, the edgeuse itself (mate's mate) */
		eu1 = eu1->eumate_p;
		nmg_pr_one_eu_vecs( eu1, xvec, yvec, zvec, tol );

		/* Now back around to the radial edgeuse */
		eu1 = eu1->radial_p;
	} while( eu1 != eu );
}

/*
 *			N M G _ P R _ F U _ A R O U N D _ E U
 *
 *  A debugging routine to print all the faceuses around a given edge,
 *  starting with the given edgeuse.
 *  The normal of the  first face is considered to be "0 degrees",
 *  and the rest are measured from there.
 */
void
nmg_pr_fu_around_eu( eu, tol )
CONST struct edgeuse *eu;
CONST struct rt_tol	*tol;
{
	CONST struct edgeuse	*eu1;
	CONST struct loopuse	*lu;
	CONST struct faceuse	*fu;
	vect_t			xvec, yvec, zvec;

	NMG_CK_EDGEUSE(eu);
	RT_CK_TOL(tol);
	rt_log("nmg_pr_fu_around_eu(x%x)\n", eu);

	/* Erect coordinate system around eu */
	nmg_eu_2vecs_perp( xvec, yvec, zvec, eu, tol );

	nmg_pr_fu_around_eu_vecs( eu, xvec, yvec, zvec, tol );
@


10.28
log
@Fixed nmg_check_radial() to ignore wire edges.
It still has a problem with dangling faces.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.27 93/12/27 22:44:54 mike Exp Locker: mike $ (ARL)";
d1112 52
d1178 3
d1194 1
a1194 12
		NMG_CK_EDGEUSE(eu1);
		lu = eu1->up.lu_p;
		NMG_CK_LOOPUSE(lu);
		fu = lu->up.fu_p;
		NMG_CK_FACEUSE(fu);
		rt_log(" %8.8x, lu=%8.8x=%s, f=%8.8x, fu=%8.8x=%s, s=%8.8x %g deg\n",
			eu1,
			lu, lu->orientation == OT_SAME ? "S" : "O",
			fu->f_p,
			fu, fu->orientation == OT_SAME ? "SAME" : "OPP.",
			fu->s_p,
			nmg_measure_fu_angle(eu1, xvec, yvec, zvec) * rt_radtodeg );
d1198 1
a1198 12
		NMG_CK_EDGEUSE(eu1);
		lu = eu1->up.lu_p;
		NMG_CK_LOOPUSE(lu);
		fu = lu->up.fu_p;
		NMG_CK_FACEUSE(fu);
		rt_log(" %8.8x, lu=%8.8x=%s, f=%8.8x, fu=%8.8x=%s, s=%8.8x %g deg\n",
			eu1,
			lu, lu->orientation == OT_SAME ? "S" : "O",
			fu->f_p,
			fu, fu->orientation == OT_SAME ? "SAME" : "OPP.",
			fu->s_p,
			nmg_measure_fu_angle(eu1, xvec, yvec, zvec) * rt_radtodeg );
@


10.27
log
@Moved bounding box for faces from struct face_g to struct face.
Necessary because face geometry is now shared by multiple faces
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.26 93/12/24 00:43:57 mike Exp Locker: mike $ (ARL)";
d1206 3
d1229 2
d1247 3
a1249 7

		NMG_CK_LOOPUSE(eu1->up.lu_p);
		NMG_CK_FACEUSE(eu1->up.lu_p->up.fu_p);

		NMG_CK_LOOPUSE(eur->up.lu_p);
		NMG_CK_FACEUSE(eur->up.lu_p->up.fu_p);
		/* go find a radial edgeuse of the same shell
d1251 3
a1253 1
		while (eur->up.lu_p->up.fu_p->s_p != s) {
a1266 2
			NMG_CK_LOOPUSE(eur->up.lu_p);
			NMG_CK_FACEUSE(eur->up.lu_p->up.fu_p);
d1279 2
d1285 1
a1285 1
			rt_log("Radial orientation problem at edge %g %g %g -> %g %g %g\n",
a1297 5
			eur= nmg_findeu( eu1->vu_p->v_p, eu1->eumate_p->vu_p->v_p,
				(struct shell *)0,  eu1, 0 );
			if( eur )  {
				rt_log("nmg_findeu found another eu=x%x\n", eur);
			}
d1303 2
@


10.26
log
@Reduced some of the excess printing.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.25 93/12/22 06:07:40 mike Exp Locker: mike $ (ARL)";
a39 3
/* XXX move to raytrace.h This duplicates the extern from nmg_mesh.c */
RT_EXTERN(double nmg_measure_fu_angle, (CONST struct edgeuse *eu, CONST vect_t xvec, CONST vect_t yvec, CONST vect_t zvec));

a417 2
	int i;

a419 4
	for (i=0 ; i < ELEMENTS_PER_PT ; ++i)
		if (fg->min_pt[i] > fg->max_pt[i])
			rt_bomb("nmg_vfg() face geom min_pt greater than max_pt\n");

d439 1
d452 4
@


10.25
log
@Improved usefulness of nmg_pr_fu_around_eu_vecs() output by
eliminating useless edge pointer, and adding loopuse pointer.
Also associated orientations with their pointers.

@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.24 93/12/03 03:34:33 mike Exp Locker: mike $ (ARL)";
a1287 1
rt_pr_tol(tol);
d1289 14
a1302 5
			if (rt_g.NMG_debug) {
				nmg_pr_fu_around_eu(eu1, tol);
				nmg_pr_fu(eu1->up.lu_p->up.fu_p, 0);
				rt_log("Radial loop:\n");
				nmg_pr_fu(eur->up.lu_p->up.fu_p, 0);
a1304 15
			{
				/* Plot the edge in yellow, & the loops */
				rt_g.NMG_debug |= DEBUG_PLOTEM;
				nmg_face_lu_plot( eu1->up.lu_p, eu1->vu_p,
					eu1->eumate_p->vu_p );
				nmg_face_lu_plot( eur->up.lu_p, eur->vu_p,
					eur->eumate_p->vu_p );
				nmg_pr_fu_around_eu( eu1, tol );
				eur= nmg_findeu( eu1->vu_p->v_p, eu1->eumate_p->vu_p->v_p,
					(struct shell *)0,  eu1, 0 );
				if( eur )  {
					rt_log("nmg_findeu found another eu\n");
					nmg_pr_eu(eur, 0 );
				}
			}
@


10.24
log
@Access to plane equation / surface normal in face_geometry structure
is now done through macros NMG_GET_FU_PLANE() NMG_GET_FU_NORMAL(),
which honor the f->flip flag.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.23 93/11/12 23:40:22 mike Exp Locker: mike $ (ARL)";
d1133 1
a1133 1
	rt_log("nmg_pr_fu_around_eu_vecs(x%x)\n", eu);
d1148 5
a1152 5
		rt_log(" %8.8x, e=%8.8x, %s fu=%8.8x, f=%8.8x %s, s=%8.8x %g deg\n",
			eu1, eu1->e_p,
			lu->orientation == OT_SAME ? "S" : "O",
			fu, fu->f_p,
			fu->orientation == OT_SAME ? "SAME" : "OPP.",
d1163 5
a1167 5
		rt_log(" %8.8x, e=%8.8x, %s fu=%8.8x, f=%8.8x %s, s=%8.8x %g deg\n",
			eu1, eu1->e_p,
			lu->orientation == OT_SAME ? "S" : "O",
			fu, fu->f_p,
			fu->orientation == OT_SAME ? "SAME" : "OPP.",
@


10.23
log
@ANSI lint
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.22 93/10/29 04:16:16 mike Exp Locker: mike $ (ARL)";
d1425 1
d1456 4
a1459 2
	dist1 = DIST_PT_PLANE( vp->vg_p->coord , fu1->f_p->fg_p->N );
	dist2 = DIST_PT_PLANE( vp->vg_p->coord , fu2->f_p->fg_p->N );
d1511 2
d1516 2
a1517 1
				dist = DIST_PT_PLANE( v->vg_p->coord , fu->f_p->fg_p->N );
@


10.22
log
@Added another check to nmg_ck_face_worthless_edges().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.21 93/10/01 20:22:44 mike Exp Locker: mike $ (ARL)";
a1478 1
static CONST struct nmg_visit_handlers  nmg_visit_handlers_null;
@


10.21
log
@Removed CONST from nmg_ck_v_in_fus(), to match prototypes in table. :-(
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.20 93/09/30 20:55:24 mike Exp Locker: mike $ (ARL)";
d980 1
a980 1
 *  Such edges are legitimate to have, but can be troublesom
d1002 2
d1005 1
a1005 1
				rt_bomb("edge runs between two copies of vu??\n");
@


10.20
log
@Moved rt_pr_tol to librt/pr.c
Added nmg_ck_face_forthless_edges()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d35 1
d1486 1
a1486 1
CONST long		*vp;
d1488 1
a1488 1
CONST int		first;
@


10.19
log
@minor mods to nmg_ck_vs_in_region
@
text
@d12 2
a13 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d15 5
d21 2
a22 2
 *	This software is Copyright (C) 1990 by the United States Army.
 *	All rights reserved.
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.18 93/09/24 15:17:55 jra Exp Locker: jra $ (BRL)";
d39 1
a39 1
/* THis duplicates the extern from nmg_mesh.c */
a41 12
/* XXX move into librt/pr.c */
void
rt_pr_tol(tol)
CONST struct rt_tol	*tol;
{
	RT_CK_TOL(tol);

	rt_log("%8.8x TOL %e (sq=%e) perp=%e, para=%e\n",
		tol, tol->dist, tol->dist_sq,
		tol->perp, tol->para );
}

d973 43
@


10.18
log
@Added nmg_ck_vs_in_region
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.17 93/09/24 12:06:03 jra Exp Locker: jra $ (BRL)";
d1487 2
a1488 2
struct nmgregion *r;
struct rt_tol *tol;
d1496 1
d1502 1
a1502 1
	st.tol = tol;
@


10.17
log
@Added nmg_ck_v_in_2fus.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_ck.c,v 10.16 93/08/19 00:10:20 mike Exp Locker: jra $ (BRL)";
d1376 5
a1380 1
nmg_ck_v_in_2fus( struct vertex *vp , struct faceuse *fu1 , struct faceuse *fu2 , struct rt_tol *tol )
d1417 2
a1418 2
	dist1 = VDOT( vp->vg_p->coord , fu1->f_p->fg_p->N ) - fu1->f_p->fg_p->N[3];
	dist2 = VDOT( vp->vg_p->coord , fu2->f_p->fg_p->N ) - fu2->f_p->fg_p->N[3];
d1432 80
@


10.16
log
@Added lots of tol args
@
text
@d9 1
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.15 93/08/13 15:23:16 mike Exp Locker: mike $ (BRL)";
d1362 66
@


10.15
log
@Made nmg_pr_fu_around_eu_vecs() print edgeuses in the expected order around
the edge.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.14 93/08/12 22:51:15 mike Exp Locker: mike $ (BRL)";
d37 6
d44 5
d1081 1
a1081 1
nmg_pr_fu_around_eu_vecs( eu, xvec, yvec, zvec )
d1086 1
d1093 1
d1146 1
a1146 1
nmg_pr_fu_around_eu( eu )
d1148 1
d1156 1
d1160 1
a1160 1
	nmg_eu_2vecs_perp( xvec, yvec, zvec, eu );
d1162 1
a1162 1
	nmg_pr_fu_around_eu_vecs( eu, xvec, yvec, zvec );
d1177 3
a1179 2
nmg_check_radial(eu)
CONST struct edgeuse *eu;
d1189 2
a1190 1
	
d1249 1
d1252 1
a1252 1
				nmg_pr_fu_around_eu(eu1);
d1265 1
a1265 1
				nmg_pr_fu_around_eu( eu1 );
d1299 3
a1301 2
nmg_ck_closed_surf(s)
CONST struct shell *s;
d1310 1
d1319 1
a1319 1
					if (nmg_check_radial(eu))
d1347 1
a1347 1
nmg_ck_closed_region(r)
d1349 1
d1355 1
d1357 1
a1357 1
		ret = nmg_ck_closed_surf( s );
@


10.14
log
@Split out nmg_pr_fu_around_eu_vecs()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.13 93/07/24 02:17:00 mike Exp Locker: mike $ (BRL)";
a34 1
RT_EXTERN(double nmg_measure_2fu_angle, (CONST struct edgeuse *eu1, CONST struct edgeuse *eu2));
d1083 5
d1090 1
a1090 1
		/* First, the edgeuse */
d1096 1
a1096 1
		rt_log("EU=%8.8x, e=%8.8x, %s fu=%8.8x, f=%8.8x %s, s=%8.8x %g deg\n",
d1104 1
a1104 1
		/* Second, the edgeuse mate */
d1111 1
a1111 1
		rt_log("MU=%8.8x, e=%8.8x, %s fu=%8.8x, f=%8.8x %s, s=%8.8x %g deg\n",
@


10.13
log
@Changed nmg_pr_fu_around_eu() to use nmg_measure_2fu_angles()
rather than duplicating an incorrect version of the code here.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.12 93/07/24 00:59:19 mike Exp Locker: mike $ (BRL)";
d36 1
d38 1
d1068 1
a1068 10
 *			N M G _ P R _ F U _ A R O U N D _ E U
 *
 *  A debugging routine to print all the faceuses around a given edge,
 *  starting with the given edgeuse.
 *  The normal of the  first face is considered to be "0 degrees",
 *  and the rest are measured from there.
 *
 *  Note that the proper ordering of the edgeuses' faceuses is:
 *  SAME, OPPOSITE, OPPOSITE, SAME, ....
 *  This can be verified by calling nmg_check_radial(eu);
d1071 5
a1075 2
nmg_pr_fu_around_eu( eu )
CONST struct edgeuse *eu;
d1082 1
a1082 1
	rt_log("nmg_pr_fu_around_eu(x%x)\n", eu);
d1098 1
a1098 1
			nmg_measure_2fu_angle(eu, eu1) * rt_radtodeg );
d1113 1
a1113 1
			nmg_measure_2fu_angle(eu, eu1) * rt_radtodeg );
d1118 26
@


10.12
log
@Greatly enhanced usefulness of nmg_pr_around_eu(),
to visualize the radial edge faceuse arrangement
Fixed two bugs in nmg_check_radial().
1) faceuse orientation parity can only be checked within faceuses from
a single shell.
2) Is the radial the (virtual, for this shell) mate's radial?
If so, don't complain.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.11 93/07/23 17:03:20 mike Exp Locker: mike $ (BRL)";
d34 3
a1075 4
 *
 *  The first faceuse will have an angle of 0 degrees if it is an OT_SAME
 *  faceuse, otherwise, it will have an angle of 180 degrees (off the
 *  true face normal).
a1083 5
	vect_t			evect;
	vect_t			xdir;
	vect_t			ydir;
	vect_t			norm;
	vect_t			left;
a1087 22
	VSUB2( evect, eu->eumate_p->vu_p->v_p->vg_p->coord,
		eu->vu_p->v_p->vg_p->coord );
	VUNITIZE( evect );

	/* get normal vector for the face */
	fu = eu->up.lu_p->up.fu_p;
	if (fu->orientation == OT_SAME) {
		VMOVE(norm, fu->f_p->fg_p->N);
	} else if (fu->orientation == OT_OPPOSITE){
		VREVERSE(norm, fu->f_p->fg_p->N);
	} else rt_bomb("nmg_pr_around_eu() bad fu orientation\n");

	/*
	 * Because edgeuses are oriented, and run CCW for an exterior
	 * face loop, crossing the face normal with the edge vector will
	 * give a vector which lies in the plane of the face and
	 * points "left", towards the interior of the faceloop.
	 */
	VCROSS(left, norm, evect);
	VMOVE( xdir, norm );
	VMOVE( ydir, left );

d1102 1
a1102 1
			rt_angle_measure( fu->f_p->fg_p->N, xdir, ydir) * rt_radtodeg );
d1117 1
a1117 1
			rt_angle_measure( fu->f_p->fg_p->N, xdir, ydir) * rt_radtodeg );
@


10.11
log
@Added calculation of face angle.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.10 93/07/20 21:17:30 mike Exp Locker: mike $ (BRL)";
d1067 10
d1083 1
d1088 2
a1096 2
	mat_vec_perp( xdir, evect );
	VCROSS( ydir, xdir, evect );
d1098 18
d1120 3
a1122 1
		fu = eu1->up.lu_p->up.fu_p;
d1124 7
a1130 3
		rt_log("%8.8x EDGEUSE, %8.8x FACEUSE, %8.8x FACE, %s %g\n",
			eu1, fu, fu->f_p, nmg_orientation(fu->orientation),
			rt_angle_measure( fu->f_p->fg_p->N, xdir, ydir) );
d1135 3
a1137 1
		fu = eu1->up.lu_p->up.fu_p;
d1139 7
a1145 2
		rt_log("%8.8x  EUMATE, %8.8x FACEUSE, %8.8x FACE, %s\n",
			eu1, fu, fu->f_p, nmg_orientation(fu->orientation) );
d1217 4
a1220 3
			if (eur->up.lu_p->up.fu_p->orientation != curr_orient) {
				rt_bomb("nmg_check_radial: orient error while skipping to edge on this shell\n");
			}
d1225 2
d1228 2
a1229 1
		if (eur->up.lu_p->up.fu_p->orientation != curr_orient) {
d1234 1
a1234 1
			rt_log("Problem Edgeuses: %8x, %8x\n", eu1, eur);
d1236 1
@


10.10
log
@ANSI lint
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.9 93/05/14 04:24:07 mike Exp Locker: mike $ (BRL)";
d1074 3
d1079 1
d1081 6
d1093 3
a1095 2
		rt_log("%8.8x EDGEUSE, %8.8x FACEUSE, %8.8x FACE, %s\n",
			eu1, fu, fu->f_p, nmg_orientation(fu->orientation) );
@


10.9
log
@An attempt to debug the sA unclosed at return problem.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.8 93/03/26 23:00:47 mike Exp Locker: mike $ (BRL)";
d278 1
a278 1
		nmg_vvu(eu->vu_p, eu);
d395 1
a395 1
			nmg_veu( &lu->down_hd, lu);
d397 1
a397 1
			nmg_vvu(RT_LIST_FIRST(vertexuse,&lu->down_hd), lu);
d584 2
a585 2
		nmg_vlu( &s->lu_hd, s);
		nmg_veu( &s->eu_hd, s);
d1112 1
a1112 1
struct edgeuse *eu;
d1115 4
a1118 2
	struct edgeuse *eur, *eu1, *eurstart;
	struct shell *s;
d1226 1
a1226 1
struct shell *s;
d1272 1
a1272 1
struct nmgregion	*r;
d1274 1
a1274 1
	struct shell	*s;
@


10.8
log
@Moved various checking routines from nmg_misc.c to nmg_ck.c
The polygon maker moved from nmg_misc.c to nmg_junk.c
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.7 93/03/23 22:16:33 mike Exp Locker: mike $ (BRL)";
d31 1
a32 1
#include "nmg.h"
d1063 37
d1154 2
a1155 2
				rt_log("nmg_check_radial: bad edgeuse mate\n");
				return(1);
d1161 4
d1182 15
d1220 1
a1220 1
 *	!0	status code from nmg_check_radial()
d1229 1
a1229 1
	int		status;
d1239 1
d1241 6
a1246 2
					if (status=nmg_check_radial(eu))
						return(status);
@


10.7
log
@Fixed bug in checking wire edgeuses.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.6 93/03/19 01:00:29 mike Exp Locker: mike $ (BRL)";
d1060 160
@


10.6
log
@Added newlines to rt_bomb() calls.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.5 93/03/09 01:31:33 butler Exp Locker: mike $ (BRL)";
d201 1
d203 1
d229 6
a234 2
		/* Ensure that vertices are shared */
		if (eu->vu_p->v_p != eulast->eumate_p->vu_p->v_p) {
d243 2
a244 1
		if( eunext->vu_p->v_p != eu->eumate_p->vu_p->v_p) {
@


10.5
log
@Added check in nmg_vvertex to assure that the vertexuse which caused the
routine to be called actually exists in the vertex's list of uses.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.4 93/03/08 20:50:24 mike Exp Locker: butler $ (BRL)";
d496 1
a496 1
					rt_bomb("nmg_vfu() faceuse of \"SAME\" orientation has mate that is not \"OPPOSITE\" orientation");
d499 1
a499 1
					rt_bomb("nmg_vfu() faceuse of \"OPPOSITE\" orientation has mate that is not \"SAME\" orientation");
d535 1
a535 1
			rt_bomb("nmg_vshell()");
d1019 1
a1019 1
			rt_bomb("nmg_ck_lueu");
d1042 1
a1042 1
			rt_bomb("nmg_ck_lueu");
@


10.4
log
@Fixed a few small bugs.
Added routine names to start of all messages
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.3 93/02/24 00:59:27 mike Exp Locker: mike $ (BRL)";
d63 1
d71 2
d75 2
@


10.3
log
@Absorbed two checking routines from nmg_mod.c
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.2 92/07/22 04:26:02 mike Exp Locker: mike $ (BRL)";
d92 2
d105 3
a107 2
	if( RT_LIST_FIRST_MAGIC( &vu->l ) != NMG_VERTEXUSE_MAGIC)
		rt_bomb("vertexuse forw is bad vertexuse\n");
d110 1
a110 1
		rt_bomb("vertexuse not back of next vertexuse\n");
d154 1
a154 1
	if (!e->eu_p) rt_bomb("edge has null edgeuse pointer\n");
d167 1
a167 1
				rt_bomb("edgeuse mate does not have correct vertex\n");
d170 1
a170 1
				rt_bomb("edgeuse does not have correct vertex\n");
d172 1
a172 1
			rt_bomb("edgeuse does not share vertex endpoint\n");
d178 1
a178 1
		rt_bomb("Cannot get from edge to parent edgeuse\n");
d186 1
a186 1
 *  Verify edgeuse
d195 2
a196 1
	
d201 1
a201 1
			rt_bomb("edgeuse denies parentage\n");
d204 1
a204 1
			rt_bomb("edgeuse has Null \"forw\" pointer\n");
d206 1
d208 8
a215 2
			rt_bomb("edgeuse forw is bad edgeuse\n");
		if (RT_LIST_PLAST_CIRC(edgeuse,eunext) != eu )  {
d217 1
a217 1
			rt_bomb("next edgeuse has back that points elsewhere\n");
d219 1
a219 1
			rt_bomb("next edgeuse has NULL back\n");
d221 22
d244 1
a244 1
			rt_bomb("edgeuse mate is bad edgeuse\n");
d246 1
a246 1
			rt_bomb("edgeuse mate spurns edgeuse\n");
d249 1
a249 1
			rt_bomb("edgeuse radial is bad edgeuse\n");
d251 1
a251 1
			rt_bomb("edgeuse radial denies knowing edgeuse\n");
d262 1
a262 1
		default		: rt_bomb("unknown loopuse orintation\n");
d285 1
a285 1
			rt_bomb("loop geom min_pt greater than max_pt\n");
d303 1
a303 1
	if (!l->lu_p) rt_bomb("loop has null loopuse pointer\n");
d311 1
a311 1
	if (l->lu_p != lu) rt_bomb("can't get to parent loopuse from loop\n");
d343 1
a343 1
			rt_bomb("loopuse denies parentage\n");
d347 1
a347 1
			rt_bomb("loopuse has null forw pointer\n");
d349 1
a349 1
			rt_bomb("forw loopuse has back pointing somewhere else\n");
d352 1
a352 1
			rt_bomb("loopuse has null mate pointer\n");
d355 1
a355 1
			rt_bomb("loopuse mate is bad loopuse\n");
d358 1
a358 1
			rt_bomb("lumate spurns loopuse\n");
d365 5
a369 2
		default		: rt_bomb("unknown loopuse orintation\n");
					break;
d372 1
a372 1
			rt_bomb("loopuse and mate have different orientation\n");
d375 1
a375 1
			rt_bomb("loopuse has Null loop pointer\n");
d387 1
a387 1
			rt_bomb("nmg_vlu bad magic\n");
d406 1
a406 1
			rt_bomb("face geom min_pt greater than max_pt\n");
d412 1
a412 1
		rt_bomb("Bad NMG geometry\n");
d432 1
a432 1
	if (!f->fu_p) rt_bomb("face has null faceuse pointer\n");
d437 1
a437 1
	if (f->fu_p != fu) rt_bomb("can't get to parent faceuse from face\n");
d463 2
d470 1
a470 1
			rt_bomb("nmg_vfu\n");
d474 1
a474 1
			rt_bomb("faceuse forw is NULL\n");
d476 1
a476 1
			rt_bomb("faceuse->forw->back != faceuse\n");
d480 1
a480 1
			rt_bomb("null faceuse fumate_p pointer\n");
d483 1
a483 1
			rt_bomb("faceuse mate is bad faceuse ptr\n");
d486 1
a486 1
			rt_bomb("faceuse mate spurns faceuse!\n");
d491 1
a491 1
					rt_bomb("faceuse of \"SAME\" orientation has mate that is not \"OPPOSITE\" orientation");
d494 1
a494 1
					rt_bomb("faceuse of \"OPPOSITE\" orientation has mate that is not \"SAME\" orientation");
d497 1
a497 1
		default		: rt_bomb("unknown faceuse orintation\n"); break;
d523 2
d530 1
a530 1
			rt_bomb("nmg_vshell");
d534 1
a534 1
			rt_bomb("nmg_vshell: Shell's forw ptr is null\n");
d538 1
a538 1
			rt_bomb("nmg_vshell\n");
d550 1
a550 1
				rt_log("Bad min_pt/max_pt for shell(%8x)'s extent\n");
d567 1
a567 1
				rt_bomb("");
d596 1
a596 1
			rt_bomb("nmg_vregion\n");
d605 1
a605 1
			rt_bomb("forw nmgregion's back is not me\n");
d661 1
a661 1
		strcat(errstr, "Edge denies edgeuse parentage\n"));
d681 1
a681 1
		strcat(errstr, "Vertexuse denies parentage\n"));
d704 1
a704 1
		strcat(errstr, "Edgeuse child denies parentage\n"));
d707 1
a707 1
		strcat(errstr, "eumate has differnt kind of parent\n"));
d710 1
a710 1
			strcat(errstr, "eumate in different shell\n"));
d717 1
a717 1
			"Radial trip from eu ended in null pointer\n"));
d722 1
a722 1
			strcat(errstr, "eumate not in same loop\n"));
d729 1
a729 1
			strcat(errstr, "radial path leads to null ptr\n"));
d731 1
a731 1
			strcat(errstr, "Never saw eumate\n"));
d742 1
a742 1
		rt_bomb(strcat(errstr, "Bad edgeuse parent\n"));
d790 1
a790 1
		strcat(errstr, "Cannot get from loop to loopuse\n"));
d819 1
a819 1
		strcat(errstr, "loopuse child denies parentage\n") );
d824 1
a824 1
		strcat(errstr,"loopuse mate has different kind of parent\n"));
d828 1
a828 1
			strcat(errstr, "Lumate not in same shell\n") );
d831 1
a831 1
			strcat(errstr, "lumate part of different face\n"));
d833 1
a833 1
		rt_bomb(strcat(errstr, "Bad loopuse parent type\n"));
d854 1
a854 1
		rt_bomb(strcat(errstr, "Bad loopuse down pointer\n") );
d875 1
a875 1
			"bad NMG plane equation %fX + %fY + %fZ = %f\n",
d900 1
a900 1
		strcat(errstr,"Cannot get from face to \"parent faceuse\"\n"));
d928 1
a928 1
		strcat(errstr, "faceuse child denies shell parentage\n") );
d931 1
a931 1
		rt_bomb( strcat(errstr, "Faceuse not lastward of next faceuse\n") );
d934 1
a934 1
		rt_bomb( strcat(errstr, "Faceuse not nextward from last faceuse\n") );
d938 1
a938 1
		strcat(errstr, "Faceuse not fumate of fumate\n") );
d941 1
a941 1
		strcat(errstr, "faceuse mates not in same shell\n") );
d986 1
a986 1
		rt_bomb("headless!\n");
@


10.2
log
@nmg_vmodel() and his minions don't work yet.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 10.1 91/10/12 06:40:40 mike Rel4_0 Locker: mike $ (BRL)";
d913 95
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 1.4 91/06/17 20:41:52 butler Exp $ (BRL)";
d93 4
a96 1
	if (vu->up.magic_p != up_magic_p)
d98 1
d300 1
d307 3
a309 1
		if (*lu->up.magic_p != hp->magic)
d311 1
d467 1
a467 1
		nmg_vlu( &fu->lu_hd, fu);
@


1.4
log
@changed function declarations so that all global functions have their
"nmg_" at the begining of the line.  Static functions have their function
names on the same line as the "static" modifier.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 1.3 91/02/07 20:32:31 mike Exp $ (BRL)";
@


1.3
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_ck.c,v 1.2 90/05/31 00:09:48 butler Exp $ (BRL)";
d45 2
a46 1
void nmg_vvg(vg)
d57 2
a58 1
void nmg_vvertex(v, vup)
d75 2
a76 1
void nmg_vvua(vua)
d87 2
a88 1
void nmg_vvu(vu, up_magic_p)
d111 2
a112 1
void nmg_veua(eua)
d119 2
a120 1
void nmg_veg(eg)
d131 2
a132 1
void nmg_vedge(e, eup)
d181 2
a182 1
void nmg_veu(hp, up_magic_p)
d238 2
a239 1
void nmg_vlg(lg)
d256 2
a257 1
void nmg_vloop(l, lup)
d281 2
a282 1
void nmg_vlua(lua)
d293 2
a294 1
void nmg_vlu(hp, up)
d352 2
a353 1
void nmg_vfg(fg)
d377 2
a378 1
void nmg_vface(f, fup)
d400 2
a401 1
void nmg_vfua(fua)
d412 2
a413 1
void nmg_vfu(hp, s)
d469 2
a470 1
void nmg_vshell(hp, r)
d536 2
a537 1
void nmg_vregion(hp, m)
d567 2
a568 1
void nmg_vmodel(m)
d588 1
d621 1
d641 1
d709 1
d728 1
d752 1
d814 1
d838 1
d862 1
@


1.2
log
@added include for string(s).h so that declarations of string functions would
be included
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_ck.c,v 1.1 90/05/24 20:50:50 mike Exp $ (BRL)";
d64 1
a64 1
	for( NMG_LIST( vu, vertexuse, &v->vu_hd ) )  {
d95 1
a95 1
	if( NMG_LIST_FIRST_MAGIC( &vu->l ) != NMG_VERTEXUSE_MAGIC)
d98 1
a98 1
	if (NMG_LIST_PNEXT_PLAST(vertexuse,vu) != vu )
d175 1
a175 1
struct nmg_list	*hp;
d181 1
a181 1
	for( NMG_LIST( eu, edgeuse, hp ) )  {
d189 1
a189 1
		eunext = NMG_LIST_PNEXT_CIRC( edgeuse, eu );
d192 1
a192 1
		if (NMG_LIST_PLAST_CIRC(edgeuse,eunext) != eu )  {
d283 1
a283 1
struct nmg_list	*hp;
d287 1
a287 1
	for( NMG_LIST( lu, loopuse, hp ) )  {
d295 1
a295 1
		else if (NMG_LIST_PNEXT_PLAST(loopuse,lu) != lu )
d326 1
a326 1
		if( NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC)
d328 2
a329 2
		else if (NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)
			nmg_vvu(NMG_LIST_FIRST(vertexuse,&lu->down_hd), lu);
d398 1
a398 1
struct nmg_list	*hp;
d403 1
a403 1
	for( NMG_LIST( fu, faceuse, hp ) )  {
d413 1
a413 1
		} else if (fu->l.forw->back != (struct nmg_list *)fu) {
d454 1
a454 1
struct nmg_list	*hp;
d460 1
a460 1
	for( NMG_LIST( s, shell, hp ) )  {
d470 1
a470 1
		} else if (s->l.forw->back != (struct nmg_list *)s) {
d497 3
a499 3
			if( NMG_LIST_NON_EMPTY( &s->fu_hd ) ||
			    NMG_LIST_NON_EMPTY( &s->lu_hd ) ||
			    NMG_LIST_NON_EMPTY( &s->eu_hd ) )  {
d520 1
a520 1
struct nmg_list	*hp;
d525 1
a525 1
	for( NMG_LIST( r, nmgregion, hp ) )  {
d538 1
a538 1
		if( NMG_LIST_PNEXT_PLAST(nmgregion, r) != r )  {
d663 1
a663 1
		eu_next = NMG_LIST_PNEXT_CIRC(edgeuse, eu);
d667 1
a667 1
		eu_last = NMG_LIST_PLAST_CIRC(edgeuse, eu);
d767 1
a767 1
	magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
d769 1
a769 1
		vu = NMG_LIST_FIRST( vertexuse, &lu->down_hd );
d774 1
a774 1
		for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d854 1
a854 1
	if( NMG_LIST_PNEXT_PLAST( faceuse, fu ) )
d857 1
a857 1
	if( NMG_LIST_PLAST_PNEXT( faceuse, fu ) )
d870 1
a870 1
	for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d24 5
@
