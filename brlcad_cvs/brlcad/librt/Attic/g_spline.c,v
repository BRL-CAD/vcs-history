head	11.10;
access;
symbols
	rel-5-4:11.7
	rel-5-3:11.7
	rel-5-2:11.7
	rel-5-1-branch:11.7.0.2
	rel-5-1:11.7
	rel-5-0:11.5
	rel-5-0-beta:11.4
	rel-4-5:11.3
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:9.11
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.10
date	2000.06.30.17.48.57;	author jra;	state dead;
branches;
next	11.9;

11.9
date	2000.06.30.15.38.03;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.06.30.15.31.15;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.11.26.21.46.49;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.11.17.02.42.02;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.07.02.22.19.24;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.05.27.19.10.42;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.12.16.00.13.37;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.01.24.21.19.59;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.01;	author mike;	state Rel4_4;
branches;
next	9.11;

9.11
date	91.06.22.22.30.34;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.05.18.03.01.31;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.01.28.23.53.19;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.01.26.03.14.58;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.01.25.21.19.17;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.01.19.04.58.09;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.01.19.04.55.08;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.10.06.02.05.23;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.05.04.08.12.45;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.03.14.15.06.00;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.28;	author mike;	state Rel3_5;
branches;
next	8.7;

8.7
date	89.04.17.17.19.52;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.04.11.15.42.45;	author phil;	state Exp;
branches;
next	8.5;

8.5
date	89.03.06.07.23.55;	author stay;	state Exp;
branches;
next	8.4;

8.4
date	89.01.07.01.12.32;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	88.12.06.00.02.43;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.10.06.04.43.30;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.31.45;	author mike;	state Rel3_0;
branches;
next	7.7;

7.7
date	88.10.01.01.50.50;	author stay;	state Exp;
branches;
next	7.6;

7.6
date	88.05.14.02.29.31;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.05.14.00.21.20;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.05.14.00.01.18;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.06.05.36.57;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.11.18.08.03;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.34.16;	author mike;	state Rel;
branches;
next	6.5;

6.5
date	87.10.22.18.19.59;	author mike;	state Exp;
branches;
next	6.4;

6.4
date	87.10.20.08.10.55;	author stay;	state Exp;
branches;
next	6.3;

6.3
date	87.09.17.07.05.37;	author stay;	state Exp;
branches;
next	6.2;

6.2
date	87.09.09.10.15.12;	author stay;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.56.34;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.12.27;	author mike;	state Rel;
branches;
next	4.9;

4.9
date	87.05.22.02.08.02;	author mike;	state Exp;
branches;
next	4.8;

4.8
date	87.04.29.17.42.53;	author phil;	state Exp;
branches;
next	4.7;

4.7
date	87.04.21.17.49.16;	author stay;	state Exp;
branches;
next	4.6;

4.6
date	87.04.21.17.36.27;	author stay;	state Exp;
branches;
next	4.5;

4.5
date	87.04.07.22.21.44;	author phil;	state Exp;
branches;
next	4.4;

4.4
date	87.03.23.23.41.24;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.03.10.23.43.06;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.12.22.11.55;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.46.00;	author mike;	state Rel1;
branches;
next	3.7;

3.7
date	86.12.24.08.06.11;	author mike;	state Exp;
branches;
next	3.6;

3.6
date	86.09.23.21.41.22;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.08.12.22.00.12;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.08.12.04.16.29;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.24.06.10.34;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.17.18.19.51;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.11.01.32.42;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.33.47;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.06.09.21.51.00;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.03.14.21.19.43;	author mike;	state Exp;
branches;
next	;


desc
@Intersect a ray with a B-spline surface.
This routine from USNA.
@


11.10
log
@This file is not used
@
text
@/* 
 *			G _ S P L I N E . C
 *
 * Function -
 *     Ray trace Spline code to work with librt and libspl.
 * 
 * Author -
 *     Paul R. Stay
 *
 * Source -
 *     SECAD/VLD Computing Consortium, Bldg 394
 *     The U.S. Army Ballistic Research Laboratory
 *     Aberdeen Proving Ground, Maryland 21005
 *
 * Copyright Notice -
 *     This software is Copyright (C) 1986 by the United States Army.
 *     All rights reserved.
 */

#include <stdio.h>	/* GED specific include files */
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "raytrace.h"
#include "./debug.h"

#include "../libspl/b_spline.h"

struct rt_spl_internal {
	long		magic;
	int		nsurf;
	fastf_t		resolution;
	struct b_spline	**surfs;
};
#define RT_SPL_INTERNAL_MAGIC	0x00911911
#define RT_SPL_CK_MAGIC(_p)	BU_CKMAG(_p,RT_SPL_INTERNAL_MAGIC,"rt_spl_internal")

struct b_tree {
	point_t min, max;		/* bounding box info */
	struct b_spline * root;	        /* B_spline surface */
	struct b_tree  * left;
	struct b_tree * right;
};

struct b_head {
	struct b_head * next;   /* Next tree over only used at level 0 */
	point_t	min,  max;  /* Current surface minimum and maximum */
	struct b_spline * root;   /* Leaf b_spline surface. Null if interior */
	struct b_spline * u_diff;
	struct b_spline * v_diff;
	struct b_tree * left;   /* Left sub tree */
	struct b_tree * right;  /* Right sub tree */
};

/* 
 * Local hit structure. We need this since the number of hits
 * may be large. An extra forward link will allow hits to be 
 * added from the surface.
 */

struct local_hit {
	fastf_t hit_dist;	/* Distance from the r_pt to the surface */
	point_t hit_point;	/* Intersection point */
	vect_t  hit_normal;	/* Surface Normal at the hit_point */
	vect_t  hit_vpriv;      /* Store parametric u and v information */
	char * hit_private; 	/* store cuurent b-spline surface pointer */
	struct local_hit * next;
	struct local_hit * prev;
};

#define NULLHIT	    (struct local_hit *) 0
#define NULLTREE    (struct b_tree *) 0

struct local_hit * rt_spl_hit_head = NULLHIT;

/* Algorithm - Fire a ray at the bounding box of a b_spline surface.  If an
 * intersection is found then subdivide the surface creating two new
 * surfaces and freeing the original surface.  Recursively shoot at each of
 * the new surfaces until it misses or hits.  A hit is found if the
 * bounding box is intersects within the ray cone and if there are no
 * ineterior knots.
 *
 *  
 *	   -- (cone)
 *       --    |---| bounding box
 *  ray -------------------------->
 *       --    |---|
 *         --
 */
void			rt_spl_n_shoot();
void			rt_spl_add_hit();
void			rt_spl_n_free();
void			rt_spl_shot_poly();
struct local_hit	*rt_spl_get_next_hit();
struct local_hit	*rt_spl_ray_poly();

#define SPL_NULL	((struct b_spline *)0)


/* 
 *			R T _ S P L _ P R E P
 *
 * Given a pointer of a GED database record, and a transformation matrix,
 * determine if this is avalid B_spline solid, and if so prepare the
 * surface so that the subdivision works.
 */
int
rt_spl_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
{
	struct rt_spl_internal	*sip;
	struct b_head		*nlist = (struct b_head *) 0;
	int			i;

	sip = (struct rt_spl_internal *)ip->idb_ptr;
	RT_SPL_CK_MAGIC(sip);

	for( i=0; i < sip->nsurf; i++ )  {
		struct b_head * s_tree;
		struct b_spline * new_srf;
		struct b_spline * s_split;

		new_srf = sip->surfs[i];

		BU_GETSTRUCT( s_tree, b_head );
		BU_GETSTRUCT( s_tree->left, b_tree );
		BU_GETSTRUCT( s_tree->right, b_tree );

		/* Add to linked list */
		s_tree->next = nlist;
		nlist = s_tree;

		s_split = (struct b_spline * ) spl_split( new_srf, ROW);
		s_tree->left->root = s_split;
		s_tree->right->root = s_split->next;
		s_split->next = (struct b_spline *) 0;

		s_tree->left->left = s_tree->left->right = NULLTREE;
		s_tree->right->left = s_tree->right->right = NULLTREE;

		s_tree->root = new_srf;
		s_tree->u_diff = (struct b_spline *) spl_u_diff( new_srf );
		s_tree->v_diff = (struct b_spline *) spl_v_diff( new_srf );

		spl_bound( s_tree->root, s_tree->min, s_tree->max);
		spl_bound( s_tree->left->root, 
		    s_tree->left->min, s_tree->left->max);
		spl_bound( s_tree->right->root, 
		    s_tree->right->min, s_tree->right->max);
		VMINMAX( stp->st_min, stp->st_max, s_tree->min );
		VMINMAX( stp->st_min, stp->st_max, s_tree->max );
		if ( rt_g.debug & DEBUG_SPLINE ) {
			rt_pr_spl( "initial surface",s_tree->root );
			fprintf(stderr, "bounding box\n");
			VPRINT("min", s_tree->min);
			VPRINT("max", s_tree->max);
		}
	}
	stp->st_specific = (genptr_t)nlist;

	VADD2SCALE( stp->st_center, stp->st_max, stp->st_min, 0.5 );
	{
		fastf_t f, dx, dy, dz;
		dx = (stp->st_max[0] - stp->st_min[0])/2;
		f = dx;
		dy = (stp->st_max[1] - stp->st_min[1])/2;
		if( dy > f )  f = dy;
		dz = (stp->st_max[2] - stp->st_min[2])/2;
		if( dz > f )  f = dz;
		stp->st_aradius = f;
		stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);
	}

	return(0);		/* OK */
}

/*
 *			R T _ S P L _ P R I N T
 */
void
rt_spl_print( stp )
register struct soltab * stp;
{
	register struct b_head * ncnt = (struct b_head *) stp->st_specific;

	if( ncnt  == (struct b_head *)0 )  {
		bu_log("spline(%s):  no surfaces\n", stp->st_name);
		return;
	}

	for( ; ncnt != (struct b_head *)0; ncnt = ncnt->next )
		rt_pr_spl( "B_Spline", ncnt->root );
}

/* 
 *			R T _ S P L _ U V
 */
void
rt_spl_uv(ap, stp, hitp, uvp)
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
{

	uvp->uv_u = hitp->hit_vpriv[0];
	uvp->uv_v = hitp->hit_vpriv[1];

	return;
}

int
rt_spl_class()
{
	return(0);
}

/*
 *			R T _ S P L _ P L O T
 */
int
rt_spl_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
{
	struct rt_spl_internal	*sip;
	register int	i;
	register int	j;
	register fastf_t *vp;
	int		s;

	RT_CK_DB_INTERNAL(ip);
	sip = (struct rt_spl_internal *)ip->idb_ptr;
	RT_SPL_CK_MAGIC(sip);

	for( s=0; s < sip->nsurf; s++ )  {
		register struct b_spline	*new;

		new = sip->surfs[s];
		/* Perhaps some spline refinement here? */

		/* Eliminate any homogenous coordinates */
		if( new->ctl_mesh->pt_type == P4 )  {
			vp = new->ctl_mesh->mesh;
			i = new->ctl_mesh->mesh_size[0] * new->ctl_mesh->mesh_size[1];
			for( ; i>0; i--, vp += new->ctl_mesh->pt_type )  {
				HDIVIDE( vp, vp );
				/* Leaves us with [x,y,z,1] */
			}
		}

		/* 
		 * Draw the control mesh, by tracing each curve.
		 */
#define CTL_POS(a,b)	((((a)*new->ctl_mesh->mesh_size[1])+(b))*new->ctl_mesh->pt_type)
		vp = new->ctl_mesh->mesh;

		for( i = 0; i < new->ctl_mesh->mesh_size[0]; i++) {
			RT_ADD_VLIST( vhead, vp, BN_VLIST_LINE_MOVE );
			vp += new->ctl_mesh->pt_type;
			for( j = 1; j < new->ctl_mesh->mesh_size[1]; j++ )  {
				/** CTL_POS( i, j ); **/
				RT_ADD_VLIST( vhead, vp, BN_VLIST_LINE_DRAW );
				vp += new->ctl_mesh->pt_type;
			}
		}

		/*
		 *  Connect the Ith points on each curve, to make a mesh.
		 */
		for( i = 0; i < new->ctl_mesh->mesh_size[1]; i++ )  {
			vp = new->ctl_mesh->mesh+CTL_POS( 0, i );
			RT_ADD_VLIST( vhead, vp, BN_VLIST_LINE_MOVE );
			for( j = 1; j < new->ctl_mesh->mesh_size[0]; j++ )  {
				vp = new->ctl_mesh->mesh+CTL_POS( j, i );
				RT_ADD_VLIST( vhead, vp, BN_VLIST_LINE_DRAW );
			}
		}
	}
	return(0);
}

/*
 *			R T _ S P L _ C U R V E
 */
void
rt_spl_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
{
	register struct b_head *s_ptr = (struct b_head *) hitp->hit_private;

	fastf_t        *u_eval, *v_eval, *s_eval, 
	 	       *u2_eval, *v2_eval, *uv_eval;
	fastf_t         u, v;
	fastf_t         E, F, G;		/* First Fundamental Form */
	fastf_t		L, M, N;		/* Second Fundamental form */
	struct b_spline *u2_srf, *v2_srf, *uv_srf;
	fastf_t         denom;
	fastf_t		wein[4];		/*Weingarten matrix */
	fastf_t		evec[3];
	fastf_t		mean, gauss, discrim;
	vect_t 		norm;

	u = hitp->hit_vpriv[0];
	v = hitp->hit_vpriv[1];

	u2_srf = (struct b_spline *) spl_u_diff(s_ptr->u_diff);
	v2_srf = (struct b_spline *) spl_v_diff(s_ptr->v_diff);
	uv_srf = (struct b_spline *) spl_u_diff(s_ptr->v_diff);

	s_eval = (fastf_t *) spl_srf_eval(s_ptr->root, u, v);
	u_eval = (fastf_t *) spl_srf_eval(s_ptr->u_diff, u, v);
	v_eval = (fastf_t *) spl_srf_eval(s_ptr->v_diff, u, v);

	uv_eval = (fastf_t *) spl_srf_eval(uv_srf, u, v);
	u2_eval = (fastf_t *) spl_srf_eval(u2_srf, u, v);
	v2_eval = (fastf_t *) spl_srf_eval(v2_srf, u, v);

	spl_sfree(u2_srf);
	spl_sfree(uv_srf);
	spl_sfree(v2_srf);

	if (s_ptr->root->ctl_mesh->pt_type == P3) {
		VCROSS( norm, u_eval, v_eval);
		VUNITIZE( norm );
		VMOVE( hitp->hit_normal, norm );
		E = VDOT(u_eval, u_eval);
		F = VDOT(u_eval, v_eval);
		G = VDOT(v_eval, v_eval);

		L = VDOT(norm, u2_eval);
		M = VDOT(norm, uv_eval);
		N = VDOT(norm, v2_eval);

	} else if (s_ptr->root->ctl_mesh->pt_type == P4) {
		vect_t          ue, ve;
		vect_t          u2e, v2e, uve;


		ue[0] =
		    (1.0 / s_eval[3] * u_eval[0]) - (u_eval[3] / s_eval[3]) *
			s_eval[0] / s_eval[3];
		ve[0] =
		    (1.0 / s_eval[3] * v_eval[0]) - (v_eval[3] / s_eval[3]) *
			s_eval[0] / s_eval[3];

		ue[1] =
		    (1.0 / s_eval[3] * u_eval[1]) - (u_eval[3] / s_eval[3]) *
			s_eval[1] / s_eval[3];
		ve[1] =
		    (1.0 / s_eval[3] * v_eval[1]) - (v_eval[3] / s_eval[3]) *
			s_eval[1] / s_eval[3];

		ue[2] =
		    (1.0 / s_eval[3] * u_eval[2]) - (u_eval[3] / s_eval[3]) *
			s_eval[2] / s_eval[3];
		ve[2] =
		    (1.0 / s_eval[3] * v_eval[2]) - (v_eval[3] / s_eval[3]) *
			s_eval[2] / s_eval[3];


		VCROSS( norm, ue, ve );
		VUNITIZE( norm );
		VMOVE( hitp->hit_normal, norm );

		E = VDOT(ue, ue);
		F = VDOT(ue, ve);
		G = VDOT(ve, ve);

		u2e[0] = 1.0 / s_eval[3] * (u2_eval[0]) -
			2 * (u2_eval[3] / s_eval[3]) * u2_eval[0] -
			u2_eval[3] / s_eval[3] * (s_eval[0] / s_eval[3]);

		v2e[0] = 1.0 / s_eval[3] * (v2_eval[0]) -
			2 * (v2_eval[3] / s_eval[3]) * v2_eval[0] -
			v2_eval[3] / s_eval[3] * (s_eval[0] / s_eval[3]);

		u2e[1] = 1.0 / s_eval[3] * (u2_eval[1]) -
			2 * (u2_eval[3] / s_eval[3]) * u2_eval[1] -
			u2_eval[3] / s_eval[3] * (s_eval[1] / s_eval[3]);

		v2e[1] = 1.0 / s_eval[3] * (v2_eval[1]) -
			2 * (v2_eval[3] / s_eval[3]) * v2_eval[1] -
			v2_eval[3] / s_eval[3] * (s_eval[1] / s_eval[3]);

		u2e[2] = 1.0 / s_eval[3] * (u2_eval[2]) -
			2 * (u2_eval[3] / s_eval[3]) * u2_eval[2] -
			u2_eval[3] / s_eval[3] * (s_eval[2] / s_eval[3]);

		v2e[2] = 1.0 / s_eval[3] * (v2_eval[2]) -
			2 * (v2_eval[3] / s_eval[3]) * v2_eval[2] -
			v2_eval[3] / s_eval[3] * (s_eval[2] / s_eval[3]);

		uve[0] = 1.0 / s_eval[3] * uv_eval[0] +
			(-1.0 / (s_eval[3] * s_eval[3])) *
			(v_eval[3] * u_eval[0] + u_eval[3] * v_eval[0] +
			 uv_eval[3] * s_eval[0]) +
			(-2.0 / (s_eval[3] * s_eval[3] * s_eval[3])) *
			(v_eval[3] * u_eval[3] * s_eval[0]);

		uve[1] = 1.0 / s_eval[3] * uv_eval[1] +
			(-1.0 / (s_eval[3] * s_eval[3])) *
			(v_eval[3] * u_eval[1] + u_eval[3] * v_eval[1] +
			 uv_eval[3] * s_eval[1]) +
			(-2.0 / (s_eval[3] * s_eval[3] * s_eval[3])) *
			(v_eval[3] * u_eval[3] * s_eval[1]);

		uve[2] = 1.0 / s_eval[3] * uv_eval[2] +
			(-1.0 / (s_eval[3] * s_eval[3])) *
			(v_eval[3] * u_eval[2] + u_eval[3] * v_eval[2] +
			 uv_eval[3] * s_eval[2]) +
			(-2.0 / (s_eval[3] * s_eval[3] * s_eval[3])) *
			(v_eval[3] * u_eval[3] * s_eval[2]);

		L = VDOT(norm, u2e);
		M = VDOT(norm, uve);
		N = VDOT(norm, v2e);
	} else {
		bu_log("rt_spl_curve: bad mesh point type %d\n",
			s_ptr->root->ctl_mesh->pt_type);
		goto	cleanup;
	}

	denom = ( (E*G) - (F*F) ); 

	gauss = ( L * N - M *M)/ denom;
	mean  = ( G * L + E * N - 2 * F * M) / (2 * denom );

	discrim = sqrt( mean * mean - gauss );

	cvp->crv_c1 = mean - discrim;
	cvp->crv_c2 = mean + discrim;

	if ( APX_EQ( (E * G) - ( F* F ) , 0.0 ) )
	{
		bu_log("first fundamental form is singular E = %g F = %g G = %g\n",
			E,F,G);
		return;
	}

	wein[0] = ( (G * L) - (F * M))/ (denom);
	wein[1] = ( (G * M) - (F * N))/ (denom);
	wein[2] = ( (E * M) - (F * L))/ (denom);
	wein[3] = ( (E * N) - (F * M))/ (denom);


	if ( APX_EQ( wein[1] , 0.0 ) && APX_EQ( wein[3] - cvp->crv_c1, 0.0) )
	{
		evec[0] = 0.0; evec[1] = 1.0;
	} else
	{
		evec[0] = 1.0;
		if( fabs( wein[1] ) > fabs( wein[3] - cvp->crv_c1) )
		{
			evec[1] = (cvp->crv_c1 - wein[0]) / wein[1];
		} else
		{
			evec[1] = wein[2] / ( cvp->crv_c1 - wein[3] );
		}
	}

	VSET( cvp->crv_pdir, 0.0, 0.0, 0.0 );

	cvp->crv_pdir[0] = evec[0] * u_eval[0] + evec[1] * v_eval[0];
	cvp->crv_pdir[1] = evec[0] * u_eval[1] + evec[1] * v_eval[1];
	cvp->crv_pdir[2] = evec[0] * u_eval[2] + evec[1] * v_eval[2];

	VUNITIZE( cvp->crv_pdir );

cleanup:
	bu_free( (char *)s_eval, "spl_curve:s_eval");
	bu_free( (char *)u_eval, "spl_curve:u_eval");
	bu_free( (char *)v_eval, "spl_curve:v_eval");
	bu_free( (char *)u2_eval, "spl_curve:u2_eval");
	bu_free( (char *)v2_eval, "spl_curve:v2_eval");
	bu_free( (char *)uv_eval, "spl_curve:uv_eval");
}

/*
 *			R T _ S P L _ F R E E
 */
void
rt_spl_free( stp )
register struct soltab * stp;
{
	struct b_head * nlist = ( struct b_head *) stp->st_specific;
	struct b_head * c_tree;
	
	for( c_tree = nlist; c_tree != (struct b_head *)0; )
	{
		c_tree = nlist->next;
		rt_spl_n_free( nlist->left );
		rt_spl_n_free( nlist->right );
		spl_sfree( nlist->root);
		spl_sfree( nlist->u_diff);
		spl_sfree( nlist->v_diff);
		bu_free( (char *)nlist, "rt_spl_free: b_head structure");
	}

	return;
}

/*
 *			R T _ S P L _ N _ F R E E
 */
void
rt_spl_n_free( tree)
struct b_tree * tree;
{
	struct b_tree * leftp, * rightp, * rootp;
	
	rootp = tree;

	if ( tree->left != (struct b_tree *) 0 )
	{
		leftp = tree->left;
		rt_spl_n_free( leftp );
	}

	if ( tree->right != (struct b_tree *) 0 )
	{
		rightp = tree->right;
		rt_spl_n_free( rightp );
	}

	if ( rootp->root != (struct b_spline *) 0 )
		spl_sfree( rootp->root );

	bu_free( (char *)rootp, "rt_spl_n_free: tree structure ");

}

/* 
 *			R T _ S P L _ N O R M
 */
void
rt_spl_norm(hitp, stp, rp)
register struct hit * hitp;
struct soltab * stp;
register struct xray *rp;
{
	struct b_head * h_ptr = (struct b_head *) hitp->hit_private;
	fastf_t u = hitp->hit_vpriv[0];
	fastf_t v = hitp->hit_vpriv[1];
	fastf_t *u_eval, * v_eval;
	vect_t norm;
	
	/* if the object is linear in one of the directions
	 * for now just use the existing normal from the polygon
         * else calculate it from the derivatives
         */

	if ( h_ptr->root->order[0] == 2 || h_ptr->root->order[1] == 2 )
		return;

	if( h_ptr->root->ctl_mesh->pt_type == P3)
	{
		u_eval = (fastf_t *) 
			spl_srf_eval( h_ptr->u_diff, u, v);

		v_eval = (fastf_t *) 
			spl_srf_eval( h_ptr->v_diff, u, v);

		VCROSS( norm, u_eval, v_eval);
		VUNITIZE( norm);
		VMOVE( hitp->hit_normal, norm);
	} else 
	if( h_ptr->root->ctl_mesh->pt_type == P4)
	{
		fastf_t * spl_eval;
		fastf_t  w, one_w;
		point_t u_norm, v_norm;

		u_eval = (fastf_t *) 
			spl_srf_eval( h_ptr->u_diff, u, v);

		v_eval = (fastf_t *) 
			spl_srf_eval( h_ptr->v_diff, u, v);
		
		spl_eval = (fastf_t *)
			spl_srf_eval( h_ptr->root, u, v);

		w = spl_eval[3];
		one_w = 1.0 / w;

		u_norm[0] = (one_w * u_eval[0]) - 
			(u_eval[3] / w * ( spl_eval[0] / w ));

		u_norm[1] = (one_w * u_eval[1]) - 
			(u_eval[3] / w * ( spl_eval[1] / w ));

		u_norm[2] = (one_w * u_eval[2]) - 
			(u_eval[3] / w * ( spl_eval[2] / w));


		v_norm[0] = (one_w * v_eval[0]) - 
			(v_eval[3] / w * ( spl_eval[0] / w ));

		v_norm[1] = ( one_w * v_eval[1]) - 
			(v_eval[3] / w * ( spl_eval[1] / w ));

		v_norm[2] = ( one_w * v_eval[2]) - 
			(v_eval[3] / w * ( spl_eval[2] / w ));

		VCROSS( norm, u_norm, v_norm );
		VUNITIZE( norm);
		VMOVE(hitp->hit_normal, norm);
		bu_free( (char *)spl_eval, "rt_spl_curve: spl_eval" );
	}
	else
	{
		bu_log("rt_spl_curve: bad mesh point type %d\n",
			h_ptr->root->ctl_mesh->pt_type);
		return;
	}

	if ( hitp->hit_vpriv[2] )
	{	
		VREVERSE( hitp->hit_normal, norm );
	}

	bu_free( (char *)u_eval, "rt_spl_curve: u_eval" );
	bu_free( (char *)v_eval, "rt_spl_curve: v_eval" );

	return;
}


/* 
 *			R T _ S P L _ S H O T 
 *
 * Intersect a ray with a set of b_spline surfaces. If an intersection
 * occurs a struct seg will be acquired and filled in.
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */

struct b_head * curr_tree;

int
rt_spl_shot( stp,  rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
{
	struct b_head * nlist = ( struct b_head *) stp->st_specific;
	auto vect_t invdir;
	struct seg * segp;

	invdir[0] = invdir[1] = invdir[2] = INFINITY;
	if(!NEAR_ZERO(rp->r_dir[0], SQRT_SMALL_FASTF)) 
		invdir[0] = 1.0 / rp->r_dir[0];
	if(!NEAR_ZERO(rp->r_dir[1], SQRT_SMALL_FASTF)) 
		invdir[1] = 1.0 / rp->r_dir[1];
	if(!NEAR_ZERO(rp->r_dir[2], SQRT_SMALL_FASTF)) 
		invdir[2] = 1.0 / rp->r_dir[2];

	bu_semaphore_acquire( RT_SEM_MODEL );	

	for(; nlist != (struct b_head *) 0; nlist = nlist->next )
	{
		curr_tree = nlist;
		rt_spl_n_shoot( rp, invdir, nlist->left,  ap, 0 );
		rt_spl_n_shoot( rp, invdir, nlist->right, ap, 0 );
	}

	/* Sort the hit points and create the segments if only one hit
	 * than add a distance and fake one.
	 */

	if (rt_spl_hit_head == NULLHIT )
	{
		bu_semaphore_release( RT_SEM_MODEL );	
		return (0);
	}

	while ( rt_spl_hit_head != NULLHIT)
	{
		register struct local_hit * hit1, * hit2;
		register struct seg * seg2p;

		RT_GET_SEG( segp, ap->a_resource );

		hit1 = rt_spl_get_next_hit( );
		hit2 = rt_spl_get_next_hit( );

		segp->seg_stp = stp;
		segp->seg_in.hit_dist = hit1->hit_dist;
		VMOVE(segp->seg_in.hit_point, hit1->hit_point );
		VMOVE(segp->seg_in.hit_normal, hit1->hit_normal);
		VMOVE(segp->seg_in.hit_vpriv,hit1->hit_vpriv);
		segp->seg_in.hit_private = hit1->hit_private;
		
		if (hit2 != NULLHIT)
		{
			segp->seg_out.hit_dist = hit2->hit_dist;
			VMOVE(segp->seg_out.hit_point, hit2->hit_point );
			VMOVE(segp->seg_out.hit_vpriv,hit2->hit_vpriv);
			segp->seg_out.hit_private = hit2->hit_private;
			bu_free( (char *)hit2, "rt_spl_shot: hit point");
		} else	/* Fake it */
		{
			segp->seg_out.hit_dist = hit1->hit_dist + .01;
			VJOIN1( segp->seg_out.hit_point,
			    rp->r_pt, segp->seg_out.hit_dist, rp->r_dir);
			VMOVE(segp->seg_out.hit_vpriv,hit1->hit_vpriv);
			segp->seg_out.hit_vpriv[2] = 1; /* flip normal */
			segp->seg_out.hit_private = hit1->hit_private;
		}

		bu_free( (char *)hit1, "rt_spl_shot: hit point");

		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	}
	bu_semaphore_release( RT_SEM_MODEL );	
	return(2);
}

/*
 *			R T _ S P L _ N _ S H O O T
 */
void
rt_spl_n_shoot( rp,  invdir,  tree, ap, level)
register struct xray *rp;
fastf_t * invdir;
struct b_tree * tree;
struct application *ap;
int level;
{
	int flat;
	struct b_spline * sub;
	fastf_t pix_size;

	if ( tree == NULLTREE)	/* Passed a null pointer  */
		return;

	if ( !rt_in_rpp ( rp,  invdir,  tree->min,  tree->max))
		return;

	pix_size = (ap->a_rbeam + ap->a_diverge * rp->r_max);

	if ( tree->root != (struct b_spline *) 0 )  {

		if( spl_check( tree->root ) < 0)  {
			rt_pr_spl("rt_spl_n_shoot: bad tree root", tree->root);
			return;
		}

		flat =	spl_flat( tree->root, pix_size );
		if (flat == FLAT)
		{
			rt_spl_shot_poly( rp,  tree, level);
			return;
		}

		sub = (struct b_spline *) 
		spl_split( tree->root, flat);
		if( spl_check( sub ) < 0 || 
		    spl_check( sub->next ) < 0 )  {
		    	rt_pr_spl("error in spl_split() input:", tree->root);
			rt_pr_spl("Left output:", sub);
			rt_pr_spl("Right output:", sub->next);
		    	return;
		}

		/* Record new right and left descendants */
		BU_GETSTRUCT( tree->left, b_tree );
		BU_GETSTRUCT( tree->right, b_tree );
		tree->left->root = sub;
		spl_bound( tree->left->root,
		    tree->left->min, tree->left->max);
		tree->left->left = tree->left->right = NULLTREE;

		tree->right->root = sub->next; 		
		spl_bound( tree->right->root,
		    tree->right->min, tree->right->max);
		tree->right->left = tree->right->right = NULLTREE;

		/* Now, release old "root" (leaf) */
		spl_sfree( tree->root );
		tree->root = (struct b_spline *) 0;
	}

	if ( rt_g.debug & DEBUG_SPLINE ) 
	    bu_log("spline: Left tree level %d\n", level);

	rt_spl_n_shoot( rp,  invdir,  tree->left, ap, level+1 );

	if ( rt_g.debug & DEBUG_SPLINE ) 
	    bu_log("spline: Right tree level %d\n", level);

	rt_spl_n_shoot( rp,  invdir,  tree->right, ap, level+1);
}

/*
 *			R T _ S P L _ S H O T _ P O L Y
 */
void
rt_spl_shot_poly( rp, tree, level )
struct xray *rp;
struct b_tree * tree;
int level;
{
	struct  spl_poly * _poly, *p, *tmp;
	struct  local_hit * h0;
	int hit_count;

	hit_count = 0;
	
	_poly = (struct spl_poly *) spl_to_poly( tree->root );

	for( p = _poly; p!= ( struct spl_poly *)0; p = p->next)
	{
		h0 = rt_spl_ray_poly( rp, p);
		if ( h0 != NULLHIT )
		{

			if ( rt_g.debug & DEBUG_SPLINE ) 
			    bu_log("spline: Hit found at level %d\n",
				level);
			hit_count++;
			rt_spl_add_hit( h0 );
			break;
		}
	}

	for ( p = _poly; p != (struct spl_poly *) 0;  )
	{
		tmp = p;
		p = p->next;
		bu_free( (char *)tmp, "rt_spl_shot_poly: polygon" );
	}

	if ( !hit_count && rt_g.debug & DEBUG_SPLINE )
	{
		bu_log("Bounding Box hit but no surface hit");
		VPRINT("min", tree->min);
		VPRINT("max", tree->max);
		rt_pr_spl("B_Spline surface", tree->root);
	}

}

#define EQ_HIT(a,b)	( ((a) - (b) ) < EPSILON)

/* If this is a duplicate of an existing hit point than
 * it means that the ray hit exactly on an edge of a patch 
 * subdivision and you need to thow out the extra hit.
 */

/*
 *			R T _ S P L _ A D D _ H I T
 */
void
rt_spl_add_hit( hit1 )
struct local_hit * hit1;
{

	register struct local_hit * h_ptr;

	if ( rt_spl_hit_head == NULLHIT) {
	        hit1 ->next = hit1-> prev = NULLHIT;
		rt_spl_hit_head = hit1;
		return;
	}

	/* check for duplicates */
	for( h_ptr = rt_spl_hit_head; h_ptr != NULLHIT; h_ptr = h_ptr->next)
	{
		if( EQ_HIT(hit1->hit_dist, h_ptr->hit_dist ) &&
		    EQ_HIT(hit1->hit_vpriv[0], h_ptr->hit_vpriv[0]) &&
		    EQ_HIT(hit1->hit_vpriv[1], h_ptr->hit_vpriv[1]) )
		{
			bu_free( (char *) hit1, "rt_spl_add_hit: duplicate");
			return;
		}
	}
	
	hit1->prev = NULLHIT;
	hit1->next = rt_spl_hit_head;
	rt_spl_hit_head->prev = hit1;
	rt_spl_hit_head = hit1;
}

/*
 *			R T _ S P L _ G E T _ N E X T _ H I T
 */
struct local_hit *
rt_spl_get_next_hit(  )
{
	register struct local_hit * list_ptr;
	struct local_hit *rt_hit = NULLHIT;
	fastf_t dist;

	dist = INFINITY;

	if (rt_spl_hit_head == NULLHIT)
		return NULLHIT;

	for( list_ptr = rt_spl_hit_head;
		list_ptr != NULLHIT; list_ptr = list_ptr->next )
	{
		if (list_ptr->hit_dist < dist )
		{
			rt_hit = list_ptr;
			dist = list_ptr->hit_dist;
		}
	}

					/* remove rtn_hit from list */
	if ( rt_hit != NULLHIT )
	{
	    if ( rt_spl_hit_head == rt_hit)
		rt_spl_hit_head = rt_hit->next;
	    if ( rt_hit->prev != NULLHIT)
		rt_hit->prev->next = rt_hit->next;
	    if ( rt_hit->next != NULLHIT)
		rt_hit->next->prev = rt_hit->prev;
  	    rt_hit->next = rt_hit->prev = NULLHIT;

	    return rt_hit;
	} else
		return NULLHIT;
}

/*
 *			R T _ S P L _ R A Y _ P O L Y
 */
struct local_hit *
rt_spl_ray_poly( rp, p1 )
struct xray * rp;
struct spl_poly * p1;
{
	register struct local_hit * h0;
	point_t pt1, pt2, pt3;
	point_t Q, B, norm;
	fastf_t d, offset, t;
	unsigned int i0, i1, i2;
	fastf_t NX, NY, NZ;

	norm[0] = (p1->ply[0])[1] * ((p1->ply[1])[2] - (p1->ply[2])[2]) + 
		  (p1->ply[1])[1] * ((p1->ply[2])[2] - (p1->ply[0])[2]) + 
		  (p1->ply[2])[1] * ((p1->ply[0])[2] - (p1->ply[1])[2]);

	norm[1] = -((p1->ply[0])[0] * ((p1->ply[1])[2] - (p1->ply[2])[2]) + 
		    (p1->ply[1])[0] * ((p1->ply[2])[2] - (p1->ply[0])[2]) + 
		    (p1->ply[2])[0] * ((p1->ply[0])[2] - (p1->ply[1])[2]));

	norm[2] = (p1->ply[0])[0] * ((p1->ply[1])[1] - (p1->ply[2])[1]) + 
		  (p1->ply[1])[0] * ((p1->ply[2])[1] - (p1->ply[0])[1]) + 
		  (p1->ply[2])[0] * ((p1->ply[0])[1] - (p1->ply[1])[1]);

	offset = -(
		(p1->ply[0])[0] * ((p1->ply[1])[1] * (p1->ply[2])[2] - 
	        (p1->ply[2])[1] * (p1->ply[1])[2]) + 

		(p1->ply[1])[0] * ((p1->ply[2])[1] * (p1->ply[0])[2] - 
	        (p1->ply[0])[1] * (p1->ply[2])[2]) +

    		(p1->ply[2])[0] * ((p1->ply[0])[1] * (p1->ply[1])[2] - 
		(p1->ply[1])[1] * (p1->ply[0])[2]));

	d = ((norm)[0] * (rp->r_dir)[0] + 
	    (norm)[1] * (rp->r_dir)[1] + 
	    (norm)[2] * (rp->r_dir)[2]);

	if ( fabs(d) < 0.0001 )
		return 0;

	t = -((
	    norm[0] * rp->r_pt[0] + 
	    norm[1] * rp->r_pt[1] + 
	    norm[2] * rp->r_pt[2]) + offset) / d;

	NX  = fabs( norm[X] );
	NY  = fabs( norm[Y] );
	NZ  = fabs( norm[Z] );

	i0 = 0; i1 = 1; i2 = 2;

	if ( NY > NX) { 
		i0 = 1; 
		i1 = 0; 
	}

	if ( NZ > NY) { 
		i0 = 2; 
		i1 = 1; 
		i2 = 0;
	}

	Q[i0] = rp->r_pt[i0] + rp->r_dir[i0] * t;
	Q[i1] = rp->r_pt[i1] + rp->r_dir[i1] * t;
	Q[i2] = rp->r_pt[i2] + rp->r_dir[i2] * t;

	VSUB2( pt1, (p1->ply[2]), (p1->ply[1]));
	VSUB2( pt2, Q, (p1->ply[1]));
	VCROSS( pt3, pt1, pt2 );
	B[X] = pt3[i0] / norm[i0];
	if( B[X] < 0.0 || B[X] > 1.0 )
		return 0;

	VSUB2( pt1, (p1->ply[0]), (p1->ply[2]));
	VSUB2( pt2, Q, (p1->ply[2]));
	VCROSS( pt3, pt1, pt2 );
	B[Y] = pt3[i0] / norm[i0];
	if( B[Y] < 0.0 || B[Y] > 1.0 )
		return 0;

	VSUB2( pt1, (p1->ply[1]), (p1->ply[0]));
	VSUB2( pt2, Q, (p1->ply[0]));
	VCROSS( pt3, pt1, pt2 );
	B[Z] = pt3[i0] / norm[i0];
	if( B[Z] < 0.0 || B[Z] > 1.0 )
		return 0;
		
	/* if we reach this point we have a hit */
	h0 = (struct local_hit *) bu_malloc ( sizeof ( struct local_hit ), 
		"rt_spl_ray_poly: hit point");

	h0->next = (struct local_hit *)0;
	h0->prev = (struct local_hit *)0;

	h0->hit_dist = t;
	VMOVE(h0->hit_normal, norm );
	VUNITIZE(h0->hit_normal);
	if( VDOT( rp->r_dir, h0->hit_normal ) > 0 )
		VREVERSE( h0->hit_normal, h0->hit_normal );
	
	VMOVE(h0->hit_point, Q);
	h0->hit_vpriv[0] = 
		((p1->uv[0][0] * B[0]) + (p1->uv[1][0] * B[1]) + 
		(p1->uv[2][0] * B[2]));
	h0->hit_vpriv[1] = 
		((p1->uv[0][1] * B[0]) + (p1->uv[1][1] * B[1]) + 
		(p1->uv[2][1] * B[2]));

	h0->hit_vpriv[2] = 0;			/* if set flip normal */

	h0->hit_private = (char *) curr_tree;
	
	if( rt_g.debug & DEBUG_SPLINE)
	{ 
		VPRINT("hit point", h0->hit_point);
		fprintf(stderr,"u = %f  v = %f\n ", h0->hit_vpriv[0], h0->hit_vpriv[1]);
	} 
	
	return h0;
}

/*
 *			R T _ S P L _ T E S S
 */
int
rt_spl_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
{
	struct rt_spl_internal	*sip;
	int	i;

	RT_CK_DB_INTERNAL(ip);
	sip = (struct rt_spl_internal *)ip->idb_ptr;
	RT_SPL_CK_MAGIC(sip);

	return(-1);
}

/*
 *			R T _ S P L _ I M P O R T
 *
 *  Read all the curves in as a two dimensional array.
 *  The caller is responsible for freeing the dynamic memory.
 *
 *  Note that in each curve array, the first point is replicated
 *  as the last point, to make processing the data easier.
 */
int
rt_spl_import( ip, ep, mat, dbip )
struct rt_db_internal	*ip;
CONST struct bu_external	*ep;
CONST mat_t			mat;
CONST struct db_i		*dbip;
{
	struct rt_spl_internal *sip;
	union record	*rp;
	register int	i, j;
	LOCAL vect_t	base_vect;
	int		currec;
	int		s;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	if( rp->u_id != ID_BSOLID )  {
		bu_log("rt_spl_import: defective header record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_type = ID_BSPLINE;
	ip->idb_meth = &rt_functab[ID_BSPLINE];
	ip->idb_ptr = bu_malloc(sizeof(struct rt_spl_internal), "rt_spl_internal");
	sip = (struct rt_spl_internal *)ip->idb_ptr;
	sip->magic = RT_SPL_INTERNAL_MAGIC;

	sip->nsurf = rp->B.B_nsurf;
	sip->resolution = rp->B.B_resolution;

	sip->surfs = (struct b_spline **)bu_malloc(
		sip->nsurf * sizeof(struct b_spline *), "spl surfs[]" );

	rp++;
	for( s = 0; s < sip->nsurf; s++ )  {
		register fastf_t	*mesh_ptr;
		int			epv;
		register dbfloat_t	*vp;

		if( rp->u_id != ID_BSURF )  {
			bu_log("rt_spl_import: defective surface record\n");
			return(-1);
		}
		/*
		 * Allocate memory for this surface.
	 	 */
		sip->surfs[s] = (struct b_spline *) spl_new(
			rp->d.d_order[0], rp->d.d_order[1],
			rp->d.d_kv_size[0], rp->d.d_kv_size[1],
			rp->d.d_ctl_size[0], rp->d.d_ctl_size[1],
			rp->d.d_geom_type );

		/* Read in the knot vectors and convert them to the 
		 * internal representation.
		 */
		vp = (dbfloat_t *) &rp[1];

		/* U knots */
		for( i = 0; i < rp->d.d_kv_size[0]; i++)
			sip->surfs[s]->u_kv->knots[i] = (fastf_t) *vp++;
		/* V knots */
		for( i = 0; i < rp->d.d_kv_size[1]; i++)
			sip->surfs[s]->v_kv->knots[i] =  (fastf_t) *vp++;

		spl_kvnorm( sip->surfs[s]->u_kv);
		spl_kvnorm( sip->surfs[s]->v_kv);

		/*
		 *  Transform the mesh control points in place,
		 *  in the b-spline data structure.
		 */
		vp = (dbfloat_t *) &rp[rp->d.d_nknots+1];
		mesh_ptr = sip->surfs[s]->ctl_mesh->mesh;
		epv = rp->d.d_geom_type;
		i = ( rp->d.d_ctl_size[0] * rp->d.d_ctl_size[1]);
		if( epv == P3 )  {
			for( ; i > 0; i--)  {
				MAT4X3PNT( mesh_ptr, mat, vp);
				mesh_ptr += P3;
				vp += P3;
			}
		} else if( epv == P4 )  {
			for( ; i > 0; i--)  {
				MAT4X4PNT( mesh_ptr, mat, vp);
				mesh_ptr += P4;
				vp += P4;
			}
		} else {
			bu_log("rt_spl_import:  %d invalid elements-per-vect\n", epv );
			return(-1);
		}
		rp += 1 + rp->d.d_nknots + rp->d.d_nctls;
	}
	return( 0 );
}

/*
 *			R T _ S P L _ E X P O R T
 *
 *  The name will be added by the caller.
 *  Generally, only libwdb will set conv2mm != 1.0
 */
int
rt_spl_export( ep, ip, local2mm, dbip )
struct bu_external	*ep;
CONST struct rt_db_internal	*ip;
double			local2mm;
CONST struct db_i		*dbip;
{
#if 0
	struct rt_spl_internal	*sip;
	union record		*rec;
	point_t		base_pt;
	int		per_curve_grans;
	int		cur;		/* current curve number */
	int		gno;		/* current granule number */

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_SPL )  return(-1);
	sip = (struct rt_spl_internal *)ip->idb_ptr;
	RT_SPL_CK_MAGIC(sip);

	per_curve_grans = (sip->pts_per_curve+7)/8;

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = (1 + per_curve_grans * sip->ncurves) *
		sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "spl external");
	rec = (union record *)ep->ext_buf;

	rec[0].a.a_id = ID_SPL_A;
	rec[0].a.a_type = SPL;			/* obsolete? */
	rec[0].a.a_m = sip->ncurves;
	rec[0].a.a_n = sip->pts_per_curve;
	rec[0].a.a_curlen = per_curve_grans;
	rec[0].a.a_totlen = per_curve_grans * sip->ncurves;

	VMOVE( base_pt, &sip->curves[0][0] );
	/* The later subtraction will "undo" this, leaving just base_pt */
	VADD2( &sip->curves[0][0], &sip->curves[0][0], base_pt);

	gno = 1;
	for( cur=0; cur<sip->ncurves; cur++ )  {
		register fastf_t	*fp;
		int			npts;
		int			left;

		fp = sip->curves[cur];
		left = sip->pts_per_curve;
		for( npts=0; npts < sip->pts_per_curve; npts+=8, left -= 8 )  {
			register int	el;
			register int	lim;
			register struct spl_ext	*bp = &rec[gno].b;

			bp->b_id = ID_SPL_B;
			bp->b_type = SPLCONT;	/* obsolete? */
			bp->b_n = cur+1;		/* obsolete? */
			bp->b_ngranule = (npts/8)+1; /* obsolete? */

			lim = (left > 8 ) ? 8 : left;
			for( el=0; el < lim; el++ )  {
				vect_t	diff;
				VSUB2SCALE( diff, fp, base_pt, local2mm );
				/* NOTE: also type converts to dbfloat_t */
				VMOVE( &(bp->b_values[el*3]), diff );
				fp += ELEMENTS_PER_VECT;
			}
			gno++;
		}
	}
#endif
	return(0);
}

/*
 *			R T _ S P L _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_spl_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
CONST struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
{
	register int			j;
	register struct rt_spl_internal	*sip =
		(struct rt_spl_internal *)ip->idb_ptr;
	char				buf[256];
	int				i;
	int				surf;

	RT_SPL_CK_MAGIC(sip);
	bu_vls_strcat( str, "arbitrary rectangular solid (SPL)\n");

	sprintf(buf, "\t%d surfaces, resolution=%g\n",
		sip->nsurf, sip->resolution );
	bu_vls_strcat( str, buf );

	for( surf=0; surf < sip->nsurf; surf++ )  {
		register struct b_spline	*sp;
		register struct b_mesh		*mp;

		sp = sip->surfs[surf];
		mp = sp->ctl_mesh;
		sprintf(buf, "\tSurface %d:  order %d * %d, mesh %d * %d\n",
			surf,
			sp->order[0],
			sp->order[1],
			mp->mesh_size[0],
			mp->mesh_size[1] );
		bu_vls_strcat( str, buf );

		sprintf(buf, "\t\tKnot vector %d + %d\n",
			sp->u_kv->k_size,
			sp->u_kv->k_size );
		bu_vls_strcat( str, buf );

		sprintf(buf, "\t\tV (%g, %g, %g)\n",
			mp->mesh[X] * mm2local,
			mp->mesh[Y] * mm2local,
			mp->mesh[Z] * mm2local );
		bu_vls_strcat( str, buf );

		if( !verbose )  continue;

		/* Print out all the points */
		for( i=0; i < mp->mesh_size[0]; i++ )  {
			register fastf_t *v = mp->mesh;

			sprintf( buf, "\Row %d:\n", i );
			bu_vls_strcat( str, buf );
			for( j=0; j < mp->mesh_size[1]; j++ )  {
				sprintf(buf, "\t\t(%g, %g, %g)\n",
					v[X] * mm2local,
					v[Y] * mm2local,
					v[Z] * mm2local );
				bu_vls_strcat( str, buf );
				v += ELEMENTS_PER_VECT;
			}
		}
	}

	return(0);
}

/*
 *			R T _ S P L _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_spl_ifree( ip )
struct rt_db_internal	*ip;
{
	register struct rt_spl_internal	*sip;
	register int			i;

	RT_CK_DB_INTERNAL(ip);
	sip = (struct rt_spl_internal *)ip->idb_ptr;
	RT_SPL_CK_MAGIC(sip);

	/*
	 *  Free storage for faces
	 */
	for( i = 0; i < sip->nsurf; i++ )  {
		spl_sfree( sip->surfs[i] );
	}
	sip->magic = 0;		/* sanity */
	sip->nsurf = 0;
	bu_free( (char *)sip, "spl ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}
@


11.9
log
@
export methods should not init the external structure, just check them.
@
text
@@


11.8
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d1215 1
a1215 1
	BU_INIT_EXTERNAL(ep);
@


11.7
log
@
Lint cleanups
@
text
@d1111 1
a1111 1
	RT_INIT_DB_INTERNAL( ip );
@


11.6
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d229 1
a229 1
struct bn_tol		*tol;
d1069 1
a1069 1
struct bn_tol		*tol;
d1091 1
a1091 1
rt_spl_import( ip, ep, mat )
d1093 3
a1095 2
struct bu_external	*ep;
mat_t			mat;
d1194 1
a1194 1
rt_spl_export( ep, ip, local2mm )
d1196 1
a1196 1
struct rt_db_internal	*ip;
d1198 1
d1275 1
a1275 1
struct rt_db_internal	*ip;
@


11.5
log
@
Removed dependence on compat4.h
@
text
@d1112 1
@


11.4
log
@
sed4
@
text
@d264 1
a264 1
			RT_ADD_VLIST( vhead, vp, RT_VLIST_LINE_MOVE );
d268 1
a268 1
				RT_ADD_VLIST( vhead, vp, RT_VLIST_LINE_DRAW );
d278 1
a278 1
			RT_ADD_VLIST( vhead, vp, RT_VLIST_LINE_MOVE );
d281 1
a281 1
				RT_ADD_VLIST( vhead, vp, RT_VLIST_LINE_DRAW );
@


11.3
log
@Converted to bu_semaphore_acquire()
@
text
@d37 1
a37 1
#define RT_SPL_CK_MAGIC(_p)	RT_CKMAG(_p,RT_SPL_INTERNAL_MAGIC,"rt_spl_internal")
d128 3
a130 3
		GETSTRUCT( s_tree, b_head );
		GETSTRUCT( s_tree->left, b_tree );
		GETSTRUCT( s_tree->right, b_tree );
d190 1
a190 1
		rt_log("spline(%s):  no surfaces\n", stp->st_name);
d226 1
a226 1
struct rt_list		*vhead;
d229 1
a229 1
struct rt_tol		*tol;
d426 1
a426 1
		rt_log("rt_spl_curve: bad mesh point type %d\n",
d443 1
a443 1
		rt_log("first fundamental form is singular E = %g F = %g G = %g\n",
d478 6
a483 6
	rt_free( (char *)s_eval, "spl_curve:s_eval");
	rt_free( (char *)u_eval, "spl_curve:u_eval");
	rt_free( (char *)v_eval, "spl_curve:v_eval");
	rt_free( (char *)u2_eval, "spl_curve:u2_eval");
	rt_free( (char *)v2_eval, "spl_curve:v2_eval");
	rt_free( (char *)uv_eval, "spl_curve:uv_eval");
d504 1
a504 1
		rt_free( (char *)nlist, "rt_spl_free: b_head structure");
d536 1
a536 1
	rt_free( (char *)rootp, "rt_spl_n_free: tree structure ");
d615 1
a615 1
		rt_free( (char *)spl_eval, "rt_spl_curve: spl_eval" );
d619 1
a619 1
		rt_log("rt_spl_curve: bad mesh point type %d\n",
d629 2
a630 2
	rt_free( (char *)u_eval, "rt_spl_curve: u_eval" );
	rt_free( (char *)v_eval, "rt_spl_curve: v_eval" );
d709 1
a709 1
			rt_free( (char *)hit2, "rt_spl_shot: hit point");
d720 1
a720 1
		rt_free( (char *)hit1, "rt_spl_shot: hit point");
d722 1
a722 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d776 2
a777 2
		GETSTRUCT( tree->left, b_tree );
		GETSTRUCT( tree->right, b_tree );
d794 1
a794 1
	    rt_log("spline: Left tree level %d\n", level);
d799 1
a799 1
	    rt_log("spline: Right tree level %d\n", level);
d828 1
a828 1
			    rt_log("spline: Hit found at level %d\n",
d840 1
a840 1
		rt_free( (char *)tmp, "rt_spl_shot_poly: polygon" );
d845 1
a845 1
		rt_log("Bounding Box hit but no surface hit");
d883 1
a883 1
			rt_free( (char *) hit1, "rt_spl_add_hit: duplicate");
d1027 1
a1027 1
	h0 = (struct local_hit *) rt_malloc ( sizeof ( struct local_hit ), 
d1069 1
a1069 1
struct rt_tol		*tol;
d1093 1
a1093 1
struct rt_external	*ep;
d1103 1
a1103 1
	RT_CK_EXTERNAL( ep );
d1106 1
a1106 1
		rt_log("rt_spl_import: defective header record\n");
d1112 1
a1112 1
	ip->idb_ptr = rt_malloc(sizeof(struct rt_spl_internal), "rt_spl_internal");
d1119 1
a1119 1
	sip->surfs = (struct b_spline **)rt_malloc(
d1129 1
a1129 1
			rt_log("rt_spl_import: defective surface record\n");
d1177 1
a1177 1
			rt_log("rt_spl_import:  %d invalid elements-per-vect\n", epv );
d1193 1
a1193 1
struct rt_external	*ep;
d1212 1
a1212 1
	RT_INIT_EXTERNAL(ep);
d1215 1
a1215 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "spl external");
d1271 1
a1271 1
struct rt_vls		*str;
d1284 1
a1284 1
	rt_vls_strcat( str, "arbitrary rectangular solid (SPL)\n");
d1288 1
a1288 1
	rt_vls_strcat( str, buf );
d1302 1
a1302 1
		rt_vls_strcat( str, buf );
d1307 1
a1307 1
		rt_vls_strcat( str, buf );
d1313 1
a1313 1
		rt_vls_strcat( str, buf );
d1322 1
a1322 1
			rt_vls_strcat( str, buf );
d1328 1
a1328 1
				rt_vls_strcat( str, buf );
d1361 1
a1361 1
	rt_free( (char *)sip, "spl ifree" );
@


11.2
log
@*** empty log message ***
@
text
@d667 1
a667 1
	RES_ACQUIRE( &rt_g.res_model );	
d682 1
a682 1
		RES_RELEASE( &rt_g.res_model );	
d724 1
a724 1
	RES_RELEASE( &rt_g.res_model );	
@


11.1
log
@Release_4.4
@
text
@d813 1
a813 1
	struct  spl_poly * poly, *p, *tmp;
d819 1
a819 1
	poly = (struct spl_poly *) spl_to_poly( tree->root );
d821 1
a821 1
	for( p = poly; p!= ( struct spl_poly *)0; p = p->next)
d836 1
a836 1
	for ( p = poly; p != (struct spl_poly *) 0;  )
@


9.11
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@@


9.10
log
@Converted to new tolerance interface
@
text
@d109 1
a109 1
rt_spl_prep( stp, ip, rtip, tol )
a112 1
CONST struct rt_tol	*tol;
d649 1
a649 1
rt_spl_shot( stp,  rp, ap, seghead, tol )
a653 1
CONST struct rt_tol	*tol;
@


9.9
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d109 1
a109 1
rt_spl_prep( stp, ip, rtip )
d113 1
d226 1
a226 1
rt_spl_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
d229 2
a230 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
d650 1
a650 1
rt_spl_shot( stp,  rp, ap, seghead )
d655 1
d1066 1
a1066 1
rt_spl_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d1070 2
a1071 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
@


9.8
log
@Eliminated mat parameter on ft_plot and ft_tess
@
text
@d226 1
a226 1
struct vlhead		*vhead;
d265 1
a265 1
			ADD_VL( vhead, vp, 0 );
d269 1
a269 1
				ADD_VL( vhead, vp, 1 );
d279 1
a279 1
			ADD_VL( vhead, vp, 0 );
d282 1
a282 1
				ADD_VL( vhead, vp, 1 );
@


9.7
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d225 6
a230 7
rt_spl_plot( vhead, mat, ip, abs_tol, rel_tol, norm_tol )
struct vlhead	*vhead;
mat_t		mat;
struct rt_db_internal *ip;
double		abs_tol;
double		rel_tol;
double		norm_tol;
d1065 1
a1065 1
rt_spl_tess( r, m, ip, mat, abs_tol, rel_tol, norm_tol )
d1069 3
a1071 4
register mat_t		mat;
double		abs_tol;
double		rel_tol;
double		norm_tol;
@


9.6
log
@pretty printing
@
text
@a107 1
#if NEW_IF
a113 10
#else
int
rt_spl_prep( stp, rec, rtip )
struct soltab	*stp;
union record	*rec;
struct rt_i	*rtip;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a117 12
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rec;
	ep->ext_nbytes = stp->st_dp->d_len*sizeof(union record);
	ip = &intern;
	if( rt_spl_import( ip, ep, stp->st_pathmat ) < 0 )
		return(-1);		/* BAD */
	RT_CK_DB_INTERNAL( ip );
#endif
a223 1
#if NEW_IF
a232 11
#else
int
rt_spl_plot( rp, mat, vhead, dp )
union record	*rp;
mat_t		mat;
struct vlhead	*vhead;
struct directory *dp;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a238 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_spl_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_spl_plot(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
a1064 1
#if NEW_IF
a1074 15
#else
int
rt_spl_tess( r, m, rp, mat, dp, abs_tol, rel_tol, norm_tol )
struct nmgregion	**r;
struct model		*m;
union record		*rp;
mat_t			mat;
struct directory	*dp;
double			abs_tol;
double			rel_tol;
double			norm_tol;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a1077 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_spl_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_spl_tess(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
@


9.5
log
@Converted to new import/export interface.
(export subroutine still to be done0
@
text
@d1387 1
a1387 1
		sprintf(buf, "\tKnot vector %d + %d\n",
d1392 1
a1392 1
		sprintf(buf, "\tV (%g, %g, %g)\n",
@


9.4
log
@Converted seg structures to use doubly linked lists.
@
text
@d30 9
a99 20
/*
 *			R T _ S P L _ R E A D I N
 *
 *  Take an in-memory array of database records, and produce a
 *  (struct b_spline) object.
 *
 *  Since the record granuals are not in the internal format,
 *  we need to declare some of the variables as dbfloat_t and not
 *  fastf_t.
 */
HIDDEN struct b_spline *
rt_spl_readin( drec, mat )
union record	*drec;
matp_t		mat;
{
	register int		i;
	struct b_spline		*new_srf;
	register fastf_t	*mesh_ptr;
	int			epv;
	register dbfloat_t	*vp;
a100 57
	if ( drec[0].u_id != ID_BSURF )  {
		rt_log("rt_spl_readin:  bad record 0%o\n", drec[0].u_id);
		return( SPL_NULL );
	}

	/*
	 * Allocate memory for a new surface.
 	 */
	new_srf = (struct b_spline *) spl_new(
		drec[0].d.d_order[0], drec[0].d.d_order[1],
		drec[0].d.d_kv_size[0], drec[0].d.d_kv_size[1],
		drec[0].d.d_ctl_size[0], drec[0].d.d_ctl_size[1],
		drec[0].d.d_geom_type );

	/* Read in the knot vectors and convert them to the 
	 * internal representation.
	 */
	vp = ( dbfloat_t *) &drec[1];

	/* U knots */
	for( i = 0; i < drec[0].d.d_kv_size[0]; i++)
		new_srf->u_kv->knots[i] = (fastf_t) *vp++;
	/* V knots */
	for( i = 0; i < drec[0].d.d_kv_size[1]; i++)
		new_srf->v_kv->knots[i] =  (fastf_t) *vp++;

	spl_kvnorm( new_srf->u_kv);
	spl_kvnorm( new_srf->v_kv);

	/*
	 *  Transform the mesh control points in place,
	 *  in the b-spline data structure.
	 */
	vp = (dbfloat_t *) &drec[drec[0].d.d_nknots+1];
	mesh_ptr = new_srf->ctl_mesh->mesh;
	epv = drec[0].d.d_geom_type;
	i = ( drec[0].d.d_ctl_size[0] * drec[0].d.d_ctl_size[1]);
	if( epv == P3 )  {
		for( ; i > 0; i--)  {
			MAT4X3PNT( mesh_ptr, mat, vp);
			mesh_ptr += P3;
			vp += P3;
		}
	} else if( epv == P4 )  {
		for( ; i > 0; i--)  {
			MAT4X4PNT( mesh_ptr, mat, vp);
			mesh_ptr += P4;
			vp += P4;
		}
	} else {
		rt_log("rt_spl_readin:  %d invalid elements-per-vect\n", epv );
		return( SPL_NULL );	/* BAD */
	}
	return( new_srf );
}


d108 1
d110 8
a117 1
rt_spl_prep( stp, rp, rtip )
d119 1
a119 1
union record	*rp;
d122 6
a127 3
	struct b_head  *nlist = (struct b_head *) 0;
	int		n_srfs;
	int		currec;
d129 14
a142 2
	n_srfs = rp[0].B.B_nsurf;
	currec = 1;		/* rp[0] has header record */
d144 1
a144 1
	while (n_srfs-- > 0) {
d149 1
a149 6
		if( (new_srf = rt_spl_readin( &rp[currec], stp->st_pathmat )) == SPL_NULL )  {
			rt_log("rt_spl_prep(%s):  database read error\n",
				stp->st_name);
			return( -1 );
		}
		currec += 1 + rp[currec].d.d_nknots + rp[currec].d.d_nctls;
d154 2
d185 1
d187 1
a187 5
	stp->st_specific = (genptr_t)nlist;
	VSET( stp->st_center,
	    (stp->st_max[0] + stp->st_min[0])/2,
	    (stp->st_max[1] + stp->st_min[1])/2,
	    (stp->st_max[2] + stp->st_min[2])/2 );
d247 1
d249 10
d265 4
d272 1
a272 2
	int		cur_gran;
	int		n_srfs;
d274 17
a290 2
	n_srfs = rp[0].B.B_nsurf;
	cur_gran = 1;
d292 1
a292 1
	while( n_srfs-- > 0 )  {
d295 1
a295 14
		if( (new = rt_spl_readin( &rp[cur_gran], mat )) == SPL_NULL )  {
			rt_log("rt_spl_plot(%s):  database read error\n",
				dp->d_namep);
			return(-1);
		}
		if ( rt_g.debug & DEBUG_SPLINE )  {
			rt_log("%s surf %d: %d x %d\n",
				dp->d_namep,
				n_srfs,
				new->ctl_mesh->mesh_size[0],
				new->ctl_mesh->mesh_size[1] );
		}
		cur_gran += 1 + rp[cur_gran].d.d_nknots + rp[cur_gran].d.d_nctls;

a334 1
		spl_sfree( new );
d1114 1
d1116 8
a1123 1
rt_spl_tess()
d1125 36
d1162 284
@


9.3
log
@Routines all got rt_spl_ prefixes
@
text
@d730 1
a730 1
 *  	segp	HIT
d735 6
a740 5
struct seg *
rt_spl_shot( stp,  rp, ap)
struct soltab *stp;
register struct xray *rp;
struct application * ap;
d770 1
a770 1
		return (SEG_NULL);
a772 2
	GET_SEG( segp, ap->a_resource );

d778 2
d809 1
a809 6
		if ( rt_spl_hit_head != NULLHIT)
		{
			GET_SEG( seg2p, ap->a_resource);
			seg2p->seg_next = segp;
			segp =  seg2p;
		}
d812 1
a812 1
	return segp;
@


9.2
log
@Changed type of st_specific to genptr_t
@
text
@d2 1
a2 1
 *       S P L I N E . C
d66 1
a66 1
struct local_hit * spl_hit_head = NULLHIT;
d82 6
a87 4
void	n_shoot();		/* XXX needs an rt_ or spl_ name */
void	add_hit();		/* XXX */
void	n_free();		/* XXX */
void	shot_poly();		/* XXX */
d92 1
a92 1
 *			S P L _ R E A D I N
d102 1
a102 1
spl_readin( drec, mat )
d113 1
a113 1
		rt_log("spl_readin:  bad record 0%o\n", drec[0].u_id);
d162 1
a162 1
		rt_log("spl_readin:  %d invalid elements-per-vect\n", epv );
d170 1
a170 1
 *			S P L _ P R E P
d177 1
a177 1
spl_prep( stp, rp, rtip )
d194 2
a195 2
		if( (new_srf = spl_readin( &rp[currec], stp->st_pathmat )) == SPL_NULL )  {
			rt_log("spl_prep(%s):  database read error\n",
d255 1
a255 1
 * S P L _ P R I N T
d258 1
a258 1
spl_print( stp )
d273 1
a273 1
 *	S P L _ U V
d276 1
a276 1
spl_uv(ap, stp, hitp, uvp)
d290 1
a290 1
spl_class()
d296 1
a296 1
 *			S P L _ P L O T
d298 2
a299 2
void
spl_plot( rp, mat, vhead, dp )
d317 2
a318 2
		if( (new = spl_readin( &rp[cur_gran], mat )) == SPL_NULL )  {
			rt_log("spl_plot(%s):  database read error\n",
d320 1
a320 1
			return;
d372 1
d376 1
a376 1
 *			S P L _ C U R V E
d379 1
a379 1
spl_curve( cvp, hitp, stp )
d513 1
a513 1
		rt_log("spl_curve: bad mesh point type %d\n",
d574 1
a574 1
 *			S P L _ F R E E
d577 1
a577 1
spl_free( stp )
d586 2
a587 2
		n_free( nlist->left );
		n_free( nlist->right );
d591 1
a591 1
		rt_free( (char *)nlist, "spl_free: b_head structure");
d597 3
d601 1
a601 1
n_free( tree)
d611 1
a611 1
		n_free( leftp );
d617 1
a617 1
		n_free( rightp );
d623 1
a623 1
	rt_free( (char *)rootp, "n_free: tree structure ");
d628 1
a628 1
 *	S P L _ N O R M
d631 1
a631 1
spl_norm(hitp, stp, rp)
d702 1
a702 1
		rt_free( (char *)spl_eval, "ray_poly: spl_eval" );
d706 1
a706 1
		rt_log("spl_curve: bad mesh point type %d\n",
d716 2
a717 2
	rt_free( (char *)u_eval, "ray_poly: u_eval" );
	rt_free( (char *)v_eval, "ray_poly: v_eval" );
d724 2
a725 1
 * S P L _ S H O T 
d736 1
a736 1
spl_shot( stp,  rp, ap)
d758 2
a759 2
		n_shoot( rp, invdir, nlist->left,  ap, 0 );
		n_shoot( rp, invdir, nlist->right, ap, 0 );
d766 1
a766 1
	if (spl_hit_head == NULLHIT )
d774 1
a774 1
	while ( spl_hit_head != NULLHIT)
a777 1
		struct local_hit * get_next_hit();
d779 2
a780 2
		hit1 = get_next_hit( );
		hit2 = get_next_hit( );
d795 1
a795 1
			rt_free( (char *)hit2, "spl_shot: hit point");
d806 1
a806 1
		rt_free( (char *)hit1, "spl_shot: hit point");
d808 1
a808 1
		if ( spl_hit_head != NULLHIT)
d819 3
d823 1
a823 1
n_shoot( rp,  invdir,  tree, ap, level)
d845 1
a845 1
			rt_pr_spl("n_shoot: bad tree root", tree->root);
d852 1
a852 1
			shot_poly( rp,  tree, level);
d887 1
a887 1
	n_shoot( rp,  invdir,  tree->left, ap, level+1 );
d892 1
a892 1
	n_shoot( rp,  invdir,  tree->right, ap, level+1);
d895 3
d899 1
a899 1
shot_poly( rp, tree, level )
d905 1
a905 1
	struct  local_hit * h0, * ray_poly();
d914 1
a914 1
		h0 = ray_poly( rp, p);
d922 1
a922 1
			add_hit( h0 );
d931 1
a931 1
		rt_free( (char *)tmp, "shot_poly: polygon" );
d951 3
d955 1
a955 1
add_hit( hit1 )
d961 1
a961 1
	if ( spl_hit_head == NULLHIT) {
d963 1
a963 1
		spl_hit_head = hit1;
d968 1
a968 1
	for( h_ptr = spl_hit_head; h_ptr != NULLHIT; h_ptr = h_ptr->next)
d974 1
a974 1
			rt_free( (char *) hit1, "add_hit: duplicate");
d980 3
a982 3
	hit1->next = spl_hit_head;
	spl_hit_head->prev = hit1;
	spl_hit_head = hit1;
d985 3
d989 1
a989 1
get_next_hit(  )
d997 1
a997 1
	if (spl_hit_head == NULLHIT)
d1000 1
a1000 1
	for( list_ptr = spl_hit_head;
d1013 2
a1014 2
	    if ( spl_hit_head == rt_hit)
		spl_hit_head = rt_hit->next;
d1026 3
a1028 1

d1030 1
a1030 1
ray_poly( rp, p1 )
d1119 1
a1119 1
		"ray_poly: hit point");
d1149 9
@


9.1
log
@Release_3.5
@
text
@d232 1
a232 1
	stp->st_specific = (int *)nlist;
@


8.7
log
@Calling sequence to xxx_prep() shortened from 6 to 3 args.
Database conversion moved into prep routines.
@
text
@@


8.6
log
@lint (removed some unused variables)
@
text
@d175 1
a175 2
spl_prep( vec,  stp,  mat, rp, rtip, dp )
register fastf_t *vec;
a176 1
matp_t		mat;
a178 1
struct directory *dp;
d192 1
a192 1
		if( (new_srf = spl_readin( &rp[currec], mat )) == SPL_NULL )  {
@


8.5
log
@Fixed a number of bugs in particular the case where the ray hits the
edge of a polygon is now found, which caused another problem in that
there may be two hits from adjacent polygons. The extra hit point was deleted.
@
text
@a183 1
	register int    i;
a308 1
	register fastf_t *mesh;
a338 2
				static hvect_t	homog;

a431 1
		vect_t		u_norm;
d893 1
a1019 1
	fastf_t uv[2];
a1132 2


@


8.4
log
@Changed some floats to fastf_t. Alliant compiler correctly warned
that INFINITY would not fit into a "float", only a double.
@
text
@a66 1
int hit_count;
a83 1
void	interp_uv();		/* XXX */
d209 1
a209 1
		s_split = (struct b_spline * ) spl_split( new_srf, 0);
a229 2
			rt_pr_spl( "left  surface", s_tree->left->root );
			rt_pr_spl( "right  surface",s_tree->right->root );
d284 1
d287 1
a753 2
	hit_count = 0;

d759 2
a760 2
		n_shoot( rp, invdir, nlist->left,  ap, 1, 0 );
		n_shoot( rp, invdir, nlist->right, ap, 1, 0 );
a820 2
#define OTHERDIR(dir)	( (dir == 0)? 1:0)

d822 1
a822 1
n_shoot( rp,  invdir,  tree, ap, dir, level)
a826 1
int dir;
d849 1
a849 1
		if (flat)
d856 1
a856 1
		spl_split( tree->root, dir);
d886 1
a886 2
	n_shoot( rp,  invdir,  tree->left, ap,
	    OTHERDIR(dir), level+1 );
d891 1
a891 2
	n_shoot( rp,  invdir,  tree->right, ap,
	    OTHERDIR(dir), level+1);
d901 3
d932 2
d939 7
d950 3
d957 4
a960 1
	} else
d962 7
a968 4
		hit1->prev = NULLHIT;
		hit1->next = spl_hit_head;
		spl_hit_head->prev = hit1;
		spl_hit_head = hit1;
d970 5
a1015 8

#define V_CROSS_SIGN( a, b )  	(( ((a[0] * b[1] - a[1] * b[0]) + (a[1] * b[2] - a[2] * b[1]) +	(a[0] * b[2] - a[2] * b[0])) >= 0.0)? 1 : 0)

struct plane {				/* Plane definition */
        point_t  nrm;			/* Plane Normal */
	fastf_t  offset;			/* Plane Offset */
};

d1021 7
a1027 5
	point_t itr_point;
	vect_t b_minus_a, c_minus_b, a_minus_c, itr_cross;
	struct local_hit * h0;
	fastf_t uv[2], tmp;
	struct plane plane_form(), pln;
d1029 3
a1031 2
	fastf_t denom, t;
	int curr_sign;
d1033 3
a1035 1
	pln = plane_form( p1->ply[0], p1->ply[1], p1->ply[2] );
d1037 3
a1039 1
	denom = VDOT( pln.nrm, rp->r_dir);
d1041 3
a1043 2
	if (APX_EQ( denom, 0.0))
		return (struct local_hit *) 0;
d1045 2
a1046 1
	t = - (VDOT( pln.nrm, rp->r_pt) + pln.offset)/ denom;
d1048 2
a1049 2
	if ( t < 0.0005  )
		return (struct local_hit *) 0;
d1051 3
a1053 1
	VJOIN1( itr_point, rp->r_pt, t, rp->r_dir);
d1055 2
a1056 2
	VSUB2( b_minus_a, p1->ply[1], p1->ply[0]);
	VSUB2( c_minus_b, p1->ply[2], p1->ply[1]);
d1058 4
a1061 2
	VSUB2( itr_cross, itr_point, p1->ply[0]);
	curr_sign = V_CROSS_SIGN( b_minus_a, itr_cross);
d1063 3
a1065 3
	VSUB2( itr_cross, itr_point, p1->ply[1]);
	if ( V_CROSS_SIGN( c_minus_b, itr_cross) != curr_sign )
		return (struct local_hit *) 0;
d1067 37
a1103 4
	VSUB2( a_minus_c, p1->ply[0], p1->ply[2]);
	VSUB2( itr_cross, itr_point, p1->ply[2]);
	if ( V_CROSS_SIGN( a_minus_c, itr_cross) != curr_sign )
		return (struct local_hit *) 0;
a1105 1

a1110 2
		
	interp_uv( p1, itr_point, uv );
d1113 1
a1113 8

	/* This is a hack */
	/* If a surface is linear in either direction than
	 * the normal must be approximated since the dirivatives
	 * can't be used to calculate the normal.
         */

	VMOVE(h0->hit_normal, pln.nrm );
d1118 7
a1124 2
	VMOVE(h0->hit_point, itr_point);
	h0->hit_vpriv[0] = uv[0];
a1125 1
	h0->hit_vpriv[1] = uv[1];
d1127 1
d1133 1
a1138 13
/*****************************************************************
 * TAG( plane_form )
 * 
 * Form the plane equation from three points.
 * Inputs:
 * 	Three homogeneous 4 points a, b, and c.
 * Outputs:
 * 	A plane equation.
 * Assumptions:
 *	[None]
 * Algorithm:
 * 	Cross product expansion from Foley and Van Dam
 */
a1139 65
struct plane
plane_form( a, b, c )
point_t a, b, c;
{
    struct plane plane_p;

    fastf_t x1, y1, z1, x2, y2, z2, x3, y3, z3;

    x1 = a[0];
    y1 = a[1];
    z1 = a[2];
    x2 = b[0];
    y2 = b[1];
    z2 = b[2];
    x3 = c[0];
    y3 = c[1];
    z3 = c[2];

    plane_p.nrm[0] = y1 * (z2 - z3) + y2 * (z3 - z1) + y3 * (z1 - z2);
    plane_p.nrm[1] = -(x1 * (z2 - z3) + x2 * (z3 - z1) + x3 * (z1 - z2));
    plane_p.nrm[2] = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2);

    plane_p.offset = -(x1 * (y2 * z3 - y3 * z2) + x2 * (y3 * z1 - y1 * z3)
			+ x3 * (y1 * z2 - y2 * z1));

    return plane_p;
}

void
interp_uv( p1, itr,uv )
fastf_t uv[2];
point_t itr;
struct spl_poly * p1;
{
	point_t tmp, b_minus_a, c_minus_a,
		d_minus_a;

	fastf_t r, s, t, area_s, area_t, area;

	VSUB2( b_minus_a, p1->ply[1], p1->ply[0]);
	VSUB2( c_minus_a, p1->ply[2], p1->ply[0]);

	VCROSS( tmp, b_minus_a, c_minus_a );
	area = MAGNITUDE( tmp );

	if (area <= 0.0)
		fprintf( stderr, "interp_norm: polygon has zero area\n");

	VSUB2( d_minus_a, itr, p1->ply[0] );
	
	VCROSS( tmp, b_minus_a, d_minus_a );
	area_t = MAGNITUDE( tmp );

	VCROSS( tmp, d_minus_a, c_minus_a );
	area_s = MAGNITUDE( tmp );

	t = area_t / area;
	s = area_s / area;
	r = 1.0 - s - t;

	uv[0] = (fastf_t)
		((p1->uv[0][0] * r) + (p1->uv[1][0] * s) + (p1->uv[2][0] * t));
	uv[1] = (fastf_t)
		((p1->uv[0][1] * r) + (p1->uv[1][1] * s) + (p1->uv[2][1] * t));
}
@


8.3
log
@Added _plot() routines, and db_*() interfaces.
@
text
@d965 1
a965 1
	float dist;
d1018 1
a1018 1
	float denom, t;
@


8.2
log
@a couple of uncovered bases that gcc picked up
@
text
@d89 80
d170 1
a170 1
 * S P L _ P R E P
a175 5

/* Since the record granuals consist of floating point values
 * we need to declare some of the read variables as dbfloat_t and not
 * fastf_t.
 */
d177 7
a183 6
spl_prep( vec,  stp,  mat, sp, rtip)
register fastf_t * vec;
struct soltab *stp;
matp_t mat;
struct solidrec *sp;
struct rt_i * rtip;
a184 1
	struct B_solid * bp;
a185 1
	static union record rec;
d187 2
a188 1
	int n_srfs;
d190 2
a191 1
	bp = (struct B_solid *) sp;
a192 2
	n_srfs = bp->B_nsurf;

a196 5
		int nbytes, nby;
		dbfloat_t * vp;
		dbfloat_t * fp;
		fastf_t * mesh_ptr;
		int epv;
d198 4
a201 8
		i = fread( (char *) &rec, sizeof(rec), 1, rtip->fp );

		if( i != 1 )
			rt_bomb("spl_prep: read error");

		if ( rec.u_id != ID_BSURF )
		{
			break;
d203 1
a204 63
		/* Read in the knot vectors and convert them to the 
		 * internal representation.
		 */
		nbytes = rec.d.d_nknots * sizeof( union record );
		fp = vp = ( dbfloat_t *) rt_malloc( nbytes, "spl knots" );
		if ( fread( (char *) vp, nbytes, 1, rtip->fp ) != 1 )
		{
			break;
		}

		epv = rec.d.d_geom_type;

		/* If everything up to here is ok then allocate memory
		 * for a surface.
	 	 */
		new_srf = (struct b_spline *) spl_new(
			rec.d.d_order[0], rec.d.d_order[1],
			rec.d.d_kv_size[0], rec.d.d_kv_size[1],
			rec.d.d_ctl_size[0], rec.d.d_ctl_size[1],
			rec.d.d_geom_type );

		for( i = 0; i < rec.d.d_kv_size[0]; i++){	/* U knots */
			new_srf->u_kv->knots[i] = (fastf_t) *vp++;
		}
		for( i = 0; i < rec.d.d_kv_size[1]; i++)	/* V knots */
			new_srf->v_kv->knots[i] =  (fastf_t) *vp++;

		rt_free( (char *) fp, "spl_prep: fp" );

		/* Read in the mesh control points and convert them to
		 * the b-spline data structure.
		 */
		nby = rec.d.d_nctls * sizeof( union record);
		fp = vp = (dbfloat_t *) rt_malloc(nby,  "control mesh");
		if( fread((char *) vp,  nby,  1, rtip->fp) != 1)
			break;

		spl_kvnorm( new_srf->u_kv);
		spl_kvnorm( new_srf->v_kv);

		mesh_ptr = new_srf->ctl_mesh->mesh;

		i = ( rec.d.d_ctl_size[0] * rec.d.d_ctl_size[1]);
		if( epv == P3 )  {
			for( ; i > 0; i--)  {
				MAT4X3PNT( mesh_ptr, mat, vp);
				mesh_ptr += P3;
				vp += P3;
			}
		} else if( epv == P4 )  {
			for( ; i > 0; i--)  {
				MAT4X4PNT( mesh_ptr, mat, vp);
				mesh_ptr += P4;
				vp += P4;
			}
		} else {
			rt_log("%s:  %d not valid elements-per-vect\n",
				stp->st_name, epv );
			return(-1);	/* BAD */
		}

		rt_free( (char *) fp,  "free up mesh points");

d299 3
d303 5
a307 1
spl_plot()
d309 70
@


8.1
log
@Release_3.0
@
text
@d439 4
d491 1
d628 6
d884 1
a884 1
	struct local_hit * rt_hit;
@


7.7
log
@added new and improved curvature routines..
-Paul
@
text
@@


7.6
log
@lint fixes
@
text
@d315 2
a316 1
	fastf_t         E, F, G, e, f, g;
d318 4
a321 3
	fastf_t         denom, a11, a12, a21, a22, a, b, c;
	vect_t          vec1, vec2;
	vect_t          uvec, vvec;
d349 1
a349 1
		E = VDOT(v_eval, v_eval);
d351 3
a353 3
		e = VDOT(norm, u2_eval);
		f = VDOT(norm, uv_eval);
		g = VDOT(norm, v2_eval);
d436 3
a438 3
		e = VDOT(norm, u2e);
		f = VDOT(norm, uve);
		g = VDOT(norm, v2e);
d443 2
a444 1
	a11 = (( f * F ) -  (e * G) ) / denom;
d446 1
a446 1
	a21 = ((e*F) - (f * E))/ denom;
d448 2
a449 1
	a12 = ((g * F) - (f * G))/ denom;
d451 6
a456 1
	a22 = ((f * F) - (g * E))/ denom;
d458 4
a461 3
	a = 1.0;
	b = - ( a11 +  a22);
	c = (a11 * a22) - (a12 * a21);
a462 2
	vec_ortho( uvec, hitp->hit_normal );
	VCROSS( vvec, hitp->hit_normal, uvec );
d464 21
a484 2
	eigen2x2( &cvp->crv_c1, &cvp->crv_c2, vec1, vec2, a, b, c );
	VCOMB2( cvp->crv_pdir, vec1[X], uvec, vec1[Y], vvec );
@


7.5
log
@more lint
@
text
@d460 6
a465 6
	rt_free(s_eval, "spl_curve:s_eval");
	rt_free(u_eval, "spl_curve:u_eval");
	rt_free(v_eval, "spl_curve:v_eval");
	rt_free(u2_eval, "spl_curve:u2_eval");
	rt_free(v2_eval, "spl_curve:v2_eval");
	rt_free(uv_eval, "spl_curve:uv_eval");
d486 1
a486 1
		rt_free( nlist, "spl_free: b_head structure");
d515 1
a515 1
	rt_free( rootp, "n_free: tree structure ");
d594 1
a594 1
		rt_free( spl_eval, "ray_poly: spl_eval" );
d602 2
a603 2
	rt_free( u_eval, "ray_poly: u_eval" );
	rt_free( v_eval, "ray_poly: v_eval" );
d683 1
a683 1
			rt_free( hit2, "spl_shot: hit point");
d694 1
a694 1
		rt_free( hit1, "spl_shot: hit point");
d814 1
a814 1
		rt_free( tmp, "shot_poly: polygon" );
@


7.4
log
@lint fixes
added zero _uv() routines to some modules
@
text
@d86 2
d492 1
d785 1
@


7.3
log
@rt_orthovec to vec_ortho
@
text
@d83 3
d96 1
a96 1
 * we need to decalre some of the read variables as dbfloat_t and not
d99 1
a99 1

d258 1
a258 1

d276 1
d288 1
d291 1
d294 1
d299 4
d466 4
d515 1
d519 1
d706 1
a706 1

d821 1
d1008 1
@


7.2
log
@Some performance mods, some minor cleanups,
some slight loop reorganization to aid debugging.
@
text
@d440 1
a440 1
	rt_orthovec( uvec, hitp->hit_normal );
@


7.1
log
@Release 2.3
@
text
@a68 8
#define MINMAX(a,b,c)   { FAST fastf_t ftemp;\
        if( (ftemp = (c)) < (a) )  a = ftemp;\
        if( ftemp > (b) )  b = ftemp; }

#define MM(v)   MINMAX( stp->st_min[0], stp->st_max[0], v[0] ); \
                MINMAX( stp->st_min[1], stp->st_max[1], v[1] ); \
                MINMAX( stp->st_min[2], stp->st_max[2], v[2] )

d93 1
a93 1
 * we need to decalre some of the read variables as float and not
d119 2
a120 2
		float * vp;
		float * fp;
d138 1
a138 7

		if ( (vp = ( float *) rt_malloc( nbytes, "spl knots" ))
		    == (float *) 0 )
		{
			rt_bomb("spl_prep: malloc error\n");
		}

d149 5
a154 6
		new_srf = (struct b_spline *) spl_new( rec.d.d_order[0],
		    rec.d.d_order[1], rec.d.d_kv_size[0],rec.d.d_kv_size[1],
		    rec.d.d_ctl_size[0], rec.d.d_ctl_size[1],
		    rec.d.d_geom_type );

		fp = vp;
a162 3
		spl_kvnorm( new_srf->u_kv);
		spl_kvnorm( new_srf->v_kv);

d167 1
a167 7

		if (( vp = (float *) rt_malloc(nby,  "control mesh"))
		    == (float *)0)
		{
			rt_bomb("spl_prep: malloc error mesh control points");
		}

d171 2
a172 1
		fp = vp;
d176 6
a181 12
		for( i = 0; 
		     i < ( rec.d.d_ctl_size[0] * rec.d.d_ctl_size[1]);
		     i++)
		{
			fastf_t tmp[4];

			if ( epv == P3)
			{
			   MAT4X3PNT( mesh_ptr, mat, vp);
			} else
			{
			   MAT4X4PNT( mesh_ptr, mat, vp);
d183 10
a192 2
			mesh_ptr += epv;
			vp += epv;
d198 2
a199 4
		s_tree->left = (struct b_tree *) 
			rt_malloc( sizeof (struct b_tree), "left subtree");
		s_tree->right = (struct b_tree *) 
			rt_malloc( sizeof (struct b_tree), "right subtree");
a203 2


d207 1
d220 2
a221 2
		MM(s_tree->min);
		MM(s_tree->max);
d705 2
a706 3
	if ( rt_in_rpp ( rp,  invdir,  tree->min,  tree->max))
	{
		pix_size = (ap->a_rbeam + ap->a_diverge * rp->r_max);
d708 1
a708 2
		if ( tree->root != (struct b_spline *) 0 )
		{
d710 1
a710 1
			flat =	spl_flat( tree->root, pix_size );
d712 4
a715 5
			if (flat)
			{
				shot_poly( rp,  tree, level);
				return;
			}
d717 6
a722 2
			sub = (struct b_spline *) 
				spl_split( tree->root, dir);
d724 9
a732 2
			spl_sfree( tree->root );
			tree->root = (struct b_spline *) 0;
d734 7
d742 4
a745 6
			tree->left = (struct b_tree *) 
				rt_malloc( sizeof (struct b_tree), 
					"nshoot: left tree");
			tree->right = (struct b_tree *) 
				rt_malloc( sizeof (struct b_tree), 
					"nshoot: right tree");
d747 4
a750 5
			tree->left->root = sub;
			spl_bound( tree->left->root,
			    tree->left->min, tree->left->max);
			tree->left->left =
			tree->left->right = NULLTREE; 		
d752 2
a753 1
			tree->right->root = sub->next; 		
d755 2
a756 5
			spl_bound( tree->right->root,
			    tree->right->min, tree->right->max);
			tree->right->left =
			tree->right->right = NULLTREE; 		
		}
d758 2
a759 2
		if ( rt_g.debug & DEBUG_SPLINE ) 
		    rt_log("spline: Left tree level %d\n", level);
d761 2
a762 9
		n_shoot( rp,  invdir,  tree->left, ap,
		    OTHERDIR(dir), level+1 );

		if ( rt_g.debug & DEBUG_SPLINE ) 
		    rt_log("spline: Right tree level %d\n", level);

		n_shoot( rp,  invdir,  tree->right, ap,
		    OTHERDIR(dir), level+1);
	}
@


6.5
log
@Fixed VREVERSE

@
text
@@


6.4
log
@Allowed linear surface normals (temp hack)
@
text
@d952 1
a952 1
		VREVERSE( h0->hit_normal );
@


6.3
log
@removed (void) casts from rt_log.
@
text
@d538 8
a608 1

d896 1
a896 1
	fastf_t uv[2];
d942 12
d956 1
@


6.2
log
@fixed a number of bugs and also allowed for homogeneous surfaces 
(rational b-splines) and added the curvature routines into
the code.
@
text
@d766 1
a766 1
		    (void)rt_log("spline: Left tree level %d\n", level);
d772 1
a772 1
		    (void)rt_log("spline: Right tree level %d\n", level);
d795 1
a795 1
			    (void)rt_log("spline: Hit found at level %d\n",
d812 1
a812 1
		(void) rt_log("Bounding Box hit but no surface hit");
@


6.1
log
@Release 2.0
@
text
@d31 8
a38 1
	struct b_tree * next;   /* Next tree over only used at level 0 */
a44 2
	short dir;		    /* Subdivision direction */
	short level;		    /* Tree Depth Level  */
d57 2
a58 1
	vect_t  hit_vpriv;  /* Store parametric u and v information */
d113 1
a113 1
	struct b_tree  *nlist = NULLTREE;
d123 1
a123 1
		struct b_tree * s_tree;
d125 1
d130 1
a141 7
		if (rec.d.d_geom_type != 3 && rec.d.d_geom_type != 4 )
		{
			fprintf(stderr,"BSURF geom_type = %d\n", 
			    rec.d.d_geom_type );
			return(1);	/* BAD */
		}

d158 2
a162 6
		new_srf = (struct b_spline *)
		    rt_malloc( sizeof( struct b_spline),  "b_spline" );
		new_srf->u_kv = (struct knot_vec *)
		    rt_malloc( sizeof( struct knot_vec ),  "u knots" );
		new_srf->v_kv = (struct knot_vec *)
		    rt_malloc( sizeof( struct knot_vec ),  "v knots" );
d164 4
a167 2
		new_srf->u_kv->k_size = ( rec.d.d_kv_size[0] );
		new_srf->v_kv->k_size = ( rec.d.d_kv_size[1] );
a168 7
		new_srf->u_kv->knots = (fastf_t *)
		    rt_malloc( sizeof( fastf_t ) * rec.d.d_kv_size[0], 
		    "u knot values" );
		new_srf->v_kv->knots = ( fastf_t *)
		    rt_malloc( sizeof( fastf_t ) * rec.d.d_kv_size[1], 
		    "v knot values" );

d176 2
a179 2
		
		rt_free( (char *) fp, "spl_prep: fp" );
a196 15
		new_srf->ctl_mesh = (struct b_mesh *) 
			rt_malloc( sizeof (struct b_mesh), "B_MESH");;

		new_srf->ctl_mesh->mesh_size[0] = rec.d.d_ctl_size[0];
		new_srf->ctl_mesh->mesh_size[1] = rec.d.d_ctl_size[1];

		new_srf->order[0] = rec.d.d_order[0];
		new_srf->order[1] = rec.d.d_order[1];

		new_srf->ctl_mesh->mesh = (fastf_t *)
		    rt_malloc( sizeof ( fastf_t ) * rec.d.d_ctl_size[0] *
		    rec.d.d_ctl_size[1] * ELEMENTS_PER_VECT,  
		    "new control mesh");


d203 1
a203 1
			float tmp[4];
d205 6
a210 9
			if ( rec.d.d_geom_type == 4) {
				MAT4X4PNT( tmp, mat, vp);
				HDIVIDE( mesh_ptr,  tmp);
				mesh_ptr += ELEMENTS_PER_VECT;
				vp += HPT_LEN;
			} else {
				MAT4X3PNT( mesh_ptr, mat, vp);
				mesh_ptr += ELEMENTS_PER_VECT;
				vp += ELEMENTS_PER_VECT;
d212 2
d215 1
d218 5
a222 1
		GETSTRUCT( s_tree, b_tree );
d226 9
a234 2
		s_tree->left = NULLTREE;
		s_tree->right = NULLTREE;
a237 2
		s_tree->dir = COL;
		s_tree->level = 0;
d240 4
d248 2
d283 1
a283 1
	register struct b_tree * ncnt = (struct b_tree *) stp->st_specific;
d285 1
a285 1
	if( ncnt  == (struct b_tree *)0 )  {
d290 1
a290 1
	for( ; ncnt != NULLTREE; ncnt = ncnt->next )
d316 4
a319 1
spl_curve()
d321 156
d482 2
a483 2
	struct b_tree * nlist = ( struct b_tree *) stp->st_specific;
	struct b_tree * c_tree;
d485 1
a485 1
	for( c_tree = nlist; c_tree != (struct b_tree *)0; )
d488 6
a493 1
		n_free( nlist );
a520 6
	if ( rootp->u_diff != (struct b_spline *) 0 )
		spl_sfree( rootp->u_diff );

	if ( rootp->v_diff != (struct b_spline *) 0 )
		spl_sfree( rootp->v_diff );
	
d527 4
a530 1
spl_norm()
d532 70
d615 1
a615 1
struct b_tree * curr_tree;
d623 1
a623 1
	struct b_tree * nlist = ( struct b_tree *) stp->st_specific;
d639 1
a639 1
	for(; nlist != (struct b_tree *) 0; nlist = nlist->next )
d642 2
a643 1
		n_shoot( rp, invdir, nlist, ap );
d672 2
a673 1

a677 1
			VMOVE(segp->seg_out.hit_normal, hit2->hit_normal);
d679 1
a685 2
			VMOVE( segp->seg_out.
			    hit_normal, segp->seg_in.hit_normal );
d687 2
d704 1
d706 2
a707 1
n_shoot( rp,  invdir,  tree, ap)
d712 2
a728 4
			if ( (tree->level == 0))
			if ( (tree->left != NULLTREE))
				goto shoot;
		
d733 1
a733 1
				shot_poly( rp,  tree);
d738 1
a738 1
				spl_split( tree->root, tree->dir);
d740 2
a741 4
			if( tree->level >= 1) {
				spl_sfree( tree->root );
				tree->root = (struct b_spline *) 0;
			}
d743 1
d752 4
a755 7
			tree->left->next = NULLTREE;
			spl_bound( tree->left->root, tree->left->min, tree->left->max);
			tree->left->dir = (tree-> dir == 0) ? 1:0;
			tree->left->level = tree->level + 1;
			tree->left->left = tree->left->right = NULLTREE;
			tree->left->u_diff = (struct b_spline *)0;
			tree->left->v_diff =  (struct b_spline *)0;
d758 3
a760 4
			tree->right->next = NULLTREE;
			spl_bound( tree->right->root, tree->right->min, tree->right->max);
			tree->right->dir = (tree-> dir == 0) ? 1:0;
			tree->right->level = tree->level + 1; 
a762 2
			tree->right->u_diff = (struct b_spline *)0;
			tree->right->v_diff = (struct b_spline *)0;
d764 1
a764 1
shoot:
d766 1
a766 1
		    (void)rt_log("spline: Left tree level %d\n", tree->level);
d768 2
a769 1
		n_shoot( rp,  invdir,  tree->left, ap);
d772 1
a772 1
		    (void)rt_log("spline: Right tree level %d\n", tree->level);
d774 2
a775 1
		n_shoot( rp,  invdir,  tree->right, ap);
d779 1
a779 1
shot_poly( rp, tree )
d795 2
a796 1
			    (void)rt_log("spline: Hit found at level %d\n", tree->level);
d872 2
a890 2
	fastf_t * u_eval, * v_eval, * tmp_hit;
	point_t norm, diff;
d904 1
a904 1
	if ( t < 0.005  )
d928 3
d938 2
a939 4

	tmp_hit = (fastf_t *) spl_srf_eval( curr_tree->root, uv[0], uv[1]);

	VSUB2( diff, tmp_hit, h0->hit_point);
a940 8
	u_eval = (fastf_t *) spl_srf_eval( curr_tree->u_diff, uv[0], uv[1]);

	v_eval = (fastf_t *) spl_srf_eval( curr_tree->v_diff, uv[0], uv[1]);

	VCROSS( norm, u_eval, v_eval);
	VUNITIZE( norm);
	VMOVE( h0->hit_normal, norm);

a943 1
		VPRINT("Normal", h0->hit_normal);
a945 3
	rt_free( u_eval, "ray_poly: u_eval" );
	rt_free( v_eval, "ray_poly: v_eval" );

@


5.1
log
@Release 1.24
@
text
@@


4.9
log
@Name changes for identification with libspl and librt,
and some name shuffling for non-FLEXNAMES machines.
@
text
@@


4.8
log
@stay's free fixes, prep fail return, include cosmetics
@
text
@d184 2
a185 2
		norm_kv( new_srf->u_kv);
		norm_kv( new_srf->v_kv);
d248 2
a249 2
		s_tree->u_diff = (struct b_spline *) u_diff_spline( new_srf );
		s_tree->v_diff = (struct b_spline *) v_diff_spline( new_srf );
d253 1
a253 1
		bound_spl( s_tree->root, s_tree->min, s_tree->max);
d257 1
a257 1
			pr_spl( "initial surface",s_tree->root );
d299 1
a299 1
		pr_spl( "B_Spline", ncnt->root );
d363 1
a363 1
		free_spl( rootp->root );
d366 1
a366 1
		free_spl( rootp->u_diff );
d369 1
a369 1
		free_spl( rootp->v_diff );
d513 1
a513 1
				split_spl( tree->root, tree->dir);
d516 1
a516 1
				free_spl( tree->root );
d529 1
a529 1
			bound_spl( tree->left->root, tree->left->min, tree->left->max);
d538 1
a538 1
			bound_spl( tree->right->root, tree->right->min, tree->right->max);
d592 1
a592 1
		pr_spl("B_Spline surface", tree->root);
d715 1
a715 1
	tmp_hit = (fastf_t *) srf_eval( curr_tree->root, uv[0], uv[1]);
d719 1
a719 1
	u_eval = (fastf_t *) srf_eval( curr_tree->u_diff, uv[0], uv[1]);
d721 1
a721 1
	v_eval = (fastf_t *) srf_eval( curr_tree->v_diff, uv[0], uv[1]);
@


4.7
log
@added spl_free code to free up tree structure.
-paul stay
@
text
@d22 4
a25 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/db.h"
#include "../h/raytrace.h"
d138 1
a138 1
			return;
d348 1
a348 1
	root = tree;
d362 1
a362 1
	if ( rootp != (struct b_spline *) 0 )
d533 2
a534 2
			tree->left->u_diff = NULLTREE;
			tree->left->v_diff = NULLTREE;
d543 2
a544 2
			tree->right->u_diff = NULLTREE;
			tree->right->v_diff = NULLTREE;
@


4.6
log
@new Spline Routines using libspl
should work mostly
@
text
@d328 2
a329 1
spl_free()
d331 10
d343 6
d350 24
d533 2
d543 2
@


4.5
log
@fixed RCS header
@
text
@d1 2
a2 2
/*
 *			S P L I N E . C
d4 5
a8 3
 *		********************************************
 *		* WARNING:  EXPERIMENTAL NON-WORKING CODE! *
 *		********************************************
d10 4
a13 3
 *  Purpose -
 *	Intersect a ray with a set of spline patches
 *	which together form a solid object
d15 3
a17 8
 *  Authors -
 *	Dr. Dave Rogers		(Analysis)
 *	Mark G. Daghir		(Programming)
 *	Michael John Muuss	(Integration)
 *  
 *  Source -
 *	United States Naval Academy
 *  
a18 3
#ifndef lint
static char RCSspline[] = "@@(#)$Header: $ (BRL)";
#endif
d20 1
a20 1
#include <stdio.h>
d22 4
a25 4
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "raytrace.h"
d28 18
a45 3
/*
 *  Algorithm:
 *  
d48 7
a54 15
struct surf {
	struct surf	*spl_forw;
	short		spl_order[2];
	short		spl_kv_size[2];
	int		*spl_ku;
	int		*spl_kw;
	short		spl_ctl_size[2];
	float		*spl_mesh;
#define SUBDIVLVL 4
	fastf_t		spl_uinterv[SUBDIVLVL];	/* interval list */
	fastf_t		spl_winterv[SUBDIVLVL];
	int		spl_lvl;	/* current level (remembered) */
	int		spl_olvl;	/* prev level (remembered) */
	fastf_t		spl_ulow[SUBDIVLVL];	/* list of U lower limits */
	fastf_t		spl_wlow[SUBDIVLVL];	/* list of W lower limits */
a55 1
#define SPL_NULL	((struct surf *)0)
d57 2
a58 1
int lp1[4], lp2[4];	/* how much tosubdivide for each level */
d60 18
a77 2
/*
 *  			S P L _ P R E P
d79 5
a83 11
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid ellipsoid, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	ELL is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct surf is created, and it's address is stored in
 *  	stp->st_specific for use by spl_shot().
d85 20
a104 5
spl_prep( vec, stp, mat, rtip )
register fastf_t	*vec;
struct soltab		*stp;
matp_t			mat;
struct rt_i		*rtip;
d106 2
a107 2
	struct surf *list;
	register int i, j;
d109 2
a110 4
	register float *vp;
	int cur_gran;
	int nby;
	float *fp;
d112 1
a112 4
	/* Global information */
	lp1[1] = lp2[1] = 11;
	lp1[2] = lp2[2] = 6;
	lp1[3] = lp2[3] = 3;
d114 1
a114 5
	list = (struct surf *)0;
	cur_gran = 1;
	while(1)  {
/***	while( cur_gran < dp->d_len )  { ***/
		register struct surf *spl;
d116 10
a125 3
/***		db_getrec( dp, &rec, cur_gran++ ); ***/
		i = fread( (char *)&rec, sizeof(rec), 1, rtip->fp );
		if( feof(rtip->fp) )  break;
d127 1
a127 2
			rt_bomb("spl_prep:  read error");
		cur_gran++;
d129 2
a130 1
		if( rec.u_id != ID_BSURF )  {
d133 6
a138 3
		if( rec.d.d_geom_type != 3 && rec.d.d_geom_type != 4 )  {
			printf("BSURF geom_type=%d?\n", rec.d.d_geom_type);
			return(-1);
a139 7
		GETSTRUCT( spl, surf );
		spl->spl_forw = list;
		list = spl;
		spl->spl_order[0] = rec.d.d_order[0];
		spl->spl_order[1] = rec.d.d_order[1];
		spl->spl_ctl_size[0] = rec.d.d_ctl_size[0];
		spl->spl_ctl_size[1] = rec.d.d_ctl_size[1];
d141 9
a149 7
		/* Read in spl_ku, spl_kw */
		spl->spl_kv_size[0] = rec.d.d_kv_size[0];
		spl->spl_kv_size[1] = rec.d.d_kv_size[1];
		nby = rec.d.d_nknots * sizeof(union record);
		if( (vp = (float *)malloc(nby)) == (float *)0 )  {
			printf("draw_spline:  malloc error\n");
			return(-1);
d151 26
d178 5
a182 4
/***		db_getmany( dp, (char *)vp, cur_gran, rec.d.d_nknots ); ***/
		i = read( (char *)vp, nby, 1, rtip->fp );
		if( i != 1 )  rt_bomb("spl_prep:  knot read");
		cur_gran += rec.d.d_nknots;
d184 4
a187 7
		spl->spl_ku = (int *)malloc( spl->spl_kv_size[0]*sizeof(int) );
		spl->spl_kw = (int *)malloc( spl->spl_kv_size[1]*sizeof(int) );
		for( i=0; i<spl->spl_kv_size[0]; i++ )
			spl->spl_ku[i] = (int)*vp++;
		for( i=0; i<spl->spl_kv_size[1]; i++ )
			spl->spl_kw[i] = (int)*vp++;
		(void)free( (char *)fp);
d189 9
a197 5
		/* Read in control mesh */
		nby = rec.d.d_nctls * sizeof(union record);
		if( (spl->spl_mesh = (float *)malloc(nby)) == (float *)0 )  {
			printf("draw_spline:  malloc error\n");
			return(-1);
a198 4
/***		db_getmany( dp, (char *)spl->spl_mesh, cur_gran, rec.d.d_nctls ); ***/
		i = fread( (char *)spl->spl_mesh, nby, 1, rtip->fp );
		if( i != 1 )  rt_bomb("spl_prep:  knot read");
		cur_gran += rec.d.d_nctls;
d200 33
a232 8
		/* Transform all the control points */
		vp = spl->spl_mesh;
		i = rec.d.d_ctl_size[0]*rec.d.d_ctl_size[1];
		for( ; i>0; i--, vp += rec.d.d_geom_type )  {
			if( rec.d.d_geom_type == 3 )  {
				static vect_t	temp;
				MAT4X3PNT( temp, mat, vp );
				VMOVE( vp, temp );
d234 3
a236 4
				static hvect_t	homog;
				MAT4X4PNT( homog, mat, vp );
				HDIVIDE( vp, homog );
				/* Leaves us with [x,y,z,1] */
a237 1
			VMINMAX( stp->st_min, stp->st_max, vp );
d239 1
d241 21
a261 13
		/* Preparations */
		/* Build the interval list in parametric space */
		spl->spl_uinterv[1] = (float)(spl->spl_ctl_size[0] - spl->spl_order[0] + 1) / (lp1[1] - 1);
		spl->spl_uinterv[2] = spl->spl_uinterv[1] / (lp1[2] - 1);
		spl->spl_uinterv[3] = spl->spl_uinterv[2] / (lp1[3] - 1);
		spl->spl_winterv[1] = (float)(spl->spl_ctl_size[1] - spl->spl_order[1] + 1) / (lp2[1] - 1);
		spl->spl_winterv[2] = spl->spl_winterv[1] / (lp2[2] - 1);
		spl->spl_winterv[3] = spl->spl_winterv[2] / (lp2[3] - 1);
		/* Set initial level and lower left corner */
		spl->spl_lvl = 1;	/* coarsest level */
		spl->spl_olvl = 2;
		spl->spl_ulow[spl->spl_lvl] = spl->spl_ulow[spl->spl_olvl] = 0;	/* Low values */
		spl->spl_wlow[spl->spl_lvl] = spl->spl_wlow[spl->spl_olvl] = 0;
d264 1
a264 3
	/* Solid is OK, compute constant terms now */
	stp->st_specific = (int *)list;

d266 3
a268 5
		(stp->st_max[X] + stp->st_min[X])/2,
		(stp->st_max[Y] + stp->st_min[Y])/2,
		(stp->st_max[Z] + stp->st_min[Z])/2 );

	/* An enclosing bounding sphere */
d271 1
a271 1
		dx = (stp->st_max[X] - stp->st_min[X])/2;
d273 1
a273 1
		dy = (stp->st_max[Y] - stp->st_min[Y])/2;
d275 1
a275 1
		dz = (stp->st_max[Z] - stp->st_min[Z])/2;
a279 2
	return(0);			/* OK */
}
d281 1
a281 23
spl_print( stp )
register struct soltab *stp;
{
	register struct surf *spl =
		(struct surf *)stp->st_specific;
	register int i;

	for( ; spl != SPL_NULL; spl = spl->spl_forw ) {
		printf("order %d x %d, kv_size %d x %d\n",
			spl->spl_order[0],
			spl->spl_order[1],
			spl->spl_kv_size[0],
			spl->spl_kv_size[1] );
		printf("control mesh %d x %d\n",
			spl->spl_ctl_size[0],
			spl->spl_ctl_size[1] );
		for( i=0; i<spl->spl_kv_size[0]; i++ )
			printf("%d ", spl->spl_ku[i] );
		printf("\n");
		for( i=0; i<spl->spl_kv_size[1]; i++ )
			printf("%d ", spl->spl_kw[i] );
		printf("\n");
	}
d285 1
a285 8
 *  			S P L _ S H O T
 *  
 *  Intersect a ray with a set of spline patches.
 *  If an intersection occurs, a struct seg will be acquired and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *  	segp	HIT
d287 3
a289 5
struct seg *
spl_shot( stp, rp, ap )
struct soltab *stp;
register struct xray *rp;
struct application	*ap;
d291 1
a291 10
	register struct surf *spl =
		(struct surf *)stp->st_specific;
	register struct seg *segp;
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
	int pointer[4];		/* indexs of current triangle points, clockwise */
	double refined[11*11*3];	/* refined array pts, ROW major */
	int npts;	/* number of refined points */
	int ntri;	/* number of refined triangles */
	double norm[6][4]; /* normal vectorS. */
	int hole;	/* flag */
d293 3
a295 39
	/* FIRST VERSION:  Just a single surface */
/*** should be able to remove lvl reset ****/
	spl->spl_lvl = 1;	/* restart: top lvl */
	spl->spl_olvl = 2;
	hole = 0;	/* flag */

labela:
printf("%d: low u,w=%f,%f\n", spl->spl_lvl, spl->spl_ulow[spl->spl_lvl], spl->spl_wlow[spl->spl_lvl] );
	bsurf3(
		spl->spl_ctl_size[0], spl->spl_ctl_size[1],
		spl->spl_order[0], spl->spl_order[1], 
		lp1[spl->spl_lvl], lp2[spl->spl_lvl],
		spl->spl_ulow[spl->spl_lvl], spl->spl_wlow[spl->spl_lvl],
		spl->spl_uinterv[spl->spl_lvl], spl->spl_winterv[spl->spl_lvl],
		refined, spl);

	if( cybk2( refined, 
		rp,
		norm,
		pointer, &k1,
		lp1[spl->spl_lvl], lp2[spl->spl_lvl]
	  ) == 0 )  {
	  	/* MISSED */
	  	if( spl->spl_lvl == 1 )
	  		return(SEG_NULL);	/* top-level MISS */

		/* MISS at current level  Go to next larger (cruder) area */
		spl->spl_olvl = spl->spl_lvl--;

		/* If get to index level 1 twice, no intersection */
		if(spl->spl_lvl == 1)  {
			if(hole == 1)  {
				spl->spl_lvl = 1;	/* restart: top lvl */
				spl->spl_olvl = 2;
				return(SEG_NULL);	/* MISS */
			}
			hole = 1;
		}
		goto labela;
d298 2
a299 30
	if(rt_g.debug&DEBUG_SPLINE)printf("hit at lvl %d\n", spl->spl_lvl);
	if (spl->spl_lvl < 3)  {
		int wintrval;
		/* Have a hit, want to be certain that this is accurate.
		 * If not the finest level, go to the finest level.
		 */
		spl->spl_olvl = spl->spl_lvl++;
		/* pointer[1] is lower left corner */
		wintrval = (int)(pointer[1] / lp1[spl->spl_olvl]);

		/* New lower limit values for next iteration */
		spl->spl_ulow[spl->spl_lvl] =
			((((pointer[1]) % lp1[spl->spl_olvl]) - 1) *
			spl->spl_uinterv[spl->spl_olvl]) +
			spl->spl_ulow[spl->spl_olvl];
		spl->spl_wlow[spl->spl_lvl] = spl->spl_winterv[spl->spl_olvl] * wintrval + spl->spl_wlow[spl->spl_olvl];
		goto labela;
	}

	/* We have a hit */
	GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;
	segp->seg_in.hit_dist = k1;
	VJOIN1( segp->seg_in.hit_point, rp->r_pt, segp->seg_in.hit_dist, rp->r_dir );
	VSET( segp->seg_in.hit_normal, norm[5][1], norm[5][2], norm[5][3] );
	VUNITIZE( segp->seg_in.hit_normal );
	segp->seg_out.hit_dist = k1+0.1;	/* fake it */
	VJOIN1( segp->seg_out.hit_point, rp->r_pt, segp->seg_out.hit_dist, rp->r_dir );
	VREVERSE( segp->seg_out.hit_normal, segp->seg_in.hit_normal );
	return(segp);			/* HIT */
d302 2
a303 4
/*
 *  			S P L _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
d305 1
a305 15
spl_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
{
	register struct surf *ell =
		(struct surf *)stp->st_specific;

}

/*
 *  			S P L _ U V
 *  
 */
spl_uv( ap, stp, hitp, uvp )
d311 3
a313 5
	register struct surf *ell =
		(struct surf *)stp->st_specific;
	uvp->uv_u = .2;
	uvp->uv_v = .2;
	uvp->uv_du = uvp->uv_dv = 0;
a315 9
/*
 *			S P L _ F R E E
 */
spl_free( stp )
struct soltab *stp;
{
	rt_log("spl_free?\n");
}

d328 3
a331 1
/*** bsurf3 ***/
d333 7
a339 1
/*********************************************************************
a340 70
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c name: bsurf3.c - b-spline surface
c
c date: 7 February 1986
c
c purpose: to generate the points of a b-spline surface
c          form a ploygon net.
c
c method:  refer to "mathematical elements for computer graphics",
c          rogers & adams, chapter 6, section 6-11, eq. 6-51.
c
c author:
c        david f. rogers
c        computer aided design and interactive graphics group
c        u. s. naval academy
c
c language: pdp-11 rt-11 v03b fortran
c
c filename: bsurf.c
c
c
c parameters:
c        
c        b()= array containing the polygon net points
c        b(i)= x-component
c        b(i+1)= y-component
c        b(i+2)= z-component
c        b(1)-b(3*n2)= first row in w direction
c        b((n1-1)*3*n2+1)-b(n1*3*n2)= last row in w direction
c           the values are stored as b(i,j) with i fixed and j varying
c           in groups of three x,y,z components.
c        
c        q()= array containing the resulting surface
c        q(i)= x-componwnt
c        q(i+1)= y-component
c        q(i+2)= z-component
c        q((p2-1)*3*p1+1)-q(p2*3*p1) last row in u direction
c           the first 3*p2 values are for u=0 with w varying in groups
c           of 3 as x,y,z components followed by the second group of 3*p2
c           values with u=xmax/(p1-1) with w varying etc.
c
c
c        c1= order in the u direction
c        c2= order in the w direction
c
c        n1= number of polygon points in the u direction
c        n2= number of polygon points in the w direction
c            thus the polygon net is n1 x n2
c
c        p1= number of pts on the display surface/w in u direction
c        p2= number of pts on the display surface/u in the w direction
c            thus the resulting surface is p1 x p2
c
c        x()=  array to contain the knot vector in u direction.
c              maximum value is n1-c1+1.
c              number of elements is n1+c1.
c        y()=  array to contain the knot vector in w  direction.
c              maximum value is n2-c2+1.
c              number of elements is nz+c2.
c
c        n() =  array to contain the basis function in the w direction.
c               the first group of p1 values is for  u=0, the second
c               group of p1 values is for u=xmax/(p1-1), etc.
c
c        m() =  array containing the basis functions in the w direction.
c               the firrst group of p2 values is for w=0, the second group
c               of p2 values for w=ymax/(p2-1), etc.
c
*********************************************************************/
d342 16
a357 5
bsurf3(n1,n2,c1,c2,p1,p2,ulo,wlo,stempu,stempw,q,spl)
int c1,c2,n1,n2,p1,p2;
double *q;
double ulo,wlo,stempu,stempw;
struct surf *spl;
d359 3
a361 5
	double t1, t2, t3, nbasis, nmbas, u1, w1;
	double n[100], m[100];		/* basis functions */
	int p1m1, p2m1, k1n1, kn2;
	int n1plc1, n2plc2, l, i, i1, i2, i3;
	int j, j2, j3, k1, k;
d363 7
a369 3
	t1 = 0;
	t2 = 0;
	t3 = 0;
d371 1
a371 5
	/*------------------precalculate certain often used values         */
	n1plc1 = n1 + c1;
	n2plc2 = n2 + c2;
	p1m1 = p1 - 1;
	p2m1 = p2 - 1;
d373 1
a373 1
	/*	calculate basis functions */
d375 1
a375 5
	/*---------------------------------set n element counter           */
	i1=0;

	/*----------------calculate u basis function n for each u          */
	for(i=0;i<=p1m1;i++)
d377 2
a378 4
		/*-increment in parameter u  0<=u<=xmax          */
		u1 = i * stempu + ulo;
		basis(c1,u1,n1,n1plc1,spl->spl_ku,&i1,m);

d381 3
a383 2
	/*----------------------------------set m element counter          */
	i2=0;
d385 4
a388 5
	/*----------------calculate w basis function m for each w          */
	for(i=0;i<=p2m1;i++)  {
		/*----------increment in parameter w   0<=w<=ymax          */
		w1 = i * stempw + wlo;
		basis(c2,w1,n2,n2plc2,spl->spl_kw,&i2,n);
d391 1
a391 5
	/*	generate completely new surface  */
	/*-----------------------initialize surface array counter          */
	i3=0;
	for(k1=0; k1<=p1m1; k1++)  	{
		k1n1=k1*n1;
d393 5
a397 8
		/*-!calc. along w for fixed u           */
		for(k=0; k<=p2m1; k++)  {
			register float *vp;
			/* !initialize surface elements to round up           */
			/* !when truncating result to integer.           */
                        t1=t2=t3=0;
			kn2=k*n2;
			vp = spl->spl_mesh;
d399 2
a400 19
			/* !vary n for fixed u           */
			for(l=1; l<=n1; l++)  {
				nbasis=n[k1n1+l];
				if(nbasis==0.0)  {
					/* Skip this row */
					vp += 3*n2;
				}  else  {
					for(j=1; j<=n2; j++)  {
						/*vary m for fixed n */
						nmbas = m[kn2+j] * nbasis;
						if(nmbas!=0.0)  {
							t1 += *vp++ *nmbas;
							t2 += *vp++ *nmbas;
							t3 += *vp++ *nmbas;
						} else
							vp += 3;
					}
				}
			}
d402 5
a406 4
			/* return surface in integer array          */
			q[i3+1]=t1;
			q[i3+2]=t2;
			q[i3+3]=t3;
d408 15
a422 2
			/* increment polygon net array counter          */
			i3+=3;
d424 9
d434 2
a437 1
/**********************************************************************************
d439 9
a447 1
                 Program Name:   cybk2.c
d449 2
a450 5
First:	Take the output of the b-spline surface
	generating program (a collection of data points column major
	in a one dimensional array), and arranges them into a polygon
	file suitable for display via the "threed" program and the 
	PS300 system.  The polygons are triangles in three-space.
d452 3
a454 27
                   Programmer:   Midn  Mark G. Daghir
                 Version/Date:   3rd // 2 February 1986
		       System:   UNIX
     		     Language:   C
		      Purpose:   To demonstrate the FUNCTION "cybk" and the
				     FUNCTION "normal".   Additionally, the functions
				     are timed to examine their effectiveness.
		       Method:   Sample data sets may be defined or read from
				     files and the results may be viewed after
				     applying the above functions.
	        Variable List:   i, ii, j, n........Loop Counters/Subscripted 
						    Variables Indices
				 dot1(4), dot2(4)...Dot product Coefficients
				 norm(6,4)..........Normal Vector i,j,k Coeff.
				 vertex(4,4)............Three Arbitrary Position
						    Vector i,j,k Coefficients
				 sd(4,4)............Three Side Vector i,j,k Coeff.
	          Subroutines:   normal(vertex,norm)....Given three arbitrary points
						    this function returns the 
						    five normals.
				 cybk(vertex,norm,ray1,ray2,intersect1,intersect2)..................
						    Given the above determined normals
						    and the arbitrary points defining a triangular volume, and
						    the endpoints of an incident line, this
						    function returns the points of intersection of the line
						    and the volume.
*/
d456 2
a457 16
cybk2(q,rp,norm,pointer,k1,p1, p2)
struct xray *rp;
int pointer[4];
double norm[6][4];
double *k1;
double q[];
{
	register int i, j;
	int ii, n, pp;
	int icount;
	double vertex[4][4];     		               /* Test Data */
	int tri;			/* number of the triangle */
	int index[11*11*2][4];		/* 2 triangles per cell */
	int ntri, npts;
      
	/* DEFINE NUMBER OF POINTS AND NUMBER OF TRIANGLES         */
d459 5
a463 2
	npts = p1 * p2;
	ntri = (p1-1) * (p2-1) * 2;
d465 5
a469 7
	/*	LIST POINTS IN COLUMN-MAJOR ORDER		      */
#ifdef never
	if(rt_g.debug&DEBUG_SPLINE) for( ii=1; ii <= npts; ii += 3 )  {
		fprintf(stdout," %f, %f, %f\n",
				q[ii], q[ii+1], q[ii+2]);
	}
#endif
d471 2
a472 2
	/*	DEFINE counter-clockwise TRIANGLES			      */
#define POINT(i,j)	((i-1)*p2+j)
d474 4
a477 7
        tri=0;
	for(i=1; i<=(p1-1); i++)  {
		for(j=1; j<=(p2-1); j++)  {
                        tri++;
                        index[tri][1] = POINT(i,j);
                        index[tri][2] = POINT(i+1,j+1);
                        index[tri][3] = POINT(i,j+1);
d479 6
a484 6
                        tri++;
                        index[tri][1] = POINT(i,j);
                        index[tri][2] = POINT(i+1,j);
                        index[tri][3] = POINT(i+1,j+1);
		}
	}
d486 6
a491 8
	/* Loop-Read the triangle order list. */
	for (i=1; i <= ntri; i++)  {
#ifdef never
		if( rt_g.debug&DEBUG_SPLINE)  {
			fprintf(stdout, "		Triangle %d Pointers\n", i);
			fprintf(stdout, "	%d,  %d,  %d\n", index[i][1], index[i][2], index[i][3]);
		}
#endif
d493 7
a499 13
		for (ii=1; ii <= 3; ii++)  {
			j = (index[i][ii]-1)*3;
			if( j < 0 || j >= ntri*3 )  {
				printf("index[%d][%d]=%d!\n", i, ii, j);
				break;
			}
			vertex[ii][1] = q[j+1];
			vertex[ii][2] = q[j+2];
			vertex[ii][3] = q[j+3];
#ifdef never
			if(rt_g.debug&DEBUG_SPLINE) fprintf(stdout, "	vertex[%d] = (%f, %f, %f)\n",
				ii, vertex[ii][1], vertex[ii][2], vertex[ii][3]);
#endif
d501 3
a503 2
		/* Create the inward and surface normals. */
  		normal(vertex,norm);
d505 7
a511 9
		/* Do the actual intersection with the triangle */
		if( cybk(vertex, norm, rp, k1) == 1 )  {
			for (j=1; j <= 3; j++) 	{
				pointer[j] = index[i][j];
			}
			return(1);	/* HIT */
		}
      	}
	return(0);			/* MISS */
a512 1
/**** cybk.c ****/
d514 8
a521 1
	/*******************************************************************
d523 5
a527 1
                 Program Name:   cybk.c
d529 7
d537 6
a542 28
                   Programmer:   Midn  Mark G. Daghir
                 Version/Date:   3nd // 2 February 1986
		       System:   UNIX
     		     Language:   C
		      Purpose:   To demonstrate the FUNCTION "cybk" and the
				     FUNCTION "normal".   Additionally, the functions
				     are timed to examine their effectiveness.
		       Method:   Sample data sets may be defined or read from
				     files and the results may be viewed after
				     applying the above functions.
	        Variable List:   i, ii, j, n........Loop Counters/Subscripted 
						    Variables Indices
				 dot1(4), dot2(4)...Dot product Coefficients
				 norm(6,4)..........Normal Vector i,j,k Coeff.
				 vertex(4,4)............Three Arbitrary Position
						    Vector i,j,k Coefficients
				 sd(4,4)............Three Side Vector i,j,k Coeff.
	          Subroutines:   normal(vertex,norm)....Given three arbitrary points
						    this function returns the 
						    five normals.
				 cybk(vertex,norm,ray1,ray2)..................
						    Given the above determined normals
						    and the arbitrary points defining a triangular volume, and
						    the endpoints of an incident line, this
						    function returns the points of intersection of the line
						    and the volume.
	        Common Blocks:   NONE
         Input/Output Devices:   Ergo terminals
d544 5
a548 1
**************************************************************************/
d550 1
d552 15
a566 1
/*
d568 6
a573 1
			FUNCTION   "cybk"
d575 1
d577 2
a578 3
	      Purpose:   To find the intersection point of a line
			     and a triangular plane defined by three
			     arbitrary points.
d580 9
a588 4
     	       Method:   This function impliments the Cyrus & Beck
			     cplipping algorithm found in the following reference:
			     Rogers, David F., Procedural Elements For Computer Graphics,
			         McGraw-Hill Book Company, New York, NY, 1985, pp. 135-159.
d590 10
a599 2
	    Variables:   vertex[1,2,3][x,y,z]........Three arbitrary points that
					   define the triangular plane, (input).
d601 4
a604 2
		 	 norm[1,2,3,4,5][x,y,z]..The five vectors normal to the
					   sides of the triangular volume, (input).
d606 1
a606 2
			 ray1[x,y,z]; ray2[x,y,z]....The two endpoints of incident
					   line intersecting the triangular volume, (input).
d608 4
a611 1
			 ddotn; wdotn..............The two dot product quantities, D*n & w*n, (internal).
d613 12
a624 1
			 w[1,2,3,4,5][x,y,z].....The vector difference between ray1[] and vertex[i][], (internal).
d626 2
a627 1
			 t; tl; tu...............Parameter values for parametric line equation, (internal).
d629 1
a629 1
			 i; ii; j................Counters and subscripts, (internal).
d631 1
a631 12
 *
 *  Returns -
 *	0 if missed,
 *	1 if hit
 */
int
cybk(vertex, norm, rp, k1)
struct xray *rp;
double vertex[4][4], norm[6][4];
double *k1;
{
	register int i, ii, j;
d633 2
a634 1
	static double t, tl, tu, ddotn, wdotn, w[6][4];
d636 1
a636 24
	/* Find intersection within bounding box limits */
	tl = rp->r_min;		/* could be 0 */
	tu = rp->r_max;		/* could be INFINITY */
#ifdef never
	if( rt_g.debug&DEBUG_SPLINE )  printf("cybk: %f<=t<=%f\n", tl, tu);
#endif
	
	for(i=1; i<=5; i++)  {
		/* NOTE:  Normals point INWARDS */
		ii = ((i-1) % 3) + 1;
		ddotn = wdotn = 0;
		for(j=1; j<=3; j++)  {
			w[i][j] = rp->r_pt[j-1] - vertex[ii][j];
			ddotn += rp->r_dir[j-1] * norm[i][j];
			wdotn += w[i][j] * norm[i][j];
		}
#ifdef never
		if( rt_g.debug&DEBUG_SPLINE )  {
		   	fprintf(stdout, "Normal Used = #%d", i);
			fprintf(stdout, "	<%f, %f, %f>\n", norm[i][1], norm[i][2], norm[i][3]);
		   	fprintf(stdout, "	ddotn = %f", ddotn);
		   	fprintf(stdout, "	wdotn = %f\n", wdotn);
		}
#endif
d638 2
a639 29
		if( NEAR_ZERO(ddotn, 0.005) )  {
			if(wdotn < 0)  {
				/* Line parallel, outside halfspace */
				return(0);	/* MISS */
			}
			continue;
		}
	
		t = -wdotn / ddotn;
#ifdef never
		if( rt_g.debug&DEBUG_SPLINE) fprintf(stdout, " t = %f\n", t);
#endif
		if(ddotn > 0)  {
			/* Ray is headed INTO halfspace */
   			if(t > tl)
   				tl = t;
   		} else {
   			/* Ray is headed OUT of halfspace */
			if(t < 0)
				return(0);  /* MISS -- pt outside halfspace */
			if(t < tu)
				tu = t;
   		}
	}
	/* Check for valid intersection */
	if( tl > rp->r_max )
		return(0);		/* MISS */
	if( rt_fdiff(tl,tu) > 0 ) 
		return(0);		/* MISS */
d641 1
a641 6
	*k1 = tl;			/* take entry distance */
	if( rt_g.debug&DEBUG_SPLINE )  printf("hit, dist=%f\n", tl);
	return(1);			/* HIT */
}
/*** normal.c ****/
/*******************************************************************
d643 2
a644 1
                 Program Name:   normal.c
d646 2
d649 3
a651 16
                   Programmer:   Midn  Mark G. Daghir
                 Version/Date:   3rd/ 2 February 1986
		       System:   UNIX
     		     Language:   C
		      Purpose:   To find three vectors normal to
				     the three side vectors connecting
                                     three arbitrary points of a triangle
				     lying in the plane of the triangle, and
				     to find the two vectors normal to the 
				     plane of the triangle.
		       Method:   The method used here is to take the 
				     triple cross product of adjoining 
				     side vectors...
					    n(i) = s(i) x ( s(i+1) x s(i) )
				     This simplifies as follows...
				     n(i) = (s(i)*s(i))s(i+1)-(s(i)*s(i+1))s(i)
d653 6
a658 16
	        Variable List:   i, ii, j, n........Loop Counters/Subscripted 
						    Variables Indices
				 dot1(3), dot2(3)...Dot product Coefficients
				 norm(5,3)..........Normal Vector i,j,k Coeff.
				 pt(3,3)............Three Arbitrary Position
						    Vector i,j,k Coefficients
				 sd(3,3)............Three Side Vector i,j,k Coeff.
	          Subroutines:   normal(pt,norm)....Given three arbitrary points
						    this function returns the 
						    five normals.
*/
normal(pt,norm)
double pt[4][4], norm[6][4];            /* Declare Passed Variables */
{
	int i, ii, j;			       /* Declare Integers */
	double sd[4][4], dot1[4], dot2[4];      /* Declare Reals */
d660 4
a663 9
	/* Loop to create side vectors */
	for(i=1; i<=3; i++)  {
		ii = i + 1;
		if(ii > 3)
		ii = 1;
		for(j=1; j<=3; j++)  {
			sd[i][j] = pt[ii][j] - pt[i][j];
		}
	}
d665 4
a668 3
	/* Loop to create dot1 Coefficients */
	for(i=1; i<=3; i++)  {
		dot1[i] = 0;
d670 1
a670 4
		for(j=1; j<=3; j++)  {
			dot1[i] += sd[i][j] * sd[i][j];
		}
	}
d672 3
a674 10
	/* Loop to create dot2 Coefficients */
	for(i=1; i<=3; i++)  {
		dot2[i] = 0;
		ii = i + 1;
		if(ii > 3)
		ii = 1;
		for(j=1; j<=3; j++)  {
			dot2[i] += sd[i][j] * sd[ii][j];
		}
	}
d676 1
a676 9
	/* Loop to create side normals */
	for(i=1; i<=3; i++)  {
		ii = i + 1;
		if(ii > 3)
		ii = 1;
		for(j=1; j<=3; j++)  {
			norm[i][j] = dot1[i] * sd[ii][j] - dot2[i] * sd[i][j];
		}
	}
d678 3
a680 7
	/* Creation of surface normals */
	norm[4][1] = sd[1][2] * sd[2][3] - sd[2][2] * sd[1][3];
	norm[4][2] = - sd[1][1] * sd[2][3] + sd[2][1] * sd[1][3];
	norm[4][3] = sd[1][1] * sd[2][2] - sd[2][1] * sd[1][2];
	norm[5][1] = - norm[4][1];
	norm[5][2] = - norm[4][2];
	norm[5][3] = - norm[4][3];
d682 8
a689 6
	for(i=1; i <= 5; i++)  {
		for(j=1; j <= 3; j++)  {
			if( NEAR_ZERO( norm[i][j], 0.005 ) )
				norm[i][j] = 0;
		}
	}
d691 1
a691 6
#ifdef never
	if( rt_g.debug&DEBUG_SPLINE) for(i=1; i<=5; i++)  {
		fprintf(stdout, "	norm[%d][1] = %f, norm[%d][2] = %f, norm[%d][3] = %f\n", 
			i, norm[i][1], i, norm[i][2], i, norm[i][3]);
	}
#endif
d694 13
a706 1
/************************************************************************
d708 5
a712 25
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c name: basis
c
c purpose: to calculate a floating point bspline basis function
c
c method: cox-deboor
c
c parameters:
c
c	np=      number of polygon vertices
c
c	c=       order of b-spline basis
c
c	nplusc=  np+c
c
c	t=       parameter value on curve
c
c	x()=     knot vector
c
c	n()=     the weighting function (cf. eq. 5-78)
c
c	temp()=  an intermediate array containing basis functions
c	
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
d714 1
a714 1
************************************************************************/
d716 24
a739 4
basis(c,t,np,nplusc,x,tcount,n)
double n[],t;
int x[];
int c,np,nplusc,*tcount;
d741 2
a742 2
	double temp[100],d,e;
	int i,k;
d744 1
a744 4
#ifdef never
	if( rt_g.debug & DEBUG_SPLINE )
		fprintf(stderr, "	In Basis.c, t=%f\n", t);
#endif
d746 2
a747 3
	for(i=1;i<=nplusc-1;i++)  {
		/* !calc. n(i,1).  if t not in interval =0. otherwise  */
		temp[i]=0;
d749 2
a750 6
		if(t>=x[i-1] && t<x[i])
			temp[i]=1;
#ifdef never
		if(rt_g.debug&DEBUG_SPLINE) fprintf(stderr, "%d %d %d\n", i, x[i-1], temp[i] );
#endif
	}
d752 2
a753 6
	for(k=2; k<=c; k++)  {
		for(i=1;i<=nplusc-k;i++) {
			/* !if n(i,k)=0. first term r&a eq. 5-78 =0. otherwise  */
			d=0;
			if(temp[i]!=0)
				d=((t-x[i-1])*temp[i])/(x[i+k-2]-x[i-1]);
d755 4
a758 7
			/* !if n(i+1,k)=0. second term r&a eq. 5-78 =0. otherwise  */
			e=0;
			if(temp[i+1]!=0)
				e=((x[i+k-1]-t)*temp[i+1])/(x[i+k-1]-x[i]);
			temp[i]=d+e;
		}
	}
d760 2
a761 5
	/* !put in n vector sequentially for each t     */
	for(i=1;i<=np;i++)  {
		/* !beginning at t=0.  np+c-1 elements for each t   */
		*tcount+=1;
		n[*tcount]=temp[i];
d763 3
a765 5
#ifdef never
		if( rt_g.debug&DEBUG_SPLINE)
			fprintf(stderr, "	n[%d] = %f\n", *tcount, n[*tcount]);
#endif
	}
d767 4
a770 3
	/* !pick up last point      */
	if(t==x[nplusc-1])
	n[*tcount]=1;
@


4.4
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d22 1
a22 1
static char RCSspline[] = "@@(#)$Header $ (BRL)";
@


4.3
log
@For Stay, switched 3rd arg to ft_shoot() from resource pointer
(member of application struct) to application struct pointer.
@
text
@d73 5
a77 4
spl_prep( vec, stp, mat )
register fastf_t *vec;
struct soltab *stp;
matp_t mat;			/* Homogenous 4x4, with translation, [15]=1 */
d99 2
a100 2
		i = fread( (char *)&rec, sizeof(rec), 1, rt_i.fp );
		if( feof(rt_i.fp) )  break;
d130 1
a130 1
		i = read( (char *)vp, nby, 1, rt_i.fp );
d149 1
a149 1
		i = fread( (char *)spl->spl_mesh, nby, 1, rt_i.fp );
d364 23
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d243 1
a243 1
spl_shot( stp, rp, res )
d246 1
a246 1
struct resource		*res;
d320 1
a320 1
	GET_SEG(segp, res);
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@@


3.7
log
@Revised for resource structure.
@
text
@@


3.6
log
@Switched to hvect_t where needed.
@
text
@d243 1
a243 1
spl_shot( stp, rp )
d246 1
d320 1
a320 1
	GET_SEG(segp);
@


3.5
log
@Fixed bad return statements.
@
text
@a155 1
			static vect_t	homog;
d157 3
a159 2
				MAT4X3PNT( homog, mat, vp );
				VMOVE( vp, homog );
d161 3
a163 7

#define HDIVIDE(a,b)  \
	(a)[X] = (b)[X] / (b)[H];\
	(a)[Y] = (b)[Y] / (b)[H];\
	(a)[Z] = (b)[Z] / (b)[H];
				HDIVIDE( homog, vp );
				MAT4X3PNT( vp, mat, homog );
d166 1
a166 8
#define MINMAX(a,b,c)	{ FAST fastf_t ftemp;\
			if( (ftemp = (c)) < (a) )  a = ftemp;\
			if( ftemp > (b) )  b = ftemp; }

#define MM(v)	MINMAX( stp->st_min[X], stp->st_max[X], v[X] ); \
		MINMAX( stp->st_min[Y], stp->st_max[Y], v[Y] ); \
		MINMAX( stp->st_min[Z], stp->st_max[Z], v[Z] )
			MM( vp );
@


3.4
log
@Changed #include directives for use with CC -I convention
@
text
@d109 1
a109 1
			return;
d125 1
a125 1
			return;
d145 1
a145 1
			return;
@


3.3
log
@Added uvcoord support
@
text
@d27 5
a31 5
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/db.h"
#include "../h/raytrace.h"
#include "debug.h"
@


3.2
log
@Upgraded to read the database using stdio.
@
text
@d361 2
a362 1
spl_uv( stp, hitp, uvp )
d365 1
a365 1
register fastf_t *uvp;
d369 3
a371 2
	uvp[0] = .2;
	uvp[1] = .2;
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d98 3
a100 3
		i = read( rt_i.fd, (char *) &rec, sizeof(rec) );
		if( i==0 )  break;
		if( i != sizeof(rec) )
d129 2
a130 2
		i = read( rt_i.fd, (char *)vp, nby );
		if( i != nby )  rt_bomb("spl_prep:  knot read");
d148 2
a149 2
		i = read( rt_i.fd, (char *)spl->spl_mesh, nby );
		if( i != nby )  rt_bomb("spl_prep:  knot read");
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header $ (BRL)";
a32 3
#undef EPSILON
#define EPSILON	0.000001

a55 3
#undef EPSILON
#define EPSILON	0.005		/* More appropriate for NEAR_ZERO here */

d768 1
a768 1
		if( NEAR_ZERO(ddotn) )  {
d892 1
a892 1
			if( NEAR_ZERO( norm[i][j] ) )
@


1.2
log
@rt and librt separated
@
text
@d104 1
a104 1
		i = read( ged_fd, (char *) &rec, sizeof(rec) );
d107 1
a107 1
			rtbomb("spl_prep:  read error");
d135 2
a136 2
		i = read( ged_fd, (char *)vp, nby );
		if( i != nby )  rtbomb("spl_prep:  knot read");
d154 2
a155 2
		i = read( ged_fd, (char *)spl->spl_mesh, nby );
		if( i != nby )  rtbomb("spl_prep:  knot read");
d316 1
a316 1
	if(debug&DEBUG_SPLINE)printf("hit at lvl %d\n", spl->spl_lvl);
d604 1
a604 1
	if(debug&DEBUG_SPLINE) for( ii=1; ii <= npts; ii += 3 )  {
d631 1
a631 1
		if( debug&DEBUG_SPLINE)  {
d647 1
a647 1
			if(debug&DEBUG_SPLINE) fprintf(stdout, "	vertex[%d] = (%f, %f, %f)\n",
d753 1
a753 1
	if( debug&DEBUG_SPLINE )  printf("cybk: %f<=t<=%f\n", tl, tu);
d766 1
a766 1
		if( debug&DEBUG_SPLINE )  {
d784 1
a784 1
		if( debug&DEBUG_SPLINE) fprintf(stdout, " t = %f\n", t);
d801 1
a801 1
	if( fdiff(tl,tu) > 0 ) 
d805 1
a805 1
	if( debug&DEBUG_SPLINE )  printf("hit, dist=%f\n", tl);
d904 1
a904 1
	if( debug&DEBUG_SPLINE) for(i=1; i<=5; i++)  {
d950 1
a950 1
	if( debug & DEBUG_SPLINE )
d961 1
a961 1
		if(debug&DEBUG_SPLINE) fprintf(stderr, "%d %d %d\n", i, x[i-1], temp[i] );
d987 1
a987 1
		if( debug&DEBUG_SPLINE)
@


1.1
log
@Initial revision
@
text
@d30 1
a30 1
#include "raytrace.h"
@
