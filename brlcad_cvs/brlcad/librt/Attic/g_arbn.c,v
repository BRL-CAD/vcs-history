head	11.27;
access;
symbols
	ansi-20040405-merged:11.23.2.2
	postmerge-20040405-ansi:11.25
	premerge-20040404-ansi:11.24
	postmerge-autoconf:11.24
	autoconf-freeze:11.23.10.2
	premerge-autoconf:11.24
	ansi-20040316-freeze:11.23.2.1
	postmerge-20040315-windows:11.24
	premerge-20040315-windows:11.24
	windows-20040315-freeze:11.23.4.1
	autoconf-20031203:11.23
	autoconf-20031202:11.23
	autoconf-branch:11.23.0.10
	phong-branch:11.23.0.8
	photonmap-branch:11.23.0.6
	rel-6-1-DP:11.23
	windows-branch:11.23.0.4
	rel-6-0-2:11.21
	ansi-branch:11.23.0.2
	rel-6-0-1-branch:11.21.0.2
	hartley-6-0-post:11.22
	hartley-6-0-pre:11.21
	rel-6-0-1:11.21
	rel-6-0:11.20
	rel-5-4:11.8
	offsite-5-3-pre:11.13
	rel-5-3:11.8
	rel-5-2:11.8
	rel-5-1-branch:11.8.0.2
	rel-5-1:11.8
	rel-5-0:11.4
	rel-5-0-beta:11.3
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.27
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	11.26;

11.26
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.25;

11.25
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.24;

11.24
date	2004.02.02.17.39.16;	author morrison;	state Exp;
branches;
next	11.23;

11.23
date	2002.08.20.17.07.58;	author jra;	state Exp;
branches
	11.23.2.1
	11.23.4.1
	11.23.10.1;
next	11.22;

11.22
date	2002.08.15.20.55.11;	author hartley;	state Exp;
branches;
next	11.21;

11.21
date	2002.05.09.20.25.06;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	2001.10.02.19.24.28;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	2001.07.18.19.30.43;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2001.06.26.13.28.38;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	2001.06.21.18.07.25;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	2001.06.19.18.16.16;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	2001.06.15.14.53.20;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	2001.04.20.22.29.42;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2000.08.21.02.02.29;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	2000.07.10.23.01.29;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.06.30.15.38.02;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.06.30.15.31.14;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.06.29.17.14.14;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	2000.04.12.02.34.30;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.03.29.02.43.09;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.11.26.21.46.44;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.11.17.02.41.56;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.07.02.22.19.22;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	99.05.27.19.10.35;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	99.01.13.21.49.10;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.29;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	95.01.03.21.11.22;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.09.15.16.45.40;	author jra;	state Exp;
branches;
next	10.2;

10.2
date	94.08.10.18.23.58;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.12;	author mike;	state Rel4_0;
branches;
next	1.24;

1.24
date	91.06.30.00.10.45;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	91.06.22.22.30.16;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	91.05.18.03.31.58;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	91.05.18.03.00.43;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	91.02.27.19.49.16;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	91.01.28.23.53.05;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	91.01.26.03.14.39;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	91.01.25.21.52.02;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	91.01.25.21.18.43;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	91.01.25.20.35.22;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	91.01.15.23.43.54;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	91.01.15.01.35.10;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	91.01.11.04.41.28;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	90.12.15.01.13.01;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	90.12.05.20.50.14;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	90.12.05.20.26.59;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	90.10.15.12.00.51;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	90.10.11.02.38.55;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	90.10.06.02.05.08;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	90.04.24.05.06.02;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	90.03.14.15.05.40;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	90.02.08.01.32.31;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.12.09.05.47.00;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.12.09.01.23.06;	author mike;	state Exp;
branches;
next	;

11.23.2.1
date	2002.09.19.18.01.32;	author morrison;	state Exp;
branches;
next	11.23.2.2;

11.23.2.2
date	2004.03.17.21.18.44;	author morrison;	state Exp;
branches;
next	;

11.23.4.1
date	2004.03.11.23.43.36;	author morrison;	state Exp;
branches;
next	;

11.23.10.1
date	2004.02.12.18.37.39;	author erikg;	state Exp;
branches;
next	11.23.10.2;

11.23.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@librt geometry module for ARBN solids
@


11.27
log
@moved to src/
@
text
@/*
 *			G _ A R B N . C
 *  
 *  Function -
 *  	Intersect a ray with an Arbitrary Regular Polyhedron with
 *	an arbitrary number of faces.
 *  
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSarbn[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_arbn.c,v 11.26 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include <ctype.h>
#include "tcl.h"
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "db.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"

RT_EXTERN(void rt_arbn_print, (const struct soltab *stp) );
RT_EXTERN(void rt_arbn_ifree, (struct rt_db_internal *ip) );

/*
 *  			R T _ A R B N _ P R E P
 *
 *  Returns -
 *	 0	OK
 *	!0	failure
 */
int
rt_arbn_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_arbn_internal	*aip;
	vect_t		work;
	fastf_t		f;
	register int	i;
	int		j;
	int		k;
	int		*used = (int *)0;	/* plane eqn use count */
	const struct bn_tol	*tol = &rtip->rti_tol;

	RT_CK_DB_INTERNAL( ip );
	aip = (struct rt_arbn_internal *)ip->idb_ptr;
	RT_ARBN_CK_MAGIC(aip);

	used = (int *)bu_malloc(aip->neqn*sizeof(int), "arbn used[]");

	/*
	 *  ARBN must be convex.  Test for concavity.
	 *  Byproduct is an enumeration of all the verticies,
	 *  which are used to make the bounding RPP.
	 */

	/* Zero face use counts */
	for( i=0; i<aip->neqn; i++ )  {
		used[i] = 0;
	}
	for( i=0; i<aip->neqn-2; i++ )  {
		for( j=i+1; j<aip->neqn-1; j++ )  {
			double	dot;

			/* If normals are parallel, no intersection */
			dot = VDOT( aip->eqn[i], aip->eqn[j] );
			if( BN_VECT_ARE_PARALLEL(dot, tol) )  continue;

			/* Have an edge line, isect with higher numbered planes */
			for( k=j+1; k<aip->neqn; k++ )  {
				register int	m;
				point_t		pt;
				int		next_k;

				next_k = 0;

				if( bn_mkpoint_3planes( pt, aip->eqn[i], aip->eqn[j], aip->eqn[k] ) < 0 )  continue;

				/* See if point is outside arb */
				for( m=0; m<aip->neqn; m++ )  {
					if( i==m || j==m || k==m )  continue;
					if( VDOT(pt, aip->eqn[m])-aip->eqn[m][3] > tol->dist )
					{
						next_k = 1;
						break;
					}
				}
				if( next_k != 0)  continue;

				VMINMAX( stp->st_min, stp->st_max, pt );

				/* Increment "face used" counts */
				used[i]++;
				used[j]++;
				used[k]++;
			}
		}
	}

	/* If any planes were not used, then arbn is not convex */
	for( i=0; i<aip->neqn; i++ )  {
		if( used[i] != 0 )  continue;	/* face was used */
		bu_log("arbn(%s) face %d unused, solid is not convex\n",
			stp->st_name, i);
		bu_free( (char *)used, "arbn used[]");
		return(-1);		/* BAD */
	}
	bu_free( (char *)used, "arbn used[]");

	stp->st_specific = (genptr_t)aip;
	ip->idb_ptr = GENPTR_NULL;	/* indicate we stole it */

	VADD2SCALE( stp->st_center, stp->st_min, stp->st_max, 0.5 );
	VSUB2SCALE( work, stp->st_max, stp->st_min, 0.5 );

	f = work[X];
	if( work[Y] > f )  f = work[Y];
	if( work[Z] > f )  f = work[Z];
	stp->st_aradius = f;
	stp->st_bradius = MAGNITUDE(work);
	return(0);			/* OK */
}

/*
 *  			R T _ A R B N _ P R I N T
 */
void
rt_arbn_print(register const struct soltab *stp)
{
}

/*
 *			R T _ A R B N _ S H O T
 *
 *  Intersect a ray with an ARBN.
 *  Find the largest "in" distance and the smallest "out" distance.
 *  Cyrus & Beck algorithm for convex polyhedra.
 *
 *  Returns -
 *	0	MISS
 *	>0	HIT
 */
int
rt_arbn_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct rt_arbn_internal	*aip =
		(struct rt_arbn_internal *)stp->st_specific;
	register int	i;
	LOCAL int	iplane, oplane;
	LOCAL fastf_t	in, out;	/* ray in/out distances */

	in = -INFINITY;
	out = INFINITY;
	iplane = oplane = -1;

	for( i = aip->neqn-1; i >= 0; i-- )  {
		FAST fastf_t	slant_factor;	/* Direction dot Normal */
		FAST fastf_t	norm_dist;
		FAST fastf_t	s;

		norm_dist = VDOT( aip->eqn[i], rp->r_pt ) - aip->eqn[i][3];
		if( (slant_factor = -VDOT( aip->eqn[i], rp->r_dir )) < -1.0e-10 )  {
			/* exit point, when dir.N < 0.  out = min(out,s) */
			if( out > (s = norm_dist/slant_factor) )  {
				out = s;
				oplane = i;
			}
		} else if ( slant_factor > 1.0e-10 )  {
			/* entry point, when dir.N > 0.  in = max(in,s) */
			if( in < (s = norm_dist/slant_factor) )  {
				in = s;
				iplane = i;
			}
		}  else  {
			/* ray is parallel to plane when dir.N == 0.
			 * If it is outside the solid, stop now
			 * Allow very small amount of slop, to catch
			 * rays that lie very nearly in the plane of a face.
			 */
			if( norm_dist > SQRT_SMALL_FASTF )
				return( 0 );	/* MISS */
		}
		if( in > out )
			return( 0 );	/* MISS */
	}

	/* Validate */
	if( iplane == -1 || oplane == -1 )  {
		bu_log("rt_arbn_shoot(%s): 1 hit => MISS\n",
			stp->st_name);
		return( 0 );	/* MISS */
	}
	if( in >= out || out >= INFINITY )
		return( 0 );	/* MISS */

	{
		register struct seg *segp;

		RT_GET_SEG( segp, ap->a_resource );
		segp->seg_stp = stp;
		segp->seg_in.hit_dist = in;
		segp->seg_in.hit_surfno = iplane;

		segp->seg_out.hit_dist = out;
		segp->seg_out.hit_surfno = oplane;
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	}
	return(2);			/* HIT */
}

/*
 *			R T _ A R B N _ V S H O T
 */
void
rt_arbn_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		 	       /* Number of ray/object pairs */
                  	    
{
	rt_vstub( stp, rp, segp, n, ap );
}

/*
 *  			R T _ A R B N _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_arbn_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct rt_arbn_internal *aip =
		(struct rt_arbn_internal *)stp->st_specific;
	int	h;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	h = hitp->hit_surfno;
	if( h < 0 || h > aip->neqn )  {
		bu_log("rt_arbn_norm(%s): hit_surfno=%d?\n", h );
		VSETALL( hitp->hit_normal, 0 );
		return;
	}
	VMOVE( hitp->hit_normal, aip->eqn[h] );
}

/*
 *			R T _ A R B N _ C U R V E
 *
 *  Return the "curvature" of the ARB face.
 *  Pick a principle direction orthogonal to normal, and 
 *  indicate no curvature.
 */
void
rt_arbn_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{

	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
	cvp->crv_c1 = cvp->crv_c2 = 0;
}

/*
 *  			R T _ A R B N _ U V
 *  
 *  For a hit on a face of an ARB, return the (u,v) coordinates
 *  of the hit point.  0 <= u,v <= 1.
 *  u extends along the arb_U direction defined by B-A,
 *  v extends along the arb_V direction defined by Nx(B-A).
 */
void
rt_arbn_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	uvp->uv_u = uvp->uv_v = 0;
	uvp->uv_du = uvp->uv_dv = 0;
}

/*
 *			R T _ A R B N _ F R E E
 */
void
rt_arbn_free(register struct soltab *stp)
{
	register struct rt_arbn_internal *aip =
		(struct rt_arbn_internal *)stp->st_specific;

	bu_free( (char *)aip->eqn, "rt_arbn_internal eqn[]");
	bu_free( (char *)aip, "rt_arbn_internal" );
}

/*
 *  			R T _ A R B N _ P L O T
 *
 *  Brute force through all possible plane intersections.
 *  Generate all edge lines, then intersect the line with all
 *  the other faces to find the vertices on that line.
 *  If the geometry is correct, there will be no more than two.
 *  While not the fastest strategy, this will produce an accurate
 *  plot without requiring extra bookkeeping.
 *  Note that the vectors will be drawn in no special order.
 */
int
rt_arbn_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register struct rt_arbn_internal	*aip;
	register int	i;
	register int	j;
	register int	k;

	RT_CK_DB_INTERNAL(ip);
	aip = (struct rt_arbn_internal *)ip->idb_ptr;
	RT_ARBN_CK_MAGIC(aip);

	for( i=0; i<aip->neqn-1; i++ )  {
		for( j=i+1; j<aip->neqn; j++ )  {
			double	dot;
			int	point_count;	/* # points on this line */
			point_t	a,b;		/* start and end points */
			vect_t	dist;

			/* If normals are parallel, no intersection */
			dot = VDOT( aip->eqn[i], aip->eqn[j] );
			if( BN_VECT_ARE_PARALLEL(dot, tol) )  continue;

			/* Have an edge line, isect with all other planes */
			point_count = 0;
			for( k=0; k<aip->neqn; k++ )  {
				register int	m;
				point_t		pt;
				int		next_k;

				next_k = 0;

				if( k==i || k==j )  continue;
				if( bn_mkpoint_3planes( pt, aip->eqn[i], aip->eqn[j], aip->eqn[k] ) < 0 )  continue;

				/* See if point is outside arb */
				for( m=0; m<aip->neqn; m++ )  {
					if( i==m || j==m || k==m )  continue;
					if( VDOT(pt, aip->eqn[m])-aip->eqn[m][3] > tol->dist )
					{
						next_k = 1;
						break;
					}
				}

				if( next_k != 0)  continue;

				if( point_count <= 0 )  {
					RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE );
					VMOVE( a, pt );
				} else if( point_count == 1 )  {
					VSUB2( dist, pt, a );
					if( MAGSQ(dist) < tol->dist_sq )  continue;
					RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
					VMOVE( b, pt );
				} else {
					VSUB2( dist, pt, a );
					if( MAGSQ(dist) < tol->dist_sq )  continue;
					VSUB2( dist, pt, b );
					if( MAGSQ(dist) < tol->dist_sq )  continue;
					bu_log("rt_arbn_plot() error, point_count=%d (>2) on edge %d/%d, non-convex\n",
						point_count+1,
						i, j );
					VPRINT(" a", a);
					VPRINT(" b", b);
					VPRINT("pt", pt);
					RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );	/* draw it */
				}
				point_count++;
			}
			/* Point counts of 1 are (generally) not harmful,
			 * occuring on pyramid peaks and the like.
			 */
		}
	}
	return(0);
}

/*
 *			R T _ A R B N _ C L A S S
 */
int
rt_arbn_class(void)
{
	return(0);
}


/* structures used by arbn tessellator */
struct arbn_pts
{
	point_t		pt;		/* coordinates for vertex */
	int		plane_no[3];	/* which planes intersect here */
	struct vertex	**vp;		/* pointer to vertex struct pointer for NMG's */
};
struct arbn_edges
{
	int		v1_no,v2_no;	/* index into arbn_pts for endpoints of edge */
};

#define		LOC(i,j)	i*(aip->neqn)+j

static void
Sort_edges(struct arbn_edges *edges, int *edge_count, const struct rt_arbn_internal *aip)
{
	int face;

	for( face=0 ; face<aip->neqn ; face++ )
	{
		int done=0;
		int edge1,edge2;

		if( edge_count[face] < 3 )
			continue;	/* nothing to sort */

		edge1 = 0;
		edge2 = 0;
		while( !done )
		{
			int edge3;
			int tmp_v1,tmp_v2;

			/* Look for out of order edge (edge2) */
			while( ++edge2 < edge_count[face] &&
				edges[LOC(face,edge1)].v2_no == edges[LOC(face,edge2)].v1_no )
					edge1++;
			if( edge2 == edge_count[face] )
			{
				/* all edges are in order */
				done = 1;
				continue;
			}

			/* look for edge (edge3) that belongs where edge2 is */
			edge3 = edge2 - 1;
			while( ++edge3 < edge_count[face] &&
				edges[LOC(face,edge1)].v2_no != edges[LOC(face,edge3)].v1_no &&
				edges[LOC(face,edge1)].v2_no != edges[LOC(face,edge3)].v2_no );

			if( edge3 == edge_count[face] )
				rt_bomb( "rt_arbn_tess: Sort_edges: Cannot find next edge in loop\n" );

			if( edge2 != edge3 )
			{
				/* swap edge2 and edge3 */
				tmp_v1 = edges[LOC(face,edge2)].v1_no;
				tmp_v2 = edges[LOC(face,edge2)].v2_no;
				edges[LOC(face,edge2)].v1_no = edges[LOC(face,edge3)].v1_no;
				edges[LOC(face,edge2)].v2_no = edges[LOC(face,edge3)].v2_no;
				edges[LOC(face,edge3)].v1_no = tmp_v1;
				edges[LOC(face,edge3)].v2_no = tmp_v2;
			}
			if( edges[LOC(face,edge1)].v2_no == edges[LOC(face,edge2)].v2_no )
			{
				/* reverse order of edge */
				tmp_v1 = edges[LOC(face,edge2)].v1_no;
				edges[LOC(face,edge2)].v1_no = edges[LOC(face,edge2)].v2_no;
				edges[LOC(face,edge2)].v2_no = tmp_v1;
			}

			edge1 = edge2;
		}
	}
}

/*
 *			R T _ A R B N _ T E S S
 *
 *  "Tessellate" an ARB into an NMG data structure.
 *  Purely a mechanical transformation of one faceted object
 *  into another.
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_arbn_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct rt_arbn_internal	*aip;
	struct shell		*s;
	struct faceuse		**fu;		/* array of faceuses */
	int			nverts;		/* maximum possible number of vertices = neqn!/(3!(neqn-3)! */
	int			point_count=0;	/* actual number of vertices */
	int			face_count=0;	/* actual number of faces built */
	int			i,j,k,l,n;
	struct arbn_pts		*pts;
	struct arbn_edges	*edges;		/* A list of edges for each plane eqn (each face) */
	int			*edge_count;	/* number of edges for each face */
	int			max_edge_count; /* maximium number of edges for any face */
	struct vertex		**verts;	/* Array of pointers to vertex structs */
	struct vertex		***loop_verts;	/* Array of pointers to vertex structs to pass to nmg_cmface */

	RT_CK_DB_INTERNAL(ip);
	aip = (struct rt_arbn_internal *)ip->idb_ptr;
	RT_ARBN_CK_MAGIC(aip);

	/* Allocate memory for the vertices */
	nverts = aip->neqn * (aip->neqn-1) * (aip->neqn-2) / 6;
	pts = (struct arbn_pts *)bu_calloc( nverts , sizeof( struct arbn_pts ) , "rt_arbn_tess: pts" );

	/* Allocate memory for arbn_edges */
	edges = (struct arbn_edges *)bu_calloc( aip->neqn*aip->neqn , sizeof( struct arbn_edges ) ,
			"rt_arbn_tess: edges" );
	edge_count = (int *)bu_calloc( aip->neqn , sizeof( int ) , "rt_arbn_tess: edge_count" );

	/* Allocate memory for faceuses */
	fu = (struct faceuse **)bu_calloc( aip->neqn , sizeof( struct faceuse *) , "rt_arbn_tess: fu" );

	/* Calculate all vertices */
	for( i=0 ; i<aip->neqn ; i++ )
	{
		for( j=i+1 ; j<aip->neqn ; j++ )
		{
			for( k=j+1 ; k<aip->neqn ; k++ )
			{
				int keep_point=1;

				if( bn_mkpoint_3planes( pts[point_count].pt, aip->eqn[i], aip->eqn[j], aip->eqn[k]))
					continue;

				for( l=0 ; l<aip->neqn ; l++ )
				{
					if( l == i || l == j || l == k )
						continue;
					if( DIST_PT_PLANE( pts[point_count].pt , aip->eqn[l] ) > tol->dist )
					{
						keep_point = 0;
						break;
					}
				}
				if( keep_point )
				{
					pts[point_count].plane_no[0] = i;
					pts[point_count].plane_no[1] = j;
					pts[point_count].plane_no[2] = k;
					point_count++;
				}
			}
		}
	}

	/* Allocate memory for the NMG vertex pointers */
	verts = (struct vertex **)bu_calloc( point_count , sizeof( struct vertex *) ,
			"rt_arbn_tess: verts" );

	/* Associate points with vertices */
	for( i=0 ; i<point_count ; i++ )
		pts[i].vp = &verts[i];

	/* Check for duplicate points */
	for( i=0 ; i<point_count ; i++ )
	{
		for( j=i+1 ; j<point_count ; j++ )
		{
			vect_t dist;

			VSUB2( dist , pts[i].pt , pts[j].pt )
			if( MAGSQ( dist ) < tol->dist_sq )
			{
				/* These two points should point to the same vertex */
				pts[j].vp = pts[i].vp;
			}
		}
	}

	/* Make list of edges for each face */
	for( i=0 ; i<aip->neqn ; i++ )
	{
		/* look for a point that lies in this face */
		for( j=0 ; j<point_count ; j++ )
		{
			if( pts[j].plane_no[0] != i && pts[j].plane_no[1] != i && pts[j].plane_no[2] != i )
				continue;

			/* look for another point that shares plane "i" and another with this one */
			for( k=j+1 ; k<point_count ; k++ )
			{
				int match=(-1);
				int pt1,pt2;
				int duplicate=0;

				/* skip points not on plane "i" */
				if( pts[k].plane_no[0] != i && pts[k].plane_no[1] != i && pts[k].plane_no[2] != i )
					continue;

				for( l=0 ; l<3 ; l++ )
				{
					for( n=0 ; n<3 ; n++ )
					{
						if( pts[j].plane_no[l] == pts[k].plane_no[n] &&
						    pts[j].plane_no[l] != i )
						{
							match = pts[j].plane_no[l];
							break;
						}
					}
					if( match != (-1) )
						break;
				}

				if( match == (-1) )
					continue;

				/* convert equivalent points to lowest point number */
				pt1 = j;
				pt2 = k;
				for( l=0 ; l<pt1 ; l++ )
				{
					if( pts[pt1].vp == pts[l].vp )
					{
						pt1 = l;
						break;
					}
				}
				for( l=0 ; l<pt2 ; l++ )
				{
					if( pts[pt2].vp == pts[l].vp )
					{
						pt2 = l;
						break;
					}
				}

				/* skip null edges */
				if( pt1 == pt2 )
					continue;

				/* check for duplicate edge */
				for( l=0 ; l<edge_count[i] ; l++ )
				{
					if( (edges[LOC(i,l)].v1_no == pt1 &&
					    edges[LOC(i,l)].v2_no == pt2) ||
					    (edges[LOC(i,l)].v2_no == pt1 &&
					    edges[LOC(i,l)].v1_no == pt2) )
					{
						duplicate = 1;
						break;
					}
				}
				if( duplicate )
					continue;

				/* found an edge belonging to faces "i" and "match" */
				if( edge_count[i] == aip->neqn )
				{
					bu_log( "Too many edges found for one face\n" );
					goto fail;
				}
				edges[LOC( i , edge_count[i] )].v1_no = pt1;
				edges[LOC( i , edge_count[i] )].v2_no = pt2;
				edge_count[i]++;
			}
		}
	}

	/* for each face, sort the list of edges into a loop */
	Sort_edges( edges , edge_count , aip );

	/* Get max number of edges for any face */
	max_edge_count = 0;
	for( i=0 ; i<aip->neqn ; i++ )
		if( edge_count[i] > max_edge_count )
			max_edge_count = edge_count[i];

	/* Allocate memory for array to pass to nmg_cmface */
	loop_verts = (struct vertex ***) bu_calloc( max_edge_count , sizeof( struct vertex **) ,
				"rt_arbn_tess: loop_verts" );

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	/* Make the faces */
	for( i=0 ; i<aip->neqn ; i++ )
	{
		int loop_length=0;

		for( j=0 ; j<edge_count[i] ; j++ )
		{
			/* skip zero length edges */
			if( pts[edges[LOC(i,j)].v1_no].vp == pts[edges[LOC(i,j)].v2_no].vp )
				continue;

			/* put vertex pointers into loop_verts array */
			loop_verts[loop_length] = pts[edges[LOC(i,j)].v2_no].vp;
			loop_length++;
		}

		/* Make the face if there is are least 3 vertices */
		if( loop_length > 2 )
			fu[face_count++] = nmg_cmface( s , loop_verts , loop_length );
	}

	/* Associate vertex geometry */
	for( i=0 ; i<point_count ; i++ )
	{
		if( !(*pts[i].vp) )
			continue;

		if( (*pts[i].vp)->vg_p )
			continue;

		nmg_vertex_gv( *pts[i].vp , pts[i].pt );
	}

	bu_free( (char *)pts , "rt_arbn_tess: pts" );
	bu_free( (char *)edges , "rt_arbn_tess: edges" );
	bu_free( (char *)edge_count , "rt_arbn_tess: edge_count" );
	bu_free( (char *)verts , "rt_arbn_tess: verts" );
	bu_free( (char *)loop_verts , "rt_arbn_tess: loop_verts" );

	/* Associate face geometry */
	for( i=0 ; i<face_count ; i++ )
	{
		if( nmg_fu_planeeqn( fu[i] , tol ) )
		{
			bu_log( "Failed to calculate face plane equation\n" );
			bu_free( (char *)fu , "rt_arbn_tess: fu" );
			nmg_kr( *r );
			*r = (struct nmgregion *)NULL;
			return( -1 );
		}
	}

	bu_free( (char *)fu , "rt_arbn_tess: fu" );

	nmg_fix_normals( s , tol );

	(void)nmg_mark_edges_real( &s->l.magic );

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

	return( 0 );

fail:
	bu_free( (char *)pts , "rt_arbn_tess: pts" );
	bu_free( (char *)edges , "rt_arbn_tess: edges" );
	bu_free( (char *)edge_count , "rt_arbn_tess: edge_count" );
	bu_free( (char *)verts , "rt_arbn_tess: verts" );
	return( -1 );	
}

/*
 *			R T _ A R B N _ I M P O R T
 *
 *  Convert from "network" doubles to machine specific.
 *  Transform
 */
int
rt_arbn_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	union record		*rp;
	struct rt_arbn_internal	*aip;
	register int	i;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	if( rp->u_id != DBID_ARBN )  {
		bu_log("rt_arbn_import: defective record, id=x%x\n", rp->u_id );
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_ARBN;
	ip->idb_meth = &rt_functab[ID_ARBN];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_arbn_internal), "rt_arbn_internal");
	aip = (struct rt_arbn_internal *)ip->idb_ptr;
	aip->magic = RT_ARBN_INTERNAL_MAGIC;
	aip->neqn = bu_glong( rp->n.n_neqn );
	if( aip->neqn <= 0 )  return(-1);
	aip->eqn = (plane_t *)bu_malloc( aip->neqn*sizeof(plane_t), "arbn plane eqn[]");

	ntohd( (unsigned char *)aip->eqn, (unsigned char *)(&rp[1]), aip->neqn*4 );

	/* Transform by the matrix */
#	include "noalias.h"
	for( i=0; i < aip->neqn; i++ )  {
		point_t	orig_pt;
		point_t	pt;
		vect_t	norm;

		/* Pick a point on the original halfspace */
		VSCALE( orig_pt, aip->eqn[i], aip->eqn[i][3] );

		/* Transform the point, and the normal */
		MAT4X3VEC( norm, mat, aip->eqn[i] );
		MAT4X3PNT( pt, mat, orig_pt );

		/* Measure new distance from origin to new point */
		VUNITIZE( norm );
		VMOVE( aip->eqn[i], norm );
		aip->eqn[i][3] = VDOT( pt, norm );
	}

	return(0);
}

/*
 *			R T _ A R B N _ E X P O R T
 */
int
rt_arbn_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_arbn_internal	*aip;
	union record		*rec;
	int			ngrans;
	double			*sbuf;		/* scalling buffer */
	register double		*sp;
	register int		i;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ARBN )  return(-1);
	aip = (struct rt_arbn_internal *)ip->idb_ptr;
	RT_ARBN_CK_MAGIC(aip);

	if( aip->neqn <= 0 )  return(-1);

	/*
	 * The network format for a double is 8 bytes and there are 4
	 * doubles per plane equation.
	 */
	ngrans = (aip->neqn * 8 * 4 + sizeof(union record)-1 ) /
		sizeof(union record);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = (ngrans + 1) * sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "arbn external");
	rec = (union record *)ep->ext_buf;

	rec[0].n.n_id = DBID_ARBN;
	(void)bu_plong( rec[0].n.n_neqn, aip->neqn );
	(void)bu_plong( rec[0].n.n_grans, ngrans );

	/* Take the data from the caller, and scale it, into sbuf */
	sp = sbuf = (double *)bu_malloc(
		aip->neqn * sizeof(double) * 4, "arbn temp");
	for( i=0; i<aip->neqn; i++ )  {
		/* Normal is unscaled, should have unit length; d is scaled */
		*sp++ = aip->eqn[i][X];
		*sp++ = aip->eqn[i][Y];
		*sp++ = aip->eqn[i][Z];
		*sp++ = aip->eqn[i][3] * local2mm;
	}

	htond( (unsigned char *)&rec[1], (unsigned char *)sbuf, aip->neqn * 4 );

	bu_free( (char *)sbuf, "arbn temp" );
	return(0);			/* OK */
}


/*
 *			R T _ A R B N _ I M P O R T 5
 *
 *  Convert from "network" doubles to machine specific.
 *  Transform
 */
int
rt_arbn_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_arbn_internal	*aip;
	register int		i;
	unsigned long		neqn;
	int			double_count;
	int			byte_count;

	BU_CK_EXTERNAL( ep );

	neqn = bu_glong((unsigned char *)ep->ext_buf);
	double_count = neqn * ELEMENTS_PER_PLANE;
	byte_count = double_count * SIZEOF_NETWORK_DOUBLE;

	BU_ASSERT_LONG(ep->ext_nbytes, ==, 4+ byte_count);

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_ARBN;
	ip->idb_meth = &rt_functab[ID_ARBN];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_arbn_internal), "rt_arbn_internal");

	aip = (struct rt_arbn_internal *)ip->idb_ptr;
	aip->magic = RT_ARBN_INTERNAL_MAGIC;
	aip->neqn = neqn;
	if (aip->neqn <= 0)  return(-1);
	aip->eqn = (plane_t *)bu_malloc(byte_count, "arbn plane eqn[]");

	ntohd((unsigned char *)aip->eqn, (unsigned char *)ep->ext_buf + 4, double_count);

	/* Transform by the matrix, if we have one that is not the identity */
#	include "noalias.h"
	if( mat && !bn_mat_is_identity( mat ) ) {
		for (i=0; i < aip->neqn; i++) {
			point_t	orig_pt;
			point_t	pt;
			vect_t	norm;

			/* Pick a point on the original halfspace */
			VSCALE( orig_pt, aip->eqn[i], aip->eqn[i][3] );

			/* Transform the point, and the normal */
			MAT4X3VEC( norm, mat, aip->eqn[i] );
			MAT4X3PNT( pt, mat, orig_pt );

			/* Measure new distance from origin to new point */
			VUNITIZE( norm );
			VMOVE( aip->eqn[i], norm );
			aip->eqn[i][3] = VDOT( pt, norm );
		}
	}

	return(0);
}

/*
 *			R T _ A R B N _ E X P O R T 5
 */
int
rt_arbn_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_arbn_internal	*aip;
	register int		i;
	fastf_t			*vec;
	register fastf_t	*sp;
	int			double_count;
	int			byte_count;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ARBN )  return(-1);
	aip = (struct rt_arbn_internal *)ip->idb_ptr;
	RT_ARBN_CK_MAGIC(aip);

	if( aip->neqn <= 0 )  return(-1);

	double_count = aip->neqn * ELEMENTS_PER_PLANE;
	byte_count = double_count * SIZEOF_NETWORK_DOUBLE;

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = 4 + byte_count;
	ep->ext_buf = (genptr_t)bu_malloc(ep->ext_nbytes, "arbn external");

	(void)bu_plong((unsigned char *)ep->ext_buf, aip->neqn);

	/* Take the data from the caller, and scale it, into vec */
	sp = vec = (double *)bu_malloc(byte_count, "arbn temp");
	for (i=0; i<aip->neqn; i++) {
		/* Normal is unscaled, should have unit length; d is scaled */
		*sp++ = aip->eqn[i][X];
		*sp++ = aip->eqn[i][Y];
		*sp++ = aip->eqn[i][Z];
		*sp++ = aip->eqn[i][3] * local2mm;
	}

	/* Convert from internal (host) to database (network) format */
	htond((unsigned char *)ep->ext_buf + 4, (unsigned char *)vec, double_count);

	bu_free((char *)vec, "arbn temp");
	return(0);			/* OK */
}


/*
 *			R T _ A R B N _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_arbn_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_arbn_internal	*aip =
		(struct rt_arbn_internal *)ip->idb_ptr;
	char	buf[256];
	int	i;

	RT_ARBN_CK_MAGIC(aip);
	sprintf(buf, "arbn bounded by %d planes\n", aip->neqn);
	bu_vls_strcat( str, buf );

	if( !verbose )  return(0);

	for( i=0; i < aip->neqn; i++ )  {
		sprintf(buf, "\t%d: (%g, %g, %g) %g\n",
			i,
			aip->eqn[i][X],		/* should have unit length */
			aip->eqn[i][Y],
			aip->eqn[i][Z],
			aip->eqn[i][3] * mm2local );
		bu_vls_strcat( str, buf );
	}
	return(0);
}


/*
 *			R T _ A R B N _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_arbn_ifree(struct rt_db_internal *ip)
{
	struct rt_arbn_internal	*aip;

	RT_CK_DB_INTERNAL(ip);
	aip = (struct rt_arbn_internal *)ip->idb_ptr;
	RT_ARBN_CK_MAGIC(aip);

	if( aip->neqn > 0 )
		bu_free( (char *)aip->eqn, "rt_arbn_internal eqn[]");
	bu_free( (char *)aip, "rt_arbn_internal" );

	ip->idb_ptr = (genptr_t)0;	/* sanity */
}

/*
 * 		R T _ A R B N _ T C L G E T
 *
 *	Routine to format the parameters of an ARBN primitive for "db get"
 *
 *	Legal requested parameters include:
 *		"N" - number of equations
 *		"P" - list of all the planes
 *		"P#" - the specified plane number (0 based)
 *		no arguments returns everything
 */

int
rt_arbn_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
	register struct rt_arbn_internal *arbn=(struct rt_arbn_internal *)intern->idb_ptr;
	Tcl_DString	ds;
	struct bu_vls	vls;
	int		i;

	RT_ARBN_CK_MAGIC( arbn );

	Tcl_DStringInit( &ds );
	bu_vls_init( &vls );

	if( attr == (char *)NULL ) {
		bu_vls_strcpy( &vls, "arbn" );
		bu_vls_printf( &vls, " N %d", arbn->neqn );
		for( i=0 ; i<arbn->neqn ; i++ ) {
			bu_vls_printf( &vls, " P%d {%.25g %.25g %.25g %.25g}", i,
				       V4ARGS( arbn->eqn[i] ) );
		}
	}
	else if( !strcmp( attr, "N" ) )
		bu_vls_printf( &vls, "%d", arbn->neqn );
	else if( !strcmp( attr, "P" ) ) {
		for( i=0 ; i<arbn->neqn ; i++ ) {
			bu_vls_printf( &vls, " P%d {%.25g %.25g %.25g %.25g}", i,
				       V4ARGS( arbn->eqn[i] ) );
		}
	}
	else if( attr[0] == 'P' ) {
		if( isdigit( attr[1] ) == 0 ) {
			Tcl_SetResult( interp, "ERROR: Illegal plane number\n",
				       TCL_STATIC );
			bu_vls_free( &vls );
			return( TCL_ERROR );
		}

		i = atoi( &attr[1] );
		if( i >= arbn->neqn || i < 0 ) {
			Tcl_SetResult( interp, "ERROR: Illegal plane number\n",
				       TCL_STATIC );
			bu_vls_free( &vls );
			return( TCL_ERROR );
		}

		bu_vls_printf( &vls, "%.25g %.25g %.25g %.25g", V4ARGS( arbn->eqn[i] ) );
	}
	else {
		Tcl_SetResult( interp,"ERROR: Unknown attribute, choices are N, P, or P#\n",
		TCL_STATIC );
		bu_vls_free( &vls );
		return( TCL_ERROR );       
	}

	Tcl_DStringAppend( &ds, bu_vls_addr( &vls ), -1 );
	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );
	bu_vls_free( &vls );
	return( TCL_OK );
}

/*
 *		R T _ A R B N _ T C L A D J U S T
 *
 *	Routine to modify an arbn via the "db adjust" command
 *
 *	Legal parameters are:
 *		"N" - adjust the number of planes (new ones will be zeroed)
 *		"P" - adjust the entire list of planes
 *		"P#" - adjust a specific plane (0 based)
 *		"P+" - add a new plane to the list of planes
 */

int
rt_arbn_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
{
	struct rt_arbn_internal *arbn;
	unsigned char		*c;
	int			len;
	int			i, j;
	fastf_t			*new_planes;
	fastf_t			*array;

	RT_CK_DB_INTERNAL( intern );

	arbn = (struct rt_arbn_internal *)intern->idb_ptr;
	RT_ARBN_CK_MAGIC( arbn );

	while( argc >= 2 ) {
		if( !strcmp( argv[0], "N" ) ) {
			i = atoi( argv[1] );
			if( i == arbn->neqn )
				goto cont;
			if( i > 0 ) {
				arbn->eqn = (plane_t *)bu_realloc( arbn->eqn,
						   i * sizeof( plane_t ),
								   "arbn->eqn");
				for( j=arbn->neqn ; j<i ; j++ ) {
					VSETALLN( arbn->eqn[j], 0.0, 4 );
				}
				arbn->neqn = i;
			} else {
				Tcl_SetResult( interp,
				       "ERROR: number of planes must be greater than 0\n",
					TCL_STATIC );
			}
		}
		else if( !strcmp( argv[0], "P" ) ) {
			/* eliminate all the '{' and '}' chars */
			c = (unsigned char *)argv[1];
			while( *c != '\0' ) {
				if( *c == '{' || *c == '}' )
					*c = ' ';
				c++;
			}
			len = 0;
			(void)tcl_list_to_fastf_array( interp, argv[1], &new_planes, &len );

			if( len%4 ) {
				Tcl_SetResult( interp,
				       "ERROR: Incorrect number of plane coefficients\n",
					TCL_STATIC );
				if( len )
					bu_free( (char *)new_planes, "new_planes" );
				return( TCL_ERROR );
			}
			if( arbn->eqn )
				bu_free( (char *)arbn->eqn, "arbn->eqn" );
			arbn->eqn = (plane_t *)new_planes;
			arbn->neqn = len / 4;
			for( i=0 ; i<arbn->neqn ; i++ )
				VUNITIZE( arbn->eqn[i] );
		}
		else if( argv[0][0] == 'P' ) {
			if( argv[0][1] == '+' ) {
				i = arbn->neqn;
				arbn->neqn++;
				arbn->eqn = (plane_t *)bu_realloc( arbn->eqn,
							 (arbn->neqn) * sizeof( plane_t ),
							 "arbn->eqn" );
			}
			else if( isdigit( argv[0][1] ) ) {
				i = atoi( &argv[0][1] );
			} else {
				Tcl_SetResult( interp,
				   "ERROR: illegal argument, choices are P, P#, P+, or N\n",
				   TCL_STATIC );
				return( TCL_ERROR );
			}
			if( i < 0 || i >= arbn->neqn ) {
				Tcl_SetResult( interp,
					       "ERROR: plane number out of range\n",
					       TCL_STATIC );
				return( TCL_ERROR );
			}
			len = 4;
			array = (fastf_t *)&arbn->eqn[i];
			if( tcl_list_to_fastf_array( interp, argv[1],
							  &array, &len ) != 4 ) {
				Tcl_SetResult( interp,
				    "ERROR: incorrect number of coefficients for a plane\n",
				    TCL_STATIC );
				return( TCL_ERROR );
			}
			VUNITIZE( arbn->eqn[i] );
		}
		else {
			Tcl_SetResult( interp,
			      "ERROR: illegal argument, choices are P, P#, P+, or N\n",
			      TCL_STATIC );
			return( TCL_ERROR );
		}
	cont:
		argc -= 2;
		argv += 2;
	}
	return( TCL_OK );
}
@


11.26
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /cvs/brlcad/librt/g_arbn.c,v 11.25 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.25
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.24
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.23 2002/08/20 17:07:58 jra Exp $ (BRL)";
d52 1
a52 4
rt_arbn_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d146 1
a146 2
rt_arbn_print( stp )
register const struct soltab *stp;
d162 1
a162 5
rt_arbn_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d233 6
a238 6
rt_arbn_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		 	    n; /* Number of ray/object pairs */
struct application	*ap;
d249 1
a249 4
rt_arbn_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d273 1
a273 4
rt_arbn_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d289 1
a289 5
rt_arbn_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d299 1
a299 2
rt_arbn_free( stp )
register struct soltab *stp;
d320 1
a320 5
rt_arbn_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d401 1
a401 1
rt_arbn_class()
d422 1
a422 4
Sort_edges( edges , edge_count , aip )
struct arbn_edges *edges;
int *edge_count;
const struct rt_arbn_internal   *aip;
d496 1
a496 6
rt_arbn_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d769 1
a769 5
rt_arbn_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d822 1
a822 5
rt_arbn_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d879 1
a879 5
rt_arbn_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d938 1
a938 5
rt_arbn_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d989 1
a989 5
rt_arbn_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1021 1
a1021 2
rt_arbn_ifree( ip )
struct rt_db_internal	*ip;
d1049 1
a1049 4
rt_arbn_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d1122 1
a1122 5
rt_arbn_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
@


11.23
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1989 by the United States Army.
d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.21 2002/05/09 20:25:06 jra Exp $ (BRL)";
@


11.23.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_arbn.c,v 11.24 2004/02/02 17:39:16 morrison Exp $ (BRL)";
@


11.23.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.24 2004/02/02 17:39:16 morrison Exp $ (BRL)";
@


11.23.10.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.23.10.1 2004/02/12 18:37:39 erikg Exp $ (BRL)";
@


11.23.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.23 2002/08/20 17:07:58 jra Exp $ (BRL)";
d52 4
a55 1
rt_arbn_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d149 2
a150 1
rt_arbn_print(register const struct soltab *stp)
d166 5
a170 1
rt_arbn_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d241 6
a246 6
rt_arbn_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		 	       /* Number of ray/object pairs */
                  	    
d257 4
a260 1
rt_arbn_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d284 4
a287 1
rt_arbn_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d303 5
a307 1
rt_arbn_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d317 2
a318 1
rt_arbn_free(register struct soltab *stp)
d339 5
a343 1
rt_arbn_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d424 1
a424 1
rt_arbn_class(void)
d445 4
a448 1
Sort_edges(struct arbn_edges *edges, int *edge_count, const struct rt_arbn_internal *aip)
d522 6
a527 1
rt_arbn_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d800 5
a804 1
rt_arbn_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d857 5
a861 1
rt_arbn_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d918 5
a922 1
rt_arbn_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d981 5
a985 1
rt_arbn_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1036 5
a1040 1
rt_arbn_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1072 2
a1073 1
rt_arbn_ifree(struct rt_db_internal *ip)
d1101 4
a1104 1
rt_arbn_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d1177 5
a1181 1
rt_arbn_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


11.23.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header$ (BRL)";
@


11.22
log
@Converted from K&R to ANSI C - RFH
@
text
@d52 4
a55 1
rt_arbn_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d149 2
a150 1
rt_arbn_print(register const struct soltab *stp)
d166 5
a170 1
rt_arbn_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d241 6
a246 6
rt_arbn_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		 	       /* Number of ray/object pairs */
                  	    
d257 4
a260 1
rt_arbn_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d284 4
a287 1
rt_arbn_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d303 5
a307 1
rt_arbn_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d317 2
a318 1
rt_arbn_free(register struct soltab *stp)
d339 5
a343 1
rt_arbn_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d424 1
a424 1
rt_arbn_class(void)
d445 4
a448 1
Sort_edges(struct arbn_edges *edges, int *edge_count, const struct rt_arbn_internal *aip)
d522 6
a527 1
rt_arbn_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d800 5
a804 1
rt_arbn_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d857 5
a861 1
rt_arbn_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d918 5
a922 1
rt_arbn_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d981 5
a985 1
rt_arbn_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1036 5
a1040 1
rt_arbn_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1072 2
a1073 1
rt_arbn_ifree(struct rt_db_internal *ip)
d1101 4
a1104 1
rt_arbn_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d1177 5
a1181 1
rt_arbn_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


11.21
log
@Fixed a bug in tclget.
Also, modified import5 to not transform if supplied matrix is identity
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.20 2001/10/02 19:24:28 jra Exp $ (BRL)";
d52 1
a52 4
rt_arbn_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d146 1
a146 2
rt_arbn_print( stp )
register const struct soltab *stp;
d162 1
a162 5
rt_arbn_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d233 6
a238 6
rt_arbn_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		 	    n; /* Number of ray/object pairs */
struct application	*ap;
d249 1
a249 4
rt_arbn_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d273 1
a273 4
rt_arbn_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d289 1
a289 5
rt_arbn_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d299 1
a299 2
rt_arbn_free( stp )
register struct soltab *stp;
d320 1
a320 5
rt_arbn_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d401 1
a401 1
rt_arbn_class()
d422 1
a422 4
Sort_edges( edges , edge_count , aip )
struct arbn_edges *edges;
int *edge_count;
const struct rt_arbn_internal   *aip;
d496 1
a496 6
rt_arbn_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d769 1
a769 5
rt_arbn_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d822 1
a822 5
rt_arbn_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d879 1
a879 5
rt_arbn_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d938 1
a938 5
rt_arbn_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d989 1
a989 5
rt_arbn_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1021 1
a1021 2
rt_arbn_ifree( ip )
struct rt_db_internal	*ip;
d1049 1
a1049 4
rt_arbn_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d1122 1
a1122 5
rt_arbn_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
@


11.20
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.19 2001/07/18 19:30:43 morrison Exp $ (BRL)";
d952 1
a952 1
	/* Transform by the matrix */
d954 18
a971 16
	for (i=0; i < aip->neqn; i++) {
		point_t	orig_pt;
		point_t	pt;
		vect_t	norm;

		/* Pick a point on the original halfspace */
		VSCALE( orig_pt, aip->eqn[i], aip->eqn[i][3] );

		/* Transform the point, and the normal */
		MAT4X3VEC( norm, mat, aip->eqn[i] );
		MAT4X3PNT( pt, mat, orig_pt );

		/* Measure new distance from origin to new point */
		VUNITIZE( norm );
		VMOVE( aip->eqn[i], norm );
		aip->eqn[i][3] = VDOT( pt, norm );
d1128 1
a1128 1
			bu_vls_printf( &vls, " P%d {%.25g %.25g %.25g}", i,
@


11.19
log
@Quelled compile warnings for m4i65
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.18 2001/06/26 13:28:38 jra Exp $ (BRL)";
d818 1
d939 1
@


11.18
log
@Plane equations must be kept noramlized
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.17 2001/06/21 18:07:25 jra Exp $ (BRL)";
d1212 1
a1212 1
			c = argv[1];
@


11.17
log
@Continueing to add tcladjust and tclget support
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.16 2001/06/19 18:16:16 jra Exp $ (BRL)";
d844 1
d965 1
@


11.16
log
@Added some comments and some code to insure that arbn plane equations use unit normals
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.15 2001/06/15 14:53:20 jra Exp $ (BRL)";
d1180 1
a1180 1
	int			i;
a1182 1
	int			ret;
d1191 4
a1194 3
			i = arbn->neqn;
			arbn->neqn = atoi( argv[1] );
			if( arbn->neqn > 0 ) {
d1196 1
a1196 1
						   arbn->neqn * sizeof( plane_t ),
d1198 2
a1199 2
				for( ; i<arbn->neqn ; i++ ) {
					VSETALLN( arbn->eqn[i], 0.0, 4 );
d1201 1
a1202 1
				arbn->neqn = i;
d1217 1
a1217 4
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new_planes,
							  &len )) != TCL_OK ) {
				return( ret );
			}
d1246 2
a1247 2
					       "ERROR: illegal argument, choices are P, P#, P+, or N\n",
					       TCL_STATIC );
d1258 6
a1263 3
			if( (ret=tcl_list_to_fastf_array( interp, argv[1],
							  &array, &len ) ) != TCL_OK ) {
				return( ret );
d1267 7
@


11.15
log
@Added tcl_get and tcl_adjust routines for ARBN solids
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.14 2001/04/20 22:29:42 morrison Exp $ (BRL)";
d1075 2
a1076 1
	bu_free( (char *)aip->eqn, "rt_arbn_internal eqn[]");
d1082 12
d1158 12
d1192 1
d1194 13
a1206 3
			arbn->eqn = (plane_t *)bu_realloc( arbn->eqn,
					     arbn->neqn * sizeof( plane_t ),
							   "arbn->eqn");
d1234 2
d1238 10
a1247 1
			if( !isdigit( argv[0][1] ) ) {
d1249 1
a1249 1
					       "ERROR: Illegal plane number\n",
d1253 1
a1253 2
			i = atoi( &argv[0][1] );
			if( i < 0 || i > arbn->neqn ) {
a1258 5
			if( i == arbn->neqn ) {
				arbn->eqn = (plane_t *)bu_realloc( arbn->eqn,
							 (i+1) * sizeof( plane_t ),
							 "arbn->eqn" );
			}
a1262 3
				arbn->eqn = (plane_t *)bu_realloc( arbn->eqn,
							 arbn->neqn * sizeof( plane_t ),
							 "arbn->eqn" );
d1265 1
a1265 2
			if( i == arbn->neqn )
				arbn->neqn++;
@


11.14
log
@CONST to const
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.13 2000/08/21 02:02:29 butler Exp $ (BRL)";
d27 3
d31 2
d1079 155
@


11.13
log
@Massive compilation warnings eliminated
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.12 2000/07/10 23:01:29 mike Exp $ (BRL)";
d36 1
a36 1
RT_EXTERN(void rt_arbn_print, (CONST struct soltab *stp) );
d59 1
a59 1
	CONST struct bn_tol	*tol = &rtip->rti_tol;
d145 1
a145 1
register CONST struct soltab *stp;
d337 2
a338 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d443 1
a443 1
CONST struct rt_arbn_internal   *aip;
d521 2
a522 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d797 3
a799 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d852 1
a852 1
CONST struct rt_db_internal	*ip;
d854 1
a854 1
CONST struct db_i		*dbip;
d913 3
a915 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d972 1
a972 1
CONST struct rt_db_internal	*ip;
d974 1
a974 1
CONST struct db_i		*dbip;
d1027 1
a1027 1
CONST struct rt_db_internal	*ip;
@


11.12
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d21 1
a21 1
static const char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.11 2000/06/30 15:38:02 mike Exp $ (BRL)";
a976 1
	int			ngrans;
@


11.11
log
@
export methods should not init the external structure, just check them.
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.10 2000/06/30 15:31:14 mike Exp $ (BRL)";
@


11.10
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.9 2000/06/29 17:14:14 bparker Exp $ (BRL)";
d877 1
a877 1
	BU_INIT_EXTERNAL(ep);
d994 1
a994 1
	BU_INIT_EXTERNAL(ep);
@


11.9
log
@Add rt_arbn_import5 and rt_arbn_export5 routines.
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.8 2000/04/12 02:34:30 mike Exp $ (BRL)";
d812 1
a812 1
	RT_INIT_DB_INTERNAL( ip );
d931 1
a931 1
	RT_INIT_DB_INTERNAL( ip );
@


11.8
log
@
NT port, non-compat4
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.7 2000/03/29 02:43:09 mike Exp $ (BRL)";
d900 114
@


11.7
log
@
Fixed invocation of nmg_mark_edges_real()
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.6 1999/11/26 21:46:44 mike Exp $ (BRL)";
d285 1
a285 1
	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.6
log
@
Lint cleanups
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.5 1999/11/17 02:41:56 mike Exp $ (BRL)";
d773 1
a773 1
	(void)nmg_mark_edges_real( &s->l );
@


11.5
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.4 1999/07/02 22:19:22 mike Exp $ (BRL)";
d338 1
a338 1
struct bn_tol		*tol;
d522 1
a522 1
struct bn_tol		*tol;
d795 1
a795 1
rt_arbn_import( ip, ep, mat )
d799 1
d850 1
a850 1
rt_arbn_export( ep, ip, local2mm )
d854 1
d914 1
a914 1
struct rt_db_internal	*ip;
@


11.4
log
@
Removed dependence on compat4.h
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.3 1999/05/27 19:10:35 mike Exp $ (BRL)";
d813 1
@


11.3
log
@
sed4
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.2 1999/01/13 21:49:10 mike Exp $ (BRL)";
d385 1
a385 1
					RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE );
d390 1
a390 1
					RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
d403 1
a403 1
					RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );	/* draw it */
@


11.2
log
@Fixed args to htond()
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_arbn.c,v 11.1 1995/01/04 09:56:29 mike Rel4_4 $ (BRL)";
d59 1
a59 1
	CONST struct rt_tol	*tol = &rtip->rti_tol;
d65 1
a65 1
	used = (int *)rt_malloc(aip->neqn*sizeof(int), "arbn used[]");
d83 1
a83 1
			if( RT_VECT_ARE_PARALLEL(dot, tol) )  continue;
d93 1
a93 1
				if( rt_mkpoint_3planes( pt, aip->eqn[i], aip->eqn[j], aip->eqn[k] ) < 0 )  continue;
d119 1
a119 1
		rt_log("arbn(%s) face %d unused, solid is not convex\n",
d121 1
a121 1
		rt_free( (char *)used, "arbn used[]");
d124 1
a124 1
	rt_free( (char *)used, "arbn used[]");
d210 1
a210 1
		rt_log("rt_arbn_shoot(%s): 1 hit => MISS\n",
d227 1
a227 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d264 1
a264 1
		rt_log("rt_arbn_norm(%s): hit_surfno=%d?\n", h );
d318 2
a319 2
	rt_free( (char *)aip->eqn, "rt_arbn_internal eqn[]");
	rt_free( (char *)aip, "rt_arbn_internal" );
d335 1
a335 1
struct rt_list		*vhead;
d338 1
a338 1
struct rt_tol		*tol;
d358 1
a358 1
			if( RT_VECT_ARE_PARALLEL(dot, tol) )  continue;
d370 1
a370 1
				if( rt_mkpoint_3planes( pt, aip->eqn[i], aip->eqn[j], aip->eqn[k] ) < 0 )  continue;
d397 1
a397 1
					rt_log("rt_arbn_plot() error, point_count=%d (>2) on edge %d/%d, non-convex\n",
d522 1
a522 1
struct rt_tol		*tol;
d544 1
a544 1
	pts = (struct arbn_pts *)rt_calloc( nverts , sizeof( struct arbn_pts ) , "rt_arbn_tess: pts" );
d547 1
a547 1
	edges = (struct arbn_edges *)rt_calloc( aip->neqn*aip->neqn , sizeof( struct arbn_edges ) ,
d549 1
a549 1
	edge_count = (int *)rt_calloc( aip->neqn , sizeof( int ) , "rt_arbn_tess: edge_count" );
d552 1
a552 1
	fu = (struct faceuse **)rt_calloc( aip->neqn , sizeof( struct faceuse *) , "rt_arbn_tess: fu" );
d563 1
a563 1
				if( rt_mkpoint_3planes( pts[point_count].pt, aip->eqn[i], aip->eqn[j], aip->eqn[k]))
d588 1
a588 1
	verts = (struct vertex **)rt_calloc( point_count , sizeof( struct vertex *) ,
d691 1
a691 1
					rt_log( "Too many edges found for one face\n" );
d711 1
a711 1
	loop_verts = (struct vertex ***) rt_calloc( max_edge_count , sizeof( struct vertex **) ,
d715 1
a715 1
	s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d750 5
a754 5
	rt_free( (char *)pts , "rt_arbn_tess: pts" );
	rt_free( (char *)edges , "rt_arbn_tess: edges" );
	rt_free( (char *)edge_count , "rt_arbn_tess: edge_count" );
	rt_free( (char *)verts , "rt_arbn_tess: verts" );
	rt_free( (char *)loop_verts , "rt_arbn_tess: loop_verts" );
d761 2
a762 2
			rt_log( "Failed to calculate face plane equation\n" );
			rt_free( (char *)fu , "rt_arbn_tess: fu" );
d769 1
a769 1
	rt_free( (char *)fu , "rt_arbn_tess: fu" );
d781 4
a784 4
	rt_free( (char *)pts , "rt_arbn_tess: pts" );
	rt_free( (char *)edges , "rt_arbn_tess: edges" );
	rt_free( (char *)edge_count , "rt_arbn_tess: edge_count" );
	rt_free( (char *)verts , "rt_arbn_tess: verts" );
d797 1
a797 1
CONST struct rt_external	*ep;
d804 1
a804 1
	RT_CK_EXTERNAL( ep );
d807 1
a807 1
		rt_log("rt_arbn_import: defective record, id=x%x\n", rp->u_id );
d813 1
a813 1
	ip->idb_ptr = rt_malloc( sizeof(struct rt_arbn_internal), "rt_arbn_internal");
d816 1
a816 1
	aip->neqn = rt_glong( rp->n.n_neqn );
d818 1
a818 1
	aip->eqn = (plane_t *)rt_malloc( aip->neqn*sizeof(plane_t), "arbn plane eqn[]");
d849 1
a849 1
struct rt_external		*ep;
d874 1
a874 1
	RT_INIT_EXTERNAL(ep);
d876 1
a876 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "arbn external");
d880 2
a881 2
	(void)rt_plong( rec[0].n.n_neqn, aip->neqn );
	(void)rt_plong( rec[0].n.n_grans, ngrans );
d884 1
a884 1
	sp = sbuf = (double *)rt_malloc(
d896 1
a896 1
	rt_free( (char *)sbuf, "arbn temp" );
d910 1
a910 1
struct rt_vls		*str;
d922 1
a922 1
	rt_vls_strcat( str, buf );
d933 1
a933 1
		rt_vls_strcat( str, buf );
d954 2
a955 2
	rt_free( (char *)aip->eqn, "rt_arbn_internal eqn[]");
	rt_free( (char *)aip, "rt_arbn_internal" );
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 10.4 95/01/03 21:11:22 mike Exp $ (BRL)";
d820 1
a820 1
	ntohd( (char *)aip->eqn, (char *)(&rp[1]), aip->neqn*4 );
d894 1
a894 1
	htond( (char *)&rec[1], (char *)sbuf, aip->neqn * 4 );
@


10.4
log
@Paul Stay's fix for compiling on the VAX.
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 10.3 94/09/15 16:45:40 jra Exp $ (BRL)";
@


10.3
log
@Added rt_arbn_tess.
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 10.2 94/08/10 18:23:58 gdurf Exp Locker: jra $ (BRL)";
d89 1
d91 2
d99 4
a102 1
						goto next_k;
d104 2
a111 1
next_k:				;
d365 1
d367 2
d376 4
a379 1
						goto next_k;
d382 2
a405 1
next_k:				;
@


10.2
log
@Added include of conf.h
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 10.1 1991/10/12 06:40:12 mike Rel4_0 gdurf $ (BRL)";
d30 1
a32 1
#include "nmg.h"
d410 81
d497 4
d510 262
a771 1
	return(-1);
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.24 91/06/30 00:10:45 mike Exp $ (BRL)";
d23 2
@


1.24
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.23 91/06/22 22:30:16 mike Exp $ (BRL)";
@


1.23
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.22 91/05/18 03:31:58 mike Exp $ (BRL)";
d34 1
a34 1
RT_EXTERN(void rt_arbn_print, (struct soltab *stp) );
d136 1
a136 1
register struct soltab *stp;
d434 3
a436 3
struct rt_db_internal	*ip;
struct rt_external	*ep;
register mat_t		mat;
d487 3
a489 3
struct rt_external	*ep;
struct rt_db_internal	*ip;
double			local2mm;
@


1.22
log
@Wrong name for macro.
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.21 91/05/18 03:00:43 mike Exp $ (BRL)";
d45 1
a45 1
rt_arbn_prep( stp, ip, rtip, tol )
a48 1
CONST struct rt_tol	*tol;
d57 1
d152 1
a152 1
rt_arbn_shot( stp, rp, ap, seghead, tol )
a156 1
CONST struct rt_tol	*tol;
d227 1
a227 1
rt_arbn_vshot( stp, rp, segp, n, resp, tol )
d232 1
a232 2
struct resource         *resp; /* pointer to a list of free segs */
CONST struct rt_tol	*tol;
d234 1
a234 1
	rt_vstub( stp, rp, segp, n, resp, tol );
@


1.21
log
@Converted to new tolerance interface
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.20 91/02/27 19:49:16 mike Exp $ (BRL)";
d81 1
a81 1
			if( RT_VEC_ARE_PARALLEL(dot, tol) )  continue;
d351 1
a351 1
			if( RT_VEC_ARE_PARALLEL(dot, tol) )  continue;
@


1.20
log
@Chagned database format to use completely machine-independent format.
In this case, only the granule count was still in machine-specific format.
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.19 91/01/28 23:53:05 mike Exp $ (BRL)";
a33 3
#define DIST_TOL	(1.0e-8)
#define DIST_TOL_SQ	(1.0e-10)

d45 1
a45 1
rt_arbn_prep( stp, ip, rtip )
d49 1
d81 1
a81 1
			if( !NEAR_ZERO( dot, 0.999999 ) )  continue;
d93 1
a93 1
					if( VDOT(pt, aip->eqn[m])-aip->eqn[m][3] > DIST_TOL )
d152 1
a152 1
rt_arbn_shot( stp, rp, ap, seghead )
d157 1
d228 1
a228 1
rt_arbn_vshot( stp, rp, segp, n, resp)
d234 1
d236 1
a236 1
	rt_vstub( stp, rp, segp, n, resp );
d327 5
a331 6
rt_arbn_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
struct rt_list	*vhead;
struct rt_db_internal *ip;
double		abs_tol;
double		rel_tol;
double		norm_tol;
d351 1
a351 1
			if( !NEAR_ZERO( dot, 0.999999 ) )  continue;
d365 1
a365 1
					if( VDOT(pt, aip->eqn[m])-aip->eqn[m][3] > DIST_TOL )
d374 1
a374 1
					if( MAGSQ(dist) < DIST_TOL_SQ )  continue;
d379 1
a379 1
					if( MAGSQ(dist) < DIST_TOL_SQ )  continue;
d381 1
a381 1
					if( MAGSQ(dist) < DIST_TOL_SQ )  continue;
d418 1
a418 1
rt_arbn_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d422 2
a423 3
double		abs_tol;
double		rel_tol;
double		norm_tol;
@


1.19
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.18 91/01/26 03:14:39 mike Exp $ (BRL)";
d458 1
a458 1
	aip->neqn = rp->n.n_neqn;
d522 2
a523 2
	rec[0].n.n_neqn = aip->neqn;
	rec[0].n.n_grans = ngrans;
@


1.18
log
@Eliminated mat parameter on ft_plot and ft_tess
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.17 91/01/25 21:52:02 mike Exp $ (BRL)";
d328 1
a328 1
struct vlhead	*vhead;
d371 1
a371 1
					ADD_VL( vhead, pt, 0 );
d376 1
a376 1
					ADD_VL( vhead, pt, 1 );
d389 1
a389 1
					ADD_VL( vhead, pt, 1 );	/* draw it */
@


1.17
log
@lint
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.16 91/01/25 21:18:43 mike Exp $ (BRL)";
d327 1
a327 1
rt_arbn_plot( vhead, mat, ip, abs_tol, rel_tol, norm_tol )
a328 1
mat_t		mat;
d419 1
a419 1
rt_arbn_tess( r, m, ip, mat, abs_tol, rel_tol, norm_tol )
a422 1
register mat_t		mat;
@


1.16
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.15 91/01/25 20:35:22 mike Exp $ (BRL)";
d48 1
a48 1
rt_arbn_prep( stp, ep, rtip )
d50 1
a50 1
struct rt_external	*ep;
a53 1
	struct rt_db_internal	intern, *ip;
d62 1
a62 1
	aip = (struct rt_arbn_internal *)intern.idb_ptr;
a64 1
	stp->st_specific = (genptr_t)aip;
a114 1
		rt_arbn_ifree( &intern );
a116 1

d119 3
d420 4
a423 3
rt_arbn_tess( s, rp, mat, dp, abs_tol, rel_tol, norm_tol )
struct shell		*s;
register union record	*rp;
d425 3
a427 4
struct directory	*dp;
double			abs_tol;
double			rel_tol;
double			norm_tol;
@


1.15
log
@Added rt_ prefix to _internal structure
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.14 91/01/15 23:43:54 mike Exp $ (BRL)";
a46 1
#if NEW_IF
a52 9
#else
int
rt_arbn_prep( stp, rec, rtip )
struct soltab	*stp;
union record	*rec;
struct rt_i	*rtip;
{
	struct rt_external	ext, *ep;
#endif
a61 13
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rec;
	ep->ext_nbytes = stp->st_dp->d_len*sizeof(union record);
	ip = &intern;
	if( rt_arbn_import( ip, ep, stp->st_pathmat ) < 0 )  {
		rt_log("arbn(%s): db import error\n", stp->st_name );
		return(-1);		/* BAD */
	}
#endif
a326 1
#if NEW_IF
a335 11
#else
int
rt_arbn_plot( rp, mat, vhead, dp )
union record		*rp;
mat_t			mat;
struct vlhead		*vhead;
struct directory	*dp;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a340 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_arbn_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_arbn_plot(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
d385 2
a386 2
					rt_log("rt_arbn_plot(%s): error, point_count=%d (>2) on edge %d/%d, non-convex\n",
						dp->d_namep, point_count+1,
@


1.14
log
@Moved arbn_internal structure to rtgeom.h
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.13 91/01/15 01:35:10 mike Exp $ (BRL)";
d63 1
a63 1
	struct arbn_internal	*aip;
d86 1
a86 1
	aip = (struct arbn_internal *)intern.idb_ptr;
d184 2
a185 2
	register struct arbn_internal	*aip =
		(struct arbn_internal *)stp->st_specific;
d274 2
a275 2
	register struct arbn_internal *aip =
		(struct arbn_internal *)stp->st_specific;
d332 2
a333 2
	register struct arbn_internal *aip =
		(struct arbn_internal *)stp->st_specific;
d335 2
a336 2
	rt_free( (char *)aip->eqn, "arbn_internal eqn[]");
	rt_free( (char *)aip, "arbn_internal" );
d371 1
a371 1
	register struct arbn_internal	*aip;
d391 1
a391 1
	aip = (struct arbn_internal *)ip->idb_ptr;
d495 1
a495 1
	struct arbn_internal	*aip;
d507 2
a508 2
	ip->idb_ptr = rt_malloc( sizeof(struct arbn_internal), "arbn_internal");
	aip = (struct arbn_internal *)ip->idb_ptr;
d547 1
a547 1
	struct arbn_internal	*aip;
d556 1
a556 1
	aip = (struct arbn_internal *)ip->idb_ptr;
d609 2
a610 2
	register struct arbn_internal	*aip =
		(struct arbn_internal *)ip->idb_ptr;
d642 1
a642 1
	struct arbn_internal	*aip;
d645 1
a645 1
	aip = (struct arbn_internal *)ip->idb_ptr;
d648 2
a649 2
	rt_free( (char *)aip->eqn, "arbn_internal eqn[]");
	rt_free( (char *)aip, "arbn_internal" );
@


1.13
log
@Added magic, and export routine
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.12 91/01/11 04:41:28 mike Exp $ (BRL)";
d28 1
d31 1
a31 1
#include "db.h"
a33 1

a35 8

struct arbn_internal  {
	long	magic;
	int	neqn;
	plane_t	*eqn;
};
#define RT_ARBN_INTERNAL_MAGIC	0x18236461
#define RT_ARBN_CK_MAGIC(_p)	RT_CKMAG(_p,RT_ARBN_INTERNAL_MAGIC,"arbn_internal")
@


1.12
log
@Modified to use new interface
@
text
@a0 1
#define NEW_IF	0
d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.11 90/12/15 01:13:01 mike Exp $ (BRL)";
d38 1
d42 2
d72 1
a72 1
	struct rt_db_internal	intern;
d87 2
a88 3
#endif

	if( rt_arbn_import( &intern, ep, stp->st_pathmat ) < 0 )  {
d92 2
a93 1
	RT_CK_DB_INTERNAL( &intern );
d95 2
a97 1

d400 1
d514 1
a514 1
	ip->idb_type = ID_PARTICLE;
d517 1
a517 1

d520 1
a520 1
	aip->eqn = (plane_t *)rt_malloc( aip->neqn*sizeof(plane_t), "rt_arbn_import() planes");
d550 1
a550 1
rt_arbn_export( ep, ip )
d553 1
d555 45
a599 1
	return(-1);
d611 1
a611 1
rt_arbn_describe( str, ip, verbose )
d615 1
d622 1
d626 2
d630 5
a634 1
			i, V4ARGS(aip->eqn[i]) );
d642 2
a644 1
 *  XXX The suffix of this name is temporary.
d654 1
@


1.11
log
@Less noisy
@
text
@d1 1
d22 1
a22 1
static char RCSarbn[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/g_arbn.c,v 1.10 90/12/05 20:50:14 mike Exp $ (BRL)";
a33 1
void	rt_arbn_print();
d43 3
d53 1
d55 7
d67 2
d70 1
d78 8
a85 2
	GETSTRUCT( aip, arbn_internal );
	stp->st_specific = (genptr_t)aip;
d87 1
a87 1
	if( rt_arbn_import( aip, rec, stp->st_pathmat ) < 0 )  {
d89 1
a89 2
		rt_free( (char *)aip, "arbn_internal" );
		return(1);		/* BAD */
d91 3
d145 2
a146 3
		rt_free( (char *)aip->eqn, "arbn_internal eqn[]");
		rt_free( (char *)aip, "arbn_internal" );
		return(1);		/* BAD */
d355 1
d357 10
d373 3
d381 11
a391 6
	GETSTRUCT( aip, arbn_internal );

	if( rt_arbn_import( aip, rp, mat ) < 0 )  {
		rt_log("arbn(%s): db import error\n", dp->d_namep );
		rt_free( (char *)aip, "arbn_internal" );
		return(-1);
d393 4
d467 20
d493 3
a495 3
rt_arbn_import( aip, rp, mat )
struct arbn_internal	*aip;
union record		*rp;
d498 2
d502 2
d509 5
d543 13
a555 1
 *			R T _ A R B N _ T E S S
d557 3
a559 3
 *  "Tessellate" an ARB into an NMG data structure.
 *  Purely a mechanical transformation of one faceted object
 *  into another.
d562 4
a565 8
rt_arbn_tess( s, rp, mat, dp, abs_tol, rel_tol, norm_tol )
struct shell		*s;
register union record	*rp;
register mat_t		mat;
struct directory	*dp;
double			abs_tol;
double			rel_tol;
double			norm_tol;
d567 34
a600 1
	return(-1);
@


1.10
log
@Improved error messages
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.10 90/12/05 20:47:10 mike Exp $ (BRL)";
a87 1
			int	point_count;	/* # points on this line */
d93 1
a93 1
			point_count = 0;
a106 1
				point_count++;
a113 5
			if( point_count > 2 )  {
				rt_log("arbn(%s): warning, point_count=%d on edge %d/%d\n",
					stp->st_name, point_count,
					i, j );
			}
d394 1
a394 1
					rt_log("rt_arbn_plot(%s): warning, point_count=%d (>2) on edge %d/%d\n",
d400 1
d405 3
a407 5
			if( point_count == 1 )  {
				rt_log("rt_arbn_plot(%s): warning, point_count=1 on edge %d/%d\n",
					dp->d_namep,
					i, j );
			}
@


1.9
log
@Fixed return code on rt_arbn_plot().
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.8 90/10/15 12:00:51 mike Exp $ (BRL)";
d117 3
a119 2
				rt_log("arbn(%s): warning, point_count on line=%d\n",
					stp->st_name, point_count);
d401 3
a403 2
					rt_log("rt_arbn_plot(%s): warning, point_count on line=%d (is >2)\n",
						dp->d_namep, point_count+1);
d411 5
a415 1
			if( point_count == 1 ) rt_log("rt_arbn_plot(%s): warning, point_count=1\n", dp->d_namep);
@


1.8
log
@Changed from using hit_private to hit_surfno for surface indicator
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.7 90/10/11 02:38:55 mike Exp $ (BRL)";
d311 2
d340 1
a340 1
void
d357 1
a357 1
		return;
d412 1
@


1.7
log
@Added rt_vstub call, declared tessellation tolerances.
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.6 90/10/06 02:05:08 mike Exp $ (BRL)";
d230 1
a230 1
		segp->seg_in.hit_private = (char *)iplane;
d233 1
a233 1
		segp->seg_out.hit_private = (char *)oplane;
d269 1
a269 1
	h = (int)hitp->hit_private;
d271 1
a271 1
		rt_log("rt_arbn_norm(%s): hit_private=x%x?\n", h );
@


1.6
log
@Converted seg structures to use doubly linked lists.
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: /m/cad/librt/RCS/g_arbn.c,v 1.5 90/04/24 05:06:02 mike Exp $ (BRL)";
d250 1
d475 2
a476 2
void
rt_arbn_tess( s, rp, mat, dp )
d481 3
d485 1
a485 1
	rt_nul_tess( s, rp, mat, dp );
@


1.5
log
@Changed prefix from arbn to rt_arbn
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: g_arbn.c,v 1.4 90/03/14 15:05:40 mike Locked $ (BRL)";
d164 2
a165 2
 *	SEG_NULL	MISS
 *	segp		HIT
d167 4
a170 4
struct seg *
rt_arbn_shot( stp, rp, ap )
struct soltab *stp;
register struct xray *rp;
d172 1
d209 1
a209 1
				return( SEG_NULL );	/* MISS */
d212 1
a212 1
			return( SEG_NULL );	/* MISS */
d219 1
a219 1
		return( SEG_NULL );	/* MISS */
d222 1
a222 1
		return( SEG_NULL );	/* MISS */
d227 1
a227 1
		GET_SEG( segp, ap->a_resource );
d234 1
a234 1
		return(segp);			/* HIT */
d236 1
a236 1
	/* NOTREACHED */
@


1.4
log
@Changed type of st_specific to genptr_t
@
text
@d2 1
a2 1
 *  			A R B N . C
d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: g_arbn.c,v 1.3 90/02/08 01:32:31 mike Locked $ (BRL)";
d33 1
a33 1
void	arbn_print();
d44 1
a44 1
 *  			A R B N _ P R E P
d51 1
a51 1
arbn_prep( stp, rec, rtip )
d67 1
a67 1
	if( arbn_import( aip, rec, stp->st_pathmat ) < 0 )  {
d148 1
a148 1
 *  			A R B N _ P R I N T
d151 1
a151 1
arbn_print( stp )
d157 1
a157 1
 *			A R B N _ S H O T
d168 1
a168 1
arbn_shot( stp, rp, ap )
d216 1
a216 1
		rt_log("arbn_shoot(%s): 1 hit => MISS\n",
d239 1
a239 1
 *			A R B N _ V S H O T
d242 1
a242 1
arbn_vshot( stp, rp, segp, n, resp)
d252 1
a252 1
 *  			A R B N _ N O R M
d257 1
a257 1
arbn_norm( hitp, stp, rp )
d269 1
a269 1
		rt_log("arbn_norm(%s): hit_private=x%x?\n", h );
d277 1
a277 1
 *			A R B N _ C U R V E
d284 1
a284 1
arbn_curve( cvp, hitp, stp )
d295 1
a295 1
 *  			A R B N _ U V
d303 1
a303 1
arbn_uv( ap, stp, hitp, uvp )
d312 1
a312 1
 *			A R B N _ F R E E
d315 1
a315 1
arbn_free( stp )
d326 1
a326 1
 *  			A R B N _ P L O T
d337 1
a337 1
arbn_plot( rp, mat, vhead, dp )
d350 1
a350 1
	if( arbn_import( aip, rp, mat ) < 0 )  {
d396 1
a396 1
					rt_log("arbn_plot(%s): warning, point_count on line=%d (is >2)\n",
d405 1
a405 1
			if( point_count == 1 ) rt_log("arbn_plot(%s): warning, point_count=1\n", dp->d_namep);
d411 1
a411 1
 *			A R B N _ C L A S S
d414 1
a414 1
arbn_class()
d420 1
a420 1
 *			A R B N _ I M P O R T
d426 1
a426 1
arbn_import( aip, rp, mat )
d434 1
a434 1
		rt_log("arbn_import: defective record, id=x%x\n", rp->u_id );
d440 1
a440 1
	aip->eqn = (plane_t *)rt_malloc( aip->neqn*sizeof(plane_t), "arbn_import planes");
d467 1
a467 1
 *			A R B N _ T E S S
d474 1
a474 1
arbn_tess( s, rp, mat, dp )
d480 1
a480 1
	nul_tess( s, rp, mat, dp );
@


1.3
log
@Improved arbn warning message by indicating which solid was having trouble.
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: g_arbn.c,v 1.2 89/12/09 05:47:00 mike Locked $ (BRL)";
d65 1
a65 1
	stp->st_specific = (int *)aip;
@


1.2
log
@Improved plotting;  still some fuzz.
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: g_arbn.c,v 1.1 89/12/09 01:23:06 mike Locked $ (BRL)";
d405 1
a405 1
			if( point_count == 1 ) rt_log("arbn_plot: warning, point_count=1\n");
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSarbn[] = "@@(#)$Header: g_arb.c,v 9.2 89/10/10 16:15:30 mike Exp $ (BRL)";
d36 1
d360 2
d383 1
a383 1
				if( point_count++ == 0 )  {
d385 6
d392 9
a400 1
					ADD_VL( vhead, pt, 1 );
d402 1
d405 1
a405 4
			if( point_count > 2 )  {
				printf("arbn_plot(%s): warning, point_count on line=%d (is >2)\n",
					dp->d_namep, point_count);
			}
@
