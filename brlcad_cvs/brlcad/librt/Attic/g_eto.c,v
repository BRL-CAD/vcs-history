head	11.25;
access;
symbols
	ansi-20040405-merged:11.21.2.2
	postmerge-20040405-ansi:11.23
	premerge-20040404-ansi:11.22
	postmerge-autoconf:11.22
	autoconf-freeze:11.21.10.2
	premerge-autoconf:11.22
	ansi-20040316-freeze:11.21.2.1
	postmerge-20040315-windows:11.22
	premerge-20040315-windows:11.22
	windows-20040315-freeze:11.21.4.1
	autoconf-20031203:11.21
	autoconf-20031202:11.21
	autoconf-branch:11.21.0.10
	phong-branch:11.21.0.8
	photonmap-branch:11.21.0.6
	rel-6-1-DP:11.21
	windows-branch:11.21.0.4
	rel-6-0-2:11.19
	ansi-branch:11.21.0.2
	rel-6-0-1-branch:11.19.0.2
	hartley-6-0-post:11.20
	hartley-6-0-pre:11.19
	rel-6-0-1:11.19
	rel-6-0:11.19
	rel-5-4:11.9
	offsite-5-3-pre:11.16
	rel-5-3:11.9
	rel-5-2:11.9
	rel-5-1-branch:11.9.0.2
	rel-5-1:11.9
	rel-5-0:11.5
	rel-5-0-beta:11.4
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.25
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	11.24;

11.24
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.23;

11.23
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2004.02.02.17.39.20;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2002.08.20.17.07.59;	author jra;	state Exp;
branches
	11.21.2.1
	11.21.4.1
	11.21.10.1;
next	11.20;

11.20
date	2002.08.15.20.55.12;	author hartley;	state Exp;
branches;
next	11.19;

11.19
date	2001.10.02.19.24.29;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	2001.04.20.22.29.44;	author morrison;	state Exp;
branches;
next	11.17;

11.17
date	2001.03.31.01.57.08;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2000.10.18.18.10.34;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	2000.08.22.21.16.59;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.08.21.02.02.30;	author butler;	state Exp;
branches;
next	11.13;

11.13
date	2000.07.10.23.01.31;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.06.30.15.38.03;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.06.30.15.31.14;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.06.29.14.00.44;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	2000.04.12.02.34.33;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.11.26.21.46.46;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.11.24.23.12.07;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.11.17.02.41.58;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.07.02.22.19.23;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.05.27.19.10.38;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.06.17.19.34.10;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	96.08.31.10.53.21;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.39;	author mike;	state Rel4_4;
branches;
next	1.11;

1.11
date	94.12.27.17.14.45;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	94.11.08.03.04.57;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	94.09.29.12.24.01;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	94.09.13.15.49.53;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	94.09.02.16.03.29;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	94.08.10.18.27.45;	author gdurf;	state Exp;
branches;
next	1.5;

1.5
date	93.11.18.01.44.05;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	92.03.27.12.59.24;	author mmark;	state Exp;
branches;
next	1.3;

1.3
date	92.03.25.15.52.56;	author mmark;	state Exp;
branches;
next	1.2;

1.2
date	92.03.24.14.07.09;	author mmark;	state Exp;
branches;
next	1.1;

1.1
date	92.02.14.15.32.01;	author mmark;	state Exp;
branches;
next	;

11.21.2.1
date	2002.09.19.18.01.33;	author morrison;	state Exp;
branches;
next	11.21.2.2;

11.21.2.2
date	2004.03.17.21.18.46;	author morrison;	state Exp;
branches;
next	;

11.21.4.1
date	2004.03.11.23.43.37;	author morrison;	state Exp;
branches;
next	;

11.21.10.1
date	2004.02.12.18.37.40;	author erikg;	state Exp;
branches;
next	11.21.10.2;

11.21.10.2
date	2004.03.15.14.07.19;	author erikg;	state Exp;
branches;
next	;


desc
@elliptical torus
@


11.25
log
@moved to src/
@
text
@/*
 *			G _ E T O . C
 *
 * Purpose -
 *	Intersect a ray with an Elliptical Torus
 *
 * Authors -
 *	Michael Markowski	(Programming)
 *	ERIM GIFT code		(ETO Eqn)
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1992-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSeto[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_eto.c,v 11.24 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"

/*
 * The ETO has the following input fields:
 *	V	V from origin to center.
 *	N	Normal to plane of eto.
 *	C	Semi-major axis of elliptical cross section.
 *      r	Radius of revolution.
 *	rd	Semi-minor axis of elliptical cross section.
 *
 */

/*
 *  Algorithm:
 *  
 *  Given V, N, C, r, and rd, there is a set of points on this eto
 *  
 *  { (x,y,z) | (x,y,z) is on eto defined by V, N, C, r, rd }
 *  
 *  Through a series of  Transformations, this set will be
 *  transformed into a set of points on an eto centered at the origin
 *  which lies on the X-Y plane (ie, N is on the Z axis).
 *  
 *  { (x',y',z') | (x',y',z') is an eto at origin }
 *  
 *  The transformation from X to X' is accomplished by:
 *  
 *  X' = R( X - V )
 *  
 *  where R(X) =  ( B/(|B|) )
 *  		 (  A/(|A|)  ) . X
 *  		  ( N/(|N|) )
 *
 *  To find the intersection of a line with the eto, consider
 *  the parametric line L:
 *  
 *  	L : { P(n) | P + t(n) . D }
 *  
 *  Call W the actual point of intersection between L and the eto.
 *  Let W' be the point of intersection between L' and the unit eto.
 *  
 *  	L' : { P'(n) | P' + t(n) . D' }
 *  
 *  W = invR( W' ) + V
 *  
 *  Where W' = k D' + P'.
 *  
 *
 *  Given a line and a ratio, alpha, finds the equation of the
 *  unit eto in terms of the variable 't'.
 *
 *  Given that the equation for the eto is:
 *
 *            _______                           _______
 *           / 2    2              2           / 2    2               2
 *  [Eu(+- \/ x  + y   - R) + Ev z]  + [Fu(+-\/ x  + y   - R) + Fv z ]
 * --------------------------------    -------------------------------  = 1
 *               2                                      2
 *             Rc                                     Rd
 *
 *  First, find X, Y, and Z in terms of 't' for this line, then
 *  substitute them into the equation above.
 *
 *  	Wx = Dx*t + Px
 *
 *  	Wx**2 = Dx**2 * t**2  +  2 * Dx * Px  +  Px**2
 *
 *  The real roots of the equation in 't' are the intersect points
 *  along the parameteric line.
 *  
 *  NORMALS.  Given the point W on the eto, what is the vector
 *  normal to the tangent plane at that point?
 *  
 *  Map W onto the eto, ie:  W' = R( W - V ).
 *  In this case, we find W' by solving the parameteric line given k.
 *  
 *  The gradient of the eto at W' is in fact the
 *  normal vector.
 *
 *  For f(x,y,z) = 0, the gradient of f() is ( df/dx, df/dy, df/dz ).
 *
 *  Note that the normal vector (gradient) produced above will not have
 *  unit length.  Also, to make this useful for the original eto, it will
 *  have to be rotated back to the orientation of the original eto.
 */

struct eto_specific {
	vect_t	eto_V;		/* Vector to center of eto */
	vect_t	eto_N;		/* unit normal to plane of eto */
	vect_t	eto_C;		/* semi-major axis of ellipse */
	fastf_t	eto_r;		/* radius of revolution */
	fastf_t	eto_rc;		/* semi-major axis of ellipse */
	fastf_t	eto_rd;		/* semi-minor axis of ellipse */
	mat_t	eto_R;		/* Rot(vect) */
	mat_t	eto_invR;	/* invRot(vect') */
	fastf_t	eu, ev, fu, fv;
};

const struct bu_structparse rt_eto_parse[] = {
    { "%f", 3, "V",   offsetof(struct rt_eto_internal, eto_V[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "N",   offsetof(struct rt_eto_internal, eto_N[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "C",   offsetof(struct rt_eto_internal, eto_C[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r",   offsetof(struct rt_eto_internal, eto_r),    BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_d", offsetof(struct rt_eto_internal, eto_rd),   BU_STRUCTPARSE_FUNC_NULL },
    { {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
 };

/*
 *  			R T _ E T O _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid eto, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	ETO is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct eto_specific is created, and it's address is stored in
 *  	stp->st_specific for use by rt_eto_shot().
 */
int
rt_eto_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	register struct eto_specific *eto;
	LOCAL vect_t	P, w1;	/* for RPP calculation */
	LOCAL vect_t	Au, Bu, Cu, Nu;
	FAST fastf_t	ch, cv, dh, f, phi;
	struct rt_eto_internal	*tip;

	tip = (struct rt_eto_internal *)ip->idb_ptr;
	RT_ETO_CK_MAGIC(tip);

	/* Solid is OK, compute constant terms now */
	BU_GETSTRUCT( eto, eto_specific );
	stp->st_specific = (genptr_t)eto;

	eto->eto_r = tip->eto_r;
	eto->eto_rd = tip->eto_rd;
	eto->eto_rc = MAGNITUDE( tip->eto_C );
	if ( NEAR_ZERO(eto->eto_r, 0.0001) || NEAR_ZERO(eto->eto_rd, 0.0001)
		|| NEAR_ZERO(eto->eto_rc, 0.0001)) {
		bu_log("eto(%s): r, rd, or rc zero length\n", stp->st_name);
		return(1);
	}

	VMOVE( eto->eto_V, tip->eto_V );
	VMOVE( eto->eto_N, tip->eto_N );
	VMOVE( eto->eto_C, tip->eto_C );
	VMOVE( Nu, tip->eto_N );
	VUNITIZE( Nu );		/* z axis of coord sys */
	bn_vec_ortho( Bu, Nu );	/* x axis */
	VUNITIZE( Bu );
	VCROSS( Au, Nu, Bu );	/* y axis */
	VMOVE( Cu, tip->eto_C );
	VUNITIZE( Cu );

	/* get horizontal and vertical components of C and Rd */
	cv = VDOT( eto->eto_C, Nu );
	ch = sqrt( VDOT( eto->eto_C, eto->eto_C ) - cv * cv );
	/* angle between C and Nu */
	phi = acos( cv / eto->eto_rc );
	dh = eto->eto_rd * cos(phi);
	/* make sure ellipse doesn't overlap itself when revolved */
	if (ch > eto->eto_r || dh > eto->eto_r) {
		bu_log("eto(%s): revolved ellipse overlaps itself\n",
			stp->st_name);
		return(1);
	}
	
	eto->ev = fabs( VDOT( Cu, Nu ) );	/* vertical component of Cu */
	eto->eu = sqrt( 1.0 - eto->ev * eto->ev );	/* horiz component */
	eto->fu = -eto->ev;
	eto->fv =  eto->eu;

	/* Compute R and invR matrices */
	MAT_IDN( eto->eto_R );
	VMOVE( &eto->eto_R[0], Bu );
	VMOVE( &eto->eto_R[4], Au );
	VMOVE( &eto->eto_R[8], Nu );
	bn_mat_inv( eto->eto_invR, eto->eto_R );

	stp->st_aradius = stp->st_bradius = eto->eto_r + eto->eto_rc;

	/*
	 *  Compute the bounding RPP planes for a circular eto.
	 *
	 *  Given a circular eto with vertex V, vector N, and
	 *  radii r and |C|.  A bounding plane with direction
	 *  vector P will touch the surface of the eto at the
	 *  points:  V +/- [|C| + r * |N x P|] P
	 */

	/* X */
	VSET( P, 1.0, 0, 0 );		/* bounding plane normal */
	VCROSS( w1, Nu, P );	/* for sin(angle N P) */
	f = eto->eto_rc + eto->eto_r * MAGNITUDE(w1);
	VSCALE( w1, P, f );
	f = fabs( w1[X] );
	stp->st_min[X] = eto->eto_V[X] - f;
	stp->st_max[X] = eto->eto_V[X] + f;

	/* Y */
	VSET( P, 0, 1.0, 0 );		/* bounding plane normal */
	VCROSS( w1, Nu, P );	/* for sin(angle N P) */
	f = eto->eto_rc + eto->eto_r * MAGNITUDE(w1);
	VSCALE( w1, P, f );
	f = fabs( w1[Y] );
	stp->st_min[Y] = eto->eto_V[Y] - f;
	stp->st_max[Y] = eto->eto_V[Y] + f;

	/* Z */
	VSET( P, 0, 0, 1.0 );		/* bounding plane normal */
	VCROSS( w1, Nu, P );	/* for sin(angle N P) */
	f = eto->eto_rc + eto->eto_r * MAGNITUDE(w1);
	VSCALE( w1, P, f );
	f = fabs( w1[Z] );
	stp->st_min[Z] = eto->eto_V[Z] - f;
	stp->st_max[Z] = eto->eto_V[Z] + f;

	return(0);			/* OK */
}

/*
 *			R T _ E T O _ P R I N T
 */
void
rt_eto_print(register const struct soltab *stp)
{
	register const struct eto_specific *eto =
		(struct eto_specific *)stp->st_specific;

	VPRINT("V", eto->eto_V);
	VPRINT("N", eto->eto_N);
	VPRINT("C", eto->eto_C);
	bu_log("r = %f\n", eto->eto_r);
	bu_log("rc = %f\n", eto->eto_rc);
	bu_log("rd = %f\n", eto->eto_rd);
	bn_mat_print("R", eto->eto_R );
	bn_mat_print("invR", eto->eto_invR );
	bu_log( "rpp: (%g, %g, %g) to (%g, %g, %g)\n",
		stp->st_min[X], stp->st_min[Y], stp->st_min[Z], 
		stp->st_max[X], stp->st_max[Y], stp->st_max[Z]);
}

/*
 *  			R T _ E T O _ S H O T
 *  
 *  Intersect a ray with an eto, where all constant terms have
 *  been precomputed by rt_eto_prep().  If an intersection occurs,
 *  one or two struct seg(s) will be acquired and filled in.
 *
 *  NOTE:  All lines in this function are represented parametrically
 *  by a point,  P( x0, y0, z0 ) and a direction normal,
 *  D = ax + by + cz.  Any point on a line can be expressed
 *  by one variable 't', where
 *
 *	X = a*t + x0,	eg,  X = Dx*t + Px
 *	Y = b*t + y0,
 *	Z = c*t + z0.
 *
 *  First, convert the line to the coordinate system of a "stan-
 *  dard" eto.  This is a eto which lies in the X-Y plane
 *  and circles the origin.  The semimajor axis is C.
 *
 *  Then find the equation of that line and the standard eto,
 *  which turns out to be a quartic equation in 't'.  Solve the
 *  equation using a general polynomial root finder.  Use those
 *  values of 't' to compute the points of intersection in the
 *  original coordinate system.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_eto_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct eto_specific *eto =
		(struct eto_specific *)stp->st_specific;
	register struct seg *segp;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL vect_t	work;		/* temporary vector */
	LOCAL bn_poly_t	C;		/* The final equation */
	LOCAL bn_complex_t	val[4];	/* The complex roots */
	LOCAL double	k[4];		/* The real roots */
	register int	i;
	LOCAL int	j;
	LOCAL vect_t	cor_pprime;	/* new ray origin */
	LOCAL fastf_t	cor_proj;
	LOCAL fastf_t	A1,A2,A3,A4,A5,A6,A7,A8,B1,B2,B3,C1,C2,C3,D1,term;

	/* Convert vector into the space of the unit eto */
	MAT4X3VEC( dprime, eto->eto_R, rp->r_dir );
	VUNITIZE( dprime );

	VSUB2( work, rp->r_pt, eto->eto_V );
	MAT4X3VEC( pprime, eto->eto_R, work );

	/* normalize distance from eto.  substitute
	 * corrected pprime which contains a translation along ray
	 * direction to closest approach to vertex of eto.
	 * Translating ray origin along direction of ray to closest pt. to
	 * origin of solid's coordinate system, new ray origin is
	 * 'cor_pprime'.
	 */
	cor_proj = VDOT( pprime, dprime );
	VSCALE( cor_pprime, dprime, cor_proj );
	VSUB2( cor_pprime, pprime, cor_pprime );

	/*
	 *  NOTE: The following code is based on code in
	 *        eto.f by ERIM for GIFT.
	 *
	 *  Given a line, finds the equation of the
	 *  eto in terms of the variable 't'.
	 *
	 *  The equation for the eto is:
	 *
            _______                           ________
           / 2    2              2           / 2    2               2
  [Eu(+- \/ x  + y   - R) + Ev z]  + [Fu(+-\/ x  + y   - R) + Fv z ]
 --------------------------------    -------------------------------  = 1
               2                                      2
             Rc                                     Rd
	 *
	 *                  ^   ^
	 *       where Ev = C . N
	 *
	 *                  ^   ^
	 *             Eu = C . A
	 *
	 *                  ^   ^
	 *             Fv = C . A
	 *
	 *                  ^   ^
	 *             Fu =-C . N.
	 *
	 *  First, find X, Y, and Z in terms of 't' for this line, then
	 *  substitute them into the equation above.
	 *
	 *  	Wx = Dx*t + Px, etc.
	 *
	 *  Regrouping coefficients and constants, the equation can then
	 *  be rewritten as:
	 *
	 *  [A1*sqrt(C1 + C2*t + C3*t^2) + A2 + A3*t]^2  +
	 *  [B1*sqrt(C1 + C2*t + C3*t^2) + B2 + B3*t]^2  - D1 = 0
	 *
	 *  where, (variables defined in code below)
	 */
	A1 = eto->eto_rd * eto->eu;
	B1 = eto->eto_rc * eto->fu;
	C1 = cor_pprime[X] * cor_pprime[X] + cor_pprime[Y] * cor_pprime[Y];
	C2 = 2 * (dprime[X] * cor_pprime[X] + dprime[Y] * cor_pprime[Y]);
	C3 = dprime[X] * dprime[X] + dprime[Y] * dprime[Y];
	A2 = -eto->eto_rd * eto->eto_r * eto->eu + eto->eto_rd * eto->ev * cor_pprime[Z];
   	B2 = -eto->eto_rc * eto->eto_r * eto->fu + eto->eto_rc * eto->fv * cor_pprime[Z];
	A3 = eto->eto_rd * eto->ev * dprime[Z];
	B3 = eto->eto_rc * eto->fv * dprime[Z];
	D1 = eto->eto_rc * eto->eto_rc * eto->eto_rd * eto->eto_rd;

	/*
	 *  Squaring the two terms above and again regrouping coefficients
	 *  the equation now becomes:
	 *
	 *  A6*t^2 + A5*t + A4 = -(A8*t + A7)*sqrt(C1 + C2*t + C3*t^2)
	 *
	 *  where, (variables defined in code)
	 */
	A4 = A1*A1*C1 + B1*B1*C1 + A2*A2 + B2*B2 - D1;
	A5 = A1*A1*C2 + B1*B1*C2 + 2*A2*A3 + 2*B2*B3;
	A6 = A1*A1*C3 + B1*B1*C3 + A3*A3 + B3*B3;
	A7 = 2*(A1*A2 + B1*B2);
	A8 = 2*(A1*A3 + B1*B3);
	term = A6*A6 - A8*A8*C3;

	/*
	 *  Squaring both sides and subtracting RHS from LHS yields:
	 */
	C.dgr=4;
	C.cf[4] = (A4*A4 - A7*A7*C1);			/* t^0 */
	C.cf[3] = (2*A4*A5 - A7*A7*C2 - 2*A7*A8*C1);	/* t^1 */
	C.cf[2] = (2*A4*A6 + A5*A5 - A7*A7*C3 - 2*A7*A8*C2 - A8*A8*C1);	/* t^2 */
	C.cf[1] = (2*A5*A6 - 2*A7*A8*C3 - A8*A8*C2);	/* t^3 */
	C.cf[0] = term;					/* t^4 */
	/* NOTE: End of ERIM based code */

	/*  It is known that the equation is 4th order.  Therefore,
	 *  if the root finder returns other than 4 roots, error.
	 */
	if ( (i = rt_poly_roots( &C, val )) != 4 ){
		if( i != 0 )  {
			bu_log("eto:  rt_poly_roots() 4!=%d\n", i);
			bn_pr_roots( stp->st_name, val, i );
		}
		return(0);		/* MISS */
	}

	/*  Only real roots indicate an intersection in real space.
	 *
	 *  Look at each root returned; if the imaginary part is zero
	 *  or sufficiently close, then use the real part as one value
	 *  of 't' for the intersections
	 */
	for ( j=0, i=0; j < 4; j++ ){
		if( NEAR_ZERO( val[j].im, 0.0001 ) )
			k[i++] = val[j].re;
	}

	/* reverse above translation by adding distance to all 'k' values. */
	for( j = 0; j < i; ++j )
		k[j] -= cor_proj;

	/* Here, 'i' is number of points found */
	switch( i )  {
	case 0:
		return(0);		/* No hit */

	default:
		bu_log("rt_eto_shot: reduced 4 to %d roots\n",i);
		bn_pr_roots( stp->st_name, val, 4 );
		return(0);		/* No hit */

	case 2:
		{
			/* Sort most distant to least distant. */
			FAST fastf_t	u;
			if( (u=k[0]) < k[1] )  {
				/* bubble larger towards [0] */
				k[0] = k[1];
				k[1] = u;
			}
		}
		break;
	case 4:
		{
			register short	n;
			register short	lim;

			/*  Inline rt_pt_sort().  Sorts k[] into descending order. */
			for( lim = i-1; lim > 0; lim-- )  {
				for( n = 0; n < lim; n++ )  {
					FAST fastf_t	u;
					if( (u=k[n]) < k[n+1] )  {
						/* bubble larger towards [0] */
						k[n] = k[n+1];
						k[n+1] = u;
					}
				}
			}
		}
		break;
	}

	/* Now, t[0] > t[npts-1] */
	/* k[1] is entry point, and k[0] is farthest exit point */
	RT_GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;
	segp->seg_in.hit_dist = k[1];
	segp->seg_out.hit_dist = k[0];
	/* Set aside vector for rt_eto_norm() later */
	VJOIN1( segp->seg_in.hit_vpriv, pprime, k[1], dprime );
	VJOIN1( segp->seg_out.hit_vpriv, pprime, k[0], dprime );
	BU_LIST_INSERT( &(seghead->l), &(segp->l) );

	if( i == 2 )
		return(2);			/* HIT */
				
	/* 4 points */
	/* k[3] is entry point, and k[2] is exit point */
	RT_GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;
	segp->seg_in.hit_dist = k[3];
	segp->seg_out.hit_dist = k[2];
	VJOIN1( segp->seg_in.hit_vpriv, pprime, k[3], dprime );
	VJOIN1( segp->seg_out.hit_vpriv, pprime, k[2], dprime );
	BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	return(4);			/* HIT */
}

#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	
/*
 *			R T _ E T O _ V S H O T
 *
 *  This is the Becker vector version
 */
void
rt_eto_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
}

/*
 *			R T _ E T O _ N O R M
 *
 *  Compute the normal to the eto,
 *  given a point on the eto centered at the origin on the X-Y plane.
 *  The gradient of the eto at that point is in fact the
 *  normal vector, which will have to be given unit length.
 *  To make this useful for the original eto, it will have
 *  to be rotated back to the orientation of the original eto.
 *  The equation for the eto is:
 *
 *            _______                           ________
 *           / 2    2              2           / 2    2               2
 *  [Eu(+- \/ x  + y   - R) + Ev z]  + [Fu(+-\/ x  + y   - R) + Fv z ]
 * --------------------------------    -------------------------------  = 1
 *               2                                      2
 *             Rc                                     Rd
 *
 *  The normal is the gradient of f(x,y,z) = 0 or
 *
 *	(df/dx, df/dy, df/dz)
 */
void
rt_eto_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct eto_specific *eto =
		(struct eto_specific *)stp->st_specific;
	FAST fastf_t sqrt_x2y2, efact, ffact, xcomp, ycomp, zcomp;
	LOCAL vect_t normp;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );

	sqrt_x2y2 = sqrt( hitp->hit_vpriv[X] * hitp->hit_vpriv[X]
			+ hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y] );

	efact = 2 * eto->eto_rd * eto->eto_rd * (eto->eu *
		(sqrt_x2y2 - eto->eto_r) + eto->ev * hitp->hit_vpriv[Z]);

	ffact = 2 * eto->eto_rc * eto->eto_rc * (eto->fu *
		(sqrt_x2y2 - eto->eto_r) + eto->fv * hitp->hit_vpriv[Z]);
	
	xcomp = (efact * eto->eu + ffact * eto->fu) / sqrt_x2y2;
	
	ycomp = hitp->hit_vpriv[Y] * xcomp;
	xcomp = hitp->hit_vpriv[X] * xcomp;
	zcomp = efact * eto->ev + ffact * eto->fv;
	
	VSET( normp, xcomp, ycomp, zcomp );
	VUNITIZE( normp );
	MAT3X3VEC( hitp->hit_normal, eto->eto_invR, normp );
}

/*
 *			R T _ E T O _ C U R V E
 *
 *  Return the curvature of the eto.
 */
void
rt_eto_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	fastf_t	a, b, ch, cv, dh, dv, k_circ, k_ell, phi, rad, xp,
		yp1, yp2, work;
	register struct eto_specific *eto =
		(struct eto_specific *)stp->st_specific;
	vect_t	Cp, Dp, Hit_Ell, Nu, Radius, Ru;

	a = eto->eto_rc;
	b = eto->eto_rd;
	VMOVE( Nu, eto->eto_N );
	VUNITIZE( Nu );

	/* take elliptical slice of eto at hit point */
	VSET( Ru, hitp->hit_vpriv[X], hitp->hit_vpriv[Y], 0. );
	VUNITIZE( Ru );
	VSCALE( Radius, Ru, eto->eto_r );

	/* get horizontal and vertical components of C and Rd */
	cv = VDOT( eto->eto_C, Nu );
	ch = sqrt( VDOT( eto->eto_C, eto->eto_C ) - cv * cv );
	/* angle between C and Nu */
	phi = acos( cv / MAGNITUDE(eto->eto_C) );
	dv = eto->eto_rd * sin(phi);
	dh = -eto->eto_rd * cos(phi);

	/* build coord system for ellipse: x,y directions are Dp,Cp */
	VCOMB2( Cp, ch, Ru, cv, Nu );
	VCOMB2( Dp, dh, Ru, dv, Nu );
	VUNITIZE( Cp );
	VUNITIZE( Dp );

	/* put hit point in cross sectional coordinates */
	VSUB2( Hit_Ell, hitp->hit_vpriv, Radius );
	xp = VDOT( Hit_Ell, Dp );
	/* yp = VDOT( Hit_Ell, Cp ); */

	/* calculate curvature along ellipse */
	/* k = y'' / (1 + y'^2) ^ 3/2 */
	rad = 1. / sqrt(1. - xp*xp/(a*a));
	yp1 = -b/(a*a)*xp*rad;
	yp2 = -b/(a*a)*rad*(xp*xp*rad*rad + 1.);
	work = 1 + yp1*yp1;
	k_ell = yp2 / (work*sqrt(work));
	
	/* calculate curvature along radial circle */
	k_circ = -1. / MAGNITUDE(Radius);

	if (fabs(k_ell) < fabs(k_circ)) {
		/* use 1st deriv for principle dir of curvature */
		VCOMB2( cvp->crv_pdir, xp, Dp, yp1, Cp );
		cvp->crv_c1 = k_ell;
		cvp->crv_c2 = k_circ;
	} else {
		VCROSS( cvp->crv_pdir, hitp->hit_normal, Radius );
		cvp->crv_c1 = k_circ;
		cvp->crv_c2 = k_ell;
	}
	VUNITIZE( cvp->crv_pdir );
}

/*
 *			R T _ E T O _ U V
 */
void
rt_eto_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	fastf_t	horz, theta_u, theta_v, vert;
	vect_t	Hit_Ell, Nu, Radius, Ru;

	register struct eto_specific *eto =
		(struct eto_specific *)stp->st_specific;

	/* take elliptical slice of eto at hit point */
	VSET( Ru, hitp->hit_vpriv[X], hitp->hit_vpriv[Y], 0. );
	VUNITIZE( Ru );
	VSCALE( Radius, Ru, eto->eto_r );
	/* put cross sectional ellipse at origin */
	VSUB2( Hit_Ell, hitp->hit_vpriv, Radius );

	/* find angle between Ru and Hit_Ell
	   (better for circle than ellipse...) */
	VMOVE( Nu, eto->eto_N );
	VUNITIZE( Nu );
	vert = VDOT( Hit_Ell, Nu );
	horz = VDOT( Hit_Ell, Ru );
	theta_u = atan2(vert, -horz);	/* tuck seam on eto inner diameter */

	/* find angle between hitp and x axis */
	theta_v = atan2(hitp->hit_vpriv[Y], hitp->hit_vpriv[X]);

	/* normalize to [0, 2pi] */
	if (theta_u < 0.)
		theta_u += bn_twopi;
	if (theta_v < 0.)
		theta_v += bn_twopi;

	/* normalize to [0, 1] */
	uvp->uv_u = theta_u/bn_twopi;
	uvp->uv_v = theta_v/bn_twopi;
	uvp->uv_du = uvp->uv_dv = 0;
}

/*
 *			R T _ E T O _ F R E E
 */
void
rt_eto_free(struct soltab *stp)
{
	register struct eto_specific *eto =
		(struct eto_specific *)stp->st_specific;

	bu_free( (char *)eto, "eto_specific");
}

int
rt_eto_class(void)
{
	return(0);
}

/*
 *			R T _ E T O _ P L O T
 *
 * The ETO has the following input fields:
 *	eto_V	V from origin to center
 *	eto_r	Radius scalar
 *	eto_N	Normal to plane of eto
 *	eto_C	Semimajor axis (vector) of eto cross section
 *	eto_rd	Semiminor axis length (scalar) of eto cross section
 *
 */
int
rt_eto_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	fastf_t		a, b;	/* axis lengths of ellipse */
	fastf_t		ang, ch, cv, dh, dv, ntol, dtol, phi, theta;
	fastf_t		*eto_ells;
	int		i, j, npts, nells;
	point_t		*ell;	/* array of ellipse points */
	point_t		Ell_V;	/* vertex of an ellipse */
	point_t		*rt_mk_ell();
	struct rt_eto_internal	*tip;
	vect_t		Au, Bu, Nu, Cp, Dp, Xu;

	RT_CK_DB_INTERNAL(ip);
	tip = (struct rt_eto_internal *)ip->idb_ptr;
	RT_ETO_CK_MAGIC(tip);

	a = MAGNITUDE( tip->eto_C );
	b = tip->eto_rd;

	if ( NEAR_ZERO(tip->eto_r, 0.0001) || NEAR_ZERO(b, 0.0001)
		|| NEAR_ZERO(a, 0.0001)) {
		bu_log("eto_plot: r, rd, or rc zero length\n");
		return(1);
	}

	/* Establish tolerances */
	if( ttol->rel <= 0.0 || ttol->rel >= 1.0 )  {
		dtol = 0.0;		/* none */
	} else {
		/*
		 * Convert relative to absolute by scaling smallest of
		 * radius and semi-minor axis
		 */
		if (tip->eto_r < b)
			dtol = ttol->rel * 2 * tip->eto_r;
		else
			dtol = ttol->rel * 2 * b;
	}
	if( ttol->abs <= 0.0 )  {
		if( dtol <= 0.0 )  {
			/* No tolerance given, use a default */
			if (tip->eto_r < b)
				dtol = 2 * 0.10 * tip->eto_r;	/* 10% */
			else
				dtol = 2 * 0.10 * b;	/* 10% */
		} else {
			/* Use absolute-ized relative tolerance */
		}
	} else {
		/* Absolute tolerance was given, pick smaller */
		if( ttol->rel <= 0.0 || dtol > ttol->abs )
			dtol = ttol->abs;
	}
	/* To ensure normal tolerance, remain below this angle */
	if( ttol->norm > 0.0 )
		ntol = ttol->norm;
	else
		/* tolerate everything */
		ntol = bn_pi;

	/* (x, y) coords for an ellipse */
	ell = rt_mk_ell( &npts, a, b, dtol, ntol );
	/* generate coordinate axes */
	VMOVE( Nu, tip->eto_N );
	VUNITIZE( Nu );			/* z axis of coord sys */
	bn_vec_ortho( Bu, Nu );		/* x axis */
	VUNITIZE( Bu );
	VCROSS( Au, Nu, Bu );		/* y axis */

	/* number of segments required in eto circles */
	nells = rt_num_circular_segments( dtol, tip->eto_r );
	theta = bn_twopi / nells;	/* put ellipse every theta rads */
	/* get horizontal and vertical components of C and Rd */
	cv = VDOT( tip->eto_C, Nu );
	ch = sqrt( VDOT( tip->eto_C, tip->eto_C ) - cv * cv );
	/* angle between C and Nu */
	phi = acos( cv / MAGNITUDE(tip->eto_C) );
	dv = tip->eto_rd * sin(phi);
	dh = -tip->eto_rd * cos(phi);

	/* make sure ellipse doesn't overlap itself when revolved */
	if (ch > tip->eto_r || dh > tip->eto_r) {
		bu_log("eto_plot: revolved ellipse overlaps itself\n");
		return(1);
	}
	
	/* get memory for nells ellipses */
	eto_ells = (fastf_t *)bu_malloc(nells * npts * sizeof(point_t), "ells[]");

	/* place each ellipse properly to make eto */
	for (i = 0, ang = 0.; i < nells; i++, ang += theta) {
		/* direction of current ellipse */
		VCOMB2( Xu, cos(ang), Bu, sin(ang), Au );
		VUNITIZE( Xu );
		/* vertex of ellipse */
		VJOIN1( Ell_V, tip->eto_V, tip->eto_r, Xu );
		/* coord system for ellipse: x,y directions are Dp,Cp */
		VCOMB2( Cp, ch, Xu, cv, Nu );
		VCOMB2( Dp, dh, Xu, dv, Nu );
		VUNITIZE( Cp );
		VUNITIZE( Dp );

/* convert 2D address to index into 1D array */
#define ETO_PT(www,lll)	((((www)%nells)*npts)+((lll)%npts))
#define ETO_PTA(ww,ll)	(&eto_ells[ETO_PT(ww,ll)*3])
#define ETO_NMA(ww,ll)	(norms[ETO_PT(ww,ll)])

		/* make ellipse */
		for (j = 0; j < npts; j++) {
			VJOIN2( ETO_PTA(i,j),
				Ell_V, ell[j][X], Dp, ell[j][Y], Cp );
		}
	}
	
	/* draw ellipses */
	for (i = 0; i < nells; i++) {
		RT_ADD_VLIST( vhead, ETO_PTA(i,npts-1), BN_VLIST_LINE_MOVE );
		for( j = 0; j < npts; j++ )
			RT_ADD_VLIST( vhead, ETO_PTA(i,j), BN_VLIST_LINE_DRAW );
	}
	
	/* draw connecting circles */
	for (i = 0; i < npts; i++) {
		RT_ADD_VLIST( vhead, ETO_PTA(nells-1,i), BN_VLIST_LINE_MOVE );
		for( j = 0; j < nells; j++ )
			RT_ADD_VLIST( vhead, ETO_PTA(j,i), BN_VLIST_LINE_DRAW );
	}

	bu_free( (char *)eto_ells, "ells[]" );
	return(0);
}

/*
 *	R T _ E L L 4
 *
 *	Approximate one fourth (1st quadrant) of an ellipse with line
 *	segments.  The initial single segment is broken at the point
 *	farthest from the ellipse if that point is not aleady within the
 *	distance and normal error tolerances.  The two resulting segments are
 *	passed recursively to this routine until each segment is within
 *	tolerance.
 */
int
rt_ell4(struct rt_pt_node *pts, fastf_t a, fastf_t b, fastf_t dtol, fastf_t ntol)
{
	fastf_t	dist, intr, m, theta0, theta1;
	int	n;
	point_t	mpt, p0, p1;
	vect_t	norm_line, norm_ell;
	struct rt_pt_node *new, *rt_ptalloc(void);

	/* endpoints of segment approximating ellipse */
	VMOVE( p0, pts->p );
	VMOVE( p1, pts->next->p );
	/* slope and intercept of segment */
	m = ( p1[X] - p0[X] ) / ( p1[Y] - p0[Y] );
	intr = p0[X] - m * p0[Y];
	/* point on ellipse with max dist between ellipse and line */
	mpt[Y] = a / sqrt( b*b / (m*m*a*a) + 1 );
	mpt[X] = b * sqrt( 1 - mpt[Y] * mpt[Y] / (a*a) );
	mpt[Z] = 0;
	/* max distance between that point and line */
	dist = fabs( m * mpt[Y] - mpt[X] + intr ) / sqrt( m * m + 1 );
	/* angles between normal of line and of ellipse at line endpoints */
	VSET( norm_line, m, -1., 0.);
	VSET( norm_ell, b * b * p0[Y], a * a * p0[X], 0. );
	VUNITIZE( norm_line );
	VUNITIZE( norm_ell );
	theta0 = fabs( acos( VDOT( norm_line, norm_ell )));
	VSET( norm_ell, b * b * p1[Y], a * a * p1[X], 0. );
	VUNITIZE( norm_ell );
	theta1 = fabs( acos( VDOT( norm_line, norm_ell )));
	/* split segment at widest point if not within error tolerances */
	if ( dist > dtol || theta0 > ntol || theta1 > ntol ) {
		/* split segment */
		new = rt_ptalloc();
		VMOVE( new->p, mpt );
		new->next = pts->next;
		pts->next = new;
		/* keep track of number of pts added */
		n = 1;
		/* recurse on first new segment */
		n += rt_ell4( pts, a, b, dtol, ntol );
		/* recurse on second new segment */
		n += rt_ell4( new, a, b, dtol, ntol );
	} else
		n  = 0;
	return( n );
}

/*
 *	R T _ M K _ E L L
 *
 *	Return pointer an array of points approximating an ellipse
 *	with semi-major and semi-minor axes a and b.  The line
 *	segments fall within the normal and distance tolerances
 *	of ntol and dtol.
 */
point_t *
rt_mk_ell( n, a, b, dtol, ntol )
int	*n;
fastf_t	a, b, dtol, ntol;
{
	int		i;
	point_t		*ell;
	struct rt_pt_node	*ell_quad, *oldpos, *pos, *rt_ptalloc(void);

	ell_quad = rt_ptalloc();
	VSET( ell_quad->p, b, 0., 0. );
	ell_quad->next = rt_ptalloc();
	VSET( ell_quad->next->p, 0., a, 0. );
	ell_quad->next->next = NULL;

	*n = rt_ell4( ell_quad, a, b, dtol, ntol );
	ell = (point_t *)bu_malloc(4*(*n+1)*sizeof(point_t), "rt_mk_ell pts");

	/* put 1st quad of ellipse into an array */
	pos = ell_quad;
	for (i = 0; i < *n+2; i++) {
		VMOVE( ell[i], pos->p );
		oldpos = pos;
		pos = pos->next;
		bu_free( (char *)oldpos, "rt_pt_node" );
	}
	/* mirror 1st quad to make 2nd */
	for (i = (*n+1)+1; i < 2*(*n+1); i++) {
		VMOVE( ell[i], ell[(*n*2+2)-i] );
		ell[i][X] = -ell[i][X];
	}
	/* mirror 2nd quad to make 3rd */
	for (i = 2*(*n+1); i < 3*(*n+1); i++) {
		VMOVE( ell[i], ell[i-(*n*2+2)] );
		ell[i][X] = -ell[i][X];
		ell[i][Y] = -ell[i][Y];
	}
	/* mirror 3rd quad to make 4th */
	for (i = 3*(*n+1); i < 4*(*n+1); i++) {
		VMOVE( ell[i], ell[i-(*n*2+2)] );
		ell[i][X] = -ell[i][X];
		ell[i][Y] = -ell[i][Y];
	}
	*n = 4*(*n + 1);
	return(ell);
}

/*
 *			R T _ E T O _ T E S S
 */
int
rt_eto_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	fastf_t		a, b;	/* axis lengths of ellipse */
	fastf_t		ang, ch, cv, dh, dv, ntol, dtol, phi, theta;
	fastf_t		*eto_ells = NULL;
	int		i, j, nfaces, npts, nells;
	point_t		*ell = NULL;	/* array of ellipse points */
	point_t		Ell_V;	/* vertex of an ellipse */
	point_t		*rt_mk_ell();
	struct rt_eto_internal	*tip;
	struct shell	*s;
	struct vertex	**verts = NULL;
	struct faceuse	**faces = NULL;
	struct vertex	**vertp[4];
	vect_t		Au, Bu, Nu, Cp, Dp, Xu;
	vect_t		*norms = NULL;	/* normal vectors for each vertex */
	int		fail=0;

	RT_CK_DB_INTERNAL(ip);
	tip = (struct rt_eto_internal *)ip->idb_ptr;
	RT_ETO_CK_MAGIC(tip);

	a = MAGNITUDE( tip->eto_C );
	b = tip->eto_rd;

	if ( NEAR_ZERO(tip->eto_r, 0.0001) || NEAR_ZERO(b, 0.0001)
		|| NEAR_ZERO(a, 0.0001)) {
		bu_log("eto_tess: r, rd, or rc zero length\n");
		fail = (-2);
		goto failure;
	}

	/* Establish tolerances */
	if( ttol->rel <= 0.0 || ttol->rel >= 1.0 )  {
		dtol = 0.0;		/* none */
	} else {
		/*
		 * Convert relative to absolute by scaling smallest of
		 * radius and semi-minor axis
		 */
		if (tip->eto_r < b)
			dtol = ttol->rel * 2 * tip->eto_r;
		else
			dtol = ttol->rel * 2 * b;
	}
	if( ttol->abs <= 0.0 )  {
		if( dtol <= 0.0 )  {
			/* No tolerance given, use a default */
			if (tip->eto_r < b)
				dtol = 2 * 0.10 * tip->eto_r;	/* 10% */
			else
				dtol = 2 * 0.10 * b;	/* 10% */
		} else {
			/* Use absolute-ized relative tolerance */
		}
	} else {
		/* Absolute tolerance was given, pick smaller */
		if( ttol->rel <= 0.0 || dtol > ttol->abs )
			dtol = ttol->abs;
	}
	/* To ensure normal tolerance, remain below this angle */
	if( ttol->norm > 0.0 )
		ntol = ttol->norm;
	else
		/* tolerate everything */
		ntol = bn_pi;

	/* (x, y) coords for an ellipse */
	ell = rt_mk_ell( &npts, a, b, dtol, ntol );
	/* generate coordinate axes */
	VMOVE( Nu, tip->eto_N );
	VUNITIZE( Nu );			/* z axis of coord sys */
	bn_vec_ortho( Bu, Nu );		/* x axis */
	VUNITIZE( Bu );
	VCROSS( Au, Nu, Bu );		/* y axis */

	/* number of segments required in eto circles */
	nells = rt_num_circular_segments( dtol, tip->eto_r );
	theta = bn_twopi / nells;	/* put ellipse every theta rads */
	/* get horizontal and vertical components of C and Rd */
	cv = VDOT( tip->eto_C, Nu );
	ch = sqrt( VDOT( tip->eto_C, tip->eto_C ) - cv * cv );
	/* angle between C and Nu */
	phi = acos( cv / MAGNITUDE(tip->eto_C) );
	dv = tip->eto_rd * sin(phi);
	dh = -tip->eto_rd * cos(phi);

	/* make sure ellipse doesn't overlap itself when revolved */
	if (ch > tip->eto_r || dh > tip->eto_r) {
		bu_log("eto_tess: revolved ellipse overlaps itself\n");
		fail = (-3);
		goto failure;
	}
	
	/* get memory for nells ellipses */
	eto_ells = (fastf_t *)bu_malloc(nells * npts * sizeof(point_t), "ells[]");
	norms = (vect_t *)bu_calloc( nells*npts , sizeof( vect_t ) , "rt_eto_tess: norms" );

	/* place each ellipse properly to make eto */
	for (i = 0, ang = 0.; i < nells; i++, ang += theta) {
		/* direction of current ellipse */
		VCOMB2( Xu, cos(ang), Bu, sin(ang), Au );
		VUNITIZE( Xu );
		/* vertex of ellipse */
		VJOIN1( Ell_V, tip->eto_V, tip->eto_r, Xu );
		/* coord system for ellipse: x,y directions are Dp,Cp */
		VCOMB2( Cp, ch, Xu, cv, Nu );
		VCOMB2( Dp, dh, Xu, dv, Nu );
		VUNITIZE( Cp );
		VUNITIZE( Dp );
		/* make ellipse */
		for (j = 0; j < npts; j++) {
			VJOIN2( ETO_PTA(i,j),
				Ell_V, ell[j][X], Dp, ell[j][Y], Cp );
			VBLEND2( ETO_NMA(i,j),
				a*a*ell[j][X], Dp , b*b*ell[j][Y], Cp );
			VUNITIZE( ETO_NMA(i,j) );
		}
	}

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	verts = (struct vertex **)bu_calloc( npts*nells, sizeof(struct vertex *),
		"rt_eto_tess *verts[]" );
	faces = (struct faceuse **)bu_calloc( npts*nells, sizeof(struct faceuse *),
		"rt_eto_tess *faces[]" );

	/* Build the topology of the eto */
	nfaces = 0;
	for( i = 0; i < nells; i++ )  {
		for( j = 0; j < npts; j++ )  {
			vertp[0] = &verts[ ETO_PT(i+0,j+0) ];
			vertp[1] = &verts[ ETO_PT(i+0,j+1) ];
			vertp[2] = &verts[ ETO_PT(i+1,j+1) ];
			vertp[3] = &verts[ ETO_PT(i+1,j+0) ];
			if( (faces[nfaces++] = nmg_cmface( s, vertp, 4 )) == (struct faceuse *)0 )  {
				bu_log("rt_eto_tess() nmg_cmface failed, i=%d/%d, j=%d/%d\n",
					i, nells, j, npts );
				nfaces--;
			}
		}
	}

	/* Associate vertex geometry */
	for( i = 0; i < nells; i++ )  {
		for( j = 0; j < npts; j++ )  {
			nmg_vertex_gv( verts[ETO_PT(i,j)], ETO_PTA(i,j) );
		}
	}

	/* Associate face geometry */
	for( i=0; i < nfaces; i++ )  {
		if( nmg_fu_planeeqn( faces[i], tol ) < 0 )
		{
			fail = (-1);
			goto failure;
		}
	}

	/* associate vertexuse normals */
	for( i=0 ; i<nells ; i++ )
	{
		for( j=0 ; j<npts ; j++ )
		{
			struct vertexuse *vu;
			vect_t rev_norm;

			VREVERSE( rev_norm , ETO_NMA(i,j) );

			NMG_CK_VERTEX( verts[ETO_PT(i,j)] );

			for( BU_LIST_FOR( vu , vertexuse , &verts[ETO_PT(i,j)]->vu_hd ) )
			{
				struct faceuse *fu;

				NMG_CK_VERTEXUSE( vu );

				fu = nmg_find_fu_of_vu( vu );
				NMG_CK_FACEUSE( fu );

				if( fu->orientation == OT_SAME )
					nmg_vertexuse_nv( vu , ETO_NMA(i,j) );
				else if( fu->orientation == OT_OPPOSITE )
					nmg_vertexuse_nv( vu , rev_norm );
			}
		}
	}

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

failure:	
	bu_free( (char *)ell, "rt_mk_ell pts" );
	bu_free( (char *)eto_ells, "ells[]" );
	bu_free( (char *)verts, "rt_eto_tess *verts[]" );
	bu_free( (char *)faces, "rt_eto_tess *faces[]" );
	bu_free( (char *)norms, "rt_eto_tess: norms[]" );

	return( fail );
}

/*
 *			R T _ E T O _ I M P O R T
 *
 *  Import a eto from the database format to the internal format.
 *  Apply modeling transformations at the same time.
 */
int
rt_eto_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_eto_internal	*tip;
	union record		*rp;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_eto_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_ETO;
	ip->idb_meth = &rt_functab[ID_ETO];
	ip->idb_ptr = bu_malloc(sizeof(struct rt_eto_internal), "rt_eto_internal");
	tip = (struct rt_eto_internal *)ip->idb_ptr;
	tip->eto_magic = RT_ETO_INTERNAL_MAGIC;

	/* Apply modeling transformations */
	MAT4X3PNT( tip->eto_V, mat, &rp->s.s_values[0*3] );
	MAT4X3VEC( tip->eto_N, mat, &rp->s.s_values[1*3] );
	MAT4X3VEC( tip->eto_C, mat, &rp->s.s_values[2*3] );
	tip->eto_r  = rp->s.s_values[3*3] / mat[15];
	tip->eto_rd = rp->s.s_values[3*3+1] / mat[15];

	if( tip->eto_r < SMALL || tip->eto_rd < SMALL )  {
		bu_log("rt_eto_import:  zero length R or Rd vector\n");
		return(-1);
	}

	return(0);		/* OK */
}

/*
 *			R T _ E T O _ E X P O R T
 *
 *  The name will be added by the caller.
 */
int
rt_eto_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_eto_internal	*tip;
	union record		*eto;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ETO )  return(-1);
	tip = (struct rt_eto_internal *)ip->idb_ptr;
	RT_ETO_CK_MAGIC(tip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "eto external");
	eto = (union record *)ep->ext_buf;

	eto->s.s_id = ID_SOLID;
	eto->s.s_type = ETO;

	if (MAGNITUDE(tip->eto_C) < RT_LEN_TOL
		|| MAGNITUDE(tip->eto_N) < RT_LEN_TOL
		|| tip->eto_r < RT_LEN_TOL
		|| tip->eto_rd < RT_LEN_TOL) {
		bu_log("rt_eto_export: not all dimensions positive!\n");
		return(-1);
	}
	
	if (tip->eto_rd > MAGNITUDE(tip->eto_C) ) {
		bu_log("rt_eto_export: semi-minor axis cannot be longer than semi-major axis!\n");
		return(-1);
	}

	/* Warning:  type conversion */
	VSCALE( &eto->s.s_values[0*3], tip->eto_V, local2mm );
	VSCALE( &eto->s.s_values[1*3], tip->eto_N, local2mm );
	VSCALE( &eto->s.s_values[2*3], tip->eto_C, local2mm );
	eto->s.s_values[3*3] = tip->eto_r * local2mm;
	eto->s.s_values[3*3+1] = tip->eto_rd * local2mm;

	return(0);
}

/*
 *			R T _ E T O _ I M P O R T 5
 *
 *  Import a eto from the database format to the internal format.
 *  Apply modeling transformations at the same time.
 */
int
rt_eto_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_eto_internal	*tip;
	fastf_t			vec[11];

	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 11 );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_ETO;
	ip->idb_meth = &rt_functab[ID_ETO];
	ip->idb_ptr = bu_malloc(sizeof(struct rt_eto_internal), "rt_eto_internal");

	tip = (struct rt_eto_internal *)ip->idb_ptr;
	tip->eto_magic = RT_ETO_INTERNAL_MAGIC;

	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)vec, ep->ext_buf, 11 );

	/* Apply modeling transformations */
	MAT4X3PNT( tip->eto_V, mat, &vec[0*3] );
	MAT4X3VEC( tip->eto_N, mat, &vec[1*3] );
	MAT4X3VEC( tip->eto_C, mat, &vec[2*3] );
	tip->eto_r  = vec[3*3] / mat[15];
	tip->eto_rd = vec[3*3+1] / mat[15];

	if( tip->eto_r < SMALL || tip->eto_rd < SMALL )  {
		bu_log("rt_eto_import:  zero length R or Rd vector\n");
		return(-1);
	}

	return(0);		/* OK */
}

/*
 *			R T _ E T O _ E X P O R T 5
 *
 *  The name will be added by the caller.
 */
int
rt_eto_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_eto_internal	*tip;
	fastf_t			vec[11];

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ETO )  return(-1);
	tip = (struct rt_eto_internal *)ip->idb_ptr;
	RT_ETO_CK_MAGIC(tip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 11;
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "eto external");

	if (MAGNITUDE(tip->eto_C) < RT_LEN_TOL
		|| MAGNITUDE(tip->eto_N) < RT_LEN_TOL
		|| tip->eto_r < RT_LEN_TOL
		|| tip->eto_rd < RT_LEN_TOL) {
		bu_log("rt_eto_export: not all dimensions positive!\n");
		return(-1);
	}
	
	if (tip->eto_rd > MAGNITUDE(tip->eto_C) ) {
		bu_log("rt_eto_export: semi-minor axis cannot be longer than semi-major axis!\n");
		return(-1);
	}

	/* scale 'em into local buffer */
	VSCALE( &vec[0*3], tip->eto_V, local2mm );
	VSCALE( &vec[1*3], tip->eto_N, local2mm );
	VSCALE( &vec[2*3], tip->eto_C, local2mm );
	vec[3*3] = tip->eto_r * local2mm;
	vec[3*3+1] = tip->eto_rd * local2mm;

	/* Convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, 11 );

	return(0);
}

/*
 *			R T _ E T O _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_eto_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_eto_internal	*tip =
		(struct rt_eto_internal *)ip->idb_ptr;
	char				buf[256];

	RT_ETO_CK_MAGIC(tip);
	bu_vls_strcat( str, "Elliptical Torus (ETO)\n");

	sprintf(buf, "\tV (%g, %g, %g)\n",
		tip->eto_V[X] * mm2local,
		tip->eto_V[Y] * mm2local,
		tip->eto_V[Z] * mm2local);
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tN=(%g, %g, %g)\n",
		tip->eto_N[X] * mm2local,
		tip->eto_N[Y] * mm2local,
		tip->eto_N[Z] * mm2local );
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tC=(%g, %g, %g) mag=%g\n",
		tip->eto_C[X] * mm2local,
		tip->eto_C[Y] * mm2local,
		tip->eto_C[Z] * mm2local,
		MAGNITUDE(tip->eto_C) * mm2local);
	bu_vls_strcat( str, buf );
	
	sprintf(buf, "\tr=%g\n", tip->eto_r * mm2local);
	bu_vls_strcat( str, buf );
	
	sprintf(buf, "\td=%g\n", tip->eto_rd * mm2local);
	bu_vls_strcat( str, buf );

	return(0);
}

/*
 *			R T _ E T O _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_eto_ifree(struct rt_db_internal *ip)
{
	register struct rt_eto_internal	*tip;

	RT_CK_DB_INTERNAL(ip);
	tip = (struct rt_eto_internal *)ip->idb_ptr;
	RT_ETO_CK_MAGIC(tip);

	bu_free( (char *)tip, "eto ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}
@


11.24
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /cvs/brlcad/librt/g_eto.c,v 11.23 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.23
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.22
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.21 2002/08/20 17:07:59 jra Exp $ (BRL)";
d160 1
a160 4
rt_eto_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d265 1
a265 2
rt_eto_print( stp )
register const struct soltab *stp;
d314 1
a314 5
rt_eto_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d527 6
a532 6
rt_eto_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d559 1
a559 4
rt_eto_norm( hitp, stp, rp)
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d594 1
a594 4
rt_eto_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d659 1
a659 5
rt_eto_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d701 1
a701 2
rt_eto_free( stp )
struct soltab *stp;
d710 1
a710 1
rt_eto_class()
d727 1
a727 5
rt_eto_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d870 1
a870 3
rt_ell4( pts, a, b, dtol, ntol )
fastf_t	a, b, dtol, ntol;
struct rt_pt_node	*pts;
d876 1
a876 1
	struct rt_pt_node *new, *rt_ptalloc();
d932 1
a932 1
	struct rt_pt_node	*ell_quad, *oldpos, *pos, *rt_ptalloc();
d976 1
a976 6
rt_eto_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d1185 1
a1185 5
rt_eto_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1227 1
a1227 5
rt_eto_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1275 1
a1275 5
rt_eto_import5( ip, ep, mat, dbip )
     struct rt_db_internal	*ip;
     const struct bu_external	*ep;
     register const mat_t	mat;
     const struct db_i		*dbip;
d1317 1
a1317 5
rt_eto_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1365 1
a1365 5
rt_eto_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1408 1
a1408 2
rt_eto_ifree( ip )
struct rt_db_internal	*ip;
@


11.21
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1992 by the United States Army.
d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.19 2001/10/02 19:24:29 jra Exp $ (BRL)";
@


11.21.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_eto.c,v 11.22 2004/02/02 17:39:20 morrison Exp $ (BRL)";
@


11.21.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.22 2004/02/02 17:39:20 morrison Exp $ (BRL)";
@


11.21.10.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.21.10.1 2004/02/12 18:37:40 erikg Exp $ (BRL)";
@


11.21.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.21 2002/08/20 17:07:59 jra Exp $ (BRL)";
d160 4
a163 1
rt_eto_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d268 2
a269 1
rt_eto_print(register const struct soltab *stp)
d318 5
a322 1
rt_eto_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d535 6
a540 6
rt_eto_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d567 4
a570 1
rt_eto_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d605 4
a608 1
rt_eto_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d673 5
a677 1
rt_eto_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d719 2
a720 1
rt_eto_free(struct soltab *stp)
d729 1
a729 1
rt_eto_class(void)
d746 5
a750 1
rt_eto_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d893 3
a895 1
rt_ell4(struct rt_pt_node *pts, fastf_t a, fastf_t b, fastf_t dtol, fastf_t ntol)
d901 1
a901 1
	struct rt_pt_node *new, *rt_ptalloc(void);
d957 1
a957 1
	struct rt_pt_node	*ell_quad, *oldpos, *pos, *rt_ptalloc(void);
d1001 6
a1006 1
rt_eto_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1215 5
a1219 1
rt_eto_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1261 5
a1265 1
rt_eto_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1313 5
a1317 1
rt_eto_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1359 5
a1363 1
rt_eto_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1411 5
a1415 1
rt_eto_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1458 2
a1459 1
rt_eto_ifree(struct rt_db_internal *ip)
@


11.21.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header$ (BRL)";
@


11.20
log
@Converted from K&R to ANSI C - RFH
@
text
@d160 4
a163 1
rt_eto_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d268 2
a269 1
rt_eto_print(register const struct soltab *stp)
d318 5
a322 1
rt_eto_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d535 6
a540 6
rt_eto_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d567 4
a570 1
rt_eto_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d605 4
a608 1
rt_eto_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d673 5
a677 1
rt_eto_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d719 2
a720 1
rt_eto_free(struct soltab *stp)
d729 1
a729 1
rt_eto_class(void)
d746 5
a750 1
rt_eto_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d893 3
a895 1
rt_ell4(struct rt_pt_node *pts, fastf_t a, fastf_t b, fastf_t dtol, fastf_t ntol)
d901 1
a901 1
	struct rt_pt_node *new, *rt_ptalloc(void);
d957 1
a957 1
	struct rt_pt_node	*ell_quad, *oldpos, *pos, *rt_ptalloc(void);
d1001 6
a1006 1
rt_eto_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1215 5
a1219 1
rt_eto_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1261 5
a1265 1
rt_eto_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1313 5
a1317 1
rt_eto_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1359 5
a1363 1
rt_eto_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1411 5
a1415 1
rt_eto_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1458 2
a1459 1
rt_eto_ifree(struct rt_db_internal *ip)
@


11.19
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.18 2001/04/20 22:29:44 morrison Exp $ (BRL)";
d160 1
a160 4
rt_eto_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d265 1
a265 2
rt_eto_print( stp )
register const struct soltab *stp;
d314 1
a314 5
rt_eto_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d527 6
a532 6
rt_eto_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d559 1
a559 4
rt_eto_norm( hitp, stp, rp)
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d594 1
a594 4
rt_eto_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d659 1
a659 5
rt_eto_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d701 1
a701 2
rt_eto_free( stp )
struct soltab *stp;
d710 1
a710 1
rt_eto_class()
d727 1
a727 5
rt_eto_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d870 1
a870 3
rt_ell4( pts, a, b, dtol, ntol )
fastf_t	a, b, dtol, ntol;
struct rt_pt_node	*pts;
d876 1
a876 1
	struct rt_pt_node *new, *rt_ptalloc();
d932 1
a932 1
	struct rt_pt_node	*ell_quad, *oldpos, *pos, *rt_ptalloc();
d976 1
a976 6
rt_eto_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d1185 1
a1185 5
rt_eto_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1227 1
a1227 5
rt_eto_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1275 1
a1275 5
rt_eto_import5( ip, ep, mat, dbip )
     struct rt_db_internal	*ip;
     const struct bu_external	*ep;
     register const mat_t	mat;
     const struct db_i		*dbip;
d1317 1
a1317 5
rt_eto_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1365 1
a1365 5
rt_eto_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1408 1
a1408 2
rt_eto_ifree( ip )
struct rt_db_internal	*ip;
@


11.18
log
@CONST to const
@
text
@d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.17 2001/03/31 01:57:08 morrison Exp $ (BRL)";
d1233 1
d1327 1
@


11.17
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.16 2000/10/18 18:10:34 butler Exp $ (BRL)";
d135 1
a135 1
CONST struct bu_structparse rt_eto_parse[] = {
d269 1
a269 1
register CONST struct soltab *stp;
d271 1
a271 1
	register CONST struct eto_specific *eto =
d749 2
a750 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d1005 2
a1006 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d1217 3
a1219 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1262 1
a1262 1
CONST struct rt_db_internal	*ip;
d1264 1
a1264 1
CONST struct db_i		*dbip;
d1314 3
a1316 3
     CONST struct bu_external	*ep;
     register CONST mat_t	mat;
     CONST struct db_i		*dbip;
d1359 1
a1359 1
CONST struct rt_db_internal	*ip;
d1361 1
a1361 1
CONST struct db_i		*dbip;
d1411 1
a1411 1
CONST struct rt_db_internal	*ip;
@


11.16
log
@Patches for compiling under RedHat 7.0
@
text
@d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.15 2000/08/22 21:16:59 mike Exp $ (BRL)";
d217 1
a217 1
	bn_mat_idn( eto->eto_R );
@


11.15
log
@
lint
@
text
@d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.14 2000/08/21 02:02:30 butler Exp $ (BRL)";
d27 3
@


11.14
log
@Massive compilation warnings eliminated
@
text
@d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.13 2000/07/10 23:01:31 mike Exp $ (BRL)";
d1007 1
a1007 1
	fastf_t		*eto_ells;
d1009 1
a1009 1
	point_t		*ell;	/* array of ellipse points */
d1014 2
a1015 2
	struct vertex	**verts;
	struct faceuse	**faces;
d1018 1
a1018 1
	vect_t		*norms;	/* normal vectors for each vertex */
@


11.13
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.12 2000/06/30 15:38:03 mike Exp $ (BRL)";
d138 2
a139 1
    {0} };
@


11.12
log
@
export methods should not init the external structure, just check them.
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.11 2000/06/30 15:31:14 mike Exp $ (BRL)";
@


11.11
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.10 2000/06/29 14:00:44 bparker Exp $ (BRL)";
d1270 1
a1270 1
	BU_INIT_EXTERNAL(ep);
d1367 1
a1367 1
	BU_INIT_EXTERNAL(ep);
@


11.10
log
@Add rt_eto_import5 and rt_eto_export5 routines.
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.9 2000/04/12 02:34:33 mike Exp $ (BRL)";
d1228 1
a1228 1
	RT_INIT_DB_INTERNAL( ip );
d1321 1
a1321 1
	RT_INIT_DB_INTERNAL( ip );
@


11.9
log
@
NT port, non-compat4
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.8 1999/11/26 21:46:46 mike Exp $ (BRL)";
d1297 96
@


11.8
log
@
Lint cleanups
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.7 1999/11/24 23:12:07 mike Exp $ (BRL)";
d188 1
a188 1
	vec_ortho( Bu, Nu );	/* x axis */
d811 1
a811 1
	vec_ortho( Bu, Nu );		/* x axis */
d1074 1
a1074 1
	vec_ortho( Bu, Nu );		/* x axis */
@


11.7
log
@
Made structparse tables CONST
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.6 1999/11/17 02:41:58 mike Exp $ (BRL)";
a131 5
struct pt_node {
	point_t		p;	/* a point */
	struct pt_node	*next;	/* ptr to next pt */
};

d746 1
a746 1
struct bn_tol		*tol;
d849 3
a851 3
#define PT(www,lll)	((((www)%nells)*npts)+((lll)%npts))
#define PTA(ww,ll)	(&eto_ells[PT(ww,ll)*3])
#define NMA(ww,ll)	(norms[PT(ww,ll)])
d855 1
a855 1
			VJOIN2( PTA(i,j),
d862 1
a862 1
		RT_ADD_VLIST( vhead, PTA(i,npts-1), BN_VLIST_LINE_MOVE );
d864 1
a864 1
			RT_ADD_VLIST( vhead, PTA(i,j), BN_VLIST_LINE_DRAW );
d869 1
a869 1
		RT_ADD_VLIST( vhead, PTA(nells-1,i), BN_VLIST_LINE_MOVE );
d871 1
a871 1
			RT_ADD_VLIST( vhead, PTA(j,i), BN_VLIST_LINE_DRAW );
d891 1
a891 1
struct pt_node	*pts;
d897 1
a897 1
	struct pt_node *new, *rt_ptalloc();
d953 1
a953 1
	struct pt_node	*ell_quad, *oldpos, *pos, *rt_ptalloc();
d970 1
a970 1
		bu_free( (char *)oldpos, "pt_node" );
d1002 1
a1002 1
struct bn_tol		*tol;
d1114 1
a1114 1
			VJOIN2( PTA(i,j),
d1116 1
a1116 1
			VBLEND2( NMA(i,j),
d1118 1
a1118 1
			VUNITIZE( NMA(i,j) );
d1134 4
a1137 4
			vertp[0] = &verts[ PT(i+0,j+0) ];
			vertp[1] = &verts[ PT(i+0,j+1) ];
			vertp[2] = &verts[ PT(i+1,j+1) ];
			vertp[3] = &verts[ PT(i+1,j+0) ];
d1149 1
a1149 1
			nmg_vertex_gv( verts[PT(i,j)], PTA(i,j) );
d1170 1
a1170 1
			VREVERSE( rev_norm , NMA(i,j) );
d1172 1
a1172 1
			NMG_CK_VERTEX( verts[PT(i,j)] );
d1174 1
a1174 1
			for( BU_LIST_FOR( vu , vertexuse , &verts[PT(i,j)]->vu_hd ) )
d1184 1
a1184 1
					nmg_vertexuse_nv( vu , NMA(i,j) );
d1211 1
a1211 1
rt_eto_import( ip, ep, mat )
d1215 1
d1256 1
a1256 1
rt_eto_export( ep, ip, local2mm )
d1260 1
d1311 1
a1311 1
struct rt_db_internal	*ip;
@


11.6
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.5 1999/07/02 22:19:23 mike Exp $ (BRL)";
d137 1
a137 1
struct bu_structparse rt_eto_parse[] = {
@


11.5
log
@
Removed dependence on compat4.h
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.4 1999/05/27 19:10:38 mike Exp $ (BRL)";
d1234 1
@


11.4
log
@
sed4
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_eto.c,v 11.3 1997/06/17 19:34:10 gdurf Exp $ (BRL)";
a34 2
#include "./complex.h"
#include "./polyno.h"
d331 1
a331 1
	LOCAL poly	C;		/* The final equation */
d867 1
a867 1
		RT_ADD_VLIST( vhead, PTA(i,npts-1), RT_VLIST_LINE_MOVE );
d869 1
a869 1
			RT_ADD_VLIST( vhead, PTA(i,j), RT_VLIST_LINE_DRAW );
d874 1
a874 1
		RT_ADD_VLIST( vhead, PTA(nells-1,i), RT_VLIST_LINE_MOVE );
d876 1
a876 1
			RT_ADD_VLIST( vhead, PTA(j,i), RT_VLIST_LINE_DRAW );
@


11.3
log
@Added bu_structparse (from tcl.c)
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /m/cad/librt/RCS/g_eto.c,v 11.2 1996/08/31 10:53:21 mike Exp gdurf $ (BRL)";
d178 1
a178 1
	GETSTRUCT( eto, eto_specific );
d186 1
a186 1
		rt_log("eto(%s): r, rd, or rc zero length\n", stp->st_name);
d209 1
a209 1
		rt_log("eto(%s): revolved ellipse overlaps itself\n",
d220 1
a220 1
	mat_idn( eto->eto_R );
d224 1
a224 1
	mat_inv( eto->eto_invR, eto->eto_R );
d280 6
a285 6
	rt_log("r = %f\n", eto->eto_r);
	rt_log("rc = %f\n", eto->eto_rc);
	rt_log("rd = %f\n", eto->eto_rd);
	mat_print("R", eto->eto_R );
	mat_print("invR", eto->eto_invR );
	rt_log( "rpp: (%g, %g, %g) to (%g, %g, %g)\n",
d334 1
a334 1
	LOCAL complex	val[4];	/* The complex roots */
d443 2
a444 2
			rt_log("eto:  rt_poly_roots() 4!=%d\n", i);
			rt_pr_roots( stp->st_name, val, i );
d470 2
a471 2
		rt_log("rt_eto_shot: reduced 4 to %d roots\n",i);
		rt_pr_roots( stp->st_name, val, 4 );
d514 1
a514 1
	RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d527 1
a527 1
	RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d708 1
a708 1
		theta_u += rt_twopi;
d710 1
a710 1
		theta_v += rt_twopi;
d713 2
a714 2
	uvp->uv_u = theta_u/rt_twopi;
	uvp->uv_v = theta_v/rt_twopi;
d728 1
a728 1
	rt_free( (char *)eto, "eto_specific");
d750 1
a750 1
struct rt_list		*vhead;
d753 1
a753 1
struct rt_tol		*tol;
d774 1
a774 1
		rt_log("eto_plot: r, rd, or rc zero length\n");
d811 1
a811 1
		ntol = rt_pi;
d824 1
a824 1
	theta = rt_twopi / nells;	/* put ellipse every theta rads */
d835 1
a835 1
		rt_log("eto_plot: revolved ellipse overlaps itself\n");
d840 1
a840 1
	eto_ells = (fastf_t *)rt_malloc(nells * npts * sizeof(point_t), "ells[]");
d881 1
a881 1
	rt_free( (char *)eto_ells, "ells[]" );
d969 1
a969 1
	ell = (point_t *)rt_malloc(4*(*n+1)*sizeof(point_t), "rt_mk_ell pts");
d977 1
a977 1
		rt_free( (char *)oldpos, "pt_node" );
d1009 1
a1009 1
struct rt_tol		*tol;
d1036 1
a1036 1
		rt_log("eto_tess: r, rd, or rc zero length\n");
d1074 1
a1074 1
		ntol = rt_pi;
d1087 1
a1087 1
	theta = rt_twopi / nells;	/* put ellipse every theta rads */
d1098 1
a1098 1
		rt_log("eto_tess: revolved ellipse overlaps itself\n");
d1104 2
a1105 2
	eto_ells = (fastf_t *)rt_malloc(nells * npts * sizeof(point_t), "ells[]");
	norms = (vect_t *)rt_calloc( nells*npts , sizeof( vect_t ) , "rt_eto_tess: norms" );
d1130 1
a1130 1
	s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d1132 1
a1132 1
	verts = (struct vertex **)rt_calloc( npts*nells, sizeof(struct vertex *),
d1134 1
a1134 1
	faces = (struct faceuse **)rt_calloc( npts*nells, sizeof(struct faceuse *),
d1146 1
a1146 1
				rt_log("rt_eto_tess() nmg_cmface failed, i=%d/%d, j=%d/%d\n",
d1181 1
a1181 1
			for( RT_LIST_FOR( vu , vertexuse , &verts[PT(i,j)]->vu_hd ) )
d1202 5
a1206 5
	rt_free( (char *)ell, "rt_mk_ell pts" );
	rt_free( (char *)eto_ells, "ells[]" );
	rt_free( (char *)verts, "rt_eto_tess *verts[]" );
	rt_free( (char *)faces, "rt_eto_tess *faces[]" );
	rt_free( (char *)norms, "rt_eto_tess: norms[]" );
d1220 1
a1220 1
CONST struct rt_external	*ep;
d1226 1
a1226 1
	RT_CK_EXTERNAL( ep );
d1230 1
a1230 1
		rt_log("rt_eto_import: defective record\n");
d1236 1
a1236 1
	ip->idb_ptr = rt_malloc(sizeof(struct rt_eto_internal), "rt_eto_internal");
d1248 1
a1248 1
		rt_log("rt_eto_import:  zero length R or Rd vector\n");
d1262 1
a1262 1
struct rt_external		*ep;
d1274 1
a1274 1
	RT_INIT_EXTERNAL(ep);
d1276 1
a1276 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "eto external");
d1286 1
a1286 1
		rt_log("rt_eto_export: not all dimensions positive!\n");
d1291 1
a1291 1
		rt_log("rt_eto_export: semi-minor axis cannot be longer than semi-major axis!\n");
d1314 1
a1314 1
struct rt_vls		*str;
d1324 1
a1324 1
	rt_vls_strcat( str, "Elliptical Torus (ETO)\n");
d1330 1
a1330 1
	rt_vls_strcat( str, buf );
d1336 1
a1336 1
	rt_vls_strcat( str, buf );
d1343 1
a1343 1
	rt_vls_strcat( str, buf );
d1346 1
a1346 1
	rt_vls_strcat( str, buf );
d1349 1
a1349 1
	rt_vls_strcat( str, buf );
d1369 1
a1369 1
	rt_free( (char *)tip, "eto ifree" );
@


11.2
log
@bn.h
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /m/cad/librt/RCS/g_eto.c,v 11.1 1995/01/04 09:56:39 mike Rel4_4 mike $ (BRL)";
d138 8
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /m/cad/librt/RCS/g_eto.c,v 1.11 94/12/27 17:14:45 mike Exp $ (BRL)";
d326 1
a326 1
	LOCAL complex	val[MAXP];	/* The complex roots */
@


1.11
log
@Fix to bug #247
Added rt_prefix and regularized names like polyRoots into rt_poly_roots.
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /m/cad/librt/RCS/g_eto.c,v 1.10 94/11/08 03:04:57 mike Exp Locker: mike $ (BRL)";
@


1.10
log
@Irix 6
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /m/cad/librt/RCS/g_eto.c,v 1.9 94/09/29 12:24:01 jra Exp Locker: mike $ (BRL)";
d433 1
a433 1
	if ( (i = polyRoots( &C, val )) != 4 ){
d435 1
a435 1
			rt_log("eto:  polyRoots() 4!=%d\n", i);
@


1.9
log
@Added vertexuse normals to tessellator.
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /m/cad/librt/RCS/g_eto.c,v 1.8 94/09/13 15:49:53 jra Exp Locker: jra $ (BRL)";
d329 1
a329 1
	LOCAL int	j, n;
d331 1
a331 1
	LOCAL fastf_t	cor_proj, f1;
d605 1
a605 1
	fastf_t	a, b, ch, cv, dh, dv, k_circ, k_ell, phi, rad, xp, yp,
d638 1
a638 1
	yp = VDOT( Hit_Ell, Cp );
d755 1
a755 1
	vect_t		Au, Bu, Nu, D, Cp, Dp, Xu;
d897 1
a897 2
	struct pt_node *pos;
	
d1015 1
a1015 1
	vect_t		Au, Bu, Nu, D, Cp, Dp, Xu;
a1216 3
	LOCAL fastf_t		vec[3*4];
	vect_t			axb;
	register fastf_t	f;
a1259 5
	vect_t			norm;
	vect_t			cross1, cross2;
	fastf_t			r1, r2;
	fastf_t			r3, r4;
	double			m2;
a1310 1
	register int			j;
a1313 2
	int				i;
	double				r3, r4;
@


1.8
log
@changed an "fprintf( stderr" to an "rt_log" and fixed failure code for tesselator.
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /m/cad/librt/RCS/g_eto.c,v 1.7 94/09/02 16:03:29 jra Exp Locker: jra $ (BRL)";
d850 1
d1017 1
d1098 1
d1116 3
d1162 29
d1199 1
@


1.7
log
@Added scaling for scalar values on import where needed.
Added conversion to mm for scalar values where needed.
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /m/cad/librt/RCS/g_eto.c,v 1.6 94/08/10 18:27:45 gdurf Exp Locker: jra $ (BRL)";
d277 1
a277 1
	fprintf(stderr, "rpp: (%g, %g, %g) to (%g, %g, %g)\n",
d1016 1
d1028 2
a1029 1
		return(-2);
d1090 2
a1091 1
		return(-3);
d1150 4
a1153 1
			return -1;		/* FAIL */
d1159 1
d1165 1
a1165 1
	return(0);
@


1.6
log
@Added include of conf.h
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /m/cad/librt/RCS/g_eto.c,v 1.5 1993/11/18 01:44:05 mike Exp gdurf $ (BRL)";
d1197 2
a1198 2
	tip->eto_r  = rp->s.s_values[3*3];
	tip->eto_rd = rp->s.s_values[3*3+1];
d1257 2
a1258 2
	eto->s.s_values[3*3] = tip->eto_r;
	eto->s.s_values[3*3+1] = tip->eto_rd;
@


1.5
log
@Added tol arg to bounding box routines
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /m/cad/librt/RCS/g_eto.c,v 1.4 92/03/27 12:59:24 mmark Exp $ (BRL)";
d23 2
@


1.4
log
@added matrix multiply to import()
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /m/cad/librt/RCS/g_eto.c,v 1.3 92/03/25 15:52:56 mmark Exp Locker: mmark $ (BRL)";
d1149 1
a1149 1
	nmg_region_a( *r );
@


1.3
log
@added error checking to import
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /m/cad/librt/RCS/g_eto.c,v 1.2 92/03/24 14:07:09 mmark Exp Locker: mmark $ (BRL)";
d1192 3
a1194 3
	VMOVE( tip->eto_V, &rp->s.s_values[0*3] );
	VMOVE( tip->eto_N, &rp->s.s_values[1*3] );
	VMOVE( tip->eto_C, &rp->s.s_values[2*3] );
@


1.2
log
@fixed import bug
@
text
@d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /m/cad/librt/RCS/g_eto.c,v 1.1 92/02/14 15:32:01 mmark Exp $ (BRL)";
d1238 13
d1252 3
a1254 3
	VMOVE( &eto->s.s_values[0*3], tip->eto_V );
	VMOVE( &eto->s.s_values[1*3], tip->eto_N );
	VMOVE( &eto->s.s_values[2*3], tip->eto_C );
@


1.1
log
@Initial revision
@
text
@a8 1
 *	Edwin O. Davisson	(ETO Eqn Development)
d21 1
a21 1
static char RCSeto[] = "@@(#)$Header: /vld/mmark/cad/librt/RCS/g_eto.c,v 1.2 92/02/14 13:23:58 mmark Exp $ (BRL)";
d625 1
a625 1
	dh = eto->eto_rd * cos(phi);
d821 1
a821 1
	dh = tip->eto_rd * cos(phi);
d1196 2
a1197 1
	tip->eto_rd = rp->s.s_values[4*3];
d1243 1
a1243 1
	eto->s.s_values[4*3] = tip->eto_rd;
d1270 1
a1270 1
	rt_vls_strcat( str, "eto (ETO)\n");
d1272 1
a1272 1
	sprintf(buf, "\tV (%g, %g, %g), r=%g (A), rd=%g (H)\n",
d1275 1
a1275 2
		tip->eto_V[Z] * mm2local,
		tip->eto_r * mm2local, tip->eto_rd * mm2local );
d1284 1
a1284 1
	sprintf(buf, "\tC=(%g, %g, %g)\n",
d1287 8
a1294 1
		tip->eto_C[Z] * mm2local );
@
