head	11.3;
access;
symbols
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.3
date	99.05.27.22.03.35;	author mike;	state dead;
branches;
next	11.2;

11.2
date	95.07.27.17.39.36;	author gdurf;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.31;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.10.19.42.01;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.57;	author mike;	state Rel4_0;
branches;
next	1.5;

1.5
date	91.07.10.23.49.33;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.07.10.23.41.52;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.06.25.16.11.06;	author phil;	state Exp;
branches;
next	1.2;

1.2
date	89.08.12.07.32.10;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.08.12.05.02.22;	author mike;	state Exp;
branches;
next	;


desc
@Quaternion math package.
@


11.3
log
@
it lives in libbn now
@
text
@/*
 *		Q M A T H . C
 *
 *  Quaternion math routines.
 *
 *  Unit Quaternions:
 *	Q = [ r, a ]	where r = cos(theta/2) = rotation amount
 *			    |a| = sin(theta/2) = rotation axis
 *
 *      If a = 0 we have the reals; if one coord is zero we have
 *	 complex numbers (2D rotations).
 *
 *  [r,a][s,b] = [rs - a.b, rb + sa + axb]
 *
 *       -1
 *  [r,a]   = (r - a) / (r^2 + a.a)
 *
 *  Powers of quaternions yield incremental rotations,
 *   e.g. Q^3 is rotated three times as far as Q.
 *
 *  Some operations on quaternions:
 *            -1
 *   [0,P'] = Q  [0,P]Q		Rotate a point P by quaternion Q
 *                     -1  a
 *   slerp(Q,R,a) = Q(Q  R)	Spherical linear interp: 0 < a < 1
 *
 *   bisect(P,Q) = (P + Q) / |P + Q|	Great circle bisector
 *
 *
 *  Author -
 *	Phil Dykstra, 25 Sep 1985
 *
 *  Additions inspired by "Quaternion Calculus For Animation" by Ken Shoemake,
 *  SIGGRAPH '89 course notes for "Math for SIGGRAPH", May 1989.
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/qmath.c,v 11.2 1995/07/27 17:39:36 gdurf Exp $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>		/* DEBUG need stderr for now... */
#include <math.h>
#include "machine.h"
#include "vmath.h"

#ifdef M_PI
#define PI M_PI
#else
#define PI	3.14159265358979323264
#endif
#define	RTODEG	(180.0/PI)

/*
 *			Q U A T _ M A T 2 Q U A T
 *
 *  Convert Matrix to Quaternion.
 */
void
quat_mat2quat( quat, mat )
register quat_t	quat;
register mat_t	mat;
{
	fastf_t		tr;
	FAST fastf_t	s;

#define XX	0
#define YY	5
#define ZZ	10
#define M(a,b)		mat[4*(a)+(b)]

	tr = mat[XX] + mat[YY] + mat[ZZ];
	if( tr > 0.0 )  {
		s = sqrt( tr + 1.0 );
		quat[W] = s * 0.5;
		s = 0.5 / s;
		quat[X] = ( mat[6] - mat[9] ) * s;
		quat[Y] = ( mat[8] - mat[2] ) * s;
		quat[Z] = ( mat[1] - mat[4] ) * s;
		return;
	}

	/* Find dominant element of primary diagonal */
	if( mat[YY] > mat[XX] )  {
		if( mat[ZZ] > mat[YY] )  {
			s = sqrt( M(Z,Z) - (M(X,X)+M(Y,Y)) + 1.0 );
			quat[Z] = s * 0.5;
			s = 0.5 / s;
			quat[W] = (M(X,Y) - M(Y,X)) * s;
			quat[X] = (M(Z,X) + M(X,Z)) * s;
			quat[Y] = (M(Z,Y) + M(Y,Z)) * s;
		} else {
			s = sqrt( M(Y,Y) - (M(Z,Z)+M(X,X)) + 1.0 );
			quat[Y] = s * 0.5;
			s = 0.5 / s;
			quat[W] = (M(Z,X) - M(X,Z)) * s;
			quat[Z] = (M(Y,Z) + M(Z,Y)) * s;
			quat[X] = (M(Y,X) + M(X,Y)) * s;
		}
	} else {
		if( mat[ZZ] > mat[XX] )  {
			s = sqrt( M(Z,Z) - (M(X,X)+M(Y,Y)) + 1.0 );
			quat[Z] = s * 0.5;
			s = 0.5 / s;
			quat[W] = (M(X,Y) - M(Y,X)) * s;
			quat[X] = (M(Z,X) + M(X,Z)) * s;
			quat[Y] = (M(Z,Y) + M(Y,Z)) * s;
		} else {
			s = sqrt( M(X,X) - (M(Y,Y)+M(Z,Z)) + 1.0 );
			quat[X] = s * 0.5;
			s = 0.5 / s;
			quat[W] = (M(Y,Z) - M(Z,Y)) * s;
			quat[Y] = (M(X,Y) + M(Y,X)) * s;
			quat[Z] = (M(X,Z) + M(Z,X)) * s;
		}
	}
#undef M
}

/*
 *			Q U A T _ Q U A T 2 M A T
 *
 *  Convert Quaternion to Matrix.
 *
 * NB: This only works for UNIT quaternions.  We may get imaginary results
 *   otherwise.  We should normalize first (still yields same rotation).
 */
void
quat_quat2mat( mat, quat )
register mat_t	mat;
register quat_t	quat;
{
	quat_t	q;

	QMOVE( q, quat );	/* private copy */
	QUNITIZE( q );

	mat[0] = 1.0 - 2.0*q[Y]*q[Y] - 2.0*q[Z]*q[Z];
	mat[1] = 2.0*q[X]*q[Y] + 2.0*q[W]*q[Z];
	mat[2] = 2.0*q[X]*q[Z] - 2.0*q[W]*q[Y];
	mat[3] = 0.0;
	mat[4] = 2.0*q[X]*q[Y] - 2.0*q[W]*q[Z];
	mat[5] = 1.0 - 2.0*q[X]*q[X] - 2.0*q[Z]*q[Z];
	mat[6] = 2.0*q[Y]*q[Z] + 2.0*q[W]*q[X];
	mat[7] = 0.0;
	mat[8] = 2.0*q[X]*q[Z] + 2.0*q[W]*q[Y];
	mat[9] = 2.0*q[Y]*q[Z] - 2.0*q[W]*q[X];
	mat[10] = 1.0 - 2.0*q[X]*q[X] - 2.0*q[Y]*q[Y];
	mat[11] = 0.0;
	mat[12] = 0.0;
	mat[13] = 0.0;
	mat[14] = 0.0;
	mat[15] = 1.0;
}

/*
 *			Q U A T _ D I S T A N C E
 *
 * Gives the euclidean distance between two quaternions.
 */
double
quat_distance( q1, q2 )
quat_t	q1, q2;
{
	quat_t	qtemp;

	QSUB2( qtemp, q1, q2 );
	return( QMAGNITUDE( qtemp ) );
}

/*
 *			Q U A T _ D O U B L E
 *
 * Gives the quaternion point representing twice the rotation
 *   from q1 to q2.
 *   Needed for patching Bezier curves together.
 *   A rather poor name admittedly.
 */
void
quat_double( qout, q1, q2 )
quat_t	qout, q1, q2;
{
	quat_t	qtemp;
	double	scale;

	scale = 2.0 * QDOT( q1, q2 );
	QSCALE( qtemp, q2, scale );
	QSUB2( qout, qtemp, q1 );
	QUNITIZE( qout );
}

/*
 *			Q U A T _ B I S E C T
 *
 * Gives the bisector of quaternions q1 and q2.
 * (Could be done with quat_slerp and factor 0.5)
 * [I believe they must be unit quaternions this to work]
 */
void
quat_bisect( qout, q1, q2 )
quat_t	qout, q1, q2;
{
	QADD2( qout, q1, q2 );
	QUNITIZE( qout );
}

/*
 *			Q U A T _ S L E R P
 *
 * Do Spherical Linear Interpolation between two unit quaternions
 *  by the given factor.
 *
 * As f goes from 0 to 1, qout goes from q1 to q2.
 * Code based on code by Ken Shoemake
 */
void
quat_slerp( qout, q1, q2, f )
quat_t	qout, q1, q2;
double	f;
{
	double		omega;
	double		cos_omega;
	double		invsin;
	register double	s1, s2;

	cos_omega = QDOT( q1, q2 );
	if( (1.0 + cos_omega) > 1.0e-5 )  {
		/* cos_omega > -0.99999 */
		if( (1.0 - cos_omega) > 1.0e-5 )  {
			/* usual case */
			omega = acos(cos_omega);	/* XXX atan2? */
			invsin = 1.0 / sin(omega);
			s1 = sin( (1.0-f)*omega ) * invsin;
			s2 = sin( f*omega ) * invsin;
		} else {
			/*
			 *  cos_omega > 0.99999
			 * The ends are very close to each other,
			 * use linear interpolation, to avoid divide-by-zero
			 */
			s1 = 1.0 - f;
			s2 = f;
		}
		QBLEND2( qout, s1, q1, s2, q2 );
	} else {
		/*
		 *  cos_omega == -1, omega = PI.
		 *  The ends are nearly opposite, 180 degrees (PI) apart.
		 */
		/* (I have no idea what permuting the elements accomplishes,
		 * perhaps it creates a perpendicular? */
		qout[X] = -q1[Y];
		qout[Y] =  q1[X];
		qout[Z] = -q1[W];
		s1 = sin( (0.5-f) * PI );
		s2 = sin( f * PI );
		VBLEND2( qout, s1, q1, s2, qout );
		qout[W] =  q1[Z];
	}
}

/*
 *			Q U A T _ S B E R P
 *
 * Spherical Bezier Interpolate between four quaternions by amount f.
 * These are intended to be used as start and stop quaternions along
 *   with two control quaternions chosen to match spline segments with
 *   first order continuity.
 *
 *  Uses the method of successive bisection.
 */
void
quat_sberp( qout, q1, qa, qb, q2, f )
quat_t	qout, q1, qa, qb, q2;
double	f;
{
	quat_t	p1, p2, p3, p4, p5;

	/* Interp down the three segments */
	quat_slerp( p1, q1, qa, f );
	quat_slerp( p2, qa, qb, f );
	quat_slerp( p3, qb, q2, f );

	/* Interp down the resulting two */
	quat_slerp( p4, p1, p2, f );
	quat_slerp( p5, p2, p3, f );

	/* Interp this segment for final quaternion */
	quat_slerp( qout, p4, p5, f );
}

/*
 *			Q U A T _ M A K E _ N E A R E S T
 *
 *  Set the quaternion q1 to the quaternion which yields the
 *   smallest rotation from q2 (of the two versions of q1 which
 *   produce the same orientation).
 *
 * Note that smallest euclidian distance implies smallest great
 *   circle distance as well (since surface is convex).
 */
void
quat_make_nearest( q1, q2 )
quat_t	q1, q2;
{
	quat_t	qtemp;
	double	d1, d2;

	QSCALE( qtemp, q1, -1.0 );
	d1 = quat_distance( q1, q2 );
	d2 = quat_distance( qtemp, q2 );

	/* Choose smallest distance */
	if( d2 < d1 ) {
		QMOVE( q1, qtemp );
	}
}

/*
 *			Q U A T _ P R I N T
 */
/* DEBUG ROUTINE */
void
quat_print( title, quat )
char	*title;
quat_t	quat;
{
	int	i;
	vect_t	axis;

	fprintf( stderr, "QUATERNION: %s\n", title );
	for( i = 0; i < 4; i++ )
		fprintf( stderr, "%8f  ", quat[i] );
	fprintf( stderr, "\n" );

	fprintf( stderr, "rot_angle = %8f deg", RTODEG * 2.0 * acos( quat[W] ) );
	VMOVE( axis, quat );
	VUNITIZE( axis );
	fprintf( stderr, ", Axis = (%f, %f, %f)\n",
		axis[X], axis[Y], axis[Z] );
}

/*
 *			Q U A T _ E X P
 *
 *  Exponentiate a quaternion, assuming that the scalar part is 0.
 *  Code by Ken Shoemake.
 */
void
quat_exp( out, in )
quat_t	out, in;
{
	FAST fastf_t	theta;
	FAST fastf_t	scale;

	if( (theta = MAGNITUDE( in )) > VDIVIDE_TOL )
		scale = sin(theta)/theta;
	else
		scale = 1.0;

	VSCALE( out, in, scale );
	out[W] = cos(theta);
}

/*
 *			Q U A T _ L O G
 *
 *  Take the natural logarithm of a unit quaternion.
 *  Code by Ken Shoemake.
 */
void
quat_log( out, in )
quat_t	out, in;
{
	FAST fastf_t	theta;
	FAST fastf_t	scale;

	if( (scale = MAGNITUDE(in)) > VDIVIDE_TOL )  {
		theta = atan2( scale, in[W] );
		scale = theta/scale;
	}

	VSCALE( out, in, scale );
	out[W] = 0.0;
}
@


11.2
log
@Added missing return type in function declaration
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/qmath.c,v 11.1 1995/01/04 09:58:31 mike Rel4_4 gdurf $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/qmath.c,v 10.2 94/08/10 19:42:01 gdurf Exp $ (BRL)";
d310 1
@


10.2
log
@added include of conf.h.
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/qmath.c,v 10.1 1991/10/12 06:40:57 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/qmath.c,v 1.5 91/07/10 23:49:33 mike Exp $ (BRL)";
d48 2
d55 3
d59 1
@


1.5
log
@Expanded all the subscripts to inline constants, for
better efficiency.
Note that the 1985 formulation added bizzare twist when az=90 degrees;
(because w**2 was close to zero), while this formulation seems stable.
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/qmath.c,v 1.4 91/07/10 23:41:52 mike Exp $ (BRL)";
@


1.4
log
@Changed from Shoemake's 1985 algorithm to 1989 version for mat2quat.
Prevented quat2mat from inadvertently unitizing callers arg.
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/qmath.c,v 1.3 91/06/25 16:11:06 phil Exp $ (BRL)";
a67 1
	int		i,j,k;
d72 2
d88 6
a93 1
			i = Z; j = X; k = Y;
d95 6
a100 1
			i = Y; j = Z; k = X;
d104 6
a109 1
			i = Z; j = X; k = Y;
d111 6
a116 1
			i = X; j = Y; k = Z;
a118 8

#define M(a,b)		mat[4*(a)+(b)]
	s = sqrt( M(i,i) - (M(j,j)+M(k,k)) + 1.0 );
	quat[i] = s * 0.5;
	s = 0.5 / s;
	quat[W] = (M(j,k) - M(k,j)) * s;
	quat[j] = (M(i,j) + M(j,i)) * s;
	quat[k] = (M(i,k) + M(k,i)) * s;
@


1.3
log
@Two lines of code in the wrong order (matrix -> quat conversion)
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/qmath.c,v 1.2 89/08/12 07:32:10 mike Exp $ (BRL)";
d66 1
a66 1
	fastf_t	w2, x2, y2;
d68 1
d70 8
a77 4
	w2 = 0.25 * (1.0 + mat[0] + mat[5] + mat[10]);
	if( w2 > VDIVIDE_TOL ) {
		quat[W] = sqrt( w2 );
		s = 0.25 / quat[W];
d84 13
a96 8
	quat[W] = 0.0;
	x2 = -0.5 * (mat[5] + mat[10]);
	if( x2 > VDIVIDE_TOL ) {
		quat[X] = sqrt( x2 );
		s = 0.5 / quat[X];
		quat[Y] = mat[1] * s;
		quat[Z] = mat[2] * s;
		return;
d98 9
a106 10
	quat[X] = 0.0;
	y2 = 0.5 * (1.0 - mat[10]);
	if( y2 > VDIVIDE_TOL ) {
		quat[Y] = sqrt( y2 );
		quat[Z] = mat[6] / (2.0 * quat[Y]);
		return;
	}
	quat[Y] = 0.0;
	quat[Z] = 1.0;
	return;
d118 1
a118 1
quat_quat2mat( mat, q )
d120 1
a120 1
register quat_t	q;
d122 3
@


1.2
log
@Added some more functions.
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: qmath.c,v 1.1 89/08/12 05:02:22 mike Locked $ (BRL)";
d82 1
a83 1
		quat[X] = sqrt( x2 );
@


1.1
log
@Initial revision
@
text
@a28 1
 *  Note: We may wish to make a quat_t synonymous with hvect_t for clarity.
d32 3
d45 1
a45 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d53 2
a54 1
#define	RTODEG	(180.0/3.1415925635898)
d61 1
d63 2
a64 2
quat_t	quat;
mat_t	mat;
d80 1
a80 1
	x2 = (-1.0 / 2.0) * (mat[5] + mat[10]);
d82 1
d84 2
a85 2
		quat[Y] = mat[1] / (2.0 * quat[X]);
		quat[Z] = mat[2] / (2.0 * quat[X]);
d89 1
a89 1
	y2 = (1.0 / 2.0) * (1.0 - mat[10]);
d108 1
d110 2
a111 2
mat_t	mat;
quat_t	q;
d156 1
d173 1
a173 1
 * (Could be done with qslerp and factor 0.5)
d176 1
d180 1
a180 6
	quat_t	qtemp;
	double	scale;

	QADD2( qtemp, q1, q2 );
	scale = QMAGNITUDE( qtemp );
	QSCALE( qout, qtemp, scale );
d187 1
a187 1
 * Do Spherical Linear Interpolation between two quaternion
d190 2
a191 1
 * I'm SURE this can be done better.
d198 4
a201 2
	double	theta, factor;
	quat_t	qtemp1, qtemp2;
d203 34
a236 17
	QUNITIZE( q1 );
	QUNITIZE( q2 );
	theta = acos( QDOT( q1, q2 ) );

	if( fabs(theta) < VDIVIDE_TOL )
		factor = 1.0;
	else
		factor = sin( theta * (1.0 - f) ) / sin( theta );
	QSCALE( qtemp1, q1, factor );

	if( fabs(theta) < VDIVIDE_TOL )
		factor = 0.0;
	else
		factor = sin( theta * f ) / sin( theta );
	QSCALE( qtemp2, q2, factor );

	QADD2( qout, qtemp1, qtemp2 );
d249 1
d272 1
a272 1
 * Test routine to set the quaternion q1 to that which yields the
d285 1
a286 1
	QSCALE( qtemp, q1, -1.0 );
d299 1
d312 1
a312 1
	fprintf( stderr, "rot_angle = %8f deg", RTODEG * 2.0 * acos( quat[3] ) );
d317 44
@
