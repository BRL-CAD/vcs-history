head	11.38;
access;
symbols
	ansi-20040405-merged:11.34.2.3
	postmerge-20040405-ansi:11.36
	premerge-20040404-ansi:11.35
	postmerge-autoconf:11.35
	autoconf-freeze:11.34.10.2
	premerge-autoconf:11.35
	ansi-20040316-freeze:11.34.2.2
	postmerge-20040315-windows:11.35
	premerge-20040315-windows:11.35
	windows-20040315-freeze:11.34.4.1
	autoconf-20031203:11.34
	autoconf-20031202:11.34
	autoconf-branch:11.34.0.10
	phong-branch:11.34.0.8
	photonmap-branch:11.34.0.6
	rel-6-1-DP:11.34
	windows-branch:11.34.0.4
	rel-6-0-2:11.32
	ansi-branch:11.34.0.2
	rel-6-0-1-branch:11.32.0.2
	hartley-6-0-post:11.33
	hartley-6-0-pre:11.32
	rel-6-0-1:11.32
	rel-6-0:11.32
	rel-5-4:11.17.2.3
	offsite-5-3-pre:11.29
	rel-5-3:11.17.2.3
	rel-5-2:11.17
	rel-5-1-branch:11.17.0.2
	rel-5-1:11.17
	rel-5-0:11.11
	rel-5-0-beta:11.10
	rel-4-5:11.9
	ctj-4-5-post:11.9
	ctj-4-5-pre:11.9
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1
	rt-2:2.1
	rt:1.1;
locks; strict;
comment	@ * @;


11.38
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	11.37;

11.37
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.36;

11.36
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.35;

11.35
date	2004.02.02.17.39.20;	author morrison;	state Exp;
branches;
next	11.34;

11.34
date	2002.08.20.17.07.59;	author jra;	state Exp;
branches
	11.34.2.1
	11.34.4.1
	11.34.10.1;
next	11.33;

11.33
date	2002.08.15.20.55.11;	author hartley;	state Exp;
branches;
next	11.32;

11.32
date	2001.10.02.19.24.29;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	2001.04.20.22.29.44;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2001.03.31.01.57.07;	author morrison;	state Exp;
branches;
next	11.29;

11.29
date	2001.01.29.19.56.54;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	2001.01.29.19.50.28;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	2000.10.19.16.08.39;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	2000.10.18.18.10.34;	author butler;	state Exp;
branches;
next	11.25;

11.25
date	2000.08.21.02.02.30;	author butler;	state Exp;
branches;
next	11.24;

11.24
date	2000.07.13.02.36.26;	author cjohnson;	state Exp;
branches;
next	11.23;

11.23
date	2000.07.10.23.01.31;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.06.30.15.38.02;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.06.30.15.29.46;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.06.27.14.44.55;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.06.26.19.22.41;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	2000.06.26.17.37.20;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.04.12.02.34.32;	author mike;	state Exp;
branches
	11.17.2.1;
next	11.16;

11.16
date	2000.03.28.21.27.51;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.12.22.02.17.59;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	99.11.26.21.46.45;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	99.11.24.23.12.07;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	99.11.17.02.41.57;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.07.02.22.19.22;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.05.27.19.10.37;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	97.06.17.19.24.43;	author gdurf;	state Exp;
branches;
next	11.8;

11.8
date	96.08.16.20.04.44;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	96.07.12.17.12.11;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.05.08.15.31.06;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.11.30.16.16.23;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.11.30.15.43.44;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.11.30.04.07.24;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.11.29.23.51.09;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.35;	author mike;	state Rel4_4;
branches;
next	10.10;

10.10
date	94.09.30.16.24.32;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.09.13.17.10.45;	author jra;	state Exp;
branches;
next	10.8;

10.8
date	94.09.13.15.49.20;	author jra;	state Exp;
branches;
next	10.7;

10.7
date	94.09.09.11.03.47;	author jra;	state Exp;
branches;
next	10.6;

10.6
date	94.09.08.16.26.54;	author jra;	state Exp;
branches;
next	10.5;

10.5
date	94.08.10.18.27.41;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.06.22.03.09.50;	author butler;	state Exp;
branches;
next	10.3;

10.3
date	93.11.18.01.44.02;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.07.20.15.33.34;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.15;	author mike;	state Rel4_0;
branches;
next	9.33;

9.33
date	91.09.20.23.05.21;	author butler;	state Exp;
branches;
next	9.32;

9.32
date	91.09.13.13.20.56;	author mmark;	state Exp;
branches;
next	9.31;

9.31
date	91.07.11.15.34.01;	author jehunt;	state Exp;
branches;
next	9.30;

9.30
date	91.06.30.00.10.48;	author mike;	state Exp;
branches;
next	9.29;

9.29
date	91.06.22.22.30.21;	author mike;	state Exp;
branches;
next	9.28;

9.28
date	91.06.12.20.57.41;	author mike;	state Exp;
branches;
next	9.27;

9.27
date	91.05.18.03.00.52;	author mike;	state Exp;
branches;
next	9.26;

9.26
date	91.04.01.19.59.36;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	91.02.07.20.32.19;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	91.01.28.23.53.09;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	91.01.26.03.14.45;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.01.25.21.52.05;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	91.01.25.21.18.48;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.01.25.20.35.34;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.01.25.16.04.42;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.01.15.23.45.45;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	90.10.06.02.05.11;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	90.05.21.13.12.50;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	90.05.18.07.25.36;	author butler;	state Exp;
branches;
next	9.14;

9.14
date	90.05.07.20.59.58;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.05.04.17.42.11;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.05.04.17.13.52;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.05.04.15.53.00;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.05.02.05.42.43;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.05.01.05.21.12;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.05.01.04.59.30;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.04.28.02.08.51;	author butler;	state Exp;
branches;
next	9.6;

9.6
date	90.03.15.01.58.18;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.03.14.22.36.53;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.03.14.21.21.10;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.03.14.15.05.47;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.03.03.05.48.31;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.11;	author mike;	state Rel3_5;
branches;
next	8.9;

8.9
date	89.04.27.23.08.05;	author phil;	state Exp;
branches;
next	8.8;

8.8
date	89.04.17.17.19.08;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.04.11.13.01.28;	author phil;	state Exp;
branches;
next	8.6;

8.6
date	89.04.08.03.35.01;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.04.08.02.48.18;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.02.17.11.02.17;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.09.04.54.19;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.02.37;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.31.13;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.05.14.00.01.02;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.06.05.36.31;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.33.24;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.55.43;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.11.23;	author mike;	state Rel;
branches;
next	4.10;

4.10
date	87.05.30.06.00.47;	author phil;	state Exp;
branches;
next	4.9;

4.9
date	87.05.26.21.54.57;	author phil;	state Exp;
branches;
next	4.8;

4.8
date	87.04.28.00.27.35;	author phil;	state Exp;
branches;
next	4.7;

4.7
date	87.03.24.01.03.50;	author phil;	state Exp;
branches;
next	4.6;

4.6
date	87.03.23.23.42.05;	author mike;	state Exp;
branches;
next	4.5;

4.5
date	87.03.17.16.17.26;	author phil;	state Exp;
branches;
next	4.4;

4.4
date	87.03.10.23.42.47;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.12.22.11.12;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.28.21.00.04;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.45.07;	author mike;	state Rel1;
branches;
next	3.4;

3.4
date	86.12.24.08.05.41;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.08.12.04.15.35;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.24.06.09.59;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.11.01.32.00;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.33.03;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	86.06.09.21.50.24;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.09.11.01.43.45;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.05.02.17.09;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.04.09;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	85.07.30.05.52.33;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	85.03.25.11.35.00;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	85.01.31.20.16.38;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	85.01.31.17.02.19;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	84.12.17.16.09.13;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	84.11.24.02.59.55;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	84.11.23.20.54.05;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	84.11.20.20.14.24;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	84.11.16.23.58.20;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	84.11.16.06.28.21;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	84.11.15.21.47.42;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	84.10.19.01.38.14;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	84.05.01.06.39.37;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.04.26.07.51.32;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.04.26.05.37.01;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.04.18.02.20.11;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.04.02.19.55.57;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.04.02.16.41.52;	author mike;	state Exp;
branches;
next	;

11.17.2.1
date	2000.10.19.16.08.01;	author bparker;	state Exp;
branches;
next	11.17.2.2;

11.17.2.2
date	2001.01.29.19.51.07;	author jra;	state Exp;
branches;
next	11.17.2.3;

11.17.2.3
date	2001.01.29.19.56.08;	author jra;	state Exp;
branches;
next	;

11.34.2.1
date	2002.09.19.18.01.33;	author morrison;	state Exp;
branches;
next	11.34.2.2;

11.34.2.2
date	2003.02.11.00.05.44;	author morrison;	state Exp;
branches;
next	11.34.2.3;

11.34.2.3
date	2004.03.17.21.18.46;	author morrison;	state Exp;
branches;
next	;

11.34.4.1
date	2004.03.11.23.43.37;	author morrison;	state Exp;
branches;
next	;

11.34.10.1
date	2004.02.12.18.37.40;	author erikg;	state Exp;
branches;
next	11.34.10.2;

11.34.10.2
date	2004.03.15.14.07.18;	author erikg;	state Exp;
branches;
next	;


desc
@Intersect Ray with ELLG
@


11.38
log
@moved to src/
@
text
@/*
 *			G _ E L L . C
 *
 *  Purpose -
 *	Intersect a ray with a Generalized Ellipsoid
 *
 *  Authors -
 *	Edwin O. Davisson	(Analysis)
 *	Michael John Muuss	(Programming)
 *	Peter F. Stiller	(Curvature Analysis)
 *	Phillip Dykstra		(RPPs, Curvature)
 *	Dave Becker		(Vectorization)
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSell[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_ell.c,v 11.37 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "rtgeom.h"
#include "./debug.h"

RT_EXTERN(int rt_sph_prep, (struct soltab *stp, struct rt_db_internal *ip,
	struct rt_i *rtip));

const struct bu_structparse rt_ell_parse[] = {
    { "%f", 3, "V", offsetof(struct rt_ell_internal, v[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "A", offsetof(struct rt_ell_internal, a[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "B", offsetof(struct rt_ell_internal, b[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "C", offsetof(struct rt_ell_internal, c[X]), BU_STRUCTPARSE_FUNC_NULL },
    { {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
 };

static void  nmg_sphere_face_snurb(struct faceuse *fu, const matp_t m);

/*
 *  Algorithm:
 *  
 *  Given V, A, B, and C, there is a set of points on this ellipsoid
 *  
 *  { (x,y,z) | (x,y,z) is on ellipsoid defined by V, A, B, C }
 *  
 *  Through a series of Affine Transformations, this set will be
 *  transformed into a set of points on a unit sphere at the origin
 *  
 *  { (x',y',z') | (x',y',z') is on Sphere at origin }
 *  
 *  The transformation from X to X' is accomplished by:
 *  
 *  X' = S(R( X - V ))
 *  
 *  where R(X) =  ( A/(|A|) )
 *  		 (  B/(|B|)  ) . X
 *  		  ( C/(|C|) )
 *  
 *  and S(X) =	 (  1/|A|   0     0   )
 *  		(    0    1/|B|   0    ) . X
 *  		 (   0      0   1/|C| )
 *  
 *  To find the intersection of a line with the ellipsoid, consider
 *  the parametric line L:
 *  
 *  	L : { P(n) | P + t(n) . D }
 *  
 *  Call W the actual point of intersection between L and the ellipsoid.
 *  Let W' be the point of intersection between L' and the unit sphere.
 *  
 *  	L' : { P'(n) | P' + t(n) . D' }
 *  
 *  W = invR( invS( W' ) ) + V
 *  
 *  Where W' = k D' + P'.
 *  
 *  Let dp = D' dot P'
 *  Let dd = D' dot D'
 *  Let pp = P' dot P'
 *  
 *  and k = [ -dp +/- sqrt( dp*dp - dd * (pp - 1) ) ] / dd
 *  which is constant.
 *  
 *  Now, D' = S( R( D ) )
 *  and  P' = S( R( P - V ) )
 *  
 *  Substituting,
 *  
 *  W = V + invR( invS[ k *( S( R( D ) ) ) + S( R( P - V ) ) ] )
 *    = V + invR( ( k * R( D ) ) + R( P - V ) )
 *    = V + k * D + P - V
 *    = k * D + P
 *  
 *  Note that ``k'' is constant, and is the same in the formulations
 *  for both W and W'.
 *  
 *  NORMALS.  Given the point W on the ellipsoid, what is the vector
 *  normal to the tangent plane at that point?
 *  
 *  Map W onto the unit sphere, ie:  W' = S( R( W - V ) ).
 *  
 *  Plane on unit sphere at W' has a normal vector of the same value(!).
 *  N' = W'
 *  
 *  The plane transforms back to the tangent plane at W, and this
 *  new plane (on the ellipsoid) has a normal vector of N, viz:
 *  
 *  N = inverse[ transpose( inverse[ S o R ] ) ] ( N' )
 *
 *  because if H is perpendicular to plane Q, and matrix M maps from
 *  Q to Q', then inverse[ transpose(M) ] (H) is perpendicular to Q'.
 *  Here, H and Q are in "prime space" with the unit sphere.
 *  [Somehow, the notation here is backwards].
 *  So, the mapping matrix M = inverse( S o R ), because
 *  S o R maps from normal space to the unit sphere.
 *
 *  N = inverse[ transpose( inverse[ S o R ] ) ] ( N' )
 *    = inverse[ transpose(invR o invS) ] ( N' )
 *    = inverse[ transpose(invS) o transpose(invR) ] ( N' )
 *    = inverse[ inverse(S) o R ] ( N' )
 *    = invR o S ( N' )
 *
 *    = invR o S ( W' )
 *    = invR( S( S( R( W - V ) ) ) )
 *
 *  because inverse(R) = transpose(R), so R = transpose( invR ),
 *  and S = transpose( S ).
 *
 *  Note that the normal vector N produced above will not have unit length.
 */

struct ell_specific {
	vect_t	ell_V;		/* Vector to center of ellipsoid */
	vect_t	ell_Au;		/* unit-length A vector */
	vect_t	ell_Bu;
	vect_t	ell_Cu;
	vect_t	ell_invsq;	/* [ 1/(|A|**2), 1/(|B|**2), 1/(|C|**2) ] */
	mat_t	ell_SoR;	/* Scale(Rot(vect)) */
	mat_t	ell_invRSSR;	/* invRot(Scale(Scale(Rot(vect)))) */
};
#define ELL_NULL	((struct ell_specific *)0)

/*
 *  			R T _ E L L _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid ellipsoid, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	ELL is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct ell_specific is created, and it's address is stored in
 *  	stp->st_specific for use by rt_ell_shot().
 */
int
rt_ell_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	register struct ell_specific *ell;
	struct rt_ell_internal	*eip;
	LOCAL fastf_t	magsq_a, magsq_b, magsq_c;
	LOCAL mat_t	R;
	LOCAL mat_t	Rinv;
	LOCAL mat_t	SS;
	LOCAL mat_t	mtemp;
	LOCAL vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
	LOCAL vect_t	w1, w2, P;	/* used for bounding RPP */
	LOCAL fastf_t	f;

	eip = (struct rt_ell_internal *)ip->idb_ptr;
	RT_ELL_CK_MAGIC(eip);

	/*
	 *  For a fast way out, hand this solid off to the SPH routine.
	 *  If it takes it, then there is nothing to do, otherwise
	 *  the solid is an ELL.
	 */
	if( rt_sph_prep( stp, ip, rtip ) == 0 ) {
	  return(0);		/* OK */
	}

	/* Validate that |A| > 0, |B| > 0, |C| > 0 */
	magsq_a = MAGSQ( eip->a );
	magsq_b = MAGSQ( eip->b );
	magsq_c = MAGSQ( eip->c );

	if( magsq_a < rtip->rti_tol.dist || magsq_b < rtip->rti_tol.dist || magsq_c < rtip->rti_tol.dist ) {
		bu_log("sph(%s):  zero length A(%g), B(%g), or C(%g) vector\n",
			stp->st_name, magsq_a, magsq_b, magsq_c );
		return(1);		/* BAD */
	}

	/* Create unit length versions of A,B,C */
	f = 1.0/sqrt(magsq_a);
	VSCALE( Au, eip->a, f );
	f = 1.0/sqrt(magsq_b);
	VSCALE( Bu, eip->b, f );
	f = 1.0/sqrt(magsq_c);
	VSCALE( Cu, eip->c, f );

	/* Validate that A.B == 0, B.C == 0, A.C == 0 (check dir only) */
	f = VDOT( Au, Bu );
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
		bu_log("ell(%s):  A not perpendicular to B, f=%f\n",stp->st_name, f);
		return(1);		/* BAD */
	}
	f = VDOT( Bu, Cu );
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
		bu_log("ell(%s):  B not perpendicular to C, f=%f\n",stp->st_name, f);
		return(1);		/* BAD */
	}
	f = VDOT( Au, Cu );
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
		bu_log("ell(%s):  A not perpendicular to C, f=%f\n",stp->st_name, f);
		return(1);		/* BAD */
	}

	/* Solid is OK, compute constant terms now */
	BU_GETSTRUCT( ell, ell_specific );
	stp->st_specific = (genptr_t)ell;

	VMOVE( ell->ell_V, eip->v );

	VSET( ell->ell_invsq, 1.0/magsq_a, 1.0/magsq_b, 1.0/magsq_c );
	VMOVE( ell->ell_Au, Au );
	VMOVE( ell->ell_Bu, Bu );
	VMOVE( ell->ell_Cu, Cu );

	MAT_IDN( ell->ell_SoR );
	MAT_IDN( R );

	/* Compute R and Rinv matrices */
	VMOVE( &R[0], Au );
	VMOVE( &R[4], Bu );
	VMOVE( &R[8], Cu );
	bn_mat_trn( Rinv, R );			/* inv of rot mat is trn */

	/* Compute SoS (Affine transformation) */
	MAT_IDN( SS );
	SS[ 0] = ell->ell_invsq[0];
	SS[ 5] = ell->ell_invsq[1];
	SS[10] = ell->ell_invsq[2];

	/* Compute invRSSR */
	bn_mat_mul( mtemp, SS, R );
	bn_mat_mul( ell->ell_invRSSR, Rinv, mtemp );

	/* Compute SoR */
	VSCALE( &ell->ell_SoR[0], eip->a, ell->ell_invsq[0] );
	VSCALE( &ell->ell_SoR[4], eip->b, ell->ell_invsq[1] );
	VSCALE( &ell->ell_SoR[8], eip->c, ell->ell_invsq[2] );

	/* Compute bounding sphere */
	VMOVE( stp->st_center, eip->v );
	f = magsq_a;
	if( magsq_b > f )
		f = magsq_b;
	if( magsq_c > f )
		f = magsq_c;
	stp->st_aradius = stp->st_bradius = sqrt(f);

	/* Compute bounding RPP */
	VSET( w1, magsq_a, magsq_b, magsq_c );

	/* X */
	VSET( P, 1.0, 0, 0 );		/* bounding plane normal */
	MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
	VELMUL( w2, w2, w2 );		/* square each term */
	f = VDOT( w1, w2 );
	f = sqrt(f);
	stp->st_min[X] = ell->ell_V[X] - f;	/* V.P +/- f */
	stp->st_max[X] = ell->ell_V[X] + f;

	/* Y */
	VSET( P, 0, 1.0, 0 );		/* bounding plane normal */
	MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
	VELMUL( w2, w2, w2 );		/* square each term */
	f = VDOT( w1, w2 );
	f = sqrt(f);
	stp->st_min[Y] = ell->ell_V[Y] - f;	/* V.P +/- f */
	stp->st_max[Y] = ell->ell_V[Y] + f;

	/* Z */
	VSET( P, 0, 0, 1.0 );		/* bounding plane normal */
	MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
	VELMUL( w2, w2, w2 );		/* square each term */
	f = VDOT( w1, w2 );
	f = sqrt(f);
	stp->st_min[Z] = ell->ell_V[Z] - f;	/* V.P +/- f */
	stp->st_max[Z] = ell->ell_V[Z] + f;

	return(0);			/* OK */
}

/*
 *			R T _ E L L _ P R I N T
 */
void
rt_ell_print(register const struct soltab *stp)
{
	register struct ell_specific *ell =
		(struct ell_specific *)stp->st_specific;

	VPRINT("V", ell->ell_V);
	bn_mat_print("S o R", ell->ell_SoR );
	bn_mat_print("invRSSR", ell->ell_invRSSR );
}

/*
 *  			R T _ E L L _ S H O T
 *  
 *  Intersect a ray with an ellipsoid, where all constant terms have
 *  been precomputed by rt_ell_prep().  If an intersection occurs,
 *  a struct seg will be acquired and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_ell_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct ell_specific *ell =
		(struct ell_specific *)stp->st_specific;
	register struct seg *segp;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL vect_t	xlated;		/* translated vector */
	LOCAL fastf_t	dp, dd;		/* D' dot P', D' dot D' */
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
	FAST fastf_t	root;		/* root of radical */

	/* out, Mat, vect */
	MAT4X3VEC( dprime, ell->ell_SoR, rp->r_dir );
	VSUB2( xlated, rp->r_pt, ell->ell_V );
	MAT4X3VEC( pprime, ell->ell_SoR, xlated );

	dp = VDOT( dprime, pprime );
	dd = VDOT( dprime, dprime );

	if( (root = dp*dp - dd * (VDOT(pprime,pprime)-1.0)) < 0 )
		return(0);		/* No hit */
	root = sqrt(root);

	RT_GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;
	if( (k1=(-dp+root)/dd) <= (k2=(-dp-root)/dd) )  {
		/* k1 is entry, k2 is exit */
		segp->seg_in.hit_dist = k1;
		segp->seg_out.hit_dist = k2;
	} else {
		/* k2 is entry, k1 is exit */
		segp->seg_in.hit_dist = k2;
		segp->seg_out.hit_dist = k1;
	}
	BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	return(2);			/* HIT */
}

#define RT_ELL_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ E L L _ V S H O T
 *
 *  This is the Becker vector version.
 */
void
rt_ell_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	register int    i;
	register struct ell_specific *ell;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL vect_t	xlated;		/* translated vector */
	LOCAL fastf_t	dp, dd;		/* D' dot P', D' dot D' */
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
	FAST fastf_t	root;		/* root of radical */

	/* for each ray/ellipse pair */
#	include "noalias.h"
	for(i = 0; i < n; i++){
#if !CRAY /* XXX currently prevents vectorization on cray */
	 	if (stp[i] == 0) continue; /* stp[i] == 0 signals skip ray */
#endif
		ell = (struct ell_specific *)stp[i]->st_specific;

		MAT4X3VEC( dprime, ell->ell_SoR, rp[i]->r_dir );
		VSUB2( xlated, rp[i]->r_pt, ell->ell_V );
		MAT4X3VEC( pprime, ell->ell_SoR, xlated );

		dp = VDOT( dprime, pprime );
		dd = VDOT( dprime, dprime );

		if( (root = dp*dp - dd * (VDOT(pprime,pprime)-1.0)) < 0 ) {
			RT_ELL_SEG_MISS(segp[i]);		/* No hit */
		}
	        else {
			root = sqrt(root);

			segp[i].seg_stp = stp[i];

			if( (k1=(-dp+root)/dd) <= (k2=(-dp-root)/dd) )  {
				/* k1 is entry, k2 is exit */
				segp[i].seg_in.hit_dist = k1;
				segp[i].seg_out.hit_dist = k2;
			} else {
				/* k2 is entry, k1 is exit */
				segp[i].seg_in.hit_dist = k2;
				segp[i].seg_out.hit_dist = k1;
			}
		}
	}
}

/*
 *  			R T _ E L L _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_ell_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct ell_specific *ell =
		(struct ell_specific *)stp->st_specific;
	LOCAL vect_t xlated;
	LOCAL fastf_t scale;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	VSUB2( xlated, hitp->hit_point, ell->ell_V );
	MAT4X3VEC( hitp->hit_normal, ell->ell_invRSSR, xlated );
	scale = 1.0 / MAGNITUDE( hitp->hit_normal );
	VSCALE( hitp->hit_normal, hitp->hit_normal, scale );

	/* tuck away this scale for the curvature routine */
	hitp->hit_vpriv[X] = scale;
}

/*
 *			R T _ E L L _ C U R V E
 *
 *  Return the curvature of the ellipsoid.
 */
void
rt_ell_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	register struct ell_specific *ell =
		(struct ell_specific *)stp->st_specific;
	vect_t	u, v;			/* basis vectors (with normal) */
	vect_t	vec1, vec2;		/* eigen vectors */
	vect_t	tmp;
	fastf_t	a, b, c, scale;

	/*
	 * choose a tangent plane coordinate system
	 *  (u, v, normal) form a right-handed triple
	 */
	bn_vec_ortho( u, hitp->hit_normal );
	VCROSS( v, hitp->hit_normal, u );

	/* get the saved away scale factor */
	scale = - hitp->hit_vpriv[X];

	/* find the second fundamental form */
	MAT4X3VEC( tmp, ell->ell_invRSSR, u );
	a = VDOT(u, tmp) * scale;
	b = VDOT(v, tmp) * scale;
	MAT4X3VEC( tmp, ell->ell_invRSSR, v );
	c = VDOT(v, tmp) * scale;

	bn_eigen2x2( &cvp->crv_c1, &cvp->crv_c2, vec1, vec2, a, b, c );
	VCOMB2( cvp->crv_pdir, vec1[X], u, vec1[Y], v );
	VUNITIZE( cvp->crv_pdir );
}

/*
 *  			R T _ E L L _ U V
 *  
 *  For a hit on the surface of an ELL, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_ell_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct ell_specific *ell =
		(struct ell_specific *)stp->st_specific;
	LOCAL vect_t work;
	LOCAL vect_t pprime;
	LOCAL fastf_t r;

	/* hit_point is on surface;  project back to unit sphere,
	 * creating a vector from vertex to hit point which always
	 * has length=1.0
	 */
	VSUB2( work, hitp->hit_point, ell->ell_V );
	MAT4X3VEC( pprime, ell->ell_SoR, work );
	/* Assert that pprime has unit length */

	/* U is azimuth, atan() range: -pi to +pi */
	uvp->uv_u = bn_atan2( pprime[Y], pprime[X] ) * bn_inv2pi;
	if( uvp->uv_u < 0 )
		uvp->uv_u += 1.0;
	/*
	 *  V is elevation, atan() range: -pi/2 to +pi/2,
	 *  because sqrt() ensures that X parameter is always >0
	 */
	uvp->uv_v = bn_atan2( pprime[Z],
		sqrt( pprime[X] * pprime[X] + pprime[Y] * pprime[Y]) ) *
		bn_invpi + 0.5;

	/* approximation: r / (circumference, 2 * pi * aradius) */
	r = ap->a_rbeam + ap->a_diverge * hitp->hit_dist;
	uvp->uv_du = uvp->uv_dv =
		bn_inv2pi * r / stp->st_aradius;
}

/*
 *			R T _ E L L _ F R E E
 */
void
rt_ell_free(register struct soltab *stp)
{
	register struct ell_specific *ell =
		(struct ell_specific *)stp->st_specific;

	bu_free( (char *)ell, "ell_specific" );
}

int
rt_ell_class(void)
{
	return(0);
}

/*
 *			R T _ E L L _ 1 6 P T S
 *
 * Also used by the TGC code
 */
#define ELLOUT(n)	ov+(n-1)*3
void
rt_ell_16pts(register fastf_t *ov,
	     register fastf_t *V,
	     fastf_t *A,
	     fastf_t *B)
{
	static fastf_t c, d, e, f,g,h;

	e = h = .92388;			/* cos(22.5) */
	c = d = .707107;		/* cos(45) */
	g = f = .382683;		/* cos(67.5) */

	/*
	 * For angle theta, compute surface point as
	 *
	 *	V  +  cos(theta) * A  + sin(theta) * B
	 *
	 * note that sin(theta) is cos(90-theta).
	 */

	VADD2( ELLOUT(1), V, A );
	VJOIN2( ELLOUT(2), V, e, A, f, B );
	VJOIN2( ELLOUT(3), V, c, A, d, B );
	VJOIN2( ELLOUT(4), V, g, A, h, B );
	VADD2( ELLOUT(5), V, B );
	VJOIN2( ELLOUT(6), V, -g, A, h, B );
	VJOIN2( ELLOUT(7), V, -c, A, d, B );
	VJOIN2( ELLOUT(8), V, -e, A, f, B );
	VSUB2( ELLOUT(9), V, A );
	VJOIN2( ELLOUT(10), V, -e, A, -f, B );
	VJOIN2( ELLOUT(11), V, -c, A, -d, B );
	VJOIN2( ELLOUT(12), V, -g, A, -h, B );
	VSUB2( ELLOUT(13), V, B );
	VJOIN2( ELLOUT(14), V, g, A, -h, B );
	VJOIN2( ELLOUT(15), V, c, A, -d, B );
	VJOIN2( ELLOUT(16), V, e, A, -f, B );
}

/*
 *			R T _ E L L _ P L O T
 */
int
rt_ell_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register int		i;
	struct rt_ell_internal	*eip;
	fastf_t top[16*3];
	fastf_t middle[16*3];
	fastf_t bottom[16*3];

	RT_CK_DB_INTERNAL(ip);
	eip = (struct rt_ell_internal *)ip->idb_ptr;
	RT_ELL_CK_MAGIC(eip);

	rt_ell_16pts( top, eip->v, eip->a, eip->b );
	rt_ell_16pts( bottom, eip->v, eip->b, eip->c );
	rt_ell_16pts( middle, eip->v, eip->a, eip->c );

	RT_ADD_VLIST( vhead, &top[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ )  {
		RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	RT_ADD_VLIST( vhead, &bottom[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ )  {
		RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	RT_ADD_VLIST( vhead, &middle[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ )  {
		RT_ADD_VLIST( vhead, &middle[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}
	return(0);
}

#if 0
static point_t	octa_verts[6] = {
	{ 1, 0, 0 },	/* XPLUS */
	{-1, 0, 0 },	/* XMINUS */
	{ 0, 1, 0 },	/* YPLUS */
	{ 0,-1, 0 },	/* YMINUS */
	{ 0, 0, 1 },	/* ZPLUS */
	{ 0, 0,-1 }	/* ZMINUS */
};

#define XPLUS 0
#define XMIN  1
#define YPLUS 2
#define YMIN  3
#define ZPLUS 4
#define ZMIN  5
#endif

/* Vertices of a unit octahedron */
/* These need to be organized properly to give reasonable normals */
/* static struct usvert {
 * 	int	a;
 * 	int	b;
 * 	int	c;
 * } octahedron[8] = {
 *     { XPLUS, ZPLUS, YPLUS },
 *     { YPLUS, ZPLUS, XMIN  },
 *     { XMIN , ZPLUS, YMIN  },
 *     { YMIN , ZPLUS, XPLUS },
 *     { XPLUS, YPLUS, ZMIN  },
 *     { YPLUS, XMIN , ZMIN  },
 *     { XMIN , YMIN , ZMIN  },
 *     { YMIN , XPLUS, ZMIN  }
 * };
 */
struct ell_state {
	struct shell	*s;
	struct rt_ell_internal	*eip;
	mat_t		invRinvS;
	mat_t		invRoS;
	fastf_t		theta_tol;
};

struct ell_vert_strip {
	int		nverts_per_strip;
	int		nverts;
	struct vertex	**vp;
	vect_t		*norms;
	int		nfaces;
	struct faceuse	**fu;
};

/*
 *			R T _ E L L _ T E S S
 *
 *  Tessellate an ellipsoid.
 *
 *  The strategy is based upon the approach of Jon Leech 3/24/89,
 *  from program "sphere", which generates a polygon mesh
 *  approximating a sphere by
 *  recursive subdivision. First approximation is an octahedron;
 *  each level of refinement increases the number of polygons by
 *  a factor of 4.
 *  Level 3 (128 polygons) is a good tradeoff if gouraud
 *  shading is used to render the database.
 *
 *  At the start, points ABC lie on surface of the unit sphere.
 *  Pick DEF as the midpoints of the three edges of ABC.
 *  Normalize the new points to lie on surface of the unit sphere.
 *
 *	  1
 *	  B
 *	 /\
 *    3 /  \ 4
 *    D/____\E
 *    /\    /\
 *   /	\  /  \
 *  /____\/____\
 * A      F     C
 * 0      5     2
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_ell_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL mat_t	R;
	LOCAL mat_t	S;
	LOCAL mat_t	invR;
	LOCAL mat_t	invS;
	LOCAL vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
	LOCAL fastf_t	Alen, Blen, Clen;
	LOCAL fastf_t	invAlen, invBlen, invClen;
	LOCAL fastf_t	magsq_a, magsq_b, magsq_c;
	LOCAL fastf_t	f;
	struct ell_state	state;
	register int		i;
	fastf_t		radius;
	int		nsegs;
	int		nstrips;
	struct ell_vert_strip	*strips;
	int		j;
	struct vertex		**vertp[4];
	int	faceno;
	int	stripno;
	int	boff;		/* base offset */
	int	toff;		/* top offset */
	int	blim;		/* base subscript limit */
	int	tlim;		/* top subscrpit limit */
	fastf_t	rel;		/* Absolutized relative tolerance */

	RT_CK_DB_INTERNAL(ip);
	state.eip = (struct rt_ell_internal *)ip->idb_ptr;
	RT_ELL_CK_MAGIC(state.eip);

	/* Validate that |A| > 0, |B| > 0, |C| > 0 */
	magsq_a = MAGSQ( state.eip->a );
	magsq_b = MAGSQ( state.eip->b );
	magsq_c = MAGSQ( state.eip->c );
	if( magsq_a < tol->dist || magsq_b < tol->dist || magsq_c < tol->dist ) {
		bu_log("rt_ell_tess():  zero length A, B, or C vector\n");
		return(-2);		/* BAD */
	}

	/* Create unit length versions of A,B,C */
	invAlen = 1.0/(Alen = sqrt(magsq_a));
	VSCALE( Au, state.eip->a, invAlen );
	invBlen = 1.0/(Blen = sqrt(magsq_b));
	VSCALE( Bu, state.eip->b, invBlen );
	invClen = 1.0/(Clen = sqrt(magsq_c));
	VSCALE( Cu, state.eip->c, invClen );

	/* Validate that A.B == 0, B.C == 0, A.C == 0 (check dir only) */
	f = VDOT( Au, Bu );
	if( ! NEAR_ZERO(f, tol->dist) )  {
		bu_log("ell():  A not perpendicular to B, f=%f\n", f);
		return(-3);		/* BAD */
	}
	f = VDOT( Bu, Cu );
	if( ! NEAR_ZERO(f, tol->dist) )  {
		bu_log("ell():  B not perpendicular to C, f=%f\n", f);
		return(-3);		/* BAD */
	}
	f = VDOT( Au, Cu );
	if( ! NEAR_ZERO(f, tol->dist) )  {
		bu_log("ell():  A not perpendicular to C, f=%f\n", f);
		return(-3);		/* BAD */
	}

	{
		vect_t	axb;
		VCROSS( axb, Au, Bu );
		f = VDOT( axb, Cu );
		if( f < 0 )  {
			VREVERSE( Cu, Cu );
			VREVERSE( state.eip->c, state.eip->c );
		}
	}

	/* Compute R and Rinv matrices */
	MAT_IDN( R );
	VMOVE( &R[0], Au );
	VMOVE( &R[4], Bu );
	VMOVE( &R[8], Cu );
	bn_mat_trn( invR, R );			/* inv of rot mat is trn */

	/* Compute S and invS matrices */
	/* invS is just 1/diagonal elements */
	MAT_IDN( S );
	S[ 0] = invAlen;
	S[ 5] = invBlen;
	S[10] = invClen;
	bn_mat_inv( invS, S );

	/* invRinvS, for converting points from unit sphere to model */
	bn_mat_mul( state.invRinvS, invR, invS );

	/* invRoS, for converting normals from unit sphere to model */
	bn_mat_mul( state.invRoS, invR, S );

	/* Compute radius of bounding sphere */
	radius = Alen;
	if( Blen > radius )
		radius = Blen;
	if( Clen > radius )
		radius = Clen;

	/*
	 *  Establish tolerances
	 */
	if( ttol->rel <= 0.0 || ttol->rel >= 1.0 )  {
		rel = 0.0;		/* none */
	} else {
		/* Convert rel to absolute by scaling by radius */
		rel = ttol->rel * radius;
	}
	if( ttol->abs <= 0.0 )  {
		if( rel <= 0.0 )  {
			/* No tolerance given, use a default */
			rel = 0.10 * radius;	/* 10% */
		} else {
			/* Use absolute-ized relative tolerance */
		}
	} else {
		/* Absolute tolerance was given, pick smaller */
		if( ttol->rel <= 0.0 || rel > ttol->abs )
		{
			rel = ttol->abs;
			if( rel > radius )
				rel = radius;
		}
	}

	/*
	 *  Converte distance tolerance into a maximum permissible
	 *  angle tolerance.  'radius' is largest radius.
	 */
	state.theta_tol = 2 * acos( 1.0 - rel / radius );

	/* To ensure normal tolerance, remain below this angle */
	if( ttol->norm > 0.0 && ttol->norm < state.theta_tol )  {
		state.theta_tol = ttol->norm;
	}

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	state.s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	/* Find the number of segments to divide 90 degrees worth into */
	nsegs = (int)(bn_halfpi / state.theta_tol + 0.999);
	if( nsegs < 2 )  nsegs = 2;

	/*  Find total number of strips of vertices that will be needed.
	 *  nsegs for each hemisphere, plus the equator.
	 *  Note that faces are listed in the the stripe ABOVE, ie, toward
	 *  the poles.  Thus, strips[0] will have 4 faces.
	 */
	nstrips = 2 * nsegs + 1;
	strips = (struct ell_vert_strip *)bu_calloc( nstrips,
		sizeof(struct ell_vert_strip), "strips[]" );

	/* North pole */
	strips[0].nverts = 1;
	strips[0].nverts_per_strip = 0;
	strips[0].nfaces = 4;
	/* South pole */
	strips[nstrips-1].nverts = 1;
	strips[nstrips-1].nverts_per_strip = 0;
	strips[nstrips-1].nfaces = 4;
	/* equator */
	strips[nsegs].nverts = nsegs * 4;
	strips[nsegs].nverts_per_strip = nsegs;
	strips[nsegs].nfaces = 0;

	for( i=1; i<nsegs; i++ )  {
		strips[i].nverts_per_strip =
			strips[nstrips-1-i].nverts_per_strip = i;
		strips[i].nverts =
			strips[nstrips-1-i].nverts = i * 4;
		strips[i].nfaces =
			strips[nstrips-1-i].nfaces = (2 * i + 1)*4;
	}
	/* All strips have vertices and normals */
	for( i=0; i<nstrips; i++ )  {
		strips[i].vp = (struct vertex **)bu_calloc( strips[i].nverts,
			sizeof(struct vertex *), "strip vertex[]" );
		strips[i].norms = (vect_t *)bu_calloc( strips[i].nverts,
			sizeof( vect_t ), "strip normals[]" );
	}
	/* All strips have faces, except for the equator */
	for( i=0; i < nstrips; i++ )  {
		if( strips[i].nfaces <= 0 )  continue;
		strips[i].fu = (struct faceuse **)bu_calloc( strips[i].nfaces,
			sizeof(struct faceuse *), "strip faceuse[]" );
	}

	/* First, build the triangular mesh topology */
	/* Do the top. "toff" in i-1 is UP, towards +B */
	for( i = 1; i <= nsegs; i++ )  {
		faceno = 0;
		tlim = strips[i-1].nverts;
		blim = strips[i].nverts;
		for( stripno=0; stripno<4; stripno++ )  {
			toff = stripno * strips[i-1].nverts_per_strip;
			boff = stripno * strips[i].nverts_per_strip;

			/* Connect this quarter strip */
			for( j = 0; j < strips[i].nverts_per_strip; j++ )  {

				/* "Right-side-up" triangle */
				vertp[0] = &(strips[i].vp[j+boff]);
				vertp[1] = &(strips[i-1].vp[(j+toff)%tlim]);
				vertp[2] = &(strips[i].vp[(j+1+boff)%blim]);
				if( (strips[i-1].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
					bu_log("rt_ell_tess() nmg_cmface failure\n");
					goto fail;
				}
				if( j+1 >= strips[i].nverts_per_strip )  break;

				/* Follow with interior "Up-side-down" triangle */
				vertp[0] = &(strips[i].vp[(j+1+boff)%blim]);
				vertp[1] = &(strips[i-1].vp[(j+toff)%tlim]);
				vertp[2] = &(strips[i-1].vp[(j+1+toff)%tlim]);
				if( (strips[i-1].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
					bu_log("rt_ell_tess() nmg_cmface failure\n");
					goto fail;
				}
			}
		}
	}
	/* Do the bottom.  Everything is upside down. "toff" in i+1 is DOWN */
	for( i = nsegs; i < nstrips; i++ )  {
		faceno = 0;
		tlim = strips[i+1].nverts;
		blim = strips[i].nverts;
		for( stripno=0; stripno<4; stripno++ )  {
			toff = stripno * strips[i+1].nverts_per_strip;
			boff = stripno * strips[i].nverts_per_strip;

			/* Connect this quarter strip */
			for( j = 0; j < strips[i].nverts_per_strip; j++ )  {

				/* "Right-side-up" triangle */
				vertp[0] = &(strips[i].vp[j+boff]);
				vertp[1] = &(strips[i].vp[(j+1+boff)%blim]);
				vertp[2] = &(strips[i+1].vp[(j+toff)%tlim]);
				if( (strips[i+1].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
					bu_log("rt_ell_tess() nmg_cmface failure\n");
					goto fail;
				}
				if( j+1 >= strips[i].nverts_per_strip )  break;

				/* Follow with interior "Up-side-down" triangle */
				vertp[0] = &(strips[i].vp[(j+1+boff)%blim]);
				vertp[1] = &(strips[i+1].vp[(j+1+toff)%tlim]);
				vertp[2] = &(strips[i+1].vp[(j+toff)%tlim]);
				if( (strips[i+1].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
					bu_log("rt_ell_tess() nmg_cmface failure\n");
					goto fail;
				}
			}
		}
	}

	/*  Compute the geometry of each vertex.
	 *  Start with the location in the unit sphere, and project back.
	 *  i=0 is "straight up" along +B.
	 */
	for( i=0; i < nstrips; i++ )  {
		double	alpha;		/* decline down from B to A */
		double	beta;		/* angle around equator (azimuth) */
		fastf_t		cos_alpha, sin_alpha;
		fastf_t		cos_beta, sin_beta;
		point_t		sphere_pt;
		point_t		model_pt;

		alpha = (((double)i) / (nstrips-1));
		cos_alpha = cos(alpha*bn_pi);
		sin_alpha = sin(alpha*bn_pi);
		for( j=0; j < strips[i].nverts; j++ )  {

			beta = ((double)j) / strips[i].nverts;
			cos_beta = cos(beta*bn_twopi);
			sin_beta = sin(beta*bn_twopi);
			VSET( sphere_pt,
				cos_beta * sin_alpha,
				cos_alpha,
				sin_beta * sin_alpha );
			/* Convert from ideal sphere coordinates */
			MAT4X3PNT( model_pt, state.invRinvS, sphere_pt );
			VADD2( model_pt, model_pt, state.eip->v );
			/* Associate vertex geometry */
			nmg_vertex_gv( strips[i].vp[j], model_pt );

			/* Convert sphere normal to ellipsoid normal */
			MAT4X3VEC( strips[i].norms[j], state.invRoS, sphere_pt );
			/* May not be unit length anymore */
			VUNITIZE( strips[i].norms[j] );
		}
	}

	/* Associate face geometry.  Equator has no faces */
	for( i=0; i < nstrips; i++ )  {
		for( j=0; j < strips[i].nfaces; j++ )  {
			if( nmg_fu_planeeqn( strips[i].fu[j], tol ) < 0 )
				goto fail;
		}
	}

	/* Associate normals with vertexuses */
	for( i=0; i < nstrips; i++ )
	{
		for( j=0; j < strips[i].nverts; j++ )
		{
			struct faceuse *fu;
			struct vertexuse *vu;
			vect_t norm_opp;

			NMG_CK_VERTEX( strips[i].vp[j] );
			VREVERSE( norm_opp , strips[i].norms[j] )

			for( BU_LIST_FOR( vu , vertexuse , &strips[i].vp[j]->vu_hd ) )
			{
				fu = nmg_find_fu_of_vu( vu );
				NMG_CK_FACEUSE( fu );
				/* get correct direction of normals depending on
				 * faceuse orientation
				 */
				if( fu->orientation == OT_SAME )
					nmg_vertexuse_nv( vu , strips[i].norms[j] );
				else if( fu->orientation == OT_OPPOSITE )
					nmg_vertexuse_nv( vu , norm_opp );
			}
		}
	}

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

	/* Release memory */
	/* All strips have vertices and normals */
	for( i=0; i<nstrips; i++ )  {
		bu_free( (char *)strips[i].vp, "strip vertex[]" );
		bu_free( (char *)strips[i].norms, "strip norms[]" );
	}
	/* All strips have faces, except for equator */
	for( i=0; i < nstrips; i++ )  {
		if( strips[i].fu == (struct faceuse **)0 )  continue;
		bu_free( (char *)strips[i].fu, "strip faceuse[]" );
	}
	bu_free( (char *)strips, "strips[]" );
	return(0);
fail:
	/* Release memory */
	/* All strips have vertices and normals */
	for( i=0; i<nstrips; i++ )  {
		bu_free( (char *)strips[i].vp, "strip vertex[]" );
		bu_free( (char *)strips[i].norms, "strip norms[]" );
	}
	/* All strips have faces, except for equator */
	for( i=0; i < nstrips; i++ )  {
		if( strips[i].fu == (struct faceuse **)0 )  continue;
		bu_free( (char *)strips[i].fu, "strip faceuse[]" );
	}
	bu_free( (char *)strips, "strips[]" );
	return(-1);
}

/*
 *			R T _ E L L _ I M P O R T
 *
 *  Import an ellipsoid/sphere from the database format to
 *  the internal structure.
 *  Apply modeling transformations as well.
 */
int
rt_ell_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_ell_internal	*eip;
	union record		*rp;
	LOCAL fastf_t	vec[3*4];

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_ell_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_ELL;
	ip->idb_meth = &rt_functab[ID_ELL];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_ell_internal), "rt_ell_internal");
	eip = (struct rt_ell_internal *)ip->idb_ptr;
	eip->magic = RT_ELL_INTERNAL_MAGIC;

	/* Convert from database to internal format */
	rt_fastf_float( vec, rp->s.s_values, 4 );

	/* Apply modeling transformations */
	MAT4X3PNT( eip->v, mat, &vec[0*3] );
	MAT4X3VEC( eip->a, mat, &vec[1*3] );
	MAT4X3VEC( eip->b, mat, &vec[2*3] );
	MAT4X3VEC( eip->c, mat, &vec[3*3] );

	return(0);		/* OK */
}

/*
 *			R T _ E L L _ E X P O R T
 */
int
rt_ell_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_ell_internal	*tip;
	union record		*rec;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ELL && ip->idb_type != ID_SPH )  return(-1);
	tip = (struct rt_ell_internal *)ip->idb_ptr;
	RT_ELL_CK_MAGIC(tip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "ell external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->s.s_type = GENELL;

	/* NOTE: This also converts to dbfloat_t */
	VSCALE( &rec->s.s_values[0], tip->v, local2mm );
	VSCALE( &rec->s.s_values[3], tip->a, local2mm );
	VSCALE( &rec->s.s_values[6], tip->b, local2mm );
	VSCALE( &rec->s.s_values[9], tip->c, local2mm );

	return(0);
}

/*
 *			R T _ E L L _ I M P O R T 5
 *
 *  Import an ellipsoid/sphere from the database format to
 *  the internal structure.
 *  Apply modeling transformations as well.
 */
int
rt_ell_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_ell_internal	*eip;
	fastf_t			vec[ELEMENTS_PER_VECT*4];

	RT_CK_DB_INTERNAL( ip );
	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * ELEMENTS_PER_VECT*4 );

	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_ELL;
	ip->idb_meth = &rt_functab[ID_ELL];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_ell_internal), "rt_ell_internal");

	eip = (struct rt_ell_internal *)ip->idb_ptr;
	eip->magic = RT_ELL_INTERNAL_MAGIC;

	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)vec, ep->ext_buf, ELEMENTS_PER_VECT*4 );

	/* Apply modeling transformations */
	MAT4X3PNT( eip->v, mat, &vec[0*ELEMENTS_PER_VECT] );
	MAT4X3VEC( eip->a, mat, &vec[1*ELEMENTS_PER_VECT] );
	MAT4X3VEC( eip->b, mat, &vec[2*ELEMENTS_PER_VECT] );
	MAT4X3VEC( eip->c, mat, &vec[3*ELEMENTS_PER_VECT] );

	return 0;		/* OK */
}

/*
 *			R T _ E L L _ E X P O R T 5
 *
 *  The external format is:
 *	V point
 *	A vector
 *	B vector
 *	C vector
 */
int
rt_ell_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_ell_internal	*eip;
	fastf_t			vec[ELEMENTS_PER_VECT*4];

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ELL && ip->idb_type != ID_SPH )  return(-1);
	eip = (struct rt_ell_internal *)ip->idb_ptr;
	RT_ELL_CK_MAGIC(eip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * ELEMENTS_PER_VECT*4;
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "ell external");

	/* scale 'em into local buffer */
	VSCALE( &vec[0*ELEMENTS_PER_VECT], eip->v, local2mm );
	VSCALE( &vec[1*ELEMENTS_PER_VECT], eip->a, local2mm );
	VSCALE( &vec[2*ELEMENTS_PER_VECT], eip->b, local2mm );
	VSCALE( &vec[3*ELEMENTS_PER_VECT], eip->c, local2mm );

	/* Convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, ELEMENTS_PER_VECT*4 );

	return 0;
}

/*
 *			R T _ E L L _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_ell_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_ell_internal	*tip =
		(struct rt_ell_internal *)ip->idb_ptr;
	fastf_t	mag_a, mag_b, mag_c;
	char	buf[256];
	double	angles[5];
	vect_t	unitv;

	RT_ELL_CK_MAGIC(tip);
	bu_vls_strcat( str, "ellipsoid (ELL)\n");

	sprintf(buf, "\tV (%g, %g, %g)\n",
		tip->v[X] * mm2local,
		tip->v[Y] * mm2local,
		tip->v[Z] * mm2local );
	bu_vls_strcat( str, buf );

	mag_a = MAGNITUDE(tip->a);
	mag_b = MAGNITUDE(tip->b);
	mag_c = MAGNITUDE(tip->c);

	sprintf(buf, "\tA (%g, %g, %g) mag=%g\n",
		tip->a[X] * mm2local,
		tip->a[Y] * mm2local,
		tip->a[Z] * mm2local,
		mag_a * mm2local);
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tB (%g, %g, %g) mag=%g\n",
		tip->b[X] * mm2local,
		tip->b[Y] * mm2local,
		tip->b[Z] * mm2local,
		mag_b * mm2local);
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tC (%g, %g, %g) mag=%g\n",
		tip->c[X] * mm2local,
		tip->c[Y] * mm2local,
		tip->c[Z] * mm2local,
		mag_c * mm2local);
	bu_vls_strcat( str, buf );

	if( !verbose )  return(0);

	VSCALE( unitv, tip->a, 1/mag_a );
	rt_find_fallback_angle( angles, unitv );
	rt_pr_fallback_angle( str, "\tA", angles );

	VSCALE( unitv, tip->b, 1/mag_b );
	rt_find_fallback_angle( angles, unitv );
	rt_pr_fallback_angle( str, "\tB", angles );

	VSCALE( unitv, tip->c, 1/mag_c );
	rt_find_fallback_angle( angles, unitv );
	rt_pr_fallback_angle( str, "\tC", angles );

	return(0);
}

/*
 *			R T _ E L L _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_ell_ifree(struct rt_db_internal *ip)
{
	RT_CK_DB_INTERNAL(ip);
	bu_free( ip->idb_ptr, "ell ifree" );
	ip->idb_ptr = GENPTR_NULL;
}

/*  The U parameter runs south to north.
 *  In order to orient loop CCW, need to start with 0,1-->0,0 transition
 *  at the south pole.
 */
static const fastf_t rt_ell_uvw[5*ELEMENTS_PER_VECT] = {
	0, 1, 0,
	0, 0, 0,
	1, 0, 0,
	1, 1, 0,
	0, 1, 0
};

/*
 *			R T _ E L L _ T N U R B
 */
int
rt_ell_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
{
	LOCAL mat_t	R;
	LOCAL mat_t	S;
	LOCAL mat_t	invR;
	LOCAL mat_t	invS;
	mat_t		invRinvS;
	mat_t		invRoS;
	LOCAL mat_t	unit2model;
	LOCAL mat_t	xlate;
	LOCAL vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
	LOCAL fastf_t	Alen, Blen, Clen;
	LOCAL fastf_t	invAlen, invBlen, invClen;
	LOCAL fastf_t	magsq_a, magsq_b, magsq_c;
	LOCAL fastf_t	f;
	register int		i;
	fastf_t		radius;
	struct rt_ell_internal	*eip;
	struct vertex		*verts[8];
	struct vertex		**vertp[4];
	struct faceuse		*fu;
	struct shell		*s;
	struct loopuse		*lu;
	struct edgeuse		*eu;
	point_t			pole;

	RT_CK_DB_INTERNAL(ip);
	eip = (struct rt_ell_internal *)ip->idb_ptr;
	RT_ELL_CK_MAGIC(eip);

	/* Validate that |A| > 0, |B| > 0, |C| > 0 */
	magsq_a = MAGSQ( eip->a );
	magsq_b = MAGSQ( eip->b );
	magsq_c = MAGSQ( eip->c );
	if( magsq_a < tol->dist || magsq_b < tol->dist || magsq_c < tol->dist ) {
		bu_log("rt_ell_tess():  zero length A, B, or C vector\n");
		return(-2);		/* BAD */
	}

	/* Create unit length versions of A,B,C */
	invAlen = 1.0/(Alen = sqrt(magsq_a));
	VSCALE( Au, eip->a, invAlen );
	invBlen = 1.0/(Blen = sqrt(magsq_b));
	VSCALE( Bu, eip->b, invBlen );
	invClen = 1.0/(Clen = sqrt(magsq_c));
	VSCALE( Cu, eip->c, invClen );

	/* Validate that A.B == 0, B.C == 0, A.C == 0 (check dir only) */
	f = VDOT( Au, Bu );
	if( ! NEAR_ZERO(f, tol->dist) )  {
		bu_log("ell():  A not perpendicular to B, f=%f\n", f);
		return(-3);		/* BAD */
	}
	f = VDOT( Bu, Cu );
	if( ! NEAR_ZERO(f, tol->dist) )  {
		bu_log("ell():  B not perpendicular to C, f=%f\n", f);
		return(-3);		/* BAD */
	}
	f = VDOT( Au, Cu );
	if( ! NEAR_ZERO(f, tol->dist) )  {
		bu_log("ell():  A not perpendicular to C, f=%f\n", f);
		return(-3);		/* BAD */
	}

	{
		vect_t	axb;
		VCROSS( axb, Au, Bu );
		f = VDOT( axb, Cu );
		if( f < 0 )  {
			VREVERSE( Cu, Cu );
			VREVERSE( eip->c, eip->c );
		}
	}

	/* Compute R and Rinv matrices */
	MAT_IDN( R );
	VMOVE( &R[0], Au );
	VMOVE( &R[4], Bu );
	VMOVE( &R[8], Cu );
	bn_mat_trn( invR, R );			/* inv of rot mat is trn */

	/* Compute S and invS matrices */
	/* invS is just 1/diagonal elements */
	MAT_IDN( S );
	S[ 0] = invAlen;
	S[ 5] = invBlen;
	S[10] = invClen;
	bn_mat_inv( invS, S );

	/* invRinvS, for converting points from unit sphere to model */
	bn_mat_mul( invRinvS, invR, invS );

	/* invRoS, for converting normals from unit sphere to model */
	bn_mat_mul( invRoS, invR, S );

	/* Compute radius of bounding sphere */
	radius = Alen;
	if( Blen > radius )
		radius = Blen;
	if( Clen > radius )
		radius = Clen;

	MAT_IDN( xlate );
	MAT_DELTAS_VEC( xlate, eip->v );
	bn_mat_mul( unit2model, xlate, invRinvS );

	/*
	 *  --- Build Topology ---
	 *
	 *  There is a vertex at either pole, and a single longitude line.
	 *  There is a single face, an snurb with singularities.
	 *  vert[0] is the south pole, and is the first row of the ctl_points.
	 *  vert[1] is the north pole, and is the last row of the ctl_points.
	 *
	 *  Somewhat surprisingly, the U parameter runs from south to north.
	 */
	for( i=0; i<8; i++ )  verts[i] = (struct vertex *)0;

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	vertp[0] = &verts[0];
	vertp[1] = &verts[0];
	vertp[2] = &verts[1];
	vertp[3] = &verts[1];

	if( (fu = nmg_cmface( s, vertp, 4 )) == 0 )  {
		bu_log("rt_ell_tnurb(%s): nmg_cmface() fail on face\n");
		return -1;
	}

	/* March around the fu's loop assigning uv parameter values */
	lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
	NMG_CK_LOOPUSE(lu);
	eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
	NMG_CK_EDGEUSE(eu);

	/* Loop always has Counter-Clockwise orientation (CCW) */
	for( i=0; i < 4; i++ )  {
		nmg_vertexuse_a_cnurb( eu->vu_p, &rt_ell_uvw[i*ELEMENTS_PER_VECT] );
		nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &rt_ell_uvw[(i+1)*ELEMENTS_PER_VECT] );
		eu = BU_LIST_NEXT( edgeuse, &eu->l );
	}

	/* Associate vertex geometry */
	VSUB2( pole, eip->v, eip->c );		/* south pole */
	nmg_vertex_gv( verts[0], pole );
	VADD2( pole, eip->v, eip->c );
	nmg_vertex_gv( verts[1], pole );	/* north pole */

	/* Build snurb, transformed into final position */
	nmg_sphere_face_snurb( fu, unit2model );

	/* Associate edge geometry (trimming curve) -- linear in param space */
	eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
	NMG_CK_EDGEUSE(eu);
	for( i=0; i < 4; i++ )  {
#if 0
struct snurb sn;
fastf_t	param[4];
bu_log("\neu=x%x, vu=x%x, v=x%x  ", eu, eu->vu_p, eu->vu_p->v_p);
VPRINT("xyz", eu->vu_p->v_p->vg_p->coord);
nmg_hack_snurb( &sn, fu->f_p->g.snurb_p );
VPRINT("uv", eu->vu_p->a.cnurb_p->param);
rt_nurb_s_eval( &sn, V2ARGS(eu->vu_p->a.cnurb_p->param), param );
VPRINT("surf(u,v)", param);
#endif

		nmg_edge_g_cnurb_plinear(eu);
		eu = BU_LIST_NEXT( edgeuse, &eu->l );
	}

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

	return 0;
}

/*
 *  u,v=(0,0) is supposed to be the south pole, at Z=-1.0
 *  The V direction runs from the south to the north pole.
 */
static void
nmg_sphere_face_snurb(struct faceuse *fu, const matp_t m)
{
	struct face_g_snurb	*fg;
	FAST fastf_t root2_2;
	register fastf_t	*op;

	NMG_CK_FACEUSE(fu);
	root2_2 = sqrt(2.0)*0.5;

	/* Let the library allocate all the storage */
	/* The V direction runs from south to north pole */
	nmg_face_g_snurb( fu,
		3, 3,		/* u,v order */
		8, 12,		/* Number of knots, u,v */
		NULL, NULL,	/* initial u,v knot vectors */
		9, 5,		/* n_rows, n_cols */
		RT_NURB_MAKE_PT_TYPE( 4, RT_NURB_PT_XYZ, RT_NURB_PT_RATIONAL ),
		NULL );		/* initial mesh */

	fg = fu->f_p->g.snurb_p;
	NMG_CK_FACE_G_SNURB(fg);

	fg->v.knots[ 0] = 0;
	fg->v.knots[ 1] = 0;
	fg->v.knots[ 2] = 0;
	fg->v.knots[ 3] = 0.25;
	fg->v.knots[ 4] = 0.25;
	fg->v.knots[ 5] = 0.5;
	fg->v.knots[ 6] = 0.5;
	fg->v.knots[ 7] = 0.75;
	fg->v.knots[ 8] = 0.75;
	fg->v.knots[ 9] = 1;
	fg->v.knots[10] = 1;
	fg->v.knots[11] = 1;

	fg->u.knots[0] = 0;
	fg->u.knots[1] = 0;
	fg->u.knots[2] = 0;
	fg->u.knots[3] = 0.5;
	fg->u.knots[4] = 0.5;
	fg->u.knots[5] = 1;
	fg->u.knots[6] = 1;
	fg->u.knots[7] = 1;

	op = fg->ctl_points;

/* Inspired by MAT4X4PNT */
#define M(x,y,z,w)	{ \
	*op++ = m[ 0]*(x) + m[ 1]*(y) + m[ 2]*(z) + m[ 3]*(w);\
	*op++ = m[ 4]*(x) + m[ 5]*(y) + m[ 6]*(z) + m[ 7]*(w);\
	*op++ = m[ 8]*(x) + m[ 9]*(y) + m[10]*(z) + m[11]*(w);\
	*op++ = m[12]*(x) + m[13]*(y) + m[14]*(z) + m[15]*(w); }


	M(   0     ,   0     ,-1.0     , 1.0     );
	M( root2_2 ,   0     ,-root2_2 , root2_2 );
	M( 1.0     ,   0     ,   0     , 1.0     );
	M( root2_2 ,   0     , root2_2 , root2_2 );
	M(   0     ,   0     , 1.0     , 1.0     );

	M(   0     ,   0     ,-root2_2 , root2_2 );
	M( 0.5     ,-0.5     ,-0.5     , 0.5     );
	M( root2_2 ,-root2_2 ,   0     , root2_2 );
	M( 0.5     ,-0.5     , 0.5     , 0.5     );
	M(   0     ,   0     , root2_2 , root2_2 );

	M(   0     ,   0     ,-1.0     , 1.0     );
	M(   0     ,-root2_2 ,-root2_2 , root2_2 );
	M(   0     ,-1.0     ,   0     , 1.0     );
	M(   0     ,-root2_2 , root2_2 , root2_2 );
	M(   0     ,   0     , 1.0     , 1.0     );

	M(   0     ,   0     ,-root2_2 , root2_2 );
	M(-0.5     ,-0.5     ,-0.5     , 0.5     );
	M(-root2_2 ,-root2_2 ,   0     , root2_2 );
	M(-0.5     ,-0.5     , 0.5     , 0.5     );
	M(   0     ,   0     , root2_2 , root2_2 );

	M(   0     ,   0     ,-1.0     , 1.0     );
	M(-root2_2 ,   0     ,-root2_2 , root2_2 );
	M(-1.0     ,   0     ,   0     , 1.0     );
	M(-root2_2 ,   0     , root2_2 , root2_2 );
	M(   0     ,   0     , 1.0     , 1.0     );

	M(   0     ,   0     ,-root2_2 , root2_2 );
	M(-0.5     , 0.5     ,-0.5     , 0.5     );
	M(-root2_2 , root2_2 ,   0     , root2_2 );
	M(-0.5     , 0.5     , 0.5     , 0.5     );
	M(   0     ,   0     , root2_2 , root2_2 );

	M(   0     ,   0     ,-1.0     , 1.0     );
	M(   0     , root2_2 ,-root2_2 , root2_2 );
	M(   0     , 1.0     ,   0     , 1.0     );
	M(   0     , root2_2 , root2_2 , root2_2 );
	M(   0     ,   0     , 1.0     , 1.0     );

	M(   0     ,   0     ,-root2_2 , root2_2 );
	M( 0.5     , 0.5     ,-0.5     , 0.5     );
	M( root2_2 , root2_2 ,   0     , root2_2 );
	M( 0.5     , 0.5     , 0.5     , 0.5     );
	M(   0     ,   0     , root2_2 , root2_2 );

	M(   0     ,   0     ,-1.0     , 1.0     );
	M( root2_2 ,   0     ,-root2_2 , root2_2 );
	M( 1.0     ,   0     ,   0     , 1.0     );
	M( root2_2 ,   0     , root2_2 , root2_2 );
	M(   0     ,   0     , 1.0     , 1.0     );
}
@


11.37
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /cvs/brlcad/librt/g_ell.c,v 11.36 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.36
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header$ (BRL)";
d27 5
a31 1
#include "conf.h"
@


11.35
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.34 2002/08/20 17:07:59 jra Exp $ (BRL)";
d54 1
a54 1
static void  nmg_sphere_face_snurb();
d176 1
a176 4
rt_ell_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d197 3
a199 2
	if( rt_sph_prep( stp, ip, rtip ) == 0 )
		return(0);		/* OK */
d206 1
a206 2
	/* XXX this coded constant stuff will bite us someday soon */
	if( magsq_a < 0.005 || magsq_b < 0.005 || magsq_c < 0.005 ) {
d222 1
a222 1
	if( ! NEAR_ZERO(f, 0.005) )  {
d227 1
a227 1
	if( ! NEAR_ZERO(f, 0.005) )  {
d232 1
a232 1
	if( ! NEAR_ZERO(f, 0.005) )  {
d318 1
a318 2
rt_ell_print( stp )
register const struct soltab *stp;
d340 1
a340 5
rt_ell_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d387 6
a392 6
rt_ell_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d445 1
a445 4
rt_ell_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d468 1
a468 4
rt_ell_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d508 1
a508 5
rt_ell_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d546 1
a546 2
rt_ell_free( stp )
register struct soltab *stp;
d555 1
a555 1
rt_ell_class()
d608 1
a608 5
rt_ell_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d727 1
a727 6
rt_ell_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d762 1
a762 1
	if( magsq_a < 0.005 || magsq_b < 0.005 || magsq_c < 0.005 ) {
d777 1
a777 1
	if( ! NEAR_ZERO(f, 0.005) )  {
d782 1
a782 1
	if( ! NEAR_ZERO(f, 0.005) )  {
d787 1
a787 1
	if( ! NEAR_ZERO(f, 0.005) )  {
d1098 1
a1098 5
rt_ell_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1136 1
a1136 5
rt_ell_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1171 1
a1171 5
rt_ell_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1211 1
a1211 5
rt_ell_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1245 1
a1245 5
rt_ell_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1311 1
a1311 2
rt_ell_ifree( ip )
struct rt_db_internal	*ip;
d1334 1
a1334 5
rt_ell_tnurb( r, m, ip, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct bn_tol		*tol;
d1368 1
a1368 1
	if( magsq_a < 0.005 || magsq_b < 0.005 || magsq_c < 0.005 ) {
d1383 1
a1383 1
	if( ! NEAR_ZERO(f, 0.005) )  {
d1388 1
a1388 1
	if( ! NEAR_ZERO(f, 0.005) )  {
d1393 1
a1393 1
	if( ! NEAR_ZERO(f, 0.005) )  {
d1517 1
a1517 3
nmg_sphere_face_snurb( fu, m )
struct faceuse	*fu;
const matp_t	m;
@


11.34
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985 by the United States Army.
d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.32 2001/10/02 19:24:29 jra Exp $ (BRL)";
@


11.34.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_ell.c,v 11.35 2004/02/02 17:39:20 morrison Exp $ (BRL)";
@


11.34.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.35 2004/02/02 17:39:20 morrison Exp $ (BRL)";
@


11.34.10.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.34.10.1 2004/02/12 18:37:40 erikg Exp $ (BRL)";
@


11.34.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.34 2002/08/20 17:07:59 jra Exp $ (BRL)";
d54 1
a54 1
static void  nmg_sphere_face_snurb(struct faceuse *fu, const matp_t m);
d176 4
a179 1
rt_ell_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d321 2
a322 1
rt_ell_print(register const struct soltab *stp)
d344 5
a348 1
rt_ell_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d395 6
a400 6
rt_ell_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d453 4
a456 1
rt_ell_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d479 4
a482 1
rt_ell_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d522 5
a526 1
rt_ell_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d564 2
a565 1
rt_ell_free(register struct soltab *stp)
d574 1
a574 1
rt_ell_class(void)
d627 5
a631 1
rt_ell_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d750 6
a755 1
rt_ell_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1126 5
a1130 1
rt_ell_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1168 5
a1172 1
rt_ell_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1207 5
a1211 1
rt_ell_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1251 5
a1255 1
rt_ell_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1289 5
a1293 1
rt_ell_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1359 2
a1360 1
rt_ell_ifree(struct rt_db_internal *ip)
d1383 5
a1387 1
rt_ell_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
d1570 3
a1572 1
nmg_sphere_face_snurb(struct faceuse *fu, const matp_t m)
@


11.34.2.2
log
@updated hard-coded tolerances to use the run-time ray-trace instance pointer tolerance
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.34.2.1 2002/09/19 18:01:33 morrison Exp $ (BRL)";
d197 2
a198 3
	if( rt_sph_prep( stp, ip, rtip ) == 0 ) {
	  return(0);		/* OK */
	}
d205 2
a206 1
	if( magsq_a < rtip->rti_tol.dist || magsq_b < rtip->rti_tol.dist || magsq_c < rtip->rti_tol.dist ) {
d222 1
a222 1
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
d227 1
a227 1
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
d232 1
a232 1
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
d762 1
a762 1
	if( magsq_a < tol->dist || magsq_b < tol->dist || magsq_c < tol->dist ) {
d777 1
a777 1
	if( ! NEAR_ZERO(f, tol->dist) )  {
d782 1
a782 1
	if( ! NEAR_ZERO(f, tol->dist) )  {
d787 1
a787 1
	if( ! NEAR_ZERO(f, tol->dist) )  {
d1368 1
a1368 1
	if( magsq_a < tol->dist || magsq_b < tol->dist || magsq_c < tol->dist ) {
d1383 1
a1383 1
	if( ! NEAR_ZERO(f, tol->dist) )  {
d1388 1
a1388 1
	if( ! NEAR_ZERO(f, tol->dist) )  {
d1393 1
a1393 1
	if( ! NEAR_ZERO(f, tol->dist) )  {
@


11.34.2.3
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSell[] = "@@(#)$Header$ (BRL)";
@


11.33
log
@Converted from K&R to ANSI C - RFH
@
text
@d54 1
a54 1
static void  nmg_sphere_face_snurb(struct faceuse *fu, const matp_t m);
d176 4
a179 1
rt_ell_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d321 2
a322 1
rt_ell_print(register const struct soltab *stp)
d344 5
a348 1
rt_ell_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d395 6
a400 6
rt_ell_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d453 4
a456 1
rt_ell_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d479 4
a482 1
rt_ell_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d522 5
a526 1
rt_ell_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d564 2
a565 1
rt_ell_free(register struct soltab *stp)
d574 1
a574 1
rt_ell_class(void)
d627 5
a631 1
rt_ell_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d750 6
a755 1
rt_ell_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1126 5
a1130 1
rt_ell_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1168 5
a1172 1
rt_ell_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1207 5
a1211 1
rt_ell_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1251 5
a1255 1
rt_ell_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1289 5
a1293 1
rt_ell_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1359 2
a1360 1
rt_ell_ifree(struct rt_db_internal *ip)
d1383 5
a1387 1
rt_ell_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
d1570 3
a1572 1
nmg_sphere_face_snurb(struct faceuse *fu, const matp_t m)
@


11.32
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.31 2001/04/20 22:29:44 morrison Exp $ (BRL)";
d54 1
a54 1
static void  nmg_sphere_face_snurb();
d176 1
a176 4
rt_ell_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d318 1
a318 2
rt_ell_print( stp )
register const struct soltab *stp;
d340 1
a340 5
rt_ell_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d387 6
a392 6
rt_ell_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d445 1
a445 4
rt_ell_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d468 1
a468 4
rt_ell_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d508 1
a508 5
rt_ell_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d546 1
a546 2
rt_ell_free( stp )
register struct soltab *stp;
d555 1
a555 1
rt_ell_class()
d608 1
a608 5
rt_ell_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d727 1
a727 6
rt_ell_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d1098 1
a1098 5
rt_ell_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1136 1
a1136 5
rt_ell_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1171 1
a1171 5
rt_ell_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1211 1
a1211 5
rt_ell_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1245 1
a1245 5
rt_ell_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1311 1
a1311 2
rt_ell_ifree( ip )
struct rt_db_internal	*ip;
d1334 1
a1334 5
rt_ell_tnurb( r, m, ip, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct bn_tol		*tol;
d1517 1
a1517 3
nmg_sphere_face_snurb( fu, m )
struct faceuse	*fu;
const matp_t	m;
@


11.31
log
@CONST to const
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.30 2001/03/31 01:57:07 morrison Exp $ (BRL)";
d1145 1
d1221 1
@


11.30
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.29 2001/01/29 19:56:54 jra Exp $ (BRL)";
d46 1
a46 1
CONST struct bu_structparse rt_ell_parse[] = {
d322 1
a322 1
register CONST struct soltab *stp;
d630 2
a631 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d754 2
a755 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d1128 3
a1130 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1169 1
a1169 1
CONST struct rt_db_internal	*ip;
d1171 1
a1171 1
CONST struct db_i		*dbip;
d1208 3
a1210 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1251 1
a1251 1
CONST struct rt_db_internal	*ip;
d1253 1
a1253 1
CONST struct db_i		*dbip;
d1289 1
a1289 1
CONST struct rt_db_internal	*ip;
d1369 1
a1369 1
static CONST fastf_t rt_ell_uvw[5*ELEMENTS_PER_VECT] = {
d1385 1
a1385 1
CONST struct bn_tol		*tol;
d1570 1
a1570 1
CONST matp_t	m;
@


11.29
log
@removed previous change
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.28 2001/01/29 19:50:28 jra Exp $ (BRL)";
d251 2
a252 2
	bn_mat_idn( ell->ell_SoR );
	bn_mat_idn( R );
d261 1
a261 1
	bn_mat_idn( SS );
d831 1
a831 1
	bn_mat_idn( R );
d839 1
a839 1
	bn_mat_idn( S );
d1460 1
a1460 1
	bn_mat_idn( R );
d1468 1
a1468 1
	bn_mat_idn( S );
d1487 1
a1487 1
	bn_mat_idn( xlate );
@


11.28
log
@describe now says "ELLG"
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.27 2000/10/19 16:08:39 bparker Exp $ (BRL)";
d1301 1
a1301 1
	bu_vls_strcat( str, "ellipsoid (ELLG)\n");
@


11.27
log
@Mods to export routine to recognize other
solids that share the routine.
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.26 2000/10/18 18:10:34 butler Exp $ (BRL)";
d1301 1
a1301 1
	bu_vls_strcat( str, "ellipsoid (ELL)\n");
@


11.26
log
@Patches for compiling under RedHat 7.0
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.25 2000/08/21 02:02:30 butler Exp $ (BRL)";
d1177 1
a1177 1
	if( ip->idb_type != ID_ELL )  return(-1);
d1259 1
a1259 1
	if( ip->idb_type != ID_ELL )  return -1;
@


11.25
log
@Massive compilation warnings eliminated
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.24 2000/07/13 02:36:26 cjohnson Exp $ (BRL)";
d30 3
@


11.24
log
@LINT from gcc -Wall
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.23 2000/07/10 23:01:31 mike Exp $ (BRL)";
d48 2
a49 1
    {0,0,0,0,0} };
d583 4
a586 4
rt_ell_16pts( ov, V, A, B )
register fastf_t *ov;
register fastf_t *V;
fastf_t *A, *B;
@


11.23
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d24 1
a24 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.22 2000/06/30 15:38:02 mike Exp $ (BRL)";
d48 1
a48 1
    {0} };
@


11.22
log
@
export methods should not init the external structure, just check them.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.21 2000/06/30 15:29:46 mike Exp $ (BRL)";
@


11.21
log
@
Parameterized with more manifest constants
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.20 2000/06/27 14:44:55 mike Exp $ (BRL)";
d1177 1
a1177 1
	BU_INIT_EXTERNAL(ep);
d1259 1
a1259 1
	BU_INIT_EXTERNAL(ep);
@


11.20
log
@
Ensure that input buffer is correct size.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.19 2000/06/26 19:22:41 bparker Exp $ (BRL)";
d1140 1
a1140 1
	RT_INIT_DB_INTERNAL( ip );
d1209 1
a1209 1
	fastf_t			vec[3*4];
d1211 1
d1214 1
a1214 1
	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 3*4 );
a1215 1
	RT_INIT_DB_INTERNAL( ip );
d1224 1
a1224 1
	ntohd( (unsigned char *)vec, ep->ext_buf, 3*4 );
d1227 4
a1230 4
	MAT4X3PNT( eip->v, mat, &vec[0*3] );
	MAT4X3VEC( eip->a, mat, &vec[1*3] );
	MAT4X3VEC( eip->b, mat, &vec[2*3] );
	MAT4X3VEC( eip->c, mat, &vec[3*3] );
d1252 1
a1252 1
	fastf_t			vec[3*4];
d1260 1
a1260 1
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 3*4;
d1264 4
a1267 4
	VSCALE( &vec[0*3], eip->v, local2mm );
	VSCALE( &vec[1*3], eip->a, local2mm );
	VSCALE( &vec[2*3], eip->b, local2mm );
	VSCALE( &vec[3*3], eip->c, local2mm );
d1270 1
a1270 1
	htond( ep->ext_buf, (unsigned char *)vec, 3*4 );
d1365 1
a1365 1
static CONST fastf_t rt_ell_uvw[5*3] = {
d1520 2
a1521 2
		nmg_vertexuse_a_cnurb( eu->vu_p, &rt_ell_uvw[i*3] );
		nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &rt_ell_uvw[(i+1)*3] );
@


11.19
log
@Fixed typo.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.18 2000/06/26 17:37:20 mike Exp $ (BRL)";
d1212 2
@


11.18
log
@
Added v5 import/export routines
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.17 2000/04/12 02:34:32 mike Exp $ (BRL)";
d1222 1
a1222 1
	ntohd( (unsigned char *)vec, ep->ext_buf, 4*4 );
d1258 1
a1258 1
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 4*4;
d1268 1
a1268 1
	htond( ep->ext_buf, (unsigned char *)vec, 4*4 );
@


11.17
log
@
NT port, non-compat4
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.16 2000/03/28 21:27:51 mike Exp $ (BRL)";
d1192 79
@


11.17.2.1
log
@Mods to export routine to recognize other
solids that share the routine.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.17 2000/04/12 02:34:32 mike Exp $ (BRL)";
d1173 1
a1173 1
	if( ip->idb_type != ID_ELL && ip->idb_type != ID_SPH )  return(-1);
@


11.17.2.2
log
@describe now reports "ELLG"
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.17.2.1 2000/10/19 16:08:01 bparker Exp $ (BRL)";
d1216 1
a1216 1
	bu_vls_strcat( str, "ellipsoid (ELLG)\n");
@


11.17.2.3
log
@removed previous change
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.17.2.2 2001/01/29 19:51:07 jra Exp $ (BRL)";
d1216 1
a1216 1
	bu_vls_strcat( str, "ellipsoid (ELL)\n");
@


11.16
log
@
Handled conflicting defines for XMIN
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.15 1999/12/22 02:17:59 mike Exp $ (BRL)";
d491 1
a491 1
	vec_ortho( u, hitp->hit_normal );
d504 1
a504 1
	eigen2x2( &cvp->crv_c1, &cvp->crv_c2, vec1, vec2, a, b, c );
d895 1
a895 1
	nsegs = bn_halfpi / state.theta_tol + 0.999;
@


11.15
log
@
Eliminated dead vars
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.14 1999/11/26 21:46:45 mike Exp $ (BRL)";
a668 1
#endif
d676 1
@


11.14
log
@
Lint cleanups
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.13 1999/11/24 23:12:07 mike Exp $ (BRL)";
a1316 11
	int		nsegs;
	int		nstrips;
	struct ell_vert_strip	*strips;
	int		j;
	int	faceno;
	int	stripno;
	int	boff;		/* base offset */
	int	toff;		/* top offset */
	int	blim;		/* base subscript limit */
	int	tlim;		/* top subscrpit limit */
	fastf_t	rel;		/* Absolutized relative tolerance */
@


11.13
log
@
Made structparse tables CONST
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.12 1999/11/17 02:41:57 mike Exp $ (BRL)";
d627 1
a627 1
struct bn_tol		*tol;
d703 1
a703 1
struct vert_strip {
d751 1
a751 1
struct bn_tol		*tol;
d767 1
a767 1
	struct vert_strip	*strips;
d904 2
a905 2
	strips = (struct vert_strip *)bu_calloc( nstrips,
		sizeof(struct vert_strip), "strips[]" );
d1122 1
a1122 1
rt_ell_import( ip, ep, mat )
d1126 1
d1163 1
a1163 1
rt_ell_export( ep, ip, local2mm )
d1167 1
d1204 1
a1204 1
struct rt_db_internal	*ip;
d1300 1
a1300 1
struct bn_tol		*tol;
d1319 1
a1319 1
	struct vert_strip	*strips;
@


11.12
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.11 1999/07/02 22:19:22 mike Exp $ (BRL)";
d43 1
a43 1
struct bu_structparse rt_ell_parse[] = {
@


11.11
log
@
Removed dependence on compat4.h
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.10 1999/05/27 19:10:37 mike Exp $ (BRL)";
d1141 1
@


11.10
log
@
sed4
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.9 1997/06/17 19:24:43 gdurf Exp $ (BRL)";
d643 1
a643 1
	RT_ADD_VLIST( vhead, &top[15*ELEMENTS_PER_VECT], RT_VLIST_LINE_MOVE );
d645 1
a645 1
		RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], RT_VLIST_LINE_DRAW );
d648 1
a648 1
	RT_ADD_VLIST( vhead, &bottom[15*ELEMENTS_PER_VECT], RT_VLIST_LINE_MOVE );
d650 1
a650 1
		RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], RT_VLIST_LINE_DRAW );
d653 1
a653 1
	RT_ADD_VLIST( vhead, &middle[15*ELEMENTS_PER_VECT], RT_VLIST_LINE_MOVE );
d655 1
a655 1
		RT_ADD_VLIST( vhead, &middle[i*ELEMENTS_PER_VECT], RT_VLIST_LINE_DRAW );
@


11.9
log
@imported bu_structparse from tcl.c
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 11.8 1996/08/16 20:04:44 butler Exp gdurf $ (BRL)";
d206 1
a206 1
		rt_log("sph(%s):  zero length A(%g), B(%g), or C(%g) vector\n",
d222 1
a222 1
		rt_log("ell(%s):  A not perpendicular to B, f=%f\n",stp->st_name, f);
d227 1
a227 1
		rt_log("ell(%s):  B not perpendicular to C, f=%f\n",stp->st_name, f);
d232 1
a232 1
		rt_log("ell(%s):  A not perpendicular to C, f=%f\n",stp->st_name, f);
d237 1
a237 1
	GETSTRUCT( ell, ell_specific );
d247 2
a248 2
	mat_idn( ell->ell_SoR );
	mat_idn( R );
d254 1
a254 1
	mat_trn( Rinv, R );			/* inv of rot mat is trn */
d257 1
a257 1
	mat_idn( SS );
d263 2
a264 2
	mat_mul( mtemp, SS, R );
	mat_mul( ell->ell_invRSSR, Rinv, mtemp );
d324 2
a325 2
	mat_print("S o R", ell->ell_SoR );
	mat_print("invRSSR", ell->ell_invRSSR );
d379 1
a379 1
	RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d539 1
a539 1
	uvp->uv_u = mat_atan2( pprime[Y], pprime[X] ) * rt_inv2pi;
d546 1
a546 1
	uvp->uv_v = mat_atan2( pprime[Z],
d548 1
a548 1
		rt_invpi + 0.5;
d553 1
a553 1
		rt_inv2pi * r / stp->st_aradius;
d566 1
a566 1
	rt_free( (char *)ell, "ell_specific" );
d624 1
a624 1
struct rt_list		*vhead;
d627 1
a627 1
struct rt_tol		*tol;
d751 1
a751 1
struct rt_tol		*tol;
d787 1
a787 1
		rt_log("rt_ell_tess():  zero length A, B, or C vector\n");
d802 1
a802 1
		rt_log("ell():  A not perpendicular to B, f=%f\n", f);
d807 1
a807 1
		rt_log("ell():  B not perpendicular to C, f=%f\n", f);
d812 1
a812 1
		rt_log("ell():  A not perpendicular to C, f=%f\n", f);
d827 1
a827 1
	mat_idn( R );
d831 1
a831 1
	mat_trn( invR, R );			/* inv of rot mat is trn */
d835 1
a835 1
	mat_idn( S );
d839 1
a839 1
	mat_inv( invS, S );
d842 1
a842 1
	mat_mul( state.invRinvS, invR, invS );
d845 1
a845 1
	mat_mul( state.invRoS, invR, S );
d892 1
a892 1
	state.s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d895 1
a895 1
	nsegs = rt_halfpi / state.theta_tol + 0.999;
d904 1
a904 1
	strips = (struct vert_strip *)rt_calloc( nstrips,
d930 1
a930 1
		strips[i].vp = (struct vertex **)rt_calloc( strips[i].nverts,
d932 1
a932 1
		strips[i].norms = (vect_t *)rt_calloc( strips[i].nverts,
d938 1
a938 1
		strips[i].fu = (struct faceuse **)rt_calloc( strips[i].nfaces,
d960 1
a960 1
					rt_log("rt_ell_tess() nmg_cmface failure\n");
d970 1
a970 1
					rt_log("rt_ell_tess() nmg_cmface failure\n");
d993 1
a993 1
					rt_log("rt_ell_tess() nmg_cmface failure\n");
d1003 1
a1003 1
					rt_log("rt_ell_tess() nmg_cmface failure\n");
d1023 2
a1024 2
		cos_alpha = cos(alpha*rt_pi);
		sin_alpha = sin(alpha*rt_pi);
d1028 2
a1029 2
			cos_beta = cos(beta*rt_twopi);
			sin_beta = sin(beta*rt_twopi);
d1067 1
a1067 1
			for( RT_LIST_FOR( vu , vertexuse , &strips[i].vp[j]->vu_hd ) )
d1088 2
a1089 2
		rt_free( (char *)strips[i].vp, "strip vertex[]" );
		rt_free( (char *)strips[i].norms, "strip norms[]" );
d1094 1
a1094 1
		rt_free( (char *)strips[i].fu, "strip faceuse[]" );
d1096 1
a1096 1
	rt_free( (char *)strips, "strips[]" );
d1102 2
a1103 2
		rt_free( (char *)strips[i].vp, "strip vertex[]" );
		rt_free( (char *)strips[i].norms, "strip norms[]" );
d1108 1
a1108 1
		rt_free( (char *)strips[i].fu, "strip faceuse[]" );
d1110 1
a1110 1
	rt_free( (char *)strips, "strips[]" );
d1124 1
a1124 1
CONST struct rt_external	*ep;
d1131 1
a1131 1
	RT_CK_EXTERNAL( ep );
d1135 1
a1135 1
		rt_log("rt_ell_import: defective record\n");
d1141 1
a1141 1
	ip->idb_ptr = rt_malloc( sizeof(struct rt_ell_internal), "rt_ell_internal");
d1162 1
a1162 1
struct rt_external		*ep;
d1174 1
a1174 1
	RT_INIT_EXTERNAL(ep);
d1176 1
a1176 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "ell external");
d1200 1
a1200 1
struct rt_vls		*str;
d1213 1
a1213 1
	rt_vls_strcat( str, "ellipsoid (ELL)\n");
d1219 1
a1219 1
	rt_vls_strcat( str, buf );
d1230 1
a1230 1
	rt_vls_strcat( str, buf );
d1237 1
a1237 1
	rt_vls_strcat( str, buf );
d1244 1
a1244 1
	rt_vls_strcat( str, buf );
d1273 1
a1273 1
	rt_free( ip->idb_ptr, "ell ifree" );
d1297 1
a1297 1
struct rt_tol		*tol;
d1343 1
a1343 1
		rt_log("rt_ell_tess():  zero length A, B, or C vector\n");
d1358 1
a1358 1
		rt_log("ell():  A not perpendicular to B, f=%f\n", f);
d1363 1
a1363 1
		rt_log("ell():  B not perpendicular to C, f=%f\n", f);
d1368 1
a1368 1
		rt_log("ell():  A not perpendicular to C, f=%f\n", f);
d1383 1
a1383 1
	mat_idn( R );
d1387 1
a1387 1
	mat_trn( invR, R );			/* inv of rot mat is trn */
d1391 1
a1391 1
	mat_idn( S );
d1395 1
a1395 1
	mat_inv( invS, S );
d1398 1
a1398 1
	mat_mul( invRinvS, invR, invS );
d1401 1
a1401 1
	mat_mul( invRoS, invR, S );
d1410 1
a1410 1
	mat_idn( xlate );
d1412 1
a1412 1
	mat_mul( unit2model, xlate, invRinvS );
d1427 1
a1427 1
	s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d1435 1
a1435 1
		rt_log("rt_ell_tnurb(%s): nmg_cmface() fail on face\n");
d1440 1
a1440 1
	lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
d1442 1
a1442 1
	eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
d1449 1
a1449 1
		eu = RT_LIST_NEXT( edgeuse, &eu->l );
d1462 1
a1462 1
	eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
d1468 1
a1468 1
rt_log("\neu=x%x, vu=x%x, v=x%x  ", eu, eu->vu_p, eu->vu_p->v_p);
d1477 1
a1477 1
		eu = RT_LIST_NEXT( edgeuse, &eu->l );
@


11.8
log
@noting use of hardcoded constants
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 11.7 1996/07/12 17:12:11 jra Exp butler $ (BRL)";
d42 7
@


11.7
log
@Minor mod for IRIX 6.2
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 11.6 1996/05/08 15:31:06 jra Exp jra $ (BRL)";
d196 2
@


11.6
log
@corrected tolerancing for ELL tessellation.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 11.5 1995/11/30 16:16:23 mike Exp bparker $ (BRL)";
d43 2
d1481 1
@


11.5
log
@Trimming curve must be CCW.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 11.1 95/01/04 09:56:35 mike Rel4_4 $ (BRL)";
d849 2
a850 2
		/* Convert rel to absolute by scaling by diameter */
		rel = ttol->rel * 2 * radius;
d855 1
a855 1
			rel = 2 * 0.10 * radius;	/* 10% */
d862 1
d864 3
d1484 1
a1484 1
	FAST fastf_t root2_2 = sqrt(2.0) * 0.5;
d1488 1
@


11.4
log
@Exchanged matrix side-for-side, so that surface normal points
outwards.
@
text
@d1262 4
d1267 1
a1267 1
#if 0
d1271 1
a1271 10
	0, 1, 0,
	0, 0, 0
#else
	/* Somewhat surprisingly, the U parameter runs south to north */
	0, 0, 0,
	0, 1, 0,
	1, 1, 0,
	1, 0, 0,
	0, 0, 0
#endif
@


11.3
log
@Tentatively workging tess/tile tnurb routine
@
text
@d1542 3
a1544 3
	M( 0.5     , 0.5     ,-0.5     , 0.5     );
	M( root2_2 , root2_2 ,   0     , root2_2 );
	M( 0.5     , 0.5     , 0.5     , 0.5     );
d1548 3
a1550 3
	M(   0     , root2_2 ,-root2_2 , root2_2 );
	M(   0     , 1.0     ,   0     , 1.0     );
	M(   0     , root2_2 , root2_2 , root2_2 );
d1554 3
a1556 3
	M(-0.5     , 0.5     ,-0.5     , 0.5     );
	M(-root2_2 , root2_2 ,   0     , root2_2 );
	M(-0.5     , 0.5     , 0.5     , 0.5     );
d1566 3
a1568 3
	M(-0.5     ,-0.5     ,-0.5     , 0.5     );
	M(-root2_2 ,-root2_2 ,   0     , root2_2 );
	M(-0.5     ,-0.5     , 0.5     , 0.5     );
d1572 3
a1574 3
	M(   0     ,-root2_2 ,-root2_2 , root2_2 );
	M(   0     ,-1.0     ,   0     , 1.0     );
	M(   0     ,-root2_2 , root2_2 , root2_2 );
d1578 3
a1580 3
	M( 0.5     ,-0.5     ,-0.5     , 0.5     );
	M( root2_2 ,-root2_2 ,   0     , root2_2 );
	M( 0.5     ,-0.5     , 0.5     , 0.5     );
@


11.2
log
@First cut at ellipsoid/sphere tiling/tessellation.
Not quite right.
@
text
@d1263 1
d1269 8
d1401 2
a1402 2
	MAT_DELTAS_VEC_NEG( xlate, eip->v );
	mat_mul( unit2model, invRinvS, xlate );
d1411 2
d1455 11
d1472 1
d1476 4
@


11.1
log
@Release_4.4
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 10.10 94/09/30 16:24:32 mike Exp $ (BRL)";
d36 1
d1260 301
@


10.10
log
@Null out ip->idb_ptr after freeing memory in rt_*_ifree()
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 10.9 94/09/13 17:10:45 jra Exp Locker: mike $ (BRL)";
@


10.9
log
@Added call to VUNITIZE for vertexuse normals.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 10.8 94/09/13 15:49:20 jra Exp Locker: jra $ (BRL)";
d1258 1
@


10.8
log
@removed vertexuse normals from tesselator.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 10.7 94/09/09 11:03:47 jra Exp Locker: jra $ (BRL)";
d1026 2
@


10.7
log
@reversed vertexuse normals for OT_OPPOSITE faceuses (tesselator).
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 10.6 94/09/08 16:26:54 jra Exp Locker: jra $ (BRL)";
a1062 3

	/* Mark the edges as real */
	(void)nmg_mark_edges_real( &state.s->l );
@


10.6
log
@Added vertexuse normals and marked edges as real in tessellator.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 10.5 94/08/10 18:27:41 gdurf Exp Locker: jra $ (BRL)";
d1042 1
d1044 1
d1047 1
d1050 11
a1060 1
				nmg_vertexuse_nv( vu , strips[i].norms[j] );
@


10.5
log
@Added include of conf.h
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 10.4 1994/06/22 03:09:50 butler Exp gdurf $ (BRL)";
d695 1
d912 1
a912 1
	/* All strips have vertices */
d916 2
d1023 3
d1037 17
d1058 1
a1058 1
	/* All strips have vertices */
d1061 1
d1072 1
a1072 1
	/* All strips have vertices */
d1075 1
@


10.4
log
@more detailed error message
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 10.3 93/11/18 01:44:02 mike Exp Locker: butler $ (BRL)";
d26 2
@


10.3
log
@Added tol arg to bounding box routines
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 10.2 93/07/20 15:33:34 mike Exp $ (BRL)";
d192 2
a193 2
		rt_log("ell(%s):  zero length A, B, or C vector\n",
			stp->st_name );
@


10.2
log
@Eliminated comment within comment
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 10.1 91/10/12 06:40:15 mike Rel4_0 Locker: mike $ (BRL)";
d1030 1
a1030 1
	nmg_region_a( *r );
@


10.1
log
@Release_4.0
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.33 91/09/20 23:05:21 butler Exp $ (BRL)";
d646 11
a656 9
/* static point_t	octa_verts[6] = {
/* 	{ 1, 0, 0 },	/* XPLUS */
/* 	{-1, 0, 0 },	/* XMINUS */
/* 	{ 0, 1, 0 },	/* YPLUS */
/* 	{ 0,-1, 0 },	/* YMINUS */
/* 	{ 0, 0, 1 },	/* ZPLUS */
/* 	{ 0, 0,-1 }	/* ZMINUS */
/* };
 */
@


9.33
log
@removing fuzz with lint
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.32 91/09/13 13:20:56 mmark Exp $ (BRL)";
@


9.32
log
@changed "x/sqrt(x)" to "sqrt(x)" in a few places
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.31 91/07/11 15:34:01 jehunt Exp $ (BRL)";
a174 1
	int		i;
a619 1
	fastf_t	points[3*8];
d646 9
a654 8
static point_t	octa_verts[6] = {
	{ 1, 0, 0 },	/* XPLUS */
	{-1, 0, 0 },	/* XMINUS */
	{ 0, 1, 0 },	/* YPLUS */
	{ 0,-1, 0 },	/* YMINUS */
	{ 0, 0, 1 },	/* ZPLUS */
	{ 0, 0,-1 }	/* ZMINUS */
};
d664 15
a678 15
static struct usvert {
	int	a;
	int	b;
	int	c;
} octahedron[8] = {
    { XPLUS, ZPLUS, YPLUS },
    { YPLUS, ZPLUS, XMIN  },
    { XMIN , ZPLUS, YMIN  },
    { YMIN , ZPLUS, XPLUS },
    { XPLUS, YPLUS, ZMIN  },
    { YPLUS, XMIN , ZMIN  },
    { XMIN , YMIN , ZMIN  },
    { YMIN , XPLUS, ZMIN  }
};

@


9.31
log
@Added unit conversion for the magnitude of the A,B,C radii vectors in
rt_ell_describe()
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.30 91/06/30 00:10:48 mike Exp $ (BRL)";
d275 1
a275 1
	f = f / sqrt(f);
d284 1
a284 1
	f = f / sqrt(f);
d293 1
a293 1
	f = f / sqrt(f);
@


9.30
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.29 91/06/22 22:30:21 mike Exp $ (BRL)";
d1173 1
a1173 1
		mag_a );
d1180 1
a1180 1
		mag_b );
d1187 1
a1187 1
		mag_c );
@


9.29
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.28 91/06/12 20:57:41 mike Exp $ (BRL)";
d305 1
a305 1
register struct soltab *stp;
d1067 3
a1069 3
struct rt_db_internal	*ip;
struct rt_external	*ep;
register mat_t		mat;
d1106 3
a1108 3
struct rt_external	*ep;
struct rt_db_internal	*ip;
double			local2mm;
@


9.28
log
@nmg.h must come before raytrace.h
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.27 91/05/18 03:00:52 mike Exp $ (BRL)";
d38 1
a38 1
	struct rt_i *rtip, CONST struct rt_tol *tol));
d160 1
a160 1
rt_ell_prep( stp, ip, rtip, tol )
a163 1
CONST struct rt_tol	*tol;
d185 1
a185 1
	if( rt_sph_prep( stp, ip, rtip, tol ) == 0 )
d327 1
a327 1
rt_ell_shot( stp, rp, ap, seghead, tol )
a331 1
CONST struct rt_tol	*tol;
d378 1
a378 1
rt_ell_vshot( stp, rp, segp, n, resp, tol )
d383 1
a383 2
struct resource         *resp; /* pointer to a list of free segs */
CONST struct rt_tol	*tol;
@


9.27
log
@Converted to new tolerance interface
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.26 91/04/01 19:59:36 mike Exp $ (BRL)";
d32 1
a33 1
#include "nmg.h"
@


9.26
log
@Edges of loops now travel in a counter-clockwise (CCW) direction
around the face normal.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.25 91/02/07 20:32:19 mike Exp $ (BRL)";
d38 1
a38 1
	struct rt_i *rtip));
d160 1
a160 1
rt_ell_prep( stp, ip, rtip )
d164 1
d186 1
a186 1
	if( rt_sph_prep( stp, ip, rtip ) == 0 )
d328 1
a328 1
rt_ell_shot( stp, rp, ap, seghead )
d333 1
d380 1
a380 1
rt_ell_vshot( stp, rp, segp, n, resp)
d386 1
d613 5
a617 6
rt_ell_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
struct rt_list	*vhead;
struct rt_db_internal *ip;
double		abs_tol;
double		rel_tol;
double		norm_tol;
d733 1
a733 1
rt_ell_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d737 2
a738 3
double		abs_tol;
double		rel_tol;
double		norm_tol;
d763 1
d844 2
a845 2
	if( rel_tol <= 0.0 || rel_tol >= 1.0 )  {
		rel_tol = 0.0;		/* none */
d848 1
a848 1
		rel_tol *= 2*radius;
d850 2
a851 2
	if( abs_tol <= 0.0 )  {
		if( rel_tol <= 0.0 )  {
d853 1
a853 1
			abs_tol = 2 * 0.10 * radius;	/* 10% */
a855 1
			abs_tol = rel_tol;
d859 2
a860 2
		if( rel_tol > 0.0 && rel_tol < abs_tol )
			abs_tol = rel_tol;
d867 1
a867 1
	state.theta_tol = 2 * acos( 1.0 - abs_tol / radius );
d870 2
a871 3
	if( norm_tol > 0.0 && norm_tol < state.theta_tol )  {
		state.theta_tol = norm_tol;
		abs_tol = radius * ( 1 - cos( state.theta_tol * 0.5 ) );
d1026 1
a1026 1
			if( nmg_fu_planeeqn( strips[i].fu[j] ) < 0 )
@


9.25
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.24 91/01/28 23:53:09 mike Exp $ (BRL)";
d938 2
a939 2
				vertp[1] = &(strips[i].vp[(j+1+boff)%blim]);
				vertp[2] = &(strips[i-1].vp[(j+toff)%tlim]);
d948 2
a949 2
				vertp[1] = &(strips[i-1].vp[(j+1+toff)%tlim]);
				vertp[2] = &(strips[i-1].vp[(j+toff)%tlim]);
d971 2
a972 2
				vertp[1] = &(strips[i+1].vp[(j+toff)%tlim]);
				vertp[2] = &(strips[i].vp[(j+1+boff)%blim]);
d981 2
a982 2
				vertp[1] = &(strips[i+1].vp[(j+toff)%tlim]);
				vertp[2] = &(strips[i+1].vp[(j+1+toff)%tlim]);
d1026 2
a1027 1
			rt_mk_nmg_planeeqn( strips[i].fu[j] );
@


9.24
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.23 91/01/26 03:14:45 mike Exp $ (BRL)";
d875 1
a875 1
	state.s = NMG_LIST_FIRST(shell, &(*r)->s_hd);
@


9.23
log
@Eliminated mat parameter on ft_plot and ft_tess
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.22 91/01/25 21:52:05 mike Exp $ (BRL)";
d611 1
a611 1
struct vlhead	*vhead;
d632 1
a632 1
	ADD_VL( vhead, &top[15*ELEMENTS_PER_VECT], 0 );
d634 1
a634 1
		ADD_VL( vhead, &top[i*ELEMENTS_PER_VECT], 1 );
d637 1
a637 1
	ADD_VL( vhead, &bottom[15*ELEMENTS_PER_VECT], 0 );
d639 1
a639 1
		ADD_VL( vhead, &bottom[i*ELEMENTS_PER_VECT], 1 );
d642 1
a642 1
	ADD_VL( vhead, &middle[15*ELEMENTS_PER_VECT], 0 );
d644 1
a644 1
		ADD_VL( vhead, &middle[i*ELEMENTS_PER_VECT], 1 );
@


9.22
log
@lint
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.21 91/01/25 21:18:48 mike Exp $ (BRL)";
d610 1
a610 1
rt_ell_plot( vhead, mat, ip, abs_tol, rel_tol, norm_tol )
a611 1
mat_t		mat;
d731 1
a731 1
rt_ell_tess( r, m, ip, mat, abs_tol, rel_tol, norm_tol )
a734 1
register mat_t		mat;
@


9.21
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.20 91/01/25 20:35:34 mike Exp $ (BRL)";
d37 2
a38 1
extern int rt_sph_prep();
d370 1
a371 2
#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	

d410 1
a410 1
			SEG_MISS(segp[i]);		/* No hit */
@


9.20
log
@Added rt_ prefix to _internal structure
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.19 91/01/25 16:04:42 mike Exp $ (BRL)";
a157 1
#if NEW_IF
a163 10
#else
int
rt_ell_prep( stp, rec, rtip )
struct soltab		*stp;
union record		*rec;
struct rt_i		*rtip;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a175 12
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rec;
	ep->ext_nbytes = stp->st_dp->d_len*sizeof(union record);
	ip = &intern;
	if( rt_ell_import( ip, ep, stp->st_pathmat ) < 0 )
		return(-1);		/* BAD */
	RT_CK_DB_INTERNAL( ip );
#endif
a608 1
#if NEW_IF
a617 14
#else
int
rt_ell_plot( rp, mat, vhead, dp, abs_tol, rel_tol, norm_tol )
union record		*rp;
register mat_t		mat;
struct vlhead		*vhead;
struct directory	*dp;
double			abs_tol;
double			rel_tol;
double			norm_tol;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a624 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_ell_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_ell_plot(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
a730 1
#if NEW_IF
a740 15
#else
int
rt_ell_tess( r, m, rp, mat, dp, abs_tol, rel_tol, norm_tol )
struct nmgregion	**r;
struct model		*m;
register union record	*rp;
register mat_t		mat;
struct directory	*dp;
double			abs_tol;
double			rel_tol;
double			norm_tol;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a764 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_ell_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_ell_tess(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
d774 1
a774 2
		rt_log("rt_ell_tess(%s):  zero length A, B, or C vector\n",
			dp->d_namep );
d789 1
a789 1
		rt_log("ell(%s):  A not perpendicular to B, f=%f\n",dp->d_namep, f);
d794 1
a794 1
		rt_log("ell(%s):  B not perpendicular to C, f=%f\n",dp->d_namep, f);
d799 1
a799 1
		rt_log("ell(%s):  A not perpendicular to C, f=%f\n",dp->d_namep, f);
@


9.19
log
@Added fallback angle stuff to the _describe routine
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.18 91/01/15 23:45:45 mike Exp $ (BRL)";
d176 1
a176 1
	struct ell_internal	*eip;
d199 1
a199 1
	eip = (struct ell_internal *)ip->idb_ptr;
d657 1
a657 1
	struct ell_internal	*eip;
d678 1
a678 1
	eip = (struct ell_internal *)ip->idb_ptr;
d736 1
a736 1
	struct ell_internal	*eip;
d848 1
a848 1
	state.eip = (struct ell_internal *)ip->idb_ptr;
d1158 1
a1158 1
	struct ell_internal	*eip;
d1172 2
a1173 2
	ip->idb_ptr = rt_malloc( sizeof(struct ell_internal), "ell_internal");
	eip = (struct ell_internal *)ip->idb_ptr;
d1197 1
a1197 1
	struct ell_internal	*tip;
d1202 1
a1202 1
	tip = (struct ell_internal *)ip->idb_ptr;
d1236 2
a1237 2
	register struct ell_internal	*tip =
		(struct ell_internal *)ip->idb_ptr;
@


9.18
log
@Changed to new import/export interface
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.17 90/10/06 02:05:11 mike Exp $ (BRL)";
d1238 1
d1240 2
d1252 4
d1260 1
a1260 1
		MAGNITUDE(tip->a) );
d1267 1
a1267 1
		MAGNITUDE(tip->b) );
d1274 1
a1274 1
		MAGNITUDE(tip->c) );
d1276 14
@


9.17
log
@Converted seg structures to use doubly linked lists.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.16 90/05/21 13:12:50 mike Exp $ (BRL)";
d34 1
d141 1
a142 8
/* Should be in a header file to share betwee g_ell.c and g_sph.c */
struct ell_internal  {
	point_t	v;
	vect_t	a;
	vect_t	b;
	vect_t	c;
};

a143 33
 *			R T _ E L L _ I M P O R T
 *
 *  Import an ellipsoid/sphere from the database format to
 *  the internal structure.
 *  Apply modeling transformations as well.
 */
int
rt_ell_import( eip, rp, mat )
struct ell_internal	*eip;
union record		*rp;
register mat_t		mat;
{
	LOCAL fastf_t	vec[3*4];

	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		rt_log("rt_ell_import: defective record\n");
		return(-1);
	}

	/* Convert from database to internal format */
	rt_fastf_float( vec, rp->s.s_values, 4 );

	/* Apply modeling transformations */
	MAT4X3PNT( eip->v, mat, &vec[0*3] );
	MAT4X3VEC( eip->a, mat, &vec[1*3] );
	MAT4X3VEC( eip->b, mat, &vec[2*3] );
	MAT4X3VEC( eip->c, mat, &vec[3*3] );

	return(0);		/* OK */
}

/*
d158 1
d160 7
d172 3
d176 1
a184 1
	struct ell_internal ei;
d187 15
d207 1
a207 1
	if( rt_sph_prep( stp, rec, rtip ) == 0 )
a209 12
	if( rec == (union record *)0 )  {
		rec = db_getmrec( rtip->rti_dbip, stp->st_dp );
		i = rt_ell_import( &ei, rec, stp->st_pathmat );
		rt_free( (char *)rec, "ell record" );
	} else {
		i = rt_ell_import( &ei, rec, stp->st_pathmat );
	}
	if( i < 0 )  {
		rt_log("rt_ell_setup(%s): db import failure\n", stp->st_name);
		return(-1);		/* BAD */
	}

d211 3
a213 3
	magsq_a = MAGSQ( ei.a );
	magsq_b = MAGSQ( ei.b );
	magsq_c = MAGSQ( ei.c );
d222 1
a222 1
	VSCALE( Au, ei.a, f );
d224 1
a224 1
	VSCALE( Bu, ei.b, f );
d226 1
a226 1
	VSCALE( Cu, ei.c, f );
d249 1
a249 1
	VMOVE( ell->ell_V, ei.v );
d276 3
a278 3
	VSCALE( &ell->ell_SoR[0], ei.a, ell->ell_invsq[0] );
	VSCALE( &ell->ell_SoR[4], ei.b, ell->ell_invsq[1] );
	VSCALE( &ell->ell_SoR[8], ei.c, ell->ell_invsq[2] );
d281 1
a281 1
	VMOVE( stp->st_center, ei.v );
d322 3
d586 1
a586 1
 *			E L L _ 1 6 P T S
d592 1
a592 1
ell_16pts( ov, V, A, B )
d632 1
d634 10
d653 3
d657 1
a657 1
	struct ell_internal	ei;
d663 11
a673 3
	if( rt_ell_import( &ei, rp, mat ) < 0 )  {
		rt_log("rt_ell_plot(%s): db import failure\n", dp->d_namep);
		return(-1);
d675 5
d681 3
a683 3
	ell_16pts( top, ei.v, ei.a, ei.b );
	ell_16pts( bottom, ei.v, ei.b, ei.c );
	ell_16pts( middle, ei.v, ei.a, ei.c );
d736 1
a736 1
	struct ell_internal	ei;
d783 1
d785 11
d806 3
d833 11
a843 3
	if( rt_ell_import( &state.ei, rp, mat ) < 0 )  {
		rt_log("rt_ell_tess(%s): import failure\n", dp->d_namep);
		return(-1);
d845 5
d852 3
a854 3
	magsq_a = MAGSQ( state.ei.a );
	magsq_b = MAGSQ( state.ei.b );
	magsq_c = MAGSQ( state.ei.c );
d863 1
a863 1
	VSCALE( Au, state.ei.a, invAlen );
d865 1
a865 1
	VSCALE( Bu, state.ei.b, invBlen );
d867 1
a867 1
	VSCALE( Cu, state.ei.c, invClen );
d892 1
a892 1
			VREVERSE( state.ei.c, state.ei.c );
d1102 1
a1102 1
			VADD2( model_pt, model_pt, state.ei.v );
d1143 141
@


9.16
log
@Eliminated diagnostic printing
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: /m/cad/librt/RCS/g_ell.c,v 9.15 90/05/18 07:25:36 butler Exp $ (BRL)";
d368 1
a368 1
 *  	segp	HIT
d370 2
a371 2
struct seg *
rt_ell_shot( stp, rp, ap )
d375 1
d396 1
a396 1
		return(SEG_NULL);		/* No hit */
d399 1
a399 1
	GET_SEG(segp, ap->a_resource);
d410 2
a411 1
	return(segp);			/* HIT */
a459 1
			segp[i].seg_next = SEG_NULL;
@


9.15
log
@Halfway converted to new double-linked-list structures ;-)
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 9.14 90/05/07 20:59:58 mike Locked $ (BRL)";
a732 2
	fastf_t		hunt_tol;
	fastf_t		hunt_tol_sq;
a833 4
rt_log("ell radii A=%g, B=%g, C=%g\n", Alen, Blen, Clen);
VPRINT("Au", Au);
VPRINT("Bu", Bu);
VPRINT("Cu", Cu);
a855 1
rt_log("AxB dot C = %g\n", f);
a878 7
#if 0
mat_print("R", R);
mat_print("invR", invR);
mat_print("S", S);
mat_print("invS", invS);
mat_print("invRinvS", state.invRinvS);
#endif
d912 1
a916 1
	
a917 1
rt_log("ell abs_tol=%g, state.theta_tol=%g\n", abs_tol, state.theta_tol);
a922 1
rt_log("norm_tol abs_tol=%g, state.theta_tol=%g\n", abs_tol, state.theta_tol);
a923 4

	state.hunt_tol = abs_tol * 0.01;
	state.hunt_tol_sq = state.hunt_tol * state.hunt_tol;
rt_log("hunt_tol = %g, hunt_tol_sq=%g\n", state.hunt_tol, state.hunt_tol_sq);
@


9.14
log
@Fixed pointer warning problem.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 9.13 90/05/04 17:42:11 mike Locked $ (BRL)";
d946 1
a946 1
	state.s = m->r_p->s_p;
@


9.13
log
@This version works.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 9.10 90/05/02 05:42:43 mike Locked $ (BRL)";
d1111 1
a1111 1
		if( strips[i].fu == (struct faceuse *)0 )  continue;
d1124 1
a1124 1
		if( strips[i].fu == (struct faceuse *)0 )  continue;
@


9.12
log
@This version is solid, but has one damaged row of faces.
@
text
@a741 1
	int		nfaces_per_strip;
d954 2
d964 1
a964 3
	strips[0].nfaces = 0;
	strips[0].nfaces_per_strip = 0;
	strips[0].fu = (struct faceuse **)0;
d968 1
a968 3
	strips[nstrips-1].nfaces = 0;
	strips[nstrips-1].nfaces_per_strip = 0;
	strips[nstrips-1].fu = (struct faceuse **)0;
d972 1
a972 2
	strips[nsegs].nfaces_per_strip = 2 * nsegs - 1;
	strips[nsegs].nfaces = (2 * nsegs - 1)*4;
a978 2
		strips[i].nfaces_per_strip =
			strips[nstrips-1-i].nfaces_per_strip = 2 * i - 1;
d980 1
a980 1
			strips[nstrips-1-i].nfaces = (2 * i - 1)*4;
d987 3
a989 2
	/* All strips have faces, except for the poles */
	for( i=1; i < nstrips-1; i++ )  {
d1011 1
a1011 1
				if( (strips[i].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
d1021 1
a1021 1
				if( (strips[i].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
d1044 1
a1044 1
				if( (strips[i].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
d1054 1
a1054 1
				if( (strips[i].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
d1071 2
a1077 2
			point_t		sphere_pt;
			point_t		model_pt;
d1090 1
a1090 2
			if( strips[i].vp[j] )
				nmg_vertex_gv( strips[i].vp[j], model_pt );
d1094 2
a1095 2
	/* Associate face geometry.  Poles have no faces "above" them. */
	for( i=1; i < nstrips-1; i++ )  {
d1097 1
a1097 2
			if( strips[i].fu[j] )
				rt_mk_nmg_planeeqn( strips[i].fu[j] );
d1109 3
a1111 2
	/* All strips have faces, except for the poles */
	for( i=1; i < nstrips-1; i++ )  {
d1122 3
a1124 2
	/* All strips have faces, except for the poles */
	for( i=1; i < nstrips-1; i++ )  {
@


9.11
log
@This version has begun to work.
@
text
@d807 7
d957 2
a958 2
	strips = (struct vert_strip *)rt_malloc(
		nstrips * sizeof(struct vert_strip), "strips[]" );
d1000 5
a1004 13
	/* XXX top half only -- other half is upside-down! */
	for( i = 1; i < nsegs+1; i++ )  {
		int	faceno = 0;
		int	stripno;
		int	boff;		/* base offset */
		int	toff;		/* top offset */
		struct vertex		**vertp[4];

#if 0
rt_log("\n*** STRIP i=%d, nverts=%d, nverts_per_strip=%d, nfaces=%d, nfaces_per_strip=%d\n",
i, strips[i].nverts, strips[i].nverts_per_strip,
strips[i].nfaces, strips[i].nfaces_per_strip );
#endif
a1010 3
#if 0
rt_log("  i=%d, stripno=%d, boff=%d, toff=%d, j=%d\n", i, stripno, boff, toff, j);
#endif
d1014 2
a1015 6
				vertp[1] = &(strips[i-1].vp[(j+toff)%strips[i-1].nverts]);
				vertp[2] = &(strips[i].vp[(j+1+boff)%strips[i].nverts]);
#if 0
rt_log("\t%d/%d\\%d\n",
	j+boff, (j+toff)%strips[i-1].nverts, (j+1+boff)%strips[i].nverts );
#endif
d1018 1
a1018 1
					faceno--;
d1023 3
a1025 9
				vertp[0] = &(strips[i].vp[(j+1+boff)%strips[i].nverts]);
				vertp[1] = &(strips[i-1].vp[(j+toff)%strips[i-1].nverts]);
				vertp[2] = &(strips[i-1].vp[(j+1+toff)%strips[i-1].nverts]);
#if 0
rt_log("\t\t%d\\%d/%d\n",
	(j+1+boff)%strips[i].nverts,
	(j+toff)%strips[i-1].nverts,
	(j+1+toff)%strips[i-1].nverts );
#endif
d1028 1
a1028 1
					faceno--;
d1032 32
a1063 2
		if( faceno != strips[i].nfaces )  {
			rt_log("seg=%d, faceno=%d != nfaces=%d\n", i, faceno, strips[i].nfaces );
d1071 1
a1071 2
	/* XXX top half only */
	for( i=0; i < nsegs+1; i++ )  {
a1075 1
		point_t		P, Q;
a1079 4
		VSET( P, sin_alpha, cos_alpha, 0 );
		VSET( Q,         0, cos_alpha, sin_alpha );
VPRINT("P", P);
VPRINT("Q", Q);
a1093 3
rt_log("    i=%d, j=%d, alpha=%g, beta=%g, cos_beta=%g, sin_beta=%g\n",
i, j, alpha, beta, cos_beta, sin_beta );
VPRINT("	sphere_pt", sphere_pt);
d1096 1
a1096 1
				nmg_vertex_gv( strips[i].vp[j], sphere_pt );
a1098 7
	{
		/* Hack for spike at +B */
		point_t	p;
		VSETALL( p, 0 );
		VPRINT("+B vertex", strips[0].vp[0]->vg_p->coord );
		nmg_vertex_gv(strips[0].vp[0], p );
	}
d1100 2
a1101 2
	/* Associate face geometry */
	for( i=1; i < nsegs+1; i++ )  {
a1109 1
rt_log("ell done\n");
d1111 4
a1114 21
	return(0);
}

#if 0

extern struct vertex *rt_nmg_find_pt_in_shell(); /* XXX from g_pg.c */

struct faceuse *
rt_ell_generate_face( a, b, c, s )
struct vertex	**a, **b, **c;
struct shell	*s;
{
	struct vertex		**vertp[4];
	struct faceuse		*fu;

	vertp[0] = a;
	vertp[1] = b;
	vertp[2] = c;
	if( (fu = nmg_cmface(s, vertp, 3 )) == 0 )  {
		rt_log("rt_ell_generate_face() nmg_cmface failure\n");
		return(NULL);
d1116 3
a1118 60
	return(fu);
}

rt_ell_refine( a, b, c, statep, lvl )
point_t	a;
point_t	b;
point_t	c;
struct ell_state	*statep;
int	lvl;
{
	point_t			d, e, f;
	struct vertex		*verts[6];
	struct faceuse		*fu1, *fu2, *fu3, *fu4;
	point_t			model[6];
	int			i;
	point_t			midpt;
	fastf_t			max_theta;
	fastf_t			dot, cos_max_theta, rhs;

rt_log("rt_ell_refine(%g,%g,%g) (%g,%g,%g) (%g,%g,%g)\n",
a[X], a[Y], a[Z], b[X], b[Y], b[Z], c[X], c[Y], c[Z] );
	VADD2SCALE( d, a, b, 0.5 );
	VADD2SCALE( e, b, c, 0.5 );
	VADD2SCALE( f, a, c, 0.5 );
	/* Normalize */
	VUNITIZE( d );
	VUNITIZE( e );
	VUNITIZE( f );

	/* At the midpoint between D and E, find the appropriate
	 * angular tolerance to use.  X in the unit sphere is A in
	 * model space, and Y -> B, Z -> C.  Thus, the correct angular
	 * tolerance is a linear combination of the tolerances needed
	 * when exactly along the A, B, or C axis.
	 */
	VADD2SCALE( midpt, d, e, 0.5 );
	VUNITIZE( midpt );
	if( midpt[X] < 0 )  midpt[X] = -midpt[X];
	if( midpt[Y] < 0 )  midpt[Y] = -midpt[Y];
	if( midpt[Z] < 0 )  midpt[Z] = -midpt[Z];
	/* Reduction sum of product of elements, not a vector dot product */
	max_theta = VDOT( midpt, statep->theta_tol );

	/* Account for normal tolerance */
	if( max_theta > statep->normal_theta )  max_theta = statep->normal_theta;

	/*  Measure angle between D and E in model space.
	 *  Don't bother adding and then subtracting the center, V.
	 *  If angle is greater than the angle tolerance, recurse.
	 */
	MAT4X3PNT( model[3], statep->invRinvS, d );
	MAT4X3PNT( model[4], statep->invRinvS, e );
	{
		point_t	p3, p4;
		VMOVE( p3, model[3] );
		VMOVE( p4, model[4] );
		VUNITIZE( p3 );
		VUNITIZE( p4 );
		dot = VDOT( p3, p4 );
		/* as 'dot' becomes less than 1, the angle increases */
d1120 7
a1126 10
	cos_max_theta = cos(max_theta);
	rhs = cos_max_theta;

	if( lvl < 4 && dot < cos_max_theta )  {
		/* Refine further */
		rt_ell_refine( a, d, f, statep, lvl+1 );
		rt_ell_refine( d, b, e, statep, lvl+1 );
		rt_ell_refine( e, c, f, statep, lvl+1 );
		rt_ell_refine( f, d, e, statep, lvl+1 );
		return;
d1128 3
a1130 9

	/* Convert rest of points to model space */
	MAT4X3PNT( model[0], statep->invRinvS, a );
	MAT4X3PNT( model[1], statep->invRinvS, b );
	MAT4X3PNT( model[2], statep->invRinvS, c );
	/* 3 and 4 are already done */
	MAT4X3PNT( model[5], statep->invRinvS, f );
	for( i=0; i<6; i++ )  {
		VADD2( model[i], model[i], statep->ei.v );
d1132 2
a1133 22

	/* Attempt to share vertices with other faces */
	for( i=0; i<6; i++ )  {
		verts[i] = rt_nmg_find_pt_in_shell( statep->s, model[i], statep->hunt_tol_sq );
	}

	/* Generate the 4 faces, 3 verts each */
	fu1 = rt_ell_generate_face( &verts[0], &verts[3], &verts[5], statep->s );
	fu2 = rt_ell_generate_face( &verts[3], &verts[1], &verts[4], statep->s );
	fu3 = rt_ell_generate_face( &verts[4], &verts[2], &verts[5], statep->s );
	fu4 = rt_ell_generate_face( &verts[5], &verts[3], &verts[4], statep->s );

	/* Associate vertex geometry */
	for( i=0; i<6; i++ )  {
		if( ! verts[i]->vg_p )  nmg_vertex_gv( verts[i], model[i] );
	}

	/* Associate face geometry */
	rt_mk_nmg_planeeqn( fu1 );
	rt_mk_nmg_planeeqn( fu2 );
	rt_mk_nmg_planeeqn( fu3 );
	rt_mk_nmg_planeeqn( fu4 );
a1134 238

/*
 * sphere - generate a polygon mesh approximating a sphere by
 *  recursive subdivision. First approximation is an octahedron;
 *  each level of refinement increases the number of polygons by
 *  a factor of 4.
 * Level 3 (128 polygons) is a good tradeoff if gouraud
 *  shading is used to render the database.
 *
 * Usage: sphere [level]
 *	level is an integer >= 1 setting the recursion level (default 1).
 *
 * Notes:
 *
 *  The triangles are generated with vertices in clockwise order as
 *  viewed from the outside in a right-handed coordinate system.
 *  To reverse the order, compile with COUNTERCLOCKWISE defined.
 *
 *  Shared vertices are not retained, so numerical errors may produce
 *  cracks between polygons at high subdivision levels.
 *
 *  The subroutines print_object() and print_triangle() should
 *  be changed to generate whatever the desired database format is.
 *  If UNC is defined, a PPHIGS text archive is generated.
 *
 * Jon Leech 3/24/89
 */
#include <stdio.h>
#include <math.h>
#include <gl.h>

typedef struct {
    double  x, y, z;
} point;

typedef struct {
    point     pt[3];	/* Vertices of triangle */
    double    area;	/* Unused; might be used for adaptive subdivision */
} triangle;

typedef struct {
    int       npoly;	/* # of polygons in object */
    triangle *poly;	/* Polygons in no particular order */
} object;

/* Six equidistant points lying on the unit sphere */
#define XPLUS {  1,  0,  0 }	/*  X */
#define XMIN  { -1,  0,  0 }	/* -X */
#define YPLUS {  0,  1,  0 }	/*  Y */
#define YMIN  {  0, -1,  0 }	/* -Y */
#define ZPLUS {  0,  0,  1 }	/*  Z */
#define ZMIN  {  0,  0, -1 }	/* -Z */

/* Vertices of a unit octahedron */
triangle octahedron[] = {
    { XPLUS, ZPLUS, YPLUS }, 0.0,
    { YPLUS, ZPLUS, XMIN  }, 0.0,
    { XMIN , ZPLUS, YMIN  }, 0.0,
    { YMIN , ZPLUS, XPLUS }, 0.0,
    { XPLUS, YPLUS, ZMIN  }, 0.0,
    { YPLUS, XMIN , ZMIN  }, 0.0,
    { XMIN , YMIN , ZMIN  }, 0.0,
    { YMIN , XPLUS, ZMIN  }, 0.0
};

/* An octahedron */
object oct = {
    sizeof(octahedron) / sizeof(octahedron[0]),
    &octahedron[0]
};

/* Forward declarations */
point *normalize(/* point *p */);
point *midpoint(/* point *a, point *b */);
void print_object(/* object *obj, int level */);
void print_triangle(/* triangle *t */);
double sqr(/* double x */);
double area_of_triangle(/* triangle *t */);

extern char *malloc(/* unsigned */);
object *old;
int maxlevels;
void disp_object();

main(ac, av)
int ac;
char *av[];
{
    object *new;
    int     i, level;
    double min[3], max[3];
    maxlevels = 1;

    if (ac > 1)
	if ((maxlevels = atoi(av[1])) < 1) {
	    fprintf(stderr, "%s: # of levels must be >= 1\n", av[0]);
	    exit(1);
	}

    

#ifdef COUNTERCLOCKWISE
    /* Reverse order of points in each triangle */
    for (i = 0; i < oct.npoly; i++) {
	point tmp;
		      tmp = oct.poly[i].pt[0];
	oct.poly[i].pt[0] = oct.poly[i].pt[2];
	oct.poly[i].pt[2] = tmp;
    }
#endif

    old = &oct;

    /* Subdivide each starting triangle (maxlevels - 1) times */
    for (level = 1; level < maxlevels; level++) {
	/* Allocate a new object */
	new = (object *)malloc(sizeof(object));
	if (new == NULL) {
	    fprintf(stderr, "%s: Out of memory on subdivision level %d\n",
		av[0], level);
	    exit(1);
	}
	new->npoly = old->npoly * 4;

	/* Allocate 4* the number of points in the current approximation */
	new->poly  = (triangle *)malloc(new->npoly * sizeof(triangle));
	if (new->poly == NULL) {
	    fprintf(stderr, "%s: Out of memory on subdivision level %d\n",
		av[0], level);
	    exit(1);
	}

	/* Subdivide each polygon in the old approximation and normalize
	 *  the new points thus generated to lie on the surface of the unit
	 *  sphere.
	 * Each input triangle with vertices labelled [0,1,2] as shown
	 *  below will be turned into four new triangles:
	 *
	 *			Make new points
	 *			    a = (0+2)/2
	 *			    b = (0+1)/2
	 *			    c = (1+2)/2
	 *	  1
	 *	 /\		Normalize a, b, c
	 *	/  \
	 *    b/____\ c		Construct new triangles
	 *    /\    /\		    [0,b,a]
	 *   /	\  /  \		    [b,1,c]
	 *  /____\/____\	    [a,b,c]
	 * 0	  a	2	    [a,c,2]
	 */
	for (i = 0; i < old->npoly; i++) {
	    triangle
		 *oldt = &old->poly[i],
		 *newt = &new->poly[i*4];
	    point a, b, c;

	    a = *normalize(midpoint(&oldt->pt[0], &oldt->pt[2]));
	    b = *normalize(midpoint(&oldt->pt[0], &oldt->pt[1]));
	    c = *normalize(midpoint(&oldt->pt[1], &oldt->pt[2]));

	    newt->pt[0] = oldt->pt[0];
	    newt->pt[1] = b;
	    newt->pt[2] = a;
	    newt++;

	    newt->pt[0] = b;
	    newt->pt[1] = oldt->pt[1];
	    newt->pt[2] = c;
	    newt++;

	    newt->pt[0] = a;
	    newt->pt[1] = b;
	    newt->pt[2] = c;
	    newt++;

	    newt->pt[0] = a;
	    newt->pt[1] = c;
	    newt->pt[2] = oldt->pt[2];
	}

	if (level > 1) {
	    free(old->poly);
	    free(old);
	}

	/* Continue subdividing new triangles */
	old = new;
    }

    disp_Init();
	
    min[0] = -2;
    min[1] = -2;
    min[2] = -2;

    max[0] = 2;
    max[1] = 2;
    max[2] = 2;

    disp_Autoscale(min, max);
    /* Print out resulting approximation */
    disp_Viewloop( disp_object);

}

/* Normalize a point p */
point *normalize(p)
point *p;
{
    static point r;
    double mag;

    r = *p;
    mag = r.x * r.x + r.y * r.y + r.z * r.z;
    if (mag != 0.0) {
	mag = 1.0 / sqrt(mag);
	r.x *= mag;
	r.y *= mag;
	r.z *= mag;
    }

    return &r;
}

/* Return the average of two points */
point *midpoint(a, b)
point *a, *b;
{
    static point r;

    r.x = (a->x + b->x) * 0.5;
    r.y = (a->y + b->y) * 0.5;
    r.z = (a->z + b->z) * 0.5;

    return &r;
}
#endif
@


9.10
log
@This version recurses, but has !!!cracks!!!
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 9.9 90/05/01 05:21:12 mike Locked $ (BRL)";
d735 1
a735 2
	vect_t		theta_tol;
	fastf_t		normal_theta;
d738 9
d761 15
d803 4
d831 3
d852 11
d892 5
a896 6
	f = magsq_a;
	if( magsq_b > f )
		f = magsq_b;
	if( magsq_c > f )
		f = magsq_c;
	radius = sqrt(f);
d910 1
a910 1
			abs_tol = 0.2*radius;	/* 10% */
d920 7
a926 6
rt_log("ell abs_tol=%g\n", abs_tol);
	VSET( state.theta_tol,
		2 * acos( 1.0 - abs_tol / Alen ),
		2 * acos( 1.0 - abs_tol / Blen ),
		2 * acos( 1.0 - abs_tol / Clen ) );
VPRINT("state.theta_tol", state.theta_tol );
d928 5
a932 5
	if( norm_tol > 0.0 )  {
		/* To ensure normal tolerance, remain below this angle */
		state.normal_theta = norm_tol;
	} else {
		state.normal_theta = rt_twopi;	/* monsterously large */
a933 1
rt_log("normal_theta = %g (%g deg)\n", state.normal_theta, state.normal_theta * rt_radtodeg);
d942 38
a979 8
	/* Recurse on each of the 8 faces of the octahedron */
	for( i=0; i<8; i++ )  {
		register struct usvert *ohp = &octahedron[i];
		rt_ell_refine(
			octa_verts[ohp->a],
			octa_verts[ohp->b],
			octa_verts[ohp->c],
			&state, 0 );
d981 10
d992 116
d1115 2
a1154 16
	/*
	 *  At the start, points ABC lie on surface of the unit sphere.
	 *  Pick DEF as the midpoints of the three edges of ABC.
	 *  Normalize the new points to lie on surface of the unit sphere.
	 *
	 *	  1
	 *	  B
	 *	 /\
	 *    3 /  \ 4
	 *    D/____\E
	 *    /\    /\
	 *   /	\  /  \
	 *  /____\/____\
	 * A      F     C
	 * 0      5     2
	 */
a1239 1
#if 0
@


9.9
log
@SPH routines got rt_ prefix
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 9.8 90/05/01 04:59:30 mike Locked $ (BRL)";
d696 8
d728 11
d744 9
d768 10
a777 2
	struct shell		*s;
	struct ell_internal	ei;
d779 1
a779 8
	struct faceuse		*outfaceuses[8];
	struct vertex		*verts[6];
	struct vertex		*vertlist[6];
	struct vertex		**vertp[4];
	struct edgeuse		*eu;
	int			face;
	plane_t			plane;
	point_t			pt;
d781 1
a781 1
	if( rt_ell_import( &ei, rp, mat ) < 0 )  {
d786 9
a794 1
	for( i=0; i<6; i++ )  verts[i] = (struct vertex *)0;
d796 103
d900 1
a900 1
	s = m->r_p->s_p;
d902 1
a902 1
	/* Build all 8 faces of the octahedron, 3 verts each */
d905 5
a909 4
		vertp[0] = &verts[ohp->a];
		vertp[1] = &verts[ohp->b];
		vertp[2] = &verts[ohp->c];
		outfaceuses[i] = nmg_cmface(s, vertp, 3 );
d912 60
a971 2
	/* Associate initial vertex geometry:
	 * Six points lying on the ellipsoid.
d973 7
a979 4
	VADD2( pt, ei.v, ei.a );
	nmg_vertex_gv(verts[XPLUS], pt );
	VSUB2( pt, ei.v, ei.a );
	nmg_vertex_gv(verts[XMIN], pt );
d981 13
a993 4
	VADD2( pt, ei.v, ei.b );
	nmg_vertex_gv(verts[YPLUS], pt );
	VSUB2( pt, ei.v, ei.b );
	nmg_vertex_gv(verts[YMIN], pt );
d995 2
a996 4
	VADD2( pt, ei.v, ei.c );
	nmg_vertex_gv(verts[ZPLUS], pt );
	VSUB2( pt, ei.v, ei.c );
	nmg_vertex_gv(verts[ZMIN], pt );
d998 14
a1011 3
	/* Associate face geometry */
	for (i=0 ; i < 8 ; ++i) {
		rt_mk_nmg_planeeqn( outfaceuses[i] );
d1013 2
d1016 8
a1023 2
	/* Glue the edges of different outward pointing face uses together */
	nmg_gluefaces( outfaceuses, 8 );
d1025 9
a1033 2
	/* Compute "geometry" for region and shell */
	nmg_region_a( *r );
d1035 21
a1055 1
	return(0);
@


9.8
log
@Converted to nmg_cmface.
All routines got rt_ prefix
Added provisions for tolerances.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 9.7 90/04/28 02:08:51 mike Locked $ (BRL)";
d36 1
a36 1
extern int sph_prep();
d220 1
a220 1
	if( sph_prep( stp, rec, rtip ) == 0 )
@


9.7
log
@removed calls to nmg_ck_closed_surf from geometry module tesselators
@
text
@d2 1
a2 1
 *			E L L . C
d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 9.6 90/03/15 01:58:18 butler Locked $ (BRL)";
d102 1
d107 15
a121 3
 *  N = inverse[ transpose(invR o invS) ] ( W' )
 *    = inverse[ transpose(invS) o transpose(invR) ] ( W' )
 *    = inverse[ inverse(S) o R ] ( W' )
d125 4
a128 1
 *  Note that the normal vector produced above will not have unit length.
d150 1
a150 1
 *			E L L _ I M P O R T
d157 1
a157 1
ell_import( eip, rp, mat )
d166 1
a166 1
		rt_log("ell_import: defective record\n");
d183 1
a183 1
 *  			E L L _ P R E P
d195 1
a195 1
 *  	stp->st_specific for use by ell_shot().
d198 1
a198 1
ell_prep( stp, rec, rtip )
d225 1
a225 1
		i = ell_import( &ei, rec, stp->st_pathmat );
d228 1
a228 1
		i = ell_import( &ei, rec, stp->st_pathmat );
d231 1
a231 1
		rt_log("ell_setup(%s): db import failure\n", stp->st_name);
d348 1
a348 1
ell_print( stp )
d360 1
a360 1
 *  			E L L _ S H O T
d363 1
a363 1
 *  been precomputed by ell_prep().  If an intersection occurs,
d371 1
a371 1
ell_shot( stp, rp, ap )
d416 1
a416 1
 *			E L L _ V S H O T
d421 1
a421 1
ell_vshot( stp, rp, segp, n, resp)
d475 1
a475 1
 *  			E L L _ N O R M
d480 1
a480 1
ell_norm( hitp, stp, rp )
d501 1
a501 1
 *			E L L _ C U R V E
d506 1
a506 1
ell_curve( cvp, hitp, stp )
d541 1
a541 1
 *  			E L L _ U V
d549 1
a549 1
ell_uv( ap, stp, hitp, uvp )
d588 1
a588 1
 *			E L L _ F R E E
d591 1
a591 1
ell_free( stp )
d601 1
a601 1
ell_class()
d608 2
d651 1
a651 1
 *			E L L _ P L O T
d654 8
a661 5
ell_plot( rp, matp, vhead, dp )
union record	*rp;
register matp_t matp;
struct vlhead	*vhead;
struct directory *dp;
d670 2
a671 2
	if( ell_import( &ei, rp, matp ) < 0 )  {
		rt_log("ell_plot(%s): db import failure\n", dp->d_namep);
d721 1
a721 1
 *			E L L _ T E S S
d730 1
a730 1
ell_tess( r, m, rp, mat, dp )
d736 3
d746 1
d752 2
a753 2
	if( ell_import( &ei, rp, mat ) < 0 )  {
		rt_log("ell_tess(%s): import failure\n", dp->d_namep);
d765 4
a768 7
		vertlist[0] = verts[ohp->a];
		vertlist[1] = verts[ohp->b];
		vertlist[2] = verts[ohp->c];
		outfaceuses[i] = nmg_cface(s, vertlist, 3 );
		verts[ohp->a] = vertlist[0];
		verts[ohp->b] = vertlist[1];
		verts[ohp->c] = vertlist[2];
@


9.6
log
@This version makes a decent solid with good normals.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 9.5 90/03/14 22:36:53 mike Locked $ (BRL)";
a776 2

	nmg_ck_closed_surf(s);		/* debug */
@


9.5
log
@Added nmg_region_a() call
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 9.4 90/03/14 21:21:10 mike Locked $ (BRL)";
d769 1
a769 13
		eu = outfaceuses[i]->lu_p->down.eu_p;
		if (rt_mk_plane_3pts(plane, eu->vu_p->v_p->vg_p->coord,
					eu->next->vu_p->v_p->vg_p->coord,
					eu->last->vu_p->v_p->vg_p->coord)) {
			rt_log("At %d in %s\n", __LINE__, __FILE__);
			rt_bomb("cannot make plane equation\n");
		}
		else if (plane[0] == 0.0 && plane[1] == 0.0 && plane[2] == 0.0) {
			rt_log("Bad plane equation from rt_mk_plane_3pts at %d in %s\n",
					__LINE__, __FILE__);
			rt_bomb("BAD Plane Equation");
		}
		else nmg_face_g(outfaceuses[i], plane);
d777 2
@


9.4
log
@Changed calling sequence to tessellation routines.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 9.3 90/03/14 15:05:47 mike Locked $ (BRL)";
d786 3
@


9.3
log
@Changed type of st_specific to genptr_t
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 9.2 90/03/03 05:48:31 mike Locked $ (BRL)";
d635 1
a635 1
void
d651 1
a651 1
		return;
d672 1
d703 4
d709 3
a711 2
ell_tess( s, rp, mat, dp )
struct shell		*s;
d716 1
d729 1
a729 1
		return;
d733 3
@


9.2
log
@Added ell_import().
Wrote initial part of ell_tess().  Only does first level of refinement.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 9.1 89/05/19 05:56:11 mike Locked $ (BRL)";
d256 1
a256 1
	stp->st_specific = (int *)ell;
@


9.1
log
@Release_3.5
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 8.9 89/04/27 23:08:05 phil Exp $ (BRL)";
d33 1
d125 8
d134 33
a192 1
	LOCAL vect_t	A, B, C;
d196 2
a197 1
	fastf_t		vec[3*4];
d207 11
a217 1
	rt_fastf_float( (fastf_t *)vec, rec->s.s_values, 4 );
a218 12
#define ELL_V	&vec[0*ELEMENTS_PER_VECT]
#define ELL_A	&vec[1*ELEMENTS_PER_VECT]
#define ELL_B	&vec[2*ELEMENTS_PER_VECT]
#define ELL_C	&vec[3*ELEMENTS_PER_VECT]

	/*
	 * Apply rotation only to A,B,C
	 */
	MAT4X3VEC( A, stp->st_pathmat, ELL_A );
	MAT4X3VEC( B, stp->st_pathmat, ELL_B );
	MAT4X3VEC( C, stp->st_pathmat, ELL_C );

d220 4
a223 6
	magsq_a = MAGSQ( A );
	magsq_b = MAGSQ( B );
	magsq_c = MAGSQ( C );
	if( NEAR_ZERO(magsq_a, 0.005) ||
	     NEAR_ZERO(magsq_b, 0.005) ||
	     NEAR_ZERO(magsq_c, 0.005) ) {
d231 1
a231 1
	VSCALE( Au, A, f );
d233 1
a233 1
	VSCALE( Bu, B, f );
d235 1
a235 1
	VSCALE( Cu, C, f );
d258 1
a258 2
	/* Apply full 4x4mat to V */
	MAT4X3PNT( ell->ell_V, stp->st_pathmat, ELL_V );
d285 3
a287 3
	VSCALE( &ell->ell_SoR[0], A, ell->ell_invsq[0] );
	VSCALE( &ell->ell_SoR[4], B, ell->ell_invsq[1] );
	VSCALE( &ell->ell_SoR[8], C, ell->ell_invsq[2] );
d290 1
a290 1
	VMOVE( stp->st_center, ell->ell_V );
d602 3
a604 3
	e = h = .92388;
	c = d = .707107;
	g = f = .382683;
d606 8
d632 3
a634 6
/* Names for GENELL fields */
#define VELL	&points[0]
#define AELL	&points[3]
#define BELL	&points[6]
#define CELL	&points[9]

d642 2
a643 3
	register int i;
	register fastf_t *op;
	register dbfloat_t *ip;
d649 3
a651 13
	/*
	 * Rotate, translate, and scale the V point.
	 * Simply rotate and scale the A, B, and C vectors.
	 */
	MAT4X3PNT( &points[0], matp, &rp[0].s.s_values[0] );

	ip = &rp[0].s.s_values[1*3];
	op = &points[1*3];
#	include "noalias.h"
	for(i=1; i<4; i++) {
		MAT4X3VEC( op, matp, ip );
		op += ELEMENTS_PER_VECT;
		ip += 3;
d654 3
a656 3
	ell_16pts( top, VELL, AELL, BELL );
	ell_16pts( bottom, VELL, BELL, CELL );
	ell_16pts( middle, VELL, AELL, CELL );
d674 344
@


8.9
log
@moved some constants to const.c
changed UV mapping (U==0 now on X axis)
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 8.8 89/04/17 17:19:08 phil Locked $ (BRL)";
@


8.8
log
@Calling sequence to xxx_prep() shortened from 6 to 3 args.
Database conversion moved into prep routines.
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: g_ell.c,v 8.7 89/04/11 13:01:28 mike Locked $ (BRL)";
a494 3
double rt_inv2pi =  0.15915494309189533619;	/* 1/(pi*2) */
double rt_invpi = 0.31830988618379067153;	/* 1/pi */

d517 3
a519 1
	uvp->uv_u = mat_atan2( pprime[Y], pprime[X] ) * rt_inv2pi + 0.5;
@


8.7
log
@missing parameter on call to sph_prep()
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: ell.c,v 8.6 89/04/08 03:35:01 phil Locked $ (BRL)";
d140 1
a140 2
ell_prep( vec, stp, mat, rtip )
register fastf_t	*vec;
d142 1
a142 1
matp_t			mat;
d155 1
d162 1
a162 1
	if( sph_prep( vec, stp, mat, rtip ) == 0 )
d165 2
d175 3
a177 3
	MAT4X3VEC( A, mat, ELL_A );
	MAT4X3VEC( B, mat, ELL_B );
	MAT4X3VEC( C, mat, ELL_C );
d221 1
a221 1
	MAT4X3PNT( ell->ell_V, mat, ELL_V );
@


8.6
log
@Vectorized another loop
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: ell.c,v 8.5 89/04/08 02:48:18 mike Locked $ (BRL)";
d35 2
d162 1
a162 1
	if( sph_prep( vec, stp, mat ) == 0 )
d460 1
a460 1
	vect_t	x, tmp;
@


8.5
log
@Includes Dave Becker's vectorized version
@
text
@d24 1
a24 1
static char RCSell[] = "@@(#)$Header: ell.c,v 8.4 89/02/17 11:02:17 mike Locked $ (BRL)";
d613 1
@


8.4
log
@Phil noted that the uv_v calculation using atan2() was not right.
@
text
@d12 1
d24 1
a24 1
static char RCSell[] = "@@(#)$Header: ell.c,v 8.3 89/01/09 04:54:19 mike Locked $ (BRL)";
d355 3
d359 59
d638 1
@


8.3
log
@Replaced asin() calls with atan2(), which is more robust.
@
text
@d23 1
a23 1
static char RCSell[] = "@@(#)$Header: ell.c,v 8.3 89/01/08 23:10:39 mike Exp $ (BRL)";
d452 1
d454 4
d460 1
a460 1
		rt_inv2pi + 0.5;
@


8.2
log
@Added _plot() routines, and db_*() interfaces.
@
text
@d23 1
a23 1
static char RCSell[] = "@@(#)$Header: /cad/d/mike/cad/librt/RCS/ell.c,v 1.2 88/11/03 12:35:16 mike Exp $ (BRL)";
d452 4
a455 2
	uvp->uv_u = atan2( pprime[Y], pprime[X] ) * rt_inv2pi + 0.5;
	uvp->uv_v = asin( pprime[Z] ) * rt_invpi + 0.5;
@


8.1
log
@Release_3.0
@
text
@d23 1
a23 1
static char RCSell[] = "@@(#)$Header: ell.c,v 7.3 88/05/14 00:01:02 mike Exp $ (BRL)";
d480 4
d485 4
a488 1
ell_plot()
d490 77
@


7.3
log
@lint fixes
added zero _uv() routines to some modules
@
text
@d23 1
a23 1
static char RCSell[] = "@@(#)$Header: ell.c,v 7.2 88/02/06 05:36:31 mike Locked $ (BRL)";
@


7.2
log
@rt_orthovec to vec_ortho
@
text
@d23 1
a23 1
static char RCSell[] = "@@(#)$Header: ell.c,v 7.1 87/11/02 23:33:24 mike Locked $ (BRL)";
d136 1
d289 1
d359 1
d385 1
d431 1
d464 1
d474 1
d477 1
d480 1
@


7.1
log
@Release 2.3
@
text
@d23 1
a23 1
static char RCSell[] = "@@(#)$Header: ell.c,v 6.1 87/07/11 07:55:43 mike Rel $ (BRL)";
d398 1
a398 1
	rt_orthovec( u, hitp->hit_normal );
@


6.1
log
@Release 2.0
@
text
@d23 1
a23 1
static char RCSell[] = "@@(#)$Header: ell.c,v 5.1 87/06/24 22:11:23 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d23 1
a23 1
static char RCSell[] = "@@(#)$Header: ell.c,v 4.10 87/05/30 06:00:47 phil Exp $ (BRL)";
@


4.10
log
@new curvature method
vmath.h name change
@
text
@d23 1
a23 1
static char RCSell[] = "@@(#)$Header: ell.c,v 4.8 87/04/28 00:27:35 phil Exp $ (BRL)";
@


4.9
log
@added values to ell_print()
@
text
@d10 2
d23 1
a23 1
static char RCSell[] = "@@(#)$Header: ell.c,v 4.8 87/04/28 00:27:35 phil Locked $ (BRL)";
d260 1
a260 1
	MAT3XVEC( w2, R, P );		/* map plane to local coord syst */
d269 1
a269 1
	MAT3XVEC( w2, R, P );		/* map plane to local coord syst */
d278 1
a278 1
	MAT3XVEC( w2, R, P );		/* map plane to local coord syst */
a294 4
	VPRINT("Au", ell->ell_Au);
	VPRINT("Bu", ell->ell_Bu);
	VPRINT("Cu", ell->ell_Cu);
	VPRINT("invsq", ell->ell_invsq);
d365 1
d370 5
a374 1
	VUNITIZE( hitp->hit_normal );
d389 4
a392 10
	vect_t	w4;		/* vector from V to hit point */
	fastf_t *aup, *bup, *cup;	/* ptr to Aunit, Bunit, Cunit used */
	fastf_t	fx, fy;
	fastf_t	fxx, fyy, fxy;
	fastf_t	e, f, g;
	fastf_t	t1, t2;
	fastf_t	t5, t6;
	fastf_t	a1, b1, c1;
	fastf_t	aa1, bb1, dd1, aa2, bb2, dd2;
	fastf_t	rc1sav, rc2sav;
d394 6
a399 9
	VSUB2( w4, hitp->hit_point, ell->ell_V );
	aup = ell->ell_Au;
	bup = ell->ell_Bu;
	cup = ell->ell_Cu;
	{
		fastf_t	*tup;
		fastf_t	*iap, *ibp, *icp, *itp;
		fastf_t	x0, y0, z0;
		FAST fastf_t	c4, a2, b2, c2;
d401 2
a402 54
		iap = &ell->ell_invsq[X];
		ibp = &ell->ell_invsq[Y];
		icp = &ell->ell_invsq[Z];
		/* find a coordinate system with non-zero z */
		while(1)  {
			x0 = VDOT( w4, aup );
			y0 = VDOT( w4, bup );
			z0 = VDOT( w4, cup );
			if( !NEAR_ZERO( z0, 0.001 ) )
				break;
			tup = aup;
			aup = bup;
			bup = cup;
			cup = tup;
			itp = iap;
			iap = ibp;
			ibp = icp;
			icp = itp;
		}
		a2 = 1.0 / (*iap);
		b2 = 1.0 / (*ibp);
		c2 = 1.0 / (*icp);
		c4 = c2 * c2;
		t2 = 1.0 / (a2*b2*z0*z0*z0);
		/* 1st and 2nd partials */
		fx = -(c2*x0) / (a2*z0);
		fy = -(c2*y0) / (b2*z0);
		fxx = -(c4*(b2 - y0*y0))*t2;
		fyy = -(c4*(a2 - x0*x0))*t2;
		fxy = -(c4*x0*y0)*t2;
	}
	e = 1.0 + fx*fx;
	f = fx*fy;
	g = 1.0 + fy*fy;
	t1 = e + fy*fy;
	t2 = 2.0*t1*sqrt(t1);
/*
	t5 = sqrt( (g*fxx - e*fyy)*(g*fxx - e*fyy) +
		4.0 * (g*fxy - f*fyy)*(e*fxy - f*fxx) );
*/
	/* XXX - t5 goes negative when we are nearly spherical */
	t5 = (g*fxx - e*fyy)*(g*fxx - e*fyy) +
		4.0 * (g*fxy - f*fyy)*(e*fxy - f*fxx);
	if( t5 < 0 ) {
		fprintf( stderr, "t5 Negative\n" );
		VPRINT( "w4", w4 );
		fprintf( stderr, "fx,fy,fxx,fyy,fxy = %e %e %e %e %e\n", fx, fy, fxx, fyy, fxy );
		fprintf( stderr, "e,f,g = %e %e %e\n", e, f, g );
		fprintf( stderr, "t3 = %e\n",  (g*fxx - e*fyy)*(g*fxx - e*fyy) );
		fprintf( stderr, "t4 = %e\n",  4.0*(g*fxy - f*fyy)*(e*fxy - f*fxx) );
		t5 = 0;
	}
	t5 = sqrt(t5);
	t6 = g*fxx + e*fyy - 2.0*f*fxy;
d404 6
a409 6
	rc1sav = (t6 - t5)/t2;
	rc2sav = (t6 + t5)/t2;
	if( (cvp->crv_c1 = -rc1sav) > 0 )
		cvp->crv_c1 = -cvp->crv_c1;
	if( (cvp->crv_c2 = -rc2sav) > 0 )
		cvp->crv_c2 = -cvp->crv_c2;
d411 2
a412 36
	/* smaller magnitude curvature first */
	if( cvp->crv_c1 < cvp->crv_c2 ) {
		FAST fastf_t f;
		f = cvp->crv_c2;
		cvp->crv_c2 = cvp->crv_c1;
		cvp->crv_c1 = f;
		f = rc2sav;
		rc2sav = rc1sav;
		rc1sav = f;
	}

	/* construct 1st possible eigenvector */
	aa1 = g*fxy - f*fyy;
	bb1 = f*fxy - g*fxx + rc1sav*t2/2.0;
	dd1 = aa1*aa1 + bb1*bb1;
	/* construct 2nd possible eigenvector */
	aa2 = f*fxy - e*fyy + rc1sav*t2/2.0;
	bb2 = e*fxy - f*fxx;
	dd2 = aa2*aa2 + bb2*bb2;
	if( (dd1 >= dd2) && (dd1 > 0) ) {
		a1 = aa1;
		b1 = bb1;
		c1 = aa1*fx + bb1*fy;
	} else if( dd2 > 0 ) {
		a1 = aa2;
		b1 = bb2;
		c1 = aa2*fx + bb2*fy;
	} else {
		/* point is umbilic, any tangent vector is OK */
		a1 = 1.0;
		b1 = 0.0;
		c1 = fx;
	}

	/* transform coords back to usual system */
	VCOMB3( cvp->crv_pdir, a1, aup, b1, bup, c1, cup );
d424 1
a424 1
double rt_inv2pi =  0.15915494309189533619;		/* 1/(pi*2) */
@


4.8
log
@changed curve convention
@
text
@d21 1
a21 1
static char RCSell[] = "@@(#)$Header: ell.c,v 4.7 87/03/24 01:03:50 phil Locked $ (BRL)";
d293 4
@


4.7
log
@added check for sphere special case
removed the sphere case from the curvature code
new code for finding tightest possible bounding RPP
@
text
@d21 1
a21 1
static char RCSell[] = "@@(#)$Header: ell.c,v 4.6 87/03/23 23:42:05 phil Locked $ (BRL)";
d375 1
a375 1
ell_curve( cvp, hitp, stp, rp )
a378 1
struct xray *rp;
a447 2
		VPRINT( "Ray origin", rp->r_pt );
		VPRINT( "Ray dir", rp->r_dir );
d460 1
a460 1
	if( (cvp->crv_c1 = rc1sav) < 0 )
d462 1
a462 1
	if( (cvp->crv_c2 = rc2sav) < 0 )
d466 1
a466 1
	if( cvp->crv_c1 > cvp->crv_c2 )  {
a501 6

	if( VDOT( hitp->hit_normal, rp->r_dir ) > 0 )  {
		/* ray strikes surface from inside; make curv negative */
		cvp->crv_c1 = - cvp->crv_c1;
		cvp->crv_c2 = - cvp->crv_c2;
	}
@


4.6
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d21 1
a21 1
static char RCSell[] = "@@(#)$Header: ell.c,v 4.5 87/03/17 16:17:26 phil Exp $ (BRL)";
d148 1
a148 2
	LOCAL vect_t	work;
	LOCAL vect_t	vbc;	/* used for bounding RPP */
d151 8
d254 1
a254 1
#define ELL_MM(v)	VMINMAX( stp->st_min, stp->st_max, v );
d256 8
a263 4
	/* There are 8 corners to the enclosing RPP;  find max and min */
	VADD3( vbc, ell->ell_V, B, C );
	VADD2( work, vbc, A ); ELL_MM( work );	/* V + A + B + C */
	VSUB2( work, vbc, A ); ELL_MM( work );	/* V - A + B + C */
d265 8
a272 9
	VSUB2( vbc, ell->ell_V, B );
	VADD2( vbc, vbc, C );
	VADD2( work, vbc, A ); ELL_MM( work );	/* V + A - B + C */
	VSUB2( work, vbc, A ); ELL_MM( work );	/* V - A - B + C */
	
	VSUB2( vbc, ell->ell_V, C );
	VADD2( vbc, vbc, B );
	VADD2( work, vbc, A ); ELL_MM( work );	/* V + A + B - C */
	VSUB2( work, vbc, A ); ELL_MM( work );	/* V - A + B - C */
d274 8
a281 3
	VSUB3( vbc, ell->ell_V, B, C );
	VADD2( work, vbc, A ); ELL_MM( work );	/* V + A - B - C */
	VSUB2( work, vbc, A ); ELL_MM( work );	/* V - A - B - C */
a392 18

	/*
	 * Sphere special case
	 */
	if( (ell->ell_invsq[X] == ell->ell_invsq[Y])
	 && (ell->ell_invsq[X] == ell->ell_invsq[Z]) ) {
	 	cvp->crv_c1 = sqrt(ell->ell_invsq[X]);
	 	cvp->crv_c2 = cvp->crv_c1;
		/* any tangent direction */
	 	rt_orthovec( cvp->crv_pdir, hitp->hit_normal );

		if( VDOT( hitp->hit_normal, rp->r_dir ) > 0 )  {
			/* ray strikes surface from inside; make curv negative */
			cvp->crv_c1 = - cvp->crv_c1;
			cvp->crv_c2 = - cvp->crv_c2;
		}
	 	return;
	}
@


4.5
log
@Changed the curvature code per ERIM's latest.
There is still a problem here for nearly sphereical ellipsoids.
The special case of the sphere should be done elsewhere.
@
text
@d21 1
a21 1
static char RCSell[] = "@@(#)$Header: ell.c,v 4.4 87/03/10 23:42:47 phil Locked $ (BRL)";
d134 5
a138 4
ell_prep( vec, stp, mat )
register fastf_t *vec;
struct soltab *stp;
matp_t mat;			/* Homogenous 4x4, with translation, [15]=1 */
d554 20
@


4.4
log
@For Stay, switched 3rd arg to ft_shoot() from resource pointer
(member of application struct) to application struct pointer.
@
text
@d21 1
a21 1
static char RCSell[] = "@@(#)$Header: ell.c,v 4.3 87/02/12 22:11:12 mike Locked $ (BRL)";
d375 2
a376 1
	fastf_t	d;
d378 18
d404 1
a404 1
		FAST fastf_t	c4;
d409 1
d425 10
a434 4
		c4 = (*icp)*(*icp);
		t2 = 1.0 / ((*iap)*(*ibp)*z0*z0*z0);
		fxx = -(c4*((*ibp) - y0*y0))*t2;
		fyy = -(c4*((*iap) - x0*x0))*t2;
a435 2
		fx = -((*icp)*x0) / ((*iap)*z0);
		fy = -((*icp)*y0) / ((*ibp)*z0);
d441 2
a442 1
	t2 = 1.0 / (2.0*t1*sqrt(t1));
d445 16
d463 3
a465 1
	if( (cvp->crv_c1 = (t6 + t5)*t2) < 0 )
d467 1
a467 1
	if( (cvp->crv_c2 = (t6 - t5)*t2) < 0 )
d470 2
a471 25
	a1 = 2.0*(g*fxy - f*fyy);
	if( cvp->crv_c1 >= cvp->crv_c2 )
		b1 = e*fyy - g*fxx + t5;
	else
		b1 = e*fyy - g*fxx - t5;
	c1 = a1*fx + b1*fy;

	d = sqrt(a1*a1 + b1*b1 + c1*c1);
	if( NEAR_ZERO( d, 0.0001 ) )  {
		if( cvp->crv_c1 >= cvp->crv_c2 )
			a1 = g*fxx - e*fyy + t5;
		else
			a1 = g*fxx - e*fyy - t5;
		b1 = 2.0*(e*fxy - f*fxx);
		c1 = a1*fx + b1*fy;

		d = sqrt(a1*a1 + b1*b1 + c1*c1);
		if( NEAR_ZERO( d, 0.0001 ) )  {
			/* Make an arbitrary choice of pdir */
			a1 = 1.0;
			b1 = 1.0;
			c1 = fx + fy;
		}
	}
	if( cvp->crv_c1 >= cvp->crv_c2 )  {
d476 3
d480 25
d508 4
a511 11
	if( VDOT( w4, hitp->hit_normal ) < 0 )  {
		LOCAL vect_t temp;
		rt_log("ell_curve(%s): normal flip?\n", stp->st_name);
		VMOVE( temp, cvp->crv_pdir );
		VCROSS( cvp->crv_pdir, hitp->hit_normal, temp);
	} else {
		FAST fastf_t f;
		/* Why did we do it wrong to start with? */
		f = -cvp->crv_c1;
		cvp->crv_c1 = -cvp->crv_c2;
		cvp->crv_c2 = f;
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d21 1
a21 1
static char RCSell[] = "@@(#)$Header: ell.c,v 4.2 87/01/28 21:00:04 mike Exp $ (BRL)";
d293 1
a293 1
ell_shot( stp, rp, res )
d296 1
a296 1
struct resource		*res;
d320 1
a320 1
	GET_SEG(segp, res);
@


4.2
log
@Release 1.16:  added curvature
@
text
@d21 1
a21 1
static char RCSell[] = "@@(#)$Header: ell.c,v 4.1 86/12/29 03:45:07 mike Locked $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d21 1
a21 1
static char RCSell[] = "@@(#)$Header: ell.c,v 3.4 86/12/24 08:05:41 mike Locked $ (BRL)";
d111 4
a146 1
	LOCAL vect_t	invsq;	/* [ 1/(|A|**2), 1/(|B|**2), 1/(|C|**2) ] */
d207 4
a210 1
	VSET( invsq, 1.0/magsq_a, 1.0/magsq_b, 1.0/magsq_c );
d223 3
a225 3
	SS[ 0] = invsq[0];
	SS[ 5] = invsq[1];
	SS[10] = invsq[2];
d232 3
a234 3
	VSCALE( &ell->ell_SoR[0], A, invsq[0] );
	VSCALE( &ell->ell_SoR[4], B, invsq[1] );
	VSCALE( &ell->ell_SoR[8], C, invsq[2] );
d352 120
@


3.4
log
@Revised for resource structure.
@
text
@d21 1
a21 1
static char RCSell[] = "@@(#)$Header: ell.c,v 3.3 86/08/12 04:15:35 mike Exp $ (BRL)";
@


3.3
log
@Changed #include directives for use with CC -I convention
@
text
@d21 1
a21 1
static char RCSell[] = "@@(#)$Header: ell.c,v 3.2 86/07/24 06:09:59 mike Exp $ (BRL)";
d287 4
a290 3
ell_shot( stp, rp )
struct soltab *stp;
register struct xray *rp;
d314 1
a314 1
	GET_SEG(segp);
@


3.2
log
@Added uvcoord support
@
text
@d21 1
a21 1
static char RCSell[] = "@@(#)$Header: ell.c,v 3.1 86/07/11 01:32:00 mike Exp $ (BRL)";
d26 5
a30 5
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/db.h"
#include "../h/raytrace.h"
#include "debug.h"
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d21 1
a21 1
static char RCSell[] = "@@(#)$Header: ell.c,v 3.0 86/06/10 01:33:03 mike Exp $ (BRL)";
d240 1
a240 3
#define ELL_MINMAX(a,b,c)	{ FAST fastf_t ftemp;\
			if( (ftemp = (c)) < (a) )  a = ftemp;\
			if( ftemp > (b) )  b = ftemp; }
a241 4
#define ELL_MM(v)	ELL_MINMAX( stp->st_min[X], stp->st_max[X], v[X] ); \
		ELL_MINMAX( stp->st_min[Y], stp->st_max[Y], v[Y] ); \
		ELL_MINMAX( stp->st_min[Z], stp->st_max[Z], v[Z] )

d358 2
a359 1
ell_uv( stp, hitp, uvp )
d362 1
a362 1
register fastf_t *uvp;
d368 1
d378 7
a384 2
	uvp[0] = atan2( pprime[Y], pprime[X] ) * rt_inv2pi + 0.5;
	uvp[1] = asin( pprime[Z] ) * rt_invpi + 0.5;
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: ell.c,v 2.4 86/06/09 21:50:24 mike Exp $ (BRL)";
a114 3
#undef EPSILON
#define EPSILON	0.005		/* More appropriate for NEAR_ZERO here */

d148 4
a151 4
#define SP_V	&vec[0*ELEMENTS_PER_VECT]
#define SP_A	&vec[1*ELEMENTS_PER_VECT]
#define SP_B	&vec[2*ELEMENTS_PER_VECT]
#define SP_C	&vec[3*ELEMENTS_PER_VECT]
d156 3
a158 3
	MAT4X3VEC( A, mat, SP_A );
	MAT4X3VEC( B, mat, SP_B );
	MAT4X3VEC( C, mat, SP_C );
d164 3
a166 1
	if( NEAR_ZERO(magsq_a) || NEAR_ZERO(magsq_b) || NEAR_ZERO(magsq_c) ) {
d182 1
a182 1
	if( ! NEAR_ZERO(f) )  {
d187 1
a187 1
	if( ! NEAR_ZERO(f) )  {
d192 1
a192 1
	if( ! NEAR_ZERO(f) )  {
d202 1
a202 1
	MAT4X3PNT( ell->ell_V, mat, SP_V );
d240 1
a240 1
#define MINMAX(a,b,c)	{ FAST fastf_t ftemp;\
d244 3
a246 3
#define MM(v)	MINMAX( stp->st_min[X], stp->st_max[X], v[X] ); \
		MINMAX( stp->st_min[Y], stp->st_max[Y], v[Y] ); \
		MINMAX( stp->st_min[Z], stp->st_max[Z], v[Z] )
d250 2
a251 2
	VADD2( work, vbc, A ); MM( work );	/* V + A + B + C */
	VSUB2( work, vbc, A ); MM( work );	/* V - A + B + C */
d255 2
a256 2
	VADD2( work, vbc, A ); MM( work );	/* V + A - B + C */
	VSUB2( work, vbc, A ); MM( work );	/* V - A - B + C */
d260 2
a261 2
	VADD2( work, vbc, A ); MM( work );	/* V + A + B - C */
	VSUB2( work, vbc, A ); MM( work );	/* V - A + B - C */
d264 2
a265 2
	VADD2( work, vbc, A ); MM( work );	/* V + A - B - C */
	VSUB2( work, vbc, A ); MM( work );	/* V - A - B - C */
d361 2
a362 2
static double inv2pi =  0.15915494309189533619;		/* 1/(pi*2) */
static double invpi = 0.31830988618379067153;	/* 1/pi */
d382 2
a383 2
	uvp[0] = atan2( pprime[Y], pprime[X] ) * inv2pi + 0.5;
	uvp[1] = asin( pprime[Z] ) * invpi + 0.5;
@


2.4
log
@rt and librt separated
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: ell.c,v 2.3 85/09/11 01:43:45 mike Exp $ (BRL)";
d168 1
a168 1
		rtlog("ell(%s):  zero length A, B, or C vector\n",
d184 1
a184 1
		rtlog("ell(%s):  A not perpendicular to B, f=%f\n",stp->st_name, f);
d189 1
a189 1
		rtlog("ell(%s):  B not perpendicular to C, f=%f\n",stp->st_name, f);
d194 1
a194 1
		rtlog("ell(%s):  A not perpendicular to C, f=%f\n",stp->st_name, f);
@


2.3
log
@Improved perpendicularity checking.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: ell.c,v 2.2 85/09/05 02:17:09 mike Exp $ (BRL)";
d29 1
a29 1
#include "raytrace.h"
@


2.2
log
@Added u,v map computation, based upon angle/azimuth.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: ell.c,v 2.1 85/08/31 06:04:09 mike Exp $ (BRL)";
d145 1
d173 10
a182 2
	/* Validate that A.B == 0, B.C == 0, A.C == 0 */
	f = VDOT( A, B );
d187 1
a187 1
	f = VDOT( B, C );
d192 1
a192 1
	f = VDOT( A, C );
d211 3
a213 6
	f = 1.0/sqrt(magsq_a);
	VSCALE( &R[0], A, f );
	f = 1.0/sqrt(magsq_b);
	VSCALE( &R[4], B, f );
	f = 1.0/sqrt(magsq_c);
	VSCALE( &R[8], C, f );
@


2.1
log
@Version 2 of RT
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: ell.c,v 1.18 85/07/30 05:52:33 mike Exp $ (BRL)";
d353 2
a354 2
 *  u = angle around skin in X,Y plane.
 *  v = angle around skin in X,Z plane.
d357 1
a367 1
	FAST fastf_t len;
d375 1
d377 2
a378 17
	/* project onto X,Y plane */
	if( (len=sqrt(pprime[X]*pprime[X]+pprime[Y]*pprime[Y])) > EPSILON )  {
		uvp[0] = acos(pprime[Y]/len) * inv2pi;
		/* Handle other half of acos() domain */
		if( pprime[X] < 0 )
			uvp[0] += 0.5;
	} else
		uvp[0] = 0;

	/* project onto X,Z plane */
	if( (len=sqrt(pprime[X]*pprime[X]+pprime[Z]*pprime[Z])) > EPSILON )  {
		uvp[1] = acos(pprime[Z]/len) * inv2pi;
		/* Handle other half of acos() domain */
		if( pprime[X] < 0 )
			uvp[1] += 0.5;
	} else
		uvp[1] = 0;
@


1.18
log
@Revised for joint GED/RT vmath.h;  some storage cleanups.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: ell.c,v 1.17 85/03/25 11:35:00 mike Exp $ (BRL)";
d25 1
d167 1
a167 1
		fprintf(stderr,"ell(%s):  zero length A, B, or C vector\n",
d175 1
a175 1
		fprintf(stderr,"ell(%s):  A not perpendicular to B, f=%f\n",stp->st_name, f);
d180 1
a180 1
		fprintf(stderr,"ell(%s):  B not perpendicular to C, f=%f\n",stp->st_name, f);
d185 1
a185 1
		fprintf(stderr,"ell(%s):  A not perpendicular to C, f=%f\n",stp->st_name, f);
d232 1
a232 1
	stp->st_radsq = f;
d297 2
a298 2
	LOCAL fastf_t	dp, dd, pp;	/* D' dot P', D' dot D', P' dot P' */
	LOCAL fastf_t	root;		/* root of radical */
d300 1
a300 1
	LOCAL vect_t	xlated;		/* translated vector */
a308 1
	pp = VDOT( pprime, pprime );
d310 1
a310 2
	root = dp*dp - dd * (pp-1.0);
	if( root < 0 )
a313 12
	k1 = (-dp + root) / dd;
	k2 = (-dp - root) / dd;

	if( k1 > k2 )  {
		FAST fastf_t f;	/*  XXX  */
		f = k1;
		k1 = k2;
		k2 = f;
	}
	/*
	 * Now, k1 is entry point, and k2 is exit point
	 */
d316 11
d328 13
a340 3
	/* ASSERT that MAGNITUDE(rp->r_dir) == 1 */
	segp->seg_in.hit_dist = k1;
	segp->seg_out.hit_dist = k2;
d342 5
a346 8
	/*
	 *  For each point, if intersect comes "after" start of ray,
	 *  compute exact intersection point, and surface normal.
	 */
	segp->seg_flag = 0;
	if( k1 >= 0 )  {
		FAST fastf_t f;		/* XXX */
		segp->seg_flag |= SEG_IN;
d348 9
a356 2
		/* Intersection point */
		VJOIN1( segp->seg_in.hit_point, rp->r_pt, k1, rp->r_dir );
d358 10
a367 9
		/* Normal at that point, pointing out */
		VSUB2( xlated, segp->seg_in.hit_point, ell->ell_V );
		MAT4X3VEC( segp->seg_in.hit_normal, ell->ell_invRSSR, xlated );
		f = 1.0 / MAGNITUDE(segp->seg_in.hit_normal );
		VSCALE( segp->seg_in.hit_normal, segp->seg_in.hit_normal, f);
	}
	if( k2 >= 0 )  {
		FAST fastf_t f;		/* XXX */
		segp->seg_flag |= SEG_OUT;
d369 6
a374 1
		VJOIN1( segp->seg_out.hit_point, rp->r_pt, k2, rp->r_dir );
d376 17
a392 6
		VSUB2( xlated, segp->seg_out.hit_point, ell->ell_V );
		MAT4X3VEC( segp->seg_out.hit_normal,ell->ell_invRSSR, xlated );
		f = 1.0 / MAGNITUDE( segp->seg_out.hit_normal );
		VSCALE(segp->seg_out.hit_normal, segp->seg_out.hit_normal, f);
	}
	return(segp);			/* HIT */
@


1.17
log
@Made local epsilon.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: ell.c,v 1.16 85/01/31 20:16:38 mike Exp $ (BRL)";
d25 3
a27 1
#include "vmath.h"
a28 1
#include "../h/db.h"
@


1.16
log
@mat_zero --> mat_idn, stupid.
@
text
@d4 1
a4 1
 * Purpose -
d7 1
a7 1
 * Authors -
d10 9
a18 5
 *
 * U. S. Army Ballistic Research Laboratory
 * March 27, 1984.
 *
 * $Revision: 1.15 $
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: ell.c,v 1.15 85/01/31 17:02:19 mike Exp $ (BRL)";
d27 1
a27 1
#include "db.h"
d112 3
@


1.15
log
@Added more information on not-perpendicular messages (dot product).
@
text
@d14 1
a14 1
 * $Revision: 1.14 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: ell.c,v 1.14 84/12/17 16:09:13 mike Exp $ (BRL)";
d189 2
a190 2
	mat_zero( ell->ell_SoR );
	mat_zero( R );
@


1.14
log
@Minor nit, no change in results.
@
text
@d14 1
a14 1
 * $Revision: 1.13 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: ell.c,v 1.13 84/11/24 02:59:55 mike Exp $ (BRL)";
d147 1
a147 1
	 * Apply 3x3 rotation mat only to A,B,C
d149 3
a151 3
	MAT3XVEC( A, mat, SP_A );
	MAT3XVEC( B, mat, SP_B );
	MAT3XVEC( C, mat, SP_C );
d166 1
a166 1
		fprintf(stderr,"ell(%s):  A not perpendicular to B\n",stp->st_name);
d171 1
a171 1
		fprintf(stderr,"ell(%s):  B not perpendicular to C\n",stp->st_name);
d176 1
a176 1
		fprintf(stderr,"ell(%s):  A not perpendicular to C\n",stp->st_name);
d294 1
a294 1
	MAT3XVEC( dprime, ell->ell_SoR, rp->r_dir );
d296 1
a296 1
	MAT3XVEC( pprime, ell->ell_SoR, xlated );
d340 1
a340 1
		MAT3XVEC( segp->seg_in.hit_normal, ell->ell_invRSSR, xlated );
d351 1
a351 1
		MAT3XVEC( segp->seg_out.hit_normal,ell->ell_invRSSR, xlated );
@


1.13
log
@Rewrote code to compute bounding RPPs correctly,
although perhaps slightly too large.
@
text
@d14 1
a14 1
 * $Revision: 1.12 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: ell.c,v 1.12 84/11/23 20:54:05 mike Exp $ (BRL)";
d201 2
a202 1
	/* Compute SoS.  Uses 3x3 of the 4x4 matrix */
@


1.12
log
@Added LOCAL, fastf_t declarations.
Made shootray() recursive.
@
text
@d14 1
a14 1
 * $Revision: 1.11 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: ell.c,v 1.11 84/11/20 20:14:24 mike Exp $ (BRL)";
d138 1
a224 5

	/* init maxima and minima */
	stp->st_max[X] = stp->st_max[Y] = stp->st_max[Z] = -INFINITY;
	stp->st_min[X] = stp->st_min[Y] = stp->st_min[Z] =  INFINITY;

d233 18
a250 6
	VADD2( work, ell->ell_V, A ); MM( work );
	VSUB2( work, ell->ell_V, A ); MM( work );
	VADD2( work, ell->ell_V, B ); MM( work );
	VSUB2( work, ell->ell_V, B ); MM( work );
	VADD2( work, ell->ell_V, C ); MM( work );
	VSUB2( work, ell->ell_V, C ); MM( work );
@


1.11
log
@General cleanup
@
text
@d14 1
a14 1
 * $Revision: 1.10 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: ell.c,v 1.10 84/11/16 23:58:20 mike Exp $ (BRL)";
d130 9
a138 9
	static fastf_t	magsq_a, magsq_b, magsq_c;
	static mat_t	R;
	static mat_t	Rinv;
	static mat_t	SS;
	static mat_t	mtemp;
	static vect_t	A, B, C;
	static vect_t	invsq;	/* [ 1/(|A|**2), 1/(|B|**2), 1/(|C|**2) ] */
	static vect_t	work;
	static fastf_t	f;
d277 6
a282 6
	static vect_t	dprime;		/* D' */
	static vect_t	pprime;		/* P' */
	static fastf_t	dp, dd, pp;	/* D' dot P', D' dot D', P' dot P' */
	static fastf_t	root;		/* root of radical */
	static fastf_t	k1, k2;		/* distance constants of solution */
	static vect_t	xlated;		/* translated vector */
@


1.10
log
@More FLEXNAMES stuff
@
text
@d14 1
a14 1
 * $Revision: 1.9 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: ell.c,v 1.9 84/11/16 06:28:21 mike Exp $ (BRL)";
d157 1
a157 1
		printf("ell(%s):  zero length A, B, or C vector\n",
d165 1
a165 1
		printf("ell(%s):  A not perpendicular to B\n",stp->st_name);
d170 1
a170 1
		printf("ell(%s):  B not perpendicular to C\n",stp->st_name);
d175 1
a175 1
		printf("ell(%s):  A not perpendicular to C\n",stp->st_name);
@


1.9
log
@struct ray --> struct xray
Bounding RPP
@
text
@d2 1
a2 1
 *			E L L G . C
d14 1
a14 1
 * $Revision: 1.8 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: ellg.c,v 1.8 84/11/15 21:47:42 mike Exp $ (BRL)";
d110 1
a110 1
 *  			E L L G _ P R E P
d122 1
a122 1
 *  	stp->st_specific for use by ellg_shot().
d124 1
a124 1
ellg_prep( vec, stp, mat )
d247 1
a247 1
ellg_print( stp )
d259 1
a259 1
 *  			E L L G _ S H O T
d262 1
a262 1
 *  been precomputed by ellg_prep().  If an intersection occurs,
d270 1
a270 1
ellg_shot( stp, rp )
@


1.8
log
@Fix to use proper matrix.
@
text
@d14 1
a14 1
 * $Revision: 1.7 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: ellg.c,v 1.7 84/10/19 01:38:14 mike Exp $ (BRL)";
d22 1
a22 1
#include "ray.h"
d24 1
d223 21
d272 1
a272 1
register struct ray *rp;
@


1.7
log
@Lint corrections
@
text
@d14 1
a14 1
 * $Revision: 1.6 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: ellg.c,v 1.6 84/05/01 06:39:37 mike Exp $ (BRL)";
d182 2
a183 4
	/* Apply full 4x4mat to V.  No need for htov_vec, as [15]==1. */
	VMOVE( work, SP_V );
	work[3] = 1;
	matXvec( ell->ell_V, mat, work );
@


1.6
log
@Modifications for ARS, code unified to use fastf_t
@
text
@d14 1
a14 1
 * $Revision: 1.5 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: ellg.c,v 1.5 84/04/26 07:51:32 mike Exp $ (BRL)";
d307 1
a307 1
		VCOMPOSE1( segp->seg_in.hit_point, rp->r_pt, k1, rp->r_dir );
d319 1
a319 1
		VCOMPOSE1( segp->seg_out.hit_point, rp->r_pt, k2, rp->r_dir );
@


1.5
log
@Working version.
@
text
@d14 1
a14 1
 * $Revision: 1.4 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: ellg.c,v 1.4 84/04/26 05:37:01 mike Exp $ (BRL)";
d123 2
a124 2
ellg_prep( sp, stp, mat )
register struct solidrec *sp;
d139 4
a142 4
#define SP_V	&sp->s_values[0]
#define SP_A	&sp->s_values[3]
#define SP_B	&sp->s_values[6]
#define SP_C	&sp->s_values[9]
d183 1
a183 1
	VMOVE( work, &sp->s_values[0] );	/* float to fastf_t */
a262 1
	extern struct seg *HeadSeg;	/* Pointer to segment list */
@


1.4
log
@Improved error checking, speed.
@
text
@d14 1
a14 1
 * $Revision: 1.3 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: ellg.c,v 1.3 84/04/18 02:20:11 mike Exp $ (BRL)";
d129 1
a129 1
	static double	magsq_a, magsq_b, magsq_c;
d137 1
a137 1
	static double	f;
d139 1
d144 3
a146 1
	/* Apply 3x3 rotation portion of mat to A,B,C */
d182 1
a182 1
	/* Apply full 4x4mat to V.  No need for htov_vec, as [15]==0. */
d184 1
@


1.3
log
@Boolean operation support
@
text
@d14 1
a14 1
 * $Revision: 1.2 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: ellg.c,v 1.2 84/04/02 19:55:57 mike Exp $ (BRL)";
d136 2
a137 1
	register float	f;
d159 3
a161 5
	if( VDOT( A, B ) != 0.0  ||
	    VDOT( B, C ) != 0.0  ||
	    VDOT( A, C ) != 0.0 )  {
		printf("ell(%s):  A, B, or C not perpendicular\n",
			stp->st_name);
d164 10
d180 2
a181 1
	matXvec( ell->ell_V, mat, &sp->s_values[0] );
d255 3
a257 3
	static float	dp, dd, pp;	/* D' dot P', D' dot D', P' dot P' */
	static float	root;		/* root of radical */
	static float	k1, k2;		/* distance constants of solution */
d270 1
a270 1
	root = dp*dp - dd * (pp-1);
d279 1
a279 1
		register float f;	/*  XXX  */
d287 1
a287 1
	GETSTRUCT(segp, seg);
d300 1
a300 1
		register float f;		/* XXX */
d313 1
a313 1
		register float f;		/* XXX */
@


1.2
log
@Changed to use invRSSR rather than SoS for Normals,
Added error checking in ellg_prep().
@
text
@d14 1
a14 1
 * $Revision: 1.1 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: ellg.c,v 1.1 84/04/02 16:41:52 mike Exp $ (BRL)";
a105 1
	vect_t	ell_invsq;	/* [ 1/(|A|**2), 1/(|B|**2), 1/(|C|**2) ] */
d126 1
a126 1
matp_t mat;
d134 2
d142 4
a145 1
	/* TODO:  Apply 4x4mat to V, special_mat to A,B,C */
d148 3
a150 3
	magsq_a = MAGSQ( SP_A );
	magsq_b = MAGSQ( SP_B );
	magsq_c = MAGSQ( SP_C );
d158 3
a160 3
	if( VDOT( SP_A, SP_B ) != 0.0  ||
	    VDOT( SP_B, SP_C ) != 0.0  ||
	    VDOT( SP_A, SP_C ) != 0.0 )  {
d170 2
a171 1
	VMOVE( ell->ell_V, &sp->s_values[0] );
d173 1
a173 1
	VSET( ell->ell_invsq, 1.0/magsq_a, 1.0/magsq_b, 1.0/magsq_c );
d180 1
a180 1
	VSCALE( &R[0], SP_A, f );
d182 1
a182 1
	VSCALE( &R[4], SP_B, f );
d184 1
a184 1
	VSCALE( &R[8], SP_C, f );
d188 3
a190 3
	SS[ 0] = ell->ell_invsq[0];
	SS[ 5] = ell->ell_invsq[1];
	SS[10] = ell->ell_invsq[2];
d197 3
a199 3
	VSCALE( &ell->ell_SoR[0], SP_A, ell->ell_invsq[0] );
	VSCALE( &ell->ell_SoR[4], SP_B, ell->ell_invsq[1] );
	VSCALE( &ell->ell_SoR[8], SP_C, ell->ell_invsq[2] );
a219 1
	VPRINT("1/magitude**2", ell->ell_invsq );
d232 2
a233 5
 *  	0	HIT
 *  	1	MISS
 *  
 *  Implicit Return -
 *  	struct seg is added to st_next chain headed by HeadSeg.
d235 1
d262 1
a262 1
		return(1);		/* No hit */
d313 1
a313 3
	segp->seg_next = HeadSeg;
	HeadSeg = segp;
	return(0);			/* HIT */
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * Function -
d14 1
a14 1
 * $Revision$
d17 1
a17 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d26 1
a26 1
 *  Algorithm;
d98 2
a103 3
	vect_t	ell_A;		/* Three axis vectors */
	vect_t	ell_B;
	vect_t	ell_C;
d105 1
a105 1
	mat_t	ell_SoS;	/* Scale(Scale(vect)) */
d109 15
d125 1
a125 1
struct solidrec *sp;
d130 6
a135 2
	double magsq_a, magsq_b, magsq_c;
	float f;
d137 3
a139 3
	/* Should do some validation here */
	/* A.B == 0, B.C == 0, A.C == 0 */
	/* |A| > 0, |B| > 0, |C| > 0 */
d141 22
a166 3
	VMOVE( ell->ell_A, &sp->s_values[3] );
	VMOVE( ell->ell_B, &sp->s_values[6] );
	VMOVE( ell->ell_C, &sp->s_values[9] );
a167 4
	magsq_a = MAGSQ( ell->ell_A );
	magsq_b = MAGSQ( ell->ell_B );
	magsq_c = MAGSQ( ell->ell_C );

d171 1
a171 1
	mat_zero( ell->ell_SoS );
d173 8
a180 4
	/* Uses 3x3 of the 4x4 matrix */
	ell->ell_SoS[ 0] = ell->ell_invsq[0];
	ell->ell_SoS[ 5] = ell->ell_invsq[1];
	ell->ell_SoS[10] = ell->ell_invsq[2];
d182 4
a185 3
	VSCALE( &ell->ell_SoR[0], ell->ell_A, ell->ell_invsq[0] );
	VSCALE( &ell->ell_SoR[4], ell->ell_B, ell->ell_invsq[1] );
	VSCALE( &ell->ell_SoR[8], ell->ell_C, ell->ell_invsq[2] );
d187 9
a214 3
	VPRINT("A", ell->ell_A);
	VPRINT("B", ell->ell_B);
	VPRINT("C", ell->ell_C);
d217 1
a217 1
	mat_print("S o S", ell->ell_SoS );
d220 14
a233 2
extern struct seg *HeadSeg;	/* Pointer to segment list */

d247 1
d296 1
a296 1
		VELMUL( segp->seg_in.hit_normal, xlated, ell->ell_invsq );
d307 1
a307 1
		VELMUL( segp->seg_out.hit_normal, xlated, ell->ell_invsq );
@
