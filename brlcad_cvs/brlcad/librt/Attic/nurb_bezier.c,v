head	11.14;
access;
symbols
	ansi-20040405-merged:11.10.2.2
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.10.10.1
	premerge-autoconf:11.11
	ansi-20040316-freeze:11.10.2.1
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.10.4.1
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.10
	phong-branch:11.10.0.8
	photonmap-branch:11.10.0.6
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.7
	offsite-5-3-pre:11.7
	rel-5-3:11.7
	rel-5-2:11.7
	rel-5-1-branch:11.7.0.2
	rel-5-1:11.7
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.5
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.14
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.13;

11.13
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.12;

11.12
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2002.08.20.17.08.06;	author jra;	state Exp;
branches
	11.10.2.1
	11.10.4.1
	11.10.10.1;
next	11.9;

11.9
date	2002.08.15.20.55.19;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2001.04.20.22.29.54;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2000.03.28.21.25.11;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.12.22.02.24.07;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	97.09.09.14.01.13;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	96.12.31.01.09.27;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.12.01.02.49.33;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.43;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	10.4;

10.4
date	94.08.11.01.09.53;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	92.06.02.22.48.25;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.29.00.51.53;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.05;	author mike;	state Rel4_0;
branches;
next	1.2;

1.2
date	91.06.14.09.42.04;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	91.05.18.02.35.01;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.10.2.1
date	2002.09.19.18.01.42;	author morrison;	state Exp;
branches;
next	11.10.2.2;

11.10.2.2
date	2004.03.17.21.18.55;	author morrison;	state Exp;
branches;
next	;

11.10.4.1
date	2004.03.11.23.43.43;	author morrison;	state Exp;
branches;
next	;

11.10.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	;


desc
@Bezier routines
@


11.14
log
@moved to src/
@
text
@/*		N U R B _ B E Z I E R . C
 *
 *  Function-
 *  	Convert a NURB surface or curve into Bezier form, with no internal knots.
 *
 *  Author -
 *	Paul R. Stay
 *
 *  Source -
 *     SECAD/VLD Computing Consortium, Bldg 394
 *     The U.S. Army Ballistic Research Laboratory
 *     Aberdeen Proving Ground, Maryland 21005
 *
 * Copyright Notice -
 *     This software is Copyright (C) 1991-2004 by the United States Army.
 *     All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"

/*
 *			R T _ N U R B _ B E Z I E R
 *
 *  Given a single snurb, if it is in Bezier form,
 *  duplicate the snurb, and enqueue it on the bezier_hd list.
 *  If the original snurb is NOT in Bezier form,
 *  subdivide it a set of snurbs which are,
 *  each of which are enqueued on the bezier_hd list.
 *
 *  In either case, the original surface remains untouched.
 *
 *  Returns -
 *	0	Surface splitting was done.
 *	1	Original surface was Bezier, only a copy was done.
 */
int
rt_nurb_bezier(struct bu_list *bezier_hd, const struct face_g_snurb *orig_surf, struct resource *res)
{
	struct face_g_snurb	*s;
	int		dir;
	struct bu_list	todo;

	NMG_CK_SNURB(orig_surf);

	if( (dir = rt_bez_check( orig_surf )) == -1)  {
		s = rt_nurb_scopy( orig_surf, res );
		BU_LIST_APPEND( bezier_hd, &s->l );
		return 1;	/* Was already Bezier, nothing done */
	}

	BU_LIST_INIT( &todo );
	rt_nurb_s_split( &todo, orig_surf, dir, res );

	while( BU_LIST_WHILE( s, face_g_snurb, &todo ) )  {
		if( (dir = rt_bez_check(s)) == -1)  {
			/* This snurb is now a Bezier */
			BU_LIST_DEQUEUE( &s->l );
			BU_LIST_APPEND( bezier_hd, &s->l );
		} else {
			/* Split, and keep going */
			BU_LIST_DEQUEUE( &s->l );
			rt_nurb_s_split( &todo, s, dir, res );
			rt_nurb_free_snurb(s, res);
		}
	}
	return 0;		/* Bezier snurbs on bezier_hd list */
}

int
rt_bez_check(const struct face_g_snurb *srf)
{
	NMG_CK_SNURB(srf);

	if( srf->u.k_size > (2.0 * srf->order[0]))
		return 0;
	if( srf->v.k_size > (2.0 * srf->order[1]))
		return 1;

	return -1;
}

/*		N U R B _ C R V _ I S _ B E Z I E R
 *
 * Check if a NURB curve is in Bezier form.
 *
 * returns:
 *	1 - curve is Bezier
 *	0 - curve is not Bezier
 */

int
nurb_crv_is_bezier(const struct edge_g_cnurb *crv)
{
	int i;
	fastf_t knot_min, knot_max;
	int bezier=1;

	knot_min = crv->k.knots[0];
	knot_max = crv->k.knots[crv->k.k_size-1];

	for( i=1 ; i<crv->k.k_size-1 ; i++ )
	{
		if( crv->k.knots[i] != knot_min && crv->k.knots[i] != knot_max )
		{
			bezier = 0;
			break;
		}
	}

	return( bezier );
}

/*	N U R B _ C _ T O _ B E Z I E R
 *
 * Split NURB curve into list of Bezier curves.
 *
 * If curve is already Bezier, return NULL
 */

void
nurb_c_to_bezier(struct bu_list *clist, struct edge_g_cnurb *crv)
{
	fastf_t knot_min, knot_max;
	int i;
	struct edge_g_cnurb *crv1, *crv_copy;
	int done;

	/* make a copy of original curve */
	crv_copy = rt_nurb_crv_copy( crv );

	/* split curve at each knot value */
	done = 0;
	while( !done )
	{
		fastf_t split;

		knot_min = crv_copy->k.knots[0];
		knot_max = crv_copy->k.knots[crv_copy->k.k_size-1];

		split = MAX_FASTF;
		for( i=1 ; i<crv_copy->k.k_size-1 ; i++ )
		{
			if( crv_copy->k.knots[i] != knot_min && crv_copy->k.knots[i] != knot_max )
			{
				split = crv_copy->k.knots[i];
				break;
			}
		}

		if( split == MAX_FASTF )
		{
			done = 1;
			BU_LIST_APPEND( clist, &crv_copy->l );
			break;
		}

		crv1 = rt_nurb_c_xsplit( crv_copy, split );

		rt_nurb_free_cnurb( crv_copy );
		crv_copy = BU_LIST_PNEXT( edge_g_cnurb, &crv1->l );
		BU_LIST_DEQUEUE( &crv_copy->l );

		BU_LIST_APPEND( clist, &crv1->l );
	}
}
@


11.13
log
@change conf.h to a wrapped config.h
@
text
@@


11.12
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 5
a23 1
#include "conf.h"
@


11.11
log
@update copyright to include span through 2003
@
text
@d45 1
a45 4
rt_nurb_bezier( bezier_hd, orig_surf, res )
struct bu_list		*bezier_hd;
const struct face_g_snurb	*orig_surf;
struct resource *res;
d78 1
a78 2
rt_bez_check( srf )
const struct face_g_snurb * srf;
d100 1
a100 2
nurb_crv_is_bezier( crv )
const struct edge_g_cnurb *crv;
d129 1
a129 3
nurb_c_to_bezier( clist, crv )
struct bu_list *clist;
struct edge_g_cnurb *crv;
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 *     This software is Copyright (C) 1991 by the United States Army.
@


11.10.4.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *     This software is Copyright (C) 1991-2004 by the United States Army.
@


11.10.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *     This software is Copyright (C) 1991-2004 by the United States Army.
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d45 4
a48 1
rt_nurb_bezier(struct bu_list *bezier_hd, const struct face_g_snurb *orig_surf, struct resource *res)
d81 2
a82 1
rt_bez_check(const struct face_g_snurb *srf)
d104 2
a105 1
nurb_crv_is_bezier(const struct edge_g_cnurb *crv)
d134 3
a136 1
nurb_c_to_bezier(struct bu_list *clist, struct edge_g_cnurb *crv)
@


11.10.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *     This software is Copyright (C) 1991-2004 by the United States Army.
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d45 4
a48 1
rt_nurb_bezier(struct bu_list *bezier_hd, const struct face_g_snurb *orig_surf, struct resource *res)
d81 2
a82 1
rt_bez_check(const struct face_g_snurb *srf)
d104 2
a105 1
nurb_crv_is_bezier(const struct edge_g_cnurb *crv)
d134 3
a136 1
nurb_c_to_bezier(struct bu_list *clist, struct edge_g_cnurb *crv)
@


11.8
log
@CONST to const
@
text
@d45 1
a45 4
rt_nurb_bezier( bezier_hd, orig_surf, res )
struct bu_list		*bezier_hd;
const struct face_g_snurb	*orig_surf;
struct resource *res;
d78 1
a78 2
rt_bez_check( srf )
const struct face_g_snurb * srf;
d100 1
a100 2
nurb_crv_is_bezier( crv )
const struct edge_g_cnurb *crv;
d129 1
a129 3
nurb_c_to_bezier( clist, crv )
struct bu_list *clist;
struct edge_g_cnurb *crv;
@


11.7
log
@
Prototypes for nurb_bezier moved to raytrace.h
@
text
@d47 1
a47 1
CONST struct face_g_snurb	*orig_surf;
d82 1
a82 1
CONST struct face_g_snurb * srf;
d105 1
a105 1
CONST struct edge_g_cnurb *crv;
@


11.6
log
@
Removed dead vars
@
text
@a28 2
RT_EXTERN( struct edge_g_cnurb *rt_nurb_crv_copy, (struct edge_g_cnurb *crv ) );

@


11.5
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d142 1
a142 2
	int bezier=1;
	struct edge_g_cnurb *crv1, *crv2, *crv_copy;
@


11.4
log
@Added nurb_c_to_bezier() and nurb_crv_is_bezier().
@
text
@d47 1
a47 1
rt_nurb_bezier( bezier_hd, orig_surf )
d50 1
d59 1
a59 1
		s = rt_nurb_scopy( orig_surf );
d65 1
a65 1
	rt_nurb_s_split( &todo, orig_surf, dir );
d75 2
a76 2
			rt_nurb_s_split( &todo, s, dir );
			rt_nurb_free_snurb(s);
@


11.3
log
@libbu
@
text
@d4 1
a4 1
 *  	Convet a NURB surface into Bezier form, with no internal knots.
d29 2
d93 89
@


11.2
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d46 1
a46 1
struct rt_list		*bezier_hd;
d51 1
a51 1
	struct rt_list	todo;
d57 1
a57 1
		RT_LIST_APPEND( bezier_hd, &s->l );
d61 1
a61 1
	RT_LIST_INIT( &todo );
d64 1
a64 1
	while( RT_LIST_WHILE( s, face_g_snurb, &todo ) )  {
d67 2
a68 2
			RT_LIST_DEQUEUE( &s->l );
			RT_LIST_APPEND( bezier_hd, &s->l );
d71 1
a71 1
			RT_LIST_DEQUEUE( &s->l );
@


11.1
log
@Release_4.4
@
text
@d47 1
a47 1
CONST struct snurb	*orig_surf;
d49 1
a49 1
	struct snurb	*s;
d64 1
a64 1
	while( RT_LIST_WHILE( s, snurb, &todo ) )  {
d81 1
a81 1
CONST struct snurb * srf;
d85 1
a85 1
	if( srf->u_knots.k_size > (2.0 * srf->order[0]))
d87 1
a87 1
	if( srf->v_knots.k_size > (2.0 * srf->order[1]))
@


11.1.1.1
log
@Release_4.5
@
text
@d4 1
a4 1
 *  	Convert a NURB surface or curve into Bezier form, with no internal knots.
a28 2
RT_EXTERN( struct edge_g_cnurb *rt_nurb_crv_copy, (struct edge_g_cnurb *crv ) );

d45 3
a47 4
rt_nurb_bezier( bezier_hd, orig_surf, res )
struct bu_list		*bezier_hd;
CONST struct face_g_snurb	*orig_surf;
struct resource *res;
d49 1
a49 1
	struct face_g_snurb	*s;
d51 1
a51 1
	struct bu_list	todo;
d56 2
a57 2
		s = rt_nurb_scopy( orig_surf, res );
		BU_LIST_APPEND( bezier_hd, &s->l );
d61 2
a62 2
	BU_LIST_INIT( &todo );
	rt_nurb_s_split( &todo, orig_surf, dir, res );
d64 1
a64 1
	while( BU_LIST_WHILE( s, face_g_snurb, &todo ) )  {
d67 2
a68 2
			BU_LIST_DEQUEUE( &s->l );
			BU_LIST_APPEND( bezier_hd, &s->l );
d71 3
a73 3
			BU_LIST_DEQUEUE( &s->l );
			rt_nurb_s_split( &todo, s, dir, res );
			rt_nurb_free_snurb(s, res);
d81 1
a81 1
CONST struct face_g_snurb * srf;
d85 1
a85 1
	if( srf->u.k_size > (2.0 * srf->order[0]))
d87 1
a87 1
	if( srf->v.k_size > (2.0 * srf->order[1]))
a90 89
}

/*		N U R B _ C R V _ I S _ B E Z I E R
 *
 * Check if a NURB curve is in Bezier form.
 *
 * returns:
 *	1 - curve is Bezier
 *	0 - curve is not Bezier
 */

int
nurb_crv_is_bezier( crv )
CONST struct edge_g_cnurb *crv;
{
	int i;
	fastf_t knot_min, knot_max;
	int bezier=1;

	knot_min = crv->k.knots[0];
	knot_max = crv->k.knots[crv->k.k_size-1];

	for( i=1 ; i<crv->k.k_size-1 ; i++ )
	{
		if( crv->k.knots[i] != knot_min && crv->k.knots[i] != knot_max )
		{
			bezier = 0;
			break;
		}
	}

	return( bezier );
}

/*	N U R B _ C _ T O _ B E Z I E R
 *
 * Split NURB curve into list of Bezier curves.
 *
 * If curve is already Bezier, return NULL
 */

void
nurb_c_to_bezier( clist, crv )
struct bu_list *clist;
struct edge_g_cnurb *crv;
{
	fastf_t knot_min, knot_max;
	int i;
	int bezier=1;
	struct edge_g_cnurb *crv1, *crv2, *crv_copy;
	int done;

	/* make a copy of original curve */
	crv_copy = rt_nurb_crv_copy( crv );

	/* split curve at each knot value */
	done = 0;
	while( !done )
	{
		fastf_t split;

		knot_min = crv_copy->k.knots[0];
		knot_max = crv_copy->k.knots[crv_copy->k.k_size-1];

		split = MAX_FASTF;
		for( i=1 ; i<crv_copy->k.k_size-1 ; i++ )
		{
			if( crv_copy->k.knots[i] != knot_min && crv_copy->k.knots[i] != knot_max )
			{
				split = crv_copy->k.knots[i];
				break;
			}
		}

		if( split == MAX_FASTF )
		{
			done = 1;
			BU_LIST_APPEND( clist, &crv_copy->l );
			break;
		}

		crv1 = rt_nurb_c_xsplit( crv_copy, split );

		rt_nurb_free_cnurb( crv_copy );
		crv_copy = BU_LIST_PNEXT( edge_g_cnurb, &crv1->l );
		BU_LIST_DEQUEUE( &crv_copy->l );

		BU_LIST_APPEND( clist, &crv1->l );
	}
@


10.4
log
@Added includes
@
text
@@


10.3
log
@Changed to rt_list structures.
@
text
@d19 2
d22 1
@


10.2
log
@Modifications due to data structure revisions:  mesh and knots are no
longer pointers, but in-place structures.
@
text
@d4 1
a4 2
 *  	Convet the NURB surfaces into their bezier form 
 *	(no internal knots)
d22 2
d26 19
a44 3
struct snurb *
rt_nurb_bezier( srf )
struct snurb * srf;
d46 3
d50 1
a50 2
	struct snurb * s_list, *s, *split;
	int dir;
d52 5
a56 1
	s_list = (struct snurb *)0;
d58 2
a59 2
	if( (dir = rt_bez_check( srf )) == -1)
		return (struct snurb * ) srf;
d61 10
a70 19
	s = (struct snurb *) rt_nurb_s_split( srf, dir);

	while( s != (struct snurb *)0)
	{
		struct snurb * bez;

		bez = s;
		s = s->next;

		if( (dir = rt_bez_check(bez)) == -1)
		{
			bez->next = s_list;
			s_list = bez;
		} else
		{
			split = (struct snurb *) rt_nurb_s_split(bez, dir);
			split->next->next = s;
			s = split;
			rt_nurb_free_snurb(bez);
d73 1
a73 1
	return (struct snurb *) s_list;	
d78 1
a78 1
struct snurb * srf;
d80 2
@


10.1
log
@Release_4.0
@
text
@d66 1
a66 1
	if( srf->u_knots->k_size > (2.0 * srf->order[0]))
d68 1
a68 1
	if( srf->v_knots->k_size > (2.0 * srf->order[1]))
@


1.2
log
@fixed nurb.h
@
text
@@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
#include "./nurb.h"
@
