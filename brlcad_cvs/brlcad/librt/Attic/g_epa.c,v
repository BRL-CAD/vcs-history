head	11.31;
access;
symbols
	ansi-20040405-merged:11.27.2.2
	postmerge-20040405-ansi:11.29
	premerge-20040404-ansi:11.28
	postmerge-autoconf:11.28
	autoconf-freeze:11.27.10.2
	premerge-autoconf:11.28
	ansi-20040316-freeze:11.27.2.1
	postmerge-20040315-windows:11.28
	premerge-20040315-windows:11.28
	windows-20040315-freeze:11.27.4.1
	autoconf-20031203:11.27
	autoconf-20031202:11.27
	autoconf-branch:11.27.0.10
	phong-branch:11.27.0.8
	photonmap-branch:11.27.0.6
	rel-6-1-DP:11.27
	windows-branch:11.27.0.4
	rel-6-0-2:11.25
	ansi-branch:11.27.0.2
	rel-6-0-1-branch:11.25.0.2
	hartley-6-0-post:11.26
	hartley-6-0-pre:11.25
	rel-6-0-1:11.25
	rel-6-0:11.25
	rel-5-4:11.12
	offsite-5-3-pre:11.20
	rel-5-3:11.12
	rel-5-2:11.12
	rel-5-1-branch:11.12.0.2
	rel-5-1:11.12
	rel-5-0:11.6
	rel-5-0-beta:11.5
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.31
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	11.30;

11.30
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.29;

11.29
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2004.02.02.17.39.20;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2002.08.20.17.07.59;	author jra;	state Exp;
branches
	11.27.2.1
	11.27.4.1
	11.27.10.1;
next	11.26;

11.26
date	2002.08.15.20.55.12;	author hartley;	state Exp;
branches;
next	11.25;

11.25
date	2001.10.02.19.24.29;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	2001.09.06.15.29.03;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	2001.05.16.21.38.04;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2001.04.20.22.29.44;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2001.03.31.01.57.07;	author morrison;	state Exp;
branches;
next	11.20;

11.20
date	2000.10.18.18.10.34;	author butler;	state Exp;
branches;
next	11.19;

11.19
date	2000.08.22.21.16.59;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.08.21.02.02.30;	author butler;	state Exp;
branches;
next	11.17;

11.17
date	2000.07.10.23.01.31;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.06.30.15.38.02;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.06.30.15.31.14;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.06.27.15.33.32;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	2000.06.26.20.42.11;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	2000.04.12.02.34.33;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.03.29.02.43.10;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.11.26.21.46.46;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.11.24.23.12.07;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.11.17.02.41.58;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.10.30.03.53.27;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.07.02.22.19.22;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.05.27.19.10.37;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.04.12.23.02.28;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	97.06.30.13.36.14;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	96.10.21.19.11.33;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.37;	author mike;	state Rel4_4;
branches;
next	10.16;

10.16
date	94.12.27.16.25.08;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	94.11.05.02.09.35;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	94.09.15.22.19.22;	author jra;	state Exp;
branches;
next	10.13;

10.13
date	94.09.12.20.14.16;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.09.12.15.53.33;	author jra;	state Exp;
branches;
next	10.11;

10.11
date	94.09.02.16.03.26;	author jra;	state Exp;
branches;
next	10.10;

10.10
date	94.08.10.18.27.27;	author gdurf;	state Exp;
branches;
next	10.9;

10.9
date	93.11.18.01.44.03;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	93.11.04.19.24.52;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	93.07.20.22.48.33;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.07.20.16.14.36;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.03.27.12.59.21;	author mmark;	state Exp;
branches;
next	10.4;

10.4
date	92.03.25.15.52.52;	author mmark;	state Exp;
branches;
next	10.3;

10.3
date	92.03.24.14.36.13;	author mmark;	state Exp;
branches;
next	10.2;

10.2
date	92.02.14.15.32.34;	author mmark;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.16;	author mike;	state Rel4_0;
branches;
next	1.8;

1.8
date	91.09.20.23.06.37;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	91.06.30.00.10.50;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	91.06.22.22.30.22;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.05.18.03.00.54;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.01.25.20.35.36;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	90.12.05.20.30.01;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.10.06.02.05.13;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.03.14.14.48.32;	author phil;	state Exp;
branches;
next	;

11.27.2.1
date	2002.09.19.18.01.33;	author morrison;	state Exp;
branches;
next	11.27.2.2;

11.27.2.2
date	2004.03.17.21.18.46;	author morrison;	state Exp;
branches;
next	;

11.27.4.1
date	2004.03.11.23.43.37;	author morrison;	state Exp;
branches;
next	;

11.27.10.1
date	2004.02.12.18.37.40;	author erikg;	state Exp;
branches;
next	11.27.10.2;

11.27.10.2
date	2004.03.15.14.07.19;	author erikg;	state Exp;
branches;
next	;


desc
@Elliptic Paraboloid
@


11.31
log
@moved to src/
@
text
@/*
 *			G _ E P A . C
 *
 *  Purpose -
 *	Intersect a ray with an Elliptical Paraboloid
 *
 *  Algorithm -
 *  
 *  Given V, H, R, and B, there is a set of points on this epa
 *  
 *  { (x,y,z) | (x,y,z) is on epa }
 *  
 *  Through a series of Affine Transformations, this set of points will be
 *  transformed into a set of points on an epa located at the origin
 *  with a semi-major axis R1 along the +Y axis, a semi-minor axis R2
 *  along the -X axis, a height H along the -Z axis, and a vertex V at
 *  the origin.
 *  
 *  
 *  { (x',y',z') | (x',y',z') is on epa at origin }
 *
 *  The transformation from X to X' is accomplished by:
 *  
 *  X' = S(R( X - V ))
 *  
 *  where R(X) =  ( R1/(-|R1|) )
 *  		 (  R2/( |R2|)  ) . X
 *  		  ( H /(-|H |) )
 *  
 *  and S(X) =	 (  1/|R1|   0     0   )
 *  		(    0    1/|R2|   0    ) . X
 *  		 (   0      0   1/|H | )
 *  
 *  To find the intersection of a line with the surface of the epa,
 *  consider the parametric line L:
 *  
 *  	L : { P(n) | P + t(n) . D }
 *  
 *  Call W the actual point of intersection between L and the epa.
 *  Let W' be the point of intersection between L' and the unit epa.
 *  
 *  	L' : { P'(n) | P' + t(n) . D' }
 *  
 *  W = invR( invS( W' ) ) + V
 *  
 *  Where W' = k D' + P'.
 *  
 *  If Dy' and Dz' are both 0, then there is no hit on the epa;
 *  but the end plates need checking.  If there is now only 1 hit
 *  point, the top plate needs to be checked as well.
 *
 *  Line L' hits the infinitely long epa at W' when
 *
 *	A * k**2 + B * k + C = 0
 *
 *  where
 *
 *  A = Dx'**2 + Dy'**2
 *  B = 2 * (Dx' * Px' + Dy' * Py') - Dz'
 *  C = Px'**2 + Py'**2 - Pz' - 1
 *  b = |Breadth| = 1.0
 *  h = |Height| = 1.0
 *  r = 1.0
 *  
 *  The quadratic formula yields k (which is constant):
 *
 *  k = [ -B +/- sqrt( B**2 - 4 * A * C )] / (2.0 * A)
 *  
 *  Now, D' = S( R( D ) )
 *  and  P' = S( R( P - V ) )
 *  
 *  Substituting,
 *  
 *  W = V + invR( invS[ k *( S( R( D ) ) ) + S( R( P - V ) ) ] )
 *    = V + invR( ( k * R( D ) ) + R( P - V ) )
 *    = V + k * D + P - V
 *    = k * D + P
 *  
 *  Note that ``k'' is constant, and is the same in the formulations
 *  for both W and W'.
 *
 *  The hit at ``k'' is a hit on the canonical epa IFF
 *  Wz' <= 0.
 *
 *  NORMALS.  Given the point W on the surface of the epa,
 *  what is the vector normal to the tangent plane at that point?
 *  
 *  Map W onto the unit epa, ie:  W' = S( R( W - V ) ).
 *  
 *  Plane on unit epa at W' has a normal vector N' where
 *
 *  N' = <Wx', Wy', -.5>.
 *  
 *  The plane transforms back to the tangent plane at W, and this
 *  new plane (on the original epa) has a normal vector of N, viz:
 *  
 *  N = inverse[ transpose( inverse[ S o R ] ) ] ( N' )
 *
 *  because if H is perpendicular to plane Q, and matrix M maps from
 *  Q to Q', then inverse[ transpose(M) ] (H) is perpendicular to Q'.
 *  Here, H and Q are in "prime space" with the unit sphere.
 *  [Somehow, the notation here is backwards].
 *  So, the mapping matrix M = inverse( S o R ), because
 *  S o R maps from normal space to the unit sphere.
 *
 *  N = inverse[ transpose( inverse[ S o R ] ) ] ( N' )
 *    = inverse[ transpose(invR o invS) ] ( N' )
 *    = inverse[ transpose(invS) o transpose(invR) ] ( N' )
 *    = inverse[ inverse(S) o R ] ( N' )
 *    = invR o S ( N' )
 *
 *  because inverse(R) = transpose(R), so R = transpose( invR ),
 *  and S = transpose( S ).
 *
 *  Note that the normal vector produced above will not have unit length.
 *
 *  THE TOP PLATE.
 *
 *  If Dz' == 0, line L' is parallel to the top plate, so there is no
 *  hit on the top plate.  Otherwise, rays intersect the top plate
 *  with k = (0 - Pz')/Dz'.  The solution is within the top plate
 *  IFF Wx'**2 + Wy'**2 <= 1.
 *
 *  The normal for a hit on the top plate is -Hunit.
 *
 *  Authors -
 *	Michael J. Markowski
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSepa[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_epa.c,v 11.30 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"

struct epa_specific {
	point_t	epa_V;		/* vector to epa origin */
	vect_t	epa_Hunit;	/* unit H vector */
	vect_t	epa_Aunit;	/* unit vector along semi-major axis */
	vect_t	epa_Bunit;	/* unit vector, A x H */
	fastf_t	epa_h;		/* |H| */
	fastf_t	epa_inv_r1sq;	/* 1/(r1 * r1) */
	fastf_t	epa_inv_r2sq;	/* 1/(r2 * r2) */
	mat_t	epa_SoR;	/* Scale(Rot(vect)) */
	mat_t	epa_invRoS;	/* invRot(Scale(vect)) */
};

const struct bu_structparse rt_epa_parse[] = {
    { "%f", 3, "V",   offsetof(struct rt_epa_internal, epa_V[X]),  BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "H",   offsetof(struct rt_epa_internal, epa_H[X]),  BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "A",   offsetof(struct rt_epa_internal, epa_Au[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_1", offsetof(struct rt_epa_internal, epa_r1),    BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_2", offsetof(struct rt_epa_internal, epa_r2),    BU_STRUCTPARSE_FUNC_NULL },
    { {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
};

/*
 *  			R T _ E P A _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid EPA, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	EPA is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct epa_specific is created, and it's address is stored in
 *  	stp->st_specific for use by epa_shot().
 */
int
rt_epa_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_epa_internal		*xip;
	register struct epa_specific	*epa;
#ifndef NO_MAGIC_CHECKING
	const struct bn_tol		*tol = &rtip->rti_tol;
#endif
	LOCAL fastf_t	magsq_h;
	LOCAL fastf_t	mag_a, mag_h;
	LOCAL fastf_t	f, r1, r2;
	LOCAL mat_t	R;
	LOCAL mat_t	Rinv;
	LOCAL mat_t	S;

#ifndef NO_MAGIC_CHECKING
	RT_CK_DB_INTERNAL(ip);
	BN_CK_TOL(tol);
#endif
	xip = (struct rt_epa_internal *)ip->idb_ptr;
	RT_EPA_CK_MAGIC(xip);

	/* compute |A| |H| */
	mag_a = sqrt( MAGSQ( xip->epa_Au ) );
	mag_h = sqrt( magsq_h = MAGSQ( xip->epa_H ) );
	r1 = xip->epa_r1;
	r2 = xip->epa_r2;
	/* Check for |H| > 0, |A| == 1, r1 >  0, r2 > 0 */
	if( NEAR_ZERO(mag_h, RT_LEN_TOL)
		|| !NEAR_ZERO(mag_a - 1.0, RT_LEN_TOL)
		|| r1 < 0.0 || r2 < 0.0 )  {
		return(1);		/* BAD, too small */
	}

	/* Check for A.H == 0 */
	f = VDOT( xip->epa_Au, xip->epa_H ) / mag_h;
	if( ! NEAR_ZERO(f, RT_DOT_TOL) )  {
		return(1);		/* BAD */
	}

	/*
	 *  EPA is ok
	 */
	stp->st_id = ID_EPA;		/* set soltab ID */
	stp->st_meth = &rt_functab[ID_EPA];

	BU_GETSTRUCT( epa, epa_specific );
	stp->st_specific = (genptr_t)epa;

	epa->epa_h = mag_h;
	epa->epa_inv_r1sq = 1 / (r1 * r1);
	epa->epa_inv_r2sq = 1 / (r2 * r2);

	/* make unit vectors in A, H, and BxH directions */
	VMOVE(    epa->epa_Hunit, xip->epa_H );
	VUNITIZE( epa->epa_Hunit );
	VMOVE(    epa->epa_Aunit, xip->epa_Au );
	VCROSS(   epa->epa_Bunit, epa->epa_Aunit, epa->epa_Hunit );

	VMOVE( epa->epa_V, xip->epa_V );

	/* Compute R and Rinv matrices */
	MAT_IDN( R );
	VREVERSE( &R[0], epa->epa_Bunit );
	VMOVE(    &R[4], epa->epa_Aunit );
	VREVERSE( &R[8], epa->epa_Hunit );
	bn_mat_trn( Rinv, R );			/* inv of rot mat is trn */

	/* Compute S */
	MAT_IDN( S );
	S[ 0] = 1.0/r2;
	S[ 5] = 1.0/r1;
	S[10] = 1.0/mag_h;

	/* Compute SoR and invRoS */
	bn_mat_mul( epa->epa_SoR, S, R );
	bn_mat_mul( epa->epa_invRoS, Rinv, S );

	/* Compute bounding sphere and RPP */
	/* bounding sphere center */
	VJOIN1( stp->st_center, epa->epa_V, mag_h / 2.0, epa->epa_Hunit );
	/* bounding radius */
	stp->st_bradius = sqrt(0.25*magsq_h + r2*r2 + r1*r1);
	/* approximate bounding radius */
	stp->st_aradius = stp->st_bradius;
	
	/* cheat, make bounding RPP by enclosing bounding sphere */
	stp->st_min[X] = stp->st_center[X] - stp->st_bradius;
	stp->st_max[X] = stp->st_center[X] + stp->st_bradius;
	stp->st_min[Y] = stp->st_center[Y] - stp->st_bradius;
	stp->st_max[Y] = stp->st_center[Y] + stp->st_bradius;
	stp->st_min[Z] = stp->st_center[Z] - stp->st_bradius;
	stp->st_max[Z] = stp->st_center[Z] + stp->st_bradius;

	return(0);			/* OK */
}

/*
 *			R T _ E P A _ P R I N T
 */
void
rt_epa_print(register const struct soltab *stp)
{
	register const struct epa_specific *epa =
		(struct epa_specific *)stp->st_specific;

	VPRINT("V", epa->epa_V);
	VPRINT("Hunit", epa->epa_Hunit);
	VPRINT("Aunit", epa->epa_Aunit);
	VPRINT("Bunit", epa->epa_Bunit);
	bn_mat_print("S o R", epa->epa_SoR );
	bn_mat_print("invR o S", epa->epa_invRoS );
}

/* hit_surfno is set to one of these */
#define	EPA_NORM_BODY	(1)		/* compute normal */
#define	EPA_NORM_TOP	(2)		/* copy epa_N */

/*
 *  			R T _ E P A _ S H O T
 *  
 *  Intersect a ray with a epa.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_epa_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct epa_specific *epa =
		(struct epa_specific *)stp->st_specific;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
	LOCAL vect_t	xlated;		/* translated vector */
	LOCAL struct hit hits[3];	/* 2 potential hit points */
	register struct hit *hitp;	/* pointer to hit point */

	hitp = &hits[0];

	/* out, Mat, vect */
	MAT4X3VEC( dprime, epa->epa_SoR, rp->r_dir );
	VSUB2( xlated, rp->r_pt, epa->epa_V );
	MAT4X3VEC( pprime, epa->epa_SoR, xlated );

	/* Find roots of the equation, using formula for quadratic */
	{
		FAST fastf_t	a, b, c;	/* coeffs of polynomial */
		FAST fastf_t	disc;		/* disc of radical */
		
		a = dprime[X] * dprime[X] + dprime[Y] * dprime[Y];
		b = 2*(dprime[X] * pprime[X] + dprime[Y] * pprime[Y])
			- dprime[Z];
		c = pprime[X] * pprime[X]
			+ pprime[Y] * pprime[Y] - pprime[Z] - 1.0;
		if ( !NEAR_ZERO(a, RT_PCOEF_TOL) ) {
			disc = b*b - 4 * a * c;
			if (disc <= 0)
				goto check_plates;
			disc = sqrt(disc);

			k1 = (-b + disc) / (2.0 * a);
			k2 = (-b - disc) / (2.0 * a);

			/*
			 *  k1 and k2 are potential solutions to intersection
			 *  with side.  See if they fall in range.
			 */
			VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );	/* hit' */
			if( hitp->hit_vpriv[Z] <= 0.0 ) {
				hitp->hit_magic = RT_HIT_MAGIC;
				hitp->hit_dist = k1;
				hitp->hit_surfno = EPA_NORM_BODY;	/* compute N */
				hitp++;
			}

			VJOIN1( hitp->hit_vpriv, pprime, k2, dprime );	/* hit' */
			if( hitp->hit_vpriv[Z] <= 0.0 ) {
				hitp->hit_magic = RT_HIT_MAGIC;
				hitp->hit_dist = k2;
				hitp->hit_surfno = EPA_NORM_BODY;	/* compute N */
				hitp++;
			}
		} else if ( !NEAR_ZERO(b, RT_PCOEF_TOL) ) {
			k1 = -c/b;
			VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );	/* hit' */
			if( hitp->hit_vpriv[Z] <= 0.0 ) {
				hitp->hit_magic = RT_HIT_MAGIC;
				hitp->hit_dist = k1;
				hitp->hit_surfno = EPA_NORM_BODY;	/* compute N */
				hitp++;
			}
		}
	}


	/*
	 * Check for hitting the top plate.
	 */
check_plates:
	/* check top plate */
	if( hitp == &hits[1]  &&  !NEAR_ZERO(dprime[Z], SMALL) )  {
		/* 1 hit so far, this is worthwhile */
		k1 = -pprime[Z] / dprime[Z];		/* top plate */

		VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );	/* hit' */
		if( hitp->hit_vpriv[X] * hitp->hit_vpriv[X] +
			hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y] <= 1.0 ) {
			hitp->hit_magic = RT_HIT_MAGIC;
			hitp->hit_dist = k1;
			hitp->hit_surfno = EPA_NORM_TOP;	/* -H */
			hitp++;
		}
	}
	
	if( hitp != &hits[2] )
		return(0);	/* MISS */

	if( hits[0].hit_dist < hits[1].hit_dist )  {
		/* entry is [0], exit is [1] */
		register struct seg *segp;

		RT_GET_SEG(segp, ap->a_resource);
		segp->seg_stp = stp;
		segp->seg_in = hits[0];		/* struct copy */
		segp->seg_out = hits[1];	/* struct copy */
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	} else {
		/* entry is [1], exit is [0] */
		register struct seg *segp;

		RT_GET_SEG(segp, ap->a_resource);
		segp->seg_stp = stp;
		segp->seg_in = hits[1];		/* struct copy */
		segp->seg_out = hits[0];	/* struct copy */
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	}
	return(2);			/* HIT */
}

#define RT_EPA_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ E P A _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_epa_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	rt_vstub( stp, rp, segp, n, ap );
}

/*
 *  			R T _ E P A _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_epa_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	fastf_t	scale;
	vect_t	can_normal;	/* normal to canonical epa */
	register struct epa_specific *epa =
		(struct epa_specific *)stp->st_specific;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	switch( hitp->hit_surfno )  {
	case EPA_NORM_BODY:
		VSET( can_normal,
			hitp->hit_vpriv[X],
			hitp->hit_vpriv[Y],
			-0.5 );
		MAT4X3VEC( hitp->hit_normal, epa->epa_invRoS, can_normal );
		scale = 1.0 / MAGNITUDE( hitp->hit_normal );
		VSCALE( hitp->hit_normal, hitp->hit_normal, scale );

		/* tuck away this scale for the curvature routine */
		hitp->hit_vpriv[X] = scale;
		break;
	case EPA_NORM_TOP:
		VREVERSE( hitp->hit_normal, epa->epa_Hunit );
		break;
	default:
		bu_log("rt_epa_norm: surfno=%d bad\n", hitp->hit_surfno);
		break;
	}
}

/*
 *			R T _ E P A _ C U R V E
 *
 *  Return the curvature of the epa.
 */
void
rt_epa_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	fastf_t	a, b, c, scale;
	mat_t	M1, M2;
	register struct epa_specific *epa =
		(struct epa_specific *)stp->st_specific;
	vect_t	u, v;			/* basis vectors (with normal) */
	vect_t	vec1, vec2;		/* eigen vectors */
	vect_t	tmp;

	switch( hitp->hit_surfno )  {
	case EPA_NORM_BODY:
		/*
		 * choose a tangent plane coordinate system
		 *  (u, v, normal) form a right-handed triple
		 */
		bn_vec_ortho( u, hitp->hit_normal );
		VCROSS( v, hitp->hit_normal, u );
		
		/* get the saved away scale factor */
		scale = - hitp->hit_vpriv[X];

		MAT_IDN( M1 );
		M1[10] = 0;	/* M1[3,3] = 0 */
		/* M1 = invR * S * M1 * S * R */
		bn_mat_mul( M2, epa->epa_invRoS, M1);
		bn_mat_mul( M1, M2, epa->epa_SoR );

		/* find the second fundamental form */
		MAT4X3VEC( tmp, M1, u );
		a = VDOT(u, tmp) * scale;
		b = VDOT(v, tmp) * scale;
		MAT4X3VEC( tmp, M1, v );
		c = VDOT(v, tmp) * scale;

		eigen2x2( &cvp->crv_c1, &cvp->crv_c2, vec1, vec2, a, b, c );
		VCOMB2( cvp->crv_pdir, vec1[X], u, vec1[Y], v );
		VUNITIZE( cvp->crv_pdir );
		break;
	case EPA_NORM_TOP:
	 	cvp->crv_c1 = cvp->crv_c2 = 0;
		/* any tangent direction */
	 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
	 	break;
	}
}

/*
 *  			R T _ E P A _ U V
 *  
 *  For a hit on the surface of an epa, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_epa_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct epa_specific *epa =
		(struct epa_specific *)stp->st_specific;
	LOCAL vect_t work;
	LOCAL vect_t pprime;
	FAST fastf_t len;

	/*
	 * hit_point is on surface;  project back to unit epa,
	 * creating a vector from vertex to hit point.
	 */
	VSUB2( work, hitp->hit_point, epa->epa_V );
	MAT4X3VEC( pprime, epa->epa_SoR, work );

	switch( hitp->hit_surfno )  {
	case EPA_NORM_BODY:
		/* top plate, polar coords */
		if (pprime[Z] == -1.0) {	/* bottom pt of body */
			uvp->uv_u = 0;
		} else {
			len = sqrt(pprime[X]*pprime[X] + pprime[Y]*pprime[Y]);
			uvp->uv_u = acos(pprime[X]/len) * bn_inv2pi;
		}
		uvp->uv_v = -pprime[Z];
		break;
	case EPA_NORM_TOP:
		/* top plate, polar coords */
		len = sqrt(pprime[X]*pprime[X] + pprime[Y]*pprime[Y]);
		uvp->uv_u = acos(pprime[X]/len) * bn_inv2pi;
		uvp->uv_v = 1.0 - len;
		break;
	}
	/* Handle other half of acos() domain */
	if( pprime[Y] < 0 )
		uvp->uv_u = 1.0 - uvp->uv_u;

	/* uv_du should be relative to rotation, uv_dv relative to height */
	uvp->uv_du = uvp->uv_dv = 0;
}

/*
 *		R T _ E P A _ F R E E
 */
void
rt_epa_free(register struct soltab *stp)
{
	register struct epa_specific *epa =
		(struct epa_specific *)stp->st_specific;


	bu_free( (char *)epa, "epa_specific" );
}

/*
 *			R T _ E P A _ C L A S S
 */
int
rt_epa_class(void)
{
	return(0);
}

/*
 *			R T _ E P A _ P L O T
 */
int
rt_epa_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	fastf_t		dtol, f, mag_a, mag_h, ntol, r1, r2;
	fastf_t		**ellipses, theta_new, theta_prev, rt_ell_ang(fastf_t *p1, fastf_t a, fastf_t b, fastf_t dtol, fastf_t ntol);
	int		*pts_dbl, i, j, nseg;
	int		jj, na, nb, nell, recalc_b;
	LOCAL mat_t	R;
	LOCAL mat_t	invR;
	LOCAL struct rt_epa_internal	*xip;
	point_t		p1;
	struct rt_pt_node	*pos_a, *pos_b, *pts_a, *pts_b, *rt_ptalloc(void);
	vect_t		A, Au, B, Bu, Hu, V, Work;
	
#ifndef NO_MAGIC_CHECKING
	RT_CK_DB_INTERNAL(ip);
#endif

	xip = (struct rt_epa_internal *)ip->idb_ptr;
	RT_EPA_CK_MAGIC(xip);

	/*
	 *	make sure epa description is valid
	 */
	 
	/* compute |A| |H| */
	mag_a = MAGSQ( xip->epa_Au );	/* should already be unit vector */
	mag_h = MAGNITUDE( xip->epa_H );
	r1 = xip->epa_r1;
	r2 = xip->epa_r2;
	/* Check for |H| > 0, |A| == 1, r1 > 0, r2 > 0 */
	if( NEAR_ZERO(mag_h, RT_LEN_TOL)
		|| !NEAR_ZERO(mag_a - 1.0, RT_LEN_TOL)
		|| r1 <= 0.0 || r2 <= 0.0 )  {
		return(-2);		/* BAD */
	}

	/* Check for A.H == 0 */
	f = VDOT( xip->epa_Au, xip->epa_H ) / mag_h;
	if( ! NEAR_ZERO(f, RT_DOT_TOL) )  {
		return(-2);		/* BAD */
	}

	/* make unit vectors in A, H, and BxH directions */
	VMOVE(    Hu, xip->epa_H );
	VUNITIZE( Hu );
	VMOVE(    Au, xip->epa_Au );
	VCROSS(   Bu, Au, Hu );

	/* Compute R and Rinv matrices */
	MAT_IDN( R );
	VREVERSE( &R[0], Bu );
	VMOVE(    &R[4], Au );
	VREVERSE( &R[8], Hu );
	bn_mat_trn( invR, R );			/* inv of rot mat is trn */

	/*
	 *  Establish tolerances
	 */
	if( ttol->rel <= 0.0 || ttol->rel >= 1.0 )
		dtol = 0.0;		/* none */
	else
		/* Convert rel to absolute by scaling by smallest side */
		dtol = ttol->rel * 2 * r2;
	if( ttol->abs <= 0.0 )  {
		if( dtol <= 0.0 )
			/* No tolerance given, use a default */
			dtol = 2 * 0.10 * r2;	/* 10% */
		else
			/* Use absolute-ized relative tolerance */
			;
	} else {
		/* Absolute tolerance was given, pick smaller */
		if( ttol->rel <= 0.0 || dtol > ttol->abs )
			dtol = ttol->abs;
	}

	/* To ensure normal tolerance, remain below this angle */
	if( ttol->norm > 0.0 )
		ntol = ttol->norm;
	else
		/* tolerate everything */
		ntol = bn_pi;

	/*
	 *	build epa from 2 parabolas
	 */
	 
	/* approximate positive half of parabola along semi-minor axis */
	pts_b = rt_ptalloc();
	pts_b->next = rt_ptalloc();
	pts_b->next->next = NULL;
	VSET( pts_b->p,       0, 0, -mag_h);
	VSET( pts_b->next->p, 0, r2, 0);
	/* 2 endpoints in 1st approximation */
	nb = 2;
	/* recursively break segment 'til within error tolerances */
	nb += rt_mk_parabola( pts_b, r2, mag_h, dtol, ntol );
	nell = nb - 1;	/* # of ellipses needed */

	/* construct positive half of parabola along semi-major axis
	 * of epa using same z coords as parab along semi-minor axis
	 */
	pts_a = rt_ptalloc();
	VMOVE(pts_a->p, pts_b->p);	/* 1st pt is the apex */
	pts_a->next = NULL;
	pos_b = pts_b->next;
	pos_a = pts_a;
	while (pos_b) {
		/* copy node from b_parabola to a_parabola */
		pos_a->next = rt_ptalloc();
		pos_a = pos_a->next;
		pos_a->p[Z] = pos_b->p[Z];
		/* at given z, find y on parabola */
		pos_a->p[Y] = r1*sqrt( pos_a->p[Z] / mag_h + 1 );
		pos_a->p[X] = 0;
		pos_b = pos_b->next;
	}
	pos_a->next = NULL;
	
	/* see if any segments need further breaking up */
	recalc_b = 0;
	na = 0;
	pos_a = pts_a;
	while (pos_a->next) {
		na = rt_mk_parabola( pos_a, r1, mag_h, dtol, ntol );
		if (na != 0) {
			recalc_b = 1;
			nell += na;
		}
		pos_a = pos_a->next;
	}
	/* if any were broken, recalculate parabola 'a' */
	if ( recalc_b ) {
		/* free mem for old approximation of parabola */
		pos_b = pts_b;
		while ( pos_b ) {
			struct rt_pt_node *next;

			/* get next node before freeing */
			next = pos_b->next;
			bu_free( (char *)pos_b, "rt_pt_node" );
			pos_b = next;
		}
		/* construct parabola along semi-major axis of epa
		 * using same z coords as parab along semi-minor axis
		 */
		pts_b = rt_ptalloc();
		pts_b->p[Z] = pts_a->p[Z];
		pts_b->next = NULL;
		pos_a = pts_a->next;
		pos_b = pts_b;
		while (pos_a) {
			/* copy node from a_parabola to b_parabola */
			pos_b->next = rt_ptalloc();
			pos_b = pos_b->next;
			pos_b->p[Z] = pos_a->p[Z];
			/* at given z, find y on parabola */
			pos_b->p[Y] = r2*sqrt( pos_b->p[Z] / mag_h + 1 );
			pos_b->p[X] = 0;
			pos_a = pos_a->next;
		}
		pos_b->next = NULL;
	}
	
	/* make array of ptrs to epa ellipses */
	ellipses = (fastf_t **)bu_malloc( nell * sizeof(fastf_t *), "fastf_t ell[]");
	/* keep track of whether pts in each ellipse are doubled or not */
	pts_dbl = (int *)bu_malloc( nell * sizeof(int), "dbl ints" );

	/* make ellipses at each z level */
	i = 0;
	nseg = 0;
	theta_prev = bn_twopi;
	pos_a = pts_a->next;	/* skip over apex of epa */
	pos_b = pts_b->next;
	while (pos_a) {
		VSCALE( A, Au, pos_a->p[Y] );	/* semimajor axis */
		VSCALE( B, Bu, pos_b->p[Y] );	/* semiminor axis */
		VJOIN1( V, xip->epa_V, -pos_a->p[Z], Hu );

		VSET( p1, 0., pos_b->p[Y], 0. );
		theta_new = rt_ell_ang(p1, pos_a->p[Y], pos_b->p[Y], dtol, ntol);
		if (nseg == 0) {
			nseg = (int)(bn_twopi / theta_new) + 1;
			pts_dbl[i] = 0;
		} else if (theta_new < theta_prev) {
			nseg *= 2;
			pts_dbl[i] = 1;
		} else
			pts_dbl[i] = 0;
		theta_prev = theta_new;

		ellipses[i] = (fastf_t *)bu_malloc(3*(nseg+1)*sizeof(fastf_t),
			"pts ell");
		rt_ell( ellipses[i], V, A, B, nseg );
		
		i++;
		pos_a = pos_a->next;
		pos_b = pos_b->next;
	}
	/* Draw the top ellipse */
	RT_ADD_VLIST( vhead,
		&ellipses[nell-1][(nseg-1)*ELEMENTS_PER_VECT],
		BN_VLIST_LINE_MOVE );
	for( i = 0; i < nseg; i++ )  {
		RT_ADD_VLIST( vhead,
			&ellipses[nell-1][i*ELEMENTS_PER_VECT],
			BN_VLIST_LINE_DRAW );
	}

	/* connect ellipses */
	for (i = nell-2; i >= 0; i--) {	/* skip top ellipse */
		int bottom, top;

		top = i + 1;
		bottom = i;
		if (pts_dbl[top])
			nseg /= 2;	/* # segs in 'bottom' ellipse */

		/* Draw the current ellipse */
		RT_ADD_VLIST( vhead,
			&ellipses[bottom][(nseg-1)*ELEMENTS_PER_VECT],
			BN_VLIST_LINE_MOVE );
		for( j = 0; j < nseg; j++ )  {
			RT_ADD_VLIST( vhead,
				&ellipses[bottom][j*ELEMENTS_PER_VECT],
				BN_VLIST_LINE_DRAW );
		}

		/* make connections between ellipses */
		for (j = 0; j < nseg; j++) {
			if (pts_dbl[top])
				jj = j + j;	/* top ellipse index */
			else
				jj = j;
			RT_ADD_VLIST( vhead,
				&ellipses[bottom][j*ELEMENTS_PER_VECT],
				BN_VLIST_LINE_MOVE );
			RT_ADD_VLIST( vhead,
				&ellipses[top][jj*ELEMENTS_PER_VECT],
				BN_VLIST_LINE_DRAW );
		}
	}

	VADD2( Work, xip->epa_V, xip->epa_H );
	for (i = 0; i < nseg; i++) {
		/* Draw connector */
		RT_ADD_VLIST( vhead, Work, BN_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vhead,
			&ellipses[0][i*ELEMENTS_PER_VECT],
			BN_VLIST_LINE_DRAW );
	}

	/* free mem */
	for (i = 0; i < nell; i++) {
		bu_free( (char *)ellipses[i], "pts ell");
	}
	bu_free( (char *)ellipses, "fastf_t ell[]");
	bu_free( (char *)pts_dbl, "dbl ints" );

	return(0);
}

#define ELLOUT(n)	ov+(n-1)*3

void
rt_ell_norms(register fastf_t *ov, fastf_t *A, fastf_t *B, fastf_t *h_vec, fastf_t t, int sides)
{
	fastf_t	ang, theta, x, y, sqrt_1mt;
	int	n;
	vect_t partial_t, partial_ang;

	sqrt_1mt = sqrt( 1.0 - t );
	if( sqrt_1mt < SMALL_FASTF )
		rt_bomb( "rt_epa_tess: rt_ell_norms: sqrt( 1.0 -t ) is zero\n" );
	theta = 2 * bn_pi / sides;
	ang = 0.;

	for (n = 1; n <= sides; n++, ang += theta) {
		x = cos( ang );
		y = sin( ang );
		VJOIN2( partial_t, h_vec, -x/(2.0*sqrt_1mt), A, -y/(2.0*sqrt_1mt), B );
		VBLEND2( partial_ang, x*sqrt_1mt, B, -y*sqrt_1mt, A );
		VCROSS( ELLOUT(n), partial_t, partial_ang );
		VUNITIZE( ELLOUT(n) );
	}
	VMOVE(ELLOUT(n), ELLOUT(1));
}


/*
 *			R T _ E L L
 *
 *  Generate an ellipsoid with the specified number of sides approximating it.
 */
void
rt_ell(register fastf_t *ov, register const fastf_t *V, const fastf_t *A, const fastf_t *B, int sides)
{
	fastf_t	ang, theta, x, y;
	int	n;
	
	theta = 2 * bn_pi / sides;
	ang = 0.;
	/* make ellipse regardless of whether it meets req's */
	for (n = 1; n <= sides; n++, ang += theta) {
		x = cos( ang );
		y = sin( ang );
		VJOIN2( ELLOUT(n), V, x, A, y, B );
	}
	VMOVE(ELLOUT(n), ELLOUT(1));
}

/*
 *	R T _ E L L _ A N G
 *
 *	Return angle required for smallest side to fall within
 *	tolerances for ellipse.  Smallest side is a side with
 *	an endpoint at (a, 0, 0) where a is the semi-major axis.
 */
fastf_t
rt_ell_ang(fastf_t *p1, fastf_t a, fastf_t b, fastf_t dtol, fastf_t ntol)
{
	fastf_t	dist, intr, m, theta0, theta1;
	point_t	mpt, p0;
	vect_t	norm_line, norm_ell;
	
	VSET( p0, a, 0., 0. );
	/* slope and intercept of segment */
	m = ( p1[Y] - p0[Y] ) / ( p1[X] - p0[X] );
	intr = p0[Y] - m * p0[X];
	/* point on ellipse with max dist between ellipse and line */
	mpt[X] = a / sqrt( b*b / (m*m*a*a) + 1 );
	mpt[Y] = b * sqrt( 1 - mpt[X] * mpt[X] / (a*a) );
	mpt[Z] = 0;
	/* max distance between that point and line */
	dist = fabs( m * mpt[X] - mpt[Y] + intr ) / sqrt( m * m + 1 );
	/* angles between normal of line and of ellipse at line endpoints */
	VSET( norm_line, m, -1., 0.);
	VSET( norm_ell, b * b * p0[X], a * a * p0[Y], 0. );
	VUNITIZE( norm_line );
	VUNITIZE( norm_ell );
	theta0 = fabs( acos( VDOT( norm_line, norm_ell )));
	VSET( norm_ell, b * b * p1[X], a * a * p1[Y], 0. );
	VUNITIZE( norm_ell );
	theta1 = fabs( acos( VDOT( norm_line, norm_ell )));
	/* split segment at widest point if not within error tolerances */
	if ( dist > dtol || theta0 > ntol || theta1 > ntol ) {
		/* split segment */
		return( rt_ell_ang( mpt, a, b, dtol, ntol ) );
	} else
		return( acos( VDOT(p0, p1)
			/ ( MAGNITUDE(p0) * MAGNITUDE(p1) ) ));
}

/*
 *			R T _ E P A _ T E S S
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_epa_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	fastf_t		dtol, f, mag_a, mag_h, ntol, r1, r2;
	fastf_t		**ellipses, **normals, theta_new, theta_prev;
	int		*pts_dbl, face, i, j, nseg;
	int		*segs_per_ell;
	int		jj, na, nb, nell, recalc_b;
	LOCAL mat_t	R;
	LOCAL mat_t	invR;
	LOCAL struct rt_epa_internal	*xip;
	point_t		p1;
	struct rt_pt_node	*pos_a, *pos_b, *pts_a, *pts_b, *rt_ptalloc(void);
	struct shell	*s;
	struct faceuse	**outfaceuses = NULL;
	struct vertex	*vertp[3];
	struct vertex	***vells = (struct vertex ***)NULL;
	vect_t		A, Au, B, Bu, Hu, V;
	vect_t		apex_norm,rev_norm;
	vect_t		A_orig,B_orig;
	struct vertex	*apex_v;
	struct vertexuse *vu;
	struct faceuse *fu;
	
	RT_CK_DB_INTERNAL(ip);
	xip = (struct rt_epa_internal *)ip->idb_ptr;
	RT_EPA_CK_MAGIC(xip);

	/*
	 *	make sure epa description is valid
	 */
	 
	/* compute |A| |H| */
	mag_a = MAGSQ( xip->epa_Au );	/* should already be unit vector */
	mag_h = MAGNITUDE( xip->epa_H );
	r1 = xip->epa_r1;
	r2 = xip->epa_r2;
	/* Check for |H| > 0, |A| == 1, r1 > 0, r2 > 0 */
	if( NEAR_ZERO(mag_h, RT_LEN_TOL)
		|| !NEAR_ZERO(mag_a - 1.0, RT_LEN_TOL)
		|| r1 <= 0.0 || r2 <= 0.0 )  {
		return(-2);		/* BAD */
	}

	/* Check for A.H == 0 */
	f = VDOT( xip->epa_Au, xip->epa_H ) / mag_h;
	if( ! NEAR_ZERO(f, RT_DOT_TOL) )  {
		return(-2);		/* BAD */
	}

	/* make unit vectors in A, H, and BxH directions */
	VMOVE(    Hu, xip->epa_H );
	VUNITIZE( Hu );
	VMOVE(    Au, xip->epa_Au );
	VCROSS(   Bu, Au, Hu );

	VSCALE( A_orig , Au , xip->epa_r1 );
	VSCALE( B_orig , Bu , xip->epa_r2 );

	/* Compute R and Rinv matrices */
	MAT_IDN( R );
	VREVERSE( &R[0], Bu );
	VMOVE(    &R[4], Au );
	VREVERSE( &R[8], Hu );
	bn_mat_trn( invR, R );			/* inv of rot mat is trn */

	/*
	 *  Establish tolerances
	 */
	if( ttol->rel <= 0.0 || ttol->rel >= 1.0 )
		dtol = 0.0;		/* none */
	else
		/* Convert rel to absolute by scaling by smallest side */
		dtol = ttol->rel * 2 * r2;
	if( ttol->abs <= 0.0 )  {
		if( dtol <= 0.0 )
			/* No tolerance given, use a default */
			dtol = 2 * 0.10 * r2;	/* 10% */
		else
			/* Use absolute-ized relative tolerance */
			;
	} else {
		/* Absolute tolerance was given, pick smaller */
		if( ttol->rel <= 0.0 || dtol > ttol->abs )
			dtol = ttol->abs;
	}

	/* To ensure normal tolerance, remain below this angle */
	if( ttol->norm > 0.0 )
		ntol = ttol->norm;
	else
		/* tolerate everything */
		ntol = bn_pi;

	/*
	 *	build epa from 2 parabolas
	 */
	 
	/* approximate positive half of parabola along semi-minor axis */
	pts_b = rt_ptalloc();
	pts_b->next = rt_ptalloc();
	pts_b->next->next = NULL;
	VSET( pts_b->p,       0, 0, -mag_h);
	VSET( pts_b->next->p, 0, r2, 0);
	/* 2 endpoints in 1st approximation */
	nb = 2;
	/* recursively break segment 'til within error tolerances */
	nb += rt_mk_parabola( pts_b, r2, mag_h, dtol, ntol );
	nell = nb - 1;	/* # of ellipses needed */

	/* construct positive half of parabola along semi-major axis
	 * of epa using same z coords as parab along semi-minor axis
	 */
	pts_a = rt_ptalloc();
	VMOVE(pts_a->p, pts_b->p);	/* 1st pt is the apex */
	pts_a->next = NULL;
	pos_b = pts_b->next;
	pos_a = pts_a;
	while (pos_b) {
		/* copy node from b_parabola to a_parabola */
		pos_a->next = rt_ptalloc();
		pos_a = pos_a->next;
		pos_a->p[Z] = pos_b->p[Z];
		/* at given z, find y on parabola */
		pos_a->p[Y] = r1*sqrt( pos_a->p[Z] / mag_h + 1 );
		pos_a->p[X] = 0;
		pos_b = pos_b->next;
	}
	pos_a->next = NULL;
	
	/* see if any segments need further breaking up */
	recalc_b = 0;
	na = 0;
	pos_a = pts_a;
	while (pos_a->next) {
		na = rt_mk_parabola( pos_a, r1, mag_h, dtol, ntol );
		if (na != 0) {
			recalc_b = 1;
			nell += na;
		}
		pos_a = pos_a->next;
	}
	/* if any were broken, recalculate parabola 'a' */
	if ( recalc_b ) {
		/* free mem for old approximation of parabola */
		pos_b = pts_b;
		while ( pos_b ) {
			struct rt_pt_node *tmp;

			tmp = pos_b->next;
			bu_free( (char *)pos_b, "rt_pt_node" );
			pos_b = tmp;
		}
		/* construct parabola along semi-major axis of epa
		 * using same z coords as parab along semi-minor axis
		 */
		pts_b = rt_ptalloc();
		pts_b->p[Z] = pts_a->p[Z];
		pts_b->next = NULL;
		pos_a = pts_a->next;
		pos_b = pts_b;
		while (pos_a) {
			/* copy node from a_parabola to b_parabola */
			pos_b->next = rt_ptalloc();
			pos_b = pos_b->next;
			pos_b->p[Z] = pos_a->p[Z];
			/* at given z, find y on parabola */
			pos_b->p[Y] = r2*sqrt( pos_b->p[Z] / mag_h + 1 );
			pos_b->p[X] = 0;
			pos_a = pos_a->next;
		}
		pos_b->next = NULL;
	}
	
	/* make array of ptrs to epa ellipses */
	ellipses = (fastf_t **)bu_malloc( nell * sizeof(fastf_t *), "fastf_t ell[]");
	/* keep track of whether pts in each ellipse are doubled or not */
	pts_dbl = (int *)bu_malloc( nell * sizeof(int), "dbl ints" );
	/* I don't understand this pts_dbl, so here is an array containing the length of
	 * each ellipses array
	 */
	segs_per_ell = (int *)bu_calloc( nell , sizeof( int ) , "rt_epa_tess: segs_per_ell" );

	/* and an array of normals */
	normals = (fastf_t **)bu_malloc( nell * sizeof(fastf_t *), "fastf_t normals[]");

	/* make ellipses at each z level */
	i = 0;
	nseg = 0;
	theta_prev = bn_twopi;
	pos_a = pts_a->next;	/* skip over apex of epa */
	pos_b = pts_b->next;
	while (pos_a) {
		fastf_t t;

		t = (-pos_a->p[Z] / mag_h);
		VSCALE( A, Au, pos_a->p[Y] );	/* semimajor axis */
		VSCALE( B, Bu, pos_b->p[Y] );	/* semiminor axis */
		VJOIN1( V, xip->epa_V, -pos_a->p[Z], Hu );

		VSET( p1, 0., pos_b->p[Y], 0. );
		theta_new = rt_ell_ang(p1, pos_a->p[Y], pos_b->p[Y], dtol, ntol);
		if (nseg == 0) {
			nseg = (int)(bn_twopi / theta_new) + 1;
			pts_dbl[i] = 0;
			/* maximum number of faces needed for epa */
			face = nseg*(1 + 3*((1 << (nell-1)) - 1));
			/* array for each triangular face */
			outfaceuses = (struct faceuse **)
			bu_malloc( (face+1) * sizeof(struct faceuse *), "faceuse []" );
		} else if (theta_new < theta_prev) {
			nseg *= 2;
			pts_dbl[i] = 1;
		} else {
			pts_dbl[i] = 0;
		}
		theta_prev = theta_new;

		ellipses[i] = (fastf_t *)bu_malloc(3*(nseg+1)*sizeof(fastf_t),
			"pts ell");
		segs_per_ell[i] = nseg;
		normals[i] = (fastf_t *)bu_malloc(3*(nseg+1)*sizeof(fastf_t), "rt_epa_tess_ normals" );
		rt_ell( ellipses[i], V, A, B, nseg );
		rt_ell_norms( normals[i], A_orig, B_orig, xip->epa_H, t, nseg );

		i++;
		pos_a = pos_a->next;
		pos_b = pos_b->next;
	}

	/*
	 *	put epa geometry into nmg data structures
	 */
	 
	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);
	
	/* vertices of ellipses of epa */
	vells = (struct vertex ***)
		bu_malloc(nell*sizeof(struct vertex **), "vertex [][]");
	j = nseg;
	for (i = nell-1; i >= 0; i--) {
	        vells[i] = (struct vertex **)
	        	bu_malloc(j*sizeof(struct vertex *), "vertex []");
		if (i && pts_dbl[i])
			j /= 2;
	}

	/* top face of epa */
	for (i = 0; i < nseg; i++)
		vells[nell-1][i] = (struct vertex *)0;
	face = 0;
	if ( (outfaceuses[face++] = nmg_cface(s, vells[nell-1], nseg)) == 0) {
		bu_log("rt_epa_tess() failure, top face\n");
		goto fail;
	}
	for (i = 0; i < nseg; i++) {
		NMG_CK_VERTEX( vells[nell-1][i] );
		nmg_vertex_gv( vells[nell-1][i], &ellipses[nell-1][3*i] );
	}

	/* Mark the edges of this face as real, this is the only real edge */
	(void)nmg_mark_edges_real( &outfaceuses[0]->l.magic );
	
	/* connect ellipses with triangles */
	for (i = nell-2; i >= 0; i--) {	/* skip top ellipse */
		int bottom, top;

		top = i + 1;
		bottom = i;
		if (pts_dbl[top])
			nseg /= 2;	/* # segs in 'bottom' ellipse */
		vertp[0] = (struct vertex *)0;

		/* make triangular faces */
		for (j = 0; j < nseg; j++) {
			jj = j + j;	/* top ellipse index */
		
			if (pts_dbl[top]) {
				/* first triangle */
			        vertp[1] = vells[top][jj+1];
			        vertp[2] = vells[top][jj];
				if ( (outfaceuses[face++] = nmg_cface(s, vertp, 3)) == 0) {
					bu_log("rt_epa_tess() failure\n");
					goto fail;
				}
				if (j == 0)
				        vells[bottom][j] = vertp[0];

				/* second triangle */
			        vertp[2] = vertp[1];
				if (j == nseg-1)
					vertp[1] = vells[bottom][0];
				else
					vertp[1] = (struct vertex *)0;
				if ( (outfaceuses[face++] = nmg_cface(s, vertp, 3)) == 0) {
					bu_log("rt_epa_tess() failure\n");
					goto fail;
				}
				if (j != nseg-1)
					vells[bottom][j+1] = vertp[1];

				/* third triangle */
				vertp[0] = vertp[1];
				if (j == nseg-1)
					vertp[1] = vells[top][0];
				else
					vertp[1] = vells[top][jj+2];
				if ( (outfaceuses[face++] = nmg_cface(s, vertp, 3)) == 0) {
					bu_log("rt_epa_tess() failure\n");
					goto fail;
				}
			} else {
				/* first triangle */
				if (j == nseg-1)
					vertp[1] = vells[top][0];
				else
				        vertp[1] = vells[top][j+1];
			        vertp[2] = vells[top][j];
				if ( (outfaceuses[face++] = nmg_cface(s, vertp, 3)) == 0) {
					bu_log("rt_epa_tess() failure\n");
					goto fail;
				}
				if (j == 0)
				        vells[bottom][j] = vertp[0];

				/* second triangle */
			        vertp[2] = vertp[0];
				if (j == nseg-1)
					vertp[0] = vells[bottom][0];
				else
					vertp[0] = (struct vertex *)0;
				if ( (outfaceuses[face++] = nmg_cface(s, vertp, 3)) == 0) {
					bu_log("rt_epa_tess() failure\n");
					goto fail;
				}
				if (j != nseg-1)
					vells[bottom][j+1] = vertp[0];
			}
		}

		/* associate geometry with each vertex */
		for (j = 0; j < nseg; j++) {
			NMG_CK_VERTEX( vells[bottom][j] );
			nmg_vertex_gv( vells[bottom][j],
				&ellipses[bottom][3*j] );
		}
	}

	/* connect bottom of ellipse to apex of epa */
	VADD2(V, xip->epa_V, xip->epa_H);
        vertp[0] = (struct vertex *)0;
	vertp[1] = vells[0][1];
	vertp[2] = vells[0][0];
	if ( (outfaceuses[face++] = nmg_cface(s, vertp, 3)) == 0) {
		bu_log("rt_epa_tess() failure\n");
		goto fail;
	}
	/* associate geometry with topology */
	NMG_CK_VERTEX(vertp[0]);
	nmg_vertex_gv( vertp[0], (fastf_t *)V );
	apex_v = vertp[0];
	/* create rest of faces around apex */
	for (i = 1; i < nseg; i++) {
		vertp[2] = vertp[1];
		if (i == nseg-1)
			vertp[1] = vells[0][0];
		else
			vertp[1] = vells[0][i+1];
		if ( (outfaceuses[face++] = nmg_cface(s, vertp, 3)) == 0) {
			bu_log("rt_epa_tess() failure\n");
			goto fail;
		}
	}
	
	/* Associate the face geometry */
	for (i=0 ; i < face ; i++) {
		if( nmg_fu_planeeqn( outfaceuses[i], tol ) < 0 )
			goto fail;
	}

	/* Associate vertexuse normals */
	for( i=0 ; i<nell ; i++ )
	{
		for( j=0 ; j<segs_per_ell[i] ; j++ )
		{
			VREVERSE( rev_norm , &normals[i][j*3] );
			for( BU_LIST_FOR( vu , vertexuse , &vells[i][j]->vu_hd ) )
			{

				fu = nmg_find_fu_of_vu( vu );
				NMG_CK_FACEUSE( fu );

				if( fu == outfaceuses[0] || fu->fumate_p == outfaceuses[0] )
					continue;	/* don't assign normals to top faceuse (flat) */

				if( fu->orientation == OT_SAME )
					nmg_vertexuse_nv( vu , &normals[i][j*3] );
				else if( fu->orientation == OT_OPPOSITE )
					nmg_vertexuse_nv( vu , rev_norm );
			}
		}
	}
	/* and don't forget the apex */
	VMOVE( apex_norm , xip->epa_H );
	VUNITIZE( apex_norm );
	VREVERSE( rev_norm , apex_norm );
	for( BU_LIST_FOR( vu , vertexuse , &apex_v->vu_hd ) )
	{
		NMG_CK_VERTEXUSE( vu );
		fu = nmg_find_fu_of_vu( vu );
		NMG_CK_FACEUSE( fu );
		if( fu->orientation == OT_SAME )
			nmg_vertexuse_nv( vu , apex_norm );
		else if( fu->orientation == OT_OPPOSITE )
			nmg_vertexuse_nv( vu , rev_norm );
	}

	/* Glue the edges of different outward pointing face uses together */
	nmg_gluefaces( outfaceuses, face, tol );

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

	/* XXX just for testing, to make up for loads of triangles ... */
	nmg_shell_coplanar_face_merge( s, tol, 1 );
	
	/* free mem */
	bu_free( (char *)outfaceuses, "faceuse []");
	for (i = 0; i < nell; i++) {
		bu_free( (char *)ellipses[i], "pts ell");
	        bu_free( (char *)vells[i], "vertex []");
	}
	bu_free( (char *)ellipses, "fastf_t ell[]");
	bu_free( (char *)pts_dbl, "dbl ints" );
	bu_free( (char *)vells, "vertex [][]");

	return(0);

fail:
	/* free mem */
	bu_free( (char *)outfaceuses, "faceuse []");
	for (i = 0; i < nell; i++) {
		bu_free( (char *)ellipses[i], "pts ell");
	        bu_free( (char *)vells[i], "vertex []");
	}
	bu_free( (char *)ellipses, "fastf_t ell[]");
	bu_free( (char *)pts_dbl, "dbl ints" );
	bu_free( (char *)vells, "vertex [][]");

	return(-1);
}

/*
 *			R T _ E P A _ I M P O R T
 *
 *  Import an EPA from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_epa_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	LOCAL struct rt_epa_internal	*xip;
	union record			*rp;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_epa_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_EPA;
	ip->idb_meth = &rt_functab[ID_EPA];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_epa_internal), "rt_epa_internal");
	xip = (struct rt_epa_internal *)ip->idb_ptr;
	xip->epa_magic = RT_EPA_INTERNAL_MAGIC;

	/* Warning:  type conversion */
	MAT4X3PNT( xip->epa_V, mat, &rp->s.s_values[0*3] );
	MAT4X3VEC( xip->epa_H, mat, &rp->s.s_values[1*3] );
	MAT4X3VEC( xip->epa_Au, mat, &rp->s.s_values[2*3] );
	VUNITIZE( xip->epa_Au );
	xip->epa_r1 = rp->s.s_values[3*3] / mat[15];
	xip->epa_r2 = rp->s.s_values[3*3+1] / mat[15];

	if( xip->epa_r1 < SMALL_FASTF || xip->epa_r2 < SMALL_FASTF )
	{
		bu_log( "rt_epa_import: r1 or r2 are zero\n" );
		bu_free( (char *)ip->idb_ptr , "rt_epa_import: ip->idb_ptr" );
		return( -1 );
	}

	return(0);			/* OK */
}

/*
 *			R T _ E P A _ E X P O R T
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_epa_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_epa_internal	*xip;
	union record		*epa;
	fastf_t			mag_h;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_EPA )  return(-1);
	xip = (struct rt_epa_internal *)ip->idb_ptr;
	RT_EPA_CK_MAGIC(xip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "epa external");
	epa = (union record *)ep->ext_buf;

	epa->s.s_id = ID_SOLID;
	epa->s.s_type = EPA;

	if (!NEAR_ZERO( MAGNITUDE(xip->epa_Au) - 1., RT_LEN_TOL)) {
		bu_log("rt_epa_export: Au not a unit vector!\n");
		return(-1);
	}

	mag_h = MAGNITUDE(xip->epa_H);
	
	if ( mag_h < RT_LEN_TOL
		|| xip->epa_r1 < RT_LEN_TOL
		|| xip->epa_r2 < RT_LEN_TOL) {
		bu_log("rt_epa_export: not all dimensions positive!\n");
		return(-1);
	}
	
	if ( !NEAR_ZERO( VDOT(xip->epa_Au, xip->epa_H)/mag_h, RT_DOT_TOL) ) {
		bu_log("rt_epa_export: Au and H are not perpendicular!\n");
		return(-1);
	}
	
	if (xip->epa_r2 > xip->epa_r1) {
		bu_log("rt_epa_export: semi-minor axis cannot be longer than semi-major axis!\n");
		return(-1);
	}

	/* Warning:  type conversion */
	VSCALE( &epa->s.s_values[0*3], xip->epa_V, local2mm );
	VSCALE( &epa->s.s_values[1*3], xip->epa_H, local2mm );
	VMOVE( &epa->s.s_values[2*3], xip->epa_Au ); /* don't scale a unit vector */
	epa->s.s_values[3*3] = xip->epa_r1 * local2mm;
	epa->s.s_values[3*3+1] = xip->epa_r2 * local2mm;

	return(0);
}

/*
 *			R T _ E P A _ I M P O R T 5
 *
 *  Import an EPA from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_epa_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	LOCAL struct rt_epa_internal	*xip;
	fastf_t				vec[11];

	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 11 );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_EPA;
	ip->idb_meth = &rt_functab[ID_EPA];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_epa_internal), "rt_epa_internal");

	xip = (struct rt_epa_internal *)ip->idb_ptr;
	xip->epa_magic = RT_EPA_INTERNAL_MAGIC;

	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)vec, ep->ext_buf, 11 );

	/* Apply modeling transformations */
	MAT4X3PNT( xip->epa_V, mat, &vec[0*3] );
	MAT4X3VEC( xip->epa_H, mat, &vec[1*3] );
	MAT4X3VEC( xip->epa_Au, mat, &vec[2*3] );
	VUNITIZE( xip->epa_Au );
	xip->epa_r1 = vec[3*3] / mat[15];
	xip->epa_r2 = vec[3*3+1] / mat[15];

	if( xip->epa_r1 < SMALL_FASTF || xip->epa_r2 < SMALL_FASTF )
	{
		bu_log( "rt_epa_import: r1 or r2 are zero\n" );
		bu_free( (char *)ip->idb_ptr , "rt_epa_import: ip->idb_ptr" );
		return( -1 );
	}

	return(0);			/* OK */
}

/*
 *			R T _ E P A _ E X P O R T 5
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_epa_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_epa_internal	*xip;
	fastf_t			vec[11];
	fastf_t			mag_h;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_EPA )  return(-1);
	xip = (struct rt_epa_internal *)ip->idb_ptr;
	RT_EPA_CK_MAGIC(xip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 11;
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "epa external");

	if (!NEAR_ZERO( MAGNITUDE(xip->epa_Au) - 1., RT_LEN_TOL)) {
		bu_log("rt_epa_export: Au not a unit vector!\n");
		return(-1);
	}

	mag_h = MAGNITUDE(xip->epa_H);
	
	if ( mag_h < RT_LEN_TOL
		|| xip->epa_r1 < RT_LEN_TOL
		|| xip->epa_r2 < RT_LEN_TOL) {
		bu_log("rt_epa_export: not all dimensions positive!\n");
		return(-1);
	}
	
	if ( !NEAR_ZERO( VDOT(xip->epa_Au, xip->epa_H)/mag_h, RT_DOT_TOL) ) {
		bu_log("rt_epa_export: Au and H are not perpendicular!\n");
		return(-1);
	}
	
	if (xip->epa_r2 > xip->epa_r1) {
		bu_log("rt_epa_export: semi-minor axis cannot be longer than semi-major axis!\n");
		return(-1);
	}

	/* scale 'em into local buffer */
	VSCALE( &vec[0*3], xip->epa_V, local2mm );
	VSCALE( &vec[1*3], xip->epa_H, local2mm );
	VMOVE( &vec[2*3], xip->epa_Au ); /* don't scale a unit vector */
	vec[3*3] = xip->epa_r1 * local2mm;
	vec[3*3+1] = xip->epa_r2 * local2mm;

	/* Convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, 11 );

	return(0);
}

/*
 *			R T _ E P A _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_epa_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_epa_internal	*xip =
		(struct rt_epa_internal *)ip->idb_ptr;
	char	buf[256];

	RT_EPA_CK_MAGIC(xip);
	bu_vls_strcat( str, "Elliptical Paraboloid (EPA)\n");

	sprintf(buf, "\tV (%g, %g, %g)\n",
		xip->epa_V[X] * mm2local,
		xip->epa_V[Y] * mm2local,
		xip->epa_V[Z] * mm2local );
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tH (%g, %g, %g) mag=%g\n",
		xip->epa_H[X] * mm2local,
		xip->epa_H[Y] * mm2local,
		xip->epa_H[Z] * mm2local,
		MAGNITUDE(xip->epa_H) * mm2local);
	bu_vls_strcat( str, buf );
	
	sprintf(buf, "\tA=%g\n", xip->epa_r1 * mm2local);
	bu_vls_strcat( str, buf );
	
	sprintf(buf, "\tB=%g\n", xip->epa_r2 * mm2local);
	bu_vls_strcat( str, buf );

	return(0);
}

/*
 *			R T _ E P A _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_epa_ifree(struct rt_db_internal *ip)
{
	register struct rt_epa_internal	*xip;

	RT_CK_DB_INTERNAL(ip);
	xip = (struct rt_epa_internal *)ip->idb_ptr;
	RT_EPA_CK_MAGIC(xip);
	xip->epa_magic = 0;		/* sanity */

	bu_free( (char *)xip, "epa ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}
@


11.30
log
@change conf.h to a wrapped config.h
@
text
@d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /cvs/brlcad/librt/g_epa.c,v 11.29 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.29
log
@merge of ansi-6-0-branch into HEAD
@
text
@d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header$ (BRL)";
d142 5
a146 1
#include "conf.h"
@


11.28
log
@update copyright to include span through 2003
@
text
@d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.27 2002/08/20 17:07:59 jra Exp $ (BRL)";
d194 1
a194 4
rt_epa_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d294 1
a294 2
rt_epa_print( stp )
register const struct soltab *stp;
d323 1
a323 5
rt_epa_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d444 6
a449 6
rt_epa_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d460 1
a460 4
rt_epa_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d496 1
a496 4
rt_epa_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d552 1
a552 5
rt_epa_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d597 1
a597 2
rt_epa_free( stp )
register struct soltab *stp;
d610 1
a610 1
rt_epa_class()
d619 1
a619 5
rt_epa_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d622 1
a622 1
	fastf_t		**ellipses, theta_new, theta_prev, rt_ell_ang();
d629 1
a629 1
	struct rt_pt_node	*pos_a, *pos_b, *pts_a, *pts_b, *rt_ptalloc();
d885 1
a885 4
rt_ell_norms( ov, A, B, h_vec, t, sides )
register fastf_t	*ov;
fastf_t			*A, *B, *h_vec, t;
int			sides;
d915 1
a915 5
rt_ell( ov, V, A, B, sides )
register fastf_t	*ov;
register const fastf_t	*V;
const fastf_t		*A, *B;
int			sides;
d939 1
a939 3
rt_ell_ang( p1, a, b, dtol, ntol )
fastf_t	a, b, dtol, ntol;
point_t	p1;
d981 1
a981 6
rt_epa_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d992 1
a992 1
	struct rt_pt_node	*pos_a, *pos_b, *pts_a, *pts_b, *rt_ptalloc();
d1440 1
a1440 5
rt_epa_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1485 1
a1485 5
rt_epa_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1545 1
a1545 5
rt_epa_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1590 1
a1590 5
rt_epa_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1650 1
a1650 5
rt_epa_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1687 1
a1687 2
rt_epa_ifree( ip )
struct rt_db_internal	*ip;
@


11.27
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d135 1
a135 1
 *	This software is Copyright (C) 1990 by the United States Army.
d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.25 2001/10/02 19:24:29 jra Exp $ (BRL)";
@


11.27.4.1
log
@sync to HEAD...
@
text
@d135 1
a135 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_epa.c,v 11.28 2004/02/02 17:39:20 morrison Exp $ (BRL)";
@


11.27.10.1
log
@merge from HEAD
@
text
@d135 1
a135 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.28 2004/02/02 17:39:20 morrison Exp $ (BRL)";
@


11.27.10.2
log
@merge from head
@
text
@d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.27.10.1 2004/02/12 18:37:40 erikg Exp $ (BRL)";
@


11.27.2.1
log
@Initial ANSIfication
@
text
@d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.27 2002/08/20 17:07:59 jra Exp $ (BRL)";
d194 4
a197 1
rt_epa_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d297 2
a298 1
rt_epa_print(register const struct soltab *stp)
d327 5
a331 1
rt_epa_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d452 6
a457 6
rt_epa_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d468 4
a471 1
rt_epa_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d507 4
a510 1
rt_epa_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d566 5
a570 1
rt_epa_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d615 2
a616 1
rt_epa_free(register struct soltab *stp)
d629 1
a629 1
rt_epa_class(void)
d638 5
a642 1
rt_epa_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d645 1
a645 1
	fastf_t		**ellipses, theta_new, theta_prev, rt_ell_ang(fastf_t *p1, fastf_t a, fastf_t b, fastf_t dtol, fastf_t ntol);
d652 1
a652 1
	struct rt_pt_node	*pos_a, *pos_b, *pts_a, *pts_b, *rt_ptalloc(void);
d908 4
a911 1
rt_ell_norms(register fastf_t *ov, fastf_t *A, fastf_t *B, fastf_t *h_vec, fastf_t t, int sides)
d941 5
a945 1
rt_ell(register fastf_t *ov, register const fastf_t *V, const fastf_t *A, const fastf_t *B, int sides)
d969 3
a971 1
rt_ell_ang(fastf_t *p1, fastf_t a, fastf_t b, fastf_t dtol, fastf_t ntol)
d1013 6
a1018 1
rt_epa_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1029 1
a1029 1
	struct rt_pt_node	*pos_a, *pos_b, *pts_a, *pts_b, *rt_ptalloc(void);
d1477 5
a1481 1
rt_epa_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1526 5
a1530 1
rt_epa_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1590 5
a1594 1
rt_epa_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1639 5
a1643 1
rt_epa_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1703 5
a1707 1
rt_epa_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1744 2
a1745 1
rt_epa_ifree(struct rt_db_internal *ip)
@


11.27.2.2
log
@sync branch with HEAD
@
text
@d135 1
a135 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header$ (BRL)";
@


11.26
log
@Converted from K&R to ANSI C - RFH
@
text
@d194 4
a197 1
rt_epa_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d297 2
a298 1
rt_epa_print(register const struct soltab *stp)
d327 5
a331 1
rt_epa_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d452 6
a457 6
rt_epa_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d468 4
a471 1
rt_epa_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d507 4
a510 1
rt_epa_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d566 5
a570 1
rt_epa_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d615 2
a616 1
rt_epa_free(register struct soltab *stp)
d629 1
a629 1
rt_epa_class(void)
d638 5
a642 1
rt_epa_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d645 1
a645 1
	fastf_t		**ellipses, theta_new, theta_prev, rt_ell_ang(fastf_t *p1, fastf_t a, fastf_t b, fastf_t dtol, fastf_t ntol);
d652 1
a652 1
	struct rt_pt_node	*pos_a, *pos_b, *pts_a, *pts_b, *rt_ptalloc(void);
d908 4
a911 1
rt_ell_norms(register fastf_t *ov, fastf_t *A, fastf_t *B, fastf_t *h_vec, fastf_t t, int sides)
d941 5
a945 1
rt_ell(register fastf_t *ov, register const fastf_t *V, const fastf_t *A, const fastf_t *B, int sides)
d969 3
a971 1
rt_ell_ang(fastf_t *p1, fastf_t a, fastf_t b, fastf_t dtol, fastf_t ntol)
d1013 6
a1018 1
rt_epa_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1029 1
a1029 1
	struct rt_pt_node	*pos_a, *pos_b, *pts_a, *pts_b, *rt_ptalloc(void);
d1477 5
a1481 1
rt_epa_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1526 5
a1530 1
rt_epa_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1590 5
a1594 1
rt_epa_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1639 5
a1643 1
rt_epa_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1703 5
a1707 1
rt_epa_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1744 2
a1745 1
rt_epa_ifree(struct rt_db_internal *ip)
@


11.25
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.24 2001/09/06 15:29:03 jra Exp $ (BRL)";
d194 1
a194 4
rt_epa_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d294 1
a294 2
rt_epa_print( stp )
register const struct soltab *stp;
d323 1
a323 5
rt_epa_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d444 6
a449 6
rt_epa_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d460 1
a460 4
rt_epa_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d496 1
a496 4
rt_epa_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d552 1
a552 5
rt_epa_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d597 1
a597 2
rt_epa_free( stp )
register struct soltab *stp;
d610 1
a610 1
rt_epa_class()
d619 1
a619 5
rt_epa_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d622 1
a622 1
	fastf_t		**ellipses, theta_new, theta_prev, rt_ell_ang();
d629 1
a629 1
	struct rt_pt_node	*pos_a, *pos_b, *pts_a, *pts_b, *rt_ptalloc();
d885 1
a885 4
rt_ell_norms( ov, A, B, h_vec, t, sides )
register fastf_t	*ov;
fastf_t			*A, *B, *h_vec, t;
int			sides;
d915 1
a915 5
rt_ell( ov, V, A, B, sides )
register fastf_t	*ov;
register const fastf_t	*V;
const fastf_t		*A, *B;
int			sides;
d939 1
a939 3
rt_ell_ang( p1, a, b, dtol, ntol )
fastf_t	a, b, dtol, ntol;
point_t	p1;
d981 1
a981 6
rt_epa_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d992 1
a992 1
	struct rt_pt_node	*pos_a, *pos_b, *pts_a, *pts_b, *rt_ptalloc();
d1440 1
a1440 5
rt_epa_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1485 1
a1485 5
rt_epa_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1545 1
a1545 5
rt_epa_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1590 1
a1590 5
rt_epa_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1650 1
a1650 5
rt_epa_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1687 1
a1687 2
rt_epa_ifree( ip )
struct rt_db_internal	*ip;
@


11.24
log
@tesellator was not working
eliminated staements setting outfacuses to NULL
corrected a bu_free() loop
@
text
@d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.23 2001/05/16 21:38:04 morrison Exp $ (BRL)";
d1495 1
d1604 1
@


11.23
log
@PRODUCTION optimizations
@
text
@d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.22 2001/04/20 22:29:44 morrison Exp $ (BRL)";
d1164 3
d1168 1
a1168 1
			pos_b = pos_b->next;
a1229 1
			outfaceuses = NULL;
a1231 1
			outfaceuses = NULL;
@


11.22
log
@CONST to const
@
text
@d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.21 2001/03/31 01:57:07 morrison Exp $ (BRL)";
d201 1
d203 1
d211 1
d214 1
d655 1
d657 2
@


11.21
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.20 2000/10/18 18:10:34 butler Exp $ (BRL)";
d169 1
a169 1
CONST struct bu_structparse rt_epa_parse[] = {
d201 1
a201 1
	CONST struct bn_tol		*tol = &rtip->rti_tol;
d294 1
a294 1
register CONST struct soltab *stp;
d296 1
a296 1
	register CONST struct epa_specific *epa =
d637 2
a638 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d936 2
a937 2
register CONST fastf_t	*V;
CONST fastf_t		*A, *B;
d1010 2
a1011 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d1471 3
a1473 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1519 1
a1519 1
CONST struct rt_db_internal	*ip;
d1521 1
a1521 1
CONST struct db_i		*dbip;
d1583 3
a1585 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1631 1
a1631 1
CONST struct rt_db_internal	*ip;
d1633 1
a1633 1
CONST struct db_i		*dbip;
d1695 1
a1695 1
CONST struct rt_db_internal	*ip;
@


11.20
log
@Patches for compiling under RedHat 7.0
@
text
@d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.19 2000/08/22 21:16:59 mike Exp $ (BRL)";
d254 1
a254 1
	bn_mat_idn( R );
d261 1
a261 1
	bn_mat_idn( S );
d528 1
a528 1
		bn_mat_idn( M1 );
d684 1
a684 1
	bn_mat_idn( R );
d1070 1
a1070 1
	bn_mat_idn( R );
@


11.19
log
@
lint
@
text
@d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.18 2000/08/21 02:02:30 butler Exp $ (BRL)";
d145 3
@


11.18
log
@Massive compilation warnings eliminated
@
text
@d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.17 2000/07/10 23:01:31 mike Exp $ (BRL)";
d1021 1
a1021 1
	struct faceuse	**outfaceuses;
d1217 2
a1218 1
		} else
d1220 2
@


11.17
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d139 1
a139 1
static const char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.16 2000/06/30 15:38:02 mike Exp $ (BRL)";
d172 2
a173 1
    {0} };
@


11.16
log
@
export methods should not init the external structure, just check them.
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.15 2000/06/30 15:31:14 mike Exp $ (BRL)";
@


11.15
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.14 2000/06/27 15:33:32 bparker Exp $ (BRL)";
d1525 1
a1525 1
	BU_INIT_EXTERNAL(ep);
d1637 1
a1637 1
	BU_INIT_EXTERNAL(ep);
@


11.14
log
@Call BU_ASSERT_LONG.
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.13 2000/06/26 20:42:11 bparker Exp $ (BRL)";
d1479 1
a1479 1
	RT_INIT_DB_INTERNAL( ip );
d1587 1
a1587 1
	RT_INIT_DB_INTERNAL( ip );
@


11.13
log
@Add rt_epa_import5 and rt_epa_export5 routines.
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.12 2000/04/12 02:34:33 mike Exp $ (BRL)";
d1584 2
@


11.12
log
@
NT port, non-compat4
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.11 2000/03/29 02:43:10 mike Exp $ (BRL)";
d1563 109
@


11.11
log
@
Fixed invocation of nmg_mark_edges_real()
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.10 1999/11/26 21:46:46 mike Exp $ (BRL)";
d518 1
a518 1
		vec_ortho( u, hitp->hit_normal );
d544 1
a544 1
	 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.10
log
@
Lint cleanups
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.9 1999/11/24 23:12:07 mike Exp $ (BRL)";
d1264 1
a1264 1
	(void)nmg_mark_edges_real( &outfaceuses[0]->l );
@


11.9
log
@
Made structparse tables CONST
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.8 1999/11/17 02:41:58 mike Exp $ (BRL)";
a165 8
struct pt_node {
	point_t		p;	/* a point */
	struct pt_node	*next;	/* ptr to next pt */
};

RT_EXTERN(void	rt_ell, (fastf_t *ov, CONST fastf_t *V, CONST fastf_t *A,
			CONST fastf_t *B, int sides) );

d634 1
a634 1
struct bn_tol		*tol;
d644 1
a644 1
	struct pt_node	*pos_a, *pos_b, *pts_a, *pts_b, *rt_ptalloc();
d767 1
a767 1
			struct pt_node *next;
d771 1
a771 1
			bu_free( (char *)pos_b, "pt_node" );
d1018 1
a1018 1
	struct pt_node	*pos_a, *pos_b, *pts_a, *pts_b, *rt_ptalloc();
d1153 1
a1153 1
			bu_free( (char *)pos_b, "pt_node" );
d1462 1
a1462 1
rt_epa_import( ip, ep, mat )
d1466 1
d1510 1
a1510 1
rt_epa_export( ep, ip, local2mm )
d1514 1
d1577 1
a1577 1
struct rt_db_internal	*ip;
@


11.8
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.7 1999/10/30 03:53:27 mike Exp $ (BRL)";
d174 1
a174 1
struct bu_structparse rt_epa_parse[] = {
@


11.7
log
@
Added magic numbers for ray, hit, and application structures.
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.6 1999/07/02 22:19:22 mike Exp $ (BRL)";
d240 1
d1488 1
@


11.6
log
@
Removed dependence on compat4.h
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.5 1999/05/27 19:10:37 mike Exp $ (BRL)";
d373 1
d381 1
d390 1
d411 1
@


11.5
log
@
sed4
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.4 1999/04/12 23:02:28 bparker Exp $ (BRL)";
d837 1
a837 1
		RT_VLIST_LINE_MOVE );
d841 1
a841 1
			RT_VLIST_LINE_DRAW );
d856 1
a856 1
			RT_VLIST_LINE_MOVE );
d860 1
a860 1
				RT_VLIST_LINE_DRAW );
d871 1
a871 1
				RT_VLIST_LINE_MOVE );
d874 1
a874 1
				RT_VLIST_LINE_DRAW );
d881 1
a881 1
		RT_ADD_VLIST( vhead, Work, RT_VLIST_LINE_MOVE );
d884 1
a884 1
			RT_VLIST_LINE_DRAW );
@


11.4
log
@*- fixed bug in plot routines where memory was being used
	after freeing.
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_epa.c,v 11.3 1997/06/30 13:36:14 gdurf Exp $ (BRL)";
d205 1
a205 1
	CONST struct rt_tol		*tol = &rtip->rti_tol;
d214 1
a214 1
	RT_CK_TOL(tol);
d241 1
a241 1
	GETSTRUCT( epa, epa_specific );
d257 1
a257 1
	mat_idn( R );
d261 1
a261 1
	mat_trn( Rinv, R );			/* inv of rot mat is trn */
d264 1
a264 1
	mat_idn( S );
d270 2
a271 2
	mat_mul( epa->epa_SoR, S, R );
	mat_mul( epa->epa_invRoS, Rinv, S );
d306 2
a307 2
	mat_print("S o R", epa->epa_SoR );
	mat_print("invR o S", epa->epa_invRoS );
d425 1
a425 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d434 1
a434 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d491 1
a491 1
		rt_log("rt_epa_norm: surfno=%d bad\n", hitp->hit_surfno);
d527 1
a527 1
		mat_idn( M1 );
d530 2
a531 2
		mat_mul( M2, epa->epa_invRoS, M1);
		mat_mul( M1, M2, epa->epa_SoR );
d587 1
a587 1
			uvp->uv_u = acos(pprime[X]/len) * rt_inv2pi;
d594 1
a594 1
		uvp->uv_u = acos(pprime[X]/len) * rt_inv2pi;
d617 1
a617 1
	rt_free( (char *)epa, "epa_specific" );
d634 1
a634 1
struct rt_list		*vhead;
d637 1
a637 1
struct rt_tol		*tol;
d683 1
a683 1
	mat_idn( R );
d687 1
a687 1
	mat_trn( invR, R );			/* inv of rot mat is trn */
d715 1
a715 1
		ntol = rt_pi;
d774 1
a774 1
			rt_free( (char *)pos_b, "pt_node" );
d799 1
a799 1
	ellipses = (fastf_t **)rt_malloc( nell * sizeof(fastf_t *), "fastf_t ell[]");
d801 1
a801 1
	pts_dbl = (int *)rt_malloc( nell * sizeof(int), "dbl ints" );
d806 1
a806 1
	theta_prev = rt_twopi;
d817 1
a817 1
			nseg = (int)(rt_twopi / theta_new) + 1;
d826 1
a826 1
		ellipses[i] = (fastf_t *)rt_malloc(3*(nseg+1)*sizeof(fastf_t),
d889 1
a889 1
		rt_free( (char *)ellipses[i], "pts ell");
d891 2
a892 2
	rt_free( (char *)ellipses, "fastf_t ell[]");
	rt_free( (char *)pts_dbl, "dbl ints" );
d912 1
a912 1
	theta = 2 * rt_pi / sides;
d942 1
a942 1
	theta = 2 * rt_pi / sides;
d1010 1
a1010 1
CONST struct rt_tol	*tol;
d1069 1
a1069 1
	mat_idn( R );
d1073 1
a1073 1
	mat_trn( invR, R );			/* inv of rot mat is trn */
d1101 1
a1101 1
		ntol = rt_pi;
d1156 1
a1156 1
			rt_free( (char *)pos_b, "pt_node" );
d1181 1
a1181 1
	ellipses = (fastf_t **)rt_malloc( nell * sizeof(fastf_t *), "fastf_t ell[]");
d1183 1
a1183 1
	pts_dbl = (int *)rt_malloc( nell * sizeof(int), "dbl ints" );
d1187 1
a1187 1
	segs_per_ell = (int *)rt_calloc( nell , sizeof( int ) , "rt_epa_tess: segs_per_ell" );
d1190 1
a1190 1
	normals = (fastf_t **)rt_malloc( nell * sizeof(fastf_t *), "fastf_t normals[]");
d1195 1
a1195 1
	theta_prev = rt_twopi;
d1209 1
a1209 1
			nseg = (int)(rt_twopi / theta_new) + 1;
d1215 1
a1215 1
			rt_malloc( (face+1) * sizeof(struct faceuse *), "faceuse []" );
d1223 1
a1223 1
		ellipses[i] = (fastf_t *)rt_malloc(3*(nseg+1)*sizeof(fastf_t),
d1226 1
a1226 1
		normals[i] = (fastf_t *)rt_malloc(3*(nseg+1)*sizeof(fastf_t), "rt_epa_tess_ normals" );
d1240 1
a1240 1
	s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d1244 1
a1244 1
		rt_malloc(nell*sizeof(struct vertex **), "vertex [][]");
d1248 1
a1248 1
	        	rt_malloc(j*sizeof(struct vertex *), "vertex []");
d1258 1
a1258 1
		rt_log("rt_epa_tess() failure, top face\n");
d1288 1
a1288 1
					rt_log("rt_epa_tess() failure\n");
d1301 1
a1301 1
					rt_log("rt_epa_tess() failure\n");
d1314 1
a1314 1
					rt_log("rt_epa_tess() failure\n");
d1325 1
a1325 1
					rt_log("rt_epa_tess() failure\n");
d1338 1
a1338 1
					rt_log("rt_epa_tess() failure\n");
d1360 1
a1360 1
		rt_log("rt_epa_tess() failure\n");
d1375 1
a1375 1
			rt_log("rt_epa_tess() failure\n");
d1392 1
a1392 1
			for( RT_LIST_FOR( vu , vertexuse , &vells[i][j]->vu_hd ) )
d1412 1
a1412 1
	for( RT_LIST_FOR( vu , vertexuse , &apex_v->vu_hd ) )
d1433 1
a1433 1
	rt_free( (char *)outfaceuses, "faceuse []");
d1435 2
a1436 2
		rt_free( (char *)ellipses[i], "pts ell");
	        rt_free( (char *)vells[i], "vertex []");
d1438 3
a1440 3
	rt_free( (char *)ellipses, "fastf_t ell[]");
	rt_free( (char *)pts_dbl, "dbl ints" );
	rt_free( (char *)vells, "vertex [][]");
d1446 1
a1446 1
	rt_free( (char *)outfaceuses, "faceuse []");
d1448 2
a1449 2
		rt_free( (char *)ellipses[i], "pts ell");
	        rt_free( (char *)vells[i], "vertex []");
d1451 3
a1453 3
	rt_free( (char *)ellipses, "fastf_t ell[]");
	rt_free( (char *)pts_dbl, "dbl ints" );
	rt_free( (char *)vells, "vertex [][]");
d1467 1
a1467 1
CONST struct rt_external	*ep;
d1473 1
a1473 1
	RT_CK_EXTERNAL( ep );
d1477 1
a1477 1
		rt_log("rt_epa_import: defective record\n");
d1483 1
a1483 1
	ip->idb_ptr = rt_malloc( sizeof(struct rt_epa_internal), "rt_epa_internal");
d1497 2
a1498 2
		rt_log( "rt_epa_import: r1 or r2 are zero\n" );
		rt_free( (char *)ip->idb_ptr , "rt_epa_import: ip->idb_ptr" );
d1512 1
a1512 1
struct rt_external		*ep;
d1525 1
a1525 1
	RT_INIT_EXTERNAL(ep);
d1527 1
a1527 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "epa external");
d1534 1
a1534 1
		rt_log("rt_epa_export: Au not a unit vector!\n");
d1543 1
a1543 1
		rt_log("rt_epa_export: not all dimensions positive!\n");
d1548 1
a1548 1
		rt_log("rt_epa_export: Au and H are not perpendicular!\n");
d1553 1
a1553 1
		rt_log("rt_epa_export: semi-minor axis cannot be longer than semi-major axis!\n");
d1576 1
a1576 1
struct rt_vls		*str;
d1586 1
a1586 1
	rt_vls_strcat( str, "Elliptical Paraboloid (EPA)\n");
d1592 1
a1592 1
	rt_vls_strcat( str, buf );
d1599 1
a1599 1
	rt_vls_strcat( str, buf );
d1602 1
a1602 1
	rt_vls_strcat( str, buf );
d1605 1
a1605 1
	rt_vls_strcat( str, buf );
d1626 1
a1626 1
	rt_free( (char *)xip, "epa ifree" );
@


11.3
log
@Moved in structparse (from tcl.c)
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 11.2 1996/10/21 19:11:33 jra Exp gdurf $ (BRL)";
d770 4
d775 1
a775 1
			pos_b = pos_b->next;
@


11.2
log
@Mod to nmg_gluefaces() call.
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 11.1 1995/01/04 09:56:37 mike Rel4_4 jra $ (BRL)";
d174 7
@


11.1
log
@Release_4.4
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.16 94/12/27 16:25:08 mike Exp $ (BRL)";
d999 1
a999 1
struct rt_tol		*tol;
d1413 1
a1413 1
	nmg_gluefaces( outfaceuses, face );
@


10.16
log
@Added rt_ prefix to ell_ang, ell_norms
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.15 94/11/05 02:09:35 mike Exp Locker: mike $ (BRL)";
@


10.15
log
@Irix 6.0 cleanup
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.14 94/09/15 22:19:22 jra Exp Locker: mike $ (BRL)";
d633 1
a633 1
	fastf_t		**ellipses, theta_new, theta_prev, ell_ang();
d804 1
a804 1
		theta_new = ell_ang(p1, pos_a->p[Y], pos_b->p[Y], dtol, ntol);
d889 1
a889 1
ell_norms( ov, A, B, h_vec, t, sides )
d900 1
a900 1
		rt_bomb( "rt_epa_tess: ell_norms: sqrt( 1.0 -t ) is zero\n" );
d943 1
a943 1
 *	E L L _ A N G
d950 1
a950 1
ell_ang( p1, a, b, dtol, ntol )
d980 1
a980 1
		return( ell_ang( mpt, a, b, dtol, ntol ) );
d1196 1
a1196 1
		theta_new = ell_ang(p1, pos_a->p[Y], pos_b->p[Y], dtol, ntol);
d1217 1
a1217 1
		ell_norms( normals[i], A_orig, B_orig, xip->epa_H, t, nseg );
@


10.14
log
@Added vertexuse normals to tessellator.
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.13 94/09/12 20:14:16 mike Exp Locker: jra $ (BRL)";
d171 2
a172 1
extern void	rt_ell();
d174 1
d199 1
a199 1
	LOCAL fastf_t	magsq_a, magsq_h;
a201 1
	LOCAL mat_t	mtemp;
a204 2
	LOCAL vect_t	invsq;	/* [ 1/(|H|**2), 1/(|A|**2), 1/(|B|**2) ] */
	LOCAL vect_t	B;
d207 1
d212 1
a212 1
	mag_a = magsq_a = MAGSQ( xip->epa_Au );
d632 1
a632 1
	fastf_t		dtol, f, mag_a, mag_h, ntol, r1, r2, theta;
d634 1
a634 1
	int		*pts_dbl, face, i, j, nseg, tmpseg;
d640 1
a640 1
	struct pt_node	*old, *pos_a, *pos_b, *pts_a, *pts_b, *rt_ptalloc();
a762 1
			old = pos_b;
d817 1
a817 1
		rt_ell( ellipses[i], V, A, B, nseg, ntol, dtol );
d894 1
a894 1
	fastf_t	a, ang, b, theta, x, y, sqrt_1mt;
d916 5
d924 2
a925 2
register fastf_t	*V;
fastf_t			*A, *B;
d928 2
a929 3
	fastf_t	a, ang, b, theta, x, y;
	int	n, ret	;
	point_t	p0, p1;
a954 1
	int	n, ret;
d1003 1
a1003 1
	int		*pts_dbl, face, i, j, nseg, tmpseg;
d1010 1
a1010 1
	struct pt_node	*old, *pos_a, *pos_b, *pts_a, *pts_b, *rt_ptalloc();
a1012 2
	struct loopuse	*lu;
	struct edgeuse	*eu, *eu2;
a1144 1
			old = pos_b;
d1216 1
a1216 1
		rt_ell( ellipses[i], V, A, B, nseg, ntol, dtol );
@


10.13
log
@Added missing } to make it compile, eliminated fprintf() calls.
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.12 94/09/12 15:53:33 jra Exp Locker: jra $ (BRL)";
d890 28
d1000 1
a1000 1
	fastf_t		**ellipses, theta_new, theta_prev;
d1002 1
d1016 5
d1054 3
d1174 8
a1181 1
	
d1189 3
d1215 2
d1218 5
d1356 1
d1374 37
@


10.12
log
@Fixed tesselator to entire epa (not just half), fixed bad vectors normal test
removed duplicate rt_malloc calls, marked real edges.
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.11 94/09/02 16:03:26 jra Exp Locker: jra $ (BRL)";
a1136 4
	if (!ellipses || !pts_dbl) {
		fprintf(stderr, "rt_epa_tess: no mem!\n");
		goto fail;
	}
d1169 1
a1180 4
	if (!vells) {
		fprintf(stderr, "rt_epa_tess: no memory!\n");
		goto fail;
	}
a1184 4
		if (!vells[i]) {
			fprintf(stderr, "rt_epa_tess: no memory!\n");
			goto fail;
		}
@


10.11
log
@Added scaling for scalar values on import where needed.
Added conversion to mm for scalar values where needed.
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.10 94/08/10 18:27:27 gdurf Exp Locker: jra $ (BRL)";
d982 1
d1137 1
a1137 1
	if (!ellipses) {
a1141 5
	/* make array of ptrs to epa ellipses */
	ellipses = (fastf_t **)rt_malloc( nell * sizeof(fastf_t *), "fastf_t ell[]");
	/* keep track of whether pts in each ellipse are doubled or not */
	pts_dbl = (int *)rt_malloc( nell * sizeof(int), "dbl ints" );

a1172 7
		
		i++;
		pos_a = pos_a->next;
		pos_b = pos_b->next;
	}
	if (pts_dbl[i-1])
		nseg /= 2;	/* # segs in top ellipse */
d1212 3
d1341 12
d1364 1
a1364 1
	return(0);
d1400 1
d1427 1
d1446 2
d1449 1
a1449 1
	if (MAGNITUDE(xip->epa_H) < RT_LEN_TOL
d1456 1
a1456 1
	if ( !NEAR_ZERO( VDOT(xip->epa_Au, xip->epa_H), RT_DOT_TOL) ) {
d1469 1
a1469 1
	VSCALE( &epa->s.s_values[2*3], xip->epa_Au, local2mm );
@


10.10
log
@Added include of conf.h
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.9 1993/11/18 01:44:03 mike Exp gdurf $ (BRL)";
d1396 2
a1397 2
	xip->epa_r1 = rp->s.s_values[3*3];
	xip->epa_r2 = rp->s.s_values[3*3+1];
d1399 7
d1462 2
a1463 2
	epa->s.s_values[3*3] = xip->epa_r1;
	epa->s.s_values[3*3+1] = xip->epa_r2;
@


10.9
log
@Added tol arg to bounding box routines
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.8 93/11/04 19:24:52 mike Exp $ (BRL)";
d141 2
@


10.8
log
@\! is wierd
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.7 93/07/20 22:48:33 mike Exp Locker: mike $ (BRL)";
d1342 1
a1342 1
	nmg_region_a( *r );
@


10.7
log
@vells could be used before set
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.6 93/07/20 16:14:36 mike Exp Locker: mike $ (BRL)";
d1194 1
a1194 1
		fprintf(stderr, "rt_epa_tess: no memory\!");
d1202 1
a1202 1
			fprintf(stderr, "rt_epa_tess: no memory\!");
@


10.6
log
@Made rt_ell() a void.
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.5 92/03/27 12:59:21 mmark Exp Locker: mike $ (BRL)";
d981 2
a982 1
	struct vertex	*vertp[3], ***vells;
@


10.5
log
@added matrix multiply to import()
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.4 92/03/25 15:52:52 mmark Exp Locker: mmark $ (BRL)";
d169 2
d887 1
a906 1
	return(ret);
@


10.4
log
@added error checking to import
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.3 92/03/24 14:36:13 mmark Exp Locker: mmark $ (BRL)";
d1388 3
a1390 3
	VMOVE( xip->epa_V, &rp->s.s_values[0*3] );
	VMOVE( xip->epa_H, &rp->s.s_values[1*3] );
	VMOVE( xip->epa_Au, &rp->s.s_values[2*3] );
@


10.3
log
@fixed import bug
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 10.2 92/02/14 15:32:34 mmark Exp $ (BRL)";
a243 4
VPRINT("prep: V",xip->epa_V);
VPRINT("H",xip->epa_H);
VPRINT("Au",xip->epa_Au);
fprintf(stderr,"r1 = %g, r2 = %g\n",xip->epa_r1,xip->epa_r2);
a1392 6
VPRINT("import: V",xip->epa_V);
VPRINT("H",xip->epa_H);
VPRINT("Au",xip->epa_Au);
fprintf(stderr,"r1 = %g, r2 = %g\n",xip->epa_r1,xip->epa_r2);
#if 0
#endif
d1424 22
d1447 3
a1449 3
	VMOVE( &epa->s.s_values[0*3], xip->epa_V );
	VMOVE( &epa->s.s_values[1*3], xip->epa_H );
	VMOVE( &epa->s.s_values[2*3], xip->epa_Au );
@


10.2
log
@real version: elliptical paraboloid
@
text
@d139 1
a139 1
static char RCSepa[] = "@@(#)$Header: /vld/mmark/cad/librt/RCS/g_epa.c,v 1.1 92/02/12 09:47:02 mmark Exp $ (BRL)";
a151 2
#define PI	3.14159265358979323264

a215 1
fprintf(stderr, "mag_h = %g, mag_a = %g, r1 = %g, r2 = %g\n", mag_h,mag_a,r1,r2);
a221 1
fprintf(stderr, "f = %g\n", f);
d229 4
a236 3
	GETSTRUCT( epa, epa_specific );
	stp->st_specific = (genptr_t)epa;

d244 4
a621 1

d632 6
d639 4
a642 7
        fastf_t top[16*3];
        fastf_t front[9*3];
	fastf_t back[9*3];
	fastf_t r1, r2, b, n, y, z;
	int	i, j;
	vect_t	Bunit, Hunit, Aunit, R1, R2;

d646 8
a653 5
	
	VREVERSE( Hunit, xip->epa_H );
	VUNITIZE( Hunit );
	VMOVE(    Aunit, xip->epa_Au );		/* make B positive z axis */
	VCROSS(   Bunit, Aunit, Hunit );	/* make R positive y axis */
d656 5
a660 11
	VSCALE(R1, Aunit, r1);
	VSCALE(R2, Bunit, r2);
	rt_ell_16pts( top, xip->epa_V, R1, R2 );
	b = sqrt(MAGSQ(xip->epa_H));
	n = b / (r1 * r1);
	for (i = 0; i < 9; i++) {
		j = i * 3;
		y = r1 * (i * 0.25 - 1);	/* 9 pts on y axis */
		z = n * y * y - b;
		VBLEND2(front+j, y, Aunit, z, Hunit);
		VADD2(front+j, front+j, xip->epa_V);
d662 5
a666 7
	n = b / (r2 * r2);
	for (i = 0; i < 9; i++) {
		j = i * 3;
		y = r2 * (i * 0.25 - 1);	/* 9 pts on x axis */
		z = n * y * y - b;
		VBLEND2(back+j, y, Bunit, z, Hunit);
		VADD2(back+j, back+j, xip->epa_V);
d669 32
a700 4
	/* Draw the top */
	RT_ADD_VLIST( vhead, &top[15*ELEMENTS_PER_VECT], RT_VLIST_LINE_MOVE );
	for( i = 0; i < 16; i++ )  {
		RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], RT_VLIST_LINE_DRAW );
d703 40
a742 4
	/* Draw the front */
	RT_ADD_VLIST( vhead, &front[0], RT_VLIST_LINE_MOVE );
	for( i = 1; i < 9; i++ )  {
		RT_ADD_VLIST( vhead, &front[i*ELEMENTS_PER_VECT], RT_VLIST_LINE_DRAW );
d744 48
d793 30
a822 4
	/* Draw the back */
	RT_ADD_VLIST( vhead, &back[0], RT_VLIST_LINE_MOVE );
	for( i = 1; i < 9; i++ )  {
		RT_ADD_VLIST( vhead, &back[i*ELEMENTS_PER_VECT], RT_VLIST_LINE_DRAW );
d824 9
d834 50
d895 3
a897 2
	fastf_t	ang, theta, x, y;
	int	n;
d899 1
a899 1
	theta = 2 * PI / sides;
d901 1
d908 1
d912 45
d971 3
a973 3
	fastf_t		dtol, f, mag_a, mag_h, ntol, r1, r2, theta;
	fastf_t		**ellipses, n_dist, n_norm;
	int		face, i, j, nseg;
d978 1
d1051 1
a1051 1
		ntol = PI;
a1130 3
	n_norm = PI / ntol;		/* # segs to satisfy norm tol */
	n_dist = PI / acos( 1 - dtol / r2 );	/* & dist tol */
	nseg = (fastf_t)(n_norm > n_dist ? n_norm+1 : n_dist+1);
d1133 3
a1135 6
	/* number of faces needed for epa */
	face = nseg*(1 + 3*((1 << (nell-1)) - 1));
	/* array for each triangular face */
	outfaceuses = (struct faceuse **)
		rt_malloc( (face+1) * sizeof(struct faceuse *), "faceuse []" );
	if (!outfaceuses || !ellipses) {
d1139 5
d1147 2
a1150 1
	theta = 2 * PI / nseg;
a1151 6
		ellipses[i] = (fastf_t *)rt_malloc(3*(nseg+1)*sizeof(fastf_t),
			"pts ell");
		if (!ellipses[i]) {
			fprintf(stderr, "rt_epa_tess: no mem!\n");
			goto fail;
		}
d1155 22
a1176 2
		rt_ell( ellipses[i], V, A, B, nseg );
		nseg *= 2;		/* double pts for next ellipse */
d1181 2
a1182 1
	nseg /= 2;	/* # segs in top ellipse */
d1206 2
a1207 1
		j /= 2;
d1229 2
a1230 1
		nseg /= 2;	/* # segs in 'bottom' ellipse */
d1237 10
a1246 9
			/* first triangle */
		        vertp[1] = vells[top][jj+1];
		        vertp[2] = vells[top][jj];
			if ( (outfaceuses[face++] = nmg_cface(s, vertp, 3)) == 0) {
				rt_log("rt_epa_tess() failure\n");
				goto fail;
			}
			if (j == 0)
			        vells[bottom][j] = vertp[0];
d1248 12
a1259 4
			/* second triangle */
		        vertp[2] = vertp[1];
			if (j == nseg-1)
				vertp[1] = vells[bottom][0];
d1261 23
a1283 8
			else
				vertp[1] = (struct vertex *)0;
			if ( (outfaceuses[face++] = nmg_cface(s, vertp, 3)) == 0) {
				rt_log("rt_epa_tess() failure\n");
				goto fail;
			}
			if (j != nseg-1)
				vells[bottom][j+1] = vertp[1];
d1285 12
a1296 9
			/* third triangle */
			vertp[0] = vertp[1];
			if (j == nseg-1)
				vertp[1] = vells[top][0];
			else
				vertp[1] = vells[top][jj+2];
			if ( (outfaceuses[face++] = nmg_cface(s, vertp, 3)) == 0) {
				rt_log("rt_epa_tess() failure\n");
				goto fail;
d1319 1
a1319 1
	nmg_vertex_gv( vertp[0], (fastf_t *)&V );
d1356 1
d1396 7
a1402 1
	xip->epa_r2 = rp->s.s_values[4*3];
d1439 1
a1439 1
	epa->s.s_values[4*3] = xip->epa_r2;
a1470 7
	sprintf(buf, "\tAu (%g, %g, %g) mag=%g\n",
		xip->epa_Au[X] * mm2local,
		xip->epa_Au[Y] * mm2local,
		xip->epa_Au[Z] * mm2local,
		MAGNITUDE(xip->epa_Au) * mm2local);
	rt_vls_strcat( str, buf );

d1478 1
a1478 1
	sprintf(buf, "\tr1=%g\n", xip->epa_r1);
d1481 1
a1481 1
	sprintf(buf, "\tr2=%g\n", xip->epa_r2);
@


10.1
log
@Release_4.0
@
text
@a1 2
 * XXX Re-do this from g_xxx.c!  Out of data already.
 *
d5 1
a5 1
 *	Librt Geometry Routines for the Elliptical Paraboloid
d7 119
d127 1
d132 1
a132 1
 *	Aberdeen Proving Ground, Maryland  21005
d135 1
a135 1
 *	This software is Copyright (C) 1989 by the United States Army.
d139 1
a139 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 1.8 91/09/20 23:06:37 butler Exp $ (BRL)";
d147 1
d149 1
d152 1
a152 7
struct rt_epa_internal {
	vect_t	v;		/* Vertex */
	vect_t	h;		/* Height Vector */
	vect_t	a;		/* Semi-major axis (unit vector) */
	fastf_t	r1;		/* semi-major axis length */
	fastf_t	r2;		/* semi-minor axis length */
};
d155 9
a163 1
	vect_t	epa_V;
d166 5
d172 1
a172 1
 *  			E P A _ P R E P
d187 1
a187 1
epa_prep( stp, rec, rtip )
d189 1
a190 1
union record		*rec;
d192 90
a281 1
	register struct epa_specific *epa;
d284 3
d288 1
a288 1
epa_print( stp )
d291 1
a291 1
	register struct epa_specific *epa =
d293 7
d302 4
d307 1
a307 1
 *  			E P A _ S H O T
d318 1
a318 1
epa_shot( stp, rp, ap, seghead )
d326 6
a331 1
	register struct seg *segp;
d333 95
d431 1
a431 1
#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	
d434 1
a434 1
 *			S P H _ V S H O T
d439 1
a439 1
epa_vshot( stp, rp, segp, n, ap )
d446 1
a446 1
	register struct epa_specific *epa;
d450 1
a450 1
 *  			E P A _ N O R M
d455 4
a458 4
epa_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d460 2
d466 20
d489 1
a489 1
 *			E P A _ C U R V E
d494 1
a494 1
epa_curve( cvp, hitp, stp )
d496 2
a497 2
register struct hit *hitp;
struct soltab *stp;
d499 2
d503 3
d507 11
a517 1
 	cvp->crv_c1 = cvp->crv_c2 = 0;
d519 23
a541 2
	/* any tangent direction */
 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
d545 1
a545 1
 *  			E P A _ U V
d553 5
a557 5
epa_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d561 35
d599 1
a599 1
 *		E P A _ F R E E
d602 1
a602 1
epa_free( stp )
d608 1
d612 3
d616 1
a616 1
epa_class()
d621 4
d626 5
a630 1
epa_plot()
d632 58
a689 1
	return(-1);
d692 28
d721 6
a726 4
epa_import( epa, rp, matp )
struct rt_epa_internal	*epa;
union record		*rp;
register matp_t		matp;
d728 381
d1110 107
@


1.8
log
@removing fuzz with lint
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 1.7 91/06/30 00:10:50 mike Exp $ (BRL)";
@


1.7
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 1.6 91/06/22 22:30:22 mike Exp $ (BRL)";
d202 1
a202 1
struct epa_internal	*epa;
@


1.6
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 1.5 91/05/18 03:00:54 mike Exp $ (BRL)";
d70 1
a70 1
register struct soltab *stp;
@


1.5
log
@Converted to new tolerance interface
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 1.4 91/01/25 20:35:36 mike Exp $ (BRL)";
d109 1
a109 1
epa_vshot( stp, rp, segp, n, resp)
d114 1
a114 1
struct resource         *resp; /* pointer to a list of free segs */
@


1.4
log
@Added rt_ prefix to _internal structure
@
text
@d2 2
d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 1.3 90/12/05 20:30:01 mike Exp $ (BRL)";
@


1.3
log
@Fixed return codes on _plot()
@
text
@d19 1
a19 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 1.2 90/10/06 02:05:13 mike Exp $ (BRL)";
d30 1
a30 1
struct epa_internal {
@


1.2
log
@Converted seg structures to use doubly linked lists.
@
text
@d19 1
a19 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_epa.c,v 1.1 90/03/14 14:48:32 phil Exp $ (BRL)";
d192 1
a192 1
void
d195 1
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSsph[] = "@@(#)$Header: g_epa.c,v 9.1 89/05/19 05:56:26 mike Rel3_5 $ (BRL)";
d31 5
a35 5
	vect_t	V;		/* Vertex */
	vect_t	H;		/* Height Vector */
	vect_t	A;		/* Semi-major axis (unit vector) */
	fastf_t	R1;		/* semi-major axis length */
	fastf_t	R2;		/* semi-minor axis length */
d83 1
a83 1
 *  	segp	HIT
d85 2
a86 2
struct seg *
epa_shot( stp, rp, ap )
d90 1
d96 1
a96 1
	return(segp);			/* HIT */
@
