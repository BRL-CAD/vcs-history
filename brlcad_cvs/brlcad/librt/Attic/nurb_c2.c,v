head	11.12;
access;
symbols
	ansi-20040405-merged:11.8.2.2
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.8.10.1
	premerge-autoconf:11.9
	ansi-20040316-freeze:11.8.2.1
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.8.4.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.10
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.5
	offsite-5-3-pre:11.5
	rel-5-3:11.5
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.12
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.11;

11.11
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.10;

11.10
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2002.08.20.17.08.06;	author jra;	state Exp;
branches
	11.8.2.1
	11.8.4.1
	11.8.10.1;
next	11.7;

11.7
date	2002.08.15.20.55.19;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2001.04.20.22.29.54;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2000.04.12.02.34.37;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	96.12.31.01.09.27;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.12.01.02.49.33;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.44;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	1.9;

1.9
date	94.12.27.15.04.09;	author stay;	state Exp;
branches;
next	1.8;

1.8
date	94.08.11.01.10.20;	author gdurf;	state Exp;
branches;
next	1.7;

1.7
date	92.06.03.01.29.32;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	92.06.02.23.25.36;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	92.05.29.01.19.59;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	92.05.29.00.52.19;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	92.05.28.22.12.04;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	92.04.13.10.20.14;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	92.04.13.10.19.17;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.8.2.1
date	2002.09.19.18.01.42;	author morrison;	state Exp;
branches;
next	11.8.2.2;

11.8.2.2
date	2004.03.17.21.18.55;	author morrison;	state Exp;
branches;
next	;

11.8.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.8.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	;


desc
@Given a nurb surface and u,v parametric values calculate the
curvature and principle curvature of the surface.
@


11.12
log
@moved to src/
@
text
@/*	N U R B  _ C 2 . C
 *
 *  Function -
 *	Given parametric u,v values, return the curvature of the
 *	surface.
 *
 *  Author -
 *	Paul Randal Stay
 * 
 *  Source -
 * 	SECAD/VLD Computing Consortium, Bldg 394
 *	The U.S. Army Ballistic Research Laboratory
 * 	Aberdeen Proving Ground, Maryland 21005
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "nurb.h"

void
rt_nurb_curvature(struct curvature *cvp, const struct face_g_snurb *srf, fastf_t u, fastf_t v)
{
	struct face_g_snurb * us, *vs, * uus, * vvs, *uvs;
	fastf_t ue[4], ve[4], uue[4], vve[4], uve[4], se[4];
        fastf_t         E, F, G;                /* First Fundamental Form */
        fastf_t         L, M, N;                /* Second Fundamental form */
        fastf_t         denom;
        fastf_t         wein[4];                /*Weingarten matrix */
        fastf_t         evec[3];
        fastf_t         mean, gauss, discrim;
        vect_t          norm;
	int 		i;

	us = rt_nurb_s_diff(srf, RT_NURB_SPLIT_ROW);
	vs = rt_nurb_s_diff(srf, RT_NURB_SPLIT_COL);
	uus = rt_nurb_s_diff(us, RT_NURB_SPLIT_ROW);
	vvs = rt_nurb_s_diff(vs, RT_NURB_SPLIT_COL);
	uvs = rt_nurb_s_diff(vs, RT_NURB_SPLIT_ROW);
	
	rt_nurb_s_eval(srf, u, v, se);
	rt_nurb_s_eval(us, u,v, ue);
	rt_nurb_s_eval(vs, u,v, ve);
	rt_nurb_s_eval(uus, u,v, uue);
	rt_nurb_s_eval(vvs, u,v, uve);
	rt_nurb_s_eval(uvs, u,v, uve);

	rt_nurb_free_snurb( us, (struct resource *)NULL);
	rt_nurb_free_snurb( vs, (struct resource *)NULL);
	rt_nurb_free_snurb( uus, (struct resource *)NULL);
	rt_nurb_free_snurb( vvs, (struct resource *)NULL);
	rt_nurb_free_snurb( uvs, (struct resource *)NULL);

	if( RT_NURB_IS_PT_RATIONAL( srf->pt_type ))
	{
		for( i = 0; i < 3; i++)
		{
			ue[i] = (1.0 / se[3] * ue[i]) -
				(ue[3]/se[3]) * se[0]/se[3];
			ve[i] = (1.0 / se[3] * ve[i]) -
				(ve[3]/se[3]) * se[0]/se[3];
		}
		VCROSS(norm, ue, ve);
		VUNITIZE(norm);
		E = VDOT( ue, ue);
		F = VDOT( ue, ve);
		G = VDOT( ve, ve);
		
		for( i = 0; i < 3; i++)
		{
			uue[i] = (1.0 / se[3] * uue[i]) -
				2 * (uue[3]/se[3]) * uue[i] -
				uue[3]/se[3] * (se[i]/se[3]);

			vve[i] = (1.0 / se[3] * vve[i]) -
				2 * (vve[3]/se[3]) * vve[i] -
				vve[3]/se[3] * (se[i]/se[3]);

			 uve[i] = 1.0 / se[3] * uve[i] +
	                        (-1.0 / (se[3] * se[3])) *
        	                (ve[3] * ue[i] + ue[3] * ve[i] +
                	         uve[3] * se[i]) + 
				(-2.0 / (se[3] * se[3] * se[3])) *
	                        (ve[3] * ue[3] * se[i]);
		}

		L = VDOT( norm, uue);
		M = VDOT( norm, uve);
		N = VDOT( norm, vve);
		
	} else
	{
		VCROSS( norm, ue, ve);
		VUNITIZE( norm );
		E = VDOT( ue, ue);
		F = VDOT( ue, ve);
		G = VDOT( ve, ve);
		
		L = VDOT( norm, uue);
		M = VDOT( norm, uve);
		N = VDOT( norm, vve);
	}

	if( srf->order[0] <= 2 && srf->order[1] <= 2)
	{
		cvp->crv_c1 = cvp->crv_c2 = 0;
		bn_vec_ortho(cvp->crv_pdir, norm);
		return;
	}

	denom = ( (E*G) - (F*F) );
	gauss = (L * N - M *M)/denom;
	mean = (G * L + E * N - 2 * F * M) / (2 * denom);
	discrim = sqrt( mean * mean - gauss);
	
	cvp->crv_c1 = mean - discrim;
	cvp->crv_c2 = mean + discrim;

	if( fabs( E*G - F*F) < 0.0001 )		/* XXX */
	{
		bu_log("rt_nurb_curvature: first fundamental form is singular E = %g F= %g G = %g\n",
			E,F,G);
		bn_vec_ortho(cvp->crv_pdir, norm);	/* sanity */
		return;
	}

        wein[0] = ( (G * L) - (F * M))/ (denom);
        wein[1] = ( (G * M) - (F * N))/ (denom);
        wein[2] = ( (E * M) - (F * L))/ (denom);
        wein[3] = ( (E * N) - (F * M))/ (denom);

	if( fabs(wein[1]) < 0.0001 && fabs( wein[3] - cvp->crv_c1 ) < 0.0001 )
        {
                evec[0] = 0.0; evec[1] = 1.0;
        } else
        {
                evec[0] = 1.0;
                if( fabs( wein[1] ) > fabs( wein[3] - cvp->crv_c1) )
                {
                        evec[1] = (cvp->crv_c1 - wein[0]) / wein[1];
                } else
                {
                        evec[1] = wein[2] / ( cvp->crv_c1 - wein[3] );
                }
        }

	cvp->crv_pdir[0] = evec[0] * ue[0] + evec[1] * ve[0];
        cvp->crv_pdir[1] = evec[0] * ue[1] + evec[1] * ve[1];
        cvp->crv_pdir[2] = evec[0] * ue[2] + evec[1] * ve[2];
	VUNITIZE( cvp->crv_pdir);
}
@


11.11
log
@change conf.h to a wrapped config.h
@
text
@@


11.10
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 5
a24 1
#include "conf.h"
@


11.9
log
@update copyright to include span through 2003
@
text
@d31 1
a31 5
rt_nurb_curvature(cvp, srf, u, v)
struct curvature *cvp;
const struct face_g_snurb * srf;
fastf_t	u;
fastf_t v;
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990 by the United States Army.
@


11.8.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.8.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d31 5
a35 1
rt_nurb_curvature(struct curvature *cvp, const struct face_g_snurb *srf, fastf_t u, fastf_t v)
@


11.8.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d31 5
a35 1
rt_nurb_curvature(struct curvature *cvp, const struct face_g_snurb *srf, fastf_t u, fastf_t v)
@


11.6
log
@CONST to const
@
text
@d31 1
a31 5
rt_nurb_curvature(cvp, srf, u, v)
struct curvature *cvp;
const struct face_g_snurb * srf;
fastf_t	u;
fastf_t v;
@


11.5
log
@
NT port, non-compat4
@
text
@d33 1
a33 1
CONST struct face_g_snurb * srf;
@


11.4
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d120 1
a120 1
		vec_ortho(cvp->crv_pdir, norm);
d136 1
a136 1
		vec_ortho(cvp->crv_pdir, norm);	/* sanity */
@


11.3
log
@libbu
@
text
@d61 5
a65 5
	rt_nurb_free_snurb( us);
	rt_nurb_free_snurb( vs);
	rt_nurb_free_snurb( uus);
	rt_nurb_free_snurb( vvs);
	rt_nurb_free_snurb( uvs);
@


11.2
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d134 1
a134 1
		rt_log("rt_nurb_curvature: first fundamental form is singular E = %g F= %g G = %g\n",
@


11.1
log
@Release_4.4
@
text
@d33 1
a33 1
CONST struct snurb * srf;
d37 1
a37 1
	struct snurb * us, *vs, * uus, * vvs, *uvs;
@


11.1.1.1
log
@Release_4.5
@
text
@d33 1
a33 1
CONST struct face_g_snurb * srf;
d37 1
a37 1
	struct face_g_snurb * us, *vs, * uus, * vvs, *uvs;
d61 5
a65 5
	rt_nurb_free_snurb( us, (struct resource *)NULL);
	rt_nurb_free_snurb( vs, (struct resource *)NULL);
	rt_nurb_free_snurb( uus, (struct resource *)NULL);
	rt_nurb_free_snurb( vvs, (struct resource *)NULL);
	rt_nurb_free_snurb( uvs, (struct resource *)NULL);
d134 1
a134 1
		bu_log("rt_nurb_curvature: first fundamental form is singular E = %g F= %g G = %g\n",
@


1.9
log
@fixed calls to rt_nurb_s_eval
@
text
@@


1.8
log
@Added includes
@
text
@d38 1
a38 1
	fastf_t *ue, *ve, *uue, *vve, *uve, *se;
d54 6
a59 6
	se = rt_nurb_s_eval(srf, u, v);
	ue = rt_nurb_s_eval(us, u,v);
	ve = rt_nurb_s_eval(vs, u,v);
	uue = rt_nurb_s_eval(uus, u,v);
	vve = rt_nurb_s_eval(vvs, u,v);
	uve = rt_nurb_s_eval(uvs, u,v);
d121 1
a121 1
		goto cleanup;
d137 1
a137 1
		goto cleanup;
a163 8

cleanup:
	rt_free( (char *) se, "rt_nurb_curv:se");
	rt_free( (char *) ue, "rt_nurb_curv:ue");
	rt_free( (char *) ve, "rt_nurb_curv:ve");
	rt_free( (char *) uue, "rt_nurb_curv:uue");
	rt_free( (char *) vve, "rt_nurb_curv:vve");
	rt_free( (char *) uve, "rt_nurb_curv:uve");
@


1.7
log
@Made epsilon values explicit.
@
text
@d20 2
d24 1
d27 1
a28 1
#include "raytrace.h"
@


1.6
log
@Changed calling sequence of rt_nurb_curvature, so it could be
used by librt/g_nurb.c
@
text
@d129 1
a129 1
	if( APX_EQ( ( E*G - F*F), 0.0 ))
d142 1
a142 2

        if ( APX_EQ( wein[1] , 0.0 ) && APX_EQ( wein[3] - cvp->crv_c1, 0.0) )
@


1.5
log
@Control polygon/mesh is now just part of the cnurb/snurb structures,
rather than being a separate structure of their own.
@
text
@d27 5
a31 4
struct curvature *
rt_nurb_curvature(srf, u, v)
struct snurb * srf;
fastf_t u;
a33 2

	struct curvature *cvp;
d45 5
a49 8
	cvp = (struct curvature *) rt_malloc(sizeof( struct curvature),
		"rt_nurb_curvature: struct curvature");

	us = (struct snurb *) rt_nurb_s_diff(srf, RT_NURB_SPLIT_ROW);
	vs = (struct snurb *) rt_nurb_s_diff(srf, RT_NURB_SPLIT_COL);
	uus = (struct snurb *) rt_nurb_s_diff(us, RT_NURB_SPLIT_ROW);
	vvs = (struct snurb *) rt_nurb_s_diff(vs, RT_NURB_SPLIT_COL);
	uvs = (struct snurb *) rt_nurb_s_diff(vs, RT_NURB_SPLIT_ROW);
d51 6
a56 6
	se = (fastf_t *) rt_nurb_s_eval(srf, u, v);
	ue = (fastf_t *) rt_nurb_s_eval(us, u,v);
	ve = (fastf_t *) rt_nurb_s_eval(vs, u,v);
	uue = (fastf_t *) rt_nurb_s_eval(uus, u,v);
	vve = (fastf_t *) rt_nurb_s_eval(vvs, u,v);
	uve = (fastf_t *) rt_nurb_s_eval(uvs, u,v);
d131 1
a131 1
		rt_log("first fundamental form is singular E = %g F= %g G = %g\n",
d133 1
a157 1
        VSET( cvp->crv_pdir, 0.0, 0.0, 0.0 );
a169 2

	return (struct curvature *) cvp;
@


1.4
log
@Modifications due to data structure revisions:  mesh and knots are no
longer pointers, but in-place structures.
@
text
@d68 1
a68 1
	if( RT_NURB_IS_PT_RATIONAL( srf->mesh.pt_type ))
@


1.3
log
@Expanded names of manifest constants
@
text
@d68 1
a68 1
	if( RT_NURB_IS_PT_RATIONAL( srf->mesh->pt_type ))
@


1.2
log
@*** empty log message ***
@
text
@d49 5
a53 5
	us = (struct snurb *) rt_nurb_s_diff(srf, ROW);
	vs = (struct snurb *) rt_nurb_s_diff(srf, COL);
	uus = (struct snurb *) rt_nurb_s_diff(us, ROW);
	vvs = (struct snurb *) rt_nurb_s_diff(vs, COL);
	uvs = (struct snurb *) rt_nurb_s_diff(vs, ROW);
d68 1
a68 1
	if( EXTRACT_RAT( srf->mesh->pt_type ))
@


1.1
log
@Initial revision
@
text
@@
