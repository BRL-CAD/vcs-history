head	11.17;
access;
symbols
	ansi-20040405-merged:11.13.2.2
	postmerge-20040405-ansi:11.15
	premerge-20040404-ansi:11.14
	postmerge-autoconf:11.14
	autoconf-freeze:11.13.10.1
	premerge-autoconf:11.14
	ansi-20040316-freeze:11.13.2.1
	postmerge-20040315-windows:11.14
	premerge-20040315-windows:11.14
	windows-20040315-freeze:11.13.4.1
	autoconf-20031203:11.13
	autoconf-20031202:11.13
	autoconf-branch:11.13.0.10
	phong-branch:11.13.0.8
	photonmap-branch:11.13.0.6
	rel-6-1-DP:11.13
	windows-branch:11.13.0.4
	rel-6-0-2:11.11
	ansi-branch:11.13.0.2
	rel-6-0-1-branch:11.11.0.2
	hartley-6-0-post:11.12
	hartley-6-0-pre:11.11
	rel-6-0-1:11.11
	rel-6-0:11.11
	rel-5-4:11.8.2.1
	offsite-5-3-pre:11.9
	rel-5-3:11.8.2.1
	rel-5-2:11.8
	rel-5-1-branch:11.8.0.2
	rel-5-1:11.8
	rel-5-0:11.8
	rel-5-0-beta:11.8
	rel-4-5:11.7
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.17
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.16;

11.16
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.15;

11.15
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2002.08.20.17.08.07;	author jra;	state Exp;
branches
	11.13.2.1
	11.13.4.1
	11.13.10.1;
next	11.12;

11.12
date	2002.08.15.20.55.20;	author hartley;	state Exp;
branches;
next	11.11;

11.11
date	2001.05.17.20.05.25;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2001.04.20.22.29.54;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2000.11.14.21.13.21;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	98.05.13.13.21.01;	author jra;	state Exp;
branches
	11.8.2.1;
next	11.7;

11.7
date	97.10.06.21.39.27;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	97.09.09.14.03.27;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.12.31.01.09.27;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.07.10.20.00.51;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.12.01.02.49.33;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.51;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	10.14;

10.14
date	94.11.04.05.35.49;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	94.10.18.01.13.37;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.08.11.01.17.30;	author gdurf;	state Exp;
branches;
next	10.11;

10.11
date	94.08.09.17.23.09;	author stay;	state Exp;
branches;
next	10.10;

10.10
date	94.08.02.14.40.16;	author stay;	state Exp;
branches;
next	10.9;

10.9
date	93.07.20.15.25.06;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.06.02.22.52.04;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.06.02.22.12.02;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.05.29.09.04.49;	author stay;	state Exp;
branches;
next	10.5;

10.5
date	92.05.29.01.20.07;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.05.29.00.52.27;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.05.28.22.12.13;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.27.16.56.21;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.11;	author mike;	state Rel4_0;
branches;
next	1.6;

1.6
date	91.08.30.20.34.55;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.08.30.09.38.59;	author stay;	state Exp;
branches;
next	1.4;

1.4
date	91.07.19.02.35.34;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.06.14.09.42.19;	author stay;	state Exp;
branches;
next	1.2;

1.2
date	91.05.18.02.42.24;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	91.05.18.02.35.47;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.8.2.1
date	2000.11.14.21.35.30;	author jra;	state Exp;
branches;
next	;

11.13.2.1
date	2002.09.19.18.01.45;	author morrison;	state Exp;
branches;
next	11.13.2.2;

11.13.2.2
date	2004.03.17.21.18.56;	author morrison;	state Exp;
branches;
next	;

11.13.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.13.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	;


desc
@Ray code
@


11.17
log
@moved to src/
@
text
@/*		N U R B _ R A Y . C
 *
 *  Function-
 *  	Functions which support the ray intersection
 *	for surfaces.
 *
 *  Author -
 *	Paul R. Stay
 *
 *  Source -
 *     SECAD/VLD Computing Consortium, Bldg 394
 *     The U.S. Army Ballistic Research Laboratory
 *     Aberdeen Proving Ground, Maryland 21005
 *
 * Copyright Notice -
 *     This software is Copyright (C) 1991-2004 by the United States Army.
 *     All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "../librt/debug.h"


void rt_nurb_pbound(struct face_g_snurb *srf, fastf_t *vmin, fastf_t *vmax);

struct face_g_snurb *
rt_nurb_project_srf(const struct face_g_snurb *srf, fastf_t *plane1, fastf_t *plane2, struct resource *res)
{

	register struct face_g_snurb *psrf;
	register fastf_t *mp1, *mp2;
	int	n_pt_type;
	int	rational;
	int	i;

	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log( "rt_nurb_project_srf: projecting surface, planes = (%g %g %g %g) (%g %g %g %g)\n",
			V4ARGS( plane1 ), V4ARGS( plane2 ) );

	rational = RT_NURB_IS_PT_RATIONAL( srf->pt_type);

	n_pt_type = RT_NURB_MAKE_PT_TYPE( 2, RT_NURB_PT_PROJ, 0);

	psrf = (struct face_g_snurb *) rt_nurb_new_snurb( srf->order[0], srf->order[1],
	    srf->u.k_size, srf->v.k_size,
	    srf->s_size[0], srf->s_size[1], n_pt_type, res);

	psrf->dir = RT_NURB_SPLIT_COL;

	for ( i = 0; i < srf->u.k_size; i++) {
		psrf->u.knots[i] = srf->u.knots[i];
	}

	for ( i = 0; i < srf->v.k_size; i++) {
		psrf->v.knots[i] = srf->v.knots[i];
	}

	mp1 = srf->ctl_points;
	mp2 = psrf->ctl_points;

	for ( i = 0; i < srf->s_size[0] * srf->s_size[1]; i++) {

		if ( rational ) {
			mp2[0] = (mp1[0] / mp1[3] * plane1[0] + 
			    mp1[1] / mp1[3] * plane1[1] + 
			    mp1[2] / mp1[3] * plane1[2] - plane1[3]) * 
			    mp1[3];
			mp2[1] = (mp1[0] / mp1[3] * plane2[0] + 
			    mp1[1] / mp1[3] * plane2[1] + 
			    mp1[2] / mp1[3] * plane2[2] - plane2[3]) * 
			    mp1[3];
		} else
		 {
			mp2[0] = mp1[0] * plane1[0] + mp1[1] * plane1[1] + 
			    mp1[2] * plane1[2] - plane1[3];
			mp2[1] = mp1[0] * plane2[0] + mp1[1] * plane2[1] + 
			    mp1[2] * plane2[2] - plane2[3];
		}

		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		{
			if( rational )
				bu_log( "\tmesh pt (%g %g %g %g), becomes (%g %g)\n", V4ARGS( mp1 ), mp2[0], mp2[1] );
			else
				bu_log( "\tmesh pt (%g %g %g), becomes (%g %g)\n", V3ARGS( mp1 ), mp2[0], mp2[1] );
		}

		mp1 += RT_NURB_EXTRACT_COORDS(srf->pt_type);
		mp2 += RT_NURB_EXTRACT_COORDS(psrf->pt_type);
	}

	return (struct face_g_snurb *) psrf;
}


/* This routine should go away and be changed into a macro
 * but for now I want to be able to useit with debugging.
 * 						- Paul
 */
#define FINDZERO(x0,x1,y0,y1) (x0 - y0 * ( x1 - x0) / (y1-y0))

struct internal_line {
	fastf_t a, b;
};

struct internal_convex_hull {
	fastf_t param;
	fastf_t min, max;
};


#define SIGN(a)	((a < 0.0)? -1 : 1)

void
rt_nurb_clip_srf(const struct face_g_snurb *srf, int dir, fastf_t *min, fastf_t *max)
{
	struct internal_convex_hull ch[20]; /* max order is 10 */
	register fastf_t * mp1;
	fastf_t * p1, *p2, *p3, *p4;	/* corner points of the mesh */
	fastf_t v1[2], v2[2], v3[2];		/* vectors from corneres */
	struct internal_line l1;
	fastf_t norm;
	fastf_t value;
	int	i;
	register int	j;
	int	k;
	int	coords;
	int col_size, row_size;

	col_size = srf->s_size[1];
	row_size = srf->s_size[0];

	coords = RT_NURB_EXTRACT_COORDS(srf->pt_type);

	p1 = srf->ctl_points;
	p2 = srf->ctl_points + coords * (col_size - 1);
	p3 = srf->ctl_points + (coords * col_size * 
	    (row_size - 1));
	p4 = srf->ctl_points + (coords * col_size * 
	    (row_size - 1)) + 
	    ((col_size - 1) * coords);

	if ( dir == RT_NURB_SPLIT_ROW) {
		v1[0] = p1[0] - p3[0];
		v1[1] = p1[1] - p3[1];

		v2[0] = p2[0] - p4[0];
		v2[1] = p2[1] - p4[1];
	} else
	 {
		v1[0] = p1[0] - p2[0];
		v1[1] = p1[1] - p2[1];

		v2[0] = p3[0] - p4[0];
		v2[1] = p3[1] - p4[1];
	}

	v3[0] = v1[0] + v2[0];
	v3[1] = v1[1] + v1[1];

	norm = sqrt( v3[1] * v3[1] + v3[0] * v3[0]);
	l1.a = v3[1] / norm;
	l1.b = -v3[0] / norm;

	*min = 1.0e8;
	*max = -1.0e8;

	if( dir == RT_NURB_SPLIT_ROW)
	{
		for( i = 0; i < col_size; i++)
		{
			ch[i].param = (fastf_t) i / (col_size - 1.0);
			ch[i].min = 1.0e8;
			ch[i].max = -1.0e8;
		}

		mp1 = srf->ctl_points;

		for( i = 0; i < row_size; i++)
		{
			for( j = 0; j < col_size; j++)
			{
				value = - (mp1[0] * l1.a + mp1[1] * l1.b);
				if( value <= ch[j].min) 
					ch[j].min = value;
				if( value >= ch[j].max) 
					ch[j].max = value;
				mp1 += coords;
			}
		}

		for( k = 0; k < col_size - 1; k++)
		for( j = k+1; j < col_size; j++)
		{
			fastf_t d;
			fastf_t param1, param2;

			param1 = ch[k].param;
			param2 = ch[j].param;
				
			d = FINDZERO( param1, param2, ch[k].max, ch[j].max);
			if( d <= *min ) *min = d * .99;
			if( d >= *max ) *max = d * .99 + .01;

			d = FINDZERO( param1, param2, ch[k].min, ch[j].min);
			if( d <= *min ) *min = d * .99;
			if( d >= *max ) *max = d * .99 + .01;
		}

		if (*min <= 0.0) 
			*min = 0.0;
		if (*max >= 1.0) 
			*max = 1.0;
		if ( SIGN(ch[0].min) != SIGN(ch[0].max))
			*min = 0.0;
		i = SIGN(ch[col_size -1].min);
		j = SIGN(ch[col_size -1].max);
		if ( i != j)
			*max = 1.0;
	} else
	{
		for( i = 0; i < row_size; i++)
		{
			ch[i].param = (fastf_t) i / (row_size - 1.0);
			ch[i].min = 1.0e8;
			ch[i].max = -1.0e8;
		}


		for( i = 0; i < col_size; i++)
		{
			int stride;

			stride = coords * col_size;

			mp1 = srf->ctl_points + i * coords;
			for( j = 0; j < row_size; j++)
			{
				value = - (mp1[0] * l1.a + mp1[1] * l1.b);
				if( value <= ch[j].min) 
					ch[j].min = value;
				if( value >= ch[j].max) 
					ch[j].max = value;
				mp1 += stride;
			}
		}

		for( k = 0; k < row_size - 1; k++)
		for( j = k+1; j < row_size; j++)
		{
			fastf_t d;
			fastf_t param1, param2;

			param1 = ch[k].param;
			param2 = ch[j].param;
				
			d = FINDZERO( param1, param2, ch[k].max, ch[j].max);
			if( d <= *min ) *min = d * .99;
			if( d >= *max ) *max = d * .99 + .01;

			d = FINDZERO( param1, param2, ch[k].min, ch[j].min);
			if( d <= *min ) *min = d * .99;
			if( d >= *max ) *max = d * .99 + .01;
		}
		if (*min <= 0.0) 
			*min = 0.0;
		if (*max >= 1.0) 
			*max = 1.0;
		if ( SIGN(ch[0].min) != SIGN(ch[0].max))
			*min = 0.0;
		i = SIGN(ch[row_size-1 ].min);
		j = SIGN(ch[row_size -1].max);
		if ( i != j )
			*max = 1.0;	}
}

/*
 *			R T _ N U R B _ R E G I O N _ F R O M _ S R F
 */
struct face_g_snurb *
rt_nurb_region_from_srf(const struct face_g_snurb *srf, int dir, fastf_t param1, fastf_t param2, struct resource *res)
{
	register int	i;
	struct face_g_snurb *region;
	struct knot_vector new_knots;
	fastf_t knot_vec[40];

	/* Build the new knot vector in the local array */
	/* XXX fill in magic number here? */
	new_knots.knots = & knot_vec[0];

	if ( dir == RT_NURB_SPLIT_ROW) {
		new_knots.k_size = srf->order[0] * 2;

		for ( i = 0; i < srf->order[0]; i++) {
			knot_vec[i] = param1;
			knot_vec[i+srf->order[0]] = param2;
		}
	} else
	 {
		new_knots.k_size = srf->order[1] * 2;

		for ( i = 0; i < srf->order[1]; i++) {
			knot_vec[i] = param1;
			knot_vec[i+srf->order[1]] = param2;
		}

	}
	if( new_knots.k_size >= 40 )  rt_bomb("rt_nurb_region_from_srf() local kv overflow\n");

	region = rt_nurb_s_refine( srf, dir, &new_knots, res);

	return region;
}

/*
 *			R T _ N U R B _ I N T E R S E C T
 */
struct rt_nurb_uv_hit *
rt_nurb_intersect(const struct face_g_snurb *srf, fastf_t *plane1, fastf_t *plane2, double uv_tol, struct resource *res)
{
	struct rt_nurb_uv_hit * h;
	struct face_g_snurb 	* psrf,
			* osrf;
	int 		dir,
			sub;

	point_t 	vmin,
			vmax;
	fastf_t 	u[2],
			v[2];
	struct bu_list	plist;

	NMG_CK_SNURB(srf);

	h = (struct rt_nurb_uv_hit *) 0;
	BU_LIST_INIT( &plist );

	/* project the surface to a 2 dimensional problem */
	/* NOTE that this gives a single snurb back, NOT a list */
	psrf = rt_nurb_project_srf( srf, plane2, plane1, res );
	psrf->dir = 1;
	BU_LIST_APPEND( &plist, &psrf->l );

	if( RT_G_DEBUG & DEBUG_SPLINE )
		rt_nurb_s_print("srf", psrf);
	
	/* This list starts out with only a single snurb,
	 * but more may be added on as work progresses.
	 */
top:
	while( BU_LIST_WHILE( psrf, face_g_snurb, &plist ) )  {
		int flat;
		
		BU_LIST_DEQUEUE( &psrf->l );
		NMG_CK_SNURB(psrf);
		sub = 0;
		flat = 0;
		dir = psrf->dir;
		
		while(!flat)
		{
			fastf_t smin, smax;

			sub++;
			dir = (dir == 0)?1:0;	/* change direction */
			
			if( RT_G_DEBUG & DEBUG_SPLINE )
				rt_nurb_s_print("psrf", psrf);

			rt_nurb_pbound( psrf, vmin, vmax);

			/* Check for origin to be included in the bounding box */
			if( !(vmin[0] <= 0.0 && vmin[1] <= 0.0 &&
				vmax[0] >= 0.0 && vmax[1] >= 0.0 ))
			{
				if( RT_G_DEBUG & DEBUG_SPLINE )
					bu_log( "this srf doesn't include the origin\n" );
				flat = 1;
				rt_nurb_free_snurb( psrf, res );
				continue;
			}

			rt_nurb_clip_srf( psrf, dir, &smin, &smax);

			if( (smax - smin) > .8)  {
				/* Split surf, requeue both sub-surfs at head */
				/* New surfs will have same dir as arg, here */
				if( RT_G_DEBUG & DEBUG_SPLINE )
					bu_log( "splitting this surface\n" );
				rt_nurb_s_split( &plist, psrf, dir, res );
				rt_nurb_free_snurb( psrf, res );
				goto top;
			}
			if( smin > 1.0 || smax < 0.0 )
			{
				if( RT_G_DEBUG & DEBUG_SPLINE )
					bu_log( "eliminating this surface (smin=%g, smax=%g)\n", smin, smax );
				flat = 1;
				rt_nurb_free_snurb( psrf, res );
				continue;
			}
			if ( dir == RT_NURB_SPLIT_ROW)
			{
		                smin = (1.0 - smin) * psrf->u.knots[0] +
                		        smin * psrf->u.knots[
		                        psrf->u.k_size -1];
		                smax = (1.0 - smax) * psrf->u.knots[0] +
		                        smax * psrf->u.knots[
                		        psrf->u.k_size -1];
			} else
			{
	                        smin = (1.0 - smin) * psrf->v.knots[0] +
        	                        smin * psrf->v.knots[
                	                psrf->v.k_size -1];
                        	smax = (1.0 - smax) * psrf->v.knots[0] +
                                	smax * psrf->v.knots[
	                                psrf->v.k_size -1];
			}

			osrf = psrf;
			psrf = (struct face_g_snurb *)	rt_nurb_region_from_srf(
				osrf, dir, smin, smax, res);

			psrf->dir = dir;
			rt_nurb_free_snurb(osrf, res);

			if( RT_G_DEBUG & DEBUG_SPLINE )
			{
				bu_log( "After call to rt_nurb_region_from_srf() (smin=%g, smax=%g)\n", smin, smax );
				rt_nurb_s_print("psrf", psrf);
			}

			u[0] = psrf->u.knots[0];
			u[1] = psrf->u.knots[psrf->u.k_size -1];

			v[0] = psrf->v.knots[0];
			v[1] = psrf->v.knots[psrf->v.k_size -1];
			
                        if( (u[1] - u[0]) < uv_tol && (v[1] - v[0]) < uv_tol)
                        {
				struct rt_nurb_uv_hit * hit;

				if( RT_G_DEBUG & DEBUG_SPLINE )
				{
					fastf_t p1[4], p2[4];
					int coords;
					vect_t diff;

					coords = RT_NURB_EXTRACT_COORDS( srf->pt_type );
					rt_nurb_s_eval( srf, u[0], v[0], p1 );
					rt_nurb_s_eval( srf, u[1], v[1], p2 );

					if( RT_NURB_IS_PT_RATIONAL( srf->pt_type ) )
					{
						fastf_t inv_w;

						inv_w = 1.0 / p1[coords-1];
						VSCALE( p1, p1, inv_w )

						inv_w = 1.0 / p2[coords-1];
						VSCALE( p2, p2, inv_w )
					}

					VSUB2( diff, p1, p2 )
					bu_log( "Precision of hit point = %g (%f %f %f) <-> (%f %f %f)\n",
						MAGNITUDE( diff ), V3ARGS( p1 ), V3ARGS( p2 ) );
				}

                       		hit = (struct rt_nurb_uv_hit *) bu_malloc(
						sizeof( struct rt_nurb_uv_hit),  "hit" );

                        	hit->next = (struct rt_nurb_uv_hit *)0;
                        	hit->sub = sub;
                        	hit->u = (u[0] + u[1])/2.0;
                        	hit->v = (v[0] + v[1])/2.0;
                        	
                        	if( h == (struct rt_nurb_uv_hit *)0)
                        		h = hit;
                        	else
                        	{
                        		hit->next = h;
                        		h = hit;
                        	}
                        	flat = 1;
                        	rt_nurb_free_snurb( psrf, res );
                        }
			if( (u[1] - u[0]) > (v[1] - v[0]) )
				dir = 1;
			else dir = 0;
		}
	}

	return (struct rt_nurb_uv_hit *)h;
}

void
rt_nurb_pbound(struct face_g_snurb *srf, fastf_t *vmin, fastf_t *vmax)
{
	register fastf_t * ptr;
	register int coords;
	int i;
	
 	vmin[0] = vmin[1] = vmin[2] = INFINITY;
	vmax[0] = vmax[1] = vmax[2] = -INFINITY;

	ptr = srf->ctl_points;

	coords = RT_NURB_EXTRACT_COORDS(srf->pt_type);

	for( i = (srf->s_size[RT_NURB_SPLIT_ROW] * 
	    srf->s_size[RT_NURB_SPLIT_COL] ); i > 0; i--)
	{
		V_MIN( (vmin[0]), (ptr[0]));
		V_MAX( (vmax[0]), (ptr[0]));

		V_MIN( (vmin[1]), (ptr[1]));
		V_MAX( (vmax[1]), (ptr[1]));
		
		ptr += coords;
	}
}
@


11.16
log
@change conf.h to a wrapped config.h
@
text
@@


11.15
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 5
a24 1
#include "conf.h"
@


11.14
log
@update copyright to include span through 2003
@
text
@d31 1
a31 1
void rt_nurb_pbound();
d34 1
a34 4
rt_nurb_project_srf( srf, plane1, plane2, res)
const struct face_g_snurb *srf;
plane_t plane1, plane2;
struct resource *res;
d122 1
a122 4
rt_nurb_clip_srf( srf, dir, min, max)
const struct face_g_snurb *srf;
int	dir;
fastf_t *min, *max;
d288 1
a288 5
rt_nurb_region_from_srf( srf, dir, param1, param2, res)
const struct face_g_snurb *srf;
int	dir;
fastf_t param1, param2;
struct resource *res;
d327 1
a327 6
rt_nurb_intersect( srf, plane1, plane2, uv_tol, res )
const struct face_g_snurb * srf;
plane_t plane1;
plane_t plane2;
double	uv_tol;
struct resource *res;
d505 1
a505 3
rt_nurb_pbound( srf, vmin, vmax)
struct face_g_snurb * srf;
point_t vmin, vmax;
@


11.13
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1991 by the United States Army.
@


11.13.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1991-2004 by the United States Army.
@


11.13.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1991-2004 by the United States Army.
@


11.13.2.1
log
@Initial ANSIfication
@
text
@d31 1
a31 1
void rt_nurb_pbound(struct face_g_snurb *srf, fastf_t *vmin, fastf_t *vmax);
d34 4
a37 1
rt_nurb_project_srf(const struct face_g_snurb *srf, fastf_t *plane1, fastf_t *plane2, struct resource *res)
d125 4
a128 1
rt_nurb_clip_srf(const struct face_g_snurb *srf, int dir, fastf_t *min, fastf_t *max)
d294 5
a298 1
rt_nurb_region_from_srf(const struct face_g_snurb *srf, int dir, fastf_t param1, fastf_t param2, struct resource *res)
d337 6
a342 1
rt_nurb_intersect(const struct face_g_snurb *srf, fastf_t *plane1, fastf_t *plane2, double uv_tol, struct resource *res)
d520 3
a522 1
rt_nurb_pbound(struct face_g_snurb *srf, fastf_t *vmin, fastf_t *vmax)
@


11.13.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1991-2004 by the United States Army.
@


11.12
log
@Converted from K&R to ANSI C - RFH
@
text
@d31 1
a31 1
void rt_nurb_pbound(struct face_g_snurb *srf, fastf_t *vmin, fastf_t *vmax);
d34 4
a37 1
rt_nurb_project_srf(const struct face_g_snurb *srf, fastf_t *plane1, fastf_t *plane2, struct resource *res)
d125 4
a128 1
rt_nurb_clip_srf(const struct face_g_snurb *srf, int dir, fastf_t *min, fastf_t *max)
d294 5
a298 1
rt_nurb_region_from_srf(const struct face_g_snurb *srf, int dir, fastf_t param1, fastf_t param2, struct resource *res)
d337 6
a342 1
rt_nurb_intersect(const struct face_g_snurb *srf, fastf_t *plane1, fastf_t *plane2, double uv_tol, struct resource *res)
d520 3
a522 1
rt_nurb_pbound(struct face_g_snurb *srf, fastf_t *vmin, fastf_t *vmax)
@


11.11
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d31 1
a31 1
void rt_nurb_pbound();
d34 1
a34 4
rt_nurb_project_srf( srf, plane1, plane2, res)
const struct face_g_snurb *srf;
plane_t plane1, plane2;
struct resource *res;
d122 1
a122 4
rt_nurb_clip_srf( srf, dir, min, max)
const struct face_g_snurb *srf;
int	dir;
fastf_t *min, *max;
d288 1
a288 5
rt_nurb_region_from_srf( srf, dir, param1, param2, res)
const struct face_g_snurb *srf;
int	dir;
fastf_t param1, param2;
struct resource *res;
d327 1
a327 6
rt_nurb_intersect( srf, plane1, plane2, uv_tol, res )
const struct face_g_snurb * srf;
plane_t plane1;
plane_t plane2;
double	uv_tol;
struct resource *res;
d505 1
a505 3
rt_nurb_pbound( srf, vmin, vmax)
struct face_g_snurb * srf;
point_t vmin, vmax;
@


11.10
log
@CONST to const
@
text
@d367 1
a367 1
	if( rt_g.debug & DEBUG_SPLINE )
d390 1
a390 1
			if( rt_g.debug & DEBUG_SPLINE )
d399 1
a399 1
				if( rt_g.debug & DEBUG_SPLINE )
d411 1
a411 1
				if( rt_g.debug & DEBUG_SPLINE )
d419 1
a419 1
				if( rt_g.debug & DEBUG_SPLINE )
d450 1
a450 1
			if( rt_g.debug & DEBUG_SPLINE )
d466 1
a466 1
				if( rt_g.debug & DEBUG_SPLINE )
@


11.9
log
@Eliminated pmalloc (a failed experiment)
@
text
@d35 1
a35 1
CONST struct face_g_snurb *srf;
d126 1
a126 1
CONST struct face_g_snurb *srf;
d295 1
a295 1
CONST struct face_g_snurb *srf;
d338 1
a338 1
CONST struct face_g_snurb * srf;
@


11.8
log
@modified rt_nurb_intersect() to use bu_malloc instead of rt_pmalloc if no resource structure is available.
@
text
@d492 1
a492 6
                        	if( res )
	                        	hit = (struct rt_nurb_uv_hit *) rt_pmalloc(
	                        		sizeof( struct rt_nurb_uv_hit), 
	                        		&res->re_pmem);
                        	else
                        		hit = (struct rt_nurb_uv_hit *) bu_malloc(
@


11.8.2.1
log
@Eliminated pmalloc (a failed experiment)
@
text
@d492 6
a497 1
                       		hit = (struct rt_nurb_uv_hit *) bu_malloc(
@


11.7
log
@rt_pmalloc
@
text
@d492 8
a499 3
                        	hit = (struct rt_nurb_uv_hit *) rt_pmalloc(
                        		sizeof( struct rt_nurb_uv_hit), 
                        		&res->re_pmem);
@


11.6
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d492 1
a492 1
                        	hit = (struct rt_nurb_uv_hit *) pmalloc(
@


11.5
log
@Added some debug logging.
@
text
@d34 1
a34 1
rt_nurb_project_srf( srf, plane1, plane2)
d37 1
d56 1
a56 1
	    srf->s_size[0], srf->s_size[1], n_pt_type);
d294 1
a294 1
rt_nurb_region_from_srf( srf, dir, param1, param2)
d298 1
d328 1
a328 1
	region = rt_nurb_s_refine( srf, dir, &new_knots);
d337 1
a337 1
rt_nurb_intersect( srf, plane1, plane2, uv_tol )
d342 1
d363 1
a363 1
	psrf = rt_nurb_project_srf( srf, plane2, plane1 );
d402 1
a402 1
				rt_nurb_free_snurb( psrf );
d413 2
a414 2
				rt_nurb_s_split( &plist, psrf, dir );
				rt_nurb_free_snurb( psrf );
d422 1
a422 1
				rt_nurb_free_snurb( psrf );
d445 1
a445 1
				osrf, dir, smin, smax);
d448 1
a448 1
			rt_nurb_free_snurb(osrf);
d465 28
a492 1
                        	hit = (struct rt_nurb_uv_hit *) rt_malloc(
d494 1
a494 1
                        		"rt_nurb_intersect:rt_nurb_uv_hit structure");
d508 1
a508 1
                        	rt_nurb_free_snurb( psrf );
@


11.4
log
@libbu
@
text
@d45 4
d89 8
d396 2
d408 2
d416 2
d446 6
@


11.3
log
@Fixed a declaration problem.
@
text
@d339 1
a339 1
	struct rt_list	plist;
d344 1
a344 1
	RT_LIST_INIT( &plist );
d350 1
a350 1
	RT_LIST_APPEND( &plist, &psrf->l );
d359 1
a359 1
	while( RT_LIST_WHILE( psrf, face_g_snurb, &plist ) )  {
d362 1
a362 1
		RT_LIST_DEQUEUE( &psrf->l );
@


11.2
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d30 3
d465 1
@


11.1
log
@Release_4.4
@
text
@d30 1
a30 1
struct snurb *
d32 1
a32 1
CONST struct snurb *srf;
d36 1
a36 1
	register struct snurb *psrf;
d46 2
a47 2
	psrf = (struct snurb *) rt_nurb_new_snurb( srf->order[0], srf->order[1],
	    srf->u_knots.k_size, srf->v_knots.k_size,
d52 2
a53 2
	for ( i = 0; i < srf->u_knots.k_size; i++) {
		psrf->u_knots.knots[i] = srf->u_knots.knots[i];
d56 2
a57 2
	for ( i = 0; i < srf->v_knots.k_size; i++) {
		psrf->v_knots.knots[i] = srf->v_knots.knots[i];
d86 1
a86 1
	return (struct snurb *) psrf;
d110 1
a110 1
CONST struct snurb *srf;
d277 1
a277 1
struct snurb *
d279 1
a279 1
CONST struct snurb *srf;
d284 1
a284 1
	struct snurb *region;
d321 1
a321 1
CONST struct snurb * srf;
d327 1
a327 1
	struct snurb 	* psrf,
d356 1
a356 1
	while( RT_LIST_WHILE( psrf, snurb, &plist ) )  {
d403 6
a408 6
		                smin = (1.0 - smin) * psrf->u_knots.knots[0] +
                		        smin * psrf->u_knots.knots[
		                        psrf->u_knots.k_size -1];
		                smax = (1.0 - smax) * psrf->u_knots.knots[0] +
		                        smax * psrf->u_knots.knots[
                		        psrf->u_knots.k_size -1];
d411 6
a416 6
	                        smin = (1.0 - smin) * psrf->v_knots.knots[0] +
        	                        smin * psrf->v_knots.knots[
                	                psrf->v_knots.k_size -1];
                        	smax = (1.0 - smax) * psrf->v_knots.knots[0] +
                                	smax * psrf->v_knots.knots[
	                                psrf->v_knots.k_size -1];
d420 1
a420 1
			psrf = (struct snurb *)	rt_nurb_region_from_srf(
d426 2
a427 2
			u[0] = psrf->u_knots.knots[0];
			u[1] = psrf->u_knots.knots[psrf->u_knots.k_size -1];
d429 2
a430 2
			v[0] = psrf->v_knots.knots[0];
			v[1] = psrf->v_knots.knots[psrf->v_knots.k_size -1];
d463 1
a463 1
struct snurb * srf;
@


11.1.1.1
log
@Release_4.5
@
text
@d30 3
a32 6

void rt_nurb_pbound();

struct face_g_snurb *
rt_nurb_project_srf( srf, plane1, plane2, res)
CONST struct face_g_snurb *srf;
a33 1
struct resource *res;
d36 1
a36 1
	register struct face_g_snurb *psrf;
a41 4
	if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		bu_log( "rt_nurb_project_srf: projecting surface, planes = (%g %g %g %g) (%g %g %g %g)\n",
			V4ARGS( plane1 ), V4ARGS( plane2 ) );

d46 3
a48 3
	psrf = (struct face_g_snurb *) rt_nurb_new_snurb( srf->order[0], srf->order[1],
	    srf->u.k_size, srf->v.k_size,
	    srf->s_size[0], srf->s_size[1], n_pt_type, res);
d52 2
a53 2
	for ( i = 0; i < srf->u.k_size; i++) {
		psrf->u.knots[i] = srf->u.knots[i];
d56 2
a57 2
	for ( i = 0; i < srf->v.k_size; i++) {
		psrf->v.knots[i] = srf->v.knots[i];
a81 8
		if (rt_g.NMG_debug & DEBUG_RT_ISECT)
		{
			if( rational )
				bu_log( "\tmesh pt (%g %g %g %g), becomes (%g %g)\n", V4ARGS( mp1 ), mp2[0], mp2[1] );
			else
				bu_log( "\tmesh pt (%g %g %g), becomes (%g %g)\n", V3ARGS( mp1 ), mp2[0], mp2[1] );
		}

d86 1
a86 1
	return (struct face_g_snurb *) psrf;
d110 1
a110 1
CONST struct face_g_snurb *srf;
d277 3
a279 3
struct face_g_snurb *
rt_nurb_region_from_srf( srf, dir, param1, param2, res)
CONST struct face_g_snurb *srf;
a281 1
struct resource *res;
d284 1
a284 1
	struct face_g_snurb *region;
d311 1
a311 1
	region = rt_nurb_s_refine( srf, dir, &new_knots, res);
d320 2
a321 2
rt_nurb_intersect( srf, plane1, plane2, uv_tol, res )
CONST struct face_g_snurb * srf;
a324 1
struct resource *res;
d327 1
a327 1
	struct face_g_snurb 	* psrf,
d336 1
a336 1
	struct bu_list	plist;
d341 1
a341 1
	BU_LIST_INIT( &plist );
d345 1
a345 1
	psrf = rt_nurb_project_srf( srf, plane2, plane1, res );
d347 1
a347 1
	BU_LIST_APPEND( &plist, &psrf->l );
d356 1
a356 1
	while( BU_LIST_WHILE( psrf, face_g_snurb, &plist ) )  {
d359 1
a359 1
		BU_LIST_DEQUEUE( &psrf->l );
a380 2
				if( rt_g.debug & DEBUG_SPLINE )
					bu_log( "this srf doesn't include the origin\n" );
d382 1
a382 1
				rt_nurb_free_snurb( psrf, res );
d391 2
a392 4
				if( rt_g.debug & DEBUG_SPLINE )
					bu_log( "splitting this surface\n" );
				rt_nurb_s_split( &plist, psrf, dir, res );
				rt_nurb_free_snurb( psrf, res );
a396 2
				if( rt_g.debug & DEBUG_SPLINE )
					bu_log( "eliminating this surface (smin=%g, smax=%g)\n", smin, smax );
d398 1
a398 1
				rt_nurb_free_snurb( psrf, res );
d403 6
a408 6
		                smin = (1.0 - smin) * psrf->u.knots[0] +
                		        smin * psrf->u.knots[
		                        psrf->u.k_size -1];
		                smax = (1.0 - smax) * psrf->u.knots[0] +
		                        smax * psrf->u.knots[
                		        psrf->u.k_size -1];
d411 6
a416 6
	                        smin = (1.0 - smin) * psrf->v.knots[0] +
        	                        smin * psrf->v.knots[
                	                psrf->v.k_size -1];
                        	smax = (1.0 - smax) * psrf->v.knots[0] +
                                	smax * psrf->v.knots[
	                                psrf->v.k_size -1];
d420 2
a421 2
			psrf = (struct face_g_snurb *)	rt_nurb_region_from_srf(
				osrf, dir, smin, smax, res);
d424 1
a424 7
			rt_nurb_free_snurb(osrf, res);

			if( rt_g.debug & DEBUG_SPLINE )
			{
				bu_log( "After call to rt_nurb_region_from_srf() (smin=%g, smax=%g)\n", smin, smax );
				rt_nurb_s_print("psrf", psrf);
			}
d426 2
a427 2
			u[0] = psrf->u.knots[0];
			u[1] = psrf->u.knots[psrf->u.k_size -1];
d429 2
a430 2
			v[0] = psrf->v.knots[0];
			v[1] = psrf->v.knots[psrf->v.k_size -1];
d435 1
a435 28

				if( rt_g.debug & DEBUG_SPLINE )
				{
					fastf_t p1[4], p2[4];
					int coords;
					vect_t diff;

					coords = RT_NURB_EXTRACT_COORDS( srf->pt_type );
					rt_nurb_s_eval( srf, u[0], v[0], p1 );
					rt_nurb_s_eval( srf, u[1], v[1], p2 );

					if( RT_NURB_IS_PT_RATIONAL( srf->pt_type ) )
					{
						fastf_t inv_w;

						inv_w = 1.0 / p1[coords-1];
						VSCALE( p1, p1, inv_w )

						inv_w = 1.0 / p2[coords-1];
						VSCALE( p2, p2, inv_w )
					}

					VSUB2( diff, p1, p2 )
					bu_log( "Precision of hit point = %g (%f %f %f) <-> (%f %f %f)\n",
						MAGNITUDE( diff ), V3ARGS( p1 ), V3ARGS( p2 ) );
				}

                        	hit = (struct rt_nurb_uv_hit *) rt_pmalloc(
d437 1
a437 1
                        		&res->re_pmem);
d451 1
a451 1
                        	rt_nurb_free_snurb( psrf, res );
a461 1
void
d463 1
a463 1
struct face_g_snurb * srf;
@


10.14
log
@Irix 6
@
text
@@


10.13
log
@Plugged dynamic memory leak.
@
text
@a124 1
	int	stride;
@


10.12
log
@Added include of conf.h
@
text
@d284 1
a284 1
	int	i;
d287 1
a287 1
	fastf_t knot_vec[20];
d289 4
a293 1

a294 1
		new_knots.knots = & knot_vec[0];
d297 2
a298 2
			new_knots.knots[i] = param1;
			new_knots.knots[i+srf->order[0]] = param2;
a302 3
		new_knots.knots = (fastf_t * ) rt_malloc( sizeof (fastf_t)
		    *srf->order[1] * 2, 
		    "rt_nurb_region_from_srf: newknot values");
d305 2
a306 2
			new_knots.knots[i] = param1;
			new_knots.knots[i+srf->order[1]] = param2;
d310 1
@


10.11
log
@added nurb_pbound here instead of in g_nurb
@
text
@d20 2
@


10.10
log
@took out malloc and free of knots in rt_nurb_region_from_surface
since we can easily use a static storage area.
@
text
@d460 28
@


10.9
log
@Can't have register arrays
@
text
@d285 1
d290 1
a290 3
		new_knots.knots = (fastf_t * ) rt_malloc( sizeof (fastf_t)
		    *srf->order[0] * 2, 
		    "rt_nurb__region_from_srf: newknot values");
a310 2

	rt_free( (char *)new_knots.knots, "rt_nurb_region_from_srf:knotvalues");
@


10.8
log
@Changed lists to use rt_list structures
Made some args CONST where appropriate
Switched to GET_CNURB() macros
Added calls to NMG_CK_SNURB()
@
text
@d112 1
a112 1
	register struct internal_convex_hull ch[20]; /* max order is 10 */
@


10.7
log
@Moved rt_nurb_intersect in from librt/g_nurb.c
@
text
@d23 2
d26 1
d30 1
a30 1
struct snurb *srf;
a47 1
	psrf->next = (struct snurb *)0;
d108 1
a108 1
struct snurb *srf;
d273 3
a275 1

d278 1
a278 1
struct snurb *srf;
d311 1
a311 2
	region = (struct snurb *)
		rt_nurb_s_refine( srf, dir, &new_knots);
d318 3
d322 2
a323 2
rt_nurb_intersect( srf, plane1, plane2)
struct snurb * srf;
d326 1
a329 1
			* s_list,
d338 1
d340 1
d343 2
d346 4
a349 2
	s_list = (struct snurb * ) rt_nurb_project_srf(
		srf, plane2, plane1);
d352 7
a358 7
		rt_nurb_s_print("srf", s_list);


	s_list->dir = 1;

	while ( s_list != ( struct snurb *)0)
	{
d361 2
a362 3
		psrf = s_list;
		s_list = s_list->next;

d390 4
a393 11
			if( (smax - smin) > .8)
			{
				struct snurb * s;

				s = (struct snurb *) rt_nurb_s_split(
					psrf, dir );
				s->dir = dir;
				s->next->dir = dir;
				s->next->next = s_list;
				s_list = s->next;
				
d395 1
a395 4

				psrf = s;
				psrf->next = (struct snurb *) 0;
				continue;
a400 1
				
d434 1
a434 2
#define UV_TOL	1.0e-6	/* Paper says 1.0e-4 is reasonable for 1k images, not close up */
                        if( (u[1] - u[0]) < UV_TOL && (v[1] - v[0]) < UV_TOL)
@


10.6
log
@deleted a couple of mallocs and free to work with the
new data structures.
@
text
@d314 150
@


10.5
log
@Control polygon/mesh is now just part of the cnurb/snurb structures,
rather than being a separate structure of their own.
@
text
@d110 1
a110 1
	register struct internal_convex_hull *ch;
a163 4
		ch = (struct internal_convex_hull *) rt_malloc(
			sizeof( struct internal_convex_hull) * col_size,
			"rt_nurb_clip_srf:convex_hull");

a215 4
		ch = (struct internal_convex_hull *) rt_malloc(
			sizeof( struct internal_convex_hull) * row_size,
			"rt_nurb_clip_srf:convex_hull");

a268 2

	rt_free( (char *)ch, "rt_nurb_clip_srf:convex_hull");
d280 1
a280 1
	struct knot_vector *new_knots;
a282 3
		new_knots = (struct knot_vector *) rt_malloc( 
		    sizeof( struct knot_vector ), 
		    "region from srf knot vector");
d284 2
a285 2
		new_knots->k_size = srf->order[0] * 2;
		new_knots->knots = (fastf_t * ) rt_malloc( sizeof (fastf_t)
d290 2
a291 2
			new_knots->knots[i] = param1;
			new_knots->knots[i+srf->order[0]] = param2;
d295 2
a296 6
		new_knots = (struct knot_vector *) rt_malloc( 
		    sizeof( struct knot_vector ), 
		    "region from srf knot vector");

		new_knots->k_size = srf->order[1] * 2;
		new_knots->knots = (fastf_t * ) rt_malloc( sizeof (fastf_t)
d301 2
a302 2
			new_knots->knots[i] = param1;
			new_knots->knots[i+srf->order[1]] = param2;
d308 1
a308 1
		rt_nurb_s_refine( srf, dir, new_knots);
d310 1
a310 2
	rt_free( (char *)new_knots->knots, "rt_nurb_region_from_srf:knotvalues");
	rt_free( (char *)new_knots, "rt_nurb_region_from_srf:knot vector");
@


10.4
log
@Modifications due to data structure revisions:  mesh and knots are no
longer pointers, but in-place structures.
@
text
@d37 1
a37 1
	rational = RT_NURB_IS_PT_RATIONAL( srf->mesh.pt_type);
d43 1
a43 1
	    srf->mesh.s_size[0], srf->mesh.s_size[1], n_pt_type);
d56 2
a57 2
	mp1 = srf->mesh.ctl_points;
	mp2 = psrf->mesh.ctl_points;
d59 1
a59 1
	for ( i = 0; i < srf->mesh.s_size[0] * srf->mesh.s_size[1]; i++) {
d78 2
a79 2
		mp1 += RT_NURB_EXTRACT_COORDS(srf->mesh.pt_type);
		mp2 += RT_NURB_EXTRACT_COORDS(psrf->mesh.pt_type);
d124 2
a125 2
	col_size = srf->mesh.s_size[1];
	row_size = srf->mesh.s_size[0];
d127 1
a127 1
	coords = RT_NURB_EXTRACT_COORDS(srf->mesh.pt_type);
d129 3
a131 3
	p1 = srf->mesh.ctl_points;
	p2 = srf->mesh.ctl_points + coords * (col_size - 1);
	p3 = srf->mesh.ctl_points + (coords * col_size * 
d133 1
a133 1
	p4 = srf->mesh.ctl_points + (coords * col_size * 
d175 1
a175 1
		mp1 = srf->mesh.ctl_points;
d238 1
a238 1
			mp1 = srf->mesh.ctl_points + i * coords;
@


10.3
log
@Expanded names of manifest constants
@
text
@d37 1
a37 1
	rational = RT_NURB_IS_PT_RATIONAL( srf->mesh->pt_type);
d42 2
a43 2
	    srf->u_knots->k_size, srf->v_knots->k_size,
	    srf->mesh->s_size[0], srf->mesh->s_size[1], n_pt_type);
d48 2
a49 2
	for ( i = 0; i < srf->u_knots->k_size; i++) {
		psrf->u_knots->knots[i] = srf->u_knots->knots[i];
d52 2
a53 2
	for ( i = 0; i < srf->v_knots->k_size; i++) {
		psrf->v_knots->knots[i] = srf->v_knots->knots[i];
d56 2
a57 2
	mp1 = srf->mesh->ctl_points;
	mp2 = psrf->mesh->ctl_points;
d59 1
a59 1
	for ( i = 0; i < srf->mesh->s_size[0] * srf->mesh->s_size[1]; i++) {
d78 2
a79 2
		mp1 += RT_NURB_EXTRACT_COORDS(srf->mesh->pt_type);
		mp2 += RT_NURB_EXTRACT_COORDS(psrf->mesh->pt_type);
d124 2
a125 2
	col_size = srf->mesh->s_size[1];
	row_size = srf->mesh->s_size[0];
d127 1
a127 1
	coords = RT_NURB_EXTRACT_COORDS(srf->mesh->pt_type);
d129 3
a131 3
	p1 = srf->mesh->ctl_points;
	p2 = srf->mesh->ctl_points + coords * (col_size - 1);
	p3 = srf->mesh->ctl_points + (coords * col_size * 
d133 1
a133 1
	p4 = srf->mesh->ctl_points + (coords * col_size * 
d175 1
a175 1
		mp1 = srf->mesh->ctl_points;
d238 1
a238 1
			mp1 = srf->mesh->ctl_points + i * coords;
@


10.2
log
@Element "trim" was never used.
@
text
@d37 1
a37 1
	rational = EXTRACT_RAT( srf->mesh->pt_type);
d39 1
a39 1
	n_pt_type = MAKE_PT_TYPE( 2, PT_PROJ, 0);
d46 1
a46 1
	psrf->dir = COL;
d78 2
a79 2
		mp1 += EXTRACT_COORDS(srf->mesh->pt_type);
		mp2 += EXTRACT_COORDS(psrf->mesh->pt_type);
d127 1
a127 1
	coords = EXTRACT_COORDS(srf->mesh->pt_type);
d137 1
a137 1
	if ( dir == ROW) {
d162 1
a162 1
	if( dir == ROW)
d292 1
a292 1
	if ( dir == ROW) {
@


10.1
log
@Release_4.0
@
text
@a45 1
	psrf->trim = (struct cnurb *)0;
@


1.6
log
@rt_nurb_clip_surf() returns void
@
text
@@


1.5
log
@deleted a struct smesh * for rt_nurb_clip_srf which returns nothing.
@
text
@d105 1
@


1.4
log
@Made things easier for 3d compiler.
@
text
@a104 1
struct s_mesh *
@


1.3
log
@fixed nurb.h
@
text
@d118 3
a120 1
	int	i, j, k;
d215 3
a217 1
		if ( SIGN(ch[col_size -1].min) != SIGN(ch[col_size -1].max))
d274 3
a276 1
		if ( SIGN(ch[row_size-1 ].min) != SIGN(ch[row_size -1].max))
@


1.2
log
@Minor lint
@
text
@d23 1
a23 1
#include "./nurb.h"
@


1.1
log
@Initial revision
@
text
@d273 1
a273 1
	rt_free( ch, "rt_nurb_clip_srf:convex_hull");
d322 2
a323 2
	rt_free( new_knots->knots, "rt_nurb_region_from_srf:knotvalues");
	rt_free( new_knots, "rt_nurb_region_from_srf:knot vector");
@
