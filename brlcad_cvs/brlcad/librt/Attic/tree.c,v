head	11.72;
access;
symbols
	ansi-20040405-merged:11.65.2.2
	postmerge-20040405-ansi:11.70
	premerge-20040404-ansi:11.69
	postmerge-autoconf:11.69
	autoconf-freeze:11.66.6.3
	premerge-autoconf:11.69
	ansi-20040316-freeze:11.65.2.1
	postmerge-20040315-windows:11.69
	premerge-20040315-windows:11.69
	windows-20040315-freeze:11.65.4.1
	autoconf-20031203:11.66.6.1
	autoconf-20031202:11.66
	autoconf-branch:11.66.0.6
	phong-branch:11.66.0.4
	photonmap-branch:11.66.0.2
	rel-6-1-DP:11.65
	windows-branch:11.65.0.4
	rel-6-0-2:11.63
	ansi-branch:11.65.0.2
	rel-6-0-1-branch:11.63.0.2
	hartley-6-0-post:11.64
	hartley-6-0-pre:11.63
	rel-6-0-1:11.63
	rel-6-0:11.62
	rel-5-4:11.42
	offsite-5-3-pre:11.48
	rel-5-3:11.42
	rel-5-2:11.42
	rel-5-1-branch:11.42.0.2
	rel-5-1:11.42
	rel-5-0:11.30
	rel-5-0-beta:11.29
	rel-4-5:11.19
	ctj-4-5-post:11.14
	ctj-4-5-pre:11.14
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.4
	rel-1-10:4.1
	rt-2:2.1
	rt:1.1;
locks; strict;
comment	@ * @;


11.72
date	2004.05.21.18.07.35;	author morrison;	state dead;
branches;
next	11.71;

11.71
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.70;

11.70
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.69;

11.69
date	2004.02.02.17.39.29;	author morrison;	state Exp;
branches;
next	11.68;

11.68
date	2003.12.09.14.58.15;	author jra;	state Exp;
branches;
next	11.67;

11.67
date	2003.10.29.17.57.25;	author jra;	state Exp;
branches;
next	11.66;

11.66
date	2003.04.07.12.46.28;	author jra;	state Exp;
branches
	11.66.6.1;
next	11.65;

11.65
date	2002.08.20.17.08.10;	author jra;	state Exp;
branches
	11.65.2.1
	11.65.4.1;
next	11.64;

11.64
date	2002.08.15.20.55.22;	author hartley;	state Exp;
branches;
next	11.63;

11.63
date	2002.05.28.13.31.48;	author jra;	state Exp;
branches;
next	11.62;

11.62
date	2002.02.20.15.55.38;	author jra;	state Exp;
branches;
next	11.61;

11.61
date	2002.02.18.20.11.13;	author jra;	state Exp;
branches;
next	11.60;

11.60
date	2002.01.10.18.12.41;	author butler;	state Exp;
branches;
next	11.59;

11.59
date	2001.11.09.16.30.15;	author rbowers;	state Exp;
branches;
next	11.58;

11.58
date	2001.11.05.21.20.06;	author morrison;	state Exp;
branches;
next	11.57;

11.57
date	2001.11.01.21.38.35;	author bparker;	state Exp;
branches;
next	11.56;

11.56
date	2001.06.22.20.41.49;	author jra;	state Exp;
branches;
next	11.55;

11.55
date	2001.05.29.18.57.46;	author jra;	state Exp;
branches;
next	11.54;

11.54
date	2001.05.17.20.05.25;	author morrison;	state Exp;
branches;
next	11.53;

11.53
date	2001.05.17.19.07.15;	author jra;	state Exp;
branches;
next	11.52;

11.52
date	2001.05.14.20.54.55;	author jra;	state Exp;
branches;
next	11.51;

11.51
date	2001.05.08.20.18.55;	author jra;	state Exp;
branches;
next	11.50;

11.50
date	2001.04.20.22.29.57;	author morrison;	state Exp;
branches;
next	11.49;

11.49
date	2001.04.02.21.38.10;	author morrison;	state Exp;
branches;
next	11.48;

11.48
date	2000.09.09.04.30.48;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	2000.09.08.05.54.43;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	2000.07.14.15.02.43;	author jra;	state Exp;
branches;
next	11.45;

11.45
date	2000.07.13.02.36.27;	author cjohnson;	state Exp;
branches;
next	11.44;

11.44
date	2000.07.10.23.01.51;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	2000.06.27.17.36.09;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	2000.04.15.02.04.42;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	2000.04.12.02.34.38;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	2000.03.04.05.53.46;	author mike;	state Exp;
branches;
next	11.39;

11.39
date	2000.03.03.01.32.49;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	2000.02.01.20.57.28;	author mike;	state Exp;
branches;
next	11.37;

11.37
date	2000.01.29.04.16.31;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	2000.01.22.03.31.51;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	2000.01.14.22.17.37;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	2000.01.13.04.08.31;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	2000.01.04.17.58.20;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	99.12.23.06.00.05;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	99.11.17.02.42.04;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	99.07.02.22.19.25;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	99.05.27.18.57.13;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	99.05.10.21.32.34;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	99.05.10.21.30.48;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	99.05.10.16.03.39;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	98.12.17.04.19.10;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	98.04.15.04.32.40;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	98.03.24.08.15.16;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	98.03.24.05.10.10;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	98.03.19.15.57.01;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	98.03.19.11.42.42;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	97.12.16.01.59.05;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	97.12.16.01.57.52;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	97.12.16.01.21.44;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	97.12.16.01.10.52;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	97.12.16.00.06.12;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	97.01.28.02.34.06;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.01.28.01.51.01;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	97.01.24.20.14.40;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.12.04.02.51.45;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	96.11.27.07.26.09;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.11.20.19.36.14;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	96.09.27.08.28.33;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.09.27.08.22.38;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.09.27.06.23.52;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	96.08.31.04.20.54;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.08.28.10.03.46;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.07.04.01.55.12;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.07.27.20.25.12;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.49;	author mike;	state Rel4_4;
branches;
next	10.12;

10.12
date	94.12.19.16.28.56;	author jra;	state Exp;
branches;
next	10.11;

10.11
date	94.11.29.22.46.52;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.11.29.17.55.24;	author butler;	state Exp;
branches;
next	10.9;

10.9
date	94.11.04.05.41.57;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.09.30.16.09.42;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.08.10.20.22.15;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.05.10.11.04.20;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.03.02.21.35.04;	author cjohnson;	state Exp;
branches;
next	10.4;

10.4
date	93.10.01.20.54.55;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.09.25.11.51.35;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.07.20.22.49.28;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.08;	author mike;	state Rel4_0;
branches;
next	9.48;

9.48
date	91.10.11.02.59.34;	author mike;	state Exp;
branches;
next	9.47;

9.47
date	91.10.10.22.42.32;	author mike;	state Exp;
branches;
next	9.46;

9.46
date	91.09.20.22.46.46;	author mike;	state Exp;
branches;
next	9.45;

9.45
date	91.07.17.01.49.27;	author mike;	state Exp;
branches;
next	9.44;

9.44
date	91.07.17.01.29.54;	author mike;	state Exp;
branches;
next	9.43;

9.43
date	91.07.16.21.12.27;	author mike;	state Exp;
branches;
next	9.42;

9.42
date	91.07.10.00.53.58;	author mike;	state Exp;
branches;
next	9.41;

9.41
date	91.07.10.00.52.19;	author mike;	state Exp;
branches;
next	9.40;

9.40
date	91.07.09.23.38.55;	author mike;	state Exp;
branches;
next	9.39;

9.39
date	91.07.06.02.16.11;	author mike;	state Exp;
branches;
next	9.38;

9.38
date	91.07.05.23.40.31;	author mike;	state Exp;
branches;
next	9.37;

9.37
date	91.07.01.03.38.05;	author mike;	state Exp;
branches;
next	9.36;

9.36
date	91.07.01.00.47.48;	author mike;	state Exp;
branches;
next	9.35;

9.35
date	91.06.30.23.17.01;	author mike;	state Exp;
branches;
next	9.34;

9.34
date	91.06.30.22.24.46;	author mike;	state Exp;
branches;
next	9.33;

9.33
date	91.06.30.21.24.05;	author mike;	state Exp;
branches;
next	9.32;

9.32
date	91.06.30.21.08.08;	author mike;	state Exp;
branches;
next	9.31;

9.31
date	91.06.30.18.33.51;	author mike;	state Exp;
branches;
next	9.30;

9.30
date	91.06.29.22.14.16;	author mike;	state Exp;
branches;
next	9.29;

9.29
date	91.06.29.19.20.13;	author mike;	state Exp;
branches;
next	9.28;

9.28
date	91.06.25.04.19.06;	author mike;	state Exp;
branches;
next	9.27;

9.27
date	91.06.25.01.57.30;	author mike;	state Exp;
branches;
next	9.26;

9.26
date	91.06.24.23.43.31;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	91.06.22.22.30.53;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	91.06.14.06.51.45;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	91.06.11.01.34.09;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.06.11.00.11.00;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	91.05.23.10.37.17;	author jehunt;	state Exp;
branches;
next	9.20;

9.20
date	91.05.18.03.03.46;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.01.26.02.55.33;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.01.25.21.19.56;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.01.11.07.08.28;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	90.11.11.04.55.53;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	90.10.07.21.38.55;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	90.05.21.15.45.16;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.04.27.02.12.53;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.04.25.00.44.26;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.04.12.23.12.32;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.04.12.04.10.29;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.04.09.21.36.58;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.02.26.15.00.48;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	89.12.31.00.13.42;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	89.12.30.05.22.25;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	89.12.09.01.29.14;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	89.12.08.06.00.22;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.10.13.20.37.18;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.12.35;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.57.35;	author mike;	state Rel3_5;
branches;
next	8.15;

8.15
date	89.04.28.00.29.35;	author mike;	state Exp;
branches;
next	8.14;

8.14
date	89.04.27.23.11.11;	author phil;	state Exp;
branches;
next	8.13;

8.13
date	89.04.17.17.25.55;	author mike;	state Exp;
branches;
next	8.12;

8.12
date	89.04.17.17.20.03;	author mike;	state Exp;
branches;
next	8.11;

8.11
date	89.04.17.11.07.17;	author mike;	state Exp;
branches;
next	8.10;

8.10
date	89.04.11.12.34.30;	author phil;	state Exp;
branches;
next	8.9;

8.9
date	89.04.08.02.49.10;	author mike;	state Exp;
branches;
next	8.8;

8.8
date	89.04.04.04.57.14;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.03.15.15.46.10;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.01.11.09.03.00;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	88.12.30.02.33.07;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	88.12.30.01.28.48;	author cjohnson;	state Exp;
branches;
next	8.3;

8.3
date	88.12.06.00.27.46;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.10.06.02.55.07;	author mike;	state Rel3_0;
branches;
next	8.1;

8.1
date	88.10.05.00.32.05;	author mike;	state Rel3_0;
branches;
next	7.12;

7.12
date	88.08.23.02.30.37;	author mike;	state Exp;
branches;
next	7.11;

7.11
date	88.08.19.06.56.10;	author mike;	state Exp;
branches;
next	7.10;

7.10
date	88.08.19.05.37.27;	author phil;	state Exp;
branches;
next	7.9;

7.9
date	88.08.09.03.49.29;	author phil;	state Exp;
branches;
next	7.8;

7.8
date	88.08.08.22.51.37;	author phil;	state Exp;
branches;
next	7.7;

7.7
date	88.07.14.20.58.52;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.05.14.02.29.37;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.05.14.00.47.52;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.01.26.05.53.41;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	87.11.14.01.04.27;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.06.40.23;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.34.59;	author mike;	state Rel;
branches;
next	6.4;

6.4
date	87.09.26.07.49.27;	author mike;	state Exp;
branches;
next	6.3;

6.3
date	87.09.26.03.24.34;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.08.09.19.13.36;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.57.16;	author mike;	state Rel;
branches;
next	5.3;

5.3
date	87.07.10.04.53.26;	author mike;	state Exp;
branches;
next	5.2;

5.2
date	87.07.08.01.01.18;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.13.17;	author mike;	state Rel;
branches;
next	4.11;

4.11
date	87.05.30.02.04.49;	author mike;	state Exp;
branches;
next	4.10;

4.10
date	87.03.24.01.02.40;	author phil;	state Exp;
branches;
next	4.9;

4.9
date	87.03.23.23.39.45;	author mike;	state Exp;
branches;
next	4.8;

4.8
date	87.03.19.04.59.47;	author mike;	state Exp;
branches;
next	4.7;

4.7
date	87.03.19.03.03.14;	author mike;	state Exp;
branches;
next	4.6;

4.6
date	87.03.17.22.52.18;	author phil;	state Exp;
branches;
next	4.5;

4.5
date	87.03.11.01.28.51;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.02.12.22.12.32;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.12.01.51.33;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.28.21.00.25;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.46.42;	author mike;	state Rel1;
branches;
next	3.17;

3.17
date	86.12.19.04.10.19;	author mike;	state Exp;
branches;
next	3.16;

3.16
date	86.12.19.04.07.27;	author mike;	state Exp;
branches;
next	3.15;

3.15
date	86.09.24.00.07.12;	author mike;	state Exp;
branches;
next	3.14;

3.14
date	86.08.12.04.17.08;	author mike;	state Exp;
branches;
next	3.13;

3.13
date	86.08.06.19.56.29;	author mike;	state Exp;
branches;
next	3.12;

3.12
date	86.07.31.08.30.34;	author mike;	state Exp;
branches;
next	3.11;

3.11
date	86.07.31.06.29.13;	author mike;	state Exp;
branches;
next	3.10;

3.10
date	86.07.30.03.54.58;	author mike;	state Exp;
branches;
next	3.9;

3.9
date	86.07.24.23.11.16;	author mike;	state Exp;
branches;
next	3.8;

3.8
date	86.07.24.06.23.10;	author mike;	state Exp;
branches;
next	3.7;

3.7
date	86.07.19.04.43.48;	author mike;	state Exp;
branches;
next	3.6;

3.6
date	86.07.18.00.22.03;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.07.17.18.20.01;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.07.11.21.51.20;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.11.17.23.26;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.11.01.33.37;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.06.11.00.35.03;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.34.34;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	86.06.09.21.52.32;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	86.03.27.21.20.36;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	86.03.14.21.57.27;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	86.03.14.21.08.03;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	86.01.29.13.33.04;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	86.01.20.23.39.27;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.10.02.22.35.14;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.09.24.18.36.12;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.09.14.05.27.34;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.09.10.01.06.35;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.09.06.02.30.39;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.05.02.21.33;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.07.59;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	85.07.30.05.56.25;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	85.06.04.23.24.25;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	85.06.04.20.22.53;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	85.05.29.00.15.25;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	85.05.02.20.18.08;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	85.03.26.20.07.08;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	85.03.25.17.46.57;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	85.03.25.11.47.42;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	85.02.07.20.31.20;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	85.02.07.19.19.53;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	85.01.31.20.17.31;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	85.01.28.13.55.00;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	84.11.30.03.59.47;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	84.11.29.07.00.42;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	84.11.27.06.58.32;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	84.11.24.03.55.58;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	84.11.24.03.05.21;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	84.11.23.20.56.51;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	84.11.22.09.07.44;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	84.11.20.20.15.17;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	84.11.16.06.30.10;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	84.11.15.22.42.49;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	84.10.19.01.39.36;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	84.09.06.03.29.45;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	84.08.28.03.07.53;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	84.05.04.09.15.59;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	84.05.03.06.55.56;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	84.05.02.05.10.04;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.05.01.06.40.07;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.04.26.07.51.50;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.04.26.05.42.55;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.04.18.02.20.44;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.04.02.16.42.20;	author mike;	state Exp;
branches;
next	;

11.65.2.1
date	2002.09.19.18.01.47;	author morrison;	state Exp;
branches;
next	11.65.2.2;

11.65.2.2
date	2004.03.17.21.19.00;	author morrison;	state Exp;
branches;
next	;

11.65.4.1
date	2004.03.11.23.43.46;	author morrison;	state Exp;
branches;
next	;

11.66.6.1
date	2003.12.03.16.24.08;	author erikg;	state Exp;
branches;
next	11.66.6.2;

11.66.6.2
date	2004.02.12.18.37.47;	author erikg;	state Exp;
branches;
next	11.66.6.3;

11.66.6.3
date	2004.03.15.14.07.30;	author erikg;	state Exp;
branches;
next	;


desc
@Reads GED database tree
@


11.72
log
@moved to src/
@
text
@/*
 *			T R E E
 *
 *  Ray Tracing library database tree walker.
 *  Collect and prepare regions and solids for subsequent ray-tracing.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/tree.c,v 11.71 2004/05/10 15:30:47 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "db.h"
#include "raytrace.h"
#include "./debug.h"

RT_EXTERN(void		rt_tree_kill_dead_solid_refs, (union tree *tp));

HIDDEN struct region *rt_getregion(struct rt_i *rtip, register const char *reg_name);
HIDDEN void	rt_tree_region_assign(register union tree *tp, register const struct region *regionp);

/*
 *  Also used by converters in conv/ directory.
 *  Don't forget to initialize ts_dbip before use.
 */
const struct db_tree_state	rt_initial_tree_state = {
	RT_DBTS_MAGIC,		/* magic */
	0,			/* ts_dbip */
	0,			/* ts_sofar */
	0, 0, 0, 0,		/* region, air, gmater, LOS */
#if __STDC__
	{
#endif
		/* struct mater_info ts_mater */
		{1.0, 1.0, 1.0},	/* color, RGB */
		-1.0,			/* Temperature */
		0,			/* ma_color_valid=0 --> use default */
		DB_INH_LOWER,		/* color inherit */
		DB_INH_LOWER,		/* mater inherit */
		(char *)0		/* shader */
#if __STDC__
	}
#endif
	,
	{1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0},
	REGION_NON_FASTGEN,		/* ts_is_fastgen */
#if __STDC__
	{
#endif
		/* attribute value set */
		BU_AVS_MAGIC,
		0,
		0,
		NULL,
		NULL,
		NULL
#if __STDC__
	}
#endif
	,
	0,				/* ts_stop_at_regions */
	NULL,				/* ts_region_start_func */
	NULL,				/* ts_region_end_func */
	NULL,				/* ts_leaf_func */
	NULL,				/* ts_ttol */
	NULL,				/* ts_tol */
	NULL,				/* ts_m */
	NULL,				/* ts_rtip */
	NULL				/* ts_resp */
};

#define ACQUIRE_SEMAPHORE_TREE(_hash)	switch((_hash)&03)  { \
	case 0: \
		bu_semaphore_acquire( RT_SEM_TREE0 ); \
		break; \
	case 1: \
		bu_semaphore_acquire( RT_SEM_TREE1 ); \
		break; \
	case 2: \
		bu_semaphore_acquire( RT_SEM_TREE2 ); \
		break; \
	default: \
		bu_semaphore_acquire( RT_SEM_TREE3 ); \
		break; \
	}

#define RELEASE_SEMAPHORE_TREE(_hash)	switch((_hash)&03)  { \
	case 0: \
		bu_semaphore_release( RT_SEM_TREE0 ); \
		break; \
	case 1: \
		bu_semaphore_release( RT_SEM_TREE1 ); \
		break; \
	case 2: \
		bu_semaphore_release( RT_SEM_TREE2 ); \
		break; \
	default: \
		bu_semaphore_release( RT_SEM_TREE3 ); \
		break; \
	}

/*
 *			R T _ G E T T R E E _ R E G I O N _ S T A R T
 *
 *  This routine must be prepared to run in parallel.
 */
/* ARGSUSED */
HIDDEN int rt_gettree_region_start(struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
/*const*/                     	     
/*const*/                    	       
                             	       
        			            
{
	RT_CK_RTI(tsp->ts_rtip);
	RT_CK_RESOURCE(tsp->ts_resp);

	/* Ignore "air" regions unless wanted */
	if( tsp->ts_rtip->useair == 0 &&  tsp->ts_aircode != 0 )  {
		tsp->ts_rtip->rti_air_discards++;
		return(-1);	/* drop this region */
	}
	return(0);
}

/*
 *			R T _ G E T T R E E _ R E G I O N _ E N D
 *
 *  This routine will be called by db_walk_tree() once all the
 *  solids in this region have been visited.
 *
 *  This routine must be prepared to run in parallel.
 *  As a result, note that the details of the solids pointed to
 *  by the soltab pointers in the tree may not be filled in
 *  when this routine is called (due to the way multiple instances of
 *  solids are handled).
 *  Therefore, everything which referred to the tree has been moved
 *  out into the serial section.  (rt_tree_region_assign, rt_bound_tree)
 */
HIDDEN union tree *rt_gettree_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
         /*const*/                     	     
/*const*/                    	       
          			         
        			            
{
	struct region		*rp;
	struct directory	*dp;
	int			shader_len=0;
	struct rt_i		*rtip;
	int			i;
	Tcl_HashTable		*tbl = (Tcl_HashTable *)client_data;
	Tcl_HashEntry		*entry;
	matp_t			inv_mat;

	RT_CK_DBI(tsp->ts_dbip);
	RT_CK_FULL_PATH(pathp);
	RT_CK_TREE(curtree);
	rtip =  tsp->ts_rtip;
	RT_CK_RTI(rtip);
	RT_CK_RESOURCE(tsp->ts_resp);

	if( curtree->tr_op == OP_NOP )  {
		/* Ignore empty regions */
		return  curtree;
	}

	BU_GETSTRUCT( rp, region );
	rp->l.magic = RT_REGION_MAGIC;
	rp->reg_regionid = tsp->ts_regionid;
	rp->reg_is_fastgen = tsp->ts_is_fastgen;
	rp->reg_aircode = tsp->ts_aircode;
	rp->reg_gmater = tsp->ts_gmater;
	rp->reg_los = tsp->ts_los;

	if( tsp->ts_attrs.count ) {
		rp->attr_values = (struct bu_mro **)bu_calloc( tsp->ts_attrs.count+1,
				     sizeof( struct bu_mro *), "regp->attr_values" );
		for( i=0 ; i<tsp->ts_attrs.count ; i++ ) {
			rp->attr_values[i] = bu_malloc( sizeof( struct bu_mro ),
							"rp->attr_values[i]" );
			bu_mro_init_with_string( rp->attr_values[i], tsp->ts_attrs.avp[i].value );
		}
	} else
		rp->attr_values = (struct bu_mro **)NULL;

	rp->reg_mater = tsp->ts_mater;		/* struct copy */
	if( tsp->ts_mater.ma_shader )
		shader_len = strlen( tsp->ts_mater.ma_shader );
	if( shader_len )
	{
		rp->reg_mater.ma_shader = bu_strdup( tsp->ts_mater.ma_shader );
	}
	else
		rp->reg_mater.ma_shader = (char *)NULL;

	rp->reg_name = db_path_to_string( pathp );

	dp = (struct directory *)DB_FULL_PATH_CUR_DIR(pathp);

	if(RT_G_DEBUG&DEBUG_TREEWALK)  {
		bu_log("rt_gettree_region_end() %s\n", rp->reg_name );
		rt_pr_tree( curtree, 0 );
	}
	
	rp->reg_treetop = curtree;
	rp->reg_all_unions = db_is_tree_all_unions( curtree );

	/* Determine material properties */
	rp->reg_mfuncs = (char *)0;
	rp->reg_udata = (char *)0;
	if( rp->reg_mater.ma_color_valid == 0 )
		rt_region_color_map(rp);

	bu_semaphore_acquire( RT_SEM_RESULTS );	/* enter critical section */

	rp->reg_instnum = dp->d_uses++;

	/*
	 *  Add the region to the linked list of regions.
	 *  Positions in the region bit vector are established at this time.
	 */
	BU_LIST_INSERT( &(rtip->HeadRegion), &rp->l );

	rp->reg_bit = rtip->nregions++;	/* Assign bit vector pos. */
	bu_semaphore_release( RT_SEM_RESULTS );	/* leave critical section */

	if( tbl && bu_avs_get( &tsp->ts_attrs, "ORCA_Comp" ) ) {
		int newentry;

		inv_mat = (matp_t)bu_calloc( 16, sizeof( fastf_t ), "inv_mat" );
		if( tsp->ts_mat )
			bn_mat_inv( inv_mat, tsp->ts_mat );
		else
			bn_mat_idn( inv_mat );
		
		bu_semaphore_acquire( RT_SEM_RESULTS );	/* enter critical section */

		entry = Tcl_CreateHashEntry(tbl, (char *)rp->reg_bit, &newentry);
		Tcl_SetHashValue( entry, (ClientData)inv_mat );

		bu_semaphore_release( RT_SEM_RESULTS );	/* leave critical section */
	}

	if( RT_G_DEBUG & DEBUG_REGIONS )  {
		bu_log("Add Region %s instnum %d\n",
			rp->reg_name, rp->reg_instnum);
	}

	/* Indicate that we have swiped 'curtree' */
	return(TREE_NULL);
}

/*
 *			R T _ F I N D _ I D E N T I C A L _ S O L I D
 *
 *  See if solid "dp" as transformed by "mat" already exists in the
 *  soltab list.  If it does, return the matching stp, otherwise,
 *  create a new soltab structure, enrole it in the list, and return
 *  a pointer to that.
 *
 *  "mat" will be a null pointer when an identity matrix is signified.
 *  This greatly speeds the comparison process.
 *
 *  The two cases can be distinguished by the fact that stp->st_id will
 *  be 0 for a new soltab structure, and non-zero for an existing one.
 *
 *  This routine will run in parallel.
 *
 *  In order to avoid a race between searching the soltab list and
 *  adding new solids to it, the new solid to be added *must* be
 *  enrolled in the list before exiting the critical section.
 *
 *  To limit the size of the list to be searched, there are many lists.
 *  The selection of which list is determined by the hash value
 *  computed from the solid's name.
 *  This is the same optimization used in searching the directory lists.
 *
 *  This subroutine is the critical bottleneck in parallel tree walking.
 *
 *  It is safe, and much faster, to use several different
 *  critical sections when searching different lists.
 *
 *  There are only 4 dedicated semaphores defined, TREE0 through TREE3.
 *  This unfortunately limits the code to having only 4 CPUs doing list
 *  searching at any one time.  Hopefully, this is enough parallelism
 *  to keep the rest of the CPUs doing I/O and actual solid prepping.
 *
 *  Since the algorithm has been reduced from an O((nsolid/128)**2)
 *  search on the entire rti_solidheads[hash] list to an O(ninstance)
 *  search on the dp->d_use_head list for this one solid, the critical
 *  section should be relatively short-lived.  Having the 3-way split
 *  should provide ample opportunity for parallelism through here,
 *  while still ensuring that the necessary variables are protected.
 *
 *  There are two critical variables which *both* need to be protected:
 *  the specific rti_solidhead[hash] list head, and the specific
 *  dp->d_use_hd list head.  Fortunately, since the selection of
 *  critical section is based upon db_dirhash(dp->d_namep), any other
 *  processor that wants to search this same 'dp' will get the same
 *  hash as the current thread, and will thus wait for the appropriate
 *  semaphore to be released.  Similarly, any other thread that
 *  wants to search the same rti_solidhead[hash] list as the current
 *  thread will be using the same hash, and will thus wait for the
 *  proper semaphore.
 */
HIDDEN struct soltab *rt_find_identical_solid(register const matp_t mat, register struct directory *dp, struct rt_i *rtip)
{
	register struct soltab	*stp = RT_SOLTAB_NULL;
	int			hash;

	RT_CK_DIR(dp);
	RT_CK_RTI(rtip);

	hash = db_dirhash( dp->d_namep );

	/* Enter the appropriate dual critical-section */
	ACQUIRE_SEMAPHORE_TREE(hash);

	/*
	 *  If solid has not been referenced yet, the search can be skipped.
	 *  If solid is being referenced a _lot_, it certainly isn't
	 *  all going to be in the same place, so don't bother searching.
	 *  Consider the case of a million instances of the same tree
	 *  submodel solid.
	 */
	if( dp->d_uses > 0 && dp->d_uses < 100 &&
	    rtip->rti_dont_instance == 0
	)  {
		struct bu_list	*mid;

		/* Search dp->d_use_hd list for other instances */
		for( BU_LIST_FOR( mid, bu_list, &dp->d_use_hd ) )  {

			stp = BU_LIST_MAIN_PTR( soltab, mid, l2 );
			RT_CK_SOLTAB(stp);

			if( stp->st_matp == (matp_t)0 )  {
				if( mat == (matp_t)0 )  {
					/* Both have identity matrix */
					goto more_checks;
				}
				continue;
			}
			if( mat == (matp_t)0 )  continue;	/* doesn't match */

			if( !bn_mat_is_equal(mat, stp->st_matp, &rtip->rti_tol))
				continue;

more_checks:
			/* Don't instance this solid from some other model instance */
			/* As this is nearly always equal, check it last */
			if( stp->st_rtip != rtip )  continue;

			/*
			 *  stp now points to re-referenced solid.
			 *  stp->st_id is non-zero, indicating pre-existing solid.
			 */
			RT_CK_SOLTAB(stp);		/* sanity */

			/* Only increment use counter for non-dead solids. */
			if( !(stp->st_aradius <= -1) )
				stp->st_uses++;
			/* dp->d_uses is NOT incremented, because number of soltab's using it has not gone up. */
			if( RT_G_DEBUG & DEBUG_SOLIDS )  {
				bu_log( mat ?
				    "rt_find_identical_solid:  %s re-referenced %d\n" :
				    "rt_find_identical_solid:  %s re-referenced %d (identity mat)\n",
					dp->d_namep, stp->st_uses );
			}

			/* Leave the appropriate dual critical-section */
			RELEASE_SEMAPHORE_TREE(hash);
			return stp;
		}
	}

	/*
	 *  Create and link a new solid into the list.
	 *
	 *  Ensure the search keys "dp", "st_mat" and "st_rtip"
	 *  are stored now, while still
	 *  inside the critical section, because they are searched on, above.
	 */
	BU_GETSTRUCT(stp, soltab);
	stp->l.magic = RT_SOLTAB_MAGIC;
	stp->l2.magic = RT_SOLTAB2_MAGIC;
	stp->st_rtip = rtip;
	stp->st_dp = dp;
	dp->d_uses++;
	stp->st_uses = 1;
	/* stp->st_id is intentionally left zero here, as a flag */

	if( mat )  {
		stp->st_matp = (matp_t)bu_malloc( sizeof(mat_t), "st_matp" );
		MAT_COPY( stp->st_matp, mat );
	} else {
		stp->st_matp = (matp_t)0;
	}

	/* Add to the appropriate soltab list head */
	/* PARALLEL NOTE:  Uses critical section on rt_solidheads element */
	BU_LIST_INSERT( &(rtip->rti_solidheads[hash]), &(stp->l) );

	/* Also add to the directory structure list head */
	/* PARALLEL NOTE:  Uses critical section on this 'dp' */
	BU_LIST_INSERT( &dp->d_use_hd, &(stp->l2) );

	/*
	 * Leave the 4-way critical-section protecting dp and [hash]
	 */
	RELEASE_SEMAPHORE_TREE(hash);

	/* Enter an exclusive critical section to protect nsolids */
	/* nsolids++ needs to be locked to a SINGLE thread */
	bu_semaphore_acquire(RT_SEM_STATS);
	stp->st_bit = rtip->nsolids++;
	bu_semaphore_release(RT_SEM_STATS);

	/*
	 *  Fill in the last little bit of the structure in
	 *  full parallel mode, outside of any critical section.
	 */

	/* Init tables of regions using this solid.  Usually small. */
	bu_ptbl_init( &stp->st_regions, 7, "st_regions ptbl" );

	return stp;
}


/*
 *			R T _ G E T T R E E _ L E A F
 *
 *  This routine must be prepared to run in parallel.
 */
HIDDEN union tree *rt_gettree_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
/*const*/                     	     
                   		       
/*const*/                      	    
        			            
{
	register struct soltab	*stp;
	union tree		*curtree;
	struct directory	*dp;
	register matp_t		mat;
	int			i;
	struct rt_i		*rtip;

	RT_CK_DBTS(tsp);
	RT_CK_DBI(tsp->ts_dbip);
	RT_CK_FULL_PATH(pathp);
	RT_CK_DB_INTERNAL(ip);
	rtip = tsp->ts_rtip;
	RT_CK_RTI(rtip);
	RT_CK_RESOURCE(tsp->ts_resp);
	dp = DB_FULL_PATH_CUR_DIR(pathp);

	/* Determine if this matrix is an identity matrix */

	if( !bn_mat_is_equal(tsp->ts_mat, bn_mat_identity, &rtip->rti_tol)) {
		/* Not identity matrix */
		mat = (matp_t)tsp->ts_mat;
	} else {
		/* Identity matrix */
		mat = (matp_t)0;
	}

	/*
	 *  Check to see if this exact solid has already been processed.
	 *  Match on leaf name and matrix.
	 *  Note that there is a race here between having st_id filled
	 *  in a few lines below (which is necessary for calling ft_prep),
	 *  and ft_prep filling in st_aradius.  Fortunately, st_aradius
	 *  starts out as zero, and will never go down to -1 unless this
	 *  soltab structure has become a dead solid, so by testing against
	 *  -1 (instead of <= 0, like before, oops), it isn't a problem.
	 */
	stp = rt_find_identical_solid( mat, dp, rtip );
	if( stp->st_id != 0 )  {
		/* stp is an instance of a pre-existing solid */
		if( stp->st_aradius <= -1 )  {
			/* It's dead, Jim.  st_uses was not incremented. */
			return( TREE_NULL );	/* BAD: instance of dead solid */
		}
		goto found_it;
	}

	if( rtip->rti_add_to_new_solids_list ) {
		bu_ptbl_ins( &rtip->rti_new_solids, (long *)stp );
	}

	stp->st_id = ip->idb_type;
	stp->st_meth = &rt_functab[ip->idb_type];
	if( mat )  {
		mat = stp->st_matp;
	} else {
		mat = (matp_t)bn_mat_identity;
	}

	RT_CK_DB_INTERNAL( ip );

	/* init solid's maxima and minima */
	VSETALL( stp->st_max, -INFINITY );
	VSETALL( stp->st_min,  INFINITY );

    	/*
    	 *  If the ft_prep routine wants to keep the internal structure,
    	 *  that is OK, as long as idb_ptr is set to null.
	 *  Note that the prep routine may have changed st_id.
    	 */
	if( stp->st_meth->ft_prep( stp, ip, rtip ) )  {
		int	hash;
		/* Error, solid no good */
		bu_log("rt_gettree_leaf(%s):  prep failure\n", dp->d_namep );
		/* Too late to delete soltab entry; mark it as "dead" */
		hash = db_dirhash( dp->d_namep );
		ACQUIRE_SEMAPHORE_TREE(hash);
		stp->st_aradius = -1;
		stp->st_uses--;
		RELEASE_SEMAPHORE_TREE(hash);
		return( TREE_NULL );		/* BAD */
	}

	if( rtip->rti_dont_instance )  {
		/*
		 *  If instanced solid refs are not being compressed,
		 *  then memory isn't an issue, and the application
		 *  (such as solids_on_ray) probably cares about the
		 *  full path of this solid, from root to leaf.
		 *  So make it available here.
		 *  (stp->st_dp->d_uses could be the way to discriminate
		 *  references uniquely, if the path isn't enough.
		 *  To locate given dp and d_uses, search dp->d_use_hd list.
		 *  Question is, where to stash current val of d_uses?)
		 */
		db_full_path_init( &stp->st_path );
		db_dup_full_path( &stp->st_path, pathp );
	} else {
		/*
		 *  If there is more than just a direct reference to this leaf
		 *  from it's containing region, copy that below-region path
		 *  into st_path.  Otherwise, leave st_path's magic number 0.
		 * XXX nothing depends on this behavior yet, and this whole
		 * XXX 'else' clause might well be deleted. -Mike
		 */
		i = pathp->fp_len-1;
		if( i > 0 && !(pathp->fp_names[i-1]->d_flags & DIR_REGION) )  {
			/* Search backwards for region.  If no region, use whole path */
			for( --i; i > 0; i-- )  {
				if( pathp->fp_names[i-1]->d_flags & DIR_REGION ) break;
			}
			if( i < 0 )  i = 0;
			db_full_path_init( &stp->st_path );
			db_dup_path_tail( &stp->st_path, pathp, i );
		}
	}
	if(RT_G_DEBUG&DEBUG_TREEWALK && stp->st_path.magic == DB_FULL_PATH_MAGIC)  {
		char	*sofar = db_path_to_string(&stp->st_path);
		bu_log("rt_gettree_leaf() st_path=%s\n", sofar );
		bu_free(sofar, "path string");
	}

	if(RT_G_DEBUG&DEBUG_SOLIDS)  {
		struct bu_vls	str;
		bu_log("\n---Primitive %d: %s\n", stp->st_bit, dp->d_namep);
		bu_vls_init( &str );
		/* verbose=1, mm2local=1.0 */
		if( stp->st_meth->ft_describe( &str, ip, 1, 1.0, tsp->ts_resp, tsp->ts_dbip ) < 0 )  {
			bu_log("rt_gettree_leaf(%s):  solid describe failure\n",
				dp->d_namep );
		}
		bu_log( "%s:  %s", dp->d_namep, bu_vls_addr( &str ) );
		bu_vls_free( &str );
	}

found_it:
	RT_GET_TREE( curtree, tsp->ts_resp );
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_SOLID;
	curtree->tr_a.tu_stp = stp;
	/* regionp will be filled in later by rt_tree_region_assign() */
	curtree->tr_a.tu_regionp = (struct region *)0;

	if(RT_G_DEBUG&DEBUG_TREEWALK)  {
		char	*sofar = db_path_to_string(pathp);
		bu_log("rt_gettree_leaf() %s\n", sofar );
		bu_free(sofar, "path string");
	}

	return(curtree);
}

/*
 *			R T _ F R E E _ S O L T A B
 *
 *  Decrement use count on soltab structure.  If no longer needed,
 *  release associated storage, and free the structure.
 *
 *  This routine semaphore protects against other copies of itself
 *  running in parallel, and against
 *  other routines (such as rt_find_identical_solid()) which might
 *  also be modifying the linked list heads.
 *
 *  Called by -
 *	db_free_tree()
 *	rt_clean()
 *	rt_gettrees()
 *	rt_kill_deal_solid_refs()
 */
void
rt_free_soltab(struct soltab *stp)
{
	int	hash;

	RT_CK_SOLTAB(stp);
	if( stp->st_id < 0 || stp->st_id >= rt_nfunctab )
		rt_bomb("rt_free_soltab:  bad st_id");
	hash = db_dirhash(stp->st_dp->d_namep);

	ACQUIRE_SEMAPHORE_TREE(hash);		/* start critical section */
	if( --(stp->st_uses) > 0 )  {
		RELEASE_SEMAPHORE_TREE(hash);
		return;
	}
	BU_LIST_DEQUEUE( &(stp->l2) );		/* remove from st_dp->d_use_hd list */
	BU_LIST_DEQUEUE( &(stp->l) );		/* uses rti_solidheads[] */

	RELEASE_SEMAPHORE_TREE(hash);		/* end critical section */

	if( stp->st_aradius > 0 )  {
		stp->st_meth->ft_free( stp );
		stp->st_aradius = 0;
	}
	if( stp->st_matp )  bu_free( (char *)stp->st_matp, "st_matp");
	stp->st_matp = (matp_t)0;	/* Sanity */

	bu_ptbl_free(&stp->st_regions);

	stp->st_dp = DIR_NULL;		/* Sanity */

	if( stp->st_path.magic )  {
		RT_CK_FULL_PATH( &stp->st_path );
		db_free_full_path( &stp->st_path );
	}

	bu_free( (char *)stp, "struct soltab" );
}

/*			R T _ G E T T R E E S _ M U V E S
 *
 *  User-called function to add a set of tree hierarchies to the active set.
 *
 *  Includes getting the indicated list of attributes and a Tcl_HashTable
 *  for use with the ORCA man regions. (stashed in the rt_i structure).
 *
 *  This function may run in parallel, but is not multiply re-entrant itself,
 *  because db_walk_tree() isn't multiply re-entrant.
 *
 *  Semaphores used for critical sections in parallel mode:
 *	RT_SEM_TREE*	protects rti_solidheads[] lists, d_uses(solids)
 *	RT_SEM_RESULTS	protects HeadRegion, mdl_min/max, d_uses(reg), nregions
 *	RT_SEM_WORKER	(db_walk_dispatcher, from db_walk_tree)
 *	RT_SEM_STATS	nsolids
 *
 *  INPUTS
 *	rtip	- RT instance pointer
 *	attrs	- array of pointers (NULL terminated) to strings (attribute names). A corresponding
 *		  array of "bu_mro" objects containing the attribute values will be attached to region
 *		  structures ("attr_values")
 *	argc	- number of trees to get
 *	argv	- array of char pointers to the names of the tree tops
 *	ncpus	- number of cpus to use
 *  
 *  Returns -
 *  	0	Ordinarily
 *	-1	On major error
 */
int
rt_gettrees_muves(struct rt_i *rtip, const char **attrs, int argc, const char **argv, int ncpus)
{
	register struct soltab	*stp;
	register struct region	*regp;
	Tcl_HashTable		*tbl;
	int			prev_sol_count;
	int			i;
	int			num_attrs=0;
	point_t			region_min, region_max;

	RT_CHECK_RTI(rtip);
	RT_CK_DBI(rtip->rti_dbip);

	if(!rtip->needprep)  {
		bu_log("ERROR: rt_gettree() called again after rt_prep!\n");
		return(-1);		/* FAIL */
	}

	if( argc <= 0 )  return(-1);	/* FAIL */

	tbl = (Tcl_HashTable *)bu_malloc( sizeof( Tcl_HashTable ), "rtip->Orca_hash_tbl" );
	Tcl_InitHashTable( tbl, TCL_ONE_WORD_KEYS );
	rtip->Orca_hash_tbl = (genptr_t)tbl;

	prev_sol_count = rtip->nsolids;

	{
		struct db_tree_state	tree_state;

		tree_state = rt_initial_tree_state;	/* struct copy */
		tree_state.ts_dbip = rtip->rti_dbip;
		tree_state.ts_rtip = rtip;
		tree_state.ts_resp = NULL;	/* sanity.  Needs to be updated */

		if( attrs ) {
                       if( rtip->rti_dbip->dbi_version < 5 ) {
                               bu_log( "WARNING: requesting attributes from an old database version (ignored)\n" );
			       bu_avs_init_empty( &tree_state.ts_attrs );
                       } else {
			       while( attrs[num_attrs] ) {
				       num_attrs++;
			       }
			       if( num_attrs ) {
				       bu_avs_init( &tree_state.ts_attrs,
						    num_attrs,
						    "avs in tree_state" );
				       num_attrs = 0;
				       while( attrs[num_attrs] ) {
					       bu_avs_add( &tree_state.ts_attrs,
							   attrs[num_attrs],
							   NULL );
					       num_attrs++;
				       }
			       } else {
				       bu_avs_init_empty( &tree_state.ts_attrs );
			       }
		       }
		} else {
			bu_avs_init_empty( &tree_state.ts_attrs );
		}

		/* ifdef this out for now, it is only using memory.
		 * perhaps a better way of initiating ORCA stuff
		 * can be found.
		 */
#if 0
		bu_avs_add( &tree_state.ts_attrs, "ORCA_Comp", (char *)NULL );
#endif
		i = db_walk_tree( rtip->rti_dbip, argc, argv, ncpus,
				  &tree_state,
				  rt_gettree_region_start,
				  rt_gettree_region_end,
				  rt_gettree_leaf, (genptr_t)tbl );
		bu_avs_free( &tree_state.ts_attrs );
	}

	/* DEBUG:  Ensure that all region trees are valid */
	for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
		RT_CK_REGION(regp);
		db_ck_tree(regp->reg_treetop);
	}

	/*
	 *  Eliminate any "dead" solids that parallel code couldn't change.
	 *  First remove any references from the region tree,
	 *  then remove actual soltab structs from the soltab list.
	 */
	for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
		RT_CK_REGION(regp);
		rt_tree_kill_dead_solid_refs( regp->reg_treetop );
		(void)rt_tree_elim_nops( regp->reg_treetop, &rt_uniresource );
	}
again:
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		RT_CK_SOLTAB(stp);
		if( stp->st_aradius <= 0 )  {
			bu_log("rt_gettrees() cleaning up dead solid '%s'\n",
				stp->st_dp->d_namep );
			rt_free_soltab(stp);
			/* Can't do rtip->nsolids--, that doubles as max bit number! */
			/* The macro makes it hard to regain place, punt */
			goto again;
		}
	} RT_VISIT_ALL_SOLTABS_END

	/*
	 *  Another pass, no restarting.
	 *  Assign "piecestate" indices for those solids
	 *  which contain pieces.
	 */
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		if( stp->st_npieces > 1 )  {
			/* all pieces must be within model bounding box for pieces to work correctly */
			VMINMAX( rtip->mdl_min, rtip->mdl_max, stp->st_min );
			VMINMAX( rtip->mdl_min, rtip->mdl_max, stp->st_max );
			stp->st_piecestate_num = rtip->rti_nsolids_with_pieces++;
		}
		if(RT_G_DEBUG&DEBUG_SOLIDS)
			rt_pr_soltab( stp );
	} RT_VISIT_ALL_SOLTABS_END

	/* Handle finishing touches on the trees that needed soltab structs
	 * that the parallel code couldn't look at yet.
	 */
	for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
		RT_CK_REGION(regp);

		/* The region and the entire tree are cross-referenced */
		rt_tree_region_assign( regp->reg_treetop, regp );

		/*
		 *  Find region RPP, and update the model maxima and minima
		 *
		 *  Don't update min & max for halfspaces;  instead, add them
		 *  to the list of infinite solids, for special handling.
		 */
		if( rt_bound_tree( regp->reg_treetop, region_min, region_max ) < 0 )  {
			bu_log("rt_gettrees() %s\n", regp->reg_name );
			rt_bomb("rt_gettrees(): rt_bound_tree() fail\n");
		}
		if( region_max[X] < INFINITY )  {
			/* infinite regions are exempted from this */
			VMINMAX( rtip->mdl_min, rtip->mdl_max, region_min );
			VMINMAX( rtip->mdl_min, rtip->mdl_max, region_max );
		}
	}

	/* DEBUG:  Ensure that all region trees are valid */
	for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
		RT_CK_REGION(regp);
		db_ck_tree(regp->reg_treetop);
	}

	if( i < 0 )  return(i);

	if( rtip->nsolids <= prev_sol_count )
		bu_log("rt_gettrees(%s) warning:  no primitives found\n", argv[0]);
	return(0);	/* OK */
}

/*
 *  			R T _ G E T T R E E S _ A N D _ A T T R S
 *
 *  User-called function to add a set of tree hierarchies to the active set.
 *
 *  This function may run in parallel, but is not multiply re-entrant itself,
 *  because db_walk_tree() isn't multiply re-entrant.
 *
 *  Semaphores used for critical sections in parallel mode:
 *	RT_SEM_TREE*	protects rti_solidheads[] lists, d_uses(solids)
 *	RT_SEM_RESULTS	protects HeadRegion, mdl_min/max, d_uses(reg), nregions
 *	RT_SEM_WORKER	(db_walk_dispatcher, from db_walk_tree)
 *	RT_SEM_STATS	nsolids
 *  
 *  Returns -
 *  	0	Ordinarily
 *	-1	On major error
 *      -2      If there were unresolved names
 */
int
rt_gettrees_and_attrs(struct rt_i *rtip, const char **attrs, int argc, const char **argv, int ncpus)
{
	return( rt_gettrees_muves( rtip, attrs, argc, argv, ncpus ) );
}

/*
 *  			R T _ G E T T R E E
 *
 *  User-called function to add a tree hierarchy to the displayed set.
 *
 *  This function is not multiply re-entrant.
 *  
 *  Returns -
 *  	0	Ordinarily
 *	-1	On major error
 *      
 *  Note: -2 returns from rt_gettrees_and_attrs are filtered.
 */
int
rt_gettree(struct rt_i *rtip, const char *node)
{
  int rv;
  
  rv =  rt_gettrees_and_attrs( rtip, NULL, 1, &node, 1 );

  if (rv == 0 || rv == -2) 
    {
      return 0;
    }
  else
    {
      return -1;
    }
}

int
rt_gettrees(struct rt_i *rtip, int argc, const char **argv, int ncpus)
{
  int rv;
  rv = rt_gettrees_and_attrs( rtip, NULL, argc, argv, ncpus );

  if (rv == 0 || rv == -2) 
    {
      return 0;
    }
  else
    {
      return -1;
    }
}

/*
 *			R T _ B O U N D _ T R E E
 *
 *  Calculate the bounding RPP of the region whose boolean tree is 'tp'.
 *  The bounding RPP is returned in tree_min and tree_max, which need
 *  not have been initialized first.
 *
 *  Returns -
 *	0	success
 *	-1	failure (tree_min and tree_max may have been altered)
 */
int
rt_bound_tree(register const union tree *tp, fastf_t *tree_min, fastf_t *tree_max)
{	
	vect_t	r_min, r_max;		/* rpp for right side of tree */

	RT_CK_TREE(tp);

	switch( tp->tr_op )  {

	case OP_SOLID:
		{
			register const struct soltab	*stp;

			stp = tp->tr_a.tu_stp;
			RT_CK_SOLTAB(stp);
			if( stp->st_aradius <= 0 )  {
				bu_log("rt_bound_tree: encountered dead solid '%s'\n",
					stp->st_dp->d_namep);
				return -1;	/* ERROR */
			}

			if( stp->st_aradius >= INFINITY )  {
				VSETALL( tree_min, -INFINITY );
				VSETALL( tree_max,  INFINITY );
				return(0);
			}
			VMOVE( tree_min, stp->st_min );
			VMOVE( tree_max, stp->st_max );
			return(0);
		}

	default:
		bu_log( "rt_bound_tree(x%x): unknown op=x%x\n",
			tp, tp->tr_op );
		return(-1);

	case OP_XOR:
	case OP_UNION:
		/* BINARY type -- expand to contain both */
		if( rt_bound_tree( tp->tr_b.tb_left, tree_min, tree_max ) < 0 ||
		    rt_bound_tree( tp->tr_b.tb_right, r_min, r_max ) < 0 )
			return(-1);
		VMIN( tree_min, r_min );
		VMAX( tree_max, r_max );
		break;
	case OP_INTERSECT:
		/* BINARY type -- find common area only */
		if( rt_bound_tree( tp->tr_b.tb_left, tree_min, tree_max ) < 0 ||
		    rt_bound_tree( tp->tr_b.tb_right, r_min, r_max ) < 0 )
			return(-1);
		/* min = largest min, max = smallest max */
		VMAX( tree_min, r_min );
		VMIN( tree_max, r_max );
		break;
	case OP_SUBTRACT:
		/* BINARY type -- just use left tree */
		if( rt_bound_tree( tp->tr_b.tb_left, tree_min, tree_max ) < 0 ||
		    rt_bound_tree( tp->tr_b.tb_right, r_min, r_max ) < 0 )
			return(-1);
		/* Discard right rpp */
		break;
	case OP_NOP:
		/* Implies that this tree has nothing in it */
		break;
	}
	return(0);
}

/*
 *			R T _ T R E E _ K I L L _ D E A D _ S O L I D _ R E F S
 *
 *  Convert any references to "dead" solids into NOP nodes.
 */
void
rt_tree_kill_dead_solid_refs(register union tree *tp)
{	

	RT_CK_TREE(tp);

	switch( tp->tr_op )  {

	case OP_SOLID:
		{
			register struct soltab	*stp;

			stp = tp->tr_a.tu_stp;
			RT_CK_SOLTAB(stp);
			if( stp->st_aradius <= 0 )  {
				if(RT_G_DEBUG&DEBUG_TREEWALK)bu_log("rt_tree_kill_dead_solid_refs: encountered dead solid '%s' stp=x%x, tp=x%x\n",
					stp->st_dp->d_namep, stp, tp);
				rt_free_soltab(stp);
				tp->tr_a.tu_stp = SOLTAB_NULL;
				tp->tr_op = OP_NOP;	/* Convert to NOP */
			}
			return;
		}

	default:
		bu_log( "rt_tree_kill_dead_solid_refs(x%x): unknown op=x%x\n",
			tp, tp->tr_op );
		return;

	case OP_XOR:
	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
		/* BINARY */
		rt_tree_kill_dead_solid_refs( tp->tr_b.tb_left );
		rt_tree_kill_dead_solid_refs( tp->tr_b.tb_right );
		break;
	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
		/* UNARY tree -- for completeness only, should never be seen */
		rt_tree_kill_dead_solid_refs( tp->tr_b.tb_left );
		break;
	case OP_NOP:
		/* This sub-tree has nothing further in it */
		return;
	}
	return;
}

/*
 *			R T _ T R E E _ E L I M _ N O P S
 *
 *  Eliminate any references to NOP nodes from the tree.
 *  It is safe to use db_free_tree() here, because there will not
 *  be any dead solids.  They will all have been converted to OP_NOP
 *  nodes by rt_tree_kill_dead_solid_refs(), previously, so there
 *  is no need to worry about multiple db_free_tree()'s repeatedly
 *  trying to free one solid that has been instanced multiple times.
 *
 *  Returns -
 *	0	this node is OK.
 *	-1	request caller to kill this node
 */
int
rt_tree_elim_nops( register union tree *tp, struct resource *resp )
{
	union tree	*left, *right;

	RT_CK_RESOURCE(resp);
top:
	RT_CK_TREE(tp);

	switch( tp->tr_op )  {

	case OP_SOLID:
		return(0);		/* Retain */

	default:
		bu_log( "rt_tree_elim_nops(x%x): unknown op=x%x\n",
			tp, tp->tr_op );
		return(-1);

	case OP_XOR:
	case OP_UNION:
		/* BINARY type -- rewrite tp as surviving side */
		left = tp->tr_b.tb_left;
		right = tp->tr_b.tb_right;
		if( rt_tree_elim_nops( left, resp ) < 0 )  {
			*tp = *right;	/* struct copy */
			RT_FREE_TREE( left, resp );
			RT_FREE_TREE( right, resp );
			goto top;
		}
		if( rt_tree_elim_nops( right, resp ) < 0 )  {
			*tp = *left;	/* struct copy */
			RT_FREE_TREE( left, resp );
			RT_FREE_TREE( right, resp );
			goto top;
		}
		break;
	case OP_INTERSECT:
		/* BINARY type -- if either side fails, nuke subtree */
		left = tp->tr_b.tb_left;
		right = tp->tr_b.tb_right;
		if( rt_tree_elim_nops( left, resp ) < 0 ||
		    rt_tree_elim_nops( right, resp ) < 0 )  {
		    	db_free_tree( left, resp );
		    	db_free_tree( right, resp );
		    	tp->tr_op = OP_NOP;
		    	return(-1);	/* eliminate reference to tp */
		}
		break;
	case OP_SUBTRACT:
		/* BINARY type -- if right fails, rewrite (X - 0 = X).
		 *  If left fails, nuke entire subtree (0 - X = 0).
		 */
		left = tp->tr_b.tb_left;
		right = tp->tr_b.tb_right;
		if( rt_tree_elim_nops( left, resp ) < 0 )  {
		    	db_free_tree( left, resp );
		    	db_free_tree( right, resp );
		    	tp->tr_op = OP_NOP;
		    	return(-1);	/* eliminate reference to tp */
		}
		if( rt_tree_elim_nops( right, resp ) < 0 )  {
			*tp = *left;	/* struct copy */
			RT_FREE_TREE( left, resp );
			RT_FREE_TREE( right, resp );
			goto top;
		}
		break;
	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
		/* UNARY tree -- for completeness only, should never be seen */
		left = tp->tr_b.tb_left;
		if( rt_tree_elim_nops( left, resp ) < 0 )  {
			RT_FREE_TREE( left, resp );
			tp->tr_op = OP_NOP;
			return(-1);	/* Kill ref to unary op, too */
		}
		break;
	case OP_NOP:
		/* Implies that this tree has nothing in it */
		return(-1);		/* Kill ref to this NOP */
	}
	return(0);
}

/*
 *			R T _ B A S E N A M E
 *
 *  Given a string containing slashes such as a pathname, return a
 *  pointer to the first character after the last slash.
 */
const char *
rt_basename(register const char *str)
{	
	register const char	*p = str;
	while( *p != '\0' )
		if( *p++ == '/' )
			str = p;
	return	str;
}

/*
 *			R T _ G E T R E G I O N
 *
 *  Return a pointer to the corresponding region structure of the given
 *  region's name (reg_name), or REGION_NULL if it does not exist.
 *
 *  If the full path of a region is specified, then that one is
 *  returned.  However, if only the database node name of the
 *  region is specified and that region has been referenced multiple
 *  time in the tree, then this routine will simply return the first one.
 */
HIDDEN struct region *
rt_getregion(struct rt_i *rtip, register const char *reg_name)
{	
	register struct region	*regp;
	register const char *reg_base = rt_basename(reg_name);

	RT_CK_RTI(rtip);
	for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
		register const char	*cp;
		/* First, check for a match of the full path */
		if( *reg_base == regp->reg_name[0] &&
		    strcmp( reg_base, regp->reg_name ) == 0 )
			return(regp);
		/* Second, check for a match of the database node name */
		cp = rt_basename( regp->reg_name );
		if( *cp == *reg_name && strcmp( cp, reg_name ) == 0 )
			return(regp);
	}
	return(REGION_NULL);
}

/*
 *			R T _ R P P _ R E G I O N
 *
 *  Calculate the bounding RPP for a region given the name of
 *  the region node in the database.  See remarks in rt_getregion()
 *  above for name conventions.
 *  Returns 0 for failure (and prints a diagnostic), or 1 for success.
 */
int
rt_rpp_region(struct rt_i *rtip, const char *reg_name, fastf_t *min_rpp, fastf_t *max_rpp)
{	
	register struct region	*regp;

	RT_CHECK_RTI(rtip);

	regp = rt_getregion( rtip, reg_name );
	if( regp == REGION_NULL )  return(0);
	if( rt_bound_tree( regp->reg_treetop, min_rpp, max_rpp ) < 0)
		return(0);
	return(1);
}

/*
 *			R T _ F A S T F _ F L O A T
 *
 *  Convert TO fastf_t FROM 3xfloats (for database) 
 */
void
rt_fastf_float(register fastf_t *ff, register const dbfloat_t *fp, register int n)
{
#	include "noalias.h"
	while( n-- )  {
		*ff++ = *fp++;
		*ff++ = *fp++;
		*ff++ = *fp++;
		ff += ELEMENTS_PER_VECT-3;
	}
}

/*
 *			R T _ M A T _ D B M A T
 *
 *  Convert TO fastf_t matrix FROM dbfloats (for database) 
 */
void
rt_mat_dbmat(register fastf_t *ff, register const dbfloat_t *dbp)
{

	*ff++ = *dbp++;
	*ff++ = *dbp++;
	*ff++ = *dbp++;
	*ff++ = *dbp++;

	*ff++ = *dbp++;
	*ff++ = *dbp++;
	*ff++ = *dbp++;
	*ff++ = *dbp++;

	*ff++ = *dbp++;
	*ff++ = *dbp++;
	*ff++ = *dbp++;
	*ff++ = *dbp++;

	*ff++ = *dbp++;
	*ff++ = *dbp++;
	*ff++ = *dbp++;
	*ff++ = *dbp++;
}

/*
 *			R T _ D B M A T _ M A T
 *
 *  Convert FROM fastf_t matrix TO dbfloats (for updating database) 
 */
void
rt_dbmat_mat(register dbfloat_t *dbp, register const fastf_t *ff)
{

	*dbp++ = (dbfloat_t) *ff++;
	*dbp++ = (dbfloat_t) *ff++;
	*dbp++ = (dbfloat_t) *ff++;
	*dbp++ = (dbfloat_t) *ff++;

	*dbp++ = (dbfloat_t) *ff++;
	*dbp++ = (dbfloat_t) *ff++;
	*dbp++ = (dbfloat_t) *ff++;
	*dbp++ = (dbfloat_t) *ff++;

	*dbp++ = (dbfloat_t) *ff++;
	*dbp++ = (dbfloat_t) *ff++;
	*dbp++ = (dbfloat_t) *ff++;
	*dbp++ = (dbfloat_t) *ff++;

	*dbp++ = (dbfloat_t) *ff++;
	*dbp++ = (dbfloat_t) *ff++;
	*dbp++ = (dbfloat_t) *ff++;
	*dbp++ = (dbfloat_t) *ff++;
}

/*
 *  			R T _ F I N D _ S O L I D
 *  
 *  Given the (leaf) name of a solid, find the first occurance of it
 *  in the solid list.  Used mostly to find the light source.
 *  Returns soltab pointer, or RT_SOLTAB_NULL.
 */
struct soltab *
rt_find_solid(const struct rt_i *rtip, register const char *name)
{
	register struct soltab	*stp;
	struct directory	*dp;

	RT_CHECK_RTI(rtip);
	if( (dp = db_lookup( (struct db_i *)rtip->rti_dbip, (char *)name,
	    LOOKUP_QUIET )) == DIR_NULL )
		return(RT_SOLTAB_NULL);

	RT_VISIT_ALL_SOLTABS_START( stp, (struct rt_i *)rtip )  {
		if( stp->st_dp == dp )
			return(stp);
	} RT_VISIT_ALL_SOLTABS_END
	return(RT_SOLTAB_NULL);
}


/*
 *			R T _ O P T I M _ T R E E
 */
void
rt_optim_tree(register union tree *tp, struct resource *resp)
{
	register union tree	**sp;
	register union tree	*low;
	register union tree	**stackend;

	RT_CK_TREE(tp);
	while( (sp = resp->re_boolstack) == (union tree **)0 )
		rt_grow_boolstack( resp );
	stackend = &(resp->re_boolstack[resp->re_boolslen-1]);
	*sp++ = TREE_NULL;
	*sp++ = tp;
	while( (tp = *--sp) != TREE_NULL ) {
		switch( tp->tr_op )  {
		case OP_NOP:
			/* XXX Consider eliminating nodes of form (A op NOP) */
			/* XXX Needs to be detected in previous iteration */
			break;
		case OP_SOLID:
			break;
		case OP_SUBTRACT:
			while( (low=tp->tr_b.tb_left)->tr_op == OP_SUBTRACT )  {
				/* Rewrite X - A - B as X - ( A union B ) */
				tp->tr_b.tb_left = low->tr_b.tb_left;
				low->tr_op = OP_UNION;
				low->tr_b.tb_left = low->tr_b.tb_right;
				low->tr_b.tb_right = tp->tr_b.tb_right;
				tp->tr_b.tb_right = low;
			}
			/* push both nodes - search left first */
			*sp++ = tp->tr_b.tb_right;
			*sp++ = tp->tr_b.tb_left;
			if( sp >= stackend )  {
				register int off = sp - resp->re_boolstack;
				rt_grow_boolstack( resp );
				sp = &(resp->re_boolstack[off]);
				stackend = &(resp->re_boolstack[resp->re_boolslen-1]);
			}
			break;
		case OP_UNION:
		case OP_INTERSECT:
		case OP_XOR:
			/* Need to look at 3-level optimizations here, both sides */
			/* push both nodes - search left first */
			*sp++ = tp->tr_b.tb_right;
			*sp++ = tp->tr_b.tb_left;
			if( sp >= stackend )  {
				register int off = sp - resp->re_boolstack;
				rt_grow_boolstack( resp );
				sp = &(resp->re_boolstack[off]);
				stackend = &(resp->re_boolstack[resp->re_boolslen-1]);
			}
			break;
		default:
			bu_log("rt_optim_tree: bad op x%x\n", tp->tr_op);
			break;
		}
	}
}

/*
 *			R T _ T R E E _ R E G I O N _ A S S I G N
 */
HIDDEN void
rt_tree_region_assign(register union tree *tp, register const struct region *regionp)
{
	RT_CK_TREE(tp);
	RT_CK_REGION(regionp);
	switch( tp->tr_op )  {
	case OP_NOP:
		return;

	case OP_SOLID:
		tp->tr_a.tu_regionp = (struct region *)regionp;
		return;

	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
		tp->tr_b.tb_regionp = (struct region *)regionp;
		rt_tree_region_assign( tp->tr_b.tb_left, regionp );
		return;

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		tp->tr_b.tb_regionp = (struct region *)regionp;
		rt_tree_region_assign( tp->tr_b.tb_left, regionp );
		rt_tree_region_assign( tp->tr_b.tb_right, regionp );
		return;

	default:
		rt_bomb("rt_tree_region_assign: bad op\n");
	}
}
@


11.71
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/tree.c,v 11.70 2004/04/05 08:48:58 morrison Exp $ (ARL)";
@


11.70
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d27 5
a31 1
#include "conf.h"
@


11.69
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.68 2003/12/09 14:58:15 jra Exp $ (ARL)";
d46 2
a47 2
HIDDEN struct region *rt_getregion();
HIDDEN void	rt_tree_region_assign();
d138 5
a142 5
HIDDEN int rt_gettree_region_start( tsp, pathp, combp, client_data )
/*const*/ struct db_tree_state	*tsp;
/*const*/ struct db_full_path	*pathp;
const struct rt_comb_internal	*combp;
genptr_t			client_data;
d169 5
a173 5
HIDDEN union tree *rt_gettree_region_end( tsp, pathp, curtree, client_data )
register /*const*/ struct db_tree_state	*tsp;
/*const*/ struct db_full_path	*pathp;
union tree			*curtree;
genptr_t			client_data;
d335 1
a335 4
HIDDEN struct soltab *rt_find_identical_solid( mat, dp, rtip )
register const matp_t		mat;
register struct directory	*dp;
struct rt_i			*rtip;
d465 5
a469 5
HIDDEN union tree *rt_gettree_leaf( tsp, pathp, ip, client_data )
/*const*/ struct db_tree_state	*tsp;
struct db_full_path		*pathp;
/*const*/ struct rt_db_internal	*ip;
genptr_t			client_data;
d640 1
a640 2
rt_free_soltab( stp )
struct soltab	*stp;
d708 1
a708 6
rt_gettrees_muves( rtip, attrs, argc, argv, ncpus )
struct rt_i	*rtip;
const char	**attrs;
int		argc;
const char	**argv;
int		ncpus;
d888 1
a888 6
rt_gettrees_and_attrs( rtip, attrs, argc, argv, ncpus )
struct rt_i	*rtip;
const char	**attrs;
int		argc;
const char	**argv;
int		ncpus;
d907 1
a907 3
rt_gettree( rtip, node )
struct rt_i	*rtip;
const char	*node;
d924 1
a924 5
rt_gettrees( rtip, argc, argv, ncpus )
struct rt_i	*rtip;
int		argc;
const char	**argv;
int		ncpus;
d951 1
a951 4
rt_bound_tree( tp, tree_min, tree_max )
register const union tree	*tp;
vect_t				tree_min;
vect_t				tree_max;
d1024 1
a1024 2
rt_tree_kill_dead_solid_refs( tp )
register union tree	*tp;
d1180 1
a1180 2
rt_basename( str )
register const char	*str;
d1201 1
a1201 3
rt_getregion( rtip, reg_name )
struct rt_i		*rtip;
register const char	*reg_name;
d1230 1
a1230 4
rt_rpp_region( rtip, reg_name, min_rpp, max_rpp )
struct rt_i	*rtip;
const char	*reg_name;
fastf_t		*min_rpp, *max_rpp;
d1249 1
a1249 4
rt_fastf_float( ff, fp, n )
register fastf_t *ff;
register const dbfloat_t *fp;
register int n;
d1266 1
a1266 3
rt_mat_dbmat( ff, dbp )
register fastf_t *ff;
register const dbfloat_t *dbp;
d1296 1
a1296 3
rt_dbmat_mat( dbp, ff )
register dbfloat_t *dbp;
register const fastf_t *ff;
d1328 1
a1328 3
rt_find_solid( rtip, name )
const struct rt_i	*rtip;
register const char	*name;
d1350 1
a1350 3
rt_optim_tree( tp, resp )
register union tree	*tp;
struct resource		*resp;
d1414 1
a1414 3
rt_tree_region_assign( tp, regionp )
register union tree	*tp;
register const struct region	*regionp;
@


11.68
log
@Simplified attribut handling in rt_gettrees_muves()
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1995 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.67 2003/10/29 17:57:25 jra Exp $ (ARL)";
@


11.67
log
@rt_gettree_leaf() now adds new solids to the rtip->rti_new_solids list when
rtip->rti_add_to_new_solids_list is set. (for dynamic geometry)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.66 2003/04/07 12:46:28 jra Exp $ (ARL)";
d220 1
a220 2
		rp->reg_mater.ma_shader = (char *)bu_malloc( shader_len+1, "rt_gettree_region_end: ma_shader" );
		strcpy( rp->reg_mater.ma_shader, tsp->ts_mater.ma_shader );
d754 1
a754 1
                               tree_state.ts_attrs.count = 0;
d759 13
a771 5
			       bu_avs_init( &tree_state.ts_attrs, num_attrs, "avs in tree_state" );
			       num_attrs = 0;
			       while( attrs[num_attrs] ) {
				       tree_state.ts_attrs.avp[num_attrs].name = bu_strdup( attrs[num_attrs] );
				       num_attrs++;
a772 1
			       tree_state.ts_attrs.count = num_attrs;
d775 1
a775 1
			tree_state.ts_attrs.count = 0;
a777 3
		if( num_attrs == 0 )
			bu_avs_init( &tree_state.ts_attrs, 1, "avs in tree_state" );

a789 1

@


11.66
log
@Model bounding box now encloses entire primitive for primitives using "pieces"
Needed to get "pieces" to work correctly
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.65 2002/08/20 17:08:10 jra Exp $ (ARL)";
d519 4
@


11.66.6.1
log
@updates from HEAD, part 1
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.67 2003/10/29 17:57:25 jra Exp $ (ARL)";
a518 4
	}

	if( rtip->rti_add_to_new_solids_list ) {
		bu_ptbl_ins( &rtip->rti_new_solids, (long *)stp );
@


11.66.6.2
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.69 2004/02/02 17:39:29 morrison Exp $ (ARL)";
d220 2
a221 1
		rp->reg_mater.ma_shader = bu_strdup( tsp->ts_mater.ma_shader );
d755 1
a755 1
			       bu_avs_init_empty( &tree_state.ts_attrs );
d760 5
a764 13
			       if( num_attrs ) {
				       bu_avs_init( &tree_state.ts_attrs,
						    num_attrs,
						    "avs in tree_state" );
				       num_attrs = 0;
				       while( attrs[num_attrs] ) {
					       bu_avs_add( &tree_state.ts_attrs,
							   attrs[num_attrs],
							   NULL );
					       num_attrs++;
				       }
			       } else {
				       bu_avs_init_empty( &tree_state.ts_attrs );
d766 1
d769 1
a769 1
			bu_avs_init_empty( &tree_state.ts_attrs );
d772 3
d787 1
@


11.66.6.3
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.66.6.2 2004/02/12 18:37:47 erikg Exp $ (ARL)";
@


11.65
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.63 2002/05/28 13:31:48 jra Exp $ (ARL)";
d823 3
@


11.65.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/tree.c,v 11.69 2004/02/02 17:39:29 morrison Exp $ (ARL)";
d220 2
a221 1
		rp->reg_mater.ma_shader = bu_strdup( tsp->ts_mater.ma_shader );
a520 4
	if( rtip->rti_add_to_new_solids_list ) {
		bu_ptbl_ins( &rtip->rti_new_solids, (long *)stp );
	}

d751 1
a751 1
			       bu_avs_init_empty( &tree_state.ts_attrs );
d756 5
a760 13
			       if( num_attrs ) {
				       bu_avs_init( &tree_state.ts_attrs,
						    num_attrs,
						    "avs in tree_state" );
				       num_attrs = 0;
				       while( attrs[num_attrs] ) {
					       bu_avs_add( &tree_state.ts_attrs,
							   attrs[num_attrs],
							   NULL );
					       num_attrs++;
				       }
			       } else {
				       bu_avs_init_empty( &tree_state.ts_attrs );
d762 1
d765 1
a765 1
			bu_avs_init_empty( &tree_state.ts_attrs );
d768 3
d783 1
a822 3
			/* all pieces must be within model bounding box for pieces to work correctly */
			VMINMAX( rtip->mdl_min, rtip->mdl_max, stp->st_min );
			VMINMAX( rtip->mdl_min, rtip->mdl_max, stp->st_max );
@


11.65.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.65 2002/08/20 17:08:10 jra Exp $ (ARL)";
d46 2
a47 2
HIDDEN struct region *rt_getregion(struct rt_i *rtip, register const char *reg_name);
HIDDEN void	rt_tree_region_assign(register union tree *tp, register const struct region *regionp);
d138 5
a142 5
HIDDEN int rt_gettree_region_start(struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
/*const*/                     	     
/*const*/                    	       
                             	       
        			            
d169 5
a173 5
HIDDEN union tree *rt_gettree_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
         /*const*/                     	     
/*const*/                    	       
          			         
        			            
d336 4
a339 1
HIDDEN struct soltab *rt_find_identical_solid(register const matp_t mat, register struct directory *dp, struct rt_i *rtip)
d469 5
a473 5
HIDDEN union tree *rt_gettree_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
/*const*/                     	     
                   		       
/*const*/                      	    
        			            
d640 2
a641 1
rt_free_soltab(struct soltab *stp)
d709 6
a714 1
rt_gettrees_muves(struct rt_i *rtip, const char **attrs, int argc, const char **argv, int ncpus)
d888 6
a893 1
rt_gettrees_and_attrs(struct rt_i *rtip, const char **attrs, int argc, const char **argv, int ncpus)
d912 3
a914 1
rt_gettree(struct rt_i *rtip, const char *node)
d931 5
a935 1
rt_gettrees(struct rt_i *rtip, int argc, const char **argv, int ncpus)
d962 4
a965 1
rt_bound_tree(register const union tree *tp, fastf_t *tree_min, fastf_t *tree_max)
d1038 2
a1039 1
rt_tree_kill_dead_solid_refs(register union tree *tp)
d1195 2
a1196 1
rt_basename(register const char *str)
d1217 3
a1219 1
rt_getregion(struct rt_i *rtip, register const char *reg_name)
d1248 4
a1251 1
rt_rpp_region(struct rt_i *rtip, const char *reg_name, fastf_t *min_rpp, fastf_t *max_rpp)
d1270 4
a1273 1
rt_fastf_float(register fastf_t *ff, register const dbfloat_t *fp, register int n)
d1290 3
a1292 1
rt_mat_dbmat(register fastf_t *ff, register const dbfloat_t *dbp)
d1322 3
a1324 1
rt_dbmat_mat(register dbfloat_t *dbp, register const fastf_t *ff)
d1356 3
a1358 1
rt_find_solid(const struct rt_i *rtip, register const char *name)
d1380 3
a1382 1
rt_optim_tree(register union tree *tp, struct resource *resp)
d1446 3
a1448 1
rt_tree_region_assign(register union tree *tp, register const struct region *regionp)
@


11.65.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d220 2
a221 1
		rp->reg_mater.ma_shader = bu_strdup( tsp->ts_mater.ma_shader );
a517 4
	if( rtip->rti_add_to_new_solids_list ) {
		bu_ptbl_ins( &rtip->rti_new_solids, (long *)stp );
	}

d742 1
a742 1
			       bu_avs_init_empty( &tree_state.ts_attrs );
d747 5
a751 13
			       if( num_attrs ) {
				       bu_avs_init( &tree_state.ts_attrs,
						    num_attrs,
						    "avs in tree_state" );
				       num_attrs = 0;
				       while( attrs[num_attrs] ) {
					       bu_avs_add( &tree_state.ts_attrs,
							   attrs[num_attrs],
							   NULL );
					       num_attrs++;
				       }
			       } else {
				       bu_avs_init_empty( &tree_state.ts_attrs );
d753 1
d756 1
a756 1
			bu_avs_init_empty( &tree_state.ts_attrs );
d759 3
d774 1
a813 3
			/* all pieces must be within model bounding box for pieces to work correctly */
			VMINMAX( rtip->mdl_min, rtip->mdl_max, stp->st_min );
			VMINMAX( rtip->mdl_min, rtip->mdl_max, stp->st_max );
@


11.64
log
@Converted from K&R to ANSI C - RFH
@
text
@d46 2
a47 2
HIDDEN struct region *rt_getregion(struct rt_i *rtip, register const char *reg_name);
HIDDEN void	rt_tree_region_assign(register union tree *tp, register const struct region *regionp);
d138 5
a142 5
HIDDEN int rt_gettree_region_start(struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
/*const*/                     	     
/*const*/                    	       
                             	       
        			            
d169 5
a173 5
HIDDEN union tree *rt_gettree_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
         /*const*/                     	     
/*const*/                    	       
          			         
        			            
d336 4
a339 1
HIDDEN struct soltab *rt_find_identical_solid(register const matp_t mat, register struct directory *dp, struct rt_i *rtip)
d469 5
a473 5
HIDDEN union tree *rt_gettree_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
/*const*/                     	     
                   		       
/*const*/                      	    
        			            
d640 2
a641 1
rt_free_soltab(struct soltab *stp)
d709 6
a714 1
rt_gettrees_muves(struct rt_i *rtip, const char **attrs, int argc, const char **argv, int ncpus)
d888 6
a893 1
rt_gettrees_and_attrs(struct rt_i *rtip, const char **attrs, int argc, const char **argv, int ncpus)
d912 3
a914 1
rt_gettree(struct rt_i *rtip, const char *node)
d931 5
a935 1
rt_gettrees(struct rt_i *rtip, int argc, const char **argv, int ncpus)
d962 4
a965 1
rt_bound_tree(register const union tree *tp, fastf_t *tree_min, fastf_t *tree_max)
d1038 2
a1039 1
rt_tree_kill_dead_solid_refs(register union tree *tp)
d1195 2
a1196 1
rt_basename(register const char *str)
d1217 3
a1219 1
rt_getregion(struct rt_i *rtip, register const char *reg_name)
d1248 4
a1251 1
rt_rpp_region(struct rt_i *rtip, const char *reg_name, fastf_t *min_rpp, fastf_t *max_rpp)
d1270 4
a1273 1
rt_fastf_float(register fastf_t *ff, register const dbfloat_t *fp, register int n)
d1290 3
a1292 1
rt_mat_dbmat(register fastf_t *ff, register const dbfloat_t *dbp)
d1322 3
a1324 1
rt_dbmat_mat(register dbfloat_t *dbp, register const fastf_t *ff)
d1356 3
a1358 1
rt_find_solid(const struct rt_i *rtip, register const char *name)
d1380 3
a1382 1
rt_optim_tree(register union tree *tp, struct resource *resp)
d1446 3
a1448 1
rt_tree_region_assign(register union tree *tp, register const struct region *regionp)
@


11.63
log
@rt_gettrees_muves() now checks database version before trying to accesss attributes
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.62 2002/02/20 15:55:38 jra Exp $ (ARL)";
d46 2
a47 2
HIDDEN struct region *rt_getregion();
HIDDEN void	rt_tree_region_assign();
d138 5
a142 5
HIDDEN int rt_gettree_region_start( tsp, pathp, combp, client_data )
/*const*/ struct db_tree_state	*tsp;
/*const*/ struct db_full_path	*pathp;
const struct rt_comb_internal	*combp;
genptr_t			client_data;
d169 5
a173 5
HIDDEN union tree *rt_gettree_region_end( tsp, pathp, curtree, client_data )
register /*const*/ struct db_tree_state	*tsp;
/*const*/ struct db_full_path	*pathp;
union tree			*curtree;
genptr_t			client_data;
d336 1
a336 4
HIDDEN struct soltab *rt_find_identical_solid( mat, dp, rtip )
register const matp_t		mat;
register struct directory	*dp;
struct rt_i			*rtip;
d466 5
a470 5
HIDDEN union tree *rt_gettree_leaf( tsp, pathp, ip, client_data )
/*const*/ struct db_tree_state	*tsp;
struct db_full_path		*pathp;
/*const*/ struct rt_db_internal	*ip;
genptr_t			client_data;
d637 1
a637 2
rt_free_soltab( stp )
struct soltab	*stp;
d705 1
a705 6
rt_gettrees_muves( rtip, attrs, argc, argv, ncpus )
struct rt_i	*rtip;
const char	**attrs;
int		argc;
const char	**argv;
int		ncpus;
d879 1
a879 6
rt_gettrees_and_attrs( rtip, attrs, argc, argv, ncpus )
struct rt_i	*rtip;
const char	**attrs;
int		argc;
const char	**argv;
int		ncpus;
d898 1
a898 3
rt_gettree( rtip, node )
struct rt_i	*rtip;
const char	*node;
d915 1
a915 5
rt_gettrees( rtip, argc, argv, ncpus )
struct rt_i	*rtip;
int		argc;
const char	**argv;
int		ncpus;
d942 1
a942 4
rt_bound_tree( tp, tree_min, tree_max )
register const union tree	*tp;
vect_t				tree_min;
vect_t				tree_max;
d1015 1
a1015 2
rt_tree_kill_dead_solid_refs( tp )
register union tree	*tp;
d1171 1
a1171 2
rt_basename( str )
register const char	*str;
d1192 1
a1192 3
rt_getregion( rtip, reg_name )
struct rt_i		*rtip;
register const char	*reg_name;
d1221 1
a1221 4
rt_rpp_region( rtip, reg_name, min_rpp, max_rpp )
struct rt_i	*rtip;
const char	*reg_name;
fastf_t		*min_rpp, *max_rpp;
d1240 1
a1240 4
rt_fastf_float( ff, fp, n )
register fastf_t *ff;
register const dbfloat_t *fp;
register int n;
d1257 1
a1257 3
rt_mat_dbmat( ff, dbp )
register fastf_t *ff;
register const dbfloat_t *dbp;
d1287 1
a1287 3
rt_dbmat_mat( dbp, ff )
register dbfloat_t *dbp;
register const fastf_t *ff;
d1319 1
a1319 3
rt_find_solid( rtip, name )
const struct rt_i	*rtip;
register const char	*name;
d1341 1
a1341 3
rt_optim_tree( tp, resp )
register union tree	*tp;
struct resource		*resp;
d1405 1
a1405 3
rt_tree_region_assign( tp, regionp )
register union tree	*tp;
register const struct region	*regionp;
@


11.62
log
@Needed to free tree_state.ts_attrs to avoid a minor memory leak
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.61 2002/02/18 20:11:13 jra Exp $ (ARL)";
d749 17
a765 10
			while( attrs[num_attrs] ) {
				num_attrs++;
			}
			bu_avs_init( &tree_state.ts_attrs, num_attrs, "avs in tree_state" );
			num_attrs = 0;
			while( attrs[num_attrs] ) {
				tree_state.ts_attrs.avp[num_attrs].name = bu_strdup( attrs[num_attrs] );
				num_attrs++;
			}
			tree_state.ts_attrs.count = num_attrs;
@


11.61
log
@Ifdef'd out the "ORCA_comp" initialization for now
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.60 2002/01/10 18:12:41 butler Exp $ (ARL)";
d752 1
a752 1
			bu_avs_init( &tree_state.ts_attrs, num_attrs, "tree_state" );
d762 1
a762 1
			bu_avs_init( &tree_state.ts_attrs, 1, "tree_state" );
d777 1
a777 2
		if( attrs )
			bu_avs_free( &tree_state.ts_attrs );
@


11.60
log
@Changed word "solids" to indicate "prims" or primitives"
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.59 2001/11/09 16:30:15 rbowers Exp $ (ARL)";
d763 6
d770 1
a770 1

@


11.59
log
@-* extended the behavior of db_walk_tree. Previously it would return -1
   iff absolutely no geometry could be loaded. It now returns -2 if
   some geometry could be loaded, but there were unresolved names.
-* rt_gettrees_muves supports the -2, it is passed to the caller.
-* rt_gettree and rt_gettrees filter the -2 and return 0 for
   backward compatibility.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.58 2001/11/05 21:20:06 morrison Exp $ (ARL)";
d852 1
a852 1
		bu_log("rt_gettrees(%s) warning:  no solids found\n", argv[0]);
@


11.58
log
@Solid to Primitive naming convention conversions
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.57 2001/11/01 21:38:35 bparker Exp $ (ARL)";
d849 1
a849 1
	if( i < 0 )  return(-1);
d873 1
d896 2
d904 12
a915 1
	return( rt_gettrees_and_attrs( rtip, NULL, 1, &node, 1 ) );
d925 11
a935 1
	return( rt_gettrees_and_attrs( rtip, NULL, argc, argv, ncpus ) );
@


11.57
log
@*- added a "struct db_i *" parameter to ft_describe
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.56 2001/06/22 20:41:49 jra Exp $ (ARL)";
d594 1
a594 1
		bu_log("\n---Solid %d: %s\n", stp->st_bit, dp->d_namep);
@


11.56
log
@ORCA hash table is now stashed in the rt_i structure
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.55 2001/05/29 18:57:46 jra Exp $ (ARL)";
d597 1
a597 1
		if( stp->st_meth->ft_describe( &str, ip, 1, 1.0, tsp->ts_resp ) < 0 )  {
@


11.55
log
@Changed "ORCA_comp" to "ORCA_Comp"
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.54 2001/05/17 20:05:25 morrison Exp $ (ARL)";
d684 1
a684 1
 *  for use with the ORCA man regions.
a699 2
 *	tbl	- Uninitialized Tcl_HashTable to hold matrices for transforming hits
 *		  on regions with a non-NULL "ORCA_Comp" attribute to the standard ORCA standing man
d709 1
a709 1
rt_gettrees_muves( rtip, attrs, tbl, argc, argv, ncpus )
a711 1
Tcl_HashTable	*tbl;
d718 1
d734 3
a736 2
	if( tbl )
		Tcl_InitHashTable( tbl, TCL_ONE_WORD_KEYS );
d761 3
a763 5
		if( tbl ) {
			if( num_attrs == 0 )
				bu_avs_init( &tree_state.ts_attrs, 1, "tree_state" );
			bu_avs_add( &tree_state.ts_attrs, "ORCA_Comp", (char *)NULL );
		}
d882 1
a882 1
	return( rt_gettrees_muves( rtip, attrs, NULL, argc, argv, ncpus ) );
@


11.54
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.53 2001/05/17 19:07:15 jra Exp $ (ARL)";
d257 1
a257 1
	if( tbl && bu_avs_get( &tsp->ts_attrs, "ORCA_comp" ) ) {
d701 1
a701 1
 *		  on regions with a non-NULL "ORCA_comp" attribute to the standard ORCA standing man
d765 1
a765 1
			bu_avs_add( &tree_state.ts_attrs, "ORCA_comp", (char *)NULL );
@


11.53
log
@Added rt_gettrees_muves() to do attributes and ORCA stuff for MUVES
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.52 2001/05/14 20:54:55 jra Exp $ (ARL)";
d230 1
a230 1
	if(rt_g.debug&DEBUG_TREEWALK)  {
d274 1
a274 1
	if( rt_g.debug & DEBUG_REGIONS )  {
d397 1
a397 1
			if( rt_g.debug & DEBUG_SOLIDS )  {
d586 1
a586 1
	if(rt_g.debug&DEBUG_TREEWALK && stp->st_path.magic == DB_FULL_PATH_MAGIC)  {
d592 1
a592 1
	if(rt_g.debug&DEBUG_SOLIDS)  {
d613 1
a613 1
	if(rt_g.debug&DEBUG_TREEWALK)  {
d816 1
a816 1
		if(rt_g.debug&DEBUG_SOLIDS)
d1020 1
a1020 1
				if(rt_g.debug&DEBUG_TREEWALK)bu_log("rt_tree_kill_dead_solid_refs: encountered dead solid '%s' stp=x%x, tp=x%x\n",
@


11.52
log
@Fixed a memory leak in rt_gettrees_and_attrs()
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.51 2001/05/08 20:18:55 jra Exp $ (ARL)";
d180 3
d257 17
d679 1
a679 2
/*
 *  			R T _ G E T T R E E S _ A N D _ A T T R S
d683 3
d694 11
d711 1
a711 1
rt_gettrees_and_attrs( rtip, attrs, argc, argv, ncpus )
d714 1
d736 3
d761 7
d772 1
a772 1
				  rt_gettree_leaf, (genptr_t)NULL );
d857 29
@


11.51
log
@Added support for attributes in the region structures
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.50 2001/04/20 22:29:57 morrison Exp $ (ARL)";
d729 3
@


11.50
log
@CONST to const
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.49 2001/04/02 21:38:10 morrison Exp $ (ARL)";
d77 14
d179 1
d200 12
d660 1
a660 20
 *  			R T _ G E T T R E E
 *
 *  User-called function to add a tree hierarchy to the displayed set.
 *
 *  This function is not multiply re-entrant.
 *  
 *  Returns -
 *  	0	Ordinarily
 *	-1	On major error
 */
int
rt_gettree( rtip, node )
struct rt_i	*rtip;
const char	*node;
{
	return( rt_gettrees( rtip, 1, &node, 1 ) );
}

/*
 *  			R T _ G E T T R E E S
d678 1
a678 1
rt_gettrees( rtip, argc, argv, ncpus )
d680 1
d689 1
d712 12
d725 4
a728 4
			&tree_state,
			rt_gettree_region_start,
			rt_gettree_region_end,
			rt_gettree_leaf, (genptr_t)NULL );
d810 29
@


11.49
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.48 2000/09/09 04:30:48 mike Exp $ (ARL)";
d53 1
a53 1
CONST struct db_tree_state	rt_initial_tree_state = {
d125 3
a127 3
/*CONST*/ struct db_tree_state	*tsp;
/*CONST*/ struct db_full_path	*pathp;
CONST struct rt_comb_internal	*combp;
d156 2
a157 2
register /*CONST*/ struct db_tree_state	*tsp;
/*CONST*/ struct db_full_path	*pathp;
d290 1
a290 1
register CONST matp_t		mat;
d423 1
a423 1
/*CONST*/ struct db_tree_state	*tsp;
d425 1
a425 1
/*CONST*/ struct rt_db_internal	*ip;
d646 1
a646 1
CONST char	*node;
d673 1
a673 1
CONST char	**argv;
d803 1
a803 1
register CONST union tree	*tp;
d815 1
a815 1
			register CONST struct soltab	*stp;
d1034 1
a1034 1
CONST char *
d1036 1
a1036 1
register CONST char	*str;
d1038 1
a1038 1
	register CONST char	*p = str;
d1059 1
a1059 1
register CONST char	*reg_name;
d1062 1
a1062 1
	register CONST char *reg_base = rt_basename(reg_name);
d1066 1
a1066 1
		register CONST char	*cp;
d1090 1
a1090 1
CONST char	*reg_name;
d1112 1
a1112 1
register CONST dbfloat_t *fp;
d1132 1
a1132 1
register CONST dbfloat_t *dbp;
d1164 1
a1164 1
register CONST fastf_t *ff;
d1197 2
a1198 2
CONST struct rt_i	*rtip;
register CONST char	*name;
d1288 1
a1288 1
register CONST struct region	*regionp;
@


11.48
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.47 2000/09/08 05:54:43 mike Exp $ (ARL)";
d381 1
a381 1
		bn_mat_copy( stp->st_matp, mat );
@


11.47
log
@
Modified tree routines to take resource pointer.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.46 2000/07/14 15:02:43 jra Exp $ (ARL)";
d54 1
d435 1
d550 1
a550 1
		if( stp->st_meth->ft_describe( &str, ip, 1, 1.0 ) < 0 )  {
@


11.46
log
@Initialization of matrix in a db_tree_state structure was incorrectly formatted
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.45 2000/07/13 02:36:27 cjohnson Exp $ (ARL)";
a44 2
RT_EXTERN(CONST char *	rt_basename, (CONST char *str));
int		rt_bound_tree();	/* used by rt/sh_light.c */
a47 1
int rt_tree_elim_nops(register union tree *);
d83 2
a84 1
	NULL				/* ts_rtip */
d130 1
d170 1
d439 1
d557 1
a557 1
	BU_GETUNION( curtree, tree );
a675 1
	struct db_tree_state	tree_state;
d692 14
a705 9
	tree_state = rt_initial_tree_state;	/* struct copy */
	tree_state.ts_dbip = rtip->rti_dbip;
	tree_state.ts_rtip = rtip;

	i = db_walk_tree( rtip->rti_dbip, argc, argv, ncpus,
		&tree_state,
		rt_gettree_region_start,
		rt_gettree_region_end,
		rt_gettree_leaf, (genptr_t)NULL );
d721 1
a721 1
		(void)rt_tree_elim_nops( regp->reg_treetop );
d941 2
a942 3
rt_tree_elim_nops( tp )
register union tree	*tp;
{	
d944 2
d964 1
a964 1
		if( rt_tree_elim_nops( left ) < 0 )  {
d966 2
a967 2
			bu_free( (char *)left, "rt_tree_elim_nops union tree");
			bu_free( (char *)right, "rt_tree_elim_nops union tree");
d970 1
a970 1
		if( rt_tree_elim_nops( right ) < 0 )  {
d972 2
a973 2
			bu_free( (char *)left, "rt_tree_elim_nops union tree");
			bu_free( (char *)right, "rt_tree_elim_nops union tree");
d981 4
a984 4
		if( rt_tree_elim_nops( left ) < 0 ||
		    rt_tree_elim_nops( right ) < 0 )  {
		    	db_free_tree( left );
		    	db_free_tree( right );
d995 3
a997 3
		if( rt_tree_elim_nops( left ) < 0 )  {
		    	db_free_tree( left );
		    	db_free_tree( right );
d1001 1
a1001 1
		if( rt_tree_elim_nops( right ) < 0 )  {
d1003 2
a1004 2
			bu_free( (char *)left, "rt_tree_elim_nops union tree");
			bu_free( (char *)right, "rt_tree_elim_nops union tree");
d1013 2
a1014 2
		if( rt_tree_elim_nops( left ) < 0 )  {
			bu_free( (char *)left, "rt_tree_elim_nops union tree");
@


11.45
log
@LINT from gcc -Wall
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.44 2000/07/10 23:01:51 mike Exp $ (ARL)";
d74 4
a77 4
	{1.0, 0.0, 0.0, 0.0},
	{0.0, 1.0, 0.0, 0.0},
	{0.0, 0.0, 1.0, 0.0},
	{0.0, 0.0, 0.0, 1.0},
@


11.44
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.43 2000/06/27 17:36:09 mike Exp $ (ARL)";
d50 1
a50 1

d64 1
a64 1
		1.0, 1.0, 1.0,		/* color, RGB */
d74 4
a77 4
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0,
@


11.43
log
@
Modified calling sequence to leaf node callback for db_recurse()
and db_walk_tree().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.42 2000/04/15 02:04:42 mike Exp $ (ARL)";
@


11.42
log
@
Code to suport solid 'pieces'.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.41 2000/04/12 02:34:38 mike Exp $ (ARL)";
d421 1
a421 1
HIDDEN union tree *rt_gettree_leaf( tsp, pathp, ep, id, client_data )
d424 1
a424 2
/*CONST*/ struct bu_external	*ep;
int				id;
a429 1
	struct rt_db_internal	intern;
d436 1
a436 1
	BU_CK_EXTERNAL(ep);
d471 2
a472 2
	stp->st_id = id;
	stp->st_meth = &rt_functab[id];
d479 1
a479 17
	/*
	 *  Import geometry from on-disk (external) format to internal.
	 */
    	RT_INIT_DB_INTERNAL(&intern);
	if( stp->st_meth->ft_import( &intern, ep, mat, tsp->ts_dbip ) < 0 )  {
		int	hash;
		bu_log("rt_gettree_leaf(%s):  solid import failure\n", dp->d_namep );
	    	if( intern.idb_ptr )  stp->st_meth->ft_ifree( &intern );
		/* Too late to delete soltab entry; mark it as "dead" */
		hash = db_dirhash( dp->d_namep );
		ACQUIRE_SEMAPHORE_TREE(hash);
		stp->st_aradius = -1;
		stp->st_uses--;
		RELEASE_SEMAPHORE_TREE(hash);
		return( TREE_NULL );		/* BAD */
	}
	RT_CK_DB_INTERNAL( &intern );
d490 1
a490 1
	if( stp->st_meth->ft_prep( stp, &intern, rtip ) )  {
a493 1
	    	if( intern.idb_ptr )  stp->st_meth->ft_ifree( &intern );
d547 1
a547 1
		if( stp->st_meth->ft_describe( &str, &intern, 1, 1.0 ) < 0 )  {
a553 3

	/* Release internal version */
    	if( intern.idb_ptr )  stp->st_meth->ft_ifree( &intern );
@


11.41
log
@
NT port, non-compat4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.40 2000/03/04 05:53:46 mike Exp $ (ARL)";
d750 11
@


11.40
log
@
Added support for FASTGEN PLATE and VOLUME mode regions,
which are special cases of the orginary BRL-CAD region.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.39 2000/03/03 01:32:49 mike Exp $ (ARL)";
d1170 19
a1188 19
	*dbp++ = *ff++;
	*dbp++ = *ff++;
	*dbp++ = *ff++;
	*dbp++ = *ff++;

	*dbp++ = *ff++;
	*dbp++ = *ff++;
	*dbp++ = *ff++;
	*dbp++ = *ff++;

	*dbp++ = *ff++;
	*dbp++ = *ff++;
	*dbp++ = *ff++;
	*dbp++ = *ff++;

	*dbp++ = *ff++;
	*dbp++ = *ff++;
	*dbp++ = *ff++;
	*dbp++ = *ff++;
@


11.39
log
@
Functions modified to match prototype exactly.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.38 2000/02/01 20:57:28 mike Exp $ (ARL)";
d78 9
d180 1
@


11.38
log
@
Performance enhancement for case where boolean tree is all unions.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.37 2000/01/29 04:16:31 mike Exp $ (ARL)";
d117 2
a118 2
CONST struct db_tree_state	*tsp;
CONST struct db_full_path	*pathp;
d147 2
a148 2
register CONST struct db_tree_state	*tsp;
CONST struct db_full_path	*pathp;
d412 1
a412 1
CONST struct db_tree_state	*tsp;
d414 1
a414 1
CONST struct bu_external	*ep;
@


11.37
log
@
Removed accidental #if 0 block.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.36 2000/01/22 03:31:51 mike Exp $ (ARL)";
d195 1
@


11.36
log
@
RT_SEM_STATS is used for rt_gettrees(), so the
recursive invocation in db_shader_mat() needed to use a different
semaphore.  RT_SEM_MODEL was available.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.35 2000/01/14 22:17:37 mike Exp $ (ARL)";
a549 1
#if 0
a561 1
#endif
@


11.35
log
@
Fixed problem that was causing BU_ASSERT failure in prep for
Mike Caruso and the 225,000 submodel Ft. APHill database.
incrementing nsolids needs to be in a special critical section.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.34 2000/01/13 04:08:31 mike Exp $ (ARL)";
d670 2
a671 2
 *	RT_SEM_MODEL	protects rti_solidheads[] lists
 *	RT_SEM_RESULTS	protects HeadRegion, mdl_min/max, d_uses, nregions
d673 1
@


11.34
log
@
Speedups for the million tree case.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.33 2000/01/04 17:58:20 bparker Exp $ (ARL)";
a282 1
	int			have_match;
a287 1
	have_match = 0;
d328 20
a347 2
			have_match = 1;
			break;
d351 19
a369 16
	if( have_match )  {
		/*
		 *  stp now points to re-referenced solid.
		 *  stp->st_id is non-zero, indicating pre-existing solid.
		 */
		RT_CK_SOLTAB(stp);		/* sanity */
		/* Only increment use counter for non-dead solids. */
		if( !(stp->st_aradius <= -1) )
			stp->st_uses++;
		/* dp->d_uses is NOT incremented, because number of soltab's using it has not gone up. */
		if( rt_g.debug & DEBUG_SOLIDS )  {
			bu_log( mat ?
			    "rt_find_identical_solid:  %s re-referenced %d\n" :
			    "rt_find_identical_solid:  %s re-referenced %d (identity mat)\n",
				dp->d_namep, stp->st_uses );
		}
d371 2
a372 27
		/*
		 *  Create and link a new solid into the list.
		 *  Ensure the search keys "dp" and "mat" are stored now.
		 */
		BU_GETSTRUCT(stp, soltab);
		stp->l.magic = RT_SOLTAB_MAGIC;
		stp->l2.magic = RT_SOLTAB2_MAGIC;
		stp->st_rtip = rtip;
		stp->st_uses = 1;
		stp->st_dp = dp;
		dp->d_uses++;
		stp->st_bit = rtip->nsolids++;
		/* stp->st_id is intentionally left zero here, as a flag */

		if( mat )  {
			stp->st_matp = (matp_t)bu_malloc( sizeof(mat_t), "st_matp" );
			bn_mat_copy( stp->st_matp, mat );
		} else {
			stp->st_matp = (matp_t)0;
		}
		/* Add to the appropriate soltab list head */
		/* PARALLEL NOTE:  Uses critical section on rt_solidheads element */
		BU_LIST_INSERT( &(rtip->rti_solidheads[hash]), &(stp->l) );

		/* Also add to the directory structure list head */
		/* PARALLEL NOTE:  Uses critical section on this 'dp' */
		BU_LIST_INSERT( &dp->d_use_hd, &(stp->l2) );
d374 7
a380 3
		/* Tables of regions using this solid.  Usually small. */
		bu_ptbl_init( &stp->st_regions, 7, "st_regions ptbl" );
	}
d382 3
a384 1
	/* Leave the appropriate dual critical-section */
d386 14
@


11.33
log
@*- add client_data to db_walk_tree
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.32 1999/12/23 06:00:05 mike Exp $ (ARL)";
d295 10
a304 2
	/* If solid has not been referenced yet, the search can be skipped */
	if( dp->d_uses > 0 && rtip->rti_dont_instance == 0 )  {
@


11.32
log
@
struct region is now a bu_list
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.31 1999/11/17 02:42:04 mike Exp $ (ARL)";
d116 1
a116 1
HIDDEN int rt_gettree_region_start( tsp, pathp, combp )
d120 1
d146 1
a146 1
HIDDEN union tree *rt_gettree_region_end( tsp, pathp, curtree )
d150 1
d388 1
a388 1
HIDDEN union tree *rt_gettree_leaf( tsp, pathp, ep, id )
d393 1
d690 1
a690 1
		rt_gettree_leaf );
@


11.31
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.30 1999/07/02 22:19:25 mike Exp $ (ARL)";
d167 1
a167 2
	rp->reg_magic = RT_REGION_MAGIC;
	rp->reg_forw = REGION_NULL;
d208 1
a208 2
	rp->reg_forw = rtip->HeadRegion;
	rtip->HeadRegion = rp;
d690 1
a690 1
	for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
d700 1
a700 1
	for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
d723 1
a723 1
	for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
d747 1
a747 1
	for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
d1029 1
a1029 1
	register struct region	*regp = rtip->HeadRegion;
d1033 1
a1033 1
	for( ; regp != REGION_NULL; regp = regp->reg_forw )  {	
@


11.30
log
@
Removed dependence on compat4.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.29 1999/05/27 18:57:13 mike Exp $ (ARL)";
d440 1
d451 1
a451 1
	if( rt_functab[id].ft_import( &intern, ep, mat, tsp->ts_dbip ) < 0 )  {
d454 1
a454 1
	    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
d474 1
a474 1
	if( rt_functab[id].ft_prep( stp, &intern, rtip ) )  {
d478 1
a478 1
	    	if( intern.idb_ptr )  rt_functab[stp->st_id].ft_ifree( &intern );
d533 1
a533 1
		if( rt_functab[stp->st_id].ft_describe( &str, &intern, 1, 1.0 ) < 0 )  {
d543 1
a543 1
    	if( intern.idb_ptr )  rt_functab[stp->st_id].ft_ifree( &intern );
d601 1
a601 1
		rt_functab[stp->st_id].ft_free( stp );
@


11.29
log
@
sed4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.28 1999/05/10 21:32:34 mike Exp $ (ARL)";
d300 1
a300 1
		for( BU_LIST_FOR( mid, rt_list, &dp->d_use_hd ) )  {
@


11.28
log
@Improved the comment.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.27 1999/05/10 21:30:48 mike Exp $ (ARL)";
d314 1
a314 1
			if( !rt_mat_is_equal(mat, stp->st_matp, &rtip->rti_tol))
d359 2
a360 2
			stp->st_matp = (matp_t)rt_malloc( sizeof(mat_t), "st_matp" );
			mat_copy( stp->st_matp, mat );
d411 1
a411 1
	if( !rt_mat_is_equal(tsp->ts_mat, bn_mat_identity, &rtip->rti_tol)) {
d523 1
a523 1
		rt_free(sofar, "path string");
d555 1
a555 1
		rt_free(sofar, "path string");
d937 2
a938 2
			rt_free( (char *)left, "rt_tree_elim_nops union tree");
			rt_free( (char *)right, "rt_tree_elim_nops union tree");
d943 2
a944 2
			rt_free( (char *)left, "rt_tree_elim_nops union tree");
			rt_free( (char *)right, "rt_tree_elim_nops union tree");
d974 2
a975 2
			rt_free( (char *)left, "rt_tree_elim_nops union tree");
			rt_free( (char *)right, "rt_tree_elim_nops union tree");
d985 1
a985 1
			rt_free( (char *)left, "rt_tree_elim_nops union tree");
@


11.27
log
@Variable name changed from ma_override to ma_color_valid
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.26 1999/05/10 16:03:39 mike Exp $ (ARL)";
d66 1
a66 1
		0,			/* override */
@


11.26
log
@ts_region_start_func() got extra parameter of
rt_comb_internal *combp
for FASTGEN foolishness.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.25 1998/12/17 04:19:10 mike Exp $ (ARL)";
d198 1
a198 1
	if( rp->reg_mater.ma_override == 0 )
@


11.25
log
@Regions now have an associated temperature
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tree.c,v 11.24 1998/04/15 04:32:40 mike Exp $ (ARL)";
d116 1
a116 1
HIDDEN int rt_gettree_region_start( tsp, pathp )
d119 1
@


11.24
log
@Eliminated global variable rt_tree_rtip
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.23 1998/03/24 08:15:16 mike Exp mike $ (ARL)";
d65 1
@


11.23
log
@Fixed major bug where 2nd instance of an rt_i might sometimes
re-use solids from the first instance.  When first one is freed, boom!
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.22 1998/03/24 05:10:10 mike Exp mike $ (ARL)";
a78 2
static struct rt_i	*rt_tree_rtip;

d119 1
d122 2
a123 2
	if( rt_tree_rtip->useair == 0 &&  tsp->ts_aircode != 0 )  {
		rt_tree_rtip->rti_air_discards++;
d151 1
d156 2
d207 2
a208 2
	rp->reg_forw = rt_tree_rtip->HeadRegion;
	rt_tree_rtip->HeadRegion = rp;
d210 1
a210 1
	rp->reg_bit = rt_tree_rtip->nregions++;	/* Assign bit vector pos. */
d398 1
d403 2
a404 1
	RT_CK_RTI(rt_tree_rtip);
d409 1
a409 1
	if( !rt_mat_is_equal(tsp->ts_mat, bn_mat_identity, &rt_tree_rtip->rti_tol)) {
d427 1
a427 1
	stp = rt_find_identical_solid( mat, dp, rt_tree_rtip );
d471 1
a471 1
	if( rt_functab[id].ft_prep( stp, &intern, rt_tree_rtip ) )  {
d485 1
a485 1
	if( rt_tree_rtip->rti_dont_instance )  {
a676 1
	rt_tree_rtip = rtip;
d680 1
d683 1
a683 1
		&rt_initial_tree_state,
a686 2

	rt_tree_rtip = (struct rt_i *)0;	/* sanity */
@


11.22
log
@When rti_dont_instance is set, let stp->st_path be the full path to the leaf.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.21 1998/03/19 15:57:01 jra Exp mike $ (ARL)";
d303 2
a304 2
					have_match = 1;
					break;
d313 1
@


11.21
log
@Cahnged to new calling sequence for ft_import and ft_export.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.20 1998/03/19 11:42:42 mike Exp jra $ (ARL)";
d480 12
a491 12
	/*
	 *  If there is more than just a direct reference to this leaf
	 *  from it's containing region, copy that below-region path
	 *  into st_path.  Otherwise, leave st_path's magic number 0.
	 */
	i = pathp->fp_len-1;
	if( i > 0 && !(pathp->fp_names[i-1]->d_flags & DIR_REGION) )  {
		/* Search backwards for region.  If no region, use whole path */
		for( --i; i > 0; i-- )  {
			if( pathp->fp_names[i-1]->d_flags & DIR_REGION ) break;
		}
		if( i < 0 )  i = 0;
d493 18
a510 5
		db_dup_path_tail( &stp->st_path, pathp, i );
		if(rt_g.debug&DEBUG_TREEWALK)  {
			char	*sofar = db_path_to_string(&stp->st_path);
			bu_log("rt_gettree_leaf() st_path=%s\n", sofar );
			rt_free(sofar, "path string");
d512 5
@


11.20
log
@Added support for rti_dont_instanc
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.19 1997/12/16 01:59:05 mike Exp mike $ (ARL)";
d443 1
a443 1
	if( rt_functab[id].ft_import( &intern, ep, mat ) < 0 )  {
@


11.19
log
@Removed rt_plookup() commented-out code.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.18 1997/12/16 01:57:52 mike Exp mike $ (ARL)";
d292 1
a292 1
	if( dp->d_uses > 0 )  {
@


11.18
log
@Removed additional race conditions, especially in error-recovery
blocks.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.17 1997/12/16 01:21:44 mike Exp mike $ (ARL)";
a735 36

#if 0	/* XXX rt_plookup replaced by db_follow_path_for_state */
/*
 *			R T _ P L O O K U P
 * 
 *  Look up a path where the elements are separates by slashes.
 *  If the whole path is valid,
 *  set caller's pointer to point at path array.
 *
 *  Returns -
 *	# path elements on success
 *	-1	ERROR
 */
int
rt_plookup( rtip, dirp, cp, noisy )
struct rt_i	*rtip;
struct directory ***dirp;
register char	*cp;
int		noisy;
{
	struct db_tree_state	ts;
	struct db_full_path	path;

	bzero( (char *)&ts, sizeof(ts) );
	ts.ts_dbip = rtip->rti_dbip;
	mat_idn( ts.ts_mat );
	path.fp_len = path.fp_maxlen = 0;
	path.fp_names = (struct directory **)0;

	if( db_follow_path_for_state( &ts, &path, cp, noisy ) < 0 )
		return(-1);		/* ERROR */

	*dirp = path.fp_names;
	return(path.fp_len);
}
#endif
@


11.17
log
@Improved rt_free_soltab() to use same semaphores as rt_find_identical_solid()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.16 1997/12/16 01:10:52 mike Exp mike $ (ARL)";
d301 2
a302 5
			/* Don't instance this solid in some other model instance */
			if( stp->st_rtip != rtip )  continue;

			if( mat == (matp_t)0 )  {
				if( stp->st_matp == (matp_t)0 )  {
d308 1
a308 1
			if( stp->st_matp == (matp_t)0 )  continue;
d310 9
a318 4
			if (rt_mat_is_equal(mat, stp->st_matp, &rtip->rti_tol)) {
				have_match = 1;
				break;
			}
d324 2
a325 1
		 *  stp now points to re-referenced solid
d328 3
a330 1
		stp->st_uses++;
d424 1
d426 1
a426 1
			stp->st_uses--;
d444 1
d448 2
d452 1
d467 1
d472 2
d476 1
d542 2
a543 5
 *  This routine can not be used in PARALLEL, hence the st_aradius hack.
 *	???? XXX is this still true?
 *
 *  This routine must semaphore protect against other copies of itself
 *  running in parallel, both in this code and in
d545 1
a545 1
 *  be modifying the linked list heads.
@


11.16
log
@Converted over to using dedicated 4-way semaphore for tree processing
@
text
@a6 4
 *  PARALLEL lock usage note -
 *	res_model	used for interlocking rti_headsolid list (PARALLEL)
 *	res_results	used for interlocking HeadRegion list (PARALLEL)
 *
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.15 1997/12/16 00:06:12 mike Exp mike $ (ARL)";
d81 30
d289 1
a289 14
	switch( hash&3 )  {
	case 0:
		bu_semaphore_acquire( RT_SEM_TREE0 );
		break;
	case 1:
		bu_semaphore_acquire( RT_SEM_TREE1 );
		break;
	case 2:
		bu_semaphore_acquire( RT_SEM_TREE2 );
		break;
	default:
		bu_semaphore_acquire( RT_SEM_TREE3 );
		break;
	}
d367 2
a368 14
	switch( hash&3 )  {
	case 0:
		bu_semaphore_release( RT_SEM_TREE0 );
		break;
	case 1:
		bu_semaphore_release( RT_SEM_TREE1 );
		break;
	case 2:
		bu_semaphore_release( RT_SEM_TREE2 );
		break;
	default:
		bu_semaphore_release( RT_SEM_TREE3 );
		break;
	}
d529 1
d531 2
a532 2
 *  This routine will semaphore protect against other copies of itself
 *  running in parallel.  However, there is no protection against
d534 1
a534 3
 *  be modifying the linked list heads while locked on other semaphores
 *  (resources).  This is the strongest argument I can think of for
 *  removing the 3-way semaphore stuff in rt_find_identical_solid().
d546 2
d551 1
d553 1
a553 1
	bu_semaphore_acquire( RT_SEM_MODEL );
d555 1
a555 1
		bu_semaphore_release( RT_SEM_MODEL );
d558 2
d561 1
a561 2
	/* NON-PARALLEL, on d_use_hd (may be locked on other semaphore) */
	BU_LIST_DEQUEUE( &(stp->l2) );	/* remove from st_dp->d_use_hd list */
a562 4
	BU_LIST_DEQUEUE( &(stp->l) );	/* NON-PARALLEL on rti_solidheads[] */

	bu_semaphore_release( RT_SEM_MODEL );

d567 1
a567 1
	if( stp->st_matp )  rt_free( (char *)stp->st_matp, "st_matp");
a572 1
	rt_free( (char *)stp, "struct soltab" );
d578 2
d612 1
a612 1
 *	res_worker	(db_walk_dispatcher, from db_walk_tree)
@


11.15
log
@Converted to bu_semaphore_acquire().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.14 1997/01/28 02:34:06 mike Exp mike $ (ARL)";
a222 1
 *  Note that there are only 5 resource locks defined:
d224 2
a225 6
 *	res_worker 	is used by db_walk_dispatcher(), so it can't be used
 * 			for fear of affecting load balancing.
 *	res_syscall	is used by rt_malloc() & database reading, so it
 *			can't be used either.
 *
 *  This unfortunately limits the code to having only 3 CPUs doing list
d262 2
a263 2
	/* Enter the appropriate critical section */
	switch( hash%3 )  {
d265 1
a265 1
		bu_semaphore_acquire( RT_SEM_MODEL );
d268 1
a268 1
		bu_semaphore_acquire( RT_SEM_RESULTS );
d270 3
d274 1
a274 1
		bu_semaphore_acquire( RT_SEM_STATS );
d342 1
a342 1
		/* PARALLEL NOTE:  Needs critical section on rt_solidheads element */
d346 1
a346 1
		/* PARALLEL NOTE:  Needs critical section on this 'dp' */
d353 2
a354 2
	/* Leave the appropriate critical section */
	switch( hash%3 )  {
d356 1
a356 1
		bu_semaphore_release( RT_SEM_MODEL );
d359 1
a359 1
		bu_semaphore_release( RT_SEM_RESULTS );
d361 3
d365 1
a365 1
		bu_semaphore_release( RT_SEM_STATS );
d535 6
@


11.14
log
@Added db_dup_db_tree_state() / db_free_db_tree_state().
More care in checking magic numbers.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.13 1997/01/28 01:51:01 mike Exp mike $ (ARL)";
d171 1
a171 1
	RES_ACQUIRE( &rt_g.res_results );	/* enter critical section */
d183 1
a183 1
	RES_RELEASE( &rt_g.res_results );	/* leave critical section */
d270 1
a270 1
		RES_ACQUIRE( &rt_g.res_model );
d273 1
a273 1
		RES_ACQUIRE( &rt_g.res_results );
d276 1
a276 1
		RES_ACQUIRE( &rt_g.res_stats );
d358 1
a358 1
		RES_RELEASE( &rt_g.res_model );
d361 1
a361 1
		RES_RELEASE( &rt_g.res_results );
d364 1
a364 1
		RES_RELEASE( &rt_g.res_stats );
d543 1
a543 1
	RES_ACQUIRE( &rt_g.res_model );
d545 1
a545 1
		RES_RELEASE( &rt_g.res_model );
d554 1
a554 1
	RES_RELEASE( &rt_g.res_model );
d602 2
a603 2
 *	res_model	protects rti_solidheads[] lists
 *	res_results	protects HeadRegion, mdl_min/max, d_uses, nregions
@


11.13
log
@JRA edits
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.12 1997/01/24 20:14:40 bparker Exp jra $ (ARL)";
d56 4
d619 1
d625 1
d636 3
@


11.12
log
@*** empty log message ***
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.11 1996/12/04 02:51:45 mike Exp bparker $ (ARL)";
d121 1
d140 10
@


11.11
log
@Combined ma_matname and ma_matparm into a single string, ma_shader.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.10 1996/11/27 07:26:09 mike Exp mike $ (ARL)";
d41 1
d43 1
d382 1
a382 1
	if( !rt_mat_is_equal(tsp->ts_mat, rt_identity, &rt_tree_rtip->rti_tol)) {
d413 1
a413 1
		mat = (matp_t)rt_identity;
@


11.10
log
@Fixed storage class decl.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.9 1996/11/20 19:36:14 jra Exp mike $ (ARL)";
d66 1
a66 2
		(char *)0,		/* material name */
		(char *)0		/* material params */
@


11.9
log
@Modified initialization of rt_initial_tree_state.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.8 1996/09/27 08:28:33 mike Exp jra $ (ARL)";
d1000 2
a1001 2
struct rt_i	*rtip;
CONST register char	*reg_name;
@


11.8
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.7 1996/09/27 08:22:38 mike Exp mike $ (ARL)";
d66 2
a67 2
		"",			/* material name */
		""			/* material params */
@


11.7
log
@Improved support for multiple rt_i pointers
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.6 1996/09/27 06:23:52 butler Exp mike $ (ARL)";
d130 1
a130 1
	GETSTRUCT( rp, region );
d143 1
a143 1
		rt_log("rt_gettree_region_end() %s\n", rp->reg_name );
d170 1
a170 1
		rt_log("Add Region %s instnum %d\n",
d266 1
a266 1
		struct rt_list	*mid;
d269 1
a269 1
		for( RT_LIST_FOR( mid, rt_list, &dp->d_use_hd ) )  {
d271 1
a271 1
			stp = RT_LIST_MAIN_PTR( soltab, mid, l2 );
d301 1
a301 1
			rt_log( mat ?
d311 1
a311 1
		GETSTRUCT(stp, soltab);
d329 1
a329 1
		RT_LIST_INSERT( &(rtip->rti_solidheads[hash]), &(stp->l) );
d333 1
a333 1
		RT_LIST_INSERT( &dp->d_use_hd, &(stp->l2) );
d363 1
a363 1
CONST struct rt_external	*ep;
d375 1
a375 1
	RT_CK_EXTERNAL(ep);
d420 1
a420 1
		rt_log("rt_gettree_leaf(%s):  solid import failure\n", dp->d_namep );
d440 1
a440 1
		rt_log("rt_gettree_leaf(%s):  prep failure\n", dp->d_namep );
d464 1
a464 1
			rt_log("rt_gettree_leaf() st_path=%s\n", sofar );
d471 3
a473 3
		struct rt_vls	str;
		rt_log("\n---Solid %d: %s\n", stp->st_bit, dp->d_namep);
		rt_vls_init( &str );
d476 1
a476 1
			rt_log("rt_gettree_leaf(%s):  solid describe failure\n",
d479 2
a480 2
		rt_log( "%s:  %s", dp->d_namep, rt_vls_addr( &str ) );
		rt_vls_free( &str );
d488 1
a488 1
	GETUNION( curtree, tree );
d497 1
a497 1
		rt_log("rt_gettree_leaf() %s\n", sofar );
d534 1
a534 1
	RT_LIST_DEQUEUE( &(stp->l2) );	/* remove from st_dp->d_use_hd list */
d536 1
a536 1
	RT_LIST_DEQUEUE( &(stp->l) );	/* NON-PARALLEL on rti_solidheads[] */
d610 1
a610 1
		rt_log("ERROR: rt_gettree() called again after rt_prep!\n");
d647 1
a647 1
			rt_log("rt_gettrees() cleaning up dead solid '%s'\n",
d674 1
a674 1
			rt_log("rt_gettrees() %s\n", regp->reg_name );
d693 1
a693 1
		rt_log("rt_gettrees(%s) warning:  no solids found\n", argv[0]);
d763 1
a763 1
				rt_log("rt_bound_tree: encountered dead solid '%s'\n",
d779 1
a779 1
		rt_log( "rt_bound_tree(x%x): unknown op=x%x\n",
d836 1
a836 1
				if(rt_g.debug&DEBUG_TREEWALK)rt_log("rt_tree_kill_dead_solid_refs: encountered dead solid '%s' stp=x%x, tp=x%x\n",
d846 1
a846 1
		rt_log( "rt_tree_kill_dead_solid_refs(x%x): unknown op=x%x\n",
d899 1
a899 1
		rt_log( "rt_tree_elim_nops(x%x): unknown op=x%x\n",
d1218 1
a1218 1
			rt_log("rt_optim_tree: bad op x%x\n", tp->tr_op);
@


11.6
log
@added some CONST's
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.5 1996/08/31 04:20:54 mike Exp butler $ (ARL)";
d274 3
d314 1
d562 2
d581 3
@


11.5
log
@Changed calling sequence to bu_ptbl_init() to have reason string
for bu_malloc() tracking
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.4 1996/08/28 10:03:46 mike Exp mike $ (ARL)";
d992 1
a992 1
register char	*reg_name;
d1023 1
a1023 1
char		*reg_name;
@


11.4
log
@st_regions is now a bu_ptbl, not a bitvector.
"regionbits" is also a bu_ptbl, not a bitvector.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.3 1996/07/04 01:55:12 mike Exp mike $ (ARL)";
d332 1
a332 1
		bu_ptbl_init( &stp->st_regions, 7 );
@


11.3
log
@Removed "pure_boolean_expressions" flag variable.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 11.2 1995/07/27 20:25:12 mike Exp mike $ (ARL)";
d330 3
d543 1
a543 2
	if( stp->st_regions ) rt_free( (char *)stp->st_regions, "st_regions bitv" );
	stp->st_regions = (bitv_t *)0;	/* Sanity */
@


11.2
log
@Added support for st_path.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
a44 2

int rt_pure_boolean_expressions = 0;
@


11.1
log
@Release_4.4
@
text
@d15 2
a16 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
d18 5
d24 2
a25 2
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
d28 1
a28 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 10.12 94/12/19 16:28:56 jra Exp $ (BRL)";
d366 1
d443 21
d548 4
@


10.12
log
@Mods for CRAY.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 10.11 94/11/29 22:46:52 mike Exp $ (BRL)";
@


10.11
log
@Changed "Found dead solid" bomb to a log and proceed.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 10.10 94/11/29 17:55:24 butler Exp Locker: mike $ (BRL)";
d792 1
a792 1
			register CONST struct soltab	*stp;
@


10.10
log
@more debugging output
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 10.9 94/11/04 05:41:57 mike Exp Locker: butler $ (BRL)";
d608 2
a609 3
			/* XXX is this rt_bomb is a problem? */
			rt_log("%s[%d]: ", __FILE__, __LINE__);
			rt_bomb("Found a dead solid\n");
@


10.9
log
@Irix 6
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 10.8 94/09/30 16:09:42 mike Exp Locker: mike $ (BRL)";
d608 2
@


10.8
log
@Implemented linear-time searching algorithm in rt_find_identical_solid(),
to replace current O((nsolid/128)**2) algorithm.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 10.7 94/08/10 20:22:15 gdurf Exp Locker: mike $ (BRL)";
a356 1
	register fastf_t	f;
a360 1
	register int		i;
@


10.7
log
@Factored ifdefs
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 10.6 1994/05/10 11:04:20 mike Exp gdurf $ (BRL)";
d215 18
a239 2
	register struct rt_list	*head;
	register int		i;
a261 2
	head = &(rtip->rti_solidheads[hash]);

d263 2
a264 1
	if( dp->d_uses > 0 )  for( RT_LIST_FOR( stp, soltab, head ) )  {
d266 2
a267 2
		/* Leaf solids must be the same before comparing matrices */
		if( dp != stp->st_dp )  continue;
d269 13
a281 2
		if( mat == (matp_t)0 )  {
			if( stp->st_matp == (matp_t)0 )  {
a284 1
			continue;
a285 6
		if( stp->st_matp == (matp_t)0 )  continue;

		if (rt_mat_is_equal(mat, stp->st_matp, &rtip->rti_tol)) {
			have_match = 1;
			break;
		}
d294 1
a294 1
		/** dp->d_uses++ ? **/
d308 1
d321 7
a327 2
		/* Add to the appropriate linked list */
		RT_LIST_INSERT( head, &(stp->l) );
d480 9
a488 1
 *  This routine can not be used in PARALLE, hence the st_aradius hack.
d498 5
a502 1
	if( --(stp->st_uses) > 0 )  return;
d504 8
a511 1
	if( stp->st_aradius > 0 )
d513 2
a514 2

	RT_LIST_DEQUEUE( &(stp->l) );	/* Non-PARALLEL */
d523 1
@


10.6
log
@Added magic numbers to union tree structures.
Added db_ck_tree() routine.
Added rt_free_soltab().
Rearranged rt_clean() to not trash soltab structures.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 10.5 94/03/02 21:35:04 cjohnson Exp Locker: mike $ (BRL)";
d27 2
d31 3
a33 1
#ifdef BSD
a34 2
#else
#include <string.h>
@


10.5
log
@change over to rt_mat_is_equal() from unique matrix compare.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 10.4 1993/10/01 20:54:55 mike Exp cjohnson $ (BRL)";
d117 4
d225 1
a260 1
#		include "noalias.h"
d272 2
d276 3
a278 3
			    "rt_find_identical_solid:  %s re-referenced\n" :
			    "rt_find_identical_solid:  %s re-referenced (identity mat)\n",
				dp->d_namep );
d287 1
d291 1
d338 2
d367 1
d389 1
d409 1
d433 1
d449 31
d543 6
d563 2
a564 6
			RT_LIST_DEQUEUE( &(stp->l) );
			if( stp->st_matp )  rt_free( (char *)stp->st_matp, "st_matp");
			stp->st_matp = (matp_t)0;
			stp->st_regions = (bitv_t *)0;
			stp->st_dp = DIR_NULL;		/* was ptr to directory */
			rt_free( (char *)stp, "dead struct soltab" );
d589 2
a590 2
			rt_log("rt_gettree_region_end() %s\n", regp->reg_name );
			rt_bomb("rt_gettree_region_end(): rt_bound_tree() fail\n");
d599 6
d667 1
a667 4
	if( tp == TREE_NULL )  {
		rt_log( "rt_bound_tree(): NULL tree pointer.\n" );
		return(-1);
	}
d740 1
a740 4
	if( tp == TREE_NULL )  {
		rt_log( "rt_tree_kill_dead_solid_refs(): NULL tree pointer.\n" );
		return;
	}
d753 1
d806 1
a806 4
	if( tp == TREE_NULL )  {
		rt_log( "rt_tree_elim_nops(): NULL tree pointer.\n" );
		return(-1);
	}
d921 1
d1085 1
d1147 2
@


10.4
log
@Added some function declarations.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 10.3 93/09/25 11:51:35 mike Exp Locker: mike $ (BRL)";
a170 12
 *  XXX Something should be done to account for tolerances from rtip,
 *  but this at least allows varying deltas for the angle and distance
 *  parts of the matrix.
 */
static CONST mat_t	rt_equal_matrix = {
	0.00001,	0.00001,	0.00001,	0.01,
	0.00001,	0.00001,	0.00001,	0.01,
	0.00001,	0.00001,	0.00001,	0.01,
	0,		0,		0,		0.00001
};

/*
d257 3
a259 5
		for( i=0; i<16; i++ )  {
			register fastf_t	f;
			f = mat[i] - stp->st_matp[i];
			if( !NEAR_ZERO(f, 0.0001) )
				goto next_one;
a260 4
		/* Success, we have a match! */
		have_match = 1;
		break;
next_one: ;
d335 2
a336 7
	/* XXX Should build custom matrix based upon rtip tolerances */
	for( i=0; i<16; i++ )  {
		f = tsp->ts_mat[i] - rt_identity[i];
		if( !NEAR_ZERO(f, rt_equal_matrix[i]) )
			break;
	}
	if( i < 16 )  {
@


10.3
log
@Made a void function
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 10.2 93/07/20 22:49:28 mike Exp Locker: mike $ (BRL)";
d42 2
d45 1
a45 1
extern CONST char	*rt_basename();
@


10.2
log
@rt_basename() eats and returns CONST
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 10.1 91/10/12 06:41:08 mike Rel4_0 Locker: mike $ (BRL)";
d706 1
@


10.1
log
@Release_4.0
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.48 91/10/11 02:59:34 mike Exp $ (BRL)";
d43 1
a43 1
extern char	*rt_basename();
d225 1
a225 1
	register struct soltab	*stp;
d866 1
a866 1
char *
d868 1
a868 1
register char	*str;
d870 1
a870 1
	register char	*p = str;
d897 1
a897 1
		register char	*cp;
@


9.48
log
@gcc on the Mac had a problem compiling an IF statement with an
empty THEN block and a non-empty ELSE block.
So, compliment the sense of the test and eliminate the empty block.
Quite a bug hunt.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.47 91/10/10 22:42:32 mike Exp Locker: mike $ (BRL)";
@


9.47
log
@tr_a.tu_name is no longer needed by anything.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.46 91/09/20 22:46:46 mike Exp Locker: mike $ (BRL)";
d566 2
a567 3
		if( region_max[X] >= INFINITY )  {
			/* skip infinite region */
		} else {
@


9.46
log
@Modified to fix Carol Ellis bug.
When multiple instances of a solid that failed to prep were cleaned up,
the references in the tree were not cleaned up first.
New strategy is to walk each tree twice.
First to change dead solid to OP_NOP nodes.
Then to optimize all OP_NOP nodes out of the tree.
And only *then* eliminate solids from the soltab list.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.45 91/07/17 01:49:27 mike Exp $ (BRL)";
a442 1
	curtree->tr_a.tu_name = db_path_to_string( pathp );
d446 5
a450 2
	if(rt_g.debug&DEBUG_TREEWALK)
		rt_log("rt_gettree_leaf() %s\n", curtree->tr_a.tu_name );
@


9.45
log
@Oops, somehow reg_magic was not getting initialized.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.44 91/07/17 01:29:54 mike Exp $ (BRL)";
d79 1
d517 10
a526 1
	/* Eliminate any "dead" solids that parallel code couldn't change */
d696 159
@


9.44
log
@Fixed serious race condition that would cause some OP_SOLID tree nodes
to vanish.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.43 91/07/16 21:12:27 mike Exp $ (BRL)";
d120 1
@


9.43
log
@rt_optim_tree is no longer hidden, it is used by prep.c
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.42 91/07/10 00:53:58 mike Exp $ (BRL)";
d99 6
a112 1
	point_t			region_min, region_max;
d134 1
a134 9

	/*
	 *  Add a region and it's boolean tree to all the appropriate places.
	 *  The	region and treetop are cross-linked, and the region is added
	 *  to the linked list of regions.
	 *  Positions in the region bit vector are established at this time.
	 */
	/* Cross-ref: Mark all solids & nodes as belonging to this region */
	rt_tree_region_assign( curtree, rp );
a142 11
	/*
	 *  Find region RPP, and update the model maxima and minima
	 *
	 *  Don't update min & max for halfspaces;  instead, add them
	 *  to the list of infinite solids, for special handling.
	 */
	if( rt_bound_tree( curtree, region_min, region_max ) < 0 )  {
		rt_log("rt_gettree_region_end() %s\n", rp->reg_name );
		rt_bomb("rt_gettree_region_end(): rt_bound_tree() fail\n");
	}

a143 6
	if( region_max[X] >= INFINITY )  {
		/* skip infinite region */
	} else {
		VMINMAX( rt_tree_rtip->mdl_min, rt_tree_rtip->mdl_max, region_min );
		VMINMAX( rt_tree_rtip->mdl_min, rt_tree_rtip->mdl_max, region_max );
	}
d147 4
a150 1
	/* Add to linked list */
d366 6
d375 1
a375 1
		if( stp->st_aradius <= 0 )
d377 1
d490 1
d493 1
d533 27
@


9.42
log
@Can't do rtip->nsolids-- when a dead solid is deleted, because
rtip->nsolids also doubles in as the maximum bit number indication.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.41 91/07/10 00:52:19 mike Exp $ (BRL)";
d860 1
a860 1
HIDDEN void
@


9.41
log
@Fixed problem with instances of "dead solids" still showing up in
a node of a boolean tree.
Made a pass through the solid table to remove them completely.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.40 91/07/09 23:38:55 mike Exp $ (BRL)";
d534 1
a534 1
			rtip->nsolids--;
@


9.40
log
@tree bounding RPP calculation ignores dead solids.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.39 91/07/06 02:16:11 mike Exp $ (BRL)";
d156 1
d385 5
a389 1
	if( stp->st_id != 0 )  goto found_it;
d405 1
a405 1
		/* Too late to delete soltab entry; mark is as "dead" */
d424 1
a424 1
		/* Too late to delete soltab entry; mark is as "dead" */
d499 1
d505 4
a508 2
	if(!rtip->needprep)
		rt_bomb("rt_gettree called again after rt_prep!\n");
d523 16
a538 4
	if(rt_g.debug&DEBUG_SOLIDS)  {
		register CONST struct soltab	*stp;
		RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
			RT_CK_SOLTAB(stp);
d540 1
a540 2
		} RT_VISIT_ALL_SOLTABS_END
	}
d618 3
a620 6
				/* Problematic: need to skip this solid.
				 * XXX Assume origin is within model RPP.
				 */
				VSETALL( tree_min, 0 );
				VSETALL( tree_max, 0 );
				return(0);
@


9.39
log
@Yuck, ANSI and K&R structure initializations are incompatible.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.38 91/07/05 23:40:31 mike Exp $ (BRL)";
d594 1
a594 1
			register struct soltab	*stp;
d597 9
@


9.38
log
@ANSI structure initialization
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.37 91/07/01 03:38:05 mike Exp $ (BRL)";
d52 1
d54 1
d62 4
a65 1
	},
@


9.37
log
@ANSI lint
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.36 91/07/01 00:47:48 mike Exp $ (BRL)";
d52 9
a60 6
	1.0, 1.0, 1.0,		/* color, RGB */
	0,			/* override */
	DB_INH_LOWER,		/* color inherit */
	DB_INH_LOWER,		/* mater inherit */
	"",			/* material name */
	"",			/* material params */
@


9.36
log
@At this point, on the SGI, the main bottleneck to parallel tree walking
is due to overhead in malloc(), which is occupying more than 50% of
all CPUs on a 4D/280.

Parallel processor interlock summary
 # of Uses   # Spins Waitloops Purpose
    185005     78999         0 syscall
      2913         1         0 worker
      4138       585         0 stats
      7039      1048         0 results
      6987      1075         0 model refinement
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.35 91/06/30 23:17:01 mike Exp $ (BRL)";
d228 1
a228 1
register CONST struct directory	*dp;
d340 1
a340 1
CONST struct db_full_path	*pathp;
d347 1
a347 1
	CONST struct directory	*dp;
d809 1
a809 2
	register CONST char	*cp;
	int			c;
d812 3
a814 1
	c = name[0];
d816 2
a817 3
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		if( *(cp = stp->st_dp->d_namep) == c  &&
		    strcmp( cp, name ) == 0 )  {
a818 1
		}
@


9.35
log
@Changed from rti_headsolid list for all soltab structures,
to RT_DBNHASH different lists, rti_solidheads[].
This permits much faster searching in the parallel treewalking stage.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.34 91/06/30 22:24:46 mike Exp $ (BRL)";
d212 13
a224 2
 *  XXX As a future enhancement, it would be safe (and faster!) to use
 *  XXX different critical sections for the different lists.
d242 12
a253 1
	RES_ACQUIRE( &rt_g.res_model );	/* enter critical section */
d317 12
a328 1
	RES_RELEASE( &rt_g.res_model );	/* leave critical section */
@


9.34
log
@Now allow un-equal weighting for equality check against identity
matrix.  Allows better chances of detecting an incomming identity.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.33 91/06/30 21:24:05 mike Exp $ (BRL)";
d205 9
d224 1
d229 2
d233 5
a237 2
	head = &(rtip->rti_headsolid);
	for( RT_LIST_FOR( stp, soltab, head ) )  {
d282 1
d291 1
a291 1

d438 1
a438 1
 *	res_model	protects rti_headsolid & list
d476 1
a476 1
		for( RT_LIST_FOR( stp, soltab, &(rtip->rti_headsolid) ) )  {
d479 1
a479 1
		}
d782 1
a782 1
	for( RT_LIST_FOR( stp, soltab, &(rtip->rti_headsolid) ) )  {
d787 1
a787 1
	}
@


9.33
log
@This version nearly doubles the speed of rt_find_identical_solid()
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.32 91/06/30 21:08:08 mike Exp $ (BRL)";
d175 12
d308 1
d311 1
a311 1
		if( !NEAR_ZERO(f, 0.0001) )
@


9.32
log
@Used wrong variable.  Not harmful.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.31 91/06/30 18:33:51 mike Exp $ (BRL)";
d200 1
d209 2
a210 3
	for( RT_LIST( stp, soltab, &(rtip->rti_headsolid) ) )  {
		RT_CK_SOLTAB(stp);		/* sanity */

d240 1
d264 1
a264 1
		RT_LIST_INSERT( &(rtip->rti_headsolid), &(stp->l) );
d447 1
a447 1
		for( RT_LIST( stp, soltab, &(rtip->rti_headsolid) ) )  {
d753 1
a753 1
	for( RT_LIST( stp, soltab, &(rtip->rti_headsolid) ) )  {
@


9.31
log
@This version can "prep" in parallel.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.33 91/06/30 02:51:34 mike Exp $ (BRL)";
d195 3
a197 3
register CONST matp_t	mat;
CONST struct directory	*dp;
struct rt_i		*rtip;
d208 1
a208 1
	for( RT_LIST( stp, soltab, &(rt_tree_rtip->rti_headsolid) ) )  {
d254 1
a254 1
		stp->st_bit = rt_tree_rtip->nsolids++;
d263 1
a263 1
		RT_LIST_INSERT( &(rt_tree_rtip->rti_headsolid), &(stp->l) );
d291 1
@


9.30
log
@ANSI lint
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.29 91/06/29 19:20:13 mike Exp $ (BRL)";
d175 1
a175 1
 *			R T _ G E T T R E E _ L E A F
d177 16
a192 1
 *  This routine must be prepared to run in parallel.
d194 4
a197 5
HIDDEN union tree *rt_gettree_leaf( tsp, pathp, ep, id )
CONST struct db_tree_state	*tsp;
CONST struct db_full_path	*pathp;
CONST struct rt_external	*ep;
int				id;
a198 1
	register fastf_t	f;
a199 3
	union tree		*curtree;
	CONST struct directory	*dp;
	struct rt_db_internal	intern;
a200 1
	register matp_t		mat;
d203 1
a203 2
	RT_CK_EXTERNAL(ep);
	dp = DB_FULL_PATH_CUR_DIR(pathp);
a204 21
	/* Determine if this matrix is an identity matrix */
	for( i=0; i<16; i++ )  {
		f = tsp->ts_mat[i] - rt_identity[i];
		if( !NEAR_ZERO(f, 0.0001) )
			break;
	}
	if( i < 16 )  {
		/* Not identity matrix */
		mat = (matp_t)tsp->ts_mat;
	} else {
		/* Identity matrix */
		mat = (matp_t)0;
	}

	/*
	 *  Check to see if this exact solid has already been processed.
	 *  Match on leaf name and matrix.
	 *
	 *  To avoid a race with updating rti_headsolid, this whole
	 *  loop must be within a critical section.
	 */
d207 1
d210 1
d222 1
d225 1
d235 1
a235 1
	RES_RELEASE( &rt_g.res_model );	/* leave critical section */
d237 3
a239 1
		/* stp now points to re-referenced solid */
d242 2
a243 2
			    "rt_gettree_leaf:  %s re-referenced\n" :
			    "rt_gettree_leaf:  %s re-referenced (ident)\n",
d246 18
a263 1
		goto found_it;
d266 48
a313 2
	GETSTRUCT(stp, soltab);
	stp->l.magic = RT_SOLTAB_MAGIC;
a314 1
	stp->st_dp = dp;
a315 2
		stp->st_matp = (matp_t)rt_malloc( sizeof(mat_t), "st_matp" );
		mat_copy( stp->st_matp, mat );
a317 1
		stp->st_matp = mat;
a319 1
	stp->st_specific = (genptr_t)0;
d321 3
a323 4
	/* init solid's maxima and minima */
	VSETALL( stp->st_max, -INFINITY );
	VSETALL( stp->st_min,  INFINITY );

d328 2
a329 2
		if( stp->st_matp )  rt_free( (char *)stp->st_matp, "st_matp");
		rt_free( (char *)stp, "struct soltab");
d334 4
d341 1
d346 3
a348 3
	    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
		if( stp->st_matp )  rt_free( (char *)stp->st_matp, "st_matp");
		rt_free( (char *)stp, "struct soltab");
a350 1
	id = stp->st_id;	/* type may have changed in prep */
a351 8
	/*
	 *  Link this new solid onto the list.  Critical section.
	 */
	RES_ACQUIRE( &rt_g.res_model );	/* enter critical section */
	RT_LIST_INSERT( &(rt_tree_rtip->rti_headsolid), &(stp->l) );
	stp->st_bit = rt_tree_rtip->nsolids++;
	RES_RELEASE( &rt_g.res_model );	/* leave critical section */

d358 1
a358 1
		if( rt_functab[id].ft_describe( &str, &intern, 1, 1.0 ) < 0 )  {
d368 1
a368 1
    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
@


9.29
log
@Added OP_NOP case
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.30 91/06/29 17:03:25 mike Exp $ (BRL)";
d72 2
a73 2
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
d93 3
a95 3
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
d115 1
a115 1
	dp = DB_FULL_PATH_CUR_DIR(pathp);
d180 4
a183 4
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_external	*ep;
int			id;
d188 1
a188 1
	struct directory	*dp;
d205 1
a205 1
		mat = tsp->ts_mat;
d350 1
a350 1
char		*node;
d373 1
a373 1
char		**argv;
d461 3
a463 3
register union tree	*tp;
vect_t			tree_min;
vect_t			tree_max;
d561 1
a561 1
	register char *reg_base = rt_basename(reg_name);
d610 1
a610 1
register dbfloat_t *fp;
d630 1
a630 1
register dbfloat_t *dbp;
d662 1
a662 1
register fastf_t *ff;
d695 2
a696 2
struct rt_i *rtip;
register char *name;
d699 2
a700 1
	register char		*cp;
d703 1
d706 1
a706 1
		if( *(cp = stp->st_name) == *name  &&
d786 1
a786 1
register struct region	*regionp;
d793 1
a793 1
		tp->tr_a.tu_regionp = regionp;
d799 1
a799 1
		tp->tr_b.tb_regionp = regionp;
d807 1
a807 1
		tp->tr_b.tb_regionp = regionp;
@


9.28
log
@Modified to be more careful in parallel operation.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.27 91/06/25 01:57:30 mike Exp $ (BRL)";
d99 1
a99 1
	vect_t			region_min, region_max;
d732 4
@


9.27
log
@Placed matrix matching into a critical section, as it deserves
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.26 91/06/24 23:43:31 mike Exp $ (BRL)";
d123 16
d148 1
a155 17
	/*
	 *  Add a region and it's boolean tree to all the appropriate places.
	 *  The	region and treetop are cross-linked, and the region is added
	 *  to the linked list of regions.
	 *  Positions in the region bit vector are established at this time.
	 */
	/* Cross-ref: Mark all solids & nodes as belonging to this region */
	rt_tree_region_assign( curtree, rp );
	rp->reg_treetop = curtree;

	/* Determine material properties */
	rp->reg_mfuncs = (char *)0;
	rp->reg_udata = (char *)0;
	if( rp->reg_mater.ma_override == 0 )
		rt_region_color_map(rp);

	RES_ACQUIRE( &rt_g.res_results );	/* enter critical section */
d221 1
a283 12
	if(rt_g.debug&DEBUG_SOLIDS)  {
		struct rt_vls	str;
		rt_vls_init( &str );
		/* verbose=1, mm2local=1.0 */
		if( rt_functab[id].ft_describe( &str, &intern, 1, 1.0 ) < 0 )  {
			rt_log("rt_gettree_leaf(%s):  solid describe failure\n",
				dp->d_namep );
		}
		rt_log( "%s:  %s", dp->d_namep, rt_vls_addr( &str ) );
		rt_vls_free( &str );
	}

a295 1
    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
d306 14
a319 1
	if(rt_g.debug&DEBUG_SOLIDS)  rt_pr_soltab( stp );
d321 3
d359 5
d396 9
@


9.26
log
@Needed to modify support routines to know about OP_NOP nodes
as region treetops.  They represent empty regions.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.25 91/06/22 22:30:53 mike Exp $ (BRL)";
d192 1
d214 3
a216 1
	 *  XXX There is a race on reading rti_headsolid here, prob. not harmful.
d218 2
d221 1
a221 4

		RT_CHECK_SOLTAB(stp);				/* debug */

		/* Leaf solids must be the same */
d226 2
a227 4
				if( rt_g.debug & DEBUG_SOLIDS )
					rt_log("rt_gettree_leaf:  %s re-referenced (ident)\n",
						dp->d_namep );
				goto found_it;
d229 1
a229 1
			goto next_one;
d231 2
a232 1
		if( stp->st_matp == (matp_t)0 )  goto next_one;
d239 11
a249 2
		if( rt_g.debug & DEBUG_SOLIDS )
			rt_log("rt_gettree_leaf:  %s re-referenced\n",
d251 1
a252 1
next_one: ;
d262 1
d265 1
d274 1
a274 1
	if( rt_functab[id].ft_import( &intern, ep, stp->st_matp ? stp->st_matp : rt_identity ) < 0 )  {
d310 3
a312 1
	/* For now, just link them all onto the same list */
d595 1
@


9.25
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.24 91/06/14 06:51:45 mike Exp $ (BRL)";
d129 1
d488 3
d750 3
@


9.24
log
@st_pathmat changed to st_matp, which is a null pointer if an
identity matrix is in use.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.23 91/06/11 01:34:09 mike Exp $ (BRL)";
a188 1
	struct rt_tol		tol;
a194 7
	/* XXX These need to be improved */
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

d286 1
a286 1
	if( rt_functab[id].ft_prep( stp, &intern, rt_tree_rtip, &tol ) )  {
d371 1
@


9.23
log
@Modified to account for having regions with no leaves passed in.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.22 91/06/11 00:11:00 mike Exp $ (BRL)";
d190 2
d202 15
a222 1
		register int i;
d225 14
a238 5
		if(	dp->d_namep[0] != stp->st_name[0]  ||	/* speed */
			dp->d_namep[1] != stp->st_name[1]  ||	/* speed */
			strcmp( dp->d_namep, stp->st_name ) != 0
		)
			continue;
d240 1
a240 1
			f = tsp->ts_mat[i] - stp->st_pathmat[i];
d256 6
a261 1
	mat_copy( stp->st_pathmat, tsp->ts_mat );
d269 1
a269 1
	if( rt_functab[id].ft_import( &intern, ep, stp->st_pathmat ) < 0 )  {
d272 1
d298 1
@


9.22
log
@Initial tree state is now exported
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.21 91/05/23 10:37:17 jehunt Exp $ (BRL)";
d100 5
@


9.21
log
@passed the LOS value from the db_tree_state data structure to the
rt region data structure
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.20 91/05/18 03:03:46 mike Exp $ (BRL)";
d48 1
a48 1
static struct db_tree_state	rt_initial_tree_state = {
@


9.20
log
@Converted to new tolerance interface
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.19 91/01/26 02:55:33 mike Exp $ (BRL)";
d51 1
a51 1
	0, 0, 0,		/* region, air, gmater */
d106 1
@


9.19
log
@Changed calling sequence to ts_leaf_func routiens
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.18 91/01/25 21:19:56 mike Exp $ (BRL)";
d183 1
d188 6
d257 1
a257 1
	if( rt_functab[id].ft_prep( stp, &intern, rt_tree_rtip ) )  {
@


9.18
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.17 91/01/11 07:08:28 mike Exp $ (BRL)";
d172 1
a172 1
HIDDEN union tree *rt_gettree_leaf( tsp, pathp, rp, id )
d175 1
a175 1
union record		*rp;
a181 1
	struct rt_external	ext, *ep;
d184 1
a223 6

	/* XXX this should be passed in as an arg */
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = stp->st_dp->d_len*sizeof(union record);
@


9.17
log
@Preparations for new import/export interface
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.16 90/11/11 04:55:53 mike Exp $ (BRL)";
d182 2
d225 1
a225 17
#if 1
	/*
	 * "rec" points to array of all relevant records, in
	 *  database format.  xxx_prep() routine is responsible for
	 *  import/export issues.
	 */
	if( rt_functab[id].ft_prep( stp, rp, rt_tree_rtip ) )  {
		/* Error, solid no good */
		rt_log("rt_gettree_leaf(%s):  prep failure\n", dp->d_namep );
		rt_free( (char *)stp, "struct soltab");
		return( TREE_NULL );		/* BAD */
	}
#else
    {
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern;

d228 1
a228 1
	ep->ext_buf = (genptr_t)rec;
d231 1
d234 1
d243 2
a244 1
		if( rt_functab[id].ft_describe( &str, &intern, 1 ) < 0 )  {
a263 2
    }
#endif
@


9.16
log
@rt_plookup stub #ifdef'ed out
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.15 90/10/07 21:38:55 mike Exp $ (BRL)";
d223 1
d235 42
@


9.15
log
@soltab structure changed to use struct rt_list.
HeadSolid became rti_headsolid.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.14 90/05/21 15:45:16 mike Exp $ (BRL)";
d317 1
d351 1
@


9.14
log
@lint
@
text
@d7 3
a9 3
 *  Parallel Note -
 *	res_model	used for interlocking HeadSolid list
 *	res_results	used for interlocking HeadRegion list
d24 1
a24 1
static char RCStree[] = "@@(#)$Header: /m/cad/librt/RCS/tree.c,v 9.13 90/04/27 02:12:53 mike Exp $ (BRL)";
d178 3
a180 2
	struct soltab	*stp;
	union tree	*curtree;
a181 1
	FAST fastf_t	f;
d188 1
a188 1
	 *  XXX There is a race on reading HeadSolid here, prob. not harmful.
d190 1
a190 1
	for( stp = rt_tree_rtip->HeadSolid; stp != SOLTAB_NULL; stp = stp->st_forw )  {
d193 1
d213 1
a215 1
	stp->st_name = dp->d_namep;	/* st_name could be eliminated */
d238 1
a238 2
	stp->st_forw = rt_tree_rtip->HeadSolid;
	rt_tree_rtip->HeadSolid = stp;
d590 1
a590 1
 *  Returns soltab pointer, or SOLTAB_NULL.
d597 2
a598 2
	register struct soltab *stp;
	register char *cp;
d602 1
a602 1
	for( stp=rtip->HeadSolid; stp != SOLTAB_NULL; stp = stp->st_forw )  {
d608 1
a608 1
	return(SOLTAB_NULL);
@


9.13
log
@Rather than building model RPP on a solid-by-solid basis,
now build region RPP, then union that together to form model RPP.
Region RPP calculations now take into account the
effect of booleans, following an idea due to Ed Davisson.
Infinite solids are enlisted in rti_inf_box in rt_cut_it() now.
@
text
@d24 1
a24 1
static char RCStree[] = "@@(#)$Header: tree.c,v 9.12 90/04/25 00:44:26 mike Locked $ (BRL)";
a96 1
	register struct combined_tree_state	*cts;
@


9.12
log
@Incorporated rt_add_solid directly into leaf function.
Added parallel interlocking.
Changed rt_gettrees() to take ncpus as a parameter.
@
text
@d4 2
a5 1
 * Ray Tracing program, GED tree tracer.
d7 4
d24 1
a24 1
static char RCStree[] = "@@(#)$Header: tree.c,v 9.11 90/04/12 23:12:32 mike Locked $ (BRL)";
d42 1
a42 1
HIDDEN int	rt_rpp_tree();
d100 1
d118 16
d237 1
a237 1
	RES_ACQUIRE( &rt_g.res_results );	/* enter critical section */
d241 1
a242 19
	/*
	 * Update the model maxima and minima
	 *
	 *  Don't update min & max for halfspaces;  instead, add them
	 *  to the list of infinite solids, for special handling.
	 *
	 *  XXX If this solid is subtracted, don't update model RPP either.
	 * XXX this is really wrong.  Model RPP should only be updated
	 * XXX when adding a region.
	 * XXX Region RPP should take into account the booleans.
	 */
	if( stp->st_aradius >= INFINITY )  {
		rt_cut_extend( &rt_tree_rtip->rti_inf_box, stp );
	}  else  {
		VMINMAX( rt_tree_rtip->mdl_min, rt_tree_rtip->mdl_max, stp->st_min );
		VMINMAX( rt_tree_rtip->mdl_min, rt_tree_rtip->mdl_max, stp->st_max );
	}
	RES_RELEASE( &rt_g.res_results );	/* leave critical section */

d353 1
a353 1
 *			R T _ R P P _ T R E E
d355 7
a361 3
 *	Calculate the bounding RPP of the region whose boolean tree is 'tp'.
 *	Depends on caller having initialized min_rpp and max_rpp.
 *	Returns 0 for failure (and prints a diagnostic), or 1 for success.
d363 5
a367 4
HIDDEN int
rt_rpp_tree( tp, min_rpp, max_rpp )
register union tree *tp;
register fastf_t *min_rpp, *max_rpp;
d369 1
d372 2
a373 2
		rt_log( "librt/rt_rpp_tree: NULL tree pointer.\n" );
		return(0);
d379 2
a380 3
		VMINMAX( min_rpp, max_rpp, tp->tr_a.tu_stp->st_min );
		VMINMAX( min_rpp, max_rpp, tp->tr_a.tu_stp->st_max );
		return(1);
d382 12
d395 3
a397 2
		rt_log( "librt/rt_rpp_tree: unknown op=x%x\n", tp->tr_op );
		return(0);
d399 1
d401 7
d409 8
d418 5
a422 5
	case OP_XOR:
		/* BINARY type */
		if( !rt_rpp_tree( tp->tr_b.tb_left, min_rpp, max_rpp )  ||
		    !rt_rpp_tree( tp->tr_b.tb_right, min_rpp, max_rpp )  )
			return	0;
a423 6
	case OP_NOT:
	case OP_GUARD:
		/* UNARY tree */
		if( ! rt_rpp_tree( tp->tr_b.tb_left, min_rpp, max_rpp ) )
			return	0;
		break;
d425 1
a425 1
	return	1;
d488 3
a490 3
struct rt_i		*rtip;
char			*reg_name;
register fastf_t	*min_rpp, *max_rpp;
d492 1
a492 1
	register struct region	*regp = rt_getregion( rtip, reg_name );
d496 1
d498 3
a500 3
	VMOVE( min_rpp, rtip->mdl_max );
	VMOVE( max_rpp, rtip->mdl_min );
	return( rt_rpp_tree( regp->reg_treetop, min_rpp, max_rpp ) );
@


9.11
log
@Minor improvements
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 9.10 90/04/12 04:10:29 mike Locked $ (BRL)";
a39 1
HIDDEN struct soltab *rt_add_solid();
d59 1
a59 1
static struct rt_i	*db_rtip;
d72 2
a73 2
	if( db_rtip->useair == 0 &&  tsp->ts_aircode != 0 )  {
		db_rtip->rti_air_discards++;
d82 3
d131 2
a132 2
	rp->reg_forw = db_rtip->HeadRegion;
	db_rtip->HeadRegion = rp;
d134 1
a134 1
	rp->reg_bit = db_rtip->nregions++;	/* Assign bit vector pos. */
d160 1
a161 2
	/* Note:  solid may not be contained by a region (yet) */

a162 2
	if( (stp = rt_add_solid( db_rtip, rp, dp, tsp->ts_mat, id )) == SOLTAB_NULL )
		return(TREE_NULL);
d164 78
d269 1
a269 1
	return( rt_gettrees( rtip, 1, &node ) );
d282 1
a282 1
rt_gettrees( rtip, argc, argv )
d286 1
d299 1
a299 1
	db_rtip = rtip;
d301 1
a301 2
	i = db_walk_tree( rtip->rti_dbip, argc, argv,
		1,	/* # cpus */
a311 95
}

/*
 *			R T _ A D D _ S O L I D
 *
 *  The record pointer "rec" points to all relevant records,
 *  in a contiguous in-core array.
 */
HIDDEN
struct soltab *
rt_add_solid( rtip, rec, dp, mat, id )
struct rt_i	*rtip;
union record	*rec;
struct directory *dp;
matp_t		mat;
int		id;
{
	register struct soltab *stp;
	FAST fastf_t	f;

	/*
	 *  Check to see if this exact solid has already been processed.
	 *  Match on leaf name and matrix.
	 */
	for( stp = rtip->HeadSolid; stp != SOLTAB_NULL; stp = stp->st_forw )  {
		register int i;

		if(
			dp->d_namep[0] != stp->st_name[0]  ||	/* speed */
			dp->d_namep[1] != stp->st_name[1]  ||	/* speed */
			strcmp( dp->d_namep, stp->st_name ) != 0
		)
			continue;
		for( i=0; i<16; i++ )  {
			f = mat[i] - stp->st_pathmat[i];
			if( !NEAR_ZERO(f, 0.0001) )
				goto next_one;
		}
		/* Success, we have a match! */
		if( rt_g.debug & DEBUG_SOLIDS )
			rt_log("rt_add_solid:  %s re-referenced\n",
				dp->d_namep );
		return(stp);
next_one: ;
	}

	GETSTRUCT(stp, soltab);
	stp->st_id = id;
	stp->st_dp = dp;
	stp->st_name = dp->d_namep;	/* st_name could be eliminated */
	mat_copy( stp->st_pathmat, mat );
	stp->st_specific = (genptr_t)0;

	/* init solid's maxima and minima */
	VSETALL( stp->st_max, -INFINITY );
	VSETALL( stp->st_min,  INFINITY );

	/*
	 * "rec" points to array of all relevant records, in
	 *  database format.  xxx_prep() routine is responsible for
	 *  import/export issues.
	 */
	if( rt_functab[id].ft_prep( stp, rec, rtip ) )  {
		/* Error, solid no good */
		rt_log("rt_add_solid(%s):  prep failure\n", dp->d_namep );
		rt_free( (char *)stp, "struct soltab");
		return( SOLTAB_NULL );		/* BAD */
	}
	id = stp->st_id;	/* type may have changed in prep */

	/* For now, just link them all onto the same list */
	stp->st_forw = rtip->HeadSolid;
	rtip->HeadSolid = stp;

	/*
	 * Update the model maxima and minima
	 *
	 *  Don't update min & max for halfspaces;  instead, add them
	 *  to the list of infinite solids, for special handling.
	 *
	 *  XXX If this solid is subtracted, don't update model RPP either.
	 * XXX this is really wrong.  Model RPP should only be updated
	 * XXX when adding a region.
	 * XXX Region RPP should take into account the booleans.
	 */
	if( stp->st_aradius >= INFINITY )  {
		rt_cut_extend( &rtip->rti_inf_box, stp );
	}  else  {
		VMINMAX( rtip->mdl_min, rtip->mdl_max, stp->st_min );
		VMINMAX( rtip->mdl_min, rtip->mdl_max, stp->st_max );
	}

	stp->st_bit = rtip->nsolids++;
	if(rt_g.debug&DEBUG_SOLIDS)  rt_pr_soltab( stp );
	return( stp );
@


9.10
log
@Modified to use the new support routines in db_tree and db_path
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 9.9 90/04/09 21:36:58 mike Locked $ (BRL)";
a36 1
HIDDEN void	rt_add_regtree();
d62 5
d80 5
a102 2
	/* XXX This should be semaphore protected! */
	rp->reg_instnum = dp->d_uses++;
d109 7
a115 1
	/* Mark all solids & nodes as belonging to this region */
d117 1
d119 23
a141 2
	rt_add_regtree( db_rtip, rp, curtree );
	return(curtree);
d144 5
a596 37

/*
 *  			R T _ A D D _ R E G T R E E
 *  
 *  Add a region and it's boolean tree to all the appropriate places.
 *  The region and treetop are cross-linked, and the region is added
 *  to the linked list of regions.
 *  Positions in the region bit vector are established at this time.
 */
HIDDEN void
rt_add_regtree( rtip, regp, tp )
register struct rt_i	*rtip;
register struct region	*regp;
register union tree	*tp;
{

	/* Cross-reference */
	regp->reg_treetop = tp;
	tp->tr_regionp = regp;
	/* Add to linked list */
	regp->reg_forw = rtip->HeadRegion;
	rtip->HeadRegion = regp;

	/* Determine material properties */
	regp->reg_mfuncs = (char *)0;
	regp->reg_udata = (char *)0;
	if( regp->reg_mater.ma_override == 0 )
		rt_region_color_map(regp);

	regp->reg_bit = rtip->nregions;	/* Add to bit vectors */
	/* Will be added to rtip->Regions[] in final prep stage */
	rtip->nregions++;
	if( rt_g.debug & DEBUG_REGIONS )  {
		rt_log("Add Region %s instnum %d\n",
			regp->reg_name, regp->reg_instnum);
	}
}
@


9.9
log
@Changed for new definition of st_specific.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 9.8 90/02/26 15:00:48 mike Locked $ (BRL)";
d37 2
a38 4
HIDDEN union tree *rt_drawobj();
HIDDEN void rt_add_regtree();
HIDDEN union tree *rt_mkbool_tree();
HIDDEN int rt_rpp_tree();
d41 2
a42 2
extern int	rt_id_solid();
extern void	rt_pr_soltab();
a43 1
HIDDEN char *rt_path_str();
d45 4
a48 1
static struct mater_info rt_no_mater = {
d52 7
a58 1
	DB_INH_LOWER		/* mater inherit */
d61 77
d139 7
a145 3
 * Note that while GED has a more limited MAXLEVELS, GED can
 * work on sub-trees, while RT must be able to process the full tree.
 * Thus the difference, and the large value here.
d147 7
a153 2
#define	MAXLEVELS	64
static struct directory	*path[MAXLEVELS];	/* Record of current path */
d156 1
a156 1
 *  			R T _ G E T _ T R E E
d158 1
a158 1
 *  User-called function to add a tree hierarchy to the displayed set.
d165 4
a168 3
rt_gettree( rtip, node)
struct rt_i *rtip;
char *node;
d170 2
a171 5
	register union tree *curtree;
	register struct directory *dp;
	mat_t	root;
	struct mater_info root_mater;
	int	prev_sol_count;
d176 1
a176 1
		rt_bomb("rt_gettree called again after rt_prep!");
d178 1
a178 1
	root_mater = rt_no_mater;	/* struct copy */
a179 3
	if( (dp = db_lookup( rtip->rti_dbip, node, LOOKUP_NOISY )) == DIR_NULL )
		return(-1);		/* ERROR */

d181 1
d183 6
a188 5
	/* Process animations located at the root */
	mat_idn( root );
	if( rtip->rti_anroot )  {
		register struct animate *anp;
		mat_t	temp_root, arc;
d190 1
a190 9
		for( anp=rtip->rti_anroot; anp != ANIM_NULL; anp = anp->an_forw ) {
			if( dp != anp->an_path[0] )
				continue;
			mat_copy( temp_root, root );
			mat_idn( arc );
			rt_do_anim( anp, temp_root, arc, &root_mater );
			mat_mul( root, temp_root, arc );
		}
	}
a191 17
	curtree = rt_drawobj( rtip, dp, REGION_NULL, 0, root, &root_mater );
	if( curtree != TREE_NULL )  {
		/*  Subtree has not been contained by a region.
		 *  This should only happen when a top-level solid
		 *  is encountered.  Build a special region for it.
		 */
		register struct region *regionp;	/* XXX */

		GETSTRUCT( regionp, region );
		rt_log("Warning:  Top level solid, region %s created\n",
			rt_path_str(path,0) );
		if( curtree->tr_op != OP_SOLID )
			rt_bomb("root subtree not Solid");
		regionp->reg_name = rt_strdup(rt_path_str(path,0));
		rt_add_regtree( rtip, regionp, curtree );
	}

d193 1
a193 1
		rt_log("rt_gettree(%s) warning:  no solids found\n", node);
a196 4
static vect_t xaxis = { 1.0, 0, 0 };
static vect_t yaxis = { 0, 1.0, 0 };
static vect_t zaxis = { 0, 0, 1.0 };

d205 1
a205 1
rt_add_solid( rtip, rec, dp, mat )
d210 1
a212 2
	static vect_t	A, B, C;
	static fastf_t	fx, fy, fz;
a213 2
	register struct soltab *nsp;
	int id;
a214 18
	/* Validate that matrix preserves perpendicularity of axis */
	/* by checking that A.B == 0, B.C == 0, A.C == 0 */
	/* XXX these vectors should just be grabbed out of the matrix */
	MAT4X3VEC( A, mat, xaxis );
	MAT4X3VEC( B, mat, yaxis );
	MAT4X3VEC( C, mat, zaxis );
	fx = VDOT( A, B );
	fy = VDOT( B, C );
	fz = VDOT( A, C );
	if( ! NEAR_ZERO(fx, 0.0001) ||
	    ! NEAR_ZERO(fy, 0.0001) ||
	    ! NEAR_ZERO(fz, 0.0001) )  {
		rt_log("rt_add_solid(%s):  matrix does not preserve axis perpendicularity.\n  X.Y=%g, Y.Z=%g, X.Z=%g\n",
			dp->d_namep, fx, fy, fz );
		mat_print("bad matrix", mat);
		return( SOLTAB_NULL );		/* BAD */
	}

d219 1
a219 1
	for( nsp = rtip->HeadSolid; nsp != SOLTAB_NULL; nsp = nsp->st_forw )  {
d223 3
a225 3
			dp->d_namep[0] != nsp->st_name[0]  ||	/* speed */
			dp->d_namep[1] != nsp->st_name[1]  ||	/* speed */
			strcmp( dp->d_namep, nsp->st_name ) != 0
d229 1
a229 1
			f = mat[i] - nsp->st_pathmat[i];
d237 1
a237 1
		return(nsp);
a240 9
	if( (id = rt_id_solid( rec )) == ID_NULL )  {
		rt_log("rt_add_solid(%s) unable to convert solid id\n",
			dp->d_namep);
		return( SOLTAB_NULL );		/* BAD */
	}

	if( id < 0 || id >= rt_nfunctab )
		rt_bomb("rt_add_solid:  bad st_id");

d276 3
a291 5
struct tree_list {
	union tree *tl_tree;
	int	tl_op;
};

d293 5
a297 1
 *			R T _ D R A W _ O B J
d299 3
a301 332
 * This routine is used to get an object drawn.
 * The actual processing of solids is performed by rt_add_solid(),
 * but all transformations and region building is done here.
 *
 * NOTE that this routine is used recursively, so no variables may
 * be declared static.
 */
HIDDEN
union tree *
rt_drawobj( rtip, dp, argregion, pathpos, old_xlate, materp )
struct rt_i	*rtip;
struct directory *dp;
struct region	*argregion;
int		pathpos;
matp_t		old_xlate;
struct mater_info *materp;
{
	union record	*rp;
	register int	i;
	auto int	j;
	union tree	*curtree = TREE_NULL;/* cur tree top, ret. code */
	struct region	*regionp;
	int		subtreecount;	/* number of non-null subtrees */
	struct tree_list *trees = (struct tree_list *)0;/* ptr to ary of structs */
	struct tree_list *tlp;		/* cur tree_list */
	struct mater_info curmater;

	if( pathpos >= MAXLEVELS )  {
		rt_log("%s: nesting exceeds %d levels\n",
			rt_path_str(path,MAXLEVELS), MAXLEVELS );
		return(TREE_NULL);
	}
	path[pathpos] = dp;

	if( (rp = db_getmrec( rtip->rti_dbip, dp )) == (union record *)0 )
		return(TREE_NULL);
	/* Any "return" below here must release "rp" dynamic memory */

	/*
	 *  Draw a solid
	 */
	if( rp->u_id != ID_COMB )  {
		register struct soltab *stp;

		if( rt_id_solid( rp ) == ID_NULL )  {
			rt_log("rt_drawobj(%s): defective database record, type '%c' (0%o), addr=x%x\n",
				dp->d_namep,
				rp->u_id, rp->u_id, dp->d_addr );
			goto null;
		}

		if( (stp = rt_add_solid( rtip, rp, dp, old_xlate )) ==
		    SOLTAB_NULL )
			goto out;

		/**GETSTRUCT( curtree, union tree ); **/
		if( (curtree=(union tree *)rt_malloc(sizeof(union tree), "solid tree"))
		    == TREE_NULL )
			rt_bomb("rt_drawobj: solid tree malloc failed\n");
		bzero( (char *)curtree, sizeof(union tree) );
		curtree->tr_op = OP_SOLID;
		curtree->tr_a.tu_stp = stp;
		curtree->tr_a.tu_name = rt_strdup(rt_path_str(path,pathpos));
		curtree->tr_regionp = argregion;
		goto out;
	}

	/*
	 *  At this point, u_id == ID_COMB.
	 *  Process a Combination (directory) node
	 */
	if( dp->d_len <= 1 )  {
		rt_log(  "Warning: combination with zero members \"%s\".\n",
			dp->d_namep );
		goto null;
	}
	regionp = argregion;

	/*
	 *  Handle inheritance of material property.
	 *  Color and the material property have separate
	 *  inheritance interlocks.
	 */
	curmater = *materp;	/* struct copy */
	if( rp->c.c_override == 1 )  {
		if( argregion != REGION_NULL )  {
			rt_log("rt_drawobj: ERROR: color override in combination within region %s\n",
				argregion->reg_name );
		} else {
			if( curmater.ma_cinherit == DB_INH_LOWER )  {
				curmater.ma_override = 1;
				curmater.ma_color[0] = (rp->c.c_rgb[0])*rt_inv255;
				curmater.ma_color[1] = (rp->c.c_rgb[1])*rt_inv255;
				curmater.ma_color[2] = (rp->c.c_rgb[2])*rt_inv255;
				curmater.ma_cinherit = rp->c.c_inherit;
			}
		}
	}
	if( rp->c.c_matname[0] != '\0' )  {
		if( argregion != REGION_NULL )  {
			rt_log("rt_drawobj: ERROR: material property spec in combination within region %s\n",
				argregion->reg_name );
		} else {
			if( curmater.ma_minherit == DB_INH_LOWER )  {
				strncpy( curmater.ma_matname, rp->c.c_matname, sizeof(rp->c.c_matname) );
				strncpy( curmater.ma_matparm, rp->c.c_matparm, sizeof(rp->c.c_matparm) );
				curmater.ma_minherit = rp->c.c_inherit;
			}
		}
	}

	/* Handle combinations which are the top of a "region" */
	if( rp->c.c_flags == 'R' )  {
		if( argregion != REGION_NULL )  {
			if(rt_g.debug&DEBUG_REGIONS)  {
				rt_log("Warning:  region %s below region %s, ignored\n",
					rt_path_str(path,pathpos),
					argregion->reg_name );
			}
			/* Just go on as if it was not a region */
		} else {
			register struct region *nrp;

			/* Ignore "air" regions unless wanted */
			if( rtip->useair == 0 &&  rp->c.c_aircode != 0 )  {
				rtip->rti_air_discards++;
				goto null;
			}

			/* Start a new region here */
			GETSTRUCT( nrp, region );
			nrp->reg_forw = REGION_NULL;
			nrp->reg_regionid = rp->c.c_regionid;
			nrp->reg_aircode = rp->c.c_aircode;
			nrp->reg_gmater = rp->c.c_material;
			nrp->reg_name = rt_strdup(rt_path_str(path,pathpos));
			nrp->reg_instnum = dp->d_uses++; /* after rt_path_str() */
			nrp->reg_mater = curmater;	/* struct copy */
			/* Material property processing in rt_add_regtree() */
			regionp = nrp;
		}
	}

	/* Process all the member records */
	j = sizeof(struct tree_list) * (dp->d_len-1);
	if( (trees = (struct tree_list *)rt_malloc( j, "tree_list array" )) ==
	    (struct tree_list *)0 )
		rt_bomb("rt_drawobj:  malloc failure\n");

	/* Process and store all the sub-trees */
	subtreecount = 0;
	tlp = trees;
	for( i = 1; i < dp->d_len; i++ )  {
		register struct member *mp;
		auto struct directory *nextdp;
		auto mat_t new_xlate;		/* Accum translation mat */
		auto struct mater_info newmater;
		mat_t xmat;		/* temp fastf_t matrix for conv */

		mp = &(rp[i].M);
		if( mp->m_id != ID_MEMB )  {
			rt_log("rt_drawobj:  defective member of %s\n", dp->d_namep);
			continue;
		}
		/* m_instname needs trimmed here! */
		if( (nextdp = db_lookup( rtip->rti_dbip, mp->m_instname,
		    LOOKUP_NOISY )) == DIR_NULL )
			continue;

		newmater = curmater;	/* struct copy -- modified below */

		/* convert matrix to fastf_t from disk format */
		rt_mat_dbmat( xmat, mp->m_mat );

		/* Check here for animation to apply */
		{
			register struct animate *anp;

			if ((nextdp->d_animate != ANIM_NULL) &&
			    (rt_g.debug & DEBUG_ANIM)) {
				rt_log("Animate %s/%s with...\n",
				    rt_path_str(path,pathpos),mp->m_instname);
			}
			for( anp = nextdp->d_animate; anp != ANIM_NULL; anp = anp->an_forw ) {
				register int i = anp->an_pathlen-2;
				/*
				 * pathlen - 1 would point to the leaf (a
				 * solid), but the solid is implicit in "path"
				 * so we need to backup "2" such that we point
				 * at the combination just above this solid.
				 */
				register int j = pathpos;

				if (rt_g.debug & DEBUG_ANIM) {
					rt_log("\t%s\t",rt_path_str(
					    anp->an_path, anp->an_pathlen-1));
				}
				for( ; i>=0 && j>=0; i--, j-- )  {
					if( anp->an_path[i] != path[j] )  {
						if (rt_g.debug & DEBUG_ANIM) {
							rt_log("%s != %s\n",
							     anp->an_path[i]->d_namep,
							     path[j]->d_namep);
						}
						goto next_one;
					}
				}
				rt_do_anim( anp,
					old_xlate, xmat, &newmater );
next_one:			;
			}
			mat_mul(new_xlate, old_xlate, xmat);
		}

		/* Recursive call */
		if( (tlp->tl_tree = rt_drawobj( rtip,
		    nextdp, regionp, pathpos+1, new_xlate, &newmater )
		    ) == TREE_NULL )
			continue;

		if( regionp == REGION_NULL )  {
			register struct region *xrp;
			/*
			 * Found subtree that is not contained in a region;
			 * invent a region to hold JUST THIS SOLID,
			 * and add it to the region chain.  Don't force
			 * this whole combination into this region, because
			 * other subtrees might themselves contain regions.
			 * This matches GIFT's current behavior.
			 */
			rt_log("Warning:  Forced to create region %s\n",
				rt_path_str(path, pathpos+1) );
			if((tlp->tl_tree)->tr_op != OP_SOLID )
				rt_bomb("subtree not Solid");
			GETSTRUCT( xrp, region );
			xrp->reg_name = rt_strdup(rt_path_str(path, pathpos+1));
			rt_add_regtree( rtip, xrp, (tlp->tl_tree) );
			tlp->tl_tree = TREE_NULL;
			continue;	/* no remaining subtree, go on */
		}

		/* Store operation on subtree */
		switch( mp->m_relation )  {
		default:
			rt_log("%s: bad m_relation '%c'\n",
				regionp->reg_name, mp->m_relation );
			/* FALL THROUGH */
		case UNION:
			tlp->tl_op = OP_UNION;
			break;
		case SUBTRACT:
			tlp->tl_op = OP_SUBTRACT;
			break;
		case INTERSECT:
			tlp->tl_op = OP_INTERSECT;
			break;
		}
		subtreecount++;
		tlp++;
	}

	if( subtreecount <= 0 )  {
		/* Null subtree in region, release region struct */
		if( argregion == REGION_NULL && regionp != REGION_NULL )  {
			rt_free( regionp->reg_name, "unused region name" );
			rt_free( (char *)regionp, "unused region struct" );
		}
		curtree = TREE_NULL;
		goto out;
	}

	/* Build tree representing boolean expression in Member records */
	if( rt_pure_boolean_expressions )  {
		curtree = rt_mkbool_tree( trees, subtreecount, regionp );
	} else {
		register struct tree_list *tstart;

		/*
		 * This is the way GIFT interpreted equations, so we
		 * duplicate it here.  Any expressions between UNIONs
		 * is evaluated first, eg:
		 *	A - B - C u D - E - F
		 * is	(A - B - C) u (D - E - F)
		 * so first we do the parenthesised parts, and then go
		 * back and glue the unions together.
		 * As always, unions are the downfall of free enterprise!
		 */
		tstart = trees;
		tlp = trees+1;
		for( i=subtreecount-1; i>=0; i--, tlp++ )  {
			/* If we went off end, or hit a union, do it */
			if( i>0 && tlp->tl_op != OP_UNION )
				continue;
			if( (j = tlp-tstart) <= 0 )
				continue;
			tstart->tl_tree = rt_mkbool_tree( tstart, j, regionp );
			if(rt_g.debug&DEBUG_REGIONS) rt_pr_tree(tstart->tl_tree, 0);
			/* has side effect of zapping all trees,
			 * so build new first node */
			tstart->tl_op = OP_UNION;
			/* tstart here at union */
			tstart = tlp;
		}
		curtree = rt_mkbool_tree( trees, subtreecount, regionp );
		if(rt_g.debug&DEBUG_REGIONS) rt_pr_tree(curtree, 0);
	}

	if( argregion == REGION_NULL )  {
		/* Region began at this level */
		rt_add_regtree( rtip, regionp, curtree );
		curtree = TREE_NULL;		/* no remaining subtree */
	}

	/* Release dynamic memory and return */
out:
	if( trees )  rt_free( (char *)trees, "tree_list array");
	if( rp )  rt_free( (char *)rp, "rt_drawobj records");
	return( curtree );
null:
	if( trees )  rt_free( (char *)trees, "tree_list array");
	if( rp )  rt_free( (char *)rp, "rt_drawobj records");
	return( TREE_NULL );				/* ERROR */
}

/*
 *			R T _ M K B O O L _ T R E E
 *
 *  Given a tree_list array, build a tree of "union tree" nodes
 *  appropriately connected together.  Every element of the
 *  tree_list array used is replaced with a TREE_NULL.
 *  Elements which are already TREE_NULL are ignored.
 *  Returns a pointer to the top of the tree.
a302 99
HIDDEN union tree *
rt_mkbool_tree( tree_list, howfar, regionp )
struct tree_list *tree_list;
int		howfar;
struct region	*regionp;
{
	register struct tree_list *tlp;
	register int		i;
	register struct tree_list *first_tlp = (struct tree_list *)0;
	register union tree	*xtp;
	register union tree	*curtree;
	register int		inuse;

	if( howfar <= 0 )
		return(TREE_NULL);

	/* Count number of non-null sub-trees to do */
	for( i=howfar, inuse=0, tlp=tree_list; i>0; i--, tlp++ )  {
		if( tlp->tl_tree == TREE_NULL )
			continue;
		if( inuse++ == 0 )
			first_tlp = tlp;
	}
	if( rt_g.debug & DEBUG_REGIONS && first_tlp->tl_op != OP_UNION )
		rt_log("Warning: %s: non-union first operation ignored\n",
			regionp->reg_name);

	/* Handle trivial cases */
	if( inuse <= 0 )
		return(TREE_NULL);
	if( inuse == 1 )  {
		curtree = first_tlp->tl_tree;
		first_tlp->tl_tree = TREE_NULL;
		return( curtree );
	}

	/* Allocate all the tree structs we will need */
	i = sizeof(union tree)*(inuse-1);
	if( (xtp=(union tree *)rt_malloc( i, "tree array")) == TREE_NULL )
		rt_bomb("rt_mkbool_tree: malloc failed\n");
	bzero( (char *)xtp, i );

	curtree = first_tlp->tl_tree;
	first_tlp->tl_tree = TREE_NULL;
	tlp=first_tlp+1;
	for( i=howfar-(tlp-tree_list); i>0; i--, tlp++ )  {
		if( tlp->tl_tree == TREE_NULL )
			continue;

		xtp->tr_b.tb_left = curtree;
		xtp->tr_b.tb_right = tlp->tl_tree;
		xtp->tr_b.tb_regionp = regionp;
		xtp->tr_op = tlp->tl_op;
		curtree = xtp++;
		tlp->tl_tree = TREE_NULL;	/* empty the input slot */
	}
	return(curtree);
}

/*
 *			R T _ P A T H _ S T R
 */
HIDDEN char *
rt_path_str( whichpath, pos )
struct directory *whichpath[];
int pos;
{
	static char line[MAXLEVELS*(NAMESIZE+2)+10];
	register char *cp = &line[0];
	register int i;
	register struct directory	*dp;

	if( pos >= MAXLEVELS )  pos = MAXLEVELS-1;
	line[0] = '/';
	line[1] = '\0';
	for( i=0; i<=pos; i++ )  {
		(void)sprintf( cp, "/%s", (dp=whichpath[i])->d_namep );
		cp += strlen(cp);
#if 1
		/* This should be superceeded by reg_instnum soon */
		if( (dp->d_flags & DIR_REGION) || dp->d_uses > 0 )  {
			(void)sprintf( cp, "{{%d}}", dp->d_uses );
			cp += strlen(cp);
		}
#endif
	}
	return( &line[0] );
}

/*
 *			R T _ P L O O K U P
 * 
 *  Look up a path where the elements are separates by slashes,
 *  filling in the path[] array along the way.  Leading slashes
 *  have no significance.  If the whole path is valid, malloc space
 *  and duplicate the used portion of the path[] array, and set the
 *  callers pointer to point there.  The return is the number of
 *  elements in the path, or 0 or -1 on error.
 */
d310 2
a311 5
	int	depth;
	char	oldc;
	register char *ep;
	struct directory *dp;
	struct directory **newpath;
d313 5
a317 1
	RT_CHECK_RTI(rtip);
d319 2
a320 2
	depth = 0;
	if( *cp == '\0' )  return(-1);
d322 2
a323 26
	/* First, look up the names of the individual path elements */
	do {
		while( *cp && *cp == '/' )
			cp++;		/* skip leading slashes */
		ep = cp;
		while( *ep != '\0' && *ep != '/' )
			ep++;		/* walk over element name */
		oldc = *ep;
		*ep = '\0';
		if( (dp = db_lookup( rtip->rti_dbip, cp, noisy )) == DIR_NULL )
			return(-1);
		path[depth++] = dp;
		cp = ep+1;
	} while( oldc != '\0' );

	/* Here, it might make sense to see if path[n+1] is
	 * actually mentioned in path[n], but save that for later...
	 */

	/* Successful conversion of path, duplicate and return */
	newpath = (struct directory **) rt_malloc(
		 depth*sizeof(struct directory *), "rt_plookup newpath");
	bcopy( (char *)path, (char *)newpath,
		depth*sizeof(struct directory *) );
	*dirp = newpath;
	return( depth );
d657 1
a657 5
 *  			S O L I D _ B I T F I N D E R
 *  
 *  Used to walk the boolean tree, setting bits for all the solids in the tree
 *  to the provided bit vector.  Should be called AFTER the region bits
 *  have been assigned.
d660 3
a662 4
rt_solid_bitfinder( treep, regbit, resp )
register union tree	*treep;
register int		regbit;
struct resource		*resp;
d664 4
a667 3
	register union tree	**sp;
	register struct soltab	*stp;
	register union tree	**stackend;
d669 18
a686 36
	while( (sp = resp->re_boolstack) == (union tree **)0 )
		rt_grow_boolstack( resp );
	stackend = &(resp->re_boolstack[resp->re_boolslen-1]);
	*sp++ = TREE_NULL;
	*sp++ = treep;
	while( (treep = *--sp) != TREE_NULL ) {
		switch( treep->tr_op )  {
		case OP_SOLID:
			stp = treep->tr_a.tu_stp;
			BITSET( stp->st_regions, regbit );
			if( !BITTEST( stp->st_regions, regbit ) )
				rt_bomb("BITSET failure\n");	/* sanity check */
			if( regbit+1 > stp->st_maxreg )  stp->st_maxreg = regbit+1;
			if( rt_g.debug&DEBUG_REGIONS )  {
				rt_pr_bitv( stp->st_name, stp->st_regions,
					stp->st_maxreg );
			}
			break;
		case OP_UNION:
		case OP_INTERSECT:
		case OP_SUBTRACT:
			/* BINARY type */
			/* push both nodes - search left first */
			*sp++ = treep->tr_b.tb_right;
			*sp++ = treep->tr_b.tb_left;
			if( sp >= stackend )  {
				register int off = sp - resp->re_boolstack;
				rt_grow_boolstack( resp );
				sp = &(resp->re_boolstack[off]);
				stackend = &(resp->re_boolstack[resp->re_boolslen-1]);
			}
			break;
		default:
			rt_log("rt_solid_bitfinder:  op=x%x\n", treep->tr_op);
			break;
		}
@


9.8
log
@Region-within-region warnings are now only printed if region debugging
is on.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 9.7 89/12/31 00:13:42 mike Locked $ (BRL)";
d216 1
a216 1
	stp->st_specific = (int *)0;
@


9.7
log
@Moved various structure printing routines to module pr.c
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 9.6 89/12/30 05:22:25 mike Locked $ (BRL)";
d381 6
a386 3
			rt_log("Warning:  region %s below region %s, ignored\n",
				rt_path_str(path,pathpos),
				argregion->reg_name );
@


9.6
log
@Added counting of solids discarded due to being in air regions.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 9.5 89/12/09 01:29:14 mike Locked $ (BRL)";
d83 1
a83 5
	if( rtip->rti_magic != RTI_MAGIC )  {
		rt_log("rtip=x%x, rti_magic=x%x s/b x%x\n", rtip,
			rtip->rti_magic, RTI_MAGIC );
		rt_bomb("rt_gettree:  bad rtip\n");
	}
d709 1
a709 1
	if( rtip->rti_magic != RTI_MAGIC )  rt_bomb("rt_plookup:  bad rtip\n");
a742 93
 *			R T _ P R _ R E G I O N
 */
void
rt_pr_region( rp )
register struct region *rp;
{
	rt_log("REGION %s (bit %d)\n", rp->reg_name, rp->reg_bit );
	rt_log("instnum=%d, id=%d, air=%d, gift_material=%d, los=%d\n",
		rp->reg_instnum,
		rp->reg_regionid, rp->reg_aircode,
		rp->reg_gmater, rp->reg_los );
	if( rp->reg_mater.ma_override == 1 )
		rt_log("Color %d %d %d\n",
			(int)rp->reg_mater.ma_color[0]*255.,
			(int)rp->reg_mater.ma_color[1]*255.,
			(int)rp->reg_mater.ma_color[2]*255. );
	if( rp->reg_mater.ma_matname[0] != '\0' )
		rt_log("Material '%s' '%s'\n",
			rp->reg_mater.ma_matname,
			rp->reg_mater.ma_matparm );
	rt_pr_tree( rp->reg_treetop, 0 );
	rt_log("\n");
}

/*
 *			R T _ P R _ T R E E
 */
void
rt_pr_tree( tp, lvl )
register union tree *tp;
int lvl;			/* recursion level */
{
	register int i;

	rt_log("%.8x ", tp);
	for( i=lvl; i>0; i-- )
		rt_log("  ");

	if( tp == TREE_NULL )  {
		rt_log("Null???\n");
		return;
	}

	switch( tp->tr_op )  {

	case OP_SOLID:
		rt_log("SOLID %s (bit %d)",
			tp->tr_a.tu_stp->st_name,
			tp->tr_a.tu_stp->st_bit );
		break;

	default:
		rt_log("Unknown op=x%x\n", tp->tr_op );
		return;

	case OP_UNION:
		rt_log("UNION");
		break;
	case OP_INTERSECT:
		rt_log("INTERSECT");
		break;
	case OP_SUBTRACT:
		rt_log("MINUS");
		break;
	case OP_XOR:
		rt_log("XOR");
		break;
	case OP_NOT:
		rt_log("NOT");
		break;
	}
	rt_log("\n");

	switch( tp->tr_op )  {
	case OP_SOLID:
		break;
	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		/* BINARY type */
		rt_pr_tree( tp->tr_b.tb_left, lvl+1 );
		rt_pr_tree( tp->tr_b.tb_right, lvl+1 );
		break;
	case OP_NOT:
	case OP_GUARD:
		/* UNARY tree */
		rt_pr_tree( tp->tr_b.tb_left, lvl+1 );
		break;
	}
}

/*
d856 1
a856 1
	if( rtip->rti_magic != RTI_MAGIC )  rt_bomb("rt_rpp_region:  bad rtip\n");
d962 1
a962 1
	if( rtip->rti_magic != RTI_MAGIC )  rt_bomb("rt_find_solid:  bad rtip\n");
a1125 26
}

/*
 *			R T _ P R _ S O L T A B
 */
void
rt_pr_soltab( stp )
register struct soltab	*stp;
{
	register int	id = stp->st_id;

	if( id <= 0 || id > ID_MAXIMUM )  {
		rt_log("stp=x%x, id=%d.\n", stp, id);
		rt_bomb("rt_pr_soltab:  bad st_id");
	}
	rt_log("------------ %s (bit %d) %s ------------\n",
		stp->st_name, stp->st_bit,
		rt_functab[id].ft_name );
	VPRINT("Bound Sph CENTER", stp->st_center);
	rt_log("Approx Sph Radius = %g\n", stp->st_aradius);
	rt_log("Bounding Sph Radius = %g\n", stp->st_bradius);
	VPRINT("Bound RPP min", stp->st_min);
	VPRINT("Bound RPP max", stp->st_max);
	rt_pr_bitv( "Referenced by Regions",
		stp->st_regions, stp->st_maxreg );
	rt_functab[id].ft_print( stp );
@


9.5
log
@Added additional debugging.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 9.4 89/12/08 06:00:22 mike Locked $ (BRL)";
d164 1
d392 2
a393 1
			if( rtip->useair == 0 &&  rp->c.c_aircode != 0 )
d395 1
@


9.4
log
@Moved rt_id_solid() into table.c
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 9.3 89/10/13 20:37:18 mike Locked $ (BRL)";
d81 1
d97 2
d131 3
d205 3
a207 1
	if( (id = rt_id_solid( rec )) == ID_NULL )  
d209 1
d232 1
@


9.3
log
@Added temporary special case for ID_VOL
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 9.2 89/10/10 16:12:35 mike Exp $ (BRL)";
d43 1
a43 1
extern int rt_id_solid();
a45 34
extern struct rt_functab	rt_functab[];
extern int			rt_nfunctab;

/* Map for database solidrec objects to internal objects */
static char idmap[] = {
	ID_NULL,	/* undefined, 0 */
	ID_NULL,	/* RPP	1 axis-aligned rectangular parallelopiped */
	ID_NULL,	/* BOX	2 arbitrary rectangular parallelopiped */
	ID_NULL,	/* RAW	3 right-angle wedge */
	ID_NULL,	/* ARB4	4 tetrahedron */
	ID_NULL,	/* ARB5	5 pyramid */
	ID_NULL,	/* ARB6	6 extruded triangle */
	ID_NULL,	/* ARB7	7 weird 7-vertex shape */
	ID_NULL,	/* ARB8	8 hexahedron */
	ID_NULL,	/* ELL	9 ellipsoid */
	ID_NULL,	/* ELL1	10 another ellipsoid ? */
	ID_NULL,	/* SPH	11 sphere */
	ID_NULL,	/* RCC	12 right circular cylinder */
	ID_NULL,	/* REC	13 right elliptic cylinder */
	ID_NULL,	/* TRC	14 truncated regular cone */
	ID_NULL,	/* TEC	15 truncated elliptic cone */
	ID_TOR,		/* TOR	16 toroid */
	ID_NULL,	/* TGC	17 truncated general cone */
	ID_TGC,		/* GENTGC 18 supergeneralized TGC; internal form */
	ID_ELL,		/* GENELL 19: V,A,B,C */
	ID_ARB8,	/* GENARB8 20:  V, and 7 other vectors */
	ID_NULL,	/* HACK: ARS 21: arbitrary triangular-surfaced polyhedron */
	ID_NULL,	/* HACK: ARSCONT 22: extension record type for ARS solid */
	ID_NULL,	/* ELLG 23:  gift-only */
	ID_HALF,	/* HALFSPACE 24:  halfspace */
	ID_NULL,	/* HACK: SPLINE 25 */
	ID_NULL		/* n+1 */
};

a249 52
}

/*
 *			R T _ I D _ S O L I D
 *
 *  Given a database record, determine the proper rt_functab subscript.
 *  Used by MGED as well as internally to librt.
 *
 *  Returns ID_xxx if successful, or ID_NULL upon failure.
 */
int
rt_id_solid( rec )
register union record *rec;
{
	register int id;

	switch( rec->u_id )  {
	case ID_SOLID:
		id = idmap[rec->s.s_type];
		break;
	case ID_ARS_A:
		id = ID_ARS;
		break;
	case ID_P_HEAD:
		id = ID_POLY;
		break;
	case ID_BSOLID:
		id = ID_BSPLINE;
		break;
	case ID_STRSOL:
		/* XXX This really needs to be some kind of table */
		if( strncmp( rec->ss.ss_str, "ebm", 3 ) == 0 )  {
			id = ID_EBM;
			break;
		} else if( strncmp( rec->ss.ss_str, "vol", 3 ) == 0 )  {
			id = ID_VOL;
			break;
		}
		rt_log("rt_id_solid(%s):  String solid type '%s' unknown\n",
			rec->ss.ss_name, rec->ss.ss_str );
		id = ID_NULL;		/* BAD */
		break;
	default:
		rt_log("rt_id_solid:  u_id=x%x unknown\n", rec->u_id);
		id = ID_NULL;		/* BAD */
		break;
	}
	if( id < ID_NULL || id > ID_MAXIMUM )  {
		rt_log("rt_id_solid: internal error, id=%d?\n", id);
		id = ID_NULL;		/* very BAD */
	}
	return(id);
@


9.2
log
@Added initial support for string solids (preliminary).
Moved some subroutines into prep.c
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 9.1 89/05/19 05:57:35 mike Rel3_5 $ (BRL)";
d318 3
d330 4
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 8.15 89/04/28 00:29:35 mike Exp $ (BRL)";
a36 2
extern struct resource	rt_uniresource;		/* from shoot.c */

a42 1
HIDDEN void rt_fr_tree();
d291 2
d313 10
d380 1
a380 2
	if( rp->u_id == ID_SOLID || rp->u_id == ID_ARS_A ||
	    rp->u_id == ID_P_HEAD || rp->u_id == ID_BSOLID )  {
d383 7
a405 7
	if( rp->u_id != ID_COMB )  {
		rt_log("rt_drawobj:  %s defective database record, type '%c' (0%o), addr=x%x\n",
			dp->d_namep,
			rp->u_id, rp->u_id, dp->d_addr );
		goto null;
	}

d407 1
a1174 45
 *			R T _ D E L _ R E G T R E E
 *
 *  Remove a region from the linked list.  Used to remove a particular
 *  region from the active database, presumably after some useful
 *  information has been extracted (eg, a light being converted to
 *  implicit type), or for special effects.
 *
 *  Returns -
 *	-1	if unable to find indicated region
 *	 0	success
 */
int
rt_del_regtree( rtip, delregp )
struct rt_i *rtip;
register struct region *delregp;
{
	register struct region *regp;
	register struct region *nextregp;

	regp = rtip->HeadRegion;
	if( rt_g.debug & DEBUG_REGIONS )
		rt_log("Del Region %s\n", delregp->reg_name);

	if( regp == delregp )  {
		rtip->HeadRegion = regp->reg_forw;
		goto zot;
	}

	for( ; regp != REGION_NULL; regp=nextregp )  {
		nextregp=regp->reg_forw;
		if( nextregp == delregp )  {
			regp->reg_forw = nextregp->reg_forw;	/* unlink */
			goto zot;
		}
	}
	rt_log("rt_del_region:  unable to find %s\n", delregp->reg_name);
	return(-1);
zot:
	rt_fr_tree( delregp->reg_treetop );
	rt_free( delregp->reg_name, "region name str");
	rt_free( (char *)delregp, "struct region");
	return(0);
}

/*
a1235 29
 *			R T _ F R  _ T R E E
 *
 *  Free a boolean operation tree.
 *  XXX should iterate, rather than recurse.
 */
HIDDEN void
rt_fr_tree( tp )
register union tree *tp;
{

	switch( tp->tr_op )  {
	case OP_SOLID:
		rt_free( (char *)tp, "leaf tree union");
		return;
	case OP_SUBTRACT:
	case OP_UNION:
	case OP_INTERSECT:
	case OP_XOR:
		rt_fr_tree( tp->tr_b.tb_left );
		rt_fr_tree( tp->tr_b.tb_right );
		/*rt_free( (char *)tp, "binary tree union"); XXX*/
		return;
	default:
		rt_log("rt_fr_tree: bad op x%x\n", tp->tr_op);
		return;
	}
}

/*
a1288 218
}

/*
 *  			R T _ P R E P
 *  
 *  This routine should be called just before the first call to rt_shootray().
 *  It should only be called ONCE per execution, unless rt_clean() is
 *  called inbetween.
 */
void
rt_prep(rtip)
register struct rt_i *rtip;
{
	register struct region *regp;
	register struct soltab *stp;
	register int		i;

	if( rtip->rti_magic != RTI_MAGIC )  rt_bomb("rt_prep:  bad rtip\n");

	if(!rtip->needprep)
		rt_bomb("rt_prep: re-invocation");
	rtip->needprep = 0;
	if( rtip->nsolids <= 0 )
		rt_bomb("rt_prep:  no solids to prep");

	/* Compute size of model-specific variable-length data structures */
	/* -sizeof(bitv_t) == sizeof(struct partition.pt_solhit) */
	rtip->rti_pt_bytes = sizeof(struct partition) + 
		BITS2BYTES(rtip->nsolids) - sizeof(bitv_t) + 1;
	rtip->rti_bv_bytes = BITS2BYTES(rtip->nsolids) +
		BITS2BYTES(rtip->nregions) + 4*sizeof(bitv_t);

	/*
	 *  Allocate space for a per-solid bit of rtip->nregions length.
	 */
	for( stp=rtip->HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw )  {
		stp->st_regions = (bitv_t *)rt_malloc(
			BITS2BYTES(rtip->nregions)+sizeof(bitv_t),
			"st_regions bitv" );
		BITZERO( stp->st_regions, rtip->nregions );
		stp->st_maxreg = 0;
	}

	/* In case everything is a halfspace, set a minimum space */
	if( rtip->mdl_min[X] >= INFINITY )  {
		VSETALL( rtip->mdl_min, -1 );
	}
	if( rtip->mdl_max[X] <= -INFINITY )  {
		VSETALL( rtip->mdl_max, 1 );
	}

	/*
	 *  Enlarge the model RPP just slightly, to avoid nasty
	 *  effects with a solid's face being exactly on the edge
	 */
	rtip->mdl_min[X] = floor( rtip->mdl_min[X] );
	rtip->mdl_min[Y] = floor( rtip->mdl_min[Y] );
	rtip->mdl_min[Z] = floor( rtip->mdl_min[Z] );
	rtip->mdl_max[X] = ceil( rtip->mdl_max[X] );
	rtip->mdl_max[Y] = ceil( rtip->mdl_max[Y] );
	rtip->mdl_max[Z] = ceil( rtip->mdl_max[Z] );

	/*  Build array of region pointers indexed by reg_bit.
	 *  Optimize each region's expression tree.
	 *  Set this region's bit in the bit vector of every solid
	 *  contained in the subtree.
	 */
	rtip->Regions = (struct region **)rt_malloc(
		rtip->nregions * sizeof(struct region *),
		"rtip->Regions[]" );
	for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
		rtip->Regions[regp->reg_bit] = regp;
		rt_optim_tree( regp->reg_treetop, &rt_uniresource );
		rt_solid_bitfinder( regp->reg_treetop, regp->reg_bit,
			&rt_uniresource );
		if(rt_g.debug&DEBUG_REGIONS)  {
			rt_pr_region( regp );
		}
	}
	if(rt_g.debug&DEBUG_REGIONS)  {
		for( stp=rtip->HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw )  {
			rt_log("solid %s ", stp->st_name);
			rt_pr_bitv( "regions ref", stp->st_regions,
				stp->st_maxreg);
		}
	}

	/*
	 *  Build array of solid table pointers indexed by solid ID.
	 *  Last element for each kind will be found in
	 *	rti_sol_by_type[id][rti_nsol_by_type[id]-1]
	 */
	for( stp=rtip->HeadSolid; stp != SOLTAB_NULL; stp = stp->st_forw )  {
		rtip->rti_nsol_by_type[stp->st_id]++;
	}
	/* Find solid type with maximum length (for rt_shootray) */
	rtip->rti_maxsol_by_type = 0;
	for( i=0; i <= ID_MAXIMUM; i++ )  {
		if( rtip->rti_nsol_by_type[i] > rtip->rti_maxsol_by_type )
			rtip->rti_maxsol_by_type = rtip->rti_nsol_by_type[i];
	}
	/* Malloc the storage and zero the counts */
	for( i=0; i <= ID_MAXIMUM; i++ )  {
		if( rtip->rti_nsol_by_type[i] <= 0 )  continue;
		rtip->rti_sol_by_type[i] = (struct soltab **)rt_calloc(
			rtip->rti_nsol_by_type[i],
			sizeof(struct soltab *),
			"rti_sol_by_type[]" );
		rtip->rti_nsol_by_type[i] = 0;
	}
	/* Fill in the array and rebuild the count (aka index) */
	for( stp=rtip->HeadSolid; stp != SOLTAB_NULL; stp = stp->st_forw )  {
		register int	id;
		id = stp->st_id;
		rtip->rti_sol_by_type[id][rtip->rti_nsol_by_type[id]++] = stp;
	}
	if( rt_g.debug & DEBUG_DB )  {
		for( i=1; i <= ID_MAXIMUM; i++ )  {
			rt_log("%5d %s (%d)\n",
				rtip->rti_nsol_by_type[i],
				rt_functab[i].ft_name,
				i );
		}
	}

	/* Partition space */
	rt_cut_it(rtip);
}

/*
 *			R T _ C L E A N
 *
 *  Release all the dynamic storage associated with a particular rt_i
 *  structure, except for the database instance information (dir, etc).
 */
void
rt_clean( rtip )
register struct rt_i *rtip;
{
	register struct region *regp;
	register struct soltab *stp;
	int	i;

	if( rtip->rti_magic != RTI_MAGIC )  rt_bomb("rt_clean:  bad rtip\n");

	/*
	 *  Clear out the solid table
	 */
	for( stp=rtip->HeadSolid; stp != SOLTAB_NULL; )  {
		register struct soltab *nextstp = stp->st_forw;

		rt_free( (char *)stp->st_regions, "st_regions bitv" );
		if( stp->st_id < 0 || stp->st_id >= rt_nfunctab )
			rt_bomb("rt_clean:  bad st_id");
		rt_functab[stp->st_id].ft_free( stp );
		stp->st_name = (char *)0;	/* was ptr to directory */
		rt_free( (char *)stp, "struct soltab");
		stp = nextstp;			/* advance to next one */
	}
	rtip->HeadSolid = SOLTAB_NULL;
	rtip->nsolids = 0;

	/*  
	 *  Clear out the region table
	 */
	for( regp=rtip->HeadRegion; regp != REGION_NULL; )  {
		register struct region *nextregp = regp->reg_forw;

		rt_fr_tree( regp->reg_treetop );
		rt_free( regp->reg_name, "region name str");
		rt_free( (char *)regp, "struct region");
		regp = nextregp;
	}
	rtip->HeadRegion = REGION_NULL;
	rtip->nregions = 0;

	/**** The best thing to do would be to hunt down the
	 *  bitv and partition structs and release them, because
	 *  they depend on the number of solids & regions!  XXX
	 */

	/* Clean out the array of pointers to regions, if any */
	if( rtip->Regions )  {
		rt_free( (char *)rtip->Regions, "rtip->Regions[]" );
		rtip->Regions = (struct region **)0;

		/* Free space partitions */
		rt_fr_cut( &(rtip->rti_CutHead) );
		bzero( (char *)&(rtip->rti_CutHead), sizeof(union cutter) );
		rt_fr_cut( &(rtip->rti_inf_box) );
		bzero( (char *)&(rtip->rti_inf_box), sizeof(union cutter) );
	}

	/* Reset instancing counters in database directory */
	for( i=0; i < RT_DBNHASH; i++ )  {
		register struct directory	*dp;

		dp = rtip->rti_dbip->dbi_Head[i];
		for( ; dp != DIR_NULL; dp = dp->d_forw )
			dp->d_uses = 0;
	}

	/* Free animation structures */
	rt_fr_anim(rtip);

	/*
	 *  Re-initialize everything important.
	 *  This duplicates the code in rt_dirbuild().
	 */

	rtip->rti_inf_box.bn.bn_type = CUT_BOXNODE;
	VMOVE( rtip->rti_inf_box.bn.bn_min, rtip->mdl_min );
	VMOVE( rtip->rti_inf_box.bn.bn_max, rtip->mdl_max );
	VSETALL( rtip->mdl_min, -0.1 );
	VSETALL( rtip->mdl_max,  0.1 );

	rtip->rti_magic = RTI_MAGIC;
	rtip->needprep = 1;
@


8.15
log
@Moved a block of code into rt_pr_soltab() for use by g_arb.c and
eventually perhaps others.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 8.14 89/04/27 23:11:11 mike Locked $ (BRL)";
@


8.14
log
@moved rt_inv255 to const.c
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 8.13 89/04/17 17:25:55 phil Locked $ (BRL)";
d43 1
a43 1
HIDDEN char *rt_basename();
d47 1
d285 1
a285 10
	if(rt_g.debug&DEBUG_SOLIDS)  {
		rt_log("------------ %s (bit %d) %s ------------\n",
			stp->st_name, stp->st_bit, rt_functab[id].ft_name );
		VPRINT("Bound Sph CENTER", stp->st_center);
		rt_log("Approx Sph Radius = %g\n", stp->st_aradius);
		rt_log("Bounding Sph Radius = %g\n", stp->st_bradius);
		VPRINT("Bound RPP min", stp->st_min);
		VPRINT("Bound RPP max", stp->st_max);
		rt_functab[id].ft_print( stp );
	}
d950 1
a950 1
HIDDEN char *
d1572 26
@


8.13
log
@Removed unneeded array.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 8.12 89/04/17 17:20:03 mike Locked $ (BRL)";
a97 2

double		rt_inv255 = 1.0/255.0;
@


8.12
log
@Calling sequence to xxx_prep() shortened from 6 to 3 args.
Database conversion moved into prep routines.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 8.11 89/04/17 11:07:17 mike Locked $ (BRL)";
d188 3
a190 4
	static vect_t v[8];
	static vect_t A, B, C;
	static fastf_t fx, fy, fz;
	FAST fastf_t f;
@


8.11
log
@Now set st_dp field
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 8.10 89/04/11 12:34:30 mike Locked $ (BRL)";
a245 4
	if( rec->u_id == ID_SOLID )  {
		/* Convert from database (float) to fastf_t */
		rt_fastf_float( (fastf_t *)v, rec->s.s_values, 8 );
	}
d248 1
d255 6
a260 2
	/* "rec" points to array of all relevant records */
	if( rt_functab[id].ft_prep( v, stp, mat, rec, rtip, dp ) )  {
a269 2

	mat_copy( stp->st_pathmat, mat );
@


8.10
log
@lint
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 8.9 89/04/08 02:49:10 phil Locked $ (BRL)";
d250 2
a251 1
	stp->st_name = dp->d_namep;
@


8.9
log
@Compute stuff needed for simple vectorization version.
This also generates the useful statistic of #solids of each type.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 8.8 89/04/04 04:57:14 mike Locked $ (BRL)";
d24 5
d46 1
d354 1
@


8.8
log
@Added some explanation prints before bombing.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 8.7 89/03/15 15:46:10 mike Locked $ (BRL)";
d1373 1
d1442 38
@


8.7
log
@Moved function table into "table.c".
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 8.6 89/01/11 09:03:00 mike Locked $ (BRL)";
d114 5
a118 1
	if( rtip->rti_magic != RTI_MAGIC )  rt_bomb("rt_gettree:  bad rtip\n");
@


8.6
log
@Added support for reg_instnum
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 8.5 88/12/30 02:33:07 mike Locked $ (BRL)";
a29 2
struct rt_g rt_g;

d42 2
a43 12
extern int	nul_prep(), nul_class();
extern int	tor_prep(), tor_class();
extern int	tgc_prep(), tgc_class();
extern int	ell_prep(), ell_class();
extern int	arb_prep(), arb_class();
extern int	hlf_prep(), hlf_class();
extern int	ars_prep(), ars_class();
extern int	rec_prep(), rec_class();
extern int	pg_prep(), pg_class();
extern int	spl_prep(), spl_class();
extern int	sph_prep(), sph_class();
extern int	ebm_prep(), ebm_class();
a44 128
extern void	nul_print(), nul_norm(), nul_uv();
extern void	tor_print(), tor_norm(), tor_uv();
extern void	tgc_print(), tgc_norm(), tgc_uv();
extern void	ell_print(), ell_norm(), ell_uv();
extern void	arb_print(), arb_norm(), arb_uv();
extern void	hlf_print(), hlf_norm(), hlf_uv();
extern void	ars_print(), ars_norm(), ars_uv();
extern void	rec_print(), rec_norm(), rec_uv();
extern void	pg_print(),  pg_norm(),  pg_uv();
extern void	spl_print(), spl_norm(), spl_uv();
extern void	sph_print(), sph_norm(), sph_uv();
extern void	ebm_print(), ebm_norm(), ebm_uv();

extern void	nul_curve(), nul_free(), nul_plot();
extern void	tor_curve(), tor_free(), tor_plot();
extern void	tgc_curve(), tgc_free(), tgc_plot();
extern void	ell_curve(), ell_free(), ell_plot();
extern void	arb_curve(), arb_free(), arb_plot();
extern void	hlf_curve(), hlf_free(), hlf_plot();
extern void	ars_curve(), ars_free(), ars_plot();
extern void	rec_curve(), rec_free(), rec_plot();
extern void	pg_curve(),  pg_free(),  pg_plot();
extern void	spl_curve(), spl_free(), spl_plot();
extern void	sph_curve(), sph_free(), sph_plot();
extern void	ebm_curve(), ebm_free(), ebm_plot();

extern struct seg *nul_shot();
extern struct seg *tor_shot();
extern struct seg *tgc_shot();
extern struct seg *ell_shot();
extern struct seg *arb_shot();
extern struct seg *ars_shot();
extern struct seg *hlf_shot();
extern struct seg *rec_shot();
extern struct seg *pg_shot();
extern struct seg *spl_shot();
extern struct seg *sph_shot();
extern struct seg *ebm_shot();

struct rt_functab rt_functab[] = {
	"ID_NULL",	0,
		nul_prep,	nul_shot,	nul_print, 	nul_norm,
	 	nul_uv,		nul_curve,	nul_class,	nul_free,
		nul_plot,
		
	"ID_TOR",	1,
		tor_prep,	tor_shot,	tor_print,	tor_norm,
		tor_uv,		tor_curve,	tor_class,	tor_free,
		tor_plot,

	"ID_TGC",	1,
		tgc_prep,	tgc_shot,	tgc_print,	tgc_norm,
		tgc_uv,		tgc_curve,	tgc_class,	tgc_free,
		tgc_plot,

	"ID_ELL",	1,
		ell_prep,	ell_shot,	ell_print,	ell_norm,
		ell_uv,		ell_curve,	ell_class,	ell_free,
		ell_plot,

	"ID_ARB8",	0,
		arb_prep,	arb_shot,	arb_print,	arb_norm,
		arb_uv,		arb_curve,	arb_class,	arb_free,
		arb_plot,

	"ID_ARS",	1,
		ars_prep,	ars_shot,	ars_print,	ars_norm,
		ars_uv,		ars_curve,	ars_class,	ars_free,
		ars_plot,

	"ID_HALF",	0,
		hlf_prep,	hlf_shot,	hlf_print,	hlf_norm,
		hlf_uv,		hlf_curve,	hlf_class,	hlf_free,
		hlf_plot,

	"ID_REC",	1,
		rec_prep,	rec_shot,	rec_print,	rec_norm,
		rec_uv,		rec_curve,	rec_class,	rec_free,
		rec_plot,

	"ID_POLY",	1,
		pg_prep,	pg_shot,	pg_print,	pg_norm,
		pg_uv,		pg_curve,	pg_class,	pg_free,
		pg_plot,

	"ID_BSPLINE",	1,
		spl_prep,	spl_shot,	spl_print,	spl_norm,
		spl_uv,		spl_curve,	spl_class,	spl_free,
		spl_plot,

	"ID_SPH",	1,
		sph_prep,	sph_shot,	sph_print,	sph_norm,
		sph_uv,		sph_curve,	sph_class,	sph_free,
		sph_plot,

	"ID_STRINGSOL",	0,
		nul_prep,	nul_shot,	nul_print,	nul_norm,
		nul_uv,		nul_curve,	nul_class,	nul_free,
		nul_plot,

	"ID_EBM",	1,
		ebm_prep,	ebm_shot,	ebm_print,	ebm_norm,
		ebm_uv,		ebm_curve,	ebm_class,	ebm_free,
		ebm_plot,

	">ID_NULL",	0,
		nul_prep,	nul_shot,	nul_print,	nul_norm,
		nul_uv,		nul_curve,	nul_class,	nul_free,
		nul_plot
};
int rt_nfunctab = sizeof(rt_functab)/sizeof(struct rt_functab);

/*
 *  Hooks for unimplemented routines
 */
#define DEF(func)	func() { rt_log("func unimplemented\n"); return; }
#define IDEF(func)	func() { rt_log("func unimplemented\n"); return(0); }

int IDEF(nul_prep)
struct seg * IDEF(nul_shot)
void DEF(nul_print)
void DEF(nul_norm)
void DEF(nul_uv)
void DEF(nul_curve)
int IDEF(nul_class)
void DEF(nul_free)
void DEF(nul_plot)

a907 1
	register int i;
d1138 3
a1140 3
struct rt_i *rtip;
register struct region *regp;
register union tree *tp;
a1141 1
	register union tree *xor;
a1280 1
	register union tree *low;
@


8.5
log
@Have "clean" function reset d_uses.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 8.4 88/12/30 01:28:48 mike Locked $ (BRL)";
d601 1
a604 1
			dp->d_uses++;		/* after rt_path_str() */
d876 2
d882 1
d951 2
a952 1
	rt_log("id=%d, air=%d, gift_material=%d, los=%d\n",
d1301 4
a1304 2
	if( rt_g.debug & DEBUG_REGIONS )
		rt_log("Add Region %s\n", regp->reg_name);
d1329 1
a1329 1
		rt_log("Del Region %s\n", regp->reg_name);
@


8.4
log
@Fix pathpos indexing in anim and add more anim debug.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 8.3 88/12/06 00:27:46 mike Exp $ (BRL)";
d1593 1
d1643 9
@


8.3
log
@Converted to new db_*() routines.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: /cad/d/mike/cad/librt/RCS/tree.c,v 1.3 88/11/27 18:38:08 mike Exp $ (BRL)";
d225 8
d290 1
a290 1
			rt_path_str(0) );
d293 1
a293 1
		regionp->reg_name = rt_strdup(rt_path_str(0));
a462 8
/*
 * Note that while GED has a more limited MAXLEVELS, GED can
 * work on sub-trees, while RT must be able to process the full tree.
 * Thus the difference, and the large value here.
 */
#define	MAXLEVELS	64
static struct directory	*path[MAXLEVELS];	/* Record of current path */

d499 1
a499 1
			rt_path_str(MAXLEVELS), MAXLEVELS );
d526 1
a526 1
		curtree->tr_a.tu_name = rt_strdup(rt_path_str(pathpos));
d585 1
a585 1
				rt_path_str(pathpos),
d600 1
a600 1
			nrp->reg_name = rt_strdup(rt_path_str(pathpos));
d643 5
d650 7
a656 1
				register int j = pathpos-1;
d658 4
d664 5
a668 1
rt_log("%s != %s\n", anp->an_path[i]->d_namep, path[j]->d_namep);
d696 1
a696 1
				rt_path_str(pathpos+1) );
d700 1
a700 1
			xrp->reg_name = rt_strdup(rt_path_str(pathpos+1));
d861 2
a862 1
rt_path_str( pos )
d874 1
a874 1
		(void)sprintf( cp, "/%s", (dp=path[i])->d_namep );
@


8.2
log
@oops, really Rel 3.0
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 8.1 88/10/05 00:32:05 mike Locked $ (BRL)";
d55 1
d68 1
d81 1
d94 1
d152 10
d208 2
a209 2
	ID_NULL,	/* ARS 21: arbitrary triangular-surfaced polyhedron */
	ID_NULL,	/* ARSCONT 22: extension record type for ARS solid */
d212 1
d253 1
a253 1
	if( (dp = rt_dir_lookup( rtip, node, LOOKUP_NOISY )) == DIR_NULL )
d297 3
d303 1
a303 1
rt_add_solid( rtip, rec, name, mat )
d306 1
a306 1
char		*name;
d329 1
a329 1
			name, fx, fy, fz );
d342 3
a344 3
			name[0] != nsp->st_name[0]  ||	/* speed */
			name[1] != nsp->st_name[1]  ||	/* speed */
			strcmp( name, nsp->st_name ) != 0
d355 1
a355 1
				name );
d372 1
a372 1
	stp->st_name = name;
d379 2
a380 1
	if( rt_functab[id].ft_prep( v, stp, mat, &(rec->s), rtip ) )  {
d398 2
d487 7
a493 8
	auto union record rec;		/* local copy of this record */
	register int i;
	auto int j;
	union tree *curtree;		/* ptr to current tree top */
	struct region *regionp;
	union record *members;		/* ptr to array of member recs */
	int subtreecount;		/* number of non-null subtrees */
	struct tree_list *trees;	/* ptr to array of structs */
d504 1
a504 17
	/*
	 * Load the first record of the object into local record buffer
	 */
#ifdef DB_MEM
	rec = rtip->rti_db[dp->d_addr];	/* struct copy */
#else DB_MEM
#ifdef CRAY_COS
	/* CRAY COS can't fseek() properly, hence this hideous I/O hack */
	rewind(rtip->fp);
	while( !feof(rtip->fp) && ftell(rtip->fp) <= dp->d_addr  &&
	    fread( (char *)&rec, sizeof rec, 1, rtip->fp ) == 1 )
		/* NULL */ ;
#else CRAY_COS
	if( fseek( rtip->fp, dp->d_addr, 0 ) < 0 ||
	    fread( (char *)&rec, sizeof rec, 1, rtip->fp ) != 1 )  {
		rt_log("rt_drawobj: %s record read error\n",
			rt_path_str(pathpos) );
d506 1
a506 3
	}
#endif CRAY_COS
#endif DB_MEM
d511 2
a512 2
	if( rec.u_id == ID_SOLID || rec.u_id == ID_ARS_A ||
	    rec.u_id == ID_P_HEAD || rec.u_id == ID_BSOLID )  {
a513 1
		register union tree *xtp;
d515 1
a515 1
		if( (stp = rt_add_solid( rtip, &rec, dp->d_namep, old_xlate )) ==
d517 1
a517 1
			return( TREE_NULL );
d519 2
a520 2
		/**GETSTRUCT( xtp, union tree ); **/
		if( (xtp=(union tree *)rt_malloc(sizeof(union tree), "solid tree"))
d523 6
a528 6
		bzero( (char *)xtp, sizeof(union tree) );
		xtp->tr_op = OP_SOLID;
		xtp->tr_a.tu_stp = stp;
		xtp->tr_a.tu_name = rt_strdup(rt_path_str(pathpos));
		xtp->tr_regionp = argregion;
		return( xtp );
d531 1
a531 1
	if( rec.u_id != ID_COMB )  {
d534 2
a535 2
			rec.u_id, rec.u_id, dp->d_addr );
		return(TREE_NULL);			/* ERROR */
d541 4
a544 4
	if( rec.c.c_length <= 0 )  {
		rt_log(  "Warning: combination with zero members \"%.16s\".\n",
			rec.c.c_name );
		return(TREE_NULL);
d554 1
a554 1
	if( rec.c.c_override == 1 )  {
d556 2
a557 1
			rt_log("rt_drawobj: ERROR: color override in combination within region %s\n", argregion->reg_name );
d561 4
a564 4
				curmater.ma_color[0] = (rec.c.c_rgb[0])*rt_inv255;
				curmater.ma_color[1] = (rec.c.c_rgb[1])*rt_inv255;
				curmater.ma_color[2] = (rec.c.c_rgb[2])*rt_inv255;
				curmater.ma_cinherit = rec.c.c_inherit;
d568 1
a568 1
	if( rec.c.c_matname[0] != '\0' )  {
d570 2
a571 1
			rt_log("rt_drawobj: ERROR: material property spec in combination within region %s\n", argregion->reg_name );
d574 3
a576 3
				strncpy( curmater.ma_matname, rec.c.c_matname, sizeof(rec.c.c_matname) );
				strncpy( curmater.ma_matparm, rec.c.c_matparm, sizeof(rec.c.c_matparm) );
				curmater.ma_minherit = rec.c.c_inherit;
d582 1
a582 1
	if( rec.c.c_flags == 'R' )  {
d591 2
a592 2
			if( rtip->useair == 0 &&  rec.c.c_aircode != 0 )
				return(TREE_NULL);
d597 3
a599 3
			nrp->reg_regionid = rec.c.c_regionid;
			nrp->reg_aircode = rec.c.c_aircode;
			nrp->reg_gmater = rec.c.c_material;
d608 3
a610 7
	/* Read all the member records */
	i = sizeof(union record) * rec.c.c_length;
	j = sizeof(struct tree_list) * rec.c.c_length;
	trees = (struct tree_list *)0;	/* satisfy picky compilers */
	if( (members = (union record *)rt_malloc(i, "member records")) ==
	    (union record *)0  ||
	    (trees = (struct tree_list *)rt_malloc( j, "tree_list array" )) ==
a613 12
#ifdef DB_MEM
	/* For now, the "members" struct array is simply ignored */
#else DB_MEM
	/* Read in all members of this combination before recursing */
	if( fread( (char *)members, sizeof(union record), rec.c.c_length,
	    rtip->fp ) != rec.c.c_length )  {
		rt_log("rt_drawobj:  %s member read error\n",
			rt_path_str(pathpos) );
		return(TREE_NULL);
	}
#endif DB_MEM

d617 1
a617 1
	for( i=0; i<rec.c.c_length; i++ )  {
d624 1
a624 5
#ifdef DB_MEM
		mp = &(rtip->rti_db[dp->d_addr+i+1].M);
#else DB_MEM
		mp = &(members[i].M);
#endif DB_MEM
d629 3
a631 2
		if( (nextdp = rt_dir_lookup( rtip, mp->m_instname, LOOKUP_NOISY )) ==
		    DIR_NULL )
d761 2
a762 2
	rt_free( (char *)trees, "tree_list array");
	rt_free( (char *)members, "member records" );
d764 4
d782 2
a783 2
int howfar;
struct region *regionp;
d786 1
a786 1
	register int i;
d788 3
a790 3
	register union tree *xtp;
	register union tree *curtree;
	register int inuse;
d901 1
a901 1
		if( (dp = rt_dir_lookup( rtip, cp, noisy )) == DIR_NULL )
a1501 5
	if( rtip->rti_db )  {
		rt_free( (char *)rtip->rti_db, "in-core database");
		rtip->rti_db = (union record *)0;
	}

d1565 1
a1565 1
 *  structure, except for the database directory.
a1575 5
	if( rtip->rti_db )  {
		rt_free( (char *)rtip->rti_db, "in-core database");
		rtip->rti_db = (union record *)0;
	}

d1629 1
a1629 1
	 *  Some things, like file & fp remain untouched.
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 7.12 88/08/23 02:30:37 mike Exp $ (BRL)";
d608 1
d799 1
a799 1
	register struct tree_list *first_tlp;
d1313 1
d1317 1
a1317 1
	if( (regp = rtip->HeadRegion ) == delregp )  {
@


7.12
log
@Updates for handling "instancing" of regions.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 7.11 88/08/19 06:56:10 mike Locked $ (BRL)";
@


7.11
log
@Added rt_grow_boolstack(), and exploited Phil's rewrite of
rt_optim_tree() and rt_solid_bitfinder() to use iteration instead of
recursion.
rt_fr_tree() remains to be converted, and may still run out of
stack space on a Gould.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 7.10 88/08/19 05:37:27 mike Locked $ (BRL)";
d559 3
a561 3
				curmater.ma_color[0] = (rec.c.c_rgb[0]+0.5)*rt_inv255;
				curmater.ma_color[1] = (rec.c.c_rgb[1]+0.5)*rt_inv255;
				curmater.ma_color[2] = (rec.c.c_rgb[2]+0.5)*rt_inv255;
d581 3
a583 5
			if( rt_g.debug & DEBUG_REGIONS )
				rt_log("Warning:  region %s within region %s\n",
					rt_path_str(pathpos),
					argregion->reg_name );
/***			argregion = REGION_NULL;	/* override! */
d601 1
d856 1
a856 1
	static char line[MAXLEVELS*(16+2)];
d859 1
d865 1
a865 1
		(void)sprintf( cp, "/%s", path[i]->d_namep );
d867 4
@


7.10
log
@Switched from recursion using system stack to iteration using local
"stack" array, because Gould stacks were unable to handle regions
with 10000 solids.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 7.9 88/08/09 03:49:29 phil Exp $ (BRL)";
d34 2
d1336 3
a1338 2
rt_optim_tree( tp )
register union tree *tp;
d1340 3
a1342 4
#define STACKDEPTH	10000
	LOCAL union tree *stackpile[STACKDEPTH];
	register union tree **sp;
	register union tree *low;
d1344 3
a1346 1
	sp = stackpile;
d1365 5
a1369 3
			if( sp >= &stackpile[STACKDEPTH-1] )  {
				rt_log("rt_optim_tree: stack overflow!\n");
				return;
d1379 5
a1383 3
			if( sp >= &stackpile[STACKDEPTH-1] )  {
				rt_log("rt_optim_tree: stack overflow!\n");
				return;
d1395 3
d1431 4
a1434 3
rt_solid_bitfinder( treep, regbit )
register union tree *treep;
register int regbit;
d1436 3
a1438 4
#define STACKDEPTH	10000
	LOCAL union tree *stackpile[STACKDEPTH];
	register union tree **sp;
	register struct soltab *stp;
d1440 3
a1442 1
	sp = stackpile;
d1465 5
a1469 3
			if( sp >= &stackpile[STACKDEPTH-1] )  {
				rt_log("rt_optim_tree: stack overflow!\n");
				return;
d1553 3
a1555 2
		rt_optim_tree( regp->reg_treetop );
		rt_solid_bitfinder( regp->reg_treetop, regp->reg_bit );
@


7.9
log
@fixed debug printf, added solid type to header
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 7.8 88/08/08 22:51:37 phil Locked $ (BRL)";
d1337 3
d1342 39
a1380 11
	switch( tp->tr_op )  {
	case OP_SOLID:
		return;
	case OP_SUBTRACT:
		while( (low=tp->tr_b.tb_left)->tr_op == OP_SUBTRACT )  {
			/* Rewrite X - A - B as X - ( A union B ) */
			tp->tr_b.tb_left = low->tr_b.tb_left;
			low->tr_op = OP_UNION;
			low->tr_b.tb_left = low->tr_b.tb_right;
			low->tr_b.tb_right = tp->tr_b.tb_right;
			tp->tr_b.tb_right = low;
a1381 9
		goto binary;
	case OP_UNION:
	case OP_INTERSECT:
	case OP_XOR:
		/* Need to look at 3-level optimizations here, both sides */
		goto binary;
	default:
		rt_log("rt_optim_tree: bad op x%x\n", tp->tr_op);
		return;
a1382 3
binary:
	rt_optim_tree( tp->tr_b.tb_left );
	rt_optim_tree( tp->tr_b.tb_right );
d1424 3
d1429 31
a1459 10
	switch( treep->tr_op )  {
	case OP_SOLID:
		stp = treep->tr_a.tu_stp;
		BITSET( stp->st_regions, regbit );
		if( !BITTEST( stp->st_regions, regbit ) )
			rt_bomb("BITSET failure\n");	/* sanity check */
		if( regbit+1 > stp->st_maxreg )  stp->st_maxreg = regbit+1;
		if( rt_g.debug&DEBUG_REGIONS )  {
			rt_pr_bitv( stp->st_name, stp->st_regions,
				stp->st_maxreg );
a1460 11
		return;
	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
		/* BINARY type */
		rt_solid_bitfinder( treep->tr_b.tb_left, regbit );
		rt_solid_bitfinder( treep->tr_b.tb_right, regbit );
		return;
	default:
		rt_log("rt_solid_bitfinder:  op=x%x\n", treep->tr_op);
		return;
a1461 1
	/* NOTREACHED */
@


7.8
log
@in rt_fr_tree we are freeing "binary tree unions", yet these get
malloc'd a whole array at a time.  I commented out the free for
the time being.  Someone should figure out whether this leaves
a memory leak or not.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 7.7 88/07/14 20:58:52 phil Locked $ (BRL)";
d364 1
d387 2
a388 2
		rt_log("-------------- %s (bit %d) -------------\n",
			stp->st_name, stp->st_bit );
@


7.7
log
@Incorporated fix from Cujo (Tom) for RPP min/max.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 7.6 88/05/14 02:29:37 mike Locked $ (BRL)";
d1384 1
a1384 1
		rt_free( (char *)tp, "binary tree union");
@


7.6
log
@lint fixes
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 7.5 88/05/14 00:47:52 mike Locked $ (BRL)";
d1039 1
@


7.5
log
@lint fixes
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 7.5 88/05/14 00:01:48 mike Exp $ (BRL)";
d350 1
a350 1
		rt_fastf_float( v, rec->s.s_values, 8 );
d361 1
a361 1
		rt_free(stp, "struct soltab");
@


7.4
log
@Added rt_del_regtree(), to make regions disappear
(esp. useful for implicit lights).
Also added support for c_inherit flag.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 7.3 87/11/14 01:04:27 mike Locked $ (BRL)";
d42 11
a52 11
extern int nul_prep(),	nul_print(), nul_norm(), nul_uv();
extern int tor_prep(),	tor_print(), tor_norm(), tor_uv();
extern int tgc_prep(),	tgc_print(), tgc_norm(), tgc_uv();
extern int ell_prep(),	ell_print(), ell_norm(), ell_uv();
extern int arb_prep(),	arb_print(), arb_norm(), arb_uv();
extern int hlf_prep(),	hlf_print(), hlf_norm(), hlf_uv();
extern int ars_prep(),  ars_print(), ars_norm(), ars_uv();
extern int rec_prep(),	rec_print(), rec_norm(), rec_uv();
extern int pg_prep(),	pg_print(),  pg_norm(),  pg_uv();
extern int spl_prep(),	spl_print(), spl_norm(), spl_uv();
extern int sph_prep(),	sph_print(), sph_norm(), sph_uv();
d54 11
a64 11
extern int nul_curve(), nul_class(), nul_free(), nul_plot();
extern int tor_curve(), tor_class(), tor_free(), tor_plot();
extern int tgc_curve(), tgc_class(), tgc_free(), tgc_plot();
extern int ell_curve(), ell_class(), ell_free(), ell_plot();
extern int arb_curve(), arb_class(), arb_free(), arb_plot();
extern int hlf_curve(), hlf_class(), hlf_free(), hlf_plot();
extern int ars_curve(), ars_class(), ars_free(), ars_plot();
extern int rec_curve(), rec_class(), rec_free(), rec_plot();
extern int pg_curve(),  pg_class(),  pg_free(),  pg_plot();
extern int spl_curve(), spl_class(), spl_free(), spl_plot();
extern int sph_curve(), sph_class(), sph_free(), sph_plot();
d66 12
d156 2
a157 1
#define DEF(func)	func() { rt_log("func unimplemented\n"); return(0); }
d159 9
a167 3
DEF(nul_prep); struct seg * DEF(nul_shot); DEF(nul_print); DEF(nul_norm);
DEF(nul_uv); DEF(nul_curve); DEF(nul_class); DEF(nul_free);
DEF(nul_plot);
d1529 1
d1552 1
a1552 1
		(void)rt_functab[stp->st_id].ft_free( stp );
@


7.3
log
@Separated out rt_id_solid().
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 7.2 87/11/05 06:40:23 mike Locked $ (BRL)";
d40 1
d184 3
a186 1
	0			/* override */
d525 5
a529 1
	/* Handle inheritance of material property */
d531 1
a531 1
	if( rec.c.c_override == 1 || rec.c.c_matname[0] != '\0' )  {
d533 1
a533 1
			rt_log("Error:  material property spec within region %s\n", argregion->reg_name );
d535 1
a535 1
			if( rec.c.c_override == 1 )  {
d540 1
d542 7
a548 1
			if( rec.c.c_matname[0] != '\0' )  {
d551 1
d1263 44
@


7.2
log
@Added rt_mat_dbmat(), rt_dbmat_mat().
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 7.3 87/11/05 06:37:31 mike Exp $ (BRL)";
d273 1
d318 6
d325 2
a326 3
	switch( rec->u_id )  {
	case ID_SOLID:
		stp->st_id = idmap[rec->s.s_type];
a328 14
		break;
	case ID_ARS_A:
		stp->st_id = ID_ARS;
		break;
	case ID_P_HEAD:
		stp->st_id = ID_POLY;
		break;
	case ID_BSOLID:
		stp->st_id = ID_BSPLINE;
		break;
	default:
		rt_log("rt_add_solid:  u_id=x%x unknown\n", rec->u_id);
		free(stp);
		return( SOLTAB_NULL );		/* BAD */
d337 1
a337 3
	if( stp->st_id < 0 || stp->st_id >= rt_nfunctab )
		rt_bomb("rt_add_solid:  bad st_id");
	if( rt_functab[stp->st_id].ft_prep( v, stp, mat, &(rec->s), rtip ) )  {
d339 1
a339 1
		free(stp);
d371 1
a371 1
		rt_functab[stp->st_id].ft_print( stp );
d374 33
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 6.4 87/09/26 07:49:27 mike Exp $ (BRL)";
d593 1
a593 2
		{
			register int k;
a594 4
			for( k=0; k<4*4; k++ )
				xmat[k] = mp->m_mat[k];
		}

d1098 64
@


6.4
log
@Fixed "root" animations.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 6.3 87/09/26 03:24:34 mike Locked $ (BRL)";
@


6.3
log
@Fixed handling of bounding RPP
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 6.2 87/08/09 19:13:36 mike Locked $ (BRL)";
d214 3
d224 2
a231 4

	dp = rt_dir_lookup( rtip, node, LOOKUP_NOISY );
	if( dp == DIR_NULL )
		return(-1);		/* ERROR */
@


6.2
log
@Added sanity check for BITTEST operation.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 6.1 87/07/11 07:57:16 mike Rel $ (BRL)";
d1313 8
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 5.3 87/07/10 04:53:26 mike Exp $ (BRL)";
d1248 2
@


5.3
log
@When converting integer RGB to 0..1 floats, changed to
add 0.5 and multiply by rt_inv255.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 5.2 87/07/08 01:01:18 mike Locked $ (BRL)";
@


5.2
log
@Changed ma_rgb to 0..1 from 0..255,
switched %f to %g in debugging prints.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 5.1 87/06/24 22:13:17 mike Locked $ (BRL)";
d186 2
d506 3
a508 3
				curmater.ma_color[0] = rec.c.c_rgb[0]/255.;
				curmater.ma_color[1] = rec.c.c_rgb[1]/255.;
				curmater.ma_color[2] = rec.c.c_rgb[2]/255.;
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 4.11 87/05/30 02:04:49 mike Exp $ (BRL)";
d181 4
a184 1
static struct mater_info rt_no_mater;
d282 1
a282 1
		rt_log("rt_add_solid(%s):  matrix does not preserve axis perpendicularity.\n  X.Y=%f, Y.Z=%f, X.Z=%f\n",
d374 2
a375 2
		rt_log("Approx Sph Radius = %f\n", stp->st_aradius);
		rt_log("Bounding Sph Radius = %f\n", stp->st_bradius);
d504 3
a506 3
				curmater.ma_rgb[0] = rec.c.c_rgb[0];
				curmater.ma_rgb[1] = rec.c.c_rgb[1];
				curmater.ma_rgb[2] = rec.c.c_rgb[2];
d882 3
a884 3
			rp->reg_mater.ma_rgb[0],
			rp->reg_mater.ma_rgb[1],
			rp->reg_mater.ma_rgb[2] );
d1153 1
a1153 1
	regp->reg_mfuncs = MF_NULL;
@


4.11
log
@Fixed to not apply region-id coloring if combination-node override
has already been applied
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 4.10 87/03/24 01:02:40 mike Locked $ (BRL)";
@


4.10
log
@added sphere module
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 4.9 87/03/23 23:39:45 phil Locked $ (BRL)";
d1152 2
a1153 1
	rt_region_color_map(regp);
@


4.9
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 4.8 87/03/19 04:59:47 mike Exp $ (BRL)";
d51 1
d63 1
d75 1
d128 5
d152 1
a152 1
	ID_NULL,	/*  RPP	1 axis-aligned rectangular parallelopiped */
d164 1
a164 1
	ID_NULL,	/* REC	13 right elliptic sylinder */
@


4.8
log
@Added code for rt_clean()
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 4.7 87/03/19 03:03:14 mike Exp $ (BRL)";
a30 1
struct rt_i rt_i;	/* eventually, malloc'ed by rt_dir_build */
d52 10
a61 10
extern int nul_curve(), nul_class();
extern int tor_curve(), tor_class();
extern int tgc_curve(), tgc_class();
extern int ell_curve(), ell_class();
extern int arb_curve(), arb_class();
extern int hlf_curve(), hlf_class();
extern int ars_curve(), ars_class();
extern int rec_curve(), rec_class();
extern int pg_curve(), pg_class();
extern int spl_curve(), spl_class();
d75 54
a128 22
	0,	nul_prep,	nul_shot,	nul_print,	nul_norm,
		nul_uv,		nul_curve,	nul_class,	"ID_NULL",
	1,	tor_prep,	tor_shot,	tor_print,	tor_norm,
		tor_uv,		tor_curve,	tor_class,	"ID_TOR",
	1,	tgc_prep,	tgc_shot,	tgc_print,	tgc_norm,
		tgc_uv,		tgc_curve,	tgc_class,	"ID_TGC",
	1,	ell_prep,	ell_shot,	ell_print,	ell_norm,
		ell_uv,		ell_curve,	ell_class,	"ID_ELL",
	0,	arb_prep,	arb_shot,	arb_print,	arb_norm,
		arb_uv,		arb_curve,	arb_class,	"ID_ARB8",
	1,	ars_prep,	ars_shot,	ars_print,	ars_norm,
		ars_uv,		ars_curve,	ars_class,	"ID_ARS",
	0,	hlf_prep,	hlf_shot,	hlf_print,	hlf_norm,
		hlf_uv,		hlf_curve,	hlf_class,	"ID_HALF",
	1,	rec_prep,	rec_shot,	rec_print,	rec_norm,
		rec_uv,		rec_curve,	rec_class,	"ID_REC",
	1,	pg_prep,	pg_shot,	pg_print,	pg_norm,
		pg_uv,		pg_curve,	pg_class,	 "ID_POLY",
	1,	spl_prep,	spl_shot,	spl_print,	spl_norm,
		spl_uv,		spl_curve,	spl_class,	"ID_BSPLINE",
	0,	nul_prep,	nul_shot,	nul_print,	nul_norm,
		nul_uv,		nul_curve,	nul_class,	">ID_NULL"
d130 1
d137 3
a139 1
DEF(nul_prep); struct seg * DEF(nul_shot); DEF(nul_print); DEF(nul_norm); DEF(nul_uv);
a140 10
DEF(nul_curve); DEF(nul_class);
DEF(tor_class);
DEF(tgc_curve); DEF(tgc_class);
DEF(ell_class);
DEF(arb_class);
DEF(hlf_class);
DEF(rec_class);
DEF(pg_curve); DEF(pg_class);
DEF(spl_curve); DEF(spl_class);

d194 2
d215 1
a215 1
	dp = rt_dir_lookup( node, LOOKUP_NOISY );
d331 3
a333 1
	if( rt_functab[stp->st_id].ft_prep( v, stp, mat, &(rec->s) ) )  {
d572 1
a572 1
		if( (nextdp = rt_dir_lookup( mp->m_instname, LOOKUP_NOISY )) ==
d825 2
d839 1
a839 1
		if( (dp = rt_dir_lookup( cp, noisy )) == DIR_NULL )
d1064 2
d1105 3
a1124 1
 *  Also, this tree is also included in the overall RootTree.
d1142 1
a1142 1
	regp->reg_ufunc = 0;
a1150 13

	if( rtip->RootTree == TREE_NULL )  {
		rtip->RootTree = tp;
		return;
	}
	/**GETSTRUCT( xor, union tree ); **/
	xor = (union tree *)rt_malloc(sizeof(union tree), "rt_add_regtree tree");
	bzero( (char *)xor, sizeof(union tree) );
	xor->tr_b.tb_op = OP_XOR;
	xor->tr_b.tb_left = rtip->RootTree;
	xor->tr_b.tb_right = tp;
	xor->tr_b.tb_regionp = REGION_NULL;
	rtip->RootTree = xor;
d1268 2
a1269 2
	if( &rt_i != rtip )
		rt_bomb("rt_prep:  bad arg!");	/* XXX --temp */
d1276 7
d1350 2
d1364 3
a1366 4
		if( stp->st_specific )  {
			/* REALLY need a solid-specific clean routine! */
			rt_free( (char *)stp->st_specific, "st_specific" );
		}
d1372 1
d1386 1
d1388 4
a1391 3
	/* Clean out the array of pointers to regions */
	rt_free( (char *)rtip->Regions, "rtip->Regions[]" );
	rtip->Regions = (struct region **)0;
d1393 20
a1412 3
	/* Free space partitions */
	rt_fr_cut( &(rtip->rti_CutHead) );
	bzero( (char *)&(rtip->rti_CutHead), sizeof(union cutter) );
a1413 2
	rt_fr_cut( &(rtip->rti_inf_box) );
	bzero( (char *)&(rtip->rti_inf_box), sizeof(union cutter) );
a1415 2

	/* Make no assumptions about next size of model */
d1419 1
a1419 3
	/* Free animation structures */
	rt_fr_anim(rtip);

a1420 47
}

/*
 *			R T _ V I E W B O U N D S
 *
 *  Given a model2view transformation matrix, compute the RPP which
 *  encloses all the solids in the model, in view space.
 */
void
rt_viewbounds( min, max, m2v )
matp_t m2v;
register vect_t min, max;
{
	register struct soltab *stp;
	static vect_t xlated;

	VSETALL( max, -INFINITY );
	VSETALL( min,  INFINITY );

	for( stp=rt_i.HeadSolid; stp != 0; stp=stp->st_forw ) {
		if( stp->st_aradius >= INFINITY )
			continue;
		MAT4X3PNT( xlated, m2v, stp->st_center );
#define VBMIN(v,t) {FAST fastf_t rt; rt=(t); if(rt<v) v = rt;}
#define VBMAX(v,t) {FAST fastf_t rt; rt=(t); if(rt>v) v = rt;}
		VBMIN( min[X], xlated[0]-stp->st_bradius );		
		VBMAX( max[X], xlated[0]+stp->st_bradius );
		VBMIN( min[Y], xlated[1]-stp->st_bradius );
		VBMAX( max[Y], xlated[1]+stp->st_bradius );
		VBMIN( min[Z], xlated[2]-stp->st_bradius );
		VBMAX( max[Z], xlated[2]+stp->st_bradius );
	}

	if( min[X] >= INFINITY )  {
		/* Only infinite solids (or none), hard to judge */
		VSETALL( min, -0.1 );
		VSETALL( max,  0.1 );
		return;
	}

	/* Provide a slight border */
	min[X] -= fabs(min[X]) * 0.03;
	min[Y] -= fabs(min[Y]) * 0.03;
	min[Z] -= fabs(min[Z]) * 0.03;
	max[X] += fabs(max[X]) * 0.03;
	max[Y] += fabs(max[Y]) * 0.03;
	max[Z] += fabs(max[Z]) * 0.03;
@


4.7
log
@Added first draft of rt_plookup().
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 4.6 87/03/17 22:52:18 phil Exp $ (BRL)";
d1169 27
d1237 2
a1238 1
 *  Right now, it should only be called ONCE per execution.
d1308 70
@


4.6
log
@added tor_curve routine.  minor cosmetics.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 4.5 87/03/11 01:28:51 phil Locked $ (BRL)";
d772 54
@


4.5
log
@Added initial animation capability.
Further eliminated rt_i references, some still remain.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 4.4 87/02/12 22:12:32 mike Exp $ (BRL)";
d47 1
a47 1
extern int hlf_prep(),	hlf_print(),hlf_norm(),hlf_uv();
d89 1
a89 1
		hlf_uv,	hlf_curve,	hlf_class,	"ID_HALF",
d108 1
a108 1
DEF(tor_curve); DEF(tor_class);
@


4.4
log
@Release 1.20 -- First Formal Release
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 4.3 87/02/12 01:51:33 mike Exp $ (BRL)";
a112 1
DEF(ars_curve); DEF(ars_class);
d167 2
a168 1
	mat_t	mat;
d170 1
a170 1
	if(!rt_i.needprep)
d173 1
a173 1
	mat_idn( mat );
d175 14
d193 1
a193 1
	curtree = rt_drawobj( dp, REGION_NULL, 0, mat, &rt_no_mater );
d207 1
a207 1
		rt_add_regtree( regionp, curtree );
d221 5
a225 4
rt_add_solid( rec, name, mat )
union record *rec;
char	*name;
matp_t	mat;
d255 1
a255 1
	for( nsp = rt_i.HeadSolid; nsp != SOLTAB_NULL; nsp = nsp->st_forw )  {
d312 2
a313 2
	stp->st_forw = rt_i.HeadSolid;
	rt_i.HeadSolid = stp;
d324 1
a324 1
		rt_cut_extend( &rt_i.rti_inf_box, stp );
d326 2
a327 2
		VMINMAX( rt_i.mdl_min, rt_i.mdl_max, stp->st_min );
		VMINMAX( rt_i.mdl_min, rt_i.mdl_max, stp->st_max );
d330 1
a330 1
	stp->st_bit = rt_i.nsolids++;
d369 2
a370 1
rt_drawobj( dp, argregion, pathpos, old_xlate, materp )
d372 2
a373 2
struct region *argregion;
matp_t old_xlate;
d398 1
a398 1
	rec = rt_i.rti_db[dp->d_addr];	/* struct copy */
d402 3
a404 3
	rewind(rt_i.fp);
	while( !feof(rt_i.fp) && ftell(rt_i.fp) <= dp->d_addr  &&
	    fread( (char *)&rec, sizeof rec, 1, rt_i.fp ) == 1 )
d407 2
a408 2
	if( fseek( rt_i.fp, dp->d_addr, 0 ) < 0 ||
	    fread( (char *)&rec, sizeof rec, 1, rt_i.fp ) != 1 )  {
d424 1
a424 1
		if( (stp = rt_add_solid( &rec, dp->d_namep, old_xlate )) ==
d488 1
a488 1
			if( rt_i.useair == 0 &&  rec.c.c_aircode != 0 )
d518 1
a518 1
	    rt_i.fp ) != rec.c.c_length )  {
d532 2
d536 1
a536 1
		mp = &(rt_i.rti_db[dp->d_addr+i+1].M);
d548 2
d553 1
a553 1
			static mat_t xmat;	/* temporary fastf_t matrix */
d556 20
d580 2
a581 2
		if( (tlp->tl_tree = rt_drawobj(
		    nextdp, regionp, pathpos+1, new_xlate, &curmater )
d601 1
a601 1
			rt_add_regtree( xrp, (tlp->tl_tree) );
d674 1
a674 1
		rt_add_regtree( regionp, curtree );
d989 1
a989 1
 *  Convert TO 4xfastf_t FROM 3xfloats (for database) 
d994 1
a994 1
register float *fp;
d1039 2
a1040 1
rt_add_regtree( regp, tp )
d1050 2
a1051 2
	regp->reg_forw = rt_i.HeadRegion;
	rt_i.HeadRegion = regp;
d1058 3
a1060 3
	regp->reg_bit = rt_i.nregions;	/* Add to bit vectors */
	/* Will be added to rt_i.Regions[] in final prep stage */
	rt_i.nregions++;
d1064 2
a1065 2
	if( rt_i.RootTree == TREE_NULL )  {
		rt_i.RootTree = tp;
d1072 1
a1072 1
	xor->tr_b.tb_left = rt_i.RootTree;
d1075 1
a1075 1
	rt_i.RootTree = xor;
d1173 3
a1175 3
	if( rt_i.rti_db )  {
		rt_free( (char *)rt_i.rti_db, "in-core database");
		rt_i.rti_db = (union record *)0;
@


4.3
log
@FLEXNAME fix
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 4.2 87/01/28 21:00:25 mike Locked $ (BRL)";
@


4.2
log
@Release 1.16:  added curvature
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 4.1 86/12/29 03:46:42 mike Locked $ (BRL)";
d37 1
a37 1
HIDDEN union tree *rt_make_bool_tree();
d598 1
a598 1
		curtree = rt_make_bool_tree( trees, subtreecount, regionp );
d620 1
a620 1
			tstart->tl_tree = rt_make_bool_tree( tstart, j, regionp );
d628 1
a628 1
		curtree = rt_make_bool_tree( trees, subtreecount, regionp );
d646 1
a646 1
 *			R T _ M A K E _ B O O L _ T R E E
d655 1
a655 1
rt_make_bool_tree( tree_list, howfar, regionp )
d693 1
a693 1
		rt_bomb("rt_make_bool_tree: malloc failed\n");
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.17 86/12/19 04:10:19 mike Exp $ (BRL)";
d110 3
a112 3
DEF(ell_curve); DEF(ell_class);
DEF(arb_curve); DEF(arb_class);
DEF(hlf_curve); DEF(hlf_class);
d114 1
a114 1
DEF(rec_curve); DEF(rec_class);
d1220 2
a1221 2
		VSETALL( min, -10 );
		VSETALL( max,  10 );
@


3.17
log
@Changed to skip bounding of infinite solids when st_aradius >= INFINITY
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.16 86/12/19 04:07:27 mike Locked $ (BRL)";
@


3.16
log
@Added DB_MEM, for in-memory database scans.
Fixed azim/elev mode display of model with only infinite objects.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.15 86/09/24 00:07:12 mike Locked $ (BRL)";
d308 1
a308 1
	if( stp->st_max[X] >= INFINITY )  {
@


3.15
log
@Shortened initializers for 3-tuple vect_t's.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.14 86/08/12 04:17:08 mike Exp $ (BRL)";
d381 3
d390 1
a390 1
#else
d397 2
a398 1
#endif
d497 4
d507 1
d517 3
d521 1
d1132 5
d1205 2
d1216 7
@


3.14
log
@Changed #include directives for use with CC -I convention
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.13 86/08/06 19:56:29 mike Exp $ (BRL)";
d198 3
a200 3
static vect_t xaxis = { 1.0, 0, 0, 0 };
static vect_t yaxis = { 0, 1.0, 0, 0 };
static vect_t zaxis = { 0, 0, 1.0, 0 };
@


3.13
log
@Added Cray COS rewind&read instead of fseek hack (conditionally).
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.12 86/07/31 08:30:34 mike Exp $ (BRL)";
d24 5
a28 5
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/db.h"
#include "../h/raytrace.h"
#include "debug.h"
@


3.12
log
@Adjusted floor/ceil parameters.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.11 86/07/31 06:29:13 mike Exp $ (BRL)";
d381 7
d394 1
d421 3
a423 2
		rt_log("rt_drawobj:  defective database record, type '%c'\n",
			rec.u_id );
d509 4
@


3.11
log
@Enlarged model RPP.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.10 86/07/30 03:54:58 mike Exp $ (BRL)";
d1121 6
a1126 6
	rtip->mdl_min[X] = floor( rtip->mdl_min[X] - 1 );
	rtip->mdl_min[Y] = floor( rtip->mdl_min[Y] - 1 );
	rtip->mdl_min[Z] = floor( rtip->mdl_min[Z] - 1 );
	rtip->mdl_max[X] = ceil( rtip->mdl_max[X] + 1 );
	rtip->mdl_max[Y] = ceil( rtip->mdl_max[Y] + 1 );
	rtip->mdl_max[Z] = ceil( rtip->mdl_max[Z] + 1 );
@


3.10
log
@improvements.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.9 86/07/24 23:11:16 mike Exp $ (BRL)";
d287 2
a288 2
	stp->st_max[X] = stp->st_max[Y] = stp->st_max[Z] = -INFINITY;
	stp->st_min[X] = stp->st_min[Y] = stp->st_min[Z] =  INFINITY;
d1117 11
d1170 2
a1171 2
	max[X] = max[Y] = max[Z] = -INFINITY;
	min[X] = min[Y] = min[Z] =  INFINITY;
@


3.9
log
@Change of name for non-FLEXNAMES.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.8 86/07/24 06:23:10 mike Exp $ (BRL)";
d1093 1
a1093 1
struct rt_i *rtip;
d1098 3
a1100 1
	if(!rt_i.needprep)
d1102 2
a1103 2
	rt_i.needprep = 0;
	if( rt_i.nsolids <= 0 )
d1107 1
a1107 1
	 *  Allocate space for a per-solid bit of rt_i.nregions length.
d1109 1
a1109 1
	for( stp=rt_i.HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw )  {
d1111 1
a1111 1
			BITS2BYTES(rt_i.nregions)+sizeof(bitv_t),
d1113 1
a1113 1
		BITZERO( stp->st_regions, rt_i.nregions );
d1122 5
a1126 5
	rt_i.Regions = (struct region **)rt_malloc(
		rt_i.nregions * sizeof(struct region *),
		"rt_i.Regions[]" );
	for( regp=rt_i.HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
		rt_i.Regions[regp->reg_bit] = regp;
d1134 1
a1134 1
		for( stp=rt_i.HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw )  {
d1142 1
a1142 1
	rt_cut_it();
@


3.8
log
@Expanded functab, added rt_rpp_region from Moss.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.7 86/07/19 04:43:48 mike Exp $ (BRL)";
d40 1
a40 1
HIDDEN struct region *rt_find_region();
d866 1
a866 1
 *			R T _ F I N D _ R E G I O N
d877 1
a877 1
rt_find_region( rtip, reg_name )
d902 1
a902 1
 *  the region node in the database.  See remarks in rt_find_region()
d912 1
a912 1
	register struct region	*regp = rt_find_region( rtip, reg_name );
@


3.7
log
@Added support for infinite solids
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.6 86/07/18 00:22:03 mike Exp $ (BRL)";
d38 3
d47 1
a47 1
extern int half_prep(),	half_print(),half_norm(),half_uv();
d53 11
d70 1
a70 1
extern struct seg *half_shot();
d76 22
a97 11
	nul_prep, nul_shot, nul_print, nul_norm, nul_uv, "ID_NULL",
	tor_prep, tor_shot, tor_print, tor_norm, tor_uv, "ID_TOR",
	tgc_prep, tgc_shot, tgc_print, tgc_norm, tgc_uv, "ID_TGC",
	ell_prep, ell_shot, ell_print, ell_norm, ell_uv, "ID_ELL",
	arb_prep, arb_shot, arb_print, arb_norm, arb_uv, "ID_ARB8",
	ars_prep, ars_shot, ars_print, ars_norm, ars_uv, "ID_ARS",
	half_prep,half_shot,half_print,half_norm,half_uv,"ID_HALF",
	rec_prep, rec_shot, rec_print, rec_norm, rec_uv, "ID_REC",
	pg_prep,  pg_shot,  pg_print,  pg_norm,  pg_uv,  "ID_POLY",
	spl_prep, spl_shot, spl_print, spl_norm, spl_uv, "ID_BSPLINE",
	nul_prep, nul_shot, nul_print, nul_norm, nul_uv, ">ID_NULL"
d107 11
a301 7
	/* Update the model maxima and minima */
#define TREE_MINMAX(a,b,c)	{ if( (c) < (a) )  a = (c);\
			if( (c) > (b) )  b = (c); }

#define TREE_MM(v)	TREE_MINMAX( rt_i.mdl_min[X], rt_i.mdl_max[X], v[X] ); \
		TREE_MINMAX( rt_i.mdl_min[Y], rt_i.mdl_max[Y], v[Y] ); \
		TREE_MINMAX( rt_i.mdl_min[Z], rt_i.mdl_max[Z], v[Z] )
d303 2
d311 2
a312 2
		TREE_MM( stp->st_min );
		TREE_MM( stp->st_max );
d801 120
d944 1
d947 2
a948 1
rt_find_solid( name )
d953 1
a953 1
	for( stp = rt_i.HeadSolid; stp != SOLTAB_NULL; stp = stp->st_forw )  {
@


3.6
log
@Bulletproofing.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.5 86/07/17 18:20:01 mike Exp $ (BRL)";
a27 1
#include "rtdir.h"
d44 1
a44 1
extern int haf_prep(),	haf_print(), haf_norm(), haf_uv();
d56 1
a56 1
extern struct seg *haf_shot();
d68 1
a68 1
	haf_prep, haf_shot, haf_print, haf_norm, haf_uv, "ID_HALF",
a81 3
/* To be replaced with code someday */
DEF(haf_prep); struct seg * DEF(haf_shot); DEF(haf_print); DEF(haf_norm); DEF(haf_uv);

d107 2
d126 2
a127 1
rt_gettree(node)
d273 10
a282 2
	TREE_MM( stp->st_min );
	TREE_MM( stp->st_max );
d939 2
a940 1
rt_prep()
@


3.5
log
@Upgraded to read the database using stdio.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.4 86/07/11 21:51:20 mike Exp $ (BRL)";
d938 1
a938 1
		rt_bomb("second invocation of rt_prep");
d940 2
@


3.4
log
@shortened name for xmp
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.3 86/07/11 17:23:26 mike Exp $ (BRL)";
d343 2
a344 2
	if( lseek( rt_i.fd, dp->d_addr, 0 ) < 0 ||
	    read( rt_i.fd, (char *)&rec, sizeof rec ) != sizeof rec )  {
d446 2
a447 1
	if( read( rt_i.fd, (char *)members, i ) != i )  {
@


3.3
log
@material to mater_info for non-flexnames.
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.2 86/07/11 01:33:37 mike Exp $ (BRL)";
d36 1
a36 1
HIDDEN union tree *rt_draw_obj();
d144 1
a144 1
	curtree = rt_draw_obj( dp, REGION_NULL, 0, mat, &rt_no_mater );
d316 1
a316 1
rt_draw_obj( dp, argregion, pathpos, old_xlate, materp )
d345 1
a345 1
		rt_log("rt_draw_obj: %s record read error\n",
d365 1
a365 1
			rt_bomb("rt_draw_obj: solid tree malloc failed\n");
d375 1
a375 1
		rt_log("rt_draw_obj:  defective database record, type '%c'\n",
d444 1
a444 1
		rt_bomb("rt_draw_obj:  malloc failure\n");
d447 1
a447 1
		rt_log("rt_draw_obj:  %s member read error\n",
d475 1
a475 1
		if( (tlp->tl_tree = rt_draw_obj(
@


3.2
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d19 1
a19 1
static char RCStree[] = "@@(#)$Header: tree.c,v 3.1 86/06/11 00:35:03 mike Exp $ (BRL)";
d116 1
a116 1
static struct material rt_no_mater;
d320 1
a320 1
struct material *materp;
d331 1
a331 1
	struct material curmater;
@


3.1
log
@Support for new object-oriented material-property code.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 3.0 86/06/10 01:34:34 mike Exp $ (BRL)";
a35 3
#define MINMAX(a,b,c)	{ if( (c) < (a) )  a = (c);\
			if( (c) > (b) )  b = (c); }

d192 3
a194 1
	if( ! NEAR_ZERO(fx) || ! NEAR_ZERO(fy) || ! NEAR_ZERO(fz) )  {
d216 1
a216 1
			if( !NEAR_ZERO(f) )
d268 2
a269 5
#define MMM(v)		MINMAX( rt_i.mdl_min[X], rt_i.mdl_max[X], v[X] ); \
			MINMAX( rt_i.mdl_min[Y], rt_i.mdl_max[Y], v[Y] ); \
			MINMAX( rt_i.mdl_min[Z], rt_i.mdl_max[Z], v[Z] )
	MMM( stp->st_min );
	MMM( stp->st_max );
d271 6
d429 1
a429 1
			nrp->reg_material = rec.c.c_material;
d679 1
a679 1
		rp->reg_material, rp->reg_los );
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 2.13 86/06/09 21:52:32 mike Exp $ (BRL)";
d119 1
a119 1
extern void color_map();
a120 1

d147 1
a147 1
	curtree = rt_draw_obj( dp, REGION_NULL, 0, mat );
d314 1
a314 1
rt_draw_obj( dp, argregion, pathpos, old_xlate )
d318 1
d329 1
d388 19
d418 2
a419 2
			/* HACK:  ignore "air" solids */
			if( rec.c.c_aircode != 0 )
d429 2
d474 2
a475 1
		    nextdp, regionp, pathpos+1, new_xlate )) == TREE_NULL )
d675 1
a675 1
	rt_log("id=%d, air=%d, material=%d, los=%d\n",
d678 9
d822 1
d824 5
a828 3
	color_map(regp);
	/* Add to bit vectors */
	regp->reg_bit = rt_i.nregions;
@


2.13
log
@rt and librt separated
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 2.12 86/03/27 21:20:36 mike Exp $ (BRL)";
d31 3
a35 7
union tree *RootTree;		/* Root of tree containing all regions */
struct region *HeadRegion;
struct region **Regions;	/* Ptr to array indexed by reg_bit */

/* A bounding RPP around the whole model */
vect_t mdl_min = {  INFINITY,  INFINITY,  INFINITY };
vect_t mdl_max = { -INFINITY, -INFINITY, -INFINITY };
d39 3
a41 3
HIDDEN union tree *drawHobj();
HIDDEN void add_regtree();
HIDDEN union tree *make_bool_tree();
d65 1
a65 1
struct functab functab[] = {
d82 1
a82 1
#define DEF(func)	func() { rtlog("func unimplemented\n"); return(0); }
d117 1
a117 1
HIDDEN char *path_str();
a119 1
extern int rt_needprep;
d123 1
a123 1
 *  			G E T _ T R E E
d132 1
a132 1
get_tree(node)
d139 2
a140 2
	if(!rt_needprep)
		rtbomb("get_tree called again after rt_prep!");
d144 1
a144 1
	dp = dir_lookup( node, LOOKUP_NOISY );
d148 1
a148 1
	curtree = drawHobj( dp, REGION_NULL, 0, mat );
d157 2
a158 2
		rtlog("Warning:  Top level solid, region %s created\n",
			path_str(0) );
d160 3
a162 3
			rtbomb("root subtree not Solid");
		regionp->reg_name = strdup(path_str(0));
		add_regtree( regionp, curtree );
d171 3
d176 1
a176 1
add_solid( rec, name, mat )
d197 1
a197 1
		rtlog("add_solid(%s):  matrix does not preserve axis perpendicularity.\n  X.Y=%f, Y.Z=%f, X.Z=%f\n",
d207 1
a207 1
	for( nsp = HeadSolid; nsp != SOLTAB_NULL; nsp = nsp->st_forw )  {
d222 2
a223 2
		if( debug & DEBUG_SOLIDS )
			rtlog("add_solid:  %s re-referenced\n",
d234 1
a234 1
		fastf_float( v, rec->s.s_values, 8 );
d246 1
a246 1
		rtlog("add_solid:  u_id=x%x unknown\n", rec->u_id);
d257 1
a257 1
	if( functab[stp->st_id].ft_prep( v, stp, mat, &(rec->s) ) )  {
d264 2
a265 2
	stp->st_forw = HeadSolid;
	HeadSolid = stp;
d270 3
a272 3
#define MMM(v)		MINMAX( mdl_min[X], mdl_max[X], v[X] ); \
			MINMAX( mdl_min[Y], mdl_max[Y], v[Y] ); \
			MINMAX( mdl_min[Z], mdl_max[Z], v[Z] )
d276 3
a278 3
	stp->st_bit = nsolids++;
	if(debug&DEBUG_SOLIDS)  {
		rtlog("-------------- %s (bit %d) -------------\n",
d281 2
a282 2
		rtlog("Approx Sph Radius = %f\n", stp->st_aradius);
		rtlog("Bounding Sph Radius = %f\n", stp->st_bradius);
d285 1
a285 1
		functab[stp->st_id].ft_print( stp );
d304 1
a304 1
 *			D R A W H O B J
d307 1
a307 1
 * The actual processing of solids is performed by add_solid(),
d315 1
a315 1
drawHobj( dp, argregion, pathpos, old_xlate )
d331 2
a332 2
		rtlog("%s: nesting exceeds %d levels\n",
			path_str(MAXLEVELS), MAXLEVELS );
d340 4
a343 4
	if( lseek( ged_fd, dp->d_addr, 0 ) < 0 ||
	    read( ged_fd, (char *)&rec, sizeof rec ) != sizeof rec )  {
		rtlog("drawHobj: %s record read error\n",
			path_str(pathpos) );
d355 1
a355 1
		if( (stp = add_solid( &rec, dp->d_namep, old_xlate )) ==
d360 1
a360 1
		if( (xtp=(union tree *)vmalloc(sizeof(union tree), "solid tree"))
d362 1
a362 1
			rtbomb("drawHobj: solid tree malloc failed\n");
d366 1
a366 1
		xtp->tr_a.tu_name = strdup(path_str(pathpos));
d372 1
a372 1
		rtlog("drawHobj:  defective database record, type '%c'\n",
d381 1
a381 1
		rtlog(  "Warning: combination with zero members \"%.16s\".\n",
d390 3
a392 3
			if( debug & DEBUG_REGIONS )
				rtlog("Warning:  region %s within region %s\n",
					path_str(pathpos),
d408 1
a408 1
			nrp->reg_name = strdup(path_str(pathpos));
d416 1
a416 1
	if( (members = (union record *)vmalloc(i, "member records")) ==
d418 1
a418 1
	    (trees = (struct tree_list *)vmalloc( j, "tree_list array" )) ==
d420 1
a420 1
		rtbomb("drawHobj:  malloc failure\n");
d422 3
a424 3
	if( read( ged_fd, (char *)members, i ) != i )  {
		rtlog("drawHobj:  %s member read error\n",
			path_str(pathpos) );
d437 1
a437 1
		if( (nextdp = dir_lookup( mp->m_instname, LOOKUP_NOISY )) ==
d451 1
a451 1
		if( (tlp->tl_tree = drawHobj(
d465 2
a466 2
			rtlog("Warning:  Forced to create region %s\n",
				path_str(pathpos+1) );
d468 1
a468 1
				rtbomb("subtree not Solid");
d470 2
a471 2
			xrp->reg_name = strdup(path_str(pathpos+1));
			add_regtree( xrp, (tlp->tl_tree) );
d479 1
a479 1
			rtlog("%s: bad m_relation '%c'\n",
d499 2
a500 2
			vfree( regionp->reg_name, "unused region name" );
			vfree( (char *)regionp, "unused region struct" );
d508 1
a508 1
		curtree = make_bool_tree( trees, subtreecount, regionp );
d530 2
a531 2
			tstart->tl_tree = make_bool_tree( tstart, j, regionp );
			if(debug&DEBUG_REGIONS) pr_tree(tstart->tl_tree, 0);
d538 2
a539 2
		curtree = make_bool_tree( trees, subtreecount, regionp );
		if(debug&DEBUG_REGIONS) pr_tree(curtree, 0);
d544 1
a544 1
		add_regtree( regionp, curtree );
d550 2
a551 2
	vfree( (char *)trees, "tree_list array");
	vfree( (char *)members, "member records" );
d556 1
a556 1
 *			M A K E _ B O O L _ T R E E
d565 1
a565 1
make_bool_tree( tree_list, howfar, regionp )
d587 2
a588 2
	if( debug & DEBUG_REGIONS && first_tlp->tl_op != OP_UNION )
		rtlog("Warning: %s: non-union first operation ignored\n",
d602 2
a603 2
	if( (xtp=(union tree *)vmalloc( i, "tree array")) == TREE_NULL )
		rtbomb("make_bool_tree: malloc failed\n");
d623 3
d627 1
a627 1
path_str( pos )
d644 3
d648 1
a648 1
pr_region( rp )
d651 2
a652 2
	rtlog("REGION %s (bit %d)\n", rp->reg_name, rp->reg_bit );
	rtlog("id=%d, air=%d, material=%d, los=%d\n",
d655 2
a656 2
	pr_tree( rp->reg_treetop, 0 );
	rtlog("\n");
d659 3
d663 1
a663 1
pr_tree( tp, lvl )
d669 1
a669 1
	rtlog("%.8x ", tp);
d671 1
a671 1
		rtlog("  ");
d674 1
a674 1
		rtlog("Null???\n");
d681 1
a681 1
		rtlog("SOLID %s (bit %d)",
d687 1
a687 1
		rtlog("Unknown op=x%x\n", tp->tr_op );
d691 1
a691 1
		rtlog("UNION");
d694 1
a694 1
		rtlog("INTERSECT");
d697 1
a697 1
		rtlog("MINUS");
d700 1
a700 1
		rtlog("XOR");
d703 1
a703 1
		rtlog("NOT");
d706 1
a706 1
	rtlog("\n");
d716 2
a717 2
		pr_tree( tp->tr_b.tb_left, lvl+1 );
		pr_tree( tp->tr_b.tb_right, lvl+1 );
d722 1
a722 1
		pr_tree( tp->tr_b.tb_left, lvl+1 );
d727 5
a731 1
/* Convert TO 4xfastf_t FROM 3xfloats (for database)  */
d733 1
a733 1
fastf_float( ff, fp, n )
d747 1
a747 1
 *  			S O L I D _ P O S
a748 30
 *  Let the user enquire about the position of the Vertex (V vector)
 *  of a solid.  Useful mostly to find the light sources.
 *
 *  Returns:
 *	0	If solid found and ``pos'' vector filled in.
 *	-1	If error.  ``pos'' vector left untouched.
 */
int
solid_pos( name, pos )
char *name;
vect_t *pos;
{
	register struct directory *dp;
	auto union record rec;		/* local copy of this record */

	if( (dp = dir_lookup( name, LOOKUP_QUIET )) == DIR_NULL )
		return(-1);	/* BAD */
	
	(void)lseek( ged_fd, dp->d_addr, 0 );
	(void)read( ged_fd, (char *)&rec, sizeof rec );

	if( rec.u_id != ID_SOLID )
		return(-1);	/* BAD:  too hard */
	fastf_float( pos, rec.s.s_values, 1 );
	return(0);		/* OK */
}

/*
 *  			F I N D _ S O L I D
 *  
d753 1
a753 1
find_solid( name )
d758 1
a758 1
	for( stp = HeadSolid; stp != SOLTAB_NULL; stp = stp->st_forw )  {
d769 1
a769 1
 *  			A D D _ R E G T R E E
d778 1
a778 1
add_regtree( regp, tp )
d788 2
a789 2
	regp->reg_forw = HeadRegion;
	HeadRegion = regp;
d793 5
a797 5
	regp->reg_bit = nregions;
	/* Will be added to Regions[] in final prep stage */
	nregions++;
	if( debug & DEBUG_REGIONS )
		rtlog("Add Region %s\n", regp->reg_name);
d799 2
a800 2
	if( RootTree == TREE_NULL )  {
		RootTree = tp;
d804 1
a804 1
	xor = (union tree *)vmalloc(sizeof(union tree), "add_regtree tree");
d807 1
a807 1
	xor->tr_b.tb_left = RootTree;
d810 1
a810 1
	RootTree = xor;
d813 5
a817 1
optim_tree( tp )
d841 1
a841 1
		rtlog("optim_tree: bad op x%x\n", tp->tr_op);
d845 2
a846 2
	optim_tree( tp->tr_b.tb_left );
	optim_tree( tp->tr_b.tb_right );
d857 1
a857 1
solid_bitfinder( treep, regbit )
d868 2
a869 2
		if( debug&DEBUG_REGIONS )  {
			pr_bitv( stp->st_name, stp->st_regions,
d877 2
a878 2
		solid_bitfinder( treep->tr_b.tb_left, regbit );
		solid_bitfinder( treep->tr_b.tb_right, regbit );
d881 1
a881 1
		rtlog("solid_bitfinder:  op=x%x\n", treep->tr_op);
d890 1
a890 1
 *  This routine should be called just before the first call to shootray().
d899 3
a901 3
	if(!rt_needprep)
		rtbomb("second invocation of rt_prep");
	rt_needprep = 0;
d904 1
a904 1
	 *  Allocate space for a per-solid bit of nregions length.
d906 3
a908 3
	for( stp=HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw )  {
		stp->st_regions = (bitv_t *)vmalloc(
			BITS2BYTES(nregions)+sizeof(bitv_t),
d910 1
a910 1
		BITZERO( stp->st_regions, nregions );
d919 9
a927 9
	Regions = (struct region **)vmalloc(
		nregions * sizeof(struct region *),
		"Regions[]" );
	for( regp=HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
		Regions[regp->reg_bit] = regp;
		optim_tree( regp->reg_treetop );
		solid_bitfinder( regp->reg_treetop, regp->reg_bit );
		if(debug&DEBUG_REGIONS)  {
			pr_region( regp );
d930 4
a933 4
	if(debug&DEBUG_REGIONS)  {
		for( stp=HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw )  {
			rtlog("solid %s ", stp->st_name);
			pr_bitv( "regions ref", stp->st_regions,
d939 1
a939 1
	cut_it();
d943 1
a943 1
 *			V I E W B O U N D S
d949 1
a949 1
viewbounds( min, max, m2v )
d959 1
a959 1
	for( stp=HeadSolid; stp != 0; stp=stp->st_forw ) {
@


2.12
log
@Added fix from Moss to check for zero length combination record.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 2.11 86/03/14 21:57:27 mike Exp $ (BRL)";
d27 1
a27 1
#include "raytrace.h"
@


2.11
log
@Increased MAXLEVELS.
Changed DEF macro for lint, made "region within region"
message conditional on DEBUG_REGIONS, per Moss.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 2.10 86/03/14 21:08:03 mike Exp $ (BRL)";
d382 5
@


2.10
log
@Changed for new spline format.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 2.9 86/01/29 13:33:04 mike Exp $ (BRL)";
d86 1
a86 1
#define DEF(func)	func() { rtlog("func unimplemented\n"); }
d292 6
a297 1
#define	MAXLEVELS	8
d387 4
a390 2
			rtlog("Warning:  region %s within region %s\n",
				path_str(pathpos), argregion->reg_name );
d624 1
a624 1
	static char line[256];
d632 1
a632 1
		(void)sprintf( cp, "/%s%c", path[i]->d_namep, '\0' );
@


2.9
log
@Made non-union warning conditional on debugging being turned on.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 2.8 86/01/20 23:39:27 mike Exp $ (BRL)";
a91 1
DEF(spl_prep); struct seg * DEF(spl_shot); DEF(spl_print); DEF(spl_norm); DEF(spl_uv);
d244 1
a244 1
	case ID_B_SPL_HEAD:
d348 1
a348 1
	    rec.u_id == ID_P_HEAD || rec.u_id == ID_B_SPL_HEAD )  {
@


2.8
log
@Reimplemented drawHobj() to read whole group of Member records
into dynamic memory, rather than doing lots of seeking and small reads.
Also implemented GIFT-style grouping around UNION operations,
to cope with models built that way (all of BRL's models, sigh).
Pure boolean operation can be optained if caller sets extern int
rt_pure_boolean_expresions=1.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 2.7 85/10/02 22:35:14 mike Exp $ (BRL)";
d578 1
a578 1
	if( first_tlp->tl_op != OP_UNION )
@


2.7
log
@Intermediate stage along the way to new material properties.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 2.6 85/09/24 18:36:12 mike Exp $ (BRL)";
d31 2
d45 1
d296 4
a299 1
static mat_t xmat;				/* temporary fastf_t matrix */
d307 3
a317 2
	auto struct directory *nextdp;	/* temporary */
	auto mat_t new_xlate;		/* Accumulated xlation matrix */
d319 8
a326 6
	auto long savepos;
	auto int nparts;		/* Number of sub-parts to this comb */
	auto int i;
	register union tree *curtree;	/* ptr to current tree top */
	auto union tree *subtree;	/* ptr to subtree passed up */
	register struct region *regionp;
d335 9
a343 2
	/* Routine is recursive:  save file pointer for restoration. */
	savepos = lseek( ged_fd, 0L, 1 );
d346 1
a346 1
	 * Load the record into local record buffer
a347 3
	(void)lseek( ged_fd, dp->d_addr, 0 );
	(void)read( ged_fd, (char *)&rec, sizeof rec );

d350 2
a351 1
		register struct soltab *stp;		/* XXX */
d353 2
a354 4
		/* Draw a solid */
		stp = add_solid( &rec, dp->d_namep, old_xlate );
		(void)lseek( ged_fd, savepos, 0);	/* restore pos */
		if( stp == SOLTAB_NULL )
d357 10
a366 10
		/**GETSTRUCT( curtree, union tree ); **/
		curtree = (union tree *)malloc(sizeof(union tree));
		if( curtree == TREE_NULL )
			rtbomb("drawHobj: curtree malloc failed\n");
		bzero( (char *)curtree, sizeof(union tree) );
		curtree->tr_op = OP_SOLID;
		curtree->tr_a.tu_stp = stp;
		curtree->tr_a.tu_name = strdup(path_str(pathpos));
		curtree->tr_regionp = argregion;
		return( curtree );
d370 2
a371 1
		rtlog("drawobj:  defective input '%c'\n", rec.u_id );
d375 3
a377 1
	/* recurse down through a combination (directory) node */
d379 2
d383 2
a384 3
			rtlog("Warning:  region %s within region %s (ID %d overrides)\n",
				path_str(pathpos), argregion->reg_name,
				argregion->reg_regionid );
d387 2
d390 1
a390 2
			if( rec.c.c_aircode != 0 )  {
				(void)lseek(ged_fd, savepos, 0);
a391 1
			}
d394 7
a400 6
			GETSTRUCT( regionp, region );
			regionp->reg_forw = REGION_NULL;
			regionp->reg_regionid = rec.c.c_regionid;
			regionp->reg_aircode = rec.c.c_aircode;
			regionp->reg_material = rec.c.c_material;
			regionp->reg_name = "being created";
d403 27
a429 6
	curtree = TREE_NULL;
	nparts = rec.c.c_length;		/* save in an auto var */
	for( i=0; i<nparts; i++ )  {
		(void)read(ged_fd, (char *)&rec, sizeof rec );
		nextdp = dir_lookup( rec.M.m_instname, LOOKUP_NOISY );
		if( nextdp == DIR_NULL )
d431 2
d434 5
a438 3
			register int j;
			for( j=0; j<4*4; j++ )
				xmat[j] = rec.M.m_mat[j];/* cvt to fastf_t */
a439 1
		mat_mul(new_xlate, old_xlate, xmat);
d442 4
a445 3
		subtree = drawHobj( nextdp, regionp, pathpos+1, new_xlate );
		if( subtree == TREE_NULL )
			continue;	/* no valid subtree, keep on going */
d458 1
a458 1
			if(subtree->tr_op != OP_SOLID )
d462 2
a463 1
			add_regtree( xrp, subtree );
d467 15
a481 25
		if( curtree == TREE_NULL )  {
			curtree = subtree;
		} else {
			register union tree *xtp;	/* XXX */
			/** GETSTRUCT( xtp, union tree ); **/
			xtp=(union tree *)malloc(sizeof(union tree));
			if( xtp == TREE_NULL )
				rtbomb("drawHobj: xtp malloc failed\n");
			bzero( (char *)xtp, sizeof(union tree) );
			xtp->tr_b.tb_left = curtree;
			xtp->tr_b.tb_right = subtree;
			xtp->tr_b.tb_regionp = regionp;
			switch( rec.M.m_relation )  {
			default:
				rtlog("(%s) bad m_relation '%c'\n",
					path_str(pathpos), rec.M.m_relation );
				/* FALL THROUGH */
			case UNION:
				xtp->tr_op = OP_UNION; break;
			case SUBTRACT:
				xtp->tr_op = OP_SUBTRACT; break;
			case INTERSECT:
				xtp->tr_op = OP_INTERSECT; break;
			}
			curtree = xtp;
d483 2
a485 7
	if( curtree != TREE_NULL )  {
		if( regionp == REGION_NULL )  {
			rtlog("drawHobj: (%s) null regionp, non-null curtree\n", path_str(pathpos) );
		} else if( argregion == REGION_NULL )  {
			/* Region began at this level */
			regionp->reg_name = strdup(path_str(pathpos));
			add_regtree( regionp, curtree );
d487 5
a491 2
			/* Return to caller indicates no remaining subtree */
			curtree = TREE_NULL;
d493 7
d501 30
a530 3
		/* Null result tree, release region struct */
		if( argregion == REGION_NULL && regionp != REGION_NULL )
			free( regionp );
d533 10
a542 2
	/* Clean up and return */
	(void)lseek( ged_fd, savepos, 0 );
d544 68
@


2.6
log
@Added support for polygonal and spline objects;  neatened
handling of ARS.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 2.5 85/09/14 05:27:34 mike Exp $ (BRL)";
a382 1
			regionp->reg_los = rec.c.c_los;
@


2.5
log
@Created new macro BITS2BYTES to unify sizing of bit vectors.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 2.4 85/09/10 01:06:35 mike Exp $ (BRL)";
d52 2
d63 2
d75 2
d89 1
d91 1
d114 1
a114 1
	ID_ARS,		/* ARS 21: arbitrary triangular-surfaced polyhedron */
a228 3
	/* Convert from database (float) to fastf_t */
	fastf_float( v, rec->s.s_values, 8 );

d230 20
a249 1
	stp->st_id = idmap[rec->s.s_type];	/* PUN for a.a_type, too */
d335 2
a336 1
	if( rec.u_id == ID_SOLID || rec.u_id == ID_ARS_A )  {
@


2.4
log
@Neatened up code for viewbounds slightly.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 2.3 85/09/06 02:30:39 mike Exp $ (BRL)";
d747 1
a747 1
			(nregions/sizeof(bitv_t))+sizeof(bitv_t),
@


2.3
log
@Added hack to omit "AIR" regions, as they cause lots of overlaps.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 2.2 85/09/05 02:21:33 mike Exp $ (BRL)";
d23 1
d811 6
a816 6
	min[X] -= min[X] * 0.03;
	min[Y] -= min[Y] * 0.03;
	min[Z] -= min[Z] * 0.03;
	max[X] *= 1.03;
	max[Y] *= 1.03;
	max[Z] *= 1.03;
@


2.2
log
@Added find_solid, which returns a soltab pointer given a solid
(leaf) name.  Mostly useful for identifying light sources.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 2.1 85/08/31 06:07:59 mike Exp $ (BRL)";
d345 6
@


2.1
log
@Version 2 of RT
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.33 85/07/30 05:56:25 mike Exp $ (BRL)";
d581 22
@


1.33
log
@Changes for merged GED & RT vmath.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.32 85/06/04 23:24:25 mike Exp $ (BRL)";
d30 1
d32 1
d41 1
d43 8
a50 8
extern int nul_prep(),	nul_print();
extern int tor_prep(),	tor_print();
extern int tgc_prep(),	tgc_print();
extern int ell_prep(),	ell_print();
extern int arb_prep(),	arb_print();
extern int haf_prep(),	haf_print();
extern int ars_prep(),  ars_print();
extern int rec_print();
d62 9
a70 8
	nul_prep,	nul_shot,	nul_print,	"ID_NULL",
	tor_prep,	tor_shot,	tor_print,	"ID_TOR",
	tgc_prep,	tgc_shot,	tgc_print,	"ID_TGC",
	ell_prep,	ell_shot,	ell_print,	"ID_ELL",
	arb_prep,	arb_shot,	arb_print,	"ID_ARB8",
	ars_prep,	ars_shot,	ars_print,	"ID_ARS",
	haf_prep,	haf_shot,	haf_print,	"ID_HALF",
	nul_prep,	nul_shot,	nul_print,	">ID_NULL"
d76 1
a76 1
#define DEF(func)	func() { fprintf(stderr,"func unimplemented\n"); }
d78 1
a78 2
DEF(haf_prep); struct seg * DEF(haf_shot); DEF(haf_print);
DEF(nul_prep); struct seg * DEF(nul_shot); DEF(nul_print);
d80 3
d112 2
a113 1
extern char *color_map();
d133 3
d151 1
a151 2
		regionp->reg_active = REGION_NULL;
		fprintf(stderr,"Warning:  Top level solid, region %s created\n",
a154 3
		curtree->tr_regionp = regionp;
		curtree->tr_materp = color_map(regionp);
		regionp->reg_treetop = curtree;
d156 1
a156 3
		regionp->reg_forw = HeadRegion;
		HeadRegion = regionp;
		nregions++;
a157 10

	if( debug & DEBUG_REGIONS )  {
		register struct region *rp = HeadRegion;	/* XXX */

		fprintf(stderr,"printing regions\n");
		while( rp != REGION_NULL )  {
			pr_region( rp );
			rp = rp->reg_forw;
		}
	}
d188 1
a188 1
		fprintf(stderr,"add_solid(%s):  matrix does not preserve axis perpendicularity.\n  X.Y=%f, Y.Z=%f, X.Z=%f\n",
d201 5
a205 1
		if( strcmp( name, nsp->st_name ) != 0 )
a212 1
		nsp->st_uses++;
d214 2
a215 2
			fprintf(stderr,"add_solid:  use %d of %s!!\n",
				nsp->st_uses, name );
a242 1
	stp->st_uses = 1;
d251 1
d253 2
a254 1
		fprintf(stderr,"-------------- %s -------------\n", stp->st_name);
d256 2
a257 1
		fprintf(stderr,"Bound Sph Rad**2 = %f\n", stp->st_radsq);
a261 1
	nsolids++;
d295 1
a295 1
		fprintf(stderr,"%s: nesting exceeds %d levels\n",
d325 2
a326 2
		curtree->tr_stp = stp;
		curtree->tr_name = strdup(path_str(pathpos));
a327 3
		curtree->tr_materp = color_map(argregion);
		VMOVE( curtree->tr_min, stp->st_min );
		VMOVE( curtree->tr_max, stp->st_max );
d332 1
a332 1
		fprintf(stderr,"drawobj:  defective input '%c'\n", rec.u_id );
d340 1
a340 1
			fprintf(stderr,"Warning:  region %s within region %s (ID %d overrides)\n",
d347 1
a347 1
			regionp->reg_forw = regionp->reg_active = REGION_NULL;
a374 1
			register struct soltab *stp;
d383 1
a383 1
			fprintf(stderr,"Warning:  Forced to create region %s\n",
a386 1
			stp = subtree->tr_stp;
a387 3
			xrp->reg_treetop = subtree;
			subtree->tr_regionp = xrp;
			subtree->tr_materp = color_map(xrp);
d389 1
a389 4
			xrp->reg_forw = HeadRegion;
			HeadRegion = xrp;
			xrp->reg_active = REGION_NULL;
			nregions++;
d402 3
a404 2
			xtp->tr_left = curtree;
			xtp->tr_right = subtree;
d407 1
a407 1
				fprintf(stderr,"(%s) bad m_relation '%c'\n",
a416 10

			/* Compute bounding RPP of full subtree */
#define MM(v)		MINMAX( xtp->tr_min[X], xtp->tr_max[X], v[X] ); \
			MINMAX( xtp->tr_min[Y], xtp->tr_max[Y], v[Y] ); \
			MINMAX( xtp->tr_min[Z], xtp->tr_max[Z], v[Z] )

			VMOVE( xtp->tr_min, curtree->tr_min );
			VMOVE( xtp->tr_max, curtree->tr_max );
			MM( subtree->tr_min );
			MM( subtree->tr_max );
d422 1
a422 1
			fprintf(stderr,"drawHobj: (%s) null regionp, non-null curtree\n", path_str(pathpos) );
a424 1
			regionp->reg_treetop = curtree;
d426 3
a428 5
			regionp->reg_forw = HeadRegion;
			HeadRegion = regionp;
			nregions++;
			if( debug & DEBUG_REGIONS )
				fprintf(stderr,"Add Region %s\n", regionp->reg_name);
d464 2
a465 2
	fprintf(stderr,"REGION %s:\n", rp->reg_name );
	fprintf(stderr,"id=%d, air=%d, material=%d, los=%d\n",
d469 1
a469 1
	fprintf(stderr,"\n");
d479 3
a481 3
	fprintf(stderr,"%.8x ", tp);
	for( i=3*lvl; i>0; i-- )
		putc(' ',stderr);	/* indent */
d484 1
a484 1
		fprintf(stderr,"Null???\n");
d491 3
a493 3
		fprintf(stderr,"SOLID %s (bin %d)",
			tp->tr_stp->st_name,
			tp->tr_stp->st_bin );
d497 1
a497 1
		fprintf(stderr,"Unknown op=x%x\n", tp->tr_op );
d501 1
a501 1
		fprintf(stderr,"UNION");
d504 1
a504 1
		fprintf(stderr,"INTERSECT");
d507 1
a507 1
		fprintf(stderr,"MINUS");
d509 6
d516 18
a533 7
	fprintf(stderr," (%.0f,%.0f,%.0f) (%.0f,%.0f,%.0f)\n",
		tp->tr_min[0], tp->tr_min[1], tp->tr_min[2],
		tp->tr_max[0], tp->tr_max[1], tp->tr_max[2] );
	if( BINOP(tp) )  {
		/* BINARY TYPE */
		pr_tree( tp->tr_left, lvl+1 );
		pr_tree( tp->tr_right, lvl+1 );
a552 14
 *  		R T B O M B
 *  
 *  Abort the RT library
 */
void
rtbomb(str)
char *str;
{
	fprintf(stderr,"\nrt FATAL ERROR %s.\n", str);
	fflush(stderr);
	exit(12);
}

/*
d580 208
@


1.32
log
@Various little changed needed to make the HEP version work.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.31 85/06/04 20:22:53 mike Exp $ (BRL)";
d23 3
a25 1
#include "vmath.h"
a26 1
#include "../h/db.h"
@


1.31
log
@Made printf in add_solid conditional on DEBUG_SOLIDS.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.30 85/05/29 00:15:25 mike Exp $ (BRL)";
d32 2
a33 2
vect_t model_min = {  INFINITY,  INFINITY,  INFINITY };
vect_t model_max = { -INFINITY, -INFINITY, -INFINITY };
d248 3
a250 3
#define MMM(v)		MINMAX( model_min[X], model_max[X], v[X] ); \
			MINMAX( model_min[Y], model_max[Y], v[Y] ); \
			MINMAX( model_min[Z], model_max[Z], v[Z] )
@


1.30
log
@Moved region and material pointer from solid structure to tree (leaf)
nodes, added path matrix and use count to solid structure, to permit
solids referenced with identical path matrices to "share",
resulting in far greater speed.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.29 85/05/02 20:18:08 mike Exp $ (BRL)";
d215 3
a217 1
		fprintf(stderr,"add_solid:  use %d of %s!!\n", nsp->st_uses, name );
@


1.29
log
@Eliminated silly m_brname stuff.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.28 85/03/26 20:07:08 mike Exp $ (BRL)";
d105 3
a137 1
		register struct soltab *stp;
d145 2
a146 2
		stp = curtree->tr_stp;
		stp->st_regionp = regionp;
a152 1
	color_soltab();			/* associate soltab w/material */
d172 1
a172 1
add_solid( rec, name, mat, regp )
a175 1
struct region *regp;
d182 1
d199 21
a226 1
	stp->st_regionp = regp;
d242 3
a257 2
		if( regp != REGION_NULL )
			fprintf(stderr,"Member of region %s\n", regp->reg_name );
d313 1
a313 1
		stp = add_solid( &rec, strdup(path_str(pathpos)), old_xlate, argregion );
d325 3
d393 3
a395 2
			stp->st_regionp = xrp;
			xrp->reg_name = stp->st_name;
d472 1
@


1.28
log
@Added missing return.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.27 85/03/25 17:46:57 mike Exp $ (BRL)";
a338 13
		if( rec.M.m_brname[0] != '\0' )  {
			register struct directory *tdp;	/* XXX */
			/*
			 * Create an alias.  First step towards full
			 * branch naming.  User is responsible for his
			 * branch names being unique.
			 */
			tdp = dir_lookup(rec.M.m_brname, LOOKUP_QUIET);
			if( tdp != DIR_NULL )
				nextdp = tdp; /* use existing alias */
			else
				nextdp=dir_add(rec.M.m_brname,nextdp->d_addr);
		}
@


1.27
log
@Added support for material code
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.26 85/03/25 11:47:42 mike Exp $ (BRL)";
d584 1
@


1.26
log
@Housekeeping
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.25 85/02/07 20:31:20 mike Exp $ (BRL)";
d151 1
@


1.25
log
@Moved HIDDEN definition to vmath.h, made more functions HIDDEN
to aid debugging.
@
text
@d6 1
a6 1
 * Author -
d8 9
a16 5
 *
 *	U. S. Army Ballistic Research Laboratory
 *	March 27, 1984
 *
 * $Revision: 1.24 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.24 85/02/07 19:19:53 mike Exp $ (BRL)";
d25 1
a25 1
#include "db.h"
@


1.24
log
@Added solid_pos() to find light source, etc.
@
text
@a0 1
#define HIDDEN /**/
d12 1
a12 1
 * $Revision: 1.23 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.23 85/01/31 20:17:31 mike Exp $ (BRL)";
@


1.23
log
@Added checking of matrices to make sure that axis perpendicularity
is preserved.  Removed wierd code to make [15]==1.0, now that
all the geometery modules use MAT4xxxx routines.
@
text
@d13 1
a13 1
 * $Revision: 1.22 $
d16 1
a16 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.22 85/01/28 13:55:00 mike Exp $ (BRL)";
d102 10
a111 1
void
d123 1
a123 1
		return;		/* ERROR */
d158 1
d532 4
a535 3
		VMOVE( ff, fp );
		fp += 3;
		ff += ELEMENTS_PER_VECT;
d551 29
@


1.22
log
@Latest batch of changes.
@
text
@d13 1
a13 1
 * $Revision: 1.21 $
d16 1
a16 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.21 84/11/30 03:59:47 mike Exp $ (BRL)";
d151 4
d165 2
d169 13
a181 11
	/* Eliminate any [15] scaling */
	f = mat[15];
	if( NEAR_ZERO(f) )  {
		fprintf(stderr,"solid %s:  ", name );
		mat_print("defective matrix", mat);
	} else if( f != 1.0 )  {
		f = 1.0 / f;
		mat[0] *= f;
		mat[5] *= f;
		mat[10]*= f;
		mat[15] = 1;
d183 2
d200 1
a200 1
		return( SOLTAB_NULL );		/* continue */
@


1.21
log
@Adjusted for separation between ars and arb8 code.
@
text
@d13 1
a13 1
 * $Revision: 1.20 $
d16 1
a16 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.20 84/11/29 07:00:42 mike Exp $ (BRL)";
d295 11
a305 2
				rec.c.c_regionid );
			argregion = REGION_NULL;	/* override! */
a306 8
		/* Start a new region here */
		GETSTRUCT( regionp, region );
		regionp->reg_forw = regionp->reg_active = REGION_NULL;
		regionp->reg_regionid = rec.c.c_regionid;
		regionp->reg_aircode = rec.c.c_aircode;
		regionp->reg_material = rec.c.c_material;
		regionp->reg_los = rec.c.c_los;
		regionp->reg_name = "being created";
@


1.20
log
@Changes to regions within regions.
@
text
@d13 1
a13 1
 * $Revision: 1.19 $
d16 1
a16 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.19 84/11/27 06:58:32 mike Exp $ (BRL)";
d42 1
a42 1
extern int ars_prep();
d50 1
d60 1
a60 1
	ars_prep,	arb_shot,	arb_print,	"ID_ARS",
@


1.19
log
@Added concept of model RPP.
Implemented individual regions for unclaimed solids.
Unified collection of RPPs along tree, and not in region structs.
@
text
@d13 1
a13 1
 * $Revision: 1.18 $
d16 1
a16 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.18 84/11/24 03:55:58 mike Exp $ (BRL)";
d292 4
a295 11
			fprintf(stderr,"Warning:  region %s within region %s (ID ignored)\n",
				path_str(pathpos), argregion->reg_name );
		} else {
			/* Start a new region here */
			GETSTRUCT( regionp, region );
			regionp->reg_forw = regionp->reg_active = REGION_NULL;
			regionp->reg_regionid = rec.c.c_regionid;
			regionp->reg_aircode = rec.c.c_aircode;
			regionp->reg_material = rec.c.c_material;
			regionp->reg_los = rec.c.c_los;
			regionp->reg_name = "being created";
d297 8
@


1.18
log
@Added calculations for region and tree bounding RPPs.
@
text
@d1 1
d13 1
a13 1
 * $Revision: 1.17 $
d16 1
a16 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.17 84/11/24 03:05:21 mike Exp $ (BRL)";
a26 1
static union tree *drawHobj();
d28 8
d99 1
a99 1
static char *path_str();
a133 2
		VMOVE( regionp->reg_min, stp->st_min );
		VMOVE( regionp->reg_max, stp->st_max );
d150 1
a150 1
static
d182 1
a182 1
	/* init maxima and minima */
d196 7
d229 1
a229 1
static
d278 2
d302 1
a302 4
			regionp->reg_max[X] = regionp->reg_max[Y] =
				regionp->reg_max[Z] = -INFINITY;
			regionp->reg_min[X] = regionp->reg_min[Y] =
				regionp->reg_min[Z] =  INFINITY;
d337 2
d341 5
a345 2
			 * invent a region to hold it.  Reach down into
			 * subtree and "fix" first solid's region pointer.
a346 2
			GETSTRUCT( regionp, region );
			regionp->reg_forw = regionp->reg_active = REGION_NULL;
d348 1
a348 1
				path_str(pathpos) );
d351 10
a360 5
			subtree->tr_stp->st_regionp = regionp;
			regionp->reg_max[X] = regionp->reg_max[Y] =
				regionp->reg_max[Z] = -INFINITY;
			regionp->reg_min[X] = regionp->reg_min[Y] =
				regionp->reg_min[Z] =  INFINITY;
a387 2
#define MINMAX(a,b,c)	{ if( (c) < (a) )  a = (c);\
			if( (c) > (b) )  b = (c); }
d391 5
a395 18
			if( curtree->tr_op == OP_SOLID )  {
				register vectp_t v = curtree->tr_stp->st_min;
				VMOVE( xtp->tr_min, v );
				v = curtree->tr_stp->st_max;
				VMOVE( xtp->tr_max, v );
			} else {
				VMOVE( xtp->tr_min, curtree->tr_min );
				VMOVE( xtp->tr_max, curtree->tr_max );
			}
			if( subtree->tr_op == OP_SOLID )  {
				register vectp_t v = subtree->tr_stp->st_min;
				MM( v );
				v = subtree->tr_stp->st_max;
				MM( v );
			} else {
				MM( subtree->tr_min );
				MM( subtree->tr_max );
			}
a405 2
			VMOVE( regionp->reg_min, curtree->tr_min );
			VMOVE( regionp->reg_max, curtree->tr_max );
d424 1
a424 1
static char *
a448 2
	VPRINT( "RPP min", rp->reg_min );
	VPRINT( "RPP max", rp->reg_max );
d472 1
a472 1
		fprintf(stderr,"SOLID %s (bin %d)\n",
d475 1
a475 1
		return;
d482 1
a482 1
		fprintf(stderr,"UNION\n");
d485 1
a485 1
		fprintf(stderr,"INTERSECT\n");
d488 1
a488 1
		fprintf(stderr,"MINUS\n");
d491 8
a498 3
	/* BINARY TYPE */
	pr_tree( tp->tr_left, lvl+1 );
	pr_tree( tp->tr_right, lvl+1 );
@


1.17
log
@Initialized bounding RPP min and max points here, rather than
in each prep routine.  Fixed another stderr omission.
@
text
@d12 1
a12 1
 * $Revision: 1.16 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.16 84/11/23 20:56:51 mike Exp $ (BRL)";
d114 2
d122 2
a123 1
		curtree->tr_stp->st_regionp = regionp;
d126 2
d229 1
a229 1
	auto union tree *curtree;	/* ptr to current tree top */
d231 1
a231 1
	auto struct region *regionp;
d277 1
a277 1
			fprintf(stderr,"Warning:  region %s within region %s (ignored)\n",
d287 4
d337 4
d366 25
d401 2
d446 2
@


1.16
log
@Added LOCAL, fastf_t declarations.
Made shootray() recursive.
@
text
@d12 1
a12 1
 * $Revision: 1.15 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.15 84/11/22 09:07:44 mike Exp $ (BRL)";
d171 4
d419 1
a419 1
		putchar(' ');	/* indent */
@


1.15
log
@Cleanups to make library version
@
text
@d12 1
a12 1
 * $Revision: 1.14 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.14 84/11/20 20:15:17 mike Exp $ (BRL)";
d240 1
a240 1
	if( rec.u_id == SOLID || rec.u_id == ARS_A )  {
d259 1
a259 1
	if( rec.u_id != COMB )  {
d274 4
@


1.14
log
@General cleanup
@
text
@d12 1
a12 1
 * $Revision: 1.13 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.13 84/11/16 06:30:10 mike Exp $ (BRL)";
d59 1
a59 1
#define DEF(func)	func() { printf("func unimplemented\n"); }
d225 1
a225 1
		(void)printf("%s: nesting exceeds %d levels\n",
d260 1
a260 1
		(void)printf("drawobj:  defective input '%c'\n", rec.u_id );
@


1.13
log
@struct ray --> struct xray
Bounding RPP
@
text
@d12 1
a12 1
 * $Revision: 1.12 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.12 84/11/15 22:42:49 mike Exp $ (BRL)";
a24 5
extern struct soltab *HeadSolid;
extern struct functab functab[];
extern long nsolids;		/* total # of solids participating */
extern long nregions;		/* total # of regions participating */

d26 1
d28 8
a35 2
void pr_region();
void pr_tree();
d37 27
a90 1
union tree *drawHobj();
d93 1
d116 1
a116 1
		printf("Warning:  Top level solid, region %s created\n",
d119 1
a119 1
			bomb("root subtree not Solid");
d131 1
a131 1
		printf("printing regions\n");
d139 1
a139 1
/*static */
d154 1
a154 1
		printf("solid %s:  ", name );
d182 1
a182 1
		printf("-------------- %s -------------\n", stp->st_name);
d184 1
a184 1
		printf("Bound Sph Rad**2 = %f\n", stp->st_radsq);
d188 1
a188 1
			printf("Member of region %s\n", regp->reg_name );
d196 1
a196 1
struct directory	*path[MAXLEVELS];	/* Record of current path */
d207 1
a207 1
/*static*/
d244 1
a244 1
		stp = add_solid( &rec.s, strdup(path_str(pathpos)), old_xlate, argregion );
d252 1
a252 1
			bomb("drawHobj: curtree malloc failed\n");
d268 1
a268 1
			printf("Warning:  region %s within region %s (ignored)\n",
d297 3
a299 3
			register int i;
			for( i=0; i<4*4; i++ )
				xmat[i] = rec.M.m_mat[i];/* cvt to fastf_t */
d315 1
a315 1
			printf("Warning:  Forced to create region %s\n",
d318 1
a318 1
				bomb("subtree not Solid");
d329 1
a329 1
				bomb("drawHobj: xtp malloc failed\n");
d335 1
a335 1
				printf("(%s) bad m_relation '%c'\n",
d350 1
a350 1
			printf("drawHobj: (%s) null regionp, non-null curtree\n", path_str(pathpos) );
d359 1
a359 1
				printf("Add Region %s\n", regionp->reg_name);
d394 2
a395 2
	printf("REGION %s:\n", rp->reg_name );
	printf("id=%d, air=%d, material=%d, los=%d\n",
d399 1
a399 1
	printf("\n");
d409 1
a409 1
	printf("%.8x ", tp);
d414 1
a414 1
		printf("Null???\n");
d421 1
a421 1
		printf("SOLID %s (bin %d)\n",
d427 1
a427 1
		printf("Unknown op=x%x\n", tp->tr_op );
d431 1
a431 1
		printf("UNION\n");
d434 1
a434 1
		printf("INTERSECT\n");
d437 1
a437 1
		printf("MINUS\n");
d446 1
d457 14
@


1.12
log
@Switched to new GED matrix accumulation technique along arcs.
@
text
@d12 1
a12 1
 * $Revision: 1.11 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.11 84/10/19 01:39:36 mike Exp $ (BRL)";
d20 1
a20 1
#include "ray.h"
d22 1
a22 1
#include "dir.h"
d156 2
@


1.11
log
@Lint corrections
@
text
@d12 1
a12 1
 * $Revision: 1.10 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.10 84/09/06 03:29:45 mike Exp $ (BRL)";
d268 1
a268 1
				xmat[i] = rec.M.m_mat[i];	/* cvt */
d270 1
a270 1
		mat_mul(new_xlate, xmat, old_xlate);
@


1.10
log
@Added code to cope with top level solids.
@
text
@d12 1
a12 1
 * $Revision: 1.9 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.9 84/08/28 03:07:53 mike Exp $ (BRL)";
d196 1
a196 1
		return;			/* Error */
@


1.9
log
@Fixed problem with shooting at solids that are not explicitly contained
in a "region".
@
text
@d12 1
a12 1
 * $Revision: 1.8 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.8 84/05/04 09:15:59 mike Exp $ (BRL)";
d68 1
a76 1
	(void)drawHobj( dp, REGION_NULL, 0, mat );
d78 21
d217 1
d225 1
a225 15
		if( argregion != REGION_NULL )
			return( curtree );	/* Leaf node within region */

		/* Found solid that is not in a region;  invent a region */
		GETSTRUCT( regionp, region );
		regionp->reg_active = REGION_NULL;
		regionp->reg_treetop = curtree;
		regionp->reg_name = strdup(path_str(pathpos));
		regionp->reg_forw = HeadRegion;
		HeadRegion = regionp;
		nregions++;
		stp->st_regionp = regionp;
		/** if( debug&DEBUG_REGIONS) */
		printf("Warning:  Created dummy region %s\n", regionp->reg_name);
		return( TREE_NULL );	/* No proper leaf encountered */
d237 2
a238 2
			printf("Warning: region %s within region (ignored)\n",
				path_str(pathpos) );
d276 15
a290 2
		if( regionp == REGION_NULL )
			continue; /* ignore subtree, we are ABOVE a region */
d329 1
@


1.8
log
@Minor hacks
@
text
@d12 1
a12 1
 * $Revision: 1.7 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.7 84/05/03 06:55:56 mike Exp $ (BRL)";
d196 22
a217 11
		if( argregion != REGION_NULL )  {
		/**	GETSTRUCT( curtree, union tree ); **/
			curtree = (union tree *)malloc(sizeof(union tree));
			if( curtree == TREE_NULL )
				bomb("drawHobj: curtree malloc failed\n");
			bzero( (char *)curtree, sizeof(union tree) );
			curtree->tr_op = OP_SOLID;
			curtree->tr_stp = stp;
			return( curtree );
		}
		return( TREE_NULL );
d229 1
a229 1
			printf("Warning: region %s within region\n",
d266 26
a291 21
		if( subtree != TREE_NULL && regionp != REGION_NULL )  {
			if( curtree == TREE_NULL )  {
				curtree = subtree;
			} else {
				register union tree *xtp;	/* XXX */
			/**	GETSTRUCT( xtp, union tree ); **/
				xtp=(union tree *)malloc(sizeof(union tree));
				if( xtp == TREE_NULL )
					bomb("drawHobj: xtp malloc failed\n");
				bzero( (char *)xtp, sizeof(union tree) );
				xtp->tr_left = curtree;
				xtp->tr_right = subtree;
				switch( rec.M.m_relation )  {
				case SUBTRACT:
					xtp->tr_op = OP_SUBTRACT; break;
				case INTERSECT:
					xtp->tr_op = OP_INTERSECT; break;
				case UNION:
					xtp->tr_op = OP_UNION; break;
				}
				curtree = xtp;
d293 1
@


1.7
log
@Performance enhancements, ARS fixes.
@
text
@d12 1
a12 1
 * $Revision: 1.6 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.6 84/05/02 05:10:04 mike Exp $ (BRL)";
d27 3
a29 1
extern int nsolids;		/* total # of solids participating */
d288 1
@


1.6
log
@More ARS support, fixes of all kinds.
@
text
@d12 1
a12 1
 * $Revision: 1.5 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.5 84/05/01 06:40:07 mike Exp $ (BRL)";
d27 1
d137 1
@


1.5
log
@Modifications for ARS, code unified to use fastf_t
@
text
@d12 1
a12 1
 * $Revision: 1.4 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.4 84/04/26 07:51:50 mike Exp $ (BRL)";
d118 1
a118 1
	if( functab[stp->st_id].ft_prep( v, stp, mat ) )  {
d346 3
a348 1
		printf("SOLID %s\n", tp->tr_stp->st_name );
@


1.4
log
@working version.
@
text
@d12 1
a12 1
 * $Revision: 1.3 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.3 84/04/26 05:42:55 mike Exp $ (BRL)";
d95 1
d110 1
d118 1
a118 1
	if( functab[stp->st_id].ft_prep( &rec->s, stp, mat ) )  {
d142 2
d242 6
a247 8
#ifdef never
		/* Don't Fix horrid GED mistake */
		rec.M.m_mat[12] = rec.M.m_mat[3];
		rec.M.m_mat[13] = rec.M.m_mat[7];
		rec.M.m_mat[14] = rec.M.m_mat[11];
		rec.M.m_mat[3] = rec.M.m_mat[7] = rec.M.m_mat[11] = 0.0;
#endif
		mat_mul(new_xlate, rec.M.m_mat, old_xlate);
d366 13
@


1.3
log
@Minor speed hack, small bug fix.
@
text
@d12 1
a12 1
 * $Revision: 1.2 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.2 84/04/18 02:20:44 mike Exp $ (BRL)";
d238 7
@


1.2
log
@Boolean operation support
@
text
@d12 1
a12 1
 * $Revision: 1.1 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: tree.c,v 1.1 84/04/02 16:42:20 mike Exp $ (BRL)";
d95 1
a95 1
	register float f;
d297 2
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
 * $Revision$
d15 1
a15 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d22 1
d27 1
d29 3
d59 3
d65 2
a66 1
	union record rec;
d68 1
a68 1
	/* For now, a very primitive function */
d70 4
a73 6
	rec.s.s_id = GENELL;
	VSET( &rec.s.s_values[0], 0,3,0 );	/*  V */
	VSET( &rec.s.s_values[3], 2.5,0,0 );	/*  A */
	VSET( &rec.s.s_values[6], 0,0.75,0 );	/*  B */
	VSET( &rec.s.s_values[9], 0,0,1 );	/*  C */
	add_solid( &rec, "Ell" );
d75 2
a76 6
	rec.s.s_id = GENELL;
	VSET( &rec.s.s_values[0], 4,3,0 );	/*  V */
	VSET( &rec.s.s_values[3], 1,0,0 );	/*  A */
	VSET( &rec.s.s_values[6], 0,1,0 );	/*  B */
	VSET( &rec.s.s_values[9], 0,0,1 );	/*  C */
	add_solid( &rec, "Near Sphere" );
d78 6
a83 40
	rec.s.s_id = GENELL;
	VSET( &rec.s.s_values[0], 4,3,-5 );	/*  V */
	VSET( &rec.s.s_values[3], 1,0,0 );	/*  A */
	VSET( &rec.s.s_values[6], 0,1,0 );	/*  B */
	VSET( &rec.s.s_values[9], 0,0,1 );	/*  C */
	add_solid( &rec, "Far Sphere" );

	rec.s.s_id = GENARB8;
	/* set Z=0 to explode the formulas */
#define Z 1
	VSET( &rec.s.s_values[0*3], -2,-1,Z);	/* Abs V */
	VSET( &rec.s.s_values[1*3], 4,0,0);	/* Relative to V ... */
	VSET( &rec.s.s_values[2*3], 4,2,0);
	VSET( &rec.s.s_values[3*3], 0,2,0);

#define H 4
	VSET( &rec.s.s_values[4*3], 2,1,H);
	VSET( &rec.s.s_values[5*3], 2,1,H);
	VSET( &rec.s.s_values[6*3], 2,1,H);
	VSET( &rec.s.s_values[7*3], 2,1,H);
	add_solid( &rec, "Flat Arb" );
#undef Z
#undef H

	rec.s.s_id = GENARB8;
	/* set Z=0 to explode the formulas */
#define Z 1
	VSET( &rec.s.s_values[0*3], 0,-3,Z);	/* Abs V */
	VSET( &rec.s.s_values[1*3], 4,0,0);	/* Relative to V ... */
	VSET( &rec.s.s_values[2*3], 4,2,0);
	VSET( &rec.s.s_values[3*3], 0,2,0);

#define H 0.5
	VSET( &rec.s.s_values[4*3], 2,1,H);
	VSET( &rec.s.s_values[5*3], 2,1,H);
	VSET( &rec.s.s_values[6*3], 2,1,H);
	VSET( &rec.s.s_values[7*3], 2,1,H);
#undef Z
#undef H
	add_solid( &rec, "Flat Arb" );
d86 3
a88 2
static
add_solid( rec, name )
d90 3
a92 1
char *name;
d95 1
a95 1
	mat_t	mat;
d97 13
d111 1
a111 1
	stp->st_id = idmap[rec->u_id];
d114 1
a114 1
	mat_idn( mat);
d119 1
a119 1
		return;		/* continue */
d130 2
d134 221
@
