head	11.14;
access;
symbols
	ansi-20040405-merged:11.10.2.2
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.10.10.1
	premerge-autoconf:11.11
	ansi-20040316-freeze:11.10.2.1
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.10.4.1
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.10
	phong-branch:11.10.0.8
	photonmap-branch:11.10.0.6
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.5.2.1
	offsite-5-3-pre:11.7
	rel-5-3:11.5.2.1
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.5
	rel-5-0-beta:11.4
	rel-4-5:11.3
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.14
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.13;

11.13
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.12;

11.12
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2002.08.20.17.08.09;	author jra;	state Exp;
branches
	11.10.2.1
	11.10.4.1
	11.10.10.1;
next	11.9;

11.9
date	2002.08.15.20.55.20;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2001.04.20.22.29.55;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2000.11.14.21.13.22;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	2000.08.21.02.02.34;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	99.06.03.01.39.15;	author mike;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	98.09.14.15.59.18;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	97.10.06.21.35.36;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.56;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	10.5;

10.5
date	94.08.11.01.20.14;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	92.06.02.22.52.10;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	91.11.29.16.13.47;	author stay;	state Exp;
branches;
next	10.2;

10.2
date	91.11.29.16.06.51;	author stay;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.15;	author mike;	state Rel4_0;
branches;
next	1.3;

1.3
date	91.06.14.09.42.26;	author stay;	state Exp;
branches;
next	1.2;

1.2
date	91.05.18.02.42.27;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	91.05.18.02.36.13;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.5.2.1
date	2000.11.14.21.35.30;	author jra;	state Exp;
branches;
next	;

11.10.2.1
date	2002.09.19.18.01.46;	author morrison;	state Exp;
branches;
next	11.10.2.2;

11.10.2.2
date	2004.03.17.21.18.57;	author morrison;	state Exp;
branches;
next	;

11.10.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.10.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	;


desc
@Oslo Algorithm Calculations

@


11.14
log
@moved to src/
@
text
@/* 
 *       C A L C _ O S L O . C
 *
 * Function -
 *     Calculate the Oslo refinement matrix.
 * 
 * Author -
 *     Paul R. Stay
 *
 * Source -
 *     SECAD/VLD Computing Consortium, Bldg 394
 *     The U.S. Army Ballistic Research Laboratory
 *     Aberdeen Proving Ground, Maryland 21005
 *
 * Copyright Notice -
 *     This software is Copyright (C) 1986-2004 by the United States Army.
 *     All rights reserved.
 *
 * This algorithm was taken from the paper 
 * "Making the Oslo Algorithm More Efficient" by T. Lyche and K. Morken 
 * The algorithm referenced in the paper is algorithm 1 since we will be
 * dealing mostly with surfaces. This routine computes the refinement
 * matrix and returns a oslo structure which will allow a new curve or
 * surface to be built.
 *
 * Since we only want the last row of the alpha's as outlined in the
 * paper we can use a one dimensional array for the ah.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "nurb.h"

#define AMAX(i,j)    ( (i) > (j) ? (i) : (j) )
#define AMIN(i,j)    ( (i) < (j) ? (i) : (j) )

struct oslo_mat *
rt_nurb_calc_oslo(register int order, register const struct knot_vector *tau_kv, register struct knot_vector *t_kv, struct resource *res)
                   
                                           	/* old knot vector */
                                   		/* new knot vector */
                     
{
	register fastf_t	*t_p;
	register const fastf_t	*tau_p;
	fastf_t ah[20];
	fastf_t newknots[20];			/* new knots */
	register int  j;			/* d(j), j = 0 : # of new ctl points */
	int     mu,				/* mu:  tau[mu] <= t[j] < tau[mu+1]*/
		muprim,
		v,				/* Nu value (order of matrix) */
		p,
		iu,				/* upper bound loop counter */
		il,				/* lower bound loop counter */
		ih,
		n1;				/* upper bound of t knot vector - order*/

	fastf_t tj;

	struct oslo_mat * head, * o_ptr, *new_o;

	n1 = t_kv->k_size - order;

	t_p = t_kv->knots;
	tau_p = tau_kv->knots;

	mu = 0;				/* initialize mu */

	head = (struct oslo_mat *) bu_malloc (
		    sizeof( struct oslo_mat),
		    "rt_nurb_calc_oslo: oslo mat head" );

	o_ptr = head;

	for (j = 0; j < n1; j++) {
		register int  i;

		if ( j != 0 )
		{
			new_o = (struct oslo_mat *) bu_malloc ( 
				    sizeof( struct oslo_mat), 
				    "rt_nurb_calc_oslo: oslo mat struct" );

			o_ptr->next = new_o;
			o_ptr = new_o;
		}

		/* find the bounding mu */
		while (tau_p[mu + 1] <= t_p[j]) mu++;

		muprim = mu;

		i = j + 1;

		while ((t_p[i] == tau_p[muprim]) && i < (j + order)) {
			i++;
			muprim--;
		}

		ih = muprim + 1;

		for (v = 0, p = 1; p < order; p++) {
			if (t_p[j + p] == tau_p[ih])
				ih++;
			else
				newknots[++v - 1] = t_p[j + p];
		}

		ah[order-1] = 1.0;

		for (p = 1; p <= v; p++) {

			fastf_t beta1;
			int o_m;

			beta1 = 0.0;
			o_m = order - muprim;

			tj = newknots[p-1];

			if (p > muprim) {
				beta1 = ah[o_m];
				beta1 = ((tj - tau_p[0]) * beta1) /
				    (tau_p[p + order - v] - tau_p[0]);
			}
			i = muprim - p + 1;
			il = AMAX (1, i);
			i = n1 - 1 + v - p;
			iu = AMIN (muprim, i);

			for (i = il; i <= iu; i++) {
				fastf_t d1, d2;
				fastf_t beta;

				d1 = tj - tau_p[i];
				d2 = tau_p[i + p + order - v - 1] - tj;

				beta = ah[i + o_m - 1] / (d1 + d2);

				ah[i + o_m - 2] = d2 * beta + beta1;
				beta1 = d1 * beta;
			}

			ah[iu + o_m - 1] = beta1;

			if (iu < muprim) {
				register fastf_t kkk;
				register fastf_t ahv;

				kkk = tau_p[n1 - 1 + order];
				ahv = ah[iu + o_m];
				ah[iu + o_m - 1] =
				    beta1 + (kkk - tj) *
				    ahv / (kkk - tau_p[iu + 1]);
			}
		}

		o_ptr->o_vec = (fastf_t *) bu_malloc ( sizeof( fastf_t) * (v+1),
			    "rt_nurb_calc_oslo: oslo vector");

		o_ptr->offset = AMAX(muprim -v,0);
		o_ptr->osize = v;

		for ( i = v, p = 0; i >= 0; i--)
			o_ptr->o_vec[p++] =  ah[(order-1) - i];
	}

	o_ptr->next = (struct oslo_mat*) 0;
	return head;
}


/*
 *  rt_pr_oslo() - FOR DEBUGGING PURPOSES
 */
void
rt_nurb_pr_oslo(struct oslo_mat *om)
{
	struct oslo_mat * omp;
	int j;

	for( omp = om; omp!= ( struct oslo_mat *) 0; omp = omp->next)
	{
		fprintf(stderr, "%lx offset %d osize %d next %lx\n",
			(unsigned long)omp,  omp->offset,  omp->osize,
			(unsigned long)omp->next);

		fprintf(stderr,"\t%f",  omp->o_vec[0]);

		for ( j = 1; j <= omp->osize; j++)
			fprintf(stderr,"\t%f",  omp->o_vec[j]);
		fprintf(  stderr, "\n");
	}
}

/* rt_nurb_free_oslo()
 * Free up the structures and links for the oslo matrix.
 */

void
rt_nurb_free_oslo(struct oslo_mat *om, struct resource *res)
{
	register struct oslo_mat * omp;

	while( om != (struct oslo_mat *) 0 )
	{
		omp = om;
		om = om->next;
		bu_free( (char *)omp->o_vec, "rt_nurb_free_oslo: ovec");
		bu_free( (char *)omp, "rt_nurb_free_oslo: struct oslo");
	}
}
@


11.13
log
@change conf.h to a wrapped config.h
@
text
@@


11.12
log
@merge of ansi-6-0-branch into HEAD
@
text
@d30 5
a34 1
#include "conf.h"
@


11.11
log
@update copyright to include span through 2003
@
text
@d42 5
a46 5
rt_nurb_calc_oslo(order, tau_kv, t_kv, res )
register int order;
register const struct knot_vector * tau_kv;	/* old knot vector */
register struct knot_vector * t_kv;		/* new knot vector */
struct resource *res;
d181 1
a181 2
rt_nurb_pr_oslo( om)
struct oslo_mat * om;
d205 1
a205 3
rt_nurb_free_oslo( om, res )
struct oslo_mat * om;
struct resource *res;
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1986 by the United States Army.
@


11.10.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1986-2004 by the United States Army.
@


11.10.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1986-2004 by the United States Army.
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d42 5
a46 5
rt_nurb_calc_oslo(register int order, register const struct knot_vector *tau_kv, register struct knot_vector *t_kv, struct resource *res)
                   
                                           	/* old knot vector */
                                   		/* new knot vector */
                     
d181 2
a182 1
rt_nurb_pr_oslo(struct oslo_mat *om)
d206 3
a208 1
rt_nurb_free_oslo(struct oslo_mat *om, struct resource *res)
@


11.10.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1986-2004 by the United States Army.
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d42 5
a46 5
rt_nurb_calc_oslo(register int order, register const struct knot_vector *tau_kv, register struct knot_vector *t_kv, struct resource *res)
                   
                                           	/* old knot vector */
                                   		/* new knot vector */
                     
d181 2
a182 1
rt_nurb_pr_oslo(struct oslo_mat *om)
d206 3
a208 1
rt_nurb_free_oslo(struct oslo_mat *om, struct resource *res)
@


11.8
log
@CONST to const
@
text
@d42 5
a46 5
rt_nurb_calc_oslo(order, tau_kv, t_kv, res )
register int order;
register const struct knot_vector * tau_kv;	/* old knot vector */
register struct knot_vector * t_kv;		/* new knot vector */
struct resource *res;
d181 1
a181 2
rt_nurb_pr_oslo( om)
struct oslo_mat * om;
d205 1
a205 3
rt_nurb_free_oslo( om, res )
struct oslo_mat * om;
struct resource *res;
@


11.7
log
@Eliminated pmalloc (a failed experiment)
@
text
@d44 1
a44 1
register CONST struct knot_vector * tau_kv;	/* old knot vector */
d49 1
a49 1
	register CONST fastf_t	*tau_p;
@


11.6
log
@Massive compilation warnings eliminated
@
text
@d73 1
a73 6
	if( res )
		head = (struct oslo_mat *) rt_pmalloc (
		    sizeof( struct oslo_mat),
		    &res->re_pmem );
	else
		head = (struct oslo_mat *) bu_malloc (
d84 1
a84 6
			if( res )
				new_o = (struct oslo_mat *) rt_pmalloc ( 
				    sizeof( struct oslo_mat), 
				    &res->re_pmem );
			else
				new_o = (struct oslo_mat *) bu_malloc ( 
d162 1
a162 5
		if( res )
			o_ptr->o_vec = (fastf_t *) rt_pmalloc ( sizeof( fastf_t) * (v+1),
			    &res->re_pmem);
		else
			o_ptr->o_vec = (fastf_t *) bu_malloc ( sizeof( fastf_t) * (v+1),
d216 2
a217 10
		if( res )
		{
			rt_pfree( (char *)omp->o_vec, &res->re_pmem);
			rt_pfree( (char *)omp, &res->re_pmem);
		}
		else
		{
			bu_free( (char *)omp->o_vec, "rt_nurb_free_oslo: ovec");
			bu_free( (char *)omp, "rt_nurb_free_oslo: struct oslo");
		}
@


11.5
log
@
sed4
@
text
@d203 3
a205 2
		fprintf( stderr, "%lx offset %d osize %d next %lx\n",  omp,
		    omp->offset,  omp->osize,  omp->next);
@


11.5.2.1
log
@Eliminated pmalloc (a failed experiment)
@
text
@d73 6
a78 1
	head = (struct oslo_mat *) bu_malloc (
d89 6
a94 1
			new_o = (struct oslo_mat *) bu_malloc ( 
d172 5
a176 1
		o_ptr->o_vec = (fastf_t *) bu_malloc ( sizeof( fastf_t) * (v+1),
d229 10
a238 2
		bu_free( (char *)omp->o_vec, "rt_nurb_free_oslo: ovec");
		bu_free( (char *)omp, "rt_nurb_free_oslo: struct oslo");
@


11.4
log
@*- fix typos
@
text
@d78 1
a78 1
		head = (struct oslo_mat *) rt_malloc (
d94 1
a94 1
				new_o = (struct oslo_mat *) rt_malloc ( 
d176 1
a176 1
			o_ptr->o_vec = (fastf_t *) rt_malloc ( sizeof( fastf_t) * (v+1),
d236 2
a237 2
			rt_free( (char *)omp->o_vec, "rt_nurb_free_oslo: ovec");
			rt_free( (char *)omp, "rt_nurb_free_oslo: struct oslo");
@


11.3
log
@rt_pmalloc
@
text
@d203 1
a203 1
		fprintf( stderr, "%x offset %d osize %d next %x\n",  omp,
@


11.2
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d74 1
a74 1
		head = (struct oslo_mat *) pmalloc (
d90 1
a90 1
				new_o = (struct oslo_mat *) pmalloc ( 
d173 1
a173 1
			o_ptr->o_vec = (fastf_t *) pmalloc ( sizeof( fastf_t) * (v+1),
d231 2
a232 2
			pfree( (char *)omp->o_vec, &res->re_pmem);
			pfree( (char *)omp, &res->re_pmem);
@


11.1
log
@Release_4.4
@
text
@d42 1
a42 1
rt_nurb_calc_oslo(order, tau_kv, t_kv )
d46 1
d73 9
a81 3
	head = (struct oslo_mat *) rt_malloc (
	    sizeof( struct oslo_mat),
	    "rt_nurb_calc_oslo: oslo mat head" );
d89 9
a97 3
			new_o = (struct oslo_mat *) rt_malloc ( 
			    sizeof( struct oslo_mat), 
			    "rt_nurb_calc_oslo: oslo mat struct" );
d172 6
a177 2
		o_ptr->o_vec = (fastf_t *) rt_malloc ( sizeof( fastf_t) * (v+1),
		    "rt_nurb_calc_oslo: oslo vector");
d219 1
a219 1
rt_nurb_free_oslo( om )
d221 1
d229 10
a238 2
		rt_free( (char *)omp->o_vec, "rt_nurb_free_oslo: ovec");
		rt_free( (char *)omp, "rt_nurb_free_oslo: struct oslo");
@


11.1.1.1
log
@Release_4.5
@
text
@d42 1
a42 1
rt_nurb_calc_oslo(order, tau_kv, t_kv, res )
a45 1
struct resource *res;
d72 3
a74 9
	if( res )
		head = (struct oslo_mat *) rt_pmalloc (
		    sizeof( struct oslo_mat),
		    &res->re_pmem );
	else
		head = (struct oslo_mat *) rt_malloc (
		    sizeof( struct oslo_mat),
		    "rt_nurb_calc_oslo: oslo mat head" );

d82 3
a84 9
			if( res )
				new_o = (struct oslo_mat *) rt_pmalloc ( 
				    sizeof( struct oslo_mat), 
				    &res->re_pmem );
			else
				new_o = (struct oslo_mat *) rt_malloc ( 
				    sizeof( struct oslo_mat), 
				    "rt_nurb_calc_oslo: oslo mat struct" );

d159 2
a160 6
		if( res )
			o_ptr->o_vec = (fastf_t *) rt_pmalloc ( sizeof( fastf_t) * (v+1),
			    &res->re_pmem);
		else
			o_ptr->o_vec = (fastf_t *) rt_malloc ( sizeof( fastf_t) * (v+1),
			    "rt_nurb_calc_oslo: oslo vector");
d202 1
a202 1
rt_nurb_free_oslo( om, res )
a203 1
struct resource *res;
d211 2
a212 10
		if( res )
		{
			rt_pfree( (char *)omp->o_vec, &res->re_pmem);
			rt_pfree( (char *)omp, &res->re_pmem);
		}
		else
		{
			rt_free( (char *)omp->o_vec, "rt_nurb_free_oslo: ovec");
			rt_free( (char *)omp, "rt_nurb_free_oslo: struct oslo");
		}
@


10.5
log
@Added includes
@
text
@@


10.4
log
@Changed lists to use rt_list structures
Made some args CONST where appropriate
Switched to GET_CNURB() macros
Added calls to NMG_CK_SNURB()
@
text
@d30 2
d35 1
@


10.3
log
@Woops forgot to take out the test case for the orig_ and rt_ to
compare execution times...
@
text
@d41 2
a42 2
register struct knot_vector * tau_kv;	/* old knot vector */
register struct knot_vector * t_kv;	/* new knot vector */
d44 2
a45 1
	register fastf_t * t_p, * tau_p;
@


10.2
log
@Changed the ah array to a one-dimensional array which allowed us
to get rid of the awful ah_index routines. Also added some optimizations
for better execution.
@
text
@d39 1
a39 1
orig_nurb_calc_oslo(order, tau_kv, t_kv )
d174 1
a174 1
orig_nurb_pr_oslo( om)
d198 1
a198 1
orig_nurb_free_oslo( om )
@


10.1
log
@Release_4.0
@
text
@d25 3
a37 5
/* Simplification needed thanks to the SGI: */
/* ah[AH_INDEX(j,t)] gives result of former ah_index(j,t) macro */
#define AH_INDEX(_j,_t)   (( (_j) * ((_j)+1)/2) + (_t) - ((order-1) - (_j)))
#define ah_index(__j,__t)	ah[AH_INDEX(__j,__t)]

d39 2
a40 2
rt_nurb_calc_oslo(order, tau_kv, t_kv )
int order;
d44 3
a46 3
	fastf_t * ah;
	fastf_t * newknots;			/* new knots */
	register int  i;
d49 8
a56 9
	muprim;
	int     v,				/* Nu value (order of matrix) */
	p;
	int     iu,				/* upper bound loop counter */
	il,				/* lower bound loop counter */
	ih,
	n1;				/* upper bound of t knot vector - order*/
	int     ahi;			/* ah[] index */
	fastf_t beta1;
d58 1
a59 5
	
	ah = (fastf_t *) rt_malloc (sizeof (fastf_t) * order * ( order + 1)/2,
	    "rt_nurb_calc_oslo: alpha matrix");
	newknots = (fastf_t *) rt_malloc (sizeof (fastf_t) * (order), 
	    "rt_nurb_calc_oslo: New knots");
d63 3
d74 1
d85 2
a86 2
		while (tau_kv->knots[mu + 1] <= t_kv->knots[j])
			mu = mu + 1;		/* find the bounding mu */
a87 1
		i = j + 1;
d90 3
a92 1
		while ((t_kv->knots[i] == tau_kv->knots[muprim]) && i < (j + order)) {
d100 1
a100 1
			if (t_kv->knots[j + p] == tau_kv->knots[ih])
d103 1
a103 1
				newknots[++v - 1] = t_kv->knots[j + p];
d106 1
a106 3
		/* Separating these two is needed to avoid the SGI 4D compiler bug */
		ahi = AH_INDEX(0, order - 1);
		ah[ahi] = 1.0;
d109 4
d114 2
d118 4
a121 4
			if (p - 1 >= muprim) {
				beta1 = ah_index (p - 1, order - muprim);
				beta1 = ((tj - tau_kv->knots[0]) * beta1) /
				    (tau_kv->knots[p + order - v] - tau_kv->knots[0]);
d129 2
a130 2
				register fastf_t d1, d2;
				register fastf_t beta;
d132 2
a133 2
				d1 = tj - tau_kv->knots[i];
				d2 = tau_kv->knots[i + p + order - v - 1] - tj;
d135 1
a135 1
				beta = ah_index (p - 1, i + order - muprim - 1) / (d1 + d2);
d137 1
a137 1
				ah_index (p, i + order - muprim - 2) = d2 * beta + beta1;
d141 1
a141 1
			ah_index (p, iu + order - muprim - 1) = beta1;
d147 3
a149 3
				kkk = tau_kv->knots[n1 - 1 + order];
				ahv = ah_index (p - 1, iu + order - muprim);
				ah_index (p, iu + order - muprim - 1) =
d151 1
a151 1
				    ahv / (kkk - tau_kv->knots[iu + 1]);
d162 1
a162 1
			o_ptr->o_vec[p++] =  ah_index(v, (order-1) - i);
a164 2
	rt_free ( (char *)ah, "rt_nurb_calc_oslo: alpha matrix" );
	rt_free ( (char *)newknots, "rt_nurb_calc_oslo: new knots" );
d174 1
a174 1
rt_nurb_pr_oslo( om)
d198 1
a198 1
rt_nurb_free_oslo( om )
d202 1
a202 1
	
@


1.3
log
@fixed nurb.h
@
text
@@


1.2
log
@Minor lint
@
text
@d30 1
a30 1
#include "./nurb.h"
@


1.1
log
@Initial revision
@
text
@d207 2
a208 2
		rt_free( omp->o_vec, "rt_nurb_free_oslo: ovec");
		rt_free( omp, "rt_nurb_free_oslo: struct oslo");	
@
