head	11.14;
access;
symbols
	ansi-20040405-merged:11.10.2.2
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.10.10.2
	premerge-autoconf:11.11
	ansi-20040316-freeze:11.10.2.1
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.10.4.1
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.10
	phong-branch:11.10.0.8
	photonmap-branch:11.10.0.6
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.5
	offsite-5-3-pre:11.7
	rel-5-3:11.5
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.5
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.14
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.13;

11.13
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.12;

11.12
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2002.08.20.17.08.08;	author jra;	state Exp;
branches
	11.10.2.1
	11.10.4.1
	11.10.10.1;
next	11.9;

11.9
date	2002.08.15.20.55.20;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2001.04.20.22.29.55;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2000.08.21.02.02.34;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	2000.07.25.16.46.06;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	97.09.09.14.04.17;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.12.31.01.09.27;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.07.10.20.15.50;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.12.01.02.49.33;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.54;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	1.6;

1.6
date	94.11.05.00.24.19;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	94.08.11.01.19.13;	author gdurf;	state Exp;
branches;
next	1.4;

1.4
date	93.10.01.19.52.07;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	93.07.20.15.26.35;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	93.04.07.00.51.23;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	92.09.17.14.23.12;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.10.2.1
date	2002.09.19.18.01.45;	author morrison;	state Exp;
branches;
next	11.10.2.2;

11.10.2.2
date	2004.03.17.21.18.56;	author morrison;	state Exp;
branches;
next	;

11.10.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.10.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	11.10.10.2;

11.10.10.2
date	2004.03.15.14.07.28;	author erikg;	state Exp;
branches;
next	;


desc
@Routines for determining whether a point lies in the
trimming curves.
@


11.14
log
@moved to src/
@
text
@/* 
 *	N U R B _ T R I M . C
 *
 * nurb_trim.c - trimming curve routines.
 * 
 * Author:  Paul R. Stay
 * Source
 * 	SECAD/VLD Computing Consortium, Bldg 394
 * 	The US Army Ballistic Research Laboratory
 * 	Aberdeen Proving Ground, Maryland 21005
 * 
 * Date: Mon June 1, 1992
 * 
 * Copyright Notice - 
 * 	This software is Copyright (C) 1990-2004 by the United States Army.
 * 	All rights reserved.
 * 
 */
#ifndef lint
static const char rcs_ident[] = "$Header: /n/xoff/cvs/brlcad/librt/nurb_trim.c,v 11.13 2004/05/10 15:30:46 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "nurb.h"

extern void	rt_clip_cnurb(struct bu_list *plist, struct edge_g_cnurb *crv, fastf_t u, fastf_t v);

struct _interior_line {
	int axis;
	fastf_t o_dist;
};

#define QUAD1 0
#define QUAD2 1
#define QUAD3 2
#define QUAD4 3


#define TRIM_OUT 	0
#define TRIM_IN 	1
#define TRIM_ON 	2

/* The following defines need to be 0,2,3 in order to drive the quad table
 * and determine the appropriate case for processing the trimming curve.
 */

#define CASE_A 		0
#define CASE_B 		2
#define CASE_C 		3

int quad_table[16]  = {		/* A = 0, B = 2, C = 3 */
0,0,0,0,0,3,0,3,0,2,3,3,0,3,3,3
};

/* This routine determines what quadrants the trimming curves lies
 * in,  It then uses a table look up to determine the whether its
 * CASE{A,B,C}, One difference from the paper is the fact that
 * if any of the points lie on the axis of the u,v quadrant system
 * then the axis is only in either Quadrant 1 or Quadrant 2 and not
 * q3 or q4. THis handles the case of endpoint problems correctly.
 */

int 
rt_trim_case(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
{
	int quadrant;
	int qstats;
	fastf_t * pts;
	int coords, rat;
	int i;

	qstats = 0;

	coords = RT_NURB_EXTRACT_COORDS(trim->pt_type);
	pts = trim->ctl_points;
	rat = RT_NURB_IS_PT_RATIONAL( trim->pt_type );

	/* Handle rational specially since we need to divide the rational
	 * portion.
	 */

	if( rat )
		for( i = 0; i < trim->c_size; i++)
		{
			if(pts[0]/pts[2] > u )
				quadrant = (pts[1]/pts[2] >= v)? QUAD1:QUAD4;
			else
				quadrant = (pts[1]/pts[2] >= v)? QUAD2:QUAD3;

			qstats |= (1 << quadrant);
			pts += coords;
		}
	else 
		for( i = 0; i < trim->c_size; i++)
		{
			if(pts[0] > u )
				quadrant = (pts[1] >= v)? QUAD1:QUAD4;
			else
				quadrant = (pts[1] >= v)? QUAD2:QUAD3;

			qstats |= (1 << quadrant);
			pts += coords;
		}

	return quad_table[qstats];	/* return the special case of the curve */
}

/* Process Case B curves. 
 *
 * If the two endpoints of the curve lie in different quadrants than
 * the axis crosses the curve an odd number of times (TRIM_IN). Otherwise
 * the curve crosses the u,v axis a even number of times (TRIM_OUT).
 * No further processing is required.
 */
int
rt_process_caseb(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
{
	int q1, q2;
	fastf_t * pts;
	int rat;

	rat = RT_NURB_IS_PT_RATIONAL( trim->pt_type );

	pts = trim->ctl_points;

	if( rat)
	{
		if( pts[0]/pts[2] > u) q1 = (pts[1]/pts[2] >= v)?QUAD1:QUAD4;
		else 		 q1 = (pts[1]/pts[2] >= v)?QUAD2:QUAD3;


		pts = trim->ctl_points + RT_NURB_EXTRACT_COORDS(trim->pt_type) *
			(trim->c_size -1);
		if( pts[0]/pts[2] > u) q2 = (pts[1]/pts[2] >= v)?QUAD1:QUAD4;
		else 		 q2 = (pts[1]/pts[2] >= v)?QUAD2:QUAD3;

	} else
	{
		if( pts[0] > u) q1 = (pts[1] >= v)?QUAD1:QUAD4;
		else 		 q1 = (pts[1] >= v)?QUAD2:QUAD3;


		pts = trim->ctl_points + 
			RT_NURB_EXTRACT_COORDS(trim->pt_type) 	*
			(trim->c_size -1);
		if( pts[0] > u) q2 = (pts[1] >= v)?QUAD1:QUAD4;
		else 		 q2 = (pts[1] >= v)?QUAD2:QUAD3;
	}

	if( q1 != q2 )
		return TRIM_IN;
	else
		return TRIM_OUT;

}

/* Only check end points of the curve */

int
rt_nurb_uv_dist(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
{

	fastf_t dist;
	fastf_t * ptr;
	int coords;
	int rat;
	fastf_t u2, v2;

	ptr = trim->ctl_points;	
	coords = RT_NURB_EXTRACT_COORDS(trim->pt_type);
	rat = RT_NURB_IS_PT_RATIONAL(trim->pt_type);

	u2 = 0.0;
	v2 = 0.0;

	if ( rat )
	{
		u2 = ptr[0]/ptr[2] - u; u2 *= u2;
		v2 = ptr[1]/ptr[2] - v; v2 *= v2;
	}
	else
	{
		u2 = ptr[0] - u; u2 *= u2;
		v2 = ptr[1] - v; v2 *= v2;
	}

	dist = sqrt( u2 + v2);
	if ( NEAR_ZERO( dist, 1.0e-4) )
		return TRIM_ON;

	ptr = trim->ctl_points + coords * (trim->c_size -1);

	u2 = 0.0;
	v2 = 0.0;

	if ( rat )
	{
		u2 = ptr[0]/ptr[2] - u; u2 *= u2;
		v2 = ptr[1]/ptr[2] - v; v2 *= v2;
	}
	else
	{
		u2 = ptr[0] - u; u2 *= u2;
		v2 = ptr[1] - v; v2 *= v2;
	}

	dist = sqrt( u2 + v2);
	if ( NEAR_ZERO( dist, 1.0e-4) )
		return TRIM_ON;

	return TRIM_OUT;

}



/* Process Case C curves;
 * A check is placed here to determin if the u,v is on the curve.
 * Determine how many times the curve will cross the u,v axis. If
 * the curve crosses an odd number of times than the point is IN,
 * else the point is OUT. Since a case C curve need processin a
 * call to clip hte curve so that it becomes either Case B, or Case A
 * is required to determine the number of crossing acurately. Thus
 * we need to keep the original curve and expect the calling routine
 * to free the storage. Additional curves are generated in this
 * routine, each of these new curves are proccesed, and then are
 * deleted before exiting this procedure.
 */

int
rt_process_casec(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
{

	struct edge_g_cnurb * clip;
	int jordan_hit;
	struct bu_list	plist;
	int trim_flag = 0;
	int caset;

	/* determine if the the u,v values are on the curve */

	if( rt_nurb_uv_dist(trim, u, v)  == TRIM_ON) return TRIM_IN;

	jordan_hit = 0;

	BU_LIST_INIT(&plist);

	if( nurb_crv_is_bezier( trim ) )
		rt_clip_cnurb(&plist, trim, u, v);
	else
		nurb_c_to_bezier( &plist, trim );

	while( BU_LIST_WHILE( clip, edge_g_cnurb, &plist ) )
	{
		BU_LIST_DEQUEUE( &clip->l );
		
		caset = rt_trim_case(clip, u,v);

		trim_flag = 0;

		if( caset == CASE_B)
			trim_flag = rt_process_caseb(clip, u, v);
		if( caset == CASE_C)
			trim_flag = rt_process_casec(clip, u, v);

		rt_nurb_free_cnurb( clip );
		
		if( trim_flag == TRIM_IN) jordan_hit++;
		if( trim_flag == TRIM_ON) break;
	}

	while( BU_LIST_WHILE( clip, edge_g_cnurb, &plist) )
	{
		BU_LIST_DEQUEUE( &clip->l );
		rt_nurb_free_cnurb( clip );
	}

	if( trim_flag == TRIM_ON) 
		return TRIM_ON;

	else if( jordan_hit & 01 )
		return TRIM_IN;
	else 
		return TRIM_OUT;
}


/* This routine will be called several times, once for each portion of
 * the trimming curve. It returns wheter a line extended from the 
 * the <u,v> point will cross the trimming curve an even or odd number
 * of times. Or the <u,v> point could be on the curve in which case
 * TRIM_ON will be returned. THe algorithm uses the approach taken
 * Tom Sederburge and uses bezier clipping to produce caseA and caseB
 * curves. If the original trimming curve is a CASE C curve then further
 * processing is required.
 */
int 
rt_uv_in_trim(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
{

	int quad_case;

	quad_case = rt_trim_case( trim, u, v);	/* determine quadrants */
	
							/* CASE A */	
	if( quad_case == CASE_A )
		return TRIM_OUT;
	if( quad_case == CASE_B )			/* CASE B */
		return rt_process_caseb(trim, u, v);
	if( quad_case == CASE_C )			/* CASE C */
		return rt_process_casec(trim, u, v);

	bu_log( "rt_uv_in_trim: rt_trim_case() returned illegal value %d\n", quad_case );
	return( -1 );
}





/* This routines is used to determine how far a point is 
 * from the u,v quadrant axes.
 *
 *	Equations 3, 4, 5 in Sederberg '90 paper 
 */

fastf_t
rt_trim_line_pt_dist(struct _interior_line *l, fastf_t *pt, int pt_type)
{
	fastf_t h;
	int h_flag;

	h_flag = RT_NURB_IS_PT_RATIONAL(pt_type);

	if( l->axis == 0)
	{
		if( h_flag) h = (pt[1] / pt[2] - l->o_dist) * pt[2]; /* pt[2] is weight */
		else h = pt[1] - l->o_dist;

	} else
	{
		if( h_flag) h = (pt[0] / pt[2] - l->o_dist) * pt[2];
		else h = pt[0] - l->o_dist;

	}

	return h;
}

/* Return the SIGN of the value */
int
_SIGN(fastf_t f)
{
	if (f < 0.0)
		return -1;
	else
		return 1;

}

/* 
 *  We try and clip a curve so that it can be either Case A, or Case C.
 *  Sometimes one of the curves is still case C though, but it is much
 *  small than the original, and further clipping will either show that
 *  it is on the curve or provide all Case B or Case A curves.
 *  We try and pick the best axis to clip against, but this may not always
 *  work. One extra step that was included, that is not in the paper for
 *  curves but is for surfaces, is the fact that sometimes the curve is
 *  not clipped enough, if the maximum clip is less than .2 than we sub
 *  divide the curve in three equal parts, at .3 and .6,
 *  Subdivision is done using the Oslo Algorithm, rather than the other
 *  methods which were prossed.
 */
void
rt_clip_cnurb(struct bu_list *plist, struct edge_g_cnurb *crv, fastf_t u, fastf_t v)
{
	fastf_t ds1, dt1;
	struct _interior_line s_line, t_line;
	int axis, i;
	fastf_t umin, umax;
	int coords;
	struct edge_g_cnurb * c1, *c2, *tmp;
	fastf_t m1, m2;
	int zero_changed;
	fastf_t *ptr;
	fastf_t dist[10];

	coords = RT_NURB_EXTRACT_COORDS( crv->pt_type);
	
	s_line.axis = 0;	s_line.o_dist = v;
	t_line.axis = 1;	t_line.o_dist = u;
	
	ds1 = 0.0;
	dt1 = 0.0;

	ptr = crv->ctl_points;


	/* determine what axis to clip against */

	for( i = 0; i < crv->c_size; i++, ptr += coords)
	{
		ds1 += 
		    fabs( rt_trim_line_pt_dist( &s_line, ptr, crv->pt_type) );
		dt1 += 
		    fabs( rt_trim_line_pt_dist( &t_line, ptr, crv->pt_type) );
	}

	if( ds1 >= dt1 ) axis = 0; else axis = 1;

	ptr = crv->ctl_points;

	for( i = 0; i < crv->c_size; i++)
	{
		if( axis == 1)
			dist[i] = rt_trim_line_pt_dist(&t_line, ptr, crv->pt_type);
		else
			dist[i] = rt_trim_line_pt_dist(&s_line, ptr, crv->pt_type);

		ptr += coords;
	}

	/* Find the convex hull of the distances and determine the
	 * minimum and maximum distance to clip against. See the
	 * paper for details about this step
 	 */

	umin = 10e40;
	umax = -10e40;
	zero_changed = 0;

	for( i = 0; i < crv->c_size; i++)
        {
                fastf_t d1, d2;
                fastf_t x0, x1, zero;

                if ( i == (crv->c_size -1 ) )
                {
                        d1 = dist[i];
                        d2 = dist[0];
                        x0 = (fastf_t) i / (fastf_t) (crv->c_size - 1);
                        x1 = 0.0;
                } else
        	{
        		d1 = dist[i];
        		d2 = dist[i+1];
                        x0 = (fastf_t) i / (fastf_t) (crv->c_size - 1 );
                        x1 = (i+1.0) / (crv->c_size - 1);        		
        	}

                if( _SIGN(d1) != _SIGN(d2) )
                {
                        zero = x0 - d1 * (x1 - x0)/ (d2-d1);
                        if( zero <= umin)
                                umin = zero * .99;
                        if( zero >= umax)
                                umax = zero * .99 + .01;
                        zero_changed = 1;
                }
        }

	if( !zero_changed)
		return;

	/* Clip is not large enough, split in thiords and try again */

	if( umax - umin < .2)
	{
		umin = .3; umax = .6;
	}

	/* Translate the 0.0-->1.09 clipping against the real knots */

        m1 = (crv->k.knots[0] * (1 - umin)) +
                crv->k.knots[crv->k.k_size -1] *  umin;

        m2 = (crv->k.knots[0] * (1-umax)) +
                crv->k.knots[crv->k.k_size -1] * umax;

	/* subdivide the curve */
	c1 = (struct edge_g_cnurb *) rt_nurb_c_xsplit(crv, m1);
	c2 = rt_nurb_c_xsplit((struct edge_g_cnurb *) c1->l.forw, m2);

	tmp = (struct edge_g_cnurb *) c1->l.forw;
	BU_LIST_DEQUEUE( &tmp->l);
	rt_nurb_free_cnurb( tmp );
	
	BU_LIST_INIT( plist );
	BU_LIST_INSERT( &c2->l, plist);
	BU_LIST_APPEND( plist, &c1->l);
}



int
nmg_uv_in_lu(const fastf_t u, const fastf_t v, const struct loopuse *lu)
{
	struct edgeuse *eu;
	int crossings=0;

	NMG_CK_LOOPUSE( lu );

	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return( 0 );

	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct edge_g_cnurb *eg;

		if( !eu->g.magic_p )
		{
			bu_log( "nmg_uv_in_lu: eu (x%x) has no geometry!!!\n", eu );
			bu_bomb( "nmg_uv_in_lu: eu has no geometry!!!\n" );
		}

		if( *eu->g.magic_p != NMG_EDGE_G_CNURB_MAGIC )
		{
			bu_log( "nmg_uv_in_lu: Called with lu (x%x) containing eu (x%x) that is not CNURB!!!!\n",
				lu, eu );
			bu_bomb( "nmg_uv_in_lu: Called with lu containing eu that is not CNURB!!!\n" );
		}

		eg = eu->g.cnurb_p;

		if( eg->order <= 0 )
		{
			struct vertexuse *vu1, *vu2;
			struct vertexuse_a_cnurb *vua1, *vua2;
			point_t uv1, uv2;
			fastf_t slope, intersept;
			fastf_t u_on_curve;

			vu1 = eu->vu_p;
			vu2 = eu->eumate_p->vu_p;

			if( !vu1->a.magic_p || !vu2->a.magic_p )
			{
				bu_log( "nmg_uv_in_lu: Called with lu (x%x) containing vu with no attribute!!!!\n",
					lu );
				bu_bomb( "nmg_uv_in_lu: Called with lu containing vu with no attribute!!!\n" );
			}

			if( *vu1->a.magic_p != NMG_VERTEXUSE_A_CNURB_MAGIC ||
			    *vu2->a.magic_p != NMG_VERTEXUSE_A_CNURB_MAGIC )
			{
				bu_log( "nmg_uv_in_lu: Called with lu (x%x) containing vu that is not CNURB!!!!\n",
					lu );
				bu_bomb( "nmg_uv_in_lu: Called with lu containing vu that is not CNURB!!!\n" );
			}

			vua1 = vu1->a.cnurb_p;
			vua2 = vu2->a.cnurb_p;

			VMOVE( uv1, vua1->param );
			VMOVE( uv2, vua2->param );

			if( RT_NURB_IS_PT_RATIONAL( eg->pt_type ) )
			{
				uv1[0] /= uv1[2];
				uv1[1] /= uv1[2];
				uv2[0] /= uv2[2];
				uv2[1] /= uv2[2];
			}

			if( uv1[1] < v && uv2[1] < v )
				continue;
			if( uv1[1] > v && uv2[1] > v )
				continue;
			if( uv1[0] <= u && uv2[0] <= u )
				continue;
			if( uv1[0] == uv2[0] )
			{
				if( (uv1[1] <= v && uv2[1] >= v) ||
				    (uv2[1] <= v && uv1[1] >= v) )
					crossings++;

				continue;
			}

			/* need to calculate intersection */
			slope = (uv1[1] - uv2[1])/(uv1[0] - uv2[0]);
			intersept = uv1[1] - slope * uv1[0];
			u_on_curve = (v - intersept)/slope;
			if( u_on_curve > u )
				crossings++;
		}
		else
			crossings += rt_uv_in_trim( eg, u, v );
	}

	if( crossings & 01 )
		return( 1 );
	else
		return( 0 );
}
@


11.13
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char rcs_ident[] = "$Header: /cvs/brlcad/librt/nurb_trim.c,v 11.12 2004/04/05 08:48:58 morrison Exp $";
@


11.12
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char rcs_ident[] = "$Header$";
d23 5
a27 1
#include "conf.h"
@


11.11
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char rcs_ident[] = "$Header: /c/CVS/brlcad/librt/nurb_trim.c,v 11.10 2002/08/20 17:08:08 jra Exp $";
d33 1
a33 1
extern void	rt_clip_cnurb();
d71 1
a71 3
rt_trim_case( trim, u, v)
struct edge_g_cnurb * trim;
fastf_t u,v;
d123 1
a123 3
rt_process_caseb(trim, u, v)
struct edge_g_cnurb * trim;
fastf_t u, v;
d167 1
a167 3
rt_nurb_uv_dist(trim, u, v)
struct edge_g_cnurb * trim;
fastf_t u, v;
d238 1
a238 3
rt_process_casec(trim, u, v)
struct edge_g_cnurb * trim;
fastf_t u, v;
d305 1
a305 3
rt_uv_in_trim(trim, u,v)
struct edge_g_cnurb * trim;
fastf_t u, v;
d335 1
a335 4
rt_trim_line_pt_dist( l, pt, pt_type)
struct _interior_line *l;
fastf_t * pt;
int pt_type;
d359 1
a359 2
_SIGN(f)
fastf_t f;
d382 1
a382 4
rt_clip_cnurb( plist, crv, u, v )
struct bu_list *plist;
struct edge_g_cnurb * crv;
fastf_t u,v;
d503 1
a503 3
nmg_uv_in_lu( u, v, lu )
const fastf_t u, v;
const struct loopuse *lu;
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 * 	This software is Copyright (C) 1990 by the United States Army.
d20 1
a20 1
static const char rcs_ident[] = "$Header: /c/CVS/brlcad/librt/nurb_trim.c,v 11.8 2001/04/20 22:29:55 morrison Exp $";
@


11.10.4.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 * 	This software is Copyright (C) 1990-2004 by the United States Army.
d20 1
a20 1
static const char rcs_ident[] = "$Header: /n/cad/c/CVS/brlcad/librt/nurb_trim.c,v 11.11 2004/02/02 17:39:28 morrison Exp $";
@


11.10.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 * 	This software is Copyright (C) 1990-2004 by the United States Army.
d20 1
a20 1
static const char rcs_ident[] = "$Header: /c/CVS/brlcad/librt/nurb_trim.c,v 11.11 2004/02/02 17:39:28 morrison Exp $";
@


11.10.10.2
log
@merge from head
@
text
@d20 1
a20 1
static const char rcs_ident[] = "$Header: /c/CVS/brlcad/librt/nurb_trim.c,v 11.10.10.1 2004/02/12 18:37:46 erikg Exp $";
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char rcs_ident[] = "$Header: /c/CVS/brlcad/librt/nurb_trim.c,v 11.10 2002/08/20 17:08:08 jra Exp $";
d33 1
a33 1
extern void	rt_clip_cnurb(struct bu_list *plist, struct edge_g_cnurb *crv, fastf_t u, fastf_t v);
d71 3
a73 1
rt_trim_case(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
d125 3
a127 1
rt_process_caseb(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
d171 3
a173 1
rt_nurb_uv_dist(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
d244 3
a246 1
rt_process_casec(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
d313 3
a315 1
rt_uv_in_trim(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
d345 4
a348 1
rt_trim_line_pt_dist(struct _interior_line *l, fastf_t *pt, int pt_type)
d372 2
a373 1
_SIGN(fastf_t f)
d396 4
a399 1
rt_clip_cnurb(struct bu_list *plist, struct edge_g_cnurb *crv, fastf_t u, fastf_t v)
d520 3
a522 1
nmg_uv_in_lu(const fastf_t u, const fastf_t v, const struct loopuse *lu)
@


11.10.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 * 	This software is Copyright (C) 1990-2004 by the United States Army.
d20 1
a20 1
static const char rcs_ident[] = "$Header$";
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d33 1
a33 1
extern void	rt_clip_cnurb(struct bu_list *plist, struct edge_g_cnurb *crv, fastf_t u, fastf_t v);
d71 3
a73 1
rt_trim_case(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
d125 3
a127 1
rt_process_caseb(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
d171 3
a173 1
rt_nurb_uv_dist(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
d244 3
a246 1
rt_process_casec(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
d313 3
a315 1
rt_uv_in_trim(struct edge_g_cnurb *trim, fastf_t u, fastf_t v)
d345 4
a348 1
rt_trim_line_pt_dist(struct _interior_line *l, fastf_t *pt, int pt_type)
d372 2
a373 1
_SIGN(fastf_t f)
d396 4
a399 1
rt_clip_cnurb(struct bu_list *plist, struct edge_g_cnurb *crv, fastf_t u, fastf_t v)
d520 3
a522 1
nmg_uv_in_lu(const fastf_t u, const fastf_t v, const struct loopuse *lu)
@


11.8
log
@CONST to const
@
text
@d20 1
a20 1
static const char rcs_ident[] = "$Header: /c/CVS/brlcad/librt/nurb_trim.c,v 11.7 2000/08/21 02:02:34 butler Exp $";
d33 1
a33 1
extern void	rt_clip_cnurb();
d71 1
a71 3
rt_trim_case( trim, u, v)
struct edge_g_cnurb * trim;
fastf_t u,v;
d123 1
a123 3
rt_process_caseb(trim, u, v)
struct edge_g_cnurb * trim;
fastf_t u, v;
d167 1
a167 3
rt_nurb_uv_dist(trim, u, v)
struct edge_g_cnurb * trim;
fastf_t u, v;
d238 1
a238 3
rt_process_casec(trim, u, v)
struct edge_g_cnurb * trim;
fastf_t u, v;
d305 1
a305 3
rt_uv_in_trim(trim, u,v)
struct edge_g_cnurb * trim;
fastf_t u, v;
d335 1
a335 4
rt_trim_line_pt_dist( l, pt, pt_type)
struct _interior_line *l;
fastf_t * pt;
int pt_type;
d359 1
a359 2
_SIGN(f)
fastf_t f;
d382 1
a382 4
rt_clip_cnurb( plist, crv, u, v )
struct bu_list *plist;
struct edge_g_cnurb * crv;
fastf_t u,v;
d503 1
a503 3
nmg_uv_in_lu( u, v, lu )
const fastf_t u, v;
const struct loopuse *lu;
@


11.7
log
@Massive compilation warnings eliminated
@
text
@d20 1
a20 1
static const char rcs_ident[] = "$Header: /c/CVS/brlcad/librt/nurb_trim.c,v 11.6 2000/07/25 16:46:06 butler Exp $";
d521 2
a522 2
CONST fastf_t u, v;
CONST struct loopuse *lu;
@


11.6
log
@Fixed bad practice in db5_update_ident definition: implicit int return
@
text
@d20 1
a20 1
static char	rcs_ident[] = "$Header: /c/CVS/brlcad/librt/nurb_trim.c,v 11.5 1997/09/09 14:04:17 jra Exp $";
a61 33

/* This routine will be called several times, once for each portion of
 * the trimming curve. It returns wheter a line extended from the 
 * the <u,v> point will cross the trimming curve an even or odd number
 * of times. Or the <u,v> point could be on the curve in which case
 * TRIM_ON will be returned. THe algorithm uses the approach taken
 * Tom Sederburge and uses bezier clipping to produce caseA and caseB
 * curves. If the original trimming curve is a CASE C curve then further
 * processing is required.
 */
int 
rt_uv_in_trim(trim, u,v)
struct edge_g_cnurb * trim;
fastf_t u, v;
{

	int quad_case;

	quad_case = rt_trim_case( trim, u, v);	/* determine quadrants */
	
							/* CASE A */	
	if( quad_case == CASE_A )
		return TRIM_OUT;
	if( quad_case == CASE_B )			/* CASE B */
		return rt_process_caseb(trim, u, v);
	if( quad_case == CASE_C )			/* CASE C */
		return rt_process_casec(trim, u, v);

	bu_log( "rt_uv_in_trim: rt_trim_case() returned illegal value %d\n", quad_case );
	return( -1 );
}


d168 62
d303 35
d370 11
a516 13
/* Return the SIGN of the value */
int
_SIGN(f)
fastf_t f;
{
	if (f < 0.0)
		return -1;
	else
		return 1;

}

/* Only check end points of the curve */
a517 57
int
rt_nurb_uv_dist(trim, u, v)
struct edge_g_cnurb * trim;
fastf_t u, v;
{

	fastf_t dist;
	fastf_t * ptr;
	int coords;
	int rat;
	fastf_t u2, v2;

	ptr = trim->ctl_points;	
	coords = RT_NURB_EXTRACT_COORDS(trim->pt_type);
	rat = RT_NURB_IS_PT_RATIONAL(trim->pt_type);

	u2 = 0.0;
	v2 = 0.0;

	if ( rat )
	{
		u2 = ptr[0]/ptr[2] - u; u2 *= u2;
		v2 = ptr[1]/ptr[2] - v; v2 *= v2;
	}
	else
	{
		u2 = ptr[0] - u; u2 *= u2;
		v2 = ptr[1] - v; v2 *= v2;
	}

	dist = sqrt( u2 + v2);
	if ( NEAR_ZERO( dist, 1.0e-4) )
		return TRIM_ON;

	ptr = trim->ctl_points + coords * (trim->c_size -1);

	u2 = 0.0;
	v2 = 0.0;

	if ( rat )
	{
		u2 = ptr[0]/ptr[2] - u; u2 *= u2;
		v2 = ptr[1]/ptr[2] - v; v2 *= v2;
	}
	else
	{
		u2 = ptr[0] - u; u2 *= u2;
		v2 = ptr[1] - v; v2 *= v2;
	}

	dist = sqrt( u2 + v2);
	if ( NEAR_ZERO( dist, 1.0e-4) )
		return TRIM_ON;

	return TRIM_OUT;

}
@


11.5
log
@Added nmg_uv_in_lu().
@
text
@d20 1
a20 1
static char	rcs_ident[] = "$Header: /m/cad/librt/RCS/nurb_trim.c,v 11.4 1996/12/31 01:09:27 mike Exp jra $";
d72 1
a72 1

d157 1
a157 1

d443 1
@


11.4
log
@libbu
@
text
@d20 1
a20 1
static char	rcs_ident[] = "$Header: /m/cad/librt/RCS/nurb_trim.c,v 11.3 1996/07/10 20:15:50 jra Exp mike $";
d127 1
a127 1
			if(pts[0]/pts[2] >= u )
d138 1
a138 1
			if(pts[0] >= u )
d172 1
a172 1
		if( pts[0]/pts[2] >= u) q1 = (pts[1]/pts[2] >= v)?QUAD1:QUAD4;
d178 1
a178 1
		if( pts[0]/pts[2] >= u) q2 = (pts[1]/pts[2] >= v)?QUAD1:QUAD4;
d183 1
a183 1
		if( pts[0] >= u) q1 = (pts[1] >= v)?QUAD1:QUAD4;
d190 1
a190 1
		if( pts[0] >= u) q2 = (pts[1] >= v)?QUAD1:QUAD4;
d228 1
a228 1
	if( rt_nurb_uv_dist(trim, u, v)  == TRIM_ON) return TRIM_ON;
d234 4
a237 1
	rt_clip_cnurb(&plist, trim, u, v);
d276 2
d293 1
a293 1
		if( h_flag) h = (pt[1] / pt[2] - l->o_dist) * pt[2];
d511 104
@


11.3
log
@Fixed declaration problems for IRIX 6.2
@
text
@d20 1
a20 1
static char	rcs_ident[] = "$Header: /m/cad/libnurb/RCS/nurb_trim.c,v 11.2 1995/12/01 02:49:33 mike Exp jra $";
d90 1
a90 1
	rt_log( "rt_uv_in_trim: rt_trim_case() returned illegal value %d\n", quad_case );
d222 1
a222 1
	struct rt_list	plist;
d232 1
a232 1
	RT_LIST_INIT(&plist);
d236 1
a236 1
	while( RT_LIST_WHILE( clip, edge_g_cnurb, &plist ) )
d238 1
a238 1
		RT_LIST_DEQUEUE( &clip->l );
d255 1
a255 1
	while( RT_LIST_WHILE( clip, edge_g_cnurb, &plist) )
d257 1
a257 1
		RT_LIST_DEQUEUE( &clip->l );
d317 1
a317 1
struct rt_list *plist;
d429 1
a429 1
	RT_LIST_DEQUEUE( &tmp->l);
d432 3
a434 3
	RT_LIST_INIT( plist );
	RT_LIST_INSERT( &c2->l, plist);
	RT_LIST_APPEND( plist, &c1->l);
@


11.2
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d20 1
a20 1
static char	rcs_ident[] = "$Header: /m/cad/libnurb/RCS/nurb_trim.c,v 11.1 95/01/04 09:53:54 mike Rel4_4 $";
d89 3
d443 1
a443 1
	if (f >= 0.0)
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char	rcs_ident[] = "$Header: /m/cad/libnurb/RCS/nurb_trim.c,v 1.6 94/11/05 00:24:19 mike Exp $";
d74 1
a74 1
struct cnurb * trim;
d102 1
a102 1
struct cnurb * trim;
d156 1
a156 1
struct cnurb * trim;
d213 1
a213 1
struct cnurb * trim;
d217 1
a217 1
	struct cnurb * clip;
d233 1
a233 1
	while( RT_LIST_WHILE( clip, cnurb, &plist ) )
d252 1
a252 1
	while( RT_LIST_WHILE( clip, cnurb, &plist) )
d315 1
a315 1
struct cnurb * crv;
d323 1
a323 1
	struct cnurb * c1, *c2, *tmp;
d415 2
a416 2
        m1 = (crv->knot.knots[0] * (1 - umin)) +
                crv->knot.knots[crv->knot.k_size -1] *  umin;
d418 2
a419 2
        m2 = (crv->knot.knots[0] * (1-umax)) +
                crv->knot.knots[crv->knot.k_size -1] * umax;
d422 2
a423 2
	c1 = (struct cnurb *) rt_nurb_c_xsplit(crv, m1);
	c2 = rt_nurb_c_xsplit((struct cnurb *) c1->l.forw, m2);
d425 1
a425 1
	tmp = (struct cnurb *) c1->l.forw;
d449 1
a449 1
struct cnurb * trim;
@


11.1.1.1
log
@Release_4.5
@
text
@d20 1
a20 1
static char	rcs_ident[] = "$Header: /m/cad4.5/RCS/nurb_trim.c,v 11.5 1997/09/09 14:04:17 jra Exp $";
d74 1
a74 1
struct edge_g_cnurb * trim;
a88 3

	bu_log( "rt_uv_in_trim: rt_trim_case() returned illegal value %d\n", quad_case );
	return( -1 );
d102 1
a102 1
struct edge_g_cnurb * trim;
d124 1
a124 1
			if(pts[0]/pts[2] > u )
d135 1
a135 1
			if(pts[0] > u )
d156 1
a156 1
struct edge_g_cnurb * trim;
d169 1
a169 1
		if( pts[0]/pts[2] > u) q1 = (pts[1]/pts[2] >= v)?QUAD1:QUAD4;
d175 1
a175 1
		if( pts[0]/pts[2] > u) q2 = (pts[1]/pts[2] >= v)?QUAD1:QUAD4;
d180 1
a180 1
		if( pts[0] > u) q1 = (pts[1] >= v)?QUAD1:QUAD4;
d187 1
a187 1
		if( pts[0] > u) q2 = (pts[1] >= v)?QUAD1:QUAD4;
d213 1
a213 1
struct edge_g_cnurb * trim;
d217 1
a217 1
	struct edge_g_cnurb * clip;
d219 1
a219 1
	struct bu_list	plist;
d225 1
a225 1
	if( rt_nurb_uv_dist(trim, u, v)  == TRIM_ON) return TRIM_IN;
d229 1
a229 1
	BU_LIST_INIT(&plist);
d231 1
a231 4
	if( nurb_crv_is_bezier( trim ) )
		rt_clip_cnurb(&plist, trim, u, v);
	else
		nurb_c_to_bezier( &plist, trim );
d233 1
a233 1
	while( BU_LIST_WHILE( clip, edge_g_cnurb, &plist ) )
d235 1
a235 1
		BU_LIST_DEQUEUE( &clip->l );
d252 1
a252 1
	while( BU_LIST_WHILE( clip, edge_g_cnurb, &plist) )
d254 1
a254 1
		BU_LIST_DEQUEUE( &clip->l );
a269 2
 *
 *	Equations 3, 4, 5 in Sederberg '90 paper 
d285 1
a285 1
		if( h_flag) h = (pt[1] / pt[2] - l->o_dist) * pt[2]; /* pt[2] is weight */
d314 2
a315 2
struct bu_list *plist;
struct edge_g_cnurb * crv;
d323 1
a323 1
	struct edge_g_cnurb * c1, *c2, *tmp;
d415 2
a416 2
        m1 = (crv->k.knots[0] * (1 - umin)) +
                crv->k.knots[crv->k.k_size -1] *  umin;
d418 2
a419 2
        m2 = (crv->k.knots[0] * (1-umax)) +
                crv->k.knots[crv->k.k_size -1] * umax;
d422 2
a423 2
	c1 = (struct edge_g_cnurb *) rt_nurb_c_xsplit(crv, m1);
	c2 = rt_nurb_c_xsplit((struct edge_g_cnurb *) c1->l.forw, m2);
d425 2
a426 2
	tmp = (struct edge_g_cnurb *) c1->l.forw;
	BU_LIST_DEQUEUE( &tmp->l);
d429 3
a431 3
	BU_LIST_INIT( plist );
	BU_LIST_INSERT( &c2->l, plist);
	BU_LIST_APPEND( plist, &c1->l);
d440 1
a440 1
	else
d449 1
a449 1
struct edge_g_cnurb * trim;
a502 104
}

int
nmg_uv_in_lu( u, v, lu )
CONST fastf_t u, v;
CONST struct loopuse *lu;
{
	struct edgeuse *eu;
	int crossings=0;

	NMG_CK_LOOPUSE( lu );

	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return( 0 );

	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct edge_g_cnurb *eg;

		if( !eu->g.magic_p )
		{
			bu_log( "nmg_uv_in_lu: eu (x%x) has no geometry!!!\n", eu );
			bu_bomb( "nmg_uv_in_lu: eu has no geometry!!!\n" );
		}

		if( *eu->g.magic_p != NMG_EDGE_G_CNURB_MAGIC )
		{
			bu_log( "nmg_uv_in_lu: Called with lu (x%x) containing eu (x%x) that is not CNURB!!!!\n",
				lu, eu );
			bu_bomb( "nmg_uv_in_lu: Called with lu containing eu that is not CNURB!!!\n" );
		}

		eg = eu->g.cnurb_p;

		if( eg->order <= 0 )
		{
			struct vertexuse *vu1, *vu2;
			struct vertexuse_a_cnurb *vua1, *vua2;
			point_t uv1, uv2;
			fastf_t slope, intersept;
			fastf_t u_on_curve;

			vu1 = eu->vu_p;
			vu2 = eu->eumate_p->vu_p;

			if( !vu1->a.magic_p || !vu2->a.magic_p )
			{
				bu_log( "nmg_uv_in_lu: Called with lu (x%x) containing vu with no attribute!!!!\n",
					lu );
				bu_bomb( "nmg_uv_in_lu: Called with lu containing vu with no attribute!!!\n" );
			}

			if( *vu1->a.magic_p != NMG_VERTEXUSE_A_CNURB_MAGIC ||
			    *vu2->a.magic_p != NMG_VERTEXUSE_A_CNURB_MAGIC )
			{
				bu_log( "nmg_uv_in_lu: Called with lu (x%x) containing vu that is not CNURB!!!!\n",
					lu );
				bu_bomb( "nmg_uv_in_lu: Called with lu containing vu that is not CNURB!!!\n" );
			}

			vua1 = vu1->a.cnurb_p;
			vua2 = vu2->a.cnurb_p;

			VMOVE( uv1, vua1->param );
			VMOVE( uv2, vua2->param );

			if( RT_NURB_IS_PT_RATIONAL( eg->pt_type ) )
			{
				uv1[0] /= uv1[2];
				uv1[1] /= uv1[2];
				uv2[0] /= uv2[2];
				uv2[1] /= uv2[2];
			}

			if( uv1[1] < v && uv2[1] < v )
				continue;
			if( uv1[1] > v && uv2[1] > v )
				continue;
			if( uv1[0] <= u && uv2[0] <= u )
				continue;
			if( uv1[0] == uv2[0] )
			{
				if( (uv1[1] <= v && uv2[1] >= v) ||
				    (uv2[1] <= v && uv1[1] >= v) )
					crossings++;

				continue;
			}

			/* need to calculate intersection */
			slope = (uv1[1] - uv2[1])/(uv1[0] - uv2[0]);
			intersept = uv1[1] - slope * uv1[0];
			u_on_curve = (v - intersept)/slope;
			if( u_on_curve > u )
				crossings++;
		}
		else
			crossings += rt_uv_in_trim( eg, u, v );
	}

	if( crossings & 01 )
		return( 1 );
	else
		return( 0 );
@


1.6
log
@Irix 6
@
text
@d20 1
a20 1
static char	rcs_ident[] = "$Header: /m/cad/libnurb/RCS/nurb_trim.c,v 1.5 94/08/11 01:19:13 gdurf Exp Locker: mike $";
@


1.5
log
@Added includes
@
text
@d20 1
a20 1
static char	rcs_ident[] = "$Header: /m/cad/libnurb/RCS/nurb_trim.c,v 1.4 1993/10/01 19:52:07 mike Exp gdurf $";
a217 1
	point_t max_uv, min_uv;
a327 1
	fastf_t ftmp1, ftmp2;
a454 1
	int i;
@


1.4
log
@Added VOID decl.
@
text
@d20 1
a20 1
static char	rcs_ident[] = "$Header: /m/cad/libnurb/RCS/nurb_trim.c,v 1.3 93/07/20 15:26:35 mike Exp Locker: mike $";
d23 3
d27 4
@


1.3
log
@Initialized trim_flag
@
text
@d20 1
a20 1
static char	rcs_ident[] = "$Header: /m/cad/libnurb/RCS/nurb_trim.c,v 1.2 93/04/07 00:51:23 mike Exp Locker: mike $";
d26 2
d306 1
a306 1

@


1.2
log
@Changed to relative path
@
text
@d20 1
a20 1
static char	rcs_ident[] = "$Header: /m/cad/libnurb/RCS/nurb_trim.c,v 1.1 92/09/17 14:23:12 stay Exp Locker: mike $";
d212 1
a212 1
	int trim_flag;
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char	rcs_ident[] = "$Header: /m/cad/libnurb/RCS/nurb_basis.c,v 10.1 91/10/12 06:39:04 mike Rel4_0 $";
d24 1
a24 1
#include "/m/cad/h/nurb.h"
@
