head	11.16;
access;
symbols
	ansi-20040405-merged:11.12.2.2
	postmerge-20040405-ansi:11.14
	premerge-20040404-ansi:11.13
	postmerge-autoconf:11.13
	autoconf-freeze:11.12.10.2
	premerge-autoconf:11.13
	ansi-20040316-freeze:11.12.2.1
	postmerge-20040315-windows:11.13
	premerge-20040315-windows:11.13
	windows-20040315-freeze:11.12.4.1
	autoconf-20031203:11.12
	autoconf-20031202:11.12
	autoconf-branch:11.12.0.10
	phong-branch:11.12.0.8
	photonmap-branch:11.12.0.6
	rel-6-1-DP:11.12
	windows-branch:11.12.0.4
	rel-6-0-2:11.10
	ansi-branch:11.12.0.2
	rel-6-0-1-branch:11.10.0.2
	hartley-6-0-post:11.11
	hartley-6-0-pre:11.10
	rel-6-0-1:11.10
	rel-6-0:11.10
	rel-5-4:11.7
	offsite-5-3-pre:11.9
	rel-5-3:11.7
	rel-5-2:11.7
	rel-5-1-branch:11.7.0.2
	rel-5-1:11.7
	rel-5-0:11.7
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.16
date	2004.05.21.18.07.33;	author morrison;	state dead;
branches;
next	11.15;

11.15
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.14;

11.14
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2004.02.02.17.39.23;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2002.08.20.17.08.04;	author jra;	state Exp;
branches
	11.12.2.1
	11.12.4.1
	11.12.10.1;
next	11.11;

11.11
date	2002.08.15.20.55.15;	author hartley;	state Exp;
branches;
next	11.10;

11.10
date	2001.04.20.22.29.51;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2000.08.22.21.28.09;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.07.10.23.01.42;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.07.02.22.47.22;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.07.02.22.19.25;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.06.03.01.43.37;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.06.28.18.26.43;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.02.15.00.16.16;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.50;	author mike;	state Rel4_4;
branches;
next	10.12;

10.12
date	94.12.30.04.13.09;	author butler;	state Exp;
branches;
next	10.11;

10.11
date	94.12.27.18.20.34;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.09.21.03.37.44;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.08.10.18.53.18;	author gdurf;	state Exp;
branches;
next	10.8;

10.8
date	94.08.09.19.38.01;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.01.25.09.36.45;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.03.20.04.10.55;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.11.17.00.31.24;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.11.17.00.18.18;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.02.21.01.35.50;	author butler;	state Exp;
branches;
next	10.2;

10.2
date	92.02.19.00.24.54;	author butler;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.46;	author mike;	state Rel4_0;
branches;
next	1.3;

1.3
date	91.06.29.21.23.34;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.06.17.20.42.06;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	91.06.13.05.43.31;	author butler;	state Exp;
branches;
next	;

11.12.2.1
date	2002.09.19.18.01.39;	author morrison;	state Exp;
branches;
next	11.12.2.2;

11.12.2.2
date	2004.03.17.21.18.53;	author morrison;	state Exp;
branches;
next	;

11.12.4.1
date	2004.03.11.23.43.42;	author morrison;	state Exp;
branches;
next	;

11.12.10.1
date	2004.02.12.18.37.44;	author erikg;	state Exp;
branches;
next	11.12.10.2;

11.12.10.2
date	2004.03.15.14.07.26;	author erikg;	state Exp;
branches;
next	;


desc
@routines to identify topological elements as being 0,1,2 or 3 manifolds.
@


11.16
log
@moved to src/
@
text
@/*
 *			N M G _ M A N I F . C
 *
 *  Routines for assessing the manifold dimension of an object.
 *
 *  Author -
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_manif.c,v 11.15 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "vmath.h"
#include "externs.h"
#include "nmg.h"
#include "raytrace.h"

#define PAINT_INTERIOR 1
#define PAINT_EXTERIOR 0

#define BU_LIST_LINK_CHECK( p ) \
	if (BU_LIST_PNEXT_PLAST(bu_list, p) != p || \
	    BU_LIST_PLAST_PNEXT(bu_list, p) != p) { \
		bu_log("%s[%d]: linked list integrity check failed\n", \
				__FILE__, __LINE__); \
	    	bu_log("0x%08x->forw(0x%08x)->back = 0x%08x\n", \
	    		(p), (p)->forw, (p)->forw->back); \
	    	bu_log("0x%08x->back(0x%08x)->forw = 0x%08x\n", \
	    		(p), (p)->back, (p)->back->forw); \
	    	rt_bomb("Goodbye\n"); \
	}
	    

/*	N M G _ D A N G L I N G _ F A C E
 *
 *	Determine if a face has any "dangling" edges.
 *
 *	Return
 *	1	face has dangling edge
 *	0	face does not have a dangling edge
 */
int 
nmg_dangling_face(const struct faceuse *fu, register const char *manifolds)
{
	struct loopuse *lu;
	struct edgeuse *eu;
	const struct edgeuse *eur;
	struct faceuse *newfu;

	NMG_CK_FACEUSE(fu);

	if (rt_g.NMG_debug & DEBUG_MANIF)
		bu_log("nmg_dangling_face(0x%08x 0x%08x)\n", fu, manifolds);

	for(BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
	    NMG_CK_LOOPUSE(lu);
	    BU_LIST_LINK_CHECK( &lu->l );

	    if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
	        /* go looking around each edge for a face of the same
	         * shell which isn't us and isn't our mate.  If we
	         * find us or our mate before another face of this
	         * shell, we are non-3-manifold.
	         */

	    	for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {

	 	    NMG_CK_EDGEUSE( eu );
	 	    BU_LIST_LINK_CHECK( &eu->l );

		    eur = nmg_radial_face_edge_in_shell(eu);
		    newfu = eur->up.lu_p->up.fu_p;

	    	    /* skip any known dangling-edge faces or 
		     * faces known to be 2manifolds.
		     */
		    while (manifolds &&
		        NMG_MANIFOLDS(manifolds,newfu) & NMG_2MANIFOLD &&
			eur != eu->eumate_p) {
				eur = nmg_radial_face_edge_in_shell(
					eur->eumate_p);
				newfu = eur->up.lu_p->up.fu_p;
	    	    }

		    if (eur == eu->eumate_p) {
		    	goto out;
		    }
		}
	    }
	}
	eur = (const struct edgeuse *)NULL;

out:
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		struct bn_tol	tol;	/* HACK */
		tol.magic = BN_TOL_MAGIC;
		tol.dist = 1;
		tol.dist_sq = tol.dist * tol.dist;
		tol.perp = 1e-5;
		tol.para = 1 - tol.perp;

		bu_log("nmg_dangling_face(fu=x%x, manifolds=x%x) dangling_eu=x%x\n", fu, manifolds, eur);
		if( eur )  nmg_pr_fu_around_eu( eur, &tol );
	}
	if ((rt_g.NMG_debug & DEBUG_MANIF) && (eur != (const struct edgeuse *)NULL) )
		bu_log( "\tdangling eu x%x\n", eur );

	return eur != (const struct edgeuse *)NULL;
}

/*
 *	"Paint" the elements of a face with a meaning.  For example
 *	mark everything in a face as being part of a 2-manifold
 */
static void paint_face(struct faceuse *fu, char *paint_table, int paint_color, char *paint_meaning, char *tbl)
{
	struct faceuse *newfu;
	struct loopuse *lu;
	struct edgeuse *eu;
	const struct edgeuse *eur;

#if 1
	if (rt_g.NMG_debug & DEBUG_MANIF)
		bu_log("nmg_paint_face(%08x, %d)\n", fu, paint_color);
#endif
	if (NMG_INDEX_VALUE(paint_table, fu->index) != 0)
		return;

	NMG_INDEX_ASSIGN(paint_table, fu, paint_color);

	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {

		if (rt_g.NMG_debug & DEBUG_MANIF)
			bu_log( "\tlu=x%x\n", lu );

		NMG_CK_LOOPUSE( lu );
		BU_LIST_LINK_CHECK( &lu->l );

		if (BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC)
			continue;

		for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
			if (rt_g.NMG_debug & DEBUG_MANIF)
				bu_log( "\t\teu=x%x\n", eu );
			NMG_CK_EDGEUSE(eu);
			NMG_CK_EDGEUSE(eu->eumate_p);
			eur = nmg_radial_face_edge_in_shell(eu);
			NMG_CK_EDGEUSE(eur);
			NMG_CK_FACEUSE(eur->up.lu_p->up.fu_p);
			newfu = eur->up.lu_p->up.fu_p;

			if (rt_g.NMG_debug & DEBUG_MANIF)
				bu_log( "\t\t\teur=x%x, newfu=x%x\n", eur, newfu );

			BU_LIST_LINK_CHECK( &eu->l );
			BU_LIST_LINK_CHECK( &eur->l );

			while (NMG_MANIFOLDS(tbl, newfu) & NMG_2MANIFOLD &&
			    eur != eu->eumate_p) {
				eur = nmg_radial_face_edge_in_shell(
							eur->eumate_p);
				newfu = eur->up.lu_p->up.fu_p;

				if (rt_g.NMG_debug & DEBUG_MANIF)
					bu_log( "\t\t\teur=x%x, newfu=x%x\n", eur, newfu );
			}

			if( newfu == fu->fumate_p )
				continue;
			else if (newfu->orientation == OT_SAME)
				paint_face(newfu,paint_table,paint_color,
					paint_meaning,tbl);
			else {
				/* mark this group as being interior */
				paint_meaning[paint_color] = PAINT_INTERIOR;

				if (rt_g.NMG_debug & DEBUG_MANIF)
					bu_log( "\t---- Painting fu x%x as interior, new_fu = x%x, eu=x%x, eur=x%x\n", fu, newfu, eu, eur );
			}
		}
	}
}

static void set_edge_sub_manifold(char *tbl, struct edgeuse *eu_p, char manifold)
{
	
	NMG_CK_EDGEUSE(eu_p);
	NMG_CK_EDGE(eu_p->e_p);
	NMG_CK_VERTEXUSE(eu_p->vu_p);
	NMG_CK_VERTEX(eu_p->vu_p->v_p);

	NMG_SET_MANIFOLD(tbl, eu_p, manifold);
	NMG_SET_MANIFOLD(tbl, eu_p->e_p, manifold);

	NMG_SET_MANIFOLD(tbl, eu_p->vu_p, manifold);
	NMG_SET_MANIFOLD(tbl, eu_p->vu_p->v_p, manifold);
}


static void set_loop_sub_manifold(char *tbl, struct loopuse *lu_p, char manifold)
{
	struct edgeuse *eu_p;
	struct vertexuse *vu_p;
#if 0
	if (rt_g.NMG_debug & DEBUG_MANIF)
		bu_log("nmg_set_loop_sub_manifold(%08x)\n", lu_p);
#endif
	NMG_CK_LOOPUSE(lu_p);

	NMG_SET_MANIFOLD(tbl, lu_p, manifold);
	NMG_SET_MANIFOLD(tbl, lu_p->l_p, manifold);
	if (BU_LIST_FIRST_MAGIC(&lu_p->down_hd) == NMG_VERTEXUSE_MAGIC) {
		vu_p = BU_LIST_FIRST(vertexuse, &lu_p->down_hd);
		NMG_SET_MANIFOLD(tbl, vu_p, manifold);
		NMG_SET_MANIFOLD(tbl, vu_p->v_p, manifold);
	} else if (BU_LIST_FIRST_MAGIC(&lu_p->down_hd) == NMG_EDGEUSE_MAGIC) {
		for (BU_LIST_FOR(eu_p, edgeuse, &lu_p->down_hd)) {
			BU_LIST_LINK_CHECK( &eu_p->l );
			set_edge_sub_manifold(tbl, eu_p, manifold);
		}
	} else
		rt_bomb("bad child of loopuse\n");
}
static void set_face_sub_manifold(char *tbl, struct faceuse *fu_p, char manifold)
{
	struct loopuse *lu_p;
	
	NMG_CK_FACEUSE(fu_p);
	NMG_CK_FACE(fu_p->f_p);

	NMG_SET_MANIFOLD(tbl, fu_p, manifold);
	NMG_SET_MANIFOLD(tbl, fu_p->f_p, manifold);
	for (BU_LIST_FOR(lu_p, loopuse, &fu_p->lu_hd)) {
		BU_LIST_LINK_CHECK( &lu_p->l );
		set_loop_sub_manifold(tbl, lu_p, manifold);
	}
}



char *
nmg_shell_manifolds(struct shell *sp, char *tbl)
{
	struct edgeuse *eu_p;
	struct loopuse *lu_p;
	struct faceuse *fu_p;
	char *paint_meaning, *paint_table, paint_color;
	int found;

	if (rt_g.NMG_debug & DEBUG_MANIF)
		bu_log("nmg_shell_manifolds(%08x)\n", sp);

	NMG_CK_SHELL(sp);

	if (tbl == (char *)NULL)
		tbl = bu_calloc(sp->r_p->m_p->maxindex, 1, "manifold table");

	/*
	 * points in shells form 0-manifold objects.
	 */
	if (sp->vu_p) {
		NMG_CK_VERTEXUSE(sp->vu_p);
		NMG_SET_MANIFOLD(tbl, sp, NMG_0MANIFOLD);
		NMG_SET_MANIFOLD(tbl, sp->vu_p, NMG_0MANIFOLD);
		NMG_SET_MANIFOLD(tbl, sp->vu_p->v_p, NMG_0MANIFOLD);
		BU_LIST_LINK_CHECK( &sp->vu_p->l );
	}

	/* edges in shells are (components of)
	 * 1-manifold objects.
	 */
	if (BU_LIST_NON_EMPTY(&sp->eu_hd)) {

		for (BU_LIST_FOR(eu_p, edgeuse, &sp->eu_hd)) {
			BU_LIST_LINK_CHECK( &eu_p->l );
			set_edge_sub_manifold(tbl, eu_p, NMG_1MANIFOLD);
		}
		NMG_SET_MANIFOLD(tbl, sp, NMG_1MANIFOLD);
	}

	/* loops in shells are (components of)
	 * 1-manifold objects.
	 */
	if (BU_LIST_NON_EMPTY(&sp->lu_hd)) {

		for (BU_LIST_FOR(lu_p, loopuse, &sp->lu_hd)) {
			BU_LIST_LINK_CHECK( &lu_p->l );

			set_loop_sub_manifold(tbl, lu_p, NMG_1MANIFOLD);
		}
		NMG_SET_MANIFOLD(tbl, sp, NMG_1MANIFOLD);
	}

	if (rt_g.NMG_debug & DEBUG_MANIF)
		bu_log("starting manifold classification on shell faces\n");

	/*
	 * faces may be either 2 or 3 manifold components.
	 */
	if (BU_LIST_IS_EMPTY(&sp->fu_hd))
		return tbl;


	/* mark all externally dangling faces and faces
	 * with or adjacent to dangling edges.
	 */
	do {
		found = 0;
		for (BU_LIST_FOR(fu_p, faceuse, &sp->fu_hd)) {
			NMG_CK_FACEUSE(fu_p);
			BU_LIST_LINK_CHECK( &fu_p->l );

			/* if this has already been marked as a 2-manifold
			 * then we don't need to check it again
			 */
			if (NMG_MANIFOLDS(tbl,fu_p) & NMG_2MANIFOLD)
				continue;

			if (nmg_dangling_face(fu_p, tbl)) {
				found = 1;

				NMG_SET_MANIFOLD(tbl, fu_p, NMG_2MANIFOLD);

				if (rt_g.NMG_debug & DEBUG_MANIF)
					bu_log("found dangling face\n");
			}
		}
	} while (found);

	/* paint the exterior faces to discover what the
	 * actual enclosing shell is
	 */

	if (rt_g.NMG_debug & DEBUG_MANIF)
		bu_log("starting to paint non-dangling faces\n");

	paint_meaning = bu_calloc(256, 1, "paint meaning table");
	paint_table = bu_calloc(sp->r_p->m_p->maxindex, 1, "paint table");
	paint_color = 1;

	for (BU_LIST_FOR(fu_p, faceuse, &sp->fu_hd)) {
		BU_LIST_LINK_CHECK( &fu_p->l );

		if (fu_p->orientation != OT_SAME ||
		    NMG_INDEX_VALUE(paint_table, fu_p->index) != 0)
			continue;

		paint_face(fu_p, paint_table, paint_color, paint_meaning, tbl);
		paint_color++;
	}

		
	if (rt_g.NMG_debug & DEBUG_MANIF)
		bu_log("painting done, looking at colors\n");

		
	/* all the faces painted with "interior" paint are 2manifolds
	 * those faces still painted with "exterior" paint are
	 * 3manifolds, ie. part of the enclosing surface
	 */
	for (BU_LIST_FOR(fu_p, faceuse, &sp->fu_hd)) {
		BU_LIST_LINK_CHECK( &fu_p->l );

		paint_color = NMG_INDEX_VALUE(paint_table,
						fu_p->index);

		if (NMG_INDEX_VALUE(paint_meaning, (int)paint_color) ==
		    PAINT_INTERIOR) {
		    	set_face_sub_manifold(tbl, fu_p, NMG_2MANIFOLD);
		} else if (NMG_INDEX_VALUE(paint_meaning, (int)paint_color)
		    == PAINT_EXTERIOR) {
		    	set_face_sub_manifold(tbl, fu_p, NMG_3MANIFOLD);
		}
	}

	bu_free(paint_meaning, "paint meaning table");
	bu_free(paint_table, "paint table");

	for (BU_LIST_FOR(fu_p, faceuse, &sp->fu_hd)) {
		BU_LIST_LINK_CHECK( &fu_p->l );

		if (fu_p->orientation != OT_SAME)
			NMG_CP_MANIFOLD(tbl, fu_p, fu_p->fumate_p);
	}

	return(tbl);
}


char *
nmg_manifolds(struct model *m)
{
	struct nmgregion *rp;
	struct shell *sp;
	char *tbl;


	NMG_CK_MODEL(m);
	if (rt_g.NMG_debug & DEBUG_MANIF)
		bu_log("nmg_manifolds(%08x)\n", m);

	tbl = bu_calloc(m->maxindex, 1, "manifold table");


	for (BU_LIST_FOR(rp, nmgregion, &m->r_hd)) {
		NMG_CK_REGION(rp);
		BU_LIST_LINK_CHECK( &rp->l );

		for (BU_LIST_FOR(sp, shell, &rp->s_hd)) {

			NMG_CK_SHELL( sp );
			BU_LIST_LINK_CHECK( &sp->l );

			nmg_shell_manifolds(sp, tbl);

			/* make sure the region manifold bits are a superset
			 * of the shell manifold bits
			 */
			NMG_CP_MANIFOLD(tbl, rp, sp);
		}
	}

	return(tbl);
}

@


11.15
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_manif.c,v 11.14 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.14
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d26 5
a30 1
#include "conf.h"
@


11.13
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_manif.c,v 11.12 2002/08/20 17:08:04 jra Exp $ (ARL)";
d64 1
a64 3
nmg_dangling_face(fu, manifolds)
const struct faceuse	*fu;
register const char	*manifolds;
d136 1
a136 4
static void paint_face(fu, paint_table, paint_color, paint_meaning, tbl)
struct faceuse *fu;
char *paint_table, *paint_meaning, *tbl;
int paint_color;
d205 1
a205 4
static void set_edge_sub_manifold(tbl, eu_p, manifold)
char *tbl;
struct edgeuse *eu_p;
char manifold;
d221 1
a221 4
static void set_loop_sub_manifold(tbl, lu_p, manifold)
char *tbl;
struct loopuse *lu_p;
char manifold;
d245 1
a245 4
static void set_face_sub_manifold(tbl, fu_p, manifold)
char *tbl;
struct faceuse *fu_p;
char manifold;
d263 1
a263 3
nmg_shell_manifolds(sp, tbl)
struct shell *sp;
char *tbl;
d412 1
a412 2
nmg_manifolds(m)
struct model *m;
@


11.12
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_manif.c,v 11.10 2001/04/20 22:29:51 morrison Exp $ (ARL)";
@


11.12.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_manif.c,v 11.13 2004/02/02 17:39:23 morrison Exp $ (ARL)";
@


11.12.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_manif.c,v 11.13 2004/02/02 17:39:23 morrison Exp $ (ARL)";
@


11.12.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_manif.c,v 11.12.10.1 2004/02/12 18:37:44 erikg Exp $ (ARL)";
@


11.12.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_manif.c,v 11.12 2002/08/20 17:08:04 jra Exp $ (ARL)";
d64 3
a66 1
nmg_dangling_face(const struct faceuse *fu, register const char *manifolds)
d138 4
a141 1
static void paint_face(struct faceuse *fu, char *paint_table, int paint_color, char *paint_meaning, char *tbl)
d210 4
a213 1
static void set_edge_sub_manifold(char *tbl, struct edgeuse *eu_p, char manifold)
d229 4
a232 1
static void set_loop_sub_manifold(char *tbl, struct loopuse *lu_p, char manifold)
d256 4
a259 1
static void set_face_sub_manifold(char *tbl, struct faceuse *fu_p, char manifold)
d277 3
a279 1
nmg_shell_manifolds(struct shell *sp, char *tbl)
d428 2
a429 1
nmg_manifolds(struct model *m)
@


11.12.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.11
log
@Converted from K&R to ANSI C - RFH
@
text
@d64 3
a66 1
nmg_dangling_face(const struct faceuse *fu, register const char *manifolds)
d138 4
a141 1
static void paint_face(struct faceuse *fu, char *paint_table, int paint_color, char *paint_meaning, char *tbl)
d210 4
a213 1
static void set_edge_sub_manifold(char *tbl, struct edgeuse *eu_p, char manifold)
d229 4
a232 1
static void set_loop_sub_manifold(char *tbl, struct loopuse *lu_p, char manifold)
d256 4
a259 1
static void set_face_sub_manifold(char *tbl, struct faceuse *fu_p, char manifold)
d277 3
a279 1
nmg_shell_manifolds(struct shell *sp, char *tbl)
d428 2
a429 1
nmg_manifolds(struct model *m)
@


11.10
log
@CONST to const
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_manif.c,v 11.9 2000/08/22 21:28:09 mike Exp $ (ARL)";
d64 1
a64 3
nmg_dangling_face(fu, manifolds)
const struct faceuse	*fu;
register const char	*manifolds;
d136 1
a136 4
static void paint_face(fu, paint_table, paint_color, paint_meaning, tbl)
struct faceuse *fu;
char *paint_table, *paint_meaning, *tbl;
int paint_color;
d205 1
a205 4
static void set_edge_sub_manifold(tbl, eu_p, manifold)
char *tbl;
struct edgeuse *eu_p;
char manifold;
d221 1
a221 4
static void set_loop_sub_manifold(tbl, lu_p, manifold)
char *tbl;
struct loopuse *lu_p;
char manifold;
d245 1
a245 4
static void set_face_sub_manifold(tbl, fu_p, manifold)
char *tbl;
struct faceuse *fu_p;
char manifold;
d263 1
a263 3
nmg_shell_manifolds(sp, tbl)
struct shell *sp;
char *tbl;
d412 1
a412 2
nmg_manifolds(m)
struct model *m;
@


11.9
log
@
Lint
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_manif.c,v 11.8 2000/07/10 23:01:42 mike Exp $ (ARL)";
d65 2
a66 2
CONST struct faceuse	*fu;
register CONST char	*manifolds;
d70 1
a70 1
	CONST struct edgeuse *eur;
d114 1
a114 1
	eur = (CONST struct edgeuse *)NULL;
d128 1
a128 1
	if ((rt_g.NMG_debug & DEBUG_MANIF) && (eur != (CONST struct edgeuse *)NULL) )
d131 1
a131 1
	return eur != (CONST struct edgeuse *)NULL;
d146 1
a146 1
	CONST struct edgeuse *eur;
@


11.8
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_manif.c,v 11.7 1999/07/02 22:47:22 mike Exp $ (ARL)";
d404 1
a404 1
		if (NMG_INDEX_VALUE(paint_meaning, paint_color) ==
d407 1
a407 1
		} else if (NMG_INDEX_VALUE(paint_meaning, paint_color)
@


11.7
log
@
Fixed script-induced typos
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_manif.c,v 11.6 1999/07/02 22:19:25 mike Exp $ (ARL)";
@


11.6
log
@
Removed dependence on compat4.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_manif.c,v 11.5 1999/06/03 01:43:37 mike Exp $ (ARL)";
d163 1
a163 1
		RT_LIST_LINK_CHECK( &lu->l );
d181 2
a182 2
			RT_LIST_LINK_CHECK( &eu->l );
			RT_LIST_LINK_CHECK( &eur->l );
d250 1
a250 1
			RT_LIST_LINK_CHECK( &eu_p->l );
d269 1
a269 1
		RT_LIST_LINK_CHECK( &lu_p->l );
d303 1
a303 1
		RT_LIST_LINK_CHECK( &sp->vu_p->l );
d312 1
a312 1
			RT_LIST_LINK_CHECK( &eu_p->l );
d324 1
a324 1
			RT_LIST_LINK_CHECK( &lu_p->l );
d348 1
a348 1
			RT_LIST_LINK_CHECK( &fu_p->l );
d379 1
a379 1
		RT_LIST_LINK_CHECK( &fu_p->l );
d399 1
a399 1
		RT_LIST_LINK_CHECK( &fu_p->l );
d417 1
a417 1
		RT_LIST_LINK_CHECK( &fu_p->l );
d445 1
a445 1
		RT_LIST_LINK_CHECK( &rp->l );
d450 1
a450 1
			RT_LIST_LINK_CHECK( &sp->l );
@


11.5
log
@
sed4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_manif.c,v 11.4 1996/09/27 08:27:30 mike Exp $ (ARL)";
d42 3
a44 3
#define RT_LIST_LINK_CHECK( p ) \
	if (BU_LIST_PNEXT_PLAST(rt_list, p) != p || \
	    BU_LIST_PLAST_PNEXT(rt_list, p) != p) { \
d80 1
a80 1
	    RT_LIST_LINK_CHECK( &lu->l );
d92 1
a92 1
	 	    RT_LIST_LINK_CHECK( &eu->l );
@


11.4
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_manif.c,v 11.3 1996/06/28 18:26:43 jra Exp mike $ (ARL)";
d293 1
a293 1
		tbl = rt_calloc(sp->r_p->m_p->maxindex, 1, "manifold table");
d374 2
a375 2
	paint_meaning = rt_calloc(256, 1, "paint meaning table");
	paint_table = rt_calloc(sp->r_p->m_p->maxindex, 1, "paint table");
d413 2
a414 2
	rt_free(paint_meaning, "paint meaning table");
	rt_free(paint_table, "paint table");
d440 1
a440 1
	tbl = rt_calloc(m->maxindex, 1, "manifold table");
@


11.3
log
@Added code to paint_face() to eliminate classing a faceuse based on its mate.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_manif.c,v 11.2 1995/02/15 00:16:16 mike Exp jra $ (ARL)";
d43 3
a45 3
	if (RT_LIST_PNEXT_PLAST(rt_list, p) != p || \
	    RT_LIST_PLAST_PNEXT(rt_list, p) != p) { \
		rt_log("%s[%d]: linked list integrity check failed\n", \
d47 1
a47 1
	    	rt_log("0x%08x->forw(0x%08x)->back = 0x%08x\n", \
d49 1
a49 1
	    	rt_log("0x%08x->back(0x%08x)->forw = 0x%08x\n", \
d76 1
a76 1
		rt_log("nmg_dangling_face(0x%08x 0x%08x)\n", fu, manifolds);
d78 1
a78 1
	for(RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
d82 1
a82 1
	    if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
d89 1
a89 1
	    	for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d118 2
a119 2
		struct rt_tol	tol;	/* HACK */
		tol.magic = RT_TOL_MAGIC;
d125 1
a125 1
		rt_log("nmg_dangling_face(fu=x%x, manifolds=x%x) dangling_eu=x%x\n", fu, manifolds, eur);
d129 1
a129 1
		rt_log( "\tdangling eu x%x\n", eur );
d150 1
a150 1
		rt_log("nmg_paint_face(%08x, %d)\n", fu, paint_color);
d157 1
a157 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
d160 1
a160 1
			rt_log( "\tlu=x%x\n", lu );
d165 1
a165 1
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC)
d168 1
a168 1
		for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d170 1
a170 1
				rt_log( "\t\teu=x%x\n", eu );
d179 1
a179 1
				rt_log( "\t\t\teur=x%x, newfu=x%x\n", eur, newfu );
d191 1
a191 1
					rt_log( "\t\t\teur=x%x, newfu=x%x\n", eur, newfu );
d204 1
a204 1
					rt_log( "\t---- Painting fu x%x as interior, new_fu = x%x, eu=x%x, eur=x%x\n", fu, newfu, eu, eur );
d238 1
a238 1
		rt_log("nmg_set_loop_sub_manifold(%08x)\n", lu_p);
d244 2
a245 2
	if (RT_LIST_FIRST_MAGIC(&lu_p->down_hd) == NMG_VERTEXUSE_MAGIC) {
		vu_p = RT_LIST_FIRST(vertexuse, &lu_p->down_hd);
d248 2
a249 2
	} else if (RT_LIST_FIRST_MAGIC(&lu_p->down_hd) == NMG_EDGEUSE_MAGIC) {
		for (RT_LIST_FOR(eu_p, edgeuse, &lu_p->down_hd)) {
d268 1
a268 1
	for (RT_LIST_FOR(lu_p, loopuse, &fu_p->lu_hd)) {
d288 1
a288 1
		rt_log("nmg_shell_manifolds(%08x)\n", sp);
d309 1
a309 1
	if (RT_LIST_NON_EMPTY(&sp->eu_hd)) {
d311 1
a311 1
		for (RT_LIST_FOR(eu_p, edgeuse, &sp->eu_hd)) {
d321 1
a321 1
	if (RT_LIST_NON_EMPTY(&sp->lu_hd)) {
d323 1
a323 1
		for (RT_LIST_FOR(lu_p, loopuse, &sp->lu_hd)) {
d332 1
a332 1
		rt_log("starting manifold classification on shell faces\n");
d337 1
a337 1
	if (RT_LIST_IS_EMPTY(&sp->fu_hd))
d346 1
a346 1
		for (RT_LIST_FOR(fu_p, faceuse, &sp->fu_hd)) {
d362 1
a362 1
					rt_log("found dangling face\n");
d372 1
a372 1
		rt_log("starting to paint non-dangling faces\n");
d378 1
a378 1
	for (RT_LIST_FOR(fu_p, faceuse, &sp->fu_hd)) {
d391 1
a391 1
		rt_log("painting done, looking at colors\n");
d398 1
a398 1
	for (RT_LIST_FOR(fu_p, faceuse, &sp->fu_hd)) {
d416 1
a416 1
	for (RT_LIST_FOR(fu_p, faceuse, &sp->fu_hd)) {
d438 1
a438 1
		rt_log("nmg_manifolds(%08x)\n", m);
d443 1
a443 1
	for (RT_LIST_FOR(rp, nmgregion, &m->r_hd)) {
d447 1
a447 1
		for (RT_LIST_FOR(sp, shell, &rp->s_hd)) {
@


11.2
log
@Added debugging print.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_manif.c,v 11.1 95/01/04 09:57:50 mike Rel4_4 Locker: mike $ (ARL)";
d128 3
d148 1
a148 1
#if 0
d159 3
d169 2
d178 3
d189 3
d194 3
a196 1
			if (newfu->orientation == OT_SAME)
d202 3
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_manif.c,v 10.12 94/12/30 04:13:09 butler Exp $ (ARL)";
d109 1
a109 1
			return(1);
d114 1
d116 13
a128 1
	return(0);
@


10.12
log
@fixed bug in nmg_shell_manifolds() where known 2-manifolds are re-checked
causing infinite loop.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_manif.c,v 10.11 1994/12/27 18:20:34 mike Exp butler $ (ARL)";
@


10.11
log
@Added RCSid
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d42 13
d75 3
d80 1
a86 1
	         *
d91 3
d97 9
a105 11
	    	    if (manifolds) {

		    	    /* skip any known dangling-edge faces or 
		    	     * faces known to be 2manifolds.
			     */
			    while (NMG_MANIFOLDS(manifolds,newfu) & NMG_2MANIFOLD &&
				eur != eu->eumate_p) {
					eur = nmg_radial_face_edge_in_shell(
						eur->eumate_p);
					newfu = eur->up.lu_p->up.fu_p;
			    }
d132 4
d142 4
d157 2
d204 4
a207 1

d218 1
d237 1
d253 1
d255 2
d271 1
d278 1
d280 1
d290 1
d292 2
d299 1
a299 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d305 2
a306 2
	if (RT_LIST_NON_EMPTY(&sp->fu_hd)) {
		register int found;
a307 18
		/* mark all externally dangling faces and faces
		 * with or adjacent to dangling edges.
		 */

		do {
			found = 0;
			for (RT_LIST_FOR(fu_p, faceuse, &sp->fu_hd)) {
				if (nmg_dangling_face(fu_p, tbl)) {
					found = 1;

					NMG_SET_MANIFOLD(tbl, fu_p, 
							NMG_2MANIFOLD);

					if (rt_g.NMG_debug & DEBUG_NMGRT)
						rt_log("found dangling faces\n");
				}
			}
		} while (found);
d309 8
a316 10
		/* paint the exterior faces to discover what the
		 * actual enclosing shell is
		 */

		if (rt_g.NMG_debug & DEBUG_NMGRT)
			rt_log("starting to paint non-dangling faces\n");

		paint_meaning = rt_calloc(256, 1, "paint meaning table");
		paint_table = rt_calloc(sp->r_p->m_p->maxindex, 1, "paint table");
		paint_color = 1;
d318 4
a321 3
		for (RT_LIST_FOR(fu_p, faceuse, &sp->fu_hd)) {
			if (fu_p->orientation != OT_SAME ||
			    NMG_INDEX_VALUE(paint_table, fu_p->index) != 0)
d324 8
a331 2
			paint_face(fu_p, paint_table, paint_color, paint_meaning, tbl);
			paint_color++;
d333 23
d358 2
a359 2
		if (rt_g.NMG_debug & DEBUG_NMGRT)
			rt_log("painting done, looking at colors\n");
d362 8
a369 6
		/* all the faces painted with "interior" paint are 2manifolds
		 * those faces still painted with "exterior" paint are
		 * 3manifolds, ie. part of the enclosing surface
		 */
		for (RT_LIST_FOR(fu_p, faceuse, &sp->fu_hd)) {
			paint_color = NMG_INDEX_VALUE(paint_table,
d372 8
a379 7
			if (NMG_INDEX_VALUE(paint_meaning, paint_color) ==
			    PAINT_INTERIOR) {
			    	set_face_sub_manifold(tbl, fu_p, NMG_2MANIFOLD);
			} else if (NMG_INDEX_VALUE(paint_meaning, paint_color)
			    == PAINT_EXTERIOR) {
			    	set_face_sub_manifold(tbl, fu_p, NMG_3MANIFOLD);
			}
d381 2
a382 1
		}
d384 2
a385 2
		rt_free(paint_meaning, "paint meaning table");
		rt_free(paint_table, "paint table");
d387 2
a388 4
		for (RT_LIST_FOR(fu_p, faceuse, &sp->fu_hd)) {
			if (fu_p->orientation != OT_SAME)
				NMG_CP_MANIFOLD(tbl, fu_p, fu_p->fumate_p);
		}
d403 1
d405 2
d410 1
d413 1
d416 4
@


10.10
log
@deleted "manifolds" from struct model, and moved it to struct ray_data.
Added extra argument to nmg_dangling_face().
@
text
@d1 25
@


10.9
log
@Factored ifdefs
@
text
@a23 3
 *
 *  Implicit Input -
 *	The "manifolds" array in the "model" structure.
d26 1
a26 1
nmg_dangling_face(fu)
d28 1
a33 1
	register char *tbl;
a35 1
	tbl = fu->s_p->r_p->m_p->manifolds;
d53 1
a53 1
	    	    if (tbl) {
d58 1
a58 1
			    while (NMG_MANIFOLDS(tbl,newfu) & NMG_2MANIFOLD &&
d249 1
a249 1
				if (nmg_dangling_face(fu_p /**,tbl**/)) {
d327 1
a327 5
	if (m->manifolds == (char *)NULL)
		m->manifolds = 
		tbl = rt_calloc(m->maxindex, 1, "manifold table");
	else
		tbl = m->manifolds;
@


10.8
log
@Added GDurf's new "conf.h"
@
text
@d3 3
a5 1
#ifdef BSD
a6 2
#else
#include <string.h>
@


10.7
log
@A few CONSTS
@
text
@d1 1
@


10.6
log
@Some args became CONST.
@
text
@d32 2
a33 1
	struct edgeuse *eu, *eur;
d90 2
a91 1
	struct edgeuse *eu, *eur;
@


10.5
log
@Oops.
@
text
@d23 3
d29 1
a29 2
struct faceuse *fu;
/**char *tblXXX;**/
d46 1
a46 1
	         * shell, we are non-manifold.
@


10.4
log
@nmg_dangling_face was declared with more args than it's called with
in other modules.
@
text
@d248 1
a248 1
				if (nmg_dangling_face(fu_p, tbl)) {
@


10.3
log
@added pointer checking and made call to paint_face() have proper # of args.
@
text
@d25 1
a25 1
nmg_dangling_face(fu, tblXXX)
d27 1
a27 1
char *tblXXX;
@


10.2
log
@changed call to NMG_CK_VERTEX to NMG_CK_VERTEXUSE for child of shell
@
text
@d77 2
a78 1
 *
d99 2
d102 2
d106 1
d115 2
a116 1
				paint_face(newfu,paint_table,paint_color,tbl);
@


10.1
log
@Release_4.0
@
text
@d199 1
a199 1
		NMG_CK_VERTEX(sp->vu_p);
@


1.3
log
@nmg_dangling_face(fu, tblXXX)
        register char *tbl;
The argument "tbl" was being hidden by the variable "tbl".
Since it was not clear which one should win,
I just changed the name of the argument.
@
text
@@


1.2
log
@changed function declarations so that all global functions have their
"nmg_" at the begining of the line.  Static functions have their function
names on the same line as the "static" modifier.
@
text
@d25 1
a25 1
nmg_dangling_face(fu, tbl)
d27 1
a27 1
char *tbl;
@


1.1
log
@Initial revision
@
text
@d79 1
a79 2
static void
paint_face(fu, paint_table, paint_color, paint_meaning, tbl)
d118 1
a118 2
static void
set_edge_sub_manifold(tbl, eu_p, manifold)
d137 1
a137 2
static void
set_loop_sub_manifold(tbl, lu_p, manifold)
d160 1
a160 2
static void
set_face_sub_manifold(tbl, fu_p, manifold)
@
