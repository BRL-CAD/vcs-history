head	11.33;
access;
symbols
	ansi-20040405-merged:11.29.2.2
	postmerge-20040405-ansi:11.31
	premerge-20040404-ansi:11.30
	postmerge-autoconf:11.30
	autoconf-freeze:11.29.10.2
	premerge-autoconf:11.30
	ansi-20040316-freeze:11.29.2.1
	postmerge-20040315-windows:11.30
	premerge-20040315-windows:11.30
	windows-20040315-freeze:11.29.4.1
	autoconf-20031203:11.29
	autoconf-20031202:11.29
	autoconf-branch:11.29.0.10
	phong-branch:11.29.0.8
	photonmap-branch:11.29.0.6
	rel-6-1-DP:11.29
	windows-branch:11.29.0.4
	rel-6-0-2:11.27
	ansi-branch:11.29.0.2
	rel-6-0-1-branch:11.27.0.2
	hartley-6-0-post:11.28
	hartley-6-0-pre:11.27
	rel-6-0-1:11.27
	rel-6-0:11.27
	rel-5-4:11.19
	offsite-5-3-pre:11.24
	rel-5-3:11.19
	rel-5-2:11.19
	rel-5-1-branch:11.19.0.2
	rel-5-1:11.19
	rel-5-0:11.13
	rel-5-0-beta:11.13
	rel-4-5:11.11
	ctj-4-5-post:11.9
	ctj-4-5-pre:11.9
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1;
locks; strict;
comment	@ * @;


11.33
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	11.32;

11.32
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.31;

11.31
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	11.29;

11.29
date	2002.08.20.17.07.57;	author jra;	state Exp;
branches
	11.29.2.1
	11.29.4.1
	11.29.10.1;
next	11.28;

11.28
date	2002.08.15.20.55.08;	author hartley;	state Exp;
branches;
next	11.27;

11.27
date	2001.05.17.20.05.23;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2001.04.02.21.38.07;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2001.03.31.01.57.06;	author morrison;	state Exp;
branches;
next	11.24;

11.24
date	2000.10.18.18.10.34;	author butler;	state Exp;
branches;
next	11.23;

11.23
date	2000.09.09.04.30.46;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.07.25.16.46.06;	author butler;	state Exp;
branches;
next	11.21;

11.21
date	2000.07.11.23.16.46;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.07.10.23.01.27;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.04.12.02.15.12;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.02.08.04.56.32;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.01.22.01.23.05;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.01.19.23.56.59;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.12.22.02.17.58;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	99.11.24.21.44.29;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	99.05.10.21.30.47;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	98.12.17.04.19.09;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	97.12.23.06.01.44;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	97.12.16.06.09.11;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.12.04.02.50.27;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	96.10.19.06.17.45;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.07.10.20.20.31;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.09.18.21.54.05;	author cjohnson;	state Exp;
branches;
next	11.4;

11.4
date	95.09.15.23.26.32;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.03.13.19.01.40;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.03.11.00.05.16;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.14;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.08.10.17.50.27;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.04.05.20.45.26;	author cjohnson;	state Exp;
branches;
next	10.6;

10.6
date	94.04.05.17.50.35;	author cjohnson;	state Exp;
branches;
next	10.5;

10.5
date	94.04.05.04.22.25;	author cjohnson;	state Exp;
branches;
next	10.4;

10.4
date	94.04.05.04.14.23;	author cjohnson;	state Exp;
branches;
next	10.3;

10.3
date	94.04.04.15.42.35;	author cjohnson;	state Exp;
branches;
next	10.2;

10.2
date	94.03.31.23.45.09;	author cjohnson;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.01;	author mike;	state Rel4_0;
branches;
next	9.6;

9.6
date	91.09.20.22.40.21;	author butler;	state Exp;
branches;
next	9.5;

9.5
date	91.01.25.15.47.43;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.11.11.04.55.11;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.04.12.03.48.59;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.12.31.01.24.11;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.53.45;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	88.12.30.02.34.24;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.30.53;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.05.14.00.47.28;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.32.35;	author mike;	state Rel;
branches;
next	6.4;

6.4
date	87.10.14.21.19.59;	author mike;	state Exp;
branches;
next	6.3;

6.3
date	87.10.14.21.10.17;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.09.26.07.50.25;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.55.07;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.10.38;	author mike;	state Rel;
branches;
next	1.4;

1.4
date	87.03.23.23.42.45;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	87.03.19.05.05.25;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	87.03.19.03.02.33;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.03.11.01.30.15;	author mike;	state Exp;
branches;
next	;

11.29.2.1
date	2002.09.19.18.01.31;	author morrison;	state Exp;
branches;
next	11.29.2.2;

11.29.2.2
date	2004.03.17.21.18.43;	author morrison;	state Exp;
branches;
next	;

11.29.4.1
date	2004.03.11.23.43.35;	author morrison;	state Exp;
branches;
next	;

11.29.10.1
date	2004.02.12.18.37.38;	author erikg;	state Exp;
branches;
next	11.29.10.2;

11.29.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@Animation Control routines, used before and durring the database tree walk.
@


11.33
log
@moved to src/
@
text
@/*
 *			D B _ A N I M . C
 *
 *  Routines to apply animation directives to geometry database.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1987-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSanim[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db_anim.c,v 11.32 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "raytrace.h"
#include "./debug.h"


/*
 *			D B _ A D D _ A N I M
 *
 *  Add a user-supplied animate structure to the end of the chain of such
 *  structures hanging from the directory structure of the last node of
 *  the path specifier.  When 'root' is non-zero, this matrix is
 *  located at the root of the tree itself, rather than an arc, and is
 *  stored differently.
 *
 *  In the future, might want to check to make sure that callers directory
 *  references are in the right database (dbip).
 */
int
db_add_anim(struct db_i *dbip, register struct animate *anp, int root)
{
	register struct animate **headp;
	struct directory	*dp;

	/* Could validate an_type here */

	RT_CK_ANIMATE(anp);
	anp->an_forw = ANIM_NULL;
	if( root )  {
		if( RT_G_DEBUG&DEBUG_ANIM )
			bu_log("db_add_anim(x%x) root\n", anp);
		headp = &(dbip->dbi_anroot);
	} else {
		dp = DB_FULL_PATH_CUR_DIR(&anp->an_path);
		if( RT_G_DEBUG&DEBUG_ANIM )
			bu_log("db_add_anim(x%x) arc %s\n", anp,
				dp->d_namep);
		headp = &(dp->d_animate);
	}

	/* Append to list */
	while( *headp != ANIM_NULL ) {
		RT_CK_ANIMATE(*headp);
		headp = &((*headp)->an_forw);
	}
	*headp = anp;
	return(0);			/* OK */
}

static char	*db_anim_matrix_strings[] = {
	"(nope)",
	"ANM_RSTACK",
	"ANM_RARC",
	"ANM_LMUL",
	"ANM_RMUL",
	"ANM_RBOTH",
	"eh?"
};

/*
 *			D B _ D O _ A N I M
 *
 *  Perform the one animation operation.
 *  Leave results in form that additional operations can be cascaded.
 *
 *  Note that 'materp' may be a null pointer, signifying that
 *  the region has already been finalized above this point in the tree.
 */
int
db_do_anim(register struct animate *anp, mat_t stack, mat_t arc, struct mater_info *materp)
{
	mat_t	temp;

	if( RT_G_DEBUG&DEBUG_ANIM )
		bu_log("db_do_anim(x%x) ", anp);
	if( RT_G_DEBUG&DEBUG_ANIM && !materp )  bu_log("(null materp) ");
	RT_CK_ANIMATE(anp);
	switch( anp->an_type )  {
	case RT_AN_MATRIX:
		if( RT_G_DEBUG&DEBUG_ANIM )  {
			int	op = anp->an_u.anu_m.anm_op;
			if( op < 0 )  op = 0;
			bu_log("matrix, op=%s (%d)\n",
				db_anim_matrix_strings[op], op);
			if( RT_G_DEBUG&DEBUG_ANIM_FULL )  {
				bn_mat_print("on original arc", arc);
				bn_mat_print("on original stack", stack);
			}
		}
		switch( anp->an_u.anu_m.anm_op )  {
		case ANM_RSTACK:
			MAT_COPY( stack, anp->an_u.anu_m.anm_mat );
			break;
		case ANM_RARC:
			MAT_COPY( arc, anp->an_u.anu_m.anm_mat );
			break;
		case ANM_RBOTH:
			MAT_COPY( stack, anp->an_u.anu_m.anm_mat );
			MAT_IDN( arc );
			break;
		case ANM_LMUL:
			/* arc = DELTA * arc */
			bn_mat_mul( temp, anp->an_u.anu_m.anm_mat, arc );
			MAT_COPY( arc, temp );
			break;
		case ANM_RMUL:
			/* arc = arc * DELTA */
			bn_mat_mul( temp, arc, anp->an_u.anu_m.anm_mat );
			MAT_COPY( arc, temp );
			break;
		default:
			return(-1);		/* BAD */
		}
		if( RT_G_DEBUG&DEBUG_ANIM_FULL )  {
			bn_mat_print("arc result", arc);
			bn_mat_print("stack result", stack);
		}
		break;
	case RT_AN_MATERIAL:
		if( RT_G_DEBUG&DEBUG_ANIM )
			bu_log("property\n");
		/*
		 * if the caller does not care about property, a null
		 * mater pointer is given.
		 */
		if (!materp)  {
			char *sofar = db_path_to_string(&anp->an_path);
			bu_log("ERROR db_do_anim(%s) property animation below region, ignored\n", sofar);
			bu_free(sofar, "path string");
			break;
		}
		if (anp->an_u.anu_p.anp_op == RT_ANP_REPLACE) {
		    	if( materp->ma_shader ) bu_free( (genptr_t)materp->ma_shader, "ma_shader" );
			materp->ma_shader = bu_vls_strdup(&anp->an_u.anu_p.anp_shader);
		} else if (anp->an_u.anu_p.anp_op == RT_ANP_APPEND) {
			struct bu_vls	str;

			bu_vls_init(&str);
			bu_vls_strcpy( &str, materp->ma_shader );
			bu_vls_putc( &str, ' ' );
			bu_vls_vlscat( &str, &anp->an_u.anu_p.anp_shader );
		    	if( materp->ma_shader )  bu_free( (genptr_t)materp->ma_shader, "ma_shader" );
			materp->ma_shader = bu_vls_strgrab( &str );
			/* bu_vls_free( &str ) is done by bu_vls_strgrab() */
		} else
			bu_log("Unknown anp_op=%d\n", anp->an_u.anu_p.anp_op);
		break;
	case RT_AN_COLOR:
		if( RT_G_DEBUG&DEBUG_ANIM )
			bu_log("color\n");
		/*
		 * if the caller does not care about property, a null
		 * mater pointer is given.
		 */
		if (!materp)  {
			char *sofar = db_path_to_string(&anp->an_path);
			bu_log("ERROR db_do_anim(%s) color animation below region, ignored\n", sofar);
			bu_free(sofar, "path string");
			break;
		}
		materp->ma_color_valid = 1;	/* XXX - really override? */
		materp->ma_color[0] =
		    (((float)anp->an_u.anu_c.anc_rgb[0])+0.5)*bn_inv255;
		materp->ma_color[1] =
		    (((float)anp->an_u.anu_c.anc_rgb[1])+0.5)*bn_inv255;
		materp->ma_color[2] =
		    (((float)anp->an_u.anu_c.anc_rgb[2])+0.5)*bn_inv255;
		break;
	case RT_AN_TEMPERATURE:
		if( RT_G_DEBUG&DEBUG_ANIM )
			bu_log("temperature = %g\n", anp->an_u.anu_t);
		if (!materp)  {
			char *sofar = db_path_to_string(&anp->an_path);
			bu_log("ERROR db_do_anim(%s) temperature animation below region, ignored\n", sofar);
			bu_free(sofar, "path string");
			break;
		}
		materp->ma_temperature = anp->an_u.anu_t;
		break;
	default:
		if( RT_G_DEBUG&DEBUG_ANIM )
			bu_log("unknown op\n");
		/* Print something here? */
		return(-1);			/* BAD */
	}
	return(0);				/* OK */
}

/*
 *			D B _ F R E E _ 1 A N I M
 *
 *  Free one animation structure
 */
void
db_free_1anim( struct animate *anp )
{
	RT_CK_ANIMATE( anp );

	switch( anp->an_type )  {
	case RT_AN_MATERIAL:
		bu_vls_free( &anp->an_u.anu_p.anp_shader );
		break;
	}

	db_free_full_path( &anp->an_path );
	bu_free( (char *)anp, "animate");
}

/*
 *			D B _ F R E E _ A N I M
 *
 *  Release chain of animation structures
 *
 *  An unfortunate choice of name.
 */
void
db_free_anim(register struct db_i *dbip)
{
	register struct animate *anp;
	register struct directory *dp;
	register int		i;

	/* Rooted animations */
	for( anp = dbip->dbi_anroot; anp != ANIM_NULL; )  {
		register struct animate *nextanp;
		RT_CK_ANIMATE(anp);
		nextanp = anp->an_forw;

		db_free_1anim( anp );
		anp = nextanp;
	}
	dbip->dbi_anroot = ANIM_NULL;

	/* Node animations */
	for( i=0; i < RT_DBNHASH; i++ )  {
		dp = dbip->dbi_Head[i];
		for( ; dp != DIR_NULL; dp = dp->d_forw )  {
			for( anp = dp->d_animate; anp != ANIM_NULL; )  {
				register struct animate *nextanp;
				RT_CK_ANIMATE(anp);
				nextanp = anp->an_forw;

				db_free_1anim( anp );
				anp = nextanp;
			}
			dp->d_animate = ANIM_NULL;
		}
	}
}

/*
 *			D B _ P A R S E _ 1 A N I M
 *
 *  Parse one "anim" type command into an "animate" structure.
 *  argv[1] must be the "a/b" path spec,
 *  argv[2] indicates what is to be animated on that arc.
 */
struct animate	*
db_parse_1anim(struct db_i *dbip, int argc, const char **argv)
{
	struct db_tree_state	ts;
	struct animate		*anp;
	int	i;

	BU_GETSTRUCT( anp, animate );
	anp->magic = ANIMATE_MAGIC;

	db_init_db_tree_state( &ts, dbip, &rt_uniresource );
	db_full_path_init( &anp->an_path );
	if( db_follow_path_for_state( &ts, &(anp->an_path), argv[1], LOOKUP_NOISY ) < 0 )
		goto bad;

	if( strcmp( argv[2], "matrix" ) == 0 )  {
		anp->an_type = RT_AN_MATRIX;
		if( strcmp( argv[3], "rstack" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_RSTACK;
		else if( strcmp( argv[3], "rarc" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_RARC;
		else if( strcmp( argv[3], "lmul" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_LMUL;
		else if( strcmp( argv[3], "rmul" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_RMUL;
		else if( strcmp( argv[3], "rboth" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_RBOTH;
		else  {
			bu_log("db_parse_1anim:  Matrix op '%s' unknown\n",
				argv[3]);
			goto bad;
		}
		/* Allow some shorthands for the matrix spec */
		if( strcmp( argv[4], "translate" ) == 0 ||
		    strcmp( argv[4], "xlate" ) == 0 )  {
		    	if( argc < 5+2 )  {
		    		bu_log("db_parse_1anim:  matrix %s translate does not have enough arguments, only %d\n",
		    			argv[3], argc );
		    		goto bad;
		    	}
		    	MAT_IDN( anp->an_u.anu_m.anm_mat );
		    	MAT_DELTAS( anp->an_u.anu_m.anm_mat,
		    		atof( argv[5+0] ),
		    		atof( argv[5+1] ),
		    		atof( argv[5+2] ) );
		} else if( strcmp( argv[4], "rot" ) == 0 )  {
			if( argc < 5+2 )  {
		    		bu_log("db_parse_1anim:  matrix %s rot does not have enough arguments, only %d\n",
		    			argv[3], argc );
		    		goto bad;
		    	}
		    	MAT_IDN( anp->an_u.anu_m.anm_mat );
			bn_mat_angles( anp->an_u.anu_m.anm_mat,
		    		atof( argv[5+0] ),
		    		atof( argv[5+1] ),
		    		atof( argv[5+2] ) );
		} else if( strcmp( argv[4], "scale" ) == 0 )  {
			fastf_t	scale;
			if( argc < 5+0 )  {
		    		bu_log("db_parse_1anim:  matrix %s scale does not have enough arguments, only %d\n",
		    			argv[3], argc );
		    		goto bad;
		    	}
			scale = atof( argv[5+3] );
			if( NEAR_ZERO( scale, SMALL ) )  {
				bu_log("db_parse_1anim:  matrix %s scale factor is zero\n",
		    			argv[3] );
				goto bad;
			}
		    	MAT_IDN( anp->an_u.anu_m.anm_mat );
			anp->an_u.anu_m.anm_mat[15] = 1/scale;
		} else if( strcmp( argv[4], "scale_about" ) == 0 )  {
			point_t	pt;
			fastf_t	scale;
			if( argc < 5+3 )  {
		    		bu_log("db_parse_1anim:  matrix %s scale_about does not have enough arguments, only %d\n",
		    			argv[3], argc );
		    		goto bad;
		    	}
			VSET( pt,
		    		atof( argv[5+0] ),
		    		atof( argv[5+1] ),
		    		atof( argv[5+2] ) );
			scale = atof( argv[5+3] );
			if( bn_mat_scale_about_pt( anp->an_u.anu_m.anm_mat,
			    pt, scale ) < 0 )  {
				bu_log("db_parse_1anim: matrix %s scale_about (%g, %g, %g) scale=%g failed\n",
			    		argv[3], V3ARGS(pt), scale );
			    	goto bad;
			}
		} else {
			/* No keyword, assume full 4x4 matrix */
			for( i=0; i<16; i++ )
				anp->an_u.anu_m.anm_mat[i] = atof( argv[i+4] );
		}
	} else if( strcmp( argv[2], "material" ) == 0 )  {
		anp->an_type = RT_AN_MATERIAL;
		bu_vls_init( &anp->an_u.anu_p.anp_shader );
		if( (strcmp( argv[3], "replace" ) == 0) ||
		    (strcmp( argv[3], "rboth" ) == 0) )  {
			bu_vls_from_argv( &anp->an_u.anu_p.anp_shader,
				argc-4, (char **)&argv[4] );
			anp->an_u.anu_p.anp_op = RT_ANP_REPLACE;
		} else if( strcmp( argv[3], "append" ) == 0 )  {
			bu_vls_from_argv( &anp->an_u.anu_p.anp_shader,
				argc-4, (char **)&argv[4] );
			anp->an_u.anu_p.anp_op = RT_ANP_APPEND;
		} else {
			bu_log("db_parse_1anim:  material animation '%s' unknown\n",
				argv[3]);
			goto bad;
		}
	} else if( strcmp( argv[2], "color" ) == 0 )  {
		anp->an_type = RT_AN_COLOR;
		anp->an_u.anu_c.anc_rgb[0] = atoi( argv[3+0] );
		anp->an_u.anu_c.anc_rgb[1] = atoi( argv[3+1] );
		anp->an_u.anu_c.anc_rgb[2] = atoi( argv[3+2] );
	} else if( strcmp( argv[2], "temperature" ) == 0 ||
		   strcmp( argv[2], "temp" ) == 0 )  {
		anp->an_type = RT_AN_TEMPERATURE;
		anp->an_u.anu_t = atof( argv[3] );
	} else {
		bu_log("db_parse_1anim:  animation type '%s' unknown\n", argv[2]);
		goto bad;
	}
	db_free_db_tree_state( &ts );
	return anp;
bad:
	db_free_db_tree_state( &ts );
	db_free_1anim( anp );		/* Does db_free_full_path() for us */
	return (struct animate *)NULL;
}

/*
 *			D B _ P A R S E _ A N I M
 *
 *  A common parser for mged and rt.
 *  Experimental.
 *  Not the best name for this.
 */
int db_parse_anim(struct db_i	*dbip,
		int		argc,
		const char	**argv)
{
	struct animate		*anp;
	int	at_root = 0;

	if( !(anp = db_parse_1anim( dbip, argc, argv )) )
		return -1;	/* BAD */

	if( argv[1][0] == '/' )
		at_root = 1;

	if( anp->an_path.fp_len > 1 )
		at_root = 0;

	if( db_add_anim( dbip, anp, at_root ) < 0 )  {
		return -1;	/* BAD */
	}
	return 0;		/* OK */
}
void
db_write_anim(FILE *fop, struct animate *anp)
{
	char *thepath;
	int i;

	RT_CK_ANIMATE(anp);

	thepath  = db_path_to_string(&(anp->an_path));
	if ( RT_G_DEBUG&DEBUG_ANIM) {
		bu_log("db_write_anim: Writing %s\n", thepath);
	}

	fprintf(fop,"anim %s ", thepath);
	bu_free(thepath, "path string");

	switch (anp->an_type) {
	case RT_AN_MATRIX:
		fputs("matrix ",fop);
		switch (anp->an_u.anu_m.anm_op) {
		case ANM_RSTACK:
			fputs("rstack\n", fop);
			break;
		case ANM_RARC:
			fputs("rarc\n", fop);
			break;
		case ANM_LMUL:
			fputs("lmul\n", fop);
			break;
		case ANM_RMUL:
			fputs("rmul\n", fop);
			break;
		case ANM_RBOTH:
			fputs("rboth\n", fop);
			break;
		default:
			fputs("unknown\n",fop);
			bu_log("db_write_anim: unknown matrix operation\n");
		}
		for (i=0; i<16; i++) {
			fprintf(fop, " %.15e", anp->an_u.anu_m.anm_mat[i]);
			if ((i == 15) || ((i&3) == 3)) {
				fputs("\n",fop);
			}
		}
		break;
	case RT_AN_MATERIAL:
		fputs("material ",fop);
		switch (anp->an_u.anu_p.anp_op) {
		case RT_ANP_REPLACE:
			fputs("replace ", fop);
			break;
		case RT_ANP_APPEND:
			fputs("append ", fop);
			break;
		default:
			bu_log("db_write_anim: unknown property operation.\n");
			break;
		}
		break;
	case RT_AN_COLOR:
		fprintf(fop,"color %d %d %d", anp->an_u.anu_c.anc_rgb[0],
		    anp->an_u.anu_c.anc_rgb[1], anp->an_u.anu_c.anc_rgb[2]);
		break;
	case RT_AN_SOLID:
		break;
	default:
		bu_log("db_write_anim: Unknown animate type.\n");
	}
	fputs(";\n", fop);
	return;
}
@


11.32
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /cvs/brlcad/librt/db_anim.c,v 11.31 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.31
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header$ (BRL)";
d22 5
a26 1
#include "conf.h"
@


11.30
log
@update copyright to include span through 2003
@
text
@d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.29 2002/08/20 17:07:57 jra Exp $ (BRL)";
d49 1
a49 4
db_add_anim( dbip, anp, root )
struct db_i *dbip;
register struct animate *anp;
int	root;
d99 1
a99 5
db_do_anim( anp, stack, arc, materp )
register struct animate *anp;
mat_t	stack;
mat_t	arc;
struct mater_info	*materp;
d246 1
a246 2
db_free_anim( dbip )
register struct db_i *dbip;
d288 1
a288 4
db_parse_1anim( dbip, argc, argv )
struct db_i	*dbip;
int		argc;
const char	**argv;
d449 1
a449 3
db_write_anim(fop, anp)
FILE *fop;
struct animate *anp;
@


11.29
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1987 by the United States Army.
d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.27 2001/05/17 20:05:23 morrison Exp $ (BRL)";
@


11.29.4.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/db_anim.c,v 11.30 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


11.29.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.30 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


11.29.10.2
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.29.10.1 2004/02/12 18:37:38 erikg Exp $ (BRL)";
@


11.29.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.29 2002/08/20 17:07:57 jra Exp $ (BRL)";
d49 4
a52 1
db_add_anim(struct db_i *dbip, register struct animate *anp, int root)
d102 5
a106 1
db_do_anim(register struct animate *anp, fastf_t *stack, fastf_t *arc, struct mater_info *materp)
d253 2
a254 1
db_free_anim(register struct db_i *dbip)
d296 4
a299 1
db_parse_1anim(struct db_i *dbip, int argc, const char **argv)
d460 3
a462 1
db_write_anim(FILE *fop, struct animate *anp)
@


11.29.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header$ (BRL)";
@


11.28
log
@Converted from K&R to ANSI C - RFH
@
text
@d49 4
a52 1
db_add_anim(struct db_i *dbip, register struct animate *anp, int root)
d102 5
a106 1
db_do_anim(register struct animate *anp, fastf_t *stack, fastf_t *arc, struct mater_info *materp)
d253 2
a254 1
db_free_anim(register struct db_i *dbip)
d296 4
a299 1
db_parse_1anim(struct db_i *dbip, int argc, const char **argv)
d460 3
a462 1
db_write_anim(FILE *fop, struct animate *anp)
@


11.27
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.26 2001/04/02 21:38:07 morrison Exp $ (BRL)";
d49 1
a49 4
db_add_anim( dbip, anp, root )
struct db_i *dbip;
register struct animate *anp;
int	root;
d99 1
a99 5
db_do_anim( anp, stack, arc, materp )
register struct animate *anp;
mat_t	stack;
mat_t	arc;
struct mater_info	*materp;
d246 1
a246 2
db_free_anim( dbip )
register struct db_i *dbip;
d288 1
a288 4
db_parse_1anim( dbip, argc, argv )
struct db_i	*dbip;
int		argc;
const char	**argv;
d449 1
a449 3
db_write_anim(fop, anp)
FILE *fop;
struct animate *anp;
@


11.26
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.25 2001/03/31 01:57:06 morrison Exp $ (BRL)";
d62 1
a62 1
		if( rt_g.debug&DEBUG_ANIM )
d67 1
a67 1
		if( rt_g.debug&DEBUG_ANIM )
d110 1
a110 1
	if( rt_g.debug&DEBUG_ANIM )
d112 1
a112 1
	if( rt_g.debug&DEBUG_ANIM && !materp )  bu_log("(null materp) ");
d116 1
a116 1
		if( rt_g.debug&DEBUG_ANIM )  {
d121 1
a121 1
			if( rt_g.debug&DEBUG_ANIM_FULL )  {
d150 1
a150 1
		if( rt_g.debug&DEBUG_ANIM_FULL )  {
d156 1
a156 1
		if( rt_g.debug&DEBUG_ANIM )
d185 1
a185 1
		if( rt_g.debug&DEBUG_ANIM )
d206 1
a206 1
		if( rt_g.debug&DEBUG_ANIM )
d217 1
a217 1
		if( rt_g.debug&DEBUG_ANIM )
d470 1
a470 1
	if ( rt_g.debug&DEBUG_ANIM) {
@


11.25
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.24 2000/10/18 18:10:34 butler Exp $ (BRL)";
d128 1
a128 1
			bn_mat_copy( stack, anp->an_u.anu_m.anm_mat );
d131 1
a131 1
			bn_mat_copy( arc, anp->an_u.anu_m.anm_mat );
d134 1
a134 1
			bn_mat_copy( stack, anp->an_u.anu_m.anm_mat );
d140 1
a140 1
			bn_mat_copy( arc, temp );
d145 1
a145 1
			bn_mat_copy( arc, temp );
@


11.24
log
@Patches for compiling under RedHat 7.0
@
text
@d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.23 2000/09/09 04:30:46 mike Exp $ (BRL)";
d135 1
a135 1
			bn_mat_idn( arc );
d338 1
a338 1
		    	bn_mat_idn( anp->an_u.anu_m.anm_mat );
d349 1
a349 1
		    	bn_mat_idn( anp->an_u.anu_m.anm_mat );
d367 1
a367 1
		    	bn_mat_idn( anp->an_u.anu_m.anm_mat );
@


11.23
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.22 2000/07/25 16:46:06 butler Exp $ (BRL)";
d25 3
@


11.22
log
@Fixed bad practice in db5_update_ident definition: implicit int return
@
text
@d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.21 2000/07/11 23:16:46 mike Exp $ (BRL)";
d305 1
a305 1
	db_init_db_tree_state( &ts, dbip );
@


11.21
log
@
Added externs for new routines in librt/db_*.c
@
text
@d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.20 2000/07/10 23:01:27 mike Exp $ (BRL)";
d296 1
a296 1
CONST char	**argv;
d435 3
a437 5
int
db_parse_anim( dbip, argc, argv )
struct db_i	*dbip;
int		argc;
CONST char		**argv;
@


11.20
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d19 1
a19 1
static const char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.19 2000/04/12 02:15:12 mike Exp $ (BRL)";
d228 1
a228 2
db_free_1anim( anp )
struct animate		*anp;
@


11.19
log
@
NT port
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.18 2000/02/08 04:56:32 mike Exp $ (BRL)";
@


11.18
log
@
Added "anim scale" command.
For documentation see tabsub.1 man page
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.17 2000/01/22 01:23:05 mike Exp $ (BRL)";
d196 1
a196 1
		    (((double)anp->an_u.anu_c.anc_rgb[0])+0.5)*bn_inv255;
d198 1
a198 1
		    (((double)anp->an_u.anu_c.anc_rgb[1])+0.5)*bn_inv255;
d200 1
a200 1
		    (((double)anp->an_u.anu_c.anc_rgb[2])+0.5)*bn_inv255;
@


11.17
log
@
Added code to check for material-property animations specified
*below* the region in the DAG, and provide a useful error message.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.16 2000/01/19 23:56:59 mike Exp $ (BRL)";
d352 15
@


11.16
log
@
Now, in addition to being able to provide the full 4x4 matrix
as an argument to the "anim ... matrix" command, there is the
new special case keyword "scale_about", which looks like this:

anim ellipse.r/ellipse.s matrix rarc
        scale_about 16.1309 46.6556 -3.72252    0.2;
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.15 1999/12/22 02:17:58 mike Exp $ (BRL)";
d94 3
d109 1
d159 6
a164 1
		if (!materp) break;
d188 6
a193 1
		if (!materp) break;
d205 6
a210 1
		if( !materp )  break;
@


11.15
log
@
Eliminated dead vars
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.14 1999/11/24 21:44:29 mike Exp $ (BRL)";
d333 19
d387 1
d390 2
a391 1
	db_free_1anim( anp );
@


11.14
log
@
Removed includes of compat header files rtstring.h and rtlist.h
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.13 1999/05/10 21:30:47 mike Exp $ (BRL)";
a282 1
	int	at_root = 0;
a386 1
	struct db_tree_state	ts;
a387 1
	int	i;
@


11.13
log
@Variable name changed from ma_override to ma_color_valid
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.12 1998/12/17 04:19:09 mike Exp $ (BRL)";
d28 1
a28 1
#include "rtstring.h"
@


11.12
log
@Regions now have an associated temperature
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_anim.c,v 11.11 1997/12/23 06:01:44 mike Exp $ (BRL)";
d180 1
a180 1
		materp->ma_override = 1;	/* XXX - really override? */
@


11.11
log
@Changed to use db_init_db_tree_state().
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 11.10 1997/12/16 06:09:11 mike Exp mike $ (BRL)";
d188 6
d361 4
@


11.10
log
@Ran h/sed4
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 11.9 1996/12/04 02:50:27 mike Exp mike $ (BRL)";
d282 1
a282 3
	bzero( (char *)&ts, sizeof(ts) );
	ts.ts_dbip = dbip;
	bn_mat_idn( ts.ts_mat );
@


11.9
log
@Combined ma_matname and ma_matparm into a single string, ma_shader.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 11.8 1996/10/19 06:17:45 mike Exp mike $ (BRL)";
d115 2
a116 2
				mat_print("on original arc", arc);
				mat_print("on original stack", stack);
d121 1
a121 1
			mat_copy( stack, anp->an_u.anu_m.anm_mat );
d124 1
a124 1
			mat_copy( arc, anp->an_u.anu_m.anm_mat );
d127 2
a128 2
			mat_copy( stack, anp->an_u.anu_m.anm_mat );
			mat_idn( arc );
d132 2
a133 2
			mat_mul( temp, anp->an_u.anu_m.anm_mat, arc );
			mat_copy( arc, temp );
d137 2
a138 2
			mat_mul( temp, arc, anp->an_u.anu_m.anm_mat );
			mat_copy( arc, temp );
d144 2
a145 2
			mat_print("arc result", arc);
			mat_print("stack result", stack);
d215 1
a215 1
	rt_free( (char *)anp, "animate");
d284 1
a284 1
	mat_idn( ts.ts_mat );
d314 1
a314 1
		    	mat_idn( anp->an_u.anu_m.anm_mat );
d325 2
a326 2
		    	mat_idn( anp->an_u.anu_m.anm_mat );
			mat_angles( anp->an_u.anu_m.anm_mat,
d415 1
a415 1
	rt_free(thepath, "path string");
@


11.8
log
@Changed to reflect that ma_matparm is now a pointer, not an array.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 11.7 1996/09/27 08:27:30 mike Exp mike $ (BRL)";
d156 4
a159 11
		if ((anp->an_u.anu_p.anp_op == RT_ANP_RBOTH) ||
		    (anp->an_u.anu_p.anp_op == RT_ANP_RMATERIAL)) {
		    	if( materp->ma_matname ) bu_free( (genptr_t)materp->ma_matname, "ma_matname" );
			materp->ma_matname = bu_vls_strdup(&anp->an_u.anu_p.anp_matname);
		}
		if ((anp->an_u.anu_p.anp_op == RT_ANP_RBOTH) ||
		    (anp->an_u.anu_p.anp_op == RT_ANP_RPARAM)) {
		    	if( materp->ma_matparm )  bu_free( (genptr_t)materp->ma_matparm, "ma_matparm" );
		    	materp->ma_matparm = bu_vls_strdup(&anp->an_u.anu_p.anp_matparam);
		}
		if (anp->an_u.anu_p.anp_op == RT_ANP_APPEND) {
d163 5
a167 4
			bu_vls_strcpy( &str, materp->ma_matparm );
			bu_vls_vlscat( &str, &anp->an_u.anu_p.anp_matparam );
		    	if( materp->ma_matparm )  bu_free( (genptr_t)materp->ma_matparm, "ma_matparm" );
			materp->ma_matparm = bu_vls_strgrab( &str );
d169 2
a170 1
		}
d210 1
a210 2
		bu_vls_free( &anp->an_u.anu_p.anp_matname );
		bu_vls_free( &anp->an_u.anu_p.anp_matparam );
d337 4
a340 12
		bu_vls_init( &anp->an_u.anu_p.anp_matname );
		bu_vls_init( &anp->an_u.anu_p.anp_matparam );
		if( strcmp( argv[3], "rboth" ) == 0 )  {
			bu_vls_strcpy( &anp->an_u.anu_p.anp_matname, argv[4] );
			bu_vls_from_argv( &anp->an_u.anu_p.anp_matparam,
				argc-5, (char **)&argv[5] );
			anp->an_u.anu_p.anp_op = RT_ANP_RBOTH;
		} else if( strcmp( argv[3], "rmaterial" ) == 0 )  {
			bu_vls_strcpy( &anp->an_u.anu_p.anp_matname, argv[4] );
			anp->an_u.anu_p.anp_op = RT_ANP_RMATERIAL;
		} else if( strcmp( argv[3], "rparam" ) == 0 )  {
			bu_vls_from_argv( &anp->an_u.anu_p.anp_matparam,
d342 1
a342 1
			anp->an_u.anu_p.anp_op = RT_ANP_RPARAM;
d344 1
a344 1
			bu_vls_from_argv( &anp->an_u.anu_p.anp_matparam,
d450 2
a451 8
		case RT_ANP_RBOTH:
			fputs("rboth ", fop);
			break;
		case RT_ANP_RMATERIAL:
			fputs("rmaterial ", fop);
			break;
		case RT_ANP_RPARAM:
			fputs("rparam ", fop);
@


11.7
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 11.6 1996/07/10 20:20:31 jra Exp mike $ (BRL)";
d158 2
a159 3
			strncpy(materp->ma_matname,
			    bu_vls_addr(&anp->an_u.anu_p.anp_matname), 32);
			materp->ma_matname[31] = '\0';
d163 2
a164 3
			strncpy(materp->ma_matparm,
			    bu_vls_addr(&anp->an_u.anu_p.anp_matparam), 60);
			materp->ma_matparm[59] = '\0';
d167 8
a174 4
			strncat(materp->ma_matparm,
			    bu_vls_addr(&anp->an_u.anu_p.anp_matparam),
			    60-strlen(materp->ma_matparm));
			materp->ma_matparm[59] = '\0';
@


11.6
log
@FIxed a declaration problem for IRIX 6.2
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 11.5 1995/09/18 21:54:05 cjohnson Exp jra $ (BRL)";
d60 1
a60 1
			rt_log("db_add_anim(x%x) root\n", anp);
d65 1
a65 1
			rt_log("db_add_anim(x%x) arc %s\n", anp,
d105 1
a105 1
		rt_log("db_do_anim(x%x) ", anp);
d112 1
a112 1
			rt_log("matrix, op=%s (%d)\n",
d150 1
a150 1
			rt_log("property\n");
d159 1
a159 1
			    rt_vls_addr(&anp->an_u.anu_p.anp_matname), 32);
d165 1
a165 1
			    rt_vls_addr(&anp->an_u.anu_p.anp_matparam), 60);
d170 1
a170 1
			    rt_vls_addr(&anp->an_u.anu_p.anp_matparam),
d177 1
a177 1
			rt_log("color\n");
d185 1
a185 1
		    (((double)anp->an_u.anu_c.anc_rgb[0])+0.5)*rt_inv255;
d187 1
a187 1
		    (((double)anp->an_u.anu_c.anc_rgb[1])+0.5)*rt_inv255;
d189 1
a189 1
		    (((double)anp->an_u.anu_c.anc_rgb[2])+0.5)*rt_inv255;
d193 1
a193 1
			rt_log("unknown op\n");
d213 2
a214 2
		rt_vls_free( &anp->an_u.anu_p.anp_matname );
		rt_vls_free( &anp->an_u.anu_p.anp_matparam );
d283 1
a283 1
	GETSTRUCT( anp, animate );
d306 1
a306 1
			rt_log("db_parse_1anim:  Matrix op '%s' unknown\n",
d314 1
a314 1
		    		rt_log("db_parse_1anim:  matrix %s translate does not have enough arguments, only %d\n",
d325 1
a325 1
		    		rt_log("db_parse_1anim:  matrix %s rot does not have enough arguments, only %d\n",
d341 2
a342 2
		rt_vls_init( &anp->an_u.anu_p.anp_matname );
		rt_vls_init( &anp->an_u.anu_p.anp_matparam );
d344 2
a345 2
			rt_vls_strcpy( &anp->an_u.anu_p.anp_matname, argv[4] );
			rt_vls_from_argv( &anp->an_u.anu_p.anp_matparam,
d349 1
a349 1
			rt_vls_strcpy( &anp->an_u.anu_p.anp_matname, argv[4] );
d352 1
a352 1
			rt_vls_from_argv( &anp->an_u.anu_p.anp_matparam,
d356 1
a356 1
			rt_vls_from_argv( &anp->an_u.anu_p.anp_matparam,
d360 1
a360 1
			rt_log("db_parse_1anim:  material animation '%s' unknown\n",
d370 1
a370 1
		rt_log("db_parse_1anim:  animation type '%s' unknown\n", argv[2]);
d423 1
a423 1
		rt_log("db_write_anim: Writing %s\n", thepath);
d450 1
a450 1
			rt_log("db_write_anim: unknown matrix operation\n");
d475 1
a475 1
			rt_log("db_write_anim: unknown property operation.\n");
d486 1
a486 1
		rt_log("db_write_anim: Unknown animate type.\n");
@


11.5
log
@Parameter missmatch.  Should not have compiled, should not have
run.  Why oh why did it ever work?  Core dumps on sun IPC.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 11.4 1995/09/15 23:26:32 mike Exp cjohnson $ (BRL)";
d390 1
a390 1
char		**argv;
@


11.4
log
@Fixed structure initialization.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/db_anim.c,v 11.3 1995/03/13 19:01:40 mike Exp mike $ (BRL)";
d397 1
a397 1
	if( !(anp = db_parse_1anim( dbip, argv )) )
@


11.3
log
@Added "rot" keyword.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 11.2 95/03/11 00:05:16 mike Exp Locker: mike $ (BRL)";
d289 1
a289 2
	anp->an_path.fp_len = anp->an_path.fp_maxlen = 0;
	anp->an_path.fp_names = (struct directory **)0;
@


11.2
log
@Broke out db_parse_1anim() for use in MGED's "arced" command.
Also added "anim matrix rarc translate dx dy dz" shorthand.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 11.1 95/01/04 09:56:14 mike Rel4_4 Locker: mike $ (BRL)";
d321 11
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 10.8 94/08/10 17:50:27 gdurf Exp $ (BRL)";
d201 22
d226 2
a227 2
 * XXX really need another subroutine in common,
 * XXX which knows how to free the vls strings, etc.
d243 1
a243 2
		db_free_full_path( &anp->an_path );
		rt_free( (char *)anp, "struct animate");
d257 1
a257 2
				db_free_full_path( &anp->an_path );
				rt_free( (char *)anp, "struct animate");
d266 1
a266 1
 *			D B _ P A R S E _ A N I M
d268 3
a270 2
 *  A common parser for mged and rt.
 *  Experimental.
d272 2
a273 2
int
db_parse_anim( dbip, argc, argv )
d276 1
a276 1
char		**argv;
a285 3
	if( argv[1][0] == '/' )
		at_root = 1;

a293 3
	if( anp->an_path.fp_len > 1 )
		at_root = 0;

d307 1
a307 1
			rt_log("db_parse_anim:  Matrix op '%s' unknown\n",
d311 18
a328 2
		for( i=0; i<16; i++ )
			anp->an_u.anu_m.anm_mat[i] = atof( argv[i+4] );
d331 2
a332 2
		RT_VLS_INIT( &anp->an_u.anu_p.anp_matname );
		RT_VLS_INIT( &anp->an_u.anu_p.anp_matparam );
d336 1
a336 1
				argc-5, &argv[5] );
d343 1
a343 1
				argc-4, &argv[4] );
d347 1
a347 1
				argc-4, &argv[4] );
d350 1
a350 1
			rt_log("db_parse_anim:  material animation '%s' unknown\n",
d360 1
a360 1
		rt_log("db_parse_anim:  animation type '%s' unknown\n", argv[2]);
d363 33
d397 1
a397 1
		goto bad;
d399 1
a399 5
	return(0);
bad:
	db_free_full_path( &anp->an_path );
	rt_free( (char *)anp, "animate");
	return(-1);		/* BAD */
@


10.8
log
@Added include of conf.h
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 10.7 1994/04/05 20:45:26 cjohnson Exp gdurf $ (BRL)";
@


10.7
log
@Reformat printf to retain as many sig. digits as possible.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 10.6 1994/04/05 17:50:35 cjohnson Exp cjohnson $ (BRL)";
d21 2
@


10.6
log
@Add some debug ability
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 10.5 1994/04/05 04:22:25 cjohnson Exp cjohnson $ (BRL)";
d381 1
a381 1
			fprintf(fop, " %8.3f", anp->an_u.anu_m.anm_mat[i]);
@


10.5
log
@It returns void, NOT int.  (stupid programmer (me))
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 10.4 1994/04/05 04:14:23 cjohnson Exp cjohnson $ (BRL)";
d350 3
@


10.4
log
@Write an animate structure to a FILE *
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 10.3 1994/04/04 15:42:35 cjohnson Exp cjohnson $ (BRL)";
d339 1
a339 1
int
@


10.3
log
@Add check for null mater pointer.
Add animation code for color and materal types.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 10.2 1994/03/31 23:45:09 cjohnson Exp cjohnson $ (BRL)";
d154 2
a155 1
		if (*rt_vls_addr(&anp->an_u.anu_p.anp_matname)) {
d160 2
a161 1
		if (*rt_vls_addr(&anp->an_u.anu_p.anp_matparam)) {
d166 6
d182 6
a187 3
		materp->ma_color[0] = anp->an_u.anu_c.anc_rgb[0];
		materp->ma_color[1] = anp->an_u.anu_c.anc_rgb[1];
		materp->ma_color[2] = anp->an_u.anu_c.anc_rgb[2];
d304 1
d307 1
d311 1
d315 1
d338 77
@


10.2
log
@Add magic number setting and checking.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 10.1 1991/10/12 06:40:01 mike Rel4_0 cjohnson $ (BRL)";
d149 28
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 9.6 91/09/20 22:40:21 butler Exp $ (BRL)";
d54 1
d69 2
a70 1
	while( *headp != ANIM_NULL )
d72 1
d104 1
d176 3
a178 1
		register struct animate *nextanp = anp->an_forw;
d191 3
a193 1
				register struct animate *nextanp = anp->an_forw;
d222 1
@


9.6
log
@removing the fuzz with lint
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 9.5 91/01/25 15:47:43 mike Exp $ (BRL)";
@


9.5
log
@Changed full-matrix debug printing from #ifdef to dynamic on DEBUG_ANIM_FULL
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/db_anim.c,v 9.4 90/11/11 04:55:11 mike Exp $ (BRL)";
a50 1
	register int i;
a208 1
	struct db_full_path	path;
@


9.4
log
@added db_parse_anim, to centralize parsing for both mged and rt
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: /m/cad/librt/RCS/db_anim.c,v 9.3 90/04/12 03:48:59 mike Exp $ (BRL)";
d75 10
d105 8
a112 5
			rt_log("matrix, op=%d\n", anp->an_u.anu_m.anm_op);
#if 0
			mat_print("on original arc", arc);
			mat_print("on original stack", stack);
#endif
d138 1
a138 2
#if 0
		if( rt_g.debug&DEBUG_ANIM )  {
a141 1
#endif
@


9.3
log
@Changed names from rt_ to db_, modified to use dbip rather than rtip.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: db_anim.c,v 9.2 89/12/31 01:24:11 mike Locked $ (BRL)";
d26 1
a26 1
#include "db.h"
d50 1
a54 4
	for( i=0; i < anp->an_pathlen; i++ )
		if( anp->an_path[i] == DIR_NULL )
			return(-1);	/* BAD */

d61 1
d64 2
a65 2
				anp->an_path[anp->an_pathlen-1]->d_namep);
		headp = &(anp->an_path[anp->an_pathlen-1]->d_animate);
d93 1
a93 1
	case AN_MATRIX:
d132 1
a132 1
	case AN_PROPERTY:
d149 2
d164 1
a164 1
		rt_free( (char *)anp->an_path, "animation path[]");
d177 1
a177 1
				rt_free( (char *)anp->an_path, "animation path[]");
d184 93
@


9.2
log
@Added some compile-time debugging, for stuborn errors.
@
text
@d2 1
a2 1
 *			A N I M
d4 1
a4 1
 *  Ray Tracing program, routines to apply animation directives.
d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 9.1 89/05/19 05:53:45 mike Locked $ (BRL)";
d32 1
a32 1
 *			R T _ A D D _ A N I M
d41 1
a41 1
 *  references are in the right model (rtip).
d44 2
a45 2
rt_add_anim( rtip, anp, root )
struct rt_i *rtip;
d61 2
a62 2
			rt_log("rt_add_anim(x%x) root\n", anp);
		headp = &(rtip->rti_anroot);
d65 1
a65 1
			rt_log("rt_add_anim(x%x) arc %s\n", anp,
d78 1
a78 1
 *			R T _ D O _ A N I M
d84 1
a84 1
rt_do_anim( anp, stack, arc, materp )
d93 1
a93 1
		rt_log("rt_do_anim(x%x) ", anp);
d148 1
a148 1
 *			R T _ F R _ A N I M
d153 2
a154 2
rt_fr_anim( rtip )
register struct rt_i *rtip;
d161 1
a161 1
	for( anp = rtip->rti_anroot; anp != ANIM_NULL; )  {
d168 1
a168 1
	rtip->rti_anroot = ANIM_NULL;
d172 1
a172 1
		dp = rtip->rti_dbip->dbi_Head[i];
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 8.2 88/12/30 02:34:24 mike Exp $ (BRL)";
d96 1
a96 1
		if( rt_g.debug&DEBUG_ANIM )
d98 5
d127 6
@


8.2
log
@Fixed animation free stuff to match new in-core directory structure.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 8.1 88/10/05 00:30:53 mike Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 7.2 88/05/14 00:47:28 mike Exp $ (BRL)";
d147 1
d160 5
a164 3
	for( dp = rtip->rti_DirHead; dp != DIR_NULL; dp = dp->d_forw )  {
		for( anp = dp->d_animate; anp != ANIM_NULL; )  {
			register struct animate *nextanp = anp->an_forw;
d166 5
a170 3
			rt_free( (char *)anp->an_path, "animation path[]");
			rt_free( (char *)anp, "struct animate");
			anp = nextanp;
a171 1
		dp->d_animate = ANIM_NULL;
@


7.2
log
@lint fixes
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 7.1 87/11/02 23:32:35 mike Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 6.4 87/10/14 21:19:59 mike Exp $ (BRL)";
d141 1
@


6.4
log
@Added "at_root" arg to rt_add_anim
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 6.3 87/10/14 21:10:17 mike Locked $ (BRL)";
@


6.3
log
@re-fixed rooted specification.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 6.2 87/09/26 07:50:25 mike Locked $ (BRL)";
d36 2
a37 2
 *  the path specifier.  A pathlen of 0 indicates that this change is
 *  to affect the root of the tree itself, rather than an arc, and is
d44 1
a44 1
rt_add_anim( rtip, anp )
d47 1
d59 1
a59 1
	if( anp->an_pathlen <= 0 )  {
d61 1
a61 1
			rt_log("rt_add_anim(x%x) ROOT\n", anp);
d65 1
a65 1
			rt_log("rt_add_anim(x%x) leaf %s\n", anp,
@


6.2
log
@Added debugging, and corrected ROOT node case.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 6.1 87/07/11 07:55:07 mike Locked $ (BRL)";
d36 1
a36 1
 *  the path specifier.  A pathlen of 1 indicates that this change is
d58 1
a58 1
	if( anp->an_pathlen <= 1 )  {
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 5.1 87/06/24 22:10:38 mike Rel $ (BRL)";
d36 1
a36 1
 *  the path specifier.  A pathlen of 0 indicates that this change is
d58 3
a60 1
	if( anp->an_pathlen < 1 )
d62 4
a65 1
	else
d67 1
d91 2
d95 2
a96 1
/*rt_log("rt_do_anim(x%x), matrix, op=%d\n", anp, anp->an_u.anu_m.anm_op);*/
d123 2
d127 2
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 1.4 87/03/23 23:42:45 mike Exp $ (BRL)";
@


1.4
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 1.3 87/03/19 05:05:25 mike Exp $ (BRL)";
@


1.3
log
@Added code for rt_clean
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 1.2 87/03/19 03:02:33 mike Exp $ (BRL)";
d87 1
d131 1
d133 1
d142 12
@


1.2
log
@Removed debug prints
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header: anim.c,v 1.1 87/03/11 01:30:15 mike Locked $ (BRL)";
d119 20
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSanim[] = "@@(#)$Header$ (BRL)";
a52 2
rt_log("rt_add_anim(x%x) x%x, len=%d\n", anp, anp->an_path[0], anp->an_pathlen);
rt_log("lvl 0 = %s\n", anp->an_path[0]->d_namep);
a84 1
rt_log("rt_do_anim(x%x) type=%d\n", anp, anp->an_type);
@
