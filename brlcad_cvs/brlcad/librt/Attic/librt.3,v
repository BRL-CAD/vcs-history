head	11.10;
access;
symbols
	ansi-20040405-merged:11.7.4.1
	postmerge-20040405-ansi:11.9
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.8.6.1
	premerge-autoconf:11.9
	ansi-20040316-freeze:11.7
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.7.6.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.6
	phong-branch:11.8.0.4
	photonmap-branch:11.8.0.2
	rel-6-1-DP:11.7
	windows-branch:11.7.0.6
	rel-6-0-2:11.7
	ansi-branch:11.7.0.4
	rel-6-0-1-branch:11.7.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.7
	rel-6-0-1:11.7
	rel-6-0:11.7
	rel-5-4:11.5
	offsite-5-3-pre:11.5
	rel-5-3:11.5
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:1.5
	rel-1-10:1.4;
locks; strict;


11.10
date	2004.05.21.18.07.32;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.02.02.17.39.22;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2003.01.07.13.43.00;	author jra;	state Exp;
branches
	11.8.6.1;
next	11.7;

11.7
date	2001.04.02.21.38.09;	author morrison;	state Exp;
branches
	11.7.4.1
	11.7.6.1;
next	11.6;

11.6
date	2001.03.31.01.57.10;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2000.02.11.21.46.09;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.12.06.17.30.56;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	95.10.23.18.39.05;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	95.10.23.18.33.49;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.14;	author mike;	state Rel4_4;
branches;
next	10.1;

10.1
date	91.10.12.06.40.32;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.07.18.00.19.46;	author butler;	state Exp;
branches;
next	9.3;

9.3
date	91.07.11.17.35.36;	author butler;	state Exp;
branches;
next	9.2;

9.2
date	90.05.30.10.09.32;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.40;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.31.19;	author mike;	state Rel3_0;
branches;
next	7.7;

7.7
date	88.09.02.15.22.24;	author phil;	state Exp;
branches;
next	7.6;

7.6
date	88.08.29.13.46.22;	author steveb;	state Exp;
branches;
next	7.5;

7.5
date	88.01.12.03.47.41;	author gwyn;	state Exp;
branches;
next	7.4;

7.4
date	87.12.05.16.26.32;	author gwyn;	state Exp;
branches;
next	7.3;

7.3
date	87.12.01.11.42.42;	author gwyn;	state Exp;
branches;
next	7.2;

7.2
date	87.12.01.10.50.42;	author gwyn;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.33.35;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.55.53;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.11.36;	author mike;	state Rel;
branches;
next	1.6;

1.6
date	87.03.23.23.36.15;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	87.02.12.22.11.21;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.12.19.02.54.43;	author phil;	state Exp;
branches;
next	1.3;

1.3
date	86.11.07.03.37.37;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.11.07.02.48.36;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.08.12.07.04.44;	author mike;	state Exp;
branches;
next	;

11.7.4.1
date	2004.03.17.21.18.48;	author morrison;	state Exp;
branches;
next	;

11.7.6.1
date	2004.03.11.23.43.40;	author morrison;	state Exp;
branches;
next	;

11.8.6.1
date	2004.02.12.18.37.42;	author erikg;	state Exp;
branches;
next	;


desc
@Manual page for RT library
@


11.10
log
@moved to src/
@
text
@.TH LIBRT 3 BRL-CAD
.SH NAME
librt \- library for raytracing an MGED database
.SH SYNOPSIS
.nf
\fB#include "machine.h"
\fB#include "vmath.h"
\fB#include "raytrace.h"
.sp
extern struct rt_functab rt_functab[\|];
extern struct rt_g rt_g;
.sp
struct rt_i *rt_dirbuild( mged_file_name, buf, len )
char *mged_file_name;
char *buf;
int len;
.sp
int rt_gettree( rtip, object_name )
struct rt_i *rtip;
char *object_name;
.sp
void rt_prep( rtip )
struct rt_i *rtip;
.sp
int rt_shootray( ap )
struct application *ap;
.sp
void rt_prep_timer(\|)
.sp
double rt_read_timer( buf, len )
char *buf;
int len;
.sp
void rt_pr_partitions( rtip, phead, title )
struct rt_i *rtip
struct partition *phead;
char *title;
.sp
void rt_pr_seg( segp );
struct seg *segp;
.sp
void rt_bomb( msg )
char *msg;
.sp
void rt_log( fmt, ...\& )
char *fmt;
.sp
char *rt_malloc(cnt, str)
unsigned int cnt;
char *str;
.sp
void rt_free(ptr, str)
char *ptr;
char *str;
.sp
char *rt_realloc(ptr, cnt, str)
register char   *ptr;
unsigned int    cnt;
char      *str;
.sp
char *rt_calloc( nelem, elsize, str )
unsigned int    nelem;
unsigned int    elsize;
char      *str;
.sp
void rt_prmem(str)
char *str;
.sp
char *rt_strdup( cp )
char *cp;
.sp
struct soltab *rt_find_solid(\|)
.sp
void MAT_ZERO( m )			/* fill matrix m with zeros */
matp_t m;
.sp
void MAT_IDN( m )			/* fill matrix m with identity matrix */
matp_t m;
.sp
void MAT_COPY( o, i )		/* copy matrix i to matrix o */
matp_t o, i;
.sp
void mat_mul( o, i1, i2 )		/* multiply i1 by i2 and store in o */
matp_t o, i1, i2;
.sp
void matXvec( ov, m, iv )		/* multiply m by vector iv, store in ov */
matp_t ov, m, iv;
.sp
void mat_inv( o, i )			/* invert matrix i, store result in o */
matp_t o, i;
.sp
void mat_print( title, m )		/* print matrix m, (with title) on stdout */
char *title;
matp_t m;
.sp
void mat_trn( o, i )			/* transpose matrix i into matrix o */
matp_t o, i;
.sp
void mat_ae( o, a, e )		/* rotation matrix o from azimuth+elevation */
matp_t o;
double a, e;
.sp
void mat_angles( o, a, b, g )	/* rotation matrix o from angles a, b, g */
matp_t o;
double a, b, g;
.sp
void vtoh_move( v, h )		/* homogeneous vector from ordinary vector */
vectp_t v, h;
.sp
void htov_move( h, v )		/* ordinary vector from homogeneous vector */
vectp_t h, v;
.sp
.SH DESCRIPTION
.I rt_dirbuild\^
opens
.I mged_file_name
and builds a directory for quick lookup of objects.
.I rt_dirbuild\^
returns a pointer to a
.I "struct rt_i"
on success (often called ``\fIrtip\fP''),
or
.I RTI_NULL
on failure (such as being unable to open the named database).
This pointer must be saved, as it is a required parameter to
.IR rt_gettree .
The user-supplied buffer
.I buf\^
is filled with up to
.I len
characters
of information from the first title record in the database.
If it is desired for ``air'' objects to be reported as ``hits''
during ray-tracing, then the
.I useair
member of the
.I "struct rt_i"
must be set before the first call to
.IR rt_gettree .
.P
All objects (groups and regions) which are to be included in the description
to be raytraced must be preprocessed with
.IR rt_gettree ,
which returns \-1 for failure and 0 for success.
This function can be called as many times as required.
Be certain to pass the
.I "struct rt_i"
pointer from
.I rt_dirbuild\^
each time.
.P
After the last
.I rt_gettree
call,
.I rt_prep
can be called to complete the preparation of internal data structures.
If
.I rt_prep
is not explicitly called, it will be indirectly invoked by the first use of
.IR rt_shootray .
.P
To fire a ray at the model, an
.I application
structure must be
prepared and its address passed to
.IR rt_shootray .
Note that it is mandatory that you provide values for
.I a_ray.r_pt
(the starting point of the ray to be fired),
.I a_ray.r_dir
(a unit-length direction vector),
.I a_hit
(address of user-supplied hit routine),
.I a_miss
(address of user-supplied miss routine),
.I a_overlap
(address of user-supplied overlap routine; may be null),
.I a_rt_i
(\fIstruct rt_i\fP pointer, from
.IR rt_dirbuild ),
.I a_onehit
(flag controlling stop after first hit),
.I a_level\^
(recursion level, just for diagnostic printing),
and
.I a_resource
(address of
.I resource
structure; may be null).
.P
To obtain a report of CPU usage for a portion or portions of your program,
frame the statements with calls to
.I rt_prep_timer
and
.IR rt_read_timer .
Each call to
.I rt_prep_timer
resets the timing process, after which
.I rt_read_timer
can be called to get
a double which is the elapsed CPU time in seconds since
.I rt_prep_timer
was last called.
In addition, up to
.I len
bytes of
system-specific detailing of resource consumption
is placed in the user-supplied buffer
.IR buf .
.P
.I rt_bomb
can be used to exit your program with
.I msg
printed on the standard error output.
.SH WARNING
.I Librt
is designed to run in parallel on some multiprocessor machines.
On some such machines
system calls must be semaphore protected.  For this reason, 
.I librt
provides:
.sp
.nf
.I rt_log()
.I rt_malloc() rt_free() rt_calloc() rt_realloc() rt_prmem()
.I rt_strdup()
.fi
.P
The fuction
.I rt_log()
is essentially a semaphore-protected version of
.I printf()
except that it uses the standard error (stderr) instead of the standard
output (stdout).
.P
Dynamic memory handling in applications using
.I librt
should use
the functions provided by
.I librt
instead of the usual system runtime library
routines.  The
.I librt
versions do not return to the caller unless they succeed.  If they fail,
they call 
.I rt_bomb
with their last argument (str) as the parameter.  The string parameter
usually indicates the purpose of the memory being allocated.
.P
The fuction
.I rt_strdup()
calls rt_malloc() instead of malloc() to acquire memory.
Thus it should be used in place of strdup() in programs linking with 
.I librt.
.SH "EXIT CODE"
All truly fatal errors detected by the library use
.I rt_bomb
to exit with a status of 12.
.SH DEFINITION
RPP \- Rectangular ParallelePiped.
A region of space defined by minimum and maximum values in X, Y, and Z.
RPPs are used by
.I librt
as bounding volumes for solids.
.SH DISCUSSION
You should study the structures in
.IR raytrace.h ,
in particular, the
.I application
structure,
the
.I partition
structure and its component structures to get an idea of what information
is handed to/from
.IR rt_shootray .
.I rt_shootray
may be called recursively from your
.I a_hit
routine (good for doing bounced rays).
If you only care about the first
object hit along the path of the ray, set the
.I a_onehit 
flag in the application structure before calling
.IR rt_shootray .
.I rt_shootray
returns the return value of the user-supplied hit or miss function
that it called.
.P
If the ray intersects the model, the
.I a_hit
routine is called
with a pointer to the application structure and a pointer to a
linked list of ray partitions
(\fIstruct partition\fP).
Within each partition are
.I seg
(solid segment)
and
.I hit
(intersection with evaluated region)
structure pointers
for the places where the ray enters and leaves this partition of space.
.I pt_inhit.hit_dist
is the parametric distance at which the ray enters
the partition, and
.I pt_outhit.hit_dist
is the parametric distance at which the ray leaves.
Note that while the
.I hit
structure contains
.I hit_point
and
.I hit_norm
elements, they are not computed by
.IR rt_shootray .
If these are needed, they can be filled in by using the
.I RT_HIT_NORM\^
macro;
if surface curvature information is needed,
it can be obtained by using the
.I RT_CURVE\^
macro after
.IR RT_HIT_NORM ;
if only the
.I hit_point
is needed,
it can be filled in by using the
.I VJOIN1\^
macro (see the following example).
.P
If the ray contains any overlaps
(partitions claimed by two or more regions) the
.I a_overlap
routine is called for each such partition
with pointers to the application structure,
the overlap partition,
two regions,
and the remaining partitions along the ray.
If the
.I a_overlap
member is null,
.I librt
uses a default overlap handler.
Additionally,
.I librt
provides the routine
.I rt_overlap_quietly
which behaves exactly as the default handler,
excepting that it produces no warning messages on standard error.
.P
If the ray does not intersect the model, the
.I a_miss
routine is called
with a pointer to the application structure.
.P
Helpful in generating a grid of ray origins, the bounding RPP of the
model is computed by
.I rt_gettree
and is stored in
.I rtip\->mdl_min
and
.IR rtip\->mdl_max .
.SH EXAMPLE
.PP
A program can be loaded as follows:
.sp
$ \|\fIcc \|\-I/usr/brlcad/include \|main.c \|/usr/brlcad/lib/librt.a \|\-l<system-specific> \|\-lm\fP
.sp
where
.I <system-specific>
indicates libraries required on a particluar architecture.  The table below
indicates which system specific libraries are necesary on a particular
architecture.
.PP
     Architecture             Librarie(s)
     Alliant FX/8             -lcvec -lcommon
     Alliant FX/2800          -lcommon
     SGI 4D                   -lmpc
     Cray(X/Y)                -L/lib/multi -lu -lio
     Cray2                    -lmt
     Encore Multi-Max         -lpp
.sp 
Here is a portion of a hypothetical program which uses the library:
.RS
.sp
.nf
#include <machine.h>
#include <vmath.h>
#include <raytrace.h>
main( argc, argv )
int argc;
char *argv[\|];
{
	extern int optind;			/* Used by getopt(3C) */
	static int do_if_hit(\|), do_if_miss(\|);	/* Application routines */
	register int h, v;
	int grid_sz;
	struct application ap;		/* Set up for rt_shootray(\|) */
	struct rt_i *rtip;
	/* \s+2...\s0\& */

	/* Build the directory.	*/
	rtip = rt_dirbuild( argv[optind++] );

	/* Load the desired portion of the model. */
	while( argv[optind] != NULL )
		rt_gettree( rtip, argv[optind++] );

	ap.a_hit = do_if_hit;		/* Supply routine for hit */
	ap.a_miss = do_if_missed;	/* Supply routine for miss */
	ap.a_overlap = 0;
	ap.a_rt_i = rtip;
	ap.a_level = 0;
	ap.a_onehit = 0;		/* Return all objects along ray */
	ap.a_resource = 0;

	for( v = 0; v < grid_sz; ++v )	/* For each scanline */
		for( h = 0; h < grid_sz; ++h )  {
			/* Set up ray origin. */
			VMOVE( ap.a_ray.r_pt, get_grid( h, v ) );
			/* Compute ray direction. */
			VMOVE( ap.a_ray.r_dir, get_dir( h, v ) );
			/* Must be unit vector. */
			VUNITIZE( ap.a_ray.r_dir );
			(void) rt_shootray( &ap );
		}
	/* \s+2...\s0\& */
}

static int
do_if_hit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	extern void put_component();
	struct curvature incurv;
	register struct partition *pp;

	for( pp = PartHeadp\->pt_forw; pp != PartHeadp; pp = pp\->pt_forw )  {

		/* Fill in all inhit info, but just the exit location for outhit. */
		RT_HIT_NORM( pp\->pt_inhit, pp\->pt_inseg\->seg_stp, &ap\->a_ray );
		RT_CURVE( &incurv, pp\->pt_inhit, pp\->pt_inseg\->seg_stp );
		VJOIN1( pp\->pt_outhit\->hit_point, ap\->a_ray.r_pt,
				pp\->pt_outhit\->hit_dist, ap\->a_ray.r_dir );

		/* Check for flipped normal and fix (if you intend to use it). */
		if( pp\->pt_inflip )  {
			VREVERSE( pp\->pt_inhit\->hit_normal,
					pp\->pt_inhit\->hit_normal );
			pp\->pt_inflip = 0;
		}

		/* Do something based on information in partition structure
		 *	such as output a shotline component data record.
		 */
		put_component( pp\->pt_inhit, &incurv, pp\->pt_outhit );
		/* \s+2...\s0\& */
	}
	return	1;			/* Report hit to main routine */
}

static int
do_if_missed( ap )
register struct application *ap;
{
	return	0;			/* Report miss to main routine */
}
.RE
.sp
.SH "SEE ALSO"
mged(1B), rt(1B).
.SH DIAGNOSTICS
``rt_malloc: malloc failure'',
if
.I librt
is unable to allocate memory with
.IR malloc .
``rt_\fI???\fP: read error'', if an error or EOF occurs while
reading from the model database.
``unexpected SIGFPE!'' when a floating point error occurs.
(The rootfinder traps SIGFPE, but SIGFPE elsewhere is unexpected.)
``rt_shootray: zero length dir vector'' when the
.I a_ray.r_dir
vector is not unit length.
``rt_gettree called again after rt_prep!'' when an attempt is made
to add more sub-trees to the active model after calling
.I rt_prep
(or after firing the first ray).
``rt_prep: re-invocation'' when
.I rt_prep
is called more than once.
``rt_prep: no solids to prep'' when there are no valid solids
in the model.
.SH AUTHOR(S)
Michael John Muuss
.SH BUGS
On a VAX, the rootfinder detects ``hard'' cases by taking a SIGFPE
and retrying
with a slower but more stable algorithm.
This is unfortunate.
.SH SOURCE
 SECAD/VLD Computing Consortium, Bldg 394
 The U. S. Army Ballistic Research Laboratory
 Aberdeen Proving Ground, Maryland  21005
.SH COPYRIGHT
This software is Copyright (C) 1985-2004 by the United States Army.
All rights reserved.
.SH "BUG REPORTS"
Reports of bugs or problems should be submitted via electronic
mail to <CAD@@ARL.ARMY.MIL>.
@


11.9
log
@update copyright to include span through 2003
@
text
@@


11.8
log
@Corrected email address
@
text
@d507 1
a507 1
This software is Copyright (C) 1985 by the United States Army.
@


11.8.6.1
log
@merge from HEAD
@
text
@d507 1
a507 1
This software is Copyright (C) 1985-2004 by the United States Army.
@


11.7
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d511 1
a511 1
mail to <CAD@@ARL.MIL>.
@


11.7.4.1
log
@sync branch with HEAD
@
text
@d507 1
a507 1
This software is Copyright (C) 1985-2004 by the United States Army.
d511 1
a511 1
mail to <CAD@@ARL.ARMY.MIL>.
@


11.7.6.1
log
@sync to HEAD...
@
text
@d507 1
a507 1
This software is Copyright (C) 1985-2004 by the United States Army.
d511 1
a511 1
mail to <CAD@@ARL.ARMY.MIL>.
@


11.6
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d80 1
a80 1
void mat_copy( o, i )		/* copy matrix i to matrix o */
@


11.5
log
@
Fixed E-mail addr
@
text
@d74 1
a74 1
void mat_zero( m )			/* fill matrix m with zeros */
d77 1
a77 1
void mat_idn( m )			/* fill matrix m with identity matrix */
@


11.4
log
@Added paragraph about overlap callbacks
@
text
@d1 1
a1 1
.TH LIBRT 3 BRL/CAD
d511 1
a511 1
mail to <CAD@@BRL.MIL>.
@


11.3
log
@Added sentence about if_miss
@
text
@d236 6
a241 2
Dynamic memory handling in applications using librt should use
the functions provided by librt instead of the usual system runtime library
d330 20
@


11.2
log
@Fixed example which included an a_miss routine
that expected the application AND a partition list
@
text
@d327 5
@


11.1
log
@Release_4.4
@
text
@d435 1
a435 1
do_if_miss( ap, PartHeadp )
a436 1
struct partition *PartHeadp;
@


10.1
log
@Release_4.0
@
text
@@


9.4
log
@added functions from storage.c and reasons for them and rt_log
@
text
@@


9.3
log
@added table of other libraries needed with librt for various architectures.
@
text
@d48 24
d215 36
a250 6
.I rt_log
is called with
.IR printf -like
arguments to print an error message without terminating.
If this default behavior is inappropriate,
these functions can be preempted by versions provided by the application.
@


9.2
log
@Modified for /usr/brlcad
@
text
@d281 1
a281 1
.RS
d284 1
a284 1
$ \|\fIcc \|\-I/usr/brlcad/include \|main.c \|/usr/brlcad/lib/librt.a \|\-lm\fP
d286 14
d301 1
@


9.1
log
@Release_3.5
@
text
@d284 1
a284 1
$ \|\fIcc \|\-I/usr/include/brlcad \|main.c \|/usr/brl/lib/librt.a \|\-lm\fP
d401 2
a402 1
The rootfinder detects ``hard'' cases by taking a SIGFPE and retrying
@


8.1
log
@Release_3.0
@
text
@@


7.7
log
@BRL.MIL
@
text
@@


7.6
log
@*** empty log message ***
@
text
@d413 1
a413 1
mail to <CAD@@BRL.ARPA>.
@


7.5
log
@Added info about curvature and revised example.
@
text
@d34 2
a35 1
void rt_pr_partitions( phead, title )
@


7.4
log
@Added info about useair.
@
text
@d162 3
a164 1
(address of resource structure; may be null).
d227 2
a228 1
returns the return value of the last user-supplied hit or miss function called.
d234 1
a234 2
linked list of ray
.I partitions
d237 2
a238 1
.I segment
d241 1
d259 11
d296 1
a296 1
	extern int do_if_hit(\|), do_if_miss(\|);	/* Application routines */
d299 1
a299 1
	struct application ap;			/* Set up for rt_shootray(\|) */
d301 1
a301 1
	/* ...\& */
d315 1
a315 1
	ap.a_onehit = 1;		/* Return only closest object hit */
a318 1
	    )
d328 1
a328 1
	/* ...\& */
d336 3
a338 1
	register struct partition	*pp = PartHeadp\->pt_forw;
d340 1
a340 2
	RT_HIT_NORM( pp\->pt_inhit, pp\->pt_inseg\->seg_stp, &ap\->a_ray );
	RT_HIT_NORM( pp\->pt_outhit, pp\->pt_outseg\->seg_stp, &ap\->a_ray );
d342 18
a359 4
	/* Check for flipped normal and fix (if you intend to use it). */
	if( pp\->pt_inflip )  {
		VREVERSE( pp\->pt_inhit\->hit_normal, pp\->pt_inhit\->hit_normal );
		pp\->pt_inflip = 0;
d361 1
a361 11
	if( pp\->pt_outflip )  {
		VREVERSE( pp\->pt_outhit\->hit_normal, pp\->pt_outhit\->hit_normal );
		pp\->pt_outflip = 0;
	}

	/* Do something based on information in partition structure
	 *	such as output a pixel to the frame buffer.
	 */
	light_model( pp\->pt_inhit );
	/* ...\& */
	return	1;	/* Report hit to main routine */
d369 1
a369 1
	return	0;	/* Report miss to main routine */
@


7.3
log
@*** empty log message ***
@
text
@d108 7
@


7.2
log
@*** empty log message ***
@
text
@d10 1
a10 1
extern struct rt_functab rt_functab[];
d28 1
a28 1
void rt_prep_timer()
d47 1
a47 1
struct soltab *rt_find_solid( )
d49 1
a49 1
void mat_zero( m )		/* fill matrix m with zeros */
d52 1
a52 1
void mat_idn( m )		/* fill matrix m with identity matrix */
d58 1
a58 1
void mat_mul( o, i1, i2 )	/* multiply i1 by i2 and store in o */
d61 1
a61 1
void matXvec( ov, m, iv )	/* multiply m by vector iv, store in ov */
d64 1
a64 1
void mat_inv( o, i )		/* invert matrix i, store result in o */
d67 1
a67 1
void mat_print( title, m )	/* print matrix m, (with title) on stdout */
d71 1
a71 1
void mat_trn( o, i )		/* transpose matrix i into matrix o */
d94 13
a106 5
returns a pointer to a struct rt_i on success (often called ``rtip''),
or RTI_NULL on failure (such as being unable to open the named database).
This rt_i pointer must be saved, as it is a required parameter to
.I rt_gettree .
The user-supplied buffer ``buf'' is filled with up to ``len'' characters
d114 5
a118 1
Be certain to pass the struct rt_i pointer from rt_dirbuild() each time.
d130 3
a132 1
To fire a ray at the model, an application structure must be
d136 17
a152 8
a_ray.r_pt (the starting point of the ray to be fired),
a_ray.r_dir (a unit-length direction vector),
a_hit (address of user-supplied hit routine),
a_miss (address of user-supplied miss routine),
a_overlap (address of user-supplied overlap routine; may be null),
a_rt_i (struct rt_i pointer, from rt_dirbuild()),
a_onehit (flag controlling stop after first hit),
a_level (recursion level, just for diagnostic printing),
d154 2
a155 1
a_resource (address of resource structure; may be null).
d170 3
a172 1
In addition, up to ``len'' bytes of
d174 2
a175 1
is placed in the user-supplied buffer ``buf''.
d183 1
a183 1
.IR printf\^ -like
d189 1
a189 1
.I rtbomb
d192 1
a192 1
RPP \- Rectangular parallelepiped.
d194 3
a196 1
RPPs are used by librt as the bounding volume for solids.
d224 25
a248 10
linked list of ray \fBpartitions\fR (struct partition).  Within each
partition are \fBsegment\fR and \fBhit\fR structure pointers
for the places that the ray enters and leaves this partition of space.
pt_inhit.hit_dist is the parametric distance at which the ray enters
the partition,
and pt_outhit.hit_dist is the parametric distance at which the ray leaves.
Note that while the \fBhit\fR structure contains hit_point
and hit_norm elements, they are not computed by rt_shootray().
If these are needed, they can be filled in by using the RT_HIT_NORM()
macro.
d257 1
a257 1
.SH EXAMPLE(S)
d263 1
a263 1
Here is a portion of a hypethetical program which uses the library:
d271 1
a271 1
char *argv[];
d274 1
a274 1
	extern int do_if_hit(), do_if_miss();	/* Application routines */
d277 1
a277 1
	struct application ap;			/* Set up for rt_shootray() */
d279 1
a279 1
	...
d285 1
a285 1
	while( argv[optind] != NULL )  {
d287 1
a287 1
	}
d296 2
a297 4
	for(	v = 0;			/* First scanline */
		v < grid_sz;		/* Check for end */
		++v			/* Next scanline */
	    )  {
d303 2
a304 1
			VUNITIZE( ap.a_ray.r_dir ); /* Must be unit vector. */
a306 1
	}
d317 4
a320 3
	RT_HIT_NORM( pp\->pt_inhit, pp\->pt_inseg\->seg_stp, &(ap\->a_ray) );
	RT_HIT_NORM( pp\->pt_outhit, pp\->pt_outseg\->seg_stp, &(ap\->a_ray) );
	/* Check for flipped normal and fix (if you intend to use it) */
d331 1
a331 1
	 *	such as output a pixel to the frame buffer
a337 1
/*ARGSUSED*/
d348 1
a348 1
mged(1B), rt(1B)
d350 6
a355 3
"rt_malloc: malloc failure",
if librt is unable to allocate memory will malloc().
"rt_XXX:  read error", if an error or EOF occurs while
d357 1
a357 1
"unexpected SIGFPE!" when a floating point error occurs.
d359 2
a360 1
"rt_shootray:  zero length dir vector" when the a_ray.r_dir
d362 3
a364 2
"rt_gettree called again after rt_prep!" when an attempt is made
to add more sub-trees to the active model after calling rt_prep
d366 4
a369 2
"rt_prep: re-invocation" when rt_prep called more than once.
"rt_prep:  no solids to prep" when there are no valid solids
d374 1
a374 1
The rootfinder detects "hard" cases by taking a SIGFPE and retrying
@


7.1
log
@Release 2.3
@
text
@d6 3
a8 2
\fB#include ``raytrace.h''
\fB#include ``vmath.h''
d22 3
d44 2
a45 2
void rt_log( msg )
char *msg;
d91 1
a91 1
.I mged_file_name\^
d103 2
a104 2
.IR rt_gettree\^ ,
which returns -1 for failure and 0 for success.
d108 10
d120 1
a120 1
.IR rt_shootray\^ .
d125 2
a126 1
a_miss (address of user-supplised miss routine),
d129 1
d131 1
a131 1
a_level (recursion level, just for diagnostic printing).
d133 1
a133 1
To obtain a report of cpu usage for a portion or portions of your program,
d144 1
a144 1
.I rt_prep_timer\^
d150 1
a150 1
.I rt_bomb\^
d152 1
a152 1
.I msg\^
d154 6
d161 3
a163 2
All truely fatal errors detected by the library use \fIrtbomb\^
\fRto exit with a status of 12.
d165 1
a165 1
RPP \- Rectangular parallel-piped.
d170 1
a170 1
.IR raytrace.h\^ ,
d172 2
a173 1
.IR application\^ ,
d175 1
a175 1
.I partition\^
d178 6
a183 5
.IR rt_shootray\^ .
.I rt_shootray\^
may be called recursively as from your
.I a_hit\^
routine (good for doing bounced rays).  If you only care about the first
d185 1
a185 1
.I a_onehit\^ 
d187 3
a189 3
.IR rt_shootray\^ .
.I rt_shootray\^
returns the return value of the user-supplied hit or miss function called.
d191 3
a193 1
If the ray intersects the model, the a_hit() routine is called
d200 1
a200 1
and pt_outhit.hit_dist is the parameteric distance the ray leaves.
d206 5
a210 5
Helpful in generation a grid of ray origins, the bounding RPP of the
model is computed as
.I rt_gettree\^
is called and stored in
.I rtip->mdl_min\^
d212 1
a212 1
.IR rtip->mdl_max\^ .
d217 1
a217 1
$ \|\fIcc \|\-I?? \|main.c \|/usr/brl/lib/librt.a \|\-lm\fP
d222 4
a225 3
#include "vmath.h"
#include "raytrace.h"
main( argc, argv )				/* m a i n ( ) */
d233 1
a233 1
	struct application ap;		/* Set up for rt_shootray() */
a240 1
	objects = &argv[optind];
d246 1
d250 1
d252 3
a254 3
	for(	v = 0;			/* First scanline.	*/
		v < grid_sz;		/* Check for end.	*/
		++v			/* Next scanline.	*/
d265 1
d273 1
a273 1
	register struct partition	*pp = PartHeadp->pt_forw;
d275 2
a276 2
	RT_HIT_NORM( pp->pt_inhit, pp->pt_inseg->seg_stp, &(ap->a_ray) );
	RT_HIT_NORM( pp->pt_outhit, pp->pt_outseg->seg_stp, &(ap->a_ray) );
d278 3
a280 3
	if( pp->pt_inflip )  {
		VREVERSE( pp->pt_inhit->hit_normal, pp->pt_inhit->hit_normal );
		pp->pt_inflip = 0;
d282 3
a284 3
	if( pp->pt_outflip )  {
		VREVERSE( pp->pt_outhit->hit_normal, pp->pt_outhit->hit_normal );
		pp->pt_outflip = 0;
d289 4
a292 4
         */
	light_model( pp->pt_inhit );
	...
	return	1; /* Report hit to main routine */
d301 1
a301 1
	return	0; /* Report miss to main routine */
d310 1
a310 1
"rt_XXX:  read error", if an error or EOF occures while
d312 3
a314 3
"unexpected SIGFPE!\n" when a floating point error occurs.
(The rootfinder traps SIGFPE, but SIGFPE elsewhere is unexpected).
"rt_shootray:  zero length dir vector\n" when the a_ray.r_dir
d325 3
a327 2
The rootfinder detects "hard" cases by taking a SIGFPE and retyring
with a slower but more stable algorithm.  This is unfortunate.
@


6.1
log
@Release 2.0
@
text
@@


5.1
log
@Release 1.24
@
text
@@


1.6
log
@Deleted obsolete function rt_viewbounds.
@
text
@@


1.5
log
@Release 1.20 -- First Formal Release
@
text
@a42 2
void rt_viewbounds( )
.sp
@


1.4
log
@removed B man suffix
@
text
@@


1.3
log
@Updated to reflect RT_HIT_NORM
@
text
@d1 1
a1 1
.TH LIBRT 3B BRL/CAD
d308 1
a308 1
mail to <GED@@BRL.ARPA>.
@


1.2
log
@Updated for new function names
(belated checkin)
@
text
@d3 1
a3 1
librt \- library for raytracing a GED database
d12 2
a13 2
struct rt_i *rt_dirbuild( ged_file_name, buf, len )
char *ged_file_name;
d89 1
a89 1
.I ged_file_name\^
d144 3
a146 2
RPP \- Rectangular parallel-piped often used as a rough estimate of a solid
object's position in 3-space.
d168 13
d247 2
d251 2
a252 2
		/* Reverse direction of surface normal */
		ScaleVec( pp->pt_inhit->hit_normal, -1.0 );
d255 2
a256 2
		/* Reverse direction of exit normal */
		ScaleVec( pp->pt_outhit->hit_normal, -1.0 );
d258 1
d262 1
a262 1
	light_model( pp->pt_inhit->hit_normal );
d282 1
a282 1
"routine:  read error", if an error or EOF occures while
d285 1
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
librt \- library for raytracing a GED file
d6 2
a7 2
\fB#include ``raytrace.h''	/* assumes /vld/include is searched */
\fB#include ``vmath.h''		/* assumes /vld/include is searched */
d9 2
a10 17
extern int ged_fd;			/* file descriptor of GED file */
extern int one_hit_flag;		/* non-zero to return first hit only */
extern int debug;			/* non-zero for debugging, bit encoded */
extern long nsolids;			/* total # of solids participating */
extern long nregions;			/* total # of regions participating */
extern long nshots;			/* # of calls to ft_shot() */
extern long nmiss_model;		/* rays missed model RPP */
extern long nmiss_tree;			/* rays missed sub-tree RPP */
extern long nmiss_solid;		/* rays missed solid RPP */
extern long nmiss;			/* solid ft_shot() returned a miss */
extern long nhits;			/* solid ft_shot() returned a hit */
extern struct seg *FreeSeg;		/* head of freelist */
extern struct functab functab[];	/* table of solid-specific functions */
extern struct soltab *HeadSolid;	/* pointer to list of solids in model */
extern struct partition *FreePart;	/* head of freelist */
extern vect_t model_min;		/* min corner of model bounding RPP */
extern vect_t model_max;		/* max corner of model bounding RPP */
d12 1
a12 1
dir_build( ged_file_name )
d14 2
d17 2
a18 1
get_tree( object_name )
d21 1
a21 1
shootray( ap )
d24 1
a24 1
void timer_prep()
d26 3
a28 2
double timer_print( msg )
char *msg;
d30 1
a30 1
void pr_partitions( phead, title )
d34 1
a34 1
void pr_seg( segp );
d37 1
a37 1
void rtbomb( msg )
d40 7
d87 1
a87 1
.I Dir_build\^
d90 9
a98 3
and builds a directory for quick lookup of objects.  The file descriptor
is kept open in the external
.IR ged_fd\^ .
d101 18
a118 4
.IR get_tree\^ .
Too fire a ray at the description, an application structure must be
filled in and its address passed to
.IR shootray\^ .
d121 1
a121 1
.I timer_prep
d123 1
a123 6
.IR timer_print .
The
.I msg
string passed to
.I timer_print
is prepended to the report for identification purposes.
d125 12
a136 3
.I timer_prep
will reset the logging process.
.I Rtbomb\^
d139 1
a139 2
appended to the string \fIrt FATAL ERROR \fRwhich is followed by a newline
and printed on the standard error output.
d141 1
a141 1
All fatal errors detected by the library use \fIrtbomb\^
d155 2
a156 2
.IR shootray\^ .
.I Shootray\^
d161 6
a166 3
.I one_hit_flag\^ 
before calling
.IR shootray\^ .
d169 1
a169 1
.I get_tree\^
d171 1
a171 1
.I model_min\^
d173 1
a173 1
.IR model_max\^ .
d178 1
a178 1
$ \|\fIcc \|\-I/vld/include \|main.c \|/vld/lib/librt.a \|\-lm\fP
d183 2
a184 3
#include <vmath.h>
#include <raytrace.h>
static int nullf() {}
d188 1
a188 1
	{
d193 2
a194 1
	structure application ap;		/* Set up for shootray() */
d198 1
a198 1
	dir_build( argv[optind++] );
d202 2
a203 4
	while( argv[optind] != NULL )
		{
		get_tree( argv[optind++] );
		}
d207 3
a209 1
	ap.a_init = ap.a_eol = ap.a_end = nullf;
a210 1
	one_hit_flag = 1;		/* Return only closest object hit */
d214 2
a215 4
		)
		{
		for( h = 0; h < grid_sz; ++h )
			{
d221 1
a221 2
			(void) shootray( &ap );
			}
d224 1
d230 1
a230 1
	{
d234 2
a235 2
	if( pp->pt_inflip )
		{ /* Reverse direction of surface normal */
d237 3
a239 3
		}
	if( pp->pt_outflip )
		{ /* Reverse direction of exit normal */
d241 1
a241 1
		}
d243 1
a243 1
		such as output a pixel to the frame buffer
d248 1
a248 1
	}
d255 1
a255 1
	{
d257 1
a257 1
	}
d261 1
a261 1
mged(1V), rt(1V)
d263 13
a275 13
.I Dir_build\^
and
.I get_tree\^
return -1 for failure and 0 for success.
.br
.I Shootray\^
returns the value of the user-supplied function passed in
the application structure.
.br
.I Timer_print\^
returns the real elapsed seconds since
.I timer_prep\^
was called.
d277 1
a277 1
Mike J. Muuss, BRL/SECAD-CSMB
d279 12
a290 2
There are instabilities with the root finder that will cause erroneous
results and verbose messages to that effect.
@
