head	11.66;
access;
symbols
	ansi-20040405-merged:11.61.2.2
	postmerge-20040405-ansi:11.64
	premerge-20040404-ansi:11.63
	postmerge-autoconf:11.63
	autoconf-freeze:11.62.4.2
	premerge-autoconf:11.63
	ansi-20040316-freeze:11.61.2.1
	postmerge-20040315-windows:11.63
	premerge-20040315-windows:11.63
	windows-20040315-freeze:11.61.4.1
	autoconf-20031203:11.62
	autoconf-20031202:11.62
	autoconf-branch:11.62.0.4
	phong-branch:11.62.0.2
	photonmap-branch:11.61.0.6
	rel-6-1-DP:11.61
	windows-branch:11.61.0.4
	rel-6-0-2:11.59
	ansi-branch:11.61.0.2
	rel-6-0-1-branch:11.59.0.2
	hartley-6-0-post:11.60
	hartley-6-0-pre:11.59
	rel-6-0-1:11.59
	rel-6-0:11.58
	rel-5-4:11.44.2.4
	offsite-5-3-pre:11.52
	rel-5-3:11.44.2.4
	rel-5-2:11.44.2.1
	rel-5-1-branch:11.44.0.2
	rel-5-1:11.44
	rel-5-0:11.23
	rel-5-0-beta:11.23
	rel-4-5:11.21
	ctj-4-5-post:11.17
	ctj-4-5-pre:11.15
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.66
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	11.65;

11.65
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.64;

11.64
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.63;

11.63
date	2004.02.02.17.39.14;	author morrison;	state Exp;
branches;
next	11.62;

11.62
date	2003.08.02.23.15.19;	author butler;	state Exp;
branches
	11.62.2.1
	11.62.4.1;
next	11.61;

11.61
date	2002.08.20.17.07.54;	author jra;	state Exp;
branches
	11.61.2.1
	11.61.4.1
	11.61.6.1;
next	11.60;

11.60
date	2002.08.15.20.55.07;	author hartley;	state Exp;
branches;
next	11.59;

11.59
date	2002.05.07.14.59.18;	author jra;	state Exp;
branches;
next	11.58;

11.58
date	2002.01.10.18.12.40;	author butler;	state Exp;
branches;
next	11.57;

11.57
date	2001.09.10.19.39.00;	author jra;	state Exp;
branches;
next	11.56;

11.56
date	2001.05.17.20.05.23;	author morrison;	state Exp;
branches;
next	11.55;

11.55
date	2001.04.20.22.29.40;	author morrison;	state Exp;
branches;
next	11.54;

11.54
date	2001.04.11.12.43.35;	author jra;	state Exp;
branches;
next	11.53;

11.53
date	2001.03.19.22.19.56;	author butler;	state Exp;
branches;
next	11.52;

11.52
date	2001.02.23.15.11.11;	author jra;	state Exp;
branches;
next	11.51;

11.51
date	2001.01.12.16.45.18;	author jra;	state Exp;
branches;
next	11.50;

11.50
date	2001.01.09.14.17.05;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	2000.10.25.21.12.08;	author mike;	state Exp;
branches;
next	11.48;

11.48
date	2000.10.24.18.38.34;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	2000.08.30.14.51.52;	author jra;	state Exp;
branches;
next	11.46;

11.46
date	2000.07.13.02.36.25;	author cjohnson;	state Exp;
branches;
next	11.45;

11.45
date	2000.07.10.23.01.25;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	2000.06.23.03.26.07;	author butler;	state Exp;
branches
	11.44.2.1;
next	11.43;

11.43
date	2000.06.02.22.46.56;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	2000.05.24.04.15.52;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	2000.05.23.03.43.49;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	2000.05.19.20.07.12;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	2000.05.19.18.02.13;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	2000.05.18.20.20.11;	author jra;	state Exp;
branches;
next	11.37;

11.37
date	2000.05.18.19.56.23;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	2000.05.18.15.48.38;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	2000.05.16.23.45.09;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	2000.03.31.18.04.07;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	2000.03.31.04.55.39;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	2000.03.28.04.06.21;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	2000.03.28.02.18.45;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	2000.03.18.01.51.50;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.02.01.20.57.27;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.01.22.04.01.39;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	99.11.13.05.12.04;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	99.11.12.20.54.17;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	99.11.11.04.18.27;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	99.10.30.03.54.00;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	99.05.27.18.52.55;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	98.03.24.08.39.25;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	98.01.22.04.54.34;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	98.01.22.04.05.23;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	98.01.09.09.18.18;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	98.01.08.11.24.24;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	97.08.29.00.51.59;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	97.08.29.00.02.12;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	97.03.04.06.58.10;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	97.02.14.06.22.13;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	96.08.29.06.33.54;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	96.08.28.10.03.46;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	96.08.28.04.02.56;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.08.13.23.49.02;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	96.07.23.22.44.10;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.06.12.17.06.00;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.06.12.13.33.09;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.03.29.21.35.21;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.12.06.17.27.45;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	95.08.22.02.10.13;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.06.16.17.29.29;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.07;	author mike;	state Rel4_4;
branches;
next	10.11;

10.11
date	95.01.04.07.46.56;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.12.29.17.20.00;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.12.28.14.06.58;	author gdurf;	state Exp;
branches;
next	10.8;

10.8
date	94.12.27.15.46.00;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.12.27.15.41.57;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.12.27.15.35.52;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.12.21.16.02.42;	author pjt;	state Exp;
branches;
next	10.4;

10.4
date	94.12.01.23.34.34;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.10.15.21.53;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.05.05.23.22.31;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.54;	author mike;	state Rel4_0;
branches;
next	9.26;

9.26
date	91.09.20.22.32.40;	author butler;	state Exp;
branches;
next	9.25;

9.25
date	91.08.31.06.52.01;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	91.08.31.06.03.38;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	91.07.23.16.00.08;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.06.30.19.12.01;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	91.06.29.17.03.13;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.06.10.23.31.35;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.06.10.23.14.06;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.06.10.22.40.19;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.06.10.22.20.16;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.03.13.19.21.52;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.02.21.16.08.45;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.02.19.23.03.24;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.11.12.18.48.02;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.11.12.18.33.36;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.10.06.02.50.43;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.10.06.02.04.48;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.07.29.22.39.46;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.05.21.14.22.37;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.01.06.03.54.03;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.01.05.04.15.01;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	89.12.31.07.42.03;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	89.12.31.00.13.59;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.12.30.05.21.57;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.12.30.04.38.11;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.53.48;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.03.15.15.35.22;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.10.06.03.08.23;	author mike;	state Rel3_0;
branches;
next	8.1;

8.1
date	88.10.05.00.31.00;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.08.20.07.22.56;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.08.20.07.01.08;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.08.19.06.54.15;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.23.00.25.49;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.32.58;	author mike;	state Rel;
branches;
next	6.6;

6.6
date	87.11.02.20.24.31;	author mike;	state Exp;
branches;
next	6.5;

6.5
date	87.10.15.01.29.56;	author mike;	state Exp;
branches;
next	6.4;

6.4
date	87.09.17.07.02.01;	author mike;	state Exp;
branches;
next	6.3;

6.3
date	87.09.17.04.16.00;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.08.09.19.12.12;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.55.19;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.10.52;	author mike;	state Rel;
branches;
next	4.5;

4.5
date	87.06.24.01.27.14;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.05.29.09.03.00;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.03.23.23.42.36;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.12.22.10.50;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.44.39;	author mike;	state Rel1;
branches;
next	3.7;

3.7
date	86.12.24.08.05.30;	author mike;	state Exp;
branches;
next	3.6;

3.6
date	86.10.26.16.56.30;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.08.12.04.15.14;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.07.22.03.20.09;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.19.04.38.25;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.11.01.31.33;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.06.12.22.30.09;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.32.38;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	86.06.09.21.49.58;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	86.05.29.01.47.15;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	86.03.14.22.01.38;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.10.29.14.23.01;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.10.28.17.00.39;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.09.11.19.39.29;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.10.00.35.57;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.03.07;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	85.07.30.05.52.09;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	85.07.30.02.03.27;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	85.06.07.00.54.00;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	85.05.29.00.15.12;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	85.03.25.11.44.14;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	85.02.04.21.50.54;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	85.02.02.01.23.41;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	85.02.01.21.26.32;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	84.11.29.07.02.26;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	84.11.27.07.00.21;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	84.11.24.03.01.49;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	84.11.23.20.53.52;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	84.11.22.09.06.50;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	84.11.20.20.14.10;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	84.11.16.06.27.48;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	84.10.19.01.37.58;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	84.10.19.00.06.49;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	84.08.28.03.07.19;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.05.03.06.55.00;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.05.02.05.10.12;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.05.01.06.39.14;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.04.26.05.35.03;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.04.18.02.19.43;	author mike;	state Exp;
branches;
next	;

11.44.2.1
date	2000.08.30.14.56.02;	author jra;	state Exp;
branches;
next	11.44.2.2;

11.44.2.2
date	2000.12.27.15.06.37;	author jra;	state Exp;
branches;
next	11.44.2.3;

11.44.2.3
date	2001.01.12.16.41.12;	author jra;	state Exp;
branches;
next	11.44.2.4;

11.44.2.4
date	2001.02.23.14.44.00;	author jra;	state Exp;
branches;
next	;

11.61.2.1
date	2002.09.19.18.01.29;	author morrison;	state Exp;
branches;
next	11.61.2.2;

11.61.2.2
date	2004.03.17.21.18.41;	author morrison;	state Exp;
branches;
next	;

11.61.4.1
date	2004.03.11.23.43.34;	author morrison;	state Exp;
branches;
next	;

11.61.6.1
date	2003.08.26.14.03.34;	author justin;	state Exp;
branches;
next	;

11.62.2.1
date	2003.09.13.17.52.41;	author butler;	state Exp;
branches;
next	;

11.62.4.1
date	2004.02.12.18.37.38;	author erikg;	state Exp;
branches;
next	11.62.4.2;

11.62.4.2
date	2004.03.15.14.07.16;	author erikg;	state Exp;
branches;
next	;


desc
@Boolean Region Evaluator
@


11.66
log
@moved to src/
@
text
@/*
 *			B O O L . C
 *
 * Ray Tracing program, Boolean region evaluator.
 *
 *  Note to developers -
 *	Do not use the hit_point field in these routines, as
 *	for some solid types it has been filled in by the g_xxx_shot()
 *	routine, and for other solid types it may not have been.
 *	In particular, copying a garbage hit_point from a structure which
 *	has not yet been filled in, into a structure which won't be
 *	filled in again, gives wrong results.
 *	Thanks to Keith Bowman for finding this obscure bug.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/bool.c,v 11.65 2004/05/10 15:30:45 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "bu.h"
#include "./debug.h"

/* Boolean values.  Not easy to change, but defined symbolicly */
#define FALSE	0
#define TRUE	1

RT_EXTERN(void rt_grow_boolstack, (struct resource *resp) );
int rt_tree_max_raynum(register const union tree *,
		       register const struct partition *);
int rt_bool_partition_eligible(register const struct bu_ptbl *,
			       register const struct bu_bitv *,
			       register const struct partition *);
int rt_booleval(register union tree*,
		struct partition *,
		struct region **,
		struct resource *);
/*
 *			R T _ W E A V E 0 S E G
 *
 *  If a zero thickness segment abutts another partition,
 *  it will be fused in, later.
 *
 *  If it is free standing, then it will remain as a
 *  zero thickness partition, which probably signals
 *  going through some solid an odd number of times,
 *  or hitting an NMG wire edge or NMG lone vertex.
 */
void
rt_weave0seg(struct seg *segp, struct partition *PartHdp, struct application *ap)
{
	register struct partition *pp;
	struct resource		*res = ap->a_resource;
	struct rt_i		*rtip = ap->a_rt_i;
	FAST fastf_t		tol_dist;

	tol_dist = rtip->rti_tol.dist;

	RT_CK_PT_HD(PartHdp);
	RT_CK_RTI(ap->a_rt_i);
	RT_CK_RESOURCE(res);
	RT_CK_RTI(rtip);

	if(RT_G_DEBUG&DEBUG_PARTITION)  {
		bu_log(
		"rt_boolweave:  Zero thickness seg: %s (%.18e,%.18e) %d,%d\n",
		segp->seg_stp->st_name,
		segp->seg_in.hit_dist,
		segp->seg_out.hit_dist,
		segp->seg_in.hit_surfno,
		segp->seg_out.hit_surfno );
	}

	if( PartHdp->pt_forw == PartHdp )  rt_bomb("rt_weave0seg() with empty partition list\n");

	/* See if this segment ends before start of first partition */
	if( segp->seg_out.hit_dist < PartHdp->pt_forw->pt_inhit->hit_dist )  {
		GET_PT_INIT( rtip, pp, res );
		bu_ptbl_ins_unique( &pp->pt_seglist, (long *)segp );
		pp->pt_inseg = segp;
		pp->pt_inhit = &segp->seg_in;
		pp->pt_outseg = segp;
		pp->pt_outhit = &segp->seg_out;
		APPEND_PT( pp, PartHdp );
		if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("0-len segment ends before start of first partition.\n");
		return;
	}

	/*
	 *  Cases:  seg at start of pt, in middle of pt, at end of pt,
	 *  or past end of pt but before start of next pt.
	 *  XXX For the first 3 cases, we might want to make a new 0-len pt,
	 *  XXX especially as the NMG ray-tracer starts reporting wire hits.
	 */
	for( pp=PartHdp->pt_forw; pp != PartHdp; pp=pp->pt_forw ) {
		if( NEAR_ZERO( segp->seg_in.hit_dist  - pp->pt_inhit->hit_dist, tol_dist ) ||
		    NEAR_ZERO( segp->seg_out.hit_dist - pp->pt_inhit->hit_dist, tol_dist )
		)  {
			if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("0-len segment ends right at start of existing partition.\n");
			return;
		}
		if( NEAR_ZERO( segp->seg_in.hit_dist  - pp->pt_outhit->hit_dist, tol_dist ) ||
		    NEAR_ZERO( segp->seg_out.hit_dist - pp->pt_outhit->hit_dist, tol_dist )
		)  {
			if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("0-len segment ends right at end of existing partition.\n");
			return;
		}
		if( segp->seg_out.hit_dist <= pp->pt_outhit->hit_dist &&
		    segp->seg_in.hit_dist >= pp->pt_inhit->hit_dist )  {
			if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("0-len segment in the middle of existing partition.\n");
			return;
		}
		if( pp->pt_forw == PartHdp ||
		    segp->seg_out.hit_dist < pp->pt_forw->pt_inhit->hit_dist )  {
		    	struct partition	*npp;
			if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("0-len segment after existing partition, but before next partition.\n");
			GET_PT_INIT( rtip, npp, res );
			bu_ptbl_ins_unique( &npp->pt_seglist, (long *)segp );
			npp->pt_inseg = segp;
			npp->pt_inhit = &segp->seg_in;
			npp->pt_outseg = segp;
			npp->pt_outhit = &segp->seg_out;
			APPEND_PT( npp, pp );
			return;
		}
	}
	rt_bomb("rt_weave0seg() fell out of partition loop?\n");
}

/*
 *			R T _ B O O L W E A V E
 *
 *  Weave a chain of segments into an existing set of partitions.
 *  The edge of each partition is an inhit or outhit of some solid (seg).
 *
 *  NOTE:  When the final partitions are completed, it is the users
 *  responsibility to honor the inflip and outflip flags.  They can
 *  not be flipped here because an outflip=1 edge and an inflip=0 edge
 *  following it may in fact be the same edge.  This could be dealt with
 *  by giving the partition struct a COPY of the inhit and outhit rather
 *  than a pointer, but that's more cycles than the neatness is worth.
 *
 * Inputs -
 *	Pointer to first segment in seg chain.
 *	Pointer to head of circular doubly-linked list of
 *	partitions of the original ray.
 *
 * Outputs -
 *	Partitions, queued on doubly-linked list specified.
 *
 * Notes -
 *	It is the responsibility of the CALLER to free the seg chain,
 *	as well as the partition list that we return.
 */
void
rt_boolweave(struct seg *out_hd, struct seg *in_hd, struct partition *PartHdp, struct application *ap)
{
	register struct seg *segp;
	register struct partition *pp;
	struct resource		*res = ap->a_resource;
	struct rt_i		*rtip = ap->a_rt_i;

	FAST fastf_t		diff, diff_se;
	FAST fastf_t		tol_dist;

	RT_CK_PT_HD(PartHdp);

	tol_dist = rtip->rti_tol.dist;

	RT_CK_RTI(ap->a_rt_i);
	RT_CK_RESOURCE(res);
	RT_CK_RTI(rtip);

	if(RT_G_DEBUG&DEBUG_PARTITION)  {
		bu_log( "In rt_boolweave, tol_dist = %g\n", tol_dist );
		rt_pr_partitions( rtip, PartHdp, "-----------------BOOL_WEAVE" );
	}

	while( BU_LIST_NON_EMPTY( &(in_hd->l) ) ) {
		register struct partition	*newpp = PT_NULL;
		register struct seg		*lastseg = RT_SEG_NULL;
		register struct hit		*lasthit = HIT_NULL;
		LOCAL int			lastflip = 0;

		segp = BU_LIST_FIRST( seg, &(in_hd->l) );
		RT_CHECK_SEG(segp);
		RT_CK_HIT(&(segp->seg_in));
		RT_CK_RAY(segp->seg_in.hit_rayp);
		RT_CK_HIT(&(segp->seg_out));
		RT_CK_RAY(segp->seg_out.hit_rayp);
		if(RT_G_DEBUG&DEBUG_PARTITION)  {
			point_t		pt;

			bu_log( "************ Input segment:\n" );
			rt_pr_seg(segp);
			rt_pr_hit(" In", &segp->seg_in );
			VJOIN1( pt, ap->a_ray.r_pt, segp->seg_in.hit_dist, ap->a_ray.r_dir );
			/* XXX needs indentation added here */
			VPRINT(" IPoint", pt );

			rt_pr_hit("Out", &segp->seg_out );
			VJOIN1( pt, ap->a_ray.r_pt, segp->seg_out.hit_dist, ap->a_ray.r_dir );
			/* XXX needs indentation added here */
			VPRINT(" OPoint", pt );
			bu_log( "***********\n" );
		}
		if( segp->seg_stp->st_bit >= rtip->nsolids) rt_bomb("rt_boolweave: st_bit");

		BU_LIST_DEQUEUE( &(segp->l) );
		BU_LIST_INSERT( &(out_hd->l), &(segp->l) );

		/* Make nearly zero be exactly zero */
		if( NEAR_ZERO( segp->seg_in.hit_dist, tol_dist ) )
			segp->seg_in.hit_dist = 0;
		if( NEAR_ZERO( segp->seg_out.hit_dist, tol_dist ) )
			segp->seg_out.hit_dist = 0;

		/* Totally ignore things behind the start position */
		if( segp->seg_out.hit_dist < -10.0 )
			continue;

		if( segp->seg_stp->st_aradius < INFINITY &&
		    !(segp->seg_in.hit_dist >= -INFINITY &&
		    segp->seg_out.hit_dist <= INFINITY) )  {
		    	bu_log("rt_boolweave:  Defective %s segment %s (%.18e,%.18e) %d,%d\n",
		    		rt_functab[segp->seg_stp->st_id].ft_name,
				segp->seg_stp->st_name,
				segp->seg_in.hit_dist,
				segp->seg_out.hit_dist,
				segp->seg_in.hit_surfno,
				segp->seg_out.hit_surfno );
			continue;
		}
		if( segp->seg_in.hit_dist > segp->seg_out.hit_dist )  {
		    	bu_log("rt_boolweave:  Inside-out %s segment %s (%.18e,%.18e) %d,%d\n",
		    		rt_functab[segp->seg_stp->st_id].ft_name,
				segp->seg_stp->st_name,
				segp->seg_in.hit_dist,
				segp->seg_out.hit_dist,
				segp->seg_in.hit_surfno,
				segp->seg_out.hit_surfno );
			continue;
		}

		/*
		 * Weave this segment into the existing partitions,
		 * creating new partitions as necessary.
		 */
		if( PartHdp->pt_forw == PartHdp )  {
			/* No partitions yet, simple! */
			GET_PT_INIT( rtip, pp, res );
			bu_ptbl_ins_unique( &pp->pt_seglist, (long *)segp );
			pp->pt_inseg = segp;
			pp->pt_inhit = &segp->seg_in;
			pp->pt_outseg = segp;
			pp->pt_outhit = &segp->seg_out;
			APPEND_PT( pp, PartHdp );
			if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("No partitions yet, segment forms first partition\n");
			goto done_weave;
		}

		if( ap->a_no_booleans )  {
			lastseg = segp;
			lasthit = &segp->seg_in;
			lastflip = 0;
			/* Just sort in ascending in-dist order */
			for( pp=PartHdp->pt_forw; pp != PartHdp; pp=pp->pt_forw ) {
				if( lasthit->hit_dist < pp->pt_inhit->hit_dist )  {
					if(RT_G_DEBUG&DEBUG_PARTITION)  {
						bu_log("Insert nobool seg before next pt\n");
					}
					GET_PT_INIT( rtip, newpp, res );
					bu_ptbl_ins_unique( &newpp->pt_seglist, (long *)segp );
					newpp->pt_inseg = segp;
					newpp->pt_inhit = &segp->seg_in;
					newpp->pt_outseg = segp;
					newpp->pt_outhit = &segp->seg_out;
					INSERT_PT( newpp, pp );
					goto done_weave;
				}
			}
			if(RT_G_DEBUG&DEBUG_PARTITION)  {
				bu_log("Append nobool seg at end of list\n");
			}
			GET_PT_INIT( rtip, newpp, res );
			bu_ptbl_ins_unique( &newpp->pt_seglist, (long *)segp );
			newpp->pt_inseg = segp;
			newpp->pt_inhit = &segp->seg_in;
			newpp->pt_outseg = segp;
			newpp->pt_outhit = &segp->seg_out;
			INSERT_PT( newpp, PartHdp );
			goto done_weave;
		}

		/* Check for zero-thickness segment, within tol */
		diff = segp->seg_in.hit_dist - segp->seg_out.hit_dist;
		if( NEAR_ZERO( diff, tol_dist ) )  {
			rt_weave0seg( segp, PartHdp, ap );
			goto done_weave;
		}

		if( segp->seg_in.hit_dist >= PartHdp->pt_back->pt_outhit->hit_dist )  {
			/*
			 * Segment starts exactly at last partition's end,
			 * or beyond last partitions end.  Make new partition.
			 */
			if(RT_G_DEBUG&DEBUG_PARTITION)  {
				bu_log("seg starts beyond last partition end. (%g,%g) Appending new partition\n",
					PartHdp->pt_back->pt_inhit->hit_dist,
					PartHdp->pt_back->pt_outhit->hit_dist);
			}
			GET_PT_INIT( rtip, pp, res );
			bu_ptbl_ins_unique( &pp->pt_seglist, (long *)segp );
			pp->pt_inseg = segp;
			pp->pt_inhit = &segp->seg_in;
			pp->pt_outseg = segp;
			pp->pt_outhit = &segp->seg_out;
			APPEND_PT( pp, PartHdp->pt_back );
			goto done_weave;
		}

		/* Loop through current partition list weaving the current input segment
		 * into the list. The following three variables keep track of the current
		 * starting point of the input segment. The starting point of the segment
		 * moves to higher hit_dist values (as it is woven in) until it is entirely consumed.
		 */
		lastseg = segp;
		lasthit = &segp->seg_in;
		lastflip = 0;
		for( pp=PartHdp->pt_forw; pp != PartHdp; pp=pp->pt_forw ) {

			if(RT_G_DEBUG&DEBUG_PARTITION) {
				bu_log( "At start of loop:\n" );
				bu_log( "	remaining input segment: (%.12e - %.12e)\n",
					lasthit->hit_dist, segp->seg_out.hit_dist );
				bu_log( "	current partition: (%.12e - %.12e)\n",
					pp->pt_inhit->hit_dist, pp->pt_outhit->hit_dist );
				rt_pr_partitions( rtip, PartHdp, "At start of loop" );
			}

			diff_se = lasthit->hit_dist - pp->pt_outhit->hit_dist;
			if( diff_se > tol_dist )  {
				/* Seg starts beyond the END of the
				 * current partition.
				 *	PPPP
				 *	        SSSS
				 * Advance to next partition.
				 */
				if(RT_G_DEBUG&DEBUG_PARTITION)  {
					bu_log("seg start beyond partition end, skipping.  (%g,%g)\n",
						pp->pt_inhit->hit_dist,
						pp->pt_outhit->hit_dist);
				}
				continue;
			}
			if(RT_G_DEBUG&DEBUG_PARTITION)  rt_pr_pt(rtip, pp);
			diff = lasthit->hit_dist - pp->pt_inhit->hit_dist;
			if( diff_se > -(tol_dist) && diff > tol_dist )  {
				/*
				 * Seg starts almost "precisely" at the
				 * end of the current partition.
				 *	PPPP
				 *	    SSSS
				 * FUSE an exact match of the endpoints,
				 * advance to next partition.
				 */
				lasthit->hit_dist = pp->pt_outhit->hit_dist;
				if(RT_G_DEBUG&DEBUG_PARTITION)  {
					bu_log("seg start fused to partition end, diff=%g\n", diff);
				}
				continue;
			}

			/*
			 *  diff < ~~0
			 *  Seg starts before current partition ends
			 *	PPPPPPPPPPP
			 *	  SSSS...
			 */
			if( diff > tol_dist )  {
				/*
				 * lasthit->hit_dist > pp->pt_inhit->hit_dist
				 * pp->pt_inhit->hit_dist < lasthit->hit_dist
				 *
				 *  Segment starts after partition starts,
				 *  but before the end of the partition.
				 *  Note:  pt_seglist will be updated in equal_start.
				 *	PPPPPPPPPPPP
				 *	     SSSS...
				 *	newpp|pp
				 */
				RT_DUP_PT( rtip, newpp, pp, res );
				/* new partition is the span before seg joins partition */
				pp->pt_inseg = segp;
				pp->pt_inhit = &segp->seg_in;
				pp->pt_inflip = 0;
				newpp->pt_outseg = segp;
				newpp->pt_outhit = &segp->seg_in;
				newpp->pt_outflip = 1;
				INSERT_PT( newpp, pp );
				if(RT_G_DEBUG&DEBUG_PARTITION) {
					bu_log("seg starts within p. Split p at seg start, advance. (diff = %g)\n", diff);
					bu_log( "newpp starts at %.12e, pp starts at %.12e\n",
						newpp->pt_inhit->hit_dist,
						pp->pt_inhit->hit_dist );
					bu_log( "newpp = x%x, pp = x%x\n", newpp, pp );
				}
				goto equal_start;
			}
			if( diff > -(tol_dist) )  {
				/*
				 * Make a subtle but important distinction here.
				 * Even though the two distances are "equal"
				 * within tolerance, they are not exactly
				 * the same.  If the new segment is slightly
				 * closer to the ray origin, then use it's
				 * IN point.
				 * This is an attempt to reduce the deflected
				 * normals sometimes seen along the edges of
				 * e.g. a cylinder unioned with an ARB8,
				 * where the ray hits the top of the cylinder
				 * and the *side* face of the ARB8 rather
				 * than the top face of the ARB8.
				 */
				diff = segp->seg_in.hit_dist - pp->pt_inhit->hit_dist;
				if( !pp->pt_back ||
				    pp->pt_back == PartHdp ||
				    pp->pt_back->pt_outhit->hit_dist <=
				    segp->seg_in.hit_dist ) {
					if( NEAR_ZERO(diff, tol_dist) &&
					    diff < 0 )  {
						if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("changing partition start point to segment start point\n");
						pp->pt_inseg = segp;
						pp->pt_inhit = &segp->seg_in;
						pp->pt_inflip = 0;
					}
				}
equal_start:
				if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("equal_start\n");
				/*
				 * Segment and partition start at
				 * (roughly) the same point.
				 * When fuseing 2 points together
				 * i.e., when NEAR_ZERO(diff,tol) is true,
				 * the two points MUST be forced to become
				 * exactly equal!
				 */
				diff = segp->seg_out.hit_dist - pp->pt_outhit->hit_dist;
				if( diff > tol_dist )  {
					/*
					 * Seg & partition start at roughly
					 * the same spot,
					 * seg extends beyond partition end.
					 *	PPPP
					 *	SSSSSSSS
					 *	pp  |  newpp
					 */
					bu_ptbl_ins_unique( &pp->pt_seglist, (long *)segp );
					lasthit = pp->pt_outhit;
					lastseg = pp->pt_outseg;
					lastflip = 1;
					if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("seg spans partition and extends beyond it\n");
					continue;
				}
				if( diff > -(tol_dist) )  {
					/*
					 *  diff ~= 0
					 * Segment and partition start & end
					 * (nearly) together.
					 *	PPPP
					 *	SSSS
					 */
					bu_ptbl_ins_unique( &pp->pt_seglist, (long *)segp );
					if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("same start&end\n");
					goto done_weave;
				} else {
					/*
					 *  diff < ~0
					 *
					 *  Segment + Partition start together,
					 *  segment ends before partition ends.
					 *	PPPPPPPPPP
					 *	SSSSSS
					 *	newpp| pp
					 */
					RT_DUP_PT( rtip, newpp, pp, res );
					/* new partition contains segment */
					bu_ptbl_ins_unique( &newpp->pt_seglist, (long *)segp );
					newpp->pt_outseg = segp;
					newpp->pt_outhit = &segp->seg_out;
					newpp->pt_outflip = 0;
					pp->pt_inseg = segp;
					pp->pt_inhit = &segp->seg_out;
					pp->pt_inflip = 1;
					INSERT_PT( newpp, pp );
					if(RT_G_DEBUG&DEBUG_PARTITION) {
						bu_log("start together, seg shorter than partition\n");
						bu_log( "newpp starts at %.12e, pp starts at %.12e\n",
							newpp->pt_inhit->hit_dist,
							pp->pt_inhit->hit_dist );
						bu_log( "newpp = x%x, pp = x%x\n", newpp, pp );
					}
					goto done_weave;
				}
				/* NOTREACHED */
			} else {
				/*
				 *  diff < ~~0
				 *
				 * Seg starts before current partition starts,
				 * but after the previous partition ends.
				 *	SSSSSSSS...
				 *	     PPPPP...
				 *	newpp|pp
				 */
				GET_PT_INIT( rtip, newpp, res );
				bu_ptbl_ins_unique( &newpp->pt_seglist, (long *)segp );
				newpp->pt_inseg = lastseg;
				newpp->pt_inhit = lasthit;
				newpp->pt_inflip = lastflip;
				diff = segp->seg_out.hit_dist - pp->pt_inhit->hit_dist;
				if( diff < -(tol_dist) )  {
					/*
					 *  diff < ~0
					 * Seg starts and ends before current
					 * partition, but after previous
					 * partition ends (diff < 0).
					 *		SSSS
					 *	pppp		PPPPP...
					 *		newpp	pp
					 */
					newpp->pt_outseg = segp;
					newpp->pt_outhit = &segp->seg_out;
					newpp->pt_outflip = 0;
					INSERT_PT( newpp, pp );
					if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("seg between 2 partitions\n");
					goto done_weave;
				}
				if( diff < tol_dist )  {
					/*
					 *  diff ~= 0
					 *
					 * Seg starts before current
					 * partition starts, and ends at or
					 * near the start of the partition.
					 * (diff == 0).  FUSE the points.
					 *	SSSSSS
					 *	     PPPPP
					 *	newpp|pp
					 * NOTE: only copy hit point, not
					 * normals or norm private stuff.
					 */
					newpp->pt_outseg = segp;
					newpp->pt_outhit = &segp->seg_out;
					newpp->pt_outhit->hit_dist = pp->pt_inhit->hit_dist;
					newpp->pt_outflip = 0;
					INSERT_PT( newpp, pp );
					if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("seg ends at partition start, fuse\n");
					goto done_weave;
				}
				/*
				 *  Seg starts before current partition
				 *  starts, and ends after the start of the
				 *  partition.  (diff > 0).
				 *	SSSSSSSSSS
				 *	      PPPPPPP
				 *	newpp| pp | ...
				 */
				newpp->pt_outseg = pp->pt_inseg;
				newpp->pt_outhit = pp->pt_inhit;
				newpp->pt_outflip = 1;
				lastseg = pp->pt_inseg;
				lasthit = pp->pt_inhit;
				lastflip = newpp->pt_outflip;
				INSERT_PT( newpp, pp );
				if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("insert seg before p start, ends after p ends.  Making new partition for initial portion.\n");
				goto equal_start;
			}
			/* NOTREACHED */
		}

		/*
		 *  Segment has portion which extends beyond the end
		 *  of the last partition.  Tack on the remainder.
		 *  	PPPPP
		 *  	     SSSSS
		 */
		if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("seg extends beyond partition end\n");
		GET_PT_INIT( rtip, newpp, res );
		bu_ptbl_ins_unique( &newpp->pt_seglist, (long *)segp );
		newpp->pt_inseg = lastseg;
		newpp->pt_inhit = lasthit;
		newpp->pt_inflip = lastflip;
		newpp->pt_outseg = segp;
		newpp->pt_outhit = &segp->seg_out;
		APPEND_PT( newpp, PartHdp->pt_back );

done_weave:	; /* Sorry about the goto's, but they give clarity */
		if(RT_G_DEBUG&DEBUG_PARTITION)
			rt_pr_partitions( rtip, PartHdp, "After weave" );
	}
	if(RT_G_DEBUG&DEBUG_PARTITION)
		bu_log( "--------------------Leaving Booleweave\n" );
}


/*
 *			_ R T _ D E F O V E R L A P
 *
 *  The guts of the default overlap callback.
 *  Returns -
 *	 0	to eliminate partition with overlap entirely
 *	 1	to retain partition in output list, claimed by reg1
 *	 2	to retain partition in output list, claimed by reg2
 */
HIDDEN int
_rt_defoverlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *pheadp, register int verbose)
{
	RT_CK_AP(ap);
	RT_CK_PT(pp);
	RT_CK_REGION(reg1);
	RT_CK_REGION(reg2);

	/*
	 *  Apply heuristics as to which region should claim partition.
	 */
	if( reg1->reg_aircode != 0 )  {
		/* reg1 was air, replace with reg2 */
		return 2;
	}
	if( pp->pt_back != pheadp ) {
		/* Repeat a prev region, if that is a choice */
		if( pp->pt_back->pt_regionp == reg1 )
			return 1;
		if( pp->pt_back->pt_regionp == reg2 )
			return 2;
	}

	/* To provide some consistency from ray to ray, use lowest bit # */
	if( reg1->reg_bit < reg2->reg_bit )
		return 1;
	return 2;
}
/*
 *			R T _ D E F O V E R L A P
 *
 *  Default handler for overlaps in rt_boolfinal().
 *  Returns -
 *	 0	to eliminate partition with overlap entirely
 *	 1	to retain partition in output list, claimed by reg1
 *	 2	to retain partition in output list, claimed by reg2
 *
 *  This is now simply a one-line wrapper that calls _rt_defoverlap(),
 *  requesting verbosity.
 */
int
rt_defoverlap (register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *pheadp)
{
    return (_rt_defoverlap(ap, pp, reg1, reg2, pheadp, 1));
}

/*
 *			R T _ O V E R L A P _ Q U I E T L Y
 *
 *  Silent version of rt_defoverlap().
 *  Returns -
 *	 0	to eliminate partition with overlap entirely
 *	 1	to retain partition in output list, claimed by reg1
 *	 2	to retain partition in output list, claimed by reg2
 *
 */
int
rt_overlap_quietly (register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *pheadp)
{
    return (_rt_defoverlap(ap, pp, reg1, reg2, pheadp, 0));
}

/*
 *	R T _ G E T _ R E G I O N _ S E G L I S T _ F O R _ P A R T I T I O N
 *
 *  Given one of the regions that is involved in a given partition
 *  (whether the boolean formula for this region is TRUE in this part or not),
 *  return a bu_ptbl list containing all the segments in this partition
 *  which came from solids that appear as terms in the boolean formula
 *  for the given region.
 *
 *  The bu_ptbl is initialized here, and must be freed by the caller.
 *  It will contain a pointer to at least one segment.
 */
void
rt_get_region_seglist_for_partition(struct bu_ptbl *sl, const struct partition *pp, const struct region *regp)
{
	const struct seg **segpp;

	bu_ptbl_init( sl, 8, "region seglist for partition" );

	/* Walk the partitions segment list */
	for( BU_PTBL_FOR( segpp, (const struct seg **), &pp->pt_seglist ) )  {
		const struct region **srpp;

		RT_CK_SEG(*segpp);
		/* For every segment in part, walk the solid's region list */
		for( BU_PTBL_FOR( srpp, (const struct region **), &(*segpp)->seg_stp->st_regions ) )  {
			RT_CK_REGION(*srpp);

			if( *srpp != regp )  continue;
			/* This segment is part of a solid in this region */
			bu_ptbl_ins_unique( sl, (long *)(*segpp) );
		}
	}

	if( BU_PTBL_LEN(sl) <= 0 )  bu_bomb("rt_get_region_seglist_for_partition() didn't find any segments\n");
}

/*
 *			R T _ F A S T G E N _ V O L _ V O L _ O V E R L A P
 *
 *  Handle FASTGEN volume/volume overlap.
 *  Look at underlying segs.
 *  If one is less than 1/4", take the longer.
 *  Otherwise take the shorter.
 *
 *  Required to null out one of the two regions.
 */
void
rt_fastgen_vol_vol_overlap(struct region **fr1, struct region **fr2, const struct partition *pp)
{
	struct bu_ptbl	sl1, sl2;
	const struct seg *s1 = (const struct seg *)NULL;
	const struct seg *s2 = (const struct seg *)NULL;
	fastf_t s1_in_dist;
	fastf_t s2_in_dist;
	fastf_t depth;
	struct seg **segpp;

	RT_CK_REGION(*fr1);
	RT_CK_REGION(*fr2);

	if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("Resolving FASTGEN volume/volume overlap: %s %s\n", (*fr1)->reg_name, (*fr2)->reg_name);

	rt_get_region_seglist_for_partition( &sl1, pp, *fr1 );
	rt_get_region_seglist_for_partition( &sl2, pp, *fr2 );

	s1_in_dist = MAX_FASTF;
	s2_in_dist = MAX_FASTF;
	for( BU_PTBL_FOR( segpp, (struct seg **), &sl1 ) )
	{
		if( (*segpp)->seg_in.hit_dist < s1_in_dist )
		{
			s1 = (*segpp);
			s1_in_dist = s1->seg_in.hit_dist;
		}
	}
	for( BU_PTBL_FOR( segpp, (struct seg **), &sl2 ) )
	{
		if( (*segpp)->seg_in.hit_dist < s2_in_dist )
		{
			s2 = (*segpp);
			s2_in_dist = s2->seg_in.hit_dist;
		}
	}
	RT_CK_SEG(s1);
	RT_CK_SEG(s2);

	depth = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;

	/* 6.35mm = 1/4 inch */
	if( depth < 6.35 )  {
		/* take region with lowest inhit */
		if( s1->seg_in.hit_dist < s2->seg_in.hit_dist )  {
			/* keep fr1, delete fr2 */
			*fr2 = REGION_NULL;
		} else {
			/* keep fr2, depete fr1 */
			*fr1 = REGION_NULL;
		}
	} else {
		/*
		 * take the region with largest inhit
		 */
		if( s1->seg_in.hit_dist >= s2->seg_in.hit_dist )  {
			/* keep fr1, delete fr2 */
			*fr2 = REGION_NULL;
		} else {
			*fr1 = REGION_NULL;
		}
	}

	bu_ptbl_free( &sl1 );
	bu_ptbl_free( &sl2 );
}

/*
 *			R T _ F A S T G E N _ P L A T E _ V O L _ O V E R L A P
 *
 *  Handle FASTGEN plate/volume overlap.
 *
 *  Measure width of _preceeding_ partition,
 *  which must have been claimed by the volume mode region fr2.
 *  If less than 1/4", delete preceeding partition, and plate wins this part.
 *  If less than 1/4", plate wins this part, previous partition untouched.
 *  If previous partition is claimed by plate mode region fr1,
 *  then overlap is left in output???
 *
 *  Required to null out one of the two regions.
 */
void
rt_fastgen_plate_vol_overlap(struct region **fr1, struct region **fr2, struct partition *pp, struct application *ap)
{
	struct partition *prev;
	fastf_t depth;

	RT_CK_REGION(*fr1);
	RT_CK_REGION(*fr2);
	RT_CK_PT(pp);
	RT_CK_AP(ap);

	if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("Resolving FASTGEN plate/volume overlap: %s %s\n", (*fr1)->reg_name, (*fr2)->reg_name);

	prev = pp->pt_back;
	if( prev->pt_magic == PT_HD_MAGIC )  {
		/* No prev partition, this is the first.  d=0, plate wins */
		*fr2 = REGION_NULL;
		return;
	}

	if( rt_fdiff(prev->pt_outhit->hit_dist, pp->pt_inhit->hit_dist) != 0 )  {
		/* There is a gap between previous partition and this one */
		/* So both plate and vol start at same place, d=0, plate wins */
		*fr2 = REGION_NULL;
		return;
	}

	if( prev->pt_regionp == *fr2 )  {
		/* previous part is volume mode, ends at start of pp */
		depth = prev->pt_outhit->hit_dist - prev->pt_inhit->hit_dist;
		/* 6.35mm = 1/4 inch */
		if( depth < 6.35 )  {
			/* Delete previous partition from list */
			DEQUEUE_PT(prev);
			FREE_PT(prev, ap->a_resource);

			/* plate mode fr1 wins this partition */
			*fr2 = REGION_NULL;
		} else {
			/* Leave previous partition alone */
			/* plate mode fr1 wins this partition */
			*fr2 = REGION_NULL;
		}
	} else if( prev->pt_regionp == *fr1 )  {
		/* previous part is plate mode, ends at start of pp */
		/* d < 0, leave overlap in output??? */
		/* For now, volume mode region just loses. */
		*fr2 = REGION_NULL;
	} else {
		/* Some other region preceeds this partition */
		/* So both plate and vol start at same place, d=0, plate wins */
		*fr2 = REGION_NULL;
	}
}

/*
 *			R T _ D E F A U L T _ M U L T I O V E R L A P
 *
 *  Default version of a_multioverlap().
 *
 *  Resolve the overlap of multiple regions withing a single partition.
 *  There are no null pointers in the table (they have been compressed
 *  out by our caller).  Consider BU_PTBL_LEN(regiontable) overlapping
 *  regions, and reduce to zero or one "claiming" regions, by
 *  setting pointers in the bu_ptbl of non-claiming regions to NULL.
 *
 *  This default routine reproduces the behavior of BRL-CAD Release 5.0
 *  by considerign the regions pairwise and calling the old a_overlap().
 *
 *  An application which knew how to handle multiple overlapping air
 *  regions would provide its own very different version of this routine
 *  as the a_multioverlap() handler.
 *
 *  This routine is for resolving overlaps only, and should not print
 *  any messages in normal operation; a_logoverlap() is for logging.
 *
 *  InputHdp is the list of partitions up to this point.  It allows us
 *  to look at the regions that have come before in deciding what to do
 *
 */
void
rt_default_multioverlap(struct application *ap, struct partition *pp, struct bu_ptbl *regiontable, struct partition *InputHdp)
{
	LOCAL struct region *lastregion = (struct region *)NULL;
	int	n_regions;
	int	n_fastgen = 0;
	int	code;
	int	i;

	RT_CK_AP(ap);
	RT_CK_PARTITION(pp);
	BU_CK_PTBL(regiontable);
	RT_CK_PT_HD(InputHdp);

   	if( ap->a_overlap == RT_AFN_NULL )
   		ap->a_overlap = rt_defoverlap;

	/* Count number of FASTGEN regions */
	n_regions = BU_PTBL_LEN(regiontable);
	for( i = n_regions-1; i >= 0; i-- )  {
		struct region *regp = (struct region *)BU_PTBL_GET(regiontable, i);
		RT_CK_REGION(regp);
		if( regp->reg_is_fastgen != REGION_NON_FASTGEN )  n_fastgen++;
	}

	/*
	 *  Resolve all FASTGEN overlaps before considering BRL-CAD
	 *  overlaps, because FASTGEN overlaps have strict rules.
	 */
	if( n_fastgen >= 2 )  {
		struct region **fr1;
		struct region **fr2;

		if(RT_G_DEBUG&DEBUG_PARTITION)  {
			bu_log("I see %d FASTGEN overlaps in this partition\n", n_fastgen);
			for( BU_PTBL_FOR( fr1, (struct region **), regiontable ) )  {
				if( *fr1 == REGION_NULL )  continue;
				rt_pr_region(*fr1);
			}
		}

		/*
		 *  First, resolve volume_mode/volume_mode overlaps
		 *  because they are a simple choice.
		 *  N.B. The searches run from high to low in the ptbl array.
		 */
		for( BU_PTBL_FOR( fr1, (struct region **), regiontable ) )  {
			if( *fr1 == REGION_NULL )  continue;
			RT_CK_REGION(*fr1);
			if( (*fr1)->reg_is_fastgen != REGION_FASTGEN_VOLUME )
				continue;
			for( fr2 = fr1-1; fr2 >= (struct region **)BU_PTBL_BASEADDR(regiontable); fr2-- )  {
				if( *fr2 == REGION_NULL )  continue;
				RT_CK_REGION(*fr2);
				if( (*fr2)->reg_is_fastgen != REGION_FASTGEN_VOLUME )
					continue;
				rt_fastgen_vol_vol_overlap( fr1, fr2, pp );
				if( *fr1 == REGION_NULL )  break;
			}
		}

		/* Second, resolve plate_mode/volume_mode overlaps */
		for( BU_PTBL_FOR( fr1, (struct region **), regiontable ) )  {
			if( *fr1 == REGION_NULL )  continue;
			RT_CK_REGION(*fr1);
			if( (*fr1)->reg_is_fastgen != REGION_FASTGEN_PLATE )
				continue;
			for( BU_PTBL_FOR( fr2, (struct region **), regiontable ) )  {
				if( *fr2 == REGION_NULL )  continue;
				RT_CK_REGION(*fr2);
				if( (*fr2)->reg_is_fastgen != REGION_FASTGEN_VOLUME )
					continue;
				rt_fastgen_plate_vol_overlap( fr1, fr2, pp, ap );
				if( *fr1 == REGION_NULL )  break;
			}
		}


		/* Finally, think up a way to pass plate/plate overlaps on */
		n_fastgen = 0;
		for( i = n_regions-1; i >= 0; i-- )  {
			struct region *regp = (struct region *)BU_PTBL_GET(regiontable, i);
			if( regp == REGION_NULL ) continue;	/* empty slot in table */
			RT_CK_REGION(regp);
			if( regp->reg_is_fastgen != REGION_NON_FASTGEN )  n_fastgen++;
		}

		/* Compress out any null pointers in the table */
		bu_ptbl_rm( regiontable, (long *)NULL );
	}

	lastregion = (struct region *)BU_PTBL_GET(regiontable, 0);
	RT_CK_REGION(lastregion);

	if( BU_PTBL_LEN(regiontable) > 1 && ap->a_rt_i->rti_save_overlaps != 0 )  {
		/*
		 *  Snapshot current state of overlap list,
		 *  so that downstream application code can resolve any
		 *  FASTGEN plate/plate overlaps.
		 *  The snapshot is not taken at the top of the routine
		 *  because nobody is interested in FASTGEN vol/plate
		 *  or vol/vol overlaps.
		 *  The list is terminated with a NULL pointer,
		 *  placed courtesy of bu_calloc().
		 */
		pp->pt_overlap_reg = (struct region **)bu_calloc(
			BU_PTBL_LEN(regiontable)+1, sizeof(struct region *),
			"pt_overlap_reg" );
		bcopy( (char *)BU_PTBL_BASEADDR(regiontable),
			(char *)pp->pt_overlap_reg,
			BU_PTBL_LEN(regiontable) * sizeof(struct region *) );
	}

	/* Examine the overlapping regions, pairwise */
	for( i=1; i < BU_PTBL_LEN(regiontable); i++ )  {
		struct region *regp = (struct region *)BU_PTBL_GET(regiontable, i);
		if( regp == REGION_NULL ) continue;	/* empty slot in table */
		RT_CK_REGION(regp);

		code = -1;				/* For debug out in policy */

		/*
		 * Two or more regions claim this partition
		 */
		if( lastregion->reg_aircode != 0 && regp->reg_aircode == 0 )  {
			/* last region is air, replace with solid regp */
			goto code2;
		} else if( lastregion->reg_aircode == 0 && regp->reg_aircode != 0 )  {
			/* last region solid, regp is air, keep last */
			goto code1;
		} else if( lastregion->reg_aircode != 0 &&
		    regp->reg_aircode != 0 &&
		    regp->reg_aircode == lastregion->reg_aircode )  {
		    	/* both are same air, keep last */
			goto code1;
		}

		/*
		 *  If a FASTGEN region overlaps a non-FASTGEN region,
		 *  the non-FASTGEN ("traditional BRL-CAD") region wins.
		 *  No mixed-mode geometry like this will be built by the
		 *  fastgen-to-BRL-CAD converters, only by human editors.
		 */
		if( lastregion->reg_is_fastgen != regp->reg_is_fastgen )  {
			if( lastregion->reg_is_fastgen )
				goto code2;		/* keep regp */
			if( regp->reg_is_fastgen )
				goto code1;		/* keep lastregion */
		}

		/*
		 *  To support ray bundles, find partition with the lower
		 *  contributing ray number (closer to center of bundle),
		 *  and retain that one.
		 */
		{
			int	r1 = rt_tree_max_raynum( lastregion->reg_treetop, pp );
			int	r2 = rt_tree_max_raynum( regp->reg_treetop, pp );
			/* Only use this algorithm if one is not the main ray */
			if( r1 > 0 || r2 > 0 )  {
/* if(RT_G_DEBUG&DEBUG_PARTITION) */
bu_log("Potential overlay along ray bundle: r1=%d, r2=%d, resolved to %s\n", r1, r2,
(r1<r2)?lastregion->reg_name:regp->reg_name);
				if( r1 < r2 )
					goto code1;	/* keep lastregion */
				goto code2;		/* keep regp */
			}
		}

	   	/*
	   	 *  Hand overlap to old-style application-specific
	   	 *  overlap handler, or default.
		 *	0 = destroy partition,
		 *	1 = keep part, claiming region=lastregion
		 *	2 = keep part, claiming region=regp
	   	 */
		code = ap->a_overlap(ap, pp, lastregion, regp, InputHdp);

		/* Implement the policy in "code" */
		if( code == 0 )  {
			/*
			 *  Destroy the whole partition.
			 */
			if(RT_G_DEBUG&DEBUG_PARTITION)  bu_log("rt_default_multioverlap:  overlap code=0, partition=x%x deleted\n", pp);
			bu_ptbl_reset(regiontable);
			return;
		} else if( code == 1 ) {
code1:
			/* Keep partition, claiming region = lastregion */
			if(RT_G_DEBUG&DEBUG_PARTITION)  bu_log("rt_default_multioverlap:  overlap policy=1, code=%d, p retained in region=%s\n",
				code, lastregion->reg_name );
			BU_PTBL_CLEAR_I(regiontable, i);
		} else {
code2:
			/* Keep partition, claiming region = regp */
			bu_ptbl_zero(regiontable, (long *)lastregion);
			lastregion = regp;
			if(RT_G_DEBUG&DEBUG_PARTITION)  bu_log("rt_default_multioverlap:  overlap policy!=(0,1) code=%d, p retained in region=%s\n",
				code, lastregion->reg_name );
		}
	}
}

/*
 *			R T _ S I L E N T _ L O G O V E R L A P
 *
 *  If an application doesn't want any logging from LIBRT, it should
 *  just set ap->a_logoverlap = rt_silent_logoverlap.
 */
void
rt_silent_logoverlap(struct application *ap, const struct partition *pp, const struct bu_ptbl *regiontable, const struct partition *InputHdp)
{
	RT_CK_AP(ap);
	RT_CK_PT(pp);
	BU_CK_PTBL(regiontable);
	return;
}


/*
 *			R T _ D E F A U L T _ L O G O V E R L A P
 *
 *  Log a multiplicity of overlaps within a single partition.
 *  This function is intended for logging only, and a_multioverlap()
 *  is intended for resolving the overlap, only.
 *  This function can be replaced by an application setting a_logoverlap().
 */
void
rt_default_logoverlap(struct application *ap, const struct partition *pp, const struct bu_ptbl *regiontable, const struct partition *InputHdp)
{
	point_t	pt;
	static long count = 0;		/* Not PARALLEL, shouldn't hurt */
	register fastf_t depth;
	int		i;
	struct bu_vls	str;

	RT_CK_AP(ap);
	RT_CK_PT(pp);
	BU_CK_PTBL(regiontable);

	/* Attempt to control tremendous error outputs */
	if( ++count > 100 )  {
		if( (count%100) != 3 )  return;
		bu_log("(overlaps omitted)\n");
	}

	/*
	 * Print all verbiage in one call to bu_log(),
	 * so that messages will be grouped together in parallel runs.
	 */
	bu_vls_init(&str);
	bu_vls_extend(&str, 80*8 );
	bu_vls_putc(&str, '\n' );

	/* List all the regions which evaluated to TRUE in this partition */
	for( i=0; i < BU_PTBL_LEN(regiontable); i++ )  {
		struct region *regp = (struct region *)BU_PTBL_GET(regiontable, i);

		if( regp == REGION_NULL )  continue;
		RT_CK_REGION(regp);

		bu_vls_printf(&str, "OVERLAP%d: %s\n", i+1, regp->reg_name);
	}

	/* List all the information common to this whole partition */
	bu_vls_printf(&str, "OVERLAPa: dist=(%g,%g) isol=%s osol=%s\n",
		pp->pt_inhit->hit_dist, pp->pt_outhit->hit_dist,
		pp->pt_inseg->seg_stp->st_name,
		pp->pt_outseg->seg_stp->st_name);

	depth = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;
	VJOIN1( pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist,
		ap->a_ray.r_dir );

	bu_vls_printf(&str, "OVERLAPb: depth %.5fmm at (%g, %g, %g) x%d y%d lvl%d\n",
		depth, pt[X], pt[Y], pt[Z],
		ap->a_x, ap->a_y, ap->a_level );

	bu_log("%s", bu_vls_addr(&str));
	bu_vls_free(&str);

#if 0
	rt_pr_partitions( ap->a_rt_i, pheadp, "Entire ray containing overlap");
#endif

}

/*
 *			R T _ O V E R L A P _ T A B L E S _ E Q U A L
 *
 *  Overlap tables are NULL terminated arrays of region pointers.
 *  The order of entries may be different between the two.
 *
 *  Returns -
 *	1	The tables match
 *	0	The tables do not match
 */
int
rt_overlap_tables_equal( struct region *const*a, struct region *const*b )
{
	int alen=0, blen=0;
	register struct region *const*app;
	register struct region *const*bpp;

	if( a == NULL && b == NULL )
		return 1;

	if( a == NULL || b == NULL )
		return 0;

	/* First step, compare lengths */
	for( app = a; *app != NULL; app++ )  alen++;
	for( bpp = b; *bpp != NULL; bpp++ )  blen++;
	if( alen != blen )  return 0;

	/* Second step, compare contents */
	for( app = a; *app != NULL; app++ )  {
		register const struct region *t = *app;
		for( bpp = b; *bpp != NULL; bpp++ )  {
			if( *bpp == t )  goto b_ok;
		}
		/* 't' not found in b table, no match */
		return 0;
b_ok:		;
	}
	/* Everything matches */
	return 1;
}

/*
 *			R T _ B O O L F I N A L
 *
 *
 *  Consider each partition on the sorted & woven input partition list.
 *  If the partition ends before this box's start, discard it immediately.
 *  If the partition begins beyond this box's end, return.
 *
 *  Next, evaluate the boolean expression tree for all regions that have
 *  some presence in the partition.
 *
 * If 0 regions result, continue with next partition.
 * If 1 region results, a valid hit has occured, so transfer
 * the partition from the Input list to the Final list.
 * If 2 or more regions claim the partition, then an overlap exists.
 * If the overlap handler gives a non-zero return, then the overlapping
 * partition is kept, with the region ID being the first one encountered.
 * Otherwise, the partition is eliminated from further consideration. 
 *
 *  All partitions in the indicated range of the ray are evaluated.
 *  All partitions which really exist (booleval is true) are appended
 *  to the Final partition list.
 *  All partitions on the Final partition list have completely valid
 *  entry and exit information, except for the last partition's exit
 *  information when a_onehit!=0 and a_onehit is odd.
 *
 *  The flag a_onehit is interpreted as follows:
 *
 *  If a_onehit = 0, then the ray is traced to +infinity, and all
 *  hit points in the final partition list are valid.
 *
 *  If a_onehit != 0, the ray is traced through a_onehit hit points.
 *  (Recall that each partition has 2 hit points, entry and exit).
 *  Thus, if a_onehit is odd, the value of pt_outhit.hit_dist in
 *  the last partition may be incorrect;  this should not mater because
 *  the application specifically said it only wanted pt_inhit there.
 *  This is most commonly seen when a_onehit = 1, which is useful for
 *  lighting models.  Not having to correctly determine the exit point
 *  can result in a significant savings of computer time.
 *  If a_onehit is negative, it indicates the number of non-air hits needed.
 *
 *  Returns -
 *	0	If more partitions need to be done
 *	1	Requested number of hits are available in FinalHdp
 *
 *  The caller must free whatever is in both partition chains.
 *
 *
 *  NOTES for code improvements -
 *
 *  With a_onehit != 0, it is difficult to stop at the 'enddist' value
 *  (or the a_ray_length value), and always get correct results.
 *  Need to take into account some additional factors:
 *
 *  1)  A region shouldn't be evaluated until all it's solids have been
 *	intersected, to prevent the "CERN" problem of out points being
 *	wrong because subtracted solids aren't intersected yet.
 *
 *	Maybe "all" solids don't have to be intersected, but some strong
 *	statements are needed along these lines.
 *
 *	A region is definitely ready to be evaluated
 *	IF all it's solids have been intersected.
 *
 *  2)  A partition shouldn't be evaluated until all the regions within it
 *	are ready to be evaluated.
 */
int
rt_boolfinal(struct partition *InputHdp, struct partition *FinalHdp, fastf_t startdist, fastf_t enddist, struct bu_ptbl *regiontable, struct application *ap, const struct bu_bitv *solidbits)
{
	LOCAL struct region *lastregion = (struct region *)NULL;
	LOCAL struct region *TrueRg[2];
	register struct partition *pp;
	register int	claiming_regions;
	int		hits_avail = 0;
	int		hits_needed;
	int		ret = 0;
	int		indefinite_outpt = 0;
	char		*reason = (char *)NULL;
	fastf_t		diff;

#define HITS_TODO	(hits_needed - hits_avail)

	RT_CK_PT_HD(InputHdp);
	RT_CK_PT_HD(FinalHdp);
	BU_CK_PTBL(regiontable);
	RT_CK_RTI(ap->a_rt_i);
	BU_CK_BITV(solidbits);

	if(RT_G_DEBUG&DEBUG_PARTITION)  {
		bu_log("\nrt_boolfinal(%g,%g) x%d y%d lvl%d START\n",
			startdist, enddist,
			ap->a_x, ap->a_y, ap->a_level );
	}

	if( !ap->a_multioverlap )
		ap->a_multioverlap = rt_default_multioverlap;

	if( !ap->a_logoverlap )
		ap->a_logoverlap = rt_default_logoverlap;

	if( enddist <= 0 )  {
		reason = "not done, behind start point";
		ret = 0;
		goto out;
	}

	if( ap->a_onehit < 0 )
		hits_needed = -ap->a_onehit;
	else
		hits_needed = ap->a_onehit;

	if( ap->a_onehit != 0 )  {
		register struct partition *npp = FinalHdp->pt_forw;

		for(; npp != FinalHdp; npp = npp->pt_forw )  {
			if( npp->pt_inhit->hit_dist < 0.0 )
				continue;
			if( ap->a_onehit < 0 && npp->pt_regionp->reg_aircode != 0 )
				continue;	/* skip air hits */
			hits_avail += 2;	/* both in and out listed */
		}
		if( hits_avail >= hits_needed )  {
			reason = "a_onehit request satisfied at outset";
			ret = 1;
			goto out;
		}
	}

	if( ap->a_no_booleans )  {
		while( (pp = InputHdp->pt_forw) != InputHdp )  {
			RT_CK_PT(pp);
			DEQUEUE_PT(pp);
			pp->pt_regionp = (struct region *)
				BU_PTBL_GET(&pp->pt_inseg->seg_stp->st_regions, 0);
			RT_CK_REGION(pp->pt_regionp);
			if(RT_G_DEBUG&DEBUG_PARTITION)  {
				rt_pr_pt( ap->a_rt_i, pp );
			}
			INSERT_PT( pp, FinalHdp );
		}
		ret = 0;
		reason = "No a_onehit processing in a_no_booleans mode";
		goto out;
	}

	pp = InputHdp->pt_forw;
	while( pp != InputHdp )  {
		RT_CK_PT(pp);
		claiming_regions = 0;
		if(RT_G_DEBUG&DEBUG_PARTITION)  {
			bu_log("\nrt_boolfinal(%g,%g) x%d y%d lvl%d, next input pp\n",
				startdist, enddist,
				ap->a_x, ap->a_y, ap->a_level );
			rt_pr_pt( ap->a_rt_i, pp );
		}
		RT_CHECK_SEG(pp->pt_inseg);
		RT_CHECK_SEG(pp->pt_outseg);

		/* Force "very thin" partitions to have exactly zero thickness. */
		diff = pp->pt_inhit->hit_dist - pp->pt_outhit->hit_dist;
		if( NEAR_ZERO( diff, ap->a_rt_i->rti_tol.dist ) )  {
			if(RT_G_DEBUG&DEBUG_PARTITION)  bu_log(
				"rt_boolfinal:  Zero thickness partition, prims %s %s (%.18e,%.18e) x%d y%d lvl%d\n",
				pp->pt_inseg->seg_stp->st_name,
				pp->pt_outseg->seg_stp->st_name,
				pp->pt_inhit->hit_dist,
				pp->pt_outhit->hit_dist,
				ap->a_x, ap->a_y, ap->a_level );
			pp->pt_outhit->hit_dist = pp->pt_inhit->hit_dist;
		}


		/* Sanity checks on sorting. */
		if( pp->pt_inhit->hit_dist > pp->pt_outhit->hit_dist )  {
			bu_log("rt_boolfinal: inverted partition %.8x x%d y%d lvl%d\n",
				pp,
				ap->a_x, ap->a_y, ap->a_level );
			rt_pr_partitions( ap->a_rt_i, InputHdp, "With problem" );
		}
		if( pp->pt_forw != InputHdp &&
		    pp->pt_outhit->hit_dist != pp->pt_forw->pt_inhit->hit_dist )  {
			diff = pp->pt_outhit->hit_dist - pp->pt_forw->pt_inhit->hit_dist;
			if( NEAR_ZERO( diff, ap->a_rt_i->rti_tol.dist ) )  {
				if(RT_G_DEBUG&DEBUG_PARTITION)  bu_log("rt_boolfinal:  fusing 2 partitions x%x x%x\n",
					pp, pp->pt_forw );
				pp->pt_forw->pt_inhit->hit_dist = pp->pt_outhit->hit_dist;
			} else if( diff > 0 )  {
				bu_log("rt_boolfinal:  sorting defect %e > %e! x%d y%d lvl%d, diff = %g\n",
					pp->pt_outhit->hit_dist,
					pp->pt_forw->pt_inhit->hit_dist,
					ap->a_x, ap->a_y, ap->a_level, diff );
				bu_log( "sort defect is between parts x%x and x%x\n",
					pp, pp->pt_forw );
				if( !(RT_G_DEBUG & DEBUG_PARTITION) )
					rt_pr_partitions( ap->a_rt_i, InputHdp, "With DEFECT" );
				ret = 0;
				reason = "ERROR, sorting defect, give up";
				goto out;
			}
		}

		/*
		 *  If partition is behind ray start point, discard it.
		 *
		 *  Partition may start before current box starts, because
		 *  it's still waiting for all it's solids to be shot.
		 */
		if( pp->pt_outhit->hit_dist <= 0.001 /* milimeters */ )  {
			register struct partition *zap_pp;
			if(RT_G_DEBUG&DEBUG_PARTITION)bu_log(
				"discarding partition x%x behind ray start, out dist=%g\n",
				pp, pp->pt_outhit->hit_dist);
			zap_pp = pp;
			pp = pp->pt_forw;
			DEQUEUE_PT(zap_pp);
			FREE_PT(zap_pp, ap->a_resource);
			continue;
		}

		/*
		 *  If partition begins beyond current box end,
		 *  the state of the partition is not fully known yet,
		 *  and new partitions might be added in front of this one,
		 *  so stop now.
		 */
		diff = pp->pt_inhit->hit_dist - enddist;
		if( diff > ap->a_rt_i->rti_tol.dist )  {
			if(RT_G_DEBUG&DEBUG_PARTITION)bu_log(
				"partition begins %g beyond current box end, returning\n", diff);
			reason = "partition begins beyond current box end";
			ret = 0;
			goto out;
		}

		/*
		 *  If partition ends somewhere beyond the end of the current
		 *  box, the condition of the outhit information is not fully
		 *  known yet.
		 *  The partition might be broken or shortened by subsequent
		 *  segments, not discovered until entering future boxes.
		 */
		diff = pp->pt_outhit->hit_dist - enddist;
		if( diff > ap->a_rt_i->rti_tol.dist )  {
			if(RT_G_DEBUG&DEBUG_PARTITION)bu_log(
				"partition ends beyond current box end\n");
			if( ap->a_onehit != 1 )  {
				ret = 0;
				reason = "a_onehit != 1, trace remaining boxes";
				goto out;
			}
			/* pt_outhit may not be correct */
			indefinite_outpt = 1;
		} else {
			indefinite_outpt = 0;
		}

		/* XXX a_ray_length checking should be done here, not in rt_shootray() */

		/* Start with a clean slate when evaluating this partition */
		bu_ptbl_reset(regiontable);

		/*
		 *  For each segment's solid that lies in this partition,
		 *  add the list of regions that refer to that solid
		 *  into the "regiontable" array.
		 */
		{
			struct seg **segpp;

			if(RT_G_DEBUG&DEBUG_PARTITION)
				bu_log( "Building region table:\n" );
			for( BU_PTBL_FOR(segpp, (struct seg **), &pp->pt_seglist) )  {
				struct soltab	*stp = (*segpp)->seg_stp;
				RT_CK_SOLTAB(stp);
				bu_ptbl_cat_uniq( regiontable, &stp->st_regions );
			}
		}

		if(RT_G_DEBUG&DEBUG_PARTITION)  {
			struct region **regpp;
			bu_log("Region table for this partition:\n");
			for( BU_PTBL_FOR( regpp, (struct region **), regiontable ) )  {
				register struct region *regp;

				regp = *regpp;
				RT_CK_REGION(regp);
				bu_log("%9lx %s\n", (long)regp, regp->reg_name);
			}
		}

		if( indefinite_outpt )  {
			if(RT_G_DEBUG&DEBUG_PARTITION)bu_log(
				"indefinite out point, checking partition eligibility for early evaluation.\n");
			/*
			 *  More hits still needed.  HITS_TODO > 0.
			 *  If every solid in every region participating
			 *  in this partition has been intersected,
			 *  then it is OK to evaluate it now.
			 */
			if( !rt_bool_partition_eligible(regiontable, solidbits, pp) )  {
				ret = 0;
				reason = "Partition not yet eligible for evaluation";
				goto out;
			}
			if(RT_G_DEBUG&DEBUG_PARTITION)bu_log(
				"Partition is eligibile for evaluation.\n");
		}

		/* Evaluate the boolean trees of any regions involved */
		{
			struct region **regpp;
			for( BU_PTBL_FOR( regpp, (struct region **), regiontable ) )  {
				register struct region *regp;

				regp = *regpp;
				RT_CK_REGION(regp);
				if(RT_G_DEBUG&DEBUG_PARTITION)  {
					rt_pr_tree_val( regp->reg_treetop, pp, 2, 0 );
					rt_pr_tree_val( regp->reg_treetop, pp, 1, 0 );
					rt_pr_tree_val( regp->reg_treetop, pp, 0, 0 );
					bu_log("%.8x=bit%d, %s: ",
						regp, regp->reg_bit,
						regp->reg_name );
				}
				if( regp->reg_all_unions )  {
					if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("TRUE (all union)\n");
					claiming_regions++;
					lastregion = regp;
					continue;
				}
				if( rt_booleval( regp->reg_treetop, pp, TrueRg,
				    ap->a_resource ) == FALSE )  {
					if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("FALSE\n");
				    	/* Null out non-claiming region's pointer */
				    	*regpp = REGION_NULL;
					continue;
				}
				/* This region claims partition */
				if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("TRUE (eval)\n");
				claiming_regions++;
				lastregion = regp;
			}
		}
		if(RT_G_DEBUG&DEBUG_PARTITION)  bu_log("rt_boolfinal:  claiming_regions=%d (%g <-> %g)\n",
			claiming_regions, pp->pt_inhit->hit_dist, pp->pt_outhit->hit_dist);
		if( claiming_regions == 0 )  {
			if(RT_G_DEBUG&DEBUG_PARTITION)bu_log("rt_boolfinal moving past partition x%x\n", pp);
			pp = pp->pt_forw;		/* onwards! */
			continue;
		}

		if( claiming_regions > 1 )  {
			/*
			 *  There is an overlap between two or more regions,
			 *  invoke multi-overlap handler.
			 */
			if(RT_G_DEBUG&DEBUG_PARTITION)
bu_log("rt_boolfinal:  invoking a_multioverlap() pp=x%x\n", pp);
			bu_ptbl_rm( regiontable, (long *)NULL );
			ap->a_logoverlap( ap, pp, regiontable, InputHdp );
			ap->a_multioverlap( ap, pp, regiontable, InputHdp );

			/* Count number of remaining regions, s/b 0 or 1 */
			claiming_regions = 0;
			{
				register struct region **regpp;
				for( BU_PTBL_FOR( regpp, (struct region **), regiontable ) )  {
					if( *regpp != REGION_NULL )  {
						claiming_regions++;
						lastregion = *regpp;
					}
				}
			}

			/*
			 *  If claiming_regions == 0, discard partition.
			 *  If claiming_regions > 1, signal error and discard.
			 *  There is nothing further we can do to fix it.
			 */
			if( claiming_regions > 1)  {
				bu_log("rt_boolfinal() a_multioverlap() failed to resolve overlap, discarding bad partition:\n");
				rt_pr_pt( ap->a_rt_i, pp );
			}

			if( claiming_regions != 1 )  {
				register struct partition	*zap_pp;

				if(RT_G_DEBUG&DEBUG_PARTITION)bu_log("rt_boolfinal discarding overlap partition x%x\n", pp);
				zap_pp = pp;
				pp = pp->pt_forw;		/* onwards! */
				DEQUEUE_PT( zap_pp );
				FREE_PT( zap_pp, ap->a_resource );
				continue;
			}
		}

		/*
		 *  claiming_regions == 1
		 *
		 *  Remove this partition from the input queue, and
		 *  append it to the result queue.
		 */
		{
			register struct partition	*newpp;
			register struct partition	*lastpp;
			if(RT_G_DEBUG&DEBUG_PARTITION )
				bu_log( "Appending partition to result queue: %g, %g\n",
					pp->pt_inhit->hit_dist, pp->pt_outhit->hit_dist );
			newpp = pp;
			pp=pp->pt_forw;				/* onwards! */
			DEQUEUE_PT( newpp );
			RT_CHECK_SEG(newpp->pt_inseg);		/* sanity */
			RT_CHECK_SEG(newpp->pt_outseg);		/* sanity */
			/* Record the "owning" region.  pt_regionp = NULL before here. */
			newpp->pt_regionp = lastregion;

			/*  See if this new partition extends the previous
			 *  last partition, "exactly" matching.
			 */
			lastpp = FinalHdp->pt_back;
			if( lastpp != FinalHdp &&
			    lastregion == lastpp->pt_regionp &&
			    NEAR_ZERO( newpp->pt_inhit->hit_dist -
				lastpp->pt_outhit->hit_dist,
				ap->a_rt_i->rti_tol.dist ) &&
			    ( ap->a_rt_i->rti_save_overlaps == 0 ||
				rt_overlap_tables_equal(
					lastpp->pt_overlap_reg,
					newpp->pt_overlap_reg ) )
			)  {
				/* same region, merge by extending last final partition */
				if(RT_G_DEBUG&DEBUG_PARTITION)bu_log("rt_boolfinal 'exact match', extending last partition, discarding x%x\n", newpp);
				RT_CK_PT(lastpp);
				RT_CHECK_SEG(lastpp->pt_inseg);	/* sanity */
				RT_CHECK_SEG(lastpp->pt_outseg);/* sanity */
				if(RT_G_DEBUG&DEBUG_PARTITION)bu_log("rt_boolfinal collapsing %x %x\n", lastpp, newpp);
				lastpp->pt_outhit = newpp->pt_outhit;
				lastpp->pt_outflip = newpp->pt_outflip;
				lastpp->pt_outseg = newpp->pt_outseg;

				/* Don't lose the fact that the two solids
				 * of this partition contributed.
				 */
				bu_ptbl_ins_unique( &lastpp->pt_seglist, (long *)newpp->pt_inseg );
				bu_ptbl_ins_unique( &lastpp->pt_seglist, (long *)newpp->pt_outseg );

				FREE_PT( newpp, ap->a_resource );
				newpp = lastpp;
			}  else  {
				APPEND_PT( newpp, lastpp );
				if( !(ap->a_onehit < 0 && newpp->pt_regionp->reg_aircode != 0) )
					hits_avail += 2;
			}

			RT_CHECK_SEG(newpp->pt_inseg);		/* sanity */
			RT_CHECK_SEG(newpp->pt_outseg);		/* sanity */
		}

		/* See if it's worthwhile breaking out of partition loop early */
		if( ap->a_onehit != 0 && HITS_TODO <= 0 )  {
			ret = 1;
			if( pp == InputHdp )
				reason = "a_onehit satisfied at bottom";
			else
				reason = "a_onehit satisfied early";
			goto out;
		}
	}
	if( ap->a_onehit != 0 && HITS_TODO <= 0 )  {
		ret = 1;
		reason = "a_onehit satisfied at end";
	} else {
		ret = 0;
		reason = "more partitions needed";
	}
out:
	if( RT_G_DEBUG&DEBUG_PARTITION )  {
		bu_log("rt_boolfinal() ret=%d, %s\n", ret, reason);
		rt_pr_partitions( ap->a_rt_i, FinalHdp, "rt_boolfinal: Final partition list at return:" );
		rt_pr_partitions( ap->a_rt_i, InputHdp, "rt_boolfinal: Input/pending partition list at return:" );
		bu_log("rt_boolfinal() ret=%d, %s\n", ret, reason);
	}
#if 0
	/* This is no longer a valid check!!! */
	/* Sanity check */
	if( RT_G_DEBUG && ap->a_onehit == 0 &&
	    InputHdp->pt_forw != InputHdp && enddist >= INFINITY )  {
		bu_log("rt_boolfinal() ret=%d, %s\n", ret, reason);
		rt_pr_partitions( ap->a_rt_i, FinalHdp, "rt_boolfinal: Final partition list at return:" );
		rt_pr_partitions( ap->a_rt_i, InputHdp, "rt_boolfinal: Input/pending partition list at return:" );
		rt_bomb("rt_boolfinal() failed to process InputHdp list\n");
	}
#endif
	return ret;
}

/*
 *  			R T _ B O O L E V A L
 *  
 *  Using a stack to recall state, evaluate a boolean expression
 *  without recursion.
 *
 *  For use with XOR, a pointer to the "first valid subtree" would
 *  be a useful addition, for rt_boolregions().
 *
 *  Returns -
 *	!0	tree is TRUE
 *	 0	tree is FALSE
 *	-1	tree is in error (GUARD)
 */
int
rt_booleval(register union tree *treep, struct partition *partp, struct region **trueregp, struct resource *resp)
                           	/* Tree to evaluate */
                        	/* Partition to evaluate */
             	           	/* XOR true (and overlap) return */
               	      		/* resource pointer for this CPU */
{
	static union tree tree_not[MAX_PSW];	/* for OP_NOT nodes */
	static union tree tree_guard[MAX_PSW];	/* for OP_GUARD nodes */
	static union tree tree_xnop[MAX_PSW];	/* for OP_XNOP nodes */
	register union tree **sp;
	register int ret;
	register union tree **stackend;

	RT_CK_TREE(treep);
	RT_CK_PT(partp);
	RT_CK_RESOURCE(resp);
	if( treep->tr_op != OP_XOR )
		trueregp[0] = treep->tr_regionp;
	else
		trueregp[0] = trueregp[1] = REGION_NULL;
	while( (sp = resp->re_boolstack) == (union tree **)0 )
		rt_grow_boolstack( resp );
	stackend = &(resp->re_boolstack[resp->re_boolslen]);
	*sp++ = TREE_NULL;
stack:
	switch( treep->tr_op )  {
	case OP_NOP:
		ret = 0;
		goto pop;
	case OP_SOLID:
		{
			register struct soltab *seek_stp = treep->tr_a.tu_stp;
			register struct seg **segpp;
			for( BU_PTBL_FOR( segpp, (struct seg **), &partp->pt_seglist ) )  {
				if( (*segpp)->seg_stp == seek_stp )  {
					ret = 1;
					goto pop;
				}
			}
			ret = 0;
		}
		goto pop;
	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		*sp++ = treep;
		if( sp >= stackend )  {
			register int off = sp - resp->re_boolstack;
			rt_grow_boolstack( resp );
			sp = &(resp->re_boolstack[off]);
			stackend = &(resp->re_boolstack[resp->re_boolslen]);
		}
		treep = treep->tr_b.tb_left;
		goto stack;
	default:
		bu_log("rt_booleval:  bad stack op x%x\n",treep->tr_op);
		return(TRUE);	/* screw up output */
	}
pop:
	if( (treep = *--sp) == TREE_NULL )
		return(ret);		/* top of tree again */
	/*
	 *  Here, each operation will look at the operation just
	 *  completed (the left branch of the tree generally),
	 *  and rewrite the top of the stack and/or branch
	 *  accordingly.
	 */
	switch( treep->tr_op )  {
	case OP_SOLID:
		bu_log("rt_booleval:  pop SOLID?\n");
		return(TRUE);	/* screw up output */
	case OP_UNION:
		if( ret )  goto pop;	/* TRUE, we are done */
		/* lhs was false, rewrite as rhs tree */
		treep = treep->tr_b.tb_right;
		goto stack;
	case OP_INTERSECT:
		if( !ret )  {
			ret = FALSE;
			goto pop;
		}
		/* lhs was true, rewrite as rhs tree */
		treep = treep->tr_b.tb_right;
		goto stack;
	case OP_SUBTRACT:
		if( !ret )  goto pop;	/* FALSE, we are done */
		/* lhs was true, rewrite as NOT of rhs tree */
		/* We introduce the special NOT operator here */
		tree_not[resp->re_cpu].tr_op = OP_NOT;
		*sp++ = &tree_not[resp->re_cpu];
		treep = treep->tr_b.tb_right;
		goto stack;
	case OP_NOT:
		/* Special operation for subtraction */
		ret = !ret;
		goto pop;
	case OP_XOR:
		if( ret )  {
			/* lhs was true, rhs better not be, or we have
			 * an overlap condition.  Rewrite as guard node
			 * followed by rhs.
			 */
			if( treep->tr_b.tb_left->tr_regionp )
				trueregp[0] = treep->tr_b.tb_left->tr_regionp;
			tree_guard[resp->re_cpu].tr_op = OP_GUARD;
			treep = treep->tr_b.tb_right;
			*sp++ = treep;		/* temp val for guard node */
			*sp++ = &tree_guard[resp->re_cpu];
		} else {
			/* lhs was false, rewrite as xnop node and
			 * result of rhs.
			 */
			tree_xnop[resp->re_cpu].tr_op = OP_XNOP;
			treep = treep->tr_b.tb_right;
			*sp++ = treep;		/* temp val for xnop */
			*sp++ = &tree_xnop[resp->re_cpu];
		}
		goto stack;
	case OP_GUARD:
		/*
		 *  Special operation for XOR.  lhs was true.
		 *  If rhs subtree was true, an
		 *  overlap condition exists (both sides of the XOR are
		 *  TRUE).  Return error condition.
		 *  If subtree is false, then return TRUE (from lhs).
		 */
		if( ret )  {
			/* stacked temp val: rhs */
			if( sp[-1]->tr_regionp )
				trueregp[1] = sp[-1]->tr_regionp;
			return(-1);	/* GUARD error */
		}
		ret = TRUE;
		sp--;			/* pop temp val */
		goto pop;
	case OP_XNOP:
		/*
		 *  Special NOP for XOR.  lhs was false.
		 *  If rhs is true, take note of it's regionp.
		 */
		sp--;			/* pop temp val */
		if( ret )  {
			if( (*sp)->tr_regionp )
				trueregp[0] = (*sp)->tr_regionp;
		}
		goto pop;
	default:
		bu_log("rt_booleval:  bad pop op x%x\n",treep->tr_op);
		return(TRUE);	/* screw up output */
	}
	/* NOTREACHED */
}

/*
 *			R T _ F D I F F
 *  
 *  Compares two floating point numbers.  If they are within "epsilon"
 *  of each other, they are considered the same.
 *  NOTE:  This is a "fuzzy" difference.  It is important NOT to
 *  use the results of this function in compound comparisons,
 *  because a return of 0 makes no statement about the PRECISE
 *  relationships between the two numbers.  Eg,
 *	if( rt_fdiff( a, b ) <= 0 )
 *  is poison!
 *
 *  Returns -
 *  	-1	if a < b
 *  	 0	if a ~= b
 *  	+1	if a > b
 */
int
rt_fdiff(double a, double b)
{
	FAST double diff;
	FAST double d;
	register int ret;

	/* d = Max(Abs(a),Abs(b)) */
	d = (a >= 0.0) ? a : -a;
	if( b >= 0.0 )  {
		if( b > d )  d = b;
	} else {
		if( (-b) > d )  d = (-b);
	}
	if( d <= 1.0e-6 )  {
		ret = 0;	/* both nearly zero */
		goto out;
	}
	if( d >= INFINITY )  {
		if( a == b )  {
			ret = 0;
			goto out;
		}
		if( a < b )  {
			ret = -1;
			goto out;
		}
		ret = 1;
		goto out;
	}
	if( (diff = a - b) < 0.0 )  diff = -diff;
	if( diff < 0.001 )  {
		ret = 0;	/* absolute difference is small, < 1/1000mm */
		goto out;
	}
	if( diff < 0.000001 * d )  {
		ret = 0;	/* relative difference is small, < 1ppm */
		goto out;
	}
	if( a < b )  {
		ret = -1;
		goto out;
	}
	ret = 1;
out:
	if(RT_G_DEBUG&DEBUG_FDIFF) bu_log("rt_fdiff(%.18e,%.18e)=%d\n", a, b, ret);
	return(ret);
}

/*
 *			R T _ R E L D I F F
 *
 * Compute the relative difference of two floating point numbers.
 *
 * Returns -
 *	0.0 if exactly the same, otherwise
 *	ratio of difference, relative to the larger of the two (range 0.0-1.0)
 */
double
rt_reldiff(double a, double b)
{
	FAST fastf_t	d;
	FAST fastf_t	diff;

	/* d = Max(Abs(a),Abs(b)) */
	d = (a >= 0.0) ? a : -a;
	if( b >= 0.0 )  {
		if( b > d )  d = b;
	} else {
		if( (-b) > d )  d = (-b);
	}
	if( d==0.0 )
		return( 0.0 );
	if( (diff = a - b) < 0.0 )  diff = -diff;
	return( diff / d );
}

/*
 *			R T _ G R O W _ B O O L S T A C K
 *
 *  Increase the size of re_boolstack to double the previous size.
 *  Depend on rt_realloc() to copy the previous data to the new area
 *  when the size is increased.
 *  Return the new pointer for what was previously the last element.
 */
void
rt_grow_boolstack(register struct resource *resp)
{
	if( resp->re_boolstack == (union tree **)0 || resp->re_boolslen <= 0 )  {
		resp->re_boolslen = 128;	/* default len */
		resp->re_boolstack = (union tree **)bu_malloc(
			sizeof(union tree *) * resp->re_boolslen,
			"initial boolstack");
	} else {
		resp->re_boolslen <<= 1;
		resp->re_boolstack = (union tree **)rt_realloc(
			(char *)resp->re_boolstack,
			sizeof(union tree *) * resp->re_boolslen,
			"extend boolstack" );
	}
}

/*
 *			R T _ P A R T I T I O N _ L E N
 *
 *  Return the length of a partition linked list.
 */
int
rt_partition_len( const struct partition *partheadp )
{
	register struct partition	*pp;
	register long	count = 0;

	pp = partheadp->pt_forw;
	if( pp == PT_NULL )
		return(0);		/* Header not initialized yet */
	for( ; pp != partheadp; pp = pp->pt_forw )  {
		if( pp->pt_magic != 0 )  {
			/* Partitions on the free queue have pt_magic = 0 */
			RT_CK_PT(pp);
		}
		if( ++count > 1000000 )  rt_bomb("partition length > 10000000 elements\n");
	}
	return( (int)count );
}


/*
 *			R T _ T R E E _ T E S T _ R E A D Y
 *
 *  Test to see if a region is ready to be evaluated over a given
 *  partition, i.e. if all the prerequisites have been satisfied.
 *
 *  Returns -
 *	!0	Region is ready for (correct) evaluation.
 *	0	Region is not ready
 */
int
rt_tree_test_ready(register const union tree *tp, register const struct bu_bitv *solidbits, register const struct region *regionp, register const struct partition *pp)
{
	RT_CK_TREE(tp);
	BU_CK_BITV(solidbits);
	RT_CK_REGION(regionp);
	RT_CK_PT(pp);

	switch( tp->tr_op )  {
	case OP_NOP:
		return 1;

	case OP_SOLID:
		if( BU_BITTEST( solidbits, tp->tr_a.tu_stp->st_bit ) )
			return 1;	/* This solid's been shot, segs are valid. */
		/*
		 *  This solid has not been shot yet.
		 */
		return 0;

	case OP_NOT:
		return !rt_tree_test_ready( tp->tr_b.tb_left, solidbits, regionp, pp );

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		if( !rt_tree_test_ready( tp->tr_b.tb_left, solidbits, regionp, pp ) )
			return 0;
		return rt_tree_test_ready( tp->tr_b.tb_right, solidbits, regionp, pp );

	default:
		rt_bomb("rt_tree_test_ready: bad op\n");
	}
	return 0;
}

/*
 *			R T _ B O O L _ P A R T I T I O N _ E L I G I B L E
 *
 *  If every solid in every region participating in this
 *  ray-partition has already been intersected with the ray,
 *  then this partition can be safely evaluated.
 *
 *  Returns -
 *	!0	Partition is ready for (correct) evaluation.
 *	0	Partition is not ready
 */
int
rt_bool_partition_eligible(register const struct bu_ptbl *regiontable, register const struct bu_bitv *solidbits, register const struct partition *pp)
{
	struct region **regpp;

	BU_CK_PTBL(regiontable);
	BU_CK_BITV(solidbits);
	RT_CK_PT(pp);

	for( BU_PTBL_FOR( regpp, (struct region **), regiontable ) )  {
		register struct region *regp;

		regp = *regpp;
		RT_CK_REGION(regp);

		/* Check region prerequisites */
		if( !rt_tree_test_ready( regp->reg_treetop, solidbits, regp, pp) )  {
			return 0;
		}
	}
	return 1;
}


/*
 *			R T _ T R E E _ M A X _ R A Y N U M
 *
 *  Find the maximum value of the raynum (seg_rayp->index)
 *  encountered in the segments contributing to this region.
 *
 *  Returns -
 *	#	Maximum ray index
 *	-1	If no rays are contributing segs for this region.
 */
int
rt_tree_max_raynum(register const union tree *tp, register const struct partition *pp)
{
	RT_CK_TREE(tp);
	RT_CK_PARTITION(pp);

	switch( tp->tr_op )  {
	case OP_NOP:
		return -1;

	case OP_SOLID:
		{
			register struct soltab *seek_stp = tp->tr_a.tu_stp;
			register struct seg **segpp;
			for( BU_PTBL_FOR( segpp, (struct seg **), &pp->pt_seglist ) )  {
				if( (*segpp)->seg_stp != seek_stp )  continue;
				return (*segpp)->seg_in.hit_rayp->index;
			}
		}
		/* Maybe it hasn't been shot yet, or ray missed */
		return -1;

	case OP_NOT:
		return rt_tree_max_raynum( tp->tr_b.tb_left, pp );

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		{
			int a = rt_tree_max_raynum( tp->tr_b.tb_left, pp );
			int b = rt_tree_max_raynum( tp->tr_b.tb_right, pp );
			if( a > b )  return a;
			return b;
		}
	default:
		bu_bomb("rt_tree_max_raynum: bad op\n");
	}
	return 0;
}

/*
 * XXX This routine seems to free things more than once.
 * For a temporary measure, don't free things.
 */
void
rt_rebuild_overlaps(struct partition *PartHdp, struct application *ap, int rebuild_fastgen_plates_only)
{
	struct partition	*pp, *next, *curr;
	struct region		*pp_reg;
	struct partition	*pp_open;
	struct bu_ptbl		open_parts;
	int			i, j;

/* rt_pr_partitions( ap->a_rt_i, PartHdp, "In rt_rebuild_overlaps:" ); */

	RT_CK_PT_HD(PartHdp);
	RT_CK_AP(ap);

	bu_ptbl_init( &open_parts, 0, "Open partitions" );

	pp = PartHdp->pt_forw;
	while( pp != PartHdp )
	{
		RT_CK_PARTITION(pp);
		next = pp->pt_forw;

		if( rebuild_fastgen_plates_only && pp->pt_regionp->reg_is_fastgen != REGION_FASTGEN_PLATE )
		{
			bu_ptbl_trunc( &open_parts, 0 );
			pp = next;
			continue;
		}

		for( i=0 ; i<BU_PTBL_END( &open_parts ) ; i++ )
		{
			int keep_open=0;

			if( !pp )
				break;

			pp_open = (struct partition *)BU_PTBL_GET( &open_parts, i );
			if( !pp_open )
				continue;
			RT_CK_PARTITION(pp_open);

			if( pp->pt_overlap_reg )
			{
				j = -1;
				while( (pp_reg = pp->pt_overlap_reg[++j]) )
				{
					if( pp_reg == (struct region *)(-1) )
						continue;
					RT_CK_REGION(pp_reg);

					if( pp_reg == pp_open->pt_regionp )
					{
						/* add this partition to pp_open */
						pp_open->pt_outseg = pp->pt_outseg;
						pp_open->pt_outhit = pp->pt_outhit;
						pp_open->pt_outflip = pp->pt_outflip;
						bu_ptbl_cat_uniq( &pp_open->pt_seglist, &pp->pt_seglist );

						/* mark it as used */
						pp->pt_overlap_reg[j] = (struct region *)(-1);
						if( pp_reg == pp->pt_regionp )
							pp->pt_regionp = (struct region *)NULL;

						/* keep pp_open open */
						keep_open = 1;
					}
				}
			}
			else
			{
				if( pp->pt_regionp == pp_open->pt_regionp && pp->pt_inhit->hit_dist <= pp_open->pt_outhit->hit_dist )
				{
					/* add this partition to pp_open */
					pp_open->pt_outseg = pp->pt_outseg;
					pp_open->pt_outhit = pp->pt_outhit;
					pp_open->pt_outflip = pp->pt_outflip;
					bu_ptbl_cat_uniq( &pp_open->pt_seglist, &pp->pt_seglist );

					/* eliminate this partition */
					BU_LIST_DEQUEUE( (struct bu_list *)pp )
					pp->pt_overlap_reg = NULL;	/* sanity */
#if 0
					FREE_PT( pp, ap->a_resource )
#endif
					pp = (struct partition *)NULL;

					/* keep pp_open open */
					keep_open = 1;
				}
			}

			if( !keep_open )
			{
				BU_PTBL_CLEAR_I( &open_parts, i );
			}
		}

		/* if all region claims have been removed, eliminate the partition */
		if( pp && pp->pt_overlap_reg )
		{
			int reg_count=0;

			/* count remaining region claims */
			j = -1;
			while( (pp_reg = pp->pt_overlap_reg[++j]) )
				if( pp_reg != (struct region *)(-1) )  {
					RT_CK_REGION(pp_reg);
					reg_count++;
				}

			if( !reg_count )
			{
				BU_LIST_DEQUEUE( (struct bu_list *)pp )
				bu_free( (char *)pp->pt_overlap_reg, "overlap list" );
				pp->pt_overlap_reg = NULL;	/* sanity */
#if 0
				FREE_PT( pp, ap->a_resource )
#endif
				pp = (struct partition *)NULL;
			}
		}

		/* any remaining region claims must produce new partitions */
		if( pp )
		{
			if( pp->pt_overlap_reg )
			{
				j = -1;
				curr = pp;
				while( (pp_reg = pp->pt_overlap_reg[++j]) )
				{
					struct partition *new_pp;

					if( pp_reg == (struct region *)(-1) )
						continue;
					RT_CK_REGION(pp_reg);

					if( rebuild_fastgen_plates_only && 
						pp_reg->reg_is_fastgen != REGION_FASTGEN_PLATE )
							continue;

					/* if the original partition is available, just use it */
					if( !pp->pt_regionp || pp->pt_regionp == pp_reg )
					{
						pp->pt_regionp = pp_reg;
						bu_ptbl_ins( &open_parts, (long *)pp );
					}
					else
					{
						/* create a new partition, link it to the end of the current pp,
						 * and add it to the open list */
						RT_DUP_PT( ap->a_rt_i, new_pp, pp, ap->a_resource )
						new_pp->pt_regionp = pp_reg;
						new_pp->pt_overlap_reg = (struct region **)NULL;
						BU_LIST_APPEND( (struct bu_list *)curr, (struct bu_list *)new_pp )
						bu_ptbl_ins( &open_parts, (long *)new_pp );
						curr = new_pp;
					}
				}
			}
			else
			{
				if( rebuild_fastgen_plates_only )
				{
					if( pp->pt_regionp->reg_is_fastgen == REGION_FASTGEN_PLATE )
					{
						bu_ptbl_ins( &open_parts, (long *)pp );
					}
				}
				else
				{
					bu_ptbl_ins( &open_parts, (long *)pp );
				}
			}
			if( pp->pt_overlap_reg )
			{
				bu_free( (char *)pp->pt_overlap_reg, "overlap list" );
				pp->pt_overlap_reg = (struct region **)NULL;
			}
		}
		pp = next;
	}

	bu_ptbl_free( &open_parts );

/* rt_pr_partitions( ap->a_rt_i, PartHdp, "partitions at end of rt_rebuild_overlaps:" ); */

}
@


11.65
log
@change conf.h to a wrapped config.h
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/bool.c,v 11.64 2004/04/05 08:48:56 morrison Exp $ (ARL)";
@


11.64
log
@merge of ansi-6-0-branch into HEAD
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d35 5
a39 1
#include "conf.h"
@


11.63
log
@update copyright to include span through 2003
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.62 2003/08/02 23:15:19 butler Exp $ (ARL)";
d75 1
a75 4
rt_weave0seg( segp, PartHdp, ap )
struct seg		*segp;
struct partition	*PartHdp;
struct application	*ap;
d181 1
a181 5
rt_boolweave( out_hd, in_hd, PartHdp, ap )
struct seg		*out_hd;
struct seg		*in_hd;
struct partition	*PartHdp;
struct application	*ap;
d642 1
a642 7
_rt_defoverlap( ap, pp, reg1, reg2, pheadp, verbose )
register struct application	*ap;
register struct partition	*pp;
struct region			*reg1;
struct region			*reg2;
struct partition		*pheadp;
register int			verbose;
d682 1
a682 8
rt_defoverlap (ap, pp, reg1, reg2, pheadp)

register struct application	*ap;
register struct partition	*pp;
struct region			*reg1;
struct region			*reg2;
struct partition		*pheadp;

d698 1
a698 8
rt_overlap_quietly (ap, pp, reg1, reg2, pheadp)

register struct application	*ap;
register struct partition	*pp;
struct region			*reg1;
struct region			*reg2;
struct partition		*pheadp;

d716 1
a716 4
rt_get_region_seglist_for_partition( sl, pp, regp )
struct bu_ptbl	*sl;
const struct partition *pp;
const struct region *regp;
d751 1
a751 4
rt_fastgen_vol_vol_overlap( fr1, fr2, pp )
struct region **fr1;
struct region **fr2;
const struct partition *pp;
d833 1
a833 5
rt_fastgen_plate_vol_overlap( fr1, fr2, pp, ap )
struct region **fr1;
struct region **fr2;
struct partition *pp;
struct application *ap;
d913 1
a913 4
rt_default_multioverlap(struct application	*ap,
			struct partition	*pp,
			struct bu_ptbl		*regiontable,
			struct partition	*InputHdp)
d1122 1
a1122 5
rt_silent_logoverlap( ap, pp, regiontable, InputHdp )
struct application	*ap;
const struct partition	*pp;
const struct bu_ptbl	*regiontable;
const struct partition	*InputHdp;
d1140 1
a1140 5
rt_default_logoverlap( ap, pp, regiontable, InputHdp )
struct application	*ap;
const struct partition	*pp;
const struct bu_ptbl	*regiontable;
const struct partition	*InputHdp;
d1309 1
a1309 7
rt_boolfinal( InputHdp, FinalHdp, startdist, enddist, regiontable, ap, solidbits )
struct partition *InputHdp;
struct partition *FinalHdp;
fastf_t startdist, enddist;
struct bu_ptbl	*regiontable;
struct application *ap;
const struct bu_bitv	*solidbits;
d1753 5
a1757 5
rt_booleval( treep, partp, trueregp, resp )
register union tree *treep;	/* Tree to evaluate */
struct partition *partp;	/* Partition to evaluate */
struct region	**trueregp;	/* XOR true (and overlap) return */
struct resource	*resp;		/* resource pointer for this CPU */
d1925 1
a1925 2
rt_fdiff( a, b )
double a, b;
d1983 1
a1983 2
rt_reldiff( a, b )
double	a, b;
d2010 1
a2010 2
rt_grow_boolstack( resp )
register struct resource	*resp;
d2062 1
a2062 5
rt_tree_test_ready( tp, solidbits, regionp, pp )
register const union tree	*tp;
register const struct bu_bitv	*solidbits;
register const struct region	*regionp;
register const struct partition	*pp;
d2110 1
a2110 4
rt_bool_partition_eligible(regiontable, solidbits, pp)
register const struct bu_ptbl	*regiontable;
register const struct bu_bitv	*solidbits;
register const struct partition	*pp;
d2144 1
a2144 3
rt_tree_max_raynum( tp, pp )
register const union tree	*tp;
register const struct partition	*pp;
d2189 1
a2189 4
rt_rebuild_overlaps( PartHdp, ap, rebuild_fastgen_plates_only )
struct partition	*PartHdp;
struct application	*ap;
int			rebuild_fastgen_plates_only;
@


11.62
log
@ANSI C declaration change
@
text
@d28 1
a28 1
 *	This software is Copyright (C) 1985-1996 by the United States Army
d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.61 2002/08/20 17:07:54 jra Exp $ (ARL)";
@


11.62.4.1
log
@merge from HEAD
@
text
@d28 1
a28 1
 *	This software is Copyright (C) 1985-2004 by the United States Army
d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.63 2004/02/02 17:39:14 morrison Exp $ (ARL)";
@


11.62.4.2
log
@merge from head
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.62.4.1 2004/02/12 18:37:38 erikg Exp $ (ARL)";
@


11.62.2.1
log
@Change overlap reporting to be silent by default
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.62 2003/08/02 23:15:19 butler Exp $ (ARL)";
a1199 1

d1394 1
a1394 2
	    ap->a_logoverlap = rt_silent_logoverlap;

@


11.61
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.59 2002/05/07 14:59:18 jra Exp $ (ARL)";
d944 4
d950 4
a953 5
rt_default_multioverlap( ap, pp, regiontable, InputHdp )
struct application	*ap;
struct partition	*pp;
struct bu_ptbl		*regiontable;
struct partition	*InputHdp;
d1030 1
a1030 1
		/* Finally, think up some way to pass plate/plate overlaps on */
@


11.61.4.1
log
@sync to HEAD...
@
text
@d28 1
a28 1
 *	This software is Copyright (C) 1985-2004 by the United States Army
d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/bool.c,v 11.63 2004/02/02 17:39:14 morrison Exp $ (ARL)";
a943 4
 *
 *  InputHdp is the list of partitions up to this point.  It allows us
 *  to look at the regions that have come before in deciding what to do
 *
d946 5
a950 4
rt_default_multioverlap(struct application	*ap,
			struct partition	*pp,
			struct bu_ptbl		*regiontable,
			struct partition	*InputHdp)
d1027 1
a1027 1
		/* Finally, think up a way to pass plate/plate overlaps on */
@


11.61.6.1
log
@updated for merging
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.62 2003/08/02 23:15:19 butler Exp $ (ARL)";
a943 4
 *
 *  InputHdp is the list of partitions up to this point.  It allows us
 *  to look at the regions that have come before in deciding what to do
 *
d946 5
a950 4
rt_default_multioverlap(struct application	*ap,
			struct partition	*pp,
			struct bu_ptbl		*regiontable,
			struct partition	*InputHdp)
d1027 1
a1027 1
		/* Finally, think up a way to pass plate/plate overlaps on */
@


11.61.2.1
log
@Initial ANSIfication
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.61 2002/08/20 17:07:54 jra Exp $ (ARL)";
d75 4
a78 1
rt_weave0seg(struct seg *segp, struct partition *PartHdp, struct application *ap)
d184 5
a188 1
rt_boolweave(struct seg *out_hd, struct seg *in_hd, struct partition *PartHdp, struct application *ap)
d649 7
a655 1
_rt_defoverlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *pheadp, register int verbose)
d695 8
a702 1
rt_defoverlap (register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *pheadp)
d718 8
a725 1
rt_overlap_quietly (register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *pheadp)
d743 4
a746 1
rt_get_region_seglist_for_partition(struct bu_ptbl *sl, const struct partition *pp, const struct region *regp)
d781 4
a784 1
rt_fastgen_vol_vol_overlap(struct region **fr1, struct region **fr2, const struct partition *pp)
d866 5
a870 1
rt_fastgen_plate_vol_overlap(struct region **fr1, struct region **fr2, struct partition *pp, struct application *ap)
d946 5
a950 1
rt_default_multioverlap(struct application *ap, struct partition *pp, struct bu_ptbl *regiontable, struct partition *InputHdp)
d1159 5
a1163 1
rt_silent_logoverlap(struct application *ap, const struct partition *pp, const struct bu_ptbl *regiontable, const struct partition *InputHdp)
d1181 5
a1185 1
rt_default_logoverlap(struct application *ap, const struct partition *pp, const struct bu_ptbl *regiontable, const struct partition *InputHdp)
d1354 7
a1360 1
rt_boolfinal(struct partition *InputHdp, struct partition *FinalHdp, fastf_t startdist, fastf_t enddist, struct bu_ptbl *regiontable, struct application *ap, const struct bu_bitv *solidbits)
d1804 5
a1808 5
rt_booleval(register union tree *treep, struct partition *partp, struct region **trueregp, struct resource *resp)
                           	/* Tree to evaluate */
                        	/* Partition to evaluate */
             	           	/* XOR true (and overlap) return */
               	      		/* resource pointer for this CPU */
d1976 2
a1977 1
rt_fdiff(double a, double b)
d2035 2
a2036 1
rt_reldiff(double a, double b)
d2063 2
a2064 1
rt_grow_boolstack(register struct resource *resp)
d2116 5
a2120 1
rt_tree_test_ready(register const union tree *tp, register const struct bu_bitv *solidbits, register const struct region *regionp, register const struct partition *pp)
d2168 4
a2171 1
rt_bool_partition_eligible(register const struct bu_ptbl *regiontable, register const struct bu_bitv *solidbits, register const struct partition *pp)
d2205 3
a2207 1
rt_tree_max_raynum(register const union tree *tp, register const struct partition *pp)
d2252 4
a2255 1
rt_rebuild_overlaps(struct partition *PartHdp, struct application *ap, int rebuild_fastgen_plates_only)
@


11.61.2.2
log
@sync branch with HEAD
@
text
@d28 1
a28 1
 *	This software is Copyright (C) 1985-2004 by the United States Army
d32 1
a32 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
a906 4
 *
 *  InputHdp is the list of partitions up to this point.  It allows us
 *  to look at the regions that have come before in deciding what to do
 *
d986 1
a986 1
		/* Finally, think up a way to pass plate/plate overlaps on */
@


11.60
log
@Converted from K&R to ANSI C - RFH
@
text
@d75 4
a78 1
rt_weave0seg(struct seg *segp, struct partition *PartHdp, struct application *ap)
d184 5
a188 1
rt_boolweave(struct seg *out_hd, struct seg *in_hd, struct partition *PartHdp, struct application *ap)
d649 7
a655 1
_rt_defoverlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *pheadp, register int verbose)
d695 8
a702 1
rt_defoverlap (register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *pheadp)
d718 8
a725 1
rt_overlap_quietly (register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *pheadp)
d743 4
a746 1
rt_get_region_seglist_for_partition(struct bu_ptbl *sl, const struct partition *pp, const struct region *regp)
d781 4
a784 1
rt_fastgen_vol_vol_overlap(struct region **fr1, struct region **fr2, const struct partition *pp)
d866 5
a870 1
rt_fastgen_plate_vol_overlap(struct region **fr1, struct region **fr2, struct partition *pp, struct application *ap)
d946 5
a950 1
rt_default_multioverlap(struct application *ap, struct partition *pp, struct bu_ptbl *regiontable, struct partition *InputHdp)
d1159 5
a1163 1
rt_silent_logoverlap(struct application *ap, const struct partition *pp, const struct bu_ptbl *regiontable, const struct partition *InputHdp)
d1181 5
a1185 1
rt_default_logoverlap(struct application *ap, const struct partition *pp, const struct bu_ptbl *regiontable, const struct partition *InputHdp)
d1354 7
a1360 1
rt_boolfinal(struct partition *InputHdp, struct partition *FinalHdp, fastf_t startdist, fastf_t enddist, struct bu_ptbl *regiontable, struct application *ap, const struct bu_bitv *solidbits)
d1804 5
a1808 5
rt_booleval(register union tree *treep, struct partition *partp, struct region **trueregp, struct resource *resp)
                           	/* Tree to evaluate */
                        	/* Partition to evaluate */
             	           	/* XOR true (and overlap) return */
               	      		/* resource pointer for this CPU */
d1976 2
a1977 1
rt_fdiff(double a, double b)
d2035 2
a2036 1
rt_reldiff(double a, double b)
d2063 2
a2064 1
rt_grow_boolstack(register struct resource *resp)
d2116 5
a2120 1
rt_tree_test_ready(register const union tree *tp, register const struct bu_bitv *solidbits, register const struct region *regionp, register const struct partition *pp)
d2168 4
a2171 1
rt_bool_partition_eligible(register const struct bu_ptbl *regiontable, register const struct bu_bitv *solidbits, register const struct partition *pp)
d2205 3
a2207 1
rt_tree_max_raynum(register const union tree *tp, register const struct partition *pp)
d2252 4
a2255 1
rt_rebuild_overlaps(struct partition *PartHdp, struct application *ap, int rebuild_fastgen_plates_only)
@


11.59
log
@Fixed a bug in rt_boolweave(). It was moving a partition start point, but sometimes that new start point
was before the previous partition end point. Fix avoids this.
Changed format of output to get more precision.
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.58 2002/01/10 18:12:40 butler Exp $ (ARL)";
d75 1
a75 4
rt_weave0seg( segp, PartHdp, ap )
struct seg		*segp;
struct partition	*PartHdp;
struct application	*ap;
d181 1
a181 5
rt_boolweave( out_hd, in_hd, PartHdp, ap )
struct seg		*out_hd;
struct seg		*in_hd;
struct partition	*PartHdp;
struct application	*ap;
d642 1
a642 7
_rt_defoverlap( ap, pp, reg1, reg2, pheadp, verbose )
register struct application	*ap;
register struct partition	*pp;
struct region			*reg1;
struct region			*reg2;
struct partition		*pheadp;
register int			verbose;
d682 1
a682 8
rt_defoverlap (ap, pp, reg1, reg2, pheadp)

register struct application	*ap;
register struct partition	*pp;
struct region			*reg1;
struct region			*reg2;
struct partition		*pheadp;

d698 1
a698 8
rt_overlap_quietly (ap, pp, reg1, reg2, pheadp)

register struct application	*ap;
register struct partition	*pp;
struct region			*reg1;
struct region			*reg2;
struct partition		*pheadp;

d716 1
a716 4
rt_get_region_seglist_for_partition( sl, pp, regp )
struct bu_ptbl	*sl;
const struct partition *pp;
const struct region *regp;
d751 1
a751 4
rt_fastgen_vol_vol_overlap( fr1, fr2, pp )
struct region **fr1;
struct region **fr2;
const struct partition *pp;
d833 1
a833 5
rt_fastgen_plate_vol_overlap( fr1, fr2, pp, ap )
struct region **fr1;
struct region **fr2;
struct partition *pp;
struct application *ap;
d909 1
a909 5
rt_default_multioverlap( ap, pp, regiontable, InputHdp )
struct application	*ap;
struct partition	*pp;
struct bu_ptbl		*regiontable;
struct partition	*InputHdp;
d1118 1
a1118 5
rt_silent_logoverlap( ap, pp, regiontable, InputHdp )
struct application	*ap;
const struct partition	*pp;
const struct bu_ptbl	*regiontable;
const struct partition	*InputHdp;
d1136 1
a1136 5
rt_default_logoverlap( ap, pp, regiontable, InputHdp )
struct application	*ap;
const struct partition	*pp;
const struct bu_ptbl	*regiontable;
const struct partition	*InputHdp;
d1305 1
a1305 7
rt_boolfinal( InputHdp, FinalHdp, startdist, enddist, regiontable, ap, solidbits )
struct partition *InputHdp;
struct partition *FinalHdp;
fastf_t startdist, enddist;
struct bu_ptbl	*regiontable;
struct application *ap;
const struct bu_bitv	*solidbits;
d1749 5
a1753 5
rt_booleval( treep, partp, trueregp, resp )
register union tree *treep;	/* Tree to evaluate */
struct partition *partp;	/* Partition to evaluate */
struct region	**trueregp;	/* XOR true (and overlap) return */
struct resource	*resp;		/* resource pointer for this CPU */
d1921 1
a1921 2
rt_fdiff( a, b )
double a, b;
d1979 1
a1979 2
rt_reldiff( a, b )
double	a, b;
d2006 1
a2006 2
rt_grow_boolstack( resp )
register struct resource	*resp;
d2058 1
a2058 5
rt_tree_test_ready( tp, solidbits, regionp, pp )
register const union tree	*tp;
register const struct bu_bitv	*solidbits;
register const struct region	*regionp;
register const struct partition	*pp;
d2106 1
a2106 4
rt_bool_partition_eligible(regiontable, solidbits, pp)
register const struct bu_ptbl	*regiontable;
register const struct bu_bitv	*solidbits;
register const struct partition	*pp;
d2140 1
a2140 3
rt_tree_max_raynum( tp, pp )
register const union tree	*tp;
register const struct partition	*pp;
d2185 1
a2185 4
rt_rebuild_overlaps( PartHdp, ap, rebuild_fastgen_plates_only )
struct partition	*PartHdp;
struct application	*ap;
int			rebuild_fastgen_plates_only;
@


11.58
log
@Changed word "solids" to indicate "prims" or primitives"
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.57 2001/09/10 19:39:00 jra Exp $ (ARL)";
d366 1
a366 1
				bu_log( "	remaining input segment: (%g - %g)\n",
d368 1
a368 1
				bu_log( "	current partition: (%g - %g)\n",
d433 7
a439 1
				if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("seg starts within p. Split p at seg start, advance.\n");
d458 11
a468 6
				if( NEAR_ZERO(diff, tol_dist) &&
				    diff < 0 )  {
					if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("changing partition start point to segment start point\n");
					pp->pt_inseg = segp;
					pp->pt_inhit = &segp->seg_in;
					pp->pt_inflip = 0;
d528 7
a534 1
					if(RT_G_DEBUG&DEBUG_PARTITION) bu_log("start together, seg shorter than partition\n");
d1480 1
a1480 1
				bu_log("rt_boolfinal:  sorting defect %e > %e! x%d y%d lvl%d\n",
d1483 3
a1485 1
					ap->a_x, ap->a_y, ap->a_level );
@


11.57
log
@rt_rebuild_overlaps() was merging discontinuous partitions
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.56 2001/05/17 20:05:23 morrison Exp $ (ARL)";
d1438 1
a1438 1
				"rt_boolfinal:  Zero thickness partition, solids %s %s (%.18e,%.18e) x%d y%d lvl%d\n",
@


11.56
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.55 2001/04/20 22:29:40 morrison Exp $ (ARL)";
d2305 1
a2305 1
				if( pp->pt_regionp == pp_open->pt_regionp )
@


11.55
log
@CONST to const
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.54 2001/04/11 12:43:35 jra Exp $ (ARL)";
d92 1
a92 1
	if(rt_g.debug&DEBUG_PARTITION)  {
d113 1
a113 1
		if(rt_g.debug&DEBUG_PARTITION) bu_log("0-len segment ends before start of first partition.\n");
d127 1
a127 1
			if(rt_g.debug&DEBUG_PARTITION) bu_log("0-len segment ends right at start of existing partition.\n");
d133 1
a133 1
			if(rt_g.debug&DEBUG_PARTITION) bu_log("0-len segment ends right at end of existing partition.\n");
d138 1
a138 1
			if(rt_g.debug&DEBUG_PARTITION) bu_log("0-len segment in the middle of existing partition.\n");
d144 1
a144 1
			if(rt_g.debug&DEBUG_PARTITION) bu_log("0-len segment after existing partition, but before next partition.\n");
d206 1
a206 1
	if(rt_g.debug&DEBUG_PARTITION)  {
d223 1
a223 1
		if(rt_g.debug&DEBUG_PARTITION)  {
d290 1
a290 1
			if(rt_g.debug&DEBUG_PARTITION) bu_log("No partitions yet, segment forms first partition\n");
d301 1
a301 1
					if(rt_g.debug&DEBUG_PARTITION)  {
d314 1
a314 1
			if(rt_g.debug&DEBUG_PARTITION)  {
d339 1
a339 1
			if(rt_g.debug&DEBUG_PARTITION)  {
d364 1
a364 1
			if(rt_g.debug&DEBUG_PARTITION) {
d381 1
a381 1
				if(rt_g.debug&DEBUG_PARTITION)  {
d388 1
a388 1
			if(rt_g.debug&DEBUG_PARTITION)  rt_pr_pt(rtip, pp);
d400 1
a400 1
				if(rt_g.debug&DEBUG_PARTITION)  {
d433 1
a433 1
				if(rt_g.debug&DEBUG_PARTITION) bu_log("seg starts within p. Split p at seg start, advance.\n");
d454 1
a454 1
					if(rt_g.debug&DEBUG_PARTITION) bu_log("changing partition start point to segment start point\n");
d460 1
a460 1
				if(rt_g.debug&DEBUG_PARTITION) bu_log("equal_start\n");
d483 1
a483 1
					if(rt_g.debug&DEBUG_PARTITION) bu_log("seg spans partition and extends beyond it\n");
d495 1
a495 1
					if(rt_g.debug&DEBUG_PARTITION) bu_log("same start&end\n");
d517 1
a517 1
					if(rt_g.debug&DEBUG_PARTITION) bu_log("start together, seg shorter than partition\n");
d551 1
a551 1
					if(rt_g.debug&DEBUG_PARTITION) bu_log("seg between 2 partitions\n");
d573 1
a573 1
					if(rt_g.debug&DEBUG_PARTITION) bu_log("seg ends at partition start, fuse\n");
d591 1
a591 1
				if(rt_g.debug&DEBUG_PARTITION) bu_log("insert seg before p start, ends after p ends.  Making new partition for initial portion.\n");
d603 1
a603 1
		if(rt_g.debug&DEBUG_PARTITION) bu_log("seg extends beyond partition end\n");
d614 1
a614 1
		if(rt_g.debug&DEBUG_PARTITION)
d617 1
a617 1
	if(rt_g.debug&DEBUG_PARTITION)
d780 1
a780 1
	if(rt_g.debug&DEBUG_PARTITION) bu_log("Resolving FASTGEN volume/volume overlap: %s %s\n", (*fr1)->reg_name, (*fr2)->reg_name);
d863 1
a863 1
	if(rt_g.debug&DEBUG_PARTITION) bu_log("Resolving FASTGEN plate/volume overlap: %s %s\n", (*fr1)->reg_name, (*fr2)->reg_name);
d965 1
a965 1
		if(rt_g.debug&DEBUG_PARTITION)  {
d1092 1
a1092 1
/* if(rt_g.debug&DEBUG_PARTITION) */
d1115 1
a1115 1
			if(rt_g.debug&DEBUG_PARTITION)  bu_log("rt_default_multioverlap:  overlap code=0, partition=x%x deleted\n", pp);
d1121 1
a1121 1
			if(rt_g.debug&DEBUG_PARTITION)  bu_log("rt_default_multioverlap:  overlap policy=1, code=%d, p retained in region=%s\n",
d1129 1
a1129 1
			if(rt_g.debug&DEBUG_PARTITION)  bu_log("rt_default_multioverlap:  overlap policy!=(0,1) code=%d, p retained in region=%s\n",
d1364 1
a1364 1
	if(rt_g.debug&DEBUG_PARTITION)  {
d1411 1
a1411 1
			if(rt_g.debug&DEBUG_PARTITION)  {
d1425 1
a1425 1
		if(rt_g.debug&DEBUG_PARTITION)  {
d1437 1
a1437 1
			if(rt_g.debug&DEBUG_PARTITION)  bu_log(
d1459 1
a1459 1
				if(rt_g.debug&DEBUG_PARTITION)  bu_log("rt_boolfinal:  fusing 2 partitions x%x x%x\n",
d1467 1
a1467 1
				if( !(rt_g.debug & DEBUG_PARTITION) )
d1483 1
a1483 1
			if(rt_g.debug&DEBUG_PARTITION)bu_log(
d1501 1
a1501 1
			if(rt_g.debug&DEBUG_PARTITION)bu_log(
d1517 1
a1517 1
			if(rt_g.debug&DEBUG_PARTITION)bu_log(
d1543 1
a1543 1
			if(rt_g.debug&DEBUG_PARTITION)
d1552 1
a1552 1
		if(rt_g.debug&DEBUG_PARTITION)  {
d1565 1
a1565 1
			if(rt_g.debug&DEBUG_PARTITION)bu_log(
d1578 1
a1578 1
			if(rt_g.debug&DEBUG_PARTITION)bu_log(
d1590 1
a1590 1
				if(rt_g.debug&DEBUG_PARTITION)  {
d1599 1
a1599 1
					if(rt_g.debug&DEBUG_PARTITION) bu_log("TRUE (all union)\n");
d1606 1
a1606 1
					if(rt_g.debug&DEBUG_PARTITION) bu_log("FALSE\n");
d1612 1
a1612 1
				if(rt_g.debug&DEBUG_PARTITION) bu_log("TRUE (eval)\n");
d1617 1
a1617 1
		if(rt_g.debug&DEBUG_PARTITION)  bu_log("rt_boolfinal:  claiming_regions=%d (%g <-> %g)\n",
d1620 1
a1620 1
			if(rt_g.debug&DEBUG_PARTITION)bu_log("rt_boolfinal moving past partition x%x\n", pp);
d1630 1
a1630 1
			if(rt_g.debug&DEBUG_PARTITION)
d1661 1
a1661 1
				if(rt_g.debug&DEBUG_PARTITION)bu_log("rt_boolfinal discarding overlap partition x%x\n", pp);
d1679 1
a1679 1
			if(rt_g.debug&DEBUG_PARTITION )
d1705 1
a1705 1
				if(rt_g.debug&DEBUG_PARTITION)bu_log("rt_boolfinal 'exact match', extending last partition, discarding x%x\n", newpp);
d1709 1
a1709 1
				if(rt_g.debug&DEBUG_PARTITION)bu_log("rt_boolfinal collapsing %x %x\n", lastpp, newpp);
d1750 1
a1750 1
	if( rt_g.debug&DEBUG_PARTITION )  {
d1759 1
a1759 1
	if( rt_g.debug && ap->a_onehit == 0 &&
d2002 1
a2002 1
	if(rt_g.debug&DEBUG_FDIFF) bu_log("rt_fdiff(%.18e,%.18e)=%d\n", a, b, ret);
@


11.54
log
@Eliminated an erroneous check at the end of rt_boolfinal()
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.53 2001/03/19 22:19:56 butler Exp $ (ARL)";
d54 5
a58 5
int rt_tree_max_raynum(register CONST union tree *,
		       register CONST struct partition *);
int rt_bool_partition_eligible(register CONST struct bu_ptbl *,
			       register CONST struct bu_bitv *,
			       register CONST struct partition *);
d728 2
a729 2
CONST struct partition *pp;
CONST struct region *regp;
d731 1
a731 1
	CONST struct seg **segpp;
d736 2
a737 2
	for( BU_PTBL_FOR( segpp, (CONST struct seg **), &pp->pt_seglist ) )  {
		CONST struct region **srpp;
d741 1
a741 1
		for( BU_PTBL_FOR( srpp, (CONST struct region **), &(*segpp)->seg_stp->st_regions ) )  {
d767 1
a767 1
CONST struct partition *pp;
d770 2
a771 2
	CONST struct seg *s1 = (CONST struct seg *)NULL;
	CONST struct seg *s2 = (CONST struct seg *)NULL;
d1144 3
a1146 3
CONST struct partition	*pp;
CONST struct bu_ptbl	*regiontable;
CONST struct partition	*InputHdp;
d1166 3
a1168 3
CONST struct partition	*pp;
CONST struct bu_ptbl	*regiontable;
CONST struct partition	*InputHdp;
d1343 1
a1343 1
CONST struct bu_bitv	*solidbits;
d2098 4
a2101 4
register CONST union tree	*tp;
register CONST struct bu_bitv	*solidbits;
register CONST struct region	*regionp;
register CONST struct partition	*pp;
d2150 3
a2152 3
register CONST struct bu_ptbl	*regiontable;
register CONST struct bu_bitv	*solidbits;
register CONST struct partition	*pp;
d2187 2
a2188 2
register CONST union tree	*tp;
register CONST struct partition	*pp;
@


11.53
log
@patches to merge 5.3 into 6.0
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/bool.c,v 11.52 2001/02/23 15:11:11 jra Exp $ (ARL)";
d1756 2
a1757 1

d1766 1
a1766 1

@


11.52
log
@Fixed bug in rt_boolweave(). Input segment start point was being fused to
current partition end point even if segment start was within tolerance of partition start.
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.51 2001/01/12 16:45:18 jra Exp $ (ARL)";
d194 1
d196 1
a196 1
	FAST fastf_t	tol_dist;
d207 1
d226 1
d237 1
d364 9
d770 2
a771 1
	CONST struct seg *s1, *s2;
a802 1

d1542 3
d1617 2
a1618 2
		if(rt_g.debug&DEBUG_PARTITION)  bu_log("rt_boolfinal:  claiming_regions=%d\n",
			claiming_regions);
d1630 2
a1631 1
			if(rt_g.debug&DEBUG_PARTITION)  bu_log("rt_boolfinal:  invoking a_multioverlap() pp=x%x\n", pp);
d1679 3
a1681 1

@


11.51
log
@rt_boolfinal() was evaluating regions too soon in cases where
the partition extended beyond the current space cut box. Can
only do that if onehit == 1.
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.50 2001/01/09 14:17:05 jra Exp $ (ARL)";
d194 1
a194 1
	FAST fastf_t		diff;
d350 5
d360 2
a361 2
			diff = lasthit->hit_dist - pp->pt_outhit->hit_dist;
			if( diff > tol_dist )  {
d376 2
a377 1
			if( diff > -(tol_dist) )  {
a398 1
			diff = lasthit->hit_dist - pp->pt_inhit->hit_dist;
@


11.50
log
@Mods to fix FASTGEN vol/vol overlap handling
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.49 2000/10/25 21:12:08 mike Exp $ (ARL)";
d1501 1
a1501 1
			if( ap->a_onehit == 0 )  {
d1503 1
a1503 1
				reason = "a_onehit=0, trace remaining boxes";
@


11.49
log
@
Need to compare _contents_ of overlap tables, not pointers,
to determine equality.
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.48 2000/10/24 18:38:34 mike Exp $ (ARL)";
d599 2
d753 2
d756 1
d766 9
a774 6
	if( BU_PTBL_LEN(&sl1) > 1 )  {
		struct seg **segpp;
		bu_log("rt_fastgen_vol_vol_overlap(), tricked by %s having more than one segment\n", (*fr1)->reg_name );
		for( BU_PTBL_FOR( segpp, (struct seg **), &sl1 ) )
			rt_pr_seg(*segpp);
bu_bomb("vol_vol s1");
d776 7
a782 6
	if( BU_PTBL_LEN(&sl2) > 1 )  {
		struct seg **segpp;
		bu_log("rt_fastgen_vol_vol_overlap(), tricked by %s having more than one segment\n", (*fr2)->reg_name );
		for( BU_PTBL_FOR( segpp, (struct seg **), &sl2 ) )
			rt_pr_seg(*segpp);
bu_bomb("vol_vol s2");
a784 2
	s1 = (CONST struct seg *)BU_PTBL_GET(&sl1, 0);
	s2 = (CONST struct seg *)BU_PTBL_GET(&sl2, 0);
d1226 5
a1230 1
	if( a == NULL || b == NULL )  bu_bomb("rt_overlap_tables_equal() NULL pointer\n");
@


11.48
log
@
Added rt_partition_len() to raytrace.h
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.47 2000/08/30 14:51:52 jra Exp $ (ARL)";
d1203 38
d1665 3
a1667 1
			      lastpp->pt_overlap_reg == newpp->pt_overlap_reg )
@


11.47
log
@Fixed a bug in rt_fastgen_vol_vol_overlap()
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.46 2000/07/13 02:36:25 cjohnson Exp $ (ARL)";
d1991 1
a1991 2
rt_partition_len( partheadp )
register struct partition	*partheadp;
@


11.46
log
@LINT from gcc -Wall
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.45 2000/07/10 23:01:25 mike Exp $ (ARL)";
d795 1
a795 1
		 * take the region who's seg started at start of partition
d797 1
a797 1
		if( s1->seg_in.hit_dist == pp->pt_inhit->hit_dist )  {
@


11.45
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.44 2000/06/23 03:26:07 butler Exp $ (ARL)";
d38 5
d46 1
d54 9
a62 1

d601 44
a693 44
 *			_ R T _ D E F O V E R L A P
 *
 *  The guts of the default overlap callback.
 *  Returns -
 *	 0	to eliminate partition with overlap entirely
 *	 1	to retain partition in output list, claimed by reg1
 *	 2	to retain partition in output list, claimed by reg2
 */
HIDDEN int
_rt_defoverlap( ap, pp, reg1, reg2, pheadp, verbose )
register struct application	*ap;
register struct partition	*pp;
struct region			*reg1;
struct region			*reg2;
struct partition		*pheadp;
register int			verbose;
{
	RT_CK_AP(ap);
	RT_CK_PT(pp);
	RT_CK_REGION(reg1);
	RT_CK_REGION(reg2);

	/*
	 *  Apply heuristics as to which region should claim partition.
	 */
	if( reg1->reg_aircode != 0 )  {
		/* reg1 was air, replace with reg2 */
		return 2;
	}
	if( pp->pt_back != pheadp ) {
		/* Repeat a prev region, if that is a choice */
		if( pp->pt_back->pt_regionp == reg1 )
			return 1;
		if( pp->pt_back->pt_regionp == reg2 )
			return 2;
	}

	/* To provide some consistency from ray to ray, use lowest bit # */
	if( reg1->reg_bit < reg2->reg_bit )
		return 1;
	return 2;
}

/*
d1026 2
d1096 1
a1096 1
			if(rt_g.debug&DEBUG_PARTITION)  bu_log("rt_default_multioverlap:  overlap code=%d, p retained in region=%s\n",
d1104 1
a1104 1
			if(rt_g.debug&DEBUG_PARTITION)  bu_log("rt_default_multioverlap:  overlap code=%d, p retained in region=%s\n",
@


11.44
log
@Modified rt_booleval so that multiple threads would not use the same
"static union tree" variables.  This gives us a 20% performance increase
on the SGI Origin 2000.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.43 2000/06/02 22:46:56 mike Exp $ (ARL)";
@


11.44.2.1
log
@Fixed a bug in rt_fastgen_vol_vol_overlap()
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.44 2000/06/23 03:26:07 butler Exp $ (ARL)";
d781 1
a781 1
		 * take the region with largest inhit
d783 1
a783 1
		if( s1->seg_in.hit_dist >= s2->seg_in.hit_dist )  {
@


11.44.2.2
log
@Mod to rt_fastgen_vol_vol_overlap() to allow regions with more than one segment
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.44.2.1 2000/08/30 14:56:02 jra Exp $ (ARL)";
a736 2
	fastf_t s1_in_dist;
	fastf_t s2_in_dist;
a737 1
	struct seg **segpp;
d747 6
a752 9
	s1_in_dist = MAX_FASTF;
	s2_in_dist = MAX_FASTF;
	for( BU_PTBL_FOR( segpp, (struct seg **), &sl1 ) )
	{
		if( (*segpp)->seg_in.hit_dist < s1_in_dist )
		{
			s1 = (*segpp);
			s1_in_dist = s1->seg_in.hit_dist;
		}
d754 6
a759 7
	for( BU_PTBL_FOR( segpp, (struct seg **), &sl2 ) )
	{
		if( (*segpp)->seg_in.hit_dist < s2_in_dist )
		{
			s2 = (*segpp);
			s2_in_dist = s2->seg_in.hit_dist;
		}
d761 3
@


11.44.2.3
log
@rt_boolfinal() was evaluating too soon for partitions that extended
beyond the end of current space box. Can only do that for onehit == 1.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.44.2.2 2000/12/27 15:06:37 jra Exp $ (ARL)";
d1440 1
a1440 1
			if( ap->a_onehit != 1 )  {
d1442 1
a1442 1
				reason = "a_onehit != 1, trace remaining boxes";
a1462 3

			if(rt_g.debug&DEBUG_PARTITION)
				bu_log( "Building region table:\n" );
d1535 2
a1536 2
		if(rt_g.debug&DEBUG_PARTITION)  bu_log("rt_boolfinal:  claiming_regions=%d (%g <-> %g)\n",
			claiming_regions, pp->pt_inhit->hit_dist, pp->pt_outhit->hit_dist);
d1548 1
a1548 2
			if(rt_g.debug&DEBUG_PARTITION)
bu_log("rt_boolfinal:  invoking a_multioverlap() pp=x%x\n", pp);
d1596 1
a1596 3
			if(rt_g.debug&DEBUG_PARTITION )
				bu_log( "Appending partition to result queue: %g, %g\n",
					pp->pt_inhit->hit_dist, pp->pt_outhit->hit_dist );
@


11.44.2.4
log
@Fixed bug in rt_boolweave(). It was fusing start point of an input segment to
the end of a partition, even if it was also within tolerance of the partition start.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.44.2.3 2001/01/12 16:41:12 jra Exp $ (ARL)";
d180 2
a181 2
	FAST fastf_t		diff, diff_se;
	FAST fastf_t		tol_dist;
a191 1
		bu_log( "In rt_boolweave, tol_dist = %g\n", tol_dist );
a209 1
			bu_log( "************ Input segment:\n" );
a219 1
			bu_log( "***********\n" );
a335 5
		/* Loop through current partition list weaving the current input segment
		 * into the list. The following three variables keep track of the current
		 * starting point of the input segment. The starting point of the segment
		 * moves to higher hit_dist values (as it is woven in) until it is entirely consumed.
		 */
d341 2
a342 11
			if(rt_g.debug&DEBUG_PARTITION) {
				bu_log( "At start of loop:\n" );
				bu_log( "	remaining input segment: (%g - %g)\n",
					lasthit->hit_dist, segp->seg_out.hit_dist );
				bu_log( "	current partition: (%g - %g)\n",
					pp->pt_inhit->hit_dist, pp->pt_outhit->hit_dist );
				rt_pr_partitions( rtip, PartHdp, "At start of loop" );
			}

			diff_se = lasthit->hit_dist - pp->pt_outhit->hit_dist;
			if( diff_se > tol_dist )  {
d357 1
a357 2
			diff = lasthit->hit_dist - pp->pt_inhit->hit_dist;
			if( diff_se > -(tol_dist) && diff > tol_dist )  {
d379 1
@


11.43
log
@
Modified error checking to not freak out on infinite solids on the VAX.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.42 2000/05/24 04:15:52 mike Exp $ (ARL)";
d1699 3
a1701 3
	static union tree tree_not;		/* for OP_NOT nodes */
	static union tree tree_guard;		/* for OP_GUARD nodes */
	static union tree tree_xnop;		/* for OP_XNOP nodes */
d1782 2
a1783 2
		tree_not.tr_op = OP_NOT;
		*sp++ = &tree_not;
d1798 1
a1798 1
			tree_guard.tr_op = OP_GUARD;
d1801 1
a1801 1
			*sp++ = &tree_guard;
d1806 1
a1806 1
			tree_xnop.tr_op = OP_XNOP;
d1809 1
a1809 1
			*sp++ = &tree_xnop;
@


11.42
log
@
Eliminated memory corruption by double-freeing,
at the cost of a potential memory leak.
This is an improvement for now. :-)
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.41 2000/05/23 03:43:49 mike Exp $ (ARL)";
d236 2
a237 1
		if( !(segp->seg_in.hit_dist >= -INFINITY &&
@


11.41
log
@
Added lots more debugging, enabled by the debug bit.
Also fixed one bug, in which some FASTGEN plate/volume overlaps would
be missed.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.40 2000/05/19 20:07:12 jra Exp $ (ARL)";
d2136 4
d2162 1
d2182 1
d2191 1
d2223 2
d2226 1
d2248 2
a2249 1
				if( pp_reg != (struct region *)(-1) )
d2251 1
d2257 2
d2260 1
d2278 1
@


11.40
log
@Fixed a small bug in rt_rebuild_overlaps()
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.39 2000/05/19 18:02:13 jra Exp $ (ARL)";
d740 3
a742 3
#if 0
	bu_log("Resolving FASTGEN volume/volume overlap: %s %s\n", (*fr1)->reg_name, (*fr2)->reg_name);
#endif
d746 14
a759 2
	if( BU_PTBL_LEN(&sl1) > 1 )  bu_log("rt_fastgen_vol_vol_overlap(), tricked by %s having more than one segment\n", (*fr1)->reg_name );
	if( BU_PTBL_LEN(&sl2) > 1 )  bu_log("rt_fastgen_vol_vol_overlap(), tricked by %s having more than one segment\n", (*fr2)->reg_name );
d822 3
a824 3
#if 0
	bu_log("Resolving FASTGEN plate/volume overlap: %s %s\n", (*fr1)->reg_name, (*fr2)->reg_name);
#endif
d924 9
a932 3
#if 0
		bu_log("I see %d FASTGEN overlaps in this partition\n", n_fastgen);
#endif
d959 1
a959 1
			for( fr2 = fr1-1; fr2 >= (struct region **)BU_PTBL_BASEADDR(regiontable); fr2-- )  {
@


11.39
log
@Fixed a bug in rt_rebuild_overlaps() and eliminated an old debug print
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.38 2000/05/18 20:20:11 jra Exp $ (ARL)";
d2251 1
a2251 1
					if( !pp->pt_regionp )
@


11.38
log
@
Added rt_rebuild_overlaps()
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.37 2000/05/18 19:56:23 mike Exp $ (ARL)";
a959 1
		if( n_fastgen > 1 )  bu_log("WARNING: no code to resolve FASTGEN plate/plate overlaps (Yet)\n");
d2152 3
@


11.37
log
@
Added member rti_save_overlaps.
If 1, fill in pt_overlap_reg, and modify rt_boolweave()'s processing
of adjacent partitions from the same region in presence of an overlap.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.36 2000/05/18 15:48:38 mike Exp $ (ARL)";
d740 1
a740 1

d742 1
a742 1

d810 1
a810 1

d812 1
a812 1

d912 1
a912 1

d914 1
a914 1

d2117 177
@


11.36
log
@
Expanded criterion for "exact match".
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.35 2000/05/16 23:45:09 mike Exp $ (ARL)";
d969 1
a969 1
	if( BU_PTBL_LEN(regiontable) > 1 )  {
d1592 2
a1593 1
			    lastpp->pt_overlap_reg == newpp->pt_overlap_reg
d1595 1
a1595 1
				/* same region, extend last final partition */
@


11.35
log
@
Support for Fastgen plate/plate overlap.
Also supports other inquiries into overlaps.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.34 2000/03/31 18:04:07 jra Exp $ (ARL)";
d1591 2
a1592 1
				ap->a_rt_i->rti_tol.dist )
d1595 1
@


11.34
log
@Made a slight change to the FASTGEN Volume-Volume overlap logic, and fixed a typo in rt_fastgen_plate_vol_overlap()
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.33 2000/03/31 04:55:39 mike Exp $ (ARL)";
d800 1
a800 1
CONST struct partition *pp;
d803 1
a803 1
	CONST struct partition *prev;
d969 20
d1010 12
@


11.33
log
@
Small misunderstanding with types of BU_PTBL_FOR.
Fixed horrid bug in libbu/ptbl.c (revision 1.9).
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.32 2000/03/28 04:06:21 mike Exp $ (ARL)";
a733 1
	fastf_t d1, d2;
a753 3
	d1 = s1->seg_out.hit_dist - s1->seg_in.hit_dist;
	d2 = s2->seg_out.hit_dist - s2->seg_in.hit_dist;

d758 2
a759 3
		/* Resolve overlap in favor of region with longest seg */
		/* XXX or is rule "take region with lowest inhit? */
		if( d1 > d2 )  {
d768 1
a768 3
		 * This partition is wide enough, resolve in favor of
		 * the shorter segment.
		 * XXX or is it: the region who's seg started at start of partition?
d770 1
a770 1
		if( d1 < d2 )  {
d814 1
a814 1
	if( pp->pt_magic == PT_HD_MAGIC )  {
@


11.32
log
@
Initial support for FASTGEN overlap resolution.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.31 2000/03/28 02:18:45 mike Exp $ (ARL)";
d696 1
a696 1
	CONST struct seg *segp;
d701 2
a702 2
	for( BU_PTBL_FOR( segp, (CONST struct seg *), &pp->pt_seglist ) )  {
		CONST struct region *srp;
d704 1
a704 1
		RT_CK_SEG(segp);
d706 2
a707 2
		for( BU_PTBL_FOR( srp, (CONST struct region *), &segp->seg_stp->st_regions ) )  {
			RT_CK_REGION(srp);
d709 1
a709 1
			if( srp != regp )  continue;
d711 1
a711 1
			bu_ptbl_ins_unique( sl, (long *)segp );
d963 1
d968 3
d978 1
@


11.31
log
@
Moved overlap logging into separate user callback invoked via a_logoverlap()
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.30 2000/03/18 01:51:50 mike Exp $ (ARL)";
d679 184
d909 1
a909 1
		if( regp->reg_is_fastgen )  n_fastgen++;
d912 4
d917 3
a919 1
		/* Resolve all FASTGEN overlaps first. */
d921 46
@


11.30
log
@
Added code to detect presence of overlapping FASTGEN regions.
More to come.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.29 2000/02/01 20:57:27 mike Exp $ (ARL)";
d74 1
a74 1
	RT_CHECK_RTI(ap->a_rt_i);
d187 1
a187 1
	RT_CHECK_RTI(ap->a_rt_i);
d652 4
a655 40
	point_t	pt;
	static long count = 0;		/* Not PARALLEL, shouldn't hurt */
	register fastf_t depth;

	RT_CHECK_PT(pp);

	if (!verbose)	goto choose;
	    
	depth = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;
	if( depth <= 0 )  goto choose;	/* Retain 0-thickness partition */

	/* Attempt to control tremendous error outputs */
	if( ++count > 100 )  {
		if( (count%100) != 3 )  goto choose;
		bu_log("(overlaps omitted)\n");
	}

	VJOIN1( pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist,
		ap->a_ray.r_dir );
	/*
	 * An application program might want to add code here
	 * to ignore "small" overlap depths.
	 * Print all verbiage in one call to bu_log(),
	 * so that messages will be grouped together in parallel runs.
	 */
	bu_log( "\n\
OVERLAP1: %s\n\
OVERLAP2: %s\n\
OVERLAP3: dist=(%g,%g) isol=%s osol=%s\n\
OVERLAP4: depth %.5fmm at (%g,%g,%g) x%d y%d lvl%d\n",
		reg1->reg_name,
		reg2->reg_name,
		pp->pt_inhit->hit_dist, pp->pt_outhit->hit_dist,
		pp->pt_inseg->seg_stp->st_name,
		pp->pt_outseg->seg_stp->st_name,
		depth, pt[X], pt[Y], pt[Z],
		ap->a_x, ap->a_y, ap->a_level );
#if 0
	rt_pr_partitions( ap->a_rt_i, pheadp, "Entire ray containing overlap");
#endif
a659 1
choose:
d695 3
d811 92
d994 1
a994 1
	RT_CHECK_RTI(ap->a_rt_i);
d1006 3
d1262 1
d1328 1
a1328 1
				RT_CHECK_PT(lastpp);
d1700 1
a1700 1
			RT_CHECK_PT(pp);
d1728 1
a1728 1
	RT_CHECK_PT(pp);
d1780 1
a1780 1
	RT_CHECK_PT(pp);
@


11.29
log
@
Performance enhancement for case where boolean tree is all unions.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.28 2000/01/22 04:01:39 mike Exp $ (ARL)";
d741 2
d753 13
@


11.28
log
@
Added extra magic number checking
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.27 1999/11/13 05:12:04 mike Exp $ (ARL)";
d1152 6
d1166 1
a1166 1
				if(rt_g.debug&DEBUG_PARTITION) bu_log("TRUE\n");
@


11.27
log
@
Added rt_tree_max_raynum(), as support for
resolving potential overlaps in ray bundles.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.26 1999/11/12 20:54:17 mike Exp $ (ARL)";
d204 1
d206 1
@


11.26
log
@
Changed from pt_solids_hit to pt_seglist; more general.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.25 1999/11/11 04:18:27 mike Exp $ (ARL)";
d687 3
a689 1
rt_pr_partitions( ap->a_rt_i, pheadp, "Entire partition containing overlap");
d706 1
d762 1
a762 1
			code = 2;
d765 1
a765 1
			code = 1;
d770 21
a790 10
		    	code = 1;
		} else {
		   	/*
		   	 *  Hand overlap to old-style application-specific
		   	 *  overlap handler, or default.
			 *	0 = destroy partition,
			 *	1 = keep part, claiming region=lastregion
			 *	2 = keep part, claiming region=regp
		   	 */
			code = ap->a_overlap(ap, pp, lastregion, regp, InputHdp);
d793 9
d811 1
d817 1
d1709 54
@


11.25
log
@
Added rt_default_multioverlap() routine, and matching a_multioverlap()
in application structure.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.24 1999/10/30 03:54:00 mike Exp $ (ARL)";
d93 1
a93 1
		bu_ptbl_ins_unique( &pp->pt_solids_hit, (long *)segp->seg_stp );
d132 1
a132 1
			bu_ptbl_ins_unique( &npp->pt_solids_hit, (long *)segp->seg_stp );
d263 1
a263 1
			bu_ptbl_ins_unique( &pp->pt_solids_hit, (long *)segp->seg_stp );
d284 1
a284 1
					bu_ptbl_ins_unique( &newpp->pt_solids_hit, (long *)segp->seg_stp );
d297 1
a297 1
			bu_ptbl_ins_unique( &newpp->pt_solids_hit, (long *)segp->seg_stp );
d324 1
a324 1
			bu_ptbl_ins_unique( &pp->pt_solids_hit, (long *)segp->seg_stp );
d384 1
a384 1
				 *  Note:  pt_solids_hit will be updated in equal_start.
d444 1
a444 1
					bu_ptbl_ins_unique( &pp->pt_solids_hit, (long *)segp->seg_stp );
d459 1
a459 1
					bu_ptbl_ins_unique( &pp->pt_solids_hit, (long *)segp->seg_stp );
d474 1
a474 1
					bu_ptbl_ins_unique( &newpp->pt_solids_hit, (long *)segp->seg_stp );
d497 1
a497 1
				bu_ptbl_ins_unique( &newpp->pt_solids_hit, (long *)segp->seg_stp );
d570 1
a570 1
		bu_ptbl_ins_unique( &newpp->pt_solids_hit, (long *)segp->seg_stp );
d687 1
d1066 1
a1066 1
		 *  For each solid that lies in this partition,
d1071 3
a1073 3
			struct soltab **spp;
			for( BU_PTBL_FOR(spp, (struct soltab **), &pp->pt_solids_hit) )  {
				struct soltab	*stp = *spp;
d1229 2
a1230 4
				bu_ptbl_ins_unique( &lastpp->pt_solids_hit,
					(long *)newpp->pt_inseg->seg_stp );
				bu_ptbl_ins_unique( &lastpp->pt_solids_hit,
					(long *)newpp->pt_outseg->seg_stp );
d1326 9
a1334 1
		if( bu_ptbl_locate( &partp->pt_solids_hit, (long *)treep->tr_a.tu_stp ) == -1 )
d1336 1
a1336 2
		else
			ret = 1;
@


11.24
log
@
Added magic numbers for ray, hit, and application structures.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.23 1999/05/27 18:52:55 mike Exp $ (ARL)";
d710 92
d902 3
d1110 3
a1112 4
		struct region **regpp;
		for( BU_PTBL_FOR( regpp, (struct region **), regiontable ) )  {
			register struct region *regp;
			int	code;
d1114 18
a1131 15
			regp = *regpp;
			RT_CK_REGION(regp);
			if(rt_g.debug&DEBUG_PARTITION)  {
				rt_pr_tree_val( regp->reg_treetop, pp, 2, 0 );
				rt_pr_tree_val( regp->reg_treetop, pp, 1, 0 );
				rt_pr_tree_val( regp->reg_treetop, pp, 0, 0 );
				bu_log("%.8x=bit%d, %s: ",
					regp, regp->reg_bit,
					regp->reg_name );
			}
			if( rt_booleval( regp->reg_treetop, pp, TrueRg,
			    ap->a_resource ) == FALSE )  {
				if(rt_g.debug&DEBUG_PARTITION) bu_log("FALSE\n");
				continue;
			} else {
d1133 1
a1133 46
			}
			/* This region claims partition */
			if( ++claiming_regions <= 1 )  {
				lastregion = regp;
				continue;
			}

			/*
			 * Two or more regions claim this partition
			 */
			if( lastregion->reg_aircode != 0 && regp->reg_aircode == 0 )  {
				/* last region is air, replace with solid regp */
				code = 2;
			} else if( lastregion->reg_aircode == 0 && regp->reg_aircode != 0 )  {
				/* last region solid, regp is air, keep last */
				code = 1;
			} else if( lastregion->reg_aircode != 0 &&
			    regp->reg_aircode != 0 &&
			    regp->reg_aircode == lastregion->reg_aircode )  {
			    	/* both are same air, keep last */
			    	code = 1;
			} else {
			   	/*
			   	 *  Hand overlap to application-specific
			   	 *  overlap handler, or default.
				 *	0 = destroy partition,
				 *	1 = keep part, reg=lastregion
				 *	2 = keep part, reg=regp
			   	 */
			   	if( ap->a_overlap == RT_AFN_NULL )
			   		ap->a_overlap = rt_defoverlap;
				code = ap->a_overlap(ap, pp, lastregion, regp, InputHdp);
			}
			/* Implement the policy in "code" */
			if( code == 0 )  {
				/* zero => delete the partition.
				 * The dirty work happens below.
				 */
				if(rt_g.debug&DEBUG_PARTITION)  bu_log("rt_boolfinal:  overlap code=0, p deleted\n");
			} else if( code == 1 ) {
				/* Keep part, region = lastregion */
			    	claiming_regions--;	/* now = 1 */
				if(rt_g.debug&DEBUG_PARTITION)  bu_log("rt_boolfinal:  overlap code=%d, p retained in region=%s\n",
					code, lastregion->reg_name );
			} else {
				/* Keep part, region = regp */
a1134 3
			    	claiming_regions--;	/* now = 1 */
				if(rt_g.debug&DEBUG_PARTITION)  bu_log("rt_boolfinal:  overlap code=%d, p retained in region=%s\n",
					code, lastregion->reg_name );
a1135 1
		 }
d1140 2
a1141 1
			pp=pp->pt_forw;			/* onwards! */
d1147 2
a1148 2
			 *  Discard partition containing overlap.
			 *  Nothing further along the ray will fix it.
d1150 15
a1164 1
			register struct partition	*zap_pp;
d1166 20
a1185 6
			if(rt_g.debug&DEBUG_PARTITION)bu_log("rt_boolfinal discarding overlap partition x%x\n", pp);
			zap_pp = pp;
			pp = pp->pt_forw;		/* onwards! */
			DEQUEUE_PT( zap_pp );
			FREE_PT( zap_pp, ap->a_resource );
			continue;
@


11.23
log
@
sed4
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/bool.c,v 11.22 1998/03/24 08:39:25 mike Exp $ (ARL)";
d203 2
@


11.22
log
@Added support for a_no_booleans flag.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.21 1998/01/22 04:54:34 mike Exp mike $ (ARL)";
d1475 1
a1475 1
		resp->re_boolstack = (union tree **)rt_malloc(
@


11.21
log
@New sanity check only applies to a_onehit == 0 case.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.20 1998/01/22 04:05:23 mike Exp mike $ (ARL)";
d271 33
d802 6
d834 17
@


11.20
log
@fixed bug reported by JRA where some partitions got lost in the
rt_boolfinal() process.
Was due to a double pp = pp->pt_forw.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.19 1998/01/09 09:18:18 mike Exp mike $ (ARL)";
d1136 5
a1140 1
	if( InputHdp->pt_forw != InputHdp && enddist >= INFINITY )
d1142 1
@


11.19
log
@The a_onehit improvements in revision 11.17 resulted in many
more ray/solid intersections being performed than were done
in the Release 4.4 code; all the additional ones were unnecessary.
This resulted in a noticable code slowdown.
Now have much more precise checking of when a partition is
eligible for _correct_ evaluation, preventing bad results
as well as reducing un-needed intersections.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.18 1998/01/08 11:24:24 mike Exp mike $ (ARL)";
d802 1
a802 1
			bu_log("rt_boolfinal: (%g,%g) x%d y%d lvl%d\n",
d1031 2
d1047 1
a1047 1
			pp = pp->pt_forw;
d1064 1
a1064 1
			pp=pp->pt_forw;
a1110 1
		pp = pp->pt_forw;
d1129 1
d1131 1
d1134 4
@


11.18
log
@Added some notes.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.17 1997/08/29 00:51:59 mike Exp mike $ (ARL)";
d722 1
a722 1
 *  --- NOTES for improvements that haven't been implemented yet ---
d724 2
a725 2
 *  With a_onehit != 0, it is difficult to honor the 'enddist' value
 *  (and the a_ray_length value), and still get correct results.
d742 1
a742 1
rt_boolfinal( InputHdp, FinalHdp, startdist, enddist, regiontable, ap )
d748 1
d757 1
d767 1
d852 1
a852 6
		 *  If partition ends before current box starts,
		 *  discard it immediately.
		 *  If all the solids are properly located in the space
		 *  partitioning tree's cells, no intersection calculations
		 *  further forward on the ray should ever produce valid
		 *  segments or partitions earlier in the ray.
d854 2
a855 2
		 *  If partition is behind ray start point, also
		 *  discard it.
d857 1
a857 2
		if( pp->pt_outhit->hit_dist < startdist ||
		    pp->pt_outhit->hit_dist <= 0.001 /* milimeters */ )  {
d860 1
a860 1
				"discarding early partition x%x, out dist=%g\n",
d872 1
d888 2
d897 1
a897 1
				reason = "a_onehit=0, more partitions to go";
d900 4
a903 12
			if( HITS_TODO > 0 )  {
				ret = 0;
				reason = "a_onehit not satisfied yet";
				goto out;
			}
			/*  In this case, proceed as if pt_outhit was correct,
			 *  even though it probably is not.
			 *  Application asked for this behavior, and it
			 *  saves having to do more ray-tracing.
			 * XXX Note that this moves partitions onto final list
			 * XXX if they evaluate to TRUE!
			 */
d906 2
d925 29
a953 2
		if(rt_g.debug&DEBUG_PARTITION)
			bu_pr_ptbl( "regiontable", regiontable, 1 );
d1109 1
d1112 4
a1115 1
			reason = "a_onehit satisfied early";
d1119 1
a1119 1
	if( ap->a_onehit > 0 && HITS_TODO <= 0 )  {
d1442 89
@


11.17
log
@Fixed bug with over-eager a_onehit processing.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.16 1997/08/29 00:02:12 mike Exp mike $ (ARL)";
d720 20
@


11.16
log
@Changed bool_weave to print partition list upon starting,
to establish context.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.15 1997/03/04 06:58:10 mike Exp mike $ (ARL)";
d880 1
a880 1
			if( HITS_TODO > 1 )  {
d889 2
@


11.15
log
@Added 'reason' processing to rt_boolfinal() to aid comprehension
of debugging output.
Optimized to satisfy a_onehit early, when possible.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.14 1997/02/14 06:22:13 mike Exp mike $ (ARL)";
d191 4
a194 2
	if(rt_g.debug&DEBUG_PARTITION)
		bu_log("-------------------BOOL_WEAVE\n");
d209 1
d214 1
@


11.14
log
@if a_onehit is negative, it signals number of non-air hits needed.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.13 1996/09/27 08:27:30 mike Exp mike $ (ARL)";
d731 2
d742 5
a746 2
	if( enddist <= 0 )
		return(0);		/* not done, behind start point! */
d763 5
a767 2
		if( hits_avail >= hits_needed )
			return(1);		/* done */
d818 3
a820 1
				return(0);	/* give up */
d857 3
a859 1
			return(0);
d871 10
a880 4
			if( ap->a_onehit == 0 )
				return(0);
			if( HITS_TODO > 1 )
				return(0);
d1005 2
a1008 3
		 *  XXX Could there be sorting trouble on final call to
		 *  XXX boolfinal when a_onehit > 0??
		 *  XXX No, because input queue shouldn't be interesting on 2nd visit.
d1053 2
a1054 1
				hits_avail += 2;
d1061 6
a1066 2
		if( ap->a_onehit > 0 && HITS_TODO <= 0 )
			return(1);		/* done */
d1068 12
a1079 2
	if( rt_g.debug&DEBUG_PARTITION )
		rt_pr_partitions( ap->a_rt_i, FinalHdp, "rt_boolfinal: Partitions returned" );
d1081 1
a1081 1
	return(0);			/* not done */
@


11.13
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.12 1996/08/29 06:33:54 mike Exp mike $ (ARL)";
d694 1
a694 1
 *  information when a_onehit>0 and a_onehit is odd.
d701 1
a701 1
 *  If a_onehit > 0, the ray is traced through a_onehit hit points.
d709 1
d730 1
d733 1
a733 1
#define HITS_TODO	(ap->a_onehit - hits_avail)
d743 6
a748 1
	if( ap->a_onehit > 0 )  {
d754 2
d758 1
a758 1
		if( HITS_TODO <= 0 )
d859 1
a859 1
			if( ap->a_onehit <= 0 )
@


11.12
log
@Converted pt_solhits from a bit vector into a bu_ptbl.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.11 1996/08/28 10:03:46 mike Exp mike $ (ARL)";
d79 1
a79 1
		rt_log(
d99 1
a99 1
		if(rt_g.debug&DEBUG_PARTITION) rt_log("0-len segment ends before start of first partition.\n");
d113 1
a113 1
			if(rt_g.debug&DEBUG_PARTITION) rt_log("0-len segment ends right at start of existing partition.\n");
d119 1
a119 1
			if(rt_g.debug&DEBUG_PARTITION) rt_log("0-len segment ends right at end of existing partition.\n");
d124 1
a124 1
			if(rt_g.debug&DEBUG_PARTITION) rt_log("0-len segment in the middle of existing partition.\n");
d130 1
a130 1
			if(rt_g.debug&DEBUG_PARTITION) rt_log("0-len segment after existing partition, but before next partition.\n");
d192 2
a193 2
		rt_log("-------------------BOOL_WEAVE\n");
	while( RT_LIST_NON_EMPTY( &(in_hd->l) ) ) {
d199 1
a199 1
		segp = RT_LIST_FIRST( seg, &(in_hd->l) );
d215 2
a216 2
		RT_LIST_DEQUEUE( &(segp->l) );
		RT_LIST_INSERT( &(out_hd->l), &(segp->l) );
d230 1
a230 1
		    	rt_log("rt_boolweave:  Defective %s segment %s (%.18e,%.18e) %d,%d\n",
d240 1
a240 1
		    	rt_log("rt_boolweave:  Inside-out %s segment %s (%.18e,%.18e) %d,%d\n",
d263 1
a263 1
			if(rt_g.debug&DEBUG_PARTITION) rt_log("No partitions yet, segment forms first partition\n");
d280 1
a280 1
				rt_log("seg starts beyond last partition end. (%g,%g) Appending new partition\n",
d308 1
a308 1
					rt_log("seg start beyond partition end, skipping.  (%g,%g)\n",
d326 1
a326 1
					rt_log("seg start fused to partition end, diff=%g\n", diff);
d359 1
a359 1
				if(rt_g.debug&DEBUG_PARTITION) rt_log("seg starts within p. Split p at seg start, advance.\n");
d380 1
a380 1
					if(rt_g.debug&DEBUG_PARTITION) rt_log("changing partition start point to segment start point\n");
d386 1
a386 1
				if(rt_g.debug&DEBUG_PARTITION) rt_log("equal_start\n");
d409 1
a409 1
					if(rt_g.debug&DEBUG_PARTITION) rt_log("seg spans partition and extends beyond it\n");
d421 1
a421 1
					if(rt_g.debug&DEBUG_PARTITION) rt_log("same start&end\n");
d443 1
a443 1
					if(rt_g.debug&DEBUG_PARTITION) rt_log("start together, seg shorter than partition\n");
d477 1
a477 1
					if(rt_g.debug&DEBUG_PARTITION) rt_log("seg between 2 partitions\n");
d499 1
a499 1
					if(rt_g.debug&DEBUG_PARTITION) rt_log("seg ends at partition start, fuse\n");
d517 1
a517 1
				if(rt_g.debug&DEBUG_PARTITION) rt_log("insert seg before p start, ends after p ends.  Making new partition for initial portion.\n");
d529 1
a529 1
		if(rt_g.debug&DEBUG_PARTITION) rt_log("seg extends beyond partition end\n");
d625 1
a625 1
		rt_log("(overlaps omitted)\n");
d633 1
a633 1
	 * Print all verbiage in one call to rt_log(),
d636 1
a636 1
	rt_log( "\n\
d758 1
a758 1
			rt_log("rt_boolfinal: (%g,%g) x%d y%d lvl%d\n",
d769 1
a769 1
			if(rt_g.debug&DEBUG_PARTITION)  rt_log(
d782 1
a782 1
			rt_log("rt_boolfinal: inverted partition %.8x x%d y%d lvl%d\n",
d791 1
a791 1
				if(rt_g.debug&DEBUG_PARTITION)  rt_log("rt_boolfinal:  fusing 2 partitions x%x x%x\n",
d795 1
a795 1
				rt_log("rt_boolfinal:  sorting defect %e > %e! x%d y%d lvl%d\n",
d819 1
a819 1
			if(rt_g.debug&DEBUG_PARTITION)rt_log(
d836 1
a836 1
			if(rt_g.debug&DEBUG_PARTITION)rt_log(
d848 1
a848 1
			if(rt_g.debug&DEBUG_PARTITION)rt_log(
d894 1
a894 1
				rt_log("%.8x=bit%d, %s: ",
d900 1
a900 1
				if(rt_g.debug&DEBUG_PARTITION) rt_log("FALSE\n");
d903 1
a903 1
				if(rt_g.debug&DEBUG_PARTITION) rt_log("TRUE\n");
d942 1
a942 1
				if(rt_g.debug&DEBUG_PARTITION)  rt_log("rt_boolfinal:  overlap code=0, p deleted\n");
d946 1
a946 1
				if(rt_g.debug&DEBUG_PARTITION)  rt_log("rt_boolfinal:  overlap code=%d, p retained in region=%s\n",
d952 1
a952 1
				if(rt_g.debug&DEBUG_PARTITION)  rt_log("rt_boolfinal:  overlap code=%d, p retained in region=%s\n",
d969 1
a969 1
			if(rt_g.debug&DEBUG_PARTITION)rt_log("rt_boolfinal discarding overlap partition x%x\n", pp);
d1010 1
a1010 1
				if(rt_g.debug&DEBUG_PARTITION)rt_log("rt_boolfinal collapsing %x %x\n", lastpp, newpp);
d1107 1
a1107 1
		rt_log("rt_booleval:  bad stack op x%x\n",treep->tr_op);
d1121 1
a1121 1
		rt_log("rt_booleval:  pop SOLID?\n");
d1199 1
a1199 1
		rt_log("rt_booleval:  bad pop op x%x\n",treep->tr_op);
d1268 1
a1268 1
	if(rt_g.debug&DEBUG_FDIFF) rt_log("rt_fdiff(%.18e,%.18e)=%d\n", a, b, ret);
@


11.11
log
@st_regions is now a bu_ptbl, not a bitvector.
"regionbits" is also a bu_ptbl, not a bitvector.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.10 1996/08/28 04:02:56 mike Exp mike $ (ARL)";
d93 1
a93 1
		BITSET(pp->pt_solhit, segp->seg_stp->st_bit);
d132 1
a132 1
			BITSET(npp->pt_solhit, segp->seg_stp->st_bit);
d257 1
a257 1
			BITSET(pp->pt_solhit, segp->seg_stp->st_bit);
d285 1
a285 1
			BITSET(pp->pt_solhit, segp->seg_stp->st_bit);
d345 1
a345 1
				 *  Note:  pt_solhit will be marked in equal_start.
d350 1
a350 2
				GET_PT( rtip, newpp, res );
				COPY_PT( rtip, newpp, pp );
d405 1
a405 1
					BITSET(pp->pt_solhit, segp->seg_stp->st_bit);
d420 1
a420 1
					BITSET(pp->pt_solhit, segp->seg_stp->st_bit);
d433 1
a433 2
					GET_PT( rtip, newpp, res );
					COPY_PT( rtip, newpp,pp);
d435 1
a435 1
					BITSET(newpp->pt_solhit, segp->seg_stp->st_bit);
d458 1
a458 1
				BITSET(newpp->pt_solhit, segp->seg_stp->st_bit);
d531 1
a531 1
		BITSET(newpp->pt_solhit, segp->seg_stp->st_bit);
d717 1
a717 1
rt_boolfinal( InputHdp, FinalHdp, startdist, enddist, regionbits, ap )
d721 1
a721 1
struct bu_ptbl	*regionbits;
d735 1
a735 1
	BU_CK_PTBL(regionbits);
d862 1
a862 1
		bu_ptbl_reset(regionbits);
d866 2
a867 1
		 *  set (OR) that solid's region bit vector into "regionbits".
d869 8
a876 4
/* XXX Change pt_solhit over to a bu_ptbl too! */
		RT_BITV_LOOP_START( pp->pt_solhit, ap->a_rt_i->nsolids )  {
			struct soltab	*stp;
			register struct region	**regp;
a877 5
			stp = ap->a_rt_i->rti_Solids[RT_BITV_LOOP_INDEX];
			RT_CK_SOLTAB(stp);
			bu_ptbl_cat_uniq( regionbits, &stp->st_regions );
		} RT_BITV_LOOP_END;

d879 1
a879 1
			bu_pr_ptbl( "regionbits", regionbits, 1 );
d884 1
a884 1
		for( BU_PTBL_FOR( regpp, (struct region **), regionbits ) )  {
d1015 7
a1021 3
				/* Don't lose the fact that this partition (solid) contributed */
				BITSET( lastpp->pt_solhit, newpp->pt_inseg->seg_stp->st_bit);
				BITSET( lastpp->pt_solhit, newpp->pt_outseg->seg_stp->st_bit);
a1022 1

d1088 4
a1091 2
		ret = treep->tr_a.tu_stp->st_bit;	/* register temp */
		ret = BITTEST( partp->pt_solhit, ret );
@


11.10
log
@Changed to use bu_bitv() routines
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.9 1996/08/13 23:49:02 butler Exp mike $ (ARL)";
d723 1
a723 1
struct bu_bitv	*regionbits;
d737 1
a737 1
	BU_CK_BITV(regionbits);
d864 1
a864 1
		bu_bitv_clear(regionbits);
d870 1
d873 1
a873 3
			register int	words;
			register bitv_t *in;
			register bitv_t *out;
d877 1
a877 4
			BU_BITV_NBITS_CHECK(regionbits, stp->st_maxreg);
			RT_BITV_LOOP_START( stp->st_regions, stp->st_maxreg )  {
				BU_BITSET(regionbits, RT_BITV_LOOP_INDEX);
			} RT_BITV_LOOP_END;
d881 1
a881 1
			bu_pr_bitv( "regionbits", regionbits);
d884 3
a886 1
		BU_BITV_LOOP_START( regionbits )  {
d890 1
a890 1
			regp = ap->a_rt_i->Regions[BU_BITV_LOOP_INDEX];
d897 1
a897 1
					regp, BU_BITV_LOOP_INDEX,
d957 2
a958 1
		} BU_BITV_LOOP_END;
d1070 3
@


11.9
log
@pp->pt_solhit was not being updated with the list of participating solids
when partitions were combined.  Changed to set bits from "collapsing"
partitions in the "surviving partition".
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.8 1996/07/23 22:44:10 mike Exp butler $ (ARL)";
d723 1
a723 1
bitv_t *regionbits;
d737 1
d864 1
a864 1
		BITZERO( regionbits, ap->a_rt_i->nregions );
d877 5
a881 8
			/* It would be nice to validate stp here */
			words = RT_BITV_BITS2WORDS(stp->st_maxreg);
			in = stp->st_regions;
			out = regionbits;

#			include "noalias.h"
			while( words-- > 0 )
				*out++ |= *in++;
d885 1
a885 1
			rt_pr_bitv( "regionbits", regionbits, ap->a_rt_i->nregions);
d888 1
a888 1
		RT_BITV_LOOP_START( regionbits, ap->a_rt_i->nregions )  {
d892 2
a893 1
			regp = ap->a_rt_i->Regions[RT_BITV_LOOP_INDEX];
d899 2
a900 1
					regp, RT_BITV_LOOP_INDEX, regp->reg_name );
d959 1
a959 1
		} RT_BITV_LOOP_END;
@


11.8
log
@Fixed horrible bug of smashing hit_point values, seen with polysolids.
Reported by Keith Bowman.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d1017 6
@


11.7
log
@removed ap.a_ray_length from rt_boolfinal() (handled entirely in rt_shootray).
@
text
@d6 10
a15 1
 * Author -
d19 2
a20 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
d22 5
d28 2
a29 2
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
d32 1
a32 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.6 1996/06/12 13:33:09 jra Exp jra $ (BRL)";
d314 1
d325 3
a327 2
				VMOVE(lasthit->hit_point, pp->pt_outhit->hit_point);
				if(rt_g.debug&DEBUG_PARTITION)  rt_log("seg start fused to partition end\n");
a329 1
			if(rt_g.debug&DEBUG_PARTITION)  rt_pr_pt(rtip, pp);
a498 1
					VMOVE(newpp->pt_outhit->hit_point, pp->pt_inhit->hit_point);
@


11.6
log
@Added code to rt_boolfinal to stop when ray has been traced requested length.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.5 1996/03/29 21:35:21 mike Exp jra $ (BRL)";
a701 1
 *		or ray has been traced the reqested distance
a739 3

	if( ap->a_ray_length > 0.0 && startdist >= ap->a_ray_length )
		return( 1 );
@


11.5
log
@Print hit point explicitly.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.4 1995/12/06 17:27:45 pjt Exp mike $ (BRL)";
d702 1
d741 3
@


11.4
log
@The guts of the default overlap callback have been renamed
_rt_defoverlap() and given an additional parameter: verbose.
This static routine now has an applications interface consisting
of two 1-line wrappers:  rt_defoverlap() and rt_overlap_quietly().
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.3 1995/08/22 02:10:13 butler Exp $ (BRL)";
d189 2
d193 3
d197 2
@


11.3
log
@Tolerances raise their ugly head.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.2 1995/06/16 17:29:29 pjt Exp butler $ (BRL)";
d535 26
d563 23
a585 1
rt_defoverlap( ap, pp, reg1, reg2, pheadp )
d591 1
d599 2
@


11.2
log
@Added magic number checking to partition heads.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 11.1 1995/01/04 09:56:07 mike Rel4_4 pjt $ (BRL)";
d197 6
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 10.11 95/01/04 07:46:56 mike Exp $ (BRL)";
d60 1
d170 2
d658 2
@


10.11
log
@Cray C90 lint
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 10.10 94/12/29 17:20:00 mike Exp Locker: mike $ (BRL)";
@


10.10
log
@Reindented.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 10.9 94/12/28 14:06:58 gdurf Exp Locker: mike $ (BRL)";
a55 1
	FAST fastf_t		diff;
d646 1
a646 1
	LOCAL struct region *lastregion;
@


10.9
log
@Fixed "illegial initialization" (causing problems on sun4)
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 10.8 94/12/27 15:46:00 mike Exp Locker: gdurf $ (BRL)";
d57 1
a57 1
	FAST fastf_t	tol_dist;
@


10.8
log
@Added void
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 10.7 94/12/27 15:41:57 mike Exp Locker: mike $ (BRL)";
d57 1
a57 1
	FAST CONST fastf_t	tol_dist = rtip->rti_tol.dist;
d59 2
d168 3
a170 1
	FAST CONST fastf_t	tol_dist = rtip->rti_tol.dist;
@


10.7
log
@Expanded some of the comments slightly.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 10.6 94/12/27 15:35:52 mike Exp Locker: mike $ (BRL)";
d47 1
@


10.6
log
@Fixed bug report #256.
This leaves open the question of exactly how 0-length segments
which overlap existing partitions should be handled.  For now,
they are discarded.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/bool.c,v 10.5 94/12/21 16:02:42 pjt Exp $ (BRL)";
d230 1
a230 1
			if(rt_g.debug&DEBUG_PARTITION) rt_log("First partition\n");
d247 1
a247 1
				rt_log("seg starts beyond last part end. (%g,%g) Appending new part.\n",
d275 1
a275 1
					rt_log("seg start beyond part end, skipping.  (%g,%g)\n",
d318 1
a318 1
				/* new part. is the span before seg joins partition */
d376 1
a376 1
					if(rt_g.debug&DEBUG_PARTITION) rt_log("seg spans p and beyond\n");
d411 1
a411 1
					if(rt_g.debug&DEBUG_PARTITION) rt_log("start together, seg shorter\n");
d468 1
a468 1
					if(rt_g.debug&DEBUG_PARTITION) rt_log("seg ends at p start, fuse\n");
d486 1
a486 1
				if(rt_g.debug&DEBUG_PARTITION) rt_log("insert seg before p start, ends after p ends\n");
d498 1
a498 1
		if(rt_g.debug&DEBUG_PARTITION) rt_log("seg extends beyond p end\n");
d735 1
a735 1
				"discarding early part x%x, out dist=%g\n",
@


10.5
log
@Don't dereference pt_regionp before it has been filled in.

@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/bool.c,v 10.4 94/12/01 23:34:34 mike Exp Locker: pjt $ (BRL)";
d37 92
d164 2
a165 1
	fastf_t			diff;
a194 19
		/*
		 *  Force "very thin" segments to have exactly zero thickness.
		 *  If a zero thickness segment abutts another partition,
		 *  it will be fused in, later.
		 *  If it is free standing, then it will remain as a
		 *  zero thickness partition, which probably signals
		 *  going through some solid an odd number of times.
		 */
		diff = segp->seg_in.hit_dist - segp->seg_out.hit_dist;
		if( NEAR_ZERO( diff, ap->a_rt_i->rti_tol.dist ) )  {
			if(rt_g.debug&DEBUG_PARTITION)  rt_log(
				"rt_boolweave:  Zero thickness seg: %s (%.18e,%.18e) %d,%d\n",
				segp->seg_stp->st_name,
				segp->seg_in.hit_dist,
				segp->seg_out.hit_dist,
				segp->seg_in.hit_surfno,
				segp->seg_out.hit_surfno );
			segp->seg_out.hit_dist = segp->seg_in.hit_dist;
		}
d233 8
d267 1
a267 1
			if( diff > ap->a_rt_i->rti_tol.dist )  {
d281 1
a281 1
			if( diff > -(ap->a_rt_i->rti_tol.dist) )  {
d304 1
a304 1
			if( diff > ap->a_rt_i->rti_tol.dist )  {
d329 1
a329 1
			if( diff > -(ap->a_rt_i->rti_tol.dist) )  {
d345 1
a345 1
				if( NEAR_ZERO(diff, ap->a_rt_i->rti_tol.dist) &&
d363 1
a363 1
				if( diff > ap->a_rt_i->rti_tol.dist )  {
d379 1
a379 1
				if( diff > -(ap->a_rt_i->rti_tol.dist) )  {
d431 1
a431 1
				if( diff < -(ap->a_rt_i->rti_tol.dist) )  {
d448 1
a448 1
				if( diff < ap->a_rt_i->rti_tol.dist )  {
@


10.4
log
@Fixed bug #219, unsightly surface normals sometimes getting picked
when distances are within tol of each other.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 10.3 94/08/10 15:21:53 gdurf Exp Locker: mike $ (BRL)";
d588 1
a588 1
		RT_CHECK_PT(pp);
d603 3
a605 2
				"rt_boolfinal:  Zero thickness partition: %s (%.18e,%.18e) x%d y%d lvl%d\n",
				pp->pt_regionp->reg_name,
d828 1
@


10.3
log
@Add conf.h
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 10.2 1994/05/05 23:22:31 mike Exp gdurf $ (BRL)";
d164 5
a175 1
			if(rt_g.debug&DEBUG_PARTITION) rt_log("seg starts beyond part end\n");
d192 5
a196 1
				if(rt_g.debug&DEBUG_PARTITION)  rt_log("seg start beyond end, skipping\n");
d225 1
d248 22
d628 2
@


10.2
log
@Added extra diagnostics.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 10.1 91/10/12 06:39:54 mike Rel4_0 Locker: mike $ (BRL)";
d21 2
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.26 91/09/20 22:32:40 butler Exp $ (BRL)";
d111 1
a111 1
				"rt_boolweave:  Zero thickness seg: %s (%.18e,%.18e)\n",
d114 3
a116 1
				segp->seg_out.hit_dist );
d121 2
a122 1
		    	rt_log("rt_boolweave:  Defective segment %s (%.18e,%.18e)\n",
d125 3
a127 1
				segp->seg_out.hit_dist );
d131 2
a132 1
		    	rt_log("rt_boolweave:  Inside-out segment %s (%.18e,%.18e)\n",
d135 3
a137 1
				segp->seg_out.hit_dist );
d439 1
a439 1
	rt_log( "\
@


9.26
log
@removing the fuzz with lint
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.25 91/08/31 06:52:01 mike Exp $ (BRL)";
@


9.25
log
@Improved overlap handling by separating policy from mechanism.
Which of two overlapping regions is given claim to the partition
is now determined by the user's a_overlap handler, and the
library simply implements that choice.
The default overlap handler has several new heuristics to try and
make more consistent choices, which in at least some cases seems
to be the right thing to do.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.24 91/08/31 06:03:38 mike Exp $ (BRL)";
a168 1
			register int i;
@


9.24
log
@Improved debug messages, more logic in overlap handling.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.23 91/07/23 16:00:08 mike Exp $ (BRL)";
d398 2
a399 1
 *	!0	to retain partition in output list
d402 1
a402 1
rt_defoverlap( ap, pp, reg1, reg2 )
d407 1
d416 1
a416 1
	if( depth <= 0 )  return(1);	/* Retain 0-thickness partition */
d420 1
a420 1
		if( (count%100) != 3 )  return(1);
d435 1
a435 1
OVERLAP3: isol=%s osol=%s dist=(%g,%g)\n\
d439 1
a441 1
		pp->pt_inhit->hit_dist, pp->pt_outhit->hit_dist,
d444 20
a463 1
	return(1);
d681 1
d707 12
a718 8
			if((	(	regp->reg_aircode == 0
				    &&	lastregion->reg_aircode == 0 
				) /* Neither are air */
			     ||	(	regp->reg_aircode != 0
				   &&	lastregion->reg_aircode != 0
				   &&	regp->reg_aircode != lastregion->reg_aircode
				) /* Both are air, but different types */
			   ) )  {
d722 3
d728 13
a740 20
				if( ap->a_overlap(ap, pp, regp, lastregion) )  {
				    	/* non-zero => retain the partition */
					if( lastregion->reg_aircode != 0 )  {
						/* Last was air, replace */
						lastregion = regp;
					} else if( pp->pt_back != InputHdp ) {
						/* Repeat prev region, if that is a choice */
						if( pp->pt_back->pt_regionp == regp )
							lastregion = regp;
					} else {
						/* Keep lastregion as is */
					}
				    	claiming_regions--;	/* now = 1 */
					if(rt_g.debug&DEBUG_PARTITION)  rt_log("rt_boolfinal:  overlap p retained, as region=%s\n",
						lastregion->reg_namep );
				} else {
					/* zero => delete the partition.
					 * The dirty work happens below.
					 */
				}
d742 5
a746 4
				/* last region is air, replace with solid */
				if( lastregion->reg_aircode != 0 )
					lastregion = regp;
				claiming_regions--;		/* now = 1 */
@


9.23
log
@Fixed Ryan's "xpa" problem.
Needed near-zero tolerance check in sorting defect checks.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.22 91/06/30 19:12:01 mike Exp $ (BRL)";
d86 5
a90 1
		if(rt_g.debug&DEBUG_PARTITION) rt_pr_seg(segp);
d226 1
a226 1
				if(rt_g.debug&DEBUG_PARTITION) rt_log("seg starts after p starts, ends after p ends. Split p in two, advance.\n");
d433 1
a433 1
OVERLAP3: isol=%s osol=%s\n\
d439 1
d558 2
a559 1
		if( pp->pt_forw != InputHdp )  {
d562 2
a563 2
				if(rt_g.debug&DEBUG_PARTITION)  rt_log("rt_boolfinal:  fusing 2 partitions x%d y%d lvl%d\n",
					ap->a_x, ap->a_y, ap->a_level );
d700 3
a702 2
				    	/* non-zero => retain last partition */
					if( lastregion->reg_aircode != 0 )
d704 7
d712 6
d778 1
@


9.22
log
@Improved overlap error messages.
Added handling of very thin partitions.
Changed some %g to %.18e formats.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.21 91/06/29 17:03:13 mike Exp $ (BRL)";
d525 3
a527 1
			rt_log("rt_boolfinal: (%g,%g)\n", startdist, enddist );
d537 1
a537 1
				"rt_boolfinal:  Zero thickness partition: %s (%.18e,%.18e)\n",
d540 2
a541 1
				pp->pt_outhit->hit_dist );
d546 1
a546 1
		/* Sanity checks on sorting.  Remove later. */
d548 3
a550 1
			rt_log("rt_boolfinal: inverted partition %.8x\n", pp);
d553 13
a565 5
		if( pp->pt_forw != InputHdp && pp->pt_outhit->hit_dist > pp->pt_forw->pt_inhit->hit_dist )  {
			rt_log("rt_boolfinal:  sorting defect!\n");
			if( !(rt_g.debug & DEBUG_PARTITION) )
				rt_pr_partitions( ap->a_rt_i, InputHdp, "With DEFECT" );
			return(0);	/* give up */
@


9.21
log
@Added code for OP_NOP
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.20 91/06/10 23:31:35 mike Exp $ (BRL)";
a105 1
			segp->seg_out.hit_dist = segp->seg_in.hit_dist;
d107 1
a107 1
				"rt_boolweave:  Zero thickness seg: %s (%g,%g)\n",
d111 1
d115 1
a115 1
		    	rt_log("rt_boolweave:  Defective segment %s (%g,%g)\n",
d122 1
a122 1
		    	rt_log("rt_boolweave:  Inside-out segment %s (%g,%g)\n",
d409 3
a419 1
	depth = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;
d427 8
a434 5
OVERLAP1: reg=%s isol=%s\n\
OVERLAP2: reg=%s osol=%s\n\
OVERLAP depth %gmm at (%g,%g,%g) x%d y%d lvl%d\n",
		reg1->reg_name, pp->pt_inseg->seg_stp->st_name,
		reg2->reg_name, pp->pt_outseg->seg_stp->st_name,
d528 2
d531 12
a543 2
		RT_CHECK_SEG(pp->pt_inseg);
		RT_CHECK_SEG(pp->pt_outseg);
d988 1
a988 1
	if(rt_g.debug&DEBUG_FDIFF) rt_log("rt_fdiff(%g,%g)=%d\n", a, b, ret);
@


9.20
log
@Initial support for zero thickness segments.
Note for the future:  there may be complications, if
the 0-len seg & another seg exactly touch at a seg endpoint.
Whether the "other seg" solid is listed in the partition may depend
on the order the two segs are processed.  Maybe.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.19 91/06/10 23:14:06 mike Exp $ (BRL)";
d789 3
@


9.19
log
@All uses of rt_fdiff() have been replaced with tolerance-based tests.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.18 91/06/10 22:40:19 mike Exp $ (BRL)";
d96 7
a102 2
		/*  Eliminate very thin segments, or they will cause
		 *  trouble below.
d106 1
d108 1
a108 1
				"rt_boolweave:  Thin seg discarded: %s (%g,%g)\n",
a111 1
			continue;
@


9.18
log
@More progress
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.17 91/06/10 22:20:16 mike Exp $ (BRL)";
a57 3
 *
 * XXX Should be given dist tolerance value, to make approx-equal decisions!
 * XXX Use of rt_fdiff is dangerous.
d231 2
a232 2
				i = rt_fdiff(segp->seg_out.hit_dist, pp->pt_outhit->hit_dist);
				if( i > 0 )  {
d248 1
a248 1
				if( i == 0 )  {
d250 1
d259 1
a259 2
				}
				if( i < 0 )  {
d261 2
d283 1
d299 2
a300 1
				if( (i=rt_fdiff(segp->seg_out.hit_dist, pp->pt_inhit->hit_dist)) < 0 ){
d302 1
d317 5
a321 2
				if( i==0 )  {
					/* Seg starts before current
@


9.17
log
@Began conversion from rt_fdiff() to tolerance-based distances.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.16 91/03/13 19:21:52 mike Exp $ (BRL)";
d73 1
d102 2
a103 1
		if( rt_fdiff(segp->seg_in.hit_dist,segp->seg_out.hit_dist)==0 ) {
d165 2
a166 1
			if( (i=rt_fdiff(lasthit->hit_dist, pp->pt_outhit->hit_dist)) > 0 )  {
d176 1
a176 1
			if( i == 0 )  {
d193 1
a193 1
			 * i < 0
d198 2
a199 2
			i=rt_fdiff(lasthit->hit_dist, pp->pt_inhit->hit_dist);
			if( i > 0 )  {
a200 2
				 * i > 0
				 *
d223 1
a223 1
			if( i == 0){
d230 2
a231 2
				 * (ie, when rt_fdiff()==0), the two
				 * points MUST be forced to become
d234 1
a234 11
				if( (i = rt_fdiff(segp->seg_out.hit_dist, pp->pt_outhit->hit_dist)) == 0 )  {
					/*
					 * Segment and partition start & end
					 * (nearly) together.
					 *	PPPP
					 *	SSSS
					 */
					BITSET(pp->pt_solhit, segp->seg_stp->st_bit);
					if(rt_g.debug&DEBUG_PARTITION) rt_log("same start&end\n");
					goto done_weave;
				}
d251 34
d286 2
a287 22
				 *  Segment + Partition start together,
				 *  segment ends before partition ends.
				 *	PPPPPPPPPP
				 *	SSSSSS
				 *	newpp| pp
				 */
				GET_PT( rtip, newpp, res );
				COPY_PT( rtip, newpp,pp);
				/* new partition contains segment */
				BITSET(newpp->pt_solhit, segp->seg_stp->st_bit);
				newpp->pt_outseg = segp;
				newpp->pt_outhit = &segp->seg_out;
				newpp->pt_outflip = 0;
				pp->pt_inseg = segp;
				pp->pt_inhit = &segp->seg_out;
				pp->pt_inflip = 1;
				INSERT_PT( newpp, pp );
				if(rt_g.debug&DEBUG_PARTITION) rt_log("start together, seg shorter\n");
				goto done_weave;
			}
			if( i < 0 )  {
				/*
d353 1
@


9.16
log
@Added an extra error check.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.15 91/02/21 16:08:45 mike Exp $ (BRL)";
d190 2
a191 1
			 * i < 0,  Seg starts before current partition ends
d195 28
a222 2

			if( (i=rt_fdiff(lasthit->hit_dist, pp->pt_inhit->hit_dist)) == 0){
a347 24
			/*
			 * i > 0
			 *
			 * lasthit->hit_dist > pp->pt_inhit->hit_dist
			 *
			 *  Segment starts after partition starts,
			 *  but before the end of the partition.
			 *  Note:  pt_solhit will be marked in equal_start.
			 *	PPPPPPPPPPPP
			 *	     SSSS...
			 *	newpp|pp
			 */
			GET_PT( rtip, newpp, res );
			COPY_PT( rtip, newpp, pp );
			/* new part. is the span before seg joins partition */
			pp->pt_inseg = segp;
			pp->pt_inhit = &segp->seg_in;
			pp->pt_inflip = 0;
			newpp->pt_outseg = segp;
			newpp->pt_outhit = &segp->seg_in;
			newpp->pt_outflip = 1;
			INSERT_PT( newpp, pp );
			if(rt_g.debug&DEBUG_PARTITION) rt_log("seg starts after p starts, ends after p ends. Split p in two, advance.\n");
			goto equal_start;
d478 1
d511 2
a512 2
		if( pp->pt_inhit->hit_dist >= pp->pt_outhit->hit_dist )  {
			rt_log("rt_boolfinal: thin or inverted partition %.8x\n", pp);
d551 2
a552 1
		if( rt_fdiff( pp->pt_inhit->hit_dist, enddist) > 0 )  {
d554 1
a554 1
				"partition begins beyond current box end, returning\n");
d563 2
a564 1
		if( rt_fdiff( pp->pt_outhit->hit_dist, enddist) > 0 )  {
d701 2
a702 1
			if( (lastpp = FinalHdp->pt_back) != FinalHdp &&
d704 3
a706 2
			    rt_fdiff( newpp->pt_inhit->hit_dist,
				lastpp->pt_outhit->hit_dist ) == 0
@


9.15
log
@Minor reorganization
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.14 91/02/19 23:03:24 mike Exp $ (BRL)";
d58 3
d112 7
@


9.14
log
@Changed overlap messages to be printed with a single call to
rt_log(), so that in parallel runs, the different lines will
stay grouped together.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.13 90/11/12 18:48:02 mike Exp $ (BRL)";
d69 1
d72 2
d86 1
a86 1
		if( segp->seg_stp->st_bit >= ap->a_rt_i->nsolids) rt_bomb("rt_boolweave: st_bit");
d121 1
a121 1
			GET_PT_INIT( ap->a_rt_i, pp, res );
d136 1
a136 1
			GET_PT_INIT( ap->a_rt_i, pp, res );
d177 1
a177 1
			if(rt_g.debug&DEBUG_PARTITION)  rt_pr_pt(ap->a_rt_i, pp);
d230 2
a231 2
				GET_PT( ap->a_rt_i, newpp, res );
				COPY_PT( ap->a_rt_i,newpp,pp);
d252 1
a252 1
				GET_PT_INIT( ap->a_rt_i, newpp, res );
d323 2
a324 2
			GET_PT( ap->a_rt_i, newpp, res );
			COPY_PT( ap->a_rt_i, newpp, pp );
d344 1
a344 1
		GET_PT_INIT( ap->a_rt_i, newpp, res );
d355 1
a355 1
			rt_pr_partitions( ap->a_rt_i, PartHdp, "After weave" );
@


9.13
log
@Fix:  don't extend previous partition when there isn't one!
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.12 90/11/12 18:33:36 mike Exp $ (BRL)";
d389 2
d392 6
a397 5
	rt_log("OVERLAP1: reg=%s isol=%s\n",
		reg1->reg_name, pp->pt_inseg->seg_stp->st_name);
	rt_log("OVERLAP2: reg=%s osol=%s\n",
		reg2->reg_name, pp->pt_outseg->seg_stp->st_name);
	rt_log("OVERLAP depth %gmm at (%g,%g,%g) x%d y%d lvl%d\n",
@


9.12
log
@There is a bad inseg pointer being stumbled over in here.
Added more sanity checking.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.11 90/10/06 02:50:43 mike Exp $ (BRL)";
d666 2
a667 1
			register struct partition *newpp;
d672 2
d679 2
a680 1
			if( lastregion == FinalHdp->pt_back->pt_regionp &&
d682 1
a682 1
				FinalHdp->pt_back->pt_outhit->hit_dist ) == 0
d685 6
a690 3
				FinalHdp->pt_back->pt_outhit = newpp->pt_outhit;
				FinalHdp->pt_back->pt_outflip = newpp->pt_outflip;
				FinalHdp->pt_back->pt_outseg = newpp->pt_outseg;
d692 1
a692 1
				newpp = FinalHdp->pt_back;
d694 1
a694 1
				APPEND_PT( newpp, FinalHdp->pt_back );
@


9.11
log
@Enlarged rti_Solids[] to have some pad area on the end.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.10 90/10/06 02:04:48 mike Exp $ (BRL)";
d75 4
a78 4
		register struct partition *newpp;
		register struct seg *lastseg;
		register struct hit *lasthit;
		LOCAL int	lastflip;
d489 2
d691 2
a692 2
			RT_CHECK_SEG(newpp->pt_inseg);
			RT_CHECK_SEG(newpp->pt_outseg);
@


9.10
log
@Converted seg structures to use doubly linked lists.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.9 90/07/29 22:39:46 mike Exp $ (BRL)";
d562 10
a571 5
			struct soltab	*stp =
				ap->a_rt_i->rti_Solids[RT_BITV_LOOP_INDEX];
			register int words=RT_BITV_BITS2WORDS(stp->st_maxreg);
			register bitv_t *in = stp->st_regions;
			register bitv_t *out = regionbits;
@


9.9
log
@ Needed to use fuzzy comparisons against enddist.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.8 90/05/21 14:22:37 mike Exp $ (BRL)";
d32 1
a32 1
void	rt_grow_boolstack();
d60 3
a62 2
rt_boolweave( segp_in, PartHdp, ap )
struct seg		*segp_in;
d74 1
a74 1
	for( segp = segp_in; segp != SEG_NULL; segp = segp->seg_next )  {
d80 1
d84 3
@


9.8
log
@lint
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: /m/cad/librt/RCS/bool.c,v 9.7 90/01/06 03:54:03 mike Exp $ (BRL)";
d524 3
a526 1
		if( pp->pt_inhit->hit_dist > enddist )
d528 1
d535 3
a537 1
		if( pp->pt_outhit->hit_dist > enddist )  {
@


9.7
log
@Converted to using RT_BITV_LOOP_START() macros
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 9.6 90/01/05 04:15:01 mike Locked $ (BRL)";
a452 1
	register int	i;
@


9.6
log
@Added rt_pr_tree_val() which can print boolean trees in compact notation,
giving either solid bit number, solid name, or bit values in the
current partition.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 9.5 89/12/31 07:42:03 mike Locked $ (BRL)";
a453 1
	struct soltab	*stp;
d545 3
d550 1
a550 1
		 *  set (OR) that solid's region bits into "regionbits".
d552 6
a557 2
		bzero( (char *)regionbits, BITS2BYTES(ap->a_rt_i->nregions) );
		for( stp=ap->a_rt_i->HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw )  {
d559 4
a562 1
			if( !BITTEST( pp->pt_solhit, stp->st_bit ) )  continue;
a563 14
			{
				register int words;
				register bitv_t *in = stp->st_regions;
				register bitv_t *out = regionbits;

				/* BITS2BYTES() / sizeof(bitv_t) */
				words = (stp->st_maxreg+BITV_MASK)>>BITV_SHIFT;

#				include "noalias.h"
				while( words-- > 0 )
					*out++ |= *in++;
			}
		}

d568 1
a568 1
		for( i=0; i < ap->a_rt_i->nregions; i++ )  {
d571 1
a571 11
/**			if( !BITTEST(regionbits, i) )  continue; **/
			{
				register bitv_t j;
				if( (j = regionbits[i>>BITV_SHIFT])==0 )  {
					i = ((i+1+BITV_MASK)&(~BITV_MASK))-1;
					continue;
				}
				if( !(j & (((bitv_t)1)<<(i&BITV_MASK))) )
					continue;
			}
			regp = ap->a_rt_i->Regions[i];
d577 1
a577 1
					regp, i, regp->reg_name );
d621 1
a621 1
		}
@


9.5
log
@Implemented a new meaning to a_onehit:  how many hit points
need to be accurately determined.
This provides a big performance "win" to the reflect/refract code,
which needs 3 hits, and was forced to compute the ray to +infinity,
which was *very* costly.

Alas, somehow I seem to have made things in general slow down.
The larger the model, the worse it gets.
This must be pursued further.
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 9.4 89/12/31 00:13:59 mike Locked $ (BRL)";
d587 7
a593 2
			if(rt_g.debug&DEBUG_PARTITION)
				rt_log("%.8x=bit%d, %s: ", regp, i, regp->reg_name );
@


9.4
log
@Moved various structure printing routines to module pr.c
@
text
@d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 9.3 89/12/30 05:21:57 mike Locked $ (BRL)";
d325 1
a325 1
			if(rt_g.debug&DEBUG_PARTITION) rt_log("seg starts after p starts, ends after p ends\n");
d399 7
a405 1
 * For each partition, evaluate the boolean expression tree.
d413 27
d441 1
a441 1
void
a448 1
	register struct partition *pp;
a449 1
	register int hitcnt;
d451 3
a453 1
	register int i;
d455 1
d457 2
d461 15
d479 1
a479 1
		hitcnt = 0;
d494 1
a494 1
			return; /* give up */
a496 4
		/* If partition begins beyond current box, stop */
		if( pp->pt_inhit->hit_dist > enddist )
			return;

d498 9
a506 3
		 * If partition exists entirely behind start position, or
		 * if partition ends before current box starts,
		 * discard it, as we should never need to look back.
d508 7
a514 6
		if( pp->pt_outhit->hit_dist < -10.0
		    || pp->pt_outhit->hit_dist < startdist
		)  {
			register struct partition *zappp;
			if(rt_g.debug&DEBUG_PARTITION)rt_log("rt_boolfinal discarding partition x%x\n", pp);
			zappp = pp;
d516 2
a517 2
			DEQUEUE_PT(zappp);
			FREE_PT(zappp, ap->a_resource);
d522 25
d597 1
a597 1
			if( ++hitcnt <= 1 )  {
d623 1
a623 1
				    	hitcnt--;	/* now = 1 */
d629 1
a629 1
				hitcnt--;		/* now = 1 */
d632 1
a632 1
		if( hitcnt == 0 )  {
d636 13
a648 3
		if( pp->pt_outhit->hit_dist <= 0.001 /* milimeters */ )  {
			/* partition is behind start point (k=0), ignore */
			pp=pp->pt_forw;
d652 7
a658 1
		/* Add this partition to the result queue */
d666 7
a672 7
			if( hitcnt > 1 )  {
				/* Overlapping partition, discard it.	*/
				FREE_PT(newpp, ap->a_resource);
			}  else if( lastregion == FinalHdp->pt_back->pt_regionp
			         &&  rt_fdiff(	newpp->pt_inhit->hit_dist,
					FinalHdp->pt_back->pt_outhit->hit_dist
					) == 0
d674 1
a674 1
				/* Adjacent partitions, same region, so join */
d682 1
d687 1
d689 2
a690 9
			/* Shameless efficiency hack:
			 * If the application is for viewing only,
			 * the first hit beyond the start point is
			 * all we care about.
			 */
			if( ap->a_onehit && newpp->pt_inhit->hit_dist > 0.0 )
				break;

		}
d694 2
a695 1
	/* Caller must free both partition chains */
d972 25
@


9.3
log
@Moved merging st_regions[] into regionbits[] from rt_shootray(),
where it was being done once for all regions crossed by a ray,
into rt_boolfinal(), where it is now built separately for each
partition.

In models where the ray may traverse quite a few regions, this
should result in a substantial savings, mostly from less calling
of rt_booleval().
@
text
@a5 12
 * Inputs -
 *	Pointer to first segment in seg chain.
 *	Pointer to head of circular doubly-linked list of
 *	partitions of the original ray.
 *
 * Outputs -
 *	Final partitions, queued on doubly-linked list specified.
 *
 * Notes -
 *	It is the responsibility of the CALLER to free the seg chain,
 *	as well as the partition list that we return.
 *
d19 1
a19 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 9.2 89/12/30 04:38:11 mike Locked $ (BRL)";
d46 12
d69 2
a70 1
	if( ap->a_rt_i->rti_magic != RTI_MAGIC )  rt_bomb("rt_boolweave:  bad rtip\n");
d398 1
a761 63
 *			R T _ P R _ P A R T I T I O N S
 *
 */
void
rt_pr_partitions( rtip, phead, title )
struct rt_i		*rtip;
register struct partition *phead;
char *title;
{
	register struct partition *pp;

	if( rtip->rti_magic != RTI_MAGIC )  rt_bomb("rt_pr_partitions:  bad rtip\n");

	rt_log("------%s\n", title);
	for( pp = phead->pt_forw; pp != phead; pp = pp->pt_forw ) {
		RT_CHECK_PT(pp);
		rt_pr_pt(rtip, pp);
	}
	rt_log("------\n");
}

/*
 *			R T _ P R _ P T
 */
void
rt_pr_pt( rtip, pp )
struct rt_i		*rtip;
register struct partition *pp;
{
	if( rtip->rti_magic != RTI_MAGIC )  rt_bomb("rt_pr_pt:  bad rtip\n");
	RT_CHECK_PT(pp);

	rt_log("%.8x: PT %s %s (%g,%g)",
		pp,
		pp->pt_inseg->seg_stp->st_name,
		pp->pt_outseg->seg_stp->st_name,
		pp->pt_inhit->hit_dist, pp->pt_outhit->hit_dist );
	rt_log("%s%s\n",
		pp->pt_inflip ? " Iflip" : "",
		pp->pt_outflip ?" Oflip" : "" );
	rt_pr_bitv( "Solids", pp->pt_solhit, rtip->nsolids );
}

/*
 *			R T _ P R _ B I T V
 *
 *  Print the bits set in a bit vector.
 */
void
rt_pr_bitv( str, bv, len )
char *str;
register bitv_t *bv;
register int len;
{
	register int i;
	rt_log("%s: ", str);
	for( i=0; i<len; i++ )
		if( BITTEST(bv,i) )
			rt_log("%d, ", i );
	rt_log("\n");
}

/*
a857 29
 *			R T _ P R _ S E G
 */
void
rt_pr_seg(segp)
register struct seg *segp;
{
	RT_CHECK_SEG(segp);
	rt_log("%.8x: SEG %s (%g,%g) bit=%d\n",
		segp,
		segp->seg_stp->st_name,
		segp->seg_in.hit_dist,
		segp->seg_out.hit_dist,
		segp->seg_stp->st_bit );
}

/*
 *			R T _ P R _ H I T
 */
void
rt_pr_hit( str, hitp )
char *str;
register struct hit *hitp;
{
	rt_log("HIT %s dist=%g\n", str, hitp->hit_dist );
	VPRINT("HIT Point ", hitp->hit_point );
	VPRINT("HIT Normal", hitp->hit_normal );
}

/*
a880 40
}

/*
 *			R T _ P R I N T B
 *
 *  Print a value a la the %b format of the kernel's printf
 *
 *    s		title string
 *    v		the integer with the bits in it
 *    bits	a string which starts with the desired base, then followed by
 *		words preceeded with embedded low-value bytes indicating
 *		bit number plus one,
 *		in little-endian order, eg:
 *		"\010\2Bit_one\1BIT_zero"
 */
void
rt_printb(s, v, bits)
char *s;
register unsigned long v;
register char *bits;
{
	register int i, any = 0;
	register char c;

	if (*bits++ == 8)
		rt_log("%s=0%o <", s, v);
	else
		rt_log("%s=x%x <", s, v);
	while (i = *bits++) {
		if (v & (1L << (i-1))) {
			if (any)
				rt_log(",");
			any = 1;
			for (; (c = *bits) > 32; bits++)
				rt_log("%c", c);
		} else
			for (; *bits > 32; bits++)
				;
	}
	rt_log(">");
@


9.2
log
@Added error checking.
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 9.1 89/05/19 05:53:48 mike Locked $ (BRL)";
d419 1
d421 2
a422 1
	if( ap->a_rt_i->rti_magic != RTI_MAGIC )  rt_bomb("rt_boolweave:  bad rtip\n");
d464 26
@


9.1
log
@Release_3.5
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 8.3 89/03/15 15:35:22 mike Exp $ (BRL)";
d76 1
a76 1
		LOCAL lastflip;
d78 1
d369 2
d423 1
d559 3
d747 1
d762 1
d897 1
@


8.3
log
@unused var, type clarification
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 8.2 88/10/06 03:08:23 mike Locked $ (BRL)";
@


8.2
log
@Improved OVERLAP error messages.
Really Rel3.0
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 8.1 88/10/05 00:31:00 mike Locked $ (BRL)";
d44 2
d603 1
a603 1
		(void)rt_grow_boolstack( resp );
a734 1
	register int i;
d917 1
@


8.1
log
@Release_3.0
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 7.5 88/08/20 07:22:56 mike Exp $ (BRL)";
d379 6
a384 3
	rt_log("OVERLAP: reg=%s sol=%s, reg=%s sol=%s (x%d y%d lvl%d)\n",
		reg1->reg_name, pp->pt_inseg->seg_stp->st_name,
		reg2->reg_name, pp->pt_outseg->seg_stp->st_name,
a385 2
	rt_log("OVERLAP depth %gmm at (%g,%g,%g)\n",
		depth, pt[X], pt[Y], pt[Z] );
@


7.5
log
@Made rt_printb() type void
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 7.4 88/08/20 07:01:08 mike Exp $ (BRL)";
@


7.4
log
@Added rt_printb() to print bitstrings as collections of named bits.
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 7.3 88/08/19 06:54:15 mike Locked $ (BRL)";
d945 1
@


7.3
log
@Added rt_grow_boolstack(), and exploited Phil's rewrite of
rt_optim_tree() and rt_solid_bitfinder() to use iteration instead of
recursion.
rt_fr_tree() remains to be converted, and may still run out of
stack space on a Gould.
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 7.2 88/01/23 00:25:49 phil Locked $ (BRL)";
d930 39
@


7.2
log
@Tolerance for absolute differences in fdiff is now 1/1000mm.
Eventually, absolute and relative tolerances should come from
the application structure, and be application-settable.
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 7.1 87/11/02 23:32:58 mike Locked $ (BRL)";
d473 2
a474 1
			if( rt_booleval( regp->reg_treetop, pp, TrueRg ) == FALSE )  {
d582 1
a582 1
rt_booleval( treep, partp, trueregp )
d585 2
a586 1
struct region **trueregp;	/* XOR true (and overlap) return */
a587 2
#define STACKDEPTH	128
	LOCAL union tree *stackpile[STACKDEPTH];
d593 1
d599 3
a601 1
	sp = stackpile;
d614 5
a618 3
		if( sp >= &stackpile[STACKDEPTH] )  {
			rt_log("rt_booleval: stack overflow!\n");
			return(TRUE);	/* screw up output */
d905 25
@


7.1
log
@Release 2.3
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 6.6 87/11/02 20:24:31 mike Exp $ (BRL)";
d363 2
a364 1
	static long count = 0;
d374 5
d384 1
a384 2
		pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist,
		pt[X], pt[Y], pt[Z] );
d810 1
a810 1
	if( d <= 0.0001 )  {
d827 2
a828 2
	if( diff <= 0.0001 )  {
		ret = 0;	/* absolute difference is small */
@


6.6
log
@Fixed return(expr) problem in rt_defoverlap
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 6.5 87/10/15 01:29:56 mike Locked $ (BRL)";
@


6.5
log
@Changed calling sequence of overlap checker.
Changed default overlap checker to print first 100,
and then only once every 100 after that.
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 6.4 87/09/17 07:02:01 mike Locked $ (BRL)";
d367 1
a367 1
		if( (count%100) != 3 )  return;
@


6.4
log
@Eliminated overlap tolerance checking here, it should be
done in user-provided overlap routine.
Improved printfs in default overlap routine.
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 6.3 87/09/17 04:16:00 mike Locked $ (BRL)";
d356 1
a356 1
rt_defoverlap( ap, pp, name1, name2 )
d359 2
a360 2
char				*name1;
char				*name2;
d363 1
d365 6
d374 2
a375 2
		name1, pp->pt_inseg->seg_stp->st_name,
		name2, pp->pt_outseg->seg_stp->st_name,
d497 1
a497 2
				if( ap->a_overlap( ap, pp,
				    regp->reg_name, lastregion->reg_name ) )  {
@


6.3
log
@Modified overlap handler function to return code indicating
whether to discard overlap ray partition, or retain it with
a random choice of region ID.
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 6.2 87/08/09 19:12:12 mike Locked $ (BRL)";
d362 7
a368 2
	rt_log("OVERLAP: %s %s (x%d y%d lvl%d)\n",
		name1, name2,
d370 3
a372 1
	rt_pr_pt( ap->a_rt_i, pp );
d472 4
a475 2
#define OVERLAP_TOL	0.5	/* 1/2 of a milimeter */
			/* Two regions claim this partition */
a482 4
			   ) &&
			   (	pp->pt_outhit->hit_dist -
				pp->pt_inhit->hit_dist
				> OVERLAP_TOL /* Permissable overlap */
d492 3
a494 1
				    	/* non-zero => retain partition */
@


6.2
log
@Fixed problem revealed by Cray-2, requiring cast of constant to bitv_t
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 6.1 87/07/11 07:55:19 mike Rel $ (BRL)";
d139 1
a139 1
			register int i;		/* XXX */
d351 3
d366 1
d377 3
d485 5
a489 4
				ap->a_overlap(	ap,
						pp,
						regp->reg_name,
						lastregion->reg_name );
d494 1
a494 1
				hitcnt--;
d509 1
a509 1
			register struct partition *newpp;	/* XXX */
@


6.1
log
@Release 2.0
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 5.1 87/06/24 22:10:52 mike Rel $ (BRL)";
d441 2
a442 1
				if( !(j & (1<<(i&BITV_MASK))) )  continue;
d446 1
a446 1
				rt_log("%.8x=%s: ", regp, regp->reg_name );
@


5.1
log
@Release 1.24
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 4.5 87/06/24 01:27:14 mike Exp $ (BRL)";
@


4.5
log
@Added additional debugging, added absolute difference check
to fdiff(), to fix "the corner of the Cray problem".
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 4.4 87/05/29 09:03:00 mike Locked $ (BRL)";
@


4.4
log
@Added Gary's overlap improvements.
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 4.3 87/03/23 23:42:36 mike Locked $ (BRL)";
d148 1
d162 1
d165 2
d175 1
d192 1
a192 1
			if(rt_g.debug&DEBUG_PARTITION) rt_log("same start\n");
d208 1
d229 1
a229 1
			if(rt_g.debug&DEBUG_PARTITION) rt_log("start together, seg shorter\n");
d258 1
a258 1
			if(rt_g.debug&DEBUG_PARTITION) rt_log("seg between 2 partitions\n");
d278 1
a278 1
			if(rt_g.debug&DEBUG_PARTITION) rt_log("seg ends at part start, fuse\n");
d296 1
d321 1
d331 1
a331 1
		if(rt_g.debug&DEBUG_PARTITION) rt_log("seg extends beyond end\n");
d774 1
d783 4
a786 2
	if( d <= 0.0001 )
		return(0);	/* both nearly zero */
d788 10
a797 3
		if( a == b )  return(0);
		if( a < b )  return(-1);
		return(1);
d799 17
a815 7
	diff = a - b;
	if( diff < 0.0 )  diff = -diff;
	if( diff < 0.000001 * d )
		return( 0 );	/* relative difference is small */
	if( a < b )
		return(-1);
	return(1);
@


4.3
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 4.2 87/02/12 22:10:50 mike Exp $ (BRL)";
d340 18
d463 10
a472 5
				rt_log("OVERLAP: %s %s (x%d y%d lvl%d)\n",
					regp->reg_name,
					lastregion->reg_name,
					ap->a_x, ap->a_y, ap->a_level );
				rt_pr_pt( ap->a_rt_i, pp );
d498 5
a502 2
			if(	lastregion == FinalHdp->pt_back->pt_regionp
			    &&	rt_fdiff(	newpp->pt_inhit->hit_dist,
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 4.1 86/12/29 03:44:39 mike Rel1 $ (BRL)";
d58 1
a58 1
rt_boolweave( segp_in, PartHdp, res )
d61 1
a61 1
struct resource		*res;
d65 1
d67 1
d77 1
d109 1
a109 1
			GET_PT_INIT( pp, res );
d124 1
a124 1
			GET_PT_INIT( pp, res );
d212 2
a213 2
				GET_PT( newpp, res );
				COPY_PT(newpp,pp);
d234 1
a234 1
				GET_PT_INIT( newpp, res );
d304 2
a305 2
			GET_PT( newpp, res );
			COPY_PT( newpp, pp );
d324 1
a324 1
		GET_PT_INIT( newpp, res );
d335 1
a335 1
			rt_pr_partitions( PartHdp, "After weave" );
a360 1
	extern union tree *RootTree;
d362 1
d368 1
a368 1
			rt_pr_pt( pp );
d374 1
a374 1
			rt_pr_partitions( InputHdp, "With problem" );
d379 1
a379 1
				rt_pr_partitions( InputHdp, "With DEFECT" );
a403 1
#ifndef OLDBOOL
d405 1
a405 1
		for( i=0; i < rt_i.nregions; i++ )  {
d417 1
a417 1
			regp = rt_i.Regions[i];
d449 1
a449 1
				rt_pr_pt( pp );
a460 17
#else
		if( (hitcnt = rt_booleval( RootTree, pp, TrueRg )) == FALSE )  {
			if(rt_g.debug&DEBUG_PARTITION) rt_log("FALSE\n");
			pp = pp->pt_forw;
			continue;
		}
		if( hitcnt < 0 )  {
			/*  GUARD error:  overlap */
			rt_log("OVERLAP: %s %s (%g,%g)\n",
				TrueRg[0]->reg_name,
				TrueRg[1]->reg_name,
				pp->pt_inhit->hit_dist,
				pp->pt_outhit->hit_dist );
		}
		lastregion = TrueRg[0];
		if(rt_g.debug&DEBUG_PARTITION) rt_log("TRUE\n");
#endif
d501 1
a501 1
		rt_pr_partitions( FinalHdp, "rt_boolfinal: Partitions returned" );
d660 2
a661 1
rt_pr_partitions( phead, title )
d668 2
d672 1
a672 1
		rt_pr_pt(pp);
d681 2
a682 1
rt_pr_pt( pp )
d685 2
d695 1
a695 1
	rt_pr_bitv( "Solids", pp->pt_solhit, rt_i.nsolids );
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 3.7 86/12/24 08:05:30 mike Locked $ (BRL)";
@


3.7
log
@Revised for resource structure.
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 3.6 86/10/26 16:56:30 mike Locked $ (BRL)";
@


3.6
log
@Fixed minor type problem.
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 3.5 86/08/12 04:15:14 mike Exp $ (BRL)";
d58 4
a61 3
rt_boolweave( segp_in, PartHdp )
struct seg *segp_in;
struct partition *PartHdp;
d106 1
a106 1
			GET_PT_INIT( pp );
d121 1
a121 1
			GET_PT_INIT( pp );
d209 1
a209 1
				GET_PT( newpp );
d231 1
a231 1
				GET_PT_INIT( newpp );
d301 1
a301 1
			GET_PT( newpp );
d321 1
a321 1
		GET_PT_INIT( newpp );
d397 1
a397 1
			FREE_PT(zappp);
d499 1
a499 1
				FREE_PT( newpp );
@


3.5
log
@Changed #include directives for use with CC -I convention
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 3.4 86/07/22 03:20:09 mike Exp $ (BRL)";
d400 1
a400 1
#ifndef NEW
d407 1
a407 1
				register int j;
@


3.4
log
@Slight additional error checking
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 3.3 86/07/19 04:38:25 mike Exp $ (BRL)";
d35 4
a38 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/raytrace.h"
#include "debug.h"
@


3.3
log
@Improved error messages.
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 3.2 86/07/11 01:31:33 mike Exp $ (BRL)";
d65 2
a66 2
	if(rt_g.debug&DEBUG_PARTITION) rt_log("-------------------BOOL_WEAVE\n");
	/* First pass -- validity checking */
d68 1
a68 28

		/* Totally ignore things behind the start position */
		if( segp->seg_out.hit_dist < -10.0 )
			continue;

		/*  Eliminate very thin segments, or they will cause
		 *  trouble below.
		 */
		if( rt_fdiff(segp->seg_in.hit_dist,segp->seg_out.hit_dist)==0 ) {
			rt_log(
				"rt_boolweave: 1  Thin seg discarded: %s (%g,%g)\n",
				segp->seg_stp->st_name,
				segp->seg_in.hit_dist,
				segp->seg_out.hit_dist );
			continue;
		}
		if( segp->seg_in.hit_dist < -INFINITY ||
		    segp->seg_out.hit_dist > INFINITY )  {
		    	rt_log("rt_boolweave: 1  Defective segment %s (%g,%g)\n",
				segp->seg_stp->st_name,
				segp->seg_in.hit_dist,
				segp->seg_out.hit_dist );
			continue;
		}
	}
	/* Second pass -- weaving */
	for( segp = segp_in; segp != SEG_NULL; segp = segp->seg_next )  {
		register struct partition *newpp;		/* XXX */
d84 1
a84 1
				"rt_boolweave: 2  Thin seg discarded: %s (%g,%g)\n",
d90 3
a92 3
		if( segp->seg_in.hit_dist < -INFINITY ||
		    segp->seg_out.hit_dist > INFINITY )  {
		    	rt_log("rt_boolweave: 2 Defective segment %s (%g,%g)\n",
d758 1
a758 1
	if( d == INFINITY )  {
@


3.2
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d31 1
a31 1
static char RCSbool[] = "@@(#)$Header: bool.c,v 3.1 86/06/12 22:30:09 mike Exp $ (BRL)";
d70 1
a70 1
		if( segp->seg_out.hit_dist < -0.005 )
d103 1
a103 1
		if( segp->seg_out.hit_dist < -0.005 )
d139 1
d154 1
d210 1
d246 1
d275 1
d295 1
d346 1
d415 1
a415 1
		if( pp->pt_outhit->hit_dist < -0.005
a775 1
	diff = a - b;
d785 6
@


3.1
log
@bool_weave thin segment warning only printed if partition debugging
enabled.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 3.0 86/06/10 01:32:38 mike Exp $ (BRL)";
d45 1
a45 1
 *			R T _ B O O L _ W E A V E
d58 1
a58 1
rt_bool_weave( segp_in, PartHdp )
d66 1
d68 27
d103 1
a103 1
		if( segp->seg_out.hit_dist < -EPSILON )
d111 1
a111 1
				"rt_bool_weave:  Thin seg discarded: %s (%f,%f)\n",
d117 8
d356 1
a356 1
 *			R T _ B O O L _ F I N A L
d365 1
a365 1
rt_bool_final( InputHdp, FinalHdp, startdist, enddist, regionbits, ap )
d383 1
a383 1
			rt_log("rt_bool_final: (%f,%f)\n", startdist, enddist );
d389 1
a389 1
			rt_log("rt_bool_final: thin or inverted partition %.8x\n", pp);
d393 1
a393 1
			rt_log("rt_bool_final:  sorting defect!\n");
d408 1
a408 1
		if( pp->pt_outhit->hit_dist < -EPSILON
d412 1
a412 1
			if(rt_g.debug&DEBUG_PARTITION)rt_log("rt_bool_final discarding partition x%x\n", pp);
d437 1
a437 1
			if( rt_bool_eval( regp->reg_treetop, pp, TrueRg ) == FALSE )  {
d468 2
a469 3
				/* One region is air, or overlap is
				 * within tolerance.  */
				if( lastregion->reg_aircode == 0 )
d479 1
a479 1
		if( (hitcnt = rt_bool_eval( RootTree, pp, TrueRg )) == FALSE )  {
d486 1
a486 1
			rt_log("OVERLAP: %s %s (%f,%f)\n",
d535 1
a535 1
		rt_pr_partitions( FinalHdp, "rt_bool_final: Partitions returned" );
d540 1
a540 1
 *  			R T _ B O O L _ E V A L
d546 1
a546 1
 *  be a useful addition, for rt_bool_regions().
d554 1
a554 1
rt_bool_eval( treep, partp, trueregp )
d585 1
a585 1
			rt_log("rt_bool_eval: stack overflow!\n");
d591 1
a591 1
		rt_log("rt_bool_eval:  bad stack op x%x\n",treep->tr_op);
d605 1
a605 1
		rt_log("rt_bool_eval:  pop SOLID?\n");
d683 1
a683 1
		rt_log("rt_bool_eval:  bad pop op x%x\n",treep->tr_op);
d715 1
a715 1
	rt_log("%.8x: PT %s %s (%f,%f)",
d772 1
a772 2
	if( b >= 0.0 )
		{
d774 1
a774 2
		}
	else
d776 2
a777 1
	if( d <= EPSILON )
d805 1
a805 1
	if( b >= 0.0 )
d807 1
a807 1
	else
d809 1
d823 1
a823 1
	rt_log("%.8x: SEG %s (%f,%f) bit=%d\n",
d839 1
a839 1
	rt_log("HIT %s dist=%f\n", str, hitp->hit_dist );
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 2.8 86/06/09 21:49:58 mike Exp $ (BRL)";
d82 2
a83 1
			rt_log("rt_bool_weave:  Thin seg discarded: %s (%f,%f)\n",
@


2.8
log
@rt and librt separated
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 2.7 86/05/29 01:47:15 mike Exp $ (BRL)";
a43 3
struct partition *FreePart = PT_NULL;		/* Head of freelist */
extern struct region *HeadRegion;		/* READ-ONLY */

d45 1
a45 1
 *			B O O L _ W E A V E
d58 1
a58 1
bool_weave( segp_in, PartHdp )
d65 1
a65 1
	if(debug&DEBUG_PARTITION) rtlog("-------------------BOOL_WEAVE\n");
d72 1
a72 1
		if(debug&DEBUG_PARTITION) pr_seg(segp);
d81 2
a82 2
		if( fdiff(segp->seg_in.hit_dist,segp->seg_out.hit_dist)==0 ) {
			rtlog("bool_weave:  Thin seg discarded: %s (%f,%f)\n",
d125 1
a125 1
			if( (i=fdiff(lasthit->hit_dist, pp->pt_outhit->hit_dist)) > 0 )  {
d153 1
a153 1
			if( (i=fdiff(lasthit->hit_dist, pp->pt_inhit->hit_dist)) == 0){
d159 1
a159 1
				 * (ie, when fdiff()==0), the two
d163 1
a163 1
				if( (i = fdiff(segp->seg_out.hit_dist, pp->pt_outhit->hit_dist)) == 0 )  {
d221 1
a221 1
				if( (i=fdiff(segp->seg_out.hit_dist, pp->pt_inhit->hit_dist)) < 0 ){
d313 2
a314 2
		if(debug&DEBUG_PARTITION)
			pr_partitions( PartHdp, "After weave" );
d319 1
a319 1
 *  			B O O L _ F I N A L
d327 2
a328 1
bool_final( InputHdp, FinalHdp, startdist, enddist, regionbits, ap )
d345 3
a347 3
		if(debug&DEBUG_PARTITION)  {
			rtlog("bool_final: (%f,%f)\n", startdist, enddist );
			pr_pt( pp );
d352 2
a353 2
			rtlog("bool_final: thin or inverted partition %.8x\n", pp);
			pr_partitions( InputHdp, "With problem" );
d356 3
a358 3
			rtlog("bool_final:  sorting defect!\n");
			if( !(debug & DEBUG_PARTITION) )
				pr_partitions( InputHdp, "With DEFECT" );
d375 1
a375 1
			if(debug&DEBUG_PARTITION)rtlog("bool_final discarding partition x%x\n", pp);
d385 1
a385 1
		for( i=0; i < nregions; i++ )  {
d397 5
a401 5
			regp = Regions[i];
			if(debug&DEBUG_PARTITION)
				rtlog("%.8x=%s: ", regp, regp->reg_name );
			if( bool_eval( regp->reg_treetop, pp, TrueRg ) == FALSE )  {
				if(debug&DEBUG_PARTITION) rtlog("FALSE\n");
d404 1
a404 1
				if(debug&DEBUG_PARTITION) rtlog("TRUE\n");
d425 1
a425 1
				rtlog("OVERLAP: %s %s (x%d y%d lvl%d)\n",
d429 1
a429 1
				pr_pt( pp );
d443 2
a444 2
		if( (hitcnt = bool_eval( RootTree, pp, TrueRg )) == FALSE )  {
			if(debug&DEBUG_PARTITION) rtlog("FALSE\n");
d450 1
a450 1
			rtlog("OVERLAP: %s %s (%f,%f)\n",
d457 1
a457 1
		if(debug&DEBUG_PARTITION) rtlog("TRUE\n");
d474 1
a474 1
			    &&	fdiff(	newpp->pt_inhit->hit_dist,
d498 2
a499 2
	if( debug&DEBUG_PARTITION )
		pr_partitions( FinalHdp, "bool_final: Partitions returned" );
d504 1
a504 1
 *  			B O O L _ E V A L
d510 1
a510 1
 *  be a useful addition, for bool_regions().
d518 1
a518 1
bool_eval( treep, partp, trueregp )
d549 1
a549 1
			rtlog("bool_eval: stack overflow!\n");
d555 1
a555 1
		rtlog("bool_eval:  bad stack op x%x\n",treep->tr_op);
d569 1
a569 1
		rtlog("bool_eval:  pop SOLID?\n");
d647 1
a647 1
		rtlog("bool_eval:  bad pop op x%x\n",treep->tr_op);
d653 4
a656 1
/* Called with address of head of chain */
d658 1
a658 1
pr_partitions( phead, title )
d665 1
a665 1
	rtlog("------%s\n", title);
d667 1
a667 1
		pr_pt(pp);
d669 1
a669 1
	rtlog("------\n");
d672 5
a676 1
pr_pt( pp )
d679 1
a679 1
	rtlog("%.8x: PT %s %s (%f,%f)",
d684 1
a684 1
	rtlog("%s%s\n",
d687 1
a687 1
	pr_bitv( "Solids", pp->pt_solhit, nsolids );
d691 1
a691 1
 *  			P R _ B I T V
d695 2
a696 1
pr_bitv( str, bv, len )
d702 1
a702 1
	rtlog("%s: ", str);
d705 2
a706 2
			rtlog("%d, ", i );
	rtlog("\n");
d710 1
a710 1
 *  			F D I F F
d718 1
a718 1
 *	if( fdiff( a, b ) <= 0 )
d727 1
a727 1
fdiff( a, b )
d753 1
a753 1
 *			R E L D I F F
a760 1

d762 1
a762 1
reldiff( a, b )
d781 1
a781 1
 *			P R _ S E G
d784 1
a784 1
pr_seg(segp)
d787 1
a787 1
	rtlog("%.8x: SEG %s (%f,%f) bit=%d\n",
d796 1
a796 1
 *  			P R _ H I T
d799 1
a799 1
pr_hit( str, hitp )
d803 1
a803 1
	rtlog("HIT %s dist=%f\n", str, hitp->hit_dist );
@


2.7
log
@Changed tolerances, added air overlap code, added
joining of adjacent partitions in bool_final,
all by Moss.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 2.6 86/03/14 22:01:38 mike Exp $ (BRL)";
d37 1
a37 1
#include "raytrace.h"
@


2.6
log
@Changed "behind start point" to 0.001 milimeters per Moss.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 2.5 85/10/29 14:23:01 mike Exp $ (BRL)";
d78 1
a78 1
		if( segp->seg_out.hit_dist <= 0 )
d333 1
a333 1
double startdist, enddist;
d373 1
a373 1
		if( pp->pt_outhit->hit_dist <= 0.0
d408 19
a426 2
			/* region claims partition */
			if( ++hitcnt > 1 ) {
d433 5
a437 1
				lastregion = regp;
d475 14
a488 1
			APPEND_PT( newpp, FinalHdp->pt_back );
d497 1
d731 1
d733 1
@


2.5
log
@Fixed pointer, per Moss.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 2.4 85/10/28 17:00:39 mike Exp $ (BRL)";
d440 1
a440 1
		if( pp->pt_outhit->hit_dist <= EPSILON )  {
@


2.4
log
@Changed fuseing of segment/partition ends to not loose normal
information.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 2.3 85/09/11 19:39:29 mike Exp $ (BRL)";
d251 1
@


2.3
log
@Relaxed fdiff() tolerance one more order of magnitude;
probably shouldn't relax any further.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 2.2 85/09/10 00:35:57 mike Exp $ (BRL)";
d143 1
a143 1
				 * Force an exact match of the endpoints,
a144 1
				 * Do NOT change lastseg or lastflip!
d146 2
a147 1
				lasthit = pp->pt_outhit;
d247 2
d251 2
a252 1
					newpp->pt_outhit = pp->pt_inhit;/*!!*/
@


2.2
log
@Tightened up fdiff() tolerance.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 2.1 85/08/31 06:03:07 mike Exp $ (BRL)";
d698 1
a698 1
	if( diff < 0.00001 * d )
@


2.1
log
@Version 2 of RT
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.23 85/07/30 05:52:09 mike Exp $ (BRL)";
d698 1
a698 1
	if( diff < EPSILON * d )
@


1.23
log
@Revised for joint GED/RT vmath.h;  some storage cleanups.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.22 85/07/30 02:03:27 mike Exp $ (BRL)";
d44 2
a45 1
int one_hit_flag;	/* non-zero if computation is for viewing only */
a46 2
struct partition *FreePart = PT_NULL;		 /* Head of freelist */

d48 1
a48 1
 *			B O O L _ R E G I O N S
d50 1
a50 1
 *  Weave the segments into the partitions.
d58 1
a58 1
 *  than a pointer, but that's more cycles than it's worth.
d61 1
a61 1
bool_regions( segp_in, FinalHdp )
d63 1
a63 1
struct partition *FinalHdp;	/* Heads final circ list */
a66 2
	LOCAL struct region ActRegHd;	/* Heads active circular forw list */
	LOCAL struct partition PartHd;	/* Heads active circular list */
d68 1
a68 8
	/* We assume that the region active chains are REGION_NULL */
	/* We assume that the solid bins st_bin are zero */
	/* bin 0 is always FALSE */

	ActRegHd.reg_active = &ActRegHd;	/* Circular forw list */
	PartHd.pt_forw = PartHd.pt_back = &PartHd;

	if(debug&DEBUG_PARTITION) fprintf(stderr,"-------------------BOOL_REGIONS\n");
d75 1
a75 5
		if( segp->seg_stp->st_bin == 0 )
			rtbomb("zero bin in bool_regions");
		/* Make sure seg's solid's region is on active list */
		if( segp->seg_stp->st_bin < 0 )  {
			register struct region *regp;		/* XXX */
d77 13
a89 7
			segp->seg_stp->st_bin = -(segp->seg_stp->st_bin);
			regp = segp->seg_tp->tr_regionp;
			if( (regp != REGION_NULL) &&
			   (regp->reg_active == REGION_NULL) )  {
				regp->reg_active = ActRegHd.reg_active;
				ActRegHd.reg_active = regp;
			}
a90 1
		if(debug&DEBUG_PARTITION) pr_seg(segp);
d96 1
a96 1
		if( PartHd.pt_forw == &PartHd )  {
d99 1
a99 1
			pp->pt_solhit[segp->seg_stp->st_bin] = TRUE;
d104 1
a104 1
			APPEND_PT( pp, &PartHd );
d107 1
a107 1
		if( segp->seg_in.hit_dist >= PartHd.pt_back->pt_outdist )  {
d113 1
a113 1
			pp->pt_solhit[segp->seg_stp->st_bin] = TRUE;
d118 1
a118 1
			APPEND_PT( pp, PartHd.pt_back );
d125 1
a125 1
		for( pp=PartHd.pt_forw; pp != &PartHd; pp=pp->pt_forw ) {
d128 1
a128 1
			if( (i=fdiff(lasthit->hit_dist, pp->pt_outdist)) > 0 )  {
d156 1
a156 1
			if( (i=fdiff(lasthit->hit_dist, pp->pt_indist)) == 0){
d166 1
a166 1
				if( (i = fdiff(segp->seg_out.hit_dist, pp->pt_outdist)) == 0 )  {
d173 1
a173 1
					pp->pt_solhit[segp->seg_stp->st_bin] = TRUE;
d185 1
a185 1
					pp->pt_solhit[segp->seg_stp->st_bin] = TRUE;
d199 1
a199 1
				*newpp = *pp;		/* struct copy */
d201 1
a201 1
				newpp->pt_solhit[segp->seg_stp->st_bin] = TRUE;
d220 1
a220 1
				newpp->pt_solhit[segp->seg_stp->st_bin] = TRUE;
d224 1
a224 1
				if( segp->seg_out.hit_dist <= pp->pt_indist ){
d232 12
a243 5
					 *
					 * Seg starts before current
					 * partition starts, and ends
					 * at the start of the partition.
					 * (diff == 0).
d249 1
a249 1
					newpp->pt_outhit = &segp->seg_out;
d274 1
a274 1
			 * lasthit->hit_dist > pp->pt_indist
d284 1
a284 1
			*newpp = *pp;			/* struct copy */
d303 1
a303 1
		newpp->pt_solhit[segp->seg_stp->st_bin] = TRUE;
d309 1
a309 1
		APPEND_PT( newpp, PartHd.pt_back );
d313 1
a313 1
			pr_partitions( &PartHd, "After weave" );
d315 1
a315 4
	if(debug&DEBUG_PARTITION)  {
		pr_act_regions( &ActRegHd );
		pr_bins();
	}
d317 22
a338 8
	/*
	 * For each partition, evaluate the boolean expression for
	 * all the regions.  If 0 regions result, continue with next
	 * partition.  If 1 region results, a valid hit has occured,
	 * so output a new segment.  If 2 or more regions claim the
	 * partition, then an overlap exists.
	 */
	FinalHdp->pt_forw = FinalHdp->pt_back = FinalHdp;
d340 2
a341 6
	pp = PartHd.pt_forw;
	while( pp != &PartHd )  {
		register struct region *lastregion;
		register struct region *regp;
		LOCAL int hitcnt;

d343 4
a346 2
		if(debug&DEBUG_PARTITION)
			fprintf(stderr,"considering partition %.8x\n", pp );
d349 3
a351 3
		if( pp->pt_indist >= pp->pt_outdist )  {
			fprintf(stderr,"bool_regions: thin inverted partition %.8x\n", pp);
			pr_partitions( &PartHd, "With problem" );
d353 5
a357 14
		if( pp->pt_forw != &PartHd && pp->pt_outdist > pp->pt_forw->pt_indist )  {
			auto struct partition FakeHead;
			auto odebug;
			fprintf(stderr,"bool_regions:  sorting defect!\n");
			if( debug & DEBUG_PARTITION ) return; /* give up */
			for( segp = segp_in; segp != SEG_NULL; segp = segp->seg_next )  {
				pr_seg(segp);
			}
			pr_partitions( &PartHd, "With DEFECT" );
			odebug = debug;
			debug |= DEBUG_PARTITION;
			bool_regions( segp_in, &FakeHead );
			debug = odebug;
			/* Wastes some dynamic memory */
d360 34
a393 5
		regp = ActRegHd.reg_active;
		for( ; regp != &ActRegHd; regp = regp->reg_active )  {
			if(debug&DEBUG_PARTITION)  {
				fprintf(stderr,"%.8x: %s\n", regp, regp->reg_name );
				pr_tree( regp->reg_treetop, 0 );
d395 5
a399 1
			if( bool_eval( regp->reg_treetop, pp ) == FALSE )
d401 3
d406 1
a406 1
				fprintf(stderr,"OVERLAP: %s %s (%f,%f)\n",
d409 2
a410 2
					pp->pt_indist,
					pp->pt_outdist );
d419 18
a436 1
		if( pp->pt_outdist <= EPSILON )  {
d457 1
a457 1
			if( one_hit_flag && newpp->pt_indist > 0.0 )
d462 2
a463 21
		pr_partitions( FinalHdp, "Final Partitions" );

	/*
	 * Cleanup:  zap the reg_active chain.
	 */
	{
		register struct region *regp;			/* XXX */
		for( regp=ActRegHd.reg_active; regp != &ActRegHd; )  {
			register struct region *newreg;		/* XXX */
			newreg = regp;
			regp = regp->reg_active;
			newreg->reg_active = REGION_NULL;
		}
	}
	for( pp = PartHd.pt_forw; pp != &PartHd;  )  {
		register struct partition *newpp;
		newpp = pp;
		pp = pp->pt_forw;
		FREE_PT(newpp);
	}
	/* Caller must Free seg chain and partition chain */
d469 10
a478 2
 *  Function -
 *  	Given a tree node, evaluate it, possibly recursing.
d481 4
a484 3
bool_eval( treep, partp )
register union tree *treep;
register struct partition *partp;
d486 6
d494 7
a501 1

d503 3
a505 3
		ret = ( partp->pt_solhit[treep->tr_stp->st_bin] );
		break;

a506 4
		ret =	bool_eval( treep->tr_left, partp )  ||
			bool_eval( treep->tr_right, partp ) ;
		break;

a507 4
		ret =	bool_eval( treep->tr_left, partp )  &&
			bool_eval( treep->tr_right, partp ) ;
		break;

d509 5
a513 6
		if( bool_eval( treep->tr_left, partp ) == FALSE )
			ret = FALSE;		/* FALSE = FALSE - X */
		else  {
			/* TRUE = TRUE - FALSE */
			/* FALSE = TRUE - TRUE */
			ret = !bool_eval( treep->tr_right, partp );
d515 2
a516 2
		break;

d518 2
a519 3
		fprintf(stderr,"bool_eval: bad op=x%x", treep->tr_op );
		ret = TRUE;		/* screw up output, get it fixed! */
		break;
d521 93
a613 1
	return( ret );
d625 1
a625 3
	fprintf(stderr,"----Partitions: %s\n", title);
	fprintf(stderr,"%.8x: forw=%.8x back=%.8x (HEAD)\n",
		phead, phead->pt_forw, phead->pt_back );
d627 1
a627 20
		fprintf(stderr,"%.8x: forw=%.8x back=%.8x (%f,%f)",
			pp, pp->pt_forw, pp->pt_back,
			pp->pt_indist, pp->pt_outdist );
		fprintf(stderr,"%s%s\n",
			pp->pt_inflip ? " Iflip" : "",
			pp->pt_outflip ?" Oflip" : "" );
#ifdef never
		fprintf(stderr,"\t Nin=[%f,%f,%f] Nout=[%f,%f,%f]\n",
			pp->pt_inhit->hit_normal[0],
			pp->pt_inhit->hit_normal[1],
			pp->pt_inhit->hit_normal[2],
			pp->pt_outhit->hit_normal[0],
			pp->pt_outhit->hit_normal[1],
			pp->pt_outhit->hit_normal[2] );
#endif
		fprintf(stderr,"Bins: ");
		for( i=0; i<NBINS; i++ )
			if( pp->pt_solhit[i] )
				fprintf(stderr,"%d, ", i );
		putc('\n',stderr);
d629 1
a629 1
	fprintf(stderr,"----\n");
d632 2
a633 3
static
pr_act_regions(headp)
register struct region *headp;
d635 10
a644 1
	register struct region *regp;
d646 16
a661 4
	fprintf(stderr,"Active Regions:\n");
	for( regp=headp->reg_active; regp != headp; regp=regp->reg_active )  {
		fprintf(stderr,"%.8x %s\n", regp, regp->reg_name );
	}
a663 3
#define	Abs( a )	((a) >= 0 ? (a) : -(a))
#define	Max( a, b )	((a) >= (b) ? (a) : (b))

d697 2
a698 1
	if( Abs(diff) < EPSILON * d )
d719 2
a720 1
	LOCAL double	d;
d722 10
a731 2
	d = Max( Abs( a ), Abs( b ) );	/* NOTE: not efficient */
	return( d == 0.0 ? 0.0 : Abs( a - b ) / d );
a733 14
void
pr_bins()
{
	register struct soltab *stp;
	extern struct soltab *HeadSolid;

	fprintf(stderr,"Bins:\n");
	for( stp=HeadSolid; stp != 0; stp=stp->st_forw ) {
		if( stp->st_bin == 0 )
			continue;
		fprintf(stderr,"%d: %s\n", stp->st_bin, stp->st_name );
	}
}

d741 1
a741 1
	fprintf(stderr,"%.8x: SEG %s (%f,%f) bin=%d\n",
d746 14
a759 1
		segp->seg_stp->st_bin );
@


1.22
log
@Slightly improved efficiency of code in fdiff().
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.21 85/06/07 00:54:00 mike Exp $ (BRL)";
d35 2
a36 1
#include "vmath.h"
@


1.21
log
@Fixed a problem with infinitely thin partitions occasionally
being generated.  Added an extra error print.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.21 85/06/07 00:29:26 mike Exp $ (BRL)";
d557 6
a562 1
	d = Max( Abs( a ), Abs( b ) );	/* NOTE: not efficient */
@


1.20
log
@Moved region and material pointer from solid structure to tree (leaf)
nodes, added path matrix and use count to solid structure, to permit
solids referenced with identical path matrices to "share",
resulting in far greater speed.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.19 85/03/25 11:44:14 mike Exp $ (BRL)";
d136 1
a136 1
			if( lasthit->hit_dist >= pp->pt_outdist )  {
d141 7
a147 2
				 *
				 * Or, Seg starts almost "precisely" at the
d151 3
a153 1
				 * Advance to next partition.
d155 2
a156 1
				 continue;
d158 5
a163 1
			/* Segment starts before current partition ends */
d340 5
a344 1
		/* Sanity check of sorting.  Remove later. */
@


1.19
log
@Housekeeping
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.18 85/02/04 21:50:54 mike Exp $ (BRL)";
a67 1
	LOCAL int curbin;
d72 1
a74 1
	curbin = 1;				/* bin 0 is always FALSE */
d84 2
d87 1
a87 1
		if( segp->seg_stp->st_bin == 0 )  {
d90 2
a91 3
			if( (segp->seg_stp->st_bin = curbin++) >= NBINS )
				rtbomb("bool_regions:  need > NBINS bins");
			regp = segp->seg_stp->st_regionp;
d397 1
a397 2
	 * Cleanup:  Put zeros in the bin#s of all the solids that were used,
	 * and zap the reg_active chain.
a398 3
	for( segp = segp_in; segp != SEG_NULL; segp = segp->seg_next )  {
		segp->seg_stp->st_bin = 0;
	}
@


1.18
log
@Tightened up ray-end fusion, keep things strictly ascending.
@
text
@d2 1
a2 1
 *			B O O L
d20 9
a28 5
 *
 *	U. S. Army Ballistic Research Laboratory
 *	April 13, 1984
 *
 * $Revision: 1.18 $
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.18 85/02/04 19:34:21 mike Exp $ (BRL)";
@


1.17
log
@Fixed problem with fdiff() being improperly used, resulting
in occasional unsorted partitions being emitted.
@
text
@d24 1
a24 1
 * $Revision: 1.16 $
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.16 85/02/01 21:26:32 mike Exp $ (BRL)";
d111 5
a115 2
		if( fdiff(segp->seg_in.hit_dist, PartHd.pt_back->pt_outdist) > 0 )  {
			/* Segment starts SIGNIFICANTLY beyond last partitions end */
d132 3
a134 3
			if( fdiff(lasthit->hit_dist, pp->pt_outdist) > 0 )  {
				/* Seg starts SIGNIFICANTLY after current
				 * partition ends.
d136 7
a142 1
				 *	      SSSS
d144 1
a144 1
				continue;
d146 3
a148 2
			i = fdiff(lasthit->hit_dist, pp->pt_indist);
			if( i == 0 )  {
d153 4
d158 1
a158 2
				i = fdiff(segp->seg_out.hit_dist, pp->pt_outdist);
				if( i == 0 )  {
d160 2
a161 2
					 * Segment and partition end
					 * (nearly) together
d170 2
a171 1
					 * Seg & partition start at same spot,
d183 3
a185 1
				/* Segment ends before partition ends
d216 17
a232 2
				if( fdiff(segp->seg_out.hit_dist, pp->pt_indist) < 0 )  {
					/* Seg ends SIGNIFICANTLY before partition starts */
d239 8
d257 3
a259 1
			 *	lasthit->hit_dist > pp->pt_indist
@


1.16
log
@Tightened up sanity check.
@
text
@d24 1
a24 1
 * $Revision: 1.15 $
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.15 84/11/29 07:02:26 mike Exp $ (BRL)";
d112 1
a112 1
			/* Segment starts beyond last partitions end */
d129 3
a131 3
			if( fdiff(lasthit->hit_dist, pp->pt_outdist) >= 0 )  {
				/* Seg starts after current partition ends,
				 * or exactly at the end.
d200 2
a201 2
				if( fdiff(segp->seg_out.hit_dist, pp->pt_indist) <= 0 )  {
					/* Seg ends before partition starts */
d204 1
d208 6
a213 3
				lastseg = newpp->pt_outseg = pp->pt_inseg;
				lasthit = newpp->pt_outhit = pp->pt_inhit;
				lastflip = newpp->pt_outflip = 1;
d271 1
a271 1
	FinalHdp->pt_forw = FinalHdp->pt_back = FinalHdp;	/* debug */
d285 2
d288 4
d293 5
d480 7
a486 1
 *  
@


1.15
log
@Added enforcement for rays extending in one direction only.
@
text
@d24 1
a24 1
 * $Revision: 1.14 $
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.14 84/11/27 07:00:21 mike Exp $ (BRL)";
d279 3
a281 3
		/* Sanity check.  Remove later. */
		if( pp->pt_forw != &PartHd && pp->pt_outdist > pp->pt_forw->pt_outdist )  {
			fprintf(stderr,"bool_regions:  defect!\n");
d341 1
a341 1
		segp->seg_stp->st_bin = FALSE;
@


1.14
log
@Corrected several major logic errors in handling of
segments crossing multiple partitions.  Introduced
"lasthit", "lastseg", and "lastflip" variables.
Several code simplifications resulted.
@
text
@d24 1
a24 1
 * $Revision: 1.13 $
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.13 84/11/24 03:01:49 mike Exp $ (BRL)";
d308 5
d409 1
a409 1
static
@


1.13
log
@Added pt_inflip and pt_outflip flags to (finally) get the
normal vectors right in all cases.
Note that the application must interpret these flags!
@
text
@d24 1
a24 1
 * $Revision: 1.12 $
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.12 84/11/23 20:53:52 mike Exp $ (BRL)";
d61 1
a61 2
	register struct seg *segp = segp_in;
	register struct soltab *stp;
d77 3
a79 1
		FAST fastf_t dist;				/* XXX */
d82 1
a82 2
		stp = segp->seg_stp;
		if( stp->st_bin == 0 )  {
d85 1
a85 1
			if( (stp->st_bin = curbin++) >= NBINS )
d87 1
a87 1
			regp = stp->st_regionp;
d103 2
a104 2
			pp->pt_solhit[stp->st_bin] = TRUE;
			pp->pt_instp = stp;
d106 1
a106 1
			pp->pt_outstp = stp;
d111 1
a111 2
		dist = segp->seg_in.hit_dist;
		if( fdiff(dist, PartHd.pt_back->pt_outdist) > 0 )  {
d114 2
a115 2
			pp->pt_solhit[stp->st_bin] = TRUE;
			pp->pt_instp = stp;
d117 1
a117 1
			pp->pt_outstp = stp;
d122 4
a125 17
		if( fdiff(segp->seg_out.hit_dist, PartHd.pt_back->pt_outdist) > 0 )  {
			/*
			 * Segment ends beyond the end of the last
			 * partition.  Create an additional partition.
			 *	PPPPPPPP
			 *	    SSSSSSSS
			 *	        |> pp
			 */
			GET_PT_INIT( pp );
			pp->pt_solhit[stp->st_bin] = TRUE;
			pp->pt_instp = PartHd.pt_back->pt_outstp;
			pp->pt_inhit = PartHd.pt_back->pt_outhit;
			pp->pt_inflip = 1;
			pp->pt_outstp = stp;
			pp->pt_outhit = &segp->seg_out;
			APPEND_PT( pp, PartHd.pt_back );
		}
d129 1
a129 1
			if( fdiff(dist, pp->pt_outdist) >= 0 )  {
d132 2
a134 14
				if( pp->pt_forw == &PartHd )  {
					/* seg starts beyond last part. end:
					 *	PPPP
					 *	      SSSS
					 */
					GET_PT_INIT( newpp );
					newpp->pt_solhit[stp->st_bin] = TRUE;
					newpp->pt_instp = stp;
					newpp->pt_inhit = &segp->seg_in;
					newpp->pt_outstp = stp;
					newpp->pt_outhit = &segp->seg_out;
					APPEND_PT( newpp, pp );
					goto done_weave;
				}
d137 1
a137 1
			i = fdiff(dist, pp->pt_indist);
d139 2
a140 1
equal_start:			/*
d152 1
a152 1
					pp->pt_solhit[stp->st_bin] = TRUE;
d156 5
a160 3
					/* Seg continues beyond part. end
					 *	PPPPPPPP
					 *	    SSSSSSSS
d163 4
a166 18
					pp->pt_solhit[stp->st_bin] = TRUE;
					dist = pp->pt_outdist;
					if( pp->pt_forw == &PartHd )  {
						/* beyond last part. end */
						GET_PT_INIT( newpp );
						newpp->pt_solhit[stp->st_bin] = TRUE;
						newpp->pt_instp = pp->pt_outstp;
						newpp->pt_inhit = pp->pt_outhit;
						newpp->pt_inflip = 1;
						newpp->pt_outstp = stp;
						newpp->pt_outhit = &segp->seg_out;
						APPEND_PT( newpp, pp );
						goto done_weave;
					}
					/*
					 * The rest of the work is done in the
					 * dist<indist case next pass through.
					 */
d177 2
a178 2
				newpp->pt_solhit[stp->st_bin] = TRUE;
				newpp->pt_outstp = stp;
d180 2
a181 1
				pp->pt_instp = stp;
d196 4
a199 6
				newpp->pt_solhit[stp->st_bin] = TRUE;
				newpp->pt_instp = stp;
				newpp->pt_inhit = &segp->seg_in;
				newpp->pt_outstp = stp;
				newpp->pt_outhit = &segp->seg_out;
				INSERT_PT( newpp, pp );
d202 3
d207 4
a210 4
				newpp->pt_outstp = pp->pt_instp;
				newpp->pt_outhit = pp->pt_inhit;
				newpp->pt_outflip = 1;
				/* dist = pp->pt_indist; */
d214 1
a214 1
			 *	dist > pp->pt_indist
d225 2
a226 2
			/* new partition is span before seg joins partition */
			pp->pt_instp = stp;
d228 2
a229 1
			newpp->pt_outstp = stp;
d235 17
a251 3
		fprintf(stderr,"bool_regions:  fell out of seg_weave loop\n");
		/* Sorry about the goto's, but they give added protection */
done_weave:	;
d271 2
a273 2
		LOCAL struct region *lastregion;
		register struct region *regp;
d279 6
d319 7
a325 2
			/* Shameless efficiency hack */
			if( !debug && one_hit_flag )  break;
d336 1
a336 2
		stp = segp->seg_stp;
		stp->st_bin = FALSE;
a385 5
		if( treep->tr_right->tr_op != OP_SOLID )  {
			fprintf(stderr,"bool_eval: rhs of MINUS not Solid\n");
			ret = FALSE;
			break;
		}
d416 1
a416 1
		fprintf(stderr,"%.8x: forw=%.8x back=%.8x (%f,%f)\n",
d419 3
@


1.12
log
@Added LOCAL, fastf_t declarations.
Made shootray() recursive.
@
text
@d24 1
a24 1
 * $Revision: 1.11 $
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.11 84/11/22 09:06:50 mike Exp $ (BRL)";
d45 10
d127 3
d135 1
d148 4
a151 1
					/* beyond last part. end */
d174 2
d181 5
a185 1
					/* Seg continues beyond part. end */
d194 1
d206 5
a210 1
				/* Segment ends before partition ends */
d215 5
a219 2
				newpp->pt_outstp = pp->pt_instp = stp;
				newpp->pt_outhit = pp->pt_inhit = &segp->seg_out;
d227 3
d244 1
d254 3
d261 5
a265 2
			newpp->pt_outstp = pp->pt_instp = stp;
			newpp->pt_outhit = pp->pt_inhit = &segp->seg_in;
d332 1
d396 5
d402 1
a402 1
			ret = FALSE;
d404 2
a406 5
			if( ret == FALSE )  {
				/* Was subtracted, flip exit normal */
				VREVERSE( partp->pt_outhit->hit_normal,
					  partp->pt_outhit->hit_normal );
			}
d447 1
a447 1
		putchar('\n');
@


1.11
log
@Various cleanups
@
text
@d6 2
a7 5
 * Input -
 *	Pointer to first in seg chain, to be processed.
 *	All seg structs should be freed before return.
 *
 * Output -
d11 3
d24 1
a24 1
 * $Revision: 1.10 $
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.10 84/11/20 20:14:10 mike Exp $ (BRL)";
d46 2
a47 2
struct partition *
bool_regions( segp_in )
d49 1
d54 3
a56 6
	static struct region ActRegHd;	/* Heads active circular forw list */
	static int curbin;
	static struct region *regp;
	static struct partition PartHd;	/* Heads active circular list */
	static struct partition FinalHd;	/* Heads final circ list */
	static int i;
d73 2
d127 2
d246 1
a246 1
	FinalHd.pt_forw = FinalHd.pt_back = &FinalHd;	/* debug */
d250 3
a252 2
		static int hitcnt;
		static struct region *lastregion;
d290 1
a290 1
			APPEND_PT( newpp, FinalHd.pt_back );
d296 1
a296 1
		pr_partitions( &FinalHd, "Final Partitions" );
d306 8
a313 5
	for( regp=ActRegHd.reg_active; regp != &ActRegHd; )  {
		register struct region *newreg;			/* XXX */
		newreg = regp;
		regp = regp->reg_active;
		newreg->reg_active = REGION_NULL;
d321 1
a321 3
	/* Free seg chain in caller */

	return( &FinalHd );
d466 1
a466 1
	static double	d;
@


1.10
log
@General cleanup
@
text
@d24 1
a24 1
 * $Revision: 1.9 $
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.9 84/11/16 06:27:48 mike Exp $ (BRL)";
d67 1
a67 1
	if(debug&DEBUG_PARTITION) printf("-------------------BOOL_REGIONS\n");
@


1.9
log
@header file shuffle
@
text
@d24 1
a24 1
 * $Revision: 1.8 $
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.8 84/10/19 01:37:58 mike Exp $ (BRL)";
d39 1
a39 1
extern int view_only;	/* non-zero if computation is for viewing only */
d76 1
a76 1
				bomb("bool_regions:  need > NBINS bins");
d226 1
a226 1
		printf("bool_regions:  fell out of seg_weave loop\n");
d253 1
a253 1
			printf("considering partition %.8x\n", pp );
d258 1
a258 1
				printf("%.8x: %s\n", regp, regp->reg_name );
d265 1
a265 1
				printf("OVERLAP: %s %s (%f,%f)\n",
d289 1
a289 1
			if( !debug && view_only )  break;
d326 1
d363 1
a363 1
		printf("bool_eval: bad op=x%x", treep->tr_op );
d379 2
a380 2
	printf("----Partitions: %s\n", title);
	printf("%.8x: forw=%.8x back=%.8x (HEAD)\n",
d383 1
a383 1
		printf("%.8x: forw=%.8x back=%.8x (%f,%f)\n",
d387 1
a387 1
		printf("\t Nin=[%f,%f,%f] Nout=[%f,%f,%f]\n",
d395 1
a395 1
		printf("Bins: ");
d398 1
a398 1
				printf("%d, ", i );
d401 1
a401 1
	printf("----\n");
d410 1
a410 1
	printf("Active Regions:\n");
d412 1
a412 1
		printf("%.8x %s\n", regp, regp->reg_name );
d468 1
d474 1
a474 1
	printf("Bins:\n");
d478 1
a478 1
		printf("%d: %s\n", stp->st_bin, stp->st_name );
d485 1
d489 1
a489 1
	printf("%.8x: SEG %s (%f,%f) bin=%d\n",
@


1.8
log
@Lint corrections
@
text
@d24 1
a24 1
 * $Revision: 1.7 $
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.7 84/10/19 00:06:49 mike Exp $ (BRL)";
d32 1
a32 1
#include "ray.h"
@


1.7
log
@Reorganization of functions for separation of application from ray functions.
@
text
@d24 1
a24 1
 * $Revision: 1.6 $
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.6 84/08/28 03:07:19 mike Exp $ (BRL)";
d41 1
a41 1
struct partition *FreePart = PART_NULL;		 /* Head of freelist */
d92 1
a92 1
			GET_PART_INIT( pp );
d98 1
a98 1
			APPEND_PART( pp, &PartHd );
d104 1
a104 1
			GET_PART_INIT( pp );
d110 1
a110 1
			APPEND_PART( pp, PartHd.pt_back );
d118 1
a118 1
			GET_PART_INIT( pp );
d124 1
a124 1
			APPEND_PART( pp, PartHd.pt_back );
d133 1
a133 1
					GET_PART_INIT( newpp );
d139 1
a139 1
					APPEND_PART( newpp, pp );
d165 1
a165 1
						GET_PART_INIT( newpp );
d171 1
a171 1
						APPEND_PART( newpp, pp );
d181 1
a181 1
				GET_PART( newpp );
d187 1
a187 1
				INSERT_PART( newpp, pp );
d195 1
a195 1
				GET_PART_INIT( newpp );
d201 1
a201 1
				INSERT_PART( newpp, pp );
d218 1
a218 1
			GET_PART( newpp );
d223 1
a223 1
			INSERT_PART( newpp, pp );
d285 1
a285 1
			DEQUEUE_PART( newpp );
d287 1
a287 1
			APPEND_PART( newpp, FinalHd.pt_back );
d313 1
a313 1
		FREE_PART(newpp);
d327 1
a327 1
register struct tree *treep;
@


1.6
log
@Fixed problem with shooting at solids that are not explicitly contained
in a "region".
@
text
@d24 1
a24 1
 * $Revision: 1.5 $
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.5 84/05/03 06:55:00 mike Exp $ (BRL)";
d478 14
@


1.5
log
@Performance enhancements, ARS fixes.
@
text
@d24 1
a24 4
 * TODO:
 *	Flip normals after subtraction!!
 *
 * $Revision: 1.4 $
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.4 84/05/02 05:10:12 mike Exp $ (BRL)";
d232 1
a232 1
	if(debug&DEBUG_PARTITION)
d234 2
d254 2
a255 4
		if( (regp=ActRegHd.reg_active) == &ActRegHd )  {
			lastregion = REGION_NULL;
			goto add_partition;
		}
d278 2
a279 1
add_partition:	/* Add this partition to the result queue */
d289 1
a289 1
			if( view_only )  break;
d465 13
@


1.4
log
@More ARS support, fixes of all kinds.
@
text
@d27 1
a27 1
 * $Revision: 1.3 $
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.3 84/05/01 06:39:14 mike Exp $ (BRL)";
d42 2
d131 14
a144 1
				/* Seg starts after current partition */
a152 1
if( debug&DEBUG_PARTITION) {pr_partitions( &PartHd, "at equal_start");printf("fdiff(%f,%f)\n", segp->seg_out.hit_dist, pp->pt_outdist);}
d268 1
a268 1
				printf("ERROR: region %s overlaps region %s in range (%f,%f)\n",
a272 2
				VPRINT("ERR IN Pt", pp->pt_inhit->hit_point );
				VPRINT("ERROUT Pt", pp->pt_outhit->hit_point);
d290 2
d417 3
d436 1
d439 5
a443 2
	if( NEAR_ZERO(diff) )
		return(0);
d447 20
@


1.3
log
@Modifications for ARS, code unified to use fastf_t
@
text
@d27 1
a27 1
 * $Revision: 1.2 $
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.2 84/04/26 05:35:03 mike Exp $ (BRL)";
a72 1
		if(debug&DEBUG_PARTITION) pr_seg(segp);
d85 1
d138 1
d152 15
a166 1
					/* NEEDS HELP */
d205 1
a208 1
			pp->pt_solhit[stp->st_bin] = TRUE;
d240 1
a240 1
			printf("considering partition x%x\n", pp );
d246 4
a249 2
			if(debug&DEBUG_PARTITION)
				printf("considering region x%x\n", regp );
d364 1
d373 1
d381 6
@


1.2
log
@Added flip of normal when subtracting, fixed some bugs.
@
text
@d27 1
a27 1
 * $Revision: 1.1 $
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: bool.c,v 1.1 84/04/18 02:19:43 mike Exp $ (BRL)";
d71 1
a71 1
		register float dist;				/* XXX */
d391 1
a391 1
float a, b;
d393 1
a393 1
	register float diff;
@


1.1
log
@Initial revision
@
text
@d27 1
a27 1
 * $Revision$
d30 1
a30 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d180 2
d226 5
a230 1
		for( regp=ActRegHd.reg_active; regp != &ActRegHd; regp = regp->reg_active )  {
d250 4
a253 2
		} else {
			/* Add this partition to the result queue */
d322 1
a322 1
		else
d324 6
d355 7
@
