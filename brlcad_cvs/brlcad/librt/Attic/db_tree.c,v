head	11.116;
access;
symbols
	ansi-20040405-merged:11.110.2.2
	postmerge-20040405-ansi:11.114
	premerge-20040404-ansi:11.113
	postmerge-autoconf:11.113
	autoconf-freeze:11.110.10.3
	premerge-autoconf:11.113
	ansi-20040316-freeze:11.110.2.1
	postmerge-20040315-windows:11.113
	premerge-20040315-windows:11.113
	windows-20040315-freeze:11.110.4.1
	autoconf-20031203:11.110
	autoconf-20031202:11.110
	autoconf-branch:11.110.0.10
	phong-branch:11.110.0.8
	photonmap-branch:11.110.0.6
	rel-6-1-DP:11.110
	windows-branch:11.110.0.4
	rel-6-0-2:11.108
	ansi-branch:11.110.0.2
	rel-6-0-1-branch:11.108.0.2
	hartley-6-0-post:11.109
	hartley-6-0-pre:11.108
	rel-6-0-1:11.108
	rel-6-0:11.107
	rel-5-4:11.87
	offsite-5-3-pre:11.99
	rel-5-3:11.87
	rel-5-2:11.87
	rel-5-1-branch:11.87.0.2
	rel-5-1:11.87
	rel-5-0:11.66
	rel-5-0-beta:11.66
	rel-4-5:11.60
	ctj-4-5-post:11.53
	ctj-4-5-pre:11.53
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.116
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	11.115;

11.115
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.114;

11.114
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.113;

11.113
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	11.112;

11.112
date	2003.12.11.02.20.00;	author jra;	state Exp;
branches;
next	11.111;

11.111
date	2003.12.09.14.56.01;	author jra;	state Exp;
branches;
next	11.110;

11.110
date	2002.08.20.17.07.57;	author jra;	state Exp;
branches
	11.110.2.1
	11.110.4.1
	11.110.10.1;
next	11.109;

11.109
date	2002.08.15.20.55.10;	author hartley;	state Exp;
branches;
next	11.108;

11.108
date	2002.05.29.15.08.46;	author jra;	state Exp;
branches;
next	11.107;

11.107
date	2002.02.22.02.42.43;	author morrison;	state Exp;
branches;
next	11.106;

11.106
date	2001.11.09.16.30.15;	author rbowers;	state Exp;
branches;
next	11.105;

11.105
date	2001.05.17.20.05.23;	author morrison;	state Exp;
branches;
next	11.104;

11.104
date	2001.05.08.20.13.53;	author jra;	state Exp;
branches;
next	11.103;

11.103
date	2001.04.20.22.29.42;	author morrison;	state Exp;
branches;
next	11.102;

11.102
date	2001.04.02.21.38.07;	author morrison;	state Exp;
branches;
next	11.101;

11.101
date	2001.03.31.01.57.06;	author morrison;	state Exp;
branches;
next	11.100;

11.100
date	2001.03.30.21.06.08;	author jra;	state Exp;
branches;
next	11.99;

11.99
date	2000.09.09.04.30.47;	author mike;	state Exp;
branches;
next	11.98;

11.98
date	2000.09.08.08.08.48;	author mike;	state Exp;
branches;
next	11.97;

11.97
date	2000.09.08.05.54.41;	author mike;	state Exp;
branches;
next	11.96;

11.96
date	2000.08.31.02.19.49;	author mike;	state Exp;
branches;
next	11.95;

11.95
date	2000.08.31.02.10.39;	author mike;	state Exp;
branches;
next	11.94;

11.94
date	2000.07.12.00.13.47;	author mike;	state Exp;
branches;
next	11.93;

11.93
date	2000.07.11.23.16.47;	author mike;	state Exp;
branches;
next	11.92;

11.92
date	2000.07.10.23.01.28;	author mike;	state Exp;
branches;
next	11.91;

11.91
date	2000.06.29.14.40.22;	author mike;	state Exp;
branches;
next	11.90;

11.90
date	2000.06.28.16.36.06;	author mike;	state Exp;
branches;
next	11.89;

11.89
date	2000.06.27.17.36.09;	author mike;	state Exp;
branches;
next	11.88;

11.88
date	2000.06.27.14.53.38;	author mike;	state Exp;
branches;
next	11.87;

11.87
date	2000.04.12.02.14.00;	author mike;	state Exp;
branches;
next	11.86;

11.86
date	2000.04.12.02.08.12;	author mike;	state Exp;
branches;
next	11.85;

11.85
date	2000.03.04.05.53.45;	author mike;	state Exp;
branches;
next	11.84;

11.84
date	2000.03.03.03.38.15;	author mike;	state Exp;
branches;
next	11.83;

11.83
date	2000.03.03.01.50.26;	author mike;	state Exp;
branches;
next	11.82;

11.82
date	2000.02.29.20.35.00;	author mike;	state Exp;
branches;
next	11.81;

11.81
date	2000.02.29.19.57.11;	author mike;	state Exp;
branches;
next	11.80;

11.80
date	2000.02.29.00.43.01;	author butler;	state Exp;
branches;
next	11.79;

11.79
date	2000.02.01.20.57.27;	author mike;	state Exp;
branches;
next	11.78;

11.78
date	2000.01.22.03.31.50;	author mike;	state Exp;
branches;
next	11.77;

11.77
date	2000.01.22.01.23.05;	author mike;	state Exp;
branches;
next	11.76;

11.76
date	2000.01.22.00.51.14;	author mike;	state Exp;
branches;
next	11.75;

11.75
date	2000.01.22.00.47.58;	author mike;	state Exp;
branches;
next	11.74;

11.74
date	2000.01.14.22.39.34;	author mike;	state Exp;
branches;
next	11.73;

11.73
date	2000.01.14.05.42.14;	author mike;	state Exp;
branches;
next	11.72;

11.72
date	2000.01.05.21.48.16;	author mike;	state Exp;
branches;
next	11.71;

11.71
date	2000.01.04.21.04.23;	author bparker;	state Exp;
branches;
next	11.70;

11.70
date	2000.01.04.17.58.20;	author bparker;	state Exp;
branches;
next	11.69;

11.69
date	99.12.28.23.30.07;	author mike;	state Exp;
branches;
next	11.68;

11.68
date	99.12.22.02.07.37;	author mike;	state Exp;
branches;
next	11.67;

11.67
date	99.11.24.23.02.32;	author mike;	state Exp;
branches;
next	11.66;

11.66
date	99.05.10.21.30.47;	author mike;	state Exp;
branches;
next	11.65;

11.65
date	99.05.10.16.03.36;	author mike;	state Exp;
branches;
next	11.64;

11.64
date	98.12.17.04.19.09;	author mike;	state Exp;
branches;
next	11.63;

11.63
date	98.06.22.19.50.39;	author jra;	state Exp;
branches;
next	11.62;

11.62
date	98.04.15.05.15.44;	author mike;	state Exp;
branches;
next	11.61;

11.61
date	98.04.02.23.48.12;	author mike;	state Exp;
branches;
next	11.60;

11.60
date	97.12.30.10.22.58;	author mike;	state Exp;
branches;
next	11.59;

11.59
date	97.12.30.10.07.08;	author mike;	state Exp;
branches;
next	11.58;

11.58
date	97.12.23.10.37.07;	author mike;	state Exp;
branches;
next	11.57;

11.57
date	97.12.23.06.37.01;	author mike;	state Exp;
branches;
next	11.56;

11.56
date	97.12.16.06.19.34;	author mike;	state Exp;
branches;
next	11.55;

11.55
date	97.12.16.00.12.31;	author mike;	state Exp;
branches;
next	11.54;

11.54
date	97.11.21.21.01.02;	author jra;	state Exp;
branches;
next	11.53;

11.53
date	97.04.15.14.30.06;	author jra;	state Exp;
branches;
next	11.52;

11.52
date	97.02.27.15.52.24;	author jra;	state Exp;
branches;
next	11.51;

11.51
date	97.02.26.18.21.28;	author jra;	state Exp;
branches;
next	11.50;

11.50
date	97.02.12.16.03.38;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	97.01.31.05.01.13;	author mike;	state Exp;
branches;
next	11.48;

11.48
date	97.01.31.02.19.30;	author butler;	state Exp;
branches;
next	11.47;

11.47
date	97.01.30.02.50.09;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	97.01.30.02.22.54;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	97.01.29.20.06.44;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	97.01.29.01.29.44;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	97.01.29.00.59.07;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	97.01.29.00.33.40;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	97.01.28.02.34.06;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	97.01.28.01.18.46;	author mike;	state Exp;
branches;
next	11.39;

11.39
date	97.01.26.03.03.41;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	97.01.24.19.33.34;	author pjt;	state Exp;
branches;
next	11.37;

11.37
date	96.12.04.02.51.56;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	96.11.27.11.29.48;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	96.11.27.11.10.42;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	96.11.27.10.12.32;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	96.11.27.09.18.37;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	96.11.27.09.11.19;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	96.11.22.08.55.51;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	96.11.22.08.49.03;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	96.10.19.06.17.45;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	96.10.19.05.46.47;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	96.10.19.05.38.42;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	96.10.19.05.22.59;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	96.10.16.03.14.01;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	96.10.12.03.01.06;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	96.10.05.09.13.54;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	96.09.27.07.07.47;	author butler;	state Exp;
branches;
next	11.20;

11.20
date	96.09.18.21.39.43;	author butler;	state Exp;
branches;
next	11.19;

11.19
date	96.09.17.04.36.36;	author butler;	state Exp;
branches;
next	11.18;

11.18
date	96.08.13.13.42.09;	author cnuzman;	state Exp;
branches;
next	11.17;

11.17
date	96.07.04.03.43.30;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	96.07.04.02.42.50;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	96.07.04.01.55.12;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	96.07.03.04.04.58;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	96.07.02.05.54.41;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	96.04.22.12.09.45;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	96.01.05.23.25.24;	author butler;	state Exp;
branches;
next	11.10;

11.10
date	96.01.04.23.44.18;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	95.11.07.16.32.53;	author adam;	state Exp;
branches;
next	11.8;

11.8
date	95.09.15.23.21.43;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.07.28.00.55.22;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.07.27.21.47.29;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.06.13.21.24.39;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	95.06.02.02.19.40;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.02.17.04.00.28;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.02.17.02.44.56;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.19;	author mike;	state Rel4_4;
branches;
next	10.15;

10.15
date	95.01.04.07.06.11;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	94.08.10.18.11.44;	author gdurf;	state Exp;
branches;
next	10.13;

10.13
date	94.05.10.11.04.17;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.05.04.07.13.52;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	94.04.07.23.02.38;	author cjohnson;	state Exp;
branches;
next	10.10;

10.10
date	94.04.05.02.14.51;	author cjohnson;	state Exp;
branches;
next	10.9;

10.9
date	94.04.01.18.03.06;	author cjohnson;	state Exp;
branches;
next	10.8;

10.8
date	94.03.31.23.49.17;	author cjohnson;	state Exp;
branches;
next	10.7;

10.7
date	93.11.13.00.20.09;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.10.22.18.42.07;	author cjohnson;	state Exp;
branches;
next	10.5;

10.5
date	93.03.18.15.28.22;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	93.01.20.14.07.33;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.11.11.00.05.41;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.10.27.16.23.55;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.05;	author mike;	state Rel4_0;
branches;
next	1.44;

1.44
date	91.10.10.22.22.58;	author mike;	state Exp;
branches;
next	1.43;

1.43
date	91.09.19.15.48.07;	author mike;	state Exp;
branches;
next	1.42;

1.42
date	91.08.29.19.45.58;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	91.07.25.01.42.14;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	91.07.16.22.23.17;	author mike;	state Exp;
branches;
next	1.39;

1.39
date	91.07.16.21.55.42;	author mike;	state Exp;
branches;
next	1.38;

1.38
date	91.07.16.00.43.48;	author mike;	state Exp;
branches;
next	1.37;

1.37
date	91.07.16.00.04.19;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	91.07.08.16.12.38;	author butler;	state Exp;
branches;
next	1.35;

1.35
date	91.07.05.21.25.27;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	91.07.05.21.07.38;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	91.06.29.22.13.51;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	91.06.29.17.08.30;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	91.06.25.06.30.30;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	91.06.25.03.58.27;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	91.06.24.23.43.52;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	91.06.11.01.32.56;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	91.05.23.10.38.21;	author jehunt;	state Exp;
branches;
next	1.26;

1.26
date	91.01.28.16.21.45;	author butler;	state Exp;
branches;
next	1.25;

1.25
date	91.01.26.02.56.04;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	90.12.11.22.03.55;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	90.11.11.04.56.29;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	90.11.02.03.41.06;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	90.11.02.02.36.59;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	90.11.02.02.18.21;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	90.05.21.14.33.54;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	90.05.04.06.23.46;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	90.04.25.00.05.23;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	90.04.24.21.07.59;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	90.04.24.02.40.18;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	90.04.12.23.12.22;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	90.04.12.04.10.10;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	90.04.12.02.52.32;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	90.04.12.02.46.18;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	90.04.12.02.28.56;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	90.04.12.02.23.25;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	90.04.12.00.46.36;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	90.04.12.00.31.02;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	90.04.11.21.31.31;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	90.04.10.16.10.56;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	90.04.10.05.48.10;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	90.04.10.02.36.47;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.04.09.22.07.59;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.04.05.05.49.39;	author mike;	state Exp;
branches;
next	;

11.110.2.1
date	2002.09.19.18.01.31;	author morrison;	state Exp;
branches;
next	11.110.2.2;

11.110.2.2
date	2004.03.17.21.18.44;	author morrison;	state Exp;
branches;
next	;

11.110.4.1
date	2004.03.11.23.43.36;	author morrison;	state Exp;
branches;
next	;

11.110.10.1
date	2003.12.17.15.35.37;	author erikg;	state Exp;
branches;
next	11.110.10.2;

11.110.10.2
date	2004.02.12.18.37.39;	author erikg;	state Exp;
branches;
next	11.110.10.3;

11.110.10.3
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@General database treewalker
@


11.116
log
@moved to src/
@
text
@/*
 *			D B _ T R E E . C
 *
 * Functions -
 *	db_walk_tree		Parallel tree walker
 *	db_path_to_mat		Given a path, return a matrix.
 *	db_region_mat		Given a name, return a matrix
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db_tree.c,v 11.115 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "nmg.h"
#include "raytrace.h"

#include "./debug.h"

BU_EXTERN(void db_ck_tree, (const union tree *tp));

/*
 *			D B _ D U P _ D B _ T R E E _ S T A T E
 *
 *  Duplicate the contents of a db_tree_state structure,
 *  including a private copy of the ts_mater field(s) and the attribute/value set.
 */
void
db_dup_db_tree_state(struct db_tree_state *otsp, const struct db_tree_state *itsp)
{
	int		shader_len=0;
	int		i;

	RT_CK_DBTS(itsp);
	RT_CK_DBI(itsp->ts_dbip);

	*otsp = *itsp;			/* struct copy */

	if( itsp->ts_mater.ma_shader )
		shader_len = strlen( itsp->ts_mater.ma_shader );
	if( shader_len )
	{
		otsp->ts_mater.ma_shader = (char *)bu_malloc( shader_len+1, "db_new_combined_tree_state: ma_shader" );
		strcpy( otsp->ts_mater.ma_shader, itsp->ts_mater.ma_shader );
	}
	else
		otsp->ts_mater.ma_shader = (char *)NULL;

	if( itsp->ts_attrs.count > 0 ) {
		bu_avs_init( &otsp->ts_attrs, itsp->ts_attrs.count, "otsp->ts_attrs" );
		for( i=0 ; i<itsp->ts_attrs.count ; i++ )
			bu_avs_add( &otsp->ts_attrs, itsp->ts_attrs.avp[i].name,
				    itsp->ts_attrs.avp[i].value );
	} else {
		bu_avs_init_empty( &otsp->ts_attrs );
	}
}

/*
 *			D B _ F R E E _ D B _ T R E E _ S T A T E
 *
 *  Release dynamic fields inside the structure, but not the structure itself.
 */
void
db_free_db_tree_state( struct db_tree_state *tsp )
{
	RT_CK_DBTS(tsp);
	RT_CK_DBI(tsp->ts_dbip);
	if( tsp->ts_mater.ma_shader )  {
		bu_free( tsp->ts_mater.ma_shader, "db_free_combined_tree_state: ma_shader" );
		tsp->ts_mater.ma_shader = (char *)NULL;		/* sanity */
	}
	if( tsp->ts_attrs.max > 0 ) {
		bu_avs_free( &tsp->ts_attrs );
		tsp->ts_attrs.avp = (struct bu_attribute_value_pair *)NULL;
	}
	tsp->ts_dbip = (struct db_i *)NULL;			/* sanity */
}

/*
 *			D B _ I N I T _ D B _ T R E E _ S T A T E
 *
 *  In most cases, you don't want to use this routine, you want to
 *  struct copy mged_initial_tree_state or rt_initial_tree_state,
 *  and then set ts_dbip in your copy.
 */
void
db_init_db_tree_state( struct db_tree_state *tsp, struct db_i *dbip, struct resource *resp )
{
	RT_CK_DBI(dbip);
	RT_CK_RESOURCE(resp);

	bzero( (char *)tsp, sizeof(*tsp) );
	tsp->magic = RT_DBTS_MAGIC;
	tsp->ts_dbip = dbip;
	tsp->ts_resp = resp;
	bu_avs_init_empty( &tsp->ts_attrs );
	MAT_IDN( tsp->ts_mat );	/* XXX should use null pointer convention! */
}

/*
 *			D B _ N E W _ C O M B I N E D _ T R E E _ S T A T E
 */
struct combined_tree_state *
db_new_combined_tree_state(register const struct db_tree_state *tsp, register const struct db_full_path *pathp)
{
	struct combined_tree_state	*new;

	RT_CK_DBTS(tsp);
	RT_CK_FULL_PATH(pathp);
	RT_CK_DBI(tsp->ts_dbip);

	BU_GETSTRUCT( new, combined_tree_state );
	new->magic = RT_CTS_MAGIC;
	db_dup_db_tree_state( &(new->cts_s), tsp );
	db_full_path_init( &(new->cts_p) );
	db_dup_full_path( &(new->cts_p), pathp );
	return new;
}

/*
 *			D B _ D U P _ C O M B I N E D _ T R E E _ S T A T E
 */
struct combined_tree_state *
db_dup_combined_tree_state(const struct combined_tree_state *old)
{
	struct combined_tree_state	*new;

 	RT_CK_CTS(old);
	BU_GETSTRUCT( new, combined_tree_state );
	new->magic = RT_CTS_MAGIC;
	db_dup_db_tree_state( &(new->cts_s), &(old->cts_s) );
	db_full_path_init( &(new->cts_p) );
	db_dup_full_path( &(new->cts_p), &(old->cts_p) );
	return new;
}

/*
 *			D B _ F R E E _ C O M B I N E D _ T R E E _ S T A T E
 */
void
db_free_combined_tree_state(register struct combined_tree_state *ctsp)
{
 	RT_CK_CTS(ctsp);
	db_free_full_path( &(ctsp->cts_p) );
	db_free_db_tree_state( &(ctsp->cts_s) );
	bzero( (char *)ctsp, sizeof(*ctsp) );		/* sanity */
	bu_free( (char *)ctsp, "combined_tree_state");
}

/*
 *			D B _ P R _ T R E E _ S T A T E
 */
void
db_pr_tree_state(register const struct db_tree_state *tsp)
{
	int i;

	RT_CK_DBTS(tsp);

	bu_log("db_pr_tree_state(x%x):\n", tsp);
	bu_log(" ts_dbip=x%x\n", tsp->ts_dbip);
	bu_printb(" ts_sofar", tsp->ts_sofar, "\020\3REGION\2INTER\1MINUS" );
	bu_log("\n");
	bu_log(" ts_regionid=%d\n", tsp->ts_regionid);
	bu_log(" ts_aircode=%d\n", tsp->ts_aircode);
	bu_log(" ts_gmater=%d\n", tsp->ts_gmater);
	bu_log(" ts_los=%d\n", tsp->ts_los);
	bu_log(" ts_mater.ma_color=%g,%g,%g\n",
		tsp->ts_mater.ma_color[0],
		tsp->ts_mater.ma_color[1],
		tsp->ts_mater.ma_color[2] );
	bu_log(" ts_mater.ma_temperature=%g K\n", tsp->ts_mater.ma_temperature);
	bu_log(" ts_mater.ma_shader=%s\n", tsp->ts_mater.ma_shader ? tsp->ts_mater.ma_shader : "" );
	for( i=0 ; i<tsp->ts_attrs.count ; i++ ) {
		bu_log( "\t%s = %s\n", tsp->ts_attrs.avp[i].name, tsp->ts_attrs.avp[i].value );
	}
	bn_mat_print("ts_mat", tsp->ts_mat );
	bu_log(" ts_resp=x%x\n", tsp->ts_resp );
}

/*
 *			D B _ P R _ C O M B I N E D _ T R E E _ S T A T E
 */
void
db_pr_combined_tree_state(register const struct combined_tree_state *ctsp)
{
	char	*str;

 	RT_CK_CTS(ctsp);
	bu_log("db_pr_combined_tree_state(x%x):\n", ctsp);
	db_pr_tree_state( &(ctsp->cts_s) );
	str = db_path_to_string( &(ctsp->cts_p) );
	bu_log(" path='%s'\n", str);
	bu_free( str, "path string" );
}

/*
 *			D B _ A P P L Y _ S T A T E _ F R O M _ C O M B
 *
 *  Handle inheritance of material property found in combination record.
 *  Color and the material property have separate inheritance interlocks.
 *
 *  Returns -
 *	-1	failure
 *	 0	success
 *	 1	success, this is the top of a new region.
 */
int
db_apply_state_from_comb(struct db_tree_state *tsp, const struct db_full_path *pathp, register const struct rt_comb_internal *comb)
{
	RT_CK_DBTS(tsp);
	RT_CK_COMB(comb);

	if( comb->rgb_valid == 1 )  {
		if( tsp->ts_sofar & TS_SOFAR_REGION )  {
			if( (tsp->ts_sofar&(TS_SOFAR_MINUS|TS_SOFAR_INTER)) == 0 )  {
				/* This combination is within a region */
				char	*sofar = db_path_to_string(pathp);

				bu_log("db_apply_state_from_comb(): WARNING: color override in combination within region '%s', ignored\n",
					sofar );
				bu_free(sofar, "path string");
			}
			/* Just quietly ignore it -- it's being subtracted off */
		} else if( tsp->ts_mater.ma_cinherit == 0 )  {
			/* DB_INH_LOWER was set -- lower nodes in tree override */
			tsp->ts_mater.ma_color_valid = 1;
			tsp->ts_mater.ma_color[0] =
				(((float)(comb->rgb[0]))*bn_inv255);
			tsp->ts_mater.ma_color[1] =
				(((float)(comb->rgb[1]))*bn_inv255);
			tsp->ts_mater.ma_color[2] =
				(((float)(comb->rgb[2]))*bn_inv255);
			/* Track further inheritance as specified by this combination */
			tsp->ts_mater.ma_cinherit = comb->inherit;
		}
	}
	if( comb->temperature > 0 )  {
		if( tsp->ts_sofar & TS_SOFAR_REGION )  {
			if( (tsp->ts_sofar&(TS_SOFAR_MINUS|TS_SOFAR_INTER)) == 0 )  {
				/* This combination is within a region */
				char	*sofar = db_path_to_string(pathp);

				bu_log("db_apply_state_from_comb(): WARNING: temperature in combination below region '%s', ignored\n",
					sofar );
				bu_free(sofar, "path string");
			}
			/* Just quietly ignore it -- it's being subtracted off */
		} else if( tsp->ts_mater.ma_minherit == 0 )  {
			/* DB_INH_LOWER -- lower nodes in tree override */
			tsp->ts_mater.ma_temperature = comb->temperature;
		}
	}
	if( bu_vls_strlen( &comb->shader ) > 0 )  {
		if( tsp->ts_sofar & TS_SOFAR_REGION )  {
			if( (tsp->ts_sofar&(TS_SOFAR_MINUS|TS_SOFAR_INTER)) == 0 )  {
				/* This combination is within a region */
				char	*sofar = db_path_to_string(pathp);

				bu_log("db_apply_state_from_comb(): WARNING: material property spec in combination below region '%s', ignored\n",
					sofar );
				bu_free(sofar, "path string");
			}
			/* Just quietly ignore it -- it's being subtracted off */
		} else if( tsp->ts_mater.ma_minherit == 0 )  {
			struct bu_vls tmp_vls;

			/* DB_INH_LOWER -- lower nodes in tree override */
			if( tsp->ts_mater.ma_shader )
				bu_free( (genptr_t)tsp->ts_mater.ma_shader, "ma_shader" );

			bu_vls_init( &tmp_vls );
			if( bu_shader_to_key_eq( bu_vls_addr( &comb->shader ), &tmp_vls ) )
			{
				char *sofar = db_path_to_string(pathp);

				bu_log( "db_apply_state_from_comb: Warning: bad shader in %s (ignored):\n", sofar );
				bu_vls_free( &tmp_vls );
				bu_free(sofar, "path string");
				tsp->ts_mater.ma_shader = (char *)NULL;
			}
			else
			{
				tsp->ts_mater.ma_shader = bu_vls_strdup( &tmp_vls );
				bu_vls_free( &tmp_vls );
			}
			tsp->ts_mater.ma_minherit = comb->inherit;
		}
	}

	/* Handle combinations which are the top of a "region" */
	if( comb->region_flag )  {
		if( tsp->ts_sofar & TS_SOFAR_REGION )  {
			if( (tsp->ts_sofar&(TS_SOFAR_MINUS|TS_SOFAR_INTER)) == 0 )  {
				char	*sofar = db_path_to_string(pathp);
				bu_log("Warning:  region unioned into region at '%s', lower region info ignored\n",
					sofar);
				bu_free(sofar, "path string");
			}
			/* Go on as if it was not a region */
		} else {
			/* This starts a new region */
			tsp->ts_sofar |= TS_SOFAR_REGION;
			tsp->ts_regionid = comb->region_id;
			tsp->ts_is_fastgen = comb->is_fastgen;
			tsp->ts_aircode = comb->aircode;
			tsp->ts_gmater = comb->GIFTmater;
			tsp->ts_los = comb->los;
			return(1);	/* Success, this starts new region */
		}
	}
	return(0);	/* Success */
}

/*
 *			D B _ A P P L Y _ S T A T E _ F R O M _ M E M B
 *
 *  Updates state via *tsp, pushes member's directory entry on *pathp.
 *  (Caller is responsible for popping it).
 *
 *  Returns -
 *	-1	failure
 *	 0	success, member pushed on path
 */
int
db_apply_state_from_memb(struct db_tree_state *tsp, struct db_full_path *pathp, const union tree *tp)
{
	register struct directory *mdp;
	mat_t			xmat;
	mat_t			old_xlate;

	RT_CK_DBTS(tsp);
	RT_CK_FULL_PATH(pathp);
	RT_CK_TREE(tp);

	if( (mdp = db_lookup( tsp->ts_dbip, tp->tr_l.tl_name, LOOKUP_QUIET )) == DIR_NULL )  {
		char	*sofar = db_path_to_string(pathp);
		bu_log("db_lookup(%s) failed in %s\n", tp->tr_l.tl_name, sofar);
		bu_free(sofar, "path string");
		return -1;
	}

	db_add_node_to_full_path( pathp, mdp );

	MAT_COPY( old_xlate, tsp->ts_mat );
	if( tp->tr_l.tl_mat ) {
		MAT_COPY( xmat, tp->tr_l.tl_mat );
	}
	else {
		MAT_IDN( xmat );
	}

	/*  If the owning region it above this node in the tree,
	 *  it is not possible to animation region-material properties
	 *  lower down in the arc.  So note by sending a NULL pointer.
	 */
	db_apply_anims( pathp, mdp, old_xlate, xmat,
		(tsp->ts_sofar & TS_SOFAR_REGION) ? 
			(struct mater_info *)NULL :
			&tsp->ts_mater );

	bn_mat_mul(tsp->ts_mat, old_xlate, xmat);

	return(0);		/* Success */
}

/*
 *		D B _ A P P L Y _ S T A T E _ F R O M _ O N E _ M E M B E R
 *
 *  Returns -
 *	-1	found member, failed to apply state
 *	 0	unable to find member 'cp'
 *	 1	state applied OK
 */
int
db_apply_state_from_one_member(
	struct db_tree_state *tsp,
	struct db_full_path *pathp,
	const char *cp,
	int sofar,
	const union tree *tp )
{
	int	ret;

	RT_CK_DBTS(tsp);
	RT_CHECK_DBI( tsp->ts_dbip );
	RT_CK_FULL_PATH( pathp );
	RT_CK_TREE(tp);

	switch( tp->tr_op )  {

	case OP_DB_LEAF:
		if( strcmp( cp, tp->tr_l.tl_name ) != 0 )
			return 0;		/* NO-OP */
		tsp->ts_sofar |= sofar;
		if( db_apply_state_from_memb( tsp, pathp, tp ) < 0 )
			return -1;		/* FAIL */
		return 1;			/* success */

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		ret = db_apply_state_from_one_member( tsp, pathp, cp, sofar,
			tp->tr_b.tb_left );
		if( ret != 0 )  return ret;
		if( tp->tr_op == OP_SUBTRACT )
			sofar |= TS_SOFAR_MINUS;
		else if( tp->tr_op == OP_INTERSECT )
			sofar |= TS_SOFAR_INTER;
		return db_apply_state_from_one_member( tsp, pathp, cp, sofar,
			tp->tr_b.tb_right );

	default:
		bu_log("db_apply_state_from_one_member: bad op %d\n", tp->tr_op);
		bu_bomb("db_apply_state_from_one_member\n");
	}
	return -1;
}

/*
 *			D B _ F I N D _ N A M E D _ L E A F
 *
 *  The search stops on the first match.
 *
 *  Returns -
 *	tp		if found
 *	TREE_NULL	if not found in this tree
 */
union tree *
db_find_named_leaf( union tree *tp, const char *cp )
{
	union tree	*ret;

	RT_CK_TREE(tp);

	switch( tp->tr_op )  {

	case OP_DB_LEAF:
		if( strcmp( cp, tp->tr_l.tl_name )  )
			return TREE_NULL;
		return tp;

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		ret = db_find_named_leaf( tp->tr_b.tb_left, cp );
		if( ret != TREE_NULL )  return ret;
		return db_find_named_leaf( tp->tr_b.tb_right, cp );

	default:
		bu_log("db_find_named_leaf: bad op %d\n", tp->tr_op);
		bu_bomb("db_find_named_leaf\n");
	}
	return TREE_NULL;
}

/*
 *			D B _ F I N D _ N A M E D _ L E A F S _ P A R E N T
 *
 *  The search stops on the first match.
 *
 *  Returns -
 *	TREE_NULL	if not found in this tree
 *	tp		if found
 *			*side == 1 if leaf is on lhs.
 *			*side == 2 if leaf is on rhs.
 *
 */
union tree *
db_find_named_leafs_parent( int *side, union tree *tp, const char *cp )
{
	union tree	*ret;

	RT_CK_TREE(tp);

	switch( tp->tr_op )  {

	case OP_DB_LEAF:
		/* Always return NULL -- we are seeking parent, not leaf */
		return TREE_NULL;

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		if( tp->tr_b.tb_left->tr_op == OP_DB_LEAF )  {
			if( strcmp( cp, tp->tr_b.tb_left->tr_l.tl_name ) == 0 )  {
				*side = 1;
				return tp;
			}
		}
		if( tp->tr_b.tb_right->tr_op == OP_DB_LEAF )  {
			if( strcmp( cp, tp->tr_b.tb_right->tr_l.tl_name ) == 0 )  {
				*side = 2;
				return tp;
			}
		}

		/* If target not on immediate children, descend down. */
		ret = db_find_named_leafs_parent( side, tp->tr_b.tb_left, cp );
		if( ret != TREE_NULL )  return ret;
		return db_find_named_leafs_parent( side, tp->tr_b.tb_right, cp );

	default:
		bu_log("db_find_named_leafs_parent: bad op %d\n", tp->tr_op);
		bu_bomb("db_find_named_leafs_parent\n");
	}
	return TREE_NULL;
}

/*
 *			D B _ T R E E _ D E L _ L H S
 */
void
db_tree_del_lhs( union tree *tp, struct resource *resp )
{
	union tree	*subtree;

	RT_CK_TREE(tp);

	switch( tp->tr_op )  {

	default:
		bu_bomb("db_tree_del_lhs() called with leaf node as parameter\n");

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		switch( tp->tr_b.tb_left->tr_op )  {
		case OP_NOP:
		case OP_SOLID:
		case OP_REGION:
		case OP_NMG_TESS:
		case OP_DB_LEAF:
			/* lhs is indeed a leaf node */
			db_free_tree( tp->tr_b.tb_left, resp );
			tp->tr_b.tb_left = TREE_NULL;	/* sanity */
			subtree = tp->tr_b.tb_right;
			/*
			 *  Since we don't know what node has the downpointer
			 *  to 'tp', replicate 'subtree' data in 'tp' node,
			 *  then release memory of 'subtree' node
			 *  (but not the actual subtree).
			 */
			*tp = *subtree;			/* struct copy */
			RT_FREE_TREE( subtree, resp );
			return;
		default:
			bu_bomb("db_tree_del_lhs()  lhs is not a leaf node\n");
		}
	}
}

/*
 *			D B _ T R E E _ D E L _ R H S
 */
void
db_tree_del_rhs( union tree *tp, struct resource *resp )
{
	union tree	*subtree;

	RT_CK_TREE(tp);

	switch( tp->tr_op )  {

	default:
		bu_bomb("db_tree_del_rhs() called with leaf node as parameter\n");

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		switch( tp->tr_b.tb_right->tr_op )  {
		case OP_NOP:
		case OP_SOLID:
		case OP_REGION:
		case OP_NMG_TESS:
		case OP_DB_LEAF:
			/* rhs is indeed a leaf node */
			db_free_tree( tp->tr_b.tb_right, resp );
			tp->tr_b.tb_right = TREE_NULL;	/* sanity */
			subtree = tp->tr_b.tb_left;
			/*
			 *  Since we don't know what node has the downpointer
			 *  to 'tp', replicate 'subtree' data in 'tp' node,
			 *  then release memory of 'subtree' node
			 *  (but not the actual subtree).
			 */
			*tp = *subtree;			/* struct copy */
			RT_FREE_TREE( subtree, resp );
			return;
		default:
			bu_bomb("db_tree_del_rhs()  rhs is not a leaf node\n");
		}
	}
}

/*
 *			D B _ T R E E _ D E L _ D B L E A F
 *
 *  Given a name presumably referenced in a OP_DB_LEAF node,
 *  delete that node, and the operation node that references it.
 *  Not that this may not produce an equivalant tree,
 *  for example when rewriting (A - subtree) as (subtree),
 *  but that will be up to the caller/user to adjust.
 *  This routine gets rid of exactly two nodes in the tree: leaf, and op.
 *  Use some other routine if you wish to kill the entire rhs
 *  below "-" and "intersect" nodes.
 *
 *  The two nodes deleted will have their memory freed.
 *
 *  If the tree is a single OP_DB_LEAF node, the leaf is freed and
 *  *tp is set to NULL.
 *
 *  Returns -
 *	-3	Internal error
 *	-2	Tree is empty
 *	-1	Unable to find OP_DB_LEAF node specified by 'cp'.
 *	 0	OK
 */
int
db_tree_del_dbleaf(union tree **tp, const char *cp, struct resource *resp)
{
	union tree	*parent;
	int		side = 0;

	if( *tp == TREE_NULL )  return -1;

	RT_CK_TREE(*tp);
	RT_CK_RESOURCE(resp);

	if( (parent = db_find_named_leafs_parent( &side, *tp, cp )) == TREE_NULL )  {
		/* Perhaps the root of the tree is the named leaf? */
		if( (*tp)->tr_op == OP_DB_LEAF &&
		    strcmp( cp, (*tp)->tr_l.tl_name ) == 0 )  {
		    	db_free_tree( *tp, resp );
		    	*tp = TREE_NULL;
		    	return 0;
		}
		return -2;
	}

	switch( side )  {
	case 1:
		db_tree_del_lhs( parent, resp );
		(void)db_tree_del_dbleaf( tp, cp, resp );	/* recurse for extras */
		return 0;
	case 2:
		db_tree_del_rhs( parent, resp );
		(void)db_tree_del_dbleaf( tp, cp, resp );	/* recurse for extras */
		return 0;
	}
	bu_log("db_tree_del_dbleaf() unknown side=%d?\n", side);
	return -3;
}

/*
 *			D B _ T R E E _ M U L _ D B L E A F
 *
 *  Multiply on the left every matrix found in a DB_LEAF node in a tree.
 */
void
db_tree_mul_dbleaf( union tree *tp, const mat_t mat )
{
	mat_t	temp;

	RT_CK_TREE(tp);

	switch( tp->tr_op )  {

	case OP_DB_LEAF:
		if( tp->tr_l.tl_mat == NULL )  {
			tp->tr_l.tl_mat = bn_mat_dup(mat);
			return;
		}
		bn_mat_mul( temp, mat, tp->tr_l.tl_mat );
		MAT_COPY( tp->tr_l.tl_mat, temp );
		break;

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		db_tree_mul_dbleaf( tp->tr_b.tb_left, mat );
		db_tree_mul_dbleaf( tp->tr_b.tb_right, mat );
		break;

	default:
		bu_log("db_tree_mul_dbleaf: bad op %d\n", tp->tr_op);
		bu_bomb("db_tree_mul_dbleaf\n");
	}
}

/*
 *			D B _ T R E E _ F U N C L E A F
 *
 *	This routine traverses a combination (union tree) in LNR order
 *	and calls the provided function for each OP_DB_LEAF node.
 *	Note that this routine does not go outside this one
 *	combination!!!!
 *	was comb_functree().
 */
void
db_tree_funcleaf(
	struct db_i		*dbip,
	struct rt_comb_internal	*comb,
	union tree		*comb_tree,
	void			(*leaf_func)(),
	genptr_t		user_ptr1,
	genptr_t		user_ptr2,
	genptr_t		user_ptr3 )
{
	RT_CK_DBI( dbip );

	if( !comb_tree )
		return;

	RT_CK_TREE( comb_tree );

	switch( comb_tree->tr_op )
	{
		case OP_DB_LEAF:
			(*leaf_func)( dbip, comb, comb_tree, user_ptr1, user_ptr2, user_ptr3 );
			break;
		case OP_UNION:
		case OP_INTERSECT:
		case OP_SUBTRACT:
		case OP_XOR:
			db_tree_funcleaf( dbip, comb, comb_tree->tr_b.tb_left, leaf_func, user_ptr1, user_ptr2, user_ptr3 );
			db_tree_funcleaf( dbip, comb, comb_tree->tr_b.tb_right, leaf_func, user_ptr1, user_ptr2, user_ptr3 );
			break;
		default:
			bu_log( "db_tree_funcleaf: bad op %d\n", comb_tree->tr_op );
			bu_bomb( "db_tree_funcleaf: bad op\n" );
			break;
	}
}

/*
 *			D B _ F O L L O W _ P A T H
 *
 *  Starting with possible prior partial path and corresponding accumulated state,
 *  follow the path given by "new_path", updating
 *  *tsp and *total_path with full state information along the way.
 *  In a better world, there would have been a "combined_tree_state" arg.
 *
 *  Parameter 'depth' controls how much of 'new_path' is used:
 *	0	use all of new_path
 *	>0	use only this many of the first elements of the path
 *	<0	use all but this many path elements.
 *
 *  A much more complete version of rt_plookup() and pathHmat().
 *  There is also a TCL interface.
 *
 *  Returns -
 *	 0	success (plus *tsp is updated)
 *	-1	error (*tsp values are not useful)
 */
int
db_follow_path(
	struct db_tree_state		*tsp,
	struct db_full_path		*total_path,
	const struct db_full_path	*new_path,
	int				noisy,
	int				depth )		/* # arcs in new_path to use */
{
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	struct directory	*comb_dp;	/* combination's dp */
	struct directory	*dp;		/* element's dp */
	int			j;

	RT_CK_DBTS(tsp);
	RT_CHECK_DBI( tsp->ts_dbip );
	RT_CK_FULL_PATH( total_path );
	RT_CK_FULL_PATH( new_path );
	RT_CK_RESOURCE( tsp->ts_resp );

	if(RT_G_DEBUG&DEBUG_TREEWALK)  {
		char	*sofar = db_path_to_string(total_path);
		char	*toofar = db_path_to_string(new_path);
		bu_log("db_follow_path() total_path='%s', tsp=x%x, new_path='%s', noisy=%d, depth=%d\n",
			sofar, tsp, toofar, noisy, depth );
		bu_free(sofar, "path string");
		bu_free(toofar, "path string");
	}

	if( depth < 0 )  {
		depth = new_path->fp_len-1 + depth;
		if( depth < 0 ) rt_bomb("db_follow_path() depth exceeded provided path\n");
	} else if( depth >= new_path->fp_len )  {
		depth = new_path->fp_len-1;
	} else if( depth == 0 )  {
		/* depth of zero means "do it all". */
		depth = new_path->fp_len-1;
	}

	j = 0;

	/* Get the first combination */
	if( total_path->fp_len > 0 )  {
		/* Some path has already been processed */
		comb_dp = DB_FULL_PATH_CUR_DIR(total_path);
	}  else  {
		/* No prior path. Process any animations located at the root */
		comb_dp = DIR_NULL;
		dp = new_path->fp_names[0];
		RT_CK_DIR(dp);

		if( tsp->ts_dbip->dbi_anroot )  {
			register struct animate *anp;
			mat_t	old_xlate, xmat;

			for( anp=tsp->ts_dbip->dbi_anroot; anp != ANIM_NULL; anp = anp->an_forw ) {
				RT_CK_ANIMATE(anp);
				if( dp != anp->an_path.fp_names[0] )
					continue;
				MAT_COPY( old_xlate, tsp->ts_mat );
				MAT_IDN( xmat );
				db_do_anim( anp, old_xlate, xmat, &(tsp->ts_mater) );
				bn_mat_mul( tsp->ts_mat, old_xlate, xmat );
			}
		}

		/* Put first element on output path, either way */
		db_add_node_to_full_path( total_path, dp );

		if( (dp->d_flags & DIR_COMB) == 0 )  goto is_leaf;

		/* Advance to next path element */
		j = 1;
		comb_dp = dp;
	}
	/*
	 *  Process two things at once:
	 *  the combination at [j], and it's member at [j+1].
	 */
	do  {
		/* j == depth is the last one, presumably a leaf */
		if( j > depth )  break;
		dp = new_path->fp_names[j];
		RT_CK_DIR(dp);

		if( (comb_dp->d_flags & DIR_COMB) == 0 )  {
			bu_log("db_follow_path() %s isn't combination\n", comb_dp->d_namep);
			goto fail;
		}

		/* At this point, comb_db is the comb, dp is the member */
		if(RT_G_DEBUG&DEBUG_TREEWALK)  {
			bu_log("db_follow_path() at %s/%s\n", comb_dp->d_namep, dp->d_namep );
		}

		/* Load the combination object into memory */
		if( rt_db_get_internal( &intern, comb_dp, tsp->ts_dbip, NULL, tsp->ts_resp ) < 0 )
			goto fail;
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		RT_CK_COMB(comb);
		if( db_apply_state_from_comb( tsp, total_path, comb ) < 0 )
			goto fail;

		/* Crawl tree searching for specified leaf */
		if( db_apply_state_from_one_member( tsp, total_path, dp->d_namep, 0, comb->tree ) <= 0 )  {
			bu_log("db_follow_path() ERROR: unable to apply member %s state\n", dp->d_namep);
			goto fail;
		}
		/* Found it, state has been applied, sofar applied,
		 * member's directory entry pushed onto total_path
		 */
		rt_db_free_internal( &intern, tsp->ts_resp );

		/* If member is a leaf, handle leaf processing too. */
		if( (dp->d_flags & DIR_COMB) == 0 )  {
is_leaf:
			/* Object is a leaf */
			if( j == new_path->fp_len-1 )  {
				/* No more path was given, all is well */
				goto out;
			}
			/* Additional path was given, this is wrong */
			if( noisy )  {
				char	*sofar = db_path_to_string(total_path);
				char	*toofar = db_path_to_string(new_path);
				bu_log("db_follow_path() ERROR: path ended in leaf at '%s', additional path specified '%s'\n",
					sofar, toofar );
				bu_free(sofar, "path string");
				bu_free(toofar, "path string");
			}
			goto fail;
		}

		/* Advance to next path element */
		j++;
		comb_dp = dp;
	} while( j <= depth );

out:
	if(RT_G_DEBUG&DEBUG_TREEWALK)  {
		char	*sofar = db_path_to_string(total_path);
		bu_log("db_follow_path() returns total_path='%s'\n",
			sofar);
		bu_free(sofar, "path string");
	}
	return 0;		/* SUCCESS */
fail:
	return -1;		/* FAIL */
}

/*
 *			D B _ F O L L O W _ P A T H _ F O R _ S T A T E
 *
 *  Follow the slash-separated path given by "cp", and update
 *  *tsp and *total_path with full state information along the way.
 *
 *  A much more complete version of rt_plookup().
 *
 *  Returns -
 *	 0	success (plus *tsp is updated)
 *	-1	error (*tsp values are not useful)
 */
int
db_follow_path_for_state(struct db_tree_state *tsp, struct db_full_path *total_path, const char *orig_str, int noisy)
{
	struct db_full_path	new_path;
	int			ret;

	RT_CK_DBTS(tsp);

	if( *orig_str == '\0' )  return 0;		/* Null string */

	if( db_string_to_path( &new_path, tsp->ts_dbip, orig_str ) < 0 )
		return -1;

	if( new_path.fp_len <= 0 )  return 0;		/* Null string */

	ret = db_follow_path( tsp, total_path, &new_path, noisy, 0 );
	db_free_full_path( &new_path );

	return ret;
}


/*
 *			D B _ R E C U R S E _ S U B T R E E
 *
 *  Helper routine for db_recurse()
 */
HIDDEN void
db_recurse_subtree(union tree *tp, struct db_tree_state *msp, struct db_full_path *pathp, struct combined_tree_state **region_start_statepp, genptr_t client_data)
{
	struct db_tree_state	memb_state;
	union tree		*subtree;

	RT_CK_TREE(tp);
	RT_CK_DBTS(msp);
	RT_CK_RESOURCE(msp->ts_resp);
	db_dup_db_tree_state( &memb_state, msp );

	switch( tp->tr_op )  {

	case OP_DB_LEAF:
		if( db_apply_state_from_memb( &memb_state, pathp, tp ) < 0 )  {
			/* Lookup of this leaf failed, NOP it out. */
			if( tp->tr_l.tl_mat )  {
				bu_free( (char *)tp->tr_l.tl_mat, "tl_mat" );
				tp->tr_l.tl_mat = NULL;
			}
			bu_free( tp->tr_l.tl_name, "tl_name" );
			tp->tr_l.tl_name = NULL;
			tp->tr_op = OP_NOP;
			goto out;
		}

		/* Recursive call */
		if( (subtree = db_recurse( &memb_state, pathp, region_start_statepp, client_data )) != TREE_NULL )  {
			union tree	*tmp;

			/* graft subtree on in place of 'tp' leaf node */
			/* exchange what subtree and tp point at */
			RT_GET_TREE( tmp, msp->ts_resp );
			RT_CK_TREE(subtree);
			*tmp = *tp;	/* struct copy */
			*tp = *subtree;	/* struct copy */
			RT_FREE_TREE( subtree, msp->ts_resp );

			db_free_tree( tmp, msp->ts_resp );
			RT_CK_TREE(tp);
		} else {
			/* Processing of this leaf failed, NOP it out. */
			if( tp->tr_l.tl_mat )  {
				bu_free( (char *)tp->tr_l.tl_mat, "tl_mat" );
				tp->tr_l.tl_mat = NULL;
			}
			bu_free( tp->tr_l.tl_name, "tl_name" );
			tp->tr_l.tl_name = NULL;
			tp->tr_op = OP_NOP;
		}
		DB_FULL_PATH_POP(pathp);
		break;

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		db_recurse_subtree( tp->tr_b.tb_left, &memb_state, pathp, region_start_statepp, client_data );
		if( tp->tr_op == OP_SUBTRACT )
			memb_state.ts_sofar |= TS_SOFAR_MINUS;
		else if( tp->tr_op == OP_INTERSECT )
			memb_state.ts_sofar |= TS_SOFAR_INTER;
		db_recurse_subtree( tp->tr_b.tb_right, &memb_state, pathp, region_start_statepp, client_data );
		break;

	default:
		bu_log("db_recurse_subtree: bad op %d\n", tp->tr_op);
		rt_bomb("db_recurse_subtree\n");
	}
out:
	db_free_db_tree_state( &memb_state );
	RT_CK_TREE(tp);
	return;
}

/*
 *			D B _ R E C U R S E
 *
 *  Recurse down the tree, finding all the leaves
 *  (or finding just all the regions).
 *
 *  ts_region_start_func() is called to permit regions to be skipped.
 *  It is not intended to be used for collecting state.
 */
union tree *
db_recurse(struct db_tree_state *tsp, struct db_full_path *pathp, struct combined_tree_state **region_start_statepp, genptr_t client_data)
{
	struct directory	*dp;
	struct rt_db_internal	intern;
	union tree		*curtree = TREE_NULL;

	RT_CK_DBTS(tsp);
	RT_CHECK_DBI( tsp->ts_dbip );
	RT_CK_RESOURCE(tsp->ts_resp);
	RT_CK_FULL_PATH(pathp);
	RT_INIT_DB_INTERNAL(&intern);

	if( pathp->fp_len <= 0 )  {
		bu_log("db_recurse() null path?\n");
		return(TREE_NULL);
	}
	dp = DB_FULL_PATH_CUR_DIR(pathp);

	if(RT_G_DEBUG&DEBUG_TREEWALK)  {
		char	*sofar = db_path_to_string(pathp);
		bu_log("db_recurse() pathp='%s', tsp=x%x, *statepp=x%x, tsp->ts_sofar=%d\n",
			sofar, tsp,
			*region_start_statepp, tsp->ts_sofar );
		bu_free(sofar, "path string");
		bn_mat_ck("db_recurse() tsp->ts_mat at start", tsp->ts_mat);
	}

	/*
	 * Load the entire object into contiguous memory.
	 * Note that this code depends on the d_flags being set properly.
	 */
	if( dp->d_addr == RT_DIR_PHONY_ADDR )  return TREE_NULL;

	if( dp->d_flags & DIR_COMB )  {
		struct rt_comb_internal	*comb;
		struct db_tree_state	nts;
		int			is_region;

	    	RT_INIT_DB_INTERNAL(&intern);
		if( rt_db_get_internal( &intern, dp, tsp->ts_dbip, NULL, tsp->ts_resp ) < 0 )  {
			bu_log("db_recurse() rt_db_get_internal(%s) FAIL\n", dp->d_namep);
			curtree = TREE_NULL;		/* FAIL */
			goto out;
		}

		/*  Handle inheritance of material property. */
		db_dup_db_tree_state( &nts, tsp );

		comb = (struct rt_comb_internal *)intern.idb_ptr;
		RT_CK_COMB(comb);
		if( (is_region = db_apply_state_from_comb( &nts, pathp, comb )) < 0 )  {
			db_free_db_tree_state( &nts );
			curtree = TREE_NULL;		/* FAIL */
			goto out;
		}

		if( is_region > 0 )  {
			struct combined_tree_state	*ctsp;

			/* get attribute/value structure */
			bu_avs_merge( &nts.ts_attrs, &intern.idb_avs );

			/*
			 *  This is the start of a new region.
			 *  If handler rejects this region, skip on.
			 *  This might be used for ignoring air regions.
			 */
			if( tsp->ts_region_start_func && 
			    tsp->ts_region_start_func( &nts, pathp, comb, client_data ) < 0 )  {
				if(RT_G_DEBUG&DEBUG_TREEWALK)  {
					char	*sofar = db_path_to_string(pathp);
					bu_log("db_recurse() ts_region_start_func deletes %s\n",
						sofar);
					bu_free(sofar, "path string");
				}
				db_free_db_tree_state( &nts );
				curtree = TREE_NULL;		/* FAIL */
				goto out;
			}

			if( tsp->ts_stop_at_regions )  {
				goto region_end;
			}

			/* Take note of full state here at region start */
			if( *region_start_statepp != (struct combined_tree_state *)0 ) {
				bu_log("db_recurse() ERROR at start of a region, *region_start_statepp = x%x\n",
					*region_start_statepp );
				db_free_db_tree_state( &nts );
				curtree = TREE_NULL;		/* FAIL */
				goto out;
			}
			ctsp =  db_new_combined_tree_state( &nts, pathp );
			*region_start_statepp = ctsp;
			if(RT_G_DEBUG&DEBUG_TREEWALK)  {
				bu_log("setting *region_start_statepp to x%x\n", ctsp );
				db_pr_combined_tree_state(ctsp);
			}
		}

		if( comb->tree )  {
			/* Steal tree from combination, so it won't be freed */
			curtree = comb->tree;
			comb->tree = TREE_NULL;
			if(curtree) RT_CK_TREE(curtree);

			/* Release most of internal form before recursing */
			rt_db_free_internal( &intern, tsp->ts_resp );
			comb = NULL;

			db_recurse_subtree( curtree, &nts, pathp, region_start_statepp, client_data );
			if(curtree) RT_CK_TREE(curtree);
		} else {
			/* No subtrees in this combination, invent a NOP */
			RT_GET_TREE( curtree, tsp->ts_resp );
			curtree->magic = RT_TREE_MAGIC;
			curtree->tr_op = OP_NOP;
			if(curtree) RT_CK_TREE(curtree);
		}

region_end:
		if( is_region > 0 )  {
			/*
			 *  This is the end of processing for a region.
			 */
			if( tsp->ts_region_end_func )  {
				curtree = tsp->ts_region_end_func(
					&nts, pathp, curtree, client_data );
				if(curtree) RT_CK_TREE(curtree);
			}
		}
		db_free_db_tree_state( &nts );
		if(curtree) RT_CK_TREE(curtree);
	} else if( dp->d_flags & DIR_SOLID )  {

		if( bn_mat_ck( dp->d_namep, tsp->ts_mat ) < 0 )  {
			bu_log("db_recurse(%s):  matrix does not preserve axis perpendicularity.\n",
				dp->d_namep );
			bn_mat_print("bad matrix", tsp->ts_mat);
			curtree = TREE_NULL;		/* FAIL */
			goto out;
		}

		if(RT_G_DEBUG&DEBUG_TREEWALK)
			bu_log("db_recurse() rt_db_get_internal(%s) solid\n", dp->d_namep);

	    	RT_INIT_DB_INTERNAL(&intern);
		if( rt_db_get_internal( &intern, dp, tsp->ts_dbip, tsp->ts_mat, tsp->ts_resp ) < 0 )  {
			bu_log("db_recurse() rt_db_get_internal(%s) FAIL\n", dp->d_namep);
			curtree = TREE_NULL;		/* FAIL */
			goto out;
		}

		if( (tsp->ts_sofar & TS_SOFAR_REGION) == 0 &&
		    tsp->ts_stop_at_regions == 0 )  {
			struct combined_tree_state	*ctsp;
			char	*sofar = db_path_to_string(pathp);
			/*
			 *  Solid is not contained in a region.
		    	 *  "Invent" region info.
		    	 *  Take note of full state here at "region start".
			 */
			if( *region_start_statepp != (struct combined_tree_state *)0 ) {
				bu_log("db_recurse(%s) ERROR at start of a region (bare solid), *region_start_statepp = x%x\n",
					sofar, *region_start_statepp );
				curtree = TREE_NULL;		/* FAIL */
				goto out;
			}
			if( RT_G_DEBUG & DEBUG_REGIONS )  {
			    	bu_log("NOTICE: db_recurse(): solid '%s' not contained in a region, creating a region for it of the same name.\n",
			    		sofar );
			}

		    	ctsp = db_new_combined_tree_state( tsp, pathp );
		    	ctsp->cts_s.ts_sofar |= TS_SOFAR_REGION;
			*region_start_statepp = ctsp;
			if(RT_G_DEBUG&DEBUG_TREEWALK)  {
				bu_log("db_recurse(%s): setting *region_start_statepp to x%x (bare solid)\n",
					sofar, ctsp );
				db_pr_combined_tree_state(ctsp);
			}
		    	bu_free( sofar, "path string" );
		}

		/* Hand the solid off for leaf processing */
		if( !tsp->ts_leaf_func )  {
			curtree = TREE_NULL;		/* FAIL */
			goto out;
		}
		curtree = tsp->ts_leaf_func( tsp, pathp, &intern, client_data );
		if(curtree) RT_CK_TREE(curtree);
	} else {
		bu_log("%s is not a drawable database object\n",
			dp->d_namep );
		curtree = TREE_NULL;
		return(curtree);
	}
out:
	rt_db_free_internal( &intern, tsp->ts_resp );
	if(RT_G_DEBUG&DEBUG_TREEWALK)  {
		char	*sofar = db_path_to_string(pathp);
		bu_log("db_recurse() return curtree=x%x, pathp='%s', *statepp=x%x\n",
			curtree, sofar,
			*region_start_statepp );
		bu_free(sofar, "path string");
	}
	if(curtree) RT_CK_TREE(curtree);
	return(curtree);
}

/*
 *			D B _ D U P _ S U B T R E E
 */
union tree *
db_dup_subtree( const union tree *tp, struct resource *resp )
{
	union tree	*new;

	RT_CK_TREE(tp);
	RT_CK_RESOURCE(resp);

	RT_GET_TREE( new, resp );
	*new = *tp;		/* struct copy */

	switch( tp->tr_op )  {
	case OP_NOP:
	case OP_SOLID:
		/* If this is a simple leaf, done */
		return(new);

	case OP_DB_LEAF:
		if( tp->tr_l.tl_mat )
			new->tr_l.tl_mat = bn_mat_dup( tp->tr_l.tl_mat );
		new->tr_l.tl_name = bu_strdup( tp->tr_l.tl_name );
		return new;

	case OP_REGION:
		/* If this is a REGION leaf, dup combined_tree_state & path */
		new->tr_c.tc_ctsp = db_dup_combined_tree_state(
			tp->tr_c.tc_ctsp );
		return(new);

	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
		new->tr_b.tb_left = db_dup_subtree( tp->tr_b.tb_left, resp );
		return(new);

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		/* This node is known to be a binary op */
		new->tr_b.tb_left = db_dup_subtree( tp->tr_b.tb_left, resp );
		new->tr_b.tb_right = db_dup_subtree( tp->tr_b.tb_right, resp );
		return(new);

	default:
		bu_log("db_dup_subtree: bad op %d\n", tp->tr_op);
		rt_bomb("db_dup_subtree\n");
	}
	return( TREE_NULL );
}

/*
 *			D B _ C K _ T R E E
 */
void
db_ck_tree( const union tree *tp )
{

	RT_CK_TREE(tp);

	switch( tp->tr_op )  {
	case OP_NOP:
		break;
	case OP_DB_LEAF:
		BU_ASSERT_PTR( tp->tr_l.tl_name, !=, NULL );
		break;
	case OP_SOLID:
		if( tp->tr_a.tu_stp )
			RT_CK_SOLTAB( tp->tr_a.tu_stp );
		break;
	case OP_REGION:
		RT_CK_CTS( tp->tr_c.tc_ctsp );
		break;

	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
		db_ck_tree( tp->tr_b.tb_left );
		break;

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		/* This node is known to be a binary op */
		db_ck_tree( tp->tr_b.tb_left );
		db_ck_tree( tp->tr_b.tb_right );
		break;

	default:
		bu_log("db_ck_tree: bad op %d\n", tp->tr_op);
		rt_bomb("db_ck_tree\n");
	}
}

/*
 *			D B _ F R E E _ T R E E
 *
 *  Release all storage associated with node 'tp', including
 *  children nodes.
 */
void
db_free_tree( register union tree *tp, struct resource *resp )
{
	RT_CK_TREE(tp);
	RT_CK_RESOURCE(resp);

	/*
	 *  Before recursion, smash the magic number, so that if
	 *  another thread tries to free this same tree, they will fail.
	 */
	tp->magic = -3;		/* special bad flag */

	switch( tp->tr_op )  {
	case OP_NOP:
		break;

	case OP_SOLID:
		if( tp->tr_a.tu_stp )  {
			register struct soltab	*stp = tp->tr_a.tu_stp;
			RT_CK_SOLTAB(stp);
			tp->tr_a.tu_stp = RT_SOLTAB_NULL;
			rt_free_soltab(stp);
		}
		break;
	case OP_REGION:
		/* REGION leaf, free combined_tree_state & path */
		db_free_combined_tree_state( tp->tr_c.tc_ctsp );
		tp->tr_c.tc_ctsp = (struct combined_tree_state *)0;
		break;

	case OP_NMG_TESS:
		{
			struct nmgregion *r = tp->tr_d.td_r;
			if( tp->tr_d.td_name )  {
				bu_free( (char *)tp->tr_d.td_name, "region name" );
				tp->tr_d.td_name = (const char *)NULL;
			}
			if( r == (struct nmgregion *)NULL )  {
				break;
			}
			/* Disposing of the nmg model structue is
			 * left to someone else.
			 * It would be rude to zap all the other regions here.
			 */
#if 0
			if( r->l.magic == (-1L) )  {
				bu_log("db_free_tree: OP_NMG_TESS, r = -1, skipping\n");
			} else if( r->l.magic != NMG_REGION_MAGIC )  {
				/* It may have been freed, and the memory re-used */
				bu_log("db_free_tree: OP_NMG_TESS, bad magic x%x (s/b x%x), skipping\n",
					r->l.magic, NMG_REGION_MAGIC );
			} else {
#endif
			if( r->l.magic == NMG_REGION_MAGIC )
			{
				NMG_CK_REGION(r);
				nmg_kr(r);
			}
			tp->tr_d.td_r = (struct nmgregion *)NULL;
		}
		break;

	case OP_DB_LEAF:
		if( tp->tr_l.tl_mat )  {
			bu_free( (char *)tp->tr_l.tl_mat, "tl_mat" );
			tp->tr_l.tl_mat = NULL;
		}
		bu_free( tp->tr_l.tl_name, "tl_name" );
		tp->tr_l.tl_name = NULL;
		break;

	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
		if( tp->tr_b.tb_left->magic == RT_TREE_MAGIC )
			db_free_tree( tp->tr_b.tb_left, resp );
		tp->tr_b.tb_left = TREE_NULL;
		break;

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		{
			register union tree *fp;

			/* This node is known to be a binary op */
			fp = tp->tr_b.tb_left;
			tp->tr_b.tb_left = TREE_NULL;
			RT_CK_TREE(fp);
			db_free_tree( fp, resp );

			fp = tp->tr_b.tb_right;
			tp->tr_b.tb_right = TREE_NULL;
			RT_CK_TREE(fp);
			db_free_tree( fp, resp );
		}
		break;

	default:
		bu_log("db_free_tree: bad op %d\n", tp->tr_op);
		rt_bomb("db_free_tree\n");
	}
	tp->tr_op = 0;		/* sanity */
	RT_FREE_TREE( tp, resp );
}

/*			D B _ L E F T _ H V Y _ N O D E
 *
 *	Re-balance this node to make it left heavy.
 *	Unions operators will be moved to left side.
 *	when finished "tp" MUST still point to top node
 *	od this subtree.
 */
void
db_left_hvy_node( union tree *tp )
{
	union tree *lhs, *rhs;

	RT_CK_TREE(tp);

	if( tp->tr_op != OP_UNION )
		return;

	while( tp->tr_b.tb_right->tr_op == OP_UNION )
	{
		lhs = tp->tr_b.tb_left;
		rhs = tp->tr_b.tb_right;

		tp->tr_b.tb_left = rhs;
		tp->tr_b.tb_right = rhs->tr_b.tb_right;
		rhs->tr_b.tb_right = rhs->tr_b.tb_left;
		rhs->tr_b.tb_left = lhs;
	}
}

/*
 *			D B _ N O N _ U N I O N _ P U S H
 *
 *  If there are non-union operations in the tree,
 *  above the region nodes, then rewrite the tree so that
 *  the entire tree top is nothing but union operations,
 *  and any non-union operations are clustered down near the region nodes.
 */
void
db_non_union_push( register union tree *tp, struct resource *resp )
{
	union tree *A, *B, *C;
	union tree *tmp;
	int repush_child=0;

	RT_CK_TREE(tp);
	RT_CK_RESOURCE(resp);

	switch( tp->tr_op )  {
	case OP_REGION:
	case OP_SOLID:
	case OP_DB_LEAF:
		/* If this is a leaf, done */
		return;

	case OP_NOP:
		/* This tree has nothing in it, done */
		return;

	default:
		db_non_union_push( tp->tr_b.tb_left, resp );
		db_non_union_push( tp->tr_b.tb_right, resp );
		break;
	}
	if( (tp->tr_op == OP_INTERSECT || tp->tr_op == OP_SUBTRACT) &&
	    tp->tr_b.tb_left->tr_op == OP_UNION ) {
		union tree	*lhs = tp->tr_b.tb_left;
	    	union tree	*rhs;

		A = lhs->tr_b.tb_left;
		B = lhs->tr_b.tb_right;

		if( A->tr_op == OP_NOP && B->tr_op == OP_NOP ) {
		  /* nothing here, eliminate entire subtree */
		  db_free_tree( tp->tr_b.tb_left, resp );
		  db_free_tree( tp->tr_b.tb_right, resp );
		  tp->tr_op = OP_NOP;
		  tp->tr_b.tb_left = NULL;
		  tp->tr_b.tb_right = NULL;

		} else if( A->tr_op == OP_NOP ) {
		  db_tree_del_lhs( lhs, resp );

		  /* recurse */
		  db_non_union_push( tp, resp );
		} else if( B->tr_op == OP_NOP ) {
		  db_tree_del_rhs( lhs, resp );

		  /* recurse */
		  db_non_union_push( tp, resp );
		} else {

		  repush_child = 1;

		  /*  Rewrite intersect and subtraction nodes, such that
		   *  (A u B) - C  becomes (A - C) u (B - C)
		   *
		   * tp->    -
		   *	   /   \
		   * lhs->  u     C
		   *	 / \
		   *	A   B
		   */
		  RT_GET_TREE( rhs, resp );

		  /* duplicate top node into rhs */
		  *rhs = *tp;		/* struct copy */
		  tp->tr_b.tb_right = rhs;
		  /* rhs->tr_b.tb_right remains unchanged:
		   *
		   * tp->    -
		   *	   /   \
		   * lhs->  u     -   <-rhs
		   *	 / \   / \
		   *	A   B ?   C
		   */

		  rhs->tr_b.tb_left = lhs->tr_b.tb_right;
		  /*
		   * tp->    -
		   *	   /   \
		   * lhs->  u     -   <-rhs
		   *	 / \   / \
		   *	A   B B   C
		   */

		  /* exchange left and top operators */
		  tp->tr_op = lhs->tr_op;
		  lhs->tr_op = rhs->tr_op;
		  /*
		   * tp->    u
		   *	   /   \
		   * lhs->  -     -   <-rhs
		   *	 / \   / \
		   *	A   B B   C
		   */

		  /* Make a duplicate of rhs->tr_b.tb_right */
		  lhs->tr_b.tb_right = db_dup_subtree( rhs->tr_b.tb_right, resp );
		  /*
		   * tp->    u
		   *	   /   \
		   * lhs->  -     -   <-rhs
		   *	 / \   / \
		   *	A  C' B   C
		   */
		}

	}

	else if( tp->tr_op == OP_INTERSECT && 
		tp->tr_b.tb_right->tr_op == OP_UNION )
	{
		/* C + (A u B) -> (C + A) u (C + B) */
		union tree	*rhs = tp->tr_b.tb_right;

		C = tp->tr_b.tb_left;
		A = tp->tr_b.tb_right->tr_b.tb_left;
		B = tp->tr_b.tb_right->tr_b.tb_right;

		if( A->tr_op == OP_NOP && B->tr_op == OP_NOP ) {
		  /* nothing here, eliminate entire subtree */
		  tp->tr_op = OP_NOP;
		  db_free_tree( tp->tr_b.tb_left, resp );
		  db_free_tree( tp->tr_b.tb_right, resp );
		  tp->tr_b.tb_left = NULL;
		  tp->tr_b.tb_right = NULL;
		} else if( A->tr_op == OP_NOP ) {
		  db_tree_del_lhs( rhs, resp );

		  /* recurse */
		  db_non_union_push( tp, resp );
		} else if( B->tr_op == OP_NOP ) {
		  db_tree_del_rhs( rhs, resp );

		  /* recurse */
		  db_non_union_push( tp, resp );
		} else {
		  repush_child = 1;

		  tp->tr_op = OP_UNION;
		  RT_GET_TREE( tmp, resp );
		  tmp->tr_regionp = tp->tr_regionp;
		  tmp->magic = RT_TREE_MAGIC;
		  tmp->tr_op = OP_INTERSECT;
		  tmp->tr_b.tb_left = C;
		  tmp->tr_b.tb_right = A;
		  tp->tr_b.tb_left = tmp;
		  tp->tr_b.tb_right->tr_op = OP_INTERSECT;
		  tp->tr_b.tb_right->tr_b.tb_left = db_dup_subtree( C, resp );
		}
	}
	else if( tp->tr_op == OP_SUBTRACT &&
		tp->tr_b.tb_right->tr_op == OP_UNION )
	{
		/* C - (A u B) -> C - A - B */
		union tree	*rhs = tp->tr_b.tb_right;


		C = tp->tr_b.tb_left;
		A = tp->tr_b.tb_right->tr_b.tb_left;
		B = tp->tr_b.tb_right->tr_b.tb_right;

		if( C->tr_op == OP_NOP ) {
		  /* nothing here, eliminate entire subtree */
		  tp->tr_op = OP_NOP;
		  db_free_tree( tp->tr_b.tb_left, resp );
		  db_free_tree( tp->tr_b.tb_right, resp );
		  tp->tr_b.tb_left = NULL;
		  tp->tr_b.tb_right = NULL;
		} else if( A->tr_op == OP_NOP && B->tr_op == OP_NOP ) {
		  db_tree_del_rhs( tp, resp );

		  /* recurse */
		  db_non_union_push( tp, resp );
		} else if( A->tr_op == OP_NOP ) {
		  db_tree_del_lhs( rhs, resp );

		  /* recurse */
		  db_non_union_push( tp, resp );
		} else if( B->tr_op == OP_NOP ) {
		  db_tree_del_rhs( rhs, resp );

		  /* recurse */
		  db_non_union_push( tp, resp );
		} else {
		  repush_child = 1;

		  tp->tr_b.tb_left = tp->tr_b.tb_right;
		  tp->tr_b.tb_left->tr_op = OP_SUBTRACT;
		  tp->tr_b.tb_right = B;
		  tmp = tp->tr_b.tb_left;
		  tmp->tr_b.tb_left = C;
		  tmp->tr_b.tb_right = A;
		}
	}

	/* if this operation has moved a UNION operator towards the leaves
	 * then the children must be processed again
	 */
	if( repush_child )
	{
		db_non_union_push( tp->tr_b.tb_left, resp );
		db_non_union_push( tp->tr_b.tb_right, resp );
	}

	/* rebalance this node (moves UNIONs to left side) */
	db_left_hvy_node( tp );
}

/*
 *			D B _ C O U N T _ T R E E _ N O D E S
 *
 *  Return a count of the number of "union tree" nodes below "tp",
 *  including tp.
 */
int
db_count_tree_nodes( const union tree *tp, int count )
{
	RT_CK_TREE(tp);
	switch( tp->tr_op )  {
	case OP_NOP:
	case OP_SOLID:
	case OP_REGION:
	case OP_DB_LEAF:
		/* A leaf node */
		return(count+1);

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
		/* This node is known to be a binary op */
		count = db_count_tree_nodes( tp->tr_b.tb_left, count );
		count = db_count_tree_nodes( tp->tr_b.tb_right, count );
		return(count);

	case OP_XOR:
	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
		/* This node is known to be a unary op */
		count = db_count_tree_nodes( tp->tr_b.tb_left, count );
		return(count);

	default:
		bu_log("db_count_tree_nodes: bad op %d\n", tp->tr_op);
		rt_bomb("db_count_tree_nodes\n");
	}
	return( 0 );
}

/*
 *			D B _ I S _ T R E E _ A L L _ U N I O N S
 *
 *  Returns -
 *	1	if this tree contains nothing but union operations.
 *	0	if at least one subtraction or intersection op exists.
 */
int
db_is_tree_all_unions( const union tree *tp )
{
	RT_CK_TREE(tp);
	switch( tp->tr_op )  {
	case OP_NOP:
	case OP_SOLID:
	case OP_REGION:
	case OP_DB_LEAF:
		/* A leaf node */
		return 1;		/* yep */

	case OP_UNION:
		if( db_is_tree_all_unions( tp->tr_b.tb_left ) == 0 )
			return 0;
		return db_is_tree_all_unions( tp->tr_b.tb_right );

	case OP_INTERSECT:
	case OP_SUBTRACT:
		return 0;		/* nope */

	case OP_XOR:
	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
		return 0;		/* nope */

	default:
		bu_log("db_is_tree_all_unions: bad op %d\n", tp->tr_op);
		rt_bomb("db_is_tree_all_unions\n");
	}
	return 0;
}

/*
 *			D B _ C O U N T _ S U B T R E E _ R E G I O N S
 */
int
db_count_subtree_regions( const union tree *tp )
{
	int	cnt;

	RT_CK_TREE(tp);
	switch( tp->tr_op )  {
	case OP_SOLID:
	case OP_REGION:
	case OP_DB_LEAF:
		return(1);

	case OP_UNION:
		/* This node is known to be a binary op */
		cnt = db_count_subtree_regions( tp->tr_b.tb_left );
		cnt += db_count_subtree_regions( tp->tr_b.tb_right );
		return(cnt);

	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
	case OP_NOP:
		/* This is as far down as we go -- this is a region top */
		return(1);

	default:
		bu_log("db_count_subtree_regions: bad op %d\n", tp->tr_op);
		rt_bomb("db_count_subtree_regions\n");
	}
	return( 0 );
}

/*
 *			D B _ T A L L Y _ S U B T R E E _ R E G I O N S
 */
int
db_tally_subtree_regions(
	union tree	*tp,
	union tree	**reg_trees,
	int		cur,
	int		lim,
	struct resource *resp)
{
	union tree	*new;

	RT_CK_TREE(tp);
	RT_CK_RESOURCE(resp);
	if( cur >= lim )  rt_bomb("db_tally_subtree_regions: array overflow\n");

	switch( tp->tr_op )  {
	case OP_NOP:
		return(cur);

	case OP_SOLID:
	case OP_REGION:
	case OP_DB_LEAF:
		RT_GET_TREE( new, resp );
		*new = *tp;		/* struct copy */
		tp->tr_op = OP_NOP;	/* Zap original */
		reg_trees[cur++] = new;
		return(cur);

	case OP_UNION:
		/* This node is known to be a binary op */
		cur = db_tally_subtree_regions( tp->tr_b.tb_left, reg_trees, cur, lim, resp );
		cur = db_tally_subtree_regions( tp->tr_b.tb_right, reg_trees, cur, lim, resp );
		return(cur);

	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
		/* This is as far down as we go -- this is a region top */
		RT_GET_TREE( new, resp );
		*new = *tp;		/* struct copy */
		tp->tr_op = OP_NOP;	/* Zap original */
		reg_trees[cur++] = new;
		return(cur);

	default:
		bu_log("db_tally_subtree_regions: bad op %d\n", tp->tr_op);
		rt_bomb("db_tally_subtree_regions\n");
	}
	return( cur );
}

/* ============================== */

HIDDEN union tree *db_gettree_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{

	RT_CK_DBTS(tsp);
	RT_CK_DBI(tsp->ts_dbip);
	RT_CK_FULL_PATH(pathp);
	RT_CK_RESOURCE(tsp->ts_resp);

	RT_GET_TREE( curtree, tsp->ts_resp );
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_REGION;
	curtree->tr_c.tc_ctsp = db_new_combined_tree_state( tsp, pathp );

	return(curtree);
}

HIDDEN union tree *db_gettree_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
{
	register union tree	*curtree;

	RT_CK_DBTS(tsp);
	RT_CK_DBI(tsp->ts_dbip);
	RT_CK_FULL_PATH(pathp);
	RT_CK_DB_INTERNAL(ip);
	RT_CK_RESOURCE(tsp->ts_resp);

	RT_GET_TREE( curtree, tsp->ts_resp );
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_REGION;
	curtree->tr_c.tc_ctsp = db_new_combined_tree_state( tsp, pathp );

	return(curtree);
}

struct db_walk_parallel_state {
	long		magic;
	union tree	**reg_trees;
	int		reg_count;
	int		reg_current;		/* semaphored when parallel */
	union tree *	(*reg_end_func)();
	union tree *	(*reg_leaf_func)();
	struct rt_i	*rtip;
	genptr_t	client_data;
};
#define DB_WALK_PARALLEL_STATE_MAGIC	0x64777073	/* dwps */
#define DB_CK_WPS(_p)	BU_CKMAG(_p, DB_WALK_PARALLEL_STATE_MAGIC, "db_walk_parallel_state")

/*
 *			D B _ W A L K _ S U B T R E E
 */
HIDDEN void
db_walk_subtree(
	register union tree	*tp,
	struct combined_tree_state	**region_start_statepp,
	union tree	 *(*leaf_func) BU_ARGS((struct db_tree_state *, struct db_full_path *, struct rt_db_internal *, void *)),
	genptr_t	client_data,
	struct resource	*resp )
{
	struct combined_tree_state	*ctsp;
	union tree	*curtree;

	RT_CK_TREE(tp);
	RT_CK_RESOURCE(resp);

	switch( tp->tr_op )  {
	case OP_NOP:
		return;

	/*  case OP_SOLID:*/
	case OP_REGION:
		/* Flesh out remainder of subtree */
		ctsp = tp->tr_c.tc_ctsp;
	 	RT_CK_CTS(ctsp);
		if( ctsp->cts_p.fp_len <= 0 )  {
			bu_log("db_walk_subtree() REGION with null path?\n");
			db_free_combined_tree_state( ctsp );
			/* Result is an empty tree */
			tp->tr_op = OP_NOP;
			tp->tr_a.tu_stp = 0;
			return;
		}
		RT_CK_DBI(ctsp->cts_s.ts_dbip);
		ctsp->cts_s.ts_stop_at_regions = 0;
		/* All regions will be accepted, in this 2nd pass */
		ctsp->cts_s.ts_region_start_func = 0;
		/* ts_region_end_func() will be called in db_walk_dispatcher() */
		ctsp->cts_s.ts_region_end_func = 0;
		/* Use user's leaf function */
		ctsp->cts_s.ts_leaf_func = leaf_func;
		ctsp->cts_s.ts_resp = resp;

		/* If region already seen, force flag */
		if( *region_start_statepp )
			ctsp->cts_s.ts_sofar |= TS_SOFAR_REGION;
		else
			ctsp->cts_s.ts_sofar &= ~TS_SOFAR_REGION;

		curtree = db_recurse( &ctsp->cts_s, &ctsp->cts_p, region_start_statepp, client_data );
		if( curtree == TREE_NULL )  {
			char	*str;
			str = db_path_to_string( &(ctsp->cts_p) );
			bu_log("db_walk_subtree() FAIL on '%s'\n", str);
			bu_free( str, "path string" );

			db_free_combined_tree_state( ctsp );
			/* Result is an empty tree */
			tp->tr_op = OP_NOP;
			tp->tr_a.tu_stp = 0;
			return;
		}
		/* replace *tp with new subtree */
		*tp = *curtree;		/* struct copy */
		db_free_combined_tree_state( ctsp );
		RT_FREE_TREE( curtree, resp );
		return;

	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
		db_walk_subtree( tp->tr_b.tb_left, region_start_statepp,
			leaf_func, client_data, resp );
		return;

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		/* This node is known to be a binary op */
		db_walk_subtree( tp->tr_b.tb_left, region_start_statepp,
			leaf_func, client_data, resp );
		db_walk_subtree( tp->tr_b.tb_right, region_start_statepp,
			leaf_func, client_data, resp );
		return;

	case OP_DB_LEAF:
		rt_pr_tree( tp, 1 );
		bu_bomb("db_walk_subtree() unexpected DB_LEAF\n");

	default:
		bu_log("db_walk_subtree: bad op %d\n", tp->tr_op);
		bu_bomb("db_walk_subtree() bad op\n");
	}
}

/*
 *			D B _ W A L K _ D I S P A T C H E R
 *
 *  This routine handles the PARALLEL portion of db_walk_tree().
 *  There will be at least one, and possibly more, instances of
 *  this routine running simultaneously.
 *
 *  Uses the self-dispatcher pattern:
 *  Pick off the next region's tree, and walk it.
 */
HIDDEN void
db_walk_dispatcher(int cpu, genptr_t arg)
{
	struct combined_tree_state	*region_start_statep;
	int		mine;
	union tree	*curtree;
	struct db_walk_parallel_state	*wps = (struct db_walk_parallel_state *)arg;
	struct resource	*resp;

	DB_CK_WPS(wps);

	if( wps->rtip == NULL && cpu == 0 )  {
		resp = &rt_uniresource;
	} else {
		RT_CK_RTI(wps->rtip);

		resp = (struct resource *)BU_PTBL_GET( &wps->rtip->rti_resources, cpu );
		if( resp == NULL && cpu == 0 )  resp = &rt_uniresource;
	}
	RT_CK_RESOURCE(resp);

	while(1)  {
		bu_semaphore_acquire( RT_SEM_WORKER );
		mine = wps->reg_current++;
		bu_semaphore_release( RT_SEM_WORKER );

		if( mine >= wps->reg_count )
			break;

		if( RT_G_DEBUG&DEBUG_TREEWALK )
			bu_log("\n\n***** db_walk_dispatcher() on item %d\n\n", mine );

		if( (curtree = wps->reg_trees[mine]) == TREE_NULL )
			continue;
		RT_CK_TREE(curtree);

		/* Walk the full subtree now */
		region_start_statep = (struct combined_tree_state *)0;
		db_walk_subtree( curtree, &region_start_statep,
			wps->reg_leaf_func, wps->client_data, resp );

		/*  curtree->tr_op may be OP_NOP here.
		 *  It is up to db_reg_end_func() to deal with this,
		 *  either by discarding it, or making a null region.
		 */
		RT_CK_TREE(curtree);
		if( !region_start_statep )  {
			bu_log("ERROR: db_walk_dispatcher() region %d started with no state\n", mine);
			if( RT_G_DEBUG&DEBUG_TREEWALK )			
				rt_pr_tree( curtree, 0 );
			continue;
		}
		RT_CK_CTS( region_start_statep );

		/* This is a new region */
		if( RT_G_DEBUG&DEBUG_TREEWALK )
			db_pr_combined_tree_state(region_start_statep);

		/*
		 *  reg_end_func() returns a pointer to any unused
		 *  subtree for freeing.
		 */
		if( wps->reg_end_func )  {
			wps->reg_trees[mine] = (*(wps->reg_end_func))(
				&(region_start_statep->cts_s),
				&(region_start_statep->cts_p),
				curtree, wps->client_data );
		}

		db_free_combined_tree_state( region_start_statep );
	}
}

/*
 *			D B _ W A L K _ T R E E
 *
 *  This is the top interface to the "tree walker."
 *
 * Parameters:
 *	rtip		rt_i structure to database (open with rt_dirbuild())
 *	argc		# of tree-tops named
 *	argv		names of tree-tops to process
 *	init_state	Input parameter: initial state of the tree.
 *			For example:  rt_initial_tree_state,
 *			and mged_initial_tree_state.
 *
 * These parameters are pointers to callback routines.
 * If NULL, they won't be called.
 *
 *	reg_start_func	Called at beginning of each region, before visiting
 *			any nodes within the region.
 *			Return 0 if region should be skipped without recursing,
 *			 otherwise non-zero.  DO NOT USE FOR OTHER PURPOSES!
 *			For example, can be used to quickly skip air regions.
 *
 *	reg_end_func	Called after all nodes within a region have been
 *			recursively processed by leaf_func.
 *			If it wants to retain 'curtree' then it may steal
 *			that pointer and return TREE_NULL.
 *			If it wants us to clean up some or all of that
 *			tree, then it returns a non-null (union tree *)
 *			pointer, and that tree is safely freed
 *			in a non-parallel section before we return.
 *  
 *	leaf_func	Function to process a leaf node.
 *			It is actually invoked from db_recurse() from db_walk_subtree().
 *			Returns (union tree *) representing the leaf, or
 *			TREE_NULL if leaf does not exist or has an error.
 *
 *
 *  This routine will employ multiple CPUs if asked,
 *  but is not multiply-parallel-recursive.
 *  Call this routine with ncpu > 1 from serial code only.
 *  When called from within an existing thread, ncpu must be 1.
 *
 *  If ncpu > 1, the caller is responsible for making sure that
 *	rt_g.rtg_parallel is non-zero, and that the
 *	bu_semaphore_init() functions has been performed, first.
 *
 *  Plucks per-cpu resources out of rtip->rti_resources[].
 *  They need to have been initialized first.
 *
 *  Returns -
 *	-1	Failure to prepare even a single sub-tree
 *	 0	OK
 */
int
db_walk_tree(struct db_i *dbip, int argc, const char **argv, int ncpu, const struct db_tree_state *init_state, int (*reg_start_func) (struct db_tree_state *, struct db_full_path *, const struct rt_comb_internal *, genptr_t), union tree *(*reg_end_func) (struct db_tree_state *, struct db_full_path *, union tree *, genptr_t), union tree *(*leaf_func) (struct db_tree_state *, struct db_full_path *, struct rt_db_internal *, genptr_t), genptr_t client_data)
           	      
   		     
          	       
   		     
                                       
   		                           
			                       /*tsp*/ 
			                      /*pathp*/ 
			                                /* combp */ 
			                    
		   
            	                         
			                       /*tsp*/ 
			                      /*pathp*/ 
			             /*curtree*/ 
			                    
		   
            	                      
			                       /*tsp*/ 
			                      /*pathp*/ 
			                        /*ip*/ 
			                    
		   
        	            
{
	union tree		*whole_tree = TREE_NULL;
	int			new_reg_count;
	int			i;
	int                     something_not_found = 0;
	union tree		**reg_trees;	/* (*reg_trees)[] */
	struct db_walk_parallel_state	wps;
	struct resource		*resp;

	RT_CK_DBTS(init_state);
	RT_CHECK_DBI(dbip);

	if( init_state->ts_rtip == NULL && ncpu == 1 )  {
		resp = &rt_uniresource;
	} else {
		RT_CK_RTI(init_state->ts_rtip);
		resp = (struct resource *)BU_PTBL_GET(&init_state->ts_rtip->rti_resources, 0);
		if( resp == NULL && ncpu == 1 )  {
			resp = &rt_uniresource;
		}
	}
	RT_CK_RESOURCE(resp);

	/* Walk each of the given path strings */
	for( i=0; i < argc; i++ )  {
		register union tree	*curtree;
		struct db_tree_state	ts;
		struct db_full_path	path;
		struct combined_tree_state	*region_start_statep;

		ts = *init_state;	/* struct copy */
		ts.ts_dbip = dbip;
		ts.ts_resp = resp;
		db_full_path_init( &path );

		/* First, establish context from given path */
		if( db_follow_path_for_state( &ts, &path, argv[i], 
					      LOOKUP_NOISY ) < 0 ) 
		  {
		    bu_log ("db_walk_tree: warning - %s not found.\n",
			    argv[i]);
		    ++ something_not_found;
		    continue;	/* ERROR */
		  }
		if( path.fp_len <= 0 )  {
			continue;	/* e.g., null combination */
		}

		/*
		 *  Second, walk tree from root to start of all regions.
		 *  Build a boolean tree of all regions.
		 *  Use user function to accept/reject each region here.
		 *  Use internal functions to process regions & leaves.
		 */
		ts.ts_stop_at_regions = 1;
		ts.ts_region_start_func = reg_start_func;
		ts.ts_region_end_func = db_gettree_region_end;
		ts.ts_leaf_func = db_gettree_leaf;

		region_start_statep = (struct combined_tree_state *)0;
		curtree = db_recurse( &ts, &path, &region_start_statep, client_data );
		if( region_start_statep )
			db_free_combined_tree_state( region_start_statep );
		db_free_full_path( &path );
		if( curtree == TREE_NULL )
			continue;	/* ERROR */

		RT_CK_TREE(curtree);
		if( RT_G_DEBUG&DEBUG_TREEWALK )  {
			bu_log("tree after db_recurse():\n");
			rt_pr_tree( curtree, 0 );
		}

		if( whole_tree == TREE_NULL )  {
			whole_tree = curtree;
		} else {
			union tree	*new;

			RT_GET_TREE( new, ts.ts_resp );
			new->magic = RT_TREE_MAGIC;
			new->tr_op = OP_UNION;
			new->tr_b.tb_left = whole_tree;
			new->tr_b.tb_right = curtree;
			whole_tree = new;
		}
	}

	if( whole_tree == TREE_NULL )
		return(-1);	/* ERROR, nothing worked */


	/*
	 *  Third, push all non-union booleans down.
	 */
	db_non_union_push( whole_tree, resp );
	if( RT_G_DEBUG&DEBUG_TREEWALK )  {
		char *str;

		bu_log("tree after db_non_union_push():\n");
		rt_pr_tree( whole_tree, 0 );
		bu_log( "Same tree in another form:\n" );
		str = (char *)rt_pr_tree_str( whole_tree );
		bu_log( "%s\n", str );
		bu_free( str, "rturn from rt_pr_tree_str" );
	}

	/*
	 *  Build array of sub-tree pointers, one per region,
	 *  for parallel processing below.
	 */
	new_reg_count = db_count_subtree_regions( whole_tree );
	reg_trees = (union tree **)bu_calloc( sizeof(union tree *),
		(new_reg_count+1), "*reg_trees[]" );
	new_reg_count = db_tally_subtree_regions( whole_tree, reg_trees, 0,
		new_reg_count, resp );

	/*  Release storage for tree from whole_tree to leaves.
	 *  db_tally_subtree_regions() duplicated and OP_NOP'ed the original
	 *  top of any sub-trees that it wanted to keep, so whole_tree
	 *  is just the left-over part now.
	 */
	db_free_tree( whole_tree, resp );

	/* As a debugging aid, print out the waiting region names */
	if( RT_G_DEBUG&DEBUG_TREEWALK )  {
		bu_log("%d waiting regions:\n", new_reg_count);
		for( i=0; i < new_reg_count; i++ )  {
			union tree	*treep;
			struct combined_tree_state	*ctsp;
			char	*str;

			if( (treep = reg_trees[i]) == TREE_NULL )  {
				bu_log("%d: NULL\n", i);
				continue;
			}
			RT_CK_TREE(treep);
			if( treep->tr_op != OP_REGION )  {
				bu_log("%d: op=%d\n", i, treep->tr_op);
				rt_pr_tree( treep, 2 );
				continue;
			}
			ctsp = treep->tr_c.tc_ctsp;
		 	RT_CK_CTS(ctsp);
			str = db_path_to_string( &(ctsp->cts_p) );
			bu_log("%d '%s'\n", i, str);
			bu_free( str, "path string" );
		}
		bu_log("end of waiting regions\n");
	}

	/*
	 *  Fourth, in parallel, for each region, walk the tree to the leaves.
	 */
	if( bu_is_parallel() && ncpu != 1 )  {
		bu_log("db_walk_tree() recursively invoked while inside parallel section with additional parallelism of ncpu=%d requested.  Running only in one thread.\n",
			ncpu );
		ncpu = 1;
	}

	/* Make state available to the threads */
	wps.magic = DB_WALK_PARALLEL_STATE_MAGIC;
	wps.reg_trees = reg_trees;
	wps.reg_count = new_reg_count;
	wps.reg_current = 0;			/* Semaphored */
	wps.reg_end_func = reg_end_func;
	wps.reg_leaf_func = leaf_func;
	wps.client_data = client_data;
	wps.rtip = init_state->ts_rtip;

	if( ncpu <= 1 )  {
		db_walk_dispatcher( 0, (genptr_t)&wps );
	} else {
		bu_parallel( db_walk_dispatcher, ncpu, (genptr_t)&wps );
	}

	/* Clean up any remaining sub-trees still in reg_trees[] */
	for( i=0; i < new_reg_count; i++ )  {
		if( reg_trees[i] != TREE_NULL )  {
			db_free_tree( reg_trees[i], resp );
		}
	}
	bu_free( (char *)reg_trees, "*reg_trees[]" );

	if (something_not_found)
	  {
	    bu_log ("db_walk_tree: %d %s not found.\n", 
		    something_not_found, 
		    (something_not_found > 1) ? "items" : "item" ) ;
	    return -2;
	  }
	else
	  {
	    return 0;	/* OK */
	  }
}

/*
 *			D B _ P A T H _ T O _ M A T
 *
 *  Returns -
 *	1	OK, path matrix written into 'mat'.
 *	0	FAIL
 *
 *  Called in librt/db_tree.c, mged/dodraw.c, and mged/animedit.c
 */
int
db_path_to_mat(
	struct db_i		*dbip,
	struct db_full_path	*pathp,
	mat_t			mat,		/* result */
	int			depth,		/* number of arcs */
	struct resource		*resp)
{
	struct db_tree_state	ts;
	struct db_full_path	null_path;
	int			ret;

	RT_CHECK_DBI(dbip);
	RT_CK_FULL_PATH(pathp);
	if( !mat ) rt_bomb("db_path_to_mat() NULL matrix pointer\n");

	db_full_path_init( &null_path );
	db_init_db_tree_state( &ts, dbip, resp );

	ret = db_follow_path( &ts, &null_path, pathp, LOOKUP_NOISY, depth );
	db_free_full_path( &null_path );
	MAT_COPY( mat, ts.ts_mat );	/* implicit return */
	db_free_db_tree_state( &ts );

	if( ret < 0 )  {
		return 0;	/* FAIL */
	}
	return 1;		/* OK */
}

/*
 *			D B _ A P P L Y _ A N I M S
 *
 *  'arc' may be a null pointer, signifying an identity matrix.
 *  'materp' may be a null pointer, signifying that
 *  the region has already been finalized above this point in the tree.
 */
void
db_apply_anims(struct db_full_path *pathp, struct directory *dp, mat_t stack, mat_t arc, struct mater_info *materp)
{
	register struct animate *anp;
	register int i,j;

	/* Check here for animation to apply */

	if ((dp->d_animate != ANIM_NULL) && (RT_G_DEBUG & DEBUG_ANIM)) {
		char	*sofar = db_path_to_string(pathp);
		bu_log("Animate %s with...\n", sofar);
		bu_free(sofar, "path string");
	}

	/*
	 * For each of the animations attached to the
	 * mentioned object,  see if the current accumulated
	 * path matches the path  specified in the animation.
	 * Comparison is performed right-to-left (from
	 * leafward to rootward).
	 */
	for( anp = dp->d_animate; anp != ANIM_NULL; anp = anp->an_forw ) {
		register int anim_flag;

		j = pathp->fp_len-1;
		
		RT_CK_ANIMATE(anp);
		i = anp->an_path.fp_len-1;
		anim_flag = 1;

		if (RT_G_DEBUG & DEBUG_ANIM) {
			char	*str;

			str = db_path_to_string( &(anp->an_path) );
			bu_log( "\t%s\t", str );
			bu_free( str, "path string" );
			bu_log("an_path.fp_len-1:%d  pathp->fp_len-1:%d\n",
				i, j);
		}

		for( ; i>=0 && j>=0; i--, j-- )  {
			if( anp->an_path.fp_names[i] != pathp->fp_names[j] ) {
				if (RT_G_DEBUG & DEBUG_ANIM) {
					bu_log("%s != %s\n",
					     anp->an_path.fp_names[i]->d_namep,
					     pathp->fp_names[j]->d_namep);
				}
				anim_flag = 0;
				break;
			}
		}

				/* anim, stack, arc, mater */
		if (anim_flag)
			db_do_anim( anp, stack, arc, materp);
	}
	return;
}

/*
 *			D B _ R E G I O N _ M A T
 *
 *  Given the name of a region, return the matrix which maps model coordinates
 *  into "region" coordinates.
 *
 *  Returns:
 *	0	OK
 *	<0	Failure
 */
int
db_region_mat(
	mat_t		m,		/* result */
	struct db_i	*dbip,
	const char	*name,
	struct resource *resp)
{
	struct db_full_path		full_path;
	mat_t	region_to_model;

	/* get transformation between world and "region" coordinates */
	if (db_string_to_path( &full_path, dbip, name) ) {
		/* bad thing */
		bu_log("db_region_mat: db_string_to_path(%s) error\n", name);
		return -1;
	}
	if(! db_path_to_mat(dbip, &full_path, region_to_model, 0, resp)) {
		/* bad thing */
		bu_log("db_region_mat: db_path_to_mat(%s) error", name);
		return -2;
	}

	/* get matrix to map points from model (world) space
	 * to "region" space
	 */
	bn_mat_inv(m, region_to_model);
	db_free_full_path( &full_path );
	return 0;
}



/*		D B _ S H A D E R _ M A T
 * XXX given that this routine depends on rtip, it should be called
 * XXX rt_shader_mat().
 *
 *  Given a region, return a matrix which maps model coordinates into
 *  region "shader space".  This is a space where points in the model
 *  within the bounding box of the region are mapped into "region"
 *  space (the coordinate system in which the region is defined).
 *  The area occupied by the region's bounding box (in region coordinates)
 *  are then mapped into the unit cube.  This unit cube defines
 *  "shader space".
 *
 *  Returns:
 *	0	OK
 *	<0	Failure
 */
int
db_shader_mat(
	mat_t			model_to_shader,	/* result */
	const struct rt_i	*rtip,
	const struct region	*rp,
	point_t			p_min,	/* input/output: shader/region min point */
	point_t			p_max,	/* input/output: shader/region max point */
	struct resource		*resp)
{
	mat_t	model_to_region;
	mat_t	m_xlate;
	mat_t	m_scale;
	mat_t	m_tmp;
	vect_t	v_tmp;
	struct	rt_i *my_rtip;
	const char	*reg_name;

	RT_CK_RTI(rtip);
	RT_CK_RESOURCE(resp);

	reg_name = rt_basename(rp->reg_name);
#ifdef DEBUG_SHADER_MAT
	bu_log("db_shader_mat(%s)\n", rp->reg_name);
#endif
	/* get model-to-region space mapping */
	if( db_region_mat(model_to_region, rtip->rti_dbip, rp->reg_name, resp) < 0 )
		return -1;

#ifdef DEBUG_SHADER_MAT
	bn_mat_print("model_to_region", model_to_region);
#endif
	if (VEQUAL(p_min, p_max)) {
		/* User/shader did not specify bounding box,
		 * obtain bounding box for un-transformed region
		 */

		/* XXX This should really be handled by a special set of
		 * tree walker routines which just build up the RPP of the
		 * region.  For now we just re-use rt_rpp_region() with
		 * a scratch rtip.
		 */
		my_rtip = rt_new_rti(rtip->rti_dbip);
		my_rtip->useair = rtip->useair;
		
		/* XXX Should have our own semaphore here */
		bu_semaphore_acquire( RT_SEM_MODEL );
		if (rt_gettree(my_rtip, reg_name)) bu_bomb(rp->reg_name);
		bu_semaphore_release( RT_SEM_MODEL );
		rt_rpp_region(my_rtip, reg_name, p_min, p_max);
		rt_clean(my_rtip);
	}
#ifdef DEBUG_SHADER_MAT
	bu_log("db_shader_mat(%s) min(%g %g %g) max(%g %g %g)\n", reg_name,
			V3ARGS(p_min), V3ARGS(p_max));
#endif
	/*
	 * Translate bounding box to origin
	 */
	MAT_IDN(m_xlate);
	VSCALE(v_tmp, p_min, -1);
	MAT_DELTAS_VEC(m_xlate, v_tmp);
	bn_mat_mul(m_tmp, m_xlate, model_to_region);


	/* 
	 * Scale the bounding box to unit cube
	 */
	VSUB2(v_tmp, p_max, p_min);
	VINVDIR(v_tmp, v_tmp);
	MAT_IDN(m_scale);
	MAT_SCALE_VEC(m_scale, v_tmp);
	bn_mat_mul(model_to_shader, m_scale, m_tmp);
	return 0;
}
@


11.115
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db_tree.c,v 11.114 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.114
log
@merge of ansi-6-0-branch into HEAD
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d25 5
a29 1
#include "conf.h"
@


11.113
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.112 2003/12/11 02:20:00 jra Exp $ (BRL)";
d129 1
a129 3
db_new_combined_tree_state( tsp, pathp )
register const struct db_tree_state	*tsp;
register const struct db_full_path	*pathp;
d149 1
a149 2
db_dup_combined_tree_state( old )
const struct combined_tree_state	*old;
d166 1
a166 2
db_free_combined_tree_state( ctsp )
register struct combined_tree_state	*ctsp;
d179 1
a179 2
db_pr_tree_state( tsp )
register const struct db_tree_state	*tsp;
d210 1
a210 2
db_pr_combined_tree_state( ctsp )
register const struct combined_tree_state	*ctsp;
d234 1
a234 4
db_apply_state_from_comb( tsp, pathp, comb )
struct db_tree_state		*tsp;
const struct db_full_path	*pathp;
register const struct rt_comb_internal	*comb;
d351 1
a351 4
db_apply_state_from_memb( tsp, pathp, tp )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
const union tree	*tp;
d950 1
a950 5
db_follow_path_for_state( tsp, total_path, orig_str, noisy )
struct db_tree_state	*tsp;
struct db_full_path	*total_path;
const char		*orig_str;
int			noisy;
d977 1
a977 6
db_recurse_subtree( tp, msp, pathp, region_start_statepp, client_data )
union tree		*tp;
struct db_tree_state	*msp;
struct db_full_path	*pathp;
struct combined_tree_state	**region_start_statepp;
genptr_t	client_data;
d1061 1
a1061 5
db_recurse( tsp, pathp, region_start_statepp, client_data )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct combined_tree_state	**region_start_statepp;
genptr_t	client_data;
d1909 1
a1909 5
HIDDEN union tree *db_gettree_region_end( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d1925 1
a1925 5
HIDDEN union tree *db_gettree_leaf( tsp, pathp, ip, client_data )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d2064 1
a2064 3
db_walk_dispatcher( cpu, arg )
int		cpu;
genptr_t	arg;
d2190 25
a2214 25
db_walk_tree( dbip, argc, argv, ncpu, init_state, reg_start_func, reg_end_func, leaf_func, client_data )
struct db_i	*dbip;
int		argc;
const char	**argv;
int		ncpu;
const struct db_tree_state *init_state;
int		(*reg_start_func) BU_ARGS((
			struct db_tree_state * /*tsp*/,
			struct db_full_path * /*pathp*/,
			const struct rt_comb_internal * /* combp */,
			genptr_t client_data
		));
union tree *	(*reg_end_func) BU_ARGS((
			struct db_tree_state * /*tsp*/,
			struct db_full_path * /*pathp*/,
			union tree * /*curtree*/,
			genptr_t client_data
		));
union tree *	(*leaf_func) BU_ARGS((
			struct db_tree_state * /*tsp*/,
			struct db_full_path * /*pathp*/,
			struct rt_db_internal * /*ip*/,
			genptr_t client_data
		));
genptr_t	client_data;
d2458 1
a2458 6
db_apply_anims(pathp, dp, stack, arc, materp)
struct db_full_path *pathp;
struct directory *dp;
mat_t	stack;
mat_t	arc;
struct mater_info *materp;
@


11.112
log
@Eliminated some unused variables
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1988 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.111 2003/12/09 14:56:01 jra Exp $ (BRL)";
@


11.111
log
@Simplified attribute handling in db_recurse()
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.110 2002/08/20 17:07:57 jra Exp $ (BRL)";
a1090 1
	int			i;
a1143 1
			const char *value;
@


11.110
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.108 2002/05/29 15:08:46 jra Exp $ (BRL)";
d1148 1
a1148 11
			for( i=0 ; i<nts.ts_attrs.count ; i++ ) {
				if( nts.ts_attrs.avp[i].value ) {
					if( AVS_IS_FREEABLE( &nts.ts_attrs, nts.ts_attrs.avp[i].value ) )
						bu_free( (char *)nts.ts_attrs.avp[i].value, "tree state AVS value" );
				}
				value = bu_avs_get( &intern.idb_avs, nts.ts_attrs.avp[i].name );
				if( value )
					nts.ts_attrs.avp[i].value = bu_strdup( value );
				else
					nts.ts_attrs.avp[i].value = (char *)NULL;
			}
@


11.110.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/db_tree.c,v 11.113 2004/02/02 17:39:15 morrison Exp $ (BRL)";
d1091 1
d1145 1
d1148 11
a1158 1
			bu_avs_merge( &nts.ts_attrs, &intern.idb_avs );
@


11.110.10.1
log
@sync from head
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.112 2003/12/11 02:20:00 jra Exp $ (BRL)";
d1091 1
d1145 1
d1148 11
a1158 1
			bu_avs_merge( &nts.ts_attrs, &intern.idb_avs );
@


11.110.10.2
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.113 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


11.110.10.3
log
@merge from head
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.110.10.2 2004/02/12 18:37:39 erikg Exp $ (BRL)";
@


11.110.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.110 2002/08/20 17:07:57 jra Exp $ (BRL)";
d129 3
a131 1
db_new_combined_tree_state(register const struct db_tree_state *tsp, register const struct db_full_path *pathp)
d151 2
a152 1
db_dup_combined_tree_state(const struct combined_tree_state *old)
d169 2
a170 1
db_free_combined_tree_state(register struct combined_tree_state *ctsp)
d183 2
a184 1
db_pr_tree_state(register const struct db_tree_state *tsp)
d215 2
a216 1
db_pr_combined_tree_state(register const struct combined_tree_state *ctsp)
d240 4
a243 1
db_apply_state_from_comb(struct db_tree_state *tsp, const struct db_full_path *pathp, register const struct rt_comb_internal *comb)
d360 4
a363 1
db_apply_state_from_memb(struct db_tree_state *tsp, struct db_full_path *pathp, const union tree *tp)
d962 5
a966 1
db_follow_path_for_state(struct db_tree_state *tsp, struct db_full_path *total_path, const char *orig_str, int noisy)
d993 6
a998 1
db_recurse_subtree(union tree *tp, struct db_tree_state *msp, struct db_full_path *pathp, struct combined_tree_state **region_start_statepp, genptr_t client_data)
d1082 5
a1086 1
db_recurse(struct db_tree_state *tsp, struct db_full_path *pathp, struct combined_tree_state **region_start_statepp, genptr_t client_data)
d1946 5
a1950 1
HIDDEN union tree *db_gettree_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d1966 5
a1970 1
HIDDEN union tree *db_gettree_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d2109 3
a2111 1
db_walk_dispatcher(int cpu, genptr_t arg)
d2237 25
a2261 25
db_walk_tree(struct db_i *dbip, int argc, const char **argv, int ncpu, const struct db_tree_state *init_state, int (*reg_start_func) (struct db_tree_state *, struct db_full_path *, const struct rt_comb_internal *, genptr_t), union tree *(*reg_end_func) (struct db_tree_state *, struct db_full_path *, union tree *, genptr_t), union tree *(*leaf_func) (struct db_tree_state *, struct db_full_path *, struct rt_db_internal *, genptr_t), genptr_t client_data)
           	      
   		     
          	       
   		     
                                       
   		                           
			                       /*tsp*/ 
			                      /*pathp*/ 
			                                /* combp */ 
			                    
		   
            	                         
			                       /*tsp*/ 
			                      /*pathp*/ 
			             /*curtree*/ 
			                    
		   
            	                      
			                       /*tsp*/ 
			                      /*pathp*/ 
			                        /*ip*/ 
			                    
		   
        	            
d2505 6
a2510 1
db_apply_anims(struct db_full_path *pathp, struct directory *dp, fastf_t *stack, fastf_t *arc, struct mater_info *materp)
@


11.110.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d1066 1
d1120 1
d1123 11
a1133 1
			bu_avs_merge( &nts.ts_attrs, &intern.idb_avs );
@


11.109
log
@Converted from K&R to ANSI C - RFH
@
text
@d129 3
a131 1
db_new_combined_tree_state(register const struct db_tree_state *tsp, register const struct db_full_path *pathp)
d151 2
a152 1
db_dup_combined_tree_state(const struct combined_tree_state *old)
d169 2
a170 1
db_free_combined_tree_state(register struct combined_tree_state *ctsp)
d183 2
a184 1
db_pr_tree_state(register const struct db_tree_state *tsp)
d215 2
a216 1
db_pr_combined_tree_state(register const struct combined_tree_state *ctsp)
d240 4
a243 1
db_apply_state_from_comb(struct db_tree_state *tsp, const struct db_full_path *pathp, register const struct rt_comb_internal *comb)
d360 4
a363 1
db_apply_state_from_memb(struct db_tree_state *tsp, struct db_full_path *pathp, const union tree *tp)
d962 5
a966 1
db_follow_path_for_state(struct db_tree_state *tsp, struct db_full_path *total_path, const char *orig_str, int noisy)
d993 6
a998 1
db_recurse_subtree(union tree *tp, struct db_tree_state *msp, struct db_full_path *pathp, struct combined_tree_state **region_start_statepp, genptr_t client_data)
d1082 5
a1086 1
db_recurse(struct db_tree_state *tsp, struct db_full_path *pathp, struct combined_tree_state **region_start_statepp, genptr_t client_data)
d1946 5
a1950 1
HIDDEN union tree *db_gettree_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d1966 5
a1970 1
HIDDEN union tree *db_gettree_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d2109 3
a2111 1
db_walk_dispatcher(int cpu, genptr_t arg)
d2237 25
a2261 25
db_walk_tree(struct db_i *dbip, int argc, const char **argv, int ncpu, const struct db_tree_state *init_state, int (*reg_start_func) (struct db_tree_state *, struct db_full_path *, const struct rt_comb_internal *, genptr_t), union tree *(*reg_end_func) (struct db_tree_state *, struct db_full_path *, union tree *, genptr_t), union tree *(*leaf_func) (struct db_tree_state *, struct db_full_path *, struct rt_db_internal *, genptr_t), genptr_t client_data)
           	      
   		     
          	       
   		     
                                       
   		                           
			                       /*tsp*/ 
			                      /*pathp*/ 
			                                /* combp */ 
			                    
		   
            	                         
			                       /*tsp*/ 
			                      /*pathp*/ 
			             /*curtree*/ 
			                    
		   
            	                      
			                       /*tsp*/ 
			                      /*pathp*/ 
			                        /*ip*/ 
			                    
		   
        	            
d2505 6
a2510 1
db_apply_anims(struct db_full_path *pathp, struct directory *dp, fastf_t *stack, fastf_t *arc, struct mater_info *materp)
@


11.108
log
@db_non_union_push() now correctly handles empty nodes
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.107 2002/02/22 02:42:43 morrison Exp $ (BRL)";
d129 1
a129 3
db_new_combined_tree_state( tsp, pathp )
register const struct db_tree_state	*tsp;
register const struct db_full_path	*pathp;
d149 1
a149 2
db_dup_combined_tree_state( old )
const struct combined_tree_state	*old;
d166 1
a166 2
db_free_combined_tree_state( ctsp )
register struct combined_tree_state	*ctsp;
d179 1
a179 2
db_pr_tree_state( tsp )
register const struct db_tree_state	*tsp;
d210 1
a210 2
db_pr_combined_tree_state( ctsp )
register const struct combined_tree_state	*ctsp;
d234 1
a234 4
db_apply_state_from_comb( tsp, pathp, comb )
struct db_tree_state		*tsp;
const struct db_full_path	*pathp;
register const struct rt_comb_internal	*comb;
d351 1
a351 4
db_apply_state_from_memb( tsp, pathp, tp )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
const union tree	*tp;
d950 1
a950 5
db_follow_path_for_state( tsp, total_path, orig_str, noisy )
struct db_tree_state	*tsp;
struct db_full_path	*total_path;
const char		*orig_str;
int			noisy;
d977 1
a977 6
db_recurse_subtree( tp, msp, pathp, region_start_statepp, client_data )
union tree		*tp;
struct db_tree_state	*msp;
struct db_full_path	*pathp;
struct combined_tree_state	**region_start_statepp;
genptr_t	client_data;
d1061 1
a1061 5
db_recurse( tsp, pathp, region_start_statepp, client_data )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct combined_tree_state	**region_start_statepp;
genptr_t	client_data;
d1921 1
a1921 5
HIDDEN union tree *db_gettree_region_end( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d1937 1
a1937 5
HIDDEN union tree *db_gettree_leaf( tsp, pathp, ip, client_data )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d2076 1
a2076 3
db_walk_dispatcher( cpu, arg )
int		cpu;
genptr_t	arg;
d2202 25
a2226 25
db_walk_tree( dbip, argc, argv, ncpu, init_state, reg_start_func, reg_end_func, leaf_func, client_data )
struct db_i	*dbip;
int		argc;
const char	**argv;
int		ncpu;
const struct db_tree_state *init_state;
int		(*reg_start_func) BU_ARGS((
			struct db_tree_state * /*tsp*/,
			struct db_full_path * /*pathp*/,
			const struct rt_comb_internal * /* combp */,
			genptr_t client_data
		));
union tree *	(*reg_end_func) BU_ARGS((
			struct db_tree_state * /*tsp*/,
			struct db_full_path * /*pathp*/,
			union tree * /*curtree*/,
			genptr_t client_data
		));
union tree *	(*leaf_func) BU_ARGS((
			struct db_tree_state * /*tsp*/,
			struct db_full_path * /*pathp*/,
			struct rt_db_internal * /*ip*/,
			genptr_t client_data
		));
genptr_t	client_data;
d2470 1
a2470 6
db_apply_anims(pathp, dp, stack, arc, materp)
struct db_full_path *pathp;
struct directory *dp;
mat_t	stack;
mat_t	arc;
struct mater_info *materp;
@


11.107
log
@Updated db_recurse complaint message when trying to draw a non-drawable database object to say simply that.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.106 2001/11/09 16:30:15 rbowers Exp $ (BRL)";
d1587 2
a1588 1
    		repush_child = 1;
d1590 15
a1604 10
		/*  Rewrite intersect and subtraction nodes, such that
		 *  (A u B) - C  becomes (A - C) u (B - C)
		 *
		 * tp->	     -
		 *	   /   \
		 * lhs->  u     C
		 *	 / \
		 *	A   B
		 */
	    	RT_GET_TREE( rhs, resp );
d1606 3
a1608 11
		/* duplicate top node into rhs */
		*rhs = *tp;		/* struct copy */
		tp->tr_b.tb_right = rhs;
		/* rhs->tr_b.tb_right remains unchanged:
		 *
		 * tp->	     -
		 *	   /   \
		 * lhs->  u     -   <-rhs
		 *	 / \   / \
		 *	A   B ?   C
		 */
d1610 1
a1610 8
		rhs->tr_b.tb_left = lhs->tr_b.tb_right;
		/*
		 * tp->	     -
		 *	   /   \
		 * lhs->  u     -   <-rhs
		 *	 / \   / \
		 *	A   B B   C
		 */
d1612 53
a1664 20
		/* exchange left and top operators */
		tp->tr_op = lhs->tr_op;
		lhs->tr_op = rhs->tr_op;
		/*
		 * tp->	     u
		 *	   /   \
		 * lhs->  -     -   <-rhs
		 *	 / \   / \
		 *	A   B B   C
		 */

		/* Make a duplicate of rhs->tr_b.tb_right */
		lhs->tr_b.tb_right = db_dup_subtree( rhs->tr_b.tb_right, resp );
		/*
		 * tp->	     u
		 *	   /   \
		 * lhs->  -     -   <-rhs
		 *	 / \   / \
		 *	A  C' B   C
		 */
d1672 1
a1672 2

		repush_child = 1;
d1677 32
a1708 10
		tp->tr_op = OP_UNION;
		RT_GET_TREE( tmp, resp );
		tmp->tr_regionp = tp->tr_regionp;
		tmp->magic = RT_TREE_MAGIC;
		tmp->tr_op = OP_INTERSECT;
		tmp->tr_b.tb_left = C;
		tmp->tr_b.tb_right = A;
		tp->tr_b.tb_left = tmp;
		tp->tr_b.tb_right->tr_op = OP_INTERSECT;
		tp->tr_b.tb_right->tr_b.tb_left = db_dup_subtree( C, resp );
d1714 1
a1715 1
		repush_child = 1;
d1720 33
a1752 6
		tp->tr_b.tb_left = tp->tr_b.tb_right;
		tp->tr_b.tb_left->tr_op = OP_SUBTRACT;
		tp->tr_b.tb_right = B;
		tmp = tp->tr_b.tb_left;
		tmp->tr_b.tb_left = C;
		tmp->tr_b.tb_right = A;
@


11.106
log
@-* extended the behavior of db_walk_tree. Previously it would return -1
   iff absolutely no geometry could be loaded. It now returns -2 if
   some geometry could be loaded, but there were unresolved names.
-* rt_gettrees_muves supports the -2, it is passed to the caller.
-* rt_gettree and rt_gettrees filter the -2 and return 0 for
   backward compatibility.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.105 2001/05/17 20:05:23 morrison Exp $ (BRL)";
d1290 1
a1290 1
		bu_log("db_recurse:  %s is neither a combination nor a solid and is not drawable\n",
@


11.105
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.104 2001/05/08 20:13:53 jra Exp $ (BRL)";
d2194 1
d2226 8
a2233 3
		if( db_follow_path_for_state( &ts, &path, argv[i], LOOKUP_NOISY ) < 0 )
			continue;	/* ERROR */

d2373 11
a2383 1
	return(0);	/* OK */
@


11.104
log
@Added support for bu_avs structires in db_tree_state structures
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.103 2001/04/20 22:29:42 morrison Exp $ (BRL)";
d819 1
a819 1
	if(rt_g.debug&DEBUG_TREEWALK)  {
d890 1
a890 1
		if(rt_g.debug&DEBUG_TREEWALK)  {
d938 1
a938 1
	if(rt_g.debug&DEBUG_TREEWALK)  {
d1105 1
a1105 1
	if(rt_g.debug&DEBUG_TREEWALK)  {
d1167 1
a1167 1
				if(rt_g.debug&DEBUG_TREEWALK)  {
d1192 1
a1192 1
			if(rt_g.debug&DEBUG_TREEWALK)  {
d1241 1
a1241 1
		if(rt_g.debug&DEBUG_TREEWALK)
d1266 1
a1266 1
			if( rt_g.debug & DEBUG_REGIONS )  {
d1274 1
a1274 1
			if(rt_g.debug&DEBUG_TREEWALK)  {
d1297 1
a1297 1
	if(rt_g.debug&DEBUG_TREEWALK)  {
d2067 1
a2067 1
		if( rt_g.debug&DEBUG_TREEWALK )
d2086 1
a2086 1
			if( rt_g.debug&DEBUG_TREEWALK )			
d2093 1
a2093 1
		if( rt_g.debug&DEBUG_TREEWALK )
d2252 1
a2252 1
		if( rt_g.debug&DEBUG_TREEWALK )  {
d2279 1
a2279 1
	if( rt_g.debug&DEBUG_TREEWALK )  {
d2308 1
a2308 1
	if( rt_g.debug&DEBUG_TREEWALK )  {
d2429 1
a2429 1
	if ((dp->d_animate != ANIM_NULL) && (rt_g.debug & DEBUG_ANIM)) {
d2451 1
a2451 1
		if (rt_g.debug & DEBUG_ANIM) {
d2463 1
a2463 1
				if (rt_g.debug & DEBUG_ANIM) {
@


11.103
log
@CONST to const
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.102 2001/04/02 21:38:07 morrison Exp $ (BRL)";
d50 1
a50 1
 *  including a private copy of the ts_mater field(s).
d56 1
d72 9
d97 4
d121 1
d186 2
d204 3
d1091 1
d1145 15
@


11.102
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.101 2001/03/31 01:57:06 morrison Exp $ (BRL)";
d44 1
a44 1
BU_EXTERN(void db_ck_tree, (CONST union tree *tp));
d115 2
a116 2
register CONST struct db_tree_state	*tsp;
register CONST struct db_full_path	*pathp;
d137 1
a137 1
CONST struct combined_tree_state	*old;
d169 1
a169 1
register CONST struct db_tree_state	*tsp;
d196 1
a196 1
register CONST struct combined_tree_state	*ctsp;
d222 2
a223 2
CONST struct db_full_path	*pathp;
register CONST struct rt_comb_internal	*comb;
d343 1
a343 1
CONST union tree	*tp;
d783 1
a783 1
	CONST struct db_full_path	*new_path,
d945 1
a945 1
CONST char		*orig_str;
d1411 1
a1411 1
				tp->tr_d.td_name = (CONST char *)NULL;
d2132 1
a2132 1
CONST char	**argv;
d2134 1
a2134 1
CONST struct db_tree_state *init_state;
d2138 1
a2138 1
			CONST struct rt_comb_internal * /* combp */,
d2517 1
a2517 1
	CONST char	*reg_name;
@


11.101
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.100 2001/03/30 21:06:08 jra Exp $ (BRL)";
d362 5
a366 4
	bn_mat_copy( old_xlate, tsp->ts_mat );
	if( tp->tr_l.tl_mat )
		bn_mat_copy( xmat, tp->tr_l.tl_mat );
	else
d368 1
d697 1
a697 1
		bn_mat_copy( tp->tr_l.tl_mat, temp );
d838 1
a838 1
				bn_mat_copy( old_xlate, tsp->ts_mat );
d2364 1
a2364 1
	bn_mat_copy( mat, ts.ts_mat );	/* implicit return */
@


11.100
log
@"e" and "draw" now do not dump on _GLOBAL
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.99 2000/09/09 04:30:47 mike Exp $ (BRL)";
d107 1
a107 1
	bn_mat_idn( tsp->ts_mat );	/* XXX should use null pointer convention! */
d366 1
a366 1
		bn_mat_idn( xmat );
d837 1
a837 1
				bn_mat_idn( xmat );
d2558 1
a2558 1
	bn_mat_idn(m_xlate);
d2569 1
a2569 1
	bn_mat_idn(m_scale);
@


11.99
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.98 2000/09/08 08:08:48 mike Exp $ (BRL)";
d1252 1
a1252 1
		bu_log("db_recurse:  %s is neither COMB nor SOLID?\n",
d1255 1
@


11.98
log
@
MGED isn't going to have an RTIP to work with.
Cope with it.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.97 2000/09/08 05:54:41 mike Exp $ (BRL)";
d57 1
d81 1
d98 1
a98 1
db_init_db_tree_state( struct db_tree_state *tsp, struct db_i *dbip )
d101 1
d104 1
d106 1
d120 1
d171 2
d225 1
d349 1
d400 1
d791 1
d949 2
d982 1
d1070 1
d1842 1
d1863 1
d2159 1
d2341 6
a2346 5
db_path_to_mat( dbip, pathp, mat, depth)
struct db_i	*dbip;
struct db_full_path *pathp;
mat_t mat;
int depth;			/* number of arcs */
d2357 1
a2357 1
	db_init_db_tree_state( &ts, dbip );
d2452 5
a2456 1
db_region_mat( mat_t m, const struct db_i *dbip, const char *name )
d2467 1
a2467 1
	if(! db_path_to_mat((struct db_i *)dbip, &full_path, region_to_model, 0)) {
d2500 7
a2506 6
db_shader_mat(model_to_shader, rtip, rp, p_min, p_max)
mat_t model_to_shader;
CONST struct rt_i *rtip;
CONST struct region *rp;
point_t p_min;	/* shader/region min point */
point_t p_max;	/* shader/region max point */
d2516 3
d2524 1
a2524 1
	if( db_region_mat(model_to_region, rtip->rti_dbip, rp->reg_name) < 0 )
@


11.97
log
@
Modified tree routines to take resource pointer.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.96 2000/08/31 02:19:49 mike Exp $ (BRL)";
a1990 1
	RT_CK_RTI(wps->rtip);
d1992 8
a1999 2
	resp = (struct resource *)BU_PTBL_GET( &wps->rtip->rti_resources, cpu );
	if( resp == NULL && cpu == 0 )  resp = &rt_uniresource;
d2143 1
a2143 4
	RT_CK_RTI(init_state->ts_rtip);
	resp = (struct resource *)BU_PTBL_GET(&init_state->ts_rtip->rti_resources, 0);
	if( resp == NULL && ncpu == 1 )  {
		bu_log("db_walk_tree() defaulting resp to rt_uniresource\n");
d2145 6
@


11.96
log
@
Added safety checks.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.95 2000/08/31 02:10:39 mike Exp $ (BRL)";
d180 1
d342 1
d521 1
a521 1
db_tree_del_lhs( union tree *tp )
d543 1
a543 1
			db_free_tree( tp->tr_b.tb_left );
d553 1
a553 1
			bu_free( (genptr_t)subtree, "union tree (subtree)" );
d565 1
a565 1
db_tree_del_rhs( union tree *tp )
d587 1
a587 1
			db_free_tree( tp->tr_b.tb_right );
d597 1
a597 1
			bu_free( (genptr_t)subtree, "union tree (subtree)" );
d629 1
a629 1
db_tree_del_dbleaf(union tree **tp, const char *cp)
d637 1
d643 1
a643 1
		    	db_free_tree( *tp );
d652 2
a653 2
		db_tree_del_lhs( parent );
		(void)db_tree_del_dbleaf( tp, cp );	/* recurse for extras */
d656 2
a657 2
		db_tree_del_rhs( parent );
		(void)db_tree_del_dbleaf( tp, cp );	/* recurse for extras */
d783 1
d861 1
a861 1
		if( rt_db_get_internal( &intern, comb_dp, tsp->ts_dbip, NULL ) < 0 )
d876 1
a876 1
		rt_db_free_internal( &intern );
d968 1
d992 1
a992 1
			BU_GETUNION(tmp, tree);
d996 3
a998 3
			bu_free( (char *)subtree, "subtree" );
db_ck_tree(tmp);
			db_free_tree( tmp );
d1056 1
d1087 1
a1087 1
		if( rt_db_get_internal( &intern, dp, tsp->ts_dbip, NULL ) < 0 )  {
d1149 5
d1158 1
a1158 1
			BU_GETUNION( curtree, tree );
d1191 1
a1191 1
		if( rt_db_get_internal( &intern, dp, tsp->ts_dbip, tsp->ts_mat ) < 0 )  {
d1241 1
a1241 1
	rt_db_free_internal( &intern );
d1257 1
a1257 2
db_dup_subtree( tp )
CONST union tree	*tp;
d1262 3
a1264 1
	BU_GETUNION( new, tree );
d1288 1
a1288 1
		new->tr_b.tb_left = db_dup_subtree( tp->tr_b.tb_left );
d1296 2
a1297 2
		new->tr_b.tb_left = db_dup_subtree( tp->tr_b.tb_left );
		new->tr_b.tb_right = db_dup_subtree( tp->tr_b.tb_right );
d1358 1
a1358 2
db_free_tree( tp )
register union tree	*tp;
d1361 1
d1432 1
a1432 1
			db_free_tree( tp->tr_b.tb_left );
d1447 1
a1447 1
			db_free_tree( fp );
d1452 1
a1452 1
			db_free_tree( fp );
d1461 1
a1461 1
	bu_free( (char *)tp, "union tree" );
d1502 1
a1502 2
db_non_union_push( tp )
register union tree	*tp;
d1509 1
d1523 2
a1524 2
		db_non_union_push( tp->tr_b.tb_left );
		db_non_union_push( tp->tr_b.tb_right );
d1543 1
a1543 1
		BU_GETUNION( rhs, tree );
d1578 1
a1578 1
		lhs->tr_b.tb_right = db_dup_subtree( rhs->tr_b.tb_right );
d1600 1
a1600 1
		BU_GETUNION( tmp, tree );
d1608 1
a1608 1
		tp->tr_b.tb_right->tr_b.tb_left = db_dup_subtree( C );
d1633 2
a1634 2
		db_non_union_push( tp->tr_b.tb_left );
		db_non_union_push( tp->tr_b.tb_right );
d1727 1
a1727 2
db_count_subtree_regions( tp )
CONST union tree	*tp;
d1765 6
a1770 5
db_tally_subtree_regions( tp, reg_trees, cur, lim )
union tree	*tp;
union tree	**reg_trees;
int		cur;
int		lim;
d1775 1
d1785 1
a1785 1
		BU_GETUNION( new, tree );
d1793 2
a1794 2
		cur = db_tally_subtree_regions( tp->tr_b.tb_left, reg_trees, cur, lim );
		cur = db_tally_subtree_regions( tp->tr_b.tb_right, reg_trees, cur, lim );
d1804 1
a1804 1
		BU_GETUNION( new, tree );
d1828 1
d1830 1
a1830 1
	BU_GETUNION( curtree, tree );
d1849 1
d1851 1
a1851 1
	BU_GETUNION( curtree, tree );
d1866 1
d1876 6
a1881 5
db_walk_subtree( tp, region_start_statepp, leaf_func, client_data )
register union tree	*tp;
struct combined_tree_state	**region_start_statepp;
union tree		 *(*leaf_func) BU_ARGS((struct db_tree_state *, struct db_full_path *, struct rt_db_internal *, void *));
genptr_t	client_data;
d1887 2
d1914 1
d1938 1
a1938 1
		bu_free( (char *)curtree, "replaced tree node" );
d1944 2
a1945 1
		db_walk_subtree( tp->tr_b.tb_left, region_start_statepp, leaf_func, client_data );
d1953 4
a1956 2
		db_walk_subtree( tp->tr_b.tb_left, region_start_statepp, leaf_func, client_data );
		db_walk_subtree( tp->tr_b.tb_right, region_start_statepp, leaf_func, client_data );
d1965 1
a1965 1
		rt_bomb("db_walk_subtree() bad op\n");
d1972 1
a1972 1
 *  This routine handles parallel operation.
d1976 1
d1988 1
d1991 5
d2015 1
a2015 1
			wps->reg_leaf_func, wps->client_data );
d2092 5
a2096 2
 *	rt_g.rtg_parallel is non-zero, and that the various
 *	bu_semaphore_init(5)functions have been performed, first.
d2134 1
d2138 8
d2155 1
d2196 1
a2196 1
			BU_GETUNION( new, tree );
d2212 1
a2212 1
	db_non_union_push( whole_tree );
d2232 1
a2232 1
		new_reg_count );
d2239 1
a2239 1
	db_free_tree( whole_tree );
d2285 1
d2296 1
a2296 1
			db_free_tree( reg_trees[i] );
@


11.95
log
@
Enhanced db_dup_subtree() to also dup OP_DB_LEAF nodes.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.94 2000/07/12 00:13:47 mike Exp $ (BRL)";
d1306 1
d1308 1
@


11.94
log
@
Added externs for db_tree.c and db_path.c
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.93 2000/07/11 23:16:47 mike Exp $ (BRL)";
d1258 3
d1262 5
a1266 2
		/* If this is a leaf, done */
		return(new);
@


11.93
log
@
Added externs for new routines in librt/db_*.c
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.92 2000/07/10 23:01:28 mike Exp $ (BRL)";
d53 1
a53 3
db_dup_db_tree_state( otsp, itsp )
register struct db_tree_state		*otsp;
register CONST struct db_tree_state	*itsp;
d78 1
a78 2
db_free_db_tree_state( tsp )
register struct db_tree_state	*tsp;
d96 1
a96 3
db_init_db_tree_state( tsp, dbip )
register struct db_tree_state	*tsp;
struct db_i			*dbip;
d379 6
a384 6
db_apply_state_from_one_member( tsp, pathp, cp, sofar, tp )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
CONST char		*cp;
int			sofar;
CONST union tree	*tp;
d433 1
a433 3
db_find_named_leaf( tp, cp )
union tree		*tp;
CONST char		*cp;
d474 1
a474 4
db_find_named_leafs_parent( side, tp, cp )
int			*side;
union tree		*tp;
CONST char		*cp;
d519 1
a519 2
db_tree_del_lhs( tp )
union tree		*tp;
d563 1
a563 2
db_tree_del_rhs( tp )
union tree		*tp;
d667 1
a667 3
db_tree_mul_dbleaf( tp, mat )
union tree	*tp;
CONST mat_t	mat;
d708 8
a715 6
db_tree_funcleaf( dbip, comb, comb_tree, leaf_func, user_ptr1, user_ptr2, user_ptr3 )
struct db_i		*dbip;
struct rt_comb_internal	*comb;
union tree		*comb_tree;
void			(*leaf_func)();
genptr_t		user_ptr1,user_ptr2,user_ptr3;
d764 6
a769 6
db_follow_path( tsp, total_path, new_path, noisy, depth )
struct db_tree_state		*tsp;
struct db_full_path		*total_path;
CONST struct db_full_path	*new_path;
int				noisy;
int				depth;		/* # arcs in new_path to use */
d952 1
a952 1
void
d1293 1
a1293 2
db_ck_tree( tp )
CONST union tree	*tp;
d1452 1
a1452 2
db_left_hvy_node( tp )
register union tree *tp;
d1490 1
a1490 1
top:
d1628 1
a1628 3
db_count_tree_nodes( tp, count )
register CONST union tree	*tp;
register int			count;
d1670 1
a1670 2
db_is_tree_all_unions( tp )
register CONST union tree	*tp;
d1947 1
a1947 1
void
d2372 1
a2372 4
db_region_mat(m, dbip, name)
mat_t m;
CONST struct db_i *dbip;
CONST char *name;
@


11.92
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.91 2000/06/29 14:40:22 mike Exp $ (BRL)";
d638 2
a639 3
db_tree_del_dbleaf( tp, cp )
union tree		**tp;
CONST char		*cp;
@


11.91
log
@
rt_db_free_internal
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.90 2000/06/28 16:36:06 mike Exp $ (BRL)";
@


11.90
log
@
db_gettree_leaf() changed to new calling sequence.
Added a useful DEBUG_TREEWALK print.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.89 2000/06/27 17:36:09 mike Exp $ (BRL)";
d885 1
a885 1
		intern.idb_meth->ft_ifree( &intern );
d1243 1
a1243 1
	if( intern.idb_ptr )  intern.idb_meth->ft_ifree( &intern );
@


11.89
log
@
Modified calling sequence to leaf node callback for db_recurse()
and db_walk_tree().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.88 2000/06/27 14:53:38 mike Exp $ (BRL)";
d1084 1
d1189 3
d1834 1
a1834 1
HIDDEN union tree *db_gettree_leaf( tsp, pathp, ext, id, client_data )
d1837 1
a1837 2
struct bu_external	*ext;
int			id;
d1844 1
@


11.88
log
@
Began conversion to more generic  rt_db_get_internal()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.87 2000/04/12 02:14:00 mike Exp $ (BRL)";
a1059 1
	struct bu_external	ext;
d1092 1
a1092 3
		/*  Handle inheritance of material property. */
		db_dup_db_tree_state( &nts, tsp );

d1094 1
a1094 2
			bu_log("db_recurse() rt_db_get_internal(%s) FAIL on combination\n", dp->d_namep);
			db_free_db_tree_state( &nts );
d1098 4
a1178 1
		int	id;
d1180 4
a1183 9
		if( db_get_external( &ext, dp, tsp->ts_dbip ) < 0 )  {
			bu_log("db_recurse() db_get_external(%s) FAIL on solid\n", dp->d_namep);
			return(TREE_NULL);		/* FAIL */
		}
		/* Get solid ID */
		if( (id = rt_id_solid( &ext )) == ID_NULL )  {
			bu_log("db_recurse(%s): defective database record, addr=x%x\n",
				dp->d_namep,
				dp->d_addr );
d1188 3
a1190 4
		if( bn_mat_ck( dp->d_namep, tsp->ts_mat ) < 0 )  {
			bu_log("db_recurse(%s):  matrix does not preserve axis perpendicularity.\n",
				dp->d_namep );
			bn_mat_print("bad matrix", tsp->ts_mat);
d1231 1
a1231 1
		curtree = tsp->ts_leaf_func( tsp, pathp, &ext, id, client_data );
a1239 1
	db_free_external( &ext );
d1869 1
a1869 1
union tree		 *(*leaf_func) BU_ARGS((struct db_tree_state *, struct db_full_path *, struct bu_external *, int, void *));
d2097 1
a2097 2
			struct bu_external * /*ep*/,
			int /*id*/,
@


11.87
log
@
NT port
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.86 2000/04/12 02:08:12 mike Exp $ (BRL)";
a1086 4
	if( db_get_external( &ext, dp, tsp->ts_dbip ) < 0 )  {
		bu_log("db_recurse() db_get_external() FAIL\n");
		return(TREE_NULL);		/* FAIL */
	}
d1096 2
a1097 2
		if( rt_comb_v4_import( &intern , &ext , NULL ) < 0 )  {
			bu_log("db_recurse() import of %s failed\n", dp->d_namep);
d1181 4
@


11.86
log
@
NT port
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.85 2000/03/04 05:53:45 mike Exp $ (BRL)";
d1877 1
a1877 1
union tree		 *(*leaf_func)();
@


11.85
log
@
Added support for FASTGEN PLATE and VOLUME mode regions,
which are special cases of the orginary BRL-CAD region.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.84 2000/03/03 03:38:15 mike Exp $ (BRL)";
d238 1
a238 1
				(((double)(comb->rgb[0]))*bn_inv255);
d240 1
a240 1
				(((double)(comb->rgb[1]))*bn_inv255);
d242 1
a242 1
				(((double)(comb->rgb[2]))*bn_inv255);
@


11.84
log
@
Added additional comment.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.83 2000/03/03 01:50:26 mike Exp $ (BRL)";
d314 1
@


11.83
log
@
Updated comments.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.82 2000/02/29 20:35:00 mike Exp $ (BRL)";
d2044 3
@


11.82
log
@
Provided real function prototypes for db_walk_tree()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.81 2000/02/29 19:57:11 mike Exp $ (BRL)";
d2045 3
a2047 1
 *	reg_start_func	Func returns 0 if region should be skipped,
d2049 1
d2051 8
a2058 3
 *	reg_end_func	Func to process collected region data.
 *			returns a pointer to "any unused subtree for freeing"
 *			  XXX What does that mean???
d2061 3
a2063 23
 *				Unknown significance of returned parameter
 *
 * Function Prototypes:
 *
 *	int	reg_start_func(
 *			struct db_tree_state	*nts,
 *			struct db_full_path	*pathp,
 *			struct rt_comb_internal	*comb,
 *			genptr_t		client_data)
 *
 *
 *	union tree *reg_end_func(
 *			struct db_tree_state	*db_ts,
 *	                struct db_full_path	*db_fp,
 *	                union tree		*curtree,
 *	                genptr_t		client_data)
 *
 *	union tree *leaf_func(
 *			struct db_tree_state	*tsp,
 *			struct db_full_path	*pathp,
 *			struct bu_external	*ep,
 *			int			id, /_* rt_id_solid() result *_/
 *			genptr_t		client_data)
@


11.81
log
@
Now it compiles. :-)
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.80 2000/02/29 00:43:01 butler Exp $ (BRL)";
d2041 3
a2043 1
 *	init_state	XXX ????
d2098 19
a2116 3
int		(*reg_start_func)();
union tree *	(*reg_end_func)();
union tree *	(*leaf_func)();
@


11.80
log
@Interpreted the arguments to db_walk_tree so that someone besides Mike could
have a chance of calling it correctly. ;-)
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.79 2000/02/01 20:57:27 mike Exp $ (BRL)";
d2072 1
a2072 1
 *			int			id, /* rt_id_solid() result */
@


11.79
log
@
Performance enhancement for case where boolean tree is all unions.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.78 2000/01/22 03:31:50 mike Exp $ (BRL)";
d2035 40
a2074 1
 *  This is the top interface to the tree walker.
@


11.78
log
@
RT_SEM_STATS is used for rt_gettrees(), so the
recursive invocation in db_shader_mat() needed to use a different
semaphore.  RT_SEM_MODEL was available.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.77 2000/01/22 01:23:05 mike Exp $ (BRL)";
d1676 2
a1677 2
		bu_log("db_count_subtree_regions: bad op %d\n", tp->tr_op);
		rt_bomb("db_count_subtree_regions\n");
d1680 42
@


11.77
log
@
Added code to check for material-property animations specified
*below* the region in the DAG, and provide a useful error message.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.76 2000/01/22 00:51:14 mike Exp $ (BRL)";
d2391 1
a2391 1
		bu_semaphore_acquire( RT_SEM_STATS );
d2393 1
a2393 1
		bu_semaphore_release( RT_SEM_STATS );
@


11.76
log
@
Improved commenting
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.75 2000/01/22 00:47:58 mike Exp $ (BRL)";
d360 8
a367 1
	db_apply_anims( pathp, mdp, old_xlate, xmat, &tsp->ts_mater );
d2225 3
a2227 1
 *  Note that 'arc' may be a null pointer.
@


11.75
log
@
Removed #if0 code no longer needed.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.74 2000/01/14 22:39:34 mike Exp $ (BRL)";
d755 5
@


11.74
log
@
Changed return codes.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.72 2000/01/05 21:48:16 mike Exp $ (BRL)";
a2207 67

#if 0
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	union tree		*tp;
	struct directory	*kidp;
	struct directory	*parentp;
	int			i,j;
	mat_t			tmat;
	int			holdlength;
	/* XXX case where depth == 0 and pathp->fp_len=2 */


	/*
	 * if depth <= 0 then use the full path.
	 */
	if (depth <= 0) depth = pathp->fp_len-1;
	/*
	 * set depth to the max of depth or path length.
	 */
	if (depth > pathp->fp_len-1) depth = pathp->fp_len-1;

	bn_mat_idn(mat);
	/*
	 * if there is no arc, return ident matrix now
	 */
	if (depth == 0) return 1;

	for (i=0; i < depth; i++) {
		parentp = pathp->fp_names[i];
		kidp = pathp->fp_names[i+1];
		if (!(parentp->d_flags & DIR_COMB)) {
			char *sofar = db_path_to_string(pathp);
			bu_log("db_path_to_mat: '%s' of '%s' not a combination.\n",
			    parentp->d_namep, sofar);
			bu_free(sofar, "path string");
			return 0;
		}

		if( rt_db_get_internal( &intern, parentp, dbip, NULL ) < 0 )  return 0;
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		RT_CK_COMB(comb);
		if( (tp = db_find_named_leaf( comb->tree, kidp->d_namep )) == TREE_NULL )  {
			bu_log("db_path_to_mat: unable to follow %s/%s path\n",
			    parentp->d_namep, kidp->d_namep);
			return 0;
		}
		/*
		 * tp->tl_mat is the matrix from the disk.
		 * mat is the collection of all operations so far.
		 * (Stack)
		 */
		holdlength = pathp->fp_len;
		pathp->fp_len = i+2;
		if( tp->tr_l.tl_mat )  {
			db_apply_anims(pathp, kidp, mat, tp->tr_l.tl_mat, 0);
			bn_mat_mul(tmat, mat, tp->tr_l.tl_mat);
			bn_mat_copy(mat, tmat);
		} else {
			bn_mat_idn( tmat );
			db_apply_anims(pathp, kidp, mat, tmat, 0);
		}
		pathp->fp_len = holdlength;
		intern.idb_meth->ft_ifree( &intern );
	}
	return 1;
#endif
@


11.73
log
@
Unnecessarily more conservative version of db_free_tree().
Inspired by hardware problems on kraken.nvl.army.mil
@
text
@a644 2
bu_log("db_free_tree from db_tree_del_dbleaf\n");
db_ck_tree( *tp );
d2351 4
d2356 1
a2356 1
void
d2368 2
a2369 2
		bu_log("db_string_to_path(%s) error\n", name);
		rt_bomb("error getting path\n");
d2373 2
a2374 2
		bu_log("db_path_to_mat(%s) error", name);
		rt_bomb("error getting region coordinate matrix\n");
d2381 2
d2398 4
d2403 1
a2403 1
void
d2424 2
a2425 1
	db_region_mat(model_to_region, rtip->rti_dbip, rp->reg_name);
d2471 1
@


11.72
log
@
Added dummy client_data args to match Bob's new calling sequence
for callbacks.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.71 2000/01/04 21:04:23 bparker Exp $ (BRL)";
d44 2
d645 2
d994 1
d1346 1
a1346 1
union tree	*tp;
d1349 7
d1427 14
a1440 7
		/* This node is known to be a binary op */
		if( tp->tr_b.tb_left->magic == RT_TREE_MAGIC )
			db_free_tree( tp->tr_b.tb_left );
		tp->tr_b.tb_left = TREE_NULL;
		if( tp->tr_b.tb_right->magic == RT_TREE_MAGIC )
			db_free_tree( tp->tr_b.tb_right );
		tp->tr_b.tb_right = TREE_NULL;
d2165 1
a2165 1
		if( reg_trees[i] != TREE_NULL )
d2167 1
@


11.71
log
@OOPS, missed one
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.70 2000/01/04 17:58:20 bparker Exp $ (BRL)";
d1748 1
a1748 1
HIDDEN union tree *db_gettree_region_end( tsp, pathp, curtree )
d1752 1
d1766 1
a1766 1
HIDDEN union tree *db_gettree_leaf( tsp, pathp, ext, id )
d1771 1
@


11.70
log
@*- add client_data to db_walk_tree
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.69 1999/12/28 23:30:07 mike Exp $ (BRL)";
d1143 1
a1143 1
			db_recurse_subtree( curtree, &nts, pathp, region_start_statepp );
@


11.69
log
@
Made message more specific when creating regions for lone solids.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.68 1999/12/22 02:07:37 mike Exp $ (BRL)";
d951 1
a951 1
db_recurse_subtree( tp, msp, pathp, region_start_statepp )
d956 1
d980 1
a980 1
		if( (subtree = db_recurse( &memb_state, pathp, region_start_statepp )) != TREE_NULL )  {
d1009 1
a1009 1
		db_recurse_subtree( tp->tr_b.tb_left, &memb_state, pathp, region_start_statepp );
d1014 1
a1014 1
		db_recurse_subtree( tp->tr_b.tb_right, &memb_state, pathp, region_start_statepp );
d1037 1
a1037 1
db_recurse( tsp, pathp, region_start_statepp )
d1041 1
d1106 1
a1106 1
			    tsp->ts_region_start_func( &nts, pathp, comb ) < 0 )  {
d1160 1
a1160 1
					&nts, pathp, curtree );
d1222 1
a1222 1
		curtree = tsp->ts_leaf_func( tsp, pathp, &ext, id );
d1791 1
d1800 1
a1800 1
db_walk_subtree( tp, region_start_statepp, leaf_func )
d1804 1
d1842 1
a1842 1
		curtree = db_recurse( &ctsp->cts_s, &ctsp->cts_p, region_start_statepp );
d1864 1
a1864 1
		db_walk_subtree( tp->tr_b.tb_left, region_start_statepp, leaf_func );
d1872 2
a1873 2
		db_walk_subtree( tp->tr_b.tb_left, region_start_statepp, leaf_func );
		db_walk_subtree( tp->tr_b.tb_right, region_start_statepp, leaf_func );
d1925 1
a1925 1
			wps->reg_leaf_func );
d1952 1
a1952 1
				curtree );
d1978 1
a1978 1
db_walk_tree( dbip, argc, argv, ncpu, init_state, reg_start_func, reg_end_func, leaf_func )
d1987 1
d2028 1
a2028 1
		curtree = db_recurse( &ts, &path, &region_start_statep );
d2134 1
@


11.68
log
@
Removed dead vars
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.67 1999/11/24 23:02:32 mike Exp $ (BRL)";
d1200 1
a1200 1
			    	bu_log("WARNING: db_recurse(): solid '%s' not contained in a region\n",
@


11.67
log
@
Changed to ft_ifree()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.66 1999/05/10 21:30:47 mike Exp $ (BRL)";
a136 1
	int				shader_len=0;
a339 1
	register struct animate *anp;
a770 1
	register int		i;
a1025 4
static vect_t xaxis = { 1.0, 0, 0 };
static vect_t yaxis = { 0, 1.0, 0 };
static vect_t zaxis = { 0, 0, 1.0 };

a1043 1
	int			i;
d1472 2
a1473 2
	union tree *A, *B, *C, *D;
	union tree *dup, *tmp, *new;
@


11.66
log
@Variable name changed from ma_override to ma_color_valid
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.65 1999/05/10 16:03:36 mike Exp $ (BRL)";
d873 1
a873 1
		rt_comb_ifree( &intern );
d1236 1
a1236 1
	if( intern.idb_ptr )  rt_comb_ifree( &intern );
d2253 1
a2253 1
		rt_comb_ifree( &intern );
@


11.65
log
@ts_region_start_func() got extra parameter of
rt_comb_internal *combp
for FASTGEN foolishness.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.64 1998/12/17 04:19:09 mike Exp $ (BRL)";
d234 2
a235 2
			/* DB_INH_LOWER -- lower nodes in tree override */
			tsp->ts_mater.ma_override = 1;
d242 1
@


11.64
log
@Regions now have an associated temperature
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.63 1998/06/22 19:50:39 jra Exp $ (BRL)";
d1111 1
a1111 1
			    tsp->ts_region_start_func( &nts, pathp ) < 0 )  {
@


11.63
log
@db_apply_state_from_comb() now converts shader info from TCL format back to keyword=value format
before putting it in the tree.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_tree.c,v 11.62 1998/04/15 05:15:44 mike Exp $ (BRL)";
d181 1
d245 16
d294 1
a294 1
		tsp->ts_mater.ma_minherit = comb->inherit;
@


11.62
log
@Eliminated nasty global state variables,
thanks to new calling sequence of bu_parallel().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.61 1998/04/02 23:48:12 mike Exp mike $ (BRL)";
d256 2
d261 16
a276 2
			tsp->ts_mater.ma_shader = bu_vls_strdup(
				&comb->shader);
@


11.61
log
@Added recursive-parallel check.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.60 1997/12/30 10:22:58 mike Exp mike $ (BRL)";
d1756 10
a1765 6
static struct db_i	*db_dbip;
static union tree	**db_reg_trees;
static int		db_reg_count;
static int		db_reg_current;		/* semaphored when parallel */
static union tree *	(*db_reg_end_func)();
static union tree *	(*db_reg_leaf_func)();
d1797 1
a1797 1
		ctsp->cts_s.ts_dbip = db_dbip;
d1866 3
a1868 1
db_walk_dispatcher()
d1873 3
d1879 1
a1879 1
		mine = db_reg_current++;
d1882 1
a1882 1
		if( mine >= db_reg_count )
d1888 1
a1888 1
		if( (curtree = db_reg_trees[mine]) == TREE_NULL )
d1894 2
a1895 1
		db_walk_subtree( curtree, &region_start_statep, db_reg_leaf_func );
d1918 2
a1919 2
		if( db_reg_end_func )  {
			db_reg_trees[mine] = (*db_reg_end_func)(
d1934 4
a1937 2
 *  This routine will employ multiple CPUs, but is not
 *  itself parallel-safe.  Call this routine from serial code only.
d1962 1
a1965 2
	db_dbip = dbip;			/* make global to this module */

d2090 13
a2102 7
	if( bu_is_parallel() )  bu_bomb("db_walk_tree() invoked inside parallel section.\n");
	/* Export some state to read-only static variables */
	db_reg_trees = reg_trees;
	db_reg_count = new_reg_count;
	db_reg_current = 0;			/* Semaphored */
	db_reg_end_func = reg_end_func;
	db_reg_leaf_func = leaf_func;
d2105 1
a2105 1
		db_walk_dispatcher();
d2107 1
a2107 1
		bu_parallel( db_walk_dispatcher, ncpu );
@


11.60
log
@I got the semantics of db_path_to_mat() wrong last week,
the matrix is an output-only variable.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.59 1997/12/30 10:07:08 mike Exp mike $ (BRL)";
d2079 1
@


11.59
log
@Added missing arg on invocation of db_init_db_tree_state()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.58 1997/12/23 10:37:07 mike Exp mike $ (BRL)";
a2103 1
 *  XXX should be able to just call db_follow_path().
d2106 1
a2106 1
 *	1	OK, updated matrix is in 'mat'.
a2127 1
	bn_mat_copy( ts.ts_mat, mat );
@


11.58
log
@Changed db_path_to_mat() to use db_follow_path(), rather than
having it's own treewalker too.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.57 1997/12/23 06:37:01 mike Exp mike $ (BRL)";
d2128 1
a2128 1
	db_init_db_tree_state( &ts );
@


11.57
log
@Split out db_follow_path(), which has a TCL interface now.
Removed some redundant code.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.56 1997/12/16 06:19:34 mike Exp mike $ (BRL)";
d91 4
d321 7
a327 1
	db_apply_anims( pathp, mdp, xmat, tp->tr_l.tl_mat, &tsp->ts_mater );
d794 1
d836 3
a838 1
		/* Found it, state has been applied, sofar applied, directory entry pushed onto total_path */
a1030 1

d1036 1
a1139 2
		vect_t	A, B, C;
		fastf_t	fx, fy, fz;
d1150 3
a1152 16
		/*
		 * Validate that matrix preserves perpendicularity of axis
		 * by checking that A.B == 0, B.C == 0, A.C == 0
		 * XXX these vectors should just be grabbed out of the matrix
		 */
		MAT4X3VEC( A, tsp->ts_mat, xaxis );
		MAT4X3VEC( B, tsp->ts_mat, yaxis );
		MAT4X3VEC( C, tsp->ts_mat, zaxis );
		fx = VDOT( A, B );
		fy = VDOT( B, C );
		fz = VDOT( A, C );
		if( ! NEAR_ZERO(fx, 0.0001) ||
		    ! NEAR_ZERO(fy, 0.0001) ||
		    ! NEAR_ZERO(fz, 0.0001) )  {
			bu_log("db_recurse(%s):  matrix does not preserve axis perpendicularity.\n  X.Y=%g, Y.Z=%g, X.Z=%g\n",
				dp->d_namep, fx, fy, fz );
d2105 6
d2119 23
a2149 5

	RT_CHECK_DBI(dbip);
	RT_CK_FULL_PATH(pathp);


d2206 1
d2211 2
@


11.56
log
@ran h/sed4
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.57 1997/12/16 06:17:25 mike Exp $ (BRL)";
d90 15
d317 2
a318 4
	if( tp->tr_l.tl_mat )
		bn_mat_copy( xmat, tp->tr_l.tl_mat );
	else
		bn_mat_idn( xmat );
a319 49
	/* Check here for animation to apply */
	if ((mdp->d_animate != ANIM_NULL) && (rt_g.debug & DEBUG_ANIM)) {
		char	*sofar = db_path_to_string(pathp);
		bu_log("Animate %s with...\n", sofar);
		bu_free(sofar, "path string");
	}
	/*
	 *  For each of the animations attached to the mentioned object,
	 *  see if the current accumulated path matches the path
	 *  specified in the animation.
	 *  Comparison is performed right-to-left (from leafward to rootward).
	 */
	for( anp = mdp->d_animate; anp != ANIM_NULL; anp = anp->an_forw ) {
		register int i;
		register int j = pathp->fp_len-1;
		register int anim_flag;
		
		RT_CK_ANIMATE(anp);
		i = anp->an_path.fp_len-1;
		anim_flag = 1;

		if (rt_g.debug & DEBUG_ANIM) {
			char	*str;

			str = db_path_to_string( &(anp->an_path) );
			bu_log( "\t%s\t", str );
			bu_free( str, "path string" );
			bu_log("an_path.fp_len-1:%d  pathp->fp_len-1:%d\n",
				i, j);

		}
		for( ; i>=0 && j>=0; i--, j-- )  {
			if( anp->an_path.fp_names[i] != pathp->fp_names[j] ) {
				if (rt_g.debug & DEBUG_ANIM) {
					bu_log("%s != %s\n",
					     anp->an_path.fp_names[i]->d_namep,
					     pathp->fp_names[j]->d_namep);
				}
				anim_flag = 0;
				break;
			}
		}
		/* Perhaps tsp->ts_mater should be just tsp someday? */
		if (anim_flag)  {
			db_do_anim( anp, old_xlate, xmat, &(tsp->ts_mater) );
		}
	}

	bn_mat_mul(tsp->ts_mat, old_xlate, xmat);
d705 1
a705 1
 *			D B _ F O L L O W _ P A T H _ F O R _ S T A T E
d707 4
a710 2
 *  Follow the slash-separated path given by "cp", and update
 *  *tsp and *pathp with full state information along the way.
d712 2
a713 1
 *  A much more complete version of rt_plookup().
d720 6
a725 5
db_follow_path_for_state( tsp, pathp, orig_str, noisy )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
CONST char		*orig_str;
int			noisy;
a726 1
	struct bu_external	ext;
a729 5
	register char		*cp;
	register char		*ep;
	char			*str;		/* ptr to duplicate string */
	char			oldc;
	register struct member *mp;
d732 1
d735 2
a736 1
	RT_CK_FULL_PATH( pathp );
d739 4
a742 3
		char	*sofar = db_path_to_string(pathp);
		bu_log("db_follow_path_for_state() pathp='%s', tsp=x%x, orig_str='%s', noisy=%d\n",
			sofar, tsp, orig_str, noisy );
d744 1
d747 9
a755 1
	if( *orig_str == '\0' )  return(0);		/* Null string */
d757 1
a757 2
	BU_INIT_EXTERNAL( &ext );
	cp = str = bu_strdup( orig_str );
d759 4
a762 4
	/* Prime the pumps, and get the starting combination */
	if( pathp->fp_len > 0 )  {
		comb_dp = DB_FULL_PATH_CUR_DIR(pathp);
		oldc = 'X';	/* Anything non-null */
d764 4
a767 1
		/* Peel out first path element & look it up. */
a768 13
		/* Skip any leading slashes */
		while( *cp && *cp == '/' )  cp++;

		/* Find end of this path element and null terminate */
		ep = cp;
		while( *ep != '\0' && *ep != '/' )  ep++;
		oldc = *ep;
		*ep = '\0';

		if( (dp = db_lookup( tsp->ts_dbip, cp, noisy )) == DIR_NULL )
			goto fail;

		/* Process animations located at the root */
d784 1
a784 1
		db_add_node_to_full_path( pathp, dp );
d789 1
a789 1
		cp = ep+1;
d793 2
a794 1
	 *  Process two things at once: the combination, and it's member.
d797 4
a800 1
		if( oldc == '\0' )  break;
d802 2
a803 11
		/* Skip any leading slashes */
		while( *cp && *cp == '/' )  cp++;
		if( *cp == '\0' )  break;

		/* Find end of this path element and null terminate */
		ep = cp;
		while( *ep != '\0' && *ep != '/' )  ep++;
		oldc = *ep;
		*ep = '\0';

		if( (dp = db_lookup( tsp->ts_dbip, cp, noisy )) == DIR_NULL )
d805 1
d809 1
a809 1
			bu_log("db_follow_path_for_state() at %s/%s\n", comb_dp->d_namep, dp->d_namep );
d812 2
a813 2
		/* Load the entire combination into contiguous memory */
		if( db_get_external( &ext, comb_dp, tsp->ts_dbip ) < 0 )
a814 5

		if( rt_comb_v4_import( &intern , &ext , NULL ) < 0 )  {
			bu_log("db_follow_path_for_state() import of %s failed\n", comb_dp->d_namep);
			goto fail;
		}
d817 1
a817 1
		if( db_apply_state_from_comb( tsp, pathp, comb ) < 0 )
d821 2
a822 2
		if( db_apply_state_from_one_member( tsp, pathp, cp, 0, comb->tree ) <= 0 )  {
			bu_log("db_follow_path_for_state() ERROR: unable to apply member %s state\n", dp->d_namep);
d825 1
a825 2
		/* Found it, state has been applied, sofar applied, directory entry pushed onto pathp */
		/* Done */
a827 2
		db_free_external( &ext );

d832 1
a832 2
			/*db_add_node_to_full_path( pathp, dp );*/
			if( oldc == '\0' )  {
d838 4
a841 3
				char	*sofar = db_path_to_string(pathp);
				bu_log("db_follow_path_for_state(%s) ERROR: found leaf early at '%s'\n",
					cp, sofar );
d843 1
a847 10
		/* Member is itself a combination */
		if( dp->d_len <= 1 )  {
			/* Combination has no members */
			if( noisy )  {
				bu_log("db_follow_path_for_state(%s) ERROR: combination '%s' has no members\n",
					cp, dp->d_namep );
			}
			goto fail;
		}

d849 1
a849 1
		cp = ep+1;
d851 1
a851 1
	} while( oldc != '\0' );
a853 2
	db_free_external( &ext );
	bu_free( str, "bu_strdup (dup'ed path)" );
d855 2
a856 2
		char	*sofar = db_path_to_string(pathp);
		bu_log("db_follow_path_for_state() returns pathp='%s'\n",
d860 1
a860 1
	return(0);		/* SUCCESS */
d862 1
a862 3
	db_free_external( &ext );
	bu_free( str, "bu_strdup (dup'ed path)" );
	return(-1);		/* FAIL */
d865 21
d887 14
d2106 1
d2230 2
d2289 2
@


11.55
log
@Converted to bu_semaphore_acquire()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.54 1997/11/21 21:01:02 jra Exp mike $ (BRL)";
d140 1
a140 1
	rt_free( (char *)ctsp, "combined_tree_state");
d163 1
a163 1
	mat_print("ts_mat", tsp->ts_mat );
d180 1
a180 1
	rt_free( str, "path string" );
d210 1
a210 1
				rt_free(sofar, "path string");
d233 1
a233 1
				rt_free(sofar, "path string");
d253 1
a253 1
				rt_free(sofar, "path string");
d295 1
a295 1
		rt_free(sofar, "path string");
d301 1
a301 1
	mat_copy( old_xlate, tsp->ts_mat );
d303 1
a303 1
		mat_copy( xmat, tp->tr_l.tl_mat );
d305 1
a305 1
		mat_idn( xmat );
d311 1
a311 1
		rt_free(sofar, "path string");
d333 1
a333 1
			rt_free( str, "path string" );
d355 1
a355 1
	mat_mul(tsp->ts_mat, old_xlate, xmat);
d676 1
a676 1
			tp->tr_l.tl_mat = mat_dup(mat);
d778 1
a778 1
		rt_free(sofar, "path string");
d814 2
a815 2
				mat_copy( old_xlate, tsp->ts_mat );
				mat_idn( xmat );
d817 1
a817 1
				mat_mul( tsp->ts_mat, old_xlate, xmat );
d891 1
a891 1
				rt_free(sofar, "path string");
d913 1
a913 1
	rt_free( str, "bu_strdup (dup'ed path)" );
d918 1
a918 1
		rt_free(sofar, "path string");
d923 1
a923 1
	rt_free( str, "bu_strdup (dup'ed path)" );
d952 1
a952 1
				rt_free( (char *)tp->tr_l.tl_mat, "tl_mat" );
d955 1
a955 1
			rt_free( tp->tr_l.tl_name, "tl_name" );
d977 1
a977 1
				rt_free( (char *)tp->tr_l.tl_mat, "tl_mat" );
d980 1
a980 1
			rt_free( tp->tr_l.tl_name, "tl_name" );
d1050 1
a1050 1
		rt_free(sofar, "path string");
d1097 1
a1097 1
					rt_free(sofar, "path string");
d1182 1
a1182 1
			mat_print("bad matrix", tsp->ts_mat);
d1215 1
a1215 1
		    	rt_free( sofar, "path string" );
d1238 1
a1238 1
		rt_free(sofar, "path string");
d1367 1
a1367 1
				rt_free( (char *)tp->tr_d.td_name, "region name" );
d1397 1
a1397 1
			rt_free( (char *)tp->tr_l.tl_mat, "tl_mat" );
d1400 1
a1400 1
		rt_free( tp->tr_l.tl_name, "tl_name" );
d1430 1
a1430 1
	rt_free( (char *)tp, "union tree" );
d1570 1
a1570 1
		GETUNION( tmp, tree );
d1842 1
a1842 1
			rt_free( str, "path string" );
d1853 1
a1853 1
		rt_free( (char *)curtree, "replaced tree node" );
d2066 1
a2066 1
	reg_trees = (union tree **)rt_calloc( sizeof(union tree *),
d2100 1
a2100 1
			rt_free( str, "path string" );
d2126 1
a2126 1
	rt_free( (char *)reg_trees, "*reg_trees[]" );
d2166 1
a2166 1
	mat_idn(mat);
d2179 1
a2179 1
			rt_free(sofar, "path string");
d2200 2
a2201 2
			mat_mul(tmat, mat, tp->tr_l.tl_mat);
			mat_copy(mat, tmat);
d2203 1
a2203 1
			mat_idn( tmat );
d2231 1
a2231 1
		rt_free(sofar, "path string");
d2255 1
a2255 1
			rt_free( str, "path string" );
d2307 1
a2307 1
	mat_inv(m, region_to_model);
d2346 1
a2346 1
	mat_print("model_to_region", model_to_region);
d2375 1
a2375 1
	mat_idn(m_xlate);
d2378 1
a2378 1
	mat_mul(m_tmp, m_xlate, model_to_region);
d2386 1
a2386 1
	mat_idn(m_scale);
d2388 1
a2388 1
	mat_mul(model_to_shader, m_scale, m_tmp);
@


11.54
log
@Fixed a memory leak in db_recurse_subtree().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.53 1997/04/15 14:30:06 jra Exp jra $ (BRL)";
d1898 1
a1898 1
		RES_ACQUIRE( &rt_g.res_worker );
d1900 1
a1900 1
		RES_RELEASE( &rt_g.res_worker );
@


11.53
log
@Fixed bug in db_non_union_push().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.52 1997/02/27 15:52:24 jra Exp jra $ (BRL)";
d971 1
@


11.52
log
@Added db_left_hvy_node() to reblance a single tree node.
Added more cases to db_non_union_push() to make it more general.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.51 1997/02/26 18:21:28 jra Exp jra $ (BRL)";
d1046 1
a1046 1
		bu_log("db_recurse() pathp='%s', tsp=x%x, *statepp=x%x\n",
d1048 1
a1048 1
			*region_start_statepp );
d1501 1
a1501 2
	    	if( tp->tr_b.tb_right->tr_op == OP_UNION )
	    		repush_child = 1;
d1563 1
a1563 2
		if( tp->tr_b.tb_left->tr_op == OP_UNION )
			repush_child = 1;
d1584 1
a1584 2
		if( tp->tr_b.tb_left->tr_op == OP_UNION )
			repush_child = 1;
d2044 1
d2050 2
d2054 4
@


11.51
log
@Added cade for OP_DB_LEAF in db_dup_subtree().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.50 1997/02/12 16:03:38 jra Exp jra $ (BRL)";
d1432 30
d1474 4
d1491 1
a1491 3
	case OP_UNION:
		/* This node is known to be a binary op */
		/* Recurse both left and right */
d1494 1
a1494 1
		return;
d1496 2
a1497 2

	if( tp->tr_op == OP_INTERSECT || tp->tr_op == OP_SUBTRACT )  {
d1501 2
a1502 7
		if( lhs->tr_op != OP_UNION )  {
			/* Recurse left only */
			db_non_union_push( lhs );
			if( (lhs=tp->tr_b.tb_left)->tr_op != OP_UNION )
				return;
			/* lhs rewrite turned up a union here, do rewrite */
		}
d1557 50
a1606 2
		/* Now reconsider whole tree again */
		goto top;
d1608 3
a1610 1
    	bu_log("db_non_union_push() ERROR tree op=%d.?\n", tp->tr_op );
@


11.50
log
@Added a third user pointer to db_tree_funcleaf().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.49 1997/01/31 05:01:13 mike Exp jra $ (BRL)";
d1259 1
@


11.49
log
@renamed comb_functree() to db_tree_funcleaf(),
moved from db_walk.c to db_tree.c
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.48 1997/01/31 02:19:30 butler Exp $ (BRL)";
d707 1
a707 1
db_tree_funcleaf( dbip, comb, comb_tree, leaf_func, user_ptr1, user_ptr2 )
d712 1
a712 1
genptr_t		user_ptr1,user_ptr2;
d724 1
a724 1
			(*leaf_func)( dbip, comb, comb_tree, user_ptr1, user_ptr2 );
d730 2
a731 2
			db_tree_funcleaf( dbip, comb, comb_tree->tr_b.tb_left, leaf_func, user_ptr1, user_ptr2 );
			db_tree_funcleaf( dbip, comb, comb_tree->tr_b.tb_right, leaf_func, user_ptr1, user_ptr2 );
@


11.48
log
@XXX comment to remind us that we need an RPP/matrix tree walker
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.47 1997/01/30 02:50:09 mike Exp butler $ (BRL)";
d694 43
@


11.47
log
@Typo
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.46 1997/01/30 02:22:54 mike Exp mike $ (BRL)";
a2222 2

		bu_log("db_shader_mat() min/max equal, getting bounding box of \"%s\"\n", reg_name);
d2225 6
@


11.46
log
@Eliminated rt_get_comb()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.45 1997/01/29 20:06:44 mike Exp mike $ (BRL)";
d2057 1
a2057 1
		if( rt_db_get_intern( &intern, parentp, dbip, NULL ) < 0 )  return 0;
@


11.45
log
@Added db_tree_mul_dbleaf()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.44 1997/01/29 01:29:44 mike Exp mike $ (BRL)";
d2057 1
a2057 1
		if( rt_get_comb( &intern, parentp, NULL, dbip ) < 0 )  return 0;
@


11.44
log
@Make sure it catches all instances of named leaf.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.43 1997/01/29 00:59:07 mike Exp $ (BRL)";
d658 38
@


11.43
log
@Added missing return.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.42 1997/01/29 00:33:40 mike Exp mike $ (BRL)";
d647 1
d651 1
@


11.42
log
@Changed calling sequence of db_tree_del_dbleaf() to allow
removing last node on tree.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.41 1997/01/28 02:34:06 mike Exp mike $ (BRL)";
d617 2
a618 1
 *	-2	Internal error
d629 2
d639 1
d641 1
a641 1
		return -1;
d653 1
a653 1
	return -2;
@


11.41
log
@Added db_dup_db_tree_state() / db_free_db_tree_state().
More care in checking magic numbers.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.40 1997/01/28 01:18:46 mike Exp mike $ (BRL)";
d415 2
d455 2
d602 1
a602 1
 *  Given a name presumably referenced in a OP_DBLEAF node,
d605 1
a605 1
 *  for example when rewriting A-subtree as "subtree",
d608 2
a609 1
 *  Use some other routine if you wish to kill the rhs of - and intersect nodes.
d613 3
d618 1
a618 1
 *	-1	Unable to find OP_DBLEAF node specified by 'cp'.
d622 1
a622 1
union tree		*tp;
d628 1
a628 1
	RT_CK_TREE(tp);
d630 7
a636 1
	if( (parent = db_find_named_leafs_parent( &side, tp, cp )) == TREE_NULL )
d638 1
@


11.40
log
@JRA's mods
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.39 1997/01/26 03:03:41 mike Exp jra $ (BRL)";
d45 45
a97 1
	int				shader_len=0;
d104 1
a104 11
	new->cts_s = *tsp;		/* struct copy */
	if( tsp->ts_mater.ma_shader )
		shader_len = strlen( tsp->ts_mater.ma_shader );
	if( shader_len )
	{
		new->cts_s.ts_mater.ma_shader = (char *)bu_malloc( shader_len+1, "db_new_combined_tree_state: ma_shader" );
	strcpy( new->cts_s.ts_mater.ma_shader, tsp->ts_mater.ma_shader );
	}
	else
		new->cts_s.ts_mater.ma_shader = (char *)NULL;

d123 1
a123 11
	new->cts_s = old->cts_s;	/* struct copy */
	if( old->cts_s.ts_mater.ma_shader )
		shader_len = strlen( old->cts_s.ts_mater.ma_shader );
	if( shader_len )
	{
		new->cts_s.ts_mater.ma_shader = (char *)bu_malloc( shader_len+1, "db_dup_combined_tree_state: ma_shader" );
	strcpy( new->cts_s.ts_mater.ma_shader, old->cts_s.ts_mater.ma_shader );
	}
	else
		new->cts_s.ts_mater.ma_shader = (char *)NULL;

d138 1
a138 3
	if( ctsp->cts_s.ts_mater.ma_shader )
		bu_free( ctsp->cts_s.ts_mater.ma_shader, "db_free_combined_tree_state: ma_shader" );

d841 2
a842 1
	memb_state = *msp;		/* struct copy */
a843 1
	RT_CK_TREE(tp);
d856 1
a856 1
			return;
d900 2
d965 1
a965 1
		nts = *tsp;	/* struct copy */
d969 1
d976 1
d996 1
d1009 1
d1047 1
@


11.39
log
@Added new routines
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /n/vapor/m/cad/librt/RCS/db_tree.c,v 11.38 1997/01/24 19:33:34 pjt Exp mike $ (BRL)";
d53 1
d61 10
d84 1
d90 10
d114 3
d220 1
a220 1
			tsp->ts_mater.ma_minherit = comb->inherit;
@


11.38
log
@Reversed sense of the comparison at the leaves indb_find_named_leaf()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.37 1996/12/04 02:51:56 mike Exp $ (BRL)";
d402 188
@


11.37
log
@Combined ma_matname and ma_matparm into a single string, ma_shader.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.36 1996/11/27 11:29:48 mike Exp mike $ (BRL)";
d384 3
a386 3
		if( strcmp( cp, tp->tr_l.tl_name ) != 0 )
			return tp;
		return TREE_NULL;
@


11.36
log
@Fixed "m35" problem.
When air regions were being deleted by the region handler routine,
their union tree nodes were not being appropriately zapped.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.35 1996/11/27 11:10:42 mike Exp mike $ (BRL)";
d115 1
a115 2
	bu_log(" ts_mater.ma_matname=%s\n", tsp->ts_mater.ma_matname ? tsp->ts_mater.ma_matname : "" );
	bu_log(" ts_mater.ma_matparam=%s\n", tsp->ts_mater.ma_matparm ? tsp->ts_mater.ma_matparm : "" );
d178 1
a178 1
	if( bu_vls_strlen( &comb->shader_name ) > 0 )  {
d184 1
a184 1
				bu_log("db_apply_state_from_comb(): WARNING: material property spec in combination within region '%s', ignored\n",
d191 4
a194 4
			tsp->ts_mater.ma_matname = bu_vls_strdup(
				&comb->shader_name);
			tsp->ts_mater.ma_matparm = bu_vls_strdup(
				&comb->shader_param);
@


11.35
log
@Additional debugging
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.34 1996/11/27 10:12:32 mike Exp mike $ (BRL)";
d637 9
@


11.34
log
@Added more debugging, in pursuit of m35 problem
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.33 1996/11/27 09:18:37 mike Exp mike $ (BRL)";
d743 6
d1657 2
a1658 1
				bu_log("%d: op=%\n", i, treep->tr_op);
@


11.33
log
@Added improved diagnostics
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.32 1996/11/27 09:11:19 mike Exp mike $ (BRL)";
d1437 4
d1443 1
a1443 1
		rt_bomb("db_walk_subtree\n");
@


11.32
log
@Fixed db_tally_subtree_regions: bad op 12
problem.
Also fixed bu_free() of stack memory.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.31 1996/11/22 08:55:51 mike Exp mike $ (BRL)";
d246 6
a251 2
	if( (mdp = db_lookup( tsp->ts_dbip, tp->tr_l.tl_name, LOOKUP_NOISY )) == DIR_NULL )
		return(-1);
@


11.31
log
@Added print of bad op.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /n/vapor/m/cad/librt/RCS/db_tree.c,v 11.30 1996/11/22 08:49:03 mike Exp mike $ (BRL)";
d609 11
a619 2
		if( db_apply_state_from_memb( &memb_state, pathp, tp ) < 0 )
			return;		/* error? */
d623 1
a623 1
			union tree	tmp;
d627 1
d629 1
a629 1
			tmp = *tp;	/* struct copy */
d631 1
a631 1
			db_free_tree( &tmp );
@


11.30
log
@Added support for OP_DB_LEAF.
Shows up in m35 benchmark test. ?!?
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /n/vapor/m/cad/librt/RCS/db_tree.c,v 11.29 1996/10/19 06:17:45 mike Exp mike $ (BRL)";
d1424 1
a1424 1
		bu_log("db_walk_subtree: bad op\n", tp->tr_op);
@


11.29
log
@Changed to reflect that ma_matparm is now a pointer, not an array.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.28 1996/10/19 05:46:47 mike Exp mike $ (BRL)";
d1266 1
@


11.28
log
@Eliminated "_new" suffix from db_apply_state_from_{comb,memb}
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.27 1996/10/19 05:38:42 mike Exp mike $ (BRL)";
d115 2
a116 2
	bu_log(" ts_mater.ma_matname=%s\n", tsp->ts_mater.ma_matname );
	bu_log(" ts_mater.ma_matparam=%s\n", tsp->ts_mater.ma_matparm );
d192 4
a195 3
			/* XXX ts_mater should become a bu_vls */
			strncpy( tsp->ts_mater.ma_matname, bu_vls_addr(&comb->shader_name), sizeof(tsp->ts_mater.ma_matname) );
			strncpy( tsp->ts_mater.ma_matparm, bu_vls_addr(&comb->shader_param), sizeof(tsp->ts_mater.ma_matparm) );
@


11.27
log
@Moved combination import routines to db_comb.c
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.26 1996/10/19 05:22:59 mike Exp mike $ (BRL)";
d149 1
a149 1
db_apply_state_from_combNEW( tsp, pathp, comb )
d233 1
a233 1
db_apply_state_from_memb_new( tsp, pathp, tp )
d336 1
a336 1
		if( db_apply_state_from_memb_new( tsp, pathp, tp ) < 0 )
d522 1
a522 1
		if( db_apply_state_from_combNEW( tsp, pathp, comb ) < 0 )
d608 1
a608 1
		if( db_apply_state_from_memb_new( &memb_state, pathp, tp ) < 0 )
d714 1
a714 1
		if( (is_region = db_apply_state_from_combNEW( &nts, pathp, comb )) < 0 )  {
@


11.26
log
@Removed old way of reading combinations
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.25 1996/10/16 03:14:01 mike Exp mike $ (BRL)";
d36 1
d38 1
a38 1
#include "db.h"
a43 12
struct tree_list {
	union tree *tl_tree;
	int	tl_op;
};
#define TREE_LIST_NULL	((struct tree_list *)0)

/* -------------------------------------------------- */


RT_EXTERN( union tree *db_mkbool_tree , (struct tree_list *tree_list , int howfar ) );
RT_EXTERN( union tree *db_mkgift_tree , (struct tree_list *tree_list , int howfar , struct db_tree_state *tsp ) );

a44 283
 *			R T _ C O M B _ V 4 _ I M P O R T
 *
 *  Import a combination record from a V4 database into internal form.
 */
int
rt_comb_v4_import( ip, ep, matrix )
struct rt_db_internal		*ip;
CONST struct bu_external	*ep;
CONST matp_t			matrix;		/* NULL if identity */
{
	union record		*rp;
	struct tree_list	*tree_list;
	union tree		*tree;
	struct rt_comb_internal	*comb;
	int			i,j;
	int			node_count;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;

	if( rp[0].u_id != ID_COMB )
	{
		bu_log( "rt_comb_v4_import: Attempt to import a non-combination\n" );
		return( -1 );
	}

	/* Compute how many granules of MEMBER records follow */
	node_count = ep->ext_nbytes/sizeof( union record ) - 1;

	if( node_count )
		tree_list = (struct tree_list *)rt_calloc( node_count , sizeof( struct tree_list ) , "tree_list" );
	else
		tree_list = (struct tree_list *)NULL;

	for( j=0 ; j<node_count ; j++ )
	{
		if( rp[j+1].u_id != ID_MEMB )
		{
			rt_free( (char *)tree_list , "rt_comb_v4_import: tree_list" );
			bu_log( "rt_comb_v4_import(): granule in external buffer is not ID_MEMB, id=%d\n", rp[j+1].u_id );
			return( -1 );
		}

		switch( rp[j+1].M.m_relation )
		{
			case '+':
				tree_list[j].tl_op = OP_INTERSECT;
				break;
			case '-':
				tree_list[j].tl_op = OP_SUBTRACT;
				break;
			default:
				bu_log("rt_comb_v4_import() unknown op=x%x, assuming UNION\n", rp[j+1].M.m_relation );
				/* Fall through */
			case 'u':
				tree_list[j].tl_op = OP_UNION;
				break;
		}
		/* Build leaf node for in-memory tree */
		{
			union tree		*tp;
			struct tree_db_leaf	*mi;
			mat_t			diskmat;
			char			namebuf[NAMESIZE+2];

			BU_GETUNION( tp, tree );
			tree_list[j].tl_tree = tp;
			tp->tr_l.magic = RT_TREE_MAGIC;
			tp->tr_l.tl_op = OP_DB_LEAF;
			strncpy( namebuf, rp[j+1].M.m_instname, NAMESIZE );
			namebuf[NAMESIZE] = '\0';	/* ensure null term */
			tp->tr_l.tl_name = bu_strdup( namebuf );

			/* See if disk record is identity matrix */
			rt_mat_dbmat( diskmat, rp[j+1].M.m_mat );
			if( mat_is_identity( diskmat ) )  {
				if( matrix == NULL )  {
					tp->tr_l.tl_mat = NULL;	/* identity */
				} else {
					tp->tr_l.tl_mat = mat_dup( matrix );
				}
			} else {
				if( matrix == NULL )  {
					tp->tr_l.tl_mat = mat_dup( diskmat );
				} else {
					mat_t	prod;
					mat_mul( prod, matrix, diskmat );
					tp->tr_l.tl_mat = mat_dup( prod );
				}
			}
/* bu_log("M_name=%s, matp=x%x\n", tp->tr_l.tl_name, tp->tr_l.tl_mat ); */
		}
	}
	if( node_count )
		tree = db_mkgift_tree( tree_list, node_count, (struct db_tree_state *)NULL );
	else
		tree = (union tree *)NULL;

	RT_INIT_DB_INTERNAL( ip );
	ip->idb_type = ID_COMBINATION;
	comb = (struct rt_comb_internal *)rt_malloc( sizeof( struct rt_comb_internal ) , "rt_comb_v4_import: rt_comb_internal" );
	ip->idb_ptr = (genptr_t)comb;
	comb->magic = RT_COMB_MAGIC;
	bu_vls_init( &comb->shader_name );
	bu_vls_init( &comb->shader_param );
	bu_vls_init( &comb->material );
	comb->tree = tree;
	comb->region_flag = (rp[0].c.c_flags == 'R');

	comb->region_id = rp[0].c.c_regionid;
	comb->aircode = rp[0].c.c_aircode;
	comb->GIFTmater = rp[0].c.c_material;
	comb->los = rp[0].c.c_los;

	comb->rgb_valid = rp[0].c.c_override;
	comb->rgb[0] = rp[0].c.c_rgb[0];
	comb->rgb[1] = rp[0].c.c_rgb[1];
	comb->rgb[2] = rp[0].c.c_rgb[2];
	bu_vls_strncpy( &comb->shader_name , rp[0].c.c_matname, 32 );
	bu_vls_strncpy( &comb->shader_param , rp[0].c.c_matparm, 60 );
	/* XXX Separate flags for color inherit, shader inherit, (new) material inherit? */
	/* XXX cf: ma_cinherit, ma_minherit */
	comb->inherit = rp[0].c.c_inherit;
	/* Automatic material table lookup here? */
	bu_vls_printf( &comb->material, "gift%d", comb->GIFTmater );

	return( 0 );
}

/*
 *			R T _ C O M B _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this combination.
 */
void
rt_comb_ifree( ip )
struct rt_db_internal	*ip;
{
	register struct rt_comb_internal	*comb;

	RT_CK_DB_INTERNAL(ip);
	comb = (struct rt_comb_internal *)ip->idb_ptr;
	RT_CK_COMB(comb);

	/* If tree hasn't been stolen, release it */
	if(comb->tree) db_free_tree( comb->tree );
	comb->tree = NULL;

	bu_vls_free( &comb->shader_name );
	bu_vls_free( &comb->shader_param );
	bu_vls_free( &comb->material );

	comb->magic = 0;			/* sanity */
	rt_free( (char *)comb, "comb ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

/*
 *			R T _ G E T _ C O M B
 *
 *  A convenience wrapper to retrive a combination from the database
 *  into internal form.
 *
 *  Returns -
 *	-1	FAIL
 *	 0	OK
 */
int
rt_get_comb( ip, dp, matp, dbip )
struct rt_db_internal	*ip;
CONST struct directory	*dp;
CONST mat_t		*matp;
CONST struct db_i	*dbip;
{
	struct bu_external	ext;

	RT_CK_DIR(dp);
	RT_CHECK_DBI( dbip );

	/* Load the entire combination into contiguous memory */
	BU_INIT_EXTERNAL( &ext );
	if( db_get_external( &ext, dp, dbip ) < 0 )
		return -1;

	/* Switch out to right routine, based on database version */
	if( rt_comb_v4_import( ip, &ext, matp ) < 0 )
		return -1;

	db_free_external( &ext );
	return 0;
}


/* -------------------- */
/* Some export support routines */

/*
 *			D B _ C K _ L E F T _ H E A V Y _ T R E E
 *
 *  Support routine for db_ck_v4gift_tree().
 *  Ensure that the tree below 'tp' is left-heavy, i.e. that there are
 *  nothing but solids on the right side of any binary operations.
 *
 *  Returns -
 *	-1	ERROR
 *	 0	OK
 */
int
db_ck_left_heavy_tree( tp, no_unions )
CONST union tree	*tp;
int			no_unions;
{
	RT_CK_TREE(tp);
	switch( tp->tr_op )  {

	case OP_DB_LEAF:
		break;

	case OP_UNION:
		if( no_unions )  return -1;
		/* else fall through */
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		if( tp->tr_b.tb_right->tr_op != OP_DB_LEAF )
			return -1;
		return db_ck_left_heavy_tree( tp->tr_b.tb_left, no_unions );

	default:
		bu_log("db_ck_left_heavy_tree: bad op %d\n", tp->tr_op);
		rt_bomb("db_ck_left_heavy_tree\n");
	}
	return 0;
}


/*
 *			D B _ C K _ V 4 G I F T _ T R E E
 *
 *  Look a gift-tree in the mouth.
 *  Ensure that this boolean tree conforms to the GIFT convention that
 *  union operations must bind the loosest.
 *  There are two stages to this check:
 *  1)  Ensure that if unions are present they are all at the root of tree,
 *  2)  Ensure non-union children of union nodes are all left-heavy
 *      (nothing but solid nodes permitted on rhs of binary operators).
 *
 *  Returns -
 *	-1	ERROR
 *	 0	OK
 */
int
db_ck_v4gift_tree( tp )
CONST union tree	*tp;
{
	RT_CK_TREE(tp);
	switch( tp->tr_op )  {

	case OP_DB_LEAF:
		break;

	case OP_UNION:
		if( db_ck_v4gift_tree( tp->tr_b.tb_left ) < 0 )
			return -1;
		return db_ck_v4gift_tree( tp->tr_b.tb_right );

	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		return db_ck_left_heavy_tree( tp, 1 );

	default:
		bu_log("db_ck_v4gift_tree: bad op %d\n", tp->tr_op);
		rt_bomb("db_ck_v4gift_tree\n");
	}
	return 0;
}



/* -------------------------------------------------- */

/*
d167 2
a168 1
		} else if( tsp->ts_mater.ma_cinherit == DB_INH_LOWER )  {
d190 2
a191 1
		} else if( tsp->ts_mater.ma_minherit == DB_INH_LOWER )  {
a232 93
db_apply_state_from_memb( tsp, pathp, mp )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
CONST struct member	*mp;
{
	register struct directory *mdp;
	mat_t			xmat;
	mat_t			old_xlate;
	register struct animate *anp;
	char			namebuf[NAMESIZE+2];

	if( mp->m_id != ID_MEMB )  {
		char	*sofar = db_path_to_string(pathp);
		bu_log("db_apply_state_from_memb:  defective member rec in '%s'\n", sofar);
		rt_free(sofar, "path string");
		return(-1);
	}

	/* Trim m_instname, and add to the path */
	strncpy( namebuf, mp->m_instname, NAMESIZE );
	namebuf[NAMESIZE] = '\0';
	if( (mdp = db_lookup( tsp->ts_dbip, namebuf, LOOKUP_NOISY )) == DIR_NULL )
		return(-1);

	db_add_node_to_full_path( pathp, mdp );

	mat_copy( old_xlate, tsp->ts_mat );

	/* convert matrix to fastf_t from disk format */
	rt_mat_dbmat( xmat, mp->m_mat );

	/* Check here for animation to apply */
	if ((mdp->d_animate != ANIM_NULL) && (rt_g.debug & DEBUG_ANIM)) {
		char	*sofar = db_path_to_string(pathp);
		bu_log("Animate %s with...\n", sofar);
		rt_free(sofar, "path string");
	}
	/*
	 *  For each of the animations attached to the mentioned object,
	 *  see if the current accumulated path matches the path
	 *  specified in the animation.
	 *  Comparison is performed right-to-left (from leafward to rootward).
	 */
	for( anp = mdp->d_animate; anp != ANIM_NULL; anp = anp->an_forw ) {
		register int i;
		register int j = pathp->fp_len-1;
		register int anim_flag;
		
		RT_CK_ANIMATE(anp);
		i = anp->an_path.fp_len-1;
		anim_flag = 1;

		if (rt_g.debug & DEBUG_ANIM) {
			char	*str;

			str = db_path_to_string( &(anp->an_path) );
			bu_log( "\t%s\t", str );
			rt_free( str, "path string" );
			bu_log("an_path.fp_len-1:%d  pathp->fp_len-1:%d\n",
				i, j);

		}
		for( ; i>=0 && j>=0; i--, j-- )  {
			if( anp->an_path.fp_names[i] != pathp->fp_names[j] ) {
				if (rt_g.debug & DEBUG_ANIM) {
					bu_log("%s != %s\n",
					     anp->an_path.fp_names[i]->d_namep,
					     pathp->fp_names[j]->d_namep);
				}
				anim_flag = 0;
				break;
			}
		}
		/* Perhaps tsp->ts_mater should be just tsp someday? */
		if (anim_flag)
			db_do_anim( anp, old_xlate, xmat, &(tsp->ts_mater) );
	}

	mat_mul(tsp->ts_mat, old_xlate, xmat);
	return(0);		/* Success */
}

/*
 *			D B _ A P P L Y _ S T A T E _ F R O M _ M E M B
 *
 *  Updates state via *tsp, pushes member's directory entry on *pathp.
 *  (Caller is responsible for popping it).
 *
 *  Returns -
 *	-1	failure
 *	 0	success, member pushed on path
 */
int
a587 125
 *			D B _ M K B O O L _ T R E E
 *
 *  Given a tree_list array, build a tree of "union tree" nodes
 *  appropriately connected together.  Every element of the
 *  tree_list array used is replaced with a TREE_NULL.
 *  Elements which are already TREE_NULL are ignored.
 *  Returns a pointer to the top of the tree.
 */
HIDDEN union tree *
db_mkbool_tree( tree_list, howfar )
struct tree_list *tree_list;
int		howfar;
{
	register struct tree_list *tlp;
	register int		i;
	register struct tree_list *first_tlp = (struct tree_list *)0;
	register union tree	*xtp;
	register union tree	*curtree;
	register int		inuse;

	if( howfar <= 0 )
		return(TREE_NULL);

	/* Count number of non-null sub-trees to do */
	for( i=howfar, inuse=0, tlp=tree_list; i>0; i--, tlp++ )  {
		if( tlp->tl_tree == TREE_NULL )
			continue;
		if( inuse++ == 0 )
			first_tlp = tlp;
	}

	/* Handle trivial cases */
	if( inuse <= 0 )
		return(TREE_NULL);
	if( inuse == 1 )  {
		curtree = first_tlp->tl_tree;
		first_tlp->tl_tree = TREE_NULL;
		return( curtree );
	}

	if( first_tlp->tl_op != OP_UNION )  {
		first_tlp->tl_op = OP_UNION;	/* Fix it */
		if( rt_g.debug & DEBUG_TREEWALK )  {
			bu_log("db_mkbool_tree() WARNING: non-union (%c) first operation ignored\n",
				first_tlp->tl_op );
		}
	}

	curtree = first_tlp->tl_tree;
	first_tlp->tl_tree = TREE_NULL;
	tlp=first_tlp+1;
	for( i=howfar-(tlp-tree_list); i>0; i--, tlp++ )  {
		if( tlp->tl_tree == TREE_NULL )
			continue;

		BU_GETUNION( xtp, tree );
		xtp->magic = RT_TREE_MAGIC;
		xtp->tr_b.tb_left = curtree;
		xtp->tr_b.tb_right = tlp->tl_tree;
		xtp->tr_b.tb_regionp = (struct region *)0;
		xtp->tr_op = tlp->tl_op;
		curtree = xtp;
		tlp->tl_tree = TREE_NULL;	/* empty the input slot */
	}
	return(curtree);
}

/*
 *			D B _ M K G I F T _ T R E E
 */
HIDDEN union tree *
db_mkgift_tree( trees, subtreecount, tsp )
struct tree_list	*trees;
int			subtreecount;
struct db_tree_state	*tsp;
{
	register struct tree_list *tstart;
	register struct tree_list *tnext;
	union tree		*curtree;
	int	i;
	int	j;

	/*
	 * This is how GIFT interpreted equations, so it is duplicated here.
	 * Any expressions between UNIONs are evaluated first.  For example:
	 *		A - B - C u D - E - F
	 * becomes	(A - B - C) u (D - E - F)
	 * so first do the parenthesised parts, and then go
	 * back and glue the unions together.
	 * As always, unions are the downfall of free enterprise!
	 */
	tstart = trees;
	tnext = trees+1;
	for( i=subtreecount-1; i>=0; i--, tnext++ )  {
		/* If we went off end, or hit a union, do it */
		if( i>0 && tnext->tl_op != OP_UNION )
			continue;
		if( (j = tnext-tstart) <= 0 )
			continue;
		curtree = db_mkbool_tree( tstart, j );
		/* db_mkbool_tree() has side effect of zapping tree array,
		 * so build new first node in array.
		 */
		tstart->tl_op = OP_UNION;
		tstart->tl_tree = curtree;

		if(rt_g.debug&DEBUG_TREEWALK)  {
			bu_log("db_mkgift_tree() intermediate term:\n");
			rt_pr_tree(tstart->tl_tree, 0);
		}

		/* tstart here at union */
		tstart = tnext;
	}

final:
	curtree = db_mkbool_tree( trees, subtreecount );
	if(rt_g.debug&DEBUG_TREEWALK)  {
		bu_log("db_mkgift_tree() returns:\n");
		rt_pr_tree(curtree, 0);
	}
	return( curtree );
}

/*
a668 2
	struct tree_list	*tlp;		/* cur elem of trees[] */
	struct tree_list	*trees = TREE_LIST_NULL;	/* array */
a858 1
	if( trees )  rt_free( (char *)trees, "tree_list array" );
@


11.25
log
@Expunged dependence on "union record" for combination handling.
@
text
@a0 2
#define USE_NEW_IMPORT	1

d9 1
a9 1
 *  Authors -
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.24 1996/10/12 03:01:06 mike Exp mike $ (BRL)";
a900 1
#if USE_NEW_IMPORT
a918 41
#else
		/* Apply state changes from new combination */
		if( db_apply_state_from_comb( tsp, pathp, &ext ) < 0 )
			goto fail;

		for( i=1; i < comb_dp->d_len; i++ )  {
			register union record *rp =
				(union record *)ext.ext_buf;
			mp = &(rp[i].M);

			/* If this is not the desired element, skip it */
			if( strncmp( mp->m_instname, cp, sizeof(mp->m_instname)) == 0 )
				goto found_it;
		}
		if(noisy) bu_log("db_follow_path_for_state() ERROR: unable to find '%s/%s'\n", comb_dp->d_namep, cp );
		goto fail;
found_it:
		if( db_apply_state_from_memb( tsp, pathp, mp ) < 0 )  {
			bu_log("db_follow_path_for_state() ERROR: unable to apply member %s state\n", dp->d_namep);
			goto fail;
		}
		/* directory entry was pushed */

		/* If not first element of comb, take note of operation */
		if( i > 1 )  {
			switch( mp->m_relation )  {
			default:
				break;		/* handle as union */
			case UNION:
				break;
			case SUBTRACT:
				tsp->ts_sofar |= TS_SOFAR_MINUS;
				break;
			case INTERSECT:
				tsp->ts_sofar |= TS_SOFAR_INTER;
				break;
			}
		} else {
			/* Handle as a union */
		}
#endif
a1211 3
#if !USE_NEW_IMPORT
		register CONST union record	*rp = (union record *)ext.ext_buf;
#endif
a1218 1
#if USE_NEW_IMPORT
a1229 6
#else
		if( (is_region = db_apply_state_from_comb( &nts, pathp, &ext )) < 0 )  {
			curtree = TREE_NULL;		/* FAIL */
			goto out;
		}
#endif
a1262 58
#if !USE_NEW_IMPORT
		tlp = trees = (struct tree_list *)rt_malloc(
			sizeof(struct tree_list) * (dp->d_len),
			"tree_list array" );

		for( i=1; i < dp->d_len; i++ )  {
			register CONST struct member *mp;
			struct db_tree_state	memb_state;

			memb_state = nts;	/* struct copy */

			mp = &(rp[i].M);

			if( db_apply_state_from_memb( &memb_state, pathp, mp ) < 0 )
				continue;
			/* Member was pushed on pathp stack */

			/* Note & store operation on subtree */
			if( i > 1 )  {
				switch( mp->m_relation )  {
				default:
				bu_log("%s: bad m_relation '%c'\n",
						dp->d_namep, mp->m_relation );
					tlp->tl_op = OP_UNION;
					break;
				case UNION:
					tlp->tl_op = OP_UNION;
					break;
				case SUBTRACT:
					tlp->tl_op = OP_SUBTRACT;
					memb_state.ts_sofar |= TS_SOFAR_MINUS;
					break;
				case INTERSECT:
					tlp->tl_op = OP_INTERSECT;
					memb_state.ts_sofar |= TS_SOFAR_INTER;
					break;
				}
			} else {
				/* Handle first one as union */
				tlp->tl_op = OP_UNION;
			}

			/* Recursive call */
			if( (tlp->tl_tree = db_recurse( &memb_state, pathp, region_start_statepp )) != TREE_NULL )  {
				tlp++;
			}

			DB_FULL_PATH_POP(pathp);
		}
		if( tlp <= trees )  {
			/* No subtrees in this region, invent a NOP */
			BU_GETUNION( curtree, tree );
			curtree->magic = RT_TREE_MAGIC;
			curtree->tr_op = OP_NOP;
		} else {
			curtree = db_mkgift_tree( trees, tlp-trees, tsp );
		}
#else
a1276 1
#endif
a2191 1
#if USE_NEW_IMPORT
a2194 3
#else
	register union record	*rp;
#endif
a2233 1
#if USE_NEW_IMPORT
a2258 31
#else
		if (!(rp= db_getmrec(dbip, parentp))) return 0;
		for (j=1; j< parentp->d_len; j++ ) {
			mat_t xmat;	/* temporary matrix */

			/* search for the right member */
			if (strcmp(kidp->d_namep, rp[j].M.m_instname) != 0) {
				continue;
			}
			/* convert matrix to fastf_t from disk format */
			rt_mat_dbmat( xmat, rp[j].M.m_mat);
			/*
			 * xmat is the matrix from the disk.
			 * mat is the collection of all operations so far.
			 * (Stack)
			 */
			holdlength = pathp->fp_len;
			pathp->fp_len = i+2;
			db_apply_anims(pathp, kidp, mat, xmat, 0);
			pathp->fp_len = holdlength;
			mat_mul(tmat, mat, xmat);
			mat_copy(mat, tmat);
			break;
		}
		if (j >= parentp->d_len) {
			bu_log("db_path_to_mat: unable to follow %s/%s path\n",
			    parentp->d_namep, kidp->d_namep);
			return 0;
		}
		rt_free((char *) rp, "db_path_to_mat recs");
#endif
@


11.24
log
@New import code is working well enough to pass the benchmarks now.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.23 1996/10/05 09:13:54 mike Exp mike $ (BRL)";
d178 2
d215 36
d445 1
a445 1
db_apply_state_from_comb( tsp, pathp, ep )
d448 1
a448 1
CONST struct bu_external	*ep;
d450 1
a450 1
	register CONST union record	*rp;
d452 1
a452 11
	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	if( rp->u_id != ID_COMB )  {
		char	*sofar = db_path_to_string(pathp);
		bu_log("db_apply_state_from_comb() defective record at '%s'\n",
			sofar );
		rt_free(sofar, "path string");
		return(-1);
	}

	if( rp->c.c_override == 1 )  {
d466 1
a466 1
				(((double)(rp->c.c_rgb[0]))*bn_inv255);
d468 1
a468 1
				(((double)(rp->c.c_rgb[1]))*bn_inv255);
d470 2
a471 2
				(((double)(rp->c.c_rgb[2]))*bn_inv255);
			tsp->ts_mater.ma_cinherit = rp->c.c_inherit;
d474 1
a474 1
	if( rp->c.c_matname[0] != '\0' )  {
d486 4
a489 3
			strncpy( tsp->ts_mater.ma_matname, rp->c.c_matname, sizeof(rp->c.c_matname) );
			strncpy( tsp->ts_mater.ma_matparm, rp->c.c_matparm, sizeof(rp->c.c_matparm) );
			tsp->ts_mater.ma_minherit = rp->c.c_inherit;
d494 1
a494 1
	if( rp->c.c_flags == 'R' )  {
d506 4
a509 4
			tsp->ts_regionid = rp->c.c_regionid;
			tsp->ts_aircode = rp->c.c_aircode;
			tsp->ts_gmater = rp->c.c_material;
			tsp->ts_los = rp->c.c_los;
d696 91
d806 2
d903 20
d962 1
d1141 5
d1147 1
a1147 1
recurseit( tp, msp, pathp, region_start_statepp )
d1184 1
d1189 1
a1189 2
		recurseit( tp->tr_b.tb_right, &memb_state, pathp, region_start_statepp );
		recurseit( tp->tr_b.tb_left, &memb_state, pathp, region_start_statepp );
d1193 2
a1194 2
		bu_log("recurseit: bad op %d\n", tp->tr_op);
		rt_bomb("recurseit\n");
d1256 1
d1258 1
d1274 5
a1278 4
#endif

/* XXX USE_NEW_IMPORT */
		/* XXX Can't convert this part yet */
d1283 1
d1380 1
a1380 1
			recurseit( curtree, &nts, pathp, region_start_statepp );
d1554 1
d1701 1
d1804 1
d1844 1
d2125 3
a2281 6
		/* Ensure that rt_g.rtg_parallel is set */
		/* XXX Should actually be done by bu_parallel(). */
		if( rt_g.rtg_parallel == 0 )  {
			bu_log("db_walk_tree() ncpu=%d, rtg_parallel not set!\n", ncpu);
			rt_g.rtg_parallel = 1;
		}
d2305 5
d2311 1
d2316 1
d2351 27
a2380 1
			int holdlength;
d2407 1
@


11.23
log
@Moved rt_comb_internal to raytrace.h
@
text
@d1 1
a1 1
#define USE_NEW_IMPORT	0
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.22 1996/09/27 08:27:30 mike Exp mike $ (BRL)";
d200 2
a201 1
	db_free_tree( comb->tree );
d1026 1
a1026 2
			*subtree = tmp;	/* struct copy */
			db_free_tree( subtree );
d1048 1
d1088 1
d1090 1
d1126 1
d1224 1
d1226 2
d1229 1
d1235 1
d1250 1
@


11.22
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d1 2
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.21 1996/09/27 07:07:47 butler Exp mike $ (BRL)";
a52 24
/*
 *  In-memory format for combination.
 *  (Regions and Groups are both a kind of Combination).
 *  Move to h/wdb.h
 */
struct rt_comb_internal  {
	long		magic;
	union tree	*tree;		/* Leading to tree_db_leaf leaves */
	char		region_flag;	/* !0 ==> this COMB is a REGION */
	/* Begin GIFT compatability */
	short		region_id;
	short		aircode;
	short		GIFTmater;
	short		los;
	/* End GIFT compatability */
	char		rgb_valid;	/* !0 ==> rgb[] has valid color */
	unsigned char	rgb[3];
	struct bu_vls	shader_name;
	struct bu_vls	shader_param;
	struct bu_vls	material;
	char		inherit;
};
#define RT_COMB_MAGIC	0x436f6d49	/* "ComI" */
#define RT_CK_COMB(_p)		NMG_CKMAG( _p , RT_COMB_MAGIC , "rt_comb_internal" )
a53 1

d58 1
a58 1
 *		R T _ C O M B _ V 4 _ I M P O R T
d148 1
a148 1
bu_log("M_name=%s, matp=x%x\n", tp->tr_l.tl_name, tp->tr_l.tl_mat );
d1113 1
a1113 1
#if !1
d1161 1
a1161 1
#if 1
@


11.21
log
@More work to get the bounding box right.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.20 1996/09/18 21:39:43 butler Exp butler $ (BRL)";
d68 3
a70 3
	struct rt_vls	shader_name;
	struct rt_vls	shader_param;
	struct rt_vls	material;
d88 1
a88 1
CONST struct rt_external	*ep;
d98 1
a98 1
	RT_CK_EXTERNAL( ep );
d103 1
a103 1
		rt_log( "rt_comb_v4_import: Attempt to import a non-combination\n" );
d120 1
a120 1
			rt_log( "rt_comb_v4_import(): granule in external buffer is not ID_MEMB, id=%d\n", rp[j+1].u_id );
d133 1
a133 1
				rt_log("rt_comb_v4_import() unknown op=x%x, assuming UNION\n", rp[j+1].M.m_relation );
d146 1
a146 1
			GETUNION( tp, tree );
d152 1
a152 1
			tp->tr_l.tl_name = rt_strdup( namebuf );
d171 1
a171 1
rt_log("M_name=%s, matp=x%x\n", tp->tr_l.tl_name, tp->tr_l.tl_mat );
d184 3
a186 3
	rt_vls_init( &comb->shader_name );
	rt_vls_init( &comb->shader_param );
	rt_vls_init( &comb->material );
d199 2
a200 2
	rt_vls_strncpy( &comb->shader_name , rp[0].c.c_matname, 32 );
	rt_vls_strncpy( &comb->shader_param , rp[0].c.c_matparm, 60 );
d203 1
a203 1
	rt_vls_printf( &comb->material, "gift%d", comb->GIFTmater );
d226 3
a228 3
	rt_vls_free( &comb->shader_name );
	rt_vls_free( &comb->shader_param );
	rt_vls_free( &comb->material );
d271 1
a271 1
		rt_log("db_ck_left_heavy_tree: bad op %d\n", tp->tr_op);
d314 1
a314 1
		rt_log("db_ck_v4gift_tree: bad op %d\n", tp->tr_op);
d337 1
a337 1
	GETSTRUCT( new, combined_tree_state );
d355 1
a355 1
	GETSTRUCT( new, combined_tree_state );
d383 9
a391 9
	rt_log("db_pr_tree_state(x%x):\n", tsp);
	rt_log(" ts_dbip=x%x\n", tsp->ts_dbip);
	rt_printb(" ts_sofar", tsp->ts_sofar, "\020\3REGION\2INTER\1MINUS" );
	rt_log("\n");
	rt_log(" ts_regionid=%d\n", tsp->ts_regionid);
	rt_log(" ts_aircode=%d\n", tsp->ts_aircode);
	rt_log(" ts_gmater=%d\n", tsp->ts_gmater);
	rt_log(" ts_los=%d\n", tsp->ts_los);
	rt_log(" ts_mater.ma_color=%g,%g,%g\n",
d395 2
a396 2
	rt_log(" ts_mater.ma_matname=%s\n", tsp->ts_mater.ma_matname );
	rt_log(" ts_mater.ma_matparam=%s\n", tsp->ts_mater.ma_matparm );
d410 1
a410 1
	rt_log("db_pr_combined_tree_state(x%x):\n", ctsp);
d413 1
a413 1
	rt_log(" path='%s'\n", str);
d432 1
a432 1
CONST struct rt_external	*ep;
d436 1
a436 1
	RT_CK_EXTERNAL( ep );
d440 1
a440 1
		rt_log("db_apply_state_from_comb() defective record at '%s'\n",
d452 1
a452 1
				rt_log("db_apply_state_from_comb(): WARNING: color override in combination within region '%s', ignored\n",
d460 1
a460 1
				(((double)(rp->c.c_rgb[0]))*rt_inv255);
d462 1
a462 1
				(((double)(rp->c.c_rgb[1]))*rt_inv255);
d464 1
a464 1
				(((double)(rp->c.c_rgb[2]))*rt_inv255);
d474 1
a474 1
				rt_log("db_apply_state_from_comb(): WARNING: material property spec in combination within region '%s', ignored\n",
d491 1
a491 1
				rt_log("Warning:  region unioned into region at '%s', lower region info ignored\n",
d533 1
a533 1
		rt_log("db_apply_state_from_memb:  defective member rec in '%s'\n", sofar);
d554 1
a554 1
		rt_log("Animate %s with...\n", sofar);
d576 1
a576 1
			rt_log( "\t%s\t", str );
d578 1
a578 1
			rt_log("an_path.fp_len-1:%d  pathp->fp_len-1:%d\n",
d585 1
a585 1
					rt_log("%s != %s\n",
d639 1
a639 1
		rt_log("Animate %s with...\n", sofar);
d661 1
a661 1
			rt_log( "\t%s\t", str );
d663 1
a663 1
			rt_log("an_path.fp_len-1:%d  pathp->fp_len-1:%d\n",
d670 1
a670 1
					rt_log("%s != %s\n",
d707 1
a707 1
	struct rt_external	ext;
d722 1
a722 1
		rt_log("db_follow_path_for_state() pathp='%s', tsp=x%x, orig_str='%s', noisy=%d\n",
d729 2
a730 2
	RT_INIT_EXTERNAL( &ext );
	cp = str = rt_strdup( orig_str );
d796 1
a796 1
			rt_log("db_follow_path_for_state() at %s/%s\n", comb_dp->d_namep, dp->d_namep );
d816 1
a816 1
		if(noisy) rt_log("db_follow_path_for_state() ERROR: unable to find '%s/%s'\n", comb_dp->d_namep, cp );
d820 1
a820 1
			rt_log("db_follow_path_for_state() ERROR: unable to apply member %s state\n", dp->d_namep);
d856 1
a856 1
				rt_log("db_follow_path_for_state(%s) ERROR: found leaf early at '%s'\n",
d867 1
a867 1
				rt_log("db_follow_path_for_state(%s) ERROR: combination '%s' has no members\n",
d880 1
a880 1
	rt_free( str, "rt_strdup (dup'ed path)" );
d883 1
a883 1
		rt_log("db_follow_path_for_state() returns pathp='%s'\n",
d890 1
a890 1
	rt_free( str, "rt_strdup (dup'ed path)" );
d939 1
a939 1
			rt_log("db_mkbool_tree() WARNING: non-union (%c) first operation ignored\n",
d951 1
a951 1
		GETUNION( xtp, tree );
d1003 1
a1003 1
			rt_log("db_mkgift_tree() intermediate term:\n");
d1014 1
a1014 1
		rt_log("db_mkgift_tree() returns:\n");
d1068 1
a1068 1
		rt_log("recurseit: bad op %d\n", tp->tr_op);
d1094 1
a1094 1
	struct rt_external	ext;
d1106 1
a1106 1
		rt_log("db_recurse() null path?\n");
d1112 1
a1112 1
		rt_log("db_recurse() pathp='%s', tsp=x%x, *statepp=x%x\n",
d1123 1
a1123 1
		rt_log("db_recurse() db_get_external() FAIL\n");
d1138 1
a1138 1
			rt_log("db_recurse() import of %s failed\n", dp->d_namep);
d1171 1
a1171 1
				rt_log("db_recurse() ERROR at start of a region, *region_start_statepp = x%x\n",
d1179 1
a1179 1
				rt_log("setting *region_start_statepp to x%x\n", ctsp );
d1205 1
a1205 1
				rt_log("%s: bad m_relation '%c'\n",
d1235 1
a1235 1
			GETUNION( curtree, tree );
d1247 1
a1247 1
			GETUNION( curtree, tree );
d1271 1
a1271 1
			rt_log("db_recurse(%s): defective database record, addr=x%x\n",
d1292 1
a1292 1
			rt_log("db_recurse(%s):  matrix does not preserve axis perpendicularity.\n  X.Y=%g, Y.Z=%g, X.Z=%g\n",
d1309 1
a1309 1
				rt_log("db_recurse(%s) ERROR at start of a region (bare solid), *region_start_statepp = x%x\n",
d1315 1
a1315 1
			    	rt_log("WARNING: db_recurse(): solid '%s' not contained in a region\n",
d1323 1
a1323 1
				rt_log("db_recurse(%s): setting *region_start_statepp to x%x (bare solid)\n",
d1338 1
a1338 1
		rt_log("db_recurse:  %s is neither COMB nor SOLID?\n",
d1348 1
a1348 1
		rt_log("db_recurse() return curtree=x%x, pathp='%s', *statepp=x%x\n",
d1367 1
a1367 1
	GETUNION( new, tree );
d1397 1
a1397 1
		rt_log("db_dup_subtree: bad op %d\n", tp->tr_op);
d1440 1
a1440 1
		rt_log("db_ck_tree: bad op %d\n", tp->tr_op);
d1490 1
a1490 1
				rt_log("db_free_tree: OP_NMG_TESS, r = -1, skipping\n");
d1493 1
a1493 1
				rt_log("db_free_tree: OP_NMG_TESS, bad magic x%x (s/b x%x), skipping\n",
d1537 1
a1537 1
		rt_log("db_free_tree: bad op %d\n", tp->tr_op);
d1597 1
a1597 1
		GETUNION( rhs, tree );
d1644 1
a1644 1
    	rt_log("db_non_union_push() ERROR tree op=%d.?\n", tp->tr_op );
d1683 1
a1683 1
		rt_log("db_count_subtree_regions: bad op %d\n", tp->tr_op);
d1721 1
a1721 1
		rt_log("db_count_subtree_regions: bad op %d\n", tp->tr_op);
d1748 1
a1748 1
		GETUNION( new, tree );
d1767 1
a1767 1
		GETUNION( new, tree );
d1774 1
a1774 1
		rt_log("db_tally_subtree_regions: bad op %d\n", tp->tr_op);
d1791 1
a1791 1
	GETUNION( curtree, tree );
d1802 1
a1802 1
struct rt_external	*ext;
d1810 1
a1810 1
	GETUNION( curtree, tree );
d1848 1
a1848 1
			rt_log("db_walk_subtree() REGION with null path?\n");
d1874 1
a1874 1
			rt_log("db_walk_subtree() FAIL on '%s'\n", str);
d1905 1
a1905 1
		rt_log("db_walk_subtree: bad op\n", tp->tr_op);
d1935 1
a1935 1
			rt_log("\n\n***** db_walk_dispatcher() on item %d\n\n", mine );
d1951 1
a1951 1
			rt_log("ERROR: db_walk_dispatcher() region %d started with no state\n", mine);
d1984 1
a1984 1
 *	RES_INIT() functions have been performed, first.
d2050 1
a2050 1
			rt_log("tree after db_recurse():\n");
d2059 1
a2059 1
			GETUNION( new, tree );
d2076 1
a2076 1
		rt_log("tree after db_non_union_push():\n");
d2099 1
a2099 1
		rt_log("%d waiting regions:\n", new_reg_count);
d2106 1
a2106 1
				rt_log("%d: NULL\n", i);
d2111 1
a2111 1
				rt_log("%d: op=%\n", i, treep->tr_op);
d2117 1
a2117 1
			rt_log("%d '%s'\n", i, str);
d2120 1
a2120 1
		rt_log("end of waiting regions\n");
d2137 1
a2137 1
		/* XXX Should actually be done by rt_parallel(). */
d2139 1
a2139 1
			rt_log("db_walk_tree() ncpu=%d, rtg_parallel not set!\n", ncpu);
d2142 1
a2142 1
		rt_parallel( db_walk_dispatcher, ncpu );
d2198 1
a2198 1
			rt_log("db_path_to_mat: '%s' of '%s' not a combination.\n",
d2229 1
a2229 1
			rt_log("db_path_to_mat: unable to follow %s/%s path\n",
d2256 1
a2256 1
		rt_log("Animate %s with...\n", sofar);
d2280 1
a2280 1
			rt_log( "\t%s\t", str );
d2287 1
a2287 1
					rt_log("%s != %s\n",
d2321 1
a2321 1
		rt_log("db_string_to_path(%s) error\n", name);
d2326 1
a2326 1
		rt_log("db_path_to_mat(%s) error", name);
@


11.20
log
@made db_shader_mat return matrix that maps model into region and thence
onto unit cube.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.19 1996/09/17 04:36:36 butler Exp butler $ (BRL)";
d2349 1
a2349 1
db_shader_mat(model_to_shader, dbip, rp)
d2351 1
a2351 1
CONST struct db_i *dbip;
d2353 2
d2359 9
a2367 3
	mat_t	tmp;
	vect_t	m_bb_min, m_bb_max, v_tmp, r_bb_min, r_bb_max;

d2369 1
a2369 1
	db_region_mat(model_to_region, dbip, rp->reg_name);
d2371 4
a2374 10
	/*
	 * Obtain region bounding box
	 */
	VSETALL(m_bb_max, -INFINITY);
	VSETALL(m_bb_min, INFINITY);
	rt_bound_tree(rp->reg_treetop, m_bb_min, m_bb_max);

	/* convert bb values to "region" coordinates */
	MAT4X3PNT(r_bb_min, model_to_region, m_bb_min)
	MAT4X3PNT(r_bb_max, model_to_region, m_bb_max)
d2376 18
d2398 1
a2398 1
	VSCALE(v_tmp, r_bb_min, -1);
d2400 2
a2401 1
	mat_mul(tmp, m_xlate, model_to_region);
d2406 1
a2406 1
	VSUB2(v_tmp, r_bb_max, r_bb_min);
d2410 1
a2410 1
	mat_mul(model_to_shader, m_scale, tmp);
@


11.19
log
@fixed mat_mul() call in db_shader_mat()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.18 1996/08/13 13:42:09 cnuzman Exp butler $ (BRL)";
d2307 1
a2307 1
 *     into "region" coordinates.
d2340 7
a2346 3
 *	Given a region, return a matrix which maps model coordinates into
 *	region "shader space".  This is a space where the bounding box
 *	of the region in region space is mapped into the unit cube
d2355 2
d2358 1
a2358 1
	vect_t	bb_min, bb_max, v_tmp;
d2363 2
a2364 3
	/* 
	 * scale space so that the range 0..1 in shader space covers 
	 * the region bounding box exactly
d2366 7
d2374 7
a2380 3
	VSETALL(bb_max, -INFINITY);
	VSETALL(bb_min, INFINITY);
	rt_bound_tree(rp->reg_treetop, bb_min, bb_max);
d2382 4
a2385 1
	VSUB2(v_tmp, bb_max, bb_min);
d2387 3
a2389 3
	mat_idn(tmp);
	MAT_SCALE_VEC(tmp, v_tmp);
	mat_mul(model_to_shader, tmp, model_to_region);
@


11.18
log
@fixed db_follow_path_for_state bug; now leaf nodes can be animated
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.17 1996/07/04 03:43:30 mike Exp cnuzman $ (BRL)";
a2353 1

d2370 1
a2370 1
	mat_mul(model_to_shader, model_to_region, tmp);
@


11.17
log
@Partial conversion to new v4 import routine
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.16 1996/07/04 02:42:50 mike Exp mike $ (BRL)";
d767 2
a770 2
		db_add_node_to_full_path( pathp, dp );

d848 1
a848 1
			db_add_node_to_full_path( pathp, dp );
@


11.16
log
@Added v4_import routine.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.15 1996/07/04 01:55:12 mike Exp mike $ (BRL)";
d603 86
d1020 54
d1095 1
d1103 1
d1129 1
d1136 11
d1184 1
d1241 11
d1343 1
d1353 1
@


11.15
log
@Removed "pure_boolean_expressions" flag variable.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.14 1996/07/03 04:04:58 mike Exp mike $ (BRL)";
d48 275
@


11.14
log
@Fixed log messages
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.13 1996/07/02 05:54:41 mike Exp mike $ (BRL)";
a42 2
extern int	rt_pure_boolean_expressions;		/* from tree.c */

a615 3

	/* Build tree representing boolean expression in Member records */
	if( rt_pure_boolean_expressions )  goto final;
@


11.13
log
@Added support for OP_DB_LEAF
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.12 1996/04/22 12:09:45 jra Exp mike $ (BRL)";
d835 1
a835 1
			rt_log("db_functree(%s): defective database record, addr=x%x\n",
d856 1
a856 1
			rt_log("db_functree(%s):  matrix does not preserve axis perpendicularity.\n  X.Y=%g, Y.Z=%g, X.Z=%g\n",
d902 1
a902 1
		rt_log("db_functree:  %s is neither COMB nor SOLID?\n",
@


11.12
log
@Added check for region before freeing sub-trees.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.11 1996/01/05 23:25:24 butler Exp jra $ (BRL)";
d1066 9
@


11.11
log
@fixed order of matricies in db_shader_mat()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.10 1996/01/04 23:44:18 butler Exp butler $ (BRL)";
d1050 1
d1058 3
d1071 2
a1072 1
		db_free_tree( tp->tr_b.tb_left );
d1081 2
a1082 1
		db_free_tree( tp->tr_b.tb_left );
d1084 2
a1085 1
		db_free_tree( tp->tr_b.tb_right );
@


11.10
log
@added db_shader_mat()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.9 1995/11/07 16:32:53 adam Exp butler $ (BRL)";
d1884 1
a1884 1
/*		D B _ M O D E L _ T O _ S H A D E R _ M A T
d1917 1
a1917 1
	mat_mul(model_to_shader, tmp, model_to_region);
@


11.9
log
@Matching malloc and free messages -- rt_strdup (dup'ed path)
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/db_tree.c,v 11.8 1995/09/15 23:21:43 mike Exp $ (BRL)";
d1719 5
d1737 1
a1737 1
	if (depth == 1) return 1;
d1880 38
@


11.8
log
@Added pointer check
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/db_tree.c,v 11.7 1995/07/28 00:55:22 mike Exp mike $ (BRL)";
d305 3
d310 1
a310 1
			if( anp->an_path.fp_names[i] != pathp->fp_names[j] )  {
d521 1
a521 1
	rt_free( str, "dupped path" );
d531 1
a531 1
	rt_free( str, "dupped path" );
@


11.7
log
@Moved db_full_path_init to db_path.c
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/db_tree.c,v 11.6 1995/07/27 21:47:29 mike Exp mike $ (BRL)";
d356 1
@


11.6
log
@Specifying db_reg_end_func pointer is optional.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.5 1995/06/13 21:24:39 butler Exp mike $ (BRL)";
a51 13
 *			D B _ F U L L _ P A T H _ I N I T
 */
void
db_full_path_init( pathp )
struct db_full_path	*pathp;
{
	pathp->fp_len = 0;
	pathp->fp_maxlen = 0;
	pathp->fp_names = (struct directory **)NULL;
	pathp->magic = DB_FULL_PATH_MAGIC;
}

/*
d1839 1
d1841 1
a1845 1

@


11.5
log
@added db_region_mat() function call to get model_to_region matrix
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.4 1995/06/02 02:19:40 mike Exp butler $ (BRL)";
d1521 6
a1526 4
		db_reg_trees[mine] = (*db_reg_end_func)(
			&(region_start_statep->cts_s),
			&(region_start_statep->cts_p),
			curtree );
@


11.4
log
@Added comments
@
text
@d7 1
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.3 1995/02/17 04:00:28 mike Exp mike $ (BRL)";
d1849 32
@


11.3
log
@Don't complain on NULL nmgregion pointers any longer.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.2 95/02/17 02:44:56 mike Exp Locker: mike $ (BRL)";
d1707 3
d1785 3
@


11.2
log
@Changed return code of nmg_booltree_evaluate() to facilitate printing
the heritage of the boolean operations.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 11.1 95/01/04 09:56:19 mike Rel4_4 Locker: mike $ (BRL)";
a1051 1
				rt_log("db_free_tree: OP_NMG_TESS, r=NULL\n");
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.15 95/01/04 07:06:11 mike Exp $ (BRL)";
d1047 4
@


10.15
log
@A fruitless attempt to reorganize the code to avoid a VAX optimizer bug:
"../librt/db_tree.c", line 925: compiler error: schain botch
Recompiling without optimization seems to work fine.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.14 94/08/10 18:11:44 gdurf Exp Locker: mike $ (BRL)";
@


10.14
log
@Factored ifdefs
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.13 1994/05/10 11:04:17 mike Exp gdurf $ (BRL)";
d693 1
a693 1
	register int		i;
d731 4
a734 2
		if( (is_region = db_apply_state_from_comb( &nts, pathp, &ext )) < 0 )
			goto fail;
d744 4
a747 2
			    tsp->ts_region_start_func( &nts, pathp ) < 0 )
				goto fail;
d757 2
a758 1
				goto fail;
d846 2
a847 1
			goto fail;
d867 2
a868 1
			goto fail;
d883 2
a884 1
				goto fail;
d903 4
a906 1
		if( !tsp->ts_leaf_func )  goto fail;
a924 3
fail:
	curtree = TREE_NULL;
	goto out;
@


10.13
log
@Added magic numbers to union tree structures.
Added db_ck_tree() routine.
Added rt_free_soltab().
Rearranged rt_clean() to not trash soltab structures.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.12 94/05/04 07:13:52 mike Exp Locker: mike $ (BRL)";
d24 2
d28 3
a30 1
#ifdef BSD
a31 2
#else
#include <string.h>
@


10.12
log
@Added db_full_path_init(), and some magic number checking.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.11 94/04/07 23:02:38 cjohnson Exp Locker: mike $ (BRL)";
d599 1
d812 1
d826 1
d895 1
d926 1
d964 42
d1015 1
a1015 1

a1022 5
			/* XXX If solid is used multiple times,
			 * XXX the pointer may now be bogus.
			 * XXX rt_free() will smash magic number to -1.
			 */
			if( stp->l.magic == -1 )  break;	/* XXX */
a1023 2
			RT_LIST_DEQUEUE( &(stp->l) );
			rt_free( (char *)stp, "(union tree) solid" );
d1025 1
d1097 1
a1097 1

d1199 1
d1239 1
d1280 1
d1333 1
d1352 1
d1366 3
d1378 1
d1480 1
d1490 1
a1490 1

d1587 1
d1599 1
d1648 1
@


10.11
log
@C allows the most interesting typos to compile.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.10 1994/04/05 02:14:51 cjohnson Exp cjohnson $ (BRL)";
d49 13
d71 3
d77 1
d95 1
d366 1
d696 2
d1285 3
d1303 3
d1507 1
a1507 1
		path.fp_len = path.fp_maxlen = 0;
@


10.10
log
@Add new routines to process paths with animation structures.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.9 1994/04/01 18:03:06 cjohnson Exp cjohnson $ (BRL)";
d1643 1
a1643 1
	for (i=0; i < i< depth; i++) {
@


10.9
log
@Used a pointer before it was checked.
@
text
@d6 1
a7 1
 *
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.8 1994/03/31 23:49:17 cjohnson Exp cjohnson $ (BRL)";
d1611 137
@


10.8
log
@Add magic number checks for struct animate
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.7 1993/11/13 00:20:09 mike Exp cjohnson $ (BRL)";
d283 1
a283 1
		register int i = anp->an_path.fp_len-1;
d288 1
@


10.7
log
@Made memory freeing less aggressive.  If the magic number is invalid,
in db_free_tree, skip that item, rather than bombing.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.6 93/10/22 18:42:07 cjohnson Exp Locker: mike $ (BRL)";
d287 1
d384 1
@


10.6
log
@nmg.h must come before raytrace.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.5 1993/03/18 15:28:22 mike Exp cjohnson $ (BRL)";
d972 4
d982 4
@


10.5
log
@Don't nmg_km(), nmg_kr().
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.4 93/01/20 14:07:33 mike Exp Locker: mike $ (BRL)";
d35 1
a36 1
#include "nmg.h"
@


10.4
log
@Added "bad op" printfs.
Added support for OP_NMG_TESS.  It *shouldn't* turn up here,
but the g-jack converter sometimes leaves them around when
using the longjmp error recovery strategy.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.3 92/11/11 00:05:41 mike Exp Locker: mike $ (BRL)";
d972 4
a975 1
			struct model	*m;
d980 1
a980 3
				m = r->m_p;
				NMG_CK_MODEL(m);
				nmg_km(m);
@


10.3
log
@Silenced inappropriate warnings when subtracting or intersecting a
region from the current region.  This is permitted.
Warnings will only occur on unions.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.2 92/10/27 16:23:55 mike Exp Locker: mike $ (BRL)";
d36 1
d928 2
a929 1
		rt_bomb("db_dup_subtree: bad op\n");
d969 16
d1004 2
a1005 1
		rt_bomb("db_free_tree: bad op\n");
d1149 2
a1150 1
		rt_bomb("db_count_subtree_regions: bad op\n");
d1186 2
a1187 1
		rt_bomb("db_count_subtree_regions: bad op\n");
d1238 2
a1239 1
		rt_bomb("db_tally_subtree_regions: bad op\n");
d1357 2
a1358 1
		rt_bomb("db_walk_subtree: bad op\n");
@


10.2
log
@Don't db_recurse() into PHONY solids.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 10.1 91/10/12 06:40:05 mike Rel4_0 Locker: mike $ (BRL)";
d166 3
a168 2
			/* This combination is within a region */
			char	*sofar = db_path_to_string(pathp);
d170 5
a174 3
			rt_log("db_apply_state_from_comb(): WARNING: color override in combination within region '%s', ignored\n",
				sofar );
			rt_free(sofar, "path string");
d188 3
a190 2
			/* This combination is within a region */
			char	*sofar = db_path_to_string(pathp);
d192 5
a196 3
			rt_log("db_apply_state_from_comb(): WARNING: material property spec in combination within region '%s', ignored\n",
				sofar );
			rt_free(sofar, "path string");
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.44 91/10/10 22:22:58 mike Exp $ (BRL)";
d683 1
@


1.44
log
@Tentative fix to multiple-freeing of struct soltab.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.43 91/09/19 15:48:07 mike Exp Locker: mike $ (BRL)";
@


1.43
log
@Fixed initialization, noted by the XMP
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.42 91/08/29 19:45:58 mike Exp $ (BRL)";
d943 5
@


1.42
log
@ANSI cast
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.41 91/07/25 01:42:14 mike Exp $ (BRL)";
d354 1
@


1.41
log
@Fixed problem reported by PJT, wherein the mged command
"e all.g/box.r" would not detect the transformation on that arc.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.40 91/07/16 22:23:17 mike Exp $ (BRL)";
d174 6
a179 3
			tsp->ts_mater.ma_color[0] = (rp->c.c_rgb[0])*rt_inv255;
			tsp->ts_mater.ma_color[1] = (rp->c.c_rgb[1])*rt_inv255;
			tsp->ts_mater.ma_color[2] = (rp->c.c_rgb[2])*rt_inv255;
@


1.40
log
@Fixed db_mkbool_tree() to not dereference null pointer.
Alas, this was not the cause of the current problem.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.39 91/07/16 21:55:42 mike Exp $ (BRL)";
d115 1
d242 1
a242 1
		rt_log("db_follow_path_for_state:  defective member rec in '%s'\n", sofar);
d348 2
a349 2
	/*  Handle each path element */
	if( pathp->fp_len > 0 )
d351 3
a353 3
	else
		comb_dp = DIR_NULL;
	do  {
d366 4
a369 3
		/* If first element, push it, and go on */
		if( pathp->fp_len <= 0 )  {
			db_add_node_to_full_path( pathp, dp );
d371 7
a377 13
			/* Process animations located at the root */
			if( tsp->ts_dbip->dbi_anroot )  {
				register struct animate *anp;
				mat_t	old_xlate, xmat;

				for( anp=tsp->ts_dbip->dbi_anroot; anp != ANIM_NULL; anp = anp->an_forw ) {
					if( dp != anp->an_path.fp_names[0] )
						continue;
					mat_copy( old_xlate, tsp->ts_mat );
					mat_idn( xmat );
					db_do_anim( anp, old_xlate, xmat, &(tsp->ts_mater) );
					mat_mul( tsp->ts_mat, old_xlate, xmat );
				}
a378 5

			/* Advance to next path element */
			cp = ep+1;
			comb_dp = dp;
			continue;
d381 25
a405 14
		if( (dp->d_flags & DIR_COMB) == 0 )  {
			/* Object is a leaf */
			db_add_node_to_full_path( pathp, dp );
			if( oldc == '\0' )  {
				/* No more path was given, all is well */
				goto out;
			}
			/* Additional path was given, this is wrong */
			if( noisy )  {
				char	*sofar = db_path_to_string(pathp);
				rt_log("db_follow_path_for_state(%s) ERROR: found leaf early at '%s'\n",
					cp, sofar );
				rt_free(sofar, "path string");
			}
a406 1
		}
d408 3
a410 8
		/* Object is a combination */
		if( dp->d_len <= 1 )  {
			/* Combination has no members */
			if( noisy )  {
				rt_log("db_follow_path_for_state(%s) ERROR: combination '%s' has no members\n",
					cp, dp->d_namep );
			}
			goto fail;
d430 1
a430 1
		if(noisy) rt_log("db_follow_path_for_state() ERROR: unable to find element '%s'\n", cp );
d433 2
a434 1
		if( db_apply_state_from_memb( tsp, pathp, mp ) < 0 )
d436 1
a455 1

d458 29
d744 1
a744 1
					rt_log("%s: bad m_relation '%c'\n",
@


1.39
log
@Added db_count_tree_nodes().
Shortened a debugging print
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.38 91/07/16 00:43:48 mike Exp $ (BRL)";
a513 7
	if( first_tlp->tl_op != OP_UNION )  {
		first_tlp->tl_op = OP_UNION;	/* Fix it */
		if( rt_g.debug & DEBUG_TREEWALK )  {
			rt_log("db_mkbool_tree() WARNING: non-union (%c) first operation ignored\n",
				first_tlp->tl_op );
		}
	}
d524 8
d653 2
a654 1
	if( db_get_external( &ext, dp, tsp->ts_dbip ) < 0 )
d656 1
@


1.38
log
@Improved error message
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.37 91/07/16 00:04:19 mike Exp $ (BRL)";
d1051 40
d1495 1
a1495 1
			rt_log("%d: path='%s'\n", i, str);
d1498 1
@


1.37
log
@Fix for Butler's invisible lights dumping core bug.
When freeing an OP_SOLID leaf, need to dequeue the solid before freeing it!
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.36 91/07/08 16:12:38 butler Exp $ (BRL)";
d1217 5
a1221 1
			rt_log("db_walk_subtree()/db_recurse() FAIL\n");
@


1.36
log
@restructured db_apply_state_from_memb() to work around compiler problem
on the VAX.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.35 91/07/05 21:25:27 mike Exp $ (BRL)";
d909 4
a912 1
			rt_free( (char *)tp->tr_a.tu_stp, "(union tree) solid" );
@


1.35
log
@Added comment
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.34 91/07/05 21:07:38 mike Exp $ (BRL)";
d274 3
d292 2
a293 1
				goto next_one;
d297 2
a298 2
		db_do_anim( anp, old_xlate, xmat, &(tsp->ts_mater) );
next_one:	;
@


1.34
log
@Added bounds checking on reg_trees[].
Changed from malloc to calloc for reg_trees[], so that unfilled entries
would become NULL.
Fixed bug where return from db_tally_subtree_regions() was ignored;
under certain circumstances (bad solids, empty regions, etc),
there may be fewer regions to operate on than expected.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.33 91/06/29 22:13:51 mike Exp $ (BRL)";
d942 5
@


1.33
log
@ANSI lint
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.32 91/06/29 17:08:30 mike Exp $ (BRL)";
d1078 1
a1078 1
db_tally_subtree_regions( tp, reg_trees, cur )
d1082 1
d1086 2
d1102 2
a1103 2
		cur = db_tally_subtree_regions( tp->tr_b.tb_left, reg_trees, cur );
		cur = db_tally_subtree_regions( tp->tr_b.tb_right, reg_trees, cur );
d1408 4
a1411 3
	reg_trees = (union tree **)rt_malloc( sizeof(union tree *) * new_reg_count,
		"*reg_trees[]" );
	(void)db_tally_subtree_regions( whole_tree, reg_trees, 0 );
@


1.32
log
@Fixed bug will null subtrees.
Cutaway views should again work.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.31 91/06/25 06:30:30 mike Exp $ (BRL)";
d99 1
a99 1
register struct db_tree_state	*tsp;
d122 1
a122 1
register struct combined_tree_state	*ctsp;
d147 3
a149 3
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_external	*ep;
d151 1
a151 1
	register union record	*rp;
d231 1
a231 1
struct member		*mp;
d317 1
a317 1
char			*orig_str;
d652 1
a652 1
		register union record	*rp = (union record *)ext.ext_buf;
d696 1
a696 1
			register struct member *mp;
d849 1
a849 1
union tree	*tp;
d1043 1
a1043 1
union tree	*tp;
d1316 1
a1316 1
char		**argv;
d1318 1
a1318 1
struct db_tree_state *init_state;
@


1.31
log
@A bit more rigor when allocating struct combined_tree_state's
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.30 91/06/25 03:58:27 mike Exp $ (BRL)";
d77 1
a77 1
	db_dup_full_path( &(new->cts_p), &(new->cts_p) );
d1177 8
d1262 3
a1266 2
		if( (curtree = db_reg_trees[mine]) == TREE_NULL )
			continue;
d1274 6
a1279 2
		if( !region_start_statep )
			rt_bomb("ERROR db_walk_dispatcher() region started with no state?\n");
d1346 4
@


1.30
log
@Improved debugging messages.  Print waiting region names,
rather than the whole bloody subtree.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.29 91/06/24 23:43:52 mike Exp $ (BRL)";
d47 9
d57 7
d65 17
d88 1
d126 1
d683 1
a683 3
			GETSTRUCT( ctsp, combined_tree_state );
			ctsp->cts_s = nts;	/* struct copy */
			db_dup_full_path( &(ctsp->cts_p), pathp );
d809 1
a809 2
			GETSTRUCT( ctsp, combined_tree_state );
			ctsp->cts_s = *tsp;	/* struct copy */
a810 1
			db_dup_full_path( &(ctsp->cts_p), pathp );
d863 2
a864 9
		{
			struct combined_tree_state	*cts;
			struct combined_tree_state	*ots;
			ots = (struct combined_tree_state *)tp->tr_a.tu_stp;
			GETSTRUCT( cts, combined_tree_state );
			cts->cts_s = ots->cts_s;	/* struct copy */
			db_dup_full_path( &(cts->cts_p), &(ots->cts_p) );
			new->tr_a.tu_stp = (struct soltab *)cts;
		}
d911 2
a912 4
		if( tp->tr_a.tu_stp )  {
			db_free_combined_tree_state(
				(struct combined_tree_state *)tp->tr_a.tu_stp );
		}
a1128 1
	register struct combined_tree_state	*cts;
a1129 4
	GETSTRUCT( cts, combined_tree_state );
	cts->cts_s = *tsp;	/* struct copy */
	db_dup_full_path( &(cts->cts_p), pathp );

d1132 1
a1132 3
	curtree->tr_a.tu_stp = (struct soltab *)cts;
	curtree->tr_a.tu_name = (char *)0;
	curtree->tr_regionp = (struct region *)0;
a1142 1
	register struct combined_tree_state	*cts;
a1144 4
	GETSTRUCT( cts, combined_tree_state );
	cts->cts_s = *tsp;	/* struct copy */
	db_dup_full_path( &(cts->cts_p), pathp );

d1147 1
a1147 3
	curtree->tr_a.tu_stp = (struct soltab *)cts;
	curtree->tr_a.tu_name = (char *)0;
	curtree->tr_regionp = (struct region *)0;
d1175 2
a1176 1
		ctsp = (struct combined_tree_state *)tp->tr_a.tu_stp;
d1267 1
d1415 2
a1416 1
			ctsp = (struct combined_tree_state *)treep->tr_a.tu_stp;
@


1.29
log
@Needed to modify support routines to know about OP_NOP nodes
as region treetops.  They represent empty regions.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.28 91/06/11 01:32:56 mike Exp $ (BRL)";
a1101 7
static struct db_i	*db_dbip;
static union tree	**db_reg_trees;
static int		db_reg_count;
static int		db_reg_current;		/* semaphored when parallel */
static union tree *	(*db_reg_end_func)();
static union tree *	(*db_reg_leaf_func)();

d1144 9
a1152 2
void
db_walk_subtree( tp, region_start_statepp )
d1155 1
d1174 2
a1175 2
		/* Use user's leaf function. Import via static global */
		ctsp->cts_s.ts_leaf_func = db_reg_leaf_func;
d1201 1
a1201 1
		db_walk_subtree( tp->tr_b.tb_left, region_start_statepp );
d1209 2
a1210 2
		db_walk_subtree( tp->tr_b.tb_left, region_start_statepp );
		db_walk_subtree( tp->tr_b.tb_right, region_start_statepp );
d1249 1
a1249 1
		db_walk_subtree( curtree, &region_start_statep );
a1381 8
	if( rt_g.debug&DEBUG_TREEWALK )  {
		rt_log("new region count=%d\n", new_reg_count);
		for( i=0; i<new_reg_count; i++ )  {
			rt_log("tree %d =\n", i);
			rt_pr_tree( reg_trees[i], 0 );
		}
	}

d1389 23
d1418 1
a1418 1
	db_reg_current = 0;
@


1.28
log
@Modified to allow regions with zero members (leaves) to still be seen
and processed by higher level routines, without any warnings from
this level.
This is important for VDECK to be able to produce the correct output
when empty regions are found, since an empty region may still have
associated code numbers.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.27 91/05/23 10:38:21 jehunt Exp $ (BRL)";
d826 1
d923 1
a923 1
union tree	*tp;
d927 5
a931 2
	/* If this is a leaf, done */
	if( tp->tr_op == OP_REGION || tp->tr_op == OP_SOLID )  return;
d933 6
a938 2
	/* This node is known to be a binary op */
	if( tp->tr_op == OP_UNION )  {
d1042 1
d1064 3
d1153 1
a1153 1
union tree	*tp;
d1160 3
@


1.27
log
@got the LOS value from the model db to the db_tree_state data structure
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.26 91/01/28 16:21:45 butler Exp $ (BRL)";
a620 6
		if( dp->d_len <= 1 )  {
			rt_log("Warning: combination with zero members \"%s\".\n",
				dp->d_namep );
			goto fail;
		}

d659 1
a659 1
			sizeof(struct tree_list) * (dp->d_len-1),
d707 5
a711 2
			/* No subtrees */
			goto fail;
a713 2
		curtree = db_mkgift_tree( trees, tlp-trees, tsp );

d719 1
a719 1
			if( tsp->ts_region_end_func )
d722 1
d927 1
a927 1
	if( tp->tr_op == OP_REGION )  return;
d1171 1
d1173 1
d1234 5
a1238 6
		if( curtree->tr_op == OP_NOP )  {
			/* Entire tree vanished, nothing to make region from */
			if( region_start_statep )
				db_free_combined_tree_state( region_start_statep );
			continue;
		}
@


1.26
log
@lint
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.25 91/01/26 02:56:04 mike Exp $ (BRL)";
d74 1
d175 1
@


1.25
log
@Changed calling sequence to ts_leaf_func() routines
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.24 90/12/11 22:03:55 mike Exp $ (BRL)";
d1119 1
a1119 1
HIDDEN union tree *db_gettree_leaf( tsp, pathp, rp, id )
d1122 1
a1122 1
union record		*rp;
@


1.24
log
@For lint purposes, #include db.h must preceed #include machine.h,
so that union record is known.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.23 90/11/11 04:56:29 mike Exp $ (BRL)";
d110 1
a110 1
db_apply_state_from_comb( tsp, pathp, rp )
d113 1
a113 1
union record		*rp;
d115 4
d283 1
a283 1
	register union record	*rp = (union record *)0;
d303 1
d377 1
a377 1
		if( (rp = db_getmrec( tsp->ts_dbip, comb_dp )) == (union record *)0 )
d381 1
a381 1
		if( db_apply_state_from_comb( tsp, pathp, rp ) < 0 )
d385 2
d418 1
a418 3
		/* Free record */
		rt_free( (char *)rp, "db_follow_path_for_state record[]" );
		rp = (union record *)0;
d426 1
a426 1
	if( rp )  rt_free( (char *)rp, "db_follow_path_for_state record[] out" );
d436 1
a436 1
	if( rp )  rt_free( (char *)rp, "db_follow_path_for_state record[] fail" );
d588 1
a588 1
	register union record	*rp = (union record *)0;
d611 1
a611 1
	if( (rp = db_getmrec( tsp->ts_dbip, dp )) == (union record *)0 )
d615 1
d628 1
a628 1
		if( (is_region = db_apply_state_from_comb( &nts, pathp, rp )) < 0 )
d732 2
a733 2
		if( (id = rt_id_solid( rp )) == ID_NULL )  {
			rt_log("db_functree(%s): defective database record, type '%c' (0%o), addr=x%x\n",
d735 1
a735 1
				rp->u_id, rp->u_id, dp->d_addr );
d793 1
a793 1
		curtree = tsp->ts_leaf_func( tsp, pathp, rp, id );
d800 1
a800 1
	if( rp )  rt_free( (char *)rp, "db_recurse record[]" );
@


1.23
log
@Fallout from changing an_path to be a db_full_path structure
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.22 90/11/02 03:41:06 mike Exp $ (BRL)";
d34 1
a35 1
#include "db.h"
@


1.22
log
@Added some sanity checks, changed messages on rt_free.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.21 90/11/02 02:36:59 mike Exp $ (BRL)";
d231 1
a231 1
		register int i = anp->an_pathlen-1;
a234 1
			struct db_full_path	path;
d237 1
a237 3
			path.fp_len = anp->an_pathlen;
			path.fp_names = anp->an_path;
			str = db_path_to_string( &path );
d242 1
a242 1
			if( anp->an_path[i] != pathp->fp_names[j] )  {
d245 1
a245 1
					     anp->an_path[i]->d_namep,
d329 1
a329 1
					if( dp != anp->an_path[0] )
@


1.21
log
@Fixed a few +/- 1 problems, sigh.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.20 90/11/02 02:18:21 mike Exp $ (BRL)";
d56 1
d415 1
a415 1
		rt_free( (char *)rp, comb_dp->d_namep );
d424 1
a424 1
	if( rp )  rt_free( (char *)rp, dp->d_namep );
d434 1
a434 1
	if( rp )  rt_free( (char *)rp, dp->d_namep );
d797 1
a797 1
	if( rp )  rt_free( (char *)rp, dp->d_namep );
d878 1
a878 1
		if( tp->tr_a.tu_stp )
d880 2
d885 1
a885 1
		if( tp->tr_a.tu_stp )
d888 1
d895 1
d904 1
d906 1
d912 1
@


1.20
log
@indexing off the end of the pathp array has been fixed.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.19 90/05/21 14:33:54 mike Exp $ (BRL)";
d204 1
a204 1
	/* Trim m_instname */
d220 1
a220 1
		rt_log("Animate %s/%s with...\n", sofar, mp->m_instname);
d223 6
d230 1
a230 7
		/*
		 * pathlen-1 would index the leaf (a
		 * solid), but the solid is implicit in "path"
		 * so use pathlen-2 to index
		 * the combination just above the leaf.
		 */
		register int i = anp->an_pathlen-2;
@


1.19
log
@lint
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_tree.c,v 1.18 90/05/04 06:23:46 mike Exp $ (BRL)";
a223 1
		register int i = anp->an_pathlen-2;
d225 1
a225 1
		 * pathlen - 1 would point to the leaf (a
d227 2
a228 2
		 * so we need to backup "2" such that we point
		 * at the combination just above this solid.
d230 2
a231 1
		register int j = pathp->fp_len;
@


1.18
log
@Made the "solid not contained in region" message conditional on debugging.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.17 90/04/25 00:05:23 mike Locked $ (BRL)";
a914 1
	union tree	*lhs;
@


1.17
log
@Added code to handle solids not contained by a region.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.16 90/04/24 21:07:59 mike Locked $ (BRL)";
d472 1
a472 1
		if( rt_g.debug & DEBUG_REGIONS )  {
d769 4
a772 2
		    	rt_log("WARNING: db_recurse(): solid '%s' not contained in a region\n",
		    		sofar );
@


1.16
log
@Fixed bug with freeing null tree
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.15 90/04/24 02:40:18 mike Locked $ (BRL)";
d755 16
a770 1
		/* Note:  solid may not be contained by a region */
d772 14
a787 1
		/* eg, rt_add_solid() */
d1230 1
a1230 1
			rt_bomb("db_walk_dispatcher() region started with no state?\n");
@


1.15
log
@Fixed memory leaks in tree walker.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.14 90/04/12 23:12:22 mike Locked $ (BRL)";
d1365 4
a1368 2
	for( i=0; i < new_reg_count; i++ )
		db_free_tree( reg_trees[i] );
@


1.14
log
@Minor improvements
@
text
@d5 1
a5 1
 *	db_functree	No-frills tree-walk
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.13 90/04/12 04:10:10 mike Locked $ (BRL)";
d767 1
d775 1
a775 1
	return(curtree);		/* SUCCESS */
d777 2
a778 9
	if( rp )  rt_free( (char *)rp, dp->d_namep );
	if(rt_g.debug&DEBUG_TREEWALK)  {
		char	*sofar = db_path_to_string(pathp);
		rt_log("db_recurse() return curtree=NULL, pathp='%s', *statepp=x%x\n",
			sofar,
			*region_start_statepp );
		rt_free(sofar, "path string");
	}
	return( (union tree *)0 );	/* FAIL */
d832 47
d1014 1
d1019 4
a1022 1
		reg_trees[cur++] = tp;
d1038 4
a1041 1
		reg_trees[cur++] = tp;
d1225 8
d1284 2
a1285 1
		if( curtree == (union tree *)0 )
d1335 6
a1340 1
	/* XXX Need to zap from whole_tree to region points */
d1355 6
a1360 4
		/* XXX Need to ensure that rt_g.rtg_parallel is set! */
		/* XXX Should actually be done by rt_parallel. */
		rt_g.rtg_parallel = 1;
		/* XXX Need to check that RES_INIT()s have been done too! */
d1364 5
a1368 1
	/* XXX Clean any remaining trees still in reg_trees[] */
@


1.13
log
@This version seems to work
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.12 90/04/12 02:52:32 mike Locked $ (BRL)";
a168 1
			/* XXX region name, instnum too? */
d395 16
a410 12
		/* Take note of operation */
		switch( mp->m_relation )  {
		default:
			break;		/* handle as union */
		case UNION:
			break;
		case SUBTRACT:
			tsp->ts_sofar |= TS_SOFAR_MINUS;
			break;
		case INTERSECT:
			tsp->ts_sofar |= TS_SOFAR_INTER;
			break;
d470 7
a476 3
	if( rt_g.debug & DEBUG_REGIONS && first_tlp->tl_op != OP_UNION )
		rt_log("db_mkbool_tree() WARNING: non-union (%c) first operation ignored\n",
			first_tlp->tl_op );
d524 5
a528 6
	 * This is the way GIFT interpreted equations, so we
	 * duplicate it here.  Any expressions between UNIONs
	 * is evaluated first, eg:
	 *	A - B - C u D - E - F
	 * is	(A - B - C) u (D - E - F)
	 * so first we do the parenthesised parts, and then go
d675 21
a695 4
			switch( mp->m_relation )  {
			default:
				rt_log("%s: bad m_relation '%c'\n",
					dp->d_namep, mp->m_relation );
a696 12
				break;
			case UNION:
				tlp->tl_op = OP_UNION;
				break;
			case SUBTRACT:
				tlp->tl_op = OP_SUBTRACT;
				memb_state.ts_sofar |= TS_SOFAR_MINUS;
				break;
			case INTERSECT:
				tlp->tl_op = OP_INTERSECT;
				memb_state.ts_sofar |= TS_SOFAR_INTER;
				break;
d1038 1
a1038 1
	union tree	*curtree;
d1114 9
d1147 1
a1147 1
			rt_log("db_walk_dispatcher() Entire subtree vanished?\n");
d1160 6
a1165 2
		/* XXX use return code? */
		(*db_reg_end_func)( &(region_start_statep->cts_s),
d1173 6
d1278 2
d1299 2
@


1.12
log
@Moved data structure definitions to raytrace.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.11 90/04/12 02:46:18 mike Locked $ (BRL)";
d39 2
d59 3
d81 3
a97 34
 *			R T _ T R E E _ R E G I O N _ A S S I G N
 */
void
rt_tree_region_assign( tp, regionp )
register union tree	*tp;
register struct region	*regionp;
{
	switch( tp->tr_op )  {
	case OP_SOLID:
		tp->tr_a.tu_regionp = regionp;
		return;

	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
		tp->tr_b.tb_regionp = regionp;
		rt_tree_region_assign( tp->tr_b.tb_left, regionp );
		return;

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		tp->tr_b.tb_regionp = regionp;
		rt_tree_region_assign( tp->tr_b.tb_left, regionp );
		rt_tree_region_assign( tp->tr_b.tb_right, regionp );
		return;

	default:
		rt_bomb("rt_tree_region_assign: bad op\n");
	}
}

/*
d235 8
a242 2
			rt_log("\t%s\t",rt_path_str(
			    anp->an_path, anp->an_pathlen-1));
d255 1
a255 1
		rt_do_anim( anp, old_xlate, xmat, &(tsp->ts_mater) );
d292 1
a292 1
	RT_CHECK_DBIP( tsp->ts_dbip );
a325 1
			/* XXX rt_do_anim should perhaps be db_do_anim? */
d336 1
a336 1
					rt_do_anim( anp, old_xlate, xmat, &(tsp->ts_mater) );
a434 1
extern union tree *rt_mkbool_tree();
d437 7
a443 1
 *			R T _ M K G I F T _ T R E E
d445 58
a502 2
union tree *
rt_mkgift_tree( trees, subtreecount, tsp )
a506 1
	extern int	rt_pure_boolean_expressions;
a511 2
	struct region	region;
	struct region	*regionp = &region;
a512 2
	region.reg_name = "DUMMY from rt_mkgift_tree()";

d514 1
a514 8
	if( rt_pure_boolean_expressions )  {
		curtree = rt_mkbool_tree( trees, subtreecount, regionp );
		if(rt_g.debug&DEBUG_TREEWALK)  {
			rt_log("rt_mkgift_tree returns pure tree:\n");
			rt_pr_tree(curtree, 0);
		}
		return( curtree );
	}
d534 2
a535 2
		curtree = rt_mkbool_tree( tstart, j, regionp );
		/* rt_mkbool_tree() has side effect of zapping tree array,
d542 1
a542 1
			rt_log("rt_mkgift_tree() intermediate term:\n");
d550 2
a551 1
	curtree = rt_mkbool_tree( trees, subtreecount, regionp );
d553 1
a553 1
		rt_log("rt_mkgift_tree() returns:\n");
d585 1
a585 1
	RT_CHECK_DBIP( tsp->ts_dbip );
d700 1
a700 1
		curtree = rt_mkgift_tree( trees, tlp-trees, tsp );
a1266 155
	return(0);	/* OK */
}

/* ============================== */

static struct db_tree_state	rt_initial_tree_state = {
	0,			/* ts_dbip */
	0,			/* ts_sofar */
	0, 0, 0,		/* region, air, gmater */
	1.0, 1.0, 1.0,		/* color, RGB */
	0,			/* override */
	DB_INH_LOWER,		/* color inherit */
	DB_INH_LOWER,		/* mater inherit */
	"",			/* material name */
	"",			/* material params */
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0,
};

static struct rt_i	*db_rtip;

HIDDEN int rt_gettree_region_start( tsp, pathp )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
{

	/* Ignore "air" regions unless wanted */
	if( db_rtip->useair == 0 &&  tsp->ts_aircode != 0 )  {
		db_rtip->rti_air_discards++;
		return(-1);	/* drop this region */
	}
	return(0);
}

HIDDEN union tree *rt_gettree_region_end( tsp, pathp, curtree )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
{
	register struct combined_tree_state	*cts;
	struct region		*rp;
	struct directory	*dp;

	GETSTRUCT( rp, region );
	rp->reg_forw = REGION_NULL;
	rp->reg_regionid = tsp->ts_regionid;
	rp->reg_aircode = tsp->ts_aircode;
	rp->reg_gmater = tsp->ts_gmater;
	rp->reg_mater = tsp->ts_mater;		/* struct copy */
	rp->reg_name = db_path_to_string( pathp );

	dp = DB_FULL_PATH_CUR_DIR(pathp);
	/* XXX This should be semaphore protected! */
	rp->reg_instnum = dp->d_uses++;

	if(rt_g.debug&DEBUG_TREEWALK)  {
		rt_log("rt_gettree_region_end() %s\n", rp->reg_name );
		rt_pr_tree( curtree, 0 );
	}

	/* Mark all solids & nodes as belonging to this region */
	rt_tree_region_assign( curtree, rp );

	rt_add_regtree( db_rtip, rp, curtree );
	return(curtree);
}

HIDDEN union tree *rt_gettree_leaf( tsp, pathp, rp, id )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union record		*rp;
int			id;
{
	struct soltab	*stp;
	union tree	*curtree;
	struct directory	*dp;

	/* Note:  solid may not be contained by a region (yet) */

	dp = DB_FULL_PATH_CUR_DIR(pathp);
	if( (stp = rt_add_solid( db_rtip, rp, dp, tsp->ts_mat )) == SOLTAB_NULL )
		return(TREE_NULL);

	GETUNION( curtree, tree );
	curtree->tr_op = OP_SOLID;
	curtree->tr_a.tu_stp = stp;
	curtree->tr_a.tu_name = db_path_to_string( pathp );
	/* regionp will be filled in later by rt_tree_region_assign() */
	curtree->tr_a.tu_regionp = (struct region *)0;

	if(rt_g.debug&DEBUG_TREEWALK)
		rt_log("rt_gettree_leaf() %s\n", curtree->tr_a.tu_name );

	return(curtree);
}

/*
 * XXX  NEW NEW NEW
 *  			R T _ G E T T R E E
 *
 *  User-called function to add a tree hierarchy to the displayed set.
 *  
 *  Returns -
 *  	0	Ordinarily
 *	-1	On major error
 */
int
NEW_rt_gettree( rtip, node )
struct rt_i	*rtip;
char		*node;
{
	return( rt_gettrees( rtip, 1, &node ) );
}

/*
 *  			R T _ G E T T R E E S
 *
 *  User-called function to add a set of tree hierarchies to the active set.
 *  
 *  Returns -
 *  	0	Ordinarily
 *	-1	On major error
 */
int
rt_gettrees( rtip, argc, argv )
struct rt_i	*rtip;
int		argc;
char		**argv;
{
	int			prev_sol_count;
	int			i;

	RT_CHECK_RTI(rtip);

	if(!rtip->needprep)
		rt_bomb("rt_gettree called again after rt_prep!\n");

	if( argc <= 0 )  return(-1);	/* FAIL */

	prev_sol_count = rtip->nsolids;
	db_rtip = rtip;

	i = db_walk_tree( rtip->rti_dbip, argc, argv,
		1,	/* # cpus */
		&rt_initial_tree_state,
		rt_gettree_region_start,
		rt_gettree_region_end,
		rt_gettree_leaf );

	if( i < 0 )  return(-1);

	if( rtip->nsolids <= prev_sol_count )
		rt_log("rt_gettrees(%s) warning:  no solids found\n", argv[0]);
@


1.11
log
@Used GETUNION
Changed tree_state to db_tree_state
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.10 90/04/12 02:28:56 mike Locked $ (BRL)";
a38 3
/* XXX for raytrace.h */


a44 24
struct db_tree_state {
	struct db_i	*ts_dbip;
	int		ts_sofar;		/* Flag bits */

	int		ts_regionid;	/* GIFT compat region ID code*/
	int		ts_aircode;	/* GIFT compat air code */
	int		ts_gmater;	/* GIFT compat material code */
	struct mater_info ts_mater;	/* material properties */

	mat_t		ts_mat;		/* transform matrix */

	int		ts_stop_at_regions;	/* else stop at solids */
	int		(*ts_region_start_func)();
	union tree *	(*ts_region_end_func)();
	union tree *	(*ts_leaf_func)();
};
#define TS_SOFAR_MINUS	1		/* Subtraction encountered above */
#define TS_SOFAR_INTER	2		/* Intersection encountered above */
#define TS_SOFAR_REGION	4		/* Region encountered above */

struct combined_tree_state {
	struct db_tree_state	cts_s;
	struct db_full_path	cts_p;
};
@


1.10
log
@Moved full_path routines into db_path.c
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.9 90/04/12 02:23:25 mike Locked $ (BRL)";
d48 1
a48 1
struct tree_state {
a62 3

/**	vect_t		ts_min;		/* RPP minimum */
/**	vect_t		ts_max;		/* RPP maximum */
d69 1
a69 1
	struct tree_state	cts_s;
d86 1
a86 1
register struct tree_state	*tsp;
d163 1
a163 1
struct tree_state	*tsp;
d241 1
a241 1
struct tree_state	*tsp;
d324 1
a324 1
struct tree_state	*tsp;
d492 1
a492 1
struct tree_state	*tsp;
d572 1
a572 1
struct tree_state	*tsp;
d604 1
a604 1
		struct tree_state	nts;
d656 1
a656 1
			struct tree_state	memb_state;
d783 1
a783 1
	new = (union tree *)rt_malloc( sizeof(union tree), "db_dup_subtree");
d796 1
a796 3
			cts=(struct combined_tree_state *)rt_malloc(
				sizeof(struct combined_tree_state),
				"combined region state");
d866 1
a866 2
		rhs = (union tree *)rt_malloc( sizeof(union tree),
			"non_union_push new rhs" );
d999 1
a999 1
register struct tree_state	*tsp;
d1005 1
a1005 2
	cts=(struct combined_tree_state *)rt_malloc(
		sizeof(struct combined_tree_state), "combined region state");
d1009 1
a1009 1
	curtree=(union tree *)rt_malloc(sizeof(union tree), "solid tree");
d1019 1
a1019 1
struct tree_state	*tsp;
d1027 1
a1027 2
	cts=(struct combined_tree_state *)rt_malloc(
		sizeof(struct combined_tree_state), "combined region state");
d1031 1
a1031 1
	curtree=(union tree *)rt_malloc(sizeof(union tree), "solid tree");
d1152 1
a1152 1
struct tree_state *init_state;
d1169 1
a1169 1
		struct tree_state	ts;
d1209 1
a1209 1
			new = (union tree *)rt_malloc( sizeof(union tree), "new tree top");
d1270 1
a1270 1
static struct tree_state	rt_initial_tree_state = {
d1289 1
a1289 1
struct tree_state	*tsp;
d1302 1
a1302 1
register struct tree_state	*tsp;
d1335 1
a1335 1
struct tree_state	*tsp;
d1350 1
a1350 1
	curtree=(union tree *)rt_malloc(sizeof(union tree), "solid tree");
@


1.9
log
@Moved rti_anroot to dbi_anroot.
Clarified rtip -vs- dbip usage.
Changed full_path to db_full_path.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.8 90/04/12 00:46:36 mike Locked $ (BRL)";
a74 95

/*
 *			D B _ A D D _ N O D E _ T O _ F U L L _ P A T H
 */
void
db_add_node_to_full_path( pp, dp )
struct db_full_path	*pp;
struct directory	*dp;
{
	if( pp->fp_maxlen <= 0 )  {
		pp->fp_maxlen = 32;
		pp->fp_names = (struct directory **)rt_malloc(
			pp->fp_maxlen * sizeof(struct directory *),
			"db_full_path array");
	} else if( pp->fp_len >= pp->fp_maxlen )  {
		pp->fp_maxlen *= 4;
		pp->fp_names = (struct directory **)rt_realloc(
			(char *)pp->fp_names,
			pp->fp_maxlen * sizeof(struct directory *),
			"enlarged db_full_path array");
	}
	pp->fp_names[pp->fp_len++] = dp;
}

/*
 *			D B _ D U P _ F U L L _ P A T H
 */
void
db_dup_full_path( newp, oldp )
register struct db_full_path	*newp;
register struct db_full_path	*oldp;
{
	newp->fp_maxlen = oldp->fp_maxlen;
	if( (newp->fp_len = oldp->fp_len) <= 0 )  {
		newp->fp_names = (struct directory **)0;
		return;
	}
	newp->fp_names = (struct directory **)rt_malloc(
		newp->fp_maxlen * sizeof(struct directory *),
		"duplicate full path array" );
	bcopy( (char *)oldp->fp_names, (char *)newp->fp_names,
		newp->fp_len * sizeof(struct directory *) );
}

/*
 *			D B _ P A T H _ T O _ S T R I N G
 *
 *  Unlike rt_path_str(), this version can be used in parallel.
 *  Caller is responsible for freeing the returned buffer.
 */
char *
db_path_to_string( pp )
struct db_full_path	*pp;
{
	int	len;
	char	*buf;
	char	*cp;
	int	i;

	len = 3;	/* leading slash, trailing null, spare */
	for( i=pp->fp_len-1; i >= 0; i-- )  {
		if( pp->fp_names[i] )
			len += strlen( pp->fp_names[i]->d_namep ) + 1;
		else
			len += 16;
	}

	buf = rt_malloc( len, "pathname string" );
	cp = buf;

	for( i=0; i < pp->fp_len; i++ )  {
		*cp++ = '/';
		if( pp->fp_names[i] )
			strcpy( cp, pp->fp_names[i]->d_namep );
		else
			strcpy( cp, "**NULL**" );
		cp += strlen( cp );
	}
	*cp++ = '\0';
	return( buf );
}

/*
 *			D B _ F R E E _ F U L L _ P A T H
 */
void
db_free_full_path( pp )
struct db_full_path	*pp;
{
	if( pp->fp_maxlen > 0 )  {
		rt_free( (char *)pp->fp_names, "db_full_path array" );
		pp->fp_maxlen = pp->fp_len = 0;
		pp->fp_names = (struct directory **)0;
	}
}
@


1.8
log
@Fixed bug
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.7 90/04/12 00:31:02 mike Locked $ (BRL)";
a39 2
#define OP_REGION	MKOP(9)		/* Leaf: tr_stp -> combined_tree_state */
#define OP_NOP		MKOP(10)	/* Leaf with no effect */
a40 7
struct full_path {
	int		fp_len;
	int		fp_maxlen;
	struct directory **fp_names;	/* array of dir pointers */
};
#define DB_FULL_PATH_POP(_pp)	{(_pp)->fp_len--;}
#define DB_FULL_PATH_CUR_DIR(_pp)	((_pp)->fp_names[(_pp)->fp_len-1])
d73 1
a73 1
	struct full_path	cts_p;
d81 1
a81 1
struct full_path	*pp;
d88 1
a88 1
			"full_path array");
d94 1
a94 1
			"enlarged full_path array");
d104 2
a105 2
register struct full_path	*newp;
register struct full_path	*oldp;
d127 1
a127 1
struct full_path	*pp;
d162 1
a162 1
struct full_path	*pp;
d165 1
a165 1
		rt_free( (char *)pp->fp_names, "full_path array" );
d262 1
a262 1
struct full_path	*pathp;
d340 1
a340 1
struct full_path	*pathp;
d423 1
a423 1
struct full_path	*pathp;
d437 1
a437 1
	if( tsp->ts_dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_follow_path_for_state:  bad dbip\n");
a470 2
#if 0
			/* XXX should these be dbip->db_anroot ?? */
d473 1
a473 1
			if( rtip->rti_anroot )  {
d477 1
a477 1
				for( anp=rtip->rti_anroot; anp != ANIM_NULL; anp = anp->an_forw ) {
a485 1
#endif
d671 1
a671 1
struct full_path	*pathp;
d681 1
a681 1
	if( tsp->ts_dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_recurse:  bad dbip\n");
d1092 1
a1092 1
static struct rt_i	*db_rtip;
d1101 1
a1101 1
struct full_path	*pathp;
d1122 1
a1122 1
struct full_path	*pathp;
d1156 1
a1156 1
		ctsp->cts_s.ts_dbip = db_rtip->rti_dbip;
d1250 2
a1251 2
db_walk_tree( rtip, argc, argv, ncpu, init_state, reg_start_func, reg_end_func, leaf_func )
struct rt_i	*rtip;
d1265 1
a1265 1
	RT_CHECK_RTI(rtip);
d1267 1
a1267 1
	db_rtip = rtip;			/* make global to this module */
d1273 1
a1273 1
		struct full_path	path;
d1277 1
a1277 1
		ts.ts_dbip = rtip->rti_dbip;
d1389 2
d1393 1
a1393 1
struct full_path	*pathp;
d1406 1
a1406 1
struct full_path	*pathp;
d1439 1
a1439 1
struct full_path	*pathp;
d1477 1
a1477 1
NEW_rt_gettree( rtip, node)
d1481 1
a1481 21
	int			prev_sol_count;
	int			i;

	RT_CHECK_RTI(rtip);

	if(!rtip->needprep)
		rt_bomb("rt_gettree called again after rt_prep!\n");

	prev_sol_count = rtip->nsolids;

	i = db_walk_tree( rtip, 1, &node, 1,
		&rt_initial_tree_state,
		rt_gettree_region_start,
		rt_gettree_region_end,
		rt_gettree_leaf );

	if( i < 0 )  return(-1);

	if( rtip->nsolids <= prev_sol_count )
		rt_log("rt_gettree(%s) warning:  no solids found\n", node);
	return(0);	/* OK */
d1510 1
d1512 2
a1513 1
	i = db_walk_tree( rtip, argc, argv, 1,	/* # cpus */
@


1.7
log
@More nicely packaged version
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.6 90/04/11 21:31:31 mike Locked $ (BRL)";
d540 1
a540 1
		for( i=1; i < dp->d_len; i++ )  {
@


1.6
log
@Minor cleanups
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.5 90/04/10 16:10:56 mike Locked $ (BRL)";
d447 1
a447 1
	if(rt_g.debug&DEBUG_DB)  {
d580 1
a580 1
	if(rt_g.debug&DEBUG_DB)  {
d618 1
a618 1
		if(rt_g.debug&DEBUG_REGIONS)  {
d650 1
a650 1
		if(rt_g.debug&DEBUG_REGIONS) {
d660 1
a660 1
	if(rt_g.debug&DEBUG_REGIONS)  {
d699 1
a699 1
	if(rt_g.debug&DEBUG_DB)  {
d754 4
a757 2
rt_log("setting *region_start_statepp to x%x\n", ctsp );
			db_pr_combined_tree_state(ctsp);
d864 1
a864 1
	if(rt_g.debug&DEBUG_DB)  {
d874 1
a874 1
	if(rt_g.debug&DEBUG_DB)  {
a1103 16
static struct tree_state	rt_initial_tree_state = {
	0,			/* ts_dbip */
	0,			/* ts_sofar */
	0, 0, 0,		/* region, air, gmater */
	1.0, 1.0, 1.0,		/* color, RGB */
	0,			/* override */
	DB_INH_LOWER,		/* color inherit */
	DB_INH_LOWER,		/* mater inherit */
	"",			/* material name */
	"",			/* material params */
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0,
};

d1108 2
d1111 1
a1111 14
HIDDEN int rt_gettree_p1_region_start( tsp, pathp )
struct tree_state	*tsp;
struct full_path	*pathp;
{

	/* Ignore "air" regions unless wanted */
	if( db_rtip->useair == 0 &&  tsp->ts_aircode != 0 )  {
		db_rtip->rti_air_discards++;
		return(-1);	/* drop this region */
	}
	return(0);
}

HIDDEN union tree *rt_gettree_p1_region_end( tsp, pathp, curtree )
d1132 1
a1132 1
HIDDEN union tree *rt_gettree_p1_leaf( tsp, pathp, rp, id )
a1154 59
HIDDEN union tree *rt_gettree_p2_region_end( tsp, pathp, curtree )
register struct tree_state	*tsp;
struct full_path	*pathp;
union tree		*curtree;
{
	register struct combined_tree_state	*cts;
	struct region		*rp;
	struct directory	*dp;

	GETSTRUCT( rp, region );
	rp->reg_forw = REGION_NULL;
	rp->reg_regionid = tsp->ts_regionid;
	rp->reg_aircode = tsp->ts_aircode;
	rp->reg_gmater = tsp->ts_gmater;
	rp->reg_mater = tsp->ts_mater;		/* struct copy */
	rp->reg_name = db_path_to_string( pathp );

	dp = DB_FULL_PATH_CUR_DIR(pathp);
	/* XXX This should be semaphore protected! */
	rp->reg_instnum = dp->d_uses++;

rt_log("rt_gettree_p2_region_end() %s\n", rp->reg_name );
	rt_pr_tree( curtree, 0 );

	/* Mark all solids & nodes as belonging to this region */
	rt_tree_region_assign( curtree, rp );

	rt_add_regtree( db_rtip, rp, curtree );
	return(curtree);
}

HIDDEN union tree *rt_gettree_p2_leaf( tsp, pathp, rp, id )
struct tree_state	*tsp;
struct full_path	*pathp;
union record		*rp;
int			id;
{
	struct soltab	*stp;
	union tree	*curtree;
	struct directory	*dp;

	/* Note:  solid may not be contained by a region (yet) */

	dp = DB_FULL_PATH_CUR_DIR(pathp);
	if( (stp = rt_add_solid( db_rtip, rp, dp, tsp->ts_mat )) == SOLTAB_NULL )
		return(TREE_NULL);

	curtree=(union tree *)rt_malloc(sizeof(union tree), "solid tree");
	curtree->tr_op = OP_SOLID;
	curtree->tr_a.tu_stp = stp;
	curtree->tr_a.tu_name = db_path_to_string( pathp );
	/* regionp will be filled in later by rt_tree_region_assign() */
	curtree->tr_a.tu_regionp = (struct region *)0;

rt_log("rt_gettree_p2_leaf() %s\n", curtree->tr_a.tu_name );

	return(curtree);
}

d1174 2
a1175 1
		ctsp->cts_s.ts_leaf_func = rt_gettree_p2_leaf;
d1184 1
a1184 1
		if( curtree == (union tree *)0 )  {
d1231 2
a1232 1
rt_log("\n\n***** db_walk_dispatcher() on item %d\n\n", mine );
d1250 5
a1254 2
		db_pr_combined_tree_state(region_start_statep);
		rt_gettree_p2_region_end( &(region_start_statep->cts_s),
d1262 1
a1262 12
/*
 * XXX  NEW NEW NEW
 *  			R T _ G E T _ T R E E
 *
 *  User-called function to add a tree hierarchy to the displayed set.
 *  
 *  Returns -
 *  	0	Ordinarily
 *	-1	On major error
 */
int
NEW_rt_gettree( rtip, node)
d1264 7
a1270 1
char		*node;
d1272 1
a1272 4
	register union tree	*curtree;
	struct tree_state	ts;
	struct full_path	path;
	int			prev_sol_count;
a1275 1
	struct combined_tree_state	*region_start_statep;
a1278 3
	if(!rtip->needprep)
		rt_bomb("rt_gettree called again after rt_prep!\n");

a1279 2
	ts = rt_initial_tree_state;	/* struct copy */
	ts.ts_dbip = rtip->rti_dbip;
d1281 6
a1286 1
	path.fp_len = path.fp_maxlen = 0;
d1288 3
a1290 1
	prev_sol_count = rtip->nsolids;
d1292 3
a1294 3
	/* First, establish context from given path */
	if( db_follow_path_for_state( &ts, &path, node, LOOKUP_NOISY ) < 0 )
		return(-1);		/* ERROR */
d1296 10
a1305 13
	/*
	 *  Second, walk tree from root to start of all regions.
	 *  Build a boolean tree of all regions.
	 */
	ts.ts_stop_at_regions = 1;
	ts.ts_region_start_func = rt_gettree_p1_region_start;
	ts.ts_region_end_func = rt_gettree_p1_region_end;
	ts.ts_leaf_func = rt_gettree_p1_leaf;
	region_start_statep = (struct combined_tree_state *)0;
	curtree = db_recurse( &ts, &path, &region_start_statep );
	if( region_start_statep )
		db_free_combined_tree_state( region_start_statep );
	if( curtree == (union tree *)0 )  return(-1);
d1307 6
a1312 2
	rt_log("tree after db_recurse():\n");
	rt_pr_tree( curtree, 0 );
d1314 21
d1338 5
a1342 3
	db_non_union_push( curtree );
	rt_log("tree after db_non_union_push():\n");
	rt_pr_tree( curtree, 0 );
d1348 1
a1348 2
	new_reg_count = db_count_subtree_regions( curtree );
rt_log("new region count=%d\n", new_reg_count);
d1351 8
a1358 5
	i = db_tally_subtree_regions( curtree, reg_trees, 0 );
	rt_log(" count1=%d, count2=%d\n", new_reg_count, i );
	for( i=0; i<new_reg_count; i++ )  {
		rt_log("tree %d =\n", i);
		rt_pr_tree( reg_trees[i], 0 );
d1364 1
a1364 1
	/* do equivalant of rt_drawobj() && rt_add_solid */
d1368 4
a1371 1
	if( 1 /* !rt_g.rtg_parallel */ )  {
d1374 5
a1378 1
		rt_parallel( db_walk_dispatcher, rt_avail_cpus() );
d1380 2
d1383 126
d1511 40
@


1.5
log
@Fixed two small but serious nits
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.4 90/04/10 05:48:10 mike Locked $ (BRL)";
d143 1
a143 1
	len = 2;	/* leading slash, trailing null */
d162 1
d206 2
a207 2
	rt_log(" ts_mater.ma_matname=%32.32s\n", tsp->ts_mater.ma_matname );
	rt_log(" ts_mater.ma_matparam=%60.60s\n", tsp->ts_mater.ma_matparm );
d691 1
a691 1
	union tree		*curtree;
a740 1
				curtree = (union tree *)0;
d1118 5
a1127 1
#if 0
d1129 2
a1130 2
	if( rtip->useair == 0 &&  tsp->ts_aircode != 0 )  {
		rtip->rti_air_discards++;
a1132 1
#endif
a1148 2
	bzero( (char *)curtree, sizeof(union tree) );
	/* XXX */
a1171 1
	bzero( (char *)curtree, sizeof(union tree) );
a1179 18
static struct rt_i	*db_rtip;
static union tree	**db_reg_trees;
static int		db_reg_count;
static int		db_reg_current;		/* semaphored when parallel */

HIDDEN int rt_gettree_p2_region_start( tsp, pathp )
struct tree_state	*tsp;
struct full_path	*pathp;
{

	/* Ignore "air" regions unless wanted */
	if( db_rtip->useair == 0 &&  tsp->ts_aircode != 0 )  {
		db_rtip->rti_air_discards++;
		return(-1);	/* drop this region */
	}
	return(0);
}

a1227 1
	bzero( (char *)curtree, sizeof(union tree) );
d1231 1
a1231 1
/**** need regionp! XXXX */
d1254 2
a1255 1
		ctsp->cts_s.ts_region_start_func = rt_gettree_p2_region_start;
d1370 1
d1407 2
a1408 1
	 *  Build array of tree pointers, one per leaf, for processing below.
a1427 1
	db_rtip = rtip;
@


1.4
log
@Mostly working now.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.3 90/04/10 02:36:47 mike Locked $ (BRL)";
d909 1
d1329 1
a1329 1
		if( mine > db_reg_count )
@


1.3
log
@Not working yet, but close to reasonable form.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.2 90/04/09 22:07:59 mike Locked $ (BRL)";
d41 1
d48 2
d86 1
a86 1
 *  rt_ or db_ ?
d89 1
a89 1
rt_add_node_to_full_path( pp, dp )
d97 1
a97 1
			"initial full path array");
d103 1
a103 1
			"enlarged full path array");
d108 3
d112 1
a112 1
rt_dup_full_path( newp, oldp )
d129 2
d135 1
a135 1
rt_path_to_string( pp )
d166 91
d274 1
a274 1
		char	*sofar = rt_path_to_string(pathp);
d284 1
a284 1
			char	*sofar = rt_path_to_string(pathp);
d300 1
a300 1
			char	*sofar = rt_path_to_string(pathp);
d316 1
a316 1
				char	*sofar = rt_path_to_string(pathp);
d358 1
a358 1
		char	*sofar = rt_path_to_string(pathp);
d370 1
a370 1
	rt_add_node_to_full_path( pathp, mdp );
d379 1
a379 1
		char	*sofar = rt_path_to_string(pathp);
d447 1
a447 1
		char	*sofar = rt_path_to_string(pathp);
d459 1
a459 1
		comb_dp = pathp->fp_names[pathp->fp_len-1];
d477 1
a477 1
			rt_add_node_to_full_path( pathp, dp );
d506 1
a506 1
			rt_add_node_to_full_path( pathp, dp );
d513 1
a513 1
				char	*sofar = rt_path_to_string(pathp);
d580 1
a580 1
		char	*sofar = rt_path_to_string(pathp);
d672 6
d680 1
a680 1
db_recurse( tsp, pathp )
d683 1
d697 1
a697 1
	dp = pathp->fp_names[pathp->fp_len-1];
d699 4
a702 3
		char	*sofar = rt_path_to_string(pathp);
		rt_log("db_recurse() pathp='%s', tsp=x%x\n",
			sofar, tsp );
d729 1
d743 13
d795 1
a795 1
			if( (tlp->tl_tree = db_recurse( &memb_state, pathp )) != TREE_NULL )  {
d799 1
a799 1
			pathp->fp_len--;	/* pop member */
d863 4
a866 3
		char	*sofar = rt_path_to_string(pathp);
		rt_log("db_recurse() return curtree=x%x, pathp='%s'\n",
			curtree, sofar);
d873 4
a876 3
		char	*sofar = rt_path_to_string(pathp);
		rt_log("db_recurse() return curtree=NULL, pathp='%s'\n",
			sofar);
d908 1
a908 1
			rt_dup_full_path( &(cts->cts_p), &(ots->cts_p) );
d928 1
a928 1
		rt_bomb("db_dup_subtree: bad op");
d1056 1
a1056 1
		rt_bomb("db_count_subtree_regions: bad op");
d1094 1
a1094 1
		rt_bomb("db_tally_subtree_regions: bad op");
d1142 1
a1142 1
	rt_dup_full_path( &(cts->cts_p), pathp );
d1167 1
a1167 1
	rt_dup_full_path( &(cts->cts_p), pathp );
d1204 1
d1212 4
a1215 3
	rp->reg_name = rt_path_to_string( pathp );
#if 0
	/* XXX how to handle this?? */
d1217 1
a1217 2
#endif
	/* XXX really should use absolute treetop here?? */
d1219 5
d1240 1
a1240 1
	dp = pathp->fp_names[pathp->fp_len-1];
d1248 1
a1248 1
	curtree->tr_a.tu_name = rt_path_to_string( pathp );
d1258 1
a1258 1
db_walk_subtree( tp )
d1260 1
d1273 2
a1274 1
		ctsp->cts_s.ts_region_end_func = rt_gettree_p2_region_end;
d1276 8
a1283 1
		curtree = db_recurse( &ctsp->cts_s, &ctsp->cts_p );
d1286 2
d1292 1
a1292 1
		rt_free( (char *)ctsp, "combined region state" );
d1299 1
a1299 1
		db_walk_subtree( tp->tr_b.tb_left );
d1307 2
a1308 2
		db_walk_subtree( tp->tr_b.tb_left );
		db_walk_subtree( tp->tr_b.tb_right );
d1312 1
a1312 1
		rt_bomb("db_walk_subtree: bad op");
d1319 3
a1321 1
	int	mine;
d1331 24
a1354 2
		/* Doit */
		db_walk_subtree( db_reg_trees[mine] );
d1380 1
d1385 1
a1385 1
		rt_bomb("rt_gettree called again after rt_prep!");
d1406 4
a1409 1
	curtree = db_recurse( &ts, &path );
a1452 2

	/* XXX need to free path storage */
@


1.2
log
@Boolean push seems to work.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_tree.c,v 1.1 90/04/05 05:49:39 mike Locked $ (BRL)";
d510 2
a511 1
	struct region	*regionp = 0;	/* XXX */
d513 2
d737 1
a737 1
		curtree = (union tree *)0;
a772 1
	case OP_REGION:
d775 13
d821 1
a821 1
	if( tp->tr_op == OP_REGION || tp->tr_op == OP_SOLID )  return;
a913 2
		/* This lone solid will become a region */
		return(1);
d1056 138
d1271 10
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_walk.c,v 9.1 89/05/19 05:55:50 mike Rel3_5 $ (BRL)";
d39 3
d515 4
a518 1
		if(rt_g.debug&DEBUG_REGIONS) rt_pr_tree(curtree, 0);
d547 4
a550 1
		if(rt_g.debug&DEBUG_REGIONS) rt_pr_tree(tstart->tl_tree, 0);
d557 4
a560 1
	if(rt_g.debug&DEBUG_REGIONS) rt_pr_tree(curtree, 0);
d756 209
d1010 2
a1011 1
	curtree->tr_op = OP_SOLID;		/* XXX OP_REGION? */
d1035 1
a1035 1
	curtree->tr_op = OP_SOLID;		/* XXX OP_REGION? */
d1062 3
d1093 1
d1097 1
a1097 1
	 *  Third, push all non-union booleans down
d1099 17
@
