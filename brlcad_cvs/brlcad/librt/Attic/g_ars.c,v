head	11.37;
access;
symbols
	ansi-20040405-merged:11.33.2.2
	postmerge-20040405-ansi:11.35
	premerge-20040404-ansi:11.34
	postmerge-autoconf:11.34
	autoconf-freeze:11.33.10.2
	premerge-autoconf:11.34
	ansi-20040316-freeze:11.33.2.1
	postmerge-20040315-windows:11.34
	premerge-20040315-windows:11.34
	windows-20040315-freeze:11.33.4.1
	autoconf-20031203:11.33
	autoconf-20031202:11.33
	autoconf-branch:11.33.0.10
	phong-branch:11.33.0.8
	photonmap-branch:11.33.0.6
	rel-6-1-DP:11.33
	windows-branch:11.33.0.4
	rel-6-0-2:11.31
	ansi-branch:11.33.0.2
	rel-6-0-1-branch:11.31.0.2
	hartley-6-0-post:11.32
	hartley-6-0-pre:11.31
	rel-6-0-1:11.31
	rel-6-0:11.30
	rel-5-4:11.16
	offsite-5-3-pre:11.21
	rel-5-3:11.16
	rel-5-2:11.16
	rel-5-1-branch:11.16.0.2
	rel-5-1:11.16
	rel-5-0:11.8
	rel-5-0-beta:11.7
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.37
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	11.36;

11.36
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.35;

11.35
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.34;

11.34
date	2004.02.02.17.39.16;	author morrison;	state Exp;
branches;
next	11.33;

11.33
date	2002.08.20.17.07.58;	author jra;	state Exp;
branches
	11.33.2.1
	11.33.4.1
	11.33.10.1;
next	11.32;

11.32
date	2002.08.15.20.55.11;	author hartley;	state Exp;
branches;
next	11.31;

11.31
date	2002.05.28.18.42.17;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	2001.11.29.18.07.52;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	2001.11.26.19.37.44;	author butler;	state Exp;
branches;
next	11.28;

11.28
date	2001.11.07.19.35.38;	author butler;	state Exp;
branches;
next	11.27;

11.27
date	2001.10.02.19.24.28;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	2001.06.26.13.31.43;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	2001.06.21.18.32.06;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	2001.06.21.18.07.25;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	2001.05.17.20.05.24;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2001.04.05.19.35.34;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2000.07.13.02.36.25;	author cjohnson;	state Exp;
branches;
next	11.20;

11.20
date	2000.07.10.23.01.29;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.06.30.19.14.30;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	2000.06.30.15.38.02;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.06.30.15.31.14;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.06.08.20.54.32;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	2000.04.12.02.34.30;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.03.29.02.43.09;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	99.12.22.02.17.58;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	99.12.06.16.54.00;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.11.26.21.46.45;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.11.17.02.41.56;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.10.30.03.53.26;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.07.02.22.19.22;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.05.27.19.10.36;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.02.12.14.52.50;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.09.06.18.32.57;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.05.28.21.14.19;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	96.05.07.14.13.51;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.04.22.12.24.19;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.30;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.09.13.15.47.17;	author jra;	state Exp;
branches;
next	10.7;

10.7
date	94.09.09.14.22.11;	author jra;	state Exp;
branches;
next	10.6;

10.6
date	94.09.01.15.54.15;	author jra;	state Exp;
branches;
next	10.5;

10.5
date	94.09.01.12.12.14;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	94.08.10.18.24.02;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	93.11.18.01.43.59;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.03.26.22.01.59;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.12;	author mike;	state Rel4_0;
branches;
next	9.24;

9.24
date	91.09.20.22.51.05;	author butler;	state Exp;
branches;
next	9.23;

9.23
date	91.06.30.00.10.47;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.06.22.22.30.18;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	91.06.12.20.57.34;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.05.18.03.00.45;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.04.01.19.59.34;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.02.27.21.14.39;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.02.07.20.32.16;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.01.28.23.53.06;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.01.26.03.14.41;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.01.25.21.52.04;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.01.25.21.18.45;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.01.25.20.35.32;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.01.15.23.46.32;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.01.14.23.29.42;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.01.14.22.35.12;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.11.01.04.47.08;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.10.06.02.05.09;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.10.05.23.25.33;	author stay;	state Exp;
branches;
next	9.5;

9.5
date	90.07.31.17.23.19;	author stay;	state Exp;
branches;
next	9.4;

9.4
date	90.05.04.08.13.08;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.03.14.15.05.42;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.01.31.12.48.10;	author moss;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.04;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.04.17.17.18.51;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.11.12.02.07;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	88.12.06.00.02.34;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.10.18.14.33.18;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.30.58;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.07.15.04.13.43;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.05.14.00.00.55;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.06.05.36.23;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.32.47;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.11.02.15.29.42;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.55.15;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.10.46;	author mike;	state Rel;
branches;
next	4.6;

4.6
date	87.04.28.00.27.25;	author phil;	state Exp;
branches;
next	4.5;

4.5
date	87.03.23.23.42.29;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.03.11.01.25.59;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.03.10.23.42.10;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.12.22.10.46;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.44.33;	author mike;	state Rel1;
branches;
next	3.6;

3.6
date	86.12.24.08.05.25;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.08.12.04.15.08;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.07.24.06.08.27;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.19.04.37.57;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.17.18.19.20;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.11.01.31.27;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.32.31;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	86.06.09.21.49.51;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.02.54;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.08.03.08.16.58;	author mike;	state Exp;
branches;
next	;

11.33.2.1
date	2002.09.19.18.01.32;	author morrison;	state Exp;
branches;
next	11.33.2.2;

11.33.2.2
date	2004.03.17.21.18.45;	author morrison;	state Exp;
branches;
next	;

11.33.4.1
date	2004.03.11.23.43.36;	author morrison;	state Exp;
branches;
next	;

11.33.10.1
date	2004.02.12.18.37.39;	author erikg;	state Exp;
branches;
next	11.33.10.2;

11.33.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@ARS ray/geometry module for RT
@


11.37
log
@moved to src/
@
text
@/*
 *			G _ A R S . C
 *
 *  Function -
 *	Intersect a ray with an ARS (Arbitrary faceted solid)
 *  
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSars[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_ars.c,v 11.36 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include <ctype.h>
#include "tcl.h"
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"
#include "./plane.h"
#include "./bot.h"
#define TRI_NULL	((struct tri_specific *)0)

/* Describe algorithm here */

extern int rt_bot_minpieces;

/* from g_bot.c */
extern int rt_bot_prep( struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip );
extern void rt_bot_ifree( struct rt_db_internal *ip );

int rt_ars_tess( struct nmgregion **r, struct model *m, struct rt_db_internal *ip,
		 const struct rt_tess_tol *ttol, const struct bn_tol *tol );

void
rt_ars_free( register struct soltab *stp )
{
    bu_bomb("rt_ars_free s/b rt_bot_free\n");
}
int
rt_ars_class(const struct soltab	*stp,
	     const vect_t		min,
	     const vect_t		max,
	     const struct bn_tol	*tol)
{
    bu_bomb("rt_ars_class s/b rt_bot_class\n");
    return 0; /* not reached */
}


/*
 *			R T _ A R S _ R D _ C U R V E
 *
 *  rt_ars_rd_curve() reads a set of ARS B records and returns a pointer
 *  to a malloc()'ed memory area of fastf_t's to hold the curve.
 */
fastf_t *
rt_ars_rd_curve(union record *rp, int npts)
{
	LOCAL int lim;
	LOCAL fastf_t *base;
	register fastf_t *fp;		/* pointer to temp vector */
	register int i;
	LOCAL union record *rr;
	int	rec;

	/* Leave room for first point to be repeated */
	base = fp = (fastf_t *)bu_malloc(
	    (npts+1) * sizeof(fastf_t) * ELEMENTS_PER_VECT,
	    "ars curve" );

	rec = 0;
	for( ; npts > 0; npts -= 8 )  {
		rr = &rp[rec++];
		if( rr->b.b_id != ID_ARS_B )  {
			bu_log("rt_ars_rd_curve():  non-ARS_B record!\n");
			break;
		}
		lim = (npts>8) ? 8 : npts;
		for( i=0; i<lim; i++ )  {
			/* cvt from dbfloat_t */
			VMOVE( fp, (&(rr->b.b_values[i*3])) );
			fp += ELEMENTS_PER_VECT;
		}
	}
	return( base );
}




/*
 *			R T _ A R S _ I M P O R T
 *
 *  Read all the curves in as a two dimensional array.
 *  The caller is responsible for freeing the dynamic memory.
 *
 *  Note that in each curve array, the first point is replicated
 *  as the last point, to make processing the data easier.
 */
int
rt_ars_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_ars_internal *ari;
	union record	*rp;
	register int	i, j;
	LOCAL vect_t	base_vect;
	int		currec;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	if( rp->u_id != ID_ARS_A )  {
		bu_log("rt_ars_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_ARS;
	ip->idb_meth = &rt_functab[ID_ARS];
	ip->idb_ptr = bu_malloc(sizeof(struct rt_ars_internal), "rt_ars_internal");
	ari = (struct rt_ars_internal *)ip->idb_ptr;
	ari->magic = RT_ARS_INTERNAL_MAGIC;
	ari->ncurves = rp[0].a.a_m;
	ari->pts_per_curve = rp[0].a.a_n;

	/*
	 * Read all the curves into internal form.
	 */
	ari->curves = (fastf_t **)bu_malloc(
		(ari->ncurves+1) * sizeof(fastf_t **), "ars curve ptrs" );
	currec = 1;
	for( i=0; i < ari->ncurves; i++ )  {
		ari->curves[i] = 
			rt_ars_rd_curve( &rp[currec], ari->pts_per_curve );
		currec += (ari->pts_per_curve+7)/8;
	}

	/*
	 * Convert from vector to point notation IN PLACE
	 * by rotating vectors and adding base vector.
	 * Observe special treatment for base vector.
	 */
	for( i = 0; i < ari->ncurves; i++ )  {
		register fastf_t *v;

		v = ari->curves[i];
		for( j = 0; j < ari->pts_per_curve; j++ )  {
			LOCAL vect_t	homog;

			if( i==0 && j == 0 )  {
				/* base vector */
				VMOVE( homog, v );
				MAT4X3PNT( base_vect, mat, homog );
				VMOVE( v, base_vect );
			}  else  {
				MAT4X3VEC( homog, mat, v );
				VADD2( v, base_vect, homog );
			}
			v += ELEMENTS_PER_VECT;
		}
		VMOVE( v, ari->curves[i] );		/* replicate first point */
	}
	return( 0 );
}

/*
 *			R T _ A R S _ E X P O R T
 *
 *  The name will be added by the caller.
 *  Generally, only libwdb will set conv2mm != 1.0
 */
int
rt_ars_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_ars_internal	*arip;
	union record		*rec;
	point_t		base_pt;
	int		per_curve_grans;
	int		cur;		/* current curve number */
	int		gno;		/* current granule number */

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ARS )  return(-1);
	arip = (struct rt_ars_internal *)ip->idb_ptr;
	RT_ARS_CK_MAGIC(arip);

	per_curve_grans = (arip->pts_per_curve+7)/8;

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = (1 + per_curve_grans * arip->ncurves) *
		sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "ars external");
	rec = (union record *)ep->ext_buf;

	rec[0].a.a_id = ID_ARS_A;
	rec[0].a.a_type = ARS;			/* obsolete? */
	rec[0].a.a_m = arip->ncurves;
	rec[0].a.a_n = arip->pts_per_curve;
	rec[0].a.a_curlen = per_curve_grans;
	rec[0].a.a_totlen = per_curve_grans * arip->ncurves;

	VMOVE( base_pt, &arip->curves[0][0] );
	gno = 1;
	for( cur=0; cur<arip->ncurves; cur++ )  {
		register fastf_t	*fp;
		int			npts;
		int			left;

		fp = arip->curves[cur];
		left = arip->pts_per_curve;
		for( npts=0; npts < arip->pts_per_curve; npts+=8, left -= 8 )  {
			register int	el;
			register int	lim;
			register struct ars_ext	*bp = &rec[gno].b;

			bp->b_id = ID_ARS_B;
			bp->b_type = ARSCONT;	/* obsolete? */
			bp->b_n = cur+1;		/* obsolete? */
			bp->b_ngranule = (npts/8)+1; /* obsolete? */

			lim = (left > 8 ) ? 8 : left;
			for( el=0; el < lim; el++ )  {
				vect_t	diff;
				if( cur==0 && npts==0 && el==0 )
					VSCALE( diff , fp , local2mm )
				else
					VSUB2SCALE( diff, fp, base_pt, local2mm )
				/* NOTE: also type converts to dbfloat_t */
				VMOVE( &(bp->b_values[el*3]), diff );
				fp += ELEMENTS_PER_VECT;
			}
			gno++;
		}
	}
	return(0);
}


/*
 *			R T _ A R S _ I M P O R T 5
 *
 *  Read all the curves in as a two dimensional array.
 *  The caller is responsible for freeing the dynamic memory.
 *
 *  Note that in each curve array, the first point is replicated
 *  as the last point, to make processing the data easier.
 */
int
rt_ars_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_ars_internal *ari;
	register int		i, j;
	register unsigned char	*cp;
	vect_t			tmp_vec;
	register fastf_t	*fp;

	BU_CK_EXTERNAL( ep );
	RT_CK_DB_INTERNAL( ip );

	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_ARS;
	ip->idb_meth = &rt_functab[ID_ARS];
	ip->idb_ptr = bu_malloc(sizeof(struct rt_ars_internal), "rt_ars_internal");

	ari = (struct rt_ars_internal *)ip->idb_ptr;
	ari->magic = RT_ARS_INTERNAL_MAGIC;

	cp = (unsigned char *)ep->ext_buf;
	ari->ncurves = bu_glong( cp );
	cp += SIZEOF_NETWORK_LONG;
	ari->pts_per_curve = bu_glong( cp );
	cp += SIZEOF_NETWORK_LONG;

	/*
	 * Read all the curves into internal form.
	 */
	ari->curves = (fastf_t **)bu_calloc(
		(ari->ncurves+1), sizeof(fastf_t *), "ars curve ptrs" );
	for( i=0; i < ari->ncurves; i++ )  {
		ari->curves[i] = (fastf_t *)bu_calloc( (ari->pts_per_curve + 1) * 3,
			sizeof( fastf_t ), "ARS points" );
		fp = ari->curves[i];
		for( j=0 ; j<ari->pts_per_curve ; j++ ) {
			ntohd( (unsigned char *)tmp_vec, cp, 3 );
			MAT4X3PNT( fp, mat, tmp_vec );
			cp += 3 * SIZEOF_NETWORK_DOUBLE;
			fp += ELEMENTS_PER_VECT;
		}
		VMOVE( fp, ari->curves[i] );	/* duplicate first point */
	}
	return( 0 );
}

/*
 *			R T _ A R S _ E X P O R T 5
 *
 *  The name will be added by the caller.
 *  Generally, only libwdb will set conv2mm != 1.0
 */
int
rt_ars_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_ars_internal	*arip;
	unsigned char	*cp;
	vect_t		tmp_vec;
	int		cur;		/* current curve number */

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ARS )  return(-1);
	arip = (struct rt_ars_internal *)ip->idb_ptr;
	RT_ARS_CK_MAGIC(arip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = 2 * SIZEOF_NETWORK_LONG +
		3 * arip->ncurves * arip->pts_per_curve * SIZEOF_NETWORK_DOUBLE;
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "ars external");
	cp = (unsigned char *)ep->ext_buf;

	(void)bu_plong( cp, arip->ncurves );
	cp += SIZEOF_NETWORK_LONG;
	(void)bu_plong( cp, arip->pts_per_curve );
	cp += SIZEOF_NETWORK_LONG;

	for( cur=0; cur<arip->ncurves; cur++ )  {
		register fastf_t	*fp;
		int			npts;

		fp = arip->curves[cur];
		for( npts=0; npts < arip->pts_per_curve; npts++ )  {
			VSCALE( tmp_vec, fp, local2mm );
			ntohd( cp, (unsigned char *)tmp_vec, 3 );
			cp += 3 * SIZEOF_NETWORK_DOUBLE;
			fp += ELEMENTS_PER_VECT;
		}
	}
	return(0);
}

/*
 *			R T _ A R S _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_ars_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register int			j;
	register struct rt_ars_internal	*arip =
		(struct rt_ars_internal *)ip->idb_ptr;
	char				buf[256];
	int				i;

	RT_ARS_CK_MAGIC(arip);
	bu_vls_strcat( str, "arbitrary rectangular solid (ARS)\n");

	sprintf(buf, "\t%d curves, %d points per curve\n",
		arip->ncurves, arip->pts_per_curve );
	bu_vls_strcat( str, buf );

	if( arip->ncurves > 0 ) {
		sprintf(buf, "\tV (%g, %g, %g)\n",
			arip->curves[0][X] * mm2local,
			arip->curves[0][Y] * mm2local,
			arip->curves[0][Z] * mm2local );
		bu_vls_strcat( str, buf );
	}

	if( !verbose )  return(0);

	/* Print out all the points */
	for( i=0; i < arip->ncurves; i++ )  {
		register fastf_t *v = arip->curves[i];

		sprintf( buf, "\tCurve %d:\n", i );
		bu_vls_strcat( str, buf );
		for( j=0; j < arip->pts_per_curve; j++ )  {
			sprintf(buf, "\t\t(%g, %g, %g)\n",
				v[X] * mm2local,
				v[Y] * mm2local,
				v[Z] * mm2local );
			bu_vls_strcat( str, buf );
			v += ELEMENTS_PER_VECT;
		}
	}

	return(0);
}

/*
 *			R T _ A R S _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_ars_ifree(struct rt_db_internal *ip)
{
	register struct rt_ars_internal	*arip;
	register int			i;

	RT_CK_DB_INTERNAL(ip);
	arip = (struct rt_ars_internal *)ip->idb_ptr;
	RT_ARS_CK_MAGIC(arip);

	/*
	 *  Free storage for faces
	 */
	for( i = 0; i < arip->ncurves; i++ )  {
		bu_free( (char *)arip->curves[i], "ars curve" );
	}
	bu_free( (char *)arip->curves, "ars curve ptrs" );
	arip->magic = 0;		/* sanity */
	arip->ncurves = 0;
	bu_free( (char *)arip, "ars ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

/*
 *			R T _ A R S _ P R E P
 *  
 *  This routine is used to prepare a list of planar faces for
 *  being shot at by the ars routines.
 *
 * Process an ARS, which is represented as a vector
 * from the origin to the first point, and many vectors
 * from the first point to the remaining points.
 *  
 *  This routine is unusual in that it has to read additional
 *  database records to obtain all the necessary information.
 */
int
rt_ars_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
#if 1
    struct rt_db_internal intern;
    struct rt_bot_internal *bot;
    struct model *m;
    struct nmgregion *r;
    struct shell *s;
    int ret;

    m = nmg_mm();
    r = BU_LIST_FIRST( nmgregion, &m->r_hd );

    if( rt_ars_tess( &r, m, ip, &rtip->rti_ttol, &rtip->rti_tol) ) {
	    bu_log( "Failed to tessellate ARS (%s)\n", stp->st_dp->d_namep );
	    nmg_km( m );
	    return( -1 );
    }
    rt_ars_ifree( ip );

    s = BU_LIST_FIRST( shell, &r->s_hd );
    bot = nmg_bot( s, &rtip->rti_tol );

    if( !bot ) {
	    bu_log( "Failed to convert ARS to BOT (%s)\n", stp->st_dp->d_namep );
	    nmg_km( m );
	    return( -1 );
    }

    nmg_km( m );

    intern.idb_magic = RT_DB_INTERNAL_MAGIC;
    intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
    intern.idb_minor_type = ID_BOT;
    intern.idb_meth = &rt_functab[ID_BOT];
    intern.idb_ptr = (genptr_t)bot;
    bu_avs_init( &intern.idb_avs, 0, "ARS to a BOT for prep" );

    ret = rt_bot_prep( stp, &intern, rtip );

    rt_bot_ifree( &intern );

    return( ret );
#else
    LOCAL fastf_t	dx, dy, dz;	/* For finding the bounding spheres */
    int	i, j, ntri;
    LOCAL fastf_t	f;
    struct rt_ars_internal	*arip;
    struct bot_specific	*bot;
    const struct bn_tol		*tol = &rtip->rti_tol;
    int ncv;

    arip = (struct rt_ars_internal *)ip->idb_ptr;
    RT_ARS_CK_MAGIC(arip);

    /* initialize the Bag-'o-triangles structure we need */
    BU_GETSTRUCT( bot, bot_specific );
    stp->st_specific = (genptr_t)bot;
    bot->bot_mode = RT_BOT_SOLID;
    bot->bot_orientation = RT_BOT_UNORIENTED;
    bot->bot_errmode = (unsigned char)NULL;
    bot->bot_thickness = (fastf_t *)NULL;
    bot->bot_facemode = (struct bu_bitv *)NULL;
    bot->bot_facelist = (struct tri_specific *)NULL;

    /*
     * Compute bounding sphere.
     * Find min and max of the point co-ordinates.
     */
    VSETALL( stp->st_max, -INFINITY );
    VSETALL( stp->st_min,  INFINITY );

    for( i = 0; i < arip->ncurves; i++ )  {
	register fastf_t *v;

	v = arip->curves[i];
	for( j = 0; j < arip->pts_per_curve; j++ )  {
	    VMINMAX( stp->st_min, stp->st_max, v );
	    v += ELEMENTS_PER_VECT;
	}
    }
    VSET( stp->st_center,
	  (stp->st_max[X] + stp->st_min[X])/2,
	  (stp->st_max[Y] + stp->st_min[Y])/2,
	  (stp->st_max[Z] + stp->st_min[Z])/2 );

    dx = (stp->st_max[X] - stp->st_min[X])/2;
    f = dx;
    dy = (stp->st_max[Y] - stp->st_min[Y])/2;
    if( dy > f )  f = dy;
    dz = (stp->st_max[Z] - stp->st_min[Z])/2;
    if( dz > f )  f = dz;
    stp->st_aradius = f;
    stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);


    /*
     *  Compute planar faces
     *  Will examine curves[i][pts_per_curve], provided by rt_ars_rd_curve.
     */
    ncv = arip->ncurves-2;
    ntri = 0;
    for(i=0; i <= ncv; i++ )  {
	register fastf_t *v1, *v2;

	v1 = arip->curves[i];
	v2 = arip->curves[i+1];
	for( j = 0; j < arip->pts_per_curve;
	     j++, v1 += ELEMENTS_PER_VECT, v2 += ELEMENTS_PER_VECT )  {

	    /* XXX make sure the faces are actual triangles */


	    /* carefully make faces, w/inward pointing normals */
	    /* [0][0] [1][1], [0][1] */
	    if (i != 0 && 
		rt_botface(stp, bot, &v1[0], &v2[ELEMENTS_PER_VECT],
			   &v1[ELEMENTS_PER_VECT], ntri, tol) > 0)   ntri++;

	    /* [1][0] [1][1] [0][0] */
	    if (i < ncv &&
		rt_botface(stp, bot, &v2[0], &v2[ELEMENTS_PER_VECT],
			   &v1[0], ntri, tol) > 0)   ntri++;
	}
    }


    if( bot->bot_facelist == (struct tri_specific *)0 )  {
	bu_log("ars(%s):  no faces\n", stp->st_name);
	return(-1);             /* BAD */
    }

    bot->bot_ntri = ntri;


    /*
     *  Support for solid 'pieces'
     *  For now, each triangle is considered a separate piece.
     *  These array allocations can't be made until the number of
     *  triangles are known.
     *
     *  If the number of triangles is too small,
     *  don't bother making pieces, the overhead isn't worth it.
     *
     *  To disable BoT pieces, on the RT command line specify:
     *	-c "set rt_bot_minpieces=0"
     */
    if( rt_bot_minpieces <= 0 )  return 0;
    if( ntri < rt_bot_minpieces )  return 0;


    rt_bot_prep_pieces(bot, stp, ntri, tol);

    rt_ars_ifree( ip );


    return(0);		/* OK */
#endif
}


/*
 *  			R T _ A R S _ P R I N T
 */
void
rt_ars_print(register const struct soltab *stp)
{
	register struct tri_specific *trip =
		(struct tri_specific *)stp->st_specific;

	if( trip == TRI_NULL )  {
		bu_log("ars(%s):  no faces\n", stp->st_name);
		return;
	}
	do {
		VPRINT( "A", trip->tri_A );
		VPRINT( "B-A", trip->tri_BA );
		VPRINT( "C-A", trip->tri_CA );
		VPRINT( "BA x CA", trip->tri_wn );
		VPRINT( "Normal", trip->tri_N );
		bu_log("\n");
	} while( (trip = trip->tri_forw) );
}

/*
 *			R T _ A R S _ S H O T
 *  
 * Function -
 *	Shoot a ray at an ARS.
 *  
 * Returns -
 *	0	MISS
 *  	!0	HIT
 */
int
rt_ars_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct tri_specific *trip =
		(struct tri_specific *)stp->st_specific;
#define RT_ARS_MAXHITS 128		/* # surfaces hit, must be even */
	LOCAL struct hit hits[RT_ARS_MAXHITS];
	register struct hit *hp;
	LOCAL int	nhits;

	nhits = 0;
	hp = &hits[0];

	/* consider each face */
	for( ; trip; trip = trip->tri_forw )  {
		FAST fastf_t	dn;		/* Direction dot Normal */
		LOCAL fastf_t	abs_dn;
		FAST fastf_t	k;
		LOCAL fastf_t	alpha, beta;
		LOCAL fastf_t	ds;
		LOCAL vect_t	wxb;		/* vertex - ray_start */
		LOCAL vect_t	xp;		/* wxb cross ray_dir */

		/*
		 *  Ray Direction dot N.  (wn is inward pointing normal)
		 */
		dn = VDOT( trip->tri_wn, rp->r_dir );
		if( RT_G_DEBUG & DEBUG_ARB8 )
			bu_log("N.Dir=%g ", dn );

		/*
		 *  If ray lies directly along the face, drop this face.
		 */
		abs_dn = dn >= 0.0 ? dn : (-dn);
		if( abs_dn < 1.0e-10 )
			continue;
		VSUB2( wxb, trip->tri_A, rp->r_pt );
		VCROSS( xp, wxb, rp->r_dir );

		/* Check for exceeding along the one side */
		alpha = VDOT( trip->tri_CA, xp );
		if( dn < 0.0 )  alpha = -alpha;
		if( alpha < 0.0 || alpha > abs_dn )
			continue;

		/* Check for exceeding along the other side */
		beta = VDOT( trip->tri_BA, xp );
		if( dn > 0.0 )  beta = -beta;
		if( beta < 0.0 || beta > abs_dn )
			continue;
		if( alpha+beta > abs_dn )
			continue;
		ds = VDOT( wxb, trip->tri_wn );
		k = ds / dn;		/* shot distance */

		/* For hits other than the first one, might check
		 *  to see it this is approx. equal to previous one */

		/*  If dn < 0, we should be entering the solid.
		 *  However, we just assume in/out sorting later will work.
		 */
		hp->hit_magic = RT_HIT_MAGIC;
		hp->hit_dist = k;
		hp->hit_private = (char *)trip;
		hp->hit_vpriv[X] = dn;
		hp->hit_rayp = rp;

		if(RT_G_DEBUG&DEBUG_ARB8) bu_log("ars: dist k=%g, ds=%g, dn=%g\n", k, ds, dn );

		/* Bug fix: next line was "nhits++".  This caused rt_hitsort
			to exceed bounds of "hits" array by one member and
			clobber some stack variables i.e. "stp" -- GSM */
		if( ++nhits >= RT_ARS_MAXHITS )  {
			bu_log("ars(%s): too many hits\n", stp->st_name);
			break;
		}
		hp++;
	}
	if( nhits == 0 )
		return(0);		/* MISS */

	/* Sort hits, Near to Far */
	rt_hitsort( hits, nhits );

	/* Remove duplicate hits.
	   We remove one of a pair of hits when they are
		1) close together, and
		2) both "entry" or both "exit" occurrences.
	   Two immediate "entry" or two immediate "exit" hits suggest
	   that we hit both of two joined faces, while we want to hit only
	   one.  An "entry" followed by an "exit" (or vice versa) suggests
	   that we grazed an edge, and thus we should leave both
	   in the hit list. */
	
	{
		register int i, j;

		if( nhits )
			RT_HIT_NORM( &hits[0], stp, 0 )

		for( i=0 ; i<nhits-1 ; i++ )
		{
			fastf_t dist;

			RT_HIT_NORM( &hits[i+1], stp, 0 )
			dist = hits[i].hit_dist - hits[i+1].hit_dist;
			if( NEAR_ZERO( dist, ap->a_rt_i->rti_tol.dist ) &&
				VDOT( hits[i].hit_normal, rp->r_dir ) *
			        VDOT( hits[i+1].hit_normal, rp->r_dir) > 0)
			{
				for( j=i ; j<nhits-1 ; j++ )
					hits[j] = hits[j+1];
				nhits--;
				i--;
			}
		}
	}

	if( nhits&1 )  {
		register int i;
		/*
		 * If this condition exists, it is almost certainly due to
		 * the dn==0 check above.  Just log error.
		 */
		bu_log("ERROR: ars(%s): %d hits odd, skipping solid\n",
			stp->st_name, nhits);
		for(i=0; i < nhits; i++ )
			bu_log("k=%g dn=%g\n",
				hits[i].hit_dist, hp->hit_vpriv[X]);
		return(0);		/* MISS */
	}

	/* nhits is even, build segments */
	{
		register struct seg *segp;
		register int	i,j;

		/* Check in/out properties */
		for( i=nhits; i > 0; i -= 2 )  {
			if( hits[i-2].hit_vpriv[X] >= 0 )
				continue;		/* seg_in */
			if( hits[i-1].hit_vpriv[X] <= 0 )
				continue;		/* seg_out */

#ifndef CONSERVATIVE
			/* if this segment is small enough, just swap the in/out hits */
			if( (hits[i-1].hit_dist - hits[i-2].hit_dist) < 200.0*RT_LEN_TOL )
			{
				struct hit temp;
				fastf_t temp_dist;

				temp_dist = hits[i-1].hit_dist;
				hits[i-1].hit_dist = hits[i-2].hit_dist;
				hits[i-2].hit_dist = temp_dist;

				temp = hits[i-1];	/* struct copy */
				hits[i-1] = hits[i-2];	/* struct copy */
				hits[i-2] = temp;	/* struct copy */
				continue;
			}
#endif
		   	bu_log("ars(%s): in/out error\n", stp->st_name );
			for( j=nhits-1; j >= 0; j-- )  {
		   		bu_log("%d %s dist=%g dn=%g\n",
					j,
					((hits[j].hit_vpriv[X] > 0) ?
		   				" In" : "Out" ),
			   		hits[j].hit_dist,
					hits[j].hit_vpriv[X] );
				if( j>0 )
					bu_log( "\tseg length = %g\n", hits[j].hit_dist - hits[j-1].hit_dist );
		   	}
#ifdef CONSERVATIVE
		   	return(0);
#else
			/* For now, just chatter, and return *something* */
			break;
#endif
		}

		for( i=nhits; i > 0; i -= 2 )  {
			RT_GET_SEG(segp, ap->a_resource);
			segp->seg_stp = stp;
			segp->seg_in = hits[i-2];	/* struct copy */
			segp->seg_out = hits[i-1];	/* struct copy */
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		}
	}
	return(nhits);			/* HIT */
}

/*
 *			R T _ H I T S O R T
 *
 *  Sort an array of hits into ascending order.
 */
void
rt_hitsort(register struct hit *h, register int nh)
{
	register int i, j;
	LOCAL struct hit temp;

	for( i=0; i < nh-1; i++ )  {
		for( j=i+1; j < nh; j++ )  {
			if( h[i].hit_dist <= h[j].hit_dist )
				continue;
			temp = h[j];		/* struct copy */
			h[j] = h[i];		/* struct copy */
			h[i] = temp;		/* struct copy */
		}
	}
}

/*
 *  			R T _ A R S _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_ars_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct tri_specific *trip =
		(struct tri_specific *)hitp->hit_private;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	VMOVE( hitp->hit_normal, trip->tri_N );
}

/*
 *			R T _ A R S _ C U R V E
 *
 *  Return the "curvature" of the ARB face.
 *  Pick a principle direction orthogonal to normal, and 
 *  indicate no curvature.
 */
void
rt_ars_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
/*	register struct tri_specific *trip =
 *		(struct tri_specific *)hitp->hit_private;
 */
	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
	cvp->crv_c1 = cvp->crv_c2 = 0;
}

/*
 *  			R T _ A R S _ U V
 *  
 *  For a hit on a face of an ARB, return the (u,v) coordinates
 *  of the hit point.  0 <= u,v <= 1.
 *  u extends along the Xbasis direction defined by B-A,
 *  v extends along the "Ybasis" direction defined by (B-A)xN.
 */
void
rt_ars_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct tri_specific *trip =
		(struct tri_specific *)hitp->hit_private;
	LOCAL vect_t P_A;
	LOCAL fastf_t r;
	LOCAL fastf_t xxlen, yylen;

	xxlen = MAGNITUDE(trip->tri_BA);
	yylen = MAGNITUDE(trip->tri_CA);

	VSUB2( P_A, hitp->hit_point, trip->tri_A );
	/* Flipping v is an artifact of how the faces are built */
	uvp->uv_u = VDOT( P_A, trip->tri_BA ) * xxlen;
	uvp->uv_v = 1.0 - ( VDOT( P_A, trip->tri_CA ) * yylen );
	if( uvp->uv_u < 0 || uvp->uv_v < 0 )  {
		if( RT_G_DEBUG )
			bu_log("rt_ars_uv: bad uv=%g,%g\n", uvp->uv_u, uvp->uv_v);
		/* Fix it up */
		if( uvp->uv_u < 0 )  uvp->uv_u = (-uvp->uv_u);
		if( uvp->uv_v < 0 )  uvp->uv_v = (-uvp->uv_v);
	}
	r = ap->a_rbeam + ap->a_diverge * hitp->hit_dist;
	uvp->uv_du = r * xxlen;
	uvp->uv_dv = r * yylen;
}


/*
 *			R T _ A R S _ P L O T
 */
int
rt_ars_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register int	i;
	register int	j;
	struct rt_ars_internal	*arip;

	RT_CK_DB_INTERNAL(ip);
	arip = (struct rt_ars_internal *)ip->idb_ptr;
	RT_ARS_CK_MAGIC(arip);

	/*
	 *  Draw the "waterlines", by tracing each curve.
	 *  n+1th point is first point replicated by code above.
	 */
	for( i = 0; i < arip->ncurves; i++ )  {
		register fastf_t *v1;

		v1 = arip->curves[i];
		RT_ADD_VLIST( vhead, v1, BN_VLIST_LINE_MOVE );
		v1 += ELEMENTS_PER_VECT;
		for( j = 1; j <= arip->pts_per_curve; j++, v1 += ELEMENTS_PER_VECT )
			RT_ADD_VLIST( vhead, v1, BN_VLIST_LINE_DRAW );
	}

	/*
	 *  Connect the Ith points on each curve, to make a mesh.
	 */
	for( i = 0; i < arip->pts_per_curve; i++ )  {
		RT_ADD_VLIST( vhead, &arip->curves[0][i*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
		for( j = 1; j < arip->ncurves; j++ )
			RT_ADD_VLIST( vhead, &arip->curves[j][i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	return(0);
}

#define IJ(ii,jj)	(((i+(ii))*(arip->pts_per_curve+1))+(j+(jj)))
#define ARS_PT(ii,jj)	(&arip->curves[i+(ii)][(j+(jj))*ELEMENTS_PER_VECT])
#define FIND_IJ(a,b)	\
	if( !(verts[IJ(a,b)]) )  { \
		verts[IJ(a,b)] = \
		nmg_find_pt_in_shell( s, ARS_PT(a,b), tol ); \
	}
#define ASSOC_GEOM(corn, a,b)	\
	if( !((*corners[corn])->vg_p) )  { \
		nmg_vertex_gv( *(corners[corn]), ARS_PT(a,b) ); \
	}
/*
 *			R T _ A R S _ T E S S
 */
int
rt_ars_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register int	i;
	register int	j;
	register int	k;
	struct rt_ars_internal	*arip;
	struct shell	*s;
	struct vertex	**verts;
	struct faceuse	*fu;
	struct bu_ptbl	kill_fus;
	int		bad_ars=0;

	RT_CK_DB_INTERNAL(ip);
	arip = (struct rt_ars_internal *)ip->idb_ptr;
	RT_ARS_CK_MAGIC(arip);

	/* Check for a legal ARS */
	for( i = 0; i < arip->ncurves-1; i++ )
	{
		for( j = 2; j < arip->pts_per_curve; j++ )
		{
			fastf_t dist;
			vect_t pca;
			int code;

			if( VAPPROXEQUAL( ARS_PT(0,-2), ARS_PT(0,-1), tol->dist ) )
				continue;

			code = bn_dist_pt3_lseg3( &dist, pca, ARS_PT(0,-2), ARS_PT(0,-1), ARS_PT(0,0), tol );

			if( code < 2 )
			{
				bu_log( "ARS curve backtracks on itself!!!\n" );
				bu_log( "\tCurve #%d, points #%d through %d are:\n", i, j-2, j );
				bu_log( "\t\t%d (%f %f %f)\n", j-2, V3ARGS( ARS_PT(0,-2) ) );
				bu_log( "\t\t%d (%f %f %f)\n", j-1, V3ARGS( ARS_PT(0,-1) ) );
				bu_log( "\t\t%d (%f %f %f)\n", j, V3ARGS( ARS_PT(0,0) ) );
				bad_ars = 1;
				j++;
			}
		}
	}

	if( bad_ars )
	{
		bu_log( "TESSELATION FAILURE: This ARS solid has not been tesselated.\n\tAny result you may obtain is incorrect.\n" );
		return( -1 );
	}

	bu_ptbl_init( &kill_fus, 64, " &kill_fus");

	/* Build the topology of the ARS.  Start by allocating storage */

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	verts = (struct vertex **)bu_calloc( arip->ncurves * (arip->pts_per_curve+1),
		sizeof(struct vertex *),
		"rt_tor_tess *verts[]" );

	/*
	 *  Draw the "waterlines", by tracing each curve.
	 *  n+1th point is first point replicated by import code.
	 */
	k = arip->pts_per_curve-2;	/* next to last point on curve */
	for( i = 0; i < arip->ncurves-1; i++ )  {
		int double_ended;

		if( k != 1 && VAPPROXEQUAL( &arip->curves[i][1*ELEMENTS_PER_VECT], &arip->curves[i][k*ELEMENTS_PER_VECT], tol->dist ) )
			double_ended = 1;
		else
			double_ended = 0;

		for( j = 0; j < arip->pts_per_curve; j++ )  {
			struct vertex **corners[3];


			if( double_ended &&
			     i != 0 &&
			     ( j == 0 || j == k || j == arip->pts_per_curve-1 ) )
					continue;

			/*
			 *  First triangular face
			 */
			if( bn_3pts_distinct( ARS_PT(0,0), ARS_PT(1,1),
				ARS_PT(0,1), tol )
			   && !bn_3pts_collinear( ARS_PT(0,0), ARS_PT(1,1),
				ARS_PT(0,1), tol )
			)  {
				/* Locate these points, if previously mentioned */
				FIND_IJ(0, 0);
				FIND_IJ(1, 1);
				FIND_IJ(0, 1);

				/* Construct first face topology, CCW order */
				corners[0] = &verts[IJ(0,0)];
				corners[1] = &verts[IJ(0,1)];
				corners[2] = &verts[IJ(1,1)];

				if( (fu = nmg_cmface( s, corners, 3 )) == (struct faceuse *)0 )  {
					bu_log("rt_ars_tess() nmg_cmface failed, skipping face a[%d][%d]\n",
						i,j);
				}

				/* Associate vertex geometry, if new */
				ASSOC_GEOM( 0, 0, 0 );
				ASSOC_GEOM( 1, 0, 1 );
				ASSOC_GEOM( 2, 1, 1 );
				if( nmg_calc_face_g( fu ) )
				{
					bu_log( "Degenerate face created, will kill it later\n" );
					bu_ptbl_ins( &kill_fus, (long *)fu );
				}
			}

			/*
			 *  Second triangular face
			 */
			if( bn_3pts_distinct( ARS_PT(1,0), ARS_PT(1,1),
				ARS_PT(0,0), tol )
			   && !bn_3pts_collinear( ARS_PT(1,0), ARS_PT(1,1),
				ARS_PT(0,0), tol )
			)  {
				/* Locate these points, if previously mentioned */
				FIND_IJ(1, 0);
				FIND_IJ(1, 1);
				FIND_IJ(0, 0);

				/* Construct second face topology, CCW */
				corners[0] = &verts[IJ(1,0)];
				corners[1] = &verts[IJ(0,0)];
				corners[2] = &verts[IJ(1,1)];

				if( (fu = nmg_cmface( s, corners, 3 )) == (struct faceuse *)0 )  {
					bu_log("rt_ars_tess() nmg_cmface failed, skipping face b[%d][%d]\n",
						i,j);
				}

				/* Associate vertex geometry, if new */
				ASSOC_GEOM( 0, 1, 0 );
				ASSOC_GEOM( 1, 0, 0 );
				ASSOC_GEOM( 2, 1, 1 );
				if( nmg_calc_face_g( fu ) )
				{
					bu_log( "Degenerate face created, will kill it later\n" );
					bu_ptbl_ins( &kill_fus, (long *)fu );
				}
			}
		}
	}

	bu_free( (char *)verts, "rt_ars_tess *verts[]" );

	/* kill any degenerate faces that may have been created */
	for( i=0 ; i<BU_PTBL_END( &kill_fus ) ; i++ )
	{
		fu = (struct faceuse *)BU_PTBL_GET( &kill_fus, i );
		NMG_CK_FACEUSE( fu );
		(void)nmg_kfu( fu );
	}

	/* ARS solids are often built with incorrect face normals.
	 * Don't depend on them to be correct.
	 */
	nmg_fix_normals( s , tol );

	/* set edge's is_real flag */
	nmg_mark_edges_real( &s->l.magic );

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

	return(0);
}

int
rt_ars_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
	register struct rt_ars_internal *ars=(struct rt_ars_internal *)intern->idb_ptr;
	Tcl_DString	ds;
	struct bu_vls	vls;
	int		i,j;

	RT_ARS_CK_MAGIC( ars );

	Tcl_DStringInit( &ds );
	bu_vls_init( &vls );

	if( attr == (char *)NULL ) {
		bu_vls_strcpy( &vls, "ars" );
		bu_vls_printf( &vls, " NC %d PPC %d", ars->ncurves, ars->pts_per_curve );
		for( i=0 ; i<ars->ncurves ; i++ ) {
			bu_vls_printf( &vls, " C%d {", i );
			for( j=0 ; j<ars->pts_per_curve ; j++ ) {
				bu_vls_printf( &vls, " { %.25g %.25g %.25g }",
					       V3ARGS( &ars->curves[i][j*3] ) );
			}
			bu_vls_printf( &vls, " }" );
		}
	}
	else if( !strcmp( attr, "NC" ) ) {
		bu_vls_printf( &vls, "%d", ars->ncurves );
	}
	else if( !strcmp( attr, "PPC" ) ) {
		bu_vls_printf( &vls, "%d", ars->pts_per_curve );
	}
	else if( attr[0] == 'C' ) {
		char *ptr;

		if( attr[1] == '\0' ) {
			/* all the curves */
			for( i=0 ; i<ars->ncurves ; i++ ) {
				bu_vls_printf( &vls, " C%d {", i );
				for( j=0 ; j<ars->pts_per_curve ; j++ ) {
					bu_vls_printf( &vls, " { %.25g %.25g %.25g }",
						       V3ARGS( &ars->curves[i][j*3] ) );
				}
				bu_vls_printf( &vls, " }" );
			}
		}
		else if( !isdigit( attr[1] ) ) {
			Tcl_SetResult( interp,
			      "ERROR: illegal argument, must be NC, PPC, C, C#, or C#P#\n",
			      TCL_STATIC );
			return( TCL_ERROR );
		}

		if( (ptr=strchr( attr, 'P' )) ) {
			/* a specific point on a specific curve */
			if( !isdigit( *(ptr+1) ) ) {
			   Tcl_SetResult( interp,
			       "ERROR: illegal argument, must be NC, PPC, C, C#, or C#P#\n",
				TCL_STATIC );
			   return( TCL_ERROR );
			}
			j = atoi( (ptr+1) );
			*ptr = '\0';
			i = atoi( &attr[1] );
			bu_vls_printf( &vls, "%.25g %.25g %.25g",
				 V3ARGS( &ars->curves[i][j*3] ) );      
		}
		else {
			/* the entire curve */
			i = atoi( &attr[1] );
			for( j=0 ; j<ars->pts_per_curve ; j++ ) {
				bu_vls_printf( &vls, " { %.25g %.25g %.25g }",
					       V3ARGS( &ars->curves[i][j*3] ) );
			}
		}
	}
	Tcl_DStringAppend( &ds, bu_vls_addr( &vls ), -1 );
	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );
	bu_vls_free( &vls );
	return( TCL_OK );
}

int
rt_ars_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
{
	struct rt_ars_internal		*ars;
	int				i,j,k;
	int				len;
	fastf_t				*array;

	RT_CK_DB_INTERNAL( intern );

	ars = (struct rt_ars_internal *)intern->idb_ptr;
	RT_ARS_CK_MAGIC( ars );

	while( argc >= 2 ) {
		if( !strcmp( argv[0], "NC" ) ) {
			/* change number of curves */
			i = atoi( argv[1] );
			if( i < ars->ncurves ) {
				for( j=i ; j<ars->ncurves ; j++ )
					bu_free( (char *)ars->curves[j], "ars->curves[j]" );
				ars->curves = (fastf_t **)bu_realloc( ars->curves,
						    i*sizeof( fastf_t *), "ars->curves" );
				ars->ncurves = i;
			}
			else if( i > ars->ncurves ) {
				ars->curves = (fastf_t **)bu_realloc( ars->curves,
						    i*sizeof( fastf_t *), "ars->curves" );
				if( ars->pts_per_curve ) {
				        /* new curves are duplicates of the last */
					for( j=ars->ncurves ; j<i ; j++ ) {
					    ars->curves[j] = (fastf_t *)bu_malloc(
						 ars->pts_per_curve * 3 * sizeof( fastf_t ),
								    "ars->curves[j]" );
					    for( k=0 ; k<ars->pts_per_curve ; k++ ) {
						 if ( j ) {
							 VMOVE( &ars->curves[j][k*3],
								&ars->curves[j-1][k*3] );
						 }
						 else {
							 VSETALL(&ars->curves[j][k*3], 0.0);
						 }
					    }
					}
				}
				else {
					for( j=ars->ncurves ; j<i ; j++ ) {
						ars->curves[j] = NULL;
					}
				}
				ars->ncurves = i;
			}
		}
		else if( !strcmp( argv[0], "PPC" ) ) {
			/* change the number of points per curve */
			i = atoi( argv[1] );
			if( i < 3 ) {
				Tcl_SetResult( interp,
				      "ERROR: must have at least 3 points per curve\n",
				      TCL_STATIC );
				return( TCL_ERROR );
			}
			if( i < ars->pts_per_curve ) {
				for( j=0 ; j<ars->ncurves ; j++ ) {
					ars->curves[j] = bu_realloc( ars->curves[j],
						    i * 3 * sizeof( fastf_t ),
						    "ars->curves[j]" );
				}
				ars->pts_per_curve = i;
			}
			else if( i > ars->pts_per_curve ) {
				for( j=0 ; j<ars->ncurves ; j++ ) {
					ars->curves[j] = bu_realloc( ars->curves[j],
						    i * 3 * sizeof( fastf_t ),
						    "ars->curves[j]" );
					/* new points are duplicates of last */
					for( k=ars->pts_per_curve ; k<i ; k++ ) {
						if( k ) {
							VMOVE( &ars->curves[j][k*3],
							       &ars->curves[j][(k-1)*3] );
						}
						else {
							VSETALL( &ars->curves[j][k*3], 0 );
						}
					}
				}
				ars->pts_per_curve = i;
			}
		}
		else if( argv[0][0] == 'C' ) {
			if( isdigit( argv[0][1] ) ) {
				char *ptr;

				/* a specific curve */
				if( (ptr=strchr( argv[0], 'P' )) ) {
					/* a specific point on this curve */
					i = atoi( &argv[0][1] );
					j = atoi( ptr+1 );
					len = 3;
					array = &ars->curves[i][j*3];
					if( tcl_list_to_fastf_array( interp, argv[1],
						   &array,
						   &len )!= len ) {
						Tcl_SetResult( interp,
						    "WARNING: incorrect number of parameters provided for a point\n",
						       TCL_STATIC );
					}
				}
				else {
					/* one complete curve */
					i = atoi( &argv[0][1] );
					len = ars->pts_per_curve * 3;
					ptr = argv[1];
					while( *ptr ) {
						if( *ptr == '{' || *ptr == '}' )
							*ptr = ' ';
						ptr++;
					}
					if( !ars->curves[i] ) {
						ars->curves[i] = (fastf_t *)bu_calloc(
								  ars->pts_per_curve * 3,
								  sizeof( fastf_t ),
								  "ars->curves[i]" );
					}
					if( tcl_list_to_fastf_array( interp, argv[1],
						   &ars->curves[i],
						   &len ) != len ) {
						Tcl_SetResult( interp,
						    "WARNING: incorrect number of parameters provided for a curve\n",
						       TCL_STATIC );
					}
				}
			}
			else {
				Tcl_SetResult( interp,
				  "ERROR: Illegal argument, must be NC, PPC, C#, or C#P#\n",
				  TCL_STATIC );
				return( TCL_ERROR );
			}
		}
		else {
			Tcl_SetResult( interp,
				 "ERROR: Illegal argument, must be NC, PPC, C#, or C#P#\n",
				 TCL_STATIC );
			return( TCL_ERROR );
		}
		argc -= 2;
		argv += 2;
	}

	return( TCL_OK );
}
@


11.36
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /cvs/brlcad/librt/g_ars.c,v 11.35 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.35
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.34
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.33 2002/08/20 17:07:58 jra Exp $ (BRL)";
d77 1
a77 3
rt_ars_rd_curve(rp, npts)
union record	*rp;
int		npts;
d121 1
a121 5
rt_ars_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d193 1
a193 5
rt_ars_export( ep, ip, local2mm, dbip )
struct bu_external	*ep;
const struct rt_db_internal	*ip;
double			local2mm;
const struct db_i	*dbip;
d269 1
a269 5
rt_ars_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d321 1
a321 5
rt_ars_export5( ep, ip, local2mm, dbip )
struct bu_external	*ep;
const struct rt_db_internal	*ip;
double			local2mm;
const struct db_i	*dbip;
d367 1
a367 5
rt_ars_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d417 1
a417 2
rt_ars_ifree( ip )
struct rt_db_internal	*ip;
d453 1
a453 4
rt_ars_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d618 1
a618 2
rt_ars_print( stp )
register const struct soltab *stp;
d648 1
a648 5
rt_ars_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d844 1
a844 3
rt_hitsort( h, nh )
register struct hit h[];
register int nh;
d866 1
a866 4
rt_ars_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d883 1
a883 4
rt_ars_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d901 1
a901 5
rt_ars_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d933 1
a933 5
rt_ars_plot( vhead, ip, ttol, tol )
struct bu_list	*vhead;
struct rt_db_internal *ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d984 1
a984 6
rt_ars_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d1161 1
a1161 4
rt_ars_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d1243 1
a1243 5
rt_ars_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
@


11.33
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985 by the United States Army.
d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.31 2002/05/28 18:42:17 jra Exp $ (BRL)";
@


11.33.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_ars.c,v 11.34 2004/02/02 17:39:16 morrison Exp $ (BRL)";
@


11.33.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.34 2004/02/02 17:39:16 morrison Exp $ (BRL)";
@


11.33.10.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.33.10.1 2004/02/12 18:37:39 erikg Exp $ (BRL)";
@


11.33.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.33 2002/08/20 17:07:58 jra Exp $ (BRL)";
d77 3
a79 1
rt_ars_rd_curve(union record *rp, int npts)
d123 5
a127 1
rt_ars_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d199 5
a203 1
rt_ars_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d279 5
a283 1
rt_ars_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d335 5
a339 1
rt_ars_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d385 5
a389 1
rt_ars_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d439 2
a440 1
rt_ars_ifree(struct rt_db_internal *ip)
d476 4
a479 1
rt_ars_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d644 2
a645 1
rt_ars_print(register const struct soltab *stp)
d675 5
a679 1
rt_ars_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d875 3
a877 1
rt_hitsort(register struct hit *h, register int nh)
d899 4
a902 1
rt_ars_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d919 4
a922 1
rt_ars_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d940 5
a944 1
rt_ars_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d976 5
a980 1
rt_ars_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1031 6
a1036 1
rt_ars_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1213 4
a1216 1
rt_ars_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d1298 5
a1302 1
rt_ars_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


11.33.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d20 1
a20 1
static const char RCSars[] = "@@(#)$Header$ (BRL)";
@


11.32
log
@Converted from K&R to ANSI C - RFH
@
text
@d77 3
a79 1
rt_ars_rd_curve(union record *rp, int npts)
d123 5
a127 1
rt_ars_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d199 5
a203 1
rt_ars_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d279 5
a283 1
rt_ars_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d335 5
a339 1
rt_ars_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d385 5
a389 1
rt_ars_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d439 2
a440 1
rt_ars_ifree(struct rt_db_internal *ip)
d476 4
a479 1
rt_ars_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d644 2
a645 1
rt_ars_print(register const struct soltab *stp)
d675 5
a679 1
rt_ars_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d875 3
a877 1
rt_hitsort(register struct hit *h, register int nh)
d899 4
a902 1
rt_ars_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d919 4
a922 1
rt_ars_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d940 5
a944 1
rt_ars_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d976 5
a980 1
rt_ars_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1031 6
a1036 1
rt_ars_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1213 4
a1216 1
rt_ars_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d1298 5
a1302 1
rt_ars_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


11.31
log
@An ARS is now converted to an NMG, thrn to a BOT, and prepped as a BOT
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.30 2001/11/29 18:07:52 jra Exp $ (BRL)";
d77 1
a77 3
rt_ars_rd_curve(rp, npts)
union record	*rp;
int		npts;
d121 1
a121 5
rt_ars_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d193 1
a193 5
rt_ars_export( ep, ip, local2mm, dbip )
struct bu_external	*ep;
const struct rt_db_internal	*ip;
double			local2mm;
const struct db_i	*dbip;
d269 1
a269 5
rt_ars_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d321 1
a321 5
rt_ars_export5( ep, ip, local2mm, dbip )
struct bu_external	*ep;
const struct rt_db_internal	*ip;
double			local2mm;
const struct db_i	*dbip;
d367 1
a367 5
rt_ars_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d417 1
a417 2
rt_ars_ifree( ip )
struct rt_db_internal	*ip;
d453 1
a453 4
rt_ars_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d618 1
a618 2
rt_ars_print( stp )
register const struct soltab *stp;
d648 1
a648 5
rt_ars_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d844 1
a844 3
rt_hitsort( h, nh )
register struct hit h[];
register int nh;
d866 1
a866 4
rt_ars_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d883 1
a883 4
rt_ars_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d901 1
a901 5
rt_ars_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d933 1
a933 5
rt_ars_plot( vhead, ip, ttol, tol )
struct bu_list	*vhead;
struct rt_db_internal *ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d984 1
a984 6
rt_ars_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d1161 1
a1161 4
rt_ars_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d1243 1
a1243 5
rt_ars_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
@


11.30
log
@Now sets the new "ntri" field in bot_specific
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.29 2001/11/26 19:37:44 butler Exp $ (BRL)";
d47 7
d481 42
a530 1

d634 1
d636 1
@


11.29
log
@moved bot_specific structure to its own header file called "bot.h" in librt
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.28 2001/11/07 19:35:38 butler Exp $ (BRL)";
d562 2
@


11.28
log
@Changes to have the ARS use the BOT ray intersection code.
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.27 2001/10/02 19:24:28 jra Exp $ (BRL)";
d40 1
a40 1

@


11.27
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.26 2001/06/26 13:31:43 jra Exp $ (BRL)";
d31 1
d45 59
a103 1
HIDDEN fastf_t	*rt_ars_rd_curve();
a104 1
extern int	rt_ars_face();
d474 104
a577 45
	LOCAL fastf_t	dx, dy, dz;	/* For finding the bounding spheres */
	register int	i, j;
	LOCAL fastf_t	f;
	struct rt_ars_internal	*arip;

	arip = (struct rt_ars_internal *)ip->idb_ptr;
	RT_ARS_CK_MAGIC(arip);

	/*
	 * Compute bounding sphere.
	 * Find min and max of the point co-ordinates.
	 */
	VSETALL( stp->st_max, -INFINITY );
	VSETALL( stp->st_min,  INFINITY );

	for( i = 0; i < arip->ncurves; i++ )  {
		register fastf_t *v;

		v = arip->curves[i];
		for( j = 0; j < arip->pts_per_curve; j++ )  {
			VMINMAX( stp->st_min, stp->st_max, v );
			v += ELEMENTS_PER_VECT;
		}
	}
	VSET( stp->st_center,
		(stp->st_max[X] + stp->st_min[X])/2,
		(stp->st_max[Y] + stp->st_min[Y])/2,
		(stp->st_max[Z] + stp->st_min[Z])/2 );

	dx = (stp->st_max[X] - stp->st_min[X])/2;
	f = dx;
	dy = (stp->st_max[Y] - stp->st_min[Y])/2;
	if( dy > f )  f = dy;
	dz = (stp->st_max[Z] - stp->st_min[Z])/2;
	if( dz > f )  f = dz;
	stp->st_aradius = f;
	stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);
	stp->st_specific = (genptr_t) 0;

	/*
	 *  Compute planar faces
	 *  Will examine curves[i][pts_per_curve], provided by rt_ars_rd_curve.
	 */
	for( i = 0; i < arip->ncurves-1; i++ )  {
		register fastf_t *v1, *v2;
a578 20
		v1 = arip->curves[i];
		v2 = arip->curves[i+1];
		for( j = 0; j < arip->pts_per_curve;
		    j++, v1 += ELEMENTS_PER_VECT, v2 += ELEMENTS_PER_VECT )  {
		    	/* carefully make faces, w/inward pointing normals */
			rt_ars_face( stp,
				&v1[0],				/* [0][0] */
				&v2[ELEMENTS_PER_VECT],		/* [1][1] */
				&v1[ELEMENTS_PER_VECT] );	/* [0][1] */
			rt_ars_face( stp,
				&v2[0],				/* [1][0] */
				&v2[ELEMENTS_PER_VECT],		/* [1][1] */
				&v1[0] );			/* [0][0] */
		}
	}

	rt_ars_ifree( ip );

	return(0);		/* OK */
}
d580 1
a580 17
/*
 *			R T _ A R S _ R D _ C U R V E
 *
 *  rt_ars_rd_curve() reads a set of ARS B records and returns a pointer
 *  to a malloc()'ed memory area of fastf_t's to hold the curve.
 */
fastf_t *
rt_ars_rd_curve(rp, npts)
union record	*rp;
int		npts;
{
	LOCAL int lim;
	LOCAL fastf_t *base;
	register fastf_t *fp;		/* pointer to temp vector */
	register int i;
	LOCAL union record *rr;
	int	rec;
d582 1
a582 4
	/* Leave room for first point to be repeated */
	base = fp = (fastf_t *)bu_malloc(
	    (npts+1) * sizeof(fastf_t) * ELEMENTS_PER_VECT,
	    "ars curve" );
d584 1
a584 15
	rec = 0;
	for( ; npts > 0; npts -= 8 )  {
		rr = &rp[rec++];
		if( rr->b.b_id != ID_ARS_B )  {
			bu_log("rt_ars_rd_curve():  non-ARS_B record!\n");
			break;
		}
		lim = (npts>8) ? 8 : npts;
		for( i=0; i<lim; i++ )  {
			/* cvt from dbfloat_t */
			VMOVE( fp, (&(rr->b.b_values[i*3])) );
			fp += ELEMENTS_PER_VECT;
		}
	}
	return( base );
a586 52
/*
 *			R T _ A R S _ F A C E
 *
 *  This function is called with pointers to 3 points,
 *  and is used to prepare ARS faces.
 *  ap, bp, cp point to vect_t points.
 *
 * Return -
 *	0	if the 3 points didn't form a plane (eg, colinear, etc).
 *	#pts	(3) if a valid plane resulted.
 */
int
rt_ars_face( stp, ap, bp, cp )
struct soltab *stp;
pointp_t ap, bp, cp;
{
	register struct tri_specific *trip;
	vect_t work;
	LOCAL fastf_t m1, m2, m3, m4;

	BU_GETSTRUCT( trip, tri_specific );
	VMOVE( trip->tri_A, ap );
	VSUB2( trip->tri_BA, bp, ap );
	VSUB2( trip->tri_CA, cp, ap );
	VCROSS( trip->tri_wn, trip->tri_BA, trip->tri_CA );

	/* Check to see if this plane is a line or pnt */
	m1 = MAGNITUDE( trip->tri_BA );
	m2 = MAGNITUDE( trip->tri_CA );
	VSUB2( work, bp, cp );
	m3 = MAGNITUDE( work );
	m4 = MAGNITUDE( trip->tri_wn );
	if( NEAR_ZERO(m1,0.0001) || NEAR_ZERO(m2,0.0001) ||
	    NEAR_ZERO(m3,0.0001) || NEAR_ZERO(m4,0.0001) )  {
		bu_free( (char *)trip, "tri_specific struct");
		if( RT_G_DEBUG & DEBUG_ARB8 )
			bu_log("ars(%s): degenerate facet\n", stp->st_name);
		return(0);			/* BAD */
	}		

	/*
	 *  wn is an inward pointing normal, of non-unit length.
	 *  tri_N is a unit length outward pointing normal.
	 */
	VREVERSE( trip->tri_N, trip->tri_wn );
	VUNITIZE( trip->tri_N );

	/* Add this face onto the linked list for this solid */
	trip->tri_forw = (struct tri_specific *)stp->st_specific;
	stp->st_specific = (genptr_t)trip;
	return(3);				/* OK */
}
a918 23
/*
 *			R T _ A R S _ F R E E
 */
void
rt_ars_free( stp )
register struct soltab *stp;
{
	register struct tri_specific *trip =
		(struct tri_specific *)stp->st_specific;

	while( trip != TRI_NULL )  {
		register struct tri_specific *nexttri = trip->tri_forw;

		bu_free( (char *)trip, "ars tri_specific");
		trip = nexttri;
	}
}

int
rt_ars_class()
{
	return(0);
}
@


11.26
log
@Minor mods to eliminate core dumps when ARS has no curves
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.25 2001/06/21 18:32:06 jra Exp $ (BRL)";
d78 1
d229 1
@


11.25
log
@Allowed a bit more generality in the tcladjust routine
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.24 2001/06/21 18:07:25 jra Exp $ (BRL)";
d337 7
a343 5
	sprintf(buf, "\tV (%g, %g, %g)\n",
		arip->curves[0][X] * mm2local,
		arip->curves[0][Y] * mm2local,
		arip->curves[0][Z] * mm2local );
	bu_vls_strcat( str, buf );
d1374 6
@


11.24
log
@Continueing to add tcladjust and tclget support
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.23 2001/05/17 20:05:24 morrison Exp $ (BRL)";
d1283 20
a1302 8
				/* new curves are duplicates of the last */
				for( j=ars->ncurves ; j<i ; j++ ) {
					ars->curves[j] = (fastf_t *)bu_malloc(
					      ars->pts_per_curve * 3 * sizeof( fastf_t ),
					      "ars->curves[j]" );
					for( k=0 ; k<ars->pts_per_curve ; k++ ) {
						VMOVE( &ars->curves[j][k*3],
						       &ars->curves[j-1][k*3] );
d1332 7
a1338 2
						VMOVE( &ars->curves[j][k*3],
						       &ars->curves[j][(k-1)*3] );
@


11.23
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.22 2001/04/05 19:35:34 morrison Exp $ (BRL)";
d26 3
d30 1
d1165 218
@


11.22
log
@updated SIGNED to signed
updated CONST to const
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.21 2000/07/13 02:36:25 cjohnson Exp $ (BRL)";
d550 1
a550 1
		if( rt_g.debug & DEBUG_ARB8 )
d633 1
a633 1
		if( rt_g.debug & DEBUG_ARB8 )
d673 1
a673 1
		if(rt_g.debug&DEBUG_ARB8) bu_log("ars: dist k=%g, ds=%g, dn=%g\n", k, ds, dn );
d888 1
a888 1
		if( rt_g.debug )
@


11.21
log
@LINT from gcc -Wall
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.20 2000/07/10 23:01:29 mike Exp $ (BRL)";
d56 3
a58 3
CONST struct bu_external	*ep;
CONST mat_t			mat;
CONST struct db_i		*dbip;
d131 1
a131 1
CONST struct rt_db_internal	*ip;
d133 1
a133 1
CONST struct db_i	*dbip;
d211 3
a213 3
CONST struct bu_external	*ep;
CONST mat_t			mat;
CONST struct db_i		*dbip;
d266 1
a266 1
CONST struct rt_db_internal	*ip;
d268 1
a268 1
CONST struct db_i	*dbip;
d316 1
a316 1
CONST struct rt_db_internal	*ip;
d573 1
a573 1
register CONST struct soltab *stp;
d930 2
a931 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d986 2
a987 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
@


11.20
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.19 2000/06/30 19:14:30 jra Exp $ (BRL)";
a293 1
		int			left;
d589 1
a589 1
	} while( trip = trip->tri_forw );
@


11.19
log
@Added database v5 support
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.18 2000/06/30 15:38:02 mike Exp $ (BRL)";
@


11.18
log
@
export methods should not init the external structure, just check them.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.17 2000/06/30 15:31:14 mike Exp $ (BRL)";
d193 109
@


11.17
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.16 2000/06/08 20:54:32 jra Exp $ (BRL)";
d149 1
a149 1
	BU_INIT_EXTERNAL(ep);
@


11.16
log
@Added duplicate hit removal to rt_ars_shot, and set hit_rayp field in hit structure
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.15 2000/04/12 02:34:30 mike Exp $ (BRL)";
d73 1
a73 1
	RT_INIT_DB_INTERNAL( ip );
@


11.15
log
@
NT port, non-compat4
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.14 2000/03/29 02:43:09 mike Exp $ (BRL)";
d563 1
d581 34
@


11.14
log
@
Fixed invocation of nmg_mark_edges_real()
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.13 1999/12/22 02:17:58 mike Exp $ (BRL)";
d712 1
a712 1
	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.13
log
@
Eliminated dead vars
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.12 1999/12/06 16:54:00 mike Exp $ (BRL)";
d1012 1
a1012 1
	nmg_mark_edges_real( &s->l );
@


11.12
log
@
Changed rt_ars_hitsort() into rt_hitsort(), and made it a non-hidden
routine.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.11 1999/11/26 21:46:45 mike Exp $ (BRL)";
a853 1
	struct bu_ptbl tbl;
@


11.11
log
@
Lint cleanups
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.10 1999/11/17 02:41:56 mike Exp $ (BRL)";
a41 1
HIDDEN void	rt_ars_hitsort();
d566 1
a566 1
		/* Bug fix: next line was "nhits++".  This caused ars_hitsort
d579 1
a579 1
	rt_ars_hitsort( hits, nhits );
d655 3
a657 1
 *			R T _ A R S _ H I T S O R T
d659 2
a660 2
HIDDEN void
rt_ars_hitsort( h, nh )
@


11.10
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.9 1999/10/30 03:53:26 mike Exp $ (BRL)";
d55 1
a55 1
rt_ars_import( ip, ep, mat )
d59 1
d130 1
a130 1
rt_ars_export( ep, ip, local2mm )
d132 1
a132 1
struct rt_db_internal	*ip;
d134 1
d209 1
a209 1
struct rt_db_internal	*ip;
d787 1
a787 1
struct bn_tol		*tol;
d843 1
a843 1
struct bn_tol		*tol;
@


11.9
log
@
Added magic numbers for ray, hit, and application structures.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.8 1999/07/02 22:19:22 mike Exp $ (BRL)";
d75 1
@


11.8
log
@
Removed dependence on compat4.h
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.7 1999/05/27 19:10:36 mike Exp $ (BRL)";
d557 1
@


11.7
log
@
sed4
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ars.c,v 11.6 1997/02/12 14:52:50 jra Exp $ (BRL)";
d801 1
a801 1
		RT_ADD_VLIST( vhead, v1, RT_VLIST_LINE_MOVE );
d804 1
a804 1
			RT_ADD_VLIST( vhead, v1, RT_VLIST_LINE_DRAW );
d811 1
a811 1
		RT_ADD_VLIST( vhead, &arip->curves[0][i*ELEMENTS_PER_VECT], RT_VLIST_LINE_MOVE );
d813 1
a813 1
			RT_ADD_VLIST( vhead, &arip->curves[j][i*ELEMENTS_PER_VECT], RT_VLIST_LINE_DRAW );
@


11.6
log
@Increased max number of hits, and added code to swap in/out on small reversed segments.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 11.5 1996/09/06 18:32:57 jra Exp jra $ (BRL)";
d57 1
a57 1
CONST struct rt_external	*ep;
d66 1
a66 1
	RT_CK_EXTERNAL( ep );
d69 1
a69 1
		rt_log("rt_ars_import: defective record\n");
d75 1
a75 1
	ip->idb_ptr = rt_malloc(sizeof(struct rt_ars_internal), "rt_ars_internal");
d84 1
a84 1
	ari->curves = (fastf_t **)rt_malloc(
d129 1
a129 1
struct rt_external	*ep;
d147 1
a147 1
	RT_INIT_EXTERNAL(ep);
d150 1
a150 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "ars external");
d205 1
a205 1
struct rt_vls		*str;
d217 1
a217 1
	rt_vls_strcat( str, "arbitrary rectangular solid (ARS)\n");
d221 1
a221 1
	rt_vls_strcat( str, buf );
d227 1
a227 1
	rt_vls_strcat( str, buf );
d236 1
a236 1
		rt_vls_strcat( str, buf );
d242 1
a242 1
			rt_vls_strcat( str, buf );
d270 1
a270 1
		rt_free( (char *)arip->curves[i], "ars curve" );
d272 1
a272 1
	rt_free( (char *)arip->curves, "ars curve ptrs" );
d275 1
a275 1
	rt_free( (char *)arip, "ars ifree" );
d384 1
a384 1
	base = fp = (fastf_t *)rt_malloc(
d392 1
a392 1
			rt_log("rt_ars_rd_curve():  non-ARS_B record!\n");
d425 1
a425 1
	GETSTRUCT( trip, tri_specific );
d439 1
a439 1
		rt_free( (char *)trip, "tri_specific struct");
d441 1
a441 1
			rt_log("ars(%s): degenerate facet\n", stp->st_name);
d469 1
a469 1
		rt_log("ars(%s):  no faces\n", stp->st_name);
d478 1
a478 1
		rt_log("\n");
d524 1
a524 1
			rt_log("N.Dir=%g ", dn );
d561 1
a561 1
		if(rt_g.debug&DEBUG_ARB8) rt_log("ars: dist k=%g, ds=%g, dn=%g\n", k, ds, dn );
d567 1
a567 1
			rt_log("ars(%s): too many hits\n", stp->st_name);
d584 1
a584 1
		rt_log("ERROR: ars(%s): %d hits odd, skipping solid\n",
d587 1
a587 1
			rt_log("k=%g dn=%g\n",
d621 1
a621 1
		   	rt_log("ars(%s): in/out error\n", stp->st_name );
d623 1
a623 1
		   		rt_log("%d %s dist=%g dn=%g\n",
d630 1
a630 1
					rt_log( "\tseg length = %g\n", hits[j].hit_dist - hits[j-1].hit_dist );
d645 1
a645 1
			RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d741 1
a741 1
			rt_log("rt_ars_uv: bad uv=%g,%g\n", uvp->uv_u, uvp->uv_v);
d764 1
a764 1
		rt_free( (char *)trip, "ars tri_specific");
d780 1
a780 1
struct rt_list	*vhead;
d783 1
a783 1
struct rt_tol		*tol;
d839 1
a839 1
struct rt_tol		*tol;
d848 2
a849 2
	struct nmg_ptbl	kill_fus;
	struct nmg_ptbl tbl;
d868 1
a868 1
			code = rt_dist_pt3_lseg3( &dist, pca, ARS_PT(0,-2), ARS_PT(0,-1), ARS_PT(0,0), tol );
d872 5
a876 5
				rt_log( "ARS curve backtracks on itself!!!\n" );
				rt_log( "\tCurve #%d, points #%d through %d are:\n", i, j-2, j );
				rt_log( "\t\t%d (%f %f %f)\n", j-2, V3ARGS( ARS_PT(0,-2) ) );
				rt_log( "\t\t%d (%f %f %f)\n", j-1, V3ARGS( ARS_PT(0,-1) ) );
				rt_log( "\t\t%d (%f %f %f)\n", j, V3ARGS( ARS_PT(0,0) ) );
d885 1
a885 1
		rt_log( "TESSELATION FAILURE: This ARS solid has not been tesselated.\n\tAny result you may obtain is incorrect.\n" );
d889 1
a889 1
	nmg_tbl( &kill_fus, TBL_INIT, (long *)NULL );
d894 1
a894 1
	s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d896 1
a896 1
	verts = (struct vertex **)rt_calloc( arip->ncurves * (arip->pts_per_curve+1),
d925 1
a925 1
			if( rt_3pts_distinct( ARS_PT(0,0), ARS_PT(1,1),
d927 1
a927 1
			   && !rt_3pts_collinear( ARS_PT(0,0), ARS_PT(1,1),
d941 1
a941 1
					rt_log("rt_ars_tess() nmg_cmface failed, skipping face a[%d][%d]\n",
d951 2
a952 2
					rt_log( "Degenerate face created, will kill it later\n" );
					nmg_tbl( &kill_fus, TBL_INS, (long *)fu );
d959 1
a959 1
			if( rt_3pts_distinct( ARS_PT(1,0), ARS_PT(1,1),
d961 1
a961 1
			   && !rt_3pts_collinear( ARS_PT(1,0), ARS_PT(1,1),
d975 1
a975 1
					rt_log("rt_ars_tess() nmg_cmface failed, skipping face b[%d][%d]\n",
d985 2
a986 2
					rt_log( "Degenerate face created, will kill it later\n" );
					nmg_tbl( &kill_fus, TBL_INS, (long *)fu );
d992 1
a992 1
	rt_free( (char *)verts, "rt_ars_tess *verts[]" );
d995 1
a995 1
	for( i=0 ; i<NMG_TBL_END( &kill_fus ) ; i++ )
d997 1
a997 1
		fu = (struct faceuse *)NMG_TBL_GET( &kill_fus, i );
@


11.5
log
@Added some code to tesselation to check for a bad ars.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 11.4 1996/05/28 21:14:19 jra Exp jra $ (BRL)";
d501 1
a501 1
#define RT_ARS_MAXHITS 32		/* # surfaces hit, must be even */
d603 18
d629 2
@


11.4
log
@fixed bug in previous mod (code to allow strange "double-ended" curves).
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 11.3 1996/05/07 14:13:51 jra Exp jra $ (BRL)";
d799 11
d830 1
d836 33
a878 12

#define IJ(ii,jj)	(((i+(ii))*(arip->pts_per_curve+1))+(j+(jj)))
#define ARS_PT(ii,jj)	(&arip->curves[i+(ii)][(j+(jj))*ELEMENTS_PER_VECT])
#define FIND_IJ(a,b)	\
	if( !(verts[IJ(a,b)]) )  { \
		verts[IJ(a,b)] = \
		nmg_find_pt_in_shell( s, ARS_PT(a,b), tol ); \
	}
#define ASSOC_GEOM(corn, a,b)	\
	if( !((*corners[corn])->vg_p) )  { \
		nmg_vertex_gv( *(corners[corn]), ARS_PT(a,b) ); \
	}
@


11.3
log
@Added code to allow strange "double-ended" curves (curves with extra endpoints in center
of ARS).
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 11.2 1996/04/22 12:24:19 jra Exp jra $ (BRL)";
d855 1
a855 1
		if( VAPPROXEQUAL( &arip->curves[i][1*ELEMENTS_PER_VECT], &arip->curves[i][k*ELEMENTS_PER_VECT], tol->dist ) )
@


11.2
log
@Added code to kill degenerate faces in rt_ars_tess().
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 11.1 1995/01/04 09:56:30 mike Rel4_4 jra $ (BRL)";
d812 1
d817 2
d824 2
d851 1
d853 7
d863 6
d873 3
a875 1
			    ARS_PT(0,1), tol )
d886 1
d897 4
a900 1
					nmg_kfu(  fu );
d907 3
a909 1
			    ARS_PT(0,0), tol )
d920 1
d931 4
a934 1
					nmg_kfu(  fu );
d939 10
a958 2

	rt_free( (char *)verts, "rt_ars_tess *verts[]" );
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 10.8 94/09/13 15:47:17 jra Exp $ (BRL)";
d874 2
a875 1
				if( nmg_fu_planeeqn( fu, tol ) < 0 )  return -1;
d902 2
a903 1
				if( nmg_fu_planeeqn( fu, tol ) < 0 )  return -1;
@


10.8
log
@removed vertexuse normals.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 10.7 94/09/09 14:22:11 jra Exp Locker: jra $ (BRL)";
@


10.7
log
@Added vertexuse normals and set edge is_real flags in tesselator
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 10.6 94/09/01 15:54:15 jra Exp Locker: jra $ (BRL)";
a909 60

	/* Associate normals with vertexuses */
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		struct loopuse *lu;
		vect_t norm;
		vect_t rev_norm;

		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;

		NMG_GET_FU_NORMAL( norm , fu );
		VREVERSE( rev_norm , norm );

		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			NMG_CK_LOOPUSE( lu );

			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
			{
				struct vertexuse *vu;

				vu = RT_LIST_FIRST( vertexuse , &lu->down_hd );
				NMG_CK_VERTEXUSE( vu );

				/* OT_SAME faceuse */
				nmg_vertexuse_nv( vu , norm );

				vu = RT_LIST_FIRST( vertexuse , &lu->lumate_p->down_hd );

				/* OT_OPPOSITE faceuse */
				nmg_vertexuse_nv( vu , rev_norm );
			}
			else if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC )
			{
				struct edgeuse *eu;

				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
				{
					struct vertexuse *vu;

					NMG_CK_EDGEUSE( eu );

					vu = eu->vu_p;
					NMG_CK_VERTEXUSE( vu );

					/* OT_SAME faceuse */
					nmg_vertexuse_nv( vu , norm );

					vu = eu->eumate_p->vu_p;
					NMG_CK_VERTEXUSE( vu );

					/* OT_OPPOSITE faceuse */
					nmg_vertexuse_nv( vu , rev_norm );
				}
			}
		}
	}
@


10.6
log
@Fixed export routine (was doubling the first point of the first curve).
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 10.5 94/09/01 12:12:14 jra Exp Locker: jra $ (BRL)";
d910 63
@


10.5
log
@Added call to nmg_fix_normals to tessellator.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 10.4 94/08/10 18:24:02 gdurf Exp Locker: jra $ (BRL)";
a160 3
	/* The later subtraction will "undo" this, leaving just base_pt */
	VADD2( &arip->curves[0][0], &arip->curves[0][0], base_pt);

d182 4
a185 1
				VSUB2SCALE( diff, fp, base_pt, local2mm );
@


10.4
log
@Added include of conf.h
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 10.3 1993/11/18 01:43:59 mike Exp gdurf $ (BRL)";
d905 5
@


10.3
log
@Added tol arg to bounding box routines
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 10.2 93/03/26 22:01:59 mike Exp $ (BRL)";
d22 2
@


10.2
log
@Moved nmg_find_pt_in_shell() into nmg_info.c
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 10.1 91/10/12 06:40:12 mike Rel4_0 Locker: mike $ (BRL)";
d905 1
a905 1
	nmg_region_a( *r );
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.24 91/09/20 22:51:05 butler Exp $ (BRL)";
a42 2
extern struct vertex *rt_nmg_find_pt_in_shell();

d833 1
a833 1
		rt_nmg_find_pt_in_shell( s, ARS_PT(a,b), tol ); \
@


9.24
log
@removing fuzz with lint
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.23 91/06/30 00:10:47 mike Exp $ (BRL)";
@


9.23
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.22 91/06/22 22:30:18 mike Exp $ (BRL)";
a299 1
	register fastf_t **curves;	/* array of curve base addresses */
d684 3
a686 3
	register struct tri_specific *trip =
		(struct tri_specific *)hitp->hit_private;

@


9.22
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.21 91/06/12 20:57:34 mike Exp $ (BRL)";
d56 3
a58 3
struct rt_db_internal	*ip;
struct rt_external	*ep;
mat_t			mat;
d464 1
a464 1
register struct soltab *stp;
@


9.21
log
@nmg.h must come before raytrace.h
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.20 91/05/18 03:00:45 mike Exp $ (BRL)";
d293 1
a293 1
rt_ars_prep( stp, ip, rtip, tol )
a296 1
CONST struct rt_tol	*tol;
d494 1
a494 1
rt_ars_shot( stp, rp, ap, seghead, tol )
a498 1
CONST struct rt_tol	*tol;
@


9.20
log
@Converted to new tolerance interface
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.19 91/04/01 19:59:34 mike Exp $ (BRL)";
d28 1
a29 1
#include "nmg.h"
@


9.19
log
@Edges of loops now travel in a counter-clockwise (CCW) direction
around the face normal.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.18 91/02/27 21:14:39 mike Exp $ (BRL)";
d293 1
a293 1
rt_ars_prep( stp, ip, rtip )
d297 1
d495 1
a495 1
rt_ars_shot( stp, rp, ap, seghead )
d500 1
d762 1
a762 1
rt_ars_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
d765 2
a766 3
double		abs_tol;
double		rel_tol;
double		norm_tol;
d806 1
a806 1
rt_ars_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d810 2
a811 3
double		abs_tol;
double		rel_tol;
double		norm_tol;
a818 2
	fastf_t		tol;
	fastf_t		tol_sq;
a823 6
	/* rel_tol is hard to deal with, given we don't know the RPP yet */
	tol = abs_tol;
	if( tol <= 0.0 )
		tol = 0.1;	/* mm */
	tol_sq = tol * tol;

d838 1
a838 1
		rt_nmg_find_pt_in_shell( s, ARS_PT(a,b), tol_sq ); \
d857 1
a857 1
			    ARS_PT(0,1), tol_sq )
d877 1
a877 1
				if( nmg_fu_planeeqn( fu ) < 0 )  return -1;
d884 1
a884 1
			    ARS_PT(0,0), tol_sq )
d904 1
a904 1
				if( nmg_fu_planeeqn( fu ) < 0 )  return -1;
@


9.18
log
@lint
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.17 91/02/07 20:32:16 mike Exp $ (BRL)";
a797 7
	/*
	 *  Free storage for faces
	 */
	for( i = 0; i < arip->ncurves; i++ )  {
		rt_free( (char *)arip->curves[i], "ars curve" );
	}
	rt_free( (char *)arip->curves, "ars curves[]" );
d872 1
a872 1
				/* Construct first face topology, clockwise order */
d874 2
a875 2
				corners[1] = &verts[IJ(1,1)];
				corners[2] = &verts[IJ(0,1)];
d883 3
a885 4
				ASSOC_GEOM( 1, 1, 1 );
				ASSOC_GEOM( 2, 0, 1 );

				rt_mk_nmg_planeeqn( fu );
d899 1
a899 1
				/* Construct second face topology, clockwise */
d901 2
a902 2
				corners[1] = &verts[IJ(1,1)];
				corners[2] = &verts[IJ(0,0)];
d910 3
a912 4
				ASSOC_GEOM( 1, 1, 1 );
				ASSOC_GEOM( 2, 0, 0 );

				rt_mk_nmg_planeeqn( fu );
a921 7
	/*
	 *  Free storage for imported curves
	 */
	for( i = 0; i < arip->ncurves; i++ )  {
		rt_free( (char *)arip->curves[i], "ars curve" );
	}
	rt_free( (char *)arip->curves, "ars curves[]" );
@


9.17
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.16 91/01/28 23:53:06 mike Exp $ (BRL)";
d229 1
a229 1
	if( !verbose )  return;
@


9.16
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.15 91/01/26 03:14:41 mike Exp $ (BRL)";
d842 1
a842 1
	s = NMG_LIST_FIRST(shell, &(*r)->s_hd);
@


9.15
log
@Eliminated mat parameter on ft_plot and ft_tess
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.14 91/01/25 21:52:04 mike Exp $ (BRL)";
d761 1
a761 1
struct vlhead	*vhead;
d783 1
a783 1
		ADD_VL( vhead, v1, 0 );
d786 1
a786 1
			ADD_VL( vhead, v1, 1 );
d793 1
a793 1
		ADD_VL( vhead, &arip->curves[0][i*ELEMENTS_PER_VECT], 0 );
d795 1
a795 1
			ADD_VL( vhead, &arip->curves[j][i*ELEMENTS_PER_VECT], 1 );
@


9.14
log
@lint
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.13 91/01/25 21:18:45 mike Exp $ (BRL)";
d760 1
a760 1
rt_ars_plot( vhead, mat, ip, abs_tol, rel_tol, norm_tol )
a761 1
mat_t		mat;
d812 1
a812 1
rt_ars_tess( r, m, ip, mat, abs_tol, rel_tol, norm_tol )
a815 1
register mat_t		mat;
@


9.13
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.12 91/01/25 20:35:32 mike Exp $ (BRL)";
d502 2
a503 2
#define MAXHITS 12		/* # surfaces hit, must be even */
	LOCAL struct hit hits[MAXHITS];
d567 1
a567 1
		if( ++nhits >= MAXHITS )  {
@


9.12
log
@Added rt_ prefix to _internal structure
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.11 91/01/15 23:46:32 mike Exp $ (BRL)";
a291 1
#if NEW_IF
a297 10
#else
int
rt_ars_prep( stp, rec, rtip )
struct soltab	*stp;
union record	*rec;
struct rt_i	*rtip;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a303 12
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rec;
	ep->ext_nbytes = stp->st_dp->d_len*sizeof(union record);
	ip = &intern;
	if( rt_ars_import( ip, ep, stp->st_pathmat ) < 0 )
		return(-1);		/* BAD */
	RT_CK_DB_INTERNAL( ip );
#endif
a758 1
#if NEW_IF
a767 14
#else
int
rt_ars_plot( rp, mat, vhead, dp, abs_tol, rel_tol, norm_tol  )
union record		*rp;
mat_t			mat;
struct vlhead		*vhead;
struct directory	*dp;
double			abs_tol;
double			rel_tol;
double			norm_tol;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a771 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_ars_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_ars_plot(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
a811 1
#if NEW_IF
a821 15
#else
int
rt_ars_tess( r, m, rp, mat, dp, abs_tol, rel_tol, norm_tol )
struct nmgregion	**r;
struct model		*m;
union record		*rp;
mat_t			mat;
struct directory	*dp;
double			abs_tol;
double			rel_tol;
double			norm_tol;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a830 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_ars_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_ars_tess(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
@


9.11
log
@Moved ars_internal to rtgeom.h
Added extra magic check
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.10 91/01/14 23:29:42 mike Exp $ (BRL)";
d60 1
a60 1
	struct ars_internal *ari;
d75 2
a76 2
	ip->idb_ptr = rt_malloc(sizeof(struct ars_internal), "ars_internal");
	ari = (struct ars_internal *)ip->idb_ptr;
d133 1
a133 1
	struct ars_internal	*arip;
d142 1
a142 1
	arip = (struct ars_internal *)ip->idb_ptr;
d211 2
a212 2
	register struct ars_internal	*arip =
		(struct ars_internal *)ip->idb_ptr;
d259 1
a259 1
	register struct ars_internal	*arip;
d263 1
a263 1
	arip = (struct ars_internal *)ip->idb_ptr;
d313 1
a313 1
	struct ars_internal	*arip;
d327 1
a327 1
	arip = (struct ars_internal *)ip->idb_ptr;
d808 1
a808 1
	struct ars_internal	*arip;
d825 1
a825 1
	arip = (struct ars_internal *)ip->idb_ptr;
d892 1
a892 1
	struct ars_internal	*arip;
d914 1
a914 1
	arip = (struct ars_internal *)ip->idb_ptr;
@


9.10
log
@Changed arg names to match raytrace.h
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.9 91/01/14 22:35:12 mike Exp $ (BRL)";
d30 1
a35 11
/* The internal (in memory) form of an ARS */
struct ars_internal {
	int	magic;
	int	ncurves;
	int	pts_per_curve;
	fastf_t	**curves;
};
#define RT_ARS_INTERNAL_MAGIC	0x77ddbbe3
#define RT_ARS_CK_MAGIC(_p)	RT_CKMAG(_p,RT_ARS_INTERNAL_MAGIC,"ars_internal")


a44 1

d328 1
@


9.9
log
@Converted to new import/export interface
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.8 90/11/01 04:47:08 mike Exp $ (BRL)";
d139 1
a139 1
rt_ars_export( ep, ip, conv2mm )
d142 1
a142 1
double			conv2mm;
d196 1
a196 1
				VSUB2SCALE( diff, fp, base_pt, conv2mm );
d215 1
a215 1
rt_ars_describe( str, ip, verbose, units )
d219 1
a219 1
double			units;
d235 3
a237 3
		arip->curves[0][X] * units,
		arip->curves[0][Y] * units,
		arip->curves[0][Z] * units );
d250 3
a252 3
				v[X] * units,
				v[Y] * units,
				v[Z] * units );
@


9.8
log
@Added tessellation support
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.7 90/10/06 02:05:09 mike Exp $ (BRL)";
d37 4
a40 3
	int ncurves;
	int pts_per_curve;
	fastf_t ** curves;
d42 2
d66 4
a69 4
rt_ars_import( ari, rp, mat )
struct ars_internal * ari;
union record	*rp;
matp_t		mat;
d71 2
d77 12
d93 1
a93 1
	 * Read all the curves into memory, and store their pointers
d95 2
a96 2
	i = (ari->ncurves+1) * sizeof(fastf_t **);
	ari->curves = (fastf_t **)rt_malloc( i, "ars curve ptrs" );
d133 158
d303 1
d305 8
a312 1
rt_ars_prep( stp, rp, rtip )
d314 1
a314 1
union record	*rp;
d317 3
d324 1
a324 1
	LOCAL struct ars_internal ari;
d326 13
a338 1
	i = rt_ars_import( &ari, rp, stp->st_pathmat );
a339 5
	if ( i < 0) {
		rt_log("rt_ars_prep(%s): db import failure\n", stp->st_name);
		return(-1);
	}

d347 1
a347 1
	for( i = 0; i < ari.ncurves; i++ )  {
d350 2
a351 2
		v = ari.curves[i];
		for( j = 0; j < ari.pts_per_curve; j++ )  {
d375 1
a375 1
	for( i = 0; i < ari.ncurves-1; i++ )  {
d378 3
a380 3
		v1 = ari.curves[i];
		v2 = ari.curves[i+1];
		for( j = 0; j < ari.pts_per_curve;
d394 1
a394 7
	/*
	 *  Free storage for faces
	 */
	for( i = 0; i < ari.ncurves; i++ )  {
		rt_free( (char *)ari.curves[i], "ars curve" );
	}
	rt_free( (char *)ari.curves, "ars curve ptrs" );
d792 1
d794 10
d813 3
d818 1
a818 1
	struct ars_internal ari;
d820 11
a830 5
	i = rt_ars_import(&ari, rp, mat );

	if ( i < 0) {
		rt_log("rt_ars_plot: db import failure\n");
		return(-1);
d832 5
d842 1
a842 1
	for( i = 0; i < ari.ncurves; i++ )  {
d845 1
a845 1
		v1 = ari.curves[i];
d848 1
a848 1
		for( j = 1; j <= ari.pts_per_curve; j++, v1 += ELEMENTS_PER_VECT )
d855 4
a858 4
	for( i = 0; i < ari.pts_per_curve; i++ )  {
		ADD_VL( vhead, &ari.curves[0][i*ELEMENTS_PER_VECT], 0 );
		for( j = 1; j < ari.ncurves; j++ )
			ADD_VL( vhead, &ari.curves[j][i*ELEMENTS_PER_VECT], 1 );
d864 2
a865 2
	for( i = 0; i < ari.ncurves; i++ )  {
		rt_free( (char *)ari.curves[i], "ars curve" );
d867 1
a867 1
	rt_free( (char *)ari.curves, "ars curves[]" );
d874 1
d876 11
d897 3
d902 1
a902 1
	struct ars_internal ari;
d909 11
a919 5
	i = rt_ars_import( &ari, rp, mat );

	if ( i < 0) {
		rt_log("rt_ars_tess: db import failure\n");
		return(-1);
d921 5
d938 1
a938 1
	verts = (struct vertex **)rt_calloc( ari.ncurves * (ari.pts_per_curve+1),
d942 2
a943 2
#define IJ(ii,jj)	(((i+(ii))*(ari.pts_per_curve+1))+(j+(jj)))
#define ARS_PT(ii,jj)	(&ari.curves[i+(ii)][(j+(jj))*ELEMENTS_PER_VECT])
d958 2
a959 2
	for( i = 0; i < ari.ncurves-1; i++ )  {
		for( j = 0; j < ari.pts_per_curve; j++ )  {
d1028 2
a1029 2
	for( i = 0; i < ari.ncurves; i++ )  {
		rt_free( (char *)ari.curves[i], "ars curve" );
d1031 1
a1031 1
	rt_free( (char *)ari.curves, "ars curves[]" );
@


9.7
log
@Converted seg structures to use doubly linked lists.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.6 90/10/05 23:25:33 stay Exp $ (BRL)";
d29 1
d50 3
d58 3
d191 3
a193 3
				&v1[0],
				&v2[ELEMENTS_PER_VECT],
				&v1[ELEMENTS_PER_VECT] );
d195 3
a197 3
				&v2[0],
				&v2[ELEMENTS_PER_VECT],
				&v1[0] );
d606 8
a613 5
rt_ars_plot( rp, mat, vhead, dp )
union record	*rp;
mat_t		mat;
struct vlhead	*vhead;
struct directory *dp;
d659 3
d663 9
a671 1
rt_ars_tess()
d673 122
a794 1
	return(-1);
@


9.6
log
@Fixed typo.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.5 90/07/31 17:23:19 stay Exp $ (BRL)";
d330 1
a330 1
 *  	segp	HIT
d332 4
a335 4
struct seg *
rt_ars_shot( stp, rp, ap )
struct soltab *stp;
register struct xray *rp;
d337 1
d413 1
a413 1
		return(SEG_NULL);		/* MISS */
d429 1
a429 1
		return(SEG_NULL);		/* MISS */
d453 1
a453 1
		   	return(SEG_NULL);
a459 1
		segp = SEG_NULL;
d461 1
a461 5
			register struct seg *newseg;

			GET_SEG(newseg, ap->a_resource);
			newseg->seg_next = segp;
			segp = newseg;
d465 1
a466 1
		return(segp);			/* HIT */
d468 1
a468 1
	/* NOTREACHED */
@


9.5
log
@Changed rt_ars_readin to rt_ars-import and added a definition
of struct ars_internal for the import function.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /m/cad/librt/RCS/g_ars.c,v 9.4 90/05/04 08:13:08 mike Exp $ (BRL)";
d38 1
a38 1
	fastf_t ** curves
d133 1
a133 1
	i = rt_ars_readin( &ari, rp, stp->st_pathmat );
@


9.4
log
@Routines all got rt_ prefixes
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: g_ars.c,v 9.3 90/03/14 15:05:42 mike Locked $ (BRL)";
d34 8
d50 1
a50 1
 *			R T _ A R S _ R E A D I N
d55 3
a57 2
HIDDEN fastf_t **
rt_ars_readin( rp, mat )
a61 3
	register fastf_t **curves;	/* array of curve base addresses */
	LOCAL int	pts_per_curve;
	LOCAL int	ncurves;
d65 2
a66 2
	ncurves = rp[0].a.a_m;
	pts_per_curve = rp[0].a.a_n;
d71 2
a72 2
	i = (ncurves+1) * sizeof(fastf_t **);
	curves = (fastf_t **)rt_malloc( i, "ars curve ptrs" );
d74 4
a77 3
	for( i=0; i < ncurves; i++ )  {
		curves[i] = rt_ars_rd_curve( &rp[currec], pts_per_curve );
		currec += (pts_per_curve+7)/8;
d85 1
a85 1
	for( i = 0; i < ncurves; i++ )  {
d88 2
a89 2
		v = curves[i];
		for( j = 0; j < pts_per_curve; j++ )  {
d103 1
a103 1
		VMOVE( v, curves[i] );		/* replicate first point */
d105 1
a105 1
	return( curves );
a129 2
	LOCAL int	pts_per_curve;
	LOCAL int	ncurves;
d131 1
d133 1
a133 2
	ncurves = rp[0].a.a_m;
	pts_per_curve = rp[0].a.a_n;
d135 4
a138 1
	curves = rt_ars_readin( rp, stp->st_pathmat );
d147 1
a147 1
	for( i = 0; i < ncurves; i++ )  {
d150 2
a151 2
		v = curves[i];
		for( j = 0; j < pts_per_curve; j++ )  {
d175 1
a175 1
	for( i = 0; i < ncurves-1; i++ )  {
d178 3
a180 3
		v1 = curves[i];
		v2 = curves[i+1];
		for( j = 0; j < pts_per_curve;
d197 2
a198 2
	for( i = 0; i < ncurves; i++ )  {
		rt_free( (char *)curves[i], "ars curve" );
d200 1
a200 1
	rt_free( (char *)curves, "ars curve ptrs" );
d611 1
a611 3
	register fastf_t **curves;	/* array of curve base addresses */
	int	pts_per_curve;
	int	ncurves;
d613 1
a613 2
	ncurves = rp[0].a.a_m;
	pts_per_curve = rp[0].a.a_n;
d615 4
a618 1
	curves = rt_ars_readin( rp, mat );
d624 1
a624 1
	for( i = 0; i < ncurves; i++ )  {
d627 1
a627 1
		v1 = curves[i];
d630 1
a630 1
		for( j = 1; j <= pts_per_curve; j++, v1 += ELEMENTS_PER_VECT )
d637 4
a640 4
	for( i = 0; i < pts_per_curve; i++ )  {
		ADD_VL( vhead, &curves[0][i*ELEMENTS_PER_VECT], 0 );
		for( j = 1; j < ncurves; j++ )
			ADD_VL( vhead, &curves[j][i*ELEMENTS_PER_VECT], 1 );
d646 2
a647 2
	for( i = 0; i < ncurves; i++ )  {
		rt_free( (char *)curves[i], "ars curve" );
d649 1
a649 1
	rt_free( (char *)curves, "ars curves[]" );
@


9.3
log
@Changed type of st_specific to genptr_t
@
text
@d2 1
a2 1
 *			A R S . C
d20 1
a20 1
static char RCSars[] = "@@(#)$Header: g_ars.c,v 9.2 90/01/31 12:48:10 mike Locked $ (BRL)";
d36 1
a36 1
extern fastf_t *rd_curve();
d38 2
a39 2
HIDDEN void	ars_hitsort();
extern int	arsface();
d42 1
a42 1
 *			A R S _ R E A D I N
d48 1
a48 1
ars_readin( rp, mat )
d69 1
a69 1
		curves[i] = rd_curve( &rp[currec], pts_per_curve );
d102 1
a102 1
 *			A R S _ P R E P
d115 1
a115 1
ars_prep( stp, rp, rtip )
d130 1
a130 1
	curves = ars_readin( rp, stp->st_pathmat );
d165 1
a165 1
	 *  Will examine curves[i][pts_per_curve], provided by rd_curve.
d175 1
a175 1
			arsface( stp,
d179 1
a179 1
			arsface( stp,
d198 1
a198 1
 *			R D _ C U R V E
d200 1
a200 1
 *  rd_curve() reads a set of ARS B records and returns a pointer
d204 1
a204 1
rd_curve(rp, npts)
d224 1
a224 1
			rt_log("ars.c/rd_curve():  non-ARS_B record!\n");
d238 1
a238 1
 *			A R S F A C E
d249 1
a249 1
arsface( stp, ap, bp, cp )
d291 1
a291 1
 *  			A R S _ P R I N T
d294 1
a294 1
ars_print( stp )
d315 1
a315 1
 *			A R S _ S H O T
d325 1
a325 1
ars_shot( stp, rp, ap )
d407 1
a407 1
	ars_hitsort( hits, nhits );
d468 1
a468 1
 *			A R S _ H I T S O R T
d471 1
a471 1
ars_hitsort( h, nh )
d490 1
a490 1
 *  			A R S _ N O R M
d495 1
a495 1
ars_norm( hitp, stp, rp )
d508 1
a508 1
 *			A R S _ C U R V E
d515 1
a515 1
ars_curve( cvp, hitp, stp )
d528 1
a528 1
 *  			A R S _ U V
d536 1
a536 1
ars_uv( ap, stp, hitp, uvp )
d557 1
a557 1
			rt_log("ars_uv: bad uv=%g,%g\n", uvp->uv_u, uvp->uv_v);
d568 1
a568 1
 *			A R S _ F R E E
d571 1
a571 1
ars_free( stp )
d586 1
a586 1
ars_class()
d592 1
a592 1
 *			A R S _ P L O T
d594 2
a595 2
void
ars_plot( rp, mat, vhead, dp )
d610 1
a610 1
	curves = ars_readin( rp, mat );
d642 7
@


9.2
log
@Bug fix: ars_shot(): changed test for nhits++ > MAXHITS to pre-increment
to insure that nhits never exceeds MAXHITS.  Previous behavior caused
ars_hitsort to exceed the bounds of the hits[] array and clobber stack
variables such as stp.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: g_ars.c,v 9.1 89/05/19 05:56:04 moss Locked $ (BRL)";
d161 1
a161 1
	stp->st_specific = (int *) 0;
d286 1
a286 1
	stp->st_specific = (int *)trip;
@


9.1
log
@Release_3.5
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: g_ars.c,v 8.5 89/04/17 17:18:51 mike Exp $ (BRL)";
d393 5
a397 1
		if( nhits++ >= MAXHITS )  {
@


8.5
log
@Calling sequence to xxx_prep() shortened from 6 to 3 args.
Database conversion moved into prep routines.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: g_ars.c,v 8.4 89/04/11 12:02:07 mike Locked $ (BRL)";
@


8.4
log
@lint cleanup
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 8.3 88/12/06 00:02:34 phil Locked $ (BRL)";
d115 1
a115 2
ars_prep( vecxx, stp, mat, rp, rtip, dp )
fastf_t		*vecxx;
a116 1
matp_t		mat;
a118 1
struct directory *dp;
d130 1
a130 1
	curves = ars_readin( rp, mat );
@


8.3
log
@Added _plot() routines, and db_*() interfaces.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: /cad/d/mike/cad/librt/RCS/ars.c,v 1.3 88/11/03 12:35:12 mike Exp $ (BRL)";
d39 1
a56 1
	LOCAL fastf_t	f;
d114 1
a127 1
	LOCAL int	pts;		/* return from arsface() */
a210 1
	LOCAL int bytes;
d251 1
a301 1
	register int i;
d598 1
@


8.2
log
@Added work-around for the Alliant struct copy bug while using -ce option.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 7.4 88/07/15 04:13:43 mike Exp $ (BRL)";
d41 1
a41 4
 *			A R S _ P R E P
 *  
 *  This routine is used to prepare a list of planar faces for
 *  being shot at by the ars routines.
d43 2
a44 6
 * Process an ARS, which is represented as a vector
 * from the origin to the first point, and many vectors
 * from the first point to the remaining points.
 *  
 *  This routine is unusual in that it has to read additional
 *  database records to obtain all the necessary information.
d46 3
a48 3
ars_prep( vecxx, stp, mat, sp, rtip )
fastf_t		*vecxx;
struct soltab	*stp;
a49 2
struct solidrec	*sp;
struct rt_i	*rtip;
a50 2
	LOCAL struct ars_rec *ap;	/* ARS A record pointer */
	LOCAL fastf_t dx, dy, dz;	/* For finding the bounding spheres */
d53 5
a57 6
	LOCAL int pts_per_curve;
	LOCAL int ncurves;
	LOCAL vect_t base_vect;
	LOCAL struct tri_specific *plp;
	LOCAL int pts;			/* return from arsface() */
	LOCAL fastf_t f;
d59 2
a60 3
	ap = (struct ars_rec *) sp;	/* PUN for record.anything */
	ncurves = ap->a_m;
	pts_per_curve = ap->a_n;
d67 1
d69 2
a70 1
		curves[i] = rd_curve( rtip, pts_per_curve );
d86 1
d98 2
d101 34
d202 1
a202 1
 *  
d207 2
a208 2
rd_curve(rtip, npts)
struct rt_i	*rtip;
d216 2
a217 1
	LOCAL union record r;
d220 3
a222 4
	bytes = (npts+1) * sizeof(fastf_t) * ELEMENTS_PER_VECT;
	if( (fp = (fastf_t *)rt_malloc(bytes, "ars curve")) == (fastf_t *) 0 )
		rt_bomb("ars.c/rd_curve():  malloc error");
	base = fp;
d224 4
a227 5
	while( npts > 0 )  {
		if( fread( (char *)&r, sizeof(r), 1, rtip->fp ) != 1 )
			rt_bomb("ars.c/rd_curve():  read error");

		if( r.b.b_id != ID_ARS_B )  {
d233 2
a234 1
			VMOVE( fp, (&(r.b.b_values[i*3])) );	/* cvt from dbfloat_t, too */
a235 1
			npts--;
d395 1
a395 1
		
a458 8
#if defined( alliant ) && ! defined( STRUCT_COPY_WORKS )
			segp->seg_in.hit_dist = hits[i-2].hit_dist;
			segp->seg_in.hit_vpriv[X] = hits[i-2].hit_vpriv[X];
			segp->seg_in.hit_private = hits[i-2].hit_private;
			segp->seg_out.hit_dist = hits[i-1].hit_dist;
			segp->seg_out.hit_vpriv[X] = hits[i-1].hit_vpriv[X];
			segp->seg_out.hit_private = hits[i-1].hit_private;
#else
a460 1
#endif
d591 3
d595 4
a598 1
ars_plot()
d600 41
@


8.1
log
@Release_3.0
@
text
@d370 1
a370 1

d434 8
d444 1
@


7.4
log
@This version has been tested, and works without complaints
on 4 sample ARSs from VMB's /tlib.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 7.3 88/05/14 00:00:55 mike Locked $ (BRL)";
@


7.3
log
@lint fixes
added zero _uv() routines to some modules
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 7.2 88/02/06 05:36:23 mike Locked $ (BRL)";
d38 1
a38 1
void		HitSort();		/* XXX needs rt_ name */
d79 1
a79 1
	curves = (fastf_t **)malloc( i );
d167 1
a167 1
		free( (char *)curves[i] );
d169 1
a169 1
	free( (char *)curves );
d194 1
a194 1
	if( (fp = (fastf_t *)malloc(bytes)) == (fastf_t *) 0 )
d208 1
a208 1
			VMOVE( fp, &r.b.b_values[i*3] );	/* cvt, too */
d249 1
a249 1
		free( (char *)trip);
d255 3
a257 5
	/*  wn is a GIFT-style
	 *  normal, needing to point inwards, whereas N is an outward
	 *  pointing normal.
	 *  There is no chance of "fixing" the normals, as bumps in the
	 *  sides of the ARS can point in any direction.
d330 1
a330 1
		 *  Ray Direction dot N.  (N is outward-pointing normal)
d334 2
a335 1
			rt_log("Face N.Dir=%f\n", dn );
a365 1
		 *  It will be verified in ars_norm().
d371 1
a371 1
		if(rt_g.debug&DEBUG_ARB8) rt_log("ars: hit dist=%f, dn=%f\n", hp->hit_dist, dn );
d382 1
a382 1
	HitSort( hits, nhits );
d401 1
a401 1
		register int	i;
d403 23
a435 14

			/* Check in/out properties */
			if( segp->seg_in.hit_vpriv[X] > 0  ||
			   segp->seg_out.hit_vpriv[X] < 0 )  {
			   	rt_log("ars(%s): in/out error\n", stp->st_name );
			   	for( i=0; i<nhits; i++ )  {
			   		rt_log("%d:  dist=%g, %s\n",
			   			i,
				   		hits[i].hit_dist,
						(hits[i].hit_vpriv[X] < 0) ?
			   				"In" : "Out" );
			   	}
			   	return(SEG_NULL);
			}
d442 5
a446 2
void
HitSort( h, nh )
a476 1
	register fastf_t	dot, dn;
a479 6

	/* If these are < 0, it implies an inward direction */
	dn = hitp->hit_vpriv[X];
	if( dn > 0 )  rt_log("ars_norm, dn=%g?\n", dn);
	dot = VDOT( hitp->hit_normal, rp->r_dir );
	if( dot > 0 )  rt_log("ars_norm:  flipped N, dn=%g, dot=%g\n", dn, dot);
d532 1
a532 1
			rt_log("ars_uv: bad uv=%f,%f\n", uvp->uv_u, uvp->uv_v);
@


7.2
log
@rt_orthovec to vec_ortho
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 7.1 87/11/02 23:32:47 mike Locked $ (BRL)";
d38 2
d251 1
a251 1
			(void)rt_log("ars(%s): degenerate facet\n", stp->st_name);
d273 1
d435 1
d459 1
d486 1
d507 1
d542 1
d557 1
d560 1
d563 1
@


7.1
log
@Release 2.3
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 6.2 87/11/02 15:29:42 mike Exp $ (BRL)";
d489 1
a489 1
	rt_orthovec( cvp->crv_pdir, hitp->hit_normal );
@


6.2
log
@Added additional ARS normal checking.  Some problems exist.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 6.1 87/07/11 07:55:15 mike Rel $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 5.1 87/06/24 22:10:46 mike Rel $ (BRL)";
d364 1
a364 1
		 *  Really should mark and check this!
d369 1
a369 4
#ifdef never
		VJOIN1( hp->hit_point, rp->r_pt, k, rp->r_dir );
		VMOVE( hp->hit_normal, trip->tri_N );
#endif
d400 1
d403 1
a403 1
		while( nhits > 0 )  {
d410 16
a425 3
			segp->seg_in = hits[nhits-2];	/* struct copy */
			segp->seg_out = hits[nhits-1];	/* struct copy */
			nhits -= 2;
d462 1
d466 6
@


5.1
log
@Release 1.24
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 4.6 87/04/28 00:27:25 phil Exp $ (BRL)";
@


4.6
log
@changed curve convention
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 4.5 87/03/23 23:42:29 phil Locked $ (BRL)";
@


4.5
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 4.4 87/03/11 01:25:59 mike Exp $ (BRL)";
d463 1
a463 1
ars_curve( cvp, hitp, stp, rp )
a466 1
struct xray *rp;
a474 1

a529 1

@


4.4
log
@Improved handling of normal vectors, added curvature.
Added a uv routine which may be bogus.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 4.3 87/03/10 23:42:10 mike Exp $ (BRL)";
d32 2
d51 6
a56 5
ars_prep( vecxx, stp, mat, sp )
fastf_t *vecxx;
struct soltab *stp;
matp_t mat;
struct solidrec *sp;
d79 1
a79 1
		curves[i] = rd_curve( pts_per_curve );
d179 3
a181 2
rd_curve(npts)
int npts;
d197 1
a197 1
		if( fread( (char *)&r, sizeof(r), 1, rt_i.fp ) != 1 )
d278 1
a278 1
	if( trip == (struct tri_specific *)0 )  {
d516 18
d535 4
@


4.3
log
@For Stay, switched 3rd arg to ft_shoot() from resource pointer
(member of application struct) to application struct pointer.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 4.2 87/02/12 22:10:46 mike Locked $ (BRL)";
d334 1
a334 1
		if( abs_dn <= 0.0001 )
d362 4
a366 3

		/* HIT is within planar face */
		hp->hit_dist = k;
d368 2
a369 1
		if(rt_g.debug&DEBUG_ARB8) rt_log("ars: hit dist=%f, dn=%f, k=%f\n", hp->hit_dist, dn, k );
d386 1
a386 5
		 * the dn==0 check above.  Thus, we will make the last
		 * surface infinitely thin and just replicate the entry
		 * point as the exit point.  This at least makes the
		 * presence of this solid known.  There may be something
		 * better we can do.
d388 1
a388 4
		hits[nhits] = hits[nhits-1];	/* struct copy */
		VREVERSE( hits[nhits].hit_normal, hits[nhits-1].hit_normal );
		hits[nhits].hit_dist *= 1.0001;
		rt_log("ERROR: ars(%s): %d hits, false exit\n",
a389 1
		nhits++;
d391 3
a393 2
			rt_log("%f, ", hits[i].hit_dist );
		rt_log("\n");
d435 9
a443 1
ars_norm()
d445 5
d451 62
a512 1
ars_uv()
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 4.1 86/12/29 03:44:33 mike Rel1 $ (BRL)";
d299 1
a299 1
ars_shot( stp, rp, res )
d302 1
a302 1
struct resource *res;
d409 1
a409 1
			GET_SEG(newseg, res);
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 3.6 86/12/24 08:05:25 mike Locked $ (BRL)";
@


3.6
log
@Revised for resource structure.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 3.5 86/08/12 04:15:08 mike Exp $ (BRL)";
@


3.5
log
@Changed #include directives for use with CC -I convention
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 3.4 86/07/24 06:08:27 mike Exp $ (BRL)";
d299 1
a299 1
ars_shot( stp, rp )
d302 1
d403 2
a404 1
		register struct seg *segp;			/* XXX */
d407 3
a409 2
			register struct seg *newseg;		/* XXX */
			GET_SEG(newseg);
@


3.4
log
@Added uvcoord support
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 3.3 86/07/19 04:37:57 mike Exp $ (BRL)";
d25 6
a30 6
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/db.h"
#include "../h/raytrace.h"
#include "debug.h"
#include "plane.h"
@


3.3
log
@Removed stray header file.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 3.2 86/07/17 18:19:20 mike Exp $ (BRL)";
a33 4
#define ARSMINMAX(a,b,c)	{ FAST fastf_t ftemp;\
			if( (ftemp = (c)) < (a) )  a = ftemp;\
			if( ftemp > (b) )  b = ftemp; }

d108 2
a109 2
	stp->st_max[X] = stp->st_max[Y] = stp->st_max[Z] = -INFINITY;
	stp->st_min[X] = stp->st_min[Y] = stp->st_min[Z] =  INFINITY;
d116 2
a117 4
			ARSMINMAX( stp->st_min[X], stp->st_max[X], *v++ );
			ARSMINMAX( stp->st_min[Y], stp->st_max[Y], *v++ );
			ARSMINMAX( stp->st_min[Z], stp->st_max[Z], *v++ );
			v++;		/* depends on ELEMENTS_PER_VECT */
@


3.2
log
@Upgraded to read the database using stdio.
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 3.1 86/07/11 01:31:27 mike Exp $ (BRL)";
a29 1
#include "rtdir.h"
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d20 1
a20 1
static char RCSars[] = "@@(#)$Header: ars.c,v 3.0 86/06/10 01:32:31 mike Exp $ (BRL)";
d200 1
a200 1
		if( read( rt_i.fd, (char *) &r, sizeof(r) ) != sizeof(r) )
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: ars.c,v 2.2 86/06/09 21:49:51 mike Exp $ (BRL)";
d31 1
a41 15
 *  Describe the ars_specific structure.
 */
#define MAXPTS	3
static point_t	points[MAXPTS];		/* Actual points on plane */

struct tri_specific  {
	point_t	tri_A;			/* triangle vertex (A) */
	vect_t	tri_BA;			/* B - A (second point) */
	vect_t	tri_CA;			/* C - A (third point) */
	vect_t	tri_wn;			/* facet normal (non-unit) */
	vect_t	tri_N;			/* unit normal vector */
	struct tri_specific *tri_forw;	/* Next facet */
};

/*
d248 2
a249 2
	if( NEAR_ZERO(m1) || NEAR_ZERO(m2) ||
	    NEAR_ZERO(m3) || NEAR_ZERO(m4) )  {
@


2.2
log
@rt and librt separated
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: ars.c,v 2.1 85/08/31 06:02:54 mike Exp $ (BRL)";
d210 1
a210 1
		rtbomb("ars.c/rd_curve():  malloc error");
d214 2
a215 2
		if( read( ged_fd, (char *) &r, sizeof(r) ) != sizeof(r) )
			rtbomb("ars.c/rd_curve():  read error");
d218 1
a218 1
			rtlog("ars.c/rd_curve():  non-ARS_B record!\n");
d265 2
a266 2
		if( debug & DEBUG_ARB8 )
			(void)rtlog("ars(%s): degenerate facet\n", stp->st_name);
d296 1
a296 1
		rtlog("ars(%s):  no faces\n", stp->st_name);
d305 1
a305 1
		rtlog("\n");
d348 2
a349 2
		if( debug & DEBUG_ARB8 )
			rtlog("Face N.Dir=%f\n", dn );
d387 1
a387 1
		if(debug&DEBUG_ARB8) rtlog("ars: hit dist=%f, dn=%f, k=%f\n", hp->hit_dist, dn, k );
d389 1
a389 1
			rtlog("ars(%s): too many hits\n", stp->st_name);
d413 1
a413 1
		rtlog("ERROR: ars(%s): %d hits, false exit\n",
d417 2
a418 2
			rtlog("%f, ", hits[i].hit_dist );
		rtlog("\n");
@


2.1
log
@Version 2 of RT
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: ars.c,v 1.1 85/08/03 08:16:58 mike Exp $ (BRL)";
d28 1
a28 1
#include "raytrace.h"
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: ars.c,v 1.13 85/03/25 11:44:05 mike Exp $ (BRL)";
d24 1
d83 1
d147 1
d149 1
d151 3
a153 1
	stp->st_radsq = dx*dx + dy*dy + dz*dz;
d218 1
a218 1
			fprintf(stderr,"ars.c/rd_curve():  non-ARS_B record!\n");
d266 1
a266 1
			(void)fprintf(stderr,"ars(%s): degenerate facet\n", stp->st_name);
d296 1
a296 1
		fprintf(stderr,"ars(%s):  no faces\n", stp->st_name);
d305 1
a305 1
		putc('\n',stderr);
d349 1
a349 1
			fprintf(stderr,"Face N.Dir=%f\n", dn );
d387 1
a387 1
		if(debug&DEBUG_ARB8) fprintf(stderr,"ars: hit dist=%f, dn=%f, k=%f\n", hp->hit_dist, dn, k );
d389 1
a389 1
			fprintf(stderr,"ars(%s): too many hits\n", stp->st_name);
d413 1
a413 1
		fprintf(stderr,"ERROR: ars(%s): %d hits, false exit\n",
d417 2
a418 2
			fprintf(stderr,"%f, ", hits[i].hit_dist );
		fprintf(stderr,"\n");
a430 1
			segp->seg_flag = SEG_IN|SEG_OUT;
d456 7
@
