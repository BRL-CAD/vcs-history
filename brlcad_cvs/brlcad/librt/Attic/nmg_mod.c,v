head	11.52;
access;
symbols
	ansi-20040405-merged:11.48.2.2
	postmerge-20040405-ansi:11.50
	premerge-20040404-ansi:11.49
	postmerge-autoconf:11.49
	autoconf-freeze:11.48.10.2
	premerge-autoconf:11.49
	ansi-20040316-freeze:11.48.2.1
	postmerge-20040315-windows:11.49
	premerge-20040315-windows:11.49
	windows-20040315-freeze:11.48.4.1
	autoconf-20031203:11.48
	autoconf-20031202:11.48
	autoconf-branch:11.48.0.10
	phong-branch:11.48.0.8
	photonmap-branch:11.48.0.6
	rel-6-1-DP:11.48
	windows-branch:11.48.0.4
	rel-6-0-2:11.46
	ansi-branch:11.48.0.2
	rel-6-0-1-branch:11.46.0.2
	hartley-6-0-post:11.47
	hartley-6-0-pre:11.46
	rel-6-0-1:11.46
	rel-6-0:11.46
	rel-5-4:11.41
	offsite-5-3-pre:11.45
	rel-5-3:11.41
	rel-5-2:11.41
	rel-5-1-branch:11.41.0.2
	rel-5-1:11.41
	rel-5-0:11.40
	rel-5-0-beta:11.39
	rel-4-5:11.38
	ctj-4-5-post:11.38
	ctj-4-5-pre:11.38
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.52
date	2004.05.21.18.07.33;	author morrison;	state dead;
branches;
next	11.51;

11.51
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.50;

11.50
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.49;

11.49
date	2004.02.02.17.39.24;	author morrison;	state Exp;
branches;
next	11.48;

11.48
date	2002.08.20.17.08.05;	author jra;	state Exp;
branches
	11.48.2.1
	11.48.4.1
	11.48.10.1;
next	11.47;

11.47
date	2002.08.15.20.55.17;	author hartley;	state Exp;
branches;
next	11.46;

11.46
date	2001.04.20.22.29.52;	author morrison;	state Exp;
branches;
next	11.45;

11.45
date	2000.08.31.03.57.41;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	2000.08.25.05.18.42;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	2000.08.21.02.02.33;	author butler;	state Exp;
branches;
next	11.42;

11.42
date	2000.07.10.23.01.44;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	99.12.30.15.37.24;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	99.06.03.01.39.14;	author mike;	state Exp;
branches;
next	11.39;

11.39
date	98.05.13.13.10.11;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	97.06.25.04.41.09;	author mike;	state Exp;
branches;
next	11.37;

11.37
date	97.06.13.21.42.51;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	97.06.11.19.48.47;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	97.06.10.13.06.33;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	97.04.16.20.27.32;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	96.12.30.13.39.33;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	96.10.21.19.09.44;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	96.10.21.02.49.29;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	96.05.29.12.38.31;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	96.05.16.21.56.18;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	96.04.26.15.06.18;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	96.04.22.12.19.01;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	96.03.25.20.50.02;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	96.03.07.20.28.41;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	96.03.05.21.35.42;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	96.02.16.15.38.57;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	96.02.14.15.56.35;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	95.11.30.17.27.35;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	95.11.30.04.06.38;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	95.11.29.17.13.18;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	95.11.22.21.27.04;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	95.03.09.13.33.09;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	95.03.02.14.33.25;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	95.03.01.06.20.54;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	95.02.28.04.16.35;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	95.02.28.00.15.48;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	95.02.24.06.42.31;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	95.02.23.13.04.20;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	95.02.23.06.15.09;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	95.02.23.05.55.59;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.02.21.23.41.36;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.02.20.16.17.41;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.02.18.13.04.30;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.02.17.16.26.33;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.02.01.02.27.49;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.30.15.29.03;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.05;	author mike;	state Rel4_4;
branches;
next	10.101;

10.101
date	94.12.05.16.07.59;	author mike;	state Exp;
branches;
next	10.100;

10.100
date	94.11.21.16.27.25;	author jra;	state Exp;
branches;
next	10.99;

10.99
date	94.11.18.16.22.42;	author jra;	state Exp;
branches;
next	10.98;

10.98
date	94.11.17.17.01.44;	author jra;	state Exp;
branches;
next	10.97;

10.97
date	94.11.05.00.32.08;	author mike;	state Exp;
branches;
next	10.96;

10.96
date	94.10.07.16.04.18;	author jra;	state Exp;
branches;
next	10.95;

10.95
date	94.09.16.20.46.02;	author mike;	state Exp;
branches;
next	10.94;

10.94
date	94.09.13.20.56.38;	author mike;	state Exp;
branches;
next	10.93;

10.93
date	94.09.12.22.40.34;	author mike;	state Exp;
branches;
next	10.92;

10.92
date	94.09.10.04.37.10;	author mike;	state Exp;
branches;
next	10.91;

10.91
date	94.09.03.03.01.48;	author mike;	state Exp;
branches;
next	10.90;

10.90
date	94.09.02.17.58.39;	author mike;	state Exp;
branches;
next	10.89;

10.89
date	94.09.02.00.32.34;	author mike;	state Exp;
branches;
next	10.88;

10.88
date	94.08.09.19.38.17;	author mike;	state Exp;
branches;
next	10.87;

10.87
date	94.07.06.16.49.32;	author mike;	state Exp;
branches;
next	10.86;

10.86
date	94.07.04.02.58.22;	author mike;	state Exp;
branches;
next	10.85;

10.85
date	94.07.03.18.52.36;	author mike;	state Exp;
branches;
next	10.84;

10.84
date	94.07.02.02.20.50;	author mike;	state Exp;
branches;
next	10.83;

10.83
date	94.04.22.10.06.03;	author butler;	state Exp;
branches;
next	10.82;

10.82
date	94.04.19.15.21.21;	author mike;	state Exp;
branches;
next	10.81;

10.81
date	94.03.11.16.36.00;	author mike;	state Exp;
branches;
next	10.80;

10.80
date	94.03.11.01.17.31;	author mike;	state Exp;
branches;
next	10.79;

10.79
date	94.03.10.07.08.31;	author butler;	state Exp;
branches;
next	10.78;

10.78
date	94.03.10.02.11.54;	author butler;	state Exp;
branches;
next	10.77;

10.77
date	94.03.04.23.17.00;	author mike;	state Exp;
branches;
next	10.76;

10.76
date	94.03.03.11.06.51;	author jra;	state Exp;
branches;
next	10.75;

10.75
date	94.03.02.18.17.57;	author mike;	state Exp;
branches;
next	10.74;

10.74
date	94.02.24.08.32.52;	author mike;	state Exp;
branches;
next	10.73;

10.73
date	94.02.24.06.19.42;	author mike;	state Exp;
branches;
next	10.72;

10.72
date	94.02.22.22.54.02;	author mike;	state Exp;
branches;
next	10.71;

10.71
date	94.02.22.21.26.35;	author mike;	state Exp;
branches;
next	10.70;

10.70
date	94.02.04.03.37.48;	author mike;	state Exp;
branches;
next	10.69;

10.69
date	94.02.03.21.34.28;	author mike;	state Exp;
branches;
next	10.68;

10.68
date	94.02.02.00.16.23;	author mike;	state Exp;
branches;
next	10.67;

10.67
date	94.01.24.10.46.00;	author jra;	state Exp;
branches;
next	10.66;

10.66
date	94.01.22.05.24.27;	author mike;	state Exp;
branches;
next	10.65;

10.65
date	94.01.14.02.45.05;	author mike;	state Exp;
branches;
next	10.64;

10.64
date	93.12.28.10.36.49;	author jra;	state Exp;
branches;
next	10.63;

10.63
date	93.12.23.05.41.39;	author mike;	state Exp;
branches;
next	10.62;

10.62
date	93.12.22.06.12.51;	author mike;	state Exp;
branches;
next	10.61;

10.61
date	93.12.03.03.35.41;	author mike;	state Exp;
branches;
next	10.60;

10.60
date	93.12.02.20.45.53;	author mike;	state Exp;
branches;
next	10.59;

10.59
date	93.12.02.20.05.18;	author mike;	state Exp;
branches;
next	10.58;

10.58
date	93.11.18.02.09.24;	author mike;	state Exp;
branches;
next	10.57;

10.57
date	93.11.09.17.03.12;	author jra;	state Exp;
branches;
next	10.56;

10.56
date	93.10.25.17.48.36;	author mike;	state Exp;
branches;
next	10.55;

10.55
date	93.10.25.02.28.03;	author cjohnson;	state Exp;
branches;
next	10.54;

10.54
date	93.10.24.03.55.01;	author mike;	state Exp;
branches;
next	10.53;

10.53
date	93.10.22.22.28.13;	author mike;	state Exp;
branches;
next	10.52;

10.52
date	93.10.08.13.10.01;	author jra;	state Exp;
branches;
next	10.51;

10.51
date	93.10.01.20.51.53;	author mike;	state Exp;
branches;
next	10.50;

10.50
date	93.06.08.20.16.39;	author mike;	state Exp;
branches;
next	10.49;

10.49
date	93.05.08.02.45.22;	author butler;	state Exp;
branches;
next	10.48;

10.48
date	93.04.27.01.53.33;	author butler;	state Exp;
branches;
next	10.47;

10.47
date	93.04.09.02.10.21;	author mike;	state Exp;
branches;
next	10.46;

10.46
date	93.04.08.03.18.52;	author mike;	state Exp;
branches;
next	10.45;

10.45
date	93.04.03.01.16.41;	author mike;	state Exp;
branches;
next	10.44;

10.44
date	93.04.02.23.21.36;	author butler;	state Exp;
branches;
next	10.43;

10.43
date	93.03.26.23.21.51;	author mike;	state Exp;
branches;
next	10.42;

10.42
date	93.03.26.23.00.05;	author mike;	state Exp;
branches;
next	10.41;

10.41
date	93.03.26.21.52.34;	author mike;	state Exp;
branches;
next	10.40;

10.40
date	93.03.26.21.28.55;	author mike;	state Exp;
branches;
next	10.39;

10.39
date	93.03.26.21.23.49;	author mike;	state Exp;
branches;
next	10.38;

10.38
date	93.03.26.21.19.47;	author mike;	state Exp;
branches;
next	10.37;

10.37
date	93.03.26.21.09.54;	author mike;	state Exp;
branches;
next	10.36;

10.36
date	93.03.25.23.19.40;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	93.03.25.22.41.35;	author mike;	state Exp;
branches;
next	10.34;

10.34
date	93.03.25.22.34.10;	author mike;	state Exp;
branches;
next	10.33;

10.33
date	93.03.25.18.05.20;	author mm;	state Exp;
branches;
next	10.32;

10.32
date	93.03.25.02.58.04;	author mike;	state Exp;
branches;
next	10.31;

10.31
date	93.03.24.22.36.04;	author mm;	state Exp;
branches;
next	10.30;

10.30
date	93.03.24.22.24.08;	author mm;	state Exp;
branches;
next	10.29;

10.29
date	93.03.24.03.22.30;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	93.03.24.02.41.45;	author mike;	state Exp;
branches;
next	10.27;

10.27
date	93.03.24.01.12.33;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	93.03.23.22.22.20;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	93.03.22.23.08.26;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	93.03.22.15.48.56;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	93.03.16.20.42.46;	author mm;	state Exp;
branches;
next	10.22;

10.22
date	93.03.13.01.48.46;	author mike;	state Exp;
branches;
next	10.21;

10.21
date	93.03.12.21.01.37;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	93.03.08.22.50.28;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	93.03.03.01.51.09;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	93.03.02.22.15.08;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	93.03.02.21.23.30;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	93.02.24.01.18.47;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	93.02.24.00.58.56;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	93.02.19.04.47.10;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	93.02.19.03.05.48;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	93.02.12.00.47.47;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	93.02.10.01.39.53;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	93.02.06.04.16.14;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	92.12.14.14.09.01;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.11.16.23.12.40;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.11.11.00.08.09;	author butler;	state Exp;
branches;
next	10.6;

10.6
date	92.08.05.22.28.40;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.07.23.05.31.54;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.07.20.23.08.47;	author butler;	state Exp;
branches;
next	10.3;

10.3
date	92.02.25.00.06.49;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.02.21.01.32.15;	author butler;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.49;	author mike;	state Rel4_0;
branches;
next	2.13;

2.13
date	91.07.26.23.45.58;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	91.06.22.20.27.07;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	91.06.22.20.12.57;	author butler;	state Exp;
branches;
next	2.10;

2.10
date	91.06.17.20.42.17;	author butler;	state Exp;
branches;
next	2.9;

2.9
date	91.06.13.05.42.44;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	91.06.03.19.25.42;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	91.05.24.19.08.17;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	91.05.24.19.00.12;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	91.05.22.23.24.40;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	91.05.18.03.03.26;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	91.04.03.03.12.00;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	91.04.01.19.59.45;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	91.04.01.16.03.57;	author mike;	state Exp;
branches;
next	;

11.48.2.1
date	2002.09.19.18.01.41;	author morrison;	state Exp;
branches;
next	11.48.2.2;

11.48.2.2
date	2004.03.17.21.18.54;	author morrison;	state Exp;
branches;
next	;

11.48.4.1
date	2004.03.11.23.43.42;	author morrison;	state Exp;
branches;
next	;

11.48.10.1
date	2004.02.12.18.37.45;	author erikg;	state Exp;
branches;
next	11.48.10.2;

11.48.10.2
date	2004.03.15.14.07.27;	author erikg;	state Exp;
branches;
next	;


desc
@NMG data structure modification routines
@


11.52
log
@moved to src/
@
text
@/*
 *			N M G _ M O D . C
 *
 *  Routines for modifying n-Manifold Geometry data structures.
 *
 *  Authors -
 *	Lee A. Butler
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1991-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_mod.c,v 11.51 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <string.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"

/*
 *			N M G _ M E R G E _ R E G I O N S
 */
void
nmg_merge_regions(struct nmgregion *r1, struct nmgregion *r2, const struct bn_tol *tol)
{
	struct model *m;

	NMG_CK_REGION( r1 );
	NMG_CK_REGION( r2 );
	BN_CK_TOL( tol );

	m = r1->m_p;
	NMG_CK_MODEL( m );

	if( r2->m_p != m )
		rt_bomb( "nmg_merge_regions: Tried to merge regions from different models!!" );

	/* move all of r2's faces into r1 */
	while( BU_LIST_NON_EMPTY( &r2->s_hd ) )
	{
		struct shell *s;

		s = BU_LIST_FIRST( shell, &r2->s_hd );
		BU_LIST_DEQUEUE( &s->l );
		s->r_p = r1;
		BU_LIST_APPEND( &r1->s_hd, &s->l );
	}

	(void)nmg_kr( r2 );
	nmg_rebound( m, tol );
}

/************************************************************************
 *									*
 *				SHELL Routines				*
 *									*
 ************************************************************************/

/*
 *			N M G _ S H E L L _ C O P L A N A R _ F A C E _ M E R G E
 *
 *  A geometric routine to
 *  find all pairs of faces in a shell that have the same plane equation
 *  (to within the given tolerance), and combine them into a single face.
 *
 *  Note that this may result in some of the verticies being very slightly
 *  off the plane equation, but the geometry routines need to be prepared
 *  for this in any case.
 *  If the "simplify" flag is set, pairs of loops in the face that touch
 *  will be combined into a single loop where possible.
 *
 *  XXX Perhaps should be recast as "nmg_shell_shared_face_merge()", leaving
 *  XXX all the geometric calculations to the code in nmg_fuse.c ?
 */
void
nmg_shell_coplanar_face_merge(struct shell *s, const struct bn_tol *tol, const int simplify)
{
	struct model	*m;
	int		len;
	char		*flags1;
	char		*flags2;
	struct faceuse	*fu1;
	struct faceuse	*fu2;
	struct face	*f1;
	struct face	*f2;
	struct face_g_plane	*fg1;
	struct face_g_plane	*fg2;

	NMG_CK_SHELL(s);
	m = nmg_find_model( &s->l.magic );
	len = sizeof(char) * m->maxindex * 2;
	flags1 = (char *)bu_calloc( sizeof(char), m->maxindex * 2,
		"nmg_shell_coplanar_face_merge flags1[]" );
	flags2 = (char *)bu_calloc( sizeof(char), m->maxindex * 2,
		"nmg_shell_coplanar_face_merge flags2[]" );

	/* Visit each face in the shell */
	for( BU_LIST_FOR( fu1, faceuse, &s->fu_hd ) )  {
		plane_t		n1;

		if( BU_LIST_NEXT_IS_HEAD(fu1, &s->fu_hd) )  break;
		f1 = fu1->f_p;
		NMG_CK_FACE(f1);
		if( NMG_INDEX_TEST(flags1, f1) )  continue;
		NMG_INDEX_SET(flags1, f1);

		fg1 = f1->g.plane_p;
		NMG_CK_FACE_G_PLANE(fg1);
		NMG_GET_FU_PLANE( n1, fu1 );

		/* For this face, visit all remaining faces in the shell. */
		/* Don't revisit any faces already considered. */
		bcopy( flags1, flags2, len );
		for( fu2 = BU_LIST_NEXT(faceuse, &fu1->l);
		     BU_LIST_NOT_HEAD(fu2, &s->fu_hd);
		     fu2 = BU_LIST_NEXT(faceuse,&fu2->l)
		)  {
			register fastf_t	dist;
			plane_t			n2;

			f2 = fu2->f_p;
			NMG_CK_FACE(f2);
			if( NMG_INDEX_TEST(flags2, f2) )  continue;
			NMG_INDEX_SET(flags2, f2);

			fg2 = f2->g.plane_p;
			NMG_CK_FACE_G_PLANE(fg2);

			if( fu2->fumate_p == fu1 || fu1->fumate_p == fu2 )
				rt_bomb("nmg_shell_coplanar_face_merge() mate confusion\n");

			/* See if face geometry is shared & same direction */
			if( fg1 != fg2 || f1->flip != f2->flip )  {
				/* If plane equations are different, done */
				NMG_GET_FU_PLANE( n2, fu2 );

				/* Compare distances from origin */
				dist = n1[3] - n2[3];
				if( !NEAR_ZERO(dist, tol->dist) ) continue;

				/*
				 *  Compare angle between normals.
				 *  Can't just use BN_VECT_ARE_PARALLEL here,
				 *  because they must point in the same direction.
				 */
				dist = VDOT( n1, n2 );
				if( !(dist >= tol->para) ) continue;

				if( nmg_ck_fu_verts( fu2, f1, tol ) )
					continue;
			}

			/*
			 * Plane equations are the same, within tolerance,
			 * or by shared fg topology.
			 * Move everything into fu1, and
			 * kill now empty faceuse, fumate, and face
			 */
			{
				struct faceuse	*prev_fu;
				prev_fu = BU_LIST_PREV(faceuse, &fu2->l);
				/* The prev_fu can never be the head */
				if( BU_LIST_IS_HEAD(prev_fu, &s->fu_hd) )
					rt_bomb("prev is head?\n");

				nmg_jf( fu1, fu2 );

				fu2 = prev_fu;
			}

			/* There is now the option of simplifying the face,
			 * by removing unnecessary edges.
			 */
			if( simplify )  {
				struct loopuse *lu;

				for (BU_LIST_FOR(lu, loopuse, &fu1->lu_hd))
					nmg_simplify_loop(lu);
			}
		}
	}
	bu_free( (char *)flags1, "nmg_shell_coplanar_face_merge flags1[]" );
	bu_free( (char *)flags2, "nmg_shell_coplanar_face_merge flags2[]" );

	nmg_shell_a( s, tol );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_shell_coplanar_face_merge(s=x%x, tol=x%x, simplify=%d)\n",
			s, tol, simplify);
	}
}

/*
 *			N M G _ S I M P L I F Y _ S H E L L
 *
 *  Simplify all the faces in this shell, where possible.
 *  Under some circumstances this may result in an empty shell as a result.
 *
 * Returns -
 *	0	If all was OK
 *	1	If shell is now empty
 */
int
nmg_simplify_shell(struct shell *s)
{
	struct faceuse *fu;
	int ret_val;

	NMG_CK_SHELL(s);

	for (BU_LIST_FOR(fu, faceuse, &s->fu_hd)) {
		if( nmg_simplify_face(fu) )  {
			struct faceuse	*kfu = fu;
			fu = BU_LIST_PREV( faceuse, &fu->l );
			nmg_kfu( kfu );
		}
	}

	ret_val = nmg_shell_is_empty(s);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_simplify_shell(s=x%x) returns %d\n", s , ret_val);
	}

	return( ret_val );
}

/*
 *			N M G _ R M _ R E D U N D A N C I E S
 *
 *  Remove all redundant parts between the different "levels" of a shell.
 *  Remove wire loops that match face loops.
 *  Remove wire edges that match edges in wire loops or face loops.
 *  Remove lone vertices (stored as wire loops on a single vertex) that
 *  match vertices in a face loop, wire loop, or wire edge.
 */
void
nmg_rm_redundancies(struct shell *s, const struct bn_tol *tol)
{
	struct faceuse	*fu;
	struct loopuse	*lu;
	struct edgeuse	*eu;
	struct vertexuse	*vu;
	long		magic1;

	NMG_CK_SHELL(s);
	BN_CK_TOL( tol );

	if( BU_LIST_NON_EMPTY( &s->fu_hd ) )  {
		/* Compare wire loops -vs- loops in faces */
		lu = BU_LIST_FIRST( loopuse, &s->lu_hd );
		while( BU_LIST_NOT_HEAD( lu, &s->lu_hd ) )  {
			register struct loopuse	*nextlu;
			NMG_CK_LOOPUSE(lu);
			NMG_CK_LOOP(lu->l_p);
			nextlu = BU_LIST_PNEXT( loopuse, lu );
			if( nmg_is_loop_in_facelist( lu->l_p, &s->fu_hd ) )  {
				/* Dispose of wire loop (and mate)
				 * which match face loop */
				if( nextlu == lu->lumate_p )
					nextlu = BU_LIST_PNEXT(loopuse, nextlu);
				nmg_klu( lu );
			}
			lu = nextlu;
		}

		/* Compare wire edges -vs- edges in loops in faces */
		eu = BU_LIST_FIRST( edgeuse, &s->eu_hd );
		while( BU_LIST_NOT_HEAD( eu, &s->eu_hd ) )  {
			register struct edgeuse *nexteu;
			NMG_CK_EDGEUSE(eu);
			NMG_CK_EDGE(eu->e_p);
			nexteu = BU_LIST_PNEXT( edgeuse, eu );
			if( nmg_is_edge_in_facelist( eu->e_p, &s->fu_hd ) )  {
				/* Dispose of wire edge (and mate) */
				if( nexteu == eu->eumate_p )
					nexteu = BU_LIST_PNEXT(edgeuse, nexteu);
				(void)nmg_keu(eu);
			}
			eu = nexteu;
		}
	}

	/* Compare wire edges -vs- edges in wire loops */
	eu = BU_LIST_FIRST( edgeuse, &s->eu_hd );
	while( BU_LIST_NOT_HEAD( eu, &s->eu_hd ) )  {
		register struct edgeuse *nexteu;
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGE(eu->e_p);
		nexteu = BU_LIST_PNEXT( edgeuse, eu );
		if( nmg_is_edge_in_looplist( eu->e_p, &s->lu_hd ) )  {
			/* Kill edge use and mate */
			if( nexteu == eu->eumate_p )
				nexteu = BU_LIST_PNEXT(edgeuse, nexteu);
			(void)nmg_keu(eu);
		}
		eu = nexteu;
	}

	/* Compare lone vertices against everything else */
	/* Individual vertices are stored as wire loops on a single vertex */
	lu = BU_LIST_FIRST( loopuse, &s->lu_hd );
	while( BU_LIST_NOT_HEAD( lu, &s->lu_hd ) )  {
		register struct loopuse	*nextlu;
		NMG_CK_LOOPUSE(lu);
		nextlu = BU_LIST_PNEXT( loopuse, lu );
		magic1 = BU_LIST_FIRST_MAGIC( &lu->down_hd );
		if( magic1 != NMG_VERTEXUSE_MAGIC )  {
			lu = nextlu;
			continue;
		}
		vu = BU_LIST_PNEXT( vertexuse, &lu->down_hd );
		NMG_CK_VERTEXUSE(vu);
		NMG_CK_VERTEX(vu->v_p);
		if( nmg_is_vertex_in_facelist( vu->v_p, &s->fu_hd ) ||
		    nmg_is_vertex_in_looplist( vu->v_p, &s->lu_hd,0 ) ||
		    nmg_is_vertex_in_edgelist( vu->v_p, &s->eu_hd ) )  {
		    	/* Kill lu and mate */
			if( nextlu == lu->lumate_p )
				nextlu = BU_LIST_PNEXT(loopuse, nextlu);
			nmg_klu( lu );
			lu = nextlu;
			continue;
		}
		lu = nextlu;
	}

	/* There really shouldn't be a lone vertex by now */
	if( s->vu_p )  bu_log("nmg_rm_redundancies() lone vertex?\n");

	/* get rid of matching OT_SAME/OT_OPPOSITE loops in same faceuse */
	fu = BU_LIST_FIRST( faceuse, &s->fu_hd );
	while( BU_LIST_NOT_HEAD( &fu->l, &s->fu_hd ) )
	{
		struct faceuse *next_fu;
		int lu1_count;
		int lu_count;

		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
		{
			fu = BU_LIST_NEXT( faceuse, &fu->l );
			continue;
		}

		next_fu = BU_LIST_NEXT( faceuse, &fu->l );
		if( next_fu == fu->fumate_p )
			next_fu = BU_LIST_NEXT( faceuse, &next_fu->l );

		lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
		while( BU_LIST_NOT_HEAD( &lu->l, &fu->lu_hd ) )
		{
			struct loopuse *next_lu;
			struct loopuse *lu1;
			struct edgeuse *eu;

			NMG_CK_LOOPUSE( lu );

			next_lu = BU_LIST_NEXT( loopuse, &lu->l );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			{
				lu = next_lu;
				continue;
			}

			/* count edges in lu */
			lu_count = 0;
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				lu_count++;

			/* look for anther loopuse with opposite orientation */
			lu1 = BU_LIST_FIRST( loopuse, &fu->lu_hd );
			while( BU_LIST_NOT_HEAD( &lu1->l, &fu->lu_hd ) )
			{
				struct loopuse *next_lu1;

				NMG_CK_LOOPUSE( lu1 );

				next_lu1 = BU_LIST_PNEXT( loopuse, &lu1->l );

				if( BU_LIST_FIRST_MAGIC( &lu1->down_hd ) != NMG_EDGEUSE_MAGIC )
				{
					lu1 = next_lu1;
					continue;
				}

				if( lu1 == lu )
				{
					lu1 = next_lu1;
					continue;
				}

				if( lu1->orientation == lu->orientation )
				{
					lu1 = next_lu1;
					continue;
				}

				/* count edges in lu1 */
				lu1_count = 0;
				for( BU_LIST_FOR( eu, edgeuse, &lu1->down_hd ) )
					lu1_count++;

				if( lu_count != lu1_count )
				{
					lu1 = next_lu1;
					continue;
				}

				if( nmg_classify_lu_lu( lu, lu1, tol ) != NMG_CLASS_AonBshared )
				{
					lu1 = next_lu1;
					continue;
				}

				/* lu and lu1 are identical, but with opposite orientations
				 * kill them both
				 */

				if( next_lu1 == lu )
					next_lu1 = BU_LIST_NEXT( loopuse, &next_lu1->l );

				if( next_lu == lu1 )
					next_lu = BU_LIST_NEXT( loopuse, &next_lu->l );

				(void)nmg_klu( lu );
				if( nmg_klu( lu1 ) )
				{
					/* faceuse is empty, kill it */
					if( nmg_kfu( fu ) )
					{
						/* shell is empty, set "nexts" to get out */
						next_fu = (struct faceuse *)(&s->fu_hd);
						next_lu = (struct loopuse *)NULL;
					}
					else
					{
						/* shell not empty, but fu is */
						next_lu = (struct loopuse *)NULL;
					}
				}
				break;
			}

			if( !next_lu )
				break;

			lu = next_lu;
		}
		fu = next_fu;
	}

	/* get rid of redundant loops in same fu (OT_SAME within an OT_SAME), etc. */
	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct loopuse *lu1;

			NMG_CK_LOOPUSE( lu );

			/* look for another loop with same orientation */
			lu1 = BU_LIST_FIRST( loopuse, &fu->lu_hd );
			while( BU_LIST_NOT_HEAD( &lu1->l, &fu->lu_hd ) )
			{
				struct loopuse *next_lu;
				struct loopuse *lu2;
				int found;

				NMG_CK_LOOPUSE( lu1 );

				next_lu = BU_LIST_PNEXT( loopuse, &lu1->l );

				if( lu1 == lu )
				{
					lu1 = next_lu;
					continue;
				}

				if( lu1->orientation != lu->orientation )
				{
					lu1 = next_lu;
					continue;
				}

				if( nmg_classify_lu_lu( lu1, lu, tol ) != NMG_CLASS_AinB )
				{
					lu1 = next_lu;
					continue;
				}

				/* lu1 is within lu and has same orientation.
				 * Check if there is a loop with opposite
				 * orientation between them.
				 */
				found = 0;
				for( BU_LIST_FOR( lu2, loopuse, &fu->lu_hd ) )
				{
					int class1,class2;

					NMG_CK_LOOPUSE( lu2 );

					if( lu2 == lu || lu2 == lu1 )
						continue;

					if( lu2->orientation == lu->orientation )
						continue;

					class1 = nmg_classify_lu_lu( lu2, lu, tol );
					class2 = nmg_classify_lu_lu( lu1, lu2, tol );

					if( class1 == NMG_CLASS_AinB &&
					    class2 == NMG_CLASS_AinB )
					{
						found = 1;
						break;
					}
				}
				if( !found )
				{
					/* lu1 is a redundant loop */
					(void) nmg_klu( lu1 );
				}
				lu1 = next_lu;
			}
		}
	}

	/* get rid of redundant loops in same fu where there are two identical
	 * loops, but with opposite orientation
	 */
	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		if( fu->orientation != OT_SAME )
			continue;

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct loopuse *lu1;

			if( lu->orientation != OT_SAME )
				continue;

			lu1 = BU_LIST_FIRST( loopuse, &fu->lu_hd );
			while( BU_LIST_NOT_HEAD( &lu1->l, &fu->lu_hd ) )
			{
				int class;
				struct loopuse *next_lu;

				next_lu = BU_LIST_PNEXT( loopuse, &lu1->l );

				if( lu1 == lu || lu1->orientation != OT_OPPOSITE )
				{
					lu1 = next_lu;
					continue;
				}

				class = nmg_classify_lu_lu( lu, lu1, tol );

				if( class == NMG_CLASS_AonBshared )
				{
					nmg_klu( lu1 ); /* lu1 is redudndant */
				}

				lu1 = next_lu;
			}
		}
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_rm_redundancies(s=x%x)\n", s);
	}
}

/*
 *			N M G _ S A N I T I Z E _ S _ L V
 *
 *	Remove those pesky little vertex-only loops of orientation "orient".
 *	Typically these will be OT_BOOLPLACE markers created in the
 *	process of doing intersections for the boolean operations.
 */
void
nmg_sanitize_s_lv(struct shell *s, int orient)
{
	struct faceuse *fu;
	struct loopuse *lu;
	pointp_t pt;

	NMG_CK_SHELL(s);

	/* sanitize the loop lists in the faces of the shell */
	fu = BU_LIST_FIRST(faceuse, &s->fu_hd);
	while (BU_LIST_NOT_HEAD(fu, &s->fu_hd) ) {

		/* all of those vertex-only/orient loops get deleted
		 */
		lu = BU_LIST_FIRST(loopuse, &fu->lu_hd);
		while (BU_LIST_NOT_HEAD(lu, &fu->lu_hd)) {
			if (lu->orientation == orient) {
				lu = BU_LIST_PNEXT(loopuse,lu);
				nmg_klu(BU_LIST_PLAST(loopuse, lu));
			} else if (lu->orientation == OT_UNSPEC &&
			    BU_LIST_FIRST_MAGIC(&lu->down_hd) ==
			    NMG_VERTEXUSE_MAGIC) {
				register struct vertexuse *vu;
				vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
				pt = vu->v_p->vg_p->coord;
				VPRINT("nmg_sanitize_s_lv() OT_UNSPEC at", pt);
				lu = BU_LIST_PNEXT(loopuse,lu);
			} else {
				lu = BU_LIST_PNEXT(loopuse,lu);
			}
		}

		/* step forward, avoiding re-processing our mate (which would
		 * have had it's loops processed with ours)
		 */
		if (BU_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
			fu = BU_LIST_PNEXT_PNEXT(faceuse, fu);
		else
			fu = BU_LIST_PNEXT(faceuse, fu);

		/* If previous faceuse has no more loops, kill it */
		if (BU_LIST_IS_EMPTY( &(BU_LIST_PLAST(faceuse, fu))->lu_hd )) {
			/* All of the loopuses of the previous face were
			 * BOOLPLACE's so the face will now go away
			 */
			nmg_kfu(BU_LIST_PLAST(faceuse, fu));
		}
	}

	/* Sanitize any wire/vertex loops in the shell */
	lu = BU_LIST_FIRST(loopuse, &s->lu_hd);
	while (BU_LIST_NOT_HEAD(lu, &s->lu_hd) ) {
		if (lu->orientation == orient) {
			lu = BU_LIST_PNEXT(loopuse,lu);
			nmg_klu(BU_LIST_PLAST(loopuse, lu));
		} else if (lu->orientation == OT_UNSPEC &&
		    BU_LIST_FIRST_MAGIC(&lu->down_hd) ==
		    NMG_VERTEXUSE_MAGIC) {
			register struct vertexuse *vu;
			vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
			pt = vu->v_p->vg_p->coord;
			VPRINT("nmg_sanitize_s_lv() OT_UNSPEC at", pt);
			lu = BU_LIST_PNEXT(loopuse,lu);
		} else {
			lu = BU_LIST_PNEXT(loopuse,lu);
		}
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_sanitize_s_lv(s=x%x, orient=%d)\n",	s, orient);
	}
}

/*
 *			N M G _ S _ S P L I T _ T O U C H I N G L O O P S
 *
 *  For every loop in a shell, invoke nmg_split_touchingloops() on it.
 *
 *  Needed before starting classification, to separate interior (touching)
 *  loop segments into true interior loops, so each can be processed
 *  separately.
 */
void
nmg_s_split_touchingloops(struct shell *s, const struct bn_tol *tol)
{
	struct faceuse	*fu;
	struct loopuse	*lu;

	NMG_CK_SHELL(s);
	BN_CK_TOL(tol);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_s_split_touching_loops(s=x%x, tol=x%x) START\n", s, tol);
	}

	/* First, handle any splitting */
	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
			(void)nmg_loop_split_at_touching_jaunt( lu, tol );
			nmg_split_touchingloops( lu, tol );
		}
	}
	for( BU_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
		(void)nmg_loop_split_at_touching_jaunt( lu, tol );
		nmg_split_touchingloops( lu, tol );
	}

	/* Second, reorient any split loop fragments */
	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
			if( lu->orientation != OT_UNSPEC )  continue;
			nmg_lu_reorient( lu );
		}
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_s_split_touching_loops(s=x%x, tol=x%x) END\n", s, tol);
	}
}

/*
 *			N M G _ S _ J O I N _ T O U C H I N G L O O P S
 *
 *  For every loop in a shell, invoke nmg_join_touchingloops() on it.
 */
void
nmg_s_join_touchingloops(struct shell *s, const struct bn_tol *tol)
{
	struct faceuse	*fu;
	struct loopuse	*lu;

	NMG_CK_SHELL(s);
	BN_CK_TOL(tol);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_s_join_touching_loops(s=x%x, tol=x%x) START\n", s, tol);
	}

	/* First, handle any joining */
	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
			nmg_join_touchingloops( lu );
		}
	}
	for( BU_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
		nmg_join_touchingloops( lu );
	}

	/* Second, reorient any disoriented loop fragments */
	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
			if( lu->orientation != OT_UNSPEC )  continue;
			nmg_lu_reorient( lu );
		}
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_s_join_touching_loops(s=x%x, tol=x%x) END\n", s, tol);
	}
}

/*
 *			N M G _ J S
 *
 *  Join two shells into one.
 *  This is mostly an up-pointer re-labeling activity, as it is left up to
 *  the caller to ensure that there are no non-explicit intersections.
 *
 *  Upon return, s2 will no longer exist.
 *
 *  The 'tol' arg is used strictly for printing purposes.
 */
void
nmg_js(register struct shell *s1, register struct shell *s2, const struct bn_tol *tol)
                     	    		/* destination */
                     	    		/* source */
                   	     
{
	struct faceuse	*fu2;
	struct faceuse	*nextfu;
	struct loopuse	*lu;
	struct loopuse	*nextlu;
	struct edgeuse	*eu;
	struct edgeuse	*nexteu;
	struct vertexuse *vu;

	NMG_CK_SHELL(s1);
	NMG_CK_SHELL(s2);
	BN_CK_TOL(tol);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_js(s1=x%x, s2=x%x) START\n", s1, s2);
	}

	if( rt_g.NMG_debug & DEBUG_VERIFY )
		nmg_vshell( &s1->r_p->s_hd, s1->r_p );

	/*
	 *  For each face in the shell, process all the loops in the face,
	 *  and then handle the face and all loops as a unit.
	 */
	fu2 = BU_LIST_FIRST( faceuse, &s2->fu_hd );
	while( BU_LIST_NOT_HEAD( fu2, &s2->fu_hd ) )  {
		struct faceuse	*fu1;

		nextfu = BU_LIST_PNEXT( faceuse, fu2 );

		/* Faceuse mates will be handled at same time as OT_SAME fu */
		if( fu2->orientation != OT_SAME )  {
			fu2 = nextfu;
			continue;
		}

		/* Consider this face */
		NMG_CK_FACEUSE(fu2);
		NMG_CK_FACE(fu2->f_p);

		if( nextfu == fu2->fumate_p )
			nextfu = BU_LIST_PNEXT(faceuse, nextfu);

		/* If there is a face in the destination shell that
		 * shares face geometry with this face, then
		 * move all the loops into the other face,
		 * and eliminate this redundant face.
		 */
		fu1 = nmg_find_fu_with_fg_in_s( s1, fu2 );
		if( fu1 && fu1->orientation == OT_SAME )  {
			if (rt_g.NMG_debug & DEBUG_BASIC)
				bu_log("nmg_js(): shared face_g_plane, doing nmg_jf()\n");
			nmg_jf( fu1, fu2 );
			/* fu2 pointer is invalid here */
			fu2 = fu1;
		} else {
			nmg_mv_fu_between_shells( s1, s2, fu2 );
		}

		fu2 = nextfu;
	}
#if 0
	if( rt_g.NMG_debug & DEBUG_VERIFY )
		nmg_vshell( &s1->r_p->s_hd, s1->r_p );
#endif

	/*
	 *  For each loop in the shell, process.
	 *  Each loop is either a wire-loop, or a vertex-with-self-loop.
	 *  Both get the same treatment.
	 */
	lu = BU_LIST_FIRST( loopuse, &s2->lu_hd );
	while( BU_LIST_NOT_HEAD( lu, &s2->lu_hd ) )  {
		nextlu = BU_LIST_PNEXT( loopuse, lu );

		NMG_CK_LOOPUSE(lu);
		NMG_CK_LOOP( lu->l_p );
		if( nextlu == lu->lumate_p )
			nextlu = BU_LIST_PNEXT(loopuse, nextlu);

		nmg_mv_lu_between_shells( s1, s2, lu );
		lu = nextlu;
	}
#if 0
	if( rt_g.NMG_debug & DEBUG_VERIFY )
		nmg_vshell( &s1->r_p->s_hd, s1->r_p );
#endif

	/*
	 *  For each wire-edge in the shell, ...
	 */
	eu = BU_LIST_FIRST( edgeuse, &s2->eu_hd );
	while( BU_LIST_NOT_HEAD( eu, &s2->eu_hd ) )  {
		nexteu = BU_LIST_PNEXT( edgeuse, eu );

		/* Consider this edge */
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGE( eu->e_p );
		if( nexteu == eu->eumate_p )
			nexteu = BU_LIST_PNEXT(edgeuse, nexteu);
		nmg_mv_eu_between_shells( s1, s2, eu );
		eu = nexteu;
	}
#if 0
	if( rt_g.NMG_debug & DEBUG_VERIFY )
		nmg_vshell( &s1->r_p->s_hd, s1->r_p );
#endif

	/*
	 * Final case:  shell of a single vertexuse
	 */
	if( (vu = s2->vu_p) )  {
		NMG_CK_VERTEXUSE( vu );
		NMG_CK_VERTEX( vu->v_p );
		nmg_mv_vu_between_shells( s1, s2, vu );
		s2->vu_p = (struct vertexuse *)0;	/* sanity */
	}

	if( BU_LIST_NON_EMPTY( &s2->fu_hd ) )  {
		rt_bomb("nmg_js():  s2 still has faces!\n");
	}
	if( BU_LIST_NON_EMPTY( &s2->lu_hd ) )  {
		rt_bomb("nmg_js():  s2 still has wire loops!\n");
	}
	if( BU_LIST_NON_EMPTY( &s2->eu_hd ) )  {
		rt_bomb("nmg_js():  s2 still has wire edges!\n");
	}
	if(s2->vu_p) {
		rt_bomb("nmg_js():  s2 still has verts!\n");
	}

	/* s2 is completely empty now, which is an invalid condition */
	nmg_ks( s2 );

	/* Some edges may need faceuse parity touched up. */
	nmg_s_radial_harmonize( s1, tol );

	if( rt_g.NMG_debug & DEBUG_VERIFY )
		nmg_vshell( &s1->r_p->s_hd, s1->r_p );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_js(s1=x%x, s2=x%x) END\n", s1, s2);
	}
}

/*
 *			N M G _ I N V E R T _ S H E L L
 *
 *  Reverse the surface normals, and invert the orientation state of
 *  all faceuses in a shell.
 * 
 *  This turns the shell "inside out", such as might be needed for the
 *  right hand side term of a subtraction operation.
 *
 *  While this function is operating, the parity of faceuses radially
 *  around edgeuses is disrupted, hence this atomic interface to
 *  invert the shell.
 *
 *  The 'tol' argument is used strictly for printing.
 */
void
nmg_invert_shell(struct shell *s, const struct bn_tol *tol)
{
	struct model	*m;
	struct faceuse	*fu;
	char		*tags;

	NMG_CK_SHELL(s);
	m = s->r_p->m_p;
	NMG_CK_MODEL(m);
	BN_CK_TOL(tol);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_invert_shell(x%x)\n", s);
	}

	/* Allocate map of faces visited */
	tags = bu_calloc( m->maxindex+1, 1, "nmg_invert_shell() tags[]" );

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
		/* By tagging on faces, marks fu and fumate together */
		if( NMG_INDEX_TEST( tags, fu->f_p ) )  continue;
		NMG_INDEX_SET( tags, fu->f_p );
		/* Process fu and fumate together */
		nmg_reverse_face(fu);
	}
	bu_free( tags, "nmg_invert_shell() tags[]" );
}

/************************************************************************
 *									*
 *				FACE Routines				*
 *									*
 ************************************************************************/

/*
 *			N M G _ C M F A C E
 *
 *	Create a face with exactly one exterior loop (and no holes),
 *	given an array of pointers to struct vertex pointers.
 *	Intended to help create a "3-manifold" shell, where
 *	each edge has only two faces alongside of it.
 *	(Shades of winged edges!)
 *
 *	"verts" is an array of "n" pointers to pointers to (struct vertex).
 *	"s" is the parent shell for the new face.
 *
 *	The new face will consist of a single loop
 *	made from n edges between the n vertices.  Before an edge is created
 *	between a pair of verticies, we check to see if there is already an
 *	edge with exactly one edgeuse+mate (in this shell)
 *	that runs between the two verticies.
 *	If such an edge can be found, the newly created edgeuses will just
 *	use the existing edge.
 *	This means that no special call to nmg_gluefaces() is needed later.
 *
 *	If a pointer in verts is a pointer to a null vertex pointer, a new
 *	vertex is created.  In this way, new verticies can be created
 *	conveniently within a user's list of known verticies
 *
 *	verts		pointers to struct vertex	    vertex structs
 *
 *	-------		--------
 *   0	|  +--|-------->|   +--|--------------------------> (struct vertex)
 *	-------		--------	---------
 *   1	|  +--|------------------------>|   +---|---------> (struct vertex)
 *	-------		--------	---------
 *   2	|  +--|-------->|   +--|--------------------------> (struct vertex)
 *	-------		--------
 *  ...
 *	-------				---------
 *   n	|  +--|------------------------>|   +---|---------> (struct vertex)
 *	-------				---------
 *
 *
 *	The vertices *must* be listed in "counter-clockwise" (CCW) order.
 *	This routine makes only topology, without reference to any geometry.
 *
 *	Note that this routine inserts new vertices (by edge use splitting)
 *	at the head of the loop, which reverses the order.
 *	Therefore, the caller's vertices are traversed in reverse order
 *	to counter this behavior, and
 *	to effect the proper vertex order in the final face loop.
 *
 *	Also note that this routine uses one level more of indirection
 *	in the verts[] array than nmg_cface().
 *
 *  Recent improvement: the lu's list of eu's traverses the
 *  verts[] array in order specified by the caller.  Imagine that.
 */
struct faceuse *
nmg_cmface(struct shell *s, struct vertex ***verts, int n)
{
	struct faceuse *fu;
	struct edgeuse *eu, *eur, *euold = NULL;
	struct loopuse	*lu;
	struct vertexuse	*vu;
	int i;

	NMG_CK_SHELL(s);

	if (n < 1) {
		bu_log("nmg_cmface(s=x%x, verts=x%x, n=%d.)\n",
			s, verts, n );
		rt_bomb("nmg_cmface() trying to make bogus face\n");
	}

	/* make sure verts points to some real storage */
	if (!verts) {
		bu_log("nmg_cmface(s=x%x, verts=x%x, n=%d.) null pointer to array start\n",
			s, verts, n );
		rt_bomb("nmg_cmface\n");
	}

	/* validate each of the pointers in verts */
	for (i=0 ; i < n ; ++i) {
		if (verts[i]) {
			if (*verts[i]) {
				/* validate the vertex pointer */
				NMG_CK_VERTEX(*verts[i]);
			}
		} else {
			bu_log("nmg_cmface(s=x%x, verts=x%x, n=%d.) verts[%d]=NULL\n",
				s, verts, n, i );
			rt_bomb("nmg_cmface\n");
		}
	}

	lu = nmg_mlv(&s->l.magic, *verts[0], OT_SAME);
	fu = nmg_mf(lu);
	fu->orientation = OT_SAME;
	fu->fumate_p->orientation = OT_OPPOSITE;
	vu = BU_LIST_FIRST( vertexuse, &lu->down_hd);
	NMG_CK_VERTEXUSE(vu);
	eu = nmg_meonvu(vu);
	NMG_CK_EDGEUSE(eu);

	if (!(*verts[0]))  {
		NMG_CK_VERTEXUSE(eu->vu_p);
		NMG_CK_VERTEX(eu->vu_p->v_p);
		*verts[0] = eu->vu_p->v_p;
	}

	for (i = n-1 ; i > 0 ; i--) {
		/* Get the edgeuse most recently created */
		euold = BU_LIST_FIRST( edgeuse, &lu->down_hd );
		NMG_CK_EDGEUSE(euold);

		if (rt_g.NMG_debug & DEBUG_CMFACE)
			bu_log("nmg_cmface() euold: %8x\n", euold);

		/* look for pre-existing edge between these
		 * verticies
		 */
		if (*verts[i]) {
			/* look for an existing edge to share */
			eur = nmg_findeu(*verts[(i+1)%n], *verts[i], s, euold, 1);
			eu = nmg_eusplit(*verts[i], euold, 0);
			if (eur) {
				nmg_je(eur, eu);

				if (rt_g.NMG_debug & DEBUG_CMFACE)
					bu_log("nmg_cmface() found another edgeuse (%8x) between %8x and %8x\n",
						eur, *verts[(i+1)%n], *verts[i]);
			} else {
				if (rt_g.NMG_debug & DEBUG_CMFACE)
				    bu_log("nmg_cmface() didn't find edge from verts[%d]%8x to verts[%d]%8x\n",
					i+1, *verts[(i+1)%n], i, *verts[i]);
			}
		} else {
			eu = nmg_eusplit(*verts[i], euold, 0);
			*verts[i] = eu->vu_p->v_p;

			if (rt_g.NMG_debug & DEBUG_CMFACE)  {
				bu_log("nmg_cmface() *verts[%d] was null, is now %8x\n",
					i, *verts[i]);
			}
		}
	}

	if( n > 1 )  {
		if ((eur = nmg_findeu(*verts[0], *verts[1], s, euold, 1)))  {
			nmg_je(eur, euold);
		} else  {
		    if (rt_g.NMG_debug & DEBUG_CMFACE)
			bu_log("nmg_cmface() didn't find edge from verts[%d]%8x to verts[%d]%8x\n",
				0, *verts[0], 1, *verts[1]);
		}
	}

	if(rt_g.NMG_debug & DEBUG_BASIC)  {
		/* Sanity check */
		euold = BU_LIST_FIRST( edgeuse, &lu->down_hd );
		NMG_CK_EDGEUSE(euold);
		if( euold->vu_p->v_p != *verts[0] )  {
			bu_log("ERROR nmg_cmface() lu first vert s/b x%x, was x%x\n",
				*verts[0], euold->vu_p->v_p );
			for( i=0; i < n; i++ )  {
				bu_log("  *verts[%2d]=x%x, eu->vu_p->v_p=x%x\n",
					i, *verts[i], euold->vu_p->v_p);
				euold = BU_LIST_PNEXT_CIRC( edgeuse, &euold->l );
			}
			rt_bomb("nmg_cmface() bogus eu ordering\n");
		}
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_cmface(s=x%x, verts[]=x%x, n=%d) fu=x%x\n",
			s, verts, n, fu);
	}
	return (fu);
}

/*
 *			N M G _ C F A C E
 *
 *	Create a loop within a face, given a list of vertices.
 *
 *	"verts" is an array of "n" pointers to (struct vertex).  "s" is the
 *	parent shell for the new face.  The face will consist of a single loop
 *	made from edges between the n vertices.
 *
 *	If verts is a null pointer (no vertex list), all vertices of the face
 *	will be new points.  Otherwise, verts is a pointer to a list of
 *	vertices to use in creating the face/loop.  Null entries within the
 *	list will cause a new vertex to be created for that point.  Such new
 *	vertices will be inserted into the list for return to the caller.
 *
 *	The vertices should be listed in
 *	"counter-clockwise" (CCW) order if this is an ordinary face (loop),
 *	and in "clockwise" (CW) order if this is an interior
 * 	("hole" or "subtracted") face (loop).
 *	This routine makes only topology, without reference to any geometry.
 *
 *	Note that this routine inserts new vertices (by edge use splitting)
 *	at the head of the loop, which reverses the order.
 *	Therefore, the caller's vertices are traversed in reverse order
 *	to counter this behavior, and
 *	to effect the proper vertex order in the final face loop.
 */
struct faceuse *
nmg_cface(struct shell *s, struct vertex **verts, int n)
{
	struct faceuse *fu;
	struct edgeuse *eu;
	struct loopuse	*lu;
	struct vertexuse *vu;
	int i;

	NMG_CK_SHELL(s);
	if (n < 1) {
		bu_log("nmg_cface(s=x%x, verts=x%x, n=%d.)\n",
			s, verts, n );
		rt_bomb("nmg_cface() trying to make bogus face\n");
	}

	if (verts) {
		for (i=0 ; i < n ; ++i) {
			if (verts[i]) {
				NMG_CK_VERTEX(verts[i]);
			}
		}
		lu = nmg_mlv(&s->l.magic, verts[n-1], OT_SAME);
		fu = nmg_mf(lu);
		vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
		eu = nmg_meonvu(vu);

		if (!verts[n-1])
			verts[n-1] = eu->vu_p->v_p;

		for (i = n-2 ; i >= 0 ; i--) {
			eu = BU_LIST_FIRST(edgeuse, &lu->down_hd);
			eu = nmg_eusplit(verts[i], eu, 0);
			if (!verts[i])
				verts[i] = eu->vu_p->v_p;
		}

	} else {
		lu = nmg_mlv(&s->l.magic, (struct vertex *)NULL, OT_SAME);
		fu = nmg_mf(lu);
		vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
		eu = nmg_meonvu(vu);
		while (--n) {
			(void)nmg_eusplit((struct vertex *)NULL, eu, 0);
		}
	}
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_cface(s=x%x, verts[]=x%x, n=%d) fu=x%x\n",
			s, verts, n, fu);
	}
	return (fu);
}

/*
 *			N M G _ A D D _ L O O P _ T O _ F A C E
 *
 *	Create a new loop within a face, given a list of vertices.
 *	Modified version of nmg_cface().
 *
 *	"verts" is an array of "n" pointers to (struct vertex).  "s" is the
 *	parent shell for the new face.  The face will consist of a single loop
 *	made from edges between the n vertices.
 *
 *	If verts is a null pointer (no vertex list), all vertices of the face
 *	will be new points.  Otherwise, verts is a pointer to a list of
 *	vertices to use in creating the face/loop.  Null entries within the
 *	list will cause a new vertex to be created for that point.  Such new
 *	vertices will be inserted into the list for return to the caller.
 *
 *	The vertices should be listed in "counter-clockwise" (CCW) order if
 *	this is an ordinary face (loop), and in "clockwise" (CW) order if
 *	this is an interior ("hole" or "subtracted") face (loop).  This
 *	routine makes only topology, without reference to any geometry.
 *
 *	Note that this routine inserts new vertices (by edge use splitting)
 *	at the head of the loop, which reverses the order.  Therefore, the
 *	caller's vertices are traversed in reverse order to counter this
 *	behavior, and to effect the proper vertex order in the final face
 *	loop.
 */
struct faceuse *
nmg_add_loop_to_face(struct shell *s, struct faceuse *fu, struct vertex **verts, int n, int dir)
{
	int i;
	struct edgeuse *eu;
	struct loopuse *lu;
	struct vertexuse *vu;

	NMG_CK_SHELL(s);
	if (n < 1) {
		bu_log("nmg_add_loop_to_face(s=x%x, verts=x%x, n=%d.)\n",
			s, verts, n );
		rt_bomb("nmg_add_loop_to_face: request to make 0 faces\n");
	}

	if (verts) {
		if (!fu) {
			lu = nmg_mlv(&s->l.magic, verts[n-1], dir);
			fu = nmg_mf(lu);
		} else {
			lu = nmg_mlv(&fu->l.magic, verts[n-1], dir);
		}
		vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
		eu = nmg_meonvu(vu);
		if (!verts[n-1])
			verts[n-1] = eu->vu_p->v_p;

		for (i = n-2 ; i >= 0 ; i--) {
			eu = BU_LIST_FIRST(edgeuse, &lu->down_hd);
			eu = nmg_eusplit(verts[i], eu, 0);
			if (!verts[i])
				verts[i] = eu->vu_p->v_p;
		}
	} else {
		if (!fu) {
			lu = nmg_mlv(&s->l.magic, (struct vertex *)NULL, dir);
			fu = nmg_mf(lu);
		} else {
			lu = nmg_mlv(&fu->l.magic, (struct vertex *)NULL, dir);
		}
		vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
		eu = nmg_meonvu(vu);
		while (--n) {
			(void)nmg_eusplit((struct vertex *)NULL, eu, 0);
		}
	}
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_add_loop_to_face(s=x%x, fu=x%x, verts[]=x%x, n=%d, %s) fu=x%x\n",
			s, fu, verts, n,
			nmg_orientation(dir) );
	}
	return (fu);
}

/*
 *			N M G _ F U _ P L A N E E Q N
 *
 *  Given a convex face that has been constructed with edges listed in
 *  counter-clockwise (CCW) order, compute the surface normal and plane
 *  equation for this face.
 *
 *
 *			D                   C
 *	                *-------------------*
 *	                |                   |
 *	                |   .<...........   |
 *	   ^     N      |   .           ^   |     ^
 *	   |      \     |   .  counter- .   |     |
 *	   |       \    |   .   clock   .   |     |
 *	   |C-B     \   |   .   wise    .   |     |C-B
 *	   |         \  |   v           .   |     |
 *	   |          \ |   ...........>.   |     |
 *	               \|                   |
 *	                *-------------------*
 *	                A                   B
 *			      <-----
 *				A-B
 *
 *  If the vertices in the loop are given in the order A B C D
 *  (e.g., counter-clockwise),
 *  then the outward pointing surface normal can be computed as:
 *
 *		N = (C-B) x (A-B)
 *
 *  This is the "right hand rule".
 *  For reference, note that a vector which points "into" the loop
 *  can be subsequently found by taking the cross product of the
 *  surface normal and any edge vector, e.g.:
 *
 *		Left = N x (B-A)
 *	or	Left = N x (C-B)
 *
 *  This routine will skip on past edges that start and end on
 *  the same vertex, in an attempt to avoid trouble.
 *  However, the loop *must* be convex for this routine to work.
 *  Otherwise, the surface normal may be inadvertently reversed.
 *
 *  Returns -
 *	0	OK
 *	-1	failure
 */
int
nmg_fu_planeeqn(struct faceuse *fu, const struct bn_tol *tol)
{
	struct edgeuse		*eu, *eu_final, *eu_next;
	struct loopuse		*lu;
	plane_t			plane;
	struct vertex		*a, *b, *c;
	register int		both_equal;

	BN_CK_TOL(tol);

	NMG_CK_FACEUSE(fu);
	lu = BU_LIST_FIRST(loopuse, &fu->lu_hd);
	NMG_CK_LOOPUSE(lu);

	if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
	{
		bu_log( "nmg_fu_planeeqn(): First loopuse does not contain edges\n" );
		return(-1);
	}
	eu = BU_LIST_FIRST(edgeuse, &lu->down_hd);
	NMG_CK_EDGEUSE(eu);
	NMG_CK_VERTEXUSE(eu->vu_p);
	a = eu->vu_p->v_p;
	NMG_CK_VERTEX(a);
	NMG_CK_VERTEX_G(a->vg_p);

	eu_next = eu;
	do {
		eu_next = BU_LIST_PNEXT_CIRC(edgeuse, eu_next);
		NMG_CK_EDGEUSE(eu_next);
		if( eu_next == eu )
		{
			bu_log( "nmg_fu_planeeqn(): First loopuse contains only one edgeuse\n" );
			return -1;
		}
		NMG_CK_VERTEXUSE(eu_next->vu_p);
		b = eu_next->vu_p->v_p;
		NMG_CK_VERTEX(b);
		NMG_CK_VERTEX_G(b->vg_p);
	} while( (b == a
		|| bn_pt3_pt3_equal(a->vg_p->coord, b->vg_p->coord, tol))
		&& eu_next->vu_p != eu->vu_p );

	eu_final = eu_next;
	do {
		eu_final = BU_LIST_PNEXT_CIRC(edgeuse, eu_final);
		NMG_CK_EDGEUSE(eu_final);
		if( eu_final == eu )
		{
			bu_log( "nmg_fu_planeeqn(): Cannot find three distinct vertices\n" );
			return -1;
		}
		NMG_CK_VERTEXUSE(eu_final->vu_p);
		c = eu_final->vu_p->v_p;
		NMG_CK_VERTEX(c);
		NMG_CK_VERTEX_G(c->vg_p);
		both_equal = (c == b) ||
		    bn_pt3_pt3_equal(a->vg_p->coord, c->vg_p->coord, tol) ||
		    bn_pt3_pt3_equal(b->vg_p->coord, c->vg_p->coord, tol);
	} while( (both_equal
		|| bn_3pts_collinear(a->vg_p->coord, b->vg_p->coord,
			c->vg_p->coord, tol))
		&& eu_next->vu_p != eu->vu_p );

	if (bn_mk_plane_3pts(plane,
	    a->vg_p->coord, b->vg_p->coord, c->vg_p->coord, tol) < 0 ) {
		bu_log("nmg_fu_planeeqn(): bn_mk_plane_3pts failed on (%g,%g,%g) (%g,%g,%g) (%g,%g,%g)\n",
			V3ARGS( a->vg_p->coord ),
			V3ARGS( b->vg_p->coord ),
			V3ARGS( c->vg_p->coord ) );
	    	HPRINT("plane", plane);
		return(-1);
	}
	if (plane[0] == 0.0 && plane[1] == 0.0 && plane[2] == 0.0) {
		bu_log("nmg_fu_planeeqn():  Bad plane equation from bn_mk_plane_3pts\n" );
	    	HPRINT("plane", plane);
		return(-1);
	}
	nmg_face_g( fu, plane);

	/* Check and make sure all verts are within tol->dist of face */
	if( nmg_ck_fu_verts( fu, fu->f_p, tol ) != 0 )  {
		bu_log("nmg_fu_planeeqn(fu=x%x) ERROR, verts are not within tol of face\n" , fu );
		return -1;
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_fu_planeeqn(fu=x%x, tol=x%x)\n", fu, tol);
	}
	return(0);
}

/*
 *			N M G _ G L U E F A C E S
 *
 *	given a shell containing "n" faces whose outward oriented faceuses are
 *	enumerated in "fulist", glue the edges of the faces together
 *	Most especially useful after using nmg_cface() several times to
 *	make faces which share vertex structures.
 *
 */
void
nmg_gluefaces(struct faceuse **fulist, int n, const struct bn_tol *tol)
{
	struct shell	*s;
	struct loopuse	*lu;
	struct edgeuse	*eu;
	int		i;
	int		f_no;		/* Face number */
	
	NMG_CK_FACEUSE(fulist[0]);
	s = fulist[0]->s_p;
	NMG_CK_SHELL(s);

	/* First, perform some checks */
	for (i = 0 ; i < n ; ++i) {
		register struct faceuse	*fu;

		fu = fulist[i];
		NMG_CK_FACEUSE(fu);
		if (fu->s_p != s) {
			bu_log("nmg_gluefaces() in %s at %d. faceuses don't share parent\n",
				__FILE__, __LINE__);
			rt_bomb("nmg_gluefaces\n");
		}
	}

	for (i=0 ; i < n ; ++i) {
		for( BU_LIST_FOR( lu , loopuse , &fulist[i]->lu_hd ) ) {
			NMG_CK_LOOPUSE( lu );

			if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
				for( f_no = i+1; f_no < n; f_no++ )  {
					struct loopuse		*lu2;
					register struct edgeuse	*eu2;

					for( BU_LIST_FOR( lu2 , loopuse , &fulist[f_no]->lu_hd ) ) {
						NMG_CK_LOOPUSE( lu2 );
						if( BU_LIST_FIRST_MAGIC(&lu2->down_hd) != NMG_EDGEUSE_MAGIC )
							continue;
						for( BU_LIST_FOR( eu2, edgeuse, &lu2->down_hd ) )  {
							if (EDGESADJ(eu, eu2))
								nmg_radial_join_eu(eu, eu2, tol);
						}
					}
				}
			}
		}
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_gluefaces(fulist=x%x, n=%d)\n", fulist, n);
	}
}


/*			N M G _ S I M P L I F Y _ F A C E
 *
 *
 *	combine adjacent loops within a face which serve no apparent purpose
 *	by remaining separate and distinct.  Kill "wire-snakes" in face.
 *
 * Returns -
 *	0	If all was OK
 *	1	If faceuse is now empty
 */
int
nmg_simplify_face(struct faceuse *fu)
{
	struct loopuse *lu;
	int ret_val;

	NMG_CK_FACEUSE(fu);

	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))  {
		nmg_simplify_loop(lu);
	}

	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))  {
		if( nmg_kill_snakes(lu) )  {
			struct loopuse	*klu = lu;
			lu = BU_LIST_PREV( loopuse, &lu->l );
			nmg_klu(klu);
		}
	}

	ret_val = BU_LIST_IS_EMPTY(&fu->lu_hd);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_simplify_face(fut=x%x) return=%d\n", fu, ret_val);
	}

	return( ret_val );
}

/*
 *			N M G _ R E V E R S E _ F A C E
 *
 *
 *  This routine reverses the direction of the Normal vector which defines
 *  the plane of the face.  
 *
 *  The OT_SAME faceuse becomes the OT_OPPOSITE faceuse, and vice versa.  
 *  This preserves the convention that OT_SAME loopuses in the
 *  OT_SAME faceuse are counter-clockwise rotating about the surface normal.
 *
 *
 *	     Before			After
 *
 * 
 * N	  OT_SAME		  OT_OPPOSITE
 *  \	.<---------.		.<---------.
 *   \	|fu        ^		|fu        ^
 *    \	|  .------ | ->.	|  .------ | ->.
 *     \|  ^fumate |   |	|  ^fumate |   |
 *	|  |       |   |	|  |       |   |
 *	|  |       |   |	|  |       |   |
 *	V  |       |   |	V  |       |   |\
 *	.--------->.   |	.--------->.   | \
 *	   |           V	   |           V  \
 *	   .<----------.	   .<----------.   \
 *	    OT_OPPOSITE		     OT_SAME        \
 *						     N
 *
 *
 *  Also note that this reverses the same:opposite:opposite:same
 *  parity radially around each edge.  This can create parity errors
 *  until all faces of this shell have been processed.
 *
 *  Applications programmers should use nmg_invert_shell(),
 *  which does not have this problem.
 *  This routine is for internal use only.
 */
void
nmg_reverse_face(register struct faceuse *fu)
{
	register struct faceuse	*fumate;

	NMG_CK_FACEUSE(fu);
	fumate = fu->fumate_p;
	NMG_CK_FACEUSE(fumate);
	NMG_CK_FACE(fu->f_p);
	NMG_CK_FACE_G_EITHER(fu->f_p->g.magic_p);

	/* reverse face normal vector */
	fu->f_p->flip = !fu->f_p->flip;

	/* switch which face is "outside" face */
	if (fu->orientation == OT_SAME)  {
		if (fumate->orientation != OT_OPPOSITE)  {
			bu_log("nmg_reverse_face(fu=x%x) fu:SAME, fumate:%d\n",
				fu, fumate->orientation);
			rt_bomb("nmg_reverse_face() orientation clash\n");
		} else {
			fu->orientation = OT_OPPOSITE;
			fumate->orientation = OT_SAME;
		}
	} else if (fu->orientation == OT_OPPOSITE) {
		if (fumate->orientation != OT_SAME)  {
			bu_log("nmg_reverse_face(fu=x%x) fu:OPPOSITE, fumate:%d\n",
				fu, fumate->orientation);
			rt_bomb("nmg_reverse_face() orientation clash\n");
		} else {
			fu->orientation = OT_SAME;
			fumate->orientation = OT_OPPOSITE;
		}
	} else {
		/* Unoriented face? */
		bu_log("ERROR nmg_reverse_face(fu=x%x), orientation=%d.\n",
			fu, fu->orientation );
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_reverse_face(fu=x%x) fumate=x%x\n", fu, fumate);
	}
}

#if 0
/*
 * XXX Called in nmg_misc.c / nmg_reverse_face_and_radials()
 *			N M G _ F A C E _ F I X _ R A D I A L _ P A R I T Y
 *
 *  Around an edge, consider all the edgeuses that belong to a single shell.
 *  The faceuses pertaining to those edgeuses must maintain the appropriate
 *  parity with their radial faceuses, so that OT_SAME is always radial to
 *  OT_SAME, and OT_OPPOSITE is always radial to OT_OPPOSITE.
 *
 *  If a radial edgeuse is encountered that belongs to *this* face, then
 *  it might not have been processed by this routine yet, and is ignored
 *  for the purposes of checking parity.
 *
 *  When moving faces between shells, sometimes this parity relationship
 *  needs to be fixed, which can be easily accomplished by exchanging
 *  the incorrect edgeuse with it's mate in the radial edge linkages.
 *
 *  XXX Note that this routine will not work right in the presence of
 *  XXX dangling faces.
 *
 *  Note that this routine can't be used incrementally, because
 *  after an odd number (like one) of faceuses have been "fixed",
 *  there is an inherrent parity error, which will cause wrong
 *  decisions to be made.  Therefore, *all* faces have to be moved from
 *  one shell to another before the radial parity can be "fixed".
 *  Even then, this isn't going to work right unless we are given
 *  a list of all the "suspect" faceuses, so the initial parity
 *  value can be properly established.
 *
 *  XXXX I am of the opinion this routine is neither useful nor correct
 *  XXXX in it's present form, except for limited special cases.
 *
 *  The 'tol' arg is used strictly for printing purposes.
 *
 *  Returns -
 *	count of number of edges fixed.
 */
int
nmg_face_fix_radial_parity( fu, tol )
struct faceuse		*fu;
const struct bn_tol	*tol;
{
	struct loopuse *lu;
	struct edgeuse *eu;
	struct faceuse *fu2;
	struct shell	*s;
	long		count = 0;

	NMG_CK_FACEUSE( fu );
	s = fu->s_p;
	NMG_CK_SHELL(s);
	BN_CK_TOL(tol);

	/* Make sure we are now dealing with the OT_SAME faceuse */
	if( fu->orientation == OT_SAME )
		fu2 = fu;
	else
		fu2 = fu->fumate_p;

	for( BU_LIST_FOR( lu , loopuse , &fu2->lu_hd ) )  {
		NMG_CK_LOOPUSE( lu );

		/* skip loops of a single vertex */
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		/*
		 *  Consider every edge of this loop.
		 *  Initial sequencing is:
		 *    before(radial), eu, eumate, after(radial)
		 */
		for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )  {
			struct edgeuse	*eumate;
			struct edgeuse	*before;
			struct edgeuse	*sbefore;	/* searched before */
			struct edgeuse	*after;

			eumate = eu->eumate_p;
			before = eu->radial_p;
			after = eumate->radial_p;
			NMG_CK_EDGEUSE(eumate);
			NMG_CK_EDGEUSE(before);
			NMG_CK_EDGEUSE(after);

			/* If no other edgeuses around edge, done. */
			if( before == eumate )
				continue;

			/*
			 *  Search in 'before' direction, until it's in
			 *  same shell.  Also ignore edgeuses from this FACE,
			 *  as they may not have been fixed yet.
			 */
			for( sbefore = before;
			     sbefore != eu && sbefore != eumate;
			     sbefore = sbefore->eumate_p->radial_p
			)  {
				struct faceuse	*bfu;
				if( nmg_find_s_of_eu(sbefore) != s )  continue;

				bfu = nmg_find_fu_of_eu(sbefore);
				/* If edgeuse isn't part of a faceuse, skip */
				if( !bfu )  continue;
				if( bfu->f_p == fu->f_p )  continue;
				/* Found a candidate */
				break;
			}

			/* If search found no others from this shell, done. */
			if( sbefore == eu || sbefore == eumate )
				continue;

			/*
			 *  'eu' is in an OT_SAME faceuse.
			 *  If the first faceuse in the 'before' direction
			 *  from this shell is OT_SAME, no fix is required.
			 */
			if( sbefore->up.lu_p->up.fu_p->orientation == OT_SAME )
				continue;

#if 0
bu_log("sbefore eu=x%x, before=x%x, eu=x%x, eumate=x%x, after=x%x\n",
			sbefore, before, eu, eumate, after );
nmg_pr_fu_around_eu(eu, tol );
#endif
			/*
			 *  Rearrange order to be: before, eumate, eu, after.
			 *  NOTE: do NOT use sbefore here.
			 */
			before->radial_p = eumate;
			eumate->radial_p = before;

			after->radial_p = eu;
			eu->radial_p = after;
			count++;
			if( rt_g.NMG_debug & DEBUG_BASIC )  {
				bu_log("nmg_face_fix_radial_parity() exchanging eu=x%x & eumate=x%x on edge x%x\n",
					eu, eumate, eu->e_p);
			}
#if 0
			/* Can't do this incrementally, it blows up after 1st "fix" */
			if( rt_g.NMG_debug )  {
nmg_pr_fu_around_eu(eu, tol );
				if( nmg_check_radial( eu, tol ) )
					rt_bomb("nmg_face_fix_radial_parity(): nmg_check_radial failed\n");
			}
#endif
		}
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_face_fix_radial_parity(fu=x%x) returns %d\n", fu, count);
	}

	return count;
}
#endif

/*
 *			N M G _ M V _ F U _ B E T W E E N _ S H E L L S
 *
 *  Move faceuse from 'src' shell to 'dest' shell.
 */
void
nmg_mv_fu_between_shells(struct shell *dest, register struct shell *src, register struct faceuse *fu)
{
	register struct faceuse	*fumate;

	NMG_CK_FACEUSE(fu);
	fumate = fu->fumate_p;
	NMG_CK_FACEUSE(fumate);

	if (fu->s_p != src) {
		bu_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fu->s_p=x%x isnt src shell\n",
			dest, src, fu, fu->s_p );
		rt_bomb("fu->s_p isnt source shell\n");
	}
	if (fumate->s_p != src) {
		bu_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fumate->s_p=x%x isn't src shell\n",
			dest, src, fu, fumate->s_p );
		rt_bomb("fumate->s_p isnt source shell\n");
	}

	/* Remove fu from src shell */
	BU_LIST_DEQUEUE( &fu->l );
	if( BU_LIST_IS_EMPTY( &src->fu_hd ) )  {
		/* This was the last fu in the list, bad news */
		bu_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fumate=x%x not in src shell\n",
			dest, src, fu, fumate );
		rt_bomb("src shell emptied before finding fumate\n");
	}

	/* Remove fumate from src shell */
	BU_LIST_DEQUEUE( &fumate->l );

	/*
	 * Add fu and fumate to dest shell,
	 * preserving implicit OT_SAME, OT_OPPOSITE order
	 */
	if( fu->orientation == OT_SAME )  {
		BU_LIST_APPEND( &dest->fu_hd, &fu->l );
		BU_LIST_APPEND( &fu->l, &fumate->l );
	} else {
		BU_LIST_APPEND( &dest->fu_hd, &fumate->l );
		BU_LIST_APPEND( &fumate->l, &fu->l );
	}

	fu->s_p = dest;
	fumate->s_p = dest;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x)\n", dest , src , fu);
	}
}

/*
 *			N M G _ M O V E _ F U _ F U
 *
 *  Move everything from the source faceuse into the destination faceuse.
 *  Exists as a support routine for nmg_jf() only.
 */
static void
nmg_move_fu_fu(register struct faceuse *dest_fu, register struct faceuse *src_fu)
{
	register struct loopuse	*lu;

	NMG_CK_FACEUSE(dest_fu);
	NMG_CK_FACEUSE(src_fu);

	if( dest_fu->orientation != src_fu->orientation )
		rt_bomb("nmg_move_fu_fu: differing orientations\n");

	/* Move all loopuses from src to dest faceuse */
	while( BU_LIST_WHILE( lu, loopuse, &src_fu->lu_hd ) )  {
		BU_LIST_DEQUEUE( &(lu->l) );
		BU_LIST_INSERT( &(dest_fu->lu_hd), &(lu->l) );
		lu->up.fu_p = dest_fu;
	}
	/* The src_fu is invalid here, with an empty lu_hd list */

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_move_fu_fu(dest_fu=x%x, src_fu=x%x)\n", dest_fu , src_fu);
	}
}

/*
 *			N M G _ J F
 *
 *  Join two faces together by
 *  moving everything from the source faceuse and mate into the
 *  destination faceuse and mate, taking into account face orientations.
 *  The source face is destroyed by this operation.
 */
void
nmg_jf(register struct faceuse *dest_fu, register struct faceuse *src_fu)
{
	NMG_CK_FACEUSE(dest_fu);
	NMG_CK_FACEUSE(src_fu);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_jf(dest_fu=x%x, src_fu=x%x)\n", dest_fu, src_fu);
	}

	if( src_fu->f_p == dest_fu->f_p )
		rt_bomb("nmg_jf() src and dest faces are the same\n");

	if( dest_fu->orientation == src_fu->orientation )  {
		nmg_move_fu_fu(dest_fu, src_fu);
		nmg_move_fu_fu(dest_fu->fumate_p, src_fu->fumate_p);
	} else {
		nmg_move_fu_fu(dest_fu, src_fu->fumate_p);
		nmg_move_fu_fu(dest_fu->fumate_p, src_fu);
	}
	/* The src_fu is invalid here, having an empty lu_hd list */
	nmg_kfu(src_fu);

}

/*
 *			N M G _ D U P _ F A C E
 *
 *  Construct a duplicate of a face into the shell 's'.
 *  The vertex geometry is copied from the source face into topologically
 *  distinct (new) vertex and vertex_g structs.
 *  They will start out being geometricly coincident, but it is anticipated
 *  that the caller will modify the geometry, e.g. as in an extrude operation.
 *
 *  It is the caller's responsibility to re-bound the new face after
 *  making any modifications.
 */
struct faceuse *
nmg_dup_face(struct faceuse *fu, struct shell *s)
{
	struct loopuse *new_lu, *lu;
	struct faceuse *new_fu = (struct faceuse *)NULL;
	struct model	*m;
	struct model	*m_f;
	plane_t		pl;
	long		**trans_tbl;
	long		tbl_size;

	NMG_CK_FACEUSE(fu);
	NMG_CK_FACE(fu->f_p);
	NMG_CK_SHELL(s);

	/* allocate the table that holds the translations between existing
	 * elements and the duplicates we will create.
	 */
	m = nmg_find_model( (long *)s );
	tbl_size = m->maxindex;

	m_f = nmg_find_model( (long *)fu );
	if (m != m_f)
		tbl_size += m_f->maxindex;

	/* Needs double space, because model will grow as dup proceeds */
	trans_tbl = (long **)bu_calloc(tbl_size*2, sizeof(long *),
			"nmg_dup_face trans_tbl");

	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		if (rt_g.NMG_debug & DEBUG_BASIC)
			bu_log("nmg_dup_face() duping %s loop...",
				nmg_orientation(lu->orientation));
		if (new_fu) {
			new_lu = nmg_dup_loop(lu, &new_fu->l.magic, trans_tbl);
		} else {
			new_lu = nmg_dup_loop(lu, &s->l.magic, trans_tbl);
			new_fu = nmg_mf(new_lu);

			/* since nmg_mf() FORCES the orientation of the
			 * initial loop to be OT_SAME, we need to re-set
			 * the orientation of new_lu if lu->orientation
			 * is not OT_SAME.  In general, the first loopuse on
			 * a faceuse's linked list will be OT_SAME, but
			 * in some circumstances (such as after booleans)
			 * the first loopuse MAY be OT_OPPOSITE
			 */
			if (lu->orientation != OT_SAME) {
				new_lu->orientation = lu->orientation;
				new_lu->lumate_p->orientation =
					lu->lumate_p->orientation;
			}
		}
		if (rt_g.NMG_debug & DEBUG_BASIC)
			bu_log(".  Duped %s loop\n",
				nmg_orientation(new_lu->orientation));
	}

	/* Create duplicate, independently modifiable face geometry */
	switch (*fu->f_p->g.magic_p) {
	case NMG_FACE_G_PLANE_MAGIC:
		NMG_GET_FU_PLANE( pl, fu );
		nmg_face_g(new_fu, pl);
		break;
	case NMG_FACE_G_SNURB_MAGIC:
		{
			struct face_g_snurb	*old = fu->f_p->g.snurb_p;
			struct face_g_snurb	*new;
			/* Create a new, duplicate snurb */
			nmg_face_g_snurb(new_fu,
				old->order[0], old->order[1],
				old->u.k_size, old->v.k_size,
				NULL, NULL,
				old->s_size[0], old->s_size[1],
				old->pt_type,
				NULL );
			new = new_fu->f_p->g.snurb_p;
			/* Copy knots */
			bcopy( old->u.knots, new->u.knots, old->u.k_size*sizeof(fastf_t) );
			bcopy( old->v.knots, new->v.knots, old->v.k_size*sizeof(fastf_t) );
			/* Copy mesh */
			bcopy( old->ctl_points, new->ctl_points,
				old->s_size[0] * old->s_size[1] *
				RT_NURB_EXTRACT_COORDS(old->pt_type) *
				sizeof(fastf_t) );
		}
	}
	new_fu->orientation = fu->orientation;
	new_fu->fumate_p->orientation = fu->fumate_p->orientation;

	bu_free((char *)trans_tbl, "nmg_dup_face trans_tbl");

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_dup_face(fu=x%x, s=x%x) new_fu=x%x\n",
			fu, s, new_fu);
	}

	return(new_fu);
}

/************************************************************************
 *									*
 *				LOOP Routines				*
 *									*
 ************************************************************************/

/*
 *			N M G _ J L
 *
 *  Join two loops together which share a common edge,
 *  such that both occurances of the common edge are deleted.
 *  This routine always leaves "lu" intact, and kills the loop
 *  radial to "eu" (after stealing all it's edges).
 *
 *  Either both loops must be of the same orientation, or then
 *  first loop must be OT_SAME, and the second loop must be OT_OPPOSITE.
 *  Joining OT_SAME & OT_OPPOSITE always gives an OT_SAME result.
 *		Above statment is not true!!!! I have added nmg_lu_reorient() -JRA
 *  Since "lu" must survive, it must be the OT_SAME one.
 */
void
nmg_jl(struct loopuse *lu, struct edgeuse *eu)
{
	struct loopuse	*lu2;
	struct edgeuse	*eu_r;		/* use of shared edge in lu2 */
	struct edgeuse	*nexteu;

	NMG_CK_LOOPUSE(lu);

	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGEUSE(eu->eumate_p);
	eu_r = eu->radial_p;
	NMG_CK_EDGEUSE(eu_r);
	NMG_CK_EDGEUSE(eu_r->eumate_p);

	lu2 = eu_r->up.lu_p;
	NMG_CK_LOOPUSE(lu2);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_jl(lu=x%x, eu=x%x) lu2=x%x\n", lu, eu, lu2);
	}

	if (eu->up.lu_p != lu)
		rt_bomb("nmg_jl: edgeuse is not child of loopuse?\n");

	if (lu2->l.magic != NMG_LOOPUSE_MAGIC)
		rt_bomb("nmg_jl: radial edgeuse not part of loopuse\n");

	if (lu2 == lu)
		rt_bomb("nmg_jl: trying to join a loop to itself\n");

	if (lu->up.magic_p != lu2->up.magic_p)
		rt_bomb("nmg_jl: loopuses do not share parent\n");

	if (lu2->orientation != lu->orientation)  {
		if( lu->orientation != OT_SAME || lu2->orientation != OT_OPPOSITE )  {
			bu_log("nmg_jl: lu2 = %s, lu = %s\n",
				nmg_orientation(lu2->orientation),
				nmg_orientation(lu->orientation) );
			rt_bomb("nmg_jl: can't join loops of different orientation!\n");
		} else {
			/* Consuming an OPPOSITE into a SAME is OK */
		}
	}

	if (eu->radial_p->eumate_p->radial_p->eumate_p != eu ||
	    eu->eumate_p->radial_p->eumate_p->radial_p != eu)
	    	rt_bomb("nmg_jl: edgeuses must be sole uses of edge to join loops\n");

	/*
	 * Remove all the edgeuses "ahead" of our radial and insert them
	 * "behind" the current edgeuse.
	 * Operates on lu and lu's mate simultaneously.
	 */
	nexteu = BU_LIST_PNEXT_CIRC(edgeuse, eu_r);
	while (nexteu != eu_r) {
		BU_LIST_DEQUEUE(&nexteu->l);
		BU_LIST_INSERT(&eu->l, &nexteu->l);
		nexteu->up.lu_p = eu->up.lu_p;

		BU_LIST_DEQUEUE(&nexteu->eumate_p->l);
		BU_LIST_APPEND(&eu->eumate_p->l, &nexteu->eumate_p->l);
		nexteu->eumate_p->up.lu_p = eu->eumate_p->up.lu_p;

		nexteu = BU_LIST_PNEXT_CIRC(edgeuse, eu_r);
	}

	/*
	 * The other loop just has the one (shared) edgeuse left in it.
	 * Delete the other loop (and it's mate).
	 */
	nmg_klu(lu2);

	/*
	 * Kill the one remaining use of the (formerly) "shared" edge in lu
	 * and voila: one contiguous loop.
	 */
	if( nmg_keu(eu) )  rt_bomb("nmg_jl() loop vanished?\n");

	nmg_lu_reorient( lu );
}

/*
 *			N M G _ J O I N _ 2 L O O P S
 *
 *  Intended to join an interior and exterior loop together,
 *  by building a bridge between the two indicated vertices.
 *
 *  This routine can be used to join two exterior loops which do not
 *  overlap, and it can also be used to join an exterior loop with
 *  a loop of oposite orientation that lies entirely within it.
 *  This restriction is important, but not checked for.
 *
 *  If the two vertexuses reference distinct vertices, then two new
 *  edges are built to bridge the loops together.
 *  If the two vertexuses share the same vertex, then it is even easier.
 *
 *  Returns the replacement for vu2.
 */
struct vertexuse *
nmg_join_2loops(struct vertexuse *vu1, struct vertexuse *vu2)
{
	struct edgeuse	*eu1, *eu2;
	struct edgeuse	*first_new_eu;
	struct edgeuse	*second_new_eu;
	struct edgeuse	*final_eu2;
	struct loopuse	*lu1, *lu2;

	NMG_CK_VERTEXUSE(vu1);
	NMG_CK_VERTEXUSE(vu2);
	eu1 = vu1->up.eu_p;
	eu2 = vu2->up.eu_p;
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);
	lu1 = eu1->up.lu_p;
	lu2 = eu2->up.lu_p;
	NMG_CK_LOOPUSE(lu1);
	NMG_CK_LOOPUSE(lu2);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_join_2loops(vu1=x%x, vu2=x%x) lu1=x%x, lu2=x%x\n",
			vu1, vu2, lu1, lu2 );
	}

	if( lu1 == lu2 || lu1->l_p == lu2->l_p )
		rt_bomb("nmg_join_2loops: can't join loop to itself\n");

	if( lu1->up.fu_p != lu2->up.fu_p )
		rt_bomb("nmg_join_2loops: can't join loops in different faces\n");

	if( vu1->v_p != vu2->v_p )  {
		/*
		 *  Start by taking a jaunt from vu1 to vu2 and back.
		 */

		/* insert 0 length edge, before eu1 */
		first_new_eu = nmg_eins(eu1);

		/* split the new edge, and connect it to vertex 2 */
		second_new_eu = nmg_eusplit( vu2->v_p, first_new_eu, 0 );
		first_new_eu = BU_LIST_PPREV_CIRC(edgeuse, second_new_eu);

		/* Make the two new edgeuses share just one edge */
		nmg_je( second_new_eu, first_new_eu );

		/* first_new_eu is eu that enters shared vertex */
		vu1 = second_new_eu->vu_p;
	} else {
		second_new_eu = eu1;
		first_new_eu = BU_LIST_PPREV_CIRC(edgeuse, second_new_eu);
		NMG_CK_EDGEUSE(second_new_eu);
	}
	/* second_new_eu is eu that departs from shared vertex */
	vu2 = second_new_eu->vu_p;	/* replacement for original vu2 */
	if( vu1->v_p != vu2->v_p )  rt_bomb("nmg_join_2loops: jaunt failed\n");

	/*
	 *  Gobble edges off of loop2 (starting with eu2),
	 *  and insert them into loop1,
	 *  between first_new_eu and second_new_eu.
	 *  The final edge from loop 2 will then be followed by
	 *  second_new_eu.
	 */
	final_eu2 = BU_LIST_PPREV_CIRC(edgeuse, eu2 );
	while( BU_LIST_NON_EMPTY( &lu2->down_hd ) )  {
		eu2 = BU_LIST_PNEXT_CIRC(edgeuse, final_eu2);

		BU_LIST_DEQUEUE(&eu2->l);
		BU_LIST_INSERT(&second_new_eu->l, &eu2->l);
		eu2->up.lu_p = lu1;

		BU_LIST_DEQUEUE(&eu2->eumate_p->l);
		BU_LIST_APPEND(&second_new_eu->eumate_p->l, &eu2->eumate_p->l);
		eu2->eumate_p->up.lu_p = lu1->lumate_p;
	}

	nmg_lu_reorient( lu1 );

	/* Kill entire (null) loop associated with lu2 */
	nmg_klu(lu2);

	return vu2;
}

/* XXX These should be included in nmg_join_2loops, or be called by it */
/*
 *			N M G _ J O I N _ S I N G V U _ L O O P
 *
 *  vu1 is in a regular loop, vu2 is in a loop of a single vertex
 *  A jaunt is taken from vu1 to vu2 and back to vu1, and the
 *  old loop at vu2 is destroyed.
 *  Return is the new vu that replaces vu2.
 */
struct vertexuse *
nmg_join_singvu_loop(struct vertexuse *vu1, struct vertexuse *vu2)
{
    	struct edgeuse	*eu1;
	struct edgeuse	*first_new_eu, *second_new_eu;
	struct loopuse	*lu2;

	NMG_CK_VERTEXUSE( vu1 );
	NMG_CK_VERTEXUSE( vu2 );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_join_singvu_loop(vu1=x%x, vu2=x%x) lu1=x%x, lu2=x%x\n",
			vu1, vu2, vu1->up.lu_p, vu2->up.lu_p );
	}

	if( *vu2->up.magic_p != NMG_LOOPUSE_MAGIC ||
	    *vu1->up.magic_p != NMG_EDGEUSE_MAGIC )  rt_bomb("nmg_join_singvu_loop bad args\n");

	if( vu1->v_p == vu2->v_p )  rt_bomb("nmg_join_singvu_loop same vertex\n");

    	/* Take jaunt from vu1 to vu2 and back */
    	eu1 = vu1->up.eu_p;
    	NMG_CK_EDGEUSE(eu1);

    	/* Insert 0 length edge */
    	first_new_eu = nmg_eins(eu1);
	/* split the new edge, and connect it to vertex 2 */
	second_new_eu = nmg_eusplit( vu2->v_p, first_new_eu, 0 );
	first_new_eu = BU_LIST_PPREV_CIRC(edgeuse, second_new_eu);
	/* Make the two new edgeuses share just one edge */
	nmg_je( second_new_eu, first_new_eu );

	/* Kill loop lu2 associated with vu2 */
	lu2 = vu2->up.lu_p;
	NMG_CK_LOOPUSE(lu2);
	nmg_klu(lu2);

	return second_new_eu->vu_p;
}

/*
 *			N M G _ J O I N _ 2 S I N G V U _ L O O P S
 *
 *  Both vertices are part of single vertex loops.
 *  Converts loop on vu1 into a real loop that connects them together,
 *  with a single edge (two edgeuses).
 *  Loop on vu2 is killed.
 *  Returns replacement vu for vu2.
 *  Does not change the orientation.
 */
struct vertexuse *
nmg_join_2singvu_loops(struct vertexuse *vu1, struct vertexuse *vu2)
{
	struct edgeuse	*first_new_eu, *second_new_eu;
	struct loopuse	*lu1, *lu2;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_join_2singvu_loops(vu1=x%x, vu2=x%x) lu1=x%x, lu2=x%x\n",
			vu1, vu2, vu1->up.lu_p, vu2->up.lu_p );
	}

	NMG_CK_VERTEXUSE( vu1 );
	NMG_CK_VERTEXUSE( vu2 );

	if( *vu2->up.magic_p != NMG_LOOPUSE_MAGIC ||
	    *vu1->up.magic_p != NMG_LOOPUSE_MAGIC )  rt_bomb("nmg_join_2singvu_loops bad args\n");

	if( vu1->v_p == vu2->v_p )  rt_bomb("nmg_join_2singvu_loops same vertex\n");

    	/* Take jaunt from vu1 to vu2 and back */
	/* Make a 0 length edge on vu1 */
	first_new_eu = nmg_meonvu(vu1);
	/* split the new edge, and connect it to vertex 2 */
	second_new_eu = nmg_eusplit( vu2->v_p, first_new_eu, 0 );
	first_new_eu = BU_LIST_PPREV_CIRC(edgeuse, second_new_eu);
	/* Make the two new edgeuses share just one edge */
	nmg_je( second_new_eu, first_new_eu );

	/* Kill loop lu2 associated with vu2 */
	lu2 = vu2->up.lu_p;
	NMG_CK_LOOPUSE(lu2);
	nmg_klu(lu2);

	lu1 = vu1->up.eu_p->up.lu_p;
	NMG_CK_LOOPUSE(lu1);

	return second_new_eu->vu_p;
}

/*			N M G _ C U T _ L O O P
 *
 *	Divide a loop of edges between two vertexuses.
 *
 *	Make a new loop between the two vertexes, and split it and
 *	the loop of the vertexuses at the same time.
 *
 *
 *		BEFORE					AFTER
 *
 *
 *     Va    eu1  vu1		Vb	       Va   eu1  vu1             Vb
 *	* <---------* <---------*		* <--------*  * <--------*
 *	|					|	      |		 
 *	|			^		|	   ^  |		 ^
 *	|	 Original	|		| Original |  |	   New   |
 *	|	   Loopuse	|		| Loopuse  |  |	 Loopuse |
 *	V			|		V          |  V	/	 |
 *				|		           |   /	 |
 *	*----------> *--------> *		*--------> *  *--------> *
 *     Vd	     vu2 eu2	Vc	       Vd             vu2  eu2   Vc
 *
 *  Returns the new loopuse pointer.  The new loopuse will contain "vu2"
 *  and the edgeuse associated with "vu2" as the FIRST edgeuse on the
 *  list of edgeuses.  The edgeuse for the new edge  (connecting
 *  the verticies indicated by vu1 and vu2) will be the LAST edgeuse on the
 *  new loopuse's list of edgeuses.
 *
 *  It is the caller's responsibility to re-bound the loops.
 *
 *  Both old and new loopuse will have orientation OT_UNSPEC.  It is the
 *  callers responsibility to determine what the orientations should be.
 *  This can be conveniently done with nmg_lu_reorient().
 *
 *  Here is a simple example of how the new loopuse might have a different
 *  orientation than the original one:
 *
 *
 *		F<----------------E
 *		|                 ^
 *		|                 |
 *		|      C--------->D
 *		|      ^          .
 *		|      |          .
 *		|      |          .
 *		|      B<---------A
 *		|                 ^
 *		v                 |
 *		G---------------->H
 *
 *  When nmg_cut_loop(A,D) is called, the new loop ABCD is clockwise,
 *  even though the original loop was counter-clockwise.
 *  There is no way to determine this without referring to the
 *  face normal and vertex geometry, which being a topology routine
 *  this routine shouldn't do.
 *
 *  Returns -
 *	NULL	Error
 *	lu	Loopuse of new loop, on success.
 */
struct loopuse *
nmg_cut_loop(struct vertexuse *vu1, struct vertexuse *vu2)
{
	struct loopuse *lu, *oldlu;
	struct edgeuse *eu1, *eu2, *eunext, *neweu, *eu;
	struct model	*m;
	FILE		*fd;
	char		name[32];
	static int	i=0;

	NMG_CK_VERTEXUSE(vu1);
	NMG_CK_VERTEXUSE(vu2);

	eu1 = vu1->up.eu_p;
	eu2 = vu2->up.eu_p;
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);
	oldlu = eu1->up.lu_p;
	NMG_CK_LOOPUSE(oldlu);

	if (eu2->up.lu_p != oldlu) {
		rt_bomb("nmg_cut_loop() vertices not decendants of same loop\n");
	}

	if( vu1->v_p == vu2->v_p )  {
		/* The loops touch, use a different routine */
		lu = nmg_split_lu_at_vu( oldlu, vu1 );
		goto out;
	}

	NMG_CK_FACEUSE(oldlu->up.fu_p);
	m = oldlu->up.fu_p->s_p->r_p->m_p;
	NMG_CK_MODEL(m);

	if (rt_g.NMG_debug & DEBUG_CUTLOOP) {
		bu_log("\tnmg_cut_loop\n");
		if (rt_g.NMG_debug & DEBUG_PLOTEM) {
			long		*tab;
			tab = (long *)bu_calloc( m->maxindex, sizeof(long),
				"nmg_cut_loop flag[] 1" );

			(void)sprintf(name, "Before_cutloop%d.pl", ++i);
			bu_log("nmg_cut_loop() plotting %s\n", name);
			if ((fd = fopen(name, "w")) == (FILE *)NULL) {
				(void)perror(name);
				exit(-1);
			}

			nmg_pl_fu(fd, oldlu->up.fu_p, tab, 100, 100, 100);
			nmg_pl_fu(fd, oldlu->up.fu_p->fumate_p, tab, 100, 100, 100);
			(void)fclose(fd);
			bu_free( (char *)tab, "nmg_cut_loop flag[] 1" );
		}
	}

	/* make a new loop structure for the new loop & throw away
	 * the vertexuse we don't need
	 */
	lu = nmg_mlv(oldlu->up.magic_p, (struct vertex *)NULL, OT_UNSPEC );
	oldlu->orientation = oldlu->lumate_p->orientation = OT_UNSPEC;

	nmg_kvu(BU_LIST_FIRST(vertexuse, &lu->down_hd));
	nmg_kvu(BU_LIST_FIRST(vertexuse, &lu->lumate_p->down_hd));
	/* nmg_kvu() does BU_LIST_INIT() on down_hd */
	/* The loopuse is considered invalid until it gets some edges */

	/* move the edges into one of the uses of the new loop */
	for (eu = eu2 ; eu != eu1 ; eu = eunext) {
		eunext = BU_LIST_PNEXT_CIRC(edgeuse, &eu->l);

		BU_LIST_DEQUEUE(&eu->l);
		BU_LIST_INSERT(&lu->down_hd, &eu->l);
		BU_LIST_DEQUEUE(&eu->eumate_p->l);
		BU_LIST_APPEND(&lu->lumate_p->down_hd, &eu->eumate_p->l);
		eu->up.lu_p = lu;
		eu->eumate_p->up.lu_p = lu->lumate_p;
	}

	/* make a wire edge in the shell to "cap off" the new loop */
	neweu = nmg_me(eu1->vu_p->v_p, eu2->vu_p->v_p, nmg_find_s_of_eu(eu1));

	/* move the new edgeuse into the new loopuse */
	BU_LIST_DEQUEUE(&neweu->l);
	BU_LIST_INSERT(&lu->down_hd, &neweu->l);
	neweu->up.lu_p = lu;

	/* move the new edgeuse mate into the new loopuse mate */
	BU_LIST_DEQUEUE(&neweu->eumate_p->l);
	BU_LIST_APPEND(&lu->lumate_p->down_hd, &neweu->eumate_p->l);
	neweu->eumate_p->up.lu_p = lu->lumate_p;

	/* now we go back and close up the loop we just ripped open */
	eunext = nmg_me(eu2->vu_p->v_p, eu1->vu_p->v_p, nmg_find_s_of_eu(eu1));

	BU_LIST_DEQUEUE(&eunext->l);
	BU_LIST_INSERT(&eu1->l, &eunext->l);
	BU_LIST_DEQUEUE(&eunext->eumate_p->l);
	BU_LIST_APPEND(&eu1->eumate_p->l, &eunext->eumate_p->l);
	eunext->up.lu_p = eu1->up.lu_p;
	eunext->eumate_p->up.lu_p = eu1->eumate_p->up.lu_p;

	/* make new edgeuses radial to each other, sharing the new edge */
	nmg_je(neweu, eunext);

	nmg_ck_lueu(oldlu, "oldlu");
	nmg_ck_lueu(lu, "lu");	/*LABLABLAB*/


	if (rt_g.NMG_debug & DEBUG_CUTLOOP && rt_g.NMG_debug & DEBUG_PLOTEM) {
		long		*tab;
		tab = (long *)bu_calloc( m->maxindex, sizeof(long),
			"nmg_cut_loop flag[] 2" );

		(void)sprintf(name, "After_cutloop%d.pl", i);
		bu_log("nmg_cut_loop() plotting %s\n", name);
		if ((fd = fopen(name, "w")) == (FILE *)NULL) {
			(void)perror(name);
			exit(-1);
		}

		nmg_pl_fu(fd, oldlu->up.fu_p, tab, 100, 100, 100);
		nmg_pl_fu(fd, oldlu->up.fu_p->fumate_p, tab, 100, 100, 100);
		(void)fclose(fd);
		bu_free( (char *)tab, "nmg_cut_loop flag[] 2" );
	}
out:
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_cut_loop(vu1=x%x, vu2=x%x) old_lu=x%x, new_lu=x%x\n",
			vu1, vu2, oldlu, lu );
	}

	return lu;
}

/*
 *			N M G _ S P L I T _ L U _ A T _ V U
 *
 *  In a loop which has at least two distinct uses of a vertex,
 *  split off the edges from "split_vu" to the second occurance of
 *  the vertex into a new loop.
 *  It is the caller's responsibility to re-bound the loops.
 *
 *  The old and new loopuses will have orientation OT_UNSPEC.  It is the
 *  callers responsibility to determine what their orientations should be.
 *  This can be conveniently done with nmg_lu_reorient().
 *
 *  Here is an example:
 *
 *	              E<__________B <___________A
 *	              |           ^\            ^
 *	              |          /  \           |
 *	              |         /    \          |
 *	              |        /      v         |
 *	              |       D<_______C        |
 *	              v                         |
 *	              F________________________>G
 *	
 *  When nmg_split_lu_at_vu(lu, B) is called, the old loopuse continues to
 *  be counter clockwise and OT_SAME, but the new loopuse BCD is now
 *  clockwise.  It needs to be marked OT_OPPOSITE.  Without referring
 *  to the geometry, this can't be determined.
 *
 *  Intended primarily for use by nmg_split_touchingloops().
 *
 *  Returns -
 *	NULL	Error
 *	lu	Loopuse of new loop, on success.
 */
struct loopuse *
nmg_split_lu_at_vu(struct loopuse *lu, struct vertexuse *split_vu)
{
	struct edgeuse		*eu;
	struct vertexuse	*vu;
	struct loopuse		*newlu;
	struct loopuse		*newlumate;
	struct vertex		*split_v;
	int			iteration;

	split_v = split_vu->v_p;
	NMG_CK_VERTEX(split_v);

	eu = split_vu->up.eu_p;
	NMG_CK_EDGEUSE(eu);

	if( eu->up.lu_p != lu )  {
		/* Could not find indicated vertex */
		newlu = (struct loopuse *)0;		/* FAIL */
		goto out;
	}

	/* Make a new loop in the same face */
	lu->orientation = lu->lumate_p->orientation = OT_UNSPEC;
	newlu = nmg_mlv( lu->up.magic_p, (struct vertex *)NULL, OT_UNSPEC );
	NMG_CK_LOOPUSE(newlu);
	newlumate = newlu->lumate_p;
	NMG_CK_LOOPUSE(newlumate);

	/* Throw away unneeded lone vertexuse */
	nmg_kvu(BU_LIST_FIRST(vertexuse, &newlu->down_hd));
	nmg_kvu(BU_LIST_FIRST(vertexuse, &newlumate->down_hd));
	/* nmg_kvu() does BU_LIST_INIT() on down_hd */

	/* Move edges & mates into new loop until vertex is repeated */
	for( iteration=0; iteration < 10000; iteration++ )  {
		struct edgeuse	*eunext;
		eunext = BU_LIST_PNEXT_CIRC(edgeuse, &eu->l);

		BU_LIST_DEQUEUE(&eu->l);
		BU_LIST_INSERT(&newlu->down_hd, &eu->l);
		BU_LIST_DEQUEUE(&eu->eumate_p->l);
		BU_LIST_APPEND(&newlumate->down_hd, &eu->eumate_p->l);

		/* Change edgeuse & mate up pointers */
		eu->up.lu_p = newlu;
		eu->eumate_p->up.lu_p = newlumate;

		/* Advance to next edgeuse */
		eu = eunext;

		/* When split_v is encountered, stop */
		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		if( vu->v_p == split_v )  break;
	}
	if( iteration >= 10000 )  rt_bomb("nmg_split_lu_at_vu:  infinite loop\n");
out:
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_split_lu_at_vu( lu=x%x, split_vu=x%x ) newlu=x%x\n",
			lu, split_vu, newlu );
	}
	return newlu;
}

/*
 *			N M G _ F I N D _ R E P E A T E D _ V _ I N _ L U
 *
 *  Given a vertexuse of an edgeuse in a loopuse, see if the vertex is
 *  used by at least one other vertexuse in that same loopuse.
 *
 *  Returns -
 *	vu	If this vertex appears elsewhere in the loopuse.
 *	NULL	If this is the only occurance of this vertex in the loopuse.
 *  XXX move to nmg_info.c
 */
struct vertexuse *
nmg_find_repeated_v_in_lu(struct vertexuse *vu)
{
	struct vertexuse	*tvu;		/* vu to test */
	struct loopuse		*lu;
	struct vertex		*v;

	v = vu->v_p;
	NMG_CK_VERTEX(v);

	if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
		return (struct vertexuse *)0;
	if( *vu->up.eu_p->up.magic_p != NMG_LOOPUSE_MAGIC )
		return (struct vertexuse *)0;
	lu = vu->up.eu_p->up.lu_p;

	/*
	 *  For each vertexuse on vertex list,
	 *  check to see if it points up to the this loop.
	 *  If so, then there is a duplicated vertex.
	 *  Ordinarily, the vertex list will be *very* short,
	 *  so this strategy is likely to be faster than
	 *  a table-based approach, for most cases.
	 */
	for( BU_LIST_FOR( tvu, vertexuse, &v->vu_hd ) )  {
		struct edgeuse		*teu;
		struct loopuse		*tlu;

		if( tvu == vu )  continue;
		if( *tvu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
		teu = tvu->up.eu_p;
		NMG_CK_EDGEUSE(teu);
		if( *teu->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
		tlu = teu->up.lu_p;
		NMG_CK_LOOPUSE(tlu);
		if( tlu != lu )  continue;
		/*
		 *  Repeated vertex exists.  Return (one) other use of it.
		 */
		return tvu;
	}
	return (struct vertexuse *)0;
}

/*
 *			N M G _ S P L I T _ T O U C H I N G L O O P S
 *
 *  Search through all the vertices in a loop.
 *  Whenever there are two distinct uses of one vertex in the loop,
 *  split off all the edges between them into a new loop.
 *
 *  Note that the call to nmg_split_lu_at_vu() will cause the split
 *  loopuses to be marked OT_UNSPEC.
 */
void
nmg_split_touchingloops(struct loopuse *lu, const struct bn_tol *tol)
{
	struct edgeuse		*eu;
	struct vertexuse	*vu;
	struct loopuse		*newlu;
	struct vertexuse	*vu_save;

	NMG_CK_LOOPUSE(lu);
	BN_CK_TOL(tol);
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_split_touchingloops( lu=x%x )\n", lu);
	}
top:
	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return;

	vu_save = (struct vertexuse *)NULL;

	/* For each edgeuse, get vertexuse and vertex */
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {

		struct edgeuse *other_eu;
		struct vertexuse *other_vu;
		int vu_is_part_of_crack=0;

		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);

#if 1
		if( !nmg_find_repeated_v_in_lu( vu ) )  continue;

		/* avoid splitting a crack if possible */
		for( BU_LIST_FOR( other_vu, vertexuse, &vu->v_p->vu_hd ) )
		{
			if( nmg_find_lu_of_vu( other_vu ) != lu )
				continue;
			if( *other_vu->up.magic_p != NMG_EDGEUSE_MAGIC )
				continue;
			other_eu = other_vu->up.eu_p;
			if( nmg_eu_is_part_of_crack( other_eu ) )
			{
				vu_save = other_vu;
				vu_is_part_of_crack = 1;
				break;
			}
		}

		if( vu_is_part_of_crack )
			continue;

		/*
		 *  Repeated vertex exists,
		 *  Split loop into two loops
		 */
		newlu = nmg_split_lu_at_vu( lu, vu );
		NMG_CK_LOOPUSE(newlu);
		NMG_CK_LOOP(newlu->l_p);
		nmg_loop_g(newlu->l_p, tol);

		/* Ensure there are no duplications in new loop */
		nmg_split_touchingloops(newlu, tol);

		/* There is no telling where we will be in the
		 * remainder of original loop, check 'em all.
		 */
		goto top;
	}

	if( vu_save )
	{
		/* split loop at crack */
		newlu = nmg_split_lu_at_vu( lu, vu_save );
		NMG_CK_LOOPUSE(newlu);
		NMG_CK_LOOP(newlu->l_p);
		nmg_loop_g(newlu->l_p, tol);

		/* Ensure there are no duplications in new loop */
		nmg_split_touchingloops(newlu, tol);

		/* There is no telling where we will be in the
		 * remainder of original loop, check 'em all.
		 */
		goto top;
	}

#else
		v = vu->v_p;
		NMG_CK_VERTEX(v);

		/*
		 *  For each vertexuse on vertex list,
		 *  check to see if it points up to the this loop.
		 *  If so, then there is a duplicated vertex.
		 *  Ordinarily, the vertex list will be *very* short,
		 *  so this strategy is likely to be faster than
		 *  a table-based approach, for most cases.
		 */
		for( BU_LIST_FOR( tvu, vertexuse, &v->vu_hd ) )  {
			struct edgeuse		*teu;
			struct loopuse		*tlu;

			if( tvu == vu )  continue;
			if( *tvu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
			teu = tvu->up.eu_p;
			NMG_CK_EDGEUSE(teu);
			if( *teu->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
			tlu = teu->up.lu_p;
			NMG_CK_LOOPUSE(tlu);
			if( tlu != lu )  continue;
			/*
			 *  Repeated vertex exists,
			 *  Split loop into two loops
			 */
			newlu = nmg_split_lu_at_vu( lu, vu );
			NMG_CK_LOOPUSE(newlu);
			NMG_CK_LOOP(newlu->l_p);
			nmg_loop_g(newlu->l_p, tol);

			/* Ensure there are no duplications in new loop */
			nmg_split_touchingloops(newlu, tol);

			/* There is no telling where we will be in the
			 * remainder of original loop, check 'em all.
			 */
			goto top;
		}
	}
#endif
}

/*
 *			N M G _ J O I N _ T O U C H I N G L O O P S
 *
 *  Search through all the vertices in a loopuse that belongs to a faceuse.
 *  Whenever another loopuse in the same faceuse refers to one of this
 *  loop's vertices, the two loops touch at (at least) that vertex.
 *  Join them together.
 *
 *  Return -
 *	count of loops joined (eliminated)
 */
int
nmg_join_touchingloops(struct loopuse *lu)
{
	struct faceuse		*fu;
	struct edgeuse		*eu;
	struct vertexuse	*vu;
	struct vertex		*v;
	int			count = 0;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_join_touchingloops( lu=x%x )\n", lu);
	}
	NMG_CK_LOOPUSE(lu);
	fu = lu->up.fu_p;
	NMG_CK_FACEUSE(fu);

top:
	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return count;

	/* For each edgeuse, get vertexuse and vertex */
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		struct vertexuse	*tvu;

		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		v = vu->v_p;
		NMG_CK_VERTEX(v);

		/*
		 *  For each vertexuse on vertex list,
		 *  check to see if it points up to an edgeuse in a
		 *  different loopuse in the same faceuse.
		 *  If so, we touch.
		 */
		for( BU_LIST_FOR( tvu, vertexuse, &v->vu_hd ) )  {
			struct edgeuse		*teu;
			struct loopuse		*tlu;

			if( tvu == vu )  continue;
			if( *tvu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
			teu = tvu->up.eu_p;
			NMG_CK_EDGEUSE(teu);
			if( *teu->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
			tlu = teu->up.lu_p;
			NMG_CK_LOOPUSE(tlu);
			if( tlu == lu )  {
				/* We touch ourselves at another vu? */
#if 0
				bu_log("INFO: nmg_join_touchingloops() lu=x%x touches itself at vu1=x%x, vu2=x%x, skipping\n",
					lu, vu, tvu );
#endif
				continue;
			}
			if( *tlu->up.magic_p != NMG_FACEUSE_MAGIC )  continue;
			if( tlu->up.fu_p != fu )  continue;	/* wrong faceuse */
			/*
			 *  Loop 'lu' touches loop 'tlu' at this vertex,
			 *  join them.
			 *  XXX Is there any advantage to searching for
			 *  XXX a potential shared edge at this point?
			 *  XXX Call nmg_simplify_loop()?
			 */
			if (rt_g.NMG_debug & DEBUG_BASIC)  {
				bu_log("nmg_join_touchingloops(): lu=x%x, vu=x%x, tvu=x%x\n", lu, vu, tvu);
			}
			tvu = nmg_join_2loops( vu, tvu );
			NMG_CK_VERTEXUSE(tvu);
			count++;
			goto top;
		}
	}
	return count;
}

/* jaunt status flags used in the jaunt_status array */
#define		JS_UNKNOWN		0
#define		JS_SPLIT		1
#define		JS_JAUNT		2
#define		JS_TOUCHING_JAUNT	3

/*	N M G _ G E T _ T O U C H I N G _ J A U N T S
 *
 * Create a table of EU's. Each EU will be the first EU in 
 * a touching jaunt (edgeuses from vert A->B->A) where vertex B
 * appears elswhere in the loopuse lu.
 *
 * returns:
 *	count of touching jaunts found
 *
 * The passed pointer to an bu_ptbl structure may
 * not be initialized. If no touching jaunts are found,
 * it will still not be initialized upon return (to avoid
 * bu_malloc/bu_free pairs for loops with no touching
 * jaunts. The flag (need_init) lets this routine know
 * whether the ptbl structure has been initialized
 */

int
nmg_get_touching_jaunts(const struct loopuse *lu, struct bu_ptbl *tbl, int *need_init)
{
	struct edgeuse *eu;
	int count=0;

	NMG_CK_LOOPUSE( lu );

	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return( 0 );

	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct edgeuse *eu2,*eu3;

		eu2 = BU_LIST_PNEXT_CIRC(edgeuse, &eu->l);
		eu3 = BU_LIST_PNEXT_CIRC(edgeuse, &eu2->l);

		/* If it's a 2 vertex crack, stop here */
		if( eu->vu_p == eu3->vu_p )  break;

		/* If not jaunt, move on */
		if( eu->vu_p->v_p != eu3->vu_p->v_p )  continue;

		/* It's a jaunt, see if tip touches same loop */
		if( nmg_find_repeated_v_in_lu(eu2->vu_p) == (struct vertexuse *)NULL )
			continue;

		/* This is a touching jaunt, add it to the list */
		if( *need_init )
		{
			bu_ptbl_init( tbl, 64, " tbl");
			*need_init = 0;
		}

		bu_ptbl_ins( tbl, (long *)eu );
		count++;
	}

	return( count );
}

/*	N M G _ C H E C K _ P R O P O S E D _ L O O P
 *
 * Support routine for nmg_loop_split_at_touching_jaunt().
 *
 * Follow the edgeuses in a proposed loop (that may later be created by nmg_split_lu_at_vu)
 * and predict the status of the jaunts in "jaunt_tbl". The jaunt_status array must be
 * initialized before this routine is called and this routine should be called twice
 * to account for both loops that will result from the application of nmg_split_lu_at_vu().
 *
 * input:
 *	start_eu - edgeuse that will be first in the proposed new loop
 *	jaunt_tbl - list of touching jaunts whose status in the resulting loops is desired.
 *	jaunt_no - which entry in the jaunt_tbl is being considered as a split location
 *	visit_count - array for counting the number of times a jaunt gets visited in the new loop
 *		This array just provides working space for the routine.
 *	which_loop - Flag:
 *		0 -> This is a proposed loop to be created  by nmg_split_lu_at_vu()
 *		1 -> This is the loop that will be remaining after nmg_split_lu_at_vu().
 *		when "which_loop" == 1, (*next_start_eu) must be set to the starting EU
 *		of the first loop (Used to find end of remaining loop).
 *
 * output:
 *	jaunt_status - status of each touching jaunt that appears in the jaunt_tbl
 *	next_start_eu - edgeuse that will be first in the next loop
 */

static void
nmg_check_proposed_loop(struct edgeuse *start_eu, struct edgeuse **next_start_eu, int *visit_count, int *jaunt_status, const struct bu_ptbl *jaunt_tbl, const int jaunt_no, const int which_loop)
{
	struct edgeuse *loop_eu;
	struct edgeuse *last_eu;
	int j;
	int done=0;

	NMG_CK_EDGEUSE( start_eu );
	BU_CK_PTBL( jaunt_tbl );

	/* Initialize the count */
	for( j=0 ; j< BU_PTBL_END( jaunt_tbl ) ; j++ )
		visit_count[j] = 0;

	/* walk through the proposed new loop, updating the visit_count and the jaunt status */
	last_eu = NULL;
	loop_eu = start_eu;
	while( !done )
	{
		for( j=0 ; j<BU_PTBL_END( jaunt_tbl ) ; j++ )
		{
			struct edgeuse *jaunt_eu;

			/* Don't worru about this jaunt */
			if( j == jaunt_no )
				continue;

			jaunt_eu = (struct edgeuse *)BU_PTBL_GET( jaunt_tbl, j );
			NMG_CK_EDGEUSE( jaunt_eu );

			/* if jaunt number j is included in this loop, update its status */
			if( last_eu && last_eu == jaunt_eu )
				jaunt_status[j] = JS_JAUNT;

			/* if this loop_eu has its vertex at the apex of one of
			 * the touching jaunts, increment the appropriate visit_count.
			 */
			if( loop_eu->vu_p->v_p == jaunt_eu->eumate_p->vu_p->v_p )
				visit_count[j]++;
		}
		last_eu = loop_eu;
		loop_eu = BU_LIST_PNEXT_CIRC(edgeuse, &loop_eu->l);

		/* if "which_loop" is 0, use the nmg_split_lu_at_vu() terminate condition,
		 * otherwise, continue until we find (*next_start_eu)
		 */
		if( !which_loop && loop_eu->vu_p->v_p == start_eu->vu_p->v_p )
			done = 1;
		else if( which_loop && loop_eu == (*next_start_eu) )
			done = 1;
	}
	*next_start_eu = loop_eu;


	/* check all jaunts to see if they are still touching jaunts in the proposed loop */
	for( j=0 ; j<BU_PTBL_END( jaunt_tbl ) ; j++ )
	{
		if( jaunt_status[j] == JS_JAUNT ) /* proposed loop contains this jaunt */
		{
			if( visit_count[j] > 1 )	/* it's still a touching jaunt */
				jaunt_status[j] = JS_TOUCHING_JAUNT;
		}
	}

	/* if the first or last eu in the proposed loop is a jaunt eu, the proposed
	 * loop will split the jaunt, so set its status to JS_SPLIT.
	 */
	for( j=0 ; j<BU_PTBL_END( jaunt_tbl ) ; j++ )
	{
		struct edgeuse *jaunt_eu;
		struct edgeuse *jaunt_eu2;

		jaunt_eu = (struct edgeuse *)BU_PTBL_GET( jaunt_tbl, j );
		jaunt_eu2 = BU_LIST_PNEXT_CIRC( edgeuse, &jaunt_eu->l );

		if( last_eu == jaunt_eu || start_eu == jaunt_eu2 )
			jaunt_status[j] = JS_SPLIT;
	}

	return;
}

void
nmg_kill_accordions(struct loopuse *lu)
{
	struct edgeuse *eu;
	struct edgeuse *jaunt_eu1;
	struct edgeuse *jaunt_eu2 = NULL;
	struct edgeuse *jaunt_eu3;

	NMG_CK_LOOPUSE( lu );

	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return;
top:
	/* first look for a jaunt */
	jaunt_eu1 = (struct edgeuse *)NULL;
	jaunt_eu3 = (struct edgeuse *)NULL;
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct edgeuse *eu2;

		eu2 = BU_LIST_PPREV_CIRC( edgeuse, &eu->l );
		if( (eu2->vu_p->v_p == eu->eumate_p->vu_p->v_p) && (eu != eu2) )
		{
			struct edgeuse *eu3;

			/* found a jaunt */
			jaunt_eu1 = eu;
			jaunt_eu2 = eu2;

			/* look for a third eu between the same vertices */
			jaunt_eu3 = (struct edgeuse *)NULL;
			for( BU_LIST_FOR( eu3, edgeuse, &lu->down_hd ) )
			{
				if( eu3 == jaunt_eu1 || eu3 == jaunt_eu2 )
					continue;

				if( NMG_ARE_EUS_ADJACENT( eu3, jaunt_eu1 ) )
				{
					jaunt_eu3 = eu3;
					break;
				}
			}
		}
		if( jaunt_eu3 )
			break;
	}

	if( !jaunt_eu3 )
		return;

	if( jaunt_eu2 != jaunt_eu1->eumate_p )
	{
		if ((rt_g.NMG_debug & DEBUG_BASIC) || (rt_g.NMG_debug & DEBUG_CUTLOOP))
			bu_log( "Killing jaunt in accordion eu's x%x and x%x\n", jaunt_eu1, jaunt_eu2 );
		(void)nmg_keu( jaunt_eu1 );
		(void)nmg_keu( jaunt_eu2 );
	}
	else
	{
		if ((rt_g.NMG_debug & DEBUG_BASIC) || (rt_g.NMG_debug & DEBUG_CUTLOOP))
			bu_log( "Killing jaunt in accordion eu x%x\n", jaunt_eu1 );
		(void)nmg_keu( jaunt_eu1 );
	}

	goto top;

}

/*
 *			N M G _ L O O P _ S P L I T _ A T _ T O U C H I N G _ J A U N T
 *
 *  If a loop makes a "jaunt" (edgeuses from verts A->B->A), where the
 *  tip of the jaunt touches the same loop at a different vertexuse,
 *  cut the loop into two.
 *
 *  This produces a much more reasonable loop split than
 *  nmg_split_touchingloops(), which tends to peel off 2-edge "cracks"
 *  as it unravels the loop.
 *
 *  Note that any loops so split will be marked OT_UNSPEC.
 */
int
nmg_loop_split_at_touching_jaunt(struct loopuse *lu, const struct bn_tol *tol)
{
	struct bu_ptbl		jaunt_tbl;
	struct loopuse		*new_lu;
	struct edgeuse		*eu;
	struct edgeuse		*eu2;
	int			count=0;
	int			jaunt_count;
	int			jaunt_no;
	int			need_init=1;
	int			*visit_count;
	int			*jaunt_status;
	int			i;

	NMG_CK_LOOPUSE(lu);
	BN_CK_TOL(tol);

	if ((rt_g.NMG_debug & DEBUG_BASIC) || (rt_g.NMG_debug & DEBUG_CUTLOOP))  {
		bu_log("nmg_loop_split_at_touching_jaunt( lu=x%x ) START\n", lu);
		nmg_pr_lu_briefly( lu, "" );
	}

	/* first kill any accordion pleats */
	nmg_kill_accordions( lu );

	visit_count = (int *)NULL;
	jaunt_status = (int *)NULL;

top:
	jaunt_count = nmg_get_touching_jaunts( lu, &jaunt_tbl, &need_init );
	if( rt_g.NMG_debug & DEBUG_CUTLOOP )
	{
		bu_log( "nmg_loop_split_at_touching_jaunt: found %d touching jaunts in lu x%x\n", jaunt_count, lu );
		if( jaunt_count )
		{
			for( i=0 ; i<BU_PTBL_END( &jaunt_tbl ) ; i++ )
			{
				eu = (struct edgeuse *)BU_PTBL_GET( &jaunt_tbl, i );
				bu_log( "\tx%x\n" , eu );
			}
		}
	}

	if( jaunt_count < 0 )
	{
		bu_log( "nmg_loop_split_at_touching_jaunt: nmg_get_touching_jaunts() returned %d for lu x%x\n", jaunt_count, lu );
		rt_bomb( "nmg_loop_split_at_touching_jaunt: bad jaunt count\n" );
	}

	if( jaunt_count == 0 )
	{
		if( visit_count )
			bu_free( (char *)visit_count, "nmg_loop_split_at_touching_jaunt: visit_count[]\n" );
		if( jaunt_status )
			bu_free( (char *)jaunt_status, "nmg_loop_split_at_touching_jaunt: jaunt_status[]\n" );
		if( !need_init )
			bu_ptbl_free( &jaunt_tbl);

		if ((rt_g.NMG_debug & DEBUG_BASIC) || (rt_g.NMG_debug & DEBUG_CUTLOOP))  {
			bu_log("nmg_loop_split_at_touching_jaunt( lu=x%x ) END count=%d\n",
				lu, count);
		}
		return( count );
	}

	if( jaunt_count == 1 )
	{
		/* just one jaunt, split it and return */
		BU_CK_PTBL( &jaunt_tbl );

		eu = (struct edgeuse *)BU_PTBL_GET( &jaunt_tbl, 0 );
		NMG_CK_EDGEUSE( eu );
		eu2 = BU_LIST_PNEXT_CIRC(edgeuse, &eu->l);

		new_lu = nmg_split_lu_at_vu( lu, eu2->vu_p );
		count++;
		NMG_CK_LOOPUSE(new_lu);
		NMG_CK_LOOP(new_lu->l_p);
		nmg_loop_g(new_lu->l_p, tol);

		bu_ptbl_free( &jaunt_tbl);
		if( visit_count )
			bu_free( (char *)visit_count, "nmg_loop_split_at_touching_jaunt: visit_count[]\n" );
		if( jaunt_status )
			bu_free( (char *)jaunt_status, "nmg_loop_split_at_touching_jaunt: jaunt_status[]\n" );

		if ((rt_g.NMG_debug & DEBUG_BASIC) || (rt_g.NMG_debug & DEBUG_CUTLOOP))  {
			bu_log("nmg_loop_split_at_touching_jaunt( lu=x%x ) END count=%d\n",
				lu, count);
		}
		return( count );
	}

	/* if we get here, there are at least two touching jaunts in the loop.
	 * We need to select which order to split them to avoid converting the
	 * touching jaunt into a crack. To do this, select one touching jaunt
	 * as the location for splitting the loop. Follow the EU's as nmg_split_lu_at_vu()
	 * would do and predict the status of ALL the touching jaunts (not just the one being
	 * split). Both the new loop and the remains of the current loop must be checked
	 * to determine the status of all the touching jaunts.
	 * The original touching jaunts must either remain as touching jaunts in
	 * one of the two resulting loops, or they must be split between the two
	 * resulting loops. If any of the touching jaunts are predicted to have a status
	 * other than split or still touching, then this is a bad choice for splitting
	 * the loop. For example, a touching jaunt may be converted to a non-touching
	 * jaunt by applying nmg_split_lu_at_vu() at the wrong vu and will later be
	 * converted to a two edgeuse loop by nmg_split_touching_loops.
	 */
	BU_CK_PTBL( &jaunt_tbl );

	if( visit_count )
		bu_free( (char *)visit_count, "nmg_loop_split_at_touching_jaunt: visit_count[]\n" );
	if( jaunt_status )
		bu_free( (char *)jaunt_status, "nmg_loop_split_at_touching_jaunt: jaunt_status[]\n" );

	visit_count = (int *)bu_calloc( BU_PTBL_END( &jaunt_tbl ), sizeof( int ),
			"nmg_loop_split_at_touching_jaunt: visit_count[]" );
	jaunt_status = (int *)bu_calloc( BU_PTBL_END( &jaunt_tbl ), sizeof( int ),
			"nmg_loop_split_at_touching_jaunt: jaunt_status[]" );

	/* consider each jaunt as a possible location for splitting the loop */
	for( jaunt_no=0 ; jaunt_no<BU_PTBL_END( &jaunt_tbl ) ; jaunt_no++ )
	{
		struct edgeuse *start_eu1;	/* EU that will start a new loop upon split */
		struct edgeuse *start_eu2;	/* EU that will start the remaining loop */
		int do_split=1;			/* flag: 1 -> this jaunt is a good choice for making the split */

		/* initialize the status of each jaunt to unknown */
		for( i=0 ; i<BU_PTBL_END( &jaunt_tbl ) ; i++ )
			jaunt_status[i] = JS_UNKNOWN;

		/* consider splitting lu at this touching jaunt */
		eu = (struct edgeuse *)BU_PTBL_GET( &jaunt_tbl, jaunt_no );
		NMG_CK_EDGEUSE( eu );

		/* get new loop starting edgeuse */
		start_eu1 = BU_LIST_PNEXT_CIRC(edgeuse, &eu->l);

		if( rt_g.NMG_debug & DEBUG_CUTLOOP )
		{
			bu_log( "\tConsider splitting lu x%x at vu=x%x\n", lu, start_eu1->vu_p );
			bu_log( "\t\t(jaunt number %d\n" , jaunt_no );	
		}

		/* determine status of jaunts in the proposed new loop */
		nmg_check_proposed_loop( start_eu1, &start_eu2, visit_count,
			jaunt_status, &jaunt_tbl, jaunt_no, 0 );

		/* Still need to check the loop that will be left if we do a split here */
		nmg_check_proposed_loop( start_eu2, &start_eu1, visit_count,
			jaunt_status, &jaunt_tbl, jaunt_no, 1 );

		if( rt_g.NMG_debug & DEBUG_CUTLOOP )
		{
			for( i=0 ; i<BU_PTBL_END( &jaunt_tbl ) ; i++ )
			{
				struct edgeuse *tmp_eu;

				tmp_eu = (struct edgeuse *)BU_PTBL_GET( &jaunt_tbl, i );
				bu_log( "\t\tpredicted status of jaunt at eu x%x is ", tmp_eu );
				switch( jaunt_status[i] )
				{
					case JS_UNKNOWN:
						bu_log( "unknown\n" );
						break;
					case JS_SPLIT:
						bu_log( "split\n" );
						break;
					case JS_JAUNT:
						bu_log( "a jaunt\n" );
						break;
					case JS_TOUCHING_JAUNT:
						bu_log( "still a touching jaunt\n" );
						break;
					default:
						bu_log( "unrecognized status\n" );
						break;
				}
			}
		}

		/* check predicted status of all the touching jaunts,
		 * every one must be either split or still a touching jaunt.
		 * Any other status will create loops of two edgeuses!!!
		 */
		for( i=0 ; i<BU_PTBL_END( &jaunt_tbl ) ; i++ )
		{
			if(jaunt_status[i] != JS_SPLIT && jaunt_status[i] != JS_TOUCHING_JAUNT )
			{
				do_split = 0;
				break;
			}
		}

		/* if splitting lu at this touching jaunt is not desirable, check the next one */
		if( !do_split )
		{
			if( rt_g.NMG_debug & DEBUG_CUTLOOP )
			{
				bu_log( "\t\tCannot split lu x%x at proposed vu\n" );
			}
			continue;
		}

		/* This touching jaunt passed all the tests, its reward is to be split */
		eu2 = BU_LIST_PNEXT_CIRC(edgeuse, &eu->l);

		new_lu = nmg_split_lu_at_vu( lu, eu2->vu_p );

		if( rt_g.NMG_debug & DEBUG_CUTLOOP )
		{
			bu_log( "\tnmg_loop_split_at_touching_jaunt: splitting lu x%x at vu x%x\n", lu, eu2->vu_p );
			bu_log( "\t\tnew_lu is x%x\n" , new_lu );
		}

		count++;
		NMG_CK_LOOPUSE(new_lu);
		NMG_CK_LOOP(new_lu->l_p);
		nmg_loop_g(new_lu->l_p, tol);
		bu_ptbl_reset( &jaunt_tbl);

		/* recurse on the new loop */
		count += nmg_loop_split_at_touching_jaunt( new_lu, tol );

		/* continue with the remains of the current loop */
		goto top;
	}

	/* If we ever get here, we have failed to find a way to split this loop!!!! */
	bu_log( "nmg_loop_split_at_touching_jaunt: Could not find a way to split lu x%x\n", lu );
	nmg_pr_lu_briefly( lu, " " );
	nmg_stash_model_to_file( "jaunt.g", nmg_find_model( &lu->l.magic ), "Can't split lu" );
	rt_bomb( "nmg_loop_split_at_touching_jaunt: Can't split lu\n" );

	/* This return will never execute, but the compilers like it */
	return( count );
}

/*			N M G _ S I M P L I F Y _ L O O P
 *
 *	combine adjacent loops within the same parent that touch along
 *	a common edge into a single loop, with the edge eliminated.
 */
void
nmg_simplify_loop(struct loopuse *lu)
{
	struct edgeuse *eu, *eu_r, *tmpeu;

	NMG_CK_LOOPUSE(lu);
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_simplify_loop(lu=x%x)\n", lu);
	}

	if (BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC)
		return;

	eu = BU_LIST_FIRST(edgeuse, &lu->down_hd);
	while (BU_LIST_NOT_HEAD(eu, &lu->down_hd) ) {

		NMG_CK_EDGEUSE(eu);

		eu_r = eu->radial_p;
		NMG_CK_EDGEUSE(eu_r);

		/* if the radial edge is part of a loop, and the loop of
		 * the other edge is a part of the same object (face)
		 * as the loop containing the current edge, and my
		 * edgeuse mate is radial to my radial`s edgeuse
		 * mate, and the radial edge is a part of a loop other
		 * than the one "eu" is a part of 
		 * then this is a "worthless" edge between these two loops.
		 */
		if (*eu_r->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    eu_r->up.lu_p->up.magic_p == lu->up.magic_p &&
		    eu->eumate_p->radial_p == eu->radial_p->eumate_p &&
		    eu_r->up.lu_p != lu) {

		    	if( eu_r->up.lu_p->orientation != lu->orientation &&
		    	   (lu->orientation != OT_SAME ||
			    eu_r->up.lu_p->orientation != OT_OPPOSITE) )  {
				/* Does not meet requirements of nmg_jl(),
				 * skip it.
				 */
			    	eu = BU_LIST_PNEXT(edgeuse, eu);
				continue;
			}

		    	/* save a pointer to where we've already been
		    	 * so that when eu becomes an invalid pointer, we
		    	 * still know where to pick up from.
		    	 */
		    	tmpeu = BU_LIST_PLAST(edgeuse, eu);

			nmg_jl(lu, eu);

		    	/* Since all the new edges will have been appended
		    	 * after tmpeu, we can pick up processing with the
		    	 * edgeuse immediately after tmpeu
		    	 */
		    	eu = tmpeu;

		    	if (rt_g.NMG_debug &(DEBUG_PLOTEM|DEBUG_PL_ANIM) &&
			    *lu->up.magic_p == NMG_FACEUSE_MAGIC ) {
		    	    	static int fno=0;

				nmg_pl_2fu("After_joinloop%d.pl", fno++,
				    lu->up.fu_p, lu->up.fu_p->fumate_p, 0);
					
		    	}
		}
		eu = BU_LIST_PNEXT(edgeuse, eu);
	}
}


/*
 *			N M G _ K I L L _ S N A K E S
 *
 *  Removes "snake" or "disconnected crack" edges from loopuse.
 *
 *  Returns -
 *	0	If all went well
 *	1	If the loopuse is now empty and needs to be killed.
 */
int
nmg_kill_snakes(struct loopuse *lu)
{
	struct edgeuse *eu, *eu_r;
	struct vertexuse *vu;
	struct vertex *v;

	NMG_CK_LOOPUSE(lu);
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_kill_snakes(lu=x%x)\n", lu);
	}
	if (BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC)
		return 0;

	eu = BU_LIST_FIRST(edgeuse, &lu->down_hd);
	while (BU_LIST_NOT_HEAD(eu, &lu->down_hd) ) {

		NMG_CK_EDGEUSE(eu);

		eu_r = eu->radial_p;
		NMG_CK_EDGEUSE(eu_r);

		/* if the radial edge is a part of the same loop, and
		 * this edge is not used by anyplace else, and the radial edge
		 * is also the next edge, this MAY be the tail of a snake!
		 */

		if (*eu_r->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    eu_r->up.lu_p == eu->up.lu_p &&
		    eu->eumate_p->radial_p == eu->radial_p->eumate_p &&
		    BU_LIST_PNEXT_CIRC(edgeuse, eu) == eu_r) {

		    	/* if there are no other uses of the vertex
		    	 * between these two edgeuses, then this is
		    	 * indeed the tail of a snake
		    	 */
			v = eu->eumate_p->vu_p->v_p;
			vu = BU_LIST_FIRST(vertexuse, &v->vu_hd);
			while (BU_LIST_NOT_HEAD(vu, &v->vu_hd) &&
			      (vu->up.eu_p == eu->eumate_p ||
			       vu->up.eu_p == eu_r) )
				vu = BU_LIST_PNEXT(vertexuse, vu);

			if (! BU_LIST_NOT_HEAD(vu, &v->vu_hd) ) {
				/* this is the tail of a snake! */
				(void)nmg_keu(eu_r);
				if( nmg_keu(eu) )  return 1; /* kill lu */
				if( BU_LIST_IS_EMPTY( &lu->down_hd ) )
					return 1;	/* loopuse is empty */
				eu = BU_LIST_FIRST(edgeuse, &lu->down_hd);

			    	if (rt_g.NMG_debug &(DEBUG_PLOTEM|DEBUG_PL_ANIM) &&
				    *lu->up.magic_p == NMG_FACEUSE_MAGIC ) {
			    	    	static int fno=0;

					nmg_pl_2fu("After_joinloop%d.pl", fno++,
					    lu->up.fu_p, lu->up.fu_p->fumate_p, 0);

			    	}


			} else
				eu = BU_LIST_PNEXT(edgeuse, eu);
		} else
			eu = BU_LIST_PNEXT(edgeuse, eu);
	}
	return 0;	/* All is well, loop still has edges */
}

/*
 *			N M G _ M V _ L U _ B E T W E E N _ S H E L L S
 *
 *  Move a wire-loopuse from one shell to another.
 *  Note that this routine can not be used on loops in faces.
 */
void
nmg_mv_lu_between_shells(struct shell *dest, register struct shell *src, register struct loopuse *lu)
{
	register struct loopuse	*lumate;

	NMG_CK_LOOPUSE(lu);
	lumate = lu->lumate_p;
	NMG_CK_LOOPUSE(lumate);

	if( lu->up.s_p != src )  {
		bu_log("nmg_mv_lu_between_shells(dest=x%x, src=x%x, lu=x%x), lu->up.s_p=x%x isn't source shell\n",
			dest, src, lu, lu->up.s_p );
		rt_bomb("lu->up.s_p isn't source shell\n");
	}
	if( lumate->up.s_p != src )  {
		bu_log("nmg_mv_lu_between_shells(dest=x%x, src=x%x, lu=x%x), lumate->up.s_p=x%x isn't source shell\n",
			dest, src, lu, lumate->up.s_p );
		rt_bomb("lumate->up.s_p isn't source shell\n");
	}

	/* Remove lu from src shell */
	BU_LIST_DEQUEUE( &lu->l );
	if( BU_LIST_IS_EMPTY( &src->lu_hd ) )  {
		/* This was the last lu in the list */
		bu_log("nmg_mv_lu_between_shells(dest=x%x, src=x%x, lu=x%x), lumate=x%x not in src shell\n",
			dest, src, lu, lumate );
		rt_bomb("src shell emptied before finding lumate\n");
	}

	/* Remove lumate from src shell */
	BU_LIST_DEQUEUE( &lumate->l );

	/* Add lu and lumate to dest shell */
	BU_LIST_APPEND( &dest->lu_hd, &lu->l );
	BU_LIST_APPEND( &lu->l, &lumate->l );

	lu->up.s_p = dest;
	lumate->up.s_p = dest;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_mv_lu_between_shells(dest=x%x, src=x%x, lu=x%x)\n",
			dest , src , lu);
	}
}

/*
 *			N M G _ M O V E L T O F
 *
 *	move first pair of shell wire loopuses out to become a genuine loop
 *	in an existing face.
 * XXX This routine is not used anywhere, and may not work.
 */
void nmg_moveltof(struct faceuse *fu, struct shell *s)
{
	struct loopuse	*lu1, *lu2;

	NMG_CK_SHELL(s);
	NMG_CK_FACEUSE(fu);
	if (fu->s_p != s) {
		bu_log("nmg_moveltof() in %s at %d. Cannot move loop to face in another shell\n",
		    __FILE__, __LINE__);
	}
	lu1 = BU_LIST_FIRST(loopuse, &s->lu_hd);
	NMG_CK_LOOPUSE(lu1);
	BU_LIST_DEQUEUE( &lu1->l );

	lu2 = BU_LIST_FIRST(loopuse, &s->lu_hd);
	NMG_CK_LOOPUSE(lu2);
	BU_LIST_DEQUEUE( &lu2->l );

	BU_LIST_APPEND( &fu->lu_hd, &lu1->l );
	BU_LIST_APPEND( &fu->fumate_p->lu_hd, &lu2->l );
	/* XXX What about loopuse "up" pointers? */

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_moveltof(fu=x%x, s=x%x)\n",
			fu , s );
	}
}

/*
 *			N M G _ D U P _ L O O P
 *
 *  A support routine for nmg_dup_face()
 *
 *  trans_tbl may be NULL.
 */
struct loopuse *
nmg_dup_loop(struct loopuse *lu, long int *parent, long int **trans_tbl)
                   
    	        		/* fu or shell ptr */
    	            
{
	struct loopuse *new_lu = (struct loopuse *)NULL;
	struct vertexuse *new_vu = (struct vertexuse *)NULL;
	struct vertexuse *old_vu = (struct vertexuse *)NULL;
	struct vertex *old_v = (struct vertex *)NULL;
	struct vertex	*new_v;
	struct edgeuse *new_eu = (struct edgeuse *)NULL;
	struct edgeuse *tbl_eu = (struct edgeuse *)NULL;
	struct edgeuse *eu = (struct edgeuse *)NULL;

	NMG_CK_LOOPUSE(lu);

	/* if loop is just a vertex, that's simple to duplicate */
	if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
		old_vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
		old_v = old_vu->v_p;

		/* Obtain new duplicate of old vertex.  May be null 1st time. */
		if( trans_tbl )
			new_v = NMG_INDEX_GETP(vertex, trans_tbl, old_v);
		else
			new_v = (struct vertex *)NULL;
		new_lu = nmg_mlv(parent, new_v, lu->orientation);
		if (new_lu->orientation != lu->orientation) {
			bu_log("%s %d: I asked for a %s loop not a %s loop.\n",
				__FILE__, __LINE__,
				nmg_orientation(lu->orientation),
				nmg_orientation(new_lu->orientation));
			rt_bomb("bombing\n");
		}
		if( new_v )  {
			/* the new vertex already exists in the new model */
			bu_log("nmg_dup_loop() existing vertex in new model\n");
			return (struct loopuse *)NULL;
		}
		/* nmg_mlv made a new vertex */
		bu_log("nmg_dup_loop() new vertex in new model\n");

		new_vu = BU_LIST_FIRST(vertexuse, &new_lu->down_hd);
		new_v = new_vu->v_p;
		/* Give old_v entry a pointer to new_v */
		if( trans_tbl )
			NMG_INDEX_ASSIGN( trans_tbl, old_v, (long *)new_v );
		if (old_v->vg_p) {
			/* Build a different vertex_g with same coordinates */
			nmg_vertex_gv(new_v, old_v->vg_p->coord);
		}
		if (rt_g.NMG_debug & DEBUG_BASIC)  {
			bu_log("nmg_dup_loop(lu=x%x, parent=x%x, trans_tbl=x%x) new_lu=x%x\n",
				lu , parent , trans_tbl , new_lu );
		}
		return new_lu;
	}

	/* This loop is an edge-loop.  This is a little more work
	 * First order of business is to duplicate the vertex/edge makeup.
	 */
	for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {

		NMG_CK_EDGEUSE(eu);
		NMG_CK_VERTEXUSE(eu->vu_p);
		NMG_CK_VERTEX(eu->vu_p->v_p);
		old_v = eu->vu_p->v_p;

		/* Obtain new duplicate of old vertex.  May be null 1st time. */
		if( trans_tbl )
			new_v = NMG_INDEX_GETP(vertex, trans_tbl, old_v);
		else
			new_v = (struct vertex *)NULL;

		if (new_lu == (struct loopuse *)NULL) {
			/* this is the first edge in the new loop */
			new_lu = nmg_mlv(parent, new_v, lu->orientation);
			if (new_lu->orientation != lu->orientation) {
				bu_log("%s %d: I asked for a %s loop not a %s loop.\n",
					__FILE__, __LINE__,
					nmg_orientation(lu->orientation),
					nmg_orientation(new_lu->orientation));
				rt_bomb("bombing\n");
			}

			new_vu = BU_LIST_FIRST(vertexuse, &new_lu->down_hd);

			NMG_CK_VERTEXUSE(new_vu);
			NMG_CK_VERTEX(new_vu->v_p);

			if( !new_v && trans_tbl )  {
				/* Give old_v entry a pointer to new_v */
				NMG_INDEX_ASSIGN( trans_tbl, old_v,
					(long *)new_vu->v_p );
			}
			new_v = new_vu->v_p;

			new_eu = nmg_meonvu(new_vu);
		} else {
			/* not the first edge in new loop */
			new_eu = BU_LIST_LAST(edgeuse, &new_lu->down_hd);
			NMG_CK_EDGEUSE(new_eu);

			new_eu = nmg_eusplit(new_v, new_eu, 0);
			new_vu = new_eu->vu_p;

			if( !new_v && trans_tbl )  {
				/* Give old_v entry a pointer to new_v */
				NMG_INDEX_ASSIGN( trans_tbl, old_v,
					(long *)new_vu->v_p );
			}
			new_v = new_vu->v_p;
		}
		/* Build a different vertex_g with same coordinates */
		if (old_v->vg_p) {
			NMG_CK_VERTEX_G(old_v->vg_p);
			nmg_vertex_gv(new_v, old_v->vg_p->coord);
		}

		/* Prepare to glue edges */
		/* Use old_e as subscript, to get 1st new_eu (for new_e) */
		/* Use old_eu to get mapped new_eu */
		if( trans_tbl )
			tbl_eu = NMG_INDEX_GETP(edgeuse, trans_tbl, eu->e_p );
		else
			tbl_eu = (struct edgeuse *)NULL;
		if( !tbl_eu && trans_tbl )  {
			/* Establishes map from old edge to new edge(+use) */
			NMG_INDEX_ASSIGN( trans_tbl, eu->e_p, (long *)new_eu );
		}
		if( trans_tbl )
			NMG_INDEX_ASSIGN( trans_tbl, eu, (long *)new_eu );
	}
#if 0
/* XXX untested */
	if( trans_tbl )
	{
		/* All vertex structs are shared.  Make shared edges be shared */
		for(BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
			/* Use old_e as subscript, to get 1st new_eu (for new_e) */
			/* Use old_eu to get mapped new_eu */
			tbl_eu = NMG_INDEX_GETP(edgeuse, trans_tbl, eu->e_p );
			new_eu = NMG_INDEX_GETP(edgeuse, trans_tbl, eu );
			if( tbl_eu->e_p == new_eu->e_p )  continue;

			/* new_eu isn't sharing edge with tbl_eu, join them */
			/* XXX Is radial relationship preserved (enough)? */
			nmg_je( tbl_eu, new_eu );
		}
	}
#endif

	/* Now that we've got all the right topology created and the
	 * vertex geometries are in place we can create the edge geometries.
	 * XXX This ought to be optional, as most callers will immediately
	 * XXX change the vertex geometry anyway (e.g. by extrusion dist).
	 */
	for(BU_LIST_FOR(new_eu, edgeuse, &new_lu->down_hd)) {
		NMG_CK_EDGEUSE(new_eu);
		NMG_CK_EDGE(new_eu->e_p);
		if( new_eu->g.magic_p )  continue;
		nmg_edge_g(new_eu);
	}

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_dup_loop(lu=x%x(%s), parent=x%x, trans_tbl=x%x) new_lu=x%x(%s)\n",
			lu, nmg_orientation(lu->orientation),
			parent , trans_tbl , new_lu,
			nmg_orientation(new_lu->orientation) );
	}
	return (new_lu);
}

/*
 *			N M G _ S E T _ L U _ O R I E N T A T I O N
 *
 *  Set this loopuse and mate's orientation to be SAME or OPPOSITE
 *  from the orientation of the faceuse they each reside in.
 */
void
nmg_set_lu_orientation(struct loopuse *lu, int is_opposite)
{
	NMG_CK_LOOPUSE(lu);
	NMG_CK_LOOPUSE(lu->lumate_p);
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_set_lu_orientation(lu=x%x, %s)\n",
			lu, is_opposite?"OT_OPPOSITE":"OT_SAME");
	}
	if( is_opposite )  {
		/* Interior (crack) loop */
		lu->orientation = OT_OPPOSITE;
		lu->lumate_p->orientation = OT_OPPOSITE;
	} else {
		/* Exterior loop */
		lu->orientation = OT_SAME;
		lu->lumate_p->orientation = OT_SAME;
	}
}

/*
 *			N M G _ L U _ R E O R I E N T
 *
 *  Based upon a geometric calculation, reorient a loop and it's mate,
 *  if the stored orientation differs from the geometric one.
 *
 *  Note that the loopuse and it's mate have the same orientation;
 *  it's the faceuses that are normalward and anti-normalward.
 *  The loopuses either both agree with their faceuse, or both differ.
 */
void
nmg_lu_reorient(struct loopuse *lu)
{
	struct faceuse	*fu;
	int	geom_orient;
	plane_t	norm;
	plane_t lu_pl;

	NMG_CK_LOOPUSE(lu);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_lu_reorient(lu=x%x)\n", lu);
	}

	/* Don't harm the OT_BOOLPLACE self-loop marker vertices */
	if( lu->orientation == OT_BOOLPLACE &&
	    BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )
		return;

	fu = lu->up.fu_p;
	NMG_CK_FACEUSE(fu);
	if( fu->orientation != OT_SAME )  {
		lu = lu->lumate_p;
		NMG_CK_LOOPUSE(lu);
		fu = lu->up.fu_p;
		NMG_CK_FACEUSE(fu);
		if (rt_g.NMG_debug & DEBUG_BASIC)
			bu_log("nmg_lu_reorient() selecting other fu=x%x, lu=x%x\n", fu, lu);
		if( fu->orientation != OT_SAME )
			rt_bomb("nmg_lu_reorient() no OT_SAME fu?\n");
	}


	/* Get OT_SAME faceuse's normal */
	NMG_GET_FU_PLANE( norm, fu );
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		PLPRINT("\tfu peqn", norm);
	}

	nmg_loop_plane_newell( lu, lu_pl );

	if( lu->orientation == OT_OPPOSITE )
		HREVERSE( lu_pl, lu_pl );

	if( VDOT( lu_pl, norm ) < 0.0 )
		geom_orient = OT_OPPOSITE;
	else
		geom_orient = OT_SAME;

	if( lu->orientation == geom_orient )  return;
	if( rt_g.NMG_debug & DEBUG_BASIC )  {
		bu_log("nmg_lu_reorient(x%x):  changing orientation: %s to %s\n",
			lu, nmg_orientation(lu->orientation),
			nmg_orientation(geom_orient) );
	}

	lu->orientation = geom_orient;
	lu->lumate_p->orientation = geom_orient;
}

/************************************************************************
 *									*
 *				EDGE Routines				*
 *									*
 ************************************************************************/

/*
 *			N M G _ E U S P L I T
 *
 *	Split an edgeuse by inserting a vertex into middle of the edgeuse.
 *
 *	Make a new edge, and a vertex.  If v is non-null it is taken as a
 *	pointer to an existing vertex to use as the start of the new edge.
 *	If v is null, then a new vertex is created for the begining of the
 *	new edge.
 *
 *	In either case, the new edge will exist as the "next" edgeuse after
 *	the edgeuse passed as a parameter.
 *
 *	Upon return, the new edgeuses (eu1 and mate) will not refer to any
 *	geometry, unless argument "share_geom" was non-zero.
 *
 *  Explicit return -
 *	edgeuse of new edge "eu1", starting at V and going to B.
 *
 *  List on entry -
 *
 *		       oldeu
 *		  .------------->
 *		 /
 *		A =============== B (edge)
 *				 /
 *		  <-------------.
 *		      oldeumate
 *
 *  List on return -
 *
 *		     oldeu(cw)    eu1
 *		    .------->   .----->
 *		   /           /
 *	   (edge) A ========= V ~~~~~~~ B (new edge)
 *			     /         /
 *		    <-------.   <-----.
 *		       mate	 mate
 */
struct edgeuse *
nmg_eusplit(struct vertex *v, struct edgeuse *oldeu, int share_geom)
{
	struct edgeuse	*eu1,
			*eu2,
			*oldeumate;
	struct shell *s = NULL;
	struct loopuse	*lu;

	NMG_CK_EDGEUSE(oldeu);
	if (v) {
		NMG_CK_VERTEX(v);
	}
	oldeumate = oldeu->eumate_p;
	NMG_CK_EDGEUSE( oldeumate );

	/* if this edge has uses other than this edge and its mate, we must
	 * separate these two edgeuses from the existing edge, and create
	 * a new edge for them.  Then we can insert a new vertex in this
	 * new edge without fear of damaging some other object.
	 */
	if (oldeu->radial_p != oldeumate)
		nmg_unglueedge(oldeu);

	if (*oldeu->up.magic_p == NMG_SHELL_MAGIC) {
		s = oldeu->up.s_p;
		NMG_CK_SHELL(s);

		/*
		 *  Make an edge from the new vertex ("V") to vertex at
		 *  other end of the edge given ("B").
		 *  The new vertex "V" may be NULL, which will cause the
		 *  shell's lone vertex to be used, or a new one obtained.
		 *  New edges will be placed at head of shell's edge list.
		 */
		eu1 = nmg_me(v, oldeumate->vu_p->v_p, s);
		eu2 = eu1->eumate_p;

		/*
		 *  The situation is now:
		 *
		 *      eu1			       oldeu
		 *  .----------->		  .------------->
		 * /				 /
		 *V ~~~~~~~~~~~~~ B (new edge)	A =============== B (edge)
		 *		 /				 /
		 *  <-----------.		  <-------------.
		 *      eu2			      oldeumate
		 */

		/* Make oldeumate start at "V", not "B" */
		nmg_movevu(oldeumate->vu_p, eu1->vu_p->v_p);

		/*
		 *  Enforce rigid ordering in shell's edge list:
		 *	oldeu, oldeumate, eu1, eu2
		 *  This is to keep edges & mates "close to each other".
		 */
		if( BU_LIST_PNEXT(edgeuse, oldeu) != oldeumate )  {
			BU_LIST_DEQUEUE( &oldeumate->l );
			BU_LIST_APPEND( &oldeu->l, &oldeumate->l );
		}
		BU_LIST_DEQUEUE( &eu1->l );
		BU_LIST_DEQUEUE( &eu2->l );
		BU_LIST_APPEND( &oldeumate->l, &eu1->l );
		BU_LIST_APPEND( &eu1->l, &eu2->l );

		/*
		 *	     oldeu(cw)    eu1
		 *	    .------->   .----->
		 *	   /           /
		 * (edge) A ========= V ~~~~~~~ B (new edge)
		 *		     /         /
		 *	    <-------.   <-----.
		 *	    oldeumate     eu2
		 */
		if( share_geom )  {
			/* Make eu1 share geom with oldeu, eu2 with oldeumate */
			nmg_use_edge_g( eu1, oldeu->g.magic_p );
			nmg_use_edge_g( eu2, oldeumate->g.magic_p );
		} else {
			/* Make eu2 use same geometry as oldeu */
			nmg_use_edge_g( eu2, oldeu->g.magic_p );
			/* Now release geometry from oldeumate;  new edge has no geom */
			BU_LIST_DEQUEUE( &oldeumate->l2 );
			nmg_keg( oldeumate );
			BU_LIST_DEQUEUE( &eu1->l2 );
			nmg_keg( eu1 );
			BU_LIST_INIT( &oldeumate->l2 );
			BU_LIST_INIT( &eu1->l2 );
			oldeumate->l2.magic = NMG_EDGEUSE2_MAGIC;
			eu1->l2.magic = NMG_EDGEUSE2_MAGIC;
		}
		goto out;
	}
	else if (*oldeu->up.magic_p != NMG_LOOPUSE_MAGIC) {
		bu_log("nmg_eusplit() in %s at %d invalid edgeuse parent\n",
			__FILE__, __LINE__);
		rt_bomb("nmg_eusplit\n");
	}

	/* now we know we are in a loop */

	lu = oldeu->up.lu_p;
	NMG_CK_LOOPUSE(lu);

	/* get a parent shell pointer so we can make a new edge */
	if (*lu->up.magic_p == NMG_SHELL_MAGIC)
		s = lu->up.s_p;
	else if (*lu->up.magic_p == NMG_FACEUSE_MAGIC)
		s = lu->up.fu_p->s_p;
	else
		rt_bomb("nmg_eusplit() bad lu->up\n");
	NMG_CK_SHELL(s);

	/* Make a new wire edge in the shell */
	if (v) {
		/* An edge on the single vertex "V" */
		eu1 = nmg_me(v, v, s);
		eu2 = eu1->eumate_p;
	} else {
		/* Form a wire edge between two new vertices */
		eu1 = nmg_me((struct vertex *)NULL, (struct vertex *)NULL, s);
		eu2 = eu1->eumate_p;
		/* Make both ends of edge use same vertex.
		 * The second vertex is freed automaticly.
		 */
		nmg_movevu(eu2->vu_p, eu1->vu_p->v_p);
	}

	/*
	 *  The current situation is now:
	 *
	 *	      eu1				       oldeu
	 *	  .------------->			  .------------->
	 *	 /					 /
	 *	V ~~~~~~~~~~~~~~~ V (new edge)		A =============== B (edge)
	 *			 /					 /
	 *	  <-------------.			  <-------------.
	 *	      eu2				      oldeumate
	 *
	 *  Goals:
	 *  eu1 will become the mate to oldeumate on the existing edge.
	 *  eu2 will become the mate of oldeu on the new edge.
	 */
	BU_LIST_DEQUEUE( &eu1->l );
	BU_LIST_DEQUEUE( &eu2->l );
	BU_LIST_APPEND( &oldeu->l, &eu1->l );
	BU_LIST_APPEND( &oldeumate->l, &eu2->l );

	/*
	 *  The situation is now:
	 *
	 *		       oldeu      eu1			>>>loop>>>
	 *		    .------->   .----->
	 *		   /           /
	 *	   (edge) A ========= V ~~~~~~~ B (new edge)
	 *			     /         /
	 *		    <-------.   <-----.	
	 *		       eu2      oldeumate		<<<loop<<<
	 */

	/* Copy parentage (loop affiliation) and orientation */
	eu1->up.magic_p = oldeu->up.magic_p;
	eu1->orientation = oldeu->orientation;

	eu2->up.magic_p = oldeumate->up.magic_p;
	eu2->orientation = oldeumate->orientation;

	/* Build mate relationship */
	eu1->eumate_p = oldeumate;
	oldeumate->eumate_p = eu1;
	eu2->eumate_p = oldeu;
	oldeu->eumate_p = eu2;

	/*  Build radial relationship.
	 *  Simple only because this edge has no other uses.
	 */
	eu1->radial_p = oldeumate;
	oldeumate->radial_p = eu1;
	eu2->radial_p = oldeu;
	oldeu->radial_p = eu2;

	/* Associate oldeumate with new edge, and eu2 with old edge. */
	oldeumate->e_p = eu1->e_p;
	eu2->e_p = oldeu->e_p;

	/* Ensure that edge points up to one of the proper edgeuses. */
	oldeumate->e_p->eu_p = oldeumate;
	eu2->e_p->eu_p = eu2;

	if( share_geom )  {
		/* Make eu1 share same geometry as oldeu */
		nmg_use_edge_g( eu1, oldeu->g.magic_p );
		/* Make eu2 share same geometry as oldeumate */
		nmg_use_edge_g( eu2, oldeumate->g.magic_p );
	} else {
		/* Make eu2 use same geometry as oldeu */
		nmg_use_edge_g( eu2, oldeu->g.magic_p );
		/* Now release geometry from oldeumate;  new edge has no geom */
		BU_LIST_DEQUEUE( &oldeumate->l2 );
		nmg_keg( oldeumate );
		BU_LIST_DEQUEUE( &eu1->l2 );
		nmg_keg( eu1 );
		BU_LIST_INIT( &oldeumate->l2 );
		BU_LIST_INIT( &eu1->l2 );
		oldeumate->l2.magic = NMG_EDGEUSE2_MAGIC;
		eu1->l2.magic = NMG_EDGEUSE2_MAGIC;
	}
	if( oldeu->g.magic_p != oldeu->eumate_p->g.magic_p )  rt_bomb("nmg_eusplit() unshared geom\n");

out:
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_eusplit(v=x%x, eu=x%x, share=%d) new_eu=x%x, mate=x%x\n",
			v, oldeu, share_geom,
			eu1, eu1->eumate_p );
	}
	return(eu1);
}

/*
 *			N M G _ E S P L I T
 *
 *	Split an edge by inserting a vertex into middle of *all* of the
 *	uses of this edge, and combine the new edgeuses together onto the
 *	new edge.
 *	A more powerful version of nmg_eusplit(), which does only one use.
 *
 *	Makes a new edge, and a vertex.  If v is non-null it is taken as a
 *	pointer to an existing vertex to use as the start of the new edge.
 *	If v is null, then a new vertex is created for the begining of the
 *	new edge.
 *
 *	In either case, the new edgeuse will exist as the "next" edgeuse
 *	after the edgeuse passed as a parameter.
 *
 *	Note that eu->e_p changes value upon return, because the old
 *	edge is incrementally replaced by two new ones.
 *
 *	Geometry will be preserved on eu and it's mates (by nmg_eusplit),
 *	if any.  ret_eu and mates will share that geometry if share_geom
 *	is set non-zero, otherwise they will have null geom pointers.
 *
 *  Explicit return -
 *	Pointer to the edgeuse which starts at the newly created
 *	vertex (V), and runs to B.
 *
 *  Implicit returns -
 *	ret_eu->vu_p->v_p gives the new vertex ("v", if non-null), and
 *	ret_eu->e_p is the new edge that runs from V to B.
 *
 *	The new vertex created will also be eu->eumate_p->vu_p->v_p.
 *
 *  Edge on entry -
 *
 *			eu
 *		  .------------->
 *		 /
 *		A =============== B (edge)
 *				 /
 *		  <-------------.
 *		    eu->eumate_p
 *
 *  Edge on return -
 *
 *			eu	  ret_eu
 *		    .------->   .--------->
 *		   /           /
 *	(newedge) A ========= V ~~~~~~~~~~~ B (new edge)
 *			     /             /
 *		    <-------.   <---------.
 *
 *  Note: to replicate the behavior of this routine in BRL-CAD Relase 4.0,
 *  call with share_geom=0.
 */
struct edgeuse *
nmg_esplit(struct vertex *v, struct edgeuse *eu, int share_geom)
             	   		/* New vertex, to go in middle */
              	    
   		           
{
	struct edge	*e;	/* eu->e_p */
	struct edgeuse	*teuX,	/* radial edgeuse of eu */
			*teuY,	/* new edgeuse (next of teuX) */
			*neu1, *neu2; /* new (split) edgeuses */
	int 		notdone=1;
	struct vertex	*vA, *vB;	/* start and end of eu */

	neu1 = neu2 = (struct edgeuse *)NULL;

	NMG_CK_EDGEUSE(eu);
	e = eu->e_p;
	NMG_CK_EDGE(e);

	NMG_CK_VERTEXUSE(eu->vu_p);
	vA = eu->vu_p->v_p;
	NMG_CK_VERTEX(vA);

	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	vB = eu->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX(vB);

	if( v && ( v == vA || v == vB ) )  {
		bu_log("WARNING: nmg_esplit(v=x%x) vertex is already an edge vertex\n", v);
		rt_bomb("nmg_esplit() new vertex is already an edge vertex\n");
	}

	/* one at a time, we peel out & split an edgeuse pair of this edge.
	 * when we split an edge that didn't need to be peeled out, we know
	 * we've split the last edge
	 */
	do {
		/* Peel two temporary edgeuses off the original edge */
		teuX = eu->radial_p;
		/* teuX runs from vA to vB */
		teuY = nmg_eusplit(v, teuX, share_geom);
		/* Now, teuX runs from vA to v, teuY runs from v to vB */
		NMG_CK_EDGEUSE(teuX);
		NMG_CK_EDGEUSE(teuY);
		NMG_TEST_EDGEUSE(teuX);
		NMG_TEST_EDGEUSE(teuY);
		
		if (!v)  {
			/* If "v" parameter was NULL and this is the
			 * first time through, take note of "v" where
			 * "e" was just split at.
			 */
			v = teuY->vu_p->v_p;
			NMG_CK_VERTEX(v);
		}

		if (teuY->e_p == e || teuX->e_p == e) notdone = 0;
		
		/*  Are the two edgeuses going in same or opposite directions?
		 *  Join the newly created temporary edge (teuX, teuY)
		 *  with the new permanant edge (neu1, neu2).
		 *  On first pass, just take note of the new edge & edgeuses.
		 */
		NMG_CK_VERTEX(teuX->vu_p->v_p);
		if (teuX->vu_p->v_p == vA) {
			if (neu1) {
				nmg_je(neu1, teuX);
				nmg_je(neu2, teuY);
			}
			neu1 = teuX->eumate_p;
			neu2 = teuY->eumate_p;
		} else if (teuX->vu_p->v_p == vB) {
			if (neu1) {
				nmg_je(neu2, teuX);
				nmg_je(neu1, teuY);
			}
			neu2 = teuX->eumate_p;
			neu1 = teuY->eumate_p;
		} else {
			bu_log("nmg_esplit(v=x%x, e=x%x)\n", v, e);
			bu_log("nmg_esplit: teuX->vu_p->v_p=x%x, vA=x%x, vB=x%x\n", teuX->vu_p->v_p, vA, vB );
			rt_bomb("nmg_esplit() teuX->vu_p->v_p is neither vA nor vB\n");
		}
	} while (notdone);
	/* Here, "e" pointer is invalid -- it no longer exists */

	/* Find an edgeuse that runs from v to vB */
	if( neu2->vu_p->v_p == v && neu2->eumate_p->vu_p->v_p == vB )  {
		if (rt_g.NMG_debug & DEBUG_BASIC)  {
			bu_log("nmg_esplit(v=x%x, eu=x%x, share=%d) neu2=x%x\n",
				v, eu, share_geom, neu2);
		}
		return neu2;
	}
	else if( neu1->vu_p->v_p == v && neu1->eumate_p->vu_p->v_p == vB )  {
		if (rt_g.NMG_debug & DEBUG_BASIC)  {
			bu_log("nmg_esplit(v=x%x, eu=x%x, share=%d) neu1=x%x\n",
				v, eu, share_geom, neu1);
		}
		return neu1;
	}

	rt_bomb("nmg_esplit() unable to find eu starting at new v\n");
	/* NOTREACHED */
	return (struct edgeuse *)NULL;
}

/*
 *			N M G _ E B R E A K
 *
 *  Like nmg_esplit(), split an edge into two parts.
 *  Ensure that both sets of edgeuses share the original edgeuse geometry.
 *  If the original edge had no edge geometry, then none is created here.
 *
 *  This is a simple compatability interface to nmg_esplit().
 *  The return is the return of nmg_esplit().
 */
struct edgeuse *
nmg_ebreak(struct vertex *v, struct edgeuse *eu)
             	   			/* May be NULL */
              	    
{
	struct edgeuse	*new_eu;

	NMG_CK_EDGEUSE(eu);
	if( eu->g.magic_p )  {
		NMG_CK_EDGE_G_LSEG(eu->g.lseg_p);
	}

	new_eu = nmg_esplit(v, eu, 1);	/* Do the hard work */
	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGEUSE(new_eu);

	if( eu->e_p == new_eu->e_p )  rt_bomb("nmb_ebreak() same edges?\n");

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_ebreak( v=x%x, eu=x%x ) new_eu=x%x\n",
			v, eu, new_eu);
	}
	return new_eu;
}

/*
 *			N M G _ E B R E A K E R
 *
 *  Like nmg_ebreak(), but with edge radial sorting when sharing occurs.
 *
 *  Use nmg_ebreak() to break an existing edge on a vertex, preserving edge
 *  geometry on both new edges.
 *  If the edge was broken on an existing vertex,
 *  search both old and new edgeuses to see if they need to be joined
 *  with an existing edgeuse that shared the same vertices.
 */
struct edgeuse *
nmg_ebreaker(struct vertex *v, struct edgeuse *eu, const struct bn_tol *tol)
             		   			/* May be NULL */
              		    
                   	     
{
	struct edgeuse	*new_eu;
	struct edgeuse	*oeu;

	NMG_CK_EDGEUSE(eu);
	BN_CK_TOL(tol);

nmg_eu_radial_check( eu, nmg_find_s_of_eu(eu), tol );
	new_eu = nmg_ebreak(v, eu);
	if( v )  {
		/*
		 *  This edge was broken on an existing vertex.
		 *  Search the whole model for other existing edges
		 *  that match the newly created edge fragments.
		 */
		for(;;)  {
			oeu = nmg_find_e( eu->vu_p->v_p,
				eu->eumate_p->vu_p->v_p,
				(struct shell *)NULL, eu->e_p );
			if( !oeu ) break;
			if (rt_g.NMG_debug & DEBUG_BASIC)  {
				bu_log("nmg_ebreaker() joining eu=x%x to oeu=x%x\n",
					eu, oeu );
			}
			nmg_radial_join_eu( eu, oeu, tol );
		}

		for(;;)  {
			oeu = nmg_find_e( new_eu->vu_p->v_p,
				new_eu->eumate_p->vu_p->v_p,
				(struct shell *)NULL, new_eu->e_p );
			if( !oeu )  break;
			if (rt_g.NMG_debug & DEBUG_BASIC)  {
				bu_log("nmg_ebreaker() joining new_eu=x%x to oeu=x%x\n",
					new_eu, oeu );
			}
			nmg_radial_join_eu( new_eu, oeu, tol );
		}
/* XXX Will this catch it? */
nmg_eu_radial_check( eu, nmg_find_s_of_eu(eu), tol );
nmg_eu_radial_check( new_eu, nmg_find_s_of_eu(new_eu), tol );
if( nmg_check_radial( eu, tol ) ) bu_log("ERROR ebreaker eu=x%x bad\n", eu);
if( nmg_check_radial( new_eu, tol ) ) bu_log("ERROR ebreaker new_eu=x%x bad\n", new_eu);
	}
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_ebreaker( v=x%x, eu=x%x ) new_eu=x%x\n", v, eu, new_eu);
	}
	return new_eu;
}

/*
 *			N M G _ E 2 B R E A K
 *
 *  Given two edges that are known to intersect someplace other than
 *  at any of their endpoints, break both of them and
 *  insert a shared vertex.
 *  Return a pointer to the new vertex.
 */
struct vertex *
nmg_e2break(struct edgeuse *eu1, struct edgeuse *eu2)
{
	struct vertex		*v;
	struct edgeuse		*new_eu;

	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);

	new_eu = nmg_ebreak( NULL, eu1 );
	v = new_eu->vu_p->v_p;
	NMG_CK_VERTEX(v);
	(void)nmg_ebreak( v, eu2 );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_e2break( eu1=x%x, eu2=x%x ) v=x%x\n", eu1, eu2, v);
	}
	return v;
}
/*
 *			N M G _ U N B R E A K _ E D G E
 *
 *  Undoes the effect of an unwanted nmg_ebreak().
 *
 *  Eliminate the vertex between this edgeuse and the next edge,
 *  on all edgeuses radial to this edgeuse's edge.
 *  The edge geometry must be shared, and all uses of the vertex
 *  to be disposed of must originate from this edge pair.
 *  Also, the "non-B" ends of all edgeuses around e1 and e2 must
 *  terminate at either A or B.
 *
 *  XXX for t-NURBS, this should probably be re-stated as
 *  saying that all the edgeuses must share the same 2 edges, and that
 *  every eu1 needs to share geom with it's corresponding eu2,
 *  and similarly for the two mates.
 *
 *		     eu1          eu2
 *		*----------->*----------->*
 *		A.....e1.....B.....e2.....C
 *		*<-----------*<-----------*
 *		    eu1mate      eu2mate
 *
 *  If successful, the vertex B, the edge e2, and all the edgeuses
 *  radial to eu2 (including eu2) will have all been killed.
 *  The radial ordering around e1 will not change.
 *
 *		     eu1
 *		*------------------------>*
 *		A.....e1..................C
 *		*<------------------------*
 *		    eu1mate
 *
 *
 *  No new topology structures are created by this operation.
 *
 *  Returns -
 *	0	OK, edge unbroken
 *	<0	failure, nothing changed
 */
int
nmg_unbreak_edge(struct edgeuse *eu1_first)
{
	struct edgeuse	*eu1;
	struct edgeuse	*eu2;
	struct edgeuse	*teu;
	struct edge	*e1;
	struct edge_g_lseg	*eg;
	struct vertexuse *vu;
	struct vertex	*vb = 0;
	struct vertex	*vc;
	struct vertex	*va;
	struct shell	*s1;
	int		ret = 0;

	NMG_CK_EDGEUSE( eu1_first );
	e1 = eu1_first->e_p;
	NMG_CK_EDGE( e1 );

	if( eu1_first->g.magic_p != eu1_first->eumate_p->g.magic_p )
		rt_bomb("nmg_unbreak_edge() eu and mate don't share geometry\n");

	eg = eu1_first->g.lseg_p;
	if( !eg )  {
		bu_log( "nmg_unbreak_edge: no geometry for edge1 x%x\n" , e1 );
		ret = -1;
		goto out;
	}
	NMG_CK_EDGE_G_LSEG(eg);

	/* If the edge geometry doesn't have at least four edgeuses, this
	 * is not a candidate for unbreaking */		
	if( bu_list_len( &eg->eu_hd2 ) < 2*2 )  {
		ret = -2;
		goto out;
	}

	s1 = nmg_find_s_of_eu(eu1_first);
	NMG_CK_SHELL(s1);

	eu1 = eu1_first;
	eu2 = BU_LIST_PNEXT_CIRC( edgeuse , eu1 );
	if( eu2->g.lseg_p != eg )  {
		bu_log( "nmg_unbreak_edge: second eu geometry x%x does not match geometry x%x of edge1 x%x\n" ,
			eu2->g.magic_p, eg, e1 );
		ret = -3;
		goto out;
	}

	va = eu1->vu_p->v_p;		/* start vertex (A) */
	vb = eu2->vu_p->v_p;		/* middle vertex (B) */
	vc = eu2->eumate_p->vu_p->v_p;	/* end vertex (C) */

	/* all uses of this vertex must be for this edge geometry, otherwise
	 * it is not a candidate for deletion */
	for( BU_LIST_FOR( vu , vertexuse , &vb->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);
		if( *(vu->up.magic_p) != NMG_EDGEUSE_MAGIC )  {
			/* vertex is referred to by a self-loop */
			if( vu->up.lu_p->orientation == OT_BOOLPLACE )  {
				/* This kind is transient, and safe to ignore */
				continue;
			}
			ret = -4;
			goto out;
		}
		NMG_CK_EDGEUSE(vu->up.eu_p);
		if( vu->up.eu_p->g.lseg_p != eg )  {
			ret = -5;
			goto out;
		}
	}

	/* Visit all edgeuse pairs radial to eu1 (A--B) */
	teu = eu1;
	for(;;)  {
		register struct edgeuse	*teu2;
		NMG_CK_EDGEUSE(teu);
		if( teu->vu_p->v_p != va || teu->eumate_p->vu_p->v_p != vb )  {
			ret = -6;
			goto out;
		}
		/* We *may* encounter a teu2 not around eu2.  Seen in BigWedge */
		teu2 = BU_LIST_PNEXT_CIRC( edgeuse, teu );
		NMG_CK_EDGEUSE(teu2);
		if( teu2->vu_p->v_p != vb || teu2->eumate_p->vu_p->v_p != vc )  {
			ret = -7;
			goto out;
		}
		teu = teu->eumate_p->radial_p;
		if( teu == eu1 )  break;
	}

	/* Visit all edgeuse pairs radial to eu2 (B--C) */
	teu = eu2;
	for(;;)  {
		NMG_CK_EDGEUSE(teu);
		if( teu->vu_p->v_p != vb || teu->eumate_p->vu_p->v_p != vc )  {
			ret = -8;
			goto out;
		}
		teu = teu->eumate_p->radial_p;
		if( teu == eu2 )  break;
	}

	/* All preconditions are met, begin the unbreak operation */
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_unbreak_edge va=x%x, vb=x%x, vc=x%x\n",
			va, vb, vc );
		bu_log("nmg_unbreak_edge A:(%g, %g, %g), B:(%g, %g, %g), C:(%g, %g, %g)\n",
			V3ARGS( va->vg_p->coord ),
			V3ARGS( vb->vg_p->coord ),
			V3ARGS( vc->vg_p->coord ) );
	}

	if( va == vc )
	{
		/* bu_log( "nmg_unbreak_edge( eu=%x ): Trying to break a jaunt, va==vc (%x)\n", eu1_first, va ); */
		ret = -9;
		goto out;
	}
		

	/* visit all the edgeuse pairs radial to eu1 */
	for(;;)  {
		/* Recheck initial conditions */
		if( eu1->vu_p->v_p != va || eu1->eumate_p->vu_p->v_p != vb )  {
			bu_log( "nmg_unbreak_edge: eu1 does not got to/from correct vertices, x%x, %x\n", 
				eu1->vu_p->v_p, eu1->eumate_p->vu_p->v_p );
			nmg_pr_eu_briefly( eu1, " " );
			rt_bomb( "nmg_unbreak_edge 1\n" );
		}
		eu2 = BU_LIST_PNEXT_CIRC( edgeuse, eu1 );
		NMG_CK_EDGEUSE(eu2);
		if( eu2->g.lseg_p != eg )  {
			rt_bomb("nmg_unbreak_edge:  eu2 geometry is wrong\n");
		}
		if( eu2->vu_p->v_p != vb || eu2->eumate_p->vu_p->v_p != vc )  {
			bu_log( "nmg_unbreak_edge: about to kill eu2, but does not got to/from correct vertices, x%x, x%x\n",
				eu2->vu_p->v_p, eu2->eumate_p->vu_p->v_p );
			nmg_pr_eu_briefly( eu2, " " );
			rt_bomb( "nmg_unbreak_edge 3\n" );
		}

		/* revector eu1mate's start vertex from B to C */
		nmg_movevu( eu1->eumate_p->vu_p , vc );

		if( eu1->vu_p->v_p != va || eu1->eumate_p->vu_p->v_p != vc )  {
			bu_log( "nmg_unbreak_edge: extended eu1 does not got to/from correct vertices, x%x, x%x\n",
				eu1->vu_p->v_p, eu1->eumate_p->vu_p->v_p );
			nmg_pr_eu_briefly( eu1, " " );
			rt_bomb( "nmg_unbreak_edge 2\n" );
		}

		if( eu2 != BU_LIST_PNEXT_CIRC( edgeuse, eu1 ) )
			rt_bomb("nmg_unbreak_edge eu2 unexpected altered\n");

		/* Now kill off the unnecessary eu2 associated w/ cur eu1 */
		if( nmg_keu( eu2 ) )
			rt_bomb( "nmg_unbreak_edge: edgeuse parent is now empty!!\n" );

		if( eu1->vu_p->v_p != va || eu1->eumate_p->vu_p->v_p != vc )  {
			bu_log( "nmg_unbreak_edge: unbroken eu1 (after eu2 killed) does not got to/from correct vertices, x%x, x%x\n",
				eu1->vu_p->v_p, eu1->eumate_p->vu_p->v_p );
			nmg_pr_eu_briefly( eu1, " " );
			rt_bomb( "nmg_unbreak_edge 4\n" );
		}
		eu1 = eu1->eumate_p->radial_p;
		if( eu1 == eu1_first )  break;
	}
out:
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_unbreak_edge(eu=x%x, vb=x%x) ret = %d\n",
			eu1_first, vb, ret);
	}
	return ret;
}

/*
 *			N M G _ U N B R E A K _ S H E L L _ E D G E _ U N S A F E
 *
 *  Undoes the effect of an unwanted nmg_ebreak().
 *
 *	NOTE: THIS IS LIKELY TO PRODUCE AN ILLEGAL NMG STRUCTURE!!!!
 *	This routine is intended for use only when simplifying an NMG
 *	prior to output in another format (such as polygons). It will
 *	unbreak edges where nmg_unbreak_edge() will not!!!!!
 *
 *  Eliminate the vertex between this edgeuse and the next edge,
 *  on all edgeuses radial to this edgeuse's edge.
 *  The edge geometry must be shared, and all uses of the vertex, in the same shell,
 *  to be disposed of must originate from this edge pair.
 *  Also, the "non-B" ends of all edgeuses around e1 and e2 (in this shell) must
 *  terminate at either A or B.
 *
 *
 *		     eu1          eu2
 *		*----------->*----------->*
 *		A.....e1.....B.....e2.....C
 *		*<-----------*<-----------*
 *		    eu1mate      eu2mate
 *
 *  If successful, the vertex B, the edge e2, and all the edgeuses in the same shell
 *  radial to eu2 (including eu2) will have all been killed.
 *  The radial ordering around e1 will not change.
 *
 *		     eu1
 *		*------------------------>*
 *		A.....e1..................C
 *		*<------------------------*
 *		    eu1mate
 *
 *
 *  No new topology structures are created by this operation.
 *
 *  Returns -
 *	0	OK, edge unbroken
 *	<0	failure, nothing changed
 */
int
nmg_unbreak_shell_edge_unsafe(struct edgeuse *eu1_first)
{
	struct edgeuse	*eu1;
	struct edgeuse	*eu2;
	struct edgeuse	*teu;
	struct edge	*e1;
	struct edge_g_lseg	*eg;
	struct vertexuse *vu;
	struct vertex	*vb = 0;
	struct vertex	*vc;
	struct vertex	*va;
	struct shell	*s1;
	int		ret = 0;

	NMG_CK_EDGEUSE( eu1_first );
	e1 = eu1_first->e_p;
	NMG_CK_EDGE( e1 );

	if( eu1_first->g.magic_p != eu1_first->eumate_p->g.magic_p )
	{
		ret = -10;
		goto out;
	}

	eg = eu1_first->g.lseg_p;
	if( !eg )  {
		ret = -1;
		goto out;
	}
	NMG_CK_EDGE_G_LSEG(eg);

	s1 = nmg_find_s_of_eu(eu1_first);
	NMG_CK_SHELL(s1);

	eu1 = eu1_first;
	eu2 = BU_LIST_PNEXT_CIRC( edgeuse , eu1 );
	if( eu2->g.lseg_p != eg )  {
		bu_log( "nmg_unbreak_edge: second eu geometry x%x does not match geometry x%x of edge1 x%x\n" ,
			eu2->g.magic_p, eg, e1 );
		ret = -3;
		goto out;
	}

	va = eu1->vu_p->v_p;		/* start vertex (A) */
	vb = eu2->vu_p->v_p;		/* middle vertex (B) */
	vc = eu2->eumate_p->vu_p->v_p;	/* end vertex (C) */

	/* all uses of this vertex (in shell s1) must be for this edge geometry, otherwise
	 * it is not a candidate for deletion */
	for( BU_LIST_FOR( vu , vertexuse , &vb->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);
		if( *(vu->up.magic_p) != NMG_EDGEUSE_MAGIC )  {
			/* vertex is referred to by a self-loop */
			if( vu->up.lu_p->orientation == OT_BOOLPLACE )  {
				/* This kind is transient, and safe to ignore */
				continue;
			}
			ret = -4;
			goto out;
		}
		if( nmg_find_s_of_vu( vu ) != s1 )
			continue;
		NMG_CK_EDGEUSE(vu->up.eu_p);
		if( vu->up.eu_p->g.lseg_p != eg )  {
			ret = -5;
			goto out;
		}
	}

	/* Visit all edgeuse pairs radial to eu1 (A--B) */
	teu = eu1;
	for(;;)  {
		register struct edgeuse	*teu2;
		NMG_CK_EDGEUSE(teu);
		if( teu->vu_p->v_p != va || teu->eumate_p->vu_p->v_p != vb )  {
			ret = -6;
			goto out;
		}
		/* We *may* encounter a teu2 not around eu2.  Seen in BigWedge */
		teu2 = BU_LIST_PNEXT_CIRC( edgeuse, teu );
		NMG_CK_EDGEUSE(teu2);
		if( teu2->vu_p->v_p != vb || teu2->eumate_p->vu_p->v_p != vc )  {
			ret = -7;
			goto out;
		}
		teu = teu->eumate_p->radial_p;
		if( teu == eu1 )  break;
	}

	/* Visit all edgeuse pairs radial to eu2 (B--C) */
	teu = eu2;
	for(;;)  {
		NMG_CK_EDGEUSE(teu);
		if( teu->vu_p->v_p != vb || teu->eumate_p->vu_p->v_p != vc )  {
			ret = -8;
			goto out;
		}
		teu = teu->eumate_p->radial_p;
		if( teu == eu2 )  break;
	}

	/* All preconditions are met, begin the unbreak operation */
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_unbreak_edge va=x%x, vb=x%x, vc=x%x\n",
			va, vb, vc );
		bu_log("nmg_unbreak_edge A:(%g, %g, %g), B:(%g, %g, %g), C:(%g, %g, %g)\n",
			V3ARGS( va->vg_p->coord ),
			V3ARGS( vb->vg_p->coord ),
			V3ARGS( vc->vg_p->coord ) );
	}

	if( va == vc )
	{
		/* bu_log( "nmg_unbreak_edge( eu=%x ): Trying to break a jaunt, va==vc (%x)\n", eu1_first, va ); */
		ret = -9;
		goto out;
	}
		

	/* visit all the edgeuse pairs radial to eu1 */
	for(;;)  {
		/* Recheck initial conditions */
		if( eu1->vu_p->v_p != va || eu1->eumate_p->vu_p->v_p != vb )  {
			bu_log( "nmg_unbreak_edge: eu1 does not got to/from correct vertices, x%x, %x\n", 
				eu1->vu_p->v_p, eu1->eumate_p->vu_p->v_p );
			nmg_pr_eu_briefly( eu1, " " );
			rt_bomb( "nmg_unbreak_edge 1\n" );
		}
		eu2 = BU_LIST_PNEXT_CIRC( edgeuse, eu1 );
		NMG_CK_EDGEUSE(eu2);
		if( eu2->g.lseg_p != eg )  {
			rt_bomb("nmg_unbreak_edge:  eu2 geometry is wrong\n");
		}
		if( eu2->vu_p->v_p != vb || eu2->eumate_p->vu_p->v_p != vc )  {
			bu_log( "nmg_unbreak_edge: about to kill eu2, but does not got to/from correct vertices, x%x, x%x\n",
				eu2->vu_p->v_p, eu2->eumate_p->vu_p->v_p );
			nmg_pr_eu_briefly( eu2, " " );
			rt_bomb( "nmg_unbreak_edge 3\n" );
		}

		/* revector eu1mate's start vertex from B to C */
		nmg_movevu( eu1->eumate_p->vu_p , vc );

		if( eu1->vu_p->v_p != va || eu1->eumate_p->vu_p->v_p != vc )  {
			bu_log( "nmg_unbreak_edge: extended eu1 does not got to/from correct vertices, x%x, x%x\n",
				eu1->vu_p->v_p, eu1->eumate_p->vu_p->v_p );
			nmg_pr_eu_briefly( eu1, " " );
			rt_bomb( "nmg_unbreak_edge 2\n" );
		}

		if( eu2 != BU_LIST_PNEXT_CIRC( edgeuse, eu1 ) )
			rt_bomb("nmg_unbreak_edge eu2 unexpected altered\n");

		/* Now kill off the unnecessary eu2 associated w/ cur eu1 */
		if( nmg_keu( eu2 ) )
			rt_bomb( "nmg_unbreak_edge: edgeuse parent is now empty!!\n" );

		if( eu1->vu_p->v_p != va || eu1->eumate_p->vu_p->v_p != vc )  {
			bu_log( "nmg_unbreak_edge: unbroken eu1 (after eu2 killed) does not got to/from correct vertices, x%x, x%x\n",
				eu1->vu_p->v_p, eu1->eumate_p->vu_p->v_p );
			nmg_pr_eu_briefly( eu1, " " );
			rt_bomb( "nmg_unbreak_edge 4\n" );
		}
		eu1 = eu1->eumate_p->radial_p;
		if( eu1 == eu1_first )  break;
	}
out:
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_unbreak_edge(eu=x%x, vb=x%x) ret = %d\n",
			eu1_first, vb, ret);
	}
	return ret;
}

/*
 *			N M G _ E I N S
 *
 *	Insert a new (zero length) edge at the begining of (ie, before)
 *	an existing edgeuse
 *	Perhaps this is what nmg_esplit and nmg_eusplit should have been like?
 *
 *	Before:
 *	.--A--> .--eu-->
 *		 \
 *		  >.
 *		 /
 *	  <-A'--. <-eu'-.
 *
 *
 *	After:
 *
 *               eu1     eu
 *	.--A--> .---> .--eu-->
 *		 \   /
 *		  >.<
 *		 /   \
 *	  <-A'--. <---. <-eu'--.
 *	          eu2     eumate
 */
struct edgeuse *
nmg_eins(struct edgeuse *eu)
{
	struct edgeuse	*eumate;
	struct edgeuse	*eu1, *eu2;
	struct shell	*s;

	NMG_CK_EDGEUSE(eu);
	eumate = eu->eumate_p;
	NMG_CK_EDGEUSE(eumate);

	if (*eu->up.magic_p == NMG_SHELL_MAGIC) {
		s = eu->up.s_p;
		NMG_CK_SHELL(s);
	}
	else {
		struct loopuse *lu;
		
		lu = eu->up.lu_p;
		NMG_CK_LOOPUSE(lu);
		if (*lu->up.magic_p == NMG_SHELL_MAGIC) {
			s = lu->up.s_p;
			NMG_CK_SHELL(s);
		} else {
			struct faceuse *fu;
			fu = lu->up.fu_p;
			NMG_CK_FACEUSE(fu);
			s = fu->s_p;
			NMG_CK_SHELL(s);
		}
	}

	eu1 = nmg_me(eu->vu_p->v_p, eu->vu_p->v_p, s);
	eu2 = eu1->eumate_p;

	if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC) {
		BU_LIST_DEQUEUE( &eu1->l );
		BU_LIST_DEQUEUE( &eu2->l );

		BU_LIST_INSERT( &eu->l, &eu1->l );
		BU_LIST_APPEND( &eumate->l, &eu2->l );

		eu1->up.lu_p = eu->up.lu_p;
		eu2->up.lu_p = eumate->up.lu_p;
	}
	else {
		rt_bomb("nmg_eins() Cannot yet insert null edge in shell\n");
	}
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_eins(eu=x%x) eu1=x%x\n", eu, eu1);
	}
	return(eu1);
}

/*
 *			N M G _ M V _ E U _ B E T W E E N _ S H E L L S
 *
 *  Move a wire edgeuse and it's mate from one shell to another.
 */
void
nmg_mv_eu_between_shells(struct shell *dest, register struct shell *src, register struct edgeuse *eu)
{
	register struct edgeuse	*eumate;

	NMG_CK_EDGEUSE(eu);
	eumate = eu->eumate_p;
	NMG_CK_EDGEUSE(eumate);

	if (eu->up.s_p != src) {
		bu_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eu->up.s_p=x%x isnt src shell\n",
			dest, src, eu, eu->up.s_p );
		rt_bomb("eu->up.s_p isnt source shell\n");
	}
	if (eumate->up.s_p != src) {
		bu_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eumate->up.s_p=x%x isn't src shell\n",
			dest, src, eu, eumate->up.s_p );
		rt_bomb("eumate->up.s_p isnt source shell\n");
	}

	/* Remove eu from src shell */
	BU_LIST_DEQUEUE( &eu->l );
	if( BU_LIST_IS_EMPTY( &src->eu_hd ) )  {
		/* This was the last eu in the list, bad news */
		bu_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eumate=x%x not in src shell\n",
			dest, src, eu, eumate );
		rt_bomb("src shell emptied before finding eumate\n");
	}

	/* Remove eumate from src shell */
	BU_LIST_DEQUEUE( &eumate->l );

	/* Add eu and eumate to dest shell */
	BU_LIST_APPEND( &dest->eu_hd, &eu->l );
	BU_LIST_APPEND( &eu->l, &eumate->l );

	eu->up.s_p = dest;
	eumate->up.s_p = dest;

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_mv_eu_between_shells( dest=x%x, src=x%x, eu=x%x ) new_eu=x%x\n",
			dest, src, eu);
	}
}

/************************************************************************
 *									*
 *				VERTEX Routines				*
 *									*
 ************************************************************************/

/*
 *			N M G _ M V _ V U _ B E T W E E N _ S H E L L S
 *
 *  If this shell had a single vertexuse in it, move it to the other
 *  shell, but "promote" it to a "loop of a single vertex" along the way.
 */
void
nmg_mv_vu_between_shells(struct shell *dest, register struct shell *src, register struct vertexuse *vu)
{
	NMG_CK_VERTEXUSE( vu );
	NMG_CK_VERTEX( vu->v_p );

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_mv_vu_between_shells( dest_s=x%x, src_s=x%x, vu=x%x )\n",
			dest, src, vu);
	}
	(void) nmg_mlv( &(dest->l.magic), vu->v_p, OT_SAME );
	if (vu->v_p->vg_p) {
		NMG_CK_VERTEX_G(vu->v_p->vg_p);
	}
	nmg_kvu( vu );
}
@


11.51
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_mod.c,v 11.50 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.50
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.49
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mod.c,v 11.48 2002/08/20 17:08:05 jra Exp $ (BRL)";
d36 1
a36 4
nmg_merge_regions( r1, r2, tol )
struct nmgregion *r1;
struct nmgregion *r2;
const struct bn_tol *tol;
d88 1
a88 4
nmg_shell_coplanar_face_merge( s, tol, simplify )
struct shell		*s;
const struct bn_tol	*tol;
const int		simplify;
d216 1
a216 2
nmg_simplify_shell(s)
struct shell *s;
d250 1
a250 3
nmg_rm_redundancies(s, tol)
struct shell	*s;
const struct bn_tol *tol;
d602 1
a602 3
nmg_sanitize_s_lv(s, orient)
struct shell	*s;
int		orient;
d685 1
a685 3
nmg_s_split_touchingloops(s, tol)
struct shell		*s;
const struct bn_tol	*tol;
d728 1
a728 3
nmg_s_join_touchingloops(s, tol)
struct shell		*s;
const struct bn_tol	*tol;
d775 4
a778 4
nmg_js( s1, s2, tol )
register struct shell	*s1;		/* destination */
register struct shell	*s2;		/* source */
const struct bn_tol	*tol;
d940 1
a940 3
nmg_invert_shell( s, tol )
struct shell		*s;
const struct bn_tol	*tol;
d1031 1
a1031 4
nmg_cmface(s, verts, n)
struct shell	*s;
struct vertex	**verts[];
int		n;
d1181 1
a1181 4
nmg_cface(s, verts, n)
struct shell *s;
struct vertex *verts[];
int n;
d1261 1
a1261 5
nmg_add_loop_to_face(s, fu, verts, n, dir)
struct shell *s;
struct faceuse *fu;
struct vertex *verts[];
int n, dir;
d1362 1
a1362 3
nmg_fu_planeeqn( fu, tol )
struct faceuse		*fu;
const struct bn_tol	*tol;
d1464 1
a1464 4
nmg_gluefaces(fulist, n, tol)
struct faceuse *fulist[];
int n;
const struct bn_tol *tol;
d1532 1
a1532 2
nmg_simplify_face(fu)
struct faceuse *fu;
d1599 1
a1599 2
nmg_reverse_face( fu )
register struct faceuse	*fu;
d1807 1
a1807 4
nmg_mv_fu_between_shells( dest, src, fu )
struct shell		*dest;
register struct shell	*src;
register struct faceuse	*fu;
d1865 1
a1865 3
nmg_move_fu_fu( dest_fu, src_fu )
register struct faceuse	*dest_fu;
register struct faceuse	*src_fu;
d1897 1
a1897 3
nmg_jf(dest_fu, src_fu)
register struct faceuse	*dest_fu;
register struct faceuse	*src_fu;
d1934 1
a1934 3
nmg_dup_face(fu, s)
struct faceuse *fu;
struct shell *s;
d2054 1
a2054 3
nmg_jl(lu, eu)
struct loopuse *lu;
struct edgeuse *eu;
d2153 1
a2153 3
nmg_join_2loops( vu1, vu2 )
struct vertexuse	*vu1;
struct vertexuse	*vu2;
d2247 1
a2247 2
nmg_join_singvu_loop( vu1, vu2 )
struct vertexuse	*vu1, *vu2;
d2297 1
a2297 2
nmg_join_2singvu_loops( vu1, vu2 )
struct vertexuse	*vu1, *vu2;
d2396 1
a2396 2
nmg_cut_loop(vu1, vu2)
struct vertexuse *vu1, *vu2;
d2564 1
a2564 3
nmg_split_lu_at_vu( lu, split_vu )
struct loopuse		*lu;
struct vertexuse	*split_vu;
d2640 1
a2640 2
nmg_find_repeated_v_in_lu( vu )
struct vertexuse	*vu;
d2694 1
a2694 3
nmg_split_touchingloops( lu, tol )
struct loopuse		*lu;
const struct bn_tol	*tol;
d2836 1
a2836 2
nmg_join_touchingloops( lu )
struct loopuse	*lu;
d2934 1
a2934 4
nmg_get_touching_jaunts( lu, tbl, need_init )
const struct loopuse *lu;
struct bu_ptbl *tbl;
int *need_init;
d3002 1
a3002 8
nmg_check_proposed_loop( start_eu, next_start_eu, visit_count, jaunt_status, jaunt_tbl, jaunt_no, which_loop )
struct edgeuse *start_eu;
struct edgeuse **next_start_eu;
int visit_count[];
int jaunt_status[];
const struct bu_ptbl *jaunt_tbl;
const int jaunt_no;
const int which_loop;
d3085 1
a3085 2
nmg_kill_accordions( lu )
struct loopuse *lu;
d3166 1
a3166 3
nmg_loop_split_at_touching_jaunt(lu, tol)
struct loopuse		*lu;
const struct bn_tol	*tol;
d3410 1
a3410 2
nmg_simplify_loop(lu)
struct loopuse *lu;
d3491 1
a3491 2
nmg_kill_snakes(lu)
struct loopuse *lu;
d3566 1
a3566 4
nmg_mv_lu_between_shells( dest, src, lu )
struct shell		*dest;
register struct shell	*src;
register struct loopuse	*lu;
d3617 1
a3617 3
void nmg_moveltof(fu, s)
struct faceuse *fu;
struct shell *s;
d3653 4
a3656 4
nmg_dup_loop(lu, parent, trans_tbl)
struct loopuse *lu;
long	*parent;		/* fu or shell ptr */
long	**trans_tbl;
d3833 1
a3833 3
nmg_set_lu_orientation( lu, is_opposite )
struct loopuse	*lu;
int		is_opposite;
d3863 1
a3863 2
nmg_lu_reorient( lu )
struct loopuse		*lu;
d3968 1
a3968 4
nmg_eusplit(v, oldeu, share_geom)
struct vertex	*v;
struct edgeuse	*oldeu;
int		share_geom;
d4243 4
a4246 4
nmg_esplit(v, eu, share_geom)
struct vertex	*v;		/* New vertex, to go in middle */
struct edgeuse	*eu;
int		share_geom;
d4361 3
a4363 3
nmg_ebreak(v, eu)
struct vertex	*v;			/* May be NULL */
struct edgeuse	*eu;
d4397 4
a4400 4
nmg_ebreaker(v, eu, tol)
struct vertex		*v;			/* May be NULL */
struct edgeuse		*eu;
const struct bn_tol	*tol;
d4460 1
a4460 3
nmg_e2break( eu1, eu2 )
struct edgeuse	*eu1;
struct edgeuse	*eu2;
d4519 1
a4519 2
nmg_unbreak_edge( eu1_first )
struct edgeuse	*eu1_first;
d4738 1
a4738 2
nmg_unbreak_shell_edge_unsafe( eu1_first )
struct edgeuse	*eu1_first;
d4938 1
a4938 2
nmg_eins(eu)
struct edgeuse *eu;
d4997 1
a4997 4
nmg_mv_eu_between_shells( dest, src, eu )
struct shell		*dest;
register struct shell	*src;
register struct edgeuse	*eu;
d5054 1
a5054 4
nmg_mv_vu_between_shells( dest, src, vu )
struct shell		*dest;
register struct shell	*src;
register struct vertexuse	*vu;
@


11.48
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1991 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mod.c,v 11.46 2001/04/20 22:29:52 morrison Exp $ (BRL)";
@


11.48.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1991-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_mod.c,v 11.49 2004/02/02 17:39:24 morrison Exp $ (BRL)";
@


11.48.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1991-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mod.c,v 11.49 2004/02/02 17:39:24 morrison Exp $ (BRL)";
@


11.48.10.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mod.c,v 11.48.10.1 2004/02/12 18:37:45 erikg Exp $ (BRL)";
@


11.48.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mod.c,v 11.48 2002/08/20 17:08:05 jra Exp $ (BRL)";
d36 4
a39 1
nmg_merge_regions(struct nmgregion *r1, struct nmgregion *r2, const struct bn_tol *tol)
d91 4
a94 1
nmg_shell_coplanar_face_merge(struct shell *s, const struct bn_tol *tol, const int simplify)
d222 2
a223 1
nmg_simplify_shell(struct shell *s)
d257 3
a259 1
nmg_rm_redundancies(struct shell *s, const struct bn_tol *tol)
d611 3
a613 1
nmg_sanitize_s_lv(struct shell *s, int orient)
d696 3
a698 1
nmg_s_split_touchingloops(struct shell *s, const struct bn_tol *tol)
d741 3
a743 1
nmg_s_join_touchingloops(struct shell *s, const struct bn_tol *tol)
d790 4
a793 4
nmg_js(register struct shell *s1, register struct shell *s2, const struct bn_tol *tol)
                     	    		/* destination */
                     	    		/* source */
                   	     
d955 3
a957 1
nmg_invert_shell(struct shell *s, const struct bn_tol *tol)
d1048 4
a1051 1
nmg_cmface(struct shell *s, struct vertex ***verts, int n)
d1201 4
a1204 1
nmg_cface(struct shell *s, struct vertex **verts, int n)
d1284 5
a1288 1
nmg_add_loop_to_face(struct shell *s, struct faceuse *fu, struct vertex **verts, int n, int dir)
d1389 3
a1391 1
nmg_fu_planeeqn(struct faceuse *fu, const struct bn_tol *tol)
d1493 4
a1496 1
nmg_gluefaces(struct faceuse **fulist, int n, const struct bn_tol *tol)
d1564 2
a1565 1
nmg_simplify_face(struct faceuse *fu)
d1632 2
a1633 1
nmg_reverse_face(register struct faceuse *fu)
d1841 4
a1844 1
nmg_mv_fu_between_shells(struct shell *dest, register struct shell *src, register struct faceuse *fu)
d1902 3
a1904 1
nmg_move_fu_fu(register struct faceuse *dest_fu, register struct faceuse *src_fu)
d1936 3
a1938 1
nmg_jf(register struct faceuse *dest_fu, register struct faceuse *src_fu)
d1975 3
a1977 1
nmg_dup_face(struct faceuse *fu, struct shell *s)
d2097 3
a2099 1
nmg_jl(struct loopuse *lu, struct edgeuse *eu)
d2198 3
a2200 1
nmg_join_2loops(struct vertexuse *vu1, struct vertexuse *vu2)
d2294 2
a2295 1
nmg_join_singvu_loop(struct vertexuse *vu1, struct vertexuse *vu2)
d2345 2
a2346 1
nmg_join_2singvu_loops(struct vertexuse *vu1, struct vertexuse *vu2)
d2445 2
a2446 1
nmg_cut_loop(struct vertexuse *vu1, struct vertexuse *vu2)
d2614 3
a2616 1
nmg_split_lu_at_vu(struct loopuse *lu, struct vertexuse *split_vu)
d2692 2
a2693 1
nmg_find_repeated_v_in_lu(struct vertexuse *vu)
d2747 3
a2749 1
nmg_split_touchingloops(struct loopuse *lu, const struct bn_tol *tol)
d2891 2
a2892 1
nmg_join_touchingloops(struct loopuse *lu)
d2990 4
a2993 1
nmg_get_touching_jaunts(const struct loopuse *lu, struct bu_ptbl *tbl, int *need_init)
d3061 8
a3068 1
nmg_check_proposed_loop(struct edgeuse *start_eu, struct edgeuse **next_start_eu, int *visit_count, int *jaunt_status, const struct bu_ptbl *jaunt_tbl, const int jaunt_no, const int which_loop)
d3151 2
a3152 1
nmg_kill_accordions(struct loopuse *lu)
d3233 3
a3235 1
nmg_loop_split_at_touching_jaunt(struct loopuse *lu, const struct bn_tol *tol)
d3479 2
a3480 1
nmg_simplify_loop(struct loopuse *lu)
d3561 2
a3562 1
nmg_kill_snakes(struct loopuse *lu)
d3637 4
a3640 1
nmg_mv_lu_between_shells(struct shell *dest, register struct shell *src, register struct loopuse *lu)
d3691 3
a3693 1
void nmg_moveltof(struct faceuse *fu, struct shell *s)
d3729 4
a3732 4
nmg_dup_loop(struct loopuse *lu, long int *parent, long int **trans_tbl)
                   
    	        		/* fu or shell ptr */
    	            
d3909 3
a3911 1
nmg_set_lu_orientation(struct loopuse *lu, int is_opposite)
d3941 2
a3942 1
nmg_lu_reorient(struct loopuse *lu)
d4047 4
a4050 1
nmg_eusplit(struct vertex *v, struct edgeuse *oldeu, int share_geom)
d4325 4
a4328 4
nmg_esplit(struct vertex *v, struct edgeuse *eu, int share_geom)
             	   		/* New vertex, to go in middle */
              	    
   		           
d4443 3
a4445 3
nmg_ebreak(struct vertex *v, struct edgeuse *eu)
             	   			/* May be NULL */
              	    
d4479 4
a4482 4
nmg_ebreaker(struct vertex *v, struct edgeuse *eu, const struct bn_tol *tol)
             		   			/* May be NULL */
              		    
                   	     
d4542 3
a4544 1
nmg_e2break(struct edgeuse *eu1, struct edgeuse *eu2)
d4603 2
a4604 1
nmg_unbreak_edge(struct edgeuse *eu1_first)
d4823 2
a4824 1
nmg_unbreak_shell_edge_unsafe(struct edgeuse *eu1_first)
d5024 2
a5025 1
nmg_eins(struct edgeuse *eu)
d5084 4
a5087 1
nmg_mv_eu_between_shells(struct shell *dest, register struct shell *src, register struct edgeuse *eu)
d5144 4
a5147 1
nmg_mv_vu_between_shells(struct shell *dest, register struct shell *src, register struct vertexuse *vu)
@


11.48.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1991-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.47
log
@Converted from K&R to ANSI C - RFH
@
text
@d36 4
a39 1
nmg_merge_regions(struct nmgregion *r1, struct nmgregion *r2, const struct bn_tol *tol)
d91 4
a94 1
nmg_shell_coplanar_face_merge(struct shell *s, const struct bn_tol *tol, const int simplify)
d222 2
a223 1
nmg_simplify_shell(struct shell *s)
d257 3
a259 1
nmg_rm_redundancies(struct shell *s, const struct bn_tol *tol)
d611 3
a613 1
nmg_sanitize_s_lv(struct shell *s, int orient)
d696 3
a698 1
nmg_s_split_touchingloops(struct shell *s, const struct bn_tol *tol)
d741 3
a743 1
nmg_s_join_touchingloops(struct shell *s, const struct bn_tol *tol)
d790 4
a793 4
nmg_js(register struct shell *s1, register struct shell *s2, const struct bn_tol *tol)
                     	    		/* destination */
                     	    		/* source */
                   	     
d955 3
a957 1
nmg_invert_shell(struct shell *s, const struct bn_tol *tol)
d1048 4
a1051 1
nmg_cmface(struct shell *s, struct vertex ***verts, int n)
d1201 4
a1204 1
nmg_cface(struct shell *s, struct vertex **verts, int n)
d1284 5
a1288 1
nmg_add_loop_to_face(struct shell *s, struct faceuse *fu, struct vertex **verts, int n, int dir)
d1389 3
a1391 1
nmg_fu_planeeqn(struct faceuse *fu, const struct bn_tol *tol)
d1493 4
a1496 1
nmg_gluefaces(struct faceuse **fulist, int n, const struct bn_tol *tol)
d1564 2
a1565 1
nmg_simplify_face(struct faceuse *fu)
d1632 2
a1633 1
nmg_reverse_face(register struct faceuse *fu)
d1841 4
a1844 1
nmg_mv_fu_between_shells(struct shell *dest, register struct shell *src, register struct faceuse *fu)
d1902 3
a1904 1
nmg_move_fu_fu(register struct faceuse *dest_fu, register struct faceuse *src_fu)
d1936 3
a1938 1
nmg_jf(register struct faceuse *dest_fu, register struct faceuse *src_fu)
d1975 3
a1977 1
nmg_dup_face(struct faceuse *fu, struct shell *s)
d2097 3
a2099 1
nmg_jl(struct loopuse *lu, struct edgeuse *eu)
d2198 3
a2200 1
nmg_join_2loops(struct vertexuse *vu1, struct vertexuse *vu2)
d2294 2
a2295 1
nmg_join_singvu_loop(struct vertexuse *vu1, struct vertexuse *vu2)
d2345 2
a2346 1
nmg_join_2singvu_loops(struct vertexuse *vu1, struct vertexuse *vu2)
d2445 2
a2446 1
nmg_cut_loop(struct vertexuse *vu1, struct vertexuse *vu2)
d2614 3
a2616 1
nmg_split_lu_at_vu(struct loopuse *lu, struct vertexuse *split_vu)
d2692 2
a2693 1
nmg_find_repeated_v_in_lu(struct vertexuse *vu)
d2747 3
a2749 1
nmg_split_touchingloops(struct loopuse *lu, const struct bn_tol *tol)
d2891 2
a2892 1
nmg_join_touchingloops(struct loopuse *lu)
d2990 4
a2993 1
nmg_get_touching_jaunts(const struct loopuse *lu, struct bu_ptbl *tbl, int *need_init)
d3061 8
a3068 1
nmg_check_proposed_loop(struct edgeuse *start_eu, struct edgeuse **next_start_eu, int *visit_count, int *jaunt_status, const struct bu_ptbl *jaunt_tbl, const int jaunt_no, const int which_loop)
d3151 2
a3152 1
nmg_kill_accordions(struct loopuse *lu)
d3233 3
a3235 1
nmg_loop_split_at_touching_jaunt(struct loopuse *lu, const struct bn_tol *tol)
d3479 2
a3480 1
nmg_simplify_loop(struct loopuse *lu)
d3561 2
a3562 1
nmg_kill_snakes(struct loopuse *lu)
d3637 4
a3640 1
nmg_mv_lu_between_shells(struct shell *dest, register struct shell *src, register struct loopuse *lu)
d3691 3
a3693 1
void nmg_moveltof(struct faceuse *fu, struct shell *s)
d3729 4
a3732 4
nmg_dup_loop(struct loopuse *lu, long int *parent, long int **trans_tbl)
                   
    	        		/* fu or shell ptr */
    	            
d3909 3
a3911 1
nmg_set_lu_orientation(struct loopuse *lu, int is_opposite)
d3941 2
a3942 1
nmg_lu_reorient(struct loopuse *lu)
d4047 4
a4050 1
nmg_eusplit(struct vertex *v, struct edgeuse *oldeu, int share_geom)
d4325 4
a4328 4
nmg_esplit(struct vertex *v, struct edgeuse *eu, int share_geom)
             	   		/* New vertex, to go in middle */
              	    
   		           
d4443 3
a4445 3
nmg_ebreak(struct vertex *v, struct edgeuse *eu)
             	   			/* May be NULL */
              	    
d4479 4
a4482 4
nmg_ebreaker(struct vertex *v, struct edgeuse *eu, const struct bn_tol *tol)
             		   			/* May be NULL */
              		    
                   	     
d4542 3
a4544 1
nmg_e2break(struct edgeuse *eu1, struct edgeuse *eu2)
d4603 2
a4604 1
nmg_unbreak_edge(struct edgeuse *eu1_first)
d4823 2
a4824 1
nmg_unbreak_shell_edge_unsafe(struct edgeuse *eu1_first)
d5024 2
a5025 1
nmg_eins(struct edgeuse *eu)
d5084 4
a5087 1
nmg_mv_eu_between_shells(struct shell *dest, register struct shell *src, register struct edgeuse *eu)
d5144 4
a5147 1
nmg_mv_vu_between_shells(struct shell *dest, register struct shell *src, register struct vertexuse *vu)
@


11.46
log
@CONST to const
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mod.c,v 11.45 2000/08/31 03:57:41 mike Exp $ (BRL)";
d36 1
a36 4
nmg_merge_regions( r1, r2, tol )
struct nmgregion *r1;
struct nmgregion *r2;
const struct bn_tol *tol;
d88 1
a88 4
nmg_shell_coplanar_face_merge( s, tol, simplify )
struct shell		*s;
const struct bn_tol	*tol;
const int		simplify;
d216 1
a216 2
nmg_simplify_shell(s)
struct shell *s;
d250 1
a250 3
nmg_rm_redundancies(s, tol)
struct shell	*s;
const struct bn_tol *tol;
d602 1
a602 3
nmg_sanitize_s_lv(s, orient)
struct shell	*s;
int		orient;
d685 1
a685 3
nmg_s_split_touchingloops(s, tol)
struct shell		*s;
const struct bn_tol	*tol;
d728 1
a728 3
nmg_s_join_touchingloops(s, tol)
struct shell		*s;
const struct bn_tol	*tol;
d775 4
a778 4
nmg_js( s1, s2, tol )
register struct shell	*s1;		/* destination */
register struct shell	*s2;		/* source */
const struct bn_tol	*tol;
d940 1
a940 3
nmg_invert_shell( s, tol )
struct shell		*s;
const struct bn_tol	*tol;
d1031 1
a1031 4
nmg_cmface(s, verts, n)
struct shell	*s;
struct vertex	**verts[];
int		n;
d1181 1
a1181 4
nmg_cface(s, verts, n)
struct shell *s;
struct vertex *verts[];
int n;
d1261 1
a1261 5
nmg_add_loop_to_face(s, fu, verts, n, dir)
struct shell *s;
struct faceuse *fu;
struct vertex *verts[];
int n, dir;
d1362 1
a1362 3
nmg_fu_planeeqn( fu, tol )
struct faceuse		*fu;
const struct bn_tol	*tol;
d1464 1
a1464 4
nmg_gluefaces(fulist, n, tol)
struct faceuse *fulist[];
int n;
const struct bn_tol *tol;
d1532 1
a1532 2
nmg_simplify_face(fu)
struct faceuse *fu;
d1599 1
a1599 2
nmg_reverse_face( fu )
register struct faceuse	*fu;
d1807 1
a1807 4
nmg_mv_fu_between_shells( dest, src, fu )
struct shell		*dest;
register struct shell	*src;
register struct faceuse	*fu;
d1865 1
a1865 3
nmg_move_fu_fu( dest_fu, src_fu )
register struct faceuse	*dest_fu;
register struct faceuse	*src_fu;
d1897 1
a1897 3
nmg_jf(dest_fu, src_fu)
register struct faceuse	*dest_fu;
register struct faceuse	*src_fu;
d1934 1
a1934 3
nmg_dup_face(fu, s)
struct faceuse *fu;
struct shell *s;
d2054 1
a2054 3
nmg_jl(lu, eu)
struct loopuse *lu;
struct edgeuse *eu;
d2153 1
a2153 3
nmg_join_2loops( vu1, vu2 )
struct vertexuse	*vu1;
struct vertexuse	*vu2;
d2247 1
a2247 2
nmg_join_singvu_loop( vu1, vu2 )
struct vertexuse	*vu1, *vu2;
d2297 1
a2297 2
nmg_join_2singvu_loops( vu1, vu2 )
struct vertexuse	*vu1, *vu2;
d2396 1
a2396 2
nmg_cut_loop(vu1, vu2)
struct vertexuse *vu1, *vu2;
d2564 1
a2564 3
nmg_split_lu_at_vu( lu, split_vu )
struct loopuse		*lu;
struct vertexuse	*split_vu;
d2640 1
a2640 2
nmg_find_repeated_v_in_lu( vu )
struct vertexuse	*vu;
d2694 1
a2694 3
nmg_split_touchingloops( lu, tol )
struct loopuse		*lu;
const struct bn_tol	*tol;
d2836 1
a2836 2
nmg_join_touchingloops( lu )
struct loopuse	*lu;
d2934 1
a2934 4
nmg_get_touching_jaunts( lu, tbl, need_init )
const struct loopuse *lu;
struct bu_ptbl *tbl;
int *need_init;
d3002 1
a3002 8
nmg_check_proposed_loop( start_eu, next_start_eu, visit_count, jaunt_status, jaunt_tbl, jaunt_no, which_loop )
struct edgeuse *start_eu;
struct edgeuse **next_start_eu;
int visit_count[];
int jaunt_status[];
const struct bu_ptbl *jaunt_tbl;
const int jaunt_no;
const int which_loop;
d3085 1
a3085 2
nmg_kill_accordions( lu )
struct loopuse *lu;
d3166 1
a3166 3
nmg_loop_split_at_touching_jaunt(lu, tol)
struct loopuse		*lu;
const struct bn_tol	*tol;
d3410 1
a3410 2
nmg_simplify_loop(lu)
struct loopuse *lu;
d3491 1
a3491 2
nmg_kill_snakes(lu)
struct loopuse *lu;
d3566 1
a3566 4
nmg_mv_lu_between_shells( dest, src, lu )
struct shell		*dest;
register struct shell	*src;
register struct loopuse	*lu;
d3617 1
a3617 3
void nmg_moveltof(fu, s)
struct faceuse *fu;
struct shell *s;
d3653 4
a3656 4
nmg_dup_loop(lu, parent, trans_tbl)
struct loopuse *lu;
long	*parent;		/* fu or shell ptr */
long	**trans_tbl;
d3833 1
a3833 3
nmg_set_lu_orientation( lu, is_opposite )
struct loopuse	*lu;
int		is_opposite;
d3863 1
a3863 2
nmg_lu_reorient( lu )
struct loopuse		*lu;
d3968 1
a3968 4
nmg_eusplit(v, oldeu, share_geom)
struct vertex	*v;
struct edgeuse	*oldeu;
int		share_geom;
d4243 4
a4246 4
nmg_esplit(v, eu, share_geom)
struct vertex	*v;		/* New vertex, to go in middle */
struct edgeuse	*eu;
int		share_geom;
d4361 3
a4363 3
nmg_ebreak(v, eu)
struct vertex	*v;			/* May be NULL */
struct edgeuse	*eu;
d4397 4
a4400 4
nmg_ebreaker(v, eu, tol)
struct vertex		*v;			/* May be NULL */
struct edgeuse		*eu;
const struct bn_tol	*tol;
d4460 1
a4460 3
nmg_e2break( eu1, eu2 )
struct edgeuse	*eu1;
struct edgeuse	*eu2;
d4519 1
a4519 2
nmg_unbreak_edge( eu1_first )
struct edgeuse	*eu1_first;
d4738 1
a4738 2
nmg_unbreak_shell_edge_unsafe( eu1_first )
struct edgeuse	*eu1_first;
d4938 1
a4938 2
nmg_eins(eu)
struct edgeuse *eu;
d4997 1
a4997 4
nmg_mv_eu_between_shells( dest, src, eu )
struct shell		*dest;
register struct shell	*src;
register struct edgeuse	*eu;
d5054 1
a5054 4
nmg_mv_vu_between_shells( dest, src, vu )
struct shell		*dest;
register struct shell	*src;
register struct vertexuse	*vu;
@


11.45
log
@
Lint
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mod.c,v 11.44 2000/08/25 05:18:42 mike Exp $ (BRL)";
d39 1
a39 1
CONST struct bn_tol *tol;
d93 2
a94 2
CONST struct bn_tol	*tol;
CONST int		simplify;
d259 1
a259 1
CONST struct bn_tol *tol;
d698 1
a698 1
CONST struct bn_tol	*tol;
d743 1
a743 1
CONST struct bn_tol	*tol;
d793 1
a793 1
CONST struct bn_tol	*tol;
d957 1
a957 1
CONST struct bn_tol	*tol;
d1391 1
a1391 1
CONST struct bn_tol	*tol;
d1496 1
a1496 1
CONST struct bn_tol *tol;
d1717 1
a1717 1
CONST struct bn_tol	*tol;
d2749 1
a2749 1
CONST struct bn_tol	*tol;
d2991 1
a2991 1
CONST struct loopuse *lu;
d3066 3
a3068 3
CONST struct bu_ptbl *jaunt_tbl;
CONST int jaunt_no;
CONST int which_loop;
d3235 1
a3235 1
CONST struct bn_tol	*tol;
d4482 1
a4482 1
CONST struct bn_tol	*tol;
@


11.44
log
@
lint
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mod.c,v 11.43 2000/08/21 02:02:33 butler Exp $ (BRL)";
d4055 1
a4055 1
	struct shell *s;
@


11.43
log
@Massive compilation warnings eliminated
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mod.c,v 11.42 2000/07/10 23:01:44 mike Exp $ (BRL)";
d1054 1
a1054 1
	struct edgeuse *eu, *eur, *euold;
d3156 1
a3156 1
	struct edgeuse *jaunt_eu2;
@


11.42
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mod.c,v 11.41 1999/12/30 15:37:24 jra Exp $ (BRL)";
d25 1
d905 1
a905 1
	if( vu = s2->vu_p )  {
d1141 1
a1141 1
		if (eur = nmg_findeu(*verts[0], *verts[1], s, euold, 1))  {
d4429 1
@


11.41
log
@Eliminated some unused variables
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mod.c,v 11.40 1999/06/03 01:39:14 mike Exp $ (BRL)";
@


11.40
log
@
sed4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mod.c,v 11.39 1998/05/13 13:10:11 jra Exp $ (BRL)";
a397 1
				int found;
a2205 1
	int		new_orient;
d3246 1
a3246 1
	int			i,j;
a3943 1
	int	ccw;
@


11.39
log
@changed  NMG_CK_FACE_G_PLANE to NMG_CK_FACE_G_EITHER in nmg_reverse_face().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.38 1997/06/25 04:41:09 mike Exp jra $ (BRL)";
d109 1
a109 1
	flags1 = (char *)rt_calloc( sizeof(char), m->maxindex * 2,
d111 1
a111 1
	flags2 = (char *)rt_calloc( sizeof(char), m->maxindex * 2,
d199 2
a200 2
	rt_free( (char *)flags1, "nmg_shell_coplanar_face_merge flags1[]" );
	rt_free( (char *)flags2, "nmg_shell_coplanar_face_merge flags2[]" );
d973 1
a973 1
	tags = rt_calloc( m->maxindex+1, 1, "nmg_invert_shell() tags[]" );
d983 1
a983 1
	rt_free( tags, "nmg_invert_shell() tags[]" );
d2002 1
a2002 1
	trans_tbl = (long **)rt_calloc(tbl_size*2, sizeof(long *),
d2066 1
a2066 1
	rt_free((char *)trans_tbl, "nmg_dup_face trans_tbl");
d2484 1
a2484 1
			tab = (long *)rt_calloc( m->maxindex, sizeof(long),
d2497 1
a2497 1
			rt_free( (char *)tab, "nmg_cut_loop flag[] 1" );
d2556 1
a2556 1
		tab = (long *)rt_calloc( m->maxindex, sizeof(long),
d2569 1
a2569 1
		rt_free( (char *)tab, "nmg_cut_loop flag[] 2" );
d2985 1
a2985 1
 * rt_malloc/rt_free pairs for loops with no touching
d3288 1
a3288 1
			rt_free( (char *)visit_count, "nmg_loop_split_at_touching_jaunt: visit_count[]\n" );
d3290 1
a3290 1
			rt_free( (char *)jaunt_status, "nmg_loop_split_at_touching_jaunt: jaunt_status[]\n" );
d3318 1
a3318 1
			rt_free( (char *)visit_count, "nmg_loop_split_at_touching_jaunt: visit_count[]\n" );
d3320 1
a3320 1
			rt_free( (char *)jaunt_status, "nmg_loop_split_at_touching_jaunt: jaunt_status[]\n" );
d3347 1
a3347 1
		rt_free( (char *)visit_count, "nmg_loop_split_at_touching_jaunt: visit_count[]\n" );
d3349 1
a3349 1
		rt_free( (char *)jaunt_status, "nmg_loop_split_at_touching_jaunt: jaunt_status[]\n" );
d3351 1
a3351 1
	visit_count = (int *)rt_calloc( BU_PTBL_END( &jaunt_tbl ), sizeof( int ),
d3353 1
a3353 1
	jaunt_status = (int *)rt_calloc( BU_PTBL_END( &jaunt_tbl ), sizeof( int ),
@


11.38
log
@Moved extern into raytrace.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.37 1997/06/13 21:42:51 mike Exp mike $ (BRL)";
d1641 1
a1641 1
	NMG_CK_FACE_G_PLANE(fu->f_p->g.plane_p);
@


11.37
log
@rt_list_len became bu_list_len
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.36 1997/06/11 19:48:47 jra Exp mike $ (BRL)";
d31 3
a33 6
/* XXX move to raytrace.h */
RT_EXTERN(struct edgeuse	*nmg_find_e, (CONST struct vertex *v1,
				CONST struct vertex *v2,
				CONST struct shell *s,
				CONST struct edge *ep));

@


11.36
log
@Minor mod to nmg_unbreak_shell_edge_unsafe().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.35 1997/06/10 13:06:33 jra Exp jra $ (BRL)";
d4639 1
a4639 1
	if( rt_list_len( &eg->eu_hd2 ) < 2*2 )  {
@


11.35
log
@Added nmg_unbreak_shell_edge_unsafe().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.34 1997/04/16 20:27:32 jra Exp jra $ (BRL)";
a4857 7

	/* If the edge geometry doesn't have at least four edgeuses, this
	 * is not a candidate for unbreaking */		
	if( rt_list_len( &eg->eu_hd2 ) < 2*2 )  {
		ret = -2;
		goto out;
	}
@


11.34
log
@No changes to code operation.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.33 1996/12/30 13:39:33 jra Exp jra $ (BRL)";
d4673 224
@


11.33
log
@nmg_eusplit() was not handling share_geom=0 case correctly.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.32 1996/10/21 19:09:44 jra Exp jra $ (BRL)";
d3806 1
a3865 1

d3898 1
a3898 2
		bu_log(
"nmg_dup_loop(lu=x%x(%s), parent=x%x, trans_tbl=x%x) new_lu=x%x(%s)\n",
@


11.32
log
@Added tolerance arg to nmg_glufaces().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.31 1996/10/21 02:49:29 jra Exp jra $ (BRL)";
d4135 12
d4252 2
a4253 2
		/* Make eu2 use same geometry as oldeumate */
		nmg_use_edge_g( eu2, oldeumate->g.magic_p );
d4255 1
d4257 6
@


11.31
log
@modified nmg_glueedges() to use nmg_radial_join_eu() rather than nmg_je();.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.30 1996/09/27 08:27:30 mike Exp jra $ (BRL)";
d1496 1
a1496 1
nmg_gluefaces(fulist, n)
d1499 1
a1505 6
struct rt_tol tol;
       tol.magic = RT_TOL_MAGIC;
       tol.dist = 0.005;
       tol.dist_sq = tol.dist * tol.dist;
       tol.perp = 1e-6;
       tol.para = 1 - tol.perp;
d1542 1
a1542 1
								nmg_radial_join_eu(eu, eu2, &tol);
@


11.30
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.29 1996/05/29 12:38:31 jra Exp mike $ (BRL)";
d1505 6
a1540 2
					if( eu->radial_p != eu->eumate_p )  break;

d1547 1
a1547 1
							    	nmg_je(eu, eu2);
@


11.29
log
@nmg_join_2loops() was making incorrect assumption about orientation of final loopuse.
nmg_split_touchingloops() now avoids splitting at a crack if possible.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.28 1996/05/16 21:56:18 jra Exp jra $ (BRL)";
d41 1
a41 1
CONST struct rt_tol *tol;
d47 1
a47 1
	RT_CK_TOL( tol );
d56 1
a56 1
	while( RT_LIST_NON_EMPTY( &r2->s_hd ) )
d60 2
a61 2
		s = RT_LIST_FIRST( shell, &r2->s_hd );
		RT_LIST_DEQUEUE( &s->l );
d63 1
a63 1
		RT_LIST_APPEND( &r1->s_hd, &s->l );
d95 1
a95 1
CONST struct rt_tol	*tol;
d118 1
a118 1
	for( RT_LIST_FOR( fu1, faceuse, &s->fu_hd ) )  {
d121 1
a121 1
		if( RT_LIST_NEXT_IS_HEAD(fu1, &s->fu_hd) )  break;
d134 3
a136 3
		for( fu2 = RT_LIST_NEXT(faceuse, &fu1->l);
		     RT_LIST_NOT_HEAD(fu2, &s->fu_hd);
		     fu2 = RT_LIST_NEXT(faceuse,&fu2->l)
d163 1
a163 1
				 *  Can't just use RT_VECT_ARE_PARALLEL here,
d181 1
a181 1
				prev_fu = RT_LIST_PREV(faceuse, &fu2->l);
d183 1
a183 1
				if( RT_LIST_IS_HEAD(prev_fu, &s->fu_hd) )
d197 1
a197 1
				for (RT_LIST_FOR(lu, loopuse, &fu1->lu_hd))
d208 1
a208 1
		rt_log("nmg_shell_coplanar_face_merge(s=x%x, tol=x%x, simplify=%d)\n",
d232 1
a232 1
	for (RT_LIST_FOR(fu, faceuse, &s->fu_hd)) {
d235 1
a235 1
			fu = RT_LIST_PREV( faceuse, &fu->l );
d243 1
a243 1
		rt_log("nmg_simplify_shell(s=x%x) returns %d\n", s , ret_val);
d261 1
a261 1
CONST struct rt_tol *tol;
d270 1
a270 1
	RT_CK_TOL( tol );
d272 1
a272 1
	if( RT_LIST_NON_EMPTY( &s->fu_hd ) )  {
d274 2
a275 2
		lu = RT_LIST_FIRST( loopuse, &s->lu_hd );
		while( RT_LIST_NOT_HEAD( lu, &s->lu_hd ) )  {
d279 1
a279 1
			nextlu = RT_LIST_PNEXT( loopuse, lu );
d284 1
a284 1
					nextlu = RT_LIST_PNEXT(loopuse, nextlu);
d291 2
a292 2
		eu = RT_LIST_FIRST( edgeuse, &s->eu_hd );
		while( RT_LIST_NOT_HEAD( eu, &s->eu_hd ) )  {
d296 1
a296 1
			nexteu = RT_LIST_PNEXT( edgeuse, eu );
d300 1
a300 1
					nexteu = RT_LIST_PNEXT(edgeuse, nexteu);
d308 2
a309 2
	eu = RT_LIST_FIRST( edgeuse, &s->eu_hd );
	while( RT_LIST_NOT_HEAD( eu, &s->eu_hd ) )  {
d313 1
a313 1
		nexteu = RT_LIST_PNEXT( edgeuse, eu );
d317 1
a317 1
				nexteu = RT_LIST_PNEXT(edgeuse, nexteu);
d325 2
a326 2
	lu = RT_LIST_FIRST( loopuse, &s->lu_hd );
	while( RT_LIST_NOT_HEAD( lu, &s->lu_hd ) )  {
d329 2
a330 2
		nextlu = RT_LIST_PNEXT( loopuse, lu );
		magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
d335 1
a335 1
		vu = RT_LIST_PNEXT( vertexuse, &lu->down_hd );
d343 1
a343 1
				nextlu = RT_LIST_PNEXT(loopuse, nextlu);
d352 1
a352 1
	if( s->vu_p )  rt_log("nmg_rm_redundancies() lone vertex?\n");
d355 2
a356 2
	fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
	while( RT_LIST_NOT_HEAD( &fu->l, &s->fu_hd ) )
d366 1
a366 1
			fu = RT_LIST_NEXT( faceuse, &fu->l );
d370 1
a370 1
		next_fu = RT_LIST_NEXT( faceuse, &fu->l );
d372 1
a372 1
			next_fu = RT_LIST_NEXT( faceuse, &next_fu->l );
d374 2
a375 2
		lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
		while( RT_LIST_NOT_HEAD( &lu->l, &fu->lu_hd ) )
d383 1
a383 1
			next_lu = RT_LIST_NEXT( loopuse, &lu->l );
d385 1
a385 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d393 1
a393 1
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d397 2
a398 2
			lu1 = RT_LIST_FIRST( loopuse, &fu->lu_hd );
			while( RT_LIST_NOT_HEAD( &lu1->l, &fu->lu_hd ) )
d405 1
a405 1
				next_lu1 = RT_LIST_PNEXT( loopuse, &lu1->l );
d407 1
a407 1
				if( RT_LIST_FIRST_MAGIC( &lu1->down_hd ) != NMG_EDGEUSE_MAGIC )
d427 1
a427 1
				for( RT_LIST_FOR( eu, edgeuse, &lu1->down_hd ) )
d447 1
a447 1
					next_lu1 = RT_LIST_NEXT( loopuse, &next_lu1->l );
d450 1
a450 1
					next_lu = RT_LIST_NEXT( loopuse, &next_lu->l );
d480 1
a480 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d487 1
a487 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d494 2
a495 2
			lu1 = RT_LIST_FIRST( loopuse, &fu->lu_hd );
			while( RT_LIST_NOT_HEAD( &lu1->l, &fu->lu_hd ) )
d503 1
a503 1
				next_lu = RT_LIST_PNEXT( loopuse, &lu1->l );
d528 1
a528 1
				for( RT_LIST_FOR( lu2, loopuse, &fu->lu_hd ) )
d563 1
a563 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d568 1
a568 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d575 2
a576 2
			lu1 = RT_LIST_FIRST( loopuse, &fu->lu_hd );
			while( RT_LIST_NOT_HEAD( &lu1->l, &fu->lu_hd ) )
d581 1
a581 1
				next_lu = RT_LIST_PNEXT( loopuse, &lu1->l );
d602 1
a602 1
		rt_log("nmg_rm_redundancies(s=x%x)\n", s);
d625 2
a626 2
	fu = RT_LIST_FIRST(faceuse, &s->fu_hd);
	while (RT_LIST_NOT_HEAD(fu, &s->fu_hd) ) {
d630 2
a631 2
		lu = RT_LIST_FIRST(loopuse, &fu->lu_hd);
		while (RT_LIST_NOT_HEAD(lu, &fu->lu_hd)) {
d633 2
a634 2
				lu = RT_LIST_PNEXT(loopuse,lu);
				nmg_klu(RT_LIST_PLAST(loopuse, lu));
d636 1
a636 1
			    RT_LIST_FIRST_MAGIC(&lu->down_hd) ==
d639 1
a639 1
				vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d642 1
a642 1
				lu = RT_LIST_PNEXT(loopuse,lu);
d644 1
a644 1
				lu = RT_LIST_PNEXT(loopuse,lu);
d651 2
a652 2
		if (RT_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
			fu = RT_LIST_PNEXT_PNEXT(faceuse, fu);
d654 1
a654 1
			fu = RT_LIST_PNEXT(faceuse, fu);
d657 1
a657 1
		if (RT_LIST_IS_EMPTY( &(RT_LIST_PLAST(faceuse, fu))->lu_hd )) {
d661 1
a661 1
			nmg_kfu(RT_LIST_PLAST(faceuse, fu));
d666 2
a667 2
	lu = RT_LIST_FIRST(loopuse, &s->lu_hd);
	while (RT_LIST_NOT_HEAD(lu, &s->lu_hd) ) {
d669 2
a670 2
			lu = RT_LIST_PNEXT(loopuse,lu);
			nmg_klu(RT_LIST_PLAST(loopuse, lu));
d672 1
a672 1
		    RT_LIST_FIRST_MAGIC(&lu->down_hd) ==
d675 1
a675 1
			vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d678 1
a678 1
			lu = RT_LIST_PNEXT(loopuse,lu);
d680 1
a680 1
			lu = RT_LIST_PNEXT(loopuse,lu);
d685 1
a685 1
		rt_log("nmg_sanitize_s_lv(s=x%x, orient=%d)\n",	s, orient);
d701 1
a701 1
CONST struct rt_tol	*tol;
d707 1
a707 1
	RT_CK_TOL(tol);
d710 1
a710 1
		rt_log("nmg_s_split_touching_loops(s=x%x, tol=x%x) START\n", s, tol);
d714 2
a715 2
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d720 1
a720 1
	for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
d726 2
a727 2
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d734 1
a734 1
		rt_log("nmg_s_split_touching_loops(s=x%x, tol=x%x) END\n", s, tol);
d746 1
a746 1
CONST struct rt_tol	*tol;
d752 1
a752 1
	RT_CK_TOL(tol);
d755 1
a755 1
		rt_log("nmg_s_join_touching_loops(s=x%x, tol=x%x) START\n", s, tol);
d759 2
a760 2
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d764 1
a764 1
	for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
d769 2
a770 2
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d777 1
a777 1
		rt_log("nmg_s_join_touching_loops(s=x%x, tol=x%x) END\n", s, tol);
d796 1
a796 1
CONST struct rt_tol	*tol;
d808 1
a808 1
	RT_CK_TOL(tol);
d811 1
a811 1
		rt_log("nmg_js(s1=x%x, s2=x%x) START\n", s1, s2);
d821 2
a822 2
	fu2 = RT_LIST_FIRST( faceuse, &s2->fu_hd );
	while( RT_LIST_NOT_HEAD( fu2, &s2->fu_hd ) )  {
d825 1
a825 1
		nextfu = RT_LIST_PNEXT( faceuse, fu2 );
d838 1
a838 1
			nextfu = RT_LIST_PNEXT(faceuse, nextfu);
d848 1
a848 1
				rt_log("nmg_js(): shared face_g_plane, doing nmg_jf()\n");
d868 3
a870 3
	lu = RT_LIST_FIRST( loopuse, &s2->lu_hd );
	while( RT_LIST_NOT_HEAD( lu, &s2->lu_hd ) )  {
		nextlu = RT_LIST_PNEXT( loopuse, lu );
d875 1
a875 1
			nextlu = RT_LIST_PNEXT(loopuse, nextlu);
d888 3
a890 3
	eu = RT_LIST_FIRST( edgeuse, &s2->eu_hd );
	while( RT_LIST_NOT_HEAD( eu, &s2->eu_hd ) )  {
		nexteu = RT_LIST_PNEXT( edgeuse, eu );
d896 1
a896 1
			nexteu = RT_LIST_PNEXT(edgeuse, nexteu);
d915 1
a915 1
	if( RT_LIST_NON_EMPTY( &s2->fu_hd ) )  {
d918 1
a918 1
	if( RT_LIST_NON_EMPTY( &s2->lu_hd ) )  {
d921 1
a921 1
	if( RT_LIST_NON_EMPTY( &s2->eu_hd ) )  {
d938 1
a938 1
		rt_log("nmg_js(s1=x%x, s2=x%x) END\n", s1, s2);
d960 1
a960 1
CONST struct rt_tol	*tol;
d969 1
a969 1
	RT_CK_TOL(tol);
d972 1
a972 1
		rt_log("nmg_invert_shell(x%x)\n", s);
d978 1
a978 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
d1065 1
a1065 1
		rt_log("nmg_cmface(s=x%x, verts=x%x, n=%d.)\n",
d1072 1
a1072 1
		rt_log("nmg_cmface(s=x%x, verts=x%x, n=%d.) null pointer to array start\n",
d1085 1
a1085 1
			rt_log("nmg_cmface(s=x%x, verts=x%x, n=%d.) verts[%d]=NULL\n",
d1095 1
a1095 1
	vu = RT_LIST_FIRST( vertexuse, &lu->down_hd);
d1108 1
a1108 1
		euold = RT_LIST_FIRST( edgeuse, &lu->down_hd );
d1112 1
a1112 1
			rt_log("nmg_cmface() euold: %8x\n", euold);
d1125 1
a1125 1
					rt_log("nmg_cmface() found another edgeuse (%8x) between %8x and %8x\n",
d1129 1
a1129 1
				    rt_log("nmg_cmface() didn't find edge from verts[%d]%8x to verts[%d]%8x\n",
d1137 1
a1137 1
				rt_log("nmg_cmface() *verts[%d] was null, is now %8x\n",
d1148 1
a1148 1
			rt_log("nmg_cmface() didn't find edge from verts[%d]%8x to verts[%d]%8x\n",
d1155 1
a1155 1
		euold = RT_LIST_FIRST( edgeuse, &lu->down_hd );
d1158 1
a1158 1
			rt_log("ERROR nmg_cmface() lu first vert s/b x%x, was x%x\n",
d1161 1
a1161 1
				rt_log("  *verts[%2d]=x%x, eu->vu_p->v_p=x%x\n",
d1163 1
a1163 1
				euold = RT_LIST_PNEXT_CIRC( edgeuse, &euold->l );
d1170 1
a1170 1
		rt_log("nmg_cmface(s=x%x, verts[]=x%x, n=%d) fu=x%x\n",
d1217 1
a1217 1
		rt_log("nmg_cface(s=x%x, verts=x%x, n=%d.)\n",
d1230 1
a1230 1
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d1237 1
a1237 1
			eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
d1246 1
a1246 1
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d1253 1
a1253 1
		rt_log("nmg_cface(s=x%x, verts[]=x%x, n=%d) fu=x%x\n",
d1300 1
a1300 1
		rt_log("nmg_add_loop_to_face(s=x%x, verts=x%x, n=%d.)\n",
d1312 1
a1312 1
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d1318 1
a1318 1
			eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
d1330 1
a1330 1
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d1337 1
a1337 1
		rt_log("nmg_add_loop_to_face(s=x%x, fu=x%x, verts[]=x%x, n=%d, %s) fu=x%x\n",
d1394 1
a1394 1
CONST struct rt_tol	*tol;
d1402 1
a1402 1
	RT_CK_TOL(tol);
d1405 1
a1405 1
	lu = RT_LIST_FIRST(loopuse, &fu->lu_hd);
d1408 1
a1408 1
	if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
d1410 1
a1410 1
		rt_log( "nmg_fu_planeeqn(): First loopuse does not contain edges\n" );
d1413 1
a1413 1
	eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
d1422 1
a1422 1
		eu_next = RT_LIST_PNEXT_CIRC(edgeuse, eu_next);
d1426 1
a1426 1
			rt_log( "nmg_fu_planeeqn(): First loopuse contains only one edgeuse\n" );
d1434 1
a1434 1
		|| rt_pt3_pt3_equal(a->vg_p->coord, b->vg_p->coord, tol))
d1439 1
a1439 1
		eu_final = RT_LIST_PNEXT_CIRC(edgeuse, eu_final);
d1443 1
a1443 1
			rt_log( "nmg_fu_planeeqn(): Cannot find three distinct vertices\n" );
d1451 2
a1452 2
		    rt_pt3_pt3_equal(a->vg_p->coord, c->vg_p->coord, tol) ||
		    rt_pt3_pt3_equal(b->vg_p->coord, c->vg_p->coord, tol);
d1454 1
a1454 1
		|| rt_3pts_collinear(a->vg_p->coord, b->vg_p->coord,
d1458 1
a1458 1
	if (rt_mk_plane_3pts(plane,
d1460 1
a1460 1
		rt_log("nmg_fu_planeeqn(): rt_mk_plane_3pts failed on (%g,%g,%g) (%g,%g,%g) (%g,%g,%g)\n",
d1468 1
a1468 1
		rt_log("nmg_fu_planeeqn():  Bad plane equation from rt_mk_plane_3pts\n" );
d1476 1
a1476 1
		rt_log("nmg_fu_planeeqn(fu=x%x) ERROR, verts are not within tol of face\n" , fu );
d1481 1
a1481 1
		rt_log("nmg_fu_planeeqn(fu=x%x, tol=x%x)\n", fu, tol);
d1517 1
a1517 1
			rt_log("nmg_gluefaces() in %s at %d. faceuses don't share parent\n",
d1524 1
a1524 1
		for( RT_LIST_FOR( lu , loopuse , &fulist[i]->lu_hd ) ) {
d1527 1
a1527 1
			if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
d1530 1
a1530 1
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d1537 1
a1537 1
					for( RT_LIST_FOR( lu2 , loopuse , &fulist[f_no]->lu_hd ) ) {
d1539 1
a1539 1
						if( RT_LIST_FIRST_MAGIC(&lu2->down_hd) != NMG_EDGEUSE_MAGIC )
d1541 1
a1541 1
						for( RT_LIST_FOR( eu2, edgeuse, &lu2->down_hd ) )  {
d1552 1
a1552 1
		rt_log("nmg_gluefaces(fulist=x%x, n=%d)\n", fulist, n);
d1576 1
a1576 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))  {
d1580 1
a1580 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))  {
d1583 1
a1583 1
			lu = RT_LIST_PREV( loopuse, &lu->l );
d1588 1
a1588 1
	ret_val = RT_LIST_IS_EMPTY(&fu->lu_hd);
d1591 1
a1591 1
		rt_log("nmg_simplify_face(fut=x%x) return=%d\n", fu, ret_val);
d1653 1
a1653 1
			rt_log("nmg_reverse_face(fu=x%x) fu:SAME, fumate:%d\n",
d1662 1
a1662 1
			rt_log("nmg_reverse_face(fu=x%x) fu:OPPOSITE, fumate:%d\n",
d1671 1
a1671 1
		rt_log("ERROR nmg_reverse_face(fu=x%x), orientation=%d.\n",
d1676 1
a1676 1
		rt_log("nmg_reverse_face(fu=x%x) fumate=x%x\n", fu, fumate);
d1721 1
a1721 1
CONST struct rt_tol	*tol;
d1732 1
a1732 1
	RT_CK_TOL(tol);
d1740 1
a1740 1
	for( RT_LIST_FOR( lu , loopuse , &fu2->lu_hd ) )  {
d1744 1
a1744 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d1752 1
a1752 1
		for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )  {
d1802 1
a1802 1
rt_log("sbefore eu=x%x, before=x%x, eu=x%x, eumate=x%x, after=x%x\n",
d1817 1
a1817 1
				rt_log("nmg_face_fix_radial_parity() exchanging eu=x%x & eumate=x%x on edge x%x\n",
d1832 1
a1832 1
		rt_log("nmg_face_fix_radial_parity(fu=x%x) returns %d\n", fu, count);
d1857 1
a1857 1
		rt_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fu->s_p=x%x isnt src shell\n",
d1862 1
a1862 1
		rt_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fumate->s_p=x%x isn't src shell\n",
d1868 2
a1869 2
	RT_LIST_DEQUEUE( &fu->l );
	if( RT_LIST_IS_EMPTY( &src->fu_hd ) )  {
d1871 1
a1871 1
		rt_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fumate=x%x not in src shell\n",
d1877 1
a1877 1
	RT_LIST_DEQUEUE( &fumate->l );
d1884 2
a1885 2
		RT_LIST_APPEND( &dest->fu_hd, &fu->l );
		RT_LIST_APPEND( &fu->l, &fumate->l );
d1887 2
a1888 2
		RT_LIST_APPEND( &dest->fu_hd, &fumate->l );
		RT_LIST_APPEND( &fumate->l, &fu->l );
d1895 1
a1895 1
		rt_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x)\n", dest , src , fu);
d1919 3
a1921 3
	while( RT_LIST_WHILE( lu, loopuse, &src_fu->lu_hd ) )  {
		RT_LIST_DEQUEUE( &(lu->l) );
		RT_LIST_INSERT( &(dest_fu->lu_hd), &(lu->l) );
d1927 1
a1927 1
		rt_log("nmg_move_fu_fu(dest_fu=x%x, src_fu=x%x)\n", dest_fu , src_fu);
d1948 1
a1948 1
		rt_log("nmg_jf(dest_fu=x%x, src_fu=x%x)\n", dest_fu, src_fu);
d2009 1
a2009 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
d2011 1
a2011 1
			rt_log("nmg_dup_face() duping %s loop...",
d2034 1
a2034 1
			rt_log(".  Duped %s loop\n",
d2073 1
a2073 1
		rt_log("nmg_dup_face(fu=x%x, s=x%x) new_fu=x%x\n",
d2121 1
a2121 1
		rt_log("nmg_jl(lu=x%x, eu=x%x) lu2=x%x\n", lu, eu, lu2);
d2138 1
a2138 1
			rt_log("nmg_jl: lu2 = %s, lu = %s\n",
d2156 1
a2156 1
	nexteu = RT_LIST_PNEXT_CIRC(edgeuse, eu_r);
d2158 2
a2159 2
		RT_LIST_DEQUEUE(&nexteu->l);
		RT_LIST_INSERT(&eu->l, &nexteu->l);
d2162 2
a2163 2
		RT_LIST_DEQUEUE(&nexteu->eumate_p->l);
		RT_LIST_APPEND(&eu->eumate_p->l, &nexteu->eumate_p->l);
d2166 1
a2166 1
		nexteu = RT_LIST_PNEXT_CIRC(edgeuse, eu_r);
d2225 1
a2225 1
		rt_log("nmg_join_2loops(vu1=x%x, vu2=x%x) lu1=x%x, lu2=x%x\n",
d2245 1
a2245 1
		first_new_eu = RT_LIST_PPREV_CIRC(edgeuse, second_new_eu);
d2254 1
a2254 1
		first_new_eu = RT_LIST_PPREV_CIRC(edgeuse, second_new_eu);
d2268 3
a2270 3
	final_eu2 = RT_LIST_PPREV_CIRC(edgeuse, eu2 );
	while( RT_LIST_NON_EMPTY( &lu2->down_hd ) )  {
		eu2 = RT_LIST_PNEXT_CIRC(edgeuse, final_eu2);
d2272 2
a2273 2
		RT_LIST_DEQUEUE(&eu2->l);
		RT_LIST_INSERT(&second_new_eu->l, &eu2->l);
d2276 2
a2277 2
		RT_LIST_DEQUEUE(&eu2->eumate_p->l);
		RT_LIST_APPEND(&second_new_eu->eumate_p->l, &eu2->eumate_p->l);
d2310 1
a2310 1
		rt_log("nmg_join_singvu_loop(vu1=x%x, vu2=x%x) lu1=x%x, lu2=x%x\n",
d2327 1
a2327 1
	first_new_eu = RT_LIST_PLAST_CIRC(edgeuse, second_new_eu);
d2357 1
a2357 1
		rt_log("nmg_join_2singvu_loops(vu1=x%x, vu2=x%x) lu1=x%x, lu2=x%x\n",
d2374 1
a2374 1
	first_new_eu = RT_LIST_PLAST_CIRC(edgeuse, second_new_eu);
d2485 1
a2485 1
		rt_log("\tnmg_cut_loop\n");
d2492 1
a2492 1
			rt_log("nmg_cut_loop() plotting %s\n", name);
d2511 3
a2513 3
	nmg_kvu(RT_LIST_FIRST(vertexuse, &lu->down_hd));
	nmg_kvu(RT_LIST_FIRST(vertexuse, &lu->lumate_p->down_hd));
	/* nmg_kvu() does RT_LIST_INIT() on down_hd */
d2518 1
a2518 1
		eunext = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);
d2520 4
a2523 4
		RT_LIST_DEQUEUE(&eu->l);
		RT_LIST_INSERT(&lu->down_hd, &eu->l);
		RT_LIST_DEQUEUE(&eu->eumate_p->l);
		RT_LIST_APPEND(&lu->lumate_p->down_hd, &eu->eumate_p->l);
d2532 2
a2533 2
	RT_LIST_DEQUEUE(&neweu->l);
	RT_LIST_INSERT(&lu->down_hd, &neweu->l);
d2537 2
a2538 2
	RT_LIST_DEQUEUE(&neweu->eumate_p->l);
	RT_LIST_APPEND(&lu->lumate_p->down_hd, &neweu->eumate_p->l);
d2544 4
a2547 4
	RT_LIST_DEQUEUE(&eunext->l);
	RT_LIST_INSERT(&eu1->l, &eunext->l);
	RT_LIST_DEQUEUE(&eunext->eumate_p->l);
	RT_LIST_APPEND(&eu1->eumate_p->l, &eunext->eumate_p->l);
d2564 1
a2564 1
		rt_log("nmg_cut_loop() plotting %s\n", name);
d2577 1
a2577 1
		rt_log("nmg_cut_loop(vu1=x%x, vu2=x%x) old_lu=x%x, new_lu=x%x\n",
d2650 3
a2652 3
	nmg_kvu(RT_LIST_FIRST(vertexuse, &newlu->down_hd));
	nmg_kvu(RT_LIST_FIRST(vertexuse, &newlumate->down_hd));
	/* nmg_kvu() does RT_LIST_INIT() on down_hd */
d2657 1
a2657 1
		eunext = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);
d2659 4
a2662 4
		RT_LIST_DEQUEUE(&eu->l);
		RT_LIST_INSERT(&newlu->down_hd, &eu->l);
		RT_LIST_DEQUEUE(&eu->eumate_p->l);
		RT_LIST_APPEND(&newlumate->down_hd, &eu->eumate_p->l);
d2679 1
a2679 1
		rt_log("nmg_split_lu_at_vu( lu=x%x, split_vu=x%x ) newlu=x%x\n",
d2721 1
a2721 1
	for( RT_LIST_FOR( tvu, vertexuse, &v->vu_hd ) )  {
d2754 1
a2754 1
CONST struct rt_tol	*tol;
d2762 1
a2762 1
	RT_CK_TOL(tol);
d2764 1
a2764 1
		rt_log("nmg_split_touchingloops( lu=x%x )\n", lu);
d2767 1
a2767 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d2773 1
a2773 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d2786 1
a2786 1
		for( RT_LIST_FOR( other_vu, vertexuse, &vu->v_p->vu_hd ) )
d2851 1
a2851 1
		for( RT_LIST_FOR( tvu, vertexuse, &v->vu_hd ) )  {
d2906 1
a2906 1
		rt_log("nmg_join_touchingloops( lu=x%x )\n", lu);
d2913 1
a2913 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d2917 1
a2917 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d2931 1
a2931 1
		for( RT_LIST_FOR( tvu, vertexuse, &v->vu_hd ) )  {
d2945 1
a2945 1
				rt_log("INFO: nmg_join_touchingloops() lu=x%x touches itself at vu1=x%x, vu2=x%x, skipping\n",
d2960 1
a2960 1
				rt_log("nmg_join_touchingloops(): lu=x%x, vu=x%x, tvu=x%x\n", lu, vu, tvu);
d2986 1
a2986 1
 * The passed pointer to an nmg_ptbl structure may
d2997 1
a2997 1
struct nmg_ptbl *tbl;
d3005 1
a3005 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d3008 1
a3008 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d3012 2
a3013 2
		eu2 = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);
		eu3 = RT_LIST_PNEXT_CIRC(edgeuse, &eu2->l);
d3028 1
a3028 1
			nmg_tbl( tbl, TBL_INIT, (long *)NULL );
d3032 1
a3032 1
		nmg_tbl( tbl, TBL_INS, (long *)eu );
d3071 1
a3071 1
CONST struct nmg_ptbl *jaunt_tbl;
d3081 1
a3081 1
	NMG_CK_PTBL( jaunt_tbl );
d3084 1
a3084 1
	for( j=0 ; j< NMG_TBL_END( jaunt_tbl ) ; j++ )
d3092 1
a3092 1
		for( j=0 ; j<NMG_TBL_END( jaunt_tbl ) ; j++ )
d3100 1
a3100 1
			jaunt_eu = (struct edgeuse *)NMG_TBL_GET( jaunt_tbl, j );
d3114 1
a3114 1
		loop_eu = RT_LIST_PNEXT_CIRC(edgeuse, &loop_eu->l);
d3128 1
a3128 1
	for( j=0 ; j<NMG_TBL_END( jaunt_tbl ) ; j++ )
d3140 1
a3140 1
	for( j=0 ; j<NMG_TBL_END( jaunt_tbl ) ; j++ )
d3145 2
a3146 2
		jaunt_eu = (struct edgeuse *)NMG_TBL_GET( jaunt_tbl, j );
		jaunt_eu2 = RT_LIST_PNEXT_CIRC( edgeuse, &jaunt_eu->l );
d3166 1
a3166 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d3172 1
a3172 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d3176 1
a3176 1
		eu2 = RT_LIST_PPREV_CIRC( edgeuse, &eu->l );
d3187 1
a3187 1
			for( RT_LIST_FOR( eu3, edgeuse, &lu->down_hd ) )
d3209 1
a3209 1
			rt_log( "Killing jaunt in accordion eu's x%x and x%x\n", jaunt_eu1, jaunt_eu2 );
d3216 1
a3216 1
			rt_log( "Killing jaunt in accordion eu x%x\n", jaunt_eu1 );
d3240 1
a3240 1
CONST struct rt_tol	*tol;
d3242 1
a3242 1
	struct nmg_ptbl		jaunt_tbl;
d3255 1
a3255 1
	RT_CK_TOL(tol);
d3258 1
a3258 1
		rt_log("nmg_loop_split_at_touching_jaunt( lu=x%x ) START\n", lu);
d3272 1
a3272 1
		rt_log( "nmg_loop_split_at_touching_jaunt: found %d touching jaunts in lu x%x\n", jaunt_count, lu );
d3275 1
a3275 1
			for( i=0 ; i<NMG_TBL_END( &jaunt_tbl ) ; i++ )
d3277 2
a3278 2
				eu = (struct edgeuse *)NMG_TBL_GET( &jaunt_tbl, i );
				rt_log( "\tx%x\n" , eu );
d3285 1
a3285 1
		rt_log( "nmg_loop_split_at_touching_jaunt: nmg_get_touching_jaunts() returned %d for lu x%x\n", jaunt_count, lu );
d3296 1
a3296 1
			nmg_tbl( &jaunt_tbl, TBL_FREE, (long *)NULL );
d3299 1
a3299 1
			rt_log("nmg_loop_split_at_touching_jaunt( lu=x%x ) END count=%d\n",
d3308 1
a3308 1
		NMG_CK_PTBL( &jaunt_tbl );
d3310 1
a3310 1
		eu = (struct edgeuse *)NMG_TBL_GET( &jaunt_tbl, 0 );
d3312 1
a3312 1
		eu2 = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);
d3320 1
a3320 1
		nmg_tbl( &jaunt_tbl, TBL_FREE, (long *)NULL );
d3327 1
a3327 1
			rt_log("nmg_loop_split_at_touching_jaunt( lu=x%x ) END count=%d\n",
d3348 1
a3348 1
	NMG_CK_PTBL( &jaunt_tbl );
d3355 1
a3355 1
	visit_count = (int *)rt_calloc( NMG_TBL_END( &jaunt_tbl ), sizeof( int ),
d3357 1
a3357 1
	jaunt_status = (int *)rt_calloc( NMG_TBL_END( &jaunt_tbl ), sizeof( int ),
d3361 1
a3361 1
	for( jaunt_no=0 ; jaunt_no<NMG_TBL_END( &jaunt_tbl ) ; jaunt_no++ )
d3368 1
a3368 1
		for( i=0 ; i<NMG_TBL_END( &jaunt_tbl ) ; i++ )
d3372 1
a3372 1
		eu = (struct edgeuse *)NMG_TBL_GET( &jaunt_tbl, jaunt_no );
d3376 1
a3376 1
		start_eu1 = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);
d3380 2
a3381 2
			rt_log( "\tConsider splitting lu x%x at vu=x%x\n", lu, start_eu1->vu_p );
			rt_log( "\t\t(jaunt number %d\n" , jaunt_no );	
d3394 1
a3394 1
			for( i=0 ; i<NMG_TBL_END( &jaunt_tbl ) ; i++ )
d3398 2
a3399 2
				tmp_eu = (struct edgeuse *)NMG_TBL_GET( &jaunt_tbl, i );
				rt_log( "\t\tpredicted status of jaunt at eu x%x is ", tmp_eu );
d3403 1
a3403 1
						rt_log( "unknown\n" );
d3406 1
a3406 1
						rt_log( "split\n" );
d3409 1
a3409 1
						rt_log( "a jaunt\n" );
d3412 1
a3412 1
						rt_log( "still a touching jaunt\n" );
d3415 1
a3415 1
						rt_log( "unrecognized status\n" );
d3425 1
a3425 1
		for( i=0 ; i<NMG_TBL_END( &jaunt_tbl ) ; i++ )
d3439 1
a3439 1
				rt_log( "\t\tCannot split lu x%x at proposed vu\n" );
d3445 1
a3445 1
		eu2 = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);
d3451 2
a3452 2
			rt_log( "\tnmg_loop_split_at_touching_jaunt: splitting lu x%x at vu x%x\n", lu, eu2->vu_p );
			rt_log( "\t\tnew_lu is x%x\n" , new_lu );
d3459 1
a3459 1
		nmg_tbl( &jaunt_tbl, TBL_RST, (long *)NULL );
d3469 1
a3469 1
	rt_log( "nmg_loop_split_at_touching_jaunt: Could not find a way to split lu x%x\n", lu );
d3491 1
a3491 1
		rt_log("nmg_simplify_loop(lu=x%x)\n", lu);
d3494 1
a3494 1
	if (RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC)
d3497 2
a3498 2
	eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
	while (RT_LIST_NOT_HEAD(eu, &lu->down_hd) ) {
d3524 1
a3524 1
			    	eu = RT_LIST_PNEXT(edgeuse, eu);
d3532 1
a3532 1
		    	tmpeu = RT_LIST_PLAST(edgeuse, eu);
d3551 1
a3551 1
		eu = RT_LIST_PNEXT(edgeuse, eu);
d3575 1
a3575 1
		rt_log("nmg_kill_snakes(lu=x%x)\n", lu);
d3577 1
a3577 1
	if (RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC)
d3580 2
a3581 2
	eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
	while (RT_LIST_NOT_HEAD(eu, &lu->down_hd) ) {
d3596 1
a3596 1
		    RT_LIST_PNEXT_CIRC(edgeuse, eu) == eu_r) {
d3603 2
a3604 2
			vu = RT_LIST_FIRST(vertexuse, &v->vu_hd);
			while (RT_LIST_NOT_HEAD(vu, &v->vu_hd) &&
d3607 1
a3607 1
				vu = RT_LIST_PNEXT(vertexuse, vu);
d3609 1
a3609 1
			if (! RT_LIST_NOT_HEAD(vu, &v->vu_hd) ) {
d3613 1
a3613 1
				if( RT_LIST_IS_EMPTY( &lu->down_hd ) )
d3615 1
a3615 1
				eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
d3628 1
a3628 1
				eu = RT_LIST_PNEXT(edgeuse, eu);
d3630 1
a3630 1
			eu = RT_LIST_PNEXT(edgeuse, eu);
d3654 1
a3654 1
		rt_log("nmg_mv_lu_between_shells(dest=x%x, src=x%x, lu=x%x), lu->up.s_p=x%x isn't source shell\n",
d3659 1
a3659 1
		rt_log("nmg_mv_lu_between_shells(dest=x%x, src=x%x, lu=x%x), lumate->up.s_p=x%x isn't source shell\n",
d3665 2
a3666 2
	RT_LIST_DEQUEUE( &lu->l );
	if( RT_LIST_IS_EMPTY( &src->lu_hd ) )  {
d3668 1
a3668 1
		rt_log("nmg_mv_lu_between_shells(dest=x%x, src=x%x, lu=x%x), lumate=x%x not in src shell\n",
d3674 1
a3674 1
	RT_LIST_DEQUEUE( &lumate->l );
d3677 2
a3678 2
	RT_LIST_APPEND( &dest->lu_hd, &lu->l );
	RT_LIST_APPEND( &lu->l, &lumate->l );
d3684 1
a3684 1
		rt_log("nmg_mv_lu_between_shells(dest=x%x, src=x%x, lu=x%x)\n",
d3705 1
a3705 1
		rt_log("nmg_moveltof() in %s at %d. Cannot move loop to face in another shell\n",
d3708 1
a3708 1
	lu1 = RT_LIST_FIRST(loopuse, &s->lu_hd);
d3710 1
a3710 1
	RT_LIST_DEQUEUE( &lu1->l );
d3712 1
a3712 1
	lu2 = RT_LIST_FIRST(loopuse, &s->lu_hd);
d3714 1
a3714 1
	RT_LIST_DEQUEUE( &lu2->l );
d3716 2
a3717 2
	RT_LIST_APPEND( &fu->lu_hd, &lu1->l );
	RT_LIST_APPEND( &fu->fumate_p->lu_hd, &lu2->l );
d3721 1
a3721 1
		rt_log("nmg_moveltof(fu=x%x, s=x%x)\n",
d3751 2
a3752 2
	if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
		old_vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d3762 1
a3762 1
			rt_log("%s %d: I asked for a %s loop not a %s loop.\n",
d3770 1
a3770 1
			rt_log("nmg_dup_loop() existing vertex in new model\n");
d3774 1
a3774 1
		rt_log("nmg_dup_loop() new vertex in new model\n");
d3776 1
a3776 1
		new_vu = RT_LIST_FIRST(vertexuse, &new_lu->down_hd);
d3786 1
a3786 1
			rt_log("nmg_dup_loop(lu=x%x, parent=x%x, trans_tbl=x%x) new_lu=x%x\n",
d3795 1
a3795 1
	for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d3811 1
a3811 1
				rt_log("%s %d: I asked for a %s loop not a %s loop.\n",
d3818 1
a3818 1
			new_vu = RT_LIST_FIRST(vertexuse, &new_lu->down_hd);
d3833 1
a3833 1
			new_eu = RT_LIST_LAST(edgeuse, &new_lu->down_hd);
d3872 1
a3872 1
		for(RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d3891 1
a3891 1
	for(RT_LIST_FOR(new_eu, edgeuse, &new_lu->down_hd)) {
d3899 1
a3899 1
		rt_log(
d3922 1
a3922 1
		rt_log("nmg_set_lu_orientation(lu=x%x, %s)\n",
d3959 1
a3959 1
		rt_log("nmg_lu_reorient(lu=x%x)\n", lu);
d3964 1
a3964 1
	    RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )
d3975 1
a3975 1
			rt_log("nmg_lu_reorient() selecting other fu=x%x, lu=x%x\n", fu, lu);
d3999 1
a3999 1
		rt_log("nmg_lu_reorient(x%x):  changing orientation: %s to %s\n",
d4114 8
a4121 8
		if( RT_LIST_PNEXT(edgeuse, oldeu) != oldeumate )  {
			RT_LIST_DEQUEUE( &oldeumate->l );
			RT_LIST_APPEND( &oldeu->l, &oldeumate->l );
		}
		RT_LIST_DEQUEUE( &eu1->l );
		RT_LIST_DEQUEUE( &eu2->l );
		RT_LIST_APPEND( &oldeumate->l, &eu1->l );
		RT_LIST_APPEND( &eu1->l, &eu2->l );
d4140 1
a4140 1
		rt_log("nmg_eusplit() in %s at %d invalid edgeuse parent\n",
d4189 4
a4192 4
	RT_LIST_DEQUEUE( &eu1->l );
	RT_LIST_DEQUEUE( &eu2->l );
	RT_LIST_APPEND( &oldeu->l, &eu1->l );
	RT_LIST_APPEND( &oldeumate->l, &eu2->l );
d4250 1
a4250 1
		rt_log("nmg_eusplit(v=x%x, eu=x%x, share=%d) new_eu=x%x, mate=x%x\n",
d4341 1
a4341 1
		rt_log("WARNING: nmg_esplit(v=x%x) vertex is already an edge vertex\n", v);
d4392 2
a4393 2
			rt_log("nmg_esplit(v=x%x, e=x%x)\n", v, e);
			rt_log("nmg_esplit: teuX->vu_p->v_p=x%x, vA=x%x, vB=x%x\n", teuX->vu_p->v_p, vA, vB );
d4402 1
a4402 1
			rt_log("nmg_esplit(v=x%x, eu=x%x, share=%d) neu2=x%x\n",
d4409 1
a4409 1
			rt_log("nmg_esplit(v=x%x, eu=x%x, share=%d) neu1=x%x\n",
d4448 1
a4448 1
		rt_log("nmg_ebreak( v=x%x, eu=x%x ) new_eu=x%x\n",
d4469 1
a4469 1
CONST struct rt_tol	*tol;
d4475 1
a4475 1
	RT_CK_TOL(tol);
d4491 1
a4491 1
				rt_log("nmg_ebreaker() joining eu=x%x to oeu=x%x\n",
d4503 1
a4503 1
				rt_log("nmg_ebreaker() joining new_eu=x%x to oeu=x%x\n",
d4511 2
a4512 2
if( nmg_check_radial( eu, tol ) ) rt_log("ERROR ebreaker eu=x%x bad\n", eu);
if( nmg_check_radial( new_eu, tol ) ) rt_log("ERROR ebreaker new_eu=x%x bad\n", new_eu);
d4515 1
a4515 1
		rt_log("nmg_ebreaker( v=x%x, eu=x%x ) new_eu=x%x\n", v, eu, new_eu);
d4545 1
a4545 1
		rt_log("nmg_e2break( eu1=x%x, eu2=x%x ) v=x%x\n", eu1, eu2, v);
d4614 1
a4614 1
		rt_log( "nmg_unbreak_edge: no geometry for edge1 x%x\n" , e1 );
d4631 1
a4631 1
	eu2 = RT_LIST_PNEXT_CIRC( edgeuse , eu1 );
d4633 1
a4633 1
		rt_log( "nmg_unbreak_edge: second eu geometry x%x does not match geometry x%x of edge1 x%x\n" ,
d4645 1
a4645 1
	for( RT_LIST_FOR( vu , vertexuse , &vb->vu_hd ) )  {
d4673 1
a4673 1
		teu2 = RT_LIST_PNEXT_CIRC( edgeuse, teu );
d4697 1
a4697 1
		rt_log("nmg_unbreak_edge va=x%x, vb=x%x, vc=x%x\n",
d4699 1
a4699 1
		rt_log("nmg_unbreak_edge A:(%g, %g, %g), B:(%g, %g, %g), C:(%g, %g, %g)\n",
d4707 1
a4707 1
		/* rt_log( "nmg_unbreak_edge( eu=%x ): Trying to break a jaunt, va==vc (%x)\n", eu1_first, va ); */
d4717 1
a4717 1
			rt_log( "nmg_unbreak_edge: eu1 does not got to/from correct vertices, x%x, %x\n", 
d4722 1
a4722 1
		eu2 = RT_LIST_PNEXT_CIRC( edgeuse, eu1 );
d4728 1
a4728 1
			rt_log( "nmg_unbreak_edge: about to kill eu2, but does not got to/from correct vertices, x%x, x%x\n",
d4738 1
a4738 1
			rt_log( "nmg_unbreak_edge: extended eu1 does not got to/from correct vertices, x%x, x%x\n",
d4744 1
a4744 1
		if( eu2 != RT_LIST_PNEXT_CIRC( edgeuse, eu1 ) )
d4752 1
a4752 1
			rt_log( "nmg_unbreak_edge: unbroken eu1 (after eu2 killed) does not got to/from correct vertices, x%x, x%x\n",
d4762 1
a4762 1
		rt_log("nmg_unbreak_edge(eu=x%x, vb=x%x) ret = %d\n",
d4830 2
a4831 2
		RT_LIST_DEQUEUE( &eu1->l );
		RT_LIST_DEQUEUE( &eu2->l );
d4833 2
a4834 2
		RT_LIST_INSERT( &eu->l, &eu1->l );
		RT_LIST_APPEND( &eumate->l, &eu2->l );
d4843 1
a4843 1
		rt_log("nmg_eins(eu=x%x) eu1=x%x\n", eu, eu1);
d4866 1
a4866 1
		rt_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eu->up.s_p=x%x isnt src shell\n",
d4871 1
a4871 1
		rt_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eumate->up.s_p=x%x isn't src shell\n",
d4877 2
a4878 2
	RT_LIST_DEQUEUE( &eu->l );
	if( RT_LIST_IS_EMPTY( &src->eu_hd ) )  {
d4880 1
a4880 1
		rt_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eumate=x%x not in src shell\n",
d4886 1
a4886 1
	RT_LIST_DEQUEUE( &eumate->l );
d4889 2
a4890 2
	RT_LIST_APPEND( &dest->eu_hd, &eu->l );
	RT_LIST_APPEND( &eu->l, &eumate->l );
d4896 1
a4896 1
		rt_log("nmg_mv_eu_between_shells( dest=x%x, src=x%x, eu=x%x ) new_eu=x%x\n",
d4923 1
a4923 1
		rt_log("nmg_mv_vu_between_shells( dest_s=x%x, src_s=x%x, vu=x%x )\n",
@


11.28
log
@Eliminated unused tolerance arg to nmg_lu_reorient().
Added a call to nmg_lu_reorient() in nmg_jl().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.27 1996/04/26 15:06:18 jra Exp jra $ (BRL)";
a729 1
rt_log( "Reoriented lu x%x to %s\n", lu, nmg_orientation( lu->orientation ) );
a2234 10
	/* Joining same & opp gives same.  */
	if( lu1->orientation != lu2->orientation )  {
		if( lu1->orientation == OT_SAME || lu2->orientation == OT_SAME )
			new_orient = OT_SAME;
		else
			new_orient = OT_UNSPEC;
	} else {
		new_orient = lu1->orientation;
	}

d2281 1
a2281 1
	lu1->orientation = lu1->lumate_p->orientation = new_orient;
d2758 2
d2770 2
d2774 4
a2777 1
		struct loopuse		*newlu;
d2784 20
d2820 19
d2880 1
a2881 1
	}
d3988 3
@


11.27
log
@Added code to nmg_rm_redundancies() to kill matching OT_SAME/OT_OPPOSITE lu's in same face,
this can happen during intersection operation.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.26 1996/04/22 12:19:01 jra Exp jra $ (BRL)";
d729 2
a730 1
			nmg_lu_reorient( lu, tol );
d773 1
a773 1
			nmg_lu_reorient( lu, tol );
d2098 1
d2182 1
d3912 1
a3912 1
nmg_lu_reorient( lu, tol )
a3913 1
CONST struct rt_tol	*tol;
a3921 1
	RT_CK_TOL(tol);
d3924 1
a3924 1
		rt_log("nmg_lu_reorient(lu=x%x, tol)\n", lu);
d3953 1
a3953 6
#if 0
	if( lu_pl[X] == 0.0 && lu_pl[Y] == 0.0 && lu_pl[Z] == 0.0 )
	{
		rt_log( "Loop is a crack\n" );
	}
#endif
@


11.26
log
@nmg_shell_coplanar_face_merge() now requires vertices to be within tolerance of merged face.
Also fixed a debug message in nmg_cmface().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.25 1996/03/25 20:50:02 jra Exp jra $ (BRL)";
d353 125
@


11.25
log
@Added code to nmg_rm_redundancies() to kill identical loops with opposite orientations.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.24 1996/03/07 20:28:41 jra Exp jra $ (BRL)";
d169 2
d1001 1
a1001 1
						eur, *verts[i+1], *verts[i]);
d1005 1
a1005 1
					i+1, *verts[i+1], i, *verts[i]);
@


11.24
log
@Added nmg_merge_regions().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.23 1996/03/05 21:35:42 jra Exp jra $ (BRL)";
d352 1
a352 1
	/* get rid of redundant loops in same fu OT_SAME within an OT_SAME, etc. */
d398 1
a398 1
				 * orientation beyween them.
d433 41
d3825 1
d3830 1
@


11.23
log
@Added code to nmg_rm_redundancies() to kill loops within loops of same
orientation. Added nmg_kill_accordions(). Re-wrote nmg_lu_reorient().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.20 1995/11/30 17:27:35 mike Exp $ (BRL)";
d37 32
@


11.22
log
@That wasn't such a great idea after all.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.21 1996/02/14 15:56:35 jra Exp jra $ (BRL)";
d136 1
a155 4
#if 0
			/* recalculate face geometry */
			nmg_calc_face_g( fu1 );
#endif
d225 1
a225 1
nmg_rm_redundancies(s)
d227 1
d229 1
d236 1
d320 81
d1787 1
d1841 2
a1842 1
		nmg_face_g(new_fu, fu->f_p->g.plane_p->N);
d2917 69
d3021 1
d3024 3
d3717 1
d3750 5
a3754 81
	ccw = nmg_loop_is_ccw( lu, norm, tol );
	if( ccw == 0 )  {
		int	class;
		/* Loop does not have 3 linearly independent vertices, can't tell. */
		if (rt_g.NMG_debug & DEBUG_BASIC)
		{
			rt_log("nmg_lu_reorient:  unable to determine orientation from geometry\n");
			nmg_pr_lu_briefly( lu , "\t" );
		}
		class = nmg_class_lu_fu( lu, tol );
		switch( class )  {
		case NMG_CLASS_AinB:
			/* An interior "hole crack" */
			geom_orient = OT_OPPOSITE;
			break;
		case NMG_CLASS_AoutB:
			/* An exterior "solid crack" */
			geom_orient = OT_SAME;
			break;
		case NMG_CLASS_AonBshared:
			/* ALL vu's touch other loops in face. */
			if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
				/* Lone vertex that touches lu.  Call it solid. */
				geom_orient = OT_SAME;
			} else {
				/* Decide by calculating midpoint */
				point_t		mid;
				struct edgeuse	*eu;
				struct vertex	*v1, *v2;

				eu = RT_LIST_NEXT(edgeuse, &lu->down_hd);
				NMG_CK_EDGEUSE(eu);
				v1 = eu->vu_p->v_p;
				NMG_CK_VERTEX(v1);

				while( RT_LIST_NOT_HEAD(&eu->l, &lu->down_hd) )  {
					v2 = eu->vu_p->v_p;
					NMG_CK_VERTEX(v2);
					if( v2 != v1 )  goto found;
					eu = RT_LIST_NEXT(edgeuse, &eu->l);
				}
				rt_bomb("nmg_lu_reorient() no 2nd vertex?\n");
found:
				VADD2SCALE( mid, v1->vg_p->coord, v2->vg_p->coord, 0.5 );
				class = nmg_class_pt_fu_except( mid, fu, lu,
					NULL, NULL, NULL, 0, tol );
#if 0
rt_log("nmg_lu_reorient() eu midpoint=(%g, %g, %g), class=%s\n", V3ARGS(mid), nmg_class_name(class) );
#endif
				switch( class )  {
				case NMG_CLASS_AinB:
					/* An interior point, must be a hole */
					geom_orient = OT_OPPOSITE;
					break;
				case NMG_CLASS_AoutB:
					/* An exterior "solid point" */
					geom_orient = OT_SAME;
					break;
				case NMG_CLASS_AonBshared:
					rt_log("nmg_lu_reorient() bad luck, midpoint didn't break edge, but is ON an edge.  Assume OT_UNSPEC\n");
					geom_orient = OT_UNSPEC;
					break;
				default:
					rt_bomb("nmg_lu_reorient() bad class from nmg_class_pt_f\n");
				}
			}
			break;
		default:
			rt_bomb("nmg_lu_reorient() bad class from nmg_class_lu_fu()\n");
		}
		if( rt_g.NMG_debug & DEBUG_BASIC )  {
			rt_log("nmg_lu_reorient() class=%s, orient=%s\n",
				nmg_class_name(class),
				nmg_orientation(geom_orient) );
		}
	} else {
		if( ccw > 0 )  {
			geom_orient = OT_SAME;	/* same as face (OT_SAME faceuse) */
		} else {
			geom_orient = OT_OPPOSITE;
		}
d3756 4
@


11.21
log
@Added a call to nmg_calc_face_g() to nmg_shell_coplanar_face_merge(). Refines face geometry as
faces are merged.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.20 1995/11/30 17:27:35 mike Exp jra $ (BRL)";
d155 1
a155 1

d158 1
@


11.20
log
@If only 1 vertex is provided, don't dump core.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.17 1995/11/22 21:27:04 jra Exp $ (BRL)";
d155 3
@


11.19
log
@Fixed nmg_cmface() so that order of verts on lu's eu list
is the same as the order of verts in caller's original array.
Otherwise it's impossible to make the proper associations!
@
text
@d858 8
a865 6
	if (eur = nmg_findeu(*verts[0], *verts[1], s, euold, 1))  {
		nmg_je(eur, euold);
	} else  {
	    if (rt_g.NMG_debug & DEBUG_CMFACE)
		rt_log("nmg_cmface() didn't find edge from verts[%d]%8x to verts[%d]%8x\n",
			0, *verts[0], 1, *verts[1]);
@


11.18
log
@Added support for copying snurb faces
@
text
@d761 3
d806 1
a806 1
	lu = nmg_mlv(&s->l.magic, *verts[n-1], OT_SAME);
a813 1
	euold = eu;
d815 1
a815 1
	if (!(*verts[n-1]))  {
d818 1
a818 1
		*verts[n-1] = eu->vu_p->v_p;
d821 1
a821 1
	for (i = n-2 ; i >= 0 ; i--) {
d834 1
a834 1
			eur = nmg_findeu(*verts[i+1], *verts[i], s, euold, 1);
d858 1
a858 1
	if (eur = nmg_findeu(*verts[n-1], *verts[0], s, euold, 1))  {
d863 1
a863 1
			n-1, *verts[n-1], 0, *verts[0]);
d865 17
@


11.17
log
@Minor change to nmg_cmface() to allow building face with one vertex.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.16 1995/03/09 13:33:09 jra Exp jra $ (BRL)";
d29 1
d1731 26
a1756 6
	if (fu->f_p->g.plane_p) {
		plane_t		n;
		if( fu->orientation == OT_SAME )  {
			NMG_GET_FU_PLANE( n, fu );
		} else {
			NMG_GET_FU_PLANE( n, fu->fumate_p );
a1757 1
		nmg_face_g(new_fu, n);
@


11.16
log
@Added check to nmg_unbreak_edge() to avoid breaking a jaunt.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.15 95/03/02 14:33:25 mike Exp $ (BRL)";
d810 1
@


11.15
log
@Added extra checking.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.14 95/03/01 06:20:54 mike Exp Locker: mike $ (BRL)";
d4253 1
a4253 1
	/* if the edge geometry doesn't have at least four edgeuses, this
d4337 8
@


11.14
log
@Changed over to use nmg_s_radial_harmonize()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.13 95/02/28 04:16:35 mike Exp Locker: mike $ (BRL)";
d4110 1
d4142 2
@


11.13
log
@Turned off code to some (maybe) bogus stuff.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.12 95/02/28 00:15:48 mike Exp Locker: mike $ (BRL)";
a553 5
#if 0
		/* First, ensure faceuse orientation parity is harmonious */
		nmg_fu_harmonize_radial_parity( fu2, s1, tol );
#endif

a627 2
	if( rt_g.NMG_debug & DEBUG_VERIFY )
		nmg_vshell( &s1->r_p->s_hd, s1->r_p );
d645 6
d1372 1
d1374 1
a1374 63
 *			N M G _ E U _ H A R M O N I Z E _ R A D I A L _ P A R I T Y
 *
 *  Note that since this routine is called in the middle of shuffling
 *  faces between shells, it can't use nmg_eu_2s_orient_bad() on just
 *  one of the shells, it must do both at once.
 *
 *  If the parity around eu1 isn't good now while some parts are still in s2,
 *  it won't get any better after re-labeling everything into s1.
 *  So fix it here.
 */
void
nmg_eu_harmonize_radial_parity( eu1, s2, tol )
struct edgeuse		*eu1;
struct shell		*s2;
CONST struct rt_tol	*tol;
{
	struct shell	*s1;

	NMG_CK_EDGEUSE(eu1);
	NMG_CK_SHELL(s2);
	RT_CK_TOL(tol);

	s1 = nmg_find_s_of_eu( eu1 );
	if( s1 == s2 )  rt_bomb("nmg_eu_harmonize_radial_parity() s1==s2\n");

	if( nmg_eu_2s_orient_bad( eu1, s1, s2, tol ) )  {
		/* XXX Take remedial action */
		rt_bomb("nmg_eu_harmonize_radial_parity() bad combined radial parity\n");
	}
}

/*
 *			N M G _ F U _ H A R M O N I Z E _ R A D I A L _ P A R I T Y
 */
int	/* XXX s/b void */
nmg_fu_harmonize_radial_parity( fu1, s2, tol )
struct faceuse		*fu1;
struct shell		*s2;
CONST struct rt_tol	*tol;
{
	struct loopuse	*lu1;
	struct edgeuse	*eu1;

	NMG_CK_FACEUSE(fu1);
	NMG_CK_SHELL(s2);
	RT_CK_TOL(tol);
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		rt_log("nmg_fu_harmonize_radial_parity(fu=x%x, s2=x%x)\n", fu1, s2);
	}

	for( RT_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu1);
		if( RT_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_VERTEXUSE_MAGIC )
			continue;
		for( RT_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )  {
			NMG_CK_EDGEUSE( eu1 );
			nmg_eu_harmonize_radial_parity( eu1, s2, tol );
		}
	}

}

/*
d1529 1
@


11.12
log
@Changed nmg_lu_reorient() to use nmg_class_pt_fu_except().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.11 95/02/24 06:42:31 mike Exp Locker: mike $ (BRL)";
d554 1
d557 1
@


11.11
log
@Changed temporary bomb to temporary rt_log().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.10 95/02/23 13:04:20 jra Exp Locker: mike $ (BRL)";
d3650 2
a3651 1
				class = nmg_class_pt_f_except( mid, fu, lu, tol );
@


11.10
log
@Added debug logging to nmg_loop_split_at_touching_jaunt().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.9 95/02/23 06:15:09 mike Exp Locker: jra $ (BRL)";
d4199 2
a4200 2
if( nmg_check_radial( eu, tol ) ) rt_bomb("ebreaker eu bad\n");
if( nmg_check_radial( new_eu, tol ) ) rt_bomb("ebreaker new_eu bad\n");
@


11.9
log
@Added temporary check for crack interaction w/nmg_radial_join_eu()
in nmg_ebreaker().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.8 95/02/23 05:55:59 mike Exp Locker: mike $ (BRL)";
d2880 1
a2880 1
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
d2889 12
d2917 1
a2917 1
		if (rt_g.NMG_debug & DEBUG_BASIC)  {
d2945 1
a2945 1
		if (rt_g.NMG_debug & DEBUG_BASIC)  {
d2997 6
d3011 29
d3055 5
d3061 1
d3065 1
d3067 7
@


11.8
log
@Added nmg_eu_harmonize_radial_parity() and nmg_fu_harmonize_radial_parity()
to processing of nmg_js().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.7 95/02/21 23:41:36 mike Exp Locker: mike $ (BRL)";
d4137 3
@


11.7
log
@Changed nmg_ebreaker() to find all EDGEs that might run between
the three vertices, not just find the first edgeuse.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.6 95/02/20 16:17:41 jra Exp Locker: mike $ (BRL)";
d554 3
d1369 63
@


11.6
log
@Mod to nmg_check_proposed_loop to insure that ENTIRE remaining
loop gets checked.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.5 95/02/18 13:04:30 jra Exp Locker: jra $ (BRL)";
d30 7
d4043 10
a4052 5

		/* This edge was broken on an existing vertex.  Search */
		oeu = nmg_findeu( eu->vu_p->v_p, eu->eumate_p->vu_p->v_p,
			(struct shell *)NULL, eu, 0 );
		if( oeu )  {
d4060 5
a4064 3
		oeu = nmg_findeu( new_eu->vu_p->v_p, new_eu->eumate_p->vu_p->v_p,
			(struct shell *)NULL, new_eu, 0 );
		if( oeu )  {
@


11.5
log
@Cleaned up  nmg_loop_split_at_touching_jaunt().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.4 95/02/17 16:26:33 jra Exp Locker: jra $ (BRL)";
d2673 5
d2685 1
a2685 1
nmg_check_proposed_loop( start_eu, next_start_eu, visit_count, jaunt_status, jaunt_tbl, jaunt_no )
d2692 1
d2697 1
d2709 1
a2709 1
	do
d2723 1
a2723 1
			if( last_eu && last_eu == jaunt_eu && jaunt_status[j] != JS_TOUCHING_JAUNT )
d2734 9
a2742 1
	} while( loop_eu->vu_p->v_p != start_eu->vu_p->v_p );
d2897 2
a2898 2
		struct edgeuse *start_eu;	/* EU that will start a new loop upon split */
		struct edgeuse *next_start_eu;	/* starting eu for the remaining loop */
d2910 1
a2910 1
		start_eu = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);
d2913 2
a2914 2
		nmg_check_proposed_loop( start_eu, &next_start_eu, visit_count,
			jaunt_status, &jaunt_tbl, jaunt_no );
d2917 2
a2918 3
		start_eu = next_start_eu;
		nmg_check_proposed_loop( start_eu, &next_start_eu, visit_count,
			jaunt_status, &jaunt_tbl, jaunt_no );
@


11.4
log
@Replaced nmg_loop_split_at_touching_jaunt().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.3 95/02/01 02:27:49 mike Exp Locker: jra $ (BRL)";
d2590 6
d2658 21
d2680 1
a2680 2
nmg_check_proposed_loop( lu, start_eu, next_start_eu, visit_count, include_or_split, jaunt_tbl, jaunt_no )
CONST struct loopuse *lu;
d2684 1
a2684 1
int include_or_split[];
a2691 1
	NMG_CK_LOOPUSE( lu );
d2699 1
a2699 1
	/* walk through the proposed new loop, updating the visit_count */
d2715 3
a2717 2
			if( last_eu && last_eu == jaunt_eu && !include_or_split[j] )
				include_or_split[j] = (-1);
d2730 2
d2734 1
a2734 1
		if( include_or_split[j] == (-1) )
d2736 2
a2737 4
			if( visit_count[j] > 1 )
				include_or_split[j] = 1;
			else
				include_or_split[j] = 0;
d2742 1
a2742 1
	 * loop will split the jaunt, so set its visit_count to 0.
d2753 1
a2753 4
		{
			visit_count[j] = 0;
			include_or_split[j] = 1;
		}
d2786 1
a2786 1
	int			*include_or_split;
d2797 1
a2797 1
	include_or_split = (int *)NULL;
d2812 2
a2813 2
		if( include_or_split )
			rt_free( (char *)include_or_split, "nmg_loop_split_at_touching_jaunt: include_or_split[]\n" );
d2842 2
a2843 2
		if( include_or_split )
			rt_free( (char *)include_or_split, "nmg_loop_split_at_touching_jaunt: include_or_split[]\n" );
d2852 1
a2852 1
	/* if we get here, there are at least two touching jaunts in the loop
d2854 12
a2865 8
	 * touching jaunt into a crack. To do this, follow the EU's as nmg_split_lu_at_vu()
	 * would do and count how many times the apex vertex of each touching jaunt is
	 * encountered. A count of zero means that the new loop is disjoint from
	 * the touching jaunt. A count of two means that the new loop will have
	 * the touching jaunt as its own touching jaunt. A count of one means that
	 * the touching jaunt and the vertex on the loop where it touches are going
	 * to be seperated if this new loop is created (this will result in a two
	 * edgeuse crack).
d2871 2
a2872 2
	if( include_or_split )
		rt_free( (char *)include_or_split, "nmg_loop_split_at_touching_jaunt: include_or_split[]\n" );
d2876 4
a2879 2
	include_or_split = (int *)rt_calloc( NMG_TBL_END( &jaunt_tbl ), sizeof( int ),
			"nmg_loop_split_at_touching_jaunt: include_or_split[]" );
d2882 1
a2882 1
		struct edgeuse *start_eu; /* EU that will start a new loop upon split */
d2884 1
a2884 1
		int do_split=1;
d2886 1
d2888 1
a2888 1
			include_or_split[i] = 0;
d2890 1
a2890 1
		/* Check this jaunt */
d2897 3
a2899 2
		nmg_check_proposed_loop( lu, start_eu, &next_start_eu, visit_count,
			include_or_split, &jaunt_tbl, jaunt_no );
d2903 2
a2904 2
		nmg_check_proposed_loop( lu, start_eu, &next_start_eu, visit_count,
			include_or_split, &jaunt_tbl, jaunt_no );
d2906 4
d2912 1
a2912 1
			if( !include_or_split[i] )
d2919 1
d2932 1
d2934 2
d2939 1
@


11.3
log
@Fixed nmg_unbreak_edge() to reject cases where some edgeuses around
the common edge don't end at vertices A and C.
Also contains lots of double-check code by John.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_mod.c,v 11.2 95/01/30 15:29:03 jra Exp Locker: jra $ (BRL)";
d2590 146
d2754 2
d2757 8
a2764 1
	int			count = 0;
d2768 1
d2772 4
d2777 1
a2777 2
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		goto out;
d2779 5
a2783 4
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		struct edgeuse	*eu2;
		struct edgeuse	*eu3;
		struct loopuse		*newlu;
d2785 23
a2808 1
		eu3 = RT_LIST_PNEXT_CIRC(edgeuse, &eu2->l);
d2810 5
a2814 2
		/* If it's a 2 vertex crack, stop here */
		if( eu->vu_p == eu3->vu_p )  break;
d2816 5
a2820 2
		/* If not jaunt, move on */
		if( eu->vu_p->v_p != eu3->vu_p->v_p )  continue;
d2822 63
a2884 2
		/* It's a jaunt, see if tip touches same loop */
		if( nmg_find_repeated_v_in_lu(eu2->vu_p) == (struct vertexuse *)NULL )
d2887 3
a2889 2
		/* Tip touches loop.  (What about ring and sleeve?) */
		newlu = nmg_split_lu_at_vu( lu, eu2->vu_p );
d2891 4
a2894 3
		NMG_CK_LOOPUSE(newlu);
		NMG_CK_LOOP(newlu->l_p);
		nmg_loop_g(newlu->l_p, tol);
d2896 1
a2896 2
		/* Recurse on new loop */
		count += nmg_loop_split_at_touching_jaunt( newlu, tol );
d2899 8
a2906 6
out:
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		rt_log("nmg_loop_split_at_touching_jaunt( lu=x%x ) END count=%d\n",
			lu, count);
	}
	return count;
@


11.2
log
@Add call to nmg_shell_a() at end of nmg_shell_coplanar_face_merge().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 11.1 95/01/04 09:58:05 mike Rel4_4 Locker: jra $ (BRL)";
d3796 2
d3833 1
d3839 1
d3877 1
d3901 42
d3945 7
a3951 4
		/* revector eu1mate's start vertex from B to C */
		nmg_movevu( eu1->eumate_p->vu_p , vc );

		/* Now kill off the unnecessary eu2 associated w/ cur eu1 */
d3957 21
d3981 6
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.101 94/12/05 16:07:59 mike Exp $ (BRL)";
d161 2
@


10.101
log
@Don't check edgeuses any more.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.100 94/11/21 16:27:25 jra Exp Locker: mike $ (BRL)";
@


10.100
log
@Mods to nmg_dup_loop to allow NULL trans_tbl.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_mod.c,v 10.99 94/11/18 16:22:42 jra Exp Locker: jra $ (BRL)";
a1947 2

	nmg_veu( &lu1->down_hd, &lu1->l.magic );	/* XXX sanity */
@


10.99
log
@eliminated bombing and warning from nmg_esplit for edgeuses to/from same vertex.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.98 94/11/17 17:01:44 jra Exp Locker: jra $ (BRL)";
d2909 2
d2935 4
a2938 1
		new_v = NMG_INDEX_GETP(vertex, trans_tbl, old_v);
d2958 2
a2959 1
		NMG_INDEX_ASSIGN( trans_tbl, old_v, (long *)new_v );
d2982 4
a2985 1
		new_v = NMG_INDEX_GETP(vertex, trans_tbl, old_v);
d3002 1
a3002 1
			if( !new_v )  {
d3018 1
a3018 1
			if( !new_v )  {
d3034 5
a3038 2
		tbl_eu = NMG_INDEX_GETP(edgeuse, trans_tbl, eu->e_p );
		if( !tbl_eu )  {
d3042 2
a3043 1
		NMG_INDEX_ASSIGN( trans_tbl, eu, (long *)new_eu );
d3048 9
a3056 7
	/* All vertex structs are shared.  Make shared edges be shared */
	for(RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
		/* Use old_e as subscript, to get 1st new_eu (for new_e) */
		/* Use old_eu to get mapped new_eu */
		tbl_eu = NMG_INDEX_GETP(edgeuse, trans_tbl, eu->e_p );
		new_eu = NMG_INDEX_GETP(edgeuse, trans_tbl, eu );
		if( tbl_eu->e_p == new_eu->e_p )  continue;
d3058 4
a3061 3
		/* new_eu isn't sharing edge with tbl_eu, join them */
		/* XXX Is radial relationship preserved (enough)? */
		nmg_je( tbl_eu, new_eu );
d3070 1
a3070 3
	for(RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
		NMG_CK_EDGEUSE( eu );
		new_eu = NMG_INDEX_GETP(edgeuse, trans_tbl, eu );
@


10.98
log
@Mods to nmg_esplit:
	eliminate bombing on edgeuse from+to same vertex.
	added check of neu1 when looking for return eu.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.97 94/11/05 00:32:08 mike Exp Locker: jra $ (BRL)";
a3576 5
	/* vA and vB are the endpoints of the original edge "e" */
	if( vA == vB )  {
		rt_log("WARNING: nmg_esplit() on edge from&to v=x%x\n", vA);
/*		rt_bomb("nmg_esplit() of edge running from&to same v\n");	*/
	}
@


10.97
log
@Irix 6
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.96 94/10/07 16:04:18 jra Exp Locker: mike $ (BRL)";
d3580 1
a3580 1
		rt_bomb("nmg_esplit() of edge running from&to same v\n");
d3648 7
@


10.96
log
@Added a check in nmg_js to keep it from doing an nmg_jf when it shouldn't.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.95 94/09/16 20:46:02 mike Exp Locker: jra $ (BRL)";
a216 1
	struct faceuse	*fu;
d324 1
a324 1
	struct loopuse *lu, *lustart;
a509 1
	struct vertex	*v;
d972 1
a972 1
	int i, j;
d1250 1
a1250 2
	struct loopuse *lu, *lu2;
	int overlap;
a1318 1
	register vectp_t	v;
a1859 1
	struct edgeuse	*new_eu;
a2017 1
    	struct edgeuse	*eu1;
a2422 1
	struct vertex		*v;
a2434 1
		struct vertexuse	*tvu;
a2552 1
			struct loopuse		*newlu;
a2622 1
		struct vertexuse	*tvu;	/* other touching vu */
d2635 1
a2635 1
		if( (tvu = nmg_find_repeated_v_in_lu(eu2->vu_p)) == (struct vertexuse *)NULL )
a2923 1
	int i=1;
d3651 1
a4055 1
	struct loopuse *lu;
d4063 1
a4063 1
	lu = nmg_mlv( &(dest->l.magic), vu->v_p, OT_SAME );
@


10.95
log
@nmg_move_eg() became nmg_jeg().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.94 94/09/13 20:56:38 mike Exp Locker: mike $ (BRL)";
d119 1
a119 1
				if( !NEAR_ZERO(dist, tol->dist) )  continue;
d127 1
a127 1
				if( !(dist >= tol->para) )  continue;
d553 1
a553 1
		if( fu1 )  {
d3168 1
d3170 2
@


10.94
log
@Added debugging, and fixed loop termination condition in nmg_move_eg()
to use return code from nmg_use_edge_g().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.93 94/09/12 22:40:34 mike Exp Locker: mike $ (BRL)";
a4041 50
	}
}

/*
 *			N M G _ M O V E _ E G
 *
 *  For all edges in the model which refer to 'old_eg',
 *  change them to refer to 'new_eg'.
 *
 *  XXX In keeping with other names, this should probably be called nmg_jeg().
 *  XXX The argument order should be reversed, too.
 *
 *  This algorithm does not make sense if new_eg is an edge_g_cnurb;
 *  those only make sense in the parameter space of their associated face.
 */
void
nmg_move_eg( old_eg, new_eg )
struct edge_g_lseg	*old_eg;
struct edge_g_lseg	*new_eg;
{
	register struct edgeuse		*eu;
	register struct edge		*e;

	NMG_CK_EDGE_G_LSEG(old_eg);
	NMG_CK_EDGE_G_LSEG(new_eg);
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		rt_log("nmg_move_eg( old_eg=x%x, new_eg=x%x )\n",
			old_eg, new_eg );
	}

	while( RT_LIST_NON_EMPTY( &old_eg->eu_hd2 ) )  {
		struct rt_list	*midway;	/* &eu->l2, midway into edgeuse */

		NMG_CK_EDGE_G_LSEG(old_eg);

		/* Obtain an eu from old_eg */
		midway = RT_LIST_FIRST(rt_list, &old_eg->eu_hd2 );
		NMG_CKMAG(midway, NMG_EDGEUSE2_MAGIC, "edgeuse2 [l2]");
		eu = RT_LIST_MAIN_PTR( edgeuse, midway, l2 );
		NMG_CK_EDGEUSE(eu);

		if( eu->g.lseg_p != old_eg )  {
			rt_log("nmg_move_eg() eu=x%x, eu->g=x%x != old_eg=x%x??  new_eg=x%x\n",
				eu, eu->g.lseg_p, old_eg, new_eg );
			rt_bomb("nmg_move_eg() edge geometry fumble\n");
		}

		/* Associate eu and mate with new_eg. old_eg freed when unused. */
		if( nmg_use_edge_g( eu, &new_eg->magic ) )
			break;		/* old_eg destroyed */
@


10.93
log
@Added sanity checking to nmg_move_eg()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.92 94/09/10 04:37:10 mike Exp Locker: mike $ (BRL)";
d4052 1
d4054 2
a4055 2
 *  This algorithm does not make sense to use on edge_g_cnurb's;  they
 *  only make sense in the parameter space of their associated face.
a4071 1
	nmg_ck_list( &old_eg->eu_hd2, "nmg_move_eg() eu_hd2");	/* safety */
d4075 2
d4083 6
d4090 2
a4091 2
		nmg_use_edge_g( eu, &new_eg->magic );
		nmg_ck_list( &old_eg->eu_hd2, "nmg_move_eg() eu_hd2 B");	/* safety */
@


10.92
log
@Converted NMG data structures to have edge_g pointer in edgeuse, not edge.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.91 94/09/03 03:01:48 mike Exp $ (BRL)";
d4071 1
d4077 1
d4083 1
@


10.91
log
@Snapshot of non-working intermediate stage in edge_g evolution.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.90 94/09/02 17:58:39 mike Exp Locker: mike $ (BRL)";
d820 1
a820 1
			eu = nmg_eusplit(*verts[i], euold);
d822 1
a822 1
				nmg_moveeu(eur, eu);
d833 1
a833 1
			eu = nmg_eusplit(*verts[i], euold);
d844 1
a844 1
		nmg_moveeu(eur, euold);
d919 1
a919 1
			eu = nmg_eusplit(verts[i], eu);
d930 1
a930 1
			(void)nmg_eusplit((struct vertex *)NULL, eu);
d1000 1
a1000 1
			eu = nmg_eusplit(verts[i], eu);
d1014 1
a1014 1
			(void)nmg_eusplit((struct vertex *)NULL, eu);
d1224 1
a1224 1
							    	nmg_moveeu(eu, eu2);
d1912 1
a1912 1
		second_new_eu = nmg_eusplit( vu2->v_p, first_new_eu );
d1916 1
a1916 1
		nmg_moveeu( second_new_eu, first_new_eu );
d1996 1
a1996 1
	second_new_eu = nmg_eusplit( vu2->v_p, first_new_eu );
d1999 1
a1999 1
	nmg_moveeu( second_new_eu, first_new_eu );
d2044 1
a2044 1
	second_new_eu = nmg_eusplit( vu2->v_p, first_new_eu );
d2047 1
a2047 1
	nmg_moveeu( second_new_eu, first_new_eu );
d2223 1
a2223 1
	nmg_moveeu(neweu, eunext);
d3017 1
a3017 1
			new_eu = nmg_eusplit(new_v, new_eu);
d3056 1
a3056 1
		nmg_moveeu( tbl_eu, new_eu );
d3070 2
a3071 2
		if( new_eu->e_p->eg_p )  continue;
		nmg_edge_g(new_eu->e_p);
d3272 3
d3276 1
a3276 1
 *	edgeuse of new edge, starting at v.
d3299 4
a3302 3
nmg_eusplit(v, oldeu)
struct vertex *v;
struct edgeuse *oldeu;
d3377 5
d3480 13
d3495 3
a3497 2
		rt_log("nmg_eusplit(v=x%x, eu=x%x) new_eu=x%x, mate=x%x\n",
			v, oldeu, eu1, eu1->eumate_p );
d3521 4
d3553 3
d3558 1
a3558 1
nmg_esplit(v, eu)
d3561 1
d3603 1
a3603 1
		teuY = nmg_eusplit(v, teuX);
d3622 2
a3623 2
		 *  Move the newly created temporary edge (teuX, teuY)
		 *  onto the new edge (neu1, neu2).
d3629 2
a3630 2
				nmg_moveeu(neu1, teuX);
				nmg_moveeu(neu2, teuY);
d3636 2
a3637 2
				nmg_moveeu(neu2, teuX);
				nmg_moveeu(neu1, teuY);
d3652 2
a3653 2
			rt_log("nmg_esplit(v=x%x, eu=x%x) neu2=x%x\n",
				v, eu, neu2);
d3664 2
a3665 2
 *  Like nmg_esplit(), split an edge into two parts, but where the
 *  two resultant parts share the original edge geometry.
d3668 1
d3673 1
a3673 1
struct vertex	*v;
a3676 1
	struct edge_g_lseg	*eg;
d3679 3
a3681 1
	eg = eu->e_p->eg_p;
d3683 1
a3683 7
	/* nmg_esplit() will delete eu->e_p, so if geom is present, save it! */
	if( eg )  {
		NMG_CK_EDGE_G_LSEG(eg);
		/* eg->usage++; */	/* ??? */
	}

	new_eu = nmg_esplit(v, eu);	/* Do the hard work */
a3688 30
	/* If there wasn't any edge geometry before, nothing more to do */
	if( !eg )
	{
		if (rt_g.NMG_debug & DEBUG_BASIC)  {
			rt_log("nmg_ebreak( v=x%x, eu=x%x ) new_eu=x%x\n", v, eu, new_eu);
		}
		return new_eu;
	}

	/* Make sure the two edges share the same geometry. */
	NMG_CK_EDGE_G_LSEG(eg);

	/* Both these edges should be fresh, without geometry yet. */
	if( eu->e_p->eg_p )   {
		rt_log("old eg=x%x, new_eg=x%x\n", eg, eu->e_p->eg_p);
		nmg_pr_eg(eg, "old_");
		nmg_pr_eg(eu->e_p->eg_p, "new_");
		rt_bomb("nmg_ebreak() eu grew geometry?\n");
	}
	eu->e_p->eg_p = eg;		/* eg->usage++ was done above */

	/* Sometimes new_eu still has the previous edge geometry on it */
	if( new_eu->e_p->eg_p )  {
		if( new_eu->e_p->eg_p != eg )
			rt_bomb("nmg_ebreak() new_eu grew geometry?\n");
		/* new_eu retained the previous geometry (why?) */
	} else {
		nmg_use_edge_g( new_eu->e_p, eg );
	}

d3690 2
a3691 1
		rt_log("nmg_ebreak( v=x%x, eu=x%x ) new_eu=x%x\n", v, eu, new_eu);
a3693 4

	/* XXX It would be much nicer to have a list of edges sharing
	 * XXX edge geometry, rather than a count...
	 */
d3788 5
d3834 4
a3837 1
	eg = e1->eg_p;
d3857 1
a3857 1
	if( eu2->e_p->eg_p != eg )  {
d3859 1
a3859 1
			eu2->e_p->eg_p, eg, e1 );
d3880 2
a3881 2
		NMG_CK_EDGE(vu->up.eu_p->e_p);
		if( vu->up.eu_p->e_p->eg_p != eg )  {
d3895 1
a3895 1
		if( eu2->e_p->eg_p != eg )  {
a4052 2
 *  XXX The algorithm needs to be changed when edge_g get linked lists of edges.
 *
d4057 1
a4057 1
nmg_move_eg( old_eg, new_eg, s )
a4059 1
struct shell	*s;
a4065 1
	NMG_CK_SHELL(s);
d4067 2
a4068 2
		rt_log("nmg_move_eg( old_eg=x%x, new_eg=x%x, s=x%x )\n",
			old_eg, new_eg, s );
d4073 2
a4075 1
		RT_LIST_DEQUEUE( midway );
d4079 2
a4080 5
		e = eu->e_p;
		NMG_CK_EDGE(e);
		e->eg_p = new_eg;

		RT_LIST_INSERT( &new_eg->eu_hd2, &eu->l2 );
a4081 1
	nmg_keg( (long *)old_eg );
@


10.90
log
@faceuse_a, loopuse_a, and edgeuse_a have been eliminated.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.89 94/09/02 00:32:34 mike Exp Locker: mike $ (BRL)";
d3645 1
a3645 1
	struct edge_g	*eg;
d3652 2
a3653 2
		NMG_CK_EDGE_G(eg);
		eg->usage++;
d3672 1
a3672 1
	NMG_CK_EDGE_G(eg);
d3824 1
a3824 1
	struct edge_g	*eg;
d3841 1
a3841 1
	NMG_CK_EDGE_G(eg);
d3843 1
a3843 1
	/* if the edge geometry doesn't have at least two uses, this
d3845 1
a3845 1
	if( eg->usage < 2 )  {
d4052 3
d4058 2
a4059 2
struct edge_g	*old_eg;
struct edge_g	*new_eg;
a4061 4
	struct  faceuse		*fu;
	struct face		*f;
	struct loopuse		*lu;
	struct loop		*l;
a4063 2
	register struct edgeuse	**eup;
	struct nmg_ptbl		eutab;
d4065 2
a4066 2
	NMG_CK_EDGE_G(old_eg);
	NMG_CK_EDGE_G(new_eg);
d4073 6
a4078 2
	/* XXX Replace with walk of eg eu list */
	nmg_edgeuse_with_eg_tabulate( &eutab, nmg_find_model(&s->l.magic), old_eg );
d4080 1
a4080 6
	for( eup = (struct edgeuse **)NMG_TBL_LASTADDR(&eutab);
	     eup >= (struct edgeuse **)NMG_TBL_BASEADDR(&eutab);
	     eup--
	)  {
		NMG_CK_EDGEUSE(*eup);
		e = (*eup)->e_p;
d4082 3
a4084 3
		/* Another use of this edge may have fix things already */
		if( e->eg_p != old_eg )  continue;
		nmg_use_edge_g( e, new_eg );
d4086 1
a4086 1
	nmg_tbl( &eutab, TBL_FREE, (long *)0 );
@


10.89
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.88 94/08/09 19:38:17 mike Exp Locker: mike $ (BRL)";
a3444 1
	eu1->eua_p = (struct edgeuse_a *)NULL;
a3447 1
	eu2->eua_p = (struct edgeuse_a *)NULL;
@


10.88
log
@Added GDurf's new "conf.h"
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.87 94/07/06 16:49:32 mike Exp Locker: mike $ (BRL)";
d66 2
a67 2
	struct face_g	*fg1;
	struct face_g	*fg2;
d87 2
a88 2
		fg1 = f1->fg_p;
		NMG_CK_FACE_G(fg1);
d106 2
a107 2
			fg2 = f2->fg_p;
			NMG_CK_FACE_G(fg2);
d555 1
a555 1
				rt_log("nmg_js(): shared face_g, doing nmg_jf()\n");
d1328 1
a1328 1
	NMG_CK_FACE_G(fu->f_p->fg_p);
d1717 1
a1717 1
	if (fu->f_p->fg_p) {
@


10.87
log
@Added nmg_ebreaker()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.86 94/07/04 02:58:22 mike Exp Locker: mike $ (BRL)";
d23 1
@


10.86
log
@Allocated extra space.
Changed flags array to chars, so it's actually smaller now.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.85 94/07/03 18:52:36 mike Exp Locker: mike $ (BRL)";
d3701 53
@


10.85
log
@Removed dead code.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.84 94/07/02 02:20:50 mike Exp Locker: mike $ (BRL)";
d59 2
a60 2
	int		*flags1;
	int		*flags2;
d70 2
a71 2
	len = sizeof(int) * m->maxindex;
	flags1 = (int *)rt_calloc( sizeof(int), m->maxindex,
d73 1
a73 1
	flags2 = (int *)rt_calloc( sizeof(int), m->maxindex,
d107 3
@


10.84
log
@Changed nmg_move_eg() to move all occurances of the 'old_eg' in the
entire model.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.83 94/04/22 10:06:03 butler Exp Locker: mike $ (BRL)";
d3994 2
a4020 1
#if 1
a4035 53
#else
	/* Faces in shell */
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
		f = fu->f_p;
		NMG_CK_FACE(f);
		/* Loops in face */
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
			NMG_CK_LOOPUSE(lu);
			l = lu->l_p;
			NMG_CK_LOOP(l);
			if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
				/* Loop of Lone vertex */
				continue;
			}
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
				NMG_CK_EDGEUSE(eu);
				e = eu->e_p;
				NMG_CK_EDGE(e);
				if(e->eg_p == old_eg)  {
					nmg_use_edge_g( e, new_eg );
				}
			}
		}
	}
	/* Wire loops in shell */
	for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		l = lu->l_p;
		NMG_CK_LOOP(l);
		if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
			/* Wire loop of Lone vertex */
			continue;
		}
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			NMG_CK_EDGEUSE(eu);
			e = eu->e_p;
			NMG_CK_EDGE(e);
			if(e->eg_p == old_eg)  {
				nmg_use_edge_g( e, new_eg );
			}
		}
	}
	/* Wire edges in shell */
	for( RT_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
		NMG_CK_EDGEUSE(eu);
		e = eu->e_p;
		NMG_CK_EDGE(e);
		if(e->eg_p == old_eg)  {
			nmg_use_edge_g( e, new_eg );
		}
	}
#endif
@


10.83
log
@fixed bug in nmg_dup_face() that manifested when first loopuse of faceuse
to be dup'ed was NOT a OT_SAME loopuse.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.82 94/04/19 15:21:21 mike Exp Locker: butler $ (BRL)";
d3991 4
a3994 2
 *  For every edge in shell 's', change all occurances of edge geometry
 *  structure 'old_eg' to be 'new_eg'.
d4008 2
d4019 17
d4087 1
@


10.82
log
@Trying to preserve the OT_BOOLPLACE self-loops.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.81 94/03/11 16:36:00 mike Exp Locker: mike $ (BRL)";
d1685 3
d1693 14
d1708 3
d2942 7
d2987 8
d3071 5
a3075 2
		rt_log("nmg_dup_loop(lu=x%x, parent=x%x, trans_tbl=x%x) new_lu=x%x\n",
			lu , parent , trans_tbl , new_lu );
@


10.81
log
@Fix due to JRA:
In nmg_eusplit(), ensure that edge's up pointer points to an associated
edgeuse.
(Under certain rare conditions, it could point up to the wrong edgeuse)
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.80 94/03/11 01:17:31 mike Exp Locker: mike $ (BRL)";
d3096 5
@


10.80
log
@Took out several irritating prints.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.79 94/03/10 07:08:31 butler Exp Locker: mike $ (BRL)";
d3421 4
@


10.79
log
@nmg_dup_face now checks to see if the two parameters belong to the same
model.  If not, the trans_tbl is allocated with double the size of the
SUM of the model->maxindex values.  The mged "fracture" command calls
nmg_dup_face with a face and target shell in two separate models.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.78 1994/03/10 02:11:54 butler Exp butler $ (BRL)";
d2548 1
d2551 1
d2563 3
a2565 1
rt_log("nmg_join_touchingloops(): lu=x%x, vu=x%x, tvu=x%x\n", lu, vu, tvu);
d3158 1
d3160 1
@


10.78
log
@Added checks to nmg_dup_loop()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.77 1994/03/04 23:17:00 mike Exp butler $ (BRL)";
d1662 1
d1664 1
d1670 3
d1674 6
d1681 1
a1681 1
	trans_tbl = (long **)rt_calloc(m->maxindex*2, sizeof(long *),
@


10.77
log
@Made pesky lu_reorient message conditional on DEBUG_BASIC.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.76 94/03/03 11:06:51 jra Exp Locker: mike $ (BRL)";
d3012 1
d3014 2
@


10.76
log
@Added more error logging to nmg_fu_planeeqn
and replaces VAPPROXEQUAL with rt_pt3_pt3_equal
in the same routine
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.75 94/03/02 18:17:57 mike Exp Locker: jra $ (BRL)";
d3162 5
a3166 1
rt_log("nmg_lu_reorient() class=%s, orient=%s\n", nmg_class_name(class), nmg_orientation(geom_orient) );
@


10.75
log
@Changed nmg_fu_planeeqn() to call nmg_ck_fu_verts(), to ensure
that all verts are within tol of face's surface.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.74 94/02/24 08:32:52 mike Exp Locker: mike $ (BRL)";
d1101 5
a1105 1
		if( eu_next == eu )  return -1;
d1111 1
a1111 1
		|| VAPPROXEQUAL(a->vg_p->coord, b->vg_p->coord, tol->dist))
d1118 5
a1122 1
		if( eu_final == eu )  return -1;
d1128 2
a1129 2
		    VAPPROXEQUAL(a->vg_p->coord, c->vg_p->coord, tol->dist) ||
		    VAPPROXEQUAL(b->vg_p->coord, c->vg_p->coord, tol->dist);
d1153 1
a1153 1
		rt_log("nmg_fu_planeeqn(fu=x%x) ERROR, verts are not within tol of face\n");
@


10.74
log
@Added nmg_find_repeated_v_in_lu(), and
nmg_loop_split_at_touching_jaunt().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.73 94/02/24 06:19:42 mike Exp Locker: mike $ (BRL)";
d1143 6
d1150 1
a1150 1
		rt_log("nmg_fu_paneeqn(fu=x%x, tol=x%x)\n", fu, tol);
@


10.73
log
@Improved BASIC debugging for loop cut and join routines.
Added nmg_s_join_touching_loops()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.72 94/02/22 22:54:02 mike Exp Locker: mike $ (BRL)";
d418 1
d423 1
d2308 56
d2394 1
d2398 20
a2431 1
			struct loopuse		*newlu;
d2458 1
d2542 68
@


10.72
log
@More debugging prints in nmg_lu_reorient().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.71 94/02/22 21:26:35 mike Exp Locker: mike $ (BRL)";
d411 4
d434 1
a434 1
		rt_log("nmg_s_split_touching_loops(s=x%x, tol=x%x)\n", s, tol);
d439 43
d1724 3
d1728 1
a1728 1
		rt_log("nmg_jl(lu=x%x, eu=x%x)\n", lu, eu);
a1733 1
	lu2 = eu_r->up.lu_p;
d1832 2
a1833 1
		rt_log("nmg_join_2loops( vu1=x%x, vu2=x%x )\n", vu1, vu2 );
d1844 4
a1847 1
		new_orient = OT_SAME;
d1929 2
a1930 1
		rt_log("nmg_join_singvu_loop( vu1=x%x, vu2=x%x )\n", vu1, vu2 );
d1977 2
a1978 1
		rt_log("nmg_join_2singvu_loops( vu1=x%x, vu2=x%x )\n", vu1, vu2 );
d2197 2
a2198 1
		rt_log("nmg_cut_loop(vu1=x%x, vu2=x%x) new lu=x%x\n", vu1, vu2, lu );
d2390 3
@


10.71
log
@Added tie-breaker code for nmg_lu_reorient().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.70 94/02/04 03:37:48 mike Exp Locker: mike $ (BRL)";
d2866 2
d2875 3
a2877 1

@


10.70
log
@Added nmg_invert_shell().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.69 94/02/03 21:34:28 mike Exp Locker: mike $ (BRL)";
d2837 4
a2853 3
	fu = lu->up.fu_p;
	NMG_CK_FACEUSE(fu);
	if( fu->orientation != OT_SAME )  fu = fu->fumate_p;
d2859 12
d2891 44
a2934 2
			/* ALL vu's touch other loops in face, should have been joined. */
			rt_bomb("nmg_lu_reorient() lu is ON another lu, should have been joined\n");
@


10.69
log
@Made debugging print in nmg_lu_reorient conditional on DEBUG_BASIC
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.68 94/02/02 00:16:23 mike Exp Locker: mike $ (BRL)";
d442 2
d446 1
a446 1
nmg_js( s1, s2 )
d449 1
d462 1
d464 4
d501 2
a502 1
rt_log("nmg_js(): shared face_g, doing nmg_jf()\n");
a508 1
		nmg_face_fix_radial_parity( fu2 );
d588 1
a588 1
		rt_log("nmg_js(s1=x%x, s2=%d)\n", s1, s2);
d592 47
a1211 1

d1241 8
d1292 1
a1292 1
		rt_log("nmg_reverse_face(fu=x%x)\n", fu);
d1314 17
d1333 3
a1335 2
nmg_face_fix_radial_parity( fu )
struct faceuse *fu;
d1346 1
d1415 5
d1434 8
a1570 1
		/* XXX call nmg_reverse_face_and_radials() here? */
@


10.68
log
@Added nmg_join_touchingloops().
Added 'tol' arg to nmg_split_touchingloops().
Added call to nmg_class_lu_fu() into nmg_lu_reorient(), to disambiguate
"crack" loops.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.67 94/01/24 10:46:00 jra Exp Locker: mike $ (BRL)";
d2772 2
a2773 1
		rt_log("nmg_lu_reorient:  unable to determine orientation from geometry\n");
@


10.67
log
@Added prints for DEBUG_BASIC for a few routines that were missed on the first pass
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.66 94/01/22 05:24:27 mike Exp Locker: jra $ (BRL)";
d414 1
a414 1
			nmg_split_touchingloops( lu );
d418 1
a418 1
		nmg_split_touchingloops( lu );
d430 1
a430 1
		rt_log("nmg_split_touching_loops(s=x%x, tol=x%x)\n", s, tol);
d2167 3
a2169 2
nmg_split_touchingloops( lu )
struct loopuse	*lu;
d2175 2
d2220 2
d2224 1
a2224 1
			nmg_split_touchingloops(newlu);
d2234 81
d2317 2
a2318 1
 *	combine adjacent loops within the same parent
d2770 1
d2773 17
a2789 4
		return;
	}
	if( ccw > 0 )  {
		geom_orient = OT_SAME;	/* same as face (OT_SAME faceuse) */
d2791 5
a2795 1
		geom_orient = OT_OPPOSITE;
@


10.66
log
@For each routine, added a 1-line debugging print that shows what the
calling sequence was, and what the return code was.
Conditional on DEBUG_BASIC.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.65 94/01/14 02:45:05 mike Exp Locker: mike $ (BRL)";
d157 5
d179 2
d190 8
a197 2
	if( nmg_shell_is_empty(s) )  return 1;
	return 0;
d302 4
d385 4
d428 4
d578 4
d1038 4
d1109 4
d1132 1
d1148 7
a1154 2
	if( RT_LIST_IS_EMPTY(&fu->lu_hd) )  return 1;
	return 0;
d1228 4
d1350 5
d1412 4
d1444 4
d1483 1
d1544 1
d1645 1
d1807 1
d2051 1
d2432 5
d2469 5
d2523 4
d2616 5
d3112 7
a3118 1
	if( !eg ) return new_eu;
d3140 4
d3432 5
@


10.65
log
@Added nmg_js().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.64 93/12/28 10:36:49 jra Exp Locker: mike $ (BRL)";
d713 4
d796 4
d880 5
d1406 4
d1479 4
d1522 4
d1626 4
d1719 3
a1721 3
#if 0
	rt_log("nmg_join_singvu_loop( x%x, x%x )\n", vu1, vu2 );
#endif
d1765 3
a1767 3
#if 0
	rt_log("nmg_join_2singvu_loops( x%x, x%x )\n", vu1, vu2 );
#endif
d1877 1
d1884 2
a1885 1
		return nmg_split_lu_at_vu( oldlu, vu1 );
d1983 4
d2044 2
a2045 1
		return (struct loopuse *)0;		/* FAIL */
d2083 5
a2087 1

d2109 3
d2175 4
d2259 3
d2553 4
d2590 4
d2740 1
a2740 1
		return(eu1);
d2836 5
d2984 5
a2988 1
	if( neu2->vu_p->v_p == v && neu2->eumate_p->vu_p->v_p == vB )
d2990 1
d3081 3
d3205 1
a3205 1
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
d3286 3
d3362 4
d3442 4
@


10.64
log
@Fixed bug in nmg_simplify_loop (continue statement in main loop without incrementing).
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.63 93/12/23 05:41:39 mike Exp Locker: jra $ (BRL)";
d409 146
d1175 119
d2552 5
a2556 2
	rt_log("nmg_lu_reorient(x%x):  changing orientation: %s to %s\n",
		lu, nmg_orientation(lu->orientation), nmg_orientation(geom_orient) );
@


10.63
log
@For nmg_s_split_touchingloops(), do all splitting before reorienting.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.62 93/12/22 06:12:51 mike Exp Locker: mike $ (BRL)";
d1897 1
@


10.62
log
@Added comments to nmg_cut_loop() and nmg_split_lu_at_vu(), describing
how the loop orientation can't be known after the slipt.
Also changed calling sequence to nmg_lu_reorient(), eliminating
the need to pass in a surface normal.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.61 93/12/03 03:35:41 mike Exp Locker: mike $ (BRL)";
d390 1
a391 1
		/* First, handle any splitting */
d395 7
a401 1
		/* Second, reorient any split loop fragments */
a405 3
	}
	for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
		nmg_split_touchingloops( lu );
@


10.61
log
@Access to plane equation / surface normal in face_geometry structure
is now done through macros NMG_GET_FU_PLANE() NMG_GET_FU_NORMAL(),
which honor the f->flip flag.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.60 93/12/02 20:45:53 mike Exp Locker: mike $ (BRL)";
d47 3
d380 3
a382 2
nmg_s_split_touchingloops(s)
struct shell	*s;
d388 1
d391 1
d395 5
d1529 30
d1617 2
a1618 2
	lu = nmg_mlv(oldlu->up.magic_p, (struct vertex *)NULL,
		oldlu->orientation);
d1693 1
a1693 1
 *  It is the caller's responsibility to re-bound the loops, if desired.
d1695 20
d1719 1
a1719 1
 *	*lu	Loopuse of new loop, on success.
a1743 1
begin:
d1745 2
a1746 1
	newlu = nmg_mlv( lu->up.magic_p, (struct vertex *)NULL, lu->orientation);
d1773 1
a1773 1
		/* When split_vertex is encountered, stop */
d1789 3
d2252 2
a2253 3
nmg_lu_reorient( lu, norm, tol )
struct loopuse	*lu;
CONST plane_t		norm;
d2256 1
d2259 1
d2263 3
d2267 3
d2272 1
a2273 1
		/* rt_bomb("nmg_lu_reorient"); */
d2277 1
a2277 1
		geom_orient = OT_SAME;	/* same as face */
d2283 1
a2283 1
	rt_log("nmg_lu_reorient(x%x):  changing loop orientation from %s to %s\n",
@


10.60
log
@Moved nmg_unbreak_edge() from nmg_misc.c to nmg_mod.c
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.59 93/12/02 20:05:18 mike Exp Locker: mike $ (BRL)";
d75 2
d83 4
d95 1
a101 2
			/* If plane equations are different, done */
			fg1 = f1->fg_p;
a102 1
			NMG_CK_FACE_G(fg1);
d105 4
a108 3
			/* Compare distances from origin */
			dist = fg1->N[3] - fg2->N[3];
			if( !NEAR_ZERO(dist, tol->dist) )  continue;
d110 3
a112 7
			/*
			 *  Compare angle between normals.
			 *  Can't just use RT_VECT_ARE_PARALLEL here,
			 *  because they must point in the same direction.
			 */
			dist = VDOT( fg1->N, fg2->N );
			if( !(dist >= tol->para) )  continue;
d114 9
d124 2
a125 1
			 * Plane equations are the same, within tolerance.
d986 1
a986 3
	v = fu->f_p->fg_p->N;
	VREVERSE(v, v);
	v[H] *= -1.0;
d1121 1
d1170 7
a1176 1
		nmg_face_g(new_fu, fu->f_p->fg_p->N);
@


10.59
log
@Added nmg_s_split_touchingloops()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.58 93/11/18 02:09:24 mike Exp Locker: mike $ (BRL)";
d2655 125
@


10.58
log
@Bounding box routines now all take a tol arg.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.57 93/11/09 17:03:12 jra Exp $ (BRL)";
d353 28
@


10.57
log
@Added another rt_log message for a failure.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.56 93/10/25 17:48:36 mike Exp Locker: jra $ (BRL)";
d1099 3
d1472 2
a1598 4

	/* Recalculate bounding boxes, if they were present */
	nmg_loop_g(oldlu->l_p);
	nmg_loop_g(lu->l_p);
d1608 1
a1608 1
 *  The bounding boxes of both old and new loops will be updated.
a1674 4
	/* Create new bounding boxes for both old & new loops */
	nmg_loop_g(lu->l_p);
	nmg_loop_g(newlu->l_p);

a2020 1
		nmg_loop_g(new_lu->l_p);
a2109 1
	nmg_loop_g(new_lu->l_p);
a2854 1
		nmg_loop_g(lu->l_p);
@


10.56
log
@Picked a better variable name.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.55 93/10/25 02:28:03 cjohnson Exp Locker: mike $ (BRL)";
d741 4
a744 1
		return -1;
@


10.55
log
@Stupid compiler can not handle a complex condition.  Performance hit??
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.54 1993/10/24 03:55:01 mike Exp cjohnson $ (BRL)";
d732 1
a732 1
	register int	stupid_compiler;
d771 1
a771 1
		stupid_compiler = c == b ||
d774 1
a774 1
	} while( (stupid_compiler
@


10.54
log
@Changed nmg_mv_fu_between_shells() to preserve implicit OT_SAME,
OT_OPPOSITE ordering on fu_hd list.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.53 93/10/22 22:28:13 mike Exp Locker: mike $ (BRL)";
d732 1
d771 4
a774 3
	} while( (c == b
		|| VAPPROXEQUAL(a->vg_p->coord, c->vg_p->coord, tol->dist)
		|| VAPPROXEQUAL(b->vg_p->coord, c->vg_p->coord, tol->dist)
@


10.53
log
@nmg_eups() and nmg_lups() eliminated, in favor of
nmg_find_s_of_lu() and nmg_find_s_of_eu().

@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.52 93/10/08 13:10:01 jra Exp Locker: mike $ (BRL)";
d1012 11
a1022 3
	/* Add fu and fumate to dest shell */
	RT_LIST_APPEND( &dest->fu_hd, &fu->l );
	RT_LIST_APPEND( &fu->l, &fumate->l );
@


10.52
log
@Modified nmg_gluefaces to look at all loops in the faces
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.51 93/10/01 20:51:53 mike Exp Locker: jra $ (BRL)";
d1535 1
a1535 1
	neweu = nmg_me(eu1->vu_p->v_p, eu2->vu_p->v_p, nmg_eups(eu1));
d1548 1
a1548 1
	eunext = nmg_me(eu2->vu_p->v_p, eu1->vu_p->v_p, nmg_eups(eu1));
@


10.51
log
@Installed reasonable return codes for non-void functions.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.50 93/06/08 20:16:39 mike Exp Locker: mike $ (BRL)";
a829 9
		lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
		NMG_CK_LOOPUSE(lu);
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC) {
			/* Not an edgeuse, probably a vertexuse */
			rt_bomb("nmg_gluefaces() Cannot glue edges of face on vertex\n");
		} else {
			eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
			NMG_CK_EDGEUSE(eu);
		}
d833 2
a834 5
		lu = RT_LIST_FIRST( loopuse, &fulist[i]->lu_hd );
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			for( f_no = i+1; f_no < n; f_no++ )  {
				struct loopuse		*lu2;
				register struct edgeuse	*eu2;
d836 2
a837 1
				if( eu->radial_p != eu->eumate_p )  break;
d839 16
a854 5
				lu2 = RT_LIST_FIRST(loopuse,
					&fulist[f_no]->lu_hd);
				for( RT_LIST_FOR( eu2, edgeuse, &lu2->down_hd ) )  {
					if (EDGESADJ(eu, eu2))
					    	nmg_moveeu(eu, eu2);
@


10.50
log
@Check pointers more carefully in nmg_fu_planeeqn().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.49 93/05/08 02:45:22 butler Exp Locker: mike $ (BRL)";
d1826 1
a1826 1
		return;
d1998 1
a1998 1
			return;
d2011 2
a2012 1
		return;
@


10.49
log
@Added a little white space to improve readability.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.48 93/04/27 01:53:33 butler Exp Locker: butler $ (BRL)";
d733 2
d743 1
d746 1
d753 1
d756 1
d766 1
d769 1
@


10.48
log
@updated description of nmg_cut_loop()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.47 93/04/09 02:10:21 mike Exp Locker: butler $ (BRL)";
d1271 1
d1274 1
d1278 1
d1281 1
@


10.47
log
@Fixed nmg_jl() to also join loops of SAME/OPPOSITE orientation.
And fixed nmg_simplify_loop() to honor that restriction.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.46 93/04/08 03:18:52 mike Exp Locker: mike $ (BRL)";
d1419 1
a1419 1
 *	Divide a loop of edges between two vertexuses
a1423 1
 *	Old Loop      New loop	Resulting loops
d1425 1
a1425 10
 *	    v1		v1	    v1
 *	    |	        |	    |\
 *	    V	        V	    V V
 *	*---*---*	*	*---* *---*
 *	|	|	|	|   | |   |
 *	|	|	|	|   | |   |
 *	*---*---*	*	*---* *---*
 *	    ^		^	    ^ ^
 *	    |	        |	    |/
 *	   v2		v2	    v2
d1427 17
a1443 1
 *  Returns the new loopuse pointer.
@


10.46
log
@Sometimes nmg_ebreak()'s new_eu retains the edge geometry.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.45 93/04/03 01:16:41 mike Exp Locker: mike $ (BRL)";
d1129 7
d1142 3
a1144 1
	struct edgeuse *eu_r, *nexteu;
d1157 2
a1158 1
	if (*eu_r->up.magic_p != NMG_LOOPUSE_MAGIC)
d1161 1
a1161 1
	if (eu_r->up.lu_p == lu)
d1164 1
a1164 1
	if (lu->up.magic_p != eu_r->up.lu_p->up.magic_p)
d1167 9
a1175 5
	if (eu_r->up.lu_p->orientation != lu->orientation)  {
		rt_log("nmg_jl: eu_r->up = %s, lu = %s\n",
			nmg_orientation(eu_r->up.lu_p->orientation),
			nmg_orientation(lu->orientation) );
		rt_bomb("nmg_jl: can't join loops of different orientation!\n");
d1185 1
d1201 2
a1202 2
	 * The other loop just has the one edgeuse/edge left in it.
	 * Delete the other loop.
d1204 1
a1204 1
	nmg_klu(eu_r->up.lu_p);
d1207 2
a1208 2
	 * Kill the one remaining use of the "shared" edge and
	 * voila: one contiguous loop.
d1751 9
@


10.45
log
@Improvements to nmg_dup_face() and nmg_dup_loop().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.44 93/04/02 23:21:36 butler Exp Locker: mike $ (BRL)";
d2519 2
d2524 3
d2534 1
a2534 1
	if( new_eu->e_p->eg_p )  rt_bomb("nmg_ebreak() new_eu grew geometry?\n");
d2536 8
a2543 5
	/* Make sure the two edges share the same geometry. */
	NMG_CK_EDGE_G(eg);
	eu->e_p->eg_p = eg;		/* eg->usage++ was done above */
	new_eu->e_p->eg_p = eg;
	eg->usage++;
d2545 4
@


10.44
log
@enhanced comment to describe nmg_reverse_face()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.43 93/03/26 23:21:51 mike Exp Locker: butler $ (BRL)";
d1073 1
a1073 1
 *  Construct a duplicate of a face.
d1094 2
a1095 1
	trans_tbl = (long **)rt_calloc(m->maxindex, sizeof(long *),
d1937 1
d1939 1
d1950 5
a1954 5
		if (NMG_INDEX_TEST(trans_tbl, old_v)) {
			/* this vertex already exists in the new model */
			new_lu = nmg_mlv(parent,
				(struct vertex *)NMG_INDEX_VALUE(trans_tbl, old_v->index),
				lu->orientation);
d1956 4
a1959 6
		} else {
			/* make a new vertex */
			rt_log("nmg_dup_loop() new vertex in new model\n");
			new_lu = nmg_mlv(parent,
				(struct vertex *)NULL,
				lu->orientation);
d1961 7
a1967 7
			new_vu = RT_LIST_FIRST(vertexuse, &new_lu->down_hd);
			trans_tbl[old_v->index] = (long *)new_vu->v_p;

			if (old_v->vg_p) {
				new_vu = RT_LIST_FIRST(vertexuse, &new_lu->down_hd);
				nmg_vertex_gv(new_vu->v_p, old_vu->v_p->vg_p->coord);
			}
d1981 3
d1986 2
a1987 5
			if (NMG_INDEX_VALUE(trans_tbl, old_v->index)) {
				struct vertex *ck_v;
				ck_v = (struct vertex *)NMG_INDEX_VALUE(trans_tbl, old_v->index);
				NMG_CK_VERTEX( ck_v );
			}
a1988 6
			new_lu = nmg_mlv(parent,
				(struct vertex *)NMG_INDEX_VALUE(trans_tbl, old_v->index),
				lu->orientation);
			new_vu = RT_LIST_FIRST(vertexuse,
				&new_lu->down_hd);

d1992 6
a1997 3
			if (!trans_tbl[old_v->index])
				trans_tbl[old_v->index] =
					(long *)new_vu->v_p;
a1999 7

			if (old_v->vg_p) {
				NMG_CK_VERTEX_G(old_v->vg_p);
				nmg_vertex_gv(new_vu->v_p,
					eu->vu_p->v_p->vg_p->coord);
			}

d2005 1
a2005 4
			new_eu = nmg_eusplit(
				(struct vertex *)trans_tbl[old_v->index],
				new_eu);

d2008 12
a2019 2
			if (!trans_tbl[old_v->index])
				trans_tbl[old_v->index] = (long *)new_vu->v_p;
d2021 7
a2027 4
			if (old_v->vg_p)
				nmg_vertex_gv(new_vu->v_p,
					eu->vu_p->v_p->vg_p->coord);

d2029 1
a2029 1
		/* XXX ought to do something with edges & trans_tbl here? */
d2032 16
d2050 2
d2054 3
a2056 2
		nmg_edge_g(eu->e_p);
		/* XXX ought to do something with edges & trans_tbl here? */
@


10.43
log
@Changed nmg_find_loop_in_facelist() et.al. to nmg_is_loop_in_facelist().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.42 93/03/26 23:00:05 mike Exp Locker: mike $ (BRL)";
d893 26
a918 2
 *  Reverse the orientation of a face.
 *  Manipulate both the topological and geometric aspects of the face.
@


10.42
log
@Moved nmg_sanitize_s_lv() and nmg_shell_is_empty() from nmg_bool.c
to nmg_mod.c and nmg_info.c, respectively.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.41 93/03/26 21:52:34 mike Exp Locker: mike $ (BRL)";
d202 1
a202 1
			if( nmg_find_loop_in_facelist( lu->l_p, &s->fu_hd ) )  {
d219 1
a219 1
			if( nmg_find_edge_in_facelist( eu->e_p, &s->fu_hd ) )  {
d236 1
a236 1
		if( nmg_find_edge_in_looplist( eu->e_p, &s->lu_hd ) )  {
d260 3
a262 3
		if( nmg_find_vertex_in_facelist( vu->v_p, &s->fu_hd ) ||
		    nmg_find_vertex_in_looplist( vu->v_p, &s->lu_hd,0 ) ||
		    nmg_find_vertex_in_edgelist( vu->v_p, &s->eu_hd ) )  {
@


10.41
log
@Reorganized the layout of the source code.
Changed return code of nmg_simplify_shell() to int.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.40 93/03/26 21:28:55 mike Exp Locker: mike $ (BRL)";
d36 110
d169 1
a169 1
	if( nmg_is_shell_empty(s) )  return 1;
d275 79
@


10.40
log
@Changed nmg_merge_2faces() to nmg_jf().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.39 93/03/26 21:23:49 mike Exp Locker: mike $ (BRL)";
d29 6
d36 1
a36 1
 *			N M G _ F U _ P L A N E E Q N
d38 2
a39 3
 *  Given a convex face that has been constructed with edges listed in
 *  counter-clockwise (CCW) order, compute the surface normal and plane
 *  equation for this face.
d41 3
a43 39
 *
 *			D                   C
 *	                *-------------------*
 *	                |                   |
 *	                |   .<...........   |
 *	   ^     N      |   .           ^   |     ^
 *	   |      \     |   .  counter- .   |     |
 *	   |       \    |   .   clock   .   |     |
 *	   |C-B     \   |   .   wise    .   |     |C-B
 *	   |         \  |   v           .   |     |
 *	   |          \ |   ...........>.   |     |
 *	               \|                   |
 *	                *-------------------*
 *	                A                   B
 *			      <-----
 *				A-B
 *
 *  If the vertices in the loop are given in the order A B C D
 *  (e.g., counter-clockwise),
 *  then the outward pointing surface normal can be computed as:
 *
 *		N = (C-B) x (A-B)
 *
 *  This is the "right hand rule".
 *  For reference, note that a vector which points "into" the loop
 *  can be subsequently found by taking the cross product of the
 *  surface normal and any edge vector, e.g.:
 *
 *		Left = N x (B-A)
 *	or	Left = N x (C-B)
 *
 *  This routine will skip on past edges that start and end on
 *  the same vertex, in an attempt to avoid trouble.
 *  However, the loop *must* be convex for this routine to work.
 *  Otherwise, the surface normal may be inadvertently reversed.
 *
 *  Returns -
 *	0	OK
 *	-1	failure
d46 2
a47 3
nmg_fu_planeeqn( fu, tol )
struct faceuse		*fu;
CONST struct rt_tol	*tol;
d49 2
a50 4
	struct edgeuse		*eu, *eu_final, *eu_next;
	struct loopuse		*lu;
	plane_t			plane;
	struct vertex		*a, *b, *c;
d52 6
a57 44
	NMG_CK_FACEUSE(fu);
	lu = RT_LIST_FIRST(loopuse, &fu->lu_hd);
	NMG_CK_LOOPUSE(lu);

	if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
		return -1;
	eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
	NMG_CK_EDGEUSE(eu);
	a = eu->vu_p->v_p;
	NMG_CK_VERTEX(a);

	eu_next = eu;
	do {
		eu_next = RT_LIST_PNEXT_CIRC(edgeuse, eu_next);
		NMG_CK_EDGEUSE(eu_next);
		if( eu_next == eu )  return -1;
		b = eu_next->vu_p->v_p;
		NMG_CK_VERTEX(b);
	} while( (b == a
		|| VAPPROXEQUAL(a->vg_p->coord, b->vg_p->coord, tol->dist))
		&& eu_next->vu_p != eu->vu_p );

	eu_final = eu_next;
	do {
		eu_final = RT_LIST_PNEXT_CIRC(edgeuse, eu_final);
		NMG_CK_EDGEUSE(eu_final);
		if( eu_final == eu )  return -1;
		c = eu_final->vu_p->v_p;
		NMG_CK_VERTEX(c);
	} while( (c == b
		|| VAPPROXEQUAL(a->vg_p->coord, c->vg_p->coord, tol->dist)
		|| VAPPROXEQUAL(b->vg_p->coord, c->vg_p->coord, tol->dist)
		|| rt_3pts_collinear(a->vg_p->coord, b->vg_p->coord,
			c->vg_p->coord, tol))
		&& eu_next->vu_p != eu->vu_p );

	if (rt_mk_plane_3pts(plane,
	    a->vg_p->coord, b->vg_p->coord, c->vg_p->coord, tol) < 0 ) {
		rt_log("nmg_fu_planeeqn(): rt_mk_plane_3pts failed on (%g,%g,%g) (%g,%g,%g) (%g,%g,%g)\n",
			V3ARGS( a->vg_p->coord ),
			V3ARGS( b->vg_p->coord ),
			V3ARGS( c->vg_p->coord ) );
	    	HPRINT("plane", plane);
		return(-1);
d59 2
a60 7
	if (plane[0] == 0.0 && plane[1] == 0.0 && plane[2] == 0.0) {
		rt_log("nmg_fu_planeeqn():  Bad plane equation from rt_mk_plane_3pts\n" );
	    	HPRINT("plane", plane);
		return(-1);
	}
	nmg_face_g( fu, plane);
	return(0);
d64 1
a64 1
 *			N M G _ C F A C E
d66 5
a70 23
 *	Create a loop within a face, given a list of vertices.
 *
 *	"verts" is an array of "n" pointers to (struct vertex).  "s" is the
 *	parent shell for the new face.  The face will consist of a single loop
 *	made from edges between the n vertices.
 *
 *	If verts is a null pointer (no vertex list), all vertices of the face
 *	will be new points.  Otherwise, verts is a pointer to a list of
 *	vertices to use in creating the face/loop.  Null entries within the
 *	list will cause a new vertex to be created for that point.  Such new
 *	vertices will be inserted into the list for return to the caller.
 *
 *	The vertices should be listed in
 *	"counter-clockwise" (CCW) order if this is an ordinary face (loop),
 *	and in "clockwise" (CW) order if this is an interior
 * 	("hole" or "subtracted") face (loop).
 *	This routine makes only topology, without reference to any geometry.
 *
 *	Note that this routine inserts new vertices (by edge use splitting)
 *	at the head of the loop, which reverses the order.
 *	Therefore, the caller's vertices are traversed in reverse order
 *	to counter this behavior, and
 *	to effect the proper vertex order in the final face loop.
d72 3
a74 5
struct faceuse *
nmg_cface(s, verts, n)
struct shell *s;
struct vertex *verts[];
int n;
d76 1
a76 2
	struct faceuse *fu;
	struct edgeuse *eu;
d78 3
a80 2
	struct vertexuse *vu;
	int i;
a82 5
	if (n < 1) {
		rt_log("nmg_cface(s=x%x, verts=x%x, n=%d.)\n",
			s, verts, n );
		rt_bomb("nmg_cface() trying to make bogus face\n");
	}
d84 14
a97 4
	if (verts) {
		for (i=0 ; i < n ; ++i) {
			if (verts[i]) {
				NMG_CK_VERTEX(verts[i]);
d99 1
a100 4
		lu = nmg_mlv(&s->l.magic, verts[n-1], OT_SAME);
		fu = nmg_mf(lu);
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
		eu = nmg_meonvu(vu);
d102 14
a115 8
		if (!verts[n-1])
			verts[n-1] = eu->vu_p->v_p;

		for (i = n-2 ; i >= 0 ; i--) {
			eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
			eu = nmg_eusplit(verts[i], eu);
			if (!verts[i])
				verts[i] = eu->vu_p->v_p;
d117 1
d119 12
a130 7
	} else {
		lu = nmg_mlv(&s->l.magic, (struct vertex *)NULL, OT_SAME);
		fu = nmg_mf(lu);
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
		eu = nmg_meonvu(vu);
		while (--n) {
			(void)nmg_eusplit((struct vertex *)NULL, eu);
d132 1
a133 2
	return (fu);
}
d135 11
a145 52
/*
 *			N M G _ A D D _ L O O P _ T O _ F A C E
 *
 *	Create a new loop within a face, given a list of vertices.
 *	Modified version of nmg_cface().
 *
 *	"verts" is an array of "n" pointers to (struct vertex).  "s" is the
 *	parent shell for the new face.  The face will consist of a single loop
 *	made from edges between the n vertices.
 *
 *	If verts is a null pointer (no vertex list), all vertices of the face
 *	will be new points.  Otherwise, verts is a pointer to a list of
 *	vertices to use in creating the face/loop.  Null entries within the
 *	list will cause a new vertex to be created for that point.  Such new
 *	vertices will be inserted into the list for return to the caller.
 *
 *	The vertices should be listed in "counter-clockwise" (CCW) order if
 *	this is an ordinary face (loop), and in "clockwise" (CW) order if
 *	this is an interior ("hole" or "subtracted") face (loop).  This
 *	routine makes only topology, without reference to any geometry.
 *
 *	Note that this routine inserts new vertices (by edge use splitting)
 *	at the head of the loop, which reverses the order.  Therefore, the
 *	caller's vertices are traversed in reverse order to counter this
 *	behavior, and to effect the proper vertex order in the final face
 *	loop.
 */
struct faceuse *
nmg_add_loop_to_face(s, fu, verts, n, dir)
struct shell *s;
struct faceuse *fu;
struct vertex *verts[];
int n, dir;
{
	int i, j;
	struct edgeuse *eu;
	struct loopuse *lu;
	struct vertexuse *vu;

	NMG_CK_SHELL(s);
	if (n < 1) {
		rt_log("nmg_add_loop_to_face(s=x%x, verts=x%x, n=%d.)\n",
			s, verts, n );
		rt_bomb("nmg_add_loop_to_face: request to make 0 faces\n");
	}

	if (verts) {
		if (!fu) {
			lu = nmg_mlv(&s->l.magic, verts[n-1], dir);
			fu = nmg_mf(lu);
		} else {
			lu = nmg_mlv(&fu->l.magic, verts[n-1], dir);
d147 12
a158 10
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
		eu = nmg_meonvu(vu);
		if (!verts[n-1])
			verts[n-1] = eu->vu_p->v_p;

		for (i = n-2 ; i >= 0 ; i--) {
			eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
			eu = nmg_eusplit(verts[i], eu);
			if (!verts[i])
				verts[i] = eu->vu_p->v_p;
d160 1
a160 12
	} else {
		if (!fu) {
			lu = nmg_mlv(&s->l.magic, (struct vertex *)NULL, dir);
			fu = nmg_mf(lu);
		} else {
			lu = nmg_mlv(&fu->l.magic, (struct vertex *)NULL, dir);
		}
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
		eu = nmg_meonvu(vu);
		while (--n) {
			(void)nmg_eusplit((struct vertex *)NULL, eu);
		}
d162 3
a164 1
	return (fu);
d167 6
d329 1
a329 1
 *			N M G _ E U S P L I T
d331 1
a331 1
 *	Split an edgeuse by inserting a vertex into middle of the edgeuse.
d333 3
a335 4
 *	Make a new edge, and a vertex.  If v is non-null it is taken as a
 *	pointer to an existing vertex to use as the start of the new edge.
 *	If v is null, then a new vertex is created for the begining of the
 *	new edge.
d337 5
a341 2
 *	In either case, the new edge will exist as the "next" edgeuse after
 *	the edgeuse passed as a parameter.
d343 5
a347 2
 *  Explicit return -
 *	edgeuse of new edge, starting at v.
d349 5
a353 19
 *  List on entry -
 *
 *		       oldeu
 *		  .------------->
 *		 /
 *		A =============== B (edge)
 *				 /
 *		  <-------------.
 *		      oldeumate
 *
 *  List on return -
 *
 *		     oldeu(cw)    eu1
 *		    .------->   .----->
 *		   /           /
 *	   (edge) A ========= V ~~~~~~~ B (new edge)
 *			     /         /
 *		    <-------.   <-----.
 *		       mate	 mate
d355 5
a359 4
struct edgeuse *
nmg_eusplit(v, oldeu)
struct vertex *v;
struct edgeuse *oldeu;
d361 2
a362 4
	struct edgeuse	*eu1,
			*eu2,
			*oldeumate;
	struct shell *s;
d364 2
d367 5
a371 3
	NMG_CK_EDGEUSE(oldeu);
	if (v) {
		NMG_CK_VERTEX(v);
a372 2
	oldeumate = oldeu->eumate_p;
	NMG_CK_EDGEUSE( oldeumate );
d374 10
a383 7
	/* if this edge has uses other than this edge and its mate, we must
	 * separate these two edgeuses from the existing edge, and create
	 * a new edge for them.  Then we can insert a new vertex in this
	 * new edge without fear of damaging some other object.
	 */
	if (oldeu->radial_p != oldeumate)
		nmg_unglueedge(oldeu);
d385 2
a386 3
	if (*oldeu->up.magic_p == NMG_SHELL_MAGIC) {
		s = oldeu->up.s_p;
		NMG_CK_SHELL(s);
d388 5
a392 33
		/*
		 *  Make an edge from the new vertex ("V") to vertex at
		 *  other end of the edge given ("B").
		 *  The new vertex "V" may be NULL, which will cause the
		 *  shell's lone vertex to be used, or a new one obtained.
		 *  New edges will be placed at head of shell's edge list.
		 */
		eu1 = nmg_me(v, oldeumate->vu_p->v_p, s);
		eu2 = eu1->eumate_p;

		/*
		 *  The situation is now:
		 *
		 *      eu1			       oldeu
		 *  .----------->		  .------------->
		 * /				 /
		 *V ~~~~~~~~~~~~~ B (new edge)	A =============== B (edge)
		 *		 /				 /
		 *  <-----------.		  <-------------.
		 *      eu2			      oldeumate
		 */

		/* Make oldeumate start at "V", not "B" */
		nmg_movevu(oldeumate->vu_p, eu1->vu_p->v_p);

		/*
		 *  Enforce rigid ordering in shell's edge list:
		 *	oldeu, oldeumate, eu1, eu2
		 *  This is to keep edges & mates "close to each other".
		 */
		if( RT_LIST_PNEXT(edgeuse, oldeu) != oldeumate )  {
			RT_LIST_DEQUEUE( &oldeumate->l );
			RT_LIST_APPEND( &oldeu->l, &oldeumate->l );
a393 4
		RT_LIST_DEQUEUE( &eu1->l );
		RT_LIST_DEQUEUE( &eu2->l );
		RT_LIST_APPEND( &oldeumate->l, &eu1->l );
		RT_LIST_APPEND( &eu1->l, &eu2->l );
a394 36
		/*
		 *	     oldeu(cw)    eu1
		 *	    .------->   .----->
		 *	   /           /
		 * (edge) A ========= V ~~~~~~~ B (new edge)
		 *		     /         /
		 *	    <-------.   <-----.
		 *	    oldeumate     eu2
		 */
		return(eu1);
	}
	else if (*oldeu->up.magic_p != NMG_LOOPUSE_MAGIC) {
		rt_log("nmg_eusplit() in %s at %d invalid edgeuse parent\n",
			__FILE__, __LINE__);
		rt_bomb("nmg_eusplit\n");
	}

	/* now we know we are in a loop */

	lu = oldeu->up.lu_p;
	NMG_CK_LOOPUSE(lu);

	/* get a parent shell pointer so we can make a new edge */
	if (*lu->up.magic_p == NMG_SHELL_MAGIC)
		s = lu->up.s_p;
	else if (*lu->up.magic_p == NMG_FACEUSE_MAGIC)
		s = lu->up.fu_p->s_p;
	else
		rt_bomb("nmg_eusplit() bad lu->up\n");
	NMG_CK_SHELL(s);

	/* Make a new wire edge in the shell */
	if (v) {
		/* An edge on the single vertex "V" */
		eu1 = nmg_me(v, v, s);
		eu2 = eu1->eumate_p;
d396 7
a402 7
		/* Form a wire edge between two new vertices */
		eu1 = nmg_me((struct vertex *)NULL, (struct vertex *)NULL, s);
		eu2 = eu1->eumate_p;
		/* Make both ends of edge use same vertex.
		 * The second vertex is freed automaticly.
		 */
		nmg_movevu(eu2->vu_p, eu1->vu_p->v_p);
d404 1
a404 61

	/*
	 *  The current situation is now:
	 *
	 *	      eu1				       oldeu
	 *	  .------------->			  .------------->
	 *	 /					 /
	 *	V ~~~~~~~~~~~~~~~ V (new edge)		A =============== B (edge)
	 *			 /					 /
	 *	  <-------------.			  <-------------.
	 *	      eu2				      oldeumate
	 *
	 *  Goals:
	 *  eu1 will become the mate to oldeumate on the existing edge.
	 *  eu2 will become the mate of oldeu on the new edge.
	 */
	RT_LIST_DEQUEUE( &eu1->l );
	RT_LIST_DEQUEUE( &eu2->l );
	RT_LIST_APPEND( &oldeu->l, &eu1->l );
	RT_LIST_APPEND( &oldeumate->l, &eu2->l );

	/*
	 *  The situation is now:
	 *
	 *		       oldeu      eu1			>>>loop>>>
	 *		    .------->   .----->
	 *		   /           /
	 *	   (edge) A ========= V ~~~~~~~ B (new edge)
	 *			     /         /
	 *		    <-------.   <-----.	
	 *		       eu2      oldeumate		<<<loop<<<
	 */

	/* Copy parentage (loop affiliation) and orientation */
	eu1->up.magic_p = oldeu->up.magic_p;
	eu1->orientation = oldeu->orientation;
	eu1->eua_p = (struct edgeuse_a *)NULL;

	eu2->up.magic_p = oldeumate->up.magic_p;
	eu2->orientation = oldeumate->orientation;
	eu2->eua_p = (struct edgeuse_a *)NULL;

	/* Build mate relationship */
	eu1->eumate_p = oldeumate;
	oldeumate->eumate_p = eu1;
	eu2->eumate_p = oldeu;
	oldeu->eumate_p = eu2;

	/*  Build radial relationship.
	 *  Simple only because this edge has no other uses.
	 */
	eu1->radial_p = oldeumate;
	oldeumate->radial_p = eu1;
	eu2->radial_p = oldeu;
	oldeu->radial_p = eu2;

	/* Associate oldeumate with new edge, and eu2 with old edge. */
	oldeumate->e_p = eu1->e_p;
	eu2->e_p = oldeu->e_p;

	return(eu1);
d408 1
a408 1
 *			N M G _ M O V E L T O F
d410 2
a411 31
 *	move first pair of shell wire loopuses out to become a genuine loop
 *	in an existing face.
 * XXX This routine is not used anywhere.
 */
void nmg_moveltof(fu, s)
struct faceuse *fu;
struct shell *s;
{
	struct loopuse	*lu1, *lu2;

	NMG_CK_SHELL(s);
	NMG_CK_FACEUSE(fu);
	if (fu->s_p != s) {
		rt_log("nmg_moveltof() in %s at %d. Cannot move loop to face in another shell\n",
		    __FILE__, __LINE__);
	}
	lu1 = RT_LIST_FIRST(loopuse, &s->lu_hd);
	NMG_CK_LOOPUSE(lu1);
	RT_LIST_DEQUEUE( &lu1->l );

	lu2 = RT_LIST_FIRST(loopuse, &s->lu_hd);
	NMG_CK_LOOPUSE(lu2);
	RT_LIST_DEQUEUE( &lu2->l );

	RT_LIST_APPEND( &fu->lu_hd, &lu1->l );
	RT_LIST_APPEND( &fu->fumate_p->lu_hd, &lu2->l );
	/* XXX What about loopuse "up" pointers? */
}

/*
 *			N M G _ E S P L I T
d413 3
a415 4
 *	Split an edge by inserting a vertex into middle of *all* of the
 *	uses of this edge, and combine the new edgeuses together onto the
 *	new edge.
 *	A more powerful version of nmg_eusplit(), which does only one use.
d417 5
a421 4
 *	Makes a new edge, and a vertex.  If v is non-null it is taken as a
 *	pointer to an existing vertex to use as the start of the new edge.
 *	If v is null, then a new vertex is created for the begining of the
 *	new edge.
d423 4
a426 2
 *	In either case, the new edgeuse will exist as the "next" edgeuse
 *	after the edgeuse passed as a parameter.
d428 5
a432 31
 *	Note that eu->e_p changes value upon return, because the old
 *	edge is incrementally replaced by two new ones.
 *
 *  Explicit return -
 *	Pointer to the edgeuse which starts at the newly created
 *	vertex (V), and runs to B.
 *
 *  Implicit returns -
 *	ret_eu->vu_p->v_p gives the new vertex ("v", if non-null), and
 *	ret_eu->e_p is the new edge that runs from V to B.
 *
 *	The new vertex created will also be eu->eumate_p->vu_p->v_p.
 *
 *  Edge on entry -
 *
 *			eu
 *		  .------------->
 *		 /
 *		A =============== B (edge)
 *				 /
 *		  <-------------.
 *		    eu->eumate_p
 *
 *  Edge on return -
 *
 *			eu	  ret_eu
 *		    .------->   .--------->
 *		   /           /
 *	(newedge) A ========= V ~~~~~~~~~~~ B (new edge)
 *			     /             /
 *		    <-------.   <---------.
d434 6
a439 4
struct edgeuse *
nmg_esplit(v, eu)
struct vertex	*v;		/* New vertex, to go in middle */
struct edgeuse	*eu;
d441 4
a444 6
	struct edge	*e;	/* eu->e_p */
	struct edgeuse	*teuX,	/* radial edgeuse of eu */
			*teuY,	/* new edgeuse (next of teuX) */
			*neu1, *neu2; /* new (split) edgeuses */
	int 		notdone=1;
	struct vertex	*vA, *vB;	/* start and end of eu */
d446 5
a450 19
	neu1 = neu2 = (struct edgeuse *)NULL;

	NMG_CK_EDGEUSE(eu);
	e = eu->e_p;
	NMG_CK_EDGE(e);

	NMG_CK_VERTEXUSE(eu->vu_p);
	vA = eu->vu_p->v_p;
	NMG_CK_VERTEX(vA);

	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	vB = eu->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX(vB);

	/* vA and vB are the endpoints of the original edge "e" */
	if( vA == vB )  {
		rt_log("WARNING: nmg_esplit() on edge from&to v=x%x\n", vA);
		rt_bomb("nmg_esplit() of edge running from&to same v\n");
a451 4
	if( v && ( v == vA || v == vB ) )  {
		rt_log("WARNING: nmg_esplit(v=x%x) vertex is already an edge vertex\n", v);
		rt_bomb("nmg_esplit() new vertex is already an edge vertex\n");
	}
d453 6
a458 22
	/* one at a time, we peel out & split an edgeuse pair of this edge.
	 * when we split an edge that didn't need to be peeled out, we know
	 * we've split the last edge
	 */
	do {
		/* Peel two temporary edgeuses off the original edge */
		teuX = eu->radial_p;
		/* teuX runs from vA to vB */
		teuY = nmg_eusplit(v, teuX);
		/* Now, teuX runs from vA to v, teuY runs from v to vB */
		NMG_CK_EDGEUSE(teuX);
		NMG_CK_EDGEUSE(teuY);
		NMG_TEST_EDGEUSE(teuX);
		NMG_TEST_EDGEUSE(teuY);
		
		if (!v)  {
			/* If "v" parameter was NULL and this is the
			 * first time through, take note of "v" where
			 * "e" was just split at.
			 */
			v = teuY->vu_p->v_p;
			NMG_CK_VERTEX(v);
d460 4
d465 10
a474 22
		if (teuY->e_p == e || teuX->e_p == e) notdone = 0;
		
		/*  Are the two edgeuses going in same or opposite directions?
		 *  Move the newly created temporary edge (teuX, teuY)
		 *  onto the new edge (neu1, neu2).
		 *  On first pass, just take note of the new edge & edgeuses.
		 */
		NMG_CK_VERTEX(teuX->vu_p->v_p);
		if (teuX->vu_p->v_p == vA) {
			if (neu1) {
				nmg_moveeu(neu1, teuX);
				nmg_moveeu(neu2, teuY);
			}
			neu1 = teuX->eumate_p;
			neu2 = teuY->eumate_p;
		} else if (teuX->vu_p->v_p == vB) {
			if (neu1) {
				nmg_moveeu(neu2, teuX);
				nmg_moveeu(neu1, teuY);
			}
			neu2 = teuX->eumate_p;
			neu1 = teuY->eumate_p;
d476 1
a476 3
			rt_log("nmg_esplit(v=x%x, e=x%x)\n", v, e);
			rt_log("nmg_esplit: teuX->vu_p->v_p=x%x, vA=x%x, vB=x%x\n", teuX->vu_p->v_p, vA, vB );
			rt_bomb("nmg_esplit() teuX->vu_p->v_p is neither vA nor vB\n");
d478 7
a484 8
	} while (notdone);
	/* Here, "e" pointer is invalid -- it no longer exists */

	/* Find an edgeuse that runs from v to vB */
	if( neu2->vu_p->v_p == v && neu2->eumate_p->vu_p->v_p == vB )
		return neu2;

	rt_bomb("nmg_esplit() unable to find eu starting at new v\n");
d488 1
a488 1
 *			N M G _ E B R E A K
d490 3
a492 3
 *  Like nmg_esplit(), split an edge into two parts, but where the
 *  two resultant parts share the original edge geometry.
 *  If the original edge had no edge geometry, then none is created here.
a493 45
 *  The return is the return of nmg_esplit().
 */
struct edgeuse *
nmg_ebreak(v, eu)
struct vertex	*v;
struct edgeuse	*eu;
{
	struct edgeuse	*new_eu;
	struct edge_g	*eg;

	NMG_CK_EDGEUSE(eu);
	eg = eu->e_p->eg_p;

	/* nmg_esplit() will delete eu->e_p, so if geom is present, save it! */
	if( eg )  {
		NMG_CK_EDGE_G(eg);
		eg->usage++;
	}

	new_eu = nmg_esplit(v, eu);	/* Do the hard work */
	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGEUSE(new_eu);

	/* If there wasn't any edge geometry before, nothing more to do */
	if( !eg ) return new_eu;

	/* Both these edges should be fresh, without geometry yet. */
	if( eu->e_p->eg_p )   {
		rt_log("old eg=x%x, new_eg=x%x\n", eg, eu->e_p->eg_p);
		nmg_pr_eg(eg, "old_");
		nmg_pr_eg(eu->e_p->eg_p, "new_");
		rt_bomb("nmg_ebreak() eu grew geometry?\n");
	}
	if( new_eu->e_p->eg_p )  rt_bomb("nmg_ebreak() new_eu grew geometry?\n");

	/* Make sure the two edges share the same geometry. */
	NMG_CK_EDGE_G(eg);
	eu->e_p->eg_p = eg;		/* eg->usage++ was done above */
	new_eu->e_p->eg_p = eg;
	eg->usage++;
	return new_eu;
}

/*
 *			N M G _ E 2 B R E A K
d495 15
a509 26
 *  Given two edges that are known to intersect someplace other than
 *  at any of their endpoints, break both of them and
 *  insert a shared vertex.
 *  Return a pointer to the new vertex.
 */
struct vertex *
nmg_e2break( eu1, eu2 )
struct edgeuse	*eu1;
struct edgeuse	*eu2;
{
	struct vertex		*v;
	struct edgeuse		*new_eu;

	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);

	new_eu = nmg_ebreak( NULL, eu1 );
	v = new_eu->vu_p->v_p;
	NMG_CK_VERTEX(v);
	(void)nmg_ebreak( v, eu2 );

	return v;
}

/*
 *			N M G _ E I N S
d511 3
a513 3
 *	Insert a new (zero length) edge at the begining of (ie, before)
 *	an existing edgeuse
 *	Perhaps this is what nmg_esplit and nmg_eusplit should have been like?
d515 1
a515 6
 *	Before:
 *	.--A--> .--eu-->
 *		 \
 *		  >.
 *		 /
 *	  <-A'--. <-eu'-.
d517 4
d522 2
a523 1
 *	After:
d525 8
a532 7
 *               eu1     eu
 *	.--A--> .---> .--eu-->
 *		 \   /
 *		  >.<
 *		 /   \
 *	  <-A'--. <---. <-eu'--.
 *	          eu2     eumate
d534 4
a537 3
struct edgeuse *
nmg_eins(eu)
struct edgeuse *eu;
d539 4
a542 3
	struct edgeuse	*eumate;
	struct edgeuse	*eu1, *eu2;
	struct shell	*s;
d544 7
d552 2
a553 2
	eumate = eu->eumate_p;
	NMG_CK_EDGEUSE(eumate);
d555 10
a564 20
	if (*eu->up.magic_p == NMG_SHELL_MAGIC) {
		s = eu->up.s_p;
		NMG_CK_SHELL(s);
	}
	else {
		struct loopuse *lu;
		
		lu = eu->up.lu_p;
		NMG_CK_LOOPUSE(lu);
		if (*lu->up.magic_p == NMG_SHELL_MAGIC) {
			s = lu->up.s_p;
			NMG_CK_SHELL(s);
		} else {
			struct faceuse *fu;
			fu = lu->up.fu_p;
			NMG_CK_FACEUSE(fu);
			s = fu->s_p;
			NMG_CK_SHELL(s);
		}
	}
d566 13
a578 2
	eu1 = nmg_me(eu->vu_p->v_p, eu->vu_p->v_p, s);
	eu2 = eu1->eumate_p;
d580 8
a587 9
	if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC) {
		RT_LIST_DEQUEUE( &eu1->l );
		RT_LIST_DEQUEUE( &eu2->l );

		RT_LIST_INSERT( &eu->l, &eu1->l );
		RT_LIST_APPEND( &eumate->l, &eu2->l );

		eu1->up.lu_p = eu->up.lu_p;
		eu2->up.lu_p = eumate->up.lu_p;
d589 4
a592 2
	else {
		rt_bomb("nmg_eins() Cannot yet insert null edge in shell\n");
d594 2
a595 1
	return(eu1);
d603 2
d665 36
d702 209
a1187 298
/*			N M G _ S I M P L I F Y _ L O O P
 *
 *	combine adjacent loops within the same parent
 */
void
nmg_simplify_loop(lu)
struct loopuse *lu;
{
	struct edgeuse *eu, *eu_r, *tmpeu;

	NMG_CK_LOOPUSE(lu);
	if (RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC)
		return;

	eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
	while (RT_LIST_NOT_HEAD(eu, &lu->down_hd) ) {

		NMG_CK_EDGEUSE(eu);

		eu_r = eu->radial_p;
		NMG_CK_EDGEUSE(eu_r);

		/* if the radial edge is part of a loop, and the loop of
		 * the other edge is a part of the same object (face)
		 * as the loop containing the current edge, and my
		 * edgeuse mate is radial to my radial`s edgeuse
		 * mate, and the radial edge is a part of a loop other
		 * than the one "eu" is a part of 
		 * then this is a "worthless" edge between these two loops.
		 */
		if (*eu_r->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    eu_r->up.lu_p->up.magic_p == lu->up.magic_p &&
		    eu->eumate_p->radial_p == eu->radial_p->eumate_p &&
		    eu_r->up.lu_p != lu) {

		    	/* save a pointer to where we've already been
		    	 * so that when eu becomes an invalid pointer, we
		    	 * still know where to pick up from.
		    	 */
		    	tmpeu = RT_LIST_PLAST(edgeuse, eu);

			nmg_jl(lu, eu);

		    	/* Since all the new edges will have been appended
		    	 * after tmpeu, we can pick up processing with the
		    	 * edgeuse immediately after tmpeu
		    	 */
		    	eu = tmpeu;

		    	if (rt_g.NMG_debug &(DEBUG_PLOTEM|DEBUG_PL_ANIM) &&
			    *lu->up.magic_p == NMG_FACEUSE_MAGIC ) {
		    	    	static int fno=0;

				nmg_pl_2fu("After_joinloop%d.pl", fno++,
				    lu->up.fu_p, lu->up.fu_p->fumate_p, 0);
					
		    	}
		}
		eu = RT_LIST_PNEXT(edgeuse, eu);
	}
}


/*
 *			N M G _ K I L L _ S N A K E S
 *
 *  Removes "snake" or "disconnected crack" edges from loopuse.
 *
 *  Returns -
 *	0	If all went well
 *	1	If the loopuse is now empty and needs to be killed.
 */
int
nmg_kill_snakes(lu)
struct loopuse *lu;
{
	struct edgeuse *eu, *eu_r;
	struct vertexuse *vu;
	struct vertex *v;

	NMG_CK_LOOPUSE(lu);
	if (RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC)
		return;

	eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
	while (RT_LIST_NOT_HEAD(eu, &lu->down_hd) ) {

		NMG_CK_EDGEUSE(eu);

		eu_r = eu->radial_p;
		NMG_CK_EDGEUSE(eu_r);

		/* if the radial edge is a part of the same loop, and
		 * this edge is not used by anyplace else, and the radial edge
		 * is also the next edge, this MAY be the tail of a snake!
		 */

		if (*eu_r->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    eu_r->up.lu_p == eu->up.lu_p &&
		    eu->eumate_p->radial_p == eu->radial_p->eumate_p &&
		    RT_LIST_PNEXT_CIRC(edgeuse, eu) == eu_r) {

		    	/* if there are no other uses of the vertex
		    	 * between these two edgeuses, then this is
		    	 * indeed the tail of a snake
		    	 */
			v = eu->eumate_p->vu_p->v_p;
			vu = RT_LIST_FIRST(vertexuse, &v->vu_hd);
			while (RT_LIST_NOT_HEAD(vu, &v->vu_hd) &&
			      (vu->up.eu_p == eu->eumate_p ||
			       vu->up.eu_p == eu_r) )
				vu = RT_LIST_PNEXT(vertexuse, vu);

			if (! RT_LIST_NOT_HEAD(vu, &v->vu_hd) ) {
				/* this is the tail of a snake! */
				(void)nmg_keu(eu_r);
				if( nmg_keu(eu) )  return 1; /* kill lu */
				if( RT_LIST_IS_EMPTY( &lu->down_hd ) )
					return 1;	/* loopuse is empty */
				eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);

			    	if (rt_g.NMG_debug &(DEBUG_PLOTEM|DEBUG_PL_ANIM) &&
				    *lu->up.magic_p == NMG_FACEUSE_MAGIC ) {
			    	    	static int fno=0;

					nmg_pl_2fu("After_joinloop%d.pl", fno++,
					    lu->up.fu_p, lu->up.fu_p->fumate_p, 0);

			    	}


			} else
				eu = RT_LIST_PNEXT(edgeuse, eu);
		} else
			eu = RT_LIST_PNEXT(edgeuse, eu);
	}
	return 0;	/* All is well, loop still has edges */
}


/*			N M G _ S I M P L I F Y _ F A C E
 *
 *
 *	combine adjacent loops within a face which serve no apparent purpose
 *	by remaining separate and distinct.  Kill "wire-snakes" in face.
 *
 * Returns -
 *	0	If all was OK
 *	1	If faceuse is now empty
 */
int
nmg_simplify_face(fu)
struct faceuse *fu;
{
	struct loopuse *lu, *lu2;
	int overlap;

	NMG_CK_FACEUSE(fu);

	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))  {
		nmg_simplify_loop(lu);
	}

	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))  {
		if( nmg_kill_snakes(lu) )  {
			struct loopuse	*klu = lu;
			lu = RT_LIST_PREV( loopuse, &lu->l );
			nmg_klu(klu);
		}
	}

	if( RT_LIST_IS_EMPTY(&fu->lu_hd) )  return 1;
	return 0;
}

/*
 *			N M G _ S I M P L I F Y _ S H E L L
 */
void
nmg_simplify_shell(s)
struct shell *s;
{
	struct faceuse *fu;
	NMG_CK_SHELL(s);

	for (RT_LIST_FOR(fu, faceuse, &s->fu_hd)) {
		if( nmg_simplify_face(fu) )  {
			struct faceuse	*kfu = fu;
			fu = RT_LIST_PREV( faceuse, &fu->l );
			nmg_kfu( kfu );
		}
	}
}

/*
 *			N M G _ R M _ R E D U N D A N C I E S
 *
 *  Remove all redundant parts between the different "levels" of a shell.
 *  Remove wire loops that match face loops.
 *  Remove wire edges that match edges in wire loops or face loops.
 *  Remove lone vertices (stored as wire loops on a single vertex) that
 *  match vertices in a face loop, wire loop, or wire edge.
 */
void
nmg_rm_redundancies(s)
struct shell	*s;
{
	struct faceuse	*fu;
	struct loopuse	*lu;
	struct edgeuse	*eu;
	struct vertexuse	*vu;
	long		magic1;

	NMG_CK_SHELL(s);

	if( RT_LIST_NON_EMPTY( &s->fu_hd ) )  {
		/* Compare wire loops -vs- loops in faces */
		lu = RT_LIST_FIRST( loopuse, &s->lu_hd );
		while( RT_LIST_NOT_HEAD( lu, &s->lu_hd ) )  {
			register struct loopuse	*nextlu;
			NMG_CK_LOOPUSE(lu);
			NMG_CK_LOOP(lu->l_p);
			nextlu = RT_LIST_PNEXT( loopuse, lu );
			if( nmg_find_loop_in_facelist( lu->l_p, &s->fu_hd ) )  {
				/* Dispose of wire loop (and mate)
				 * which match face loop */
				if( nextlu == lu->lumate_p )
					nextlu = RT_LIST_PNEXT(loopuse, nextlu);
				nmg_klu( lu );
			}
			lu = nextlu;
		}

		/* Compare wire edges -vs- edges in loops in faces */
		eu = RT_LIST_FIRST( edgeuse, &s->eu_hd );
		while( RT_LIST_NOT_HEAD( eu, &s->eu_hd ) )  {
			register struct edgeuse *nexteu;
			NMG_CK_EDGEUSE(eu);
			NMG_CK_EDGE(eu->e_p);
			nexteu = RT_LIST_PNEXT( edgeuse, eu );
			if( nmg_find_edge_in_facelist( eu->e_p, &s->fu_hd ) )  {
				/* Dispose of wire edge (and mate) */
				if( nexteu == eu->eumate_p )
					nexteu = RT_LIST_PNEXT(edgeuse, nexteu);
				(void)nmg_keu(eu);
			}
			eu = nexteu;
		}
	}

	/* Compare wire edges -vs- edges in wire loops */
	eu = RT_LIST_FIRST( edgeuse, &s->eu_hd );
	while( RT_LIST_NOT_HEAD( eu, &s->eu_hd ) )  {
		register struct edgeuse *nexteu;
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGE(eu->e_p);
		nexteu = RT_LIST_PNEXT( edgeuse, eu );
		if( nmg_find_edge_in_looplist( eu->e_p, &s->lu_hd ) )  {
			/* Kill edge use and mate */
			if( nexteu == eu->eumate_p )
				nexteu = RT_LIST_PNEXT(edgeuse, nexteu);
			(void)nmg_keu(eu);
		}
		eu = nexteu;
	}

	/* Compare lone vertices against everything else */
	/* Individual vertices are stored as wire loops on a single vertex */
	lu = RT_LIST_FIRST( loopuse, &s->lu_hd );
	while( RT_LIST_NOT_HEAD( lu, &s->lu_hd ) )  {
		register struct loopuse	*nextlu;
		NMG_CK_LOOPUSE(lu);
		nextlu = RT_LIST_PNEXT( loopuse, lu );
		magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
		if( magic1 != NMG_VERTEXUSE_MAGIC )  {
			lu = nextlu;
			continue;
		}
		vu = RT_LIST_PNEXT( vertexuse, &lu->down_hd );
		NMG_CK_VERTEXUSE(vu);
		NMG_CK_VERTEX(vu->v_p);
		if( nmg_find_vertex_in_facelist( vu->v_p, &s->fu_hd ) ||
		    nmg_find_vertex_in_looplist( vu->v_p, &s->lu_hd,0 ) ||
		    nmg_find_vertex_in_edgelist( vu->v_p, &s->eu_hd ) )  {
		    	/* Kill lu and mate */
			if( nextlu == lu->lumate_p )
				nextlu = RT_LIST_PNEXT(loopuse, nextlu);
			nmg_klu( lu );
			lu = nextlu;
			continue;
		}
		lu = nextlu;
	}

	/* There really shouldn't be a lone vertex by now */
	if( s->vu_p )  rt_log("nmg_rm_redundancies() lone vertex?\n");
}

d1488 1
a1488 2
/*
 *			N M G _ R E V E R S E _ F A C E
d1490 1
a1490 2
 *  Reverse the orientation of a face.
 *  Manipulate both the topological and geometric aspects of the face.
d1493 2
a1494 2
nmg_reverse_face( fu )
register struct faceuse	*fu;
d1496 1
a1496 2
	register struct faceuse	*fumate;
	register vectp_t	v;
d1498 3
a1500 5
	NMG_CK_FACEUSE(fu);
	fumate = fu->fumate_p;
	NMG_CK_FACEUSE(fumate);
	NMG_CK_FACE(fu->f_p);
	NMG_CK_FACE_G(fu->f_p->fg_p);
d1502 2
a1503 4
	/* reverse face normal vector */
	v = fu->f_p->fg_p->N;
	VREVERSE(v, v);
	v[H] *= -1.0;
d1505 40
a1544 9
	/* switch which face is "outside" face */
	if (fu->orientation == OT_SAME)  {
		if (fumate->orientation != OT_OPPOSITE)  {
			rt_log("nmg_reverse_face(fu=x%x) fu:SAME, fumate:%d\n",
				fu, fumate->orientation);
			rt_bomb("nmg_reverse_face() orientation clash\n");
		} else {
			fu->orientation = OT_OPPOSITE;
			fumate->orientation = OT_SAME;
d1546 1
a1546 13
	} else if (fu->orientation == OT_OPPOSITE) {
		if (fumate->orientation != OT_SAME)  {
			rt_log("nmg_reverse_face(fu=x%x) fu:OPPOSITE, fumate:%d\n",
				fu, fumate->orientation);
			rt_bomb("nmg_reverse_face() orientation clash\n");
		} else {
			fu->orientation = OT_SAME;
			fumate->orientation = OT_OPPOSITE;
		}
	} else {
		/* Unoriented face? */
		rt_log("ERROR nmg_reverse_face(fu=x%x), orientation=%d.\n",
			fu, fu->orientation );
d1550 1
d1552 1
a1552 1
 *			N M G _ M V _ F U _ B E T W E E N _ S H E L L S
d1554 5
a1558 1
 *  Move faceuse from 'src' shell to 'dest' shell.
d1560 3
a1562 5
void
nmg_mv_fu_between_shells( dest, src, fu )
struct shell		*dest;
register struct shell	*src;
register struct faceuse	*fu;
d1564 3
a1566 1
	register struct faceuse	*fumate;
d1568 3
a1570 3
	NMG_CK_FACEUSE(fu);
	fumate = fu->fumate_p;
	NMG_CK_FACEUSE(fumate);
d1572 2
a1573 10
	if (fu->s_p != src) {
		rt_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fu->s_p=x%x isnt src shell\n",
			dest, src, fu, fu->s_p );
		rt_bomb("fu->s_p isnt source shell\n");
	}
	if (fumate->s_p != src) {
		rt_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fumate->s_p=x%x isn't src shell\n",
			dest, src, fu, fumate->s_p );
		rt_bomb("fumate->s_p isnt source shell\n");
	}
d1575 1
a1575 8
	/* Remove fu from src shell */
	RT_LIST_DEQUEUE( &fu->l );
	if( RT_LIST_IS_EMPTY( &src->fu_hd ) )  {
		/* This was the last fu in the list, bad news */
		rt_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fumate=x%x not in src shell\n",
			dest, src, fu, fumate );
		rt_bomb("src shell emptied before finding fumate\n");
	}
d1577 2
a1578 2
	/* Remove fumate from src shell */
	RT_LIST_DEQUEUE( &fumate->l );
d1580 4
a1583 3
	/* Add fu and fumate to dest shell */
	RT_LIST_APPEND( &dest->fu_hd, &fu->l );
	RT_LIST_APPEND( &fu->l, &fumate->l );
d1585 40
a1624 2
	fu->s_p = dest;
	fumate->s_p = dest;
d1677 1
a1677 1
 *			N M G _ M V _ E U _ B E T W E E N _ S H E L L S
d1679 3
a1681 1
 *  Move a wire edgeuse and it's mate from one shell to another.
d1683 3
a1685 5
void
nmg_mv_eu_between_shells( dest, src, eu )
struct shell		*dest;
register struct shell	*src;
register struct edgeuse	*eu;
d1687 1
a1687 1
	register struct edgeuse	*eumate;
d1689 5
a1693 8
	NMG_CK_EDGEUSE(eu);
	eumate = eu->eumate_p;
	NMG_CK_EDGEUSE(eumate);

	if (eu->up.s_p != src) {
		rt_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eu->up.s_p=x%x isnt src shell\n",
			dest, src, eu, eu->up.s_p );
		rt_bomb("eu->up.s_p isnt source shell\n");
d1695 3
a1697 5
	if (eumate->up.s_p != src) {
		rt_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eumate->up.s_p=x%x isn't src shell\n",
			dest, src, eu, eumate->up.s_p );
		rt_bomb("eumate->up.s_p isnt source shell\n");
	}
d1699 3
a1701 8
	/* Remove eu from src shell */
	RT_LIST_DEQUEUE( &eu->l );
	if( RT_LIST_IS_EMPTY( &src->eu_hd ) )  {
		/* This was the last eu in the list, bad news */
		rt_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eumate=x%x not in src shell\n",
			dest, src, eu, eumate );
		rt_bomb("src shell emptied before finding eumate\n");
	}
d1703 3
a1705 9
	/* Remove eumate from src shell */
	RT_LIST_DEQUEUE( &eumate->l );

	/* Add eu and eumate to dest shell */
	RT_LIST_APPEND( &dest->eu_hd, &eu->l );
	RT_LIST_APPEND( &eu->l, &eumate->l );

	eu->up.s_p = dest;
	eumate->up.s_p = dest;
a1708 158
 *			N M G _ M V _ V U _ B E T W E E N _ S H E L L S
 *
 *  If this shell had a single vertexuse in it, move it to the other
 *  shell, but "promote" it to a vertex-with-self-loop along the way.
 */
void
nmg_mv_vu_between_shells( dest, src, vu )
struct shell		*dest;
register struct shell	*src;
register struct vertexuse	*vu;
{
	struct loopuse *lu;
	NMG_CK_VERTEXUSE( vu );
	NMG_CK_VERTEX( vu->v_p );

	lu = nmg_mlv( &(dest->l.magic), vu->v_p, OT_SAME );
	if (vu->v_p->vg_p) {
		NMG_CK_VERTEX_G(vu->v_p->vg_p);
		nmg_loop_g(lu->l_p);
	}
	nmg_kvu( vu );
}

/*
 *			N M G _ M O V E _ F U _ F U
 *
 *  Move everything from the source faceuse into the destination faceuse.
 *  Exists as a support routine for nmg_jf() only.
 */
static void
nmg_move_fu_fu( dest_fu, src_fu )
register struct faceuse	*dest_fu;
register struct faceuse	*src_fu;
{
	register struct loopuse	*lu;

	NMG_CK_FACEUSE(dest_fu);
	NMG_CK_FACEUSE(src_fu);

	if( dest_fu->orientation != src_fu->orientation )
		rt_bomb("nmg_move_fu_fu: differing orientations\n");

	/* Move all loopuses from src to dest faceuse */
	while( RT_LIST_WHILE( lu, loopuse, &src_fu->lu_hd ) )  {
		RT_LIST_DEQUEUE( &(lu->l) );
		RT_LIST_INSERT( &(dest_fu->lu_hd), &(lu->l) );
		lu->up.fu_p = dest_fu;
	}
	/* The src_fu is invalid here, with an empty lu_hd list */
}

/*
 *			N M G _ J F
 *
 *  Join two faces together by
 *  moving everything from the source faceuse and mate into the
 *  destination faceuse and mate, taking into account face orientations.
 *  The source face is destroyed by this operation.
 */
void
nmg_jf(dest_fu, src_fu)
register struct faceuse	*dest_fu;
register struct faceuse	*src_fu;
{
	NMG_CK_FACEUSE(dest_fu);
	NMG_CK_FACEUSE(src_fu);

	if( src_fu->f_p == dest_fu->f_p )
		rt_bomb("nmg_jf() src and dest faces are the same\n");

	if( dest_fu->orientation == src_fu->orientation )  {
		nmg_move_fu_fu(dest_fu, src_fu);
		nmg_move_fu_fu(dest_fu->fumate_p, src_fu->fumate_p);
	} else {
		nmg_move_fu_fu(dest_fu, src_fu->fumate_p);
		nmg_move_fu_fu(dest_fu->fumate_p, src_fu);
	}
	/* The src_fu is invalid here, having an empty lu_hd list */
	nmg_kfu(src_fu);
}

/*
 *			N M G _ M O V E _ E G
 *
 *  For every edge in shell 's', change all occurances of edge geometry
 *  structure 'old_eg' to be 'new_eg'.
 */
void
nmg_move_eg( old_eg, new_eg, s )
struct edge_g	*old_eg;
struct edge_g	*new_eg;
struct shell	*s;
{
	struct  faceuse		*fu;
	struct face		*f;
	struct loopuse		*lu;
	struct loop		*l;
	register struct edgeuse		*eu;
	register struct edge		*e;

	NMG_CK_EDGE_G(old_eg);
	NMG_CK_EDGE_G(new_eg);
	NMG_CK_SHELL(s);

	/* Faces in shell */
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
		f = fu->f_p;
		NMG_CK_FACE(f);
		/* Loops in face */
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
			NMG_CK_LOOPUSE(lu);
			l = lu->l_p;
			NMG_CK_LOOP(l);
			if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
				/* Loop of Lone vertex */
				continue;
			}
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
				NMG_CK_EDGEUSE(eu);
				e = eu->e_p;
				NMG_CK_EDGE(e);
				if(e->eg_p == old_eg)  {
					nmg_use_edge_g( e, new_eg );
				}
			}
		}
	}
	/* Wire loops in shell */
	for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		l = lu->l_p;
		NMG_CK_LOOP(l);
		if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
			/* Wire loop of Lone vertex */
			continue;
		}
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			NMG_CK_EDGEUSE(eu);
			e = eu->e_p;
			NMG_CK_EDGE(e);
			if(e->eg_p == old_eg)  {
				nmg_use_edge_g( e, new_eg );
			}
		}
	}
	/* Wire edges in shell */
	for( RT_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
		NMG_CK_EDGEUSE(eu);
		e = eu->e_p;
		NMG_CK_EDGE(e);
		if(e->eg_p == old_eg)  {
			nmg_use_edge_g( e, new_eg );
		}
	}
}

/*
d1711 1
a1711 1
 *  Called by nmg_dup_face
d1830 1
a1830 1
 *			N M G _ D U P _ F A C E
d1832 2
a1833 1
 *  Construct a duplicate of a face, 
a1834 41
struct faceuse *
nmg_dup_face(fu, s)
struct faceuse *fu;
struct shell *s;
{
	struct loopuse *new_lu, *lu;
	struct faceuse *new_fu = (struct faceuse *)NULL;
	struct model	*m;
	long		**trans_tbl;

	NMG_CK_FACEUSE(fu);
	NMG_CK_FACE(fu->f_p);
	NMG_CK_SHELL(s);

	m = nmg_find_model( (long *)s );
	trans_tbl = (long **)rt_calloc(m->maxindex, sizeof(long *),
			"nmg_dup_face trans_tbl");

	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		if (new_fu) {
			new_lu = nmg_dup_loop(lu, &new_fu->l.magic, trans_tbl);
		} else {
			new_lu = nmg_dup_loop(lu, &s->l.magic, trans_tbl);
			new_fu = nmg_mf(new_lu);
		}
	}

	if (fu->f_p->fg_p) {
		nmg_face_g(new_fu, fu->f_p->fg_p->N);
	}
	new_fu->orientation = fu->orientation;
	new_fu->fumate_p->orientation = fu->fumate_p->orientation;

	rt_free((char *)trans_tbl, "nmg_dup_face trans_tbl");

	return(new_fu);
}

/*
 *			N M G _ S E T _ L U _ O R I E N T A T I O N
 */
d1889 673
@


10.39
log
@Moved #if 0 code out into nmg_junk.c
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.38 93/03/26 21:19:47 mike Exp Locker: mike $ (BRL)";
d2188 1
a2188 1
 *			N M G _ M E R G E _ 2 F A C E S
d2190 4
a2193 3
 *  Move everything from the source face and mate into the
 *  destination face and mate, taking into account face orientations.
 *  XXX should be called nmg_jf().
d2196 1
a2196 1
nmg_merge_2faces(dest_fu, src_fu)
d2213 1
a2213 1

@


10.38
log
@Incorporated some remarks from today's code review.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.37 93/03/26 21:09:54 mike Exp Locker: mike $ (BRL)";
a1516 97


#if 0
/*XXX	Group sets of loops within a face into overlapping units.
 *	This will allow us to separate dis-associated groups into separate
 *	(but equal ;-) faces
 */

struct groupie {
	struct rt_list	l;
	struct loopuse *lu;
}

struct loopgroup {
	struct rt_list	l;
	struct rt_list	groupies;
} groups;


struct loopgroup *
group(lu, groups)
struct loopuse *lu;
struct rt_list *groups;
{
	struct loopgroup *group;
	struct groupie *groupie;

	for (RT_LIST_FOR(group, loopgroup, groups)) {
		for (RT_LIST_FOR(groupie, groupie, &groupies)) {
			if (groupie->lu == lu)
				return(group);
		}
	}
	return NULL;
}

void
new_loop_group(lu, groups)
struct loopuse *lu;
struct rt_list *groups;
{
	struct loopgroup *lg;
	struct groupie *groupie;

	lg = (struct loopgroup *)rt_calloc(sizeof(struct loopgroup), "loopgroup");
	groupie = (struct groupie *)rt_calloc(sizeof(struct groupie), "groupie");
	groupie->lu = lu;

	RT_LIST_INIT(&lg->groupies);
	RT_LIST_APPEND(&lg->groupies, &groupie->l);
	RT_LIST_APPEND(groups, &lg.l);
}

void
merge_groups(lg1, lg2);
struct loopgroup *lg1, *lg2;
{
	struct groupie *groupie;

	while (RT_LIST_WHILE(groupie, groupie, &lg2->groupies)) {
		RT_LIST_DEQUEUE(&(groupie->l));
		RT_LIST_APPEND(&(lg1->groupies), &(groupie->l))
	}
	RT_DEQUEUE(&(lg2->l));
	rt_free((char *)lg2, "free loopgroup 2 of merge");
}
void
free_groups(head)
struct rt_list *head;
{
	while
}

	RT_LIST_INIT(&groups);

	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {

		/* build loops out of exterior loops only */
		if (lu->orientation == OT_OPPOSITE)
			continue;

		if (group(lu) == NULL)
			new_loop_group(lu, &groups);

		for (RT_LIST_FOR(lu2, loopuse, &fu->lu_hd)) {
			if (lu == lu2 ||
			    group(lu, &groups) == group(lu2, &groups))
				continue;
			if (loops_touch_or_overlap(lu, lu2))
				merge_groups(group(lu), group(lu2));
		}



	}
#endif

a1938 32

#if 0
/*			N M G _ E U _ S Q
 *
 *	squeeze an edgeuse out of a list
 *
 *	All uses of the edge being "Squeezed" must be followed by
 *	the same "next" edge
 *
 */
nmg_eu_sq(eu)
struct edgeuse *eu;
{
	struct edgeuse *matenext;
	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGEUSE(eu->eumate_p);

	/* foreach use of this edge, there must be exactly one use of the
	 * previous edge.  There may not be any "extra" uses of the
	 * previous edge
	 */



	matenext = RT_LIST_PNEXT_CIRC(eu->eumate_p);
	NMG_CK_EDGEUSE(matenext);

	RT_LIST_DEQUEUE(eu);
	RT_LIST_DEQUEUE(matenext);

}
#endif
@


10.37
log
@Moved "information extracting" routines into separate file nmg_info.c
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.36 93/03/25 23:19:40 mike Exp Locker: mike $ (BRL)";
d653 1
a653 1
	 *  Simply only because this edge has no other uses.
d670 3
a672 1
 *	move first pair of shell loopuses to an existing face
d696 1
d1408 2
a2069 25
 *			N M G _ M O V E _ F U _ F U
 *
 *  Move everything from the source faceuse into the destination faceuse.
 */
void
nmg_move_fu_fu( dest_fu, src_fu )
register struct faceuse	*dest_fu;
register struct faceuse	*src_fu;
{
	register struct loopuse	*lu;

	NMG_CK_FACEUSE(dest_fu);
	NMG_CK_FACEUSE(src_fu);

	if( dest_fu->orientation != src_fu->orientation )
		rt_bomb("nmg_move_fu_fu: differing orientations\n");

	/* Move all loopuses from src to dest faceuse */
	while( RT_LIST_WHILE( lu, loopuse, &src_fu->lu_hd ) )  {
		RT_LIST_DEQUEUE( &(lu->l) );
		RT_LIST_INSERT( &(dest_fu->lu_hd), &(lu->l) );
		lu->up.fu_p = dest_fu;
	}
}
/*
d2218 2
d2289 28
d2321 1
d2330 3
@


10.36
log
@Made some more args CONST.
Updated to reflect that nmg_keu() now returns an (int) return code,
which needs to be acted on.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.35 93/03/25 22:41:35 mike Exp Locker: mike $ (BRL)";
a996 284
 *			N M G _ F I N D _ V _ I N _ F A C E
 *
 *	Perform a topological search to
 *	determine if the given vertex is contained in the given faceuse.
 *	If it is, return a pointer to the vertexuse which was found in the
 *	faceuse.
 *
 *  Returns NULL if not found.
 */
struct vertexuse *
nmg_find_v_in_face(v, fu)
CONST struct vertex	*v;
CONST struct faceuse	*fu;
{
	struct vertexuse *vu;
	struct edgeuse *eu;
	struct loopuse *lu;

#define CKLU_FOR_FU(_lu, _fu, _vu) \
	if (*_lu->up.magic_p == NMG_FACEUSE_MAGIC && _lu->up.fu_p == _fu) \
		return(_vu)

	NMG_CK_VERTEX(v);

	for( RT_LIST_FOR( vu, vertexuse, &v->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);
		if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC) {
			eu = vu->up.eu_p;
			if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC) {
				lu = eu->up.lu_p;
				CKLU_FOR_FU(lu, fu, vu);
			}
		} else if (*vu->up.magic_p == NMG_LOOPUSE_MAGIC) {
			lu = vu->up.lu_p;
			CKLU_FOR_FU(lu, fu, vu);
		}
	}
	return((struct vertexuse *)NULL);
}

/*
 *			N M G _ F I N D _ V U _ I N _ F A C E
 *
 *	try to find a vertex(use) in a face wich appoximately matches the
 *	coordinates given.  
 *	
 *	This is a geometric search, not a topological one.
 */
struct vertexuse *
nmg_find_vu_in_face(pt, fu, tol)
CONST point_t		pt;
CONST struct faceuse	*fu;
CONST struct rt_tol	*tol;
{
	register struct loopuse	*lu;
	struct edgeuse		*eu;
	vect_t			delta;
	struct vertex		*v;
	register struct vertex_g *vg;
	int			magic1;

	NMG_CK_FACEUSE(fu);
	RT_CK_TOL(tol);

	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
		if (magic1 == NMG_VERTEXUSE_MAGIC) {
			struct vertexuse	*vu;
			vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
			v = vu->v_p;
			NMG_CK_VERTEX(v);
			if( !(vg = v->vg_p) )  continue;
			NMG_CK_VERTEX_G(vg);
			VSUB2(delta, vg->coord, pt);
			if ( MAGSQ(delta) < tol->dist_sq)
				return(vu);
		}
		else if (magic1 == NMG_EDGEUSE_MAGIC) {
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
				v = eu->vu_p->v_p;
				NMG_CK_VERTEX(v);
				if( !(vg = v->vg_p) )  continue;
				NMG_CK_VERTEX_G(vg);
				VSUB2(delta, vg->coord, pt);
				if ( MAGSQ(delta) < tol->dist_sq)
					return(eu->vu_p);
			}
		} else
			rt_bomb("nmg_find_vu_in_face() Bogus child of loop\n");
	}
	return ((struct vertexuse *)NULL);
}

/*
 *			N M G _ F I N D _ V E R T E X _ I N _ E D G E L I S T
 *
 *  Returns -
 *	1	If found
 *	0	If not found
 */
int
nmg_find_vertex_in_edgelist( v, hd )
register CONST struct vertex	*v;
CONST struct rt_list		*hd;
{
	register CONST struct edgeuse	*eu;

	NMG_CK_VERTEX(v);
	for( RT_LIST_FOR( eu, edgeuse, hd ) )  {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_VERTEXUSE(eu->vu_p);
		NMG_CK_VERTEX(eu->vu_p->v_p);
		if( eu->vu_p->v_p == v )  return(1);
	}
	return(0);
}

/*
 *			N M G _ F I N D _ V E R T E X _ I N _ L O O P L I S T
 *
 *  Returns -
 *	1	If found
 *	0	If not found
 */
int
nmg_find_vertex_in_looplist( v, hd, singletons )
register CONST struct vertex	*v;
CONST struct rt_list		*hd;
int				singletons;
{
	register CONST struct loopuse	*lu;
	long			magic1;

	NMG_CK_VERTEX(v);
	for( RT_LIST_FOR( lu, loopuse, hd ) )  {
		NMG_CK_LOOPUSE(lu);
		magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
		if( magic1 == NMG_VERTEXUSE_MAGIC )  {
			register CONST struct vertexuse	*vu;
			if( !singletons )  continue;
			vu = RT_LIST_FIRST(vertexuse, &lu->down_hd );
			NMG_CK_VERTEXUSE(vu);
			NMG_CK_VERTEX(vu->v_p);
			if( vu->v_p == v )  return(1);
		} else if( magic1 == NMG_EDGEUSE_MAGIC )  {
			if( nmg_find_vertex_in_edgelist( v, &lu->down_hd ) )
				return(1);
		} else {
			rt_bomb("nmg_find_vertex_in_loopuse() bad magic\n");
		}
	}
	return(0);
}

/*
 *			N M G _ F I N D _ V E R T E X _ I N _ F A C E L I S T
 *
 *  Returns -
 *	1	If found
 *	0	If not found
 */
int
nmg_find_vertex_in_facelist( v, hd )
register CONST struct vertex	*v;
CONST struct rt_list		*hd;
{
	register CONST struct faceuse	*fu;

	NMG_CK_VERTEX(v);
	for( RT_LIST_FOR( fu, faceuse, hd ) )  {
		NMG_CK_FACEUSE(fu);
		if( nmg_find_vertex_in_looplist( v, &fu->lu_hd, 1 ) )
			return(1);
	}
	return(0);
}

/*
 *			N M G _ F I N D _ E D G E _ I N _ E D G E L I S T
 *
 *  Returns -
 *	1	If found
 *	0	If not found
 */
int
nmg_find_edge_in_edgelist( e, hd )
CONST struct edge	*e;
CONST struct rt_list	*hd;
{
	register CONST struct edgeuse	*eu;

	NMG_CK_EDGE(e);
	for( RT_LIST_FOR( eu, edgeuse, hd ) )  {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGE(eu->e_p);
		if( e == eu->e_p )  return(1);
	}
	return(0);
}

/*
 *			N M G _ F I N D _ E D G E _ I N _ L O O P L I S T
 *
 *  Returns -
 *	1	If found
 *	0	If not found
 */
int
nmg_find_edge_in_looplist( e, hd )
CONST struct edge	*e;
CONST struct rt_list	*hd;
{
	register CONST struct loopuse	*lu;
	long			magic1;

	NMG_CK_EDGE(e);
	for( RT_LIST_FOR( lu, loopuse, hd ) )  {
		NMG_CK_LOOPUSE(lu);
		magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
		if( magic1 == NMG_VERTEXUSE_MAGIC )  {
			/* Loop of a single vertex does not have an edge */
			continue;
		} else if( magic1 == NMG_EDGEUSE_MAGIC )  {
			if( nmg_find_edge_in_edgelist( e, &lu->down_hd ) )
				return(1);
		} else {
			rt_bomb("nmg_find_edge_in_loopuse() bad magic\n");
		}
	}
	return(0);
}

/*
 *			N M G _ F I N D _ E D G E _ I N _ F A C E L I S T
 *
 *  Returns -
 *	1	If found
 *	0	If not found
 */
int
nmg_find_edge_in_facelist( e, hd )
CONST struct edge	*e;
CONST struct rt_list	*hd;
{
	register CONST struct faceuse	*fu;

	NMG_CK_EDGE(e);
	for( RT_LIST_FOR( fu, faceuse, hd ) )  {
		NMG_CK_FACEUSE(fu);
		if( nmg_find_edge_in_looplist( e, &fu->lu_hd ) )
			return(1);
	}
	return(0);
}

/*
 *			N M G _ F I N D _ L O O P _ I N _ F A C E L I S T
 *
 *  Returns -
 *	1	If found
 *	0	If not found
 */
int
nmg_find_loop_in_facelist( l, fu_hd )
CONST struct loop	*l;
CONST struct rt_list	*fu_hd;
{
	register CONST struct faceuse	*fu;
	register CONST struct loopuse	*lu;

	NMG_CK_LOOP(l);
	for( RT_LIST_FOR( fu, faceuse, fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
			NMG_CK_LOOPUSE(lu);
			NMG_CK_LOOP(lu->l_p);
			if( l == lu->l_p )  return(1);
		}
	}
	return(0);
}

/*
a1061 134
 *			N M G _ F I N D E U
 *
 *  Find an edgeuse in a shell between a given pair of vertex structs.
 *
 *  If a given shell "s" is specified, then only edgeuses in that shell
 *  will be considered, otherwise all edgeuses in the model are fair game.
 *
 *  If a particular edgeuse "eup" is specified, then that edgeuse
 *  and it's mate will not be returned as a match.
 *
 *  If "dangling_only" is true, then an edgeuse will be matched only if
 *  there are no other edgeuses on the edge, i.e. the radial edgeuse is
 *  the same as the mate edgeuse.
 *
 *  Returns -
 *	edgeuse*	Edgeuse which matches the criteria
 *	NULL		Unable to find matching edgeuse
 */
struct edgeuse *
nmg_findeu(v1, v2, s, eup, dangling_only)
struct vertex	*v1, *v2;
struct shell	*s;
struct edgeuse	*eup;
int		dangling_only;
{
	register struct vertexuse	*vu;
	register struct edgeuse		*eu;
	struct edgeuse			*eup_mate;
	int				eup_orientation;

	NMG_CK_VERTEX(v1);
	NMG_CK_VERTEX(v2);
	if(s) NMG_CK_SHELL(s);

	if(eup)  {
		NMG_CK_EDGEUSE(eup);
		eup_mate = eup->eumate_p;
		NMG_CK_EDGEUSE(eup_mate);
		if (*eup->up.magic_p != NMG_LOOPUSE_MAGIC ||
		    *eup->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC )
			rt_bomb("nmg_findeu(): eup not part of a face\n");
		eup_orientation = eup->up.lu_p->up.fu_p->orientation;
	} else {
		eup_mate = eup;			/* NULL */
		eup_orientation = OT_SAME;
	}

	if (rt_g.NMG_debug & DEBUG_FINDEU)
		rt_log("nmg_findeu() seeking eu!=%8x/%8x between (%8x, %8x) %s\n",
			eup, eup_mate, v1, v2,
			dangling_only ? "[dangling]" : "[any]" );

	for( RT_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);
		if (!vu->up.magic_p)
			rt_bomb("nmg_findeu() vertexuse in vu_hd list has null parent\n");

		/* Ignore self-loops and lone shell verts */
		if (*vu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
		eu = vu->up.eu_p;

		/* Ignore edgeuses which don't run between the right verts */
		if( eu->eumate_p->vu_p->v_p != v2 )  continue;

		if (rt_g.NMG_debug & DEBUG_FINDEU )  {
			rt_log("nmg_findeu: check eu=%8x vertex=(%8x, %8x)\n",
				eu, eu->vu_p->v_p,
				eu->eumate_p->vu_p->v_p);
		}

		/* Ignore the edgeuse to be excluded */
		if( eu == eup || eu->eumate_p == eup )  {
			if (rt_g.NMG_debug & DEBUG_FINDEU )
				rt_log("\tIgnoring -- excluded edgeuse\n");
			continue;
		}

		/* See if this edgeuse is in the proper shell */
		if( s )  {
			struct loopuse	*lu;
			if( *eu->up.magic_p == NMG_SHELL_MAGIC &&
			    eu->up.s_p != s )  {
			    	if (rt_g.NMG_debug & DEBUG_FINDEU)
			    		rt_log("\tIgnoring -- wire eu in wrong shell s=%x\n", eu->up.s_p);
				continue;
			}
			if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )
				rt_bomb("nmg_findeu() eu has bad up\n");
			lu = eu->up.lu_p;
			NMG_CK_LOOPUSE(lu);
			if( *lu->up.magic_p == NMG_SHELL_MAGIC &&
			    lu->up.s_p != s )  {
			    	if (rt_g.NMG_debug & DEBUG_FINDEU)
			    		rt_log("\tIgnoring -- eu of wire loop in wrong shell s=%x\n", lu->up.s_p);
				continue;
			}
			if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )
				rt_bomb("nmg_findeu() lu->up is bad\n");
			/* Edgeuse in loop in face, normal case */
			if( lu->up.fu_p->s_p != s )  {
			    	if (rt_g.NMG_debug & DEBUG_FINDEU)
		    		rt_log("\tIgnoring -- eu of lu+fu in wrong shell s=%x\n", lu->up.fu_p->s_p);
				continue;
			}
		}

		/* If it's not a dangling edge, skip on */
		if( dangling_only && eu->eumate_p != eu->radial_p) {
		    	if (rt_g.NMG_debug & DEBUG_FINDEU)  {
			    	rt_log("\tIgnoring %8x/%8x (radial=x%x)\n",
			    		eu, eu->eumate_p,
					eu->radial_p );
		    	}
			continue;
		}

	    	if (rt_g.NMG_debug & DEBUG_FINDEU)
		    	rt_log("\tFound %8x/%8x\n", eu, eu->eumate_p);

		if ( *eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
		     *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
		     eup_orientation != eu->up.lu_p->up.fu_p->orientation)
			eu = eu->eumate_p;	/* Take other orient */
		goto out;
	}
	eu = (struct edgeuse *)NULL;
out:
	if (rt_g.NMG_debug & DEBUG_FINDEU)
	    	rt_log("nmg_findeu() returns x%x\n", eu);

	return eu;
}

/*
a2331 25
 *			N M G _ E U _ W I T H _ V U _ I N _ L U
 *
 *  Find an edgeuse starting at a given vertexuse within a loop(use).
 */
struct edgeuse *
nmg_eu_with_vu_in_lu( lu, vu )
struct loopuse		*lu;
struct vertexuse	*vu;
{
	register struct edgeuse	*eu;

	NMG_CK_LOOPUSE(lu);
	NMG_CK_VERTEXUSE(vu);
	if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
		rt_bomb("nmg_eu_with_vu_in_lu: loop has no edges!\n");
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		NMG_CK_EDGEUSE(eu);
		if( eu->vu_p == vu )  return eu;
	}
	rt_bomb("nmg_eu_with_vu_in_lu:  Unable to find vu!\n");
	/* NOTREACHED */
	return((struct edgeuse *)NULL);
}

/*
a2568 148
}

/*
 *			N M G _ L O O P _ I S _ A _ C R A C K
 *
 *  Returns -
 *	 0	Loop is not a "crack"
 *	!0	Loop *is* a "crack"
 */
int
nmg_loop_is_a_crack( lu )
CONST struct loopuse	*lu;
{
	struct edgeuse	*cur_eu;
	struct edgeuse	*cur_eumate;
	struct vertexuse *cur_vu;
	struct vertex	*cur_v;
	struct vertexuse *next_vu;
	struct vertex	*next_v;
	struct faceuse	*fu;
	struct vertexuse *test_vu;
	struct edgeuse	*test_eu;
	struct loopuse	*test_lu;

	NMG_CK_LOOPUSE(lu);
	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )  return 0;
	fu = lu->up.fu_p;
	NMG_CK_FACEUSE(fu);

	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )  return 0;

	for( RT_LIST_FOR( cur_eu, edgeuse, &lu->down_hd ) )  {
		NMG_CK_EDGEUSE(cur_eu);
		cur_eumate = cur_eu->eumate_p;
		NMG_CK_EDGEUSE(cur_eumate);
		cur_vu = cur_eu->vu_p;
		NMG_CK_VERTEXUSE(cur_vu);
		cur_v = cur_vu->v_p;
		NMG_CK_VERTEX(cur_v);

		next_vu = cur_eumate->vu_p;
		NMG_CK_VERTEXUSE(next_vu);
		next_v = next_vu->v_p;
		NMG_CK_VERTEX(next_v);
		/* XXX It might be more efficient to walk the radial list */
		/* See if the next vertex has an edge pointing back to cur_v */
		for( RT_LIST_FOR( test_vu, vertexuse, &next_v->vu_hd ) )  {
			if( *test_vu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
			test_eu = test_vu->up.eu_p;
			NMG_CK_EDGEUSE(test_eu);
			if( test_eu == cur_eu )  continue;	/* skip self */
			if( test_eu == cur_eumate )  continue;	/* skip mates */
			if( *test_eu->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
			test_lu = test_eu->up.lu_p;
			if( test_lu != lu )  continue;
			/* Check departing edgeuse's NEXT vertex */
			if( test_eu->eumate_p->vu_p->v_p == cur_v )  goto match;
		}
		/* No path back, this can't be a crack, abort */
		return 0;
		
		/* One edgeuse matched, all the others have to as well */
match:		;
	}
	return 1;
}

/*
 *			N M G _ L O O P _ I S _ C C W
 *
 *  Returns -
 *	+1	Loop is CCW, should be exterior loop.
 *	-1	Loop is CW, should be interior loop.
 *	 0	Unable to tell, error.
 */
int
nmg_loop_is_ccw( lu, norm, tol )
CONST struct loopuse	*lu;
CONST plane_t		norm;
CONST struct rt_tol	*tol;
{
	vect_t		edge1, edge2;
	vect_t		left;
	struct edgeuse	*eu;
	struct edgeuse	*next_eu;
	struct vertexuse *this_vu, *next_vu, *third_vu;
	fastf_t		theta = 0;
	fastf_t		x,y;
	fastf_t		rad;

	NMG_CK_LOOPUSE(lu);
	RT_CK_TOL(tol);
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )  return 0;

	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		next_eu = RT_LIST_PNEXT_CIRC( edgeuse, eu );
		this_vu = eu->vu_p;
		next_vu = eu->eumate_p->vu_p;
		third_vu = next_eu->eumate_p->vu_p;

		/* Skip topological 0-length edges */
		if( this_vu->v_p == next_vu->v_p )  continue;
		if( next_vu->v_p == third_vu->v_p )  continue;

		/* Skip edges with calculated edge lengths near 0 */
		VSUB2( edge1, next_vu->v_p->vg_p->coord, this_vu->v_p->vg_p->coord );
		if( MAGSQ(edge1) < tol->dist_sq )  continue;
		VSUB2( edge2, third_vu->v_p->vg_p->coord, next_vu->v_p->vg_p->coord );
		if( MAGSQ(edge2) < tol->dist_sq )  continue;
		VUNITIZE(edge1);
		VUNITIZE(edge2);

		/* Compute (loop)inward pointing "left" vector */
		VCROSS( left, norm, edge1 );
		y = VDOT( edge2, left );
		x = VDOT( edge2, edge1 );
		rad = atan2( y, x );
#if 0
		VPRINT("vu1", this_vu->v_p->vg_p->coord);
		VPRINT("vu2", next_vu->v_p->vg_p->coord);
		VPRINT("edge1", edge1);
		VPRINT("edge2", edge2);
		VPRINT("left", left);
		rt_log("atan2(%g,%g) = %g\n", y, x, rad);
#endif
		theta += rad;
	}
#if 0
	rt_log(" theta = %g (%g)\n", theta, theta / rt_twopi );
	nmg_face_lu_plot( lu, this_vu, this_vu );
	nmg_face_lu_plot( lu->lumate_p, this_vu, this_vu );
#endif

	rad = theta * rt_inv2pi;
	x = rad-1;
	/* Value is in radians, tolerance here is 1% */
	if( NEAR_ZERO( x, 0.05 ) )  {
		/* theta = two pi, loop is CCW */
		return 1;
	}
	x = rad + 1;
	if( NEAR_ZERO( x, 0.05 ) )  {
		/* theta = -two pi, loop is CW */
		return -1;
	}
	rt_log("nmg_loop_is_ccw(x%x):  unable to determine CW/CCW, theta=%g (%g)\n",
		theta, rad );
	return 0;
@


10.35
log
@Moved these routines from nmg_eval.c to nmg_mod.c:
nmg_reverse_face
nmg_mv_fu_between_shells
nmg_mv_lu_between_shells
nmg_mv_eu_between_shells
nmg_mv_vu_between_shells
nmg_find_vertex_in_edgelist
nmg_find_vertex_in_looplist
nmg_find_vertex_in_facelist
nmg_find_edge_in_edgelist
nmg_find_edge_in_looplist
nmg_find_edge_in_facelist
nmg_find_loop_in_facelist
nmg_rm_redundancies
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.34 93/03/25 22:34:10 mike Exp Locker: mike $ (BRL)";
d1093 4
d1100 2
a1101 2
register struct vertex	*v;
struct rt_list		*hd;
d1103 1
a1103 1
	register struct edgeuse	*eu;
d1115 7
d1124 3
a1126 3
register struct vertex	*v;
struct rt_list		*hd;
int			singletons;
d1128 1
a1128 1
	register struct loopuse	*lu;
d1136 1
a1136 1
			register struct vertexuse	*vu;
d1152 7
d1161 2
a1162 2
register struct vertex	*v;
struct rt_list		*hd;
d1164 1
a1164 1
	register struct faceuse	*fu;
d1175 7
d1184 2
a1185 2
struct edge	*e;
struct rt_list	*hd;
d1187 1
a1187 1
	register struct edgeuse	*eu;
d1198 7
d1207 2
a1208 2
struct edge	*e;
struct rt_list	*hd;
d1210 1
a1210 1
	register struct loopuse	*lu;
d1230 7
d1239 2
a1240 2
struct edge	*e;
struct rt_list	*hd;
d1242 1
a1242 1
	register struct faceuse	*fu;
d1253 7
d1262 2
a1263 2
struct loop	*l;
struct rt_list	*fu_hd;
d1265 2
a1266 2
	register struct faceuse	*fu;
	register struct loopuse	*lu;
d1550 1
a1550 1
	nmg_keu(eu);
d1870 2
a1871 2
				nmg_keu(eu_r);
				nmg_keu(eu);
d2096 1
a2096 1
				nmg_keu(eu);
d2113 1
a2113 1
			nmg_keu(eu);
@


10.34
log
@Modified kill_snakes() to indicate if the loopuse needs to be killed,
and simplify_face() to indicate if the faceuse needs to be killed.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.33 93/03/25 18:05:20 mm Exp Locker: mike $ (BRL)";
d1092 143
d2000 104
d2460 216
@


10.33
log
@tightened up loop checks in plane_eqn()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.32 1993/03/25 02:58:04 mike Exp mm $ (BRL)";
d1634 3
d1638 1
a1638 1
void
d1683 2
d1702 1
d1711 4
d1716 1
a1716 1
void
d1725 1
a1725 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))
d1727 1
d1729 5
a1733 29
	
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))
		nmg_kill_snakes(lu);

#if 0
	/* An exterior loop in face that:
	 *	1) has an extent which does not overlap the extent of another
	 *		loop in this face.
	 *	2) does not share a vertex with another loop of this face.
	 *
	 * defines the boundary of a separated "face patch" and should 
	 * become a separate face.
	 */

	/* a face of one loop cannot be subdivided */
	if (RT_LIST_NEXT(loopuse, &fu->lu_hd) ==
	    RT_LIST_LAST(loopuse, &fu->lu_hd))
	    	return;


	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		overlap = 0;
		for (RT_LIST_FOR(lu2, loopuse, &fu->lu_hd)) {
			if (lu == lu2) continue;
			if (V3RPP_OVERLAP(
			    lu->lg_p->min_pt, lu->lg_p->max_pt,
			    lu2->lg_p->min_pt, lu2->lg_p->max_pt) ) {
				overlap
			}
a1734 2


a1735 1
#endif
d1737 2
a1738 1

d1849 5
a1853 1
		nmg_simplify_face(fu);
@


10.32
log
@Changed nmg_cut_loop() to call nmg_split_lu_at_vu() when the
two vertexuses refer to the same vertex, e.g. loop touches itself.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.31 93/03/24 22:36:04 mm Exp Locker: mike $ (BRL)";
d104 3
a106 2
	} while( b == a
		|| VAPPROXEQUAL(a->vg_p->coord, b->vg_p->coord, tol->dist) );
d115 1
a115 1
	} while( c == b
d119 2
a120 1
			c->vg_p->coord, tol->dist));
@


10.31
log
@fixed call to rt_3pts_collinear
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.30 1993/03/24 22:24:08 mm Exp mm $ (BRL)";
d1911 6
d2048 2
a2049 6
	/*
	 *  The vertexuse will appear exactly once in the loop, so
	 *  find the edgeuse which has the indicated vertexuse.
	 */
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return (struct loopuse *)0;	/* FAIL */
d2051 3
a2053 4
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		if( vu == split_vu )  goto begin;
a2054 2
	/* Could not find indicated vertex */
	return (struct loopuse *)0;		/* FAIL */
@


10.30
log
@modified nmg_fu_planeeqn to avoid collinearity of points
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.29 1993/03/24 03:22:30 mike Exp mm $ (BRL)";
d117 2
a118 2
		|| collinear(a->vg_p->coord, b->vg_p->coord, c->vg_p->coord,
			tol->dist));
@


10.29
log
@Absorbed nmg_find_v_in_face().
Made some arguments CONST.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.28 93/03/24 02:41:45 mike Exp Locker: mike $ (BRL)";
d104 2
a105 1
	} while( b == a );
d114 5
a118 1
	} while( c == b );
@


10.28
log
@Moved these routines from nmg_fcut.c to nmg_mod.c:
        nmg_join_singvu_loop
        nmg_join_2singvu_loops
        nmg_loop_is_a_crack
        nmg_loop_is_ccw
        nmg_set_lu_orientation
        nmg_lu_reorient
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.27 93/03/24 01:12:33 mike Exp Locker: mike $ (BRL)";
d990 41
d1036 1
d1041 1
a1041 1
struct faceuse		*fu;
d2492 1
a2492 1
			new_lu = nmg_dup_loop(lu, new_fu, trans_tbl);
d2494 1
a2494 1
			new_lu = nmg_dup_loop(lu, s, trans_tbl);
d2519 1
a2519 1
struct loopuse	*lu;
d2585 2
a2586 2
struct loopuse	*lu;
CONST plane_t	norm;
d2626 6
a2631 6
VPRINT("vu1", this_vu->v_p->vg_p->coord);
VPRINT("vu2", next_vu->v_p->vg_p->coord);
VPRINT("edge1", edge1);
VPRINT("edge2", edge2);
VPRINT("left", left);
rt_log("atan2(%g,%g) = %g\n", y, x, rad);
d2637 2
a2639 2
nmg_face_lu_plot( lu, this_vu, this_vu );
nmg_face_lu_plot( lu->lumate_p, this_vu, this_vu );
@


10.27
log
@Greatly expanded the usefulness of nmg_findeu().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.26 93/03/23 22:22:20 mike Exp Locker: mike $ (BRL)";
d1421 98
d2466 207
@


10.26
log
@Improved comment
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.25 93/03/22 23:08:26 mike Exp Locker: mike $ (BRL)";
d401 1
d413 1
a413 1
			eur = nmg_findeu(*verts[i+1], *verts[i], s, euold);
d437 1
a437 1
	if (eur = nmg_findeu(*verts[n-1], *verts[0], s, euold))  {
d765 1
a765 1
	if( vA == vB )
d767 3
a769 1
	if( v && ( v == vA || v == vB ) )
d771 2
a1110 1
 *  If "eup" is non-NULL, that specific edgeuse & it's mate will be ignored.
d1112 10
d1127 5
a1131 4
nmg_findeu(v1, v2, s, eup)
struct vertex *v1, *v2;
struct shell *s;
struct edgeuse *eup;
d1140 1
a1140 1
	NMG_CK_SHELL(s);
d1156 3
a1158 2
		rt_log("nmg_findeu() seeking eu!=%8x/%8x between (%8x, %8x)\n",
			eup, eup_mate, v1, v2 );
d1186 26
a1211 6
		if (*eu->up.magic_p != NMG_LOOPUSE_MAGIC ||
		    *eu->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC ||
		    eu->up.lu_p->up.fu_p->s_p != s) {
		    	if (rt_g.NMG_debug & DEBUG_FINDEU)
		    		rt_log("\tIgnoring -- wrong parent\n");
			continue;
d1215 1
a1215 1
		if( eu->eumate_p != eu->radial_p) {
d1227 3
a1229 1
	    	if ( eup_orientation != eu->up.lu_p->up.fu_p->orientation)
@


10.25
log
@Improved code in nmg_findeu() to explain it's decisions better
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.24 93/03/22 15:48:56 mike Exp Locker: mike $ (BRL)";
d1354 2
a1355 1
	 *  Gobble edges off of loop2, and insert them into loop1,
@


10.24
log
@Additional comments resulting from Friday's code review.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.23 93/03/16 20:42:46 mm Exp Locker: mike $ (BRL)";
d1105 6
a1110 1
 *	find an edgeuse in a shell between a pair of verticies
d1120 2
d1127 13
d1141 2
a1142 2
		rt_log("nmg_findeu() looking for edge between %8x and %8x other than %8x/%8x\n",
		v1, v2, eup, eup->eumate_p);
d1146 2
a1147 5
		if (!vu->up.magic_p) {
			rt_log("nmg_findeu() in %s at %d vertexuse has null parent\n",
				__FILE__, __LINE__);
			rt_bomb("nmg_findeu\n");
		}
d1149 1
d1151 1
d1153 3
d1157 3
a1159 3
			rt_log("checking edgeuse %8x vertex pair (%8x, %8x)\n",
				vu->up.eu_p, vu->up.eu_p->vu_p->v_p,
				vu->up.eu_p->eumate_p->vu_p->v_p);
d1162 6
a1167 8
		/* look for an edgeuse pair (other than the one we have)
		 * on the vertices we want
		 * the edgeuse pair should be a dangling edge
		 */
		eu = vu->up.eu_p;
		if( eu != eup && eu->eumate_p != eup &&
		    eu->eumate_p->vu_p->v_p == v2  &&
		    eu->eumate_p == eu->radial_p) {
d1169 8
a1176 7
		    	/* if the edgeuse we have found is a part of a face
		    	 * in the proper shell, we've found what we're looking
		    	 * for.
		    	 */
			if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
			    *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
			    eu->up.lu_p->up.fu_p->s_p == s) {
d1178 9
a1186 3
			    	if (rt_g.NMG_debug & DEBUG_FINDEU)
				    	rt_log("Found %8x/%8x\n",
				    		eu, eu->eumate_p);
d1188 2
a1189 9
			    	if (eup->up.lu_p->up.fu_p->orientation ==
			    	    eu->up.lu_p->up.fu_p->orientation)
				    	return(eu);
			    	else
			    		return(eu->eumate_p);
			    }
		    	else
		    		if (rt_g.NMG_debug & DEBUG_FINDEU)
		    		rt_log("ignoring an edge because it has wrong parent\n");
d1191 3
a1193 1
		}
d1195 2
a1196 1

d1198 1
a1198 1
	    	rt_log("nmg_findeu search failed\n");
d1200 1
a1200 1
	return((struct edgeuse *)NULL);
@


10.23
log
@added nmg_add_loop_to_face
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.22 1993/03/13 01:48:46 mike Exp mm $ (BRL)";
d213 1
a213 1
 *	N M G _ A D D _ L O O P _ T O _ F A C E
a238 1

d277 6
a282 2
		lu = nmg_mlv(&s->l.magic, (struct vertex *)NULL, dir);
		fu = nmg_mf(lu);
d296 1
a296 1
 *	given a list of pointers to vertices.
d582 1
a582 4
	nmg_ck_list( &s->eu_hd, "eusplit A" );
	nmg_ck_list( &s->lu_hd, "eusplit lu A" );

	/* make a new edge on the vertex */
d588 1
a588 3
		/* An edge between two new vertices */
		nmg_ck_list( &s->eu_hd, "eusplit B" );
		nmg_ck_list( &s->lu_hd, "eusplit lu B" );
d600 7
a606 7
	 *	      eu1			       oldeu
	 *	  .------------->		  .------------->
	 *	 /				 /
	 *	V ~~~~~~~~~~~~~~~ V (new edge)	A =============== B (edge)
	 *			 /				 /
	 *	  <-------------.		  <-------------.
	 *	      eu2			      oldeumate
d644 3
a646 1
	/* Build radial relationship */
d738 1
a738 1
struct vertex	*v;
d742 2
a743 2
	struct edgeuse	*eur,	/* radial edgeuse of eu */
			*eu2,	/* new edgeuse (next of eur) */
d746 1
a746 1
	struct vertex	*v1, *v2;	/* start and end of eu */
d755 2
a756 2
	v1 = eu->vu_p->v_p;
	NMG_CK_VERTEX(v1);
d760 2
a761 2
	v2 = eu->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX(v2);
d763 4
a766 4
	/* v1 and v2 are the endpoints of the original edge "e" */
	if( v1 == v2 )
		rt_log("WARNING: nmg_esplit() on edge from&to v=x%x\n", v1);
	if( v && ( v == v1 || v == v2 ) )
d774 9
a782 8
		eur = eu->radial_p;
		/* eur could runs from v1 to v2 */
		eu2 = nmg_eusplit(v, eur);
		/* Now, eur runs from v1 to v, eu2 runs from v to v2 */
		NMG_CK_EDGEUSE(eur);
		NMG_CK_EDGEUSE(eu2);
		NMG_TEST_EDGEUSE(eur);
		NMG_TEST_EDGEUSE(eu2);
d785 5
a789 2
			/* "v" is the vertex "e" was just split at */
			v = eu2->vu_p->v_p;
d793 1
a793 1
		if (eu2->e_p == e || eur->e_p == e) notdone = 0;
d795 7
a801 2
		NMG_CK_VERTEX(eur->vu_p->v_p);
		if (eur->vu_p->v_p == v1) {
d803 2
a804 2
				nmg_moveeu(neu1, eur);
				nmg_moveeu(neu2, eu2);
d806 3
a808 3
			neu1 = eur->eumate_p;
			neu2 = eu2->eumate_p;
		} else if (eur->vu_p->v_p == v2) {
d810 2
a811 2
				nmg_moveeu(neu2, eur);
				nmg_moveeu(neu1, eu2);
d813 2
a814 2
			neu2 = eur->eumate_p;
			neu1 = eu2->eumate_p;
d817 2
a818 2
			rt_log("nmg_esplit: eur->vu_p->v_p=x%x, v1=x%x, v2=x%x\n", eur->vu_p->v_p, v1, v2 );
			rt_bomb("nmg_esplit() eur->vu_p->v_p is neither v1 nor v2\n");
d823 2
a824 20
	/* Error checking loops */
	eu = neu1;
	do {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGEUSE(eu->eumate_p);
		NMG_TEST_EDGEUSE(eu);
		NMG_TEST_EDGEUSE(eu->eumate_p);
		eu = eu->radial_p->eumate_p;
	} while (eu != neu1);
	eu = neu2;
	do {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGEUSE(eu->eumate_p);
		NMG_TEST_EDGEUSE(eu);
		NMG_TEST_EDGEUSE(eu->eumate_p);
		eu = eu->radial_p->eumate_p;
	} while (eu != neu2);

	/* Find an edgeuse that runs from v to v2 */
	if( neu2->vu_p->v_p == v && neu2->eumate_p->vu_p->v_p == v2 )
d1702 1
a1702 3
		rt_log("nmg_cut_loop() at %d in %s vertices should be decendants of same loop\n",
			__LINE__, __FILE__);
		rt_bomb("nmg_cut_loop\n");
a1728 2
	nmg_ck_lueu(oldlu, "oldlu (fresh)");

d1738 1
a1750 1
	nmg_ck_lueu(lu, "lu check1");	/*LABLABLAB*/
d1752 1
a1752 1
	/* make an edge to "cap off" the new loop */
a1764 3
	nmg_ck_lueu(lu, "lu check2");	/*LABLABLAB*/


d1775 1
a1775 2

	/* make sure new edgeuses are radial to each other */
d1800 1
@


10.22
log
@Added more debugging
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.21 93/03/12 21:01:37 mike Exp Locker: mike $ (BRL)";
d202 77
@


10.21
log
@Incorporated clarifications from the code review today.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.20 93/03/08 22:50:28 mike Exp Locker: mike $ (BRL)";
d796 6
a801 1
	if( eu->e_p->eg_p )  rt_bomb("nmg_ebreak() eu grew geometry?\n");
d1145 4
a1148 1
	if (eu_r->up.lu_p->orientation != lu->orientation)
d1150 1
@


10.20
log
@Fixed bad bug in nmg_join_2loops()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.19 93/03/03 01:51:09 mike Exp Locker: mike $ (BRL)";
d180 5
d215 1
a215 1
 *	Create a loop within a face for a 3-manifold shell,
d217 3
d223 3
a225 2
 *	The face will consist of a single loop
 *	made from edges between the n vertices.  Before an edge is created
d227 5
a231 4
 *	edge with a single use-pair (in this shell) between the two verticies.
 *	If such an edge can be found, the newly created edge will "use-share"
 *	the existing edge.  This greatly facilitates the construction of
 *	shells from a series of points/faces.
d252 1
a252 4
 *	The vertices should be listed in
 *	"counter-clockwise" (CCW) order if this is an ordinary face (loop),
 *	and in "clockwise" (CW) order if this is an interior
 * 	("hole" or "subtracted") face (loop).
d260 3
a320 2
		lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
		NMG_CK_LOOPUSE(lu);
d325 1
a325 1
			rt_log("euold: %8x\n", euold);
d338 1
a338 1
					rt_log("found another edgeuse (%8x) between %8x and %8x\n",
d342 1
a342 1
				    rt_log("didn't find edge from verts[%d]%8x to verts[%d]%8x\n",
d350 1
a350 1
				rt_log("*verts[%d] was null, is now %8x\n",
d360 1
a360 1
		rt_log("didn't find edge from verts[%d]%8x to verts[%d]%8x\n",
@


10.19
log
@Changed to V3RPP_OVERLAP, DIST_PT_PLANE
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.18 93/03/02 22:15:08 mike Exp Locker: mike $ (BRL)";
d1227 1
a1227 1
		/* insert 0 length edge */
d1231 1
a1231 1
		first_new_eu = RT_LIST_PLAST_CIRC(edgeuse, second_new_eu);
d1234 2
d1237 2
a1238 1
		second_new_eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
d1241 1
d1243 1
d1251 1
a1251 1
	final_eu2 = RT_LIST_PLAST_CIRC(edgeuse, eu2 );
d1268 3
@


10.18
log
@Moved GET_xxx and FREE_xxx macros from nmg.h to nmg_mk.c,
because that is the only module authorized to create and destroy
the fundamental structures.
As a consequence, moved nmg_unglueedge(), nmg_moveeu(),
and nmg_jv() from nmg_mod.c to nmg_mk.c
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.17 93/03/02 21:23:30 mike Exp Locker: mike $ (BRL)";
d1440 1
a1440 1
			if (NMG_EXTENT_OVERLAP(
@


10.17
log
@Streamlined nmg_moveeu()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.16 93/02/24 01:18:47 mike Exp Locker: mike $ (BRL)";
a571 165
}

/*
 *			N M G _ M O V E E U
 *
 *	Move a pair of edgeuses onto a new edge (glue edgeuse).
 *	the edgeuse eusrc and its mate are moved to the edge
 *	used by eudst.  eusrc is made to be immediately radial to eudst.
 *	if eusrc does not share the same vertices as eudst, we bomb.
 */
void
nmg_moveeu(eudst, eusrc)
struct edgeuse *eudst, *eusrc;
{
	struct edgeuse	*eudst_mate;
	struct edgeuse	*eusrc_mate;
	struct edge	*e;

	NMG_CK_EDGEUSE(eudst);
	NMG_CK_EDGEUSE(eusrc);
	eudst_mate = eudst->eumate_p;
	eusrc_mate = eusrc->eumate_p;
	NMG_CK_EDGEUSE(eudst_mate);
	NMG_CK_EDGEUSE(eusrc_mate);

	/* protect the morons from themselves.  Don't let them
	 * move an edgeuse to itself or it's mate
	 */
	if (eusrc == eudst || eusrc_mate == eudst)  {
		rt_log("nmg_moveeu() moving edgeuse to itself\n");
		return;
	}

	if (eusrc->e_p == eudst->e_p &&
	    (eusrc->radial_p == eudst || eudst->radial_p == eusrc))  {
	    	rt_log("nmg_moveeu() edgeuses already share edge\n");
		return;
	}

	/* make sure vertices are shared */
	if ( ! ( (eudst_mate->vu_p->v_p == eusrc->vu_p->v_p &&
	    eudst->vu_p->v_p == eusrc_mate->vu_p->v_p) ||
	    (eudst->vu_p->v_p == eusrc->vu_p->v_p &&
	    eudst_mate->vu_p->v_p == eusrc_mate->vu_p->v_p) ) ) {
		/* edgeuses do NOT share verticies. */
	    	VPRINT("eusrc", eusrc->vu_p->v_p->vg_p->coord);
	    	VPRINT("eusrc_mate", eusrc_mate->vu_p->v_p->vg_p->coord);
	    	VPRINT("eudst", eudst->vu_p->v_p->vg_p->coord);
	    	VPRINT("eudst_mate", eudst_mate->vu_p->v_p->vg_p->coord);
	    	rt_bomb("nmg_moveeu() edgeuses do not share vertices, cannot share edge\n");
	}

	e = eusrc->e_p;
	eusrc_mate->e_p = eusrc->e_p = eudst->e_p;

	/* if we're not deleting the edge, make sure it will be able
	 * to reference the remaining uses, otherwise, take care of disposing
	 * of the (now unused) edge
	 */
	if (eusrc->radial_p != eusrc_mate) {
		/* this is NOT the only use of the eusrc edge! */
		if (e->eu_p == eusrc || e->eu_p == eusrc_mate)
			e->eu_p = eusrc->radial_p;

		/* disconnect from the list of uses of this edge */
		eusrc->radial_p->radial_p = eusrc_mate->radial_p;
		eusrc_mate->radial_p->radial_p = eusrc->radial_p;
	} else {
		/* this is the only use of the eusrc edge */
		if (e->eg_p) FREE_EDGE_G(e->eg_p);
		FREE_EDGE(e);
	}

	eusrc->radial_p = eudst;
	eusrc_mate->radial_p = eudst->radial_p;

	eudst->radial_p->radial_p = eusrc_mate;
	eudst->radial_p = eusrc;
}

/*			N M G _ U N G L U E E D G E
 *
 *	If edgeuse is part of a shared edge (more than one pair of edgeuses
 *	on the edge), it and its mate are "unglued" from the edge, and 
 *	associated with a new edge structure.
 *
 *	Primarily a support routine for nmg_eusplit()
 */
void
nmg_unglueedge(eu)
struct edgeuse *eu;
{
	struct edge	*old_e;
	struct edge	*new_e;
	struct model	*m;

	NMG_CK_EDGEUSE(eu);
	old_e = eu->e_p;
	NMG_CK_EDGE(old_e);

	/* if we're already a single edge, just return */
	if (eu->radial_p == eu->eumate_p)
		return;

	m = nmg_find_model( &eu->l.magic );
	GET_EDGE(new_e, m);

	new_e->magic = NMG_EDGE_MAGIC;
	/* XXX If old_e had edge_g, should duplicate reference here */
	new_e->eg_p = (struct edge_g *)NULL;
	new_e->eu_p = eu;

	/* make sure the edge isn't pointing at this edgeuse */
	if (old_e->eu_p == eu || old_e->eu_p == eu->eumate_p ) {
		old_e->eu_p = old_e->eu_p->radial_p;
	}

	/* unlink edgeuses from old edge */
	eu->radial_p->radial_p = eu->eumate_p->radial_p;
	eu->eumate_p->radial_p->radial_p = eu->radial_p;
	eu->eumate_p->radial_p = eu;
	eu->radial_p = eu->eumate_p;

	/* Associate edgeuse and mate with new edge */
	eu->eumate_p->e_p = eu->e_p = new_e;
}

/*
 *			N M G _ J V
 *
 *	Join two vertexes into one.
 *	v1 inherits all the vertexuses presently pointing to v2,
 *	and v2 is then destroyed.
 */
void
nmg_jv(v1, v2)
register struct vertex	*v1;
register struct vertex	*v2;
{
	register struct vertexuse	*vu;

	NMG_CK_VERTEX(v1);
	NMG_CK_VERTEX(v2);

	if (v1 == v2) return;

	/*
	 *  Walk the v2 list, unlinking vertexuse structs,
	 *  and adding them to the *end* of the v1 list
	 *  (which preserves relative ordering).
	 */
	vu = RT_LIST_FIRST(vertexuse, &v2->vu_hd );
	while( RT_LIST_NOT_HEAD( vu, &v2->vu_hd ) )  {
		register struct vertexuse	*vunext;

		NMG_CK_VERTEXUSE(vu);
		vunext = RT_LIST_PNEXT(vertexuse, vu);
		RT_LIST_DEQUEUE( &vu->l );
		RT_LIST_INSERT( &v1->vu_hd, &vu->l );
		vu->v_p = v1;		/* "up" to new vertex */
		vu = vunext;
	}

	if (v2->vg_p) FREE_VERTEX_G(v2->vg_p);
	FREE_VERTEX(v2);
@


10.16
log
@Minor tidy up of nmg_dup_face().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.15 93/02/24 00:58:56 mike Exp Locker: mike $ (BRL)";
d657 2
d664 2
a665 5
#if UNGLUE_MAKES_VERTICES
	struct vertex *v1, *v2;
	struct vertex_g *vg1, *vg2;
#endif
	struct edge	*e;
d669 2
d677 1
a677 1
	GET_EDGE(e, m);
d679 4
a682 8
	e->magic = NMG_EDGE_MAGIC;
	e->eg_p = (struct edge_g *)NULL;
	e->eu_p = eu;
#if UNGLUE_MAKES_VERTICES
	GET_VERTEX(v1, m);
	GET_VERTEX(v2, m);
	GET_VERTEX_G(vg1, m);
	GET_VERTEX_G(vg2, m);
a683 28
	/* we want a pair of new vertices that are identical to the old
	 * ones for the newly separated edge.
	 */
	v1->vu_p = v2->vu_p = (struct vertexuse *)NULL;
	v1->magic = v2->magic = NMG_VERTEX_MAGIC;

	/* if there was vertex geometry, copy it */
	if (eu->vu_p->v_p->vg_p) {
		*vg1 = *(eu->vu_p->v_p->vg_p);	/* struct copy */
		v1->vg_p = vg1;
	} else {
		v1->vg_p = (struct vertex_g *)NULL;
		FREE_VERTEX_G(vg1);
	}

	if (eu->eumate_p->vu_p->v_p->vg_p) {
		*vg2 = *(eu->eumate_p->vu_p->v_p->vg_p);	/* struct copy */
		v2->vg_p = vg2;
	} else {
		v2->vg_p = (struct vertex_g *)NULL;
		FREE_VERTEX_G(vg2);
	}

	/* now move the vertexuses to the new (but identical) verteces. */
	nmg_movevu(eu->vu_p, v1);
	nmg_movevu(eu->eumate_p->vu_p, v1);
#endif

d685 2
a686 2
	if (eu->e_p->eu_p == eu || eu->e_p->eu_p == eu->eumate_p ) {
		eu->e_p->eu_p = eu->e_p->eu_p->radial_p;
d695 2
a696 2
	eu->eumate_p->e_p = eu->e_p = e;

@


10.15
log
@Added subroutine names to rt_log statements.
Moved some checking routines to nmg_ck.c
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.14 93/02/19 04:47:10 mike Exp Locker: mike $ (BRL)";
d2254 5
a2258 8





/* XXX This should be dynamic, for PARALLEL operation */
static long **trans_tbl = (long **)NULL;

d2260 1
a2260 1
nmg_dup_loop(lu, parent)
d2262 2
a2263 1
long *parent;
a2270 1
	char padstr[32];
a2274 3
	if (trans_tbl == (long **)NULL)
		nmg_start_dup(nmg_find_model( (long *)lu ));

a2279 1

d2285 1
a2285 1
			rt_log("nmg_dup_loop() vertex in new model\n");
d2375 5
d2387 2
a2388 1
	char padstr[32];
d2394 3
a2396 1
	if (!trans_tbl) nmg_start_dup(nmg_find_model( (long *)s ));
d2400 1
a2400 1
			nmg_dup_loop(lu, new_fu);
d2402 1
a2402 1
			new_lu = nmg_dup_loop(lu, s);
a2411 2
	return(new_fu);
}
d2413 1
a2413 5
nmg_start_dup(m)
struct model *m;
{
	if (trans_tbl)
		rt_free((char *)trans_tbl, "nmg_dup_face trans_tbl");
d2415 1
a2415 9
	
	trans_tbl = (long **)rt_calloc(m->maxindex, sizeof(long *),
			"nmg_dup_face trans_tbl");
}

nmg_end_dup()
{
	rt_free((char *)trans_tbl, "nmg_dup_face trans_tbl");
	trans_tbl = (long **)NULL;
@


10.14
log
@Changed calling sequence of nmg_ebreak() and nmg_esplit() to
use edgeuse pointers, rather than edge pointers.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.13 93/02/19 03:05:48 mike Exp Locker: mike $ (BRL)";
d475 1
a475 1
		rt_log("in %s at %d invalid edgeuse parent\n",
d477 1
a477 1
		rt_bomb("nmg_eusplit");
d784 1
a784 1
		rt_log("in %s at %d Cannot move loop to face in another shell\n",
d826 1
a826 2
 *	If the call was nmg_esplit( NULL, eu->e_p );
 *	then on return the new vertex created will be eu->eumate_p->vu_p->v_p;
d947 1
a947 1
	rt_bomb("nmg_esplit: *** unable to find eu starting at new v ***\n");
d953 3
a955 1
 *	break an edge in two.
a956 3
 *	This splits an edge into two parts.  The two resultant parts share
 *	the same edge geometry.
 *
a968 1
	/* XXX if eg is null, and vertex geom exists, really ought to make edge geom */
d976 1
a976 1
	new_eu = nmg_esplit(v, eu);
d983 1
a983 1
	/* Make sure the two edges share same geometry, if there was any. */
d987 1
a1008 2
	struct vertexuse	*vu;
	long			*magicp;
a1012 12
	/*
	 * Need to get from eu1 up to shell, so that the vertex can
	 * be made in the current shell.
	 * Otherwise, nmg_kvu() will zap our edge!
	 */
	magicp = eu1->up.magic_p;		/* loopuse or shell */
	if( *magicp == NMG_LOOPUSE_MAGIC )
		magicp = ((struct loopuse *)magicp)->up.magic_p;
	if( *magicp == NMG_FACEUSE_MAGIC )
		magicp = &((struct faceuse *)magicp)->s_p->l.magic;
	if( *magicp != NMG_SHELL_MAGIC )
		rt_bomb("nmg_e2break():  Can't find e1's shell\n");
d1014 2
a1015 3
	vu = nmg_mvvu( magicp );	/* Really only want v, not vu */
	NMG_CK_VERTEXUSE(vu);
	v = vu->v_p;
a1016 5
	new_eu = nmg_ebreak( v, eu1 );
	/* XXX  get the new v info here, then the nmg_mvvu()
	 * XXX gunk could be avoided. */
	if( new_eu->vu_p->v_p != v )  rt_bomb("nmg_e2break: new vertex mis-match?\n");

a1018 2
	/* Note:  nmg_kvu() nulls out vu->up.magic_p's down pointer! */
	nmg_kvu( vu );			/* Kill initial (temporary) use */
d1181 1
a1181 1
			rt_log("in %s at %d faceuses don't share parent\n",
d1189 1
a1189 1
			rt_bomb("nmg_cluefaces() Cannot glue edges of face on vertex\n");
d1236 1
a1236 1
		rt_log("looking for edge between %8x and %8x other than %8x/%8x\n",
d1242 1
a1242 1
			rt_log("in %s at %d vertexuse has null parent\n",
d1244 1
a1244 1
			rt_bomb("nmg_findeu");
d1323 1
a1323 1
		rt_bomb("nmg_jl: some moron trying to join a loop to itself\n");
a1761 61
/*
 *			N M G _ C K _ L U E U
 *
 *	check all the edgeuses of a loopuse to make sure these children
 *	know who thier parent really is.
 */
void nmg_ck_lueu(cklu, s)
struct loopuse *cklu;
char *s;
{
	struct edgeuse *eu;

	if (RT_LIST_FIRST_MAGIC(&cklu->down_hd) == NMG_VERTEXUSE_MAGIC)
		rt_bomb("NMG nmg_ck_lueu.  I got a vertex loop!\n");

	eu = RT_LIST_FIRST(edgeuse, &cklu->down_hd);
	if (eu->l.back != &cklu->down_hd) {
		rt_bomb("nmg_ck_lueu first element in list doesn't point back to head\n");
	}

	for (RT_LIST_FOR(eu, edgeuse, &cklu->down_hd)) {
		NMG_CK_EDGEUSE(eu);
		if (eu->up.lu_p != cklu) {
			rt_log("edgeuse of %s (going next) has lost proper parent\n", s);
			rt_bomb("nmg_ck_lueu");
		}
		if ((struct edgeuse *)eu->l.forw->back != eu) {
			rt_log("%s next edge (%8x) doesn't point back to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
		if ((struct edgeuse *)eu->l.back->forw != eu) {
			rt_log("%s last edge (%8x) doesn't point forward to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
	}

	cklu = cklu->lumate_p;

	eu = RT_LIST_FIRST(edgeuse, &cklu->down_hd);
	if (eu->l.back != &cklu->down_hd) {
		rt_bomb("nmg_ck_lueu first element in lumate list doesn't point back to head\n");
	}

	for (RT_LIST_FOR(eu, edgeuse, &cklu->down_hd)) {
		NMG_CK_EDGEUSE(eu);
		if (eu->up.lu_p != cklu) {
			rt_log("edgeuse of %s (lumate going next) has lost proper parent\n", s);
			rt_bomb("nmg_ck_lueu");
		}
		if ((struct edgeuse *)eu->l.forw->back != eu) {
			rt_log("%s next edge (%8x) doesn't point back to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
		if ((struct edgeuse *)eu->l.back->forw != eu) {
			rt_log("%s (lumate) back edge (%8x) doesn't point forward to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
	}
}


d1805 1
a1805 1
		rt_log("at %d in %s vertices should be decendants of same loop\n",
d1807 1
a1807 1
		rt_bomb("subroutine nmg_cut_loop");
d1821 1
a1821 1
			rt_log("plotting %s\n", name);
d1899 1
a1899 1
		rt_log("plotting %s\n", name);
d1994 1
a1994 1
	if( iteration >= 10000 )  rt_bomb("nmg_split_lu_at_vu:  infinite loop");
a2102 35
 *			N M G _ C K _ L I S T
 *
 *  Generic list checker.
 */
void
nmg_ck_list( hd, str )
struct rt_list		*hd;
CONST char		*str;
{
	register struct rt_list	*cur;
	int	head_count = 0;

	cur = hd;
	do  {
		if( cur->magic == RT_LIST_HEAD_MAGIC )  head_count++;
		if( cur->forw->back != cur )  {
			rt_log("nmg_ck_list(%s) cur=x%x, cur->forw=x%x, cur->forw->back=x%x\n",
				str, cur, cur->forw, cur->forw->back );
			rt_bomb("nmg_ck_list() forw\n");
		}
		if( cur->back->forw != cur )  {
			rt_log("nmg_ck_list(%s) cur=x%x, cur->back=x%x, cur->back->forw=x%x\n",
				str, cur, cur->back, cur->back->forw );
			rt_bomb("nmg_ck_list() back\n");
		}
		cur = cur->forw;
	} while( cur != hd );

	if( head_count != 1 )  {
		rt_log("nmg_ck_list(%s) head_count = %d\n", head_count);
		rt_bomb("headless!\n");
	}
}

/*
d2259 1
d2292 1
a2292 1
			rt_log("vertex in new model\n");
d2295 1
a2295 1
			rt_log("new vertex in new model\n");
a2429 2


@


10.13
log
@Added comments and error checking to nmg_esplit, with no change in
function.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.12 93/02/12 00:47:47 mike Exp Locker: mike $ (BRL)";
a28 3
/* XXX move to raytrace.h */
RT_EXTERN( struct vertex *nmg_e2break, (struct edge *e1, struct edge *e2) );

d368 2
a369 2
 *	In either case, the new edge will exist as the "next" edge after
 *	the edge passed as a parameter.
d371 3
d812 2
a813 2
 *	In either case, the new edge will exist as the "next" edge after
 *	the edge passed as a parameter.
d815 2
a816 9
 *	Explicit return:
 *		edge pointer, referring to the edge structure which
 *		replaces the edge passed in as parameter "e".
 *		The calling routine should be careful to update it's
 *		"e" variable with this new value, assuming that "e"
 *		wasn't derived as eu->e_p, which will still evaluate to
 *		the correct edge (but with a different pointer value
 *		than before).
 *		This is silly, because the return is *always* "e".
d818 3
a820 8
 * XXX I don't understand what the return is, by reading this comment.
 * XXX something more useful might be along these lines:
 *	The explicit return (ret_e) referrs to the new edge.
 *	On return, e->eu_p will run from A to V, and
 *	(ret_e)->eu_p will run from V to B.
 *	Note that only edgeuses are oriented, not edges, so it's
 *	not possible to say whether ret_e "starts" or "ends" at V.
 * XXX The question is, is this what really happens?
d822 3
a824 3
 *	Vertex A is e->eu_p->vu_p->v_p,
 *	Vertex B is e->eu_p->eumate_p->vu_p->v_p,
 *	and vertex V (either made new or as an argument) will lie inbetween.
d831 1
a831 1
 *		       oldeu
d837 1
a837 1
 *		      oldeumate
d841 2
a842 2
 *		     oldeu(cw)    eu1
 *		    .------->   .----->
d844 3
a846 4
 *	   (edge) A ========= V ~~~~~~~ B (new edge)
 *			     /         /
 *		    <-------.   <-----.
 *		       mate	 mate
d848 4
a851 4
struct edge *
nmg_esplit(v, e)
struct vertex *v;
struct edge *e;
d853 2
a854 2
	struct edgeuse	*eu,	/* placeholder edgeuse */
			*eur,	/* radial edgeuse of placeholder */
d858 1
a858 1
	struct vertex	*v1, *v2;
a859 2
	NMG_CK_EDGE(e);
	eu = e->eu_p;
d863 3
d887 1
a887 1
		/* eur could run either from v1 to v2, or from v2 to v1 */
d889 1
d924 1
d944 3
a946 1
	if( neu2->e_p != e )  rt_log("nmg_esplit: neu2->e_p != e\n");
d948 1
a948 1
	return(e);
d961 4
a964 4
struct edge *
nmg_ebreak(v, e)
struct vertex *v;
struct edge *e;
d966 2
a967 1
	struct edge *new_e;
d969 3
a971 1
	new_e = nmg_esplit(v, e);
d973 13
d987 2
a988 2
	if (!e->eg_p) return new_e;
	if (new_e->eg_p)  rt_bomb("nmg_ebreak() new edge developed geometry?\n");
d990 5
a994 3
	new_e->eg_p = e->eg_p;
	new_e->eg_p->usage++;
	return new_e;
d1006 3
a1008 3
nmg_e2break( e1, e2 )
struct edge	*e1;
struct edge	*e2;
d1013 1
a1013 1
	struct edge		*repl_e1;
d1015 2
a1016 2
	NMG_CK_EDGE(e1);
	NMG_CK_EDGE(e2);
d1018 1
a1018 1
	 * Need to get from e1 up to shell, so that the vertex can
d1022 1
a1022 1
	magicp = e1->eu_p->up.magic_p;		/* loopuse or shell */
d1034 2
a1035 2
	repl_e1 = nmg_ebreak( v, e1 );
	/* XXX If we could get the new v info here, the nmg_mvvu()
d1037 3
a1039 1
	(void)nmg_ebreak( v, e2 );
@


10.12
log
@Fixed bug in nmg_e2break(), although a better strategy could
be found.
Added a useful comment on how to use nmg_esplit().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.11 93/02/10 01:39:53 mike Exp Locker: mike $ (BRL)";
d814 1
d816 9
a824 2
 *		pointer to the new edge which took the place of the parameter
 *	edge.
a827 3
 *	Vertex A is e->eu_p->v_p,
 *	Vertex B is e->eu_p->eumate_p->v_p,
 *	and vertex V (either made new or as an argument) will lie inbetween.
d834 4
d839 1
a839 1
 *	then the new vertex created will be eu->eumate_p->vu_p->v_p;
d873 1
a878 1
	NMG_CK_VERTEX(eu->vu_p->v_p);
d880 1
d882 1
a883 1
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
d885 1
d887 1
d899 1
d906 5
a910 1
		if (!v) v = eu2->vu_p->v_p;
a912 1

d914 1
d930 3
a932 2
			rt_log("in %s at %d ", __FILE__, __LINE__);
			rt_bomb("nmg_esplit() Something's awry\n");
d936 1
a942 1

a950 1

d954 3
a956 1
	return(neu2->e_p);
d1003 1
d1024 1
a1024 1
	(void)nmg_ebreak( v, e1 );
@


10.11
log
@Added some sanity checking to nmg_esplit.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.10 93/02/06 04:16:14 mike Exp Locker: mike $ (BRL)";
d829 3
d981 1
a981 1
	struct vertex	*v;
d983 1
d985 16
a1000 1
	vu = nmg_mvvu( &e1->magic );	/* Really only want v, not vu */
d1005 2
d1008 2
@


10.10
log
@Added nmg_e2break
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.9 92/12/14 14:09:01 mike Exp Locker: mike $ (BRL)";
d872 5
@


10.9
log
@Prevent infinite loop
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.8 92/11/16 23:12:40 mike Exp Locker: mike $ (BRL)";
d29 3
d802 4
a805 1
 *	Split an edge.
d807 4
a810 2
 *	Actually, we split each edgeuse pair of the given edge, and combine
 *	the new edgeuses together onto new edges.  
d812 2
d817 31
d929 1
a929 2

	return(eu->e_p);
d939 2
d942 1
d947 1
a947 3
	struct edge *e_p;
	
	e_p = nmg_esplit(v, e);
d949 1
a949 3
	/* now that the edge has been split, let's make sure the two edges
	 * share the same geometry.  This gives me the heebie-geebies. XXX
	 */
d951 3
a953 1
	if (!e->eg_p) return;
d955 29
a983 2
	e_p->eg_p = e->eg_p;
	e_p->eg_p->usage++;
@


10.8
log
@Removed stray backslash
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.7 92/11/11 00:08:09 butler Exp Locker: mike $ (BRL)";
d1897 1
d1930 1
a1930 1
	for( ;; )  {
d1951 1
@


10.7
log
@Revised formatting of function definitions
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.6 92/08/05 22:28:40 mike Exp Locker: butler $ (BRL)";
d2267 1
a2267 1
	if (trans_tbl == (long **)NULL)\
@


10.6
log
@When two loops of opposite orientations are combined, the resulting
loop is of OT_SAME, always.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.5 92/07/23 05:31:54 mike Exp Locker: mike $ (BRL)";
d1197 2
a1198 1
void nmg_jl(lu, eu)
d1362 2
a1363 1
void nmg_simplify_loop(lu)
d1425 2
a1426 1
void nmg_kill_snakes(lu)
d1496 2
a1497 1
void nmg_simplify_face(fu)
d1646 2
a1647 1
void nmg_simplify_shell(s)
d2419 2
@


10.5
log
@Changed nmg_cut_loop and nmg_join_2loops to give meaningful return codes.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.4 92/07/20 23:08:47 butler Exp Locker: mike $ (BRL)";
d1288 1
d1307 7
d1349 2
@


10.4
log
@added nmg_dup_face()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.3 92/02/25 00:06:49 mike Exp Locker: butler $ (BRL)";
d1274 2
d1277 1
a1277 1
int
d1321 1
d1344 1
d1708 2
a1709 2
 *	we make a new loop between the two vertexes, and split it and
 *	the loop of the parametric vertexuses at the same time.
d1724 1
d1726 2
a1727 1
void nmg_cut_loop(vu1, vu2)
d1855 1
@


10.3
log
@Added nmg_eu_with_vu_in_lu() and nmg_move_eg().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 10.2 92/02/21 01:32:15 butler Exp Locker: mike $ (BRL)";
d1316 2
a1317 1
		second_new_eu = RT_LIST_NEXT( edgeuse, &eu1->l );
d1482 2
a1483 1
	struct loopuse *lu;
d1493 33
d1529 96
d2220 176
@


10.2
log
@added nmg_ebreak to split an edge but retain same geometry for both
resultant edge parts.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_mod.c,v 10.1 91/10/12 06:40:49 mike Rel4_0 Locker: butler $ (BRL)";
d1988 101
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 2.13 91/07/26 23:45:58 mike Exp $ (BRL)";
d890 26
@


2.13
log
@Added more error checking to find vu in face
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 2.12 91/06/22 20:27:07 mike Exp $ (BRL)";
@


2.12
log
@Fixed nmg_merge_2faces to take orientation into account.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 2.11 91/06/22 20:12:57 butler Exp $ (BRL)";
d985 2
a986 1
	register pointp_t	pp;
d990 1
d998 5
a1002 2
			pp = vu->v_p->vg_p->coord;
			VSUB2(delta, pp, pt);
d1008 5
a1012 2
				pp = eu->vu_p->v_p->vg_p->coord;
				VSUB2(delta, pp, pt);
@


2.11
log
@Added nmg_merge_2faces
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 2.10 91/06/17 20:42:17 butler Exp $ (BRL)";
d1931 6
d1945 7
a1951 2
	nmg_move_fu_fu(dest_fu, src_fu);
	nmg_move_fu_fu(dest_fu->fumate_p, src_fu->fumate_p);
@


2.10
log
@changed function declarations so that all global functions have their
"nmg_" at the begining of the line.  Static functions have their function
names on the same line as the "static" modifier.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 2.9 91/06/13 05:42:44 mike Exp $ (BRL)";
d1910 2
a1911 1
void nmg_move_fu_fu( dest_fu, src_fu )
d1929 14
@


2.9
log
@Order of #include
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 2.8 91/06/03 19:25:42 mike Exp $ (BRL)";
d160 2
a161 1
struct faceuse *nmg_cface(s, verts, n)
d254 2
a255 1
struct faceuse *nmg_cmface(s, verts, n)
d391 2
a392 1
struct edgeuse *nmg_eusplit(v, oldeu)
d579 2
a580 1
void nmg_moveeu(eudst, eusrc)
d655 2
a656 1
void nmg_unglueedge(eu)
d734 2
a735 1
void nmg_jv(v1, v2)
d808 2
a809 1
struct edge *nmg_esplit(v, e)
d917 2
a918 1
struct edgeuse *nmg_eins(eu)
d976 2
a977 1
struct vertexuse *nmg_find_vu_in_face(pt, fu, tol)
d1084 2
a1085 1
struct edgeuse *nmg_findeu(v1, v2, s, eup)
@


2.8
log
@CONST fiddlign
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 2.8 91/06/03 19:20:33 mike Exp $ (BRL)";
d26 1
a27 1
#include "nmg.h"
@


2.7
log
@Added comments to nmg_jl()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 2.6 91/05/24 19:00:12 mike Exp $ (BRL)";
d969 1
a969 1
point_t			pt;
d1867 1
a1867 1
CONST struct rt_list	*hd;
d1870 1
a1870 1
	struct rt_list	*cur;
@


2.6
log
@Moved nmg_join_2loops() to nmg_mod
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 2.5 91/05/22 23:24:40 mike Exp $ (BRL)";
d1147 2
a1148 1
/*			N M G _ J L
d1150 2
a1151 2
 *	Join two loops together which share a common edge
 *
d1158 1
d1163 3
a1165 2
	NMG_CK_EDGEUSE(eu->radial_p);
	NMG_CK_EDGEUSE(eu->radial_p->eumate_p);
a1169 1
	eu_r = eu->radial_p;
d1186 2
a1187 2

	/* remove all the edgeuses "ahead" of our radial and insert them
d1203 3
a1205 2
	/* at this point, the other loop just has the one edgeuse/edge in
	 * it.  we can delete the other loop.
d1209 3
a1211 2
	/* we pop out the one remaining use of the "shared" edge and
	 * voila! we should have one contiguous loop.
@


2.5
log
@Added nmg_move_fu_fu
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 2.4 91/05/18 03:03:26 mike Exp $ (BRL)";
d1212 81
@


2.4
log
@Converted to new tolerance interface
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 2.3 91/04/03 03:12:00 mike Exp $ (BRL)";
d962 1
a962 1
 *			F I N D _ V U _ I N _ F A C E
d1807 25
@


2.3
log
@Now nmg_kill_snakes().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 2.2 91/04/01 19:59:45 mike Exp $ (BRL)";
d77 3
a79 3
nmg_fu_planeeqn( fu, tol_sq )
struct faceuse	*fu;
double		tol_sq;
d116 1
a116 1
	    a->vg_p->coord, b->vg_p->coord, c->vg_p->coord, tol_sq) < 0 ) {
d969 3
a971 3
point_t		pt;
struct faceuse	*fu;
fastf_t		tol;
d989 1
a989 1
			if ( MAGSQ(delta) < tol)
d996 1
a996 1
				if ( MAGSQ(delta) < tol)
d1782 2
a1783 2
struct rt_list	*hd;
char		*str;
@


2.2
log
@Edges of loops now travel in a counter-clockwise (CCW) direction
around the face normal.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mod.c,v 2.1 91/04/01 16:03:57 mike Exp $ (BRL)";
d1275 2
a1276 1
/*	K I L L _ S N A K E S
d1279 1
a1279 1
static void kill_snakes(lu)
d1361 1
a1361 1
		kill_snakes(lu);
@


2.1
log
@Moved geometry modification routines from nmg_mk.c to nmg_mod.c
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.36 91/03/26 00:51:41 mike Exp $ (BRL)";
d30 104
d136 1
a136 1
 *	Create a face from a list of vertices
d148 5
a152 4
 *	The vertices should be listed in "clockwise" order if this is
 *	an ordinary face, and in "counterclockwise" order if this is
 *	an interior ("hole" or "subtracted") face.
 *	See the comments in nmg_cmface() for more details.
d156 2
a157 1
 *	Therefore, the callers vertices are inserted in reverse order,
d209 2
a210 1
 *	Create a face for a manifold shell from a list of vertices
d220 1
a220 1
 *	manifold shells from a series of points/faces.
d241 5
a245 7
 *	The vertices should be listed in "clockwise" order if this is
 *	an ordinary face, and in "counterclockwise" order if this is
 *	an interior ("hole" or "subtracted") face.
 *	Note that while this routine makes only topology, without
 *	reference to geometry, by following the clockwise rule,
 *	finding the surface normal
 *	of ordinary faces can be done using the following procedure.
a246 21
 *
 *			C                   D
 *	                *-------------------*
 *	                |                   |
 *	                |   ^...........>   |
 *	   ^     N      |   .           .   |
 *	   |      \     |   .           .   |
 *	   |       \    |   . clockwise .   |
 *	   |C-B     \   |   .           .   |
 *	   |         \  |   .           v   |
 *	   |          \ |   <............   |
 *	               \|                   |
 *	                *-------------------*
 *	                B                   A
 *			       ----->
 *				A-B
 *
 *	If the points are given in the order A B C D (eg, clockwise),
 *	then the outward pointing surface normal N = (A-B) x (C-B).
 *	This is the "right hand rule".
 *
d249 2
a250 1
 *	Therefore, the callers vertices are inserted in reverse order,
d328 3
a330 4
				rt_log("found another edgeuse (%8x) between %8x and %8x\n",
					eur, *verts[i+1], *verts[i]);
			}
			else {
a335 3
			if (rt_g.NMG_debug & DEBUG_CMFACE)
				rt_log("*verts[%d] is null\t", i);

d339 4
a342 2
			if (rt_g.NMG_debug & DEBUG_CMFACE)
			rt_log("*verts[%d] is now %8x\n", i, *verts[i]);
d346 1
a346 1
	if (eur = nmg_findeu(*verts[n-1], *verts[0], s, euold))
d348 1
a348 1
	else 
d352 1
a352 1

@
