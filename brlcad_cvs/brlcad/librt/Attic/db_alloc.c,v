head	11.21;
access;
symbols
	ansi-20040405-merged:11.17.2.2
	postmerge-20040405-ansi:11.19
	premerge-20040404-ansi:11.18
	postmerge-autoconf:11.18
	autoconf-freeze:11.17.10.2
	premerge-autoconf:11.18
	ansi-20040316-freeze:11.17.2.1
	postmerge-20040315-windows:11.18
	premerge-20040315-windows:11.18
	windows-20040315-freeze:11.17.4.1
	autoconf-20031203:11.17
	autoconf-20031202:11.17
	autoconf-branch:11.17.0.10
	phong-branch:11.17.0.8
	photonmap-branch:11.17.0.6
	rel-6-1-DP:11.17
	windows-branch:11.17.0.4
	rel-6-0-2:11.15
	ansi-branch:11.17.0.2
	rel-6-0-1-branch:11.15.0.2
	hartley-6-0-post:11.16
	hartley-6-0-pre:11.15
	rel-6-0-1:11.15
	rel-6-0:11.15
	rel-5-4:11.8
	offsite-5-3-pre:11.13
	rel-5-3:11.8
	rel-5-2:11.8
	rel-5-1-branch:11.8.0.2
	rel-5-1:11.8
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.5
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.21
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	11.20;

11.20
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.19;

11.19
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	11.17;

11.17
date	2002.08.20.17.07.57;	author jra;	state Exp;
branches
	11.17.2.1
	11.17.4.1
	11.17.10.1;
next	11.16;

11.16
date	2002.08.15.20.55.08;	author hartley;	state Exp;
branches;
next	11.15;

11.15
date	2001.05.17.20.05.23;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2001.04.20.22.29.41;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2000.08.22.20.16.37;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	2000.07.29.23.23.04;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.07.10.23.01.27;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.07.07.03.26.24;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.06.29.20.24.17;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.12.30.02.48.00;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.12.22.02.07.37;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.12.22.02.01.50;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.12.16.06.08.47;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.02.06.04.18.29;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.01.29.07.34.41;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.13;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.12.27.16.57.01;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.25.19.50.59;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.10.15.40.57;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.00;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	90.12.11.22.03.25;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.55.38;	author mike;	state Rel3_5;
branches;
next	1.2;

1.2
date	89.03.15.15.36.20;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.12.06.00.09.07;	author mike;	state Exp;
branches;
next	;

11.17.2.1
date	2002.09.19.18.01.30;	author morrison;	state Exp;
branches;
next	11.17.2.2;

11.17.2.2
date	2004.03.17.21.18.43;	author morrison;	state Exp;
branches;
next	;

11.17.4.1
date	2004.03.11.23.43.35;	author morrison;	state Exp;
branches;
next	;

11.17.10.1
date	2004.02.12.18.37.38;	author erikg;	state Exp;
branches;
next	11.17.10.2;

11.17.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@db_alloc
@


11.21
log
@moved to src/
@
text
@/*
 *			D B _ A L L O C . C
 *
 * Functions -
 *	db_alloc	Find a contiguous block of database storage
 *	db_delete	Delete storage associated w/entry, zap records
 *	db_zapper	Zap region of file into ID_FREE records
 *	db_flags_internal	Construct flags word
 *
 *
 *  Authors -
 *	Michael John Muuss
 *	Robert Jon Reschly Jr.
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db_alloc.c,v 11.20 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "raytrace.h"

#include "./debug.h"

/*
 *  			D B _ A L L O C
 *  
 *  Find a block of database storage of "count" granules.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
int
db_alloc(register struct db_i *dbip, register struct directory *dp, int count)
{
	unsigned long	addr;
	union record	rec;

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_alloc(%s) x%x, x%x, count=%d\n",
		dp->d_namep, dbip, dp, count );
	if( count <= 0 )  {
		bu_log("db_alloc(0)\n");
		return(-1);
	}

	if( dp->d_flags & RT_DIR_INMEM )  {
		if( dp->d_un.ptr )  {
			dp->d_un.ptr = bu_realloc( dp->d_un.ptr,
				count * sizeof(union record), "db_alloc() d_un.ptr" );
		} else {
			dp->d_un.ptr = bu_malloc( count * sizeof(union record), "db_alloc() d_un.ptr" );
		}
		dp->d_len = count;
		return 0;
	}

	if( dbip->dbi_read_only )  {
		bu_log("db_alloc on READ-ONLY file\n");
		return(-1);
	}
	while(1)  {
		if( (addr = rt_memalloc( &(dbip->dbi_freep), (unsigned)count )) == 0L )  {
			/* No contiguous free block, append to file */
			if( (dp->d_addr = dbip->dbi_eof) < 0 )  {
				bu_log("db_alloc: bad EOF\n");
				return(-1);
			}
			dp->d_len = count;
			dbip->dbi_eof += count * sizeof(union record);
			dbip->dbi_nrec += count;
			break;
		}
		dp->d_addr = addr * sizeof(union record);
		dp->d_len = count;
		if( db_get( dbip, dp, &rec, 0, 1 ) < 0 )
			return(-1);
		if( rec.u_id != ID_FREE )  {
			bu_log("db_alloc():  addr %ld non-FREE (id %d), skipping\n",
				addr, rec.u_id );
			continue;
		}
	}

	/* Clear out ALL the granules, for safety */
	return( db_zapper( dbip, dp, 0 ) );
}

/*
 *			D B _ D E L R E C
 *
 *  Delete a specific record from database entry
 *  No longer supported.
 */
int
db_delrec(struct db_i *dbip, register struct directory *dp, int recnum)
{

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_delrec(%s) x%x, x%x, recnum=%d\n",
		dp->d_namep, dbip, dp, recnum );

	bu_log("ERROR db_delrec() is no longer supported.  Use combination import/export routines.\n");
	return -1;
}

/*
 *  			D B _ D E L E T E
 *  
 *  Delete the indicated database record(s).
 *  Arrange to write "free storage" database markers in it's place,
 *  positively erasing what had been there before.
 */
int
db_delete(struct db_i *dbip, struct directory *dp)
{
	register int i = -1;

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_delete(%s) x%x, x%x\n",
		dp->d_namep, dbip, dp );

	if( dp->d_flags & RT_DIR_INMEM )  {
		bu_free( dp->d_un.ptr, "db_delete d_un.ptr");
		dp->d_un.ptr = NULL;
		dp->d_len = 0;
		return 0;
	}

	if( dbip->dbi_version == 4 )  {
		i = db_zapper( dbip, dp, 0 );
		rt_memfree( &(dbip->dbi_freep), (unsigned)dp->d_len,
			dp->d_addr/(sizeof(union record)) );
	} else if( dbip->dbi_version == 5 )  {
		i = db5_write_free( dbip, dp, dp->d_len );
		rt_memfree( &(dbip->dbi_freep), dp->d_len,
			dp->d_addr );
	} else {
		bu_bomb("db_delete() unsupported database version\n");
	}

	dp->d_len = 0;
	dp->d_addr = -1;
	return i;
}

/*
 *			D B _ Z A P P E R
 *
 *  Using a single call to db_put(), write multiple zeroed records out,
 *  all with u_id field set to ID_FREE.
 *  This will zap all records from "start" to the end of this entry.
 *
 *  Returns:
 *	-1	on error
 *	0	on success (from db_put())
 */
int
db_zapper(struct db_i *dbip, struct directory *dp, int start)
{
	register union record	*rp;
	register int		i;
	int			todo;

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_zapper(%s) x%x, x%x, start=%d\n",
		dp->d_namep, dbip, dp, start );

	if( dp->d_flags & RT_DIR_INMEM )  bu_bomb("db_zapper() called on RT_DIR_INMEM object\n");

	if( dbip->dbi_read_only )
		return(-1);

	BU_ASSERT_LONG( dbip->dbi_version, ==, 4 );

	if( (todo = dp->d_len - start) == 0 )
		return(0);		/* OK -- trivial */
	if( todo < 0 )
		return(-1);

	rp = (union record *)bu_malloc( todo * sizeof(union record), "db_zapper buf");
	bzero( (char *)rp, todo * sizeof(union record) );
	for( i=0; i < todo; i++ )
		rp[i].u_id = ID_FREE;
	i = db_put( dbip, dp, rp, start, todo );
	bu_free( (char *)rp, "db_zapper buf" );
	return i;
}

/*
 *			D B _ F L A G S _ I N T E R N A L
 *
 *  Given the internal form of a database object,
 *  return the appropriate 'flags' word for stashing in the
 *  in-memory directory of objects.
 */
int
db_flags_internal(const struct rt_db_internal *intern)
{
	const struct rt_comb_internal	*comb;

	RT_CK_DB_INTERNAL(intern);

	if( intern->idb_type != ID_COMBINATION )
		return DIR_SOLID;

	comb = (struct rt_comb_internal *)intern->idb_ptr;
	RT_CK_COMB(comb);

	if( comb->region_flag )
		return DIR_COMB | DIR_REGION;
	return DIR_COMB;
}
@


11.20
log
@change conf.h to a wrapped config.h
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db_alloc.c,v 11.19 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.19
log
@merge of ansi-6-0-branch into HEAD
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d28 5
a32 1
#include "conf.h"
@


11.18
log
@update copyright to include span through 2003
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.17 2002/08/20 17:07:57 jra Exp $ (BRL)";
d54 1
a54 4
db_alloc( dbip, dp, count )
register struct db_i	*dbip;
register struct directory *dp;
int		count;
d117 1
a117 4
db_delrec( dbip, dp, recnum )
struct db_i		*dbip;
register struct directory *dp;
int			recnum;
d137 1
a137 3
db_delete( dbip, dp )
struct db_i	*dbip;
struct directory *dp;
d182 1
a182 4
db_zapper( dbip, dp, start )
struct db_i	*dbip;
struct directory *dp;
int		start;
d222 1
a222 2
db_flags_internal( intern )
const struct rt_db_internal	*intern;
@


11.17
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1988 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.15 2001/05/17 20:05:23 morrison Exp $ (BRL)";
@


11.17.4.1
log
@sync to HEAD...
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/db_alloc.c,v 11.18 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


11.17.10.1
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.18 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


11.17.10.2
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.17.10.1 2004/02/12 18:37:38 erikg Exp $ (BRL)";
@


11.17.2.1
log
@Initial ANSIfication
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.17 2002/08/20 17:07:57 jra Exp $ (BRL)";
d54 4
a57 1
db_alloc(register struct db_i *dbip, register struct directory *dp, int count)
d120 4
a123 1
db_delrec(struct db_i *dbip, register struct directory *dp, int recnum)
d143 3
a145 1
db_delete(struct db_i *dbip, struct directory *dp)
d190 4
a193 1
db_zapper(struct db_i *dbip, struct directory *dp, int start)
d233 2
a234 1
db_flags_internal(const struct rt_db_internal *intern)
@


11.17.2.2
log
@sync branch with HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.16
log
@Converted from K&R to ANSI C - RFH
@
text
@d54 4
a57 1
db_alloc(register struct db_i *dbip, register struct directory *dp, int count)
d120 4
a123 1
db_delrec(struct db_i *dbip, register struct directory *dp, int recnum)
d143 3
a145 1
db_delete(struct db_i *dbip, struct directory *dp)
d190 4
a193 1
db_zapper(struct db_i *dbip, struct directory *dp, int start)
d233 2
a234 1
db_flags_internal(const struct rt_db_internal *intern)
@


11.15
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.14 2001/04/20 22:29:41 morrison Exp $ (BRL)";
d54 1
a54 4
db_alloc( dbip, dp, count )
register struct db_i	*dbip;
register struct directory *dp;
int		count;
d117 1
a117 4
db_delrec( dbip, dp, recnum )
struct db_i		*dbip;
register struct directory *dp;
int			recnum;
d137 1
a137 3
db_delete( dbip, dp )
struct db_i	*dbip;
struct directory *dp;
d182 1
a182 4
db_zapper( dbip, dp, start )
struct db_i	*dbip;
struct directory *dp;
int		start;
d222 1
a222 2
db_flags_internal( intern )
const struct rt_db_internal	*intern;
@


11.14
log
@CONST to const
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.13 2000/08/22 20:16:37 butler Exp $ (BRL)";
d64 1
a64 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_alloc(%s) x%x, x%x, count=%d\n",
d128 1
a128 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_delrec(%s) x%x, x%x, recnum=%d\n",
d151 1
a151 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_delete(%s) x%x, x%x\n",
d201 1
a201 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_zapper(%s) x%x, x%x, start=%d\n",
@


11.13
log
@Initialized variable
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.12 2000/07/29 23:23:04 mike Exp $ (BRL)";
d234 1
a234 1
CONST struct rt_db_internal	*intern;
d236 1
a236 1
	CONST struct rt_comb_internal	*comb;
@


11.12
log
@
Removed old v4 db_grow() and db_trunc() internal interfaces.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.11 2000/07/10 23:01:27 mike Exp $ (BRL)";
d147 1
a147 1
	register int i;
@


11.11
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@a5 2
 *	db_grow		Increase size of existing database entry
 *	db_trunc	Decrease size of existing entry, from it's end
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.10 2000/07/07 03:26:24 mike Exp $ (BRL)";
a110 125
}

/*
 *  			D B _ G R O W
 *  
 *  Increase the database size of an object by "count",
 *  by duplicating in a new area if necessary.
 *  XXX deprecated.  Only used by mged/mover.c
 *
 *  Returns:
 *	-1	on error
 *	0	on success
 */
int
db_grow( dbip, dp, count )
struct db_i	*dbip;
register struct directory *dp;
int		count;
{
	register int	i;
	union record	rec;
	union record	*rp;
	struct directory olddir;
	int		extra_start;
	int		old_len;

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	if(rt_g.debug&DEBUG_DB) bu_log("db_grow(%s) x%x, x%x, count=%d\n",
		dp->d_namep, dbip, dp, count );
	if( dp->d_flags & RT_DIR_INMEM )  bu_bomb("db_grow() called on RT_DIR_INMEM object\n");

	if( dbip->dbi_read_only )  {
		bu_log("db_grow on READ-ONLY file\n");
		return(-1);
	}

	if( count <= 0 )  {
		bu_log("db_grow(%d)\n", count );
		return(-1);
	}

	BU_ASSERT_LONG( dbip->dbi_version, ==, 4 );

	/* Easy case -- see if at end-of-file */
	old_len = dp->d_len;
	extra_start = dp->d_addr + dp->d_len * sizeof(union record);
	if( extra_start == dbip->dbi_eof )  {
		dbip->dbi_eof += count * sizeof(union record);
		dbip->dbi_nrec += count;
		dp->d_len += count;
		return( db_zapper( dbip, dp, old_len ) );

	}

	/* Try to extend into free space immediately following current obj */
	if( rt_memget( &(dbip->dbi_freep), (unsigned)count, (unsigned long)(dp->d_addr/sizeof(union record)) ) == 0L )
		goto hard;

	dp->d_len += count;
	/* Check to see if granules are all really availible (sanity check) */
	for( i=old_len; i < dp->d_len; i++ )  {
		if( db_get( dbip, dp, &rec, i, 1 ) < 0 ||
		     rec.u_id != ID_FREE )  {
			bu_log("db_grow:  FREE record wasn't?! (id%d)\n",
				rec.u_id);
		     	dp->d_len -= count;
			goto hard;
		}
	}
	return( db_zapper( dbip, dp, old_len ) );

hard:
	/*
	 *  Duplicate the records into a new area that is large enough.
	 */
	olddir = *dp;				/* struct copy */

	if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
		return(-1);
	db_alloc( dbip, dp, dp->d_len + count );	/* fixes addr & len */
	db_put( dbip, dp, rp, 0, old_len );
	bu_free( (char *)rp, "db_grow temp records");

	/* Release space that original copy consumed */
	db_delete( dbip, &olddir );
	return(0);
}

/*
 *  			D B _ T R U N C
 *  
 *  Remove "count" granules from the indicated database entry.
 *  Stomp on them with ID_FREE's.
 *  Add them to the freelist.
 */
int
db_trunc( dbip, dp, count )
struct db_i		*dbip;
register struct directory *dp;
int			 count;
{
	register int i;

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	if(rt_g.debug&DEBUG_DB) bu_log("db_trunc(%s) x%x, x%x, count=%d\n",
		dp->d_namep, dbip, dp, count );

	if( dp->d_flags & RT_DIR_INMEM )  {
		/* Decrease d_len, but don't bother with bu_realloc() */
		dp->d_len -= count;
		return 0;
	}
	if( dbip->dbi_read_only )  {
		bu_log("db_trunc on READ-ONLY file\n");
		return(-1);
	}
	BU_ASSERT_LONG( dbip->dbi_version, ==, 4 );

	i = db_zapper( dbip, dp, dp->d_len - count );
	rt_memfree( &(dbip->dbi_freep), (unsigned)count,
		(dp->d_addr/(sizeof(union record)))+dp->d_len-count );
	dp->d_len -= count;
	return(i);
@


11.10
log
@
Modified db_delete() to handle v5 databases.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.9 2000/06/29 20:24:17 mike Exp $ (BRL)";
@


11.9
log
@
Added protection against running some old routines on v5 databases.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.8 1999/12/30 02:48:00 mike Exp $ (BRL)";
d266 2
a267 1
 *  Mark all records with ID_FREE.
a286 1
	BU_ASSERT_LONG( dbip->dbi_version, ==, 4 );
d288 11
a298 4
	i = db_zapper( dbip, dp, 0 );

	rt_memfree( &(dbip->dbi_freep), (unsigned)dp->d_len,
		dp->d_addr/(sizeof(union record)) );
d302 1
a302 1
	return(i);
@


11.8
log
@
Moved db_flags_internal() into db_alloc.c
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.7 1999/12/22 02:07:37 mike Exp $ (BRL)";
d155 2
d231 2
d286 1
d328 2
@


11.7
log
@
Removed dead vars
@
text
@d10 1
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.6 1999/12/22 02:01:50 mike Exp $ (BRL)";
d336 26
@


11.6
log
@
Removed unused vars
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_alloc.c,v 11.5 1997/12/16 06:08:47 mike Exp $ (BRL)";
a246 2
	union record	*rp;
	register union record *in, *out;
@


11.5
log
@Ran h/sed4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_alloc.c,v 11.4 1997/02/06 04:18:29 mike Exp mike $ (BRL)";
a246 1
	register int	i;
@


11.4
log
@Initial RT_DIR_INMEM support
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_alloc.c,v 11.3 1997/01/29 07:34:41 mike Exp mike $ (BRL)";
d192 1
a192 1
	rt_free( (char *)rp, "db_grow temp records");
d331 1
a331 1
	rp = (union record *)rt_malloc( todo * sizeof(union record), "db_zapper buf");
d336 1
a336 1
	rt_free( (char *)rp, "db_zapper buf" );
@


11.3
log
@Dropped support for db_delrec().
It's ugly.
Use combination import/export routines instead.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_alloc.c,v 11.2 1996/09/27 08:27:30 mike Exp mike $ (BRL)";
d67 4
d72 11
a86 4
	if( count <= 0 )  {
		bu_log("db_alloc(0)\n");
		return(-1);
	}
d119 1
d142 1
d204 1
a204 1
 *  Later, we will add them to a freelist.
d219 5
d239 1
d278 7
d320 2
@


11.2
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@a7 1
 *	db_delrec	Delete a specific record from database entry
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_alloc.c,v 11.1 1995/01/04 09:56:13 mike Rel4_4 mike $ (BRL)";
d237 2
a238 25
	if( dbip->dbi_read_only )  {
		bu_log("db_delrec on READ-ONLY file\n");
		return(-1);
	}
	/* If deleting last member, just truncate */
	if( recnum == dp->d_len-1 )
		return( db_trunc( dbip, dp, 1 ) );

	/* "Ripple up" the rest of the entry */
	if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
		return(-1);
	in = out = rp;
	for( i=0; i<dp->d_len; i++ )  {
		if( i == recnum )  {
			in++;
			/* don't bump "out" */
			continue;
		}
		*out++ = *in++;		/* struct copy */
	}
	if( db_put( dbip, dp, rp, 0, dp->d_len-1 ) < 0 )
		return(-1);
	rt_free( (char *)rp, "db_delrec temp");
		
	return( db_trunc( dbip, dp, 1 ) );
@


11.1
log
@Release_4.4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_alloc.c,v 10.4 94/12/27 16:57:01 mike Exp $ (BRL)";
d66 1
a66 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_alloc(%s) x%x, x%x, count=%d\n",
d70 1
a70 1
		rt_log("db_alloc on READ-ONLY file\n");
d74 1
a74 1
		rt_log("db_alloc(0)\n");
d81 1
a81 1
				rt_log("db_alloc: bad EOF\n");
d94 1
a94 1
			rt_log("db_alloc():  addr %ld non-FREE (id %d), skipping\n",
d129 1
a129 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_grow(%s) x%x, x%x, count=%d\n",
d133 1
a133 1
		rt_log("db_grow on READ-ONLY file\n");
d138 1
a138 1
		rt_log("db_grow(%d)\n", count );
d162 1
a162 1
			rt_log("db_grow:  FREE record wasn't?! (id%d)\n",
d204 1
a204 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_trunc(%s) x%x, x%x, count=%d\n",
d208 1
a208 1
		rt_log("db_trunc on READ-ONLY file\n");
d235 1
a235 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_delrec(%s) x%x, x%x, recnum=%d\n",
d239 1
a239 1
		rt_log("db_delrec on READ-ONLY file\n");
d280 1
a280 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_delete(%s) x%x, x%x\n",
d316 1
a316 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_zapper(%s) x%x, x%x, start=%d\n",
@


10.4
log
@Fixed bug #247, added rt_ prefix to memalloc(), etc.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_alloc.c,v 10.3 94/08/25 19:50:59 mike Exp Locker: mike $ (BRL)";
@


10.3
log
@Improved arg checking.
Eliminated memory leak in db_zapper().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_alloc.c,v 10.2 94/08/10 15:40:57 gdurf Exp Locker: mike $ (BRL)";
d78 1
a78 1
		if( (addr = memalloc( &(dbip->dbi_freep), (unsigned)count )) == 0L )  {
d154 1
a154 1
	if( memget( &(dbip->dbi_freep), (unsigned)count, (unsigned long)(dp->d_addr/sizeof(union record)) ) == 0L )
d212 1
a212 1
	memfree( &(dbip->dbi_freep), (unsigned)count,
d285 1
a285 1
	memfree( &(dbip->dbi_freep), (unsigned)dp->d_len,
@


10.2
log
@Factored ifdefs
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_alloc.c,v 10.1 1991/10/12 06:40:00 mike Rel4_0 gdurf $ (BRL)";
d64 2
a65 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_alloc:  bad dbip\n");
d127 2
a128 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_grow:  bad dbip\n");
d202 2
a203 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_trunc:  bad dbip\n");
d233 2
a234 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_delrec:  bad dbip\n");
d278 2
a279 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_delete:  bad dbip\n");
d314 2
a315 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_zapper:  bad dbip\n");
d331 3
a333 1
	return( db_put( dbip, dp, rp, start, todo ) );
@


10.1
log
@Release_4.0
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_alloc.c,v 9.2 90/12/11 22:03:25 mike Exp $ (BRL)";
d30 2
d33 3
a35 1
#ifdef BSD
a36 2
#else
#include <string.h>
@


9.2
log
@For lint purposes, #include db.h must preceed #include machine.h,
so that union record is known.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_alloc.c,v 9.1 89/05/19 05:55:38 mike Rel3_5 $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: db_alloc.c,v 1.2 89/03/15 15:36:20 mike Exp $ (BRL)";
d39 1
a40 1
#include "db.h"
@


1.2
log
@unused var
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: db_alloc.c,v 1.1 88/12/06 00:09:07 mike Locked $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/libdb/RCS/alloc.c,v 1.5 88/10/23 13:54:29 mike Exp $ (BRL)";
d55 1
a55 1
struct db_i	*dbip;
a58 1
	register int	i;
@
