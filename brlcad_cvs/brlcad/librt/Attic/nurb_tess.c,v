head	1.13;
access;
symbols
	ansi-20040405-merged:1.9.2.2
	postmerge-20040405-ansi:1.11
	premerge-20040404-ansi:1.10
	postmerge-autoconf:1.10
	autoconf-freeze:1.9.10.1
	premerge-autoconf:1.10
	ansi-20040316-freeze:1.9.2.1
	postmerge-20040315-windows:1.10
	premerge-20040315-windows:1.10
	windows-20040315-freeze:1.9.4.1
	autoconf-20031203:1.9
	autoconf-20031202:1.9
	autoconf-branch:1.9.0.10
	phong-branch:1.9.0.8
	photonmap-branch:1.9.0.6
	rel-6-1-DP:1.9
	windows-branch:1.9.0.4
	rel-6-0-2:1.7
	ansi-branch:1.9.0.2
	rel-6-0-1-branch:1.7.0.2
	hartley-6-0-post:1.8
	hartley-6-0-pre:1.7
	rel-6-0-1:1.7
	rel-6-0:1.7
	rel-5-4:1.6
	offsite-5-3-pre:1.6
	rel-5-3:1.6
	rel-5-2:1.6
	rel-5-1-branch:1.6.0.2
	rel-5-1:1.6
	rel-5-0:1.3
	rel-5-0-beta:1.3
	rel-4-5:1.3
	ctj-4-5-post:1.2
	ctj-4-5-pre:1.2;
locks; strict;
comment	@ * @;


1.13
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	1.12;

1.12
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.20.17.08.08;	author jra;	state Exp;
branches
	1.9.2.1
	1.9.4.1
	1.9.10.1;
next	1.8;

1.8
date	2002.08.15.20.55.20;	author hartley;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.20.22.29.55;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	99.12.30.16.02.44;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	99.12.30.14.23.16;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	99.12.22.02.24.07;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	95.12.01.02.49.33;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	95.05.05.13.04.15;	author stay;	state Exp;
branches;
next	;

1.9.2.1
date	2002.09.19.18.01.45;	author morrison;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2004.03.17.21.18.56;	author morrison;	state Exp;
branches;
next	;

1.9.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

1.9.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	;


desc
@calculate the shortest edge lenght for a give epsilon
for a nurb surface, edge lenght is in parameter space
@


1.13
log
@moved to src/
@
text
@/*	N U R B  _ T E S S . C
 *
 *  Function -
 *	Given Epsilon, compute the number of internal knots to
 *	add so that every triangle generated in parametric space
 *	is within epsilon of the original surface.
 *
 *  Author -
 *	Paul Randal Stay
 * 
 *  Source -
 * 	SECAD/VLD Computing Consortium, Bldg 394
 *	The U.S. Army Ballistic Research Laboratory
 * 	Aberdeen Proving Ground, Maryland 21005
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "nurb.h"

/* Algorithm -
 *
 * See paper in Computer Aided Design (CAD) Volumne 27, Number 1, January 1995
 *	TESSELATING TRIMMMED NURBS SURFACES, Leslie A Piegl and Arnaud Richard.
 *
 * There is a slight deviation from the paper, Since libnurb (rt_nurb_s_diff) 
 * differentiation correctly handles rational surfaces, no special processing for
 * rational is needed. 
 *
 * The idea is to compute the longest edge size in parametric space such that
 * a the edge (or curve) in real space is within epsilon tolerance. The mapping
 * from parametric space is done as a separate step.
 * 
 */

fastf_t
rt_nurb_par_edge(const struct face_g_snurb *srf, fastf_t epsilon)
{
	struct face_g_snurb * us, *vs, * uus, * vvs, *uvs;
	fastf_t d1,d2,d3;
	int i;
	fastf_t *pt;
	

	us = rt_nurb_s_diff(srf, RT_NURB_SPLIT_ROW);
	vs = rt_nurb_s_diff(srf, RT_NURB_SPLIT_COL);
	uus = rt_nurb_s_diff(us, RT_NURB_SPLIT_ROW);
	vvs = rt_nurb_s_diff(vs, RT_NURB_SPLIT_COL);
	uvs = rt_nurb_s_diff(vs, RT_NURB_SPLIT_ROW);

	d1 = 0.0;
	d2 = 0.0;
	d3 = 0.0;
	
	pt = (fastf_t *) uus->ctl_points;

	/* Find the maximum value of the 2nd derivative in U */

	for( i = 0; i < uus->s_size[0] * uus->s_size[1]; i++)
	{
		fastf_t mag;

		mag = MAGNITUDE( pt );
		
		if ( mag > d1) d1 = mag;

		pt += RT_NURB_EXTRACT_COORDS(uus->pt_type);

	}

	/* Find the maximum value of the partial derivative in UV */

	pt = (fastf_t *) uvs->ctl_points;

	for( i = 0; i < uvs->s_size[0] * uvs->s_size[1]; i++)
	{
		fastf_t mag;

		mag = MAGNITUDE( pt );
		
		if ( mag > d2) d2 = mag;

		pt += RT_NURB_EXTRACT_COORDS(uvs->pt_type);

	}


	/* Find the maximum value of the 2nd derivative in V */
	pt = (fastf_t *) vvs->ctl_points;

	for( i = 0; i < vvs->s_size[0] * vvs->s_size[1]; i++)
	{
		fastf_t mag;

		mag = MAGNITUDE( pt );
		
		if ( mag > d3) d3 = mag;

		pt += RT_NURB_EXTRACT_COORDS(vvs->pt_type);

	}

	/* free up storage */

        rt_nurb_free_snurb( us, (struct resource *)NULL);
        rt_nurb_free_snurb( vs, (struct resource *)NULL);
        rt_nurb_free_snurb( uus, (struct resource *)NULL);
        rt_nurb_free_snurb( vvs, (struct resource *)NULL);
        rt_nurb_free_snurb( uvs, (struct resource *)NULL);


	/* The paper uses the following to calculate the longest edge size
  	 *			  	  1/2
	 *  3.0 * (			)
	 *	  (	   2.0		)
	 *	  _________________________
	 *	  (2.0 * (d1 + 2 D2 + d3)
 	 */

	return ( 3.0 * sqrt( epsilon / (2.0*(d1 + (2.0 * d2)+ d3))));
}

/*
 *		R T _ C N U R B _ P A R _ E D G E
 *
 *	Calculate the maximum edge length (in parameter space)
 *	that will keep the curve approximation within epsilon
 *	of the true curve
 *
 *	This is a temporary guess until legitimate code can be found
 *
 *	returns:
 *		-1.0 if the curve is a straight line
 *		maximum parameter increment otherwise
 */
fastf_t
rt_cnurb_par_edge(const struct edge_g_cnurb *crv, fastf_t epsilon)
{
	struct edge_g_cnurb *d1, *d2;
	fastf_t der2[5], t, *pt;
	fastf_t num_coord_factor, final_t;
	int num_coords;
	int i,j;

	if( crv->order < 3)
		return( -1.0 );

	num_coords = RT_NURB_EXTRACT_COORDS( crv->pt_type );
	if( num_coords > 5 )
	{
		bu_log( "ERROR: rt_cnurb_par_edge() cannot handle curves with more than 5 coordinates (curve has %d)\n",
			num_coords );
		bu_bomb( "ERROR: rt_cnurb_par_edge() cannot handle curves with more than 5 coordinates\n" );
	}

	for( i=0 ; i<num_coords ; i++ )
	{
		der2[i] = 0.0;
	}

	final_t = MAX_FASTF;
	num_coord_factor = sqrt( (double)num_coords );

	d1 = rt_nurb_c_diff( crv );
	d2 = rt_nurb_c_diff( d1 );

#if 0
	pt = d1->ctl_points;
	for( i=0 ; i<d1->c_size ; i++ )
	{
		for( j=0 ; j<num_coords ; j++ )
		{
			fastf_t abs_val;

			abs_val = *pt > 0.0 ? *pt : -(*pt);
			if( abs_val > der1[j] )
				der1[j] = abs_val;
			pt++;
		}
	}
#endif
	pt = d2->ctl_points;
	for( i=0 ; i<d2->c_size ; i++ )
	{
		for( j=0 ; j<num_coords ; j++ )
		{
			fastf_t abs_val;

			abs_val = *pt > 0.0 ? *pt : -(*pt);
			if( abs_val > der2[j] )
				der2[j] = abs_val;
			pt++;
		}
	}

	rt_nurb_free_cnurb( d1 );
	rt_nurb_free_cnurb( d2 );

	for( j=0 ; j<num_coords ; j++ )
	{
		if( NEAR_ZERO( der2[j], SMALL_FASTF ) )
			continue;

		t = sqrt( 2.0 * epsilon / (num_coord_factor * der2[j] ) );
		if( t < final_t )
			final_t = t;
	}

	if( final_t == MAX_FASTF )
		return( -1.0 );
	else
		return( final_t/2.0 );
}
@


1.12
log
@change conf.h to a wrapped config.h
@
text
@@


1.11
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 5
a25 1
#include "conf.h"
@


1.10
log
@update copyright to include span through 2003
@
text
@d47 1
a47 3
rt_nurb_par_edge(srf, epsilon)
const struct face_g_snurb * srf;
fastf_t epsilon;
d147 1
a147 3
rt_cnurb_par_edge( crv, epsilon )
const struct edge_g_cnurb *crv;
fastf_t epsilon;
@


1.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1990 by the United States Army.
@


1.9.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


1.9.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


1.9.2.1
log
@Initial ANSIfication
@
text
@d47 3
a49 1
rt_nurb_par_edge(const struct face_g_snurb *srf, fastf_t epsilon)
d149 3
a151 1
rt_cnurb_par_edge(const struct edge_g_cnurb *crv, fastf_t epsilon)
@


1.9.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
@


1.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d47 3
a49 1
rt_nurb_par_edge(const struct face_g_snurb *srf, fastf_t epsilon)
d149 3
a151 1
rt_cnurb_par_edge(const struct edge_g_cnurb *crv, fastf_t epsilon)
@


1.7
log
@CONST to const
@
text
@d47 1
a47 3
rt_nurb_par_edge(srf, epsilon)
const struct face_g_snurb * srf;
fastf_t epsilon;
d147 1
a147 3
rt_cnurb_par_edge( crv, epsilon )
const struct edge_g_cnurb *crv;
fastf_t epsilon;
@


1.6
log
@Eliminated some unused variables
@
text
@d48 1
a48 1
CONST struct face_g_snurb * srf;
d150 1
a150 1
CONST struct edge_g_cnurb *crv;
@


1.5
log
@More stuff for the sketch and extrusion solids
@
text
@d154 1
a154 1
	fastf_t der1[5], der2[5], t, *pt;
a171 1
		der1[i] = 0.0;
a214 2
		fastf_t tmp, sqrt_tmp;

@


1.4
log
@
Removed dead vars
@
text
@d135 96
@


1.3
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d53 1
a53 1
	int i,j;
@


1.2
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d117 5
a121 5
        rt_nurb_free_snurb( us);
        rt_nurb_free_snurb( vs);
        rt_nurb_free_snurb( uus);
        rt_nurb_free_snurb( vvs);
        rt_nurb_free_snurb( uvs);
@


1.1
log
@Initial revision
@
text
@d48 1
a48 1
CONST struct snurb * srf;
d51 1
a51 1
	struct snurb * us, *vs, * uus, * vvs, *uvs;
@
