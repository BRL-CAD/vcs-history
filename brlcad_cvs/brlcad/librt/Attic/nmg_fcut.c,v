head	11.42;
access;
symbols
	ansi-20040405-merged:11.38.2.2
	postmerge-20040405-ansi:11.40
	premerge-20040404-ansi:11.39
	postmerge-autoconf:11.39
	autoconf-freeze:11.38.10.2
	premerge-autoconf:11.39
	ansi-20040316-freeze:11.38.2.1
	postmerge-20040315-windows:11.39
	premerge-20040315-windows:11.39
	windows-20040315-freeze:11.38.4.1
	autoconf-20031203:11.38
	autoconf-20031202:11.38
	autoconf-branch:11.38.0.10
	phong-branch:11.38.0.8
	photonmap-branch:11.38.0.6
	rel-6-1-DP:11.38
	windows-branch:11.38.0.4
	rel-6-0-2:11.36
	ansi-branch:11.38.0.2
	rel-6-0-1-branch:11.36.0.2
	hartley-6-0-post:11.37
	hartley-6-0-pre:11.36
	rel-6-0-1:11.36
	rel-6-0:11.35
	rel-5-4:11.29
	offsite-5-3-pre:11.33
	rel-5-3:11.29
	rel-5-2:11.29
	rel-5-1-branch:11.29.0.2
	rel-5-1:11.29
	rel-5-0:11.28
	rel-5-0-beta:11.26
	rel-4-5:11.24
	ctj-4-5-post:11.24
	ctj-4-5-pre:11.23
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.42
date	2004.05.21.18.07.32;	author morrison;	state dead;
branches;
next	11.41;

11.41
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.40;

11.40
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.39;

11.39
date	2004.02.02.17.39.22;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2002.08.20.17.08.03;	author jra;	state Exp;
branches
	11.38.2.1
	11.38.4.1
	11.38.10.1;
next	11.37;

11.37
date	2002.08.15.20.55.14;	author hartley;	state Exp;
branches;
next	11.36;

11.36
date	2002.05.12.03.49.42;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	2001.05.17.20.05.25;	author morrison;	state Exp;
branches;
next	11.34;

11.34
date	2001.04.20.22.29.49;	author morrison;	state Exp;
branches;
next	11.33;

11.33
date	2000.10.19.19.19.46;	author butler;	state Exp;
branches;
next	11.32;

11.32
date	2000.08.29.03.47.09;	author butler;	state Exp;
branches;
next	11.31;

11.31
date	2000.08.21.02.02.32;	author butler;	state Exp;
branches;
next	11.30;

11.30
date	2000.07.10.23.01.39;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	99.12.30.15.33.12;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	99.06.03.01.57.01;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	99.06.03.01.39.14;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	99.05.11.19.08.22;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	98.03.09.15.19.53;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	97.08.29.15.31.46;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	97.07.11.14.57.51;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	96.12.19.14.04.07;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	96.07.12.12.17.41;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	96.07.02.14.25.46;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	96.05.29.12.43.46;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	96.05.16.21.58.46;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	96.04.30.20.34.02;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	96.04.26.15.03.23;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	96.04.22.12.11.14;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	96.03.28.14.28.44;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	96.03.25.21.14.53;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	96.03.18.00.12.24;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	96.03.05.21.29.07;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	95.09.06.13.08.36;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	95.08.30.12.16.01;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	95.06.20.02.38.28;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.06.17.03.09.29;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.05.11.18.52.15;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.03.05.21.24.06;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.02.10.16.24.25;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.02.07.03.56.55;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.30;	author mike;	state Rel4_4;
branches;
next	10.138;

10.138
date	94.12.27.15.55.48;	author mike;	state Exp;
branches;
next	10.137;

10.137
date	94.11.04.06.56.55;	author mike;	state Exp;
branches;
next	10.136;

10.136
date	94.09.16.20.45.24;	author mike;	state Exp;
branches;
next	10.135;

10.135
date	94.09.16.20.20.53;	author mike;	state Exp;
branches;
next	10.134;

10.134
date	94.09.10.04.36.38;	author mike;	state Exp;
branches;
next	10.133;

10.133
date	94.09.03.03.01.13;	author mike;	state Exp;
branches;
next	10.132;

10.132
date	94.08.09.19.37.30;	author mike;	state Exp;
branches;
next	10.131;

10.131
date	94.07.07.14.04.37;	author mike;	state Exp;
branches;
next	10.130;

10.130
date	94.07.06.21.27.20;	author mike;	state Exp;
branches;
next	10.129;

10.129
date	94.07.06.21.07.59;	author mike;	state Exp;
branches;
next	10.128;

10.128
date	94.07.06.20.36.17;	author mike;	state Exp;
branches;
next	10.127;

10.127
date	94.07.06.19.13.47;	author mike;	state Exp;
branches;
next	10.126;

10.126
date	94.07.06.16.49.58;	author mike;	state Exp;
branches;
next	10.125;

10.125
date	94.07.02.02.21.12;	author mike;	state Exp;
branches;
next	10.124;

10.124
date	94.07.02.00.32.30;	author mike;	state Exp;
branches;
next	10.123;

10.123
date	94.07.01.23.55.43;	author mike;	state Exp;
branches;
next	10.122;

10.122
date	94.07.01.16.12.06;	author mike;	state Exp;
branches;
next	10.121;

10.121
date	94.07.01.16.07.54;	author mike;	state Exp;
branches;
next	10.120;

10.120
date	94.06.30.22.34.32;	author mike;	state Exp;
branches;
next	10.119;

10.119
date	94.06.30.19.23.43;	author mike;	state Exp;
branches;
next	10.118;

10.118
date	94.04.25.03.10.18;	author mike;	state Exp;
branches;
next	10.117;

10.117
date	94.04.24.18.27.48;	author mike;	state Exp;
branches;
next	10.116;

10.116
date	94.04.23.12.26.25;	author mike;	state Exp;
branches;
next	10.115;

10.115
date	94.04.23.07.54.57;	author mike;	state Exp;
branches;
next	10.114;

10.114
date	94.04.22.10.48.46;	author mike;	state Exp;
branches;
next	10.113;

10.113
date	94.04.19.16.19.44;	author mike;	state Exp;
branches;
next	10.112;

10.112
date	94.04.19.02.48.57;	author butler;	state Exp;
branches;
next	10.111;

10.111
date	94.04.18.07.07.37;	author mike;	state Exp;
branches;
next	10.110;

10.110
date	94.04.17.19.34.16;	author mike;	state Exp;
branches;
next	10.109;

10.109
date	94.04.15.11.49.12;	author mike;	state Exp;
branches;
next	10.108;

10.108
date	94.04.15.08.45.00;	author mike;	state Exp;
branches;
next	10.107;

10.107
date	94.04.14.07.29.01;	author mike;	state Exp;
branches;
next	10.106;

10.106
date	94.03.11.21.40.58;	author mike;	state Exp;
branches;
next	10.105;

10.105
date	94.03.11.20.51.08;	author mike;	state Exp;
branches;
next	10.104;

10.104
date	94.03.09.22.06.32;	author mike;	state Exp;
branches;
next	10.103;

10.103
date	94.03.04.23.17.58;	author mike;	state Exp;
branches;
next	10.102;

10.102
date	94.02.22.21.27.37;	author mike;	state Exp;
branches;
next	10.101;

10.101
date	94.02.02.00.12.29;	author mike;	state Exp;
branches;
next	10.100;

10.100
date	94.01.22.21.32.30;	author mike;	state Exp;
branches;
next	10.99;

10.99
date	94.01.22.02.15.10;	author mike;	state Exp;
branches;
next	10.98;

10.98
date	94.01.15.00.26.52;	author mike;	state Exp;
branches;
next	10.97;

10.97
date	93.12.22.06.11.39;	author mike;	state Exp;
branches;
next	10.96;

10.96
date	93.12.03.03.35.22;	author mike;	state Exp;
branches;
next	10.95;

10.95
date	93.11.19.02.36.26;	author mike;	state Exp;
branches;
next	10.94;

10.94
date	93.11.19.02.24.33;	author mike;	state Exp;
branches;
next	10.93;

10.93
date	93.11.18.02.09.12;	author mike;	state Exp;
branches;
next	10.92;

10.92
date	93.11.17.19.01.55;	author mike;	state Exp;
branches;
next	10.91;

10.91
date	93.11.12.21.39.47;	author mike;	state Exp;
branches;
next	10.90;

10.90
date	93.11.09.19.36.12;	author butler;	state Exp;
branches;
next	10.89;

10.89
date	93.10.27.19.32.11;	author mike;	state Exp;
branches;
next	10.88;

10.88
date	93.10.23.07.18.43;	author mike;	state Exp;
branches;
next	10.87;

10.87
date	93.10.22.22.27.56;	author mike;	state Exp;
branches;
next	10.86;

10.86
date	93.10.18.23.45.10;	author mike;	state Exp;
branches;
next	10.85;

10.85
date	93.10.18.20.09.29;	author mike;	state Exp;
branches;
next	10.84;

10.84
date	93.10.18.19.41.12;	author mike;	state Exp;
branches;
next	10.83;

10.83
date	93.10.01.20.32.49;	author mike;	state Exp;
branches;
next	10.82;

10.82
date	93.10.01.20.08.57;	author mike;	state Exp;
branches;
next	10.81;

10.81
date	93.09.15.02.35.04;	author mike;	state Exp;
branches;
next	10.80;

10.80
date	93.09.10.23.19.16;	author mike;	state Exp;
branches;
next	10.79;

10.79
date	93.09.09.00.15.05;	author mike;	state Exp;
branches;
next	10.78;

10.78
date	93.09.07.09.22.52;	author jra;	state Exp;
branches;
next	10.77;

10.77
date	93.08.27.21.19.24;	author mike;	state Exp;
branches;
next	10.76;

10.76
date	93.08.27.04.53.18;	author mike;	state Exp;
branches;
next	10.75;

10.75
date	93.08.19.01.07.48;	author mike;	state Exp;
branches;
next	10.74;

10.74
date	93.08.19.00.45.09;	author mike;	state Exp;
branches;
next	10.73;

10.73
date	93.07.20.22.47.37;	author mike;	state Exp;
branches;
next	10.72;

10.72
date	93.07.20.21.21.58;	author mike;	state Exp;
branches;
next	10.71;

10.71
date	93.05.21.02.02.44;	author mike;	state Exp;
branches;
next	10.70;

10.70
date	93.05.20.19.42.17;	author mike;	state Exp;
branches;
next	10.69;

10.69
date	93.05.14.01.37.18;	author mike;	state Exp;
branches;
next	10.68;

10.68
date	93.05.08.07.46.55;	author mike;	state Exp;
branches;
next	10.67;

10.67
date	93.05.08.01.31.15;	author mike;	state Exp;
branches;
next	10.66;

10.66
date	93.05.07.20.30.11;	author mike;	state Exp;
branches;
next	10.65;

10.65
date	93.05.07.05.20.35;	author mike;	state Exp;
branches;
next	10.64;

10.64
date	93.05.07.04.40.42;	author mike;	state Exp;
branches;
next	10.63;

10.63
date	93.05.05.05.26.20;	author mike;	state Exp;
branches;
next	10.62;

10.62
date	93.05.05.04.52.53;	author mike;	state Exp;
branches;
next	10.61;

10.61
date	93.04.09.04.10.14;	author mike;	state Exp;
branches;
next	10.60;

10.60
date	93.04.08.03.32.02;	author mike;	state Exp;
branches;
next	10.59;

10.59
date	93.04.07.06.34.48;	author mike;	state Exp;
branches;
next	10.58;

10.58
date	93.03.26.23.39.19;	author mike;	state Exp;
branches;
next	10.57;

10.57
date	93.03.26.22.41.05;	author mike;	state Exp;
branches;
next	10.56;

10.56
date	93.03.24.03.21.01;	author mike;	state Exp;
branches;
next	10.55;

10.55
date	93.03.24.02.41.24;	author mike;	state Exp;
branches;
next	10.54;

10.54
date	93.03.22.15.44.55;	author mike;	state Exp;
branches;
next	10.53;

10.53
date	93.03.17.05.17.43;	author mike;	state Exp;
branches;
next	10.52;

10.52
date	93.03.17.05.03.28;	author mike;	state Exp;
branches;
next	10.51;

10.51
date	93.03.17.04.47.24;	author mike;	state Exp;
branches;
next	10.50;

10.50
date	93.03.15.21.12.15;	author mike;	state Exp;
branches;
next	10.49;

10.49
date	93.03.13.01.47.11;	author mike;	state Exp;
branches;
next	10.48;

10.48
date	93.03.10.22.29.16;	author mike;	state Exp;
branches;
next	10.47;

10.47
date	93.03.08.21.42.41;	author mike;	state Exp;
branches;
next	10.46;

10.46
date	93.02.25.04.27.38;	author mike;	state Exp;
branches;
next	10.45;

10.45
date	93.02.25.03.51.44;	author mike;	state Exp;
branches;
next	10.44;

10.44
date	93.02.19.04.46.21;	author mike;	state Exp;
branches;
next	10.43;

10.43
date	93.02.18.06.12.07;	author mike;	state Exp;
branches;
next	10.42;

10.42
date	93.02.10.03.03.56;	author mike;	state Exp;
branches;
next	10.41;

10.41
date	93.01.22.22.06.42;	author mike;	state Exp;
branches;
next	10.40;

10.40
date	93.01.20.21.52.14;	author mike;	state Exp;
branches;
next	10.39;

10.39
date	93.01.20.15.26.58;	author mike;	state Exp;
branches;
next	10.38;

10.38
date	92.12.16.06.30.27;	author mike;	state Exp;
branches;
next	10.37;

10.37
date	92.12.14.23.01.18;	author mike;	state Exp;
branches;
next	10.36;

10.36
date	92.11.16.23.24.54;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	92.11.11.00.07.13;	author mike;	state Exp;
branches;
next	10.34;

10.34
date	92.10.20.00.43.51;	author mike;	state Exp;
branches;
next	10.33;

10.33
date	92.10.16.00.09.52;	author mike;	state Exp;
branches;
next	10.32;

10.32
date	92.10.07.06.51.35;	author mike;	state Exp;
branches;
next	10.31;

10.31
date	92.10.06.23.12.52;	author mike;	state Exp;
branches;
next	10.30;

10.30
date	92.10.06.18.28.57;	author mike;	state Exp;
branches;
next	10.29;

10.29
date	92.08.07.00.28.23;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	92.08.06.20.50.55;	author mike;	state Exp;
branches;
next	10.27;

10.27
date	92.08.06.00.40.14;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	92.08.05.22.32.04;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	92.08.05.16.16.35;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	92.07.25.07.13.34;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	92.07.23.05.51.39;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	92.07.23.01.08.17;	author mike;	state Exp;
branches;
next	10.21;

10.21
date	92.07.22.23.35.31;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	92.07.22.22.17.24;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	92.07.22.21.45.44;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	92.07.22.21.37.34;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	92.07.22.20.28.13;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	92.07.22.04.31.50;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	92.07.22.02.29.33;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	92.07.22.00.52.07;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	92.07.21.23.47.13;	author butler;	state Exp;
branches;
next	10.12;

10.12
date	92.03.09.16.12.41;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	92.03.06.13.40.55;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	92.03.06.07.54.54;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	92.03.06.05.10.25;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.03.06.03.02.35;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.03.05.07.43.29;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.03.05.04.16.04;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.03.03.15.20.22;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.02.29.03.17.31;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.02.25.00.06.15;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.02.21.01.30.41;	author butler;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.42;	author mike;	state Rel4_0;
branches;
next	2.34;

2.34
date	91.09.25.02.15.27;	author butler;	state Exp;
branches;
next	2.33;

2.33
date	91.08.29.22.33.27;	author mike;	state Exp;
branches;
next	2.32;

2.32
date	91.07.24.20.38.47;	author mike;	state Exp;
branches;
next	2.31;

2.31
date	91.07.19.02.38.27;	author mike;	state Exp;
branches;
next	2.30;

2.30
date	91.07.02.23.16.40;	author butler;	state Exp;
branches;
next	2.29;

2.29
date	91.06.29.22.13.59;	author mike;	state Exp;
branches;
next	2.28;

2.28
date	91.06.22.20.10.52;	author butler;	state Exp;
branches;
next	2.27;

2.27
date	91.06.17.20.41.59;	author butler;	state Exp;
branches;
next	2.26;

2.26
date	91.05.30.11.21.37;	author mike;	state Exp;
branches;
next	2.25;

2.25
date	91.05.25.03.30.56;	author mike;	state Exp;
branches;
next	2.24;

2.24
date	91.05.24.19.59.44;	author mike;	state Exp;
branches;
next	2.23;

2.23
date	91.05.24.18.59.57;	author mike;	state Exp;
branches;
next	2.22;

2.22
date	91.04.04.00.53.12;	author mike;	state Exp;
branches;
next	2.21;

2.21
date	91.04.04.00.14.07;	author mike;	state Exp;
branches;
next	2.20;

2.20
date	91.04.03.23.34.18;	author mike;	state Exp;
branches;
next	2.19;

2.19
date	91.04.03.22.35.20;	author mike;	state Exp;
branches;
next	2.18;

2.18
date	91.04.03.21.54.41;	author mike;	state Exp;
branches;
next	2.17;

2.17
date	91.04.03.21.23.11;	author mike;	state Exp;
branches;
next	2.16;

2.16
date	91.04.03.21.20.05;	author mike;	state Exp;
branches;
next	2.15;

2.15
date	91.04.03.20.31.38;	author mike;	state Exp;
branches;
next	2.14;

2.14
date	91.04.03.20.28.23;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	91.04.03.03.38.30;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	91.04.03.01.15.24;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	91.04.03.00.43.16;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	91.04.02.21.29.32;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	91.04.02.20.27.50;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	91.04.02.18.46.42;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	91.04.02.04.12.24;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	91.04.02.01.59.58;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	91.04.01.23.14.17;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	91.04.01.20.43.38;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	91.04.01.20.04.54;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	91.03.30.20.40.07;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	91.03.30.05.40.03;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	91.03.28.01.15.33;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	91.03.28.01.03.35;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	91.03.26.00.51.04;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	91.03.25.22.12.23;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	91.03.02.01.27.32;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	91.03.02.00.17.38;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.02.08.02.49.24;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.02.07.20.32.33;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.01.12.07.23.18;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.12.08.03.34.06;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.12.08.03.25.59;	author mike;	state Exp;
branches;
next	;

11.38.2.1
date	2002.09.19.18.01.38;	author morrison;	state Exp;
branches;
next	11.38.2.2;

11.38.2.2
date	2004.03.17.21.18.52;	author morrison;	state Exp;
branches;
next	;

11.38.4.1
date	2004.03.11.23.43.40;	author morrison;	state Exp;
branches;
next	;

11.38.10.1
date	2004.02.12.18.37.43;	author erikg;	state Exp;
branches;
next	11.38.10.2;

11.38.10.2
date	2004.03.15.14.07.24;	author erikg;	state Exp;
branches;
next	;


desc
@NMG combine loops code
@


11.42
log
@moved to src/
@
text
@#define PLOT_BOTH_FACES	1
/*
 *			N M G _ F C U T . C
 *
 *  After two faces have been intersected, cut or join loops crossed
 *  by the line of intersection.  (Formerly nmg_comb.c)
 *
 *  The main external routine here is nmg_face_cutjoin().
 *
 *  The line of intersection ("ray") will divide the face into two sets
 *  of loops.
 *  No one loop may cross the ray after this routine is finished.
 *  (Current optimization may remove this property).
 *
 *  Intersection points of significance to the other face but not yet
 *  part of the current face's geometry are denoted by a vu on the ray
 *  list, which points to a loop of a single vertex.  These points
 *  need to be incorporated into the final face.
 *
 *  Authors -
 *	Michael John Muuss
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_fcut.c,v 11.41 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <string.h>
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"



/* States of the state machine */
#define NMG_STATE_ERROR		0
#define NMG_STATE_OUT		1
#define NMG_STATE_ON_L		2
#define NMG_STATE_ON_R		3
#define NMG_STATE_ON_B		4
#define NMG_STATE_ON_N		5
#define NMG_STATE_IN		6
static const char *nmg_state_names[] = {
	"*ERROR*",
	"out",
	"on_L",
	"on_R",
	"on_both",		/* "hole" crack */
	"on_neither",		/* "non-hole" crack */
	"in",
	"TOOBIG"
};

#define NMG_E_ASSESSMENT_LEFT		0
#define NMG_E_ASSESSMENT_RIGHT		1
#define NMG_E_ASSESSMENT_ON_FORW	2
#define NMG_E_ASSESSMENT_ON_REV		3
#define NMG_E_ASSESSMENT_ERROR		4	/* risky */

#define NMG_V_ASSESSMENT_LONE		16
#define NMG_V_ASSESSMENT_ERROR		17
#define NMG_V_COMB(_p,_n)	(((_p)<<2)|(_n))

/* Extract previous and next assessments from combined version */
#define NMG_V_ASSESSMENT_PREV(_a)	(((_a)>>2)&3)
#define NMG_V_ASSESSMENT_NEXT(_a)	((_a)&3)

static const char *nmg_v_assessment_names[32] = {
	"Left,Left",
	"Left,Right",
	"Left,On_Forw",
	"Left,On_Rev",
	"Right,Left",
	"Right,Right",
	"Right,On_Forw",
	"Right,On_Rev",
	"On_Forw,Left",
	"On_Forw,Right",
	"On_Forw,On_Forw",
	"On_Forw,On_Rev",
	"On_Rev,Left",
	"On_Rev,Right",
	"On_Rev,On_Forw",
	"On_Rev,On_Rev",
	"LONE_V",		/* 16 */
	"V_ERROR",		/* 17 */
	"?18",
	"?19",
	"?20",
	"?21",
	"?22",
	"?23",
	"?24",
	"?25",
	"?26",
	"?27",
	"?28",
	"?29",
	"?30",
	"?31"
};
#define NMG_LEFT_LEFT	NMG_V_COMB(NMG_E_ASSESSMENT_LEFT,NMG_E_ASSESSMENT_LEFT)
#define NMG_LEFT_RIGHT	NMG_V_COMB(NMG_E_ASSESSMENT_LEFT,NMG_E_ASSESSMENT_RIGHT)
#define NMG_LEFT_ON_FORW NMG_V_COMB(NMG_E_ASSESSMENT_LEFT,NMG_E_ASSESSMENT_ON_FORW)
#define NMG_LEFT_ON_REV	NMG_V_COMB(NMG_E_ASSESSMENT_LEFT,NMG_E_ASSESSMENT_ON_REV)
#define NMG_RIGHT_LEFT	NMG_V_COMB(NMG_E_ASSESSMENT_RIGHT,NMG_E_ASSESSMENT_LEFT)
#define NMG_RIGHT_RIGHT	NMG_V_COMB(NMG_E_ASSESSMENT_RIGHT,NMG_E_ASSESSMENT_RIGHT)
#define NMG_RIGHT_ON_FORW NMG_V_COMB(NMG_E_ASSESSMENT_RIGHT,NMG_E_ASSESSMENT_ON_FORW)
#define NMG_RIGHT_ON_REV NMG_V_COMB(NMG_E_ASSESSMENT_RIGHT,NMG_E_ASSESSMENT_ON_REV)
#define NMG_ON_FORW_LEFT NMG_V_COMB(NMG_E_ASSESSMENT_ON_FORW,NMG_E_ASSESSMENT_LEFT)
#define NMG_ON_FORW_RIGHT NMG_V_COMB(NMG_E_ASSESSMENT_ON_FORW,NMG_E_ASSESSMENT_RIGHT)
#define NMG_ON_FORW_ON_FORW NMG_V_COMB(NMG_E_ASSESSMENT_ON_FORW,NMG_E_ASSESSMENT_ON_FORW)
#define NMG_ON_FORW_ON_REV NMG_V_COMB(NMG_E_ASSESSMENT_ON_FORW,NMG_E_ASSESSMENT_ON_REV)
#define NMG_ON_REV_LEFT	NMG_V_COMB(NMG_E_ASSESSMENT_ON_REV,NMG_E_ASSESSMENT_LEFT)
#define NMG_ON_REV_RIGHT NMG_V_COMB(NMG_E_ASSESSMENT_ON_REV,NMG_E_ASSESSMENT_RIGHT)
#define NMG_ON_REV_ON_FORW NMG_V_COMB(NMG_E_ASSESSMENT_ON_REV,NMG_E_ASSESSMENT_ON_FORW)
#define NMG_ON_REV_ON_REV NMG_V_COMB(NMG_E_ASSESSMENT_ON_REV,NMG_E_ASSESSMENT_ON_REV)
#define NMG_LONE	NMG_V_ASSESSMENT_LONE

static const char *nmg_e_assessment_names[6] = {
	"LEFT",
	"RIGHT",
	"ON_FORW",
	"ON_REV",
	"E_ERROR",
	"E_5?"
};

/*
 *  Action entries for the state transition tables
 */
#define NMG_ACTION_ERROR		0
#define NMG_ACTION_NONE			1
#define NMG_ACTION_NONE_OPTIM		2
#define NMG_ACTION_VFY_EXT		3
#define NMG_ACTION_VFY_MULTI		4
#define NMG_ACTION_LONE_V_ESPLIT	5
#define NMG_ACTION_LONE_V_JAUNT		6
#define NMG_ACTION_CUTJOIN		7
static const char *action_names[] = {
	"*ERROR*",
	"NONE",
	"NONE_OPTIM",
	"VFY_EXT",
	"VFY_MULTI",
	"LONE_V_ESPLIT",
	"LONE_V_JAUNT",
	"CUTJOIN",
	"*TOOBIG*"
};

/* The "ray" here is the intersection line between two faces */
struct nmg_ray_state {
	long			magic;
	struct vertexuse	**vu;		/* ptr to vu array */
	int			nvu;		/* len of vu[] */
	point_t			pt;		/* The ray */
	vect_t			dir;
	struct edge_g_lseg		*eg_p;		/* Edge geom of the ray */
	struct shell		*sA;
	struct shell		*sB;
	struct faceuse		*fu1;
	struct faceuse		*fu2;
	vect_t			left;		/* points left of ray, on face */
	int			state;		/* current (old) state */
	int			last_action;	/* last action taken */
	vect_t			ang_x_dir;	/* x axis for angle measure */
	vect_t			ang_y_dir;	/* y axis for angle measure */
	const struct bn_tol	*tol;
};
#define NMG_RAYSTATE_MAGIC	0x54322345
#define NMG_CK_RAYSTATE(_p)	NMG_CKMAG(_p, NMG_RAYSTATE_MAGIC, "nmg_ray_state")

struct loop_cuts {
	struct loopuse *lu;
	struct vertexuse *vu1;
	struct vertexuse *vu2;
};
int
nmg_face_state_transition(struct nmg_ray_state	*rs, 
			  int			pos,
			  int			multi,
			  int			other_rs_state);

/*
 *			P T B L _ V S O R T
 *
 *  Sort list of hit points (vertexuse's) in fu1 on plane of fu2,
 *  by increasing distance, vertex ptr, and vu ptr.
 *  Eliminate duplications of vu at same distance.
 *  (Actually, a given vu should show up at exactly 1 distance!)
 *  The line of intersection is pt + t * dir.
 *
 *  For now, a bubble-sort is used, because the list should not have more
 *  than a few hundred entries on it.
 */
static void ptbl_vsort(struct bu_ptbl *b, struct faceuse *fu1, struct faceuse *fu2, fastf_t *pt, fastf_t *dir, fastf_t *mag, fastf_t dist_tol)
                  		/* table of vertexuses on intercept line */
              	     		/* unused? */
              	     		/* unused? */
       		   
      		    
       		     
       		         
{
	register struct vertexuse	**vu;
	register int i, j;

	vu = (struct vertexuse **)b->buffer;

	if( rt_g.NMG_debug )  {
		/* Ensure that distance from points to ray is reasonable */
		for(i = 0 ; i < b->end ; ++i) {
			fastf_t		dist;

			NMG_CK_VERTEXUSE(vu[i]);
			dist = bn_dist_line3_pt3( pt, dir, vu[i]->v_p->vg_p->coord );
			if( dist > dist_tol )  {
				bu_log("WARNING ptbl_vsort() vu=x%x point off line by %e %g*tol, tol=%e\n",
					vu[i], dist,
					dist/dist_tol, dist_tol);
				if(rt_g.NMG_debug&DEBUG_VU_SORT)  {
					VPRINT("  vu", vu[i]->v_p->vg_p->coord);
					VPRINT("  pt", pt);
					VPRINT(" dir", dir);
				}
			}
			if( dist > 100*dist_tol )  {
				bu_log("ERROR ptbl_vsort() vu=x%x point off line by %g > 100*dist_tol\n",
					vu[i], dist);
				rt_bomb("ptbl_vsort()\n");
			}
		}
	}

	/* check vertexuses and compute distance from start of line */
	for(i = 0 ; i < b->end ; ++i) {
		vect_t		vect;
		NMG_CK_VERTEXUSE(vu[i]);

		if( mag[i] == MAX_FASTF )
		{
			VSUB2(vect, vu[i]->v_p->vg_p->coord, pt);
			mag[i] = VDOT( vect, dir );
		}

		/* Find previous vu's at "same" distance, within dist_tol */
		for( j = 0; j < i; j++ )  {
			register fastf_t	tmag;

			tmag = mag[i] - mag[j];
			if( tmag < -dist_tol )  continue;
			if( tmag > dist_tol )  continue;
			/* Nearly equal at same vertex */
			if( mag[i] != mag[j] &&
			    vu[i]->v_p == vu[j]->v_p )  {
	bu_log("ptbl_vsort: forcing vu=x%x & vu=x%x mag equal\n", vu[i], vu[j]);
				mag[j] = mag[i]; /* force equal */
			}
		}
	}

	for(i=0 ; i < b->end - 1 ; ++i) {
		for (j=i+1; j < b->end ; ++j) {

			if( mag[i] < mag[j] )  continue;
			if( mag[i] == mag[j] )  {
				if( vu[i]->v_p < vu[j]->v_p )  continue;
				if( vu[i]->v_p == vu[j]->v_p )  {
					if( vu[i] < vu[j] )  continue;
					if( vu[i] == vu[j] )  {
						int	last = b->end - 1;
						/* vu duplication, eliminate! */
	bu_log("ptbl_vsort: vu duplication eliminated\n");
						if( j >= last )  {
							/* j is last element */
							b->end--;
							break;
						}
						/* rewrite j with last element */
						vu[j] = vu[last];
						mag[j] = mag[last];
						b->end--;
						/* Repeat this index */
						j--;
						continue;
					}
					/* vu[i] > vu[j], fall through */
				}
				/* vu[i]->v_p > vu[j]->v_p, fall through */
			}
			/* mag[i] > mag[j] */

			/* exchange [i] and [j] */
			{
				register struct vertexuse *tvu;
				tvu = vu[i];
				vu[i] = vu[j];
				vu[j] = tvu;
			}

			{
				register fastf_t	tmag;
				tmag = mag[i];
				mag[i] = mag[j];
				mag[j] = tmag;
			}
		}
	}
}

/*
 *			N M G _ C K _ V U _ P T B L
 *
 *  As an automatic check for the intersector failing to find
 *  all intersections, check all the vertices on the intersection line.
 *  For each one, find all the other uses in this faceuse, and
 *  if they are not also listed on the line, they were overlooked.
 *
 *  This does not catch _all_ possible mistakes, but does catch some.
 */
int
nmg_ck_vu_ptbl(struct bu_ptbl *p, struct faceuse *fu)
{
	struct vertex		*v;
	struct vertexuse	*vu;
	struct vertexuse	*tvu;
	struct faceuse		*tfu;
	int			i;
	int			ret = 0;

	BU_CK_PTBL(p);
	NMG_CK_FACEUSE(fu);

top:
	for( i=0; i < BU_PTBL_END(p); i++ )  {
		vu = (struct vertexuse *)BU_PTBL_GET(p, i);
		NMG_CK_VERTEXUSE(vu);
		v = vu->v_p;
		NMG_CK_VERTEX(v);
		tfu = nmg_find_fu_of_vu(vu);
		if( tfu != fu )  {
			bu_log("ERROR: vu=x%x v=x%x up_fu=x%x != arg_fu=x%x\n",
				vu, v, tfu, fu );
			rt_bomb("nmg_ck_vu_ptbl() intersect list is confused about which face it belongs to.\n");
		}
		for( BU_LIST_FOR( tvu, vertexuse, &v->vu_hd ) )  {
			NMG_CK_VERTEXUSE(tvu);
			if( tvu == vu )  continue;
			if( (tfu = nmg_find_fu_of_vu( tvu )) == (struct faceuse *)NULL )
				continue;
			if( tfu != fu )  continue;
			/* tvu is in fu.  Is tvu on the line? */
			if( bu_ptbl_locate(p, &tvu->l.magic ) >= 0 )  continue;
			/* No, not on list */
			bu_log("ERROR: vu=x%x v=x%x %s=x%x is on isect line, tvu=x%x %s=x%x isn't.\n",
				vu, v,
				bu_identify_magic( *vu->up.magic_p ),
				vu->up.magic_p,
				tvu,
				bu_identify_magic( *tvu->up.magic_p ),
				tvu->up.magic_p );
			/* XXX bomb here? */
			nmg_pr_ptbl( "intersect line vu table", p, 1 );
			rt_bomb("nmg_ck_vu_ptbl() missing vertexuse\n");
/* XXXXXXXXXXXXXXXXXXXXXXXX Horrible temporizing measure */
			/* Another strategy:  add it in! */
			(void)bu_ptbl_ins( p, &tvu->l.magic );
			ret++;
			goto top;
		}
	}
	if(ret)bu_log("nmg_ck_vu_ptbl() ret=%d\n", ret);
	return ret;
}

/*
 *			N M G _ V U _ A N G L E _ M E A S U R E
 *
 *  Given a vertexuse from a loop which lies in a plane,
 *  compute the vector 'vec' from the previous vertex to this one.
 *  Using two perpendicular vectors (x_dir and y_dir) which both lie
 *  in the plane of the loop, return the angle (in radians) of 'vec'
 *  from x_dir, going CCW around the perpendicular x_dir CROSS y_dir.
 *
 *  x_dir is -ray_dir
 *  y_dir points right.
 *
 *  Returns -
 *	vec == x_dir returns 0,
 *	vec == y_dir returns pi/2,
 *	vec == -x_dir returns pi,
 *	vec == -y_dir returns 3*pi/2.
 *	0.0 if unable to compute 'vec'
 */
double
nmg_vu_angle_measure(struct vertexuse *vu, fastf_t *x_dir, fastf_t *y_dir, int assessment, int in)
                	    
      			      
      			      
   			           
   			   	/* 1 = inbound edge, 0 = outbound edge */
{	
	struct loopuse	*lu;
	struct edgeuse	*this_eu;
	struct edgeuse	*prev_eu;
	vect_t		vec;
	fastf_t		ang;
	int		this_ass;

	NMG_CK_VERTEXUSE( vu );
	if( *vu->up.magic_p == NMG_LOOPUSE_MAGIC )  {
		return 0;		/* Unable to compute 'vec' */
	}

	/*
	 *  For consistency, if entry edge is ON the ray,
	 *  force the angles to be exact, don't compute them.
	 */
	if( in )
		this_ass = NMG_V_ASSESSMENT_PREV( assessment );
	else
		this_ass = NMG_V_ASSESSMENT_NEXT( assessment );
	if( this_ass == NMG_E_ASSESSMENT_ON_FORW )  {
		if( in )  ang = 0;	/* zero angle */
		else	ang = bn_pi;	/* 180 degrees */
		if(rt_g.NMG_debug&DEBUG_VU_SORT)
			bu_log("nmg_vu_angle_measure:  NMG_E_ASSESSMENT_ON_FORW, ang=%g\n", ang);
		return ang;
	}
	if( this_ass == NMG_E_ASSESSMENT_ON_REV )  {
		if( in )  ang = bn_pi;	/* 180 degrees */
		else	ang = 0;	/* zero angle */
		if(rt_g.NMG_debug&DEBUG_VU_SORT)
			bu_log("nmg_vu_angle_measure:  NMG_E_ASSESSMENT_ON_REV, ang=%g\n", ang);
		return ang;
	}

	/*
	 *  Compute the angle
	 */
	lu = nmg_find_lu_of_vu(vu);
	NMG_CK_LOOPUSE(lu);
	this_eu = nmg_find_eu_with_vu_in_lu( lu, vu );
	prev_eu = this_eu;
	do {
		prev_eu = in ? BU_LIST_PPREV_CIRC( edgeuse, prev_eu ) :
			BU_LIST_PNEXT_CIRC( edgeuse, prev_eu );
		if( prev_eu == this_eu )  {
			if(rt_g.NMG_debug&DEBUG_VU_SORT)
				bu_log("nmg_vu_angle_measure: prev eu is this eu, ang=0\n");
			return 0;	/* Unable to compute 'vec' */
		}
		/* Skip any edges that stay on this vertex */
	} while( prev_eu->vu_p->v_p == this_eu->vu_p->v_p );

	/* in==1 Get vec for inbound edge, but pointing away from vert. */
	/* in==0 "prev" is really next, so this is departing vec */
	VSUB2( vec, prev_eu->vu_p->v_p->vg_p->coord, vu->v_p->vg_p->coord );

	ang = bn_angle_measure( vec, x_dir, y_dir );
	if(rt_g.NMG_debug&DEBUG_VU_SORT)
		bu_log("nmg_vu_angle_measure:  measured angle=%e\n", ang*bn_radtodeg);

	/*
	 *  Since the entry edge is not on the ray, ensure the
	 *  angles are not exactly 0 or pi.
	 */
#define RADIAN_TWEEK	1.0e-14	/* low bits of double prec., re: 6.28... */
	if( ang == 0 )  {
		if( this_ass == NMG_E_ASSESSMENT_RIGHT )  {
			ang = RADIAN_TWEEK;
		} else {
			/* Assuming NMG_E_ASSESSMENT_LEFT */
			ang = bn_twopi - RADIAN_TWEEK;
		}
	} else if( ang == bn_pi )  {
		if( this_ass == NMG_E_ASSESSMENT_RIGHT )  {
			ang = bn_pi - RADIAN_TWEEK;
		} else {
			ang = bn_pi + RADIAN_TWEEK;
		}
	}

	/*
	 *  Also, ensure computed angle and topological assessment agree
	 *  about which side of the ray this edge is on.
	 */
	if( ang > bn_pi )  {
		if( this_ass != NMG_E_ASSESSMENT_LEFT )  {
			bu_log("*** ERROR topology/geometry conflict, ang=%e, ass=%s\n",
				ang*bn_radtodeg,
				nmg_e_assessment_names[this_ass] );
		}
	} else if( ang < bn_pi )  {
		if( this_ass != NMG_E_ASSESSMENT_RIGHT )  {
			bu_log("*** ERROR topology/geometry conflict, ang=%e, ass=%s\n",
				ang*bn_radtodeg,
				nmg_e_assessment_names[this_ass] );
		}
	}
	if(rt_g.NMG_debug&DEBUG_VU_SORT)
		bu_log("  final ang=%g (%e), vec=(%g,%g,%g)\n", ang*bn_radtodeg, ang*bn_radtodeg, V3ARGS(vec) );
	return ang;
}

/*
 *			N M G _ I S _ V _ O N _ R S _ L I S T
 */
int
nmg_is_v_on_rs_list(const struct nmg_ray_state *rs, const struct vertex *v)
{
	register int	i;

	NMG_CK_VERTEX(v);
	for( i=rs->nvu-1; i >= 0; i-- )  {
		if( !rs->vu[i] )  continue;
		if( rs->vu[i]->v_p == v )  return i;
	}
	return -1;
}

/*
 *			N M G _ A S S E S S _ E U
 *
 *  The current vertex (eu->vu_p) is on the line of intersection.
 *  Assess the indicated edge, to see if it lies on the line of
 *  intersection, or departs towards the left or right.
 *
 *  There is no need to look more than one edge forward or backward.
 *  Even if there are edges which loop around to the same vertex
 *  (with a different vertexuse), that (0-length) edge is ON the ray.
 */
int
nmg_assess_eu(struct edgeuse *eu, int forw, struct nmg_ray_state *rs, int pos)
{
	struct vertex		*v;
	struct vertex		*otherv = (struct vertex *)0;
	struct edgeuse		*othereu;
	vect_t			heading;
	int			ret;
	register int		i;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_RAYSTATE(rs);
	BN_CK_TOL(rs->tol);
	v = eu->vu_p->v_p;
	NMG_CK_VERTEX(v);
	othereu = eu;
	if( forw )  {
		othereu = BU_LIST_PNEXT_CIRC( edgeuse, othereu );
	} else {
		othereu = BU_LIST_PPREV_CIRC( edgeuse, othereu );
	}
	if( othereu == eu )  {
		/* Back to where search started */
		if(rt_g.NMG_debug) nmg_pr_eu(eu, NULL);
		rt_bomb("nmg_assess_eu() no edges leave the vertex!\n");
	}
	otherv = othereu->vu_p->v_p;
	if( otherv == v )  {
		/* Edge stays on this vertex -- can't tell if forw or rev! */
		if(rt_g.NMG_debug) nmg_pr_eu(eu, NULL);
		rt_bomb("nmg_assess_eu() edge runs from&to same vertex!\n");
	}

	/*  If the other vertex is mentioned anywhere on the ray's vu list,
	 *  then the edge is "on" the ray.
	 *  Match against vertex (rather than vertexuse) because cut/join
	 *  operations may have changed the particular vertexuse pointer.
	 */
	if( (i = nmg_is_v_on_rs_list(rs, otherv)) > -1 )  {
		struct vertex	*farv;
		struct edgeuse	*fareu;
		int		start, end;

		fareu = othereu;
again:
		/* Edge's far end is ON the ray.  Which way does it go? */
		if(rt_g.NMG_debug&DEBUG_FCUT)
			bu_log("eu ON ray: vu[%d]=x%x, other:vu[%d]=x%x\n",
				pos, rs->vu[pos], i, otherv );

		/*
		 *  As an attempt at fixing the ON/ON vertexuse problem,
		 *  look further forw/back along the edgeuse list,
		 *  as long as it shares the same edge geometry.
		 *  If not on list, use *that* vertex to assess left/right.
		 */
		if( forw )  {
			fareu = BU_LIST_PNEXT_CIRC( edgeuse, fareu );
		} else {
			fareu = BU_LIST_PPREV_CIRC( edgeuse, fareu );
		}
		if( fareu == eu )  goto really_on;	/* All eu's are ON! */
		if( fareu->g.lseg_p != eu->g.lseg_p )  goto really_on;
		farv = fareu->vu_p->v_p;
		if(rt_g.NMG_debug&DEBUG_FCUT)
			bu_log("nmg_assess_eu() farv = x%x, on_index=%d\n", farv, nmg_is_v_on_rs_list(rs, farv) );
		if( nmg_is_v_on_rs_list(rs, farv) > -1 )  {
			/* farv is ON list, try going further back */
			goto again;
		}
		/* farv is not ON list, assess _it_ */
		/* XXX Need to remove othervu from the list! */
		otherv = farv;
		if(rt_g.NMG_debug&DEBUG_FCUT)
			bu_log("nmg_assess_eu() assessing farv\n");
		goto left_right;

		/* Compute edge vector, for purposes of orienting answer */
really_on:
#if 0
		if( forw )  {
			/* Edge goes from v to otherv */
			VSUB2( heading, otherv->vg_p->coord, v->vg_p->coord );
		} else {
			/* Edge goes from otherv to v */
			VSUB2( heading, v->vg_p->coord, otherv->vg_p->coord );
		}
		if( MAGSQ(heading) < SMALL_FASTF )  rt_bomb("nmg_assess_eu() null heading\n");
		if( MAGSQ(heading) < rs->tol->dist_sq )  rt_bomb("nmg_assess_eu() edge len < dist tol\n");
		if( VDOT( heading, rs->dir ) < 0 )  {
			ret = NMG_E_ASSESSMENT_ON_REV;
		} else {
			ret = NMG_E_ASSESSMENT_ON_FORW;
		}

		if( i > pos )  {
			start = pos+1;
			end = i;
		} else {
			start = i+1;
			end = pos;
		}
#else
		/*
		 *  There are 2 ways of determining the assessment:
		 *  edge direction DOT ray direction, above, and
		 *  comparing the subscripts of the two vertexuses
		 *  (which translates to comparing dists along ray).
		 */
		if( i > pos )  {
			if( forw )
				ret = NMG_E_ASSESSMENT_ON_FORW;
			else
				ret = NMG_E_ASSESSMENT_ON_REV;
			start = pos+1;
			end = i;
		} else {
			/* i < pos  (They can't be equal) */
			if( forw )
				ret = NMG_E_ASSESSMENT_ON_REV;
			else
				ret = NMG_E_ASSESSMENT_ON_FORW;
			start = i+1;
			end = pos;
		}
#endif
		/*
		 *  Verify that any other vertexuses on the intersect line
		 *  along the ON edge are uses of one of the two edge
		 *  endpoints.  Otherwise, something awful has happened.
		 */
		for( i=start; i<end; i++ )  {
			int	j;
			if( !rs->vu[i] )  continue;
			if( rs->vu[i]->v_p == v ||
			    rs->vu[i]->v_p == otherv )
				continue;
			if(rt_g.NMG_debug&DEBUG_FCUT)  {
				bu_log("In edge interval (%d,%d), ON vertexuse [%d] = x%x appears?\n",
					start-1, end, i, rs->vu[i] );
				for( j=start-1; j<=end; j++ )  {
					if( !rs->vu[i] )  continue;
					bu_log(" %d ", j);
					nmg_pr_vu_briefly( rs->vu[j], (char *)0 );
				}
				bu_log("nmg_assess_eu():  ON vertexuse in middle of edge?\n");
			}
			/* Leave it for nmg_onon_fix() to fix */
			ret = NMG_E_ASSESSMENT_ERROR;
			return -i;	/* Special flag to nmg_onon_fix() */
		}
		goto out;
	}

	/*
	 *  Since other vertex does not lie anywhere on line of intersection,
	 *  the edge must lie to one side or the other of the ray.
	 *  Check vector from v to otherv against "left" vector.
	 */
left_right:
	VSUB2( heading, otherv->vg_p->coord, v->vg_p->coord );
	if( MAGSQ(heading) < SMALL_FASTF )  rt_bomb("nmg_assess_eu() null heading 2\n");
	if( VDOT( heading, rs->left ) < 0 )  {
		ret = NMG_E_ASSESSMENT_RIGHT;
	} else {
		ret = NMG_E_ASSESSMENT_LEFT;
	}
out:
	if(rt_g.NMG_debug&DEBUG_FCUT)  {
		bu_log("nmg_assess_eu(x%x, fw=%d, pos=%d) v=x%x otherv=x%x: %s\n",
			eu, forw, pos, v, otherv,
			nmg_e_assessment_names[ret] );
		bu_log(" v(%g, %g, %g) other(%g, %g, %g)\n",
			V3ARGS(v->vg_p->coord), V3ARGS(otherv->vg_p->coord) );
		bu_log(" rs->left(%g, %g, %g) heading(%g, %g, %g)\n",
			V3ARGS(rs->left), V3ARGS(heading) );
	}
	return ret;
}

/*
 *			N M G _ A S S E S S _ V U
 */
int
nmg_assess_vu(struct nmg_ray_state *rs, int pos)
{
	struct vertexuse	*vu;
	struct loopuse	*lu;
	struct edgeuse	*this_eu;
	int		next_ass;
	int		prev_ass;
	int		ass;

	NMG_CK_RAYSTATE(rs);
	vu = rs->vu[pos];
	NMG_CK_VERTEXUSE( vu );
	if( *vu->up.magic_p == NMG_LOOPUSE_MAGIC )  {
		return NMG_V_ASSESSMENT_LONE;
	}
	if( (lu = nmg_find_lu_of_vu(vu)) == (struct loopuse *)0 )
		rt_bomb("nmg_assess_vu: no lu\n");
	this_eu = nmg_find_eu_with_vu_in_lu( lu, vu );
	/* Couldn't this have been this_eu = vu->up.eu_p ? */
	if( this_eu != vu->up.eu_p )  bu_log("nmg_assess_vu() eu mis-match? x%x x%x\n", this_eu, vu->up.eu_p);
	prev_ass = nmg_assess_eu( this_eu, 0, rs, pos );
	next_ass = nmg_assess_eu( this_eu, 1, rs, pos );
	if( prev_ass < 0 || next_ass < 0 )  {
		ass = NMG_V_ASSESSMENT_ERROR;
	} else {
		ass = NMG_V_COMB( prev_ass, next_ass );
	}

	/*
	 *  If the vu assessment is
	 *  NMG_ON_REV_ON_FORW or NMG_ON_FORW_ON_REV,
	 *  ensure that other end of both eu's is same vertex.
	 *  If not, it's an intersector error, and will confuse our caller.
	 */
	if( ass==NMG_ON_REV_ON_FORW || ass==NMG_ON_FORW_ON_REV )  {
		struct edgeuse	*prev;
		struct edgeuse	*next;
		prev = BU_LIST_PPREV_CIRC( edgeuse, this_eu );
		next = BU_LIST_PNEXT_CIRC( edgeuse, this_eu );
		if( prev->vu_p->v_p != next->vu_p->v_p )  {
			bu_log("nmg_assess_vu() %s, v=x%x, prev_v=x%x, next_v=x%x\n",
				nmg_v_assessment_names[ass],
				this_eu->vu_p->v_p,
				prev->vu_p->v_p, next->vu_p->v_p );
			bu_log("nmg_assess_vu() ON/ON edgeuse ends on different vertices.\n");
			VPRINT("vu  ", this_eu->vu_p->v_p->vg_p->coord);
			VPRINT("prev", prev->vu_p->v_p->vg_p->coord);
			VPRINT("next", next->vu_p->v_p->vg_p->coord);

			/* See how far off the line they are */
			bu_log("vu dist=%e, next dist=%e, tol=%e\n",
			bn_dist_line3_pt3( rs->pt, rs->dir, this_eu->vu_p->v_p->vg_p->coord ),
			bn_dist_line3_pt3( rs->pt, rs->dir, prev->vu_p->v_p->vg_p->coord ),
				rs->tol->dist );
#if 0
			/* It's too late for this now. */
			if( nmg_break_long_edges( nmg_find_s_of_eu(this_eu), rs->tol ) > 0 )
				bu_log("\tnmg_break_long_edges succeeded\n");
#endif
			rt_bomb("nmg_assess_vu() ON/ON edgeuse ends on different vertices.\n");
		}
	}
	if(rt_g.NMG_debug&DEBUG_FCUT)  {
		bu_log("nmg_assess_vu() vu[%d]=x%x, v=x%x: %s\n",
			pos, vu, vu->v_p, nmg_v_assessment_names[ass] );
	}
	return ass;
}

struct nmg_vu_stuff {
	struct vertexuse	*vu;
	int			loop_index;
	struct nmg_loop_stuff	*lsp;
	fastf_t			in_vu_angle;
	fastf_t			out_vu_angle;
	fastf_t			min_vu_dot;
	fastf_t			lo_ang;		/* small if RIGHT, large if LEFT */
	fastf_t			hi_ang;
	int			seq;		/* seq # after lsp->min_vu */
	int			wedge_class;	/* WEDGE_LEFT, etc */
};
struct nmg_loop_stuff {
	struct loopuse		*lu;
	fastf_t			min_dot;
	struct vertexuse	*min_vu;
	int			n_vu_in_loop;	/* # ray vu's in this loop */
};

#define WEDGE_LEFT	0
#define WEDGE_CROSS	1
#define WEDGE_RIGHT	2
#define WEDGE_ON	3
#define WEDGECLASS2STR(_cl)	nmg_wedgeclass_string[(_cl)]
static const char *nmg_wedgeclass_string[] = {
	"LEFT",
	"CROSS",
	"RIGHT",
	"ON",
	"???"
};

/*
 *			N M G _ P R _ V U _ S T U F F
 */
void
nmg_pr_vu_stuff(const struct nmg_vu_stuff *vs)
{
	bu_log("nmg_pr_vu_stuff(x%x) vu=x%x, loop_index=%d, lsp=x%x\n",
		vs, vs->vu, vs->loop_index, vs->lsp);
	bu_log(" in_vu_angle=%g, out_vu_angle=%g, min_vu_dot=%g\n",
		vs->in_vu_angle, vs->out_vu_angle, vs->min_vu_dot);
	bu_log(" lo_ang=%g, hi_ang=%g, seq=%d, wedge_class=%s\n",
		vs->lo_ang, vs->hi_ang, vs->seq,
		WEDGECLASS2STR(vs->wedge_class) );
}

/*
 *			N M G _ W E D G E _ C L A S S
 *
 *  0 degrees is to the rear (ON_REV), 90 degrees is to the RIGHT,
 *  180 is ON_FORW, 270 is to the LEFT.
 *  Determine if the given wedge is entirely to the left or right of
 *  the ray, or if it crosses.
 *
 *  "halfway X" (ha, hb) have these properties:
 *	< 0	( ==> X < 180 ) RIGHT
 *	> 0	( ==> X > 180 )	LEFT
 *	==0	( ==> X == 180 ) ON_FORW
 *
 *  Returns -
 *	WEDGE_LEFT
 *	WEDGE_CROSSING
 *	WEDGE_RIGHT
 *	WEDGE_ON
 */
int
nmg_wedge_class(int ass, double a, double b)
   	    			/* assessment of two edges forming wedge */
      	  
      	  
{
	double	ha, hb;
	register int	ret;

	ha = a - 180;
	hb = b - 180;

	if( ass == NMG_V_COMB(NMG_E_ASSESSMENT_ON_FORW, NMG_E_ASSESSMENT_ON_FORW) )  {
		ret = WEDGE_ON;
		goto out;
	}
	if( ass == NMG_V_COMB(NMG_E_ASSESSMENT_ON_REV, NMG_E_ASSESSMENT_ON_REV) )  {
		ret = WEDGE_ON;
		goto out;
	}

	if( NEAR_ZERO( ha, .01 ) )  {
		/* A is on the ray, within tol */
		if( NEAR_ZERO( hb, .01 ) )  {
			/* B is on the ray, within tol */
			/* This is a 0-angle wedge entering & leaving.
			 * This is not WEDGE_ON
			 * Call it WEDGE_CROSS.
			 */
			if(rt_g.NMG_debug&DEBUG_VU_SORT)
				bu_log("nmg_wedge_class() 0-angle wedge\n");
			ret = WEDGE_CROSS;
			goto out;
		}
		if( hb < 0 )  {
			ret = WEDGE_RIGHT;
			goto out;
		}
		ret = WEDGE_LEFT;
		goto out;
	}
	if( ha < 0 )  {
		/* A is to the right */
		if( hb <= 0 )  {
			ret = WEDGE_RIGHT;
			goto out;
		}
		ret = WEDGE_CROSS;
		goto out;
	}
	/* ha is > 0, A is to the left */
	if( NEAR_ZERO( hb, .01 ) )  {
		/* A is left, B is ON_FORW (180) */
		ret = WEDGE_LEFT;
		goto out;
	}
	if( hb >= 0 )  {
		/* A is left, B is LEFT */
		ret = WEDGE_LEFT;
		goto out;
	}
	/* A is left, B is RIGHT */
	ret = WEDGE_CROSS;
out:
	if(rt_g.NMG_debug&DEBUG_VU_SORT)  {
		bu_log("nmg_wedge_class(%g,%g) = %s\n",
			a, b, WEDGECLASS2STR(ret) );
	}
	return ret;
}

static const char *nmg_wedge2_string[] = {
	"WEDGE2_OVERLAP",
	"WEDGE2_NO_OVERLAP",
	"WEDGE2_AB_IN_CD",
	"WEDGE2_CD_IN_AB",
	"WEDGE2_IDENTICAL",
	"WEDGE2_TOUCH_AT_BC",
	"WEDGE2_TOUCH_AT_DA",
	"WEDGE2_???"
};
#define WEDGE2_TO_STRING(_class2)	(nmg_wedge2_string[(_class2)+2])

#define WEDGE2_OVERLAP		-2
#define WEDGE2_NO_OVERLAP	-1
#define WEDGE2_AB_IN_CD		0
#define WEDGE2_CD_IN_AB		1
#define WEDGE2_IDENTICAL	2
#define WEDGE2_TOUCH_AT_BC	3
#define WEDGE2_TOUCH_AT_DA	4

/*
 *			N M G _ C O M P A R E _ 2 _W E D G E S
 *
 *  Returns -
 *	WEDGE2_OVERLAP		AB partially overlaps CD (error)
 *	WEDGE2_NO_OVERLAP	AB does not overlap CD
 *	WEDGE2_AB_IN_CD		AB is inside CD
 *	WEDGE2_CD_IN_AB		CD is inside AB
 *	WEDGE2_IDENTICAL	AB == CD
 *	WEDGE2_TOUCH_AT_BC	AB touches CD at BC, but does not overlap
 *	WEDGE2_TOUCH_AT_DA	CD touches AB at DA, but does not overlap
 */
static int
nmg_compare_2_wedges(double a, double b, double c, double d)
{
	double	t;
	int	a_in_cd = 0;
	int	b_in_cd = 0;
	int	c_in_ab = 0;
	int	d_in_ab = 0;
	int	a_eq_b = 0;
	int	a_eq_c = 0;
	int	a_eq_d = 0;
	int	b_eq_c = 0;
	int	b_eq_d = 0;
	int	c_eq_d = 0;
	int	ret;

#define WEDGE_ANG_TOL	0.001	/* XXX Angular tolerance, in degrees */
#define	ANG_SMASH(_a)	{\
	if( _a <= WEDGE_ANG_TOL )  _a = 0; \
	else if( NEAR_ZERO( _a - 180, WEDGE_ANG_TOL ) )  _a = 180; \
	else if( _a >= 360 - WEDGE_ANG_TOL )  _a = 360; }

	ANG_SMASH(a);
	ANG_SMASH(b);
	ANG_SMASH(c);
	ANG_SMASH(d);

	/* Ensure A < B */
	if( a > b )  {
		t = a;
		a = b;
		b = t;
	}
	/* Ensure that C < D */
	if( c > d )  {
		t = c;
		c = d;
		d = t;
	}

	if( NEAR_ZERO( a-b, WEDGE_ANG_TOL ) )  a_eq_b = 1;
	if( NEAR_ZERO( a-c, WEDGE_ANG_TOL ) )  a_eq_c = 1;
	if( NEAR_ZERO( a-d, WEDGE_ANG_TOL ) )  a_eq_d = 1;
	if( NEAR_ZERO( b-c, WEDGE_ANG_TOL ) )  b_eq_c = 1;
	if( NEAR_ZERO( b-d, WEDGE_ANG_TOL ) )  b_eq_d = 1;
	if( NEAR_ZERO( c-d, WEDGE_ANG_TOL ) )  c_eq_d = 1;

	/*
	 *  Test for TOUCHing wedges must come before INside test,
	 *  so that zero-angle wedges that touch a non-zero angle wedge,
	 *  will be properly recognized.  e.g. AB=(0,0) CD=(0,180).
	 */
	if( b_eq_c )  {
		/* Wedges touch along B-C junction */
		if( a_eq_d )
			ret = WEDGE2_IDENTICAL;	/* two zero-angle wedges */
		else
			ret = WEDGE2_TOUCH_AT_BC;
		goto out;
	}

	if( a_eq_d )  {
		/* We know c <= d, d==a, a <= b */
		if( b_eq_c )  {
			ret = WEDGE2_IDENTICAL;
			goto out;
		}
		if( a_eq_b )  {
			ret = WEDGE2_AB_IN_CD;
		} else if( c_eq_d )  {
			ret = WEDGE2_CD_IN_AB;
		} else {
			ret = WEDGE2_TOUCH_AT_DA;
		}
		goto out;
	}

	if( a_eq_c )  {
		if( b_eq_d )  {
			ret = WEDGE2_IDENTICAL;
			goto out;
		}
		/* We already know that A <= B, from sort above */
		if( b < d )  ret = WEDGE2_AB_IN_CD;
		else  ret = WEDGE2_CD_IN_AB;
		goto out;
	}

	if( b_eq_d )  {
		/* a != c, because of previous IF statement */
		if( a < c )  ret = WEDGE2_CD_IN_AB;
		else  ret = WEDGE2_AB_IN_CD;
		goto out;
	}

	/* See if c < a,b < d */
	if( c <= a && a <= d )  a_in_cd = 1;
	if( c <= b && b <= d )  b_in_cd = 1;
	/* See if a < c,d < b */
	if( a < c && c < b )  c_in_ab = 1;
	if( a < d && d < b )  d_in_ab = 1;

	if( a_in_cd && b_in_cd )  {
		if( c_in_ab || d_in_ab )  {
			ret = WEDGE2_OVERLAP;	/* ERROR */
			goto out;
		}
		ret = WEDGE2_AB_IN_CD;
		goto out;
	}
	if( c_in_ab && d_in_ab )  {
		if( a_in_cd || b_in_cd )  {
			ret = WEDGE2_OVERLAP;	/* ERROR */
			goto out;
		}
		ret = WEDGE2_CD_IN_AB;
		goto out;
	}
	if( a_in_cd + b_in_cd + c_in_ab + d_in_ab <= 0 )  {
		ret = WEDGE2_NO_OVERLAP;
		goto out;
	}
	ret = WEDGE2_OVERLAP;			/* ERROR */
out:
	if(rt_g.NMG_debug&DEBUG_VU_SORT)  {
		bu_log(" a_in_cd=%d, b_in_cd=%d, c_in_ab=%d, d_in_ab=%d\n",
			a_in_cd, b_in_cd, c_in_ab, d_in_ab );
		bu_log("nmg_compare_2_wedges(%g,%g, %g,%g) = %d %s\n",
			a, b, c, d, ret, WEDGE2_TO_STRING(ret) );
	}
	if(ret <= WEDGE2_OVERLAP )  {
		bu_log("nmg_compare_2_wedges(%g,%g, %g,%g) ERROR!\n", a, b, c, d);
		rt_bomb("nmg_compare_2_wedges() ERROR\n");
	}
	return ret;
}

/*
 *			N M G _ F I N D _ V U _ I N _ W E D G E
 *
 *  Find the VU which is inside (or on) the given wedge,
 *  fitting as tightly to the given wedge as possible,
 *  and with the lowest value of lo_ang possible.
 *  XXX how to do tie-breaking for the two coincident ones where
 *  XXX two loops come together.
 *
 *  lo_ang < hi_ang on RIGHT side of intersection line
 *  lo_ang > hi_ang on LEFT side of intersection line
 *
 *  There are three wedges involved here:
 *	the original one, from lo to hi,
 *	the current best "candidate" so far,
 *	and "this", the current one being considered.
 */
static int
nmg_find_vu_in_wedge(struct nmg_vu_stuff *vs, int start, int end, double lo_ang, double hi_ang, int wclass, int *skip_array)
                   	    
   	      		/* vu index of coincident range */
   	    
      	       
      	       
   	       
   	             
{
	register int	i;
	double	cand_lo;
	double	cand_hi;
	int	candidate;

	if(rt_g.NMG_debug&DEBUG_VU_SORT)
		bu_log("nmg_find_vu_in_wedge(start=%d,end=%d, lo=%g, hi=%g) START\n",
			start, end, lo_ang, hi_ang);

	candidate = -1;
	cand_lo = lo_ang;
	cand_hi = hi_ang;

	/* Consider all the candidates */
	for( i=start; i < end; i++ )  {
		int	this_wrt_orig;
		int	this_wrt_cand;

		NMG_CK_VERTEXUSE( vs[i].vu );
		if( skip_array[i] )  {
			if(rt_g.NMG_debug&DEBUG_VU_SORT)
				bu_log("Skipping index %d\n", i);
			continue;
		}

		/* Ignore wedges crossing, or on other side of line */
		if( vs[i].wedge_class != wclass && vs[i].wedge_class != WEDGE_ON )  {
			if(rt_g.NMG_debug&DEBUG_VU_SORT)  {
				bu_log("Seeking wedge_class=%s, [%d] has wedge_class %s\n",
					WEDGECLASS2STR(wclass), i, WEDGECLASS2STR(vs[i].wedge_class) );
			}
			continue;
		}

		if( vs[i].wedge_class == WEDGE_ON )  {
			/* Ensure that comparisons will work */
			if( wclass == WEDGE_RIGHT )  {
				vs[i].lo_ang = 0;
				vs[i].hi_ang = 180;
			} else {
				vs[i].lo_ang = 360;
				vs[i].hi_ang = 180;
			}
		}

		this_wrt_orig = nmg_compare_2_wedges(
			vs[i].lo_ang, vs[i].hi_ang,
			lo_ang, hi_ang );
		switch( this_wrt_orig )  {
		case WEDGE2_AB_IN_CD:
			break;
		case WEDGE2_IDENTICAL:
			candidate = i;
			goto out;
		default:
			continue;	/* not inside wedge */
		}

		if( candidate < 0 ) {
			/* This wedge AB is inside original wedge.
			 * If candidate is -1, use AB as candidate.
			 */
			if(rt_g.NMG_debug&DEBUG_VU_SORT)
				bu_log("Initial candidate %d selected\n", i);
			candidate = i;
			cand_lo = vs[i].lo_ang;
			cand_hi = vs[i].hi_ang;
			continue;
		}

		this_wrt_cand = nmg_compare_2_wedges(
			vs[i].lo_ang, vs[i].hi_ang,
			cand_lo, cand_hi );
		switch( this_wrt_cand )  {
		case WEDGE2_CD_IN_AB:
			/* This wedge AB contains candidate wedge CD, therefore
			 * this wedge is closer to original wedge */
			if(rt_g.NMG_debug&DEBUG_VU_SORT)
				bu_log("This candidate %d is closer\n", i);
			candidate = i;
			cand_lo = vs[i].lo_ang;
			cand_hi = vs[i].hi_ang;
			break;
		case WEDGE2_NO_OVERLAP:
			/* No overlap, but both are inside.  Take lower angle */
			if( vs[i].lo_ang < cand_lo )  {
			if(rt_g.NMG_debug&DEBUG_VU_SORT)
				bu_log("Taking lower angle %d\n", i);
				candidate = i;
				cand_lo = vs[i].lo_ang;
				cand_hi = vs[i].hi_ang;
			}
			break;
		default:
			if(rt_g.NMG_debug&DEBUG_VU_SORT)
				bu_log("Continuing with search\n");
			continue;
		}
	}
out:
	if(rt_g.NMG_debug&DEBUG_VU_SORT)
		bu_log("nmg_find_vu_in_wedge(start=%d,end=%d, lo=%g, hi=%g) END candidate=%d\n",
			start, end, lo_ang, hi_ang,
			candidate);
	return candidate;	/* is -1 if none found */
}

/*
 *			N M G _ I S _ W E D G E _ B E F O R E _ C R O S S
 *
 *  Determine if the 'wedge' vu, which is either a LEFT or RIGHT wedge,
 *  should be processed before or after the 'cross' vu, which is a
 *  CROSS wedge.
 *
 *  Returns -
 *	1	if wedge should be processed before cross
 *	0	if cross should be processed before wedge
 */
static int
nmg_is_wedge_before_cross(const struct nmg_vu_stuff *wedge, const struct nmg_vu_stuff *cross)
{
	int	class2;
	int	ret = -1;

	if( cross->wedge_class != WEDGE_CROSS || wedge->wedge_class == WEDGE_CROSS )
		rt_bomb("nmg_is_wedge_before_cross() bad input\n");

	/* LEFT/RIGHT Wedge is (AB), CROSS wedge is (CD) */
	class2 = nmg_compare_2_wedges( wedge->lo_ang, wedge->hi_ang,
		cross->lo_ang, cross->hi_ang );

	switch(class2)  {
	default:
		bu_log("nmg_is_wedge_before_cross() class2=%s\n",
			WEDGE2_TO_STRING(class2) );
		rt_bomb("nmg_is_wedge_before_cross(): bad wedge comparison\n");
	case WEDGE2_NO_OVERLAP:
		/* wedge is not inside cross, cross is not inside wedge. */
		/* Do wedge first */
		ret = 1;
		break;
	case WEDGE2_TOUCH_AT_BC:
		/* Should only happen when wedge is WEDGE_RIGHT */
		if( wedge->wedge_class != WEDGE_RIGHT )
			rt_bomb("WEDGE not RIGHT with WEDGE2_TOUCH_AT_BC?\n");
		ret = 1;
		break;
	case WEDGE2_TOUCH_AT_DA:
		/* Should only happen when wedge is WEDGE_LEFT */
		if( wedge->wedge_class != WEDGE_LEFT )
			rt_bomb("WEDGE not LEFT with WEDGE2_TOUCH_AT_DA?\n");
		ret = 1;
		break;
	case WEDGE2_AB_IN_CD:
		/* 'wedge' is inside the 'cross' wedge, do it second. */
		ret = 0;
		break;
	}
	if(rt_g.NMG_debug&DEBUG_VU_SORT)  {
		bu_log("nmg_is_wedge_before_cross() class2=%s, ret=%d\n",
			WEDGE2_TO_STRING(class2), ret );
	}
	return ret;
}

/*
 *			N M G _ F A C E _ V U _ C O M P A R E
 *
 *  Support routine for nmg_face_coincident_vu_sort(), via qsort().
 *
 *  It is important to note that an edge on the LEFT side of the ray
 *  will have a "lo" angle which is numerically LARGER than the "hi" angle.
 *  However, all are measured in the usual units:
 *  0 = ON_REV, 90 = RIGHT, 180 = ON_FORW, 270 = LEFT.
 *
 *  Returns -
 *	-1	when A < B
 *	 0	when A == B
 *	+1	when A > B
 */
#define	A_LT_B		{ret = -1; goto out;}
#define AB_EQUAL	{ret = 0; goto out;}
#define A_GT_B		{ret = 1; goto out;}
static int
nmg_face_vu_compare(const void *aa, const void *bb)
#if __STDC__
           	    
           	    
#else
               	   
               	   
#endif
{
	register const struct nmg_vu_stuff *a = (const struct nmg_vu_stuff *)aa;
	register const struct nmg_vu_stuff *b = (const struct nmg_vu_stuff *)bb;
	register double	diff;
	int	lo_equal = 0;
	int	hi_equal = 0;
	register int	ret = 0;

	lo_equal = NEAR_ZERO( a->lo_ang - b->lo_ang, WEDGE_ANG_TOL );
	hi_equal = NEAR_ZERO( a->hi_ang - b->hi_ang, WEDGE_ANG_TOL );
	/* If both have the same assessment & angles match, => tie */
	if( a->wedge_class == b->wedge_class && lo_equal && hi_equal ) {
		/* Break the tie */
tie_break:
		if( a->loop_index == b->loop_index )  {
			/* Within a loop, sort by vu sequence number */
			if( a->seq < b->seq )  A_LT_B;
			if( a->seq == b->seq )  AB_EQUAL;
			A_GT_B;
		}
		/* Select smallest inbound angle */
		diff = a->in_vu_angle - b->in_vu_angle;
		if( NEAR_ZERO( diff, WEDGE_ANG_TOL ) )  {
			/* Gak, this really means trouble! */
			bu_log("nmg_face_vu_compare(): two loops (single vertex) have same in_vu_angle%g?\n",
				a->in_vu_angle);
			nmg_pr_vu_stuff(a);
			nmg_pr_vu_stuff(b);
			rt_bomb("nmg_face_vu_compare():  can't decide\n");
			AB_EQUAL;
		}
		if( diff < 0 )  A_LT_B;
		A_GT_B;
	}
	switch( a->wedge_class )  {
	case WEDGE_ON:
		switch( b->wedge_class )  {
		case WEDGE_ON:
			goto tie_break;
		default:
			nmg_pr_vu_stuff(a);
			nmg_pr_vu_stuff(b);
			rt_bomb("nmg_face_vu_compare() WEDGE_ON 1?\n");
		}
		break;
	case WEDGE_LEFT:
		switch( b->wedge_class )  {
		case WEDGE_LEFT:
			if( lo_equal )  {
				/* hi_equal case handled above */
				if( a->hi_ang < b->hi_ang ) A_LT_B;
				A_GT_B;
			}
			if( a->lo_ang > b->lo_ang )  A_LT_B;
			A_GT_B;
		case WEDGE_CROSS:
			/* A is LEFT, B is CROSS */
			if( nmg_is_wedge_before_cross( a, b ) )  A_LT_B;
			A_GT_B;
		case WEDGE_RIGHT:
			diff = 360 - a->lo_ang;/* CW version of left angle */
			if( b->lo_ang <= diff )  A_GT_B;
			A_LT_B;
		case WEDGE_ON:
			nmg_pr_vu_stuff(a);
			nmg_pr_vu_stuff(b);
			rt_bomb("nmg_face_vu_compare() WEDGE_ON 2?\n");
		}
	case WEDGE_CROSS:
		switch( b->wedge_class )  {
		case WEDGE_LEFT:
			/* A (AB) is CROSS, (CD) is LEFT */
			if( nmg_is_wedge_before_cross( b, a ) )  A_GT_B;
			A_LT_B;
		case WEDGE_CROSS:
			if( lo_equal )  {
				if( a->hi_ang > b->hi_ang )  A_LT_B;
				A_GT_B;
			}
			if( a->lo_ang < b->lo_ang )  A_LT_B;
			A_GT_B;
		case WEDGE_RIGHT:
			/* A is CROSS, B is RIGHT */
			if( nmg_is_wedge_before_cross( b, a ) )  A_GT_B;
			A_LT_B;
		case WEDGE_ON:
			nmg_pr_vu_stuff(a);
			nmg_pr_vu_stuff(b);
			rt_bomb("nmg_face_vu_compare() WEDGE_ON 3?\n");
		}
	case WEDGE_RIGHT:
		switch( b->wedge_class )  {
		case WEDGE_LEFT:
			diff = 360 - b->lo_ang;/* CW version of left angle */
			if( a->lo_ang <= diff )  A_LT_B;
			A_GT_B;
		case WEDGE_CROSS:
			/* A is RIGHT, B is CROSS */
			if( nmg_is_wedge_before_cross( a, b ) )  A_LT_B;
			A_GT_B;
		case WEDGE_RIGHT:
			if( lo_equal )  {
				if( a->hi_ang < b->hi_ang )  A_GT_B;
				A_LT_B;
			}
			if( a->lo_ang < b->lo_ang )  A_LT_B;
			A_GT_B;
		case WEDGE_ON:
			nmg_pr_vu_stuff(a);
			nmg_pr_vu_stuff(b);
			rt_bomb("nmg_face_vu_compare() WEDGE_ON 4?\n");
		}
	}
out:
	if(rt_g.NMG_debug&DEBUG_VU_SORT)  {
		bu_log("nmg_face_vu_compare(vu=x%x, vu=x%x) %s %s, %s\n",
			a->vu, b->vu,
			WEDGECLASS2STR(a->wedge_class),
			WEDGECLASS2STR(b->wedge_class),
			ret==(-1) ? "A<B" : (ret==0 ? "A==B" : "A>B") );
	}
	return ret;
}

/*
 *			N M G _ F A C E _ V U _ D O T
 *
 *  For the purpose of computing the dot product of the edges around
 *  this vertexuse and the ray direction vector, the edge vectors should
 *  both be pointing inwards to the vertex,
 *  rather than in the edge direction, so that it is possible to sort
 *  the vertexuse's into sequence by "angle" along the ray direction,
 *  starting with the vertexuse that the ray first encounters.
 */
static void
nmg_face_vu_dot(struct nmg_vu_stuff *vsp, struct loopuse *lu, const struct nmg_ray_state *rs, int ass)
{
	struct edgeuse	*this_eu;
	struct edgeuse	*othereu;
	vect_t		vec;
	fastf_t		dot;
	struct vertexuse	*vu;
	int		this;

	NMG_CK_RAYSTATE(rs);
	vu = vsp->vu;
	NMG_CK_VERTEXUSE(vu);
	NMG_CK_LOOPUSE(lu);
	this_eu = nmg_find_eu_with_vu_in_lu( lu, vu );

	/* First, consider the edge inbound into this vertex */
	this = NMG_V_ASSESSMENT_PREV(ass);
	if( this == NMG_E_ASSESSMENT_ON_REV )  {
		vsp->min_vu_dot = -1;		/* straight back */
	} else if( this == NMG_E_ASSESSMENT_ON_FORW )  {
		vsp->min_vu_dot = 1;		/* straight forw */
	} else {
		othereu = BU_LIST_PPREV_CIRC( edgeuse, this_eu );
		if( vu->v_p != othereu->vu_p->v_p )  {
			/* Vector from othereu to this_eu */
			VSUB2( vec, vu->v_p->vg_p->coord,
				othereu->vu_p->v_p->vg_p->coord );
			VUNITIZE(vec);
			vsp->min_vu_dot = VDOT( vec, rs->dir );
		} else {
			vsp->min_vu_dot = 99;		/* larger than +1 */
		}
	}

	/* Second, consider the edge outbound from this vertex (forw) */
	this = NMG_V_ASSESSMENT_NEXT(ass);
	if( this == NMG_E_ASSESSMENT_ON_REV )  {
		dot = -1;		/* straight back */
		if( dot < vsp->min_vu_dot )  vsp->min_vu_dot = dot;
	} else if( this == NMG_E_ASSESSMENT_ON_FORW )  {
		dot = 1;		/* straight forw */
		if( dot < vsp->min_vu_dot )  vsp->min_vu_dot = dot;
	} else {
		othereu = BU_LIST_PNEXT_CIRC( edgeuse, this_eu );
		if( vu->v_p != othereu->vu_p->v_p )  {
			/* Vector from othereu to this_eu */
			VSUB2( vec, vu->v_p->vg_p->coord,
				othereu->vu_p->v_p->vg_p->coord );
			VUNITIZE(vec);
			dot = VDOT( vec, rs->dir );
			if( dot < vsp->min_vu_dot )  {
				vsp->min_vu_dot = dot;
			}
		}
	}
}

/*
 *			N M G _ S P E C I A L _ W E D G E _ P R O C E S S I N G
 *
 *  If one loop gets cut, then unwind the whole call stack, and reassess
 *  where things stand.  (The caller needs to re-call in that case).
 *
 *  The goal here is to get rid of nested wedges.
 *  To do that, join loops wherever possible, cut them sparingly.
 *
 *  Returns -
 *	0	Nothing needed changing, OK to proceed with vertex sorting.
 *	1	Loops were cut or joined, need to reclassify everything
 *		at this vertexuse.
 */
static int
nmg_special_wedge_processing(struct nmg_vu_stuff *vs, int start, int end, double lo_ang, double hi_ang, int wclass, int *exclude, const struct bn_tol *tol)
                   	    
   	      		/* vu index of coincident range */
   	    
      	       
      	       
   	       
   	         
                   	     
{
	register int	i;
	int		outer_wedge;
	int		inner_wedge;
	int		class2;
	struct loopuse	*outer_lu;
	struct loopuse	*inner_lu;
	int		not_these[128];

	BN_CK_TOL(tol);

	if(rt_g.NMG_debug&DEBUG_VU_SORT)  {
		char			buf[128];
		FILE			*fp;
		struct model		*m;
		long			*b;
		struct bn_vlblock	*vbp;
		static int		num = 0;

		bu_log("nmg_special_wedge_processing(start=%d,end=%d, lo=%g, hi=%g, wclass=%s)\n",
			start, end, lo_ang, hi_ang,
			WEDGECLASS2STR(wclass) );
		VPRINT("\tvertex", vs[start].vu->v_p->vg_p->coord);

		/* Plot all the loops that touch here. */
		m = nmg_find_model((long *)vs[start].vu);
		b = (long *)bu_calloc( m->maxindex, sizeof(long), "nmg_special_wedge_processing flag[]" );
		vbp = rt_vlblock_init();
		for( i=start; i < end; i++ )  {
			struct loopuse	*lu;
			lu = nmg_find_lu_of_vu(vs[i].vu);
			bu_log("\tvu[%d]=x%x, lu=x%x\n", i, vs[i].vu, lu);
			nmg_vlblock_lu(vbp, lu, b, 255, 0, 0, 0, 0 );
		}
		for( i=start; i < end; i++ )  {
			struct loopuse	*lu;
			lu = nmg_find_lu_of_vu(vs[i].vu);
			nmg_pr_lu_briefly(lu,0);
		}
		sprintf(buf, "wedge%d.pl", num++);
		fp = fopen(buf, "w");
		rt_plot_vlblock( fp, vbp );
		fclose(fp);
		bu_log("wrote %s\n", buf);
		bu_free( (char *)b, "nmg_special_wedge_processing flag[]" );
		rt_vlblock_free(vbp);
	}

	if( end-start >= 128 )  rt_bomb("nmg_special_wedge_processing: array overflow\n");
	if( !exclude )  {
		bzero( (char *)not_these, sizeof(not_these) );
		exclude = not_these;
	}

again:
	/* May be many "outer" wedges to iterate over this side of line */
	outer_wedge = nmg_find_vu_in_wedge( vs, start, end,
		lo_ang, hi_ang, wclass, exclude );
	if( outer_wedge <= -1 )  return 0;	/* No wedges to process */

	exclude[outer_wedge] = 1;	/* Don't return this wedge again */

	/* There is at least one wedge on this side of the line */
	outer_lu = nmg_find_lu_of_vu( vs[outer_wedge].vu );
	NMG_CK_LOOPUSE(outer_lu);

again_inner:
	inner_wedge = nmg_find_vu_in_wedge( vs, start, end,
		vs[outer_wedge].lo_ang, vs[outer_wedge].hi_ang,
		wclass, exclude );
	if( inner_wedge <= -1 )  {
		/*
		 *  See if there is another outer wedge that starts where
		 *  outer_wedge left off.
		 *  exclude[outer_wedge] is already set.
		 */
		goto again;
	}
	if( inner_wedge == outer_wedge )  rt_bomb("nmg_special_wedge_processing() identical vu selections?\n");

	class2 = nmg_compare_2_wedges( vs[outer_wedge].lo_ang, vs[outer_wedge].hi_ang,
		vs[inner_wedge].lo_ang, vs[inner_wedge].hi_ang );
	if(rt_g.NMG_debug&DEBUG_VU_SORT)
		bu_log("+++nmg_special_wedge_processing() outer=%d, inner=%d, class2=%s\n", outer_wedge, inner_wedge, WEDGE2_TO_STRING(class2) );

	inner_lu = nmg_find_lu_of_vu( vs[inner_wedge].vu );
	NMG_CK_LOOPUSE(inner_lu);

	if( outer_lu == inner_lu )  {
		struct loopuse	*new_lu;
		if( class2 == WEDGE2_IDENTICAL &&
		    NEAR_ZERO( vs[inner_wedge].hi_ang - vs[inner_wedge].lo_ang, WEDGE_ANG_TOL )
		    )  {
#if 0
rt_g.NMG_debug |= DEBUG_VU_SORT|DEBUG_FCUT;
#endif
			if(rt_g.NMG_debug&DEBUG_VU_SORT)
				bu_log("nmg_special_wedge_processing:  inner and outer wedges from same loop, WEDGE2_IDENTICAL & 0deg spread, already in final form.\n");
			exclude[inner_wedge] = 1;	/* Don't return this wedge again */
			/* Don't need to recurse only because this is a crack */
			goto again_inner;
		}
		if(rt_g.NMG_debug&DEBUG_VU_SORT)
			bu_log("nmg_special_wedge_processing:  inner and outer wedges from same loop, cutting loop\n");
		new_lu = nmg_cut_loop( vs[outer_wedge].vu, vs[inner_wedge].vu );
		NMG_CK_LOOPUSE(new_lu);
		NMG_CK_LOOPUSE(inner_lu);
		nmg_loop_g( inner_lu->l_p, tol );
		nmg_loop_g( new_lu->l_p, tol );
		nmg_lu_reorient(inner_lu);
		nmg_lu_reorient(new_lu);
		return 1;		/* cutjoin was done */
	}

	/* XXX Or they could be WEDGE2_IDENTICAL */
	/* XXX If WEDGE2_IDENTICAL, could we join and then simplify? */
	if(rt_g.NMG_debug&DEBUG_VU_SORT)
		bu_log("wedge at vu[%d] is inside wedge at vu[%d]\n", inner_wedge, outer_wedge);

	if( outer_lu->orientation == inner_lu->orientation )  {
		/*
		 *  Two loops meet at this vu.  Joining them will impose
		 *  a natural edgeuse ordering onto the vu's.
		 */
		if(rt_g.NMG_debug&DEBUG_VU_SORT)
			bu_log("joining loops\n");
		vs[inner_wedge].vu = nmg_join_2loops( vs[outer_wedge].vu,
			vs[inner_wedge].vu );
		nmg_loop_g( outer_lu->l_p, tol );
		return 1;		/* cutjoin was done */
	}

	/* Recurse on inner wedge */
	if( nmg_special_wedge_processing( vs, start, end,
	    vs[inner_wedge].lo_ang, vs[inner_wedge].hi_ang, wclass, exclude, tol ) )
		return 1;	/* An inner wedge was cut */

	/*
	 *  Inner and outer are different loopuses,
	 *  have different orientations,
	 *  and have nothing complex inside the wedge of the inner loop.
	 *  Join inner and outer loops here, to impose a proper vu ordering.
	 */
	if(rt_g.NMG_debug&DEBUG_VU_SORT)
		bu_log("Inner wedge is simple, join inner and outer loops.\n");

	vs[inner_wedge].vu = nmg_join_2loops( vs[outer_wedge].vu,
		vs[inner_wedge].vu );
	nmg_loop_g( outer_lu->l_p, tol );
	return 1;		/* cutjoin was done */
}

/*
 *			N M G _ F A C E _ C O I N C I D E N T _ V U _ S O R T
 *
 *  Given co-incident vertexuses (same distance along the ray),
 *  sort them into the "proper" order for driving the state machine.
 */
int
nmg_face_coincident_vu_sort(struct nmg_ray_state *rs, int start, int end)
                    	    
   			      		/* first index */
   			    		/* last index + 1 */
{
	int		num;
	struct nmg_vu_stuff	*vs;
	struct nmg_loop_stuff *ls;
	int		nloop;
	unsigned	nvu;
	int		i;
	struct loopuse	*lu;
	int		ass;
	int		l;
	int		retries = 0;

	if(rt_g.NMG_debug&DEBUG_VU_SORT)
		bu_log("nmg_face_coincident_vu_sort(, %d, %d) START\n", start, end);

	NMG_CK_RAYSTATE(rs);

	num = end - start;
	vs = (struct nmg_vu_stuff *)bu_malloc( sizeof(struct nmg_vu_stuff)*num,
		"nmg_vu_stuff" );
	ls = (struct nmg_loop_stuff *)bu_malloc( sizeof(struct nmg_loop_stuff)*num,
		"nmg_loop_stuff" );

top:
#if 0
	if( retries > 20 )  rt_g.NMG_debug |= DEBUG_VU_SORT;
#endif
	if( retries++ > 24 )  rt_bomb("nmg_face_coincident_vu_sort() infinite loop\n");
	/* Assess each vu, create list of loopuses, find max angles */
	nloop = 0;
	nvu = 0;
	for( i = end-1; i >= start; i-- )  {
		lu = nmg_find_lu_of_vu( rs->vu[i] );
		NMG_CK_LOOPUSE(lu);
		ass = nmg_assess_vu( rs, i );
		if(rt_g.NMG_debug&DEBUG_VU_SORT)
		   bu_log("vu[%d]=x%x v=x%x assessment=%s\n",
			i, rs->vu[i], rs->vu[i]->v_p, nmg_v_assessment_names[ass] );
		/*  Ignore lone vertices, unless that is all that there is,
		 *  in which case, let just one through.  (return 'start+1');
		 */
		if( *(rs->vu[i]->up.magic_p) == NMG_LOOPUSE_MAGIC )  {
			if( nvu > 0 || i > start )  {
				/* Drop this loop of a single vertex in sanitize() */
				lu->orientation =
				  lu->lumate_p->orientation = OT_BOOLPLACE;
				/* "continue" keeps vu from being added to vs[] */
				continue;
			}
		}

		vs[nvu].vu = rs->vu[i];
		vs[nvu].seq = -1;		/* Not assigned yet */

		/* x_dir is -dir, y_dir is -left */
		vs[nvu].in_vu_angle = nmg_vu_angle_measure( rs->vu[i],
			rs->ang_x_dir, rs->ang_y_dir, ass, 1 ) * bn_radtodeg;
		vs[nvu].out_vu_angle = nmg_vu_angle_measure( rs->vu[i],
			rs->ang_x_dir, rs->ang_y_dir, ass, 0 ) * bn_radtodeg;

		/* Special case for LEFT & ON combos */
		if( ass == NMG_V_COMB(NMG_E_ASSESSMENT_ON_FORW, NMG_E_ASSESSMENT_LEFT) )
			vs[nvu].in_vu_angle = 360;
		else if( ass == NMG_V_COMB(NMG_E_ASSESSMENT_LEFT, NMG_E_ASSESSMENT_ON_REV) )
			vs[nvu].out_vu_angle = 360;

		vs[nvu].wedge_class = nmg_wedge_class( ass, vs[nvu].in_vu_angle, vs[nvu].out_vu_angle );
		if(rt_g.NMG_debug&DEBUG_VU_SORT) bu_log("nmg_wedge_class = %d %s\n", vs[nvu].wedge_class, WEDGECLASS2STR(vs[nvu].wedge_class));
		/* Sort the angles (Don't forget to sort for CROSS case too) */
		if( (vs[nvu].wedge_class == WEDGE_LEFT && vs[nvu].in_vu_angle > vs[nvu].out_vu_angle) ||
		    (vs[nvu].wedge_class != WEDGE_LEFT && vs[nvu].in_vu_angle < vs[nvu].out_vu_angle) )  {
			vs[nvu].lo_ang = vs[nvu].in_vu_angle;
			vs[nvu].hi_ang = vs[nvu].out_vu_angle;
		} else {
			vs[nvu].lo_ang = vs[nvu].out_vu_angle;
			vs[nvu].hi_ang = vs[nvu].in_vu_angle;
		}

		/* Check entering and departing edgeuse angle w.r.t. ray */
		/* This is already done once in nmg_assess_vu();  reuse? */
		/* Computes vs[nvu].min_vu_dot */
		nmg_face_vu_dot( &vs[nvu], lu, rs, ass );

		/* Search for loopuse table entry */
		for( l = 0; l < nloop; l++ )  {
			if( ls[l].lu == lu )  goto got_loop;
		}
		/* didn't find loopuse in table, add to table */
		l = nloop++;
		ls[l].lu = lu;
		ls[l].n_vu_in_loop = 0;
		ls[l].min_dot = 99;		/* > +1 */
got_loop:
		ls[l].n_vu_in_loop++;
		vs[nvu].loop_index = l;
		vs[nvu].lsp = &ls[l];
		if( vs[nvu].min_vu_dot < ls[l].min_dot )  {
			ls[l].min_dot = vs[nvu].min_vu_dot;
			ls[l].min_vu = vs[nvu].vu;
		}
		nvu++;
	}

	/*
	 *  For each loop which has more than one vertexuse present on the
	 *  ray, start at the vu which has the smallest angle off the ray,
	 *  and walk the edges of the loop, marking off the vu sequence for
	 *  those vu's on the ray (those vu's found in vs[].vu).
	 */
	for( l=0; l < nloop; l++ )  {
		register struct edgeuse	*eu;
		struct edgeuse	*first_eu;
		int		seq = 0;

		if( ls[l].n_vu_in_loop <= 1 )  continue;

		first_eu = nmg_find_eu_with_vu_in_lu( ls[l].lu, ls[l].min_vu );
		eu = first_eu;
		do {
			register struct vertexuse *vu = eu->vu_p;
			NMG_CK_VERTEXUSE(vu);
			for( i=0; i < nvu; i++ )  {
				if( vs[i].vu == vu )  {
					vs[i].seq = seq++;
					break;
				}
			}
			eu = BU_LIST_PNEXT_CIRC(edgeuse,eu);
		} while( eu != first_eu );
	}

	/* For loops with >1 crossings here, determine proper VU ordering on that loop */
	/* XXX */

	/* Here is where the special wedge-breaking code goes */
	if( nmg_special_wedge_processing( vs, 0, nvu, 0.0, 180.0, WEDGE_RIGHT, (int *)0, rs->tol ) )  {
		if(rt_g.NMG_debug&DEBUG_VU_SORT)
			bu_log("*** nmg_face_coincident_vu_sort(, %d, %d) restarting after 0--180 wedge\n", start, end);
		goto top;
	}
	/* XXX reclass on/on edges from WEDGE_RIGHT to WEDGE_LEFT here? */
	if( nmg_special_wedge_processing( vs, 0, nvu, 360.0, 180.0, WEDGE_LEFT, (int *)0, rs->tol ) ) {
		if(rt_g.NMG_debug&DEBUG_VU_SORT)
			bu_log("*** nmg_face_coincident_vu_sort(, %d, %d) restarting after 180-360 wedge\n", start, end);
		goto top;
	}

	if(rt_g.NMG_debug&DEBUG_VU_SORT)
	{
		bu_log("Loop table (before sort):\n");
		for( l=0; l < nloop; l++ )  {
			bu_log("  index=%d, lu=x%x, min_dot=%g, #vu=%d\n",
				l, ls[l].lu, ls[l].min_dot,
				ls[l].n_vu_in_loop );
		}
	}

	/* Sort the vertexuse table into appropriate order */
	qsort( (genptr_t)vs, (unsigned)nvu, (unsigned)sizeof(*vs),
		nmg_face_vu_compare );

	if(rt_g.NMG_debug&DEBUG_VU_SORT)
	{
		bu_log("Vertexuse table (after sort):\n");
		for( i=0; i < nvu; i++ )  {
			bu_log("  x%x, l=%d, in/o=(%g, %g), lo/hi=(%g,%g), %s, sq=%d\n",
				vs[i].vu, vs[i].loop_index,
				vs[i].in_vu_angle, vs[i].out_vu_angle,
				vs[i].lo_ang, vs[i].hi_ang,
				WEDGECLASS2STR(vs[i].wedge_class),
				vs[i].seq );
		}
	}

	/* Copy new vu's back to main array */
#if 0
	/* XXX I'm not sure if this is right or not */
	if( rs->state == NMG_STATE_IN )  {
		/*
		 *  If the state is IN, then need to traverse the vertexuse's
		 *  in the opposite order.
		 *  All the sorting is done from the point of view of
		 *  being in OUT state.
		 */
		if(rt_g.NMG_debug&DEBUG_VU_SORT)
			bu_log("Reversed processing order, state=IN.\n");
		for( i=0; i < nvu; i++ )  {
			rs->vu[start+i] = vs[nvu-1-i].vu;
		}
	} else
#endif
	{
		for( i=0; i < nvu; i++ )  {
			rs->vu[start+i] = vs[i].vu;
		}
	}
	if(rt_g.NMG_debug&DEBUG_VU_SORT)  {
		for( i=0; i < nvu; i++ )  {
			bu_log(" vu[%d]=x%x, v=x%x\n",
				start+i, rs->vu[start+i], rs->vu[start+i]->v_p );
		}
	}

	bu_free( (char *)vs, "nmg_vu_stuff");
	bu_free( (char *)ls, "nmg_loop_stuff");

	if(rt_g.NMG_debug&DEBUG_VU_SORT)
		bu_log("nmg_face_coincident_vu_sort(, %d, %d) END, ret=%d\n", start, end, start+nvu);

	return start+nvu;
}

/*
 *			N M G _ S A N I T I Z E _ F U
 *
 *  Eliminate any OT_BOOLPLACE self-loops that remain behind in this face.
 */
void
nmg_sanitize_fu(struct faceuse *fu)
{
	struct loopuse	*lu;
	struct loopuse	*lunext;

	NMG_CK_FACEUSE(fu);

	lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
	while( BU_LIST_NOT_HEAD(lu, &fu->lu_hd) )  {
		NMG_CK_LOOPUSE(lu);
		lunext = BU_LIST_PNEXT(loopuse,lu);
		if( lu->orientation == OT_BOOLPLACE )  {
			/* XXX What to do with return code? */
			if( nmg_klu(lu) )  rt_bomb("nmg_sanitize_fu() nmg_klu() emptied face?\n");
		}
		lu = lunext;
	}
}

/*
 *			N M G _ F A C E _ R S _ I N I T
 *
 *  Set up nmg_ray_state structure.
 *  "left" is a vector that lies in the plane of the face
 *  which contains the loops being operated on.
 *  It points in the direction "left" of the ray, such that the first
 *  OT_SAME loop in the first OT_SAME fact that it crosses will cross
 *  the ray in a left-to-right manner consistent with the CCW loop rule.
 *  There are some special conditions placed on the "dir" argument to
 *  make this happen;  see the comments in nmg_inter.c for details, or
 *  Mike's notes "The 'Left' Vector Choice" dated 27-Aug-93, page 1.
 */
void
nmg_face_rs_init(struct nmg_ray_state *rs, struct bu_ptbl *b, struct faceuse *fu1, struct faceuse *fu2, fastf_t *pt, fastf_t *dir, struct edge_g_lseg *eg, const struct bn_tol *tol)
                    	    
              	   		/* table of vertexuses in fu1 on intercept line */
              	     		/* face being worked */
              	     		/* for plane equation */
       		   
      		    
                  		    	/* may be null.  Geom of isect line. */
                   	     
{
	plane_t	n1;

	BN_CK_TOL(tol);
	BU_CK_PTBL(b);
	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);
	if(eg)  NMG_CK_EDGE_G_LSEG(eg);

	bzero( (char *)rs, sizeof(*rs) );
	rs->magic = NMG_RAYSTATE_MAGIC;
	rs->tol = tol;
	rs->vu = (struct vertexuse **)b->buffer;
	rs->nvu = b->end;
	rs->eg_p = eg;
	rs->sA = fu1->s_p;
	rs->sB = fu2->s_p;
	rs->fu1 = fu1;
	rs->fu2 = fu2;
	VMOVE( rs->pt, pt );
	VMOVE( rs->dir, dir );
	NMG_GET_FU_PLANE( n1, fu1 );
	VCROSS( rs->left, n1, dir );
	VUNITIZE( rs->left );
	switch( fu1->orientation )  {
	case OT_SAME:
		break;
	case OT_OPPOSITE:
		VREVERSE(rs->left, rs->left);
		break;
	default:
		rt_bomb("nmg_face_rs_init: bad orientation\n");
	}
	if(rt_g.NMG_debug&DEBUG_FCUT)  {
		struct loopuse *lu;
		struct edgeuse *eu;
		struct vertexuse *vu;
		int i;

		bu_log("\tfu->orientation=%s\n", nmg_orientation(fu1->orientation) );
		HPRINT("\tfg N", n1);
		VPRINT("\t  pt", pt);
		VPRINT("\t dir", dir);
		VPRINT("\tleft", rs->left);
		bu_log( "\tvertexuses in fu that are on lintersect line:\n" );
		for( i=0 ; i<BU_PTBL_END( b ) ; i++ )
		{
			vu = (struct vertexuse *)BU_PTBL_GET( b , i );
			nmg_pr_vu_briefly( vu , "\t  " );
		}
		bu_log( "\tLoopuse in fu (x%x):\n" , fu1 );
		for( BU_LIST_FOR( lu , loopuse , &fu1->lu_hd ) )
		{
			bu_log( "\tLOOPUSE x%x:\n" , lu );
			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
			{
				vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
				nmg_pr_vu_briefly( vu , "\tVertex Loop: " );
			}
			else
			{
				for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
				{
					struct edgeuse *eu_next;
					vect_t eu_dir;
					fastf_t eu_len;
					double inv_len;

					nmg_pr_eu_briefly( eu , "\t\t" );
					eu_next = BU_LIST_PNEXT_CIRC( edgeuse , eu );
					VSUB2( eu_dir , eu_next->vu_p->v_p->vg_p->coord , eu->vu_p->v_p->vg_p->coord );
					eu_len = MAGNITUDE( eu_dir );
					if( eu_len < VDIVIDE_TOL )
						inv_len = 0.0;
					else
						inv_len = 1.0/eu_len;
					for( i=0 ; i<3 ; i++ )
						eu_dir[i] = eu_dir[i] * inv_len;
					bu_log( "\t\t\teu_dir = ( %g , %g , %g ), length = %g\n", V3ARGS( eu_dir ) , eu_len );
				}
			}
		}
	}
	rs->state = NMG_STATE_OUT;

	/* For measuring angle CCW around plane from -dir */
	VREVERSE( rs->ang_x_dir, dir );
	VREVERSE( rs->ang_y_dir, rs->left );
}

/*
 *			N M G _ F A C E _ N E X T _ V U _ I N T E R V A L
 *
 *  Handle the extent of coincident vertexuses at this distance.
 *  ptbl_vsort() will have forced all the distances to be
 *  exactly equal if they are within tolerance of each other.
 *
 *  Two cases:  lone vertexuse, and range of vertexuses.
 *
 *  Return value is where next interval starts.
 */
HIDDEN int
nmg_face_next_vu_interval(struct nmg_ray_state *rs, int cur, fastf_t *mag, int other_rs_state)
{
	int	j;
	int	k;
	int	m;
	struct vertex	*v;

	NMG_CK_RAYSTATE(rs);
	BN_CK_TOL(rs->tol);
	if(rs->eg_p) NMG_CK_EDGE_G_LSEG(rs->eg_p);

	if( cur == rs->nvu-1 || mag[cur+1] != mag[cur] )  {
		/* Single vertexuse at this dist */
		if(rt_g.NMG_debug&DEBUG_FCUT)
			bu_log("nmg_face_next_vu_interval() fu=x%x, single vertexuse at index %d\n", rs->fu1, cur);
		nmg_face_state_transition( rs, cur, 0, other_rs_state );
#if PLOT_BOTH_FACES
		nmg_2face_plot( rs->fu1, rs->fu2 );
#else
		nmg_face_plot( rs->fu1 );
#endif
		return cur+1;
	}

	/* Find range of vertexuses at this distance */
	v = rs->vu[cur]->v_p;
	for( j = cur+1; j < rs->nvu; j++ )  {
		/* If distance along the ray changes, start a new interval */
		if( mag[j] != mag[cur] )  break;
#if 0
		/* If vertex changes, it starts a new interval */
		/* XXX Note that they will be sorted by pointer addres. */
		/* XXX This might cause inconsistencies later */
		if( rs->vu[j]->v_p != v )  break;
#endif
	}

	/* vu Interval runs from [cur] to [j-1] inclusive */
	if(rt_g.NMG_debug&DEBUG_FCUT)
		bu_log("nmg_face_next_vu_interval() fu=x%x vu's on list interval [%d] to [%d] equal\n", rs->fu1, cur, j-1 );

	/* Ensure that all vu's point to same vertex */
	for( k = cur+1; k < j; k++ )  {
		if( rs->vu[k]->v_p == v )  continue;
		/* Trouble.  Print out the interval and die */
		bu_log("At k=%d, vertex changed from v=x%x!\n", k, v);
		bu_log("pt_equality=%d\n", bn_pt3_pt3_equal(v->vg_p->coord,
			rs->vu[k]->v_p->vg_p->coord, rs->tol ) );
		for( k = cur; k < j; k++ )  {
			bu_log("  %d vu=%8x v=%8x mag=%g\n", k,
				rs->vu[k], rs->vu[k]->v_p, mag[k] );
			NMG_CK_VERTEX_G(rs->vu[k]->v_p->vg_p);
			VPRINT("\tpt", rs->vu[k]->v_p->vg_p->coord);
		}
		rt_bomb("nmg_face_combine: vu block with differing vertices\n");
	}
	/* All vu's point to the same vertex, sort them */
	m = nmg_face_coincident_vu_sort( rs, cur, j );

	/* Process vu list, up to cutoff index 'm', which can be less than j */
	for( k = cur; k < m; k++ )  {
		nmg_face_state_transition( rs, k, 1, other_rs_state );
#if PLOT_BOTH_FACES
		nmg_2face_plot( rs->fu1, rs->fu2 );
#else
		nmg_face_plot( rs->fu1 );
#endif
	}
	rs->vu[j-1] = rs->vu[m-1]; /* for next iteration's lookback */
	if(rt_g.NMG_debug&DEBUG_FCUT)
		bu_log("nmg_face_next_vu_interval() vu[%d] set to x%x\n", j-1, rs->vu[j-1] );
	return j;
}

#define	VAVERAGE( a, b, c )	{ \
	(a)[X] = ((b)[X] + (c)[X]) * 0.5;\
	(a)[Y] = ((b)[Y] + (c)[Y]) * 0.5;\
	(a)[Z] = ((b)[Z] + (c)[Z]) * 0.5;\
	}
/*
 *			N M G _ E D G E _ G E O M _ I S E C T _ L I N E
 *
 *  Force the geometry structure for a given edge to be that of
 *  the intersection line between the two faces.
 *
 *  Note that sometimes a vertex can appear to lie on more than one
 *  line.  It is important to refer to geometry here, to make sure
 *  that the edgeuse is not mistakenly fused to the wrong edge geometry.
 *
 *  XXX This has the byproduct that not all edgeuses "on" the line
 *  XXX of intersection will share rs->eg_p.
 *
 *  See the comments in nmg_radial_join_eu() for the rationale.
 */
void
nmg_edge_geom_isect_line(struct edgeuse *eu, struct nmg_ray_state *rs, const char *reason)
{
	register struct edge_g_lseg	*eg;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_RAYSTATE(rs);
	if(eu->g.lseg_p) NMG_CK_EDGE_G_LSEG(eu->g.lseg_p);
	if(rs->eg_p) NMG_CK_EDGE_G_LSEG(rs->eg_p);

	if(rt_g.NMG_debug&DEBUG_FCUT)  {
		bu_log("nmg_edge_geom_isect_line(eu=x%x, %s)\n eu->g=x%x, rs->eg=x%x at START\n",
			eu, reason,
			eu->g.magic_p, rs->eg_p);
	}
	if( !eu->g.magic_p )  {
		/* This edgeuse has No edge geometry so far.
		 * It may be a new edge formed by a CUTJOIN operation.
		 */
		if( !rs->eg_p )  {
			nmg_edge_g( eu );
			eg = eu->g.lseg_p;
			NMG_CK_EDGE_G_LSEG(eg);
			VMOVE( eg->e_pt, rs->pt );
			VMOVE( eg->e_dir, rs->dir );
			rs->eg_p = eg;
		} else {
			NMG_CK_EDGE_G_LSEG(rs->eg_p);
			nmg_use_edge_g( eu, (long *)rs->eg_p );
		}
		goto out;
	}
	/* Edge has edge geometry */
	if( eu->g.lseg_p == rs->eg_p )  return;	/* nothing changes */
	if( !rs->eg_p )  {
		/* This is first edge_g found on isect line, remember it */
		eg = eu->g.lseg_p;
		NMG_CK_EDGE_G_LSEG(eg);
		rs->eg_p = eg;
		goto out;
	}

	/*
	 * Edge has an edge geometry struct, different from that of isect line.
	 * Force all uses of this edge geom to take on isect line's geometry.
	 * Everywhere eu->g.lseg_p is seen, replace with rs->eg_p.
	 *
	 *  XXX This is DUBIOUS, as the angle might be very different.
	 */
	nmg_jeg( rs->eg_p, eu->g.lseg_p );
out:
	NMG_CK_EDGE_G_LSEG(rs->eg_p);
	if(rt_g.NMG_debug&DEBUG_FCUT)  {
		bu_log("nmg_edge_geom_isect_line(eu=x%x) g=x%x, rs->eg=x%x at END\n",
			eu, eu->g.magic_p, rs->eg_p);
	}
}

static struct bu_ptbl *
find_loop_to_cut(int *index1, int *index2, int prior_start, int prior_end, int next_start, int next_end, fastf_t *mid_pt, struct nmg_ray_state *rs)
{
	struct loopuse *lu1,*lu2;
	struct vertexuse *vu1 = (struct vertexuse *)NULL;
	struct vertexuse *vu2 = (struct vertexuse *)NULL;
	struct loopuse *match_lu=(struct loopuse *)NULL;
	struct loopuse *prior_lu,*next_lu;
	struct bu_ptbl *cuts=(struct bu_ptbl *)NULL;
	struct loop_cuts *lcut;
	int count=0;
	int i,j,k;
	int done=0;

	if(rt_g.NMG_debug&DEBUG_FCUT)
		bu_log( "find_loop_to_cut: prior_start=%d, prior_end=%d, next_start=%d, next_end=%d, rs=x%x\n",
			prior_start, prior_end, next_start, next_end, rs );

	NMG_CK_RAYSTATE(rs);

	/* check if any coincident VU's can give us a loop to cut */
	while( !done )
	{
		done = 1;
		count++;
		if( count > 100 )
		{
			bu_log( "find_loop_to_cut: infinite loop\n" );
			bu_log( "prior_start = %d, prior_end = %d, next_start = %d next_nd = %d\n",
				prior_start, prior_end, next_start, next_end );
			bu_log( "mid_point = ( %f %f %f )\n", V3ARGS( mid_pt ) );
			for( i=0 ; i<rs->nvu ; i++ )
				bu_log( "\t%d x%x\n", i, rs->vu[i] );
			rt_bomb( "find_loop_to_cut: infinite loop" );
		}
		for( i=prior_start ; i < prior_end ; i++ )
		{
			int class_pt;

			prior_lu = nmg_find_lu_of_vu( rs->vu[i] );
			class_pt = NMG_CLASS_Unknown;
			for( j=next_start ; j < next_end ; j++ )
			{
				next_lu = nmg_find_lu_of_vu( rs->vu[j] );
				if( prior_lu == next_lu )
				{
					int class_lu;

					if( !match_lu )
					{
						match_lu = next_lu;
						cuts = (struct bu_ptbl *)bu_malloc( sizeof( struct bu_ptbl ), "cuts" );
						bu_ptbl_init( cuts, 64, " cuts");
						lcut = (struct loop_cuts *)bu_malloc( sizeof( struct loop_cuts ), "lcut" );
						lcut->lu = match_lu;
						bu_ptbl_ins( cuts, (long *)lcut );
						continue;
					}

					if( match_lu == next_lu )
						continue;

					if( class_pt == NMG_CLASS_Unknown )
					{
						class_pt = nmg_class_pt_lu_except( mid_pt,
							match_lu, (struct edge *)NULL, rs->tol );
						if( match_lu->orientation == OT_OPPOSITE )
						{
							if( class_pt == NMG_CLASS_AinB )
								class_pt = NMG_CLASS_AoutB;
							else if( class_pt == NMG_CLASS_AoutB )
								class_pt = NMG_CLASS_AinB;
						}
					}
					class_lu = nmg_classify_lu_lu( next_lu, match_lu, rs->tol );

					if( class_lu == class_pt ||
						class_lu == NMG_CLASS_AonBshared )
					{
						int found=0;

						match_lu = next_lu;
						for( k=0 ; k<BU_PTBL_END( cuts ) ; k++ )
						{
							lcut = (struct loop_cuts *)BU_PTBL_GET( cuts , k );
							if( lcut->lu == match_lu )
							{
								found = 1;
								break;
							}
						}
						if( !found )
						{
							done = 0;
							lcut = (struct loop_cuts *)bu_malloc( sizeof( struct loop_cuts ), "lcut" );
							lcut->lu = match_lu;
							bu_ptbl_ins( cuts, (long *)lcut );
						}
					}
				}
			}
		}
	}

	if( cuts )
	{
		for( k=0 ; k<BU_PTBL_END( cuts ) ; k++ )
		{
			lcut = (struct loop_cuts *)BU_PTBL_GET( cuts, k );
			match_lu = lcut->lu;

			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log( "\tfind_loop_to_cut: matching lu's = x%x\n", match_lu );
			lu1 = match_lu;
			for( i=prior_start ; i < prior_end ; i++ )
			{
				if( nmg_find_lu_of_vu( rs->vu[i] ) == lu1 )
				{
					*index1 = i;
					vu1 = rs->vu[i];
					lcut->vu1 = vu1;
					break;
				}
			}
			lu2 = match_lu;
			for( i=next_start ; i < next_end ; i++ )
			{
				if( nmg_find_lu_of_vu( rs->vu[i] ) == lu2 )
				{
					*index2 = i;
					vu2 = rs->vu[i];
					lcut->vu2 = vu2;
					break;
				}
			}
		}
	}
	else
	{
		if(rt_g.NMG_debug&DEBUG_FCUT)
			bu_log( "\tfind_loop_to_cut returning 0\n" );
		return( (struct bu_ptbl *)NULL );
	}

	for( k=0 ; k<BU_PTBL_END( cuts ) ; k++ )
	{
		lcut = (struct loop_cuts *)BU_PTBL_GET( cuts, k );
		lu1 = lcut->lu;
		lu2 = lu1;

		/* Check if there is more than one VU from lu2 */
		count = 0;
		for( i=next_start ; i<next_end ; i++ )
		{
			if( nmg_find_lu_of_vu( rs->vu[i] ) == lu2 )
				count++;
		}

		if( count > 1 )
		{
			struct vertexuse *vu_best;
			fastf_t vu_angle;
			vect_t x_dir,y_dir;
			vect_t norm;

			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log( "\tfind_loop_to_cut: %d VU's from lu x%x\n", count, lu2 );

			/* need to select correct VU */
			vu_angle = (-bn_pi);
			vu_best = (struct vertexuse *)NULL;

			VSUB2( x_dir, vu2->v_p->vg_p->coord, vu1->v_p->vg_p->coord );
			VUNITIZE( x_dir );
			NMG_GET_FU_NORMAL( norm, rs->fu1 );

			VCROSS( y_dir, norm, x_dir );
			VUNITIZE( y_dir );

			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log( "\tx_dir=(%g %g %g), y_dir=(%g %g %g)\n",
					V3ARGS( x_dir ), V3ARGS( y_dir ) );

			for( i=next_start ; i<next_end ; i++ )
			{
				struct edgeuse *eu;
				fastf_t angle;
				vect_t eu_dir;


				if( nmg_find_lu_of_vu( rs->vu[i] ) != lu2 )
					continue;

				if( *(rs->vu[i]->up.magic_p) != NMG_EDGEUSE_MAGIC )
				{
					bu_log( "nmg_fcut_face: VU (x%x) is not from an EU\n", rs->vu[i] );
					rt_bomb( "nmg_fcut_face: VU is not from an EU" );
				}

				/* calculate angle this EU will make with edgeuse
				 * that will be created by the cut/join
				 */
				eu = rs->vu[i]->up.eu_p;
				VSUB2( eu_dir, eu->eumate_p->vu_p->v_p->vg_p->coord, eu->vu_p->v_p->vg_p->coord );
				angle = atan2( VDOT( y_dir,eu_dir ), VDOT( x_dir, eu_dir ) );

				if(rt_g.NMG_debug&DEBUG_FCUT)
					bu_log( "\tangle for eu x%x (vu=x%x, #%d) is %g\n",
						eu, rs->vu[i], i, angle );

				/* select max angle */
				if( angle > vu_angle )
				{
					if(rt_g.NMG_debug&DEBUG_FCUT)
						bu_log( "\t\tabove is the new best VU\n" );
					vu_angle = angle;
					vu_best = rs->vu[i];
					*index2 = i;
				}
			}

			if( vu_best )
			{
				vu2 = vu_best;
				lcut->vu2 = vu2;
			}

			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log( "\tfind_loop_to_cut: selecting VU2 x%x\n", vu2 );
		}

		/* Check for duplicate cuts (cutting two different loops across same two vertices) */
		if( BU_PTBL_END( cuts ) > 1 )
		{
			for( i=0 ; i<BU_PTBL_END( cuts ) ; i++ )
			{
				struct loop_cuts *lcut1, *lcut2;
				int class1, class2;

				lcut1 = (struct loop_cuts *)BU_PTBL_GET( cuts, i );
				for( j=i+1 ; j<BU_PTBL_END( cuts ) ; j++ )
				{
					lcut2 = (struct loop_cuts *)BU_PTBL_GET( cuts, j );

					if( lcut1->vu1->v_p != lcut2->vu1->v_p ||
					    lcut1->vu2->v_p != lcut2->vu2->v_p )
						continue;

					/* lcut1 and lcut2 are the same cut, choose one loop to cut */
					if( lcut1->lu->orientation == OT_OPPOSITE &&
						lcut2->lu->orientation == OT_OPPOSITE )
					{
						bu_log( "find_loop_to_cut: Two OT_OPPOSITE loops to be cut?? x%x and x%x\n",
							lcut1->lu, lcut2->lu );
						bu_bomb( "find_loop_to_cut: Two OT_OPPOSITE loops to be cut??\n" );
					}
					if( lcut1->lu->orientation == OT_OPPOSITE )
					{
						/* don't cut an OT_OPPOSITE loop */
						bu_ptbl_rm( cuts, (long *)lcut1 );
						break;
					}
					if( lcut2->lu->orientation == OT_OPPOSITE )
					{
						/* don't cut an OT_OPPOSITE loop */
						bu_ptbl_rm( cuts, (long *)lcut2 );
						break;
					}
					class1 = nmg_class_pt_lu_except( mid_pt, lcut1->lu,
						(struct edge *)NULL, rs->tol );
					class2 = nmg_class_pt_lu_except( mid_pt, lcut2->lu,
						(struct edge *)NULL, rs->tol );

					if( class1 == NMG_CLASS_AoutB && class2 == NMG_CLASS_AoutB )
					{
						bu_log( "find_loop_to_cut: mid point is outside both loops??? x%x and x%x pt=(%g %g %g)\n",
							lcut1->lu, lcut2->lu, V3ARGS( mid_pt ) );
						bu_bomb( "find_loop_to_cut: mid point is outside both loops???\n" );
					}

					if( class1 == NMG_CLASS_AoutB )
					{
						/* Don't cut this loop (cut is outside loop) */
						bu_ptbl_rm( cuts, (long *)lcut1 );
						break;
					}
					if( class2 == NMG_CLASS_AoutB )
					{
						/* Don't cut this loop (cut is outside loop) */
						bu_ptbl_rm( cuts, (long *)lcut2 );
						break;
					}
				}
			}
		}

		/* Check if there is more than one VU from lu1 */
		count = 0;
		for( i=prior_start ; i<prior_end ; i++ )
		{
			if( nmg_find_lu_of_vu( rs->vu[i] ) == lu1 )
				count++;
		}

		if( count > 1 )
		{
			struct vertexuse *vu_best;

			fastf_t vu_angle;
			vect_t x_dir,y_dir;
			vect_t norm;

			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log( "\tfind_loop_to_cut: %d VU's from lu x%x\n", count, lu1 );

			/* need to select correct VU */
			vu_angle = (-bn_pi);
			vu_best = (struct vertexuse *)NULL;

			VSUB2( x_dir, vu1->v_p->vg_p->coord, vu2->v_p->vg_p->coord );
			VUNITIZE( x_dir );
			NMG_GET_FU_NORMAL( norm, rs->fu1 );

			VCROSS( y_dir, norm, x_dir );
			VUNITIZE( y_dir );

			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log( "\tx_dir=(%g %g %g), y_dir=(%g %g %g)\n",
					V3ARGS( x_dir ), V3ARGS( y_dir ) );

			for( i=prior_start ; i<prior_end ; i++ )
			{
				struct edgeuse *eu;
				fastf_t angle;
				vect_t eu_dir;

				if( nmg_find_lu_of_vu( rs->vu[i] ) != lu1 )
					continue;

				if( *(rs->vu[i]->up.magic_p) != NMG_EDGEUSE_MAGIC )
				{
					bu_log( "nmg_fcut_face: VU (x%x) is not from an EU\n", rs->vu[i] );
					rt_bomb( "nmg_fcut_face: VU is not from an EU" );
				}

				/* calculate angle this EU will make with edgeuse
				 * that will be created by the cut/join
				 */
				eu = rs->vu[i]->up.eu_p;
				VSUB2( eu_dir, eu->eumate_p->vu_p->v_p->vg_p->coord, eu->vu_p->v_p->vg_p->coord );
				angle = atan2( VDOT( y_dir,eu_dir ), VDOT( x_dir, eu_dir ) );

				if(rt_g.NMG_debug&DEBUG_FCUT)
					bu_log( "\tangle for eu x%x (vu=x%x, #%d) is %g\n",
						eu, rs->vu[i], i, angle );

				/* select max angle */
				if( angle > vu_angle )
				{
					if(rt_g.NMG_debug&DEBUG_FCUT)
						bu_log( "\t\tabove is the new best VU\n" );
					vu_angle = angle;

					vu_best = rs->vu[i];
					*index1 = i;
				}
			}

			if( vu_best )
			{
				vu1 = vu_best;
				lcut->vu1 = vu1;
			}

			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log( "\tfind_loop_to_cut: selecting VU1 x%x\n", vu1 );
		}
	}

	if(rt_g.NMG_debug&DEBUG_FCUT)
		bu_log( "\tfind_loop_to_cut: returning %d cuts (index1=%d, index2=%d)\n",
				BU_PTBL_END( cuts ), *index1, *index2 );

	return( cuts );
}

static fastf_t
nmg_eu_angle(struct edgeuse *eu, struct vertex *vp)
{
	struct faceuse *fu;
	struct vertex_g *vg1,*vg2;
	vect_t norm;
	vect_t x_dir;
	vect_t y_dir;
	vect_t eu_dir;
	fastf_t angle;

	NMG_CK_EDGEUSE( eu );
	NMG_CK_VERTEX( vp );

	fu = nmg_find_fu_of_eu( eu );
	NMG_CK_FACEUSE( fu );
	NMG_GET_FU_NORMAL( norm, fu );

	vg1 = eu->vu_p->v_p->vg_p;
	vg2 = eu->eumate_p->vu_p->v_p->vg_p;

	VSUB2( x_dir, vg1->coord, vp->vg_p->coord );
	VUNITIZE( x_dir );
	VCROSS( y_dir, norm, x_dir );
	VUNITIZE( y_dir );

	VSUB2( eu_dir, vg2->coord, vg1->coord );
	angle = atan2( VDOT( eu_dir, y_dir ), VDOT( eu_dir, x_dir ) );

	return( angle );
}

static int
find_best_vu(int start, int end, struct vertex *other_vp, struct nmg_ray_state *rs)
{
	struct edgeuse *eu;
	struct vertexuse *best_vu;
	struct loopuse *best_lu;
	fastf_t best_angle;
	int best_index;
	int other_is_in_best = -42;
	int class;
	int i;

	if(rt_g.NMG_debug&DEBUG_FCUT)
		bu_log( "find_best_vu: start=%d, end=%d, other_vp=x%x, rs=x%x\n",
				start,end,other_vp, rs );

	NMG_CK_VERTEX( other_vp );
	NMG_CK_RAYSTATE(rs);

	if( start == end-1 )
	{
		if(rt_g.NMG_debug&DEBUG_FCUT)
			bu_log( "\tfind_best_vu returning %d\n", start );

		return( start );
	}

	best_vu = rs->vu[start];
	best_lu = nmg_find_lu_of_vu( best_vu );
	best_index = start;
	eu = best_vu->up.eu_p;
	best_angle = nmg_eu_angle( eu, other_vp );

	if( BU_LIST_FIRST_MAGIC( &best_lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
	{
		other_is_in_best = 0;
	}
	else if( nmg_loop_is_a_crack( best_lu ) )
	{
		other_is_in_best = 0;
	}
	else
	{
		class = nmg_class_pt_lu_except( other_vp->vg_p->coord, best_lu, (struct edge *)NULL, rs->tol );

		if( (class == NMG_CLASS_AinB && best_lu->orientation == OT_SAME) ||
		    (class == NMG_CLASS_AoutB && best_lu->orientation == OT_OPPOSITE) )
			other_is_in_best = 1;
		else if( class == NMG_CLASS_AonBshared )
		{
			bu_log( "find_best_vu: There is a loop to cut, lu=x%x\n", best_lu );
			rt_bomb( "find_best_vu: There is a loop to cut" );
		}
		else
			other_is_in_best = 0;
	}

	if(rt_g.NMG_debug&DEBUG_FCUT)
		bu_log( "\tfind_best_vu: first choice is index=%d, vu=x%x, lu=x%x, other_is_in_best=%d\n",
				best_index, best_vu, best_lu, other_is_in_best );

	for( i=start+1 ; i<end ; i++ )
	{
		struct loopuse *lu;

		lu = nmg_find_lu_of_vu( rs->vu[i] );
		if( lu != best_lu )
		{
			class = nmg_classify_lu_lu( lu, best_lu, rs->tol );
			if(rt_g.NMG_debug&DEBUG_FCUT)
			{
				bu_log( "lu x%x is %s\n", lu , nmg_orientation( lu->orientation ) );
				bu_log( "best_lu x%x is %s\n", best_lu , nmg_orientation( best_lu->orientation ) );
				bu_log( "lu x%x is %s w.r.t lu x%x\n",
					lu, nmg_class_name( class ), best_lu );
			}

			if( other_is_in_best )
			{
				if( class == NMG_CLASS_AinB || (class == NMG_CLASS_AonBshared && lu->orientation == OT_SAME) )
				{

					best_vu = rs->vu[i];
					best_lu = lu;
					best_index = i;

					if(rt_g.NMG_debug&DEBUG_FCUT)
						bu_log( "\tfind_best_vu: better choice (inside) - index=%d, vu=x%x, lu=x%x, other_is_in_best=%d\n",
							best_index, best_vu, best_lu, other_is_in_best );
					/* other_is_in_best can't change */
				}
			}
			else
			{
				if( class == NMG_CLASS_AoutB || (class == NMG_CLASS_AonBshared && lu->orientation == OT_OPPOSITE) )
				{
					best_vu = rs->vu[i];
					best_lu = lu;
					best_index = i;

					/* other_is_in_best may change */
					if( BU_LIST_FIRST_MAGIC( &best_lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
					{
						other_is_in_best = 0;
					}
					else if( nmg_loop_is_a_crack( best_lu ) )
					{
						other_is_in_best = 0;
					}
					else
					{
						class = nmg_class_pt_lu_except( other_vp->vg_p->coord,
							best_lu, (struct edge *)NULL, rs->tol );

						if( (class == NMG_CLASS_AinB && best_lu->orientation == OT_SAME) ||
						    (class == NMG_CLASS_AoutB && best_lu->orientation == OT_OPPOSITE) )
							other_is_in_best = 1;
						else if( class == NMG_CLASS_AonBshared )
						{
							bu_log( "find_best_vu: There is a loop to cut, lu=x%x\n",
								best_lu );
							rt_bomb( "find_best_vu: There is a loop to cut" );
						}
						else
							other_is_in_best = 0;
					}
					if(rt_g.NMG_debug&DEBUG_FCUT)
						bu_log( "\tfind_best_vu: better choice (outside) - index=%d, vu=x%x, lu=x%x, other_is_in_best=%d\n",
							best_index, best_vu, best_lu, other_is_in_best );
				}
			}
		}
		else
		{
			struct edgeuse *eu;
			fastf_t angle;
			/* need to choose based on eu directions */

			eu = rs->vu[i]->up.eu_p;
			NMG_CK_EDGEUSE( eu );
			angle = nmg_eu_angle( eu, other_vp );

			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log( "best_angle = %f, eu=x%x, eu_angle=%f\n",
					best_angle, eu, angle );
			if( angle > best_angle )
			{
				best_angle = angle;
				best_vu = rs->vu[i];
				best_lu = nmg_find_lu_of_vu( best_vu );
				best_index = i;
			}
		}
	}

	return( best_index );
}

HIDDEN void
nmg_fcut_face(struct nmg_ray_state *rs)
{
	register int	cur;
	struct vertexuse *vu1,*vu2;
	struct loopuse *new_lu;
	struct edgeuse *new_eu1;
	struct edgeuse *old_eu;
	struct vertex *prev_v;
	struct bu_ptbl *cuts;
	int prior_start;
	int cut_no;

	NMG_CK_RAYSTATE(rs);
	BN_CK_TOL(rs->tol);

	if(rt_g.NMG_debug&DEBUG_FCUT)
		bu_log("nmg_face_combine()\n");

	if(rs->eg_p) NMG_CK_EDGE_G_LSEG(rs->eg_p);

#if PLOT_BOTH_FACES
	nmg_2face_plot( rs->fu1, rs->fu2 );
#else
	nmg_face_plot( rs->fu1 );
	nmg_face_plot( rs->fu2 );
#endif

	if(rt_g.NMG_debug&DEBUG_FCUT)
	{
		bu_log( "rs->fu1 = x%x\n", rs->fu1 );
		bu_log( "rs->fu2 = x%x\n", rs->fu2 );
		nmg_pr_fu_briefly( rs->fu1, "" );
		bu_log( "%d vertices on intersect line\n", rs->nvu );
		for( cur=0 ; cur<rs->nvu ; cur++ )
		bu_log( "\tvu=x%x, v=x%x, lu=x%x\n", rs->vu[cur], rs->vu[cur]->v_p, nmg_find_lu_of_vu( rs->vu[cur] ) );
	}


	if( rs->nvu < 2 )
		return;

	prev_v = (struct vertex *)NULL;
	prior_start = 0;
	while( 1 )
	{
		struct edgeuse *eu_tmp;
		struct loopuse *lu1 = (struct loopuse *)NULL;
		struct loopuse *lu2 = (struct loopuse *)NULL;
		point_t mid_pt;
		int class;
		int orient1 = 0;
		int orient2 = 0;
		int prior_end;
		int next_start,next_end;
		int i;
		int index1,index2;

		while( rs->vu[prior_start]->v_p == prev_v )
			prior_start++;

		vu1 = rs->vu[prior_start];
		prior_end = prior_start;

		prev_v = vu1->v_p;

		while( ++prior_end < rs->nvu && rs->vu[prior_end]->v_p == vu1->v_p );

		next_start = prior_end;

		if( next_start >= rs->nvu )
			break;		/* all done */

		vu2 = rs->vu[next_start];
		next_end = next_start;
		while( ++next_end < rs->nvu && rs->vu[next_end]->v_p == vu2->v_p );

		if(rt_g.NMG_debug&DEBUG_FCUT)
		{
			bu_log( "rs->fu1 = x%x\n", rs->fu1 );
			bu_log( "rs->fu2 = x%x\n", rs->fu2 );
			bu_log( "prior_start=%d. prior_end=%d, next_start=%d, next_end=%d\n", 
				prior_start, prior_end, next_start, next_end );
			bu_log( "%d vertices on intersect line\n", rs->nvu );
			for( cur=0 ; cur<rs->nvu ; cur++ )
			bu_log( "\tvu=x%x, v=x%x, lu=x%x\n", rs->vu[cur], rs->vu[cur]->v_p, nmg_find_lu_of_vu( rs->vu[cur] ) );
		}

		/* look for an EU in this face that connects vu1 and vu2 */
		if( nmg_find_eu_in_face( vu1->v_p, vu2->v_p, rs->fu1,
			(struct edgeuse *)NULL, 0 ) )
		{
			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log( "Already an edge here\n" );
			continue;
		}

		if( nmg_find_eu_in_face( vu1->v_p, vu2->v_p, rs->fu1->fumate_p,
			(struct edgeuse *)NULL, 0 ) )
		{
			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log( "Already an edge here\n" );
			continue;
		}

		/* we know that fu1 does not contain an edge connecting vu1 and vu2,
		 * Now check if the midpoint is inside or outside fu1.
		 * Note that ON fu1 is not an option at this point
		 */
		VAVERAGE( mid_pt, vu1->v_p->vg_p->coord, vu2->v_p->vg_p->coord )
		class = nmg_class_pt_fu_except( mid_pt, rs->fu1, (struct loopuse *)NULL,
			(void (*)())NULL, (void (*)())NULL, (char *)NULL, 0, 1, rs->tol );

		if(rt_g.NMG_debug&DEBUG_FCUT)
		{
			bu_log( "vu1=x%x (%g %g %g ), vu2=x%x (%g %g %g)\n",
				vu1, V3ARGS( vu1->v_p->vg_p->coord ),
				vu2, V3ARGS( vu2->v_p->vg_p->coord ) );
			bu_log( "\tmid_pt = (%g %g %g)\n", V3ARGS( mid_pt ) );
			bu_log( "class for mid point is %s\n", nmg_class_name(class) );
		}

		if( class == NMG_CLASS_AoutB )
			continue;

		/* Check if mid-point is in fu2. If fu2 is disjoint loops, this point
		 * may be outside fu2, and we don't want to cut fu1 here.
		 */
		class = nmg_class_pt_fu_except( mid_pt, rs->fu2, (struct loopuse *)NULL,
			(void (*)())NULL, (void (*)())NULL, (char *)NULL, 0, 0, rs->tol );

		if( class == NMG_CLASS_AoutB )
			continue;

		/* See if there is an edge joining the 2 vertices already, this
		 * will be used for radial join later */
		old_eu = nmg_findeu( vu1->v_p, vu2->v_p, (struct shell *)NULL,
			(struct edgeuse *)NULL, 0);

		
		cuts = find_loop_to_cut( &index1, &index2, prior_start, prior_end,
				       next_start, next_end, mid_pt, rs );
		if( cuts == (struct bu_ptbl *)NULL )
#if 0
		{
			vu1 = rs->vu[index1];
			vu2 = rs->vu[index2];
			lu1 = nmg_find_lu_of_vu( vu1 );
			lu2 = nmg_find_lu_of_vu( vu2 );
			orient1 = lu1->orientation;
			orient2 = lu2->orientation;

		}
		else
#endif
		{
			index1 = find_best_vu( prior_start, prior_end, vu2->v_p, rs );
			index2 = find_best_vu( next_start, next_end, vu1->v_p, rs );
			vu1 = rs->vu[index1];
			vu2 = rs->vu[index2];
			lu1 = nmg_find_lu_of_vu( vu1 );
			lu2 = nmg_find_lu_of_vu( vu2 );
			orient1 = lu1->orientation;
			orient2 = lu2->orientation;
		}

		if( cuts )
		{
			for( cut_no=0 ; cut_no<BU_PTBL_END( cuts ) ; cut_no++ )
			{
				struct loop_cuts *lcut;

				if(rt_g.NMG_debug&DEBUG_FCUT)
					bu_log( "\tcut loop (#%d of %d)\n", cut_no, BU_PTBL_END( cuts ) );

				lcut = (struct loop_cuts *)BU_PTBL_GET( cuts, cut_no );

				vu1 = lcut->vu1;
				vu2 = lcut->vu2;
				lu1 = lcut->lu;

				new_lu = nmg_cut_loop( vu1, vu2 );
				new_eu1 = BU_LIST_LAST( edgeuse, &new_lu->down_hd );

				NMG_CK_EDGEUSE( new_eu1 );

				/* make intersection edges real */
				new_eu1->e_p->is_real = 1;

				nmg_loop_g( lu1->l_p, rs->tol );
				nmg_loop_g( new_lu->l_p, rs->tol );

				nmg_lu_reorient( lu1 );
				nmg_lu_reorient( new_lu );

				if(rt_g.NMG_debug&DEBUG_FCUT)
				{
					bu_log( "\t\t new_eu = x%x\n", new_eu1 );
					nmg_pr_fu_briefly( rs->fu1, "" );
				}
#if 0
				/* Fuse new edge to intersect line, old edge */
				nmg_edge_geom_isect_line( new_eu1, rs, "CUTJOIN, new edge after loop cut" );
#endif
				if( old_eu ) nmg_radial_join_eu( old_eu, new_eu1, rs->tol );

				/* A new VU has been added to vu2->v_p, add it to the rs->vu[]
				 * array by overwriting the last use of vu1->v_p
				 */

				eu_tmp = vu1->up.eu_p;
				eu_tmp = BU_LIST_PPREV_CIRC( edgeuse, &eu_tmp->l );
				if( eu_tmp->vu_p->v_p != vu2->v_p )
				{
					bu_log( "nmg_fcut_face: eu (x%x) has wrong vertex (x%x) should be (x%x)\n", eu_tmp, eu_tmp->vu_p->v_p, vu2->v_p );
					rt_bomb( "nmg_fcut_face: eu has wrong vertex" );
				}

				rs->vu[prior_end-1-cut_no] = eu_tmp->vu_p;
			}
			bu_ptbl_free( cuts);
			bu_free( (char *)cuts, "cuts" );

			continue;
		}

		if( BU_LIST_FIRST_MAGIC( &lu1->down_hd ) == NMG_VERTEXUSE_MAGIC &&
		    BU_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_VERTEXUSE_MAGIC )

		{
			struct vertexuse *new_vu2;

			new_vu2 = nmg_join_2singvu_loops( vu1, vu2 );
			new_eu1 = new_vu2->up.eu_p;
			NMG_CK_EDGEUSE( new_eu1 );

			/* make intersection edges real */
			new_eu1->e_p->is_real = 1;

			nmg_loop_g( lu1->l_p, rs->tol );
			lu1->orientation = OT_SAME;
			lu1->lumate_p->orientation = OT_SAME;

			if(rt_g.NMG_debug&DEBUG_FCUT)
			{
				bu_log( "\tjoin 2 singvu loops\n" );
				nmg_pr_fu_briefly( rs->fu1, "" );
			}
#if 0			
			/* Fuse new edge to intersect line, old edge */
			nmg_edge_geom_isect_line( new_eu1, rs, "CUTJOIN, new edge after loop cut" );
#endif
			if( old_eu )  nmg_radial_join_eu( old_eu, new_eu1, rs->tol );

			/* vu2 has been killed, replace it in rs->vu[] */

			for( i=next_start ; i<next_end ; i++ )
			{
				if( rs->vu[i] == vu2 )
				{
					rs->vu[i] = new_vu2;
					break;
				}
			}

			continue;
		}

		if( BU_LIST_FIRST_MAGIC( &lu1->down_hd ) == NMG_VERTEXUSE_MAGIC &&
		    BU_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_EDGEUSE_MAGIC )
		{
			struct vertexuse *new_vu1;

			new_vu1 = nmg_join_singvu_loop( vu2, vu1 );
			new_eu1 = new_vu1->up.eu_p;
			NMG_CK_EDGEUSE( new_eu1 );

			/* make intersection edges real */
			new_eu1->e_p->is_real = 1;

			nmg_loop_g( lu2->l_p, rs->tol );
			lu2->orientation = orient2;
			lu2->lumate_p->orientation = orient2;

			if(rt_g.NMG_debug&DEBUG_FCUT)
			{
				bu_log( "\tjoin loops vu1 (x%x) is sing vu loop\n", vu1 );
				nmg_pr_fu_briefly( rs->fu1, "" );
			}
#if 0			
			/* Fuse new edge to intersect line, old edge */
			nmg_edge_geom_isect_line( new_eu1, rs, "CUTJOIN, new edge after loop cut" );

#endif
			if( old_eu )  nmg_radial_join_eu( old_eu, new_eu1, rs->tol );

			/* A new VU has been added to vu2->v_p, add it to the rs->vu[]
			 * array by overwriting the last use of vu1->v_p
			 */

			eu_tmp = new_vu1->up.eu_p;
			eu_tmp = BU_LIST_PPREV_CIRC( edgeuse, &eu_tmp->l );
			if( eu_tmp->vu_p->v_p != vu2->v_p )
			{
				bu_log( "nmg_fcut_face: eu (x%x) has wrong vertex (x%x) should be (x%x)\n", eu_tmp, eu_tmp->vu_p->v_p, vu2->v_p );
				rt_bomb( "nmg_fcut_face: eu has wrong vertex" );
			}

			rs->vu[prior_end-1] = eu_tmp->vu_p;
			continue;
		}

		if( BU_LIST_FIRST_MAGIC( &lu1->down_hd ) == NMG_EDGEUSE_MAGIC &&
		    BU_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_VERTEXUSE_MAGIC )
		{
			struct vertexuse *new_vu2;

			new_vu2 = nmg_join_singvu_loop( vu1, vu2 );
			new_eu1 = new_vu2->up.eu_p;
			NMG_CK_EDGEUSE( new_eu1 );

			/* make intersection edges real */
			new_eu1->e_p->is_real = 1;

			nmg_loop_g( lu1->l_p, rs->tol );
			lu1->orientation = orient1;
			lu1->lumate_p->orientation = orient1;

			if(rt_g.NMG_debug&DEBUG_FCUT)
			{
				bu_log( "\tjoin loops vu2 (x%x) is sing vu loop\n", vu2 );
				nmg_pr_fu_briefly( rs->fu1, "" );
			}
#if 0			
			/* Fuse new edge to intersect line, old edge */
			nmg_edge_geom_isect_line( new_eu1, rs, "CUTJOIN, new edge after loop cut" );
#endif

			if( old_eu )  nmg_radial_join_eu( old_eu, new_eu1, rs->tol );

			/* vu2 has been killed, replace it in rs->vu[] */

			for( i=next_start ; i<next_end ; i++ )
			{
				if( rs->vu[i] == vu2 )
				{
					rs->vu[i] = new_vu2;
					break;
				}
			}

			continue;
		}

		if( lu1 != lu2 )
		{
			struct vertexuse *new_vu2;

			new_vu2 = nmg_join_2loops( vu1, vu2 );
			new_eu1 = new_vu2->up.eu_p;
			NMG_CK_EDGEUSE( new_eu1 );

			/* make intersection edges real */
			new_eu1->e_p->is_real = 1;

			nmg_loop_g( lu1->l_p, rs->tol );

			if(rt_g.NMG_debug&DEBUG_FCUT)
			{
				bu_log( "\t join 2 loops\n" );
				bu_log( "\t\tvu2 (x%x) replaced with new_vu2 x%x\n", vu2, new_vu2 );
				nmg_pr_fu_briefly( rs->fu1, "" );
			}

#if 0
			/* Fuse new edge to intersect line, old edge */
			nmg_edge_geom_isect_line( new_eu1, rs, "CUTJOIN, new edge after loop cut" );
#endif

			if( old_eu )  nmg_radial_join_eu( old_eu, new_eu1, rs->tol );

			/* a new use of vu2->v_p has been created add it to the list by
			 * overwriting a use of the previous vertex
			 */
			rs->vu[prior_end - 1] = new_vu2;

			continue;
		}

		bu_log( "ERROR in face cutter: something should have been cut!!\n" );
		bu_log( "vu1=x%x, vu2=x%x\n", vu1, vu2 );
		nmg_pr_fu_briefly( rs->fu1, "" );
		rt_bomb( "ERROR: face cutter didn't cut anything" );
	}

	if(rt_g.NMG_debug&DEBUG_FCUT)
		nmg_pr_fu_briefly( rs->fu1, "" );
}

HIDDEN void
nmg_face_combine_jra(struct nmg_ray_state *rs1, fastf_t *mag1, struct nmg_ray_state *rs2, fastf_t *mag2)
{
	nmg_fcut_face( rs1 );
	nmg_fcut_face( rs2 );

}

/*
 *			N M G _ F A C E _ C O M B I N E
 *
 *	collapse loops,vertices within face fu1 (relative to fu2)
 *
 */
HIDDEN void
nmg_face_combineX(struct nmg_ray_state *rs1, fastf_t *mag1, struct nmg_ray_state *rs2, fastf_t *mag2)
{
	register int	cur1, cur2;
	register int	nxt1, nxt2;

	NMG_CK_RAYSTATE(rs1);
	NMG_CK_RAYSTATE(rs2);
	BN_CK_TOL(rs1->tol);
	BN_CK_TOL(rs2->tol);

	if(rt_g.NMG_debug&DEBUG_FCUT)
		bu_log("nmg_face_combine()\n");

	if(rs1->eg_p) NMG_CK_EDGE_G_LSEG(rs1->eg_p);
	if(rs2->eg_p) NMG_CK_EDGE_G_LSEG(rs2->eg_p);

#if PLOT_BOTH_FACES
	nmg_2face_plot( rs1->fu1, rs1->fu2 );
#else
	nmg_face_plot( rs1->fu1 );
	nmg_face_plot( rs1->fu2 );
#endif

	/*  Handle next block of coincident vertexuses.
	 *  Sometimes only one list has a block in it.
	 */
	cur1 = cur2 = 0;
	for( ; cur1 < rs1->nvu && cur2 < rs2->nvu; cur1=nxt1, cur2=nxt2 )  {
		int	old_rs1_state = rs1->state;

		if(rt_g.NMG_debug&DEBUG_FCUT)
			bu_log("\nnmg_face_combineX() vu block, index1=%d, index2=%d\n", cur1, cur2);

		if( mag1[cur1] < mag2[cur2] )  {
			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log("\nnmg_face_combineX() doing index1 block (at end)\n");
			nxt1 = nmg_face_next_vu_interval( rs1, cur1, mag1, rs2->state );
			nxt2 = cur2;
			if(rs1->eg_p) NMG_CK_EDGE_G_LSEG(rs1->eg_p);
			if(rs2->eg_p) NMG_CK_EDGE_G_LSEG(rs2->eg_p);
			if( !rs2->eg_p )  rs2->eg_p = rs1->eg_p;
		} else if( mag1[cur1] > mag2[cur2] )  {
			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log("\nnmg_face_combineX() doing index2 block (at end)\n");
			nxt1 = cur1;
			nxt2 = nmg_face_next_vu_interval( rs2, cur2, mag2, old_rs1_state );
			if(rs1->eg_p) NMG_CK_EDGE_G_LSEG(rs1->eg_p);
			if(rs2->eg_p) NMG_CK_EDGE_G_LSEG(rs2->eg_p);
			if( !rs1->eg_p )  rs1->eg_p = rs2->eg_p;
		} else {
			struct vertexuse	*vu1;
			struct vertexuse	*vu2;
			vu1 = rs1->vu[cur1];
			vu2 = rs2->vu[cur2];
			NMG_CK_VERTEXUSE(vu1);
			NMG_CK_VERTEXUSE(vu2);
			if( vu1->v_p != vu2->v_p )  {
				bu_log("cur1=%d, cur2=%d, v1=x%x, v2=x%x\n",
					cur1, cur2, vu1->v_p, vu2->v_p);
				rt_bomb("nmg_face_combineX: vertex lists scrambled");
			}
			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log("\nnmg_face_combineX() doing index1 block\n");
			nxt1 = nmg_face_next_vu_interval( rs1, cur1, mag1, rs2->state );
			if(rs1->eg_p) NMG_CK_EDGE_G_LSEG(rs1->eg_p);
			if(rs2->eg_p) NMG_CK_EDGE_G_LSEG(rs2->eg_p);
			if( !rs2->eg_p )  rs2->eg_p = rs1->eg_p;

			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log("\nnmg_face_combineX() doing index2 block\n");
			nxt2 = nmg_face_next_vu_interval( rs2, cur2, mag2, old_rs1_state );
			if(rs1->eg_p) NMG_CK_EDGE_G_LSEG(rs1->eg_p);
			if(rs2->eg_p) NMG_CK_EDGE_G_LSEG(rs2->eg_p);
			if( !rs1->eg_p )  rs1->eg_p = rs2->eg_p;
		}
		if(rs1->eg_p) NMG_CK_EDGE_G_LSEG(rs1->eg_p);
		if(rs2->eg_p) NMG_CK_EDGE_G_LSEG(rs2->eg_p);
	}

	/*
	 *  Here, one list is exhausted, but the other may not be.
	 *  Press on until both are.
	 */
	for( ; cur1 < rs1->nvu; cur1 = nxt1 )  {
		nxt1 = nmg_face_next_vu_interval( rs1, cur1, mag1, rs2->state );
	}
	if( !rs2->eg_p )  rs2->eg_p = rs1->eg_p;
	if(rs1->eg_p) NMG_CK_EDGE_G_LSEG(rs1->eg_p);
	if(rs2->eg_p) NMG_CK_EDGE_G_LSEG(rs2->eg_p);

	for( ; cur2 < rs2->nvu; cur2 = nxt2 )  {
		nxt2 = nmg_face_next_vu_interval( rs2, cur2, mag2, rs1->state );
	}
	if( !rs1->eg_p )  rs1->eg_p = rs2->eg_p;
	if(rs1->eg_p) NMG_CK_EDGE_G_LSEG(rs1->eg_p);
	if(rs2->eg_p) NMG_CK_EDGE_G_LSEG(rs2->eg_p);

	if( rs1->state != NMG_STATE_OUT || rs2->state != NMG_STATE_OUT )  {
		bu_log("ERROR nmg_face_combine() ended in state '%s'/'%s'?\n",
			nmg_state_names[rs1->state],
			nmg_state_names[rs2->state] );
		bu_log("cur1 = %d of %d, cur2 = %d of %d\n",
			cur1, rs1->nvu, cur2, rs2->nvu );

		if( RT_G_DEBUG || rt_g.NMG_debug )  {
			/* Drop a plot file */
			rt_g.NMG_debug |= DEBUG_VU_SORT|DEBUG_FCUT|DEBUG_PLOTEM;
			nmg_pl_comb_fu( 0, 1, rs1->fu1 );
			nmg_pl_comb_fu( 0, 2, rs1->fu2 );
		}

#if 0
		bu_log("nmg_face_combine() bad ending state, pushing on\n");
#else
		/* This is the production setting */
		rt_bomb("nmg_face_combine() bad ending state\n");
#endif
	}
}

/*
 *			N M G _ U N L I S T _ V
 */
void
nmg_unlist_v(struct bu_ptbl *b, fastf_t *mag, struct vertex *v)
{
	register int		i;
	struct vertexuse	*vu;

	BU_CK_PTBL(b);
	NMG_CK_VERTEX(v);
	for( i=0; i<BU_PTBL_END(b); i++ )  {
		vu = (struct vertexuse *)BU_PTBL_GET(b, i);
		if( !vu )  continue;
		if( vu->v_p == v )
		{
			BU_PTBL_GET(b, i) = (long *)0;
			mag[i] = MAX_FASTF;
		}
	}
}

/*
 *			N M G _ O N O N _ F I X
 *
 *  An attempt to fix the condition:
 *	nmg_assess_eu():  ON vertexuse in middle of edge?
 *
 *  Note that the vertexuse being zapped may have a lower subscript.
 *
 *  Must be called after vu list has been sorted.
 */
int
nmg_onon_fix(struct nmg_ray_state *rs, struct bu_ptbl *b, struct bu_ptbl *ob, fastf_t *mag, fastf_t *omag)
                    	    
              		   
              		    	/* other rs's vu list */
       			     	/* list of distances from intersect ray start point */
       			      	/* list of distances from intersect ray start point */
{
	int		i;
	int		zapped;
	struct vertexuse	*vu;
	struct vertex		*v;
	int		zot;

	NMG_CK_RAYSTATE(rs);
	BU_CK_PTBL(b);
	BU_CK_PTBL(ob);

	zapped = 0;
	for( i=0; i<BU_PTBL_END(b); i++ )  {
again:
		vu = (struct vertexuse *)BU_PTBL_GET(b, i);
		if( !vu )  continue;
		NMG_CK_VERTEXUSE(vu);
		if( *vu->up.magic_p == NMG_LOOPUSE_MAGIC )  continue;
		v = vu->v_p;
		NMG_CK_VERTEX(v);
		if( (zot = nmg_assess_eu( vu->up.eu_p, 0, rs, i )) < 0 )  {
			if(rt_g.NMG_debug&DEBUG_FCUT)  {
				bu_log("nmg_onon_fix(): vu[%d] zapped (rev)\n", -zot);
			}
doit:
			vu = (struct vertexuse *)BU_PTBL_GET(b, -zot);
			NMG_CK_VERTEXUSE(vu);
			v = vu->v_p;
			/* Need to null out all uses of this vertex from both lists */
			nmg_unlist_v(b, mag, v);
			nmg_unlist_v(ob, omag, v);
			zapped++;
			goto again;
		}

		if( (zot = nmg_assess_eu( vu->up.eu_p, 1, rs, i )) < 0 )  {
			if(rt_g.NMG_debug&DEBUG_FCUT)  {
				bu_log("nmg_onon_fix(): vu[%d] zapped (forw)\n", -zot);
			}
			goto doit;
		}
	}
	if( zapped )  {
		int removed;

		/* If any vertexuses got zapped, their pointer was set to NULL.
		 *  They can all be removed from the list in one easy operation.
		 */
		bu_log("nmg_onon_fix(): removing %d dead vertexuses\n", zapped);
		/* remove entries from distance list first */
		removed = 0;
		for( i=BU_PTBL_END( b ) ; i>=0 ; i-- )
		{
			int count=0;
			int j,k;

			j = i;
			while( j>=0 && !BU_PTBL_GET( b, j ) ) --j;
			count = i-j;
			removed += count;
			for( k=j+1; k<BU_PTBL_END(b)-removed ; k++ )
				mag[k] = mag[k+count];
		}
		bu_ptbl_rm(b, 0 );
		removed = 0;
		for( i=BU_PTBL_END( ob ) ; i>=0 ; i-- )
		{
			int count=0;
			int j,k;

			j = i;
			while( j>=0 && !BU_PTBL_GET( ob, j ) ) --j;
			count = i-j;
			removed += count;
			for( k=j+1 ; k<BU_PTBL_END(ob)-removed ; k++ )
				omag[k] = omag[k+count];
		}
		bu_ptbl_rm(ob, 0 );
#if 0
rt_bomb("nmg_onon_fix(): check the intersector\n");
#endif
		return 1;
	}

	return 0;
}
#if 0
void
nmg_sort_coincident_vus( tbl, tol )
struct bu_ptbl *tbl;
const struct bn_tol *tol;
{
	int curr_vu=0;
	int start1,end1;
	int start2,end2;
	struct vertexuse *vu1;
	struct vertexuse *vu2;
	struct loopuse **matching_lus;
	int match_count=0;

	BN_CK_TOL( tol );
	BU_CK_PTBL( tbl );

	if( BU_PTBL_END( tbl ) < 3 )
		return;

	matching_lus = (struct loopuse **)bu_calloc( BU_PTBL_END( tbl ), 
		sizeof( struct loopuse *), "nmg_sort_coincident_vus: matching_lus" );

	/* look for coincident vu's */
	while( curr_vu < BU_PTBL_END( tbl )-1 )
	{
		struct loopuse *lu1,*lu2;

		vu1 = (struct vertexuse *)BU_PTBL_GET( tbl, curr_vu );
		start1 = curr_vu;
		end1 = start1;
		vu2 = (struct vertexuse *)BU_PTBL_GET( tbl, start1 + 1 );
		if( vu1->v-p != vu2->v_p )
		{
			/* not coincident */
			curr_vu++;
			continue;
		}
		while( vu2->v_p == vu1->v_p )
		{
			end1++;
			vu2 = (struct vertexuse *)BU_PTBL_GET( tbl, end1 + 1 );
		}

		/*
		 * get next vu after coincident list
		 * might be another list of coincident VU's
		 */
		start2 = end1 + 1;
		end2 = start2;
		vu1 = (struct vertexuse *)BU_PTBL_GET( tbl, start2 );
		vu2 = (struct vertexuse *)BU_PTBL_GET( tbl, start2+1 );
		while( vu2->v_p == vu1->v_p )
		{
			end2++;
			vu2 = (struct vertexuse *)BU_PTBL_GET( tbl, end2+1 );
		}

		match_count = 0;
		for( i=start1 ; i<=end1 ; i++ )
		{
			vu1 = (struct vertexuse *)BU_PTBL_GET( tbl, i );
			lu1 = nmg_find_lu_of_vu( vu1 );
			if( !lu1 )
				continue;

			/* look for same LU in next list */
			for( j=start1 ; j<= end1 ; j++ )
			{
				vu2 = (struct vertexuse *)BU_PTBL_GET( tbl, j );
				lu2 = nmg_find_lu_of_vu( vu2 );
				if( lu2 == lu1 )
				{
					matching_lus[match_count] = lu1;
					match_count++;
				}
			}
		}
	}
}

#endif
/*
 *			N M G _ F A C E _ C U T J O I N
 *
 *  The main face cut handler.
 *  Called from nmg_inter.c by nmg_isect_2faces().
 *
 *  A wrapper for nmg_face_combine, for now.
 *
 *  The two vertexuse lists may be of different lengths, because
 *  one may have multiple uses of a vertex, while the other has only
 *  a single use of that same vertex.
 */
struct edge_g_lseg *
nmg_face_cutjoin(struct bu_ptbl *b1, struct bu_ptbl *b2, fastf_t *mag1, fastf_t *mag2, struct faceuse *fu1, struct faceuse *fu2, fastf_t *pt, fastf_t *dir, struct edge_g_lseg *eg, const struct bn_tol *tol)
              	    		/* table of vertexuses in fu1 on intercept line */
              	    		/* table of vertexuses in fu2 on intercept line */
       		      		/* table of distances to vertexuses from is->pt */
       		      		/* table of distances to vertexuses from is->pt */
              	     		/* face being worked */
              	     		/* for plane equation */
       		   
      		    
                  		    	/* may be null.  geometry of isect line */
                   	     
{
	struct vertexuse **vu1, **vu2;
	int		i;
	struct nmg_ray_state	rs1;
	struct nmg_ray_state	rs2;

	if(rt_g.NMG_debug&DEBUG_FCUT)  {
		bu_log("\nnmg_face_cutjoin(fu1=x%x, fu2=x%x) eg=x%x START\n", fu1, fu2, eg);
	}

	BN_CK_TOL(tol);
	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);

	/* Perhaps this should only happen when debugging is on? */
	if( rt_g.NMG_debug&DEBUG_FCUT && ( b1->end <= 0 || b2->end <= 0) )  {
		bu_log("nmg_face_cutjoin(fu1=x%x, fu2=x%x): WARNING empty list %d %d\n",
			fu1, fu2, b1->end, b2->end );
#if 0
		return eg;
#endif
	}

top:
	/*
	 *  Sort hit points by increasing distance, vertex ptr, vu ptr,
	 *  and eliminate any duplicate vu's.
	 */
	ptbl_vsort(b1, fu1, fu2, pt, dir, mag1, tol->dist);
	ptbl_vsort(b2, fu2, fu1, pt, dir, mag2, tol->dist);

	vu1 = (struct vertexuse **)b1->buffer;
	vu2 = (struct vertexuse **)b2->buffer;

	/* Print list of intersections */
	if(rt_g.NMG_debug&DEBUG_FCUT)  {
		bu_log("Ray vu intersection list:\n");
		for( i=0; i < b1->end; i++ )  {
			bu_log(" %d %e ", i, mag1[i] );
			nmg_pr_vu_briefly( vu1[i], (char *)0 );
		}
		for( i=0; i < b2->end; i++ )  {
			bu_log(" %d %e ", i, mag2[i] );
			nmg_pr_vu_briefly( vu2[i], (char *)0 );
		}
	}

	/* Check to make sure that intersector didn't miss anything */
	if( nmg_ck_vu_ptbl( b1, fu1 ) || nmg_ck_vu_ptbl( b2, fu2 ) )  goto top;

#if 0
	/* Check to see if lists are different */
	/* XXX Note that there may be different numbers of multiple uses in different faces.  This won't work. */
	{
		i = b1->end-1;
		if( b2->end-1 < i )  i = b2->end-1;
		for( ; i >= 0; i-- )  {
			NMG_CK_VERTEXUSE(vu1[i]);
			NMG_CK_VERTEXUSE(vu2[i]);
			if( vu1[i]->v_p == vu2[i]->v_p ) continue;
			bu_log("Index %d mis-match, x%x != x%x\n",
				i, vu1[i]->v_p, vu2[i]->v_p );
		}
	}
#endif

	/* this block of code checks if the two lists of intersection vertexuses
	 * contain vertexuses from the appropriate faceuse */
	if(rt_g.NMG_debug&DEBUG_FCUT)  {
		int found1=(-1),found2=(-1); /* -1 => not set, 0 => no vertexuses from faceuse found */
		int tmp_found;
		struct faceuse *fu;
		struct vertexuse *vu;

		/* list b1 should contain vertexuses from faceuse fu1 */
		for( i=0 ; i<BU_PTBL_END( b1 ) ; i++ )
		{
			tmp_found = 0;
			vu = (struct vertexuse *)BU_PTBL_GET( b1 , i );
			fu = nmg_find_fu_of_vu(vu);
			if( fu == fu1 )
				tmp_found = 1;
			if( found1 == (-1) )
				found1 = tmp_found;
			else if( tmp_found != found1 ) /* some found, some not found!!!!! */
			{
				bu_log ("nmg_face_cutjoin: Intersection list is screwy for face 1\n" );
				break;
			}
		}

		/* and list b2 should contain vertexuses from faceuse fu2 */
		for( i=0 ; i<BU_PTBL_END( b2 ) ; i++ )
		{
			tmp_found = 0;
			vu = (struct vertexuse *)BU_PTBL_GET( b2 , i );
			fu = nmg_find_fu_of_vu(vu);
			if( fu == fu2 )
				tmp_found = 1;
			if( found2 == (-1) )
				found2 = tmp_found;
			else if( tmp_found != found2 ) /* some found, some not found!!!!! */
			{
				bu_log ("nmg_face_cutjoin: Intersection list is screwy for face 2\n" );
				break;
			}
		}
		if( !found1 )
			bu_log( "nmg_face_cutjoin: intersection list for face 1 doesn't contain vertexuses from face 1!!!\n" );
		if( !found2 )
			bu_log( "nmg_face_cutjoin: intersection list for face 2 doesn't contain vertexuses from face 2!!!\n" );
	}

	nmg_face_rs_init( &rs1, b1, fu1, fu2, pt, dir, eg, tol );
	nmg_face_rs_init( &rs2, b2, fu2, fu1, pt, dir, eg, tol );
#if 0
	/* Ensure that small angles don't plunk vertexuses down onto the intersection line */
	if( nmg_onon_fix( &rs1, b1, b2, mag1, mag2 ) || nmg_onon_fix( &rs2, b2, b1, mag2, mag1 ) )  goto top;
#endif

#if 0
	nmg_face_combineX( &rs1, mag1, &rs2, mag2 );
#else
	nmg_face_combine_jra( &rs1, mag1, &rs2, mag2 );
#endif

	/* Can't do simplifications here,
	 * because the caller's linked lists & pointers might get disrupted.
	 */

	/* Merging uses of common edges is OK, though, and quite necessary. */
	if( (i = nmg_mesh_two_faces( fu1, fu2, tol )) )  {
		if(rt_g.NMG_debug&DEBUG_FCUT)
			bu_log("nmg_face_cutjoin() meshed %d edges\n", i);
	}
	if(rt_g.NMG_debug&DEBUG_FCUT)  {
		bu_log("nmg_face_cutjoin(fu1=x%x, fu2=x%x) eg=x%x END\n", fu1, fu2, rs1.eg_p);
	}
	if( eg && !rs1.eg_p )  rt_bomb("nmg_face_cutjoin() lost edge_g_lseg?\n");
	if( eg && eg != rs1.eg_p )  bu_log("nmg_face_cutjoin() changed from eg=x%x to rs1.eg_p=x%x\n", eg, rs1.eg_p);
	return rs1.eg_p;
}

void
nmg_fcut_face_2d(struct bu_ptbl *vu_list, fastf_t *mag, struct faceuse *fu1, struct faceuse *fu2, struct bn_tol *tol)
{
	struct nmg_ray_state rs;
	point_t pt;
	vect_t dir;
	struct edge_g_lseg *eg;

	NMG_CK_FACEUSE( fu1 );
	NMG_CK_FACEUSE( fu2 );
	BN_CK_TOL( tol );
	BU_CK_PTBL( vu_list );

	VSETALL( pt, 0.0 );
	VSET( dir, 1.0, 0.0 ,0.0 );
	eg = (struct edge_g_lseg *)NULL;

	nmg_face_rs_init( &rs, vu_list, fu1, fu2, pt,  dir, eg, tol );

	nmg_fcut_face( &rs );
}

/*
 *  State machine transition tables
 *  Indexed by MNG_V_ASSESSMENT values.
 */

struct state_transitions {
	int	assessment;
	int	new_state;
	int	action;
};

static const struct state_transitions nmg_state_is_out[17] = {
	{ NMG_LEFT_LEFT,	NMG_STATE_OUT,		NMG_ACTION_NONE },
	{ NMG_LEFT_RIGHT,	NMG_STATE_IN,		NMG_ACTION_VFY_EXT },
	{ NMG_LEFT_ON_FORW,	NMG_STATE_ON_L,		NMG_ACTION_VFY_EXT },
	{ NMG_LEFT_ON_REV,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_RIGHT_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_RIGHT_RIGHT,	NMG_STATE_OUT,		NMG_ACTION_NONE },
	{ NMG_RIGHT_ON_FORW,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_RIGHT_ON_REV,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_FORW_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_FORW_RIGHT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_FORW_ON_FORW,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_FORW_ON_REV,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_REV_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_REV_RIGHT,	NMG_STATE_ON_R,		NMG_ACTION_VFY_EXT },
	{ NMG_ON_REV_ON_FORW,	NMG_STATE_ON_N,		NMG_ACTION_NONE },
	{ NMG_ON_REV_ON_REV,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_LONE,		NMG_STATE_OUT,		NMG_ACTION_NONE }
};

static const struct state_transitions nmg_state_is_on_L[17] = {
	{ NMG_LEFT_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_LEFT_RIGHT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_LEFT_ON_FORW,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_LEFT_ON_REV,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_RIGHT_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_RIGHT_RIGHT,	NMG_STATE_ON_L,		NMG_ACTION_NONE },
	{ NMG_RIGHT_ON_FORW,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_RIGHT_ON_REV,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_FORW_LEFT,	NMG_STATE_OUT,		NMG_ACTION_NONE },
	{ NMG_ON_FORW_RIGHT,	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ NMG_ON_FORW_ON_FORW,	NMG_STATE_ON_L,		NMG_ACTION_NONE },
	{ NMG_ON_FORW_ON_REV,	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ NMG_ON_REV_LEFT,	NMG_STATE_ON_N,		NMG_ACTION_VFY_MULTI },
	{ NMG_ON_REV_RIGHT,	NMG_STATE_ON_B,		NMG_ACTION_VFY_EXT },
	{ NMG_ON_REV_ON_FORW,	NMG_STATE_ON_L,		NMG_ACTION_VFY_MULTI },
	{ NMG_ON_REV_ON_REV,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_LONE,		NMG_STATE_ON_L,		NMG_ACTION_LONE_V_ESPLIT }
};

static const struct state_transitions nmg_state_is_on_R[17] = {
	{ NMG_LEFT_LEFT,	NMG_STATE_ON_R,		NMG_ACTION_NONE },
	{ NMG_LEFT_RIGHT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_LEFT_ON_FORW,	NMG_STATE_ON_B,		NMG_ACTION_NONE },
	{ NMG_LEFT_ON_REV,	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ NMG_RIGHT_LEFT,	NMG_STATE_ON_N,		NMG_ACTION_VFY_MULTI },
	{ NMG_RIGHT_RIGHT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_RIGHT_ON_FORW,	NMG_STATE_ON_N,		NMG_ACTION_VFY_MULTI },
	{ NMG_RIGHT_ON_REV,	NMG_STATE_OUT,		NMG_ACTION_NONE },
	{ NMG_ON_FORW_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_FORW_RIGHT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_FORW_ON_FORW,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_FORW_ON_REV,	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ NMG_ON_REV_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_REV_RIGHT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_REV_ON_FORW,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_REV_ON_REV,	NMG_STATE_ON_R,		NMG_ACTION_NONE },
	{ NMG_LONE,		NMG_STATE_ON_R,		NMG_ACTION_LONE_V_ESPLIT }
};

static const struct state_transitions nmg_state_is_on_B[17] = {
	{ NMG_LEFT_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_LEFT_RIGHT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_LEFT_ON_FORW,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_LEFT_ON_REV,	NMG_STATE_IN,		NMG_ACTION_VFY_MULTI },
	{ NMG_RIGHT_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_RIGHT_RIGHT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_RIGHT_ON_FORW,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_RIGHT_ON_REV,	NMG_STATE_ON_L,		NMG_ACTION_NONE },
	{ NMG_ON_FORW_LEFT,	NMG_STATE_ON_R,		NMG_ACTION_NONE },
	{ NMG_ON_FORW_RIGHT,	NMG_STATE_IN,		NMG_ACTION_VFY_MULTI },
	{ NMG_ON_FORW_ON_FORW,	NMG_STATE_ON_B,		NMG_ACTION_VFY_MULTI },
	{ NMG_ON_FORW_ON_REV,	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ NMG_ON_REV_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_REV_RIGHT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_REV_ON_FORW,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_REV_ON_REV,	NMG_STATE_ON_B,		NMG_ACTION_VFY_MULTI },
	{ NMG_LONE,		NMG_STATE_ON_B,		NMG_ACTION_LONE_V_ESPLIT }
};

static const struct state_transitions nmg_state_is_on_N[17] = {
	{ NMG_LEFT_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_LEFT_RIGHT,	NMG_STATE_OUT,		NMG_ACTION_VFY_MULTI },
	{ NMG_LEFT_ON_FORW,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_LEFT_ON_REV,	NMG_STATE_ON_L,		NMG_ACTION_VFY_MULTI },
	{ NMG_RIGHT_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_RIGHT_RIGHT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_RIGHT_ON_FORW,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_RIGHT_ON_REV,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_FORW_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_FORW_RIGHT,	NMG_STATE_ON_R,		NMG_ACTION_VFY_MULTI },
	{ NMG_ON_FORW_ON_FORW,	NMG_STATE_ON_N,		NMG_ACTION_VFY_MULTI },
	{ NMG_ON_FORW_ON_REV,	NMG_STATE_OUT,		NMG_ACTION_NONE },
	{ NMG_ON_REV_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_REV_RIGHT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_REV_ON_FORW,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_REV_ON_REV,	NMG_STATE_ON_N,		NMG_ACTION_VFY_MULTI },
	{ NMG_LONE,		NMG_STATE_ON_N,		NMG_ACTION_LONE_V_ESPLIT }
};

static const struct state_transitions nmg_state_is_in[17] = {
	{ NMG_LEFT_LEFT,	NMG_STATE_IN,		NMG_ACTION_CUTJOIN },
	{ NMG_LEFT_RIGHT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_LEFT_ON_FORW,	NMG_STATE_ON_R,		NMG_ACTION_CUTJOIN },
	{ NMG_LEFT_ON_REV,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_RIGHT_LEFT,	NMG_STATE_OUT,		NMG_ACTION_CUTJOIN },
	{ NMG_RIGHT_RIGHT,	NMG_STATE_IN,		NMG_ACTION_CUTJOIN },
	{ NMG_RIGHT_ON_FORW,	NMG_STATE_ON_L,		NMG_ACTION_CUTJOIN },
	{ NMG_RIGHT_ON_REV,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_FORW_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_FORW_RIGHT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_FORW_ON_FORW,	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ NMG_ON_FORW_ON_REV,	NMG_STATE_OUT,		NMG_ACTION_NONE },
	{ NMG_ON_REV_LEFT,	NMG_STATE_ON_R,		NMG_ACTION_CUTJOIN },
	{ NMG_ON_REV_RIGHT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ NMG_ON_REV_ON_FORW,	NMG_STATE_ON_B,		NMG_ACTION_CUTJOIN },
	{ NMG_ON_REV_ON_REV,	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ NMG_LONE,		NMG_STATE_IN,		NMG_ACTION_LONE_V_JAUNT }
};

/*
 *			N M G _ I N S E R T _ V U _ I F _ O N _ E D G E
 *
 *	This code checks if the vertex from a loop of a single vertex lies on
 *	an edge containing vu2. If so, the edge is split, vu1 is inserted,
 *	the loop containing vu1 is killed, and the newly created edgeuse is
 *	returned in "new_eu".
 *
 *		returns:
 *			0 - did nothing
 *			1 - inserted vu1 and created a new edge
 */
int
nmg_insert_vu_if_on_edge(struct vertexuse *vu1, struct vertexuse *vu2, struct edgeuse *new_eu, struct bn_tol *tol)
                      	/* vertexuse from a loop of a single vertex */
                      	/* vertexuse from another loop */
                       	/* use of new edge that may be created (implicit return ) */
                   	/* tolerance for collinearity check */
{
	struct edgeuse *eu_from;	/* edgeuse that starts at end of vu2's eu */
	struct edgeuse *eu_to;		/* edgeuse that terminates at vu2 */
	vect_t eu_vect;			/* edge vector starting or terminating at vu2 */
	vect_t vect_to_loop;		/* vector from start of eu_vect to vu1 */
	fastf_t eu_len_sq;		/* square of length of edge containing vu2 */
	fastf_t dist_to_loop_sq;	/* square of distance between vu1 and vu2 */

	NMG_CK_VERTEXUSE( vu1 );
	if( *vu1->up.magic_p != NMG_LOOPUSE_MAGIC )
		rt_bomb( "nmg_insert_vu_if_on_edge: vu1 is not from a loop of a single vertex" );

	NMG_CK_VERTEXUSE( vu2 );
	if( *vu2->up.magic_p != NMG_EDGEUSE_MAGIC )
		rt_bomb( "nmg_insert_vu_if_on_edge: vu2 is not from an edgeuse" );

	BN_CK_TOL( tol );

	if(rt_g.NMG_debug&DEBUG_FCUT)
		bu_log( "nmg_insert_vu_if_on_edge: vu1=x%x, vu2=x%x\n" , vu1 , vu2 );

	eu_from = BU_LIST_PNEXT_CIRC( edgeuse , vu2->up.eu_p );
	eu_to = BU_LIST_PPREV_CIRC( edgeuse , vu2->up.eu_p );
	if( bn_3pts_collinear( vu1->v_p->vg_p->coord , vu2->v_p->vg_p->coord , eu_from->vu_p->v_p->vg_p->coord , tol ))
	{
		if(rt_g.NMG_debug&DEBUG_FCUT)
			bu_log( "\t points are collinear with vu2's eu ( %g , %g , %g ) -> ( %g , %g , %g )\n",
				V3ARGS( vu2->v_p->vg_p->coord ),
				V3ARGS( eu_from->vu_p->v_p->vg_p->coord ) );
		VSUB2( eu_vect , eu_from->vu_p->v_p->vg_p->coord , vu2->v_p->vg_p->coord );
		VSUB2( vect_to_loop , vu1->v_p->vg_p->coord , vu2->v_p->vg_p->coord );
		if( VDOT( eu_vect , vect_to_loop ) > 0.0 )
		{
			eu_len_sq = MAGSQ( eu_vect );
			dist_to_loop_sq = MAGSQ( vect_to_loop );
			if( dist_to_loop_sq < eu_len_sq )
			{
				if(rt_g.NMG_debug&DEBUG_FCUT)
					bu_log( "\tvu1 is on vu2's eu, creating new edge (MAGSQ=%g, tol->dist_sq=%g)\n" , dist_to_loop_sq , tol->dist_sq );
				(void) nmg_ebreaker( vu1->v_p , vu2->up.eu_p, tol );
				nmg_klu( vu1->up.lu_p );
				return( 1 );
			}
		}
	}
	if( bn_3pts_collinear( vu1->v_p->vg_p->coord , vu2->v_p->vg_p->coord , eu_to->vu_p->v_p->vg_p->coord , tol ))
	{
		if(rt_g.NMG_debug&DEBUG_FCUT)
			bu_log( "\t points are collinear with eu that ends at vu2 ( %g , %g , %g ) -> ( %g , %g , %g )\n",
				V3ARGS( eu_to->vu_p->v_p->vg_p->coord ),
				V3ARGS( vu2->v_p->vg_p->coord ) );
		VSUB2( eu_vect , vu2->v_p->vg_p->coord , eu_to->vu_p->v_p->vg_p->coord );
		VSUB2( vect_to_loop , vu1->v_p->vg_p->coord , eu_to->vu_p->v_p->vg_p->coord );
		if( VDOT( eu_vect , vect_to_loop ) > 0.0 )
		{
			eu_len_sq = MAGSQ( eu_vect );
			dist_to_loop_sq = MAGSQ( vect_to_loop );
			if( dist_to_loop_sq < eu_len_sq )
			{

				if(rt_g.NMG_debug&DEBUG_FCUT)
					bu_log( "\tvu1 is on eu that ends at vu2, creating new edge (MAGSQ=%g, tol->dist_sq=%g)\n" , dist_to_loop_sq , tol->dist_sq );
				(void) nmg_ebreaker( vu1->v_p , eu_to, tol );
				nmg_klu( vu1->up.lu_p );
				return( 1 );
			}
		}
	}
	return( 0 );
}

/*
 *			N M G _ F A C E _ S T A T E _ T R A N S I T I O N
 *
 *  Given current (old) state, assess the current vertexuse, and
 *  pull the appropriate action and new state from the tables.
 *  Then perform the indicated action.
 *
 *  The real work happens in the nmg_assess_vu() and in the tables.
 *
 *  Explicit Returns -
 *	Nothing useful yet.
 *
 *  Implicit Returns -
 *	Modifications to the NMG shell being operated on.
 *	Updated state etc. in nmg_ray_state structure.
 */
int
nmg_face_state_transition(struct nmg_ray_state *rs, int pos, int multi, int other_rs_state)
{
	int			assessment;
	int			old_state;
	int			new_state;
	const struct state_transitions	*stp;
	struct vertexuse	*vu;
	struct vertexuse	*prev_vu = (struct vertexuse *)NULL;
	struct loopuse		*lu;
	struct loopuse		*prev_lu;
	struct faceuse		*fu;
	struct edgeuse		*eu;
	struct edgeuse		*first_new_eu;
	struct edgeuse		*second_new_eu;
	struct edgeuse		*old_eu;
	int			e_assessment;
	int			action;
	int			e_pos;

	NMG_CK_RAYSTATE(rs);
	vu = rs->vu[pos];
	NMG_CK_VERTEXUSE(vu);
	BN_CK_TOL(rs->tol);
	if(rs->eg_p) NMG_CK_EDGE_G_LSEG(rs->eg_p);

	if(rt_g.NMG_debug&DEBUG_FCUT)  {
		bu_log("nmg_face_state_transition(vu x%x, pos=%d) START\n",
			vu, pos);
		bu_log("Plotting this loopuse, before action:\n");
		nmg_pr_lu_briefly(nmg_find_lu_of_vu(vu), (char *)0);
		nmg_plot_lu_ray(nmg_find_lu_of_vu(vu),
			rs->vu[0], rs->vu[rs->nvu-1], rs->left );
	}

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_vfu( &rs->fu1->s_p->fu_hd, rs->fu1->s_p );
		nmg_vfu( &rs->fu2->s_p->fu_hd, rs->fu2->s_p );
		nmg_fu_touchingloops(rs->fu1);
		nmg_fu_touchingloops(rs->fu2);
	}

	assessment = nmg_assess_vu( rs, pos );
	old_state = rs->state;
	switch( old_state )  {
	default:
	case NMG_STATE_ERROR:
		rt_bomb("nmg_face_state_transition: was in ERROR state\n");
	case NMG_STATE_OUT:
		stp = &nmg_state_is_out[assessment];
		break;
	case NMG_STATE_ON_L:
		stp = &nmg_state_is_on_L[assessment];
		break;
	case NMG_STATE_ON_R:
		stp = &nmg_state_is_on_R[assessment];
		break;
	case NMG_STATE_ON_B:
		stp = &nmg_state_is_on_B[assessment];
		break;
	case NMG_STATE_ON_N:
		stp = &nmg_state_is_on_N[assessment];
		break;
	case NMG_STATE_IN:
		stp = &nmg_state_is_in[assessment];
		break;
	}

	if( assessment != stp->assessment )  {
		bu_log("assessment=%d, stp->assessment=%d, error\n", assessment, stp->assessment);
		rt_bomb("nmg_face_state_transition() bad table\n");
	}
	action = stp->action;
	new_state = stp->new_state;
	rs->last_action = action;

	/*
	 *  Major optimization here.
	 *  If the state machine for the other face is still in OUT state,
	 *  then take no actions in this face,
	 *  because any cutting or joining done here will have no effect
	 *  on the final result of the boolean, it's just extra work.
	 *  This can reduce the amount of unnecessary topology by 75% or more.
	 */
	if( other_rs_state == NMG_STATE_OUT && action != NMG_ACTION_ERROR &&
	    action != NMG_ACTION_NONE )  {
		action = NMG_ACTION_NONE_OPTIM;
	}

	if(rt_g.NMG_debug&DEBUG_FCUT)  {
		bu_log("nmg_face_state_transition(vu x%x, pos=%d)\n\told=%s, assessed=%s, new=%s, action=%s\n",
			vu, pos,
			nmg_state_names[old_state], nmg_v_assessment_names[assessment],
			nmg_state_names[new_state], action_names[action] );
	}

	/*
	 *  Force edge geometry that lies on the intersection line
	 *  to use the edge_g_lseg structure of the intersection line (ray).
	 */
	if( NMG_V_ASSESSMENT_PREV(assessment) == NMG_E_ASSESSMENT_ON_REV )  {
		eu = nmg_find_eu_of_vu(vu);
		eu = BU_LIST_PPREV_CIRC( edgeuse, eu );
		NMG_CK_EDGEUSE(eu);
		if( !rs->eg_p || eu->g.lseg_p != rs->eg_p )  {
			if( rs->eg_p )
				NMG_CK_EDGE_G_LSEG(rs->eg_p)
			nmg_edge_geom_isect_line( eu, rs, "force ON_REV to line" );
		}
	}
	if( NMG_V_ASSESSMENT_NEXT(assessment) == NMG_E_ASSESSMENT_ON_FORW )  {
		eu = nmg_find_eu_of_vu(vu);
		NMG_CK_EDGEUSE(eu);
		if( !rs->eg_p || eu->g.lseg_p != rs->eg_p )  {
			if( rs->eg_p )
				NMG_CK_EDGE_G_LSEG(rs->eg_p)
			nmg_edge_geom_isect_line( eu, rs, "force ON_FORW to line" );
		}
	}

	switch( action )  {
	default:
	case NMG_ACTION_ERROR:
	bomb:
	    {
		struct bu_vls	str;

		bu_log("nmg_face_state_transition: got action=ERROR\n");
	    	bu_vls_init(&str);
		bu_vls_printf(&str,"nmg_face_state_transition(vu x%x, pos=%d)\n\told=%s, assessed=%s, new=%s, action=%s\n",
			vu, pos,
			nmg_state_names[old_state], nmg_v_assessment_names[assessment],
			nmg_state_names[new_state], action_names[action] );
	     if( RT_G_DEBUG || rt_g.NMG_debug )  {
		/* First, print this faceuse */
		lu = nmg_find_lu_of_vu( vu );
	     	NMG_CK_LOOPUSE(lu);
		/* Print the faceuse for later analysis */
		bu_log("Loop with the offending vertex\n");
		nmg_pr_lu_briefly(lu, (char *)0);
#if 0
		if(rt_g.NMG_debug&DEBUG_FCUT)  {
			bu_log("The whole face\n");
			nmg_pr_fu(lu->up.fu_p, (char *)0);
		}
#endif

		/* Drop a plot file */
#if 0
		rt_g.NMG_debug |= DEBUG_FCUT|DEBUG_PLOTEM;
		nmg_pl_comb_fu( 0, 1, lu->up.fu_p );
		nmg_plot_lu_ray(lu, rs->vu[0], rs->vu[rs->nvu-1], rs->left );
		{
			FILE	*fp = fopen("error.pl", "w");
			nmg_pl_m(fp, nmg_find_model((long *)lu));
			fclose(fp);
			bu_log("wrote error.pl\n");
		}
		/* Store this face in a .g file for examination! */
		nmg_stash_model_to_file( "error.g", nmg_find_model((long*)lu), "nmg_fcut.c error dump" );
#endif
	     }
		/* Explode */
	    	rt_bomb(bu_vls_addr(&str));
	    }
	case NMG_ACTION_NONE:
	case NMG_ACTION_NONE_OPTIM:
		if( *(vu->up.magic_p) != NMG_LOOPUSE_MAGIC )  break;
		lu = vu->up.lu_p;
		if( old_state != NMG_STATE_OUT && lu->orientation == OT_BOOLPLACE )  {
			/* If something connects to the surface of our face,
			 * hang on to this vertexuse.
			 */
			lu->orientation = lu->lumate_p->orientation = OT_UNSPEC;
		}
		break;
	case NMG_ACTION_VFY_EXT:
		/* Verify loop containing this vertex has external orientation */
		lu = nmg_find_lu_of_vu( vu );
		NMG_CK_LOOPUSE(lu);
		switch( lu->orientation )  {
		case OT_SAME:
			break;
		default:
			bu_log("nmg_face_state_transition: VFY_EXT got orientation=%s\n",
				nmg_orientation(lu->orientation) );
			break;
		}
		break;
	case NMG_ACTION_VFY_MULTI:
		/*  Ensure that there are multiple vertexuse's at this
		 *  vertex along the ray.
		 *  If not, the table entry is illegal.
		 */
		if( multi )  break;
		bu_log("nmg_face_state_transition: VFY_MULTI had only 1 vertex\n");
		goto bomb;
	case NMG_ACTION_LONE_V_ESPLIT:
		/*
		 *  Split edge to include vertex from this lone vert loop.
		 *  This only happens in an "ON" state, so split the edge that
		 *  starts (or ends) with the previously seen vertex.
		 *  Note that the forward going edge may point the wrong way,
		 *  i.e., not lie on the ray at all.
		 *  Also note that the previous member(s) of vu[] may be
		 *  lone vert loops that were not processed due to optimization,
		 *  so it may be necessary to look back a ways to find
		 *  the vertexuse which started this ON edge.
		 */
		lu = nmg_find_lu_of_vu( vu );
		NMG_CK_LOOPUSE(lu);
		for( e_pos = pos-1; e_pos >= 0; e_pos-- )  {
			prev_vu = rs->vu[e_pos];
			NMG_CK_VERTEXUSE(prev_vu);
			prev_lu = nmg_find_lu_of_vu( prev_vu );
			/* lu is lone vert loop; l_p is distinct from prev_lu->l_p */
			if( *prev_vu->up.magic_p == NMG_EDGEUSE_MAGIC )
				break;
			/* Not an edgeuse, prob. a loopuse, continue backwards */
#if 0
			bu_log("prev_vu->up is %s\n", bu_identify_magic(*prev_vu->up.magic_p) );
			nmg_pr_vu(prev_vu, "prev ");
			nmg_pr_vu(rs->vu[e_pos], "cur  ");
#endif
		}
		if( e_pos < 0 ) rt_bomb("nmg_face_state_transition: LONE_V_ESPLIT can't find start of edge!\n");
		eu = prev_vu->up.eu_p;
		NMG_CK_EDGEUSE(eu);
		e_assessment = nmg_assess_eu( eu, 1, rs, e_pos );	/* forw */
		if( e_assessment == NMG_E_ASSESSMENT_ON_FORW )  {
			/* "eu" (forw) is the right edge to split */
		} else {
			e_assessment = nmg_assess_eu( eu, 0, rs, e_pos ); /*rev*/
			if( e_assessment == NMG_E_ASSESSMENT_ON_REV )  {
				/* (reverse) "eu" is the right one */
				eu = BU_LIST_PPREV_CIRC( edgeuse, eu );
			} else {
				/* What went wrong? */
				bu_log("LONE_V_ESPLIT:  rev e_assessment = %s\n", nmg_e_assessment_names[e_assessment]);
				rt_bomb("nmg_face_state_transition: LONE_V_ESPLIT could not find ON edge to split\n");
			}
		}
		/* Break edge, update vu table with new value */
		if( vu->v_p == eu->vu_p->v_p )  {
			/* Edge already starts at same vertex */
			rs->vu[pos] = eu->vu_p;
		} else if( vu->v_p == eu->eumate_p->vu_p->v_p )  {
			/* Edge already ends at same vertex */
			rs->vu[pos] = BU_LIST_PNEXT_CIRC(edgeuse, eu)->vu_p;
		} else {
			/* Break edge, force onto isect line */
			nmg_edge_geom_isect_line( eu, rs, "LONE_V_ESPLIT, before edge split" );
			rs->vu[pos] = nmg_ebreaker( vu->v_p, eu, rs->tol )->vu_p;
		}
		/* Kill lone vertex loop (and vertexuse) */
		nmg_klu(lu);
		if(rt_g.NMG_debug&DEBUG_FCUT)  {
			bu_log("After LONE_V_ESPLIT, the final loop:\n");
			lu = nmg_find_lu_of_vu(rs->vu[pos]);
			NMG_CK_LOOPUSE(lu);
			nmg_pr_lu(lu, "   ");
			nmg_plot_lu_ray(lu, rs->vu[0], rs->vu[rs->nvu-1], rs->left );
		}
		break;
	case NMG_ACTION_LONE_V_JAUNT:
		/*
		 * Take current loop on a jaunt from current (prev_vu) edge
		 * up to the vertex (vu) of this lone vertex loop,
		 * and back again.
		 * This only happens in "IN" state.
		 */
		prev_vu = rs->vu[pos-1];
		NMG_CK_VERTEXUSE(prev_vu);

		if( *prev_vu->up.magic_p == NMG_LOOPUSE_MAGIC )  {
			/* Both prev and current are lone vertex loops */
			rs->vu[pos] = nmg_join_2singvu_loops( prev_vu, vu );
		    	/* Set orientation */
			lu = nmg_find_lu_of_vu(rs->vu[pos]);
			NMG_CK_LOOPUSE(lu);
			/* If state is IN, this is a "crack" loop */
			nmg_set_lu_orientation( lu, old_state==NMG_STATE_IN );
		} else {
			rs->vu[pos] = nmg_join_singvu_loop( prev_vu, vu );
		}

		/*  We know edge geom is null, make it be the isect line */
		first_new_eu = BU_LIST_PPREV_CIRC(edgeuse, rs->vu[pos]->up.eu_p);
		nmg_edge_geom_isect_line( first_new_eu, rs, "LONE_V_JAUNT, new edge" );

		/* Fusing to this new edge will happen in nmg_face_cutjoin() */

		/* Recompute loop geometry.  Bounding box may have expanded */
		nmg_loop_g(nmg_find_lu_of_vu(rs->vu[pos])->l_p, rs->tol);

		if(rt_g.NMG_debug&DEBUG_FCUT)  {
			bu_log("After LONE_V_JAUNT, the final loop:\n");
			nmg_pr_lu_briefly(nmg_find_lu_of_vu(rs->vu[pos]), (char *)0);
			nmg_plot_lu_ray(nmg_find_lu_of_vu(rs->vu[pos]),
				rs->vu[0], rs->vu[rs->nvu-1], rs->left );
		}
		break;
	case NMG_ACTION_CUTJOIN:
		/*
		 *  Cut loop into two, or join two into one.
		 *  The operation happens between the previous vu
		 *  and the current one.
		 *  If the two vu's are part of the same loop,
		 *  then cut the loop into two, otherwise
		 *  join the two loops into one.
		 */
		lu = nmg_find_lu_of_vu( vu );
		NMG_CK_LOOPUSE(lu);
		fu = lu->up.fu_p;
		NMG_CK_FACEUSE(fu);
		prev_vu = rs->vu[pos-1];
		NMG_CK_VERTEXUSE(prev_vu);
		prev_lu = nmg_find_lu_of_vu( prev_vu );
		NMG_CK_LOOPUSE(prev_lu);

		/* See if there is an edge joining the 2 vertices already */
		old_eu = nmg_findeu(prev_vu->v_p, vu->v_p, (struct shell *)NULL,
			(struct edgeuse *)NULL, 0);

		if( lu->l_p == prev_lu->l_p )  {
			int is_crack;

			/* Same loop, cut into two */
			is_crack = nmg_loop_is_a_crack(lu);
			if(rt_g.NMG_debug&DEBUG_FCUT)
				bu_log("Calling nmg_cut_loop(prev_vu=x%x, vu=x%x) is_crack=%d, old_eu=x%x\n", prev_vu, vu, is_crack, old_eu);
			if( prev_vu->v_p == vu->v_p )  {
				/* The loop touches itself already */
				lu = nmg_split_lu_at_vu( prev_lu, prev_vu );
			} else {
				lu = nmg_cut_loop( prev_vu, vu );

				/* New edge has been created between 2 verts, fuse */
				/* first_new_eu starts at vu, ends at prev_vu */
				/* second_new_eu starts at prev_vu, ends at vu */
				first_new_eu = BU_LIST_PPREV_CIRC( edgeuse, &prev_vu->up.eu_p->l );
				second_new_eu = BU_LIST_PPREV_CIRC( edgeuse, &vu->up.eu_p->l );
				NMG_CK_EDGEUSE(first_new_eu);
				NMG_CK_EDGEUSE(second_new_eu);
				if( first_new_eu->vu_p->v_p != vu->v_p || first_new_eu->eumate_p->vu_p->v_p != prev_vu->v_p )  {
					nmg_pr_vu_briefly(prev_vu, 0);
					nmg_pr_vu_briefly(vu, 0);
					nmg_pr_eu_endpoints(first_new_eu, 0);
					nmg_pr_eu_endpoints(second_new_eu, 0);
					if(old_eu)	nmg_pr_eu_endpoints(old_eu, 0);
					rt_bomb("nmg_face_state_transition() cut loop bafflement\n");
				}
				/* Fuse new edge to intersect line, old edge */
				nmg_edge_geom_isect_line( first_new_eu, rs, "CUTJOIN, new edge after loop cut" );
				if( old_eu )  nmg_radial_join_eu( old_eu, first_new_eu, rs->tol );
			}

			nmg_loop_g( lu->l_p, rs->tol );
			nmg_loop_g( prev_lu->l_p, rs->tol );

			nmg_lu_reorient( lu );
			nmg_lu_reorient( prev_lu );

			if(rt_g.NMG_debug&DEBUG_FCUT)  {
				bu_log("After CUT, the final loop:\n");
				nmg_pr_lu_briefly(nmg_find_lu_of_vu(rs->vu[pos]), (char *)0);
				nmg_plot_lu_ray(nmg_find_lu_of_vu(rs->vu[pos]),
					rs->vu[0], rs->vu[rs->nvu-1], rs->left );
			}
			break;
		}
		/*
		 *  prev_vu and vu are in different loops,
		 *  join the two loops into one loop.
		 *  No edgeuses are deleted at this stage,
		 *  so some "snakes" may appear in the process.
		 */
		if(rt_g.NMG_debug&DEBUG_FCUT)  {
			bu_log("nmg_face_state_transition() joining 2 loops, prev_vu=x%x, vu=x%x, old_eu=x%x\n",
				prev_vu, vu, old_eu);
		}

		if( *prev_vu->up.magic_p == NMG_LOOPUSE_MAGIC ||
		    *vu->up.magic_p == NMG_LOOPUSE_MAGIC )  {
		    	/* One (or both) is a loop of a single vertex */
		    	/* This is the special boolean vertex marker */

		    	/* See if there is an existing edge between
		    	 * the two vertices.
		    	 */

			if( *prev_vu->up.magic_p == NMG_LOOPUSE_MAGIC &&
			    *vu->up.magic_p != NMG_LOOPUSE_MAGIC )  {
			    	if(rt_g.NMG_debug&DEBUG_FCUT)
			    		bu_log( "\tprev_vu is a vertex loop\n" );
			    	/* if prev_vu is geometrically on an edge that goes through vu,
			    	 * then split that edge at prev_vu */
				rs->vu[pos-1] = nmg_join_singvu_loop( vu, prev_vu );
			} else if( *vu->up.magic_p == NMG_LOOPUSE_MAGIC &&
			    *prev_vu->up.magic_p != NMG_LOOPUSE_MAGIC )  {
			    	if(rt_g.NMG_debug&DEBUG_FCUT)
			    		bu_log( "\tvu is a vertex loop\n" );
			    	/* if vu is geometrically on an edge that goes through prev_vu,
			    	 * then split that edge at vu */
				rs->vu[pos] = nmg_join_singvu_loop( prev_vu, vu );
			} else {
				/* Both are loops of single vertex */
			    	if(rt_g.NMG_debug&DEBUG_FCUT)
			    		bu_log( "\tprev_vu and vu are vertex loops\n" );
				vu = rs->vu[pos] = nmg_join_2singvu_loops( prev_vu, vu );
			    	/* Set orientation */
				lu = nmg_find_lu_of_vu(vu);
				NMG_CK_LOOPUSE(lu);
				nmg_set_lu_orientation( lu, old_state==NMG_STATE_IN );
			}
		} else {
			rs->vu[pos] = nmg_join_2loops( prev_vu, vu );
		}

		/* XXX If an edge has been built between prev_vu and vu,
		 * force it's geometry to lie on the ray.
		 */
		vu = rs->vu[pos];
		lu = nmg_find_lu_of_vu(vu);
		NMG_CK_LOOPUSE(lu);
		prev_vu = rs->vu[pos-1];
		eu = prev_vu->up.eu_p;
		NMG_CK_EDGEUSE(eu);
		first_new_eu = BU_LIST_PPREV_CIRC(edgeuse, rs->vu[pos]->up.eu_p);
		NMG_CK_EDGEUSE(first_new_eu);
		if( eu == first_new_eu )  {
			nmg_edge_geom_isect_line( first_new_eu, rs, "CUTJOIN new edge" );
			if( old_eu )  nmg_radial_join_eu( old_eu, eu, rs->tol );
		}

		/* Recompute loop geometry.  Bounding box may have expanded */
		nmg_loop_g(lu->l_p, rs->tol);

		if(rt_g.NMG_debug&DEBUG_FCUT)  {
			bu_log("After JOIN, the final loop:\n");
			nmg_pr_lu_briefly(lu, (char *)0);
			nmg_plot_lu_ray( lu, rs->vu[0], rs->vu[rs->nvu-1], rs->left );
		}
		break;
	}

	rs->state = new_state;

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		/* Verify both faces are still OK */
		nmg_vfu( &rs->fu1->s_p->fu_hd, rs->fu1->s_p );
		nmg_vfu( &rs->fu2->s_p->fu_hd, rs->fu2->s_p );
nmg_fu_touchingloops(rs->fu1);
nmg_fu_touchingloops(rs->fu2);
	}

	if(rt_g.NMG_debug&DEBUG_FCUT)  {
		bu_log("nmg_face_state_transition(vu x%x, pos=%d) END\n",
			rs->vu[pos], pos);
	}
	if(rs->eg_p) NMG_CK_EDGE_G_LSEG(rs->eg_p);
	return 0;
}

@


11.41
log
@change conf.h to a wrapped config.h
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_fcut.c,v 11.40 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.40
log
@merge of ansi-6-0-branch into HEAD
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d41 5
a45 1
#include "conf.h"
@


11.39
log
@update copyright to include span through 2003
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.38 2002/08/20 17:08:03 jra Exp $ (ARL)";
d215 8
a222 8
static void ptbl_vsort(b, fu1, fu2, pt, dir, mag, dist_tol)
struct bu_ptbl *b;		/* table of vertexuses on intercept line */
struct faceuse	*fu1;		/* unused? */
struct faceuse	*fu2;		/* unused? */
point_t		pt;
vect_t		dir;
fastf_t		*mag;
fastf_t		dist_tol;
d341 1
a341 3
nmg_ck_vu_ptbl( p, fu )
struct bu_ptbl	*p;
struct faceuse	*fu;
d415 6
a420 6
nmg_vu_angle_measure( vu, x_dir, y_dir, assessment, in )
struct vertexuse	*vu;
vect_t			x_dir;
vect_t			y_dir;
int			assessment;
int			in;	/* 1 = inbound edge, 0 = outbound edge */
d529 1
a529 3
nmg_is_v_on_rs_list( rs, v )
const struct nmg_ray_state	*rs;
const struct vertex		*v;
d553 1
a553 5
nmg_assess_eu( eu, forw, rs, pos )
struct edgeuse		*eu;
int			forw;
struct nmg_ray_state	*rs;
int			pos;
d736 1
a736 3
nmg_assess_vu( rs, pos )
struct nmg_ray_state	*rs;
int			pos;
d841 1
a841 2
nmg_pr_vu_stuff( vs )
const struct nmg_vu_stuff	*vs;
d872 4
a875 4
nmg_wedge_class(ass, a,b)
int	ass;			/* assessment of two edges forming wedge */
double	a;
double	b;
d975 1
a975 2
nmg_compare_2_wedges( a, b, c, d )
double	a,b,c,d;
d1129 8
a1136 8
nmg_find_vu_in_wedge( vs, start, end, lo_ang, hi_ang, wclass, skip_array )
struct nmg_vu_stuff	*vs;
int	start;		/* vu index of coincident range */
int	end;
double	lo_ang;
double	hi_ang;
int	wclass;
int	skip_array[];
d1257 1
a1257 3
nmg_is_wedge_before_cross( wedge, cross )
const struct nmg_vu_stuff	*wedge;
const struct nmg_vu_stuff	*cross;
d1322 1
a1322 1
nmg_face_vu_compare( aa, bb )
d1324 2
a1325 2
 const void	*aa;
 const void	*bb;
d1327 2
a1328 2
 const genptr_t	aa;
 const genptr_t	bb;
d1465 1
a1465 5
nmg_face_vu_dot( vsp, lu, rs, ass )
struct nmg_vu_stuff		*vsp;
struct loopuse			*lu;
const struct nmg_ray_state	*rs;
int				ass;
d1537 9
a1545 9
nmg_special_wedge_processing( vs, start, end, lo_ang, hi_ang, wclass, exclude, tol )
struct nmg_vu_stuff	*vs;
int	start;		/* vu index of coincident range */
int	end;
double	lo_ang;
double	hi_ang;
int	wclass;
int	*exclude;
const struct bn_tol	*tol;
d1705 4
a1708 4
nmg_face_coincident_vu_sort( rs, start, end )
struct nmg_ray_state	*rs;
int			start;		/* first index */
int			end;		/* last index + 1 */
d1927 1
a1927 2
nmg_sanitize_fu(fu)
struct faceuse	*fu;
d1960 9
a1968 9
nmg_face_rs_init( rs, b, fu1, fu2, pt, dir, eg, tol )
struct nmg_ray_state	*rs;
struct bu_ptbl	*b;		/* table of vertexuses in fu1 on intercept line */
struct faceuse	*fu1;		/* face being worked */
struct faceuse	*fu2;		/* for plane equation */
point_t		pt;
vect_t		dir;
struct edge_g_lseg		*eg;	/* may be null.  Geom of isect line. */
const struct bn_tol	*tol;
d2071 1
a2071 5
nmg_face_next_vu_interval( rs, cur, mag, other_rs_state )
struct nmg_ray_state	*rs;
int		cur;
fastf_t		*mag;
int		other_rs_state;
d2166 1
a2166 4
nmg_edge_geom_isect_line( eu, rs, reason )
struct edgeuse		*eu;
struct nmg_ray_state	*rs;
const char		*reason;
d2224 1
a2224 6
find_loop_to_cut( index1, index2, prior_start, prior_end, next_start, next_end, mid_pt, rs )
int *index1,*index2;
int prior_start, prior_end;
int next_start, next_end;
point_t mid_pt;
struct nmg_ray_state *rs;
d2610 1
a2610 3
nmg_eu_angle( eu, vp )
struct edgeuse *eu;
struct vertex *vp;
d2642 1
a2642 5
find_best_vu( start, end, other_vp, rs )
int start;
int end;
struct vertex *other_vp;
struct nmg_ray_state *rs;
d2800 1
a2800 2
nmg_fcut_face( rs )
struct nmg_ray_state *rs;
d3199 1
a3199 5
nmg_face_combine_jra(rs1, mag1, rs2, mag2)
struct nmg_ray_state	*rs1;
fastf_t			*mag1;
struct nmg_ray_state	*rs2;
fastf_t			*mag2;
d3213 1
a3213 5
nmg_face_combineX(rs1, mag1, rs2, mag2)
struct nmg_ray_state	*rs1;
fastf_t			*mag1;
struct nmg_ray_state	*rs2;
fastf_t			*mag2;
d3337 1
a3337 4
nmg_unlist_v(b, mag, v)
struct bu_ptbl	*b;
fastf_t *mag;
struct vertex	*v;
d3366 6
a3371 6
nmg_onon_fix( rs, b, ob, mag, omag )
struct nmg_ray_state	*rs;
struct bu_ptbl		*b;
struct bu_ptbl		*ob;	/* other rs's vu list */
fastf_t			*mag;	/* list of distances from intersect ray start point */
fastf_t			*omag;	/* list of distances from intersect ray start point */
d3553 11
a3563 11
nmg_face_cutjoin(b1, b2, mag1, mag2, fu1, fu2, pt, dir, eg, tol)
struct bu_ptbl	*b1;		/* table of vertexuses in fu1 on intercept line */
struct bu_ptbl	*b2;		/* table of vertexuses in fu2 on intercept line */
fastf_t		*mag1;		/* table of distances to vertexuses from is->pt */
fastf_t		*mag2;		/* table of distances to vertexuses from is->pt */
struct faceuse	*fu1;		/* face being worked */
struct faceuse	*fu2;		/* for plane equation */
point_t		pt;
vect_t		dir;
struct edge_g_lseg		*eg;	/* may be null.  geometry of isect line */
const struct bn_tol	*tol;
d3708 1
a3708 6
nmg_fcut_face_2d( vu_list, mag, fu1, fu2, tol )
struct bu_ptbl *vu_list;
fastf_t *mag;
struct faceuse *fu1;
struct faceuse *fu2;
struct bn_tol *tol;
d3873 5
a3877 5
nmg_insert_vu_if_on_edge( vu1 , vu2 , new_eu , tol )
struct vertexuse *vu1;	/* vertexuse from a loop of a single vertex */
struct vertexuse *vu2;	/* vertexuse from another loop */
struct edgeuse *new_eu;	/* use of new edge that may be created (implicit return ) */
struct bn_tol *tol;	/* tolerance for collinearity check */
d3966 1
a3966 5
nmg_face_state_transition( rs, pos, multi, other_rs_state )
struct nmg_ray_state	*rs;
int			pos;
int			multi;
int			other_rs_state;
@


11.38
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1994 by the United States Army
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.36 2002/05/12 03:49:42 jra Exp $ (ARL)";
@


11.38.4.1
log
@sync to HEAD...
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_fcut.c,v 11.39 2004/02/02 17:39:22 morrison Exp $ (ARL)";
@


11.38.10.1
log
@merge from HEAD
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.39 2004/02/02 17:39:22 morrison Exp $ (ARL)";
@


11.38.10.2
log
@merge from head
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.38.10.1 2004/02/12 18:37:43 erikg Exp $ (ARL)";
@


11.38.2.1
log
@Initial ANSIfication
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.38 2002/08/20 17:08:03 jra Exp $ (ARL)";
d215 8
a222 8
static void ptbl_vsort(struct bu_ptbl *b, struct faceuse *fu1, struct faceuse *fu2, fastf_t *pt, fastf_t *dir, fastf_t *mag, fastf_t dist_tol)
                  		/* table of vertexuses on intercept line */
              	     		/* unused? */
              	     		/* unused? */
       		   
      		    
       		     
       		         
d341 3
a343 1
nmg_ck_vu_ptbl(struct bu_ptbl *p, struct faceuse *fu)
d417 6
a422 6
nmg_vu_angle_measure(struct vertexuse *vu, fastf_t *x_dir, fastf_t *y_dir, int assessment, int in)
                	    
      			      
      			      
   			           
   			   	/* 1 = inbound edge, 0 = outbound edge */
d531 3
a533 1
nmg_is_v_on_rs_list(const struct nmg_ray_state *rs, const struct vertex *v)
d557 5
a561 1
nmg_assess_eu(struct edgeuse *eu, int forw, struct nmg_ray_state *rs, int pos)
d744 3
a746 1
nmg_assess_vu(struct nmg_ray_state *rs, int pos)
d851 2
a852 1
nmg_pr_vu_stuff(const struct nmg_vu_stuff *vs)
d883 4
a886 4
nmg_wedge_class(int ass, double a, double b)
   	    			/* assessment of two edges forming wedge */
      	  
      	  
d986 2
a987 1
nmg_compare_2_wedges(double a, double b, double c, double d)
d1141 8
a1148 8
nmg_find_vu_in_wedge(struct nmg_vu_stuff *vs, int start, int end, double lo_ang, double hi_ang, int wclass, int *skip_array)
                   	    
   	      		/* vu index of coincident range */
   	    
      	       
      	       
   	       
   	             
d1269 3
a1271 1
nmg_is_wedge_before_cross(const struct nmg_vu_stuff *wedge, const struct nmg_vu_stuff *cross)
d1336 1
a1336 1
nmg_face_vu_compare(const void *aa, const void *bb)
d1338 2
a1339 2
           	    
           	    
d1341 2
a1342 2
               	   
               	   
d1479 5
a1483 1
nmg_face_vu_dot(struct nmg_vu_stuff *vsp, struct loopuse *lu, const struct nmg_ray_state *rs, int ass)
d1555 9
a1563 9
nmg_special_wedge_processing(struct nmg_vu_stuff *vs, int start, int end, double lo_ang, double hi_ang, int wclass, int *exclude, const struct bn_tol *tol)
                   	    
   	      		/* vu index of coincident range */
   	    
      	       
      	       
   	       
   	         
                   	     
d1723 4
a1726 4
nmg_face_coincident_vu_sort(struct nmg_ray_state *rs, int start, int end)
                    	    
   			      		/* first index */
   			    		/* last index + 1 */
d1945 2
a1946 1
nmg_sanitize_fu(struct faceuse *fu)
d1979 9
a1987 9
nmg_face_rs_init(struct nmg_ray_state *rs, struct bu_ptbl *b, struct faceuse *fu1, struct faceuse *fu2, fastf_t *pt, fastf_t *dir, struct edge_g_lseg *eg, const struct bn_tol *tol)
                    	    
              	   		/* table of vertexuses in fu1 on intercept line */
              	     		/* face being worked */
              	     		/* for plane equation */
       		   
      		    
                  		    	/* may be null.  Geom of isect line. */
                   	     
d2090 5
a2094 1
nmg_face_next_vu_interval(struct nmg_ray_state *rs, int cur, fastf_t *mag, int other_rs_state)
d2189 4
a2192 1
nmg_edge_geom_isect_line(struct edgeuse *eu, struct nmg_ray_state *rs, const char *reason)
d2250 6
a2255 1
find_loop_to_cut(int *index1, int *index2, int prior_start, int prior_end, int next_start, int next_end, fastf_t *mid_pt, struct nmg_ray_state *rs)
d2641 3
a2643 1
nmg_eu_angle(struct edgeuse *eu, struct vertex *vp)
d2675 5
a2679 1
find_best_vu(int start, int end, struct vertex *other_vp, struct nmg_ray_state *rs)
d2837 2
a2838 1
nmg_fcut_face(struct nmg_ray_state *rs)
d3237 5
a3241 1
nmg_face_combine_jra(struct nmg_ray_state *rs1, fastf_t *mag1, struct nmg_ray_state *rs2, fastf_t *mag2)
d3255 5
a3259 1
nmg_face_combineX(struct nmg_ray_state *rs1, fastf_t *mag1, struct nmg_ray_state *rs2, fastf_t *mag2)
d3383 4
a3386 1
nmg_unlist_v(struct bu_ptbl *b, fastf_t *mag, struct vertex *v)
d3415 6
a3420 6
nmg_onon_fix(struct nmg_ray_state *rs, struct bu_ptbl *b, struct bu_ptbl *ob, fastf_t *mag, fastf_t *omag)
                    	    
              		   
              		    	/* other rs's vu list */
       			     	/* list of distances from intersect ray start point */
       			      	/* list of distances from intersect ray start point */
d3602 11
a3612 11
nmg_face_cutjoin(struct bu_ptbl *b1, struct bu_ptbl *b2, fastf_t *mag1, fastf_t *mag2, struct faceuse *fu1, struct faceuse *fu2, fastf_t *pt, fastf_t *dir, struct edge_g_lseg *eg, const struct bn_tol *tol)
              	    		/* table of vertexuses in fu1 on intercept line */
              	    		/* table of vertexuses in fu2 on intercept line */
       		      		/* table of distances to vertexuses from is->pt */
       		      		/* table of distances to vertexuses from is->pt */
              	     		/* face being worked */
              	     		/* for plane equation */
       		   
      		    
                  		    	/* may be null.  geometry of isect line */
                   	     
d3757 6
a3762 1
nmg_fcut_face_2d(struct bu_ptbl *vu_list, fastf_t *mag, struct faceuse *fu1, struct faceuse *fu2, struct bn_tol *tol)
d3927 5
a3931 5
nmg_insert_vu_if_on_edge(struct vertexuse *vu1, struct vertexuse *vu2, struct edgeuse *new_eu, struct bn_tol *tol)
                      	/* vertexuse from a loop of a single vertex */
                      	/* vertexuse from another loop */
                       	/* use of new edge that may be created (implicit return ) */
                   	/* tolerance for collinearity check */
d4020 5
a4024 1
nmg_face_state_transition(struct nmg_ray_state *rs, int pos, int multi, int other_rs_state)
@


11.38.2.2
log
@sync branch with HEAD
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.37
log
@Converted from K&R to ANSI C - RFH
@
text
@d215 8
a222 8
static void ptbl_vsort(struct bu_ptbl *b, struct faceuse *fu1, struct faceuse *fu2, fastf_t *pt, fastf_t *dir, fastf_t *mag, fastf_t dist_tol)
                  		/* table of vertexuses on intercept line */
              	     		/* unused? */
              	     		/* unused? */
       		   
      		    
       		     
       		         
d341 3
a343 1
nmg_ck_vu_ptbl(struct bu_ptbl *p, struct faceuse *fu)
d417 6
a422 6
nmg_vu_angle_measure(struct vertexuse *vu, fastf_t *x_dir, fastf_t *y_dir, int assessment, int in)
                	    
      			      
      			      
   			           
   			   	/* 1 = inbound edge, 0 = outbound edge */
d531 3
a533 1
nmg_is_v_on_rs_list(const struct nmg_ray_state *rs, const struct vertex *v)
d557 5
a561 1
nmg_assess_eu(struct edgeuse *eu, int forw, struct nmg_ray_state *rs, int pos)
d744 3
a746 1
nmg_assess_vu(struct nmg_ray_state *rs, int pos)
d851 2
a852 1
nmg_pr_vu_stuff(const struct nmg_vu_stuff *vs)
d883 4
a886 4
nmg_wedge_class(int ass, double a, double b)
   	    			/* assessment of two edges forming wedge */
      	  
      	  
d986 2
a987 1
nmg_compare_2_wedges(double a, double b, double c, double d)
d1141 8
a1148 8
nmg_find_vu_in_wedge(struct nmg_vu_stuff *vs, int start, int end, double lo_ang, double hi_ang, int wclass, int *skip_array)
                   	    
   	      		/* vu index of coincident range */
   	    
      	       
      	       
   	       
   	             
d1269 3
a1271 1
nmg_is_wedge_before_cross(const struct nmg_vu_stuff *wedge, const struct nmg_vu_stuff *cross)
d1336 1
a1336 1
nmg_face_vu_compare(const void *aa, const void *bb)
d1338 2
a1339 2
           	    
           	    
d1341 2
a1342 2
               	   
               	   
d1479 5
a1483 1
nmg_face_vu_dot(struct nmg_vu_stuff *vsp, struct loopuse *lu, const struct nmg_ray_state *rs, int ass)
d1555 9
a1563 9
nmg_special_wedge_processing(struct nmg_vu_stuff *vs, int start, int end, double lo_ang, double hi_ang, int wclass, int *exclude, const struct bn_tol *tol)
                   	    
   	      		/* vu index of coincident range */
   	    
      	       
      	       
   	       
   	         
                   	     
d1723 4
a1726 4
nmg_face_coincident_vu_sort(struct nmg_ray_state *rs, int start, int end)
                    	    
   			      		/* first index */
   			    		/* last index + 1 */
d1945 2
a1946 1
nmg_sanitize_fu(struct faceuse *fu)
d1979 9
a1987 9
nmg_face_rs_init(struct nmg_ray_state *rs, struct bu_ptbl *b, struct faceuse *fu1, struct faceuse *fu2, fastf_t *pt, fastf_t *dir, struct edge_g_lseg *eg, const struct bn_tol *tol)
                    	    
              	   		/* table of vertexuses in fu1 on intercept line */
              	     		/* face being worked */
              	     		/* for plane equation */
       		   
      		    
                  		    	/* may be null.  Geom of isect line. */
                   	     
d2090 5
a2094 1
nmg_face_next_vu_interval(struct nmg_ray_state *rs, int cur, fastf_t *mag, int other_rs_state)
d2189 4
a2192 1
nmg_edge_geom_isect_line(struct edgeuse *eu, struct nmg_ray_state *rs, const char *reason)
d2250 6
a2255 1
find_loop_to_cut(int *index1, int *index2, int prior_start, int prior_end, int next_start, int next_end, fastf_t *mid_pt, struct nmg_ray_state *rs)
d2641 3
a2643 1
nmg_eu_angle(struct edgeuse *eu, struct vertex *vp)
d2675 5
a2679 1
find_best_vu(int start, int end, struct vertex *other_vp, struct nmg_ray_state *rs)
d2837 2
a2838 1
nmg_fcut_face(struct nmg_ray_state *rs)
d3237 5
a3241 1
nmg_face_combine_jra(struct nmg_ray_state *rs1, fastf_t *mag1, struct nmg_ray_state *rs2, fastf_t *mag2)
d3255 5
a3259 1
nmg_face_combineX(struct nmg_ray_state *rs1, fastf_t *mag1, struct nmg_ray_state *rs2, fastf_t *mag2)
d3383 4
a3386 1
nmg_unlist_v(struct bu_ptbl *b, fastf_t *mag, struct vertex *v)
d3415 6
a3420 6
nmg_onon_fix(struct nmg_ray_state *rs, struct bu_ptbl *b, struct bu_ptbl *ob, fastf_t *mag, fastf_t *omag)
                    	    
              		   
              		    	/* other rs's vu list */
       			     	/* list of distances from intersect ray start point */
       			      	/* list of distances from intersect ray start point */
d3602 11
a3612 11
nmg_face_cutjoin(struct bu_ptbl *b1, struct bu_ptbl *b2, fastf_t *mag1, fastf_t *mag2, struct faceuse *fu1, struct faceuse *fu2, fastf_t *pt, fastf_t *dir, struct edge_g_lseg *eg, const struct bn_tol *tol)
              	    		/* table of vertexuses in fu1 on intercept line */
              	    		/* table of vertexuses in fu2 on intercept line */
       		      		/* table of distances to vertexuses from is->pt */
       		      		/* table of distances to vertexuses from is->pt */
              	     		/* face being worked */
              	     		/* for plane equation */
       		   
      		    
                  		    	/* may be null.  geometry of isect line */
                   	     
d3757 6
a3762 1
nmg_fcut_face_2d(struct bu_ptbl *vu_list, fastf_t *mag, struct faceuse *fu1, struct faceuse *fu2, struct bn_tol *tol)
d3927 5
a3931 5
nmg_insert_vu_if_on_edge(struct vertexuse *vu1, struct vertexuse *vu2, struct edgeuse *new_eu, struct bn_tol *tol)
                      	/* vertexuse from a loop of a single vertex */
                      	/* vertexuse from another loop */
                       	/* use of new edge that may be created (implicit return ) */
                   	/* tolerance for collinearity check */
d4020 5
a4024 1
nmg_face_state_transition(struct nmg_ray_state *rs, int pos, int multi, int other_rs_state)
@


11.36
log
@Turned off some old excessive debug logging
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.35 2001/05/17 20:05:25 morrison Exp $ (ARL)";
d215 8
a222 8
static void ptbl_vsort(b, fu1, fu2, pt, dir, mag, dist_tol)
struct bu_ptbl *b;		/* table of vertexuses on intercept line */
struct faceuse	*fu1;		/* unused? */
struct faceuse	*fu2;		/* unused? */
point_t		pt;
vect_t		dir;
fastf_t		*mag;
fastf_t		dist_tol;
d341 1
a341 3
nmg_ck_vu_ptbl( p, fu )
struct bu_ptbl	*p;
struct faceuse	*fu;
d415 6
a420 6
nmg_vu_angle_measure( vu, x_dir, y_dir, assessment, in )
struct vertexuse	*vu;
vect_t			x_dir;
vect_t			y_dir;
int			assessment;
int			in;	/* 1 = inbound edge, 0 = outbound edge */
d529 1
a529 3
nmg_is_v_on_rs_list( rs, v )
const struct nmg_ray_state	*rs;
const struct vertex		*v;
d553 1
a553 5
nmg_assess_eu( eu, forw, rs, pos )
struct edgeuse		*eu;
int			forw;
struct nmg_ray_state	*rs;
int			pos;
d736 1
a736 3
nmg_assess_vu( rs, pos )
struct nmg_ray_state	*rs;
int			pos;
d841 1
a841 2
nmg_pr_vu_stuff( vs )
const struct nmg_vu_stuff	*vs;
d872 4
a875 4
nmg_wedge_class(ass, a,b)
int	ass;			/* assessment of two edges forming wedge */
double	a;
double	b;
d975 1
a975 2
nmg_compare_2_wedges( a, b, c, d )
double	a,b,c,d;
d1129 8
a1136 8
nmg_find_vu_in_wedge( vs, start, end, lo_ang, hi_ang, wclass, skip_array )
struct nmg_vu_stuff	*vs;
int	start;		/* vu index of coincident range */
int	end;
double	lo_ang;
double	hi_ang;
int	wclass;
int	skip_array[];
d1257 1
a1257 3
nmg_is_wedge_before_cross( wedge, cross )
const struct nmg_vu_stuff	*wedge;
const struct nmg_vu_stuff	*cross;
d1322 1
a1322 1
nmg_face_vu_compare( aa, bb )
d1324 2
a1325 2
 const void	*aa;
 const void	*bb;
d1327 2
a1328 2
 const genptr_t	aa;
 const genptr_t	bb;
d1465 1
a1465 5
nmg_face_vu_dot( vsp, lu, rs, ass )
struct nmg_vu_stuff		*vsp;
struct loopuse			*lu;
const struct nmg_ray_state	*rs;
int				ass;
d1537 9
a1545 9
nmg_special_wedge_processing( vs, start, end, lo_ang, hi_ang, wclass, exclude, tol )
struct nmg_vu_stuff	*vs;
int	start;		/* vu index of coincident range */
int	end;
double	lo_ang;
double	hi_ang;
int	wclass;
int	*exclude;
const struct bn_tol	*tol;
d1705 4
a1708 4
nmg_face_coincident_vu_sort( rs, start, end )
struct nmg_ray_state	*rs;
int			start;		/* first index */
int			end;		/* last index + 1 */
d1927 1
a1927 2
nmg_sanitize_fu(fu)
struct faceuse	*fu;
d1960 9
a1968 9
nmg_face_rs_init( rs, b, fu1, fu2, pt, dir, eg, tol )
struct nmg_ray_state	*rs;
struct bu_ptbl	*b;		/* table of vertexuses in fu1 on intercept line */
struct faceuse	*fu1;		/* face being worked */
struct faceuse	*fu2;		/* for plane equation */
point_t		pt;
vect_t		dir;
struct edge_g_lseg		*eg;	/* may be null.  Geom of isect line. */
const struct bn_tol	*tol;
d2071 1
a2071 5
nmg_face_next_vu_interval( rs, cur, mag, other_rs_state )
struct nmg_ray_state	*rs;
int		cur;
fastf_t		*mag;
int		other_rs_state;
d2166 1
a2166 4
nmg_edge_geom_isect_line( eu, rs, reason )
struct edgeuse		*eu;
struct nmg_ray_state	*rs;
const char		*reason;
d2224 1
a2224 6
find_loop_to_cut( index1, index2, prior_start, prior_end, next_start, next_end, mid_pt, rs )
int *index1,*index2;
int prior_start, prior_end;
int next_start, next_end;
point_t mid_pt;
struct nmg_ray_state *rs;
d2610 1
a2610 3
nmg_eu_angle( eu, vp )
struct edgeuse *eu;
struct vertex *vp;
d2642 1
a2642 5
find_best_vu( start, end, other_vp, rs )
int start;
int end;
struct vertex *other_vp;
struct nmg_ray_state *rs;
d2800 1
a2800 2
nmg_fcut_face( rs )
struct nmg_ray_state *rs;
d3199 1
a3199 5
nmg_face_combine_jra(rs1, mag1, rs2, mag2)
struct nmg_ray_state	*rs1;
fastf_t			*mag1;
struct nmg_ray_state	*rs2;
fastf_t			*mag2;
d3213 1
a3213 5
nmg_face_combineX(rs1, mag1, rs2, mag2)
struct nmg_ray_state	*rs1;
fastf_t			*mag1;
struct nmg_ray_state	*rs2;
fastf_t			*mag2;
d3337 1
a3337 4
nmg_unlist_v(b, mag, v)
struct bu_ptbl	*b;
fastf_t *mag;
struct vertex	*v;
d3366 6
a3371 6
nmg_onon_fix( rs, b, ob, mag, omag )
struct nmg_ray_state	*rs;
struct bu_ptbl		*b;
struct bu_ptbl		*ob;	/* other rs's vu list */
fastf_t			*mag;	/* list of distances from intersect ray start point */
fastf_t			*omag;	/* list of distances from intersect ray start point */
d3553 11
a3563 11
nmg_face_cutjoin(b1, b2, mag1, mag2, fu1, fu2, pt, dir, eg, tol)
struct bu_ptbl	*b1;		/* table of vertexuses in fu1 on intercept line */
struct bu_ptbl	*b2;		/* table of vertexuses in fu2 on intercept line */
fastf_t		*mag1;		/* table of distances to vertexuses from is->pt */
fastf_t		*mag2;		/* table of distances to vertexuses from is->pt */
struct faceuse	*fu1;		/* face being worked */
struct faceuse	*fu2;		/* for plane equation */
point_t		pt;
vect_t		dir;
struct edge_g_lseg		*eg;	/* may be null.  geometry of isect line */
const struct bn_tol	*tol;
d3708 1
a3708 6
nmg_fcut_face_2d( vu_list, mag, fu1, fu2, tol )
struct bu_ptbl *vu_list;
fastf_t *mag;
struct faceuse *fu1;
struct faceuse *fu2;
struct bn_tol *tol;
d3873 5
a3877 5
nmg_insert_vu_if_on_edge( vu1 , vu2 , new_eu , tol )
struct vertexuse *vu1;	/* vertexuse from a loop of a single vertex */
struct vertexuse *vu2;	/* vertexuse from another loop */
struct edgeuse *new_eu;	/* use of new edge that may be created (implicit return ) */
struct bn_tol *tol;	/* tolerance for collinearity check */
d3966 1
a3966 5
nmg_face_state_transition( rs, pos, multi, other_rs_state )
struct nmg_ray_state	*rs;
int			pos;
int			multi;
int			other_rs_state;
@


11.35
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.34 2001/04/20 22:29:49 morrison Exp $ (ARL)";
d4171 1
d4183 1
@


11.34
log
@CONST to const
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.33 2000/10/19 19:19:46 butler Exp $ (ARL)";
d3363 1
a3363 1
		if( rt_g.debug || rt_g.NMG_debug )  {
d4156 1
a4156 1
	     if( rt_g.debug || rt_g.NMG_debug )  {
@


11.33
log
@Changes to compile under RedHat 7.0
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.32 2000/08/29 03:47:09 butler Exp $ (ARL)";
d61 1
a61 1
static CONST char *nmg_state_names[] = {
d86 1
a86 1
static CONST char *nmg_v_assessment_names[32] = {
d138 1
a138 1
static CONST char *nmg_e_assessment_names[6] = {
d158 1
a158 1
static CONST char *action_names[] = {
d187 1
a187 1
	CONST struct bn_tol	*tol;
d532 2
a533 2
CONST struct nmg_ray_state	*rs;
CONST struct vertex		*v;
d839 1
a839 1
static CONST char *nmg_wedgeclass_string[] = {
d852 1
a852 1
CONST struct nmg_vu_stuff	*vs;
d953 1
a953 1
static CONST char *nmg_wedge2_string[] = {
d1270 2
a1271 2
CONST struct nmg_vu_stuff	*wedge;
CONST struct nmg_vu_stuff	*cross;
d1341 2
a1342 2
 CONST genptr_t	aa;
 CONST genptr_t	bb;
d1345 2
a1346 2
	register CONST struct nmg_vu_stuff *a = (CONST struct nmg_vu_stuff *)aa;
	register CONST struct nmg_vu_stuff *b = (CONST struct nmg_vu_stuff *)bb;
d1482 1
a1482 1
CONST struct nmg_ray_state	*rs;
d1563 1
a1563 1
CONST struct bn_tol	*tol;
d1987 1
a1987 1
CONST struct bn_tol	*tol;
d2192 1
a2192 1
CONST char		*reason;
d3511 1
a3511 1
CONST struct bn_tol *tol;
d3612 1
a3612 1
CONST struct bn_tol	*tol;
d3794 1
a3794 1
static CONST struct state_transitions nmg_state_is_out[17] = {
d3814 1
a3814 1
static CONST struct state_transitions nmg_state_is_on_L[17] = {
d3834 1
a3834 1
static CONST struct state_transitions nmg_state_is_on_R[17] = {
d3854 1
a3854 1
static CONST struct state_transitions nmg_state_is_on_B[17] = {
d3874 1
a3874 1
static CONST struct state_transitions nmg_state_is_on_N[17] = {
d3894 1
a3894 1
static CONST struct state_transitions nmg_state_is_in[17] = {
d4029 1
a4029 1
	CONST struct state_transitions	*stp;
@


11.32
log
@fixed compilation warnings
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.31 2000/08/21 02:02:32 butler Exp $ (ARL)";
d2884 2
a2885 1
		struct loopuse *lu1,*lu2;
d2888 2
a2889 1
		int orient1,orient2;
d2976 4
a2979 2
		if( (cuts=find_loop_to_cut( &index1, &index2, prior_start, prior_end,
			next_start, next_end, mid_pt, rs )) == (struct bu_ptbl *)NULL )
@


11.31
log
@Massive compilation warnings eliminated
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.30 2000/07/10 23:01:39 mike Exp $ (ARL)";
d2258 2
a2259 1
	struct vertexuse *vu1,*vu2;
d2686 1
a2686 1
	int other_is_in_best;
d4027 1
a4027 1
	struct vertexuse	*prev_vu;
@


11.30
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.29 1999/12/30 15:33:12 jra Exp $ (ARL)";
d43 1
d51 2
d197 5
d3739 1
a3739 1
	if( i = nmg_mesh_two_faces( fu1, fu2, tol ) )  {
d4479 1
@


11.29
log
@Eliminated some unused variables
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.28 1999/06/03 01:57:01 mike Exp $ (ARL)";
@


11.28
log
@
sed4 oops fixes
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.27 1999/06/03 01:39:14 mike Exp $ (ARL)";
a559 1
	int			ret2;
a2252 1
	struct vertexuse *prior_vu, *next_vu;
a2832 1
	struct loopuse *lu;
d2834 1
a2834 1
	struct edgeuse *new_eu1,*new_eu2;
a2880 1
		int count;
@


11.27
log
@
sed4
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.26 1999/05/11 19:08:22 mike Exp $ (ARL)";
d1602 1
a1602 1
		bn_vlblock_free(vbp);
@


11.26
log
@Reduced amount of stray debug printing,
to provide a better image of the released version.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fcut.c,v 11.25 1998/03/09 15:19:53 jra Exp $ (ARL)";
d1573 1
a1573 1
		struct rt_vlblock	*vbp;
d1583 1
a1583 1
		b = (long *)rt_calloc( m->maxindex, sizeof(long), "nmg_special_wedge_processing flag[]" );
d1601 2
a1602 2
		rt_free( (char *)b, "nmg_special_wedge_processing flag[]" );
		rt_vlblock_free(vbp);
d1738 1
a1738 1
	vs = (struct nmg_vu_stuff *)rt_malloc( sizeof(struct nmg_vu_stuff)*num,
d1740 1
a1740 1
	ls = (struct nmg_loop_stuff *)rt_malloc( sizeof(struct nmg_loop_stuff)*num,
d1923 2
a1924 2
	rt_free( (char *)vs, "nmg_vu_stuff");
	rt_free( (char *)ls, "nmg_loop_stuff");
d2298 1
a2298 1
						cuts = (struct bu_ptbl *)rt_malloc( sizeof( struct bu_ptbl ), "cuts" );
d2300 1
a2300 1
						lcut = (struct loop_cuts *)rt_malloc( sizeof( struct loop_cuts ), "lcut" );
d2341 1
a2341 1
							lcut = (struct loop_cuts *)rt_malloc( sizeof( struct loop_cuts ), "lcut" );
d3049 1
a3049 1
			rt_free( (char *)cuts, "cuts" );
d3518 1
a3518 1
	matching_lus = (struct loopuse **)rt_calloc( BU_PTBL_END( tbl ), 
@


11.25
log
@Added a check to prevent nmg_fcut_face() from trying to make a cut that is not within the face.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.24 1997/08/29 15:31:46 jra Exp $ (ARL)";
d1650 1
d1652 1
d1744 1
d1746 1
@


11.24
log
@Made intersection edges "real".
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.23 1997/07/11 14:57:51 jra Exp jra $ (ARL)";
d2947 9
@


11.23
log
@mod to find_loop_to_cut() to avoid making duplicate cuts.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.22 1996/12/19 14:04:07 jra Exp jra $ (ARL)";
d2998 1
d3001 3
d3051 3
d3092 3
d3136 3
d3176 3
@


11.22
log
@Solaris complains about passing (void *)NULL where it should be (void (*)())NULL.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.21 1996/09/27 08:27:30 mike Exp jra $ (ARL)";
d2472 65
@


11.21
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.20 1996/07/12 12:17:41 jra Exp mike $ (ARL)";
d2872 1
a2872 1
			(void *)NULL, (void *)NULL, (char *)NULL, 0, 1, rs->tol );
@


11.20
log
@Minor Mods for IRIX 6.2
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.19 1996/07/02 14:25:46 jra Exp jra $ (ARL)";
d184 1
a184 1
	CONST struct rt_tol	*tol;
d208 1
a208 1
struct nmg_ptbl *b;		/* table of vertexuses on intercept line */
d227 1
a227 1
			dist = rt_dist_line_point( pt, dir, vu[i]->v_p->vg_p->coord );
d229 1
a229 1
				rt_log("WARNING ptbl_vsort() vu=x%x point off line by %e %g*tol, tol=%e\n",
d239 1
a239 1
				rt_log("ERROR ptbl_vsort() vu=x%x point off line by %g > 100*dist_tol\n",
d267 1
a267 1
	rt_log("ptbl_vsort: forcing vu=x%x & vu=x%x mag equal\n", vu[i], vu[j]);
d284 1
a284 1
	rt_log("ptbl_vsort: vu duplication eliminated\n");
d334 1
a334 1
struct nmg_ptbl	*p;
d344 1
a344 1
	NMG_CK_PTBL(p);
d348 2
a349 2
	for( i=0; i < NMG_TBL_END(p); i++ )  {
		vu = (struct vertexuse *)NMG_TBL_GET(p, i);
d355 1
a355 1
			rt_log("ERROR: vu=x%x v=x%x up_fu=x%x != arg_fu=x%x\n",
d359 1
a359 1
		for( RT_LIST_FOR( tvu, vertexuse, &v->vu_hd ) )  {
d366 1
a366 1
			if( nmg_tbl(p, TBL_LOC, &tvu->l.magic ) >= 0 )  continue;
d368 1
a368 1
			rt_log("ERROR: vu=x%x v=x%x %s=x%x is on isect line, tvu=x%x %s=x%x isn't.\n",
d370 1
a370 1
				rt_identify_magic( *vu->up.magic_p ),
d373 1
a373 1
				rt_identify_magic( *tvu->up.magic_p ),
d380 1
a380 1
			(void)nmg_tbl( p, TBL_INS, &tvu->l.magic );
d385 1
a385 1
	if(ret)rt_log("nmg_ck_vu_ptbl() ret=%d\n", ret);
d438 1
a438 1
		else	ang = rt_pi;	/* 180 degrees */
d440 1
a440 1
			rt_log("nmg_vu_angle_measure:  NMG_E_ASSESSMENT_ON_FORW, ang=%g\n", ang);
d444 1
a444 1
		if( in )  ang = rt_pi;	/* 180 degrees */
d447 1
a447 1
			rt_log("nmg_vu_angle_measure:  NMG_E_ASSESSMENT_ON_REV, ang=%g\n", ang);
d459 2
a460 2
		prev_eu = in ? RT_LIST_PLAST_CIRC( edgeuse, prev_eu ) :
			RT_LIST_PNEXT_CIRC( edgeuse, prev_eu );
d463 1
a463 1
				rt_log("nmg_vu_angle_measure: prev eu is this eu, ang=0\n");
d473 1
a473 1
	ang = rt_angle_measure( vec, x_dir, y_dir );
d475 1
a475 1
		rt_log("nmg_vu_angle_measure:  measured angle=%e\n", ang*rt_radtodeg);
d487 1
a487 1
			ang = rt_twopi - RADIAN_TWEEK;
d489 1
a489 1
	} else if( ang == rt_pi )  {
d491 1
a491 1
			ang = rt_pi - RADIAN_TWEEK;
d493 1
a493 1
			ang = rt_pi + RADIAN_TWEEK;
d501 1
a501 1
	if( ang > rt_pi )  {
d503 2
a504 2
			rt_log("*** ERROR topology/geometry conflict, ang=%e, ass=%s\n",
				ang*rt_radtodeg,
d507 1
a507 1
	} else if( ang < rt_pi )  {
d509 2
a510 2
			rt_log("*** ERROR topology/geometry conflict, ang=%e, ass=%s\n",
				ang*rt_radtodeg,
d515 1
a515 1
		rt_log("  final ang=%g (%e), vec=(%g,%g,%g)\n", ang*rt_radtodeg, ang*rt_radtodeg, V3ARGS(vec) );
d565 1
a565 1
	RT_CK_TOL(rs->tol);
d570 1
a570 1
		othereu = RT_LIST_PNEXT_CIRC( edgeuse, othereu );
d572 1
a572 1
		othereu = RT_LIST_PLAST_CIRC( edgeuse, othereu );
d600 1
a600 1
			rt_log("eu ON ray: vu[%d]=x%x, other:vu[%d]=x%x\n",
d610 1
a610 1
			fareu = RT_LIST_PNEXT_CIRC( edgeuse, fareu );
d612 1
a612 1
			fareu = RT_LIST_PLAST_CIRC( edgeuse, fareu );
d618 1
a618 1
			rt_log("nmg_assess_eu() farv = x%x, on_index=%d\n", farv, nmg_is_v_on_rs_list(rs, farv) );
d627 1
a627 1
			rt_log("nmg_assess_eu() assessing farv\n");
d691 1
a691 1
				rt_log("In edge interval (%d,%d), ON vertexuse [%d] = x%x appears?\n",
d695 1
a695 1
					rt_log(" %d ", j);
d698 1
a698 1
				rt_log("nmg_assess_eu():  ON vertexuse in middle of edge?\n");
d722 1
a722 1
		rt_log("nmg_assess_eu(x%x, fw=%d, pos=%d) v=x%x otherv=x%x: %s\n",
d725 1
a725 1
		rt_log(" v(%g, %g, %g) other(%g, %g, %g)\n",
d727 1
a727 1
		rt_log(" rs->left(%g, %g, %g) heading(%g, %g, %g)\n",
d758 1
a758 1
	if( this_eu != vu->up.eu_p )  rt_log("nmg_assess_vu() eu mis-match? x%x x%x\n", this_eu, vu->up.eu_p);
d776 2
a777 2
		prev = RT_LIST_PLAST_CIRC( edgeuse, this_eu );
		next = RT_LIST_PNEXT_CIRC( edgeuse, this_eu );
d779 1
a779 1
			rt_log("nmg_assess_vu() %s, v=x%x, prev_v=x%x, next_v=x%x\n",
d783 1
a783 1
			rt_log("nmg_assess_vu() ON/ON edgeuse ends on different vertices.\n");
d789 3
a791 3
			rt_log("vu dist=%e, next dist=%e, tol=%e\n",
			rt_dist_line_point( rs->pt, rs->dir, this_eu->vu_p->v_p->vg_p->coord ),
			rt_dist_line_point( rs->pt, rs->dir, prev->vu_p->v_p->vg_p->coord ),
d796 1
a796 1
				rt_log("\tnmg_break_long_edges succeeded\n");
d802 1
a802 1
		rt_log("nmg_assess_vu() vu[%d]=x%x, v=x%x: %s\n",
d847 1
a847 1
	rt_log("nmg_pr_vu_stuff(x%x) vu=x%x, loop_index=%d, lsp=x%x\n",
d849 1
a849 1
	rt_log(" in_vu_angle=%g, out_vu_angle=%g, min_vu_dot=%g\n",
d851 1
a851 1
	rt_log(" lo_ang=%g, hi_ang=%g, seq=%d, wedge_class=%s\n",
d905 1
a905 1
				rt_log("nmg_wedge_class() 0-angle wedge\n");
d940 1
a940 1
		rt_log("nmg_wedge_class(%g,%g) = %s\n",
d1104 1
a1104 1
		rt_log(" a_in_cd=%d, b_in_cd=%d, c_in_ab=%d, d_in_ab=%d\n",
d1106 1
a1106 1
		rt_log("nmg_compare_2_wedges(%g,%g, %g,%g) = %d %s\n",
d1110 1
a1110 1
		rt_log("nmg_compare_2_wedges(%g,%g, %g,%g) ERROR!\n", a, b, c, d);
d1149 1
a1149 1
		rt_log("nmg_find_vu_in_wedge(start=%d,end=%d, lo=%g, hi=%g) START\n",
d1164 1
a1164 1
				rt_log("Skipping index %d\n", i);
d1171 1
a1171 1
				rt_log("Seeking wedge_class=%s, [%d] has wedge_class %s\n",
d1206 1
a1206 1
				rt_log("Initial candidate %d selected\n", i);
d1221 1
a1221 1
				rt_log("This candidate %d is closer\n", i);
d1230 1
a1230 1
				rt_log("Taking lower angle %d\n", i);
d1238 1
a1238 1
				rt_log("Continuing with search\n");
d1244 1
a1244 1
		rt_log("nmg_find_vu_in_wedge(start=%d,end=%d, lo=%g, hi=%g) END candidate=%d\n",
d1278 1
a1278 1
		rt_log("nmg_is_wedge_before_cross() class2=%s\n",
d1304 1
a1304 1
		rt_log("nmg_is_wedge_before_cross() class2=%s, ret=%d\n",
d1361 1
a1361 1
			rt_log("nmg_face_vu_compare(): two loops (single vertex) have same in_vu_angle%g?\n",
d1452 1
a1452 1
		rt_log("nmg_face_vu_compare(vu=x%x, vu=x%x) %s %s, %s\n",
d1498 1
a1498 1
		othereu = RT_LIST_PLAST_CIRC( edgeuse, this_eu );
d1519 1
a1519 1
		othereu = RT_LIST_PNEXT_CIRC( edgeuse, this_eu );
d1556 1
a1556 1
CONST struct rt_tol	*tol;
d1566 1
a1566 1
	RT_CK_TOL(tol);
d1576 1
a1576 1
		rt_log("nmg_special_wedge_processing(start=%d,end=%d, lo=%g, hi=%g, wclass=%s)\n",
d1588 1
a1588 1
			rt_log("\tvu[%d]=x%x, lu=x%x\n", i, vs[i].vu, lu);
d1600 1
a1600 1
		rt_log("wrote %s\n", buf);
d1640 1
a1640 1
		rt_log("+++nmg_special_wedge_processing() outer=%d, inner=%d, class2=%s\n", outer_wedge, inner_wedge, WEDGE2_TO_STRING(class2) );
d1652 1
a1652 1
				rt_log("nmg_special_wedge_processing:  inner and outer wedges from same loop, WEDGE2_IDENTICAL & 0deg spread, already in final form.\n");
d1658 1
a1658 1
			rt_log("nmg_special_wedge_processing:  inner and outer wedges from same loop, cutting loop\n");
d1672 1
a1672 1
		rt_log("wedge at vu[%d] is inside wedge at vu[%d]\n", inner_wedge, outer_wedge);
d1680 1
a1680 1
			rt_log("joining loops\n");
d1699 1
a1699 1
		rt_log("Inner wedge is simple, join inner and outer loops.\n");
d1731 1
a1731 1
		rt_log("nmg_face_coincident_vu_sort(, %d, %d) START\n", start, end);
d1752 1
a1752 1
		   rt_log("vu[%d]=x%x v=x%x assessment=%s\n",
d1772 1
a1772 1
			rs->ang_x_dir, rs->ang_y_dir, ass, 1 ) * rt_radtodeg;
d1774 1
a1774 1
			rs->ang_x_dir, rs->ang_y_dir, ass, 0 ) * rt_radtodeg;
d1783 1
a1783 1
		if(rt_g.NMG_debug&DEBUG_VU_SORT) rt_log("nmg_wedge_class = %d %s\n", vs[nvu].wedge_class, WEDGECLASS2STR(vs[nvu].wedge_class));
d1843 1
a1843 1
			eu = RT_LIST_PNEXT_CIRC(edgeuse,eu);
d1853 1
a1853 1
			rt_log("*** nmg_face_coincident_vu_sort(, %d, %d) restarting after 0--180 wedge\n", start, end);
d1859 1
a1859 1
			rt_log("*** nmg_face_coincident_vu_sort(, %d, %d) restarting after 180-360 wedge\n", start, end);
d1865 1
a1865 1
		rt_log("Loop table (before sort):\n");
d1867 1
a1867 1
			rt_log("  index=%d, lu=x%x, min_dot=%g, #vu=%d\n",
d1879 1
a1879 1
		rt_log("Vertexuse table (after sort):\n");
d1881 1
a1881 1
			rt_log("  x%x, l=%d, in/o=(%g, %g), lo/hi=(%g,%g), %s, sq=%d\n",
d1901 1
a1901 1
			rt_log("Reversed processing order, state=IN.\n");
d1914 1
a1914 1
			rt_log(" vu[%d]=x%x, v=x%x\n",
d1923 1
a1923 1
		rt_log("nmg_face_coincident_vu_sort(, %d, %d) END, ret=%d\n", start, end, start+nvu);
d1942 2
a1943 2
	lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
	while( RT_LIST_NOT_HEAD(lu, &fu->lu_hd) )  {
d1945 1
a1945 1
		lunext = RT_LIST_PNEXT(loopuse,lu);
d1970 1
a1970 1
struct nmg_ptbl	*b;		/* table of vertexuses in fu1 on intercept line */
d1976 1
a1976 1
CONST struct rt_tol	*tol;
d1980 2
a1981 2
	RT_CK_TOL(tol);
	NMG_CK_PTBL(b);
d2016 1
a2016 1
		rt_log("\tfu->orientation=%s\n", nmg_orientation(fu1->orientation) );
d2021 2
a2022 2
		rt_log( "\tvertexuses in fu that are on lintersect line:\n" );
		for( i=0 ; i<NMG_TBL_END( b ) ; i++ )
d2024 1
a2024 1
			vu = (struct vertexuse *)NMG_TBL_GET( b , i );
d2027 2
a2028 2
		rt_log( "\tLoopuse in fu (x%x):\n" , fu1 );
		for( RT_LIST_FOR( lu , loopuse , &fu1->lu_hd ) )
d2030 2
a2031 2
			rt_log( "\tLOOPUSE x%x:\n" , lu );
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
d2033 1
a2033 1
				vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d2038 1
a2038 1
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d2046 1
a2046 1
					eu_next = RT_LIST_PNEXT_CIRC( edgeuse , eu );
d2055 1
a2055 1
					rt_log( "\t\t\teu_dir = ( %g , %g , %g ), length = %g\n", V3ARGS( eu_dir ) , eu_len );
d2091 1
a2091 1
	RT_CK_TOL(rs->tol);
d2097 1
a2097 1
			rt_log("nmg_face_next_vu_interval() fu=x%x, single vertexuse at index %d\n", rs->fu1, cur);
d2122 1
a2122 1
		rt_log("nmg_face_next_vu_interval() fu=x%x vu's on list interval [%d] to [%d] equal\n", rs->fu1, cur, j-1 );
d2128 2
a2129 2
		rt_log("At k=%d, vertex changed from v=x%x!\n", k, v);
		rt_log("pt_equality=%d\n", rt_pt3_pt3_equal(v->vg_p->coord,
d2132 1
a2132 1
			rt_log("  %d vu=%8x v=%8x mag=%g\n", k,
d2153 1
a2153 1
		rt_log("nmg_face_next_vu_interval() vu[%d] set to x%x\n", j-1, rs->vu[j-1] );
d2191 1
a2191 1
		rt_log("nmg_edge_geom_isect_line(eu=x%x, %s)\n eu->g=x%x, rs->eg=x%x at START\n",
d2233 1
a2233 1
		rt_log("nmg_edge_geom_isect_line(eu=x%x) g=x%x, rs->eg=x%x at END\n",
d2238 1
a2238 1
static struct nmg_ptbl *
d2251 1
a2251 1
	struct nmg_ptbl *cuts=(struct nmg_ptbl *)NULL;
d2258 1
a2258 1
		rt_log( "find_loop_to_cut: prior_start=%d, prior_end=%d, next_start=%d, next_end=%d, rs=x%x\n",
d2270 2
a2271 2
			rt_log( "find_loop_to_cut: infinite loop\n" );
			rt_log( "prior_start = %d, prior_end = %d, next_start = %d next_nd = %d\n",
d2273 1
a2273 1
			rt_log( "mid_point = ( %f %f %f )\n", V3ARGS( mid_pt ) );
d2275 1
a2275 1
				rt_log( "\t%d x%x\n", i, rs->vu[i] );
d2294 2
a2295 2
						cuts = (struct nmg_ptbl *)rt_malloc( sizeof( struct nmg_ptbl ), "cuts" );
						nmg_tbl( cuts, TBL_INIT, (long *)NULL );
d2298 1
a2298 1
						nmg_tbl( cuts, TBL_INS, (long *)lcut );
d2325 1
a2325 1
						for( k=0 ; k<NMG_TBL_END( cuts ) ; k++ )
d2327 1
a2327 1
							lcut = (struct loop_cuts *)NMG_TBL_GET( cuts , k );
d2339 1
a2339 1
							nmg_tbl( cuts, TBL_INS, (long *)lcut );
d2349 1
a2349 1
		for( k=0 ; k<NMG_TBL_END( cuts ) ; k++ )
d2351 1
a2351 1
			lcut = (struct loop_cuts *)NMG_TBL_GET( cuts, k );
d2355 1
a2355 1
				rt_log( "\tfind_loop_to_cut: matching lu's = x%x\n", match_lu );
d2383 2
a2384 2
			rt_log( "\tfind_loop_to_cut returning 0\n" );
		return( (struct nmg_ptbl *)NULL );
d2387 1
a2387 1
	for( k=0 ; k<NMG_TBL_END( cuts ) ; k++ )
d2389 1
a2389 1
		lcut = (struct loop_cuts *)NMG_TBL_GET( cuts, k );
d2409 1
a2409 1
				rt_log( "\tfind_loop_to_cut: %d VU's from lu x%x\n", count, lu2 );
d2412 1
a2412 1
			vu_angle = (-rt_pi);
d2423 1
a2423 1
				rt_log( "\tx_dir=(%g %g %g), y_dir=(%g %g %g)\n",
d2438 1
a2438 1
					rt_log( "nmg_fcut_face: VU (x%x) is not from an EU\n", rs->vu[i] );
d2450 1
a2450 1
					rt_log( "\tangle for eu x%x (vu=x%x, #%d) is %g\n",
d2457 1
a2457 1
						rt_log( "\t\tabove is the new best VU\n" );
d2471 1
a2471 1
				rt_log( "\tfind_loop_to_cut: selecting VU2 x%x\n", vu2 );
d2491 1
a2491 1
				rt_log( "\tfind_loop_to_cut: %d VU's from lu x%x\n", count, lu1 );
d2494 1
a2494 1
			vu_angle = (-rt_pi);
d2505 1
a2505 1
				rt_log( "\tx_dir=(%g %g %g), y_dir=(%g %g %g)\n",
d2519 1
a2519 1
					rt_log( "nmg_fcut_face: VU (x%x) is not from an EU\n", rs->vu[i] );
d2531 1
a2531 1
					rt_log( "\tangle for eu x%x (vu=x%x, #%d) is %g\n",
d2538 1
a2538 1
						rt_log( "\t\tabove is the new best VU\n" );
d2553 1
a2553 1
				rt_log( "\tfind_loop_to_cut: selecting VU1 x%x\n", vu1 );
d2558 2
a2559 2
		rt_log( "\tfind_loop_to_cut: returning %d cuts (index1=%d, index2=%d)\n",
				NMG_TBL_END( cuts ), *index1, *index2 );
d2615 1
a2615 1
		rt_log( "find_best_vu: start=%d, end=%d, other_vp=x%x, rs=x%x\n",
d2624 1
a2624 1
			rt_log( "\tfind_best_vu returning %d\n", start );
d2635 1
a2635 1
	if( RT_LIST_FIRST_MAGIC( &best_lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
d2652 1
a2652 1
			rt_log( "find_best_vu: There is a loop to cut, lu=x%x\n", best_lu );
d2660 1
a2660 1
		rt_log( "\tfind_best_vu: first choice is index=%d, vu=x%x, lu=x%x, other_is_in_best=%d\n",
d2673 3
a2675 3
				rt_log( "lu x%x is %s\n", lu , nmg_orientation( lu->orientation ) );
				rt_log( "best_lu x%x is %s\n", best_lu , nmg_orientation( best_lu->orientation ) );
				rt_log( "lu x%x is %s w.r.t lu x%x\n",
d2689 1
a2689 1
						rt_log( "\tfind_best_vu: better choice (inside) - index=%d, vu=x%x, lu=x%x, other_is_in_best=%d\n",
d2703 1
a2703 1
					if( RT_LIST_FIRST_MAGIC( &best_lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
d2721 1
a2721 1
							rt_log( "find_best_vu: There is a loop to cut, lu=x%x\n",
d2729 1
a2729 1
						rt_log( "\tfind_best_vu: better choice (outside) - index=%d, vu=x%x, lu=x%x, other_is_in_best=%d\n",
d2745 1
a2745 1
				rt_log( "best_angle = %f, eu=x%x, eu_angle=%f\n",
d2771 1
a2771 1
	struct nmg_ptbl *cuts;
d2776 1
a2776 1
	RT_CK_TOL(rs->tol);
d2779 1
a2779 1
		rt_log("nmg_face_combine()\n");
d2792 2
a2793 2
		rt_log( "rs->fu1 = x%x\n", rs->fu1 );
		rt_log( "rs->fu2 = x%x\n", rs->fu2 );
d2795 1
a2795 1
		rt_log( "%d vertices on intersect line\n", rs->nvu );
d2797 1
a2797 1
		rt_log( "\tvu=x%x, v=x%x, lu=x%x\n", rs->vu[cur], rs->vu[cur]->v_p, nmg_find_lu_of_vu( rs->vu[cur] ) );
d2840 3
a2842 3
			rt_log( "rs->fu1 = x%x\n", rs->fu1 );
			rt_log( "rs->fu2 = x%x\n", rs->fu2 );
			rt_log( "prior_start=%d. prior_end=%d, next_start=%d, next_end=%d\n", 
d2844 1
a2844 1
			rt_log( "%d vertices on intersect line\n", rs->nvu );
d2846 1
a2846 1
			rt_log( "\tvu=x%x, v=x%x, lu=x%x\n", rs->vu[cur], rs->vu[cur]->v_p, nmg_find_lu_of_vu( rs->vu[cur] ) );
d2854 1
a2854 1
				rt_log( "Already an edge here\n" );
d2862 1
a2862 1
				rt_log( "Already an edge here\n" );
d2876 1
a2876 1
			rt_log( "vu1=x%x (%g %g %g ), vu2=x%x (%g %g %g)\n",
d2879 2
a2880 2
			rt_log( "\tmid_pt = (%g %g %g)\n", V3ARGS( mid_pt ) );
			rt_log( "class for mid point is %s\n", nmg_class_name(class) );
d2892 1
a2892 1
			next_start, next_end, mid_pt, rs )) == (struct nmg_ptbl *)NULL )
d2918 1
a2918 1
			for( cut_no=0 ; cut_no<NMG_TBL_END( cuts ) ; cut_no++ )
d2923 1
a2923 1
					rt_log( "\tcut loop (#%d of %d)\n", cut_no, NMG_TBL_END( cuts ) );
d2925 1
a2925 1
				lcut = (struct loop_cuts *)NMG_TBL_GET( cuts, cut_no );
d2932 1
a2932 1
				new_eu1 = RT_LIST_LAST( edgeuse, &new_lu->down_hd );
d2943 1
a2943 1
					rt_log( "\t\t new_eu = x%x\n", new_eu1 );
d2957 1
a2957 1
				eu_tmp = RT_LIST_PPREV_CIRC( edgeuse, &eu_tmp->l );
d2960 1
a2960 1
					rt_log( "nmg_fcut_face: eu (x%x) has wrong vertex (x%x) should be (x%x)\n", eu_tmp, eu_tmp->vu_p->v_p, vu2->v_p );
d2966 1
a2966 1
			nmg_tbl( cuts, TBL_FREE, (long *)NULL );
d2972 2
a2973 2
		if( RT_LIST_FIRST_MAGIC( &lu1->down_hd ) == NMG_VERTEXUSE_MAGIC &&
		    RT_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_VERTEXUSE_MAGIC )
d2988 1
a2988 1
				rt_log( "\tjoin 2 singvu loops\n" );
d3011 2
a3012 2
		if( RT_LIST_FIRST_MAGIC( &lu1->down_hd ) == NMG_VERTEXUSE_MAGIC &&
		    RT_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_EDGEUSE_MAGIC )
d3026 1
a3026 1
				rt_log( "\tjoin loops vu1 (x%x) is sing vu loop\n", vu1 );
d3041 1
a3041 1
			eu_tmp = RT_LIST_PPREV_CIRC( edgeuse, &eu_tmp->l );
d3044 1
a3044 1
				rt_log( "nmg_fcut_face: eu (x%x) has wrong vertex (x%x) should be (x%x)\n", eu_tmp, eu_tmp->vu_p->v_p, vu2->v_p );
d3052 2
a3053 2
		if( RT_LIST_FIRST_MAGIC( &lu1->down_hd ) == NMG_EDGEUSE_MAGIC &&
		    RT_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_VERTEXUSE_MAGIC )
d3067 1
a3067 1
				rt_log( "\tjoin loops vu2 (x%x) is sing vu loop\n", vu2 );
d3103 2
a3104 2
				rt_log( "\t join 2 loops\n" );
				rt_log( "\t\tvu2 (x%x) replaced with new_vu2 x%x\n", vu2, new_vu2 );
d3123 2
a3124 2
		rt_log( "ERROR in face cutter: something should have been cut!!\n" );
		rt_log( "vu1=x%x, vu2=x%x\n", vu1, vu2 );
d3163 2
a3164 2
	RT_CK_TOL(rs1->tol);
	RT_CK_TOL(rs2->tol);
d3167 1
a3167 1
		rt_log("nmg_face_combine()\n");
d3187 1
a3187 1
			rt_log("\nnmg_face_combineX() vu block, index1=%d, index2=%d\n", cur1, cur2);
d3191 1
a3191 1
				rt_log("\nnmg_face_combineX() doing index1 block (at end)\n");
d3199 1
a3199 1
				rt_log("\nnmg_face_combineX() doing index2 block (at end)\n");
d3213 1
a3213 1
				rt_log("cur1=%d, cur2=%d, v1=x%x, v2=x%x\n",
d3218 1
a3218 1
				rt_log("\nnmg_face_combineX() doing index1 block\n");
d3225 1
a3225 1
				rt_log("\nnmg_face_combineX() doing index2 block\n");
d3254 1
a3254 1
		rt_log("ERROR nmg_face_combine() ended in state '%s'/'%s'?\n",
d3257 1
a3257 1
		rt_log("cur1 = %d of %d, cur2 = %d of %d\n",
d3268 1
a3268 1
		rt_log("nmg_face_combine() bad ending state, pushing on\n");
d3281 1
a3281 1
struct nmg_ptbl	*b;
d3288 1
a3288 1
	NMG_CK_PTBL(b);
d3290 2
a3291 2
	for( i=0; i<NMG_TBL_END(b); i++ )  {
		vu = (struct vertexuse *)NMG_TBL_GET(b, i);
d3295 1
a3295 1
			NMG_TBL_GET(b, i) = (long *)0;
d3314 2
a3315 2
struct nmg_ptbl		*b;
struct nmg_ptbl		*ob;	/* other rs's vu list */
d3326 2
a3327 2
	NMG_CK_PTBL(b);
	NMG_CK_PTBL(ob);
d3330 1
a3330 1
	for( i=0; i<NMG_TBL_END(b); i++ )  {
d3332 1
a3332 1
		vu = (struct vertexuse *)NMG_TBL_GET(b, i);
d3340 1
a3340 1
				rt_log("nmg_onon_fix(): vu[%d] zapped (rev)\n", -zot);
d3343 1
a3343 1
			vu = (struct vertexuse *)NMG_TBL_GET(b, -zot);
d3355 1
a3355 1
				rt_log("nmg_onon_fix(): vu[%d] zapped (forw)\n", -zot);
d3366 1
a3366 1
		rt_log("nmg_onon_fix(): removing %d dead vertexuses\n", zapped);
d3369 1
a3369 1
		for( i=NMG_TBL_END( b ) ; i>=0 ; i-- )
d3375 1
a3375 1
			while( j>=0 && !NMG_TBL_GET( b, j ) ) --j;
d3378 1
a3378 1
			for( k=j+1; k<NMG_TBL_END(b)-removed ; k++ )
d3381 1
a3381 1
		nmg_tbl(b, TBL_RM, 0 );
d3383 1
a3383 1
		for( i=NMG_TBL_END( ob ) ; i>=0 ; i-- )
d3389 1
a3389 1
			while( j>=0 && !NMG_TBL_GET( ob, j ) ) --j;
d3392 1
a3392 1
			for( k=j+1 ; k<NMG_TBL_END(ob)-removed ; k++ )
d3395 1
a3395 1
		nmg_tbl(ob, TBL_RM, 0 );
d3407 2
a3408 2
struct nmg_ptbl *tbl;
CONST struct rt_tol *tol;
d3418 2
a3419 2
	RT_CK_TOL( tol );
	NMG_CK_PTBL( tbl );
d3421 1
a3421 1
	if( NMG_TBL_END( tbl ) < 3 )
d3424 1
a3424 1
	matching_lus = (struct loopuse **)rt_calloc( NMG_TBL_END( tbl ), 
d3428 1
a3428 1
	while( curr_vu < NMG_TBL_END( tbl )-1 )
d3432 1
a3432 1
		vu1 = (struct vertexuse *)NMG_TBL_GET( tbl, curr_vu );
d3435 1
a3435 1
		vu2 = (struct vertexuse *)NMG_TBL_GET( tbl, start1 + 1 );
d3445 1
a3445 1
			vu2 = (struct vertexuse *)NMG_TBL_GET( tbl, end1 + 1 );
d3454 2
a3455 2
		vu1 = (struct vertexuse *)NMG_TBL_GET( tbl, start2 );
		vu2 = (struct vertexuse *)NMG_TBL_GET( tbl, start2+1 );
d3459 1
a3459 1
			vu2 = (struct vertexuse *)NMG_TBL_GET( tbl, end2+1 );
d3465 1
a3465 1
			vu1 = (struct vertexuse *)NMG_TBL_GET( tbl, i );
d3473 1
a3473 1
				vu2 = (struct vertexuse *)NMG_TBL_GET( tbl, j );
d3500 2
a3501 2
struct nmg_ptbl	*b1;		/* table of vertexuses in fu1 on intercept line */
struct nmg_ptbl	*b2;		/* table of vertexuses in fu2 on intercept line */
d3509 1
a3509 1
CONST struct rt_tol	*tol;
d3517 1
a3517 1
		rt_log("\nnmg_face_cutjoin(fu1=x%x, fu2=x%x) eg=x%x START\n", fu1, fu2, eg);
d3520 1
a3520 1
	RT_CK_TOL(tol);
d3526 1
a3526 1
		rt_log("nmg_face_cutjoin(fu1=x%x, fu2=x%x): WARNING empty list %d %d\n",
d3546 1
a3546 1
		rt_log("Ray vu intersection list:\n");
d3548 1
a3548 1
			rt_log(" %d %e ", i, mag1[i] );
d3552 1
a3552 1
			rt_log(" %d %e ", i, mag2[i] );
d3570 1
a3570 1
			rt_log("Index %d mis-match, x%x != x%x\n",
d3585 1
a3585 1
		for( i=0 ; i<NMG_TBL_END( b1 ) ; i++ )
d3588 1
a3588 1
			vu = (struct vertexuse *)NMG_TBL_GET( b1 , i );
d3596 1
a3596 1
				rt_log ("nmg_face_cutjoin: Intersection list is screwy for face 1\n" );
d3602 1
a3602 1
		for( i=0 ; i<NMG_TBL_END( b2 ) ; i++ )
d3605 1
a3605 1
			vu = (struct vertexuse *)NMG_TBL_GET( b2 , i );
d3613 1
a3613 1
				rt_log ("nmg_face_cutjoin: Intersection list is screwy for face 2\n" );
d3618 1
a3618 1
			rt_log( "nmg_face_cutjoin: intersection list for face 1 doesn't contain vertexuses from face 1!!!\n" );
d3620 1
a3620 1
			rt_log( "nmg_face_cutjoin: intersection list for face 2 doesn't contain vertexuses from face 2!!!\n" );
d3643 1
a3643 1
			rt_log("nmg_face_cutjoin() meshed %d edges\n", i);
d3646 1
a3646 1
		rt_log("nmg_face_cutjoin(fu1=x%x, fu2=x%x) eg=x%x END\n", fu1, fu2, rs1.eg_p);
d3649 1
a3649 1
	if( eg && eg != rs1.eg_p )  rt_log("nmg_face_cutjoin() changed from eg=x%x to rs1.eg_p=x%x\n", eg, rs1.eg_p);
d3655 1
a3655 1
struct nmg_ptbl *vu_list;
d3659 1
a3659 1
struct rt_tol *tol;
d3668 2
a3669 2
	RT_CK_TOL( tol );
	NMG_CK_PTBL( vu_list );
d3828 1
a3828 1
struct rt_tol *tol;	/* tolerance for collinearity check */
d3845 1
a3845 1
	RT_CK_TOL( tol );
d3848 1
a3848 1
		rt_log( "nmg_insert_vu_if_on_edge: vu1=x%x, vu2=x%x\n" , vu1 , vu2 );
d3850 3
a3852 3
	eu_from = RT_LIST_PNEXT_CIRC( edgeuse , vu2->up.eu_p );
	eu_to = RT_LIST_PLAST_CIRC( edgeuse , vu2->up.eu_p );
	if( rt_3pts_collinear( vu1->v_p->vg_p->coord , vu2->v_p->vg_p->coord , eu_from->vu_p->v_p->vg_p->coord , tol ))
d3855 1
a3855 1
			rt_log( "\t points are collinear with vu2's eu ( %g , %g , %g ) -> ( %g , %g , %g )\n",
d3867 1
a3867 1
					rt_log( "\tvu1 is on vu2's eu, creating new edge (MAGSQ=%g, tol->dist_sq=%g)\n" , dist_to_loop_sq , tol->dist_sq );
d3874 1
a3874 1
	if( rt_3pts_collinear( vu1->v_p->vg_p->coord , vu2->v_p->vg_p->coord , eu_to->vu_p->v_p->vg_p->coord , tol ))
d3877 1
a3877 1
			rt_log( "\t points are collinear with eu that ends at vu2 ( %g , %g , %g ) -> ( %g , %g , %g )\n",
d3890 1
a3890 1
					rt_log( "\tvu1 is on eu that ends at vu2, creating new edge (MAGSQ=%g, tol->dist_sq=%g)\n" , dist_to_loop_sq , tol->dist_sq );
d3943 1
a3943 1
	RT_CK_TOL(rs->tol);
d3947 1
a3947 1
		rt_log("nmg_face_state_transition(vu x%x, pos=%d) START\n",
d3949 1
a3949 1
		rt_log("Plotting this loopuse, before action:\n");
d3989 1
a3989 1
		rt_log("assessment=%d, stp->assessment=%d, error\n", assessment, stp->assessment);
d4010 1
a4010 1
		rt_log("nmg_face_state_transition(vu x%x, pos=%d)\n\told=%s, assessed=%s, new=%s, action=%s\n",
d4022 1
a4022 1
		eu = RT_LIST_PLAST_CIRC( edgeuse, eu );
d4045 1
a4045 1
		struct rt_vls	str;
d4047 3
a4049 3
		rt_log("nmg_face_state_transition: got action=ERROR\n");
	    	rt_vls_init(&str);
		rt_vls_printf(&str,"nmg_face_state_transition(vu x%x, pos=%d)\n\told=%s, assessed=%s, new=%s, action=%s\n",
d4058 1
a4058 1
		rt_log("Loop with the offending vertex\n");
d4062 1
a4062 1
			rt_log("The whole face\n");
d4075 1
a4075 1
			rt_log("wrote error.pl\n");
d4081 1
a4081 1
	    	rt_bomb(rt_vls_addr(&str));
d4102 1
a4102 1
			rt_log("nmg_face_state_transition: VFY_EXT got orientation=%s\n",
d4113 1
a4113 1
		rt_log("nmg_face_state_transition: VFY_MULTI had only 1 vertex\n");
d4138 1
a4138 1
			rt_log("prev_vu->up is %s\n", rt_identify_magic(*prev_vu->up.magic_p) );
d4153 1
a4153 1
				eu = RT_LIST_PLAST_CIRC( edgeuse, eu );
d4156 1
a4156 1
				rt_log("LONE_V_ESPLIT:  rev e_assessment = %s\n", nmg_e_assessment_names[e_assessment]);
d4166 1
a4166 1
			rs->vu[pos] = RT_LIST_PNEXT_CIRC(edgeuse, eu)->vu_p;
d4175 1
a4175 1
			rt_log("After LONE_V_ESPLIT, the final loop:\n");
d4205 1
a4205 1
		first_new_eu = RT_LIST_PLAST_CIRC(edgeuse, rs->vu[pos]->up.eu_p);
d4214 1
a4214 1
			rt_log("After LONE_V_JAUNT, the final loop:\n");
d4248 1
a4248 1
				rt_log("Calling nmg_cut_loop(prev_vu=x%x, vu=x%x) is_crack=%d, old_eu=x%x\n", prev_vu, vu, is_crack, old_eu);
d4258 2
a4259 2
				first_new_eu = RT_LIST_PPREV_CIRC( edgeuse, &prev_vu->up.eu_p->l );
				second_new_eu = RT_LIST_PPREV_CIRC( edgeuse, &vu->up.eu_p->l );
d4282 1
a4282 1
				rt_log("After CUT, the final loop:\n");
d4296 1
a4296 1
			rt_log("nmg_face_state_transition() joining 2 loops, prev_vu=x%x, vu=x%x, old_eu=x%x\n",
d4312 1
a4312 1
			    		rt_log( "\tprev_vu is a vertex loop\n" );
d4319 1
a4319 1
			    		rt_log( "\tvu is a vertex loop\n" );
d4326 1
a4326 1
			    		rt_log( "\tprev_vu and vu are vertex loops\n" );
d4346 1
a4346 1
		first_new_eu = RT_LIST_PLAST_CIRC(edgeuse, rs->vu[pos]->up.eu_p);
d4357 1
a4357 1
			rt_log("After JOIN, the final loop:\n");
d4375 1
a4375 1
		rt_log("nmg_face_state_transition(vu x%x, pos=%d) END\n",
@


11.19
log
@Added capability for nmg_find_loop_to_cut to return a list of cuts to be made.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.18 1996/05/29 12:43:46 jra Exp jra $ (ARL)";
d1851 1
a1851 1
	if( nmg_special_wedge_processing( vs, 0, nvu, 0.0, 180.0, WEDGE_RIGHT, 0, rs->tol ) )  {
d1857 1
a1857 1
	if( nmg_special_wedge_processing( vs, 0, nvu, 360.0, 180.0, WEDGE_LEFT, 0, rs->tol ) ) {
@


11.18
log
@Fixed minor bug in find_best_vu().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.17 1996/05/16 21:58:46 jra Exp jra $ (ARL)";
d189 6
d2238 1
a2238 1
static int
d2251 2
d2254 1
a2254 1
	int i,j;
d2262 1
d2271 5
d2294 5
d2319 2
a2320 1
					if( class_lu == class_pt )
d2322 2
d2325 16
a2340 1
						done = 0;
d2347 1
a2347 1
	if( match_lu )
d2349 1
a2349 4
		if(rt_g.NMG_debug&DEBUG_FCUT)
			rt_log( "\tfind_loop_to_cut: matching lu's = x%x\n", match_lu );
		lu1 = match_lu;
		for( i=prior_start ; i < prior_end ; i++ )
d2351 7
a2357 1
			if( nmg_find_lu_of_vu( rs->vu[i] ) == lu1 )
d2359 7
a2365 3
				*index1 = i;
				vu1 = rs->vu[i];
				break;
d2367 2
a2368 5
		}
		lu2 = match_lu;
		for( i=next_start ; i < next_end ; i++ )
		{
			if( nmg_find_lu_of_vu( rs->vu[i] ) == lu2 )
d2370 7
a2376 4
				*index2 = i;
				vu2 = rs->vu[i];
				break;

d2384 1
a2384 9
		return( 0 );
	}

	/* Check if there is more than one VU from lu2 */
	count = 0;
	for( i=next_start ; i<next_end ; i++ )
	{
		if( nmg_find_lu_of_vu( rs->vu[i] ) == lu2 )
			count++;
d2387 1
a2387 1
	if( count > 1 )
d2389 3
a2391 4
		struct vertexuse *vu_best;
		fastf_t vu_angle;
		vect_t x_dir,y_dir;
		vect_t norm;
d2393 2
a2394 18
		if(rt_g.NMG_debug&DEBUG_FCUT)
			rt_log( "\tfind_loop_to_cut: %d VU's from lu x%x\n", count, lu2 );

		/* need to select correct VU */
		vu_angle = (-rt_pi);
		vu_best = (struct vertexuse *)NULL;

		VSUB2( x_dir, vu2->v_p->vg_p->coord, vu1->v_p->vg_p->coord );
		VUNITIZE( x_dir );
		NMG_GET_FU_NORMAL( norm, rs->fu1 );

		VCROSS( y_dir, norm, x_dir );
		VUNITIZE( y_dir );

		if(rt_g.NMG_debug&DEBUG_FCUT)
			rt_log( "\tx_dir=(%g %g %g), y_dir=(%g %g %g)\n",
				V3ARGS( x_dir ), V3ARGS( y_dir ) );

d2397 3
a2399 3
			struct edgeuse *eu;
			fastf_t angle;
			vect_t eu_dir;
d2401 6
d2408 2
a2409 2
			if( nmg_find_lu_of_vu( rs->vu[i] ) != lu2 )
				continue;
d2411 7
a2417 5
			if( *(rs->vu[i]->up.magic_p) != NMG_EDGEUSE_MAGIC )
			{
				rt_log( "nmg_fcut_face: VU (x%x) is not from an EU\n", rs->vu[i] );
				rt_bomb( "nmg_fcut_face: VU is not from an EU" );
			}
d2419 2
a2420 6
			/* calculate angle this EU will make with edgeuse
			 * that will be created by the cut/join
			 */
			eu = rs->vu[i]->up.eu_p;
			VSUB2( eu_dir, eu->eumate_p->vu_p->v_p->vg_p->coord, eu->vu_p->v_p->vg_p->coord );
			angle = atan2( VDOT( y_dir,eu_dir ), VDOT( x_dir, eu_dir ) );
d2423 2
a2424 2
				rt_log( "\tangle for eu x%x (vu=x%x, #%d) is %g\n",
					eu, rs->vu[i], i, angle );
d2426 1
a2426 2
			/* select max angle */
			if( angle > vu_angle )
d2428 3
a2430 7
				if(rt_g.NMG_debug&DEBUG_FCUT)
					rt_log( "\t\tabove is the new best VU\n" );
				vu_angle = angle;
				vu_best = rs->vu[i];
				*index2 = i;
			}
		}
a2431 2
		if( vu_best )
			vu2 = vu_best;
d2433 2
a2434 3
		if(rt_g.NMG_debug&DEBUG_FCUT)
			rt_log( "\tfind_loop_to_cut: selecting VU2 x%x\n", vu2 );
	}
d2436 5
a2440 7
	/* Check if there is more than one VU from lu1 */
	count = 0;
	for( i=prior_start ; i<prior_end ; i++ )
	{
		if( nmg_find_lu_of_vu( rs->vu[i] ) == lu1 )
			count++;
	}
d2442 6
a2447 3
	if( count > 1 )
	{
		struct vertexuse *vu_best;
d2449 3
a2451 3
		fastf_t vu_angle;
		vect_t x_dir,y_dir;
		vect_t norm;
d2453 10
a2462 2
		if(rt_g.NMG_debug&DEBUG_FCUT)
			rt_log( "\tfind_loop_to_cut: %d VU's from lu x%x\n", count, lu1 );
d2464 5
a2468 7
		/* need to select correct VU */
		vu_angle = (-rt_pi);
		vu_best = (struct vertexuse *)NULL;

		VSUB2( x_dir, vu1->v_p->vg_p->coord, vu2->v_p->vg_p->coord );
		VUNITIZE( x_dir );
		NMG_GET_FU_NORMAL( norm, rs->fu1 );
d2470 3
a2472 2
		VCROSS( y_dir, norm, x_dir );
		VUNITIZE( y_dir );
d2474 7
a2480 3
		if(rt_g.NMG_debug&DEBUG_FCUT)
			rt_log( "\tx_dir=(%g %g %g), y_dir=(%g %g %g)\n",
				V3ARGS( x_dir ), V3ARGS( y_dir ) );
d2482 1
a2482 1
		for( i=prior_start ; i<prior_end ; i++ )
d2484 5
a2488 3
			struct edgeuse *eu;
			fastf_t angle;
			vect_t eu_dir;
d2490 2
a2491 2
			if( nmg_find_lu_of_vu( rs->vu[i] ) != lu1 )
				continue;
d2493 7
a2499 5
			if( *(rs->vu[i]->up.magic_p) != NMG_EDGEUSE_MAGIC )
			{
				rt_log( "nmg_fcut_face: VU (x%x) is not from an EU\n", rs->vu[i] );
				rt_bomb( "nmg_fcut_face: VU is not from an EU" );
			}
d2501 2
a2502 6
			/* calculate angle this EU will make with edgeuse
			 * that will be created by the cut/join
			 */
			eu = rs->vu[i]->up.eu_p;
			VSUB2( eu_dir, eu->eumate_p->vu_p->v_p->vg_p->coord, eu->vu_p->v_p->vg_p->coord );
			angle = atan2( VDOT( y_dir,eu_dir ), VDOT( x_dir, eu_dir ) );
d2505 2
a2506 2
				rt_log( "\tangle for eu x%x (vu=x%x, #%d) is %g\n",
					eu, rs->vu[i], i, angle );
d2508 1
a2508 2
			/* select max angle */
			if( angle > vu_angle )
d2510 20
d2531 2
a2532 2
					rt_log( "\t\tabove is the new best VU\n" );
				vu_angle = angle;
d2534 10
a2543 2
				vu_best = rs->vu[i];
				*index1 = i;
a2544 1
		}
d2546 5
a2550 2
		if( vu_best )
			vu1 = vu_best;
d2552 3
a2554 2
		if(rt_g.NMG_debug&DEBUG_FCUT)
			rt_log( "\tfind_loop_to_cut: selecting VU1 x%x\n", vu1 );
d2558 2
a2559 2
		rt_log( "\tfind_loop_to_cut: returning 1 (index1=%d, index2=%d)\n",
				*index1, *index2 );
d2561 1
a2561 1
	return( 1 );
d2771 1
d2773 1
d2891 3
a2893 2
		if( find_loop_to_cut( &index1, &index2, prior_start, prior_end,
			next_start, next_end, mid_pt, rs ) )
d2904 1
d2916 1
a2916 1
		if( lu1 == lu2 )
d2918 12
a2929 2
			if(rt_g.NMG_debug&DEBUG_FCUT)
				rt_log( "\tcut loop\n" );
d2931 3
a2933 3
			new_lu = nmg_cut_loop( vu1, vu2 );
			new_eu1 = RT_LIST_LAST( edgeuse, &new_lu->down_hd );
			NMG_CK_EDGEUSE( new_eu1 );
d2935 2
a2936 2
			nmg_loop_g( lu1->l_p, rs->tol );
			nmg_loop_g( new_lu->l_p, rs->tol );
d2938 2
a2939 2
			nmg_lu_reorient( lu1 );
			nmg_lu_reorient( new_lu );
d2941 5
a2945 5
			if(rt_g.NMG_debug&DEBUG_FCUT)
			{
				rt_log( "\t\t new_eu = x%x\n", new_eu1 );
				nmg_pr_fu_briefly( rs->fu1, "" );
			}
d2947 2
a2948 2
			/* Fuse new edge to intersect line, old edge */
			nmg_edge_geom_isect_line( new_eu1, rs, "CUTJOIN, new edge after loop cut" );
d2950 1
a2950 1
			if( old_eu ) nmg_radial_join_eu( old_eu, new_eu1, rs->tol );
d2952 11
a2962 3
			/* A new VU has been added to vu2->v_p, add it to the rs->vu[]
			 * array by overwriting the last use of vu1->v_p
			 */
d2964 1
a2964 6
			eu_tmp = vu1->up.eu_p;
			eu_tmp = RT_LIST_PPREV_CIRC( edgeuse, &eu_tmp->l );
			if( eu_tmp->vu_p->v_p != vu2->v_p )
			{
				rt_log( "nmg_fcut_face: eu (x%x) has wrong vertex (x%x) should be (x%x)\n", eu_tmp, eu_tmp->vu_p->v_p, vu2->v_p );
				rt_bomb( "nmg_fcut_face: eu has wrong vertex" );
d2966 2
a2967 2

			rs->vu[prior_end-1] = eu_tmp->vu_p;
@


11.17
log
@removed tolerance args in calls to nmg_lu_reorient().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.16 1996/04/30 20:34:02 jra Exp jra $ (ARL)";
d2624 1
a2624 1
				if( class == NMG_CLASS_AinB || (class == NMG_CLASS_AonBshared && lu->orientation == OT_OPPOSITE) )
d2639 1
a2639 1
				if( class == NMG_CLASS_AoutB ||  (class == NMG_CLASS_AonBshared && lu->orientation == OT_OPPOSITE) )
@


11.16
log
@Mods to find_best_vu() to account for differing returns of nmg_classify_lu_lu()
and nmg_class_pt_lu_except().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.15 1996/04/26 15:03:23 jra Exp jra $ (ARL)";
d1658 2
a1659 2
		nmg_lu_reorient(inner_lu, tol);
		nmg_lu_reorient(new_lu, tol);
d2867 2
a2868 2
			nmg_lu_reorient( lu1, rs->tol );
			nmg_lu_reorient( new_lu, rs->tol );
d4204 2
a4205 2
			nmg_lu_reorient( lu, rs->tol );
			nmg_lu_reorient( prev_lu, rs->tol );
@


11.15
log
@Added code to find_loop_to_cut() to correctly find innermost loop.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.14 1996/04/22 12:11:14 jra Exp jra $ (ARL)";
d2590 2
a2591 1
		if( class == NMG_CLASS_AinB )
d2614 7
d2659 2
a2660 1
						if( class == NMG_CLASS_AinB )
a2671 1

d2686 4
@


11.14
log
@Added code to nmg_fcut_face() to correctly handle new VU after a join.
Also added "mid_pt" parameter to find_loop_to_cut() to help select correct loop to cut.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.13 1996/03/28 14:28:44 jra Exp jra $ (ARL)";
d2245 1
a2245 1
	int count;
d2258 6
d2282 4
d2287 1
d2290 9
a2299 1
					class_lu = nmg_classify_lu_lu( next_lu, match_lu, rs->tol );
a4294 1
                                                                                                                                      @


11.13
log
@Mods for new arg to nmg_class_pt_fu_except().
And rearranged some code for efficiency.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.12 1996/03/25 21:14:53 jra Exp jra $ (ARL)";
d2233 1
a2233 1
find_loop_to_cut( index1, index2, prior_start, prior_end, next_start, next_end, rs )
d2237 1
a2244 1
	int class;
d2260 1
d2263 1
d2269 2
d2276 6
a2281 2
					class = nmg_classify_lu_lu( next_lu, match_lu, rs->tol );
					if( class == NMG_CLASS_AinB )
d2748 11
d2801 2
a2802 1
		if( find_loop_to_cut( &index1, &index2, prior_start, prior_end, next_start, next_end, rs ) )
d2999 1
d3010 4
a3013 10
			/* vu2 has been killed, replace it in rs->vu[] */

			for( i=next_start ; i<next_end ; i++ )
			{
				if( rs->vu[i] == vu2 )
				{
					rs->vu[i] = new_vu2;
					break;
				}
			}
d3420 1
a3420 1
	if( b1->end <= 0 || b2->end <= 0 )  {
d3423 1
d3425 1
@


11.12
log
@Added find_loop_to_cut(), nmg_eu_angle(), and find_best_vu(). Incorporated them into face cutter.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.11 1996/03/18 00:12:24 jra Exp $ (ARL)";
d2740 16
a2755 3
		/* See if there is an edge joining the 2 vertices already */
		old_eu = nmg_findeu( vu1->v_p, vu2->v_p, (struct shell *)NULL,
			(struct edgeuse *)NULL, 0);
d2757 4
d2763 1
a2763 1
			(void *)NULL, (void *)NULL, (char *)NULL, 0, rs->tol );
d2777 4
a2780 16
		if( nmg_find_eu_in_face( vu1->v_p, vu2->v_p, rs->fu1,

			(struct edgeuse *)NULL, 0 ) )
		{
			if(rt_g.NMG_debug&DEBUG_FCUT)
				rt_log( "Already an edge here\n" );
			continue;
		}

		if( nmg_find_eu_in_face( vu1->v_p, vu2->v_p, rs->fu1->fumate_p,
			(struct edgeuse *)NULL, 0 ) )
		{
			if(rt_g.NMG_debug&DEBUG_FCUT)
				rt_log( "Already an edge here\n" );
			continue;
		}
@


11.11
log
@Removed some excessive logging.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.10 1996/03/05 21:29:07 jra Exp jra $ (ARL)";
d2215 1
d2232 431
d2674 2
d2702 1
d2706 3
a2708 2
	vu2 = rs->vu[0];
	for( cur=1 ; cur<rs->nvu ; cur++ )
d2710 1
d2715 13
d2729 1
a2729 2
		vu1 = vu2;
		vu2 = rs->vu[cur];
d2731 8
a2738 2
		if( vu1->v_p == vu2->v_p )
			continue;
d2761 1
d2777 8
a2784 4
		lu1 = nmg_find_lu_of_vu( vu1 );
		lu2 = nmg_find_lu_of_vu( vu2 );
		orient1 = lu1->orientation;
		orient2 = lu2->orientation;
d2786 2
a2787 4
		if(rt_g.NMG_debug&DEBUG_FCUT)
			rt_log( "lu1=x%x (mate=x%x), lu2=x%x (mate=x%x)\n", lu1, lu1->lumate_p, lu2, lu2->lumate_p );

		if( lu1 != lu2 )
d2789 8
a2796 71
			struct loopuse *match_lu=(struct loopuse *)NULL;
			struct loopuse *prior_lu,*next_lu;
			struct vertexuse *prior_vu, *next_vu;
			int prior_start,prior_end;
			int next_start,next_end;
			int i,j;
			int done=0;

			/* check if any conicident VU's can give us a loop to cut */
			prior_start = cur;
			prior_end = cur;
			next_start = cur;
			next_end = cur;

			while( prior_start > 0 && rs->vu[--prior_start]->v_p == vu1->v_p );
			if( rs->vu[prior_start]->v_p != vu1->v_p )
				prior_start++;

			while( next_end < rs->nvu-1 && rs->vu[++next_end]->v_p == vu2->v_p );
			if( rs->vu[next_end]->v_p == vu2->v_p )
				next_end++;

			match_lu = (struct loopuse *)NULL;
			while( !done )
			{
				done = 1;
				for( i=prior_start ; i < prior_end ; i++ )
				{
					prior_lu = nmg_find_lu_of_vu( rs->vu[i] );
					for( j=next_start ; j < next_end ; j++ )
					{
						next_lu = nmg_find_lu_of_vu( rs->vu[j] );
						if( prior_lu == next_lu )
						{
							if( !match_lu )
							{
								match_lu = next_lu;
								continue;
							}
							class = nmg_classify_lu_lu( next_lu, match_lu, rs->tol );
							if( class == NMG_CLASS_AinB )
							{
								match_lu = next_lu;
								done = 0;
							}
						}
					}
				}
			}

			if( match_lu )
			{
				lu1 = match_lu;
				for( i=prior_start ; i < prior_end ; i++ )
				{
					if( nmg_find_lu_of_vu( rs->vu[i] ) == lu1 )
					{
						vu1 = rs->vu[i];
						break;
					}
				}
				lu2 = match_lu;
				for( i=next_start ; i < next_end ; i++ )
				{
					if( nmg_find_lu_of_vu( rs->vu[i] ) == lu2 )
					{
						vu2 = rs->vu[i];
						break;
					}
				}
			}
d2815 1
d2817 2
d2825 14
d2844 1
d2846 1
a2846 2
			if(rt_g.NMG_debug&DEBUG_FCUT)
				rt_log( "\tjoin 2 singvu loops\n" );
d2848 2
a2849 2
			vu2 = nmg_join_2singvu_loops( vu1, vu2 );
			new_eu1 = vu2->up.eu_p;
d2855 6
d2867 11
d2884 1
a2884 2
			if(rt_g.NMG_debug&DEBUG_FCUT)
				rt_log( "\tjoin loops vu1 (x%x) is sing vu loop\n", vu1 );
d2886 2
a2887 2
			vu1 = nmg_join_singvu_loop( vu2, vu1 );
			new_eu1 = vu1->up.eu_p;
d2893 6
d2902 1
d2906 13
d2925 1
a2925 2
			if(rt_g.NMG_debug&DEBUG_FCUT)
				rt_log( "\tjoin loops vu2 (x%x) is sing vu loop\n", vu2 );
d2927 2
a2928 2
			vu2 = nmg_join_singvu_loop( vu1, vu2 );
			new_eu1 = vu2->up.eu_p;
d2934 6
d2947 11
d2963 1
a2963 2
			if(rt_g.NMG_debug&DEBUG_FCUT)
				rt_log( "\t join 2 loops\n" );
d2965 2
a2966 2
			vu2 = nmg_join_2loops( vu1, vu2 );
			new_eu1 = vu2->up.eu_p;
d2970 7
d2983 11
@


11.10
log
@Numerous Mods to get NMG Booleans working a bit better.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.9 1995/09/06 13:08:36 jra Exp $ (ARL)";
a2352 8
if( prior_end - prior_start > 1 ||  next_end - next_start > 1 )
{

	rt_log( "coincident VU's at %d:\n", cur );
	for( i=0 ; i<rs->nvu ; i++ )
		rt_log( "\tvu=x%x, v=x%x, lu=x%x\n", rs->vu[i], rs->vu[i]->v_p, nmg_find_lu_of_vu( rs->vu[i] ) );
}

a2382 1
rt_log( "\t\tx%x is the innermost matching lu\n", match_lu );
a2400 1
rt_log( "\t\tUse vu1=x%x, vu2=x%x\n", vu1, vu2 );
d2536 1
@


11.9
log
@Added distances along intersect ray corresponding to intersection vertices.
Also ifdef'd out code in nmg_assess_eu() that used headings for assessment
and switched to using intersection list position.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.8 1995/08/30 12:16:01 jra Exp jra $ (ARL)";
d1978 1
a1978 1
	if(eg)  NMG_CK_EDGE_G_LSEG(rs->eg_p);
d2151 397
d2799 1
d2801 1
d2807 80
d2888 1
d3026 1
a3026 1

d3029 1
d3031 1
d3033 3
a3053 15
/*
 *			N M G _ E D G E _ G E O M _ I S E C T _ L I N E
 *
 *  Force the geometry structure for a given edge to be that of
 *  the intersection line between the two faces.
 *
 *  Note that sometimes a vertex can appear to lie on more than one
 *  line.  It is important to refer to geometry here, to make sure
 *  that the edgeuse is not mistakenly fused to the wrong edge geometry.
 *
 *  XXX This has the byproduct that not all edgeuses "on" the line
 *  XXX of intersection will share rs->eg_p.
 *
 *  See the comments in nmg_radial_join_eu() for the rationale.
 */
d3055 20
a3074 6
nmg_edge_geom_isect_line( eu, rs, reason )
struct edgeuse		*eu;
struct nmg_ray_state	*rs;
CONST char		*reason;
{
	register struct edge_g_lseg	*eg;
d3076 1
a3076 4
	NMG_CK_EDGEUSE(eu);
	NMG_CK_RAYSTATE(rs);
	if(eu->g.lseg_p) NMG_CK_EDGE_G_LSEG(eu->g.lseg_p);
	if(rs->eg_p) NMG_CK_EDGE_G_LSEG(rs->eg_p);
d3078 1
a3078 45
	if(rt_g.NMG_debug&DEBUG_FCUT)  {
		rt_log("nmg_edge_geom_isect_line(eu=x%x, %s)\n eu->g=x%x, rs->eg=x%x at START\n",
			eu, reason,
			eu->g.magic_p, rs->eg_p);
	}
	if( !eu->g.magic_p )  {
		/* This edgeuse has No edge geometry so far.
		 * It may be a new edge formed by a CUTJOIN operation.
		 */
		if( !rs->eg_p )  {
			nmg_edge_g( eu );
			eg = eu->g.lseg_p;
			NMG_CK_EDGE_G_LSEG(eg);
			VMOVE( eg->e_pt, rs->pt );
			VMOVE( eg->e_dir, rs->dir );
			rs->eg_p = eg;
		} else {
			NMG_CK_EDGE_G_LSEG(rs->eg_p);
			nmg_use_edge_g( eu, (long *)rs->eg_p );
		}
		goto out;
	}
	/* Edge has edge geometry */
	if( eu->g.lseg_p == rs->eg_p )  return;	/* nothing changes */
	if( !rs->eg_p )  {
		/* This is first edge_g found on isect line, remember it */
		eg = eu->g.lseg_p;
		NMG_CK_EDGE_G_LSEG(eg);
		rs->eg_p = eg;
		goto out;
	}
	/*
	 * Edge has an edge geometry struct, different from that of isect line.
	 * Force all uses of this edge geom to take on isect line's geometry.
	 * Everywhere eu->g.lseg_p is seen, replace with rs->eg_p.
	 *
	 *  XXX This is DUBIOUS, as the angle might be very different.
	 */
	nmg_jeg( rs->eg_p, eu->g.lseg_p );
out:
	NMG_CK_EDGE_G_LSEG(rs->eg_p);
	if(rt_g.NMG_debug&DEBUG_FCUT)  {
		rt_log("nmg_edge_geom_isect_line(eu=x%x) g=x%x, rs->eg=x%x at END\n",
			eu, eu->g.magic_p, rs->eg_p);
	}
@


11.8
log
@Added check in nmg_face_state_transition() to avoid doing an NMG_CK_EDGE_G_LSEG() on a NULL pointer.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.7 1995/06/20 02:38:28 mike Exp jra $ (ARL)";
d245 5
a249 2
		VSUB2(vect, vu[i]->v_p->vg_p->coord, pt);
		mag[i] = VDOT( vect, dir );
d626 1
d641 9
d658 1
a658 1
				ret2 = NMG_E_ASSESSMENT_ON_FORW;
d660 1
a660 1
				ret2 = NMG_E_ASSESSMENT_ON_REV;
d666 1
a666 1
				ret2 = NMG_E_ASSESSMENT_ON_REV;
d668 1
a668 1
				ret2 = NMG_E_ASSESSMENT_ON_FORW;
d672 1
a672 6
		if( ret != ret2 )  {
			rt_log("ret=%s, ret2=%s?\n",
				nmg_e_assessment_names[ret],
				nmg_e_assessment_names[ret2]);
			rt_bomb("nmg_assess_eu() assessment inconsistency\n");
		}
d2286 1
a2286 1
nmg_unlist_v(b, v)
d2288 1
d2299 5
a2303 1
		if( vu->v_p == v )  NMG_TBL_GET(b, i) = (long *)0;
d2318 1
a2318 1
nmg_onon_fix( rs, b, ob )
d2322 2
d2353 2
a2354 2
			nmg_unlist_v(b, v);
			nmg_unlist_v(ob, v);
d2367 2
d2373 14
d2388 13
d2422 1
a2422 1
nmg_face_cutjoin(b1, b2, fu1, fu2, pt, dir, eg, tol)
d2425 2
a2433 2
	fastf_t		*mag1;
	fastf_t		*mag2;
a2454 5
	mag1 = (fastf_t *)rt_calloc(b1->end+1, sizeof(fastf_t),
		"vector magnitudes along ray, for sort");
	mag2 = (fastf_t *)rt_calloc(b2->end+1, sizeof(fastf_t),
		"vector magnitudes along ray, for sort");

d2548 1
a2548 1
	if( nmg_onon_fix( &rs1, b1, b2 ) || nmg_onon_fix( &rs2, b2, b1 ) )  goto top;
a2550 3

	rt_free((char *)mag1, "vector magnitudes");
	rt_free((char *)mag2, "vector magnitudes");
@


11.7
log
@Added some debugging
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_fcut.c,v 11.6 1995/06/17 03:09:29 mike Exp mike $ (ARL)";
d2953 2
a2954 1
			NMG_CK_EDGE_G_LSEG(rs->eg_p);
d2962 2
a2963 1
			NMG_CK_EDGE_G_LSEG(rs->eg_p);
@


11.6
log
@Made 0-angle wedge print conditional.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.5 1995/05/11 18:52:15 jra Exp mike $ (ARL)";
d1970 1
d2078 1
d2167 3
d2192 2
d2200 2
d2218 2
d2225 2
d2229 2
d2241 3
d2248 2
d2558 2
d2578 1
d2601 1
d2872 1
d2953 1
d2961 1
d3304 1
@


11.5
log
@Added calls to nmg_loop_g() to nmg_special_wedge_processing() after calls to nmg_join_2loops().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.4 1995/03/05 21:24:06 mike Exp jra $ (ARL)";
d887 2
a888 2
			 * This is not WEDGE_ON, and it's not WEDGE_CROSS.
			 * Call it WEDGE_LEFT.
d890 2
a891 1
rt_log("nmg_wedge_class() 0-angle wedge\n");
@


11.4
log
@Added some debugging.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.3 95/02/10 16:24:25 jra Exp Locker: mike $ (ARL)";
d1668 1
d1688 1
@


11.3
log
@Moved a call to nmg_edge_geom_isect_line() up one line to get it before
a call to nmg_radial_join_eu(). mg_radial_join_eu() was getting eu with null geometry.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.2 1995/02/07 03:56:55 mike Exp jra $ (ARL)";
d359 7
a365 2
			rt_log("ERROR: vu=x%x v=x%x is on isect line, tvu=x%x eu=x%x isn't.\n",
				vu, v, tvu, tvu->up.magic_p );
d367 2
d825 1
d827 16
d883 1
a883 1
		/* A is on the ray */
d885 6
d1348 2
d1362 2
d1386 2
d1408 2
d1430 2
@


11.2
log
@Changed calling sequence to nmg_edge_geom_isect_line() to include
a reason string.
Enhanced comments.
Didn't fix the essential problem with this routine yet, though.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 11.1 95/01/04 09:57:30 mike Rel4_4 Locker: mike $ (ARL)";
d3205 1
a3206 1
			nmg_edge_geom_isect_line( first_new_eu, rs, "CUTJOIN new edge" );
@


11.1
log
@Release_4.4
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.138 94/12/27 15:55:48 mike Exp $ (ARL)";
d2476 8
d2486 1
a2486 1
nmg_edge_geom_isect_line( eu, rs )
d2489 1
d2497 3
a2499 2
		rt_log("nmg_edge_geom_isect_line(eu=x%x) g=x%x, rs->eg=x%x at start\n",
			eu, eu->g.magic_p, rs->eg_p);
d2502 3
a2504 1
		/* This edgeuse has No edge geometry so far.  How??? */
d2520 1
a2520 1
		/* This is first edge_g on line, remember it */
d2530 2
d2536 1
a2536 1
		rt_log("nmg_edge_geom_isect_line(eu=x%x) g=x%x, rs->eg=x%x at end\n",
d2885 1
a2885 3
			if(rt_g.NMG_debug&DEBUG_FCUT)
				rt_log("force prev eu to ray\n");
			nmg_edge_geom_isect_line( eu, rs );
d2892 1
a2892 3
			if(rt_g.NMG_debug&DEBUG_FCUT)
				rt_log("force next eu to ray\n");
			nmg_edge_geom_isect_line( eu, rs );
d3025 1
a3025 1
			nmg_edge_geom_isect_line( eu, rs );
d3062 1
a3062 1
		nmg_edge_geom_isect_line( first_new_eu, rs );
d3127 1
a3127 1
				nmg_edge_geom_isect_line( first_new_eu, rs );
d3206 1
a3206 1
			nmg_edge_geom_isect_line( first_new_eu, rs );
@


10.138
log
@Added if(rt_g.NMG_debug&DEBUG_FCUT) checks around some
stray rt_log() prints
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.137 94/11/04 06:56:55 mike Exp Locker: mike $ (ARL)";
@


10.137
log
@Irix 6
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.136 94/09/16 20:45:24 mike Exp Locker: mike $ (ARL)";
d601 2
a602 1
rt_log("nmg_assess_eu() farv = x%x, on_index=%d\n", farv, nmg_is_v_on_rs_list(rs, farv) );
d610 2
a611 1
rt_log("nmg_assess_eu() assessing farv\n");
d766 6
a771 5
/* See how far off the line they are */
rt_log("vu dist=%e, next dist=%e, tol=%e\n",
rt_dist_line_point( rs->pt, rs->dir, this_eu->vu_p->v_p->vg_p->coord ),
rt_dist_line_point( rs->pt, rs->dir, prev->vu_p->v_p->vg_p->coord ),
rs->tol->dist );
d2804 2
a2805 2
nmg_fu_touchingloops(rs->fu1);
nmg_fu_touchingloops(rs->fu2);
d2871 2
a2872 1
rt_log("force prev eu to ray\n");
d2880 2
a2881 1
rt_log("force next eu to ray\n");
@


10.136
log
@nmg_move_eg() became nmg_jeg().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.135 94/09/16 20:20:53 mike Exp Locker: mike $ (ARL)";
a2709 2
				struct edgeuse *new_eu;

d2712 1
a2712 1
				new_eu = nmg_ebreaker( vu1->v_p , vu2->up.eu_p, tol );
a2731 1
				struct edgeuse *new_eu;
d2735 1
a2735 1
				new_eu = nmg_ebreaker( vu1->v_p , eu_to, tol );
d3214 1
a3214 1
out:
@


10.135
log
@Moved stuff to raytrace.h
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.134 94/09/10 04:36:38 mike Exp Locker: mike $ (ARL)";
d2516 1
a2516 1
	nmg_move_eg( eu->g.lseg_p, rs->eg_p );
@


10.134
log
@Converted NMG data structures to have edge_g pointer in edgeuse, not edge.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.133 94/09/03 03:01:13 mike Exp $ (ARL)";
a48 4

/* XXX move to raytrace.h */
RT_EXTERN(struct edgeuse	*nmg_ebreaker, (struct vertex *v,
				struct edgeuse *eu, CONST struct rt_tol *tol));
@


10.133
log
@Snapshot of non-working intermediate stage in edge_g evolution.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.132 94/08/09 19:37:30 mike Exp Locker: mike $ (ARL)";
d603 1
a603 1
		if( fareu->e_p->eg_p != eu->e_p->eg_p )  goto really_on;
d2474 1
a2474 1
 *  Force the edge geometry structure for a given edge to be that of
d2479 2
a2480 2
nmg_edge_geom_isect_line( e, rs )
struct edge		*e;
d2485 1
a2485 1
	NMG_CK_EDGE(e);
d2489 2
a2490 2
		rt_log("nmg_edge_geom_isect_line(e=x%x) eg=x%x, rs->eg=x%x at start\n",
			e, e->eg_p, rs->eg_p);
d2492 2
a2493 2
	if( !e->eg_p )  {
		/* No edge geometry so far */
d2495 2
a2496 2
			nmg_edge_g( e );
			eg = e->eg_p;
d2502 1
a2502 1
			nmg_use_edge_g( e, rs->eg_p );
d2507 1
a2507 1
	if( e->eg_p == rs->eg_p )  return;	/* nothing changes */
d2509 2
a2510 2
		/* Smash edge geom with isect line geom, and remember it */
		eg = e->eg_p;
a2511 2
		VMOVE( eg->e_pt, rs->pt );
		VMOVE( eg->e_dir, rs->dir );
d2518 1
a2518 1
	 * Everywhere e->eg_p is seen, replace with rs->eg_p.
d2520 1
a2520 6
	nmg_move_eg( e->eg_p, rs->eg_p, rs->sA );
#if 0
	/* XXX Old routine will break association with eg in other shells!! */
	/* Only need one call to do whole model, with new routine */
	nmg_move_eg( e->eg_p, rs->eg_p, rs->sB );
#endif
d2523 2
a2524 2
		rt_log("nmg_edge_geom_isect_line(e=x%x) eg=x%x, rs->eg=x%x at end\n",
			e, e->eg_p, rs->eg_p);
d2874 1
a2874 1
		if( !rs->eg_p || eu->e_p->eg_p != rs->eg_p )  {
d2876 1
a2876 1
			nmg_edge_geom_isect_line( eu->e_p, rs );
d2882 1
a2882 1
		if( !rs->eg_p || eu->e_p->eg_p != rs->eg_p )  {
d2884 1
a2884 1
			nmg_edge_geom_isect_line( eu->e_p, rs );
d3017 1
a3017 1
			nmg_edge_geom_isect_line( eu->e_p, rs );
d3054 1
a3054 1
		nmg_edge_geom_isect_line( first_new_eu->e_p, rs );
d3119 1
a3119 1
				nmg_edge_geom_isect_line( first_new_eu->e_p, rs );
d3198 1
a3198 1
			nmg_edge_geom_isect_line( first_new_eu->e_p, rs );
@


10.132
log
@Added GDurf's new "conf.h"
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.131 94/07/07 14:04:37 mike Exp Locker: mike $ (ARL)";
d178 1
a178 1
	struct edge_g		*eg_p;		/* Edge geom of the ray */
d1919 1
a1919 1
struct edge_g		*eg;	/* may be null.  Geom of isect line. */
d2315 1
a2315 1
struct edge_g *
d2323 1
a2323 1
struct edge_g		*eg;	/* may be null.  geometry of isect line */
d2466 1
a2466 1
	if( eg && !rs1.eg_p )  rt_bomb("nmg_face_cutjoin() lost edge_g?\n");
d2483 1
a2483 1
	register struct edge_g	*eg;
d2497 1
a2497 1
			NMG_CK_EDGE_G(eg);
d2511 1
a2511 1
		NMG_CK_EDGE_G(eg);
d2875 1
a2875 1
	 *  to use the edge_g structure of the intersection line (ray).
@


10.131
log
@Eliminated unglued edge problem in NMG_ACTION_CUTJOIN.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.130 94/07/06 21:27:20 mike Exp Locker: mike $ (ARL)";
d41 1
@


10.130
log
@More fixes for "unglued edges".
Some unfinished business.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.129 94/07/06 21:07:59 mike Exp Locker: mike $ (ARL)";
d3103 5
a3107 1
			prev_lu = nmg_cut_loop( prev_vu, vu );
d3109 19
a3127 8
			/* New edge has been created between 2 verts, fuse */
#if 0
			first_new_eu = RT_LIST_PREV( edgeuse, &prev_lu->down_hd );
			NMG_CK_EDGEUSE(first_new_eu);
/* XXX Need to pick proper value for first_new_eu! */
			nmg_edge_geom_isect_line( first_new_eu->e_p, rs );
			if( old_eu )  nmg_radial_join_eu( old_eu, first_new_eu, rs->tol );
#endif
@


10.129
log
@"unglued edge"
problem is happening in nmg_fcut.c, on NMG_ACTION_CUTJOIN, when
connecting a lone vertex with an existing loop.  The routine
nmg_join_singvu_loop() joins the lone vertex to the existing loop with a
new edge, without bothering to search to see if there is an existing
edge. Nor should it.  I've modified that block of code to call
nmg_findeu() first;  if an existing edge is found, after the new one is
made, the two are fused together in proper radial orientation.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.128 94/07/06 20:36:17 mike Exp Locker: mike $ (ARL)";
d3092 4
d3098 1
d3102 1
a3102 1
				rt_log("nmg_cut_loop(prev_vu=x%x, vu=x%x) is_crack=%d\n", prev_vu, vu, is_crack);
d3104 10
a3132 1
		 *  See if there is an edge joining the 2 vertices already.
a3133 3
		old_eu = nmg_findeu(prev_vu->v_p, vu->v_p, (struct shell *)NULL,
			(struct edgeuse *)NULL, 0);

@


10.128
log
@Fixed so that edges get fused to intersection line even when no
intersection line has been defined yet.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.127 94/07/06 19:13:47 mike Exp Locker: mike $ (ARL)";
a2779 1
	struct vertexuse	*vu;
d2784 1
a2785 1
	struct edgeuse		*eu;
d2787 1
d2789 4
a2792 3
	struct loopuse		*prev_lu;
	struct edgeuse	*first_new_eu;
	struct edgeuse	*second_new_eu;
d3118 1
d3120 2
a3121 3
		if(rt_g.NMG_debug&DEBUG_FCUT)
			rt_log("nmg_join_2loops(prev_vu=x%x, vu=x%x)\n",
			prev_vu, vu);
d3123 5
a3131 1
		    	struct edgeuse *new_eu;
d3133 4
d3143 1
a3143 9
/* XXX If there is an ON condition, this is bad. */
#if 0
			    	if( nmg_insert_vu_if_on_edge( prev_vu , vu , new_eu , rs->tol ) )
			    		rt_bomb("insert_vu_if_on_edge 1\n");
			    	if( nmg_insert_vu_if_on_edge( prev_vu , vu , new_eu , rs->tol ) )
			    		rs->vu[pos-1] = new_eu->vu_p;
			    	else
#endif
				    	rs->vu[pos-1] = nmg_join_singvu_loop( vu, prev_vu );
d3150 1
a3150 9
/* XXX If there is an ON condition, this is bad. */
#if 0
			    	if( nmg_insert_vu_if_on_edge( vu , prev_vu , new_eu , rs->tol ) )
			    		rt_bomb("insert_vu_if_on_edge 2\n");
			    	if( nmg_insert_vu_if_on_edge( vu , prev_vu , new_eu , rs->tol ) )
			    		rs->vu[pos] = new_eu->vu_p;
			    	else
#endif
				    	rs->vu[pos] = nmg_join_singvu_loop( prev_vu, vu );
d3177 1
a3177 1
			/*  We know edge geom is null, make it be the isect line */
@


10.127
log
@Added debugging to nmg_edge_geom_isect_line()
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.126 94/07/06 16:49:58 mike Exp Locker: mike $ (ARL)";
d2850 1
a2850 1
#if 1
a2858 1
/* XXX This is a bit too agressive.  r5 */
a2862 1
#endif
d2879 1
a2879 1
		if( rs->eg_p && eu->e_p->eg_p != rs->eg_p )  {
d2887 1
a2887 1
		if( rs->eg_p && eu->e_p->eg_p != rs->eg_p )  {
d3208 6
@


10.126
log
@Changed from nmg_ebreak() to nmg_ebreaker()
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.125 94/07/02 02:21:12 mike Exp Locker: mike $ (ARL)";
d2486 5
d2503 1
a2503 1
		return;
d2506 1
a2506 1
	if( e->eg_p == rs->eg_p )  return;
d2514 1
a2514 1
		return;
d2527 5
@


10.125
log
@Changed nmg_move_eg() to move all occurances of the 'old_eg' in the
entire model.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.124 94/07/02 00:32:30 mike Exp Locker: mike $ (ARL)";
d49 4
d2714 1
a2714 1
				new_eu = nmg_ebreak( vu1->v_p , vu2->up.eu_p );
d2738 1
a2738 1
				new_eu = nmg_ebreak( vu1->v_p , eu_to );
d3013 3
a3015 2
			/* Break edge */
			rs->vu[pos] = nmg_ebreak( vu->v_p, eu )->vu_p;
@


10.124
log
@Clarified debug messages
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.123 94/07/01 23:55:43 mike Exp Locker: mike $ (ARL)";
a2471 2
 *  XXX What about orientation?  Which way should direction vector point?
 *  XXX What about edgeuse orientation flags?
d2513 3
d2517 1
@


10.123
log
@Changed nmg_esplit to nmg_ebreak.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.122 94/07/01 16:12:06 mike Exp Locker: mike $ (ARL)";
d225 5
a229 3
				VPRINT("  vu", vu[i]->v_p->vg_p->coord);
				VPRINT("  pt", pt);
				VPRINT(" dir", dir);
d600 1
a600 1
rt_log("farv = x%x, on_index=%d\n", farv, nmg_is_v_on_rs_list(rs, farv) );
d608 1
a608 1
rt_log("assessing farv\n");
@


10.122
log
@Only print message if eg was non-null
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.121 94/07/01 16:07:54 mike Exp Locker: mike $ (ARL)";
d2289 1
d2706 1
a2706 1
				new_eu = nmg_esplit( vu1->v_p , vu2->up.eu_p );
d2730 1
a2730 1
				new_eu = nmg_esplit( vu1->v_p , eu_to );
@


10.121
log
@lint
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.120 94/06/30 22:34:32 mike Exp Locker: mike $ (ARL)";
d2459 1
a2459 1
	if( eg != rs1.eg_p )  rt_log("nmg_face_cutjoin() changed from eg=x%x to rs1.eg_p=x%x\n", eg, rs1.eg_p);
@


10.120
log
@Changed calling sequence to nmg_fcut.c to take and return the
edge_g structure representing the line of intersection
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.119 94/06/30 19:23:43 mike Exp Locker: mike $ (ARL)";
d2337 1
a2337 1
		return;
d2459 1
@


10.119
log
@Changed call to ptbl_vsort over to using tol->dist
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.118 94/04/25 03:10:18 mike Exp Locker: mike $ (ARL)";
d168 1
a168 1
	/* XXX could use a magic number */
d185 2
d545 1
d722 1
d1424 1
d1670 2
d1905 1
a1905 1
nmg_face_rs_init( rs, b, fu1, fu2, pt, dir, tol )
d1912 1
d1923 1
d1927 1
a1927 1
	rs->eg_p = (struct edge_g *)NULL;
d2026 1
d2108 2
d2138 1
d2144 1
d2160 2
d2165 1
d2176 1
d2180 1
d2247 1
d2307 2
a2308 2
void
nmg_face_cutjoin(b1, b2, fu1, fu2, pt, dir, tol)
d2315 1
d2326 1
a2326 1
		rt_log("\nnmg_face_cutjoin(fu1=x%x, fu2=x%x) START\n", fu1, fu2);
d2435 2
a2436 2
	nmg_face_rs_init( &rs1, b1, fu1, fu2, pt, dir, tol );
	nmg_face_rs_init( &rs2, b2, fu2, fu1, pt, dir, tol );
d2456 1
a2456 1
		rt_log("nmg_face_cutjoin(fu1=x%x, fu2=x%x) END\n", fu1, fu2);
d2458 2
d2479 1
d2776 1
@


10.118
log
@Added nmg_onon_fix(), and special handling in nmg_assess_eu().
This stuff is quite suspect.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.117 94/04/24 18:27:48 mike Exp Locker: mike $ (ARL)";
a2298 1
	fastf_t		dist_tol = 0.005;	/* XXX */
d2329 2
a2330 2
	ptbl_vsort(b1, fu1, fu2, pt, dir, mag1, dist_tol);
	ptbl_vsort(b2, fu2, fu1, pt, dir, mag2, dist_tol);
@


10.117
log
@Changed to using nmg_plot_lu_ray()
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1993 by the United States Army
d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.116 94/04/23 12:26:25 mike Exp Locker: mike $ (ARL)";
d72 1
d75 1
d100 1
a100 1
	"?17",
d134 1
a134 1
static CONST char *nmg_e_assessment_names[4] = {
d138 3
a140 1
	"ON_REV"
d510 1
d656 2
d661 9
a669 5
			rt_log("In edge interval (%d,%d), ON vertexuse [%d] = x%x appears?\n",
				start, end, i, rs->vu[i] );
			for( i=start-1; i<=end; i++ )  {
				rt_log(" %d ", i);
				nmg_pr_vu_briefly( rs->vu[i], (char *)0 );
d671 3
a673 1
			rt_bomb("nmg_assess_eu():  ON vertexuse in middle of edge?\n");
d727 2
d731 5
a735 1
	ass = NMG_V_COMB( prev_ass, next_ass );
d2187 89
d2349 3
d2354 1
a2367 1
#if 0
d2370 1
a2370 1
	{
a2413 3
#endif
	/* Check to make sure that intersector didn't miss anything */
	if( nmg_ck_vu_ptbl( b1, fu1 ) || nmg_ck_vu_ptbl( b2, fu2 ) )  goto top;
d2418 3
d2871 1
d2876 1
@


10.116
log
@Added code to detect ON vertexuse in middle of edge.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.115 94/04/23 07:54:57 mike Exp Locker: mike $ (ARL)";
d2651 2
a2652 1
		nmg_face_lu_plot(nmg_find_lu_of_vu(vu), rs->vu[0], rs->vu[rs->nvu-1] );
d2768 1
a2768 1
		nmg_face_lu_plot(lu, rs->vu[0], rs->vu[rs->nvu-1] );
d2876 1
a2876 1
			nmg_face_lu_plot(lu, rs->vu[0], rs->vu[rs->nvu-1] );
d2913 2
a2914 1
			nmg_face_lu_plot(nmg_find_lu_of_vu(rs->vu[pos]), rs->vu[0], rs->vu[rs->nvu-1] );
d2951 2
a2952 1
				nmg_face_lu_plot(nmg_find_lu_of_vu(rs->vu[pos]), rs->vu[0], rs->vu[rs->nvu-1] );
d3038 1
a3038 1
			nmg_face_lu_plot( lu, rs->vu[0], rs->vu[rs->nvu-1] );
@


10.115
log
@Made slightly less verbose upon encountering an error
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.114 94/04/22 10:48:46 mike Exp Locker: mike $ (ARL)";
d566 2
d569 1
d583 1
a583 1
			othereu = RT_LIST_PNEXT_CIRC( edgeuse, othereu );
d585 1
a585 1
			othereu = RT_LIST_PLAST_CIRC( edgeuse, othereu );
d587 3
a589 3
		if( othereu == eu )  goto really_on;	/* All eu's are ON! */
		if( othereu->e_p->eg_p != eu->e_p->eg_p )  goto really_on;
		farv = othereu->vu_p->v_p;
d628 2
d636 2
d644 17
@


10.114
log
@Initial attempt at breaking ties with ON/ON vertexuse assessments.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.113 94/04/19 16:19:44 mike Exp Locker: mike $ (ARL)";
d2732 8
a2742 5
		/* Print the faceuse for later analysis */
		rt_log("Loop with the offending vertex\n");
		nmg_pr_lu_briefly(lu, (char *)0);
		rt_log("The whole face\n");
		nmg_pr_fu(lu->up.fu_p, (char *)0);
@


10.113
log
@OT_BOOLPLACE clarificaiton
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.112 94/04/19 02:48:57 butler Exp Locker: mike $ (ARL)";
d495 17
d564 5
a568 4
	for( i=rs->nvu-1; i >= 0; i-- )  {
		if( rs->vu[i]->v_p != otherv )  continue;
		/* Edge is on the ray.  Which way does it go? */
/* XXX How to detect leaving the current vertex groups? */
d573 25
d599 1
d646 1
d719 2
d723 1
@


10.112
log
@added argument to nmg_vlblock_lu() call
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.111 94/04/18 07:07:37 mike Exp Locker: butler $ (ARL)";
d2707 7
a2713 6
		if( *(vu->up.magic_p) == NMG_LOOPUSE_MAGIC )  {
			lu = vu->up.lu_p;
			/* Drop this loop of a single vertex in sanitize() */
			if( lu->orientation == OT_UNSPEC );
				lu->orientation =
				  lu->lumate_p->orientation = OT_BOOLPLACE;
@


10.111
log
@Added double check in nmg_assess_eu()
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.110 94/04/17 19:34:16 mike Exp Locker: mike $ (ARL)";
d1432 1
a1432 1
			nmg_vlblock_lu(vbp, lu, b, 255, 0, 0, 0 );
@


10.110
log
@Added debugging.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.109 94/04/15 11:49:12 mike Exp Locker: mike $ (ARL)";
d517 1
d552 2
a553 2
			rt_log("ON: vu[%d]=x%x otherv=x%x, i=%d\n",
				pos, rs->vu[pos], otherv, i );
d570 24
d661 1
a661 1
			rt_log("nmg_assess_vu() %s, prev_v=x%x, next_v=x%x\n",
d663 1
d669 1
@


10.109
log
@Added nmg_ck_vu_ptbl(), to find vertexuses missing from intersection line.
It works!
Temporary hack:  If missing ones are found, add them in.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.108 94/04/15 08:45:00 mike Exp Locker: mike $ (ARL)";
d350 2
a351 2
			rt_log("ERROR: vu=x%x v=x%x is on isect line, tvu=x%x isn't.\n",
				vu, v, tvu );
@


10.108
log
@Fixed problem with special wedge processing, when 2 wedges were WEDGE2_IDENTICAL,
with a 0 degree spread, where it would go into an infinite loop,
first cutting then joining them back together.
They should stay joined, in this case.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.107 94/04/14 07:29:01 mike Exp Locker: mike $ (ARL)";
d196 2
a197 2
struct faceuse	*fu1;
struct faceuse	*fu2;
d305 60
d1466 1
d2113 1
d2205 3
@


10.107
log
@Inifinite loop detection.
Added some debugging
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d1295 3
d1347 5
d1379 1
d1396 1
a1396 1
		rt_log("nmg_special_wedge_processing() outer=%d, inner=%d, class2=%s\n", outer_wedge, inner_wedge, WEDGE2_TO_STRING(class2) );
d1403 3
a1405 2
#if 0
		if( class2 == WEDGE2_IDENTICAL )  {
d1407 4
a1410 2
				rt_log("nmg_special_wedge_processing() inner and outer wedges from same loop, wedges identical, nothing to do\n");
			return 0;
a1411 1
#endif
d1425 1
a1445 1
#if 1
a1457 6
#else
	/* This is adequate for Test16.r to work, but is a hack. */
	if(rt_g.NMG_debug&DEBUG_VU_SORT)
		rt_log("No inner wedges needed cutting, nothing further to do.\n");
	return 0;
#endif
@


10.106
log
@Changed to using nmg_find_eu_of_vu().
@
text
@d25 2
a26 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d28 5
d34 2
a35 2
 *	This software is Copyright (C) 1992 by the United States Army.
 *	All rights reserved.
d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.105 94/03/11 20:51:08 mike Exp Locker: mike $ (BRL)";
d1312 3
a1314 2
	int	outer_wedge;
	int	inner_wedge;
d1332 1
d1339 4
a1342 2
			nmg_vlblock_lu(vbp, nmg_find_lu_of_vu(vs[i].vu), b,
				255, 0, 0, 0 );
d1384 5
d1394 7
d1402 1
a1402 1
			rt_log("special_wedge:  inner and outer wedges from same loop, cutting loop\n");
d1476 1
d1478 3
d1488 2
a1489 3
	if(rt_g.NMG_debug&DEBUG_VU_SORT)
		rt_log("nmg_face_coincident_vu_sort(, %d, %d)\n", start, end);

d1597 3
a1599 1
	if( nmg_special_wedge_processing( vs, 0, nvu, 0.0, 180.0, WEDGE_RIGHT, 0, rs->tol ) )
d1601 1
d1603 3
a1605 1
	if( nmg_special_wedge_processing( vs, 0, nvu, 360.0, 180.0, WEDGE_LEFT, 0, rs->tol ) )
d1607 1
d1667 4
d1838 1
a1838 1
			rt_log("fu x%x, single vertexuse at index %d\n", rs->fu1, cur);
d1863 1
a1863 1
		rt_log("fu x%x vu's on list interval [%d] to [%d] equal\n", rs->fu1, cur, j-1 );
d1894 1
a1894 1
		rt_log("vu[%d] set to x%x\n", j-1, rs->vu[j-1] );
d1916 3
@


10.105
log
@Replaced nmg_lu_of_vu() with nmg_find_lu_of_vu().
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.104 94/03/09 22:06:32 mike Exp Locker: mike $ (BRL)";
d2517 1
a2517 1
		eu = nmg_find_eu_with_vu_in_lu( nmg_find_lu_of_vu(vu), vu );
d2526 1
a2526 1
		eu = nmg_find_eu_with_vu_in_lu( nmg_find_lu_of_vu(vu), vu );
@


10.104
log
@Added wedge##.pl plotting at top of nmg_special_wedge_processing().
Fleshed out bottom case of that function, too.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.103 94/03/04 23:17:58 mike Exp Locker: mike $ (BRL)";
d365 2
a366 1
	lu = nmg_lu_of_vu(vu);
d553 1
a553 1
	if( (lu = nmg_lu_of_vu(vu)) == (struct loopuse *)0 )
d1333 1
a1333 1
			nmg_vlblock_lu(vbp, nmg_lu_of_vu(vs[i].vu), b,
d1360 1
a1360 1
	outer_lu = nmg_lu_of_vu( vs[outer_wedge].vu );
d1376 1
a1376 1
	inner_lu = nmg_lu_of_vu( vs[inner_wedge].vu );
d1471 2
a1472 1
		lu = nmg_lu_of_vu( rs->vu[i] );
d2445 2
a2446 2
		nmg_pr_lu_briefly(nmg_lu_of_vu(vu), (char *)0);
		nmg_face_lu_plot(nmg_lu_of_vu(vu), rs->vu[0], rs->vu[rs->nvu-1] );
d2517 1
a2517 1
		eu = nmg_find_eu_with_vu_in_lu( nmg_lu_of_vu(vu), vu );
d2526 1
a2526 1
		eu = nmg_find_eu_with_vu_in_lu( nmg_lu_of_vu(vu), vu );
d2549 2
a2550 1
		lu = nmg_lu_of_vu( vu );
d2584 2
a2585 1
		lu = nmg_lu_of_vu( vu );
d2615 1
a2615 1
		lu = nmg_lu_of_vu( vu );
d2620 1
a2620 1
			prev_lu = nmg_lu_of_vu( prev_vu );
d2663 4
a2666 2
			nmg_pr_lu(nmg_lu_of_vu(rs->vu[pos]), "   ");
			nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]), rs->vu[0], rs->vu[rs->nvu-1] );
d2683 2
a2684 1
			lu = nmg_lu_of_vu(rs->vu[pos]);
d2698 1
a2698 1
		nmg_loop_g(nmg_lu_of_vu(rs->vu[pos])->l_p, rs->tol);
d2702 2
a2703 2
			nmg_pr_lu_briefly(nmg_lu_of_vu(rs->vu[pos]), (char *)0);
			nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]), rs->vu[0], rs->vu[rs->nvu-1] );
d2715 1
a2715 1
		lu = nmg_lu_of_vu( vu );
d2721 1
a2721 1
		prev_lu = nmg_lu_of_vu( prev_vu );
d2739 2
a2740 2
				nmg_pr_lu_briefly(nmg_lu_of_vu(rs->vu[pos]), (char *)0);
				nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]), rs->vu[0], rs->vu[rs->nvu-1] );
d2796 2
a2797 1
				lu = nmg_lu_of_vu(vu);
d2808 2
a2809 1
		lu = nmg_lu_of_vu(vu);
@


10.103
log
@Don't bomb at end of special wedge processing.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.102 94/02/22 21:27:37 mike Exp Locker: mike $ (BRL)";
d1316 7
d1326 16
d1392 1
d1413 7
a1419 1
#if 0
d1421 1
a1421 1
		rt_log("Inner wedge was not cut, need to consider cut/joinhere\n");
d1423 3
a1425 2
	rt_bomb("XXX special wedge processing needed\n");
	return 1;
d1427 1
a1427 1
	/* Can we get by with not doing anything more? */
@


10.102
log
@Eliminated infinite recursion by changing calling sequence to
nmg_special_wedge_processing() to include passing the exclude[] array.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.101 94/02/02 00:12:29 mike Exp Locker: mike $ (BRL)";
d1287 3
d1291 1
a1291 1
 *	0	Nothing done
d1389 1
d1395 6
@


10.101
log
@Fusing new common edges is now done inside nmg_face_cutjoin(),
rather than by each of the (two) callers in nmg_inter.c
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.100 94/01/22 21:32:30 mike Exp Locker: mike $ (BRL)";
d1293 1
a1293 1
nmg_special_wedge_processing( vs, start, end, lo_ang, hi_ang, wclass, tol )
d1300 1
d1319 4
a1322 1
	bzero( (char *)not_these, sizeof(not_these) );
d1327 1
a1327 1
		lo_ang, hi_ang, wclass, not_these );
d1330 1
a1330 1
	not_these[outer_wedge] = 1;	/* Don't return this wedge again */
d1338 1
a1338 1
		wclass, not_these );
d1343 1
a1343 1
		 *  not_these[outer_wedge] is already set.
d1363 1
a1363 1
		return 1;
d1378 1
a1378 1
		return 1;
a1381 1
/* XXX Need to not process wedges already done (like, outer_wedge) */
d1383 1
a1383 1
	    vs[inner_wedge].lo_ang, vs[inner_wedge].hi_ang, wclass, tol ) )
d1531 1
a1531 1
	if( nmg_special_wedge_processing( vs, 0, nvu, 0.0, 180.0, WEDGE_RIGHT, rs->tol ) )
d1534 1
a1534 1
	if( nmg_special_wedge_processing( vs, 0, nvu, 360.0, 180.0, WEDGE_LEFT, rs->tol ) )
@


10.100
log
@nmg_face_combine() bad ending state is again an rt_bomb() by default.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.99 94/01/22 02:15:10 mike Exp Locker: mike $ (BRL)";
d1951 1
a1951 1
		rt_log("\nnmg_face_cutjoin(fu1=x%x, fu2=x%x)\n", fu1, fu2);
d2067 9
d2643 2
@


10.99
log
@Fixed missing assignment of "vu" in debugging prints.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.98 94/01/15 00:26:52 mike Exp Locker: mike $ (BRL)";
d1911 1
d1913 4
a1916 1
/*		rt_bomb("nmg_face_combine() bad ending state\n"); */
@


10.98
log
@After call to nmg_cut_loop(), need to re-run nmg_loop_g().
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.97 93/12/22 06:11:39 mike Exp Locker: mike $ (BRL)";
d1697 1
@


10.97
log
@Have to reorient after calling nmg_cut_loop().
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.96 93/12/03 03:35:22 mike Exp Locker: mike $ (BRL)";
d1353 6
a1358 1
		if(new_lu)  nmg_lu_reorient(new_lu, tol);
@


10.96
log
@Access to plane equation / surface normal in face_geometry structure
is now done through macros NMG_GET_FU_PLANE() NMG_GET_FU_NORMAL(),
which honor the f->flip flag.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.95 93/11/19 02:36:26 mike Exp Locker: mike $ (BRL)";
d1293 1
a1293 1
nmg_special_wedge_processing( vs, start, end, lo_ang, hi_ang, wclass )
d1300 1
d1309 2
d1349 1
d1352 2
a1353 1
		(void)nmg_cut_loop( vs[outer_wedge].vu, vs[inner_wedge].vu );
d1375 1
a1375 1
	    vs[inner_wedge].lo_ang, vs[inner_wedge].hi_ang, wclass ) )
d1523 1
a1523 1
	if( nmg_special_wedge_processing( vs, 0, nvu, 0.0, 180.0, WEDGE_RIGHT ) )
d1526 1
a1526 1
	if( nmg_special_wedge_processing( vs, 0, nvu, 360.0, 180.0, WEDGE_LEFT ) )
d2661 4
a2664 9
			if(is_crack)  {
				struct face_g	*fg;
				plane_t		n;
				fg = fu->f_p->fg_p;
				NMG_CK_FACE_G(fg);
				NMG_GET_FU_PLANE( n, fu );
				nmg_lu_reorient( lu, n, rs->tol );
				nmg_lu_reorient( prev_lu, n, rs->tol );
			}
@


10.95
log
@More strict checking of the 'tol' structure.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.94 93/11/19 02:24:33 mike Exp Locker: mike $ (BRL)";
d1625 1
a1625 1
nmg_face_rs_init( rs, b, fu1, fu2, pt, dir )
d1632 1
d1634 3
a1636 1
	RT_CK_TOL(rs->tol);
d1642 1
d1652 2
a1653 1
	VCROSS( rs->left, fu1->f_p->fg_p->N, dir );
d1671 1
a1671 1
		HPRINT("\tfg N", fu1->f_p->fg_p->N);
d1743 2
d1824 3
d2041 2
a2042 3
	nmg_face_rs_init( &rs1, b1, fu1, fu2, pt, dir );
	nmg_face_rs_init( &rs2, b2, fu2, fu1, pt, dir );
	rs1.tol = rs2.tol = tol;
d2369 1
d2658 1
d2661 3
a2663 2
				nmg_lu_reorient( lu, fg->N, rs->tol );
				nmg_lu_reorient( prev_lu, fg->N, rs->tol );
@


10.94
log
@Lee's triangulator detected that the nmg_special_wedge_wedge_processing()
routine was being too strict about which wedges it would join.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.93 93/11/18 02:09:12 mike Exp Locker: mike $ (BRL)";
d160 1
d454 2
d1633 5
d1928 5
a1938 2

	RT_CK_TOL(tol);
@


10.93
log
@Bounding box routines now all take a tol arg.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.92 93/11/17 19:01:55 mike Exp $ (BRL)";
d1353 3
a1355 3
		/* Different loops with same orientation.  If they are exactly
		 * the same wedge, then join them.
		 * Otherwise, this is an error condition.
a1356 11
		int	other_way_round;
		not_these[outer_wedge] = 0;	/* temporary reset */
		not_these[inner_wedge] = 1;
		other_way_round = nmg_find_vu_in_wedge( vs, start, end,
			vs[inner_wedge].lo_ang, vs[inner_wedge].hi_ang,
			wclass, not_these );
		if( other_way_round != outer_wedge )  {
			rt_log("outer=%d, inner=%d, other_way_round=%d\n",
				outer_wedge, inner_wedge, other_way_round);
			rt_bomb("nmg_special_wedge_processing: touching loops have same orientation, but are not exactly the same wedge\n");
		}
@


10.92
log
@Made the RIGHT/CROSS call nmg_is_wedge_before_cross() like the other
cases.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.91 93/11/12 21:39:47 mike Exp Locker: mike $ (BRL)";
d2611 1
a2611 1
		nmg_loop_g(nmg_lu_of_vu(rs->vu[pos])->l_p);
d2644 2
d2735 1
a2735 1
		nmg_loop_g(lu->l_p);
@


10.91
log
@Fixed problem with vu sorting reported by Lee.
Pushed decision making code into nmg_is_wedge_before_cross().
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.90 93/11/09 19:36:12 butler Exp Locker: mike $ (BRL)";
d1185 3
a1187 5
			if( b->lo_ang < a->hi_ang )  A_GT_B;
			/* Choose smaller inbound angle */
			diff = 360 - b->hi_ang;/* CW version of left angle */
			if( diff < a->lo_ang )  A_GT_B;
			A_LT_B;
@


10.90
log
@static function nmg_face_rs_init() made non-static
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.89 1993/10/27 19:32:11 mike Exp butler $ (BRL)";
d715 2
d733 3
a735 1
 *	WEDGE2_IDENTICAL		AB == CD
d754 1
d756 3
a758 3
	if( _a <= .01 )  _a = 0; \
	else if( NEAR_ZERO( _a - 180, .01 ) )  _a = 180; \
	else if( _a >= 360 - .01 )  _a = 360; }
d778 6
a783 6
	if( NEAR_ZERO( a-b, 0.01 ) )  a_eq_b = 1;
	if( NEAR_ZERO( a-c, 0.01 ) )  a_eq_c = 1;
	if( NEAR_ZERO( a-d, 0.01 ) )  a_eq_d = 1;
	if( NEAR_ZERO( b-c, 0.01 ) )  b_eq_c = 1;
	if( NEAR_ZERO( b-d, 0.01 ) )  b_eq_d = 1;
	if( NEAR_ZERO( c-d, 0.01 ) )  c_eq_d = 1;
d866 1
a866 1
			a, b, c, d, ret, nmg_wedge2_string[ret+2] );
d868 1
a868 1
	if(ret <= -2 )  {
d1010 60
d1084 1
a1084 1
#define	A_WINS		{ret = -1; goto out;}
d1086 1
a1086 1
#define B_WINS		{ret = 1; goto out;}
d1104 2
a1105 2
	lo_equal = NEAR_ZERO( a->lo_ang - b->lo_ang, 0.001 );
	hi_equal = NEAR_ZERO( a->hi_ang - b->hi_ang, 0.001 );
d1112 1
a1112 1
			if( a->seq < b->seq )  A_WINS;
d1114 1
a1114 1
			B_WINS;
d1118 1
a1118 1
		if( NEAR_ZERO( diff, 0.001 ) )  {
d1125 2
a1126 2
		if( diff < 0 )  A_WINS;
		B_WINS;
d1142 2
a1143 2
				if( a->hi_ang < b->hi_ang ) A_WINS;
				B_WINS;
d1145 2
a1146 2
			if( a->lo_ang > b->lo_ang )  A_WINS;
			B_WINS;
d1148 3
a1150 6
			/* See if A is behind B */
			if( a->lo_ang <= b->hi_ang ) B_WINS;
			/* Choose smaller inbound angle */
			diff = 360 - a->lo_ang;/* CW version of left angle */
			if( b->lo_ang <= diff )  B_WINS;
			A_WINS;
d1153 2
a1154 2
			if( b->lo_ang <= diff )  B_WINS;
			A_WINS;
d1161 3
a1163 5
			if( a->hi_ang >= b->lo_ang ) A_WINS;
			/* Choose smaller inbound angle */
			diff = 360 - b->lo_ang;/* CW version of left angle */
			if( diff <= a->lo_ang )  B_WINS;
			A_WINS;
d1166 2
a1167 2
				if( a->hi_ang > b->hi_ang )  A_WINS;
				B_WINS;
d1169 2
a1170 2
			if( a->lo_ang < b->lo_ang )  A_WINS;
			B_WINS;
d1172 3
a1174 5
			if( a->lo_ang < b->hi_ang )  A_WINS;
			/* Choose smaller inbound angle */
			diff = 360 - a->hi_ang;/* CW version of left angle */
			if( diff < b->lo_ang )  A_WINS;
			B_WINS;
d1182 2
a1183 2
			if( a->lo_ang <= diff )  A_WINS;
			B_WINS;
d1185 1
a1185 1
			if( b->lo_ang < a->hi_ang )  B_WINS;
d1188 2
a1189 2
			if( diff < a->lo_ang )  B_WINS;
			A_WINS;
d1192 2
a1193 2
				if( a->hi_ang < b->hi_ang )  B_WINS;
				A_WINS;
d1195 2
a1196 2
			if( a->lo_ang < b->lo_ang )  A_WINS;
			B_WINS;
@


10.89
log
@Moved face simplification from the bottom of the face cutter
up to the bottom of nmg_isect_two_generic_faces().
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.88 93/10/23 07:18:43 mike Exp Locker: mike $ (BRL)";
d1576 1
a1576 1
HIDDEN void
@


10.88
log
@Added more printing on "point off line" error handling.
Added nmg_sanitize_fu() routine.
At end of face cutting operation, eliminate OT_BOOLPLACE, and unbreak
any edges.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.87 93/10/22 22:27:56 mike Exp Locker: mike $ (BRL)";
d1984 3
a1986 7
	/* Eliminate any OT_BOOLPLACE self-loops now. */
	nmg_sanitize_fu( fu1 );
	nmg_sanitize_fu( fu2 );

	/* Eliminate stray vertices that were added along edges in this step */
	(void)nmg_unbreak_region_edges( &fu1->l.magic );
	(void)nmg_unbreak_region_edges( &fu2->l.magic );
@


10.87
log
@nmg_eups() and nmg_lups() eliminated, in favor of
nmg_find_s_of_lu() and nmg_find_s_of_eu().

@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.86 93/10/18 23:45:10 mike Exp Locker: mike $ (BRL)";
a209 4
			if( dist > 100*dist_tol )  {
				rt_log("ERROR ptbl_vsort() vu=x%x point off line by %g > 100*dist_tol\n", dist);
				rt_bomb("ptbl_vsort()\n");
			}
d214 3
d218 5
d1538 26
d1983 8
@


10.86
log
@Added support for WEDGE_ON recognition and processing.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.85 93/10/18 20:09:29 mike Exp Locker: mike $ (BRL)";
d575 1
a575 1
			if( nmg_break_long_edges( nmg_eups(this_eu), rs->tol ) > 0 )
@


10.85
log
@Unterminated comment.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.84 93/10/18 19:41:12 mike Exp Locker: mike $ (BRL)";
d517 1
a517 1
		rt_log(" v(%g,%g,%g) other(%g,%g,%g)\n",
d519 1
a519 1
		rt_log(" rs->left(%g,%g,%g) heading(%g,%g,%g)\n",
d597 1
a597 1
	int			wedge_class;	/* -1=LEFT, 0=Cross, +1=RIGHT */
d606 5
a610 4
#define WEDGE_LEFT	-1
#define WEDGE_CROSS	0
#define WEDGE_RIGHT	1
#define WEDGECLASS2STR(_cl)	nmg_wedgeclass_string[(_cl)+1]
d615 1
d632 4
a635 3
 *	-1	LEFT
 *	 0	Crossing or both ON
 *	 1	RIGHT
d638 2
a639 1
nmg_wedge_class(a,b)
d649 9
d919 1
a919 1
		if( vs[i].wedge_class != wclass )  {
d927 11
d994 1
a994 1
		rt_log("nmg_find_vu_in_wedge(start=%d,end=%d, lo=%g, hi=%g) candidate=%d\n",
d1060 8
d1089 2
d1113 2
d1135 2
d1245 6
d1255 1
a1255 1
	/* There may be many wedges to iterate over */
d1397 1
a1397 1
		vs[nvu].wedge_class = nmg_wedge_class( vs[nvu].in_vu_angle, vs[nvu].out_vu_angle );
d1468 1
@


10.84
log
@Fixed bug in lo_ang/hi_ang sorting for WEDGE_CROSS case.
Improved tie breaker code in nmg_face_vu_compare()
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.83 93/10/01 20:32:49 mike Exp Locker: mike $ (BRL)";
d1023 1
a1023 1
		/* Select smallest inbound angle
@


10.83
log
@Moved nmg_stash_model_to_file() into nmg_misc.c.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.82 93/10/01 20:08:57 mike Exp Locker: mike $ (BRL)";
d1015 1
a1015 1
	    	/* XXX tie break */
d1023 1
a1023 2
	    	/* XXX what about loop orientation? */
	    	rt_log("XXX nmg_face_vu_compare(): tie break\n");
d1025 1
a1025 2
		if( diff < 0 )  A_WINS;
		if( diff == 0 )  {
d1029 1
d1032 1
d1103 2
a1104 2
		rt_log("nmg_face_vu_compare(x%x, x%x) %s %s, %s\n",
			a, b,
d1355 3
a1357 3
		/* Sort the angles */
		if( (vs[nvu].wedge_class == WEDGE_LEFT  && vs[nvu].in_vu_angle > vs[nvu].out_vu_angle) ||
		    (vs[nvu].wedge_class == WEDGE_RIGHT && vs[nvu].in_vu_angle < vs[nvu].out_vu_angle) )  {
@


10.82
log
@machine.h goes first.
On IRIX 5.0.1, won't compile without -cckr flag due to compiler bug.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.81 93/09/15 02:35:04 mike Exp Locker: mike $ (BRL)";
a44 2
#include "db.h"		/* for debugging stuff at bottom */

d215 3
a217 1
				rt_log("WARNING ptbl_vsort() vu=x%x point off line by %e, tol=%e\n", vu[i], dist, dist_tol);
d996 7
a1002 2
CONST genptr_t	aa;
CONST genptr_t	bb;
a2616 51
}

/*
 *			N M G _ S T A S H _ M O D E L _ T O _ F I L E
 *
 *  Store an NMG model as a separate .g file, for later examination.
 * XXX Move this to nmg_misc.c
 */
void
nmg_stash_model_to_file( filename, m, title )
CONST char		*filename;
CONST struct model	*m;
CONST char		*title;
{
	FILE	*fp;
	struct rt_external	ext;
	struct rt_db_internal	intern;
	union record		rec;

	rt_log("nmg_stash_model_to_file('%s', x%x, %s)\n", filename, m, title);

	NMG_CK_MODEL(m);

	if( (fp = fopen(filename, "w")) == NULL )  {
		perror(filename);
		return;
	}

	RT_INIT_DB_INTERNAL(&intern);
	intern.idb_type = ID_NMG;
	intern.idb_ptr = (genptr_t)m;
	RT_INIT_EXTERNAL( &ext );

	/* Scale change on export is 1.0 -- no change */
	if( rt_functab[ID_NMG].ft_export( &ext, &intern, 1.0 ) < 0 )  {
		rt_log("nmg_stash_model_to_file: solid export failure\n");
		if( intern.idb_ptr )  rt_functab[ID_NMG].ft_ifree( &intern );
		db_free_external( &ext );
		rt_bomb("nmg_stash_model_to_file() ft_export() error\n");
	}
	rt_functab[ID_NMG].ft_ifree( &intern );
	NAMEMOVE( "error", ((union record *)ext.ext_buf)->s.s_name );

	bzero( (char *)&rec, sizeof(rec) );
	rec.u_id = ID_IDENT;
	strcpy( rec.i.i_version, ID_VERSION );
	strncpy( rec.i.i_title, title, sizeof(rec.i.i_title)-1 );
	fwrite( (char *)&rec, sizeof(rec), 1, fp );
	fwrite( ext.ext_buf, ext.ext_nbytes, 1, fp );
	fclose(fp);
	rt_log("nmg_stash_model_to_file(): wrote '%s' in %d bytes\n", filename, ext.ext_nbytes);
@


10.81
log
@Fixed debug printf
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.80 93/09/10 23:19:16 mike Exp Locker: mike $ (BRL)";
d39 1
a40 1
#include "machine.h"
@


10.80
log
@Lots of debugging additions in the hunt for the ON/ON bug.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.79 93/09/09 00:15:05 mike Exp Locker: mike $ (BRL)";
d217 1
a217 1
				rt_log("WARNING ptbl_vsort() vu=x%x point off line by %e, tol=%e\n", dist, dist_tol);
@


10.79
log
@Debug fiddling.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.78 93/09/07 09:22:52 jra Exp Locker: mike $ (BRL)";
d212 3
a214 3
			if( dist > 1 )  {
				rt_log("ptbl_vsort() vu=x%x point off line by %g\n", dist);
				rt_log("ptbl_vsort()\n");
d216 3
a448 2
	

d491 1
d567 10
d2218 11
a2235 2
	vu = rs->vu[pos];
	NMG_CK_VERTEXUSE(vu);
a2289 3
		rt_log("Plotting this loopuse, before action:\n");
		nmg_pr_lu_briefly(nmg_lu_of_vu(vu), (char *)0);
		nmg_face_lu_plot(nmg_lu_of_vu(vu), rs->vu[0], rs->vu[rs->nvu-1] );
d2618 1
a2618 1
 * XXX this belongs elsewhere.
d2622 3
a2624 3
char		*filename;
struct model	*m;
CONST char	*title;
d2662 1
a2662 1
	rt_log("nmg_stash_model_to_file(): wrote '%s'\n", filename);
@


10.78
log
@added "nmg_insert_vu_if_on_edge" and calls to it from "nmg_face_state_transition"
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.77 93/08/27 21:19:24 mike Exp Locker: jra $ (BRL)";
d1534 1
a1534 1
			rt_log( "\t\tLOOPUSE x%x:\n" , lu );
d1537 1
a1537 1
				nmg_pr_vu_briefly( vu , "\t\tVertex Loop: " );
d1548 1
a1548 1
					nmg_pr_eu_briefly( eu , "\t\t\t" );
d1558 1
a1558 1
					rt_log( "\t\t\t\teu_dir = ( %g , %g , %g ), length = %g\n", V3ARGS( eu_dir ) , eu_len );
d2075 4
a2078 1
/*	This code checks if the vertex from a loop of a single vertex lies on
d2522 2
d2525 2
d2529 1
d2537 2
d2540 2
d2544 1
@


10.77
log
@The "left" issue is dealt with in nmg_inter.c, not here.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.76 93/08/27 04:53:18 mike Exp Locker: mike $ (BRL)";
d446 2
d517 2
d1515 5
d1525 37
d1834 49
d2075 89
d2511 2
d2515 8
a2522 1
			    	rs->vu[pos-1] = nmg_join_singvu_loop( vu, prev_vu );
d2525 8
a2532 1
			    	rs->vu[pos] = nmg_join_singvu_loop( prev_vu, vu );
d2535 2
@


10.76
log
@Marked probabl location of rs->left difficulty.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.75 93/08/19 01:07:48 mike Exp Locker: mike $ (BRL)";
d1473 6
a1478 1
 *  It points in the direction "left" of the ray.
a1498 1
/* XXX We can't assume that "dir" lies in the direction of an edge. */
@


10.75
log
@nmg_assess_vu() ON/ON edgeuse ends on different vertices.
Added sanity check on behavior of intersector.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.73 93/07/20 22:47:37 mike Exp $ (BRL)";
d1494 1
d1496 1
@


10.74
log
@Eliminated hack to purge vu list of ON_FORW_ON_REV vu's.
Now that state=on_neither exists, they are quite necessary to advance
the state machine properly.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.73 93/07/20 22:47:37 mike Exp Locker: mike $ (BRL)";
d545 19
@


10.73
log
@qsort() oddities.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.72 93/07/20 21:21:58 mike Exp $ (BRL)";
a1265 2
	if(rt_g.NMG_debug&DEBUG_VU_SORT)
		rt_log("nmg_face_coincident_vu_sort(, %d, %d)\n", start, end);
d1273 3
a1293 16
				continue;
			}
		}

		/*
		 *  At a multiple vertexuse vertex, eliminate all the
		 *  NMG_ON_REV_ON_FORW and NMG_ON_FORW_ON_REV vu's.
		 *  If they are all such, then send just one through.
		 */
		if( ass==NMG_ON_REV_ON_FORW || ass==NMG_ON_FORW_ON_REV )  {
			if( nvu > 0 || i > start )  {
				/* At least one other kind already seen,
				 * or at least one other vu still to be
				 * processed, toss this one.
				 * XXX What about if last one is a lone-vu-loop, and should be tossed in place of this corner vu?
				 */
@


10.72
log
@ANSI qsort calling sequence fix.
Additional debugging on ray distance.
Temporary calls to nmg_fu_touchingloops().
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.71 93/05/21 02:02:44 mike Exp Locker: mike $ (BRL)";
d1413 2
a1414 6
#if defined(__convexc__)
	qsort( (genptr_t)vs, nvu, sizeof(*vs),
		(int (*)())nmg_face_vu_compare);
#else
	qsort( (genptr_t)vs, nvu, sizeof(*vs), nmg_face_vu_compare );
#endif
@


10.71
log
@Fixed "accordian pleat" problem with vu sorting at multiple
coincident vertexuse locations.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.70 93/05/20 19:42:17 mike Exp Locker: mike $ (BRL)";
d204 15
d1260 1
a1260 1
	int		nvu;
d2016 2
d2370 2
@


10.70
log
@Test for TOUCHing wedges must come before INside test.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.69 93/05/14 01:37:18 mike Exp Locker: mike $ (BRL)";
d112 17
d1048 1
a1048 1
		rt_log("nmg_face_vu_comapre(x%x, x%x) %s %s, %s\n",
d1273 6
a1278 4
			if( i <= start && nvu == 0 )  {
				rt_free( (char *)vs, "nmg_vu_stuff");
				rt_free( (char *)ls, "nmg_loop_stuff");
				return start+1;	/* end point */
a1279 4
			/* Drop this loop of a single vertex in sanitize() */
			lu->orientation =
			  lu->lumate_p->orientation = OT_BOOLPLACE;
			continue;
d1281 17
a1831 18
#define NMG_LEFT_LEFT	NMG_V_COMB(NMG_E_ASSESSMENT_LEFT,NMG_E_ASSESSMENT_LEFT)
#define NMG_LEFT_RIGHT	NMG_V_COMB(NMG_E_ASSESSMENT_LEFT,NMG_E_ASSESSMENT_RIGHT)
#define NMG_LEFT_ON_FORW NMG_V_COMB(NMG_E_ASSESSMENT_LEFT,NMG_E_ASSESSMENT_ON_FORW)
#define NMG_LEFT_ON_REV	NMG_V_COMB(NMG_E_ASSESSMENT_LEFT,NMG_E_ASSESSMENT_ON_REV)
#define NMG_RIGHT_LEFT	NMG_V_COMB(NMG_E_ASSESSMENT_RIGHT,NMG_E_ASSESSMENT_LEFT)
#define NMG_RIGHT_RIGHT	NMG_V_COMB(NMG_E_ASSESSMENT_RIGHT,NMG_E_ASSESSMENT_RIGHT)
#define NMG_RIGHT_ON_FORW NMG_V_COMB(NMG_E_ASSESSMENT_RIGHT,NMG_E_ASSESSMENT_ON_FORW)
#define NMG_RIGHT_ON_REV NMG_V_COMB(NMG_E_ASSESSMENT_RIGHT,NMG_E_ASSESSMENT_ON_REV)
#define NMG_ON_FORW_LEFT NMG_V_COMB(NMG_E_ASSESSMENT_ON_FORW,NMG_E_ASSESSMENT_LEFT)
#define NMG_ON_FORW_RIGHT NMG_V_COMB(NMG_E_ASSESSMENT_ON_FORW,NMG_E_ASSESSMENT_RIGHT)
#define NMG_ON_FORW_ON_FORW NMG_V_COMB(NMG_E_ASSESSMENT_ON_FORW,NMG_E_ASSESSMENT_ON_FORW)
#define NMG_ON_FORW_ON_REV NMG_V_COMB(NMG_E_ASSESSMENT_ON_FORW,NMG_E_ASSESSMENT_ON_REV)
#define NMG_ON_REV_LEFT	NMG_V_COMB(NMG_E_ASSESSMENT_ON_REV,NMG_E_ASSESSMENT_LEFT)
#define NMG_ON_REV_RIGHT NMG_V_COMB(NMG_E_ASSESSMENT_ON_REV,NMG_E_ASSESSMENT_RIGHT)
#define NMG_ON_REV_ON_FORW NMG_V_COMB(NMG_E_ASSESSMENT_ON_REV,NMG_E_ASSESSMENT_ON_FORW)
#define NMG_ON_REV_ON_REV NMG_V_COMB(NMG_E_ASSESSMENT_ON_REV,NMG_E_ASSESSMENT_ON_REV)
#define NMG_LONE	NMG_V_ASSESSMENT_LONE

@


10.69
log
@Expanded nmg_compare_2_wedges() to handle a==d case.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.68 93/05/08 07:46:55 mike Exp Locker: mike $ (BRL)";
d696 5
a700 18
	if( a_eq_c )  {
		if( b_eq_d )  {
			ret = WEDGE2_IDENTICAL;
			goto out;
		}
		/* We already know that A <= B, from sort above */
		if( b < d )  ret = WEDGE2_AB_IN_CD;
		else  ret = WEDGE2_CD_IN_AB;
		goto out;
	}

	if( b_eq_d )  {
		/* a != c, because of previous IF statement */
		if( a < c )  ret = WEDGE2_CD_IN_AB;
		else  ret = WEDGE2_AB_IN_CD;
		goto out;
	}

d703 4
a706 1
		ret = WEDGE2_TOUCH_AT_BC;
d723 18
@


10.68
log
@More wedgies.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.67 93/05/08 01:31:15 mike Exp Locker: mike $ (BRL)";
d627 2
a628 1
	"WEDGE2_AB_TOUCH_CD",
d636 3
a638 1
#define WEDGE2_AB_TOUCH_CD	3
d658 1
d663 1
d689 1
d694 1
d716 1
a716 1
		ret = WEDGE2_AB_TOUCH_CD;
d720 16
d771 4
a774 1
	if(ret <= -2 )  rt_log("nmg_compare_2_wedges(%g,%g, %g,%g) ERROR!\n", a, b, c, d);
@


10.67
log
@Made wedge debugging messages conditional on DEBUG_VU_SORT.
Changed wedge comparison routine to detect AB_TOUCHES_CD.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.66 93/05/07 20:30:11 mike Exp Locker: mike $ (BRL)";
a644 2
 *  XXX Would there be any value to detecting non-overlapping wedges
 *  XXX that share an edge?
d655 4
d684 13
a696 2
	if( a == c && b == d )  {
		ret = WEDGE2_IDENTICAL;
d700 8
a707 1
	if( NEAR_ZERO( b-c, 0.01 ) )  {
d816 9
a824 1
		if( this_wrt_orig != WEDGE2_AB_IN_CD )  continue;	/* not inside */
d867 1
d1149 1
@


10.66
log
@Handle wedge case of different loops with same orientation touching
in exactly the same wedge.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.65 93/05/07 05:20:35 mike Exp Locker: mike $ (BRL)";
d627 2
a628 1
	"???"
d635 1
d684 1
d687 6
d779 2
a780 1
rt_log("Skipping index %d\n", i);
d786 4
a789 2
rt_log("Seeking wedge_class=%s, [%d] has wedge_class %s\n",
WEDGECLASS2STR(wclass), i, WEDGECLASS2STR(vs[i].wedge_class) );
d802 2
a803 1
rt_log("Initial candidate %d selected\n", i);
d817 2
a818 1
rt_log("This candidate %d is closer\n", i);
d826 2
a827 1
rt_log("Taking lower angle %d\n", i);
d834 2
a835 1
rt_log("Continuing with search\n");
d1104 2
a1105 1
		rt_log("special_wedge:  inner and outer wedges from same loop, cutting loop\n");
d1110 2
a1111 1
	rt_log("wedge at vu[%d] is inside wedge at vu[%d]\n", inner_wedge, outer_wedge);
d1128 2
a1129 1
		rt_log("joining loops\n");
d1141 2
a1142 1
	rt_log("Inner wedge was not cut, need to consider cut/joinhere\n");
@


10.65
log
@Added extra state to state machine:  ON_N  --
loop is ON the ray, but solid does not extend to either side.
This is a "non-hole" crack, like the base of the letter "P".
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.64 93/05/07 04:40:42 mike Exp Locker: mike $ (BRL)";
d643 2
d1095 21
d1117 1
@


10.64
log
@Fixed legitimate error in ON_L table.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.63 93/05/05 05:26:20 mike Exp Locker: mike $ (BRL)";
d53 2
a54 1
#define NMG_STATE_IN		5
d60 2
a61 1
	"on_both",
d1483 2
d1488 2
d1504 2
d1507 2
d1732 1
a1732 1
	{ NMG_ON_REV_ON_FORW,	NMG_STATE_IN,		NMG_ACTION_VFY_EXT },
d1750 1
a1750 1
	{ NMG_ON_REV_LEFT,	NMG_STATE_IN,		NMG_ACTION_VFY_MULTI },
d1762 1
a1762 1
	{ NMG_RIGHT_LEFT,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d1764 1
a1764 1
	{ NMG_RIGHT_ON_FORW,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d1797 20
d1900 3
@


10.63
log
@Modified to use skip_array[] to tag which wedges have already been visited.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.62 93/05/05 04:52:53 mike Exp Locker: mike $ (BRL)";
d1742 1
a1742 1
	{ NMG_ON_REV_ON_FORW,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
@


10.62
log
@Worked on nmg_special_wedge_processing().
Fixed problem in nmg_find_vu_in_wedge() that was causing candidates to
be overlooked.
Fixed one table entry in ON state.  ON_FORW,ON_REV leads to OUT.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.61 93/04/09 04:10:14 mike Exp Locker: mike $ (BRL)";
d737 1
a737 1
nmg_find_vu_in_wedge( vs, start, end, lo_ang, hi_ang, wclass, skip_index )
d744 1
a744 1
int	skip_index;
d765 1
a765 1
		if( i == skip_index )  {
d1050 1
d1052 3
d1057 2
a1058 1
	outer_wedge = nmg_find_vu_in_wedge( vs, start, end, lo_ang, hi_ang, wclass, -1 );
d1061 2
d1069 1
a1069 1
		wclass, outer_wedge );
d1074 1
a1075 1
		lo_ang = vs[outer_wedge].hi_ang;
@


10.61
log
@Added debugging in search of the "vu block with differing vertices" bug.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.60 93/04/08 03:32:02 mike Exp Locker: mike $ (BRL)";
d737 1
a737 1
nmg_find_vu_in_wedge( vs, start, end, lo_ang, hi_ang, wclass )
d744 1
d751 4
d764 6
d771 5
a775 1
		if( vs[i].wedge_class != wclass )  continue;
d782 11
d798 1
a798 1
			/* This wedge contains candidate wedge, therefore
d800 1
d808 1
d815 1
d1046 4
a1049 1
	int	this_wedge;
d1051 4
a1054 2
	this_wedge = nmg_find_vu_in_wedge( vs, start, end, lo_ang, hi_ang, wclass );
	if( this_wedge <= -1 )  return 0;	/* No wedges to process */
d1057 2
d1060 12
d1073 19
a1091 2
	/* XXX more here */
	rt_log("XXX special wedge processing needed\n");
d1125 1
d1233 4
a1236 2
	nmg_special_wedge_processing( vs, 0, nvu, 0.0, 180.0, WEDGE_RIGHT );
	nmg_special_wedge_processing( vs, 0, nvu, 360.0, 180.0, WEDGE_LEFT );
d1792 1
a1792 1
	{ NMG_ON_FORW_ON_REV,	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
@


10.60
log
@Be sure not to break edge at a loop of a single vertex when
that vertex is already an end-point of the edge.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.59 93/04/07 06:34:48 mike Exp Locker: mike $ (BRL)";
d1323 1
d1325 1
d1327 6
a1339 1
	v = rs->vu[cur]->v_p;
d1341 12
a1352 1
		if( rs->vu[k]->v_p != v )  rt_bomb("nmg_face_combine: vu block with differing vertices\n");
@


10.59
log
@Made DEBUG_VERIFY a runtime option
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.58 93/03/26 23:39:19 mike Exp Locker: mike $ (BRL)";
d1951 11
a1961 2
		rs->vu[pos] = nmg_ebreak( vu->v_p, eu )->vu_p;
		/* Kill lone vertex loop */
@


10.58
log
@Changed nmg_eu_with_vu_in_lu
to nmg_find_eu_with_vu_in_lu()
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.57 93/03/26 22:41:05 mike Exp Locker: mike $ (BRL)";
d1753 4
a1756 4
#ifdef PARANOID_VERIFY
	nmg_vfu( &rs->fu1->s_p->fu_hd, rs->fu1->s_p );
	nmg_vfu( &rs->fu2->s_p->fu_hd, rs->fu2->s_p );
#endif
d2092 5
a2096 5
#ifdef PARANOID_VERIFY
	/* Verify both faces are still OK */
	nmg_vfu( &rs->fu1->s_p->fu_hd, rs->fu1->s_p );
	nmg_vfu( &rs->fu2->s_p->fu_hd, rs->fu2->s_p );
#endif
@


10.57
log
@Changed log message.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.56 93/03/24 03:21:01 mike Exp Locker: mike $ (BRL)";
d324 1
a324 1
	this_eu = nmg_eu_with_vu_in_lu( lu, vu );
d507 1
a507 1
	this_eu = nmg_eu_with_vu_in_lu( lu, vu );
d955 1
a955 1
	this_eu = nmg_eu_with_vu_in_lu( lu, vu );
d1148 1
a1148 1
		first_eu = nmg_eu_with_vu_in_lu( ls[l].lu, ls[l].min_vu );
d1821 1
a1821 1
		eu = nmg_eu_with_vu_in_lu( nmg_lu_of_vu(vu), vu );
d1830 1
a1830 1
		eu = nmg_eu_with_vu_in_lu( nmg_lu_of_vu(vu), vu );
@


10.56
log
@Moved extern declaration to raytrace.h
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.55 93/03/24 02:41:24 mike Exp Locker: mike $ (BRL)";
d2116 1
a2116 2
	rt_log("nmg_stash_model_to_file(x%x '%s', x%x, %s)\n", filename, filename, m, title);
filename = "error.g";	/* XXX First arg is getting trashed! */
@


10.55
log
@Moved these routines from nmg_fcut.c to nmg_mod.c:
        nmg_join_singvu_loop
        nmg_join_2singvu_loops
        nmg_loop_is_a_crack
        nmg_loop_is_ccw
        nmg_set_lu_orientation
        nmg_lu_reorient
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.54 93/03/22 15:44:55 mike Exp Locker: mike $ (BRL)";
a158 2

RT_EXTERN(void			nmg_face_lu_plot, ( struct loopuse *lu, struct vertexuse *vu1, struct vertexuse *vu2) );
@


10.54
log
@Added routine names to three rt_bomb() calls.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.53 93/03/17 05:17:43 mike Exp Locker: mike $ (BRL)";
a162 21
 *			N M G _ S E T _ L U _ O R I E N T A T I O N
 */
void
nmg_set_lu_orientation( lu, is_opposite )
struct loopuse	*lu;
int		is_opposite;
{
	NMG_CK_LOOPUSE(lu);
	NMG_CK_LOOPUSE(lu->lumate_p);
	if( is_opposite )  {
		/* Interior (crack) loop */
		lu->orientation = OT_OPPOSITE;
		lu->lumate_p->orientation = OT_OPPOSITE;
	} else {
		/* Exterior loop */
		lu->orientation = OT_SAME;
		lu->lumate_p->orientation = OT_SAME;
	}
}

/*
a1586 1
/* XXX This should move into nmg_join_2loops, or be called by it */
a1587 91
 *			N M G _ J O I N _ S I N G V U _ L O O P
 *
 *  vu1 is in a regular loop, vu2 is in a loop of a single vertex
 *  A jaunt is taken from vu1 to vu2 and back to vu1, and the
 *  old loop at vu2 is destroyed.
 *  Return is the new vu that replaces vu2.
 */
struct vertexuse *
nmg_join_singvu_loop( vu1, vu2 )
struct vertexuse	*vu1, *vu2;
{
    	struct edgeuse	*eu1;
	struct edgeuse	*first_new_eu, *second_new_eu;
	struct loopuse	*lu2;

	NMG_CK_VERTEXUSE( vu1 );
	NMG_CK_VERTEXUSE( vu2 );

	if( *vu2->up.magic_p != NMG_LOOPUSE_MAGIC ||
	    *vu1->up.magic_p != NMG_EDGEUSE_MAGIC )  rt_bomb("nmg_join_singvu_loop bad args\n");

	if( vu1->v_p == vu2->v_p )  rt_bomb("nmg_join_singvu_loop same vertex\n");

    	/* Take jaunt from vu1 to vu2 and back */
    	eu1 = vu1->up.eu_p;
    	NMG_CK_EDGEUSE(eu1);

    	/* Insert 0 length edge */
    	first_new_eu = nmg_eins(eu1);
	/* split the new edge, and connect it to vertex 2 */
	second_new_eu = nmg_eusplit( vu2->v_p, first_new_eu );
	first_new_eu = RT_LIST_PLAST_CIRC(edgeuse, second_new_eu);
	/* Make the two new edgeuses share just one edge */
	nmg_moveeu( second_new_eu, first_new_eu );

	/* Kill loop lu2 associated with vu2 */
	lu2 = vu2->up.lu_p;
	NMG_CK_LOOPUSE(lu2);
	nmg_klu(lu2);
	return second_new_eu->vu_p;
}

/*
 *			N M G _ J O I N _ 2 S I N G V U _ L O O P S
 *
 *  Both vertices are part of single vertex loops.
 *  Converts loop on vu1 into a real loop that connects them together,
 *  with a single edge (two edgeuses).
 *  Loop on vu2 is killed.
 *  Returns replacement vu for vu2.
 *  Does not change the orientation.
 */
struct vertexuse *
nmg_join_2singvu_loops( vu1, vu2 )
struct vertexuse	*vu1, *vu2;
{
    	struct edgeuse	*eu1;
	struct edgeuse	*first_new_eu, *second_new_eu;
	struct loopuse	*lu1, *lu2;

rt_log("nmg_join_2singvu_loops( x%x, x%x )\n", vu1, vu2 );

	NMG_CK_VERTEXUSE( vu1 );
	NMG_CK_VERTEXUSE( vu2 );

	if( *vu2->up.magic_p != NMG_LOOPUSE_MAGIC ||
	    *vu1->up.magic_p != NMG_LOOPUSE_MAGIC )  rt_bomb("nmg_join_2singvu_loops bad args\n");

	if( vu1->v_p == vu2->v_p )  rt_bomb("nmg_join_2singvu_loops same vertex\n");

    	/* Take jaunt from vu1 to vu2 and back */
	/* Make a 0 length edge on vu1 */
	first_new_eu = nmg_meonvu(vu1);
	/* split the new edge, and connect it to vertex 2 */
	second_new_eu = nmg_eusplit( vu2->v_p, first_new_eu );
	first_new_eu = RT_LIST_PLAST_CIRC(edgeuse, second_new_eu);
	/* Make the two new edgeuses share just one edge */
	nmg_moveeu( second_new_eu, first_new_eu );

	/* Kill loop lu2 associated with vu2 */
	lu2 = vu2->up.lu_p;
	NMG_CK_LOOPUSE(lu2);
	nmg_klu(lu2);

	lu1 = vu1->up.eu_p->up.lu_p;
	NMG_CK_LOOPUSE(lu1);

	return second_new_eu->vu_p;
}

/*
d2102 1
a2102 1
 *			N M G _ L O O P _ I S _ A _ C R A C K
a2103 186
 *  Returns -
 *	 0	Loop is not a "crack"
 *	!0	Loop *is* a "crack"
 */
int
nmg_loop_is_a_crack( lu )
struct loopuse	*lu;
{
	struct edgeuse	*cur_eu;
	struct edgeuse	*cur_eumate;
	struct vertexuse *cur_vu;
	struct vertex	*cur_v;
	struct vertexuse *next_vu;
	struct vertex	*next_v;
	struct faceuse	*fu;
	struct vertexuse *test_vu;
	struct edgeuse	*test_eu;
	struct loopuse	*test_lu;

	NMG_CK_LOOPUSE(lu);
	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )  return 0;
	fu = lu->up.fu_p;
	NMG_CK_FACEUSE(fu);

	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )  return 0;

	for( RT_LIST_FOR( cur_eu, edgeuse, &lu->down_hd ) )  {
		NMG_CK_EDGEUSE(cur_eu);
		cur_eumate = cur_eu->eumate_p;
		NMG_CK_EDGEUSE(cur_eumate);
		cur_vu = cur_eu->vu_p;
		NMG_CK_VERTEXUSE(cur_vu);
		cur_v = cur_vu->v_p;
		NMG_CK_VERTEX(cur_v);

		next_vu = cur_eumate->vu_p;
		NMG_CK_VERTEXUSE(next_vu);
		next_v = next_vu->v_p;
		NMG_CK_VERTEX(next_v);
		/* XXX It might be more efficient to walk the radial list */
		/* See if the next vertex has an edge pointing back to cur_v */
		for( RT_LIST_FOR( test_vu, vertexuse, &next_v->vu_hd ) )  {
			if( *test_vu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
			test_eu = test_vu->up.eu_p;
			NMG_CK_EDGEUSE(test_eu);
			if( test_eu == cur_eu )  continue;	/* skip self */
			if( test_eu == cur_eumate )  continue;	/* skip mates */
			if( *test_eu->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
			test_lu = test_eu->up.lu_p;
			if( test_lu != lu )  continue;
			/* Check departing edgeuse's NEXT vertex */
			if( test_eu->eumate_p->vu_p->v_p == cur_v )  goto match;
		}
		/* No path back, this can't be a crack, abort */
		return 0;
		
		/* One edgeuse matched, all the others have to as well */
match:		;
	}
	return 1;
}

/*
 *			N M G _ L O O P _ I S _ C C W
 *
 *  Returns -
 *	+1	Loop is CCW, should be exterior loop.
 *	-1	Loop is CW, should be interior loop.
 *	 0	Unable to tell, error.
 */
int
nmg_loop_is_ccw( lu, norm, tol )
struct loopuse	*lu;
CONST plane_t	norm;
CONST struct rt_tol	*tol;
{
	vect_t		edge1, edge2;
	vect_t		left;
	struct edgeuse	*eu;
	struct edgeuse	*next_eu;
	struct vertexuse *this_vu, *next_vu, *third_vu;
	fastf_t		theta = 0;
	fastf_t		x,y;
	fastf_t		rad;

	NMG_CK_LOOPUSE(lu);
	RT_CK_TOL(tol);
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )  return 0;

	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		next_eu = RT_LIST_PNEXT_CIRC( edgeuse, eu );
		this_vu = eu->vu_p;
		next_vu = eu->eumate_p->vu_p;
		third_vu = next_eu->eumate_p->vu_p;

		/* Skip topological 0-length edges */
		if( this_vu->v_p == next_vu->v_p )  continue;
		if( next_vu->v_p == third_vu->v_p )  continue;

		/* Skip edges with calculated edge lengths near 0 */
		VSUB2( edge1, next_vu->v_p->vg_p->coord, this_vu->v_p->vg_p->coord );
		if( MAGSQ(edge1) < tol->dist_sq )  continue;
		VSUB2( edge2, third_vu->v_p->vg_p->coord, next_vu->v_p->vg_p->coord );
		if( MAGSQ(edge2) < tol->dist_sq )  continue;
		VUNITIZE(edge1);
		VUNITIZE(edge2);

		/* Compute (loop)inward pointing "left" vector */
		VCROSS( left, norm, edge1 );
		y = VDOT( edge2, left );
		x = VDOT( edge2, edge1 );
		rad = atan2( y, x );
#if 0
VPRINT("vu1", this_vu->v_p->vg_p->coord);
VPRINT("vu2", next_vu->v_p->vg_p->coord);
VPRINT("edge1", edge1);
VPRINT("edge2", edge2);
VPRINT("left", left);
rt_log("atan2(%g,%g) = %g\n", y, x, rad);
#endif
		theta += rad;
	}
#if 0
	rt_log(" theta = %g (%g)\n", theta, theta / rt_twopi );
#endif
nmg_face_lu_plot( lu, this_vu, this_vu );
nmg_face_lu_plot( lu->lumate_p, this_vu, this_vu );

	rad = theta * rt_inv2pi;
	x = rad-1;
	/* Value is in radians, tolerance here is 1% */
	if( NEAR_ZERO( x, 0.05 ) )  {
		/* theta = two pi, loop is CCW */
		return 1;
	}
	x = rad + 1;
	if( NEAR_ZERO( x, 0.05 ) )  {
		/* theta = -two pi, loop is CW */
		return -1;
	}
	rt_log("nmg_loop_is_ccw(x%x):  unable to determine CW/CCW, theta=%g (%g)\n",
		theta, rad );
	return 0;
}

/*
 *			N M G _ L U _ R E O R I E N T
 *
 *  Based upon a geometric calculation, reorient a loop and it's mate,
 *  if the stored orientation differs from the geometric one.
 */
void
nmg_lu_reorient( lu, norm, tol )
struct loopuse	*lu;
CONST plane_t		norm;
CONST struct rt_tol	*tol;
{
	int	ccw;
	int	geom_orient;

	NMG_CK_LOOPUSE(lu);
	RT_CK_TOL(tol);

	ccw = nmg_loop_is_ccw( lu, norm, tol );
	if( ccw == 0 )  {
		rt_log("nmg_lu_reorient:  unable to determine orientation from geometry\n");
		/* rt_bomb("nmg_lu_reorient"); */
		return;
	}
	if( ccw > 0 )  {
		geom_orient = OT_SAME;	/* same as face */
	} else {
		geom_orient = OT_OPPOSITE;
	}

	if( lu->orientation == geom_orient )  return;
	rt_log("nmg_lu_reorient(x%x):  changing loop orientation from %s to %s\n",
		lu, nmg_orientation(lu->orientation), nmg_orientation(geom_orient) );

	/* Something more may need to be done.  Edges? */
	lu->orientation = geom_orient;
	lu->lumate_p->orientation = geom_orient;
}

/*
 *
d2105 1
@


10.53
log
@Oops, put bzero() in wrong place, compensate.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.52 93/03/17 05:03:28 mike Exp Locker: mike $ (BRL)";
d476 1
a476 1
		if( MAGSQ(heading) < SMALL_FASTF )  rt_bomb("null heading\n");
d491 1
a491 1
	if( MAGSQ(heading) < SMALL_FASTF )  rt_bomb("null heading 2\n");
d2436 1
a2436 1
		rt_bomb("zappo");
@


10.52
log
@Added code to reverse coincident vertexuse order when ray state=IN.
It's commented out for now, until further testing can be done.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.51 93/03/17 04:47:24 mike Exp Locker: mike $ (BRL)";
a1503 1
	rs1.tol = rs2.tol = tol;
d1549 1
d2378 1
@


10.51
log
@Fixed "nmg_face_state_transition: prev_vu->up is not an edge"
problem by continuing search for edge further back along ray.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.50 93/03/15 21:12:15 mike Exp Locker: mike $ (BRL)";
d1210 1
d1225 9
a1233 2
	for( i=0; i < nvu; i++ )  {
		rs->vu[start+i] = vs[i].vu;
d1235 13
d1250 1
d1275 1
d1406 3
@


10.50
log
@Now distinguish between ACTION_NONE and ACTION_NONE_OPTIM.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.49 93/03/13 01:47:11 mike Exp Locker: mike $ (BRL)";
d54 1
a54 1
static char *nmg_state_names[] = {
d118 24
a849 47
#if 0
	if( a->loop_index == b->loop_index )  {
		/* Within a loop, sort by vu sequence number */
		if( a->seq < b->seq )  A_WINS;
		if( a->seq == b->seq )  AB_EQUAL;
		B_WINS;
	}
#endif
#if 0
	/* Between two loops each with a single vertex, use min angle */
	/* This works, but is the "very old way".  Should use dot products. */
	if( a->lsp->n_vu_in_loop <= 1 && b->lsp->n_vu_in_loop <= 1 )  {
		diff = a->in_vu_angle - b->in_vu_angle;
		if( diff < 0 )  A_WINS;
		if( diff == 0 )  {
			/* Gak, this really means trouble! */
			rt_log("nmg_face_vu_compare(): two loops (single vertex) have same in_vu_angle%g?\n",
				a->in_vu_angle);
			AB_EQUAL;
		}
		B_WINS;
	}
#endif

#if 0
	/* Between loops, sort by minimum dot product of the loops */
/* XXX This is wrong.  Test13.r shows how */
	/* The intermediate old way */
	diff = a->lsp->min_dot - b->lsp->min_dot;
	if( NEAR_ZERO( diff, RT_DOT_TOL) )  {
		/*
		 *  The dot product is the same, so loop edges are parallel.
		 *  Take minimum CCW angle first.
		 */
		diff = a->in_vu_angle - b->in_vu_angle;
		if( diff < 0 )  A_WINS;	/* A ang < B ang */
		if( diff == 0 )  {
			/* Gak, this really means trouble! */
			rt_log("nmg_face_vu_compare(): two loops have same min_dot %g, in_vu_angle%g?\n",
				a->lsp->min_dot, a->in_vu_angle);
			AB_EQUAL;
		}
		B_WINS;			/* A ang > B ang */
	}
	if( diff < 0 )  A_WINS;		/* A dot < B dot */
	B_WINS;				/* A dot > B dot */
#else
a939 1
#endif
a1695 19
#define NMG_ACTION_ERROR		0
#define NMG_ACTION_NONE			1
#define NMG_ACTION_NONE_OPTIM		2
#define NMG_ACTION_VFY_EXT		3
#define NMG_ACTION_VFY_MULTI		4
#define NMG_ACTION_LONE_V_ESPLIT	5
#define NMG_ACTION_LONE_V_JAUNT		6
#define NMG_ACTION_CUTJOIN		7
static char *action_names[] = {
	"*ERROR*",
	"-none-",
	"none(optim)",
	"VFY_EXT",
	"VFY_MULTI",
	"ESPLIT",
	"JAUNT",
	"CUTJOIN",
	"*TOOBIG*"
};
d1840 1
d1889 2
a1890 1
	if( other_rs_state == NMG_STATE_OUT && action != NMG_ACTION_ERROR )  {
d2001 4
d2008 9
a2016 7
		prev_vu = rs->vu[pos-1];
		NMG_CK_VERTEXUSE(prev_vu);
		prev_lu = nmg_lu_of_vu( prev_vu );
		/* lu is lone vert loop; l_p is distinct from prev_lu->l_p */
/* XXX sometimes up is an lu */
/* Different self-loops, not near each other */
		if( *prev_vu->up.magic_p != NMG_EDGEUSE_MAGIC )  {
d2019 2
a2020 2
			nmg_pr_vu(rs->vu[pos], "cur  ");
			rt_bomb("nmg_face_state_transition: prev_vu->up is not an edge\n");
d2022 1
d2025 1
a2025 1
		e_assessment = nmg_assess_eu( eu, 1, rs, pos-1 );	/* forw */
d2029 1
a2029 1
			e_assessment = nmg_assess_eu( eu, 0, rs, pos-1 ); /*rev*/
d2039 2
a2040 3
		(void)nmg_ebreak( vu->v_p, eu );
		/* Update vu table with new value */
		rs->vu[pos] = RT_LIST_PNEXT_CIRC(edgeuse, eu)->vu_p;
@


10.49
log
@Expanded tables.  No bug there, it was the cutting optimization
that was a bit too agressive.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.48 93/03/10 22:29:16 mike Exp Locker: mike $ (BRL)";
d129 2
a130 1
	int			state;
d1722 6
a1727 5
#define NMG_ACTION_VFY_EXT		2
#define NMG_ACTION_VFY_MULTI		3
#define NMG_ACTION_LONE_V_ESPLIT	4
#define NMG_ACTION_LONE_V_JAUNT		5
#define NMG_ACTION_CUTJOIN		6
d1731 1
d1848 13
d1920 1
d1932 1
a1932 1
		action = NMG_ACTION_NONE;
d2006 1
@


10.48
log
@Calling nmg_vshell() or nmg_vfu() all the time is *very* expensive.
Made nearly all calls conditionally compiled on PARANOID_VERIFY
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.47 93/03/08 21:42:41 mike Exp Locker: mike $ (BRL)";
d70 1
a70 1
#define NMG_V_ASSESSMENT_COMBINE(_p,_n)	(((_p)<<2)|(_n))
d508 1
a508 1
	ass = NMG_V_ASSESSMENT_COMBINE( prev_ass, next_ass );
d1139 1
a1139 1
		if( ass == NMG_V_ASSESSMENT_COMBINE(NMG_E_ASSESSMENT_ON_FORW, NMG_E_ASSESSMENT_LEFT) )
d1141 1
a1141 1
		else if( ass == NMG_V_ASSESSMENT_COMBINE(NMG_E_ASSESSMENT_LEFT, NMG_E_ASSESSMENT_ON_REV) )
d1701 17
d1738 1
d1744 17
a1760 17
	{ /* LEFT,LEFT */	NMG_STATE_OUT,		NMG_ACTION_NONE },
	{ /* LEFT,RIGHT */	NMG_STATE_IN,		NMG_ACTION_VFY_EXT },
	{ /* LEFT,ON_FORW */	NMG_STATE_ON_L,		NMG_ACTION_VFY_EXT },
	{ /* LEFT,ON_REV */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,LEFT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,RIGHT */	NMG_STATE_OUT,		NMG_ACTION_NONE },
	{ /* RIGHT,ON_FORW */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,ON_REV */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_FORW,LEFT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_FORW,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_FORW,ON_FORW */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_FORW,ON_REV */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_REV,LEFT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_REV,RIGHT */	NMG_STATE_ON_R,		NMG_ACTION_VFY_EXT },
	{ /* ON_REV,ON_FORW */	NMG_STATE_IN,		NMG_ACTION_VFY_EXT },
	{ /* ON_REV,ON_REV */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LONE */		NMG_STATE_OUT,		NMG_ACTION_NONE }
d1764 17
a1780 17
	{ /* LEFT,LEFT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LEFT,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LEFT,ON_FORW */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LEFT,ON_REV */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,LEFT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,RIGHT */	NMG_STATE_ON_L,		NMG_ACTION_NONE },
	{ /* RIGHT,ON_FORW */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,ON_REV */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_FORW,LEFT */	NMG_STATE_OUT,		NMG_ACTION_NONE },
	{ /* ON_FORW,RIGHT */	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ /* ON_FORW,ON_FORW */	NMG_STATE_ON_L,		NMG_ACTION_NONE },
	{ /* ON_FORW,ON_REV */	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ /* ON_REV,LEFT */	NMG_STATE_IN,		NMG_ACTION_VFY_MULTI },
	{ /* ON_REV,RIGHT */	NMG_STATE_ON_B,		NMG_ACTION_VFY_EXT },
	{ /* ON_REV,ON_FORW */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_REV,ON_REV */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LONE */		NMG_STATE_ON_L,		NMG_ACTION_LONE_V_ESPLIT }
d1784 17
a1800 17
	{ /* LEFT,LEFT */	NMG_STATE_ON_R,		NMG_ACTION_NONE },
	{ /* LEFT,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LEFT,ON_FORW */	NMG_STATE_ON_B,		NMG_ACTION_NONE },
	{ /* LEFT,ON_REV */	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ /* RIGHT,LEFT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,ON_FORW */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,ON_REV */	NMG_STATE_OUT,		NMG_ACTION_NONE },
	{ /* ON_FORW,LEFT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_FORW,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_FORW,ON_FORW */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_FORW,ON_REV */	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ /* ON_REV,LEFT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_REV,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_REV,ON_FORW */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_REV,ON_REV */	NMG_STATE_ON_R,		NMG_ACTION_NONE },
	{ /* LONE */		NMG_STATE_ON_R,		NMG_ACTION_LONE_V_ESPLIT }
d1802 1
d1804 17
a1820 17
	{ /* LEFT,LEFT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LEFT,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LEFT,ON_FORW */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LEFT,ON_REV */	NMG_STATE_IN,		NMG_ACTION_VFY_MULTI },
	{ /* RIGHT,LEFT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,ON_FORW */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,ON_REV */	NMG_STATE_ON_L,		NMG_ACTION_NONE },
	{ /* ON_FORW,LEFT */	NMG_STATE_ON_R,		NMG_ACTION_NONE },
	{ /* ON_FORW,RIGHT */	NMG_STATE_IN,		NMG_ACTION_VFY_MULTI },
	{ /* ON_FORW,ON_FORW */	NMG_STATE_ON_B,		NMG_ACTION_VFY_MULTI },
	{ /* ON_FORW,ON_REV */	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ /* ON_REV,LEFT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_REV,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_REV,ON_FORW */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_REV,ON_REV */	NMG_STATE_ON_B,		NMG_ACTION_VFY_MULTI },
	{ /* LONE */		NMG_STATE_ON_B,		NMG_ACTION_LONE_V_ESPLIT }
d1824 17
a1840 17
	{ /* LEFT,LEFT */	NMG_STATE_IN,		NMG_ACTION_CUTJOIN },
	{ /* LEFT,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LEFT,ON_FORW */	NMG_STATE_ON_R,		NMG_ACTION_CUTJOIN },
	{ /* LEFT,ON_REV */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,LEFT */	NMG_STATE_OUT,		NMG_ACTION_CUTJOIN },
	{ /* RIGHT,RIGHT */	NMG_STATE_IN,		NMG_ACTION_CUTJOIN },
	{ /* RIGHT,ON_FORW */	NMG_STATE_ON_L,		NMG_ACTION_CUTJOIN },
	{ /* RIGHT,ON_REV */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_FORW,LEFT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_FORW,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_FORW,ON_FORW */	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ /* ON_FORW,ON_REV */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_REV,LEFT */	NMG_STATE_ON_R,		NMG_ACTION_CUTJOIN },
	{ /* ON_REV,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON_REV,ON_FORW */	NMG_STATE_ON_B,		NMG_ACTION_CUTJOIN },
	{ /* ON_REV,ON_REV */	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ /* LONE */		NMG_STATE_IN,		NMG_ACTION_LONE_V_JAUNT }
d1898 4
d1913 1
d2032 1
d2035 2
@


10.47
log
@Added lots of error checking
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.46 93/02/25 04:27:38 mike Exp Locker: mike $ (BRL)";
d1849 1
d1852 1
d1931 6
a1936 1
		rt_log("nmg_face_state_transition(vu x%x, pos=%d)\n\told=%s, assessed=%s, new=%s, action=%s\n",
d1962 2
a1963 1
		rt_bomb("nmg_face_state_transition: got action=ERROR\n");
d2094 1
d2096 1
a2096 4
				rt_log("nmg_cut_loop(prev_vu=x%x, vu=x%x)\n", prev_vu, vu);
			if(is_crack = nmg_loop_is_a_crack(lu))  {
				rt_log("ABOUT TO CUT A CRACK!\n");
			} else rt_log("About to cut a non-crack\n");
a2121 4
#if 0
		/* XXX This checking routine does not work */
		nmg_vmodel(nmg_find_model(&vu->l.magic));
#endif
d2171 2
a2172 1
	/* XXX Verify both faces are still OK */
d2175 1
@


10.46
log
@Fixed NEAR_ZERO bugs in nmg_wedge_class() and nmg_compare_2_wedges().
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.45 93/02/25 03:51:44 mike Exp Locker: mike $ (BRL)";
d1849 3
d2168 4
@


10.45
log
@Added some extra table elements.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.44 93/02/19 04:46:21 mike Exp Locker: mike $ (BRL)";
d553 5
d569 1
d576 10
a585 3
		if( NEAR_ZERO( hb, .01 ) )  return WEDGE_CROSS;
		if( hb < 0 )  return WEDGE_RIGHT;
		return WEDGE_LEFT;
d589 6
a594 2
		if( hb <= 0 )  return WEDGE_RIGHT;
		return WEDGE_CROSS;
d596 19
a614 3
	/* hb > 0, A is to the left */
	if( hb >= 0 )  return WEDGE_LEFT;
	return WEDGE_CROSS;
d651 10
d707 3
a709 1
	if(rt_g.NMG_debug&DEBUG_VU_SORT)
d712 1
@


10.44
log
@Changed calling sequence of nmg_ebreak() and nmg_esplit() to
use edgeuse pointers, rather than edge pointers.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.43 93/02/18 06:12:07 mike Exp Locker: mike $ (BRL)";
d76 1
a76 1
static char *nmg_v_assessment_names[17] = {
d93 16
a108 1
	"LONE_V"
d111 1
a111 1
static char *nmg_e_assessment_names[4] = {
@


10.43
log
@Added more debugging
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.42 93/02/10 03:03:56 mike Exp Locker: mike $ (BRL)";
d1956 1
a1956 1
		(void)nmg_ebreak( vu->v_p, eu->e_p );
@


10.42
log
@Added a tad more debugging on fatal errors
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.41 93/01/22 22:06:42 mike Exp Locker: mike $ (BRL)";
d1353 9
a1361 1
			if( rs1->vu[cur1]->v_p != rs2->vu[cur2]->v_p )
d1363 1
@


10.41
log
@Lone vert jaunt error checking was too severe.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.40 93/01/20 21:52:14 mike Exp $ (BRL)";
d405 1
d411 1
@


10.40
log
@Added special case for LEFT & ON combos,
so that the ON edge has angle "360" rather than "0".
Left angles have to sort high to low, and on_forw,left and
left,on_rev are the highest angles.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.39 93/01/20 15:26:58 mike Exp Locker: mike $ (BRL)";
d1923 6
a1928 3
		if( prev_lu->l_p != lu->l_p )  rt_bomb("nmg_face_state_transition: prev_vu not on same loop\n");
/* XXX sometimes up is a vu */
		if( *prev_vu->up.magic_p != NMG_EDGEUSE_MAGIC )  rt_bomb("nmg_face_state_transition: prev_vu->up is not an edge\n");
@


10.39
log
@One list may be exhausted before the other one, resulting in
bad "ending" states being detected.  Added code to press on.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.38 92/12/16 06:30:27 mike Exp Locker: mike $ (BRL)";
d1074 7
@


10.38
log
@Debug
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.37 1992/12/14 23:01:18 mike Exp mike $ (BRL)";
d1351 11
d1366 2
d1376 1
a1376 1
		rt_log("nmg_face_combine() bad ending state\n");
@


10.37
log
@Die with a more intelligible message, anyway.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.36 92/11/16 23:24:54 mike Exp Locker: mike $ (BRL)";
d1356 6
a1361 4
		/* Drop a plot file */
		rt_g.NMG_debug |= DEBUG_VU_SORT|DEBUG_FCUT|DEBUG_PLOTEM;
		nmg_pl_comb_fu( 0, 1, rs1->fu1 );
		nmg_pl_comb_fu( 0, 2, rs1->fu2 );
d1363 1
d1838 1
a1838 1
	     if( rt_g.NMG_debug )  {
d1903 1
a1903 1
		if( prev_lu != lu )  rt_bomb("nmg_face_state_transition: prev_vu not on same loop\n");
d1905 1
a1905 1
		if( *prev_vu->up.magic_p != NMG_MAGIC_EDGEUSE )  rt_bomb("nmg_face_state_transition: prev_vu->up is not an edge\n");
@


10.36
log
@Moved some declarations to raytrace.h
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.35 92/11/11 00:07:13 mike Exp Locker: mike $ (BRL)";
d1899 4
@


10.35
log
@Improved error logging
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.34 92/10/20 00:43:51 mike Exp Locker: mike $ (BRL)";
d2222 1
a2222 1
plane_t		norm;
@


10.34
log
@Beginnings of a working wedge-based coincident vertexuse sorting algorithm.
The hard parts still remain to be finished.
Tests 1,2,4-12 work, 3 and 13 fail (maybe not due to this).
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.33 92/10/16 00:09:52 mike Exp Locker: mike $ (BRL)";
d725 4
a728 3
rt_log("nmg_find_vu_in_wedge(start=%d,end=%d, lo=%g, hi=%g) candidate=%d\n",
start, end, lo_ang, hi_ang,
candidate);
d985 4
d990 1
a990 1
static void
d1003 1
a1003 1
	if( this_wedge <= -1 )  return;	/* No wedges to process */
d1010 1
d1790 1
a1790 1
	if( other_rs_state == NMG_STATE_OUT )  {
d1835 1
a1835 1
#if 0	/* XXX turn this on only for debugging */
d1855 1
a1855 1
#endif
@


10.33
log
@A start on the new wedge-based vu sorting.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.32 92/10/07 06:51:35 mike Exp Locker: mike $ (BRL)";
d521 1
d736 5
d746 3
d750 3
a752 3
nmg_face_vu_compare( a, b )
CONST genptr_t	a;
CONST genptr_t	b;
d754 2
a755 2
	register CONST struct nmg_vu_stuff *va = (CONST struct nmg_vu_stuff *)a;
	register CONST struct nmg_vu_stuff *vb = (CONST struct nmg_vu_stuff *)b;
d757 3
d761 2
a762 1
	if( va->loop_index == vb->loop_index )  {
d764 3
a766 3
		if( va->seq < vb->seq )  return -1;
		if( va->seq == vb->seq )  return 0;
		return 1;
d768 1
d772 3
a774 3
	if( va->lsp->n_vu_in_loop <= 1 && vb->lsp->n_vu_in_loop <= 1 )  {
		diff = va->in_vu_angle - vb->in_vu_angle;
		if( diff < 0 )  return -1;
d778 2
a779 2
				va->in_vu_angle);
			return 0;
d781 1
a781 1
		return 1;
d785 1
a785 1
#if 1
d789 1
a789 1
	diff = va->lsp->min_dot - vb->lsp->min_dot;
d795 2
a796 2
		diff = va->in_vu_angle - vb->in_vu_angle;
		if( diff < 0 )  return -1;	/* A ang < B ang */
d800 2
a801 2
				va->lsp->min_dot, va->in_vu_angle);
			return 0;
d803 1
a803 1
		return 1;			/* A ang > B ang */
d805 2
a806 2
	if( diff < 0 )  return -1;		/* A dot < B dot */
	return 1;				/* A dot > B dot */
d808 2
d811 1
a811 3
	if( va->wedge_class == vb->wedge_class &&
	    NEAR_ZERO( va->lo_ang - vb->lo_ang, 0.001 ) &&
	    NEAR_ZERO( va->hi_ang - vb->hi_ang, 0.001 ) ) {
d814 6
d822 2
a823 2
		diff = va->in_vu_angle - vb->in_vu_angle;
		if( diff < 0 )  return -1;
d827 2
a828 2
				va->in_vu_angle);
			return 0;
d830 1
a830 1
		return 1;
d832 1
a832 3
/* XXX draw all 6 cases, and re-check this */
/* XXX should NOT have two NEAR_ZERO checks for any case. */
	switch( va->wedge_class )  {
d834 1
a834 1
		switch( vb->wedge_class )  {
d836 7
a842 3
			if( NEAR_ZERO( va->lo_ang - vb->lo_ang, 0.001 ) )  goto tie_break;
			if( va->lo_ang > vb->lo_ang )  return -1; /* A */
			return 1;	/* B */
d844 6
a849 4
			if( NEAR_ZERO( va->lo_ang - vb->hi_ang, 0.001 ) )  goto tie_break;
			if( NEAR_ZERO( va->hi_ang - vb->hi_ang, 0.001 ) )  goto tie_break;
			if( va->hi_ang > vb->hi_ang )  return -1; /* A */
			return 1;	/* B */
d851 3
a853 3
			diff = 360 - va->lo_ang;/* CW version of left angle */
			if( diff < vb->hi_ang )  return -1; /* A */
			return 1;	/* B */
d856 1
a856 1
		switch( vb->wedge_class )  {
d858 5
a862 4
			if( NEAR_ZERO( va->hi_ang - vb->lo_ang, 0.001 ) )  goto tie_break;
			if( NEAR_ZERO( va->hi_ang - vb->hi_ang, 0.001 ) )  goto tie_break;
			if( va->hi_ang > vb->hi_ang )  return -1; /* A */
			return 1;	/* B */
d864 6
a869 2
			if( va->lo_ang < vb->lo_ang )  return -1; /* A */
			return 1;	/* B */
d871 5
a875 4
			if( NEAR_ZERO( va->lo_ang - vb->lo_ang, 0.001 ) )  goto tie_break;
			if( NEAR_ZERO( va->lo_ang - vb->hi_ang, 0.001 ) )  goto tie_break;
			if( va->lo_ang < vb->lo_ang )  return -1; /* A */
			return 1;	/* B */
d878 1
a878 1
		switch( vb->wedge_class )  {
d880 3
a882 3
			diff = 360 - vb->lo_ang;/* CW version of left angle */
			if( va->lo_ang < diff )  return -1; /* A */
			return 1;	/* B */
d884 5
a888 4
			if( NEAR_ZERO( va->lo_ang - vb->lo_ang, 0.001 ) )  goto tie_break;
			if( NEAR_ZERO( va->hi_ang - vb->lo_ang, 0.001 ) )  goto tie_break;
			if( va->lo_ang < vb->lo_ang )  return -1; /* A */
			return 1;	/* B */
d890 6
a895 3
			if( NEAR_ZERO( va->lo_ang - vb->lo_ang, 0.001 ) )  goto tie_break;
			if( va->lo_ang < vb->lo_ang )  return -1; /* A */
			return 1;	/* B */
d899 9
d1069 1
a1069 1
		if(rt_g.NMG_debug&DEBUG_VU_SORT) rt_log("nmg_wedge_class = %d %s\n", vs[nvu].wedge_class, nmg_wedgeclass_string[vs[nvu].wedge_class+1]);
d1165 1
a1165 1
				nmg_wedgeclass_string[vs[i].wedge_class+1],
@


10.32
log
@Modified printing statements.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.31 92/10/06 23:12:52 mike Exp Locker: mike $ (BRL)";
d506 2
d509 1
d518 9
d528 203
d735 4
d757 1
a757 1
	/* This works, but is the "old way".  Should use dot products. */
d771 1
d774 1
d793 72
d939 26
d1025 11
d1076 2
a1077 4
		for( eu = RT_LIST_PNEXT_CIRC(edgeuse,first_eu);
		     eu != first_eu;
		     eu = RT_LIST_PNEXT_CIRC(edgeuse,eu)
		)  {
d1081 4
a1084 3
				if( vs[i].vu != vu )  continue;
				vs[i].seq = seq++;
				break;
d1086 2
a1087 1
		}
d1090 7
a1096 2
#if 0
/**
a1097 1
**/
a1104 7
		rt_log("Vertexuse table:\n");
		for( i=0; i < nvu; i++ )  {
			rt_log("  vu=x%x, loop_ind=%d, in ang=%g, out ang=%g, min_vu_dot=%g, seq=%d\n",
				vs[i].vu, vs[i].loop_index,
				vs[i].in_vu_angle, vs[i].out_vu_angle,
				vs[i].min_vu_dot, vs[i].seq );
		}
a1105 1
#endif
d1118 1
a1118 1
			rt_log("  vu=x%x, loop_ind=%d, in ang=%g, out ang=%g, min_vu_dot=%g, seq=%d\n",
d1121 3
a1123 1
				vs[i].min_vu_dot, vs[i].seq );
@


10.31
log
@DEBUG_COMBINE -> DEBUG_FCUT
Added DEBUG_VU_SORT.
Added second angle measurement at vu.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.30 92/10/06 18:28:57 mike Exp Locker: mike $ (BRL)";
d366 1
a366 1
		rt_log("ang=%g (%e), vec=(%g,%g,%g)\n", ang*rt_radtodeg, ang*rt_radtodeg, V3ARGS(vec) );
d773 1
a773 1
			rt_log("  vu=x%x, loop_index=%d, in_vu_angle=%g, min_vu_dot=%g, seq=%d\n",
d775 2
a776 1
				vs[i].in_vu_angle, vs[i].min_vu_dot, vs[i].seq );
d792 1
a792 1
			rt_log("  vu=x%x, loop_index=%d, in_vu_angle=%g, min_vu_dot=%g, seq=%d\n",
d794 2
a795 1
				vs[i].in_vu_angle, vs[i].min_vu_dot, vs[i].seq );
@


10.30
log
@Added comments
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.29 92/08/07 00:28:23 mike Exp Locker: mike $ (BRL)";
d261 1
a261 1
nmg_vu_angle_measure( vu, x_dir, y_dir, assessment )
d266 1
d273 1
a273 1
	int		entry_ass;
d284 10
a293 5
	entry_ass = NMG_V_ASSESSMENT_PREV( assessment );
	if( entry_ass == NMG_E_ASSESSMENT_ON_FORW )  {
		if(rt_g.NMG_debug&DEBUG_COMBINE)
			rt_log("nmg_vu_angle_measure:  NMG_E_ASSESSMENT_ON_FORW, ang=0\n");
		return 0;		/* zero angle */
d295 6
a300 4
	if( entry_ass == NMG_E_ASSESSMENT_ON_REV )  {
		if(rt_g.NMG_debug&DEBUG_COMBINE)
			rt_log("nmg_vu_angle_measure:  NMG_E_ASSESSMENT_ON_FORW, ang=180\n");
		return rt_pi;		/* 180 degrees */
d310 2
a311 1
		prev_eu = RT_LIST_PLAST_CIRC( edgeuse, prev_eu );
d313 1
a313 1
			if(rt_g.NMG_debug&DEBUG_COMBINE)
d320 2
a321 1
	/* Get vector which represents the inbound edge, but pointing away from vert. */
d325 1
a325 1
	if(rt_g.NMG_debug&DEBUG_COMBINE)
d334 1
a334 1
		if( entry_ass == NMG_E_ASSESSMENT_RIGHT )  {
d341 1
a341 1
		if( entry_ass == NMG_E_ASSESSMENT_RIGHT )  {
d353 1
a353 1
		if( entry_ass != NMG_E_ASSESSMENT_LEFT )  {
d356 1
a356 1
				nmg_e_assessment_names[entry_ass] );
d359 1
a359 1
		if( entry_ass != NMG_E_ASSESSMENT_RIGHT )  {
d362 1
a362 1
				nmg_e_assessment_names[entry_ass] );
d365 1
a365 1
	if(rt_g.NMG_debug&DEBUG_COMBINE)
d422 1
a422 1
		if(rt_g.NMG_debug&DEBUG_COMBINE)
d456 1
a456 1
	if(rt_g.NMG_debug&DEBUG_COMBINE)  {
d492 1
a492 1
	if(rt_g.NMG_debug&DEBUG_COMBINE)  {
d503 2
a504 1
	fastf_t			vu_angle;
d540 1
a540 1
		diff = va->vu_angle - vb->vu_angle;
d544 2
a545 2
			rt_log("nmg_face_vu_compare(): two loops (single vertex) have same vu_angle%g?\n",
				va->vu_angle);
d560 1
a560 1
		diff = va->vu_angle - vb->vu_angle;
d564 2
a565 2
			rt_log("nmg_face_vu_compare(): two loops have same min_dot %g, vu_angle%g?\n",
				va->lsp->min_dot, va->vu_angle);
d667 1
a667 1
	if(rt_g.NMG_debug&DEBUG_COMBINE)
d681 1
a681 1
		if(rt_g.NMG_debug&DEBUG_COMBINE)
d691 1
a691 1
				return start+1;
d702 4
a705 2
		vs[nvu].vu_angle = nmg_vu_angle_measure( rs->vu[i],
			rs->ang_x_dir, rs->ang_y_dir, ass ) * rt_radtodeg;
d762 1
a762 1
	if(rt_g.NMG_debug&DEBUG_COMBINE)
d773 1
a773 1
			rt_log("  vu=x%x, loop_index=%d, vu_angle=%g, min_vu_dot=%g, seq=%d\n",
d775 1
a775 1
				vs[i].vu_angle, vs[i].min_vu_dot, vs[i].seq );
d787 1
a787 1
	if(rt_g.NMG_debug&DEBUG_COMBINE)
d791 1
a791 1
			rt_log("  vu=x%x, loop_index=%d, vu_angle=%g, min_vu_dot=%g, seq=%d\n",
d793 1
a793 1
				vs[i].vu_angle, vs[i].min_vu_dot, vs[i].seq );
d800 1
a800 1
		if(rt_g.NMG_debug&DEBUG_COMBINE)
d846 1
a846 1
	if(rt_g.NMG_debug&DEBUG_COMBINE)  {
d885 1
a885 1
		if(rt_g.NMG_debug&DEBUG_COMBINE)
d902 1
a902 1
	if(rt_g.NMG_debug&DEBUG_COMBINE)
d923 1
a923 1
	if(rt_g.NMG_debug&DEBUG_COMBINE)
d978 1
a978 1
		rt_g.NMG_debug |= DEBUG_COMBINE|DEBUG_PLOTEM;
d1016 1
a1016 1
	if(rt_g.NMG_debug&DEBUG_COMBINE)  {
d1045 1
a1045 1
	if(rt_g.NMG_debug&DEBUG_COMBINE)  {
d1416 1
a1416 1
	if(rt_g.NMG_debug&DEBUG_COMBINE)  {
d1460 1
a1460 1
		rt_g.NMG_debug |= DEBUG_COMBINE|DEBUG_PLOTEM;
d1541 1
a1541 1
		if(rt_g.NMG_debug&DEBUG_COMBINE)  {
d1575 1
a1575 1
		if(rt_g.NMG_debug&DEBUG_COMBINE)  {
d1602 1
a1602 1
			if(rt_g.NMG_debug&DEBUG_COMBINE)
d1615 1
a1615 1
			if(rt_g.NMG_debug&DEBUG_COMBINE)  {
d1628 1
a1628 1
		if(rt_g.NMG_debug&DEBUG_COMBINE)
d1675 1
a1675 1
		if(rt_g.NMG_debug&DEBUG_COMBINE)  {
@


10.29
log
@Added comments.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.28 92/08/06 20:50:55 mike Exp Locker: mike $ (BRL)";
d250 3
d311 1
a311 1
	/* Get vector which represents the inbound edge */
@


10.28
log
@Added another essential debugging print.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.27 92/08/06 00:40:14 mike Exp Locker: mike $ (BRL)";
d539 1
d547 1
a547 1
		if( diff < 0 )  return -1;
d554 1
a554 1
		return 1;
d556 2
a557 2
	if( diff < 0 )  return -1;
	return 1;
@


10.27
log
@Added more printing to nmg_stash_model_to_file(), because
first arg seems to be getting trashed on SGI.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.26 92/08/05 22:32:04 mike Exp Locker: mike $ (BRL)";
d1405 1
@


10.26
log
@Improved error logging slightly.
Moved nmg_set_lu_orientation() into a subroutine.
@
text
@d1 1
a1 1
#define PLOT_BOTH_FACES	0
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.25 92/08/05 16:16:35 mike Exp Locker: mike $ (BRL)";
d1860 1
a1860 1
CONST char	*filename;
d1869 3
d1901 1
a1901 1
	rt_log("nmg_stash_model_to_file(): wrote %s\n", filename);
@


10.25
log
@Split out nmg_stash_model_to_file()
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.24 92/07/25 07:13:34 mike Exp Locker: mike $ (BRL)";
d123 21
d869 1
a869 1
			rt_log("single vertexuse at index %d\n", cur);
d886 1
a886 1
		rt_log("vu's on list interval [%d] to [%d] equal\n", cur, j-1 );
d1002 6
d1404 1
a1404 1
		rt_log("This loopuse, before action:\n");
d1544 2
a1545 8
			NMG_CK_LOOPUSE(lu);
			if( old_state == NMG_STATE_IN )  {
				/* Interior (crack) loop */
				lu->orientation = OT_OPPOSITE;
			} else {
				/* Exterior loop */
				lu->orientation = OT_SAME;
			}
d1559 1
d1633 1
a1633 11
				NMG_CK_LOOPUSE(lu);
				NMG_CK_LOOPUSE(lu->lumate_p);
				if( old_state == NMG_STATE_IN )  {
					/* Interior (crack) loop */
					lu->orientation = OT_OPPOSITE;
					lu->lumate_p->orientation = OT_OPPOSITE;
				} else {
					/* Exterior loop */
					lu->orientation = OT_SAME;
					lu->lumate_p->orientation = OT_SAME;
				}
d1659 1
@


10.24
log
@When a "crack" loop is cut into two loops, one loop needs to be
reoriented as an interior loop.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.23 92/07/23 05:51:39 mike Exp Locker: mike $ (BRL)";
d45 2
d1430 1
a1430 29
		{
			FILE	*fp = fopen("error.g", "w");
			struct rt_external	ext;
			struct rt_db_internal	intern;
			static union record		rec;

			RT_INIT_DB_INTERNAL(&intern);
			intern.idb_type = ID_NMG;
			intern.idb_ptr = (genptr_t)nmg_find_model((long*)lu);
			RT_INIT_EXTERNAL( &ext );

			/* Scale change on export is 1.0 -- no change */
			if( rt_functab[ID_NMG].ft_export( &ext, &intern, 1.0 ) < 0 )  {
				rt_log("solid export failure\n");
				if( intern.idb_ptr )  rt_functab[ID_NMG].ft_ifree( &intern );
				db_free_external( &ext );
				rt_bomb("zappo");
			}
			rt_functab[ID_NMG].ft_ifree( &intern );
			NAMEMOVE( "error", ((union record *)ext.ext_buf)->s.s_name );

			rec.u_id = ID_IDENT;
			strcpy( rec.i.i_version, ID_VERSION );
			strcpy( rec.i.i_title, "nmg_fcut.c error dump" );
			fwrite( (char *)&rec, sizeof(rec), 1, fp );
			fwrite( ext.ext_buf, ext.ext_nbytes, 1, fp );
			fclose(fp);
			rt_log("wrote error.g\n");
		}
d1839 47
@


10.23
log
@Snapshot of work-in-progress for handling the aftermath
of cutting a "crack" loop.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.22 92/07/23 01:08:17 mike Exp Locker: mike $ (BRL)";
d1595 5
a1599 2
				nmg_loop_is_ccw( lu, fu->f_p->fg_p->N, rs->tol );
				nmg_loop_is_ccw( prev_lu, fu->f_p->fg_p->N, rs->tol );
d1746 8
d1757 1
a1757 1
CONST vect_t	norm;
d1766 2
d1793 12
a1804 1
		theta += atan2( VDOT( edge2, edge1 ), VDOT( edge2, left ) );
d1806 1
d1808 57
a1864 1
	return 1;
@


10.22
log
@Eliminated excess parameter from nmg_face_state_transition
@
text
@d1 1
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.21 92/07/22 23:35:31 mike Exp Locker: mike $ (BRL)";
a44 7
/* XXX move to raytrace.h */
RT_EXTERN(double		rt_angle_measure, (vect_t vec, vect_t x_dir,
				vect_t	y_dir));
RT_EXTERN(struct edgeuse	*nmg_eu_with_vu_in_lu, (struct loopuse *lu,
				struct vertexuse *vu));


d115 1
d848 1
d850 3
d876 1
d878 3
d904 1
d906 4
d980 3
a1172 1
nmg_pr_lu( lu1, "  ");
d1322 1
d1578 2
d1586 1
d1590 8
a1597 1
			nmg_cut_loop( prev_vu, vu );
d1635 1
d1639 1
d1643 1
d1647 1
a1647 5
			nmg_join_2loops( prev_vu, vu );
			/* update vu[pos], as it will have changed. */
			/* Must be all on one line for SGI 3d compiler */
			rs->vu[pos] = RT_LIST_PNEXT_CIRC(edgeuse,prev_vu->up.eu_p)->vu_p;
			/* XXX This should be the return from nmg_join_2loops */
d1676 108
@


10.21
log
@Works for many of the test cases, but there are oddities in the
topology that need investigation.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.20 92/07/22 22:17:24 mike Exp Locker: mike $ (BRL)";
d852 1
a852 1
		nmg_face_state_transition( rs->vu[cur], rs, cur, 0, other_rs_state );
d876 1
a876 1
		nmg_face_state_transition( rs->vu[k], rs, k, 1, other_rs_state );
d1298 1
a1298 2
nmg_face_state_transition( vu, rs, pos, multi, other_rs_state )
struct vertexuse	*vu;
d1304 1
d1318 1
@


10.20
log
@Moved plotting routines out to nmg_plot.c
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.19 92/07/22 21:45:44 mike Exp Locker: mike $ (BRL)";
d1134 1
a1134 1
	struct loopuse	*lu2;
d1159 5
d1344 1
a1344 1
#if 0
d1547 3
d1633 1
d1644 3
d1649 1
a1649 1
			nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]), rs->vu[0], rs->vu[rs->nvu-1] );
@


10.19
log
@Improved nmg_face_cutjoin() visualization, so that both participating
faces are always drawn together as a pair.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.18 92/07/22 21:37:34 mike Exp Locker: mike $ (BRL)";
d123 1
a123 1
RT_EXTERN(void			nmg_face_lu_plot, ( struct loopuse *lu, struct nmg_ray_state *rs) );
a1336 1
	/* If no loop has been entered in other face, don't do any cutting */
d1340 8
a1347 1
	/* XXX This is the new part */
d1359 1
a1359 1
		nmg_face_lu_plot(nmg_lu_of_vu(vu), rs);
d1403 1
a1403 1
		nmg_face_lu_plot(lu, rs);
d1508 1
a1508 1
			nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]), rs);
d1544 1
a1544 1
			nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]), rs);
d1571 1
a1571 1
				nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]), rs);
d1637 1
a1637 1
			nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]), rs);
a1642 121
}

/*
 *			N M G _ F A C E _ P L O T
 */
void
nmg_face_plot( fu )
struct faceuse	*fu;
{
	extern void (*nmg_vlblock_anim_upcall)();
	struct model		*m;
	struct rt_vlblock	*vbp;
	struct face_g	*fg;
	long		*tab;
	int		fancy;

	if( ! (rt_g.NMG_debug & DEBUG_PL_ANIM) )  return;

	NMG_CK_FACEUSE(fu);

	m = nmg_find_model( (long *)fu );
	NMG_CK_MODEL(m);

	/* get space for list of items processed */
	tab = (long *)rt_calloc( m->maxindex+1, sizeof(long),
		"nmg_face_plot tab[]");

	vbp = rt_vlblock_init();

	fancy = 3;	/* show both types of edgeuses */
	nmg_vlblock_fu(vbp, fu, tab, fancy );

	/* Cause animation of boolean operation as it proceeds! */
	if( nmg_vlblock_anim_upcall )  {
		/* if requested, delay 3/4 second */
		(*nmg_vlblock_anim_upcall)( vbp,
			(rt_g.NMG_debug&DEBUG_PL_SLOW) ? 750000 : 0,
			0 );
	} else {
		rt_log("null nmg_vlblock_anim_upcall, no animation\n");
	}
	rt_vlblock_free(vbp);
	rt_free( (char *)tab, "nmg_face_plot tab[]" );

}

/*
 *			N M G _ F A C E _ P L O T
 *
 *  Just like nmg_face_plot, except it draws two faces each iteration.
 */
void
nmg_2face_plot( fu1, fu2 )
struct faceuse	*fu1, *fu2;
{
	extern void (*nmg_vlblock_anim_upcall)();
	struct model		*m;
	struct rt_vlblock	*vbp;
	struct face_g	*fg;
	long		*tab;
	int		fancy;

	if( ! (rt_g.NMG_debug & DEBUG_PL_ANIM) )  return;

	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);

	m = nmg_find_model( (long *)fu1 );
	NMG_CK_MODEL(m);

	/* get space for list of items processed */
	tab = (long *)rt_calloc( m->maxindex+1, sizeof(long),
		"nmg_2face_plot tab[]");

	vbp = rt_vlblock_init();

	fancy = 3;	/* show both types of edgeuses */
	nmg_vlblock_fu(vbp, fu1, tab, fancy );
	nmg_vlblock_fu(vbp, fu2, tab, fancy );

	/* Cause animation of boolean operation as it proceeds! */
	if( nmg_vlblock_anim_upcall )  {
		/* if requested, delay 3/4 second */
		(*nmg_vlblock_anim_upcall)( vbp,
			(rt_g.NMG_debug&DEBUG_PL_SLOW) ? 750000 : 0,
			0 );
	} else {
		rt_log("null nmg_vlblock_anim_upcall, no animation\n");
	}
	rt_vlblock_free(vbp);
	rt_free( (char *)tab, "nmg_2face_plot tab[]" );

}

void
nmg_face_lu_plot( lu, rs )
struct loopuse		*lu;
struct nmg_ray_state	*rs;
{
	FILE	*fp;
	struct model	*m;
	long		*b;
	char		buf[128];
	static int	num = 0;

	if(!(rt_g.NMG_debug&DEBUG_PLOTEM)) return;

	NMG_CK_LOOPUSE(lu);
	m = nmg_find_model((long *)lu);
	sprintf(buf, "loop%d.pl", num++ );

	fp = fopen(buf, "w");
	b = (long *)rt_calloc( m->maxindex, sizeof(long), "nmg_face_lu_plot flag[]" );
	nmg_pl_lu(fp, lu, b, 255, 0, 0);
	/* A yellow line for the ray */
	pl_color(fp, 255, 255, 0);
	pdv_3line(fp, rs->vu[0]->v_p->vg_p->coord,
		rs->vu[rs->nvu-1]->v_p->vg_p->coord );
	fclose(fp);
	rt_log("wrote %s\n", buf);
	rt_free( (char *)b, "nmg_face_lu_plot flag[]" );
@


10.18
log
@This version works for Test1.r and Test2.r with the new optimization
turned on.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.17 92/07/22 20:28:13 mike Exp Locker: mike $ (BRL)";
d853 1
a853 1
		nmg_face_plot( rs->fu1 );
d877 1
a877 1
		nmg_face_plot( rs->fu1 );
d901 1
a901 2
	nmg_face_plot( rs1->fu1 );
	nmg_face_plot( rs2->fu1 );
d1639 3
d1680 48
@


10.17
log
@nmg_join_singvu_loop() split out.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.16 92/07/22 04:31:50 mike Exp Locker: mike $ (BRL)";
d904 3
a906 1
	/* Handle next block of coincident vertexuses */
d909 14
a922 2
		nxt1 = nmg_face_next_vu_interval( rs1, cur1, mag1, rs2->state );
		nxt2 = nmg_face_next_vu_interval( rs2, cur2, mag2, rs1->state );
d1302 2
a1303 1
	int			old;
d1316 2
a1317 2
	old = rs->state;
	switch( old )  {
d1338 10
d1351 2
a1352 2
			nmg_state_names[old], nmg_v_assessment_names[assessment],
			nmg_state_names[stp->new_state], action_names[stp->action] );
a1378 8
	/* If no loop has been entered in other face, don't do any cutting */
	action = stp->action;
#if 0
	/* XXX This is the new part */
	if( other_rs_state == NMG_STATE_OUT )
		action = NMG_ACTION_NONE;
#endif

d1385 2
a1386 2
			nmg_state_names[old], nmg_v_assessment_names[assessment],
			nmg_state_names[stp->new_state], action_names[action] );
d1522 1
a1522 1
			if( old == NMG_STATE_IN )  {
d1600 1
a1600 1
				if( old == NMG_STATE_IN )  {
d1637 1
a1637 1
	rs->state = stp->new_state;
@


10.16
log
@Dual-state machine for face cutting implemented, but not
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.15 92/07/22 02:29:33 mike Exp Locker: mike $ (BRL)";
d837 1
a837 1
nmg_face_next_vu_interval( rs, cur, mag, other_rs )
d841 1
a841 1
struct nmg_ray_state	*other_rs;
d852 1
a852 1
		nmg_face_state_transition( rs->vu[cur], rs, cur, 0, other_rs );
d876 1
a876 1
		nmg_face_state_transition( rs->vu[k], rs, k, 1, other_rs );
d907 2
a908 2
		nxt1 = nmg_face_next_vu_interval( rs1, cur1, mag1, rs2 );
		nxt2 = nmg_face_next_vu_interval( rs2, cur2, mag2, rs1 );
d1061 1
d1063 87
d1280 1
a1280 1
nmg_face_state_transition( vu, rs, pos, multi, other_rs )
d1285 1
a1285 1
struct nmg_ray_state	*other_rs;
d1358 1
a1358 1
	if( other_rs->state == NMG_STATE_OUT )
d1491 2
a1492 2
		 * Take current loop on a jaunt from current edge up to the
		 * vertex from this lone vertex loop,
a1495 2
		lu = nmg_lu_of_vu( vu );
		NMG_CK_LOOPUSE(lu);
d1498 1
d1500 14
a1513 1
			eu = nmg_meonvu(prev_vu);
a1514 2
		eu = prev_vu->up.eu_p;
		NMG_CK_EDGEUSE(eu);
a1515 8
		/* insert 0 length edge */
		first_new_eu = nmg_eins(eu);
		/* split the new edge, and connect it to vertex of "vu" */
		second_new_eu = nmg_eusplit( vu->v_p, first_new_eu );
		first_new_eu = RT_LIST_PLAST_CIRC(edgeuse, second_new_eu);
		/* Make the two new edgeuses share just one edge */
		nmg_moveeu( second_new_eu, first_new_eu );

d1517 1
a1519 7
		/*  Kill lone vertex loop and that vertex use.
		 *  Vertex is still safe, being also used by new edge.
		 */
		nmg_klu(lu);

		/* Because vu changed, update vu table, for next action */
		rs->vu[pos] = second_new_eu->vu_p;
d1567 30
a1596 2
		if( *prev_vu->up.magic_p == NMG_LOOPUSE_MAGIC )  {
			(void)nmg_meonvu(prev_vu);
d1598 13
a1610 2
		if( *vu->up.magic_p == NMG_LOOPUSE_MAGIC )  {
			(void)nmg_meonvu(vu);
a1611 5
		nmg_join_2loops( prev_vu, vu );

		/* update vu[pos], as it will have changed. */
		/* Must be all on one line for SGI 3d compiler */
		rs->vu[pos] = RT_LIST_PNEXT_CIRC(edgeuse,prev_vu->up.eu_p)->vu_p;
@


10.15
log
@Reorganizing code, but it still seems to work.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.14 92/07/22 00:52:07 mike Exp Locker: mike $ (BRL)";
d115 2
d797 2
d826 8
a834 1
 *  *end is 1 beyond where current interval ends, e.g. from [cur ... *end - 1]
d837 1
a837 2
nmg_face_next_vu_interval( end, rs, cur, b, mag )
int		*end;
a839 1
struct nmg_ptbl	*b;
d841 1
a846 1
	struct vertexuse	**vu;
d848 1
a848 1
	if( cur == b->end-1 || mag[cur+1] != mag[cur] )  {
d852 2
a853 1
		*end = cur+1;
d858 1
a858 1
	for( j = cur+1; j < b->end; j++ )  {
d867 1
a867 2
	vu = (struct vertexuse **)b->buffer;
	v = vu[cur]->v_p;
d869 1
a869 1
		if( vu[k]->v_p != v )  rt_bomb("nmg_face_combine: vu block with differing vertices\n");
d874 8
a881 1
	*end = m;	/* This can be less than j */
d892 5
a896 7
nmg_face_combineX(b, fu1, fu2, pt, dir, mag)
struct nmg_ptbl	*b;		/* table of vertexuses in fu1 on intercept line */
struct faceuse	*fu1;		/* face being worked */
struct faceuse	*fu2;		/* for plane equation */
point_t		pt;
vect_t		dir;
fastf_t		*mag;
d898 2
a899 6
	struct vertexuse	**vu;
	register int	i;
	register int	j;
	int		k;
	int		m;
	struct nmg_ray_state	rs;
d901 2
a902 4
	if(rt_g.NMG_debug&DEBUG_COMBINE)  {
		rt_log("\nnmg_face_combine(fu1=x%x, fu2=x%x)\n", fu1, fu2);
		nmg_pr_fu_briefly(fu1,(char *)0);
	}
d904 5
a908 27
	vu = (struct vertexuse **)b->buffer;
	nmg_face_rs_init( &rs, b, fu1, fu2, pt, dir );
	nmg_face_plot( fu1 );

	/*
	 *  Find the extent of the vertexuses at this distance.
	 *  ptbl_vsort() will have forced all the distances to be
	 *  exactly equal if they are within tolerance of each other.
	 *
	 *  Two cases:  lone vertexuse, and range of vertexuses.
	 */
	for( i=0; i < b->end; i = j )  {
		j = nmg_face_next_vu_interval( &m, &rs, i, b, mag );
		if( j == i + 1 )  {
			/* Single vertexuse at this dist */
			nmg_face_state_transition( vu[i], &rs, i, 0 );
			nmg_face_plot( fu1 );
		} else {
			/* Process vu list, up to cutoff index 'm' */
			for( k = i; k < m; k++ )  {
				nmg_face_state_transition( vu[k], &rs, k, 1 );
				nmg_face_plot( fu1 );
			}
			vu[j-1] = vu[m-1]; /* for next iteration's lookback */
			if(rt_g.NMG_debug&DEBUG_COMBINE)
				rt_log("vu[%d] set to x%x\n", j-1, vu[j-1] );
		}
d911 4
a914 3
	if( rs.state != NMG_STATE_OUT )  {
		rt_log("ERROR nmg_face_combine() ended in state '%s'?\n",
			nmg_state_names[rs.state] );
d918 2
a919 2
		nmg_pl_comb_fu( 0, 1, fu1 );
		nmg_pl_comb_fu( 0, 2, fu2 );
d952 2
d959 1
a959 1
	mag1 = (fastf_t *)rt_calloc(b1->end, sizeof(fastf_t),
d961 1
a961 1
	mag2 = (fastf_t *)rt_calloc(b2->end, sizeof(fastf_t),
d1001 2
d1004 1
a1004 2
	nmg_face_combineX( b1, fu1, fu2, pt, dir, mag1 );
	nmg_face_combineX( b2, fu2, fu1, pt, dir, mag2 );
d1192 1
a1192 1
nmg_face_state_transition( vu, rs, pos, multi )
d1197 1
d1209 1
d1234 1
d1266 9
a1274 1
	switch( stp->action )  {
d1281 1
a1281 1
			nmg_state_names[stp->new_state], action_names[stp->action] );
d1412 3
d1479 2
d1482 7
@


10.14
log
@This version still works
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.13 92/07/21 23:47:13 butler Exp $ (BRL)";
d774 96
a895 6
	/*
	 *  Set up nmg_ray_state structure.
	 *  "left" is a vector that lies in the plane of the face
	 *  which contains the loops being operated on.
	 *  It points in the direction "left" of the ray.
	 */
d897 1
a897 30
	rs.vu = vu;
	rs.nvu = b->end;
	rs.eg_p = (struct edge_g *)NULL;
	rs.sA = fu1->s_p;
	rs.sB = fu2->s_p;
	VMOVE( rs.pt, pt );
	VMOVE( rs.dir, dir );
	VCROSS( rs.left, fu1->f_p->fg_p->N, dir );
	switch( fu1->orientation )  {
	case OT_SAME:
		break;
	case OT_OPPOSITE:
		VREVERSE(rs.left, rs.left);
		break;
	default:
		rt_bomb("nmg_face_combine: bad orientation\n");
	}
	if(rt_g.NMG_debug&DEBUG_COMBINE)  {
		rt_log("\tfu->orientation=%s\n", nmg_orientation(fu1->orientation) );
		HPRINT("\tfg N", fu1->f_p->fg_p->N);
		VPRINT("\t  pt", pt);
		VPRINT("\t dir", dir);
		VPRINT("\tleft", rs.left);
	}
	rs.state = NMG_STATE_OUT;

	/* For measuring angle CCW around plane from -dir */
	VREVERSE( rs.ang_x_dir, dir );
	VREVERSE( rs.ang_y_dir, rs.left );

d907 3
a909 2
	for( i = 0; i < b->end; i = j )  {
		if( i == b->end-1 || mag[i+1] != mag[i] )  {
a910 2
			if(rt_g.NMG_debug&DEBUG_COMBINE)
				rt_log("single vertexuse at index %d\n", i);
a912 1
			j = i+1;
a913 16
			/* Find range of vertexuses at this distance */
			struct vertex	*v;

			for( j = i+1; j < b->end; j++ )  {
				if( mag[j] != mag[i] )  break;
			}
			/* vu Interval runs from [i] to [j-1] inclusive */
			if(rt_g.NMG_debug&DEBUG_COMBINE)
				rt_log("vu's on list interval [%d] to [%d] equal\n", i, j-1 );
			/* Ensure that all vu's point to same vertex */
			v = vu[i]->v_p;
			for( k = i+1; k < j; k++ )  {
				if( vu[k]->v_p != v )  rt_bomb("nmg_face_combine: vu block with differing vertices\n");
			}
			/* All vu's point to the same vertex, sort them */
			m = nmg_face_coincident_vu_sort( &rs, i, j );
@


10.13
log
@grammar change in error message.
@
text
@d7 1
a7 5
 *  XXX A better name than nmg_face_combine() might be
 *  XXX nmg_face_cutjoin() or nmg_fcut() or
 *  XXX nmg_face_loop_partition() or nmg_face_loop_split() or something,
 *  XXX since the main goal is not combining faces, but spliting the loops
 *  XXX across the line of intersection.
d10 3
a12 1
 *  of loops.  No one loop may cross the ray after this routine is finished.
d29 1
a29 1
 *	This software is Copyright (C) 1991 by the United States Army.
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_fcut.c,v 10.12 92/03/09 16:12:41 mike Exp Locker: butler $ (BRL)";
d779 2
a780 2
void
nmg_face_combine(b, fu1, fu2, pt, dir)
d786 1
a787 1
	fastf_t		*mag;
a792 1
	fastf_t		dist_tol = 0.005;	/* XXX */
a798 2
	mag = (fastf_t *)rt_calloc(b->end, sizeof(fastf_t),
		"vector magnitudes along ray, for sort");
a800 6
	 *  Sort hit points by increasing distance, vertex ptr, vu ptr,
	 *  and eliminate any duplicate vu's.
	 */
	ptbl_vsort(b, fu1, fu2, pt, dir, mag, dist_tol);

	/*
a838 9
	/* Print list of intersections */
	if(rt_g.NMG_debug&DEBUG_COMBINE)  {
		rt_log("Ray vu intersection list:\n");
		for( i=0; i < b->end; i++ )  {
			rt_log(" %d %e ", i, mag[i] );
			nmg_pr_vu_briefly( vu[i], (char *)0 );
		}
	}

d893 1
d895 80
a974 1
	rt_free((char *)mag, "vector magnitudes");
@


10.12
log
@Fixed problem with LONE_V_ESPLIT.  Need to choose forw/rev edge
appropriately;  can't always use forw edge.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.11 92/03/06 13:40:55 mike Exp Locker: mike $ (BRL)";
d883 1
a883 1
				rt_log("interval from [%d] to [%d]\n", i, j-1 );
d911 1
a911 1
		rt_bomb("nmg_face_combine() bad ending state\n");
d1102 1
d1372 1
d1413 1
a1413 1
	fancy = 1;
d1420 2
a1421 1
			(rt_g.NMG_debug&DEBUG_PL_SLOW) ? 750000 : 0 );
@


10.11
log
@Fixed spelling.
Changed so that ON_FORW and ON_REV assessments are figured into
the dot product values.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.10 92/03/06 07:54:54 mike Exp Locker: mike $ (BRL)";
d905 6
d1113 1
d1260 4
a1263 2
		 *  This only happens in an "ON" state, so split edge that
		 *  starts with previously seen vertex.
d1271 14
a1284 1
/*		(void)nmg_esplit( vu->v_p, eu->e_p ); */
d1292 1
@


10.10
log
@Improved debugging prints
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.9 92/03/06 05:10:25 mike Exp Locker: mike $ (BRL)";
d486 1
a486 1
 *  Support routine for nmg_fact_coincident_vu_sort(), via qsort().
d552 1
a552 1
nmg_face_vu_dot( vsp, lu, rs )
d556 1
d563 1
d571 5
a575 7
	othereu = RT_LIST_PLAST_CIRC( edgeuse, this_eu );
	if( vu->v_p != othereu->vu_p->v_p )  {
		/* Vector from othereu to this_eu */
		VSUB2( vec, vu->v_p->vg_p->coord,
			othereu->vu_p->v_p->vg_p->coord );
		VUNITIZE(vec);
		vsp->min_vu_dot = VDOT( vec, rs->dir );
d577 10
a586 1
		vsp->min_vu_dot = 99;		/* larger than +1 */
d590 18
a607 9
	othereu = RT_LIST_PNEXT_CIRC( edgeuse, this_eu );
	if( vu->v_p != othereu->vu_p->v_p )  {
		/* Vector from othereu to this_eu */
		VSUB2( vec, vu->v_p->vg_p->coord,
			othereu->vu_p->v_p->vg_p->coord );
		VUNITIZE(vec);
		dot = VDOT( vec, rs->dir );
		if( dot < vsp->min_vu_dot )  {
			vsp->min_vu_dot = dot;
d619 1
a619 1
nmg_fact_coincident_vu_sort( rs, start, end )
d635 1
a635 1
		rt_log("nmg_fact_coincident_vu_sort(, %d, %d)\n", start, end);
d675 1
a675 1
		nmg_face_vu_dot( &vs[nvu], lu, rs );
d890 1
a890 1
			m = nmg_fact_coincident_vu_sort( &rs, i, j );
d905 1
@


10.9
log
@More forcing of edge geometry
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.8 92/03/06 03:02:35 mike Exp Locker: mike $ (BRL)";
a806 6
	if(rt_g.NMG_debug&DEBUG_COMBINE)  {
		rt_log("fu->orientation=%s\n", nmg_orientation(fu1->orientation) );
		VPRINT("fg_p->N", fu1->f_p->fg_p->N);
		VPRINT(" pt", pt);
		VPRINT("dir", dir);
	}
d817 7
a823 3
if(rt_g.NMG_debug&DEBUG_COMBINE) {
VPRINT("left", rs.left);
}
d1117 1
a1117 1
		rt_log("This loopuse, before action: ");
d1250 1
a1250 1
			rt_log("After LONE_V_ESPLIT, the final loop: ");
d1287 1
a1287 1
			rt_log("After LONE_V_JAUNT, the final loop: ");
d1313 1
a1313 1
				rt_log("After CUT, the final loop: ");
d1336 1
a1336 1
			rt_log("After JOIN, the final loop: ");
@


10.8
log
@Algorithm to sort coincident vertexuses now working.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.7 92/03/05 07:43:29 mike Exp Locker: mike $ (BRL)";
d1121 22
@


10.7
log
@Added code to support proper handling of repeated vertexuses with
multiplicity>1 (e.g., fan-fold loops).
A bit more will be required.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.6 92/03/05 04:16:04 mike Exp Locker: mike $ (BRL)";
d504 1
d506 1
d518 1
a520 1
	/* XXX This is almost certainly wrong */
d523 3
a525 2
		/* Dot product is the same, edges are parallel.
		 * Take min angle first.
d543 7
d583 3
a585 3
		/* Vector from this_eu to othereu */
		VSUB2( vec, othereu->vu_p->v_p->vg_p->coord,
			vu->v_p->vg_p->coord );
a587 3
#if 0
rt_log("dot vu=x%x dots %g %g\n", vu, vsp->min_vu_dot, dot );
#endif
@


10.6
log
@Renamed nmg_comb.c to nmg_fcut.c
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fcut.c,v 10.5 92/03/03 15:20:22 mike Exp Locker: mike $ (BRL)";
d473 2
d478 3
a480 1
	fastf_t			max_angle;
d486 1
a486 1
 *  Support routine for nmg_face_vu_sort(), via qsort().
a487 3
 *  If vu's are from same loop, sort is from larger to smaller vu_angle.
 *  If vu's are from different loops,
 *  sort is from small to large loop max_angle.
d496 1
d499 3
a501 2
		/* Sort from larger to smaller vu_angle */
		if( va->vu_angle > vb->vu_angle )  return -1;
d504 10
a513 2
	/* Sort from small to large max_angle */
	if( va->lsp->max_angle > vb->lsp->max_angle )
d515 21
a535 3
	if( va->lsp->max_angle == vb->lsp->max_angle )
		return 0;
	return -1;
d539 1
a539 1
 *			N M G _ F A C E _ V U _ S O R T
d541 52
d594 1
a594 1
nmg_face_vu_sort( rs, start, end )
d610 1
a610 1
		rt_log("nmg_face_vu_sort(, %d, %d)\n", start, end);
d641 2
d646 6
d659 2
a660 1
		ls[l].max_angle = 0;
d662 1
d665 4
a668 2
		if( vs[nvu].vu_angle > ls[l].max_angle )
			ls[l].max_angle = vs[nvu].vu_angle;
d671 7
a677 2
#if 0
	rt_log("Loop table (before sort):\n");
d679 19
a697 2
		rt_log("  index=%d, lu=x%x, max_angle=%g\n",
			l, ls[l].lu, ls[l].max_angle );
d699 18
a716 4
	rt_log("Vertexuse table:\n");
	for( i=0; i < nvu; i++ )  {
		rt_log("  vu=x%x, loop_index=%d, vu_angle=%g\n",
			vs[i].vu, vs[i].loop_index, vs[i].vu_angle );
d727 2
a728 1
	if(rt_g.NMG_debug&DEBUG_COMBINE)  {
d731 3
a733 2
			rt_log("  vu=x%x, loop_index=%d, vu_angle=%g\n",
				vs[i].vu, vs[i].loop_index, vs[i].vu_angle );
d867 1
a867 1
			m = nmg_face_vu_sort( &rs, i, j );
@


10.5
log
@For sanity, added equal test to qsort routine.
@
text
@d2 1
a2 1
 *			N M G _ C O M B . C
d5 1
a5 1
 *  by the line of intersection.
d8 1
a11 1
 *  XXX nmg_split or nmg_weave are other candidates.
d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 10.4 92/02/29 03:17:31 mike Exp Locker: mike $ (BRL)";
d1035 1
a1035 1
			strcpy( rec.i.i_title, "nmg_comb.c error dump" );
@


10.4
log
@Comment update
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 10.3 92/02/25 00:06:15 mike Exp Locker: mike $ (BRL)";
d504 2
@


10.3
log
@Starting to deal with having edge geometry
@
text
@d11 1
d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 10.2 92/02/21 01:30:41 butler Exp Locker: mike $ (BRL)";
d283 2
a284 2
		if(rt_g.NMG_debug&DEBUG_COMBINE)
			rt_log("nmg_vu_angle_measure: prev eu is this eu, ang=0\n");
d289 2
d292 1
d395 1
d759 3
@


10.2
log
@changed to use nmg_ebreak instead of nmg_esplit
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 10.1 91/10/12 06:40:42 mike Rel4_0 Locker: butler $ (BRL)";
a41 1
#include "db.h"		/* XXX just for debugging */
d45 7
d113 3
a222 84
 *			N M G _ E U _ W I T H _ V U _ I N _ L U
 *
 * XXX should move to nmg_mod.c or nmg_misc.c
 */
struct edgeuse *
nmg_eu_with_vu_in_lu( lu, vu )
struct loopuse		*lu;
struct vertexuse	*vu;
{
	register struct edgeuse	*eu;

	NMG_CK_LOOPUSE(lu);
	NMG_CK_VERTEXUSE(vu);
	if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
		rt_bomb("nmg_eu_with_vu_in_lu: loop has no edges!\n");
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		NMG_CK_EDGEUSE(eu);
		if( eu->vu_p == vu )  return eu;
	}
	rt_bomb("nmg_eu_with_vu_in_lu:  Unable to find vu!\n");
	/* NOTREACHED */
	return((struct edgeuse *)NULL);
}

/*
 *			R T _ A N G L E _ M E A S U R E
 *
 *  Using two perpendicular vectors (x_dir and y_dir) which lie
 *  in the same plane as 'vec', return the angle (in radians) of 'vec'
 *  from x_dir, going CCW around the perpendicular x_dir CROSS y_dir.
 *
 *  Trig note -
 *
 *  theta = atan2(x,y) returns an angle in the range -pi to +pi.
 *  Here, we need an angle in the range of 0 to 2pi.
 *  This could be implemented by adding 2pi to theta when theta is negative,
 *  but this could have nasty numeric ambiguity right in the vicinity
 *  of theta = +pi, which is a very critical angle for the applications using
 *  this routine.
 *  So, an alternative formulation is to compute gamma = atan2(-x,-y),
 *  and then theta = gamma + pi.  Now, any error will occur in the
 *  vicinity of theta = 0, which can be handled much more readily.
 *
 *  If theta is negative, or greater than two pi,
 *  wrap it around.
 *  These conditions only occur if there are problems in atan2().
 *
 *  Returns -
 *	vec == x_dir returns 0,
 *	vec == y_dir returns pi/2,
 *	vec == -x_dir returns pi,
 *	vec == -y_dir returns 3*pi/2.
 */
double
rt_angle_measure( vec, x_dir, y_dir )
vect_t	vec;
vect_t	x_dir;
vect_t	y_dir;
{
	fastf_t		xproj, yproj;
	fastf_t		gamma;
	fastf_t		ang;

	xproj = -VDOT( vec, x_dir );
	yproj = -VDOT( vec, y_dir );
	gamma = atan2( yproj, xproj );	/* -pi..+pi */
	ang = rt_pi + gamma;		/* 0..+2pi */
	if( ang < 0 )  {
#if 0
 rt_log("angle = %e < 0, setting to %e (%g deg)\n",
 ang, rt_twopi + ang, (rt_twopi + ang) * rt_radtodeg );
#endif
		return rt_twopi + ang;
	} else if( ang > rt_twopi )  {
#if 0
 rt_log("angle = %e > 2pi, setting to %e (%g deg)\n",
 ang, ang - rt_twopi, (ang - rt_twopi) * rt_radtodeg );
#endif
		return ang - rt_twopi;
	}
	return ang;
}

/*
d657 3
d750 48
d1108 3
d1141 8
a1148 8
		if(rt_g.NMG_debug&DEBUG_COMBINE)
			rt_log("nmg_cut_loop(prev_vu=x%x, vu=x%x)\n", prev_vu, vu);
		nmg_cut_loop( prev_vu, vu );
		if(rt_g.NMG_debug&DEBUG_COMBINE)  {
			rt_log("After CUT, the final loop: ");
			nmg_pr_lu_briefly(nmg_lu_of_vu(rs->vu[pos]), (char *)0);
			nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]), rs);
		}
@


10.1
log
@Release_4.0
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.34 91/09/25 02:15:27 butler Exp $ (BRL)";
d1099 2
a1100 1
		(void)nmg_esplit( vu->v_p, eu->e_p );
@


2.34
log
@ifdef for $#%^!@@#$ convex
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.33 91/08/29 22:33:27 mike Exp $ (BRL)";
@


2.33
log
@A fruitless attempt to silence warnings about qsort()
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.32 91/07/24 20:38:47 mike Exp $ (BRL)";
d660 4
d665 1
a665 1

@


2.32
log
@#if'ed out lots of debugging prints on NMG_ACTION_ERROR case.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.31 91/07/19 02:38:27 mike Exp $ (BRL)";
d560 2
a561 2
genptr_t	a;
genptr_t	b;
d563 2
a564 2
	register struct nmg_vu_stuff	*va = (struct nmg_vu_stuff *)a;
	register struct nmg_vu_stuff	*vb = (struct nmg_vu_stuff *)b;
@


2.31
log
@Bloody SGI 3d compiler bugs
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.30 91/07/02 23:16:40 butler Exp $ (BRL)";
d1003 1
d1051 1
@


2.30
log
@gave nmg_eu_with_vu_in_lu() a return((struct edgeuse *)NULL) to make the
gould compiler happy.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_comb.c,v 2.29 91/06/29 22:13:59 mike Exp $ (BRL)";
d1178 2
a1179 2
		rs->vu[pos] = RT_LIST_PNEXT_CIRC(edgeuse,
			prev_vu->up.eu_p)->vu_p;
@


2.29
log
@ANSI lint
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.28 91/06/22 20:10:52 butler Exp $ (BRL)";
d234 2
@


2.28
log
@Fixed log message
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.27 91/06/17 20:41:59 butler Exp $ (BRL)";
d113 2
d953 1
a953 1
	struct state_transitions	*stp;
@


2.27
log
@changed function declarations so that all global functions have their
"nmg_" at the begining of the line.  Static functions have their function
names on the same line as the "static" modifier.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.26 91/05/30 11:21:37 mike Exp $ (BRL)";
d459 2
a460 2
			rt_log("ON: vu[%d]=x%x otherv=x%x,
				i=%d\n", pos, rs->vu[pos], otherv, i );
@


2.26
log
@Added extra message
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.25 91/05/25 03:30:56 mike Exp $ (BRL)";
d125 1
a125 2
static void
ptbl_vsort(b, fu1, fu2, pt, dir, mag, dist_tol)
d156 1
a156 1
rt_log("ptbl_vsort: forcing vu=x%x & vu=x%x mag equal\n", vu[i], vu[j]);
d173 1
a173 1
rt_log("ptbl_vsort: vu duplication eliminated\n");
d279 2
a280 2
rt_log("angle = %e < 0, setting to %e (%g deg)\n",
ang, rt_twopi + ang, (rt_twopi + ang) * rt_radtodeg );
d285 2
a286 2
rt_log("angle = %e > 2pi, setting to %e (%g deg)\n",
ang, ang - rt_twopi, (ang - rt_twopi) * rt_radtodeg );
d458 4
a461 2
if(rt_g.NMG_debug&DEBUG_COMBINE)
rt_log("ON: vu[%d]=x%x otherv=x%x, i=%d\n", pos, rs->vu[pos], otherv, i );
d726 6
a731 6
if(rt_g.NMG_debug&DEBUG_COMBINE)  {
rt_log("fu->orientation=%s\n", nmg_orientation(fu1->orientation) );
VPRINT("fg_p->N", fu1->f_p->fg_p->N);
VPRINT(" pt", pt);
VPRINT("dir", dir);
}
d1094 4
a1097 4
if(rt_g.NMG_debug&DEBUG_COMBINE)  {
rt_log("After LONE_V_ESPLIT, the final loop: ");
nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]), rs);
}
d1128 4
a1131 4
if(rt_g.NMG_debug&DEBUG_COMBINE)  {
rt_log("After LONE_V_JAUNT, the final loop: ");
nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]), rs);
}
d1151 8
a1158 8
if(rt_g.NMG_debug&DEBUG_COMBINE)
rt_log("nmg_cut_loop(prev_vu=x%x, vu=x%x)\n", prev_vu, vu);
			nmg_cut_loop( prev_vu, vu );
if(rt_g.NMG_debug&DEBUG_COMBINE)  {
rt_log("After CUT, the final loop: ");
nmg_pr_lu_briefly(nmg_lu_of_vu(rs->vu[pos]), (char *)0);
nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]), rs);
}
d1167 3
a1169 2
if(rt_g.NMG_debug&DEBUG_COMBINE)
rt_log("nmg_join_2loops(prev_vu=x%x, vu=x%x)\n", prev_vu, vu);
d1187 1
d1227 1
@


2.25
log
@Added DEBUG_PL_SLOW bit
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.24 91/05/24 19:59:44 mike Exp $ (BRL)";
d994 4
@


2.24
log
@Improved implementation of CUTJOIN rule
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.23 91/05/24 18:59:57 mike Exp $ (BRL)";
a1189 1
	int		delay;
a1208 2
		delay = 1;

d1211 1
a1211 1
			delay ? 750000 : 0 );
@


2.23
log
@Moved nmg_join_2loops() to nmg_mod
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.22 91/04/04 00:53:12 mike Exp $ (BRL)";
d805 1
a805 1
		rt_log("ERROR nmg_face_combine() ended in state %s?\n",
d1143 1
a1155 1
		/* Different loops, join into one. */
d1157 4
a1160 2
		 *  If the edge from prev_vu to vu is already
		 *  in both loops, use nmg_jl().
d1162 9
a1170 23
		eu = nmg_eu_with_vu_in_lu( lu, vu );
		/* XXX Need better check.  If prev_lu is found around
		 * this edge, but is not "first hop" radial in both
		 * directions, can not do any joining,
		 * and need to go to state = out_internal if new_state=out.
		 * (as opposed to out_external).
		 */
		if( eu->radial_p->up.lu_p == prev_lu &&
		    eu->eumate_p->radial_p->up.lu_p == prev_lu )  {
			if(rt_g.NMG_debug&DEBUG_COMBINE)
				rt_log("using nmg_jl( lu=x%x, eu=x%x\n", lu, eu );
			nmg_jl( lu, eu );
#if 0
rt_log("After nmg_jl, before nmg_kill_snakes: ");
nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]), rs);
			/* nmg_kill_snakes( lu ); */
#endif
		} else {
			nmg_join_2loops( prev_vu, vu );
			/* update vu[pos], as it will have changed. */
			rs->vu[pos] = RT_LIST_PNEXT_CIRC(edgeuse,
				prev_vu->up.eu_p)->vu_p;
		}
@


2.22
log
@Fixed memory leak.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.21 91/04/04 00:14:07 mike Exp $ (BRL)";
a1190 106
}

/*
 *			N M G _ J O I N _ 2 L O O P S
 *
 *  Intended to join an interior and exterior loop together,
 *  by building a bridge between the two indicated vertices.
 *
 *  This routine can be used to join two exterior loops which do not
 *  overlap, and it can also be used to join an exterior loop with
 *  a loop of oposite orientation that lies entirely within it.
 *  This restriction is important, but not checked for.
 *
 *XXX Should move to nmg_mod.c
 */
int
nmg_join_2loops( vu1, vu2 )
struct vertexuse	*vu1;
struct vertexuse	*vu2;
{
	struct edgeuse	*eu1, *eu2;
	struct edgeuse	*new_eu;
	struct edgeuse	*first_new_eu;
	struct edgeuse	*second_new_eu;
	struct edgeuse	*final_eu2;
	struct loopuse	*lu1, *lu2;

	NMG_CK_VERTEXUSE(vu1);
	NMG_CK_VERTEXUSE(vu2);
	eu1 = vu1->up.eu_p;
	eu2 = vu2->up.eu_p;
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);
	lu1 = eu1->up.lu_p;
	lu2 = eu2->up.lu_p;
	NMG_CK_LOOPUSE(lu1);
	NMG_CK_LOOPUSE(lu2);

	if(rt_g.NMG_debug&DEBUG_COMBINE)  {
		rt_log("nmg_join_2loops(vu1=x%x, vu2=x%x) lu1=x%x, lu2=x%x\n",
			vu1, vu2, lu1, lu2 );
#if 0
		/* Drop a plot file */
		rt_g.NMG_debug |= DEBUG_COMBINE|DEBUG_PLOTEM;
		nmg_pl_comb_fu( 10, 11, lu1->up.fu_p );
#endif
		rt_log("lu1=%s lu2=%s\n", nmg_orientation(lu1->orientation), nmg_orientation(lu2->orientation) );
	}

	if( lu1 == lu2 || lu1->l_p == lu2->l_p )
		rt_bomb("nmg_join_2loops: can't join loop to itself\n");

	if( lu1->up.fu_p != lu2->up.fu_p )
		rt_bomb("nmg_join_2loops: can't join loops in different faces\n");

	if( vu1->v_p != vu2->v_p )  {
		/*
		 *  Start by taking a jaunt from vu1 to vu2 and back.
		 */
		/* insert 0 length edge */
		first_new_eu = nmg_eins(eu1);
		/* split the new edge, and connect it to vertex 2 */
		second_new_eu = nmg_eusplit( vu2->v_p, first_new_eu );
		first_new_eu = RT_LIST_PLAST_CIRC(edgeuse, second_new_eu);
		/* Make the two new edgeuses share just one edge */
		nmg_moveeu( second_new_eu, first_new_eu );
	} else {
		second_new_eu = RT_LIST_NEXT( edgeuse, &eu1->l );
	}

	/*
	 *  Gobble edges off of loop2, and insert them into loop1,
	 *  between first_new_eu and second_new_eu.
	 *  The final edge from loop 2 will then be followed by
	 *  second_new_eu.
	 */
	final_eu2 = RT_LIST_PLAST_CIRC(edgeuse, eu2 );
	while( RT_LIST_NON_EMPTY( &lu2->down_hd ) )  {
		eu2 = RT_LIST_PNEXT_CIRC(edgeuse, final_eu2);

		RT_LIST_DEQUEUE(&eu2->l);
		RT_LIST_INSERT(&second_new_eu->l, &eu2->l);
		eu2->up.lu_p = lu1;

		RT_LIST_DEQUEUE(&eu2->eumate_p->l);
		RT_LIST_APPEND(&second_new_eu->eumate_p->l, &eu2->eumate_p->l);
		eu2->eumate_p->up.lu_p = lu1->lumate_p;
	}

#if 0
	if(rt_g.NMG_debug&DEBUG_COMBINE)
		nmg_pl_comb_fu( 11, 12, lu1->up.fu_p );
#endif

	/* Kill entire (null) loop associated with lu2 */
	nmg_klu(lu2);

	if(rt_g.NMG_debug&DEBUG_COMBINE)  {
#if 0
		nmg_pl_comb_fu( 12, 13, lu1->up.fu_p );
#endif
		rt_log("final lu1\n");
		nmg_pr_lu_briefly( lu1, (char *)0);
		rt_log("final lu1mate\n");
		nmg_pr_lu_briefly( lu1->lumate_p, (char *)0);
	}
@


2.21
log
@if(rt_g.NMG_debug&DEBUG_COMBINE) tests placed around all
debugging prints, to leave the code in a (more) useful state.
It gets amazingly far now, but not all the way (on c-a-b)
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.20 91/04/03 23:34:18 mike Exp $ (BRL)";
d612 5
a616 1
			if( i <= start && nvu == 0 )  return start+1;
d672 3
@


2.20
log
@Changed to plot line of intersection, in yellow.
@
text
@d7 5
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.19 91/04/03 22:35:20 mike Exp $ (BRL)";
d279 1
d282 1
d285 1
d288 1
d335 2
a336 1
rt_log("nmg_vu_angle_measure:  NMG_E_ASSESSMENT_ON_FORW, ang=0\n");
d340 2
a341 1
rt_log("nmg_vu_angle_measure:  NMG_E_ASSESSMENT_ON_FORW, ang=180\n");
d354 2
a355 1
rt_log("nmg_vu_angle_measure: prev eu is this eu, ang=0\n");
d362 2
a363 1
rt_log("nmg_vu_angle_measure:  measured angle=%e\n", ang*rt_radtodeg);
d402 2
a403 1
rt_log("ang=%g (%e), vec=(%g,%g,%g)\n", ang*rt_radtodeg, ang*rt_radtodeg, V3ARGS(vec) );
d458 2
d490 7
a496 5
	rt_log("nmg_assess_eu(x%x, fw=%d, pos=%d) v=x%x otherv=x%x: %s\n",
		eu, forw, pos, v, otherv,
		nmg_e_assessment_names[ret] );
	rt_log(" v(%g,%g,%g) other(%g,%g,%g)\n",
		V3ARGS(v->vg_p->coord), V3ARGS(otherv->vg_p->coord) );
d526 4
a529 2
	rt_log("nmg_assess_vu() vu[%d]=x%x, v=x%x: %s\n",
		pos, vu, vu->v_p, nmg_v_assessment_names[ass] );
d591 2
a592 1
rt_log("nmg_face_vu_sort(, %d, %d)\n", start, end);
d605 2
a606 1
		rt_log("vu[%d]=x%x v=x%x assessment=%s\n",
d637 1
d648 1
d653 6
a658 4
	rt_log("Vertexuse table (after sort):\n");
	for( i=0; i < nvu; i++ )  {
		rt_log("  vu=x%x, loop_index=%d, vu_angle=%g\n",
			vs[i].vu, vs[i].loop_index, vs[i].vu_angle );
d664 3
a666 2
		rt_log(" vu[%d]=x%x, v=x%x\n",
			start+i, rs->vu[start+i], rs->vu[start+i]->v_p );
d694 4
a697 2
rt_log("\nnmg_face_combine(fu1=x%x, fu2=x%x)\n", fu1, fu2);
nmg_pr_fu_briefly(fu1,(char *)0);
d718 1
d723 1
d734 1
d736 1
d746 6
a751 4
	rt_log("Ray vu intersection list:\n");
	for( i=0; i < b->end; i++ )  {
		rt_log(" %d %e ", i, mag[i] );
		nmg_pr_vu_briefly( vu[i], (char *)0 );
d764 2
a765 1
rt_log("single vertexuse at index %d\n", i);
d777 2
a778 1
rt_log("interval from %d to %d\n", i, j );
d792 2
a793 1
			rt_log("vu[%d] set to x%x\n", j-1, vu[j-1] );
d974 8
a981 6
rt_log("nmg_face_state_transition(vu x%x, pos=%d)\n\told=%s, assessed=%s, new=%s, action=%s\n",
vu, pos,
nmg_state_names[old], nmg_v_assessment_names[assessment],
nmg_state_names[stp->new_state], action_names[stp->action] );
rt_log("This loopuse, before action: ");
nmg_face_lu_plot(nmg_lu_of_vu(vu), rs);
d1082 1
d1085 1
d1116 1
d1119 1
d1138 1
d1141 1
d1145 1
d1162 2
a1163 1
rt_log("using nmg_jl( lu=x%x, eu=x%x\n", lu, eu );
d1176 4
a1179 2
rt_log("After JOIN, the final loop: ");
nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]), rs);
d1222 10
a1231 4
rt_log("nmg_join_2loops(vu1=x%x, vu2=x%x) lu1=x%x, lu2=x%x\n", vu1, vu2, lu1, lu2 );
	/* Drop a plot file */
	rt_g.NMG_debug |= DEBUG_COMBINE|DEBUG_PLOTEM;
	nmg_pl_comb_fu( 10, 11, lu1->up.fu_p );
a1235 2
rt_log("lu1=%s lu2=%s\n", nmg_orientation(lu1->orientation), nmg_orientation(lu2->orientation) );

d1273 4
a1276 1
	nmg_pl_comb_fu( 11, 12, lu1->up.fu_p );
d1281 9
a1289 5
	nmg_pl_comb_fu( 12, 13, lu1->up.fu_p );
	rt_log("final lu1\n");
	nmg_pr_lu_briefly( lu1, (char *)0);
	rt_log("final lu1mate\n");
	nmg_pr_lu_briefly( lu1->lumate_p, (char *)0);
d1343 2
@


2.19
log
@Fixed problem with ptbl sorting
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.18 91/04/03 21:54:41 mike Exp $ (BRL)";
d941 1
a941 1
nmg_face_lu_plot(nmg_lu_of_vu(vu));
d957 1
a957 1
		nmg_face_lu_plot(lu);
d1043 1
a1043 1
nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]));
d1075 1
a1075 1
nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]));
d1098 1
a1098 1
nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]));
d1117 1
d1119 1
a1119 1
nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]));
d1121 1
d1129 1
a1129 1
nmg_face_lu_plot(nmg_lu_of_vu(rs->vu[pos]));
d1273 3
a1275 2
nmg_face_lu_plot( lu )
struct loopuse	*lu;
d1290 4
@


2.18
log
@Changed from SMALL_FASTF to RADIAN_TWEEK.  Only ~15 digits of precision!
nmg_jl() is working better now.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.17 91/04/03 21:23:11 mike Exp $ (BRL)";
d130 1
a130 4
	union {
		struct vertexuse **vu;
		long **magic_p;
	} p;
d133 1
a133 1
	p.magic_p = b->buffer;
d137 1
a137 1
		NMG_CK_VERTEXUSE(p.vu[i]);
d139 1
a139 1
		VSUB2(vect, p.vu[i]->v_p->vg_p->coord, pt);
d141 13
a153 8
		if( mag[i] < 0 )  {
			if( mag[i] < -dist_tol )  {
				/* Code later depends on positive mag's */
				VPRINT("coord", p.vu[i]->v_p->vg_p->coord);
				VPRINT("pt", pt);
				VPRINT("vect", vect);
				rt_log("magnitude=%e\n", mag[i]);
				rt_bomb("ptbl_vsort: negative dist\n");
a154 1
			mag[i] = 0;
a159 2
			register struct vertexuse *tvu;
			register fastf_t	tmag;
d161 6
a166 8
			if( mag[i] < mag[j]-dist_tol )  continue;
			tmag = mag[i] - mag[j];
			if( NEAR_ZERO( tmag, dist_tol ) )  {
				mag[j] = mag[i];	/* force equal */
				if( p.vu[i]->v_p < p.vu[j]->v_p )  continue;
				if( p.vu[i]->v_p == p.vu[j]->v_p )  {
					if( p.vu[i] < p.vu[j] )  continue;
					if( p.vu[i] == p.vu[j] )  {
d169 1
d176 1
a176 1
						p.vu[j] = p.vu[last];
d183 1
a183 1
					/* p.vu[i] > p.vu[j], fall through */
d185 1
a185 1
				/* p.vu[i]->v_p > p.vu[j]->v_p, fall through */
d190 6
a195 3
			tvu = p.vu[i];
			p.vu[i] = p.vu[j];
			p.vu[j] = tvu;
d197 6
a202 3
			tmag = mag[i];
			mag[i] = mag[j];
			mag[j] = tmag;
d664 1
a664 1
	fastf_t		dist_tol = 0.05;	/* XXX */
d715 1
a715 1
		rt_log(" %d ", i );
d1109 3
a1111 1
		 * directions, may not want to do any joining.
@


2.17
log
@No need to measure angle on single vu vertex.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.16 91/04/03 21:20:05 mike Exp $ (BRL)";
d352 1
d355 1
a355 1
			ang = SMALL_FASTF;
d358 1
a358 1
			ang = rt_twopi;
d362 1
a362 1
			ang = rt_pi - SMALL_FASTF;
d364 1
a364 1
			ang = rt_pi + SMALL_FASTF;
d1103 8
a1110 4
		/* XXX This test is not comprehensive */
		if( eu->radial_p->up.lu_p == prev_lu )  {
rt_log("using nmg_jl\n");
			nmg_jl( lu, eu->radial_p );
d1113 1
a1113 1
			nmg_kill_snakes( lu );
@


2.16
log
@Made nmg_vu_angle_measure much more rigorous.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.15 91/04/03 20:31:38 mike Exp $ (BRL)";
a724 1
(void)nmg_vu_angle_measure( vu[i], rs.ang_x_dir, rs.ang_y_dir );
@


2.15
log
@Additional printing
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.14 91/04/03 20:28:23 mike Exp $ (BRL)";
d66 4
d244 3
a246 2
 *  If theta is negative, set it to zero.
 *  If theta is greater than two pi, set it to two pi.
d270 3
a272 1
		return 0;
d274 3
a276 1
		return rt_twopi;
d298 1
a298 1
nmg_vu_angle_measure( vu, x_dir, y_dir )
d302 1
d309 1
d315 18
d339 1
d346 39
a384 2
rt_log("ang=%g, vec=(%g,%g,%g), x=(%g,%g,%g), y=(%g,%g,%g)\n",
 ang*rt_radtodeg, V3ARGS(vec), V3ARGS(x_dir), V3ARGS(y_dir) );
d594 1
a594 1
			rs->ang_x_dir, rs->ang_y_dir ) * rt_radtodeg;
d633 1
a633 1
		rt_log(" vu[%]=x%x, v=x%x\n",
d1090 1
a1090 1
rt_log("nmg_cut_loop\n");
d1093 1
@


2.14
log
@Minor bug with previous rev
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.13 91/04/03 03:38:30 mike Exp $ (BRL)";
d566 2
d684 1
d865 3
a867 2
rt_log("nmg_face_state_transition(vu x%x)\n\told=%s, assessed=%s, new=%s, action=%s\n",
vu, nmg_state_names[old], nmg_v_assessment_names[assessment],
@


2.13
log
@If joining two loops, and both vertexuses point to same vertex,
no need to take a jaunt over there.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.12 91/04/03 01:15:24 mike Exp $ (BRL)";
d1112 2
a1121 1
	/* Same orientation */
@


2.12
log
@Added code to export defective NMG to a .g file, in an attempt
to allow closer scrutiny.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.11 91/04/03 00:43:16 mike Exp $ (BRL)";
d865 2
d882 7
d916 2
d967 2
d999 2
d1021 17
a1038 1
			/* Different loops, join into one. */
d1044 2
d1101 12
a1112 10
	/*
	 *  Start by taking a jaunt from vu1 to vu2 and back.
	 */
	/* insert 0 length edge */
	first_new_eu = nmg_eins(eu1);
	/* split the new edge, and connect it to vertex 2 */
	second_new_eu = nmg_eusplit( vu2->v_p, first_new_eu );
	first_new_eu = RT_LIST_PLAST_CIRC(edgeuse, second_new_eu);
	/* Make the two new edgeuses share just one edge */
	nmg_moveeu( second_new_eu, first_new_eu );
d1140 4
d1186 21
@


2.11
log
@Got nmg_join_2loops() working, at least to outward appearances.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.10 91/04/02 21:29:32 mike Exp $ (BRL)";
d37 1
d880 28
@


2.10
log
@Fixed bug in edge assessment of ON edges.
Tightened up rules for hitting loops in OUT state.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.9 91/04/02 20:27:50 mike Exp $ (BRL)";
d875 3
d897 2
a898 2
			rt_log("nmg_face_state_transition: VFY_EXT got orientation=%d\n",
				lu->orientation );
d908 1
d996 5
d1026 5
a1030 1
rt_log("nmg_join_2loops\n");
d1034 1
a1034 2
	if( lu1->orientation == lu2->orientation )
		rt_bomb("nmg_join_2loops: can't join loops of same orientation\n");
d1052 1
a1052 1
	 *  immediately after first_new_eu.
d1056 1
d1067 1
a1067 1
		eu2->eumate_p->up.lu_p = lu1;
d1070 3
a1072 3
	/* Kill entire loop associated with lu2 */
rt_log("Here is what will be killed\n");
nmg_pr_lu(lu2, (char *)0);
d1074 2
@


2.9
log
@Added distinctions to edge ON assessment:  ON_FORW and ON_REV.
Expanded state tables to match.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.8 91/04/02 18:46:42 mike Exp $ (BRL)";
d323 4
d365 2
a366 3
	 *  There is a slight possibility that loop/face orientation might
	 *  play a factor in choosing the correct scan direction.
	/* XXX Need to distinguish between OnForw & OnRev.
d372 8
a379 1
		VSUB2( heading, rs->vu[i]->v_p->vg_p->coord, v->vg_p->coord );
d389 3
a391 1
	 *  The edge must lie to one side or the other of the ray.
a392 4
#if 0
VPRINT("assess_eu from", v->vg_p->coord);
VPRINT("          to  ", otherv->vg_p->coord);
#endif
d394 1
d404 2
d614 1
a614 1
rt_log("fu->orientation=%d\n", fu1->orientation);
d619 9
d725 1
a725 1
	{ /* RIGHT,LEFT */	NMG_STATE_IN,		NMG_ACTION_VFY_EXT },
d801 1
a801 1
	{ /* LEFT,RIGHT */	NMG_STATE_OUT,		NMG_ACTION_CUTJOIN },
@


2.8
log
@Shuffled defintions to top of file.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.7 91/04/02 04:12:24 mike Exp $ (BRL)";
d57 4
a60 3
#define NMG_E_ASSESSMENT_LEFT		1
#define NMG_E_ASSESSMENT_RIGHT		2
#define NMG_E_ASSESSMENT_ON		3
d62 1
a62 1
#define NMG_V_ASSESSMENT_LONE		1
d65 1
a65 6
static char *nmg_v_assessment_names[16] = {
	"ASSESS_0",
	"LONE",
	"ASSESS_2",
	"ASSESS_3",
	"Left,0",
d68 2
a69 2
	"Left,On",
	"Right,0",
d72 11
a82 5
	"Right,On",
	"On,0",
	"On,Left",
	"On,Right",
	"On,On"
a85 1
	"*ERROR*",
d88 2
a89 1
	"ON"
d344 14
a357 15
	do {
		if( forw )  {
			othereu = RT_LIST_PNEXT_CIRC( edgeuse, othereu );
		} else {
			othereu = RT_LIST_PLAST_CIRC( edgeuse, othereu );
		}
		if( othereu == eu )  {
			/* Back to where search started */
rt_log("ON: (no edges)\n");
			ret = NMG_E_ASSESSMENT_ON;
			goto out;
		}
		/* Skip over any edges that stay on this vertex */
		otherv = othereu->vu_p->v_p;
	} while( otherv == v );
d365 3
a367 3
/**	for( i=rs->nvu-1; i >= 0; i-- )  { **/
	for( i=0; i < rs->nvu; i++ )  {
		if( rs->vu[i]->v_p == otherv )  {
d369 5
a373 2
			ret = NMG_E_ASSESSMENT_ON;
			goto out;
d375 1
d421 1
a422 1
	prev_ass = nmg_assess_eu( this_eu, 0, rs, pos );
d636 1
a636 1
			nmg_face_state_transition( vu[i], &rs, i );
d657 1
a657 1
				nmg_face_state_transition( vu[k], &rs, k );
d677 7
a683 6
#define NMG_ACTION_ERROR	0
#define NMG_ACTION_NONE		1
#define NMG_ACTION_VFY_EXT	2
#define NMG_ACTION_LONE_V_ESPLIT	3
#define NMG_ACTION_LONE_V_JAUNT	4
#define NMG_ACTION_CUTJOIN	5
d688 1
d700 1
a700 6
static CONST struct state_transitions nmg_state_is_out[16] = {
	{ /* 0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LONE */		NMG_STATE_OUT,		NMG_ACTION_NONE },
	{ /* 2 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* 3 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LEFT,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d702 4
a705 4
	{ /* LEFT,RIGHT */	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ /* LEFT,ON */		NMG_STATE_ON_L,		NMG_ACTION_VFY_EXT },
	{ /* RIGHT,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,LEFT */	NMG_STATE_IN,		NMG_ACTION_NONE },
d707 11
a717 5
	{ /* RIGHT,ON */	NMG_STATE_ON_R,		NMG_ACTION_VFY_EXT },
	{ /* ON,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON,LEFT */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON,RIGHT */	NMG_STATE_ON_R,		NMG_ACTION_VFY_EXT },
	{ /* ON,ON */		NMG_STATE_ERROR,	NMG_ACTION_ERROR }
d720 1
a720 6
static CONST struct state_transitions nmg_state_is_on_L[16] = {
	{ /* 0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LONE */		NMG_STATE_ON_L,		NMG_ACTION_LONE_V_ESPLIT },
	{ /* 2 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* 3 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LEFT,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d723 2
a724 2
	{ /* LEFT,ON */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d727 11
a737 5
	{ /* RIGHT,ON */	NMG_STATE_ON_B,		NMG_ACTION_VFY_EXT },
	{ /* ON,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON,LEFT */		NMG_STATE_OUT,		NMG_ACTION_NONE },
	{ /* ON,RIGHT */	NMG_STATE_IN,		NMG_ACTION_NONE },
	{ /* ON,ON */		NMG_STATE_ON_L,		NMG_ACTION_NONE }
d740 1
a740 6
static CONST struct state_transitions nmg_state_is_on_R[16] = {
	{ /* 0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LONE */		NMG_STATE_ON_R,		NMG_ACTION_LONE_V_ESPLIT },
	{ /* 2 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* 3 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LEFT,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d743 2
a744 2
	{ /* LEFT,ON */		NMG_STATE_ON_B,		NMG_ACTION_VFY_EXT },
	{ /* RIGHT,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d747 11
a757 5
	{ /* RIGHT,ON */	NMG_STATE_OUT,		NMG_ACTION_NONE },
	{ /* ON,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON,LEFT */		NMG_STATE_IN,		NMG_ACTION_NONE },
	{ /* ON,RIGHT */	NMG_STATE_OUT,		NMG_ACTION_NONE },
	{ /* ON,ON */		NMG_STATE_ON_R,		NMG_ACTION_NONE }
d759 1
a759 6
static CONST struct state_transitions nmg_state_is_on_B[16] = {
	{ /* 0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LONE */		NMG_STATE_ON_B,		NMG_ACTION_LONE_V_ESPLIT },
	{ /* 2 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* 3 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LEFT,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d762 2
a763 2
	{ /* LEFT,ON */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d766 11
a776 5
	{ /* RIGHT,ON */	NMG_STATE_ON_L,		NMG_ACTION_NONE },
	{ /* ON,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON,LEFT */		NMG_STATE_ON_R,		NMG_ACTION_NONE },
	{ /* ON,RIGHT */	NMG_STATE_ON_L,		NMG_ACTION_NONE },
	{ /* ON,ON */		NMG_STATE_ON_B,		NMG_ACTION_NONE }
d779 1
a779 6
static CONST struct state_transitions nmg_state_is_in[16] = {
	{ /* 0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LONE */		NMG_STATE_IN,		NMG_ACTION_LONE_V_JAUNT },
	{ /* 2 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* 3 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* LEFT,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d782 2
a783 2
	{ /* LEFT,ON */		NMG_STATE_ON_R,		NMG_ACTION_CUTJOIN },
	{ /* RIGHT,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d786 11
a796 5
	{ /* RIGHT,ON */	NMG_STATE_ON_L,		NMG_ACTION_CUTJOIN },
	{ /* ON,0 */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON,LEFT */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* ON,ON */		NMG_STATE_ERROR,	NMG_ACTION_ERROR }
d799 3
d803 1
a803 1
nmg_face_state_transition( vu, rs, pos )
d806 1
d848 1
d879 7
@


2.7
log
@Improved debugging, fixed assessment names[] names.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.6 91/04/02 01:59:58 mike Exp $ (BRL)";
d47 1
a47 1
static char *state_names[] = {
d57 44
d196 5
a317 44
#define NMG_E_ASSESSMENT_LEFT		1
#define NMG_E_ASSESSMENT_RIGHT		2
#define NMG_E_ASSESSMENT_ON		3

#define NMG_V_ASSESSMENT_LONE		1
#define NMG_V_ASSESSMENT_COMBINE(_p,_n)	(((_p)<<2)|(_n))

static char *nmg_v_assessment_names[16] = {
	"ASSESS_0",
	"LONE",
	"ASSESS_2",
	"ASSESS_3",
	"Left,0",
	"Left,Left",
	"Left,Right",
	"Left,On",
	"Right,0",
	"Right,Left",
	"Right,Right",
	"Right,On",
	"On,0",
	"On,Left",
	"On,Right",
	"On,On"
};

static char *nmg_e_assessment_names[4] = {
	"*ERROR*",
	"LEFT",
	"RIGHT",
	"ON"
};

struct nmg_ray_state {
	struct vertexuse	**vu;		/* ptr to vu array */
	int			nvu;		/* len of vu[] */
	point_t			pt;		/* The ray */
	vect_t			dir;
	vect_t			left;		/* points left of ray, on face */
	int			state;
	vect_t			ang_x_dir;	/* x axis for angle measure */
	vect_t			ang_y_dir;	/* y axis for angle measure */
};

d431 2
a432 2
	struct loopuse	*lu;
	fastf_t		max_angle;
d661 1
a661 1
			state_names[rs.state] );
d826 2
a827 2
vu, state_names[old], nmg_v_assessment_names[assessment],
state_names[stp->new_state], action_names[stp->action] );
d947 2
@


2.6
log
@Improved debugging
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.5 91/04/01 23:14:17 mike Exp $ (BRL)";
d276 1
a276 1
static char *nmg_e_assessment_names[16] = {
d295 1
a295 1
static char *nmg_v_assessment_names[4] = {
d357 1
d384 1
a384 1
		nmg_v_assessment_names[ret] );
d414 2
d491 1
a491 1
			i, rs->vu[i], rs->vu[i]->v_p, nmg_e_assessment_names[ass] );
d821 1
a821 1
vu, state_names[old], nmg_e_assessment_names[assessment],
@


2.5
log
@Fixed some nits in the state table.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.4 91/04/01 20:43:38 mike Exp $ (BRL)";
d276 1
a276 1
static char *assessment_names[16] = {
d295 7
a326 1
	struct vertexuse	*thisvu;
d328 1
a328 1
	struct vertexuse	*othervu;
d331 1
d334 2
a335 2
	thisvu = eu->vu_p;
	v = thisvu->v_p;
d346 2
a347 1
			return NMG_E_ASSESSMENT_ON;
d350 2
a351 2
		othervu = othereu->vu_p;
	} while( othervu->v_p == v );
d353 4
a356 1
	/*  If the othervu is on the ray list, edge is "on" the ray.
d358 6
a363 5
#if 0
	if( forw )  {
		for( i=pos+1; i<rs->nvu; i++ )  {
			if( rs->vu[i] == othervu )
				return NMG_E_ASSESSMENT_ON;
a364 5
	} else {
		for( i=pos-1; i >= 0; i-- )  {
			if( rs->vu[i] == othervu )
				return NMG_E_ASSESSMENT_ON;
		}
a365 13
#else
	/* 
	 * For now, just scan the whole vertexuse list.
	 * There is a slight possibility that loop/face orientation might
	 * also play a factor in choosing the correct scan direction.
	 */
	for( i=rs->nvu-1; i >= 0; i-- )  {
		if( rs->vu[i] == othervu )  {
rt_log("ON: vu[%d]=x%x othervu=x%x, i=%d\n", pos, rs->vu[pos], othervu, i );
			return NMG_E_ASSESSMENT_ON;
		}
	}
#endif
d371 2
a372 2
VPRINT("assess_eu from", thisvu->v_p->vg_p->coord);
VPRINT("          to  ", othervu->v_p->vg_p->coord);
d374 1
a374 1
	VSUB2( heading, othervu->v_p->vg_p->coord, thisvu->v_p->vg_p->coord );
d376 3
a378 1
		return NMG_E_ASSESSMENT_RIGHT;
d380 5
a384 1
	return NMG_E_ASSESSMENT_LEFT;
d488 1
a488 1
			i, rs->vu[i], rs->vu[i]->v_p, assessment_names[ass] );
d604 7
a618 1
nmg_pr_vu_briefly(vu[i], (char *)0);
d818 1
a818 1
vu, state_names[old], assessment_names[assessment],
d826 4
d831 1
@


2.4
log
@Split out rt_angle_measure.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.3 91/04/01 20:04:54 mike Exp $ (BRL)";
d568 2
a569 1
rt_log("nmg_face_combine(fu1=x%x, fu2=x%x)\n", fu1, fu2);
d612 1
d694 1
a694 1
	{ /* ON,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d710 1
a710 1
	{ /* RIGHT,ON */	NMG_STATE_ON_B,		NMG_ACTION_NONE },
d725 1
a725 1
	{ /* LEFT,ON */		NMG_STATE_ON_B,		NMG_ACTION_NONE },
d729 1
a729 1
	{ /* RIGHT,ON */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d747 1
a747 1
	{ /* RIGHT,ON */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
@


2.3
log
@Loops now go CCW, they way they were supposed to.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.3 91/04/01 20:03:33 mike Exp $ (BRL)";
d171 1
a171 1
 *			N M G _ V U _ A N G L E _ M E A S U R E
d173 2
a174 4
 *  Given a vertexuse from a loop which lies in a plane,
 *  compute the vector 'vec' from the previous vertex to this one.
 *  Using two perpendicular vectors (x_dir and y_dir) which both lie
 *  in the plane of the loop, return the angle (in radians) of 'vec'
d184 1
a184 1
 *  this routine, wishing to sort edges by angle from x_dir.
d189 2
a190 1
 *  If theta is greater than two pi, that's OK
d197 37
a245 2
	fastf_t		xproj, yproj;
	fastf_t		gamma;
d263 1
a263 8
	xproj = -VDOT( vec, x_dir );
	yproj = -VDOT( vec, y_dir );
	gamma = atan2( yproj, xproj );	/* -pi..+pi */
	ang = rt_pi + gamma;		/* 0..+2pi */
	if( ang < 0 )  {
rt_log("ang=0, ang was %e\n", ang);
		return 0;
	}
@


2.2
log
@Added on_B state
@
text
@a14 6
 *  Warning XXX -
 *	XXX While everybody else has loops travel in the counter-clockwise
 *	XXX direction, for the time being, Lee has NMG loops traveling in
 *	XXX the clockwise direction.  While this will (probably) be
 *	XXX corrected before the release, it is programmed around, here.
 *
d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 2.1 91/03/30 05:40:03 mike Exp $ (BRL)";
d333 2
a334 2
	/* Since edges go the wrong way right now (CW rather than CCW),
	 * just scan the whole vertexuse list.
a569 1
#if 0
a572 5
#else
	/* For measuring angle CW around plane from -dir */
	VREVERSE( rs.ang_x_dir, dir );
	VMOVE( rs.ang_y_dir, rs.left );
#endif
@


2.1
log
@State-machine algorithm.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 1.9 91/03/26 00:51:04 mike Exp $ (BRL)";
d51 2
a52 1
#define NMG_STATE_IN		4
d58 1
d326 1
d338 13
d547 1
a547 1
rt_log("nmg_face_combine()\n");
d570 1
d628 5
d692 2
a693 2
	{ /* RIGHT,RIGHT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
	{ /* RIGHT,ON */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d706 1
a706 1
	{ /* LEFT,LEFT */	NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d708 1
a708 1
	{ /* LEFT,ON */		NMG_STATE_ERROR,	NMG_ACTION_ERROR },
d718 18
d786 3
@


1.11
log
@Improved tbl_vsort slightly.
@
text
@d4 2
a5 1
 *	Routines to combine loops
d7 16
a22 1
 *  Author -
d31 1
a31 1
 *	This software is Copyright (C) 1989 by the United States Army.
d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 1.10 91/03/28 01:03:35 mike Exp $ (BRL)";
d46 17
a62 1
/*	J U S T G R A Z I N G
d64 5
a68 2
 *	Find the relationship (grazing/crossing) of the edge/loop
 *	associated with a vertex with respect to a given plane.
d70 2
a71 11
 *      vu is a vertexuse of an edge which is in turn a part of a loop.
 *      The vertex under vu lies on the plane "pl".  The edge whith which
 *      vu is associated may either approach the plane, or lie within the
 *      plane.  In either case the loop which this edge is a part of has
 *      verticies on the plane, and to at least one side of the plane.  If
 *      it only has verticies to one side, the loop is said to "graze" the
 *      plane (i.e. is tangential to the plane)
 *
 *	explicit Return:
 *		Zero		loop crosses plane at vu
 *		Non-Zero	loop does not cross plane at vu
d73 9
a81 4
static int justgrazing(pl, vu, b)
plane_t pl;
struct vertexuse *vu;
struct nmg_ptbl *b;
d83 5
a87 4
	point_t pt;
	fastf_t next_class,	/* classification of nextward and lastward */
		last_class;	/* points not on given plane */
	struct edgeuse *eun, *eul;
d89 5
a93 2
	if (rt_g.NMG_debug & DEBUG_GRAZING)
		rt_log("justgrazing:\n");
d95 13
a107 6
	NMG_CK_VERTEXUSE(vu);
	if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )  {
		/* This is sometimes a loop of a single vertex */
		rt_log("justgrazing() vu->up is not edgeuse, (%s) skipping\n",
			rt_identify_magic(*vu->up.magic_p));
		return(1);
a108 1
	NMG_CK_EDGEUSE(vu->up.eu_p);
d110 4
d115 28
a142 4
	if (rt_g.NMG_debug & DEBUG_GRAZING) {
		VPRINT("\tVertex", vu->v_p->vg_p->coord);
		PLPRINT("\tplane", pl);
	}
d144 4
a147 11
	/* We look at successively "next" edgeuses looking for one whose
	 * vertex does not lie on the given plane.
	 *
	 * First we skip over all the points which are "topologically" on 
	 * the given plane
	 */
	next_class = 0.0;
	eun = RT_LIST_PNEXT_CIRC(edgeuse, &vu->up.eu_p->l);
	while (nmg_in_or_ref(eun->vu_p, b) && eun != vu->up.eu_p) {
		eun = RT_LIST_PNEXT_CIRC(edgeuse, &eun->l);
	}
d149 4
a152 12
	if (eun == vu->up.eu_p) return (1);

	/* Just to be sure, we do some geometry checking to make sure the
	 * point we end up with is NOT on the plane
	 */
	VMOVE(pt, eun->vu_p->v_p->vg_p->coord);
	next_class = NMG_DIST_PT_PLANE(pt, pl);
	while (NEAR_ZERO(next_class, VDIVIDE_TOL) && eun != vu->up.eu_p) {
		eun = RT_LIST_PNEXT_CIRC(edgeuse, &eun->l);

		VMOVE(pt, eun->vu_p->v_p->vg_p->coord);
		next_class = NMG_DIST_PT_PLANE(pt, pl);
d154 1
d156 6
d163 7
a169 3
	if (rt_g.NMG_debug & DEBUG_GRAZING) {
		VPRINT("\tNext_pt", pt);
		rt_log("\t\tdistance: %g\n", next_class);
d171 2
d174 43
a216 1
	if (eun == vu->up.eu_p) return (1);
d218 3
a220 16
	/* We look at successively "last" edgeuses looking for one whose
	 * vertex does not lie on the given plane.
	 */
	eul = RT_LIST_PLAST_CIRC(edgeuse, &vu->up.eu_p->l);
	NMG_CK_EDGEUSE(eul);
	last_class = 0.0;
	while (nmg_in_or_ref(eul->vu_p, b) && eul != vu->up.eu_p)
		eul = RT_LIST_PLAST_CIRC(edgeuse, eul);

	if (eul == vu->up.eu_p) return (1);
	VMOVE(pt, eul->vu_p->v_p->vg_p->coord);
	last_class = NMG_DIST_PT_PLANE(pt, pl);
	while (NEAR_ZERO(last_class, VDIVIDE_TOL) && eul != vu->up.eu_p) {
		eul = RT_LIST_PLAST_CIRC(edgeuse, eul);
		VMOVE(pt, eul->vu_p->v_p->vg_p->coord);
		last_class = NMG_DIST_PT_PLANE(pt, pl);
d222 18
a239 8


	if (rt_g.NMG_debug & DEBUG_GRAZING) {
		VPRINT("\tLast_pt", pt);
		rt_log("\t\tdistance: %g\n", last_class);

		rt_log("grazecheck Next dist:%g Last dist:%g\n",
			next_class, last_class);
d241 4
d246 3
d250 2
a251 2
	if (last_class <= 0.0 && next_class <= 0.0 ||
	    last_class >= 0.0 && next_class >= 0.0) {
d253 18
a270 2
	    	if (rt_g.NMG_debug & DEBUG_GRAZING)
		    	rt_log("\tgrazing\n");
d272 10
a281 2
		return(1);
	}
d283 2
a284 8
    	if (rt_g.NMG_debug & DEBUG_GRAZING)
	    	rt_log("\tnot grazing\n");

	return(0);
}


/*	S K I P P T S
d286 3
a288 2
 *	Skip points which are sole children of loopuses.
 *	this is a support routine for the routine "combine"
d290 6
a295 4
static int skippts(i, b, plane_eq)
int i;
struct nmg_ptbl *b;
plane_t plane_eq;
d297 6
a302 5
	union {
		struct vertexuse **v;
		long **l;
	} vu;
	struct edgeuse *eu_forw, *eu_back;
d304 17
a320 1
	vu.l = b->buffer;
d322 12
a333 91
	for (; i < b->end ; ++i)
		if (*vu.v[i]->up.magic_p == NMG_LOOPUSE_MAGIC ) {

			/* mark loopuse for later deletion */
			vu.v[i]->up.lu_p->lumate_p->orientation =
				vu.v[i]->up.lu_p->orientation = OT_BOOLPLACE;

			if (rt_g.NMG_debug & DEBUG_COMBINE)
				rt_log("\tBoolplace'ing: #%d (%g, %g, %g)\n", i,
					vu.v[i]->v_p->vg_p->coord[0],
					vu.v[i]->v_p->vg_p->coord[1],
					vu.v[i]->v_p->vg_p->coord[2]);

			continue;
		}else if (*vu.v[i]->up.magic_p == NMG_SHELL_MAGIC) {
			rt_log("in %s at %d splitting edge of shell??\n",
				__FILE__, __LINE__);
			rt_bomb("BAD NMG pointer");
		} else if (*vu.v[i]->up.magic_p == NMG_EDGEUSE_MAGIC) {
			/* if we are just grazing a single point here
			 * we can skip this point.  Otherwise, this is
			 * our terminal condition.
			 */

			/* if the verticies of the last and next edgeuse
			 * are not in the list, and we are grazing at this
			 * point, we can skip this point. Example:
			 *
			 *    *---------
			 *     \
			 *  __*_\
			 *  __*_>\
			 *	 /
			 *	/
			 *     /
			 *    *---------
			 */
			eu_forw = RT_LIST_PNEXT_CIRC(edgeuse,
				&vu.v[i]->up.eu_p->l);

			eu_back = RT_LIST_PNEXT_CIRC(edgeuse,
				&vu.v[i]->up.eu_p->l);

			if (nmg_in_or_ref(eu_back->vu_p, b) || 
			    nmg_in_or_ref(eu_forw->vu_p, b) ||
			    ! justgrazing(plane_eq, vu.v[i], b) )
				break;

			if (rt_g.NMG_debug & DEBUG_COMBINE)
				VPRINT("Skippt: skipping \"graze\" edgevert",
					vu.v[i]->v_p->vg_p->coord);
		} else
			rt_bomb("Bogus vertexuse parent");
	return(i);
}

/*	N I T Z		(another wonderful function name! ;-) )
 *
 *	This function divides a loop between a pair of vertexuses/edgeuse
 *	causing the loop to become two loops with a co-incident edge.
 */
static void nitz(i, b, vu, plane_eq)
int *i;
struct nmg_ptbl *b;
struct vertexuse **vu;
plane_t plane_eq;
{				
	int j = *i + 1;
	register struct edgeuse *eu_next,
				*eu_last,
				*eu;

	if (rt_g.NMG_debug & DEBUG_COMBINE)
		rt_log("nitz\n");

	eu = vu[*i]->up.eu_p;
	eu_next = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);
	eu_last = RT_LIST_PLAST_CIRC(edgeuse, &eu->l);

	if (vu[j] == eu_next->vu_p 
	    || vu[j] == eu_last->vu_p
	    || vu[j] == eu->eumate_p->vu_p 
	    || vu[j] == eu_last->eumate_p->vu_p) {
		/* both vertices are a part of the
		 * same linear edge, so we just move forward
		 * along the edge.
		 */
		if (rt_g.NMG_debug & DEBUG_COMBINE)
	    		rt_log("\tBoth verts are part of same linear edge\n");
	    	*i = j;
		return;
d336 2
a337 2
	/* classify this loop intersect as
	 * either grazing or cutting accross the plane of intersection
d339 7
a345 17
	if (justgrazing(plane_eq, vu[*i], b)) {
		/* We're just grazing this loop.
		 * so we skip to next point
		 */

		if (rt_g.NMG_debug & DEBUG_COMBINE)
			rt_log("\t a graze\n");

		*i = j;
	} else {
		/* We're cutting accross this
		 * loop
		 * we must divide it in twain
		 * from vu[*i] to vu[j]
		 */
		nmg_cut_loop(vu[*i], vu[j]);
		*i = j + 1;
d347 1
d349 3
a351 5
/*	T R Y _ S W I T C H
 *
 * check to see if a little HARMLESS re-ordering of the vertex list 
 * will allow us to do a "simple loop division" instead of a more complex
 * loop-join or a stupid loopouse-point insert
d353 4
a356 3
static int try_switch(i, j, lim, vul)
int i, j, lim;
struct vertexuse **vul;
d358 6
a363 3
	int next;
	struct vertexuse *tvu;
	pointp_t p1;
d365 4
a368 23
	/* while not past end of list && coords still ~= */
	p1 = vul[j]->v_p->vg_p->coord;

	next = j + 1;

#if 1
	while (next < lim && vul[next]->v_p == vul[j]->v_p) {
#else
	while (next < lim && (vul[next]->v_p == vul[j]->v_p ||
	    VAPPROXEQUAL(p1, vul[next]->v_p->vg_p->coord, tol)) {
#endif
		/* if next vertexuse is under edgeuse of same loop */
		if (*vul[next]->up.magic_p == NMG_EDGEUSE_MAGIC &&
		    vul[next]->up.eu_p->up.magic_p ==
		    vul[i]->up.eu_p->up.magic_p) {

		    	/* switch the vertexuses in the list "vul" */
			tvu = vul[i+1];
			vul[i+1] = vul[next];
			vul[next] = tvu;
			return(1);
		    }
		++next;
d370 7
a376 1
	return(0);
d379 13
a391 1
/*	A B S O R B _ P T
d393 1
a393 3
 *	We're going to deal with the case where we link a lone vertex
 *	(a vertexuse of a loopuse) into a face/loop/edge.  This is to support
 *	the "combine" function.
d395 3
a397 5
 *	Explicit Return:	indication of what next point in combine
 *				proceedure should be.
 *
 *		1	new first point is first edge point past vu[i+1]
 *		0	new first point is vu[i+1]
d399 4
a402 5
static int absorb_pt(i, b, vu, fu2)
int *i;
struct nmg_ptbl *b;
struct vertexuse **vu;
struct faceuse *fu2;
d404 2
a405 5
	plane_t pl;
	struct edgeuse *eu;
	struct edgeuse	*eu_next;
	struct edgeuse	*eu_last;
	int j = *i + 1;
d407 4
a410 11
	VMOVEN(pl, fu2->f_p->fg_p->N, 4);
	/* check to see if a little harmless
	 * re-ordering of the vertex list would turn
	 * this into a "simple loop division"
	 */
	if (try_switch(*i, j, b->end, vu)) {
		if (*vu[*i]->up.magic_p == NMG_LOOPUSE_MAGIC &&
			(struct vertexuse *)vu[*i]->up.lu_p->down_hd.forw != vu[*i])
			rt_bomb("I'm not taking this shit!\n");
		nitz(i, b, vu, pl);
		return(1);
d412 5
d418 18
a435 6
	if (rt_g.NMG_debug & DEBUG_COMBINE) {
		rt_log("absorb_pt\n");
		if (*vu[*i]->up.magic_p == NMG_LOOPUSE_MAGIC &&
			(struct vertexuse *)vu[*i]->up.lu_p->down_hd.forw != vu[*i])
			rt_bomb("I'm still not taking this shit!\n");
	}
d437 6
a442 30
	/* if point is along edge from p.vu[i]		.____,_____.
	 *	we split that edge with the point
	 *	and start again from vu[j]
	 * else if point is inside loop		      \
	 *	we insert a "jaunt" to that point	._.
	 *	and start again from vu[j]		|,|
	 *						!_!
	 * else	(point is outside loop)			   \
	 *	discard vu[j] and p.vu[i] as candidates
	 *     \
	 *  .___.	._.
	 *  |	|	| |
	 *  |	| ,	| |
	 *  |	!__.____! |
	 *  |	    \	  |
	 *  !________.____!	
	 *	      \
	 *
	 * Note: Comma is vu[j], Period/Exclamation-base is other (vu[i]?)
	 *	vertex
	 *
	 *
	 * We determine if vu[j] is along one of the edges from vu[i] by
	 * looking for the other endpoints of the edges in the intersection
	 * list.  If one of these points come after vu[j] then we know that
	 * the edge runs along the plane of intersection
	 */
	eu = vu[*i]->up.eu_p;
	eu_next = RT_LIST_PNEXT_CIRC(edgeuse, eu);
	eu_last = RT_LIST_PLAST_CIRC(edgeuse, eu);
d444 10
a453 6
	if (nmg_tbl(b, TBL_LOC, &eu_next->vu_p->l.magic) >= j ) {
		/* splitting in the "next" direction */
		(void)nmg_esplit(vu[j]->v_p, eu->e_p);

		/* replace the loop vertex in the list
		 * with the one we just created.
d455 25
a479 3
		nmg_klu(vu[j]->up.lu_p);
		eu_next = RT_LIST_PNEXT_CIRC(edgeuse, eu);
		vu[j] = eu_next->vu_p;
d481 4
a484 10
	else if (nmg_tbl(b, TBL_LOC, &eu_last->vu_p->l.magic) >= j) {
		/* splitting in the "last" direction */
		(void)nmg_esplit(vu[j]->v_p, eu_last->e_p);

		/* replace the loop vertex in the list
		 * with the one we just created. 
		 */
		nmg_klu(vu[j]->up.lu_p);
		eu_last = RT_LIST_PLAST_CIRC(edgeuse, eu);
		vu[j] = eu_last->vu_p;
d486 5
a490 8
	else if (!justgrazing(pl, vu[*i], b)) {
		/* point does NOT lie along an existing edge, but DOES lie on
		 * the interior of the loop, so we will
		 * have to build a "jaunt" or "spike" into the edge of the
		 * current loop.
		 */
		if (((struct vertexuse *)(vu[j]->up.lu_p->down_hd.forw)) != vu[j])
			rt_bomb("vertexuse has lost parent 1\n");
d492 2
a493 1
		eu = nmg_eins(eu);		  /* insert 0 length edge */
d495 5
a499 1
		eu = nmg_eusplit(vu[j]->v_p, eu); /* split it to new point */
d501 3
a503 10
		eu_last = RT_LIST_PLAST_CIRC(edgeuse, eu);
		/* make uses share edge */
		nmg_moveeu(eu, eu_last);

		nmg_klu(vu[j]->up.lu_p);
		vu[j] = eu->vu_p;
	} else {
		/* point lies on exterior of loop */
		*i = j;
		return(1);
d505 1
a505 2

	return(0);
d508 2
a509 1
/*	C O M B _ L O O P S
d511 1
a511 2
 *	Two loops (presumably an interior and an exterior) are being joined
 *	along a (new) edge that runs between them.
a512 3
 *	This routine and the routine to join loops of the same face which
 *	are the only uses of a common edge should be coded and tested at the
 *	same time.
d514 7
a520 4
static int comb_loops(plane_eq, vu1, vu2, b)
plane_t plane_eq;
struct vertexuse *vu1, *vu2;
struct nmg_ptbl *b;
d522 8
a529 6
	/* if ( We are cutting accross both loops )
	 *	join loops at intersection points
	 *	start next line at j+1
	 * else ( cutting first and tangenting second)
	 *	1) join loops, start next line at j
	 */
d531 3
d535 5
a539 2
	if (rt_g.NMG_debug & DEBUG_COMBINE)
		rt_log("comb_loops\n");
d541 5
a545 2
	/* if we're just grazing the first loop, we don't
	 * really want to join the loops together. 
d547 11
a557 16
	if (justgrazing(plane_eq, vu1, b)) return(0);
	else if (justgrazing(plane_eq, vu2, b)) {
		/* we're crossing one loop, but grazing the inside one.
		 * We join them together & continue from the second point
		 * onward.
		 */
		rt_bomb("Can't do this yet");
		return(0);
	} else {
		/* we're crossing both loops.  We join them together and
		 * then continue from the point AFTER the second point.
		 */
		rt_bomb("Can't do this yet.  Shouldn't need to");
		return(1);
	}
}
d559 9
a567 20
/*	C H E C K _ V E R T L I N K
 *
 *	The two verticies starting at *i_p in the table share the same vertex.
 *	pick which one we should ignore.
 */
static void check_vertlink(i_p, b)
int *i_p;
struct nmg_ptbl *b;
{
	int i, j, k;
	struct loopuse *lu_i, *lu_j;
	struct loopuse *lu_k = (struct loopuse *)0;
	struct edgeuse *eu_next;
	struct vertexuse *tvu;
	struct edgeuse	*eu_jnext;
	struct edgeuse	*eu_inext;
	union {
		long **l;
		struct vertexuse **v;
	} vul;
d569 1
a569 2
	if (rt_g.NMG_debug & DEBUG_COMBINE)
		rt_log("check_vertlink (%d)\n", *i_p);
d571 6
a576 9
	vul.l = b->buffer;
	j = (i = *i_p) +1;

	eu_jnext = RT_LIST_PNEXT_CIRC(edgeuse, &vul.v[j]->up.eu_p->l);
	eu_inext = RT_LIST_PNEXT_CIRC(edgeuse, &vul.v[i]->up.eu_p->l);

	/* if the "j" vertexuse is for edgeuse and the vertexuse at the
	 * other end of the edgeuse is in the list "after" j, then we toss
	 * out the "i" vertexuse and go onward
d578 11
a588 5
	if (*vul.v[j]->up.magic_p == NMG_EDGEUSE_MAGIC &&
	    nmg_tbl(b, TBL_LOC, (long *)eu_jnext->vu_p) > j) {
		/* ignore i */
		if (rt_g.NMG_debug & DEBUG_COMBINE)
			rt_log("\tignore i (%d) for j (%d)\n", i, j);
d590 19
a608 17
	    	/* if "i" was a "temporary" loopuse, take care of
	    	 * tagging it as "not-in-use"
	    	 */
	    	if (*vul.v[i]->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    vul.v[i]->up.lu_p->orientation == OT_UNSPEC) {
			lu_i = vul.v[i]->up.lu_p;
			lu_i->orientation = 
			lu_i->lumate_p->orientation = OT_BOOLPLACE;

		    	if (rt_g.NMG_debug & DEBUG_COMBINE)
				rt_log("\tBoolplace'ing: #%d (%g, %g, %g)\n", i,
					vul.v[i]->v_p->vg_p->coord[0],
					vul.v[i]->v_p->vg_p->coord[1],
					vul.v[i]->v_p->vg_p->coord[2]);
	    	}
	    		
	    	*i_p = j;
d611 2
a612 12
	/* if the "i" vertexuse is for edgeuse and the vertexuse at the
	 * other end of the edgeuse is in the list "after" j, then we toss
	 * out the "j" vertexuse and go onward
	 */
	if (*vul.v[i]->up.magic_p == NMG_EDGEUSE_MAGIC &&
	    nmg_tbl(b, TBL_LOC, (long *)eu_inext->vu_p) > j) {
		/* switch i & j to ignore j */
		if (rt_g.NMG_debug & DEBUG_COMBINE)
			rt_log("\tswitch i(%d) & j(%d) to ignore j\n", i, j);
		tvu = vul.v[j];
		vul.v[j] = vul.v[i];
		vul.v[i] = tvu;
d614 4
a617 8
	    	/* if this was a "temporary" loopuse, take care of
	    	 * tagging it as "not-in-use"
	    	 */
	    	if (*vul.v[i]->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    vul.v[i]->up.lu_p->orientation == OT_UNSPEC) {
			lu_i = vul.v[i]->up.lu_p;
			lu_i->orientation = 
			lu_i->lumate_p->orientation = OT_BOOLPLACE;
d619 15
a633 6
		    	if (rt_g.NMG_debug & DEBUG_COMBINE)
				rt_log("\tBoolplace'ing: #%d (%g, %g, %g)\n", i,
					vul.v[i]->v_p->vg_p->coord[0],
					vul.v[i]->v_p->vg_p->coord[1],
					vul.v[i]->v_p->vg_p->coord[2]);
	    	}
d635 4
d640 18
a657 1
		*i_p = j;
d659 18
a676 4
	} else {
		/* neither edgeuse has the "next" vertexuse in the list of
		 * points on the intersection line
		 */
d678 18
a695 2
		lu_i = nmg_lu_of_vu(vul.v[i]);
		lu_j = nmg_lu_of_vu(vul.v[j]);
d697 18
a714 9
		/* look forward for a vertex of either loop */
		for (k = j; k < b->end ; ++k) {
		    	lu_k = nmg_lu_of_vu(vul.v[k]);
			if (lu_k == lu_i || lu_k == lu_j) break;
			else if (lu_k != lu_i && lu_k != lu_j &&
			    RT_LIST_FIRST_MAGIC(&lu_k->down_hd) != NMG_VERTEXUSE_MAGIC) {
				rt_bomb("ought to be restarting edge joins on new loop\n");
			}
	    	}
d716 14
a729 10
		/* if there's another vertex in the loop of "i" before there's
		 *  another vertex in the loop of "j", we use the "i"
		 * vertexuse, and skip the "j" vertexuse
		 */
		if (lu_k == lu_i) {
			if (rt_g.NMG_debug & DEBUG_COMBINE)
				rt_log("\tuse to i's (%d) loop (discard j:%d)", i, j);
			tvu = vul.v[j];
			vul.v[j] = vul.v[i];
			vul.v[i] = tvu;
d731 23
a753 14
		    	/* if this was a "temporary" loopuse, take care of
		    	 * tagging it as "not-in-use"
	    		 */
		    	if (*vul.v[i]->up.magic_p == NMG_LOOPUSE_MAGIC &&
			    vul.v[i]->up.lu_p->orientation == OT_UNSPEC) {
				lu_i = vul.v[i]->up.lu_p;
				lu_i->orientation = 
				lu_i->lumate_p->orientation = OT_BOOLPLACE;
			    	if (rt_g.NMG_debug & DEBUG_COMBINE)
					rt_log("\tBoolplace'ing: #%d (%g, %g, %g)\n", i,
						vul.v[i]->v_p->vg_p->coord[0],
						vul.v[i]->v_p->vg_p->coord[1],
						vul.v[i]->v_p->vg_p->coord[2]);
		    	}
d755 59
a813 1
			*i_p = j;
d815 7
a821 3
		} else if (lu_k == lu_j) {
			if (rt_g.NMG_debug & DEBUG_COMBINE)
				rt_log("\t(discard i:%d)use to j's (%d)loop\n", i, j);
d823 4
a826 14
		    	/* if this was a "temporary" loopuse, take care of
		    	 * tagging it as "not-in-use"
	    		 */
		    	if (*vul.v[i]->up.magic_p == NMG_LOOPUSE_MAGIC &&
			    vul.v[i]->up.lu_p->orientation == OT_UNSPEC) {
				lu_i = vul.v[i]->up.lu_p;
				lu_i->orientation = 
				lu_i->lumate_p->orientation = OT_BOOLPLACE;
			    	if (rt_g.NMG_debug & DEBUG_COMBINE)
					rt_log("\tBoolplace'ing: #%d (%g, %g, %g)\n", i,
						vul.v[i]->v_p->vg_p->coord[0],
						vul.v[i]->v_p->vg_p->coord[1],
						vul.v[i]->v_p->vg_p->coord[2]);
		    	}
d828 30
a857 7
			*i_p = j;

		} else
			/* neither the "i" nor "j" loops have another vertex
			 * in the list after "j"
			 */
			rt_bomb("I don't know how to doooooo this\n");
d860 1
a860 1
	return;
d864 1
a864 2
 *	T B L _ V S O R T
 *	sort list of vertices in fu1 on plane of fu2 
d866 2
a867 4
 *	W A R N I N G:
 *		This function makes gross assumptions about the contents
 *	and structure of an nmg_ptbl list!  If I could figure a way of folding
 *	this into the nmg_tbl routine, I would do it.
d869 4
a872 5
static void tbl_vsort(b, fu1, fu2, pt, dir)
struct nmg_ptbl *b;		/* table of vertexuses on intercept line */
struct faceuse	*fu1, *fu2;
point_t		pt;
vect_t		dir;
d874 6
a879 6
	union {
		struct vertexuse **vu;
		long **magic_p;
	} p;
	fastf_t	*mag;
	register int i, j;
d881 10
a890 2
	mag = (fastf_t *)rt_calloc(b->end, sizeof(fastf_t),
					"vector magnitudes for sort");
d892 3
a894 5
	p.magic_p = b->buffer;
	/* check vertexuses and compute distance from start of line */
	for(i = 0 ; i < b->end ; ++i) {
		vect_t		vect;
		NMG_CK_VERTEXUSE(p.vu[i]);
d896 2
a897 3
		VSUB2(vect, pt, p.vu[i]->v_p->vg_p->coord);
		mag[i] = VDOT( vect, dir );
	}
d899 5
a903 2
	/* a trashy bubble-head sort, because I hope this list is never
	 * very long.
d905 7
a911 5
	for(i=0 ; i < b->end - 1 ; ++i) {
		for (j=i+1; j < b->end ; ++j) {
			if (mag[i] > mag[j]) {
				register struct vertexuse *tvu;
				register fastf_t	tmag;
d913 9
a921 3
				tvu = p.vu[i];
				p.vu[i] = p.vu[j];
				p.vu[j] = tvu;
d923 7
a929 5
				tmag = mag[i];
				mag[i] = mag[j];
				mag[j] = tmag;
			}
		}
d932 4
a935 1
	rt_free((char *)mag, "vector magnitudes");
d938 2
a939 17
/*
 *			N M G _ F A C E _ C O M B I N E
 *
 *	collapse loops,vertices within face fu1 (relative to fu2)
 *
 *	At this point, we've got faces with loops on a single vertex, and
 *	we've got loops which have had edges cut in two (with a new vertex
 *	inserted in the edge) and it is time to put edges between the new
 *	vertices, thus subdividing loops and combining single-vertex loops
 *	with loops containing edges.
 */
void nmg_face_combine(b, fu1, fu2, pt, dir)
struct nmg_ptbl *b;		/* table of vertexuses in fu1 on intercept line */
struct faceuse	*fu1;		/* Face being worked */
struct faceuse	*fu2;		/* fu2 here for plane equation */
point_t		pt;		/* line of intersection */
vect_t		dir;
d941 4
a944 7
	plane_t plane_eq;	/* the plane of the other face */
	int i;
	union {
		struct vertexuse **vu;
		long **magic_p;
	} p;
	pointp_t	p1, p2;
d946 2
a947 4
	FILE *fp;
	static int pn=0;
	static char name[32];
	int vn=0;
d949 1
a949 16
	if (rt_g.NMG_debug & DEBUG_COMBINE) {
		rt_log("nmg_face_combine\n");
		if (rt_g.NMG_debug & DEBUG_PLOTEM) {
			(void)sprintf(name, "comb%d.pl", ++pn);
			rt_log("plotting %s\n", name);
			if ((fp=fopen(name, "w")) == (FILE *)NULL) {
				(void)perror(name);
				exit(-1);
			}
			tab = (long *)rt_calloc( fu1->s_p->r_p->m_p->maxindex,
				sizeof(long),
				"nmg_face_combine flags[]" );
		/*	nmg_pl_fu(fp, fu1, &tbl, 200, 20, 200);
			nmg_pl_fu(fp, fu2, &tbl, 20, 200, 200); */
		}
	}
d951 1
a951 2
	/* Sort vertexuse list */
	tbl_vsort(b, fu1, fu2, pt, dir);
d953 2
a954 10
	/* validate vertexuse list, and maybe print some useful diagnostics
	 */
	VMOVEN(plane_eq, fu2->f_p->fg_p->N, 4);
	p.magic_p = b->buffer;
	for (i=0 ; i < b->end ; ++i) {
		register struct vertexuse	*vu;
		vu = p.vu[i];
		NMG_CK_VERTEXUSE(vu);
		NMG_CK_VERTEX(vu->v_p);
		NMG_CK_VERTEX_G(vu->v_p->vg_p);
d956 3
a958 7
		if (rt_g.NMG_debug & DEBUG_COMBINE) {
			rt_log("%d\t%g, %g, %g\t", i,
				vu->v_p->vg_p->coord[X],
				vu->v_p->vg_p->coord[Y],
				vu->v_p->vg_p->coord[Z]);
			if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC) {
				register struct vertex_g *tmpvg;
d960 1
a960 3
				NMG_CK_EDGEUSE(vu->up.eu_p->eumate_p);
				NMG_CK_VERTEXUSE(vu->up.eu_p->eumate_p->vu_p);
				NMG_CK_VERTEX(vu->up.eu_p->eumate_p->vu_p->v_p);
d962 2
a963 1
				tmpvg = vu->up.eu_p->eumate_p->vu_p->v_p->vg_p;
d965 3
a967 5
				NMG_CK_VERTEX_G(tmpvg);
				rt_log("EDGEUSE -> %g, %g, %g\n",
					tmpvg->coord[0],
					tmpvg->coord[1],
					tmpvg->coord[2]);
d969 5
a973 18
				nmg_pl_eu(fp, vu->up.eu_p, tab, 180, 180, 180);

			} else if (*vu->up.magic_p == NMG_LOOPUSE_MAGIC) {
				rt_log("LOOPUSE\n");
				nmg_pl_lu(fp, vu->up.lu_p, tab, 80, 180, 100);

				if ((struct vertexuse *)vu->up.lu_p->down_hd.forw !=
					vu) {
					rt_log("vertexuse's parent disowns us!\n");
						if (((struct vertexuse *)(vu->up.lu_p->lumate_p->down_hd.forw))->l.magic == NMG_VERTEXUSE_MAGIC)
							rt_bomb("lumate has vertexuse\n");
						else
							rt_bomb("lumate has garbage\n");
				}
			} else
				rt_log("UNKNOWN\n");
		}

d975 2
a977 82
	if (rt_g.NMG_debug & DEBUG_COMBINE)  {
		rt_free( (char *)tab, "nmg_face_combine flags[]" );
		tab = (long *)0;		/* sanity */
		(void)fclose(fp);
	}

	/* We don't want to start an edge on a loop of one vertex
	 * becuase such a vertex will lie outside of the face.  Thus
	 * we go looking for the first vertex which is part of an
	 * edge-loop.		p.vu, b->end
	 */
	for (i=0 ; (i = skippts(i, b, plane_eq)) < b->end-1 ; ) {

		/* At this point we have a plausible first vertex from which
		 * to work.  Now we determine whether that
		 * vertex needs only to be inserted in an existing edge,
		 * or if we need to make a new edge and what that edge
		 * connects.
		 */
		for ( ; i < b->end-1 ; ++i) {

			if (rt_g.NMG_debug & DEBUG_COMBINE) {

			    p1 = p.vu[i]->v_p->vg_p->coord;
			    p2 = p.vu[i+1]->v_p->vg_p->coord;
			    rt_log("linking (%d) %g, %g, %g -> (%d) %g, %g, %g\n",
					i, p1[X], p1[Y], p1[Z],
					i+1, p2[X], p2[Y], p2[Z]);
			}
			if( rt_g.NMG_debug & (DEBUG_PLOTEM|DEBUG_PL_ANIM) )
				nmg_pl_comb_fu( pn, vn++, fu1 );

			if (p.vu[i]->v_p == p.vu[i+1]->v_p) {
				/* We may be cutting a face on an
				 * intersection line which is already
				 * the result of a previous plane
				 * intersection.
				 */
				check_vertlink(&i, b);
				if (rt_g.NMG_debug & DEBUG_COMBINE)
					rt_log("\tNew i: %d\n", i);
				if (i >= b->end-1) break;
			}


			if (*p.vu[i+1]->up.magic_p == NMG_LOOPUSE_MAGIC) {
				/* we're linking in a loopuse point
				 */
				if (absorb_pt(&i, b, p.vu, fu2))
					break;
			}
			else if (p.vu[i+1]->up.eu_p->up.magic_p ==
			    p.vu[i]->up.eu_p->up.magic_p) {
				/* the two edges (of the two vertexuses) are
				 * a part of the same parent (loop)
				 */
				nitz(&i, b, p.vu, plane_eq);
				break;
			} else {
				/* we're joining 2 different edge-loops
				 * together.
				 */

				/* check to see if a little harmless
				 * re-ordering of the vertex list would turn
				 * this into a "simple loop division"
				 */
				if (try_switch(i, i+1, b->end, p.vu)) {
					nitz(&i, b, p.vu, plane_eq);
					break;
				} else if (comb_loops(plane_eq, p.vu[i],
				    p.vu[i+1], b) ) {
					break;
				}
			}
		} /* for ( ; i < b->end-1 ; ++i) */
	} /* for all vertices in the list */

	if( rt_g.NMG_debug & (DEBUG_PLOTEM|DEBUG_PL_ANIM) )
		nmg_pl_comb_fu( pn, vn++, fu1 );

	nmg_face_bb(fu1->f_p);
@


1.10
log
@Imported tbl_vsort from nmg_inter.c
Added parameters to nmg_face_combine.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 1.9 91/03/26 00:51:04 mike Exp $ (BRL)";
a679 2
	point_t		min_pt;
	vect_t		vect;
d684 2
a685 3
	struct vertexuse *tvu;
	fastf_t *mag, tmag;
	int i, j;
d693 1
d697 1
a697 1
		mag[i] = MAGNITUDE(vect);
d706 3
d719 1
a719 14
	/*
	 * We should do something here to "properly"
	 * order vertexuses which share a vertex
	 * or whose coordinates are equal.
	 *
	 * Just what should be done & how is not
	 * clear to me at this hour of the night.
	 * for (i=0 ; i < b->end - 1 ; ++i) {
	 *	if (p.vu[i]->v_p == p.vu[i+1]->v_p ||
	 *	    VAPPROXEQUAL(p.vu[i]->v_p->vg_p->coord,
	 *	    p.vu[i+1]->v_p->vg_p->coord, VDIVIDE_TOL) ) {
	 *	}
	 * }
	 */
@


1.9
log
@Moved nmg_cut_loop to nmg_mk.c
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 1.8 91/03/25 22:12:23 mike Exp $ (BRL)";
d665 24
d690 2
d693 42
d746 1
a746 1
void nmg_face_combine(b, fu1, fu2)
d748 5
a752 2
struct faceuse *fu1, *fu2;	/* fu1 = face being worked, */
{				/* fu2 here for plane equation */
d783 2
@


1.8
log
@Added comment.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 1.7 91/03/02 01:27:32 mike Exp $ (BRL)";
a29 214

/*
 *			N M G _ C K _ L U E U
 *
 *	check all the edgeuses of a loopuse to make sure these children
 *	know who thier parent really is.
 */
void nmg_ck_lueu(cklu, s)
struct loopuse *cklu;
char *s;
{
	struct edgeuse *eu;

	if (RT_LIST_FIRST_MAGIC(&cklu->down_hd) == NMG_VERTEXUSE_MAGIC)
		rt_bomb("NMG nmg_ck_lueu.  I got a vertex loop!\n");

	eu = RT_LIST_FIRST(edgeuse, &cklu->down_hd);
	if (eu->l.back != &cklu->down_hd) {
		rt_bomb("nmg_ck_lueu first element in list doesn't point back to head\n");
	}

	for (RT_LIST_FOR(eu, edgeuse, &cklu->down_hd)) {
		NMG_CK_EDGEUSE(eu);
		if (eu->up.lu_p != cklu) {
			rt_log("edgeuse of %s (going next) has lost proper parent\n", s);
			rt_bomb("nmg_ck_lueu");
		}
		if ((struct edgeuse *)eu->l.forw->back != eu) {
			rt_log("%s next edge (%8x) doesn't point back to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
		if ((struct edgeuse *)eu->l.back->forw != eu) {
			rt_log("%s last edge (%8x) doesn't point forward to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
	}

	cklu = cklu->lumate_p;

	eu = RT_LIST_FIRST(edgeuse, &cklu->down_hd);
	if (eu->l.back != &cklu->down_hd) {
		rt_bomb("nmg_ck_lueu first element in lumate list doesn't point back to head\n");
	}

	for (RT_LIST_FOR(eu, edgeuse, &cklu->down_hd)) {
		NMG_CK_EDGEUSE(eu);
		if (eu->up.lu_p != cklu) {
			rt_log("edgeuse of %s (lumate going next) has lost proper parent\n", s);
			rt_bomb("nmg_ck_lueu");
		}
		if ((struct edgeuse *)eu->l.forw->back != eu) {
			rt_log("%s next edge (%8x) doesn't point back to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
		if ((struct edgeuse *)eu->l.back->forw != eu) {
			rt_log("%s (lumate) back edge (%8x) doesn't point forward to me (%8x)!\n", s, eu->l.forw, eu);
			nmg_pr_lu(cklu, NULL);
		}
	}
}


/*	C U T _ L O O P
 *	Divide a loop of edges between two vertexuses
 *
 *	we make a new loop between the two vertexes, and split it and
 *	the loop of the parametric vertexuses at the same time.
 *
 *	Old Loop      New loop	Resulting loops
 *
 *	    v1		v1	    v1
 *	    |	        |	    |\
 *	    V	        V	    V V
 *	*---*---*	*	*---* *---*
 *	|	|	|	|   | |   |
 *	|	|	|	|   | |   |
 *	*---*---*	*	*---* *---*
 *	    ^		^	    ^ ^
 *	    |	        |	    |/
 *	   v2		v2	    v2
 *
 */
static void cut_loop(vu1, vu2)
struct vertexuse *vu1, *vu2;
{
	struct loopuse *lu, *oldlu;
	struct edgeuse *eu1, *eu2, *eunext, *neweu, *eu;
	struct model	*m;
	FILE		*fd;
	char		name[32];
	static int	i=0;

	NMG_CK_VERTEXUSE(vu1);
	NMG_CK_VERTEXUSE(vu2);

	eu1 = vu1->up.eu_p;
	eu2 = vu2->up.eu_p;
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);
	oldlu = eu1->up.lu_p;
	NMG_CK_LOOPUSE(oldlu);
	if (eu2->up.lu_p != oldlu) {
		rt_log("at %d in %s vertices should be decendants of same loop\n",
			__LINE__, __FILE__);
		rt_bomb("subroutine cut_loop");
	}
	NMG_CK_FACEUSE(oldlu->up.fu_p);
	m = oldlu->up.fu_p->s_p->r_p->m_p;
	NMG_CK_MODEL(m);

	if (rt_g.NMG_debug & DEBUG_CUTLOOP) {
		rt_log("\tcut_loop\n");
		if (rt_g.NMG_debug & DEBUG_PLOTEM) {
			long		*tab;
			tab = (long *)rt_calloc( m->maxindex, sizeof(long),
				"cut_loop flag[] 1" );

			(void)sprintf(name, "Before_cutloop%d.pl", ++i);
			rt_log("plotting %s\n", name);
			if ((fd = fopen(name, "w")) == (FILE *)NULL) {
				(void)perror(name);
				exit(-1);
			}

			nmg_pl_fu(fd, oldlu->up.fu_p, tab, 100, 100, 100);
			nmg_pl_fu(fd, oldlu->up.fu_p->fumate_p, tab, 100, 100, 100);
			(void)fclose(fd);
			rt_free( (char *)tab, "cut_loop flag[] 1" );
		}
	}

	nmg_ck_lueu(oldlu, "oldlu (fresh)");

	/* make a new loop structure for the new loop & throw away
	 * the vertexuse we don't need
	 */
	lu = nmg_mlv(oldlu->up.magic_p, (struct vertex *)NULL,
		oldlu->orientation);

	nmg_kvu(RT_LIST_FIRST(vertexuse, &lu->down_hd));
	nmg_kvu(RT_LIST_FIRST(vertexuse, &lu->lumate_p->down_hd));
	/* nmg_kvu() does RT_LIST_INIT() on down_hd */

	/* move the edges into one of the uses of the new loop */
	for (eu = eu2 ; eu != eu1 ; eu = eunext) {
		eunext = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);

		RT_LIST_DEQUEUE(&eu->l);
		RT_LIST_INSERT(&lu->down_hd, &eu->l);
		RT_LIST_DEQUEUE(&eu->eumate_p->l);
		RT_LIST_APPEND(&lu->lumate_p->down_hd, &eu->eumate_p->l);
		eu->up.lu_p = lu;
		eu->eumate_p->up.lu_p = lu->lumate_p;
	}
	nmg_ck_lueu(lu, "lu check1");	/*LABLABLAB*/

	/* make an edge to "cap off" the new loop */
	neweu = nmg_me(eu1->vu_p->v_p, eu2->vu_p->v_p, nmg_eups(eu1));

	/* move the new edgeuse into the new loopuse */
	RT_LIST_DEQUEUE(&neweu->l);
	RT_LIST_INSERT(&lu->down_hd, &neweu->l);
	neweu->up.lu_p = lu;

	/* move the new edgeuse mate into the new loopuse mate */
	RT_LIST_DEQUEUE(&neweu->eumate_p->l);
	RT_LIST_APPEND(&lu->lumate_p->down_hd, &neweu->eumate_p->l);
	neweu->eumate_p->up.lu_p = lu->lumate_p;

	nmg_ck_lueu(lu, "lu check2");	/*LABLABLAB*/


	/* now we go back and close up the loop we just ripped open */
	eunext = nmg_me(eu2->vu_p->v_p, eu1->vu_p->v_p, nmg_eups(eu1));

	RT_LIST_DEQUEUE(&eunext->l);
	RT_LIST_INSERT(&eu1->l, &eunext->l);
	RT_LIST_DEQUEUE(&eunext->eumate_p->l);
	RT_LIST_APPEND(&eu1->eumate_p->l, &eunext->eumate_p->l);
	eunext->up.lu_p = eu1->up.lu_p;
	eunext->eumate_p->up.lu_p = eu1->eumate_p->up.lu_p;


	/* make sure new edgeuses are radial to each other */
	nmg_moveeu(neweu, eunext);

	nmg_ck_lueu(oldlu, "oldlu");
	nmg_ck_lueu(lu, "lu");	/*LABLABLAB*/


	if (rt_g.NMG_debug & DEBUG_CUTLOOP && rt_g.NMG_debug & DEBUG_PLOTEM) {
		long		*tab;
		tab = (long *)rt_calloc( m->maxindex, sizeof(long),
			"cut_loop flag[] 2" );

		(void)sprintf(name, "After_cutloop%d.pl", i);
		rt_log("plotting %s\n", name);
		if ((fd = fopen(name, "w")) == (FILE *)NULL) {
			(void)perror(name);
			exit(-1);
		}

		nmg_pl_fu(fd, oldlu->up.fu_p, tab, 100, 100, 100);
		nmg_pl_fu(fd, oldlu->up.fu_p->fumate_p, tab, 100, 100, 100);
		(void)fclose(fd);
		rt_free( (char *)tab, "cut_loop flag[] 2" );
	}

	nmg_loop_g(oldlu->l_p);
	nmg_loop_g(lu->l_p);
}



d282 1
a282 1
		cut_loop(vu[*i], vu[j]);
@


1.7
log
@Freed flag array a bit sooner.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 1.6 91/03/02 00:17:38 mike Exp $ (BRL)";
d171 1
@


1.6
log
@All the plotting routines changed to using flags arrays
instead of nmg_ptbl structures.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 1.5 91/02/08 02:49:24 mike Exp $ (BRL)";
d931 5
a935 3
		NMG_CK_VERTEXUSE(p.vu[i]);
		NMG_CK_VERTEX(p.vu[i]->v_p);
		NMG_CK_VERTEX_G(p.vu[i]->v_p->vg_p);
d939 4
a942 4
				p.vu[i]->v_p->vg_p->coord[X],
				p.vu[i]->v_p->vg_p->coord[Y],
				p.vu[i]->v_p->vg_p->coord[Z]);
			if (*p.vu[i]->up.magic_p == NMG_EDGEUSE_MAGIC) {
d945 3
a947 3
				NMG_CK_EDGEUSE(p.vu[i]->up.eu_p->eumate_p);
				NMG_CK_VERTEXUSE(p.vu[i]->up.eu_p->eumate_p->vu_p);
				NMG_CK_VERTEX(p.vu[i]->up.eu_p->eumate_p->vu_p->v_p);
d949 1
a949 1
				tmpvg = p.vu[i]->up.eu_p->eumate_p->vu_p->v_p->vg_p;
d957 1
a957 1
				nmg_pl_eu(fp, p.vu[i]->up.eu_p, tab, 180, 180, 180);
d959 1
a959 1
			} else if (*p.vu[i]->up.magic_p == NMG_LOOPUSE_MAGIC) {
d961 1
a961 1
				nmg_pl_lu(fp, p.vu[i]->up.lu_p, tab, 80, 180, 100);
d963 2
a964 2
				if ((struct vertexuse *)p.vu[i]->up.lu_p->down_hd.forw !=
					p.vu[i]) {
d966 1
a966 1
						if (((struct vertexuse *)(p.vu[i]->up.lu_p->lumate_p->down_hd.forw))->l.magic == NMG_VERTEXUSE_MAGIC)
d977 3
a979 1
	if (rt_g.NMG_debug & DEBUG_COMBINE)
d981 1
a1058 4

	if (rt_g.NMG_debug & DEBUG_COMBINE)  {
		rt_free( (char *)tab, "nmg_face_combine flags[]" );
	}
@


1.5
log
@nmg_identify_magic to rt_identify_magic
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 1.4 91/02/07 20:32:33 mike Exp $ (BRL)";
d117 4
a120 4
	FILE *fd;
	struct nmg_ptbl b;
	char name[32];
	static int i=0;
a121 1

a126 1

a128 5
	NMG_CK_LOOPUSE(eu1->up.lu_p);
	NMG_CK_LOOPUSE(eu2->up.lu_p);
	NMG_CK_FACEUSE(eu1->up.lu_p->up.fu_p);
	NMG_CK_FACEUSE(eu2->up.lu_p->up.fu_p);

d130 1
d136 3
d143 3
a146 2
			(void)nmg_tbl(&b, TBL_INIT, (long *)NULL);
	
d154 2
a155 2
			(void)nmg_pl_fu(fd, oldlu->up.fu_p, &b, 100, 100, 100);
			(void)nmg_pl_fu(fd, oldlu->up.fu_p->fumate_p, &b, 100, 100, 100);
d157 1
a162 5
	eu1 = vu1->up.eu_p;
	eu2 = vu2->up.eu_p;

	oldlu = eu1->up.lu_p;

d220 4
a223 1
		(void)nmg_tbl(&b, TBL_RST, (long *)NULL);
d231 2
a232 2
		(void)nmg_pl_fu(fd, oldlu->up.fu_p, &b, 100, 100, 100);
		(void)nmg_pl_fu(fd, oldlu->up.fu_p->fumate_p, &b, 100, 100, 100);
d234 1
a234 1
		(void)nmg_tbl(&b, TBL_FREE,  (long *)NULL);
d902 1
a902 1
	struct nmg_ptbl tbl;
d917 3
a919 1
			(void)nmg_tbl(&tbl, TBL_INIT, (long *)NULL);
d955 1
a955 1
				nmg_pl_eu(fp, p.vu[i]->up.eu_p, &tbl, 180, 180, 180);
d959 1
a959 1
				nmg_pl_lu(fp, p.vu[i]->up.lu_p, &tbl, 80, 180, 100);
d1055 3
a1057 2
	if (rt_g.NMG_debug & DEBUG_COMBINE)
		(void)nmg_tbl(&tbl, TBL_FREE, (long *)NULL);
@


1.4
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 1.3 91/01/12 07:23:18 mike Exp $ (BRL)";
d280 1
a280 1
			nmg_identify_magic(*vu->up.magic_p));
@


1.3
log
@lint
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 1.2 90/12/08 03:34:06 mike Exp $ (BRL)";
d43 1
a43 1
	if (NMG_LIST_FIRST_MAGIC(&cklu->down_hd) == NMG_VERTEXUSE_MAGIC)
d46 1
a46 1
	eu = NMG_LIST_FIRST(edgeuse, &cklu->down_hd);
d51 1
a51 1
	for (NMG_LIST(eu, edgeuse, &cklu->down_hd)) {
d69 1
a69 1
	eu = NMG_LIST_FIRST(edgeuse, &cklu->down_hd);
d74 1
a74 1
	for (NMG_LIST(eu, edgeuse, &cklu->down_hd)) {
d175 2
a176 2
	nmg_kvu(NMG_LIST_FIRST(vertexuse, &lu->down_hd));
	nmg_kvu(NMG_LIST_FIRST(vertexuse, &lu->lumate_p->down_hd));
d180 1
a180 1
		eunext = NMG_LIST_PNEXT_CIRC(edgeuse, &eu->l);
d182 4
a185 4
		NMG_LIST_DEQUEUE(&eu->l);
		NMG_LIST_INSERT(&lu->down_hd, &eu->l);
		NMG_LIST_DEQUEUE(&eu->eumate_p->l);
		NMG_LIST_APPEND(&lu->lumate_p->down_hd, &eu->eumate_p->l);
d195 2
a196 2
	NMG_LIST_DEQUEUE(&neweu->l);
	NMG_LIST_INSERT(&lu->down_hd, &neweu->l);
d200 2
a201 2
	NMG_LIST_DEQUEUE(&neweu->eumate_p->l);
	NMG_LIST_APPEND(&lu->lumate_p->down_hd, &neweu->eumate_p->l);
d210 4
a213 4
	NMG_LIST_DEQUEUE(&eunext->l);
	NMG_LIST_INSERT(&eu1->l, &eunext->l);
	NMG_LIST_DEQUEUE(&eunext->eumate_p->l);
	NMG_LIST_APPEND(&eu1->eumate_p->l, &eunext->eumate_p->l);
d298 1
a298 1
	eun = NMG_LIST_PNEXT_CIRC(edgeuse, &vu->up.eu_p->l);
d300 1
a300 1
		eun = NMG_LIST_PNEXT_CIRC(edgeuse, &eun->l);
d311 1
a311 1
		eun = NMG_LIST_PNEXT_CIRC(edgeuse, &eun->l);
d328 1
a328 1
	eul = NMG_LIST_PLAST_CIRC(edgeuse, &vu->up.eu_p->l);
d332 1
a332 1
		eul = NMG_LIST_PLAST_CIRC(edgeuse, eul);
d338 1
a338 1
		eul = NMG_LIST_PLAST_CIRC(edgeuse, eul);
d424 1
a424 1
			eu_forw = NMG_LIST_PNEXT_CIRC(edgeuse,
d427 1
a427 1
			eu_back = NMG_LIST_PNEXT_CIRC(edgeuse,
d463 2
a464 2
	eu_next = NMG_LIST_PNEXT_CIRC(edgeuse, &eu->l);
	eu_last = NMG_LIST_PLAST_CIRC(edgeuse, &eu->l);
d615 2
a616 2
	eu_next = NMG_LIST_PNEXT_CIRC(edgeuse, eu);
	eu_last = NMG_LIST_PLAST_CIRC(edgeuse, eu);
d626 1
a626 1
		eu_next = NMG_LIST_PNEXT_CIRC(edgeuse, eu);
d637 1
a637 1
		eu_last = NMG_LIST_PLAST_CIRC(edgeuse, eu);
d653 1
a653 1
		eu_last = NMG_LIST_PLAST_CIRC(edgeuse, eu);
d740 2
a741 2
	eu_jnext = NMG_LIST_PNEXT_CIRC(edgeuse, &vul.v[j]->up.eu_p->l);
	eu_inext = NMG_LIST_PNEXT_CIRC(edgeuse, &vul.v[i]->up.eu_p->l);
d817 1
a817 1
			    NMG_LIST_FIRST_MAGIC(&lu_k->down_hd) != NMG_VERTEXUSE_MAGIC) {
@


1.2
log
@Folded in comments and some debugging prints from
the "experimental springtime" version.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_comb.c,v 1.1 90/12/08 03:25:59 mike Exp $ (BRL)";
d117 1
a117 1
	FILE *fd, *fopen();
d906 1
a906 1
	FILE *fp, *fopen();
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_bool.c,v 1.27 90/12/08 03:09:29 mike Exp $ (BRL)";
d273 3
d279 2
a280 1
		rt_log("justgrazing() vu->up is not edgeuse, skipping\n");
d715 2
d742 5
d753 1
a753 1
	    	/* if this was a "temporary" loopuse, take care of
d771 5
d805 3
d822 4
d872 3
d942 14
a955 1
				rt_log("EDGEUSE\n");
@
