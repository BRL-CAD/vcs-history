head	11.44;
access;
symbols
	ansi-20040405-merged:11.41.4.1
	postmerge-20040405-ansi:11.42
	premerge-20040404-ansi:11.42
	postmerge-autoconf:11.42
	autoconf-freeze:11.41.12.2
	premerge-autoconf:11.42
	ansi-20040316-freeze:11.41
	postmerge-20040315-windows:11.42
	premerge-20040315-windows:11.42
	windows-20040315-freeze:11.41.6.1
	autoconf-20031203:11.41
	autoconf-20031202:11.41
	autoconf-branch:11.41.0.12
	phong-branch:11.41.0.10
	photonmap-branch:11.41.0.8
	rel-6-1-DP:11.41
	windows-branch:11.41.0.6
	rel-6-0-2:11.41
	ansi-branch:11.41.0.4
	rel-6-0-1-branch:11.41.0.2
	hartley-6-0-post:11.41
	hartley-6-0-pre:11.41
	rel-6-0-1:11.41
	rel-6-0:11.41
	rel-5-4:11.23
	offsite-5-3-pre:11.38
	rel-5-3:11.23
	rel-5-2:11.23
	rel-5-1-branch:11.23.0.2
	rel-5-1:11.23
	rel-5-0:11.16
	rel-5-0-beta:11.16
	rel-4-5:11.9
	ctj-4-5-post:11.8
	ctj-4-5-pre:11.7
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.44
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	11.43;

11.43
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.42;

11.42
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	11.41;

11.41
date	2002.02.22.02.41.27;	author morrison;	state Exp;
branches
	11.41.4.1
	11.41.6.1
	11.41.12.1;
next	11.40;

11.40
date	2001.05.08.20.17.12;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	2001.03.20.21.53.05;	author pjt;	state Exp;
branches;
next	11.38;

11.38
date	2000.09.20.03.44.25;	author mike;	state Exp;
branches;
next	11.37;

11.37
date	2000.09.08.05.54.41;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	2000.07.20.23.30.54;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	2000.07.13.02.36.25;	author cjohnson;	state Exp;
branches;
next	11.34;

11.34
date	2000.07.10.23.01.29;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	2000.06.30.18.03.07;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	2000.06.30.15.27.27;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	2000.06.29.20.03.35;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	2000.06.29.18.20.55;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.06.29.15.53.25;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.06.29.14.40.23;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.06.28.18.03.40;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.06.28.17.49.59;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.06.28.17.45.51;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.06.27.17.33.13;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.06.23.06.40.13;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.01.07.03.23.11;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	99.12.30.04.56.59;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	99.12.29.23.23.10;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.11.26.22.14.14;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	99.11.18.20.59.22;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	99.11.18.02.52.41;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	98.08.10.17.51.05;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	98.04.02.23.09.52;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	98.03.26.07.09.09;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	98.03.26.06.45.23;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	98.03.24.08.30.24;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	98.03.24.06.31.23;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	98.03.19.15.57.01;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	97.12.18.02.52.34;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	97.09.02.13.54.18;	author gdurf;	state Exp;
branches;
next	11.7;

11.7
date	97.05.22.02.15.45;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.02.20.16.25.48;	author pjt;	state Exp;
branches;
next	11.5;

11.5
date	97.01.30.01.46.16;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.01.29.19.56.23;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.01.26.03.03.53;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.23;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.11.05.05.13.44;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.11.05.04.22.45;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.11.04.05.41.19;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.10.18.22.45;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	93.12.28.14.44.46;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	93.12.22.07.06.59;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.03.18.00.32.41;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.08;	author mike;	state Rel4_0;
branches;
next	9.7;

9.7
date	91.06.30.23.18.11;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.06.04.22.58.53;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.01.28.23.52.56;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.07.05.27.36;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.10.07.21.38.41;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.04.12.03.30.35;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.55.54;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.04.04.04.56.45;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.25.43;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.31.11;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.10.01.01.47.37;	author stay;	state Exp;
branches;
next	7.3;

7.3
date	88.08.23.02.30.51;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.05.14.02.29.21;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.33.20;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.09.26.03.24.20;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.55.40;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.11.18;	author mike;	state Rel;
branches;
next	4.5;

4.5
date	87.03.23.23.42.13;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.03.11.01.32.10;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.12.22.11.09;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.17.01.47.35;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.45.03;	author mike;	state Rel1;
branches;
next	3.11;

3.11
date	86.12.19.04.17.17;	author mike;	state Exp;
branches;
next	3.10;

3.10
date	86.08.13.18.12.20;	author mike;	state Exp;
branches;
next	3.9;

3.9
date	86.08.12.04.15.31;	author mike;	state Exp;
branches;
next	3.8;

3.8
date	86.08.08.05.05.43;	author mike;	state Exp;
branches;
next	3.7;

3.7
date	86.08.06.19.54.04;	author mike;	state Exp;
branches;
next	3.6;

3.6
date	86.07.31.02.50.43;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.07.24.06.09.15;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.07.19.04.41.12;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.17.18.19.43;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.11.01.31.56;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.06.11.00.34.16;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.33.00;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	86.06.09.21.50.20;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	86.03.14.21.07.47;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.24.18.33.42;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.04.04;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	85.07.30.05.52.27;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	85.07.30.02.00.55;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	85.06.05.00.25.10;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	85.03.25.17.45.12;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	85.03.25.11.45.24;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	85.02.07.19.19.23;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	85.02.01.14.45.34;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	84.11.23.20.54.02;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.11.20.21.00.03;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.11.20.20.14.20;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.11.16.06.28.13;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.10.19.01.38.10;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.04.18.02.19.58;	author mike;	state Exp;
branches;
next	;

11.41.4.1
date	2004.03.17.21.18.44;	author morrison;	state Exp;
branches;
next	;

11.41.6.1
date	2004.03.11.23.43.36;	author morrison;	state Exp;
branches;
next	;

11.41.12.1
date	2004.02.12.18.37.39;	author erikg;	state Exp;
branches;
next	11.41.12.2;

11.41.12.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@Database Directory Manager
@


11.44
log
@moved to src/
@
text
@/*
 *			D I R . C
 *
 * Ray Tracing program, GED database directory manager.
 *
 *  Functions -
 *	rt_dirbuild	Read GED database, build directory
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSdir[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/dir.c,v 11.43 2004/05/10 15:30:46 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./debug.h"

/*
 *			R T _ D I R B U I L D
 *
 *  Builds a directory of the object names.
 *
 *  Allocate and initialize information for this
 *  instance of an RT model database.
 *
 * Returns -
 *	(struct rt_i *)	Success
 *	RTI_NULL	Fatal Error
 */
struct rt_i *
rt_dirbuild( const char *filename, char *buf, int len )
{
	register struct rt_i	*rtip;
	register struct db_i	*dbip;		/* Database instance ptr */

	if( rt_uniresource.re_magic == 0 )
		rt_init_resource( &rt_uniresource, 0, NULL );

	if( (dbip = db_open( filename, "r" )) == DBI_NULL )
	    	return( RTI_NULL );		/* FAIL */
	RT_CK_DBI(dbip);

	if( db_dirbuild( dbip ) < 0 )  {
		db_close( dbip );
	    	return RTI_NULL;		/* FAIL */
	}

	rtip = rt_new_rti( dbip );		/* clones dbip */
	db_close(dbip);				/* releases original dbip */

	if( buf != (char *)NULL )
		strncpy( buf, dbip->dbi_title, len );

	return( rtip );				/* OK */
}

/*
 *			R T _ D B _ G E T _ I N T E R N A L
 *
 *  Get an object from the database, and convert it into it's internal
 *  representation.
 *
 *  Returns -
 *	<0	On error
 *	id	On success.
 */
int
rt_db_get_internal(
	struct rt_db_internal	*ip,
	const struct directory	*dp,
	const struct db_i	*dbip,
	const mat_t		mat,
	struct resource		*resp)
{
	struct bu_external	ext;
	register int		id;

	BU_INIT_EXTERNAL(&ext);
	RT_INIT_DB_INTERNAL(ip);

	if( dbip->dbi_version > 4 )
		return  rt_db_get_internal5( ip, dp, dbip, mat, resp );

	if( db_get_external( &ext, dp, dbip ) < 0 )
		return -2;		/* FAIL */

	if( dp->d_flags & DIR_COMB )  {
		id = ID_COMBINATION;
	} else {
		/* As a convenience to older ft_import routines */
		if( mat == NULL )  mat = bn_mat_identity;
		id = rt_id_solid( &ext );
	}

	/* ip is already initialized and should not be re-initialized */
	if( rt_functab[id].ft_import( ip, &ext, mat, dbip, resp ) < 0 )  {
		bu_log("rt_db_get_internal(%s):  import failure\n",
			dp->d_namep );
	    	rt_db_free_internal( ip, resp );
		bu_free_external( &ext );
		return -1;		/* FAIL */
	}
	bu_free_external( &ext );
	RT_CK_DB_INTERNAL( ip );
	ip->idb_meth = &rt_functab[id];

	/* prior to version 5, there are no attributes */
	bu_avs_init_empty( &ip->idb_avs );

	return id;			/* OK */
}

/*
 *			R T _ D B _ P U T _ I N T E R N A L
 *
 *  Convert the internal representation of a solid to the external one,
 *  and write it into the database.
 *  On success only, the internal representation is freed.
 *
 *  Returns -
 *	<0	error
 *	 0	success
 */
int
rt_db_put_internal(
	struct directory	*dp,
	struct db_i		*dbip,
	struct rt_db_internal	*ip,
	struct resource		*resp)
{
	struct bu_external	ext;
	int			ret;

	BU_INIT_EXTERNAL(&ext);
	RT_CK_DB_INTERNAL( ip );

	if( dbip->dbi_version > 4 )
		return  rt_db_put_internal5( dp, dbip, ip, resp,
		    DB5_MAJORTYPE_BRLCAD );

	/* Scale change on export is 1.0 -- no change */
	ret = ip->idb_meth->ft_export( &ext, ip, 1.0, dbip, resp );
	if( ret < 0 )  {
		bu_log("rt_db_put_internal(%s):  solid export failure\n",
			dp->d_namep);
		rt_db_free_internal( ip, resp );
		bu_free_external( &ext );
		return -2;		/* FAIL */
	}
	rt_db_free_internal( ip, resp );

	if( db_put_external( &ext, dp, dbip ) < 0 )  {
		bu_free_external( &ext );
		return -1;		/* FAIL */
	}

	bu_free_external( &ext );
	return 0;			/* OK */
}

/*
 *			R T _ F W R I T E _ I N T E R N A L
 *
 *  Put an object in internal format out onto a file in external format.
 *  Used by LIBWDB.
 *
 *  Can't really require a dbip parameter, as many callers won't have one.
 *
 *  Returns -
 *	0	OK
 *	<0	error
 */
int
rt_fwrite_internal(
	FILE *fp,
	const char *name,
	const struct rt_db_internal *ip,
	double conv2mm )
{
	struct bu_external	ext;

	RT_CK_DB_INTERNAL(ip);
	RT_CK_FUNCTAB( ip->idb_meth );
	BU_INIT_EXTERNAL( &ext );

	if( ip->idb_meth->ft_export( &ext, ip, conv2mm, NULL /*dbip*/, &rt_uniresource ) < 0 )  {
		bu_log("rt_file_put_internal(%s): solid export failure\n",
			name );
		bu_free_external( &ext );
		return(-2);				/* FAIL */
	}
	BU_CK_EXTERNAL( &ext );

	if( db_fwrite_external( fp, name, &ext ) < 0 )  {
		bu_log("rt_fwrite_internal(%s): db_fwrite_external() error\n",
			name );
		bu_free_external( &ext );
		return(-3);
	}
	bu_free_external( &ext );
	return(0);

}

/*
 *			R T _ D B _ F R E E _ I N T E R N A L
 */
void
rt_db_free_internal( struct rt_db_internal *ip, struct resource *resp )
{
	RT_CK_DB_INTERNAL( ip );
	RT_CK_FUNCTAB( ip->idb_meth );
	/* resp is not checked, since most ifree's don't take/need it
	 * (only combinations use it) -- leave it up to ft_ifree to check it
	 */
	if( ip->idb_ptr )  {
		ip->idb_meth->ft_ifree(ip, resp);
		ip->idb_ptr = NULL;		/* sanity.  Should be handled by INIT, below */
	}
	if( ip->idb_avs.magic == BU_AVS_MAGIC )  bu_avs_free(&ip->idb_avs);
	RT_INIT_DB_INTERNAL(ip);
}

/*
 *		R T _ D B _ L O O K U P _ I N T E R N A L
 *
 *	    Convert an object name to a rt_db_internal pointer
 *
 *	Looks up the named object in the directory of the specified model,
 *	obtaining a directory pointer.  Then gets that object from the
 *	database and constructs its internal representation.  Returns
 *	ID_NULL on error, otherwise returns the type of the object.
 */
int
rt_db_lookup_internal (
	struct db_i *dbip,
	const char *obj_name,
	struct directory **dpp,
	struct rt_db_internal *ip,
	int noisy,
	struct resource *resp)
{
    struct directory		*dp;

    if (obj_name == (char *) 0)
    {
	if (noisy == LOOKUP_NOISY)
	    bu_log("rt_db_lookup_internal() No object specified\n");
	return ID_NULL;
    }
    if ((dp = db_lookup(dbip, obj_name, noisy)) == DIR_NULL)
	return ID_NULL;
    if (rt_db_get_internal(ip, dp, dbip, (matp_t) NULL, resp ) < 0 )
    {
	if (noisy == LOOKUP_NOISY)
	    bu_log("rt_db_lookup_internal() Failed to get internal form of object '%s'\n",
		dp -> d_namep);
	return ID_NULL;
    }

    *dpp = dp;
    return (ip -> idb_type);
}
@


11.43
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSdir[] = "@@(#)$Header: /cvs/brlcad/librt/dir.c,v 11.42 2004/02/02 17:39:15 morrison Exp $";
@


11.42
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.41 2002/02/22 02:41:27 morrison Exp $";
d25 5
a29 1
#include "conf.h"
@


11.41
log
@removed an RT_CK_RESOURCE from rt_db_free_internal() since most ifree's don't take/need it (only combinations use that param).  The job is left up to the function that it gets passed to the idb_meth->ft_ifree() func pointer (e.g. rt_dsp_ifree()).
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985 by the United States Army.
d22 1
a22 1
static const char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.40 2001/05/08 20:17:12 jra Exp $";
@


11.41.4.1
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSdir[] = "@@(#)$Header$";
@


11.41.6.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSdir[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/dir.c,v 11.42 2004/02/02 17:39:15 morrison Exp $";
@


11.41.12.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.42 2004/02/02 17:39:15 morrison Exp $";
@


11.41.12.2
log
@merge from head
@
text
@d22 1
a22 1
static const char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.41.12.1 2004/02/12 18:37:39 erikg Exp $";
@


11.40
log
@rt_db_get_internal() now initializes the idb_avs field to an empty AVS
@
text
@d22 1
a22 1
static const char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.39 2001/03/20 21:53:05 pjt Exp $";
a231 1
	RT_CK_RESOURCE(resp);
d233 3
@


11.39
log
@Added DB5_MAJORTYPE_BRLCAD as last argument of something or other
@
text
@d22 1
a22 1
static const char RCSdir[] = "@@(#)$Header: /d/CVS/brlcad/librt/dir.c,v 11.38 2000/09/20 03:44:25 mike Exp $";
d126 4
@


11.38
log
@
Improved initialization of rt_uniresource.
@
text
@d22 1
a22 1
static const char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.37 2000/09/08 05:54:41 mike Exp $";
d154 2
a155 1
		return  rt_db_put_internal5( dp, dbip, ip, resp );
@


11.37
log
@
Modified tree routines to take resource pointer.
@
text
@d22 1
a22 1
static const char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.36 2000/07/20 23:30:54 mike Exp $";
d55 3
@


11.36
log
@
Added sanity code.
@
text
@d22 1
a22 1
static const char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.35 2000/07/13 02:36:25 cjohnson Exp $";
d85 6
a90 5
rt_db_get_internal( ip, dp, dbip, mat )
struct rt_db_internal	*ip;
CONST struct directory	*dp;
CONST struct db_i	*dbip;
CONST mat_t		mat;
d99 1
a99 1
		return  rt_db_get_internal5( ip, dp, dbip, mat );
d113 1
a113 1
	if( rt_functab[id].ft_import( ip, &ext, mat, dbip ) < 0 )  {
d116 1
a116 1
	    	rt_db_free_internal( ip );
d138 5
a142 4
rt_db_put_internal( dp, dbip, ip )
struct directory	*dp;
struct db_i		*dbip;
struct rt_db_internal	*ip;
d151 1
a151 1
		return  rt_db_put_internal5( dp, dbip, ip );
d154 1
a154 1
	ret = ip->idb_meth->ft_export( &ext, ip, 1.0, dbip );
d158 1
a158 1
		rt_db_free_internal( ip );
d162 1
a162 1
	rt_db_free_internal( ip );
d198 1
a198 1
	if( ip->idb_meth->ft_export( &ext, ip, conv2mm, NULL /*dbip*/ ) < 0 )  {
d221 1
a221 1
rt_db_free_internal( struct rt_db_internal *ip )
d224 1
d227 1
a227 1
		ip->idb_meth->ft_ifree(ip);
d250 2
a251 1
	int noisy )
d258 1
a258 1
	    bu_log("No object specified\n");
d263 1
a263 1
    if (rt_db_get_internal(ip, dp, dbip, (matp_t) NULL ) < 0 )
d266 1
a266 1
	    bu_log("Failed to get internal form of object '%s'\n",
@


11.35
log
@LINT from gcc -Wall
@
text
@d22 1
a22 1
static const char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.34 2000/07/10 23:01:29 mike Exp $";
d223 4
a226 1
	if( ip->idb_ptr )  ip->idb_meth->ft_ifree(ip);
@


11.34
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d22 1
a22 1
static const char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.33 2000/06/30 18:03:07 mike Exp $";
d28 5
@


11.33
log
@
Need to init extern struct before calling import/export
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.32 2000/06/30 15:27:27 mike Exp $";
@


11.32
log
@
Added comment
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.31 2000/06/29 20:03:35 mike Exp $";
d189 1
@


11.31
log
@
added ip->idb_avs
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.30 2000/06/29 18:20:55 mike Exp $";
d106 1
@


11.30
log
@
Changed from db_free_external() to bu_free_external()
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.29 2000/06/29 15:53:25 mike Exp $";
d217 1
@


11.29
log
@
rt_db_free_internal()
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.28 2000/06/29 14:40:23 mike Exp $";
d110 1
a110 1
		db_free_external( &ext );
d113 1
a113 1
	db_free_external( &ext );
d151 1
a151 1
		db_free_external( &ext );
d157 1
a157 1
		db_free_external( &ext );
d161 1
a161 1
	db_free_external( &ext );
d192 1
a192 1
		db_free_external( &ext );
d200 1
a200 1
		db_free_external( &ext );
d203 1
a203 1
	db_free_external( &ext );
@


11.28
log
@
rt_db_free_internal
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.27 2000/06/28 18:03:40 mike Exp $";
d216 1
a216 1
	if( ip->idb_ptr )  ip->idb_meth->ft_ifree;
@


11.27
log
@
Added externs from dir.c to raytrace.h
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.26 2000/06/28 17:49:59 mike Exp $";
d109 1
a109 1
	    	if( ip->idb_ptr )  ip->idb_meth->ft_ifree( ip );
d216 1
a216 1
    	if( ip->idb_ptr )  ip->idb_meth->ft_ifree( ip );
@


11.26
log
@
Changed to use rt_db_free_internal()
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.25 2000/06/28 17:45:51 mike Exp $";
d46 1
a46 4
rt_dirbuild(filename, buf, len)
CONST char	*filename;
char		*buf;
int		len;
d178 5
a182 5
rt_fwrite_internal( fp, name, ip, conv2mm )
FILE				*fp;
CONST char			*name;
CONST struct rt_db_internal	*ip;
double				conv2mm;
d212 1
a212 2
rt_db_free_internal( ip )
struct rt_db_internal	*ip;
d231 6
a236 8
rt_db_lookup_internal (dbip, obj_name, dpp, ip, noisy)

struct db_i		*dbip;
char			*obj_name;
struct directory	**dpp;
struct rt_db_internal	*ip;
int			noisy;

@


11.25
log
@
Linked to rt_db_put_internal5()
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.24 2000/06/27 17:33:13 mike Exp $";
d153 1
d157 1
a163 3
    	if( ip->idb_ptr )  ip->idb_meth->ft_ifree( ip );

	RT_INIT_DB_INTERNAL(ip);
@


11.24
log
@
Added rt_db_get_internal5()
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.23 2000/06/23 06:40:13 mike Exp $";
d144 3
@


11.23
log
@
Changed from using v4-specific support in rt_dirbuild()
to using generic support.  Called, suspiciously enough, db_dirbuild().
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.22 2000/01/07 03:23:11 mike Exp $";
d94 4
@


11.22
log
@
Added rt_fwrite_internal(), as a parallel to rt_db_put_internal().
Particularly useful for simplifying LIBWDB.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.21 1999/12/30 04:56:59 mike Exp $";
d58 1
a58 1
	if( db_scan( dbip, (int (*)())db_diradd, 1, NULL ) < 0 )  {
d60 1
a60 1
	    	return( RTI_NULL );		/* FAIL */
@


11.21
log
@
Additional datastructures to support the submodel.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.20 1999/12/29 23:23:10 mike Exp $";
d160 43
@


11.20
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.19 1999/11/26 22:14:14 mike Exp $";
d63 2
a64 1
	rtip = rt_new_rti( dbip );
@


11.19
log
@
lint
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.18 1999/11/18 20:59:22 mike Exp $";
d58 1
a58 1
	if( db_scan( dbip, (int (*)())db_diradd, 1 ) < 0 )  {
@


11.18
log
@
Changed invocation of ft_ifree to be via idb_meth
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.17 1999/11/18 02:52:41 mike Exp $";
d84 2
a85 2
struct directory	*dp;
struct db_i		*dbip;
a129 1
struct rt_db_internal	*ip;
d132 1
d141 1
a141 1
	ret = rt_functab[ip->idb_type].ft_export( &ext, ip, 1.0, dbip );
@


11.17
log
@
Set idb_meth
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.16 1998/08/10 17:51:05 mike Exp $";
d107 1
a107 1
	    	if( ip->idb_ptr )  rt_functab[id].ft_ifree( ip );
d154 1
a154 1
    	if( ip->idb_ptr )  rt_functab[ip->idb_type].ft_ifree( ip );
d169 2
a170 1
    	if( ip->idb_ptr )  rt_functab[ip->idb_type].ft_ifree( ip );
@


11.16
log
@Fixed arg type of rt_dirbuild
Fixed arg type to rt_dirbuild (added CONST)
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /c/CVS/brlcad/librt/dir.c,v 11.15 1998/04/02 23:09:52 mike Exp $";
d113 1
@


11.15
log
@Tidy.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 11.14 1998/03/26 07:09:09 mike Exp mike $";
d47 3
a49 3
char	*filename;
char	*buf;
int	len;
@


11.14
log
@Moved rt_new_rti() and rt_free_rti() from dir.c to prep.c
to make it easier to parcel out who does what.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 11.13 1998/03/26 06:45:23 mike Exp mike $";
d58 2
a59 1
	if( db_scan( dbip, (int (*)())db_diradd, 1 ) < 0 )
d61 1
@


11.13
log
@renamed rt_free_resource()
to be rt_clean_resource(), as that is all it does, and I've added some
clarifying comments.  Also, it makes more sense to truncate the
rti_resources ptbl than to free it as part of the cleanup operation.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 11.12 1998/03/24 08:30:24 mike Exp mike $";
a33 67
 *			R T _ N E W _ R T I
 *
 *  Given a db_i database instance, create an rt_i instance.
 *
 *  XXX Perhaps the db_i structure should be reference counted?
 */
struct rt_i *
rt_new_rti( dbip )
struct db_i	*dbip;
{
	register struct rt_i	*rtip;
	register int		i;

	RT_CK_DBI( dbip );

	BU_GETSTRUCT( rtip, rt_i );
	rtip->rti_magic = RTI_MAGIC;
	for( i=0; i < RT_DBNHASH; i++ )  {
		BU_LIST_INIT( &(rtip->rti_solidheads[i]) );
	}
	rtip->rti_dbip = dbip;
	rtip->needprep = 1;

	/* This table is used for discovering the per-cpu resource structures */
	bu_ptbl_init( &rtip->rti_resources, MAX_PSW, "rti_resources ptbl" );

	rt_uniresource.re_magic = RESOURCE_MAGIC;

	VSETALL( rtip->mdl_min,  INFINITY );
	VSETALL( rtip->mdl_max, -INFINITY );
	VSETALL( rtip->rti_inf_box.bn.bn_min, -0.1 );
	VSETALL( rtip->rti_inf_box.bn.bn_max,  0.1 );
	rtip->rti_inf_box.bn.bn_type = CUT_BOXNODE;

	/* XXX These need to be improved */
	rtip->rti_tol.magic = BN_TOL_MAGIC;
	rtip->rti_tol.dist = 0.005;
	rtip->rti_tol.dist_sq = rtip->rti_tol.dist * rtip->rti_tol.dist;
	rtip->rti_tol.perp = 1e-6;
	rtip->rti_tol.para = 1 - rtip->rti_tol.perp;

	rtip->rti_space_partition = RT_PART_NUBSPT;
	rtip->rti_nugrid_dimlimit = 0;
	rtip->rti_nu_gfactor = RT_NU_GFACTOR_DEFAULT;

	/*
	 *  Zero the solid instancing counters in dbip database instance.
	 *  Done here because the same dbip could be used by multiple
	 *  rti's, and rt_gettrees() can be called multiple times on
	 *  this one rtip.
	 *  There is a race (collision!) here on d_uses if rt_gettrees()
	 *  is called on another rtip of the same dbip
	 *  before this rtip is done
	 *  with all it's treewalking.
	 */
	for( i=0; i < RT_DBNHASH; i++ )  {
		register struct directory	*dp;

		dp = rtip->rti_dbip->dbi_Head[i];
		for( ; dp != DIR_NULL; dp = dp->d_forw )
			dp->d_uses = 0;
	}

	return rtip;
}

/*
a53 4
	if( BU_LIST_FIRST( rt_list, &rt_g.rtg_vlfree ) == 0 )  {
		BU_LIST_INIT( &rt_g.rtg_vlfree );
	}

a66 22
}

/*
 *			R T _ F R E E _ R T I
 *
 *  Release all the dynamic storage acquired by rt_dirbuild() and
 *  any subsequent ray-tracing operations.
 *
 *  Note that any PARALLEL resource structures have to be freed separately.
 *  Note that the rt_g structure needs to be cleaned separately.
 */
void
rt_free_rti( rtip )
struct rt_i	*rtip;
{
	RT_CK_RTI(rtip);

	rt_clean( rtip );
	db_close( rtip->rti_dbip );
	rtip->rti_dbip = (struct db_i *)NULL;
	bu_ptbl_free( &rtip->rti_resources );
	rt_free( (char *)rtip, "struct rt_i" );
@


11.12
log
@Moved reset of d_uses field from rt_clean() to rt_new_rti().
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 11.11 1998/03/24 06:31:23 mike Exp mike $";
d158 1
@


11.11
log
@Moved init of rti_resources ptbl into rt_new_rti().
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 11.10 1998/03/19 15:57:01 jra Exp mike $";
d78 18
@


11.10
log
@Cahnged to new calling sequence for ft_import and ft_export.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 11.9 1997/12/18 02:52:34 mike Exp jra $";
d56 5
@


11.9
log
@Don't give rt_comb_import() a bn_mat_identity, give it a null
pointer.  This can save lots of storage when building the imported
tree.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 11.8 1997/09/02 13:54:18 gdurf Exp mike $";
d171 1
a171 1
	if( rt_functab[id].ft_import( ip, &ext, mat ) < 0 )  {
d207 1
a207 1
	ret = rt_functab[ip->idb_type].ft_export( &ext, ip, 1.0 );
@


11.8
log
@set up defaults for new NUgrid-related members
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 11.7 1997/05/22 02:15:45 mike Exp gdurf $";
d163 1
a163 3
	if( mat == NULL )  mat = bn_mat_identity;

	if( dp->d_flags & DIR_COMB )
d165 3
a167 1
	else
d169 1
@


11.7
log
@Fixed cast
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 11.6 1997/02/20 16:25:48 pjt Exp mike $";
d69 4
@


11.6
log
@Implemented rt_db_lookup_internal()
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 11.5 1997/01/30 01:46:16 mike Exp $";
d264 1
a264 1
    if (rt_db_get_internal(ip, dp, dbip, (mat_t *) NULL ) < 0 )
@


11.5
log
@Changed rt_db_get/put_internal() to use combination import/export
via the function table, rather than hardwired.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 11.4 1997/01/29 19:56:23 mike Exp mike $";
d232 42
@


11.4
log
@Extension.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 11.3 1997/01/26 03:03:53 mike Exp mike $";
a142 2
 *
 *  XXX How to handle combinations?
d161 5
a165 1
	id = rt_id_solid( &ext );
d167 1
a167 1
		bu_log("rt_db_get_internal(%s):  solid import failure\n",
d202 1
a202 5
	if( ip->idb_type == ID_COMBINATION )  {
		ret = rt_comb_v4_export( &ext, ip, 1.0 );
	} else {
		ret = rt_functab[ip->idb_type].ft_export( &ext, ip, 1.0 );
	}
d215 2
a216 5
	if( ip->idb_type == ID_COMBINATION )  {
	    	if( ip->idb_ptr )  rt_comb_ifree( ip );
	} else {
	    	if( ip->idb_ptr )  rt_functab[ip->idb_type].ft_ifree( ip );
	}
@


11.3
log
@Added call to rt_comb_v4_export() at right place, since it isn't
in the functab properly.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /n/vapor/m/cad/librt/RCS/dir.c,v 11.2 1996/09/27 08:27:30 mike Exp mike $";
d139 6
d161 2
d173 1
a173 1
	return 0;			/* OK */
@


11.2
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 11.1 1995/01/04 09:56:23 mike Rel4_4 mike $";
d186 1
d192 6
a197 1
	if( rt_functab[ip->idb_type].ft_export( &ext, ip, 1.0 ) < 0 )  {
d209 5
a213 1
    	if( ip->idb_ptr )  rt_functab[ip->idb_type].ft_ifree( ip );
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 10.8 94/11/05 05:13:44 mike Exp $";
d49 1
a49 1
	GETSTRUCT( rtip, rt_i );
d52 1
a52 1
		RT_LIST_INIT( &(rtip->rti_solidheads[i]) );
d64 1
a64 1
	rtip->rti_tol.magic = RT_TOL_MAGIC;
d94 2
a95 2
	if( RT_LIST_FIRST( rt_list, &rt_g.rtg_vlfree ) == 0 )  {
		RT_LIST_INIT( &rt_g.rtg_vlfree );
d147 1
a147 1
	struct rt_external	ext;
d150 1
a150 1
	RT_INIT_EXTERNAL(&ext);
d157 1
a157 1
		rt_log("rt_db_get_internal(%s):  solid import failure\n",
d185 1
a185 1
	struct rt_external	ext;
d187 1
a187 1
	RT_INIT_EXTERNAL(&ext);
d192 1
a192 1
		rt_log("rt_db_put_internal(%s):  solid export failure\n",
@


10.8
log
@Changed to use the proper RT_CK macro!
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 10.7 94/11/05 04:22:45 mike Exp Locker: mike $";
@


10.7
log
@Added extra checking, Irix 6 inspired.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 10.6 94/11/04 05:41:19 mike Exp Locker: mike $";
d100 1
a100 1
	RT_CK_DB_INTERNAL(dbip);
@


10.6
log
@Irix 6
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 10.5 94/08/10 18:22:45 gdurf Exp Locker: mike $";
d100 1
@


10.5
log
@Added include of conf.h
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 10.4 1993/12/28 14:44:46 jra Exp gdurf $";
a92 1
	register int		i;
a184 1
	register int		id;
@


10.4
log
@Fixed bug in rt_new_rti. It was doing a RT_CK_DIR on a struct db_i pointer.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/dir.c,v 10.3 93/12/22 07:06:59 mike Exp Locker: jra $";
d24 2
@


10.3
log
@Broke out cleanup and setup routines, in anticipation of Jim Hunt's
needs.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 10.2 92/03/18 00:32:41 mike Exp Locker: mike $";
d45 1
a45 1
	RT_CK_DIR( dbip );
@


10.2
log
@Got new internal-format geometry import/export routines.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 10.1 91/10/12 06:40:08 mike Rel4_0 Locker: mike $";
d32 40
d103 1
a103 7
	GETSTRUCT( rtip, rt_i );
	rtip->rti_magic = RTI_MAGIC;
	for( i=0; i < RT_DBNHASH; i++ )  {
		RT_LIST_INIT( &(rtip->rti_solidheads[i]) );
	}
	rtip->rti_dbip = dbip;
	rtip->needprep = 1;
a104 13
	VSETALL( rtip->mdl_min,  INFINITY );
	VSETALL( rtip->mdl_max, -INFINITY );
	VSETALL( rtip->rti_inf_box.bn.bn_min, -0.1 );
	VSETALL( rtip->rti_inf_box.bn.bn_max,  0.1 );
	rtip->rti_inf_box.bn.bn_type = CUT_BOXNODE;

	/* XXX These need to be improved */
	rtip->rti_tol.magic = RT_TOL_MAGIC;
	rtip->rti_tol.dist = 0.005;
	rtip->rti_tol.dist_sq = rtip->rti_tol.dist * rtip->rti_tol.dist;
	rtip->rti_tol.perp = 1e-6;
	rtip->rti_tol.para = 1 - rtip->rti_tol.perp;

d109 21
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 9.7 91/06/30 23:18:11 mike Exp $";
a27 1
#include "db.h"
d88 88
@


9.7
log
@Changed from rti_headsolid to rti_solidheads[]
They all need initializing.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 9.6 91/06/04 22:58:53 mike Exp $";
@


9.6
log
@Moved tolerance info into struct rt_i (rti_tol).
It is now invented in rt_dirbuild(), rather than in rt_shootray().
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 9.5 91/01/28 23:52:56 mike Exp $";
d52 1
d66 3
a68 1
	RT_LIST_INIT( &(rtip->rti_headsolid) );
@


9.5
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 9.4 90/12/07 05:27:36 mike Exp $";
d74 7
@


9.4
log
@Tell db_scan to process old region-ID based material property stuff.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 9.3 90/10/07 21:38:41 mike Exp $";
d52 4
@


9.3
log
@soltab structure changed to use struct rt_list.
HeadSolid became rti_headsolid.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /m/cad/librt/RCS/dir.c,v 9.2 90/04/12 03:30:35 mike Exp $";
d56 1
a56 1
	if( db_scan( dbip, (int (*)())db_diradd ) < 0 )
@


9.2
log
@rtip->file is no longer used.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 9.1 89/05/19 05:55:54 mike Locked $";
d61 1
@


9.1
log
@Release_3.5
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 8.3 89/04/04 04:56:45 mike Exp $";
a62 1
	rtip->file = rt_strdup( filename );
@


8.3
log
@Eliminated needless extra bzero()
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 8.2 88/12/06 00:25:43 mike Locked $";
@


8.2
log
@Converted to new db_*() routines.
@
text
@d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: /cad/d/mike/cad/librt/RCS/dir.c,v 1.3 88/11/27 19:07:28 mike Exp $";
a59 1
	bzero( (char *)rtip, sizeof(struct rt_i) );
@


8.1
log
@Release_3.0
@
text
@a7 2
 *	rt_dir_lookup	Look up name in directory
 *	rt_dir_add	Add entry to directory
d22 1
a22 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 7.4 88/10/01 01:47:37 stay Exp $";
d35 1
a35 3
 * This routine reads through the 3d object file and
 * builds a directory of the object names, to allow rapid
 * named access to objects.
d37 2
a38 6
 *  Note that some multi-record database items include length fields.
 *  These length fields are not used here.
 *  Instead, the sizes of multi-record items are determined by
 *  reading ahead and computing the actual size.
 *  This prevents difficulties arising from external "adjustment" of
 *  the number of records without corresponding adjustment of the length fields.
d46 3
a48 3
char *filename;
char *buf;
int len;
d51 1
a51 6
	static union record	record;		/* Initial record, holds name */
	static union record	rec2;		/* additional record(s) */
	register long	addr;			/* start of current rec */
	register int	nrec;			/* # total records */
	register long	here;			/* intermediate positions */
	register int	j;
d53 6
a58 4
	/*
	 *  Allocate and initialize information for this
	 *  instance of an RT model.
	 */
d61 2
a62 4
	if( (rtip->fp = fopen(filename, "r")) == NULL )  {
		perror(filename);
		goto bad;
	}
d72 2
a73 1
	buf[0] = '\0';
d75 1
a75 245
	/* In a portable way, read the header (even if not rewound) */
	rewind( rtip->fp );
	if( fread( (char *)&record, sizeof record, 1, rtip->fp ) != 1  ||
	    record.u_id != ID_IDENT )  {
		rt_log("\nWARNING:  File is lacking a proper MGED database header\n");
		rt_log("This database should be converted before further use.\n\n");
	}
	rewind( rtip->fp );

	here = addr = -1;
	while(1)  {
#ifdef DB_MEM
		addr++;		/* really, nrec;  ranges 0..n */
#else
		if( (addr = ftell(rtip->fp)) == EOF )
			rt_log("rt_dirbuild:  ftell() failure\n");
#endif DB_MEM
		if( fread( (char *)&record, sizeof record, 1, rtip->fp ) != 1
		    || feof(rtip->fp) )
			break;

		if(rt_g.debug&DEBUG_DB)rt_log("db x%x %c (0%o)\n",
			addr, record.u_id, record.u_id );

		switch( record.u_id )  {
		case ID_IDENT:
			if( strcmp( record.i.i_version, ID_VERSION) != 0 )  {
				rt_log("WARNING: File is Version %s, Program is version %s\n",
					record.i.i_version, ID_VERSION );
			}
			if( buf[0] == '\0' )
				strncpy( buf, record.i.i_title, len );
			continue;
		case ID_FREE:
			continue;
		case ID_ARS_A:
			nrec = 1;
			while(1) {
				here = ftell( rtip->fp );
				if( fread( (char *)&rec2, sizeof(rec2),
				    1, rtip->fp ) != 1 )
					break;
				if( rec2.u_id != ID_ARS_B )  {
					fseek( rtip->fp, here, 0 );
					break;
				}
				nrec++;
			}
			rt_dir_add( rtip, record.a.a_name, addr, nrec,
				DIR_SOLID );
			continue;
		case ID_ARS_B:
			rt_log("ERROR: Unattached ARS 'B' record\n");
			continue;
		case ID_SOLID:
			rt_dir_add( rtip, record.s.s_name, addr, 1,
				DIR_SOLID );
			continue;
		case ID_MATERIAL:
			rt_color_addrec( &record, addr );
			continue;
		case ID_P_HEAD:
			nrec = 1;
			while(1) {
				here = ftell( rtip->fp );
				if( fread( (char *)&rec2, sizeof(rec2),
				    1, rtip->fp ) != 1 )
					break;
				if( rec2.u_id != ID_P_DATA )  {
					fseek( rtip->fp, here, 0 );
					break;
				}
				nrec++;
			}
			rt_dir_add( rtip, record.p.p_name, addr, nrec,
				DIR_SOLID );
			continue;
		case ID_P_DATA:
			rt_log("ERROR: Unattached P_DATA record\n");
			continue;
		case ID_BSOLID:
			nrec = 1;
			while(1) {
				/* Find and skip subsequent BSURFs */
				here = ftell( rtip->fp );
				if( fread( (char *)&rec2, sizeof(rec2),
				    1, rtip->fp ) != 1 )
					break;
				if( rec2.u_id != ID_BSURF )  {
					fseek( rtip->fp, here, 0 );
					break;
				}

				/* Just skip over knots and control mesh */
				j = (rec2.d.d_nknots + rec2.d.d_nctls);
				while( j-- > 0 )
					fread( (char *)&rec2, sizeof(rec2), 1, rtip->fp );
				nrec += j+1;
			}
			rt_dir_add( rtip, record.B.B_name, addr, nrec,
				DIR_SOLID );
			continue;
		case ID_BSURF:
			rt_log("ERROR: Unattached B-spline surface record\n");

			/* Just skip over knots and control mesh */
			j = (record.d.d_nknots + record.d.d_nctls);
			while( j-- > 0 )
				fread( (char *)&rec2, sizeof(rec2), 1, rtip->fp );
			continue;
		case ID_MEMB:
			rt_log("ERROR: Unattached combination MEMBER record\n");
			continue;
		case ID_COMB:
			nrec = 1;
			while(1) {
				here = ftell( rtip->fp );
				if( fread( (char *)&rec2, sizeof(rec2),
				    1, rtip->fp ) != 1 )
					break;
				if( rec2.u_id != ID_MEMB )  {
					fseek( rtip->fp, here, 0 );
					break;
				}
				nrec++;
			}
			rt_dir_add( rtip, record.c.c_name, addr, nrec,
				record.c.c_flags == 'R' ?
					DIR_COMB|DIR_REGION : DIR_COMB );
			continue;
		default:
			rt_log("rt_dirbuild:  unknown record %c (0%o), addr=x%x\n",
				record.u_id, record.u_id, addr );
			/* skip this record */
			continue;
		}
	}
	rewind( rtip->fp );

#ifdef DB_MEM
	/*
	 * Obtain in-core copy of database, rather than doing lots of
	 * random-access reads.  Here, "addr" is really "nrecords".
	 */
	if( (rtip->rti_db = (union record *)rt_malloc(
	    addr*sizeof(union record), "in-core database"))
	    == (union record *)0 )
	    	rt_bomb("in-core database malloc failure");
	rewind(rtip->fp);
	if( fread( (char *)rtip->rti_db, sizeof(union record), addr,
	    rtip->fp) != addr )  {
	    	rt_log("rt_dirbuild:  problem reading db on 2nd pass\n");
	    	goto bad;
	}
#endif DB_MEM

	rtip->rti_magic = RTI_MAGIC;
	return( rtip );			/* OK */
bad:
	rt_free( (char *)rtip, "rt_i");
    	return( RTI_NULL );		/* FAIL */
}

/*
 *			R T _ D I R _ L O O K U P
 *
 * This routine takes a name, and looks it up in the
 * directory table.  If the name is present, a pointer to
 * the directory struct element is returned, otherwise
 * NULL is returned.
 *
 * If noisy is non-zero, a print occurs, else only
 * the return code indicates failure.
 */
struct directory *
rt_dir_lookup( rtip, str, noisy )
struct rt_i	*rtip;
register char	*str;
{
	register struct directory *dp;

	if( rtip->rti_magic != RTI_MAGIC )  rt_bomb("rt_dir_lookup:  bad rtip\n");

	for( dp = rtip->rti_DirHead; dp != DIR_NULL; dp=dp->d_forw )  {
		if(
			str[0] == dp->d_namep[0]  &&	/* speed */
			str[1] == dp->d_namep[1]  &&	/* speed */
			strcmp( str, dp->d_namep ) == 0
		)
			return(dp);
	}

	if( noisy )
		rt_log("rt_dir_lookup:  could not find '%s'\n", str );
	return( DIR_NULL );
}

/*
 *			R T _ D I R _ A D D
 *
 * Add an entry to the directory
 */
struct directory *
rt_dir_add( rtip, name, laddr, len, flags )
struct rt_i	*rtip;
register char	*name;
long		laddr;
int		len;
int		flags;
{
	register struct directory *dp;
	char local[NAMESIZE+2];

	(void)strncpy( local, name, NAMESIZE );	/* Trim the name */
	local[NAMESIZE] = '\0';			/* Ensure null termination */

	if(rt_g.debug&DEBUG_DB)
		rt_log("rt_dir_add(x%x,%s,x%x,%d.,x%x)\n", rtip, local, laddr, len, flags);

	GETSTRUCT( dp, directory );
	dp->d_namep = rt_strdup( local );
	dp->d_addr = laddr;
	dp->d_flags = flags;
	dp->d_len = len;
	dp->d_forw = rtip->rti_DirHead;
	rtip->rti_DirHead = dp;
	return( dp );
}

/*
 *			R T _ P R _ D I R
 */
void
rt_pr_dir( rtip )
register struct rt_i *rtip;
{
	register struct directory *dp;

	if( rtip->rti_magic != RTI_MAGIC )  rt_bomb("rt_pr_dir:  bad rtip\n");

	rt_log("Dump of directory for %s, rtip=x%x\n", rtip->file, rtip);
	for( dp = rtip->rti_DirHead; dp != DIR_NULL; dp=dp->d_forw )  {
		rt_log("%.8x disk=%.8x anim=%.8x %s\n", dp, dp->d_addr,
			dp->d_animate, dp->d_namep);
	}
@


7.4
log
@fixed spline BSOLID routine to correctly read in the 
and skip the BSURFS records.
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 7.3 88/08/23 02:30:51 stay Locked $";
@


7.3
log
@Improved scanning of directory, to measure size of objects,
rather than trusing values stored in database.
Also set db_flags now.
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 7.2 88/05/14 02:29:21 mike Locked $";
d181 1
a181 1
				j = (record.d.d_nknots + record.d.d_nctls);
@


7.2
log
@lint fixes
@
text
@d9 1
a9 1
 *	rt_dir_add		Add entry to directory
d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 7.1 87/11/02 23:33:20 mike Locked $";
d41 7
d59 6
a64 2
	static union record	record;
	register long	addr;
d91 2
a92 2
		rt_log("WARNING:  File is lacking a proper MGED database header\n");
		rt_log("This database should be converted before further use.\n");
d96 1
a96 1
	addr = -1;
d123 14
a136 1
			rt_dir_add( rtip, record.a.a_name, addr );
d139 1
d142 2
a143 1
			rt_dir_add( rtip, record.s.s_name, addr );
d149 9
a157 16
			{
				union record rec;
				register int nrec;

				nrec = 1;
				while(1) {
					register int here;
					here = ftell( rtip->fp );
					if( fread( (char *)&rec, sizeof(rec), 1,
					    rtip->fp ) != 1 )
						break;
					if( rec.u_id != ID_P_DATA )  {
						fseek( rtip->fp, here, 0 );
						break;
					}
					nrec++;
d159 1
a159 2
				rt_dir_add( rtip, record.p.p_name, addr );
				continue;
d161 6
d168 11
a178 6
			rt_dir_add( rtip, record.B.B_name, addr );
			continue;
		case ID_BSURF:
			{
				union record rec;
				register int j;
a179 2
				rt_dir_add( rtip, record.p.p_name, addr );

d183 2
a184 2
					fread( (char *)&rec, sizeof(rec), 1, rtip->fp );
				continue;
d186 11
d198 1
d201 15
a215 1
			rt_dir_add( rtip, record.c.c_name, addr );
d290 1
a290 1
rt_dir_add( rtip, name, laddr )
d294 2
d304 1
a304 1
		rt_log("rt_dir_add(x%x,%s,x%x)\n", rtip, local, laddr);
d309 2
@


7.1
log
@Release 2.3
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 6.2 87/09/26 03:24:20 mike Exp $";
d262 1
@


6.2
log
@Fixed handling of bounding RPP
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 6.1 87/07/11 07:55:40 mike Locked $";
@


6.1
log
@Release 2.0
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 5.1 87/06/24 22:11:18 mike Rel $";
d68 4
a71 5
	/* In case everything is a halfspace, set a minimum space */
	VSETALL( rtip->mdl_min, -0.1 );
	VSETALL( rtip->mdl_max,  0.1 );
	VMOVE( rtip->rti_inf_box.bn.bn_min, rtip->mdl_min );
	VMOVE( rtip->rti_inf_box.bn.bn_max, rtip->mdl_max );
@


5.1
log
@Release 1.24
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 4.5 87/03/23 23:42:13 mike Exp $";
@


4.5
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 4.4 87/03/11 01:32:10 mike Exp $";
@


4.4
log
@Eliminated rt_i references, added
rt_pr_dir() routine for debugging.
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 4.3 87/02/12 22:11:09 mike Exp $";
a57 2
	 *
	 *  (Here we will allocate an rt_i struct, someday)
d59 1
a59 1
	rtip = &rt_i;		/* XXX malloc() this on a per-db basis */
d63 1
a63 1
		return(RTI_NULL);
d113 1
a113 1
			rt_dir_add( record.a.a_name, addr );
d118 1
a118 1
			rt_dir_add( record.s.s_name, addr );
d141 1
a141 1
				rt_dir_add( record.p.p_name, addr );
d145 1
a145 1
			rt_dir_add( record.B.B_name, addr );
d152 1
a152 1
				rt_dir_add( record.p.p_name, addr );
d163 1
a163 1
			rt_dir_add( record.c.c_name, addr );
d187 1
a187 1
	    	return( RTI_NULL );	/* FAIL */
d191 5
a195 1
	return( rtip );	/* OK */
d210 3
a212 2
rt_dir_lookup( str, noisy )
register char *str;
d216 3
a218 1
	for( dp = rt_i.rti_DirHead; dp != DIR_NULL; dp=dp->d_forw )  {
d238 4
a241 3
rt_dir_add( name, laddr )
register char *name;
long laddr;
d248 4
a251 1
	if(rt_g.debug&DEBUG_DB)rt_log("rt_dir_add(%s,x%x)\n", local, laddr);
d255 2
a256 2
	dp->d_forw = rt_i.rti_DirHead;
	rt_i.rti_DirHead = dp;
d268 3
a270 1
	rt_log("Dump of directory for rtip x%x\n", rtip);
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 4.2 87/01/17 01:47:35 mike Exp $";
d51 1
d61 3
a63 2
	bzero( (char *)&rt_i, sizeof(rt_i) );
	if( (rt_i.fp = fopen(filename, "r")) == NULL )  {
d67 2
a68 2
	rt_i.needprep = 1;
	rt_i.file = rt_strdup( filename );
d71 5
a75 5
	VSETALL( rt_i.mdl_min, -0.1 );
	VSETALL( rt_i.mdl_max,  0.1 );
	VMOVE( rt_i.rti_inf_box.bn.bn_min, rt_i.mdl_min );
	VMOVE( rt_i.rti_inf_box.bn.bn_max, rt_i.mdl_max );
	rt_i.rti_inf_box.bn.bn_type = CUT_BOXNODE;
d80 2
a81 2
	rewind( rt_i.fp );
	if( fread( (char *)&record, sizeof record, 1, rt_i.fp ) != 1  ||
d86 1
a86 1
	rewind( rt_i.fp );
d93 1
a93 1
		if( (addr = ftell(rt_i.fp)) == EOF )
d96 2
a97 2
		if( fread( (char *)&record, sizeof record, 1, rt_i.fp ) != 1
		    || feof(rt_i.fp) )
d133 1
a133 1
					here = ftell( rt_i.fp );
d135 1
a135 1
					    rt_i.fp ) != 1 )
d138 1
a138 1
						fseek( rt_i.fp, here, 0 );
d159 1
a159 1
					fread( (char *)&rec, sizeof(rec), 1, rt_i.fp );
d174 1
a174 1
	rewind( rt_i.fp );
d181 1
a181 1
	if( (rt_i.rti_db = (union record *)rt_malloc(
d185 3
a187 3
	rewind(rt_i.fp);
	if( fread( (char *)rt_i.rti_db, sizeof(union record), addr,
	    rt_i.fp) != addr )  {
d193 1
a193 2
	/* Eventually, we will malloc() this on a per-db basis */
	return( &rt_i );	/* OK */
d249 15
@


4.2
log
@Changed minimum space
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 4.1 86/12/29 03:45:03 mike Locked $";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 3.11 86/12/19 04:17:17 mike Exp $";
d69 2
a70 2
	VSETALL( rt_i.mdl_min, -10 );
	VSETALL( rt_i.mdl_max,  10 );
@


3.11
log
@Added DB_MEM code, to read whole database into memory,
rather than doing random access I/O to the disk file.
On UNIX, this gives a 10% speedup at the cost of much memory.
On COS, this makes useful operation possible.
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 3.10 86/08/13 18:12:20 mike Exp $";
@


3.10
log
@Sysv says rewind() returns VOID.
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 3.9 86/08/12 04:15:31 mike Exp $";
d86 1
d88 3
d93 1
d149 1
d151 3
d155 3
a157 5
				j = (record.d.d_nknots + record.d.d_nctls) *
					sizeof(union record);
				/****** NON-PORTABLE ******/
				fseek( rt_i.fp, j, 1 );
				rt_dir_add( record.p.p_name, addr );
d173 17
@


3.9
log
@Changed #include directives for use with CC -I convention
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 3.8 86/08/08 05:05:43 mike Exp $";
d78 1
a78 2
	if(rewind( rt_i.fp )==EOF)
		rt_log("rt_dirbuild: rewind() failure 1\n");
d84 1
a84 2
	if(rewind( rt_i.fp )==EOF)
		rt_log("rt_dirbuild: rewind() failure 2\n");
d165 2
a166 2
	if(rewind( rt_i.fp )==EOF)
		rt_log("rt_dirbuild: rewind() failure\n");
@


3.8
log
@Changed to properly register database names of NAMESIZE len.
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 3.7 86/08/06 19:54:04 mike Exp $";
d28 5
a32 5
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/db.h"
#include "../h/raytrace.h"
#include "debug.h"
@


3.7
log
@Improved error checking, used rewind() where possible.
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 3.6 86/07/31 02:50:43 mike Exp $";
d76 7
a82 3
	(void)fread( (char *)&record, sizeof record, 1, rt_i.fp );
	if( record.u_id != ID_IDENT )  {
		rt_log("WARNING:  File is not a proper GED database\n");
d86 2
a87 1
		rt_log("rt_dirbuild: rewind() failure\n");
d215 1
d217 3
d221 1
a221 1
	dp->d_namep = rt_strdup( name );
@


3.6
log
@Improved rt_dirbuild to have central switch statement for
record type.
Only one non-portable instance of fseek() usage left.
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 3.5 86/07/24 06:09:15 mike Exp $";
a75 1
	addr = ftell(rt_i.fp);
d81 2
a82 1
	(void)fseek( rt_i.fp, addr, 0 );
d84 2
a85 1
		addr = ftell(rt_i.fp);
d90 3
d162 2
@


3.5
log
@Started using VSETALL
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 3.4 86/07/19 04:41:12 mike Exp $";
d89 2
a90 1
		if( record.u_id == ID_IDENT )  {
d98 1
a98 2
		}
		if( record.u_id == ID_FREE )  {
d100 1
a100 2
		}
		if( record.u_id == ID_ARS_A )  {
a101 6

			/* Skip remaining B type records.	*/
			(void)fseek( rt_i.fp,
				(long)(record.a.a_totlen) *
				(long)(sizeof record),
				1 );
d103 3
a105 3
		}

		if( record.u_id == ID_SOLID )  {
d108 1
a108 2
		}
		if( record.u_id == ID_MATERIAL )  {
d111 4
a114 4
		}
		if( record.u_id == ID_P_HEAD )  {
			union record rec;
			register int nrec;
d116 12
a127 10
			nrec = 1;
			while(1) {
				register int here;
				here = ftell( rt_i.fp );
				if( fread( (char *)&rec, sizeof(rec), 1,
				    rt_i.fp ) != 1 )
					break;
				if( rec.u_id != ID_P_DATA )  {
					fseek( rt_i.fp, here, 0 );
					break;
d129 2
a130 1
				nrec++;
d132 1
a132 4
			rt_dir_add( record.p.p_name, addr );
			continue;
		}
		if( record.u_id == ID_BSOLID )  {
d135 12
a146 8
		}
		if( record.u_id == ID_BSURF )  {
			register int j;
			/* Just skip over knots and control mesh */
			j = (record.d.d_nknots + record.d.d_nctls) *
				sizeof(union record);
			fseek( rt_i.fp, j, 1 );
			rt_dir_add( record.p.p_name, addr );
d148 6
a153 4
		}
		if( record.u_id != ID_COMB )  {
			rt_log("rt_dirbuild:  unknown record %c (0%o)\n",
				record.u_id, record.u_id );
a156 6

		rt_dir_add( record.c.c_name, addr );
		/* Skip over member records */
		(void)fseek( rt_i.fp,
			(long)record.c.c_length * (long)sizeof record,
			1 );
@


3.4
log
@Removed rtdir.h
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 3.3 86/07/17 18:19:43 mike Exp $";
d69 2
a70 2
	VSET( rt_i.mdl_min, -10, -10, -10 );
	VSET( rt_i.mdl_max,  10,  10,  10 );
@


3.3
log
@Upgraded to read the database using stdio.
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 3.2 86/07/11 01:31:56 mike Exp $";
a31 1
#include "rtdir.h"
a33 2
static struct directory *DirHead = DIR_NULL;	/* rt_i, eventually */

d42 2
a43 2
 *	0	Success
 *	-1	Fatal Error
d45 1
a45 1
int
d52 1
a52 1
	static long	addr;
d54 6
d63 1
a63 1
		return(-1);
d67 8
a75 1

d166 2
a167 1
	return(0);	/* OK */
d187 1
a187 1
	for( dp = DirHead; dp != DIR_NULL; dp=dp->d_forw )  {
d216 2
a217 2
	dp->d_forw = DirHead;
	DirHead = dp;
@


3.2
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d24 1
a24 1
static char RCSdir[] = "@@(#)$Header: dir.c,v 3.1 86/06/11 00:34:16 mike Exp $";
d58 1
a58 1
	if( (rt_i.fd = open(filename, 0)) < 0 )  {
d66 2
a67 2
	(void)lseek( rt_i.fd, 0L, 0 );
	(void)read( rt_i.fd, (char *)&record, sizeof record );
d72 1
a72 1
	(void)lseek( rt_i.fd, 0L, 0 );
d74 3
a76 3
		addr = lseek( rt_i.fd, 0L, 1 );
		if( (unsigned)read( rt_i.fd, (char *)&record, sizeof record )
				!= sizeof record )
d95 1
a95 1
			(void)lseek( rt_i.fd,
d113 1
a113 1
			register int j;
d116 4
a119 2
				j = read( rt_i.fd, (char *)&rec, sizeof(rec) );
				if( j != sizeof(rec) )
d122 1
a122 1
					lseek( rt_i.fd, -(sizeof(rec)), 1 );
d139 1
a139 1
			lseek( rt_i.fd, j, 1 );
d152 1
a152 1
		(void)lseek( rt_i.fd,
@


3.1
log
@Support for new object-oriented material-property code.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: dir.c,v 3.0 86/06/10 01:33:00 mike Exp $";
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.4 86/06/09 21:50:20 mike Exp $";
d107 1
a107 1
			color_addrec( &record, addr );
@


2.4
log
@rt and librt separated
@
text
@d7 3
a9 4
 *	dir_build	Read GED database, build directory
 *	dir_lookup	Look up name in directory
 *	dir_add		Add entry to directory
 *	strdup		Duplicate string
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.3 86/03/14 21:07:47 mike Exp $";
d35 1
a35 1
static struct directory *DirHead = DIR_NULL;
a36 3
int	ged_fd = -1;		/* FD of object file */
extern char *malloc();

d38 1
a38 1
 *			D I R _ B U I L D
d49 1
a49 1
dir_build(filename, buf, len)
d57 2
a58 1
	if( (ged_fd = open(filename, 0)) < 0 )  {
d62 2
d66 2
a67 2
	(void)lseek( ged_fd, 0L, 0 );
	(void)read( ged_fd, (char *)&record, sizeof record );
d69 2
a70 2
		rtlog("WARNING:  File is not a proper GED database\n");
		rtlog("This database should be converted before further use.\n");
d72 1
a72 1
	(void)lseek( ged_fd, 0L, 0 );
d74 2
a75 2
		addr = lseek( ged_fd, 0L, 1 );
		if( (unsigned)read( ged_fd, (char *)&record, sizeof record )
d81 1
a81 1
				rtlog("WARNING: File is Version %s, Program is version %s\n",
d92 1
a92 1
			dir_add( record.a.a_name, addr );
d95 1
a95 1
			(void)lseek( ged_fd,
d103 1
a103 1
			dir_add( record.s.s_name, addr );
d116 1
a116 1
				j = read( ged_fd, (char *)&rec, sizeof(rec) );
d120 1
a120 1
					lseek( ged_fd, -(sizeof(rec)), 1 );
d125 1
a125 1
			dir_add( record.p.p_name, addr );
d129 1
a129 1
			dir_add( record.B.B_name, addr );
d137 2
a138 2
			lseek( ged_fd, j, 1 );
			dir_add( record.p.p_name, addr );
d142 1
a142 1
			rtlog("dir_build:  unknown record %c (0%o)\n",
d148 1
a148 1
		dir_add( record.c.c_name, addr );
d150 1
a150 1
		(void)lseek( ged_fd,
d158 1
a158 1
 *			D I R _ L O O K U P
d169 1
a169 1
dir_lookup( str, noisy )
d184 1
a184 1
		rtlog("dir_lookup:  could not find '%s'\n", str );
d189 1
a189 1
 *			D I R _ A D D
d194 1
a194 1
dir_add( name, laddr )
d201 1
a201 1
	dp->d_namep = strdup( name );
a205 23
}

/*
 *			S T R D U P
 *
 * Given a string, allocate enough memory to hold it using malloc(),
 * duplicate the strings, returns a pointer to the new string.
 */
char *strdup( cp )
register char *cp;
{
	register char	*base;
	register char	*current;

	if( (base = malloc( strlen(cp)+1 )) == (char *)0 )
		rtbomb("strdup:  unable to allocate memory");

	current = base;
	do  {
		*current++ = *cp;
	}  while( *cp++ != '\0' );

	return(base);
@


2.3
log
@Changed for new spline format.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.2 85/09/24 18:33:42 mike Exp $";
d32 1
a32 1
#include "raytrace.h"
@


2.2
log
@Changed calling sequence to dir_build() to have pointer and length
of buffer to hold database ID string, rather than just printing
it.  Also changed all fprintf calls to rtlog() calls.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.1 85/08/31 06:04:04 mike Exp $";
d126 13
@


2.1
log
@Version 2 of RT
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.13 85/07/30 05:52:27 mike Exp $";
a40 10
static char *units_str[] = {
	"none",
	"mm",
	"cm",
	"meters",
	"inches",
	"feet",
	"extra"
};

d53 1
a53 1
dir_build(filename, noisy)
d55 2
a56 1
int noisy;
d65 1
d70 2
a71 2
		(void)fprintf(stderr,"Warning:  File is not a proper GED database\n");
		(void)fprintf(stderr,"This database should be converted before further use.\n");
d82 1
a82 1
				(void)fprintf(stderr,"File is Version %s, Program is version %s\n",
d85 2
a86 4
			if(noisy)
				(void)fprintf(stderr,"%s (units=%s)\n",
					record.i.i_title,
					units_str[record.i.i_units] );
d130 1
a130 1
			(void)fprintf(stderr, "dir_build:  unknown record %c (0%o)\n",
d172 1
a172 1
		fprintf(stderr, "dir_lookup:  could not find '%s'\n", str );
@


1.13
log
@Revised for joint GED/RT vmath.h;  some storage cleanups.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.12 85/07/30 02:00:55 mike Exp $";
d173 5
a177 1
		if ( strcmp( str, dp->d_namep ) == 0 )
@


1.12
log
@Added "noisy" arg to dir_build() to control printout.
per Moss.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.11 85/06/05 00:25:10 mike Exp $";
d29 2
a30 1
#include "vmath.h"
@


1.11
log
@Header file added for GETSTRUCT.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.10 85/03/25 17:45:12 mike Exp $";
d62 1
a62 1
dir_build(filename)
d64 1
d92 4
a95 3
			(void)fprintf(stderr,"%s (units=%s)\n",
				record.i.i_title,
				units_str[record.i.i_units] );
@


1.10
log
@Added support for material codes.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.9 85/03/25 11:45:24 mike Exp $";
d31 1
@


1.9
log
@Housekeeping
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.8 85/02/07 19:19:23 mike Exp $";
d111 4
@


1.8
log
@changed return codes from get_tree()
@
text
@d6 7
a12 1
 * Author -
d14 9
a22 5
 *
 *	U. S. Army Ballistic Research Laboratory
 *	April 2, 1984
 *
 * $Revision: 1.7 $
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.7 85/02/01 14:45:34 mike Exp $";
d30 1
a30 1
#include "db.h"
d175 1
a175 1
 *			D I R A D D
@


1.7
log
@Less harsh treatment of version mismatch
@
text
@d12 1
a12 1
 * $Revision: 1.6 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.6 84/11/23 20:54:02 mike Exp $";
d45 4
d50 1
a50 1
void
d59 1
a59 1
		rtbomb("Unable to continue");
d134 1
@


1.6
log
@Added LOCAL, fastf_t declarations.
Made shootray() recursive.
@
text
@d12 1
a12 1
 * $Revision: 1.5 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.5 84/11/20 21:00:03 mike Exp $";
a74 1
				rtbomb("Version mismatch");
@


1.5
log
@errors to stderr
@
text
@d12 1
a12 1
 * $Revision: 1.4 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.4 84/11/20 20:14:20 mike Exp $";
d29 10
d42 1
a42 1
 * This routine reads through the GED database and
d58 7
d67 1
a67 1
		if( read( ged_fd, (char *)&record, sizeof record )
d71 16
a86 6
		/*
		 * Check for a deleted record
		 */
		if( record.u_id == ARS_A )  {
			if( record.a.a_name[0] != '\0' )
				dir_add( record.a.a_name, addr );
d89 4
a92 4
			(void)lseek(	ged_fd,
					(long)(record.a.a_totlen) *
					(long)(sizeof record),
					1 );
d96 2
a97 3
		if( record.u_id == SOLID )  {
			if( record.s.s_name[0] != '\0' )
				dir_add( record.s.s_name, addr );
d100 20
a119 2
		if( record.u_id != COMB )  {
			fprintf(stderr, "dir_build:  unknown record %c (0%o)\n",
d125 2
a126 5
		/* Check for a deleted combination record */
		if( record.c.c_name[0] != '\0' )
			dir_add( record.c.c_name, addr );

		/* Skip over combination member records */
@


1.4
log
@General cleanup
@
text
@d12 1
a12 1
 * $Revision: 1.3 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.3 84/11/16 06:28:13 mike Exp $";
d75 1
a75 1
			(void)printf( "dir_build:  unknown record %c (0%o)\n",
d115 1
a115 1
		(void)printf("dir_lookup:  could not find '%s'\n", str );
@


1.3
log
@header file shuffle
@
text
@d12 1
a12 1
 * $Revision: 1.2 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.2 84/10/19 01:38:10 mike Exp $";
d18 1
a23 2
extern char	*malloc();

d26 2
a27 1
int	ged_fd;		/* FD of object file */
d45 1
a45 1
		bomb("Unable to continue");
d50 1
a50 1
		if( (unsigned)read( ged_fd, (char *)&record, sizeof record )
d152 1
a152 1
		bomb("strdup:  unable to allocate memory");
@


1.2
log
@Lint corrections
@
text
@d12 1
a12 1
 * $Revision: 1.1 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.1 84/04/18 02:19:58 mike Exp $";
d20 1
a20 1
#include "dir.h"
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
 * $Revision$
d15 1
a15 1
static char RCSid[] = "@@(#)$Header$";
a39 1
	register struct directory *dp;
@
